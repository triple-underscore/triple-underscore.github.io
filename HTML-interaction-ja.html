<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — User interaction（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'editing',
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		p: 'property',
		st: 'attr-state',
		aH: 'attr-state',
		css: 'css',
		v: 'value',
		E: 'error',
		h: 'header',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		st: 'span',
		aH: 'span',
		h: 'code',
		p: 'code',
		css: 'code',
		samp: 'samp',
		v: 'code',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'a': // attr
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'h': // http header
	text = '<code class="header">' + text + '</code>';
	break;
case 'v': // attr value
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-03-02
trans_update:2018-03-02
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/interaction.html
site_nav:uievents,html
nav_prev:HTMLselectors
nav_next:HTMLdnd
trans_1st_pub:2016-11-06


●●original_id_map


dom-document-designmode:designMode


●●link_map


E.SyntaxError:~WEBIDL#syntaxerror

I.Document:~HTMLdom#document
I.ElementContentEditable:#elementcontenteditable
I.Element:~DOM4#interface-element
I.FocusEvent:~UIEVENTS#focusevent
I.Node:~DOM4#interface-node
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window
I.Selection:https://w3c.github.io/selection-api/#idl-def-Selection
I.FocusOptions:#focusoptions

CEReactions:~HEcustom#cereactions


	■DOM
m.isTrusted:~DOM4#dom-event-istrusted
m.bubbles:~DOM4#dom-event-bubbles
m.type:~DOM4#dom-event-type
m.accessKey:#dom-accesskey
m.accessKeyLabel:#dom-accesskeylabel
m.activeElement:#dom-document-activeelement
m.autocapitalize:#dom-autocapitalize
m.~blur0:#dom-blur
m.blur:#dom-window-blur
m.~focus0:#dom-focus
m.focus:#dom-window-focus
m.click:#dom-click
m.contentEditable:#dom-contenteditable
m.hasFocus:#dom-document-hasfocus
m.hidden:#dom-hidden
m.isContentEditable:#dom-iscontenteditable
m.inputMode:#dom-inputmode
m.preventScroll:#dom-focusoptions-preventscroll

	m.execCommand:#execCommand
m.execCommand:~EXEC-COMMAND#execcommand%28%29
m.queryCommandEnabled:~EXEC-COMMAND#dom-document-querycommandenabled%28%29
m.queryCommandIndeterm:~EXEC-COMMAND#dom-document-querycommandindeterm%28%29
m.queryCommandState:~EXEC-COMMAND#dom-document-querycommandstate%28%29
m.queryCommandSupported:~EXEC-COMMAND#dom-document-querycommandsupported%28%29
m.queryCommandValue:~EXEC-COMMAND#dom-document-querycommandvalue%28%29

m.spellcheck:#dom-spellcheck
m.tabIndex:#dom-tabindex

m.relatedTarget:~UIEVENTS#dom-focusevent-relatedtarget
m.detail:~UIEVENTS#dom-uievent-detail
m.view:~UIEVENTS#dom-uievent-view
m.showModal:~HEinteractive#dom-dialog-showmodal
m.designMode:#dom-document-designmode
~designMode:#designMode

	■css
p.outline:~CSSUI#outline
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.white-space:~CSSTEXT#white-space-property

	■e
e.a:~HEtextlevel#the-a-element

e.area:~HEimages#the-area-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element

e.body:~HEsections#the-body-element

e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.form:~HEforms#the-form-element
e.label:~HEforms#the-label-element
e.output:~HEforms#the-output-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.summary:~HEinteractive#the-summary-element

e.div:~HEgrouping#the-div-element
e.link:~HEmetadata#the-link-element
e.object:~HEembed#the-object-element
e.video:~HEmedia#the-video-element

	■#attr-
a.autocapitalize:#attr-autocapitalize
a.contenteditable:#attr-contenteditable
a.inputmode:#attr-inputmode
a.form:~HTMLforms#attr-fae-form
a.href:~HTMLlinks#attr-hyperlink-href
a.~href0:~HEmetadata#attr-link-href
a.open:~HEinteractive#attr-dialog-open
a.pattern:~HEinput#attr-input-pattern
a.readonly:~HEinput#attr-input-readonly
a.~readonly0:~HEforms#attr-textarea-readonly
a.spellcheck:#attr-spellcheck
a.src:~HEimages#attr-img-src
a.tabindex:#attr-tabindex
a.title:~HTMLdom#attr-title
a.type:~HEinput#attr-input-type

a.accesskey:#the-accesskey-attribute
a.hidden:#the-hidden-attribute
a.aria-describedby:~ARIA1#aria-describedby

a.draggable:~HTMLdnd#the-draggable-attribute

v.none:#attr-inputmode-keyword-none
v.text:#attr-inputmode-keyword-text
v.tel:#attr-inputmode-keyword-tel
v.url:#attr-inputmode-keyword-url
v.email:#attr-inputmode-keyword-email
v.numeric:#attr-inputmode-keyword-numeric
v.decimal:#attr-inputmode-keyword-decimal
v.search:#attr-inputmode-keyword-search

v.off:#attr-autocapitalize-off
v.~noneC:#attr-autocapitalize-none
v.on:#attr-autocapitalize-on
v.sentences:#attr-autocapitalize-sentences
v.words:#attr-autocapitalize-words
v.characters:#attr-autocapitalize-characters

	■event
et.blur:~HTMLindex#event-blur
et.change:~HTMLindex#event-change
et.focus:~HTMLindex#event-focus
et.reset:~HTMLindex#event-reset
et.submit:~HTMLindex#event-submit
et.click:~UIEVENTS#event-type-click
et.dblclick:~UIEVENTS#event-type-dblclick
et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseup:~UIEVENTS#event-type-mouseup
et.mousemove:~UIEVENTS#event-type-mousemove
et.mouseover:~UIEVENTS#event-type-mouseover
et.pointerup:~POINTEREVENTS#the-pointerup-event
et.touchend:~TOUCHEVENTS#event-touchend

st.Email:~HEinput#e-mail-state-(type=email)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Number:~HEinput#number-state-(type=number)
st.Password:~HEinput#password-state-(type=password)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Url:~HEinput#url-state-(type=url)

aH.既定:#autocap-hint-default
aH.なし:#autocap-hint-none
aH.一文ごと:#autocap-hint-sentences
aH.単語ごと:#autocap-hint-words
aH.文字ごと:#autocap-hint-characters


cF.動作:~HEinteractive#command-facet-action
cF.不能化~状態:~HEinteractive#command-facet-disabledstate
cF.隠され状態:~HEinteractive#command-facet-hiddenstate

	■
文書:~HTMLdom#the-document-object
要素:#_element
~tabindex値:#_focusable-area-tabindex-value


利用者の作動化により誘発され:#triggered-by-user-activation
割当されている~access~key:#assigned-access-key
~modal~dialogにより阻まれ:#blocked-by-a-modal-dialog

~control群:#control-group
~focus可能~域~順序:#_control-group-order

~home~control群:#home-control-group
首~control群:#primary-control-group
所有者~obj:#control-group-owner-object
所有者:#control-group-owner-object
	~control群~所有者~obj:#control-group-owner-object

既定の被focus~dialog:#_default-dialog-in-a-dialog-group
~dialog群:#dialog-group
管理者:#dialog-group-manager
指名する被focus~dialog:#focused-dialog-of-the-dialog-group

編集-可能:~EXEC-COMMAND#editable
編集中の~host:~EXEC-COMMAND#editing-host
属する編集中の~host:~EXEC-COMMAND#editing-host-of
作動範囲:~EXEC-COMMAND#active-range
選択を削除-:~EXEC-COMMAND#delete-the-selection

	＊作動範囲:#active-range


明に不活:#expressly-inert
	dlg.明に不活:#expressly-inert-dialog

~task:~WAPI#concept-task
~queueされ:~WAPI#queue-a-task
~click~eventを発火-:~WAPI#fire-a-click-event
~click~eventを発火する:~WAPI#fire-a-click-event
~focus~eventを発火する:#fire-a-focus-event
合成~mouse~eventを発火する:~WAPI#fire-a-synthetic-mouse-event

~click進捗中~flag:#click-in-progress-flag

~DOM~anchor:#dom-anchor
~focus鎖:#focus-chain
~focusを獲得した:#gains-focus
~focusを得ている:#has-focus-steps
~focusされて:#focused

~focus可能~域:#focusable-area
~focus可能な図形:#_focusable-shape

~top-level閲覧文脈の現在の被focus域:#currently-focused-area-of-a-top-level-browsing-context
現在の被focus域:#currently-focused-area-of-a-top-level-browsing-context
	指名-:#focused-area-of-the-control-group
指名する被focus域:#focused-area-of-the-control-group
	~control群の被focus域:#focused-area-of-the-control-group
	~that~focus群の被focus域:#focused-area-of-the-control-group
相応しい逐次的~focus可能~域:#suitable-sequentially-focusable-area

~focusを更新する:#focus-update-steps
~objを~unfocusする:#unfocusing-steps
~objを~focusする:#focusing-steps

	:#bc-focus-ergo-bcc-focus

~home逐次的~focus~navi順序:#home-sequential-focus-navigation-order
~focus~lock~flag:#locked-for-focus
逐次的~focus~navi順序:#sequential-focus-navigation-order
逐次的~focus~naviの始点:#sequential-focus-navigation-starting-point
始点:#sequential-focus-navigation-starting-point
逐次的~focus~navi:#sequential-focus-navigation
~tabindex~focus~flag:#specially-focusable
~focus修復~規則 1:#focus-fixup-rule-one
~focus修復~規則 3:#focus-fixup-rule-three
~focus修復~規則 2:#focus-fixup-rule-two

	適切になるなら:#concept-platform-dropeffect-override
	concept-platform-dropeffect-override-

不活:#inert
不活ness:#inert-
既定の挙動:#concept-spellcheck-default
既定で継承する:#concept-spellcheck-default-inherit
既定で行う:#concept-spellcheck-default-true
既定で行わない:#concept-spellcheck-default-false

逐次的~navi探索~algo:#sequential-navigation-search-algorithm
~source~node:#source-node


自動頭字化~hint:#autocapitalization-hint
自前の自動頭字化~hint:#own-autocapitalization-hint
使用~自動頭字化~hint:#used-autocapitalization-hint
自動頭字化-を継承-:~HEforms#category-autocapitalize


	●DOM/CSS
表示域:~CSS2VISUREN#viewport
~box木~順序:#_box-tree-order
~box木:~CSSDISP#css-box-tree
~viewの中へ~scrollする:~CSSOMVIEW#scroll-an-element-into-view

~node文書:~DOM4#concept-node-document
木~順序:~DOM4#concept-tree-order
文書~内にある:~DOM4#in-a-document
文書~要素:~DOM4#document-element
配送-:~DOM4#concept-event-dispatch
発火-:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior
接続されて:~DOM4#connected
~shadowも含む子孫:~DOM4#concept-shadow-including-descendant
~composed~flag:~DOM4#composed-flag

	●HTML
閲覧文脈~容器:~BROWSERS#browsing-context-container
入子にしている閲覧文脈~容器:~BROWSERS#browsing-context-nested-through
閲覧文脈:~BROWSERS#browsing-context
ある閲覧文脈に属する:~BROWSERS#concept-document-bc
属する閲覧文脈:~BROWSERS#concept-document-bc
子~閲覧文脈:~BROWSERS#child-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
入子にして:~BROWSERS#nested-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
作動中の文書:~BROWSERS#active-document

~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白:~INFRA#ascii-whitespace
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace

~HTML要素:~HTMLINFRA#html-elements
大小区別:~HTMLINFRA#case-sensitive
即時に:~HTMLINFRA#immediately
~live:~HTMLINFRA#live
反映-:~HTMLcdom#reflect
既知の値のみに制限され:~HTMLcdom#limited-to-only-known-values

列挙ed属性:~HTMLcms#enumerated-attribute
真偽~属性:~HTMLcms#boolean-attribute
妥当でない値~用の既定:~HTMLcms#invalid-value-default
値なし用の既定:~HTMLcms#missing-value-default
整数として構文解析する:~HTMLcms#rules-for-parsing-integers
一意な~tokenからなる空白区切りの有順序~集合:~HTMLcms#ordered-set-of-unique-space-separated-tokens
妥当な整数:~HTMLcms#valid-integer

不能化され:~HTMLforms#concept-fe-disabled
変異-可能:~HTMLforms#concept-fe-mutable
fe.値:~HTMLforms#concept-fe-value
~form所有者:~HTMLforms#form-owner

選択-中の~fileの~list:~HEinput#concept-input-type-file-selected
	~HEtextlevel#the-a-element
	~HEinput#number-state-(type=number)
	~HEinput#range-state-(type=range)
	~HEinput#text-(type=text)-state-and-search-state-(type=search)
	適用される:~HEinput#concept-input-apply

~commandを定義する:~HEinteractive#concept-command
~modal~dialogが示され:~HEinteractive#dom-dialog-showmodal
	公開することもある:~HEinteractive#expose-commands-in-ui

	関連する~canvas~fallback内容として利用中にある:~HEcanvas#being-used-as-relevant-canvas-fallback-content

不能化-:~HTMLselectors#concept-element-disabled

~UIにより利用者に公開されている~control:~HEmedia#expose-a-user-interface-to-the-user

~body要素:~HTMLdom#the-body-element-2
対話的~内容:~HTMLdom#interactive-content-2

具現化され:~HTMLrendering#being-rendered
具現化されて:~HTMLrendering#being-rendered
	具現化~節にて示唆されている規則:~HTMLrendering#hiddenCSS
~hyperlink:~HTMLlinks#hyperlink
画像~map:~HEimages#image-map

上端層:~FULLSCREEN#top-layer
~URL:~URL1#concept-url

●●words_table1


EXEC-COMMAND:https://w3c.github.io/editing/execCommand.html
POINTEREVENTS:pointerevents-ja.html
TOUCHEVENTS:touch-events-ja.html


href0:href
readonly0:readonly
blur0:blur
focus0:focus
noneC:none

●●words_table


	●仕様
model::::モデル
platform::::プラットフォーム
system::::システム
UA:
Web:
algo:algorithm:::アルゴリズム
app:application:::アプリ
browser::::ブラウザ
一般:general:~
事例:case:~
	可能:possible
理由:reason:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
代替:alternative:~
共通的に:common に:よく
効果:effect:~
可用:available:~
問題:problem:~
実際:actual:~
局面:scenario:~
序論:introduction:~
情報:information:~
意味論:semantics:~
手動:manual:~
	基に／基になる情報:guide:~
手段:means:~
手続き:steps:~
下位手続き:substeps:~
段:step:~
方式:manner:~
既定:default:~:::デフォルト
既定の:default:~:::デフォルト
明示的:explicit:~
最善:best:~
有用:useful:~
本質的:essential:~
概して:typical に:~
正確:exact:~
歴史的:historical:~
特色機能:feature:~
用語:term:~
目的:purpose:~
相応しい:suitable:~
素早く:quick:~
規則:rule:~
	-:non-normative
規約:convention:~
通例的に:usual に:~
適切:appropriate:~
直接的:direct:~
間接的:indirect:~
敵対的:hostile:~
参考情報:advisory information:~
美観:aesthetics:~
正当:legitimate:~
不正:incorrect:~
正しく:correct に:~
略式的:skeletal:~
文脈的な:contextual::~
判定基準:criteria:~
機能性:functionality:~
状況下:circumstance:~
能:ability:~
余地:option:~
	おそらく:probably
	きれいに:neatly
	きわどい:corner
	それに代わる:in its stead
	ないがしろに:detriment
	に過ぎない:merely
	も:opt to
	任意選択
	何らかの方法:somehow
	何らかの類の:some sort of
	弱視者:reduced vision:~
	目障り:unsightly:~
	無思慮:unwise:~
	普及している:prevalent:
	〜の違いを除いて:Modulo
	申し分ない:fine
	賢明とは言えない:unwise:~
	馴染んでいる:familiar な:~
	全面的に:entirely
	具体的には:for instance
	可能性が高い:likely
	多様な:wide variety of
	広範:wide:~
	様々な:variety
	等々:and so forth
	通常は:normally
	必要とされ:necessary
	しかしながら，:however
	したがって:therefore
	したがって:thus
	とりわけ:especially
	べき:should
	例:example
	-:in fact
	それに伴い:thereby

	●仕様（動詞
support::::サポート
custom::::カスタム
	custom化:customizable
上書き:override:~
作者:author:~
依存-:depend:~
保護-:protect:~
処理-:process:~
処理:processing:~
利用-:use:~
利用者:user:~
制約:restriction:~
取扱わせ:handle させ:取り扱わせ
取扱い:handling:取り扱い
呼出され:invoke され:呼び出され
呼出せる:invoke できる:呼び出せる
呼出して:invoke して:呼び出して
奨励-:encourage:~
	〜しないことが奨励:discourage
定義-:define:~
定義:definition:~
実施:practice:~
実行-:execute:~
実装-:implement:~
	-:future:~
導出-:derive:~
強制-:force:~
影響-:affect:~
意味-:mean:~
	-:abstract concept
指定-:specify:~
	指定されていない:unspecified
指示-:indicate:~
挙動:behavior:ふるまい
供-:provide:~
供せ:provide でき:~
提供-:offer:~
含意-:imply:~
期待-:expect:~
決定-:determine:~
決定:determination:~
	惑わす:confusion:~
濫用-:abuse:~
	ある:particular
特有の:specific な:~
特定の:specific:~
確保-:ensure:~
確立-:establish:~
示唆-:suggest:~
結付けら:associate さ:結び付けら
	考える:consider
要件:requirements:~
要求-:require:~
要請-:request:~
見出-:find:~
解釈-:interpret:~
記述-:describe:~
記述:description:~
述べる:describe する:~
述べた:describe した:~
	できるようにする:allow
試行-:try:~
遂行-:perform:~
適用-:apply:~
	適用-可能:applicable
遵守-:honour:~
選好-:prefer:~
選好:preference:~
関係する:related:~
関心:interest:~
関連する:relevant な:~
関連しな:relevant でな:~
防止-:prevent:~
	できなく:prevent:~
編集者:editor:~
列挙ed:enumerated:列挙
想定-:suppose:~
受容-可能:accept:~
	受容-可能:acceptable
開発者:developer:~
失った:lose した:~
働かな:work しな:~
選択的:selective:~
最適化-:optimize:~
制限-:limit:~
依拠-:rely:~
制御:control:~
推奨-:recommend:~
望む:wish する:~
考慮点:considerations:~
支援-:assist:~
介入-:intervene:~

	易くする:help
	概ね、:roughly speaking
	正当化される:well justify
	要因:a factor that contributes towards
	見込んで:believe して:~
	則る:according
	加えて:additionally
	周知の:commonly known
	呼応:in response to
	織り込む:take into account
	かかわらず:regardless
	~~説明:Description
	できる:capable of
	助けになる:helpful:~
	注意:note
	満たす:meet

	●focus／dialog
	逐次的~focus~navi順序
	~focus~navi序列
blur:
focus::::フォーカス
	~focus可能:focusable
被focus:focused::被 focus:被フォーカス
unfocus::::未フォーカスに
	~unfocus時の:unfocusing
	~focus時の:focusing

域:area::~
指名-:designate::~
標的:target::~
届けら:route さ::~
届ける:route する::~
	経由-:channeled:

獲得した:gain した::得た
獲得しよ:gain しよ::得よう

tabindex:
図形:shape::~
control::::コントロール
dialog::::ダイアログ
修復:fixup::~
	~focus修復:focus-fixup
到達-:reach:~
	到達-不能:unreachable
	到達-可能:reachable

前方:forward::~
後方:backward::~

阻まれ:block され::~::ブロックされ

群:group::~::グループ
不活:inert::~
	inertness::::

不能化-:disable::~
不能化:disabled::~
	不能化され:disabled:~
可能化-:enable:~
	可能化:enabled:~
具現化-:render::~
具現化:rendering::~
明に:expressly::~
環:ring::~
管理-:manage::~
管理:management::~
管理者:manager::~::マネージャ

anchor::::アンカー

転送-:transfer:~
逐次的:sequential::~
鎖:chain::~
進捗中:in progress::~
隠す:hide する:~
隠され:hidden:~
隠-:hide:~
領域:region:~

作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
作動化-:activate::~::アクティブ化
作動化:activation::~::アクティブ化
動作-:act:~
動作:action:~

移動-:move:~
所有-:own::~
所有者:owner::~
組合せ:combination:組み合わせ

演算:operation:操作
代役:placeholder:~
作動範囲:active range:~
候補:candidate:~
選定法:selection mechanism:~
始点:starting point:~


home:
首:primary:主
	首に:primarily
	＊首位／第一
表示域:viewport::~


	●編集
host::::ホスト
綴り:spelling:~
	綴りが誤っている:misspelt
文法:grammar:~
検査-:check:~
検査:checking:~
	検査-可能:checkable
検査器:checker:~
編集:editing::~
編集-:edit::~
編集中の:editing::~
	編集-可能:editable
行0:line:行
折返す:wrap する::折り返す
折返され:wrap され::折り返され
折返し:wrapping::折り返し
境界点:boundary point::~
選定-:select:~
選択-:select:~
	選択:selecting:~
選択:selection:~
	打ち込んだ:type
字下げ:indentation:~
単語:word:~
一文:sentence:文
変異-:mutate::~
	変異-可能:mutable
自然言語:language:~
終端:end:~
始端:start:~
誤り:error::~::エラー
訂正:correction:~
	不向き: not well suited

	●UI／呈示
scroll::::スクロール
view::::ビュー
可scroll:scrollable:::スクロール可能
scrollbar::::スクロールバー

overflow::::過フロー:オーバーフロー
方向:direction:~
位置:position:~
塊:block:::ブロック
flow::::フロー
行内:inline::~::インライン
基底:base::~

tab::::タブ
	tab化された:tabbed
	tabbing:

top-level::::トップレベル
window::::ウィンドウ
designMode:
kiosk:
mode::::モード
所在bar:location bar:::URL 欄
容器:container:::コンテナ

	%O:subject:対象
pop:
access::::アクセス
割当され:assign され:あてがわれ
割当する:assign する:あてがう
割当でき:assign でき:あてがえ
割当しな:assign しな:あてがわな
割当した:assign した:あてがった
割当法:assign 法:あてがい方

accessibility::access 容易性::アクセス容易性
panel::::パネル
screen::::スクリーン
button::::ボタン
popup::::
box::::ボックス
bullet::::ビュレット
map::::マップ
command::::コマンド
data::::データ
drag::::ドラッグ
drop::::ドロップ
form::::フォーム
lock::::ロック
modal::::モーダル
modality::::モダリティ
navigate::::ナビゲート
navi:navigation:::ナビ
label::::ラベル
widget::::ウィジェット
下位widget:subwidget::下位 widget:下位ウィジェット
menu::::メニュー

key::::キー
keyboard::::キーボード
full::::フル
mouse::::マウス
pointing::::ポインタ指示
十key:numeric keypad:::テンキーの類
修飾:modifier:~

対話-:interact::やりとり
対話:interaction::~
対話的:interactive::~

呈示:presentation:~
呈示-:present:~
声:voice:~
押下げた:press した:~
背景:background:~
表示-:display:~
装置:device:~
機器:device:~
読取器:reader::~::リーダ
通知:notification:~
click:
外形線:outline:~
可視:visible:~
	露わに:visible に:~
欄:field::~::フィールド
探索:search:検索
	探索:search:~
上端層:top layer::~

	使い勝手:usability
	使い勝手がすこぶる悪く:significantly less usable
	使い勝手は悪くなる:become unusable
	収まる:fit する:~
	押すこと:pressing
	閉じられ:closed
	最も手前に示される:topmost

手入力-:enter:~
alphabetic-mnemonic:alphabetic mnemonic::alphabetic 符号:アルファベット符号
電話番号:telephone :number:~
e-mail-address::::メールアドレス
domain::::ドメイン
手早く:quick に:~
書式区切子:format separator::~
locale::::ロケール
virtual-keyboard:virtual keyboard:::ソフトウェアキーボード
	小数を含む:fractional
数的:numeric:~
	数:numeric
	PIN

自動的:automatic:~

自動頭字化-:autocapitalize::~
自動頭字化:autocapitalization::~
字l:letter::字
頭字化:capitalize::~
頭字:capital letter::~
	頭字に:to a capital letter
voice:::声::ボイス
打込まれ:type され:~
打込む:type する:~
組成-:compose::~

	●構文

keyword::::キーワード
	-:literal
token::::トークン
縮約-:collapse:~
数字:digit:~
普通字:letter:~
頭部の:leading:~
分割-:split:~
構文解析-:parse::~::パース
整数:integer:~
文字:character:~
文字列:string:~
空:empty:~
空白:whitespace:~
空白区切りの:space-separated:~
符号位置:code point:~
小文字:lowercase:~
大文字:uppercase:~
妥当:valid:~


	●event
event::::イベント
listener::::リスナ
task::::タスク
queue::::キュー
配送-:dispatch::~
発火-:fire::~
誘発-:trigger::~
取消す:cancel する::取り消す
trusted:
composed:
初期化-:initialize:~

	●内容／DOM
body:
node::::ノード
obj:object:::オブジェクト
shadow:
先祖:ancestor::~
入子に:nest::入れ子に
入子の:nested::入れ子の
	先行-:precede:~
	後続-:
親:parent::~
子:child::~
	子たち:children
子孫:descendant::~
木:tree::~::ツリー
部分木:subtree::~::サブツリー
	前順, 深さ優先:pre-order, depth-first traversal:~
一節:section:~
外側:outside:~
内側:inside:~
内容:content:~
段落:paragraph:~
文書:document:~
文脈:context::~
要素:element:~
階層:hierarchy:~
頁:page:::ページ
接続-:connect:~

	●未分類（動詞
取得-:get:~
設定-:set:~
再設定-:reset:~
設定群:settings:~
	設定:setting:~
	未設定:unset
取得子:getter:~
設定子:setter:~
被呼出時:被 invoke 時:~
走らせ:run し:~
走って:run して:~
走らす:run する:~
変更-:change:~
変更:change:~
変化-:change:~
変化:changes:~
存在-:exist:~
宣言-:declare:~
	対応-:correspond:~
投出:throw:~
持続-:persist:~
更新-:update:~
包含-:contain:~
参照-:reference:~
反映-:reflect:~
合致-:match:~
対応付けら:map さ:~
挿入-:insert:~
置換-:replace:~
援助:aid:~
構築-:construct:~
無視-:ignore:~
省略-:omit:~
	外された
破壊-:destroy:~
継承-:inherit:~
	〜続ける:continue:~
表現-:represent:~
追加-:add:~
	追加:addition:~
開始-:start:~
除去-:remove:~
提出-:submit:~
削除-:delete:~
代用:substitute:~
合成:synthetic:~
告知-:advertise:~
	やり直して-:restart:~
投稿-:publish:~
読込まれ:load され:~
試みた:attempt した:~
試みる:attempt する:~
試みて:attempt して:~
	-:contribute:~
付加-:append:~
作成-:create:~
保つ:keep する:~
	なくなった:stop
公開-:expose:~
再利用:reuse:~
	属-／:belong:~
初期:initial:~
	初期~時に:initially:~
切替える:switch する:切り替える
算出-:compute:~
検証:validation:~
対応関係:mappings:~
組合され:combine され:組み合わされ

	戻せるように:allow 〜 toggle it back
	ようになる:get:~
	生じる:occur する
	求め:want
	〜に基づく:based
	含-:include
	在-:present
	不在:absent
	始-:begin
	示す:show
	起こる:happen
	返す:return
	所与の:given
	与-:give
	伝える:tell／:inform
	~~由来する:comes from
	~~検索
	~~生成
	~~要請
	~~連続する:adjacent
	〜されない:opposed
	選び取る:pick
	選んだ:choosing
	選ぶ:choose
	-:exception
	-:setting
	-:map

	●未分類
web:
URL:
entry::::エントリ
fallback::::フォールバック
option::::オプション
member::::メンバ
	辞書:dictionary::~::ディクショナリ
ASCII:
API:
DOM:
CSS:
HTML:
IDL:
ID:
UI:
canvas:
buffer::::バッファ
rich:
call::::
error::::エラー
commit:
file::::ファイル
flag::::フラグ

	designated focused
形成-:form:~
game::::ゲーム
graphic-engine:graphic engine:::グラフィックエンジン
graphical::::グラフィック的
	-:header
hint::::ヒント
hyperlink::::ハイパーリンク
link::::リンク
interface::::インタフェース
item::::アイテム

単独の:single:~
list::::リスト
log-in:log in:::ログイン
logic::::ロジック
	loop::::ループ
main::::メイン
	map::::マップ
	mark::::
markup::::マークアップ
method::::メソッド
prop:property:::プロパティ
script::::スクリプト
style::::スタイル
stylesheet:style sheet:::スタイルシート
shortcut::::ショートカット
site::::サイト
space::::
level::::レベル
text::::テキスト
	text片:piece of text
	-:time
zero::::ゼロ

例外:exception:~
値:value:~
	再び:again
入力:input:~
出力:output:~

即時:immediate:~
名前:name:~
属性:attribute:~
層:layer:~
	-:argument
	-:required
新たな:new:~
有順序:ordered:~
順序:order:~
順序付けら:order さ:~
逆順:reverse order:~
	-:plain:~

状態:state:~
環境:environment:~
画像:image:~
	-:relative
	省略時:optional:~
範囲:range:~
継続的:continuous:~

off-screen::::オフスクリーン

時間枠:timeframe:~
真偽:boolean:~
記事:article:~
連鎖:chain:~
	開閉:opened or closed
閲覧文脈:browsing context::~
集合:set:~
物理的:physical:~
携帯:mobile:~
型:type:~
使用:used:~

	数:number
	正の:positive
	負の:negative
	小さい:small

	●指示語
自前の:own:~
現在:currently:~
現在の:current:~
一意:unique:~
一様:uniform:~
	同様に:similarly
	最も近い:nearest
	直に:immediate に
	直の:immediate
	合間:between
	先ず:first place
	一定の／ある種の:certain
	自身:itself
	複数の:multiple
	異なる:different
	種々の:various
	等々:etc
	などなど:and so forth
	前者:former
	後者:latter
	他の:other
	他の場合:otherwise
	任意の／恣意的な:arbitrary
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	その他:others
	それら:they
	それらの:their
	それらの:those
	それらを:them
	つ／ 個の:two／three／five
	-:second／third
	上:above
	下:below
	両者／両:both
	以前の:previous
	-:originally
	別の:another
	前:before
	各:each
	同じ:same
	常に:always
	後:after
	先ず／最初:first
	最後:last
	次:next
	一つに:together
	一例
	一方
	一種
	一連
	一部
	一部分／一部を成す:part of
	上述
	以上
	以下
	以前
	以外
	以降
	任意
	個
	個数
	全体
	各種
	場合
	前後の:next or previous
	前述
	部分:part
	単独:alone
	〜しか:just
	右列:cells in the right column
	左列:The cells in the left column
	左右列にまたがるセル:cells that span both columns
	直前
	直前に:just
	直後
	自身
	新
	旧
	その検査／:spellchecking
	とする／:suppose
	またがる:span
	利用中に:being used
	つつある:about to be
	いかなる類の:any sort of
	多い:often
	次の:the following
	通:through
	決して:never
	介:via
	結果:result
	結果の:resulting
	〜の代わりに:instead
	すでに:already
	依然として:still

	●他の語
	-:facet
	-:in place for
	-:in the middle
	-:lack thereof
	ARIA
	Alt
	C:
	CSS
	Control
	Emacs
	Escape
	Mac
	Shift
	WYSIWYG
	Windows
	aforementioned
	amongst
	aware
	became
	become
	care
	caused
	cell
	column
	committing
	consist
	e-mail
	earlier:#1
	equipped
	express
	finally
	follow
	home
	instruction
	lack
	later
	lead
	left
	mac
	made
	marked
	matching
	moving
	off-screen
	opted
	in-
	middle
	point
	pre-order
	put
	redo
	reduce
	referenced
	rerouting
	right
	row
	said
	sometime
	spin-control
	sure
	thereof
	top
	toward
	unable
	unadorned
	unmark
	unset
	vision

	し易く:easily
	その場で:on-demand
	セル
	一枚の大きな:one big
	人々:people
	分断不可:non-breaking
	前順, 深さ優先:pre-order, depth-first
	だけで:simply
	参照
	参照元:
	同時:
	同等に:equally
	名称:
	増減:button:up and down buttons in a spin-control version
	大小区別:case sensitive:~
	始点:starting point:~
	対応
	必ず:make sure
	指-:refer
	指す~refer
	新着:New
	方法
	昇順に整列
	時点
	時経過に伴って:over time
	時間~後:

	普通の:regular
	最も深い:deepest

	条件:conditions
	正数
	注意:
	注記
	用途
	留意
	省略時
	秒~後
	組み合わせ:mix
	自動的:
	表:table
	複数:
	複雑:complicated
	規定:
	該当:
	詳細:
	黄色:yellow

	無条件
	無用に煩雑
	現時点


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">User interaction</a>
章を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header id="head">
	<hgroup>
<h1>HTML — 利用者対話 — User interaction</h1>
	</hgroup>
</header>

<main id="MAIN" style="display:none;">

	<section id="editing">
<h2 title="User interaction">6. 利用者~対話</h2>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ε, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
用語
`要素@
は、 `Element$I ~objの略記として用いられる。
</p>

		</section>
		<section id="the-hidden-attribute">
<h3 title="The hidden attribute">6.1. `hidden^a 属性</h3>

<p>
`hidden$a 内容~属性は、すべての`~HTML要素$に設定できる。
`hidden$a 属性は`真偽~属性$である。
指定された場合、その要素は，利用者からは直接的に~accessできないことを指示する
— すなわち，［
まだ, あるいはそれ以降、頁の現在の状態に直接的には関連しない
］ことを, あるいは［
頁の他の部分に再利用される内容を宣言するために利用されている
］ことを指示する。
~UAは、 `hidden$a 属性が指定されている要素を具現化するべきでない。
この要件は、~style層を通して間接的に実装されてよい。
例えば ~HTML＋~CSS ~UAは、これらの要件を
<a href="~HTMLrendering#hiddenCSS">具現化~節にて示唆されている規則</a>
を利用して実装することもできる。
◎
All HTML elements may have the hidden content attribute set. The hidden attribute is a boolean attribute. When specified on an element, it indicates that the element is not yet, or is no longer, directly relevant to the page's current state, or that it is being used to declare content to be reused by other parts of the page as opposed to being directly accessed by the user. User agents should not render elements that have the hidden attribute specified. This requirement may be implemented indirectly through the style layer. For example, an HTML+CSS user agent could implement these requirements using the rules suggested in the Rendering section.
</p>


<p class="note">注記：
この属性は、概して~CSSを利用して実装されるので、~CSSを利用して上書きすることもまた可能である。
具体的には、すべての要素に
`display: block^css
を適用する規則は、 `hidden$a 属性の効果を取消すことになる。
したがって，~stylesheetを書く作者には、この属性を有する要素に依然として期待される~styleが割当されるよう，注意する必要がある。
◎
Because this attribute is typically implemented using CSS, it's also possible to override it using CSS. For instance, a rule that applies 'display: block' to all elements will cancel the effects of the hidden attribute. Authors therefore have to take care when writing their style sheets to make sure that the attribute is still styled as expected.
</p>



<div class="example">

<p>
次の略式的な例では、利用者が~log-inするまで~Web~gameの~main~screenを隠すために，この属性が利用されている：
◎
In the following skeletal example, the attribute is used to hide the Web game's main screen until the user logs in:
</p>


<pre>
&lt;h1&gt;The Example Game&lt;/h1&gt;
&lt;section id="login"&gt;
 &lt;h2&gt;Login&lt;/h2&gt;
 &lt;form&gt;
  ...
  &lt;!-- 利用者~資格を検査したなら， login() を~callする --&gt;
 &lt;/form&gt;
 &lt;script&gt;
  function login() {
    // ~screenを切り替える
    document.getElementById('login').hidden = true;
    document.getElementById('game').hidden = false;
  }
 &lt;/script&gt;
&lt;/section&gt;
&lt;section id="game" hidden&gt;
 ...
&lt;/section&gt;
</pre>

</div>

<!-- 
The Example Game
Login

calls login() once the user's credentials have been checked

// switch screens
-->
<p>
`hidden$a 属性は、他の呈示では正当に示され得るような内容に対し，それを隠す用途には，利用されては~MUST_NOT。
例えば、~tab化された~dialog内の~panelを隠す用途に `hidden$a を利用することは，不正である
— ~tab化された~interfaceは，~overflow呈示の一種に過ぎず、単に~scrollbarを伴う大きな頁にすべての~form~controlを示すことに同等なので。
同様に、この属性を ある呈示に限って内容を隠す用途に利用することは，不正である
— `hidden$a 属性を有するものは、~screen読取器も含め，すべての呈示から隠-される。
◎
The hidden attribute must not be used to hide content that could legitimately be shown in another presentation. For example, it is incorrect to use hidden to hide panels in a tabbed dialog, because the tabbed interface is merely a kind of overflow presentation — one could equally well just show all the form controls in one big page with a scrollbar. It is similarly incorrect to use this attribute to hide content just from one presentation — if something is marked hidden, it is hidden from all presentations, including, for instance, screen readers.
</p>

<p>
`hidden$a 属性を有さない要素から， `hidden$a 属性を有する要素へ`~hyperlink$しては~MUST_NOT。
同様に、 `hidden$a 属性を有さない［
`label$e ／ `output$e
］要素の `for^a 属性が、 `hidden$a 属性を有する要素を指しては~MUST_NOT。
いずれの参照-も，利用者を惑わすことになるので。
◎
Elements that are not themselves hidden must not hyperlink to elements that are hidden. The for attributes of label and output elements that are not themselves hidden must similarly not refer to elements that are hidden. In both cases, such references would cause user confusion.
</p>


<p>
しかしながら，他の文脈においては、要素や~scriptが `hidden$a 属性を有する要素を指すこともある。
◎
Elements and scripts may, however, refer to elements that are hidden in other contexts.
</p>

<div class="example">

<p>
例えば， `href$a 属性の~link先に `hidden$a 属性を有する一節を割当するのは、不正になる。
当の内容が［
適用-可能でない／関連しない
］ならば、そこへ~linkする理由はない。
◎
For example, it would be incorrect to use the href attribute to link to a section marked with the hidden attribute. If the content is not applicable or relevant, then there is no reason to link to it.
</p>


<p>
しかしながら， ARIA `aria-describedby$a 属性を利用して `hidden$a 属性を有する記述を指すことは，申し分ない。
記述を隠すことは，それ~~単独では有用でないことを含意するが、ある画像についての記述を その画像から参照させるなど，特定の文脈~下で有用になるように書くことはできる。
◎
It would be fine, however, to use the ARIA aria-describedby attribute to refer to descriptions that are themselves hidden. While hiding the descriptions implies that they are not useful alone, they could be written in such a way that they are useful in the specific context of being referenced from the images that they describe.
</p>

<p>
同様に、 `hidden$a 属性を有する `canvas$e 要素は，~scriptによる~graphic-engineから~off-screen~bufferとして利用されることもあり、~form~controlの `form$a 属性は， `hidden$a 属性を有する `form$e 要素を指すこともある。
◎
Similarly, a canvas element with the hidden attribute could be used by a scripted graphics engine as an off-screen buffer, and a form control could refer to a hidden form element using its form attribute.
</p>

</div>

<p>
`hidden$a 属性を有する一節~内の要素であっても、依然として作動中であり続ける
— 例えば，そのような一節~内の［
~script／~form~control
］は、依然として［
実行される／提出される
］。
変化するのは、利用者~向けの呈示に限られる。
◎
Elements in a section hidden by the hidden attribute are still active, e.g. scripts and form controls in such sections still execute and submit respectively. Only their presentation to the user changes.
</p>

<dl class="idl-def">
	<dt>`hidden@m</dt>
	<dd>
同じ名前の内容~属性を`反映-$し~MUST。
◎
The hidden IDL attribute must reflect the content attribute of the same name.
</dd>
</dl>


		</section>
		<section id="inert-subtrees">
<h3 title="Inert subtrees">6.2. 不活~部分木</h3>


<p>
~node（特に，要素／~text~node）は、
`不活@
にされ得る。
~UAは、`不活$にされている~nodeに対しては：
◎
This section does not define or create any content attribute named "inert". This section merely defines an abstract concept of inertness.
◎
A node (in particular elements and text nodes) can be marked as inert. When a node is inert, then the user agent＼
</p>

<ul>
	<li>
利用者~対話~eventの標的にしては~MUST_NOT
— その目的においては，~nodeは不在であったかのように動作して。
◎
must act as if the node was absent for the purposes of targeting user interaction events,＼
</li>
	<li>
~text探索~UI（ “頁~内を~~検索” として周知の）の目的においては，~nodeを無視してよい。
◎
may ignore the node for the purposes of text search user interfaces (commonly known as "find in page"), and＼
</li>
	<li>
その~node内の~textについては，利用者が選択できなくしてよい。
◎
may prevent the user from selecting text in that node.＼
</li>
</ul>

<p>
しかしながら，~UAは、~textの探索と選択については，利用者が上の制約を上書きできるようにするべきである。
◎
User agents should allow the user to override the restrictions on search and text selection, however.
</p>


<p class="example">
例えば、ある頁に`不活$にされた段落が 1 個だけあって `body$e の~~中程に位置しているとする。
利用者が，~pointing装置をその段落の外から内に移動させ，そこで~clickした場合、
`mouseover$et ~eventは発火されず，
`mousemove$et ／ `click$et
~eventは，段落ではなく `body$e 要素に向けて発火されることになる。
◎
For example, consider a page that consists of just a single inert paragraph positioned in the middle of a body. If a user moves their pointing device from the body over to the inert paragraph and clicks on the paragraph, no mouseover event would be fired, and the mousemove and click events would be fired on the body element rather than the paragraph.
</p>


<p class="note">注記：
一般に、不活である~nodeには，~focusできない
— そのような~nodeが`~commandを定義する$ものであれば，不能化されることになる。
◎
When a node is inert, it generally cannot be focused. Inert nodes that are commands will also get disabled.
</p>


<p>
ある閲覧文脈 %B を`入子にしている閲覧文脈~容器$に対しては、それが`不活$にされている間は，［
%B にて`作動中の文書$, および
その`文書$内のすべての~node
］も`不活$にされ~MUST。
◎
While a browsing context container is marked as inert, its nested browsing context's active document, and all nodes in that Document, must be marked as inert.
</p>

<p>
`文書$ %文書 が ある
`~modal~dialogにより阻まれ@
ているとは、 %文書 の`上端層$の最後の（最も手前に示される）要素が その~modal~dialog（ `dialog$e 要素）であることをいう。
%文書 がそのように阻まれている間は、
%文書 に`接続されて$いるどの~nodeも
— %dialog と その`~shadowも含む子孫$を除き —
`不活$にされ~MUST。
（この段落にて除かれた要素であっても、他の手段を通して，`不活$にされ得る
— 当の~modal~dialogの一部を成す~nodeであっても，`不活$にされないよう “保護される” わけではない）
◎
A Document document is blocked by a modal dialog subject if subject is the topmost dialog element in document's top layer. While document is so blocked, every node that is connected to document, with the exception of the subject element and its shadow-including descendants, must be marked inert. (The elements excepted by this paragraph can additionally be marked inert through other means; being part of a modal dialog does not "protect" a node from being marked inert.)
</p>

<p class="note">注記：
`dialog$e 要素の `showModal()$m ~methodは、要素の`~node文書$の`上端層$に要素を追加することにより，この仕組みを誘発する。
◎
The dialog element's showModal() method causes this mechanism to trigger, by adding the dialog element to its node document's top layer.
</p>


		</section>
		<section id="activation">
<h3 title="Activation">6.3. 作動化</h3>


<p>
ある種の~HTML要素は、`作動化の挙動$を有する
— すなわち、利用者はそれを作動化できる。
これは、常に `click$et ~eventにより生じる。
◎
Certain elements in HTML have an activation behavior, which means that the user can activate them. This is always caused by a click event.
</p>

<p>
~UAは、利用者が，`作動化の挙動$を有する要素を手動で
— 具体的には、~keyboardや声~入力を利用したり，~mouse~clickを通して —
誘発できるようにするべきである。
利用者が，`作動化の挙動$が定義されている要素を~click以外の方式で誘発したときは、対話~eventの既定の動作においては，要素に向けて`~click~eventを発火-$し~MUST。
◎
The user agent should allow the user to manually trigger elements that have an activation behavior, for instance using keyboard or voice input, or through mouse clicks. When the user triggers an element with a defined activation behavior in a manner other than clicking it, the default action of the interaction event must be to fire a click event at the element.
</p>


<p id="allowed-to-show-a-popup">
［
次のいずれかの条件を満たす`~task$
］が走らせている~algoは、
`利用者の作動化により誘発され@
たとされる：
◎
An algorithm is triggered by user activation if any of the following conditions is true:
</p>

<ul>
	<li>
［［
`isTrusted$m ~EQ ~T
］なる `click$et ~eventによる`作動化の挙動$
］を現在~処理している
◎
The task in which the algorithm is running is currently processing an activation behavior whose click event's isTrusted attribute is true.
</li>
	<li>
<p>
［
次をいずれも満たす~event
］用の~event~listenerを現在~走らせている：
◎
The task in which the algorithm is running is currently running the event listener for an event＼
</p>

		<ul>
			<li>
`isTrusted$m ~EQ ~T
◎
whose isTrusted attribute is true and＼
</li>
			<li>
`type$m ~IN { `change$et, `click$et, `dblclick$et, `mouseup$et, `pointerup$et, `reset$et, `submit$et, `touchend$et }
◎
whose type is one of:
• change
• click
• dblclick
• mouseup
• pointerup
• reset
• submit
• touchend
</li>
		</ul>
	</li>
	<li>
<p>
`利用者の作動化により誘発され$た~algoにより`~queueされ$たものであって，そのような~algoの連鎖は~UA定義の時間枠の中で開始された。
◎
The task in which the algorithm is running was queued by an algorithm that was triggered by user activation, and the chain of such algorithms started within a user-agent defined timeframe.
</p>

<p class="example">
例えば~popupは、利用者が~buttonを~clickしてから 4 秒~後であれば 受容-可能かもしれないが， 4 時間~後ならおよそ受容-可能とされないであろう。
◎
For example, if a user clicked a button, it might be acceptable for a popup to result from that after 4 seconds, but it would likely not be acceptable for a popup to result from that after 4 hours.
</p>
	</li>
</ul>


<dl class="domintro">
	<dt>%element . `click()$m</dt>
	<dd>
要素が~clickされたかのように動作させる。
◎
Acts as if the element was clicked.
</dd>
</dl>

<p>
各~要素には、
`~click進捗中~flag@
— 初期~時は ~OFF —
が結付けられる。
◎
Each element has an associated click in progress flag, which is initially unset.
</p>


<dl class="idl-def">
	<dt>`click()@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The click() method must run the following steps:
</p>

		<ol>
			<li>
此れは`不能化され$ている~form~controlである
⇒
~RET
◎
If this element is a form control that is disabled, then return.
</li>
			<li>
~IF［
此れの`~click進捗中~flag$ ~EQ ~ON
］
⇒
~RET
◎
If this element's click in progress flag is set, then return.
</li>
			<li>
此れの`~click進捗中~flag$ ~SET ~ON
◎
Set this element's click in progress flag.
</li>
			<li>
［
%非~trusted~flag  ~SET ~ON
］の下で、此れに向けて`合成~mouse~eventを発火する$
◎
Fire a synthetic mouse event at this element, with the not trusted flag set.
</li>
			<li>
此れの`~click進捗中~flag$ ~SET ~OFF
◎
Unset this element's click in progress flag.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="focus">
<h3 title="Focus">6.4. ~focus</h3>


			<section id="introduction-8">
<h4 title="Introduction">6.4.1. 序論</h4>

~INFORMATIVE

<p>
~HTML~UIは、概して複数の対話的~widgetからなる
—
~form~control,
可scroll領域,
~link,
~dialog~box,
~browser~tab,
などなど。
これらの~widgetは、あるもの（例： ~browser~tab, ~dialog~box）が他のもの（例： ~link, ~form~control）を包含しているような，階層を形成する。
◎
An HTML user interface typically consists of multiple interactive widgets, such as form controls, scrollable regions, links, dialog boxes, browser tabs, and so forth. These widgets form a hierarchy, with some (e.g. browser tabs, dialog boxes) containing others (e.g. links, form controls).
</p>


<p>
~keyboard~UIによる対話-時の~key入力は、~systemから対話的~widgetの階層を経由して，`~focusされて$いる作動中の~widgetにたどり着く。
◎
When interacting with an interface using a keyboard, key input is channeled from the system, through the hierarchy of interactive widgets, to an active widget, which is said to be focused.
</p>

<div class="example">


<p>
~graphical環境~内で走っている~browser~tab内で走っている~HTML~appを考える。
この~appの頁には，いくつかの~text~controlや~linkがあり、~modal~dialogを現在~示していて，その中にも~text~controlや~buttonがあるとする。
この局面における~focus可能な~widgetの階層は：
◎
Consider an HTML application running in a browser tab running in a graphical environment. Suppose this application had a page with some text controls and links, and was currently showing a modal dialog, which itself had a text control and a button.
</p>


<p>
先ず~browser~windowを含み、
⇒
~windowは，~HTML~appを包含している~browser~tabを子として持ち、
⇒
~tabは，前述の~dialogの他に種々の~linkや~text~controlを子として持ち、
⇒
~dialogは，~text~controlや~buttonを子として持つことになる。
◎
The hierarchy of focusable widgets, in this scenario, would include the browser window, which would have, amongst its children, the browser tab containing the HTML application. The tab itself would have as its children the various links and text controls, as well as the dialog. The dialog itself would have as its children the text control and the button.
</p>

<figure>
<img src="HTML-resources/focus-tree.png" alt="" width="800" height="450">
<figcaption>

</figcaption></figure>

<p>
この例において `~focusされて$いる~widgetが，~dialog~box内の~text~controlであった場合、~key入力は、［
~graphical~system →
① ~Web~browser →
② ~tab →
③ ~dialog →
④ ~text~control
］の順に経由することになる。
◎
If the widget with focus in this example was the text control in the dialog box, then key input would be channeled from the graphical system to ① the Web browser, then to ② the tab, then to ③ the dialog, and finally to ④ the text control.
</p>

</div>


<p>
~keyboard~eventは、常に，この`~focusされて$いる要素を標的にする。
◎
Keyboard events are always targeted at this focused element.
</p>


			</section>
			<section id="data-model">
<h4 title="Data model">6.4.2. ~data~model</h4>


<p>
用語
`~focus可能~域@
は、~keyboard入力の標的になれるような，~UIの領域を指す。
［
要素, 要素の一部分, その他の~UAにより管理される領域
］は、~focus可能~域になり得る。
◎
The term focusable area is used to refer to regions of the interface that can become the target of keyboard input. Focusable areas can be elements, parts of elements, or other regions managed by the user agent.
</p>

<p>
各 `~focus可能~域$は、
`~DOM~anchor@
を持つ
— それは、`~focus可能~域$の~DOMにおける位置を表現する `Node$I ~objである（`~focus可能~域$自身が `Node$I であれば，それがそのまま`~DOM~anchor$になる）。
`~DOM~anchor$は、`~focus可能~域$を表現する~DOM~objが他にないときに，一部の~APIにより`~focus可能~域$の代用として利用される。
◎
Each focusable area has a DOM anchor, which is a Node object that represents the position of the focusable area in the DOM. (When the focusable area is itself a Node, it is its own DOM anchor.) The DOM anchor is used in some APIs as a substitute for the focusable area when there is no other DOM object to represent the focusable area.
</p>


<p>
次の表の左列に、どの~objが`~focus可能~域$になり得るかを述べる。
対応する`~DOM~anchor$を表の右列に述べる。
◎
The following table describes what objects can be focusable areas. The cells in the left column describe objects that can be focusable areas; the cells in the right column describe the DOM anchors for those elements. (The cells that span both columns are non-normative examples.)
</p>

<table id="table-fa"><thead><tr><th>`~focus可能~域$
<th id="th-fa-dom-rep">`~DOM~anchor$
<tr><th colspan="2">
<div class="example"><i>左右列にまたがるセルには、例を示す。</i></div>
</thead>

<tbody><tr><th id="td-fa-1">
<p >
次をいずれも満たす要素：
</p>

<ul ><li>`~tabindex~focus~flag$ ~EQ ~ON
</li><li>`不能化-$されていない
</li><li>`明に不活$でない
</li><li>［
`具現化されて$いる
］~OR［
<a href="~HEcanvas#being-used-as-relevant-canvas-fallback-content">関連する~canvas~fallback内容として利用中にある</a>
］
</li></ul>

◎
Elements that have their tabindex focus flag set, that are not actually disabled, that are not expressly inert, and that are either being rendered or being used as relevant canvas fallback content.
<td>
要素~自身。
◎
The element itself.
<tr><td colspan="2">

<div class="example">

<ul><li>`iframe$e
</li><li><a href="~HEinput#text-(type=text)-state-and-search-state-(type=search)">`&lt;input type=text&gt;^e</a>,
</li><li>場合によっては（~platform規約に依存する）
<a href="~HEtextlevel#the-a-element">`&lt;a href="…"&gt;^e</a>
</li></ul>

◎
iframe, &lt;input type=text&gt;, sometimes &lt;a href=""&gt; (depending on platform conventions).
</div>
</tbody>

<tbody><tr><th id="td-fa-2">
<p>
`画像~map$内の
`~focus可能な図形@
— そのような図形は、次を満たす各~組
( `area$e 要素 %A , `img$e 要素 %I )
ごとに作成される：
</p>

<ul ><li>%I は、その `usemap^a 属性を通して %A の親である `map^e 要素を参照している
</li><li>%I は、`具現化されて$いる, かつ `明に不活$でない
</li></ul>

<p class="trans-note">【
以下では、
%A を指して 図形を`定義している^i `area$e 要素，
%I を指して 図形が`属する^i `img$e 要素
と称することにする。
】</p>

◎
The shapes of area elements in an image map associated with an img element that is being rendered and is not expressly inert.
<td>
その図形が属する `img$e 要素。
◎
The img element.
<tr><td colspan="2">

<div class="example">
<p>
次の例の `area$e 要素は、［
その親である `map^e 要素への参照を通して それを利用している各 `img$e 要素
］ごとに 1 個ずつ，計 2 個の図形を作成する。
各~図形の`~DOM~anchor$は、参照元の `img^e 要素になる。
◎
In the following example, the area element creates two shapes, one on each image. The DOM anchor of the first shape is the first img element, and the DOM anchor of the second shape is the second img element.
</p>

<pre>
&lt;map id=wallmap&gt;&lt;area alt="入り口ドア" coords="10,10,100,200" href="door.html"&gt;&lt;/map&gt;
...
&lt;img src="images/innerwall.jpeg" alt="ドア付きの白い壁がここにある" usemap="#wallmap"&gt;
...
&lt;img src="images/outerwall.jpeg" alt="ドア付きの赤い壁がここにある" usemap="#wallmap"&gt;
</pre>
</div>
<!-- 
alt="Enter Door"
...
alt="There is a white wall here, with a door."
...
alt="There is a red wall here, with a door."
-->

</tbody>

<tbody><tr><th id="td-fa-3">
<p >
~UAにより供される下位widget要素であって，次をいずれも満たすもの：
</p>

<ul ><li>`具現化されて$いる
</li><li>`不能化-$されてない
</li><li>`明に不活$でない
</li></ul>

◎
The user-agent provided subwidgets of elements that are being rendered and are not actually disabled or expressly inert.
<td>
`~focus可能~域$がその下位widgetである要素。
◎
The element for which the focusable area is a subwidget.
<tr><td colspan="2" headers="td-fa-3">

<div class="example">
<ul>
	<li>
`video$e 要素に対し，`~UIにより利用者に公開されている~control$
◎
The controls in the user interface that is exposed to the user for a video element,＼
</li>
	<li>
<a href="~HEinput#number-state-(type=number)">`&lt;input type=number&gt;^e</a>
用の増減~button
◎
the up and down buttons in a spin-control version of &lt;input type=number&gt; ,＼
</li>
	<li>
<a href="~HEinput#range-state-(type=range)">`&lt;input type=range multiple&gt;^e</a>
用の範囲~control~widget
◎
the two range control widgets in a &lt;input type=range multiple&gt;,＼
</li>
	<li>
`details$e 要素の具現化の一部を成していて，当の要素の開閉を~keyboard入力を利用して可能化させているもの。
◎
the part of a details element's rendering that enabled the element to be opened or closed using keyboard input.
</li>
</ul>
</div>
</tbody>

<tbody><tr><th id="td-fa-4">
次を満たす要素の可scroll領域
⇒
［
`具現化されて$いる
］~AND［
`明に不活$でない
］
◎
The scrollable regions of elements that are being rendered and are not expressly inert.
<td>
その可scroll領域~boxを~~生成させた要素。
◎
The element for which the box that the scrollable region scrolls was created.
<tr><td colspan="2">

<div class="example">
<p>
~CSS `overflow$p ~propに対する `scroll^v 値は、概して，可scroll領域を作成させる。
◎
The CSS 'overflow' property's 'scroll' value typically creates a scrollable region.
</p>
</div>

</tbody>

<tbody><tr><th id="td-fa-5">
`ある閲覧文脈に属する$, かつ`不活$でない
`文書$の`表示域$。
◎
The viewport of a Document that has a browsing context and is not inert.
<td>
`表示域$を作成させている`文書$。
◎
The Document for which the viewport was created.
<tr><td colspan="2">
<div class="example">
<p>
`iframe$e の内容。
◎
The contents of an iframe.
</p>
</div>
</tbody>

<tbody><tr><th id="td-fa-6">
他の任意の
— とりわけ，~accessibilityを援助する, あるいは~platform規約により良く合致するような —
要素またはその一部分。
◎
Any other element or part of an element, especially to aid with accessibility or to better match platform conventions.
<td>
要素。
◎
The element.
<tr><td colspan="2">

<div class="example">
<p>
~UAは、利用者が~listを~navigateし易くなるよう，すべての~list~item~bulletを~focus可能にすることもできる。
◎
A user agent could make all list item bullets focusable, so that a user can more easily navigate lists.
</p>

<p>
同様に，~UAは、
`title$a 属性を有するすべての要素に対し，その参考情報に~accessできるよう，~focus可能にすることもできる。
◎
Similarly, a user agent could make all elements with title attributes focusable, so that their advisory information can be accessed.
</p>
</div>

</tbody></table>


<p id="bc-focus-ergo-bcc-focus" class="note">注記：
`閲覧文脈~容器$ %容器 （例： `iframe$e ）は `~focus可能~域$であるが，ある`閲覧文脈$ %B を`入子にして$いる場合、 %容器 へ届けられる~key~eventは，%B にて`作動中の文書$ %文書 へ，直に届けられるようになる。
同様に，`逐次的~focus~navi$においては、
%容器 は，本質的には %文書 の代役として動作するに過ぎない。
◎
A browsing context container (e.g. an iframe) is a focusable area, but key events routed to a browsing context container get immediately routed to the nested browsing context's active document. Similarly, in sequential focus navigation a browsing context container essentially acts merely as a placeholder for its nested browsing context's active document.
</p>


<hr>

<div class="p">
<p>
次のいずれかに該当するものは、
`所有者~obj@
とされる：
</p>

<ul ><li>
`文書$のうち，`ある閲覧文脈に属する$もの
</li><li>
`open$a 属性を有する `dialog$e 要素であって，`具現化されて$いるもの
</li></ul>
◎
The following create control groups:
• Document object that have browsing contexts.
• dialog elements that have an open attribute specified and that are being rendered.
</div>

<div class="p">
<p>
どの`~focus可能~域$ %F も、ある一つの`所有者~obj$ %O に所有される：
</p>

<ul ><li>%O を指して， %F の`所有者$という。
</li><li>%O は、［
%F の`~DOM~anchor$ %A, または %A の先祖
］のうち， %A に最も近い`所有者~obj$として定義される。†
</li><li>%O が所有する`~focus可能~域$の集合は、
`~control群@
と呼ばれる。
</li></ul>

<p class="trans-note">【†
定義により， %O 自身も`~focus可能~域$である場合、
%O は自身に所有され，自身の`~control群$に属することになる。
】</p>

◎
The corresponding Document object or dialog element is the created control group's owner object. (There is always a 1-to-1 mapping of control groups to control group owner objects.)
◎
Each focusable area belongs to a single control group as follows. If the DOM anchor of a focusable area is a control group owner object, then that focusable area belongs to that control group owner object's control group. Otherwise, the focusable area belongs to its DOM anchor's nearest ancestor control group owner object's control group.
</div>


<div class="example">

<p>
したがって：
◎
Thus:
</p>

<ul>
	<li>
`表示域$は常に，それを作成した`文書$の`~control群$に属する。
◎
A viewport always belongs to the control group of the Document for which the viewport was created.
</li>
	<li>
`input$e ~controlは、［
その最も近い先祖である`所有者~obj$
］の`~control群$に属する。
◎
An input control belongs to the control group of its nearest ancestor dialog or Document.
</li>
	<li>
画像~mapの図形は、それが属する `img$e 要素の［
最も近い先祖である`所有者~obj$
］に属する（それを定義している `area$e 要素のそれではなく
— これは、同じ `area$e 要素が，異なる`~control群$に属する複数の図形を作成し得ることを意味する）。
◎
An image map's shapes belong to the nearest ancestor dialog or Document of the img elements (not the area elements — this means one area element might create multiple shapes in different control groups).
</li>
</ul>

</div>


<p class="note">注記：
`~control群$は空になることもある。
◎
It is possible for a control group to be empty, i.e. for it to have no focusable areas.
</p>

<p>
`不活$にされている要素のうち，［
最も近い先祖である`所有者~obj$は `不活$でない
］ものは、
`明に不活@
とされる：
◎
An element is expressly inert if it is inert and its nearest ancestor control group owner object is not inert.
</p>

<div class="example">
<p>
`dialog$e 要素を一つも含まない頁~内では、どの`不活$な要素も`明に不活$になる。
◎
In a page with no dialog elements, all elements that are inert are expressly inert, and vice-versa.
</p>

<p>
`不活$な `dialog$e 要素の内側では、子孫のどの`不活$な要素も，`明に不活$にはならない。
◎
Inside an inert dialog element, all descendant elements are not expressly inert, even if they are inert.
</p>

<p>
`不活$な `dialog$e 要素は、別の`不活$な~dialogの内側に入子にされていないならば，`明に不活$になる。
◎
A dialog element is expressly inert if it is inert and not nested inside another inert dialog.
</p>

</div>

<hr>

<div class="p">
<p>
各
`所有者~obj$ %O は、
`~dialog群@
も持つ。
それは、次を満たす `dialog$e 要素からなる：
</p>

<ul ><li>`所有者~obj$である
</li><li>`明に不活$でない
</li><li>先祖である`所有者~obj$のうち，最も近いものは %O である†
</li></ul>

<p>
%O を指して，［
当の`~dialog群$の`所有者$ ／
`~dialog群$に属する `dialog$e 要素の
`管理者@
（ manager ）
］という††。
</p>

<p class="trans-note">【†
したがって、 `dialog$e 要素が同時に複数の`~dialog群$に属することはない。
】【††
この訳では、この用語 `管理者$は利用せずに，`所有者$を通して述べることにする。
この頁~以外のどこからも利用されておらず，さして有用でもないので。
】【
`~dialog群$は空になり得る。
原文では、そのような場合を
“%O は~dialog群を持たない”
と定義しているが、［
空であること, 持たないこと
］を区別する意味はないので、単純化するため，この訳では単に空~集合と定義する。
】</p>

◎
Each control group owner object can also act as the manager of a dialog group.
◎
Each dialog element that has an open attribute specified and that is being rendered (i.e. that is a control group owner object) and is not expressly inert belongs to the dialog group whose manager is the dialog element's nearest ancestor control group owner object.
◎
If no dialog element has a particular control group owner object as its nearest ancestor control group owner object, then that control group owner object has no dialog group.
</div>

<p>
各 `~dialog群$ %G が
`指名する被focus~dialog@
は、 ε （何も指名されていない）か,
%G 内のいずれかの `dialog$e 要素を指す（ %G が空ならば自動的に ε になるが，そうでなくても ε になり得る）。
どの `dialog$e がそう指名されるかは、この仕様の各種~algoに基づいて，時経過に伴って変化する。
`所有者~obj$ %O の`~dialog群$が`指名する被focus~dialog$は、単に［
%O が`指名する被focus~dialog$
］とも記される。
◎
Each dialog group can have a dialog designated as the focused dialog of the dialog group. Which dialog is so designated changes over time, based on algorithms in this specification.
</p>


<p>
`~dialog群$に属する要素たちの順序は、`木~順序$に従うとする。
◎
Elements in dialog groups are ordered in tree order.
</p>

<hr>

<p>
各 `~control群$ %C が
`指名する被focus域@
は、 %C が空でないならば， %C 内のある`~focus可能~域$を指す。
%C が空ならば ε （存在しない）とする。
どの~focus可能~域がそう指名されるかは、この仕様の各種~algoに基づいて，時経過に伴って変化する。
`所有者~obj$ %O の`~control群$が`指名する被focus域$は、単に［
%O が`指名する被focus域$
］とも記される。
◎
One focusable area in each non-empty control group is designated the focused area of the control group. Which control is so designated changes over time, based on algorithms in this specification. If a control group is empty, it has no focused area.
</p>

<p>
同じ`~control群$に属する`~focus可能~域$たちの順序は、次に与える
`~focus可能~域~順序@
に従う：
◎
Focusable areas in control groups are ordered relative to＼
</p>

<ul>
	<li>
それぞれの`~DOM~anchor$の`木~順序$。
◎
the tree order of their DOM anchors.＼
</li>
	<li>
`~DOM~anchor$が同じになる`~focus可能~域$たちの順序は、
`~box木~順序@
— すなわち，それらが~~生成する~CSS`~box木$ `CSS$r における前順, 深さ優先の順序。
【すなわち，`木~順序$と同様に定義される順序】
◎
Focusable areas with the same DOM anchor in a control group are ordered relative to their CSS box's relative positions in a pre-order, depth-first traversal of the box tree. [CSS]
</li>
</ul>

<hr>

<p class="algo-head">
ある時点における`~top-level閲覧文脈$ %T の
`現在の被focus域@
は、次の~algoから返される［
`~focus可能~域$ ／ `dialog$e 要素 ／ `文書$
］である：
◎
The currently focused area of a top-level browsing context at any particular time is the focusable area or dialog returned by this algorithm:
</p>


<ol>
	<li>
%候補 ~LET %T にて`作動中の文書$
◎
Let candidate be the Document of the top-level browsing context.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
~IF［
%候補 が`指名する被focus~dialog$ %D ~NEQ ε
］
⇒
%候補 ~SET %D
◎
If candidate has a dialog group with a designated focused dialog of the dialog group, then let candidate be the designated focused dialog of the dialog group, and redo this step.
</li>
			<li>
<p>
~ELIF［
%候補 が`指名する被focus域$ %F ~NEQ ε
］
◎
↓</p>
				<ol>
					<li>
~IF［
%F は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］
⇒
%候補 ~SET %B にて`作動中の文書$
◎
Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container with a non-null nested browsing context, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.
</li>
					<li>
~ELSE
⇒
~RET %F
◎
Otherwise, if candidate has a non-empty control group, let candidate be the designated focused area of the control group.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
~RET %候補
◎
Return candidate.
</li>
		</ol>
	</li>
</ol>


<p>
`現在の被focus域$の`~DOM~anchor$である要素は、
`~focusされて@
いるという。
そうでない要素が`~focusされて$いるようになることを、
`~focusを獲得した@
という。
◎
An element that is the DOM anchor of a focusable area is said to gain focus when that focusable area becomes the currently focused area of a top-level browsing context. When an element is the DOM anchor of a focusable area of the currently focused area of a top-level browsing context, it is focused.
</p>


<p class="algo-head">
`~focus可能~域$ ／ `所有者~obj$
%O の
`~focus鎖@
は、次に従って構築される有順序~listである：
◎
The focus chain of a focusable area or control group owner object subject is the ordered list constructed as follows:
</p>

<ol>
	<li>
%出力 ~LET 空~list
◎
Let current object be subject.
◎
Let output be an empty list.
</li>
	<li>
<p>
<!-- Loop -->
~WHILE 無条件：
</p>
		<ol>
			<li>
%出力 に %O を付加する
◎
Loop: Append current object to output.
</li>
			<li>
~IF［
%O は`~focus可能な図形$である
］
⇒
%出力 に %O を定義している `area$e 要素を付加する
◎
If current object is an area element's shape, append that area element to output.
</li>
			<li>
~ELIF［
%O は`~focus可能~域$である
］~AND［
%O の`~DOM~anchor$ %A ~NEQ %O
］
⇒
%出力 に %A を付加する
◎
Otherwise, if current object is a focusable area whose DOM anchor is an element that is not current object itself, append that DOM anchor element to output.
</li>
			<li>
<p>
~IF［
%O は ある`~dialog群$ %D 内の `dialog$e ~objである
］
⇒
%O ~SET %D の`所有者$
◎
If current object is a dialog object in a dialog group, let current object be that dialog group's manager, and return to the step labeled loop.
</li>
			<li>
~ELIF［
%O は`~focus可能~域$である
］
⇒
%O ~SET %O の`所有者$
◎
Otherwise, if current object is a focusable area, let current object be that focusable area's control group's owner object, and return to the step labeled loop.
</li>
			<li>
~ELIF［
%O は`文書$である
］~AND［
%O が`属する閲覧文脈$ %B を`入子にしている閲覧文脈~容器$ %C がある
］
⇒
%O ~SET %C
◎
Otherwise, if current object is a Document in a nested browsing context, let current object be its browsing context container, and return to the step labeled loop.
</li>
			<li>
~ELSE
⇒
~RET %出力
◎
Return output.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
~focus鎖は、 %O から開始して，（ %O が`現在の被focus域$である／なり得るならば）
`~top-level閲覧文脈$に属する`文書$まで，~focus階層を辿り続ける。
◎
The chain starts with subject and (if subject is or can be the currently focused area of a top-level browsing context) continues up the focus hierarchy up to the Document of the top-level browsing context.
</p>

			</section>
			<section id="the-tabindex-attribute">
<h4 title="The tabindex attribute">6.4.3. `tabindex^a 属性</h4>

<p>
`tabindex@a
内容~属性により、作者は，次について想定することを指示できるようになる：
◎
The tabindex content attribute allows authors to indicate that＼
</p>

<ul>
	<li>
要素は`~focus可能~域$になること。
◎
an element is supposed to be focusable, and＼
</li>
	<li>
`逐次的~focus~navi$を利用して到達-可能かどうか。
◎
whether it is supposed to be reachable using sequential focus navigation and,＼
</li>
	<li>
到達できる場合、要素は，逐次的~focus~navi順序においてどこに~~位置するか。
◎
if so, what is to be the relative order of the element for the purposes of sequential focus navigation.＼
</li>
</ul>

<p>
“tab index” という名称は、一連の~focus可能な要素を~navigateするときに， “tab” ~keyが共通的に利用されることに~~由来する。
語 “tabbing” とは、逐次的~focus~naviを利用して到達し得る~focus可能な要素を，前方へ辿ることを指す。
◎
The name "tab index" comes from the common use of the "tab" key to navigate through the focusable elements. The term "tabbing" refers to moving forward through the focusable elements that can be reached using sequential focus navigation.
</p>

<p>
この属性が省略されている場合、~UAは，下に述べる既定のふるまいを適用する。
（`具現化されて$いる要素を~focus可能でなくする仕方は、それを`不能化-$するか`不活$にする他にない。）
◎
When the attribute is omitted, the user agent applies defaults. (There is no way to make an element that is being rendered be not focusable at all without disabling it or making it inert.)
</p>


<p>
`tabindex$a 属性に指定される値は、`妥当な整数$で~MUST。
正~数は、要素の`~focus可能~域$の，`逐次的~focus~navi順序$における位置を指定する。
負~数は、当の~controlは，`逐次的~focus~navi$においては到達-不能になることを指示する。
◎
The tabindex attribute, if specified, must have a value that is a valid integer. Positive numbers specify the relative position of the element's focusable areas in the sequential focus navigation order, and negative numbers indicate that the control is to be unreachable by sequential focus navigation.
</p>


<p>
開発者は、 `tabindex$a 属性に対する 0, −1 以外の値は注意して利用するべきである
— 正しく利用するのは複雑なので。
◎
Developers should use caution when using values other than 0 or −1 for their tabindex attributes as this is complicated to do correctly.
</p>

<p>
各~要素には
`~tabindex~focus~flag@
が結付けられ、下に定義されるように ~ON にされ得る。
以前の節で述べたように、この~flagは，要素が`~focus可能~域$になるかどうか決定する要因になる。
◎
Each element can have a tabindex focus flag set, as defined below. This flag is a factor that contributes towards determining whether an element is a focusable area, as described in the previous section.
</p>


<p>
所与の要素の
`~tabindex値@
は、［
要素は `tabindex$a 属性 %A を有する
］~AND［
`整数として構文解析する$( %A の値 ) ~NEQ ~error
］ならば その結果 ／
~ELSE_ ε
］とする。
所与の`~focus可能~域$の`~tabindex値$は、その`~DOM~anchor$の`~tabindex値$とする。
【この定義は、以下を簡潔に述べるために，この訳に導入したものである。】
◎
↓</p>


<p>
~UAは、要素~上の`~tabindex値$を，次に従って解釈し~MUST：
◎
If the tabindex attribute is specified on an element, it must be parsed using the rules for parsing integers. The attribute's values, or lack thereof, must be interpreted as follows:
</p>

<ul>
	<li>
<p>
`~tabindex値$ ~EQ ε の場合、~UAは，~platform規約に従って
次を決定するべきである
⇒
要素の`~tabindex~focus~flag$は ~ON にされるか？
— そうであれば
⇒
［
要素, または要素を`~DOM~anchor$とする`~focus可能~域$
］へは、`逐次的~focus~navi$を利用して到達できるか？
— そうであれば
⇒
要素／~focus可能~域は、`逐次的~focus~navi順序$において どこに位置するか？
◎
If the attribute is omitted or parsing the value returns an error
◎
The user agent should follow platform conventions to determine if the element's tabindex focus flag is set and, if so, whether the element and any focusable areas that have the element as their DOM anchor can be reached using sequential focus navigation, and if so, what their relative position in the sequential focus navigation order is to be.
</p>

<p>
~platform規約の違いを除き、次のいずれかに該当する要素に対しては，`~tabindex~focus~flag$を ~ON にすることが示唆される：
◎
Modulo platform conventions, it is suggested that for the following elements, the tabindex focus flag be set:
</p>

		<ul>
			<li>
`a$e 要素のうち， `href$a 属性を有するもの
◎
a elements that have an href attribute
</li>
			<li>
`link$e 要素のうち， `~href0$a 属性を有するもの
◎
link elements that have an href attribute
</li>
			<li>
`button$e 要素
◎
button elements
</li>
			<li>
`input$e 要素のうち，その `type$a 属性の状態 ~NEQ `Hidden$st なるもの
◎
input elements whose type attribute are not in the Hidden state
</li>
			<li>
`select$e 要素
◎
select elements
</li>
			<li>
`textarea$e 要素
◎
textarea elements
</li>
			<li>
`details$e 要素の子である `summary$e 要素のうち，最初のもの
◎
summary elements that are the first summary element child of a details element
</li>
			<li>
`draggable$a 属性を有する要素のうち、~UAが［
利用者が~pointing装置を利用することなく，その要素に対する~drag演算を始める
］ことを可能化するもの。
◎
Elements with a draggable attribute set, if that would enable the user agent to allow the user to begin a drag operations for those elements without the use of a pointing device
</li>
			<li>
`編集中の~host$
◎
Editing hosts
</li>
			<li>
`閲覧文脈~容器$
◎
Browsing context containers
</li>
		</ul>
	</li>
	<li>
<p>
`~tabindex値$ ~NEQ ε の場合、要素の`~tabindex~focus~flag$は ~ON にし~MUST。
加えて：
◎
↓</p>
		<ul>
			<li>
<p>
`~tabindex値$ ~LT 0 の場合、`逐次的~focus~navi順序$からは，要素を外すべきである。
◎
If the value is a negative integer
◎
The user agent must set the element's tabindex focus flag, but should omit the element from the sequential focus navigation order.
</p>

<p class="note">注記：
要素を逐次的~focus~naviから外すとする，作者から~~要請された要件を無視する妥当な理由としては、利用者が~focusを移動する仕組みが，逐次的~focus~naviの他にない場合が挙げられる。
具体的には、~keyboardのみの利用者は，負の `tabindex$a を伴う~text~controlを~clickできないので、~UAが，~~要請にかかわらず［
利用者が~tabで当の~controlへ移れる
］ようにすることは正当化される。
◎
One valid reason to ignore the requirement that sequential focus navigation not allow the author to lead to the element would be if the user's only mechanism for moving the focus is sequential focus navigation. For instance, a keyboard-only user would be unable to click on a text control with a negative tabindex, so that user's user agent would be well justified in allowing the user to tab to the control regardless.
</p>
			</li>
			<li>
`~tabindex値$ ~GTE 0 の場合、［
要素, および要素を`~DOM~anchor$とする`~focus可能~域$
］へは，`逐次的~focus~navi$を利用して到達できるようにするべきである。
◎
If the value is a zero
◎
↓↓
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation, following platform conventions to determine the element's relative position in the sequential focus navigation order.
◎
If the value is greater than zero
◎
The user agent must set the element's tabindex focus flag, should allow the element and any focusable areas that have the element as their DOM anchor to be reached using sequential focus navigation,＼
</li>
		</ul>
	</li>
	<li >
<p>
`逐次的~focus~navi$を利用して到達できる`~focus可能~域$たちの~navi順序は、以下に従うべきである：
</p>

<ul>
	<li>
［
`~tabindex値$ ~EQ 0
］なるものどうしの順序は、~platform規約に従う。
</li>
	<li>
［
`~tabindex値$ ~GT 0
］なるものは、他のものより先にする。
</li>
	<li>
<p>
［
`~tabindex値$ ~GT 0
］なるものどうしの順序は：
</p>

<ul><li>`~tabindex値$の昇順に整列する（値が小さいものが先）。
</li><li>`~tabindex値$が同じものどうしの順序は、`~DOM~anchor$の`木~順序$に従う。
</li></ul>

	</li>
</ul>

<p class="trans-note">【
`~tabindex値$が負数のものどうしの順序は、ここには規定されていない（元々、逐次的~focus~naviからは外される “べき” とされている）。
同じ`~DOM~anchor$を共有するものどうしの順序も、定義されていない（`~focus可能~域~順序$に準じそうにも思われるが、ここには言及されていない）。
】</p>

◎
and should place the element — referenced as candidate below — and the aforementioned focusable areas in the sequential focus navigation order so that, relative to other focusable areas in the sequential focus navigation order, they are:
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has been omitted or whose value, when parsed, returns an error,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to or less than zero,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than zero but less than the value of the tabindex attribute on candidate,
◎
after any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is earlier in the document in tree order than candidate,
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value equal to the value of the tabindex attribute on candidate but that is later in the document in tree order than candidate, and
◎
before any focusable area whose DOM anchor is an element whose tabindex attribute has a value greater than the value of the tabindex attribute on candidate.
</li>
</ul>

<p>
`tabindex$a 属性が指定されている要素は、`対話的~内容$になる。
◎
An element with the tabindex attribute specified is interactive content.
</p>

<dl class="idl-def">
	<dt>`tabIndex@m</dt>
	<dd>
`tabindex$a 内容~属性の値を`反映-$し~MUST。
◎
The tabIndex IDL attribute must reflect the value of the tabindex content attribute.＼
</dd>
	<dd>
その既定~値は、要素が［
~focus可能ならば 0 ／
~focus可能でないならば −1 
］とする。
◎
Its default value is 0 for elements that are focusable and −1 for elements that are not focusable.
</dd>
</dl>


			</section>
			<section id="focus-processing-model">
<h4 title="Processing model">6.4.4. 処理~model</h4>

<p class="algo-head">
`~objを~focusする@
ときは、所与の
⇒＃
%標的 （ `~focus可能~域$ ／ `~focus可能~域$でない要素 ／ `閲覧文脈$ ）,
%~fallback標的 （省略時は ε ）
◎終
に対し，次の手続きを走らす：
◎
The focusing steps for an object new focus target that is either a focusable area, or an element that is not a focusable area, or a browsing context, are as follows. They can optionally be run with a fallback target.
</p>

<ol>
	<li>
<p>
%標的 ~SET 次の下位手続きを走らせた結果：
◎
If new focus target is neither a dialog element that has an open attribute specified and that is being rendered (i.e. that is a control group owner object), nor a focusable area, then run the first matching set of steps from the following list:
</p>
		<ol>
			<li>
~IF［
%標的 は`~focus可能~域$である
］
⇒
~RET %標的
◎
↑</li>
			<li>
~IF［
%標的 は `dialog$e 要素である
］~AND［
%標的 は`所有者~obj$である
］
⇒
~RET %標的
◎
↑</li>
			<li>
~IF［
%標的 は `area$e 要素である
］~AND［
%標的 は`~focus可能な図形$を定義している
］
⇒
~RET 
それらの図形の`~DOM~anchor$のうち，`木~順序$で最初のもの
◎
If new focus target is an area element with one or more shapes that are focusable areas
• Let new focus target be the shape corresponding to the first img element in tree order that uses the image map to which the area element belongs.
</li>
			<li>
~IF［
%標的 は要素である
］~AND［
%標的 は`~focus可能~域$である 1 個以上の可scroll領域を伴う
］
⇒
~RET %標的 の，`~box木~順序$による最初の可scroll領域
`CSS$r
◎
If new focus target is an element with one or more scrollable regions that are focusable areas
• Let new focus target be the element's first scrollable region, according to a pre-order, depth-first traversal of the box tree. [CSS]
</li>
			<li>
~IF［
%標的 は`文書~要素$である
］
⇒
~RET %標的 の`文書$の`表示域$
◎
If new focus target is the document element of its Document
• Let new focus target be the Document's viewport.
</li>
			<li>
~IF［
%標的 は
`閲覧文脈$である
］
⇒
~RET %標的 にて`作動中の文書$
◎
If new focus target is a browsing context
• Let new focus target be the browsing context's active document.
</li>
			<li>
~IF［
%標的 は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］
⇒
~RET %B にて`作動中の文書$
◎
If new focus target is a browsing context container with a non-null nested browsing context
• Let new focus target be the browsing context container's nested browsing context's active document.
</li>
			<li>
~RET %~fallback標的
◎
Otherwise
• If no fallback target was specified, abort the focusing steps.
• Otherwise, let new focus target be the fallback target.
</li>
		</ol>
	</li>
	<li>
~IF［
%標的 ~EQ ε
］
⇒
~RET
◎
↑</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
<p >
~IF［
%標的 は`所有者~obj$である
］~AND［
%標的 は`~focus可能~域$でない
］
</p>

				<ol>
					<li>
~IF［
%標的 が`指名する被focus~dialog$ ~NEQ ε
］
⇒
%標的 ~SET それ
</li>
					<li>
~ELIF［
%標的 が`指名する被focus域$ ~NEQ ε
］
⇒
%標的 ~SET それ
<!-- ＊
designate new focus target as the focused area of the control group
自身の指名focus域を自身にする？？
-->
</li>
				</ol>

◎
If new focus target is a control group owner object that is not a focusable area, but does have a dialog group, and that dialog group has a designated focused dialog, then let new focus target be the focused dialog of the dialog group, and redo this step.
◎
Otherwise, if new focus target is a control group owner object that is not a focusable area, and its control group is not empty, then designate new focus target as the focused area of the control group, and redo this step.
</li>
			<li>
~ELIF［
%標的 は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］
⇒
%標的 ~SET %B にて`作動中の文書$
◎
Otherwise, if new focus target is a browsing context container with non-null nested browsing context, then let new focus target be the nested browsing context's active document, and redo this step.
</li>
			<li>
~ELSE
⇒
~BREAK
</li>
		</ol>

<p class="note">注記：
`具現化されて$いる `dialog$e 要素は、［
`open$a, `tabindex$a
］両~属性が指定されている場合，`所有者~obj$であると同時に`~focus可能~域$になり得る。
◎
A dialog element can be both a control group owner object and a focusable area, if it has both an open attribute specified and a tabindex attribute specified and is being rendered.
</p>
	</li>
	<li>
~IF［
%標的 は`~focus可能~域$である
］~AND［
%標的 の`~DOM~anchor$は`不活$である
］
⇒
~RET
◎
If new focus target is a focusable area and its DOM anchor is inert, then return.
</li>
	<li>
~IF［
%標的 ~EQ `現在の被focus域$
］
⇒
~RET
◎
If new focus target is the currently focused area of a top-level browsing context, then return.
</li>
	<li>
%旧~鎖 ~LET ［［
%標的 が見出される`~top-level閲覧文脈$
］の`現在の被focus域$
］の`~focus鎖$
◎
Let old chain be the focus chain of the currently focused area of the top-level browsing context in which new focus target finds itself.
</li>
	<li>
%新~鎖 ~LET %標的 の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
`~focusを更新する$( %旧~鎖, %新~鎖, %標的 )
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>
</ol>

<p>
~UAは、利用者が［
`~focus可能~域$ ／ `dialog$e ／ `閲覧文脈$
］ %候補 に~focusを移動しようと試みたときには、`即時に$次を走らせ~MUST
⇒
`~objを~focusする$( %候補 )
◎
User agents must immediately run the focusing steps for a focusable area, dialog, or browsing context candidate whenever the user attempts to move the focus to candidate.
</p>

<p class="algo-head">
`~objを~unfocusする@
ときは、所与の
( ［ `~focus可能~域$ ／ `~focus可能~域$でない要素 ］ %旧~標的 )
に対し，次の手続きを走らす：
◎
The unfocusing steps for an object old focus target that is either a focusable area or an element that is not a focusable area are as follows:
</p>

<ol>
	<li>
~IF［
%旧~標的 は`不活$である
］
⇒
~RET
◎
If old focus target is inert, then return.
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

		<ul>
			<li>
［
`現在の被focus域$は`~focus可能な図形$である
］~AND［
 %旧~標的 は その図形を定義している `area$e 要素である
</li>
			<li>
［
`現在の被focus域$は可scroll領域である
］~AND［
%旧~標的 は その可scroll領域を有する要素である
］
</li>
		</ul>
<p>
…ならば
⇒
%旧~標的 ~LET `現在の被focus域$
</p>
◎
If old focus target is an area element and one of its shapes is the currently focused area of a top-level browsing context, or, if old focus target is an element with one or more scrollable regions, and one of them is the currently focused area of a top-level browsing context, then let old focus target be that currently focused area of a top-level browsing context.
</li>
	<li>
~ELIF［
%旧~標的 ~NIN `現在の被focus域$の`~focus鎖$
］
⇒
~RET
◎
Let old chain be the focus chain of the currently focused area of a top-level browsing context.
◎
If old focus target is not one of the entries in old chain, then return.
</li>
	<li>
~IF［
%旧~標的 は ある`~dialog群$ %D に属する
］~AND［
%D の`所有者$が`指名する被focus域$ %F ~NEQ ε
］
⇒
`~objを~focusする$( %F )
◎
If old focus target is a dialog in a dialog group, and the dialog group manager has a non-empty control group, then let new focus target be the designated focused area of that focus group.
</li>
	<li>
<p>
~ELIF［
%旧~標的 は`~focus可能~域$である
］：
◎
Otherwise, if old focus target is a focusable area, then＼
</p>
		<ol>
			<li>
%新~標的 ~LET %旧~標的 が属する`~control群$内の最初の`~focus可能~域$
— （ %旧~標的 の`所有者$が`文書$ならば、これは常に`表示域$になる。）
◎
let new focus target be the first focusable area of its control group (if the control group owner object is a Document, this will always be a viewport).
</li>
			<li>
`~objを~focusする$( %新~標的 )
◎
Otherwise, let new focus target be null.
◎
If new focus target is not null, then run the focusing steps for new focus target.
</li>
		</ol>
	</li>
</ol>

<p>
`現在の被focus域$ %F が，それに代わる別の要素が明示的に~focusされずに，何らかの方法で~unfocusされた場合、~UAは，`即時に$次を走らせ~MUST
⇒
`~objを~unfocusする$( %F )
◎
When the currently focused area of a top-level browsing context is somehow unfocused without another element being explicitly focused in its stead, the user agent must immediately run the unfocusing steps for that object.
</p>


<p class="note">注記：
`~objを~unfocusする$ことにより，常に~focusが変更されるとは限らない
— `現在の被focus域$に適用されるときであっても。
例えば，`現在の被focus域$は`表示域$である場合、通例的には，［
`~objを~focusする$ことにより，別の`~focus可能~域$が明示的に~focusされる
］までは，その~focusを保つことになる。
◎
The unfocusing steps do not always result in the focus changing, even when applied to the currently focused area of a top-level browsing context. For example, if the currently focused area of a top-level browsing context is a viewport, then it will usually keep its focus regardless until another focusable area is explicitly focused with the focusing steps.
</p>


<hr>

<p>
`~dialog群$ %G 内の
`既定の被focus~dialog@
とは、［
%G は空であるならば ε ／
~ELSE_ %G 内に`不活$でない `dialog$e があるならば それらのうち 最初のもの／
~ELSE_ %G 内の最初の`dialog$e
］とする。
◎
↓</p>

<p class="trans-note">【
`既定の被focus~dialog$は、以下を簡潔に記述するために，この訳に導入した定義である。
】</p>

<p>
所与の`所有者~obj$の［
`~dialog群$ %G, `~control群$ %C
］において、次が生じた場合：
◎
↓</p>

<ul>
	<li>
%C が空である下で，ある`~focus可能~域$ %F が %C に追加されたときは
⇒
%C が`指名する被focus域$ ~SET %F にされ~MUST。
◎
When a focusable area is added to an empty control group, it must be designated the focused area of the control group.
</li>
	<li>
［
%G は空である
］~AND［
%C は空である
］下で，
%G が空でなくなったときは
⇒
%G が`指名する被focus~dialog$ ~SET %G 内の`既定の被focus~dialog$にされ~MUST。
◎
When a dialog group is formed, if the dialog group manager has an empty control group, the first non-inert dialog in the dialog group, if any, or else the first dialog in the dialog group regardless of inertness, must be designated the focused dialog of the dialog group.
</li>
	<li>
<p>
`~focus修復~規則 1@
：
%C が`指名する被focus域$が %C に属さなくなったときは（例：
`~focus可能~域$でなくなった ／
~DOMから除去された ／
`明に不活$になった,
等々）、
%C が`指名する被focus域$を，次に与えるものにする：
◎
Focus fixup rule one: When the designated focused area of a control group is removed from that control group in some way (e.g. it stops being a focusable area, it is removed from the DOM, it becomes expressly inert, etc),＼
</p>

<ol>
			<li>
%C は空ならば ε（なし）
◎
and the control group is still not empty:＼
</li>
			<li>
~ELSE_ %C 内に`不活$でない`~focus可能~域$があるならば，それらのうち `~focus可能~域~順序$で最初のもの
◎
designate the first non-inert focusable area in that control group to be the new focused area of the control group, if any;＼
</li>
			<li>
~ELSE_ %C 内の `~focus可能~域~順序$で最初の`~focus可能~域$
◎
if they are all inert, then designate the first focusable area in that control group to be the new focused area of the control group regardless of inertness.＼
◎
If such a removal instead results in the control group being empty, then there is simply no longer a focused area of the control group.
</li>
		</ol>

<div class="example">
<p>
これは、例えば次のときに起こり得る：
</p>

<ul><li>要素が`文書$から除去されたとき
</li><li>`hidden$a 属性が追加されたとき
</li><li>`input$e 要素が`不能化され$たとき
</li></ul>
◎
For example, this might happen because an element is removed from its Document, or has a hidden attribute added. It might also happen to an input element when the element gets disabled.
</div>

<p class="example">
`dialog$e 要素を含まない`文書$が`指名する被focus域$は `button$e 要素である下で，その~button要素が［
除去- ／不能化- ／ 隠-
］された場合、`文書$の`表示域$が 頁の新たな`指名する被focus域$になる。
これは、 `activeElement$m が`~body要素$を返すように反映される。
◎
In a Document without dialog elements, whose focused area is a button element, removing, disabling, or hiding that button would cause the page's new focused area to be the viewport of the Document. This would, in turn, be reflected through the activeElement API as the body element.
</p>

	</li>
	<li>
<p>
`~focus修復~規則 2@
：
次の条件すべてが満たされている下で：
</p>
<ul ><li>%G が`指名する被focus~dialog$ ~EQ ε
</li><li>%G は空でない 
</li><li>%C は空でない
</li></ul>

<p>
%C が空になったときは
⇒
%G が`指名する被focus~dialog$ ~SET  %G 内の`既定の被focus~dialog$にする
</p>

<!-- Focus fixup rule two:
https://github.com/whatwg/html/issues/897
-->

◎
Focus fixup rule two: When a dialog group has no designated focused dialog of the dialog group, and its dialog group manager's control group changes from being non-empty to being empty, the first non-inert dialog in the dialog group, if any, or else the first dialog in the dialog group regardless of inertness, must be designated the focused dialog of the dialog group.
</li>
	<li>
<p>
`~focus修復~規則 3@：
［
%G が`指名する被focus~dialog$ %D ~NEQ ε
］の下で， %D が %G に属さなくなったときは（例：
`具現化され$なくなった ／
`open$a 属性を有さなくなった ／
`明に不活$になった,
等々）
⇒
%G が`指名する被focus~dialog$ ~SET ［
%C は空でないならば ε ／
~ELSE_ %G 内の`既定の被focus~dialog$
］にする
◎
Focus fixup rule three: When the designated focused dialog of a dialog group is removed from that dialog group in some way (e.g. it stops being rendered, it loses its open attribute, it becomes expressly inert, etc), and there is still a dialog group (because the dialog in question was not the last dialog in that dialog group): if the dialog group's manager's control group is non-empty, let there be no designated focused dialog of the dialog group any more; otherwise (in the case that the control group is empty), designate the first non-inert dialog in the dialog group to be the focused dialog of the dialog group, or, if they are all inert, designate the first dialog in the dialog group to be the focused dialog of the dialog group regardless of inertness.
</li>
</ul>

<p class="algo-head">
~UAは、`現在の被focus域$が、次のいずれかのように変化したときは…：
◎
When the currently focused area of a top-level browsing context＼
</p>

		<ul>
			<li>
`~focus可能~域$でなくなった
◎
was a focusable area but stops being a focusable area, or＼
</li>
			<li>
`~dialog群$に属する `dialog$e であったが，属さなくなった
◎
when it was a dialog in a dialog group and stops being part of that dialog group, or＼
</li>
			<li>
`不活$でなくなった
◎
when it starts being inert,＼
</li>
		</ul>
<p>
…次の手続きを走らせ~MUST：
◎
the user agent must run the following steps:
</p>

<ol>
	<li>
%旧~時点 ~LET この~algoが適用-可能になる直前
◎
↓</li>
	<li>
%旧~標的 ~LET
%旧~時点 における`現在の被focus域$（例：
不能化された要素 ／ 閉じられる前の~dialog ／ この~algoを走らせたもの）
◎
Let old focus target be whatever the currently focused area of the top-level browsing context was immediately before this algorithm became applicable (e.g. before the element was disabled, or the dialog was closed, or whatever caused this algorithm to run).
</li>
	<li>
%旧~鎖 ~LET %旧~時点 における %旧~標的 の`~focus鎖$
◎
Let old chain be the focus chain of the currently focused area of the top-level browsing context at the same time.
</li>
	<li>
変化により含意される，上の［
`~focus修復~規則 1$,
`~focus修復~規則 2$,
`~focus修復~規則 3$
］が必ず適用されるようにする
◎
Make sure that the changes implied by the focus fixup rules one, two, and three above are applied.
</li>
	<li>
%新~標的 ~LET `現在の被focus域$
◎
Let new focus target be the currently focused area of a top-level browsing context.
</li>
	<li>
~IF［
%旧~標的 ~EQ %新~標的
］
⇒
~RET
◎
If old focus target and new focus target are the same, return.
</li>
	<li>
%新~鎖 ~LET %新~標的 の`~focus鎖$
◎
Let new chain be the focus chain of new focus target.
</li>
	<li>
`~focusを更新する$( %旧~鎖, %新~鎖, %新~標的 )
◎
Run the focus update steps with old chain, new chain, and new focus target respectively.
</li>
</ol>
<hr>


<p class="algo-head">
`~focusを更新する@
ときは、所与の
( %旧~鎖, %新~鎖, %新~標的 )
に対し，次の手続きを走らす：
◎
The focus update steps, given an old chain, a new chain, and a new focus target respectively, are as follows:
</p>

<ol>
	<li>
~WHILE［
%旧~鎖 内の最後の~entry ~EQ %新~鎖 内の最後の~entry
］
⇒＃
%旧~鎖 内から最後の~entryを~popする；
%新~鎖 内から最後の~entryを~popする
◎
If the last entry in old chain and the last entry in new chain are the same, pop the last entry from old chain and the last entry from new chain and redo this step.
</li>
	<li>
<p>
%旧~鎖 内の
~EACH( ~entry %~entry ) に対し：
◎
For each entry entry in old chain, in order, run these substeps:
</p>

		<ol>
			<li id="unfocus-causes-change-event">
<p>
~IF［
次のいずれも満たされる
］…
</p>

<ul ><li>%~entry は `input$e 要素 %要素 である
</li><li>%要素 には `change$et ~eventが
<a href="~HEinput#concept-input-apply">適用される</a>
</li><li>%要素 には`作動化の挙動$は定義されていない
</li><li>%要素 が~focusされている間に，利用者は %要素 の［
`値$fe ／ `選択-中の~fileの~list$
］を変更していて、その（~controlが最初に~focusされたときと異なるような）変更はまだ~commitされていない
</li></ul>

<p>
…ならば
⇒
%要素 に向けて，名前 `change$et の~eventを［
`bubbles$m 属性 ~SET ~T
］に初期化した上で`発火-$する
</p>
◎
If entry is an input element, and the change event applies to the element, and the element does not have a defined activation behavior, and the user has changed the element's value or its list of selected files while the control was focused without committing that change (such that it is different to what it was when the control was first focused), then fire an event named change at the element, with the bubbles attribute initialized to true.
</li>
			<li>
%~blur~event標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry は要素である
］
⇒
%~blur~event標的 ~LET %~entry
◎
If entry is an element, let blur event target be entry.
</li>
			<li>
~ELIF［
%~entry は`文書$である
］
⇒
%~blur~event標的 ~LET その`文書$の `Window$I ~obj
◎
If entry is a Document object, let blur event target be that Document object's Window object.
◎
Otherwise, let blur event target be null.
</li>
			<li>
%関係する標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %旧~鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%新~鎖 内の最後の~entryは`要素$である
］
⇒
%関係する標的 ~LET %新~鎖 内の最後の~entry
◎
If entry is the last entry in old chain, and entry is an Element, and the last entry in new chain is also an Element, then let related blur target be the last entry in new chain. Otherwise, let related blur target be null.
</li>
			<li>
<p>
~IF［
%~blur~event標的 ~NEQ ~NULL
］
⇒
%~blur~event標的 に向けて `~focus~eventを発火する$( `blur$et, %関係する標的 )
◎
If blur event target is not null, fire a focus event named blur at blur event target, with related blur target as the related target.
</p>


<p class="note">注記：
~eventは発火されない事例もある
— 例えば、 %~entry は［
`~focus可能な図形$ ／ 可scroll領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
	<li>
~IF［
%新~標的 の~focus時に，~platform特有の関連する規約がある
］
⇒
その規約を適用する（例えば，一部の~platformは、~text~controlに~focusされたときに，その内容を選択する）
◎
Apply any relevant platform-specific conventions for focusing new focus target. (For example, some platforms select the contents of a text control when that control is focused.)
</li>
	<li>
<p>
%新~鎖 内の ~EACH( ~entry %~entry ) に対し，逆順に：
◎
For each entry entry in new chain, in reverse order, run these substeps:
</p>

		<ol>
			<li>
~IF［
%~entry は `dialog$e 要素である
］
⇒
%~entry ~LET %~entry が属する`~dialog群$が`指名する被focus~dialog$
◎
If entry is a dialog element: let entry be the designated focused dialog of its dialog group.
</li>
			<li>

<div class="p">
<p>
~IF［
%~entry は`~focus可能~域$である
］：
</p>
<ol><li>%所有者 ~LET %~entry の`所有者$
</li><li>%所有者 が`指名する被focus域$ ~SET %~entry
</li><li>%所有者 が`指名する被focus~dialog$ ~SET ε
</li></ol>
◎
If entry is a focusable area: designate entry as the focused area of the control group. If its control group's owner object is also a dialog group manager, then let there be no designated focused dialog in that dialog group.
</div>


<p class="note">注記：
%~entry は `dialog$e 要素であると同時に，`~focus可能~域$であることもあり得る
— その場合、 %~entry 自身が %所有者 になる。
◎
It is possible for entry to be both a dialog element and a focusable area, in which case it is its own control group owner object.
</p>

			</li>
			<li>
%~focus~event標的 ~LET %~entry に応じて［
要素であるならば  %~entry ／
`文書$であるならば その `Window$I ~obj ／
~ELSE_ ~NULL
］
◎
If entry is an element, let focus event target be entry.
◎
If entry is a Document object, let focus event target be that Document object's Window object.
◎
Otherwise, let focus event target be null.
</li>
			<li>
%関係する標的 ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%~entry ~EQ %新~鎖 内の最後の~entry
］~AND［
%~entry は`要素$である
］~AND［
%旧~鎖 内の最後の~entryは`要素$である
］
⇒
%関係する標的 ~SET %旧~鎖 内の最後の~entry
◎
If entry is the last entry in new chain, and entry is an Element, and the last entry in old chain is also an Element, then let related focus target be the last entry in old chain. Otherwise, let related focus target be null.
</li>
			<li>
<p>
~IF［
%~focus~event標的 ~NEQ ~NULL
］
⇒
%~focus~event標的 に向けて `~focus~eventを発火する$( `focus$et, %関係する標的 )
◎
If focus event target is not null, fire a focus event named focus at focus event target, with related focus target as the related target.
</p>


<p class="note">注記：
~eventは発火されない事例もある
— 例えば、 %~entry は［
`~focus可能な図形$ ／ 可scroll領域 ／ `表示域$
］であるとき。
◎
In some cases, e.g. if entry is an area element's shape, a scrollable region, or a viewport, no event is fired.
</p>

			</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
%要素 に向けて
`~focus~eventを発火する@
ときは、所与の
( 名前 %e, 関係する標的 %r )
に対し，
%要素 に向けて 次のように初期化された~eventを`発火-$する
⇒＃
`FocusEvent$I を利用する,
名前 %e,
`relatedTarget$m 属性 ~SET %r,
`view$m 属性 ~SET %要素 の`~node文書$の `Window$I ~obj,
`~composed~flag$ ~SET ~ON
◎
To fire a focus event named e at an element t with a given related target r, fire an event named e at t, using FocusEvent, with the relatedTarget attribute initialized to r, the view attribute initialized to t's node document's Window object, and the composed flag set.
</p>


<hr>

<p class="algo-head">
~UAは、`~top-level閲覧文脈$内で~key~event %~event を届けるときは、次の手続きを走らせ~MUST：
◎
When a key event is to be routed in a top-level browsing context, the user agent must run the following steps:
</p>

<ol>
	<li>
%標的~域 ~LET `現在の被focus域$
◎
Let target area be the currently focused area of the top-level browsing context.
</li>
	<li>
%標的~node ~LET ［
%標的~域 は`~focus可能~域$ならば %標的~域 の`~DOM~anchor$ ／
~ELSE_ %標的~域
］
◎
If target area is a focusable area, let target node be target area's DOM anchor. Otherwise, target area is a dialog; let target node be target area.
</li>
	<li>
~IF［
%標的~node は`文書$である
］
⇒
%標的~node ~SET ［
%標的~node の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %標的~node の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %標的~node
］
◎
If target node is a Document that has a body element, then let target node be the body element of that Document.
◎
Otherwise, if target node is a Document object that has a non-null document element, then let target node be that document element.
</li>
	<li>
<p>
~IF［
%標的~node は`不活$である
］
⇒
~RET
◎
If target node is not inert, then:
</p>

<p class="note">注記：
`現在の被focus域$は`不活$の場合もある
— 例えば`~modal~dialogが示され$ていて，その `dialog$e 要素が`不活$にされているとき。
それは，~appにおける~logicの誤りによる可能性が高いが。
◎
It is possible for the currently focused area of a top-level browsing context to be inert, for example if a modal dialog is shown, and then that dialog element is made inert. It is likely to be the result of a logic error in the application, though.
</p>
	<li>
%canHandle ~LET %標的~node に向けて %~event を`配送-$した結果
◎
Let canHandle be the result of dispatching the key event at target node.
</li>
	<li>
~IF［
%canHandle ~EQ ~T
］
⇒
%標的~域 に %~event を取扱わせる
— これは、 %標的~node に向けて`~click~eventを発火する$ことも含み得る。
◎
If canHandle is true, then let target area handle the key event. This might include firing a click event at target node.
</li>
</ol>

<hr>

<p class="algo-head">
所与の`文書$ %標的 は、所与の時点で，次の手続きが ~T を返すならば
`~focusを得ている@
とされる：
◎
The has focus steps, given a Document object target, are as follows:
</p>

<ol>
	<li>
%候補 ~LET %標的 が`属する閲覧文脈$の`~top-level閲覧文脈$にて`作動中の文書$
<!-- ＊原文抜け “作動中の” -->
◎
Let candidate be the Document of the top-level browsing context.
</li>
	<li>
~IF［
%候補 ~EQ %標的
］
⇒
~RET ~T
◎
If candidate is target, return true.
</li>
	<li>
<p>
~WHILE 無条件：
</p>

		<ol>
			<li>
~IF［
%候補 が`指名する被focus~dialog$ %D ~NEQ ε
］
⇒
%候補 ~LET %D
◎
If candidate has a dialog group with a designated focused dialog of the dialog group, then let candidate be the designated focused dialog of the dialog group, and redo this step.
</li>
			<li>
<p>
~ELIF［
%候補 が`指名する被focus域$ %F ~NEQ ε
］~AND［
%F は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］：
</p>

				<ol>
					<li>
%文書 ~LET %B にて`作動中の文書$
</li>
					<li>
~IF［
%文書 ~EQ %標的
］
⇒
~RET ~T
</li>
					<li>
%候補 ~LET %文書
</li>
				</ol>
◎
Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container with a non-null nested browsing context, and the active document of that browsing context container's nested browsing context is target, then return true.
◎
Otherwise, if candidate has a non-empty control group, and the designated focused area of the control group is a browsing context container with a non-null nested browsing context, then let candidate be the active document of that browsing context container's nested browsing context, and redo this step.
</li>
			<li>
~ELSE
⇒
~RET ~F
◎
Otherwise, return false.
</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="sequential-focus-navigation">
<h4 title="Sequential focus navigation">6.4.5. 逐次的~focus~navi</h4>


<p>
所与の`~control群$に属する`~focus可能~域$のうち いくつかのものは，
`逐次的~focus~navi順序@
により順序付けられ、`逐次的~focus~navi$を介して到達できるとされる。
この順序は、`~focus可能~域~順序$に従う必要はない。
この順序から外された`~focus可能~域$は、`逐次的~focus~navi$を介して到達-不能になることになる。
◎
Each control group has a sequential focus navigation order, which orders some or all of the focusable areas in the control group relative to each other. The order in the sequential focus navigation order does not have to be related to the order in the control group itself. If a focusable area is omitted from the sequential focus navigation order of its control group, then it is unreachable via sequential focus navigation.
</p>


<p>
逐次的~focus~naviには
`逐次的~focus~naviの始点@
もある。
それは、初期~時には ε （未設定）とする。
~UAは、利用者がそれを移動すべく指示したときに，この始点を設定してよい。
◎
There can also be a sequential focus navigation starting point. It is initially unset. The user agent may set it when the user indicates that it should be moved.
</p>


<p class="example">
例えば~UAは、利用者が文書の内容を~clickしたときに，その~click位置に設定することもできる。
◎
For example, the user agent could set it to the position of the user's click if the user clicks on the document contents.
</p>

<div class="p">
<p class="algo-head">
~UAは、利用者から~focusを移動するよう要請されたとき
— より詳細には：
</p>

<ul><li>ある`~top-level閲覧文脈$ %top 内で，
</li><li>
	<ul ><li>(A) %top の`現在の被focus域$から, または
	</li><li>(B) %top の外側（例えば，~browserの所在bar）から 先ず %top へ~focusを移動した上で，
	</li></ul>
</li><li>ある %方向 ［
`前方^i または `後方^i
］へ，
</li></ul>

<p>
~focusを移動するよう要請されたときには（例えば，~tab~keyを押すことによる既定の動作として）、以下の~algoを利用し~MUST：
</p>

<p class="note">注記：
概して、［
<kbd><kbd>tab</kbd></kbd> ／
<kbd><kbd>shift</kbd>+<kbd>tab</kbd></kbd>
］を押すことは［
前方／後方
］にある~controlへ移動することを要請する。
</p>


◎
When the user requests that focus move from the currently focused area of a top-level browsing context to the next or previous focusable area (e.g. as the default action of pressing the tab key), or when the user requests that focus sequentially move to a top-level browsing context in the first place (e.g. from the browser's location bar), the user agent must use the following algorithm:
</div>

<ol>
	<li>
%始点 ~LET 上述の［
(A) ならば %top の`現在の被focus域$ ／ (B) ならば %top
］
◎
Let starting point be the currently focused area of a top-level browsing context, if the user requested to move focus sequentially from there, or else the top-level browsing context itself, if the user instead requested to move focus from outside the top-level browsing context.
</li>
	<li>
%~focus始点 ~LET `逐次的~focus~naviの始点$
◎
↓</li>
	<li>
~IF［
%~focus始点 ~NEQ ε
］~AND［
%~focus始点 は %始点 の内側にある
］
⇒
%始点 ~LET %~focus始点
◎
If there is a sequential focus navigation starting point defined and it is inside starting point, then let starting point be the sequential focus navigation starting point instead.
◎
Let direction be forward if the user requested the next control, and backward if the user requested the previous control.
◎
Typically, pressing tab requests the next control, and pressing shift+tab requests the previous control.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
<p>
%選定法 ~LET ［
次のいずれかが満たされるならば `逐次的^i ／
~ELSE_ `~DOM順^i
］：
</p>

<ul ><li>%始点 は`閲覧文脈$である
</li><li>%始点 ~IN ある`~control群$の`逐次的~focus~navi順序$
</li></ul>

◎
Loop: Let selection mechanism be sequential if the starting point is a browsing context or if starting point is in its control group's sequential focus navigation order.
◎
Otherwise, starting point is not in its control group's sequential focus navigation order; let selection mechanism be DOM.
</li>
			<li>
%候補 ~LET
`逐次的~navi探索~algo$( %始点, %方向, %選定法 )
◎
Let candidate be the result of running the sequential navigation search algorithm with starting point, direction, and selection mechanism as the arguments.
</li>
			<li>
~IF［
%候補 ~NEQ ~NULL
］
⇒＃
`~objを~focusする$( %候補 )；
~RET
◎
If candidate is not null, then run the focusing steps for candidate and return.
</li>
			<li>
`逐次的~focus~naviの始点$ ~SET ε
◎
Otherwise, unset the sequential focus navigation starting point.
</li>
			<li>
<p>
~IF［
%始点 ~EQ %top
］~OR［
%始点 は %top 内の`~focus可能~域$である
］：
◎
If starting point is the top-level browsing context, or a focusable area in the top-level browsing context,＼
</p>

				<ol>
					<li>
<p>
~IF［
~UAには、自前の~focus可能な~controlがある
］
⇒
~UAは、次を行うべきである
⇒
%方向 を遵守しつつ，~focusを自前の~focus可能な~controlのいずれかに適切に転送する
◎
the user agent should transfer focus to its own controls appropriately (if any), honouring direction, and then return.
</p>

<p class="example">
例えば， %方向 ~EQ `後方^i の場合、［
~browserの具現化~域の直前にある~focus可能な~control
］に，~focusすることになる。
◎
For example, if direction is backward, then the last focusable control before the browser's rendering area would be the control to focus.
</p>
					</li>
					<li>
<p>
~ELSE
⇒
~UAは、次を行ってもよい
⇒＃
%始点 ~SET %top；
~CONTINUE
</p>

<p class="example">
~kiosk~mode~browserなど、自前の~focus可能な~controlがない~UAもあり得る。
</p>

◎
If the user agent has no focusable controls — a kiosk-mode browser, for instance — then the user agent may instead restart these steps with the starting point being the top-level browsing context itself.
</li>
					<li>
~RET
◎
↑</li>
				</ol>
			</li>
			<li>
~ELSE（ %始点 は`入子の閲覧文脈$ %B 内の`~focus可能~域$である）
⇒
%始点 ~LET %B を`入子にしている閲覧文脈~容器$
◎
Otherwise, starting point is a focusable area in a nested browsing context. Let starting point be that nested browsing context's browsing context container, and return to the step labeled loop.
</li>
		</ol>
	</li>
</ol>



<p class="algo-head">
`逐次的~navi探索~algo@
は、所与の
( %始点, %方向, %選定法 )
に対し，次を走らす：
◎
The sequential navigation search algorithm consists of the following steps. This algorithm takes three arguments: starting point, direction, and selection mechanism.
</p>

<div >


<ol>
	<li>
<p>
%候補~集合 ~LET %始点 に応じて，次の下位手続きを走らせた結果：
</p>
		<dl class="switch">
			<dt>`閲覧文脈$である場合</dt>
			<dd>
				<ol>
					<li>
%D ~LET %始点 にて`作動中の文書$
</li>
					<li>
~WHILE %D が`指名する被focus~dialog$ ~NEQ ε
⇒
%D ~SET %D が`指名する被focus~dialog$
</li>
					<li>
~RET %D の`~control群$†1
</li>
				</ol>
			</dd>

			<dt>`~focus可能~域$である場合</dt>
			<dd>
				<ol>
					<li>
%G ~LET %始点 が属する`~control群$†2
</li>
					<li>
~RET %選定法 に応じて［
`~DOM順^i ならば %G ／
`逐次的^i ならば %G の`逐次的~focus~navi順序$†3
］
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
<p>
%候補~集合 ~SET %候補~集合 内の`~focus可能~域$ %F のうち，次の両者とも満たすもの†4：
</p>

<ul ><li>%F の`~DOM~anchor$は`不活$でない
</li><li>%F ~IN %F が属する`~control群$の`逐次的~focus~navi順序$
</li></ul>
	</li>
	<li>
<p>
~IF［
%始点 は`~focus可能~域$である
］：
</p>

		<ol>
			<li>
<p>
~Assert：
%始点 ~IN %G
</p>

<p class="note">注記：
%始点 ~NIN %G になるような場合に、この手続きが［
%選定法 ~SET `逐次的^i
］にされて呼出されることはない。
</p>
<!-- ↓ class="note" -->
			</li>
			<li>
%候補~集合 ~SET %候補~集合 内の~focus可能~域のうち， %方向 に応じて
⇒
`前方^i ならば  %始点 に後続しているもの／
`後方^i ならば %始点 に先行しているもの
</li>
		</ol>
	</li>
	<li>
~IF［
%候補~集合 は空である
］
⇒
~RET ~NULL
</li>
	<li>
%候補 ~SET %候補~集合 内の~focus可能~域のうち， %方向 に応じて
⇒
`前方^i ならば 最初のもの ／
`後方^i ならば 最後のもの
</li>
	<li>
<p>
~IF［
%候補 は ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である
］：
</p>
		<ol>
			<li>
%新~候補 ~LET
`逐次的~navi探索~algo$( %B, %方向, `逐次的^i )
</li>
			<li>
~IF［
%新~候補 ~NEQ ~NULL
］
⇒
~RET %新~候補
</li>
			<li>
~RET
`逐次的~navi探索~algo$( %候補, %方向, %選定法 )
</li>
		</ol>
	</li>
	<li>
~RET %候補
</li>
</ol>


<div class="trans-note">
<p>【
簡明にするため、この手続きの構成は，原文から大きく違えている。
原文では、この手続きにて次の用語が定義されている：
</p>

<ul ><li>†1 を指して，
`首~control群@
という。
</li><li>†2 を指して，
`~home~control群@
という。
</li><li>†3 を指して，
`~home逐次的~focus~navi順序@
という。
</li><li>†4 を指して，
`相応しい逐次的~focus可能~域@
という。
</li></ul>

<p>
が、無用に煩雑になるだけで，（現時点では）他からも参照されていないので、この訳では利用しない。
】</p>
</div>

<ol lang="en">

	<li>
<p>
Pick the appropriate cell from the following table, and follow the instructions in that cell.

<p>
The appropriate cell is the one that is from the column whose header describes direction and from the first row whose header describes starting point and selection mechanism.


<table><thead><tr><th>
<th>direction is forward
<th>direction is backward
</thead>
<tbody><tr><th>
starting point is a browsing context
<td>
Let candidate be the first suitable sequentially focusable area in starting point's active document's primary control group, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in starting point's active document's primary control group, if any; or else null
<tr><th>
selection mechanism is DOM
<td>
Let candidate be the first suitable sequentially focusable area in the home control group following starting point, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in the home control group preceding starting point, if any; or else null
<tr><th>
selection mechanism is sequential
<td>
Let candidate be the first suitable sequentially focusable area in the home sequential focus navigation order following starting point, if any; or else null
<td>
Let candidate be the last suitable sequentially focusable area in the home sequential focus navigation order preceding starting point, if any; or else null
</tbody></table>

<p>
A suitable sequentially focusable area is a focusable area whose DOM anchor is not inert and that is in its control group's sequential focus navigation order.
<p>
The primary control group of a control group owner object X is the control group of X if X has no dialog group or if its dialog group has no designated focused dialog of the dialog group, otherwise, it is the primary control group of X's dialog group's designated focused dialog of the dialog group.
<p>
The home control group is the control group to which starting point belongs.
<p>
The home sequential focus navigation order is the sequential focus navigation order to which starting point belongs.
<p class="note">
The home sequential focus navigation order is the home control group's sequential focus navigation order, but is only used when the starting point is in that sequential focus navigation order (when it's not, selection mechanism will be DOM).
</p>
	<li>
<p>
If candidate is a browsing context container with a non-null nested browsing context, then let new candidate be the result of running the sequential navigation search algorithm with candidate's nested browsing context as the first argument, direction as the second, and sequential as the third.
<p>
If new candidate is null, then let starting point be candidate, and return to the top of this algorithm. Otherwise, let candidate be new candidate.
	<li>
Return candidate.

</ol>
</div>

			</section>
			<section id="focus-management-apis">
<h4 title="Focus management APIs">6.4.6. ~focus管理~API</h4>

<pre class="idl">
dictionary `FocusOptions@I {
  boolean `preventScroll$m = false;
};
</pre>

<dl class="domintro">
	<dt>%document . `activeElement$m</dt>
	<dd>
文書~内の要素のうち，
~key~eventが
それを経て／それに向けて
届けられることになるような，最も深い要素を返す。
これは概ね、文書~内の被focus要素になる。
◎
Returns the deepest element in the document through which or to which key events are being routed. This is, roughly speaking, the focused element in the document.
</dd>
	<dd>
この~APIの目的においては、`子~閲覧文脈$が~focusされるときには，それを`入子にしている閲覧文脈~容器$が`親~閲覧文脈$内で
<a href="#bc-focus-ergo-bcc-focus">~focusされる</a>。
例えば、利用者が，~focusを `iframe$e 内のある~text~controlに移動させたとき、その `iframe$e が，その`~node文書$上の `activeElement$m から返される要素になる。
◎
For the purposes of this API, when a child browsing context is focused, its browsing context container is focused in the parent browsing context. For example, if the user moves the focus to a text control in an iframe, the iframe is the element returned by the activeElement API in the iframe's node document.
</dd>

	<dt>%document . `hasFocus()$m</dt>
	<dd>
~key~eventは，［
%document へ, または %document を経て届けられている
］ならば ~T を返す。
~ELSE_ ~F を返す。
これは概ね、~focusされている［
当の文書, または
その内側に入子にされている文書
］に対応する。
◎
Returns true if key events are being routed through or to the document; otherwise, returns false. Roughly speaking, this corresponds to the document, or a document nested inside this one, being focused.
</dd>

	<dt>%window . `focus()$m</dt>
	<dd>
~focusを %window の`閲覧文脈$（もしあれば）に移動させる。
◎
Moves the focus to the window's browsing context, if any.
</dd>

	<dt>%element . `~focus0$m([ { `preventScroll$m: true } ])</dt>
	<dd>
~focusを %element に移動させる。
◎
Moves the focus to the element.
</dd>
	<dd>
要素が ある`閲覧文脈$ %B を`入子にしている閲覧文脈~容器$である場合、~focusは，代わりに %B へ移動される。
◎
If the element is a browsing context container, moves the focus to the nested browsing context instead.
</dd>
	<dd>
既定では、この~methodはまた，要素を~viewの中へ~scrollする。
`preventScroll$m ~optionを供して ~T に設定すれば、この挙動は防止される。
◎
By default, this method also scrolls the element into view. Providing the preventScroll option and setting it to true prevents this behavior.
</dd>

	<dt>%element . `~blur0()$m</dt>
	<dd>
~focusを`表示域$に移動させる。
この~methodは、利用しないことが奨励される。
`表示域$を~focusしたければ、`文書$の`文書~要素$上で，
`~focus0()$m ~methodを~callすること。
◎
Moves the focus to the viewport. Use of this method is discouraged; if you want to focus the viewport, call the focus() method on the Document's document element.
</dd>
	<dd>
~focus環が目障りであっても、~focus環を隠すためにこの~methodを利用しないこと。
代わりに、~CSS規則で `outline$p ~prop（外形線）を上書きした上で，~focusされる要素を示すような他の仕方を供すること。
そのような代替の~focus時の~styleを可用にできなかった場合、~keyboardを首に利用して頁を~navigateしている人や，~navigateし易くするため~focus外形線を利用している弱視者にとっては、頁の使い勝手がすこぶる悪くなることに留意すること。
◎
Do not use this method to hide the focus ring if you find the focus ring unsightly. Instead, use a CSS rule to override the 'outline' property, and provide a different way to show what element is focused. Be aware that if an alternative focusing style isn't made available, the page will be significantly less usable for people who primarily navigate pages using a keyboard, or those with reduced vision who use focus outlines to help them navigate the page.
</dd>
	<dd class="example">
<p>
例えば、~linkから外形線を隠す代わりに，黄色の背景を利用して~focusを指示したければ、次も利用できる：
◎
For example, to hide the outline from links and instead use a yellow background to indicate focus, you could use:
</p>

<pre>
:link:focus, :visited:focus { outline: none; background: yellow; color: black; }
</pre>

	</dd>
</dl>


<dl class="idl-def">
	<dt>`activeElement@m</dt>
	<dd>
<p>
取得子は、次を走らせた結果を返さ~MUST：
◎
The activeElement attribute on Document objects must return the value returned by the following steps:
</p>

	<ol>
			<li>
%候補 ~LET 此れ
◎
Let candidate be the Document on which the method was invoked.
</li>
			<li>
~WHILE［
%候補 の`~dialog群$ %G ~NEQ ε
］~AND［
%G が`指名する被focus~dialog$ %D ~NEQ ε
］
⇒
%候補 ~LET %D
◎
If candidate has a dialog group with a designated focused dialog of the dialog group, then let candidate be the designated focused dialog of the dialog group, and redo this step.
</li>
			<li>
~IF［
%候補 の`~control群$ %G は空でない
］
⇒
%候補 ~LET %G が`指名する被focus域$
◎
If candidate has a non-empty control group, let candidate be the designated focused area of the control group.
</li>
			<li>
~IF［
%候補 は`~focus可能~域$である
］
⇒
%候補 ~LET %候補 の`~DOM~anchor$
◎
If candidate is a focusable area, let candidate be candidate's DOM anchor.
</li>
			<li>
~IF［
%候補 は`文書$である
］
⇒
~RET［
%候補 の`~body要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ %候補 の`文書~要素$ ~NEQ ~NULL ならば それ ／
~ELSE_ ~NULL
］
◎
If candidate is a Document that has a body element, then let candidate be the body element of that Document.
◎
Otherwise, if candidate is a Document with a non-null document element, then let candidate be that document element.
◎
Otherwise, if candidate is a Document, then let candidate be null.
</li>
			<li>
~RET %候補
◎
Return candidate.
</li>
		</ol>
	</dd>

	<dt>`hasFocus()@m</dt>
	<dd>
被呼出時には、［
此れが`~focusを得ている$ならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The hasFocus() method on the Document object, when invoked, must return the result of running the has focus steps with the Document object as the argument.
</dd>

	<dt>`Window$I ~obj上の `focus()@m</dt>
	<dd>
被呼出時には、次を走らせ~MUST
⇒
`~objを~focusする$( 此れの`閲覧文脈$ )
◎
The focus() method on the Window object, when invoked, must run the focusing steps with the Window object's browsing context.＼
</dd>
	<dd>
加えて，此れの`閲覧文脈$が`~top-level閲覧文脈$である場合、~UAには，［［
頁が~focusを獲得しようと試みていることを，利用者に向けて指示する
］ような，何らかの類の通知
］を誘発することが奨励される。
◎
Additionally, if this browsing context is a top-level browsing context, user agents are encouraged to trigger some sort of notification to indicate to the user that the page is attempting to gain focus.
</dd>

	<dt>`Window$I ~obj上の `blur()@m</dt>
	<dd>
被呼出時には、［
~scriptは、利用者が，おそらく［
当の `Window$I ~objの`閲覧文脈$の内容に対する関心
］を失ったものと見込んでいる
］が，再び関心が向けられるかもしれないことを、~hintとして~UAに供する。
◎
The blur() method on the Window object, when invoked, provides a hint to the user agent that the script believes the user probably is not currently interested in the contents of the browsing context of the Window object on which the method was invoked, but that the contents might become interesting again in the future.
</dd>
	<dd>
~UAには、この~methodの~callを全面的に無視することが奨励される。
◎
User agents are encouraged to ignore calls to this blur() method entirely.
</dd>
	<dd class="note">注記：
歴史的に、
`focus()$m ／ `blur()$m
~methodは、実際には，~system~levelの~focus
— `閲覧文脈$を包含している~system~widget（例：~tabや~window）の~focus —
にも影響していたが、この挙動は，利用者をないがしろに敵対的~siteから広範に濫用されている。
◎
Historically, the focus() and blur() methods actually affected the system-level focus of the system widget (e.g. tab or window) that contained the browsing context, but hostile sites widely abuse this behavior to the user's detriment.
</dd>

	<dt>要素~上の `~focus0(options)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The focus(options) method on elements, when invoked, must run the following steps:
</p>
		<ol>
			<li>
~IF［
此れの`~focus~lock~flag$ ~EQ ~ON
］
⇒
~RET
◎
If the element is marked as locked for focus, then return.
</li>
			<li>
此れの
`~focus~lock~flag@
~SET ~ON
◎
Mark the element as locked for focus.
</li>
			<li>
`~objを~focusする$( 此れ )
◎
Run the focusing steps for the element.
</li>
			<li>
~IF［
%options の
`preventScroll@m
~memberの値 ~EQ ~F
］
⇒
次を与える下で，
此れを`~viewの中へ~scrollする$
⇒＃
~scrollの挙動 ~SET `auto^l, 
塊~flow方向~位置 ~SET ~UAにより定義される値,
行内~基底~方向~位置 ~SET ~UAにより定義される値
◎
If the value of the preventScroll dictionary member of options is false, then scroll the element into view with scroll behavior "auto", block flow direction position set to a UA-defined value, and inline base direction position set to a UA-defined value.
</li>
			<li>
此れの`~focus~lock~flag$ ~SET ~OFF
◎
Unmark the element as locked for focus.
</li>
		</ol>
	</dd>

	<dt>要素~上の `~blur0()@m</dt>
	<dd>
被呼出時には、次を走らすべきである
⇒
`~objを~unfocusする$( 此れ )
◎
The blur() method, when invoked, should run the unfocusing steps for the element on which the method was called.＼
</dd>
	<dd>
~UAは、使い勝手の理由から，選択的に または一様に，この~methodの~callを無視してよい。
◎
User agents may selectively or uniformly ignore calls to this method for usability reasons.
</dd>
	<dd class="example">
例えば、ただ美観の理由で， `~blur0()$m ~methodを利用して無思慮に~focus環が除去された場合、~keyboard利用者からは，頁の使い勝手は悪くなるであろう。
この~methodの~callを無視すれば、~keyboard利用者でも頁と対話できるようになる。
◎
For example, if the blur() method is unwisely being used to remove the focus ring for aesthetics reasons, the page would become unusable by keyboard users. Ignoring calls to this method would thus allow keyboard users to interact with the page.
</dd>
</dl>

			</section>
		</section>
		<section id="assigning-keyboard-shortcuts">
<h3 title="Assigning keyboard shortcuts">6.5. ~keyboard~shortcutの割当法</h3>

			<section id="introduction-9">
<h4 title="Introduction">6.5.1. 序論</h4>

~INFORMATIVE

<p>
作動化-／~focusされ得るような各~要素には、
`accesskey$a 属性を利用して，それを作動化させる単独の~key組合せを割当できる。
◎
Each element that can be activated or focused can be assigned a single key combination to activate it, using the accesskey attribute.
</p>


<p>
正確な~shortcutは、
`accesskey$a 属性から供される情報を基に，利用者の~keyboardについての情報
— ［
~platform上にすでに存在する ／
頁~上で他に指定されている
］~shortcutなど —
に基づいて、~UAにより決定される
◎
The exact shortcut is determined by the user agent, based on information about the user's keyboard, what keyboard shortcuts already exist on the platform, and what other shortcuts have been specified on the page, using the information provided in the accesskey attribute as a guide.
</p>


<p>
`accesskey$a 属性~内にいくつもの代替を供すれば、作者は，多様な入力~装置にわたり関連する~keyboard~shortcutが可用になることを確保できる。
◎
In order to ensure that a relevant keyboard shortcut is available on a wide variety of input devices, the author can provide a number of alternatives in the accesskey attribute.
</p>


<p>
各~代替は、普通字や数字などの単独の文字からなる。
◎
Each alternative consists of a single character, such as a letter or digit.
</p>


<p>
~UAは，利用者に~keyboard~shortcutの~listを供せるが、作者にもそうすることが奨励される。
`accessKeyLabel$m ~IDL属性は、~UAにより割当された実際の~key組合せを表現している文字列を返す。
◎
User agents can provide users with a list of the keyboard shortcuts, but authors are encouraged to do so also. The accessKeyLabel IDL attribute returns a string representing the actual key combination assigned by the user agent.
</p>

<div class="example">

<p>
次の例には、~shortcut~keyを利用して呼出せる~buttonが供されている。
ここでは、~full~keyboard用に~key "C" ，および
十keyしかない場合のために別の~key "1" も供されている。
◎
In this example, an author has provided a button that can be invoked using a shortcut key. To support full keyboards, the author has provided "C" as a possible key. To support devices equipped only with numeric keypads, the author has provided "1" as another possibly key.
</p>


<pre>
&lt;input type=button value=Collect onclick="collect()"
       <strong>accesskey="C 1"</strong> id=c&gt;
</pre>

</div>

<div class="example">

<p>
どの~shortcut~keyがあるか，利用者に伝えるため、次の~scriptでは，~buttonの~labelに ~key組合せを明示的に追加する：
<!-- opted to＊ -->
◎
To tell the user what the shortcut key is, the author has this script here opted to explicitly add the key combination to the button's label:
</p>


<pre>
function addShortcutKeyLabel(button) {
<strong>  if (button.accessKeyLabel != '')
    button.value += ' (' + button.accessKeyLabel + ')';</strong>
}
addShortcutKeyLabel(document.getElementById('c'));
</pre>


<p>
同じ~key組合せであっても、~browserが示す~labelは，各~platformに普及している規約に応じて異なり得る。
例えば、~key組合せが［
Control ＋ Shift ＋ C
］ならば、［
Windows ~browserでは `Ctrl+Shift+C^samp ／
Mac ~browserでは `^⇧C^samp ／
Emacs ~browserでは `C-C^samp
］のように表示されるであろう。
同様に、~keyの組合せが［
Alt ~key ＋ Escape ~key
］であれば、［
Windows では `Alt+Esc^samp ／
Mac では `⌥⎋^samp ／
Emacs ~browserでは `M-ESC^samp または `ESC ESC^samp
］が利用されるであろう。
◎
Browsers on different platforms will show different labels, even for the same key combination, based on the convention prevalent on that platform. For example, if the key combination is the Control key, the Shift key, and the letter C, a Windows browser might display "Ctrl+Shift+C", whereas a Mac browser might display "^⇧C", while an Emacs browser might just display "C-C". Similarly, if the key combination is the Alt key and the Escape key, Windows might use "Alt+Esc", Mac might use "⌥⎋", and an Emacs browser might use "M-ESC" or "ESC ESC".
</p>


<p>
したがって一般に、 `accessKeyLabel$m ~IDL属性から返される値を構文解析しようと試みるのは，賢明とは言えない。
◎
In general, therefore, it is unwise to attempt to parse the value returned from the accessKeyLabel IDL attribute.
</p>

</div>


			</section>
			<section id="the-accesskey-attribute">
<h4 title="The accesskey attribute">6.5.2. `accesskey^a 属性</h4>


<p>
`accesskey$a 内容~属性は、すべての`~HTML要素$に設定できる。
この属性の値は、要素を［
作動化する／~focusする
］ための~keyboard~shortcutを作成する基になる情報として，~UAにより利用される。
◎
All HTML elements may have the accesskey content attribute set. The accesskey attribute's value is used by the user agent as a guide for creating a keyboard shortcut that activates or focuses the element.
</p>


<p>
この属性に指定する値は、`大小区別$される`一意な~tokenからなる空白区切りの有順序~集合$であって、各~tokenは，正確に 1 個の符号位置で~MUST。
◎
If specified, the value must be an ordered set of unique space-separated tokens that are case-sensitive, each of which must be exactly one code point in length.
</p>

<div class="example">

<p>
次の例では、各~linkに~access~keyが割当されている
— ~siteに馴染んでいる~keyboard利用者は，関連する頁に素早く~navigateできるようになる：
◎
In the following example, a variety of links are given with access keys so that keyboard users familiar with the site can more quickly navigate to the relevant pages:
</p>


<pre>
&lt;nav&gt;
 &lt;p&gt;
  &lt;a
    title="Consortium Activities"
    accesskey="A"
    href="/Consortium/activities"
  &gt;Activities&lt;/a&gt; |
  &lt;a
    title="Technical Reports and Recommendations"
    accesskey="T"
    href="/TR/"
  &gt;Technical Reports&lt;/a&gt; |
  &lt;a
    title="Alphabetical Site Index"
    accesskey="S"
    href="/Consortium/siteindex"
  &gt;Site Index&lt;/a&gt; |
  &lt;a
    title="About This Site"
    accesskey="B"
    href="/Consortium/"
  &gt;About Consortium&lt;/a&gt; |
  &lt;a
    title="Contact Consortium"
    accesskey="C"
    href="/Consortium/contact"
  &gt;Contact&lt;/a&gt;
 &lt;/p&gt;
&lt;/nav&gt;
</pre>

<!-- 
<nav>
 <p>
  <a title="Consortium Activities" accesskey="A" href="/Consortium/activities">Activities</a> |
  <a title="Technical Reports and Recommendations" accesskey="T" href="/TR/">Technical Reports</a> |
  <a title="Alphabetical Site Index" accesskey="S" href="/Consortium/siteindex">Site Index</a> |
  <a title="About This Site" accesskey="B" href="/Consortium/">About Consortium</a> |
  <a title="Contact Consortium" accesskey="C" href="/Consortium/contact">Contact</a>
 </p>
</nav>
-->

</div>

<div class="example">


<p>
次の例では、探索~欄に，可能な~access~keyとして
`s^l, `0^l
の 2 つがこの順で与えられている。
~full~keyboard装置を備えている~UAは、~shortcut~keyとして
<kbd><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>S</kbd></kbd>
選び取るであろう。
一方で，十keyしか備えていない装置~上の~UAは、~key
<kbd><kbd>0</kbd></kbd>
を選び取るであろう：
◎
In the following example, the search field is given two possible access keys, "s" and "0" (in that order). A user agent on a device with a full keyboard might pick Ctrl+Alt+S as the shortcut key, while a user agent on a small device with just a numeric keypad might pick just the plain unadorned key 0:
</p>


<pre>
&lt;form action="/search"&gt;
 &lt;label&gt;Search: &lt;input type="search" name="q" accesskey="s 0"&gt;&lt;/label&gt;
 &lt;input type="submit"&gt;
&lt;/form&gt;
</pre>

</div>

<div class="example">
<p>
次の例では、可能な~access~keyが~buttonに記述されている。
加えて，~UAが選択した~keyの組合せを告知するため、~scriptは，~buttonの~labelを更新しようと試行する。
◎
In the following example, a button has possible access keys described. A script then tries to update the button's label to advertise the key combination the user agent selected.
</p>


<pre>
&lt;input type=submit accesskey="N @ 1" value="Compose"&gt;
...
&lt;script&gt;
 function labelButton(button) {
   if (button.accessKeyLabel)
     button.value += ' (' + button.accessKeyLabel + ')';
 }
 var inputs = document.getElementsByTagName('input');
 for (var i = 0; i &lt; inputs.length; i += 1) {
   if (inputs[i].type == "submit")
     labelButton(inputs[i]);
 }
&lt;/script&gt;
</pre>

<p>
~buttonの~labelは、~UAに応じて，
`Compose (⌘N)^l にも `Compose (Alt+⇧+1)^l にもなり得る。
~UAが~keyを割当しなければ、 `Compose^l のみになる。
正確な文字列は、`割当されている~access~key$, および
~UAがその~key組合せをどう表現するかに依存する。
◎
On one user agent, the button's label might become "Compose (⌘N)". On another, it might become "Compose (Alt+⇧+1)". If the user agent doesn't assign a key, it will be just "Compose". The exact string depends on what the assigned access key is, and on how the user agent represents that key combination.
</p>

</div>

			</section>
			<section id="keyboard-shortcuts-processing-model">
<h4 title="Processing model">6.5.3. 処理~model</h4>


<p>
要素に
`割当されている~access~key@
とは、要素の `accesskey$a 内容~属性から導出される~key組合せである
— 初期~時には、どのような~access~keyも割当されては~MUST_NOT。
◎
An element's assigned access key is a key combination derived from the element's accesskey content attribute. Initially, an element must not have an assigned access key.
</p>


<p class="algo-head">
~UAは、要素の `accesskey$a 属性が［
設定- ／ 変更- ／除去-
］される度に、次の手続きを走らせて得られる~access~keyで，要素に`割当されている~access~key$を更新し~MUST：
◎
Whenever an element's accesskey attribute is set, changed, or removed, the user agent must update the element's assigned access key by running the following steps:
</p>

<ol>
	<li>
<p>
~IF［
要素は `accesskey$a 属性を有する
］
⇒
`~ASCII空白で分割する$( 属性の値 )
— その結果を成す~EACH ( %値 ) に対し：
◎
If the element has no accesskey attribute, then skip to the fallback step below.
◎
Otherwise, split the attribute's value on ASCII whitespace, and let keys be the resulting tokens.
◎
For each value in keys in turn, in the order the tokens appeared in the attribute's value, run the following substeps:
</p>

		<ol>
			<li>
~IF［
%値 を成す符号位置の個数 ~NEQ 1
］
⇒
~CONTINUE
◎
If the value is not a string exactly one code point in length, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 は~systemの~keyboard上のどの~keyにも対応しない
］
⇒
~CONTINUE
◎
If the value does not correspond to a key on the system's keyboard, then skip the remainder of these steps for this value.
</li>
			<li>
~IF［
%値 に対応する~keyと, ~zero個以上の修飾~keyとの組み合わせに，~access~keyとして利用できるものがある
］
⇒
~UAの任意選択で
⇒
~RET その~key組合せ
~FINGERPRINTING
◎
If the user agent can find a mix of zero or more modifier keys that, combined with the key that corresponds to the value given in the attribute, can be used as the access key, then the user agent may assign that combination of keys as the element's assigned access key and return. (This is a fingerprinting vector.)
</li>
		</ol>
	</li>
	<li>
~UAの任意選択で
⇒
~RET ~UAが選んだ~key組合せ
◎
Fallback: Optionally, the user agent may assign a key combination of its choosing as the element's assigned access key and then returnZ.
</li>
	<li>
~RET ~access~keyなし
◎
If this step is reached, the element has no assigned access key.
</li>
</ol>


<p>
要素に対し~access~keyを選択して割当した~UAは、要素の `accesskey$a 内容~属性が変更されるか，要素が別の`文書$へ移動されるまでは、要素に`割当されている~access~key$を変更するべきでない。
◎
Once a user agent has selected and assigned an access key for an element, the user agent should not change the element's assigned access key unless the accesskey content attribute is changed or the element is moved to another Document.
</p>


<div class="p">
<p>
`~commandを定義する$ような要素に対し，［
利用者が，それに`割当されている~access~key$に対応する~key組合せを押下げた
］ときは、~UAは，次のいずれも満たされるならば，その~commandの`動作$cFを誘発し~MUST：
</p>

<ul><li>~commandの`隠され状態$cF ~EQ ~F （可視である）
</li><li>~commandの`不能化~状態$cF ~EQ  ~F （可能化されている）
</li><li>要素は、`ある閲覧文脈に属する$`文書~内にある$
</li><li>要素, および そのどの先祖も， `hidden$a 属性を有さない
</li></ul>
◎
the element defines a command, the command's Hidden State facet is false (visible), the command's Disabled State facet is also false (enabled), the element is in a document that has a browsing context, and neither the element nor any of its ancestors has a hidden attribute specified, then the user agent must trigger the Action of the command.
</div>


<p class="note">注記：
~UAは、 `accesskey$a 属性を有する要素を，他の仕方で
— 例えば，特定の~key組合せに呼応して表示される~menu内に —
<a href="~HEinteractive#expose-commands-in-ui">公開することもある</a>。
◎
User agents might expose elements that have an accesskey attribute in other ways as well, e.g. in a menu displayed in response to a specific key combination.
</p> 

<hr>

<dl class="idl-def">
	<dt>`accessKey@m</dt>
	<dd>
`accesskey$a 内容~属性を`反映-$し~MUST。
◎
The accessKey IDL attribute must reflect the accesskey content attribute.
</dd>

	<dt>`accessKeyLabel@m</dt>
	<dd>
要素に`割当されている~access~key$が［
あれば それを表現する文字列 ／
なければ空~文字列
］を返さ~MUST。
◎
The accessKeyLabel IDL attribute must return a string that represents the element's assigned access key, if any. If the element does not have one, then the IDL attribute must return the empty string.
</dd>
</dl>

			</section>
		</section>
		<section id="editing-2">
<h3 title="Editing">6.6. 編集</h3>



			<section id="contenteditable">
<h4 title="Making document regions editable: The contenteditable content attribute">6.6.1. 文書の領域を編集-可能にする： `contenteditable^a 属性</h4>


<pre class="idl">
interface mixin `ElementContentEditable@I {
  [`CEReactions$] attribute DOMString `contentEditable$m;
  readonly attribute boolean `isContentEditable$m;
  [`CEReactions$] attribute DOMString `inputMode$m;
};
</pre>

<div class="p">
<p>
`contenteditable@a
内容~属性は`列挙ed属性$である。
とり得る~keywordの集合は
{ 空~文字列, `true^v, `false^v }
であり，次の状態に対応付けられる：
</p>

<dl class="switch">
	<dt>空~文字列</dt>
	<dt>`true^v</dt>
	<dd>
`~T^st 状態に対応付けられ、当の要素は編集-可能であることを指示する。
</dd>

	<dt>`false^v</dt>
	<dd>
`~F^st 状態に対応付けられ、当の要素は編集-可能でないことを指示する。
</dd>

	<dt>`値なし用の既定$</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`継承-^st 状態に対応付けられ、当の要素は，親が編集-可能ならそうなることを指示する。
</dd>
</dl>
◎
The contenteditable content attribute is an enumerated attribute whose keywords are the empty string, true, and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the inherit state, which is the missing value default (and the invalid value default).
◎
The true state indicates that the element is editable. The inherit state indicates that the element is editable if its parent is. The false state indicates that the element is not editable.
</div>


<div class="example">
<p>
例えば、頁~内に 新たな記事の投稿-用に `form$e と `textarea$e があり、利用者は~HTMLで記事を書くよう期待されているとする：
◎
For example, consider a page that has a form and a textarea to publish a new article, where the user is expected to write the article using HTML:
</p>

<pre>
&lt;form method=POST&gt;
 &lt;fieldset&gt;
  &lt;legend&gt;新着~記事&lt;/legend&gt;
  &lt;textarea name=article&gt;&amp;lt;p&gt;Hello world.&amp;lt;/p&gt;&lt;/textarea&gt;
 &lt;/fieldset&gt;
 &lt;p&gt;&lt;button&gt;投稿-&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>
<!-- 
<form method=POST>
 <fieldset>
  <legend>New article</legend>
  <textarea name=article>&lt;p>Hello world.&lt;/p></textarea>
 </fieldset>
 <p><button>Publish</button></p>
</form>
-->

<p>
~scriptが可能化されている下では、
`contenteditable$a 属性を利用して，
`textarea$e 要素を~rich~text~controlに置換することもできる：
◎
When scripting is enabled, the textarea element could be replaced with a rich text control instead, using the contenteditable attribute:
</p>

<pre>
&lt;form method=POST&gt;
 &lt;fieldset&gt;
  &lt;legend&gt;New article&lt;/legend&gt;
  &lt;textarea id=textarea name=article&gt;&amp;lt;p&gt;Hello world.&amp;lt;/p&gt;&lt;/textarea&gt;
  &lt;div id=div style="white-space: pre-wrap" hidden&gt;&lt;p&gt;Hello world.&lt;/p&gt;&lt;/div&gt;
  &lt;script&gt;
   let %textarea = document.getElementById("textarea");
   let %div = document.getElementById("div");
   %textarea.hidden = true;
   %div.hidden = false;
   %div.contentEditable = "true";
   %div.oninput = (%e) =&gt; {
     %textarea.value = %div.innerHTML;
   };
  &lt;/script&gt;
 &lt;/fieldset&gt;
 &lt;p&gt;&lt;button&gt;Publish&lt;/button&gt;&lt;/p&gt;
&lt;/form&gt;
</pre>

<p>
例えば，~linkを挿入-可能にする特色機能は、
`execCommand()$m ~APIを利用して, あるいは
`Selection$I ~APIと他の~DOM~APIを利用して実装できる。
`EXECCOMMAND$r `SELECTION$r `DOM$r
◎
Features to enable, e.g., inserting links, can be implemented using the document.execCommand() API, or using Selection APIs and other DOM APIs. [EXECCOMMAND] [SELECTION] [DOM]
</p>

</div>

<div class="example">
<p>
`contenteditable$a
属性は、効果を great にする【？】ためにも利用できる：
◎
The contenteditable attribute can also be used to great effect:
</p>

<pre>
&lt;!doctype html&gt;
&lt;html lang=en&gt;
&lt;title&gt;Live CSS editing!&lt;/title&gt;
&lt;style style=white-space:pre contenteditable&gt;
html { margin:.2em; font-size:2em; color:lime; background:purple }
head, title, style { display:block }
body { display:none }
&lt;/style&gt;
</pre>

</div>



<dl class="domintro">
	<dt>%element . `contentEditable$m [ = %value ]</dt>
	<dd>
`contenteditable$a 属性の状態に基づいて［
`true^l, `false^l,  `inherit^l
］いずれかを返す。
◎
Returns "true", "false", or "inherit", based on the state of the contenteditable attribute.
</dd>
	<dd>
設定してその状態を変更できる
— 新たな値がこれらの文字列のいずれでもない場合、
`SyntaxError$E 例外が投出される。
◎
Can be set, to change that state.
◎
Throws a "SyntaxError" DOMException if the new value isn't one of those strings.
</dd>

	<dt>%element . `isContentEditable$m</dt>
	<dd>
要素が編集-可能ならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is editable; otherwise, returns false.
</dd>
</dl>


<dl class="idl-def">
	<dt>`contentEditable@m</dt>
	<dd>
取得子は、要素~上の
`contenteditable$a 内容~属性の状態に応じて，次を返さ~MUST
⇒＃
`~T^st ならば `true^l ／
`~F^st ならば `false^l ／
~ELSE_ `inherit^l
◎
The contentEditable IDL attribute, on getting, must return the string "true" if the content attribute is set to the true state, "false" if the content attribute is set to the false state, and "inherit" otherwise.＼
</dd>
	<dd>
<p>
設定子は、`~ASCII小文字~化する$( 所与の値 ) の結果に応じて，次を走らせ~MUST：
</p>

<dl class="switch"
	><dt>`inherit^l
</dt><dd>内容~属性を除去する

</dd><dt>`true^l
</dt><dd>内容~属性 ~SET `true^l

</dd><dt>`false^l
</dt><dd>内容~属性 ~SET `false^l

</dd><dt>その他
</dt><dd>~THROW `SyntaxError$E
</dd></dl>

◎
On setting, if the new value is an ASCII case-insensitive match for the string "inherit" then the content attribute must be removed, if the new value is an ASCII case-insensitive match for the string "true" then the content attribute must be set to the string "true", if the new value is an ASCII case-insensitive match for the string "false" then the content attribute must be set to the string "false", and otherwise the attribute setter must throw a "SyntaxError" DOMException.
</dd>

	<dt>`isContentEditable@m</dt>
	<dd>
取得子は、［
次が満たされるならば ~T ／
~ELSE_ ~F
］を返さ~MUST
⇒
要素は`編集中の~host$または `編集-可能$である
◎
The isContentEditable IDL attribute, on getting, must return true if the element is either an editing host or editable, and false otherwise.
</dd>
</dl>


			</section>
			<section id="making-entire-documents-editable:-the-designmode-idl-attribute">
<h4 title="Making entire documents editable: the designMode IDL attribute">6.6.2. 文書~全体を編集-可能にする： `designMode^m ~IDL属性</h4>

<p>
文書は
`~designMode@
を持ち、可能化したり不能化できる。
◎
Documents have a designMode, which can be either enabled or disabled.
</p>


<dl class="domintro">
	<dt>%document . `designMode$m [ = %value ]</dt>
	<dd>
文書は［
編集-可能ならば `on^l ／
~ELSE_ `off^l
］返す。
◎
Returns "on" if the document is editable, and "off" if it isn't.
</dd>
	<dd>
設定して文書の現在の状態を変更できる。
これは、文書を~focusした上で，文書~内の選択を再設定する。
◎
Can be set, to change the document's current state. This focuses the document and resets the selection in that document.
</dd>
</dl>


<dl class="idl-def">
	<dt>`designMode@m</dt>
	<dd>
この属性がとり得る値は［
`on^l, `off^l
］のいずれかである。
◎
The designMode IDL attribute on the Document object takes two values, "on" and "off".＼
</dd>
	<dd>
<p>
設定子は、`~ASCII小文字~化する$( 所与の値 ) の結果に応じて，次を走らせ~MUST：
</p>

		<dl class="switch">
			<dt>`on^l</dt>
			<dd>
此れの`~designMode$を可能化する
</dd>

			<dt>`off^l</dt>
			<dd>
此れの`~designMode$を不能化する
</dd>

			<dt>その他</dt>
			<dd>
無視する
</dd>
		</dl>
◎
On setting, the new value must be compared in an ASCII case-insensitive manner to these two values; if it matches the "on" value, then designMode must be enabled, and if it matches the "off" value, then designMode must be disabled. Other values must be ignored.
</dd>
	<dd>
取得子は、［
次が満たされるならば `on^l ／
~ELSE_ `off^l
］を返さ~MUST
⇒
此れの`~designMode$は可能化されている
◎
On getting, if designMode is enabled, the IDL attribute must return the value "on"; otherwise it is disabled, and the attribute must return the value "off".
</dd>
</dl>

<p>
文書の`~designMode$は、初期~時には，不能化され~MUST。
また、文書が破壊されるか, 状態が変化するまで，最後に設定された状態を持続し~MUST。
◎
The last state set must persist until the document is destroyed or the state is changed. Initially, documents must have their designMode disabled.
</p>

<p>
不能化されている`~designMode$が可能化されたときは、~UAは，`即時に$文書の`作動範囲$の［
始端／終端
］境界点を`文書$の始端に再設定した上で、［
`文書$の`文書~要素$ %E ~NEQ ~NULL
］ならば、次を走らせ~MUST
⇒
`~objを~focusする$( %E )
◎
When the designMode changes from being disabled to being enabled, the user agent must immediately reset the document's active range's start and end boundary points to be at the start of the Document and then run the focusing steps for the document element of the Document, if non-null.
</p>

			</section>
			<section id="best-practices-for-in-page-editors">
<h4 title="Best practices for in-page editors">6.6.3. 頁~編集者による最善の実施</h4>


<p>
作者には、［
`編集中の~host$, および
編集-用の仕組みを通して作成された~markup
］上の `white-space$p ~propを値 `pre-wrap^v に設定することが奨励される。
~HTMLにおける空白に対する既定の取扱いは， WYSIWYG 編集には不向きであり、
`white-space$p が既定~値のままだと，一部のきわどい事例では，行0の折返しが正しく働かなくなる。
◎
Authors are encouraged to set the 'white-space' property on editing hosts and on markup that was originally created through these editing mechanisms to the value 'pre-wrap'. Default HTML whitespace handling is not well suited to WYSIWYG editing, and line wrapping will not work correctly in some corner cases if 'white-space' is left at its default value.
</p>


<div class="example">

<p>
既定の `normal^v 値が利用された場合に生じる問題の一例として、利用者が［
"<kbd>yellow</kbd>", `space^i, `space^i, <kbd>ball</kbd>"
］を続けて打ち込んだときを考える。
`white-space$p の既定の値（ `normal^v ）の下では，~~連続する `space^i は一つに縮約する呈示が要求されるため、結果の~markupを［
`yellow^l, `nbsp^i, `space^i, `ball^l
］の並び, または［
`yellow^l, `space^i, `nbsp^i, `ball^l
］の並びとするような編集~規則が必要とされる
— ここで， `nbsp^i は分断不可 space（ non-breaking space ）,
`space^i は普通の space（ U+0020 ）を表すとする。
<!--  "␣"  -->
◎
As an example of problems that occur if the default 'normal' value is used instead, consider the case of the user typing "yellow␣␣ball", with two spaces (here represented by "␣") between the words. With the editing rules in place for the default value of 'white-space' ('normal'), the resulting markup will either consist of "yellow&amp;nbsp; ball" or "yellow &amp;nbsp;ball"; i.e., there will be a non-breaking space between the two words in addition to the regular space. This is necessary because the 'normal' value for 'white-space' requires adjacent regular spaces to be collapsed together.
</p>

<p>
2 つの単語の合間で行0を折返す必要がある場合、前者の［
`nbsp^i, `space^i
］並びの事例では，行0の終端までに単語 `yellow^l のみが収まる場合でも，
`nbsp^i の直後で次の行0へ折返され、後者の［
`space^i, `nbsp^i
］並びの事例では， `nbsp^i の直前で次の行0へ折返される
— その結果、単語 `ball^l の前に字下げが露わになる。
◎
In the former case, "yellow⍽" might wrap to the next line ("⍽" being used here to represent a non-breaking space) even though "yellow" alone might fit at the end of the line; in the latter case, "⍽ball", if wrapped to the start of the line, would have visible indentation from the non-breaking space.
</p>



<p>
一方で、 `white-space$p が `pre-wrap^v に設定されている下での編集~規則は、単語の合間に 2 個の `space^i を挟むだけ済む。
その結果、 2 個の単語は行0の終端の所で分割され，~spaceは具現化からきれいに除去されることになる。
◎
When 'white-space' is set to 'pre-wrap', however, the editing rules will instead simply put two regular spaces between the words, and should the two words be split at the end of a line, the spaces would be neatly removed from the rendering.
</p>

</div>


			</section>
			<section id="editing-apis">
<h4 title="Editing APIs">6.6.4. 編集~API</h4>


<div>
<p>
次に挙げるものは、
`EXECCOMMAND$r 仕様にて定義される：
</p>

<ul ><li id="active-range">`作動範囲$
</li><li id="editing-host">`編集中の~host$
</li><li id="editing-host-of">~nodeが`属する編集中の~host$
</li><li id="editable">`編集-可能$
</li><li>［
`編集中の~host$ ／ `編集-可能$
］である要素に課される~UI要件
</li><li>~text選択
</li><li id="delete-the-selection">`選択を削除-$する~algo
</li><li>
<p>
次に挙げる各種~method
⇒＃
`execCommand()$m,
`queryCommandEnabled()$m,
`queryCommandIndeterm()$m,
`queryCommandState()$m,
`queryCommandSupported()$m,
`queryCommandValue()$m
</li></ul>

◎
The definition of the terms active range, editing host, editing host of, and editable, the user interface requirements of elements that are editing hosts or editable, the execCommand(), queryCommandEnabled(), queryCommandIndeterm(), queryCommandState(), queryCommandSupported(), and queryCommandValue() methods, text selections, and the delete the selection algorithm are defined in execCommand. [EXECCOMMAND]
</div>

			</section>
			<section id="spelling-and-grammar-checking">
<h4 title="Spelling and grammar checking">6.6.5. 綴りや文法の検査： `spellcheck^a 属性</h4>


<p>
~UAは、［
~form~control（ `textarea$e 要素の値など）や,
`編集中の~host$内の要素（例： `contenteditable$a を利用して）
］内の編集-可能~textに対する綴りや文法の検査を~supportできる。
◎
User agents can support the checking of spelling and grammar of editable text, either in form controls (such as the value of textarea elements), or in elements in an editing host (e.g. using contenteditable).
</p>


<p>
~UAは、各~要素に対し，［
既定のもの, または利用者の選好
］を通して、
`既定の挙動@
を確立し~MUST。
各~要素に対して可能な既定の挙動には、次の 3 種がある：
◎
For each element, user agents must establish a default behavior, either through defaults or through preferences expressed by the user. There are three possible default behaviors for each element:
</p>

<dl>
	<dt>`既定で行う@</dt>
	<dd>
要素の内容の綴りや文法は、その内容が編集-可能であって，その検査は
`spellcheck$a 属性を通して明示的に不能化されていないならば、検査される。
◎
The element will be checked for spelling and grammar if its contents are editable and spellchecking is not explicitly disabled through the spellcheck attribute.
</dd>
	<dt>`既定で行わない@</dt>
	<dd>
要素の綴りや文法は、 `spellcheck$a 属性を通して明示的に可能化されていない限り，決して検査されない。
◎
The element will never be checked for spelling and grammar unless spellchecking is explicitly enabled through the spellcheck attribute.
</dd>
	<dt>`既定で継承する@</dt>
	<dd>
要素の既定の挙動は、その親~要素のそれと同じになる。
親~要素がない場合、既定の挙動はない。
◎
The element's default behavior is the same as its parent element's. Elements that have no parent element cannot have this as their default behavior.
</dd>

</dl>

<hr>

<div class="p">
<p>
`spellcheck@a
属性は，`列挙ed属性$であり、次に挙げる~keyword, および対応する状態をとり得る：
</p>

<dl class="switch">
	<dt>空~文字列</dt>
	<dt>`true^v</dt>
	<dd>
`~T^st 状態に対応付けられる。
</dd>

	<dt>`false^v</dt>
	<dd>
`~F^st 状態に対応付けられる。
</dd>

	<dt>`値なし用の既定$</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`既定の挙動^st 状態に対応付けられる。
</dd>
</dl>
◎
The spellcheck attribute is an enumerated attribute whose keywords are the empty string, true and false. The empty string and the true keyword map to the true state. The false keyword maps to the false state. In addition, there is a third state, the default state, which is the missing value default (and the invalid value default).
</div>

<p class="note">注記：
［
`~T^st ／ `~F^st ／ `既定の挙動^st
］状態は、当の要素の綴りや文法が，［
検査される ／ 検査されない ／ 検査されるかどうかは`既定の挙動$に則る
］ことを指示する。
`既定の挙動$に則る場合、場合によっては親~要素の `spellcheck$a 状態に基づくことになる。
◎
The true state indicates that the element is to have its spelling and grammar checked. The default state indicates that the element is to act according to a default behavior, possibly based on the parent element's own spellcheck state, as defined below. The false state indicates that the element is not to be checked.
</p>


<hr>

<dl class="domintro">
	<dt>%element . `spellcheck$m [ = %値 ]</dt>
	<dd>
要素の綴りや文法が検査されるならば ~T ／
~ELSE_ ~F
を返す。
◎
Returns true if the element is to have its spelling and grammar checked; otherwise, returns false.
</dd>
	<dd>
設定して、既定の挙動を上書きしつつ，
`spellcheck$a 内容~属性を設定できる。
◎
Can be set, to override the default and set the spellcheck content attribute.
</dd>
</dl>

<dl class="idl-def">
	<dt>`spellcheck@m</dt>
	<dd>
<p>
取得子は、此れの `spellcheck$a 内容~属性の状態に応じて，次を走らせ~MUST：
</p>

		<dl class="switch">
			<dt>`~T^st</dt>
			<dd>
~RET ~T
</dd>
			<dt>`~F^st</dt>
			<dd>
~RET ~F
</dd>
			<dt>`既定の挙動^st</dt>
			<dd>
<p>
要素の`既定の挙動$に応じて：
</p>
				<dl class="switch">
				<dt>`既定で行う$</dt>
				<dd>
~RET ~T
</dd>
				<dt>`既定で行わない$</dt>
				<dd>
~RET ~F
</dd>
				<dt>`既定で継承する$</dt>
				<dd>
~RET 要素の親~要素の `spellcheck$m ~IDL属性を取得した結果
【親~要素がない場合は？】
</dd>
			</dl>
		</dd>
	</dl>
◎
The spellcheck IDL attribute, on getting, must return true if the element's spellcheck content attribute is in the true state, or if the element's spellcheck content attribute is in the default state and the element's default behavior is true-by-default, or if the element's spellcheck content attribute is in the default state and the element's default behavior is inherit-by-default and the element's parent element's spellcheck IDL attribute would return true; otherwise, if none of those conditions applies, then the attribute must instead return false.
</dd>
	<dd class="note">注記：
`spellcheck$m ~IDL属性は、［
利用者による， `spellcheck$a 内容~属性を上書きする選好
］からは影響されないため、実際の綴りや文法に対する検査~状態を反映しないこともある。
◎
The spellcheck IDL attribute is not affected by user preferences that override the spellcheck content attribute, and therefore might not reflect the actual spellchecking state.
</dd>
	<dd>
設定子は、要素の `spellcheck$a 内容~属性を［
所与の値 ~EQ ~T ならば 文字列 `true^l ／
~ELSE_ `false^l
］に設定し~MUST。
◎
On setting, if the new value is true, then the element's spellcheck content attribute must be set to the literal string "true", otherwise it must be set to the literal string "false".
</dd>
</dl>

<hr>


<p>
この特色機能の目的において検査-可能な~textは：
◎
User agents must only consider the following pieces of text as checkable for the purposes of this feature:
</p>

<ul>
	<li>
<p>
次に挙げる~text片に限られ~MUST：
◎
↑</p>

		<ul>
			<li>
<p>
［
次のいずれも満たすような `input$e 要素
］の，`値$fe：
</p>

<ul><li>`type$a 属性の状態 ~IN { `Text$st, `Search$st, `Url$st, `Email$st }
</li><li>`変異-可能$ （すなわち、 `readonly$a 属性は有さない, かつ`不能化され$ていない）
</li></ul>
◎
The value of input elements whose type attributes are in the Text, Search, URL, or E-mail states and that are mutable (i.e. that do not have the readonly attribute specified and that are not disabled).
</li>
			<li>
<p>
［
次のいずれも満たすような `textarea$e 要素
］の，`値$fe：
</p>

<ul><li>`~readonly0$a 属性は有さない
</li><li>`不能化され$ていない
</li></ul>

◎
The value of textarea elements that do not have a readonly attribute and that are not disabled.
</li>
			<li>
［
`編集中の~host$ ／ `編集-可能$な要素
］の子であるような `Text$I ~node内の~text。
◎
Text in Text nodes that are children of editing hosts or editable elements.
</li>
			<li>
`編集-可能$な要素の属性~内の~text。
◎
Text in attributes of editable elements.
</li>
		</ul>
	</li>
	<li>
<p>
所与の~textが属するとされる要素は、次で与えられる：
</p>

<ul><li>`Text$I ~nodeの一部を成す~textに対しては、［
単語, 一文, その他の~text片
］の最初の文字の直の親である要素。
</li><li>属性~内の~textに対しては、当の属性を有している要素。
</li><li>`input$e ／ `textarea$e 要素の値に対しては、要素~自身。
</li></ul>

◎
For text that is part of a Text node, the element with which the text is associated is the element that is the immediate parent of the first character of the word, sentence, or other piece of text. For text in attributes, it is the attribute's element. For the values of input and textarea elements, it is the element itself.
</li>
</ul>


<p class="algo-head">
綴りや文法の検査を適用し得る要素 %要素 に属する~textに対する検査は、次の~algoの結果が［
`可能化される^i ならば可能化され ／ `不能化される^i ならば不能化され
］~MUST：
◎
To determine if a word, sentence, or other piece of text in an applicable element (as defined above) is to have spelling- and grammar-checking enabled, the UA must use the following algorithm:
</p>

<ol>
	<li>
~IF［
利用者は、この~textに対する検査を不能化している
］
⇒
~RET `不能化される^i
◎
If the user has disabled the checking for this text, then the checking is disabled.
</li>
	<li>
~IF［
利用者は、この~textの検査を常に可能化するように強制している
］
⇒
~RET `可能化される^i
◎
Otherwise, if the user has forced the checking for this text to always be enabled, then the checking is enabled.
</li>
	<li>
%要素~list ~SET［
%要素 , および その先祖~要素
］からなる，%要素 に近い順の~list
◎
↓</li>
	<li>
<p>
%要素~list 内の~EACH( %E ) に対し：
</p>
		<ol>
			<li>
%状態 ~LET %E の `spellcheck$a 内容~属性の状態
</li>
			<li>
~IF［
%状態 ~EQ `既定の挙動^st
］
⇒
~CONTINUE
</li>
			<li>
~RET %状態 に応じて
⇒＃
`~T^st ならば `可能化される^i ／
`~F^st ならば `不能化される^i
</li>
		</ol>
◎
Otherwise, if the element with which the text is associated has a spellcheck content attribute, then: if that attribute is in the true state, then checking is enabled; otherwise, if that attribute is in the false state, then checking is disabled.
◎
Otherwise, if there is an ancestor element with a spellcheck content attribute that is not in the default state, then: if the nearest such ancestor's spellcheck content attribute is in the true state, then checking is enabled; otherwise, checking is disabled.
</li>
	<li>
<p>
%要素~list 内の~EACH( %E ) に対し：
</p>
		<ol>
			<li>
%挙動 ~LET %E の`既定の挙動$
</li>
			<li>
~IF［
%挙動 ~EQ `既定で継承する$
］
⇒
~CONTINUE†
</li>
			<li>
~RET %挙動 に応じて
⇒＃
`既定で行う$ならば `可能化される^i ／
`既定で行わない$ならば `不能化される^i
</li>
		</ol>

<p class="trans-note">【†
原文では，この~algoを %E の親に対し再帰的に呼出しているが、前~段にて， %E のどの先祖の `spellcheck$a 内容~属性の状態も `既定の挙動^st であることはすでに判っているので、この段で反復することで十分になる。
】</p>

◎
Otherwise, if the element's default behavior is true-by-default, then checking is enabled.
◎
Otherwise, if the element's default behavior is false-by-default, then checking is disabled.
◎
Otherwise, if the element's parent element has its checking enabled, then checking is enabled.
</li>
	<li>
~RET `不能化される^i
◎
Otherwise, checking is disabled.
</li>
</ol>

<p>
単語や一文などの~textに対する検査が可能化されている場合、~UAは，その~text内に綴りや文法の誤りがあれば それを指示するべきである。
~UAは、綴りや文法の訂正を示唆するときには，文書~内に所与の他の意味論も織り込むべきである — これには、次が含まれる：
◎
If the checking is enabled for a word/sentence/text, the user agent should indicate spelling and grammar errors in that text. User agents should take into account the other semantics given in the document when suggesting spelling and grammar corrections.＼
</p>

<ul>
	<li>
綴りや文法に利用する規則を、要素に指定されている自然言語や, 利用者が選好している自然言語~設定群から決定してよい。
◎
User agents may use the language of the element to determine what spelling and grammar rules to use, or may use the user's preferred language settings.＼
</li>
	<li>
可能な所では、 `pattern$a などの `input$e 要素~属性を利用して，結果の値が妥当になることを確保するべきである。
◎
UAs should use input element attributes such as pattern to ensure that the resulting value is valid, where possible.
</li>
</ul>

<p>
検査が不能化されている場合、~UAは，その~textに対する綴りや文法の誤りを指示するべきでない。
◎
If checking is disabled, the user agent should not indicate spelling or grammar errors for that text.
</p>

<div class="example">

<p>
次の例の単語 `Hello^l に対しては、その綴りを検査するかどうかを決定するときに，~ID `a^l の要素が利用され、その結果，検査されないになる。
◎
The element with ID "a" in the following example would be the one used to determine if the word "Hello" is checked for spelling errors. In this example, it would not be.
</p>


<pre>
&lt;div contenteditable="true"&gt;
 &lt;span spellcheck="false" id="a"&gt;Hell&lt;/span&gt;&lt;em&gt;o!&lt;/em&gt;
&lt;/div&gt;
</pre>


<p>
次の例における~ID `b^l の要素に対しては、検査は可能化される（ `input$e 要素~上の属性~値~内の頭部の~ASCII空白は，属性を無視させるので、既定の挙動にかかわらず先祖の値が代わりに利用される）。
◎
The element with ID "b" in the following example would have checking enabled (the leading space character in the attribute's value on the input element causes the attribute to be ignored, so the ancestor's value is used instead, regardless of the default).
</p>


<pre class="bad">&lt;p spellcheck="true"&gt;
 &lt;label&gt;Name: &lt;input spellcheck=" false" id="b"&gt;&lt;/label&gt;
&lt;/p&gt;
</pre>

</div>


<p class="note">注記：
この仕様は、綴りや文法~検査器~用の~UIは定義しない。
例えば~UAは、［
その場で検査を提供する ／
検査が可能化されている間，継続的に検査を遂行する ／
その他の~UI
］のいずれも利用できる。
◎
This specification does not define the user interface for spelling and grammar checkers. A user agent could offer on-demand checking, could perform continuous checking while the checking is enabled, or could use other interfaces.
</p>

			</section>
			<section id="autocapitalization">
<h4 title="Autocapitalization">6.6.6. 自動頭字化： `autocapitalize^a 属性</h4>

<p>
~textを手入力する~methodには、例えば，携帯~機器~上の~virtual-keyboardや ~voice入力などもあり、各~一文の最初の字lを自動的に頭字化（ capital 化 ）して，利用者を支援することが多い（当の自然言語にこの規約がある下で，~textを組成しているならば）。
【 字l（ letter ）とは、約物等を除く，“普通の” 文字を指す。】
自動頭字化を実装する~virtual-keyboardは、自動頭字化されるべき字lが打込まれつつあるとき，自動的に字lを大文字で示すよう切替えるかもしれない（利用者が小文字に戻せるようにしつつ）。
他の型の入力，例えば~voice入力では、最初に介入する~~余地を利用者に与えない仕方で，自動頭字化を遂行することもある。
`autocapitalize$a 属性は、作者がそのような挙動を制御できるようにする。
◎
Some methods of entering text, for example virtual keyboards on mobile devices, and also voice input, often assist users by automatically capitalizing the first letter of sentences (when composing text in a language with this convention). A virtual keyboard that implements autocapitalization might automatically switch to showing uppercase letters (but allow the user to toggle it back to lowercase) when a letter that should be autocapitalized is about to be typed. Other types of input, for example voice input, may perform autocapitalization in a way that does not give users an option to intervene first. The autocapitalize attribute allows authors to control such behavior.
</p>

<p>
`autocapitalize$a 属性は、概して，物理的~keyboardを打込むときの挙動には影響しないように実装される。
（この理由から, および
利用者が自動頭字化の挙動を上書きできる能を与えるため、一部の事例では, あるいは初期~入力の後に~textを編集するときには、いかなる類の入力~検証も，この属性に依拠しては~MUST_NOT。）
◎
The autocapitalize attribute, as typically implemented, does not affect behavior when typing on a physical keyboard. (For this reason, as well as the ability for users to override the autocapitalization behavior in some cases or edit the text after initial input, the attribute must not be relied on for any sort of input validation.)
</p>

<p>
`autocapitalize$a 属性は、次に該当するものに利用できる：
◎
The autocapitalize attribute can be used＼
</p>

<ul>
	<li>
`編集中の~host$
— ~hostされている編集-可能~領域~用に自動頭字化の挙動を制御するためとして。
◎
on an editing host to control autocapitalization behavior for the hosted editable region,＼
</li>
	<li>
［
`input$e ／ `textarea$e
］要素
— その要素の中に~textを入力するときの挙動を制御するためとして。
◎
on an input or textarea element to control the behavior for inputting text into that element, or＼
</li>
	<li>
`form$e 要素
— その~formが所有していて, `自動頭字化-を継承-$する要素すべての，既定の挙動を制御するためとして。
◎
on a form element to control the default behavior for all autocapitalize-inheriting elements associated with the form element. 
</li>
</ul>

<p>
`autocapitalize$a 属性は、次に該当するものに対しては，決して自動頭字化を可能化させない（この挙動は、下の`使用~自動頭字化~hint$~algoに含まれている）
⇒
`input$e 要素のうち，［
その`type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］なるもの
◎
The autocapitalize attribute never causes autocapitalization to be enabled for input elements whose type attribute is in one of the URL, E-mail, or Password states. (This behavior is included in the used autocapitalization hint algorithm below.)
</p>

<p>
自動頭字化の処理~modelは、次に定義される 5 個の
`自動頭字化~hint@
から選定することに基づく：
◎
The autocapitalization processing model is based on selecting among five autocapitalization hints, defined as follows:
</p>

<dl>
	<dt>`既定@aH</dt>
	<dd>
［
~UA／入力~method
］は、自前の決定を用立てて，自動頭字化を可能化するべきである。
<!-- ＊use make 誤順序？ -->
◎
The user agent and input method should use make their own determination of whether or not to enable autocapitalization.
</dd>

	<dt>`なし@aH</dt>
	<dd>
自動頭字化は適用されるべきでない（すべての字lは、既定で小文字にされるべきである）。
◎
No autocapitalization should be applied (all letters should default to lowercase).
</dd>

	<dt>`一文ごと@aH</dt>
	<dd>
各~一文の最初の字lは、既定で頭字にされるべきである。
他のすべての字lは、既定で小文字にされるべきである。
◎
The first letter of each sentence should default to a capital letter; all other letters should default to lowercase.
</dd>

	<dt>`単語ごと@aH</dt>
	<dd>
各~単語の最初の字lは、既定で頭字にされるべきである。
他のすべての字lは、既定で小文字にされるべきである
◎
The first letter of each word should default to a capital letter; all other letters should default to lowercase.
</dd>
	<dt>`文字ごと@aH</dt>
	<dd>
すべての字lは、既定で大文字にされるべきである。
◎
All letters should default to uppercase.
</dd>
</dl>

<p>
`autocapitalize@a
属性は，`列挙ed属性$であり、その状態は，可能な`自動頭字化~hint$を与える。
属性の状態により指定される`自動頭字化~hint$は、`使用~自動頭字化~hint$を~formするための他の考慮点と組合されて，~UAの挙動を伝える。
この属性~用の各種~keywordと, 状態への対応関係は、次で与えられる：
◎
The autocapitalize attribute is an enumerated attribute whose states are the possible autocapitalization hints. The autocapitalization hint specified by the attribute's state combines with other considerations to form the used autocapitalization hint, which informs the behavior of the user agent. The keywords for this attribute and their state mappings are as follows:
</p>


<div>
<dl class="switch">
	<dt>`off$v</dt>
	<dt>`~noneC$v</dt>
	<dd>
`なし$aH
</dd>

	<dt>`on$v</dt>
	<dt>`sentences$v</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`一文ごと$aH
</dd>

	<dt>`words$v</dt>
	<dd>
`単語ごと$aH
</dd>

	<dt>`characters$v</dt>
	<dd>
`文字ごと$aH
</dd>

	<dt>`値なし用の既定$</dt>
	<dd>
`既定$aH
</dd>
</dl>
◎
Keyword 	State
off 	none
none
on 	sentences
sentences
words 	words
characters 	characters
◎
The invalid value default is the sentences state. The missing value default is the default state.
</div>

<dl class="domintro">
	<dt>%element . `autocapitalize$m [ = %value ]</dt>
	<dd>
この要素~用の［
現在の自動頭字化~状態, または
未~設定-の場合は空~文字列
］を返す。
［
`input$e ／ `textarea$e
］要素は、自身の状態を `form$e 要素から継承することに注意：
その場合， `form$e 要素の自動頭字化~状態を返すことになり、編集-可能~領域~内の要素であっても編集中の~hostの自動頭字化~状態は返さないことになる（要素~自身が，`編集中の~host$でない限り）。
◎
Returns the current autocapitalization state for the element, or an empty string if it hasn't been set. Note that for input and textarea elements that inherit their state from a form element, this will return the autocapitalization state of the form element, but for an element in an editable region, this will not return the autocapitalization state of the editing host (unless this element is, in fact, the editing host).
</dd>
	<dd>
設定して， `autocapitalize$a 内容~属性を設定できる（それに伴い，要素~用の自動頭字化の挙動も変更する）。
◎
Can be set, to set the autocapitalize content attribute (and thereby change the autocapitalization behavior for the element).
</dd>
</dl>

<p>
所与の要素 %要素 の
`自前の自動頭字化~hint@
を算出するときは、次を走らす：
◎
To compute the own autocapitalization hint of an element element, run the following steps:
</p>

<ol>
	<li>
~IF［
%要素 は `autocapitalize$a 内容~属性を有していて，その値 ~NEQ 空~文字列
］
⇒
~RET その属性の状態
◎
If the autocapitalize content attribute is present on element, and its value is not the empty string, return the state of the attribute.
</li>
	<li>
~IF［
%要素 は`自動頭字化-を継承-$する
］~AND［
%要素 の`~form所有者$ ~NEQ ~NULL
］
⇒
~RET %要素 の`~form所有者$の`自前の自動頭字化~hint$
◎
If element is an autocapitalize-inheriting element and has a non-null form owner, return the own autocapitalization hint of element's form owner.
</li>
	<li>
~RET `既定$aH
◎
Return default.
</li>
</ol>


<dl class="idl-def">
	<dt>`autocapitalize@m</dt>
	<dd>
取得子は、此れの`自前の自動頭字化~hint$に応じて，次に与える文字列~値を返さ~MUST
⇒＃
`既定$aH ならば 空~文字列,
`なし$aH ならば `none^l†,
`一文ごと$aH ならば `sentences^l†,
`単語ごと$aH ならば `words^l,
`文字ごと$aH ならば `characters^l
◎
The autocapitalize IDL attribute, on getting, must return the string value corresponding to own autocapitalization hint of the element, with the exception that the default state maps to the empty string.＼
</dd>
	<dd class="trans-note">【†
実際の原文では，`自前の自動頭字化~hint$に “対応する文字列” としか記されておらず、例えば `一文ごと$aHに対し `sentences^l, `on^l のどちらを返すか，はっきりしない。
】</dd>
	<dd>
設定子は、此れの `autocapitalize$a 内容~属性を所与の値に設定し~MUST。
◎
On setting, it must set the autocapitalize content attribute to the given new value.
</dd>
</dl>

<hr>


<p>
~UAは，［
~text入力~methodに対する自動頭字化の挙動を~custom化する機能性
］を~supportしていて［
~web開発者がそれを制御できる
］ようにしたいと望むならば、要素の中に~textを入力する間，要素~用の
`使用~自動頭字化~hint@
を算出するべきである。
これは、［
要素の中への~text入力~用に推奨される，自動頭字化の挙動
］を述べる，`自動頭字化~hint$になる。
◎
User agents that support customizable autocapitalization behavior for a text input method and wish to allow web developers to control this functionality should, during text input into an element, compute the used autocapitalization hint for the element. This will be an autocapitalization hint that describes the recommended autocapitalization behavior for text input into the element.
</p>

<p>
ある種の状況下においては、［
~UA／入力~method
］は，`使用~自動頭字化~hint$を［
無視する, または上書きする
］ことを選んでも~MAY。
◎
User agents or input methods may choose to ignore or override the used autocapitalization hint in certain circumstances.
</p>

<p>
要素 %要素 用の`使用~自動頭字化~hint$は、次の~algoを用いて算出される：
◎
The used autocapitalization hint for an element element is computed using the following algorithm:
</p>

<ol>
	<li>
~IF［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN { `Url$st, `Email$st, `Password$st }
］
⇒
~RET `既定$aH
◎
If element is an input element whose type attribute is in one of the URL, E-mail, or Password states, then return default.
</li>
	<li>
~IF［
%要素 は［
`input$e ／ `textarea$e
］要素である
］
⇒
~RET %要素 の`自前の自動頭字化~hint$
◎
If element is an input element or a textarea element, then return element's own autocapitalization hint.
</li>
	<li>
~IF［
%要素 は［
`編集中の~host$ ／ `編集-可能$な要素
］である
］
⇒
~RET
%要素 が`属する編集中の~host$の`自前の自動頭字化~hint$
◎
If element is an editing host or an editable element, then return the own autocapitalization hint of the editing host of element.
</li>
	<li>
~Assert：
この段に到達することは決してない
— ~text入力が生じるのは，上の判定基準のいずれかを満たす要素に限られるので。
◎
Assert: this step is never reached, since text input only occurs in elements that meet one of the above criteria.
</li>
</ol>

			</section>
			<section id="input-modalities:-the-inputmode-attribute">
<h3 title="Input modalities: the inputmode attribute">6.6.7. 入力~modality： `inputmode^a 属性</h3>

<p>
~UAは、次に挙げるものに対し， `inputmode$a 属性を~supportできる
⇒＃
~form~control（`textarea$e 要素の値など） ／
`編集中の~host$内の要素（ `contenteditable$a を利用しているものなど）
◎
User agents can support the inputmode attribute on form controls (such as the value of textarea elements), or in elements in an editing host (e.g., using contenteditable).
</p>

<p>
`inputmode@a
内容~属性は、［
内容を手入力している利用者にとって，どの種類の入力の仕組みが最も助けになるか
］を指定する，`列挙ed属性$である。
◎
The inputmode content attribute is an enumerated attribute that specifies what kind of input mechanism would be most helpful for users entering content.
</p>


<table><thead><tr><th>~keyword
<th>~~説明
</thead><tbody>

<tr><td>`none@v
</td><td>
~UAは、~virtual-keyboardを表示するべきでない。
この~keywordは、自前の~keyboard~controlを具現化するような内容に，有用になる。
◎
The user agent should not display a virtual keyboard. This keyword is useful for content that renders its own keyboard control.

<tr><td>`text@v
</td><td>
~UAは、利用者の~localeにおける~textを入力できる，~virtual-keyboardを表示するべきである。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale.

<tr><td>`tel@v
</td><td>
~UAは、電話番号を入力できる，~virtual-keyboardを表示するべきである。
これは、［
数字 0 〜 9, 文字 "#", "*"
］用の~keyを含むべきである。
~localeによっては、これには~alphabetic-mnemonicも含まれる（例えば米国では、歴史的に，~label "2" の~keyには ~label "A", "B", "C" も付与されている）。
◎
The user agent should display a virtual keyboard capable of telephone number input. This should including keys for the digits 0 to 9, the "#" character, and the "*" character. In some locales, this can also include alphabetic mnemonic labels (e.g., in the US, the key labeled "2" is historically also labeled with the letters A, B, and C).

<tr><td>`url@v
</td><td>
~UAは、利用者の~localeにおける~textを入力でき,
`~URL$の入力を援助する
— 文字 "/" や "." ， "www." や ".com" など，~domain名に共通的に見出される文字列を手早く入力するための — 
~keyも伴われた，~virtual-keyboardを表示するべきである。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of URLs, such as that for the "/" and "." characters and for quick input of strings commonly found in domain names such as "www." or ".com".

<tr><td>`email@v
</td><td>
~UAは、利用者の~localeにおける~textを入力でき,
~e-mail-addressの入力を援助する~key
— 文字 "@", "." 用など —
も伴われた，~virtual-keyboardを表示するべきである。
◎
The user agent should display a virtual keyboard capable of text input in the user's locale, with keys for aiding in the input of e-mail addresses, such as that for the "@" character and the "." character.

<tr><td>`numeric@v
</td><td>
~UAは、数を入力できる，~virtual-keyboardを表示するべきである。
この~keywordは、 PIN を手入力するときに有用になる。
◎
The user agent should display a virtual keyboard capable of numeric input. This keyword is useful for PIN entry.

<tr><td>`decimal@v
</td><td>
~UAは、小数を含む数を入力できる，~virtual-keyboardを表示するべきである。
利用者の~locale用の数的~keyと書式区切子が示されるべきである。
◎
The user agent should display a virtual keyboard capable of fractional numeric input. Numeric keys and the format separator for the locale should be shown.

<tr><td>`search@v
</td><td>
~UAは、探索~用に最適化された，~virtual-keyboardを表示するべきである。
◎
The user agent should display a virtual keyboard optimized for search.

</tbody></table>

<dl class="idl-def">
	<dt>`inputMode@m</dt>
	<dd>
`既知の値のみに制限され$る下で，
`inputmode$a 内容~属性を`反映-$し~MUST。
◎
The inputMode IDL attribute must reflect the inputmode content attribute, limited to only known values.
</dd>
</dl>

<p>
`inputmode$a が指定されていない（または、~UAが~supportしない状態にある）ときは、~UAは，既定の~virtual-keyboardを決定して利用者に呈示するべきである
— 決定する際には、入力の［
`type$a や `pattern$a
］属性などの文脈的な情報を利用するべきである。
◎
When inputmode is unspecified (or is in a state not supported by the user agent), the user agent should determine the default virtual keyboard to be shown. Contextual information such as the input type or pattern attributes should be used to determine which type of virtual keyboard should be presented to the user.
</p>

			</section>
		</section>
		<section id="dnd">
<h3 title="Drag and drop">6.7. ~drag＆~drop</h3>

<p class="trans-note">【
この節の内容は、
<a href="~HTMLdnd#dnd">別~頁にて</a>。
】</p>

		</section>
	</section>
</main>
