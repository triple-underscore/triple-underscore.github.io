<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>SVG 2 — Document Structure （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-svg.css" type="text/css">

<style>
.role {
	color: #832;
}
</style>

<script src="common0.js"></script>
<script src="svg-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options
spec_title:SVG 2 — Document Structure
spec_date:2021-04-22
trans_update:2019-09-24
source_checked:180924
abbr_url:SVGstruct
page_state_key:SVG
original_url:https://svgwg.org/svg2-draft/struct.html
spec_status:ED
copyright:2019,use
site_nav:svg,css
nav_prev:SVGtypes
nav_next:SVGstyling
trans_1st_pub:2018-10-02

●●class_map
m:dom0
m1:dom1
n:dom
role:role

●●tag_map
role:code
m:code
m1:code
n:code
kbd:kbd

●●original_id_map
__svg__ShadowAnimation__ShadowAnimation:

●●mdn_urls
elementdef-defs:SVG/Element/defs
elementdef-desc:SVG/Element/desc
elementdef-g:SVG/Element/g
elementdef-metadata:SVG/Element/metadata
elementdef-svg:SVG/Element/svg
elementdef-switch:SVG/Element/switch
elementdef-symbol:SVG/Element/symbol
elementdef-title:SVG/Element/title
elementdef-use:SVG/Element/use

	InterfaceGetSVGDocument:API/GetSVGDocument
InterfaceSVGDefsElement:API/SVGDefsElement
InterfaceSVGDescElement:API/SVGDescElement
	InterfaceDocumentExtensions:API/SVGDocument
	InterfaceSVGElementInstance:API/SVGElementInstance
InterfaceSVGGElement:API/SVGGElement
InterfaceSVGMetadataElement:API/SVGMetadataElement
InterfaceSVGSVGElement:API/SVGSVGElement
InterfaceSVGSwitchElement:API/SVGSwitchElement
InterfaceSVGSymbolElement:API/SVGSymbolElement
InterfaceSVGTitleElement:API/SVGTitleElement
InterfaceSVGUseElement:API/SVGUseElement
	InterfaceSVGUseElementShadowRoot:API/SVGUseElementShadowRoot

●●link_map

	●IDL
I.HTMLEmbedElement:~HEembed#htmlembedelement
I.HTMLIFrameElement:~HEembed#htmliframeelement
I.HTMLObjectElement:~HEembed#htmlobjectelement

I.DocumentFragment:~DOM4#interface-documentfragment
I.DocumentOrShadowRoot:~DOM4#mixin-documentorshadowroot
I.StyleSheetList:~CSSOM1#stylesheetlist
I.KeyframeEffect:~WANIMapi#keyframeeffect
	廃＊I.KeyframeEffectReadOnly:~WANIMapi#keyframeeffectreadonly

	m.rootElement:#__svg__SVGDocument__rootElement
	m.activeElement:#__svg__SVGDocument__activeElement

	m.createSVGPoint:struct.html:#__svg__SVGSVGElement__createSVGPoint
	m.currentTranslate:#__svg__SVGSVGElement__currentTranslate
	m.checkEnclosure:#__svg__SVGSVGElement__checkEnclosure
	m.checkIntersection:#__svg__SVGSVGElement__checkIntersection
	m.createSVGAngle:#__svg__SVGSVGElement__createSVGAngle
	m.createSVGLength:#__svg__SVGSVGElement__createSVGLength
	m.createSVGMatrix:#__svg__SVGSVGElement__createSVGMatrix
	m.createSVGNumber:#__svg__SVGSVGElement__createSVGNumber
	m.createSVGRect:#__svg__SVGSVGElement__createSVGRect
	m.createSVGTransform:#__svg__SVGSVGElement__createSVGTransform
	m.createSVGTransformFromMatrix:#__svg__SVGSVGElement__createSVGTransformFromMatrix
	m.currentScale:#__svg__SVGSVGElement__currentScale
	m.deselectAll:#__svg__SVGSVGElement__deselectAll
	m.forceRedraw:#__svg__SVGSVGElement__forceRedraw
	m.getElementById:#__svg__SVGSVGElement__getElementById
	m.getEnclosureList:#__svg__SVGSVGElement__getEnclosureList
	m.getIntersectionList:#__svg__SVGSVGElement__getIntersectionList
	m.height:#__svg__SVGSVGElement__height
	m.suspendRedraw:#__svg__SVGSVGElement__suspendRedraw
	m.unsuspendRedraw:#__svg__SVGSVGElement__unsuspendRedraw
	m.unsuspendRedrawAll:#__svg__SVGSVGElement__unsuspendRedrawAll
	m.width:#__svg__SVGSVGElement__width
	m.x:#__svg__SVGSVGElement__x
	m.y:#__svg__SVGSVGElement__y

	m.animatedInstanceRoot:#__svg__SVGUseElement__animatedInstanceRoot
	m.height:#__svg__SVGUseElement__height
	m.instanceRoot:#__svg__SVGUseElement__instanceRoot
	m.x:#__svg__SVGUseElement__x
	m.y:#__svg__SVGUseElement__y
	m.width:#__svg__SVGUseElement__width

	m.correspondingElement:#__svg__SVGElementInstance__correspondingElement
	m.correspondingUseElement:#__svg__SVGElementInstance__correspondingUseElement

	m.ShadowAnimation:#__svg__ShadowAnimation__ShadowAnimation
	m.sourceAnimation:#__svg__ShadowAnimation__sourceAnimation

	m.getSVGDocument:#__svg__GetSVGDocument__getSVGDocument


n.addEventListener:~DOM4#dom-eventtarget-addeventlistener
n.createSVGTransformFromMatrix:~SVGcoords#__svg__SVGTransformList__createSVGTransformFromMatrix
n.documentElement:~DOM4#dom-document-documentelement

n.target:~DOM4#dom-event-target
n.effect:~WANIMapi#dom-animation-effect
n.~target0:~WANIMapi#dom-keyframeeffect-target
	~target0:~WANIMapi#dom-keyframeeffectreadonly-target


n.styleSheets:~CSSOM1#dom-document-stylesheets
n.sheet:~CSSOM1#dom-linkstyle-sheet



	●a

a.onblur:~SVGinteract#EventAttributes
a.onerror:~SVGinteract#ErrorEvent
a.onfocus:~SVGinteract#EventAttributes
a.onload:~SVGinteract#LoadEvent
a.onscroll:~SVGinteract#EventAttributes

a.class:~SVGstyling#ClassAttribute
a.href:#UseElementHrefAttribute
	a.href:~SVGanim#HrefAttribute

a.id:#IDAttribute
a.lang:#LangAttribute
a.preserveAspectRatio:~SVGcoords#PreserveAspectRatioAttribute
a.refX:#SymbolElementRefXAttribute
a.refY:#SymbolElementRefYAttribute
a.~refX0:~SVGpainting#MarkerElementRefXAttribute
a.~refY0:~SVGpainting#MarkerElementRefYAttribute
a.requiredExtensions:#RequiredExtensionsAttribute
a.role:#RoleAttribute
a.style:~SVGstyling#StyleAttribute
a.systemLanguage:#SystemLanguageAttribute
a.tabindex:#SVGElementTabindexAttribute
a.autofocus:#SVGElementAutofocusAttribute
a.viewBox:~SVGcoords#ViewBoxAttribute
a.xlink:href:~SVGlinking#XLinkHrefAttribute
a.xlink:title:~SVGlinking#XLinkTitleAttribute
a.xml:space:#XMLSpaceAttribute
a.allowReorder:~TR/REC-smil/smil-content.html#adef-allowReorder


a.aria-activedescendant:~ARIA11#aria-activedescendant
a.aria-atomic:~ARIA11#aria-atomic
a.aria-autocomplete:~ARIA11#aria-autocomplete
a.aria-busy:~ARIA11#aria-busy
a.aria-checked:~ARIA11#aria-checked
a.aria-colcount:~ARIA11#aria-colcount
a.aria-colindex:~ARIA11#aria-colindex
a.aria-colspan:~ARIA11#aria-colspan
a.aria-controls:~ARIA11#aria-controls
a.aria-current:~ARIA11#aria-current
a.aria-describedby:~ARIA11#aria-describedby
a.aria-details:~ARIA11#aria-details
a.aria-disabled:~ARIA11#aria-disabled
a.aria-dropeffect:~ARIA11#aria-dropeffect
a.aria-errormessage:~ARIA11#aria-errormessage
a.aria-expanded:~ARIA11#aria-expanded
a.aria-flowto:~ARIA11#aria-flowto
a.aria-grabbed:~ARIA11#aria-grabbed
a.aria-haspopup:~ARIA11#aria-haspopup
a.aria-hidden:~ARIA11#aria-hidden
a.aria-invalid:~ARIA11#aria-invalid
a.aria-keyshortcuts:~ARIA11#aria-keyshortcuts
a.aria-label:~ARIA11#aria-label
a.aria-labelledby:~ARIA11#aria-labelledby
a.aria-level:~ARIA11#aria-level
a.aria-live:~ARIA11#aria-live
a.aria-modal:~ARIA11#aria-modal
a.aria-multiline:~ARIA11#aria-multiline
a.aria-multiselectable:~ARIA11#aria-multiselectable
a.aria-orientation:~ARIA11#aria-orientation
a.aria-owns:~ARIA11#aria-owns
a.aria-valuetext:~ARIA11#aria-valuetext

a.~xlink_href:~SVGlinking#XLinkHrefAttribute
a.~xml_space:#XMLSpaceAttribute

	●code 他
p.background-position:~CSSBG#the-background-position
	~TR/css3-background/#the-background-position
P.Language-Tag:~RFCx/bcp47#section-2.1
P.Name:~TR/xml/#NT-Name

role.link:~ARIA11#link
role.application:~ARIA11#application
role.document:~ARIA11#document
role.img:~ARIA11#img
role.none:~ARIA11#none
role.group:~ARIA11#group
role.graphics-symbol:~TR/graphics-aria-1.0/#graphics-symbol
role.graphics-document:~TR/graphics-aria-1.0/#graphics-document
role.graphics-object:~TR/graphics-aria-1.0/#graphics-object


ps.nth-child():~SELECTORS4#nth-child-pseudo
ps.nth-of-type():~SELECTORS4#nth-of-type-pseudo

	●用語／§

~host:~SVGstruct#TermShadowHost
~shadow~host:~SVGstruct#TermShadowHost
~shadow~tree:~SVGstruct#TermShadowTree
~shadow根:~SVGstruct#TermShadowRoot

内包~判定基準:~SVGstruct#TermInclusionCriteria

現在の並進-点~obj:#CurrentTranslatePointObject
矩形に入る子孫を見出す:#TermFindIntersectingOrEnclosedDescendants
要素の中の容器でない~graphics要素を見出す:#TermFindNonContainerGraphicsElements

未解決:~SVGlinking#TermUnresolvedReference
文書~event属性:~SVGinteract#EventAttributes

sec.~URL参照:~SVGlinking#URLReference

	~SVGcoords#EstablishingANewSVGViewport
	~SVGinteract#Focus
	~SVGlinking#MediaFragments
~SVG~view指定:~SVGlinking#SVGViewSpecification
	~SVGlinking#processingURL
	~SVGlinking#processingURL-absolute
	~SVGrender#Rendered-vs-NonRendered
	~SVGshapes#AssignToDOMPoint
	~SVGtext#WhiteSpace

	~SVGshapes#PointMode
	読専~flagに集約:
		~SVGshapes#ReadOnlyPoint
	関連な要素に集約:
		~SVGtypes#AngleMode
		~SVGtypes#LengthMode
		~SVGtypes#NumberMode
		~SVGcoords#MatrixMode
		~SVGcoords#TransformMode

	§#ARIAStateandPropertyAttributes
	§#ConditionalProcessing
	§#DataAttributes
	例#EmbeddedSVGExample
	§#Head
	§#UseAnimations
	§#UseEventHandling
	§#UseLayout
	§#UseMultimedia
	§#UseShadowTree
	§#UseStyleInheritance

	●外部

妥当な整数:~HTMLcms#valid-integer
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens
~commaで分離された~token集合:~HTMLcms#set-of-comma-separated-tokens
真偽-属性:~HTMLcms#boolean-attribute
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler内容~属性:~WAPI#event-handler-content-attributes

単体~選択子:~SELECTORS4#simple
複体~選択子:~SELECTORS4#complex

生来な~size:~CSSIMAGE#natural-size

~HTML~accessibility~APIの対応付け:https://w3c.github.io/html-aam/#x4-4-html-element-role-mappings
指定d値:~CASCADE#specified
	~TR/css-cascade-3/#specified

~tree順序:~DOM4#concept-tree-order
要素の~ID:~DOM4#concept-id
範囲~obj:~DOM4#concept-range
~shadowも含む先祖:~DOM4#concept-shadow-including-ancestor
静的:~DOM4#concept-collection-static
	~host:~DOM4#concept-documentfragment-host
~eventを~targetし直す:~DOM4#retarget
~event経路:~DOM4#event-path

各種~roleの定義:~ARIA11#role_definitions
~graphics用の各種~role:~TR/graphics-aria-1.0/#roles
	~SVG~accessibility~API対応付け:~TR/svg-aam-1.0/

原始filter要素:~FILTERS#elementdef-filter-primitive
光源~要素:~FILTERS#light-source
伝達-関数~要素:~FILTERS#transfer-function-element

~animation:~WANIM#concept-animation
~target要素:~WANIM#target-element
文書~時列線:~WANIM#document-timeline

浮上-相:~UIEVENTS#bubble-phase
捕捉-相:~UIEVENTS#capture-phase

x 座標:~GEOMETRY#point-x-coordinate
y 座標:~GEOMETRY#point-y-coordinate


	●他
	~HTMLdom#the-document-object
	~custom~data属性:~HTMLdom#custom-data-attribute
	~HTMLdom#embedding-custom-non-visible-data-with-the-data-*-attributes
	~ARIA11
	~ARIA11#state_prop_def
	~ARIA11#typemapping
	~TR/svg-aam-1.0/
	~TR/wai-aria/#states_and_properties
	~SELECTIONAPI#dfn-direction
	~SELECTIONAPI#dom-selection

	`web-animations-1$r:~TR/web-animations-1/
	`xml-names$r:~TR/2006/REC-xml-names-20060816/
	foreignObject$e:~SVGembedded#ForeignObjectElement
	`BCP47$r:http://www.ietf.org/rfc/bcp/bcp47.txt
	`svg-animation$r:https://svgwg.org/specs/animations/
	https://w3c.github.io/svg-aam/#details-id-69
	`xml$r:~TR/2008/REC-xml-20081126/
	`css-scoping-1$r:~TR/css-scoping-1/
	~TR/dom/ →~DOM4
	~TR/2014/WD-dom-20140204/→~DOM4
	~TR/2014/CR-html5-20140204/dom.html→~HTMLdom
	~TR/html51/dom.html→~HTMLdom


●●words_table1
SVGeltindex:svg-eltindex-ja.html
use-:<code class="element">use</code>-
refX0:refX
refY0:refY
target0:target

●●words_table


	●構造
Shadow:
encapsulation::::カプセル化
light:
重製-:duplicate:複製
	重複する:duplicate
循環-:circular::~
循環する:circularになる::~
	:create a circular

	●構文
数字:digit::~
普通字:letter:~
約物:punctuation mark:~
	区切られた:separated

	●幾何
封入d:enclosed:封入
封入-:enclose:~
直径:diameter:~
2x3:2×3
単位i:identity::単位
点:point:~

	星形:star
	反対:opposite
	基準~点:reference point
	左上:top-left
	右:right
	右側:right-side
	合間:between
	成型する:extrude


	●呈示／UI／CSS
WAI-ARIA:
role:
zoom_pan:magnification and panning:::ズーム＆パン
再生-:play::~
複体:complex::~
単体:simple::~
hover:
tooltip::::ツールチップ
screen-reader:screen reader:::スクリーンリーダ
助言:help::~
感応する:sensitiveな:~
生来:natural::~

	●event
相:phase::~
捕捉-:capture::~
経路:path::~


	●仕様
視点:perspective:~
視聴者:audience:~
読上げる:readする:読み上げる
話者:-literate audience:~
言語上の:linguistic:~
不活:inert:~
事実:fact:~
保たれ:keepされ:~
冗長:redundant:~
呈-:exhibit:~
多方面:extensive:~
支援技術:assistive technology:~
文脈的:contextual:~
理想的:ideal:~
緩める:relaxする:~
競合-:conflict:~
自己完結的:self-contained:~

完璧:perfect:~
初学者:beginner:~
多言語の:multi-lingualな:~
	多言語の:multilingual
準拠-:comply:~
	準拠する:compliance with
機械実行可能:machine-extractable:~
アタる:consultする:あたる
指名-:designate:~
悟る:realizeする:~
一対一:one-to-one:~
拙く:poorに:~

	示した:illustrated
	用語で:in terms of
	適合する:in conformance with
	逆に:conversely
	万能な:catch-all
	~~同名の:corresponding
	~~同名の:matching
	~~実際に:indeed
	~~選択肢:choice
	〜に沿う:in line with
	その帰結として:In consequence
	できるようにする:allow
	〜の他に:aside from
	あり得る:potentially
	かなり:quite
	ごく:very
	そうなるとは限らない:not necessarily
	それでも，:nonetheless
	それも:once again
	ここでも:again
	できなくする:prevent 〜 from being successfully
	とされる:taken
	とする／想定-:suppose
	ないであろう:may not
	に乏しい:much
	に従って:as described in
	もたらす:lead
	一環として:matter of course through
	一式:suite
	下で:accordingly
	併用:used in conjunction with
	用途:use
	拙かった:poor
	文脈に~~富む:context-rich
	書き手:writer
	期待され:expectation
	様子:how
	~~自立する:stand by itself
	見込まれ:likely
	解し易さ:understandability
	読み解く:comprehension
	次に従って:as follows
	探して:look at
	よく似る:very similarly
	馴染んで:familiar
	拡げ:expand
	~~由来する:comes from
	~~無視して:place
	上述以外の~~点では:in all other ways
	鍵:key
	多くは:commonly
	注意されたし:warn
	注意すべき:notable
	大きく異なる~~点がある:notably different
	補足する:supplementary
	待っている:pending
	-:approach
	揃える:align with
	求まれない:unwanted


	●未分類
RDF:
switch:
open:
main:
	TODO
utility::便利
	視野-法:scoping
st_prop:state/property::［状態／property］:［状態／プロパティ］
template::::テンプレート
分割-:split::~
終止-:end::~
始動-:begin::~
	^en:timing
記号:symbol:~
	同時に:simultaneous
	~access:connect
整列-:align:~
累積的:cumulative:~
逐次的:sequential:~
連結-:concatenate:~
隅:corner:~
地図:map:~
往来用の:roundtripping::~
地域化d:localized::地域化::ローカル化
地域化-:localize::~::ローカル化
	localised
映出す:mirrorする:映し出す

綴り:spelling::~
線型:linear::~
迂回-:bypass:~
領域:region:~
処理待ち:pending::~
	凍結d:frozen:凍結
	~3D:three dimensions
私用:private::~::プライベート
British::英国
Dutch::オランダ語
English::英語
American::米国
偽:false::~
真:true::~
業務用:business:~
子付番:child-indexed::~

	着想を得た:inspire
keyframe:
factory::::ファクトリ
schema::::スキーマ
絵文字:emoji::~
図表:chart:~
pie-chart:pie chart:円グラフ
深く:deepに::~
深さ:depth::~

繰返し:repeatedly:繰り返し

	x
	y
	組み立て直:reassemble
	種類:kind
	入る:lie
	現在／現時点:currently
	書き出して:write
	読み戻し:reading
	読み戻し:read

	~~隠蔽:mask
	失わな:loss
	短い:short
	欠落している:missing
	~cloneして:cloning
	等しく:equally
	表:table
	遡っ:exiting
	近く:closely
	戻-:back
	属する:belong
	出る:go
	~~白い／~~白:white
	~~黒い:black
	ピンク:pink
	明るい:light green
	尻尾:tail
	尻尾:fluffy tails
	鼻:nose
	耳:ear
	生き物:creature
	体毛:fur
	兎:rabbit
	中世の養蜂:Medieval Bee-Keeping
	入門書:primer

	●言い換え
	-:datatype
	-:timed
	-:starts with
	-:total
	-:wide
	-:full stop
	-:hyphen-minus
	-:, or its future replacement
	-:cell
	-:"tabbing" refers to moving forward through
	-:talk about
	-:writable
	^i:forward
	:furthest
	:so that
	^e:marker
	^e:pattern
	^en:Status: done
	^en:tabindex
	^e:tspan
	^v:blue
	^v:green
	^v:orange
	^v:purple
	^kbd:tab
	~CSSによらない:non-CSS
	~style~clone法:style-cloning
	~styleし直され:re-styled
	~style照合:style-matching
	~targetし直す:retargeted／:retargeting／:retargetting
	~targetしている:targetting
	~targetにされ:targetted
	~test法:testing
	~access可能な:accessible
	~focus可能:focusable
	非~graphicな:non-graphical
	~group化:grouping
	~shadow~DOM:shadow-DOM
	~shadowも含む:shadow-including
	~instance化:instantiate
	~viewしている／~view法:viewing
	依拠-不能:unreliable
	取得子は…:points to
	同名の:equivalent
	変形-法~transforming
	変形されない:un-transformed
	子孫:descend from
	定義し直す:re-define
	抽象-~roleでない~role:non-abstract
	拡縮して収まる:scale-to-fit
	指す:point to
	指す:refer
	~~日本語訳:Maori
	時刻に基づく:time-based
	確立-法:establishing
	資源:asset
	高~level:higher-level
	~NULL でないこと:presence of this pointer
	~mouseが重なった:moused over
	~query:queries
	~version付け~versioning
	より容易に:easier
	より高く:higher
	交差している:partially or fully
	優先される:takes precedence over
	優先度は すべての〜よりも低い:lowest-priority match
	優先度／~rank
	何かを描く:drawing
	~member:properties and methods
	~errorになる:in error
	~~手続き:procedure
	接触判定:hit detection
	~scriptによる:scripted
	無名の:nameless な
	含めること:inclusion
	空~文字列:empty-string
	空白:space
	空白:white space
	最初の文字は:start with
	子:direct child
	名前~付き:named

	●指示語
後方:backwards:~
	いくつかの:a number of
	一部:parts of
	他にも:third
	までに至る:range from
	一連の:set of
	され続ける／あり続ける:remain
	のみならず:rather than solely
	ときには:sometimes
	冒頭近く:near the top
	末尾:end
	末端:end
	それ自体:itself
	何回も:multiple times
	一体:whole
	他の点では:otherwise 
	代わって:in place of
	以前の:earlier
	大きい:large
	逆も同様:vice versa
	途中:in the middle
	次:next
	更に:futher
	異なる:differently
	成すすべて:all parts of
	~~任意個数の:any number of
	全体が:entirely
	against

●●images
＠svg-resources/
Use-changed-styles｜｜｜Use-changed-styles.png
Use-visibility-inheritance｜｜｜Use-visibility-inheritance.png
Use-visibility-inheritance-2｜｜｜Use-visibility-inheritance.2.png


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="https://svgwg.org/svg2-draft/Overview.html">SVG 2 仕様</a>
の
<a href="~SPEC_URL">§ Document Structure</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>5. 文書構造 — Document Structure</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="NewDocument">
<h2 title="Defining an SVG document fragment: the ‘svg’ element">5.1. ~SVG文書片の定義-法： `svg^e 要素</h2>

		<section id="NewDocumentOverview">
<h3 title="Overview">5.1.1. 概観</h3>

<p>
`~SVG文書片$は、
`svg$e 要素の中に包含される~~任意個数の~SVG要素からなる。
◎
An SVG document fragment consists of any number of SVG elements contained within an ‘svg’ element.
</p>

<p>
~SVG文書片は、［
空な素片（すなわち，内容が無い `svg$e 要素）
］から，［
`rect$e などの~SVG`~graphics要素$を 1 個だけ包含するごく単純な~SVG文書片
］, ［
複階的で深く入子にされた，`容器~要素$や`~graphics要素$が成す~collection
］までに至る。
◎
An SVG document fragment can range from an empty fragment (i.e., no content inside of the ‘svg’ element), to a very simple SVG document fragment containing a single SVG graphics element such as a ‘rect’, to a complex, deeply nested collection of container elements and graphics elements.
</p>


<p>
~SVG文書片は、
自己完結的な~fileや資源として~~自立することも，
親~HTMLや~XML文書の中に素片として~inlineに埋込むこともできる。
前者の事例では、
~SVG文書片は，~SVG文書になる。
◎
An SVG document fragment can stand by itself as a self-contained file or resource, in which case the SVG document fragment is an SVG document, or it can be embedded inline as a fragment within a parent HTML or XML document.
</p>

<div class="example">

<p id="EmbeddedSVGExample">
次の例に、
親~XML文書の中に素片として~inlineに埋込まれた単純な~SVG内容を示す。
~XML名前空間を利用して，［
`svg$e ／ `ellipse$e
］要素が`~SVG名前空間$に属するよう指示していることに注意：
◎
The following example shows simple SVG content embedded inline as a fragment within a parent XML document. Note the use of XML namespaces to indicate that the ‘svg’ and ‘ellipse’ elements belong to the SVG namespace:
</p>


<pre class="lang-xml">
&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;parent xmlns="http://example.org"
        xmlns:svg="http://www.w3.org/2000/svg"&gt;
   &lt;!-- <span class="comment">
ここには親の内容がある
◎
parent contents here
</span> --&gt;
   &lt;svg:svg width="4cm" height="8cm"&gt;
      &lt;svg:ellipse cx="2cm" cy="4cm" rx="2cm" ry="1cm" /&gt;
   &lt;/svg:svg&gt;
   &lt;!-- ... --&gt;
&lt;/parent&gt;
</pre>

</div>


<div class="example">

<p>
もう少し複階的で（すなわち，複数の矩形を包含する）自己完結的な自立的~SVG文書を、
次の例に示す：
◎
This example shows a slightly more complex (i.e., it contains multiple rectangles) stand-alone, self-contained SVG document:
</p>

<pre class="lang-xml">
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;svg width="5cm" height="4cm" version="1.1"
     xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;desc&gt;<span class="comment">
4 個の別々の矩形
◎
Four separate rectangles
</span>&lt;/desc&gt;
    &lt;rect x="0.5cm" y="0.5cm" width="2cm" height="1cm"/&gt;
    &lt;rect x="0.5cm" y="2cm" width="1cm" height="1.5cm"/&gt;
    &lt;rect x="3cm" y="0.5cm" width="1.5cm" height="2cm"/&gt;
    &lt;rect x="3.5cm" y="3cm" width="1cm" height="0.5cm"/&gt;

  &lt;!-- <span class="comment">
`rect^e 要素を利用して 表示域の外形線を示す

◎
Show outline of viewport using 'rect' element
</span> --&gt;
  &lt;rect x=".01cm" y=".01cm" width="4.98cm" height="3.98cm"
        fill="none" stroke="blue" stroke-width=".02cm" /&gt;

&lt;/svg&gt;
</pre>
</div>

<p>
`svg$e 要素は、
~SVG内容の途中にも現れ得る。
これが、~SVG文書片を他の~SVG文書片の中に埋込む仕組みを成す。
◎
‘svg’ elements can appear in the middle of SVG content. This is the mechanism by which SVG document fragments can be embedded within other SVG document fragments.
</p>

<p>
~SVG内容の途中に `svg$e 要素を置く別の利用には、
新たな~SVG表示域を確立することもある。
（`§ 新たな~SVG表示域の確立-法＠~SVGcoords#EstablishingANewSVGViewport$を見よ。）
◎
Another use for ‘svg’ elements within the middle of SVG content is to establish a new SVG viewport. (See Establishing a new SVG viewport.)
</p>

		</section>
		<section id="Namespace">
<h3 title="Namespace">5.1.2. 名前空間</h3>

<p>
~SVGが~XMLとして構文解析されるときは、
`xml-names$r 勧告に準拠するためには、
~SVG名前空間~宣言を供して，［
すべての~SVG要素は~SVG名前空間に属している
］ものと識別されるようにしなければナラナイ。
◎
When SVG is parsed as a XML, for compliance with the Namespaces in XML Recommendation [xml-names], an SVG namespace declaration must be provided so that all SVG elements are identified as belonging to the SVG namespace.
</p>

<p>
この名前空間は、
~HTML構文を利用しているときは，~HTML構文解析器により自動的に供される。
◎
When using the HTML syntax, the namespace is provided automatically by the HTML parser.
</p>

<div class="example">
<pre class="lang-html">
&lt;html&gt;
&lt;svg viewBox="0 0 100 100"&gt;
  &lt;circle cx="50" cy="50" r="50" fill="green"&gt;
&lt;/svg&gt;
&lt;/html&gt;
</pre>

</div>


<p>
上の例が示すように，~HTML構文解析器を利用しているときは、［
`xmlns^a 属性で，要素は~SVG名前空間に属するものと宣言する
］必要はない。
~HTML構文解析器は、
自動的に適正な名前空間に属するように，~SVG要素を作成することになる。
◎
As the example shows there's no need to have an ‘xmlns’ attribute declaring that the element is in the SVG namespace when using the HTML parser. The HTML parser will automatically create the SVG elements in the proper namespace.
</p>


<p class="issue" id="issue1">
この節は、
文書の挙動が~DOMの用語では どう定義され，
~HTML構文解析器は~SVG素片を どう作成できるかについて説明するベキである。
◎
This section should talk about how a document's behavior is defined in terms of the DOM, and also explain how the HTML parser can create SVG fragments.
</p>

<p>
~SVG-2名前空間は、
以前の~versionの~SVGと同じく
`http://www.w3.org/2000/svg^l
とする。
◎
The SVG 2 namespace is http://www.w3.org/2000/svg, which is the same as for earlier versions of SVG.
</p>

<p>
~SVGが~XMLとして構文解析されるときに，名前空間~宣言を供するアリな仕方を次に示す。
`svg$e 要素には、
名前空間~接頭辞を伴わない `xmlns^a 属性も指定できる
— それは、 `xmlns^a 属性を有する要素の視野に入る，どの要素に対しても、
その既定の名前空間は~SVGになることを意味する：
◎
The following are possible ways to provide a namespace declaration when SVG is parsed as XML. An ‘xmlns’ attribute without a namespace prefix could be specified on an ‘svg’ element, which means that SVG is the default namespace for all elements within the scope of the element with the ‘xmlns’ attribute:
</p>

<pre class="lang-xml">
&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"&gt;
  &lt;rect x="10" y="10" width="80" height="80" fill="green" /&gt;
&lt;/svg&gt;
</pre>


<p>
`xmlns^a 属性に名前空間~接頭辞を指定した場合
（例： `xmlns:svg="http://www.w3.org/2000/svg"^c ），
対応する名前空間は既定の名前空間にはならないので、
各~要素に明示的に，名前空間~接頭辞をアテガわなければナラナイ：
◎
If a namespace prefix is specified on the ‘xmlns’ attribute (e.g., xmlns:svg="http://www.w3.org/2000/svg"), then the corresponding namespace is not the default namespace, so an explicit namespace prefix must be assigned to the elements:
</p>

<pre class="lang-xml">
&lt;svg:svg xmlns:svg="http://www.w3.org/2000/svg" viewBox="0 0 100 100"&gt;
  &lt;svg:rect x="10" y="10" width="80" height="80" fill="green" /&gt;
&lt;/svg:svg&gt;
</pre>


<p>
名前空間~接頭辞は、
先祖~要素にも指定できる
（`上の例＠#EmbeddedSVGExample$に示したように）。
更なる情報は、 `xml-names$r 勧告を見よ。
◎
Namespace prefixes can be specified on ancestor elements (illustrated in the above example). For more information, refer to the Namespaces in XML Recommendation [xml-names].
</p>

		</section>
		<section id="Definitions">
<h3 title="Definitions">5.1.3. 定義</h3>

<dl class="definitions">
	<dt>
`構造上の要素@
（ `structural element^en ）
</dt>
	<dd>
~SVG文書の首な構造を定義する要素。
特定的には、次に挙げる要素
⇒＃
`defs$e,
`g$e,
`svg$e,
`symbol$e,
`use$e
◎
The structural elements are those which define the primary structure of an SVG document. Specifically, the following elements are structural elements: ‘defs’, ‘g’, ‘svg’, ‘symbol’ and ‘use’.
</dd>

	<dt>
`構造的に外部の要素@
（ `structurally external element^en ）
</dt>
	<dd>
自身の構造を外部~資源への参照により定義する要素。
特定的には、次に挙げる要素のうち， `href^a 属性を有するもの
⇒＃
`foreignObject$e,
`image$e,
`script$e,
`use$e
◎
Elements that define its structure by reference to an external resource. Specifically, the following elements are structurally external elements when they have an ‘href’ attribute: ‘foreignObject’, ‘image’, ‘script’ and ‘use’.
</dd>

	<dt>
`現在の~SVG文書片@
（ `current SVG document fragment^en ）
</dt>
	<dd>
所与の要素に対し，その`最外縁の~svg要素$を根とする文書~下位tree
◎
↓</dd>

	<dt>
`最外縁の~svg要素@
（ `outermost svg element^en ）
</dt>
	<dd>
所与の要素に対し、
次を満たす `svg$e 要素のうち，最も根に近いもの
⇒
［
要素~自身†または要素の先祖である
］~AND［
要素の先祖であって `svg$e 要素の子孫である どの要素も~SVG名前空間に属する
］
◎
The document sub-tree which starts with the outermost ancestor ‘svg’ element of a given SVG element, with the requirement that all container elements between the outermost ‘svg’ and the given element are all elements in the SVG namespace.
◎
The furthest ‘svg’ ancestor element that remains in the current SVG document fragment.
</dd>
	<dd class="trans-note">【
原文の定義には，要素~自身は明示的に含められていないが、
そうすると，`最外縁の~svg要素$に対しては`最外縁の~svg要素$が定義されなくなる。
】【
定義により，該当する `svg^e 要素が無い場合もあり得るが、
そのような文脈でこの用語が利用されることは，通例的にない。
】</dd>

	<dt>
`~SVG文書片@
（ `SVG document fragment^en ）
</dt>
	<dd>
次を満たす `svg$e 要素を根とする文書~下位tree
⇒
［
文書の根~要素である
］~OR［
要素の親は~SVG名前空間に属さない
］
◎
A document sub-tree which starts with an ‘svg’ element which is either the root element of the document or whose parent element is not in the SVG namespace.＼
</dd>
	<dd>
~SVG文書片は
自立的~SVG文書であるか，
親~文書を成す `svg$e 要素に封入された素片からなり得る。
しかしながら，
`svg$e 要素のうち，親も~SVG名前空間に属するものは、
~SVG文書片の根にならない。
◎
An SVG document fragment can consist of a stand-alone SVG document, or a fragment of a parent document enclosed by an ‘svg’ element. Howevere, an ‘svg’ element that is a direct child of another SVG-namespaced element is not the root of an SVG document fragment.
</dd>

	<dt>
`~SVG要素@
（ `SVG elements^en ）
</dt>
	<dd>
`~SVG名前空間$に属する~~任意の要素。
◎
Any element in the SVG namespace.
</dd>

	<dt>
`~graphics要素@
（ `graphics element^en ）
</dt>
	<dd>
~target~canvas上に~graphicを描かせ得る要素~型
— 特定的には、次に挙げる要素
⇒＃
`circle$e,
`ellipse$e,
`foreignObject$e,
`image$e,
`line$e,
`path$e,
`polygon$e,
`polyline$e,
`rect$e,
`text$e,
`textPath$e,
`tspan$e
◎
One of the element types that can cause graphics to be drawn onto the target canvas. Specifically: ‘circle’, ‘ellipse’, ‘foreignObject’, ‘image’, ‘line’, ‘path’, ‘polygon’, ‘polyline’, ‘rect’, ‘text’, ‘textPath’ and ‘tspan’.
</dd>

	<dt>
`~graphicを参照する要素@
（ `graphics referencing element^en ）
</dt>
	<dd>
~graphics要素のうち，自身の~graphicな内容の~sourceとして
異なる文書／要素への参照を利用するもの
— 特定的には、次に挙げる要素
⇒＃
`image$e,
`use$e
◎
A graphics element which uses a reference to a different document or element as the source of its graphical content. Specifically: ‘image’ and ‘use’.
</dd>
</dl>

		</section>
		<section id="SVGElement">
<h3 title="The ‘svg’ element">5.1.4. `svg^e 要素</h3>

<div class="annotation svg2-requirement">

<p>
~SVG-2要件：
`svg$e 要素の変形-法を~supportする。
◎
SVG 2 Requirement: Support transforming ‘svg’ elements.
</p>
<ul>
	<li>
解決：
~SVG-2は、
`svg^e 上に `transform^a 属性を許容する
（`~~参照先＠http://www.w3.org/2011/10/28-svg-irc#T00-23-44$）。
◎
Resolution: We will allow ‘transform’ on ‘svg’ in SVG 2.
</li>
	<li>
目的：
作者の期待に沿うよう，入子な `svg$e 要素に対する変形を許容する。
◎
Purpose: To allow transforms on nested ‘svg’ elements, in line with author expectations.
</li>
	<li>
Owner:
Dirk (no action)
</li>
	<li>
`Status: done^en
</li>
</ul>

</div>

◎要素名 `svg@e
◎分類 `容器~要素$, `描画-可能な要素$, `構造上の要素$
◎内容 任意個数, 任意順序の，次に挙げる要素
⇒＃
`~animation要素$,
`記述的~要素$,
`塗り~server要素$,
`図形~要素$,
`構造上の要素$,
`a$e,
`clipPath$e,
`filter$e,
`foreignObject$e,
`image$e,
`marker$e,
`mask$e,
`script$e,
`style$e,
`switch$e,
`text$e,
`view$e
◎属性
`~ARIA属性$,
`条件付き処理~属性$,
`中核~属性$,
`文書~event属性$,
`大域~event属性$,
`文書~要素~event属性$,
`呈示~属性$,
`viewBox$a,
`preserveAspectRatio$a,
`transform$p
◎幾何
`x$p, `y$p, `width$p, `height$p
◎界面 `SVGSVGElement$I
◎表終

<p>
［
`x$p, `y$p
］属性は、
埋込d `svg$e 要素が配置される矩形な領域の左上~隅を指定する。
`最外縁の~svg要素$上では，これらの属性の効果は無い。
◎
The x and y attributes specify the top-left corner of the rectangular region into which an embedded ‘svg’ element is placed. On an outermost svg element, these attributes have no effect.
</p>

<p>
`最外縁の~svg要素$用の［
`width$p, `height$p
］属性は、~SVG文書片の`生来な~size$を指定する。
埋込d `svg$e 要素~用のそれらは、
`svg$e 要素が配置される矩形な領域の~sizeを指定する。
どちらの事例でも，算出d~style `auto^v は `100%^v と等価に扱われる。
◎
For outermost svg elements, the width and height attributes specify the intrinsic size of the SVG document fragment. For embedded ‘svg’ elements, they specify the size of the rectangular region into which the ‘svg’ element is placed. In either case, a computed style of auto is treated equivalent to 100%.
</p>

<p>
別の文書の成分として参照されると見込まれる~SVG文書に対しては、
作者は 参照先の文書の`最外縁の~svg要素$上の `viewBox$a 属性を含めたいと求めることが多い。
この属性は、［
~SVG文書は、任意な~SVG表示域の中に拡縮して収まる
］よう設計する，簡便な仕方を供する。
◎
If an SVG document is likely to be referenced as a component of another document, the author will often want to include a ‘viewBox’ attribute on the outermost svg element of the referenced document. This attribute provides a convenient way to design SVG documents to scale-to-fit into an arbitrary SVG viewport.
</p>

<p id="SVGElementEventHandlerAttributes">
`svg$e 要素は、
`Window$I ~objのいくつかの`~event~handler$を`~event~handler内容~属性$として公開する。
また、`~event~handler~IDL属性$を映出す。
◎
The ‘svg’ element exposes as event handler content attributes a number of the event handlers of the Window object. It also mirrors their event handler IDL attributes.
</p>

<p>
`Window$I ~objの［
`onblur$a,
`onerror$a,
`onfocus$a,
`onload$a,
`onscroll$a
］`~event~handler$は、
`svg$e 要素~上に公開され，`~SVG要素$が通常に~supportする同じ名前の汎用`~event~handler$を置換する。
◎
The onblur, ‘onerror’, onfocus, ‘onload’, and ‘onscroll’ event handlers of the Window object, exposed on the ‘svg’ element, replace the generic event handlers with the same names normally supported by SVG elements.
</p>


		</section>
	</section>
	<section id="Groups">
<h2 title="Grouping: the ‘g’ element">5.2. ~group化： `g^e 要素</h2>

		<section id="GroupsOverview">
<h3 title="Overview">5.2.1. 概観</h3>

<dl class="definitions">
	<dt>
`容器~要素@
（ `container element^en ）
</dt>
	<dd>
子~要素として［
`~graphics要素$／ 他の容器~要素
］を持てる要素
— 特定的には：
`a$e,
`clipPath$e,
`defs$e,
`g$e,
`marker$e,
`mask$e,
`pattern$e,
`svg$e,
`switch$e,
`symbol$e
◎
An element which can have graphics elements and other container elements as child elements. Specifically: ‘a’, ‘clipPath’, ‘defs’, ‘g’, ‘marker’, ‘mask’, ‘pattern’, ‘svg’, ‘switch’ and ‘symbol’.
</dd>
</dl>

<p>
`g$e 要素は、
関係する`~graphics要素$を一緒に~group化するための`容器~要素$である。
◎
The ‘g’ element is a container element for grouping together related graphics elements.
</p>

<p>
要素たちが成す~groupにも, 個々の~objにも、
`id$a 属性を利用して名前を付与できる。
名前~付き~groupは~animationや再利用-可能な~objなど，
いくつかの目的に必要になる。
◎
A group of elements, as well as individual objects, can be given a name using the ‘id’ attribute. Named groups are needed for several purposes such as animation and re-usable objects.
</p>

<div class="example">
<p>
例：
◎
An example:
</p>

<pre class="lang-xml">
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;svg xmlns="http://www.w3.org/2000/svg"
     version="1.1" width="5cm" height="5cm"&gt;
  &lt;desc&gt;<span class="comment">
2 個の~group
— それぞれ、 2 個の矩形からなる
◎
Two groups, each of two rectangles
</span>&lt;/desc&gt;
  &lt;g id="group1" fill="red"&gt;
    &lt;rect x="1cm" y="1cm" width="1cm" height="1cm"/&gt;
    &lt;rect x="3cm" y="1cm" width="1cm" height="1cm"/&gt;
  &lt;/g&gt;
  &lt;g id="group2" fill="blue"&gt;
    &lt;rect x="1cm" y="3cm" width="1cm" height="1cm"/&gt;
    &lt;rect x="3cm" y="3cm" width="1cm" height="1cm"/&gt;
  &lt;/g&gt;

  &lt;!-- <span class="comment">
`rect^e 要素を利用して表示域の外形線を示す
◎
Show outline of viewport using 'rect' element
</span> --&gt;
  &lt;rect x=".01cm" y=".01cm" width="4.98cm" height="4.98cm"
        fill="none" stroke="blue" stroke-width=".02cm"/&gt;
&lt;/svg&gt;
</pre>

`struct/grouping01.svg^viewAs

</div>


<p>
`g$e 要素は、
他の `g$e 要素を任意な深さまで入子にして包含できる。
◎
A ‘g’ element can contain other ‘g’ elements nested within it, to an arbitrary depth.
</p>

		</section>
		<section id="GElement">
<h3 title="The ‘g’ element">5.2.2. `g^e 要素</h3>

◎要素名 `g@e
◎分類 `容器~要素$, `描画-可能な要素$, `構造上の要素$
◎内容 任意個数, 任意順序の，次に挙げる要素
⇒＃
`~animation要素$
`記述的~要素$
`塗り~server要素$
`図形~要素$
`構造上の要素$
`a$e,
`clipPath$e,
`filter$e,
`foreignObject$e,
`image$e,
`marker$e,
`mask$e,
`script$e,
`style$e,
`switch$e,
`text$e,
`view$e
◎属性
`~ARIA属性$,
`条件付き処理~属性$,
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$,
`呈示~属性$
◎界面 `SVGGElement$I
◎表終

		</section>
	</section>
	<section id="Head">
<h2 title="Defining content for reuse, and the ‘defs’ element">5.3. 再利用する内容の定義-法と `defs^e 要素</h2>

		<section id="Overview">
<h3 title="Overview">5.3.1. 概観</h3>

<p>
~SVGでは、
~graphicな~objを後で再利用できるように定義することも許容される。
これを行うため、
~SVGでは，`~URL参照$ `rfc3987$r 構成子を多方面に用立てる。
◎
SVG allows a graphical object to be defined for later reuse. To do this, SVG makes extensive use of the URL reference construct [rfc3987].＼
</p>

<div class="example">

<p>
例えば次のように、
`linearGradient$e 要素を定義しておいて，
その `id$a 属性を矩形の `fill$p ~propの値から参照すれば、
矩形を線型~gradientで~fillできる：
◎
For example, to fill a rectangle with a linear gradient, a ‘linearGradient’ element may be defined with an ‘id’ property that may be referenced in the value for the rectangle's fill property, as in the following:
</p>
<pre class="lang-xml">
&lt;linearGradient id="MyGradient"&gt;...&lt;/linearGradient&gt;
&lt;rect style="fill:url(#MyGradient)"/&gt;
</pre>

</div>

<p>
要素~型には、
~gradientなど，それ自体は~graphicな結果を生産しないものもあり、
したがって，どこにでも簡便な所に配置できる。
しかしながら，ときには、
~graphicな~objを
— 他所から参照するだけに限るよう —
直には描画されないように定義したいと欲されることもある。
これを行うため, および定義される内容を簡便に~group化できるようにするため、
~SVGは `defs^e 要素を供する。
◎
Some types of element, such as gradients, will not by themselves produce a graphical result. They can therefore be placed anywhere convenient. However, sometimes it is desired to define a graphical object and prevent it from being directly rendered. it is only there to be referenced elsewhere. To do this, and to allow convenient grouping defined content, SVG provides the ‘defs’ element.
</p>

<p>
参照先の要素は、
アリな所では，それを利用する要素より文書~順序で先に定義することが推奨される。
参照されるすべての要素を，~fileの冒頭近くにある `defs$e 要素の内側に収集しておけば、
~markupを読んだり解するのも より容易になり得る。
◎
It is recommended that, where possible, referenced elements be defined prior to the elements that use them, in document order. Collecting all referenced elements inside of a single ‘defs’ element near the top of the file can make the markup easier to read and understand.
</p>

		</section>
		<section id="DefsElement">
<h3 title="The ‘defs’ element">5.3.2. `defs^e 要素</h3>

◎要素名 `defs@e
◎分類 `容器~要素$, `決して描画されない要素$, `構造上の要素$
◎内容 任意個数, 任意順序の，次に挙げる要素
⇒＃
`~animation要素$
`記述的~要素$
`塗り~server要素$
`図形~要素$
`構造上の要素$
`a$e,
`clipPath$e,
`filter$e,
`foreignObject$e,
`image$e,
`marker$e,
`mask$e,
`script$e,
`style$e,
`switch$e,
`text$e,
`view$e
◎属性
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$,
`呈示~属性$
◎界面 `SVGDefsElement$I
◎表終


<p>
`defs$e 要素は、
`参照先の要素＠#Head$用の容器~要素を成す。
解し易さと`~accessibility＠~SVGmisc#access$の理由から、
アリなときは，参照先の要素を `defs$e の内側に定義することが推奨される。
◎
The ‘defs’ element is a container element for referenced elements. For understandability and accessibility reasons, it is recommended that, whenever possible, referenced elements be defined inside of a ‘defs’.
</p>

<p>
`defs$e 用の内容~modelは、
`g$e 要素~用のそれと同じである。
したがって， `g$e の子になれる要素は `defs$e の子になれ、
逆も同様になる。
◎
The content model for ‘defs’ is the same as for the ‘g’ element; thus, any element that can be a child of a ‘g’ can also be a child of a ‘defs’, and vice versa.
</p>

<p>
`defs$e の子孫である要素は、
直に描画されることはない。
`defs$e 要素~用の `display$p 値は、
`~UA~stylesheet$により，常に `none^v に設定されるモノトスル
— この宣言の重要度は，他のどの［
~CSS規則／呈示~属性
］よりも高いモノトスル。
しかしながら， `defs$e 要素の子孫は、
~source~tree内に常に在るので
— `defs$e 要素~上の `display$p ~propの値にかかわらず —
他の要素から常に参照できることに注意。
◎
Elements that are descendants of a ‘defs’ are not rendered directly; the display value for the ‘defs’ element must always be set to none by the user agent style sheet, and this declaration must have importance over any other CSS rule or presentation attribute. Note, however, that the descendants of a ‘defs’ are always present in the source tree and thus can always be referenced by other elements; thus, the value of the display property on the ‘defs’ element does not prevent those elements from being referenced by other elements.
</p>

		</section>
	</section>
	<section id="SymbolElement">
<h2 title="The ‘symbol’ element">5.4. `symbol^e 要素</h2>

<p>
`symbol$e 要素は、［
`use$e 要素により~instance化できるが直には描画されない，~graphicな~template
］を定義するために利用される。
◎
The ‘symbol’ element is used to define graphical templates which can be instantiated by a ‘use’ element but which are not rendered directly.
</p>

<p>
`symbol$e は、
入子な座標系を，自身が包含する~graphic用に確立する。
したがって， `use$e 要素の`参照先の要素$として~instance化された `symbol^e の描画は、
入子な `svg$e 要素とよく似る。
◎
A ‘symbol’ establishes a nested coordinate system for the graphics it contains. When a symbol is instantiated as the referenced element of a ‘use’ element, it is therefore rendered very similarly to a nested ‘svg’ element.
</p>

◎要素名 `symbol@e
◎分類 `容器~要素$, `構造上の要素$
◎内容 任意個数, 任意順序の，次に挙げる要素
⇒＃
`~animation要素$
`記述的~要素$
`塗り~server要素$
`図形~要素$
`構造上の要素$
`a$e,
`clipPath$e,
`filter$e,
`foreignObject$e,
`image$e,
`marker$e,
`mask$e,
`script$e,
`style$e,
`switch$e,
`text$e,
`view$e
◎属性
`~ARIA属性$,
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$,
`呈示~属性$,
`preserveAspectRatio$a,
`viewBox$a,
`refX$a,
`refY$a
◎幾何 `x$p, `y$p, `width$p, `height$p
◎界面 `SVGSymbolElement$I
◎表終

<p>
`use$e 要素が~instance化した `symbol$e 上の［
`x$p ／ `y$p ／ `width$p ／ `height$p
］幾何~propの効果は、
`svg$e 要素と同じになる。
特に［
`width$p ／ `height$p
］の算出d値が `auto^v である
（かつ，それを~instance化した `use$e 要素~上の値で上書きされていない）
場合、
値 `100%^v として扱われることになる。
◎
The x, y, width, and height geometry properties have the same effect as on an ‘svg’ element, when the ‘symbol’ is instantiated by a ‘use’ element. In particular, if width and height compute to auto (and are not over-ridden by values on the instantiating ‘use’ element), then they will be treated as a value of 100%.
</p>


<p class="note">注記：
~SVG-2にて新たに~~導入された。
`symbol^e 上に幾何~propを指定できるようにすることで、
より一貫した描画~modelが得られ，
作者は 各 `symbol^e 用に既定の~sizeを設定できるようになる
（それは、依然として `use$e 要素~上の属性で上書きできる）。
◎
New in SVG 2. Allowing geometry properties to be specified on a symbol provides a more consistent rendering model, and allows authors to set a default size for each symbol (which may still be over-ridden by attributes on the ‘use’ element).
</p>

		<section id="SymbolAttributes">
<h3 title="Attributes">5.4.1. 属性</h3>

<dl class="attrdef-list">
	<dt>
◎属名 `refX@a
◎属値 `length$t | `left^v | `center^v | `right^v
◎属初 （ナシ）
◎属ア 可
◎表終
◎
Name 	Value 	Initial value 	Animatable
refX 	&lt;length&gt; | left | center | right 	(none) 	yes
</dt>
	<dt>
◎属名 `refY@a
◎属値 `length$t | `top^v | `center^v | `bottom^v
◎属初 （ナシ）
◎属ア 可
◎表終
◎
refY 	&lt;length&gt; | top | center | bottom 	(none) 	yes
</dt>
	<dd class="note">注記：
~SVG-2にて新たに~~導入された。
`symbol^e を特定0の点に整列する（地図~内で行われることが多い）のを容易にするために追加された。
これは、 `marker$e 上の~~同名の属性に類似する。
◎
New in SVG 2. Added to make it easier to align symbols to a particular point, as is often done in maps. Similar to the matching attributes on ‘marker’.
</dd>
	<dd class="annotation">
`symbol^e 要素に［
`refX^a, `refY^a
］を追加する。
`Leipzig F2F＠http://www.w3.org/2014/04/08-svg-minutes.html#item12$
にて解決された。
`Status: done^en
◎
Add refX/refY to symbol element. Resolved at Leipzig F2F. Status: Done.
</dd>
	<dd class="annotation">
［
`marker^e, `symbol^a
］上の［
`refX^a ／`refY^a
］に~keyword［
`left^v, `center^v, `right^v ／
`top^v, `center^v, `bottom^v
］を追加する。
`London F2F＠http://www.w3.org/2014/08/26-svg-minutes.html#item07$
にて解決された。
値は、 `background-position$p から着想を得ている。
`Status: done^en
◎
We will add top/center/bottom, left/center/right keywords to refX/refY on marker/symbol. Resolved at London F2F. Values inspired by 'background-position'. Status: Done.
</dd>
	<dd>
［
`refX$a, `refY$a
］属性は、
基準~点を定義する
— `symbol^e 要素は、
その `位置決め座標^i と この基準~点が正確に一致するように配置される。
位置決め座標は、
要素の［
`x$p, `y$p
］~prop, および［
要素, 要素の`~host$ `use$e 要素
］上の座標系変換による累積的な効果により定義される。
◎
The ‘refX’ and ‘refY’ attributes define the reference point of the symbol which is to be placed exactly at the symbol's x,y positioning coordinate, as defined by the cumulative effect of the x and y properties and any transformations on the ‘symbol’ and its host ‘use’ element.
</dd>
	<dd>
各種~keyword値の意味は、
`marker$e 要素~上の［
`~refX0$a, `~refY0$a
］属性~用のそれと同じで、
属性の適用-可能な方向における［
0% ／ 50% ／ 100%
］に解決される。
◎
Keyword values have the same meaning as for the ‘refX’ and ‘refY’ attributes on the ‘marker’ element, resolving to 0%, 50%, or 100% in the applicable direction.
</dd>
	<dd>
他の位置決め属性と違って，［
`refX$a, `refY$a
］が与える基準~点は、［
`viewBox$a, `preserveAspectRatio$a
］属性を適用した後における，
`symbol^e の内容が属する座標系~内にあるものと解釈される。
［
`refX^a ／ `refY^a
］属性が指定されていない場合、
`symbol^e の表示域を成す矩形~領域の［
左端／上端
］が，要素の `位置決め座標^i に一致するように配置される
（要素の `viewBox$a 座標に関わらず）。
◎
Unlike other positioning attributes, ‘refX’ and ‘refY’ are interpreted as being in the coordinate system of the symbol contents, after application of the ‘viewBox’ and ‘preserveAspectRatio’ attributes. If one or both of the attributes is not specified, no adjustment is made in the corresponding dimension, and the top or left side of the symbol's rectangular viewport region (regardless of the ‘viewBox’ coordinates) is positioned at the x,y point.
</dd>
	<dd class="note">注記：
後方-互換性を得るため、
`symbol$e 上に［
`refX$a ／ `refY$a
］が指定されていないときの挙動は，
値 `0^v が指定されたときと異なる
— したがって， `marker$e 上に~~同名の属性（初期~値 `0^v ）が指定されていないときと異なる。
◎
For backwards compatibility, the behavior when ‘refX’ and ‘refY’ are not specified on a ‘symbol’ is different from when they are specified with a value of 0, and therefore different from the behavior when equivalent attributes are not specified on a ‘marker’.
</dd>
</dl>

		</section>
		<section id="SymbolNotes">
<h3 title="Notes on symbols">5.4.2. `symbol^e に対する注記</h3>

<p>
同じ文書~内で何回も利用される~graphicとしての，
`symbol$e 要素の利用は、
構造と意味論を追加する。
`symbol$e 要素と［
`marker$e, `pattern$e
］要素は、
いずれも［
~SVG内で様々な位置に様々な拡縮率で繰返し描画できる~graphicな内容
］の容器を定義する~~点で近く関係する。
しかしながら、［
`marker^e ／ `pattern^e
］内の`再利用される~graphic$は，別の要素~上の~graphicな効果を供する一方で、
`symbol$e の内容は，`~use要素の~shadow~tree$の中に対話的な内容として全部的に埋込まれる。
◎
The use of ‘symbol’ elements for graphics that are used multiple times in the same document adds structure and semantics. Closely related to the ‘symbol’ element are the ‘marker’ and ‘pattern’ elements; all three define a container of graphical content that can be rendered repeatedly at various positions and scales in the SVG. However, while re-used graphics in a pattern and marker provide a graphical effect on another element, the content in a ‘symbol’ will be embedded as fully interactive content, within a use-element shadow tree.
</p>

<p>
`~UA~stylesheet$は、
`symbol$e 要素~用の `overflow$p ~propを `hidden^v に設定する
— それにより、
`symbol^e の~SVG表示域の限界域を成す，矩形な切抜き~pathが作成される。
`overflow$p ~propが上書きされない限り、［
`symbol^e の中にある~graphicのうち， `symbol^e の表示域の外側へ出る部分
］は，切取られる。
◎
The user agent style sheet sets the overflow property for ‘symbol’ elements to hidden, which causes a rectangular clipping path to be created at the bounds of symbol's SVG viewport. Unless the overflow property is overridden, any graphics within the symbol which goes outside of the symbol's SVG viewport will be clipped.
</p>

<p>
`symbol$e 要素は、
決して直に描画されないモノトスル
— その用法は、
`use$e 要素を利用して参照できる何かとしてに限られる。
`symbol$e 要素に対する `display$p 値は、
`~UA~stylesheet$により，常に `none^v に設定されるモノトスル
— この宣言の重要度は，他のどの［
~CSS規則／呈示~属性
］よりも高いモノトスル。
◎
‘symbol’ elements must never be rendered directly; their only usage is as something that can be referenced using the ‘use’ element. The user agent must set the display property on the ‘symbol’ element to none, as part of the user agent style sheet, and this declaration must have importance over any other CSS rule or presentation attribute.
</p>

<p>
`symbol$e から生成される`要素~instance$のうち，
`use$e 要素が直に`参照している＠#TermReferencedElement$ものは、
その
`display$p ~prop用の算出d値は常に `inline^v にされるモノトスル
— 言い換えれば、
その要素~instanceは，~host `use$e 要素が描画されるときには描画されるモノトスル。
ここでも，`~UA~stylesheet$は、
この宣言の重要度を 他のどの［
~CSS規則／呈示~属性
］よりも高いものと定義する。
他の，［
`~use要素の~shadow~tree$の中で`要素~instance$を作成するよう~cloneされた `symbol$e
］は、 `symbol^e 定義として挙動するので，描画されないモノトスル。
◎
The generated instance of a ‘symbol’ that is the direct referenced element of a ‘use’ element must always have a computed value of inline for the display property. In other words, it must be rendered whenever the host ‘use’ element is rendered. The user agent style sheet again defines this declaration to have importance over any other CSS rule or presentation attribute. Any other ‘symbol’ that is cloned to create an element instance within the use-element shadow tree behaves as a symbol definition, and must not be rendered.
</p>

		</section>
	</section>
	<section id="UseElement">
<h2 title="The ‘use’ element">5.5. `use^e 要素</h2>

<div class="annotation svg2-requirement">

<p>
~SVG-2要件：［
素片を省略することにより，外部~文書の根~要素を参照する
］ことを， `use$e 要素に許容する。
◎
SVG 2 Requirement: Allow ‘use’ to reference an external document's root element by omitting the fragment.
</p>
<ul>
	<li>
解決：
［
素片を落とすことは根~要素への参照を意味する
］ことを許容するように，特定0の要素を参照するときの要件を緩める
— ~SVG-2においては `use^e など，それがイミを成す所では
（`~~参照先＠http://www.w3.org/2011/10/28-svg-irc#T00-33-43$）。
◎
Resolution: We will relax referencing requirements to particular elements to allow dropping fragments to mean referencing root element, where it makes sense, such as with use, in SVG 2.
</li>
	<li>
目的：
参照先の文書を改変して根~要素に~IDを追加することを，作者に要求するのを避ける。
◎
Purpose: To avoid requiring authors to modify the referenced document to add an ID to the root element.
</li>
	<li>
Owner:
Cameron (`3417$ACTION)
</li>
	<li>
`Status: done^en
</li>
</ul>
</div>


◎要素名 `use@e
◎分類 `~graphicを参照する要素$, `描画-可能な要素$, `構造上の要素$, `構造的に外部の要素$
◎内容 任意個数, 任意順序の，次に挙げる要素
⇒＃
`~animation要素$
`記述的~要素$
`clipPath$e,
`mask$e,
`script$e,
`style$e
◎属性
`~ARIA属性$,
`中核~属性$,
`条件付き処理~属性$,
`大域~event属性$,
`文書~要素~event属性$,
`呈示~属性$,
`非推奨にされた~XLink属性$,
`href$a
◎幾何 `x$p, `y$p, `width$p, `height$p
◎界面 `SVGUseElement$I
◎表終

<p>
`use$e 要素は、
別の要素を参照する
— その複製が、
文書~内で `use$e に代わって描画される。
`参照先の要素$は、
`容器~要素$でもヨイ
— その事例では、
その要素を根とする~SVG文書~下位treeの完全な複製が利用される。
◎
The ‘use’ element references another element, a copy of which is rendered in place of the ‘use’ in the document. The referenced element may be a container element, in which case a copy of the complete SVG document subtree rooted at that element is used.
</p>

<p>
~cloneされた内容は、
~styleを `use$e 要素から継承し，利用者~eventの~targetになり得る。
しかしながら，これらの~cloneされた`要素~instance$は、
参照先の~sourceに~linkされ続け，元の要素における~DOM変異を反映する。
加えて、参照先の要素の視野~内で適用されるすべての~style規則も，~cloneされた`~shadow~tree$の視野~内で適用される。
◎
The cloned content inherits styles from the ‘use’ element and can be the target of user events. However, these cloned element instances remain linked to the referenced source and reflect DOM mutations in the original. In addition, all style rules that apply in the scope of the referenced element also apply in the scope of the cloned shadow tree.
</p>

<p>
幾何-~prop［
`x$p, `y$p, `width$p, `height$p
］は、参照先の要素の位置決めを指定する。
［
`width$p, `height$p
］属性は、
`参照先の要素$が表示域を定義する場合
（すなわち，それは［
`svg$e ／ `symbol$e
］である場合）
に限り，効果を発揮する。
その場合、
`use$e 要素における `auto^v 以外の値は，
参照先の要素~上の~~同名の幾何-~propの値を上書きする。
◎
The x, y, width and height geometric properties specify the positioning of the referenced element. The width and height attributes only have an effect if the referenced element defines a viewport (i.e., if it is a ‘svg’ or ‘symbol’); if so, a value other than auto for the ‘use’ element overrides the value of the corresponding geometric property on that element.
</p>

<p>
［
`width$p ／ `height$p
］に対する負な値は、
`無効な値$であり，`無視する$モノトスル。
［
`width$p, `height$p
］~propのどちらかが 0 にされていて, かつ［
その~propは`参照先の要素$に効果を発揮する
］ならば、
その要素の描画は不能化されることになる。
◎
A negative value for width or height must be treated as an illegal value. If width or height is zero, and the properties have an effect on the referenced element, then rendering of that element will be disabled.
</p>

<p class="note">注記：
［
`x$p ／ `y$p
］~propは、
要素~用の利用元~座標系に影響する。
実装の詳細~については、
`§ ~layout＠#UseLayout$を見よ。
◎
The x and y properties affect the user coordinate system for the element. See the Layout section for implementation details.
</p>

<dl class="attrdef-list">
	<dt>
◎属名 `href@a
◎属値 `~URLt$
◎属初 （ナシ）
◎属ア 可
◎表終
◎
Name 	Value 	Initial value 	Animatable
href 	URL [URL] 	(none) 	yes
</dt>
	<dd>
~SVG文書の中にあり，描画~用に~cloneされることになる［
要素／素片
］への`~URL参照$sec。
◎
An URL reference to the element/fragment within an SVG document to be cloned for rendering.
</dd>
	<dd>
`use$e 要素は、
素片を省いた値を `href$a に指定することにより，
~SVG文書~全体も参照できる。
そのような参照は、
参照先の文書の根~要素を指しているものとされる。
◎
The ‘use’ element can reference an entire SVG document by specifying an ‘href’ value without a fragment. Such references are taken to be referring to the root element of the referenced document.
</dd>
	<dd>
`~URL参照~属性$と`非推奨にされた~XLink属性$用に定義される共通な取扱いを見よ。
◎
Refer to the common handling defined for URL reference attributes and deprecated XLink attributes.
</dd>
</dl>

<p class="note">注記：
~SVG-2にて新たに~~導入された。
素片なしの `href$a は、
根~要素が~IDを有することを確保することなく，
~SVG文書~全体を参照することを許容する。
◎
New in SVG 2. An ‘href’ without a fragment allows an entire SVG document to be referenced without having to ensure that it has an ID on its root element.
</p>

<p>
~UAは、外部~資源~文書を，~securityの理由から制約してもヨイ。
特に，この仕様は、
`use$e による非同一-生成元~資源への要請を許容しない。
この仕様／別の仕様の将来~versionは、
非同一-生成元に属する資源の再利用を~secureに可能化する手法を供するかもしれない。
◎
User agents may restrict external resource documents for security reasons. In particular, this specification does not allow cross-origin resource requests in ‘use’. A future version of this or another specification may provide a method of securely enabling cross-origin re-use of assets.
</p>

<p>
`href$a 属性（または `href$a 属性が無い場合は `~xlink_href$a 属性）が設定されたときは、
~UAは`~URLを処理する＠~SVGlinking#processingURL$モノトスル。
~URL処理による結果の~target要素が `use$e の`参照先の要素$になる。
◎
When the ‘href’ attribute is set (or, in the absence of an ‘href’ attribute, an ‘xlink:href’ attribute), the user agent must process the URL. The target element that results from URL processing is the referenced element of the ‘use’.
</p>

<p>
~URLを解決した結果の`参照先の要素$が，~SVG要素でない場合、
参照は`無効な値$になり， `use$e 要素は~errorになるとする。
◎
If the referenced element that results from resolving the URL is not an SVG element, then the reference is invalid and the ‘use’ element is in error.
</p>

<p>
参照先の要素は［
`use$e 要素の`~shadowも含む先祖$
］である場合、
`無効な循環-参照$になり，当の `use$e 要素は~errorになるとする。
◎
If the referenced element is a (shadow-including) ancestor of the ‘use’ element, then this is an invalid circular reference and the ‘use’ element is in error.
</p>

<p>
他の場合，~UAは、
`use$e 要素の内容として描画するためとして，
`再利用される~graphic$が成す`~shadow~tree$を［
`§ ~use要素の~shadow~tree＠#UseShadowTree$（次~節）
］に述べるように生成するモノトスル。
◎
Otherwise, the user agent must generate a shadow tree of re-used graphics to render as the contents of the ‘use’ element, as described in the next section, The use-element shadow tree.
</p>

<p>
`use$e は、
その~URL参照が［
`未解決$ ／ `無効な値$
］である間は描画されず、
限界~box計算の目的においては，空な容器~要素に等価になる。
◎
A ‘use’ that has an unresolved or invalid URL reference is not rendered. For the purpose of bounding box calculations, it is equivalent to an empty container element.
</p>

		<section id="UseShadowTree">
<h3 title="The use-element shadow tree">5.5.1. ~use要素の~shadow~tree</h3>

<p>
`use$e 要素から生成される`再利用される~graphic$は、
`~shadow~tree$の用語で定義される。
したがって，対話性と~style継承の用語では、
それらは，~SVGにおける他の型の`再利用される~graphic$
— `pattern$e や `marker$e の内容など —
とは かなり異なる。
◎
The re-used graphics generated by a ‘use’ element are defined in terms of a shadow tree. In terms of interactivity and style inheritance, they are therefore quite different from other types of re-used graphics in SVG, such as ‘pattern’ and ‘marker’ content.
</p>

<p>
~shadow~tree内の要素は、［
`use$e 要素が容器で，その子孫は それらであった
］かのように描画される。
しかしながら，~SVG~DOMが包含するのは `use$e 要素とその属性に限られ、
要素~instanceを `use$e 要素の子孫として含むことはない。
◎
Elements in the shadow tree are rendered as if the ‘use’ element was a container and they were its children. However, the SVG Document Object Model (DOM) only contains the ‘use’ element and its attributes. The SVG DOM does not include the element instances as children of the ‘use’ element.
</p>


<p>
~scriptingと文書~obj~modelを~supportする~UAは、
この節に述べるように, かつ
`DOM$r 仕様に適合するように，`~use要素の~shadow~tree$を実装するモノトスル。
対照的に，動的かつ対話的な処理~modeを`~supportしない^em ~UAは、
~shadow~DOMのすべての詳細を実装する必要はないであろう。
しかしながら，すべての~UAは、［
再利用される~graphic用の，次に挙げるもの
］は［
~shadow~DOMが実装されていたかのように，同じ仕方で描画される
］ことを確保するモノトスル
⇒＃
`~layout＠#UseLayout$,
`~style継承＠#UseStyleInheritance$,
適用-可能な`宣言的~animation＠#UseAnimations$
◎
User agents that support scripting and the document object model must implement the use-element shadow tree as described in this section and in conformance with the dom specification [dom], or its future replacement. In contrast, user agents that do not support the dynamic interactive processing mode may not need to implement all the details of the shadow DOM. However, all user agents must ensure that the layout and style inheritance for the re-used graphics and declarative animations if applicable, are rendered in the same way as if the shadow DOM was implemented.
</p>

<p>
次に挙げる定義は、
`use$e 要素, その~shadow~treeを論じるときに適用される：
◎
The following definitions apply when discussing ‘use’ elements and their shadow trees:
</p>

<dl>
	<dt>
`参照先の要素@
（ `referenced element^en ）
</dt>
	<dd>
`use$e 要素~上の `href$a（または `~xlink_href$a ）属性が供する~URLは，特定の要素 `id$a へ~linkする~target素片を［
含むならば その要素 ／
含まないならば ~URLが参照する文書の根~要素
］。
◎
The element specified by the ‘href’ (or ‘xlink:href’) attribute on the ‘use’ element, or the root element of a document referenced by that attribute if the URL provided does not include a target fragment that links to a specific element ‘id’.
</dd>

	<dt>
`参照先の文書~下位tree@
（ `referenced document subtree^en ）
</dt>
	<dt>
参照先の~graphic
（ `referenced graphics^en ）
</dt>
	<dd>
参照先の要素, および，そのすべての子孫~node。
◎
The referenced element, and all of its descendent nodes.
</dd>

	<dt>
`~shadow根@
（ `shadow root^en ）
</dt>
	<dd>
`ShadowRoot$I ~obj。
それは、
ある~host `Element$I に結付けられた `DocumentFragment$I 型の~nodeであって，その~hostを描画するために利用されることになる内容を包含する。
~shadow根は、
`DOM$r 仕様に適合するように実装されるベキである。
◎
A ShadowRoot object, a type of DocumentFragment node which is associated with a host Element, and which contains the content that will be used to render that host. A shadow root should be implemented in conformance with the dom specification [dom], or its future replacement.
</dd>

	<dt>
`~shadow~host@
（ `shadow host^en ）
</dt>
	<dt>
~host
（ `host^en ）
</dt>
	<dd>
［
ある`~shadow根$を結付けている ／
ある`~shadow~tree$を~hostしている
］要素
— その用法は `DOM$r による
`~host＠~DOM4#concept-documentfragment-host$の定義と整合する。
◎
An element that has an associated shadow root; usage is consistent the definition of host in the DOM standard.
</dd>

	<dt>
`~shadow~tree@
（ `shadow tree^en ）
</dt>
	<dd>
ある`~shadow根$を根とする~node~tree
— その用法は `DOM$r による`~shadow~tree＠~DOM4#shadow-trees$の定義と整合する。
◎
A node tree whose root is a shadow root; usage is consistent the definition of shadow tree in the DOM standard.
</dd>

	<dt>
`~use要素の~shadow~tree@
（ `use-element shadow tree^en ）
</dt>
	<dd>
`~shadow~tree$のうち，その~hostは `use$e 要素であるもの。
それは、
要素の`参照先の~graphic$を~cloneして生成される`要素~instance$たちを包含する。
◎
A shadow tree whose host is a ‘use’ element, which contains element instances generated by cloning the referenced graphics.
</dd>

	<dt>
`要素~instance@
（ `element instance^en ）
</dt>
	<dt>
~instance
◎
instance
</dt>
	<dd>
`~use要素の~shadow~tree$内にある要素であって，`参照先の文書~下位tree$内の対応する要素を~cloneして生成されたもの。
◎
An element in the use-element shadow tree, which is generated by cloning a corresponding element in the referenced document subtree.
</dd>

	<dt>
`~instance根@
（ `instance root^en ）
</dt>
	<dd>
`参照先の要素$用の`要素~instance$
— 常に `use$e 要素の`~shadow根$の子になる。
◎
The element instance for the referenced element; it is always a direct child of the ‘use’ element's shadow root.
</dd>

	<dt>
`対応している要素@
（ `corresponding element^en ）
</dt>
	<dd>
所与の`要素~instance$の~clone元である，`参照先の文書~下位tree$内の要素。
◎
For each element instance, the element in the referenced document subtree from which it is cloned.
</dd>

	<dt>
`対応している~use要素@
（ `corresponding use element^en ）
</dt>
	<dd>
<p>
当の［
`要素~instance$／`~use要素の~shadow~tree$
］を文書~内に描画させる，（文書~内の） `use$e 要素を指す：
</p>
		<ul>
			<li>
所与の`要素~instance$ %~instance に`対応している~use要素$は、
%~instance が属する~shadow~treeに`対応している~use要素$を指す。
</li>
			<li>
所与の`~use要素の~shadow~tree$ %~shadow~tree に`対応している~use要素$は、
%~shadow~tree を~hostしている `use$e 要素 %use が［
`要素~instance$であるならば %use に`対応している~use要素$／
他の場合は %use
］を指す。
</li>
		</ul>
<p>
（すなわち、
~shadow~treeの一部を成さない `use^e 要素に達するまで，
再帰的に~shadow~treeたちを遡っていく。）
</p>

◎
For each element instance, the ‘use’ element which causes it to be rendered in the document. This is the instance's shadow root's host ‘use’ element if that element is not itself an element instance within a ‘use’ element shadow tree, or is that element's corresponding use element otherwise, recursively exiting shadow trees as many times as necessary to reach a ‘use’ element that was not itself generated as part of the shadow tree of another ‘use’ element.
</dd>
</dl>

<p>
~UAは、
`use$e 要素 %use 【からの~URL参照】を解決して，`参照先の要素$を成功裡に識別できたときは、
%use を~hostとする`~use要素の~shadow~tree$を作成するモノトスル。
この~shadow~treeは、［
次に挙げる~~事由により， %use が描画されない場合
］でも作成されるモノトスル
【！他の~~事由により描画されない場合は？】
⇒＃
`決して描画されない要素$の子孫である ／
条件付き処理 ／
自身または先祖の `display$p ~propは `none^v に設定されている
◎
When the user agent successfully resolves a ‘use’ element to identify a referenced element, the user agent must create a use-element shadow tree whose host is the ‘use’ element itself. The shadow tree must be created even if the ‘use’ element is not rendered because it is a descendent of a never-rendered element, because of conditional processing, or because of the display property being set to none on it or an ancestor element.
</p>

<p>
~shadow~tree内の各~nodeは、
`参照先の~graphic$からの対応する~nodeの`要素~instance$を与える。
どの~shadow~nodeも、
`~instance根$（`参照先の要素$の~instanceを与える，`~shadow根$~nodeの子）か，
その子孫になる。
◎
Each node in the shadow tree is an instance of a corresponding node from the referenced document subtree. The shadow nodes all descend from the instance root, which is the instance of the referenced element, and which itself is a direct child of the shadow root node.
</p>

<p>
~shadow~treeは~open（~scriptから検分-可能）であるが、
読専とする。
~shadow~tree内の［
要素, 属性, 他の~node
］を直に改変しようとする どの試みに対しても，
`NoModificationAllowedError$E 例外を投出するモノトスル。
◎
The shadow tree is open (inspectable by script), but read-only. Any attempt to directly modify the elements, attributes, and other nodes in the shadow tree must throw a NoModificationAllowedError.
</p>

<p>
`~use要素の~shadow~tree$の中では、
`script$e 要素は不活になる（実行されない）。
◎
Within a use-element shadow tree, ‘script’ elements are inert (do not execute).
</p>

<p class="note">注記：
以前の~versionの~SVGは、
~shadow~treeの内容を，~SVG~graphics要素に制約していた。
この仕様は、
妥当な~SVG文書~下位treeであれば，~cloneされるのを許容する。
しかしながら，非~graphicな内容は、
通例的には，~cloneされても可視な効果は生じない。
◎
Previous versions of SVG restricted the contents of the shadow tree to SVG graphics elements. This specification allows any valid SVG document subtree to be cloned. Cloning non-graphical content, however, will not usually have any visible effect.
</p>

<p>
`参照先の要素$は外部~file内にある場合、
その［
属性／~style~prop
］内のすべての`~URL参照$は、
`要素~instance$に値を複製する前に
— `§ 絶対~URLの生成-法＠~SVGlinking#processingURL-absolute$に従って —
絶対~化されるモノトスル。
~shadow~tree自身が利用する文書~基底~URLは、
~shadow~treeを含む文書と同じになる。
◎
If the referenced element is in an external file, then all URL references in attributes and style properties must be made absolute as described in Generating the absolute URL, before copying the value to the element instances. The shadow tree itself uses the same document base URL as the document that includes it.
</p>

<p>
~UAは、［
`参照先の~graphic$に対するすべての変異が~shadow~tree内に反映される
］ことを確保するモノトスル。
これには［
要素, 属性, ~text, 他の~node
］に対する変更も含まれる。
加えて，参照先の~graphic用に効果を発揮している~stylesheetに対する変更は
— `~style継承＠#UseStyleInheritance$にて更に述べるように —
~shadow~treeの視野~内にある~stylesheetも変更するように反映されるモノトスル。
◎
The user agent must ensure that all mutations to the referenced document subtree are reflected in the shadow tree. This includes changes to elements, attributes, and text and other nodes. In addition, changes to the stylesheets in effect for the referenced graphics must be reflected in changes to the stylesheets in the shadow tree's scope, as described futher in the section on style inheritance.
</p>

<p>
［
`use$e 要素, `参照先の要素$
］どちらかが［
`use$e 要素の~URL参照を`未解決$に~~戻す
］ような仕方で改められた場合、
その `use^e 要素~用の~shadow~tree全体が破棄される。
◎
If either the ‘use’ element or the referenced element is altered in a way that causes the ‘use’ element's URL reference to become unresolved again, then the entire shadow tree for that use element is discarded.
</p>

<p>
`use$e 要素が［
別の `use$e, または 別の `use$e を包含する内容
］を参照する場合、
上で述べた~shadow~DOMは再帰的に~cloneされる。
しかしながら，そのような一連の参照の~~連鎖により依存関係が循環する場合、
`無効な循環-参照$になる。
~shadow~treeにおいて そのような循環-参照を作成させた［
`use$e 要素 ／ 要素~instance
］は、~errorになり，描画されないモノトスル。
◎
When a ‘use’ references another element which is another ‘use’ or whose content contains a ‘use’ element, then the shadow DOM cloning approach described above is recursive. However, a set of references that directly or indirectly reference a element to create a circular dependency is an invalid circular reference. The ‘use’ element or element instance whose shadow tree would create the circular reference is in error and must not be rendered by the user agent.
</p>

		</section>
		<section id="UseLayout">
<h3 title="Layout of re-used graphics">5.5.2. 再利用される~graphicの~layout</h3>

<p>
`use$e 要素~上の［
`x$p, `y$p,
`width$p, `height$p
］~propの値は、
再利用される~graphicを位置するために利用され，
`参照先の要素$が入子な表示域を定義する場合には，表示域の~sizeを設定するために利用される。
`use$e 要素~上のこれらの~propによる効果は［
`~graphics要素$に対する それらの効果 ／
~CSS~box~layoutにおける それらの効果
］から大きく異なる~~点がある。
◎
The value of the x, y, width and height properties on a ‘use’ element are used to position the re-used graphics and to set the viewport size if the referenced element defines a nested viewport. The effect of these properties on a ‘use’ element is notably different from their effect on a graphics element, or from their effect in CSS box layout.
</p>

<p>
［
`x$p, `y$p
］~propは、
追加的な座標系変換を定義する
（ <code class="func">translate(%x, %y)</code>
（ %x, %y はこれらの~propの算出d値）が，その座標系変換を与える）
— それは、他の~propで指定された どの座標系変換よりも後に
`use$e 要素に適用される（すなわち，変形n~listの右側に付加される）。
◎
The x and y properties define an additional transformation (translate(x,y), where x and y represent the computed value of the corresponding property) to be applied to the ‘use’ element, after any transformations specified with other properties (i.e., appended to the right-side of the transformation list).
</p>

<div class="note">

<p>注記：
歴史的な理由から、
補足的な座標系変換は `use$e 要素~自身に適用される
— ~shadow~tree内の再利用される内容のみに適用されるのではなく。
これは、 `use$e 要素に適用された［
~mask／切抜き~path／~filter
］があれば，それ用に利用される座標系に影響し，
`userSpaceOnUse^v 単位で計算される。
◎
For historical reasons, the supplemental transformation is applied to the ‘use’ element itself, rather than solely to the re-used content in the shadow tree. This affects the coordinate system used for any masks, clipping paths, or filters applied to the ‘use’ element and calculated in userSpaceOnUse units.
</p>

<p>
作者は、［［
`x$p, `y$p
］を利用して~graphicを位置しつつ，
それらで変形されない座標~空間に `userSpaceOnUse^v に基づく~graphicな効果を適用する
］ときは，［
`use$e 要素を `g$e の内側に入子にして，~graphicな効果を `g$e 要素に適用する
］ことでできる。
◎
To apply userSpaceOnUse graphical effects in an un-transformed coordinate space, while also using the x and y to position the graphics, authors can nest the ‘use’ element inside a ‘g’, and apply the graphical effects to the ‘g’ element.
</p>

</div>

<p>
`use$e 要素 %use の`参照先の要素$ %要素 は［
`svg$e または `symbol$e
］要素である場合、
%use 上の［
`width$p ／ `height$p
］~propは，その算出d値が `auto^v でない場合には［
%要素 用の`~instance根$ %~instance 上の~~同名の~prop用の使用~値を決定する
］ときに %要素 上の~~同名の~prop用の値を上書きする。
算出d値が `auto^v になる場合、
%~instance 上の~propは，通常通り算出される。
◎
The width and height properties on the ‘use’ element override the values for the corresponding properties on a referenced ‘svg’ or ‘symbol’ element when determining the used value for that property on the instance root element. However, if the computed value for the property on the ‘use’ element is auto, then the property is computed as normal for the element instance.
</p>

<p>
したがってこれらの~propを利用すれば、［
自前の座標系を定義する ある~graphic
］を，再利用される各回ごとに拡縮できる。
`auto^v は初期~値なので、
`use$e 要素~上に寸法が明示的に設定されていない場合，［
`svg$e ／ `symbol$e
］上に設定された値が既定として利用されることになる。
◎
These properties can therefore be used to scale a graphic that defines its own coordinate system, each time it is re-used. Because auto is the initial value, if dimensions are not explicitly set on the ‘use’ element, the values set on the ‘svg’ or ‘symbol’ will be used as defaults.
</p>

<p>
`use$e 要素~上の［
`width$p, `height$p
］~propの効果は、
`参照先の要素$が`新たな表示域を確立しない＠~SVGcoords#EstablishingANewSVGViewport$場合には無い。
特に， `use$e 要素~自身は新たな表示域を確立しないので、
再利用される~graphic内の百分率の解釈には影響しない。
◎
The width and height properties on the ‘use’ element have no effect if the referenced element does not establish a new viewport. In particular, the ‘use’ element does not itself establish a new viewport, and therefore does not affect the interpretation of percentages in the re-used graphics.
</p>

<p>
上述以外の~~点では、
`~use要素の~shadow~tree$の中の要素の描画と~layoutは，［
`use$e 要素が その~shadow内容の容器であった
］かのように生じる。
特に，~shadow~treeの中の要素が新たな表示域を確立しない場合には、
それらは［
`use$e 要素~用に定義される座標系（累積的な変形nも含む）
］内に描かれるモノトスル。
これは［
百分率~長さの解釈／
`userSpaceOnUse^v 単位を伴う~graphicな効果
］に影響する。
◎
In all other ways, rendering and layout of elements within the use-element shadow tree occurs as if the ‘use’ element was a container for its shadow content. In particular, unless elements within the shadow tree establish a new viewport, they must be drawn in the coordinate system in which the ‘use’ element is defined (including any cumulative transformations). This affects the interpretation of percentage lengths, and also graphical effects with userSpaceOnUse units.
</p>

		</section>
		<section id="UseStyleInheritance">
<h3 title="Style Scoping and Inheritance">5.5.3. ~styleの視野-法と継承</h3>

<p>
`~use要素の~shadow~tree$は、
他の~shadow~treeの様に，
`css-scoping-1$r ~moduleに定義される~styleの~encapsulationを呈する。
このことは［
~shadow~tree内の要素は，その`~host$である `use$e 要素から~styleを継承するが、
外縁~文書~内に定義された そのような~style規則は，~shadow~tree内の要素には合致しない
］ことを意味する。
代わりに、
~shadow~treeは自前の~stylesheet~listを保守し，
その~CSS規則が~shadow~tree内の要素に対し照合される。
◎
The use-element shadow tree, like other shadow trees, exhibits style encapsulation, as defined in the CSS Scoping module [css-scoping-1]. This means that elements in the shadow tree inherit styles from its host ‘use’ element, but that style rules defined in the outer document do not match the elements in the shadow tree. Instead, the shadow tree maintains its own list of stylesheets, whose CSS rules are matched against elements in the shadow tree.
</p>


<p class="note">注記：
［
呈示~属性, `style$a 属性
］であっても、
他の属性と同じ方式で，
`参照先の~graphic$内の要素から`要素~instance$の中へ~cloneされる。
◎
Presentation attributes and the ‘style’ attribute are cloned from the elements in the referenced graphics into the element instances in the same manner as other attributes.
</p>

<p>
`use$e 要素と その`参照先の要素$が同じ文書~内にある場合、
その文書の~stylesheetは，
`~use要素の~shadow~tree$を成す文書片にも適用されることになる。
~main文書~内の~stylesheetに対するどの変更も、
~shadow~treeに影響する
— ［
文書, ~shadow根~文書片
］の `styleSheets$n 属性を通して~accessされる `StyleSheetList$I ~objは、
一致させるモノトスル。
`参照先の~graphic$の一部として， `style$e 要素も重製された場合、
`要素~instance$上の `styleSheet^m 【 `sheet$n ？】~propは，
`対応している要素$用のそれと同じ~objを指す。
◎
When the referenced element is from the same document as the ‘use’ element, the same document stylesheets will apply in both the original document and the shadow tree document fragment. Any changes to the stylesheets in the main document also affect the shadow tree; the StyleSheetList object accessed through the document and shadow root document fragment's styleSheets properties must be identical. If a ‘style’ element is duplicated as part of the referenced document subtree, then the styleSheet property on the element instance points to the same object as for the corresponding element.
</p>

<p>
`参照先の要素$は，ある外部~文書 %文書 に包含されている場合、
%文書 を処理するときに生成された~stylesheet~objは，~shadow~treeに適用され，読専になる。
~stylesheet内のすべての`~URL参照$は
— 素片のみの参照も含めて —
%文書 の~URLに相対的に絶対~化されるモノトスル。
~UAは、 %文書 を参照するどの~shadow~treeにも，同じ~stylesheet~objを再利用してもヨイ。
◎
When the referenced element is from an external document, the stylesheet objects generated when processing that document apply to the shadow tree, and are read-only. All URL references in the stylesheet, including fragment-only references, must be made absolute, relative to the URL of the document that contains the referenced element. User agents may re-use the same stylesheet objects for any shadow trees that reference that same external document.
</p>

<p>
~style規則のうち，その視野が~shadow~treeにされたものは、
通常は，~main文書~内のどの要素にも影響し得ない。
同様に，~main文書~内の~style規則が~shadow~tree内の要素に影響し得るのは、
継承される値を変更することに限られる。
しかしながら，
`css-scoping-1$r は、［
~shadow~treeの中から`~host$ 要素を~styleする／
~hostの文脈における変化に呼応して~shadow~treeの中の~styleを調整する
］ための`特別な選択子＠~CSSSCOPING#host-selector$を定義する。
◎
Style rules that are scoped to the shadow tree cannot normally affect any elements in the main document. Similarly, style rules in the main document can only affect the shadow tree elements by changing inherited values. However, CSS Scoping defines special selectors for styling the host element from within the shadow tree, or for adjusting styles within the shadow tree in response to changes in the host's context [css-scoping-1].
</p>

<p>
~shadow~treeの視野の中の~CSS媒体~queryは、［
~shadow~treeに`対応している~use要素$を包含する文書
］と同じ装置における特能と寸法を利用して評価される。
◎
CSS media queries within a shadow tree's scope are evaluated using the same device features and dimensions as the corresponding "light" document (that is, the document that contains the corresponding use element for the shadow tree, after recursively exiting all nested shadow trees).
</p>

<div class="note">

<p>注記：
ほとんどの事例では、
~shadow~tree内の`要素~instance$は，
元の文書~内の`対応している要素$と同じ~style規則に合致することになる。
しかしながら、~CSS規則のうち，その選択子は［
~shadow~treeの一部として~cloneされない，先祖や同胞
］に基づいて要素に合致する`複体~選択子$であるものは，もはや`要素~instance$には合致しなくなる。
同様に［
`nth-of-type()$ps ／ `nth-child()$ps
］などの子付番~疑似類は、
適用される要素が より~~少なくなり得る。
これは、以前の~versionの~SVGにて定義された，~styleが~cloneされる方法からの変更を表現する。
◎
In most cases, the element instance in the shadow tree will match the same style rules as its corresponding element in the original document. However, if a CSS rule uses a complex selector to match an element based on its ancestors or siblings, and those ancestors or siblings are not cloned as part of the shadow tree, then that rule would no longer match the element instance. Similarly, child-indexed pseudo-classes such as nth-of-type and nth-child may apply to one element but not the other. This represents a change from how style cloning was defined in previous versions of SVG.
</p>

<p>
次の例に［
以前と整合なもの, 変更されたもの
］両~style照合~規則をデモる。
左にある真円（ `circle^e ）は、
右にある真円を描くために再利用されている。
元の真円~の~styleは様々な仕方で設定されている：
◎
The following example demonstrates both the consistent and changed style-matching rules. The circle on the left is re-used to draw the circle on the right. The original circle has styles set in various ways:
</p>

<ul>
	<li>
`stroke-width$p （ `20^v ）が設定されている
— 真円~自身の呈示~属性により。
◎
stroke-width (20) is set in a presentation attribute on the circle itself.
</li>
	<li>
`stroke-opacity$p （ `0.7^v ）が設定されている
— 真円の~tag名に合致している`単体~選択子$を伴う，~CSS規則を介して。
◎
stroke-opacity (0.7) is set via a CSS rule with a simple selector matching the circle tag name.
</li>
	<li>
`stroke$p 色（ `green^v ）が設定されている
— ~class `special^css を伴う要素の子孫として 真円に合致する~CSS`複体~選択子$を利用して。
◎
stroke color (green) is set using a complex CSS selector, matching the circle as a descendent of an element with class special.
</li>
	<li>
`fill$p 色は真円には直に設定されていない
— 真円を包含している `g$e 要素~上に設定された~style（ `blue^v ）から継承される。
◎
fill color is not set directly on the circle, so is inherited from the style set on the containing ‘g’ element (blue).
</li>
</ul>

<p>
~SVG-11における~style~clone法の~modelにおいては、
~styleの`指定d値$は、
元の要素から`要素~instance$へ~cloneされる。
再利用される真円の~styleは、
元の~styleと同じになる
— `fill$p 値は `g$e （ `blue^v ）からでなく， `use$e （ `orange^v ）から継承されることを除いて。
◎
In the SVG 1.1 style-cloning model, the specified style values would be cloned from the original element to the element instance. The re-used circle would have the same styles as the original, except that the fill value would be inherited from the ‘use’ (orange) instead of from the ‘g’ (blue).
</p>

<p>
~SVG-2に要求される~shadow~DOM~modelにおいては、
再利用される真円~用の~styleは，次に従って計算される
◎
In the shadow DOM model required by SVG 2, the styles for the re-used circle are calculated as follows:
</p>

<ul>
	<li>
`stroke-width$p （ `20^v ）呈示~属性は、
`要素~instance$
— 以下，単に %~instance と記す —
へ~cloneされる。
◎
the stroke-width (20) presentation attribute is cloned to the element instance.
</li>
	<li>
`stroke-opacity$p （ `0.7^v ）を設定している~CSS規則は、
~shadow~treeの中へ~cloneされる~CSS~stylesheetの一部を成す。
それは、 %~instance の~tag名（ `circle^e ）に合致するので適用される。
◎
the CSS rule setting stroke-opacity (0.7) is part of the CSS stylesheet cloned into the shadow tree; it matches the circle tag name of the element instance, so is applied.
</li>
	<li>
`複体~選択子$を伴う~CSS規則も，~cloneされた~stylesheetの一部を成すが、
 %~instance は~class `special^css が付与された要素の子孫ではないので，
 %~instance には合致しない
— %~instance 上の `stroke$p 色（ `purple^v ）は、
代わりに，~host `use$e 要素から継承される。
◎
the CSS rule with the complex selector is also part of the cloned stylesheet, but it does not match the element instance of the circle, which is not a descendent of an element with class special; instead, stroke color on the circle is inherited from the host ‘use’ element (purple).
</li>
	<li>
%~instance 上の `fill$p 色は、
ここでも直に設定されていないので，それも~host `use$e 要素から継承される。
◎
fill color is still not set directly, so is once again inherited from the host ‘use’ element.
</li>
</ul>

<p>
したがって、再利用される真円は、［
~fill色, ~stroke色
］両者において，元のものから相違する
（前者は異なる要素から継承し，後者は もはや`複体~選択子$に合致しないので）。
◎
The re-used circle therefore differs from the original in both fill color (because it inherits from a different element) and stroke color (because the complex selector no longer matches).
</p>


<div class="example">

<pre class="lang-xml">
&lt;svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     width="200" height="100" viewBox="0 0 200 100"&gt;
  &lt;title&gt;Style inheritance and the use element&lt;/title&gt;
  &lt;desc&gt;<span class="comment">
2 個の真円
— 一方の真円は他方の真円の~cloneであり，~styleし直される。
この~fileは、
~SVG-2における~shadow~DOMの~style照合~規則による効果が，~SVG-11における~style~clone法の規則よる効果から異なる事例をデモる。
左に示される元の真円は［
~fillは `blue^v, ~strokeは `green^v
］になるベキである。
右に示される再利用された真円は、
適合~SVG-11~UAにおいては［
~fillは `orange^v, ~strokeは `green^v
］になり，適合~SVG-2~UAにおいては［
~fillは `orange^v,
~strokeは `purple^v
］になるベキである。
両~事例とも、
~strokeは部分的に透明になり，真円の直径は 100 利用元~単位になるベキである。
◎
Two circles, one of which is a re-styled clone of the other. This file demonstrates one of the cases where the shadow-DOM style matching rules in SVG 2 have a different effect than the SVG 1.1 style cloning rules. The original circle on the left should have blue fill and green stroke. In a conforming SVG 1.1 user agent, the re-used circle on the right should have orange fill and green stroke. In a conforming SVG 2 user agent, the re-used circle should have orange fill and purple stroke. In all cases, the stroke should be partially transparent and 20 units wide, relative to a total circle diameter of 100 units.
</span>&lt;/desc&gt;
  &lt;style type="text/css"&gt;
    circle          { stroke-opacity: 0.7; }
    .special circle { stroke: green; }
    use             { stroke: purple;
                      fill: orange; }
  &lt;/style&gt;
  &lt;g class="special" style="fill: blue"&gt;
     &lt;circle id="c" cy="50" cx="50" r="40" 
             stroke-width="20" /&gt;
  &lt;/g&gt;
  &lt;use xlink:href="#c" x="100" /&gt;
&lt;/svg&gt;
</pre>

<figure>
<p class="alt" hidden id="_dgm-Use-changed-styles">
`circle^e を複製している `use^e 要素
— 様々な~style照合~規則がデモられる。
◎
Example Use-changed-styles — A 'use' element copying a 'circle', with various style matching rules demonstrated
</p>
<figcaption>
例
`Use-changed-styles^xl
◎
Example Use-changed-styles
</figcaption></figure>

`struct/Use-changed-styles.svg^viewAs

</div>

<p>
以前の~versionの~SVGでは、
動的~疑似類（ `hover^ps など）が要素~instanceにどう適用されるベキかについて明瞭でなかった。
~shadow~tree~modelでは、
そのような どの疑似類も，利用者がどの要素とヤリトリしているかに依存して［
`要素~instance$，それに`対応している要素$
］に独立に合致することが要求される。
◎
Previous versions of SVG were not clear about how dynamic pseudo-classes (such as :hover) should apply to element instances. The shadow tree model requires that all such pseudo-classes are matched independently to the element instance or to its corresponding element, depending on which element the user is interacting with.
</p>
</div>

<div class="example">

<p>
`use$e 要素~上の `visibility^p に `hidden^v を指定しても，参照先の内容を描画しないことは保証されない。
［
`display$p ／ `opacity$p
］~propと違って，
`visibility$p ~propは容器~要素に
— したがって `use$e 要素にも —
直に適用されることはない。
`visibility$p は継承されるので、
`use$e 要素を隠せば，その子~内容を隠すことになることが多いが、
そうなるとは限らない。
`use$e 要素の `visibility^p に `hidden^v が指定されていても、
その~shadow~tree内の~graphics要素の `visibility^p に `visible^v が指定されれば，
その要素は可視になる。
◎
Specifying 'visibility:hidden' on a ‘use’ element does not guarantee that the referenced content will not be rendered. Unlike the display or the opacity properties, the visibility property does not appy directly to container elements, and therefore does not apply directly to the ‘use’ element. Because visibility is normally inherited, hiding the use element will often hide the child content, but not necessarily. If any graphics elements in the shadow tree have 'visibility:visible' specified, then that element will be visible even if the ‘use’ element specifies 'visibility:hidden'.
</p>

<p>
下の例では、
次の~style規則を鍵にしている：
◎
In the following example, key style rules are as follows:
</p>

<pre class="lang-css">
.dark {
  visibility: hidden;
}
.eyes {
  visibility: visible;
}
svg:hover .dark, svg:focus .dark {
  visibility: visible;
}
</pre>

<p>
`use$e 要素を包含している~group上には `dark^css ~class（ “~~暗闇” ）が設定されているので、
再利用される~graphicを成すすべては `hidden^v に設定された `visibility^p を継承する
— ~class `eyes^css （ “~~目玉” ）が付与され， `visible^v に設定し直された下位treeは除いて。
~graphic上に［
~hover／~focus
］したときは、
~graphicを隠している効果は除去される。
◎
The "dark" class is set on the group containing the ‘use’ elements, so all parts of the re-used graphics inherit the hidden visibility setting, except for the subtrees with class "eyes", where it is reset to visible. Upon hovering or focusing the graphic, the hiding effect is removed.
</p>

<figure>
<p class="alt" hidden id="_dgm-Use-visibility-inheritance">
ある生き物を表す `symbol^e の［
`use^e による複数個の複製
］が~~黒い背景~上に示される
— `use^e 要素の `visibility^p は `hidden^v にされているが、
生き物の~~目玉だけ `visibility^p は `visible^v にされている。
◎
Multiple use-copies of a creature-symbol on a black background; the use elements have visibility: hidden, but the creatures' eyes have visibility: visible.
</p>
<figcaption>
例 `Use-visibility-hidden^xl ：
既定の~style
◎
Example Use-visibility-hidden, default styles
</figcaption></figure>

<figure>
<p class="alt" hidden id="_dgm-Use-visibility-inheritance-2">
兎を表す `symbol^e の［
`use^e による複数個の複製
］が~~明るい背景に示される（この生き物は兎であった）
— 各~兎は、体毛の色は様々だが，鼻と尻尾は同じ色（ピンクと~~白）にされている。
◎
Multiple use-copies of a rabbit-symbol on a light green background; each rabbit has different=coloured fur, but the same pink noses and white fluffy tails.
</p>
<figcaption>
例 `Use-visibility-hidden^xl ：
対話的な~style
◎
Example Use-visibility-hidden, interactive styles
</figcaption></figure>

`struct/Use-visibility-inheritance.svg^viewAs

<p>
この例は、
`use$e 要素~上に指定された他の~style~prop（ `fill$p, `stroke$p ）の継承と，これらも［
`symbol^e の中に明示的な値を指定する要素がある場合には，利用されなくなる様子（例： ピンクの鼻と耳, ~~白い尻尾）
］もデモる。
◎
The example also demonstrates inheritance of other style properties (fill and stroke) specified on the ‘use’ elements, and how these are also not used if any elements within the symbol specify explicit values (e.g., the pink noses and ears and the white tails).
</p>
</div>

		</section>
		<section id="UseAnimations">
<h3 title="Animations in use-element shadow trees">5.5.4. ~use要素の~shadow~tree内の~animation</h3>

<p>
`web-animations-1$r, `svg-animation$r は、
~targetにされた要素~上の属性や~styleを［
~CSSによらず，~DOM~propも直に操作しない
］仕方で~animateする仕方を定義する
（詳細は、`~animation付録＠~SVGmisc#animate$を見よ）。
それらの特能を実装する~UAは、
この節に従って，［
`参照先の~graphic$内の要素に適用されるすべての~animation
］が［
`~use要素の~shadow~tree$内の，その要素の各~instanceにも適用される
］ことを確保するモノトスル。
◎
The Web Animations API [web-animations-1] and the SVG Animations specification [svg-animation] define non-CSS ways to animate attributes and styles on targetted elements without directly manipulating DOM properties (see the Animation appendix for details). User agents that implement those features must ensure that all animations that apply to an element in a referenced document subtree also apply to instances of that element in a use-element shadow tree, as described in this section.
</p>

<div class="note">

<p>注記：
`参照先の~graphic$内の要素~上の属性（その `style$a 属性や~IDL~propを含む）を直に操作することで作成される，~scriptによる~animationは、
他の~DOM操作と同じ方式で，~shadow~tree内の`要素~instance$にも伝播されることになる。
◎
Scripted animations created by directly manipulating attributes on elements in the referenced graphics (including the ‘style’ attribute or its IDL property) will be propagated to the element instances in the shadow tree in the same manner as any other DOM manipulations.
</p>

<p>
~CSSを利用して適用される~animation効果は、
`§ ~style視野-法と継承＠#UseStyleInheritance$に指定される~~手続きに従って，
他の~stylesheet規則とともに重製されることになる。
◎
Animation effects applied using CSS will be duplicated along with other stylesheet rules, following the procedure specified in the Style Scoping and Inheritance section.
</p>
</div>

<p>
`~use要素の~shadow~tree$の中にあるすべての~animationは、
`対応している~use要素$と同じ`文書~時列線$内で演算する
— `参照先の要素$が同じ文書~内にあるか否か関わらず。
◎
All animations within a use-element shadow tree operate in the same document timeline as for the corresponding use element, regardless of whether the referenced element is from the same or an external document.
</p>

<p>
`web-animations-1$r ~API~methodを利用して適用された~animation効果に対しては、［
効果の`~target要素$が，~shadow~tree内の ある`要素~instance$に`対応している要素$である
］場合には、
~UAは，そのような各~instanceごとに
— 異なる~tree内にあるものも含め —
`ShadowAnimation$I を構築するモノトスル：
その構築子に定義される手続きに，引数 ( %source, %target ) として
( その~animationを表現する `Animation$I ~obj, `要素~instance$ )
を渡して。
◎
For animation effects applied using a Web Animations API method [web-animations-1], if the target of the animation is a corresponding element to an element instance in a shadow tree, the user agent must construct a ShadowAnimation whose source is that Animation object and whose target is the element instance. If there are multiple instances of the element in different trees, then there will be multiple shadow animations, one for each.
</p>

<p>
~UAは、~shadow~treeが生成された時点で，［
効果を発揮している どの`~animation$ `web-animations-1$r 用にも，
~shadow~treeが存在する間に適用された新たな~animation用にも
］，そのような `ShadowAnimation$I を作成するモノトスル（［
処理待ち／凍結された
］~animationも含めて）。
~UAは、［
~CSS~animation／~animation要素
］用には
`ShadowAnimation$I ~objを作成しないモノトスル
（これらは別々に重製されるので）。
◎
The user agent must create such a ShadowAnimation for all Web Animations API animations in effect (including pending and frozen animations) at the time the shadow tree is generated, and for any new animations applied while the shadow tree exists. The user agent must not create ShadowAnimation objects for CSS animations or animation elements (as these are duplicated separately).
</p>


<p class="note">注記：
`ShadowAnimation$I は、
~interface定義の一部として【すなわち、~scriptからは】読専であり，
`sourceAnimation$m に対する どの変化も反映しなければならない。
◎
As part of the interface definition, a ShadowAnimation is read-only, and must reflect any changes to its sourceAnimation.
</p>

<p>
［
`~use要素の~shadow~tree$の中にある
読専`要素~instance$（または疑似要素のそれ）である~target
］に新たな~animationを直に適用しようとするどの試みも，
`NoModificationAllowedError$E を投出するモノトスル。
◎
Any attempts to directly apply new animations to a target that is a read-only element instance (or pseudo-element) within a use-element shadow tree must throw a NoModificationAllowedError.
</p>

<p>
各`~animation要素$
`svg-animation$r
のうち，`参照先の~graphic$内の要素を~targetにするものに対しては、
~UAは，等価な~animation要素が`~use要素の~shadow~tree$内に効果を発揮することを確保するモノトスル。
~animation要素~自身が参照先の文書~下位treeの一部を成している場合、
これは`要素~instance$を作成する一環として，当の~animation要素に対し起こる。
他の場合、
~UAは，当の~animation要素~用に
— それが~shadow~tree内の~nodeであったかのように —
同じ効果を備える`要素~instance$を生成するモノトスル。
これらの生成された~animation要素の実質的な文書~順序は、
それぞれに`対応している要素$用の文書~順序と同じになるモノトスル【この要件は何のためにある？】。
◎
For each animation element [svg-animation] that targets an element in the referenced document subtree, the user agent must ensure that an equivalent animation element is in effect in the use-element shadow tree. If the animation element itself is part of the referenced document subtree, then this happens as a matter of course through the creation of an element instance for the animation element. Otherwise, the user agent must generate an element instance for the animation element that has the same effect as if it was a node in the shadow tree. The effective document order for these generated animation elements must be the same as the document order for their corresponding elements.
</p>

<p>
各［
~animation要素／その~instance
］が影響するのは、
同じ~node~tree（~shadow／~light）内の~target要素に限られるモノトスル
— ［
暗黙的（親~要素）, 明示的（要素 `id$a への域外参照~URL）
］どちらで~targetしているかに関わらず。
~animation要素と~target要素の間の一対一の関係性は、
この仕方で保全される。
◎
Each animation element or instance must only affect a target element in the same node tree (shadow or light), regardless of whether the targetting is implicit (the parent element) or explicit (a URL cross-reference to an element ‘id’). In this way, the one-to-one relationship between animation elements and target elements is preserved.
</p>

<p class="note">注記：
`id$a 属性も、
他の属性と同様に，`対応している要素$から`要素~instance$へ~cloneされる。
これは、 `id$a は一意とする要件には競合しない
— ~cloneと~clone元は、別個な~node~tree内にあるので。
◎
The ‘id’ attribute is cloned, like any other attribute, from the corresponding element to the element instance; This does not conflict with the requirement for ‘id’ to be unique, because the clone and the original are in distinct node trees.
</p>


<p>
［
文書や~shadow~tree
］内にある，~animation要素のうち［
その `id$a 属性により識別される別の要素
］上の~eventに呼応して［
始動する／終止する
］ものは、
その `id$a を伴うどの`要素~instance$が同じ~eventを受取るときにも［
始動する／終止する
］モノトスル。
この挙動は：
◎
All animation elements, in the document or in the shadow trees, which are timed to begin or end in response to an event on another element identified by its ‘id’ attribute, must also begin or end when any instance of an element with that ‘id’ receives the same event.＼
</p>

<ul>
	<li>
`§ ~use要素の~shadow~treeにおける~eventの取扱い＠#UseEventHandling$に従うふるまい
— `参照先の要素$上の~event~listenerは、
その要素の各~instance上でも，~eventを~listenする —
と整合する。
◎
This is consistent with how event listeners on a referenced element also listen to events on instances of that element, as described in the section on Event handling in use-element shadow trees.＼
</li>
	<li>
［
始動-時刻／終止-時刻
］が `id$a でなく~eventのみにより定義される~animation（したがって暗黙的に~target要素~上の~eventを~listenしているもの）には適用されない
— その事例では、
各~animation要素を誘発するのは，自前の~targetに限られる。
◎
This behavior does not apply to animation begin or end times defined only by an event and not by an ‘id’ (and therefore implicitly listening for the event on the target element); in that case, each animation element is only triggered by its own target.
</li>
</ul>

<p>
~animation要素 %A の`要素~instance$ %B が~shadow~treeの中に生成される時点で，次が満たされるならば、
%B 用の~animationも起動するモノトスル
— %B の始動-時刻は %A の計時に合致するように，`文書~時列線$内で後方（~~過去）へ調整した上で
⇒
［
%A には ある~animation %C が結付けられている
］~AND［
%C は作動中である（凍結された~animationも含む）
］~AND［
%C を起動した `timing^en ~eventは、
起動した時点で %B が存在していたとするなら， %B も起動していた
］
◎
At the time an instance of an animation element is generated within a shadow tree, if there is an active animation associated with the corresponding element (including a frozen animation), and the timing event that initiated that animation would also have initiated the instance if it existed, then the animation for the element instance must be initiated, with its begin time adjusted backwards in the document timeline to match the timing of the corresponding element.
</p>

<div class="note">

<p>注記：
この節の要件は、
`要素~instance$とそれに`対応している要素$は，
多くの事例で同期的に~animateすることを意味する。
これは、［
~animationが純粋に時刻に基づく
］または［
その `id$a により参照された要素に対する利用者~対話に呼応して［
始動する／終止する
］］事例に該当する。
しかしながら，当の~animationが［
それが~targetにしている要素~上の利用者~対話~event
］により（暗黙的に）誘発される場合、
~animationを表示するのは，対話~eventを受取る［
要素または要素~instance
］に限られることになる。
◎
In many cases, the requirements of this section mean that the element instance and its corresponding element will animate synchronously. This will be the case if the animation is purely time-based, or if it begins and ends in response to user interaction on an element referenced by its ‘id’. However, if the animation is triggered by a user interaction event on the targetted element (implicitly), then only the element or element instance that receives the interaction event will display the animation.
</p>

<p>
これは、以前の~versionの~SVGからの変更である
— そこでは、
利用者~対話に関わらず，`対応している要素$上のすべての~animationを映出すことが要求されていたが、
利用者による要素~instanceとの対話にどう応答するかについて，明瞭な指導は提供されてなかった。
この変更は、
~animation要素で宣言された対話的~animationは［
対話的な~CSS~style ／ ~CSS~animation
］と同じ方式で挙動することを確保する。
◎
This is a change from previous versions of SVG, which required all animations on the corresponding element to be mirrored, regardless of user interaction, but which did not offer clear guidance for responding to user interactions with the element instances. The change ensures that interactive animations declared with animation elements behave in the same manner as interactive CSS styles and CSS animations.
</p>

<p>
［
~instance／元の要素
］のうちいずれかが~eventを受取るときに［
すべての~instanceに適用される~animation
］を作成するためには、
要素 `id$a を明示的に指定する：
◎
In order to create animations that apply to all instances when any instance or the original element receives an event, specify the element ‘id’ explicitly:
</p>

<pre class="lang-xml">
&lt;set href="#target" begin="mouseover" ... /&gt;
  &lt;!-- <span class="comment">
~mouseが重なった要素のみに影響する
◎
only affects the element that is moused over
</span> --&gt;

&lt;set href="#target" begin="target.mouseover" ... /&gt;
  &lt;!-- <span class="comment">
`id^a に `target^v を伴うどの要素~instanceにも影響する
— それらのうち どれに重なろうが，~light, ~shadow どの~node~tree内にあるものにも。
◎
affects all instances of the element with the id 'target', in all light and shadow node trees, when any of them are moused over
</span> --&gt;
</pre>

</div>

		</section>
		<section id="UseEventHandling">
<h3 title="Event handling in use-element shadow trees">5.5.5. ~use要素の~shadow~treeにおける~eventの取扱い</h3>

<p>
`~use要素の~shadow~tree$内の要素は、
~DOM~eventを~listenし，~DOM~eventの~targetにもなる。
`~eventを~targetし直す$ことにより、［
~eventが~shadow~treeから外へ出て~light~treeの中へ浮上するときには，~shadow~DOM構造の詳細は~~隠蔽される
］ような~encapsulationが供される。
◎
Element in a use-element shadow tree can both listen for and be the target of DOM events. Event retargetting provides encapsulation, so that the details of the shadow DOM structure are masked when an event bubbles out of the shadow tree and into the light.
</p>


<p class="note">注記：
~eventを~targetし直すのは、
~SVG-2にて新たに~~導入された。
それは、~Shadow~DOM仕様と［
既存の実装 ／ ~main~DOM内の要素のみ懸念する作者の期待
］との一貫性を供する。
◎
Event retargeting is new in SVG 2. It provides consistency with the Shadow DOM specification, with existing implementations, and with the expectations of authors who are only concerned with elements in the main DOM.
</p>

<p>
`参照先の~graphic$内の要素~上に定義された どの~event~listenerも、［
`~use要素の~shadow~tree$内の［
その要素の各`要素~instance$
］］上で，同じ`捕捉-相$で同じ~eventを~listenするモノトスル。
これは、［
`~event属性$ ／ `addEventListener()$m ~method
］を利用してアテガわれた~event~listenerも含む
（~event属性の~listenerは、
他の~DOM属性と同じく重製されることになる）。
~UAは、
各`要素~instance$用の~event~listenerたちが成す~listを，
`対応している要素$のそれに合致するよう同期することを確保するモノトスル。
~event~listenerは、
`~use要素の~shadow~tree$内の読専`要素~instance$には直にアテガえない。
そのような要素に~event~listenerを追加しようとする どの試みに対しても，
`NoModificationAllowedError$E を投出するモノトスル。
◎
Any event listeners defined on an element in the referenced graphics must also listen for the same event, at the same capture phase, on each instance of that element in a use-element shadow tree. This includes event listeners assigned using event attributes (which would be duplicated as with any other DOM attribute) and also event listeners assigned using the addEventListener method. The user agent must ensure that the list of event listeners for each element instance is synchronized to match its corresponding element. An event listener cannot be directly assigned to a read-only element instance in a use-element shadow tree. Any attempt to add an event listener to such an element must throw a NoModificationAllowedError.
</p>

<p>
`~use要素の~shadow~tree$内の~eventは、
~shadow~tree用の`~event経路$と`~eventを~targetし直す$~algoに則って配送され，浮上する。
`DOM$r
◎
Events in the use-element shadow tree are dispatched and bubble according to the shadow tree event path and event retargeting algorithm [DOM].
</p>

<div class="note">

<p>注記：
一般に，`~use要素の~shadow~tree$用の`~event経路$は、
~event~target要素から先祖を遡って`~shadow根$まで構築され，
そこからは`~host$ `use$e 要素から文書~windowまでの~event経路を通る。
このことは、~eventは，`捕捉-相$においては［
~windowから定例の文書~treeを `use$e 要素まで降りて，その~shadow根から~shadow~treeを通って（複数の~shadow~treeを再帰的に通って）~event~target要素まで降りる
］ように伝播し、
`浮上-相$においては反対~方向に［
~shadow~tree内の要素, ~shadow根, `use$e 要素, その先祖たち
］の順に渡されることを意味する。
◎
In general, the event path for a use-element shadow tree is constructed from the ancestors of the event target element up to the shadow root, then the host ‘use’ element and its event path through to the document window. This means that, in the capture phase, an event propagates from the window through the regular document tree to the ‘use’ element and then to the shadow root object and down through the shadow tree (or recursively through multiple shadow trees) to the event target element. In the bubbling phase, the event passes in the opposite direction, from the shadow tree elements to the shadow root, then to the ‘use’ element and its ancestors.
</p>

<p>
`~eventを~targetし直す$~algoは、
`use$e 要素や その先祖~上の~event~listenerの視点からは，［
~shadow~tree内の`要素~instance$を~targetにするような どの~eventも、
その `target$n は，代わりに `use$e 要素になる
］ことを確保する。
~eventに［
`target$n, `relatedTarget^m
］両~属性があって, これらが同じ `use$e 要素を指すように~targetし直されることになる場合、~eventは~shadow~treeの外側へはまったく伝播されない。
これが生じるのは、
例えば，~shadow~treeの内側にある 2 つの要素~間で ~focusが移動したときである。
他のある種の~event型は、
作成される時点で，~shadow~treeの外側には伝播しないよう拘束される。
◎
The event retargeting algorithm ensures that from the perspective of event listeners on the ‘use’ element or its ancestors, all events targetted to element instances in the shadow tree instead have a target of the ‘use’ element itself. If the event has both a target and a relatedTarget, and both of these properties would be retargeted to point to the same ‘use’ element, then the event is not propagated at all outside of the shadow tree. This would occur, for example, if focus moved from one element inside the shadow tree to another. Certain other event types are constrained to not propagate outside of the shadow tree in which they were created.
</p>

<p>
対照的に，［
~shadow~treeを通して伝播している間に~eventを処理する
］~event~listenerは
（その~listenerは、`対応している要素$に追加されたものであるが）、［
~shadow~tree内の読専`要素~instance$を指している `target$n
］を伴う~eventを受取ることになる。
その`要素~instance$の［
<!-- `SVGElementInstance^I1 -->
`correspondingElement$m1, `correspondingUseElement$m1
］属性を利用すれば、
~main~DOM内の改変-可能な要素に~accessできる。
◎
In contrast, event listeners that process the event while it is propagating through the shadow tree (because the listener has been added to a corresponding element) will receive the event with its target pointing to a read-only element instance in the shadow tree. The correspondingElement and correspondingUseElement properties of that element instance can be used to connect it to the modifiable elements in the main DOM.
</p>
</div>


		</section>
	</section>
	<section id="ConditionalProcessing">
<h2 title="Conditional processing">5.6. 条件付き処理</h2>

		<section id="ConditionalProcessingOverview">
<h3 title="Conditional processing overview">5.6.1. 条件付き処理の概観</h3>


<p>
所与の［
~UAの能力, 利用者の言語
］に応じて，代替-~view法を指定する能を供するためとして、
~SVGには
`switch$e 要素と`条件付き処理~属性$（
`requiredExtensions$a, `systemLanguage$a
）がある。
◎
SVG contains a ‘switch’ element along with attributes ‘requiredExtensions’ and ‘systemLanguage’ to provide an ability to specify alternate viewing depending on the capabilities of a given user agent or the user's language.
</p>

<p>
`条件付き処理~属性$は、［
`真^i か `偽^i
］に評価される~testとして動作する。
`switch$e は、
その子のうち［
これらの属性による~testがすべて `真^i になる最初のもの
］を描画する。
これらのうち指定されていない属性は、
`真^i に評価されるものと見做される。
◎
Attributes ‘requiredExtensions’ and ‘systemLanguage’ act as tests and evaluate to either true or false. The ‘switch’ renders the first of its children for which all of these attributes test true. If the given attribute is not specified, then a true value is assumed.
</p>

<p>
条件付き処理により除外された要素は、［
`display$p ~propの使用~値は `none^v である
］かのように扱われる。
`display$p ~propと類似に，条件付き処理~属性が影響するのは、
当の要素の直接的な描画に限られる
— 他の要素（ `use$e など）から要素を参照できなくすることはない。
◎
When an element is excluded because of conditional processing, it is treated as if it had a used value of none for the display property. Similar to the display property, conditional processing attributes only affect the direct rendering of elements and do not prevent elements from being successfully referenced by other elements (such as via a ‘use’).
</p>

<p>
その帰結として：
◎
In consequence:
</p>

<ul>
	<li>
条件付き処理は、［
`~graphics要素$ ／ `a$e ／ `foreignObject$e ／ `~text内容~要素$
］の視覚的な表示に影響する。
◎
conditional processing affects the visual display of graphics elements, ‘a’, ‘foreignObject’, and text content elements.
</li>
	<li>
条件付き処理は、
`~animation要素$を再生するのを防止する。
【？】
◎
conditional processing prevents animation elements from playing.
</li>
	<li>
条件付き処理の効果は、
`決して描画されない要素$に対しては無い。
特に，条件付き処理は［
`style$e ／ `script$e
］要素の処理には影響しない。
◎
conditional processing will have no effect on never-rendered elements; in particular, conditional processing does not affect the processing of a ‘style’ or ‘script’ element.
</li>
	<li>
決して描画されない容器~要素（例：
`pattern$e ／ `mask$e
）の子~内容に対する条件付き処理は、［
子~内容は、容器~要素による~graphicな効果に寄与するかどうか
］に影響する。
◎
conditional processing of child content of a never-rendered container element (e.g., a ‘pattern’ or a ‘mask’) will affect whether that child content contributes to the graphical effect.
</li>
</ul>

<p class="note">注記：
以前の~versionの~SVGは、
条件付き処理~属性として，他にも `requiredFeatures^a を含んでいた。
これは、［
~SVG仕様の一部しか実装していない~UA用に，~fallbackの挙動を供する
］ことを作者に許容することが意図されていた。
あいにく，この属性の仕様と実装は拙かっため、
特能~supportの~testとしては，依拠-不能であった。
◎
Previous versions of SVG included a third conditional processing attribute, requiredFeatures. This was intended to allow authors to provide fallback behavior for user agents that only implemented parts of the SVG specification. Unfortunately, poor specification and implementation of this attribute made it unreliable as a test of feature support.
</p>

		</section>
		<section id="ConditionalProcessingDefinitions">
<h3 title="Definitions">5.6.2. 定義</h3>

<dl class="definitions">
	<dt>
`条件付き処理~属性@
（ `conditional processing attribute^en ）
</dt>
	<dd>
属性のうち、
それが現れる要素を処理するかどうかを制御するもの。
すべてではないが，ほとんどの要素には、
条件付き処理~属性を指定できる。
詳細は、`§ 条件付き処理＠#ConditionalProcessing$を見よ。
~SVG-2は、
条件付き処理~属性として［
`requiredExtensions$a, `systemLanguage$a
］を定義する。
◎
A conditional processing attribute is one that controls whether or not the element on which it appears is processed. Most elements, but not all, may have conditional processing attributes specified on them. See Conditional processing for details. The conditional processing attributes defined in SVG 2 are ‘requiredExtensions’ and ‘systemLanguage’.
</dd>
</dl>

		</section>
		<section id="SwitchElement">
<h3 title="The ‘switch’ element">5.6.3. `switch^e 要素</h3>

◎要素名 `switch@e
◎分類 `容器~要素$, `描画-可能な要素$
◎内容 任意個数, 任意順序の，次に挙げる要素
⇒＃
`~animation要素$
`図形~要素$
`a$e,
`foreignObject$e,
`g$e,
`image$e,
`svg$e,
`switch$e,
`text$e,
`use$e
◎属性
`~ARIA属性$,
`条件付き処理~属性$,
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$,
`呈示~属性$
◎界面 `SVGSwitchElement$I
◎表終

<p>
`switch$e 要素は、
その各~子~要素に対し順に，その［
`requiredExtensions$a, `systemLanguage$a
］属性を評価していき、
これらの属性がともに `真^i に評価される最初の子を処理して描画する。
他のすべての子は、
迂回され，描画されないことになる。
子~要素が `g$e などの容器~要素である場合、
その下位tree全体が［
処理されて描画されるか, 迂回されて描画されないか
］のどちらかになる。
◎
The ‘switch’ element evaluates the ‘requiredExtensions’ and ‘systemLanguage’ attributes on its direct child elements in order, and then processes and renders the first child for which these attributes evaluate to true. All others will be bypassed and therefore not rendered. If the child element is a container element such as a ‘g’, then the entire subtree is either processed/rendered or bypassed/not rendered.
</p>

<p>
~SVGにおいては、
`systemLanguage$a 属性を評価するときの
`switch$e 要素の子孫~要素†は、［
`SMIL$r が定義する `allowReorder$a 属性の値は常に `yes^v にされていた
］かのような順序で評価されるモノトスル。
【† なぜ、子ではなく子孫なのかは不明】
◎
In SVG, when evaluating the ‘systemLanguage’ attribute, the order of evaluation of descendant elements of the ‘switch’ element must be as if the 'allowReorder' attribute, defined in the SMIL specification [SMIL] always has a value of 'yes'.
</p>

<p>
`switch$e 要素の処理には［
`display$p ／ `visibility$p
］~propによる効果は無いことに注意。
特に， `switch$e 要素の子の `display$p を `none^v に設定しようが、
`switch$e 要素の `真^i/`偽^i ~test法に効果を及ぼすことはない。
◎
Note that the values of properties display and visibility have no effect on ‘switch’ element processing. In particular, setting display to none on a child of a ‘switch’ element has no effect on true/false testing associated with ‘switch’ element processing.
</p>

<p>
`switch$e 要素は［
`script$e ／ `style$e
］要素の処理には影響しない。
◎
The ‘switch’ element does not affect the processing of ‘script’ and ‘style’ elements.
</p>

<p>
更なる情報, 例は、
`foreignObject$e 要素を見よ。
◎
For more information and an example, see Embedding foreign object types.
</p>

		</section>
		<section id="ConditionalProcessingRequiredExtensionsAttribute">
<h3 title="The ‘requiredExtensions’ attribute">5.6.4. `requiredExtensions^a 属性</h3>


<p>
`requiredExtensions$a 属性は、
要求される言語~拡張の~listを定義する。
言語~拡張は、
この仕様が定義する特能の集合を超える，~UAが備える能力の総称である。
各~拡張は、
`~URL参照$secで識別される。
◎
The ‘requiredExtensions’ attribute defines a list of required language extensions. Language extensions are capabilities within a user agent that go beyond the feature set defined in this specification. Each extension is identified by an URL reference.
</p>

<dl class="attrdef-list">
	<dt>
◎属名 `requiredExtensions@a
◎属値 `~space等で分離された~token集合$ `HTML^r
◎属初 （ナシ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
requiredExtensions 	set of space-separated tokens [HTML] 	(none) 	no
</dt>
	<dd>
値を成す各~tokenは、［
要求される ある拡張を識別する`~URL参照$sec
］を与える。
~UAは、それらすべての拡張を~supportするかどうか決定する。
この属性は［
所与の拡張をすべて~supportするならば `真^i ／
~ELSE_ `偽^i
］に評価される。
（ `偽^i ならば、現在の要素は、その内容ごと飛ばされ，描画されない。）
◎
The value is a list of URL references which identify the required extensions, with the individual values separated by white space. Determines whether all of the named extensions are supported by the user agent. If all of the given extensions are supported, then the attribute evaluates to true; otherwise, the current element and its children are skipped and thus will not be rendered.
</dd>
</dl>

<p>
所与の拡張~用の`~URL参照$secが空白を包含する場合、
その空白は~escapeされなければナラナイ。
◎
If a given URL reference contains white space within itself, that white space must be escaped.
</p>


<p>
`requiredExtensions$a 属性は、
無い場合は暗黙的に `真^i に評価され，値が空~文字列の場合は
【！ ＊null string or empty string 】
`偽^i に評価される。
【すなわち，空~文字列は、決して~supportされない拡張を識別する 1 個の~tokenからなるものと解釈される。】
◎
If the attribute is not present, then it implicitly evaluates to "true". If a null string or empty string value is given to attribute ‘requiredExtensions’, the attribute evaluates to "false".
</p>

<p>
`requiredExtensions$a 属性は， `switch$e 要素と併用されることが多い。
他の状況で利用された `requiredExtensions$a は、
それを有する要素を描画するかしないかを表す単純な~switchを表現する。
◎
‘requiredExtensions’ is often used in conjunction with the ‘switch’ element. If the ‘requiredExtensions’ is used in other situations, then it represents a simple switch on the given element whether to render the element or not.
</p>

<p>
拡張~用の~URL名は、
~version付け情報を含むベキである
— `http://example.org/SVGExtensionXYZ/1.0^l など —
~scriptの書き手が，所与の拡張の異なる~versionを判別できるよう。
◎
The URL names for the extension should include versioning information, such as "http://example.org/SVGExtensionXYZ/1.0", so that script writers can distinguish between different versions of a given extension.
</p>

		</section>
		<section id="ConditionalProcessingSystemLanguageAttribute">
<h3 title="The ‘systemLanguage’ attribute">5.6.5. `systemLanguage^a 属性</h3>

<dl class="attrdef-list">
	<dt>
◎属名 `systemLanguage@a
◎属値 `~commaで分離された~token集合$ `HTML^r
◎属初 （ナシ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
systemLanguage 	set of comma-separated tokens [HTML] 	(none) 	no
</dt>
	<dd>
値を成す各~tokenは、
`BCP47$r に定義される `Language-Tag$P 値でなければナラナイ。
◎
The value is a set of comma-separated tokens, each of which must be a Language-Tag value, as defined in BCP 47 [BCP47].
</dd>
</dl>

<p>
この属性は、
次が満たされるならば `真^i に評価され，
他の場合は `偽^i に評価される
⇒
［
利用者~選好により指示された いずれかの言語~tag %A,
この属性の値を成す いずれかの言語~tag %B
］は次を満たす
⇒
［
%A は %B の頭部に文字大小無視で合致する
］~AND［
%B から合致した部分を除去した結果は、
空であるか，先頭の文字は `-^l である
］
◎
Evaluates to "true" if one of the language tags indicated by user preferences is a case-insensitive match of one of the language tags given in the value of this parameter, or if one of the language tags indicated by user preferences is a case-insensitive prefix of one of the language tags given in the value of this parameter such that the first tag character following the prefix is "-".
◎
Evaluates to "false" otherwise.
</p>

<p>
`systemLanguage$a 属性は、
無い場合には暗黙的に `真^i に評価され，
値が空~文字列の場合は【！ ＊null string or empty string 】 `偽^i に評価される。
【すなわち，空~文字列は、どの言語~tagにも合致しない 1 個の言語~tagからなるものと解釈される。】
◎
If the attribute is not present, then it implicitly evaluates to "true". If a null string or empty string value is given to attribute ‘systemLanguage’, the attribute evaluates to "false".
</p>

<p>
注記：
接頭辞~照合~規則のこの利用は、［
言語~tagは［
利用者は一定の~tagを伴う言語を解するならば、
その~tagを接頭辞とする~tagを伴う他のどの言語も常に解する
］ような仕方で言語にアテガわれている
］ことを含意するものではない。
◎
Note: This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always true that if a user understands a language with a certain tag, then this user will also understand all languages with tags for which this tag is a prefix.
</p>

<p>
接頭辞~規則は、
単純に，これが該当する場合に接頭辞~tagの利用を許容するだけである。
◎
The prefix rule simply allows the use of prefix tags if this is the case.
</p>

<p class="note">実装に対する注記：
言語上の選好について~~選択肢を利用者に可用にするときは、
実装者は
— 利用者が上に述べた言語~照合の詳細~には馴染んでない事実を織り込んで —
適切な手引きを供するベキである。
例えば利用者は、
`en-gb^l を選択すれば［
可用な文書に~British~Englishは無いが他に~Englishがあるときは，どの種類であれ~serveされる
］ものと見做すかもしれない。
利用者の選好を設定する~UIは、
照合の挙動を最良にするためには `en^l も追加するよう，利用者を手引きするベキである。
◎
Implementation note: When making the choice of linguistic preference available to the user, implementers should take into account the fact that users are not familiar with the details of language matching as described above, and should provide appropriate guidance. As an example, users may assume that on selecting "en-gb", they will be served any kind of English document if British English is not available. The user interface for setting user preferences should guide the user to add "en" to get the best matching behavior.
</p>

<p>
複数の視聴者~向けに意図された内容~用に，複数の言語が挙げられてもヨイ。
◎
Multiple languages may be listed for content that is intended for multiple audiences.＼
</p>

<div class="example">
<p>
例えば、
~Englishと~~日本語訳~versionが同時に呈示される内容は，次のようになるであろう：
◎
For example, content that is presented simultaneously in the original Maori and English versions, would call for:
</p>

<pre class="lang-xml">
&lt;text systemLanguage="en, ja"&gt;&lt;!-- <span class="comment">
ここには内容がある
◎
content goes here
</span> --&gt;&lt;/text&gt;
</pre>

</div>

<p>
しかしながら，［
`systemLanguage$a 属性が設置された~obj
］の中に複数の言語が在るだけで，複数種の言語~話者~向けが意図されたことにはならない。
例えば、
“A First Lesson in Latin” などの，
~English話者~向けが明瞭に意図された初学者~向け言語~入門書であれば、
`systemLanguage$a ~test属性は `en^l のみを含むベキである。
◎
However, just because multiple languages are present within the object on which the ‘systemLanguage’ test attribute is placed, this does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as "A First Lesson in Latin," which is clearly intended to be used by an English-literate audience. In this case, the ‘systemLanguage’ test attribute should only include "en".
</p>

<p class="note">注記：
作者は、
`switch$e 内に封入された どの代替~言語~objも合致しない結果，
どの内容も表示されない状況にもなりかねないことを悟るベキである。
したがって，そのような `switch$e の末尾には［
あらゆる事例に受容-可能な “万能の” ~~選択肢
］を含むことが推奨される。
◎
Authoring note: Authors should realize that if several alternative language objects are enclosed in a ‘switch’, and none of them matches, this may lead to situations where no content is displayed. It is thus recommended to include a "catch-all" choice at the end of such a ‘switch’ which is acceptable in all cases.
</p>

<p>
`systemLanguage$a は、
`switch$e 要素と併用されることが多い。
他の状況で利用された `systemLanguage$a は、
それを有する要素を描画するかしないかを表す単純な~switchを表現する。
◎
‘systemLanguage’ is often used in conjunction with the ‘switch’ element. If the ‘systemLanguage’ is used in other situations, then it represents a simple switch on the given element whether to render the element or not.
</p>

		</section>
	</section>
	<section id="DescriptionAndTitleElements">
<h2 title="The ‘desc’ and ‘title’ elements">5.7. `desc^e, `title^e 要素</h2>

		<section id="DescriptionDefinitions">
<h3 title="Definition">5.7.1. 定義</h3>
<dl class="definitions">
	<dt>
`記述的~要素@
（ `descriptive element^en ）
</dt>
	<dd>
要素であって，その親についての補足する記述的~情報を供するもの。
特定的には、次に挙げる要素
⇒
`desc$e,
`metadata$e,
`title$e
◎
An element which provides supplementary descriptive information about its parent. Specifically, the following elements are descriptive elements: ‘desc’, ‘metadata’ and ‘title’.
</dd>
</dl>


<p class="note">注記：
［
`desc$e ／ `title$e
］要素の国際-化を許容するため、 
`lang$a 属性に基づく多言語の記述的~text選定が追加された。
◎
Multilingual descriptive text selection, based on the ‘lang’ attribute, was added to allow internationalization of the ‘desc’ and ‘title’ elements.
</p>


<p class="annotation">
~SVG-2にて新たに~~導入された。
`lang^a を追加することが
Rigi Kaltbad face-to-face
にて解決された。
［
`desc^e ／ `title^e 
］要素の個数を制限していた~textは除去した。
`Status: done^en
◎
New in SVG 2. Adding 'lang' resolved at Rigi Kaltbad face-to-face. Removed text that limited number of 'desc' and 'title' elements. Status: Done.
</p>



<p>
~SVG文書~内のどの［
`容器~要素$ ／ `~graphics要素$
］も［
0 個~以上の `desc$e 要素,
0 個~以上の `title$e 要素
］を子として持てる。
その内容は~textである。
［
`desc$e ／ `title$e
］要素は、
~graphicの一部として視覚的に描画されることはない。
［
`desc$e ／ `title$e
］要素~用の `display$p 値は、
`~UA~stylesheet$により，常に `none^v に設定されるモノトスル
— この宣言の重要度は，他のどの［
~CSS規則／呈示~属性
］よりも高いモノトスル。
◎
Any container element or graphics element in an SVG document can have zero or more ‘desc’ and/or ‘title’ elements as children, whose content is text. ‘desc’ and ‘title’ elements are not visually rendered as part of the graphics. The display value for the ‘title’ and ‘desc’ elements must always be set to none by the user agent style sheet, and this declaration must have importance over any other CSS rule or presentation attribute.
</p>

<p>
互いに同胞である［
複数の `desc$e 要素 ／ 複数の `title$e 要素
］の言語は互いに異なっていなければナラナイ。
ここで，要素の言語は、
自身, または，その先祖~上の `lang$a 属性（または `xml:lang^a 属性）を利用して定義される。
~UAは、［
`desc^e, `title^e
］各~型の要素たちに対し，［
利用者が設定した言語~選好に最良に合致する言語を持つもの
］を選定するモノトスル。
言語~tagとして空~文字列
（どの言語も指示しない
— 例えば，絵文字~記号からなる~text代替~用の）
を伴う記述的~要素は、
利用者が指定した どの言語~選好よりも低い優先度で合致するとする。
言語~選好に等しく妥当に合致するものが複数~存在する場合、
最初に合致したものが利用されるベキである。
所与の型の要素は在るが合致するものは存在しない場合、
その型の最初の要素が選定されるモノトスル。
◎
Multiple sibling ‘desc’ or ‘title’ elements must have different languages, as defined using a ‘lang’ attribute (or xml:lang attribute) on the descriptive element or an ancestor. The user agent must select the element of each type whose language best matches language preferences set by the user. A descriptive element with an empty-string language tag (indicating no language, for example a text alternative consisting of emoji symbols) is a lowest-priority match for any user, ranked below all user-specified language preferences. If multiple equally valid matches exist, the first match should be used. If no match exists for either 'title' or 'desc', the first element of that type must be selected.
</p>

<div class="example">

<p>
再利用される星形~icon上の代替~言語~titleたちを次の例に示す。
この例の文書片は、
~HTML文書~内に~inlineに埋込まれていて，その~HTMLには言語 `en^c
（国別~codeが指定されていない~English）
が正しく宣言されているとする。
◎
The following example shows alternative language titles on a re-used star icon, inline in an HTML document. The example assumes that the HTML document as a whole has a correctly-declared language of en (English without a specified country code).
</p>

<pre class="lang-xml">
&lt;svg&gt;
  &lt;use href="#star"&gt;
    &lt;title&gt;Favourite&lt;/title&gt;
    &lt;title lang="en-us"&gt;Favorite&lt;/title&gt;
    &lt;title lang="nl"&gt;Favoriet&lt;/title&gt;
    &lt;title lang=""&gt;★&lt;/title&gt;
  &lt;/use&gt;
&lt;/svg&gt;
</pre>

<p>
最初の `title^e 要素は 文書の言語（ `en^c ）を継承し、
それ以外の各~要素には，明示的に言語が宣言されている。
~iconの~titleは、
利用者が選好する言語~listに［
~American~English（ `en-us^c ）が在るならば~American綴り "Favorite" になる ／
他の場合，~Dutch（ `nl^ ）が在るならば "Favoriet" になる
］。
言語~listが汎用の~Englishを含んでいて，~Dutchより優先度が高くされている場合、
~titleは~British綴りによる "Favourite" になる。
利用者が~Dutchも~Englishも解さないならば、
~titleは星形~記号による文字になる
— それは理想的ではないが（ほとんどの~screen-readerは、
それを "`black star^en" の地域化d~versionとして読上げる）、
~text代替がまったく無いよりは良い。
◎
The first title element inherits the language of the document (en); the others have explicitly-declared languages for each element. If the user's preferred language (out of those provided) is American English, the icon title is the American spelling "Favorite". If the user's preferred language is Dutch, the icon title is "Favoriet". If the user's preference list includes generic English ranked higher than Dutch, the title is "Favourite" with British spelling. If the user does not understand either Dutch or English, the title will be the star symbol character—which is not ideal (most screen readers will read it as a localized version of "black star"), but better than no text alternative at all.
</p>

<p class="note">注記：
作者は、［
~SVG-11を~supportするが，多言語の記述的~textをまだ実装していない~UAは、
利用者~選好に関わらず，通常は各~要素~型に対し最初の要素を選定する
］ことについて自覚するベキである。
~SVG-11~UAはまた、［
`title^e 要素のうち，その親の最初の子でないもの ／
`desc^e 要素のうち，その前に他の記述的~要素でない同胞があるもの
］を認識するのに失敗するかもしれない。
◎
Authors should be aware that SVG 1.1-supporting user agents that have not yet implemented multi-lingual descriptive text will normally select the first element of each type, regardless of user preferences. SVG 1.1 user agents may also fail to recognize a title element that is not the first child of its parent, or a desc element that has previous siblings that are not other descriptive elements.
</p>
</div>


<p class="issue" id="issue67">
地域化された情報を供するために［
複数個の `title$e ／ 複数個の `desc$e
］要素を利用することは、
既知な実装が無く，~risk下にある。
◎
The use of more than one ‘title’ or ‘desc’ element to provide localised information is at risk, with no known implementations.
</p>

<p>
~UAは、選定した［
`title^e ／ `desc^e
］要素の~text内容を~platform~accessibility~APIに可用にするモノトスル
— 
`SVG Accessibility API Mappings＠~TR/svg-aam-1.0/$cite `svg-aam-1.0$r
仕様に定義される，親~要素~用の［
名前 ／ 記述
］算出の一部として。
◎
User agents must make the text content of selected 'title' and 'desc' elements available to platform accessibility APIs as part of the name and description computation for the parent element, as defined in the SVG Accessibility API Mappings [SVG-AAM] specification.
</p>

<p>
`描画される要素$の子に［
`title^e ／ `desc^e
］要素を含めることは、［
描画される要素は，~graphicにおいて意味論上の重要度がある
］ことを指示する。
［
作者 ／ `~SVG生成器$
］は、~text内容が空白しかない［
`title^e や `desc^e
］要素を［
含めるベキでない／含めてはナラナイ
］
— そうすると，支援技術の利用者に無名の~objを呈示することになるので。
◎
Inclusion of any 'title' or 'desc' elements as a direct child of a rendered element indicates that the rendered element is of semantic importance in the graphic. Authors should not, and SVG generators must not, include empty 'title' or 'desc' elements with no text content or whitespace-only text content, as this will result in a nameless object being presented to assistive technology users.
</p>


<p>
自前の意味が無い個々の~graphic要素に対しては、
代替~textは，代わりに有意義な~objを述べるような最も近い【先祖の】容器~要素~用に供されるベキである。
作者は、
~group化（ `g$e ）要素を利用して，それらの何かを描く要素を有意義な~objに構造化した上で，
そのような~groupを `title$e で命名するベキである。
逆に、
単純に~styleや~layoutを適用するために利用され，有意義な~group化~構造を供さない容器~objには、
代替~textは必要ない。
◎
If an individual graphic element has no meaning on its own, alternative text should instead be provided for the nearest container element that describes a meaningful object. Authors should use grouping (‘g’) elements to structure their drawing elements into meaningful objects, and name those groups with ‘title’. Conversely, if a container object is used simply to apply styles or layout, and neither defines an object nor provides meaningful grouping structure, it does not need alternative text.
</p>

<p>
作者／著作~toolは、
記述的~text要素を`描画されない＠~SVGrender#Rendered-vs-NonRendered$要素の子に参照~情報として利用してもヨイ。
この~dataは、
通常は，支援技術を通して~graphicを~viewしている末端~利用者~向けには可用にならないので、
作者は注意されたし。
それでも，`描画されない要素$は，
（`SVG-AAM＠~TR/svg-aam-1.0/$cite にて定義されるとおり）
描画される要素の~access可能な［
名前／記述
］の一部として参照され得るので、
再帰的な算出は，参照先の要素の記述的な子~要素を利用することになる。
◎
Descriptive text elements whose parent is not rendered may be used by authors or authoring tools as reference information; authors are warned that this data is not normally available to end users viewing the graphic through assistive technologies. Nonetheless, a non-rendered element may be referenced as part of the accessible name or description of a rendered element (as defined in SVG-AAM), and the recursive computation will use descriptive child elements of the referenced element.
</p>

<p>
［
`desc^e ／ `title^e
］要素は、［
名前空間を指示する標準~XMLの仕組みを利用して，他の名前空間に属する要素で~mark-upされた~text
］を包含してもヨイ。
しかしながら，作者は、
代替~textに意味を供するときに，そのような~markupに依拠するベキでない
— 現時点では、
支援技術に公開するよう要求されるものは，素な~text内容に限られているので。
◎
Description and title elements may contain marked-up text from other namespaces, using standard XML mechanisms to indicate the namespace. However, authors should not rely on such markup to provide meaning to alternative text; only the plain text content is currently required to be exposed to assistive technologies.
</p>


<p class="note">注記：
~HTML構文解析器は、［
`desc$e ／ `title$e
］の中のすべての~markupを，~HTML素片~内の~markupと同じ仕方で扱う
— ほとんどの要素には、
~HTML名前空間がアテガわれることになる。
◎
The HTML parser treats all markup within ‘title’ and ‘desc’ the same way it treats markkup in an HTML fragment; most elements will be assigned to the HTML namespace.
</p>


<p>
~UAは、
`title$e の中の~markupを~titleの視覚的な呈示（~tooltipなど）に波及するように利用してもヨイが，そうすることは要求されない。
◎
User agents may use markup within ‘title’ to influence the visual presentation of titles (such as tooltips), but are not required to do so.
</p>

<div id="TitleElement">
◎要素名 `title@e
◎分類 `記述的~要素$, `決して描画されない要素$
◎内容 任意個数, 任意順序の，~~任意の要素, 文字~data
◎属性
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$
◎界面 `SVGTitleElement$I
◎表終
</div>

<p>
`title$e 要素は、
その親~要素~用の短い~text代替を表現する。
これは、次に挙げるもの, 等々にもなり得る：
◎
The ‘title’ child element represents a short text alternative for the element.
</p>

<ul>
	<li>
~link上では ~target資源の~titleや記述
◎
On a link, this could be the title or a description of the target resource;＼
</li>
	<li>
画像や何かを描く~obj上では、
~graphicの短い記述
◎
on an image or drawing object, it could be a short description of the graphic;＼
</li>
	<li>
対話的~内容においては、
それ用の~label, それ用の指示書き, 当の要素の用途, 等々
◎
on interactive content, it could be a label for, or instructions for, use of the element; and so forth.
</li>
</ul>

<p>
作者は、
何かを描く要素~用に可視な~labelもある場合は（例： `text$e 要素を利用して）、
冗長な情報を `title$e 要素~内に供するベキでない。
視覚的な~labelは、
代わりに `aria-labelledby$a 属性を利用して何かを描く要素に結付けられるベキである。
◎
Authors should not provide redundant information in a ‘title’ element if there is also a visible label for the drawing element (e.g., using a ‘text’ element). Instead, the visual label should be associated with the drawing element using an ‘aria-labelledby’ attribute.
</p>

<p>
対話的~UAは、
利用者~対話に呼応して，
`title$e 要素の内容を成す素な~textを ~platform規約と整合な方式で可用にするベキである
— 既存の~UAの多くは、
`title$e 要素の親~要素に~hoverされたとき，~tooltipとして描画する。
◎
Interactive user agents should make the plain text content of ‘title’ elements available in response to user interaction, in a manner consistent with platform conventions; existing user agents commonly render ‘title’ elements as a tooltip on hovering the parent element.
</p>

<p>
作者は、
自立的~SVG文書の中に，その根 `svg^e 要素の子として `title$e 要素を供するベキである。
利用者は 文脈の外から文書にアタることが多いので、
作者は 文脈に~~富む~titleを供するベキである。
したがって作者は、
“序論” のような文脈的な背景に乏しい~titleに代えて，
“中世の養蜂 序論”
のような~titleを給するベキである。
~accessibilityの理由から、
~UAは，根 `svg^e 要素の `title^e 子~要素の内容を利用者に可用にするベキである。
しかしながら，これは概して、［［
入子な~SVGや~graphics要素
］用に利用される~tooltip
］以外の手段を通して行われる
— 例：~browser~UItab内に表示するなど。
◎
Authors should provide a ‘title’ child element to the root svg element within a stand-alone SVG document. Since users often consult documents out of context, authors should provide context-rich titles. Thus, instead of a title such as "Introduction", which doesn't provide much contextual background, authors should supply a title such as "Introduction to Medieval Bee-Keeping" instead. For reasons of accessibility, user agents should always make the content of the ‘title’ child element to the root svg element available to users. However, this is typically done through other means than the tooltips used for nested SVG and graphics elements, e.g., by displaying in a browser tab.
</p>

<div id="DescElement">
◎要素名 `desc@e
◎分類 `記述的~要素$, `決して描画されない要素$
◎内容 任意個数, 任意順序の，~~任意の要素, 文字~data
◎属性
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$
◎界面 `SVGDescElement$I
◎表終
</div>

<p>
`desc$e 要素は、
他の要素~用に，記述など，より詳細な~textな情報を表現する。
この情報
— ［
~graphicを成す視覚的な外観の記述 ／
複階的な~widgetの機能性を説明する助言
］など —
は、概して支援技術に公開される。
これは，他の利用者~向けに可用にされることは概してないので、
本質的な指示書き用に利用されるベキではない。
◎
The ‘desc’ element represents more detailed textual information for the element such as a description. This is typically exposed to assistive technologies to provide more detailed information, such as a description of the visual appearance of a graphic or help to explain the functionality of a complex widget. It is not typically available to other users, so should not be used for essential instructions.
</p>

<p>
作者は、
（記述される要素またはその親~容器に）
`aria-describedby$a 属性を利用して
— その値に 1 個~以上の記述を包含している［
~SVG／~HTML
］要素への~ID参照を伴わせることにより —
~graphicの一部に［
可視な~textを含む詳細な情報
］を結付けてもヨイ。
`aria-describedby$a 属性を通して供される記述は、
子 `desc$e 要素より優先される。
要素に［
可視な記述, 補足する情報を供している子 `desc$e 要素
］の両者がある場合、
作者は，［
`aria-describedby$a の値を成す~listに後者の `id$a も明示的に含めて，両~記述を一緒に連結する
］ベキである。
◎
Authors may associate detailed information, including visible text, with part of the graphic using ‘aria-describedby’ attribute (on the described element or a parent container), with the value being an ID reference to one or more SVG or HTML elements containing the description. The ‘aria-describedby’ attribute takes precedence over the child ‘desc’ when providing a description. If an element has both visible description and a child ‘desc’ element providing supplementary information, authors should explicitly include the ‘id’ of the element itself in its own ‘aria-describedby’ list, in order to concatenate the two descriptions together.
</p>

		</section>
	</section>
	<section id="MetadataElement">
<h2 title="The ‘metadata’ element">5.8. `metadata^e 要素</h2>

<p>
~SVG内容に含まれる~metadataは、
`metadata$e 要素の中に指定されるベキである。
`metadata$e の内容は、［
`xml-names$r 勧告に適合する方式で表出された，他の~XML名前空間に属する要素たち
］からなるベキである。
◎
Metadata which is included with SVG content should be specified within ‘metadata’ elements. The contents of the ‘metadata’ should be elements from other XML namespaces, with these elements from these namespaces expressed in a manner conforming with the Namespaces in XML Recommendation [xml-names].
</p>


<p class="annotation">
~SVG-2は［
~metadata要素を，特定0の仕方で構造化するものとする推奨
］を除去する。
◎
SVG 2 removes the recommendation to structure metadata elements in any particular way.
</p>

◎要素名 `metadata@e
◎分類 `記述的~要素$, `決して描画されない要素$
◎内容 任意個数, 任意順序の，~~任意の要素, 文字~data
◎属性
`中核~属性$,
`大域~event属性$,
`文書~要素~event属性$
◎界面 `SVGMetadataElement$I
◎表終


<p>
~metadata内容は、
直に描画されることはない。
`metadata$e 要素~用の `display$p 値は、
`~UA~stylesheet$により，常に `none^v に設定されるモノトスル
— この宣言の重要度は，他のどの［
~CSS規則／呈示~属性
］よりも高いモノトスル。
◎
Metadata content is not directly rendered; the display value for the ‘metadata’ element must always be set to none by the user agent style sheet, and this declaration must have importance over any other CSS rule or presentation attribute.
</p>

<div class="example">

<p>
~SVG文書~内に~metadataを含める方法を，次の例に示す。
この例は Dublin Core ~version 1.1 ~schemaを利用する。
（~XMLに互換な他の~metadata言語も利用できる
— ~RDFに基づくものも含め。）
◎
Here is an example of how metadata can be included in an SVG document. The example uses the Dublin Core version 1.1 schema. (Other XML-compatible metadata languages, including ones not based on RDF, can be used also.)
</p>


<pre class="lang-xml">
&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;svg width="4in" height="3in"
    xmlns = 'http://www.w3.org/2000/svg'&gt;
    &lt;desc xmlns:myfoo="http://example.org/myfoo"&gt;
      &lt;myfoo:title&gt;This is a financial report&lt;/myfoo:title&gt;
      &lt;myfoo:descr&gt;The global description uses markup from the
        &lt;myfoo:emph&gt;myfoo&lt;/myfoo:emph&gt; namespace.&lt;/myfoo:descr&gt;
      &lt;myfoo:scene&gt;&lt;myfoo:what&gt;widget $growth&lt;/myfoo:what&gt;
      &lt;myfoo:contains&gt;$three $graph-bar&lt;/myfoo:contains&gt;
        &lt;myfoo:when&gt;1998 $through 2000&lt;/myfoo:when&gt; &lt;/myfoo:scene&gt;
   &lt;/desc&gt;
    &lt;metadata&gt;
      &lt;rdf:RDF
           xmlns:rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
           xmlns:rdfs = "http://www.w3.org/2000/01/rdf-schema#"
           xmlns:dc = "http://purl.org/dc/elements/1.1/" &gt;
        &lt;rdf:Description about="http://example.org/myfoo"
             dc:title="MyFoo Financial Report"
             dc:description="$three $bar $thousands $dollars $from 1998 $through 2000"
             dc:publisher="Example Organization"
             dc:date="2000-04-11"
             dc:format="image/svg+xml"
             dc:language="en" &gt;
          &lt;dc:creator&gt;
            &lt;rdf:Bag&gt;
              &lt;rdf:li&gt;Irving Bird&lt;/rdf:li&gt;
              &lt;rdf:li&gt;Mary Lambert&lt;/rdf:li&gt;
            &lt;/rdf:Bag&gt;
          &lt;/dc:creator&gt;
        &lt;/rdf:Description&gt;
      &lt;/rdf:RDF&gt;
    &lt;/metadata&gt;
&lt;/svg&gt;
</pre>

</div>


	</section>
	<section id="HTMLMetadataElements">
<h2 title="HTML metadata elements">5.9. ~HTML~metadata要素</h2>

<p>
~HTMLを~supportする~UAは、
~SVG文書においては，
次に挙げる~HTML要素（~HTML名前空間に属する要素）を~supportするモノトスル
⇒
`base$eH,
`link$eH,
`meta$eH,
`style$eH,
`script$eH
◎
For user agents that support HTML, the following HTML elements (in the HTML namespace) must be supported in SVG documents:
◎
• the base element
• the link element
• the meta element
• the style element
• the script element
</p>

<p class="note">注記：
`base$eH 要素は、
文書~内のすべての~URL値に影響することに注意
— 塗り~server参照や `use$e 要素~参照なども含め。
しかしながら，特定の~target要素を識別するために
`~URL参照を処理する＠~SVGlinking#processingURL-absolute$ときは、
~UAは常に，生成された絶対~URLを現在の文書~基底~URLと比較して、
それが`同一-文書~URL参照$かどうか決定するモノトスル。
この仕方により，同じ文書~内にある要素のみを参照する素片のみの~targetは、
文書~基底~URLに対するどの変更にも関わらず妥当であり続ける。
◎
Note that the base element will affect all URL values in the document, including e.g. paint server references or ‘use’ element references. However, when processing URL references to identify a specific target element, the user agent must always compare the generated absolute URL against the current document base URL to determine whether it is a same-document URL reference. In this way, target-fragment only references to elements in the same document remain valid, regardless of any changes to the document base URL.
</p>


	</section>
	<section id="ForeignNamespaces">
<h2 title="Foreign namespaces and private data">5.10. 外来の名前空間と私用~data</h2>

<p>
~SVGは、
~SVG内容の中のどこでも，外来の名前空間に属する要素の内包を許容する。
一般に，~SVG~UAは、［
外来の名前空間に属する未知な要素
］を［
~DOM内に含めた上で，描画~目的においては無視して除外する
］モノトスル。
◎
SVG allows inclusion of elements from foreign namespaces anywhere within the SVG content. In general, the SVG user agent must include the unknown foreign-namespaced elements in the DOM but will ignore and exclude them for rendering purposes.
</p>

<p>
注意すべき例外は、
`foreignObject$e 要素にて述べられる。
◎
The notable exceptions is described in the Embedded Content chapter under Embedding Foreign Object Types.
</p>

<p>
加えて，~SVGは、
どの~SVG要素にも，外来の名前空間に属する属性の内包を許容する。
~SVG~UAは、
未知な属性を~DOM内に含めるモノトスルが，他の~~点では無視するベキである。
◎
Additionally, SVG allows inclusion of attributes from foreign namespaces on any SVG element. The SVG user agent must include unknown attributes in the DOM but should otherwise ignore unknown attributes.
</p>

<div class="note">
<p>注記：
作者は、
未知な名前空間に属する［
要素／属性
］は，~HTML構文解析器などからは構文解析されないことに自覚するベキである。
代わりに，［
~tag／属性
］名に名前空間~接頭辞が含められる結果、
要素は親~要素の名前空間に属するように設置され，
属性は既定の名前空間に属するように設置されることになる。
◎
Authors should be aware that unknown namespaced elements and attributes will not be parsed as such by the HTML parser. Instead, the namespace prefix will be included in the tag or attribute name, elements will be placed in the parent element namespace and attributes in the default namespace.
</p>

<p>
~XML, ~HTML
両~文書に対し，構文解析した結果が整合な仕方で~custom属性を追加するためには、
作者は
<a href="#DataAttributes">`data-*^a 属性</a>
を利用してもヨイ。
これらは~SVG `metadata$e 要素に追加できる
— それが符号化する情報は、
文書~内の他のどの要素にも結付けられていない場合には。
◎
To add custom attributes in a way that will result in consistent parsing in both XML and HTML documents, authors may use the ‘data-*’ attributes. These can be added to SVG ‘metadata’ elements if the information they encode is not associated with any other element in the document.
</p>
</div>

<p>
~SVGの外来の名前空間を含む能は、
次に挙げる目的に利用できる：
◎
SVG's ability to include foreign namespaces can be used for the following purposes:
</p>

<ul>
	<li>
~appに特有な情報
— 著作~appは、
“往来用の” 目的
（すなわち，~fileを書き出してからまた読み戻しても，高~levelな情報は失わない能）
を~serveするためとして，~SVG内容~内に~model~levelの~dataを含めれる。
◎
Application-specific information so that authoring applications can include model-level data in the SVG content to serve their "roundtripping" purposes (i.e., the ability to write, then read a file without loss of higher-level information).
</li>
	<li>
拡張能~用の補足的~data。
例えば、
一定の~parameterに則って，
~2D~graphicを~3Dに成型するような拡張があるとする
— これらの~parameterは、
拡張の名前空間に属する要素に挿入することにより，
~SVG内容~内に含められてもヨイ。
◎
Supplemental data for extensibility. For example, suppose there is an extension which extrudes 2D graphics into three dimensions according to certain parameters; these parameters may be included in the SVG content by inserting elements from the extension's namespace.
</li>
</ul>

<p>
例えば業務用~graphic著作~appは、
~SVG文書の中に，何らかの私用~dataを含めたいと求めるかもしれない
— それをまた読み戻したときに，図表（この事例では~pie-chart）を適正に組み立て直せるよう：
◎
For example, a business graphics authoring application might want to include some private data within an SVG document so that it could properly reassemble the chart (a pie chart in this case) upon reading it back in:
</p>

<div class="example">

<pre class="lang-xml">
&lt;?xml version="1.0" standalone="yes"?&gt;
&lt;svg width="4in" height="3in"
     xmlns = 'http://www.w3.org/2000/svg'&gt;
  &lt;defs&gt;
    &lt;myapp:piechart xmlns:myapp="http://example.org/myapp"
                    title="Sales by Region"&gt;
      &lt;myapp:pieslice label="Northern Region" value="1.23"/&gt;
      &lt;myapp:pieslice label="Eastern Region" value="2.53"/&gt;
      &lt;myapp:pieslice label="Southern Region" value="3.89"/&gt;
      &lt;myapp:pieslice label="Western Region" value="2.04"/&gt;
      &lt;!-- <span class="comment">
他の私用~dataここに来る
◎
Other private data goes here
</span> --&gt;
    &lt;/myapp:piechart&gt;
  &lt;/defs&gt;
  &lt;desc&gt;<span class="comment">
この図表は、別の名前空間に属する私用~dataを含む
◎
This chart includes private data in another namespace
</span>&lt;/desc&gt;
  &lt;!-- <span class="comment">
ここには、~pie-chartを描く実際の~SVG~graphic要素がある
◎
In here would be the actual SVG graphics elements which draw the pie chart
</span> --&gt;
&lt;/svg&gt;
</pre>
</div>



	</section>
	<section id="CommonAttributes">
<h2 title="Common attributes">5.11. 共通な属性</h2>

		<section id="CommonAttributeDefinitions">
<h3 title="Definitions">5.11.1. 定義</h3>

<dl class="definitions">
	<dt>
`中核~属性@
（ `core attributes^en ）
</dt>
	<dd>
どの~SVG要素にも指定できる属性。
次に挙げるものは中核~属性とされる
⇒
`id$a,
`tabindex$a,
`autofocus$a,
`lang$a,
`~xml_space$a,
`class$a,
`style$a,
すべての`~custom~data属性＠#DataAttributes$
◎
The core attributes are those attributes that can be specified on any SVG element. The core attributes are ‘id’, ‘tabindex’, ‘autofocus’, ‘lang’, ‘xml:space’, ‘class’ and ‘style’, along with all custom data attributes.
</dd>
</dl>

		</section>
		<section id="Core.attrib">
<h3 title="Attributes common to all elements: ‘id’">5.11.2. すべての要素に共通な属性： `id^a</h3>

<p>
`id$a 属性は、
すべての~SVG要素に可用である：
◎
The ‘id’ attribute is available on all SVG elements:
</p>

<dl class="attrdef-list">
	<dt>
◎属名 `id@a
◎属値 （下を見よ）
◎属初 （ナシ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
id 	(see below) 	(none) 	no
</dt>
	<dd>
`要素の~ID$ `DOM$r を反映するモノトスル。
`id$a 属性の値は、
次をすべて満たさなければナラナイ
⇒＃
~node~treeの中で一意である ／
空~文字列でない ／
空白~文字を包含しない
◎
Must reflect the element's ID [DOM]. The ‘id’ attribute must be unique within the node tree, must not be an empty string, and must not contain any whitespace characters.
</dd>
	<dd>
`id$a 属性が~XML文書~内で妥当になるためには、
~XMLの関連な~version用の仕様に定義される追加的な要件が適用される。
自立的~SVG文書は、
~XML 1.0 構文 `xml$rを利用する
— それは、
~XML `Name$P ~tokenが妥当な `id$a 値であるものと指定する。
妥当な ~XML 1.0 名は、
指名された文字（普通字, 数字, 少数の約物）のみを含み, かつ
最初の文字は［
数字, `002E^U (.), `002D^U (-)
］でないものである。
◎
Additional requirements apply in order for the ‘id’ attribute to be valid in XML documents, as defined in the specification for the relevant version of XML. A stand-alone SVG document uses XML 1.0 syntax [xml], which specifies that valid ‘id’ values are XML name tokens. Valid XML 1.0 names only include designated characters (letters, digits, and a few punctuation marks), and do not start with a digit, a full stop (.) character, or a hyphen-minus (-) character.
</dd>
	<dd>
~UAは、
~SVG~file内の `id$a 値を，~XMLの妥当性を問わずに処理するベキである。
◎
User agents should process ‘id’ values in SVG files irrespective of XML validity.
</dd>
	<dd>
作者は、［
~URL~target素片として利用されたときは［
`~SVG~view指定$／
`基本的な~media素片~識別子＠~SVGlinking#MediaFragments$
］として構文解析されるもの
］には， `id$a 値の利用を避けるベキである。
◎
Authors should avoid the use of ‘id’ values that would be parsed as an SVG view specification or a basic media fragment when used as a URL target fragment.
</dd>
</dl>

		</section>
		<section id="LangSpaceAttrs">
<h3 title="The ‘lang’ and ‘xml:lang’ attributes">5.11.3. `lang^a ／ `xml:lang^a 属性</h3>

<p>
（名前空間に属さない） `lang^a 属性は、［
要素の内容, 要素の属性のうち~textを包含するもの
］用の首な言語を指定する。
◎
The ‘lang’ attribute (in no namespace) specifies the primary language for the element's contents and for any of the element's attributes that contain text.
</p>

<p>
~XML名前空間に属する `lang^a 属性は、
`xml$r にて定義される。
◎
The ‘lang’ attribute in the XML namespace is defined in XML [xml].
</p>

<p>
これらの属性が要素から省略された場合、
要素の言語は，親があれば 親の言語と同じになるとする。
◎
If these attributes are omitted from an element, then the language of this element is the same as the language of its parent element, if any.
</p>

<p>
~XML文書~内の~SVG要素には、
~XML名前空間に属する `lang^a 属性も利用されてもヨイ。
同じ要素に［
名前空間に属さない, ~XML名前空間に属する
］両 `lang^a 属性を指定する場合、
それらの値は~ASCII文字大小無視で合致しなければナラナイ。
◎
The ‘lang’ attribute in the XML namespace may be used on SVG elements in XML documents. If both the ‘lang’ attribute in no namespace and the ‘lang’ attribute in the XML namespace are specified on the same element, they must have exactly the same value when compared in an ASCII case-insensitive manner.
</p>

<p>
要素が［
名前空間に属さない, ~XML名前空間に属するそれ
］両 `lang^a 属性を有する場合、
~UAは
— 要素の言語を決定する目的においては —
前者は無視して，~XML名前空間に属する方を利用するモノトスル。
◎
If both the ‘lang’ attribute in no namespace and the ‘lang’ attribute in the XML namespace are set on an element, user agents must use the ‘lang’ attribute in the XML namespace, and the ‘lang’ attribute in no namespace must be ignored for the purposes of determining the element's language.
</p>

<dl class="attrdef-list">
	<dt>
◎属名 `lang@a
◎属値 `Language-Tag$P `ABNF^r
◎属初 （ナシ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
lang 	Language-Tag [ABNF] 	(none) 	no
</dt>
	<dd>
`lang^a 属性は［
要素の内容, 要素の属性のうち~textを包含するもの
］用の首な言語を指定する。
その値は［
妥当な `BCP47$r 言語~tag／空~文字列
］でなければナラナイ。
空~文字列は、
首な言語は未知であることを指示する。
◎
The ‘lang’ attribute specifies the primary language for the element's contents and for any of the element's attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown. [BCP47].
</dd>
</dl>

		</section>
		<section id="WhitespaceProcessingXMLSpaceAttribute">
<h3 title="The ‘xml:space’ attribute">5.11.4. `xml:space^a 属性</h3>

<div class="annotation svg2-requirement">

<p>
~SVG-2要件：
~text~layoutに影響する `xml:space^a の利用を非推奨にして，代わりに `white-space^p ~propを利用する。
◎
SVG 2 Requirement: Deprecate the use of ‘xml:space’ to affect text layout and use the ‘white-space’ property instead.
</p>

<ul>
	<li>
解決：
~SVG-2から `xml:space^a を落として，~SVG-11の~test一式から関係する~testを除去する
（`~~参照先＠http://www.w3.org/2011/03/03-svg-minutes.html#item04$）。
◎
Resolution: We drop xml:space from SVG 2 and remove the relating tests from the SVG 1.1. test suite.
</li>
	<li>
目的：
~CSSに揃える。
◎
Purpose: To align with CSS.
</li>
	<li>
Owner:
Chris (`3004$ACTION, done; and `3005$ACTION, done)
</li>
	<li>
`Status: done^en
</li>
</ul>
</div>
<dl class="attrdef-list">
	<dt>
◎属名 `~xml_space@a
◎属値 （下を見よ）
◎属初 `default^v
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
xml:space 	(see below) 	default 	no
</dt>
	<dd>
文字~data内の空白は保全されるかどうかを指定する。
この~XML属性は非推奨にされた。
アリな値は、
空白なしの文字列［
`default^v, `preserve^v
］に限られる。
`xml$r 勧告, ~SVGにおける`空白の取扱い＠~SVGtext#WhiteSpace$の論点を見よ。
◎
Deprecated XML attribute to specify whether white space is preserved in character data. The only possible values are the strings 'default' and 'preserve', without white space. Refer to the Extensible Markup Language (XML) 1.0 Recommendation [xml] and to the discussion white space handling in SVG.
</dd>
	<dd>
新たな内容は、
代わりに `white-space$p ~propを利用するベキである。
◎
New content should use the white-space property instead.
</dd>
</dl>

		</section>
		<section id="tabindexattribute">
<h3 title="The ‘tabindex’ attribute">5.11.5. `tabindex^a 属性</h3>

<dl class="attrdef-list">
	<dt>
◎属名 `tabindex@a
◎属値 `妥当な整数$ `HTML^r
◎属初 （ナシ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
tabindex 	valid integer [HTML] 	(none) 	no
</dt>
	<dd>
この内容~属性は、
次を制御することを作者に許容する
⇒＃
要素は~focus可能かどうか ／
`逐次的~focus~navi＠~SVGinteract#Focus$を利用して到達-可能と想定しているかどうか ／
逐次的~focus~naviの目的において 要素の相対~順序はどこになるか
◎
This content attribute allows authors to control whether an element is focusable, whether it is supposed to be reachable using sequential focus navigation, and what is to be the relative order of the element for the purposes of sequential focus navigation.
</dd>
	<dd class="note">注記：
“`tabindex^en” という名前は、
~focus可能な要素たちを順に~navigateしていくときに，
`tab^kbd ~Keyが共通的に利用されることに~~由来する。
【！＊省略：用語 "~tabbing" は逐次的~focus~naviを利用して到達できる~focus可能な要素を moving forward through を指す。】
◎
The name "tab index" comes from the common use of the "tab" key to navigate through the focusable elements. The term "tabbing" refers to moving forward through the focusable elements that can be reached using sequential focus navigation.
</dd>
</dl>

		</section>
		<section id="autofocusattribute">
<h3 title="The ‘autofocus’ attribute">5.11.6. `autofocus^a 属性</h3>

<dl class="attrdef-list">
	<dt>
◎属名 `autofocus@a
◎属値 `真偽-属性$ `HTML^r
◎属初 （ナシ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
autofocus 	boolean attribute [HTML] 	(none) 	no
</dt>
	<dd>
この内容~属性は、［
~focus可能な要素が，文書に接続された後に~focusされる
］よう依頼することを，作者に許容する。
詳細は、
~HTML仕様の `autofocus＠~HTMLinteraction#attr-fe-autofocus$a 属性を見よ。
◎
This content attribute allows authors to ask a focusable element to be focused after it's connected to a document. See autofocus in the HTML specification for details.
</dd>
	<dd class="note">注記：
要素が`~focus可能$でない間は、
この属性による効果は無い。
◎
The attribute has no effect if the element is not already focusable.
</dd>
</dl>

		</section>
		<section id="DataAttributes">
<h3 title="The ‘data-*’ attributes">5.11.7. `data-*^a 属性</h3>

<p>
すべての~SVG要素は、
`~custom~data属性＠~HTMLdom#custom-data-attribute$を~supportする。
それらは、どの名前空間にも属さず，名前は文字列 `data-^l から始まる。
~HTML仕様の
`~custom~data属性~用の要件＠~HTMLdom#embedding-custom-non-visible-data-with-the-data-*-attributes$
を見よ。
◎
All SVG elements support custom data attributes, which are those in no namespace whose names begin with the string "data-". See the requirements for custom data attributes in the HTML specification.
</p>

		</section>
	</section>
	<section id="WAIARIAAttributes">
<h2 title="WAI-ARIA attributes">5.12. ~WAI-ARIA属性</h2>

		<section id="WAIARIA-definitions">
<h3 title="Definitions">5.12.1. 定義</h3>

<dl class="definitions">
	<dt>
`~ARIA属性@
（ `ARIA attributes^en ）
</dt>
	<dd>
これらは，~WAI-ARIA
【 `Web Accessibility Initiative^en による `Accessible Rich Internet Applications^en 】
にて定義される属性であり、
一連の~WAI-ARIA~st_prop, および
`role^a 属性からなる。
次を見よ
⇒＃
`各種~roleの定義$（ ~WAI-ARIA ）,
`~graphics用の各種~role$（ ~WAI-ARIA Graphics Module ）,
`~supportされる~st_prop＠~TR/wai-aria/#states_and_properties$（ ~WAI-ARIA ）
◎
These are the attributes defined in WAI-ARIA, consisting of WAI-ARIA states and properties as well as the role attribute. See the WAI-ARIA Definition of Roles, the WAI-ARIA Graphics Module Graphics Roles, and the WAI-ARIA Supported States and Properties.＼
</dd>
	<dd>
次のものが~ARIA属性とされる
⇒
`aria-activedescendant$a,
`role$a,
`aria-autocomplete$a,
`aria-busy$a,
`aria-checked$a,
`aria-colcount$a,
`aria-colindex$a,
`aria-colspan$a,
`aria-controls$a,
`aria-current$a,
`aria-describedby$a,
`aria-details$a,
`aria-disabled$a,
`aria-dropeffect$a,
`aria-errormessage$a,
`aria-expanded$a,
`aria-flowto$a,
`aria-grabbed$a,
`aria-haspopup$a,
`aria-hidden$a,
`aria-invalid$a,
`aria-keyshortcuts$a,
`aria-label$a,
`aria-labelledby$a,
`aria-atomic$a,
`aria-live$a,
`aria-modal$a,
`aria-multiline$a,
`aria-multiselectable$a,
`aria-orientation$a,
`aria-owns$a,
`aria-valuetext$a,
`aria-level$a
◎
The aria attributes are ‘aria-activedescendant’, ‘role’, ‘aria-autocomplete’, ‘aria-busy’, ‘aria-checked’, ‘aria-colcount’, ‘aria-colindex’, ‘aria-colspan’, ‘aria-controls’, ‘aria-current’, ‘aria-describedby’, ‘aria-details’, ‘aria-disabled’, ‘aria-dropeffect’, ‘aria-errormessage’, ‘aria-expanded’, ‘aria-flowto’, ‘aria-grabbed’, ‘aria-haspopup’, ‘aria-hidden’, ‘aria-invalid’, ‘aria-keyshortcuts’, ‘aria-label’, ‘aria-labelledby’, ‘aria-atomic’, ‘aria-live’, ‘aria-modal’, ‘aria-multiline’, ‘aria-multiselectable’, ‘aria-orientation’, ‘aria-owns’’, ‘aria-valuetext’ and ‘aria-level’.
</dd>
</dl>

<p class="note">注記：
将来の~WAI-ARIA仕様は、
上の~ARIA属性の~listを拡げ得ることに注意。
◎
Note that the above list of ARIA attributes may be expanded by future WAI-ARIA specifications.
</p>

		</section>
		<section id="roleattribute">
<h3 title="Role attribute">5.12.2. `role^a 属性</h3>


<p>
~ARIA `role^a 属性は、
どの`描画-可能な要素$に指定されてもヨイ。
`描画されない要素$上の `role^a 属性は無視される。
属性に指定する値は、
`~space等で分離された~token集合$であって，それを成す各~tokenは，要素が属する様々な~WAI-ARIA~roleを表現していなければナラナイ。
これらの~tokenは［
`各種~roleの定義$ `wai-aria$r,
`~graphics用の各種~role$ `graphics-aria-1.0$r
］にて定義される~role値を与える。
◎
Any renderable element may have an ARIA role attribute specified; the role attribute is ignored on non-rendered elements. The attribute, if specified, must have a value that is a set of space-separated tokens representing the various WAI-ARIA roles that the element belongs to. These tokens are role values defined in Definition of Roles ([wai-aria], section 5.4) and Graphics Roles ([graphics-aria-1.0], section 4).
</p>

<p>
~SVG要素にアテガわれる~WAI-ARIA~roleは、［
要素が `role^a 属性を有していて，
その値を空白で分割した結果を成す~tokenの~list内に妥当な~roleが見出される
］ならば，それらのうち最初のもの とする。
妥当な~roleは、
次を満たす~roleとする
⇒
［
~UAが認識できる
］~AND［
抽象-~roleでない
］~AND［
当の`要素~型に許容される＠#implicit-aria-semantics$
］
◎
The WAI-ARIA role that an SVG element has assigned to it is the first valid role found in the list of tokens generated when the role attribute is split on spaces. A valid role is a recognized, non-abstract role that is allowed for the element type.
</p>

<dl class="attrdef-list">
	<dt>
◎属名 `role@a
◎属値 `~space等で分離された~token集合$ `HTML^r
◎属初 （下を見よ）
◎属ア 不可
◎表終
◎
Name 	Value 	Initial value 	Animatable
role 	set of space-separated tokens [HTML] 	(see below) 	no
</dt>
	<dd>
`role$a 属性の値は、
`~space等で分離された~token集合$であって，
それを成す各~tokenは［
`wai-aria$r による`各種~roleの定義$
］にて定義されるものでなければナラナイ。
◎
The ‘role’ attribute must be a set of space-separated tokens having values defined in Definition of Roles ([wai-aria], section 5.4).
</dd>
	<dd>
値を成す各~tokenは、［
機械実行可能な意味論上の情報
］を与え，当の要素の目的を定義するために利用される。
◎
The role value is a set of white-space separated machine-extractable semantic information used to define the purpose of the element.
</dd>
	<dd>
`role$a 属性~用の`初期~値$は、
各~SVG要素~型に定義され，
`~SVG要素~用の暗黙の~ARIA意味論＠#implicit-aria-semantics$にて与える対応する既定の値とする。
◎
The initial value for the ‘role’ attribute, for each SVG element, is the corresponding default implied ARIA semantic for SVG elements.
</dd>
</dl>

<p>
多くの要素~roleは、
妥当かつ有用になるためには［
~access可能な名前 ／
明示的な`~st_prop値＠#ARIAStateandPropertyAttributes$
］の形で，追加的な情報を供することが要求される。
~access可能な名前は、［
`記述的~要素$ ／ `~ARIA属性$
］を利用して供されてもヨイ。
各~role用の要件は、
当の~roleが定義される箇所
— 例：
`各種~roleの定義$ `WAI-ARIA$r,
`~graphics用の各種~role$ `graphics-aria-1.0$r
— にて指示される。
◎
To be valid and useful, many element roles require additional information to be provided in the form of an accessible name or explicit state and property values. Accessible names may be provided using SVG descriptive elements or ARIA attributes. The requirements for each role are indicated where the role is defined, e.g., in WAI-ARIA ([WAI-ARIA]) or the WAI-ARIA Graphics Module ([graphics-aria-1.0]).
</p>

		</section>
		<section id="ARIAStateandPropertyAttributes">
<h3 title="State and property attributes (all aria- attributes)">5.12.3. ~st_prop属性（すべての `aria-*^a 属性）</h3>

<p>
~WAI-ARIA~st_prop属性は、
どの~SVG要素に指定されてもヨイ。
これらの属性は、
~ARIAによる`~st_propの定義（すべての `aria-*^a 属性）＠~ARIA11#state_prop_def$にて定義される。
`wai-aria$r
◎
WAI-ARIA state and property attributes may be specified on SVG elements. These attributes are defined by ARIA in Definitions of States and Properties (all aria-* attributes) ([wai-aria], section 6.6).
</p>

<p>
これらの属性に指定する値は、
次を満たさなければナラナイ
⇒
当の~st_prop用の定義を成す “値（ `Value^en ）” 欄に与えられる~WAI-ARIA値~型であって，
`~WAI-ARIA値~型から言語への対応付け＠~ARIA11#typemapping$ `wai-aria$r
に則って，~SVG対応付けを利用して適切な~SVG値~型に対応付けられる
◎
These attributes, if specified, must have a value that is the WAI-ARIA value type in the "Value" field of the definition for the state or property, mapped to the appropriate SVG value type according to Mapping WAI-ARIA Value types to languages using the SVG mapping ([wai-aria], section 10.2).
</p>

<p>
各~属性は~animate可能とする。
~animationが，~graphicの［
状態を変更する／
内容を正しい代替~text記述を改めるような仕方で変更する
］ために利用された場合、
対応している~ARIA~st_prop属性を更新するのと同じ~animationの手法【？】が利用されるベキである。
◎
The attributes are animatable; if animation is used to change the state of the graphic, or to change its content in a way that alters the correct alternative text description, the same method of animation should be used to update the corresponding ARIA state or property attribute.
</p>

<p>
~WAI-ARIA~st_prop属性は、
どの要素~上でも利用できる。
それらは，常に有意義になるとは限らないが、
そのような事例では，~UAは それらを~DOM内に含める他に何ら処理を遂行しないであろう。
~st_prop属性は、
`ARIA＠~ARIA11$cite `wai-aria$r,
`SVG Accessibility API Mappings＠~TR/svg-aam-1.0/$cite `svg-aam-1.0$r
仕様に則って処理される。
◎
WAI-ARIA State and Property attributes can be used on any element. They are not always meaningful, however, and in such cases user agents might not perform any processing aside from including them in the DOM. State and property attributes are processed according to the ARIA and SVG Accessibility API Mappings specification specifications. [wai-aria] [svg-aam-1.0]
</p>

		</section>
		<section id="implicit-aria-semantics">
<h3 title="Implicit and Allowed ARIA Semantics">5.12.4. 暗黙的に許容される~ARIA意味論</h3>

<p>
この節では、
`各種~SVG要素~型＠~SVGeltindex$に適用される
`既定の暗黙的な~ARIA意味論^
— 要素が含意する~ARIA意味論（~role ／ 状態 ／ ~prop） —
および，各~要素~型にどの~WAI-ARIA意味論が適用されてもヨイかについての制約を定義する。
◎
The following table defines the default implicit ARIA semantics that apply to SVG elements. Each language feature (element) in a cell in the first column implies the ARIA semantics (role, states, and/or properties) given in the cell in the second column of the same row. The third column defines restrictions as to what WAI-ARIA semantic (role, state, or property) may or may not apply.
</p>

<p>
多くの~graphics要素は、
その暗黙的な~roleは［
作者が意味論上の重要度を指示する情報を供する
］場合に限りアテガわれる。
~accessibility~tree用の完全な~UA用の
`内包~判定基準@
は、
`svg-aam-1.0$r に定義される。
作者~用の［
意味論上の重要度を指示する手段
］としては、
要素~用に~access可能な名前を供することが選好される。
これは［
子 `title$e 要素 ／ `aria-label$a 属性／ `aria-labelledby$a 属性
］通して行える。
作者は、［
~SVGを読み解くために本質的な，どの内容
］にも，これらいずれかの手法を利用して~access可能な名前を供するベキである
— とりわけ、対話的~内容には。
◎
For many graphics elements, an implicit role is only assigned if the author provides information that indicates semantic importance. The complete inclusion criteria for the accessibility tree are defined by the SVG Accessibility API Mappings specification for user agents [svg-aam-1.0]. For authors, the preferred means of indicating semantic importance is to provide an accessible name for the element. This can be done through a direct child ‘title’ element, or through the ‘aria-label’ or ‘aria-labelledby’ attributes. Authors should use one of these methods to provide an accessible name for any content that is essential to the comprehension of the SVG, and especially for any interactive content.
</p>

<p class="trans-note">【
この訳では、
原文の表の形による要素ごとの一覧に代えて，
同類の~ARIA意味論が定義される要素を集約した形で記述する。
】</p>
<!-- 
表~内に単独で現れる "`none^role" は、原文では~markupされていない
— ~roleとしての `none$role ではなく “無い” ことを意味する一般語かもしれない。
-->

<div>

<ul>
	<li>
<p>
次に挙げる要素に対しては、
既定の暗黙の~ARIA意味論は `none^role であり，他に許容される~roleは無い：
</p>
		<ul>
			<li>
`決して描画されない要素$（ `symbol$e 以外）
⇒
`clipPath$e,
`defs$e,
`desc$e,
`linearGradient$e,
`marker$e,
`mask$e,
`metadata$e,
`pattern$e,
`radialGradient$e,
`script$e,
`style$e,
`title$e
</li>
			<li>
~filter用の要素
⇒
`feBlend$e,
`feColorMatrix$e,
`feComponentTransfer$e,
`feComposite$e,
`feConvolveMatrix$e,
`feDiffuseLighting$e,
`feDisplacementMap$e,
`feDistantLight$e,
`feDropShadow$e,
`feFlood$e,
`feFuncA$e,
`feFuncB$e,
`feFuncG$e,
`feFuncR$e,
`feGaussianBlur$e,
`feImage$e,
`feMerge$e,
`feMergeNode$e,
`feMorphology$e,
`feOffset$e,
`fePointLight$e,
`feSpecularLighting$e,
`feSpotLight$e,
`feTile$e,
`feTurbulence$e,
`filter$e
</li>
			<li>
`mpath$e, `stop$e, `switch$e, `view$e
</li>
		</ul>
	</li>
	<li>
次に挙げる要素（`図形~要素$）に対しては、
既定の暗黙の~ARIA意味論は［
要素は`内包~判定基準$を満たすならば `graphics-symbol$role ~role ／
~ELSE_ `none$role
］とする。
これらに適用されてヨイ~roleには、制約はない。
⇒
`ellipse$e,
`circle$e,
`line$e,
`polygon$e,
`polyline$e,
`rect$e,
`path$e
</li>
	<li>
次に挙げる要素に対しては、
既定の暗黙の~ARIA意味論は［
要素は`内包~判定基準$を満たすならば `group$role ~role ／
~ELSE_ `none$role
］とする。
これらに適用されてヨイ~roleには、制約はない
⇒
`foreignObject$e,
`g$e,
`textPath$e,
`tspan$e
</li>
	<li>
<p>
他の要素の既定の暗黙の~ARIA意味論は、
次の表に与えられる。
これらの要素に適用されてヨイ~roleには、制約はない：
</p>

<table id="table-aria-implicit">
<thead><tr><th>要素
<th>既定の暗黙の~ARIA意味論
</thead><tbody>

<tr><td>`a$e
<td>
要素は妥当な［
`href^a ／ `xlink:href^a
］属性を有するならば `link$role ~role。
~linkでない `a^e 要素~用の既定の意味論は、［
`a^e 要素は `text$e の子孫ならば `tspan$e ／
~ELSE_ `g$e 
］と同じ規則に従う。

<tr><td>`image$e
<td>`img$role ~role

<tr><td>`svg$e
<td>`graphics-document$role ~role

<tr><td>`symbol$e
<td>
要素は ある描画される`要素~instance$であって
`内包~判定基準$を満たすならば `graphics-object$role ~role ／
~ELSE_ `none$role

<tr><td>`text$e
<td>
`group$role ~role
— ［
`~SVG~accessibility~APIの対応付け＠https://w3c.github.io/svg-aam/#details-id-69$
にて定義される，~platformに特有な~role対応付け
］を伴う。

<tr><td>`use$e
<td>
要素は`内包~判定基準$を満たすならば `graphics-object$role ~role ／
~ELSE_ `none$role

</tbody></table>
	</li>
</ul>

◎
Language feature
• Default implied ARIA semantics
• Allowed roles

‘a’
• link role if the element has a valid href or xlink:href attribute. For a elements that are not links, the default semantics are the same as tspan if the a element is a descendent of text, or the same as g otherwise.
• no restrictions

‘circle’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘clipPath’
• none
• no role may be applied

‘defs’
• none
• no role may be applied

‘desc’
• none
• no role may be applied

‘ellipse’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘feBlend’
• none
• no role may be applied

‘feColorMatrix’
• none
• no role may be applied

‘feComponentTransfer’
• none
• no role may be applied

‘feComposite’
• none
• no role may be applied

‘feConvolveMatrix’
• none
• no role may be applied

‘feDiffuseLighting’
• none
• no role may be applied

‘feDisplacementMap’
• none
• no role may be applied

‘feDistantLight’
• none
• no role may be applied

‘feDropShadow’
• none
• no role may be applied

‘feFlood’
• none
• no role may be applied

‘feFuncA’
• none
• no role may be applied

‘feFuncB’
• none
• no role may be applied

‘feFuncG’
• none
• no role may be applied

‘feFuncR’
• none
• no role may be applied

‘feGaussianBlur’
• none
• no role may be applied

‘feImage’
• none
• no role may be applied

‘feMerge’
• none
• no role may be applied

‘feMergeNode’
• none
• no role may be applied

‘feMorphology’
• none
• no role may be applied

‘feOffset’
• none
• no role may be applied

‘fePointLight’
• none
• no role may be applied

‘feSpecularLighting’
• none
• no role may be applied

‘feSpotLight’
• none
• no role may be applied

‘feTile’
• none
• no role may be applied

‘feTurbulence’
• none
• no role may be applied

‘filter’
• none
• no role may be applied

‘foreignObject’
• group role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘g’
• group role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘image’
• img role
• no restrictions

‘line’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘linearGradient’
• none
• no role may be applied

‘marker’
• none
• no role may be applied

‘mask’
• none
• no role may be applied

‘metadata’
• none
• no role may be applied

‘mpath’
• none
• no role may be applied

‘path’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘pattern’
• none
• no role may be applied

‘polygon’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘polyline’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘radialGradient’
• none
• no role may be applied

‘rect’
• graphics-symbol role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘script’
• none
• no role may be applied

‘stop’
• none
• no role may be applied

‘style’
• none
• no role may be applied

‘svg’
• graphics-document role
• no restrictions

‘switch’
• none
• no role may be applied

‘symbol’
• graphics-object role if the element is a rendered element instance that meets the inclusion criteria, otherwise none
• no restrictions

‘text’
• grouprole, with platform-specific role mappings, as defined in the SVG Accessibility API Mappings specification
• no restrictions

‘textPath’
• group role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘title’
• none
• no role may be applied

‘tspan’
• group role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘use’
• graphics-object role if the element meets the inclusion criteria, otherwise none
• no restrictions

‘view’
• none
• no role may be applied
</div>



		</section>
	</section>
	<section id="DOMInterfaces">
<h2 title="DOM interfaces">5.13. ~DOM~interface</h2>

		<section id="InterfaceDocumentExtensions">
<h3 title="Extensions to the Document interface">5.13.1. `Document^I ~interfaceに対する拡張</h3>
<!-- `SVGDocument^I0 -->

<p>
~DOM中核~仕様は `Document$I ~interfaceを定義する。
この仕様はそれを拡張する。
◎
The DOM Core specification defines a Document interface, which this specification extends.
</p>

<p class="note">注記：
~SVG文書が参照により埋込まれる事例では
— 例えば、
~HTML文書に `object^e 要素が在って，
その `data^a 属性は ある~SVG文書
（すなわち、文書~MIME型は `image/svg+xml^l で，根~要素は `svg$e 要素であるもの）
を参照する場合など —
別個な~DOM階層が 2 つ存在することになる：
1 つは参照元の文書~用のそれ（例： ある~XHTML文書），もう 1 つは参照先の~SVG文書~用のそれ。
◎
In the case where an SVG document is embedded by reference, such as when an HTML document has an ‘object’ element whose ‘data’ attribute references an SVG document (i.e., a document whose MIME type is "image/svg+xml" and whose root element is thus an ‘svg’ element), there will exist two distinct DOM hierarchies. The first DOM hierarchy will be for the referencing document (e.g., an XHTML document). The second DOM hierarchy will be for the referenced SVG document.
</p>

<pre class="idl">
partial interface `Document$I {
  readonly attribute `SVGSVGElement$I? `rootElement$m;
};
</pre>


<dl class="idl-def">
	<dt>`rootElement@m</dt>
	<dd>
根 `svg$e 要素を表現する。
◎
The rootElement IDL attribute represents the root ‘svg’ element.＼
</dd>
	<dd class="algo">
その取得子~手続きは
⇒
~RET ［
コレの根~要素は `svg$e 要素であるならば それ ／
~ELSE_ ~NULL
］
◎
On getting rootElement, the root element of the document is returned, if it is an ‘svg’ element, or null otherwise.
</dd>
	<dd class="note">注記：
この属性は、非推奨にされた。
将来の~SVG仕様からは除去され得る。
作者は代わりに `Document$I 上の `documentElement$n 属性を利用することが奨励される。
◎
This attribute is deprecated, and may be removed in a future SVG specification. Authors are encouraged to use the documentElement attribute on Document instead.
</dd>
</dl>

【！<p class="issue">Data point: `UseCounter in blink＠https://www.chromestatus.com/metrics/feature/timeline/popularity/251$ shows ~0.010.</p>】

<p>
~HTMLを実装する~SVG実装は、
<a href="~HTMLdom#the-document-object">`Document^I ~interfaceに対する~HTML拡張</a>
を~supportするモノトスル。
他の~SVG実装は、
次の~IDL素片を~supportするモノトスル：
◎
SVG implementations that implement HTML must support the HTML extensions to the document interface. Other SVG implementations must support the following IDL fragment.
</p>

<pre class="idl extract">
/* <span class="comment">
一定の実装に限り，実装するモノトスル。
◎
must only be implemented in certain implementations
</span> */
partial interface `Document$I {
  readonly attribute DOMString title;
  readonly attribute DOMString referrer;
  readonly attribute DOMString domain;
  readonly attribute Element? `activeElement$m;
};
</pre>

<dl class="idl-def">
	<dt>`title^m</dt>
	<dt>`referrer^m</dt>
	<dt>`domain^m</dt>
	<dt>`activeElement@m</dt>
	<dd>
これらの~IDL属性は、
~HTMLが定義する`~~同名の~IDL属性＠~HTMLdom#the-document-object$と同じに挙動するモノトスル。
◎
The title, referrer, domain and activeElement IDL attributes must behave the same as the corresponding IDL attributes defined in HTML.
</dd>
</dl>

		</section>
		<section id="InterfaceSVGSVGElement">
<h3 title="Interface SVGSVGElement">5.13.2. ~interface `SVGSVGElement^I0</h3>


<p>
`SVGSVGElement$I ~objは、
~DOM内で `svg$e 要素を表現する。
`SVGSVGElement$I ~interfaceは、
~data型~obj~factory~methodなどの
諸々の~utility~methodも包含する。
◎
An SVGSVGElement object represents an ‘svg’ element in the DOM. The SVGSVGElement interface also contains miscellaneous utility methods, such as data type object factory methods.
</p>

<p>
各 `SVGSVGElement$I ~objは、
`現在の並進-点~obj@
と呼ばれる `DOMPoint$I ~objを内部に保守する。
それは `currentTranslate$m ~IDL属性から返される。
◎
An SVGSVGElement object maintains an internal DOMPoint object, called its current translate point object, which is the object returned from the currentTranslate IDL attribute.
</p>


<pre class="idl">
[Exposed=Window]
interface `SVGSVGElement^Ix : `SVGGraphicsElement$I {

  [SameObject] readonly attribute `SVGAnimatedLength$I `x$m;
  [SameObject] readonly attribute `SVGAnimatedLength$I `y$m;
  [SameObject] readonly attribute `SVGAnimatedLength$I `width$m;
  [SameObject] readonly attribute `SVGAnimatedLength$I `height$m;

  attribute float `currentScale$m;
  [SameObject] readonly attribute `DOMPointReadOnly$I `currentTranslate$m;

  `NodeList$I `getIntersectionList$m(`DOMRectReadOnly$I %rect, `SVGElement$I? %referenceElement);
  `NodeList$I `getEnclosureList$m(`DOMRectReadOnly$I %rect, `SVGElement$I? %referenceElement);
  boolean `checkIntersection$m(`SVGElement$I %element, `DOMRectReadOnly$I %rect);
  boolean `checkEnclosure$m(`SVGElement$I %element, `DOMRectReadOnly$I %rect);

  undefined `deselectAll$m();

  `SVGNumber$I `createSVGNumber$m();
  `SVGLength$I `createSVGLength$m();
  `SVGAngle$I `createSVGAngle$m();
  `DOMPoint$I `createSVGPoint$m();
  `DOMMatrix$I `createSVGMatrix$m();
  `DOMRect$I `createSVGRect$m();
  `SVGTransform$I `createSVGTransform$m();
  `SVGTransform$I `createSVGTransformFromMatrix$m(optional `DOMMatrix2DInit$I %matrix);
  `Element$I `getElementById$m(DOMString %elementId);

  /* <span class="comment">
非推奨にされ，~callされても効果は無い~methodであるが、
互換性の理由から保たれている。
◎
Deprecated methods that have no effect when called, but which are kept for compatibility reasons.
</span> */
  unsigned long `suspendRedraw$m(unsigned long %maxWaitMilliseconds);
  undefined `unsuspendRedraw$m(unsigned long %suspendHandleID);
  undefined `unsuspendRedrawAll$m();
  undefined `forceRedraw$m();
};

`SVGSVGElement$I includes `SVGFitToViewBox$I;
`SVGSVGElement$I includes `WindowEventHandlers$I;
</pre>

<dl class="idl-def">
	<dt>`x@m</dt>
	<dt>`y@m</dt>
	<dt>`width@m</dt>
	<dt>`height@m</dt>
	<dd>
これらは順に，コレ上の［
`x$p, `y$p, `width$p, `height$p
］~propの算出d値, それぞれに対応する呈示~属性を`反映する$。
◎
The x, y, width and height IDL attributes reflect the computed values of the x, y, width and height properties and their corresponding presentation attributes, respectively.
</dd>

	<dt>`currentScale@m</dt>
	<dd>
この属性と `currentTranslate$m ~IDL属性は、
~SVGに適用される追加的な変形を表現する。
これらは、`~SVG文書片$の`最外縁の~svg要素$に限り効果がある。
◎
The currentScale and currentTranslate IDL attributes represent an additional transform applied to the SVG. They only have an effect on the outermost svg element of an SVG document fragment.
</dd>
	<dd>
文書の~zoom_pan変形は、
次の形の~2x3行列になる：
[ `currentScale^m 0 0 `currentScale^m `currentTranslate.x^c `currentTranslate.y^c]
。
`transform$p ~propの値は、［
`currentScale$m ／ `currentTranslate$m
］には影響しない。
◎
The document's magnification and panning transform is a 2x3 matrix of the form [currentScale 0 0 currentScale currentTranslate.x currentTranslate.y]. The value of the ‘transform’ property does not affect currentScale or currentTranslate.
</dd>
	<dd class="note">注記：
これまでの~versionの~SVGは、
既定では［
利用者が~graphicの拡縮-（~zoom）や並進-（~pan）を設定するための制御を実装する
］よう，~UAに推奨していた。
これらの利用者~動作による変形nは
`currentScale^m, `currentTranslate^m
の値に`反映されることになる^em。
これらの利用者~制御は、
きちんと実装されておらず，もはや推奨されない。
しかしながら，作者は、
~UAがこれらの値を更新し得ることに自覚するベキである。
◎
Previous versions of SVG recommended that user agents implement controls, by default, for the user to set the scale (zoom) and translate (pan) of the graphic. Transformations from these user actions would be reflected in the values of currentScale and currentTranslate. These user controls were not well implemented, and are no longer recommended. However, authors should be aware that the user agent may update these values.
</dd>
	<dd class="note">注記：
最外縁の~svg要素に対する廃用にされた属性 `zoomAndPan="disable"^a は、
~UAによる利用者~動作に基づく値の操作を不能化するベキであるが，一部の~UAにおいて求まれない副作用があるかもしれない。
◎
The obsolete attribute zoomAndPan="disable", on the outermost SVG element, should disable any user agent manipulation of the values based on user action, but may have unwanted side effects in some user agents.
</dd>
	<dd class="issue">
［
`currentScale^m ／ `currentTranslate^m
］と文書の根を変形する他の仕方（ `transform^a ／`~SVG~view指定$）との相互作用は、
拙くしか定義されていない。
`360$issue を見よ。
◎
The interaction of currentScale and currentTranslate with other ways of transforming the document root (transforms and SVG views) is poorly defined. See the GitHub issue for more.
</dd>
	<dd class="algo">
<p>
その取得子~手続きは：
◎
On getting currentScale, the following steps are run:
</p>
		<ol>
			<li>
~IF［
コレは`最外縁の~svg要素$でない
］
⇒
~RET 1
◎
If the current ‘svg’ element is not the outermost svg element, then return 1.
</li>
			<li>
[ %a 0 0 %a %e %f ] ~LET
文書の~zoom_pan変形を表現する~2x3行列
◎
Let [a b c d e f] be the 2x3 matrix that represents the document's magnification and panning transform.
</li>
			<li>
~RET %a
◎
Return a.
</li>
		</ol>
	</dd>
	<dd class="algo">
<p>
その設定子~手続きは：
◎
On setting currentScale, the following steps are run:
</p>
		<ol>
			<li>
~IF［
コレは`最外縁の~svg要素$でない
］
⇒
~RET
◎
If the current ‘svg’ element is not the outermost svg element, then return.
</li>
			<li>
%scale ~LET 所与の値
◎
Let scale be the value being assigned to currentScale.
</li>
			<li>
[ %a 0 0 %a %e %f ] ~LET 文書の~zoom_pan変形を表現する~2x3行列
◎
Let [a b c d e f] be the 2x3 matrix that represents the document's magnification and panning transform.
</li>
			<li>
文書の~zoom_pan変形 ~SET [ %scale 0 0 %scale %e %f ]
が表現する変形
◎
Set the document's magnification and panning transform to [scale 0 0 scale e f].
</li>
		</ol>
	</dd>

	<dt>`currentTranslate@m</dt>
	<dd>
この~objは、
コレ用の現在の並進を表現する【！~SVGshapes#PointMode】
◎
↓</dd>
	<dd class="algo">
その取得子~手続きは、
コレの`現在の並進-点~obj$を返す。
`現在の並進-点~obj$は、
コレは`最外縁の~svg要素$でない場合には，`読専~flag$は ~T にするモノトスル。
◎
On getting currentTranslate, the SVGSVGElement object's current translate point object is returned. This object represents the current translation for the ‘svg’ element. A current translate point object must be read only when its ‘svg’ element is not the outermost svg element, and writable otherwise.
</dd>
	<dd class="note">注記：
`現在の並進-点~obj$を改変すると文書の~zoom_pan変形にどう影響するかについては、
<a href="~SVGshapes#AssignToDOMPoint">`DOMPoint^I に値をアテガうときの規則</a>
を見よ。
◎
See the rules for assigning to a DOMPoint for how modifying the current translate point object affects the document's magnification and panning transform.
</dd>
	<dd class="trans-note">【
この属性の型は `DOMPointReadOnly$I とされているが、
改変-可能な `DOMPoint$I を返すことになる
（加えて、現在の実装は `DOMPoint^I の別名である `SVGPoint^I を返している）。
】</dd>
</dl>

<div class="algo">
<p>
［
利用者~対話により文書の~zoom_pan変形が変更された ／ 
`最外縁の~svg要素$が変更された
］ときは、
それに呼応して，次の手続きを走らす：
◎
Whenever the document's magnification and panning transform changes in response to user interaction or whenever the outermost svg element changes, the following steps are run:
</p>

<ol>
	<li>
[ %a 0 0 %a %e %f ] ~LET 
文書の~zoom_pan変形を表現する~2x3行列
◎
Let [a b c d e f] be the 2x3 matrix that represents the document's magnification and panning transform.
</li>
	<li>
%element ~LET `最外縁の~svg要素$
◎
Let element be the outermost svg element.
</li>
	<li>
%element の`現在の並進-点~obj$の ( x 座標, y 座標 ) ~SET ( %e, %f )
◎
Update the x and y components of element's current translate point object to e and f, respectively.
</li>
</ol>

<p class="note">注記：
`最外縁の~svg要素$が変更したときに，この手続きを走らすことで、
次が確保されることになる：
文書~要素が異なる `svg$e 要素に置換された場合には、
その `currentTranslate$m は［
文書の~zoom_pan変形を成す並進~成分を反映する
］よう即時に更新されることになる。
◎
Running these steps when the outermost svg element changes will ensure that if the document element is replaced with a different ‘svg’ element, that its currentTranslate will be immediately updated to reflect the translation component of the document's magnification and panning transform.
</p>
</div>

<div class="algo">
<p>
`svg$e 要素が`最外縁の~svg要素$でなくなったときは、
その`現在の並進-点~obj$の
( x 座標, y 座標 ) とも 0 に設定するモノトスル。
◎
Whenever an ‘svg’ element is no longer outermost svg element, the x and y components of its current translate point object must be set to 0.
</p>
</div>

<dl class="idl-def">
	<dt>`suspendRedraw()@m</dt>
	<dt>`unsuspendRedraw()@m</dt>
	<dt>`unsuspendRedrawAll()@m</dt>
	<dt>`forceRedraw()@m</dt>
	<dd>
これらの~methodは、
どれも非推奨にされ，その効果は無いものと定義される。
</dd>
	<dd class="algo">
`suspendRedraw()^m ~method~手続きは、
1 を返す。
他の~method~手続きは、
何もしない。
◎
The suspendRedraw, unsuspendRedraw, unsuspendRedrawAll and forceRedraw methods are all deprecated and defined to have no effect. When the suspendRedraw method is called, it must return 1.
</dd>
</dl>


<p>
［
`getIntersectionList()$m,
`getEnclosureList()$m,
`checkIntersection()$m,
`checkEnclosure()$m
］~methodは、
`~graphics要素$上で，
その~graphicな内容が所与の矩形の中に部分的にまたは完全に入るかどうか見出す（または検査する）ための幾何~演算を遂行するために利用される。
◎
The getIntersectionList, getEnclosureList, checkIntersection and checkEnclosure methods are used to perform geometry operations on graphics elements to find those whose (or check whether their) graphical content lies partially or completely within a given rectangle.
</p>

<div class="algo">
<p>
`矩形に入る子孫を見出す@
ときは、所与の
( 要素 %要素, 矩形 %矩形, %封入d~flag ~IN { `全部的^i, `部分的^i }, %座標系 （省略時は %要素 の座標系 ） )
に対し，次の手続きを走らす：
◎
To find the intersecting or enclosed descendants of a given element element with a given rectangle rectangle using ancestor as the element in whose coordinate space rectangle is to be interpreted, the following steps are run:
</p>

<p class="note">
%要素 は~~探索する下位treeの根を与える。
%封入d~flag は見出す子孫を 全部的に %矩形 に入るものに限るかどうかを与える。
%座標系 は %矩形 をどの要素の座標~空間で解釈するかを与える
（この~algoは自身を再帰的に呼出すが、その間 %矩形, %座標系 は同じであり続ける）。
◎
↑</p>

<ol>
	<li>
%結果 ~LET 空~list
◎
Let result be an initially empty list.
</li>
	<li>
~IF［
%要素 は表示されていない（
`display$p 値は `none^v であるか，
`条件付き処理~属性$が `偽^i に評価されたこと因り）
］
⇒
~RET %結果
◎
If element is not displayed, due to having a display value of none or being in a subtree that has failing conditional processing attributes or a failing branch of a ‘switch’, then return result.
</li>
	<li>
<p>
%要素 の
~EACH( 子~要素 %子 )
に対し，文書~順序で：
◎
For each child element child of element, in document order:
</p>
		<ol>
			<li>
<p>
~IF［
%子 は［
`svg$e ／ `g$e
］要素である
］：
◎
If child is an ‘svg’ or ‘g’ element, then:
</p>
				<ol>
					<li>
%子孫たち ~LET `矩形に入る子孫を見出す$( %子, %矩形, %封入d~flag, %座標系 )
◎
Let descendants be the result of finding the intersecting (or enclosed) descendants of child with rectangle in ancestor's coordinate space.
</li>
					<li>
%結果 に %子孫たち を成すすべての要素を付加する
◎
Append to result all the elements of descendants.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%子 は `use$e 要素である
］：
◎
Otherwise, if child is a ‘use’ element, then:
</p>
				<ol>
					<li>
%子孫たち ~LET `矩形に入る子孫を見出す$( %子 の~shadow~treeの根, %矩形, %封入d~flag, %座標系 )
◎
Let root be the root of the child's shadow tree.
◎
Let descendants be the result of finding the intersecting (or enclosed) descendants of root with rectangle in ancestor's coordinate space.
</li>
					<li>
<p>
~IF［
%子孫たち は空でない
］
⇒
%結果 に %子 を付加する
◎
If descendants is not empty, then append child to result.
</p>

<p class="note">注記：
ここでは，`~use要素の~shadow~tree$内の要素を探しているが、
その結果（`要素~instance$たち）は~~無視して，
`use$e 要素のみ %結果 ~listに加える。
◎
This means that although we look at the elements in the use-element shadow tree, we don't place the element instances or their corresponding element in the result list; only the ‘use’ element itself is returned.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
%子 は`~graphics要素$である
］：
◎
Otherwise, if child is a graphics element, then:
</p>
				<ol>
					<li>
%領域 ~LET ［
%子 の座標系における`接触判定$に感応する図形（ %子 の `pointer-events$p 値を解釈する規則も織り込む）
］を %座標系 における領域に変形した結果
◎
Let region be the shape in child's coordinate system that is sensitive to hit detection, taking into account the rules for interpreting child's pointer-events value.
◎
Transform region into ancestor's coordinate system.
</li>
					<li>
~IF［
%封入d~flag ~EQ `部分的^i
］~AND［
%領域 内の ある点は %矩形 に入る
］
⇒
%結果 に %子 を付加する
◎
If we are finding intersecting descendants and region lies partially or fully within rectangle, then append child to result.
</li>
					<li>
~IF［
%封入d~flag ~EQ `全部的^i
］~AND［
%領域 内の どの点も %矩形 に入る
］
⇒
%結果 に %子 を付加する
◎
Otherwise, we are finding enclosed descendants. If region lies fully within rectangle, then append child to result.
</li>
				</ol>
<p class="trans-note">【
点が領域や矩形の境界~上にある場合に どうするか指定されていないが、
精度など実装の詳細~に依存するので，
指定したところで各~UAにおける挙動の一貫性は保証されないであろう。
】</p>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`要素の中の容器でない~graphics要素を見出す@
ときは、所与の
( 要素 %要素 )
に対し，次の手続きを走らす：
◎
To find the non-container graphics elements within a given element element, the following steps are run:
</p>

<ol>
	<li>
%結果 ~LET 空~list
◎
Let result be an initially empty list.
</li>
	<li>
<p>
~IF［
%要素 は［
`svg$e ／ `g$e
］要素である
］
⇒
%要素 の
~EACH( 子~要素 %子 )
に対し文書~順序で：
◎
If element is an ‘svg’ or ‘g’ element, then for each child element child of element, in document order:
</p>
		<ol>
			<li>
%子孫たち ~LET `要素の中の容器でない~graphics要素を見出す$( %子 )
◎
Let descendants be the result of finding the non-container graphics elements within child.
</li>
			<li>
%結果 に %子孫たち を成すすべての要素を付加する
◎
Append to result all the elements of descendants.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%要素 は`~graphics要素$である
］
⇒
%結果 に %要素 を付加する
◎
Otherwise, if element is a graphics element then append element to result.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<dl class="idl-def">
	<dt>`getIntersectionList(rect, referenceElement)@m</dt>
	<dt>`getEnclosureList(rect, referenceElement)@m</dt>
	<dd class="algo">
<p>
これらの~method~手続きは：
◎
When getIntersectionList(rect, referenceElement) or getEnclosureList(rect, referenceElement) is called, the following steps are run:
</p>
		<ol>
			<li>
<p>
%子孫たち ~LET 呼ばれた~methodに応じて：
◎
Let descendants be a list, depending on what method we are in:
</p>
				<dl class="switch">
					<dt>`getIntersectionList()$m</dt>
					<dd>
`矩形に入る子孫を見出す$( コレ, %rect, `部分的^i )
◎
descendants is the result of finding the intersecting descendants of the current ‘svg’ element with rectangle rect in the current ‘svg’ element's coordinate system.
</dd>
					<dt>`getEnclosureList()$m</dt>
					<dd>
`矩形に入る子孫を見出す$( コレ, %rect, `全部的^i )
◎
descendants is the result of finding the enclosed descendants of the current ‘svg’ element with rectangle rect in the current ‘svg’ element's coordinate system.
</dd>
				</dl>
			</li>
			<li>
~IF［
%referenceElement ~NEQ ~NULL
］
⇒
%子孫たち から %referenceElement の子孫でない要素はすべて除去する
◎
If referenceElement is not null, then remove from descendants any element that does not have referenceElement as an ancestor.
</li>
			<li>
~RET %子孫たち を成すすべての要素を包含する，`静的$な `NodeList$I
`DOM$r 【！＊】
◎
Return a static NodeList that contains all of the elements in descendants. ([DOM], section 5.2.7)
</li>
		</ol>
	</dd>

	<dt>`checkIntersection(element, rect)@m</dt>
	<dt>`checkEnclosure(element, rect)@m</dt>
	<dd class="algo">
<p>
これらの~method~手続きは：
◎
When checkIntersection(element, rect) or checkEnclosure(element, rect) is called, the following steps are run:
</p>
		<ol>
			<li>
<p>
%子孫たち ~LET 呼ばれた~methodに応じて：
◎
Let descendants be a list, depending on what method we are in:
</p>
				<dl class="switch">
					<dt>`getIntersectionList()$m</dt>
					<dd>
`矩形に入る子孫を見出す$( コレ, %rect, `部分的^i )
◎
descendants is the result of finding the intersecting descendants of the current ‘svg’ element with rectangle rect in the current ‘svg’ element's coordinate system.
</dd>
					<dt>`getEnclosureList()$m</dt>
					<dd>
`矩形に入る子孫を見出す$( コレ, %rect, `全部的^i )
◎
descendants is the result of finding the enclosed descendants of the current ‘svg’ element with rectangle rect in the current ‘svg’ element's coordinate system.
</dd>
				</dl>
			</li>
			<li>
%要素たち ~LET `要素の中の容器でない~graphics要素を見出す$( %element )
◎
Let elements be the result of finding the non-container graphics elements within element.
</li>
			<li>
~RET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%要素たち は空でない
］~AND［
%要素たち を成すどの要素も %子孫たち に含まれる
］
◎
If elements is empty, then return false.
◎
If any element in elements is not also in descendants, then return false.
◎
Return true.
</li>
		</ol>
	</dd>


	<dt>`deselectAll()@m</dt>
	<dd>
文書から選択を除去するために利用される。
◎
The deselectAll method is used to remove any selections from the document.＼
</dd>
	<dd class="algo">
<p>
その~method~手続きは：
</p>
		<ul>
			<li>
%選択 ~LET 文書の`選択＠~SELECTIONAPI#dom-selection$
`EDITING$r
</li>
			<li>
%選択 からすべての`範囲~obj$を除去する
`DOM$r
</li>
			<li>
%選択 の`方向＠~SELECTIONAPI#dfn-direction$
~SET `forwards^i
</li>
		</ul>
◎
When deselectAll() is called, all ranges from the document's selection are removed and the selection's direction is set to forwards. [DOM][EDITING]＼
</dd>
	<dd>
この~methodは、非推奨にされた
— Selection ~APIの機能性と重複するので。
◎
This method is deprecated, as it duplicates functionality from the Selection API.
</dd>
	<dd class="note">注記：
これは、この `svg$e 要素が属する文書~上で
`document.getSelection().removeAllRanges()^c
を~callするのと等価になる。
◎
This is equivalent to calling document.getSelection().removeAllRanges() on the document that this ‘svg’ element is in.
</dd>

	<dt>`createSVGNumber()@m</dt>
	<dt>`createSVGLength()@m</dt>
	<dt>`createSVGAngle()@m</dt>
	<dt>`createSVGPoint()@m</dt>
	<dt>`createSVGMatrix()@m</dt>
	<dt>`createSVGRect()@m</dt>
	<dt>`createSVGTransform()@m</dt>
	<dd>
<p>
これらの~methodは、
特定0の型の新たな~objを作成するために利用される~factory関数である。
~callされたときは、
~methodに応じて，次の表の 2 列目に与える新たな~objを返す
（いずれも、`関連な要素$は ε になる）：
◎
The createSVGNumber, createSVGLength, createSVGAngle, createSVGPoint, createSVGMatrix, createSVGRect and createSVGTransform methods are all factory functions used to create a new datatype object of a particular type. When one of these methods is called, a new object is returned according to the following table:
</p>

<table><tbody><tr><th>~method
<th>~objとその詳細
<tr><td>`createSVGNumber()$m
<td>
新たな `SVGNumber$I ~objであって，その値は 0 にされたもの
◎
A new, detached SVGNumber object whose value is 0.

<tr><td>`createSVGLength()$m
<td>
新たな `SVGLength$I ~objであって，その長さ値は［
単位なしの `number$t 0
］にされたもの
◎
A new, detached SVGLength object whose value is the unitless &lt;number&gt; 0.

<tr><td>`createSVGAngle()$m
<td>
新たな `SVGAngle$I ~objであって，その角度~値は［
単位なしの `number$t 0
］にされたもの
◎
A new, detached SVGAngle object whose value is the unitless &lt;number&gt; 0.

<tr><td>`createSVGPoint()$m
<td>
新たな `DOMPoint$I ~objであって，その座標はすべて 0 にされたもの
◎
A new, detached DOMPoint object whose coordinates are all 0.

<tr><td>`createSVGMatrix()$m
<td>
新たな `DOMMatrix$I ~objであって，単位i行列を表現しているもの
◎
A new, detached DOMMatrix object representing the identity matrix.

<tr><td>`createSVGRect()$m
<td>
新たな `DOMRect$I ~objであって，その［
x 座標, y 座標, 横幅~寸法, 縦幅~寸法
］はすべて 0 にされたもの
◎
A new, DOMRect object whose x, y, width and height are all 0.

<tr><td>`createSVGTransform()$m
<td>
新たな `SVGTransform$I ~objであって，その値は
`matrix(1, 0, 0, 1, 0, 0)^v
【単位i行列で表現される~2D変形】にされたもの
◎
A new, detached SVGTransform object whose value is matrix(1, 0, 0, 1, 0, 0).

</tbody></table>

	</dd>
	<dd>
［
`createSVGPoint()$m, `createSVGMatrix()$m, `createSVGRect()$m
］~methodは、
非推奨にされ，旧来の内容との互換性を得るために限り保たれている。
作者には、代わりに［
`DOMPoint$I, `DOMMatrix$I, `DOMRect$I
］の構築子（同順）を利用することが奨励される。
◎
The createSVGPoint, createSVGMatrix and createSVGRect methods are all deprecated and kept only for compatibility with legacy content. Authors are encouraged to use the DOMPoint, DOMMatrix and DOMRect constructors instead.
</dd>

	<dt>`createSVGTransformFromMatrix(matrix)@m</dt>
	<dd>
行列から新たな `SVGTransform$I ~objを作成するために利用される。
その挙動は、
`SVGTransformList$I 上の `createSVGTransformFromMatrix()$n ~methodと同じとする。
◎
The createSVGTransformFromMatrix method is used to create a new SVGTransform object from a matrix object. Its behavior is the same as the createSVGTransformFromMatrix method on SVGTransformList.
</dd>

	<dt>`getElementById(elementId)@m</dt>
	<dd class="algo">
~method~手続きは、次を返す
⇒
コレの子孫の中で［
~ID ~EQ %elementId
］を満たすものが［
在れば それらのうち`~tree順序$で最初の要素 ／
無ければ ~NULL
］
◎
The getElementById method, must return the first element in tree order, within the ‘svg’ element's descendants, whose ID is elementId, or null if there is no such element.
</dd>
</dl>

		</section>
		<section id="InterfaceSVGGElement">
<h3 title="Interface SVGGElement">5.13.3. ~interface `SVGGElement^I0</h3>

<p>
`SVGGElement$I ~objは、
~DOM内で `g$e 要素を表現する。
◎
An SVGGElement object represents a ‘g’ element in the DOM.
</p>


<pre class="idl">
[Exposed=Window]
interface `SVGGElement^Ix : `SVGGraphicsElement$I {
};
</pre>

		</section>
		<section id="InterfaceSVGDefsElement">
<h3 title="Interface SVGDefsElement">5.13.4. ~interface `SVGDefsElement^I0</h3>


<p>
`SVGDefsElement$I ~objは、
~DOM内で `defs$e 要素を表現する。
◎
An SVGDefsElement object represents a ‘defs’ element in the DOM.
</p>

<pre class="idl">
[Exposed=Window]
interface `SVGDefsElement^Ix : `SVGGraphicsElement$I {
};
</pre>

		</section>
		<section id="InterfaceSVGDescElement">
<h3 title="Interface SVGDescElement">5.13.5. ~interface `SVGDescElement^I0</h3>

<p>
`SVGDescElement$I ~objは、
~DOM内で `desc$e 要素を表現する。
◎
An SVGDescElement object represents a ‘desc’ element in the DOM.
</p>

<pre class="idl">
[Exposed=Window]
interface `SVGDescElement^Ix : `SVGElement$I {
};
</pre>

		</section>
		<section id="InterfaceSVGMetadataElement">
<h3 title="Interface SVGMetadataElement">5.13.6. ~interface `SVGMetadataElement^I0</h3>


<p>
`SVGMetadataElement$I ~objは、
~DOM内で `metadata$e 要素を表現する。
◎
An SVGMetadataElement object represents a ‘metadata’ element in the DOM.
</p>

<pre class="idl">
[Exposed=Window]
interface `SVGMetadataElement^Ix : `SVGElement$I {
};
</pre>

		</section>
		<section id="InterfaceSVGTitleElement">
<h3 title="Interface SVGTitleElement">5.13.7. ~interface `SVGTitleElement^I0</h3>

<p>
`SVGTitleElement$I ~objは、
~DOM内で `title$e 要素を表現する。
◎
An SVGTitleElement object represents a ‘title’ element in the DOM.
</p>

<pre class="idl">
[Exposed=Window]
interface `SVGTitleElement^Ix : `SVGElement$I {
};
</pre>

		</section>
		<section id="InterfaceSVGSymbolElement">
<h3 title="Interface SVGSymbolElement">5.13.8. ~interface `SVGSymbolElement^I0</h3>

<p>
`SVGSymbolElement$I ~objは、
~DOM内で `symbol$e 要素を表現する。
◎
An SVGSymbolElement object represents a ‘symbol’ element in the DOM.
</p>


<pre class="idl">
[Exposed=Window]
interface `SVGSymbolElement^Ix : `SVGGraphicsElement$I {
};

`SVGSymbolElement$I includes `SVGFitToViewBox$I;
</pre>

<p class="note">注記：
~SVG-2にて新たに~~導入された。
`SVGSymbolElement$I ~interfaceは、
今や `SVGGraphicsElement$I を継承する
— ~shadow~DOM内に~instance化された `symbol$e を~graphics要素として~queryできるように。
◎
New in SVG 2. The SVGSymbolElement interface now inherits from SVGGraphicsElement, so that the instantiated symbol in the shadow DOM can be queried as a graphics element.
</p>

		</section>
		<section id="InterfaceSVGUseElement">
<h3 title="Interface SVGUseElement">5.13.9. ~interface `SVGUseElement^I0</h3>

<p>
`SVGUseElement$I ~objは、
~DOM内で `use$e 要素を表現する。
◎
An SVGUseElement object represents a ‘use’ element in the DOM.
</p>


<pre class="idl">
[Exposed=Window]
interface `SVGUseElement^Ix : `SVGGraphicsElement$I {
  [SameObject] readonly attribute `SVGAnimatedLength$I `x$m;
  [SameObject] readonly attribute `SVGAnimatedLength$I `y$m;
  [SameObject] readonly attribute `SVGAnimatedLength$I `width$m;
  [SameObject] readonly attribute `SVGAnimatedLength$I `height$m;
  [SameObject] readonly attribute `SVGElement$I? `instanceRoot$m;
  [SameObject] readonly attribute `SVGElement$I? `animatedInstanceRoot$m;
};

`SVGUseElement$I includes `SVGURIReference$I;
</pre>

<dl class="idl-def">
	<dt>`x@m</dt>
	<dt>`y@m</dt>
	<dt>`width@m</dt>
	<dt>`height@m</dt>
	<dd>
これらの~IDL属性は、
順に，コレ上の［
`x$p, `y$p, `width$p, `height$p
］~propの算出d値, それぞれに対応する呈示~属性を`反映する$。
◎
The x, y, width and height IDL attributes reflect the computed values of the x, y, width and height properties and their corresponding presentation attributes, respectively.
</dd>

	<dt>`instanceRoot@m</dt>
	<dt>`animatedInstanceRoot@m</dt>
	<dd class="algo">
<p>
これらの取得子~手続きは：
</p>
		<ol>
			<li>
~IF［
コレは~shadow~treeを~hostしていない
（すなわち、`参照先の要素$は無い
— 例えば，［
その~URIは無効である ／
`条件付き処理＠#ConditionalProcessing$により不能化されている
］ことにより）
］
⇒
~RET ~NULL
</li>
			<li>
~RET コレの`~instance根$（`参照先の要素$の`要素~instance$）を表現する `SVGElementInstance$I ~obj
</li>
		</ol>

<p>
（ `instanceRoot^m は、
同じ~obj上の `shadowRoot^m から `firstChild^m を取得するのに等価になる。）
</p>

◎
The instanceRoot and animatedInstanceRoot IDL attributes both point to the instance root, the SVGElementInstance that is a direct child of this element's shadow root (u.instanceRoot is equivalent to getting u.shadowRoot.firstChild). If this element does not have a shadow tree (for example, because its URI is invalid or because it has been disabled by conditional processing), then getting these attributes returns null.
</dd>
</dl>

		</section>
		<section id="InterfaceSVGUseElementShadowRoot">
<h3 title="Interface SVGUseElementShadowRoot">5.13.10. ~interface `SVGUseElementShadowRoot^I0</h3>


<p>
各`~use要素の~shadow~tree$の根は、
`SVGUseElementShadowRoot$I ~interfaceを実装する。
この~interfaceは、
現時点では［
`ShadowRoot$I ~interface, `DocumentOrShadowRoot$I ~mixin
］用に定義された各~memberに対する拡張は定義していない。
しかしながら，この~nodeを根とする~treeは、
作者~scriptの視点からは，全体が読専になる。
◎
The root object of each use-element shadow tree implements the SVGUseElementShadowRoot interface. This interface does not currently define any extensions to the properties and methods defined for the ShadowRoot interface and DocumentOrShadowRoot mixin. However, the tree rooted at this node is entirely read-only from the perspective of author scripts.
</p>


<pre class="idl">
[Exposed=Window]
interface `SVGUseElementShadowRoot^Ix : `ShadowRoot$I {
};
</pre>

		</section>
		<section id="InterfaceSVGElementInstance">
<h3 title="Mixin SVGElementInstance">5.13.11. ~mixin `SVGElementInstance^I0</h3>

<p>
`SVGElementInstance$I ~interface~mixinは、
`SVGElement$I ~interfaceに対する拡張を定義する
— これは、`~use要素の~shadow~tree$内にある要素~用に限り利用される。
◎
The SVGElementInstance interface defines extensions to the SVGElement interface, which are only used for elements in a use-element shadow tree.
</p>


<p class="note">注記：
以前の~versionの~SVGでは、
~SVG要素~instanceは［
~event~targetとしては妥当であるが，全部的な~DOM~nodeではない、
要素でない~obj
］として定義されていた。
この仕様は、
`~use要素の~shadow~tree$を ~Shadow~DOM仕様と整合するように定義し直す
— それは、
各~instanceは，実際に `SVGElement^I ~objになることを意味する。
この~interfaceは、
後方-互換性を得るため，欠落している機能性を追加する。
しかしながら，作者は、
互換性は完璧でないことを自覚する下で，自身の~scriptを設計するベキである。
また，これらの~memberは、
~shadow~tree内の~HTML名前空間に属する要素~obj上では可用にならないことに注意。
◎
In previous versions of SVG, SVG element instances were defined as non-element objects that were valid event targets but not full DOM nodes. This specification re-defines the use-element shadow tree to be consistent with the Shadow DOM specification, which means that instances are actual SVGElement objects. This interface adds the missing functionality for backwards compatibility. However, authors should be aware that compatibility is not perfect, and design their scripts accordingly. Also note that these properties will not be available on HTML-namespaced element objects in the shadow tree.
</p>


<pre class="idl">
interface mixin `SVGElementInstance^Ix {
  [SameObject] readonly attribute `SVGElement$I? `correspondingElement$m;
  [SameObject] readonly attribute `SVGUseElement$I? `correspondingUseElement$m;
};
</pre>

<dl class="idl-def">
	<dt>`correspondingElement@m</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET ［
コレは `~use要素の~shadow~tree$内の`要素~instance$であるならば コレに`対応している要素$ ／
~ELSE_ ~NULL
］
◎
The correspondingElement IDL attribute points to the corresponding element if this element is an element instance in a use-element shadow tree, or is null otherwise.
</dd>
	<dd class="issue" id="issue71">
`参照先の要素$が外部~file内にあるとき、
これが ~NULL でないことは，外部~fileを成す~DOM全体が ~memory内に保守しなければならないことを含意する。
しかしながら，現時点では、
外部~DOMは読専と指定されている。
したがって，提供する機能性は制限されており、
処理能に大きな影響iがあり得る。
実装者からの~feedbackを待っている。
作者は、外部~file参照に対する `correspondingElement^m の利用は，~risk下にあるものと見なすベキである。
◎
When the referenced element is in an external file, the presence of this pointer implies that the entire DOM of the external file must be maintained in memory. However, as currently specified, the external DOM is read-only. It therefore offers limited functionality and a potentially large performance impact. Pending feedback from implementers, authors should consider the use of correspondingElement with external file references to be at-risk.
</dd>

	<dt>`correspondingUseElement@m</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET ［
コレは `~use要素の~shadow~tree$内の`要素~instance$であるならば コレに`対応している~use要素$ ／
~ELSE_ ~NULL
］
◎
The correspondingUseElement IDL attribute points to the corresponding use element if this element is an element instance in a use-element shadow tree, or is null otherwise.
</dd>
</dl>

		</section>
		<section id="InterfaceShadowAnimation">
<h3 title="Interface ShadowAnimation">5.13.12. ~interface `ShadowAnimation^I0</h3>

<p>
`ShadowAnimation$I ~interfaceは、
読専 `Animation$I ~objを定義する。
この~objは、
構築-時に渡された `Animation$I ~objにおけるすべての変化を映出す。
この~objは、［
`~use要素の~shadow~tree$内にある，作者が起動した~animation~obj
］を映出すために利用される。
◎
The ShadowAnimation inteface defines a read-only Animation object, which mirrors all changes to the sourceAnimation object from which it was constructed. They are used to mirror author-initiated animation objects in the use-element shadow tree.
</p>


<pre class="idl">
[Exposed=Window]
interface `ShadowAnimation^Ix : `Animation$I {
  constructor(`Animation$I %source, (`Element$I or `CSSPseudoElement$I) %newTarget);
  [SameObject] readonly attribute `Animation$I `sourceAnimation$m;
};
</pre>

<dl class="idl-def">
	<dt>`sourceAnimation@m</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET 構築子の %source 引数に渡された `Animation$I ~obj
◎
The sourceAnimation IDL property points to the Animation object passed in the constructor.
</dd>

	<dt>`ShadowAnimation(source, newTarget)@m</dt>
	<dd>
<p>
この構築子は、
新たな `ShadowAnimation$I ~objを生成する。
それは、~objの `effect$n 属性~値を次の結果に改変することを除き，
%source 上のすべての~propを反映する：
</p>
		<ol>
			<li>
%効果 ~LET %source の~keyframe効果を利用して，新たな `KeyframeEffect$I ~objを構築した結果†
</li>
			<li>
%効果 の `~target0$n 属性 ~SET %newTarget
</li>
			<li>
~RET %効果
</li>
		</ol>

<p class="trans-note">【†
原文には `KeyframeEffectReadOnly^I と記されているが、
廃されて `KeyframeEffect^I に統合された。
おそらく、 %source の `effect$n 属性~値を引数に `KeyframeEffect$I ~objの構築子~手続きを呼出す。
】</p>
◎
The constructor generates a new ShadowAnimation object, which reflects all properties on the sourceAnimation, except that its effect is created by constructing a new KeyframeEffectReadOnly using the keyframe effect of the sourceAnimation as its source, and then modifying its target to match the newTarget parameter.
</dd>
	<dd>
`ShadowAnimation$I は読専とする。
［
`Animation$I から継承した~IDL~propの設定子を呼出す ／
状態を変更するような `Animation^I 上の~methodを~callする
］どの試みに対しても，
`NoModificationAllowedError$E を投出するモノトスル。
一方で~UAは、
構築-時に渡された `Animation$I ~obj上の~propや状態に対するどの変化も，
`ShadowAnimation$I ~obj上の変化として反映されることを確保するモノトスル。
◎
A ShadowAnimation is read-only. Any attempt to set any of the inherited IDL properties, or call any of the Animation methods that change its state, must throw a NoModificationAllowedError. However, the user agent must ensure that any changes to the properties or state of the sourceAnimation are reflected in changes to the ShadowAnimation.
</dd>
</dl>


		</section>
		<section id="InterfaceSVGSwitchElement">
<h3 title="Interface SVGSwitchElement">5.13.13. ~interface `SVGSwitchElement^I0</h3>

<p>
`SVGSwitchElement$I ~objは、
~DOM内で `switch$e 要素を表現する。
◎
An SVGSwitchElement object represents a ‘switch’ element in the DOM.
</p>

<pre class="idl">
[Exposed=Window]
interface `SVGSwitchElement^Ix : `SVGGraphicsElement$I {
};
</pre>

		</section>
		<section id="InterfaceGetSVGDocument">
<h3 title="Mixin GetSVGDocument">5.13.14. ~mixin `GetSVGDocument^I0</h3>

<p>
この~interfaceは、［
~DOMに基づく別の言語~内に，参照により埋込まれた~SVG文書
］への~accessを供する。
この~interfaceは、
そのような~SVG文書~参照を許容する~DOM~obj上に実装されることが期待されている。
◎
This interface provides access to an SVG document embedded by reference in another DOM-based language. The expectation is that the interface is implemented on DOM objects that allow such SVG document references.
</p>


<p>
この~interfaceは、
非推奨にされ，将来~versionの~SVG仕様からは落とされ得る。
［
`iframe^e ／ `object^e
］要素の内側にある~SVG文書に~accessするときは、
作者には［
`HTMLIFrameElement$I ／ `HTMLObjectElement$I
］~interface上の`contentDocument^m 属性を利用することが示唆される。
◎
This interface is deprecated and may be dropped from future versions of the SVG specification. To access the SVG document inside an ‘iframe’ or ‘object’ element, authors are suggested to use the contentDocument attribute on the HTMLIFrameElement or HTMLObjectElement interface, respectively.
</p>

<p class="note">注記：
［
`HTMLIFrameElement$I ／ `HTMLEmbedElement$I ／ `HTMLObjectElement$I
］~interfaceは、
それぞれ，［
`GetSVGDocument$I が行うのと同じ仕方で~SVG文書への~accessを供する
］ような，自前の `getSVGDocument()^m ~methodを定義する。
したがって、
これらの~interfaceは， `GetSVGDocument$I を実装する必要は無い。
作者には、
依然として，代わりに `contentDocument^m を利用することが強く推奨される。
◎
The HTMLIFrameElement, HTMLEmbedElement and HTMLObjectElement interfaces all define their own getSVGDocument method, which provides access to the SVG document in the same way that the GetSVGDocument does. Those three interfaces therefore do not need to implement GetSVGDocument. Still, authors are strongly recommended to use contentDocument instead.
</p>


<pre class="idl">
interface mixin `GetSVGDocument^Ix {
  `Document$I `getSVGDocument$m();
};
</pre>

<dl class="idl-def">
	<dt>`getSVGDocument()@m</dt>
	<dd>
参照先の~SVG文書を返す。
◎
The getSVGDocument method is used to return a referenced SVG document.＼
</dd>
	<dd class="algo">
その~method~手続きは、
埋込んでいる要素から参照されていて， `GetSVGDocument$I ~interfaceを実装する `Document$I ~objが［
在るならば それ ／
無いならば ~NULL
］を返す。
◎
When getSVGDocument() is called, it must return the Document object referenced by the embedding element that implements the GetSVGDocument interface; if there is no document, null is returned.
</dd>
	<dd class="note">注記：
これは、参照先の文書が~~実際に~SVG文書かどうか検査しないことに注意。
代わりに~~任意の文書が返され得る。
◎
Note that this does no check to see whether the referenced document is indeed an SVG document. Instead, any document is returned.
</dd>
</dl>

		</section>
	</section>
</main>

