<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Positioned Layout Module Level 3 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
#_ex-table-relative-position {
	border: medium solid silver;
	border-collapse: separate;
	border-spacing:0.2em;
	margin:1em 2em;
}
#_ex-table-relative-position col {
	width: 10em;
}
#_ex-table-relative-position td {
	border: thin solid silver;
}
</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'tp':
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:CSS Positioned Layout Module Level 3
spec_date:2022-08-29
trans_update:2022-08-30
source_checked:200501
page_state_key:CSS
original_url:https://drafts.csswg.org/css-position-3/
	abbr_url:CSSPOS
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:layouts,layout,css
conformance:css
copyright:2022,permissive
trans_1st_pub:2020-05-05

●●class_map
p:property
g:production
css:css
at:at-rule
t:type
pe:pseudo
e:element
v:value
op:op

●●tag_map
p:code
at:code
t:var
css:code
c:code
e:code
pe:code
v:code
op:span
i:i

●●original_id_map
	abspos-insets:fixed-pos

●●link_map

p.position:#propdef-position

p.left:#propdef-left
p.right:#propdef-right
p.top:#propdef-top
p.bottom:#propdef-bottom

p.inset:#propdef-inset
p.inset-block:#propdef-inset-block
p.inset-block-end:#propdef-inset-block-end
p.inset-block-start:#propdef-inset-block-start
p.inset-inline:#propdef-inset-inline
p.inset-inline-end:#propdef-inset-inline-end
p.inset-inline-start:#propdef-inset-inline-start

p.border-bottom-width:~CSSBG#propdef-border-bottom-width
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-right-width:~CSSBG#propdef-border-right-width
p.border-top-width:~CSSBG#propdef-border-top-width

p.width:~SIZING#propdef-width
p.height:~SIZING#propdef-height

p.margin:~CSSBOX#propdef-margin
p.margin-bottom:~CSSBOX#propdef-margin-bottom
p.margin-left:~CSSBOX#propdef-margin-left
p.margin-right:~CSSBOX#propdef-margin-right
p.margin-top:~CSSBOX#propdef-margin-top

p.padding-bottom:~CSSBOX#propdef-padding-bottom
p.padding-left:~CSSBOX#propdef-padding-left
p.padding-right:~CSSBOX#propdef-padding-right
p.padding-top:~CSSBOX#propdef-padding-top

p.display:~CSSDISP#propdef-display

p.direction:~CSSWM#propdef-direction
p.writing-mode:~CSSWM#propdef-writing-mode
p.background-attachment:~CSSBG#propdef-background-attachment

p.float:~CSS2VISUREN#propdef-float
p.clear:~CSS2VISUREN#propdef-clear

p.contain:~CSSCONTAIN#propdef-contain
p.transform:~TRANSFORM#propdef-transform
p.will-change:~CSSWILLCHANGE#propdef-will-change

v.absolute:#valdef-position-absolute
v.fixed:#valdef-position-fixed
v.relative:#valdef-position-relative
v.static:#valdef-position-static
v.sticky:#valdef-position-sticky

v.self-start:~CSSALIGN#valdef-self-position-self-start
v.self-end:~CSSALIGN#valdef-self-position-self-end
v.center:~CSSALIGN#valdef-self-position-center
v.normal:~CSSALIGN#valdef-align-self-normal
v.start:~CSSALIGN#valdef-self-position-start
v.stretch:~CSSALIGN#valdef-align-self-stretch

v.ltr:~CSSWM#valdef-direction-ltr
v.rtl:~CSSWM#valdef-direction-rtl
v.~autoS:~SIZING#valdef-width-auto
v.auto:#valdef-top-auto

	v.none:~CSSDISP#valdef-display-none
	v.none:~CSS2#valdef-float-none

t.length:~CSSVAL#length-value
	vt.length:#valdef-top-length
t.percentage:~CSSVAL#percentage-value
	vt.percentage:#valdef-top-percentage
t.length-percentage:~CSSVAL#typedef-length-percentage

v.table-row-group:~CSSDISP#valdef-display-table-row-group
v.table-header-group:~CSSDISP#valdef-display-table-header-group
v.table-footer-group:~CSSDISP#valdef-display-table-footer-group
v.table-row:~CSSDISP#valdef-display-table-row
v.table-column-group:~CSSDISP#valdef-display-table-column-group
v.table-column:~CSSDISP#valdef-display-table-column
v.table-cell:~CSSDISP#valdef-display-table-cell
~table~cell:~CSSDISP#valdef-display-table-cell

at.media:~CSSCOND#at-ruledef-media
	~CSS22/media.html#at-media-rule

	●用語
最も近い~scrollport:~CSSOVERFLOW3#nearest-scrollport
位置決め~scheme:#positioning-scheme
相対~位置決め:#relative-position
相対的に位置され:#relative-position

絶対~位置決め~layout~model:#absolute-positioning-layout
絶対~位置決め:#absolute-position
絶対的に位置され:#absolute-position
絶対~位置決め包含塊:#absolute-positioning-containing-block

固定d位置決め:#fixed-position
固定的に位置され:#fixed-position
固定d位置決め包含塊:#fixed-positioning-containing-block

張付き位置決め:#sticky-position
張付き位置:#sticky-position
張付きに位置され:#sticky-position
張付き~view矩形:#sticky-view-rectangle
位置~box:#position-box

~inset~prop:#inset-properties
~insetで改変された包含塊:#inset-modified-containing-block
弱い方の~inset:#weaker-inset

有位置:#positioned-box
有位置な~box:#positioned-box

静的~位置:#static-position
静的~位置~矩形:#static-position-rectangle
静的~位置~用の包含塊:#_static-position-containing-block
	静的~位置~用の包含塊:~CSS2VISUDET#static-position

	●用語（外部

~page区画:~CSSPAGE#page-area

包含塊:~CSSDISP#containing-block
初期~包含塊:~CSSDISP#initial-containing-block
整形~文脈:~CSSDISP#formatting-context
置換され:~CSSDISP#replaced-element
	置換されない:~CSSDISP#non-replaced
塊~levelの~box:~CSSDISP#block-level-box
行内~levelの~box:~CSSDISP#inline-level-box
塊~level:~CSSDISP#block-level
行内~level:~CSSDISP#inline-level
~flow内:~CSSDISP#in-flow
~flow外:~CSSDISP#out-of-flow
独立な整形~文脈を確立する:~CSSDISP#establish-an-independent-formatting-context

~scroll容器:~CSSOVERFLOW3#scroll-container
~scrollport:~CSSOVERFLOW3#scrollport
初期~scroll位置:~CSSOVERFLOW3#initial-scroll-position

~box:~CSSDISP#box
行内~box:~CSSDISP#inline-box

~margin:~CSSBOX#margin
~margin~box:~CSSBOX#margin-box
~margin辺:~CSSBOX#margin-edge
~border~box:~CSSBOX#border-box
~border辺:~CSSBOX#border-edge
~border辺:~CSSBOX#border-edge
~padding辺:~CSSBOX#padding-edge
内容~辺:~CSSBOX#content-edge
~margin~prop:~CSSBOX#margin-properties

始端:~CSSWM#css-start
終端:~CSSWM#css-end
行内-軸:~CSSWM#inline-axis
塊-軸:~CSSWM#block-axis
塊-始端:~CSSWM#block-start
行内-始端:~CSSWM#inline-start
塊-終端:~CSSWM#block-end
行内-終端:~CSSWM#inline-end
行-下面:~CSSWM#line-under
行-上面:~CSSWM#line-over
横組み:~CSSWM#horizontal-writing-mode

~box断片:~CSSBREAK#box-fragment
断片~化~flow:~CSSBREAK#fragmented-flow
断片化~分断:~CSSBREAK#fragmentation-break
断片化~容器:~CSSBREAK#fragmentation-container

~flex容器:~CSSFLEX#flex-container
格子~容器:~CSSGRID#grid-container
格子~配置~prop:~CSSGRID#grid-placement-property
格子~区画:~CSSGRID#grid-area

物理的:~CSSWM#physical
~flow相対:~CSSWM#flow-relative
書字~mode:~CSSWM#writing-mode

下位prop:~CASCADE#longhand
略式~prop:~CASCADE#shorthand-property
初期~値:~CASCADE#initial-value
指定d値:~CASCADE#specified-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value

整列~容器:~CSSALIGN#alignment-container
自己-整列~prop:~CSSALIGN#self-alignment-properties
自己-整列:~CSSALIGN#self-align
分布型の整列:~CSSALIGN#distributed-alignment
基底線~整列:~CSSALIGN#baseline-alignment
~box整列~prop:~CSSALIGN#box-alignment-properties

~table包装~box:~CSSTABLE#table-wrapper-box

解決d値:~CSSOM1#resolved-value

塊~化:~CSSDISP#blockify

可用な空間:~SIZING#available
確定的:~SIZING#definite
選好d~size:~SIZING#preferred-size
最小~size:~SIZING#min-size
最大~size:~SIZING#max-size
最大-内容~size:~SIZING#max-content
自動的~size:~SIZING#automatic-size
伸張して収まる~size:~SIZING#stretch-fit-size
内容が収まる~size:~SIZING#fit-content-size
自動的な最小~size:~SIZING#automatic-minimum-size

	●補完
縦横比に依存する軸:~SIZING#ratio-dependent-axis
縦横比に依存しない軸:~SIZING#ratio-determining-axis

格子~layout:~CSSGRID#grid-layout
~flex~layout:~CSSFLEX#flex-layout

表示域:~CSS2VISUREN#viewport
	通常~flow:~CSS2VISUREN#normal-flow

時計回りに設定する:~CSSBOX#_setup-clockwise
行l~box:~CSSINLINE#line-box
浮動体:~CSS2VISUREN#floats
	通常~flow:~CSS2VISUREN#normal-flow

内部~table要素:~CSSDISP#internal-table-element
~scroll可能な~overflow区画:~CSSOVERFLOW3#scrollable-overflow-region

	normal flow:~CSS2VISUREN#normal-flow
	絶対的に位置され:~CSSDISP#absolutely-positioned

連続的~媒体:~MQ5#continuous-media
~paged媒体:~MQ5#paged-media

	●§
	前節:#abs-non-replaced-width
	前節:#abs-non-replaced-height
	§:#abspos-layout
	§:#abspos-insets
	§:#abspos-auto-size
	§:#abspos-margins
	§:fixpos-insets

	●§（外部
	§:~CSSPAGE#content-outside-box
	§:~CSSGRID#abspos-items
	§:~CSSFLEX#abspos-items

置換d要素の~sizing:~CSS2VISUDET#replaced-size

	§:~CSS22/media.html#paged-media-group
	§:固定的な背景~画像:~CSS22/colors.html#background-properties
		→~CSSBG#background-attachment
	§:行l縦幅の計算:~CSS2VISUDET#line-height
	§:~CSS2VISUDET#containing-block-details
	§:~CSS2VISUDET#abs-non-replaced-width
	§:~CSS2VISUDET#abs-replaced-width
	§:~CSS2VISUDET#abs-non-replaced-height
	§:~CSS2VISUDET#abs-replaced-height
	§:~CSS2VISUREN#containing-block
	§:~CSS2VISUREN#positioning-scheme
	§:~CSS2VISUREN#relative-positioning
	§:~CSS2VISUREN#absolute-positioning
	§:~CSS2VISUREN#dis-pos-flo
	§:~CSS2VISUREN#comparison

●●words_table1

autoS:auto

●●words_table

	●幾何
側:side:~
矩形:rectangle:~
横方向:horizontal:~
縦:vertical:~
上面:over::~
下面:under::~
行-:line-::~
上方:upward:~
内方:inward:~
下方:downward:~
縦横比:aspect ratio::~
	縦横比:aspect-ratio
	縦横比に依存する:ratio-dependent
	縦横比に依存しない:ratio-determining
近似:approximation:~

	空間:spaced
	~down:下へ
	~up:上へ
	下端~辺:bottom-edge
	終端~辺:end-edge
	始端~辺:start-edge
	始端~~側に（逆）:end-ward
	高さ:tall
	互いに反対側の:opposing

	●layout
有位置:positioned:~
固定-:fix::~
固定d:fixed::固定
固定的:fixed::~
張付き:sticky::~
row:
flex:
格子:grid::~::グリッド
浮動体:float::~
収まる:fitする::~
伸張-:stretch::~
	内容が収まる:fit-content
	伸張して収まる:stretch-fit
	shrink-to-fit
cell::::セル
scrollport::::スクロール域
	~scroll可能:scrollable
	~scroll法:scrolling
中心:center:~
移動:movement:~
自動:auto:~
横組み:horizontal writing mode::~
押出され:pushされ:押し出され
最大-:max-::~
	最小-:min-::~
確定的:definite::~
連続的:continuous:~

	印刷機:printer:~:::プリンタ
相殺-:collapse::~
ズラされ:shiftされ::ずらされ
ズラさな:shiftしな::ずらさな
ズラせ:shiftでき::ずらせ
ズラす:shiftする::ずらす
	~inset:shift
span:
居座る:stayする:~
固着-:affix:~
分布型の:distributed::~
基底線:baseline::~::ベースライン
包装:wrapper::~

	拘束され過ぎ:over-constrained
	静的~位置~用の:static-position
	張付き拘束:sticky-constraint
	後続する:later
	取り除かれ:take outされ
	later
	最初に~spanする~row:originate in the affected row
	基準:refer／:against／:reference／:in reference to／:with respect to
	残りの:remaining
	周辺に:around
	外れる:out of
	ごちゃ混ぜに:jumble
	引き抜いて:pulling
	~offsetされない:non-offsetted
	~~留めて:remain

	●塗り
重合する:overlapする::重なり合う
重合し:overlapし::重なり合い
重合しな:overlapしな::重なり合わな
重合して:overlapし::重なり合って
塗れる:paintできる:~

	●CSS
書字:writing::~

	下位prop:longhand

	●保安
騙す:trickする:~
modal::::モーダル
模倣-:emulate:~
騙す:trickする:~
	~~錯覚させ:tricking 〜 thinking 
捕捉-:capture:~
	道:route
	他者:people
	〜のどこか:to bits of
	~~重ねる:over

	●仕様
等式:equation:~
依存な:dependentな:~
	に依存-:-dependent
誤利用-:misuse:~
明確さ:clarity:~
	~~選択:choosing
	拘束されない:unconstrained
	興味を引く:interesting
	利用-不能:unusable
	書き直した:rewrote
	易く:easy
	かまうことなく:with no regard for
	仮の:hypotheticalな
	論の最中:under discussion
	たしかに:Yes,
	惑わすもの:confusing
	軽く:little
	取って代わる:supersede
	揃えた:alignした
	かまわない:free to

	●その他
反数:negation::~
増大-:increase:~
量:amount:~
保つ:keepする:~
preview::::プレビュー
実効:effective:~
視界:sight:~
展開-:expand:~
数量-:numeric:~

	互いに:in relation to each other
	できるだけ多くの部分が入る:insofar as it can
	〜の一種:subset
	得られる:yielding
	~~複製:replicate
	時計回りに設定する:exactly as the margin...
	そうならなくなる所まで:to bring the sticky view rectangle...
	十分:enough
	〜に代わって:in place of
	弱い方:weaker
	変わる:vary
	最も近い:nearest
	複数の行lに:across a line
	後続して:subsequently
	まるごと:altogether
	まるごと:entirely
	対応する:respective
	-:pick
	見える:seen
	-:across
	全体:whole
	max^op:capped
	min^op:floored
	-:First,／:Next,／:Then,／:Lastly,
	引いた結果:minus
	の半分:divided
	付与され:attached

	旧-:old
	得られる:yield
	最終的な:final
	~targetにしている:targeting
	同じ仕方で:bounds of 〜 determined identically
	され戻され:back

●●ref_normative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. URL: https://drafts.csswg.org/css-align/
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-BOX-4]
    Elika Etemad. ＜CSS Box Model Module Level 4＞. URL: https://drafts.csswg.org/css-box-4/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. URL: https://drafts.csswg.org/css-break-4/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. ＜CSS Flexible Box Layout Module Level 1＞. URL: https://drafts.csswg.org/css-flexbox-1/
[CSS-GRID-1]
    CSS Grid Layout Level 1 URL: https://www.w3.org/TR/css-grid-1/
[CSS-GRID-2]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. ＜CSS Grid Layout Module Level 2＞. URL: https://drafts.csswg.org/css-grid-2/
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. ＜CSS Inline Layout Module Level 3＞. URL: https://drafts.csswg.org/css-inline-3/
[CSS-LOGICAL-1]
    CSS Logical Properties Module Level 1 URL: https://www.w3.org/TR/css-logical-1/
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. ＜CSS Overflow Module Level 3＞. URL: https://drafts.csswg.org/css-overflow-3/
[CSS-PAGE-3]
    Elika Etemad; Simon Sapin. ＜CSS Paged Media Module Level 3＞. URL: https://drafts.csswg.org/css-page-3/
[CSS-PAGE-FLOATS-3]
    Johannes Wilm. ＜CSS Page Floats＞. URL: https://drafts.csswg.org/css-page-floats/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SIZING-4]
    Tab Atkins Jr.; Elika Etemad; Jen Simmons. ＜CSS Box Sizing Module Level 4＞. URL: https://drafts.csswg.org/css-sizing-4/
[CSS-TABLES-3]
    François Remy; Greg Whitworth; David Baron. ＜CSS Table Module Level 3＞. URL: https://drafts.csswg.org/css-tables-3/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-WRITING-MODES-3]
    CSS Writing Modes Module Level 3 URL: https://www.w3.org/TR/css-writing-modes-3/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. URL: https://drafts.csswg.org/css-writing-modes-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119

●●ref_informative

[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 3＞. URL: https://drafts.csswg.org/css-break/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. URL: https://drafts.csswg.org/css-contain-2/
[CSS-WILL-CHANGE-1]
    Tab Atkins Jr.. ＜CSS Will Change Module Level 1＞. URL: https://drafts.csswg.org/css-will-change/


●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Positioned Layout Module Level 3</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-position-3/
公表履歴
	https://www.w3.org/standards/history/css-position-3

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-position-3">CSSWG Issues Repository</a>

編集
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
前任編集者
	<a href="mailto:ratan@microsoft.com">Rossen Atanassov</a> (Microsoft)</dd>
	<a href="mailto:arronei@microsoft.com">Arron Eicholz</a> (Microsoft)</dd>

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-position-3/Overview.bs">GitHub Editor</a>
課題リスト（Wiki内）
	https://wiki.csswg.org/spec/css-position/
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-position-3

</script>

<body>

<header>
	<hgroup>
<h1>CSS Positioned Layout Module Level 3</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~moduleは、
`~CSS＠~CSSSNAPSHOT$において座標に基づいて~boxを［
位置する／~offsetする
］ための~schemeとして，次に挙げるものを定義する
⇒＃
`相対~位置決め$,
`張付き位置決め$,
`絶対~位置決め$,
`固定d位置決め$
◎
This module contains defines coordinate-based positioning and offsetting schemes of CSS: relative positioning, sticky positioning, absolute positioning, and fixed positioning.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~CSS~layout~algoは、既定では，互いに重合しないよう，~boxたちを~sizeして位置する。
◎
The CSS layout algorithms, by default, size and position boxes in relation to each other so that nothing overlaps.
</p>

<p>
この仕様は、この前提に違反する いくつかの仕方を定義する
— 必要なときは要素を周辺に移動して，他の内容と重合し得るような：
◎
This specification defines several ways to violate these assumptions when needed, moving elements around in ways that can make them overlap other content:
</p>

<ul>
	<li>
`相対~位置決め$は、~boxを~lay-outされた所在から相対的に，視覚的にズラす。
◎
Relative positioning, which visually shifts a box relative to its laid-out location.
</li>
	<li>
`張付き位置決め$は、~boxを~lay-outされた所在から相対的に
— ~scroll可能な先祖が~scrollして~boxが視界から外れるとき，~boxを可視に保つように —
視覚的にズラす。
◎
Sticky positioning, which visually shifts a box relative to its laid-out location in order to keep it visible when a scrollable ancestor would otherwise scroll it out of sight.
</li>
	<li>
`絶対~位置決め$は、通常の~layoutをまるごと無視する。
それは、~boxを`~flow外$に引き抜いて，他の内容にかまうことなく，~boxをその`包含塊$に相対的に位置する。
◎
Absolute positioning, which ignores normal layout entirely, pulling the element out of flow and positioning it relative to its containing block with no regard for other content.
</li>
	<li>
`固定d位置決め$は、~boxを絶対的に位置して，~boxが常に可視になるよう，~boxを［
表示域／~page~frame
］に固着させる。
◎
Fixed positioning, which absolutely positions the box and affixes it to the viewport or page frame so that it is always visible.
</li>
</ul>

<p>
これらの`位置決め~scheme$は、
`position$p ~prop, および各種`~inset~prop$により制御され，強力だが誤利用し易くもある。
これらは、標準な~layout規則では達成できない，多くの興味を引く有用な~layoutを許容するが、適切に~careしないと，~pageの内容は ごちゃ混ぜに重合するよう~lay-outされ，利用-不能になる。
◎
These positioning schemes, controlled by the position property and the inset properties, are powerful but easy to misuse. With appropriate care, they allow many interesting and useful layouts that couldn’t otherwise be achieved with standard layout rules; without, they allow a page to be laid out in an unusable overlapping jumble of content.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、
以下に挙げる `CSS2$r の各節にて定義された`位置決め~scheme$の特能を置換して, 拡張する。
◎
This module replaces and extends the positioning scheme features defined in [CSS2] sections:
</p>

<div >
<ul>
<li>`§ 包含塊＠~CSS2VISUREN#containing-block$
<li>`§ 位置決め~scheme＠~CSS2VISUREN#positioning-scheme$
<li>`§ 相対~位置決め＠~CSS2VISUREN#relative-positioning$
<li>`§ 絶対~位置決め＠~CSS2VISUREN#absolute-positioning$
<li><a href="~CSS2VISUREN#dis-pos-flo">§ `display^p, `position^p, `float^p の関係性</a>
<li>`§ 通常~flow, 浮動体, 絶対~位置決めの比較＠~CSS2VISUREN#comparison$
<li>`§ “包含塊” の定義＠~CSS2VISUDET#containing-block-details$
<li>`§ 絶対的に位置された置換されない要素＠~CSS2VISUDET#abs-non-replaced-width$
<li>`§ 絶対的に位置された置換d要素＠~CSS2VISUDET#abs-replaced-width$
<li>`§ 絶対的に位置された置換されない要素＠~CSS2VISUDET#abs-non-replaced-height$
<li>`§ 絶対的に位置された置換d要素＠~CSS2VISUDET#abs-replaced-height$
</ul>

◎
• 9.1.2 Containing blocks
• 9.3 Positioning schemes
• 9.4.3 Relative positioning
• 9.6 Absolute positioning
• 9.7 Relationships between display, position, and float
• 9.8 Comparison of normal flow, floats, and absolute positioning
• 10.1 Definition of "containing block"
• 10.3.7 Absolutely positioned, non-replaced elements
• 10.3.8 Absolutely positioned, replaced elements
• 10.6.4 Absolutely positioned, non-replaced elements
• 10.6.5 Absolutely positioned replaced elements
</div>

<p>
この~moduleはまた、
`CSS-LOGICAL-1$r
`§ ~flow相対な~offset＠~CSSLOGICAL#position-properties$【！#inset-properties】
における各種 `inset-*^p ~propの定義を置換して，それに取って代わる。
◎
It also replaces and supersedes the inset* property definitions in [CSS-LOGICAL-1] (CSS Logical Properties 1 § 4.3 Flow-relative Offsets: the inset-block-start, inset-block-end, inset-inline-start, inset-inline-end properties and inset-block, inset-inline, and inset shorthands).
</p>

		</section>
		<section id="values">
<h3 title="Value Definitions">1.2. 値~定義</h3>

<p class="trans-note">【
この節の内容は `~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
	</section>
	<section id="position-property">
<h2 title="Choosing A Positioning Scheme: position property">2. 位置決め~schemeの~~選択 : `position^p ~prop</h2>

◎名 `position@p
◎値
`static$v | `relative$v | `absolute$v | `sticky$v | `fixed$v
◎初 `static^v
◎適 
すべての要素
— ただし， `table-column-group^v, `table-column^v は除く。
◎
all elements except table-column-group and table-column
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`position$p ~propは、どの
`位置決め~scheme@
（ `positioning scheme^en ）を利用して，~boxの位置を計算するかを決定する。
`static$v 以外の値は、~boxを
`有位置な~box@
（ `positioned box^en ）にして，~boxの子孫~用の`絶対~位置決め包含塊$を確立させる。
各種 値の意味は：
◎
The position property determines which of the positioning schemes is used to calculate the position of a box. Values other than static make the box a positioned box, and cause it to establish an absolute positioning containing block for its descendants. Values have the following meanings:
</p>

<dl>
	<dt>`static@v</dt>
	<dd>
~boxは`有位置な~box$にはならず、その親`整形~文脈$の規則に則って~lay-outされる。
`~inset~prop$は適用されない。
◎
The box is not a positioned box, and is laid out according to the rules of its parent formatting context. The inset properties do not apply.
</dd>

	<dt>`relative@v</dt>
	<dd>
~boxは、 `static$v のときと同じに~lay-outされた上で，結果の位置から~offsetされる。
この~offset法は、純粋に視覚的な効果であり，他の~boxの~sizeや位置には影響しない
— ~boxの先祖の`~scroll可能な~overflow区画$が増大することを除けば。
◎
The box is laid out as for static, then offset from the resulting position. This offsetting is a purely visual effect, and does not affect the size or position of any other box, except insofar as it increases the scrollable overflow area of its ancestors.＼
</dd>
	<dd>
この`位置決め~scheme$は、
`相対~位置決め@
（ `relative positioning^en ）と呼ばれる。
◎
This positioning scheme is called relative positioning.
</dd>

	<dt>`sticky@v</dt>
	<dd>
次を除き， `relative$v に一致する
⇒
その~offsetは、`最も近い~scrollport$（を当の~boxの`~inset~prop$で改変した結果）を基準に自動的に調整される
— それは、利用者が~scrollするに伴い，~boxを その`包含塊$の中で ~view内に保つよう試行する。
ただし，所与の軸に対応する両`~inset~prop$の値とも `auto$v になる場合、その軸については調整されない。
◎
Identical to relative, except that its offsets are automatically adjusted in reference to the nearest ancestor scroll container’s scrollport (as modified by the inset properties) in whichever axes the inset properties are not both auto, to try to keep the box in view within its containing block as the user scrolls.＼
</dd>
	<dd>
この`位置決め~scheme$は、
`張付き位置決め@
（ `sticky positioning^en ）と呼ばれる。
◎
This positioning scheme is called sticky positioning.
</dd>

	<dt>`absolute@v</dt>
	<dd>
~boxは，`~flow外$に取り除かれ、その［
同胞／先祖
］の~sizeや位置に対する影響iも，親の`整形~文脈$にも関与することもなくなる。
◎
The box is taken out of flow such that it has no impact on the size or position of its siblings and ancestors, and does not participate in its parent’s formatting context.
</dd>
	<dd>
<p>
代わりに，~boxは、もっぱら，~boxの`絶対~位置決め包含塊$を~boxの`~inset~prop$により改変した結果を基準に位置され, ~sizeされる
— `§ 絶対~位置決めの~layout~model＠#abspos-layout$を見よ。
その結果，~boxは：
◎
Instead, the box is positioned and sized solely in reference to its absolute positioning containing block, as modified by the box’s inset properties, see § 4 Absolute Positioning Layout Model.＼
</p>
		<ul>
			<li>
`~flow内$にある内容や他の`絶対的に位置され$た要素と重合し得る。
◎
It can overlap in-flow content or other absolutely positioned elements, and＼
</li>
			<li>
その【！is】`包含塊$を【！generate】確立した~boxの，`~scroll可能な~overflow区画$に含まれる。
◎
is included in the scrollable overflow area of the box that generates is containing block.＼
</li>
		</ul>
	</dd>
	<dd>
この`位置決め~scheme$は、
`絶対~位置決め@
（ `absolute positioning^en ）と呼ばれる。
【 `fixed$v にて述べるように、用語としてのこの語は，`固定d位置決め$も包摂していることに注意。】
◎
This positioning scheme is called absolute positioning.
</dd>

	<dt>`fixed@v</dt>
	<dd>
<p>
次を除いて `absolute$v と同じになる：
◎
Same as absolute, except＼
</p>
		<ul>
			<li>
~boxは`固定d位置決め包含塊$に相対的に位置され, ~sizeされる
（通例的には、［
`連続的~媒体$においては`表示域$／`~paged媒体$においては`~page区画$
］内で）。
◎
the box is positioned and sized relative to a fixed positioning containing block (usually the viewport in continuous media, or the page area in paged media).＼
</li>
			<li>
<p>
~boxの位置は、この矩形を基準に固定される：
◎
The box’s position is fixed with respect to this reference rectangle:＼
</p>
				<ul>
					<li>
`表示域$に付与されたときは、
文書が~scrollされても移動しない。
◎
when attached to the viewport it does not move when the document is scrolled,＼
</li>
					<li>
`~page区画$に付与されたときは、
文書が~page割りされるとき，~boxは~pageごとに~~複製される。
◎
and when attached to the page area is replicated on every page when the document is paginated.
</li>
				</ul>
			</li>
		</ul>
	</dd>
	<dd>
この`位置決め~scheme$は、
`固定d位置決め@
（ `fixed positioning^en ）と呼ばれ，`絶対~位置決め$の一種と見なされる。
【一方で、`絶対~位置決め包含塊$と`固定d位置決め包含塊$は，排他的な概念であることに注意。】
◎
This positioning scheme is called fixed positioning and is considered a subset of absolute positioning.
</dd>

	<dd class="example">
<p>
作者は、 `fixed$v を媒体~依存な仕方で指定したいと望むこともあろう。
一例として，作者は、~screen上では~boxを`表示域$の上端に~~留めておきたいが，印刷される各~page上では そうしたくないと求めることもあろう。
この 2 つの指定は、次のように `media$at 規則を利用すれば分離できる：
◎
Authors may wish to specify fixed in a media-dependent way. For instance, an author may want a box to remain at the top of the viewport on the screen, but not at the top of each printed page. The two specifications may be separated by using an '@media' rule, as in:
</p>

<pre class="lang-css">
@media screen {
    h1#first { position: fixed }
}
@media print {
    h1#first { position: static }
}
</pre>

	</dd>
</dl>

<p>
`position$p 用の値［
`absolute$v ／ `fixed$v
］は
⇒＃
~boxを`塊~化$させる。
`float$p の算出d値を `none^v にする。
~boxが`独立な整形~文脈を確立する$よう強制する。
◎
A position value of absolute or fixed blockifies the box, causes float to compute to none, and forces the box to establish an independent formatting context.
</p>

		<section id="def-cb">
<h3 title="Containing Blocks of Positioned Boxes">2.1. 有位置な~boxの包含塊</h3>

<p>
［
`static$v ／ `relative$v ／ `sticky$v
］`~box$用の`包含塊$は、~boxが関与する`整形~文脈$により定義される。
［
`absolute$v ／ `fixed$v
］`~box$用の`包含塊$は、次に従って定義される：
◎
The containing block of a static, relative, or sticky box is as defined by its formatting context. For fixed and absolute boxes, it is defined as follows:
</p>

<dl class="switch">
	<dt id="absolute-cb">
`absolute$v の場合
◎
If the box has position: absolute:
</dt>
	<dd>
<p>
~boxの`包含塊$は、先祖に
`絶対~位置決め包含塊@
を確立する~boxが：
◎
The containing block is established by＼
</p>
		<ul class="switch">
			<li>
<p>
在るならば、それらのうち~boxに最も近い先祖 %先祖 に応じて，次の仕方で確立される：
◎
the nearest ancestor box that establishes an absolute positioning containing block, in the following way:
</p>
				<ul class="switch">
					<li>
%先祖 は`行内~box$でない場合
⇒
%先祖 の`~padding辺$により形成される
— 他が指定されない限り（例えば、`格子~layout$
CSS Grid Layout の
`§ 包含塊が格子~容器により生成されているとき＠~CSSGRID#abspos-items$
を見よ）。
◎
If the ancestor is not an inline box,
• the containing block is formed by the padding edge of the ancestor, unless otherwise specified (for example, see CSS Grid Layout 1 § 9.1 With a Grid Container as Containing Block).
</li>
					<li>
<p>
%先祖 は`行内~box$である場合
⇒
%先祖 の最初の`~box断片$の［
`塊-始端$, `行内-始端$
］`内容~辺$, および
%先祖 の最後の`~box断片$の［
`塊-終端$, `行内-終端$
］`内容~辺$により形成される。
◎
If the ancestor is an inline box,
• the containing block is formed by the block-start and inline-start content edges of the first box fragment of the ancestor, and the block-end and inline-end content edges of the last box fragment of the ancestor.
</p>

<p class="note">注記：
%先祖 が複数の行lに分断される場合、~boxの “終端” 位置は “始端” 位置より始端~~側に来るかもしれない。
◎
Note: If the ancestor breaks across a line, the “start” position might more end-ward than the “end” position.
</p>

					</li>
				</ul>
			</li>
			<li>
無いならば、`初期~包含塊$になる。
◎
If no ancestor establishes one, the absolute positioning containing block is the initial containing block.
</li>
		</ul>
	</dd>
	<dd class="trans-note">【
上述のように決定される`包含塊$は，
“~boxの`絶対~位置決め包含塊$”
とも称される
— この句は、~boxがそれを確立したことではなく，~boxは`絶対的に位置され$ている（かつ`固定的に位置され$ていない）前提を含意する。
】</dd>
	<dd class="note">注記：
要素に`絶対~位置決め包含塊$を確立させる~propには、
`position$p, `transform$p, `will-change$p, `contain$p, …
などがある。
◎
Note: Properties that can cause a box to establish an absolute positioning containing block include position, transform, will-change, contain…
</dd>

	<dt id="fixed-cb">
`fixed$v の場合
◎
If the box has position: fixed:
</dt>
	<dd>
<p>
~boxの`包含塊$は、先祖に
`固定d位置決め包含塊@
を確立する~boxが：
◎
The containing block is established by＼
</p>
		<ul class="switch">
			<li>
<p>
在るならば、それらのうち最も近い先祖により
— `絶対~位置決め包含塊$のときと同じ仕方で —
確立される。
◎
the nearest ancestor box that establishes an fixed positioning containing block, with the bounds of the containing block determined identically to the absolute positioning containing block.
</p>

<p class="note">注記：
要素に`固定d位置決め包含塊$を確立させる~propには、
`transform$p, `will-change$p, `contain$p, …
などがある。
◎
Note: Properties that can cause a box to establish a fixed positioning containing block include transform, will-change, contain…
</p>
			</li>
			<li>
<p>
無いならば：
◎
If no ancestor establishes one, the fixed positioning containing block is:
</p>
				<ul>
					<li>
<p>
`連続的~媒体$においては、`表示域$になる。
その結果，`固定的に位置され$た~boxは、文書が~scrollされても移動しない。
◎
in continuous media, the viewport; as a result, fixed boxes do not move when the document is scrolled.
</p>

<p class="note">注記：
この点に関しては、
`固定的な背景~画像＠~CSSBG#background-attachment$
（ `background-attachment$p が `fixed^v にされたそれ）と同様になる。
◎
Note: In this respect, they are similar to fixed background images (background-attachment: fixed).
</p>
					</li>
					<li>
`~paged媒体$においては、各~pageの`~page区画$になる。
その結果，`固定的に位置され$た`~box$は、~pageごとに~~複製される（例えば印刷~previewのように，~pageが`表示域$を通して見える【呈示されている】場合でも、~page~boxのみを基準に固定される）。
◎
in paged media, the page area of each page; fixed positioned boxes are thus replicated on every page. (They are fixed with respect to the page box only, and are not affected by being seen through a viewport; as in the case of print preview, for example.)
</li>
				</ul>

<p class="note">注記：
その結果，`固定d位置決め$においては、［
`初期~包含塊$／`~page区画$
］の外側まで拡張する部分は，［
そこへは~scrollし得なくなる／印刷されなくなる
］。
◎
Note: As a result, parts of fixed-positioned boxes that extend outside the initial containing block/page area cannot be scrolled to and will not print.
</p>
			</li>
		</ul>
	</dd>
	<dd class="trans-note">【
上述のように決定される`包含塊$は，
“~boxの`固定d位置決め包含塊$”
とも称される
— この句は、~boxがそれを確立したことではなく，~boxは`固定的に位置され$ている前提を含意する。
】</dd>
</dl>

<div class="example">
<p>
位置決めが無ければ、次の文書における各~要素の包含塊は：
◎
With no positioning, the containing blocks (C.B.) in the following document:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;包含塊の~~説明&lt;/title&gt;
    &lt;/head&gt;
    &lt;body id="body"&gt;
        &lt;div id="div1"&gt;
        &lt;p id="p1"&gt;最初の段落の~text...&lt;/p&gt;
        &lt;p id="p2"&gt;これは &lt;em id="em1"&gt;
        &lt;strong id="strong1"&gt;2 番目の&lt;/strong&gt; 段落の中の~text&lt;/em&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<!-- 
Illustration of containing blocks
This is text in the first paragraph...
This is text in the second paragraph.
-->

<p>
次に従って確立される：
◎
are established as follows:
</p>

<table class="cb-example-table"><tbody>

<tr><th>
~boxを生成する要素
◎
For box generated by
<th>
要素の包含塊を確立するもの
◎
C.B. is established by

<tr><td>`html^e
<td>初期~包含塊（~UAに依存する）
◎
initial C.B. (UA-dependent)
<tr><td>`body^v
<td>`html^e
<tr><td>`div1^v
<td>`body^v
<tr><td>`p1^v
<td>`div1^v
<tr><td>`p2^v
<td>`div1^v
<tr><td>`em1^v
<td>`p2^v
<tr><td>`strong1^v
<td>`p2^v
</tbody></table>

<p>
初期~包含塊は、~UAに依存する。
</p>

<p>
"`div1^v" を次のように位置した場合：
◎
If we position "div1":
</p>

<pre class="lang-css">
#div1 { position: absolute; left: 50px; top: 50px }
</pre>

<p>
その包含塊は、最早 `body^v でなくなり，`初期~包含塊$になる（他に有位置な先祖~boxは無いので）。
◎
its containing block is no longer "body"; it becomes the initial containing block (since there are no other positioned ancestor boxes).
</p>

<p>
同様に， `em1^v も次のように位置した場合：
◎
If we position "em1" as well:
</p>

<pre class="lang-css">
#div1 { position: absolute; left: 50px; top: 50px }
#em1  { position: absolute; left: 100px; top: 100px }
</pre>

<p>
包含塊の表は：
◎
the table of containing blocks becomes:
</p>

<table class="cb-example-table"><tbody>

<tr><th>~boxを生成する要素◎ For box generated by
<th>包含塊を確立するもの◎ C.B. is established by

<tr><td>`html^e
<td>初期~包含塊◎ initial C.B.
<tr><td>`body^v
<td>`html^e
<tr><td>`div1^v
<td>初期~包含塊◎ initial C.B.
<tr><td>`p1^v
<td>`div1^v
<tr><td>`p2^v
<td>`div1^v
<tr><td>`em1^v
<td>`div1^v
<tr><td>`strong1^v
<td>`em1^v
</tbody></table>

<p>
`em1^v の位置決めにより、その包含塊は最も近い有位置な先祖~box
— すなわち， `div1^v が生成する~box —
になる。
◎
By positioning "em1", its containing block becomes the nearest positioned ancestor box (i.e., that generated by "div1").
</p>

</div>

		</section>
	</section>
	<section id="coords">
<h2 title="Positioning Coordinates">3. 位置決め座標</h2>

<div class="p">
<p>
`有位置な~box$の精確な所在は、次に挙げる各種
`~inset~prop@
により制御される：
</p>
<ul>
	<li>
`物理的$な`~inset~prop$
⇒＃
`top$p,
`right$p,
`bottom$p,
`left$p
</li>
	<li>
`~flow相対$な`~inset~prop$
⇒＃
`inset-block-start$p,
`inset-inline-start$p,
`inset-block-end$p,
`inset-inline-end$p
</li>
	<li>
前項に挙げた~propの`略式~prop$
⇒＃
`inset-block$p,
`inset-inline$p,
`inset$p
</li>
</ul>
◎
The precise location of a positioned box is controlled by the inset properties: the physical inset properties top, right, bottom, left; the flow-relative inset properties inset-block-start, inset-inline-start, inset-block-end, and inset-inline-end; and their shorthands, inset-block, inset-inline, and inset.
</div>

<p>
これらの`~inset~prop$の解釈は、`位置決め~scheme$により変わる：
◎
The interpretation of these inset properties varies by positioning scheme:
</p>
<ul>
	<li>
`絶対~位置決め$
⇒
包含塊からの~insetを表現する。
◎
for absolute positioning, they represent insets from the containing block.
</li>
	<li>
`相対~位置決め$
⇒
~boxの元の~margin辺からの~insetを表現する。
◎
for relative positioning, they represent insets from the box’s original margin edge.
</li>
	<li>
`張付き位置決め$
⇒
`最も近い~scrollport$【！`~scrollport$】の辺からの~insetを表現する。
◎
for sticky positioning, they represent insets from the scrollport edge.
</li>
</ul>

		<section id="insets">
<h3 title="Box Insets: the top, right, bottom, left, inset-block-start, inset-inline-start, inset-block-end, and inset-inline-end properties ">3.1. ~box~inset： `top^p, `right^p, `bottom^p, `left^p, `inset-block-start^p, `inset-inline-start^p, `inset-block-end^p, `inset-inline-end^p ~prop</h3>

◎名
<span class="preline">`top@p,
`right@p,
`bottom@p,
`left@p,
`inset-block-start@p,
`inset-inline-start@p,
`inset-block-end@p,
`inset-inline-end@p</span>
◎値
`auto$v | `length-percentage$t
◎初 `auto$v
◎適 `有位置$な要素
◎継 されない
◎百 
`包含塊$の~sizeを基準にする
— 注釈文を見よ
◎
refer to size of containing block; see prose
◎算 
~keyword `auto$v ／算出された `length-percentage$t 値
◎順 文法に従う
◎ア 算出された値~型による
◎表終

<p>
これらの`~inset~prop$は、~boxの対応している側からの “~inset”
— 内方への~offset —
を表現する（どの~propが上下左右どの側に対応するかは、~boxの自前の`書字~mode$に基づく
— `CSS-WRITING-MODES-3$r
`§ ~boxの抽象的な各種用語＠~CSSWM#abstract-box$
を見よ）。
例えば， `top$p は、上端~辺から下方への~insetを表現する。
`物理的$な~propと`~flow相対$な~propは、
`CSS-LOGICAL-1$r に定義されるように相互作用する。
各種 値の意味は：
◎
These inset properties represent an inward “inset” on the corresponding side of the box (with respect to the box’s own writing mode; see CSS Writing Modes 3 § 6 Abstract Box Terminology). For example, top represents a downward inset of the top edge. The physical and flow-relative properties interact as defined in [CSS-LOGICAL-1]. Values have the following meanings:
</p>

<dl class="valdef">
	<dt id="valdef-top-length">`length$t</dt>
	<dd>
~insetは、基準~辺からの固定的な距離になる。
◎
The inset is a fixed distance from the reference edge.＼
</dd>
	<dd>
負な値も許容される。
◎
Negative values are allowed.
</dd>

	<dt id="valdef-top-percentage">`percentage$t</dt>
	<dd>
~insetは、対応する軸における`包含塊$の~size（例：
`left$p ／ `right$p
に対しては横幅,
`top$p ／ `bottom$p
に対しては縦幅）に相対的な百分率になる。
`張付きに位置され$た~box用の~insetは、代わりに`最も近い~scrollport$【！関連な`~scrollport$】の~sizeに相対的になる。
◎
The inset is a percentage relative to the containing block’s size in the corresponding axis (e.g. width for left or right, height for top and bottom). For sticky positioned boxes, the inset is instead relative to the relevant scrollport’s size.＼
</dd>
	<dd>
負な値も許容される。
◎
Negative values are allowed.
</dd>

	<dt>`auto@v</dt>
	<dd>
拘束されない~insetを表現する。
正確な意味は、`位置決め~scheme$に依存する。
◎
Represents an unconstrained inset; the exact meaning depends on the positioning scheme.
</dd>
</dl>

<p class="note">注記：
`固定的に位置され$た要素~用の~insetに大き過ぎる値や負な値を利用すると、要素は`表示域$の外側へ容易に移動され得る。
そうなった場合、内容は，~scrollする その他の手段を通して到達できなくなる。
◎
Note: For fixed positioned elements, using large values or negative values can easily move elements outside the viewport and make the contents unreachable through scrolling or other means.
</p>

		</section>
		<section id="inset-shorthands">
<h3 title="Box Insets Shorthands: the inset-block, inset-inline, and inset properties">3.2. ~box~inset略式~prop： `inset-block^p, `inset-inline^p, `inset^p ~prop</h3>

◎名 
`inset-block@p,
`inset-inline@p
◎値 `top$tp{1,2}
◎初 `auto$v
◎適 `有位置$な要素
◎継 されない
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 算出された値~型による
◎表終

<p>
`inset-block$p ~propは［
`inset-block-start$p, `inset-block-end$p
］を，
`inset-inline$p ~propは［
`inset-inline-start$p, `inset-inline-end$p
］を単独の宣言で設定するための`略式~prop$である。
2 個の成分~値は、順に［
`始端$, `終端$
］側を設定する。
2 個目の値が省略された場合の既定は、 1 個目の値と同じになる。
◎
The inset-block and inset-inline properties are shorthand properties for setting inset-block-start + inset-block-end or inset-inline-start + inset-inline-end, respectively, in a single declaration. The first component value sets the start side, the second sets the end; if omitted, the second value defaults to the first.
</p>

◎名 `inset@p
◎値 `top$tp{1,4}
◎初 `auto$v
◎適 `有位置$な要素
◎継 されない
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎順 文法に従う
◎ア 算出された値~型による
◎表終

<p>
`inset$p ~propは、すべての`~inset~prop$を単独の宣言で設定する`略式~prop$であり、各~側を表現している下位propを`時計回りに設定する$
【！exactly as the margin property does for its longhands】。
◎
The inset property is a shorthand property that sets all of the inset properties in a single declaration, assigning values to the longhands representing each side exactly as the margin property does for its longhands.
</p>

<div class="note">

<p>注記：
`inset$p ~prop値は、既定では，対応する<em>`物理的$</em>な`下位prop$
— `top$p, `right$p, `bottom$p, `left$p — 
にアテガわれるが、歴史的な理由から，これらには `inset-^p 接頭辞は無い。
この挙動は、
`margin$p など，他の “各~側に 4 個の値をアテガう” ~propに合致する。
◎
By default, the inset property values are assigned to the corresponding physical longhand properties—top, right, bottom, and left—which for historical reasons do not have an inset- prefix. This matches the behavior of other "4 values assigned to sides" properties, such as margin.
</p>

<p>
このような~propを`~flow相対$な`下位prop$に解決するのを許容することは、
`CSS-LOGICAL-1$r にて論の最中にある。
◎
Allowing properties such as this to resolve to the flow-relative longhands is under discussion in [CSS-LOGICAL-1].
</p>

<p>
たしかに、 `inset$p が どの `inset-*^p ~propにも展開されないのは，軽く惑わすものになろうことは理解している。
◎
Yes, we understand it’s a little confusing that inset doesn’t expand to any inset-* properties.
</p>
</div>

		</section>
		<section id="relpos-insets">
<h3 title="Relative Positioning">3.3. 相対~位置決め</h3>

<p>
`相対的に位置され$た~box %~box 用には、`~inset~prop$は， %~box を
— その~sizeは変更することなく —
対応する辺から内方へ移動する。
`left$p に対する【正な】値は， %~box を右へ移動させ、
`right$p に対する【正な】値は， %~box を左へ移動させる，等々。
%~box は，相対~位置決めにより［
分割される／伸張される
］ことはないので、所与の軸において互いに反対側の`~inset~prop$の`使用~値$は，互いに反数になる（それらの和は 0 になる）ことが要求される
— そのような 2 つの`~inset~prop$の`算出d値$が：
◎
For a relatively positioned box, the inset properties move the box inward from the respective edge, without changing its size. left moves the box to the right, right moves it to the left, etc. Since boxes are not split or stretched as a result of relative positioning opposing used values in a given axis must be negations of each other:
</p>

<ul>
	<li>
どちらも `auto$v （`初期~値$）ならば
⇒
どちらも`使用~値$は 0 になる（すなわち，当の軸においては、 %~box は元の位置に居座る）。
◎
If opposing inset properties in an axis both compute to auto (their initial values), their used values are zero (i.e., the boxes stay in their original position in that axis).
</li>
	<li>
片方だけ `auto$v ならば
⇒
その方の`使用~値$が他方の算出d値の反数になる（ %~box は指定された量だけズラされる）。
◎
If only one is auto, its used value becomes the negation of the other, and the box is shifted by the specified amount.
</li>
	<li>
どちらも `auto$v でないならば
⇒
位置は拘束され過ぎ
— この場合、［
%~box の`包含塊$の`終端$と同じ側†における`~inset~prop$
］の`算出d値$は無視され，その`使用~値$は［
もう片方の`~inset~prop$の使用~値
］の反数になる。
（† この終端は，`包含塊$の`書字~mode$に基づくので、
%~box の終端とは反対~側になる場合もあることに注意。）
◎
If neither is auto, the position is over-constrained; (with respect to the writing mode of its containing block) the computed end side value is ignored, and its used value becomes the negation of the start side.
</li>
</ul>

<div class="example">
<p>
次の 3 規則は等価であり、どれも~boxを `1em^v だけ左へズラす：
◎
The following three rules are equivalent, and shift the box 1em to the left:
</p>

<pre class="lang-css">
div.a8 { position: relative; direction: ltr; left: -1em; right: auto }
div.a8 { position: relative; direction: ltr; left: auto; right: 1em }
div.a8 { position: relative; direction: ltr; left: -1em; right: 5em }
</pre>
</div>

<p>
［
`table-row-group$v ／
`table-header-group$v ／
`table-footer-group$v ／
`table-row$v
］`~box$に指定された~insetは、~boxのすべての内容に影響する
— これには、`~table~cell$のうち［
それが最初に~spanする~rowは，当の~boxに含まれるもの
］すべてが含まれるが，他の`~table~cell$は含まれない。
◎
If specified on a table-row-group, table-header-group, table-footer-group, or table-row box the shift affects all the contents of the box, including all table cells that originate in the affected row, but not those that don’t.
</p>

<p class="note">注記：
`position$p は［
`table-column-group$v ／ `table-column$v
］~boxには適用されない
— それらの~boxは、`相対~位置決め$に影響されない。
◎
Note: Since position does not apply to table-column-group or table-column boxes, they are not affected by relative positioning.
</p>

<div class="example">

<p class="trans-note">【
この例は、この訳による追加。
】</p>

<p>
閲覧中の~browserによる［
`table-row^v ／ `table-cell^v
］~boxに対する `relative$v の効果（ 2 本目の~rowは右へ, 3 本目の~rowは左へズラされている）：
</p>

<table id="_ex-table-relative-position">
<col><col><col>
<tbody><tr><td>この~cellが属する~rowは、ズラされていない
<td rowspan="3" style="position:relative; top:1em; color:blue;">
下へズラされた~cell
— 3 本の~rowに~spanしていてるが，ズラされない~rowに属する
<td>この~cellが属する~rowは、ズラされていない

<tr style="position:relative; left:2em;"><td>
この~cellは、右へズラされる~rowに属する
<td rowspan="2" style="position:relative; top:1em; color:blue;">
下へズラされた~cell
— 2 本の~rowに~spanしているが，右へズラされる~rowに属する

<tr style="position:relative; right:2em;"><td>
この~cellは、左へズラされる~rowに属する
</tbody>
</table>
</div>

		</section>
		<section id="stickypos-insets">
<h3 title="Sticky positioning">3.4. 張付き位置決め</h3>

<p>
`張付き位置決め$は、次を除いて，`相対~位置決め$に類似する
⇒
各~offsetは、`最も近い~scrollport$を基準に，以下に従って自動的に計算される
◎
Sticky positioning is similar to relative positioning except the offsets are automatically calculated in reference to the nearest scrollport.
</p>

<p>
`張付きに位置され$た`~box$ %~box に対しては、`~inset~prop$は，`最も近い~scrollport$の対応する辺からの~insetを表現する。
それは、 %~box の位置を拘束するために利用される
`張付き~view矩形@
（ `sticky view rectangle^en ）を定義する。
（この目的においては、 `auto$v 値は~inset 0 を表現する）。
所与の軸において，この結果の`張付き~view矩形$の~sizeが %~box の`~border~box$の~size未満になる場合、当の軸における
%~box の［
%~box の`包含塊$の`終端$と同じ側†にある辺
］の実効~insetは，そうならなくなる所まで抑制される（場合によっては負になる）。
（† この終端は，`包含塊$の`書字~mode$に基づくので、
%~box の終端とは反対~側になる場合もあることに注意。）
◎
For a sticky positioned box, the inset properties represent insets from the respective edges of the nearest scrollport, defining the sticky view rectangle used to constrain the box’s position. (For this purpose an auto value represents a zero inset.) If this results in a sticky view rectangle size in any axis less than the size of the border box of the sticky box in that axis, then the effective end-edge inset in the affected axis is reduced (possibly becoming negative) to bring the sticky view rectangle’s size up to the size of the border box in that axis (where end is interpreted relative to the writing mode of the containing block).
</p>

<div class="example">

<p>
例えば，［
`最も近い~scrollport$の高さは `300px^v,
`張付きに位置され$た~boxの`~border~box$の高さは `200px^v,
~boxの `top$p は `20px^v
］の場合、`最も近い~scrollport$からの［
上端~辺の~insetは `20px^v,
下端~辺の~insetは `0px^v
］になり，`張付き~view矩形$の高さとして `280px^v が得られる。
◎
For example, if the nearest scrollport is 300px tall, the sticky box’s border box is 200px tall, and it has top: 20px, then the top-edge inset of the nearest scrollport is 20px, and the bottom-edge inset is 0px, yielding a sticky view rectangle that is 280px tall.
</p>

<p>
一方で，`最も近い~scrollport$の高さが `100px^v しかない場合、下端~辺の実効~insetは， `-120px^v になり、結果の`張付き~view矩形$は，`張付きに位置され$た~boxの`~margin~box$【`~border~box$？】を全部的に包含するまでに十分な高さ `200px^v になる。
◎
But if the nearest scrollport were only 100px tall, then the effective bottom-edge inset becomes -120px, resulting in a sticky view rectangle that’s 200px tall, enough to fully contain the margin box of the sticky box.
</p>
</div>

<p>
%~box の各~側に対し：［
その側に対応する %~box の`~inset~prop$は `auto$v でない
］かつ［
その側に対応する %~box の`~border辺$は`張付き~view矩形$の対応する辺より外側に来る†
］ときは、
%~box を
— `相対~位置決めに対するときと同じく＠#relpos-insets$，視覚的に —
その`位置~box$が［
`包含塊$に包含され続ける
］下で［
`張付き~view矩形$の内方へ，できるだけ多く入る（近付く）所
］まで，ズラすモノトスル。
◎
For each side of the box, if the corresponding inset property is not auto, and the corresponding border edge of the box would be outside the corresponding edge of the sticky view rectangle, then the box must be visually shifted (as for relative positioning) to be inward of that sticky view rectangle edge, insofar as it can while its position box remains contained within its containing block.＼
</p>

<p class="trans-note">【†
%~box の各種~辺（~border辺や~margin辺）は包含塊を基準にする一方で，張付き~view矩形は~scrollportを基準にするので、これらの位置関係は，~scrollされるに伴い変化することに注意。
】【
すなわち，~scrollされて %~box が`張付き~view矩形$の外側に出かかったときは、できるだけ内側に留まろうとすることになる
— その効果は、`固定d位置決め$に似る。
】</p>

<p>
%~box の
`位置~box@
は、
%~box の各~側の`~margin$を［
%~box の`~margin辺$【`~border辺$？】から %~box の`包含塊$の対応する辺までの距離
］以下に切り詰めたとするときの，`~margin~box$になる。
◎
The position box is its margin box, except that for any side for which the distance between its margin edge and the corresponding edge of its containing block is less than its corresponding margin, that distance is used in place of that margin.
</p>

<p class="note">注記：
`張付きに位置され$た要素のうち，［
`top$p 値は非 `auto$v,
`bottom$p 値は `auto^v
］なるものは、下へ押出されるのみであり，張付き位置決めにより上方へ~offsetすることは決してない。
◎
Note: A sticky positioned element with a non-auto top value and an auto bottom value will only ever be pushed down by sticky positioning; it will never be offset upwards.
</p>

<p class="note">注記：
同じ容器~内に`張付きに位置され$た~boxが複数ある場合、それぞれが独立に~offsetするので，それらは重合し得る。
◎
Note: Multiple sticky positioned boxes in the same container are offset independently, and therefore might overlap.
</p>

			<section id="stickypos-scroll">
<h4 title="Scroll Position of Sticky-Positioned Boxes">3.4.1. 張付きに位置された~boxの~scroll位置</h4>

<p>
`張付きに位置され$た要素（またはその ある子孫）の~scroll位置を~targetにしている演算の目的においては、張付きに位置された要素は，その初期（~offsetされない）位置に位置されることになると見なすモノトスル。
◎
For the purposes of any operation targeting the scroll position of a sticky positioned element (or one of its descendants), the sticky positioned element must be considered to be positioned at its initial (non-offsetted) position.
</p>

<div class="example">

<p>
例えば，`張付きに位置され$た要素を~targetにしている~linkを利用者が~clickした場合、要素の`最も近い~scrollport$は
— 現在~scrollされていて、要素は初期~位置から~offsetされていても —
要素の初期~位置が可視になるよう，~scrollされ戻されることになる。
◎
For example, if a user clicks a link targeting a sticky-positioned element, even if the element’s nearest scrollport is currently scrolled such that the sticky positioned element is offset from its initial position, the scrollport will be scrolled back so that the element’s initial position is visible.
</p>
</div>

			</section>
		</section>
		<section id="abspos-insets">
<h3 title="Absolute (and Fixed) Positioning">3.5. 絶対（および固定d）位置決め</h3>

<p>
`絶対的に位置され$た~boxに対しては、
その`~inset~prop$は，その~sizingと位置決めの基準になる`包含塊$を実質的に指定された量だけ抑制する
— 結果の包含塊を指して，
`~insetで改変された包含塊@
という。
◎
For an absolutely positioned box, the inset properties effectively reduce the containing block into which it is sized and positioned by the specified amounts.
</p>

<div>
<p>
各~軸に対し，
当の~box %~box の`包含塊$ %包含塊 の［
始端, 終端
］から抑制する量【言い換えれば、対応する`~inset~prop$の`使用~値$】は、
以下に従って決定される結果の［
%始端~inset, %終端~inset
］（同順）で与えられる
— 以下においては：
</p>
<ul>
	<li>
~sizeは、一貫して，所与の軸における それらを表すとする。
</li>
	<li>
［
`始端~側^i ／ `終端~側^i
］は、所与の軸における %~box の［
`始端$ ／ `終端$
］側を指すとする。
</li>
	<li>
［
`始端~inset~prop^i ／ `終端~inset~prop^i
］は
%~box の`~inset~prop$のうち［
`始端~側^i ／ `終端~側^i
］に対応する方を指すとする。
</li>
</ul>
◎
↓</div>

<ol>
	<li>
%始端~inset ~LET `始端~inset~prop^i の`算出d値$
◎
↓</li>
	<li>
%終端~inset ~LET `終端~inset~prop^i の`算出d値$
◎
↓</li>
	<li>
%弱い方の~inset ~LET ε
◎
↓</li>
	<li>
<p>
~IF［
%始端~inset ~NEQ `auto$v
］~OR［
%終端~inset ~NEQ `auto$v
］：
</p>
		<ol>
			<li>
~IF［
%終端~inset ~EQ `auto$v
］
⇒＃
%終端~inset ~SET 0；
%弱い方の~inset ~SET `終端~側^i
</li>
			<li>
~ELSE（ %始端~inset ~EQ `auto$v ）
⇒＃
%始端~inset ~SET 0；
%弱い方の~inset ~SET `始端~側^i
</li>
		</ol>
◎
If only one inset property in a given axis is auto, it is set to zero.＼
</li>
	<li>
<p>
~ELSE（ %始端~inset, %終端~inset どちらも `auto$v ）：
◎
If both inset properties in a given axis are auto, then,＼
</p>
		<ol>
			<li>
%始端~静的~位置 ~LET `始端~側^i からの %~box の`静的~位置$
◎
↓</li>
			<li>
%終端~静的~位置 ~LET `終端~側^i からの %~box の`静的~位置$
◎
↓</li>
			<li>
<p>
当の軸における %~box の`自己-整列~prop$に応じて
（ここでは、
`normal$v は `start$v として扱う／［
`分布型の整列$／`基底線~整列$／ `stretch$v 整列
］値は，その~fallback整列として扱う）：
◎
depending on the box’s self-alignment property in the relevant axis＼
(treating normal as start and any distributed, baseline, or stretch alignment value as its fallback alignment):
</p>
				<ul class="switch">
					<li>
`self-start$v 整列または，それに等価になる値
⇒＃
%始端~inset ~SET %始端~静的~位置；
%終端~inset ~SET 0
◎
for self-start alignment or its equivalent
• Set its start-edge inset property to the static position, and its end-edge inset property to zero.
</li>
					<li>
`self-end$v 整列または，それに等価になる値
⇒＃
%始端~inset ~SET 0；
%終端~inset ~SET %終端~静的~位置
◎
for self-end alignment or its equivalent
• Set its end-edge inset property to the static position, and its start-edge inset property to zero.
</li>
					<li>
<p>
`center$v 整列に対しては：
◎
for center alignment
</p>
						<ol>
							<li>
%始端~距離 ~LET %始端~静的~位置 ~PLUS ( %~box の`静的~位置~矩形$の~size ~DIV 2 )
◎
Let start distance be the distance from the center of its static-position rectangle to the start edge of its containing block, and＼
</li>
							<li>
%終端~距離 ~LET %終端~静的~位置 ~PLUS ( %~box の`静的~位置~矩形$の~size ~DIV 2 )
◎
end distance be the distance from the center of its static-position rectangle to the end edge of its containing block.＼
</li>
							<li>
~IF［
%始端~距離 ~LTE %終端~距離
］
⇒＃
%始端~inset ~SET 0；
%終端~inset ~SET %包含塊 の~size ~MINUS ( 2 ~MUL %始端~距離 )
◎
If start distance is less than or equal to end distance, then set the start-edge inset property to zero, and set the end-edge inset property to (containing block size - 2 × |start distance|);＼
</li>
							<li>
~ELSE
⇒＃
%始端~inset ~SET %包含塊 の~size ~MINUS ( 2 ~MUL %終端~距離 )；
%終端~inset ~SET 0
◎
otherwise, set the end-edge inset property to zero and the start-edge inset property to (containing block size - 2 × |end distance|).
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%弱い方の~inset ~EQ ε
］
⇒
%弱い方の~inset ~SET ［
`始端~側^i, `終端~側^i
］のうち， %包含塊 の`終端$と同じ側にある方
◎
↓</p>

<p class="trans-note">【
%包含塊 と %~box の`書字~mode$が一致しない場合、［
`始端~側^i ／ `終端~側^i
］は， %包含塊 の［
`始端$／`終端$
］と反対~側になり得ることに注意。
】</p>

	</li>
	<li>
<p>
~IF［
%始端~inset ~PLUS %終端~inset ~GT %包含塊 の~size
］：
</p>
		<ol>
			<li>
~IF［
%弱い方の~inset ~EQ `始端~側^i
］
⇒
%始端~inset ~SET %包含塊 の~size ~MINUS %終端~inset （負になり得る）
</li>
			<li>
~ELSE（ %弱い方の~inset ~EQ `終端~側^i ）
⇒
%終端~inset ~SET %包含塊 の~size ~MINUS %始端~inset （負になり得る）
</li>
		</ol>

<p>
所与の軸における
`弱い方の~inset@
は、
%弱い方の~inset に応じて［
`始端~側^i ならば `始端~inset~prop^i ／
`終端~側^i ならば `終端~inset~prop^i
］を指す。
</p>
◎
If these adjustments result in an effective containing block size in any axis less than zero, then the weaker inset in the affected axis is reduced (possibly becoming negative) to bring that size up to zero.＼
↑↑In the case that only one inset is auto, that is the weaker inset;＼
↑otherwise the weaker inset is the inset of the end edge (where end is interpreted relative to the writing mode of the containing block).
</li>
	<li>
~Assert：
%始端~inset ~PLUS %終端~inset ~LTE %包含塊 の~size
</li>
	<li>
~RET ( %始端~inset, %終端~inset )
</li>
</ol>

<p class="note">注記：
`絶対的に位置され$た~boxは、`~insetで改変された包含塊$の中で
— `§ 絶対~位置決め~layout~model＠#abspos-layout$にて述べるように — 
~sizeされ位置される。
◎
Note: Sizing and positioning of the absolutely positioned box into this inset-modified containing block is as described in § 4 Absolute Positioning Layout Model.
</p>

<p>
所与の軸において，~boxの`自己-整列~prop$が `normal$v の場合、その軸における`弱い方の~inset$の`解決d値$は、その軸において［
`~insetで改変された包含塊$の対応する辺
］と［
`~layout＠#abspos-layout$した後における，~boxの`~margin~box$の対応する辺
］が合致するために必要とされる値になる（他の場合の`~inset~prop$の`解決d値$は、通常通り`使用~値$（上による結果の %始端~inset, %終端~inset ）になる）。
◎
If its self-alignment property in an axis is normal, then the resolved value of its weaker inset in that axis is the value necessary to match that edge of its inset-modified containing block to the corresponding edge of its margin box after layout. (Otherwise the resolved value is the used value described above.)
</p>

			<section id="staticpos-rect">
<h4 title="Resolving Automatic Insets: the “Static Position Rectangle”">3.5.1. 自動的な~insetの解決-法： “静的~位置~矩形”</h4>

<p>
所与の~box %~box の所与の軸における`~inset~prop$が どちらも `auto$v である場合、
%~box は，その`静的~位置~矩形$に整列することにより
`静的~位置@
（ `static position^en ）に解決される。
%~box の
`静的~位置~矩形@
（ `static-position rectangle^en ）は、［
%~box の `position$p が `static^v であったとする場合に，
（ %~box の実際の`包含塊$とは独立に）
%~box が関与することになる`整形~文脈$
］から導出される`整列~容器$である。
`静的~位置$は、［
`static^v であった場合における %~box の位置
］の近似を表現する。
◎
When both inset properties in a given axis are auto, they are resolved into a static position by aligning the box into its static-position rectangle, an alignment container derived from the formatting context the box would have participated in if it were position: static (independent of its actual containing block). The static position represents an approximation of the position the box would have had if it were position: static.
</p>

<p class="trans-note">【
`静的~位置$を見出すために利用される`包含塊$（`静的~位置~用の包含塊$など）は，
~boxの`包含塊$と同じになるとは限らないが、
~layout~algoの中など，`静的~位置$を数量-~offsetとして解釈する必要がある所では、
通例的に，［
~boxの`包含塊$
（言い換えれば、実際の~layout用の包含塊）
の各~辺から~boxの同じ側の辺まで
］の内方への~offset（~inset）と見なされる
（~boxの辺が包含塊の外側に位置する場合、負になる）。
例えば， “上端からの静的~位置” と記された所では、
包含塊の上端~辺から`静的~位置~矩形$の上端~辺までの~insetを表す。
】</p>

<dl>
	<dt>
塊~layout
◎
Block Layout
</dt>
	<dd>
`塊~levelの~box$の`静的~位置$は、
`CSS2$r にて`定義される＠#_css2-static-position$。
`静的~位置~矩形$は、~boxの`静的~位置~用の包含塊$の［
`行内-軸$における始端から終端まで【！between the inline-axis sides】~spanする厚さ【塊~size】 0 の矩形
］になり，その`塊-始端$からの`静的~位置$に位置する。
【！see ~CSS2VISUDET#abs-non-replaced-width】
【！see ~CSS2VISUDET#abs-non-replaced-height】
◎
The static positions of a block-level box are defined in [CSS2] Chapter 10. The static-position rectangle is a zero-thickness rectangle spanning between the inline-axis sides of the box’s static-position containing block (see CSS2§10.3.7); and positioned at its block-start static position (see CSS2§10.6.4).
</dd>
	<dd class="note">注記：
塊~layoutにおける`静的~位置~矩形$は、
`CSS2$r 【！`CSS2.1, § 10.3.7＠~CSS2VISUDET#abs-non-replaced-width$】に述べられている
“`仮の~box＠#_css2-static-position$”
の位置に対応する。
`CSS2$r の下では，`~box整列~prop$は無いので、
`静的~位置~矩形$の中での`絶対的に位置され$た~boxの整列には，常に［
`塊-始端$／`行内-始端$
］が利用される。
◎
Note: In block layout the static-position rectangle corresponds to the position of the “hypothetical box” described in CSS2.1§10.3.7. Since it has no alignment properties, CSS2.1 always uses a block-start inline-start alignment of the absolutely-positioned box within the static-position rectangle.
</dd>

	<dt>
行内~layout
◎
Inline Layout
</dt>
	<dd>
`行内~levelの~box$の`静的~位置$は、
`CSS2$r にて`定義される＠#_css2-static-position$。
`静的~位置~矩形$は、`行l~box$の［
`行-上面$と`行-下面$
］の合間に~spanする， “仮の~box” を包含していた厚さ【行内~size】 0 の矩形になり，その`行内-始端$からの`静的~位置$に位置する。
【！see CSS2§10.3.7 ~CSS2VISUDET#abs-non-replaced-width】
◎
The static positions of an inline-level box are defined in [CSS2] Chapter 10. The static-position rectangle is a zero-thickness rectangle spanning between the line-over/line-under sides of the line box that would have contained its “hypothetical box” (see CSS2§10.3.7); and positioned at its inline-start static position.
</dd>
	<dt>
`~flex~layout$
◎
Flex Layout
</dt>
	<dd>
`~flex容器$の子の`静的~位置~矩形$は、`~flex容器$の`内容~辺$に対応する。
`§ ~flex容器の子の静的~位置＠~CSSFLEX#abspos-items$
`CSS-FLEXBOX-1$r
を見よ。
◎
The static-position rectangle of the child of a flex container corresponds to the content edges of the flex container. See static position of a grid container child in [CSS-FLEXBOX-1].
</dd>
	<dt>
`格子~layout$
◎
Grid Layout
</dt>
	<dd>
`格子~容器$の子の`静的~位置~矩形$は、既定では，格子~容器の`内容~辺$に対応する。
しかしながら，その`格子~容器^も~boxの実際の`包含塊$を確立する場合、`格子~配置~prop$により指定される`格子~区画$が，代わりに`静的~位置~矩形$を確立する。
`§ 格子~容器の子の静的~位置＠~CSSGRID#static-position$
`CSS-GRID-1$r
を見よ。
◎
By default, the static-position rectangle of the child of a grid container corresponds to the content edges of the grid container. However, if that grid container also establishes the box’s actual containing block, then the grid area specified by the grid-placement properties establishes its static-position rectangle instead. See the static position of a grid container child in [CSS-GRID-1].
</dd>
</dl>

<p>
~boxの［
`静的~位置$, `静的~位置~矩形$
］を見出すときは：
◎
Finding the static position and the static position rectangle＼
</p>
<ul>
	<li>
~boxの［
`float$p, `clear$p
］~propは、
どちらも，各自の初期~値をとるものと見做す。
◎
assumes that both float and clear have their initial values,＼
</li>
	<li>
~boxの `display$p ~prop用にも異なる仮の値が要求され得ると見做す。
【`CSS2$r <a href="~CSS2VISUREN#dis-pos-flo">§ `display^p, `position^p `float^p の関係性</a>を見よ。】
◎
and can require assuming a different hypothetical value for display as well.＼
</li>
	<li>
~boxが`固定的に位置され$る場合、
その`包含塊$は，`表示域$に代えて`初期~包含塊$になるものと見做す。
◎
Additionally, the containing block of fixed positioned elements is assumed to be the initial containing block instead of the viewport,＼
</li>
	<li>
すべての`~scroll容器$は、
各自の`初期~scroll位置$に~scrollされていると見做すベキである。
【 “ベキ” とされているのは、例外的な事例もあるからと思われる。】
◎
and all scroll containers should be assumed to be scrolled to their initial scroll position.＼
</li>
	<li>
~boxの~marginに対する `auto^v は、
すべて 0 として扱う。
◎
Lastly, all auto margins on the box itself are treated as zero.
</li>
</ul>

			</section>
			<section id="abspos-breaking">
<h4 title="Fragmenting Absolutely-positioned Elements">3.5.2. 絶対的に位置された要素の断片化-法</h4>

<p>
`断片~化~flow$において`絶対的に位置され$た~boxは、`断片化~分断$をすべて無視する下で，~boxの`包含塊$に相対的に位置される（当の~flowは連続的であったかのように）。
~boxは、後続して，いくつかの`断片化~容器$に分断されてもヨイ／され得る。
◎
In a fragmented flow, an absolutely positioned box is positioned relative to its containing block ignoring any fragmentation breaks (as if the flow were continuous). The box may subsequently be broken over several fragmentation containers.
</p>

<p>
`~paged媒体$において`絶対的に位置され$た内容のうち，その位置が［
~lay-outされている~page（現在の~page）以外の~page／
印刷するためにすでに描画された現在の~page
］内に解決されるものは、【！printers】［
現在の~page／後続な~page
］に配置しても, まるごと省略してもヨイ。
◎
For absolutely positioned content in paged media that resolves to a position on a page other than the page being laid out (the current page), or resolves to a position on the current page that has already been rendered for printing, printers may place the content:
• on the current page,
• on a subsequent page, or
• may omit it altogether.
</p>

<p class="note">注記：
何~pageかに分割される`塊~level$の要素の横幅は、~pageごとに異なり得るので，機器に特有な制限sがあり得る。
◎
Note: A block-level element that is split over several pages can have a different width on each page, and there may be device-specific limits.
</p>

<p>
~UAは、`固定的に位置され$た~boxの内容は~page割りしないモノトスル。
◎
User agents must not paginate the content of fixed-positioned boxes.
</p>

<p class="note">注記：
~UAは、不可視な内容を他の仕方で印刷するかもしれない。
`§ ~page~boxの外側にある内容＠~CSSPAGE#content-outside-box$ `CSS-PAGE-3$r
を見よ。
◎
Note: User agents might print invisible content in other ways. See CSS Paged Media 3 § 3.2 Content outside the page box.
</p>

			</section>
		</section>
	</section>
	<section id="abspos-layout">
<h2 title="Absolute Positioning Layout Model">4. 絶対的~位置決め~layout~model</h2>

<p>
`絶対~位置決め$は、~boxを`~flow外$に取り出すことに加え，~boxを その`包含塊$内に
— 以下に与える
`絶対~位置決め~layout~model@
に則って —
~lay-outする（包含塊の最終的な~sizeが決定された後に）：
◎
Absolute positioning not only takes a box out of flow, but also lays it out in its containing block (after the final size of the containing block has been determined) according to the absolute positioning layout model:
</p>
<ol>
	<li>
<p>
~boxの`~insetで改変された包含塊$を計算する
— `§ 絶対（および固定d）位置決め＠#abspos-insets$を見よ。
◎
First, its inset-modified containing block is calculated, defining its available space. (See § 3.5 Absolute (and Fixed) Positioning.)＼
</p>
<p>
この結果が~boxに`可用な空間$を定義する。
これは常に，`確定的$な~sizeになる
— `絶対~位置決め$には，`包含塊$の~sizeに対する効果は無いので。
◎
Because an absolutely positioned box can have no effect on the size of its containing block, its available space is always definite.
</p>
	</li>
	<li>
<p>
前~段で得られた`可用な空間$を基準に，~boxの~size（横幅, 縦幅）を
— `§ 絶対的に位置された~boxの自動的な~size＠#abspos-auto-size$
に従う下で —
次の結果として解決する
⇒
`max^op( `min^op( ~boxの`選好d~size$, ~boxの`最大~size$ ), ~boxの`最小~size$ )
</p>

<p>
ただし：
</p>
<ul>
	<li>
［
最大~size／最小~size
］が無い場合は［
無限大／ 0
］と見做す。
</li>
	<li>
百分率は、`包含塊$の元の~sizeを基準に解決する。
</li>
</ul>
◎
Next, its width and height are resolved against this definite available space, as its preferred size capped by its maximum size (if any), floored by its minimum size. See § 4.1 Automatic Sizes of Absolutely-Positioned Boxes. Percentages, however, are resolved against the original containing block size.
</li>
	<li>
~marginに対する値 `auto^v を計算する
— `§ 絶対的に位置された~boxの自動~margin＠#abspos-margins$を見よ。
◎
Then, the value of any auto margins are calculated, see § 4.2 Auto Margins of Absolutely-Positioned Boxes.
</li>
	<li>
~boxの`~margin~box$を、`~insetで改変された包含塊$の中で
— ~boxの`自己-整列~prop$に定義されるとおりに —
整列する。
◎
Lastly, its margin box is aligned within the inset-modified containing block as defined by its self-alignment properties.
</li>
</ol>

		<section id="abspos-auto-size">
<h3 title="Automatic Sizes of Absolutely-Positioned Boxes">4.1. 絶対的に位置された~boxの自動的な~size</h3>

<p>
`絶対的に位置され$た~box %~box の所与の軸 %軸 における`自動的~size$は、
%~box の`~insetで改変された包含塊$を基準に（`~margin$に対する `auto^v は 0 と扱う下で）解決される†
— それは：
◎
The automatic size of an absolutely positioned box is resolved against its inset-modified containing block as follows (treating auto margins as zero):
</p>
<ul>
	<li>
<p>
次のいずれかが満たされるならば %~box の`伸張して収まる~size$になる：
</p>
		<ul>
			<li>
%自己-整列~値 ~EQ `stretch$v
</li>
			<li>
［
%自己-整列~値 ~EQ `normal$v
］~AND［
%~box は`置換され$ない
］~AND［
%~box は`~table包装~box$でない
］~AND［
%~box の %軸 における`~inset~prop$はどちらも `auto$v でない
］
</li>
		</ul>
<p>
ここで， %自己-整列~値 は、
%~box の %軸 における`自己-整列~prop$の値とする。
</p>
◎
If its self-alignment property in the relevant axis is stretch
◎
Or if it is normal and the box is non-replaced, not a table wrapper box, and has no auto inset in the relevant axis
• Its automatic size is its stretch-fit size.
</li>
	<li>
~ELSE_
%~box の`内容が収まる~size$になる。
◎
Otherwise
• Its automatic size is its fit-content size.
</li>
</ul>

<p class="trans-note">【†
すなわち、［
伸張して収まる~size／内容が収まる~size
］を計算するときには、`可用な空間$として
%~box の`~insetで改変された包含塊$を利用し，
%~box の`~margin~prop$に対する値 `auto^v は 0 と扱うとする。
】</p>

<p>
ただし， %~box が縦横比を伴う場合、
`縦横比に依存する軸$における`自動的~size$は，代わりに`最大-内容~size$として解決される。
両~軸とも`自動的~size$にされたときの`縦横比に依存する軸$は、［
~insetが片方の軸に限り `auto$v の場合は その軸／
~ELSE_ `塊-軸$
］になる。
`縦横比に依存しない軸$における`自動的~size$は、上述したとおりに決定される。
◎
However, if the box has an aspect-ratio, then an automatic size in the ratio-dependent axis is instead resolved as a max-content size. When both axes have an automatic size, if only one axis has an auto inset then that axis is the ratio-dependent axis, else the block axis is the ratio-dependent axis. An automatic size in the ratio-determining axis is determined as above.
</p>

<p>
`絶対的に位置され$た~boxの`自動的な最小~size$は常に 0 になるとする。
◎
The automatic minimum size of an absolutely-positioned box is always zero.
</p>

		</section>
		<section id="abspos-margins">
<h3 title="Auto Margins of Absolutely-Positioned Boxes">4.2. 絶対的に位置された~boxの自動~margin</h3>

<p>
`絶対的に位置され$た~box %~box の`~margin$に対する【算出d値】 `auto^v は、各~軸ごとに，以下に従って解決する
— 以下における［
~size／~margin／~inset~prop
］は，関連な軸における それらを指すとする：
◎
↓</p>

<ol>
	<li>
%~box の始端, 終端どちらかの`~inset~prop$は `auto$v の場合
⇒
0 になる
◎
If either inset property in the relevant axis is auto, then any auto margins resolve to zero.
</li>
	<li>
<p>
他の場合
— 以下における %残りの空間 は［
%~box の`~insetで改変された包含塊$の~sizeから %~box の使用~sizeを引いた結果
］とする：
</p>
		<ul class="switch">
			<li>
<p>
両~marginとも `auto^v の場合：
</p>
					<ul class="switch">
						<li>
［
当の軸は %~box の`包含塊$の（`書字~mode$に基づく）`行内-軸$である
］かつ［
%残りの空間 は負である
］場合
⇒
始端~marginは 0 になり，終端~marginは %残りの空間 になる
</li>
						<li>
他の場合
⇒
両~marginとも %残りの空間 の半分になる
</li>
				</ul>
			</li>
			<li>
片方の~marginだけ `auto^v の場合
⇒
その~marginが %残りの空間 になる
</li>
		</ul>
◎
Otherwise, the remaining space is calculated as the size of its inset-modified containing block in the relevant axis minus the box’s used size in the relevant axis, and this remaining space is divided among any auto margins in the relevant axis. However, (all with respect to the writing mode of the containing block), if in the inline axis the remaining space is negative and both margins are auto, the start margin resolves to zero and the end margin receives the remaining space.
</li>
</ol>

		</section>
	</section>
	<section id="abspos-old">
<h2 title="Old Absolute Positioning Layout Model">5. 旧- 絶対~位置決め~layout~model</h2>

<p class="issue">
この節は、新たな
`§ 絶対~位置決め~layout~model＠#abspos-layout$
により置換されているが、比較~用にここに保全されている【~CSS 2 による定義と同じ】。
`横組み$かつ，~boxの`自己-整列$は
`normal$v である下では、どちらの~modelからも，同じ結果が得られるベキである。
◎
This section is being replaced with the new § 4 Absolute Positioning Layout Model section. It is preserved here for comparison: both models should yield the same result in horizontal writing modes when the box’s self-alignment is normal.
</p>

<div>
<p>
以下の各 下位~節では、`絶対的に位置され$た要素に対し，関係する各種（当の下位~節に挙げる）~propの`算出d値$から`使用~値$を得る方法を，次を通して定義する：
</p>

<ul>
	<li>
不定を表す算出d値 `auto^v を，当の下位~節に与える等式により拘束される下で 確定的な長さに解決する
</li>
	<li>
非 `auto^v 値により拘束され過ぎになる事例を取扱う
</li>

</ul>
◎
↓↓</div>

<p class="trans-note">【
見通しを良くするため，この訳では、この節に定義される各種~algoにおける原文の場合分けを一部 組み替えて，同じ結果を得るように改変している。
加えて、一部の節の~algoは，他の節の~algoを利用するよう簡素化している。
】</p>

		<section id="abs-non-replaced-width">
<h3 title="The Width of Absolutely-Positioned, Non-Replaced Elements">5.1. 絶対的に位置された置換されない要素の横幅</h3>

<div>
<p>
この節では、関係する各種~propの値を次の変数で表す：
</p>

<ul>
<li>%W = `width$p
<li>%L = `left$p
<li>%R = `right$p
<li>%B = `bottom$p
<li>%mL = `margin-left$p
<li>%mR = `margin-right$p
</ul>

<p>
これらの変数の値は、初期~時には，対応する~propの`算出d値$に設定されているとする。
結果の`使用~値$は、次の等式による拘束を満たさなければならない：
</p>

<ul>
	<li>
( %L ~PLUS %W ~PLUS %R ) ~PLUS ( %mL ~PLUS %mR ) ~PLUS %BP = `包含塊$の横幅
</li>
	<li>
%BP は、次に挙げる~propの`算出d値$の総和を表す（常に確定的）
⇒＃
`border-left-width$p,
`padding-left$p,
`padding-right$p,
`border-right-width$p
</li>
</ul>

<p>
以下に現れる，
“%X について等式を解く”
という句は、［
上に挙げた変数のうち，
%X 以外の変数は どれも非 `auto^v 値に解決されている
］ことの表明, および
%X の値を［
%X について上の等式を解いた結果
］に設定することを意味する。
</p>

◎
The constraint that determines the used values for these elements is:
◎
left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = width of containing block
</div>

<div>

<ol>
	<li>
<p>
~IF［
%L ~EQ `auto^v
］~OR［
%R ~EQ `auto^v
］：
<p>
		<ol>
			<li>
~IF［
%mL ~EQ `auto^v
］
⇒
%mL ~SET 0
</li>
			<li>
~IF［
%mR ~EQ `auto^v
］
⇒
%mR ~SET 0
</li>
	<li>
<p>
~IF［
%W ~EQ `auto^v
］
⇒
%W ~SET `内容が収まる~size$
</li>
			<li>
<p>
~IF［
%L ~EQ `auto^v
］~AND［
%R ~EQ `auto^v
］：
<p>
				<ol>
					<li>
%D ~LET `静的~位置~用の包含塊$を確立している要素の `direction$p ~propの値
</li>
					<li>
~IF［
%D ~EQ `ltr^v
］
⇒
%L ~SET 左端からの`静的~位置$
</li>
					<li>
~ELSE（ %D ~EQ `rtl^v ）
⇒
%R ~SET 右端からの`静的~位置$
</li>
				</ol>
			</li>
			<li>
~IF［
%L ~EQ `auto^v
］
⇒
%L について等式を解く
</li>
			<li>
~ELSE（ %R ~EQ `auto^v ）
⇒
%R について等式を解く
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
~Assert：
［
%L ~NEQ `auto^v
］~AND［
%R ~NEQ `auto^v
］
</li>
	<li>
<p>
~IF［
%W ~EQ `auto^v
］：
</p>
		<ol>
			<li>
~IF［
%mL ~EQ `auto^v
］
⇒
%mL ~SET 0
</li>
			<li>
~IF［
%mR ~EQ `auto^v
］
⇒
%mR ~SET 0
</li>
			<li>
%W について等式を解く
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
%D ~LET 包含塊の `direction$p ~propの値
</li>
	<li>
<p>
( %mL, %mR ) に応じて：
</p>
		<ul class="switch">
			<li>
<p>
( `auto^v, `auto^v )：
</p>
				<ol>
					<li>
%m ~LET ( %mL ~PLUS %mR ) について等式を解いた結果
</li>
					<li>
~IF［
%m ~GTE 0
］
⇒
( %mL, %mR ) ~SET ( %m ~DIV 2, %m ~DIV 2 )
【これは、~boxを横方向に中央寄せにする。】
</li>
					<li>
~ELIF［
%D ~EQ `ltr^v
］
⇒
( %mL, %mR ) ~SET ( 0, %m )
</li>
					<li>
~ELSE（ %D ~EQ `rtl^v ）
⇒
( %mL, %mR ) ~SET ( %m, 0 )
</li>
				</ol>
			</li>
			<li>
( `auto^v, 非 `auto^v )
⇒
%mL について等式を解く
</li>
			<li>
( 非 `auto^v, `auto^v )
⇒
%mR について等式を解く
</li>
			<li>
( 非 `auto^v, 非 `auto^v )
（この事例は拘束され過ぎ）
⇒
%D に応じて
⇒＃
`ltr^v ならば（ %R の値は無視して） %R について等式を解く／
`rtl^v ならば（ %L の値は無視して） %L について等式を解く
</li>
		</ul>
	</li>
</ol>

◎
If all three of left, width, and right are auto: First set any auto values for margin-left and margin-right to 0. Then, if the direction property of the element establishing the static-position containing block is ltr set left to the static position and apply rule number three below; otherwise, set right to the static-position and apply rule number one below.
◎
If none of the three is auto: If both margin-left and margin-right are auto, solve the equation under the extra constraint that the two margins get equal values, unless this would make them negative, in which case when direction of the containing block is ltr (rtl), set margin-left (margin-right) to 0 and solve for margin-right (margin-left). If one of margin-left or margin-right is auto, solve the equation for that value. If the values are over-constrained, ignore the value for left (in case the direction property of the containing block is rtl) or right (in case direction is ltr) and solve for that value.
◎
Otherwise, set auto values for margin-left and margin-right to 0, and pick one of the following six rules that apply.
• If left and width are auto and right is not auto, then the width is shrink-to-fit. Then solve for left.
• If left and right are auto and width is not auto, then if the direction property of the element establishing the static-position containing block is ltr set left to the static-position, otherwise set right to the static-position. Then solve for left (if direction is rtl) or right (if direction is ltr).
• If width and right are auto and left is not auto, then the width is shrink-to-fit. Then solve for right.
• If left is auto, width and right are not auto, then solve for left.
• If width is auto, left and right are not auto, then solve for width.
• If right is auto, left and width are not auto, then solve for right.

◎
Summary of rules for dir=ltr in horizontal writing modes Is auto?

Result

left 	width 	right 	margin-left 	margin-right
✔ 	✔ 	✔ 	any 	

    auto margins → zero
    left → static pos
    width → shrink-to-fit
    right → solve 

✘ 	✘ 	✘ 	✔ 	✘ 	auto margin → free space
✘ 	✔
✔ 	✔ 	

    margins split positive free space
    right margin gets negative free space 

✘ 	✘ 	treat right as auto
✔ 	✘ 	✔ 	any 	

    auto margins → zero
    left → static pos
    width → as specified
    right → solve 

✔ 	✔ 	✘ 	any 	

    auto margins → zero
    left → solve
    width → shrink-to-fit
    right → as specified 

✘ 	✔ 	✔ 	any 	

    auto margins → zero
    left → as specified
    width → shrink-to-fit
    right → solve 

✔ 	✘ 	✘ 	any 	

    auto margins → zero
    solve for auto 

✘ 	✘ 	✔
✘ 	✔ 	✘
</div>

		</section>
		<section id="abs-replaced-width">
<h3 title="The width of absolute or fixed positioned, replaced elements">5.2. 絶対的に位置された置換d要素の横幅</h3>

<p>
`auto^v 値をとる %W を`置換d要素の~sizing$に従って解決した上で、
`前節＠#abs-non-replaced-width$を適用する。
◎
If height and width both have computed values of auto and the element also has an intrinsic width, then that intrinsic width is the used value of width.
◎
If height and width both have computed values of auto and the element has no intrinsic width, but does have an intrinsic height and intrinsic ratio; or if width has a computed value of auto, height has some other computed value, and the element does have an intrinsic ratio; then the used value of width is:
◎
(used height) * (intrinsic ratio)
◎
If height and width both have computed values of auto, the element has an intrinsic ratio but no intrinsic height or width, and the containing block’s width does not itself depend on the replaced element’s width, then the used value of width is calculated from the constraint equation used for block-level, non-replaced elements in normal flow.
◎
Otherwise, if width has a computed value of auto, and the element has an intrinsic width, then that intrinsic width is the used value of width.
◎
Otherwise, if width has a computed value of auto, but none of the conditions above are met, and then the used value of width becomes 300px. If 300px is too wide to fit the device, user agents should use the width of the largest rectangle that has a 2:1 ratio and fits the device instead.
◎
After establishing the width, in order to position the replaced element, apply the following rules as appropriate.
• If both left and right have the value auto, and if the direction property of the element establishing the static-position containing block is ltr, set left to the static position and solve for right; else if direction is rtl, set right to the static position and solve for left.
• If left is auto and right is not auto, replace any auto on margin-left or margin-right with 0, then solve for left.
• If right is auto and left is not auto, replace any auto on margin-left or margin-right with 0, then solve for right.
• If at this point both margin-left and margin-right are still auto, solve the equation under the extra constraint that the two margins must get equal values, unless this would make them negative, in which case when the direction of the containing block is ltr (rtl), set margin-left (margin-right) to 0 and solve for margin-right (margin-left).
• If at this point there is an auto remaining, solve the equation for that value.
• If at this point the values are over-constrained, ignore the value for either left (in case the direction property of the containing block is rtl) or right (in case direction is ltr) and solve for that value.
</p>
		</section>
		<section id="abs-non-replaced-height">
<h3 title="The Height Of Absolutely Positioned, Non-Replaced Elements">5.3. 絶対的に位置された置換されない要素の縦幅</h3>

<div>
<p>
この節では、関係する各種~propの値を次の変数で表す：
</p>

<ul>
<li>%H = `height$p
<li>%T = `top$p
<li>%B = `bottom$p
<li>%mT = `margin-top$p
<li>%mB = `margin-bottom$p
</ul>

<p>
これらの変数の値は、初期~時には，対応する~propの`算出d値$に設定されているとする。
結果の`使用~値$は、次の等式による拘束を満たさなければならない：
</p>

<ul>
	<li>
( %T ~PLUS %H ~PLUS %B ) ~PLUS ( %mT ~PLUS %mB ) ~PLUS %BP = `包含塊$の縦幅
</li>
	<li>
ここで， %BP は、次に挙げる~propの`算出d値$の総和を表す（常に確定的）
⇒＃
`border-top-width$p,
`padding-top$p,
`padding-bottom$p,
`border-bottom-width$p
</li>
</ul>

<p>
以下に現れる，
“〜について等式を解く”
という句の意味は、
`§ 横幅＠#abs-non-replaced-width$のそれと同様とする。
</p>

◎
For absolutely positioned elements, the used values of the vertical dimensions must satisfy this constraint:
◎
top + margin-top + border-top-width + padding-top + height + padding-bottom + border-bottom-width + margin-bottom + bottom = height of containing block
</div>

<div>

<ol>
	<li>
<p>
~IF［
%T ~EQ `auto^v
］~OR［
%B ~EQ `auto^v
］：
<p>
		<ol>
			<li>
~IF［
%mT ~EQ `auto^v
］
⇒
%mT ~SET 0
</li>
			<li>
~IF［
%mB ~EQ `auto^v
］
⇒
%mB ~SET 0
</li>
	<li>
~IF［
%H ~EQ `auto^v
］
⇒
%H ~SET `§ 塊~整形~文脈の根に対する自動~縦幅＠~CSS2VISUDET#root-height$に基づいて得られる値
</li>
			<li>
<p>
~IF［
%T ~EQ `auto^v
］~AND［
%B ~EQ `auto^v
］
⇒
%T ~SET 上端からの`静的~位置$
</li>
			<li>
~IF［
%T ~EQ `auto^v
］
⇒
%T について等式を解く
</li>
			<li>
~ELSE（ %B ~EQ `auto^v ）
⇒
%B について等式を解く
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
~Assert：
［
%T ~NEQ `auto^v
］~AND［
%B ~NEQ `auto^v
］
</li>
	<li>
<p>
~IF［
%H ~EQ `auto^v
］
</p>
		<ol>
			<li>
~IF［
%mT ~EQ `auto^v
］
⇒
%mT ~SET 0
</li>
			<li>
~IF［
%mB ~EQ `auto^v
］
⇒
%mB ~SET 0
</li>
			<li>
%H について等式を解く
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
<p>
( %mT, %mB ) に応じて：
</p>
		<ul class="switch">
			<li>
<p>
( `auto^v, `auto^v )：
</p>
				<ol>
					<li>
%m ~LET ( %mT ~PLUS %mB ) について等式を解いた結果
</li>
					<li>
( %mT, %mB ) ~SET ( %m ~DIV 2, %m ~DIV 2 )
【これは、~boxを縦方向に中央寄せにする。】
</li>
				</ol>
			</li>
			<li>
( `auto^v, 非 `auto^v )
⇒
%mT について等式を解く
</li>
			<li>
( 非 `auto^v, `auto^v )
⇒
%mB について等式を解く
</li>
			<li>
( 非 `auto^v, 非 `auto^v )
（この事例は拘束され過ぎ）
⇒
（ %B の値は無視して） %B について等式を解く
</li>
		</ul>
	</li>
</ol>

◎
If all three of top, height, and bottom are auto: First set any auto values for margin-top and margin-bottom to 0, then set top to the static position, and finally apply rule number three below.
◎
If none of the three are auto: If both margin-top and margin-bottom are auto, solve the equation under the extra constraint that the two margins get equal values. If one of margin-top or margin-bottom is auto, solve the equation for that value. If the values are over-constrained, ignore the value for bottom and solve for that value.
◎
Otherwise, set auto values for margin-top and margin-bottom to 0, and pick one of the following six rules that apply.
• If top and height are auto and bottom is not auto, then the height is based on the Auto heights for block formatting context roots, and solve for top.
• If top and bottom are auto and height is not auto, then set top to the static position, then solve for bottom.
• If height and bottom are auto and top is not auto, then the height is based on the Auto heights for block formatting context roots, and solve for bottom.
• If top is auto, height and bottom are not auto, then solve for top.
• If height is auto, top and bottom are not auto, then solve for height.
• If bottom is auto, top and height are not auto, then solve for bottom.
</div>

		</section>
		<section id="abs-replaced-height">
<h3 title="The Height Of Absolutely Positioned, Replaced Elements">5.4. 絶対的に位置された置換d要素の縦幅</h3>

<p>
`auto^v 値をとる %H を`置換d要素の~sizing$に従って解決した上で、
`前節＠#abs-non-replaced-height$を適用する。

◎
If height and width both have computed values of auto and the element also has an intrinsic height, then that intrinsic height is the used value of height.
◎
Otherwise, if height has a computed value of auto and the element has an intrinsic ratio then the used value of height is:
◎
(used width) / (intrinsic ratio)
◎
Otherwise, if height has a computed value of auto and the element has an intrinsic height, then that intrinsic height is the used value of height.
◎
Otherwise, if height has a computed value of auto, but none of the conditions above are met, then the used value of height must be set to the height of the largest rectangle that has a 2:1 ratio, has a height not greater than 150px, and has a width not greater than the device width.
◎
After establishing the height, in order to position the replaced element, apply the following rules as appropriate.
• If both top and bottom have the value auto, replace top with the element’s static position.
• If bottom is auto, replace any auto on margin-top or margin-bottom with 0.
• If at this point both margin-top and margin-bottom are still auto, solve the equation under the extra constraint that the two margins must get equal values.
• If at this point there is only one auto remaining, solve the equation for that value.
• If at this point the values are over-constrained, ignore the value for bottom and solve for that value.
</p>

		</section>
		<section id="_css2-static-position">
<h3>5.X. 通常~flowの静的~位置</h3>

<p class="trans-note">【
この節（この訳による追加）は、上の各~節にて利用される定義を `CSS2$r から抜き出したものである。
】</p>

<p>
~boxの`静的~位置$は、概ね，~boxが通常~flowに置かれた【`~flow内$にあった】とするときの位置を指す。
より精確には：
◎
For the purposes of this section and the next, the term "static position" (of an element) refers, roughly, to the position an element would have had in the normal flow. More precisely:
</p>
<ul>
	<li>
<p>
~boxの
`静的~位置~用の包含塊@
は、
“仮の~box” の`包含塊$である。
仮の~boxとは、
【当の~boxを生成させる】要素の［
`position$p の指定d値は `static$v,
`float$p の指定d値は `none^v
］であった【すなわち，いずれも初期~値であった】とするとき，要素が生成することになる最初の†~boxである。
（ <a href="~CSS2VISUREN#dis-pos-flo">§ `display^p, `position^p, `float^p の関係性</a>により、この仮の計算は， `display$p も指定d値と異なると見做して行うよう要求され得ることに注意。）
</p>

<p class="trans-note">【†
“最初の”
— ~boxが`行内~box$の場合は、複数~行lに分断される場合における最初の断片を成す~boxと見受けられる。
】</p>

◎
The static-position containing block is the containing block of a hypothetical box that would have been the first box of the element if its specified position value had been static and its specified float had been none.＼
(Note that due to the rules in section 9.7 this hypothetical calculation might require also assuming a different computed value for display.)
</li>
	<li>
要素の静的~位置は、`静的~位置~用の包含塊$の各~辺から， “仮の~box” の同じ側にある`~margin辺$までの距離【~inset】として与えられる。
【すなわち、仮の~boxが，`静的~位置~矩形$を与える。】
これらの~offsetは、仮の~boxが包含塊をはみ出すときは，はみ出した側において負になる。
◎
The static position for left is the distance from the left edge of the containing block to the left margin edge of a hypothetical box that would have been the first box of the element if its position property had been static and float had been none. The value is negative if the hypothetical box is to the left of the containing block.
◎
The static position for right is the distance from the right edge of the containing block to the right margin edge of the same hypothetical box as above. The value is positive if the hypothetical box is to the left of the containing block’s edge.
</li>
</ul>

<p>
しかしながら，~UAは、
仮の~boxの寸法を実際に計算せずに，確からしい位置を推測してかまわない。
◎
But rather than actually calculating the dimensions of that hypothetical box, user agents are free to make a guess at its probable position.
</p>

<p class="trans-note">【
すなわち、 “仮の” ~layoutを実際に遂行することなく。
】【
CSS 2 においては，このように述べられているが、
`§ 自動的な~insetの解決-法＠#staticpos-rect$の記述に従うなら，仮の~boxは［
`塊~levelの~box$であるならば塊~size（ CSS2 においては縦幅）は 0 ／
`行内~levelの~box$であるならば行内~size（ CSS2 においては横幅）は 0
］と見なされることになる。
】</p>

		</section>
	</section>
	<section id="comparison">
<h2 title="Comparison of normal flow, floats, and positioning">6. 通常~flow, 浮動体, 位置決めの比較</h2>

~INFORMATIVE

<p class="trans-note">【
この節の内容は未訳。
】</p>

	</section>
	<section id="ack">
<h2 title="Acknowledgments">謝辞</h2>
<p>
この仕様に~~貢献された次の方々に：
◎
This module would not have been possible without input and support from many helpful people. Thanks to＼
</p>

<p lang="en">
Rossen Atanassov, Bert Bos, Oriol Brufau, Tantek Çelik, Arron Eicholz Sylvain Galineau, John Jansen, Chris Jones, Ian Kilpatrick, Anton Prowse.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p class="trans-note">【
変更-箇所の引用は省略する。
】</p>
<dl>
	<dt>
`2020年 5月 19日 作業草案＠~TR/2020/WD-css-position-3-20200519/$
からの有意な変更点は：
◎
The following significant changes were made since the 19 May 2020 Working Draft:
</dt>
	<dd>
［
縦横比を伴う, `置換され$ない, `絶対的に位置され$た~box
］の自動的~sizingを定義した。
（ `5151$issue ）
◎
Defined automatic sizing of non-replaced absolutely-positioned boxes with an aspect ratio. (Issue 5151
</dd>
	<dd>
自動~marginの解決を`有位置な~box$の`自動的~size$と揃えた。
`CSS2$r
（ `5374$issue, `5077$issue, `5327$issue ）
◎
Aligned resolution of auto margins and automatic sizes of positioned boxes with [CSS2]. (Issue 5374, Issue 5077, Issue 5327)
</dd>

	<dt>
`2016年 5月 17日 作業草案＠~TR/2016/WD-css-position-3-20160517/$
からの有意な変更点は：
◎
The following significant changes were made since the 17 May 2016 Working Draft:
</dt>
	<dd>
仕様~全体を書き直した
— 編集上の明確さ, 技術的な精度, ［
`CSS-ALIGN-3$r,
`CSS-WRITING-MODES-3$r,
`CSS-BREAK-3$r,
`CSS-DISPLAY-3$r
］との互換性を得るため。
◎
Rewrote the whole spec for editorial clarity, technical precision, and compatibility with [CSS-ALIGN-3], [CSS-WRITING-MODES-3], [CSS-BREAK-3], and [CSS-DISPLAY-3].
</dd>
</dl>

	</section>
	<section id="priv-sec">
<h2 title=" Privacy and Security Considerations"> ~privacyと~securityの考慮点</h2>

<p>
この仕様が導入する新たな~privacy考慮点は無い。
◎
This specification introduces no new privacy considerations.
</p>

<p>
攻撃者が任意な~CSSを注入-可能な場合、有位置な~layoutは［
~pageを成す他の任意な要素に~~重ねるように，攻撃者が制御する要素を位置すること
］を より容易にするので，~pageの利用者を騙すことになりかねない。
（この攻撃には、多くの道がある
— 負な `margin$p, `transform$p, 等々。
作者は、~pageのどこかに他者による任意な~CSSを適用させないこと。）
◎
If an attacker is able to inject arbitrary CSS, positioned layout can make it easier to position elements the attacker has control of over arbitrary other elements of the page, potentially tricking users of the page. (There are many routes to this attack: negative margin, transform, etc. Don’t let people apply arbitrary CSS to bits of your page.)
</p>

<p>
`position$p 値 `fixed$v は、~modal~dialogを模倣することを~pageに許容し得る。
それは、利用者を［
~UAとヤリトリしている下で，敏感な情報を手入力している
］と~~錯覚させ，~pageがその情報を捕捉することにもなりかねない。
~UAは、［
自身の~native~dialogは，~pageが模倣し得ない仕方で位置される
］ことを確保するモノトスル
— 特に，少なくとも一部の~dialogは、~web内容を塗れるような “有位置な画素” の外側に来るように。
◎
position: fixed can allow a page to emulate modal dialogs, potentially tricking a user into thinking they’re interacting with the user agent and entering in sensitive information that they page can then capture. User agents must ensure that their native dialogs are positioned in ways that the page cannot emulate; in particular, that at least some of the dialog is outside the "poisoned pixels" that web content can paint to.
</p>

	</section>
</main></div>
