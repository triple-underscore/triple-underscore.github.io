<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web IDL （第 2 版 — 日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>

/* common-*.css を上書き */
*[lang="en"] {
	white-space: pre-line;
}

.advisement { /* 警告 */
	text-align: left;
}

.deprecated {
	background: #FFEECC; /* .advisement と同じ */
	/* color: #9D937D; */
}


pre {
	white-space: pre-wrap;
}

code {
	color: #aa2300; /* #ff4500; 変更 */
}

/* 追加 */

.sym {
	font-weight: bold;
}
.g {
	font-style: italic;
}

.char {
	font-size: 85%
}


/* 節リンク */
.sec::before {
	content: '「';
	color: gray;
}
.sec::after {
	content: '」節';
	color: gray;
}

.input,
.xattr,
.sym {
  font-family: monospace0, monospace;
}
/* 添字 */
sub::before {
	content: ' ';
}


/* 拡張属性 */
.xattr {
	color: purple;
}

/* 生成文法記号 */
.sym {
}

/* IDL, ECMAScript 型／値 */

.idltype,
.idlmember,
.idlvalue,
.es-type,
.es-class,
.es-value {
	font-family: monospace0, monospace;
}

.idltype,
.idlvalue,
.idlmember {
	color: #017;
}
.es-class {
	color: #017;
}

.es-intrinsic,
.es-symbol,
.es-type {
	color: #061;
}
.es-value {
	color: #061;
}

.es-error,
error {
	color: #006633;
}

/* ECMAScript
	プロパティ記述子,
	内部プロパティ ／ well-known symbol,
	intrinsic/prototype object
*/
.descriptor,
.prop {
	color: #061;
}

/* 仮想の定数 */
i.const {
	text-decoration: underline;
}

/* 定義語彙参照 */
.dfnref {
}

	/* コードブロック */
pre {
	margin: 0.5em 0 0.5em 0.5em;
	padding: 0.5em 1em;
}

pre.syntax,
pre.webidl,
pre.es-code,
pre.html-code {
}

pre.webidl,
pre.syntax{
	background:hsl(24, 20%, 95%);
}

pre.es-code {
	background: #FCFADC;
}

/* 引用例 */
blockquote {
	padding: 1px 1em;
	margin-left: 2em;
	margin-right: 2em;
}

.example blockquote {
	background: #f0f6ff;
}

/* 抽象演算 */
.abstract {
	color: green;
}


/* 文法 */
dl.grammar {
	background: #eee;
}
dl.grammar > dt {
	font-weight: normal;
}
dl.grammar > dd {
	margin-left: 6em;
	white-space: pre-line;
}

dl.grammar > dt::after {
	content: " ::";
}

	/* 終端記号 */
#terminals > dd {
	margin-left: 4em;
}

#terminals > dt::after {
	content: " =";
}
#terminals > dd.regex::before,
#terminals > dd.regex::after {
	position:static;
	content: "/";
	color: orangered;
}

/* アルゴリズム */

ol.algorithm,
ol.algorithm ol {
	border-left: 1px solid #90b8de;
}

dd > :first-child {
  margin-top: 0;
}


a.placeholder {
  color: #00e;
}

/* 集合 */
div.set {
  margin-left: 3em;
  margin-bottom: 1em;
  text-indent: -1em;
}

/* Level 2 */
section.L2, /* override :target */
.L2 {
	background: #FEE;
}


/* table */

table {
	border-style:hidden hidden none hidden;
}
table thead {
	border-bottom: solid medium gray;
}

table td, table th {
	border: solid thin gray;
	border-top: none;
	padding:0.2em;
}

	/* 表 整形 */
#matrix-idl-floats th,
#matrix-idl-integers th {
	white-space: nowrap;
}
#matrix-idl-integers td:nth-child(2),
#matrix-idl-integers td:nth-child(3),
#matrix-integers td,
#matrix-integers th {
	text-align: right;
	white-space: nowrap;
}
#matrix-integers th {
	min-width: 4em;
}
#matrix-buffer-sources td:first-child {
	white-space: pre-line;
}

/* 判別表 */

#distinguishable-table > thead {
	border-bottom: 1px solid #90b8de;
}

#distinguishable-table th {
	border: 1px solid #90b8de;
}

#distinguishable-table td {
	border: 1px solid #90b8de;
	text-align: center;
	background: #f0f6ff;
}

#distinguishable-table td[colspan] {
	background: #ddd;
}

#distinguishable-table > tbody > tr > th:first-child {
	text-align: right;
}

@supports (writing-mode: vertical-rl) {
	#distinguishable-table > thead > tr > th > span {
		display: block;
		writing-mode: vertical-rl;
		white-space: nowrap;
		min-width: 1.5em; /* FF bug. 本来は不要 */
	}
}

</style>
<!-- 

/* IDL 構文の参考例 */
pre.syntax {
	background: #ddffdd;
	padding: 1em;
	margin: 1em 2em;
}

/* IDL 構文 
pre.syntax {
	font-weight: bold;
}
pre.syntax em, pre.syntax i { font-weight: normal; }
pre.syntax em { color: red }
*/

 -->


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->

<script>

var source_data = {
	toc_main: 'MAIN0',
};

Util.ready = function(){

	source_data.grammar_tables = buildGrammerTables(),
	Util.switchWordsInit(source_data);
	return;

// 文法ブロック生成
// 逆参照機能があるので、文法一覧 → 本文リンクは省略
	function buildGrammerTables(){
	//
		var g_data = PAGE_DATA.d_grammar_table;
		delete PAGE_DATA.d_grammar_table;
		var g_table = C('dl');

		var lhs = Object.create(null);
		var rhs = Object.create(null);
		var index = 0;//＊

		g_table.className = 'grammar';
		g_table.innerHTML = '<dd>' + g_data
			.replace(/</g, '&lt;')
			.replace(/>/g, '&gt;')
			.replace(/\s(?=[A-Za-z])/g, '$&＠')
			.replace(/"([ -~]+?)"/g, '<span class="sym">$1</span>')
			.replace(/\s*●(\w+)\s*/g, function(t, name){
				lhs[name] = index++;
				return ( '</dd><dt>＠' + name + '</dt><dd>' );
			})
			.replace(/＠(\w+)/g, ' <a class="g" href="#prod-$1">$1</a>')
			+ '</dd>\n'
		;

		g_table.removeChild(g_table.firstChild);

		var dts = g_table.getElementsByTagName('dt');
		var span = C('span');
		span.className = 'g';

		for(var name in lhs){
			var dt = dts.item(lhs[name]);
			rhs[name] = dt.nextElementSibling;
			lhs[name] = dt.cloneNode(true);

			dt.id = 'prod-' + name;
			var s = span.cloneNode(false);
			s.textContent = name;
			dt.replaceChild(s, dt.lastChild);
		}

		return {dom: g_table, dt: lhs, dd: rhs};///
	}
}

/*内容変換生成*/
source_data.generate = function(){

	var link_map = this.link_map;
	var tf_map = { T: 'true', F: 'false', 0: '0', 1: '1' };

	var class_map = {
		g: 'g',
		sym: 'sym',
		char: 'char',
		C: 'const',
		E: 'error',
		jE: 'es-error',
		Ec: 'error',
		T: 'idltype',
		V: 'idlvalue',
		t: 'es-class',
		jv: 'es-value',
		jt: 'es-type',
		jI: 'es-intrinsic',
		jS: 'es-symbol',
		A: 'abstract',
		M: 'idlmember',
		x: 'xattr',
		sl: 'prop',
	};
	var tag_map = {
		g: 'span', // 非終端記号／生成規則
		sym: 'span', // 終端記号
		char: 'span', // Unicode 符号位置
		sup: 'sup',
		c: 'code',
		i: 'i', // i syntax変数
		C: 'i', // 仮想定数
		mk: 'mark', // syntax強調
		E: 'code', // error 名
		Ec: 'code', // error code
		jE: 'code', // ES error 型
		V: 'code', // IDL 値
		T: 'code', // IDL 型
		t: 'code',  // ES class
		jt: 'code',  // ES 型
		jI: 'code', // ES intrinsic/prototype object
		jS: 'code',  // ES well-known symbols
		jv: 'code',  // ES 値
		sl: 'span', // 内部 slot
		A: 'span',  // ES 抽象演算
		M: 'code',  // IDL メンバ
		x: 'span',  // 拡張属性
		var: 'var',  // 変数
	}

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'g':
	href = '#prod-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + key + '</code>"'
	break;
case 'jE':
	href = '#exceptiondef-' + key.toLowerCase();
	break;
case 'E':
	href = '#' + key.toLowerCase();
	break;
case 'Ec':
	href = '#dom-domexception-' + key.toLowerCase();
	break;
case 'T':
	href = '#idl-' + key.replace(/ /g, '-');
	break;
case 'A':
	href = '~TC39#sec-' + key.toLowerCase();
	break;
case 'x':
	href = '#' + key;
	text = '[' + key + ']';
	break;
case 'sec':  // 節
	return '<a class="sec" href="#'+ key +'" >' + ( link_map[ '#' + key] || '＊') + '</a>';
	break;
case 'sl':
	text = '[[' + key + ']]'
	break;
case 'jI':
	text = '%' + key + '%';
	break;
case 'jS':
	href = '~TC39#sec-well-known-symbols';
	text = '@@' + key;
	break;
case 'desc': // ES property descriptor
	return desc(key);
	break;
case 'fI':
	href = 'https://github.com/heycam/webidl/issues/new?title=' + key.replace(/ /g, '%20');
	text = '課題を提出-';
	break;
default:
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}

	function desc(id){// ES プロパティ記述子
		return (
			'{ ' +
			'[[Writable]]: ' + TFmap(id[0]) +
			', [[Enumerable]]: ' + TFmap(id[1]) +
			', [[Configurable]]: ' + TFmap(id[2]) +
			( (id.length > 3) ?
				', [[Value]]: ' + TFmap(id.slice(4)) : ''
			) + 
			' }'
		);
		function TFmap(c){
			var s = tf_map[c];
			return s ?
				'<span class="es-value">' + s + '</span>' : 
				'<var>' + c + '</var>';
		}
	}
}

source_data.populate = function(){

// 内容複製
	duplicate();
	
	function duplicate(){
		var visited = Object.create(null);
		var iter = document.createNodeIterator(
			E('MAIN0'), NodeFilter.SHOW_COMMENT, null, null
		);
		var node;
		while(node = iter.nextNode()){
			var id = node.data;
			if(id.slice(0, 3) !== 'cp-'){
				continue;
			}
			var e = visited[id] || E(id);
			if(!e){
//				console.log(id);
				continue;
			}
			if(!visited[id]){
				e.removeAttribute('id');
//				e.style.outline = 'solid green 1px'
				visited[id] = e;
			}
			e = e.cloneNode(true);
//			e.style.outline = 'dashed green 1px'
			node.parentNode.replaceChild(e, node);
		}
	}


// 文法ブロック
	var G = this.grammar_tables;
	var lhs = G.dt;
	var rhs = G.dd;

	repeat('div.grammar', function(div){
		var dl = C('dl');
		dl.className = 'grammar';
		div.textContent.match(/\w+/g).forEach(function(name){
			if(!(name in lhs)) return;// throw name;
			dl.appendChild(lhs[name].cloneNode(true));
			dl.appendChild(rhs[name].cloneNode(true));
		});
		div.parentNode.replaceChild(dl, div);
	});

	var grammar_table = E('_p-grammar-table');
	grammar_table.parentNode.replaceChild(G.dom, grammar_table);



/* checked: 171012 spec.

	Util.del_j();
	repeat('pre span[title]', function(e){
		e.textContent = e.title;//.replace(/^/gm, '// ');
	});
	repeat('h2, h3, h4, h5', function(e){
		var t = e.title;
		if(!t) return;
		e.textContent = e.textContent.replace(/\. .+/, '. ' + t);
	});
	repeat('dl.grammar > dt', function(e){
		e.insertBefore(C('br'), e.firstChild);
		e.appendChild(document.createTextNode(' ::'));
	});
	repeat('.algorithm li', function(e){
		e.insertBefore(C('br'), e.firstChild);
	});

*/

}



</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Web IDL
spec_date:2017-10-17
trans_update:2017-10-17
original_url:https://heycam.github.io/webidl/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2017,permissive
trans_1st_pub:2013-08-22


●●original_id_map


ol-callable:
ol-optionality-list:
ol-type-list:
dfn-variadic-argument:
dfn-normal-location:
dfn-const-tokens:
	dfn-element-type:
dfn-exception-thrown:
idl-integers:
idl-floats:
dfn-function-like:

	dfn-get-buffer-source-reference:dfn-get-buffer-source-reference-or-copy
	es-DOMException-specialness:es-DOMException-constructor-object
	es-DOMException-specialness:es-DOMException-prototype-object
	idl-DOMException:dfn-DOMException

normative:normative-references
informative:informative-references

●●words_table1

WEBGLEXT:https://www.khronos.org/registry/webgl/extensions
GEOLOCATION:https://www.w3.org/TR/geolocation-API/

throwTypeError:<a href="#ecmascript-throw"><b>THROW</b></a> <a href="https://tc39.github.io/ecma262/#sec-native-error-types-used-in-this-standard-typeerror"><code class="error">TypeError</code></a>
SLASH:<code class="sym">/</code>

REPLACEMENT:<span class="char">U+FFFD REPLACEMENT CHARACTER</span>
record_KV:<span class="idltype">record&lt;<var>K</var>, <var>V</var>&gt;</span>

GEOMETRY:geometry-ja.html
FULLSCREEN:https://fullscreen.spec.whatwg.org/

DOMException:<span class="idltype">DOMException</span> 
promise_T:<span class="idltype">Promise&lt;<var>T</var>&gt;</span>
sequence_T:<span class="idltype">sequence&lt;<var>T</var>&gt;</span>
FrozenArray_T:<span class="idltype">FrozenArray&lt;<var>T</var>&gt;</span>
toJSON: <code>toJSON</code> 
varT:<var>T</var>
iterator0:<span class="prop">@@iterator</span>


●●words_table


IDL:
ES:ECMAScript
JS:JavaScript
DOMException:
名前:name::~
名:name::~
値:value::~
型:type::~
有型:typed::~
	種別:type:~
ifc:interface::::インタフェース
mixin:
partial:
host:
obj:object::::オブジェクト
prop:property::::プロパティ
data-prop:data property::::データプロパティ
meth:method::::メソッド
内部:internal::~
algo:algorithm::アルゴリズム
辞書:dictionary::~::ディクショナリ
record:::::レコード
ns:namespace::名前空間
列挙:enumeration::~
列挙不可:unenumerable::~
列挙可能:enumerable::~
列挙-:enumerate::~
連列:sequence::~::シーケンス
	sequence:::並び
原型:prototype::::プロトタイプ
原型鎖:prototype chain::::プロトタイプチェイン
tok:token:::トークン

随意:optional::::オプショナル
	随意の:optional::::オプショナル
	随意~引数
省略可否:optionality::~
	随意~性:optionality
省略可:optional::~
必須:required::~
必須の:required::~
	~~不可欠:required to
	必須:non-optional
引数:argument:~
引数個数:argument count:~
可変個:variadic::~
可変個の:variadic な::~
	可変個の引数をとる:variadic
	可変個
	可変個~引数:variadic argument:
固定長:fixed length:~

判別-:distinguish:~
判別可能:distinguishable:~
判別引数:distinguishing argument:~

mb:member:::メンバ
文字列:string::~
演算:operation::~
演算-:operate::~
演算子:operator::~
関数:function::~
組込みの:built-in::~
例外:exception::~
単純例外:simple exception::~
変換-:convert::~
変換:conversion::~
属性:attribute::~::アトリビュート
拡張属性:extended attribute::~::拡張アトリビュート

定義-:define:~
定義:definition:~
	再~定義-:redefine
未定義:undefined:~
	〜により定義される:-defined
定義済み:predefined:~

返値:return value::返り値
返値型:return type::返り値型
返す:return する::~
返る:return する::~
返され:return され::~
返さな:return しな::~
返し:return し::~
返せる:return できる::~
	int_t:integer 型::整数型
固有型:specific type::~
内縁:inner::~::インナー
最内縁の:innermost::~::最インナーの
	最も内縁:innermost
共用体:union:::~:ユニオン
promise:
凍結-:freeze::~
凍結:frozen::~
実数:numeric::~
整数:integer::~
無符号:unsigned:::符号なし
有符号:signed:::符号あり

配列:array:::~
既定:default:::~:デフォルト
既定の:default:::~:デフォルト
呼戻:callback::::コールバック
呼戻子:callback::::コールバック
index:::::インデックス
indexing:::index アクセス::インデクシング
有index:indexed::有 index::有インデックス
有名:named::~
keyword::::キーワード
pdesc:Property Descriptor::property 記述子::プロパティデスクリプタ
	descriptor::::記述子:デスクリプタ
field::::フィールド
instance::::インスタンス
nullable:
view:::::ビュー
class:::::クラス
JSON:
多重定義:overload::~::オーバーロード
	多重定義:overloading
有効:effective:~
	有効~多重定義~集合:effective overload set
継承-:inherit::~
継承:inheritance::~
	継承していない:non-inherited
	多重~継承:multiple inheritance
被継承:inherited::継承
	継承-先の:inherited
階層:hierarchy:~
UA:user agent::UA::ユーザエージェント
利用者:user:::~:ユーザ
platform:::::プラットフォーム
予約-:reserve:~
予約済み:reserved:~
	予約-済みの:reserved
識別-:identify::~
識別子:identifier::~
構築子:constructor:::~:コンストラクタ
取得子:getter:::~:ゲッタ
設定子:setter:::~:セッタ
削除子:deleter:::~:デリータ
文字列化子:stringifier:::~
文字列化-:stringify:::~
文字列化:stringification:::~
旧来の:legacy:::~
	LegacyWindowAlias:legacy window alias
map:::::マップ
set:::::セット
stack:::::スタック
slot:::::スロット
buffer:::::バッファ
source:::::ソース
maplike:::map 類::マップ類
setlike:::set 類::セット類
反復子:iterator:::~:イテレータ
反復-:iterate:::~:イテレート
反復:iteration:::~:イテレーション
反復値:iterated value:iterated 値::~:イテレート値
可反復:iterable:::~:イテラブル

状態:state:~
target:

投出:throw::~
定数:constant::~::コンスタント
正則:regular:::~:レギュラー
静的:static:::~:スタティック
特殊:special:::~:スペシャル
有限:finite::~
無限:infinity::~
単精度:single-precision::~
倍精度:double-precision::~
浮動小数点:floating point::~
浮動小数点数:floating point number::~
片:fragment:~:::フラグメント
部分的:partial::~::パーシャル
首:primary::主
中途完了:abrupt completion::~
正常完了:normal completion::~
完了record:Completion Record::完了 record

符号単位:code unit::~::コードユニット
support::::サポート
被support:supported::被 support:被サポート
message::::メッセージ
読専:readonly:::~
	読み取り専用
	//EN dash
可書:read–write:::読み書き可能
catch:::::キャッチ
primitive:::::プリミティブ
bit::::ビット
callable:
call:
	~call元:caller
真偽:boolean::~
自前の:own::~
native:::::ネイティブ
大域:global:::~:グローバル
環境:environment:~
大域環境:global environment:global 環境:~::グローバル環境
形:form::~
key:::::キー
value:::::値
	//EN dash
key-value:key–value pair::key–value ペア::{キー：値} ペア

言語束縛:language binding:言語 binding:~::言語バインディング
pair::::ペア
data::::データ
literal::::リテラル
escape::::エスケープ
平坦化:flat 化::~
	flattened
公開-:expose::~
	exposition
公開:exposure::~
変更:change::~
改変-:modify::~
改変:modification::~
偽装不可:unforgeable::~::アンフォージャブル
参照:reference::~
	相互に参照しあう:mutually referential
accessor::::アクセサ
access::::アクセス
list::::リスト
空:empty:~
空の:empty:~
文:statement:~
集合:set::~::セット
和集合:union::~
下位集合:subset::~::サブセット
交差集合:intersection::~

block::::ブロック
code::::コード

error::::エラー
script::::スクリプト
trace::::トレース
scope::::スコープ
octet::::オクテット

現任の:incumbent::~
exotic:
proxy:
bind:
Realm:
configurable:
typedef:
普通の:ordinary::~

保安:security::~:セキュリティ
保安的:secure::~:セキュア
	保安的でない:insecure
注釈文:prose::~::プローズ
隠蔽:shadow:~
言語:language:~
合致:match::~::マッチ
	時間:time
	時間切れ:timed out
	時間差:amount of time
	ミリ秒数:number of milliseconds
	起点:epoch
変数:variable:~
複製:copy:~
entry::::エントリ
item::::アイテム
長さ:length:~
writable:::書き込み可能
妥当:valid:~
	invalid
解決:resolution::~::レゾリューション
解決-:resolve::~::リゾルブ
伝播-:propagate:~
要素:element:~
表現-:represent:~
	表現:representation:~
文脈:context::~
評価-:evaluate:~
等価:equivalent:~
特徴:characteristics:~
strict-mode:strict mode
byte::::バイト
loop:::ループ
tuple::::タプル
一意:unique:~
size::::サイズ
検索:lookup::~::ルックアップ
worker:
window:

内在的:intrinsic::~
新たな:new:~
既存の:existing:~

	●動詞
back:
充足-:fulfill::~
却下-:reject::~
却下:rejection::~
事由:reason::~
決着-:settle::~
初期:initial::~
未初期化の:uninitialized::~
代入-:assign::~
代入:assignment::~
設定-:set::~
設定:setting::~
設定群:settings::~
取得-:get::~
取得:getting::~
取得0-:retrieve:取得
取得0:retrieving:取得
取得1:retrieval:取得
削除-:delete::~
削除:deletion::~
作成-:create::~
作成:creation::~
除去-:remove::~
付加-:append::~
決定-:determine:~
追加-:add:~
追加:addition:~
追加の:additional:~
追加で:additional に:~
試み:attempt:~
試みて:attempt して:~
試みる:attempt する:~
試みた:attempt した:~
試みさ:attempt さ:~
試みら:attempt さ:~
走らせ:run し:~
走らさ:run さ:~
走らす:run する:~

呼出す:invoke する::呼び出す
呼出せる:invoke できる::呼び出せる
呼出され:invoke され::呼び出され
呼出して:invoke して::呼び出して
呼出した:invoke した::呼び出した
呼出し:invoking::呼び出し
呼出そう:invoke しよう::呼び出そう
呼出:invocation::呼び出し
被呼出時:被 invoke 時::~
	when invoked
渡され:pass され:~
渡す:pass する:~
渡し:pass し:~
渡して:pass して:~
渡した:pass した:~
渡さず:pass せず:~
渡せる:pass できる:~
値渡し:passed by value:value 渡し:~

	受け~~渡-:send and receive
	~~渡しで:で pass by され
	渡り
結付けら:associate さ:結び付けら
	結付け:association:結び付け
	結付けて:associate して:結び付けて
結付ける:associate する:結び付ける
現れる:appear する:~
現れて:appear して:~
現れ:appear し:~
	appearance
出現:appearing:~
扱う:treat する:~
扱わな:treat しな:~
扱われ:treat され:~
扱える:treat できる:~
	扱い:treatment:~
	扱っ:treat し:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
取扱える:handle できる:取り扱える
	利用:use:~
	用いる:use する:~
	用いら:use さ:~
	用いて:use して:~
	利用~中:in use
	用法:usage
存在-:exist:~
	有無:existence
在する:present する:在る
存在t:presence:存在
不在:not present:~

置換-:replace:~
制御:control:~
構築-:construct::~
構築:construction::~
連結:concatenation:~
連結-:concatenate:~
	連結-:prepended
無視-:ignore:~
束縛-:bind:~
符号化-:encode::~::エンコード
復号-:decode::~::デコード
符号化方式:encoding::~::エンコーディング
更新:update:~
検査:check:~:::チェック
上書き:override:~
破棄-:discard:~
失敗-:fail:~
分割-:split:~
分離-:separate:~
区切る:separate する:~
区切らな:separate しな:~
区切られ:separate され:~
区切りの:-separated:~
先送り:defer:~
省略-:omit:~
	~~省略:missing:~
正準化-:canonicalize:~
強制-:coerce:~
選定-:select:~
選定:selection:~
格納-:store:~
格納済み:stored:~
保持-:hold:~
保有-:keep:~
照会-:query:::~:クエリ
成功-:succeed:~
登録-:register:~
完了-:complete:~
完了:completion:~
完全:complete:~
変化-:change:~
切離す:detach する::切り離す
切離され:detach され::切り離され
観測-:observe:~
見出され:find され:~
見出せ:find でき:~
見出した:find した:~
転送-:forward:~
準備-:prepare:~
収集-:collect:~
	転換-:turn into
pop:
push:
内包-:include::~
includes:

	●構文／文字
scalar:::::スカラー
構成子:constructs:~
文字:character:~
	大小:case:~
	大文字:uppercase letter:~
	小文字:lowercase letter／lowercase:~
pattern::::パタン
宣言:declaration::~
宣言-:declare::~
範囲:range:~
	範囲~外:out-of-range
符号位置:code point::~::コードポイント
構文:syntax::~::シンタックス
文法:grammar:~:::グラマー
記号:symbol:~:::シンボル
symbol:
終端記号:terminal symbol:~:::ターミナルシンボル
構文解析-:parse::~::パース
	構文解析-時:parsing
構文解析器:parser::~::パーサ
引用符:quotes:~:::クォート
	引用符で括られ:quote され:~
正規表現:regular expression:~
生成規則:production:~
	0:zero
surrogate::::サロゲート
	代用対:surrogate pair
式:expression:~
	:::エクスプレッション
注釈付きの:annotated::~
注釈付き:annotated::~
注釈-:annotate::~
注釈:annotation::~

Unicode:
UTF-16:
UTF-8:
接尾辞:suffix:~
接頭辞:prefix:~
単語:word:~
命名法:naming scheme:~
最長合致:longest possible match:~
等号:equals sign:~
semicolon:::セミコロン
colon:::コロン
comma:::カンマ
dash:::ダッシュ
波括弧:braces:~
丸括弧:parenthesis:~
角括弧:square brackets:~
山括弧:angle brackets:~
	括弧対:balanced brackets
辞書式:lexicographic:~

	●仕様
Web:
	web:Web
API:
custom::::カスタム
特色機能:feature::~::フィーチャ
	省略符:ellipsis
仕様:spec:~
	仕様~化:specify
特有:specific:~
特有の:specific な:~
特定の:specific な:~
特定的:specifical:~
文書:document:~
暗黙的:implicit:~
明示的:explicit:~
付録:Appendix:~
標準:standard:~
	標準でない:non-standard
相互運用性:interoperability:~
level:::レベル
互換性:compatibility:~
互換:compatible:~
技術報告:technical reports:~
独立:independent:~
通用する:agnostic な:~
将来:future:~
bug:::バグ
	リンク:link:~
規範的:normative:~
規範:normative:~
	参考:informative:~
詳細:details:~
意味論:semantics:~:::セマンティクス
意味論的:semantic:~:::セマンティック
判定基準:criteria:~
記法:notation:~
	表記-:notation:~
手続き:steps:~
下位手続き:substeps:~
	手続き:action
系列:variety:~
便宜性:facility:~
実質的:effective:~
	実質的:In effect,
共通の:common:~
共通する:common な:~
共通的に:common に:よく
共通的な:common に:よくある
規約:convention:~
多義性:ambiguity:~
一義化-:disambiguate:~
歴史的:historical:~
状況:situation:~
要請:request:~
一般的な:general:~
一般:general:~
整合性:consistency:~
機能性:functionality:~
実際の:actual:~
実際:actual:~
査読者:reviewer:~
概して:typical に:~
	誤った:wrong
	誤った:erroneous
強く:strong に:~
勧める:suggest する:~
一貫する:consistent になる:~
	終始:consistently
通常通り:as normal に:通常どおり
通常の: normal な:~
	通常~のように:normally
	~~通常:Fine
定例の:regular な
仕方:way:~
用語:term:~
不用意:accidental:~
version:::バージョン
style::::スタイル
方式:manner:~
	~~方式:style
直接的:direct:~
	直に:direct に
間接的:indirect:~
暗黙の:implied:~
形式的:formal:~
略記形:bare form:~
仕組み:mechanism:~
	策定中:underspecified:~
変種:variant:~
相互運用可能:interoperable:~
実施:practice:~
正確:exact:~
略記:shorthand:~
副作用:side effect:~
情報:information:~
適切:appropriate:~
単純:simple:~
効果:effect:~
	効果なし:no effect
不正:incorrect:~
正しく:correct に:~
正しい:correct な:~
	~~正しい right
私的:private:~
交換可能:interchangeable:~
可用:available:~
一義的:unambiguous:~
理由:reason:~
手引き:guide:~
目安:guidance:~
モデル:model::~
クラス:class::~
事例:case:~
相応しく:suitableに:~
編集者:editor:~
精度:precision:~
精確:precise:~
基本的:basic:~
手段:means:~
明瞭:clear:~
目的:purpose:~
有意:significant:~
	有意になる:has significance
概念:concept:~
	~~概念:notion
状況下:circumstance:~
簡便:convenient:~
考慮点:consideration:~
自由:free:~
重要:important:~
今日:today:~
局面:scenario:~
成句的:idiomatic:~
通例的:usual:~
	usually
	通例的でない:unusual
	通例，:usually／usual
	通例の:usual な／
便利:convenience:~
首尾一貫する:coherent な:~
	~~実現できそう:viable solution
	よく見れば:The astute reader may
	同様に:similarly
	似た:similar
	よく似ている:very similar
	少しばかり／もう少し:slightly
	代替の:alternative:~
	~~理由:because
	可能
	必要
	不要
	候補:possible
	可能:possible
	場合によっては／にもなり得る:possibly
	側面:aspect
	具体的な:concrete:~
	分類:categories／
	問題:problem:~
	より問題になる:problem is exacerbated
	難しい:difficult:~
	difficulties
	問題:matter
	孕まれる問題:problematic
	~~問題ない:Fine;
	方法:how
	概略的:Informally
	例:example
	記述例／用例:examples of
	用語例
	編集を補助する:editorial aide
	編集者草案:editor’s draft
	草案:draft:~
	~~自動的:no need to also
	~~確認:checked to ensure
	表記:
	表記規約:typographic convention:~
	謝意
	謝辞:acknowledgements
	因る:due to
	~~例外
	何故
	参照文献
	参考例
	図式:diagram
	~~意図的に:deliberate
	-:be true
	手法:methods
	把握:unaware
	容易く:easily
	休み:unavailable to do so
	もまた，:By extension,
	対照的に:In contrast
	-:terminology
	場合分け
	力:powers
	仮想の:-
	支持を受けて:in favor of
	文献:
	担当グループ:group responsible for work
	必要:need／have to
	もちろん:of course
	選り分ける:reason about
	著しく:remarkably
	最善:best
	より良い／良く:better
	そのようなわけで、:that being said,
	上手く:well に
	稀:rare:~
	相当の:substantial な
	事実:fact
	例えば:perhaps
	足る:sufficient
	あてはまらない:not the case for
	ほとんどの場合:most likely
	模範文例的:boilerplate-
	関わらず:regardless
	そのわけは:This is because
	冗長:verbose:~
	今は無き:defunct
	まかなう:cater

	●仕様（動詞
指定-:specify:~
	他が指定されない限り:unless otherwise specified
実装:implementation:~
実装-:implement:~
実装者:implementor:~
適合:conforming:~
適合性:conformance:~
言明-:state:~
予期-:expect:~
期待-:expect:~
指示-:indicate:~
提供-:provide:~
解釈-:interpret:~
解釈:interpretation:~
解-:understand:~
付随-:accompany:~
影響-:affect:~
反映-:reflect:~
制約-:restrict:~
制約:restriction:~
拘束:constraint:~
要求-:require:~
要件:requirements:~
適用-:apply:~
	適用できる:applicable
推奨-:recommend:~
非推奨:deprecated:~
許容-:allow:~
	許容されない:disallow
依存-:depend:~
受容-:accept:~
波及-:influence:~
記述-:describe:~
記述:description:~
	~~説明:description
述べる:describe する:~
述べら:describe さ:~
述べ:describe し:~
競合-:conflict:~
改称-:rename:~
命名:naming:~
命名-:name:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
挙動し:behave し:ふるまわ
拡張-:extend:~
	拡張-可能:extensible
拡張:extension:~
拡張性:extensibility:~
意図-:intend:~
意図:intent:~
意味され:mean され:意図され
	meant
	意味: mean／meaning／-
	~~意味がある:it makes sense
	~~意味で:in the sense
働く:work する:~
策定者:author:~
作者:author:~
認識-:recognize:~
保証:guarantee:~
心配:concern:~
制限:limitation:~
最適化:optimization:~
設計:design:~:::デザイン
論じた:discuss した:~
論じら:discuss さ:~
論交する:discuss する:論を交わす
説明-:explain:~
説明:explanation:~
遂行-:perform:~
保全-:preserve:~
決める:decide する:~
	decision
見なさ:consider さ:~
考える:consider する:~
考慮-:consider:~
見做す:assume する:~
見做さ:assume さ:~
発行-:publish:~
確保-:ensure:~
奨励-:encourage:~
	しないことが奨励:discourage:~
否認-:deny:~
検分:inspection:~
検分-:inspect:~
単純化-:simplify:~
言及-:mention:~
達成-:accomplish:~
取組まれ:address され:取り組まれ
保守-:maintain:~
出荷-:ship:~
提出-:file:~
課題:issue:~
望む:wish する:~
	望ましくない:undesirable
注記:note:~
警告:warning:~
混同:confusion:~
混同-:confuse:~
特化-:specialize:~
示唆-:suggest:~
適用-:apply:~
選好-:prefer:~
避ける:avoid する:~
開発者:developer:~
併合-:merge:~
	~~併合:conflate
	~~併合:mixed
分類-:categorize:~
分類:category:~
懸念:concern:~
推奨:recommendation:~
援助:aid:~
再現-:replicate:~
相違-:differ:~
相違:differences:~
依拠-:rely:~
要約-:summarize:~
含意-:imply:~
専用の:dedicated:~
移行-:migrate:~
報告-:report:~
変更点:changes:~

	-:plan
	したい:plan
	問い:question:~
	答える:answer する:~
	異なる:different
	加えて:additionally
	意外な:surprising
	伝え:convey
	従う:follow
	気付く／注意:notice
	注意:Note that
	惑わす:confusing
	~~特別な:discriminated
	~~働く:serve
	表出:
	表現力:expressiveness
	表現力のある:expressive
	表す:express
	表す:denote
	見受:
	見通:
	解消:
	集約
	見誤られ:looking like
	~~入力にとる:take
	~~入力の:incoming
	順繰りに挙げ:loop through

	交換可能に:interchangeably
	強調-:highlight
	予測し得ない:unpredictable
	細心の注意を払う必要がある:Extreme care must be taken
	見つけ:look for
	易くする:help
	付与:mark／
	感謝
	~~寄与:adhere／contributing
	課す:impose
	~~調整を通す:coordinate
	混ぜ合わせる:mix and match
	乏しく:decreasing
	無為に:defeat
	~~提供:offer
	とする:suppose
	委ねる:leave
	書き直す:rewrite
	書く:write
	読み難く:less readable
	読める:readable
	読む:read
	見よ:see
	収まる:fit 
	壊-:break
	見える:seem

	●未分類（動詞
変異:mutation::~
変異-:mutate::~
変異不可の:immutable な::~
梱包-:package:~
循環:cycle:~
循環-:cycle:~
片付ける:clean up する:~
派生:derived::~
基底:base::~
順序:order::~
順序付けら:order さ::~
有順序:ordered::~
	昇順
	降順
	昇順／:in ascending numerical order
	作成した順に:in ascending chronological order
実行:execution:~
実行-:execute:~
	実行できる:executable
終端-:end:終了
所在:location:~
所在-:locate:~
対応関係:mapping:~
衝突-:clash:~
encapsulate:::カプセル化
encapsulation:::カプセル化
処理:processing:~
記録-:record:~
算出-:compute:~
計算:computation:~
入子に:nest:入れ子に
開いた:open した:~
読込んだ:load した:読み込んだ
切詰める:clamp する:切り詰める
切詰めら:clamp さ:切り詰めら
	切り詰める:truncate
生成-:generate:~
install::::インストール
	保たれ:keep され:~
	含む総称:encompasses 
共有-:share:~
中止-:abort:~
動作:action:~
操作-:manipulate:~
操作:manipulation:~
整列-:sort:~
検出-:detect:~
	detection
形成-:form:~
組合わせ:combination:組み合わせ
選択子:selector::~::セレクタ
	好ましい:favor
	生じ:occur
	供され:supplied
	置く:place
	前に〜を置く:precede
	対応-:correspond:~
	対応付ける:map する:~／correspond
	合格-:pass:~
	遭遇-:encounter:~
	選ぶ:choose／choice
	重複:duplicates
	~~重複する:overlap
	開始:start
	関係:
	関係無い:unrelated
	なくする:prevent
	listed in 〜／
	含む:include
	指す:refer
	指す:address
	束ねる:bundle する
	用いられる:trigger する
	包含-:contain
	挿入-:insert
	出自に:originate
	実現:done
	変形-:
	導入:
	併用:declared with／
	~~供給-:-
	~~区別-:-
	行われ:carry out
	受け入れる:adopt
	~~捕える:intercept
	組に:coupling
	になる:yielding
	行く:go

	●未分類
group::::グループ
代理:proxy:~
抽象:abstract:~
	抽象~演算
仮数:significand:~
偶数:even:~
protocol:::プロトコル
binary:::バイナリ
network:::ネットワーク
transaction:::トランザクション
database:::データベース
mode:::モード
polyfill:
font::::フォント
singleton:
runtime:
	最小:shortest
	series
基数:base:~
先祖:ancestor:~
単一:single:~
規則:rule:~
入力:input:~
出力:output:~
連鎖:chain:~
可視性判定:visibility:~
不可視:invisible:~
可視:visible:~
特別:special:~
推移的:transitive:~
offset:::オフセット
signature:::シグネチャ
library:::ライブラリ
system:::システム
browser:::ブラウザ
clone:::クローン
主thread:main thread::メインスレッド
project::::プロジェクト
node:::ノード
graph:::グラフ
parameter:::パラメタ
page:::ページ
text:::テキスト
event-handler:event handler:::イベントハンドラ
place-holder:place holder:::プレースホルダ
programming:::プログラミング
program:::プログラム
pointer:::ポインタ
chunk:::チャンク
固定的:fixed:~
構造:structure:~
有向:directed:~
相対的:relative:~
絶対的:absolute:~

非同期:asynchronous:~
	同一性:identity:~
実体:entity:~
表明:assertion:~
計数:counter:~
種類:kind:~
単独の:single:~
作動中:active::~::アクティブ
作動中の:active な::~::アクティブな
記憶域:memory::~::メモリ
木:tree::~::ツリー
下層の:undelying:~
	節:section
	下位~節:sub-section
	表／一覧:table
内容:contents:~
匿名:anonymous:~
数学的:mathematical:~
数学的実数:mathematical real number:~
内側:inside:~
本体:body:~
関連する:relevant な:~
不透明:opaque::~

	~~基準
	等しい:equal
	等距離:equally close／lies halfway between two
	何もしない:no-op
	数値:value
	数字:-
	条件:
	-:just
	姓名:names
	構成-:comprise:~
	段落:paragraph
	矩形:rectangle
	英単語:English word
	英字:letter
	過去:
	2 の補数:two’s complement
	指向:oriented
	グラム／単位
	米／肉／麺／魚／その他:rice／sandwich／noodles／dumplings／other

	●訳／meta
	適当:
	リンク
	原文:-
	総称:-
	~~参照:-
	定訳:-
	対訳:-
	訳者:-
	非公式:-

	●指示語
全部的:full:~
特定0の:particular:ある特定の
	個々の:individual
	所与の:given:与えられた
現在の:current:~
現在:currently:~
	違って:unlike
	最初の:first
	最後の:last
	個目:first／second／third
	結果:result
	素の:bare
	この:this
	これらの:these
	その:that
	すべて:all
	各:each
	別の:another
	そのような:such
	など:such as
	依然として:still
	直後:
	種別:
	多少:
	種:
	項:
	合間:
	余分:
	全体:
	前回:
	前段:
	前述:
	前項:
	既知の:known
	未知の:unknown
	粗い:low
	最低:lowest
	最新の:latest
	最終的:
	最良:
	最長:longest
	次項:
	唯一の:only
	常に:always
	同じ:the same
	後続:
	同様:
	自身:
	複数:
	以上
	以下
	以外
	任意:
	場合:
	部分:parts／
	最大:
	最小:
	類似:
	片方
	一方
	両方同時
	一連
	一部:part of
	一部の:some
	広義
	時点
	この時点:at this point
	末尾
	両／両方／両者:both
	後者:latter
	前者:
	末端:most-derived／
	先頭
	下端:
	右側:right-hand side／right
	左側:left-hand side／left
	合間:between
	元の:original／
	場所:
	一定の／ある種の:certain
	一環:as part of
	一種:
	上述:
	一時的:
	今度:this time
	上限:
	中心:
	即時:immediately
	以前:
	同時:
	周囲:
	左右:
	広範囲:wide
	類:category
	数~段~先:subsequently
	不定:indeterminate
	冒頭:
	頭部:
	最終的:eventual
	一例:
	~~唯一の:sole
	もっぱら:solely
	代わりに／に代えて／~~仮に:instead
	に位置する／の位置:at
	位置:position
	近く:closely
	単に:simply
	回数:how many
	該当:
	他所で:other parts
	まずない:almost never 
	ほとんどの:most
	はるかに:much more
	少ししかない:little to no
	ときには／こともある:sometimes
	9 回重ねる:nine times
	個数:
	個
	1 個だけ:only
	個の:two
	個目:first／second
	個数:length
	先ず，:first
	他方:one other
	他方:On the other hand
	ここでも:again#1
	しかしながら:however
	上:above
	下:below
	他の:other
	別々の:separate
	別個の:distinct
	全く:distinctively
	多い:often
	複数:multiple
	同じ:same
	次の:the following
	およそ:about
	引数を省いた:alone
	さらに／より:further
	より短い:shorter
	通:through
	場合によっては／にもなり得る:possibly
	またがって／:across
	まで:until
	自身:itself
	対象に:target
	以前は:previously
	今や:now
	一つに:together
	と同じく:as with


●●link_map



~THROW:#ecmascript-throw

jI.FunctionPrototype:~TC39#sec-properties-of-the-function-prototype-object
jI.ObjectPrototype:~TC39#sec-properties-of-the-object-prototype-object
jI.ErrorPrototype:~TC39#sec-properties-of-the-error-prototype-object
jI.ArrayPrototype:~TC39#sec-properties-of-the-array-prototype-object
jI.ArrayProto_values:~TC39#sec-array.prototype.values
jI.ArrayProto_forEach:~TC39#sec-array.prototype.foreach
jI.ArrayProto_entries:~TC39#sec-array.prototype.entries
jI.ArrayProto_keys:~TC39#sec-array.prototype.keys
jI.IteratorPrototype:~TC39#sec-%iteratorprototype%-object
jI.Promise:~TC39#sec-promise-constructor
jI.Promise_resolve:~TC39#sec-promise.resolve
jI.Promise_reject:~TC39#sec-promise.reject

jE.SyntaxError:~TC39#sec-native-error-types-used-in-this-standard-syntaxerror

	jt.Undefined
	jt.Null
	jt.Object
	jt.Function
jt.Number:~TC39#sec-ecmascript-language-types-number-type
	jt.Boolean
	jt.String
	jt.Symbol

	// 
t.Map:~TC39#sec-map-objects
t.Set:~TC39#sec-set-objects
t.Promise:~TC39#sec-promise-objects
t.Error:~TC39#sec-error-objects
t.ArrayBuffer:~TC39#sec-arraybuffer-objects
t.DataView:~TC39#sec-dataview-objects
t.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-objects
t.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
t.Number:~TC39#sec-ecmascript-language-types-number-type
t.Array:~TC39#sec-array-objects
	t.Function

i.NumericLiteral:~TC39#sec-literals-numeric-literals
	~TC39#sec-well-known-symbols
	jS.iterator:
	jS.unscopables:
	jS.toStringTag:

oL.~callable:#effective-overload-set-tuple-callable
oL.省略可否~list:#optionality-list
	#dfn-optionality-value
oL.型~list:#type-list

T.WindowProxy:~WINDOW#windowproxy
T.Window:~WINDOW#window
T.WindowOrWorkerGlobalScope:~WAPI#windoworworkerglobalscope
T.Worklet:https://drafts.css-houdini.org/worklets/#worklet
T.CSSRuleList:~CSSOM1#cssrulelist
T.MediaList:~CSSOM1#medialist
T.StyleSheetList:~CSSOM1#stylesheetlist
T.Document:~DOM4#document
T.DocumentOrShadowRoot:~DOM4#documentorshadowroot
T.HTMLCollection:~DOM4#htmlcollection
T.NamedNodeMap:~DOM4#namednodemap
T.fullscreenElement:~FULLSCREEN#dom-document-fullscreenelement
T.fullscreenEnabled:~FULLSCREEN#dom-document-fullscreenenabled
T.DOMMatrix:~GEOMETRY#dommatrix
T.DOMPoint:~GEOMETRY#dompoint
T.DOMRect:~GEOMETRY#domrect
T.DOMRectList:~GEOMETRY#domrectlist
T.DOMStringMap:~HTMLdom#domstringmap
T.EventHandlerNonNull:~WAPI#eventhandlernonnull
T.HTMLAllCollection:~HTML5/common-dom-interfaces.html#htmlallcollection
T.HTMLAudioElement:~HEmedia#htmlaudioelement
T.HTMLFormElement:~HEforms#htmlformelement
T.HTMLImageElement:~HEimages#htmlimageelement
T.HTMLOptionElement:~HEforms#htmloptionelement
T.MimeTypeArray:~HTMLnavigator#mimetypearray
T.Location:~HISTORY#location
T.OnBeforeUnloadEventHandlerNonNull:~WAPI#onbeforeunloadeventhandlernonnull
T.OnErrorEventHandlerNonNull:~WAPI#onerroreventhandlernonnull
T.Plugin:~HTMLnavigator#dom-plugin
T.PluginArray:~HTMLnavigator#pluginarray
T.URL:~URL1#url
T.CSS:~CSSOM1#css
T.CanvasDrawPath:~HEcanvas#canvasdrawpath
T.Path2D:~HEcanvas#path2d
T.CanvasDrawPath:~HEcanvas#canvasdrawpath
T.EventListener:~DOM4#callbackdef-eventlistener

T.DeviceAcceleration:https://w3c.github.io/deviceorientation/spec-source-orientation.html#device_acceleration
T.DeviceRotationRate:https://w3c.github.io/deviceorientation/spec-source-orientation.html#device_rotation_rate
T.ConstrainablePattern:https://w3c.github.io/mediacapture-main/#dom-constrainablepattern
T.ANGLE_instanced_arrays:~WEBGLEXT/ANGLE_instanced_arrays/#angle_instanced_arrays
T.EXT_blend_minmax:~WEBGLEXT/EXT_blend_minmax/#ext_blend_minmax
T.EXT_color_buffer_float:~WEBGLEXT/EXT_color_buffer_float/#ext_color_buffer_float
T.EXT_disjoint_timer_query:~WEBGLEXT/EXT_disjoint_timer_query/#ext_disjoint_timer_query
T.OES_standard_derivatives:~WEBGLEXT/OES_standard_derivatives/#oes_standard_derivatives
T.OES_vertex_array_object:~WEBGLEXT/OES_vertex_array_object/#oes_vertex_array_object
T.WEBGL_compressed_texture_astc:~WEBGLEXT/WEBGL_compressed_texture_astc/#webgl_compressed_texture_astc
T.WEBGL_compressed_texture_s3tc_srgb:~WEBGLEXT/WEBGL_compressed_texture_s3tc_srgb/#webgl_compressed_texture_s3tc_srgb
T.WEBGL_draw_buffers:~WEBGLEXT/WEBGL_draw_buffers/#webgl_draw_buffers
T.WEBGL_lose_context:~WEBGLEXT/WEBGL_lose_context/#webgl_lose_context
T.Coordinates:~GEOLOCATION#coordinates
T.Geolocation:~GEOLOCATION#geolocation
T.Position:~GEOLOCATION#position
T.PositionError:~GEOLOCATION#position-error


M.supports():~CSSCONDITIONAL#dom-css-supports
M.stroke():~HEcanvas#dom-context-2d-stroke
M.onmouseenter:~WAPI#handler-onmouseenter
M.onmouseleave:~WAPI#handler-onmouseleave
M.onreadystatechange:~WAPI#handler-onreadystatechange



~Unicode~scalar値~列に変換-:#dfn-obtain-unicode
~IDL片:#dfn-idl-fragment

A.Type:~TC39#sec-ecmascript-data-types-and-values
A.Get:~TC39#sec-get-o-p
A.Set:~TC39#sec-set-o-p-v-throw
A.LegacyPlatformObjectGetOwnProperty:#LegacyPlatformObjectGetOwnProperty

A.IntegerPart:#abstract-opdef-integerpart
A.ConvertToInt:#abstract-opdef-converttoint
	A.json.stringify:~TC39#sec-json.stringify
A.SetImmutablePrototype:~TC39#sec-set-immutable-prototype

c.JSON.stringify():~TC39#sec-json.stringify

x.*Global:#GlobalOrPrimaryGlobal

引数をとらない:#dfn-xattr-no-arguments
引数~listを引数にとる:#dfn-xattr-argument-list
有名~引数~list:#dfn-xattr-named-argument-list
有名~引数~listを引数にとる:#dfn-xattr-named-argument-list
識別子~listを引数にとる:#dfn-xattr-identifier-list
識別子を引数にとる:#dfn-xattr-identifier
型の~pairを引数にとる:#dfn-xattr-type-pair


~ifc:#dfn-interface
~ifc~mb:#dfn-interface-member
~ns:#dfn-namespace
部分的~ns定義:#dfn-partial-namespace
部分的~ns:#dfn-partial-namespace
~ns~mb:#dfn-namespace-member
~ifc~mixin:#interface-mixin
部分的~ifc~mixin:#partial-interface-mixin
部分的~ifc~mixin定義:#partial-interface-mixin
~ifc~mixin~mb:#interface-mixin-member
~includes文:#includes-statement
内包-:#include
~host~ifc:#host-interfaces

~mb:#dfn-member
属性:#dfn-attribute
呼戻~文脈:#dfn-callback-context
呼戻~関数:#dfn-callback-function
呼戻~ifc:#dfn-callback-interface
符号単位:#dfn-code-unit
適合~ES実装:#dfn-conforming-ecmascript-implementation
適合~IDL片の集合:#dfn-conforming-set-of-idl-fragments
適合~実装:#dfn-conforming-implementation
定数:#dfn-constant
定義:#dfn-definition
既定~値:#dfn-optional-argument-default-value
diC.既定~値:#dfn-dictionary-member-default-value
削除子:#dfn-deleter
辞書:#dfn-dictionary
辞書~mb:#dfn-dictionary-member
必須~辞書~mb:#dfn-required-dictionary-member
判別可能:#dfn-distinguishable
判別引数~index:#dfn-distinguishing-argument-index
有効~多重定義~集合:#dfn-effective-overload-set
関数類:#dfn-function-like
列挙:#dfn-enumeration
列挙~値:#dfn-enumeration-value

例外:#dfn-exception
作成-:#dfn-create-exception
作成する:#dfn-create-exception
単純例外:#dfn-simple-exception
~message:#dfn-exception-message
~error名:#dfn-exception-error-name
~error名~一覧:#dfn-error-names-table
投出:#dfn-throw
投出する:#dfn-throw
例外が投出された:#an-exception-was-thrown
	~DOMException:#idl-DOMException

平坦化~mb型:#dfn-flattened-union-member-types
取得子:#dfn-getter
取得子を継承-:#dfn-inherit-getter
識別子:#dfn-identifier
nC.識別子:#namedconstructor-identifier
wA.識別子:#legacywindowalias-identifier


継承-:#dfn-inherit
diC.継承-:#dfn-inherit-dictionary
被継承~ifc:#dfn-inherited-interfaces
被継承~辞書:#dfn-inherited-dictionaries

可反復:#dfn-iterable
可反復~宣言:#dfn-iterable-declaration
反復される値:#dfn-values-to-iterate-over
反復される値~pair:#dfn-value-pairs-to-iterate-over

値~反復子:#dfn-value-iterator
~pair反復子:#dfn-pair-iterator
~map~entry:#dfn-map-entries
~map~key型:#dfn-map-key-type
~map~value型:#dfn-map-value-type
~set~entry:#dfn-set-entries
~maplike:#dfn-maplike
~maplike 宣言:#dfn-maplike-declaration
~setlike:#dfn-setlike
~setlike 宣言:#dfn-setlike-declaration

有index~prop取得子:#dfn-indexed-property-getter
有index~prop設定子:#dfn-indexed-property-setter
有index~propを~support:#dfn-support-indexed-properties
有index~propの値を決定する:#dfn-determine-the-value-of-an-indexed-property
	既存の有index~propを削除する:#dfn-delete-an-existing-indexed-property
既存の有index~propを設定する:#dfn-set-the-value-of-an-existing-indexed-property
新たな有index~propを設定する:#dfn-set-the-value-of-a-new-indexed-property

有名~prop削除子:#dfn-named-property-deleter
有名~prop取得子:#dfn-named-property-getter
有名~prop設定子:#dfn-named-property-setter
有名~propを~support:#dfn-support-named-properties

有名~propの値を決定する:#dfn-determine-the-value-of-a-named-property
既存の有名~propを削除する:#dfn-delete-an-existing-named-property
既存の有名~propを設定する:#dfn-set-the-value-of-an-existing-named-property
新たな有名~propを設定する:#dfn-set-the-value-of-a-new-named-property

有名~定義:#dfn-named-definition

演算:#dfn-operation
省略可否 値:#dfn-optionality-value
随意~引数:#dfn-optional-argument
多重定義:#dfn-overloaded
部分的~辞書~定義:#dfn-partial-dictionary
部分的~ifc定義:#dfn-partial-interface
部分的~ifc:#dfn-partial-interface
~platform~obj:#dfn-platform-object
旧来の~platform~obj:#dfn-legacy-platform-object

~JSON型:#dfn-json-types
既定の~toJSON演算:#default-tojson-operation
下層の値を取得-:#get-the-underlying-value
対応する既定の演算:#corresponding-default-operation
継承~stackを作成する:#create-an-inheritance-stack
属性~値を収集する:#collect-attribute-values
継承~stackの属性~値を収集する:#collect-attribute-values-of-an-inheritance-stack


読専:#dfn-read-only
正則~属性:#dfn-regular-attribute
正則~演算:#dfn-regular-operation
設定子:#dfn-setter
特殊~keyword:#dfn-special-keyword
特殊~演算:#dfn-special-operation
静的~属性:#dfn-static-attribute
静的~演算:#dfn-static-operation
文字列化子:#dfn-stringifier
文字列化の挙動:#dfn-stringification-behavior
被support~prop~index:#dfn-supported-property-indices
被support~prop名:#dfn-supported-property-names
~target~obj:#dfn-iterator-target-object

~typedef:#dfn-typedef
新たな名前が与えられる型:#type-being-given-a-new-name

注釈付きの型:#annotated-types
拡張属性が結付けられ:#idl-type-extended-attribute-associated-with
結付けられている拡張属性:#idl-type-extended-attribute-associated-with
anO.内縁~型:#annotated-types-inner-type
最内縁の型:#_innermost-type
型に適用でき:#extended-attributes-applicable-to-types

型~名:#dfn-type-name
利用者~obj:#dfn-user-object
可変個の引数:#dfn-variadic
可変個~引数:#dfn-variadic-argument
末尾~引数:#dfn-variadic-argument
拡張属性:#dfn-extended-attribute
予約済み識別子:#dfn-reserved-identifier
在する:#dfn-present
不在:#dfn-present

用語例:#dfn-example-term

参照／複製を取得-:#dfn-get-buffer-source-reference
	dfn-get-buffer-source-copy
切離す:#dfn-detach
切離された:#dfn-detach

定数~tok:#dfn-const-tokens
	配列の要素~型:#dfn-element-type
	連列の要素~型:#dfn-element-type

例外~型:#dfn-exception-type
~nullable~mb型の個数:#dfn-number-of-nullable-member-types
~nullable型:#dfn-nullable-type
~nullable:#dfn-nullable-type
~nullable型を内包する:#dfn-includes-a-nullable-type
内縁~型:#dfn-inner-type
整数~型:#dfn-integer-type
~buffer~source型:#dfn-buffer-source-type
有型~配列~型:#dfn-typed-array-type
~mb型:#dfn-union-member-type
実数~型:#dfn-numeric-type
文字列~型:#dfn-string-type
~primitive型:#dfn-primitive-type
返値型:#dfn-return-type
型:#idl-types
固有型:#dfn-specific-type
共用体~型:#dfn-union-type
呼戻~関数~型:#idl-callback-function
~ifc型:#idl-interface
連列~型:#sequence-type
~sequence_T:#idl-sequence
辞書~型:#idl-dictionary
~record型:#record-type
~record_KV:#idl-record
列挙~型:#idl-enumeration
凍結~配列~型:#dfn-frozen-array-type
~FrozenArray_T:#idl-frozen-array
~obj型:#dfn-object-type
	~symbol型:#idl-symbol
~promise型:#dfn-promise-type
~promise_T:#idl-promise

有index~prop:#idl-indexed-properties
有名~prop:#idl-named-properties
連列~値を作成-:#create-sequence-from-iterable
凍結~配列~値を作成-:#create-frozen-array-from-iterable

ArrayBufferView:#ArrayBufferView
BufferSource:#BufferSource
DOMTimeStamp:#DOMTimeStamp
Function:#Function
VoidFunction:#VoidFunction

~Web~IDL引数~list:#web-idl-arguments-list
~ES引数~listに変換-:#web-idl-arguments-list-converting

	●JS 束縛
A.CleanupSettings:#_CleanupSettings
A.PrepareSettings:#_PrepareSettings


通例の所在:#dfn-normal-location

NewTarget:~TC39#sec-built-in-function-objects
~error~obj:~TC39#sec-error-objects



~IDL値に変換-:#dfn-convert-ecmascript-to-idl-value
~ES値に変換-:#dfn-convert-idl-to-ecmascript-value

~class文字列:#dfn-class-string
首~ifc:#dfn-primary-interface
首~大域~ifc:#dfn-primary-global-interface
単一~演算~呼戻~ifc:#dfn-single-operation-callback-interface

~ifc~obj:#dfn-interface-object
旧来の呼戻~ifc~obj:#dfn-legacy-callback-interface-object
~ifc原型~obj:#dfn-interface-prototype-object
初期~obj:#dfn-initial-object
反復子~原型~obj:#dfn-iterator-prototype-object
~ns~obj:#dfn-namespace-object
既定の反復子~obj:#dfn-default-iterator-object
有名~prop~obj:#dfn-named-properties-object

~promiseが決着したときの手続きを遂行する:#dfn-perform-steps-once-promise-is-settled

~map~size取得子:#dfn-map-size-getter
~set~size取得子:#dfn-set-size-getter
内部~map~objへ転送する:#dfn-forwards-to-the-internal-map-object
内部~set~objへ転送する:#dfn-forwards-to-the-internal-set-object

保安的~文脈:~SECURE-CONTEXT#secure-contexts
保安~検査を遂行する:#dfn-perform-a-security-check
保安的~文脈~下に限り可用:#dfn-available-only-in-secure-contexts
保安的かどうかに関わらず可用:#available-in-both-secure-and-non-secure-contexts
偽装不可:#dfn-unforgeable-on-an-interface
偽装不可~prop名:#dfn-unforgeable-property-name

公開~集合:#dfn-exposure-set
自前の公開~集合:#own-exposure-set
公開され:#dfn-exposed
公開する:#dfn-expose

凍結~配列を作成-:#dfn-create-frozen-array
呼戻 this 値:#dfn-callback-this-value
呼戻~関数を呼出す:#invoke-a-callback-function
呼戻~関数で構築-:#construct-a-callback-function
変化-:#dfn-change-global-environment
多重定義~解決~algo:#dfn-overload-resolution-algorithm
大域~名:#dfn-global-name
属する~Realm:#dfn-associated-realm

属性~取得子:#dfn-attribute-getter
属性~設定子:#dfn-attribute-setter
有index~prop設定子を呼出す:#invoke-indexed-setter
有名~prop設定子を呼出す:#invoke-named-setter
有名~propは可視か？:#dfn-named-property-visibility
有名~propの可視性判定~algo:#dfn-named-property-visibility
有名~構築子:#dfn-named-constructor
演算~関数を作成する:#dfn-create-operation-function
配列~indexで:#is-an-array-index

利用者~objの属性~値を取得する:#get-a-user-objects-attribute-value
利用者~objの属性~値を設定する:#set-a-user-objects-attribute-value
利用者~objの演算を~callする:#call-a-user-objects-operation

M.name:#dom-domexception-name
M.message:#dom-domexception-message
M.code:#dom-domexception-code
eX.名前:#domexception-name
eX.~message:#domexception-name

	●外部
~entry:~INFRA#map-entry
有順序~map:~INFRA#ordered-map
~key:~INFRA#map-key
値:~INFRA#map-value
~item:~INFRA#list-item
~list:~INFRA#list
付加-:~INFRA#list-append
~size:~INFRA#list-size
空:~INFRA#list-is-empty

有順序~集合:~INFRA#ordered-set
集合:~INFRA#ordered-set
交差集合:~INFRA#set-intersection
下位集合:~INFRA#set-subset
set.付加-:~INFRA#set-append

~tuple:~INFRA#tuple
sct.~item:~INFRA#struct-item

~stack:~INFRA#stack
~pop:~INFRA#stack-pop
~push:~INFRA#stack-push

~JS文字列:~INFRA#javascript-string
範囲:~INFRA#the-range

	~BREAK:~INFRA#iteration-break
	~WHILE:~INFRA#iteration-while
	~EACH:~INFRA#list-iterate


	~EACH:~INFRA#list-iterate
	~EACH:~INFRA#map-iterate
	←:~INFRA#map-set
	~set:~INFRA#map-set

大域~obj:~WAPI#concept-realm-global
関連する~Realm:~WAPI#concept-relevant-realm
関連する設定群~obj:~WAPI#relevant-settings-object
設定群~obj:~WAPI#concept-realm-settings-object
現任の設定群~obj:~WAPI#incumbent-settings-object
走らせた~scriptを片付ける:~WAPI#clean-up-after-running-script
走らせた呼戻子を片付ける:~WAPI#clean-up-after-running-a-callback
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
呼戻子を走らすために準備する:~WAPI#prepare-to-run-a-callback
~event-handler~IDL属性:~WAPI#event-handler-idl-attributes

完了record:~TC39#sec-completion-record-specification-type
中途完了:~TC39#sec-completion-record-specification-type
	正常完了:#normal-completion
	~TC39#sec-completion-record-specification-type
~completion-record:~TC39#sec-completion-record-specification-type
構築子:~TC39#constructor
関数~obj:~TC39#function-object
組込みの関数~obj:~TC39#sec-built-in-function-objects
~Realm:~TC39#realm
現在の~Realm:~TC39#current-realm
~callable:~TC39#sec-iscallable
配列~反復子~obj:~TC39#sec-array-iterator-objects
配列~index:~TC39#array-index
~pdesc:~TC39#sec-property-descriptor-specification-type
Assert:~TC39#sec-algorithm-conventions
変異不可の原型~exotic~obj:~TC39#sec-immutable-prototype-exotic-objects
内部~slot:~TC39#sec-object-internal-methods-and-internal-slots
eS.型:~TC39#sec-ecmascript-data-types-and-values
max:~TC39#eqn-max
eS.要素:~TC39#sec-ecmascript-language-types-string-type

~Unicode~scalar値:https://www.unicode.org/glossary/#unicode_scalar_value

	●§
#idl:~ifc定義~言語
#idl-interfaces:~ifc
#idl-interface-mixins:~ifc~mixin
#using-mixins-and-partials:~mixinと~partialの用法
#idl-namespaces:~ns
#idl-objects:~ifcを実装している~obj
#idl-types:型
#idl-extended-attributes:拡張属性
#idl-tojson-operation:~toJSON
#idl-special-operations:特殊~演算
#idl-stringifiers:文字列化子
#idl-indexed-properties:有index~prop
#idl-named-properties:有名~prop
#idl-overloading-vs-union:多重定義 vs. 共用体~型

#es-creating-throwing-exceptions:例外の作成と投出
#es-any:<code class="idltype">any</code>
#es-type-mapping:~ES型との対応関係
#es-integer-types:整数~型
#es-unrestricted-double:unrestricted double
#es-DOMString:DOMString
#es-symbol:symbol
#es-interface:~ifc型
#es-callback-function:呼戻~関数~型
#es-nullable-type:~nullable型
#es-buffer-source-types:~buffer~source型
#es-extended-attributes:~ES固有の拡張属性
#es-interfaces:~ifc
#interface-object:~ifc~obj
#named-constructors:有名~構築子
#interface-prototype-object:~ifc原型~obj
#named-properties-object:有名~prop~obj
#es-constants:定数
#es-attributes:属性
#es-operations:演算
#es-iterators:反復子に共通する挙動
#es-platform-objects:~ifcを実装している~platform~obj
#es-legacy-platform-objects:旧来の~platform~obj
#legacy-platform-object-getownproperty:[[GetOwnProperty]]
#legacy-platform-object-defineownproperty:[[DefineOwnProperty]]
#legacy-platform-object-set:[[Set]]
#es-user-objects:利用者~obj
#namespace-object:~ns~obj
#idl-grammar:~IDL文法

#es-DOMException-specialness:~DOMException~custom言語束縛

●●d_grammar_table


●Definitions
ExtendedAttributeList Definition Definitions
ε

●Definition
CallbackOrInterfaceOrMixin
Namespace
Partial
Dictionary
Enum
Typedef
IncludesStatement

●ArgumentNameKeyword
"attribute"
"callback"
"const"
"deleter"
"dictionary"
"enum"
"getter"
"includes"
"inherit"
"interface"
"iterable"
"maplike"
"namespace"
"partial"
"required"
"setlike"
"setter"
"static"
"stringifier"
"typedef"
"unrestricted"

●CallbackOrInterfaceOrMixin
"callback" CallbackRestOrInterface
"interface" InterfaceOrMixin

●CallbackRestOrInterface
CallbackRest
"interface" InterfaceRest

●InterfaceOrMixin
InterfaceRest
MixinRest

●InterfaceRest
identifier Inheritance "{" InterfaceMembers "}" ";"

●Partial
"partial" PartialDefinition

●PartialDefinition
"interface" PartialInterfaceOrPartialMixin
PartialDictionary
Namespace

●PartialInterfaceOrPartialMixin
PartialInterfaceRest
MixinRest

●PartialInterfaceRest
identifier "{" InterfaceMembers "}" ";"

●InterfaceMembers
ExtendedAttributeList InterfaceMember InterfaceMembers
ε

●InterfaceMember
Const
Operation
Stringifier
StaticMember
Iterable
ReadOnlyMember
ReadWriteAttribute
ReadWriteMaplike
ReadWriteSetlike

●Inheritance
":" identifier
ε

●MixinRest
"mixin" identifier "{" MixinMembers "}" ;

●MixinMembers
ExtendedAttributeList MixinMember MixinMembers
ε

●MixinMember
Const
RegularOperation
Stringifier
ReadOnly AttributeRest

●IncludesStatement
identifier "includes" identifier ;

●Const
"const" ConstType identifier "=" ConstValue ";"

●ConstValue
BooleanLiteral
FloatLiteral
integer
"null"

●BooleanLiteral
"true"
"false"

●FloatLiteral
float
"-Infinity"
"Infinity"
"NaN"

●ConstType
PrimitiveType Null
identifier Null

●ReadOnlyMember
"readonly" ReadOnlyMemberRest

●ReadOnlyMemberRest
AttributeRest
ReadWriteMaplike
ReadWriteSetlike

●ReadWriteAttribute
"inherit" ReadOnly AttributeRest
AttributeRest

●AttributeRest
"attribute" TypeWithExtendedAttributes AttributeName ";"

●AttributeName
AttributeNameKeyword
identifier

●AttributeNameKeyword
"required"

●ReadOnly
"readonly"
ε

●DefaultValue
ConstValue
string
"[" "]"

●Operation
RegularOperation
SpecialOperation

●RegularOperation
ReturnType OperationRest

●SpecialOperation
Special Specials RegularOperation

●Specials
Special Specials
ε

●Special
"getter"
"setter"
"deleter"

●OperationRest
OptionalIdentifier "(" ArgumentList ")" ";"

●OptionalIdentifier
identifier
ε

●ArgumentList
Argument Arguments
ε

●Arguments
"," Argument Arguments
ε

●Argument
ExtendedAttributeList ArgumentRest

●ArgumentRest
"optional" TypeWithExtendedAttributes ArgumentName Default
Type Ellipsis ArgumentName

●ArgumentName
ArgumentNameKeyword
identifier

●Ellipsis
"..."
ε

●ReturnType
Type
"void"

●Stringifier
"stringifier" StringifierRest

●StringifierRest
ReadOnly AttributeRest
RegularOperation
";"

●StaticMember
"static" StaticMemberRest

●StaticMemberRest
ReadOnly AttributeRest
RegularOperation

●Iterable
"iterable" "<" TypeWithExtendedAttributes OptionalType ">" ";"

●OptionalType
"," TypeWithExtendedAttributes
ε

●ReadWriteMaplike
MaplikeRest

●MaplikeRest
"maplike" "<" TypeWithExtendedAttributes "," TypeWithExtendedAttributes ">" ";"

●ReadWriteSetlike
SetlikeRest

●SetlikeRest
"setlike" "<" TypeWithExtendedAttributes ">" ";"

●Namespace
"namespace" identifier "{" NamespaceMembers "}" ";"

●NamespaceMembers
ExtendedAttributeList NamespaceMember NamespaceMembers
ε

●NamespaceMember
RegularOperation
"readonly" AttributeRest

●Dictionary
"dictionary" identifier Inheritance "{" DictionaryMembers "}" ";"

●DictionaryMembers
DictionaryMember DictionaryMembers
ε

●DictionaryMember
ExtendedAttributeList DictionaryMemberRest

●DictionaryMemberRest
"required" TypeWithExtendedAttributes identifier Default ";"
Type identifier Default ";"

●PartialDictionary
"dictionary" identifier "{" DictionaryMembers "}" ";"

●Default
"=" DefaultValue
ε

●Enum
"enum" identifier "{" EnumValueList "}" ";"

●EnumValueList
string EnumValueListComma

●EnumValueListComma
"," EnumValueListString
ε

●EnumValueListString
string EnumValueListComma
ε

●CallbackRest
identifier "=" ReturnType "(" ArgumentList ")" ";"

●Typedef
"typedef" TypeWithExtendedAttributes identifier ";"

●Type
SingleType
UnionType Null

●TypeWithExtendedAttributes
ExtendedAttributeList Type

●SingleType
NonAnyType
"any"

●UnionType
"(" UnionMemberType "or" UnionMemberType UnionMemberTypes ")"

●UnionMemberType
ExtendedAttributeList NonAnyType
UnionType Null

●UnionMemberTypes
"or" UnionMemberType UnionMemberTypes
ε

●NonAnyType
PromiseType ε
PrimitiveType Null
StringType Null
identifier Null
"sequence" "<" TypeWithExtendedAttributes ">" Null
"object" Null
"symbol" Null
"Error" Null
BufferRelatedType Null
"FrozenArray" "<" TypeWithExtendedAttributes ">" Null
RecordType Null

●PrimitiveType
UnsignedIntegerType
UnrestrictedFloatType
"boolean"
"byte"
"octet"

●UnrestrictedFloatType
"unrestricted" FloatType
FloatType

●FloatType
"float"
"double"

●UnsignedIntegerType
"unsigned" IntegerType
IntegerType

●IntegerType
"short"
"long" OptionalLong

●OptionalLong
"long"
ε

●StringType
"ByteString"
"DOMString"
"USVString"

●PromiseType
"Promise" "<" ReturnType ">"

●RecordType
"record" "<" StringType "," TypeWithExtendedAttributes ">"

●Null
"?"
ε

●BufferRelatedType
"ArrayBuffer"
"DataView"
"Int8Array"
"Int16Array"
"Int32Array"
"Uint8Array"
"Uint16Array"
"Uint32Array"
"Uint8ClampedArray"
"Float32Array"
"Float64Array"

●ExtendedAttributeList
"[" ExtendedAttribute ExtendedAttributes "]"
ε

●ExtendedAttributes
"," ExtendedAttribute ExtendedAttributes
ε

●ExtendedAttribute
"(" ExtendedAttributeInner ")" ExtendedAttributeRest
"[" ExtendedAttributeInner "]" ExtendedAttributeRest
"{" ExtendedAttributeInner "}" ExtendedAttributeRest
Other ExtendedAttributeRest

●ExtendedAttributeRest
ExtendedAttribute
ε

●ExtendedAttributeInner
"(" ExtendedAttributeInner ")" ExtendedAttributeInner
"[" ExtendedAttributeInner "]" ExtendedAttributeInner
"{" ExtendedAttributeInner "}" ExtendedAttributeInner
OtherOrComma ExtendedAttributeInner
ε

●Other
integer
float
identifier
string
other
"-"
"-Infinity"
"."
"..."
":"
";"
"<"
"="
">"
"?"
"ByteString"
"DOMString"
"FrozenArray"
"Infinity"
"NaN"
"USVString"
"any"
"boolean"
"byte"
"double"
"false"
"float"
"long"
"null"
"object"
"octet"
"or"
"optional"
"sequence"
"short"
"true"
"unsigned"
"void"
ArgumentNameKeyword
BufferRelatedType

●OtherOrComma
Other
","

●IdentifierList
identifier Identifiers

●Identifiers
"," identifier Identifiers
ε

●ExtendedAttributeNoArgs
identifier

●ExtendedAttributeArgList
identifier "(" ArgumentList ")"

●ExtendedAttributeIdent
identifier "=" identifier

●ExtendedAttributeIdentList
identifier "=" "(" IdentifierList ")"

●ExtendedAttributeNamedArgList
identifier "=" identifier "(" ArgumentList ")"


●●ref_normative
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. URL: http://dev.w3.org/csswg/css-syntax/ 
[ECMA-262]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[IEEE-754]
    IEEE Standard for Binary Floating-Point Arithmetic (ANSI/IEEE Std 754-1985). 29 August 2008. URL: http://ieeexplore.ieee.org/servlet/opac?punumber=4610933 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[PERLRE]
    Perl regular expressions (Perl 5.8.8). February 2006. URL: http://search.cpan.org/dist/perl/pod/perlre.pod 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC2781]
    P. Hoffman; F. Yergeau. UTF-16, an encoding of ISO 10646. February 2000. Informational. URL: https://tools.ietf.org/html/rfc2781 
[RFC3629]
    F. Yergeau. UTF-8, a transformation format of ISO 10646. November 2003. Internet Standard. URL: https://tools.ietf.org/html/rfc3629 
[SECURE-CONTEXTS]
    Mike West. Secure Contexts. URL: https://w3c.github.io/webappsec-secure-contexts/ 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 

●●ref_informative

[CSS-CONDITIONAL-3]
    CSS Conditional Rules Module Level 3 URL: https://drafts.csswg.org/css-conditional-3/ 
[CSS3-CONDITIONAL]
    David Baron. CSS Conditional Rules Module Level 3. URL: https://drafts.csswg.org/css-conditional-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). URL: https://drafts.csswg.org/cssom/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FULLSCREEN]
    Anne van Kesteren. Fullscreen API Standard. Living Standard. URL: https://fullscreen.spec.whatwg.org/ 
[GEOLOCATION-API]
    Andrei Popescu. Geolocation API Specification 2nd Edition. URL: http://dev.w3.org/geo/api/spec-source.html 
[GEOMETRY]
    Simon Pieters; Dirk Schulze; Rik Cabanier. Geometry Interfaces Module Level 1. URL: https://drafts.fxtf.org/geometry/ 
[MEDIACAPTURE-STREAMS]
    Daniel Burnett; et al. Media Capture and Streams. URL: https://w3c.github.io/mediacapture-main/ 
[OMGIDL]
    CORBA 3.1 – OMG IDL Syntax and Semantics chapter. January 2008. URL: http://www.omg.org/cgi-bin/doc?formal/08-01-04.pdf 
[ORIENTATION-EVENT]
    Rich Tibbett; et al. DeviceOrientation Event Specification. URL: https://w3c.github.io/deviceorientation/spec-source-orientation.html 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEBGL]
    Dean Jackson; Jeff Gilbert. WebGL 2.0 Specification. 12 August 2017. URL: https://www.khronos.org/registry/webgl/specs/latest/2.0/ 
[WORKLETS-1]
    Ian Kilpatrick. Worklets Level 1. URL: https://drafts.css-houdini.org/worklets/ 
[XML-NAMES]
    Tim Bray; et al. Namespaces in XML 1.0 (Third Edition). 8 December 2009. REC. URL: https://www.w3.org/TR/xml-names 

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案（ Editor’s Draft ）として公開された 
<a href="https://heycam.github.io/webidl/">Web IDL</a>
（第 2 版）を日本語に翻訳したものです。
~PUB
<!-- <time>2012-05-15</time>（第１版） -->
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/WebIDL-1/

バージョン履歴
	https://github.com/heycam/webidl/commits/master

フィードバック
	<a href="mailto:public-script-coord@w3.org?subject=%5Bwebidl%5D%20YOUR%20TOPIC%20HERE">public-script-coord@w3.org</a> with subject line “<kbd>[webidl] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-script-coord/" rel="discussion">archives</a>)
	<a href="https://github.com/heycam/webidl">GitHub</a> ( <a href="https://github.com/heycam/webidl/issues/new">new issue</a>, <a href="https://github.com/heycam/webidl/issues">open issues</a>, <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=WebAppsWG&amp;component=WebIDL&amp;resolution=---">legacy bug tracker</a>)

編集
	<a href="http://mcc.id.au/">Cameron McCormack</a> (Mozilla Corporation) <a href="mailto:cam@mcc.id.au">cam@mcc.id.au</a>
     <a href="mailto:bzbarsky@mit.edu">Boris Zbarsky</a> (Mozilla Corporation)
     <a href="http://tobie.me">Tobie Langel</a> <a href="mailto:tobie@codespeaks.com">tobie@codespeaks.com</a>

</script>



</head>

<body>

<header>
<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 title="Web IDL">Web IDL</h1>
	</hgroup>
</header>


<div id="MAIN" style="display:none;">

	<section>
<h2 title="Abstract">~~要約</h2>

<p>
この文書は、~ifc定義~言語， ~Web~IDLを定義する
— その用途は、~Web~browserに実装するよう意図された~ifcを記述することである。
~Web~IDLは、~Web~platformにおける, 共通の~script~objの挙動を，より容易く指定できるようするために、いくつもの特色機能を備えた~IDLの変種である。
この文書では、~Web~IDLで記述される~ifcを ~ES実行~環境の構成子に対応付ける方法についても，詳細に渡り述べられる。
この文書は、［
既に発行-済みの仕様，および 新たに発行され, この文書を参照する仕様
］の適合~ifc実装が，相互運用可能になるための、実装者にとっての手引きになるものと期待されている。
◎
This document defines an interface definition language, Web IDL, that can be used to describe interfaces that are intended to be implemented in web browsers. Web IDL is an IDL variant with a number of features that allow the behavior of common script objects in the web platform to be specified more readily. How interfaces described with Web IDL correspond to constructs within ECMAScript execution environments is also detailed in this document. It is expected that this document acts as a guide to implementors of already-published specifications, and that newly published specifications reference this document to ensure conforming implementations of interfaces are interoperable.
</p>

	</section>
	<section id="sotd">

<h2 title="Status of this Document">この文書の位置付け</h2>

<p>
<em>この節では…</em>
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p><strong>
この文書に対する変更点は、
<a href="https://github.com/heycam/webidl">https://github.com/heycam/webidl</a>
から追跡できます。
</strong>
◎
Changes to this document may be tracked at https://github.com/heycam/webidl.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序</h2>

~INFORMATIVE

<p>
W3C により発行される技術報告に含められる~programming言語~ifcは、概して
Object Management Group による~IDL（ Interface Definition Language ）
`OMGIDL$r を利用して記述されていた。
この~IDLは、これらの~ifcを，言語から独立な方式で記述する手段を提供する。
通例，その種の文書には、~IDLで記述された~ifcを［
所与の言語
］の構成子に対応付ける方法について，詳細を述べる、言語束縛についての追加の付録が含められる。
◎
Technical reports published by the W3C that include programming language interfaces have typically been described using the Object Management Group’s Interface Definition Language (IDL) [OMGIDL]. The IDL provides a means to describe these interfaces in a language independent manner. Usually, additional language binding appendices are included in such documents which detail how the interfaces described with the IDL correspond to constructs in the given language.
</p>

<p>
しかしながら、~Web上で最も共通的に利用されている言語, ~ESに対しては、これらの仕様における言語束縛は，終始~粗い精度で指定されていたため、相互運用性の課題も生じていた。
加えて、それぞれの仕様が同じ基本的な情報を述べなければならない
— 例えば、
~IDLで記述される DOM ~ifcが~ES大域~objの~propに対応していることや,
`unsigned long$T ~IDL型が~ESの `Number^jt 型に対応付けられることなど。
◎
However, the bindings in these specifications for the language most commonly used on the web, ECMAScript, are consistently specified with low enough precision as to result in interoperability issues. In addition, each specification must describe the same basic information, such as DOM interfaces described in IDL corresponding to properties on the ECMAScript global object, or the unsigned long IDL type mapping to the Number type in ECMAScript.
</p>

<p>
この仕様は、~Web~API用の~ifcを定義する仕様で利用できる， OMG ~IDLに似た~IDL言語を定義する。
この~IDLには、以前は注釈文による記述を要していた共通の機能性を~supportするために，いくつもの拡張が加えられた。
加えて、~ES言語~用の精確な言語束縛も与えられた。
◎
This specification defines an IDL language similar to OMG IDL for use by specifications that define interfaces for Web APIs. A number of extensions are given to the IDL to support common functionality that previously must have been written in prose. In addition, precise language bindings for the ECMAScript language are given.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（ ~LET, ~IF, `~THROW$, ~WHILE, ~GOTO, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
ただし，`~THROW$ の意味は、この仕様に定義され（リンク先を~~参照），もっぱら~ES言語束縛において利用される。
</p>

<p>
この仕様~自身にも，<a href="#conventions">表記規約がある</a>。
</p>

<p class="L2">
最新発行~versionにはない，編集者草案にて追加された おおよその部分には、この段落と同じ~styleがあてがわれている（細かい箇所までは網羅していない）。
</p>

<p>
この仕様の中の用語の一部は、定訳が無いため，訳者が適当に対訳をあてがっている。
ウィンドウ下端に対訳の切り替え機能がある。
</p>


	</section>
	<section id="idl">
<h2 title="Interface definition language">2. ~ifc定義~言語</h2>


<p>
この節では、~Web~platform~API用の~ifcを定義するために利用できる言語，
<em>~Web~IDL</em> について述べる。
~Web~APIを定義する仕様は、［
その仕様が定義する~API用の~ifc（~objが表出し得る状態と挙動）
］を記述する， 1 つ以上の
`~IDL片@
を含み得る。
`~IDL片$は、いくつかの［
文法~記号 `Definitions$g に合致する定義
］からなる並びである。
実装が~supportする `~IDL片$の集合は、順序付けられない。
完全な文法と利用される記法の説明については、
`idl-grammar$sec
を見よ。
◎
This section describes a language, Web IDL, which can be used to define interfaces for APIs in the Web platform. A specification that defines Web APIs can include one or more IDL fragments that describe the interfaces (the state and behavior that objects can exhibit) for the APIs defined by that specification. An IDL fragment is a sequence of definitions that matches the Definitions grammar symbol. The set of IDL fragments that an implementation supports is not ordered. See IDL grammar for the complete grammar and an explanation of the notation used.
</p>


<p>
`~IDL片$に現れ得る
`定義@
には、次の種類があり，すべて後続の節にて定義される
⇒
`~ifc$,
`部分的~ifc定義$,
`~ifc~mixin$,
`部分的~ifc~mixin定義$,
`~ns$,
`部分的~ns定義$,
`辞書$,
`部分的~辞書~定義$,
`~typedef$,
`~includes文$
◎
The different kinds of definitions that can appear in an IDL fragment are: interfaces, partial interface definitions, interface mixins, partial mixin definitions, namespaces, partial namespace definitions, dictionaries, partial dictionary definitions, typedefs and includes statements. These are all defined in the following sections.
</p>

<p>
各`定義$（ `Definition$g に合致）の前には、［
`拡張属性$の~list（ `ExtendedAttributeList$g に合致）
］を置ける
— それらは、［
当の定義が，言語束縛において どう取扱われるか
］を制御する。
この仕様が定義する拡張属性の，どの言語束縛にも通用する部分については
`idl-extended-attributes$sec
にて論じられ、~ES言語束縛に特有の部分については
`es-extended-attributes$sec
にて論じられる。
◎
Each definition (matching Definition) can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the definition will be handled in language bindings. The extended attributes defined by this specification that are language binding agnostic are discussed in §2.13 Extended attributes, while those specific to the ECMAScript language binding are discussed in §3.3 ECMAScript-specific extended attributes.
</p>


<pre class="syntax">
[`extended_attributes^mk]
interface `identifier^i {
  /* interface_members... */
};
</pre>


<div class="grammar">
Definitions
Definition
</div>

<div class="example">
<p>
 `~IDL片$の例を示す：
◎
The following is an example of an IDL fragment.
</p>

<pre class="webidl">
interface Paint { };

interface SolidColor : Paint {
  attribute double red;
  attribute double green;
  attribute double blue;
};

interface Pattern : Paint {
  attribute DOMString imageURL;
};

[Constructor]
interface GraphicalWindow {
  readonly attribute unsigned long width;
  readonly attribute unsigned long height;

  attribute Paint currentPaint;

  void drawRectangle(double %x, double %y, double %width, double %height);

  void drawText(double %x, double %y, DOMString %text);
};
</pre>

<p>
ここでは、 4 個の`~ifc$が定義されている。
`GraphicalWindow^T ~ifcには、
2 個の`読専$ `属性$,
1 個の~writableな属性,
2 個の`演算$
が定義されている。
`GraphicalWindow^T ~ifcを実装する~objは、利用されている 特定0の言語に適切な方式で，これらの属性と演算を公開することになる。
◎
Here, four interfaces are being defined. The GraphicalWindow interface has two read only attributes, one writable attribute, and two operations defined on it. Objects that implement the GraphicalWindow interface will expose these attributes and operations in a manner appropriate to the particular language being used.
</p>

<p>
~ESにおいては、~IDL~ifc上の属性／演算は、すべての `GraphicalWindow^T ~objにおいて，その原型~obj上の［
`組込みの関数~obj$を値とする~data-propとして与えられる［
~accessor~prop ／ 演算
］］として，公開されることになる。
`GraphicalWindow^T を実装する各~ES~objは、その原型鎖の中にその原型~objを持つことになる。
◎
In ECMAScript, the attributes on the IDL interfaces will be exposed as accessor properties and the operations as data properties whose value is a built-in function object on a prototype object for all GraphicalWindow objects; each ECMAScript object that implements GraphicalWindow will have that prototype object in its prototype chain.
</p>

<p>
`GraphicalWindow^T 上に現れる `Constructor$x は`拡張属性$である。
この拡張属性により、 `new GraphicalWindow()^c の~callに対し，この~ifcを実装する新たな~objを返すような`構築子$が、~ES実装に存在することになる。
◎
The [Constructor] that appears on GraphicalWindow is an extended attribute. This extended attribute causes a constructor to exist in ECMAScript implementations, so that calling new GraphicalWindow() would return a new object that implemented the interface.
</p>

</div>

		<section id="idl-names">
<h3 title="Names">2.1. 名前（識別子）</h3>


<p>
どの［
`~ifc$ ／
`部分的~ifc定義$ ／
`~ns$ ／
`部分的~ns定義$ ／
`辞書$ ／
`部分的~辞書~定義$ ／
`列挙$ ／
`呼戻~関数$ ／
`~typedef$
］も（これらは総称して
`有名~定義@
と呼ばれる）, および
どの［
`定数$ ／
`属性$ ／
`辞書~mb$
］も、何らかの`演算$を行うための
`識別子@
を持つ。
識別子はその宣言~内のどこかに在る `identifier$g ~tokから決定される：
◎
Every interface, partial interface definition, namespace, partial namespace definition, dictionary, partial dictionary definition, enumeration, callback function and typedef (together called named definitions) and every constant, attribute, and dictionary member has an identifier, as do some operations. The identifier is determined by an identifier token somewhere in the declaration:
</p>

<ul>
	<li>
<p>
`有名~定義$に対しては、~keyword［
`interface^c ／
`namespace^c ／
`dictionary^c ／
`enum^c ／
`callback^c
］の直後に現れる `identifier$g ~tokがその定義の識別子を決定する。
◎
For named definitions, the identifier token that appears directly after the interface, namespace, dictionary, enum or callback keyword determines the identifier of that definition.
</p>

<pre class="syntax">
interface `interface_identifier^mk { /* interface_members... */ };
partial interface `interface_identifier^mk { /* interface_members... */ };
namespace `namespace_identifier^mk { /* namespace_members... */ };
partial namespace `namespace_identifier^mk { /* namespace_members... */ };
dictionary `dictionary_identifier^mk { /* dictionary_members... */ };
partial dictionary `dictionary_identifier^mk { /* dictionary_members... */ };
enum `enumeration_identifier^mk { "enum", "values" /* , ... */ };
callback `callback_identifier^mk = return_type (/* arguments... */);
</pre>
	</li>
	<li>
<p>
`属性$,
`~typedef$,
`辞書~mb$
に対しては、宣言の末尾の~semicolonの前に在る最後の `identifier$g ~tokが識別子を決定する。
◎
For attributes, typedefs and dictionary members, the final identifier token before the semicolon at the end of the declaration determines the identifier.
</p>

<pre class="syntax">
interface `identifier^i {
  attribute `type^i `attribute_identifier^mk;
};

typedef `type^i `typedef_identifier^mk;

dictionary `identifier^i {
  `type^i `dictionary_member_identifier^mk;
};
</pre>

</li>
	<li>
<p>
`定数$に対しては、等号の前に在る
`identifier$g ~tokが識別子を決定する。
◎
For constants, the identifier token before the equals sign determines the identifier.
</p>

<pre class="syntax">
const `type^i `constant_identifier^mk = 42;
</pre>

</li>
	<li>
<p>
`演算$に対しては、返値型の後，かつ左~丸括弧の前に現れる `identifier$g ~tok（ `OperationRest$g の中の文法~記号 `OptionalIdentifier$g の部分として合致）
が、その演算の識別子を決定する。
そのような `identifier$g ~tokが無い場合、その演算は識別子を持たない。
◎
For operations, the identifier token that appears after the return type but before the opening parenthesis (that is, one that is matched as part of the OptionalIdentifier grammar symbol in an OperationRest) determines the identifier of the operation. If there is no such identifier token, then the operation does not have an identifier.
</p>

<pre class="syntax">
interface interface_identifier {
  `return_type^i `operation_identifier^mk(/* arguments... */);
};
</pre>

</li>
</ul>

<p class="note">注記：
［
取得子や設定子などの，
<a href="#idl-special-operations">特殊な種類の演算</a>
］を宣言する演算は、識別子を持たないことがある。
◎
Note: Operations can have no identifier when they are being used to declare a special kind of operation, such as a getter or setter.
</p>

<p>
これらの構成子のすべてにおいて、
`identifier$g ~tokから先頭の
`U+005F LOW LINE ("_")^char
文字を（もし在れば）除去した値が`識別子$になる。
◎
For all of these constructs, the identifier is the value of the identifier token with any leading U+005F LOW LINE ("_") character (underscore) removed.
</p>

<p class="note">注記：
先頭の
`"_"^char
は、識別子を~escapeして，予約-済みの語と見誤られなくするために利用される。
例えば、 `interface^l という名前を持つ~ifcも定義できる。
先頭の
`"_"^char
は識別子の~escapeを外す際に落とされる。
◎
Note: A leading "_" is used to escape an identifier from looking like a reserved word so that, for example, an interface named “interface” can be defined. The leading "_" is dropped to unescape the identifier.
</p>

<p>
演算~引数がとり得る識別子は、もう少し広い集合になる。
演算の宣言においては、引数の識別子はその型の直後に指定され、
`identifier$g ~tokか, または `ArgumentNameKeyword$g 記号に合致する~keywordで与えられる。
これらの~keywordのいずれかが利用される場合、先頭の underscore による~escapeは不要である。
◎
Operation arguments can take a slightly wider set of identifiers. In an operation declaration, the identifier of an argument is specified immediately after its type and is given by either an identifier token or by one of the keywords that match the ArgumentNameKeyword symbol. If one of these keywords is used, it need not be escaped with a leading underscore.
</p>

<pre class="syntax">
interface interface_identifier {
  `return_type^i `operation_identifier^i(argument_type `argument_identifier^mk /* , ... */);
};
</pre>

<div class="grammar">
ArgumentNameKeyword
</div>

<p>
演算~引数に `identifier$g ~tokが利用された場合、その`識別子$はその~tokから先頭の
`U+005F LOW LINE ("_")^char
文字（ underscore ）を取り除いた値になる。
代わりにいずれかの `ArgumentNameKeyword$g ~keyword~tokが利用された場合、演算~引数の`識別子$は単にその~tokになる。
◎
If an identifier token is used, then the identifier of the operation argument is the value of that token with any leading U+005F LOW LINE ("_") character (underscore) removed. If instead one of the ArgumentNameKeyword keyword token is used, then the identifier of the operation argument is simply that token.
</p>

<p>
上に示されたどの~IDL構成子のどの`識別子$も
`constructor^l, `toString^l
になっては~MUST_NOT。
また、文字
`U+005F LOW LINE ("_")^char
から始まっては~MUST_NOT。
これらは
`予約済み識別子@
と呼ばれる。
◎
The identifier of any of the abovementioned IDL constructs must not be “constructor”, “toString”, or begin with a U+005F LOW LINE ("_") character. These are known as reserved identifiers.
</p>

<p>
`識別子$ `toJSON^l は`予約済み識別子$ではないが、`idl-tojson-operation$secに述べるように，利用されるのは［
~objを`~JSON型$に変換する`正則~演算$
］に限られ~MUST。
◎
Although the “toJSON” identifier is not a reserved identifier, it must only be used for regular operations that convert objects to JSON types, as described in §2.4.3.1 toJSON.
</p>


<p class="note">注記：
後の節にて、一部の特定0の構成子に対しては，識別子の名前に更なる制約が課され得る。
◎
Note: Further restrictions on identifier names for particular constructs may be made in later sections.
</p>

<p>
所与の実装が~supportする `~IDL片$の集合に属する、どの［
`~ifc$ ／
`~ns$ ／
`辞書$ ／
`列挙$ ／
`呼戻~関数$ ／
`~typedef$
］の`識別子$も，他のそれと互いに同じになっては~MUST_NOT。
◎
Within the set of IDL fragments that a given implementation supports, the identifier of every interface, namespace, dictionary, enumeration, callback function and typedef must not be the same as the identifier of any other interface, namespace, dictionary, enumeration, callback function or typedef.
</p>

<p>
`~IDL片$の中における`定義$への参照が、参照~先の定義の宣言より後に現れる必要はない。
参照は複数の`~IDL片$をまたがることもできる。
◎
Within an IDL fragment, a reference to a definition need not appear after the declaration of the referenced definition. References can also be made across IDL fragments.
</p>

<div class="example">
<p>
したがって，次の`~IDL片$は妥当である：
◎
Therefore, the following IDL fragment is valid:
</p>

<pre class="webidl">
interface B : A {
  void f(SequenceOfLongs %x);
};

interface A {
};

typedef sequence&lt;long&gt; SequenceOfLongs;
</pre>
</div>


<div class="example">
<p>
`定義$／`~ifc~mb$に，`識別子$を与える例を、次の`~IDL片$に示す：
◎
The following IDL fragment demonstrates how identifiers are given to definitions and interface members.
</p>

<pre class="webidl">
/* <span class="comment">
~typedef識別子： `number^l
◎
Typedef identifier: &quot;number&quot;
</span> */
typedef double number;

/* <span class="comment">
~ifc識別子： `System^l
◎
Interface identifier: &quot;System&quot;
</span> */
interface System {

  /* <span class="comment">
演算~識別子： `createObject^l
◎
Operation identifier:  &quot;createObject&quot;
</span> */
  /* <span class="comment">
演算~引数~識別子： `interface^l
◎
Operation argument identifier: &quot;interface&quot;
</span> */
  object createObject(DOMString _interface);

  /* <span class="comment">
演算~引数~識別子： `interface^l
◎
Operation argument identifier: &quot;interface&quot;
</span> */
  sequence&lt;object&gt; getObjects(DOMString interface);

  /* <span class="comment">
演算は識別子を持たない。取得子を宣言する。
◎
Operation has no identifier; it declares a getter.
</span> */
  getter DOMString (DOMString keyName);
};

/* <span class="comment">
~ifc識別子： `TextField^l
◎
Interface identifier: &quot;TextField&quot;
</span> */
interface TextField {

  /* <span class="comment">
属性~識別子： `const^l
◎
Attribute identifier: &quot;const&quot;
</span> */
  attribute boolean _const;

  /* <span class="comment">
属性~識別子： `value^l
◎
Attribute identifier: &quot;value&quot;
</span> */
  attribute DOMString? _value;
};
</pre>

<p>
`TextField^T `~ifc$の 2 個目の`属性$は（ `value^l は~IDL文法の~keywordではないので） underscore で~escapeする必要はないが、属性の`識別子$を得る際には，依然として~escapeは外される。
◎
Note that while the second attribute on the TextField interface need not have been escaped with an underscore (because “value” is not a keyword in the IDL grammar), it is still unescaped to obtain the attribute’s identifier.
</p>
</div>
		</section>
		<section id="idl-interfaces">
<h3 title="Interfaces">2.2. ~ifc</h3>


<p>
`~IDL片$は~obj指向~systemの記述に利用される。
その種の~systemにおいては、~objは同一性（ identity ）を備える実体であり，状態と挙動の~encapsulationである。
`~ifc@
とは、その~ifcを実装する~objが公開することになる，何らかの状態や挙動を宣言するための，`定義$（
`interface^sym `InterfaceRest$g ／
`callback^sym `interface^sym `InterfaceRest$g
いずれかに合致）である。
◎
IDL fragments are used to describe object oriented systems. In such systems, objects are entities that have identity and which are encapsulations of state and behavior. An interface is a definition (matching interface InterfaceRest or callback interface InterfaceRest) that declares some state and behavior that an object implementing that interface will expose.
</p>

<pre class="syntax">
interface `identifier^i {
  /* interface_members... */
};
</pre>

<p>
~ifcは、その宣言の波括弧を成す合間に現れる，一連の`~mb$が成す集合（ `InterfaceMembers$g に合致）の仕様である。
これらの~mbは、
`~ifc~mb@
と称される。
◎
An interface is a specification of a set of interface members (matching InterfaceMembers). These are the members that appear between the braces in the interface declaration.
</p>

<p>
~Web~IDLの~ifcは，その~ifcを実装する~objが どう挙動するかを記述する。
~obj指向~言語~用の言語束縛においては、特定0の~IDL~ifcを実装する~objは，［
~objの状態を検分したり改変する仕方，~ifcに記述された挙動を呼出す仕方
］を提供することが期待されている。
◎
Interfaces in Web IDL describe how objects that implement the interface behave. In bindings for object oriented languages, it is expected that an object that implements a particular IDL interface provides ways to inspect and modify the object’s state and to invoke the behavior described by the interface.
</p>

<p>
~ifcは，別の~ifc（の~mb）を
`継承-@
するようにも定義できる。
~ifcの識別子に文字
`U+003A COLON (":")^char
と`識別子$が後続している場合、後者の識別子が，継承される~ifcを識別する。
ある~ifc %I を継承する~ifcを実装する~objは， %I も実装する。
~objはしたがって， %I からの~ifc~mbに対応する~mbも持つことになる。
◎
An interface can be defined to inherit from another interface. If the identifier of the interface is followed by a U+003A COLON (":") character and an identifier, then that identifier identifies the inherited interface. An object that implements an interface that inherits from another also implements that inherited interface. The object therefore will also have members that correspond to the interface members from the inherited interface.
</p>

<pre class="syntax">
interface `identifier^i : `identifier_of_inherited_interface^mk {
  /* interface_members... */
};
</pre>

<p>
~mbたちが現れる順序は、
<a href="#es-interfaces">~ES言語束縛</a>
における~prop列挙に，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
~ifcは、継承される~ifcの~mbと同じ名前を持つ，~ifc~mbを指定してもよい。
派生~ifcを実装する~objは、派生~ifc上でそれらの~mbを公開することになる。
その~obj上で上書きされた~mbに~accessできるかどうかは、言語束縛に特有になる。
◎
Interfaces may specify an interface member that has the same name as one from an inherited interface. Objects that implement the derived interface will expose the member on the derived interface. It is language binding specific whether the overridden member can be accessed on the object.
</p>

<div class="example">
<p>
次の 2 つの~ifcを考える
◎
Consider the following two interfaces.
</p>

<pre class="webidl">
interface A {
  void f();
  void g();
};

interface B : A {
  void f();
  void g(DOMString %x);
};
</pre>

<p>
~ES言語束縛においては、
`B^T の~instanceは，次の様な原型鎖を持つことになる：
◎
In the ECMAScript language binding, an instance of B will have a prototype chain that looks like the following:
</p>

<div style="white-space:pre;margin-left:2em;">
[ `Object.prototype^jv ： `Object^jt 原型~obj]
              ↑
[ `A.prototype^jv ： `A^T の~ifc原型~obj]
              ↑
[ `B.prototype^jv ： `B^T の~ifc原型~obj]
              ↑
[ `B^T の~instance]</div>

<!-- 
[Object.prototype: the Object prototype object]
[B.prototype: interface prototype object for B]
[instanceOfB]
 -->
<p>
~ESにおける
`instanceOfB.f()^c
の~callは、
`B^T 上で定義された f を呼出すことになる。<!-- ＊ f -->
しかしながら， `A^T 上の f も、依然として
`A.prototype.f.call(instanceOfB)^c
の~callにより， `B^T を実装する~obj上で呼出せる。
◎
Calling instanceOfB.f() in ECMAScript will invoke the f defined on B. However, the f from A can still be invoked on an object that implements B by calling A.prototype.f.call(instanceOfB).
</p>

</div>

<p>
所与の~ifc %A の
`被継承~ifc@
とは、［
%A が直接的にまたは間接的に継承する，すべての~ifc
］からなる集合である。
%A が 他の~ifcを`継承-$しない場合、集合は空である。
他の場合、その集合には， %A が継承する~ifc %B と %B の`被継承~ifc$すべてが含まれる。
◎
The inherited interfaces of a given interface A is the set of all interfaces that A inherits from, directly or indirectly. If A does not inherit from another interface, then the set is empty. Otherwise, the set includes the interface B that A inherits from and all of B’s inherited interfaces.
</p>

<p>
~ifcは、その継承~階層が循環するように宣言されては~MUST_NOT。
すなわち、~ifc %A は自身を継承することも,
%A を継承する別の~ifc %B を継承することもできない，等々。
◎
An interface must not be declared such that its inheritance hierarchy has a cycle. That is, an interface A cannot inherit from itself, nor can it inherit from another interface B that inherits from A, and so on.
</p>

<p>
~ifcの一般的な多重~継承は~supportされず，~objは~ifcの任意の集合を実装することはできないことに注意。
~objは、所与の単独の~ifc %A を実装するように
— すなわち %A の`被継承~ifc$すべてを実装するように —
定義できる。
加えて，`~includes文$を利用すれば、［
ある~ifc %A を実装している~objが，常に［
%A が`内包-$する各`~ifc~mixin$の各`~ifc~mixin~mb$を内包する
］］ように定義することもできる。
◎
Note that general multiple inheritance of interfaces is not supported, and objects also cannot implement arbitrary sets of interfaces. Objects can be defined to implement a single given interface A, which means that it also implements all of A’s inherited interfaces. In addition, an includes statement can be used to define that objects implementing an interface A will always also include the members of the interface mixins A includes.
</p>

<p>
各~ifc~mbの前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致）を置くことができる
— それらは、その~ifc~mbが，言語束縛において どう取扱われるかを制御する。
◎
Each interface member can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how the interface member will be handled in language bindings.
</p>

<pre class="syntax">
interface `identifier^i {

  [`extended_attributes^mk]
  const `type^i `constant_identifier^i = 42;

  [`extended_attributes^mk]
  attribute `type^i `identifier^i;

  [`extended_attributes^mk]
  `return_type^i `identifier^i(/* arguments... */);
};
</pre>


<p>
`呼戻~ifc@
は，その定義の先頭に `callback^c ~keywordを利用する`~ifc$である。
呼戻~ifcは、
`idl-objects$sec
にて述べるように，`~platform~obj$ではなく，`利用者~obj$により実装され得るものである。
◎
A callback interface is an interface that uses the callback keyword at the start of its definition. Callback interfaces are ones that can be implemented by user objects and not by platform objects, as described in §2.11 Objects implementing interfaces.
</p>

<pre class="syntax">
callback interface `identifier^i {
  /* interface_members... */
};
</pre>

<p class="note">注記：
似た命名の`呼戻~関数$定義も見よ。
◎
Note: See also the similarly named callback function definition.
</p>

<p>
`呼戻~ifc$は非~呼戻~ifcを`継承-$しては~MUST_NOT。
非~呼戻~ifcは呼戻~ifcを`継承-$しては~MUST_NOT。
呼戻~ifcは`~ifc~mixin$を`内包-$しては~MUST_NOT。
◎
Callback interfaces must not inherit from any non-callback interfaces, and non-callback interfaces must not inherit from any callback interfaces. Callback interfaces must not include any interface mixins.
</p>

<p>
`呼戻~ifc$上に［
`静的~属性$ ／ `静的~演算$
］が定義されては~MUST_NOT。
◎
Static attributes and static operations must not be defined on a callback interface.
</p>


<div class="advisement">

<p>
仕様~策定者は、既存の~APIの要件の記述に~~不可欠な場合を除き，単独の`演算$のみを持つ`呼戻~ifc$を定義するべきでない。
代わりに，`呼戻~関数$が利用されるべきである。
◎
Specification authors should not define callback interfaces that have only a single operation, unless required to describe the requirements of existing APIs. Instead, a callback function should be used.
</p>

<p>
`呼戻~ifc$である `EventListener^T の定義は、所与の~prop（この場合は `handleEvent^l ）を伴う`利用者~obj$により その~ifcを実装することが，許容される必要があるものと見なされている、既存の~APIの例である。
新たな~API, あるいは互換性の心配がない~API用の`呼戻~関数$には、（~ES言語束縛においては）`関数~obj$のみが許容されることになる。
◎
The definition of EventListener as a callback interface is an example of an existing API that needs to allow user objects with a given property (in this case “handleEvent”) to be considered to implement the interface. For new APIs, and those for which there are no compatibility concerns, using a callback function will allow only a function object (in the ECMAScript language binding).
</p>
</div>

<p class="issue">
上の警告は，将来に呼戻~ifcを拡張する際には、おそらく適用されるべきではないであろう。
それが単一~演算~呼戻~ifcから取り掛かる良い理由になると見られる。
◎
Perhaps this warning shouldn’t apply if you are planning to extend the callback interface in the future. That’s probably a good reason to start off with a single operation callback interface.
</p>

<p class="issue">
編集者は，［
所与の呼戻~ifcを実装している利用者~obj上で，演算が実装されていない場合
］を~supportする必要があると考えている。
既存の呼戻~ifcを拡張する仕様は、おそらく，実装されていない演算の~callを避けることが求まれるであろう（代わりに何らかの既定の挙動を持たせて）。
従って，演算が実装されているかどうか意味する用語が定義されるべきであろう
—
~ES言語束縛における，~propの有無の検査に対応することになるような。
◎
I think we need to support operations not being implemented on a given user object implementing a callback interface. If specs extending an existing callback interface, we probably want to be able to avoid calling the operations that aren’t implemented (and having some default behavior instead). So we should perhaps define a term that means whether the operation is implemented, which in the ECMAScript binding would correspond to checking for the property’s existence.
</p>

<div class="note">
<p>
関数~引数として
“~propの集まり（ property bag ）”
のような~ES~objをとる~APIを定義する仕様の策定者には、`呼戻~ifc$よりも`辞書$の利用を勧める。
◎
Specification authors wanting to define APIs that take ECMAScript objects as “property bag” like function arguments are suggested to use dictionaries rather than callback interfaces.
</p>

<p>
例えば，次のものは：
◎
For example, instead of this:
</p>

<pre class="webidl">
callback interface Options {
  attribute DOMString? option1;
  attribute DOMString? option2;
  attribute long? option3;
};

interface A {
  void doTask(DOMString %type, Options %options);
};
</pre>

<p>
次の様な利用を可能にするために：
◎
to be used like this:
</p>

<pre class="es-code">
var %a = getA();  /* <span class="comment">
`A^T の~instanceを取得する。
◎
Get an instance of A.
</span> */

%a.doTask("something", { option1: "banana", option3: 100 });
</pre>

<p>
代わりに，次のように記す：
◎
instead write the following:
</p>

<pre class="webidl">
dictionary Options {
  DOMString? option1;
  DOMString? option2;
  long? option3;
};

interface A {
  void doTask(DOMString %type, optional Options %options);
};
</pre>
</div>

<p>
~ifcに対する~IDLは、
`部分的~ifc定義@
（ `partial^sym `PartialInterfaceRest$g に合致）を利用して，複数の部分に分割できる。
部分的~ifc定義の`識別子$は、その~ifc定義の識別子と同じで~MUST。
それぞれの部分的~ifcに現れる，すべての~mbは、その~ifc自身の~mbであるものと見なされる。
◎
The IDL for interfaces can be split into multiple parts by using partial interface definitions (matching partial PartialInterfaceRest). The identifier of a partial interface definition must be the same as the identifier of an interface definition. All of the members that appear on each of the partial interfaces are considered to be members of the interface itself.
</p>

<pre class="syntax">
interface `SomeInterface^mk {
  /* interface_members... */
};

partial interface `SomeInterface^mk {
  /* interface_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義に意図される用途は、~ifcの定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助することである。
◎
Note: Partial interface definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p>
`~ifc$定義, およびその`部分的~ifc定義$が現れる順序は問題にされない。
◎
The order of appearance of an interface definition and any of its partial interface definitions does not matter.
</p>

<p class="note">注記：
部分的~ifc定義においては、別の~ifcからの`継承-$は指定できない。
継承は元の`~ifc$定義に指定され~MUST。
◎
Note: A partial interface definition cannot specify that the interface inherits from another interface. Inheritance must be specified on the original interface definition.
</p>

<p>
多少の制限もあるが、`部分的~ifc定義$にも，`拡張属性$を指定できる。
次の拡張属性は，部分的~ifc定義に指定されては~MUST_NOT：
`Constructor$x,
`LegacyArrayClass$x,
`LegacyWindowAlias$x,
`NamedConstructor$x,
`NoInterfaceObject$x
◎
Extended attributes can be specified on partial interface definitions, with some limitations. The following extended attributes must not be specified on partial interface definitions: [Constructor], [LegacyArrayClass], [LegacyWindowAlias], [NamedConstructor], [NoInterfaceObject].
</p>


<p class="note">注記：
`Exposed$x,
`Global$x,
`OverrideBuiltins$x,
`PrimaryGlobal$x,
`SecureContext$x
を除き，上に挙げたものが
この文書に定義される中で`~ifc$に適用できる`拡張属性$のすべてである。
◎
Note: The above list of extended attributes is all of those defined in this document that are applicable to interfaces except for [Exposed], [Global], [OverrideBuiltins], [PrimaryGlobal], and [SecureContext].
</p>

<p>
`部分的~ifc定義$に指定される
`拡張属性$は
`~ifc$自身に現れるものと見なされる。
◎
Any extended attribute specified on a partial interface definition is considered to appear on the interface itself.
</p>

<p>
関連する言語束縛が，~ifcと［
言語の構成子
］との間の対応付けを決定する。
◎
The relevant language binding determines how interfaces correspond to constructs in the language.
</p>

<p>
~ifcには、次の拡張属性を適用できる
⇒
`Constructor$x,
`Exposed$x,
`Global$x,
`LegacyArrayClass$x,
`LegacyWindowAlias$x,
`NamedConstructor$x,
`NoInterfaceObject$x,
`OverrideBuiltins$x,
`PrimaryGlobal$x,
`SecureContext$x
◎
The following extended attributes are applicable to interfaces: [Constructor], [Exposed], [Global], [LegacyArrayClass], [LegacyWindowAlias], [NamedConstructor], [NoInterfaceObject], [OverrideBuiltins], [PrimaryGlobal], and [SecureContext].
</p>

<div class="grammar">
CallbackOrInterfaceOrMixin
CallbackRestOrInterface
InterfaceOrMixin
InterfaceRest
Partial
PartialDefinition
PartialInterfaceOrPartialMixin
PartialInterfaceRest
InterfaceMembers
InterfaceMember
Inheritance
</div>

<div class="example">

<p>
次の`~IDL片$に、 2 つの相互に参照しあう`~ifc$
— `Human^T と `Dog^T —
の定義~例を示す。
いずれも `Animal^T を継承するので、 2 つの~ifcいずれかを実装する~objは， `name^M 属性も持つことになる。
◎
The following IDL fragment demonstrates the definition of two mutually referential interfaces. Both Human and Dog inherit from Animal. Objects that implement either of those two interfaces will thus have a name attribute.
</p>

<pre class="webidl">
interface Animal {
  attribute DOMString name;
};

interface Human : Animal {
  attribute Dog? pet;
};

interface Dog : Animal {
  attribute Human? owner;
};
</pre>
</div>


<div class="example">
<p>
次の`~IDL片$は
DOM `~ifc$の一部を単純化した~versionを定義する。
うち 1 個は`呼戻~ifc$である。
◎
The following IDL fragment defines simplified versions of a few DOM interfaces, one of which is a callback interface.
</p>

<pre class="webidl">
interface Node {
  readonly attribute DOMString nodeName;
  readonly attribute Node? parentNode;
  Node appendChild(Node %newChild);
  void addEventListener(DOMString %type, EventListener %listener);
};

callback interface EventListener {
  void handleEvent(Event %event);
};
</pre>

<p>
`EventListener^T ~ifcは呼戻~注釈付きの~ifcなので，`利用者~obj$により実装できる：
◎
Since the EventListener interface is annotated callback interface, user objects can implement it:
</p>

<pre class="es-code">
var %node = getNode();  /* <span class="comment" id="cp-get-Node">
`Node^T の~instanceを得る。
◎
Obtain an instance of Node.
</span> */

var %listener = {
  handleEvent: function(%event) {
    /* <span class="comment" id="cp-some-code">...</span> */
  }
};
%node.addEventListener("click", %listener);            /* <span class="comment">
これは働く。
◎
This works.
</span> */

%node.addEventListener("click", function() { ... });  /* <span class="comment">
これと同様に。
◎
As does this.
</span> */
</pre>

<p>
しかしながら，利用者~objは
`Node^T を実装することはできない：
◎
It is not possible for a user object to implement Node, however:
</p>

<pre class="es-code">
var %node = getNode();  /* <!--cp-get-Node--> */

var %newNode = {
  nodeName: "span",
  parentNode: null,
  appendChild: function(%newchild) {
    /* <!--cp-some-code--> */
  },
  addEventListener: function(%type, %listener) {
    /* <!--cp-some-code--> */
  }
};
%node.appendChild(%newNode);  /* <span class="comment">
`TypeError^jE 例外が投出されることになる。
◎
This will throw a TypeError exception.
</span> */
</pre>
</div>


		</section>
		<section id="idl-interface-mixins">
<h3 title="Interface mixins">2.3. ~ifc~mixin</h3>

<p>
`~ifc~mixin@
は、［
それを`内包-$する`~ifc$を実装する各~obj
］により公開される状態や挙動を宣言する，`定義$（
`interface^sym `MixinRest$g
に合致）である。
`~ifc~mixin$は、複数の`~ifc$に`内包-$され得る。
◎
An interface mixin is a definition (matching interface MixinRest) that declares state and behavior that can be included by one or more interfaces, and that are exposed by objects that implement an interface that includes the interface mixin.
</p>


<pre class="webidl">
interface mixin identifier {
  /* mixin_members... */
};
</pre>

<p class="note">注記：
`~ifc~mixin$に意図されている用途は、`部分的~ifc$と同様に，［
複数の~ifcに
— 場合によっては複数の文書にわたって —
内包されるような，首尾一貫する機能性の集合
］を一つに~group化できるようにして，仕様の編集を補助することである。
それには、言語束縛を通して公開されることは意味されていない。
［
`部分的~ifc$, `~ifc~mixin$, `部分的~ifc~mixin$
］のどれを選ぶかについての目安は、
`using-mixins-and-partials$sec
に見出せる。
◎
Note: Interface mixins, much like partial interfaces, are intended for use as a specification editorial aide, allowing a coherent set of functionalities to be grouped together, and included in multiple interfaces, possibly across documents. They are not meant to be exposed through language bindings. Guidance on when to choose partial interfaces, interface mixins, or partial interface mixins can be found in §2.3.1 Using mixins and partials.
</p>

<p>
`~ifc~mixin$は、その宣言を成す波括弧の合間に現れる，一連の`~mb$
— ［
`定数$,
`正則~演算$,
`正則~属性$,
`文字列化子$
］ —
が成す集合（
`MixinMembers$g
に合致）の仕様である。
これらの~mbは、
`~ifc~mixin~mb@
と称され、それぞれが［
当の`~ifc~mixin$を`内包-$する`~ifc$
］に指定されていたかのように，~objに実装できる挙動を述べる。
◎
An interface mixin is a specification of a set of interface mixin members (matching MixinMembers), which are the constants, regular operations, regular attributes, and stringifiers that appear between the braces in the interface mixin declaration.
◎
These constants, regular operations, regular attributes, and stringifiers describe the behaviors that can be implemented by an object, as if they were specified on the interface that includes them.
</p>

<p>
`~ifc~mixin$の宣言には、次に挙げるものは現れ得ない
⇒
`静的~属性$ ／
`静的~演算$ ／
`文字列化子$を除く`特殊~演算$ ／
`可反復~宣言$ ／
`~maplike 宣言$ ／
`~setlike 宣言$
◎
Static attributes, static operations, special operations except for stringifiers, and iterable, maplike, and setlike declarations cannot appear in interface mixin declarations.
</p>

<p>
~ifcと同じく，`~ifc~mixin$用の~IDLは、
`部分的~ifc~mixin@
定義（
`partial^sym `interface^sym `MixinRest$g
に合致）を用いて，複数の部分に分割できる。
`部分的~ifc~mixin$`定義$の`識別子$は、`~ifc~mixin$`定義$の`識別子$と同じで~MUST。
各`部分的~ifc~mixin$`定義$に現れる どの`~ifc~mixin~mb$も，［
`~ifc~mixin$自身に加え，当の`~ifc~mixin$を
— 拡張により —
`内包-$している`~ifc$
］の`~mb$であると見なされる。
◎
As with interfaces, the IDL for interface mixins can be split into multiple parts by using partial interface mixin definitions (matching partial interface MixinRest). The identifier of a partial interface mixin definition must be the same as the identifier of an interface mixin definition. All of the members that appear on each of the partial interface mixin definitions are considered to be members of the interface mixin itself, and—by extension—of the interfaces that include the interface mixin.
</p>


<pre class="webidl">
interface mixin `SomeMixin^mk {
  /* mixin_members... */
};

partial interface mixin `SomeMixin^mk {
  /* mixin_members... */
};
</pre>


<p>
~mbたちが現れる順序は、
<a href="#es-namespaces">~ES言語束縛</a>
における~prop列挙に，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
`~ifc$や`辞書$と違って、`~ifc~mixin$は，型を作成しないことに注意。
◎
Note that unlike interfaces or dictionaries, interface mixins do not create types.
</p>

<p>
この仕様に定義される拡張属性のうち，`~ifc~mixin$に適用できる拡張属性は、
`Exposed$x, `SecureContext$x
に限られる。
◎
Of the extended attributes defined in this specification, only the [Exposed] and [SecureContext] extended attributes are applicable to interface mixins.
</p>

<p>
`~includes文@
は、［
（ 1 個目の`識別子$により識別される）`~ifc$ %I が
（ 2 個目の`識別子$により識別される）`~ifc~mixin$ %M を
`内包-@
すること
— すなわち， %I を実装しているすべて~objは， %M も内包し~MUSTこと —
を宣言するために利用される，`定義$（
`IncludesStatement$g
に合致）である。
◎
An includes statement is a definition (matching IncludesStatement) used to declare that all objects implementing an interface I (identified by the first identifier) must additionally include the [=interface mixin member|members] of interface mixin M (identified by the second identifier). Interface I is said to include interface mixin M.
</p>


<pre class="webidl">
interface_identifier includes mixin_indentifier;
</pre>

<p>
1 個目の`識別子$は ［
`呼戻~ifc$／`~ifc$
］を参照し~MUST。
2 個目の識別子は `~ifc~mixin$を参照し~MUST。
◎
The first identifier must reference a non-callback interface I. The second identifier must reference an interface mixin M.
</p>

<p>
%M の各`~ifc~mixin~mb$は、
%M を`内包-$する各`~ifc$［
%I, %J, %K, …
］の`~mb$と見なされる
— 各~ifcごとに，`~ifc~mixin~mb$の複製が作られたかのように。
すなわち、
%M のある~mb %m に対し，~ifc［
%I  ／ %J ／ %K ／ …
］は`~mb$［
%m<sub>%I</sub> ／ %m<sub>%J</sub> ／ %m<sub>%K</sub> ／ …
］を持つと見なされる。
［
%m<sub>%I</sub> ／ %m<sub>%J</sub> ／ %m<sub>%K</sub> ／ …
］の
`~host~ifc@
は、［
%I  ／ %J ／ %K ／ 等々
］になる。
◎
Each member of M is considered to be a member of each interface I, J, K, … that includes M, as if a copy of each member had been made. So for a given member m of M, interface I is considered to have a member mI, interface J is considered to have a member mJ, interface K is considered to have a member mK, and so on. The host interfaces of mI, mJ, and mK, are I, J, and K respectively.
</p>

<div class="note">
<p>注記：
このことは，~ESにおいては、次のことを含意する
— `~ifc~mixin$ %M に宣言された各`~ifc~mixin~mb$ %m に対し：
</p>

<ul>
	<li>
%m は［
`正則~演算$であり，`組込みの関数~obj$値を伴うものとして公開される~data~prop
］になるならば、［
%M を`内包-$する 各`~ifc$に結付けられている`~ifc原型~obj$
］ごとに，別個の`組込みの関数~obj$がある。
</li>
	<li>
%m は`属性$ならば、その~accessor~propの各~複製ごとに別個の`組込みの関数~obj$が，［
取得子 ／ 設定子
］用にある。
</li>
</ul>

◎
Note: In ECMAScript, this implies that each regular operation declared as a member of interface mixin M, and exposed as a data property with a built-in function object value, is a distinct built-in function object in each interface prototype object whose associated interface includes M. Similarly, for attributes, each copy of the accessor property has distinct built-in function objects for its getters and setters.
</div>

<p>
`~includes文$が現れる順序は、`~ifc~mixin$が`~host~ifc$に`内包-$される順序に影響する。
【その順序は何に影響する？】
◎
The order of appearance of includes statements affects the order in which interface mixin are included by their host interface.
</p>


<p class="issue">
`~ifc~mixin~mb$の順序は、まだ明瞭に指定されていない
— 特に、`~ifc~mixin$が別々の文書~内に定義されている場合には。
<a href="https://github.com/heycam/webidl/issues/432">issue #432</a>
にて論じられている。
◎
Member order isn’t clearly specified, in particular when interface mixins are defined in separate documents. It is discussed in issue #432.
</p>

<p>
`~includes文$に適用できる`拡張属性$は、この仕様には定義されていない。
◎
No extended attributes defined in this specification are applicable to includes statements.
</p>

<div class="example">

<p>
次の`~IDL片$は、［
`~ifc$ `Entry^T,
`~ifc~mixin$ `Observable^T
］を定義する。
`~includes文$は、［
`Observable^T の`~ifc~mixin~mb$は，
`Entry^T を実装している~objに常に内包される
］ことを指定する。
◎
The following IDL fragment defines an interface, Entry, and an interface mixin, Observable. The includes statement specifies that Observable’s members are always included on objects implementing Entry.
</p>

<pre class="webidl">
interface Entry {
  readonly attribute unsigned short entryType;
  /* <!--cp-some-code--> */
};

interface mixin Observable {
  void addEventListener(DOMString %type, EventListener %listener, boolean %useCapture);
  /* <!--cp-some-code--> */
};

Entry includes Observable;
</pre>

<p>
~ES実装は、各 `Entry^T ごとに，その原型鎖~内に
`addEventListener^l ~propを有することになる：
◎
An ECMAScript implementation would thus have an “addEventListener” property in the prototype chain of every Entry:
</p>

<pre class="es-code">
var %e = getEntry();          /* <span class="comment">
`Entry^T の~instanceを得る。
◎
Obtain an instance of Entry.
</span> */
typeof %e.addEventListener;   /* <!--cp-eval-function--> */
</pre>
</div>


<div class="grammar">
CallbackOrInterfaceOrMixin
InterfaceOrMixin
Partial
PartialDefinition
MixinRest
MixinMembers
MixinMember
IncludesStatement
</div>

			<section id="using-mixins-and-partials">
<h4 title="Using mixins and partials">2.3.1. ~mixinと~partialの用法</h4>

~INFORMATIVE

<p>
`~ifc~mixin$は、［
`属性$ ／ `定数$ ／ `演算$
］を，<em>複数</em>の`~ifc$から共有できるようにする。
単独の~ifcを拡張したければ、代わりに`部分的~ifc$の利用を考えるであろう。
◎
Interface mixins allow the sharing of attributes, constants, and operations across multiple interfaces. If you’re only planning to extend a single interface, you might consider using a partial interface instead.
</p>

<p>
例えば，次に代えて：
◎
For example, instead of:
</p>

<pre class="webidl">
interface mixin WindowSessionStorage {
  readonly attribute Storage sessionStorage;
};
Window includes WindowSessionStorage;
</pre>

<p>
次にするなど：
◎
do:
</p>

<pre class="webidl">
partial interface Window {
  readonly attribute Storage sessionStorage;
};
</pre>

<p>
加えて，共通的な利用~事例
— 一連の［
`属性$, `定数$, `演算$
］の集合を，
~window, ~worker
両~文脈に`公開され$るようにするなど —
を~~対象にするため、他の仕様により公開される`~ifc~mixin$を拡張することに依拠できる。
◎
Additionally, you can rely on extending interface mixins exposed by other specifications to target common use cases, such as exposing a set of attributes, constants, or operations across both window and worker contexts.
</p>

<p>
例えば、共通的にあるが冗長な，次のものに代えて：
◎
For example, instead of the common but verbose:
</p>

<pre class="webidl">
interface mixin GlobalCrypto {
  readonly attribute Crypto crypto;
};

Window includes GlobalCrypto;
WorkerGlobalScope includes GlobalCrypto;
</pre>

<p>
`部分的~ifc~mixin$を用いれば，
`WindowOrWorkerGlobalScope$T `~ifc~mixin$を拡張できる：
◎
you can extend the WindowOrWorkerGlobalScope interface mixin using a partial interface mixin:
</p>


<pre class="webidl">
partial interface mixin WindowOrWorkerGlobalScope {
  readonly attribute Crypto crypto;
};
</pre>

			</section>
		</section>
		<section id="idl-members">
<h3 title="Members">2.4. ~mb</h3>

<p>
［
`~ifc$ ／ `~ifc~mixin$ ／ `~ns$
］は、その宣言を成す波括弧の合間に現れる，一連の
`~mb@
— ［
`定数$, `属性$, `演算$, その他の宣言
］ —
からなる集合（順に，
`InterfaceMembers$g ／
`MixinMembers$g ／
`NamespaceMembers$g
に合致）の仕様である。
%A を実装している~objを %O とするとき
⇒＃
`属性$は、 %O が公開することになる状態を述べる。
`演算$は、 %O 上で呼出せる挙動を述べる。
`定数$は、 %O に公開される有名~定数~値を宣言する — ~systemにおける %O の利用者~用の便利として。
◎
Interfaces, interface mixins, and namespaces are specifications of a set of members (respectively matching InterfaceMembers, MixinMembers, and NamespaceMembers), which are the constants, attributes, operations, and other declarations that appear between the braces of their declarations. Attributes describe the state that an object implementing the interface, interface mixin, or namespace will expose, and operations describe the behaviors that can be invoked on the object. Constants declare named constant values that are exposed as a convenience to users of objects in the system.
</p>

<p>
［
`~ifc$,
`~ifc~mixin$,
`~ns$
］が~supportする`~mb$の~~種類は、それぞれに異なる
— それらは順に
`idl-interfaces$sec,
`idl-interface-mixins$sec,
`idl-namespaces$sec
にて指定され，次の表（参考）に要約される：
◎
Interfaces, interface mixins, and namespaces each support a different set of members, which are specified in §2.2 Interfaces, §2.3 Interface mixins, and §2.5 Namespaces, and summarized in the following informative table:
</p>


<table><thead><tr><th>
<th>`~ifc$
<th>`呼戻~ifc$
<th>`~ifc~mixin$
<th>`~ns$
</thead><tbody>

<tr><th>`定数$
<td>●
<td>●
<td>●
<td>

<tr><th>`正則~属性$
<td>●
<td>●
<td>●
<td>`読専$属性のみ

<tr><th>`静的~属性$
<td>●
<td>
<td>
<td>

<tr><th>`正則~演算$
<td>●
<td>●
<td>●
<td>●

<tr><th>`特殊~演算$
<td>●
<td>
<td>`文字列化子$のみ
<td>


<tr><th>`静的~演算$
<td>●
<td>
<td>
<td>

<tr><th>`可反復~宣言$
<td>●
<td>
<td>
<td>

<tr><th>`~maplike 宣言$
<td>●
<td>
<td>
<td>


<tr><th>`~setlike 宣言$
<td>●
<td>
<td>
<td>
</tbody></table>


			<section id="idl-constants">
<h4 title="Constants">2.4.1. 定数</h4>


<p>
`定数@
は、定数~値を名前に束縛するために利用される，宣言（ `Const$g に合致）である。
定数は`~ifc$に現れ得る。
◎
A constant is a declaration (matching Const) used to bind a constant value to a name. Constants can appear on interfaces.
</p>


<p class="advisement">
過去においては，定数は、主に，有名~整数~codeを列挙する~styleで定義されていた。
~Web~platformは、文字列~利用の支持を受けて，この設計~patternから離れつつある。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use Constants$fI
した上で論交することを，強く勧める。
◎
Constants have in the past primarily been used to define named integer codes in the style of an enumeration. The Web platform is moving away from this design pattern in favor of the use of strings. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<pre class="syntax">
const `type^i `constant_identifier^i = 42;
</pre>

<p>
`定数$の`識別子$は［
同じ~ifc上で定義される別の`~ifc~mb$
］の識別子と同じになっては~MUST_NOT。
また、識別子が［
`length^l ／ `name^l ／ `prototype^l
］になっては~MUST_NOT。
◎
The identifier of a constant must not be the same as the identifier of another interface member defined on the same interface.  The identifier also must not be “length”, “name” or “prototype”.
</p>

<p class="note">
これらの名前は、`関数~obj$に存在する~propの名前である。
◎
Note: These three names are the names of properties that may exist on function objects at the time the function object is created in the ECMAScript language binding.
</p>

<p>
定数の型（ `ConstType$g に合致）は、［
`~primitive型$または`~nullable$~primitive型
］で~MUST。
`識別子$が利用される場合、その識別子は［
~primitive型または~nullable~primitive型<!-- numeric？ -->
］の`~typedef$を参照し~MUST。
◎
The type of a constant (matching ConstType) must not be any type other than a primitive type or a nullable primitive type. If an identifier is used, it must reference a typedef whose type is a primitive type or a nullable primitive type.
</p>

<div class="p">
<p>
定数~宣言の `ConstValue$g 部は定数の値を与え、次のいずれかとして与えられる
`定数~tok@
をとり得る：
</p>

<ul ><li>2 個の真偽~literal： `true^c と `false^c
</li><li>`null^c
</li><li>`integer$g
</li><li>`float$g
</li><li>3 個の特別な浮動小数点~定数~値： `-Infinity^c, `Infinity^c, `NaN^c
</li></ul>

<p class="trans-note">【
`定数~tok$は、他所から簡潔に参照できるよう，この訳にて導入した用語である。
】</p>
◎
The ConstValue part of a constant declaration gives the value of the constant, which can be one of the two boolean literal tokens (true and false), the null token, an integer token, a float token, or one of the three special floating point constant values (-Infinity, Infinity and NaN).
</div>

<p class="note">注記：
文字列や空~連列に加え，これらの値も［
辞書~mbの`既定~値$diCや, 随意~引数の`既定~値$
］を指定するために利用できる。
文字列や空~連列 `[]^c は、`定数$の値には利用できないことに注意。
◎
Note: These values – in addition to strings and the empty sequence – can also be used to specify the default value of a dictionary member or of an optional argument. Note that strings and the empty sequence [] cannot be used as the value of a constant.
</p>

<p>
真偽~literal~tokの値は、それぞれ，
~IDL `boolean$T 値［
`true^V, `false^V
］になる。
◎
The value of the boolean literal tokens true and false are the IDL boolean values true and false.
</p>

<p>
`integer$g ~tokの値は、次に従って決定される整数~値になる：
◎
The value of an integer token is an integer whose value is determined as follows:
</p>

<ol class="algorithm">
	<li>
%S ~LET `integer$g ~tokに合致する文字~並び
◎
Let S be the sequence of characters matched by the integer token.
</li>
	<li>
%sign ~LET ［
%S の先頭が
`U+002D HYPHEN-MINUS ("-")^char
ならば −1 ／
~ELSE_ 1
］
◎
Let sign be −1 if S begins with U+002D HYPHEN-MINUS ("-"), and 1 otherwise.
</li>
	<li>
<p>
%base ~LET %S から先頭の
`U+002D HYPHEN-MINUS ("-")^char
は（もしあれば）除いた残りの部分の，頭部の文字~並びに基づく基数：
◎
Let base be the base of the number based on the characters that follow the optional leading U+002D HYPHEN-MINUS ("-") character:
</p>
		<dl class="switch">
<dt>`0X^l （
`U+0030 DIGIT ZERO ("0")^char,
`U+0058 LATIN CAPITAL LETTER X ("X")^char
）</dt>
<dt>`0x^l （
`U+0030 DIGIT ZERO ("0")^char,
`U+0078 LATIN SMALL LETTER X ("x")^char
）</dt>
<dd>
基数は 16
◎
The base is 16.
</dd>
<dt>`U+0030 DIGIT ZERO ("0")^char</dt>
<dd>
基数は 8
◎
The base is 8.
</dd>
<dt title="Otherwise">その他</dt>
<dd>
基数は 10
◎
The base is 10.
</dd>
		</dl>
	</li>
	<li>
%number ~LET %S から頭部の ［
`U+002D HYPHEN-MINUS ("-")^char ／
基数を指示する文字~並び
］を（もしあれば）除いた残りの文字すべてを，指定された基数 %base に基づいて整数に解釈した結果
◎
Let number be the result of interpreting all remaining characters following the optional leading U+002D HYPHEN-MINUS ("-") character and any characters indicating the base as an integer specified in base base.
</li>
	<li>
~RET %sign × %number
◎
Return sign × number.
</li>
</ol>

<p>
`integer$g ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じである。
`integer$g ~tokの値は、
`idl-types$sec
で与えられる，その型の値として妥当な範囲に入ら~MUST。
◎
The type of an integer token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the integer token must not lie outside the valid range of values for its type, as given in §2.12 Types.
</p>

<p id="float-token-value">
`float$g ~tokの値は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次に従って決定される：
◎
The value of a float token is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument it is being used as the value for, determined as follows:
</p>

<ol class="algorithm">
	<li>
%S ~LET `float$g ~tokに合致する文字~並び
◎
Let S be the sequence of characters matched by the float token.
</li>
	<li>
%result ~LET %S を~ES `NumericLiteral$i として構文解析して得られる `Mathematical Value^i
◎
Let result be the Mathematical Value that would be obtained if S were parsed as an ECMAScript NumericLiteral.
</li>
	<li>
<p>
`float$g ~tokは どの型の値として利用されているかに応じて：
</p>
		<dl class="switch">
			<dt>`float$T</dt>
			<dt>`unrestricted float$T</dt>
			<dd>
~RET %result に最も近い IEEE 754 単精度 浮動小数点数
</dd>

			<dt>`double$T</dt>
			<dt>`unrestricted double$T</dt>
			<dd>
~RET %result に最も近い IEEE 754 倍精度 浮動小数点数
</dd>
		</dl>
<p>
`IEEE-754$r
</p>
◎
If the float token is being used as the value for a float or unrestricted float, then the value of the float token is the IEEE 754 single-precision floating point number closest to result.
◎
Otherwise, the float token is being used as the value for a double or unrestricted double, and the value of the float token is the IEEE 754 double-precision floating point number closest to result. [IEEE-754]
</li>
</ol>

<p>
`Infinity^c, `-Infinity^c, `NaN^c
のいずれかとして指定された定数~値は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型に依存して，単精度, 倍精度 いずれかの IEEE 754 浮動小数点数になり、次に従って決定される：
◎
The value of a constant value specified as Infinity, -Infinity or NaN is either an IEEE 754 single-precision floating point number or an IEEE 754 double-precision floating point number, depending on the type of the constant, dictionary member or optional argument is is being used as the value for:
</p>


<dl class="switch">
	<dt>
`unrestricted float$T 型の定数~値 `Infinity^c
◎
Type unrestricted float, constant value Infinity
</dt>
	<dd>
値は IEEE 754 単精度，正の無限~値
◎
The value is the IEEE 754 single-precision positive infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `Infinity^c
◎
Type unrestricted double, constant value Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，正の無限~値
◎
The value is the IEEE 754 double-precision positive infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `-Infinity^c
◎
Type unrestricted float, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 単精度，負の無限~値
◎
The value is the IEEE 754 single-precision negative infinity value.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `-Infinity^c
◎
Type unrestricted double, constant value -Infinity
</dt>
	<dd>
値は IEEE 754 倍精度，負の無限~値
◎
The value is the IEEE 754 double-precision negative infinity value.
</dd>
	<dt>
`unrestricted float$T 型の定数~値 `NaN^c
◎
Type unrestricted float, constant value NaN
</dt>
	<dd>
値は~bit~pattern 0x7fc00000 の， IEEE 754 単精度 NaN
◎
The value is the IEEE 754 single-precision NaN value with the bit pattern 0x7fc00000.
</dd>
	<dt>
`unrestricted double$T 型の定数~値 `NaN^c
◎
Type unrestricted double, constant value NaN
</dt>
	<dd>
値は~bit~pattern 0x7ff8000000000000 の， IEEE 754 倍精度 NaN
◎
The value is the IEEE 754 double-precision NaN value with the bit pattern 0x7ff8000000000000.
</dd>
</dl>

<p>
`float$g ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じになる。
`float$g ~tokの値は、
`idl-types$sec
で与えられる，その型の値として妥当な範囲に入ら~MUST。
また、［
`Infinity^c, `-Infinity^c, `NaN^c
］が［
`float$T や `double$T
］の値として利用されては~MUST_NOT。
◎
The type of a float token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of. The value of the float token must not lie outside the valid range of values for its type, as given in §2.12 Types. Also, Infinity, -Infinity and NaN must not be used as the value of a float or double.
</p>

<p>
`null^c ~tokの値は、`~nullable型$に属する特別な `null^V 値である。
`null^c ~tokの型は、それを値に利用している
［ 定数／辞書~mb／随意~引数 ］
の型と同じになる。
◎
The value of the null token is the special null value that is a member of the nullable types. The type of the null token is the same as the type of the constant, dictionary member or optional argument it is being used as the value of.
</p>

<p>
%VT を定数にあてがわれる値の型,
%DT を［ 定数／辞書~mb／随意~引数 ］自身の型とするとき、これらの型は互換，すなわち %DT と %VT が一致するか, または
%DT はその`内縁~型$が %VT であるような`~nullable型$でなければ~MUST。
◎
If VT is the type of the value assigned to a constant, and DT is the type of the constant, dictionary member or optional argument itself, then these types must be compatible, which is the case if DT and VT are identical, or DT is a nullable type whose inner type is VT.
</p>

<p>
`定数$は、それが現れる`~ifc$の特定0の~instanceには結付けられない。
`定数$が~instanceにも公開されるかどうかは、言語束縛に特有になる。
◎
Constants are not associated with particular instances of the interface on which they appear. It is language binding specific whether constants are exposed on instances.
</p>

<div class="note">

<p>
~ES言語束縛では，しかしながら、`定数$が宣言されている~IDL`~ifc$を実装する~objを通して，`定数$への~accessが許容される。
例えば次の~IDLでは：
◎
The ECMAScript language binding does however allow constants to be accessed through objects implementing the IDL interfaces on which the constants are declared. For example, with the following IDL:
</p>

<pre class="webidl">
interface A {
  const short rambaldi = 47;
};
</pre>

<p>
~ESにおいては、この定数~値は，［
`A.rambaldi^c および (`A^T の~instance)`.rambaldi^c
］として~accessできる。
◎
the constant value can be accessed in ECMAScript either as A.rambaldi or instanceOfA.rambaldi.
</p>
</div>

<p>
定数には、次の拡張属性を適用できる
⇒
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to constants: [Exposed], [SecureContext].
</p>

<div class="grammar">
Const
ConstValue
BooleanLiteral
FloatLiteral
ConstType
</div>


<div class="example">
<p>
次の`~IDL片$に、上の型の`定数$を定義する例を示す。
◎
The following IDL fragment demonstrates how constants of the above types can be defined.
</p>

<pre class="webidl">
interface Util {
  const boolean DEBUG = false;
  const octet LF = 10;
  const unsigned long BIT_MASK = 0x0000fc00;
  const double AVOGADRO = 6.022e23;
};
</pre>

</div>
			</section>
			<section id="idl-attributes">
<h4 title="Attributes">2.4.2. 属性</h4>


<p>
`属性@
（
`inherit^sym `ReadOnly$g `AttributeRest$g ／
`static^sym `ReadOnly$g `AttributeRest$g ／
`stringifier^sym `ReadOnly$g `AttributeRest$g ／
`ReadOnly$g `AttributeRest$g
いずれかに合致）は、［
`~ifc$を実装している~objが，［
所与の［
型, `識別子$
］により，値の取得0や（一部の場合は）変更を行える
］~data~fieldを持つことになる
］ことを宣言するために利用される，
`~ifc~mb$である。
属性は次の 2 種類に分けられる：
◎
An attribute is an interface member (matching inherit ReadOnly AttributeRest, static ReadOnly AttributeRest, stringifier ReadOnly AttributeRest, or ReadOnly AttributeRest) that is used to declare data fields with a given type and identifier whose value can be retrieved and (in some cases) changed. There are two kinds of attributes:
</p>

<ol>
	<li>
<p>
`正則~属性$は、［
当の`~ifc$を実装している~objが，所与の`識別子$を伴う~data~field~mbを持つことになる
］ことを宣言するために利用される。
◎
regular attributes, which are those used to declare that objects implementing the interface will have a data field member with the given identifier
</p>

<pre class="syntax">
interface `interface_identifier^i {
  attribute `type^i `identifier^i;
};
</pre>

	</li>
	<li>
<p>
`静的~属性$は、［
当の~ifcを実装している特定0の~objには結付けられない属性
］を宣言するために利用される。
◎
static attributes, which are used to declare attributes that are not associated with a particular object implementing the interface
</p>

<pre class="syntax">
interface `interface_identifier^i {
  static attribute `type^i `identifier^i;
};
</pre>

	</li>
</ol>

<p>
`static^c ~keywordを伴わない属性は
`正則~属性@
を宣言する。
そうでなければ，`静的~属性$を宣言する。
`読専$の`正則~属性$は、`~ifc~mb$であることに加え，`~ns~mb$も持ち得ることに注意。
◎
If an attribute has no static keyword, then it declares a regular attribute. Otherwise, it declares a static attribute. Note that in addition to being interface members, read only regular attributes can be namespace members as well.
</p>

<div class="p">
<p class="algo-head">
所与の %~target 上で属性 %属性 の
`下層の値を取得-@
するときは、次を走らす：
</p>

<ol>
	<li>
~IF［
%属性 は`取得子を継承-$するように宣言されている
］
⇒
%属性 ~SET 継承されている属性
</li>
	<li>
~RET
%属性 の取得子の記述に挙げられている動作を
— %~target ~NEQ ~NULL ならば %~target 上で —
遂行した結果
</li>
</ol>

◎
To get the underlying value of an attribute attr given a value target, return the result of performing the actions listed in the description of attr that occur on getting, or those listed in the description of the inherited attribute, if attr is declared to inherit its getter, on target if target is not null.
</div>

<p>
`属性$の`識別子$は［
同じ`~ifc$上に定義される別の`~ifc~mb$の識別子
］と同じになっては~MUST_NOT。
静的~属性の識別子が `prototype^l になっては~MUST_NOT。
◎
The identifier of an attribute must not be the same as the identifier of another interface member defined on the same interface. The identifier of a static attribute must not be “prototype”.
</p>

<p>
属性の型は、 `attribute^c ~keywordの後に現れる
型（ `Type$g に合致）で与えられる。
`Type$g が［
`識別子$, または `?^c が後続する識別子
］である場合、その識別子は［
~ifc, `列挙$, `呼戻~関数$, `~typedef$
］のいずれかとして識別され~MUST。
◎
The type of the attribute is given by the type (matching Type) that appears after the attribute keyword. If the Type is an identifier or an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef.
</p>

<p>
属性の型は、~typedefの解決-後に，次に挙げる型, あるいはその`~nullable型$になっては~MUST_NOT。
◎
The type of the attribute, after resolving typedefs, must not be a nullable or non-nullable version of any of the following types:
</p>


<ul id="cp-nullable-type-list">
	<li>
`連列~型$
◎
a sequence type
</li>
	<li>
`辞書~型$
◎
a dictionary type
</li>
	<li>
`~record型$
◎
a record type
</li>
	<li>
その`平坦化~mb型$に［
［ ~nullable／非~nullable ］の連列~型 ／ 辞書 ／ ~record<!-- 区切り？ -->
］を含んでいるような，`共用体~型$
【平坦化~mb型は~nullableを含み得ないので，この “~nullable” の記述は不要では？】
◎
a union type that has a nullable or non-nullable sequence type, dictionary, or record as one of its flattened member types
</li>
</ul>


<p>
`attribute^c ~keywordの前に `readonly^c ~keywordが利用されている場合、属性は
`読専@（ read only, 読み取り専用）
になる。
［
読専の属性が定義されている~ifc
］を実装する~objにおいては、その属性に対する代入は許容されないことになる。
代入が、単に言語において許容されないのか,
無視されるのか,
あるいは例外が投出されるのか，については、言語束縛に特有になる。
◎
The attribute is read only if the readonly keyword is used before the attribute keyword. An object that implements the interface on which a read only attribute is defined will not allow assignment to that attribute. It is language binding specific whether assignment is simply disallowed by the language, ignored or an exception is thrown.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly attribute `type^i `identifier^i;
};
</pre>

<p>
`~promise型$である属性は`読専$で~MUST。
加えて、［
`LenientSetter$x ／ `PutForwards$x ／ `Replaceable$x ／ `SameObject$x
］`拡張属性$を持ち得ない。
◎
Attributes whose type is a promise type must be read only. Additionally, they cannot have any of the extended attributes [LenientSetter], [PutForwards], [Replaceable], or [SameObject].
</p>

<p>
`読専$でない`正則~属性$は、先祖の~ifcからその
`取得子を継承-@
するように宣言できる。
これにより、先祖~ifcの読専の属性を，派生~ifc上で~writableにできる。
属性は、その宣言が `inherit^c を伴うとき，`取得子を継承-$するものとされる。
その属性が取得子を継承する読専の属性は、［
同じ識別子の属性が定義されている，先祖の~ifc
］のうち，最も末端の~ifcに属する属性である。
<!-- readonlyとは限らない？ -->
取得子を［
継承する側, される側
］の属性の型は同じで~MUST。
また、 `inherit^c が［
`読専$の属性／`静的~属性$
］に現れては~MUST_NOT。
◎
A regular attribute that is not read only can be declared to inherit its getter from an ancestor interface. This can be used to make a read only attribute in an ancestor interface be writable on a derived interface. An attribute inherits its getter if its declaration includes inherit in the declaration. The read only attribute from which the attribute inherits its getter is the attribute with the same identifier on the closest ancestor interface of the one on which the inheriting attribute is defined. The attribute whose getter is being inherited must be of the same type as the inheriting attribute, and inherit must not appear on a read only attribute or a static attribute.
</p>

<pre class="syntax">
interface `Ancestor^i {
  readonly attribute `TheType^i `theIdentifier^i;
};

interface `Derived^i : `Ancestor^i {
  inherit attribute `TheType^i `theIdentifier^i;
};
</pre>

<p>
`正則~属性$の宣言に `stringifier^c ~keywordが利用されている場合、その~ifcを実装している~objが文字列化されるときに，その属性の値になることを指示する。
詳細は
`idl-stringifiers$sec
を見よ。
◎
When the stringifier keyword is used in a regular attribute declaration, it indicates that objects implementing the interface will be stringified to the value of the attribute. See §2.4.4.1 Stringifiers for details.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier attribute DOMString `identifier^i;
};
</pre>

<p id="callback-attribute-exceptions">
実装が`利用者~obj$上の`属性$の値を取得-または設定しようと試みたときに（例えば 呼戻~objが実装に供されているとき），その試みによる~~結果，例外が投出される場合、他が指定されない限り，その例外は［
実装からその属性への~accessを生じさせた，利用者~code
］まで伝播することになる。
同様に、属性の取得-により返される値を~IDL型の値に変換できない場合、それにより生じた例外も［
実装からその属性の値の取得を試みさせた，利用者~code
］まで伝播することになる。
◎
If an implementation attempts to get or set the value of an attribute on a user object (for example, when a callback object has been supplied to the implementation), and that attempt results in an exception being thrown, then, unless otherwise specified, that exception will be propagated to the user code that caused the implementation to access the attribute. Similarly, if a value returned from getting the attribute cannot be converted to an IDL type, then any exception resulting from this will also be propagated to the user code that resulted in the implementation attempting to get the value of the attribute.
</p>

<p>
［
正則／静的
］属性には、次の`拡張属性$を適用できる：
`Exposed$x,
`SameObject$x,
`SecureContext$x
◎
The following extended attributes are applicable to regular and static attributes: [Exposed], [SameObject], [SecureContext].
</p>

<p>
次の`拡張属性$は、正則~属性のみに適用できる：
`LenientSetter$x,
`LenientThis$x,
`PutForwards$x,
`Replaceable$x,
`Unforgeable$x
◎
The following extended attributes are applicable only to regular attributes: [LenientSetter], [LenientThis], [PutForwards], [Replaceable], [Unforgeable].
</p>


<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteAttribute
AttributeRest
AttributeName
AttributeNameKeyword
ReadOnly
</div>

<div class="example">
<p>
次の`~IDL片$に，`~ifc$上にて`属性$を宣言する例を示す：
◎
The following IDL fragment demonstrates how attributes can be declared on an interface:
</p>

<pre class="webidl">
interface Animal {

  /* <span class="comment">
単純な，任意の文字列に設定され得る属性。
◎
A simple attribute that can be set to any string value.
</span> */
  readonly attribute DOMString name;

  /* <span class="comment">
値を代入できる属性。
◎
An attribute whose value can be assigned to.
</span> */
  attribute unsigned short age;
};

interface Person : Animal {

  /* <span class="comment">
取得子の挙動を `Animal^T から継承する属性。
`Person^T の記述にて指定する必要はない。
◎
An attribute whose getter behavior is inherited from Animal, and need not be specified in the description of Person.
</span> */
  inherit attribute DOMString name;
};
</pre>
</div>
			</section>
			<section id="idl-operations">
<h4 title="Operations">2.4.3. 演算</h4>


<p>
`演算@
（
`static^sym `OperationRest$g ／
`stringifier^sym `OperationRest$g ／
`RegularOperation$g ／
`SpecialOperation$g
いずれかに合致）は、その~ifcを実装している~obj上で呼出せる挙動を定義する，
`~ifc~mb$である。
演算には次の 3 種類がある：
◎
An operation is an interface member (matching static OperationRest, stringifier OperationRest, RegularOperation or SpecialOperation) that defines a behavior that can be invoked on objects implementing the interface. There are three kinds of operation:
</p>

<dl>
	<dt>`正則~演算$</dt>
	<dd>
その`~ifc$を実装している~objが、所与の`識別子$を伴う~methを持つことになることを宣言するために利用される。
◎
regular operations, which are those used to declare that objects implementing the interface will have a method with the given identifier
</dd>
	<dd>
<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(/* arguments... */);
};
</pre>
	</dd>

	<dt>`特殊~演算$</dt>
	<dd>
~objの~indexingや文字列化など、その~ifcを実装している~obj上の特殊な挙動を宣言するために利用される。
◎
special operations, which are used to declare special behavior on objects implementing the interface, such as object indexing and stringification
</dd>
	<dd>

<pre class="syntax">
interface `interface_identifier^i {
  /* special_keywords... */ `return_type^i `identifier^i(/* arguments... */);
  /* special_keywords... */ `return_type^i (/* arguments... */);
};
</pre>
	</dd>

	<dt>`静的~演算$</dt>
	<dd>
その~ifcを実装している特定0の~objには結付けられない演算を宣言するために利用される。
◎
static operations, which are used to declare operations that are not associated with a particular object implementing the interface
</dd>
	<dd>
<pre class="syntax">
interface `interface_identifier^i {
  static `return_type^i `identifier^i(/* arguments... */);
};
</pre>
	</dd>
</dl>

<p>
演算のうち，［
識別子を持つ
~AND
`static^sym ~keywordがない
］ものは、
`正則~演算@
を宣言する。
1 個~以上の`特殊~keyword$（すなわち，［
`Special$g に合致する~keyword, または
`stringifier^c ~keyword
］）が宣言に利用されている演算は，`特殊~演算$を宣言する。
演算を，正則~演算と特殊~演算を兼ねるように宣言することもできる。
特殊~演算についての詳細は、
`idl-special-operations$sec
を見よ。
`正則~演算$は、`~ifc~mb$になり得ることに加え，`~ns~mb$にもなり得ることに注意。
◎
If an operation has an identifier but no static keyword, then it declares a regular operation. If the operation has one or more special keywords used in its declaration (that is, any keyword matching Special, or the stringifier keyword), then it declares a special operation. A single operation can declare both a regular operation and a special operation; see §2.4.4 Special operations for details on special operations. Note that in addition to being interface members, regular operations can also be namespace members.
</p>

<p>
識別子を持たない演算は、いずれかの特殊~keywordを利用して，`特殊~演算$として宣言され~MUST。
◎
If an operation has no identifier, then it must be declared to be a special operation using one of the special keywords.
</p>

<p>
`正則~演算$／`静的~演算$の識別子は、同じ`~ifc$上に定義される`定数$や`属性$の識別子と同じになっては~MUST_NOT。
静的~演算の識別子が `prototype^l になっては~MUST_NOT。
◎
The identifier of a regular operation or static operation must not be the same as the identifier of a constant or attribute defined on the same interface. The identifier of a static operation must not be “prototype”.
</p>

<p class="note">注記：
しかしながら、識別子をその~ifc上の別の演算と同じにすることはできる。
演算の多重定義は、これにより指定される。
◎
Note: The identifier can be the same as that of another operation on the interface, however. This is how operation overloading is specified.
</p>

<p>
`静的~演算$の`識別子$は、同じ`~ifc$上に定義される`正則~演算$の識別子と同じになっては~MUST_NOT。
◎
The identifier of a static operation also must not be the same as the identifier of a regular operation defined on the same interface.
</p>

<p>
演算の
`返値型@
（ `ReturnType$g に合致）は、［
随意の［
演算の`識別子$
］］の前に現れる型により 与えられる。
返値型
`void@T
は，演算が値を返さないことを指示する。
返値型が `?^c 付きの`識別子$である場合、その識別子は［
~ifc , 辞書 , `列挙$ , `呼戻~関数$ , `~typedef$
］のいずれかに識別され~MUST。
◎
The return type of the operation is given by the type (matching ReturnType) that appears before the operation’s optional identifier. A return type of void indicates that the operation returns no value. If the return type is an identifier followed by ?, then the identifier must identify an interface, dictionary, enumeration, callback function or typedef.
</p>

<p>
演算の引数（ `ArgumentList$g に合致）は、宣言の中の丸括弧の合間にて与えられる。
それぞれの引数は、型（ `Type$g に合致）の後に
`識別子$（ `ArgumentName$g に合致）を続けて指定される。
◎
An operation’s arguments (matching ArgumentList) are given between the parentheses in the declaration. Each individual argument is specified as a type (matching Type) followed by an identifier (matching ArgumentName).
</p>

<p class="note">注記：
表現力のため、演算~引数の識別子には， `ArgumentNameKeyword$g 記号に合致する~keywordも，~escapeを要することなく 指定できる。
<!--  -->
◎
Note: For expressiveness, the identifier of an operation argument can also be specified as one of the keywords matching the ArgumentNameKeyword symbol without needing to escape it.
</p>

<p>
演算~引数の `Type$g が `?^c 付きの`識別子$である場合、その識別子は［
~ifc , `列挙$ , `呼戻~関数$ , `~typedef$
］のいずれかに識別され~MUST。
演算~引数の型が `?^c 付きでない`識別子$である場合、その識別子は，それらのいずれかの定義か, または `辞書$に識別され~MUST。
◎
If the Type of an operation argument is an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef. If the operation argument type is an identifier not followed by ?, then the identifier must identify any one of those definitions or a dictionary.
</p>

<p>
演算~引数の型が`~typedef$の解決-後に`~nullable型$になる場合、その`内縁~型$は`辞書~型$になっては~MUST_NOT。
◎
If the operation argument type, after resolving typedefs, is a nullable type, its inner type must not be a dictionary type.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, `type^i `identifier^i /* , ... */);
};
</pre>

<p>
各~引数の識別子は、同じ演算~宣言~内の他の引数の識別子と同じになっては~MUST_NOT。
◎
The identifier of each argument must not be the same as the identifier of another argument in the same operation declaration.
</p>

<p>
各~引数の前には、`拡張属性$の~list（ `ExtendedAttributeList$g に合致）を置くことができる
— それらは、その引数として渡された値が，言語束縛において どう取扱われるかを制御する。
◎
Each argument can be preceded by a list of extended attributes (matching ExtendedAttributeList), which can control how a value passed as the argument will be handled in language bindings.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i([`extended_attributes^mk] `type^i `identifier^i, [`extended_attributes^mk] `type^i `identifier^i /* , ... */);
};
</pre>


<div class="example">
<p>
次の`~IDL片$は
`~ifc$上に`正則~演算$を宣言する：
◎
The following IDL fragment demonstrates how regular operations can be declared on an interface:
</p>

<pre class="webidl">
interface Dimensions {
  attribute unsigned long width;
  attribute unsigned long height;
};

interface Button {

  /* <span class="comment">
引数をとらず, `boolean^T を返す演算
◎
An operation that takes no arguments and returns a boolean.
</span> */
  boolean isMouseOver();

  /* <span class="comment">
多重定義された演算。
◎
Overloaded operations.
</span> */
  void setDimensions(Dimensions %size);
  void setDimensions(unsigned long %width, unsigned long %height);
};
</pre>
</div>

<p>
演算の 最後の引数 の引数~型の直後に `...^c ~tokが利用されている場合、その演算は
`可変個の引数@
をとるもの（ variadic ）と見なされる。
<span class="trans-note">【
その最後の引数を
`可変個~引数@
もしくは
<dfn>末尾~引数</dfn>
と記すことにする。
】</span>
そのように宣言された演算は：
◎
An operation is considered to be variadic if the final argument uses the ... token just after the argument type.＼
</p>

<ul>
	<li>
その末尾~引数の後に任意~個数の引数を伴って呼出せることを指示し、それらの余分な暗黙の形式的~引数の型は，末尾~引数と同じ型と見なされる。
◎
Declaring an operation to be variadic indicates that the operation can be invoked with any number of arguments after that final argument. Those extra implied formal arguments are of the same type as the final explicit argument in the operation declaration.＼
</li>
	<li>
呼出すときには、末尾~引数を省略することもできる。
◎
The final argument can also be omitted when invoking the operation.＼
</li>
	<li>
末尾~引数~以外の引数が `...^c ~tokを伴って宣言されては~MUST_NOT。
◎
An argument must not be declared with the ... token unless it is the final argument in the operation’s argument list.
</li>
</ul>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i<em>...</em> `identifier^i);
  `return_type^i `identifier^i(`type^i `identifier^i, `type^i<em>...</em> `identifier^i);
};
</pre>

<p>
`引数~listを引数にとる$`拡張属性$（この仕様で定義される `Constructor$x と `NamedConstructor$x ）, および
`呼戻~関数$についても、その引数~listに `...^c ~tokが利用されているならば，`可変個の引数$をとるものと見なされる。
【以下の記述における “演算†” には，これらの（構築子を与える）拡張属性や呼戻も含まれていると思われる。】
◎
Extended attributes that take an argument list ([Constructor] and [NamedConstructor], of those defined in this specification) and callback functions are also considered to be variadic when the ... token is used in their argument lists.
</p>


<div class="example">
<p>
次の`~IDL片$は，可変個の引数をとる演算を 2 つ持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two variadic operations:
</p>

<pre class="webidl">
interface IntegerSet {
  readonly attribute unsigned long cardinality;

  void union(long... %ints);
  void intersection(long... %ints);
};
</pre>

<p>
~ES言語束縛においては、可変個の引数をとる演算は，後続の引数を受容できる関数により実装される：
◎
In the ECMAScript binding, variadic operations are implemented by functions that can accept the subsequent arguments:
</p>

<pre class="es-code">
var %s = getIntegerSet();  /* <span class="comment">
`IntegerSet^T の~instanceを得る。
◎
Obtain an instance of IntegerSet.
</span> */

%s.union();                /* <span class="comment">
`ints^l に対応する引数を~~省略。
◎
Passing no arguments corresponding to 'ints'.
</span> */
%s.union(1, 4, 7);         /* <span class="comment">
`ints^l に対応する 3 個の引数を渡す。
◎
Passing three arguments corresponding to 'ints'.
</span> */
</pre>

<p>
可変個の引数をとる関数を~supportしない言語~用の言語束縛においては、その種の演算には，整数の 配列または~list を明示的に渡すように指定することになるであろう。
◎
A binding for a language that does not support variadic functions might specify that an explicit array or list of integers be passed to such an operation.
</p>
</div>


<p>
`optional^c ~keywordを伴って宣言された引数は
`随意~引数@
であるものと見なされる。
`可変個の引数$をとる演算†の`末尾~引数$も随意~引数と見なされる。
随意として宣言された引数は，演算†を呼出す時にその値を省略できることを指示する。
`末尾~引数$が，明示的に随意として宣言されては~MUST_NOT。
◎
An argument is considered to be an optional argument if it is declared with the optional keyword. The final argument of a variadic operation is also considered to be an optional argument. Declaring an argument to be optional indicates that the argument value can be omitted when the operation is invoked. The final argument in an operation must not explicitly be declared to be optional if the operation is variadic.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i);
};
</pre>


<p>
随意~引数には
`既定~値@
を指定できる。
引数の識別子に
`U+003D EQUALS SIGN ("=")^char
と
値（ `DefaultValue$g に合致）が後続している場合、その値がその随意~引数の
`既定~値$
を与える。
ただし、`可変個の引数$をとる演算†の`末尾~引数$には、既定~値が指定されては~MUST_NOT。
既定~値は、対応する引数が省略されて演算†が~callされたときに，その引数がとる値と見做される。
◎
Optional arguments can also have a default value specified. If the argument’s identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the optional argument its default value. The implicitly optional final argument of a variadic operation must not have a default value specified. The default value is the value to be assumed when the operation is called with the corresponding argument omitted.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  `return_type^i `identifier^i(`type^i `identifier^i, optional `type^i `identifier^i = `value^i);
};
</pre>

<p class="advisement">
`boolean$T 型の引数には、`既定~値$として `true^V を利用しないことを強く勧める。
さもなければ、 `undefined^jv に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
It is strongly suggested not to use a default value of true for boolean-typed arguments, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>

<p>
次をすべて満たす引数は、随意として指定され~MUST。
◎
If＼
</p>

<ul>
	<li>
引数の型は、［
`辞書~型$である
］~OR［
`共用体~型$であって，その`平坦化~mb型$に ある`辞書~型$を含んでいる
］
◎
the type of an argument is a dictionary type or a union type that has a dictionary as one of its flattened member types, and＼
</li>
	<li>
その辞書~型と その先祖には，必須の~mbはない
◎
that dictionary type and its ancestors have no required members, and
</li>
	<li>
［
引数は最後の引数である
］~OR［
引数に後続するどの引数も`随意~引数$である
］
◎
the argument is either the final argument or is followed only by optional arguments,＼
</li>
</ul>

<p>
そのような引数は、他が指定されない限り，常に［
各~mbが既定~値にされた，空の辞書
］を値にとるものと見なされる。
◎
then the argument must be specified as optional. Such arguments are always considered to have a default value of an empty dictionary, unless otherwise specified.
</p>


<div class="note">
<p>
これは、作者が辞書の既定~値のみの利用を望むときでも，空の辞書~値を渡さずに済むような~APIの設計を促すためである。
◎
This is to encourage API designs that do not require authors to pass an empty dictionary value when they wish only to use the dictionary’s default values.
</p>

<p>
辞書~型は明示的な既定~値を指定し得ないので、上の “他が指定されない限り” の条件は，`平坦化~mb型$に辞書~型が含まれているような`共用体~型$に対してのみ可能になる。<!--  -->
◎
Dictionary types cannot have a default value specified explicitly, so the “unless otherwise specified” clause above can only be invoked for a union type that has a dictionary type as one of its flattened member types.
</p>
</div>

<p>
`既定~値$に`定数~tok$が利用された場合、`定数$に対するときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a float token or one of the three special floating point literal values (Infinity, -Infinity or NaN) is used as the default value, it is interpreted in the same way as for a constant.
</p>

<p id="string-literal">
随意~引数の既定~値には、 `string$g ~tokも指定できる。
それは、次に従って決定される`文字列~型$の値をとる：
◎
Optional argument default values can also be specified using a string token, whose value is a string type determined as follows:
</p>

<ol class="algorithm">
	<li>
%S ~LET `string$g ~tokに合致する［
`~Unicode~scalar値$の並び
］から，先頭と末尾の
`U+0022 QUOTATION MARK^char ( `"^c )
文字を除去したもの
◎
Let S be the sequence of Unicode scalar values matched by the string token with its leading and trailing U+0022 QUOTATION MARK ('"') characters removed.
</li>
	<li>
<p>
`string$g ~tokの値は、引数の型に応じて，次で与えられる：
◎
Depending on the type of the argument:
</p>

<dl class="switch">
	<dt>`DOMString$T</dt>
	<dt>`列挙$ 型</dt>
	<dd>
%S を~UTF-16符号化したものに対応する， 16 ~bit無符号~整数~符号単位（以下、単に
`符号単位@
と記される）の並び。
◎
The value of the string token is the sequence of 16 bit unsigned integer code units (hereafter referred to just as code units) corresponding to the UTF-16 encoding of S.
</dd>
	<dt>`ByteString$T</dt>
	<dd>
%S を~UTF-8符号化したものに対応する， 8 ~bit無符号~整数~符号単位の並び。
◎
The value of the string token is the sequence of 8 bit unsigned integer code units corresponding to the UTF-8 encoding of S.
</dd>
	<dt>`USVString$T</dt>
	<dd>
%S 。
◎
The value of the string token is S.
</dd>
</dl>
	</li>
</ol>

<p>
`随意~引数$の型が`列挙$である場合、その`既定~値$に指定される値は，その列挙のいずれかの`列挙~値$で~MUST。
◎
If the type of the optional argument is an enumeration, then its default value if specified must be one of the enumeration’s values.
</p>

<p>
`連列~型$（`~nullable$も含む）の随意~引数の既定~値には、
2 個の~tokによる `[]^c を利用して，その型と同じ型の空~連列~値を表現する値も指定できる。
この既定~値の型は［
`連列~型$ ／
`~nullable$であって その`内縁~型$は`連列~型$であるもの ／
`共用体~型$または`~nullable$なそれであって その`平坦化~mb型$は`連列~型$を含むもの
］で~MUST。
◎
Optional argument default values can also be specified using the two token value [], which represents an empty sequence value. The type of this value is the same as the type of the optional argument it is being used as the default value of. That type must be a sequence type, a nullable type whose inner type is a sequence type or a union type or nullable union type that has a sequence type in its flattened member types.
</p>

<div class="example">
<p>
次の`~IDL片$は、［
2 通りの長さによる引数~listで呼出せる，単独の`演算$
］を伴う`~ifc$を定義する：
◎
The following IDL fragment defines an interface with a single operation that can be invoked with two different argument list lengths:
</p>

<pre class="webidl">
interface ColorCreator {
  object createColor(double %v1, double %v2, double %v3, optional double %alpha);
};
</pre>

<p>
それは、次の，`多重定義$された 2 つの`演算$を持つ`~ifc$と等価になる：
◎
It is equivalent to an interface that has two overloaded operations:
</p>

<pre class="webidl">
interface ColorCreator {
  object createColor(double %v1, double %v2, double %v3);
  object createColor(double %v1, double %v2, double %v3, double %alpha);
};
</pre>
</div>

<p id="callback-operation-exceptions">
実装が`利用者~obj$上の`演算$の呼出しを試みた結果
（例えば，呼戻~objが実装に供されていて），例外が投出される場合、他が指定されない限り，その例外は［
実装からその演算の呼出しを生じさせた，利用者~code
］まで伝播することになる。
同様に，演算の呼出しにより返される値を~IDL型に変換できない場合、それにより生じた例外も［
実装からその演算の呼出しを試みさせた，利用者~code
］まで伝播することになる。
◎
If an implementation attempts to invoke an operation on a user object (for example, when a callback object has been supplied to the implementation), and that attempt results in an exception being thrown, then, unless otherwise specified, that exception will be propagated to the user code that caused the implementation to invoke the operation. Similarly, if a value returned from invoking the operation cannot be converted to an IDL type, then any exception resulting from this will also be propagated to the user code that resulted in the implementation attempting to invoke the operation.
</p>


<p>
演算には、次の拡張属性を適用できる
⇒
`Default$x,
`Exposed$x,
`NewObject$x,
`SecureContext$x,
`Unforgeable$x
◎
The following extended attributes are applicable to operations: [Default], [Exposed], [NewObject], [SecureContext], [Unforgeable].
</p>

<div class="grammar">
DefaultValue
Operation
RegularOperation
SpecialOperation
Specials
Special
OperationRest
OptionalIdentifier
ArgumentList
Arguments
Argument
ArgumentRest
ArgumentName
Ellipsis
ArgumentNameKeyword
ReturnType
</div>

				<section id="idl-tojson-operation">
<h5 title="toJSON">2.4.3.1. ~toJSON</h5>

<p>
`~ifc$は、それを実装する~objを`~JSON型$に変換する方法を，~toJSON`正則~演算$を宣言することにより指定する。
◎
By declaring a toJSON regular operation, an interface specifies how to convert the objects that implement it to JSON types.
</p>

<p>
~toJSON`正則~演算$は、この用法のために予約される。
それは、
0 個の引数をとり，`~JSON型$を返さ~MUST。
◎
The toJSON regular operation is reserved for this usage. It must take zero arguments and return a JSON type.
</p>

<p>
次に挙げる型が
`~JSON型@
とされる：
◎
The JSON types are:
</p>

<ul>
	<li>
`実数~型$
◎
numeric types,
</li>
	<li>
`boolean$T 型
◎
boolean,
</li>
	<li>
`文字列~型$
◎
string types,
</li>
	<li>
`~nullable型$のうち，その`内縁~型$は`~JSON型$であるもの
◎
nullable types whose inner type is a JSON type,
</li>
	<li>
`注釈付きの型$のうち，その`内縁~型$anOは`~JSON型$であるもの
◎
annotated types whose inner type is a JSON type,
</li>
	<li>
`共用体~型$のうち，その`~mb型$は`~JSON型$であるもの
◎
union types whose member types are JSON types,
</li>
	<li>
`連列~型$のうち，その~parameter化された型は`~JSON型$であるもの
◎
sequence types whose parameterized type is a JSON type,
</li>
	<li>
`凍結~配列~型$のうち，その~parameter化された型は`~JSON型$であるもの
◎
frozen array types whose parameterized type is a JSON type,
</li>
	<li>
`辞書$のうち，そのすべての`辞書~mb$は`~JSON型$であるもの
◎
dictionaries where all of their members are JSON types,
</li>
	<li>
`~record型$のうち，そのすべての`値$は`~JSON型$であるもの
◎
records where all of their values are JSON types,
</li>
	<li>
`object$T 型
◎
object,
</li>
	<li>
`~ifc型$のうち，［
自身または`被継承~ifc$
］上に~toJSON演算が宣言されているもの
◎
interface types that have a toJSON operation declared on themselves or one of their inherited interfaces.
</li>
</ul>

<p>
言語束縛において~toJSON`正則~演算$を~obj上でどう可用にするか, および
`~JSON型$を~JSON文字列に正確にどう変換するかは、言語束縛に特有になる。
◎
How the toJSON regular operation is made available on an object in a language binding, and how exactly the JSON types are converted into a JSON string, is language binding specific.
</p>


<p class="note">注記：
~ES言語束縛においては、これは，~toJSON~methを公開することにより行われる
— この~methは、`~JSON型$を［
`JSON.stringify()$c 関数により~JSON文字列に転換できるような，~ES値
］に変換して返す。
加えて，~ES言語束縛においては、~toJSON演算は `Default$x `拡張属性$をとれる
— その事例では、代わりに `既定の~toJSON演算$が公開される。
◎
Note: In the ECMAScript language binding, this is done by exposing a toJSON method which returns the JSON type converted into an ECMAScript value that can be turned into a JSON string by the JSON.stringify() function. Additionaly, in the ECMAScript language binding, the toJSON operation can take a [Default] extended attribute, in which case the default toJSON operation is exposed instead.
</p>

<div class="example" id="tojson-example">

<p>
次の`~IDL片$は、~toJSON~methを持つような `Transaction^T ~ifcを定義する
— ~methは注釈文にて定義されることになる：
◎
The following IDL fragment defines an interface Transaction that has a toJSON method defined in prose:
</p>


<pre class="webidl">
interface Transaction {
  readonly attribute DOMString from;
  readonly attribute DOMString to;
  readonly attribute double amount;
  readonly attribute DOMString description;
  readonly attribute unsigned long number;
  TransactionJSON toJSON();
};

dictionary TransactionJSON {
  Account from;
  Account to;
  double amount;
  DOMString description;
};</pre>


<p>
`Transaction^T `~ifc$の~toJSON`正則~演算$は、［
被呼出時には次の手続きを走らす
］ように定義することもできる：
◎
The toJSON regular operation of Transaction interface could be defined as follows:
◎
To invoke the toJSON() operation of the Transaction interface, run the following steps:
</p>

<ol>
	<li>
%O ~LET 当の `Transaction^T ~obj
◎
↓</li>
	<li>
%json ~LET 新たな `TransactionJSON^T 辞書
◎
Let json be a new TransactionJSON dictionary.
</li>
	<li>
<p>
属性`識別子$の`~list$ « `from^l, `to^l, `amount^l, `description^l » 内の~EACH( %識別子 ) に対し：
◎
For each attribute identifier attr in « "from", "to", "amount", "description" »:
</p>

		<ol>
			<li>
%json [ %識別子 ] ~SET %O 上で［
%識別子 で識別される`属性$
］の`下層の値を取得-$した結果
◎
Let value be result of getting the underlying value of the attribute identified by attr, given this Transaction object.
◎
Set json[attr] to value.
</li>
		</ol>
	</li>
	<li>
~RET %json
◎
Return json.
</li>
</ol>

<p>
~ES言語束縛においては、
`Transaction^T ~obj上に `toJSON()^c ~methが存在することになる：
◎
In the ECMAScript language binding, there would exist a toJSON() method on Transaction objects:
</p>


<pre class="es-code">
/* <span class="comment">
`Transaction^T の~instanceを取得する
◎
Get an instance of Transaction.
</span> */
var %txn = getTransaction();

/* <span class="comment">
次の様な~objに評価される：
◎
Evaluates to an object like this:
</span> */
   {
     from: "Bob",
     to: "Alice",
     amount: 50,
     description: "books"
   }
*/
%txn.toJSON();

/* <span class="comment">
次の様な文字列に評価される：
◎
Evaluates to a string like this:
</span> */
   '{"from":"Bob","to":"Alice","amount":50,"description":"books"}'
*/
JSON.stringify(%txn);
</pre>
</div>
				</section>
			</section>
			<section id="idl-special-operations">
<h4 title="Special operations">2.4.4. 特殊~演算</h4>


<p>
`特殊~演算@
は、［
その特殊~演算~宣言が現れる~ifc
］を実装する~obj上における［
一定の種類の特殊な挙動
］の宣言である。
`特殊~演算$は，演算~宣言において 1 個~以上の
`特殊~keyword@
を利用して宣言される。
◎
A special operation is a declaration of a certain kind of special behavior on objects implementing the interface on which the special operation declarations appear. Special operations are declared by using one or more special keywords in an operation declaration.
</p>

<p>
`特殊~演算$には、次の一覧に示す 5 種類がある。
一覧には、それぞれの種類の特殊~演算に対し，その宣言-時に利用される特殊~keyword, およびその特殊~演算の目的も示す：
◎
There are five kinds of special operations. The table below indicates for a given kind of special operation what special keyword is used to declare it and what the purpose of the special operation is:
</p>

<table>

<thead><tr><th>`特殊~演算$◎ Special operation
<th>~keyword◎ Keyword
<th>目的◎ Purpose
</thead>

<tbody><tr><td>`取得子@
<td>`getter^c
<td>
~prop取得1
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property retrieval.

<tr><td>`設定子@
<td>`setter^c
<td>
~prop代入／作成
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property assignment or creation.

<tr><td>`削除子@
<td>`deleter^c
<td>
~prop削除
のために~objが~indexingされる際の挙動を定義する。
◎
Defines behavior for when an object is indexed for property deletion.

<tr><td>`文字列化子@
<td>`stringifier^c
<td>
~objを `DOMString$T に変換する方法を定義する。
◎
Defines how an object is converted into a DOMString.

</tbody></table>

<p>
すべての言語束縛が、［
これら 5 種類の，~objの特殊な挙動
］すべてを~supportするわけではない。
`特殊~演算$が，識別子を伴わない演算を利用して宣言された場合、その特定0の種類の特殊~演算を~supportしない言語束縛においては，単にその機能性が存在しないことになる。
◎
Not all language bindings support all of the five kinds of special object behavior. When special operations are declared using operations with no identifier, then in language bindings that do not support the particular kind of special operations there simply will not be such functionality.
</p>

<div class="example">
<p>
次の~IDL片は、取得子と設定子を伴う~ifcを定義する：
◎
The following IDL fragment defines an interface with a getter and a setter:
</p>

<pre class="webidl">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double (DOMString %propertyName);
  setter void (DOMString %propertyName, double %propertyValue);
};
</pre>

<p>
~propの取得子や設定子を~supportしない言語束縛では、
`Dictionary^T を実装している~objはこの特殊な挙動を持たないことになる。
◎
In language bindings that do not support property getters and setters, objects implementing Dictionary will not have that special behavior.
</p>

</div>

<p>
`特殊~演算$を`識別子$を伴わせて定義することは、その宣言から識別子のない特殊~演算を分離することと，等価である。
この書き方は、~ifcの演算についての注釈文の記述を単純化するために許容されている。
◎
Defining a special operation with an identifier is equivalent to separating the special operation out into its own declaration without an identifier. This approach is allowed to simplify prose descriptions of an interface’s operations.
</p>

<div class="example">
<p>
次の 2 つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="webidl">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  getter double getProperty(DOMString %propertyName);
  setter void setProperty(DOMString %propertyName, double %propertyValue);
};
</pre>

<pre class="webidl">
interface Dictionary {
  readonly attribute unsigned long propertyCount;

  double getProperty(DOMString %propertyName);
  void setProperty(DOMString %propertyName, double %propertyValue);

  getter double (DOMString %propertyName);
  setter void (DOMString %propertyName, double %propertyValue);
};
</pre>
</div>

<p>
1 つの演算に同じ`特殊~keyword$が複数~回 現れては~MUST_NOT。
◎
A given special keyword must not appear twice on an operation.
</p>

<!-- 
有index~prop~accessor:indexed-property-accessor
有名~prop~accessor:named-property-accessor
-->
<p>
取得子, 設定子, 削除子は 2 種の系列に分類される：
◎
Getters and setters come in two varieties:＼
</p>

<ul id="_property-accessors">
	<li>
`有名~prop取得子@,
`有名~prop設定子@,
`有名~prop削除子@
と呼ばれる，~prop名として `DOMString$T をとるもの。
◎
ones that take a DOMString as a property name, known as named property getters and named property setters, and＼
</li>
	<li>
`有index~prop取得子@,
`有index~prop設定子@
と呼ばれる，~prop~indexとして `unsigned long$T をとるもの
— 有index~propには，<em>削除子は無い</em>。
◎
ones that take an unsigned long as a property index, known as indexed property getters and indexed property setters. There is only one variety of deleter: named property deleters.＼
</li>
</ul>

<p>
詳細は、
`idl-indexed-properties$sec,
`idl-named-properties$sec
を見よ。
◎
See §2.4.4.2 Indexed properties and §2.4.4.3 Named properties for details.
</p>

<p>
所与の`~ifc$上に存在する，［
`文字列化子$, `削除子$ および, 各~系列の［
`取得子$, `設定子$
］］は、それぞれ，高々 1 個までで~MUST。
◎
On a given interface, there must exist at most one stringifier, at most one named property deleter, and at most one of each variety of getter and setter.
</p>

<p>
~ifcが［
いずれかの系列の`設定子$,
あるいは`有名~prop削除子$
］を持つ場合、同じ系列の`取得子$も持た~MUST。
◎
If an interface has a setter of a given variety, then it must also have a getter of that variety. If it has a named property deleter, then it must also have a named property getter.
</p>


<p>
演算を利用して宣言される`特殊~演算$は，［
`可変個の引数$ ／
`随意~引数$
］をとるようにされては~MUST_NOT。
◎
Special operations declared using operations must not be variadic nor have any optional arguments.
</p>

<p>
`特殊~演算$は，`呼戻~ifc$上で宣言されては~MUST_NOT。
◎
Special operations must not be declared on callback interfaces.
</p>

<p>
~objが，所与の`特殊~演算$を定義する複数の`~ifc$を実装する場合、その演算に対し，どの特殊~演算が呼出されるかは 未定義である。
◎
If an object implements more than one interface that defines a given special operation, then it is undefined which (if any) special operation is invoked for that operation.
</p>

				<section id="idl-stringifiers">
<h5 title="Stringifiers">2.4.4.1. 文字列化子</h5>


<p>
`~ifc$が`文字列化子$を持つとき、
<!--  -->
その~ifcを実装する~objは，文字列への既定でない変換を持つことになる。
上で言及したように、文字列化子は
`stringifier^c ~keywordを伴って宣言される`演算$を利用して，指定できる。
◎
When an interface has a stringifier, it indicates that objects that implement the interface have a non-default conversion to a string. As mentioned above, stringifiers can be specified using an operation declared with the stringifier keyword.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier DOMString `identifier^i();
  stringifier DOMString ();
};
</pre>

<p>
`文字列化子$の宣言-時に利用された演算が`識別子$を持たない場合、~ifcに付随する注釈文において，~ifcの
`文字列化の挙動@
が定義され~MUST。
演算が識別子を持つ場合、その演算の呼出しにより，~objは文字列に変換される。
◎
If an operation used to declare a stringifier does not have an identifier, then prose accompanying the interface must define the stringification behavior of the interface. If the operation does have an identifier, then the object is converted to a string by invoking the operation to obtain the string.
</p>

<p>
演算により宣言される`文字列化子$は、
0 個の引数をとり `DOMString$T を返すように，宣言され~MUST。
◎
Stringifiers declared with operations must be declared to take zero arguments and return a DOMString.
</p>

<p>
略記として、
`stringifier^c ~keywordが，識別子を伴わない演算により宣言される場合、その演算の`返値型$, および引数~listを省略できる。
◎
As a shorthand, if the stringifier keyword is declared using an operation with no identifier, then the operation’s return type and argument list can be omitted.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier;
};
</pre>

<div class="example">
<p>
次の 2 つの~ifcは等価である：
◎
The following two interfaces are equivalent:
</p>

<pre class="webidl">
interface A {
  stringifier DOMString ();
};
</pre>

<pre class="webidl">
interface A {
  stringifier;
};
</pre>
</div>

<p>
`stringifier^c ~keywordは
`属性$上に置くこともできる。
この場合、その属性の値が，~objから文字列への変換-を与える。
`stringifier^c ~keywordが［［
`DOMString$T／`USVString$T
として宣言されていない属性
］や
`静的~属性$
］上に置かれては~MUST_NOT。
◎
The stringifier keyword can also be placed on an attribute. In this case, the string to convert the object to is the value of the attribute. The stringifier keyword must not be placed on an attribute unless it is declared to be of type DOMString or USVString. It also must not be placed on a static attribute.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  stringifier attribute DOMString `identifier^i;
};
</pre>

<div class="grammar">
Stringifier
StringifierRest
</div>

<div class="example">
<p>
次の`~IDL片$は、
`name^M
属性の値に文字列化する~ifcを定義する：
◎
The following IDL fragment defines an interface that will stringify to the value of its name attribute:
</p>

<pre class="webidl">
[Constructor]
interface Student {
  attribute unsigned long id;
  stringifier attribute DOMString name;
};
</pre>

<p>
~ES言語束縛においては、文字列が期待されている文脈において
`Student^T
~objが利用されたときの結果は、その~objの `name^l ~propの値になる：
◎
In the ECMAScript binding, using a Student object in a context where a string is expected will result in the value of the object’s “name” property being used:
</p>

<pre class="es-code">
var %s = new Student();
%s.id = 12345678;
%s.name = '周杰倫';

var greeting = 'こんにちは、 ' + s + ' さん。';
    /* <span class="comment">
%greeting は `こんにちは、 周杰倫 さん。^l になる。
◎
Now greeting == 'Hello, 周杰倫!'.
</span> */
</pre>

<p>
次の`~IDL片$は、~IDL自身には指定されない~customな文字列化の挙動を備える~ifcを定義する。
◎
The following IDL fragment defines an interface that has custom stringification behavior that is not specified in the IDL itself.
</p>

<pre class="webidl">
[Constructor]
interface Student {
  attribute unsigned long id;
  attribute DOMString? familyName;
  attribute DOMString givenName;

  stringifier DOMString ();
};
</pre>

<p>
したがって、例えば次の段落の様な，文字列化の挙動を説明する注釈文が要求される：
◎
Thus, prose is required to explain the stringification behavior, such as the following paragraph:
</p>

<blockquote>
`Student^T ~ifc を実装する~objを文字列化した結果は、
`familyName^M 属性の値が `null^V の場合は
`givenName^M 属性の値，他の場合は［
`givenName^M 属性の値,
1 個の space 文字,
`familyName^M 属性の値
］の連結にならなければ~MUST_NOT。
◎
Objects that implement the Student interface must stringify as follows. If the value of the familyName attribute is null, the stringification of the object is the value of the givenName attribute. Otherwise, if the value of the familyName attribute is not null, the stringification of the object is the concatenation of the value of the givenName attribute, a single space character, and the value of the familyName attribute.
</blockquote>

<p>
この~IDLの~ES実装は、次に従って挙動することになる：
◎
An ECMAScript implementation of the IDL would behave as follows:
</p>

<pre class="es-code">
var %s = new Student();
%s.id = 12345679;
%s.familyName = 'Smithee';
%s.givenName = 'Alan';

var %greeting = 'こんにちは、 ' + s + ' さん。';
    /* <span class="comment">
%greeting は `こんにちは、 Alan Smithee さん^l になる。
◎
Now greeting == 'Hi Alan Smithee'.
</span> */
</pre>
</div>
				</section>
				<section id="idl-indexed-properties">
<h5 title="Indexed properties">2.4.4.2. 有index~prop</h5>

<p>
`有index~prop取得子$を定義する`~ifc$は、
`有index~propを~support@
するという。
そのような~ifcを実装する`~platform~obj$もまた，`有index~propを~support$するという。
◎
An interface that defines an indexed property getter is said to support indexed properties. By extension, a platform object is said to support indexed properties if it implements an interface that itself does.
</p>

<p>
~ifcが`有index~propを~support$する場合、その~ifc定義には，所与の任意の時点で~objに~indexingできる~indexについての記述も付随してい~MUST。
これらの~indexは
`被support~prop~index@
と呼ばれる。
◎
If an interface supports indexed properties, then the interface definition must be accompanied by a description of what indices the object can be indexed with at any given time. These indices are called the supported property indices.
</p>

<p>
`有index~propを~support$する~ifcは、`整数~型$である名前 `length^l の属性を定義し~MUST。
◎
Interfaces that support indexed properties must define an integer-typed attribute named “length”.
</p>

<p>
`有index~prop取得子$は、 1 個の `unsigned long$T 引数をとるように宣言され~MUST。
有index~propの設定子は、 2 個の引数をとり,
1 個目の引数が `unsigned long$T をとるように宣言され~MUST。
◎
Indexed property getters must be declared to take a single unsigned long argument. Indexed property setters must be declared to take two arguments, where the first is an unsigned long.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  getter `type^i `identifier^i(unsigned long `identifier^i);
  setter `type^i `identifier^i(unsigned long `identifier^i, `type^i `identifier^i);

  getter `type^i (unsigned long `identifier^i);
  setter `type^i (unsigned long `identifier^i, `type^i `identifier^i);
};
</pre>

<p>
次の要件が，有index~propの［
取得子, 設定子
］の定義に適用される：
◎
The following requirements apply to the definitions of indexed property getters and setters:
</p>
<ul>
	<li>
<p>
`有index~prop取得子$の宣言に利用された`演算$が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop~index$による~indexingの際に返される値は、その演算を，その~indexを唯一の引数に渡して呼出したときと同じになる。
◎
If an indexed property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property index is the value that would be returned by invoking the operation, passing the index as its only argument.＼
</li>
			<li>
持たない場合、その~ifc定義には，所与の~indexに対し
`有index~propの値を決定する@
方法についての記述も付随してい~MUST。
◎
If the operation used to declare the indexed property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of an indexed property for a given index.
</li>
		</ul>
	</li>
	<li>
<p>
`有index~prop設定子$の宣言に利用された`演算$が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の
( `被support~prop~index$, 値 )
による，~prop代入のための~indexingの際に生じる挙動は、その演算の 1 個目の引数に~indexを， 2 個目の引数に値を渡して呼出したときと同じになる。
◎
If an indexed property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property index and value is the same as if the operation is invoked, passing the index as the first argument and the value as the second argument.＼
</li>
			<li>
持たない場合、その~ifc定義には，所与の
( ~prop~index, 値 )
に対し［
`既存の有index~propを設定する@
方法, および
`新たな有index~propを設定する@
方法
］についての記述も付随してい~MUST。
◎
If the operation used to declare the indexed property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing indexed property and how to set the value of a new indexed property for a given property index and value.
</li>
		</ul>
	</li>
</ul>


<div class="note">
<p>
`有index~prop$の［
取得子／設定子
］が`識別子$を伴う`演算$を利用して指定されている場合、~objに対する［
`被support~prop~index$でない整数
］による~indexingは，その~indexによる演算の呼出しと同じ挙動をなぞるとは限らないことに注意。
この場合における実際の挙動は、言語束縛に特有になる。
◎
Note that if an indexed property getter or setter is specified using an operation with an identifier, then indexing an object with an integer that is not a supported property index does not necessarily elicit the same behavior as invoking the operation with that index. The actual behavior in this case is language binding specific.
</p>

<p>
~ES言語束縛においては，定例の~prop検索が行われる。
例えば次の~IDLでは：
◎
In the ECMAScript language binding, a regular property lookup is done. For example, take the following IDL:
</p>
<!-- language -->

<pre class="webidl">
interface A {
  getter DOMString toWord(unsigned long %index);
};
</pre>

<p>
`A^T を実装している~objの`被support~prop~index$は、
0 以上 2 未満とする。
また、 `toWord^M は，引数の数字を英単語に変換した文字列を返すように定義されているとする。
範囲~外の~indexにより`演算$を呼出したときの挙動は，~objの直接的な~indexingとは異なる：
◎
Assume that an object implementing A has supported property indices in the range 0 ≤ index &lt; 2. Also assume that toWord is defined to return its argument converted into an English word. The behavior when invoking the operation with an out of range index is different from indexing the object directly:
</p>

<pre class="es-code">
var %a = getA();

%a.toWord(0);  /* <span class="comment">
`zero^l  に評価される。
◎
Evaluates to &quot;zero&quot;.
</span> */
%a[0];         /* <span class="comment">
これも `zero^l に評価される。
◎
Also evaluates to &quot;zero&quot;.
</span> */

%a.toWord(5);  /* <span class="comment">
`five^l に評価される。
◎
Evaluates to &quot;five&quot;.
</span> */
%a[5];         /* <span class="comment">
~prop `5^l は存在しないので `undefined^jv に評価される。
◎
Evaluates to undefined, since there is no property &quot;5&quot;.
</span> */
</pre>
</div>

<div class="example">
<p>
次の`~IDL片$は
名前または~indexによる値の取得0と設定を許容する
`OrderedMap^T
~ifcを定義する：
◎
The following IDL fragment defines an interface OrderedMap which allows retrieving and setting values by name or by index number:
</p>

<pre class="webidl">
interface OrderedMap {
  readonly attribute unsigned long size;

  getter any getByIndex(unsigned long %index);
  setter void setByIndex(unsigned long %index, any %value);

  getter any get(DOMString %name);
  setter void set(DOMString %name, any %value);
};
</pre>

<p>
すべての特殊~演算が識別子を伴う演算を利用して宣言されているので、追加を要する唯一の注釈文は，これらの集合が持つ~keyを与える記述になる。
`OrderedMap^T 内に存在しない~itemに対する検索が試みられた場合に対し，
`get()^c 演算が `null^V を返すように定義されているとするとき、次の 2 つの~~文で足りるであろう：
◎
Since all of the special operations are declared using operations with identifiers, the only additional prose that is necessary is that which describes what keys those sets have. Assuming that the get() operation is defined to return null if an attempt is made to look up a non-existing entry in the OrderedMap, then the following two sentences would suffice:
</p>

	<blockquote>
<p>
`OrderedMap^T を実装する~obj %map は、範囲［
0 ~LTE %index ~LT `map.size^c
］の`有index~propを~support$する。
◎
An object map implementing OrderedMap supports indexed properties with indices in the range 0 ≤ index &lt; map.size.
</p>

<p>
そのような~objは、
`get()^c に渡されたときに非 `null^V 値が返されるような，どの名前に対しても、有名~propを~supportする。
◎
Such objects also support a named property for every name that, if passed to get(), would return a non-null value.
</p>
	</blockquote>

<p>
`es-legacy-platform-objects$sec
に述べられるように、~ES実装は［
有名, 有index
］いずれの~propの集合に対しても、その集合に属する各項に対応する~propを［
`OrderedMap^T を実装している`旧来の~platform~obj$
］上に，作成することになるであろう。
下に示すように、これらの~propを，~objの~methの呼出しと同じ仕方で，~objとのやり取りに利用できる：
◎
As described in §3.8 Legacy platform objects, an ECMAScript implementation would create properties on a legacy platform object implementing OrderedMap that correspond to entries in both the named and indexed property sets. These properties can then be used to interact with the object in the same way as invoking the object’s methods, as demonstrated below:
</p>

<pre class="es-code">
/* <span class="comment">
%map は `OrderedMap^T ~ifcを実装する旧来の~platform~objであるとする。
◎
Assume map is a legacy platform object implementing the OrderedMap interface.
</span> */
var %map = getOrderedMap();
var %x, %y;

%x = %map[0];       /* <span class="comment">
`map.length^c ~GT 0 ならば、これは
`x = map.getByIndex(0)^c
と等価になる（名前 `0^l の~propが %map 上に置かれるので）。
他の場合、名前 `0^l の~propは %map 上にないので，
%x は `undefined^jv に設定されることになる。
◎
If map.length &gt; 0, then this is equivalent to:

  x = map.getByIndex(0)

since a property named &quot;0&quot; will have been placed on map.
Otherwise, x will be set to undefined, since there will be
no property named &quot;0&quot; on map.
</span> */

%map[1] = false;   /* <span class="comment">
これは、
`map.setByIndex(1, false)^c
と等価な動作になる。
◎
This will do the equivalent of:

  map.setByIndex(1, false)
</span> */

%y = %map.apple;    /* <span class="comment">
名前 `apple^l の有名~propが存在する場合、
%map 上には名前 `apple^l の~propがあり，
`y = map.get('apple')^c
と等価な動作になる。
他の場合、 %map 上に名前 `apple^l の~propはないので，
%y は `undefined^jv に設定されることになる。
◎
If there exists a named property named &quot;apple&quot;, then this
will be equivalent to:

  y = map.get('apple')

since a property named &quot;apple&quot; will have been placed on
map.  Otherwise, y will be set to undefined, since there
will be no property named &quot;apple&quot; on map.
</span> */

%map.berry = 123;  /* <span class="comment">
これは、
`map.set('berry', 123)^c
と等価な動作になる。
◎
This will do the equivalent of:

  map.set('berry', 123)
</span> */

delete %map.cake;  /* <span class="comment">
有名~prop `cake^l が存在するならば、 `cake^l ~propは削除され，
`map.remove("cake")^c
と等価な動作になる。
◎
If a named property named &quot;cake&quot; exists, then the &quot;cake&quot;
property will be deleted, and then the equivalent to the
following will be performed:

	  map.remove(&quot;cake&quot;)
</span> */

</pre></div>
				</section>
				<section id="idl-named-properties">
<h5 title="Named properties">2.4.4.3. 有名~prop</h5>


<p>
`有名~prop取得子$を定義する`~ifc$は、
`有名~propを~support@
するという。
そのような~ifcを実装する`~platform~obj$もまた，`有名~propを~support$するという。
◎
An interface that defines a named property getter is said to support named properties. By extension, a platform object is said to support named properties if it implements an interface that itself does.
</p>

<p>
`有名~propを~support$する~ifcの~ifc定義には、［
所与の任意の時点で~objに~indexingできるような名前からなる，有順序~集合
］についての記述も付随してい~MUST。
これらの名前は、
`被support~prop名@
と呼ばれる。
◎
If an interface supports named properties, then the interface definition must be accompanied by a description of the ordered set of names that can be used to index the object at any given time. These names are called the supported property names.
</p>

<p>
有名~propの取得子と削除子は、 1 個の `DOMString$T 引数をとるように宣言され~MUST。
有名~propの設定子は、 2 個の引数をとり， 1 個目の引数に `DOMString$T をとるように宣言され~MUST。
◎
Named property getters and deleters must be declared to take a single DOMString argument. Named property setters must be declared to take two arguments, where the first is a DOMString.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  getter `type^i `identifier^i(DOMString `identifier^i);
  setter `type^i `identifier^i(DOMString `identifier^i, `type^i `identifier^i);
  deleter `type^i `identifier^i(DOMString `identifier^i);

  getter `type^i (DOMString `identifier^i);
  setter `type^i (DOMString `identifier^i, `type^i `identifier^i);
  deleter `type^i (DOMString `identifier^i);
};
</pre>

<p>
次の要件が，有名~propの［
取得子, 設定子, 削除子
］の定義に適用される：
◎
The following requirements apply to the definitions of named property getters, setters and deleters:
</p>
<ul>
	<li>
<p>
`有名~prop取得子$の宣言に利用された`演算$が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop名$による~indexingの際に返される値は、その演算を，その~prop名を唯一の引数に渡して呼出したときと同じになる。
◎
If a named property getter was specified using an operation with an identifier, then the value returned when indexing the object with a given supported property name is the value that would be returned by invoking the operation, passing the name as its only argument.＼
</li>
			<li>
持たない場合、その~ifc定義には，所与の~prop名に対し
`有名~propの値を決定する@
方法についての記述も付随してい~MUST。
◎
If the operation used to declare the named property getter did not have an identifier, then the interface definition must be accompanied by a description of how to determine the value of a named property for a given property name.
</li>
		</ul>
	</li>
	<li>
<p>
`有名~prop設定子$の宣言に利用された`演算$が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の
( `被support~prop名$, 値 )
による，~prop代入のための~indexingの際に生じる挙動は、
その演算の 1 個目の引数に~prop名を， 2 個目の引数に値を渡して呼出したときと同じになる。
◎
If a named property setter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property assignment with a given supported property name and value is the same as if the operation is invoked, passing the name as the first argument and the value as the second argument.＼
</li>
			<li>
持たない場合、その~ifc定義には，所与の
( ~prop名, 値 )
に対し［
`既存の有名~propを設定する@
方法, および
`新たな有名~propを設定する@
方法
］についての記述も付随してい~MUST。
◎
If the operation used to declare the named property setter did not have an identifier, then the interface definition must be accompanied by a description of how to set the value of an existing named property and how to set the value of a new named property for a given property name and value.
</li>
		</ul>
	</li>
	<li>
<p>
`有名~prop削除子$の宣言に利用された`演算$が`識別子$を：
◎
↓</p>
		<ul>
			<li>
持つ場合、~objに対する，所与の`被support~prop名$による，~prop削除のための~indexingの際に生じる挙動は、その演算を，その~prop名を唯一の引数に渡して呼出したときと同じになる。
◎
If a named property deleter was specified using an operation with an identifier, then the behavior that occurs when indexing the object for property deletion with a given supported property name is the same as if the operation is invoked, passing the name as the only argument.＼
</li>
			<li>
持たない場合、その~ifc定義には，所与の~prop名に対し
`既存の有名~propを削除する@
方法についての記述も付随してい~MUST。
◎
If the operation used to declare the named property deleter did not have an identifier, then the interface definition must be accompanied by a description of how to delete an existing named property for a given property name.
</li>
		</ul>
	</li>
</ul>


<p class="note">注記：
`有index~prop$のときと同様に，`有名~prop$の［
取得子／設定子／削除子
］が`識別子$を伴う`演算$を利用して指定された場合、~objに対する［
`被support~prop名$でない名前
］による~indexingは，その名前による演算の呼出しと同じ挙動をなぞるとは限らないことに注意。
挙動は、言語束縛に特有になる。
◎
Note: As with indexed properties, if an named property getter, setter or deleter is specified using an operation with an identifier, then indexing an object with a name that is not a supported property name does not necessarily elicit the same behavior as invoking the operation with that name; the behavior is language binding specific.
</p>

				</section>
			</section>
			<section id="idl-static-attributes-and-operations">
<h4 title="Static attributes and operations">2.4.5. 静的~属性と静的~演算</h4>


<p>
<span>`静的~属性@</span>,
`静的~演算@
は、それが宣言される`~ifc$の特定0の~instance上には結付けられないものであり、代わりに，その ~ifc自身に結付けられる。
静的~属性と静的~演算は，それらの宣言の中で `static^c ~keywordを利用して宣言される。
◎
Static attributes and static operations are ones that are not associated with a particular instance of the interface on which it is declared, and is instead associated with the interface itself. Static attributes and operations are declared by using the static keyword in their declarations.
</p>

<p>
静的~演算の呼出しや静的~属性の取得-／設定-が，~ifcの~instanceへの参照を通して可能かどうかは、言語束縛に特有になる。
◎
It is language binding specific whether it is possible to invoke a static operation or get or set a static attribute through a reference to an instance of the interface.
</p>

<p>
静的~演算／静的~属性は，`呼戻~ifc$上で宣言されては~MUST_NOT。
◎
Static attributes and operations must not be declared on callback interfaces.
</p>

<div class="grammar">
StaticMember
StaticMemberRest
</div>

<div class="example">
<p>
次の`~IDL片$は、静的~演算が宣言されている
`Circle^T ~ifcを定義する：
◎
The following IDL fragment defines an interface Circle that has a static operation declared on it:
</p>

<pre class="webidl">
interface Point { /* ... */ };

interface Circle {
  attribute double cx;
  attribute double cy;
  attribute double radius;

  static readonly attribute long triangulationCount;
  static Point triangulate(Circle %c1, Circle %c2, Circle %c3);
};
</pre>

<p>
~ES言語束縛においては、
`Circle^T に対応する`~ifc~obj$上に，
`triangulate^M に対応する`関数~obj$, および
`triangulationCount^M に対応する~accessor~prop
が存在することになる：
◎
In the ECMAScript language binding, the function object for triangulate and the accessor property for triangulationCount will exist on the interface object for Circle:
</p>

<pre class="es-code">
var %circles = getCircles();        /* <span class="comment">
`Circle^T ~objの `Array^t
◎
an Array of Circle objects
</span> */

typeof Circle.triangulate;         /* <span class="comment" id="cp-eval-function">
`function^l に評価される。
◎
Evaluates to &quot;function&quot;
</span> */
typeof Circle.triangulationCount;  /* <span class="comment">
`number^l に評価される。
◎
Evaluates to &quot;number&quot;
</span> */
Circle.prototype.triangulate;      /* <span class="comment" id="cp-eval-undefined">
`undefined^jv に評価される。
◎
Evaluates to undefined
</span> */
Circle.prototype.triangulationCount;  /* <span class="comment">
これも `undefined^jv に評価される。
◎
Also evaluates to undefined
</span> */
%circles[0].triangulate;            /* <span class="comment">
これも。
◎
As does this
</span> */
%circles[0].triangulationCount;     /* <span class="comment">
これも。
◎
And this
</span> */

/* <span class="comment">
静的~演算の~call
◎
Call the static operation
</span> */
var %triangulationPoint = Circle.triangulate(%circles[0], %circles[1], %circles[2]);
/* <span class="comment">
`triangulate^M を呼んだ回数を調べる
◎
Find out how many triangulations we have done
</span> */
window.alert(Circle.triangulationCount);

</pre>

</div>
			</section>
			<section id="idl-overloading">
<h4 title="Overloading">2.4.6. 多重定義</h4>


<p>
`~ifc$上に定義される［
`正則~演算$／`静的~演算$
］が，その~ifc上の同じ種類の別の（正則／静的）演算と
同じ`識別子$を持つ場合、その演算は
`多重定義@
されているという。
その~ifcを実装する~obj上で，それらの演算のどれかを呼出すために多重定義された演算の識別子が利用された際に，どの演算が実際に呼出されるかは、演算に渡された引数の個数と型により決定される。
~ES言語束縛においては
`Constructor$x も多重定義され得る。
多重定義された［
演算／構築子
］がとり得る引数の指定には一定の制約があり、これらの制約を記述するため，`有効~多重定義~集合$の~~概念が利用される。
◎
If a regular operation or static operation defined on an interface has an identifier that is the same as the identifier of another operation on that interface of the same kind (regular or static), then the operation is said to be overloaded. When the identifier of an overloaded operation is used to invoke one of the operations on an object that implements the interface, the number and types of the arguments passed to the operation determine which of the overloaded operations is actually invoked. In the ECMAScript language binding, constructors can be overloaded too. There are some restrictions on the arguments that overloaded operations and constructors can be specified to take, and in order to describe these restrictions, the notion of an effective overload set is used.
</p>

<p>
`演算$は、複数の［
`~ifc$,
`部分的~ifc$,
`~ifc~mixin$,
`部分的~ifc~mixin$
］にまたがって多重定義されては~MUST_NOT。
◎
Operations must not be overloaded across interface, partial interface, interface mixin, and partial interface mixin definitions.
</p>

<div class="note">
<p>
例えば，次の様な `f^T, `g^T の多重定義は許容されない：
◎
For example, the overloads for both f and g are disallowed:
</p>

<pre class="webidl">
interface A {
  void f();
};

partial interface A {
  void f(double %x);
  void g();
};

partial interface A {
  void g(DOMString %x);
};
</pre>

<p>
構築子の多重定義については、元々`部分的~ifc定義$上には［
`Constructor$x, `NamedConstructor$x
］`拡張属性$の出現が許容されていないので，同様の制約は~~自動的に満たされることに注意。
◎
Note that the [Constructor] and [NamedConstructor] extended attributes are disallowed from appearing on partial interface definitions, so there is no need to also disallow overloading for constructors.
</p>
</div>


<div class="p">
<p>
`有効~多重定義~集合@
とは、特定0の
`関数類@
— ［
`演算$ ／
構築子（ `Constructor$x または `NamedConstructor$x により指定される） ／
`呼戻~関数$
］ —
に許容され得る呼出を表現するものである。
</p>

<p class="trans-note">【
“関数類（引数を伴って~callできる~IDL構成子）”
という語は、簡潔に総称するためにこの訳に導入した，非公式な用語である。
】</p>

<p>
`有効~多重定義~集合$を算出する~algoは、次に挙げる 6 種の~IDL構成子に対し演算する。
算出するために必要な入力は、渡される引数の個数, および
`関数類$の種別に応じて，以下に示されるものになる：
</p>
◎
An effective overload set represents the allowable invocations for a particular operation, constructor (specified with [Constructor] or [NamedConstructor]), or callback function. The algorithm to compute an effective overload set operates on one of the following six types of IDL constructs, and listed with them below are the inputs to the algorithm needed to compute the set.
</div>


<dl class="switch">
	<dt>
正則~演算
◎
For regular operations
</dt>
	<dt>
静的~演算
◎
For static operations
</dt>
	<dd>
`演算$が見出される`~ifc$, および
演算の`識別子$
◎
the interface on which the operations are to be found
◎
the identifier of the operations
◎
the number of arguments to be passed
</dd>

	<dt>
構築子
◎
For constructors
</dt>
	<dd>
`Constructor$x `拡張属性$が見出される`~ifc$
◎
the interface on which the [Constructor] extended attributes are to be found
◎
the number of arguments to be passed
</dd>

	<dt>
有名~構築子
◎
For named constructors
</dt>
	<dd>
`NamedConstructor$x `拡張属性$が見出される`~ifc$, および
有名~構築子の`識別子$
◎
the interface on which the [NamedConstructor] extended attributes are to be found
◎
the identifier of the named constructors
◎
the number of arguments to be passed
</dd>

	<dt>
呼戻~関数
◎
For callback functions
</dt>
	<dd>
`呼戻~関数$
◎
the callback function
◎
the number of arguments to be passed
</dd>

</dl>

<p>
有効~多重定義~集合は、他のものと伴に，~ifc上に多重定義された`関数類$が多義性を孕んでいるかどうか決定するために利用される。
◎
An effective overload set is used, among other things, to determine whether there are ambiguities in the overloaded operations and constructors specified on an interface.
</p>

<p>
`有効~多重定義~集合$を成す各`~item$は，`~tuple$
( `~callable$oL, `型~list$oL, `省略可否~list$oL )
であり、その各`~tuple$を成す各`~item$sctは：
◎
The items of an effective overload set are tuples of the form (callable, type list, optionality list) whose items are described below:
</p>

<dl class="def-list">
	<dt>`~callable@oL</dt>
	<dd>
<p>
`関数類$の種別に応じて，次で与えられる：
</p>
		<dl class="switch">
			<dt>`正則~演算$</dt>
			<dt>`静的~演算$</dt>
			<dd>
その いずれかの`演算$
</dd>

			<dt>構築子</dt>
			<dt>`有名~構築子$</dt>
			<dd>
その いずれかの`拡張属性$
</dd>

			<dt>`呼戻~関数$</dt>
			<dd>
呼戻~関数~自身
</dd>
		</dl>
◎
A callable is an operation if the effective overload set is for regular operations or static operations; it is an extended attribute if the effective overload set is for constructors or named constructors; and it is the callback function itself if the effective overload set is for callback functions.
</dd>

	<dt>`型~list@oL</dt>
	<dd>
0 個~以上の~IDL型からなる`~list$。
— `~callable$oL の引数たちにあてがわれているそれらになる。
◎
A type list is a list of IDL types.
</dd>

	<dt>`省略可否~list@oL</dt>
	<dd>
<p>
0 個~以上の
`省略可否 値@
からなる`~list$。
各 `省略可否 値$は、次のいずれかの値をとり，所与の~indexに位置する引数について指示する：
</p>

<ul><li>`必須^C
— 引数は省略できない
</li><li>`省略可^C
— `随意~引数$である
</li><li>`可変個^C
— `可変個~引数$である
</li></ul>

◎
An optionality list is a list of three possible optionality values – "required", "optional" or "variadic" – indicating whether the argument at a given index was declared as being optional or corresponds to a variadic argument.
</dd>
</dl>

<p>
各`~tuple$は、［
引数~値~listに伴われる一連の型であって，当の`関数類$の呼出に許容され得るもの
］を表現する。
［
`随意~引数$／［
`可変個の引数$をとる`関数類$ （すなわち，演算または構築子）
］］の利用に因り、有効~多重定義~集合~内には，同じ種類の`関数類$を識別する複数の~itemが存在し得る。
◎
Each tuple represents an allowable invocation of the operation, constructor, or callback function with an argument value list of the given types. Due to the use of optional arguments and variadic operations and constructors, there may be multiple items in an effective overload set identifying the same operation or constructor.
</p>

<p>
有効~多重定義~集合を算出する方法は、以下の~algoに述べられる。
必要に応じて，上述の入力~変数が利用される：
◎
The algorithm below describes how to compute an effective overload set. The following input variables are used, if they are required:
</p>

<ul>
	<li>
%A は［
演算／有名~構築子
］の識別子
◎
the identifier of the operation or named constructor is A
</li>
	<li>
%N は引数個数
◎
the argument count is N
</li>
	<li>
%I は~ifc
◎
the interface is I
</li>
	<li>
%C は呼戻~関数
◎
the callback function is C
</li>
</ul>

<p>
以下において言及される，拡張属性の引数は、その`有名~引数~list$の引数を指すとする。
◎
Whenever an argument of an extended attribute is mentioned, it is referring to an argument of the extended attribute’s named argument list.
</p>

<ol class="algorithm">
	<li>
%S ~LET 新たな`有順序~集合$
◎
Let S be an ordered set.
</li>
	<li>
<p>
%F ~LET ［
有効~多重定義~集合の種類に応じて，次で与えられる~itemたち
］からなる新たな`有順序~集合$：
◎
Let F be an ordered set with items as follows, according to the kind of effective overload set:
</p>
		<dl class="switch">
			<dt>
正則~演算
◎
For regular operations
</dt>
			<dd>
%I 上で定義された`正則~演算$のうち，［
その識別子 ~EQ %A
］なるもの
◎
The elements of F are the regular operations with identifier A defined on interface I.
</dd>

			<dt>
静的~演算
◎
For static operations
</dt>
			<dd>
%I 上で定義された`静的~演算$のうち，［
その識別子 ~EQ %A
］なるもの
◎
The elements of F are the static operations with identifier A defined on interface I.
</dd>

			<dt>
構築子
◎
For constructors
</dt>
			<dd>
%I 上の `Constructor$x `拡張属性$
◎
The elements of F are the [Constructor] extended attributes on interface I.
</dd>

			<dt>
有名~構築子
◎
For named constructors
</dt>
			<dd>
%I 上の `NamedConstructor$x `拡張属性$のうち，［
その`有名~引数~list$の識別子 ~EQ %A
］なるもの
◎
The elements of F are the [NamedConstructor] extended attributes on interface I whose named argument lists’ identifiers are A.
</dd>

			<dt>
呼戻~関数
◎
For callback functions
</dt>
			<dd>
呼戻~関数~自身である %C （唯一つ）
◎
The single element of F is the callback function itself, C.
</dd>
		</dl>
	</li>
	<li>
<p>
%maxarg ~LET ［
%F 内の各~item（`関数類$）が宣言している引数~個数
］の最大
— ただし，［
`可変個の引数$をとる`関数類$
］の中の`末尾~引数$は、 1 個の引数に数える
◎
Let maxarg be the maximum number of arguments the operations, constructor extended attributes or callback functions in F are declared to take. For variadic operations and constructor extended attributes, the argument on which the ellipsis appears counts as a single argument.
</p>

<p class="note">注記：
したがって
`void f(long x, long... y);^c
が宣言している引数~個数は 2 個と見なされる。
◎
Note: So void f(long x, long... y); is considered to be declared to take two arguments.
</p>
	</li>
	<li>
%max ~LET `max$( %maxarg, %N )
◎
Let max be max(maxarg, N).
</li>
	<li>
<p>
%F 内の~EACH ( %X ) に対し：
◎
For each operation, extended attribute, or callback function X in F:
</p>

		<ol>
			<li>
%引数~list ~LET %X がとるよう宣言されている引数たちからなる`~list$
◎
Let arguments be the list of arguments X is declared to take.
</li>
			<li>
%n ~LET %引数~list の`~size$
（したがって %n ~LTE %max ）
◎
Let n be the size of arguments.
</li>
			<li>
%型~list ~LET 新たな`~list$
（これは、`型~list$oLを与えることになる）
◎
Let types be a type list.
</li>
			<li>
%省略可否~list ~LET 新たな`~list$
（これは、`省略可否~list$oLを与えることになる）
◎
Let optionalityValues be an optionality list.
</li>
			<li>
<p>
%引数~list 内の~EACH( %引数 ) に対し：
◎
For each argument in arguments:
</p>
				<ol>
					<li>
%引数 の型を %型~list に`付加-$する
◎
Append the type of argument to types.
</li>
					<li>
%引数 に応じて，次で与えられる値を %省略可否~list に`付加-$する
⇒
`可変個~引数$ならば `可変個^C ／
~ELSE_ `随意~引数$ならば `省略可^C ／
~ELSE_ `必須^C
◎
Append "variadic" to optionalityValues if argument is a final, variadic argument, "optional" if argument is optional, and "required" otherwise.
</li>
				</ol>
			</li>
			<li>
`~tuple$( %X, %型~list, %省略可否~list )
を %S に`付加-$setする
◎
Append the tuple (X, types, optionalityValues) to S.
</li>
			<li>
<p>
~IF［
%X は `可変個の引数$をとるように宣言されている
］：
◎
If X is declared to be variadic, then:
</p>
				<ol>
					<li>
<p>
%n ~LTE %i ~LT %max なる ~EACH( 整数 %i ) に対し，~~昇順に：
◎
For each i in the range n to max − 1, inclusive:
</p>
						<ol>
							<li>
%t ~LET %型~list の複製
◎
Let t be a type list.
</li>
							<li>
%o ~LET %省略可否~list の複製
◎
Let o be an optionality list.
◎
For each j in the range 0 to n − 1, inclusive:
• Append types[j] to t.
• Append optionalityValues[j] to o.
</li>
							<li>
<p>
%n ~LTE %j ~LTE %i なる ~EACH( 整数 %j ) に対し：
◎
For each j in the range n to i, inclusive:
</p>
								<ol>
									<li>
%型~list[ %n − 1] を %t に`付加-$する
◎
Append types[n − 1] to t.
</li>
									<li>
`可変個^C を %o に`付加-$する
◎
Append "variadic" to o.
</li>
								</ol>
							</li>
							<li>
`~tuple$( %X, %t, %o ) を %S に`付加-$setする
◎
Append the tuple (X, t, o) to S.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
%n ~GT %i ~GTE 0 なる ~EACH( 整数 %i ) に対し，~~降順に：
◎
Let i be n − 1.
◎
While i ≥ 0:
</p>

				<ol>
					<li>
~IF［
%省略可否~list[ %i ] ~EQ `必須^C
］
⇒
~BREAK
◎
If arguments[i] is not optional (i.e., it is not marked as "optional" and is not a final, variadic argument), then break.
</li>
					<li>
［
%t, %o
］ ~LET 順に［
%型~list, %省略可否~list
］の複製
◎
↓</li>
					<li>
［
%t, %o
］それぞれに対し，その尾部から 0 個~以上の~itemたちを［
その`~size$ ~EQ %i
］になるよう除去する
◎
Let t be a type list.
◎
Let o be an optionality list.
◎
For each j in the range 0 to i − 1, inclusive:
• Append types[j] to t.
• Append optionalityValues[j] to o.
</li>
					<li>
<p>
`~tuple$( %X, %t, %o ) を %S に`付加-$setする
◎
Append the tuple (X, t, o) to S.
</p>

<p class="note">注記：
%i ~EQ 0 ならば %t, %o は`空$になる。
◎
Note: if i is 0, this means to add to S the tuple (X, « », « »); (where "« »" represents an empty list).
◎
Set i to i − 1.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %S
◎
Return S.
</li>
</ol>

<div class="example" id="_dist-example-1_">
<p>
次の~ifcに対し：
◎
For the following interface:
</p>

<pre class="webidl">
interface A {
  /* f1 */ void f(DOMString %a);
  /* f2 */ void f(Node %a, DOMString %b, double... %c);
  /* f3 */ void f();
  /* f4 */ void f(Event %a, DOMString %b, optional DOMString %c, double... %d);
};
</pre>

<p>
`Node^T と `Event^T は、どの~objからも両方同時には実装できない，別々の~ifcとする。
［
識別子 `f^c, 引数個数 4
］の`正則~演算$からなる`有効~多重定義~集合$は：
◎
assuming Node and Event are two other interfaces of which no object can implement both, the effective overload set for regular operations with identifier f and argument count 4 is:
</p>

<pre class="set">
«
  (f1, « DOMString »,                           « `必須^C »),
  (f2, « Node, DOMString »,                     « `必須^C, `必須^C »),
  (f2, « Node, DOMString, double »,             « `必須^C, `必須^C, `可変個^C »),
  (f2, « Node, DOMString, double, double »,     « `必須^C, `必須^C, `可変個^C, `可変個^C »),
  (f3, « »,                                     « »),
  (f4, « Event, DOMString »,                    « `必須^C, `必須^C »),
  (f4, « Event, DOMString, DOMString »,         « `必須^C, `必須^C, `省略可^C »),
  (f4, « Event, DOMString, DOMString, double », « `必須^C, `必須^C, `省略可^C, `可変個^C »)
»
</pre>

</div>


<p>
2 つの型は、次の~algoが ~T を返すならば，
`判別可能@
であるとされる：
◎
Two types are distinguishable if the following algorithm returns true.
</p>

<ol class="algorithm">
	<li>
<div class="p">
<p>
~IF［
一方の型は`~nullable型を内包する$
］~AND［
他方の型は 次のいずれかを満たす
］
⇒
~RET ~F：
</p>

<ul><li>`~nullable型を内包する$
</li><li>`共用体~型$である ~AND
その`平坦化~mb型$に`辞書~型$が含まれている
</li><li>`辞書~型$である
</li></ul>

◎
If one type includes a nullable type and the other type either includes a nullable type, is a union type with flattened member types including a dictionary type, or is a dictionary type, return false.
</div>


<div class="example">

<p>
次の各~pairは、いずれも判別可能でない：
</p>

<ul><li>`double?^T と `Dictionary1^T
</li><li>`(Interface1 or long)?^T と `(Interface2 or DOMString)?^T
</li><li>`(Interface1 or long?)^T と `(Interface2 or DOMString)?^T
</li><li>`(Interface1 or long?)^T と `(Interface2 or DOMString?)^T
</li><li>`(Dictionary1 or long)^T と `(Interface2 or DOMString)?^T
</li><li>`(Dictionary1 or long)^T と `(Interface2 or DOMString?)^T
</li></ul>

<p>
（ `Interface1^T, `Interface2^T は ~ifc型，
`Dictionary1^T は 辞書~型とする）
</p>

◎
None of the following pairs are distinguishable:
•  double? and Dictionary1
• (Interface1 or long)? and (Interface2 or DOMString)?
• (Interface1 or long?) and (Interface2 or DOMString)?
• (Interface1 or long?) and (Interface2 or DOMString?)
• (Dictionary1 or long) and (Interface2 or DOMString)?
• (Dictionary1 or long) and (Interface2 or DOMString?) 
</div>

	</li>
	<li>
~IF［
両方の型とも［
`共用体~型$ ／`~nullable$`共用体~型$
］である
］
⇒
~RET
両者のどの`~mb型$どうしも互いに判別可能であるならば ~T ／
~ELSE_ ~F
◎
If both types are either a union type or nullable union type, return true if each member type of the one is distinguishable with each member type of the other, or false otherwise.
</li>
	<li>
~IF［
一方の型は［
`共用体~型$ ／~nullable共用体~型
］である
］
⇒
~RET 
その共用体のどの`~mb型$も 他方の型と`判別可能$であるならば ~T ／
~ELSE_ ~F
◎
If one type is a union type or nullable union type, return true if each member type of the union type is distinguishable with the non-union type, or false otherwise.
</li>
	<li>
<div class="p">
<p>
~IF［
2 つそれぞれの`最内縁の型$は，［
下の表に現れる
~OR
下の表に現れる分類に入る
］~AND［
対応する欄に “●” 印がある, または［
対応する欄に英字があって，表の下に指定される追加の要件を満たす
］］
⇒
~RET ~T
</p>

<p>
ここで、所与の型 %T の
`最内縁の型@
は，次に従って決定される型とする：
</p>
		<ol>
			<li>
~IF［
%T は`注釈付きの型$である
］
⇒
%T ~SET %T の`内縁~型$anO
</li>
			<li>
~IF［
%T は`~nullable型$である
］
⇒
%T ~SET %T の`内縁~型$
</li>
			<li>
~RET %T
</li>
		</ol>

◎
Consider the two "innermost" types derived by taking each type’s inner type if it is an annotated type, and then taking its inner type inner type if the result is a nullable type. If these two innermost types appear or are in categories appearing in the following table and there is a “●” mark in the corresponding entry or there is a letter in the corresponding entry and the designated additional requirement below the table is satisfied, then return true. Otherwise return false.
</div>

<p>
下の表に現れる分類は、次で定義される：
◎
Categories:
</p>

		<ul>
			<li>
~ifc類
⇒
`呼戻~ifc$でない`~ifc型$ ／
`例外~型$ ／
`~buffer~source型$
◎
interface-like
• non-callback interface types
• exception types
• buffer source types
</li>
			<li>
辞書~類
⇒
`辞書~型$ ／
`~record型$ ／
`呼戻~ifc$である`~ifc型$
◎
dictionary-like
• dictionary types
• record types
• callback interfaces
</li>
			<li>
連列~類
⇒
`連列~型$ ／
`凍結~配列~型$
◎
sequence-like
• sequence types
• frozen array types
</li>
</ul>

<div style="overflow:auto;">
<table id="distinguishable-table">
<thead><tr><th>
<th><span>`boolean$T
</span><th><span>`実数~型$
</span><th><span>`文字列~型$
</span><th><span>`object$T
</span><th><span>`symbol$T
</span><th><span>~ifc類
</span><th><span>`呼戻~関数$
</span><th><span>辞書~類
</span><th><span>連列~類
</span></thead>

<tbody><tr><th>`boolean$T
<td><td>●<td>●<td>●<td>●<td>●<td>●<td>●<td>●

<tr><th>`実数~型$
<td colspan="1"><td><td>●<td>●<td>●<td>●<td>●<td>●<td>●

<tr><th>`文字列~型$
<td colspan="2"><td><td>●<td>●<td>●<td>●<td>●<td>●

<tr><th>`object$T
<td colspan="3"><td><td>●<td><td><td><td>

<tr><th>`symbol$T
<td colspan="4"><td><td>●<td>●<td>●<td>●

<tr><th>~ifc~類
<td colspan="5"><td>(a)<td>●<td>●<td>●

<tr><th>呼戻~関数
<td colspan="6"><td><td><td>●

<tr><th>辞書~類
<td colspan="7">
<td><td>●

<tr><th>連列~類
<td colspan="8"><td>

</tbody></table></div>

<p>
(a) — 識別される 2 つの~ifc類の型が同じ`~platform~obj$に実装されることは、起こり得ない（特に， 2 つは同じ~ifcでない）。
◎
The two identified interface-like types are not the same, and no single platform object implements both interface-like types.
</p>

	</li>
	<li>
~RET ~F
◎
↑</li>
</ol>

<div class="example">

<ul>
	<li>
`double$T と `DOMString$T とは判別可能になる
— `実数~型$と`文字列~型$の交差する欄に ● 印があるので。
◎
double and DOMString are distinguishable because there is a ● at the intersection of numeric types with string types.
</li>
	<li>
`double$T と `long$T は判別可能でない
— 両者とも`実数~型$であり，`実数~型$と`実数~型$の交差する欄に ● 印はないので
◎
double and long are not distinguishable because they are both numeric types, and there is no ● or letter at the intersection of numeric types with numeric types.
</li>
	<li>
<p>
次の~IDL片が与えられたとするとき：
◎
Given:
</p>

<pre class="webidl">
callback interface CBIface {
    attribute DOMString attr1;
};

interface Iface {
    attribute DOMString attr2;
};

dictionary Dict {
    DOMString field1;
};
</pre>

<p>
`CBIface^T は、
`Iface^T とは 判別可能になる（辞書~類 と ~ifc類が交差する欄に ● があるので）が，
`Dict^T とは判別可能にならない（辞書~類どうしが交差する欄に ● がないので）
◎
CBIface is distinguishable from Iface because there’s a ● at the intersection of dictionary-like and interface-like, but it is not distinguishable from Dict because there’s no ● at the intersection of dictionary-like and itself.
</li>
	<li>
`~promise型$は、上の表には現れていないので，他のどの型とも判別可能でない。
◎
Promise types do not appear in the above table, and as a consequence are not distinguishable with any other type.
</li>
</ul>
</div>

<div class="p">
<p>
負でない整数 %N 【すなわち引数~個数】,
【N から算出される】
`有効~多重定義~集合$ %S
が与えられた下で：
</p>

<ul>
	<li>
%S の中の複数の`~item$が［
その`型~list$oLの`~size$ ~EQ %N
］を満たすならば、［
それらのどの 2 つの~itemに対しても~index %i に位置する 2 つの型が`判別可能$になる
］ような，~index %i が存在し~MUST。
</li>
	<li>
そのような~indexのうち，最小のものを、 %~size に対する
`判別引数~index@
と呼ぶ。
</li>
</ul>
◎
If there is more than one item in an effective overload set that has a given type list size, then for those items there must be an index i such that for each pair of items the types at index i are distinguishable. The lowest such index is termed the distinguishing argument index for the items of the effective overload set with the given type list size.
</div>

<div class="example">
<p>
前の例に示された有効~多重定義~集合を考える。
`型~list$oL ~size %~size ~IN { 2, 3, 4 } に対するそれは、いずれも複数の~itemを含む。
これらいずれの %~size に対しても、［
`Node^T, `Event^T
］は`判別可能$になるので，`判別引数~index$は 0 になる。
◎
Consider the effective overload set shown in the previous example. There are multiple items in the set with type lists 2, 3 and 4. For each of these type list size, the distinguishing argument index is 0, since Node and Event are distinguishable.
</p>

<p>
しかしながら，次の多重定義の利用は妥当でない：
◎
The following use of overloading however is invalid:
</p>

<pre class="webidl">
interface B {
  void f(DOMString %x);
  void f(USVString %x);
};
</pre>

<p>
`DOMString$T と `USVString$T は判別可能でないので。
◎
since DOMString and USVString are not distinguishable.
</p>
</div>

<p>
加えて，［
0 ~LTE %j ~LT ［
所与の `型~list$oL ~sizeに対する`判別引数~index$
］］を満たすどの~index %j に対しても，次が満たされ~MUST
⇒
【~sizeから算出される】
`有効~多重定義~集合$のすべての~itemにわたり
⇒
［
それらの`型~list$oL[ %j ] は互いに同じになる
］~AND［
それらの`省略可否~list$oL[ %j ] は互いに同じになる
］。
◎
In addition, for each index j, where j is less than the distinguishing argument index for a given type list size, the types at index j in all of the items’ type lists must be the same, and the optionality values at index j in all of the items’ optionality lists must be the same.
</p>

<div class="example">
<p>
次は妥当でない：
◎
The following is invalid:
</p>

<pre class="webidl">
interface B {
  /* f1 */ void f(DOMString %w);
  /* f2 */ void f(long %w, double %x, Node %y, Node %z);
  /* f3 */ void f(double %w, double %x, DOMString %y, Node %z);
};
</pre>

<p>
引数個数 4 に対する
有効~多重定義~集合は：
◎
For argument count 4, the effective overload set is:
</p>

<pre class="set">
«
  (f1, « DOMString »,                       « `必須^C »),
  (f2, « long, double, Node, Node »,        « `必須^C, `必須^C, `必須^C, `必須^C »),
  (f3, « double, double, DOMString, Node », « `必須^C, `必須^C, `必須^C, `必須^C »)
»
</pre>

<p>
であり、`型~list$oL ~size 4 の~itemを調べると，
`Node^T と `DOMString$T は`判別可能$なので、
`判別引数~index$は 2 になる。
しかしながら，これらの 2 つの多重定義の~index 0 に位置する引数~型は異なるので、この多重定義は妥当でない。
◎
Looking at items with type list size 4, the distinguishing argument index is 2, since Node and DOMString are distinguishable. However, since the arguments in these two overloads at index 0 are different, the overloading is invalid.
</p>
</div>


<div class="trans-note">

<p>【
複雑な条件だが，概念的には、共用体~型を利用して，多重定義された宣言を等価な単独の宣言に併合するために必要な条件が意図されている様に見られる。
例えば、<a href="#_dist-example-1_">先に挙げられた例</a>は，次のように書き換え得る：
】</p>

<pre class="webidl">
interface A {
             /*---f4----*/ /*-f2-*/     /*---f1----*/    /*-f3-*/
  void f(
    optional ( Event     or Node     or   DOMString ) %a, /*----*/
    optional   DOMString             %b, /*---------------------*/
    optional ( DOMString or double ) %c, /*---------------------*/
               double...             %d  /*---------------------*/
  );
};
</pre>

<p>【
これらの書き方の相違は、`idl-overloading-vs-union$secに述べられている。
】</p>

</div>

				<section id="idl-overloading-vs-union">
<h4 title="Overloading vs. union types">2.4.6.1. 多重定義 vs. 共用体~型</h4>

~INFORMATIVE

<p>
~IDL`演算$を定義している仕様にとって、`多重定義$と［［
`共用体~型$, `随意~引数$
］の組合わせ
］とは，特色機能が~~重複しているように見えるかもしれない。
◎
For specifications defining IDL operations, it might seem that overloads and a combination of union types and optional arguments have some feature overlap.
</p>

<p>
先ず，重要な点として、`多重定義$の挙動は `共用体~型$, `随意~引数$とで相違するので，他方を用いて 全部的に<em>定義できない</em>ことに注意（もちろん、~Web~IDL型~systemの目的を無為にしかねない 追加の注釈文が提供されない限り）。
例えば `CanvasDrawPath$T ~ifcに定義される `stroke()$M 演算を考える
`HTML$r
：
◎
It is first important to note that overloads have different behaviors than union types or optional arguments, and one cannot be fully defined using the other (unless, of course, additional prose is provided, which can defeat the purpose of the Web IDL type system). For example, consider the stroke() operations defined on the CanvasDrawPath interface [HTML]:
</p>


<pre class="webidl">
interface CanvasDrawPathExcerpt {
  void stroke();
  void stroke(Path2D %path);
};
</pre>

<p>
~ES言語束縛により、
`CanvasDrawPathExcerpt^T を実装している~obj上で
`stroke(undefined)^c
を~callした場合，
 2 個目の多重定義を~callしようと試みる結果 `TypeError$jE になる
— `undefined^jv は `Path2D$T に<a href="#es-to-interface">変換-</a>できないので。
しかしながら~~仮に、演算が，`随意~引数$を伴って定義されていて，一つに併合されていた場合：
◎
Per the ECMAScript language binding, calling stroke(undefined) on an object implementing CanvasDrawPathExcerpt would attempt to call the second overload, yielding a TypeError since undefined cannot be converted to a Path2D. However, if the operations were instead defined with optional arguments and merged into one,
</p>


<pre class="webidl">
interface CanvasDrawPathExcerptOptional {
  void stroke(optional Path2D %path);
};
</pre>

<p>
`多重定義~解決~algo$は、同じ
`stroke(undefined)^c
~callに対し， %path 引数 を不在<!-- ＊ -->として扱うことになり，例外は投出されない。
◎
the overload resolution algorithm would treat the path argument as not present given the same call stroke(undefined), and not throw any exceptions.
</p>

<p class="note">注記：
この特定0の例では、後者の挙動が，実際に~Web開発者たちが一般に期待するものである。
今日 `CanvasDrawPath$T 設計するなら、 `stroke()^M には`随意~引数$を利用することになるであろう。
◎
Note: For this particular example, the latter behavior is actually what Web developers would generally expect. If CanvasDrawPath were to be designed today, optional arguments would be used for stroke().
</p>

<p>
加えて，意味論的な相違もある。
`共用体~型$は、通例的に
“どの型もおよそ同じ仕方で働く”
ような~~意味で利用される。
対照的に，`多重定義$された演算は、 C++ の多重定義などの言語~特色機能に上手く対応付けられるように設計されており、通例的に，所与の引数の異なる型ごとに何を行うかについて相当の相違がある演算たちに、より良く収まる。
しかしながら，ほとんどの事例では、そのような相違がある演算たちには 異なる名前を伴わせて，~Web開発者からの混同を避けるのが最善になる
— ~ES言語は、言語~levelの多重定義を提供しないので。
そのため，多重定義は、新たな~APIに適切になるのは稀であり，旧来の~APIや特化された状況下で現れることが多い。
◎
Additionally, there are semantic differences as well. Union types are usually used in the sense that "any of the types would work in about the same way". In contrast, overloaded operations are designed to map well to language features such as C++ overloading, and are usually a better fit for operations with more substantial differences in what they do given arguments of different types. However, in most cases, operations with such substantial differences are best off with different names to avoid confusion for Web developers, since the ECMAScript language does not provide language-level overloading. As such, overloads are rarely appropriate for new APIs, instead often appearing in legacy APIs or in specialized circumstances.
</p>


<p>
どの~Web~IDL言語~特色機能を利用するか決定するのが難しい事例のために、次の推奨と例を~~提供する：
◎
That being said, we offer the following recommendations and examples in case of difficulties to determine what Web IDL language feature to use:
</p>

<ul>
	<li>
<p>
演算の返値型を 引数の型ごとに異ならせる必要があるような，通例的でない事例では、`多重定義$の方が，より表現力のある~IDL片になる。
<span class="note">
これが適切な~API設計になることは、まずない。
そのような事例では、別個の名前を伴う別々の演算にする方が，通例的に良くなる。
</span>
◎
In the unusual case where the operation needs to return values of different types for different argument types, overloading will result in more expressive IDL fragments. This is almost never appropriate API design, and separate operations with distinct names usually are a better choice for such cases.
</p>


<p>
演算 `calculate()^M は，［
`long$T, `DOMString$T, `CalculatableInterface^T （ `~ifc型$ ）
］を受容する引数を 1 個だけとり，引数と同じ型の値を返すとする。
この場合、`多重定義$された演算を用いて~IDL片を書く方が明瞭になるであろう：
◎
Suppose there is an operation calculate() that accepts a long, DOMString, or CalculatableInterface (an interface type) as its only argument, and returns a value of the same type as its argument. It would be clearer to write the IDL fragment using overloaded operations as
</p>

<pre class="webidl">
interface A {
  long calculate(long %input);
  DOMString calculate(DOMString %input);
  CalculatableInterface calculate(CalculatableInterface %input);
};
</pre>

<p>
`~typedef$を伴う`共用体~型$を利用するよりも：
◎
than using a union type with a typedef as
</p>


<pre class="webidl">
typedef (long or DOMString or CalculatableInterface) Calculatable;
interface A {
  Calculatable calculate(Calculatable %input);
};
</pre>

<p>
これは、返値が常に %入力 と同じ型になる事実を伝えないので。
◎
which does not convey the fact that the return value is always of the same type as input.
</p>


<p>
多重定義のいずれかの返値型が `void$T であるときには、より問題になる
— `共用体~型$は`~mb型$に `void$T すら包含できないので。
その事例では、返値型を定義する適切な注釈文を伴わせた上で，返値型に `any$T を利用する必要があり、表現力はさらに乏しくなる。
◎
The problem is exacerbated when one of the overloads has a return type of void, since union types cannot even contain void as a member type. In that case, a return type of any needs to be used with appropriate prose defining the return type, further decreasing expressiveness.
</p>

<p>
仕様~化する `calculate()^M が新たな~APIで，互換性の懸念はない場合、多重定義される演算に対しては，互いに異なる名前を利用することが示唆される
— 例えば，次のように：
◎
If the specified calculate() is a new API and does not have any compatibility concerns, it is suggested to use different names for the overloaded operations, perhaps as
</p>


<pre class="webidl">
interface A {
  long calculateNumber(long %input);
  DOMString calculateString(DOMString %input);
  CalculatableInterface calculateCalculatableInterface(CalculatableInterface %input);
};
</pre>

<p>
こうすれば、~Web開発者は，明示的かつ一義的な~codeを書けるようになる。
◎
which allows Web developers to write explicit and unambiguous code.
</p>
	</li>
	<li class="trans-note">
<p>【
他にも、演算ごとに異なる拡張属性や特殊~演算を指定する場合も、多重定義する他にないであろう
— 例えば：
】</p>

<pre class="webidl">
interface A {
  `NewObject$x calculate f(B %a);
              calculate f(C %a);
};
</pre>

<p>【
（このように指定される演算は，ほぼないと思われるが、このような指定-法を総じて禁止している箇所は、この仕様の中には見当たらない。）
】</p>

	</li>
	<li>
<p>
引数の型や個数ごとに，演算が意味論的に有意に異なる場合、`多重定義$が選好される。
ここでも，そのような局面では、別個の名前を伴わせた別々の演算を作成する方が通例的には良いが、旧来の~APIには，この~patternに従うものもある。
◎
When the operation has significantly different semantics for different argument types or lengths, overloading is preferred. Again, in such scenarios, it is usually better to create separate operations with distinct names, but legacy APIs sometimes follow this pattern.
</p>

<p>
例として，
`CSS$T ~ifcの `supports()$M 演算
`CSS3-CONDITIONAL$r `CSSOM$r
は、次の~IDL片として定義されている：
◎
As an example, the supports() operations of the CSS interface is defined as the following IDL fragment [CSS3-CONDITIONAL] [CSSOM].
</p>

<pre class="webidl">
partial interface CSS {
  static boolean supports(CSSOMString %property, CSSOMString %value);
  static boolean supports(CSSOMString %conditionText);
};
</pre>

<p>
この~IDL片は、`随意~引数$を用いて，次のように書き直すこともできる：
◎
Using optional arguments one can rewrite the IDL fragment as follows:
</p>


<pre class="webidl">
partial interface CSSExcerptOptional {
  static boolean supports(CSSOMString %propertyOrConditionText, optional CSSOMString %value);
};
</pre>

<p>
この~versionの~IDLは、元のものより短くなっているが， 1 個目の引数に全く異なる 2 つの概念が~~併合されている。
`多重定義$しない場合、注釈文による演算の定義を読むことなく，
“ %property ／ %conditionText は %value と~pairになるのか？ ”
のような問いに答えるのは、はるかに難しくなる。
そのため、この~versionは，元のものより著しく読み取り難くなっている。
◎
Even though the IDL is shorter in the second version, two distinctively different concepts are conflated in the first argument. Without overloads, the question "is property or conditionText paired with value?" is much more difficult to answer without reading the prose definition of the operation. This makes the second version remarkably less readable than the first.
</p>

<p>
別の考慮点として、`多重定義$された演算の注釈文は，演算ごとに別々の~block内に指定できるので、仕様を読むときにも書くときにも援助になることが挙げられる
— このことは、`随意~引数$にはあてはまらない。
すなわち，最初の事例に対しては、仕様~策定者は，演算の定義を 次のように注釈文に書けるようになる：
◎
Another consideration is that the prose for overloaded operations can be specified in separate blocks, which can aid in both reading and writing specifications. This is not the case for optional arguments. This means that in the first case the specification author can write the prose definition of the operations as:
</p>

<p>
<code class="idlmember">supports(%property, %value)</code>
~methの~call時には、次を走らせ~MUST：
◎
The supports(property, value) method, when called, must run these steps:
</p>

<ol><li>…
</li></ol>

<hr>

<p>
<code class="idlmember">supports(%conditionText)</code>
~methの~call時には、次を走らせ~MUST：
◎
The supports(conditionText) method, when called, must run these steps:
</p>

<ol><li>…
</li></ol>

<p>
それでも`随意~引数$として %value を用いる場合、仕様~策定者は、実質的に`多重定義~解決~algo$を再現するような，模範文例的~styleで~textを書く必要がある。
◎
Yet using value as an optional argument, the specification author has to use more boilerplate-style text to effectively replicate the overload resolution algorithm.
</p>

<p>
<code class="idlmember">supports(%propertyOrConditionText, %value)</code>
~methの~call時には、次を走らせ~MUST：
◎
The supports(propertyOrConditionText, value) method, when called, must run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
%value は与えられている
］：
◎
If value is given, then:
</p>
				<ol>
					<li>
%property ~LET %propertyOrConditionText
◎
Let property be propertyOrConditionText.
</li>
					<li>
…
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>

				<ol>
					<li>
%conditionText ~LET %propertyOrConditionText
◎
Let conditionText be propertyOrConditionText.
</li>
					<li>
…
</li>
				</ol>
			</li>
		</ol>

<p>
2 つの多重定義が共有する部分が少ししかないなら、多重定義~解決を~IDLの仕組みに委ねる方が良い。
◎
If the two overloads have little to no shared parts, it is better to leave overload resolution to the IDL mechanism.
</p>
	</li>
	<li>
<p>
演算が 複数の引数をとり，その それぞれが複数の型を受容していて，異なる引数どうしの型が組にされていない場合、`共用体~型$の他は~~実現できそうにないこともある。
◎
If the operation accepts multiple types for multiple arguments with no coupling between types of different arguments, union types can sometimes be the only viable solution.
</p>

<pre class="webidl">
typedef (long long or DOMString or CalculatableInterface) %SupportedArgument;
interface A {
  void add(SupportedArgument %operand1, %SupportedArgument %operand2);
};
</pre>

<p>
上の `add()^M 演算を，`多重定義$を利用して指定しようとした場合、次が要求されることになる：
◎
For the add() operation above, to specify it using overloads would require
</p>


<pre class="webidl">
interface A {
  void add(long long %operand1, long long %operand2);
  void add(long long %operand1, DOMString %operand2);
  void add(long long %operand1, CalculatableInterface %operand2);
  void add(DOMString %operand1, long long %operand2);
  void add(DOMString %operand1, DOMString %operand2);
  void add(DOMString %operand1, CalculatableInterface %operand2);
  void add(CalculatableInterface %operand1, long long %operand2);
  void add(CalculatableInterface %operand1, DOMString %operand2);
  void add(CalculatableInterface %operand1, CalculatableInterface %operand2);
};
</pre>

<p>
対応する注釈文も， 9 回重ねることになる。
◎
and nine times the corresponding prose!
</p>
			</li>
			<li>
<p>
仕様~策定者には、 `missing^C 引数と `undefined^jv 引数とを，~ES言語束縛において同じ仕方で扱うことが奨励される。
◎
Specification authors are encouraged to treat missing argument and undefined argument the same way in the ECMAScript language binding.
</p>

<p>
次の~IDL片が与えられたとき：
◎
Given the following IDL fragment:
</p>


<pre class="webidl">
interface A {
  void foo();
  void foo(Node? %arg);
};
</pre>

<p>
~ES言語束縛を利用する下で，
`foo()^M を~callするとき、引数に［
`undefined^jv ／ `null^jv
］を渡した場合は，
%arg を ~NULL に設定した上で 2 個目の `foo()^M 演算に対応する手続きを走らすことになる。
一方で、引数を省いた場合は， 1 個目の多重定義に行くことになり、多くの~API利用者にとって意外な挙動になるであろう。
仕様~策定者には、代わりに，`随意~引数$を利用することが奨励される
— そうすれば、引数が省かれたときも `undefined^jv のときも，
“%arg は不在<!-- ＊ -->” 
に分類されることになる。
◎
Using the ECMAScript language binding, calling foo(undefined) and foo(null) would both run the steps corresponding to the foo(arg) operation, with arg set to null, while foo() alone would go to the first overload. This can be a surprising behavior for many API users. Instead, specification authors are encouraged to use an optional argument, which would categorize both foo() and foo(undefined) as "arg is not present".
</p>


<pre class="webidl">
interface A {
  void foo(optional Node? %arg);
};
</pre>


<p>
一般に，随意~性は、多重定義は利用せず， `optional^c ~keywordを利用して表すのが最善になる。
◎
In general, optionality is best expressed using the optional keyword, and not using overloads.
</p>

	</li>
</ul>

<p>
上のどの分類にも収まらない事例で，どの~styleを選ぶかは、仕様~策定者に委ねられる
— ほとんどの場合、どちらの~styleでも，意図される挙動を簡便に述べるに足るので。
しかしながら、［
`共用体~型$, `随意~引数$
］の定義と<a href="#es-to-union">変換~algo</a>の方が，`多重定義$の<a href="#dfn-overload-resolution-algorithm">それ</a>よりも実装して選り分けるのは単純であり、通例的に，~ES言語束縛において より成句的な~APIになる。
したがって，他の考慮点が適用されない限り、`共用体~型$や`随意~引数$を選ぶ方が既定になる。
◎
When the case fits none of the categories above, it is up to the specification author to choose the style, since it is most likely that either style would sufficiently and conveniently describe the intended behavior. However, the definition and conversion algorithms of union types and optional arguments are simpler to implement and reason about than those of overloads, and usually result in more idiomatic APIs in the ECMAScript language binding. Thus, unless any other considerations apply, union types (and/or optional arguments) are the default choice.
</p>

<p>
仕様~策定者は、適切かつ簡便であると見出したなら，共用体~型と多重定義を混ぜ合わせるのも自由である。
◎
Specifications are also free to mix and match union types and overloads, if the author finds it appropriate and convenient.
</p>

				</section>
			</section>
			<section id="idl-iterable">
<h4 title="Iterable declarations">2.4.7. 可反復~宣言</h4>

<p>
~ifcは
`可反復@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`可反復~宣言@
（`Iterable$g に合致）を利用する。
◎
An interface can be declared to be iterable by using an iterable declaration (matching Iterable) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  iterable&lt;`value_type^i&gt;;
  iterable&lt;`key_type^i, `value_type^i&gt;;
};
</pre>

<p>
可反復として宣言された~ifcを実装している~objは、値の連列を得るために反復できるようになる。
◎
Objects implementing an interface that is declared to be iterable support being iterated over to obtain a sequence of values.
</p>

<p class="note">注記：
~ES言語束縛においては、可反復な~ifcは、その`~ifc原型~obj$上に，［
`entries^l, `forEach^l, `keys^l, `values^l, `iterator$jS
］~propを持つことになる。
◎
Note: In the ECMAScript language binding, an interface that is iterable will have “entries”, “forEach”, “keys”, “values” and @@iterator properties on its interface prototype object.
</p>

<p>
~parameterとして所与の型の個数が：
◎
↓</p>

<ul>
	<li>
1 個の場合、~ifcは，その型の値たちを提供する
`値~反復子@
を持つことになる。
◎
If a single type parameter is given, then the interface has a value iterator and provides values of the specified type.＼
</li>
	<li>
2 個の場合、~ifcは，［
~key, 値
］からなる~pairたちを提供する
`~pair反復子@
を持つことになる。
ここで、~pairの~keyは， 1 個目の型の値をとり、~pairの値は， 2 個目の型の値をとる。
◎
If two type parameters are given, then the interface has a pair iterator and provides value pairs, where the first value is a key and the second is the value associated with the key.
</li>
</ul>

<p>
`値~反復子$は、`有index~propを~support$する~ifc上を除き，宣言されては~MUST_NOT。
`値~反復子$の値~型は、`有index~prop取得子$が返す型と同じで~MUST。
`値~反復子$は暗黙的に，当の~objの有index~prop上を反復するように定義される。
◎
A value iterator must only be declared on an interface that supports indexed properties. The value-type of the value iterator must be the same as the type returned by the indexed property getter. A value iterator is implicitly defined to iterate over the object’s indexed properties.
</p>

<p>
`~pair反復子$は、`有index~propを~support$する~ifc上に宣言されては~MUST_NOT。
`~pair反復子$を伴う`~ifc$においては、付随する注釈文にて［
何が
`反復される値~pair@
の~listを成すのか
］が定義され~MUST。
◎
A pair iterator must not be declared on an interface that supports indexed properties. Prose accompanying an interface with a pair iterator must define what the list of value pairs to iterate over is.
</p>


<div class="note">

<p>
`値~反復子$に対し生成される~ES `forEach^c ~methは、
`Array.prototype.forEach^c が行うように，その呼戻子を呼出す。
`~pair反復子$に対する `forEach^c ~methは、
`Map.prototype.forEach^c が行うように，その呼戻子を呼出す。
◎
The ECMAScript forEach method that is generated for a value iterator invokes its callback like Array.prototype.forEach does, and the forEach method for a pair iterator invokes its callback like Map.prototype.forEach does.
</p>

<p>
現在，`値~反復子$は`有index~propを~support$する~ifcのみに許容されているので、
`forEach^c ~methを配列のように利用することにも~~意味がある。
`値~反復子$は、次のものにも必要かもしれない：
(a) `有index~propを~support$しない~ifc上, あるいは
(b) 呼戻子を，代わりに `Set.protoype.forEach^c のように呼出す（ここで~keyは，値と同じ）ような `forEach^c ~methに対して。
そのような `forEach^c ~methを必要とする~APIを再~作成している策定者は、`Enhancement request for Iterables$fIされたし。
◎
Since value iterators are currently allowed only on interfaces that support indexed properties, it makes sense to use an Array-like forEach method. There may be a need for value iterators (a) on interfaces that do not support indexed properties, or (b) with a forEach method that instead invokes its callback like Set.protoype.forEach (where the key is the same as the value). If you’re creating an API that needs such a forEach method, please file an issue.
</p>

</div>

<p class="note">注記：
`配列~反復子~obj$は，このように働く。
`有index~propを~support$する ~ifcに対しては、［
`entries^l ／ `keys^l ／ `values^l ／ `iterator$jS
］から返される反復子~objは，実際の`配列~反復子~obj$である。
◎
Note: This is how array iterator objects work. For interfaces that support indexed properties, the iterator objects returned by “entries”, “keys”, “values” and @@iterator are actual array iterator objects.
</p>

<p>
［
可反復~宣言を伴う~ifc, および
その`被継承~ifc$
］の`~ifc~mb$の名前は［
`entries^l ／ `forEach^l ／ `keys^l ／ `values^l
］にされては~MUST_NOT。
◎
Interfaces with iterable declarations must not have any interface members named “entries”, “forEach”, “keys” or “values”, or have any inherited interfaces that have members with these names.
</p>


<div class="example">
<p>
次の~ifcを考える。
`SessionManager^T は、文字列 %username を~keyに，一連の `Session^T ~objに~accessできるようにする：
◎
Consider the following interface SessionManager, which allows access to a number of Session objects keyed by username:
</p>

<pre class="webidl">
interface SessionManager {
  Session getSessionForUser(DOMString %username);

  iterable&lt;DOMString, Session&gt;;
};

interface Session {
  readonly attribute DOMString username;
  /* <!--cp-some-code--> */
};
</pre>

<p>
反復子の挙動は、次の様に定義することもできる：
◎
The behavior of the iterator could be defined like so:
</p>

<blockquote>
`反復される値~pair$の~listを成す各
( ~key / 値 )
~pairは，
( `username^M  / ［
`SessionManager^T ~obj上で open している `Session^T ~obj
］ )
で与えられ、~listは `username^M の昇順で整列される。
◎
The value pairs to iterate over are the list of key-value pairs with the key being the username and the value being the open Session object on the SessionManager object corresponding to that username, sorted by username.
</blockquote>

<div class="p">
<p>
~ES言語束縛においては、
`SessionManager^T `~ifc$の`~ifc原型~obj$は、次の~methを持つことになる：
</p>

<ul>
	<li>
`values^c ~meth：
被呼出時に［［
次の反復値を返す `next^c ~meth
］を持つ反復子~obj
］を返す関数。
</li>
	<li>
`keys^c ~meth：
一連の `Session^T ~objの `username^M を反復する。
</li>
	<li>
`entries^c ~meth：
一連の ( `username^M / `Session^T ~obj ) ~pairを反復する。
</li>
	<li>
`iterator$jS ~meth：
`entries^c ~methと同じ値をとり，
`SessionManager^T を `for..of^c ~loopの中でも利用できるようする。
</li>
</ul>
◎
In the ECMAScript language binding, the interface prototype object for the SessionManager interface has a values method that is a function, which, when invoked, returns an iterator object that itself has a next method that returns the next value to be iterated over. It has keys and entries methods that iterate over the usernames of session objects and username/Session object pairs, respectively. It also has a @@iterator method that allows a SessionManager to be used in a for..of loop that has the same value as the entries method:
</div>

<pre class="es-code">
/* <span class="comment">
`SessionManager^T の~instanceを取得する。
2 人の利用者 `anna^l, `brian^l 用の session があるとする。
◎
Get an instance of SessionManager.
Assume that it has sessions for two users, "anna" and "brian".
</span> */
var %sm = getSessionManager();

typeof SessionManager.prototype.values;  /* <!--cp-eval-function--> */
var %it = %sm.values();    /* <span class="comment">
`values()^c は反復子~objを返す
◎
values() returns an iterator object
</span> */
typeof %it.next;          /* <!--cp-eval-function--> */

/* <span class="comment">
この~loopは、順に `anna^l, `brian^l を log することになる。
◎
This loop will log "anna" and then "brian".
</span> */
for (;;) {
  let %result = %it.next();
  if (%result.done) {
    break;
  }
  let %session = %result.value;
  console.log(%session.username);
}

/* <span class="comment">
この~loopも、順に `anna^l, `brian^l を log することになる。
◎
This loop will also log "anna" and then "brian".
</span> */
for (let %username of %sm.keys()) {
  console.log(%username);
}

/* <span class="comment">
同じことを達成する別の仕方。
◎
Yet another way of accomplishing the same.
</span> */
for (let [%username, %session] of %sm) {
  console.log(%username);
}
</pre>

</div>


<p>
`可反復~宣言$を伴う~ifc %I に対しては、［
%I, および %I の`被継承~ifc$
］に［
別の`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$
］が宣言されていては~MUST_NOT。
◎
An interface must not have more than one iterable declaration. The inherited interfaces of an interface with an iterable declaration must not also have an iterable declaration. An interface with an iterable declaration and its inherited interfaces must not have a maplike declaration or setlike declaration.
</p>

<p>
`可反復~宣言$には、次の拡張属性を適用できる
⇒
`Exposed$x,
`SecureContext$x
◎
The following extended attributes are applicable to iterable declarations: [Exposed], [SecureContext].

</p>

<div class="grammar">
Iterable
OptionalType
</div>


			</section>
			<section id="idl-maplike" class="L2">
<h4 title="Maplike declarations">2.4.8. ~maplike 宣言</h4>

<p>
~ifcは
`~maplike@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`~maplike 宣言@
（
`ReadWriteMaplike$g ／
`readonly^sym `MaplikeRest$g
いずれかに合致）を利用する。
◎
An interface can be declared to be maplike by using a maplike declaration (matching ReadWriteMaplike or readonly MaplikeRest) in the body of the interface.
</p>


<pre class="syntax">
interface `interface_identifier^i {
  readonly maplike&lt;`key_type^i, `value_type^i&gt;;
  maplike&lt;`key_type^i, `value_type^i&gt;;
};
</pre>


<p>
~maplikeになるように宣言された~ifcを実装する~objは、その一連の［
`~map~entry@
と呼ばれる~key-value
］からなる，有順序~listを表現する。
~keyおよび~valueに利用される型は、~maplike 宣言の山括弧の中で与えられる。
それらの~keyは一意になることが要求される。
◎
Objects implementing an interface that is declared to be maplike represent an ordered list of key–value pairs known as its map entries. The types used for the keys and values are given in the angle brackets of the maplike declaration. Keys are required to be unique.
</p>

<p>
`~maplike$ ~ifcを実装している~objの`~map~entry$の~listは、~objの作成~時には空である。
~ifcに付随している注釈文は、~objの一連の`~map~entry$が どう変化するかを述べ得る。
◎
The map entries of an object implementing a maplike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the map entries of an object change.
</p>

<p>
~maplike~ifcは、一連の~map~entryを照会するための，言語束縛に適切な~APIを~supportする。
`readonly^c ~keywordが利用されなかった場合†、~map~entryを改変するための~APIも~supportする。
【† 以下， “可書~maplike” とも記される】
◎
Maplike interfaces support an API for querying the map entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the map entries.
</p>

<p class="note">注記：
~ES言語束縛においては、一連の~map~entryとやりとりするための~APIは，
~ESにて可用な `Map$t ~objに類似する。
`readonly^c ~keywordが利用された場合、それは［
`entries^l, `forEach^l, `get^l, `has^l, `keys^l, `values^l, `iterator$jS
］~meth, および `size^l 取得子を含む。
可書~maplikeに対しては、更に［
`clear^l, `delete^l, `set^l
］~methも含む。
◎
Note: In the ECMAScript language binding, the API for interacting with the map entries is similar to that available on ECMAScript Map objects. If the readonly keyword is used, this includes “entries”, “forEach”, “get”, “has”, “keys”, “values”, @@iterator methods and a “size” getter. For read–write maplikes, it also includes “clear”, “delete” and “set” methods.
</p>

<p>
［
~maplike~ifc, および
その`被継承~ifc$
］の`~ifc~mb$の名前は［
`entries^l ／ `forEach^l ／ `get^l ／ `has^l ／ `keys^l ／ `size^l ／ `values^l
］にされては~MUST_NOT。
［
可書~maplike~ifc, および
その`被継承~ifc$
］の［
`属性$, `定数$
］の名前は［
`clear^l ／ `delete^l ／ `set^l
］にされては~MUST_NOT。
◎
Maplike interfaces must not have any interface members named “entries”, “forEach”, “get”, “has”, “keys”, “size”, or “values”, or have any inherited interfaces that have members with these names. Read–write maplike interfaces must not have any attributes or constants named “clear”, “delete”, or “set”, or have any inherited interfaces that have attributes or constants with these names.
</p>

<p class="note">注記：
［
名前 ~IN { `clear^l, `delete^l, `set^l }
］なる演算は，可書~maplike~ifc上にも許容され、その場合，~ES言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Note: Operations named “clear”, “delete”, or “set” are allowed on read–write maplike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p>

<p>
~maplike~ifc %I に対しては、［
%I, および %I の`被継承~ifc$
］に［
`可反復~宣言$, 別の`~maplike 宣言$, `~setlike 宣言$
］が宣言されていては~MUST_NOT。
◎
An interface must not have more than one maplike declaration. The inherited interfaces of a maplike interface must not also have a maplike declaration. A maplike interface and its inherited interfaces must not have an iterable declaration or setlike declaration.
</p>

<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteMaplike
MaplikeRest
</div>

<p>
`~maplike 宣言$に適用できる`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to maplike declarations.
</p>

<p class="issue">
例を追加する。
◎
Add example.
</p>


			</section>
			<section id="idl-setlike" class="L2">
<h4 title="Setlike declarations">2.4.9. ~setlike 宣言</h4>

<p>
~ifcは
`~setlike@
になるように宣言できる。
そのためには、`~ifc$の本体にて
`~setlike 宣言@
（
`ReadWriteSetlike$g ／
`readonly^sym `SetlikeRest$g
いずれかに合致）を利用する。
◎
An interface can be declared to be setlike by using a setlike declaration (matching ReadWriteSetlike or readonly SetlikeRest) in the body of the interface.
</p>

<pre class="syntax">
interface `interface_identifier^i {
  readonly setlike&lt;`type^i&gt;;
  setlike&lt;`type^i&gt;;
};
</pre>

<p>
~setlikeになるように宣言された~ifcを実装する~objは、その一連の［
`~set~entry@
と呼ばれる~value
］からなる，有順序~listを表現する。
~valueに利用される型は、~setlike 宣言の山括弧の中で与えられる。
それらの~valueは一意になることが要求される。
◎
Objects implementing an interface that is declared to be setlike represent an ordered list of values known as its set entries. The type of the values is given in the angle brackets of the setlike declaration. Values are required to be unique.
</p>

<p>
`~setlike$ ~ifcを実装している~objの`~set~entry$の~listは、~objの作成~時には空である。
~ifcに付随している注釈文は、~objの一連の`~set~entry$が どう変化するかを述べ得る。
◎
The set entries of an object implementing a setlike interface is empty at the of the object’s creation. Prose accompanying the interface can describe how the set entries of an object change.
</p>

<p>
~setlike~ifcは、一連の~set~entryを照会するための，言語束縛に適切な~APIを~supportする。
`readonly^c ~keywordが利用されなかった場合†、~set~entryを改変するための API も~supportする。
【† 以下， “可書~setlike” とも記される】
◎
Setlike interfaces support an API for querying the set entries appropriate for the language binding. If the readonly keyword is not used, then it also supports an API for modifying the set entries.
</p>

<p class="note">注記：
~ES言語束縛においては、一連の~set~entryとやりとりするための~APIは，
~ESにて可用な `Set$t ~objに類似する。
`readonly^c ~keywordが利用された場合、それは［
`entries^l, `forEach^l, `has^l, `keys^l, `values^l, `iterator$jS
］~meth, および `size^l 取得子を含む。
可書~setlikeに対しては、更に［
`add^l, `clear^l, `delete^l
］~methも含む。
◎
Note: In the ECMAScript language binding, the API for interacting with the set entries is similar to that available on ECMAScript Set objects. If the readonly keyword is used, this includes “entries”, “forEach”, “has”, “keys”, “values”, @@iterator methods and a “size” getter. For read–write setlikes, it also includes “add”, “clear”, and “delete” methods.
</p>

<p>
［
~setlike~ifc, および
その`被継承~ifc$
］の`~ifc~mb$の名前は［
`entries^l ／ `forEach^l ／ `has^l ／ `keys^l ／ `size^l ／ `values^l
］にされては~MUST_NOT。
［
可書~setlike~ifc, および
その`被継承~ifc$
］の［
`属性$, `定数$
］の名前は［
`add^l ／ `clear^l ／ `delete^l
］にされては~MUST_NOT。
◎
Setlike interfaces must not have any interface members named “entries”, “forEach”, “has”, “keys”, “size”, or “values”, or have any inherited interfaces that have members with these names. Read–write setlike interfaces must not have any attributes or constants named “add”, “clear”, or “delete”, or have any inherited interfaces that have attributes or constants with these names.
</p>

<p class="note">注記：
名前［
`add^l／`clear^l／`delete^l
］の演算は，可書~setlike~ifc上にも許容され、その場合，~ES言語束縛においては，その~methの既定の実装は `~ifc原型~obj$に追加されなくなる。
これにより、これらの演算の既定の挙動を上書きできるようになる。
◎
Note: Operations named “add”, “clear”, or “delete” are allowed on read–write setlike interfaces and will prevent the default implementation of these methods being added to the interface prototype object in the ECMAScript language binding. This allows the default behavior of these operations to be overridden.
</p>

<p>
~setlike~ifc %I に対しては、［
%I, および %I の`被継承~ifc$
］に［
`可反復~宣言$, `~maplike 宣言$, 別の`~setlike 宣言$
］が宣言されていては~MUST_NOT。
◎
An interface must not have more than one setlike declaration. The inherited interfaces of a setlike interface must not also have a setlike declaration. A setlike interface and its inherited interfaces must not have an iterable declaration or maplike declaration.
</p>

<div class="grammar">
ReadOnlyMember
ReadOnlyMemberRest
ReadWriteSetlike
SetlikeRest
</div>

<p>
`~setlike 宣言$に適用できる`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to setlike declarations.
</p>

<p class="issue">
例を追加する。
◎
Add example.
</p>


			</section>
		</section>
		<section id="idl-namespaces" class="L2">
<h3 title="Namespaces">2.5. ~ns</h3>

<p>
`~ns@
（ namespace ）は、いくつかの挙動が結付けられた 大域~singletonを宣言する，`定義$（ `Namespace$g に合致）である。
◎
A namespace is a definition (matching Namespace) that declares a global singleton with associated behaviors.
</p>

<p class="trans-note">【
すなわち、~instanceは 1 個しか存在し得ない（かつ，その 1 個は常に存在する）ような~ifcのようなものと捉えればよいであろう。
】</p>


<pre class="syntax">
namespace `identifier^i {
  /* namespace_members... */
};
</pre>

<p>
`~ns$は、その宣言を成す波括弧の合間に現れる［
`正則~演算$, `正則~属性$
］の集合（ `NamespaceMembers$g に合致）の仕様である
— これらの［
演算／属性
］~mbは、
`~ns~mb@
と称され，~nsの中に梱包された挙動を述べる。
◎
A namespace is a specification of a set of namespace members (matching NamespaceMembers), which are the regular operations and read only regular attributes that appear between the braces in the namespace declaration. These operations and attributes describe the behaviors packaged into the namespace.
</p>



<p>
~ifcと同様、~nsに対する~IDLは、
`部分的~ns定義@
（ `partial^sym `Namespace$g に合致）を利用して，複数の部分に分割できる。
部分的~ns定義の`識別子$は、その~ns定義の識別子と同じで~MUST。
それぞれの部分的~nsに現れる，すべての~mbは、その~ns自身の~mbであるものと見なされる。
◎
As with interfaces, the IDL for namespaces can be split into multiple parts by using partial namespace definitions (matching partial Namespace). The identifier of a partial namespace definition must be the same as the identifier of a namespace definition. All of the members that appear on each of the partial namespace definitions are considered to be members of the namespace itself.
</p>



<pre class="syntax">
namespace `SomeNamespace^mk {
  /* namespace_members... */
};

partial namespace `SomeNamespace^mk {
  /* namespace_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義と同様に、部分的~ns定義に意図される用途は、~nsの定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助することである。
◎
Note: As with partial interface definitions, partial namespace definitions are intended for use as a specification editorial aide, allowing the definition of a namespace to be separated over more than one section of the document, and sometimes multiple documents.
</p>


<p><!-- copy* -->
~mbたちが現れる順序は、
<a href="#es-namespaces">~ES言語束縛</a>
における~prop列挙に，有意になる。
◎
The order that members appear in has significance for property enumeration in the ECMAScript binding.
</p>

<p>
~ifcや辞書と違って、~nsは型を作成しないことに注意。
◎
Note that unlike interfaces or dictionaries, namespaces do not create types.
</p>

<p>
この仕様に定義される拡張属性のうち，~nsに適用できるのは
`Exposed$x, `SecureContext$x
に限られる。
◎
Of the extended attributes defined in this specification, only the [Exposed] and [SecureContext] extended attributes are applicable to namespaces.
</p>

<div class="grammar">
Partial
PartialDefinition
Namespace
NamespaceMembers
NamespaceMember
</div>

<div class="example">

<p>
次の`~IDL片$は、`~ns$を定義する：
◎
The following IDL fragment defines an namespace.
</p>

<pre class="webidl">namespace VectorUtils {
  readonly attribute Vector unit;
  double dotProduct(Vector %x, Vector %y);
  Vector crossProduct(Vector %x, Vector %y);
};
</pre>

<p>
~ES実装は、（原型 `ObjectPrototype$jI を伴う）単純~objであった名前 `VectorUtils^c の大域~propを，宣言された各［
演算に対する列挙可能な~data~prop ／
属性に対する列挙可能な取得-のみの~accessor
］たちで公開することになる：
◎
An ECMAScript implementation would then expose a global property named VectorUtils which was a simple object (with prototype %ObjectPrototype%) with enumerable data properties for each declared operation, and enumerable get-only accessors for each declared attribute:
</p>



<pre class="es-code">
Object.getPrototypeOf(VectorUtils);  /* <span class="comment">
`Object.prototype^c に評価される。
◎
Evaluates to Object.prototype.
</span> */
Object.keys(VectorUtils);            /* <span class="comment">
<samp>[`dotProduct^l, `crossProduct^l]</samp> に評価される。
◎
Evaluates to [&quot;dotProduct&quot;, &quot;crossProduct&quot;].
</span> */
Object.getOwnPropertyDescriptor(VectorUtils, "dotProduct"); /*
<span class="comment">
<samp>{ value: &lt;ある関数&gt;, enumerable: true,  configurable: true, writable: true }</samp>
に評価される。
◎
Evaluates to { value: &lt;a function&gt;, enumerable: true, configurable: true, writable: true }.
</span> */
Object.getOwnPropertyDescriptor(VectorUtils, "unit");        /*
<span class="comment">
<samp>{ get: &lt;ある関数&gt;, enumerable: true, configurable: true }</samp>
に評価される。
◎
Evaluates to { get: &lt;a function&gt;, enumerable: true, configurable: true }.
</span> */
</pre>
</div>

		</section>
		<section id="idl-dictionaries">
<h3 title="Dictionaries">2.6. 辞書</h3>

<p>
`辞書@
（ dictionary ）は、［
有順序かつ固定的な，一連の［
`辞書~mb@
と呼ばれる`~entry$
］からなる`有順序~map$~data型
］を定義するために利用される，`定義$（ `Dictionary$g に合致）である。
各`~entry$の`~key$は文字列であり，その`値$は定義の中で指定される特定0の型に属する。
◎
A dictionary is a definition (matching Dictionary) used to define an ordered map data type with a fixed, ordered set of entries, termed dictionary members, where keys are strings and values are of a particular type specified in the definition.
</p>

<pre class="syntax">
dictionary `identifier^i {
  /* dictionary_members... */
};
</pre>

<p>
辞書は常に値渡しである。
辞書が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に辞書が渡された際に，その辞書への参照が~objに保有されることはない。
同様に，~platform~objから返されるどの辞書も複製であり、それに対する改変は~platform~objからは可視でないことになる。
◎
Dictionaries are always passed by value. In language bindings where a dictionary is represented by an object of some kind, passing a dictionary to a platform object will not result in a reference to the dictionary being kept by that object. Similarly, any dictionary returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>
<p>
辞書は 別の辞書を
`継承-@diC
するように定義できる。
辞書の識別子に~colonと`識別子$が後続する場合、後者の識別子が，継承される辞書を識別する。
この識別子は辞書を識別するもので~MUST。
◎
A dictionary can be defined to inherit from another dictionary. If the identifier of the dictionary is followed by a colon and a identifier, then that identifier identifies the inherited dictionary. The identifier must identify a dictionary.
</p>

<p>
辞書は、その継承~階層が循環するように宣言されては~MUST_NOT。
すなわち、辞書 %A は自身を継承することも,
%A を継承する別の辞書 %B を継承することもできない，等々。
◎
A dictionary must not be declared such that its inheritance hierarchy has a cycle. That is, a dictionary A cannot inherit from itself, nor can it inherit from another dictionary B that inherits from A, and so on.
</p>

<pre class="syntax">
dictionary `Base^mk {
  /* dictionary_members... */
};

dictionary `Derived^i : `Base^mk {
  /* dictionary_members... */
};
</pre>

<p>
所与の辞書~型 %D の
`被継承~辞書@
とは、
%D が直接的にまたは間接的に継承するすべての辞書の集合である。
%D が他の辞書を`継承-$diCしない場合、その集合は空である。
そうでない場合、その集合は %D が`継承-$diCする~ifc %E と %E の`被継承~辞書$すべてを含む。
◎
The inherited dictionaries of a given dictionary D is the set of all dictionaries that D inherits from, directly or indirectly. If D does not inherit from another dictionary, then the set is empty. Otherwise, the set includes the dictionary E that D inherits from and all of E’s inherited dictionaries.
</p>

<p>
型 %D の辞書~値 %d は、
%D 上および %D の`被継承~辞書$上で定義される辞書~mbに対応する~key-valueを持ち得る。
%d 上における，各~辞書~mbの存在tは、それが %D において`必須~辞書~mb$であると指定されていない限り，随意である。
%d 上に指定されているならば，その辞書~mbは
`在する@
（ present ）といい、そうでなければ
<dfn>`不在$</dfn>
という。
辞書~mbは，随意で
`既定~値@diC
も持ち得る。
それは、 %d 上にその~mb値が指定されずに %d が`~platform~obj$に渡された際に，辞書~mbに利用される値になる。
既定~値を伴う辞書~mbは常に在するものと見なされる。
◎
A dictionary value of type D can have key–value pairs corresponding to the dictionary members defined on D and on any of D’s inherited dictionaries. On a given dictionary value, the presence of each dictionary member is optional, unless that member is specified as required. When specified in the dictionary value, a dictionary member is said to be present, otherwise it is not present. Dictionary members can also optionally have a default value, which is the value to use for the dictionary member when passing a value to a platform object that does not have a specified value. Dictionary members with default values are always considered to be present.
</p>

<p class="note">注記：
~ES言語束縛における `undefined^jv 値は，`不在$と扱われ、適用できる所では`既定~値$diCが用いられることになる。
◎
In the ECMAScript binding, a value of undefined is treated as not present, or will trigger the default value where applicable.
</p>

<p>
文字列を`~key$とする`有順序~map$は、次を満たすならば，暗黙的に特定の辞書 %D の辞書~値として扱える：
すべての`~entry$は、正しい順序において %D の`辞書~mb$に対応していて,
正しい型を伴い，
%D のどの`必須~辞書~mb$に対しても，適切な~entryがあるならば。
◎
An ordered map with string keys can be implicitly treated as a dictionary value of a specific dictionary D if all of its entries correspond to dictionary members, in the correct order and with the correct types, and with appropriate entries for any required dictionary members.
</p>

<p class="advisement">
演算~引数の`既定~値$と同様に、
`boolean$T 型の`辞書~mb$に対しては、`既定~値$diCとして `true^V を利用しないことを強く勧める。
さもなければ、 `undefined^jv に既定の変換（すなわち， `false^V ）が利用されると期待する作者たちを惑わすことになるので。
◎
As with operation argument default values, it is strongly suggested not to use true as the default value for boolean-typed dictionary members, as this can be confusing for authors who might otherwise expect the default conversion of undefined to be used (i.e., false).
</p>


<p>
各`辞書~mb$（ `DictionaryMember$g に合致）は、型（ `Type$g に合致）および, 後続の（ `identifier$g ~tokで与えられる）`識別子$により指定され、その識別子が~key-valueの~key名になる。
`Type$g が `?^c 付きの`識別子$である場合、その識別子は［
~ifc, `列挙$, `呼戻~関数$, `~typedef$
］のいずれかに識別され~MUST。
辞書~mb型が `?^c 付きでない識別子である場合、その識別子は，それらの定義, または`辞書$に識別され~MUST。
◎
Each dictionary member (matching DictionaryMember) is specified as a type (matching Type) followed by an identifier (given by an identifier token following the type). The identifier is the key name of the key–value pair. If the Type is an identifier followed by ?, then the identifier must identify an interface, enumeration, callback function or typedef. If the dictionary member type is an identifier not followed by ?, then the identifier must identify any one of those definitions or a dictionary.
</p>

<p>
`辞書~mb$の型が`~typedef$の解決-後に`~nullable型$になる場合、その`内縁~型$は，`辞書~型$になっては~MUST_NOT。
◎
If the type of the dictionary member, after resolving typedefs, is a nullable type, its inner type must not be a dictionary type.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i;
};
</pre>

<p>
識別子に
`U+003D EQUALS SIGN ("=")^char
と値（ `DefaultValue$g に合致）が後続している場合、それが辞書~mbの`既定~値$diCを与える。
◎
If the identifier is followed by a U+003D EQUALS SIGN ("=") and a value (matching DefaultValue), then that gives the dictionary member its default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  `type^i `identifier^i = "value";
};
</pre>

<p>
`既定~値$diCに［
`定数~tok$ ／ `string$g ~tok ／ 2 個の~tok並び `[]^c
］が利用された場合、
`演算$の引数の`既定~値$
のときと同じ仕方で解釈される。
◎
When a boolean literal token (true or false), the null token, an integer token, a float token, one of the three special floating point literal values (Infinity, -Infinity or NaN), a string token or the two token sequence [] used as the default value, it is interpreted in the same way as for an operation’s optional argument default value.
</p>

<p>
`辞書~mb$の型が`列挙$である場合、その`既定~値$diCに指定される値は，その`列挙~値$のいずれかで~MUST。
◎
If the type of the dictionary member is an enumeration, then its default value if specified must be one of the enumeration’s values.
</p>


<p>
辞書~mbの型の前に ~keyword `required^c が置かれた場合、その~mbは
`必須~辞書~mb@
と見なされ，辞書~上に`在する$ことが要求される。
`必須~辞書~mb$は、`既定~値$を持っては~MUST_NOT。
◎
If the type of the dictionary member is preceded by the required keyword, the member is considered a required dictionary member and must be present on the dictionary. A required dictionary member must not have a default value.
</p>

<pre class="syntax">
dictionary `identifier^i {
  required `type^i `identifier^i;
};
</pre>

<p>
辞書~mbの型は，その辞書を <em>内包-</em> しては~MUST_NOT。
次のいずれかを満たす型 %T は、辞書~型 %D を内包するものとされる：
◎
The type of a dictionary member must not include the dictionary it appears on. A type includes a dictionary D if at least one of the following is true:
</p>

<ul>
	<li>
%T は %D である
◎
the type is D
</li>
	<li>
%T は %D を`継承-$diCしている辞書である
◎
the type is a dictionary that inherits from D
</li>
	<li>
%T は`~nullable型$であり，その`内縁~型$は %D を内包している
◎
the type is a nullable type whose inner type includes D
</li>
	<li>
%T は［
`連列~型$, または`凍結~配列~型$
］であり，その要素~型は %D を内包している
◎
the type is a sequence type or frozen array whose element type includes D
</li>
	<li>
%T は`共用体~型$であり，そのいずれかの`~mb型$は %D を内包している
◎
the type is a union type, one of whose member types includes D
</li>
	<li>
%T は辞書であり，そのいずれかの［
自前の, または 継承している
］~mbの型は %D を内包している
◎
the type is a dictionary, one of whose members or inherited members has a type that includes D
</li>
	<li>
%T は `~record_KV$ であり， %V は %D を内包している
◎
the type is record&lt;K, V&gt; where V includes D
</li>
</ul>


<p>
~ifcと同様に、辞書~用の~IDLは
`部分的~辞書~定義@
（ `partial^sym `Dictionary$g に合致）を利用して複数の部分に分割できる。
部分的~辞書~定義の`識別子$は、当の辞書~定義の識別子と同じで~MUST。
それぞれの部分的~辞書~定義に現れるすべての~mbは、辞書~自身の~mbと見なされる。
◎
As with interfaces, the IDL for dictionaries can be split into multiple parts by using partial dictionary definitions (matching partial Dictionary). The identifier of a partial dictionary definition must be the same as the identifier of a dictionary definition. All of the members that appear on each of the partial dictionary definitions are considered to be members of the dictionary itself.
</p>

<pre class="syntax">
dictionary `SomeDictionary^mk {
  /* dictionary_members... */
};

partial dictionary `SomeDictionary^mk {
  /* dictionary_members... */
};
</pre>

<p class="note">注記：
部分的~ifc定義と同様に、部分的~辞書~定義に意図される用途は、辞書の定義を
文書の複数の節, ときには複数の文書に分離できるようにして，仕様の編集を補助することである。
◎
Note: As with partial interface definitions, partial dictionary definitions are intended for use as a specification editorial aide, allowing the definition of an interface to be separated over more than one section of the document, and sometimes multiple documents.
</p>

<p id="_order-of-dict-members_">
所与の辞書~上の`辞書~mb$は、継承された辞書~mbが 継承していない~mbより前に位置するように順序付けられる。
同じ辞書~定義~上の（部分的~辞書~定義もすべて含めた）すべての辞書~mbは、それらの識別子を構成する~Unicode符号位置により，辞書式に順序付けられる。
◎
The order of the dictionary members on a given dictionary is such that inherited dictionary members are ordered before non-inherited members, and the dictionary members on the one dictionary definition (including any partial dictionary definitions) are ordered lexicographically by the Unicode codepoints that comprise their identifiers.
</p>

<div class="note">
<p>
例えば，次の定義では：
◎
For example, with the following definitions:
</p>

<pre class="webidl">
dictionary B : A {
  long b;
  long a;
};

dictionary A {
  long c;
  long g;
};

dictionary C : B {
  long e;
  long f;
};

partial dictionary A {
  long h;
  long d;
};
</pre>

<p>
型 `C^T の辞書~値の `辞書~mb$の順序は［
`c^M, `d^M, `g^M, `h^M, `a^M, `b^M, `e^M, `f^M
］になる。
◎
the order of the dictionary members of a dictionary value of type C is c, d, g, h, a, b, e, f.
</p>

<p>
辞書の~mbは順序付けられることが要求される。
一部の言語束縛においては、~platform~objに辞書~値を渡した際に観測される挙動が，辞書~mbを取りに行く順序に依存するので。
例えば，次の追加の~ifc：
◎
Dictionaries are required to have their members ordered because in some language bindings the behavior observed when passing a dictionary value to a platform object depends on the order the dictionary members are fetched. For example, consider the following additional interface:
</p>

<pre class="webidl">
interface Something {
  void f(A %a);
};
</pre>

<p>
および，次の~ES~codeを考えるとき：
◎
and this ECMAScript code:
</p>

<pre class="es-code">
var %something = getSomething();  /* <span class="comment">
`Something^T の~instanceを取得する。
◎
Get an instance of Something.
</span> */
var %x = 0;

var %dict = { };
Object.defineProperty(dict, "d", { get: function() { return ++%x; } });
Object.defineProperty(dict, "c", { get: function() { return ++%x; } });

%something.f(%dict);
</pre>

<p>
辞書~mbを取りに行く順序が、それらがとることになる値を決定する。
`A^T における順序は， `c^M の次が `d^M と定義されるので、
`c^M に対する値は 1 になり, `d^M に対する値は 2 になる。
◎
The order that the dictionary members are fetched in determines what values they will be taken to have. Since the order for A is defined to be c then d, the value for c will be 1 and the value for d will be 2.
</p>
</div>

<p>
辞書~mbの識別子は、その辞書~上, またはその辞書の`被継承~辞書$上で定義される，別の辞書~mbの識別子と同じになっては~MUST_NOT。
◎
The identifier of a dictionary member must not be the same as that of another dictionary member defined on the dictionary or on that dictionary’s inherited dictionaries.
</p>

<p>
辞書は［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Dictionaries must not be used as the type of an attribute or constant.
</p>

<p>
`辞書$には、適用できる`拡張属性$はない。
◎
No extended attributes are applicable to dictionaries.
</p>

<div class="grammar">
Partial
PartialDefinition
Dictionary
DictionaryMembers
DictionaryMember
DictionaryMemberRest
PartialDictionary
Default
DefaultValue
Inheritance
</div>

<div class="example">
<p>
辞書~型の利用の一つは、`演算$に対し、
呼出し~codeの所で指定される順序に制約を課すことなく，随意~引数をいくつでも与えられるようにすることである。
例えば，次の`~IDL片$を考える：
◎
One use of dictionary types is to allow a number of optional arguments to an operation without being constrained as to the order they are specified at the call site. For example, consider the following IDL fragment:
</p>

<pre class="webidl">
[Constructor]
interface Point {
  attribute double x;
  attribute double y;
};

dictionary PaintOptions {
  DOMString? fillPattern = "black";
  DOMString? strokePattern = null;
  Point position;
};

interface GraphicsContext {
  void drawRectangle(
    double %width, double %height,
    optional PaintOptions %options
  );
};
</pre>

<p>
この~IDLの~ES実装においては、随意の
`PaintOptions^T 辞書
により， `Object^jt を渡すことができる：
◎
In an ECMAScript implementation of the IDL, an Object can be passed in for the optional PaintOptions dictionary:
</p>

<pre class="es-code">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する。
◎
Get an instance of GraphicsContext.
</span> */
var %ctx = getGraphicsContext();

/* <span class="comment">
矩形を描く。
◎
Draw a rectangle.
</span> */
%ctx.drawRectangle(
    300, 200,
    { fillPattern: "red", position: new Point(10, 10) }
);
</pre>

<p>
`fillPattern^M と `strokePattern^M のいずれにも`既定~値$diCが与えられているので、 `drawRectangle^M の定義においては，それらが省略された場合でも所与の既定~値を持つと見做すことができ、それらが`不在$の場合に取扱う方法についての明示的な言及が不要になる。
◎
Both fillPattern and strokePattern are given default values, so if they are omitted, the definition of drawRectangle can assume that they have the given default values and not include explicit wording to handle their non-presence.
</p>
</div>
		</section>
		<section id="idl-exceptions">
<h3 title="Exceptions">2.7. 例外</h3>

<p>
`例外@
とは、~errorを表現する~objの型であり，実装により［
投出される, または first ~class値として扱われる
］ものである。
~Web~IDLでは，例外を定義することは許容されないが、代わりに
仕様が参照し，その演算, 属性, 等々の定義にて投出できるような，いくつもの定義済み例外がある。
◎
An exception is a type of object that represents an error and which can be thrown or treated as a first class value by implementations. Web IDL does not allow exceptions to be defined, but instead has a number of pre-defined exceptions that specifications can reference and throw in their definition of operations, attributes, and so on.＼
</p>

<div class="p">
<p>
各 例外は、次のものを持つ：
</p>

<dl>
	<dt>`~error名@</dt>
	<dd>
`DOMString$T による，例外が表現する~errorの型
</dd>

	<dt>`~message@（随意）</dt>
	<dd>
~errorの詳細を人が読める~~形で提供する，~UAにより定義される値
</dd>
</dl>
◎
Exceptions have an error name, a DOMString, which is the type of error the exception represents, and a message, which is an optional, user agent-defined value that provides human readable details of the error.
</div>


<p>
仕様にて投出するために可用な例外には 2 つの種類がある。
まず、次のいずれかの型として識別される
`単純例外@
：
◎
There are two kinds of exceptions available to be thrown from specifications. The first is a simple exception, which is identified by one of the following types:
</p>

<ul ><li>`EvalError@jE
</li><li>`RangeError@jE
</li><li>`ReferenceError@jE
</li><li>`TypeError@jE
</li><li>`URIError@jE
</li></ul>

<p>
これらは、~ES`~error~obj$に対応する（ただし， `SyntaxError^jE, `Error$t は除く — 順に ~ES構文解析器~用, 作者~用に予約されているので、~~意図的に除かれている）。
各 `単純例外$の意味は、~ES仕様における対応する~error~objに合致する。
◎
These correspond to all of the ECMAScript error objects (apart from SyntaxError and Error, which are deliberately omitted as they are reserved for use by the ECMAScript parser and by authors, respectively). The meaning of each simple exception matches its corresponding error object in the ECMAScript specification.
</p>


<p>
もう一種の例外は `DOMException$T である
— それは，歴史的に DOM にて定義された例外との互換性をとるための例外であり、名前と整数~code（後者は随意）を，~encapsulateする。
◎
The second kind of exception is a DOMException, which is an exception that encapsulates a name and an optional integer code, for compatibility with historically defined exceptions in the DOM.
</p>

<p>
`単純例外$に対しては、`~error名$がその例外の型になる。
`DOMException$T の`~error名$は、後に示す`~error名~一覧$に挙げられている いずれかの名前で~MUST。
その一覧には、その~error名に対する `DOMException$T の整数~codeも（もし在れば）指示される。
◎
For simple exceptions, the error name is the type of the exception. For a DOMException, the error name must be one of the names listed in the error names table below. The table also indicates the DOMException's integer code for that error name, if it has one.
</p>

<p>
例外~objを指すためには、 2 種の型
`DOMException$T, `Error$T
を利用できる。
後者は、`単純例外$と `DOMException$T の両者を含む総称である。
これにより、`演算$の`返値型$を `DOMException$T に宣言したり，`属性$の型を `Error$T 型にすることも可能になる。
◎
There are two types that can be used to refer to exception objects: DOMException and Error, where the latter encompasses simple exceptions and DOMException. This allows for example an operation to be declared to have a DOMException return type or an attribute to be of type Error.
</p>

<p>
例外を
`作成する@
よう記すときは、`単純例外$に対しては その`~error名$，
 `DOMException$T に対しては `~error名$に `DOMException$T も加えて表記する。
例外は、それを`作成する$ために要求される詳細を提供して
`投出する@
よう表記することもできる。
◎
Simple exceptions can be created by providing their error name. A DOMException can be created by providing its error name followed by DOMException. Exceptions can also be thrown, by providing the same details required to create one.
</p>

<p>
例外を作成したり, 作成した例外を投出した結果の挙動は、言語束縛に特有になる。
◎
The resulting behavior from creating and throwing an exception is language binding-specific.
</p>

<p class="note">注記：
~ES言語束縛の場合にどうなるかについては、
`es-creating-throwing-exceptions$sec
を見よ。
◎
Note: See §3.12.3 Creating and throwing exceptions for details on what creating and throwing an exception entails in the ECMAScript language binding.
</p>

<div class="example">

<p>
例外を作成して投出する言い回しの用例をここに示す†。
名前 `TypeError^jE の新たな `単純例外$を投出するときは：
◎
Here is are some examples of wording to use to create and throw exceptions. To throw a new simple exception named TypeError:
</p>

<blockquote>
Throw a `TypeError^jE.
</blockquote>

<p>
`~error名$ `NotAllowedError$E の新たな `DOMException$T を投出するときは：
◎
To throw a new DOMException with error name "NotAllowedError":
</p>

<blockquote>
Throw an "`NotAllowedError^E" `DOMException^T.
</blockquote>

<p>
`~error名$ "`SyntaxError$E" の新たな `DOMException$T を作成するときは：
◎
To create a new DOMException with error name "SyntaxError":
</p>

<blockquote>
Let %object be a newly created "`SyntaxError^E" `DOMException^T.
</blockquote>

</div>

<div class="trans-note">
<p>【†
このサイトの和訳全般においては、次のように例外~名の引用符や “`DOMException^T” を省略して表記している：
</p>

<ul><li>~throwTypeError
</li><li>`~THROW$ `NotAllowedError^E
</li><li>%object ~LET 新たな `SyntaxError^E 例外
</li></ul>

<p>
投出の表記は，`単純例外$も `DOMException$T も同じ表記になっているが、単純例外は一握りしかない上、これらが同じ名前を共有することも，まずないと考えられるので（詳細は、~SYMBOL_DEF_REFを~~参照されたし）。
】</p>

</div>


			<section id="idl-DOMException-error-names">
<h4 title="Error names">2.7.1. ~error名</h4>

<p>
下の
`~error名~一覧@
は、 `DOMException$T に許容されるすべての~error名, ~~説明, および 旧来の code 名とその値の一覧である。
◎
The error names table below lists all the allowed error names for DOMException, a description, and legacy code values.
</p>

<p class="advisement">
“非推奨” と記されている `DOMException$T 名は、旧来の目的~用に保たれてはいるが，利用しないことが奨励される。
◎
The DOMException names marked as deprecated are kept for legacy purposes but their usage is discouraged.
</p>

<p class="note">注記：
ここに挙げられていない~error名があれば、この仕様の冒頭に指示したように, ~bugを提出されるよう願う。
間もなく解消に向けて取組まれることになる。
Thanks! 
◎
Note: If an error name is not listed here, please file a bug as indicated at the top of this specification and it will be addressed shortly. Thanks!
</p>


<p class="note">注記：
ここに定義される `SyntaxError$E `DOMException$T 例外と ~ESの `SyntaxError$jE とを混同しないように。
前者は
— 例えば選択子を構文解析するときなど —
~Web~APIにおける構文解析-時の~errorを報告するために利用される一方で、後者は~ES構文解析器~用に予約されている。
これをより一義化し易くするため、単に `SyntaxError$E を用いずに，常に［
"`SyntaxError$E" `DOMException$T
］と表記して `DOMException$T を指す方が好ましい。
【が，上述したように、他の~Web仕様の和訳では， `DOMException^T は省略している — ~ES `SyntaxError^jE は，それらの仕様には現れないので。】
`DOM$r
◎
Note: Don’t confuse the "SyntaxError" DOMException defined here with ECMAScript’s SyntaxError. "SyntaxError" DOMException is used to report parsing errors in web APIs, for example when parsing selectors, while the ECMAScript SyntaxError is reserved for the ECMAScript parser. To help disambiguate this further, always favor the "SyntaxError" DOMException notation over just using SyntaxError to refer to the DOMException. [DOM]
</p>

<div style="overflow:auto;"><table id="error-names">
<thead><tr><th>名前◎ Name
<th style="min-width:12em;">~~説明◎ Description
<th>
旧来の~code名（括弧内は数値）
◎
Legacy code name and value
</thead>

<tbody><tr class="deprecated"><td>`IndexSizeError@E
<td>
非推奨。
`RangeError$jE を利用すること。
◎
Deprecated. Use RangeError instead.
<td>`INDEX_SIZE_ERR@Ec (1)

<tr class="deprecated"><td>`DOMStringSizeError@E
<td>
非推奨。
`RangeError$jE を利用すること。
◎
Deprecated. Use RangeError instead.
<td>`DOMSTRING_SIZE_ERR@Ec (2)

<tr><td>`HierarchyRequestError@E
<td>
演算から不正な~node木が得られることになる。
◎
The operation would yield an incorrect node tree.
<td>`HIERARCHY_REQUEST_ERR@Ec (3)

<tr><td>`WrongDocumentError@E
<td>
~objが属している文書は誤っている。
◎
The object is in the wrong document.
<td>`WRONG_DOCUMENT_ERR@Ec (4)

<tr><td>`InvalidCharacterError@E
<td>
文字列に妥当でない文字が含まれている。
◎
The string contains invalid characters.
<td>`INVALID_CHARACTER_ERR@Ec (5)

<tr class="deprecated"><td>`NoDataAllowedError@E
<td>
非推奨。
◎
Deprecated.
<td>`NO_DATA_ALLOWED_ERR@Ec (6)

<tr><td>`NoModificationAllowedError@E
<td>
~objは改変できない。
◎
The object can not be modified.
<td>`NO_MODIFICATION_ALLOWED_ERR@Ec (7)

<tr><td>`NotFoundError@E
<td>
~objは見出せなかった。
◎
The object can not be found here.
<td>`NOT_FOUND_ERR@Ec (8)

<tr><td>`NotSupportedError@E
<td>
演算は~supportされていない。
◎
The operation is not supported.
<td>`NOT_SUPPORTED_ERR@Ec (9)

<tr><td>`InUseAttributeError@E
<td>
属性は利用~中にある。
◎
The attribute is in use.
<td>`INUSE_ATTRIBUTE_ERR@Ec (10)

<tr><td>`InvalidStateError@E
<td>
~objは不正な状態にある。
◎
The object is in an invalid state.
<td>`INVALID_STATE_ERR@Ec (11)

<tr><td>`SyntaxError@E
<td>
文字列は期待される~patternに合致していない。
◎
The string did not match the expected pattern.
<td>`SYNTAX_ERR@Ec (12)

<tr><td>`InvalidModificationError@E
<td>
~objはこの仕方では改変できない。
◎
The object can not be modified in this way.
<td>`INVALID_MODIFICATION_ERR@Ec (13)

<tr><td>`NamespaceError@E
<td>
演算は <cite>Namespaces in XML</cite> において許容されない。
`XML-NAMES$r
◎
The operation is not allowed by Namespaces in XML. [XML-NAMES]
<td>`NAMESPACE_ERR@Ec (14)

<tr class="deprecated"><td>`InvalidAccessError@E
<td>
非推奨。
代わりに、［
妥当でない引数に対しては `TypeError$jE ／
未~supportの演算に対しては `NotSupportedError$E ／
否認された要請に対しては `NotAllowedError$E
］を利用すること。
◎
Deprecated. Use TypeError for invalid arguments, "NotSupportedError" DOMException for unsupported operations, and "NotAllowedError" DOMException for denied requests instead.
<td>`INVALID_ACCESS_ERR@Ec (15)

<tr class="deprecated"><td>`ValidationError@E
<td>
非推奨。
◎
Deprecated.
<td>`VALIDATION_ERR@Ec (16)

<tr class="deprecated"><td>`TypeMismatchError@E
<td>
非推奨。
代わりに、 `TypeError$jE を利用すること。
◎
Deprecated. Use TypeError instead.
<td>`TYPE_MISMATCH_ERR@Ec (17)

<tr><td>`SecurityError@E
<td>
演算は保安的でない。
◎
The operation is insecure.
<td>`SECURITY_ERR@Ec (18)

<tr><td>`NetworkError@E
<td>
~network~errorが生じた。
◎
A network error occurred.
<td>`NETWORK_ERR@Ec (19)

<tr><td>`AbortError@E
<td>
演算は中止された。
◎
The operation was aborted.
<td>`ABORT_ERR@Ec (20)

<tr><td>`URLMismatchError@E
<td>
所与の URL は他方の URLに合致していない。
◎
The given URL does not match another URL.
<td>`URL_MISMATCH_ERR@Ec (21)
 

<tr><td>`QuotaExceededError@E
<td>
quota の上限を超えた。
◎
The quota has been exceeded.
<td>`QUOTA_EXCEEDED_ERR@Ec (22)

<tr><td>`TimeoutError@E
<td>
演算は時間切れになった。
◎
The operation timed out.
<td>`TIMEOUT_ERR@Ec (23)

<tr><td>`InvalidNodeTypeError@E
<td>
あてがわれた~nodeは不正か, またはこの演算において不正な先祖を持つ。
◎
The supplied node is incorrect or has an incorrect ancestor for this operation.
<td>`INVALID_NODE_TYPE_ERR@Ec (24)

<tr><td>`DataCloneError@E
<td>
~objは~cloneできない。
◎
The object can not be cloned.
<td>`DATA_CLONE_ERR@Ec (25)

<tr><td>`EncodingError@E
<td>
符号化する演算に失敗した（符号化-時, 復号-時とも含め）。
◎
The encoding operation (either encoded or decoding) failed.
<td>—

<tr><td>`NotReadableError@E
<td>
I/O 読み取り演算に失敗した。
◎
The I/O read operation failed.
<td>—


<tr><td>`UnknownError@E
<td>
未知の一時的な事由により，演算に失敗した（例：記憶域を使い切った）。
◎
The operation failed for an unknown transient reason (e.g. out of memory).
<td>—

<tr><td>`ConstraintError@E
<td>
~transactionにおける変異~演算は、拘束を満たせないため，失敗した。
◎
A mutation operation in a transaction failed because a constraint was not satisfied.
<td>—

<tr><td>`DataError@E
<td>
提供された~dataは、必要十分でない。
◎
Provided data is inadequate.
<td>—

<tr><td>`TransactionInactiveError@E
<td>
現在~作動中でない／すでに終わった ~transactionに対し，要請が行われた。
◎
A request was placed against a transaction which is currently not active, or which is finished.
<td>—

<tr><td>`ReadOnlyError@E
<td>
“読み取り専用” （ `readonly^l ~mode）の~transactionにおいて，変異させようとする演算が試みられた。
◎
The mutating operation was attempted in a "readonly" transaction.
<td>—

<tr><td>`VersionError@E
<td>
既存の~versionより低い~versionを利用して~databaseを open しようとした。
◎
An attempt was made to open a database using a lower version than the existing version.
<td>—

<tr><td>`OperationError@E
<td>
演算に特有の事由により，演算に失敗した。
◎
The operation failed for an operation-specific reason.
<td>—

<tr><td>`NotAllowedError@E
<td>
要請された演算は、現在の文脈においては
~UA／~platform
からは
— 場合によっては，利用者が否認したことにより —
許容されない。
◎
The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.
<td>—

</tbody></table></div>


			</section>
		</section>
		<section id="idl-enums">
<h3 title="Enumerations">2.8. 列挙</h3>


<p>
`列挙@
（ enumeration ）は、［
妥当な値の集合が，定義済み文字列の集合になる
］ような型を宣言するために利用される，`定義$（ `Enum$g に合致）である。
`属性$に代入できる／`演算$に渡せる `DOMString$T 値を制約する用途に，列挙を利用できる。
◎
An enumeration is a definition (matching Enum) used to declare a type whose valid values are a set of predefined strings. Enumerations can be used to restrict the possible DOMString values that can be assigned to an attribute or passed to an operation.
</p>

<pre class="syntax">
enum `identifier^i { "enum", "values" /* , ... */ };
</pre>

<p>
一連の
`列挙~値@
は、
`string$g ~literalの~comma区切りの~listとして指定される。
`列挙~値$の~list内に重複があっては~MUST_NOT。
◎
The enumeration values are specified as a comma-separated list of string literals. The list of enumeration values must not include duplicates.
</p>

<p class="advisement">
別の命名法を利用する理由が特にない限り、列挙~値は，すべて小文字にすることを強く勧める
— 複数の単語は，~dashで区切るか全く区切らないことにして。
例えば、~objが作成されるべきであることを指示する列挙~値は，
`createobject^l や `create-object^l
などと命名することもできる。
列挙~値の単語を~dashで区切るかどうか決めるときは、類似の他の~APIと一貫するように，関係する列挙~値の利用を考慮すること。
◎
It is strongly suggested that enumeration values be all lowercase, and that multiple words be separated using dashes or not be separated at all, unless there is a specific reason to use another value naming scheme. For example, an enumeration value that indicates an object should be created could be named "createobject" or "create-object". Consider related uses of enumeration values when deciding whether to dash-separate or not separate enumeration value words so that similar APIs are consistent.
</p>

<p>
妥当な列挙~値のいずれでもない文字列~値が，［
列挙~型の`属性$に代入するときや, 列挙~型の`演算$に渡される引数
］に利用されたときの挙動は、言語束縛に特有になる。
◎
The behavior when a string value that is not one a valid enumeration value is used when assigning to an attribute, or passed as an operation argument, whose type is the enumeration, is language binding specific.
</p>

<p class="note">注記：
~ES言語束縛においては、`属性$への妥当でない文字列~値の代入は無視される一方，そのような値を`演算$の引数に渡したときには例外が投出される。
◎
Note: In the ECMAScript binding, assignment of an invalid string value to an attribute is ignored, while passing such a value as an operation argument results in an exception being thrown.
</p>

<p>
`列挙$に適用できる`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to enumerations.
</p>

<div class="grammar">
Enum
EnumValueList
EnumValueListComma
EnumValueListString
</div>


<div class="example">
<p>
次の`~IDL片$は
1 個の`属性$と 1 個の`演算$引数の型として利用される
`列挙$を定義する
◎
The following IDL fragment defines an enumeration that is used as the type of an attribute and an operation argument:
</p>

<pre class="webidl">
enum MealType { "米", "麺", "その他" };

interface Meal {
  attribute MealType type;
  attribute double size;     /* <span class="comment">
グラム~~単位
◎
in grams
</span> */

  void initialize(MealType %type, double %size);
};
</pre>

<p>
~ES実装は、 type ~propに代入され得る, あるいは
`initialize^M 関数に渡され得る文字列を，
`列挙$内にて識別されるものに制約することになる。
◎
An ECMAScript implementation would restrict the strings that can be assigned to the type property or passed to the initializeMeal function to those identified in the enumeration.
</p>

<pre class="es-code">
var %meal = getMeal();          /* <span class="comment">
`Meal^T の~instanceを取得する。
◎
Get an instance of Meal.
</span> */

%meal.initialize("米", 200);    /* <span class="comment">
演算は通常通り呼出される。
◎
Operation invoked as normal.
</span> */

try {
  %meal.initialize("肉", 100);  /* <span class="comment">
`TypeError^jE が投出される。
◎
Throws a TypeError.
</span> */
} catch (%e) {
}

%meal.type = "麺";              /* <span class="comment">
属性は通常通り代入される。
◎
Attribute assigned as normal.
</span> */
%meal.type = "魚";              /* <span class="comment">
属性~代入は無視される。
◎
Attribute assignment ignored.
</span> */
%meal.type == "麺";             /* <span class="comment"
	title="" id="cp-eval-true"
>`true^jv に評価される。
◎
Evaluates to true.
</span> */
</pre>
</div>

		</section>
		<section id="idl-callback-functions">
<h3 title="Callback functions">2.9. 呼戻~関数</h3>

<p class="issue">
“Custom DOM Elements” 仕様からは、`呼戻~関数~型$を，~platform~objから提供される関数に利用することが求められている。
“呼戻~関数” を，両方の目的に利用できることを明らかにするため、単に “関数” と改称するべきだろうか？
◎
The “Custom DOM Elements” spec wants to use callback function types for platform object provided functions. Should we rename “callback functions” to just “functions” to make it clear that they can be used for both purposes?
</p>

<p>
`呼戻~関数@
は、関数~型を宣言するときに利用される，`定義$（ `callback^sym `CallbackRest$g に合致）である。
◎
A callback function is a definition (matching callback CallbackRest) used to declare a function type.
</p>

<pre class="syntax">
callback `identifier^i = `return_type^i (/* arguments... */);
</pre>

<p class="note">注記：
似た命名の`呼戻~ifc$も見よ。
◎
Note: See also the similarly named callback interfaces.
</p>

<p>
等号の左側の`識別子$が
`呼戻~関数$の名前を与える。
等号の右側の［
返値型（ `ReturnType$g に合致）
と［
引数~list（ `ArgumentList$g に合致）
【による一連の型】
］］が，`呼戻~関数~型$の~signatureを与える。
◎
The identifier on the left of the equals sign gives the name of the callback function and the return type and argument list (matching ReturnType and ArgumentList) on the right side of the equals sign gives the signature of the callback function type.
</p>

<p>
`呼戻~関数$は
`定数$の型に利用されては~MUST_NOT。
◎
Callback functions must not be used as the type of a constant.
</p>

<p>
呼戻~関数には、次の拡張属性を適用できる
⇒
`TreatNonObjectAsNull$x
◎
The following extended attribute is applicable to callback functions: [TreatNonObjectAsNull].
</p>

<div class="grammar">
CallbackOrInterfaceOrMixin
CallbackRest
</div>


<div class="example">
<p>
次の`~IDL片$は、演算の完了-時に利用者により定義される関数を呼出す~API用に利用される，`呼戻~関数$を定義する。
◎
The following IDL fragment defines a callback function used for an API that invokes a user-defined function when an operation is complete.
</p>

<pre class="webidl">
callback AsyncOperationCallback = void (DOMString %status);

interface AsyncOperations {
  void performOperation(AsyncOperationCallback %whenFinished);
};
</pre>

<p>
~ES言語束縛においては、`関数~obj$は演算~引数として渡される。
◎
In the ECMAScript language binding, a function object is passed as the operation argument.
</p>

<pre class="es-code">
var %ops = getAsyncOperations();  /* <span class="comment">
`AsyncOperations^T の~instanceを取得する。
◎
Get an instance of AsyncOperations.
</span> */

%ops.performOperation(function(%status) {
  window.alert("Operation finished, status is " + %status + ".");
});
</pre>
</div>
		</section>
		<section id="idl-typedefs">
<h3 title="Typedefs">2.10. ~typedef</h3>


<p>
`~typedef@
は、ある型に対し 新たな名前を宣言するために利用される，`定義$（ `Typedef$g に合致）である。
この新たな名前は、言語束縛からは公開されない。
これはもっぱら，~IDLにおいて型を参照するための略記として利用される。
◎
A typedef is a definition (matching Typedef) used to declare a new name for a type. This new name is not exposed by language bindings; it is purely used as a shorthand for referencing the type in the IDL.
</p>

<pre class="syntax">
typedef `type^i `identifier^i;
</pre>

<p>
`新たな名前が与えられる型@
（ `TypeWithExtendedAttributes$g に合致）は， `typedef^c ~keywordの後に指定され、型に後続する `identifier$g ~tokが，その新たな名前を与える。
◎
The type being given a new name is specified after the typedef keyword (matching TypeWithExtendedAttributes), and the identifier token following the type gives the name.
</p>

<p>
`Type$g は、同じまたは別の`~typedef$の識別子にされては~MUST_NOT。
◎
The Type must not be the identifier of the same or another typedef.
</p>

<p>
`~typedef$に適用できる`拡張属性$は、この仕様では定義されない。
◎
No extended attributes defined in this specification are applicable to typedefs.
</p>

<div class="grammar">
Typedef
</div>


<div class="example">
<p>
次の`~IDL片$は、`~typedef$を利用して，長い`連列~型$の代わりに短い`識別子$を使えるようしている。
◎
The following IDL fragment demonstrates the use of typedefs to allow the use of a short identifier instead of a long sequence type.
</p>


<pre class="webidl">
interface Point {
  attribute double x;
  attribute double y;
};

typedef sequence&lt;Point&gt; Points;

interface Widget {
  boolean pointWithinBounds(Point %p);
  boolean allPointsWithinBounds(Points %ps);
};
</pre>

</div>
		</section>
		<section id="idl-objects">
<h3 title="Objects implementing interfaces">2.11. ~ifcを実装している~obj</h3>


<p>
`~IDL片$の集合の実装においては、
~objは
`~platform~obj@,
`利用者~obj@,
またはそのいずれでもないものとして記述できる。
~platform~objと見なされる~objは次の 2 種類に分けられる：
◎
In a given implementation of a set of IDL fragments, an object can be described as being a platform object, a user object, or neither. There are two kinds of object that are considered to be platform objects:
</p>
<ul>
	<li>
`呼戻~ifc$でない`~ifc$を実装する~obj
◎
objects that implement a non-callback interface;
</li>
	<li>
~IDL `DOMException$T を表現する~obj
◎
objects representing an IDL DOMException.
</li>
</ul>

<div class="p">
<p>
`旧来の~platform~obj@
は、`~platform~obj$のうち，次をすべて満たすものである：
</p>

<ul ><li>`*Global$x `拡張属性$も有さない`~ifc$を実装する
</li><li>`有index~propを~support$する, または
`有名~propを~support$する
</li></ul>
◎
Legacy platform objects are platform objects that implement an interface which does not have a [Global] or [PrimaryGlobal] extended attribute, supports indexed or named properties.
</div>

<p>
~browserにおいては、例えば，［
~page内で走らせている~ESに対し，~page内容への~accessを提供する
］ために，~browserに実装されている（ `Node^T や `Document^T などの~ifcを実装している） DOM ~objが、~platform~objになる。
これらの~objは、
C++ などの言語で実装される~exotic~objになるか,
または~native~ES~objになるであろう。
いずれにせよ，所与の~IDL片の集合に対する実装は、［
実装により作成されたすべての~platform~obj
］を認識できる必要がある。
これは、所与の~objに［
その~objが実装における~platform~objであるかどうかを記録するための，何らかの内部~状態
］を~~実際に持たせるか、あるいは, おそらく，［
~objが一定の内部 C++ ~classにより実装されているかどうか
］を見ることにより、実現できるであろう。
~platform~objが，正確に どう実装から認識されるかについては、実装に特有になる。
◎
In a browser, for example, the browser-implemented DOM objects (implementing interfaces such as Node and Document) that provide access to a web page’s contents to ECMAScript running in the page would be platform objects. These objects might be exotic objects, implemented in a language like C++, or they might be native ECMAScript objects. Regardless, an implementation of a given set of IDL fragments needs to be able to recognize all platform objects that are created by the implementation. This might be done by having some internal state that records whether a given object is indeed a platform object for that implementation, or perhaps by observing that the object is implemented by a given internal C++ class. How exactly platform objects are recognized by a given implementation of a set of IDL fragments is implementation specific.
</p>

<p>
~system内の他のすべての~objは、~platform~objとしては扱われないことになる。
例えば、~browserが開いた~Web~pageが， DOM Core を実装する~ES~libraryを読込んだとする。
この~libraryは、~browserが提供する実装とは異なる実装と見なされることになる。
~ES~libraryにより作成された［
`Node^T ~ifcを実装する~obj
］は、~browser実装による［
`Node^T を実装する~platform~obj
］としては扱われないことになる。
◎
All other objects in the system would not be treated as platform objects. For example, assume that a web page opened in a browser loads an ECMAScript library that implements DOM Core. This library would be considered to be a different implementation from the browser provided implementation. The objects created by the ECMAScript library that implement the Node interface will not be treated as platform objects that implement Node by the browser implementation.
</p>

<p>
利用者~objとは、［［
作者により定義される演算を~Web~APIから呼出せるようにする，あるいは~Web~APIからの~objの属性~操作を通して, 作者の~programと値を受け~~渡せるようにする
］ための`呼戻~ifc$
］を実装するものとして、作者が作成することになる~objである。
~Web~pageにおいては、 DOM Events 実装から呼出される呼戻を登録する際に利用される，［
`EventListener^T ~ifcを実装する~ES~obj
］が、利用者~objと見なされることになる。
◎
User objects are those that authors would create, implementing callback interfaces that the Web APIs use to be able to invoke author-defined operations or to send and receive values to the author’s program through manipulating the object’s attributes. In a web page, an ECMAScript object that implements the EventListener interface, which is used to register a callback that the DOM Events implementation invokes, would be considered to be a user object.
</p>

<p>
利用者~objが実装できるのは`呼戻~ifc$のみであり,
~platform~objが実装できるのは非~呼戻~ifcのみであることに注意。
◎
Note that user objects can only implement callback interfaces and platform objects can only implement non-callback interfaces.
</p>
		</section>
		<section id="idl-types">
<h3 title="Types">2.12. 型</h3>


<p>
この節では、~Web~IDLで~supportされる型,
それぞれの型に対応する値の集合,
その型の`定数$が どう表現されるか,
について挙げていく。
◎
This section lists the types supported by Web IDL, the set of values corresponding to each type, and how constants of that type are represented.
</p>

<p>
互いに類似する型の集合には、次のような総称が付与されている：
</p>

<dl >
	<dt>`整数~型@</dt>
	<dd>
`byte$T ,
`octet$T ,
`short$T ,
`unsigned short$T ,
`long$T ,
`unsigned long$T ,
`long long$T ,
`unsigned long long$T
◎
The following types are known as integer types: byte, octet, short, unsigned short, long, unsigned long, long long and unsigned long long.
</dd>

	<dt>`実数~型@</dt>
	<dd>
すべての`整数~型$ ,
`float$T ,
`unrestricted float$T ,
`double$T ,
`unrestricted double$T
◎
The following types are known as numeric types: the integer types, float, unrestricted float, double and unrestricted double.
</dd>

	<dt>`~primitive型@</dt>
	<dd>
`boolean$T ,
すべての`実数~型$
◎
The primitive types are boolean and the numeric types.
</dd>

	<dt>`文字列~型@</dt>
	<dd>
`DOMString$T, すべての`列挙~型$ , `ByteString$T, `USVString$T
◎
The string types are DOMString, all enumeration types, ByteString and USVString.
</dd>

	<dt>`例外~型@</dt>
	<dd>
`Error$T, `DOMException$T
◎
The exception types are Error and DOMException.
</dd>

	<dt>`有型~配列~型@</dt>
	<dd>
`Int8Array$T,
`Int16Array$T,
`Int32Array$T,
`Uint8Array$T,
`Uint16Array$T,
`Uint32Array$T,
`Uint8ClampedArray$T,
`Float32Array$T,
`Float64Array$T
◎
The typed array types are Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array and Float64Array.
</dd>

	<dt>`~buffer~source型@</dt>
	<dd>
`ArrayBuffer$T,
`DataView$T,
すべての`有型~配列~型$
◎
The buffer source types are ArrayBuffer, DataView, and the typed array types.
</dd>

	<dt>`~obj型@</dt>
	<dd>
`object$T 型, すべての `~ifc型$, すべての`例外~型$
◎
The object type, all interface types and the exception types are known as object types.
</dd>

</dl>


<p>
どの型も，型を識別するための文字列である
`型~名@
を持つ — それは一意になるとは限らない。
以下の各~節では、各~型にあてがわれる型~名も定義する。
◎
Every type has a type name, which is a string, not necessarily unique, that identifies the type. Each sub-section below defines what the type name is for each type.
</p>

<p id="type-conversion-exceptions">
`演算$の呼出しや`属性$に値を代入する際に必要になる，言語束縛に特有の型から~IDL型への変換はすべて、［
演算に指定された機能性や 属性~代入
］が~~実行に移される前に遂行される。
変換が遂行できない場合、演算は走らされず, 属性は更新されないことになる。
一部の言語束縛では、この型~変換により，例外が投出され得る。
そのような場合、これらの例外は，演算の呼出しや属性への代入-を試みた~codeまで，伝播することになる。
◎
When conversions are made from language binding specific types to IDL types in order to invoke an operation or assign a value to an attribute, all conversions necessary will be performed before the specified functionality of the operation or attribute assignment is carried out. If the conversion cannot be performed, then the operation will not run or the attribute will not be updated. In some language bindings, type conversions could result in an exception being thrown. In such cases, these exceptions will be propagated to the code that made the attempt to invoke the operation or assign to the attribute.
</p>

<div class="grammar">
Type
TypeWithExtendedAttributes
SingleType
UnionType
UnionMemberType
UnionMemberTypes
NonAnyType
ConstType
PrimitiveType
UnrestrictedFloatType
FloatType
UnsignedIntegerType
IntegerType
OptionalLong
StringType
PromiseType
RecordType
Null
</div>

			<section id="idl-any">
<h4 title="any">2.12.1. `any^T</h4>


<p>
`any$T 型は、 `共用体~型$ 以外のすべての型の和集合である。
その`型~名$は、 `Any^l である。
◎
The any type is the union of all other possible non-union types. Its type name is “Any”.
</p>

<p>
`any$T 型は、そのそれぞれの値ごとに固有の非 `any$T 型が結付けられる意味で，~~特別な共用体~型のようなものである。
例えば，
`any$T 型のある値は `unsigned long$T 150 をとり得る一方、別の値は `long$T 150 をとり得る。
これらは別個の型の値になる。
◎
The any type is like a discriminated union type, in that each of its values has a specific non-any type associated with it. For example, one value of the any type is the unsigned long 150, while another is the long 150. These are distinct values.
</p>

<p>
`any$T 型~値の 特定0の型は、その
`固有型@
と呼ばれる。
（ `共用体~型$の値も`固有型$を持つ。）
◎
The particular type of an any value is known as its specific type. (Values of union types also have specific types.)
</p>

<p class="trans-note">【
`any^T 型は，`es-any$secにも見られるように `null^V 値もとり得るようだが（従って暗黙的な意味で`~nullable$型になると考えられる）、明示的な言及が見当たらない（“すべての型” には~nullable型も含まれる？）。
<!-- 
おそらく、非~nullableの `any^T 型も在った方が，いくつかの定義はより簡潔に記せるように思われる。
 -->
】</p>


			</section>
			<section id="idl-boolean">
<h4 title="boolean">2.12.2. `boolean^T</h4>


<p>
`boolean$T 型は 2 つの値：
`true^V と `false^V をとり得る。
◎
The boolean type has two values: true and false.
</p>

<p>
~IDLにおいては、 `boolean$T 定数~値は［
`true^c ／ `false^c
］~tokで表現される。
◎
boolean constant values in IDL are represented with the true and false tokens.
</p>

<p>
`boolean$T 型の`型~名$は、 `Boolean^l である。
◎
The type name of the boolean type is “Boolean”.
</p>
			</section>
			<section id="idl-integers">
<h4>2.12.3〜10. 整数~型</h4>

<p class="trans-note">【
この訳では、原文の 2.12.3 〜 2.12.10 節の内容
— 各種~IDL整数~型の定義を集約して，一括して与える。
】</p>

<p>
各種 有符号／無符号 `整数~型$の，とり得る値の範囲, および `型~名$は、次の表で与えられる：
◎
The xxx ~LET (byte|short|long|long long／octet|unsigned short|unsigned long|unsigned long long) type is a (signed／unsigned) integer type that has values in the range ([−P÷2, P÷2 − 1]／[0, P − 1]); P ~LET 2^(8|16|32|64).
◎
xxx constant values in IDL are represented with integer tokens.
◎
The type name of the xxx type is “Xxx”.
</p>


<table id="matrix-idl-integers">

<thead><tr><th>~IDL型
<th>最小~値
<th>最大~値
<th>型~名
</thead>

<tbody><tr><th>`byte@T
<td title="−128">−2`7^sup
<td title="127">2`7^sup − 1
<td>`Byte^l

<tr><th>`octet@T
<td>0
<td title="255">2`8^sup − 1
<td>`Octet^l

<tr><th>`short@T
<td title="−32768">−2`15^sup
<td title="32767">2`15^sup − 1
<td>`Short^l

<tr><th>`unsigned short@T
<td>0
<td title="65535">2`16^sup − 1
<td>`UnsignedShort^l

<tr><th>`long@T
<td title="−2147483648">−2`31^sup
<td title="2147483647">2`31^sup − 1
<td>`Long^l

<tr><th>`unsigned long@T
<td>0
<td title="4294967295">2`32^sup − 1
<td>`UnsignedLong^l

<tr><th>`long long@T
<td title="−9223372036854775808">−2`63^sup
<td title="9223372036854775807">2`63^sup − 1
<td>`LongLong^l

<tr><th>`unsigned long long@T
<td>0
<td title="18446744073709551615">2`64^sup − 1
<td>`UnsignedLongLong^l

</tbody></table>


<p>
~IDLにおいては、どの`整数~型$の定数~値も， `integer$g ~tokで表現される。
</p>

			</section>
			<section id="idl-floats">
<h4>2.12.11〜14. 浮動小数点数~型</h4>

<p class="trans-note">【
この訳では、原文の 2.12.11 〜 2.12.14 節の内容
— 各種~IDL浮動小数点数~型の定義を集約して，一括して与える。
】</p>

<p>
各種
“浮動小数点数 型”
— `整数~型$でない`実数~型$ —
に対応する値の範囲, および それぞれの`型~名$は、次の表で与えられる：
</p>


<table id="matrix-idl-floats">

<thead><tr><th>~IDL型
<th>値の範囲 `IEEE-754$r
<th>型~名
</thead>

<tbody><tr><th>`float@T
<td>
すべての有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合
◎
The float type is a floating point numeric type that corresponds to the set of finite single-precision 32 bit IEEE 754 floating point numbers. [IEEE-754]
<td>`Float^l

<tr><th>`unrestricted float@T
<td>
すべての有限, 非~有限［
単精度 32 ~bit IEEE 754 浮動小数点数
］の集合に “非数（ not a number ）” （ 各種 NaN ）を加えた集合
◎
The unrestricted float type is a floating point numeric type that corresponds to the set of all possible single-precision 32 bit IEEE 754 floating point numbers, finite, non-finite, and special "not a number" values (NaNs). [IEEE-754]
<td>`UnrestrictedFloat^l

<tr><th>`double@T
<td>
すべての有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合
◎
The double type is a floating point numeric type that corresponds to the set of finite double-precision 64 bit IEEE 754 floating point numbers. [IEEE-754]
<td>`Double^l

<tr><th>`unrestricted double@T
<td>
すべての有限, 非~有限［
倍精度 64 ~bit IEEE 754 浮動小数点数
］の集合に “非数（ not a number ）” （ 各種 NaN ）を加えた集合
◎
The unrestricted double type is a floating point numeric type that corresponds to the set of all possible double-precision 64 bit IEEE 754 floating point numbers, finite, non-finite, and special "not a number" values (NaNs). [IEEE-754]
<td>`UnrestrictedDouble^l

</tbody></table>


<p>
~IDLにおいては、どの浮動小数点数 型の定数~値も，
`float$g ~tokで表現される。
◎
The type name of the( xxx)? yyy type is “(Xxx)Yyy”.
</p>

<p class="advisement">
特に 32 ~bit浮動小数点~型を利用する理由が無い限り，仕様は
`float$T でなく，`double$T を利用するべきである。
`double$T が表現できる値~集合は，より近く~ES `Number^jt に合致するので。
◎
Unless there are specific reasons to use a 32 bit floating point type, specifications should use double rather than float, since the set of values that a double can represent more closely matches an ECMAScript Number.
</p>

			</section>
			<section id="idl-DOMString">
<h4 title="DOMString">2.12.15. `DOMString^T</h4>


<p>
`DOMString$T 型は、可能なすべての［
`符号単位$の並び
］の集合に対応する。
そのような並びは、共通的に，~UTF-16に符号化された文字列 `RFC2781$r
として解釈されるが、要求されてはいない。
`DOMString$T は
<cite><a href="https://www.w3.org/TR/DOM-Level-3-Core//core#ID-C74D1578">DOM Level 3 Core §The DOMString Type</a></cite>
において［
OMG IDL boxed `sequence&lt;unsigned short&gt;^T valuetype
］として定義されているが、この文書は，文字列が要求される様々な状況における，その連列~型に対する特別な場合分けを避けるため、 `DOMString$T を内在的な型として定義する。
◎
The DOMString type corresponds to the set of all possible sequences of code units. Such sequences are commonly interpreted as UTF-16 encoded strings [RFC2781] although this is not required. While DOMString is defined to be an OMG IDL boxed sequence&lt;unsigned short&gt; valuetype in DOM Level 3 Core §The DOMString Type, this document defines DOMString to be an intrinsic type so as to avoid special casing that sequence type in various situations where a string is required.
</p>

<p class="note">注記：
`null^V は `DOMString$T の値ではないことにも注意。
~IDLにおいて `null^V を許容するためには，
<code >DOMString?</code> と記される
`~nullable$
`DOMString$T
を利用する必要がある。
◎
Note: Note also that null is not a value of type DOMString. To allow null, a nullable DOMString, written as DOMString? in IDL, needs to be used.
</p>

<p>
この仕様においては、
`DOMString$T 値が妥当な~UTF-16文字列であることは要求されない。
例えば，
`DOMString$T 値は、対を成さない代用対（ surrogate pair）文字も含み得る。
しかしながら，~Web~IDLを利用する仕様の策定者は、所与の［
特定0の`符号単位$並び
］から `~Unicode~scalar値$列を得たいと求めることもあろう。
◎
Nothing in this specification requires a DOMString value to be a valid UTF-16 string. For example, a DOMString value might include unmatched surrogate pair characters. However, authors of specifications using Web IDL might want to obtain a sequence of Unicode scalar values given a particular sequence of code units.
</p>

<p>
次の~algoは、 `DOMString$T 値 %S を
`~Unicode~scalar値~列に変換-@
する仕方を定義する：
◎
The following algorithm defines a way to convert a DOMString to a sequence of Unicode scalar values:
</p>

<ol class="algorithm">
	<li>
%n ~LET %S の長さ
◎
Let S be the DOMString value.
◎
Let n be the length of S.
</li>
	<li>
%i ~LET 0
◎
Initialize i to 0.
</li>
	<li>
%U ~LET ~Unicode文字の空~連列
◎
Initialize U to be an empty sequence of Unicode characters.
</li>
	<li>
<p id="cp-while-i-n">
~WHILE %i ~LT %n ：
◎
While i &lt; n:
</p>


		<ol>
			<li>
%c ~LET %S 内で~index %i に位置する`符号単位$
◎
Let c be the code unit in S at index i.
</li>
			<li>
<p>
%c の値に応じて：
◎
Depending on the value of c:
</p>
				<dl class="switch">
					<dt>%c ~LT 0xD800</dt>
					<dt>%c ~GT 0xDFFF</dt>
					<dd>

<p>
符号位置 %c の~Unicode文字を %U に付加する
◎
Append to U the Unicode character with code point c.
</p>
					</dd>
					<dt>0xDC00 ~LTE %c ~LTE 0xDFFF</dt>
					<dd>
<p>
~REPLACEMENT を %U に付加する
◎
Append to U a U+FFFD REPLACEMENT CHARACTER.
</p>
					</dd>
					<dt>0xD800 ~LTE %c ~LTE 0xDBFF</dt>
					<dd>
						<ol class="only">
							<li>
~IF［
%i + 1 ~GTE %n
］
⇒
~REPLACEMENT を %U に付加する
◎
If i = n−1, then append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
							<li>
<p>
~ELSE
：
◎
Otherwise, i &lt; n−1:
</p>
								<ol>
									<li>
%d ~LET %S 内の~index %i + 1 に位置する`符号単位$
◎
Let d be the code unit in S at index i+1.
</li>
									<li>
<p>
~IF［
0xDC00 ~LTE %d ~LTE 0xDFFF
］：
◎
If 0xDC00 ≤ d ≤ 0xDFFF, then:
</p>
										<ol>
											<li>
符号位置 ［
2`16^sup + 2`10^sup × ( %c &amp; 0x3FF ) + ( %d &amp; 0x3FF )
］の~Unicode文字を %U に付加する
◎
Let a be c &amp; 0x3FF.
◎
Let b be d &amp; 0x3FF.
◎
Append to U the Unicode character with code point 2^16 + 2^10 a+b.
</li>
											<li>
%i ~SET %i + 1
◎
Set i to i+1.
</li>
										</ol>
									</li>
									<li>
~ELSE
⇒
~REPLACEMENT を %U に付加する
◎
Otherwise, d &lt; 0xDC00 or d &gt; 0xDFFF. Append to U a U+FFFD REPLACEMENT CHARACTER.
</li>
								</ol>
							</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%i ~SET %i + 1
◎
Set i to i+1.
</li>
		</ol>
	</li>
	<li>
~RET %U
◎
Return U.
</li>
</ol>

<p>
~IDLにおいて，定数 `DOMString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `DOMString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant DOMString value in IDL, although DOMString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`DOMString$T 型の`型~名$は、 `String^l である。
◎
The type name of the DOMString type is “String”.
</p>

			</section>
			<section id="idl-ByteString">
<h4 title="ByteString">2.12.16. `ByteString^T</h4>

<p>
`ByteString$T 型は、可能なすべての［
byte の並び
］の集合に対応する。
その種の並びは、要求されてはいないが，［
~UTF-8に符号化された文字列 `RFC3629$r, あるいは［
他の何らかの［ 1 符号単位あたり 8 ~bit ］になる符号化方式
］により符号化された文字列
］に解釈し得る。
◎
The ByteString type corresponds to the set of all possible sequences of bytes. Such sequences might be interpreted as UTF-8 encoded strings [RFC3629] or strings in some other 8-bit-per-code-unit encoding, although this is not required.
</p>

<p>
~IDLにおいて，定数 `ByteString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `ByteString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant ByteString value in IDL, although ByteString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`ByteString$T 型の`型~名$は、 `ByteString^l である。
◎
The type name of the ByteString type is “ByteString”.
</p>

<p class="advisement">
仕様は、［
HTTP などの，~byteや文字列を交換可能な~~形で利用する~protocol
］とのやりとりのみに，
`ByteString$T を利用するべきである。
一般に、文字列は，その値が［
常に ASCII または 何らかの 8 ~bit文字~符号化方式
］になることが期待されているとしても，
`DOMString$T 値により表現されるべきである。
8 ~bit~dataを保持するためには、`ByteString$T ではなく，［
`octet$T または `byte$T
］を要素とする［
`連列~型$ ／ `凍結~配列~型$ ／ `Uint8Array$T ／ `Int8Array$T
］が利用されるべきである。
◎
Specifications should only use ByteString for interfacing with protocols that use bytes and strings interchangeably, such as HTTP. In general, strings should be represented with DOMString values, even if it is expected that values of the string will always be in ASCII or some 8 bit character encoding. Sequences or frozen arrays with octet or byte elements, Uint8Array, or Int8Array should be used for holding 8 bit data rather than ByteString.
</p>

			</section>
			<section id="idl-USVString">
<h4 title="USVString">2.12.17. `USVString^T</h4>

<p>
`USVString$T 型は、可能なすべての［［
`~Unicode~scalar値$
— ~surrogate符号位置でない~Unicode符号位置
］の並び
］の集合に対応する。
◎
The USVString type corresponds to the set of all possible sequences of Unicode scalar values, which are all of the Unicode code points apart from the surrogate code points.
</p>

<p>
~IDLにおいて，定数 `USVString$T 値を表現する仕方は、ない。
`string$g ~literalを利用して， `USVString$T 型の［
`辞書~mb$ ／ 演算の`随意~引数$
］に既定~値を指定することはできる。
◎
There is no way to represent a constant USVString value in IDL, although USVString dictionary member and operation optional argument default values can be specified using a string literal.
</p>

<p>
`USVString$T 型の`型~名$は、 `USVString^l である。
◎
The type name of the USVString type is “USVString”.
</p>

<p class="advisement">
仕様は、［
~text処理を遂行する際に `~Unicode~scalar値$による文字列~演算が必要になる
］ときにのみ，~APIに `USVString$T を利用するべきである。
文字列を利用する ほとんどの~APIは、文字列~内の`符号単位$に いかなる解釈も行わない `DOMString$T を利用するべきである。
疑わしい場合は `DOMString$T を利用すること。
◎
Specifications should only use USVString for APIs that perform text processing and need a string of Unicode scalar values to operate on. Most APIs that use strings should instead be using DOMString, which does not make any interpretations of the code units in the string. When in doubt, use DOMString.
</p>

			</section>
			<section id="idl-object">
<h4 title="object">2.12.18. `object^T</h4>

<p>
`object$T 型は、可能なすべての［
非 `null^V ~obj参照
］の集合に対応する。
◎
The object type corresponds to the set of all possible non-null object references.
</p>

<p>
~IDLにおいて，定数 `object$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant object value in IDL.
</p>

<p>
可能なすべての~obj参照に加えて，
`null^V 値も内包する型を表すためには、
`~nullable型$ `object?^T を利用する。
◎
To denote a type that includes all possible object references plus the null value, use the nullable type object?.
</p>

<p>
`object$T 型の`型~名$は、 `Object^l である。
◎
The type name of the object type is “Object”.
</p>
			</section>
			<section id="idl-symbol">
<h4 title="symbol">2.12.19. `symbol^T</h4>

<p>
`symbol$T 型は、可能なすべての~symbol値の集合に対応する。
~symbol値は、不透明かつ `object$T でない値であるが，同一性（ identity ）は備える（すなわち、自身のみに等しい）。
◎
The symbol type corresponds to the set of all possible symbol values. Symbol values are opaque, non-object values which nevertheless have identity (i.e., are only equal to themselves).
</p>

<p>
~IDLにおいて，定数 `symbol$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant symbol value in IDL.
</p>

<p>
`symbol$T 型の`型~名$は、 `Symbol^l である。
◎
The type name of the symbol type is “Symbol”.
</p>
			</section>
			<section id="idl-interface">
<h4 title="Interface types">2.12.20. ~ifc型</h4>


<p>
`~ifc$を識別する`識別子$は、その~ifcを実装する，可能なすべての［
非 `null^V ~obj参照の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies an interface is used to refer to a type that corresponds to the set of all possible non-null references to objects that implement that interface.
</p>

<p>
非~呼戻~ifcに対する~ifc型の~IDL値は，単に~obj参照により表現される。
`呼戻~ifc$ に対しては、~ifc型の~IDL値は［
~obj参照,
`呼戻~文脈$
］の組により表現される。
`呼戻~文脈@
とは、言語束縛に特有の値であり、［
言語束縛に特有の~obj参照が~IDL値に変換される時点における，実行~文脈についての情報
］を格納するために利用されるものである。
◎
For non-callback interfaces, an IDL value of the interface type is represented just by an object reference. For callback interfaces, an IDL value of the interface type is represented by a tuple of an object reference and a callback context. The callback context is a language binding specific value, and is used to store information about the execution context at the time the language binding specific object reference is converted to an IDL value.
</p>

<p class="note">注記：
~ES~objに対しては、`呼戻~文脈$は，
`Object^jt 値が~IDL呼戻~ifc型の値に変換される時点の
`現任の設定群~obj$への参照を保持するために利用される。
`es-interface$sec
を見よ。
◎
Note: For ECMAScript objects, the callback context is used to hold a reference to the incumbent settings object at the time the Object value is converted to an IDL callback interface type value. See §3.2.14 Interface types.
</p>

<p>
~IDLにおいて，特定0の~ifc型の定数~obj参照~値を表現する仕方は、ない。
◎
There is no way to represent a constant object reference value for a particular interface type in IDL.
</p>

<p>
［
所与の~ifcを実装する 可能なすべての~obj参照に加え， `null^V 値も内包する
］ような型を表すためには、`~nullable型$を利用する。
◎
To denote a type that includes all possible references to objects implementing the given interface plus the null value, use a nullable type.
</p>

<p>
~ifc型の`型~名$は、その~ifcの`識別子$である。
◎
The type name of an interface type is the identifier of the interface.
</p>
			</section>
			<section id="idl-dictionary">
<h4 title="Dictionary types">2.12.21. 辞書~型</h4>


<p>
`辞書$を識別する`識別子$は、［
辞書~定義に~~寄与する，すべての辞書の集合
］に対応する型を指すために利用される。
◎
An identifier that identifies a dictionary is used to refer to a type that corresponds to the set of all dictionaries that adhere to the dictionary definition.
</p>

<p>
`有順序~map$用の~literal構文も，辞書を表現するために利用できる
— その文脈から、暗黙的に［
当の~mapが，特定の辞書~型の~instanceとして扱われる
］ものと解されるならば。
しかしながら、~IDL片の内側では，定数~辞書~値を表現する仕方は、ない。
◎
The literal syntax for ordered maps may also be used to represent dictionaries, when it is implicitly understood from context that the map is being treated as an instance of a specific dictionary type. However, there is no way to represent a constant dictionary value inside IDL fragments.
</p>

<p>
辞書~型の`型~名$は、その辞書の`識別子$である。
◎
The type name of a dictionary type is the identifier of the dictionary.
</p>
			</section>
			<section id="idl-enumeration">
<h4 title="Enumeration types">2.12.22. 列挙~型</h4>


<p>
`列挙$を識別する`識別子$は、［
その`列挙~値$に属する文字列（ `DOMString$T と同様の，`符号単位$の並び）の集合
］を値にとる型を指すために利用される。
<!--  -->
◎
An identifier that identifies an enumeration is used to refer to a type whose values are the set of strings (sequences of code units, as with DOMString) that are the enumeration’s values.
</p>

<p>
`DOMString$T と同様に、
~IDLにおいて，定数`列挙$値を表現する仕方は、ない。
`string$g ~literalを利用して、列挙~型にされた`辞書~mb$に
`既定~値$diCを指定することはできる。
◎
Like DOMString, there is no way to represent a constant enumeration value in IDL, although enumeration-typed dictionary member default values can be specified using a string literal.
</p>

<p>
列挙~型の`型~名$は、その列挙の`識別子$である。
◎
The type name of an enumeration type is the identifier of the enumeration.
</p>
			</section>
			<section id="idl-callback-function">
<h4 title="Callback function types">2.12.23. 呼戻~関数~型</h4>


<p>
`呼戻~関数$を識別する`識別子$は、［
所与の~signatureを伴う関数~objへの参照
］を値にとる型を指すために利用される。
◎
An identifier that identifies a callback function is used to refer to a type whose values are references to objects that are functions with the given signature.
</p>

<p>
呼戻~関数~型の~IDL値は，［
~obj参照, `呼戻~文脈$
］の組により表現される。
◎
An IDL value of the callback function type is represented by a tuple of an object reference and a callback context.
</p>

<p class="note">注記：
`~ifc型$と同様に、`呼戻~文脈$は，
~ES `Object^jt 値が~IDL呼戻~ifc型の値に変換される時点の
`現任の設定群~obj$への参照を保持するために利用される。
`es-callback-function$sec
を見よ。
◎
Note: As with callback interface types, the callback context is used to hold a reference to the incumbent settings object at the time an ECMAScript Object value is converted to an IDL callback function type value. See §3.2.17 Callback function types.
</p>


<p>
~IDLにおいて，定数  `呼戻~関数$値を表現する仕方は、ない。
◎
There is no way to represent a constant callback function value in IDL.
</p>

<p>
呼戻~関数~型の`型~名$は、その呼戻~関数の`識別子$である。
◎
The type name of a callback function type is the identifier of the callback function.
</p>
			</section>
			<section id="idl-nullable-type">
<h4 title="Nullable types — T?">2.12.24. ~nullable型 — `~varT?^T</h4>


<p>
`~nullable型@
は、（その
`内縁~型@
と呼ばれる）既存の型から構築される~IDL型であり、とり得る値の集合は，内縁~型がとり得る値に値 `null^V のみを~~追加したものになる。
~IDLにおいては、`~nullable型$は，既存の型の後に
文字 `U+003F QUESTION MARK ("?")^char
を置いて表現される。
`内縁~型$は次のいずれであっても~MUST_NOT：
◎
A nullable type is an IDL type constructed from an existing type (called the inner type), which just allows the additional value null to be a member of its set of values. Nullable types are represented in IDL by placing a U+003F QUESTION MARK ("?") character after an existing type. The inner type must not be:
</p>

<div class="p">

<ul ><li>`any$T 型
</li><li>`~promise型$
</li><li>別の~nullable型
</li><li>`共用体~型$であって［
それ自身が`~nullable型を内包する$, または
その`平坦化~mb型$に`辞書~型$が含まれている
］もの。
</li></ul>

◎
• any,
• a Promise type,
• another nullable type, or
• a union type that itself has includes a nullable type or has a dictionary type as one of its flattened member types.
</div>


<p class="note">注記：
辞書~型は，一般には~nullableになれるが、その場合，演算~引数や辞書~mbの型には利用できない。
◎
Note: Although dictionary types can in general be nullable, they cannot when used as the type of an operation argument or a dictionary member.
</p>

<p>
~IDLにおいては、~nullable型の定数~値は，その`内縁~型$の定数~値と同じ仕方で表現されるか, または `null^c ~tokで表現される。
◎
Nullable type constant values in IDL are represented in the same way that constant values of their inner type would be represented, or with the null token.
</p>

<p>
~nullable型の`型~名$は、［
その`内縁~型$ %T の型~名,
文字列 `OrNull^l
］の連結である。
◎
The type name of a nullable type is the concatenation of the type name of the inner type T and the string “OrNull”.
</p>

<div class="example">
<p>
例えば、値
`true^V, `false^V, `null^V
をとり得る型は， `boolean?^T と記される：
◎
For example, a type that allows the values true, false and null is written as boolean?:
</p>

<pre class="webidl">
interface NetworkFetcher {
  void get(optional boolean? areWeThereYet = false);
};
</pre>

<p>
次の`~ifc$は 2 個の`属性$を持つ。
一方は `DOMString$T または `null^V 値を値にとり得る。
他方は `Node^T ~objへの参照または `null^V 値を値にとり得る：
◎
The following interface has two attributes: one whose value can be a DOMString or the null value, and another whose value can be a reference to a Node object or the null value:
</p>

<pre class="webidl">
interface Node {
  readonly attribute DOMString? namespaceURI;
  readonly attribute Node? parentNode;
  /* <!--cp-some-code--> */
};
</pre>
</div>
			</section>
			<section id="idl-sequence">
<h4 title="Sequence types — sequence&lt;T&gt;">2.12.25. 連列~型 — ~sequence_T</h4>

<p>
`連列~型@
— ~sequence_T —
は、［
一連の［
型 %T の値
］からなる`~list$（長さ 0 にもなり得る）
］を値にとり得るような，~parameter化された型である。
◎
The sequence&lt;T&gt; type is a parameterized type whose values are (possibly zero-length) lists of values of type T.
</p>

<p>
連列は常に値渡しである。
連列が何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に連列が渡された際に，その連列への参照が~objに保有されることはない。
同様に，~platform~objから返されるどの連列も複製であり、それに対する改変は~platform~objからは可視でないことになる。
◎
Sequences are always passed by value. In language bindings where a sequence is represented by an object of some kind, passing a sequence to a platform object will not result in a reference to the sequence being kept by that object. Similarly, any sequence returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>

<p>
`~list$用の~literal構文も，連列を表現するために利用できる
— その文脈から、暗黙的に［
当の~listが，ある連列の~instanceとして扱われる
］ものと解されるならば。
しかしながら、~IDL片の内側では，定数~連列~値を表現する仕方は、ない。
◎
The literal syntax for lists may also be used to represent sequences, when it is implicitly understood from context that the list is being treated as a sequences. However, there is no way to represent a constant sequence value inside IDL fragments.
</p>

<p>
連列は［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Sequences must not be used as the type of an attribute or constant.
</p>

<p class="note">注記：
この制約は、［
`連列~型$は、その参照が渡し回されるものではなく，複製されるものである
］ことを，仕様~策定者や利用者から見て明らかにするためにある。
連列~型の~writableな`属性$には、代わりに，連列を取得-／設定する`演算$~pairの利用を勧める。
◎
Note: This restriction exists so that it is clear to specification writers and API users that sequences are copied rather than having references to them passed around. Instead of a writable attribute of a sequence type, it is suggested that a pair of operations to get and set the sequence is used.
</p>

<p>
連列~型の`型~名$は、［
%T の型~名,
文字列 `Sequence^l
］の連結である。
◎
The type name of a sequence type is the concatenation of the type name for T and the string “Sequence”.
</p>

<p>
どの`~list$であれ、そのどの`~item$の型も %T である限り，暗黙的に ~sequence_T として扱える
◎
Any list can be implicitly treated as a sequence&lt;T&gt;, as long as it contains only items that are of type T.
</p>

			</section>
			<section id="idl-record">
<h4 title="Record types — record&lt;K, V&gt;">2.12.26. ~record型 — ~record_KV</h4>

<p>
`~record型@
— ~record_KV —
は、`有順序~map$であって，その各`~entry$の［
`~key$は型 %K の ある~instance,
`値$は型 %V の ある~instance
］であるような，~parameter化された型である。
%K は［
`DOMString$T ／ `USVString$T ／ `ByteString$T
］でなければ~MUST。
◎
A record type is a parameterized type whose values are ordered maps with keys that are instances of K and values that are instances of V. K must be one of DOMString, USVString, or ByteString.
</p>

<p>
`有順序~map$用の~literal構文も，~recordを表現するために利用できる
— その文脈から、暗黙的に［
当の~mapが，~record型の~instanceとして扱われる
］ものと解されるならば。
しかしながら、~IDL片の内側では，定数~record値を表現する仕方は、ない。
◎
The literal syntax for ordered maps may also be used to represent records, when it is implicitly understood from context that the map is being treated as a record. However, there is no way to represent a constant record value inside IDL fragments.
</p>

<p>
~recordは常に値渡しである。
~recordが何らかの種類の~objで表現される言語束縛においても、`~platform~obj$に~recordが渡された際に，その~recordへの参照が~objに保有されることはない。
同様に，~platform~objから返されるどの~recordも複製であり、それに対する改変は~platform~objからは可視でないことになる。
◎
Records are always passed by value. In language bindings where a record is represented by an object of some kind, passing a record to a platform object will not result in a reference to the record being kept by that object. Similarly, any record returned from a platform object will be a copy and modifications made to it will not be visible to the platform object.
</p>

<p>
~recordは［
`属性$／`定数$
］の型に利用されては~MUST_NOT。
◎
Records must not be used as the type of an attribute or constant.
</p>

<p>
~record型の`型~名$は、［
%K の型~名,
%V の型~名,
文字列 `Record^l
］の連結である。
◎
The type name of a record type is the concatenation of the type name for K, the type name for V and the string “Record”.
</p>

<p>
どの`有順序~map$であれ、そのどの`~entry$も，その［
`~key$の型は %K, `値$の型は %V 
］である限り，暗黙的に ~record_KV として扱える。
◎
Any ordered map can be implicitly treated as a record&lt;K, V&gt;, as long as it contains only entries whose keys are all of of type K and whose values are all of type V.
</p>

			</section>
			<section id="idl-promise">

<h4 title="Promise types — Promise&lt;T&gt;">2.12.27. ~promise型 — ~promise_T</h4>

<p>
`~promise型@
— ~promise_T —
は、［［
<span class="block">
“［［
非同期 演算において，先送りされ得る（非同期にもなり得る）計算
］の最終的な結果†
］への~place-holder”
`ECMA-262$r
</span>
］として利用される~obj
］への参照を値にとるような，~parameter化された型である。
~promise~objの意味論についての詳細は~ES仕様
<a href="~TC39#sec-promise-objects">25.4 節</a>
を見よ。
◎
A promise type is a parameterized type whose values are references to objects that “is used as a place holder for the eventual results of a deferred (and possibly asynchronous) computation result of an asynchronous operation”. See section 25.4 of the ECMAScript specification for details on the semantics of promise objects.
</p>

<p class="trans-note">【†
%T が，充足-時における結果の値の型を与える。
】</p>

<p>
~promise型は~nullableでないが、 %T は~nullableにもなり得る。
◎
Promise types are non-nullable, but T may be nullable.
</p>

<p>
~IDLにおいて，~promise値を表現する仕方は、ない。
◎
There is no way to represent a promise value in IDL.
</p>

<p>
~promise型の`型~名$は、［
%T の型~名,
文字列 `Promise^l
］の連結である。
◎
The type name of a promise type is the concatenation of the type name for T and the string “Promise”.
</p>


			</section>
			<section id="idl-union">
<h4 title="Union types">2.12.28. 共用体~型</h4>


<p>
`共用体~型@
（ union ）は、とり得る値の集合が 複数の型の値の和集合であるような，型である。
共用体~型（ `UnionType$g に合致）は、
`or^c ~keywordで区切られた型の並びを左右~丸括弧で括って記される。
共用体~型を構成する型は、共用体の
`~mb型@
と呼ばれる。
◎
A union type is a type whose set of values is the union of those in two or more other types. Union types (matching UnionType) are written as a series of types separated by the or keyword with a set of surrounding parentheses. The types which comprise the union type are known as the union’s member types.
</p>

<div class="note">
<p>
例えば，
`(Node or DOMString)^c や `(double or sequence&lt;double&gt;)^c
などのように記す。
`共用体~型$に全体として `?^c 接尾辞を適用するときは，
`(Node or DOMString)?^c
のように，右~丸括弧の後に置く。
◎
For example, you might write (Node or DOMString) or (double or sequence&lt;double&gt;). When applying a ? suffix to a union type as a whole, it is placed after the closing parenthesis, as in (Node or DOMString)?.
</p>

<p>
共用体~型の`~mb型$は、入子にされた共用体~型にまでは掘り下げられないことに注意。
したがって，
`(double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?)^T
の~mb型は、
`double^T ,
`(sequence&lt;long&gt; or Event)^T ,
`(Node or DOMString)?^T
になる。
◎
Note that the member types of a union type do not descend into nested union types. So for (double or (sequence&lt;long&gt; or Event) or (Node or DOMString)?) the member types are double, (sequence&lt;long&gt; or Event) and (Node or DOMString)?.
</p>
</div>

<p>
`any$T 型と同様、共用体~型の値は，その値に合致する特定0の`~mb型$を`固有型$として持つ。
◎
Like the any type, values of union types have a specific type, which is the particular member type that matches the value.
</p>

<p>
`共用体~型$ %T
— `注釈付きの型$にもなり得る —
の
`平坦化~mb型@
とは、次の手続きで決定される型の集合である：
◎
The flattened member types of a union type, possibly annotated, is a set of types determined as follows:
</p>

<ol class="algorithm">
	<li>
%S ~LET 空~集合
◎
Let T be the union type.
◎
Initialize S to ∅.
</li>
	<li>
<p id="cp-foreach-union-mb">
%T 内の~EACH ( `~mb型$ %U ) に対し：
◎
For each member type U of T:
</p>
		<ol>
			<li>
%U ~SET %U の`最内縁の型$
◎
If U is an annotated type, then set U to be the inner type of U.
◎
If U is a nullable type, then set U to be the inner type of U.
</li>
			<li>
~IF［
%U は `共用体~型$である
］
⇒
%U の`平坦化~mb型$に属するすべての型を %S に追加する
◎
If U is a union type, then add to S the flattened member types of U.
</li>
			<li>
~ELSE
⇒
%U を %S に追加する
◎
Otherwise, U is not a union type. Add U to S.
</li>
		</ol>
	</li>
	<li>
~RET %S
◎
Return S.
</li>
</ol>

<p class="note">注記：
例えば，`共用体~型$
`(Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;)^T
の`平坦化~mb型$は、 6 つの型［
`Node^T ,
`sequence&lt;long&gt;^T ,
`Event^T ,
`XMLHttpRequest^T ,
`DOMString^T ,
`sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;^T
］からなる。
◎
Note: For example, the flattened member types of the union type (Node or (sequence&lt;long&gt; or Event) or (XMLHttpRequest or DOMString)? or sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;) are the six types Node, sequence&lt;long&gt;, Event, XMLHttpRequest, DOMString and sequence&lt;(sequence&lt;double&gt; or NodeList)&gt;.
</p>

<p>
`共用体~型$ %T の
`~nullable~mb型の個数@
とは、次の手続きで決定される整数である：
◎
The number of nullable member types of a union type is an integer determined as follows:
</p>

<ol class="algorithm">
	<li>
%n ~LET 0
◎
Let T be the union type.
◎
Initialize n to 0.
</li>
	<li>
<!--cp-foreach-union-mb-->
		<ol>
			<li>
<p>
~IF［
%U は `~nullable型$である
］：
◎
If U is a nullable type, then:
</p>
				<ol>
					<li>
%n ~SET %n + 1
◎
Set n to n + 1.
</li>
					<li>
%U ~SET %U の`内縁~型$
◎
Set U to be the inner type of U.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%U は `共用体~型$である
］：
◎
If U is a union type, then:
</p>
				<ol>
					<li>
%m ~LET %U の`~nullable~mb型の個数$
◎
Let m be the number of nullable member types of U.
</li>
					<li>
%n ~SET %n + %m
◎
Set n to n + m.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %n
◎
Return n.
</li>
</ol>

<p>
`~mb型$に `any$T 型が利用されては~MUST_NOT。
◎
The any type must not be used as a union member type.
</p>

<p>
`共用体~型$の
`~nullable~mb型の個数$
は 0 か 1 で~MUST。
1 の場合、その共用体~型は`平坦化~mb型$に`辞書~型$を含んでは~MUST_NOT。
◎
The number of nullable member types of a union type must be 0 or 1, and if it is 1 then the union type must also not have a dictionary type in its flattened member types.
</p>

<p>
次のいずれかを満たす型は
`~nullable型を内包する@
とされる。
◎
A type includes a nullable type if:
</p>

<ul>
	<li>
`~nullable型$である
◎
the type is a nullable type, or
</li>
	<li>
`注釈付きの型$である
~AND
その`内縁~型$anOは`~nullable型$である
◎
the type is an annotated type and its inner type is a nullable type, or
</li>
	<li>
`共用体~型$である
~AND
その `~nullable~mb型の個数$は 0 でない（ 1 である）。
◎
the type is a union type and its number of nullable member types is 1.
	</li>
</ul>

<p class="trans-note">【
概念的には， `null^V を値にとり得る型と考えられる。
ただし、この定義では `any$T 型は含まれないことになる。
】</p>

<p>
`共用体~型$の`平坦化~mb型$に属する
どの 2 つの型も`判別可能$で~MUST。
◎
Each pair of flattened member types in a union type, T and U, must be distinguishable.
</p>

<p>
~IDLにおいては、`共用体~型$の定数~値は，それらの`~mb型$の定数~値と同じ仕方で表現される。
◎
Union type constant values in IDL are represented in the same way that constant values of their member types would be represented.
</p>

<p>
共用体~型の`型~名$は、その各~mb型の型~名を順に，文字列 `Or^l で連結したものである。
◎
The type name of a union type is formed by taking the type names of each member type, in order, and joining them with the string “Or”.
</p>
<div class="grammar">
UnionType
UnionMemberType
UnionMemberTypes
NonAnyType
</div>
			</section>
			<section id="idl-annotated-types">
<h4 title="Annotated types">2.12.29. 注釈付きの型</h4>

<p>
既存の型に ある種の`拡張属性$を指定することにより，追加の型を作成できる。
そのような型は
`注釈付きの型@
と呼ばれ、注釈された~~元の型は その
`内縁~型@anO
と呼ばれる。
◎
Additional types can be created from existing ones by specifying certain extended attributes on the existing types. Such types are called annotated types, and the types they annotate are called inner types.
</p>

<p class="example">
`[Clamp] long^c
は、新たな`注釈付きの型$を定義する
— その挙動は`内縁~型$anO `long$T に基づくが，
`Clamp$x 拡張属性に指定されるように改変される。
◎
[Clamp] long defines a new annotated type, whose behavior is based on that of the inner type long, but modified as specified by the [Clamp] extended attribute.
</p>

<p>
次のものが
`型に適用でき@
る拡張属性とされる：
`Clamp$x,
`EnforceRange$x,
`TreatNullAs$x
◎
The following extended attributes are applicable to types: [Clamp], [EnforceRange], and [TreatNullAs].
</p>

<p>
所与の~IDL型 %型 に
`結付けられている拡張属性@
は、次に従って決定される：
◎
The extended attributes associated with an IDL type type are determined as follows:
</p>

<ol class="algorithm">
	<li>
%拡張属性~集合 ~LET 新たな空`集合$
◎
Let extended attributes be a new empty set.
</li>
	<li>
<p>
~IF［
%型 は `TypeWithExtendedAttributes$g 生成規則 %P の一部として現れている
］
⇒
%P の中の `ExtendedAttributeList$g 内に在する各 `拡張属性$を
%拡張属性~集合 に`付加-$setする
◎
If type appears as part of a TypeWithExtendedAttributes production, append each of the extended attributes present in the production’s ExtendedAttributeList to extended attributes.
</p>

<div class="example">
<pre class="webidl">
interface I {
    attribute [XAttr] long attrib;
    void f1(sequence&lt;[XAttr] long&gt; %arg);
    void f2(optional [XAttr] long %arg);

    maplike&lt;[XAttr2] DOMString, [XAttr3] long&gt;;
};

dictionary D {
    required [XAttr] long member;
};
</pre>
</div>
	</li>
	<li>
<p>
~IF［
%型 は`共用体~型$ %U の`~mb型$である
］
⇒
各［
%U に`結付けられている拡張属性$
］を
%拡張属性~集合 に`付加-$setする
◎
If type is a member type of a union type U, append each of the extended attributes associated with U to extended attributes.
</p>

<div class="example">
<pre class="webidl">
interface I {
    attribute [XAttr] (long or Node) attrib;
};
</pre>
</div>

	</li>
	<li>
<p>
~IF［
%型 は［
`Argument$g 生成規則 %P の中に直に現れる `Type$g 生成規則
］の一部として現れている
］
⇒
［［
%P の中の `ExtendedAttributeList$g 内に在する`拡張属性$
］のうち，`型に適用でき$るもの
］すべてを，
%拡張属性~集合 に`付加-$setする
◎
If type appears as part of a Type production directly within an Argument production, append to extended attributes all of the extended attributes present in the production’s ExtendedAttributeList that are applicable to types.
</p>

<div class="example">
<pre class="webidl">
interface I {
    void f([XAttr] long %attrib);
};
</pre>

<p>
この例の `XAttr^x は、`型に適用でき$る場合に限り，引数の型に結付けられる（他の場合、 `XAttr^x は，引数に適用される）。
◎
Note that this is an example of this step only if [XAttr] is applicable to types; otherwise [XAttr] applies to the argument, and not the argument’s type.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%型 は［
`DictionaryMember$g 生成規則 %P の中に直に現れる `Type$g 生成規則
］の一部として現れている
］
⇒
［［
%P の中の `ExtendedAttributeList$g 内に在する`拡張属性$
］のうち，`型に適用でき$るもの
］すべてを，
%拡張属性~集合 に`付加-$setする
◎
If type appears as part of a Type production directly within an DictionaryMember production, append to extended attributes all of the extended attributes present in the production’s ExtendedAttributeList that are applicable to types.
</p>

<div class="example">
<pre class="webidl">
dictionary D {
    [XAttr] long member;
};
</pre>

<p>
この例の `XAttr^x は、`型に適用でき$る場合に限り，辞書~mbの型に結付けられる（他の場合、 `XAttr^x は，辞書~mbに適用される）。
◎
Note that this is an example of this step only if [XAttr] is applicable to types; otherwise [XAttr] applies to the dictionary member, and not the member’s type.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%型 は`~typedef$である
］
⇒
各［
%型 により`新たな名前が与えられる型$に`結付けられている拡張属性$
］を %拡張属性~集合 に`付加-$setする
◎
If type is a typedef, append the extended attributes associated with the type being given a new name to extended attributes.
</p>

<div class="example">
<pre class="webidl">
typedef [XAttr] long xlong;
</pre>
</div>
	</li>
	<li>
~RET %拡張属性~集合
◎
Return extended attributes.
</li>
</ol>


<p>
どの型に対しても，それに`結付けられている拡張属性$は、`型に適用でき$るもので~MUST。
◎
For any type, the extended attributes associated with it must only contain extended attributes that are applicable to types.
</p>

<div class="p">
<p>
`拡張属性が結付けられ$ている型の`型~名$は、次の連結である：
</p>

<ol ><li>元の型の`型~名$
</li><li>各［
型に`結付けられている拡張属性$
］の`識別子$に対応する文字列すべてを辞書式~順序で連結した結果
</li></ol>

◎
The type name of a type associated with extended attributes is the concatenation of the type name of the original type with the set of strings corresponding to the identifiers of each extended attribute associated with the type, sorted in lexicographic order.
</div>

<p class="example">
`[B, A] long?^c の形による型の`型~名$は、 `LongOrNullAB^l になる。
◎
The type name for a type of the form [B, A] long? is "LongOrNullAB".
</p>

			</section>
			<section id="idl-Error">
<h4 title="Error">2.12.30. `Error^T</h4>

<p>
`Error$T 型は、［
`単純例外$, `DOMException$T
］~objを含む，可能なすべての［
非 null 例外~objへの参照
］の集合に対応する。
◎
The Error type corresponds to the set of all possible non-null references to exception objects, including simple exceptions and DOMException objects.
</p>

<p>
~IDLにおいて，定数 `Error$T 値を表現する仕方は、ない。
◎
There is no way to represent a constant Error value in IDL.
</p>

<p>
`Error$T の`型~名$は、 `Error^l である。
◎
The type name of the Error type is “Error”.
</p>

			</section>
			<section id="idl-buffer-source-types">
<h4 title="Buffer source types">2.12.31. ~buffer~source型</h4>

<p>
可能なすべての［［［
~dataの~buffer, または［
~dataの~buffer上の~view
］］を表現する~obj
］への 非 `null^V 参照
］の集合に対応する，いくつかの型がある。
下の一覧に、それらの型, および それらが表現する［
~bufferまたは その~view
］の種類を挙げる。
◎
There are a number of types that correspond to sets of all possible non-null references to objects that represent a buffer of data or a view on to a buffer of data. The table below lists these types and the kind of buffer or view they represent.
</p>


<table id="matrix-buffer-sources">

<thead><tr><th>型◎ Type
<th>~bufferの種類◎ Kind of buffer
</thead>

<tbody><tr><td>`ArrayBuffer@T
<td>
固定的な個数の~byteからなる~bufferへの~pointer（ `null^V もとり得る）を保持する~obj。
◎
An object that holds a pointer (which may be null) to a buffer of a fixed number of bytes

<tr><td>`DataView@T
<td>
`ArrayBuffer$T への~viewであって、~bufferの中の，任意の~offsetに格納されている 整数／浮動小数点 値への~accessを可能にするもの。
◎
A view on to an ArrayBuffer that allows typed access to integers and floating point values stored at arbitrary offsets into the buffer

<tr><td>`Int8Array@T,
`Int16Array@T,
`Int32Array@T
<td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの 2 の補数による有符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of two’s complement signed integers of the given size in bits

<tr><td>`Uint8Array@T,
`Uint16Array@T,
`Uint32Array@T
<td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの 無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned integers of the given size in bits

<tr><td>`Uint8ClampedArray@T
<td>
`ArrayBuffer$T への~viewであって、値を切詰める変換も伴われるような，［
8~bit無符号~整数からなる配列
］を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of unsigned 8 bit integers with clamped conversions

<tr><td>`Float32Array@T,
`Float64Array@T
<td>
`ArrayBuffer$T への~viewであって、［
所与の~bit~sizeの IEEE 754 浮動小数点数
］からなる配列を公開するもの。
◎
A view on to an ArrayBuffer that exposes it as an array of IEEE 754 floating point numbers of the given size in bits

</tbody></table>

<p class="note">注記：
これらの型はすべて、~ESにて定義される~classに対応する。
◎
Note: These types all correspond to classes defined in ECMAScript.
</p>

<p>
これらのどの型についても：
◎
↓</p>

<ul>
	<li>
~IDLにおいて，その型の定数~値を表現する仕方は、ない。
◎
There is no way to represent a constant value of any of these types in IDL.
</li>
	<li>
その`型~名$は、その型~自身の名前である。
◎
The type name of all of these types is the name of the type itself.
</li>
</ul>

<p>
仕様の中の注釈文~levelにおいては、~IDL`~buffer~source型$は，単純に~objへの参照である。
仕様の注釈文にて，~buffer内の~byte列を 検分したり操作するときは、最初に，~buffer~sourceに保持されている~byte列の
<a id="dfn-get-buffer-source-copy">`参照／複製を取得-@</a>
する手続きを介さ~MUST。
仕様の注釈文では、その結果の~byte列への参照／複製を利用して，個々の~byte値を取得したり設定できる。
◎
At the specification prose level, IDL buffer source types are simply references to objects. To inspect or manipulate the bytes inside the buffer, specification prose must first either get a reference to the bytes held by the buffer source or get a copy of the bytes held by the buffer source. With a reference to the buffer source’s bytes, specification prose can get or set individual byte values using that reference.
</p>

<div class="advisement">
<p>
仕様において、［
~buffer~sourceに保持されている~byteへの参照を取得する
］ような ~textを書くときには、細心の注意を払う必要がある
— 下層の~dataは、作者や他の~APIにより，予測し得ない時に容易く変更され得るので。
改変されないような ~binary~dataの~chunkを得るために，演算~引数として~buffer~source型を利用する場合は、その演算を定義する注釈文の始めの方で，~buffer~sourceの~byte列の複製を取得することが、強く推奨される。
◎
Extreme care must be taken when writing specification text that gets a reference to the bytes held by a buffer source, as the underlying data can easily be changed by the script author or other APIs at unpredictable times. If you are using a buffer source type as an operation argument to obtain a chunk of binary data that will not be modified, it is strongly recommended to get a copy of the buffer source’s bytes at the beginning of the prose defining the operation.
</p>

<p>
~byte列の 参照／複製 を取得する明示的な注釈文を要することの意図は、仕様の査読者が，これらの~buffer~source型の利用に孕まれる問題を見つけ易くするためである。
◎
Requiring prose to explicitly get a reference to or copy of the bytes is intended to help specification reviewers look for problematic uses of these buffer source types.
</p></div>

<div class="note">
<p>注記：
~bufferを~~入力にとる~APIを設計するときは、 `ArrayBuffer$T や他の~view~型よりも `BufferSource^T ~typedefの利用が推奨される。
◎
When designing APIs that take a buffer, it is recommended to use the BufferSource typedef rather than ArrayBuffer or any of the view types.
</p>

<p>
~bufferを作成したり返す~APIを設計するときは、
`Uint8Array$T よりも `ArrayBuffer$T 型の利用が推奨される。
◎
When designing APIs that create and return a buffer, it is recommended to use the ArrayBuffer type rather than Uint8Array.
</p>
</div>

<p>
`切離された$ `ArrayBuffer$T ~objに対し，~buffer~sourceに保持されている~byte列の`参照／複製を取得-$しようと試みたときは、言語束縛に特有の方式で失敗することになる。
◎
Attempting to get a reference to or get a copy of the bytes held by a buffer source when the ArrayBuffer has been detached will fail in a language binding-specific manner.
</p>

<p class="note">注記：
~ES言語束縛において ~buffer~source型とのやりとりが どう働くかについては、`es-buffer-source-types$sec
を見よ。
◎
Note: See §3.2.25 Buffer source types below for how interacting with buffer source types works in the ECMAScript language binding.
</p>

<p class="issue">
これらの型や用語を利用する仕様~textの例を含ませる必要がある。
◎
We should include an example of specification text that uses these types and terms.
</p>


<div class="grammar">
BufferRelatedType
</div>

			</section>
			<section id="idl-frozen-array">
<h4 title="Frozen array types — FrozenArray&lt;T&gt;">2.12.32. 凍結~配列~型 — ~FrozenArray_T</h4>

<p>
`凍結~配列~型@
— ~FrozenArray_T —
は、［［［
一連の［
改変できない，型 %T の値
］からなる，固定長の配列
］を保持する~obj
］への参照
］を値にとり得るような，~parameter化された型である。
◎
A frozen array type is a parameterized type whose values are references to objects that hold a fixed length array of unmodifiable values. The values in the array are of type T.
</p>

<p>
`~FrozenArray_T$ 値は参照である
— 値の~listであり，値渡しである`連列~型$と違って。
◎
Since FrozenArray&lt;T&gt; values are references, they are unlike sequence types, which are lists of values that are passed by value.
</p>

<p>
~IDLにおいて，定数~凍結~配列~値を表現する仕方は、ない。
◎
There is no way to represent a constant frozen array value in IDL.
</p>

<p>
凍結~配列~型の`型~名$は、［
%T の型~名,
文字列 `Array^l
］の連結である。
◎
The type name of a frozen array type is the concatenation of the type name for T and the string “Array”.
</p>

			</section>
		</section>
		<section id="idl-extended-attributes">
<h3 title="Extended attributes">2.13. 拡張属性</h3>


<p>
`拡張属性@
は、［
`定義$ ／ `注釈付きの型$としての型 ／ `~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$ ／ `辞書~mb$ ／ `演算$引数
］上に現れ得る <em>注釈</em> （ annotation ）であり，［
言語束縛がこれらの構成子をどう取扱うことになるか
］を制御するために利用される。
拡張属性は `ExtendedAttributeList$g により指定される。
それは、全体が角括弧で括られた，いくつかの `ExtendedAttribute$g からなる~comma区切りの~listである。
◎
An extended attribute is an annotation that can appear on definitions, types as annotated types, interface members, interface mixin members, namespace members, dictionary members, and operation arguments, and is used to control how language bindings will handle those constructs. Extended attributes are specified with an ExtendedAttributeList, which is a square bracket enclosed, comma separated list of ExtendedAttributes.
</p>

<p>
文法~記号 `ExtendedAttribute$g は，ほぼ任意の~tok並びに合致するが、この文書で定義される`拡張属性$は，より制約された構文のみを受容する。
`~IDL片$に~~現れるどの拡張属性も、次の表に示す文法~記号のいずれかへの合致により、それが属する（ 1 個~以上の）形が決定される：
◎
The ExtendedAttribute grammar symbol matches nearly any sequence of tokens, however the extended attributes defined in this document only accept a more restricted syntax. Any extended attribute encountered in an IDL fragment is matched against the following five grammar symbols to determine which form (or forms) it is in:
</p>


<table><thead>
<tr><th>文法~記号◎ Grammar symbol
<th>形◎ Form
<th>例◎ Example
</thead><tbody>

<tr><td>`ExtendedAttributeNoArgs$g
<td>`引数をとらない@
◎
takes no arguments
<td>`[Replaceable]^c

<tr><td>`ExtendedAttributeArgList$g
<td>`引数~listを引数にとる@
◎
takes an argument list
<td>`[Constructor(double x, double y)]^c

<tr><td>`ExtendedAttributeNamedArgList$g
<td>`有名~引数~listを引数にとる@
◎
takes a named argument list
<td>`[NamedConstructor=Image(DOMString src)]^c

<tr><td>`ExtendedAttributeIdent$g
<td>`識別子を引数にとる@
◎
takes an identifier
<td>`[PutForwards=name]^c

<tr><td>`ExtendedAttributeIdentList$g
<td>`識別子~listを引数にとる@
◎
takes an identifier list
<td>`[Exposed=(Window,Worker)]^c

</tbody></table>

<p>
この仕様は、~ES言語束縛に適用できる，種々の拡張属性を定義する。
それらについては
`es-extended-attributes$sec
にて述べる。
各~拡張属性~定義において、上に挙げたどの形が許容されるかについて言明される。
◎
This specification defines a number of extended attributes that are applicable to the ECMAScript language binding, which are described in §3.3 ECMAScript-specific extended attributes. Each extended attribute definition will state which of the above five forms are allowed.
</p>

<div class="grammar">
ExtendedAttributeList
ExtendedAttributes
ExtendedAttribute
ExtendedAttributeRest
ExtendedAttributeInner
Other
OtherOrComma
IdentifierList
Identifiers
ExtendedAttributeNoArgs
ExtendedAttributeArgList
ExtendedAttributeIdent
ExtendedAttributeIdentList
ExtendedAttributeNamedArgList
</div>

		</section>
	</section>
	<section id="ecmascript-binding">
<h2 title="ECMAScript binding">3. ~ES言語束縛</h2>


<p>
この節では、
`idl$secにて定義された~IDLで記される`定義$が，
<cite>~ES言語~仕様</cite> `ECMA-262$r
により定義される~ESの中の特定0の構成子にどう対応するかを述べる。
◎
This section describes how definitions written with the IDL defined in §2 Interface definition language correspond to particular constructs in ECMAScript, as defined by the ECMAScript Language Specification [ECMA-262].
</p>

<p>
他が指定されない限り，この節に定義される~objは、
ECMA-262 の［
9.1 節, <a href="~TC39#sec-ordinary-object-internal-methods-and-internal-slots">普通の~objの内部~methと内部~slot</a> ／
`関数~obj$である場合は 9.3 節, `組込みの関数~obj$
］に述べられる，普通の~objであるとする。
◎
Unless otherwise specified, objects defined in this section are ordinary objects as described in ECMA-262 §9.1 Ordinary object internal methods and internal slots, and if the object is a function object, §9.3 Built-in function objects.
</p>

<p>
この節では、一部の~objに対し，一定の［
内部~meth ／ 内部~slot
］を再~定義する。
他の仕様も、［
`~ifc$の~instanceである`~platform~obj$
］の［
内部~meth ／ 内部~slot
］の定義を上書きして~MAY。
これらの，意味論が変更された~objは、~exotic~obj用の規則に則って扱われるものとする。
◎
This section may redefine certain internal methods and/or internal slots of objects. Other specifications may also override the definitions of any internal method and/or internal slots of a platform object that is an instance of an interface. These objects with changed semantics shall be treated in accordance with the rules for exotic objects.
</p>

<p class="advisement">
内部~ES~obj~methを上書きすることは、低~levelの演算であり，~objの挙動を普通の~objから違えさせ得るので、この便宜性は，保安／互換性のために必要とされない限り，利用されるべきでない。
これは現在、
`HTMLAllCollection$T, `Location$T
~ifcを定義するために利用されている。
`HTML$r
◎
As overriding internal ECMAScript object methods is a low level operation and can result in objects that behave differently from ordinary objects, this facility should not be used unless necessary for security or compatibility. This is currently used to define the HTMLAllCollection and Location interfaces. [HTML] 
</p>

<p>
他が指定されない限り，［
この節 ／ 他の仕様
］に定義される~exotic~objは、普通の~objと同じ`内部~slot$たちを持ち，その内部~methのうち代替の定義が与えられなかったものすべては，普通の~objの
<a href="~TC39#sec-ordinary-object-internal-methods-and-internal-slots">それら</a>
と同じとする。
◎
Unless otherwise specified, exotic objects defined in this section and other specifications have the same internal slots as ordinary objects, and all of the internal methods for which alternative definitions are not given are the same as those of ordinary objects.
</p>

<p>
他が指定されない限り，この節に定義される~objの `Extensible^sl 内部~slotの値は `true^jv とする。
◎
Unless otherwise specified, the [[Extensible]] internal slot of objects defined in this section has the value true.
</p>

<p>
他が指定されない限り，この節に定義される~objの `Prototype^sl 内部~slotは `ObjectPrototype$jI とする。
◎
Unless otherwise specified, the [[Prototype]] internal slot of objects defined in this section is %ObjectPrototype%.
</p>

<p>
この節にて述べる一部の~objは、
`~class文字列@
を持つものと定義される。
この文字列は、 `Object.prototype.toString^c が返す文字列に内包されることになる。
そのような~objは、その作成-時に，［
指定された文字列を値にとる，名前 `toStringTag$jS ~symbolの~prop
］を持た~MUST。
◎
Some objects described in this section are defined to have a class string, which is the string to include in the string returned from Object.prototype.toString. If an object has a class string, then the object must, at the time it is created, have a property whose name is the @@toStringTag symbol and whose value is the specified string.
</p>

<p class="issue">
`toStringTag$jS が
{ writable, enumerable, configurable }
かどうかを定義するべきである。
~ES仕様における すべての `toStringTag$jS ~propは、非 writable かつ非 enumerable であり，非 configurable である。
◎
Should define whether @@toStringTag is writable, enumerable and configurable. All @@toStringTag properties in the ECMAScript spec are non-writable and non-enumerable, and configurable.
</p>

<p id="ecmascript-abstractop">
この節の中の~algoは、手続きとその下位手続き, 数学的~演算, 等々の利用に関し，
<a href="~TC39#sec-algorithm-conventions">ECMA-262 Algorithm Conventions 節</a>
に記述されている表記規約を利用する。
この節は、 ECMA-262 の他所で定義される［
抽象~演算 ／ 記法
］も参照する。
◎
Algorithms in this section use the conventions described in ECMA-262 §5.2 Algorithm conventions, such as the use of steps and substeps, the use of mathematical operations, and so on. This section may also reference abstract operations and notations defined in other parts of ECMA-262.
</p>

<p>
~algoにおいて
“`~THROW@ `SomethingError^E”
と記される所では、`現在の~Realm$に属する新たな~ES `SomethingError^E ~objを構築して，
ECMA-262 の~algoとちょうど同じ様に投出することを意味する。
◎
When an algorithm says to throw a SomethingError then this means to construct a new ECMAScript SomethingError object in the current Realm and to throw it, just as the algorithms in ECMA-262 do.
</p>

<p>
~algoの手続きは，他の~algoや抽象~演算の中へ~callできるが、それらから投出される例外は
<a href="#_try-catch_">明示的に取扱われ</a>ていないことに注意。
~algoまたは抽象~演算により例外が投出され，それが~call元により明示的に取扱われない所では、~algoは終端され，その~call元の更に外へ伝播する，等々となる。
◎
Note that algorithm steps can call in to other algorithms and abstract operations and not explicitly handle exceptions that are thrown from them. When an exception is thrown by an algorithm or abstract operation and it is not explicitly handled by the caller, then it is taken to end the algorithm and propagate out to its caller, and so on.
</p>

<div class="example">
<p>
次の~algoを考える：
◎
Consider the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x ~LET この~algoに渡された~ES値
◎
Let x be the ECMAScript value passed in to this algorithm.
</li>
	<li>
%y ~LET `ToString$A( %x )
◎
Let y be the result of calling ToString(x).
</li>
	<li>
~RET %y
◎
Return y.
</li>
</ol>

<p>
`ToString$A は例外を投出し得るが（例えば~obj
`({ toString: function() { throw 1 } })^c
が渡されたとき），例外は上の~algoでは取扱われないので、もし投出された場合、この~algoは終端され，その例外は ~call元が在るならばその~call元に伝播する。
◎
Since ToString can throw an exception (for example if passed the object ({ toString: function() { throw 1 } })), and the exception is not handled in the above algorithm, if one is thrown then it causes this algorithm to end and for the exception to propagate out to its caller, if there is one.
</p>
</div>


		<section id="es-environment">
<h3 title="ECMAScript environment">3.1. ~ES環境</h3>

<p>
所与の［
`~IDL片$の集合
］に対する~ES実装においては、それらの`~IDL片$の中の それぞれの定義に対応する，~ES~objが存在することになる。
これらの~objは
`初期~obj@
と呼ばれ、次のものからなる：
◎
In an ECMAScript implementation of a given set of IDL fragments, there will exist a number of ECMAScript objects that correspond to definitions in those IDL fragments. These objects are termed the initial objects, and comprise the following:
</p>
<ul>
	<li>
`~ifc~obj$
◎
interface objects
</li>
	<li>
`旧来の呼戻~ifc~obj$
◎
legacy callback interface objects
</li>
	<li>
`有名~構築子$
◎
named constructors
</li>
	<li>
`~ifc原型~obj$
◎
interface prototype objects
</li>
	<li>
`有名~prop~obj$
◎
named properties objects
</li>
	<li>
`反復子~原型~obj$
◎
iterator prototype objects
</li>
	<li>
`属性~取得子$
◎
attribute getters
</li>
	<li>
`属性~設定子$
◎
attribute setters
</li>
	<li>
<a href="#es-operations">演算に対応する関数~obj</a>
◎
the function objects that correspond to operations
</li>
	<li>
<a href="#es-stringifier">文字列化子に対応する関数~obj</a>
◎
the function objects that correspond to stringifiers
</li>
	<li>
<a href="#es-iterator">反復子に対応する関数~obj</a>
◎
the function objects that correspond to iterators
</li>
	<li class="L2">
`~map~size取得子$
◎
map size getters
</li>
</ul>

<p>
各
<a href="~TC39#realm">~ES大域環境</a>
は、それぞれに一意な［
各種`初期~obj$からなる集合
］を持た~MUST。
この集合は、［
その環境~用の大域~objが作成された後
~AND
その環境に結付けられている~ES実行~文脈に制御が移る前
］に作成され~MUST。
所与の大域環境に属する すべての初期~objに対し、その `Prototype^sl は，同じ大域環境に属してい~MUST。
◎
Each ECMAScript global environment must have its own unique set of each of the initial objects, created before control enters any ECMAScript execution context associated with the environment, but after the global object for that environment is created. The [[Prototype]]s of all initial objects in a given global environment must come from that same global environment.
</p>

<p class="trans-note">【
<!-- 
objet’s global environment ／ global environment associated with an objet
-->
上の “大域環境に属する” という句は、所与の~objが同時に複数の大域環境に <em >属する</em> ことは，決してないことを含意する。
】</p>

<div class="example">
<p>
HTML ~UAにおいては、複数の frame や window が作成されたときに，複数の大域環境が存在し得る。
frame や window のそれぞれは、自身の`初期~obj$の集合を持つことになる。
次の HTML 文書の例のように：
◎
In an HTML user agent, multiple global environments can exist when multiple frames or windows are created. Each frame or window will have its own set of initial objects, which the following HTML document demonstrates:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
相異なる大域~環境
◎
Different global environments
</span>&lt;/title&gt;
&lt;iframe id=a&gt;&lt;/iframe&gt;
&lt;script&gt;
var %iframe = document.getElementById("a");
var %w = %iframe.contentWindow;     /* <span class="comment">
frame 内の大域~obj
◎
The global object in the frame
</span> */

Object == %w.Object;       /* <span class="comment">
ECMA-262 に則り， `false^jv に評価される
◎
Evaluates to false, per ECMA-262
</span> */
Node == %w.Node;                            /* <span class="comment"
	title="" id="cp-eval-false"
>`false^jv に評価される。
◎
Evaluates to false.
</span> */
%iframe instanceof %w.Node;                  /* <!--cp-eval-false--> */
%iframe instanceof %w.Object;                /* <!--cp-eval-false--> */
%iframe.appendChild instanceof Function;    /* <!--cp-eval-true--> */
%iframe.appendChild instanceof %w.Function;  /* <!--cp-eval-false--> */
&lt;/script&gt;
</pre>
</div>

<p>
他が指定されない限り、各~ES大域環境は，実装が~supportする すべての`~ifc$を
`公開する@
。
所与の~ES大域環境が公開しない~ifcは，
`es-interfaces$secにて与える要件に従うとは限らない。
◎
Unless otherwise specified, each ECMAScript global environment exposes all interfaces that the implementation supports. If a given ECMAScript global environment does not expose an interface, then the requirements given in §3.6 Interfaces are not followed for that interface.
</p>

<p class="note">注記：
これにより，例えば、［
Web Workers 用の~ES大域環境
］が`公開する$［
被support~ifcの集合
］を，［
~Web~page用の環境
］が公開するものと異なるようにすることも許容される。
◎
Note: This allows, for example, ECMAScript global environments for Web Workers to expose different sets of supported interfaces from those exposed in environments for Web pages.
</p>


<div class="p">
<p>
これを書いている時点では，~ES仕様は それを反映していないが、どの~ES~objにも`~Realm$が結付けられ~MUST
— この~Realmを指して， ~objが
`属する~Realm@†
という。
</p>

<p class="trans-note">【†
日本語表現の都合により，この訳では “属する” という句を用いることにする。
】</p>

<p>
各~objと~Realmを結付ける仕組みは、今の所，策定中にあるが：
</p>
<ul>
	<li>
`~platform~obj$については、それが`属する~Realm$は，その~objに`関連する~Realm$に等しい。
</li>
	<li>
~exoticでない`関数~obj$（すなわち，`~callable$~proxyでも~bindされた関数でもない）についても、それが`属する~Realm$は，その`関数~obj$の `Realm^sl 内部~slotの値に等しい。
</li>
</ul>

◎
Although at the time of this writing the ECMAScript specification does not reflect this, every ECMAScript object must have an associated Realm. The mechanisms for associating objects with Realms are, for now, underspecified. However, we note that in the case of platform objects, the associated Realm is equal to the object’s relevant Realm, and for non-exotic function objects (i.e. not callable proxies, and not bound functions) the associated Realm is equal to the value of the function object's [[Realm]] internal slot.
</div>


		</section>
		<section id="es-type-mapping">
<h3 title="ECMAScript type mapping">3.2. ~ES型との対応関係</h3>


<p>
この節では、~IDLにおける各~型が，~ESにおける型に どう対応付けられるかについて述べる。
◎
This section describes how types in the IDL map to types in ECMAScript.
</p>

<p>
以下の各~下位~節では、所与の［
~IDL型の値
］が，~ESの中では どう表現されるかを述べる。
各種~IDL型に対し、その型を期待する`~platform~obj$に~ES値が渡された際に
`~IDL値に変換-@
する方法, および
その型の~IDL値が~platform~objから返される際に
`~ES値に変換-@
する方法が述べられる。
◎
Each sub-section below describes how values of a given IDL type are represented in ECMAScript. For each IDL type, it is described how ECMAScript values are converted to an IDL value when passed to a platform object expecting that type, and how IDL values of that type are converted to ECMAScript values when returned from a platform object.
</p>

<p>
以下の各 下位~節と~algoは、［［
その見出しに挙げられる名前の型
］に拡張属性を適用して作成される，`注釈付きの型$
］にも適用されることに注意。
◎
Note that the sub-sections and algorithms below also apply to annotated types created by applying extended attributes to the types named in their headers.
</p>


			<section id="es-any">
<h4 title="any">3.2.1. `any^T</h4>


<p>
~IDL `any$T 型は、他のすべての~IDL型の和集合なので，どの~ES値~型にも対応し得る。
◎
Since the IDL any type is the union of all other IDL types, it can correspond to any ECMAScript value type.
</p>

<p id="es-to-any">
次の~algoにより，~ES値 %V は `any$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL any value by running the following algorithm:
</p>

<ol>
	<li>
~IF［
%V ~EQ `undefined^jv
］
⇒
~RET ~ES `undefined^jv 値を表現する特別な~objへの `object$T 参照
◎
If V is undefined, then return an object reference to a special object that represents the ECMAScript undefined value.
</li>
	<li>
~IF［
%V ~EQ `null^jv
］
⇒
~RET `null^V `object$T​? 参照
◎
If V is null, then return the null object? reference.
</li>
	<li>
<p>
~RET `Type$A( %V ) に応じて，次で与えられる値：
◎
↓</p>

		<dl class="switch">
			<dt>`Boolean^jt</dt>
			<dd>
同じ真偽~値を表現する `boolean$T 値
◎
If Type(V) is Boolean, then return the boolean value that represents the same truth value.
</dd>

			<dt>`Number^jt</dt>
			<dd>
`es-unrestricted-double$secに従って，
%V を `unrestricted double$T 値に変換した結果
◎
If Type(V) is Number, then return the result of converting V to an unrestricted double.
</dd>

			<dt>`String^jt</dt>
			<dd>
`es-DOMString$secに従って，
%V を `DOMString$T 値に変換した結果
◎
If Type(V) is String, then return the result of converting V to a DOMString.
</dd>

			<dt>`Symbol^jt</dt>
			<dd>
`es-symbol$secに従って，
%V を `symbol$T 値に変換した結果
◎
If Type(V) is Symbol, then return the result of converting V to a symbol.
</dd>

			<dt>`Object^jt</dt>
			<dd>
%V を参照する~IDL `object$T 値
◎
If Type(V) is Object, then return an IDL object value that references V.
</dd>
		</dl>
	</li>
</ol>

<p id="any-to-es">
~IDL `any$T 値 %V は，次のように`~ES値に変換-$される：
◎
An IDL any value is converted to an ECMAScript value as follows.＼
</p>

<ul>
	<li>
%V が［
~ES `undefined^jv 値を表現する特別な~objへの `object$T 参照
］ならば、~ES `undefined^jv 値に変換される。
◎
If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value.＼
</li>
	<li>
他の場合、この節の残りで述べられる， %V の`固有型$を変換するための規則に従う。
◎
Otherwise, the rules for converting the specific type of the IDL any value as described in the remainder of this section are performed.
</li>
</ul>

			</section>
			<section id="es-void">
<h4 title="void">3.2.2. `void^T</h4>


<p>
`void$T が~IDLに現れ得る唯一の場所は、`演算$の`返値型$である。
［
~IDLにおいて `void$T 返値型が指定されている演算
］を実装する［
`~platform~obj$上の関数
］は、 `undefined^jv 値を返さ~MUST。
<!-- % ` Function -->
◎
The only place that the void type may appear in IDL is as the return type of an operation. Functions on platform objects that implement an operation whose IDL specifies a void return type must return the undefined value.
</p>

<p>
［
~IDLにおいて `void$T 返値型が指定されている演算
］を実装する~ES関数は、どのような値を返しても~MAY（破棄されることになる）。
◎
ECMAScript functions that implement an operation whose IDL specifies a void return type may return any value, which will be discarded.
</p>
			</section>
			<section id="es-boolean">
<h4 title="boolean">3.2.3. `boolean^T</h4>


<p id="es-to-boolean">
次の~algoにより，~ES値 %V は `boolean$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL boolean value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x ~LET `ToBoolean$A( %V ) の算出-結果
◎
Let x be the result of computing ToBoolean(V).
</li>
	<li>
~RET ［
~ES `Boolean^jt 値 %x
］と同じ真偽~値を表現する~IDL `boolean$T 値
◎
Return the IDL boolean value that is the one that represents the same truth value as the ECMAScript Boolean value x.
</li>
</ol>

<p id="boolean-to-es">
~IDL `boolean$T 値［
`true^V／`false^V
］は，~ES［
`true^jv／`false^jv
］値に
<a href="#dfn-convert-idl-to-ecmascript-value">変換される</a>。
◎
The IDL boolean value true is converted to the ECMAScript true value and the IDL boolean value false is converted to the ECMAScript false value.
</p>


			</section>
			<section id="es-integer-types">
<h4>3.2.4〜8. 整数~型</h4>

<p>
この節に利用される数学的~演算は
<a href="~TC39#sec-algorithm-conventions">ECMA-262 Algorithm Conventions 節</a>
にて定義されるものも含め，数学的実数による数学的に正確な結果を算出していると解されるとする。
◎
Mathematical operations used in this section, including those defined in ECMA-262 §5.2 Algorithm conventions, are to be understood as computing exact mathematical results on mathematical real numbers.
</p>

<p>
`Number^jt 値 %x に対し，
“%x に演算する”
ことは、実質的に
“%x と同じ実数~値を表現する数学的実数に演算する”
ことの略記である。
◎
In effect, where x is a Number value, “operating on x” is shorthand for “operating on the mathematical real number that represents the same numeric value as x”.
</p>

<p class="trans-note">【
この訳では、原文の次に挙げる各~節の内容
— ~ES値 から各種~IDL整数~型 値への変換, およびその逆の変換の定義 —
を集約して，一括して与える。
】</p>

<dl>
	<dt id="es-byte">3.2.4.1. `byte^T</dt>
	<dt id="es-octet">3.2.4.2. `octet^T</dt>
	<dt id="es-short">3.2.4.3. `short^T</dt>
	<dt id="es-unsigned-short">3.2.4.4. `unsigned short^T</dt>
	<dt id="es-long">3.2.4.5. `long^T</dt>
	<dt id="es-unsigned-long">3.2.4.6. `unsigned long^T</dt>
	<dt id="es-long-long">3.2.4.7. `long long^T</dt>
	<dt id="es-unsigned-long-long">3.2.4.8. `unsigned long long^T</dt>
	<dd></dd>
</dl>

<p>
<a id="es-to-byte"></a
><a id="es-to-octet"></a
><a id="es-to-short"></a
><a id="es-to-unsigned-short"></a
><a id="es-to-long"></a
><a id="es-to-unsigned-long"></a
><a id="es-to-long-long"></a
><a id="es-to-unsigned-long-long"></a>
次の~algoにより，~ES値 %V は `整数~型$ %T の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL _T_ value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x ~LET ? `ConvertToInt$A( %V, %T )
◎
Let x be ? ConvertToInt(V, _N_, "signed|unsigned").
</li>
	<li>
~RET %x と同じ実数~値を表現する，型 %T の~IDL値
◎
Return the IDL _T_ value that represents the same numeric value as x.
</li>
</ol>

<p>
<a id="byte-to-es"></a
><a id="octet-to-es"></a
><a id="short-to-es"></a
><a id="unsigned-short-to-es"></a
><a id="long-to-es"></a
><a id="unsigned-long-to-es"></a
><a id="long-long-to-es"></a
><a id="unsigned-long-long-to-es"></a>
~IDL`整数~型$ %T の値 %V を`~ES値に変換-$した結果は， %T に応じて次で与えられる：
◎
The result of converting an IDL _T_ value to an ECMAScript value is a ...
</p>

<div class="p">
<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd id="_int-toES_">
%V に最も近い実数~値を表現する `Number^jt 値
⇒
2 数が等距離にある場合は，<em>仮数が偶数になる</em>方を選ぶとする
</dd>
	<dd>
%V が範囲 [%MIN, %MAX] に入るならば、その値 は %V と正確に同じ値を表現できることになる。†
</dd>

	<dt>他の整数~型</dt>
	<dd>
%V と同じ実数~値を表現する `Number^jt 値。
</dd>
	<dd>
その値は 範囲 [%MIN, %MAX] の整数になる。†
</dd>
</dl>

<p>†
上の %MIN, %MAX は、次節の `ConvertToInt$A にて与えられる。
</p>

◎
The result of converting an IDL _T_ value to an ECMAScript value is a Number value that represents the closest numeric value to the _T_, choosing the numeric value with an even significand if there are two equally close values. If the _T_ is in the range [_MIN_, _MAX_], then the Number will be able to represent exactly the same value as the _T_.
◎
Number that represents the same numeric value as the IDL _T_ value. The Number value will be an integer in the range [_MIN_, _MAX_].
</div>

				<section id="es-integer-types-abstract-ops">
<h5 title="Abstract operations">3.2.4.9. 抽象~演算</h5>

<p>
`IntegerPart@A( %n )：
◎
IntegerPart(n):
</p>

<ol class="algorithm">
	<li>
%r ~LET
<a href="~TC39#eqn-floor">floor</a>(
<a href="~TC39#eqn-abs">abs</a>( %n ) )
◎
Let r be floor(abs(n)).
</li>
	<li>
~IF［
%n ~LT 0
］
⇒
~RET −1 × %r
◎
If n &lt; 0, then return -1 × r.
</li>
	<li>
~RET %r
◎
Otherwise, return r.
</li>
</ol>

<p>
`ConvertToInt@A( %V, %T )
◎
ConvertToInt(V, bitLength, signedness):
</p>

<ol class="algorithm">
	<li>
<p>
( %MIN, %MAX, %N, %signed ) ~LET
%T に応じて，次の表で与えられる値：
</p>

<table id="matrix-integers">

<thead><tr><th>%T
<th>%N
<th>%MIN
<th>%MAX
<th>%signed
</thead>

<tbody><tr><th>`byte$T
<td>8
<td>−2`7^sup
<td>2`7^sup − 1
<td>~T

<tr><th>`octet$T
<td>8
<td>0
<td>2`8^sup − 1
<td>~F

<tr><th>`short$T
<td>16
<td>−2`15^sup
<td>2`15^sup − 1
<td>~T

<tr><th>`unsigned short$T
<td>16
<td>0
<td>2`16^sup − 1
<td>~F

<tr><th>`long$T
<td>32
<td>−2`31^sup
<td>2`31^sup − 1
<td>~T

<tr><th>`unsigned long$T
<td>32
<td>0
<td>2`32^sup − 1
<td>~F

<tr><th>`long long$T
<td>64
<td>−2`53^sup + 1
<td>2`53^sup − 1
<td>~T

<tr><th>`unsigned long long$T
<td>64
<td>0
<td>2`53^sup − 1
<td>~F

</tbody></table>

<p class="note">注記：
`long long^T, `unsigned long long^T の
%MIN, %MAX
を 2 の 53 乗で~~制限しているのは、［
`EnforceRange$x ／ `Clamp$x
］`拡張属性が結付けられ$ている `long long$T 型を，~ES `Number$jt 型の整数として一義的に表現できることを確保するためである。
</p>
◎
If bitLength is 64, then:
• Let upperBound be 253 − 1.
• If signedness is "unsigned", then let lowerBound be 0.
• Otherwise let lowerBound be −253 + 1.
◎
Note: this ensures long long types associated with [EnforceRange] or [Clamp] extended attributes are representable in ECMAScript’s Number type as unambiguous integers.
◎
Otherwise, if signedness is "unsigned", then:
• Let lowerBound be 0.
• Let upperBound be 2bitLength − 1.
◎
Otherwise:
• Let lowerBound be -2bitLength − 1.
• Let upperBound be 2bitLength − 1 − 1.
</li>
	<li>
%x ~LET ? `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<li>
~IF［
%x ~EQ −0
］
⇒
%x ~SET +0
◎
If x is −0, then set x to +0.
</li>
	<li>
<p>
~IF［
`EnforceRange$x `拡張属性が結付けられ$ている~IDL型への変換である
］：
◎
If the conversion is to an IDL type associated with the [EnforceRange] extended attribute, then:
</p>
		<ol>
			<li id="cp-x-isNonFinite">
~IF［
%x ~IN { `NaN^jv, +∞, −∞ }
］
⇒
~throwTypeError
◎
If x is NaN, +∞, or −∞, then throw a TypeError.
</li>
			<li id="cp-floor_x">
%x ~SET ! `IntegerPart$A( %x )
◎
Set x to ! IntegerPart(x).
</li>
			<li>
~IF［
%x ~LT %MIN
］~OR［
%x ~GT %MAX
］
⇒
~throwTypeError
◎
If x &lt; lowerBound or x &gt; upperBound, then throw a TypeError.
</li>
			<li>
~RET %x
◎
Return x.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%x ~NEQ `NaN^jv
］~AND［
`Clamp$x `拡張属性が結付けられ$ている~IDL型への変換である
］：
◎
If x is not NaN and the conversion is to an IDL type associated with the [Clamp] extended attribute, then:
</p>

		<ol>
			<li>
%x ~SET <a href="~TC39#eqn-min">min</a>(
<a href="~TC39#eqn-max">max</a>(
%x, %MIN ), %MAX)
◎
Set x to min(max(x, lowerBound), upperBound).
</li>
			<li>
~RET %x を最も近い整数に丸めた結果
⇒
2 つの整数と等距離にある場合は偶数を選び，−0 より +0 の方を選ぶとする
◎
Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than −0.
</li>
			<li>
~RET %x
◎
Return x.
</li>
		</ol>
	</li>
	<li>
~IF［
%x ~IN { `NaN^jv, +0, +∞, −∞ }
］
⇒
~RET 0
◎
If x is NaN, +0, +∞, or −∞, then return +0.
</li>
	<!--cp-floor_x-->
	<li>
%x ~SET %x
<a href="~TC39#eqn-modulo">modulo</a>
2<sup>%N</sup>
◎
Set x to x modulo 2bitLength.
</li>
	<li>
~IF［
%signed ~EQ ~T
］~AND［
%x  ~GTE 2<sup>%N − 1</sup>
］
⇒
~RET %x − 2<sup>%N</sup>
◎
If signedness is "signed" and x ≥ 2bitLength − 1, then return x − 2bitLength.
</li>
	<li>
~RET %x
◎
Otherwise, return x.
</li>
</ol>

				</section>
			</section>
			<section id="es-float">
<h4 title="float">3.2.5. `float^T</h4>


<p id="es-to-float">
次の~algoにより，~ES値 %V は `float$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL float value by running the following algorithm:
</p>

<ol class="algorithm">
	<li id="cp-ToNumber">
%x ~LET ? `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<!--cp-x-isNonFinite-->
	<li id="cp-let-S-to754">
%S ~LET ［
−0 を除く有限 IEEE 754 単精度 浮動小数点~値の集合に， 2 つの特別な値{ 2`128^sup, −2`128^sup }
を追加した集合
］
◎
Let S be the set of finite IEEE 754 single-precision floating point values except −0, but with two special values added: 2^128 and −2^128.
</li>
	<li id="cp-round-x-to-y">
%y ~LET 
%S の中で %x に最も近い実数~値
⇒
2 数が等距離にある場合は，<em>仮数が偶数になる</em>方を選ぶとする
⇒
この目的においては， 2 つの特別な値 2`128^sup, −2`128^sup の仮数は偶数と見なされる。
◎
Let y be the number in S that is closest to x, selecting the number with an even significand if there are two equally close values. (The two special values 2^128 and −2^128 are considered to have even significands for this purpose.)
</li>
	<li>
~IF［
%y ~IN { 2`128^sup, −2`128^sup }
］
⇒
~throwTypeError
◎
If y is 2^128 or −2^128, then throw a TypeError.
</li>
	<li id="cp-if-y-0-x-lt0">
~IF［
%y ~EQ +0
］~AND［
%x ~LT 0
］
⇒
~RET −0
◎
If y is +0 and x is negative, return −0.
</li>
	<li id="cp-ret-y">
~RET %y
◎
Return y.
</li>
</ol>

<p id="float-to-es">
~IDL `float$T 値を`~ES値に変換-$した結果は、その
~IDL値と同じ実数~値を表現する `Number^jt 値になる。
◎
The result of converting an IDL float value to an ECMAScript value is the Number value that represents the same numeric value as the IDL float value.
</p>
			</section>
			<section id="es-unrestricted-float">
<h4 title="unrestricted float">3.2.6. `unrestricted float^T</h4>


<p id="es-to-unrestricted-float">
次の~algoにより，~ES値 %V は `unrestricted float$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL unrestricted float value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF［
%x ~EQ `NaN^jv
］
⇒
~RET ~bit~pattern 0x7fc00000 の IEEE 754 NaN 値 `IEEE-754$r を表現する~IDL `unrestricted float$T 値
◎
If x is NaN, then return the IDL unrestricted float value that represents the IEEE 754 NaN value with the bit pattern 0x7fc00000 [IEEE-754].
</li>
	<!--cp-let-S-to754-->
	<!--cp-round-x-to-y-->
	<li>
~IF［
%y ~EQ 2`128^sup
］
⇒
~RET +∞
◎
If y is 2^128, return +∞.
</li>
	<li>
~IF［
%y ~EQ −2`128^sup 
］
⇒
~RET −∞
◎
If y is −2^128, return −∞.
</li>
	<!--cp-if-y-0-x-lt0-->
	<!--cp-ret-y-->
</ol>

<p class="note">注記：
~ES `NaN^jv 値は唯 1 個しかないので，特定0の単精度 IEEE 754 NaN 値に正準化されなければならない。
上で言及した NaN 値は、単純に，その~bit~patternが無符号 32 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Note: Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular single precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 32 bit integer.
</p>

<p id="unrestricted-float-to-es">
~IDL `unrestricted float$T 値を`~ES値に変換-$した結果は、次の `Number^jt になる：
◎
The result of converting an IDL unrestricted float value to an ECMAScript value is a Number:
</p>

<ol>
	<li>
その~IDL値 ~EQ NaN ならば `NaN^jv
◎
If the IDL unrestricted float value is a NaN, then the Number value is NaN.
</li>
	<li>
他の場合，その~IDL値と同じ実数~値を表現する（~~唯一の） `Number^jt 値。
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted float value.
</li>
</ol>
			</section>
			<section id="es-double">
<h4 title="double">3.2.7. `double^T</h4>


<p id="es-to-double">
次の~algoにより，~ES値 %V は `double$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL double value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<!--cp-x-isNonFinite-->
	<li>
~RET %x と同じ実数~値を表現する~IDL `double$T 値
◎
Return the IDL double value that represents the same numeric value as x.
</li>
</ol>

<p id="double-to-es">
~IDL `double$T 値を`~ES値に変換-$した結果は、その
~IDL値と同じ実数~値を表現する `Number^jt 値になる。
◎
The result of converting an IDL double value to an ECMAScript value is the Number value that represents the same numeric value as the IDL double value.
</p>
			</section>
			<section id="es-unrestricted-double">
<h4 title="unrestricted double">3.2.8. `unrestricted double^T</h4>


<p id="es-to-unrestricted-double">
次の~algoにより，~ES値 %V は `unrestricted double$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL unrestricted double value by running the following algorithm:
</p>

<ol class="algorithm">
	<!--cp-ToNumber-->
	<li>
~IF［
%x ~EQ `NaN^jv
］
⇒
~RET ~bit~pattern 0x7ff8000000000000 の IEEE 754 NaN 値 `IEEE-754$r を表現する~IDL `unrestricted double$T 値
◎
If x is NaN, then return the IDL unrestricted double value that represents the IEEE 754 NaN value with the bit pattern 0x7ff8000000000000 [IEEE-754].
</li>
	<li>
~RET %x と同じ実数~値を表現する~IDL `unrestricted double$T 値
◎
Return the IDL unrestricted double value that represents the same numeric value as x.
</li>
</ol>

<p class="note">注記：
~ES `NaN^jv 値は唯 1 個しかないので，特定0の倍精度 IEEE 754 NaN 値に正準化されなければならない。
上で言及した NaN 値は、単純に，その~bit~patternが無符号 64 ~bit整数に解釈されたときに最低~値の quiet NaN になることから，選ばれている。
◎
Note: Since there is only a single ECMAScript NaN value, it must be canonicalized to a particular double precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an unsigned 64 bit integer.
</p>

<p id="unrestricted-double-to-es">
~IDL `unrestricted double$T 値を`~ES値に変換-$した結果は、次の `Number^jt になる：
◎
The result of converting an IDL unrestricted double value to an ECMAScript value is a Number:
</p>

<ol>
	<li>
その~IDL値 ~EQ NaN ならば `NaN^jv 。
◎
If the IDL unrestricted double value is a NaN, then the Number value is NaN.
</li>
	<li>
他の場合，その~IDL値と同じ実数~値を表現する（~~唯一の） `Number^jt 値。
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted double value.
</li>
</ol>
			</section>
			<section id="es-DOMString">
<h4 title="DOMString">3.2.9. `DOMString^T</h4>


<p id="es-to-DOMString">
次の~algoにより，~ES値 %V は `DOMString$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL DOMString value by running the following algorithm:
</p>


<ol class="algorithm">
	<li>
~IF［
%V ~EQ `null^jv
］~AND［
`TreatNullAs$x `拡張属性が結付けられ$ている~IDL型への変換である
］
⇒
~RET 空~文字列を表現する `DOMString$T 値
◎
If V is null and the conversion is to an IDL type associated with the [TreatNullAs] extended attribute, then return the DOMString value that represents the empty string.
</li>
	<li>
%x ~LET `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~RET ［
その~ES `String^jt 値 %x が表現するものと同じ，符号単位の並び
］を表現する~IDL `DOMString$T 値
◎
Return the IDL DOMString value that represents the same sequence of code units as the one the ECMAScript String value x represents.
</li>
</ol>

<p id="DOMString-to-es">
~IDL `DOMString$T 値を`~ES値に変換-$した結果は、
その~IDL `DOMString$T が表現するものと同じ,
`符号単位$の並びを表現する `String^jt 値になる。
◎
The result of converting an IDL DOMString value to an ECMAScript value is the String value that represents the same sequence of code units that the IDL DOMString represents.
</p>
			</section>
			<section id="es-ByteString">
<h4 title="ByteString">3.2.10. `ByteString^T</h4>

<p id="es-to-ByteString">
次の~algoにより，~ES値 %V は `ByteString$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL ByteString value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%x ~LET `ToString$A( %V )
◎
Let x be ToString(V).
</li>
	<li>
~IF［
%x の中に 値 ~GT 255 なる`要素$eSがある
］
⇒
~throwTypeError
◎
If the value of any element of x is greater than 255, then throw a TypeError.
</li>
	<li>
~RET ［［
各~要素の値 ~SET %x の対応する要素の値
］にされた，
長さ ~EQ %x の長さ
］の~IDL `ByteString$T 値
◎
Return an IDL ByteString value whose length is the length of x, and where the value of each element is the value of the corresponding element of x.
</li>
</ol>

<p id="ByteString-to-es">
~IDL `ByteString$T 値 %V を`~ES値に変換-$した結果は、次を満たすようにされた
`String^jt 値になる
⇒
［
長さ ~EQ %V の長さ
］~AND［
各 `要素$eSに対し，その値 ~EQ %V の対応する要素の値
］
◎
The result of converting an IDL ByteString value to an ECMAScript value is a String value whose length is the length of the ByteString, and the value of each element of which is the value of the corresponding element of the ByteString.
</p>

			</section>
			<section id="es-USVString">
<h4 title="USVString">3.2.11. `USVString^T</h4>

<p id="es-to-USVString">
次の~algoにより，~ES値 %V は `USVString$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL USVString value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%string ~LET  %V を `DOMString$T 型の`~IDL値に変換-$した結果
◎
Let string be the result of converting V to a DOMString.
</li>
	<li>
~RET
%string を `~Unicode~scalar値~列に変換-$した結果の~IDL `USVString$T 値
◎
Return an IDL USVString value that is the result of converting string to a sequence of Unicode scalar values.
</li>
</ol>

<p id="USVString-to-es">
次の~algoにより，~IDL `USVString$T 値 %V は`~ES値に変換-$される：
◎
An IDL USVString value is converted to an ECMAScript value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%scalarValues ~LET `USVString$T が表現する`~Unicode~scalar値$の並び
◎
Let scalarValues be the sequence of Unicode scalar values the USVString represents.
</li>
	<li>
%string ~LET %scalarValues を~UTF-16に符号化した結果の`符号単位$の並び
◎
Let string be the sequence of code units that results from encoding scalarValues in UTF-16.
</li>
	<li>
~RET
%string と同じ`符号単位$の並びを表現する `String^jt 値
◎
Return the String value that represents the same sequence of code units as string.
</li>
</ol>


			</section>
			<section id="es-object">
<h4 title="object">3.2.12. `object^T</h4>


<p>
~IDL `object$T 値は、~ES `Object^jt 値により表現される。
◎
IDL object values are represented by ECMAScript Object values.
</p>

<p id="es-to-object">
次の~algoにより，~ES値 %V は `object$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL object value by running the following algorithm:
</p>

<ol class="algorithm">
	<li id="cp-type-not-object">
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(V) is not Object, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objを参照する~IDL `object$T 値
◎
Return the IDL object value that is a reference to the same object as V.
</li>
</ol>

<p id="object-to-es">
~IDL `object$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL object value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL object represents.
</p>
			</section>
			<section id="es-symbol">
<h4 title="symbol">3.2.13. `symbol^T</h4>

<p>
~IDL `symbol$T 値は、~ES `Symbol^jt 値により表現される。
◎
IDL symbol values are represented by ECMAScript Symbol values.
</p>

<p id="es-to-symbol">
次の~algoにより，~ES値 %V は `symbol$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL symbol value by running the following algorithm:
</p>

<ol>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Symbol^jt
］
⇒
~throwTypeError
◎
If Type(V) is not Symbol, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~symbolを参照する~IDL `symbol$T 値
◎
Return the IDL symbol value that is a reference to the same symbol as V.
</li>
</ol>


<p id="symbol-to-es">
~IDL `symbol$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~symbolへの参照を表現する `Symbol^jt 値である。
◎
The result of converting an IDL symbol value to an ECMAScript value is the Symbol value that represents a reference to the same symbol that the IDL symbol represents.
</p>

			</section>
			<section id="es-interface">
<h4 title="Interface types">3.2.14. ~ifc型</h4>


<p>
~IDL`~ifc型$の値は、~ES `Object^jt 値（`関数~obj$も含む）により表現される。
◎
IDL interface type values are represented by ECMAScript Object values (including function objects).
</p>

<p id="es-to-interface">
次の~algoにより，~ES値 %V は `~ifc型$ %I の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL interface type value by running the following algorithm (where I is the interface):
</p>

<ol class="algorithm">
	<!--cp-type-not-object-->
	<li>
~IF［
%V は %I を実装する`~platform~obj$である
］
⇒
~RET その~platform~objへの参照を表現する，~IDL`~ifc型$の値
◎
If V is a platform object that implements I, then return the IDL interface type value that represents a reference to that platform object.
</li>
	<li>
~IF［
%V は［
`es-user-objects$secの規則に則って %I を実装する
］ものと見なされる`利用者~obj$である
］
⇒
~RET その利用者~objへの参照を表現し,
`呼戻~文脈$として`現任の設定群~obj$を伴う，~IDL`~ifc型$の値
◎
If V is a user object that is considered to implement I according to the rules in §3.9 User objects implementing callback interfaces, then return the IDL interface type value that represents a reference to that user object, with the incumbent settings object as the callback context.
</li>
	<li id="cp-throw-typeerror">
~throwTypeError
◎
Throw a TypeError.
</li><!-- % * -->
</ol>

<p id="interface-to-es">
~IDL`~ifc型$の値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値になる。
◎
The result of converting an IDL interface type value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL interface type value represents.
</p>
			</section>
			<section id="es-dictionary">
<h4 title="Dictionary types">3.2.15. 辞書~型</h4>


<p>
~IDL`辞書~型$の値は、~ES `Object^jt 値により表現される。
その~obj（またはその原型鎖）上の~propが`辞書~mb$に対応する。
◎
IDL dictionary type values are represented by ECMAScript Object values. Properties on the object (or its prototype chain) correspond to dictionary members.
</p>

<p id="es-to-dictionary">
次の~algoにより，~ES値 %V は `辞書~型$ %D の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL dictionary type value by running the following algorithm (where D is the dictionary type):
</p>

<ol class="algorithm">
	<li><!--  title="cp-type-not-object" -->
~IF［
`Type$A( %V ) ~NIN { `Undefined^jt, `Null^jt, `Object^jt }
］
⇒
~throwTypeError
◎
If Type(V) is not Undefined, Null or Object, then throw a TypeError.
</li>
	<li>
%辞書~値 ~LET 型 %D の空の辞書~値（初期~時にはどの`辞書~mb$も`不在$と見なされる）
◎
Let dict be an empty dictionary value of type D; every dictionary member is initially considered to be not present.
</li>
	<li id="cp-let-inherited-dictionaries">
%辞書~list ~LET %D および %D のすべての`被継承~辞書$を，先祖から先に，継承-順に並べた~list
◎
Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
</li>
	<li>
<p id="cp-for-each-dictionary">
%辞書~list 内の~EACH ( %辞書 ) に対し，順に：
◎
For each dictionary dictionary in dictionaries, in order:
</p>
		<ol>
			<li>
<p id="cp-foreach-mb">
%辞書 上に宣言されている~EACH ( 辞書~mb %member ) に対し，辞書式~順序で：
◎
For each dictionary member member declared on dictionary, in lexicographical order:
</p>

				<ol>
					<li id="cp-let-key">
%key ~LET %member の`識別子$
◎
Let key be the identifier of member.
</li>
					<li>
<p>
%value ~LET
`Type$A( %V ) に応じて，次で与えられる~ES値：
◎
Let value be an ECMAScript value, depending on Type(V):
</p>

						<dl class="switch">
							<dt>`Undefined^jt</dt>
							<dt>`Null^jt</dt>
							<dd>
`undefined^jv
◎
undefined
</dd>

							<dt>その他</dt>
							<dd>
? `Get$A( %key, %V )
◎
? Get(V, key)
</dd>
						</dl>
					</li>
					<li>
~IF［
%value ~NEQ `undefined^jv
］
⇒
%idlValue ~LET %value を %member に宣言されている型の`~IDL値に変換-$した結果
◎
If value is not undefined, then:
• Let idlValue be the result of converting value to an IDL value whose type is the type member is declared to be of.
• Set the dictionary member on dict with key name key to the value idlValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF［
%member は`既定~値$diC %d を持つ
］
⇒
%idlValue ~LET %d
◎
Otherwise, if value is undefined but member has a default value, then:

• Let idlValue be member’s default value.
• Set the dictionary member on dict with key name key to the value idlValue. This dictionary member is considered to be present.
</li>
					<li>
~ELIF［
%member は `必須~辞書~mb$である
］
⇒
~throwTypeError
◎
Otherwise, if value is undefined and member is a required dictionary member, then throw a TypeError.
</li>
					<li>
~ELSE
⇒
~CONTINUE
◎
↑</li>
					<li>
%辞書~値 上の ~key名 %key の辞書~mbの値 ~SET %idlValue
（この辞書~mbは`在する$ものと見なされるようになる）
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %辞書~値
◎
Return dict.
</li>
</ol>

<p class="note">注記：
`辞書~mb$が~ES~obj上で検索される順序は、~objの~prop列挙~順序と同じになるとは限らない。
◎
Note: The order that dictionary members are looked up on the ECMAScript object are not necessarily the same as the object’s property enumeration order.
</p>

<p id="dictionary-to-es">
次の~algoにより，~IDL辞書 %D 型の値 %V は `Object^jt 型の`~ES値に変換-$される：
◎
An IDL dictionary value V is converted to an ECMAScript Object value by running the following algorithm (where D is the dictionary):
</p>

<ol class="algorithm">
	<li>
%O ~LET ! `ObjectCreate$A( `ObjectPrototype$jI )
◎
Let O be ! ObjectCreate(%ObjectPrototype%).
</li>
	<!--cp-let-inherited-dictionaries-->
	<li>
<!--cp-for-each-dictionary-->
		<ol>
			<li>
<!--cp-foreach-mb-->
				<ol>
					<!--cp-let-key-->
					<li>
<p>
~IF［
名前 %key の辞書~mbが %V 内に`在する$
］：
◎
If the dictionary member named key is present in V, then:
</p>
						<ol>
							<li>
%idlValue ~LET %V 上の %member の値
◎
Let idlValue be the value of member on V.
</li>
							<li>
%value ~LET %idlValue を`~ES値に変換-$した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
							<li>
! `CreateDataProperty$A( %O, %key, %value )
を遂行する
◎
Perform ! CreateDataProperty(O, key, value).
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>
			</section>
			<section id="es-enumeration">
<h4 title="Enumeration types">3.2.16. 列挙~型</h4>


<p>
~IDL`列挙~型$の値は、~ES `String^jt 値により表現される。
◎
IDL enumeration types are represented by ECMAScript String values.
</p>

<p id="es-to-enumeration">
次の~algoにより，~ES値 %V は `列挙$型 %E の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL enumeration type value as follows (where E is the enumeration):
</p>

<ol class="algorithm">
	<li>
%S ~LET `ToString$A( %V )
◎
Let S be the result of calling ToString(V).
</li>
	<li>
~IF［
%S は %E の`列挙~値$のいずれでもない
］
⇒
~throwTypeError
◎
If S is not one of E’s enumeration values, then throw a TypeError.
</li>
	<li>
~RET 型 %E の， %S に等しい列挙~値
◎
Return the enumeration value of type E that is equal to S.
</li>
</ol>

<p id="enumeration-to-es">
~IDL`列挙$型の値を`~ES値に変換-$した結果は、［
その`列挙~値$と同じ`符号単位$の並び
］を表現する `String^jt 値になる。
◎
The result of converting an IDL enumeration type value to an ECMAScript value is the String value that represents the same sequence of code units as the enumeration value.
</p>
			</section>
			<section id="es-callback-function">
<h4 title="Callback function types">3.2.17. 呼戻~関数~型</h4>


<p>
~IDL`呼戻~関数~型$の値は、~ES`関数~obj$により表現される。
ただし， `TreatNonObjectAsNull$x の場合は、任意の~objをとり得る。
◎
IDL callback function types are represented by ECMAScript function objects, except in the [TreatNonObjectAsNull] case, when they can be any object.
</p>

<p id="es-to-callback-function">
次の~algoにより，~ES値 %V は `呼戻~関数~型$の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL callback function type value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`IsCallable$A( %V ) ~EQ ~F
］~AND ［
~IDL値への変換は［
`~nullable$ `呼戻~関数$型 ~AND
`TreatNonObjectAsNull$x 注釈付き
］である`属性$への代入-に因り，遂行されては<em>いない</em>
］
⇒
~throwTypeError <!-- % * -->
◎
If the result of calling IsCallable(V) is false and the conversion to an IDL value is not being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then throw a TypeError.
</li>
	<li>
~RET
%V が表現するものと同じ~objを表現し,
`呼戻~文脈$として`現任の設定群~obj$を伴う，~IDL`呼戻~関数~型$の値
◎
Return the IDL callback function type value that represents a reference to the same object that V represents, with the incumbent settings object as the callback context.
</li>
</ol>

<p id="callback-function-to-es">
~IDL`呼戻~関数~型$の値を`~ES値に変換-$した結果は、その`呼戻~関数~型$の値が表現するものと同じ~objへの参照になる。
◎
The result of converting an IDL callback function type value to an ECMAScript value is a reference to the same object that the IDL callback function type value represents.
</p>
			</section>
			<section id="es-nullable-type">
<h4 title="Nullable types — T?">3.2.18. ~nullable型 — `~varT?^T</h4>

<p>
~IDL`~nullable型$の値は、その`内縁~型$に対応する~ES型の値か, または
~ES `null^jv 値により表現される。
◎
IDL nullable type values are represented by values of either the ECMAScript type corresponding to the inner IDL type, or the ECMAScript null value.
</p>

<p>
この節を通して、
`~varT?^T は，`内縁~型$が %T である~IDL`~nullable型$を表す。
</p>

<p id="es-to-nullable">
次の~algoにより，~ES値 %V は  `~varT?^T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL nullable type T? value (where T is the inner type) as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~AND ［
%V から~IDL値への変換は［
`~nullable$<!-- missing id="dfn-nullable" -->`呼戻~関数$型 ~AND
`TreatNonObjectAsNull$x 注釈付き
］である`属性$への代入-に因り遂行されている
］
⇒
~RET 型 `~varT?^T の値 `null^V
◎
If Type(V) is not Object, and the conversion to an IDL value is being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [TreatNonObjectAsNull], then return the IDL nullable type T? value null.
</li>
	<li>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］
⇒
~RET 型 `~varT?^T の値 `null^V
◎
Otherwise, if V is null or undefined, then return the IDL nullable type T? value null.
</li>
	<li>
~RET %V を`内縁~型$ %T に対する規則に従って`~IDL値に変換-$した結果
◎
Otherwise, return the result of converting V using the rules for the inner IDL type T.
</li>
</ol>

<p id="nullable-to-es">
型 `~varT?^T の~IDL値 %V を`~ES値に変換-$した結果は、［
%V ~EQ `null^V ならば `null^jv ／
~ELSE_ %V を型 %T の値として`~ES値に変換-$した結果
］になる。
◎
The result of converting an IDL nullable type value to an ECMAScript value is:
• If the IDL nullable type T? value is null, then the ECMAScript value is null.
• Otherwise, the ECMAScript value is the result of converting the IDL nullable type value to the inner IDL type T.
</p>

			</section>
			<section id="es-sequence">
<h4 title="Sequences — sequence&lt;T&gt;">3.2.19. 連列 — ~sequence_T</h4>

<p>
~IDL `~sequence_T$ 値は、~ES `Array^t 値により表現される。
◎
IDL sequence&lt;T&gt; values are represented by ECMAScript Array values.
</p>

<p id="es-to-sequence">
次の~algoにより，~ES値 %V は `~sequence_T$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL sequence&lt;T&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(V) is not Object, throw a TypeError.
</li>
	<li id="cp-checkiter-V">
%method ~LET ? `GetMethod$A( %V, `iterator$jS )
◎
Let method be ? GetMethod(V, @@iterator).
</li>
	<li>
~IF［
%method ~EQ `undefined^jv
］
⇒
~throwTypeError
◎
If method is undefined, throw a TypeError.
</li>
	<li>
( %V, %method )
から
`~sequence_T$ 型の`連列~値を作成-$した結果
◎
Return the result of creating a sequence from V and method.
</li>
</ol>

<p id="sequence-to-es">
次の~algoにより，型 `~sequence_T$ の~IDL連列~値 %S は
`Array^jt 型の`~ES値に変換-$される：
◎
An IDL sequence value S of type sequence&lt;T&gt; is converted to an ECMAScript Array object as follows:
</p>

<ol class="algorithm">
	<li>
%n ~LET %S の長さ
◎
Let n be the length of S.
</li>
	<li>
%A ~LET 式 `[]^c で作成されるものと同じ，新たな `Array^jt ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
	<li>
%i ~LET 0
◎
Initialize i to be 0.
</li>
	<li>
<!--cp-while-i-n-->
		<ol>
			<li>
%V ~LET %S 内の~index %i に位置する値
◎
Let V be the value in S at index i.
</li>
			<li>
%E ~LET %V を`~ES値に変換-$した結果
◎
Let E be the result of converting V to an ECMAScript value.
</li>
			<li>
%P ~LET `ToString$A( %i )
◎
Let P be the result of calling ToString(i).
</li>
			<li>
`CreateDataProperty$A( %A, %P, %E ) を~callする
◎
Call CreateDataProperty(A, P, E).
</li>
			<li id="cp-inc-i">
%i ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
~RET %A
◎
Return A.
</li>
</ol>




				<section id="create-sequence-from-iterable">
<h5 title="Creating a sequence from an iterable">3.2.19.1. 可反復から連列を作成する</h5>

<p>
所与の
( 可反復 %iterable, 反復子~取得子 %method )
から
型 `~sequence_T$ の~IDL値を作成するときは、次の手続きを遂行する：
◎
To create an IDL value of type sequence&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%iter ~LET ? `GetIterator$A(%iterable, %method)
◎
Let iter be ? GetIterator(iterable, method).
</li>
	<li>
%i ~LET 0
◎
Initialize i to be 0.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Repeat
</p>
		<ol>
			<li>
%next ~LET ? `IteratorStep$A( %iter )
◎
Let next be ? IteratorStep(iter).
</li>
			<li>
~IF［
%next ~EQ `false^jv
］
⇒
~RET
~index %j に位置する要素の値が %S<sub>%j</sub> で, 長さ %i の，型
`~sequence_T$ の~IDL連列~値
◎
If next is false, then return an IDL sequence value of type sequence&lt;T&gt; of length i, where the value of the element at index j is Sj.
</li>
			<li>
%nextItem ~LET ? `IteratorValue$A( %next )
◎
Let nextItem be ? IteratorValue(next).
</li>
			<li>
%S<sub>%i</sub> ~LET %nextItem を型 %T の`~IDL値に変換-$した結果
◎
Initialize Si to the result of converting nextItem to an IDL value of type T.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
</ol>
				</section>

<div class="example">
<p>
次の`~ifc$は
連列~型の引数を伴う`演算$と伴に
連列~型の`属性$を定義する。
◎
The following interface defines an attribute of a sequence type as well as an operation with an argument of a sequence type.
</p>

<pre class="webidl">
interface Canvas {

  sequence&lt;DOMString&gt; getSupportedImageCodecs();

  void drawPolygon(sequence&lt;double&gt; %coordinates);
  sequence&lt;double&gt; getLastDrawnPolygon();

  /* <!--cp-some-code--> */
};
</pre>

<p>
この~ifcの~ES実装においては、型［
`String^jt ／ `Number^jt
］の要素からなる `Array^t ~objが，それぞれ［
`sequence&lt;DOMString&gt;^T ／
`sequence&lt;double&gt;^T
］の表現-に利用される。
この `Array^t ~objは実質的には値渡しであり、
`getSupportedImageCodecs()^c
関数が~callされる度に，新たな `Array^t が返され、
`Array^t が `drawPolygon^c に渡されたときは常に，その参照は~call完了-後には保有されないことになる。
◎
In an ECMAScript implementation of this interface, an Array object with elements of type String is used to represent a sequence&lt;DOMString&gt;, while an Array with elements of type Number represents a sequence&lt;double&gt;. The Array objects are effectively passed by value; every time the getSupportedImageCodecs() function is called a new Array is returned, and whenever an Array is passed to drawPolygon no reference will be kept after the call completes.
</p>

<pre class="es-code">
/* <span class="comment">
`Canvas^T の~instanceを得る。
`getSupportedImageCodecs()^c は、 2 個の `DOMString^T 値
`image/png^l, `image/svg+xml^l
からなる連列を返すものとする。
◎
Obtain an instance of Canvas.  Assume that getSupportedImageCodecs()
returns a sequence with two DOMString values: "image/png" and "image/svg+xml".
</span> */
var %canvas = getCanvas();

/* <span class="comment">
長さ 2 の `Array^t ~obj。
◎
An Array object of length 2.
</span> */
var %supportedImageCodecs = %canvas.getSupportedImageCodecs();

/* <span class="comment" id="cp-eval-img-png">
`image/png^l に評価される。
◎
Evaluates to "image/png".
</span> */
%supportedImageCodecs[0];

/* <span class="comment">
%canvas`.getSupportedImageCodecs()^c が~callされる度に，新たな `Array^t object が返される。
したがって，返された `Array^t を改変しても，後続の関数~callで返される値には影響しないことになる。
◎
Each time canvas.getSupportedImageCodecs() is called, it returns a new Array object.  Thus modifying the returned Array will not affect the value returned from a subsequent call to the function.
</span> */
%supportedImageCodecs[0] = `image/jpeg^l;

/* <!--cp-eval-img-png--> */
%canvas.getSupportedImageCodecs()[0];

/* <span class="comment">
各~callで新たな `Array^t ~objが返されるので、これは `false^jv に評価される。
◎
This evaluates to false, since a new Array object is returned each call.
</span> */
%canvas.getSupportedImageCodecs() == %canvas.getSupportedImageCodecs();


/* <span class="comment">
実数~値の `Array^t は...
◎
An Array of Numbers...
</span> */
var %a = [0, 0, 100, 0, 50, 62.5];

/* <span class="comment">
...は `sequence&lt;double&gt;^T を期待する~platform~objに渡すことができる
◎
...can be passed to a platform object expecting a sequence&lt;double&gt;.
</span> */
%canvas.drawPolygon(%a);

/* <span class="comment">
各~要素は最初に `ToNumber$A() の~callにより， `double^T に変換される。
したがって，次の~callは `drawPolygon()^c が返る前に `hi^l が alert されることを除き，前のものと等価になる。
◎
Each element will be converted to a double by first calling ToNumber().
So the following call is equivalent to the previous one, except that
"hi" will be alerted before drawPolygon() returns.
</span> */
%a = [
    false,
    '',
    { valueOf: function() { alert('hi'); return 100; } },
    0,
    '50',
    new Number(62.5)
];
%canvas.drawPolygon(%a);

/* <span class="comment">
`Array^t は実質的に値渡しなので，`drawPolygon()^c に渡された `Array^t を改変しても， `Canvas^T には効果を及ぼさないことが保証される。
◎
Modifying an Array that was passed to drawPolygon() is guaranteed not to
have an effect on the Canvas, since the Array is effectively passed by value.
</span> */
%a[4] = 20;
var %b = %canvas.getLastDrawnPolygon();
alert(%b[4]);    /* <span class="comment">
これは `50^l を alert することになる。
◎
This would alert "50".
</span> */
</pre>
</div>

			</section>
			<section id="es-record">
<h4 title="Records — record&lt;K, V&gt;">3.2.20. ~record — ~record_KV</h4>

<p>
~IDL `record$T 値は、~ES `Object^jt 値により表現される。
◎
IDL record&lt;K, V&gt; values are represented by ECMAScript Object values.
</p>

<p id="es-to-record">
次の~algoにより，~ES値 %O は `~record_KV$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value O is converted to an IDL record&lt;K, V&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %O ) ~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(O) is not Object, throw a TypeError.
</li>
	<li>
%result ~LET 新たな空の`~record_KV$ 値
◎
Let result be a new empty instance of record&lt;K, V&gt;.
</li>
	<li>
%keys ~LET ? %O.`OwnPropertyKeys^sl()
◎
Let keys be ? O.[[OwnPropertyKeys]]().
</li>
	<li>
<p>
%keys 内の~EACH ( %key ) に対し：
◎
For each key of keys:
</p>

		<ol>
			<li>
%desc ~LET ? %O.`GetOwnProperty^sl( %key )
◎
Let desc be ? O.[[GetOwnProperty]](key).
</li>
			<li>
<p>
~IF［
%desc ~NEQ `undefined^jv
］~AND［
%desc.`Enumerable^sl ~EQ `true^jv
］：
◎
If desc is not undefined and desc.[[Enumerable]] is true:
</p>

				<ol>
					<li>
%typedKey ~LET %key を %K 型の`~IDL値に変換-$した結果
◎
Let typedKey be key converted to an IDL value of type K.
</li>
					<li>
%value ~LET ? `Get$A( %O, %key)
◎
Let value be ? Get(O, key).
</li>
					<li>
%typedValue ~LET %value を %V 型の`~IDL値に変換-$した結果
◎
Let typedValue be value converted to an IDL value of type V.
</li>
					<li>
<p>
%result[%typedKey] ~SET %typedValue
◎
Set result[typedKey] to typedValue.
</p>

<p class="note">注記：
%O が~proxy~objである場合には、
%typedKey がすでに %result 内にあることも あり得る。
◎
Note: it’s possible that typedKey is already in result, if O is a proxy object.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>


<p id="record-to-es">
次の~algoにより，~IDL `record$T 値 %D は`~ES値に変換-$される：
◎
An IDL record&lt;…&gt; value D is converted to an ECMAScript value as follows:
</p>

<ol class="algorithm">
	<li>
%result ~LET ! `ObjectCreate$A( `ObjectPrototype$jI )
◎
Let result be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
<p>
%D 内の~EACH ( %key → %value ) に対し：
◎
For each key → value of D:
</p>

		<ol>
			<li>
%esKey ~LET %key を`~ES値に変換-$した結果
◎
Let esKey be key converted to an ECMAScript value.
</li>
			<li>
%esValue ~LET %value を`~ES値に変換-$した結果
◎
Let esValue be value converted to an ECMAScript value.
</li>
			<li>
%created ~LET ! `CreateDataProperty$A( %result, %esKey, %esValue )
◎
Let created be ! CreateDataProperty(result, esKey, esValue).
</li>
			<li>
~Assert：
%created ~EQ `true^jv
◎
Assert: created is true.
</li>
		</ol>
	</li>
	<li>
~RET %result
◎
Return result.
</li>
</ol>

<div class="example">

<p>
`record&lt;DOMString, double&gt;^T 型の引数として~ES値 `{b: 3, a: 4}^jv を渡した結果は、~IDL値 «[ "b" → 3, "a" → 4 ]» になる。
◎
Passing the ECMAScript value {b: 3, a: 4} as a record&lt;DOMString, double&gt; argument would result in the IDL value «[ "b" → 3, "a" → 4 ]».
</p>

<p>
~recordが考慮するのは，
<a href="~TC39#sec-own-property">own</a>
<a href="~TC39#sec-property-attributes">enumerable</a>
~propに限られるので、引数を返すだけの~IDL演算
<span class="block">
<samp>`record&lt;DOMString, double&gt;^T identity(`record&lt;DOMString, double&gt;^T %arg)</samp>
</span>
が与えられたとき、次の~codeは 各~表明（ `assert^c ）に合格する：
◎
Records only consider own enumerable properties, so given an IDL operation record&lt;DOMString, double&gt; identity(record&lt;DOMString, double&gt; arg) which returns its argument, the following code passes its assertions:
</p>

<pre class="es-code">
let %proto = {a: 3, b: 4};
let %obj = {__proto__: proto, d: 5, c: 6}
Object.defineProperty(%obj, "e", {value: 7, enumerable: false});
let %result = identity(%obj);
console.assert(%result.a === undefined);
console.assert(%result.b === undefined);
console.assert(%result.e === undefined);
let %entries = Object.entries(%result);
console.assert(%entries[0][0] === "d");
console.assert(%entries[0][1] === 5);
console.assert(%entries[1][0] === "c");
console.assert(%entries[1][1] === 6);
</pre>

<p>
~recordの［
~key, 値
］は、他から拘束され得る
— ~keyは、 3 種の文字列~型に拘束されるに過ぎないが。
例えば：
◎
Record keys and values can be constrained, although keys can only be constrained among the three string types. The following conversions have the described results:
</p>

<table><thead><tr><th>渡された値◎ Value
<th>値が渡された型◎ Passed to type
<th>結果◎ Result
</thead>

<tbody><tr><td>`{"😞": 1}^jv
<td>`record&lt;ByteString, double&gt;^T
<td>`TypeError^jE

<tr><td>`{"\uD83D": 1}^jv
<td>`record&lt;USVString, double&gt;^T
<td>«[ "\uFFFD" → 1 ]»

<tr><td>`{"\uD83D": {hello: "world"}}^jv
<td>`record&lt;DOMString, double&gt;^T
<td>«[ "\uD83D" → 0 ]»
</tbody></table>

</div>

			</section>
			<section id="es-promise">

<h4 title="Promise types — Promise&lt;T&gt;">3.2.21. ~promise型 — ~promise_T</h4>

<p>
~IDL`~promise型$値は、~ES `Promise$t ~objにより表現される。
◎
IDL promise type values are represented by ECMAScript Promise objects.
</p>

<p id="es-to-promise">
次の~algoにより，~ES値 %V は `~promise_T$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL Promise&lt;T&gt; value as follows:
</p>

<ol class="algorithm">
	<li>
%promise ~LET 
! `Call$A(`Promise_resolve$jI, `Promise$jI, «%V»)
◎
Let promise be ! Call(%Promise_resolve%, %Promise%, «V»)
</li>
	<li>
~RET %promise と同じ~objへの参照である~IDL`~promise型$値
◎
Return the IDL promise type value that is a reference to the same object as promise.
</li>
</ol>

<p id="promise-to-es">
~IDL`~promise型$値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Promise$t 値になる。
◎
The result of converting an IDL promise type value to an ECMAScript value is the Promise value that represents a reference to the same object that the IDL promise type represents.
</p>

<p>
~promiseが決着したとき、すなわち，それが［
充足された, または却下された
］とき、それぞれに応じて，何らかの手続きが遂行され得る
— そのいずれかは省略され得る
【これらの手続きは、~promiseを利用する仕様が指定する】
。
仕様にて
`~promiseが決着したときの手続きを遂行する@
と記された所では、次の手続きに従わ~MUST：
◎
One can perform some steps once a promise is settled. There can be one or two sets of steps to perform, covering when the promise is fulfilled, rejected, or both. When a specification says to perform some steps once a promise is settled, the following steps must be followed:
</p>

<ol class="algorithm">

	<li>
%promise ~LET 型 `~promise_T$ の~promise~obj
◎
Let promise be the promise object of type Promise&lt;T&gt;.
</li>
	<li>
<p>
%onFulfilled ~LET 被呼出時の挙動が次で与えられる，新たな`組込みの関数~obj$
◎
Let onFulfilled be a new built-in function object whose behavior when invoked is as follows:
</p>

		<ol>
			<li>
<p>
~IF［
%T は `void$T 型である
］：
◎
If T is void, then:
</p>
				<ol>
					<li>
~RET
~promiseの充足-時に走らすことが要求されている手続きを遂行した結果
◎
Return the result of performing any steps that were required to be run if the promise was fulfilled.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
：
◎
Otherwise, T is a type other than void:
</p>

				<ol>
					<li>
%V ~LET %onFulfilled に渡された 1 個目の引数
◎
Let V be the first argument to onFulfilled.
</li>
					<li>
%value ~LET %V を型 %T の`~IDL値に変換-$した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
					<li>
~IF［
~promiseの充足-時に走らすことが要求されている手続きはある
］
⇒
~RET ~promiseの値として %value を渡して，その手続きを遂行した結果
◎
If there are no steps that are required to be run if the promise was fulfilled, then return undefined.
◎
Otherwise, return the result of performing any steps that were required to be run if the promise was fulfilled, with value as the promise’s value.
</li>
					<li>
~RET `undefined^jv
◎
↑</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%onRejected ~LET 被呼出時の挙動が次で与えられる，新たな`組込みの関数~obj$：
◎
Let onRejected be a new built-in function object whose behavior when invoked is as follows:
</p>
		<ol>

			<li>
%R ~LET %onRejected に渡された 1 個目の引数
◎
Let R be the first argument to onRejected.
</li>
			<li>
%reason ~LET %R を `any$T 型の`~IDL値に変換-$した結果
◎
Let reason be the result of converting R to an IDL value of type any.
</li>
			<li>
~IF［
~promiseの却下-時に走らすことが要求されている手続きはある
］
⇒
~RET 却下~事由として %reason を渡して，その手続きを遂行した結果
◎
If there are no steps that are required to be run if the promise was rejected, then return undefined.
◎
Otherwise, return the result of performing any steps that were required to be run if the promise was rejected, with reason as the rejection reason.
</li>
			<li>
~RET `undefined^jv
◎
↑</li>
		</ol>
	</li>
	<li>
%then ~LET `Get$A( %promise, `then^l )
◎
Let then be the result of calling the internal [[Get]] method of promise with property name “then”.
</li>
	<li>
~IF［
`IsCallable$A( %then ) ~EQ ~F
］
⇒
~throwTypeError
◎
If IsCallable(then) is false, then throw a TypeError.
</li>
	<li>
~RET ［
`this^jv 値に %promise,
その 2 個の引数に ( %onFulfilled, %onRejected )
］を渡して，%then を~callした結果
◎
Return the result of calling then with promise as the this value and onFulfilled and onRejected as its two arguments.
</li>
</ol>

<p class="issue">
この用語を利用する仕様の記述例を含める必要がある。
◎
Include an example of how to write spec text using this term.
</p>


			</section>
			<section id="es-union">
<h4 title="Union types">3.2.22. 共用体~型</h4>


<p>
~IDL`共用体~型$の値は、共用体の`~mb型$に対応する~ES値により表現される。
◎
IDL union type values are represented by ECMAScript values that correspond to the union’s member types.
</p>

<p id="es-to-union">
次の~algoにより，~ES値 %V は `共用体~型$ %U の`~IDL値に変換-$される：
◎
To convert an ECMAScript value V to an IDL union type value is done as follows:
</p>

<ol class="algorithm">
	<li>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］~AND［
%U は`~nullable型を内包する$
］
⇒
~RET ~IDL値 `null^V
◎
If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
</li>
	<li>
%型たち ~LET %U の`平坦化~mb型$
◎
Let types be the flattened member types of the union type.
</li>
	<li>
<p>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］：
◎
If V is null or undefined, then:
</p>
		<ol>
			<li>
~IF［
%型たち に`辞書~型$が含まれている
］
⇒
~RET %V をその辞書~型の`~IDL値に変換-$した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `~platform~obj$である
］：
◎
If V is a platform object, then:
</p>

		<ol>
			<li>
~IF［
%型たち に %V が実装する`~ifc型$が含まれている
］
⇒
~RET ~obj %V への参照である~IDL値
◎
If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
</li>
			<li id="cp-object-in-types">
~IF［
%型たち に `object$T が含まれている
］
⇒
~RET ~obj %V への参照である~IDL値
◎
If types includes object, then return the IDL value that is a reference to the object V.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `DOMException^t ~platform~objである
］：
◎
If V is a DOMException platform object, then:
</p>
		<ol>
			<li>
~IF［
%型たち に `DOMException$T または `Error$T が含まれている
］
⇒
~RET %V を その型の`~IDL値に変換-$した結果
◎
If types includes DOMException or Error, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
%型 ~LET `Type$A( %V )
◎
↓</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
~AND
%V は `ErrorData^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has an [[ErrorData]] internal slot), then:
</p>
		<ol>
			<li>
~IF［
%型たち に `Error$T が含まれている
］
⇒
~RET %V を `Error$T 型の`~IDL値に変換-$した結果
◎
If types includes Error, then return the result of converting V to Error.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
~AND
%V は `ArrayBufferData^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has an [[ArrayBufferData]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型たち に `ArrayBuffer$T が含まれている
］
⇒
~RET %V を `ArrayBuffer$T 型の`~IDL値に変換-$した結果
◎
If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
~AND
%V は `DataView^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has a [[DataView]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型たち に `DataView$T が含まれている
］
⇒
~RET %V を `DataView$T 型の`~IDL値に変換-$した結果
◎
If types includes DataView, then return the result of converting V to DataView.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
~AND
%V は `TypedArrayName^sl `内部~slot$を持つ
］：
◎
If Type(V) is Object and V has a [[TypedArrayName]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型たち に［
`有型~配列~型$であって，［
その型~名<!-- ＊名前 --> ~EQ %V の `TypedArrayName^sl `内部~slot$の値
］なるもの
］が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
`IsCallable$A( %V ) ~EQ ~T
］：
◎
If IsCallable(V) is true, then:
</p>
		<ol>
			<li>
~IF［
%型たち に`呼戻~関数$型が含まれている
］
⇒
~RET %V をその呼戻~関数~型の`~IDL値に変換-$した結果
◎
If types includes a callback function type, then return the result of converting V to that callback function type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Object^jt
］：
◎
If Type(V) is Object, then:
</p>
		<ol>
			<li>
<p>
~IF［
%型たち に`連列~型$が含まれている
］：
◎
If types includes a sequence type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<li>
~IF［
%method ~NEQ `undefined^jv
］
⇒
~RET
( %V, %method )
から
その型の`連列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a sequence of that type from V and method.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%型たち に`凍結~配列~型$が含まれている
］：
◎
If types includes a frozen array type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<li>
~IF［
%method ~NEQ `undefined^jv
］
⇒
~RET
( %V, %method )
から
その型の`凍結~配列~値を作成-$した結果
◎
If method is not undefined, return the result of creating a frozen array of that type from V and method.
</li>
				</ol>
			</li>
			<li>
~IF［
%型たち に`辞書~型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
			<li>
~IF［
%型たち に`~record型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a record type, then return the result of converting V to that record type.
</li>
			<li>
~IF［
%型たち に`呼戻~ifc$型が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a callback interface type, then return the result of converting V to that interface type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Boolean^jt
］：
◎
If Type(V) is Boolean, then:
</p>
		<ol>
			<li id="cp-boolean-in-types">
~IF［
%型たち に `boolean$T が含まれている
］
⇒
~RET %V を `boolean$T 型の`~IDL値に変換-$した結果
◎
If types includes a boolean, then return the result of converting V to boolean.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~EQ `Number^jt
］：
◎
If Type(V) is Number, then:
</p>
		<ol>
			<li id="cp-numeric-in-types">
~IF［
%型たち に`実数~型$が含まれている
］
⇒
~RET %V をその`実数~型$の`~IDL値に変換-$した結果
◎
If types includes a numeric type, then return the result of converting V to that numeric type.
</li>
		</ol>
	</li>
	<li>
~IF［
%型たち に`文字列~型$が含まれている
］
⇒
~RET %V をその型の`~IDL値に変換-$した結果
◎
If types includes a string type, then return the result of converting V to that type.
</li>
	<!--cp-numeric-in-types-->
	<!--cp-boolean-in-types-->
	<!--cp-throw-typeerror-->
</ol>

<p id="union-to-es">
~IDL共用体~型の値 %U は，次に従って`~ES値に変換-$される：
◎
An IDL union type value is converted to an ECMAScript value as follows.
</p>

<ul>
	<li>
%U が［
~ES `undefined^jv 値を表現する特別な~objへの `object$T 参照
］ならば、~ES `undefined^jv 値に変換される。
◎
If the value is an object reference to a special object that represents an ECMAScript undefined value, then it is converted to the ECMAScript undefined value.＼
</li>
	<li>
他の場合、この`es-type-mapping$secにて述べている， %U の`固有型$を変換するための規則に従う。
◎
Otherwise, the rules for converting the specific type of the IDL union type value as described in this section (§3.2 ECMAScript type mapping).
</li>
</ul>

			</section>
			<section id="es-Error">
<h4 title="Error">3.2.23. `Error^T</h4>

<p>
~IDL `Error$T 値は、［
~native~ES `Error$t ~obj ／
`DOMException$T ~platform~obj
］により表現される。
◎
IDL Error values are represented by native ECMAScript Error objects and by DOMException platform objects.
</p>


<p id="es-to-Error">
次の~algoにより，~ES値 %V は `Error$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL Error value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `ErrorData^sl `内部~slot$を持たない
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have an [[ErrorData]] internal slot, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `Error$T 値
◎
Return the IDL Error value that is a reference to the same object as V.
</li>
</ol>


<p id="Error-to-es">
~IDL `Error$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Error$t 値である。
◎
The result of converting an IDL Error value to an ECMAScript value is the Error value that represents a reference to the same object that the IDL Error represents.
</p>

			</section>
			<section id="es-DOMException">
<h4 title="DOMException">3.2.24. `DOMException^T</h4>

<p>
~IDL `DOMException$T 値は、~ES `Object^jt 値により表現される。
◎
IDL DOMException values are represented by ECMAScript Object values.
</p>

<p id="es-to-DOMException">
次の~algoにより，~ES値 %V は `DOMException$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL DOMException value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `DOMException$T を表現する~platform~objでない
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V is not a platform object that represents a DOMException, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `DOMException$T 値
◎
Return the IDL DOMException value that is a reference to the same object as V.
</li>
</ol>

<p id="DOMException-to-es">
~IDL `DOMException$T 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値である。
◎
The result of converting an IDL DOMException value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL DOMException represents.
</p>


			</section>
			<section id="es-buffer-source-types">
<h4 title="Buffer source types">3.2.25. ~buffer~source型</h4>

<p>
~IDL`~buffer~source型$の値は、対応する~ES~classの~objにより表現され，~ES［
`ArrayBuffer$t ／ `SharedArrayBuffer$t
］~objに~backされ得るが、後者に~backできるのは，当の型に `AllowShared$x `拡張属性が結付けられ$ている場合に限られる。
◎
Values of the IDL buffer source types are represented by objects of the corresponding ECMAScript class, with the additional restriction that unless the type is associated with the [AllowShared] extended attribute, they can only be backed by ECMAScript ArrayBuffer objects, and not SharedArrayBuffer objects.
</p>

<p id="es-to-buffer-source">
次の~algoにより，~ES値 %V は `ArrayBuffer$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL ArrayBuffer value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `ArrayBufferData^sl `内部~slot$を持たない
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have an [[ArrayBufferData]] internal slot, then throw a TypeError.
</li>
	<li>
~IF［
`AllowShared$x `拡張属性が結付けられ$ている~IDL型への変換でない
］~AND［
`IsSharedArrayBuffer$A( %V ) ~EQ `true^jv
］
⇒
~throwTypeError
◎
If the conversion is not to an IDL type associated with the [AllowShared] extended attribute, and IsSharedArrayBuffer(V) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `ArrayBuffer$T 値
◎
Return the IDL ArrayBuffer value that is a reference to the same object as V.
</li>
</ol>

<p id="buffer-source-to-es">
次の~algoにより，~ES値 %V は `DataView$T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL DataView value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `DataView^sl `内部~slot$を持たない
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have a [[DataView]] internal slot, then throw a TypeError.
</li>
	<li id="cp-is-conv-not-AllowShared">
~IF［
`AllowShared$x `拡張属性が結付けられ$ている~IDL型への変換でない
］~AND［
`IsSharedArrayBuffer$A( %V.`ViewedArrayBuffer^sl ) ~EQ `true^jv
］
⇒
~throwTypeError
◎
If the conversion is not to an IDL type associated with the [AllowShared] extended attribute, and IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `DataView$T 値
◎
Return the IDL DataView value that is a reference to the same object as V.
</li>
</ol>

<p>
%T をいずれかの`有型~配列~型$とするとき、次の~algoにより，~ES値 %V は %T 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array or Float64Array value by running the following algorithm:
</p>

<ol class="algorithm">
	<li>
%有型~配列~名 ~LET ［
%T は`注釈付きの型$であるならば %T の`内縁~型$anOの`型~名$ ／
~ELSE_ %T の`型~名$
］
◎
Let T be the IDL type V is being converted to.
◎
Let typedArrayName be the name of T’s inner type if T is an annotated type, or the name of T otherwise.
</li>
	<li>
~IF［
`Type$A( %V ) ~NEQ `Object^jt
］~OR［
%V は `TypedArrayName^sl `内部~slot$を持たない
］~OR［
%V の `TypedArrayName^sl `内部~slot$の値 ~NEQ %有型~配列~名
］
⇒
~throwTypeError
◎
If Type(V) is not Object, or V does not have a [[TypedArrayName]] internal slot with a value equal to typedArrayName, then throw a TypeError.
</li>
	<!--cp-is-conv-not-AllowShared-->
	<li>
~RET %V と同じ~objへの参照である~IDL %T 型~値
◎
Return the IDL value of type T that is a reference to the same object as V.
</li>
</ol>

<p>
いずれの`~buffer~source型$に対しても、その型の~IDL値 %V を`~ES値に変換-$した結果は，
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値である。
◎
The result of converting an IDL value of any buffer source type to an ECMAScript value is the Object value that represents a reference to the same object that the IDL value represents.
</p>

<p>
~buffer~source %O は［
~ES［
`ArrayBuffer$t ／ `DataView$t
］ ／
`有型~配列~型$
］~objであるとする。
%O に保持されている~byte列の`参照／複製を取得-$するときは、次の手続きに従わ~MUST：
◎
When getting a reference to or getting a copy of the bytes held by a buffer source that is an ECMAScript ArrayBuffer, DataView or typed array object, these steps must be followed:
</p>

<ol class="algorithm">
	<li>
%arrayBuffer ~LET %O
◎
Let O be the ECMAScript object that is the buffer source.
◎
Initialize arrayBuffer to O.
</li>
	<li>
%offset ~LET 0
◎
Initialize offset to 0.
</li>
	<li>
%length ~LET 0
◎
Initialize length to 0.
</li>
	<li>

<p>
~IF［
%O は `ViewedArrayBuffer^sl `内部~slot$を持つ
］：
◎
If O has a [[ViewedArrayBuffer]] internal slot, then:
</p>

		<ol>
			<li>
%arrayBuffer ~SET
%O の `ViewedArrayBuffer^sl `内部~slot$の値
◎
Set arrayBuffer to the value of O’s [[ViewedArrayBuffer]] internal slot.
</li>
			<li>
~IF［
%arrayBuffer ~EQ `undefined^jv
］
⇒
~throwTypeError
◎
If arrayBuffer is undefined, then throw a TypeError.
</li>
			<li>
%offset ~SET
%O の `ByteOffset^sl `内部~slot$の値
◎
Set offset to the value of O’s [[ByteOffset]] internal slot.
</li>
			<li>
%length ~SET
%O の `ByteLength^sl `内部~slot$の値
◎
Set length to the value of O’s [[ByteLength]] internal slot.
</li>
		</ol>
	</li>
	<li>
~ELSE
%length ~SET
%O の `ArrayBufferByteLength^sl `内部~slot$の値
◎
Otherwise, set length to the value of O’s [[ArrayBufferByteLength]] internal slot.
</li>
	<li>
~IF［
`IsDetachedBuffer$A( %O )
］
⇒
~throwTypeError
◎
If IsDetachedBuffer(O), then throw a TypeError.
</li>
	<li>
%data ~LET
%O の `ArrayBufferData^sl `内部~slot$の値
◎
Let data be the value of O’s [[ArrayBufferData]] internal slot.
</li>
	<li>
~RET ［
%data 内の~byte~offset %offset の所から， %length 個の~byte
］［
への参照, または の複製
］（いずれか要求された方）。
◎
Return a reference to or copy of (as required) the length bytes in data starting at byte offset offset.
</li>
</ol>

<p>
`ArrayBuffer$T ~objを
`切離す@
ときは、次の手続きに従わ~MUST：
◎
To detach an ArrayBuffer, these steps must be followed:
</p>

<ol class="algorithm">
	<li>
%O ~LET その `ArrayBuffer$T である~ES~obj
◎
Let O be the ECMAScript object that is the ArrayBuffer.
</li>
	<li>
! `DetachArrayBuffer$A( %O )
を遂行する
◎
Perform ! DetachArrayBuffer(O).
</li>
</ol>

			</section>
			<section id="es-frozen-array" class="L2">
<h4 title="Frozen arrays — FrozenArray&lt;T&gt;">3.2.26. 凍結~配列 — ~FrozenArray_T</h4>


<p>
`凍結~配列~型$の値は、~~凍結された（ frozen ）~ES `Array^t ~obj参照により表現される。
◎
Values of frozen array types are represented by frozen ECMAScript Array object references.
</p>

<p>
次の~algoにより，~ES値 %V は `~FrozenArray_T$ 型の`~IDL値に変換-$される：
◎
An ECMAScript value V is converted to an IDL FrozenArray&lt;T&gt; value by running the following algorithm:
</p>


<ol class="algorithm">
	<li>
%値~list ~LET %V を ~sequence_T 型の`~IDL値に変換-$した結果
◎
Let values be the result of converting V to IDL type sequence&lt;T&gt;.
</li>
	<li>
~RET %値~list から`凍結~配列を作成-$した結果
◎
Return the result of creating a frozen array from values.
</li>
</ol>

<p>
型 %T の値の連列 %S から
`凍結~配列を作成-@
するときは、次の手続きに従う：
◎
To create a frozen array from a sequence of values of type T, follow these steps:
</p>

<ol class="algorithm">
	<li>
%array ~LET %S を`~ES値に変換-$した結果
◎
Let array be the result of converting the sequence of values of type T to an ECMAScript value.
</li>
	<li>
`SetIntegrityLevel$A(%array, <code>"frozen"</code>)
を遂行する
◎
Perform SetIntegrityLevel(array, "frozen").
</li>
	<li>
~RET %array
◎
Return array.
</li>
</ol>

<p>
~IDL `~FrozenArray_T$ 値 %V を`~ES値に変換-$した結果は、
%V が表現するものと同じ~objへの参照を表現する `Object^jt 値である。
◎
The result of converting an IDL FrozenArray&lt;T&gt; value to an ECMAScript value is the Object value that represents a reference to the same object that the IDL FrozenArray&lt;T&gt; represents.
</p>

				<section id="create-frozen-array-from-iterable">
<h5 title="Creating a frozen array from an iterable">3.2.26.1. 可反復から凍結~配列を作成する</h5>

<p>
所与の
( 可反復 %iterable, 反復子~取得子 %method )
から
型 `~FrozenArray_T$ の~IDL値を作成するときは、次の手続きを遂行する：
◎
To create an IDL value of type FrozenArray&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%値~list ~LET
( %iterable, %method )
から
型 %T の`連列~値を作成-$した結果
◎
Let values be the result of creating a sequence of type sequence&lt;T&gt; from iterable and method.
</li>
	<li>
~RET %値~list から`凍結~配列を作成-$した結果
◎
Return the result of creating a frozen array from values.
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="es-extended-attributes">
<h3 title="ECMAScript-specific extended attributes">3.3. ~ESに特有の拡張属性</h3>


<p>
この節では、その存在tが~ES言語束縛にのみ影響する いくつかの`拡張属性$を定義する。
◎
This section defines a number of extended attributes whose presence affects only the ECMAScript binding.
</p>

			<section id="AllowShared">
<h4>3.3.1. `AllowShared^x</h4>

<p>
`AllowShared$x `拡張属性$が`~buffer~source型$に現れた場合、その型の値は
— 共有されない `ArrayBuffer$t のみならず —
~ES `SharedArrayBuffer$t にも~backできるような，新たな~IDL型を作成する。
【~back — 下層の~dataを保持しておく】
◎
If the [AllowShared] extended attribute appears on one of the buffer source types, it creates a new IDL type that allows the buffer source type to be backed by an ECMAScript SharedArrayBuffer, instead of only by a non-shared ArrayBuffer.
</p>


<p>
`AllowShared$x 拡張属性は、`引数をとらない$ことが要求される。
◎
The [AllowShared] extended attribute must take no arguments.
</p>

<p>
`~buffer~source型$でない型に `AllowShared$x `拡張属性が結付けられ$ては~MUST_NOT。
◎
A type that is not a buffer source type must not be associated with the [AllowShared] extended attribute.
</p>

<p>
`AllowShared$x の利用に課される特有の要件については、
`es-buffer-source-types$secの［
~ES値から~IDL`~buffer~source型$へ変換する規則
］を見よ。
◎
See the rules for converting ECMAScript values to IDL buffer source types in §3.2.25 Buffer source types for the specific requirements that the use of [AllowShared] entails.
</p>

<div class="example">

<p>
次の`~IDL片$においては、一方の演算は 引数 %pixels に `AllowShared$x 拡張属性を利用し，他方はそうでない：
◎
In the following IDL fragment, one operation’s argument uses the [AllowShared] extended attribute, while the other does not:
</p>

<pre class="webidl">
interface RenderingContext {
  void readPixels(long %width, long %height, BufferSource %pixels);
  void readPixelsShared(long %width, long %height, [AllowShared] BufferSource %pixels);
};
</pre>

<p>
この定義の下で `readPixels^c に対し［
`SharedArrayBuffer$t ~instance ／
何らかに~backされた ［
有型~配列 ／ `DataView$t
］］を伴わせて~callした場合、 `TypeError$t 例外が投出されることになる。
対照的に， `readPixelsShared^c は、そのような~objを入力として許容する。
◎
With this definition, a call to readPixels with an SharedArrayBuffer instance, or any typed array or DataView backed by one, will throw a TypeError exception. In contrast, a call to readPixelsShared will allow such objects as input.
</p>
</div>

			</section>
			<section id="Clamp">
<h4>3.3.2. `Clamp^x</h4>

<p>
`Clamp$x `拡張属性$が`整数~型$に現れた場合、次に従ってふるまう，新たな型を作成する
⇒
~ES `Number^jt 値がこの~IDL型へ変換される際には、範囲~外の値に対しては，範囲~内の最も近い妥当な値に切詰める
— modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）は利用せずに。
◎
If the [Clamp] extended attribute appears on one of the integer types, it creates a new IDL type such that that when an ECMAScript Number is converted to the IDL type, out-of-range values will be clamped to the range of valid values, rather than using the operators that use a modulo operation (ToInt32, ToUint32, etc.).
</p>

<p>
`Clamp$x 拡張属性には、`引数をとらない$ことが要求される。
◎
The [Clamp] extended attribute must take no arguments.
</p>

<div class="p">
<p>
型 %T に `Clamp$x `拡張属性が結付けられ$るときは、次のすべてが満たされ~MUST：
</p>

<ul ><li>%T は、`読専$属性に現れていない。
</li><li>%T には `EnforceRange$x `拡張属性が結付けられ$てはいない。
</li><li>%T は`整数~型$である。
</li></ul>

◎
A type annotated with the [Clamp] extended attribute must not appear in a read only attribute. A type must not be associated with both the [Clamp] and [EnforceRange] extended attributes. A type that is not an integer type must not be associated with the [Clamp] extended attribute.
</div>

<p>
`Clamp$x の利用に課される特有の要件については、
`es-integer-types$secの［
~ES値から種々の~IDL整数~型へ変換する規則
］を見よ。
◎
See the rules for converting ECMAScript values to the various IDL integer types in §3.2.4 Integer types for the specific requirements that the use of [Clamp] entails.
</p>


<div class="example">
<p>
次の`~IDL片$では，それぞれが 3 個の `octet$T 引数をとる， 2 個の`演算$が宣言される。
一方には 3 個すべての引数に `Clamp$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [Clamp] extended attribute on all three arguments, while the other does not:
</p>

<pre class="webidl">
interface GraphicsContext {
  void setColor(octet %red, octet %green, octet %blue);
  void setColorClamped([Clamp] octet %red, [Clamp] octet %green, [Clamp] octet %blue);
};
</pre>

<p>
`setColorClamped^M の~callに渡された，
`octet$T の範囲~外の `Number^jt 値は、範囲 [0, 255] に切詰められる。
◎
A call to setColorClamped with Number values that are out of range for an octet are clamped to the range [0, 255].
</p>

<pre class="es-code">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する。
◎
Get an instance of GraphicsContext.
</span> */
var %context = getGraphicsContext();

/* <span class="comment"
	title="."
>非 `Clamp^x 版の~callは実数~値を~octetに強制する ToUint8 を利用する。
◎
Calling the non-[Clamp] version uses ToUint8 to coerce the Numbers to octets
</span> */
/* <span class="comment">
次は `setColor(255, 255, 1)^c の~callと等価。
◎
This is equivalent to calling setColor(255, 255, 1).
</span> */
%context.setColor(-1, 255, 257);

/* <span class="comment">
範囲~外の値を渡して `setColorClamped^M を~callする。
◎
Call setColorClamped with some out of range values.
</span> */
/* <span class="comment">
次は `setColorClamped(0, 255, 255)^c の~callと等価。
◎
This is equivalent to calling setColorClamped(0, 255, 255).
</span> */
%context.setColorClamped(-1, 255, 257);
</pre>
</div>
			</section>
			<section id="Constructor">
<h4>3.3.3. `Constructor^x</h4>


<p>
`Constructor$x `拡張属性$が `~ifc$上に現れた場合、その~ifcに対応する`~ifc~obj$は，［
その~ifcを実装する~objを構築できるようにする， `Construct^sl 内部~meth
］を持つことになる。
◎
If the [Constructor] extended attribute appears on an interface, it indicates that the interface object for this interface will have an [[Construct]] internal method, allowing objects implementing the interface to be constructed.
</p>

<p>
同じ~ifc上に複数の `Constructor$x 拡張属性が現れてもよい。
◎
Multiple [Constructor] extended attributes may appear on a given interface.
</p>

<p>
`Constructor$x 拡張属性には、［
`引数をとらない$
か, または
`有名~引数~listを引数にとる$
］ことが要求される。<!-- must -->
略記形の前者
`[Constructor]^c
は、引数~listが空にされた
`[Constructor()]^c
と同じ意味になる。
~ifc上のそれぞれの `Constructor$x 拡張属性が、［
指定された引数を渡して，その~ifcを実装する~objを構築する仕方
］を、供することになる。
◎
The [Constructor] extended attribute must either take no arguments or take an argument list. The bare form, [Constructor], has the same meaning as using an empty argument list, [Constructor()]. For each [Constructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments.
</p>

<p>
構築子の注釈文においては，［
`Constructor$x 拡張属性が現れる~ifcに対応する型の~IDL値を返すか, または
例外を投出する
］ように定義され~MUST。
◎
The prose definition of a constructor must either return an IDL value of a type corresponding to the interface the [Constructor] extended attribute appears on, or throw an exception.
</p>

<p>
`Constructor$x 拡張属性は：
</p>

<ul>
	<li>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性と併用されては~MUST_NOT。
◎
The [Constructor] and [NoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [Constructor] extended attribute must not be used on a callback interface.
</li>
</ul>

<p>
~ifcに対する構築子がどう実装されるかの詳細は、
`interface-object$sec
を見よ。
◎
See §3.6.1 Interface object for details on how a constructor for an interface is to be implemented.
</p>


<div class="example">
<p>
次の~IDLは 2 つの~ifcを定義する。
2 個目のものには `Constructor$x 拡張属性がある一方，
1 個目のものにはない。
◎
The following IDL defines two interfaces. The second has the [Constructor] extended attribute, while the first does not.
</p>

<pre class="webidl">
interface NodeList {
  Node item(unsigned long %index);
  readonly attribute unsigned long length;
};

[Constructor,
 Constructor(double %radius)]
interface Circle {
  attribute double r;
  attribute double cx;
  attribute double cy;
  readonly attribute double circumference;
};
</pre>

<p>
これらの~ifcを~supportする~ES実装は、
`Circle^T ~ifc~obj上に，［
その~ifcを実装する新たな~obj
］を返す `Construct^sl ~propを持つことになる。
それは 0 個または 1 個の引数をとる。
`NodeList^T ~ifc~objは
`Construct^sl ~propを持たないことになる。
◎
An ECMAScript implementation supporting these interfaces would have a [[Construct]] property on the Circle interface object which would return a new object that implements the interface. It would take either zero or one argument. The NodeList interface object would not have a [[Construct]] property.
</p>

<pre class="es-code">
var %x = new Circle();
       /* <span class="comment">
これは，引数なしの構築子を利用して、 `Circle^T ~ifcを実装する~platform~objへの参照を作成する。
◎
The uses the zero-argument constructor to create a reference to a platform object that implements the Circle interface.
</span> */

var %y = new Circle(1.25);  
       /* <span class="comment">
今度は 1 個の引数をとる構築子を利用して `Circle^T ~objを作成する。
◎
This also creates a Circle object, this time using the one-argument constructor.
</span> */

var %z = new NodeList();    
       /* <span class="comment">
`Constructor^x が宣言されていないので `TypeError^jE が投出されることになる。
◎
This would throw a TypeError, since no [Constructor] is declared.
</span> */
</pre>
</div>


			</section>
			<section id="Default">
<h4>3.3.4. `Default^x</h4>

<p>
`Default$x `拡張属性$が`正則~演算$上に現れた場合、［
その演算が呼出されたときには，`対応する既定の演算$に述べられる手続きが行われ~MUST
］ことを指示する。
◎
If the [Default] extended attribute appears on a regular operation, then it indicates that steps described in the corresponding default operation must be carried out when the operation is invoked.
</p>

<p>
`Default$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Default] extended attribute must take no arguments.
</li>
	<li>
次のもの以外に利用されては~MUST_NOT
⇒
`正則~演算$であって，`対応する既定の演算$が定義されているもの
◎
The [Default] extended attribute must not be used on anything other than a regular operation for which a corresponding default operation has been defined.
</li>
</ul>

<div class="example">

<p>
例として、 `Default$x 拡張属性は，~toJSON`正則~演算$の利用に相応しくなる：
◎
As an example, the [Default] extended attribute is suitable for use on toJSON regular operations:
</p>


<pre class="webidl">
interface Animal {
  attribute DOMString name;
  attribute unsigned short age;
  [Default] object toJSON();
};

interface Human : Animal {
  attribute Dog? pet;
  [Default] object toJSON();
};

interface Dog : Animal {
  attribute DOMString? breed;
};
</pre>

<p>
~ES言語束縛においては、
`toJSON()^c ~methは，
`Animal^T, `Human^T
~obj上に, および
継承を介して `Dog^T ~obj上にも存在することになる：
◎
In the ECMAScript language binding, there would exist a toJSON() method on Animal, Human, and (via inheritance) Dog objects:
</p>

<pre class="es-code">
/* <span class="comment">
`Human^T の~instanceを取得する
◎
Get an instance of Human.
</span> */
var %alice = getHuman();

/* <span class="comment">
次の様な~objに評価される（この時点で， `Dog^T の~instanceは依然として `pet^l を保持することに注意）：
◎
Evaluates to an object like this (notice how "pet" still holds an instance of Dog at this point):
</span> */
   {
     name: "Alice",
     age: 59,
     pet: Dog
   }
*/
%alice.toJSON();

/* <span class="comment">
次の様な~objに評価される（ `Dog^T ~ifcは既定の~toJSON演算を宣言していないので， `breed^l は不在になることに注意）：
◎
Evaluates to an object like this (notice how "breed" is absent, as the Dog interface doesn’t declare a default toJSON operation):
</span> */
   {
     name: "Tramp",
     age: 6
   }
*/
%alice.pet.toJSON();

/* <span class="comment">
次の様な文字列に評価される：
◎
Evaluates to a string like this:
</span> */
   '{"name":"Alice","age":59,"pet":{"name":"Tramp","age":6}}'
*/
JSON.stringify(%alice);
</pre>

</div>

			</section>
			<section id="EnforceRange">
<h4>3.3.5. `EnforceRange^x</h4>


<p>
`EnforceRange$x `拡張属性$が`整数~型$に現れた場合、次に従ってふるまう，新たな型を作成する
⇒
~ES `Number^jt 値をこの~IDL型へ変換する際には、
0 側に丸めた結果が範囲~外になる値に対しては，例外を投出する
— modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）は利用せずに。
◎
If the [EnforceRange] extended attribute appears on one of the integer types, it creates a new IDL type such that that when an ECMAScript Number is converted to the IDL type, out-of-range values will cause an exception to be thrown, rather than being converted to a valid value using using the operators that use a modulo operation (ToInt32, ToUint32, etc.). The Number will be rounded toward zero before being checked against its range.
</p>

<p>
`EnforceRange$x 拡張属性には、`引数をとらない$ことが要求される。
◎
The [EnforceRange] extended attribute must take no arguments.
</p>

<div class="p">
<p>
型 %T に `EnforceRange$x `拡張属性が結付けられ$るときは、次のすべてが満たされ~MUST：
</p>

<ul ><li>%T は、`読専$属性に現れていない。
</li><li>%T には `Clamp$x `拡張属性が結付けられ$ていない。
</li><li>%T は`整数~型$である。
</li></ul>

◎
A type annotated with the [EnforceRange] extended attribute must not appear in a read only attribute. A type must not be associated with both the [Clamp] and [EnforceRange] extended attributes. A type that is not an integer type must not be associated with the [EnforceRange] extended attribute.
</div>


<p>
`EnforceRange$x の利用に課される特有の要件については、
`es-type-mapping$secの［
~ES値から種々の~IDL整数~型へ変換する規則
］を見よ。
◎
See the rules for converting ECMAScript values to the various IDL integer types in §3.2 ECMAScript type mapping for the specific requirements that the use of [EnforceRange] entails.
</p>


<div class="example">
<p><!-- copy* -->
次の`~IDL片$では，それぞれが 3 個の `octet$T 引数をとる， 2 個の`演算$が宣言される。
一方には 3 個すべての引数に `EnforceRange$x `拡張属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [EnforceRange] extended attribute on all three arguments, while the other does not:
</p>

<pre class="webidl">
interface GraphicsContext {
  void setColor(octet %red, octet %green, octet %blue);
  void setColorEnforcedRange([EnforceRange] octet %red, [EnforceRange] octet %green, [EnforceRange] octet %blue);
};
</pre>

<p>
この~IDLの~ES実装においては、
`octet$T の範囲~外の `Number^jt 値を渡して
`setColorEnforcedRange^M を~callしたときの結果は、例外の投出になる。
◎
In an ECMAScript implementation of the IDL, a call to setColorEnforcedRange with Number values that are out of range for an octet will result in an exception being thrown.
</p>

<pre class="es-code">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する。
◎
Get an instance of GraphicsContext.
</span> */
var %context = getGraphicsContext();

/* <span class="comment">
非 `EnforceRange^x 版の~callは実数~値を~octetに強制する ToUint8 を利用する。これは `setColor(255, 255, 1)^c の~callと等価になる。
◎
Calling the non-[EnforceRange] version uses ToUint8 to coerce the Numbers to octets. This is equivalent to calling setColor(255, 255, 1).
</span> */
%context.setColor(-1, 255, 257);

/* <span class="comment">
実数~値は `setColorEnforcedRange^M が~callされる際に 0 側に丸められる。
これは `setColor(0, 255, 255)^c の~callと等価になる。
◎
When setColorEnforcedRange is called, Numbers are rounded towards zero.
This is equivalent to calling setColor(0, 255, 255).
</span> */
%context.setColorEnforcedRange(-0.9, 255, 255.2);

/* <span class="comment">
次は `TypeError^jE を投出させる。丸められた後でも， 1 個目, 3 個目の引数は範囲~外になるので。
◎
The following will cause a TypeError to be thrown, since even after
rounding the first and third argument values are out of range.
</span> */
%context.setColorEnforcedRange(-1, 255, 256);
</pre>
</div>


			</section>
			<section id="Exposed">
<h4>3.3.6. `Exposed^x</h4>

<p>
`Exposed$x `拡張属性$が［
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$ ／
個々の［
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
］］上に現れた場合、その構成子が特定0の［
大域~ifc
【`*Global$x が指定された~ifc】
の集合
］上に公開されることを指示する
— 以下に述べる既定により、`首~大域~ifc$上に限り，暗黙的に公開されるのではなく。
◎
If the [Exposed] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, namespace, partial namespace, or an individual interface member, interface mixin member, or namespace member, it indicates that the construct is exposed on a particular set of global interfaces, rather than the default implicit exposition described below.
</p>

<p>
`Exposed$x `拡張属性$には、［
`識別子を引数にとる$か, または
`識別子~listを引数にとる$
］ことが要求される。
挙げられた各~識別子は、引数~内で一意, かつ`大域~名$で~MUST。
これらの識別子が成す~listは、当の構成子の
`自前の公開~集合@
と呼ばれる。
◎
The [Exposed] extended attribute must either take an identifier or take an identifier list. Each of the identifiers mentioned must be a global name and be unique. This list of identifiers is known as the construct’s own exposure set.
</p>

<p>
所与の構成子 %C の
`公開~集合@
を取得するときは、次の手続きを走らす：
◎
To get the exposure set of a construct C, run the following steps:
</p>

<ol class="algorithm">
	<li>
~Assert：
%C は［
`~ifc$ ／ `~ns$ ／ `~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である。
◎
Assert: C is an interface, namespace, interface member, interface mixin member, or namespace member.
</li>
	<li>
%H ~LET ［
%C は`~ifc~mixin~mb$ならば %C の`~host~ifc$ ／
~ELSE_ ε
］
◎
Let H be C’s host interface if C is an interface mixin member, or null otherwise.
</li>
	<li>
%E ~LET ［
%H ~NEQ ε ならば %H の`公開~集合$ ／
~ELSE_ すべての大域~ifcからなる集合
］
◎
↓</li>
	<li>
<p>
~IF［
%C は［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
］：
◎
If C is an interface member, interface mixin member, or namespace member, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET `交差集合$( %C の`自前の公開~集合$, %E )
◎
If the [Exposed] extended attribute is specified on C, then:
• If H is set, return the intersection of C’s own exposure set and H’s exposure set.
• Otherwise, return C’s own exposure set.
</li>
			<li>
%C ~SET
%C を宣言している［
`~ifc$ ／ `部分的~ifc$ ／ `~ifc~mixin$ ／ `部分的~ifc~mixin$ ／ `~ns$ ／ `部分的~ns$
］
◎
Otherwise, set C to be the interface, partial interface, interface mixin, partial interface mixin, namespace, or partial namespace C is declared on.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］である
］：
◎
If C is a partial interface, partial interface mixin, or partial namespace, then:
</p>

		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET `交差集合$( %C の`自前の公開~集合$, %E )
］
◎
If the [Exposed] extended attribute is specified on C, then:
• If H is set, return the intersection of C’s own exposure set and H’s exposure set.
• Otherwise, return C’s own exposure set.
</li>
			<li>
%C ~SET %C の元の［
`~ifc$ ／ `~ifc~mixin$ ／ `~ns$
］定義
◎
Otherwise, set C to be the original interface, interface mixin, or namespace definition of C.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は`~ifc~mixin$である
］：
◎
If C is an interface mixin, then:
</p>

		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET `交差集合$( %C の`自前の公開~集合$, %E )
◎
If the [Exposed] extended attribute is specified on C, then return the intersection of C’s own exposure set and H’s exposure set.
</li>
			<li>
~ELSE
⇒
%C ~SET %H
◎
Otherwise, set C to H.
</li>
		</ol>
	</li>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~ns$
］である
◎
Assert: C is a interface or namespace.
</li>
	<li>
~IF［
%C 上に `Exposed$x `拡張属性$は指定されている
］
⇒
~RET %C の`自前の公開~集合$
◎
If the [Exposed] extended attribute is specified on C, then return C’s own exposure set.
</li>
	<li>
~RET « `首~大域~ifc$ »
◎
Otherwise, return « primary global interface ».
</li>
</ol>

<p>
`Exposed$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`多重定義$された ある`演算$に現れた場合、その多重定義を成す他のすべての演算にも現れ~MUST。
◎
If [Exposed] appears on an overloaded operation, then it must appear identically on all overloads.
</li>
	<li>
<p>
［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］, および それを宣言している［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］定義の両者に指定されては~MUST_NOT。
◎
The [Exposed] extended attribute must not be specified both on an interface, mixin, or namespace member, and on the partial interface, partial interface mixin, or partial namespace definition the member is declared on.
</p>

<p class="note">注記：
そのわけは、［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］上に `Exposed$x `拡張属性$を追加することは，その各`~mb$を注釈することの略記だからである。
◎
Note: This is because adding an [Exposed] extended attribute on a partial interface, partial interface mixin, or partial namespace is shorthand for annotating each of its members.
</p>
	</li>
	<li>
［
`部分的~ifc$ ／ `部分的~ns$
］ %A に現れた場合、
%A の`自前の公開~集合$は， %A の元の［
`~ifc$ ／ `~ns$
］の`公開~集合$の`下位集合$で~MUST。
◎
If [Exposed] appears on a partial interface or partial namespace, then the partial’s own exposure set must be a subset of the exposure set of the partial’s original interface or namespace.
</li>
	<li>
［
`~ifc$ ／ `~ns$
］ %A 上の［
`~ifc~mb$ ／ `~ns~mb$
］ %m に現れた場合、
%m の`公開~集合$は %A の`公開~集合$の`下位集合$で~MUST。
◎
If [Exposed] appears on an interface or namespace member, then the member's exposure set must be a subset of the exposure set of the interface or namespace it is a member of.
</li>
	<li>
［
`部分的~ifc~mixin$ %A,
%A の元の`~ifc~mixin$ %B
］の両者に現れた場合、
%A の`自前の公開~集合$は %B の`自前の公開~集合$の`下位集合$で~MUST。
◎
If [Exposed] appears both on a partial interface mixin and its original interface mixin, then the partial interface mixin's own exposure set must be a subset of the interface mixin's own exposure set.
</li>
	<li>
`~ifc~mixin$ %A, 
%A の`~ifc~mixin~mb$ %m
の両者に現れた場合、
%m の`自前の公開~集合$は
%A の`自前の公開~集合$の`下位集合$で~MUST。
◎
If [Exposed] appears both on an interface mixin member and the interface mixin it is a member of, then the interface mixin members's own exposure set must be a subset of the interface mixin's own exposure set.
</li>
</ul>

<p>
%A が別の~ifc %B を`継承-$しているならば、
%A の`公開~集合$は %B の`公開~集合$の`下位集合$で~MUST。
◎
If an interface X inherits from another interface Y then the exposure set of X must be a subset of the exposure set of Y.
</p>

<p class="note">注記：
`~ifc~mixin$ %M は，互いに異なる`~ifc$に`内包-$され得るので、
%M の`~ifc~mixin~mb$ %m の`公開~集合$は，
%M を`内包-$している`~ifc$
— すなわち， %m の`~host~ifc$ %I —
の関数になり、
%F を %I の`公開~集合$とするならば，次で与えられる
⇒
%m は `Exposed$x `拡張属性$で注釈されているならば  `交差集合$( %m の`自前の公開~集合$, %F ) ／
~ELSE_ %M は `Exposed$x `拡張属性$で注釈されているならば `交差集合$( %M の`自前の公開~集合$, %F ) ／
~ELSE_ %F
◎
Note: As an interface mixin can be included by different interfaces, the exposure set of its members is a function of the interface that includes them. If the interface mixin member, partial interface mixin, or interface mixin is annotated with an [Exposed] extended attribute, then the interface mixin member's exposure set is the intersection of the relevant construct’s own exposure set with the the host interface's exposure set. Otherwise, it is the host interface's exposure set.
</p>

<p>
所与の
( ［
`~ifc$ ／ `~ns$ ／ `~ifc~mb$ ／ `~ns~mb$
］ %X, ~ES大域環境 %G )
に対し，
%X は %G に
`公開され@
るとは、次の両者が満たされることを意味する：
◎
An interface, namespace, interface member, or namespace member is exposed in a given ECMAScript global environment if the ECMAScript global object implements an interface that is in the construct’s exposure set, and either:
</p>

<ul>
	<li>
%G は［
%X の`公開~集合$に属する ある~ifc
］を実装している
</li>
	<li>
<p>
次のいずれかが満たされる：
</p>
		<ul>
			<li>
%G の~ES大域~objに`関連する設定群~obj$は`保安的~文脈$である
◎
the relevant settings object for the ECMAScript global object is a secure context; or
</li>
			<li>
%X は`保安的~文脈~下に限り可用$ではない
◎
the construct is not available only in secure contexts.
</li>
		</ul>
	</li>
</ul>


<p class="note">注記：
~ES大域~objに`関連する設定群~obj$が`保安的~文脈$であるかどうかは，変化し得ないので、実装が %X に対する~propを作成するかどうか決めるのは、`初期~obj$を作成する時点の一度限りになる。
◎
Note: Since it is not possible for the relevant settings object for an ECMAScript global object to change whether it is a secure context or not over time, an implementation’s decision to create properties for an interface or interface member can be made once, at the time the initial objects are created.
</p>

<p>
`Exposed$x の利用に課される特有の要件については、
`es-interfaces$sec,
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec,
`es-iterators$sec
を見よ。
◎
See §3.6 Interfaces, §3.6.6 Constants, §3.6.7 Attributes, §3.6.8 Operations, and §3.6.9 Common iterator behavior for the specific requirements that the use of [Exposed] entails.
</p>


<div class="example">
<p>
`Exposed$x に意図されている用途は、［
~ifc ／
~ns ／
個々の［
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
］］が可用になるのは［
<a href="~WORKERS">~worker</a>, `Worklet$T, `Window$T
］のうち［
どれ, あるいは どの組合わせ
］の中に限るかを，制御することである。
◎
[Exposed] is intended to be used to control whether interfaces, namespaces, or individual interface, mixin or namespace members are available for use in workers, Worklet, Window, or any combination of the above.
</p>

<p>
それが どうやって得られるかを，次の~IDL片に示す：
◎
The following IDL fragment shows how that might be achieved:
</p>

<pre class="webidl">
[PrimaryGlobal]
interface Window {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`SharedWorkerGlobalScope^T と `DedicatedWorkerGlobalScope^T
の両者に同じ識別子 `Worker^l を利用する
— 両者は `Exposed^x 拡張属性からまとめて指せるようになる。
◎
By using the same identifier Worker for both SharedWorkerGlobalScope and DedicatedWorkerGlobalScope, both can be addressed in an [Exposed] extended attribute at once.
</span> */
[Global=Worker]
interface SharedWorkerGlobalScope : WorkerGlobalScope {
  /* <!--cp-some-code--> */
};

[Global=Worker]
interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`Dimensions^T は、［ 主thread上と~workerの中 ］でのみ可用。
◎
Dimensions is available for use in workers and on the main thread.
</span> */
[Exposed=(Window,Worker), Constructor(double %width, double %height)]
interface Dimensions {
  readonly attribute double %width;
  readonly attribute double %height;
};

/* <span class="comment">
`WorkerNavigator^T は~workerの中でのみ可用。
~workerの大域~scopeの中で `WorkerNavigator^T を評価したときは~ifc~objを得られる一方で、主thread上でそうしたときは `ReferenceError^jE になる。
◎
WorkerNavigator is only available in workers.  Evaluating WorkerNavigator in the global scope of a worker would give you its interface object, while doing so on the main thread will give you a ReferenceError.
</span> */
[Exposed=Worker]
interface WorkerNavigator {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`Node^T は主thread上でのみ可用。
~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^jE になる。
◎
Node is only available on the main thread.  Evaluating Node in the global scope of a worker would give you a ReferenceError.
</span> */
interface Node {
  /* <!--cp-some-code--> */
};

/* <span class="comment">
`MathUtils^T は、［ 主thread上と~workerの中 ］でのみ可用。
◎
MathUtils is available for use in workers and on the main thread.
</span> */
[Exposed=(Window,Worker)]
namespace MathUtils {
  double someComplicatedFunction(double %x, double %y);
};

/* <span class="comment">
`WorkerUtils^T は，~workerの中でのみ可用。
~workerの大域~scopeの中で `WorkerUtils^T を評価したときは その~ns~objを得られる一方で、主thread上でそうしたときは `ReferenceError^jE になる。
◎
WorkerUtils is only available in workers.  Evaluating WorkerUtils in the global scope of a worker would give you its namespace object, while doing so on the main thread will give you a ReferenceError.
</span> */
[Exposed=Worker]
namespace WorkerUtils {
  void setPriority(double %x);
};

/* <span class="comment">
`NodeUtils^T は主thread上でのみ可用。
~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^jE になる。
◎
NodeUtils is only available in the main thread.  Evaluating NodeUtils in the global scope of a worker would give you a ReferenceError.
</span> */
namespace NodeUtils {
  DOMString getAllText(Node %node);
};



</pre>

</div>


			</section>
			<section id="Global">
<h4 title="[Global] and [PrimaryGlobal]">3.3.7. `Global^x と `PrimaryGlobal^x</h4>

<p>
［
`Global$x ／
`PrimaryGlobal@x
］`拡張属性$が `~ifc$上に現れた場合、［
その~ifcを実装している~objは，~ES環境にて大域~objとして利用できる
］ことを指示する。
これら 2 つを、ここでは
`*Global@x
拡張属性と総称することにする
【この総称は、この和訳による追加 — これら 2 つは下に述べるように排他的でもある】
。
また、原型鎖の構造, および［
`~ifc~mb$に対応する~propが原型~obj上に どう反映されるか
］についても、他の~ifcと異なるものにされることを指示する。
より特定的には：
◎
If the [Global] or [PrimaryGlobal] extended attribute appears on an interface, it indicates that objects implementing this interface can be used as the global object in an ECMAScript environment, and that the structure of the prototype chain and how properties corresponding to interface members will be reflected on the prototype objects will be different from other interfaces. Specifically:
</p>

<ol>
	<li>
どの`有名~prop$も，~obj自身ではなく,
原型鎖の中の~obj
— `有名~prop~obj$ —
上に公開されることになる。
◎
Any named properties will be exposed on an object in the prototype chain – the named properties object – rather than on the object itself.
</li>
	<li>
`~ifc$からの`~ifc~mb$は、`~ifc原型~obj$上ではなく, ~obj自身の~propに対応することになる。
◎
Interface members from the interface will correspond to properties on the object itself rather than on interface prototype objects.
</li>
</ol>

<div class="note">
<p>
原型鎖の中の~obj上に置かれる有名~propは、変数~宣言とそのままの名前の代入を通して，大域~obj自身の~propにより隠蔽される。
◎
Placing named properties on an object in the prototype chain is done so that variable declarations and bareword assignments will shadow the named property with a property on the global object itself.
</p>

<p>
~ifc~mbに対応する~propを~obj自身の上に置くことは、次の様な，特色機能を検出するためによく利用される手法が働くことになることを意味する：
<!-- 機能しない？ -->
◎
Placing properties corresponding to interface members on the object itself will mean that common feature detection methods like the following will work:
</p>

<pre class="es-code">
var %indexedDB = window.indexedDB || window.webkitIndexedDB ||
                window.mozIndexedDB || window.msIndexedDB;

var %requestAnimationFrame = window.requestAnimationFrame ||
                            window.mozRequestAnimationFrame || ...;
</pre>

<p>
~ESにおける変数~宣言が取扱われる仕方から，代入が評価される前に隠蔽する変数~propが作成されることになるので、上の~codeでは，
`window.indexedDB^c
と
`window.requestAnimationFrame^c
が `undefined^jv に評価されることになる。
◎
Because of the way variable declarations are handled in ECMAScript, the code above would result in the window.indexedDB and window.requestAnimationFrame evaluating to undefined, as the shadowing variable property would already have been created before the assignment is evaluated.
</p>
</div>

<p>
`*Global$x `拡張属性$を利用する`~ifc$ %I に対しては：
◎
If the [Global] or [PrimaryGlobal] extended attributes is used on an interface, then:
</p>

<ul>
	<li>
`有名~prop設定子$は 定義されては~MUST_NOT。
◎
The interface must not define a named property setter.
</li>
	<li>
［
`有index~prop取得子$／`有index~prop設定子$
］は 定義されては~MUST_NOT。
◎
The interface must not define indexed property getters or setters.
</li>
	<li>
［
%I, および %I の`被継承~ifc$
］は
`OverrideBuiltins$x 拡張属性を伴って宣言されては~MUST_NOT。
◎
The interface must not also be declared with the [OverrideBuiltins] extended attribute.
◎
The interface must not inherit from another interface with the [OverrideBuiltins] extended attribute.
</li>
	<li>
%I は 他の~ifcは`継承-$しては~MUST_NOT。
◎
Any other interface must not inherit from it.
</li>
	<li>
%I の`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，
%I を成す~ifc定義の中で`有名~prop取得子$を定義する部分を成してい~MUST。
◎
If [Global] or [PrimaryGlobal] is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</li>
	<li>
<p>
%I は、同じ~ES大域環境~内で，複数の~objから実装され得るものであっては~MUST_NOT。
◎
The [Global] and [PrimaryGlobal] extended attribute must not be used on an interface that can have more than one object implementing it in the same ECMAScript global environment.
</p>

<p class="note">注記：
そのわけは、有名~propを公開する`有名~prop~obj$が 原型鎖の中にあるものであり、複数の［
~objの有名~prop
］を，それらの~objを継承する 1 個の~obj上で公開することに意味が無いからである。
◎
Note: This is because the named properties object, which exposes the named properties, is in the prototype chain, and it would not make sense for more than one object’s named properties to be exposed on an object that all of those objects inherit from.
</p>
	</li>
	<li>
<p>
%I には［
`識別子$が同じになる複数の`~mb$
］があっては~MUST_NOT。
また、
%I には［
複数の`文字列化子$ ／
複数の［
`可反復~宣言$, `~maplike 宣言$, `~setlike 宣言$【混在も含む】
］］があっては~MUST_NOT。
◎
If an interface is declared with the [Global] or [PrimaryGlobal] extended attribute, then there must not be more than one member across the interface with the same identifier. There also must not be more than one stringifier or more than one iterable declaration, maplike declaration or setlike declaration across those interfaces.
</p>

<p class="note">注記：
そのわけは、~ifcの`~mb$すべてが、~ifcを実装する~objに平坦化されるからである。
◎
Note: This is because all of the members of the interface get flattened down on to the object that implements the interface.
</p>
	</li>
</ul>

<p>
`*Global$x 拡張属性は、
1 個~以上の大域~ifcに同じ名前を与えて，
`Exposed$x 拡張属性から参照できるようにするときにも利用できる。
◎
The [Global] and [PrimaryGlobal] extended attributes can also be used to give a name to one or more global interfaces, which can then be referenced by the [Exposed] extended attribute.
</p>

<p>
`*Global$x 拡張属性には、［
`引数をとらない$
か, または
`識別子~listを引数にとる$
］ことが要求される。
◎
The [Global] and [PrimaryGlobal] extended attributes must either take no arguments or take an identifier list.
</p>

<p>
`*Global$x `拡張属性$が宣言されている~ifcは， 1 個~以上の
`大域~名@
を持つ：
拡張属性が 識別子~listを引数に伴うならば，それらの識別子が~ifcの大域~名になり、他の場合，~ifc自身の識別子が~ifcの~~唯一の大域~名になる。
◎
If the [Global] or [PrimaryGlobal] extended attribute is declared with an identifier list argument, then those identifiers are the interface’s global names; otherwise, the interface has a single global name, which is the interface’s identifier.
</p>

<p class="note">注記：
識別子~list引数は、 `Exposed$x `拡張属性$の中の単独の名前で，複数の大域~ifcを指せるようにするためにある。
◎
Note: The identifier argument list exists so that more than one global interface can be addressed with a single name in an [Exposed] extended attribute.
</p>

<p>
`Global$x, `PrimaryGlobal$x の両`拡張属性$が，同じ~ifc上に宣言されては~MUST_NOT。
`PrimaryGlobal$x 拡張属性が宣言される~ifcは<!-- ある大域環境において実装が~supportする~ifcの集合の中で -->，高々 1 個で~MUST。
`PrimaryGlobal$x が宣言された~ifcは、
`首~大域~ifc@
と呼ばれる。
◎
The [Global] and [PrimaryGlobal] extended attributes must not be declared on the same interface. The [PrimaryGlobal] extended attribute must be declared on at most one interface. The interface [PrimaryGlobal] is declared on, if any, is known as the primary global interface.
</p>


<p>
有名~propにおける `*Global$x の利用に課される特有の要件については、
`named-properties-object$sec
を見よ。
`~ifc~mb$に対応する~propの所在に関する要件については、
`es-constants$sec,
`es-attributes$sec,
`es-operations$sec
を見よ。
◎
See §3.6.5 Named properties object for the specific requirements that the use of [Global] and [PrimaryGlobal] entails for named properties, and §3.6.6 Constants, §3.6.7 Attributes and §3.6.8 Operations for the requirements relating to the location of properties corresponding to interface members.
</p>

<div class="example">
<p>
`PrimaryGlobal$x は、 `Window$T ~ifcからの利用が意図されている（ `Global$x は，~worker大域~ifcからの利用が意図されている）。
`Window^T ~ifcは frame を `Window^T ~obj上の~propとして公開する。
`Window^T ~objは~ES大域~objとしても~~働くので、有名~propに対する代入や変数~宣言は、新たな値への置換-になる。
属性に対する変数~宣言は、既存の~propを置換する~propを作成しない。
◎
The [PrimaryGlobal] extended attribute is intended to be used by the Window interface. ([Global] is intended to be used by worker global interfaces.) The Window interface exposes frames as properties on the Window object. Since the Window object also serves as the ECMAScript global object, variable declarations or assignments to the named properties will result in them being replaced by the new value. Variable declarations for attributes will not create a property that replaces the existing one.
</p>

<pre class="webidl">
[PrimaryGlobal]
interface Window {
  getter any (DOMString %name);
  attribute DOMString name; 
   /* <!--cp-some-code--> */
};
</pre>

<p>
次の HTML 文書では、
`Window^T ~obj上の有名~propが隠蔽され,
属性に対する~propは同じ名前の変数が宣言されても置換されない：
◎
The following HTML document illustrates how the named properties on the Window object can be shadowed, and how the property for an attribute will not be replaced when declaring a variable of the same name:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
Window 上の変数~宣言と代入
◎
Variable declarations and assignments on Window
</span>&lt;/title&gt;
&lt;iframe name=abc&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment"
	title="">有名~propを隠蔽する
◎
Shadowing named properties
</span> --&gt;
&lt;script&gt;
  window.abc;    /* <span class="comment">
`iframe^c の `Window^T ~objに評価される。
◎
Evaluates to the iframe’s Window object.
</span> */
  %abc = 1;       /* <span class="comment">
有名~propを隠蔽する。
◎
Shadows the named property.
</span> */
  window.abc;    /* <span class="comment"
	title="" id="cp-eval-1"
>`1^jv に評価される。
◎
Evaluates to 1.
</span> */
&lt;/script&gt;

&lt;!-- <span class="comment">
~IDL属性に対する~propは保全される
◎
Preserving properties for IDL attributes
</span> --&gt;
&lt;script&gt;
  Window.prototype.def = 2;         /* <span class="comment">
原型~上に~propを置く。
◎
Places a property on the prototype.
</span> */
  window.hasOwnProperty("length");  /* <!--cp-eval-true--> */

  %length;        /* <!--cp-eval-1--> */
  %def;           /* <span class="comment">
`2^jv に評価される。
◎
Evaluates to 2.
</span> */
&lt;/script&gt;

&lt;script&gt;
  var %length;    /* <span class="comment">
この変数~宣言は既存の~propに触らない。
◎
Variable declaration leaves existing property.
</span> */
  %length;        /* <!--cp-eval-1--> */
  var %def;       /* <span class="comment">
この変数~宣言は隠蔽する~propを作成する。
◎
Variable declaration creates shadowing property.
</span> */
  %def;           /* <!--cp-eval-undefined--> */
&lt;/script&gt;
</pre>

</div>

			</section>
			<section id="LegacyArrayClass" class="L2">
<h4>3.3.8. `LegacyArrayClass^x</h4>

<div class="advisement">
<p>
`LegacyArrayClass$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [LegacyArrayClass]$fI
した上で論交することを，強く勧める。
◎
The [LegacyArrayClass] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LegacyArrayClass$x `拡張属性$は、次の`~ifc$に現れる：
`DOMRectList$T,
`MediaList$T,
`StyleSheetList$T,
`CSSRuleList$T
`GEOMETRY$r `CSSOM$r
◎
The [LegacyArrayClass] extended attribute appears on the following interfaces: DOMRectList, MediaList, StyleSheetList, and CSSRuleList. [GEOMETRY] [CSSOM]
</small></p>
</div>


<p>
`LegacyArrayClass$x `拡張属性$が［
他を`継承-$しないように定義された`~ifc$
］上に現れた場合、その`~ifc原型~obj$の `Prototype^sl 内部~propは，内在的~obj `ArrayPrototype$jI になる
— `ObjectPrototype$jI ではなく。
これにより、その~ifcを実装している~objにおいて，
`Array$t ~methを容易く利用できるようになる。
◎
If the [LegacyArrayClass] extended attribute appears on an interface that is not defined to inherit from another, it indicates that the internal [[Prototype]] property of its interface prototype object will be the intrinsic object %ArrayPrototype% rather than %ObjectPrototype%. This allows Array methods to be used more easily with objects implementing the interface.
</p>

<div class="p">
<p>
`LegacyArrayClass$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`被継承~ifc$を持つ~ifcに利用されては~MUST_NOT：
</li></ul>

◎
The [LegacyArrayClass] extended attribute must take no arguments. It must not be used on an interface that has any inherited interfaces.
</div>


<p class="note">注記：
`LegacyArrayClass$x を利用する~ifcには、継承される `Array^t ~methが正しく演算するように、配列に類似するような，~objの長さを公開する［
型 `unsigned long$T の `length^l `属性$
］を定義する必要がある。
そのような~ifcは、概して，配列~要素への~accessを提供する`有index~propを~support$することになるであろう。
◎
Note: Interfaces using [LegacyArrayClass] will need to define a “length” attribute of type unsigned long that exposes the length of the array-like object, in order for the inherited Array methods to operate correctly. Such interfaces would typically also support indexed properties, which would provide access to the array elements.
</p>

<p>
`LegacyArrayClass$x の利用に課される特有の要件については、
`interface-prototype-object$sec
を見よ。
◎
See §3.6.3 Interface prototype object for the specific requirements that the use of [LegacyArrayClass] entails.
</p>

<div class="example">

<p>
次の`~IDL片$は、 `LegacyArrayClass$x を利用する 2 つの`~ifc$を定義する。
◎
The following IDL fragment defines two interfaces that use [LegacyArrayClass].
</p>

<pre class="webidl">
[LegacyArrayClass]
interface ItemList {
  attribute unsigned long length;
  getter object getItem(unsigned long %index);
  setter object setItem(unsigned long %index, object %item);
};

[LegacyArrayClass]
interface ImmutableItemList {
  readonly attribute unsigned long length;
  getter object getItem(unsigned long %index);
};
</pre>

<p>
上の 2 つの~ifcの
`getItem^c, `setItem^c, `removeItem^c
用の適切な定義を伴う~ES実装においては、配列に類似する~objを検分したり改変するための `Array$t ~methを利用できる：
◎
In an ECMAScript implementation of the above two interfaces, with appropriate definitions for getItem, setItem and removeItem, Array methods to inspect and modify the array-like object can be used.
</p>

<pre class="es-code">
var %list = getItemList();  /* <span class="comment">
`ItemList^T の~instanceを得る。
◎
Obtain an instance of ItemList.
</span> */

%list.concat();             /* <span class="comment">
%list を `Array^t の中に~cloneする。
◎
Clone the ItemList into an Array.
</span> */
%list.pop();                /* <span class="comment">
%list から~itemを除去する。
◎
Remove an item from the ItemList.
</span> */
%list.unshift({ });         /* <span class="comment">
~itemを~index 0 の位置に挿入する。
◎
Insert an item at index 0.
</span> */
</pre>

<p>
`ImmutableItemList^T は、読専の `length^c `属性$を持ち，
`有index~prop設定子$を持たない。
`ImmutableItemList^T を実装する~obj上では、一般に `Array$t を改変する~methは失敗することになる。
正確な挙動は `Array$t ~meth自身の定義に依存する。
◎
ImmutableItemList has a read only length attribute and no indexed property setter. The mutating Array methods will generally not succeed on objects implementing ImmutableItemList. The exact behavior depends on the definition of the Array methods themselves.
</p>

</div>

			</section>
			<section id="LegacyNamespace">
<h4>3.3.9. `LegacyNamespace^x</h4>

<p class="advisement">
`LegacyNamespace$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
~ifc名は、~nsを利用する代わりに，［
一連の~ifcの識別子を，特定0の接頭辞から開始させるような命名~規約
］により形成できる。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [LegacyNamespace]$fI
した上で論交することを，強く勧める。
◎
The [LegacyNamespace] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Instead, interface names can be formed with a naming convention of starting with a particular prefix for a set of interfaces, as part of the identifier, rather than using a namespace. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p>
`LegacyNamespace$x `拡張属性$が`~ifc$上に現れた場合、その~ifc用の`~ifc~obj$は、大域~objの~propとしてではなく，この拡張属性の引数により識別される`~ns$の~propとして作成されることを指示する。
◎
If the [LegacyNamespace] extended attribute appears on an interface, it indicates that the interface object for this interface will not be created as a property of the global object, but rather as a property of the namespace identified by the argument to the extended attribute.
</p>

<p>
`LegacyNamespace$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
ある`~ns$の`識別子を引数にとる$ことが要求される。
◎
The [LegacyNamespace] extended attribute take an identifier. This identifier must be the identifier of a namespace.
</li>
	<li>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性と併用されては~MUST_NOT。
◎
The [LegacyNamespace] and [NoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [LegacyNamespace] extended attribute must not be used on a callback interface.
</li>
</ul>

<p>
~ifcが~ns上にどう公開されるかの詳細は
`namespace-object$sec
を見よ。
◎
See §3.11.1 Namespace object for details on how an interface is exposed on a namespace.
</p>

<div class="example">
<p>
次の`~IDL片$は、`~ns$, および
その内側に定義されることになる［
`LegacyNamespace$x を利用する`~ifc$
］を定義する：
◎
The following IDL fragment defines a namespace and an interface which uses [LegacyNamespace] to be defined inside of it.
</p>

<pre class="webidl">
namespace Foo { };

[LegacyNamespace=Foo, Constructor]
interface Bar { };
</pre>

<p>
上の~nsと~ifcの~ES実装においては、構築子 `Bar^M は、次のように~accessできる：
◎
In an ECMAScript implementation of the above namespace and interface, the constructor Bar can be accessed as follows:
</p>

<pre class="es-code">
var %instance = new Foo.Bar();
</pre>

</div>

			</section>
			<section id="LegacyUnenumerableNamedProperties" class="L2">
<h4>3.3.10. `LegacyUnenumerableNamedProperties^x</h4>

<div class="advisement">
<p>
`LegacyUnenumerableNamedProperties$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [LegacyUnenumerableNamedProperties]$fI
した上で論交することを，強く勧める。
◎
The [LegacyUnenumerableNamedProperties] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LegacyUnenumerableNamedProperties$x `拡張属性$は、次の`~ifc$に現れる：
`HTMLCollection$T,
`NamedNodeMap$T,
`HTMLAllCollection$T,
`HTMLFormElement$T,
`PluginArray$T,
`MimeTypeArray$T,
`Plugin$T,
`Window$T
`DOM$r `HTML$r
◎
The [LegacyUnenumerableNamedProperties] extended attribute appears on the following interfaces: HTMLCollection, NamedNodeMap, HTMLAllCollection, HTMLFormElement, PluginArray, MimeTypeArray, Plugin, and Window. [DOM] [HTML]
</small></p>
</div>

<p id="dfn-unenumerable">
`LegacyUnenumerableNamedProperties$x `拡張属性$が［
`有名~propを~support$する`~ifc$
］に現れた場合、その~ifc上の すべての有名~propは，列挙不可であることを指示する。
◎
If the [LegacyUnenumerableNamedProperties] extended attribute appears on a interface that supports named properties, it indicates that all the interface’s named properties are unenumerable.
</p>

<div class="p">
<p>
`LegacyUnenumerableNamedProperties$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`有名~prop取得子$を定義しない~ifc上に現れては~MUST_NOT。
</li><li>当の~ifcのすべての派生~ifcにも適用され、それらには，この拡張属性は指定されては~MUST_NOT。
</li></ul>

◎
The [LegacyUnenumerableNamedProperties] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter.
◎
If the [LegacyUnenumerableNamedProperties] extended attribute is specified on an interface, then it applies to all its derived interfaces and must not be specified on any of them.
</div>

<p>
`LegacyUnenumerableNamedProperties$x の利用に課される特有の要件については、
`legacy-platform-object-getownproperty$sec
を見よ。
◎
See §3.8.1 [[GetOwnProperty]] for the specific requirements that the use of [LegacyUnenumerableNamedProperties] entails.
</p>


			</section>
			<section id="LegacyWindowAlias">
<h4>3.3.11. `LegacyWindowAlias^x</h4>

<div class="advisement">
<p>
`LegacyWindowAlias$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [LegacyWindowAlias]$fI
した上で論交することを，強く勧める。
◎
The [LegacyWindowAlias] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LegacyWindowAlias$x `拡張属性$は、次の`~ifc$に現れる：
`DOMPoint$T,
`DOMRect$T,
`DOMMatrix$T,
`URL$T
`GEOMETRY$r `URL$r
◎
The [LegacyWindowAlias] extended attribute appears on the following interfaces: DOMPoint, DOMRect, DOMMatrix, and URL. [GEOMETRY] [URL]
</small></p>
</div>

<p>
`LegacyWindowAlias$x `拡張属性$が `~ifc$ %I 上に現れた場合、［
`首~大域~ifc$は、その拡張属性~内に挙げられた各 `識別子$に対し，
%I に対応する`~ifc~obj$を値にとるような~propを持つことになる
］ことを指示する。
◎
If the [LegacyWindowAlias] extended attribute appears on an interface, it indicates that the primary global interface will have a property for each identifier mentioned in the extended attribute, whose value is the interface object for the interface.
</p>


<p>
`LegacyWindowAlias$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`識別子を引数にとる$か, または
`識別子~listを引数にとる$ことが要求される。
`=^sym の直後に~~現れる `identifier$g が
`LegacyWindowAlias$x の
`識別子@wA
になる。
◎
The [LegacyWindowAlias] extended attribute must either take an identifier or take an identifier list. The identifiers that occur after the “=” are the [LegacyWindowAlias]'s identifiers.
</li>
	<li>
<p>
次に挙げる識別子は、
`LegacyWindowAlias$x の`識別子$wAとして利用されては~MUST_NOT：
</p>

<ul ><li>当のまたは別の~ifc上の `LegacyWindowAlias$x 拡張属性に利用されている他の`識別子$wA
</li><li>当のまたは別の~ifc上の `NamedConstructor$x 拡張属性に利用されている`識別子$nC
</li><li>`~ifc~obj$を持つ~ifcの`識別子$
</li><li>`予約済み識別子$
</li></ul>
◎
Each of the identifiers of [LegacyWindowAlias] must not be the same as one used by a [LegacyWindowAlias] extended attribute on this interface or another interface, must not be the same as the identifier used by a [NamedConstructor] extended attribute on this interface or another interface, must not be the same as an identifier of an interface that has an interface object, and must not be one of the reserved identifiers.
</li>
	<li>
同じ~ifc上で， `NoInterfaceObject$x 拡張属性と併用されては~MUST_NOT。
◎
The [LegacyWindowAlias] and [NoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
	<li>
自身の`公開~集合$内に`首~大域~ifc$を含んでいない~ifcには、指定されては~MUST_NOT。
◎
The [LegacyWindowAlias] extended attribute must not be specified on an interface that does not include the primary global interface in its exposure set.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [LegacyWindowAlias] extended attribute must not be specified on a callback interface.
</li>
	<li>
同じ~ifc上に複数~個 指定されては~MUST_NOT。
◎
An interface must not have more than one [LegacyWindowAlias] extended attributes specified.
</li>
</ul>

<p>
`LegacyWindowAlias^x がどう実装されるかの詳細は
`es-interfaces$sec
を見よ。
◎
See §3.6 Interfaces for details on how legacy window aliases are to be implemented.
</p>


<div class="example">

<p>
次の~IDLは
`LegacyWindowAlias$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [LegacyWindowAlias] extended attribute.
</p>


<pre class="webidl">
[Constructor,
 LegacyWindowAlias=WebKitCSSMatrix]
interface DOMMatrix : DOMMatrixReadOnly {
  /* <!--cp-some-code--> */
};
</pre>


<p>
この~ifcを~supportする~ES実装は、
`Window$T ~obj上に，同じ値, 同じ特徴を備える 2 個の~propを公開することになる
— 1 つは`~ifc~obj$を通常~のように公開するためのもの，もう 1 つは それを旧来の名前で公開するためのもの。
◎
An ECMAScript implementation that supports this interface will expose two properties on the Window object with the same value and the same characteristics; one for exposing the interface object normally, and one for exposing it with a legacy name.
</p>

<pre class="es-code">
WebKitCSSMatrix === DOMMatrix;     /* <!--cp-eval-true--> */

var %m = new WebKitCSSMatrix();     /* <span class="comment">
`DOMMatrix^T を実装する新たな~objを作成する。
◎
Creates a new object that implements DOMMatrix.
</span> */

%m.constructor === DOMMatrix;       /* <!--cp-eval-true--> */
%m.constructor === WebKitCSSMatrix; /* <!--cp-eval-true--> */
{}.toString.call(%m);               /* <span class="comment">
`[object DOMMatrix]^l に評価される。
◎
Evaluates to '[object DOMMatrix]'.
</span> */
</pre>

</div>
			</section>
			<section id="LenientSetter" class="L2">
<h4>3.3.12. `LenientSetter^x</h4>

<div class="advisement">
<p>
互換性の理由から要求されない限り、仕様は `LenientSetter$x を利用するべきでない。
~pageにて、作者が当の~propへ代入することで~IDL属性を~polyfillしようと試みていて、~propが存在するときでも不用意にそうしたとする。
~strict-mode下では、これは例外を投出させ，~pageを壊しかねない。
`LenientSetter$x が無いと、このことから~browserは，将来に出荷できなくなる。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [LenientSetter]$fI
した上で論交することを，強く勧める。
◎
Specifications should not use [LenientSetter] unless required for compatibility reasons. Pages have been observed where authors have attempted to polyfill an IDL attribute by assigning to the property, but have accidentally done so even if the property exists. In strict mode, this would cause an exception to be thrown, potentially breaking page. Without [LenientSetter], this could prevent a browser from shipping the feature. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LenientSetter$x `拡張属性$は、次の`属性$に現れる：
`Document$T ~ifc の［
`fullscreenEnabled$T,
`fullscreenEnabled$T
］,
`DocumentOrShadowRoot$T `~ifc~mixin$の `fullscreenElement$T
`FULLSCREEN$r
◎
The [LenientSetter] extended attribute appears on the fullscreenEnabled and fullscreenEnabled attributes of the Document interface, and on the fullscreenElement attribute of the DocumentOrShadowRoot interface mixin. [FULLSCREEN] 
</small></p>
</div>

<p>
`LenientSetter$x `拡張属性$が［
`読専$の`正則~属性$
］に現れた場合、［
属性の~accessor~propとして，何もしない設定子が生成される
］ことを指示する。
その結果，~strict-mode下では、~propに対する誤った代入に対しては，例外は投出されずに無視されるようになる。
◎
If the [LenientSetter] extended attribute appears on a read only regular attribute, it indicates that a no-op setter will be generated for the attribute’s accessor property. This results in erroneous assignments to the property in strict mode to be ignored rather than causing an exception to be thrown.
</p>


<div class="p">
<p>
`LenientSetter$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`読専$の`正則~属性$以外に利用されては~MUST_NOT。
</li><li>同じ属性~上で，
`PutForwards$x ／ `Replaceable$x
拡張属性と併用されては~MUST_NOT。
</li><li>`~ns$上で宣言される属性~上に利用されては~MUST_NOT。
</li></ul>

◎
The [LenientThis] extended attribute must take no arguments. It must not be used on anything other than a read only regular attribute.
◎
An attribute with the [LenientSetter] extended attribute must not also be declared with the [PutForwards] or [Replaceable] extended attributes.
◎
The [LenientSetter] extended attribute must not be used on an attribute declared on a namespace.
</div>

<p>
`LenientSetter$x がどう実装されるかの詳細は、
`es-attributes$sec
を見よ。
◎
See the Attributes section for how [LenientSetter] is to be implemented.
</p>

<div class="example">

<p>
次の~IDL片は `LenientSetter$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientSetter] extended attribute.
</p>

<pre class="webidl">
interface Example {
  [LenientSetter] readonly attribute DOMString x;
  readonly attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~ES実装は， `x^M に対応する~accessor~prop上に設定子を持つことになり、~strict-mode下では，どのような代入も無視されるようになる。
◎
An ECMAScript implementation that supports this interface will have a setter on the accessor property that correspond to x, which allows any assignment to be ignored in strict mode.
</p>

<pre class="es-code">
"use strict";

var %example = getExample();  /* <span class="comment">
`Example^T の~instanceを取得する。
◎
Get an instance of Example.
</span> */

/* <span class="comment">
~~問題ない。~strict-mode下では，何もしない設定子がある。
◎
Fine; while we are in strict mode, there is a setter that is a no-op.
</span> */
%example.x = 1;

/* <span class="comment">
`TypeError^jE が投出される。~strict-mode下にあり，設定子がないので。
◎
Throws a TypeError, since we are in strict mode and there is no setter.
</span> */
%example.y = 1;
</pre>

</div>

			</section>
			<section id="LenientThis">
<h4>3.3.13. `LenientThis^x</h4>

<div class="advisement">
<p>
互換性の理由から要求されない限り、仕様は `LenientThis$x を利用するべきでない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [LenientThis]$fI
した上で論交することを，強く勧める。
◎
Specifications should not use [LenientThis] unless required for compatibility reasons. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`LenientThis$x `拡張属性$は、次の`属性$に現れる：
`Document$T ~ifcの［
`onreadystatechange$M,
`onmouseenter$M,
`onmouseleave$M
］
`HTML$r
◎
The [LenientThis] extended attribute appears on the onreadystatechange, onmouseenter, and onmouseleave attributes of the Document interface. [HTML]
</small></p>
</div>

<p>
`LenientThis$x `拡張属性$が `正則~属性$上に現れた場合、その属性が現れる`~ifc$を実装する~objとは異なる `this^jv 値を伴うような，その属性の取得子や設定子の呼出は、無視されることになる。
◎
If the [LenientThis] extended attribute appears on a regular attribute, it indicates that invocations of the attribute’s getter or setter with a this value that is not an object that implements the interface on which the attribute appears will be ignored.
</p>

<div class="p">
<p>
`LenientThis$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`静的~属性$上に利用されては~MUST_NOT。
</li><li>`~ns$上で宣言される属性~上に利用されては~MUST_NOT。
</li></ul>
◎
The [LenientThis] extended attribute must take no arguments. It must not be used on a static attribute.
◎
The [LenientThis] extended attribute must not be used on an attribute declared on a namespace.
</div>

<p>
`LenientThis$x がどう実装されるかについては、
`es-attributes$sec
を見よ。
◎
See the Attributes section for how [LenientThis] is to be implemented.
</p>

<div class="example">
<p>
次の~IDL片は
`LenientThis$x 拡張属性を利用する
~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LenientThis] extended attribute.
</p>

<pre class="webidl">
interface Example {
  [LenientThis] attribute DOMString x;
  attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~ES実装では、 `x^M に対応する~accessor~propの取得子／設定子では，
`Example^T ~obj以外の何かを伴う呼出しも許容されることになる。
◎
An ECMAScript implementation that supports this interface will allow the getter and setter of the accessor property that corresponds to x to be invoked with something other than an Example object.
</p>

<pre class="es-code">
var %example = getExample();  /* <span class="comment">
`Example^T の~instanceを取得する。
◎
Get an instance of Example.
</span> */
var %obj = { };

/* <span class="comment">
~~通常。
◎
Fine.
</span> */
%example.x;

/* <span class="comment">
この値は `Example^T ~objでなく, かつ
`LenientThis^x が利用されているので、無視される。
◎
Ignored, since the this value is not an Example object and [LenientThis] is used.
</span> */
Object.getOwnPropertyDescriptor(Example.prototype, "x").get.call(%obj);

/* <span class="comment">
`Example.prototype^jv は `Example^T ~objでなく, かつ
`LenientThis^x が利用されているので、これも無視される。
◎
Also ignored, since Example.prototype is not an Example object and [LenientThis] is used.
</span> */
Example.prototype.x;

/* <span class="comment">
`Example.prototype^jv は `Example^T ~objでないので `TypeError^jE が投出される。
◎
Throws a TypeError, since Example.prototype is not an Example object.
</span> */
Example.prototype.y;
</pre>
</div>
			</section>
			<section id="NamedConstructor">
<h4>3.3.14. `NamedConstructor^x</h4>

<div class="advisement">
<p>
[
`NamedConstructor$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [NamedConstructor]$fI
した上で論交することを，強く勧める。
◎
[NamedConstructor] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`NamedConstructor$x `拡張属性$は、次の`~ifc$に現れる：
`HTMLAudioElement$T,
`HTMLOptionElement$T,
`HTMLImageElement$T
`HTML$r
◎
The [NamedConstructor] extended attribute appears on the following interfaces: HTMLAudioElement, HTMLOptionElement, and HTMLImageElement. [HTML]
</small></p>
</div>


<div class="p">

<p>
`NamedConstructor$x `拡張属性$が `~ifc$上に現れた場合、~ES大域~objは，次を伴う~propを持つことになる：
</p>

<ul><li>その名前は、拡張属性の引数に指定された名前。
</li><li>値は、その~ifcを実装する~objを作成できる`構築子$。
</li></ul>
◎
If the [NamedConstructor] extended attribute appears on an interface, it indicates that the ECMAScript global object will have a property with the specified name whose value is a constructor that can create objects that implement the interface.＼
</div>

<p>
所与の~ifc上に，複数の `NamedConstructor$x 拡張属性が現れてもよい。
◎
Multiple [NamedConstructor] extended attributes may appear on a given interface.
</p>

<p>
`NamedConstructor$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`識別子を引数にとる$か, または`有名~引数~listを引数にとる$ことが要求される。
`=^sym の直後に現れる `identifier$g が
`NamedConstructor$x の
`識別子@nC
になる。
前者の形
<code>[NamedConstructor=`identifier$g]</code>
は、空の引数~list
<code>[NamedConstructor=`identifier$g()]</code>
を利用するのと同じ意味になる。
~ifc上の各 `NamedConstructor$x 拡張属性が、［［
前述の~propの値である`構築子$
］に，指定された引数を渡して、その~ifcを実装する~objを構築する仕方
］を供することになる。
◎
The [NamedConstructor] extended attribute must either take an identifier or take a named argument list. The identifier that occurs directly after the “=” is the [NamedConstructor]'s identifier. The first form, [NamedConstructor=identifier], has the same meaning as using an empty argument list, [NamedConstructor=identifier()]. For each [NamedConstructor] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments to the constructor that is the value of the aforementioned property.
</li>
	<li>
<p>
次に挙げる識別子は、有名~構築子の識別子として利用されては~MUST_NOT：
</p>

<ul ><li>別の~ifc上の `NamedConstructor$x 拡張属性に利用されている`識別子$nC
</li><li>当のまたは別の~ifc上の `LegacyWindowAlias$x 拡張属性に利用されている`識別子$wA
</li><li>`~ifc~obj$を持つ~ifcの`識別子$
</li><li>`予約済み識別子$
</li></ul>

◎
The identifier used for the named constructor must not be the same as that used by a [NamedConstructor] extended attribute on another interface, must not be the same as an identifier used by a [LegacyWindowAlias] extended attribute on this interface or another interface, must not be the same as an identifier of an interface that has an interface object, and must not be one of the reserved identifiers.
</li>
	<li>
`呼戻~ifc$上に利用されては~MUST_NOT。
◎
The [NamedConstructor] extended attribute must not be used on a callback interface.
</li>
</ul>

<p>
有名~構築子がどう実装されるかの詳細は
`named-constructors$sec
を見よ。
◎
See §3.6.2 Named constructors for details on how named constructors are to be implemented.
</p>

<div class="example">
<p>
次の~IDLは
`NamedConstructor$x 拡張属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [NamedConstructor] extended attribute.
</p>

<pre class="webidl">
[NamedConstructor=Audio,
 NamedConstructor=Audio(DOMString %src)]
interface HTMLAudioElement : HTMLMediaElement {
  /* <!--cp-some-code--> */
};
</pre>

<p>
この~ifcを~supportする~ES実装は、
`Audio^T `構築子$を利用する `HTMLAudioElement^T ~objの構築を許容することになる。
◎
An ECMAScript implementation that supports this interface will allow the construction of HTMLAudioElement objects using the Audio constructor.
</p>

<pre class="es-code">
typeof Audio;                   /* <!--cp-eval-function--> */

var %a1 = new Audio();
   /* <span class="comment">
引数なしの構築子を利用して， `HTMLAudioElement^T を実装する ~objを作成する。
◎
Creates a new object that implements HTMLAudioElement, using the zero-argument constructor.
</span> */

var %a2 = new Audio('a.flac');
   /* <span class="comment">
1 個の引数をとる構築子を利用して， `HTMLAudioElement^T を作成する。
◎
Creates an HTMLAudioElement using the one-argument constructor.
</span> */
</pre>
</div>


			</section>
			<section id="NewObject">
<h4>3.3.15. `NewObject^x</h4>

<p>
`NewObject$x `拡張属性$が［
`正則~演算$／`静的~演算$
］上に現れた場合、その演算が~callされる際に，常に
新たに作成された~objへの参照が返され~MUSTことを指示する。
◎
If the [NewObject] extended attribute appears on a regular or static operation, then it indicates that when calling the operation, a reference to a newly created object must always be returned.
</p>

<p>
`NewObject$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NewObject] extended attribute must take no arguments.
</li>
	<li>
`返値型$が［
`~ifc型$, または `~promise型$
］である［
`正則~演算$／`静的~演算$
］以外の所に利用されては~MUST_NOT。
◎
The [NewObject] extended attribute must not be used on anything other than a regular or static operation whose return type is an interface type or a promise type.
</li>
</ul>

<div class="example">
<p>
この拡張属性の利用が適する一例には，
<a href="https://dom.spec.whatwg.org/#document">`Document^T</a>
~ifc（ `DOM$r, 6.5 節）上の
<a href="https://dom.spec.whatwg.org/#dom-document-createelement">createElement</a>
演算がある。
これは，~callされる度に新たな~objが返されるべきなので。
◎
As an example, this extended attribute is suitable for use on the createElement operation on the Document interface ([DOM], section 6.5), since a new object should always be returned when it is called.
</p>

<pre class="webidl">
interface Document : Node {
  [NewObject] Element createElement(DOMString %localName);
  /* <!--cp-some-code--> */
};
</pre>

</div>

			</section>
			<section id="NoInterfaceObject">
<h4>3.3.16. `NoInterfaceObject^x</h4>

<div class="advisement">
<p>
`NoInterfaceObject$x 拡張属性は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [NoInterfaceObject]$fI
することにより，論交することを強く勧める。
◎
The [NoInterfaceObject] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`NamedConstructor$x `拡張属性$は、次の`~ifc$に現れる
⇒＃
`Geolocation$T,
`Coordinates$T,
`Position$T,
`PositionError$T,
`DeviceAcceleration$T,
`DeviceRotationRate$T,
`ConstrainablePattern$T,
`WEBGL_compressed_texture_astc$T,
`WEBGL_compressed_texture_s3tc_srgb$T,
`WEBGL_draw_buffers$T,
`WEBGL_lose_context$T,
`ANGLE_instanced_arrays$T,
`EXT_blend_minmax$T,
`EXT_color_buffer_float$T,
`EXT_disjoint_timer_query$T,
`OES_standard_derivatives$T,
`OES_vertex_array_object$T
◎終
`GEOLOCATION-API$r
`ORIENTATION-EVENT$r
`MEDIACAPTURE-STREAMS$r
各種 `WEBGL$r 拡張~仕様
◎
The [NoInterfaceObject] extended attribute appears on the following interfaces:
• Geolocation, Coordinates, Position, PositionError, DeviceAcceleration, DeviceRotationRate, ConstrainablePattern, WEBGL_compressed_texture_astc, WEBGL_compressed_texture_s3tc_srgb, WEBGL_draw_buffers, WEBGL_lose_context, ANGLE_instanced_arrays, EXT_blend_minmax, EXT_color_buffer_float, EXT_disjoint_timer_query, OES_standard_derivatives, and OES_vertex_array_object. [GEOLOCATION-API] [ORIENTATION-EVENT] [MEDIACAPTURE-STREAMS] (various [WEBGL] extension specifications)
</small></p>

<p class="note">注記：
`NoInterfaceObject$x `拡張属性$は、以前は，［［
（今は無き “`implements^sym 文” を用いて、）
`~ifc$を，それが~mixinであったかのように他の`~ifc$が実装できる
］ようにする
］ために注釈する用途があった。
今や、これをまかなうための，専用の構文
— `~ifc~mixin$／`~includes文$ —
がある。
この目的に `NoInterfaceObject$x `拡張属性$を用いることは、もはや~supportされない。
依然としてそうしている仕様は、可能な限りすみやかに`~ifc~mixin$に移行することが，強く奨励される。
すべての仕様が移行されるまで。
◎
Note: Previously, the [NoInterfaceObject] extended attribute could also be used to annotate interfaces, which other interfaces could then implement (using the defunct "implements statement") as if they were mixins. There is now dedicated syntax to cater for this in the form of interface mixins and includes statements. Using the [NoInterfaceObject] extended attribute for this purpose is no longer supported. Specifications which still do are strongly encouraged to migrate to interface mixins as soon as possible. Until all specifications have migrated.
</p>

</div>

<p>
`NoInterfaceObject$x `拡張属性$が `~ifc$上に現れた場合、その~ifcに対応する`~ifc~obj$は，~ES言語束縛には存在しないことになる。
◎
If the [NoInterfaceObject] extended attribute appears on an interface, it indicates that an interface object will not exist for the interface in the ECMAScript binding.
</p>

<p>
`NoInterfaceObject$x 拡張属性は：
</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NoInterfaceObject] extended attribute must take no arguments.
</li>
	<li>
同じ~ifc上で， `Constructor$x 拡張属性と併用されては~MUST_NOT。
一方， `NamedConstructor$x 拡張属性との併用は差し支えない。
◎
If the [NoInterfaceObject] extended attribute is specified on an interface, then the [Constructor] extended attribute must not also be specified on that interface. A [NamedConstructor] extended attribute is fine, however.
</li>
	<li>
`静的~演算$が定義されている~ifc上に指定されては~MUST_NOT。
◎
The [NoInterfaceObject] extended attribute must not be specified on an interface that has any static operations defined on it.
</li>
	<li>
`呼戻~ifc$上に指定されては~MUST_NOT。
◎
The [NoInterfaceObject] extended attribute must not be specified on a callback interface.
</li>
	<li>
この拡張属性が指定されていない~ifcが，この拡張属性が指定されている~ifcを継承しては~MUST_NOT
◎
An interface that does not have the [NoInterfaceObject] extended attribute specified must not inherit from an interface that has the [NoInterfaceObject] extended attribute specified.
</li>
</ul>


<p>
`NoInterfaceObject$x の利用に課される特有の要件については、
`es-interfaces$sec
を見よ。
◎
See §3.6 Interfaces for the specific requirements that the use of [NoInterfaceObject] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの~ifcを定義する。
一方はその~ifc~objが~ES大域~obj上に公開され，他方はそうでない：
◎
The following IDL fragment defines two interfaces, one whose interface object is exposed on the ECMAScript global object, and one whose isn’t:
</p>

<pre class="webidl">
interface Storage {
  void addEntry(unsigned long %key, any %value);
};

[NoInterfaceObject]
interface Query {
  any lookupEntry(unsigned long %key);
};
</pre>

<p>
上の~IDLの~ES実装においては、
`Storage^T に対する原型の操作は許容される一方，
`Query^T に対してはそうならない。
◎
An ECMAScript implementation of the above IDL would allow manipulation of Storage’s prototype, but not Query’s.
</p>

<pre class="es-code">
typeof Storage;                        /* <span class="comment">
`object^l に評価される。
◎
evaluates to &quot;object&quot;
</span> */

/* <span class="comment">
`Storage.addEntry^c に~trace用の `alert()^c ~callを追加する
◎
Add some tracing alert() call to Storage.addEntry.
</span> */
var %fn = Storage.prototype.addEntry;
Storage.prototype.addEntry = function(%key, %value) {
  alert('Calling addEntry()');
  return %fn.call(this, %key, %value);
};

typeof Query;                          /* <span class="comment">
`undefined^l に評価される。
◎
evaluates to &quot;undefined&quot;
</span> */
var %fn = Query.prototype.lookupEntry;  /* <span class="comment">
例外を投出。 `Query^T は定義されていない。
◎
exception, Query isn’t defined
</span> */
</pre>
</div>
			</section>
			<section id="OverrideBuiltins">
<h4>3.3.17. `OverrideBuiltins^x</h4>

<div class="advisement">
<p>
`OverrideBuiltins$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [OverrideBuiltins]$fI
した上で論交することを，強く勧める。
◎
The [OverrideBuiltins] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`OverrideBuiltins$x `拡張属性$は、次の`~ifc$に現れる：
`DOMStringMap$T,
`Document$T,
`HTMLFormElement$T
`HTML$r
◎
The [OverrideBuiltins] extended attribute appears on the DOMStringMap, Document, and HTMLFormElement interfaces. [HTML]
</small></p>
</div>

<p>
`OverrideBuiltins$x `拡張属性$が `~ifc$上に現れた場合，その~ifcを実装する`旧来の~platform~obj$ %O においては、［
%O や %O の原型鎖
］上に存在する他の~propに関わらず，
%O の`被support~prop名$すべてに対し，それぞれに対応する~propが %O 上に現れることになる。
このことは、（通例の挙動では、有名~propは［
%O 自身やその原型鎖
］上のどこにも同じ名前の~propが存在しないときに限り，公開されるのに対し、）有名~propが、［
さもなければ %O 上に現れることになる，同じ名前のどの~prop
］も，常に隠蔽することになることを意味する。
◎
If the [OverrideBuiltins] extended attribute appears on an interface, it indicates that for a legacy platform object implementing the interface, properties corresponding to all of the object’s supported property names will appear to be on the object, regardless of what other properties exist on the object or its prototype chain. This means that named properties will always shadow any properties that would otherwise appear on the object. This is in contrast to the usual behavior, which is for named properties to be exposed only if there is no property with the same name on the object itself or somewhere on its prototype chain.
</p>

<div class="p">
<p>
`OverrideBuiltins$x 拡張属性は：
</p>

<ul><li>`引数をとらない$ことが要求される。
</li><li>`有名~prop取得子$を定義しない~ifc上に現れては~MUST_NOT。
</li><li>`*Global$x 拡張属性と併用されては~MUST_NOT。
</li><li>`部分的~ifc定義$上に指定される場合、その部分的~ifc定義は，~ifc定義の中で`有名~prop取得子$を定義する部分をなすもので~MUST。
</li></ul>

◎
The [OverrideBuiltins] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter or that also is declared with the [Global] or [PrimaryGlobal] extended attribute. If the extended attribute is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</div>

<p>
`OverrideBuiltins$x の利用に課される特有の要件については、
`es-legacy-platform-objects$sec,
`legacy-platform-object-defineownproperty$sec
を見よ。
◎
See §3.8 Legacy platform objects and §3.8.3 [[DefineOwnProperty]] for the specific requirements that the use of [OverrideBuiltins] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの`~ifc$を定義する。
一方は`有名~prop取得子$を持ち, 他方はそうでない：
◎
The following IDL fragment defines two interfaces, one that has a named property getter and one that does not.
</p>

<pre class="webidl">
interface StringMap {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString %key);
};

[OverrideBuiltins]
interface StringMap2 {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString %key);
};
</pre>

<p>
これら 2 つの~ifcの~ES実装においては、それぞれの~ifcを実装する~obj上の一部の~propについて，その取得による結果が異なってくることになる：
◎
In an ECMAScript implementation of these two interfaces, getting certain properties on objects implementing the interfaces will result in different values:
</p>

<pre class="es-code">
/* <span class="comment">
`StringMap^T の~instanceを得る。
被support~prop名として， `abc^l, `length^l, `toString^l を持つとする。
◎
Obtain an instance of StringMap.  Assume that it has "abc", "length" and "toString" as supported property names.
</span> */
var %map1 = getStringMap();

/* <span class="comment">
有名~prop取得子を呼出す。
◎
This invokes the named property getter.
</span> */
%map1.abc;

/* <span class="comment"
>`length^M 属性に対応する~obj上の `length^l ~propを取りに行く。
◎
This fetches the "length" property on the object that corresponds to the length attribute.
</span> */
%map1.length;

/* <span class="comment"
>~objの原型鎖~上の `toString^l ~propを取りに行く。
◎
This fetches the "toString" property from the object’s prototype chain.
</span> */
%map1.toString;


/* <span class="comment">
`StringMap2^T の~instanceを得る。
これも被support~prop名として， `abc^l, `length^l, `toString^l を持つとする。
◎
Obtain an instance of StringMap2.  Assume that it also has "abc", "length"
and "toString" as supported property names.
</span> */
var %map2 = getStringMap2();

/* <span class="comment">
これは 有名~prop取得子を呼出す。
◎
This invokes the named property getter.
</span> */
%map2.abc;

/* <span class="comment">
これも 有名~prop取得子を呼出す。
~obj上の `length^l ~propが length 属性に対応しているにも関わらず。
◎
This also invokes the named property getter, despite the fact that the "length"
property on the object corresponds to the length attribute.
</span> */
%map2.length;

/* <span class="comment">
これもまた 有名~prop取得子を呼出す。
`toString^l が %map2 の prototype chain 内にある~propであるにも関わらず。
◎
This too invokes the named property getter, despite the fact that "toString" is
a property in map2’s prototype chain.
</span> */
%map2.toString;
</pre>
</div>
			</section>
			<section id="PutForwards">
<h4>3.3.18. `PutForwards^x</h4>


<p>
`PutForwards$x `拡張属性$が［
`~ifc型$の`読専$の`正則~属性$宣言
］上に現れた場合、その属性への代入-時に特有に挙動することになる。
すなわち，その代入は、代入-が試みられた属性から，現在~参照されている~objの属性（その拡張属性の引数で指定される）に “転送-” される。
◎
If the [PutForwards] extended attribute appears on a read only regular attribute declaration whose type is an interface type, it indicates that assigning to the attribute will have specific behavior. Namely, the assignment is “forwarded” to the attribute (specified by the extended attribute argument) on the object that is currently referenced by the attribute being assigned to.
</p>

<p>
`PutForwards$x 拡張属性には、`識別子を引数にとる$ことが要求される。
次が与えられるとき：
◎
The [PutForwards] extended attribute must take an identifier. Assuming that:
</p>

<ul>
	<li>
%A は
`PutForwards$x 拡張属性が現れる`属性$,
◎
A is the attribute on which the [PutForwards] extended attribute appears,
</li>
	<li>
%I は
%A が宣言されている`~ifc$,
◎
I is the interface on which A is declared,
</li>
	<li>
%J は
%A の型として宣言されている `~ifc型$, <!--  -->
◎
J is the interface type that A is declared to be of, and
</li>
	<li>
%N は
その拡張属性の`識別子$引数,
◎
N is the identifier argument of the extended attribute,
</li>
</ul>

<p>
このとき，`識別子$ %N を持つ別の`属性$ %B が
%J 上に宣言されてい~MUST。
%I を実装している~obj上の属性 %A への値の代入では、代わりに，
%A が参照する~objの属性 %B にその値が代入されることになる。
◎
then there must be another attribute B declared on J whose identifier is N. Assignment of a value to the attribute A on an object implementing I will result in that value being assigned to attribute B of the object that A references, instead.
</p>

<p>
`PutForwards$x 注釈付きの`属性$は連鎖し得ることに注意。
すなわち、
`PutForwards$x `拡張属性$を伴う属性は，この拡張属性を持つ他の属性を指すことができる。
ただし、この代入の連鎖が循環しては~MUST_NOT。
代入の連鎖が辿られる際に，同じ`~ifc$上の特定0の属性に複数~回 遭遇するならば、循環が存在する。
◎
Note that [PutForwards]-annotated attributes can be chained. That is, an attribute with the [PutForwards] extended attribute can refer to an attribute that itself has that extended attribute. There must not exist a cycle in a chain of forwarded assignments. A cycle exists if, when following the chain of forwarded assignments, a particular attribute on an interface is encountered more than once.
</p>

<p>
`PutForwards$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
同じ属性~上で，
`LenientSetter$x ／ `Replaceable$x
拡張属性と併用されては~MUST_NOT。
◎
An attribute with the [PutForwards] extended attribute must not also be declared with the [LenientSetter] or [Replaceable] extended attributes.
</li>
	<li>
`読専$でない`属性$~上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute must not be used on a static attribute.
</li>
	<li>
［
`呼戻~ifc$／`~ns$
］上で宣言される属性~上に利用されては~MUST_NOT。
◎
The [PutForwards] extended attribute must not be used on an attribute declared on a callback interface or namespace.
</li>
</ul>

<p>
`PutForwards$x がどう実装されるかについては、
`es-attributes$sec
を見よ。
◎
See the Attributes section for how [PutForwards] is to be implemented.
</p>

<div class="example">
<p>
次の`~IDL片$は、姓名と人を表す~ifcを定義する。
`Person^T ~ifcの `name^M 属性~上に利用される `PutForwards$x 拡張属性は、その属性への代入による結果が `Person^T ~objの
【 `name^M 属性が指す `Name^T ~objの】
`full^M 属性への代入になることを指示する：
◎
The following IDL fragment defines interfaces for names and people. The [PutForwards] extended attribute is used on the name attribute of the Person interface to indicate that assignments to that attribute result in assignments to the full attribute of the Person object:
</p>

<pre class="webidl">
interface Name {
  attribute DOMString full;
  attribute DOMString family;
  attribute DOMString given;
};

interface Person {
  [PutForwards=full] readonly attribute Name name;
  attribute unsigned short age;
};
</pre>

<p>
~ES言語束縛においては、
`name^l ~propへの代入が許容されることになる：
◎
In the ECMAScript binding, this would allow assignments to the “name” property:
</p>

<pre class="es-code">
var %p = getPerson();           /* <span class="comment">
`Person^T の~instanceを得る。
◎
Obtain an instance of Person.
</span> */

%p.name = 'John Citizen';       /* <span class="comment">
この文は...
◎
This statement...
</span> */
%p.name.full = 'John Citizen';  /* <span class="comment">
...これと同じ挙動になる。
◎
...has the same behavior as this one.
</span> */
</pre>
</div>
			</section>
			<section id="Replaceable">
<h4>3.3.19. `Replaceable^x</h4>


<p>
`Replaceable$x `拡張属性$が `読専$の`正則~属性$上に現れた場合、`~platform~obj$上の対応する~propが設定される際に、その~obj上に，代入される値をとる同じ名前の自前の~propが作成されることになる。
この~propは、
`~ifc原型~obj$上に存在する，その属性に対応する~accessor~propを隠蔽する。
◎
If the [Replaceable] extended attribute appears on a read only regular attribute, it indicates that setting the corresponding property on the platform object will result in an own property with the same name being created on the object which has the value being assigned. This property will shadow the accessor property corresponding to the attribute, which exists on the interface prototype object.
</p>

<p>
`Replaceable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Replaceable] extended attribute must take no arguments.
</li>
	<li>
同じ属性~上で，
`LenientSetter$x ／ `Replaceable$x
拡張属性と併用されては~MUST_NOT。
◎
An attribute with the [Replaceable] extended attribute must not also be declared with the [LenientSetter] or [PutForwards] extended attributes.
</li>
	<li>
`読専$でない`属性$~上に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$上に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute must not be used on a static attribute.
</li>
	<li>
`呼戻~ifc$上で宣言される属性に利用されては~MUST_NOT。
◎
The [Replaceable] extended attribute must not be used on an attribute declared on a callback interface.
</li>
</ul>

<p>
`Replaceable$x の利用に課される特有の要件については、
`es-attributes$sec
を見よ。
◎
See §3.6.7 Attributes for the specific requirements that the use of [Replaceable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、計数を増やす`演算$と，計数~値を公開する初期~値 0 の`属性$を持つ`~ifc$を定義する：
◎
The following IDL fragment defines an interface with an operation that increments a counter, and an attribute that exposes the counter’s value, which is initially 0:
</p>

<pre class="webidl">
interface Counter {
  [Replaceable] readonly attribute unsigned long value;
  void increment();
};
</pre>

<p>
`Counter^T を実装する `~platform~obj$上の
`value^l ~propに代入することにより，その`属性$に対応する~propは隠蔽されることになる：
◎
Assigning to the “value” property on a platform object implementing Counter will shadow the property that corresponds to the attribute:
</p>

<pre class="es-code">
var %counter = getCounter();         /* <span class="comment">
`Counter^T の~instanceを得る。
◎
Obtain an instance of Counter.
</span> */
%counter.value;                      /* <span class="comment">
`0^jv に評価される。
◎
Evaluates to 0.
</span> */

%counter.hasOwnProperty("value");    /* <!--cp-eval-false--> */
Object.getPrototypeOf(%counter).hasOwnProperty("value");
                                    /* <!--cp-eval-true--> */

%counter.increment();
%counter.increment();
%counter.value;                      /* <span class="comment">
`2^jv に評価される。
◎
Evaluates to 2.
</span> */

%counter.value = 'a';                
       /* <span class="comment">
`Counter::value^V に関係無いもので~propを隠蔽する。
◎
Shadows the property with one that is unrelated to Counter::value.
</span> */

%counter.hasOwnProperty("value");    /* <!--cp-eval-true--> */

%counter.increment();
%counter.value;                      /* <span class="comment">
`a^l に評価される。
◎
Evaluates to 'a'.
</span> */

delete %counter.value;               /* <span class="comment">
元の~propを露にする。
◎
Reveals the original property.
</span> */
%counter.value;                      /* <span class="comment">
`3^jv に評価される。
◎
Evaluates to 3.
</span> */
</pre>
</div>

			</section>
			<section id="SameObject">
<h4>3.3.20. `SameObject^x</h4>


<p>
`SameObject$x `拡張属性$が `読専$`属性$に現れた場合、所与の~obj上でその属性の値が取得される度に，常に同じ値が返され~MUSTことを指示する。
◎
If the [SameObject] extended attribute appears on a read only attribute, then it indicates that when getting the value of the attribute on a given object, the same value must always be returned.
</p>

<p>
`SameObject$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [SameObject] extended attribute must take no arguments.
</li>
	<li>
［［
`~ifc型$／`~obj型$
］である`読専$`属性$
］以外の所に利用されては~MUST_NOT。
◎
The [SameObject] extended attribute must not be used on anything other than a read only attribute whose type is an interface type or object.
</li>
</ul>


<div class="example">
<p>
この拡張属性の利用が適する一例には，
<a href="https://dom.spec.whatwg.org/#document">`Document^T</a>
~ifc（ `DOM$r, 6.5 節）上の
<a href="https://dom.spec.whatwg.org/#dom-document-implementation">`implementation^c</a>
属性がある。
所与の `Document^T ~objに対しては，常に同じ~objが返されるので。
◎
As an example, this extended attribute is suitable for use on the implementation attribute on the Document interface ([DOM], section 6.5), since the same object is always returned for a given Document object.
</p>

<pre class="webidl">
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  /* <!--cp-some-code--> */
};
</pre>
</div>

			</section>
			<section id="SecureContext">
<h4>3.3.21. `SecureContext^x</h4>

<p>
`SecureContext$x `拡張属性$が［
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$ ／
個々の［
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
］］ %X 上に現れた場合、［
%X が公開されるのは `保安的~文脈$の中に限られる
］ことを指示する。
◎
If the [SecureContext] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, namespace, partial namespace, interface member, interface mixin member, or namespace member, it indicates that the construct is exposed only within a secure context.＼
</p>

<p>
`SecureContext$x 拡張属性は：
</p>

<ul>
	<li>
上に挙げたもの以外の構成子に利用されては~MUST_NOT。
◎
The [SecureContext] extended attribute must not be used on any other construct.
</li>
	<li>
`引数をとらない$ことが要求される。
◎
The [SecureContext] extended attribute must take no arguments.
</li>
</ul>

<p>
既定では、構成子は
`保安的かどうかに関わらず可用@
とされる。
◎
By default, constructs are available in both secure and non-secure contexts.
</p>

<p>
所与の構成子 %C が
`保安的~文脈~下に限り可用@
かどうか検査するときは、次の手続きを走らす（結果が ~T ならば可用とされる）：
◎
To check if a construct C is available only in secure contexts, run the following steps:
</p>

<ol>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~ns$ ／ `~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
◎
Assert: C is an interface, namespace, interface member, interface mixin member, or namespace member.
</li>
	<li>
%H ~LET ［
%C は`~ifc~mixin~mb$であるならば %C の`~host~ifc$ ／
~ELSE_ ~NULL
］
◎
Let H be C’s host interface if C is an interface mixin member, or null otherwise.
</li>
	<li>
<p>
~IF［
%C は［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
］：
◎
If C is an interface member, interface mixin member, or namespace member, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
			<li>
~ELSE
⇒
%C ~SET %C を宣言している［
`~ifc$ ／
`部分的~ifc$ ／
`~ifc~mixin$ ／
`部分的~ifc~mixin$ ／
`~ns$ ／
`部分的~ns$
］
◎
Otherwise, set C to be the interface, partial interface, interface mixin, partial interface mixin, namespace, or partial namespace C is declared on.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］である
］：
◎
If C is a partial interface, partial interface mixin, or partial namespace, then:
</p>

		<ol>
			<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
			<li>
%C ~SET %C の元の［
`~ifc$ ／
`~ifc~mixin$ ／
`~ns$
］定義
◎
Otherwise, set C to be the original interface, interface mixin, or namespace definition of C.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は`~ifc~mixin$である
］：
◎
If C is an interface mixin, then:
</p>

		<ol>
			<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
			<li>
%C ~SET %H
◎
Otherwise, set C to H.
</li>
		</ol>
	</li>
	<li>
~Assert：
%C は［
`~ifc$ ／ `~ns$
］である
◎
Assert: C is a interface or namespace
</li>
	<li>
~IF［
%C 上に `SecureContext$x `拡張属性$は指定されている
］
⇒
~RET ~T
◎
If the [SecureContext] extended attribute is specified on C, then return true.
</li>
	<li>
~RET ~F
◎
Otherwise, return false.
</li>
</ol>

<p class="note">注記：
所与の構成子が`保安的~文脈~下に限り可用$かどうかは、所与の~ES大域~環境~内に`公開され$るかどうかに波及する。
◎
Note: Whether a construct is available only in secure contexts influences whether it is exposed in a given ECMAScript global environment.
</p>

<p>
`SecureContext$x `拡張属性$は：
</p>
<ul>
	<li>
`多重定義$された ある`演算$に現れるならば、その多重定義を成す他のすべての演算にも現れ~MUST。
◎
If [SecureContext] appears on an overloaded operation, then it must appear on all overloads.
</li>
	<li>
<p>
次の両者に指定されては~MUST_NOT
⇒
［
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
］, および その`~mb$を宣言している［
`部分的~ifc$ ／
`部分的~ifc~mixin$ ／
`部分的~ns$
］定義
◎
The [SecureContext] extended attribute must not be specified both on an interface, mixin, or namespace member, and on the partial interface, partial interface mixin, or partial namespace definition the member is declared on.
</p>

<p class="note">注記：
そのわけは、［
`部分的~ifc$ ／ `部分的~ifc~mixin$ ／ `部分的~ns$
］上に `SecureContext$x `拡張属性$を追加することは，その各`~mb$を注釈することの略記だからである。
◎
Note: This is because adding a [SecureContext] extended attribute on a partial interface, partial interface mixin, or partial namespace is shorthand for annotating each of its members.
</p>

	</li>
	<li>
次の両者に指定されては~MUST_NOT：
⇒
`~ifc~mb$, および その`~mb$を宣言している［
`~ifc$ ／ `部分的~ifc$
］定義
◎
The [SecureContext] extended attribute must not be specified on both an interface member and the interface or partial interface definition the interface member is declared on.＼
</li>
	<li>
次の両者に指定されては~MUST_NOT：
⇒
`~ns~mb$, および その`~mb$を宣言している［
`~ns$ ／ `部分的~ns$
］定義
◎
It must also not be specified on both a namespace member and the namespace or partial namespace definition the namespace member is declared on.
</li>
</ul>

<p>
`SecureContext$x`拡張属性$を伴わない`~ifc$は、
`SecureContext$x を指定する別の~ifcを`継承-$しては~MUST_NOT。
◎
An interface without the [SecureContext] extended attribute must not inherit from another interface that does specify [SecureContext].
</p>

<div class="example">

<p>
次の`~IDL片$が定義する~ifcには、 3 個の~mbがある
— うち 1 個は すべて文脈から実行できる`演算$であり，他は 保安的~文脈に限り実行できる：
◎
The following IDL fragment defines an interface with one operation that is executable from all contexts, and two which are executable only from secure contexts.
</p>

<pre class="webidl">
interface PowerfulFeature {
  /* <span class="comment">
次の演算の~callはどの文脈~下でも成功する。
◎
This call will succeed in all contexts.
</span> */
  Promise &lt;Result&gt; calculateNotSoSecretResult();

  /* <span class="comment">
次の演算は、保安的でない文脈には公開されない。
`PowerfulFeature.prototype^c 上に
`calculateSecretResult^l ~propはない。
◎
This operation will not be exposed to a non-secure context. In such a context, there will be no "calculateSecretResult" property on PowerfulFeature.prototype.
</span> */
  [SecureContext] Promise&lt;Result&gt; calculateSecretResult();

  /* <span class="comment">
次の属性にも同じことが言え、保安的でない文脈には公開されない
— `PowerfulFeature.prototype^c 上に 
`secretBoolean^l ~propはない。
◎
The same applies here: the attribute will not be exposed to a non-secure context, and in a non-secure context there will be no "secretBoolean" property on PowerfulFeature.prototype.
</span> */

  [SecureContext] readonly attribute boolean secretBoolean;
};

/* <span class="comment">
`HeartbeatSensor^T は、保安的でない文脈にも その~mbにも公開されない
— `Window^T 上に `HeartbeatSensor^l ~propはない。
◎
HeartbeatSensor will not be exposed in a non-secure context, nor will its members. In such a context, there will be no "HeartbeatSensor" property on Window.
</span> */

[SecureContext]
interface HeartbeatSensor {
  Promise&lt;float&gt; getHeartbeatsPerMinute();
};

/* <span class="comment">
次に定義される~ifc~mixin~mbは、それを内包する~ifcが保安的かどうかに関わらず，保安的でない文脈には決して公開されない
— `PowerfulFeature.prototype^c 上に `snap^l ~propはない。
◎
The interface mixin members defined below will never be exposed in a non-secure context, regardless of whether the interface that includes them is. In a non-secure context, there will be no "snap" property on PowerfulFeature.prototype.
</span> */
[SecureContext]
interface mixin Snapshotable {
  Promise&lt;boolean&gt; snap();
};
PowerfulFeature includes Snapshotable;

/* <span class="comment">
他方，次の各 ~ifc~mixin~mbは、
`SecureContext$x 拡張属性を伴わない~host~ifcに内包された場合には，保安的でない文脈にも公開されることになる
— そのような文脈においても，
`PowerfulFeature.prototype^c 上に `log^l ~propはある。
◎
On the other hand, the following interface mixin members will be exposed to a non-secure context when included by a host interface that doesn’t have the [SecureContext] extended attribute. In a non-secure context, there will be a "log" property on PowerfulFeatures.prototype.
</span> */
interface mixin Loggable {
  Promise&lt;boolean&gt; log();
};
PowerfulFeatures includes Loggable;
</pre>
</div>

			</section>
			<section id="TreatNonObjectAsNull">
<h4>3.3.22. `TreatNonObjectAsNull^x</h4>

<div class="advisement">
<p>
`TreatNonObjectAsNull$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [TreatNonObjectAsNull]$fI
した上で論交することを，強く勧める。
◎
The [TreatNonObjectAsNull] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p><small class="non-normative">
`TreatNonObjectAsNull$x `拡張属性$は、`onclick^M や `onerror^M などの`~event-handler~IDL属性$の型として利用される，次のものに現れる：
`呼戻~関数$, `EventHandlerNonNull$T, `OnBeforeUnloadEventHandlerNonNull$T, `OnErrorEventHandlerNonNull$T
`HTML$r
◎
The [TreatNonObjectAsNull] extended attribute appears on the callback functions EventHandlerNonNull, OnBeforeUnloadEventHandlerNonNull, and OnErrorEventHandlerNonNull used as the type of event handler IDL attributes such as onclick and onerror. [HTML]
</small></p>
</div>

<p>
`TreatNonObjectAsNull$x `拡張属性$が `呼戻~関数$上に現れた場合、
`属性$に代入される［
`~nullable$`呼戻~関数$型であって, ~objではない
］どの値も， `null^V 値に変換するようにすることを指示する。
◎
If the [TreatNonObjectAsNull] extended attribute appears on a callback function, then it indicates that any value assigned to an attribute whose type is a nullable callback function that is not an object will be converted to the null value.
</p>

<p>
`TreatNonObjectAsNull$x の利用に課される特有の要件については、
`es-nullable-type$sec
を見よ。
◎
See §3.2.18 Nullable types — T? for the specific requirements that the use of [TreatNonObjectAsNull] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、
`TreatNonObjectAsNull$x 注釈付きの`呼戻~関数$型の属性と,
この`拡張属性$を伴わない`呼戻~関数$を持つ~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute whose type is a [TreatNonObjectAsNull]-annotated callback function and another whose type is a callback function without the extended attribute:
</p>

<pre class="webidl">
callback OccurrenceHandler = void (DOMString %details);

[TreatNonObjectAsNull]
callback ErrorHandler = void (DOMString %details);

interface Manager {
  attribute OccurrenceHandler? handler1;
  attribute ErrorHandler? handler2;
};
</pre>

<p>
~ES実装においては、~objでない値（ `Number^jt 値など）を
`handler1^c に代入したときと,
`handler2^c に代入したときとの挙動と異なる：
◎
In an ECMAScript implementation, assigning a value that is not an object (such as a Number value) to handler1 will have different behavior from that when assigning to handler2:
</p>

<pre class="es-code">
var %manager = getManager();  /* <span class="comment">
`Manager^T の~instanceを取得する。
◎
Get an instance of Manager.
</span> */

%manager.handler1 = function() { };
%manager.handler1;            /* <span class="comment" id="cp-eval-the-function">
当の function に評価される。
◎
Evaluates to the function.
</span> */

try {
  %manager.handler1 = 123;    /* <span class="comment">
`TypeError^jE を投出。
◎
Throws a TypeError.
</span> */
} catch (%e) {
}

%manager.handler2 = function() { };
%manager.handler2;            /* <!--cp-eval-the-function--> */

%manager.handler2 = 123;
%manager.handler2;            /* <span class="comment">
`null^jv に評価される。
◎
Evaluates to null.
</span> */
</pre>

</div>

			</section>
			<section id="TreatNullAs">
<h4>3.3.23. `TreatNullAs^x</h4>

<p class="advisement">
`TreatNullAs$x `拡張属性$は、望ましくない特色機能である。
旧来の~Web~platform特色機能を指定できるようにするためのみに存在するので、旧来の~API［
の挙動を指定するため／との整合性のため
］に要求されない限り，仕様に利用されるべきではない。
この特色機能を利用したいと望む編集者は、先に進む前に，
`Intent to use [TreatNullAs]$fI
した上で論交することを，強く勧める。
◎
The [TreatNullAs] extended attribute is an undesirable feature. It exists only so that legacy Web platform features can be specified. It should not be used in specifications unless required to specify the behavior of legacy APIs, or for consistency with these APIs. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<p>
`TreatNullAs$x `拡張属性$が `DOMString$T 型に現れた場合、次に従ってふるまう，新たな型を作成する
⇒
~ES `null^jv 値がこの~IDL型に変換される際には、既定による `null^l に文字列化される代わりに，空~文字列に変換される。
◎
If the [TreatNullAs] extended attribute appears on the DOMString type, it creates a new IDL type such that that when an ECMAScript null is converted to the IDL type, it will be handled differently from its default handling. Instead of being stringified to "null", which is the default, it will be converted to the empty string.
</p>

<p>
`TreatNullAs$x 拡張属性には、次の`識別子を引数にとる$ことが要求される：
`EmptyString^c
◎
The [TreatNullAs] extended attribute must take the identifier EmptyString.
</p>

<p>
`TreatNullAs$x `拡張属性が結付けられ$ている型は、 `DOMString$T で~MUST。
◎
The [TreatNullAs] extended attribute must not be associated with a type that is not DOMString.
</p>

<p class="note">注記：
すなわち、
`DOMString?^T 型であっても，
`TreatNullAs$x を利用してはならない
— `null^V はその型の妥当な値なので。
◎
Note: This means that even DOMString? must not use [TreatNullAs], since null is a valid value of that type.
</p>

<p>
`TreatNullAs$x の利用に課される特有の要件については、
`es-DOMString$sec
を見よ。
◎
See §3.2.9 DOMString for the specific requirements that the use of [TreatNullAs] entails.
</p>

<div class="example">
<p>
次の`~IDL片$が定義する［
属性 ／ 演算がとる引数
］の型は、 `TreatNullAs$x 拡張属性を有している：
◎
The following IDL fragment defines an interface that has one attribute whose type has the extended attribute, and one operation whose argument’s type has the extended attribute:
</p>

<pre class="webidl">
interface Dog {
  attribute DOMString name;
  attribute [TreatNullAs=EmptyString] DOMString owner;

  boolean isMemberOfBreed([TreatNullAs=EmptyString] DOMString %breedName);
};
</pre>

<p>
`Dog^T ~ifcを実装する~ES実装においては、
`owner^c ~propに代入される, あるいは
`isMemberOfBreed^c 関数の引数に渡される `null^jv 値は、
`null^l ではなく，空~文字列に変換されることになる：
◎
An ECMAScript implementation implementing the Dog interface would convert a null value assigned to the owner property or passed as the argument to the isMemberOfBreed function to the empty string rather than "null":
</p>

<pre class="es-code">
var %d = getDog();         
       /* <span class="comment">
%d は `Dog^T ~ifcを実装する~platform~objとする。
◎
Assume d is a platform object implementing the Dog
interface.
</span> */

%d.name = null;            /* <span class="comment">
文字列 `null^l を `.name^c ~propに代入する。
◎
This assigns the string &quot;null&quot; to the .name property.
</span> */

%d.owner = null;           /* <span class="comment">
文字列 "" を `.owner^c ~propに代入する。
◎
This assigns the string &quot;&quot; to the .owner property.
</span> */

%d.isMemberOfBreed(null);  /* <span class="comment">
文字列 "" を `isMemberOfBreed^c 関数に渡す。
◎
This passes the string &quot;&quot; to the isMemberOfBreed
function.
</span> */
</pre>
</div>
			</section>
			<section id="Unforgeable">
<h4>3.3.24. `Unforgeable^x</h4>


<p>
`Unforgeable$x `拡張属性$が［
静的でない［
`属性$／`演算$
］］上に現れた場合、その属性／演算は，［
その挙動を改変できない, かつ［
~obj上で~prop検索が遂行された際には，常にその属性の~prop値が返される
］］ような~ES~propとして反映されることになる。
特に，その~propは、非~configurableになり，かつ［
~objの原型~上ではなく, ~obj上の自前の~prop
］として存在することになる。
◎
If the [Unforgeable] extended attribute appears on a non-static attribute or non-static operations, it indicates that the attribute or operation will be reflected as an ECMAScript property in a way that means its behavior cannot be modified and that performing a property lookup on the object will always result in the attribute’s property value being returned. In particular, the property will be non-configurable and will exist as an own property on the object itself rather than on its prototype.
</p>

<p>
所与の~ifc %A 上にて
`Unforgeable$x `拡張属性$ 注釈付きで宣言されている［
属性／演算
］は、
%A 上において
`偽装不可@
であるとされる。
<!-- “偽装不可” という対訳は概念的な意味で汎用性には欠くが，元々は保安~上の要求に端を発するものと見られる -->
◎
An attribute or operation is said to be unforgeable on a given interface A if the attribute or operation is declared on A, and is annotated with the [Unforgeable] extended attribute.
</p>

<p>
`Unforgeable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Unforgeable] extended attribute must take no arguments.
</li>
	<li>
静的でない［
`属性$, `演算$
］以外の所に現れては~MUST_NOT。
◎
The [Unforgeable] extended attribute must not appear on anything other than an attribute or a non-static operation.＼
</li>
	<li>
ある演算~上に現れるならば、その~ifc上で同じ識別子を持つ他のすべての演算~上にも現れ~MUST。
◎
If it does appear on an operation, then it must appear on all operations with the same identifier on that interface.
</li>
	<li>
`~ns$上で宣言される属性~上に利用されては~MUST_NOT。
◎
The [Unforgeable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
［
属性／演算
］ %m が［
~ifc %A 上で`偽装不可$である
］~AND［
%A が別の~ifc %B の`被継承~ifc$である
］場合、
%B は，`識別子$が %m と同じであるような［
`正則~属性$, `正則~演算$
］（順不同）を持っては~MUST_NOT。
◎
If an attribute or operation X is unforgeable on an interface A, and A is one of the inherited interfaces of another interface B, then B must not have a regular attribute or regular operation with the same identifier as X.
</p>

<div class="note">

<p>
例えば，次は許容されない：
◎
For example, the following is disallowed:
</p>

<pre class="webidl">
interface A1 {
[Unforgeable] readonly attribute DOMString x;
};
interface B1 : A1 {
  void x();  /* <span class="comment">
妥当でない
— `A1^T の `x^M で隠蔽されるので。
◎
Invalid; would be shadowed by A1’s x.
</span> */
};

interface B2 : A1 { };
B2 includes M1;
interface mixin M1 {
  void x();  /* <span class="comment">
妥当でない
— `B2^T における `x^M の複製は `A1^T の `x^M で隠蔽されるので。
◎
Invalid; B2’s copy of x would be shadowed by A1’s x.
</span> */
};
</pre>

</div>


<p>
`Unforgeable$x の利用に課される特有の要件については、
`es-attributes$sec,
`es-operations$sec,
`es-platform-objects$sec,
`es-legacy-platform-objects$sec,
`legacy-platform-object-defineownproperty$sec
を見よ。
◎
See §3.6.7 Attributes, §3.6.8 Operations, §3.7 Platform objects implementing interfaces, §3.8 Legacy platform objects and §3.8.3 [[DefineOwnProperty]] for the specific requirements that the use of [Unforgeable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は
片方に `Unforgeable$x が指定された 2 個の`属性$を持つ~ifcを定義する：
◎
The following IDL fragment defines an interface that has two attributes, one of which is designated as [Unforgeable]:
</p>

<pre class="webidl">
interface System {
  [Unforgeable] readonly attribute DOMString username;
  readonly attribute long long loginTime;
};
</pre>

<p>
この~ifcの~ES実装においては、
`username^M 属性は，~obj自身において非~configurable~propとして公開されることになる：
◎
In an ECMAScript implementation of the interface, the username attribute will be exposed as a non-configurable property on the object itself:
</p>

<pre class="es-code">
var %system = getSystem();         /* <span class="comment">
`System^T の~instanceを取得する。
◎
Get an instance of System.
</span> */

%system.hasOwnProperty("username");             /* <!--cp-eval-true--> */
%system.hasOwnProperty("loginTime");            /* <!--cp-eval-false--> */
System.prototype.hasOwnProperty("username");   /* <!--cp-eval-false--> */
System.prototype.hasOwnProperty("loginTime");  /* <!--cp-eval-true--> */

try {
  /* <span class="comment">
この~callは失敗することになる — ~propは非~configurableなので。
◎
This call would fail, since the property is non-configurable.
</span> */
  Object.defineProperty(system, "username", { value: "administrator" });
} catch (%e) { }

/* <span class="comment">
次の `defineProperty^c ~callは成功する
— `System.prototype.loginTime^c が~configurableなので。
◎
This defineProperty call would succeed, because System.prototype.loginTime is configurable.
</span> */
var %forgedLoginTime = 5;
Object.defineProperty(System.prototype, "loginTime", { value: %forgedLoginTime });

%system.loginTime;  /* <span class="comment">
よって，これは今や %forgedLoginTime に評価される。
◎
So this now evaluates to forgedLoginTime.
</span> */
</pre>
</div>
			</section>
			<section id="Unscopable" class="L2">

<h4>3.3.25. `Unscopable^x</h4>

<p>
`Unscopable$x `拡張属性$が［
`正則~属性$／`正則~演算$
］上に現れた場合、［
その~ifc~mbを伴う~ifcを実装する~obj
］が，［
その~prop名 %N を，それに伴うどの［
~obj環境~record
］内にも，その基底~objとして内包しない
］ことを指示する。
その~~結果、 `with^c 文の中では，［
%N に合致する “素の” 識別子
］は，その~propには解決されないことになる。
このふるまいは、 %N を［
`~ifc原型~obj$上の
`unscopables$jS ~propの値
］に含ませることで，得られる。
◎
If the [Unscopable] extended attribute appears on a regular attribute or regular operation, it indicates that an object that implements an interface with the given interface member will not include its property name in any object environment record with it as its base object. The result of this is that bare identifiers matching the property name will not resolve to the property in a with statement. This is achieved by including the property name on the interface prototype object’s @@unscopables property’s value.
</p>

<p>
`Unscopable$x 拡張属性は：
◎
↓</p>

<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Unscopable] extended attribute must take no arguments.
</li>
	<li>
［
`正則~属性$, `正則~演算$
］以外の所に現れては~MUST_NOT。
◎
The [Unscopable] extended attribute must not appear on anything other than a regular attribute or regular operation.
</li>
	<li>
`~ns$上で宣言される属性~上に利用されては~MUST_NOT。
◎
The [Unscopable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>


<p>
`Unscopable$x の利用に課される特有の要件については、
`interface-prototype-object$sec
を見よ。
◎
See §3.6.3 Interface prototype object for the specific requirements that the use of [Unscopable] entails.
</p>

<div class="note">

<p>
例えば、次の~IDLが与えられたとき：
◎
For example, with the following IDL:
</p>

<pre class="webidl">
interface Thing {
  void f();
  [Unscopable] g();
};
</pre>

<p>
`f^l ~propは、 `with^c 文の中で “素の” 識別子により参照できるが，
`g^l ~propはできない：
◎
the “f” property an be referenced with a bare identifier in a with statement but the “g” property cannot:
</p>

<pre class="es-code">
var %thing = getThing();  /* <span class="comment">
`Thing^T の~instance
◎
An instance of Thing
</span> */
with (%thing) {
  f;                     /* <span class="comment">
`Function^jt ~objに評価される。
◎
Evaluates to a Function object.
</span> */
  g;                     /* <span class="comment">
`ReferenceError^jE を投出。
◎
Throws a ReferenceError.
</span> */
}
</pre>

</div>

			</section>
		</section>
		<section id="es-security">
<h3 title="Security">3.4. 保安~検査</h3>

<p>
以下の節の一部の~algoでは、所与の~objに対し
`保安~検査を遂行する@
ものがある。
この検査は、所与の［
`演算$／`属性$
］ %m に対する［
呼出／~access
］が許容されるべきかどうかを決定するために利用される。
保安~検査に対する入力は次の 3 つである：
◎
Certain algorithms in the sections below are defined to perform a security check on a given object. This check is used to determine whether a given operation invocation or attribute access should be allowed. The security check takes the following three inputs:
</p>

<ol>
	<li>
［
%m の呼出 ／ %m への~access
］が行われている当の`~platform~obj$
◎
the platform object on which the operation invocation or attribute access is being done,
</li>
	<li>
%m の`識別子$
◎
the identifier of the operation or attribute, and
</li>
	<li>
<p>
%m を実装する`関数~obj$の種別
— 次のいずれかとして与えられる：
</p>
		<ul>
			<li>
`~meth^C
（ %m が演算に対応するとき）
</li>
			<li>
`取得子^C
（ %m が “取得子” 関数に対応するとき）
</li>
			<li>
`設定子^C
（ %m が “設定子” 関数に対応するとき）
</li>
		</ul>
◎
the type of the function object – “method” (when it corresponds to an IDL operation), or “getter” or “setter” (when it corresponds to the getter or setter function of an IDL attribute).
</li>
</ol>


<p class="note">注記：
保安~検査がどう遂行されるかは、 HTML 仕様が定義する。
`HTML$r
◎
Note: The HTML Standard defines how a security check is performed. [HTML]
</p>



		</section>
		<section id="es-overloads">
<h3 title="Overload resolution algorithm">3.5. 多重定義~解決~algo</h3>

<p>
`関数類$の呼出を解決するために，
`多重定義~解決~algo@
が定義される：
◎
In order to define how function invocations are resolved, the overload resolution algorithm is defined.＼
</p>

<ul>
	<li>
<p>
その入力は：
</p>

<ul><li>%S
— `有効~多重定義~集合$
</li><li>%args
— %n 個の~ES値からなる`~list$
</li></ul>

◎
Its input is an effective overload set, S, and a list of ECMAScript values, arg0..n−1.＼
</li>
	<li>
<p>
その出力は，次の組である：
</p>

<ul><li>%S 内のいずれかの~entryの［
`演算$／`拡張属性$（構築子）
］
</li><li>各項が［
~IDL値, または特殊~値 `missing^C
］のいずれかであるような，~list
</li></ul>

◎
Its output is a pair consisting of the operation or extended attribute of one of S’s entries and a list of IDL values or the special value “missing”.＼
</li>
</ul>

<p>
~algoは次に従って挙動する：
◎
The algorithm behaves as follows:
</p>

<ol class="algorithm">
	<li>
%maxarg ~LET
%S 内の各~entryの`型~list$oL の長さのうち，最大
◎
Let maxarg be the length of the longest type list of the entries in S.
</li>
	<li>
%argcount ~LET min(%maxarg, %n)
◎
Initialize argcount to be min(maxarg, n).
</li>
	<li>
%S から，次を満たす~entryはすべて除去する
⇒
`型~list$oL の長さ ~NEQ %argcount
◎
Remove from S all entries whose type list is not of length argcount.
</li>
	<li>
~IF［
%S は空である
］
⇒
~throwTypeError
◎
If S is empty, then throw a TypeError.
</li>
	<li>
%method ~LET `undefined^jv
◎
↓</li>
	<li>
%entry ~LET ε
◎
↓</li>
	<li>
%値~list ~LET 空~list（各項は［
~IDL値, または特殊~値 `missing^C
］のいずれかになる）
◎
↓</li>
	<li>
<p>
~IF［
%S は 1 個の~entryのみからなる
］：
</p>
<ol ><li>%entry ~SET その~entry
</li><li>~GOTO `多重定義~解決済み^i
</li></ol>

◎
Initialize d to −1.
◎
Initialize method to undefined.
◎
If there is more than one entry in S, then＼
◎
set d to be the distinguishing argument index for the entries of S.
◎
Initialize values to be an empty list, where each entry will be either an IDL value or the special value “missing”.
</li>
	<li>
%d ~LET %S の~entryたちに対する`判別引数~index$
◎
↑</li>
	<li>
%i ~LET 0
◎
Initialize i to 0.
</li>
	<li>
<p>
~WHILE %i ~LT %d ：
◎
While i &lt; d:
</p>
		<ol>
			<li>
%V ~LET %args[ %i ]
◎
Let V be argi.
</li>
			<li>
<p>
%type ~LET %S から任意に選んだ~entryの `型~list$oL[ %i ]
◎
Let type be the type at index i in the type list of any entry in S.
</p>

<p class="note">注記：
この時点では、
%S 内のすべての~entryにわたる，［
`型~list$oL[ %i ], および
`省略可否~list$oL[ %i ]
］は 互いに同じである。
◎
Note: All entries in S at this point have the same type and optionality value at index i.
</p>
			</li>
			<li>
%省略可否 ~LET %S から任意に選んだ~entryの `省略可否~list$oL[ %i ]
◎
Let optionality be the value at index i in the list of optionality values of any entry in S.
</li>
			<li id="cp-if-optional">
<p>
~IF［
%省略可否 ~EQ “`省略可^C”
］~AND［
%V ~EQ `undefined^jv
］：
◎
If optionality is “optional” and V is undefined, then:
</p>
				<ol>
					<li>
~IF［
~index %i に位置する引数は `既定~値$を伴って宣言されている
］
⇒
その既定~値を %値~list に付加する
◎
If the argument at index i is declared with a default value, then append to values that default value.
</li>
					<li>
~ELSE
⇒
特殊~値 `missing^C を %値~list に付加する
◎
Otherwise, append to values the special value “missing”.
</li>
				</ol>
			</li>
			<li id="cp-append-convert1">
~ELSE
⇒
%V を %type 型の`~IDL値に変換-$した結果を %値~list に付加する
◎
Otherwise, append to values the result of converting V to IDL type type.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
<p>
%V ~LET %args[ %i ]
◎
If i = d, then:
◎
Let V be argi.
</p>
<p class="note">注記：
この引数が、多重定義を解決するために利用される。
◎
Note: This is the argument that will be used to resolve which overload is selected.
</p>
	</li>
	<li>
<div >

<p>
%entry ~SET 次の下位手続きを走らせた結果：
</p>
		<ol>
			<li>
~IF［
%V ~EQ `undefined^jv
］~AND［
%S の~entryに［
`省略可否~list$oL[ %i ] ~EQ “`省略可^C”
］なるものが在る
］
⇒
~RET 該当する~entry†
</li>
			<li>
~ELIF［［
%V ~IN { `null^jv, `undefined^jv }
］~AND［
%S 内の~entryに［
その `型~list$oL[ %i ] は `~nullable型を内包する$
］ものは在る
］
⇒
~RET 該当する~entry†
</li>
			<li>
<p>
下に示す “多重定義~選別表” の ~EACH( %行 ) に対し，挙げられた順に：
</p>
				<ol>
					<li>
~IF［
%V は行の 1 列目の条件を満たさない
］
⇒
~CONTINUE
</li>
					<li>
%型~集合 ~LET %行 の 2 列目に挙げられる型の集合
</li>
					<li>
<p>
~IF［
%S 内の~entryに［
その `型~list$oL[ %i ] の`最内縁の型$ %T は、次のいずれかを満たす
］ものは在る
］…：
</p>

<ul ><li>%T は %型~集合 に属する
</li><li>%T は`共用体~型$である
~AND
%T の`平坦化~mb型$の中に %型~集合 に属するものが在る
</li></ul>

<p>
…ならば
⇒
~RET 該当する~entry††
</p>
					</li>
				</ol>
			</li>
			<li>
~throwTypeError
</li>
		</ol>

<p class="trans-note">【†
いずれの場合も、 %S （`有効~多重定義~集合$）に課される拘束,
%i （`判別引数~index$）の定義により，該当する~entryは 1 つに限られる。
】【††
下の表のどの行についても、 2 列目に挙げられた型たちは，どの 2 つも互いに`判別可能$でない。
したがってこれも † と同様に、どの行についても， %S 内で条件を満たす~entryは高々 1 つになる。
】【
簡潔するため，この段では、原文の記述を再構成して，上の下位手続きと下の “多重定義~選別表” に集約している。
】</p>

◎
If V is undefined, and there is an entry in S whose list of optionality values has “optional” at index i, then remove from S all other entries.
◎
↓</div>

<table>
<caption>多重定義~選別表</caption>
<col span="1" style="width:50%;" /><col/>
<thead><tr><th>%V が満たす条件
<th>%型~集合
</thead>

<tbody><tr><td>
%V ~IN { `null^jv, `undefined^jv }
◎
Otherwise: if V is null or undefined, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`辞書~型$
◎
• a nullable type
• a dictionary type
• an annotated type whose inner type is one of the above types
• a union type or annotated union type that includes a nullable type or that has a dictionary type in its flattened members
◎
then remove from S all other entries.

<tr><td>
`~platform~obj$である
◎
Otherwise: if V is a platform object, and there is an entry in S that has one of the following types at position i of its type list,
<td>
%V が実装する`~ifc型$, `object$T
◎
• an interface type that V implements
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`DOMException^t ~objである
◎
Otherwise: if V is a DOMException platform object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`DOMException$T, `Error$T, `object$T
◎
• DOMException
• Error
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Object^jt
~AND
%V は `ErrorData^sl `内部~slot$を持つ
◎
Otherwise: if Type(V) is Object, V has an [[ErrorData]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`Error$T, `object$T
◎
• Error
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Object^jt
~AND
%V は `ArrayBufferData^sl `内部~slot$を持つ
◎
Otherwise: if Type(V) is Object, V has an [[ArrayBufferData]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`ArrayBuffer$T, `object$T
◎
• ArrayBuffer
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Object^jt
~AND
%V は `DataView^sl `内部~slot$を持つ
◎
Otherwise: if Type(V) is Object, V has a [[DataView]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`DataView$T, `object$T
◎
• DataView
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Object^jt
~AND
%V は `TypedArrayName^sl `内部~slot$を持つ
◎
Otherwise: if Type(V) is Object, V has a [[TypedArrayName]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
［
型~名が %V の `TypedArrayName^sl `内部~slot$に等しい `有型~配列~型$
］, `object$T
◎
• a typed array type whose name is equal to the value of V’s [[TypedArrayName]] internal slot
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`IsCallable$A( %V ) ~EQ ~T
◎
Otherwise: if IsCallable(V) is true, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`呼戻~関数$ 型, `object$T
◎
• a callback function type
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
<p>
［
`Type$A( %V ) ~EQ `Object^jt
］~AND［
次を遂行した結果の %method ~NEQ `undefined^jv
］：
</p>

<ol class="algorithm"
	><li>%method ~LET ? `GetMethod$A( %V, `iterator$jS )
</li></ol>

◎
Otherwise: if Type(V) is Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`連列~型$, `凍結~配列~型$
◎
• a sequence type
• a frozen array type
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
and after performing the following steps,
• Let method be ? GetMethod(V, @@iterator).
◎
method is not undefined, then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Object^jt
◎
Otherwise: if Type(V) is Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`呼戻~ifc$型, `辞書~型$, `~record型$, `object$T
◎
• a callback interface type
• a dictionary type
• a record type
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Boolean^jt
◎
Otherwise: if Type(V) is Boolean and there is an entry in S that has one of the following types at position i of its type list,
<td>
`boolean$T
◎
• boolean
• a nullable boolean
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Type$A( %V ) ~EQ `Number^jt
◎
Otherwise: if Type(V) is Number and there is an entry in S that has one of the following types at position i of its type list,
<td>
`実数~型$
◎
• a numeric type
• a nullable numeric type
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`文字列~型$
◎
• a string type
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`実数~型$
◎
• a numeric type
• a nullable numeric type
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`boolean$T
◎
• boolean
• a nullable boolean
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
<td>
`any$T
◎
Otherwise: if there is an entry in S that has any at position i of its type list, then remove from S all other entries.
◎
↑↑Otherwise: throw a TypeError.

</tbody></table>

	</li>
	<li>
`多重定義~解決済み^i：<br>
%callable ~LET %entry の `~callable$oL （ `演算$／`拡張属性$ ）
◎
Let callable be the operation or extended attribute of the single entry in S.
</li>
	<li>
<p>
~IF［
%i ~EQ %d
］~AND［
%method ~NEQ `undefined^jv
］：
◎
If i = d and method is not undefined, then
</p>
		<ol>
			<li>
%V ~LET %args[ %i ]
◎
Let V be argi.
</li>
			<li>
%T ~LET %entry の `型~list$oL[ %i ]
◎
Let T be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
~IF［
%T は`連列~型$である
］
⇒
( %V, %method )
から
型 %T の`連列~値を作成-$した結果を， %値~list に付加する
◎
If T is a sequence type, then append to values the result of creating a sequence of type T from V and method.
</li>
			<li>
~ELSE（ %T は`凍結~配列~型$である）
］
⇒
( %V, %method )
から
型 %T の`凍結~配列~値を作成-$した結果を， %値~list に付加する
◎
Otherwise, T is a frozen array type. Append to values the result of creating a frozen array of type T from V and method.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
<p>
~WHILE %i ~LT %argcount ：
◎
While i &lt; argcount:
</p>

		<ol>
			<li>
%V ~LET %args[ %i ]
◎
Let V be argi.
</li>
			<li>
%type ~LET %entry の `型~list$oL[ %i ]
◎
Let type be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
%省略可否 ~LET %entry の `省略可否~list$oL[ %i ]
◎
Let optionality be the value at index i in the list of optionality values of the remaining entry in S.
</li>
			<!--cp-if-optional-->
			<!--cp-append-convert1-->
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
<p>
~WHILE %i ~LT %callable が宣言している引数~個数：
◎
While i is less than the number of arguments callable is declared to take:
</p>

		<ol>
			<li>
~IF［
%callable の~index %i に位置する引数に
`既定~値$
が宣言されている
］
⇒
その既定~値を %値~list に付加する
◎
If callable’s argument at index i is declared with a default value, then append to values that default value.
</li>
			<li>
~ELIF［
%callable の~index %i に位置する引数は`可変個~引数$でない
］
⇒
特殊~値 `missing^Cを %値~list に付加する
◎
Otherwise, if callable’s argument at index i is not variadic, then append to values the special value “missing”.
</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
~RET ~pair &lt;%callable, %値~list&gt;
◎
Return the pair &lt;callable, values&gt;.
</li>
</ol>

<div class="note">

<p>
多重定義~解決~algoは、~callされている［
多重定義された`関数類$
］の識別に加えて、
~ES引数~値から，それぞれに対応する~IDL値への変換を遂行する。
概略的には次のように演算する。
◎
The overload resolution algorithm performs both the identification of which overloaded operation, constructor, etc. is being called, and the conversion of the ECMAScript argument values to their corresponding IDL values. Informally, it operates as follows.
</p>

<p>
まず、関数に渡された~ES引数の個数を考慮しつつ，妥当な多重定義の選定が行われる：
◎
First, the selection of valid overloads is done by considering the number of ECMAScript arguments that were passed in to the function:
</p>
	<ul>
		<li>
最長の多重定義~引数~listより多い引数が渡された場合、余分な引数は無視する。
◎
If there are more arguments passed in than the longest overload argument list, then they are ignored.
</li>
		<li>
考慮する必要があるのは、余分な引数を無視した後の引数の個数, および同じ個数の引数をとれる多重定義に限られる。
もし無ければ， `TypeError^jE が投出される。
◎
After ignoring these trailing arguments, only overloads that can take this exact number of arguments are considered. If there are none, then a TypeError is thrown.
</li>
	</ul>

<p>
~~正しい個数の引数をとる，多重定義の集合が得られたなら、
~ES値は左から右の順に変換される。
多重定義に対する制約の定義から、この時点で複数の多重定義の候補がある場合、引数~listの中で，最終的に選定される多重定義を判別する際の~~基準となる位置がある。
これが`判別引数~index$である。
◎
Once we have a set of possible overloads with the right number of arguments, the ECMAScript values are converted from left to right. The nature of the restrictions on overloading means that if we have multiple possible overloads at this point, then there will be one position in the argument list that will be used to distinguish which overload we will finally select; this is the distinguishing argument index.
</p>

<p>
まず最初に，判別引数より左に位置する引数を変換する（これらの引数については、同じ~indexに位置する他の多重定義の引数と同じ型であることが要件にされている）。
<!-- 判別引数~indexまで到達したなら、 -->
次に、対応し得る~IDL型を決定するために，判別引数~indexの位置に渡された~ES値の型を検分する。
これにより、呼出されることになる多重定義の最終的な選定が可能になる。
［
渡された値は `undefined^jv である
~AND
この位置に随意~引数を伴う多重定義がある
］場合、その多重定義が選定される。
このとき，渡された値の型に対する妥当な多重定義が無ければ、 `TypeError^jE が投出される。
判別引数~indexに位置する値の検分は副作用を持たない。
多重定義~解決~algoを走らすことに因る唯一の副作用は、
~ES値から~IDL値への変換-に因るものに限られる。
◎
We first convert the arguments to the left of the distinguishing argument. (There is a requirement that an argument to the left of the distinguishing argument index has the same type as in the other overloads, at the same index.) Then we inspect the type of the ECMAScript value that is passed in at the distinguishing argument index to determine which IDL type it may correspond to. This allows us to select the final overload that will be invoked. If the value passed in is undefined and there is an overload with an optional argument at this position, then we will choose that overload. If there is no valid overload for the type of value passed in here, then we throw a TypeError. The inspection of the value at the distinguishing argument index does not have any side effects; the only side effects that come from running the overload resolution algorithm are those that come from converting the ECMAScript values to IDL values.
</p>

<p>
この時点で，利用する多重定義が決定されたことになる。
しかる後、判別引数に後続する残りの引数~値も左から右の順に変換する。
ここでも，前述の余分な引数は、無視される。
◎
At this point, we have determined which overload to use. We now convert the remaining arguments, from the distinguishing argument onwards, again ignoring any additional arguments that were ignored due to being passed after the last possible argument.
</p>

<p>
随意~引数の~ES値からそれに等価な~IDL値へ変換する際には、
`undefined^jv は，［
随意~引数に`既定~値$が在ればそれに／
無ければ特殊~値 `missing^C に
］変換されることになる。
◎
When converting an optional argument’s ECMAScript value to its equivalent IDL value, undefined will be converted into the optional argument’s default value, if it has one, or a special value “missing” otherwise.
</p>

<p>
しかしながら、`可変個~引数$に対応する随意~引数に対する `undefined^jv は，特殊~値 `missing^C とは見なされない。
この場合の `undefined^jv 値は、必須の引数と同様に，`可変個~引数$の型に変換されることになる。
◎
Optional arguments corresponding to a final, variadic argument do not treat undefined as a special “missing” value, however. The undefined value is converted to the type of variadic argument as would be done for a non-optional argument.
</p>
</div>

		</section>
		<section id="es-interfaces">
<h3 title="Interfaces">3.6. ~ifc</h3>

<p>
所与の~ES大域環境 %G にて`公開され$ている，どの`~ifc$ %I に対しても：
</p>

<ul>
	<li>
<p>
%I が［
`NoInterfaceObject$x, `LegacyNamespace$x
］いずれの`拡張属性$も伴わずに宣言されているならば、
%I に対応して，次の特徴を有する~propが %G の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は %I の`識別子$。
</li>
	<li>
値は
`~ifc~obj@
と呼ばれる~obj
— この~objの特徴については、下の
`interface-object$sec
にて述べる。
</li>
	<li id="cp-has-attr-TFT">
属性 `TFT^desc を持つ。
</li>
</ul>

◎
For every non-callback interface that is exposed in a given ECMAScript global environment and that is not declared with the [NoInterfaceObject] or [LegacyNamespace] extended attributes, a corresponding property must exist on the ECMAScript environment’s global object. The name of the property is the identifier of the interface, and its value is an object called the interface object. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of an interface object are described in §3.6.1 Interface object.
</li>
	<li>
<p id="_legacy-window-alias">
%I に `LegacyWindowAlias$x 拡張属性が指定されている場合、その拡張属性~内の各`識別子$wAに対し，`首~大域~ifc$上にも［
次の特徴を有する，対応する~prop
］が存在し~MUST：
</p>

<ul><li>名前は その`識別子$wA
</li><li>値は %I に対応する`~ifc~obj$への参照
</li><li>属性 `TFT^desc を持つ
</li></ul>

◎
If the [LegacyWindowAlias] extended attribute was specified on an exposed interface, then for each identifier in [LegacyWindowAlias]'s identifiers there must be a corresponding property on the primary global interface. The name of the property is the given identifier, and its value is a reference to the interface object for the interface. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
	<li>
<p>
加えて，
%I に `NamedConstructor$x 拡張属性たちが伴われるならば、そのそれぞれに対し，次の特徴を有する~propが %G の大域~obj上に存在し~MUST：
</p>

<ul>
	<li>
名前は  `NamedConstructor$x 拡張属性の`識別子$nC。
</li>
	<li>
値は、
`有名~構築子@
と呼ばれる~obj
— それは、 %I を実装する~objの構築を可能にする。
この構築子の特徴については、下の
`named-constructors$sec
にて述べる。
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
In addition, for every [NamedConstructor] extended attribute on an exposed interface, a corresponding property must exist on the ECMAScript global object. The name of the property is the [NamedConstructor]'s identifier, and its value is an object called a named constructor, which allows construction of objects that implement the interface. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of a named constructor are described in §3.6.2 Named constructors.
</li>
</ul>


			<section>
<h4>3.6.X. 【この訳に特有の定義】</h4>

<p>
共通の記述を集約するため、この訳では次の非公式な定義を導入する：
</p>

<div>
<p>
所与の~prop %p の，~ifc %I に対する
`通例の所在@
は、次に従って決定される：
</p>

<ul>
	<li>
%A は `*Global$x `拡張属性$を伴って宣言されているならば、
%p は %A を実装する単独の~obj上に存在する。
</li>
	<li>
他の場合、 %p は もっぱら
%I の`~ifc原型~obj$上に存在する。
</li>
</ul>
◎
If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</div>

			<section id="interface-object">
<h4 title="Interface object">3.6.1. ~ifc~obj</h4>

<p>
所与の`~ifc$ %I に対応する`~ifc~obj$ %O は、`組込みの関数~obj$である：
◎
The interface object for a given interface is a built-in function object.＼
</p>

<ul>
	<li>
%O は、下の
`es-constants$sec,
`es-operations$sec
にて述べるように， %I 上に定義される［
`定数$, `静的~演算$
］のそれぞれに対応する~propを持つ。
◎
It has properties that correspond to the constants and static operations defined on that interface, as described in sections §3.6.6 Constants and §3.6.8 Operations.
</li>
	<li>
%I が `Constructor$x `拡張属性$を伴って宣言されている場合、
%O を`構築子$として~callして， %I を実装する~objを作成できる。
%I を関数として~callした場合、例外が投出される。
◎
If the interface is declared with a [Constructor] extended attribute, then the interface object can be called as a constructor to create an object that implements that interface. Calling that interface as a function will throw an exception.
</li>
	<li>
%I が `Constructor$x `拡張属性$を伴わずに宣言されている場合、`構築子$として~callしようが関数として~callしようが，例外が投出される。
◎
Interface objects whose interfaces are not declared with a [Constructor] extended attribute will throw when called, both as a function and as a constructor.
</li>
	<li>
%I が非~呼戻`~ifc$である場合、 %O には`~ifc原型~obj$と呼ばれる~objが結付けられ、 %I 上に定義される［
`正則~属性$, `正則~演算$
］のそれぞれに対応する~propを持つ。
詳細は
`interface-prototype-object$sec
にて述べる。
◎
An interface object for a non-callback interface has an associated object called the interface prototype object. This object has properties that correspond to the regular attributes and regular operations defined on the interface, and is described in more detail in §3.6.3 Interface prototype object.
</li>
</ul>

<p class="note">注記：
`~ifc~obj$は `関数~obj$なので、
`typeof^c 演算子が適用されたときは， "`function^jv" を返すことになる。
◎
Note: Since an interface object is a function object the typeof operator will return "function" when applied to an interface object.
</p>

<p>
所与の非~呼戻`~ifc$ %I に対する`~ifc~obj$は、次に従って作成される：
◎
The interface object for a given non-callback interface I with identifier id and in Realm realm is created as follows:
</p>

<ol class="algorithm">
	<li id="cp-let-realm-I">
%realm ~LET %I が属する`~Realm$
◎
↑</li>
	<li>
%id ~LET %I の識別子
◎
↑</li>
	<li>
<p id="cp-let-steps">
%手続き ~LET 以下を走らす手続き：
◎
Let steps be the following steps:
</p>
		<ol>
			<li>
~IF［
%I は `Constructor$x `拡張属性$を伴って宣言されていない
］
⇒
~throwTypeError
◎
If I was not declared with a [Constructor] extended attribute, then throw a TypeError.
</li>
			<li id="cp-throw-undef-NewTarget">
~IF［
`NewTarget$ ~EQ `undefined^jv
］
⇒
~throwTypeError
◎
If NewTarget is undefined, then throw a TypeError.
</li>
			<li id="cp-let-args-0-n-1">
%args ~LET 渡された引数たちからなる~list
◎
Let arg0..n−1 be the passed arguments.
</li>
			<!-- ＊Let id be the identifier of interface I. -->
			<li id="cp-constructor-overload-n">
%S ~LET %I 上の構築子のうち［
`識別子$ %id, 引数個数 %n
］から得られる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on interface I and with argument count n.
</li>
			<li id="cp-resolve-overload">
&lt;%constructor, %値~list&gt; ~LET
%S と %args を`多重定義~解決~algo$に渡した結果
◎
Let &lt;constructor, values&gt; be the result of passing S and arg0..n−1 to the overload resolution algorithm.
</li>
			<li id="cp-construct-with-values">
%R ~LET %値~list を一連の引数~値として， %constructor の記述に挙げられている手続きを遂行した結果
— 例外は再~投出する
◎
Let R be the result of performing the actions listed in the description of constructor with values as the argument values. Rethrow any exceptions.
</li>
			<li>
%O ~LET %R を`~ifc型$ %I の値とする下で`~ES値に変換-$した結果<!-- ＊ -->
◎
Let O be the result of converting R to an ECMAScript interface type value I.
</li>
			<li>
~Assert：
%O は %I を実装する~objである
◎
Assert: O is an object that implements I.
</li>
			<li>
~Assert：
%O.`Realm^sl ~EQ %F.`Realm^sl
◎
Assert: O.[[Realm]] is equal to F.[[Realm]].
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
	<li>
%constructorProto ~LET %realm の `FunctionPrototype$jI
◎
Let constructorProto be the %FunctionPrototype% of realm.
</li>
	<li>
~IF［
%I は他の~ifc %P を継承する
］
⇒
%constructorProto ~SET %realm に属する %P の`~ifc~obj$
◎
If I inherits from some other interface P, then set constructorProto to the interface object of P in realm.
</li>
	<li>
%F ~LET ! `CreateBuiltinFunction$A( %realm, %手続き, %constructorProto )
◎
Let F be ! CreateBuiltinFunction(realm, steps, constructorProto).
</li>
	<li id="cp-SetFunctionName-F-id">
! `SetFunctionName$A( %F, %id )
を遂行する
◎
Perform ! SetFunctionName(F, id).
</li>
	<li>
%length ~LET 0
◎
Let length be 0.
</li>
	<li>
<p>
~IF［
%I は `Constructor$x 拡張属性を伴って宣言されている
］：
◎
If I was declared with a [Constructor] extended attribute, then
</p>
		<ol>
			<li id="cp-constructor-overload0">
%S ~LET `~ifc$ %I 上の構築子のうち［
`識別子$ %id, 引数個数 0
］から得られる`有効~多重定義~集合$
◎
Initialize S to the effective overload set for constructors with identifier id on interface I and with argument count 0.
</li>
			<li>
%length ~SET %S 内の各~entryの引数~listの長さのうち，最小
◎
Set length to the length of the shortest argument list of the entries in S.
</li>
		</ol>
	</li>
	<li id="cp-DefinePropertyOrThrow-F-length">
! `DefinePropertyOrThrow$A( %F, `length^l, `FFT-length^desc )
を遂行する
◎
Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor{[[Value]]: length, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
	<li id="cp-let-proto-I">
%proto ~LET %I の`~ifc原型~obj$
◎
Let proto be the interface prototype object of interface I.
</li>
	<li id="cp-DefinePropertyOrThrow-F-proto">
! `DefinePropertyOrThrow$A( %F, `prototype^l, `FFF-proto^desc )
を遂行する
◎
Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: proto, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).
</li>
</ol>

				</section>
			</section>
			<section id="named-constructors">
<h4 title="Named constructors">3.6.2. 有名~構築子</h4>

<p>
`有名~構築子$は、`識別子$nCを伴う 1 個~以上の
`NamedConstructor$x `拡張属性$に因り存在することになる，`組込みの関数~obj$である。
それは、その拡張属性が現れる`~ifc$（以下 %I とする）を実装する~objの構築を可能にする。
◎
A named constructor that exists due to one or more [NamedConstructor] extended attributes with a given identifier is a built-in function object. It allows constructing objects that implement the interface on which the [NamedConstructor] extended attributes appear.
</p>

<p>
`有名~構築子$の記述に挙げられる手続きは、例外を投出しないならば，
%I を実装する~objを返さ~MUST。
この~objに`関連する~Realm$は、有名~構築子のそれと同じで~MUST。
◎
If the actions listed in the description of the constructor return normally, then those steps must return an object that implements interface I. This object’s relevant Realm must be the same as that of the named constructor.
</p>

<p>
所与の`~ifc$ %I に対する`有名~構築子$は、次に従って作成される：
◎
The named constructor with identifier id for a given interface I in Realm realm is created as follows:
</p>

<ol class="algorithm">
	<!--cp-let-realm-I-->
	<li>
%id ~LET `有名~構築子$の`識別子$nC
◎
↑</li>
	<li>
<!--cp-let-steps-->
		<ol>
			<!--cp-throw-undef-NewTarget-->
			<!--cp-let-args-0-n-1-->
			<!--cp-constructor-overload-n-->
			<!--cp-resolve-overload-->
			<!--cp-construct-with-values-->
			<li>
~RET %R を`~ifc型$ %I の値とする下で`~ES値に変換-$した結果
◎
Return the result of converting R to an ECMAScript interface type value I.
</li>
		</ol>
	</li>
	<li id="cp-F-CreateBuiltinFunction">
%F ~LET ! `CreateBuiltinFunction$A( %realm, %手続き, %realm の `FunctionPrototype$jI )
◎
Let F be ! CreateBuiltinFunction(realm, steps, the %FunctionPrototype% of realm).
</li>
	<!--cp-SetFunctionName-F-id-->
	<!--cp-constructor-overload0-->
	<li>
%length ~LET %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list of the entries in S.
</li>
	<!--cp-DefinePropertyOrThrow-F-length-->
	<!--cp-let-proto-I-->
	<!--cp-DefinePropertyOrThrow-F-proto-->
</ol>


			</section>
			<section id="interface-prototype-object">
<h4 title="Interface prototype object">3.6.3. ~ifc原型~obj</h4>


<p>
定義されたどの非~呼戻`~ifc$に対しても、その~ifcが `NoInterfaceObject$x `拡張属性$を伴って宣言されたかどうかに関わらず，対応する
`~ifc原型~obj@
が存在し~MUST。
特定0の~ifcに対する~ifc原型~objは、その~ifc上に定義される［
`正則~属性$, `正則~演算$
］のそれぞれに対応する~propを持つ。
これらの~propについての詳細は
`es-attributes$sec,
`es-operations$sec
にて述べる。
◎
There must exist an interface prototype object for every non-callback interface defined, regardless of whether the interface was declared with the [NoInterfaceObject] extended attribute. The interface prototype object for a particular interface has properties that correspond to the regular attributes and regular operations defined on that interface. These properties are described in more detail in sections §3.6.7 Attributes and §3.6.8 Operations.
</p>

<p>
`~ifc~obj$と同様に，`~ifc原型~obj$も その~ifc上に定義される`定数$に対応する~propを持つ（
`es-constants$sec
にて述べる）。
◎
As with the interface object, the interface prototype object also has properties that correspond to the constants defined on that interface, described in §3.6.6 Constants.
</p>

<div class="p">
<p>
その~ifc上に `NoInterfaceObject$x 拡張属性が指定されていない場合、その`~ifc原型~obj$は，次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `constructor^l
</li>
	<li>
値は その~ifcに対応する`~ifc~obj$への参照
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
If the [NoInterfaceObject] extended attribute was not specified on the interface, then the interface prototype object must also have a property named “constructor” with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } whose value is a reference to the interface object for the interface.

</div>


<p>
所与の~ifc %A の`~ifc原型~obj$は、次に与える値をとる， `Prototype^sl 内部~propを持た~MUST：
◎
The interface prototype object for a given interface A must have an internal [[Prototype]] property whose value is returned from the following steps:
</p>

<ol class="algorithm">
	<li>
［
%A は `*Global$x `拡張属性$を伴って宣言されている
］~AND［
%A は`有名~propを~support$する
］ならば、下の
`named-properties-object$sec
にて定義される， %A に対応する`有名~prop~obj$
◎
If A is declared with the [Global] or [PrimaryGlobal] extended attribute, and A supports named properties, then return the named properties object for A, as defined in §3.6.5 Named properties object.
</li>
	<li>
<p>
他の場合：
◎
Otherwise,
</p>
		<ol class="algorithm" id="cp-get-proto">
			<li>
［
%A は別の~ifc %B を継承するように宣言されている
］ならば、
%B の`~ifc原型~obj$
◎
If A is declared to inherit from another interface, then return the interface prototype object for the inherited interface.
</li>
			<li>
他の場合，［
%A が `LegacyArrayClass$x 拡張属性を伴って宣言されている
］ならば、
`ArrayPrototype$jI
◎
Otherwise, if A is declared with the [LegacyArrayClass] extended attribute, then return %ArrayPrototype%.
</li>
			<li>
他の場合、
`ObjectPrototype$jI
◎
Otherwise, return %ObjectPrototype%.
</li>
		</ol>
	</li>
</ol>

<div class="note">
<p>
`NoInterfaceObject$x `拡張属性$を伴って定義された`~ifc$の`~ifc原型~obj$は、~access可能になる。
例えば、次の~IDLでは：
◎
The interface prototype object of an interface that is defined with the [NoInterfaceObject] extended attribute will be accessible. For example, with the following IDL:
</p>

<pre class="webidl">
[NoInterfaceObject]
interface Foo {
};

partial interface Window {
  attribute Foo foo;
};
</pre>

<p>
`~ifc~obj$を通して
~ifc原型~objに~accessすることはできない（ `window.Foo^c として存在しないので）。
しかしながら、
`Foo^T の~instanceは，その `Prototype^sl 内部~prop値の取得 —
この例では， `Object.getPrototypeOf(window.foo)^c
— により，~ifc原型~objを公開し得る。
◎
it is not possible to access the interface prototype object through the interface object (since it does not exist as window.Foo). However, an instance of Foo can expose the interface prototype object by getting its internal [[Prototype]] property value – Object.getPrototypeOf(window.foo) in this example.
</p>

</div>

<div class="L2">

<div class="p">
<p>
~ifcのある`~mb$が  `Unscopable$x 拡張属性を伴って宣言されている場合（そのような~mbからなる集合を %M とする）、その~ifc原型~obj上には，次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `unscopables$jS ~symbol
</li>
	<li>
属性 `FFT^desc を持つ。
</li>
	<li>
値は 次の手続きで作成される~obj
</li>
</ul>
◎
If the interface has any member declared with the [Unscopable] extended attribute, then there must be a property on the interface prototype object whose name is the @@unscopables symbol, which has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }, and whose value is an object created as follows:
</div>

<ol class="algorithm">
	<li>
%object ~LET 式 `({})^c により作成されるものと同じ，新たな~obj
<!-- ObjectCreate -->
◎
Let object be a new object created as if by the expression ({}).
</li>
	<li>
<p>
%M 内の ~EACH ( %m ) に対し：
</p>
		<ol>
			<li>
`CreateDataProperty$A( %object, %m の`識別子$, `true^jv ) を~callする
</li>
		</ol>
◎
For each of the aforementioned interface members declared with the [Unscopable] extended attribute, call CreateDataProperty(object, the identifier of the interface member, true).
</li>
	<li>
~RET %object
◎
Return object.
</li>
</ol>

</div>

<p>
~ifc %A が `*Global$x `拡張属性$を伴って宣言されている場合、どの~ifc
%B ~IN { %A , %A の`被継承~ifc$ }
に対しても、
%B の`~ifc原型~obj$は，`変異不可の原型~exotic~obj$で~MUST。
◎
If the interface is declared with the [Global] or [PrimaryGlobal] extended attribute, or the interface is in the set of inherited interfaces for any other interface that is declared with one of these attributes, then the interface prototype object must be an immutable prototype exotic object.
</p>

<p>
`~ifc原型~obj$の `~class文字列$は［
`~ifc$の`識別子$,
文字列 `Prototype^l
］の連結である。
◎
The class string of an interface prototype object is the concatenation of the interface’s identifier and the string “Prototype”.
</p>
			</section>
			<section id="legacy-callback-interface-object">
<h4 title="Legacy callback interface object">3.6.4. 旧来の呼戻~ifc~obj</h4>

<div class="p">
<p>
所与の~ES大域~環境 %G にて`公開され$ている どの`呼戻~ifc$ %I に対しても、
%I 上に`定数$が定義されているならば
%G の大域~obj上に，次の特徴を有するような 対応する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は %I の`識別子$
</li>
	<li>
値は
`旧来の呼戻~ifc~obj@
と呼ばれる~obj
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
For every callback interface that is exposed in a given ECMAScript global environment and on which constants are defined, a corresponding property must exist on the ECMAScript environment’s global object. The name of the property is the identifier of the interface, and its value is an object called the legacy callback interface object. The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</div>


<p>
所与の`~ifc$ %I の`旧来の呼戻~ifc~obj$は、`組込みの関数~obj$であり、下の
`es-constants$sec
にて述べるように， %I 上に定義される`定数$のそれぞれに対応する~propを持つ。
◎
The legacy callback interface object for a given callback interface is a built-in function object. It has properties that correspond to the constants defined on that interface, as described in sections §3.6.6 Constants.
</p>

<p class="note">注記：
`旧来の呼戻~ifc~obj$は `関数~obj$なので、
`typeof^c 演算子が適用されたときは， "`function^jv" を返すことになる。
◎
Note: Since a legacy callback interface object is a function object the typeof operator will return "function" when applied to a legacy callback interface object.
</p>

<p>
所与の`呼戻~ifc$ %I の`旧来の呼戻~ifc~obj$は、次に従って作成される：
◎
The legacy callback interface object for a given callback interface with identifier id and in Realm realm is created as follows:
</p>

<ol class="algorithm">
	<!--cp-let-realm-I-->
	<li>
%id ~LET %I の識別子
◎
↑</li>
	<li>
<!--cp-let-steps-->
		<ol>
			<!--cp-throw-typeerror-->
		</ol>
	</li>
	<!--cp-F-CreateBuiltinFunction-->
	<!--cp-SetFunctionName-F-id-->
	<li id="cp-DefinePropertyOrThrow-F-0">
! `DefinePropertyOrThrow$A( %F, `length^l, `FFT-0^desc )
を遂行する
◎
Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor{[[Value]]: 0, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
</ol>

			</section>
			<section id="named-properties-object">
<h4 title="Named properties object">3.6.5. 有名~prop~obj</h4>


<p>
`*Global$x `拡張属性$を伴って宣言されていて, かつ
`有名~propを~support$する
どの`~ifc$に対しても、その~ifcに対応する
`有名~prop~obj@
と呼ばれる~objが，当の有名~propが公開される~ifc上に存在し~MUST。
◎
For every interface declared with the [Global] or [PrimaryGlobal] extended attribute that supports named properties, there must exist an object known as the named properties object for that interface on which named properties are exposed.
</p>

<p>
所与の~ifc %A に対応する`有名~prop~obj$は、次に従って決定される値をとる， `Prototype^sl 内部~propを持た~MUST：
◎
The named properties object for a given interface A must have an internal [[Prototype]] property whose value is returned from the following steps:
</p>

<!--cp-get-proto-->

<p>
`有名~prop~obj$の `~class文字列$は［
`~ifc$の`識別子$,
文字列 `Properties^l
］の連結である。
◎
The class string of a named properties object is the concatenation of the interface’s identifier and the string “Properties”.
</p>

				<section id="named-properties-object-getownproperty">
<h5>3.6.5.1. `GetOwnProperty^sl</h5>


<p>
`有名~prop~obj$ %O の `GetOwnProperty^sl 内部~methが ~prop名 %P を伴って~callされたときは、次の手続きを行う：
◎
When the [[GetOwnProperty]] internal method of a named properties object O is called with property key P, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
%A ~LET %O に対する`~ifc$
◎
Let A be the interface for the named properties object O.
</li>
	<li>
<p>
%object ~LET %O が属する~ES大域環境に属する， %A を実装する~~唯一の~obj
<!--  -->
◎
Let object be the sole object from O’s ECMAScript global environment that implements A.
</p>

<p class="note">注記：
例えば，`~ifc$が HTML5 で定義される `Window^T ~ifcならば、この大域環境の window ~objが~~唯一の~objになる。
◎
Note: For example, if the interface is the Window interface, then the sole object will be this global environment’s window object.
</p>

</li>
	<li>
<p>
~IF［
`有名~propは可視か？$( %P, %object ) ~EQ ~T
］：
◎
If the result of running the named property visibility algorithm with property name P and object object is true, then:
</p>
		<ol>
			<li>
%演算 ~LET `有名~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
			<li id="cp-let-uninitialized">
%value ~LET 未初期化の変数
◎
Let value be an uninitialized variable.
</li>
			<li id="cp-determine-ifndef">
~IF［
%演算 は `識別子$なしに定義されている
］
⇒
%value ~SET ［
名前 %P に対し，~ifcの記述に挙げられている
`有名~propの値を決定する$
手続きを遂行した結果
］
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of a named property with P as the name.
</li>
			<li id="cp-set-as-desc1">
~ELSE
⇒
%value ~SET ［
( %P )
を引数に， %演算 の記述に挙げられている手続きを遂行した結果
］
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with P as the only argument value.
</li>
			<li>
<p id="cp-ret-new-desc">
~RET 次の様な新たな`~pdesc$：
◎
Let desc be a newly created Property Descriptor with no fields.
</p>

<div>
&nbsp;&nbsp; `TET-V^desc — ここで：

				<ul>
					<li id="cp-let-convert2">
%V ~LET %value を`~ES値に変換-$した結果
</li>
					<li>
%E ~LET ［
%A が実装するある~ifcに `LegacyUnenumerableNamedProperties$x `拡張属性$が伴われているならば `false^jv ／
~ELSE_ `true^jv
］
</li>
				</ul>

◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If A implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Writable]] to true and desc.[[Configurable]] to true.
◎
Return desc.
</div>
			</li>
		</ol>
	</li>
	<li id="cp-return-OrdinaryGetOwnProperty">
~RET
`OrdinaryGetOwnProperty$A( %O, %P )
◎
Return OrdinaryGetOwnProperty(O, P).
</li>
</ol>

				</section>
				<section id="named-properties-object-defineownproperty">

<h5>3.6.5.2. `DefineOwnProperty^sl</h5>

<p>
`有名~prop~obj$の `DefineOwnProperty^sl 内部~methが~callされたときは、次の手続きを行う：
◎
When the [[DefineOwnProperty]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>

				</section>
				<section id="named-properties-object-delete">

<h5>3.6.5.3. `Delete^sl</h5>

<p>
`有名~prop~obj$の `Delete^sl 内部~methが~callされたときには，次の手続きを行う：
◎
When the [[Delete]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>


				</section>
				<section id="named-properties-object-setprototypeof">
<h5>3.6.5.4. `SetPrototypeOf^sl</h5>

<p>
`有名~prop~obj$ %O の `SetPrototypeOf^sl 内部~methが，~ES言語~値 %V で~callされたときは、次の手続きを行う：
◎
When the [[SetPrototypeOf]] internal method of a named properties object O is called with ECMAScript language value V, the following step is taken:
</p>

<ol class="algorithm" id="cp-SetImmutablePrototype">
	<li>
~RET
? `SetImmutablePrototype$A( %O, %V )
◎
Return ? SetImmutablePrototype(O, V).
</li>
</ol>

				</section>
				<section id="named-properties-object-preventextensions">
<h5>3.6.5.5. `PreventExtensions^sl</h5>

<p>
`有名~prop~obj$の `PreventExtensions^sl 内部~methが~callされたときは、次の手続きを行う：
◎
When the [[PreventExtensions]] internal method of a named properties object is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>


<p class="note">注記:
これにより、`有名~prop~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^sl を失敗させることにより。
◎
Note: this keeps named properties object extensible by making [[PreventExtensions]] fail.
</p>
				</section>
			</section>
			<section id="es-constants">
<h4 title="Constants">3.6.6. 定数</h4>


<p>
`定数$のうち，［
`~ifc$ %I 上で定義されている
］~AND［
`公開され$ている
］ものに対しては、次の特徴を有する，対応する~propが存在し~MUST：
◎
For each exposed constant defined on an interface A, there must be a corresponding property. The property has the following characteristics:
</p>
<ul>
	<li>
名前は 定数の`識別子$。
◎
The name of the property is the identifier of the constant.
</li>
	<li>
<p>
~propの所在は、次に従って決定される：
◎
The location of the property is determined as follows:
</p>
		<ul>
			<li>
%I は `*Global$x `拡張属性$を伴って宣言されているならば、
%I を実装する単独の~obj上に存在する。
◎
If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
</li>
			<li>
他の場合， %I の`~ifc原型~obj$ %O は在るならば、もっぱら %O 上に存在する。
◎
Otherwise, if the interface has an interface prototype object, then the property exists on it.
</li>
		</ul>
	</li>
	<li>
値は その~IDL定数~値を`~ES値に変換-$した結果。
◎
The value of the property is that which is obtained by converting the constant’s IDL value to an ECMAScript value.
</li>
	<li>
属性 `FTF^desc を持つ。
◎
The property has attributes { [[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false }.
</li>
</ul>

<p>
加えて、 %I の［
`~ifc原型~obj$ ／ `旧来の呼戻~ifc~obj$
］が在る場合は、同じ特徴を有する~propが，その~obj上にも存在し~MUST。
◎
In addition, a property with the same characteristics must exist on the interface object or the legacy callback interface object, if either of those objects exists.
</p>
			</section>
			<section id="es-attributes">
<h4 title="Attributes">3.6.7. 属性</h4>


<p>
`~ifc$に`公開され$ている各 `属性$（以下， %属性 と記す）に対しては、次の特徴を有する，対応する~propが存在し~MUST：
◎
For each exposed attribute of the interface there must exist a corresponding property. The characteristics of this property are as follows:
</p>

<ul>
	<li>
名前は %属性 の`識別子$
◎
The name of the property is the identifier of the attribute.
</li>
	<li>
<p id="cp-proploc">
~propの所在は、次に従って決定される：
◎
The location of the property is determined as follows:
</p>
		<ul>
			<li>
%属性 は`静的~属性$であるならば、対応する単独の~propが， ~ifcに対する`~ifc~obj$上に存在する。
◎
If the attribute is a static attribute, then there is a single corresponding property and it exists on the interface’s interface object.
</li>
			<li>
他の場合， %属性 は~ifc上で`偽装不可$であるならば、~propは，
~ifcを実装するどの~obj上にも存在する。
◎
Otherwise, if the attribute is unforgeable on the interface＼
</li>
			<li id="cp-exist-normal-loc">
他の場合、~propは ~ifcに対する`通例の所在$にある。
◎
or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface.
◎
Otherwise, the property exists solely on the interface’s interface prototype object.
</li>
		</ul>
	</li>
	<li>
<p>
属性
{ [[Get]]: %G, [[Set]]: %S, [[Enumerable]]: `true^jv, [[Configurable]]: %configurable }
を持つ
— ここで：
◎
The property has attributes { [[Get]]: G, [[Set]]: S, [[Enumerable]]: true, [[Configurable]]: configurable }, where:
</p>
		<ul>
			<li>
%configurable は［
%属性 が `Unforgeable$x 拡張属性を伴って宣言されているならば `false^jv ／
~ELSE_ `true^jv
］
◎
configurable is false if the attribute was declared with the [Unforgeable] extended attribute and true otherwise;
</li>
			<li>
%G は `属性~取得子$, 
%S は `属性~設定子$であり，いずれも
( %属性, ~ifc, ［
~propの所在である~obj
］に`関連する~Realm$ )
から，下に述べるように作成されるとする。
◎
G is the attribute getter created given the attribute, the interface, and the relevant Realm of the object that is the location of the property; and
◎
S is the attribute setter created given the attribute, the interface, and the relevant Realm of the object that is the location of the property.
</li>
		</ul>
	</li>
</ul>


<p>
`属性~取得子@
は、所与の
( `属性$ %属性, ［`~ifc$／`~ns$］ %target, `~Realm$ %realm )
から，次に従って作成される：
◎
The attribute getter is created as follows, given an attribute attribute, a namespace or interface target, and a Realm realm:
</p>

<ol class="algorithm">
	<li>
<p>
%手続き ~LET 以下を走らす手続き
— ただし，手続きの中で`例外が投出された$ときは、その下に与える手続きを走らすとする：
◎
Let steps be the following series of steps:
◎
Try running the following steps:
</p>
		<ol>
			<li>
%O ~LET `null^jv
◎
Let O be null.
</li>
			<li>
<p>
~IF［
%target は`~ifc$である
］~AND［
%属性 は`正則~属性$である
］：
◎
If target is an interface, and attribute is a regular attribute:
</p>

				<ol>
					<li id="cp-let-O-realm-global-obj">
<p >
~IF［
`this^jv 値 ~IN { `null^jv, `undefined^jv }
］
⇒
%O ~SET %realm の`大域~obj$
</p>

<p>
（この大域~objが %target を実装しない, かつ
`LenientThis$x は指定されていない場合、数~段~先で `TypeError^jE が生じることになる。）</p>

◎
If the this value is null or undefined, set O to realm’s global object. (This will subsequently cause a TypeError in a few steps, if the global object does not implement target and [LenientThis] is not specified.)
</li>
					<li id="cp-set-O-this-value">
~ELSE
⇒
%O ~SET `this^jv 値
◎
Otherwise, set O to the this value.
</li>
					<li>
~IF［
%O は `~platform~obj$である
］
⇒
( %O, %属性 の`識別子$, `取得子^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing O, attribute’s identifier, and "getter".
</li>
					<li>
<p>
~IF［
%O は %target を実装する`~platform~obj$ではない
］：
◎
If O is not a platform object that implements the interface target, then:
</p>

						<ol>
							<li>
~IF［
%属性
`LenientThis$x `拡張属性$が指定されている
］
⇒
~RET `undefined^jv
◎
If attribute was specified with the [LenientThis] extended attribute, then return undefined.
</li>
							<li>
~ELSE
⇒
~throwTypeError
◎
Otherwise, throw a TypeError.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%R ~LET %O 上で %属性 の`下層の値を取得-$した結果
◎
Let R be the result of getting the underlying value of attribute given O.
</li>
			<li>
~RET %R を
%属性 に宣言されている型から`~ES値に変換-$した結果
◎
Return the result of converting R to an ECMAScript value of the type attribute is declared as.
</li>
		</ol>

<p id="cp-if-E-thrown">
上で`例外が投出された$ときは、その例外 %E に対し：
◎
And then, if an exception E was thrown:
</p>
		<ol>
			<li>
~IF［
%属性 の型は`~promise型$である
］
⇒
~RET
! `Call$A( `Promise_reject$jI, `Promise$jI, «%E» )
◎
If attribute’s type is a promise type, then return ! Call(%Promise_reject%, %Promise%, «E»)
</li>
			<li id="cp-throw-E">
~ELSE
⇒
`~THROW$ %E
◎
Otherwise, end these steps and allow the exception to propagate.
</li>
		</ol>
	</li>
	<!--cp-F-CreateBuiltinFunction-->
	<li>
%name ~LET ［
文字列 `get^l, %属性 の`識別子$
］を順に連結した結果
◎
Let name be the string "get " prepended to attribute’s identifier.
</li>
	<li id="cp-SetFunctionName-name-F">
! `SetFunctionName$A( %F, %name )
を遂行する
◎
Perform ! SetFunctionName(F, name).
</li>
	<!--cp-DefinePropertyOrThrow-F-0-->
	<li>
~RET %F
◎
Return F.
</li>
</ol>

<p>
`属性~設定子@
は、所与の
( `属性$ %属性, `~ifc$ %target, `~Realm$ %realm )
から，次に従って作成される：
◎
The attribute setter is created as follows, given an attribute attribute, an interface target, and a Realm realm:
</p>

<ol class="algorithm">
	<li>
~IF［
%属性 は`読専$である
］~AND［［
`LenientSetter$x, `PutForwards$x, `Replaceable$x
］いずれの`拡張属性$も伴わない
］
⇒
~RET `undefined^jv
— `属性~設定子$ 関数はない。
◎
If attribute is read only and does not have a [LenientSetter], [PutForwards] or [Replaceable] extended attribute, return undefined; there is no attribute setter function.
</li>
	<li>
~Assert：
%属性 の型は`~promise型$でない
◎
Assert: attribute’s type is not a promise type.
</li>
	<li>
<p>
%手続き ~LET 以下を走らす手続き：
◎
Let steps be the following series of steps:
</p>

		<ol>
			<li>
~IF［
渡された引数の個数 ~EQ 0
］
⇒
~throwTypeError
◎
If no arguments were passed, then throw a TypeError.
</li>
			<li>
%V ~LET 渡された最初の引数の値
◎
Let V be the value of the first argument passed.
</li>
			<li>
%id ~LET %属性 の`識別子$
◎
Let id be attribute’s identifier.
</li>
			<li>
%O ~LET `null^jv
◎
Let O be null.
</li>
			<li>
<p>
~IF［
%属性 は`正則~属性$である
］：
◎
If attribute is a regular attribute:
</p>
				<ol>
					<!--cp-let-O-realm-global-obj-->
					<!--cp-set-O-this-value-->
					<li>
~IF［
%O は`~platform~obj$である
］
⇒
( %O, %id, `設定子^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing O, id, and "setter".
</li>
					<li>
%validThis ~LET ［
%O は %target を実装する`~platform~obj$であるならば ~T ／
~ELSE_ ~F
］
◎
Let validThis be true if O is a platform object that implements the interface target, or false otherwise.
</li>
					<li>
~IF［
%validThis ~EQ ~F
~AND
%属性 には `LenientThis$x `拡張属性$は指定されていない
］
⇒
~throwTypeError
◎
If validThis is false and attribute was not specified with the [LenientThis] extended attribute, then throw a TypeError.
</li>
					<li>
<p>
~IF［
%属性 は `Replaceable$x 拡張属性を伴って宣言されている
］：
◎
If attribute is declared with the [Replaceable] extended attribute, then:
</p>

						<ol>
							<li>
? `CreateDataProperty$A( %O, %id, %V )
を遂行する
◎
Perform ? CreateDataProperty(O, id, V).
</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
					<li>
~IF［
%validThis ~EQ ~F
］
⇒
~RET `undefined^jv
◎
If validThis is false, then return undefined.
</li>
					<li>
~IF［
%属性 は `LenientSetter$x 拡張属性を伴って宣言されている
］
⇒
~RET `undefined^jv
◎
If attribute is declared with a [LenientSetter] extended attribute, then return undefined.
</li>
					<li>
<p>
~IF［
%属性 は `PutForwards$x 拡張属性を伴って宣言されている
］：
◎
If attribute is declared with a [PutForwards] extended attribute, then:
</p>

						<ol>
							<li>
%Q ~LET ? `Get$A( %O, %id )
◎
Let Q be ? Get(O, id).
</li>
							<li>
~IF［
`Type$A( %Q ）~NEQ `Object^jt
］
⇒
~throwTypeError
◎
If Type(Q) is not Object, then throw a TypeError.
</li>
							<li>
%forwardId ~LET `PutForwards$x 拡張属性の識別子~引数
◎
Let forwardId be the identifier argument of the [PutForwards] extended attribute.
</li>
							<li>
? `Set$A( %Q, %forwardId, %V, `true^jv )
を遂行する
◎
Perform ? Set(Q, forwardId, V, true).
</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%idlValue ~LET 未初期化の変数
◎
Let idlValue be determined as follows:
</li>
			<li>
<p>
~IF［
%属性 の型 は`列挙$である
］：
◎
attribute’s type is an enumeration
</p>
				<ol>
					<li>
%S ~LET ? `ToString$A( %V )
◎
Let S be ? ToString(V).
</li>
					<li>
~IF［
%S は `列挙~値$のいずれでもない
］
⇒
~RET `undefined^jv
◎
If S is not one of the enumeration’s values, then return undefined.
</li>
					<li>
%idlValue ~SET %S に等しい列挙~値
◎
Otherwise, idlValue is the enumeration value equal to S.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%idlValue ~SET %V を%属性 の型の`~IDL値に変換-$した結果
◎
Otherwise
• idlValue is the result of converting V to an IDL value of attribute’s type.
</li>
			<li>
%idlValue を用いて， %属性 の記述に挙げられている 設定-時に生じる手続きを
— %O ~NEQ `null^jv ならば %O 上で —
遂行する
◎
Perform the actions listed in the description of attribute that occur on setting, on O if O is not null.
</li>
			<li>
~RET `undefined^jv
◎
Return undefined
</li>
		</ol>
	</li>
	<!--cp-F-CreateBuiltinFunction-->
	<li>
%name ~LET 文字列 `set^l, %id を順に連結した結果
◎
Let name be the string "set " prepended to id.
</li>
	<!--cp-SetFunctionName-name-F-->
	<li>
! `DefinePropertyOrThrow$A( %F, `length^l, `FFT-1^desc )
を遂行する
◎
Perform ! DefinePropertyOrThrow(F, "length", PropertyDescriptor{[[Value]]: 1, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
</li>
	<li>
~RET %F
◎
Return F.
</li>
</ol>

<p class="note">注記：
1 個の~IDL属性に対応する~propは 1 個に限られるが、~accessor~prop［
取得子／設定子
］には，［［
その~IDL属性に対応する~prop
］が~accessされた
］~objを指す `this^jv 値が渡されるので、それらの~propは，~instanceに特有の~dataを公開できる。
◎
Note: Although there is only a single property for an IDL attribute, since accessor property getters and setters are passed a this value for the object on which property corresponding to the IDL attribute is accessed, they are able to expose instance-specific data.
</p>

<p class="note">注記：
`読専$`属性$に対応する~propへの代入を試みた結果は、それを行う~scriptが~strict-modeであるかどうかに依存して異なる挙動になる。
~strict-modeの場合、その種の代入により `TypeError^jE が投出されることになる。
~strict-modeでない場合、代入の試みは無視されることになる。
◎
Note: Attempting to assign to a property corresponding to a read only attribute results in different behavior depending on whether the script doing so is in strict mode. When in strict mode, such an assignment will result in a TypeError being thrown. When not in strict mode, the assignment attempt will be ignored.
</p>

			</section>
			<section id="es-operations">
<h4 title="Operations">3.6.8. 演算</h4>

<p>
`演算$ %演算 のうち，［
`~ifc$上に定義されている
~AND
`公開され$ている
］ものに対しては、それぞれの一意な`識別子$ごとに，次の特徴を有する 対応する~propが存在し~MUST
—
ただし、［
その`識別子$, 引数個数 0
］の`演算$からなる`有効~多重定義~集合$が空~集合である場合
【要するに %演算 が識別子を伴わない場合？】
は除く：
◎
For each unique identifier of an exposed operation defined on the interface, there must exist a corresponding property, unless the effective overload set for that identifier and operation and with an argument count of 0 has no entries.
◎
The characteristics of this property are as follows:
</p>

<ul>
	<li>
名前は %演算 の`識別子$
◎
The name of the property is the identifier.
</li>
	<li>
<!--cp-proploc-->
		<ul>
			<li>
%演算 が`静的~演算$である場合、~propは ~ifcに対する`~ifc~obj$上に存在する。
◎
If the operation is static, then the property exists on the interface object.
</li>
			<li><!-- copy* -->
他の場合， %演算 が~ifc上で`偽装不可$であるならば、~propは，~ifcを実装するどの~obj上にも存在する。
◎
Otherwise, if the operation is unforgeable on the interface＼
</li>
			<!--cp-exist-normal-loc-->
		</ul>
	</li>
	<li>
属性 `BTB^desc を持つ。
ここで %B は［
%演算 が~ifc上で`偽装不可$である場合は `false^jv ／
~ELSE_ `true^jv
］である。
◎
The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the operation is unforgeable on the interface, and true otherwise.
</li>
	<li>
<p>
~propの~値は、次の結果で与えられる
⇒
`演算~関数を作成する$( %演算, ~ifc, ~propが所在する~objに`関連する~Realm$ )
◎
The value of the property is the result of creating an operation function given the operation, the interface, and the relevant Realm of the object that is the location of the property.
</p>

<p class="note">注記：
すなわち，当の演算が`~includes文$を通して可用にされていたとしても、当の演算が元々宣言された`~ifc~mixin$ではなく，`~ifc~mixin$を`内包-$している~ifcを渡す。
◎
Note: that is, even if an includes statement was used to make an operation available on the interface, we pass in the interface which includes the interface mixin, and not the interface mixin on which the operation was originally declared.
</p>
	</li>
</ul>


<p class="advisement">
上の記述には、とりわけ部分的~ifc周りで，~bugがある。
<a href="https://github.com/heycam/webidl/issues/164">issue #164</a>
を見よ。
◎
The above description has some bugs, especially around partial interfaces. See issue #164.
</p>


<p>
`~ns$にて宣言された演算に対応する~propについては、
`namespace-object$sec
に述べる（~ifcについても、最終的には~nsと同様に，~propを明示的に~installする~~方式に~~移行することが望まれている。）
◎
For namespaces, the properties corresponding to each declared operation are described in §3.11.1 Namespace object. (We hope to eventually move interfaces to the same explicit property-installation style as namespaces.)
</p>

<p>
`演算~関数を作成する@
ときは、所与の
( `演算$ %演算, `~ns$または`~ifc$ %target, `~Realm$ %realm )
に対し：
◎
To create an operation function, given an operation op, a namespace or interface target, and a Realm realm:
</p>


<ol class="algorithm">
	<li>
%id ~LET %演算 の`識別子$
◎
Let id be op’s identifier.
</li>
	<li>
<p>
%手続き ~LET
所与の関数~引数~値 %arg<sub>0..%n−1</sub> に対し，次を走らす手続き
— ただし，手続きの中で`例外が投出された$ときは、その下に与える手続きを走らすとする：
◎
Let steps be the following series of steps, given function argument values arg0..n−1:
◎
Try running the following steps:
</p>

		<ol>
			<li>
%O ~LET `null^jv
◎
Let O be null.
</li>
			<li>
<p>
~IF［
%target は`~ifc$である
］~AND［
%演算 は`静的~演算$でない
］：
◎
If target is an interface, and op is not a static operation:
</p>

				<ol>
					<li>
<p >
~IF［
`this^jv 値 ~IN { `null^jv, `undefined^jv }
］
⇒
%O ~SET %realm の`大域~obj$
</p>

<p>
（この大域~objが %target を実装しない場合、数~段~先で `TypeError^jE が生じることになる。）</p>
◎
If the this value is null or undefined, set O to realm’s global object. (This will subsequently cause a TypeError in a few steps, if the global object does not implement target.)
</li>
					<li>
~ELSE
⇒
%O ~SET `this^jv 値
◎
Otherwise, set O to the this value.
</li>
					<li>
~IF［
%O は `~platform~obj$である
］
⇒
( %O, %id, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing O, id, and "method".
</li>
					<li>
~IF［
%O は ~ifc %target を実装する`~platform~obj$でない
］
⇒
~throwTypeError
◎
If O is not a platform object that implements the interface target, throw a TypeError.
</li>
				</ol>
			</li>
			<li>
<p>
%S ~LET %target 上の［
%演算 が［
正則~演算ならば`正則~演算$ ／ 静的~演算ならば`静的~演算$
］］のうち，［
`識別子$ %id, 引数個数 %n
］から得られる`有効~多重定義~集合$
◎
Let S be the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count n.
</li>
			<li>
&lt;%演算, %値~list&gt; ~LET
%S と %arg<sub>0..%n−1</sub> を`多重定義~解決~algo$に渡した結果
◎
Let &lt;operation, values&gt; be the result of passing S and arg0..n−1 to the overload resolution algorithm.
</li>
			<li>
%R ~LET ~NULL
◎
Let R be null.
</li>
			<li>
~IF［
%演算 は `Default$x 拡張属性を伴って宣言されている
］
⇒
%R ~SET %値~list を一連の引数~値として，
%演算 に`対応する既定の演算$に挙げられている動作を %O 上で遂行した結果
◎
If operation is declared with a [Default] extended attribute, then:
• Set R be the result of performing the actions listed in operation’s corresponding default operation on O, with values as the argument values.
</li>
			<li>
<p>
~ELSE ：
◎
Otherwise:
</p>
				<ol>
					<li>
%R ~SET
( %演算, %値~list ) を引数に，演算の記述に挙げられている手続きを
— %O ~NEQ `null^jv ならば %O 上で —
遂行した結果
◎
Set R be the result of performing the actions listed in the description of operation, on O if O is not null, with values as the argument values.
</li>
					<li>
~RET %R を［
%演算 の返値に宣言された型
］の`~ES値に変換-$した結果
◎
Return the result of converting R to an ECMAScript value of the type op is declared to return.
</li>
				</ol>
			</li>
		</ol>

<!--cp-if-E-thrown-->

		<ol>
			<li>
~IF［
%演算 の`返値型$は `~promise型$である
］
⇒
~RET 
! `Call$A( `Promise_reject$jI, `Promise$jI, «%E» )
◎
If op has a return type that is a promise type, then return ! Call(%Promise_reject%, %Promise%, «E»)
</li>
			<!--cp-throw-E-->
		</ol>
	</li>
	<!--cp-F-CreateBuiltinFunction-->
	<!--cp-SetFunctionName-F-id-->
	<li>
%S ~LET %target 上の［
%演算 が正則~演算である場合は`正則~演算$ ／
静的~演算である場合は`静的~演算$
］のうち［
`識別子$ %id, 引数個数 0
］から得られる`有効~多重定義~集合$
◎
Let S be the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count 0.
</li>
	<li>
%length ~LET %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list in the entries in S.
</li>
	<!--cp-DefinePropertyOrThrow-F-length-->
	<li>
~RET %F
◎
Return F.
</li>
</ol>


				<section id="es-default-operations">
<h5 title="Default operations">3.6.8.1. 既定の演算</h5>

<p>
`Default$x `拡張属性$を宣言してよい`正則~演算$は、下に定義される
`対応する既定の演算@
持つものに限られる。
【現時点では、~toJSONしかない。】
◎
Only regular operations which have a corresponding default operation defined below may be declared with a [Default] extended attribute.
</p>

					<section id="es-default-tojson">
<h6 title="Default toJSON operation">3.6.8.1.1. 既定の~toJSON演算</h6>

<p>
~toJSON演算に`対応する既定の演算$は、`既定の~toJSON演算$で与えられる。
◎
The corresponding default operation of the toJSON operation is the default toJSON operation.
</p>

<p>
`既定の~toJSON演算$の`返値型$は、
`object$T で~MUST。
◎
The return type of the default toJSON operation must be object.
</p>

<p class="algo-head">
`~ifc$ %I の
`既定の~toJSON演算@
を %O 上で呼出すときは、次の手続きを走らす：
◎
To invoke the default toJSON operation of interface I on O, run the the following steps:
</p>

<ol>
	<li>
%~map ~LET 新たな`有順序~map$
◎
Let map be a new ordered map.
</li>
	<li>
%~stack ~LET `継承~stackを作成する$( %I )
◎
Let stack be the result of creating an inheritance stack for interface I.
</li>
	<li>
%O 上の`継承~stackの属性~値を収集する$( %~stack, %~map )
◎
Invoke collect attribute values of an inheritance stack on O, passing it stack and map as arguments.
</li>
	<li>
%結果 ~LET
! `ObjectCreate$A( `ObjectPrototype$jI )
◎
Let result be ! ObjectCreate(%ObjectPrototype%).
</li>
	<li>
<p>
%~map 内の~EACH( %key → %value ) に対し：
◎
For each key → value of map,
</p>
		<ol>
			<li>
%k ~LET %key を`~ES値に変換-$した結果
◎
Let k be key converted to an ECMAScript value.
</li>
			<li>
%v ~LET %value を`~ES値に変換-$した結果
◎
Let v be value converted to an ECMAScript value.
</li>
			<li>
! `CreateDataProperty$A( %結果, %k, %v )
を遂行する
◎
Perform ! CreateDataProperty(result, k, v).
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


<p>
%O 上の
`継承~stackの属性~値を収集する@
抽象~演算は、所与の
( `~stack$ %~stack, `有順序~map$ %~map )
に対し，次を走らす：
◎
To invoke the collect attribute values of an inheritance stack abstract operation on O with stack stack and ordered map map as arguments, run the the following steps:
</p>

<ol class="algorithm">
	<li>
%I ~LET %~stack から`~pop$した結果
◎
Let I be the result of popping from stack.
</li>
	<li>
%O 上の`属性~値を収集する$( %I, %~map )
◎
Invoke collect attribute values on O, passing it I and map as arguments.
</li>
	<li>
~IF［
%~stack は`空$でない
］
⇒
%O 上の`継承~stackの属性~値を収集する$( %~stack, %~map )
◎
If stack is not empty, then invoke collect attribute values of an inheritance stack on O, passing it stack and map as arguments.
</li>
</ol>

<p>
%O 上の
`属性~値を収集する@
抽象~演算は、所与の
( `~ifc$ %I, `有順序~map$ %~map )
に対し，次を走らす：
◎
To invoke the collect attribute values abstract operation on O with interface I and ordered map map as arguments, run the the following steps:
</p>

<ol class="algorithm">
	<li>
<p>
~IF［
%I 上に［
`Default$x `拡張属性$を伴う~toJSON演算
］は宣言されている
］
⇒
%I 上に`公開され$ている`~ifc~mb$のうち，`正則~属性$である ~EACH( %属性 ) に対し：
◎
If a toJSON operation with a [Default] extended attribute is declared on I, then for each exposed regular attribute attr that is an interface member of I, in order:
</p>
		<ol>
			<li>
%id ~LET %属性 の`識別子$
◎
Let id be the identifier of attr.
</li>
			<li>
%値 ~LET %O 上で %属性 の`下層の値を取得-$した結果
◎
Let value be the result of getting the underlying value of attr given O.
</li>
			<li>
~IF［
%値 は`~JSON型$である
］
⇒
%~map[ %id ] ~SET %値
◎
If value is a JSON type, then set map[id] to value.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
`継承~stackを作成する@
ときは、所与の
( `~ifc$ %I )
に対し，次を走らす：
◎
To create an inheritance stack for interface I, run the the following steps:
</p>

<ol>
	<li>
%~stack ~LET 新たな`~stack$
◎
Let stack be a new stack.
</li>
	<li>
%~stack に %I を`~push$する
◎
Push I onto stack.
</li>
	<li>
%I の`被継承~ifc$である~EACH( `~ifc$ %J ) に対し，最も末端のものから順に
⇒
%J を %~stack に`~push$する
◎
While I inherits from an interface,
• Let I be that interface.
• Push I onto stack.
</li>
	<li>
~RET %~stack
◎
Return stack.
</li>
</ol>

<div class="example">

<p>
下に与える`~IDL片$は、`~ifc$ `A^T の`被継承~ifc$, および［
`A^T, または `A^T の`被継承~ifc$
］に`内包-$されている`~ifc~mixin$たちを成す，いくつかの`~ifc$を定義する
— 次の継承~木に示されるような：
◎
The following IDL fragment defines a number of interfaces, which are inherited interfaces of A, and interface mixins, which are included by A or by A’s inherited interfaces, as show in the below inheritance tree.
</p>

<pre>
     C* - M4
     |
     B - M3
     |
M1 - A - M2*
</pre>

<p>
`*^c が付与されている［
`~ifc$／`~ifc~mixin$
］は、
`Default$x `拡張属性$を伴う~toJSON`演算$を宣言する。
◎
Interfaces and interface mixins marked with an asterisk ("*") declare a toJSON operation with a [Default] extended attribute.
</p>

<pre class="webidl">
interface A : B {
  attribute DOMString a;
};

interface B : C {
  attribute DOMString b;
};

interface C {
  [Default] object toJSON();
  attribute DOMString c;
};

interface mixin M1 {
  attribute DOMString m1;
};

interface mixin M2 {
  [Default] object toJSON();
  attribute DOMString m2;
};

interface mixin M3 {
  attribute DOMString m3;
};

interface mixin M4 {
  attribute DOMString m4;
};

A includes M1;
A includes M2;
B includes M3;
C includes M4;
</pre>

<p>
上に定義した~ifc `A^T を実装している~obj上で `toJSON()^c を~methを~callした場合、次のような~JSON~objを返すことになる：
◎
Calling the toJSON() method of an object implementing interface A defined above would return the following JSON object:
</p>


<pre class="es-code">
{
    "a": "...",
    "m1": "...",
    "m2": "...",
    "c": "...",
    "m4": "..."
}
</pre>

<p>
~ifc `B^T を実装している~objでは、次のような~JSON~objを返すことになる：
◎
An object implementing interface B would return:
</p>


<pre class="es-code">
{
    "c": "...",
    "m4": "..."
}
</pre>

</div>

					</section>
				</section>
				<section id="es-stringifier">
<h5 title="Stringifiers">3.6.8.2. 文字列化子</h5>

<p>
`~ifc$が`公開され$ている`文字列化子$（以下 %文字列化子 と記す）を持つ場合、次の特徴を有する~propが存在し~MUST：
◎
If the interface has an exposed stringifier, then there must exist a property with the following characteristics:
</p>

<ul>
	<li>
名前は `toString^l
◎
The name of the property is “toString”.
</li>
	<li><!-- copy* -->
~propの所在は：
%文字列化子 が~ifc上で`偽装不可$であるか, または
~ifcが `*Global$x 拡張属性を伴って宣言されているならば、~ifcを実装するどの~obj上にも存在する。
他の場合、~ifcの`~ifc原型~obj$上に存在する。
◎
If the stringifier is unforgeable on the interface or if the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on every object that implements the interface. Otherwise, the property exists on the interface prototype object.
</li>
	<li>
属性 `BTB^desc を持つ。
ここで %B は［
%文字列化子 が~ifc上で`偽装不可$である場合は `false^jv ／
~ELSE_ `true^jv
］である。
◎
The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the stringifier is unforgeable on the interface, and true otherwise.
</li>
	<li>
値は 下に与える`組込みの関数~obj$ %F 。
◎
The value of the property is a built-in function object,＼
</li>
</ul>

<p>
~prop値 %F は、被呼出時には次に従って挙動し~MUST：
◎
which behaves as follows:
</p>

<ol class="algorithm">
	<li>
%O ~LET `this^jv 値~上で `ToObject$A を~callした結果
◎
Let O be the result of calling ToObject on the this value.
</li>
	<li><!-- copy* -->
~IF［
%O は `~platform~obj$である
］
⇒
( %O, %文字列化子 の`識別子$, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the stringifier, and
• the type “method”.
</li>
	<li>
~IF［
%O は［
%文字列化子 を宣言する~ifcを実装する~obj
］でない
］
⇒
~throwTypeError
◎
If O is not an object that implements the interface on which the stringifier was declared, then throw a TypeError.
</li>
	<li>
%V ~LET 未初期化の変数
◎
Let V be an uninitialized variable.
</li>
	<li>
<p>
`stringifier^c が指定されている場所に応じて：
◎
Depending on where stringifier was specified:
</p>
		<dl class="switch">
			<dt>
`属性$上
◎
on an attribute
</dt>
			<dd><!-- copy* -->
%V ~SET %O を~objとして、［
その属性, あるいは［
その属性がその`取得子を継承-$するように宣言されている場合は，継承-先の属性
］］の記述に挙げられている，取得-時に生じる手続きを遂行した結果
◎
Set V to the result of performing the actions listed in the description of the attribute that occur when getting (or those listed in the description of the inherited attribute, if this attribute is declared to inherit its getter), with O as the object.
</dd>

			<dt>
識別子を伴う`演算$上
◎
on an operation with an identifier
</dt>
			<dd>
%V ~SET %O を `this^jv 値として, 引数は渡さずに、その演算の記述に挙げられている手続きを遂行した結果
◎
Set V to the result of performing the actions listed in the description of the operation, using O as the this value and passing no arguments.
</dd>
			<dt>
識別子を伴わない`演算$上
◎
on an operation with no identifier
</dt>
			<dd>
%V ~SET ~ifcの`文字列化の挙動$を遂行した結果
◎
Set V to the result of performing the stringification behavior of the interface.
</dd>
		</dl>
	</li>
	<li>
~RET
%V を `String^jt 型の`~ES値に変換-$した結果
◎
Return the result of converting V to a String value.
</li>
</ol>

<p id="cp-length-is-0">
この`関数~obj$の `length^l ~propの値は、 `Number^jt 値 `0^jv である。
◎
The value of the function object’s “length” property is the Number value 0.
</p>

<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `toString^l である。
◎
The value of the function object’s “name” property is the String value “toString”.
</p>

				</section>
			</section>
			<section id="es-iterators">
<h4 title="Common iterator behavior">3.6.9. 反復子に共通する挙動</h4>

				<section id="es-iterator">
<h5 title="@@iterator">3.6.9.1. ~iterator0</h5>

<p >
所与の`~ifc$が，次のいずれかを持つならば…：
◎
If the interface has any of the following:
</p>

<ul>
	<li>
`可反復~宣言$
◎
an iterable declaration
</li>
	<li>
`有index~prop取得子$, および［
名前 `length^c の，`整数~型$の`属性$
］
◎
an indexed property getter and an integer-typed attribute named “length”
</li>
	<li class="L2">
`~maplike 宣言$
◎
a maplike declaration
</li>
	<li class="L2">
`~setlike 宣言$
◎
a setlike declaration
</li>
</ul>

<div class="p">
<p>
…ならば、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は ~iterator0 ~symbol
</li>
	<li id="cp-value-is-a-func-F">
値は 下に与える`関数~obj$ %F
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
then a property must exist whose name is the @@iterator symbol, with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is a function object.
</div>

<p id="cp-proploc0">
~propは ~ifcに対する`通例の所在$にある。
◎
The location of the property is determined as follows:
• If the interface was declared with the [Global] or [PrimaryGlobal] extended attribute, then the property exists on the single object that implements the interface.
• Otherwise, the property exists solely on the interface’s interface prototype object.
</p>

<p id="cp-F-is-given-as-follows">
~prop値 %F は、次で与えられる：
◎
↓</p>

<dl class="switch">
	<dt>
~ifcに `有index~prop取得子$が定義されている場合：
◎
If the interface defines an indexed property getter, then＼
</dt>
	<dd>
`ArrayProto_values$jI 。
◎
the function object is %ArrayProto_values%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
<p id="cp-built-in-F-must-behave-as">
%F は`組込みの関数~obj$であり、被呼出時には次に従って挙動し~MUST：
◎
the function object is a built-in function object that, when invoked, must behave as follows:
</p>

		<ol class="algorithm">
			<li id="cp-let-ToObject-this">
%object ~LET `this^jv 値~上の `ToObject$A を~callした結果
◎
Let object be the result of calling ToObject on the this value.
</li>
			<li id="cp-iterator-security-check">
~IF［
%object は `~platform~obj$である
］
⇒
( %object, `~iterator0^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “@@iterator”, and
• the type “method”.
</li>
			<li>
%interface ~LET `可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface the iterable declaration is on.
</li>
			<li id="cp-throw-if-not-impl">
~IF［
%object は［
%interface を実装する`~platform~obj$
］でない
］
⇒
~throwTypeError
◎
If object is not a platform object that implements interface, then throw a TypeError.
</li>
			<li>
~RET ［
%interface,
~target %object,
反復子の種類 `key+value^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “key+value”.
◎
Return iterator.
</li>
		</ol>
	</dd>

	<dt class="L2">
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration, then＼
</dt>
	<dd class="L2">
<!--cp-built-in-F-must-behave-as-->

		<ol class="algorithm">
			<!--cp-let-ToObject-this-->
			<!--cp-iterator-security-check-->
			<li>
~IF［
%object は［
`~maplike 宣言$ ／ `~setlike 宣言$
を定義する`~ifc$を実装する`~platform~obj$
］でない
］
⇒
~throwTypeError
◎
If object is not a platform object that implements the interface on which the maplike declaration or setlike declaration is defined, then throw a TypeError.
</li>
			<li>
<p>
~IF［
~ifcは`~maplike 宣言$を持つ
］：
◎
If the interface has a maplike declaration, then:
</p>
				<ol>
					<li>
%backing ~LET %object の `BackingMap^sl `内部~slot$の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object.
</li>
					<li>
~RET `CreateMapIterator$A(%backing, `key+value^l)
◎
Return CreateMapIterator(backing, "key+value").
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE ：
◎
Otherwise:
</p>
				<ol>
					<li>
%backing ~LET %object の `BackingSet^sl `内部~slot$の値
◎
Let backing be the value of the [[BackingSet]] internal slot of object.
</li>
					<li>
~RET `CreateSetIterator$A(%backing, `value^l)
◎
Return CreateSetIterator(backing, "value").
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>

<p>
%F の `length^l ~propの値は、 `Number^jt 値 `0^jv である。
◎
The value of the @@iterator function object’s “length” property is the Number value 0.
</p>

<p>
%F の `name^l ~propの値は、当の~ifcが［［
`~pair反復子$ ／ `~maplike 宣言$
］を持つならば `String^jt 値 `entries^l ／
`~setlike 宣言$を持つならば `String^jt 値 `values^l
］である。
◎
The value of the @@iterator function object’s “name” property is the String value “entries” if the interface has a pair iterator or a maplike declaration and the String “values” if the interface has a setlike declaration.
</p>


				</section>
				<section id="es-forEach">
<h5 title="forEach">3.6.9.2. forEach</h5>

<p>
`~ifc$が次のいずれかを持つならば：
◎
If the interface has any of the following:
</p>

<ul>
	<li>
`可反復~宣言$
◎
an iterable declaration
</li>
	<li class="L2">
`~maplike 宣言$
◎
a maplike declaration
</li>
	<li class="L2">
`~setlike 宣言$
◎
a setlike declaration
</li>
</ul>


<div class="p">
<p>
…ならば、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `forEach^l
</li>
	<!--cp-value-is-a-func-F-->
	<li id="cp-has-attr-TTT">
属性 `TTT^desc を持つ
</li>
</ul>

◎
then a property named “forEach” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcに `有index~prop取得子$が定義されている場合：
◎
If the interface defines an indexed property getter, then＼
</dt>
	<dd>
`ArrayProto_forEach$jI
◎
the function object is %ArrayProto_forEach%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
<p>
［［
その~ifcが，その`~pair反復子$を代わりに 次に示す［
`演算$, および注釈文による定義
］を持つ
］と見なしたときに，存在することになるもの
］と同じに挙動する：
◎
the method must have the same behavior, when invoked with argument callback and optional argument thisArg, as one that would exist assuming the interface had this operation instead of the iterable declaration:
</p>

<pre class="webidl">
interface Iterable {
  void forEach(Function %callback, optional any %thisArg);
};
</pre>

<p>
注釈文による定義は、
( 引数 %callback, 随意~引数 %thisArg )
で呼出されたとき：
◎
with the following prose definition:
</p>

		<ol class="algorithm">
			<li>
%O ~LET `this^jv 値
◎
Let O be the this value.
</li>
			<li>
%pairs ~LET `反復される値~pair$の~list
◎
Let pairs be the list of value pairs to iterate over.
</li>
			<li>
<p>
%pairs 内の~EACH ( %pairs ) に対し，順に：
◎
Let i be 0.
◎
While i is less than the length of pairs:
</p>
				<ol>
					<li>
%pair ~LET %pairs 内で~index %i に位置する~entry
◎
Let pair be the entry in pairs at index i.
</li>
					<li>
%key ~LET %pair の~key
◎
Let key be pair’s key.
</li>
					<li>
%value ~LET %pair の値
◎
Let value be pair’s value.
</li>
					<li>
`呼戻 this 値$に %thisArg （引数が渡されなかった場合は `undefined^jv ）を,
引数に ( %value, %key, %O ) を渡して，
%callback を<a href="#invoke-a-callback-function">呼出す</a>
◎
Invoke callback with thisArg (or undefined, if the argument was not supplied) as the callback this value and value, key and O as its arguments.
</li>
					<li>
現在の`反復される値~pair$の~listに %pairs で更新する
◎
Update pairs to the current list of value pairs to iterate over.
◎
Set i to i + 1.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt class="L2">
~ifcは `~maplike 宣言$／`~setlike 宣言$を持つ場合：
◎
If the interface has a maplike declaration or setlike declaration then＼
</dt>
	<dd class="L2">
<p id="cp-must-behave-as-follows">
~methの被呼出時には、次に従って挙動し~MUST：
◎
the method, when invoked, must behave as follows:
</p>

		<ol class="algorithm">
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~obj$である
］
⇒
( %object, `forEach^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “forEach”, and
• the type “method”.
</li>
			<li>
%interface ~LET `~maplike 宣言$／`~setlike 宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the maplike declaration or setlike declaration is declared.
</li>
			<!--cp-throw-if-not-impl-->
			<li>
%callbackFn ~LET ［
この関数に引数が渡されているならば その 1 個目の引数の値 ／
~ELSE_ `undefined^jv
］
◎
Let callbackFn be the value of the first argument passed to the function, or undefined if the argument was not supplied.
</li>
			<li>
~IF［
`IsCallable$A( %callbackFn ) ~EQ ~F
］
⇒
~throwTypeError
◎
If IsCallable(callbackFn) is false, throw a TypeError.
</li>
			<li>
%thisArg ~LET ［
関数に 2 個目の引数が渡されているならば その引数の値 ／
~ELSE_ `undefined^jv
］
◎
Let thisArg be the value of the second argument passed to the function, or undefined if the argument was not supplied.
</li>
			<li>
%backing ~LET %interface が［
`~maplike 宣言$ ／ `~setlike 宣言$
］のいずれを持つかに応じて， %object の［
`BackingMap^sl ／ `BackingSet^sl
］`内部~slot$の値
◎
Let backing be the value of the [[BackingMap]] internal slot of object, if the interface has a maplike declaration, or the [[BackingSet]] internal slot of object otherwise.
</li>
			<li>
<p>
%callbackWrapper ~LET 被呼出時に次に従って挙動する`組込みの関数~obj$：
◎
Let callbackWrapper be a built-in function object that, when invoked, behaves as follows:
</p>

				<ol>
					<li>
( %v, %k ) ~LET 関数に渡された ( 1 個目の引数, 2 個目の引数 )
◎
Let v and k be the first two arguments passed to the function.
</li>
					<li>
%thisArg ~LET `this^jv 値
◎
Let thisArg be the this value.
</li>
					<li>
`Call$A( %callbackFn, %thisArg, « %v, %k, %object » )
◎
Call(callbackFn, thisArg, «v, k, object»).
</li>
				</ol>

<p class="note">注記：
%callbackWrapper 関数は、単純に， 3 個目の引数に %object を渡して ~~入力の %callbackFn を~callする
— その内部［
`BackingMap^sl ／ `BackingSet^sl
］~objではなく。
◎
Note: The callbackWrapper function simply calls the incoming callbackFn with object as the third argument rather than its internal [[BackingMap]] or [[BackingSet]] object.
</p>

<p class="issue">
~script作者は、［
forEach が~callされる度に， %callbackWrapper が新たな関数になる
］かどうか，観測し得るだろうか？
［
環境を capture <!-- ＊ -->した唯一の関数が在ること
］を指定する仕方として，何が最良になるだろうか？
◎
Can the script author observe that callbackWrapper might be a new function every time forEach is called? What’s the best way of specifying that there’s only one function that has captured an environment?
</p>

			</li>
			<li>
%forEach ~LET `Get$A( %backing, `forEach^l )
◎
Let forEach be the result of calling the [[Get]] internal method of backing with “forEach” and backing as arguments.
</li>
			<li>
~IF［
`IsCallable$A( %forEach ) ~EQ ~F
］
⇒
~throwTypeError
◎
If IsCallable(forEach) is false, throw a TypeError.
</li>
			<li>
`Call$A( %forEach, %backing, « %callbackWrapper, %thisArg » )
◎
Call(forEach, backing, «callbackWrapper, thisArg»).
</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</dd>
</dl>

<p id="cp-length-is-1">
この`関数~obj$の `length^l ~propの値は、 `Number^jt 値 `1^jv である。
◎
The value of the function object’s “length” property is the Number value 1.
</p>

<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `forEach^l である。
◎
The value of the function object’s “name” property is the String value “forEach”.
</p>

				</section>
			</section>
			<section id="es-iterable">
<h4 title="Iterable declarations">3.6.10. 可反復~宣言</h4>

				<section id="es-iterable-entries">
<h5 title="entries">3.6.10.1. entries</h5>

<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `entries^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “entries” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは`値~反復子$を持つ場合：
◎
If the interface has a value iterator, then＼
</dt>
	<dd>
`ArrayProto_entries$jI 。
◎
the function object is %ArrayProto_entries%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
`iterator$jS ~propの値で与えられる`関数~obj$。
◎
the function object is the value of the @@iterator property.
</dd>
</dl>

				</section>
				<section id="es-iterable-keys">
<h5 title="keys">3.6.10.2. keys</h5>


<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `keys^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “keys” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは`値~反復子$を持つ場合：
◎
If the interface has a value iterator,＼
</dt>
	<dd>
`ArrayProto_keys$jI 。
◎
then the function object is %ArrayProto_keys%.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
<!--cp-must-behave-as-follows-->
		<ol class="algorithm">
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~obj$である
］
⇒
( %object, `keys^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “keys”, and
• the type “method”.
</li>
			<li id="cp-let-ifc-iterable-declared">
%interface ~LET `可反復~宣言$が宣言されている`~ifc$
◎
Let interface be the interface on which the iterable declaration is declared on.
</li>
			<!--cp-throw-if-not-impl-->
			<li>
~RET ［
%interface,
~target %object,
反復子の種類 `key^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “key”.
◎
Return iterator.
</li>
		</ol>
	</dd>
</dl>


<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `keys^l である。
◎
The value of the function object’s “name” property is the String value “keys”.
</p>

				</section>
				<section id="es-iterable-values">
<h5 title="values">3.6.10.3. values</h5>

<div class="p">
<p>
`可反復~宣言$を持つ`~ifc$には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `values^l
</li>
	<!--cp-value-is-a-func-F-->
	<!--cp-has-attr-TTT-->
</ul>

◎
If the interface has an iterable declaration, then a property named “values” must exist with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a function object.
</div>

<!--cp-proploc0-->

<!--cp-F-is-given-as-follows-->

<dl class="switch">
	<dt>
~ifcは`値~反復子$を持つ場合：
◎
If the interface has a value iterator,＼
</dt>
	<dd>
`iterator$jS ~propの値で与えられる`関数~obj$。
◎
then the function object is the value of the @@iterator property.
</dd>

	<dt>
~ifcは `~pair反復子$を持つ場合：
◎
If the interface has a pair iterator, then＼
</dt>
	<dd>
<!--cp-must-behave-as-follows-->

		<ol class="algorithm">
			<!--cp-let-ToObject-this-->
			<li>
~IF［
%object は `~platform~obj$である
］
⇒
( %object, `entries^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “entries”, and
• the type “method”.
</li>
			<!--cp-let-ifc-iterable-declared-->
			<!--cp-throw-if-not-impl-->
			<li>
~RET ［
%interface,
~target %object,
反復子の種類 `value^C
］に対し，新たに作成した`既定の反復子~obj$
◎
Let iterator be a newly created default iterator object for interface with object as its target and iterator kind “value”.
◎
Return iterator.
</li>
		</ol>
	</dd>
</dl>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `values^l である。
◎
The value of the function object’s “name” property is the String value “values”.
</p>


				</section>
				<section id="es-default-iterator-object">
<h5 title="Default iterator objects">3.6.10.4. 既定の反復子~obj</h5>


<p>
所与の［
`~ifc$, ~target, 反復の種類
］に対する
`既定の反復子~obj@
とは、~objであって，その
`Prototype^sl 内部~propが，その~ifcの`反復子~原型~obj$であるものである。
◎
A default iterator object for a given interface, target and iteration kind is an object whose internal [[Prototype]] property is the iterator prototype object for the interface.
</p>

<p>
`既定の反復子~obj$は、次の 3 つの値を内部に持つ：
◎
A default iterator object has three internal values:
</p>

<dl>
	<dt>~target</dt>
	<dd>
反復される値を~~供給する~obj
◎
its target, which is an object whose values are to be iterated,
</dd>

	<dt>種類</dt>
	<dd>
反復の種類
【 `key^C, `value^C, `key+value^C のいずれか】
◎
its kind, which is the iteration kind,
</dd>

	<dt>~index</dt>
	<dd>
一連の値のうち，反復されることになる値を指す、現在の~index。
◎
its index, which is the current index into the values value to be iterated.
</dd>

</dl>


<p class="note">注記：
既定の反復子~objは、`~pair反復子$のみに利用される
—
`値~反復子$は、現在は，~objの`被support~prop~index$上を反復するように制約されており、標準の~ES `Array^t 反復子~objを利用する。
<!-- #dfn-supported-indexed-properties＊誤記？ -->
◎
Note: Default iterator objects are only used for pair iterators; value iterators, as they are currently restricted to iterating over an object’s supported indexed properties, use standard ECMAScript Array iterator objects.
</p>

<p>
`既定の反復子~obj$が最初に作成されたときの~indexは、 0 にされる。
◎
When a default iterator object is first created, its index is set to 0.
</p>

<p>
所与の`~ifc$に対する`既定の反復子~obj$の `~class文字列$は、［
その~ifcの`識別子$,
文字列 `Iterator^l
］の連結である。
◎
The class string of a default iterator object for a given interface is the result of concatenating the identifier of the interface and the string “Iterator”.
</p>

				</section>
				<section id="es-iterator-prototype-object">
<h5 title="Iterator prototype object">3.6.10.5. 反復子~原型~obj</h5>

<p>
`~pair反復子$を持つどの`~ifc$に対しても、
`反復子~原型~obj@
と呼ばれる~objが存在する。
それは、その~ifcに対する`既定の反復子~obj$の原型として~~働く。
◎
The iterator prototype object for a given interface is an object that exists for every interface that has a pair iterator. It serves as the prototype for default iterator objects for the interface.
</p>

<p>
`反復子~原型~obj$の `Prototype^sl 内部~propは、
`IteratorPrototype$jI で~MUST。
◎
The internal [[Prototype]] property of an iterator prototype object must be %IteratorPrototype%.
</p>

<div class="p">
<p>
`反復子~原型~obj$は、次の特徴を有する~propを持た~MUST：
</p>

<ul>
	<li>
名前は `next^l
</li>
	<li>
値は 下に与えるように挙動する`組込みの関数~obj$
</li>
	<!--cp-has-attr-TTT-->
</ul>

◎
An iterator prototype object must have a property named “next” with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a built-in function object that behaves as follows:
</div>

<ol class="algorithm">
	<li>
%interface ~LET その`反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the iterator prototype object exists.
</li>
	<!--cp-let-ToObject-this-->
	<li>
~IF［
%object は `~platform~obj$である
］
⇒
( %object, `next^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier “next”, and
• the type “method”.
</li>
	<li>
~IF［
%object は %interface に対する`既定の反復子~obj$でない
］
⇒
~throwTypeError
◎
If object is not a default iterator object for interface, then throw a TypeError.
</li>
	<li>
%index ~LET %object の~index
◎
Let index be object’s index.
</li>
	<li>
%kind ~LET %object の種類
◎
Let kind be object’s kind.
</li>
	<li>
%値~list ~LET `反復される値~pair$の~list
◎
Let values be the list of value pairs to iterate over.
</li>
	<li>
%len ~LET %値~list の長さ
◎
Let len be the length of values.
</li>
	<li>
~IF［
%index ~GTE %len
］
⇒
~RET
`CreateIterResultObject$A(`undefined^jv, `true^jv)
◎
If index is greater than or equal to len, then return CreateIterResultObject(undefined, true).
</li>
	<li>
%pair ~LET %値~list 内の %index に位置する~entry
◎
Let pair be the entry in values at index index.
</li>
	<li>
%object の~index ~SET %index + 1
◎
Set object’s index to index + 1.
</li>
	<li>
<p>
%result ~LET
%kind の値に応じて，次で決定される値：
◎
Let result be a value determined by the value of kind:
</p>

		<dl class="switch">
			<dt>`key^C</dt>
			<dd>
<ol class="algorithm">
	<li id="cp-let-idlkey-of-pair">
%idlKey ~LET %pair の~key
◎
Let idlKey be pair’s key.
</li>
	<li id="cp-idlKey-toES">
%key ~LET %idlKey を`~ES値に変換-$した結果
◎
Let key be the result of converting idlKey to an ECMAScript value.
</li>
	<li>
%result ~SET %key
◎
result is key.
</li>
</ol>
			</dd>

			<dt>`value^C</dt>
			<dd>
<ol class="algorithm">
	<li id="cp-let-idlValue-of-pair">
%idlValue ~LET %pair の~key
◎
Let idlValue be pair’s value.
</li>
	<li id="cp-idlValue-toES">
%value ~LET %idlValue を`~ES値に変換-$した結果
◎
Let value be the result of converting idlValue to an ECMAScript value.
</li>
	<li>
%result ~SET %value
◎
result is value.
</li>
</ol>
			</dd>

			<dt>`key+value^C</dt>
			<dd>
<ol class="algorithm">
	<!--cp-let-idlkey-of-pair-->
	<!--cp-let-idlValue-of-pair-->
	<!--cp-idlKey-toES-->
	<!--cp-idlValue-toES-->
	<li>
%array ~LET `ArrayCreate$A( 2 ) を遂行した結果
◎
Let array be the result of performing ArrayCreate(2).
</li>
	<li>
`CreateDataProperty$A( %array, `0^l, %key ) を~callする
◎
Call CreateDataProperty(array, "0", key).
</li>
	<li>
`CreateDataProperty$A( %array, `1^l, %value ) を~callする
◎
Call CreateDataProperty(array, "1", value).
</li>
	<li>
%result ~SET %array
◎
result is array.
</li>
</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET
`CreateIterResultObject$A( %result, `false^jv )
◎
Return CreateIterResultObject(result, false).
</li>
</ol>

<p>
所与の`~ifc$に対する`反復子~原型~obj$の `~class文字列$は［
その~ifcの`識別子$,
文字列 `Iterator^l
］の連結である。
◎
The class string of an iterator prototype object for a given interface is the result of concatenating the identifier of the interface and the string “Iterator”.
</p>

				</section>
			</section>
			<section id="es-maplike" class="L2">
<h4 title="Maplike declarations">3.6.11. ~maplike 宣言</h4>

<p>
`~maplike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を実装する どの~objも，
`BackingMap^sl `内部~slot$を持た~MUST。
— それは、初期~時には，新たに作成された `Map$t ~objに設定される。
この `Map$t ~objの `MapData^sl 内部~slotが，~objの一連の`~map~entry$になる。
◎
Any object that implements an interface that has a maplike declaration must have a [[BackingMap]] internal slot, which is initially set to a newly created Map object. This Map object’s [[MapData]] internal slot is the object’s map entries.
</p>

<p>
%A の`~ifc原型~obj$上には、いくつかの追加の~propが存在する。
これらの追加の~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a maplike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<p>
それらの~propのうち一部のものは、以下において［
所与の関数~名に対し，
`内部~map~objへ転送する@
ような`組込みの関数~obj$ 値を持つ
］ように定義される。
その種の関数は、被呼出時に次に従って挙動する：
◎
Some of the properties below are defined to have a function object value that forwards to the internal map object for a given function name. Such functions behave as follows when invoked:
</p>

<ol class="algorithm">
	<li id="cp-let-O-this-value">
%O ~LET `this^jv 値
◎
Let O be the this value.
</li>
	<li id="cp-let-arguments-passed">
%arguments ~LET 関数に渡された引数の~list
◎
Let arguments be the list of arguments passed to this function.
</li>
	<li id="cp-let-name-function-name">
%name ~LET 関数~名
◎
Let name be the function name.
</li>
	<li id="cp-security-check-name">
~IF［
%O は `~platform~obj$である
］
⇒
( %O, %name, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• an identifier equal to name, and
• the type “method”.
</li>
	<li id="cp-throw-if-O-not-obj">
~IF［
%O は %A を実装する~objでない
］
⇒
~throwTypeError
◎
If O is not an object that implements A, then throw a TypeError.
</li>
	<li id="cp-let-map-BackingMap">
%map ~LET
%O の `BackingMap^sl `内部~slot$の値である `Map$t ~obj
◎
Let map be the Map object that is the value of O’s [[BackingMap]] internal slot.
</li>
	<li id="cp-Get-map-name">
%function ~LET `Get$A( %map, %name )
◎
Let function be the result of calling the [[Get]] internal method of map passing name and map as arguments.
</li>
	<li id="cp-throw-if-IsCallable-funciton-false">
~IF［
`IsCallable$A( %function ) ~EQ ~F
］
⇒
~throwTypeError
◎
If IsCallable(function) is false, then throw a TypeError.
</li>
	<li>
~RET
`Call$A( %function, %map, %arguments )
◎
Return Call(function, map, arguments).
</li>
</ol>

				<section id="es-map-size">
<h5 title="size">3.6.11.1. size</h5>
<p>
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
There must exist a property named “size” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `size^l
◎
↑</li>
	<li>
属性
{ [[Get]]: %G, [[Enumerable]]: `false^jv, [[Configurable]]: `true^jv }
を持つ。
ここで %G は、次項にて定義される
`~map~size取得子@
である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s map size getter, defined below.
</li>
	<li>
<p>
`~map~size取得子$は、被呼出時の挙動が次で与えられる，`組込みの関数~obj$：
◎
The map size getter is a built-in function object whose behavior when invoked is as follows:
</p>

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li id="cp-security-check-size">
~IF［
%O は `~platform~obj$である
］
⇒
( %O, `size^l, `取得子^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “size”, and
• the type “getter”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
~RET `Get$A( %map, %map )
◎
Return the result of calling the [[Get]] internal method of map passing “size” and map as arguments.
</li>
		</ol>
<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `size^l である。
◎
The value of the function object’s “name” property is the String value “size”.
</p>

	</li>
</ul>


				</section>
				<section id="es-map-entries">
<h5 title="entries">3.6.11.2. entries</h5>

<div class="p">
<p>
%A の`~ifc原型~obj$上には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `entries^l
</li>
	<li>
値は `iterator$jS ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A property named “entries” must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>


				</section>
				<section id="es-map-keys-values">
<h5 title="keys and values">3.6.11.3. keys, values</h5>

<p>
名前［
`keys^l ／ `values^l
］に対しては、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST。
◎
For both of “keys” and “values”, there must exist a property with that name on A’s interface prototype object with the following characteristics:
</p>


<ul>
	<li id="cp-has-TFT">
属性 `TFT^desc を持つ。
◎
The property has attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }.
</li>
	<li>
値は `内部~map~objへ転送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards that name to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、 `String^jt 値［
`keys^l ／ `values^l
］である。
◎
The value of the function object’s “name” property is the String value “keys” or “values”, correspondingly.
</p>

				</section>
				<section id="es-map-get-has">
<h5 title="get and has">3.6.11.4. get, has</h5>

<p>
名前［
`get^l ／ `has^l
］に対しては、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST。
◎
For both of “get” and “has”, there must exist a property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<p id="cp-value-is-built-in-func">
値は 被呼出時に次に従って挙動する`組込みの関数~obj$：
◎
The value of the property is a built-in function object that behaves as follows when invoked:
</p>

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
%name ~LET ~propの名前（ `get^l または `has^l ）。
◎
Let name be the name of the property – “get” or “has”.
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li id="cp-let-keyType">
%keyType ~LET `~maplike 宣言$にて指定された~key型
◎
Let keyType be the key type specified in the maplike declaration.
</li>
			<!--cp-Get-map-name-->
			<li id="cp-let-keyArg-1st-arg">
%keyArg ~LET ［
この関数に引数が渡されているならば その 1 個目の引数の値 ／
~ELSE_ `undefined^jv
］
◎
Let keyArg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-keyArg-toIDL-keyIDL">
%keyIDL ~LET %keyArg を型 %keyType の`~IDL値に変換-$した結果
◎
Let keyIDL be the result of converting keyArg to an IDL value of type keyType.
</li>
			<li id="cp-keyIDL-toES-key">
%key ~LET %keyIDL を`~ES値に変換-$した結果
◎
Let key be the result of converting keyIDL to an ECMAScript value.
</li>
			<li id="cp-Call-fmk">
~RET
`Call$A( %function, %map, « %key » )
◎
Return Call(function, map, «key»).
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^l ~propの値は、 `String^jt 値［
`get^l ／ `has^l
］である。
◎
The value of the function object’s “name” property is the String value “get” or “has”, correspondingly.
</p>

				</section>
				<section id="es-map-clear">
<h5 title="clear">3.6.11.5. clear</h5>

<p>
［
%A には 識別子 `clear^l の`~mb$は宣言されていない
］~AND［
%A は可書~maplike 宣言を伴って宣言されている
］場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A does not declare a member with identifier “clear”, and A was declared with a read–write maplike declaration, then a property named “clear” and the following characteristics must exist on A’s interface prototype object:
</p>


<ul>
	<li>
名前は `clear^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
値は `内部~map~objへ転送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards “clear” to the internal map object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `clear^l である。
◎
The value of the function object’s “name” property is the String value “clear”.
</p>

				</section>
				<section id="es-map-delete">
<h5 title="delete">3.6.11.6. delete</h5>


<p>
［
%A には 識別子 `delete^l の`~mb$は宣言されていない
］~AND［
%A は 可書~maplike 宣言を伴って宣言されている
］場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A does not declare a member with identifier “delete”, and A was declared with a read–write maplike declaration, then a property named “delete” and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<li>
名前は `delete^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-built-in-func-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF［
%O は `~platform~obj$である
］
⇒
( %O, `delete^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “delete”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<!--cp-let-keyType-->
			<li>
%function ~LET `Get$A( %map, `delete^l )
◎
Let function be the result of calling the [[Get]] internal method of map passing “delete” and map as arguments.
</li>
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-keyArg-toIDL-keyIDL-->
			<!--cp-keyIDL-toES-key-->
			<!--cp-Call-fmk-->
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `delete^l である。
◎
The value of the function object’s “name” property is the String value “delete”.
</p>

				</section>
				<section id="es-map-set">
<h5 title="set">3.6.11.7. set</h5>

<p>
［
%A は 識別子 `set^l の`~ifc~mb$を宣言しない
］~AND［
%A は 可書~maplike 宣言を伴って宣言されている
］場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A does not declare a member with identifier “set”, and A was declared with a read–write maplike declaration, then a property named “set” and the following characteristics must exist on A’s interface prototype object:
</p>


<ul>
	<li>
名前は `set^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-built-in-func-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF［
%O は `~platform~obj$である
］
⇒
( %O, `set^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “set”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-map-BackingMap-->
			<li>
%keyType, %valueType ~LET 順に，`~maplike 宣言$にて指定された~key型, ~value型
◎
Let keyType and valueType be the key and value types specified in the maplike declaration.
</li>
			<li>
%function ~LET `Get$A( %map, `set^l )
◎
Let function be the result of calling the [[Get]] internal method of map passing “set” and map as arguments.
</li>
	<!--cp-let-keyArg-1st-arg-->

			<li>
%valueArg ~LET［
この関数に 2 個目の引数が渡されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let valueArg be the second argument passed to this function, or undefined if not supplied.
</li>
			<!--cp-keyArg-toIDL-keyIDL-->
			<li>
%valueIDL ~LET %valueArg を型 %valueType の`~IDL値に変換-$した結果
◎
Let valueIDL be the result of converting valueArg to an IDL value of type valueType.
</li>
			<!--cp-keyIDL-toES-key-->
			<li>
%value ~LET %valueIDL を`~ES値に変換-$した結果
◎
Let value be the result of converting valueIDL to an ECMAScript value.
</li>
			<li>
%result ~LET
! `Call$A( %function, %map, « %key, value » )
◎
! Call(function, map, «key, value»).
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
</ul>

<p>
この`関数~obj$の `length^l ~propの値は、 `Number^jt 値 `2^jv である。
◎
The value of the function object’s “length” property is the Number value 2.
</p>

<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `set^l である。
◎
The value of the function object’s “name” property is the String value “set”.
</p>

				</section>
			</section>
			<section id="es-setlike" class="L2">
<h4 title="Setlike declarations">3.6.12. ~setlike 宣言</h4>

<p>
`~setlike 宣言$を持つ`~ifc$
— この節を通して， %A と記される —
を実装するどの~objも，
`BackingSet^sl `内部~slot$を持た~MUST
— それは、初期~時には，新たに作成された `Set$t ~objに設定される。
この `Map$t ~objの `SetData^sl 内部~slotが，~objの一連の`~set~entry$になる。
◎
Any object that implements an interface that has a setlike declaration must have a [[BackingSet]] internal slot, which is initially set to a newly created Set object. This Set object’s [[SetData]] internal slot is the object’s set entries.
</p>

<p>
%A の`~ifc原型~obj$上には、いくつかの追加の~propが存在する。
これらの追加の~propは、以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a setlike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

<p>
それらの~propのうち一部のものは、以下にて
所与の関数~名に対し，
`内部~set~objへ転送する@
ような`組込みの関数~obj$ 値を持つように定義される。
その種の関数は、被呼出時に次に従って挙動する：
◎
Some of the properties below are defined to have a built-in function object value that forwards to the internal set object for a given function name. Such functions behave as follows when invoked:
</p>

<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<!--cp-let-arguments-passed-->
	<!--cp-let-name-function-name-->
	<li>
~IF［
%O は `~platform~obj$である
］
⇒
( %O, %name, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• an identifier equal to name, and
• the type “method”.
</li>
	<!--cp-throw-if-O-not-obj-->
	<li id="cp-let-set-BackingSet">
%set ~LET
%O の `BackingSet^sl `内部~slot$の値である `Set$t ~obj
◎
Let set be the Set object that is the value of O’s [[BackingSet]] internal slot.
</li>
	<li id="cp-Get-set-name">
%function ~LET `Get$A( %set, %name )
◎
Let function be the result of calling the [[Get]] internal method of set passing name and set as arguments.
</li>
	<!--cp-throw-if-IsCallable-funciton-false-->
	<li>
~RET
`Call$A( %function, %set, %arguments )
◎
Return Call(function, set, arguments).
</li>
</ol>

				<section id="es-set-size">
<h5 title="size">3.6.12.1. size</h5>


<p>
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
There must exist a property named “size” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `size^l
◎
↑</li>
	<li>
属性
{ [[Get]]: %G, [[Enumerable]]: `false^jv, [[Configurable]]: `true^jv }
を持つ。
ここで %G は、下に定義される
`~set~size取得子@
である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: false, [[Configurable]]: true }, where G is the interface’s set size getter, defined below.
	</li>
</ul>

<p>
`~set~size取得子$は、被呼出時の挙動が次で与えられる，`組込みの関数~obj$である：
◎
The set size getter is a built-in function object whose behavior when invoked is as follows:
</p>

		<ol class="algorithm">
	<!--cp-let-O-this-value-->
	<!--cp-security-check-size-->
	<!--cp-throw-if-O-not-obj-->
	<!--cp-let-set-BackingSet-->
			<li>
~RET `Get$A( %set, `size^l )
◎
Return the result of calling the [[Get]] internal method of set passing “size” and set as arguments.
</li>
		</ol>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `size^l である。
◎
The value of the function object’s “name” property is the String value “size”.
</p>

				</section>
				<section id="es-set-values">
<h5 title="values">3.6.12.2. values</h5>

<div class="p">
<p>
%A の`~ifc原型~obj$上には、次の特徴を有する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は `values^l
</li>
	<li>
値は `iterator$jS ~propの値で与えられる`関数~obj$
</li>
	<!--cp-has-attr-TFT-->
</ul>
◎
A property named “values” must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the @@iterator property.
</div>


				</section>
				<section id="es-set-entries-keys">
<h5 title="entries and keys">3.6.12.3. entries, keys</h5>


<p>
名前［
`entries^l ／ `keys^l,
］に対しては、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST。
◎
For both of “entries” and “keys”, there must exist a property with that name on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
値は `内部~set~objへ転送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards that name to the internal set object.
</li>
</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、 `String^jt 値［
`entries^l ／ `keys^l
］である。
◎
The value of the function object’s “name” property is the String value “entries” or “keys”, correspondingly.
</p>


				</section>
				<section id="es-set-has">
<h5 title="has">3.6.12.4. has</h5>

<p>
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST。
◎
There must exist a property with named “has” on A’s interface prototype object with the following characteristics:
</p>

<ul>
	<li>
名前は `has^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-built-in-func-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
~IF［
%O は `~platform~obj$である
］
⇒
( %O, `has^l, `~meth^C )
に対し，`保安~検査を遂行する$
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier “has”, and
• the type “method”.
</li>
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li>
%type ~LET `~setlike 宣言$にて指定された~value型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<li>
%function ~LET `Get$A( %set, `has^l )
◎
Let function be the result of calling the [[Get]] internal method of set passing “has” and set as arguments.
</li>
			<li id="cp-let-arg-1st-arg">
%arg ~LET ［
この関数に引数が渡されているならば その 1 個目の引数の値 ／
~ELSE_ `undefined^jv
］
◎
Let arg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-arg-toIDL-type">
%idlValue ~LET %arg を型 %type の`~IDL値に変換-$した結果
◎
Let idlValue be the result of converting arg to an IDL value of type type.
</li>
			<!--cp-idlValue-toES-->
			<li>
~RET
`Call$A( %function, %set, « %value » )
◎
Call(function, set, «value»).
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `has^l である。
◎
The value of the function object’s “name” property is the String value “has”.
</p>

				</section>
<!-- es-set-add-delete？ -->
				<section id="es-add-delete">
<h5 title="add and delete">3.6.12.5. add, delete</h5>


<p>
名前［
`add^l ／ `delete^l
］に対しては、次の両~条件がいずれも満たされるならば：
◎
For both of “add” and “delete”, if:
</p>

<ul>
	<li>
%A には その名前に合致する識別子を伴う`~mb$は宣言されていない
◎
A does not declare an member with a matching identifier, and
</li>
	<li>
%A は可書`~maplike 宣言$を伴って宣言されている
◎
A was declared with a read–write setlike declaration,
</li>
</ul>

<p>
…ならば、
%A の`~ifc原型~obj$上には，次の特徴を有する 同じ名前の~propが存在し~MUST：
◎
then a property with that name and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<!--cp-has-TFT-->
	<li>
<!--cp-value-is-built-in-func-->

		<ol class="algorithm">
			<!--cp-let-O-this-value-->
			<li>
%name ~LET ~propの名前（ `add^l または `delete^l ）。
◎
Let name be the name of the property – “add” or “delete”.
</li>
			<!--cp-security-check-name-->
			<!--cp-throw-if-O-not-obj-->
			<!--cp-let-set-BackingSet-->
			<li>
%type ~LET `~setlike 宣言$に指定された値~型
◎
Let type be the value type specified in the setlike declaration.
</li>
			<!--cp-Get-set-name-->
			<!--cp-let-arg-1st-arg-->
			<!--cp-arg-toIDL-type-->
			<!--cp-idlValue-toES-->
			<li>
%result ~LET
! `Call$A( %function, %set, « %value » )
◎
Let result be ! Call(function, set, «value»).
</li>
			<li>
~RET ［
%name ~EQ `delete^l ならば %result ／
~ELSE_ %O
］
◎
If name is "delete", then return result.
◎
Otherwise, return O.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->
<p>
この`関数~obj$の `name^l ~propの値は、 `String^jt 値［
`add^l ／ `delete^l
］である。
◎
The value of the function object’s “name” property is the String value “add” or “delete”, correspondingly.
</p>

				</section>
				<section id="es-set-clear">
<h5 title="clear">3.6.12.6. clear</h5>

<p>
［
%A には 合致する識別子を伴う`~ifc~mb$は宣言されていない
］~AND［
%A は可書~setlike 宣言を伴って宣言されている
］場合、
%A の`~ifc原型~obj$上には，次の特徴を有する~propが存在し~MUST：
◎
If A does not declare a member with a matching identifier, and A was declared with a read–write setlike declaration, then a property named “clear” and the following characteristics must exist on A’s interface prototype object:
</p>

<ul>
	<li>
名前は `clear^l
◎
↑</li>
	<!--cp-has-TFT-->
	<li>
値は `内部~set~objへ転送する$`組込みの関数~obj$。
◎
The value of the property is a built-in function object that forwards “clear” to the internal set object.
</li>
	</ul>

<!--cp-length-is-0-->
<p>
この`関数~obj$の `name^l ~propの値は、
`String^jt 値 `clear^l である。
◎
The value of the function object’s “name” property is the String value “clear”.
</p>

				</section>
			</section>
		</section>
		<section id="es-platform-objects">
<h3 title="Platform objects implementing interfaces">3.7. ~ifcを実装している~platform~obj</h3>

<p>
どの`~platform~obj$も、`初期~obj$とちょうど同じ様に，大域環境に属する。
各~platform~objがどの大域環境に（または、代理を通して，どの大域~objに）属するか，についての言明-は~Web~IDLを利用する仕様が責を負う。
◎
Every platform object is associated with a global environment, just as the initial objects are. It is the responsibility of specifications using Web IDL to state which global environment (or, by proxy, which global object) each platform object is associated with.
</p>

<p>
1 個~以上の~ifcを実装する~platform~objの
`首~ifc@
とは、それが実装する`~ifc$のうち，継承~階層において最も末端の~ifcである。
~platform~objの `Prototype^sl 内部~propの値は、`~platform~obj$が属する大域環境に属する，`首~ifc$の`~ifc原型~obj$である。
◎
The primary interface of a platform object that implements one or more interfaces is the most-derived interface that it implements. The value of the internal [[Prototype]] property of the platform object is the interface prototype object of the primary interface from the platform object’s associated global environment.
</p>

<p>
所与の`~platform~obj$が属する大域環境は、その作成-後に
`変化-@
し得る。
~platform~objが属する大域環境が変化した場合、その `Prototype^sl 内部~propは，その新たな大域環境に属する `首~ifc$の`~ifc原型~obj$に，即時に更新され~MUST。
◎
The global environment that a given platform object is associated with can change after it has been created. When the global environment associated with a platform object is changed, its internal [[Prototype]] property must be immediately updated to be the interface prototype object of the primary interface from the platform object’s newly associated global environment.
</p>

<p>
1 個~以上の~ifcを実装する~platform~objの `~class文字列$は、~platform~objの`首~ifc$の`識別子$で~MUST。
◎
The class string of a platform object that implements one or more interfaces must be the identifier of the primary interface of the platform object.
</p>

<div class="p">
<p>
`LegacyNamespace$x 拡張属性を伴う~ifcの`~class文字列$は、次の連結で与えられる：
</p>

<ol ><li>拡張属性に指定された~nsの，~class文字列
</li><li>`.^l
</li><li>この~ifcがこの拡張属性を伴っていなかった場合に有することになる~class文字列
</li></ol>

◎
The class string of an interface with the [LegacyNamespace] extended attribute is the concatenation of the class string of the namespace, ".", and the class string that the interface would otherwise have without this extended attribute.
</div>


			<section id="platform-object-setprototypeof">
<h4>3.7.1. `SetPrototypeOf^sl</h4>

<p>
`*Global$x `拡張属性$を伴う`~ifc$を実装する`~platform~obj$ %O の `SetPrototypeOf^sl 内部~methが，~ES言語~値 %V で~callされたときは、次の手続きを行う：
◎
When the [[SetPrototypeOf]] internal method of a platform object O that implements an interface with the [Global] or [PrimaryGlobal] extended attribute is called with ECMAScript language value V, the following step is taken:
</p>

<!--cp-SetImmutablePrototype-->

<p class="note">注記：
`Window$T ~objに対しては、これが実装されているかどうかは観測し得ない
— `WindowProxy$T ~objの存在tにより、 `Window^T ~obj上では， `SetPrototypeOf^sl は決して直接的に~callされないことが確保されるので。
しかしながら，他の~大域~objに対しては、このことは必要とされない。
◎
Note: For Window objects, it is unobservable whether this is implemented, since the presence of the WindowProxy object ensures that [[SetPrototypeOf]] is never called on a Window object directly. For other global objects, however, this is necessary.
</p>

			</section>
		</section>
		<section id="es-legacy-platform-objects">
<h3 title="Legacy platform objects">3.8. 旧来の~platform~obj</h3>

<p>
`旧来の~platform~obj$は、［
自身の［
`有index~prop$, `有名~prop$
］に対応するような 追加の~prop
］を持つように現れることになる。
これらの~propは，~obj上の “真の” 自前の~propではないが、
`GetOwnProperty^sl 内部~methにより公開されて見えるようにされる。
◎
Legacy platform objects will appear to have additional properties that correspond to their indexed and named properties. These properties are not “real” own properties on the object, but are made to look like they are by being exposed by the [[GetOwnProperty]] internal method .
</p>

<p>
~objが`有index~propを~support$するような複数の~ifcを実装することは許可され得る。
しかしながら，そうであって［
~objにおける`被support~prop~index$の定義が競合している
］場合に、［
~objが持つように現れることになる追加の~prop
］がどれになるか, あるいは［
その有index~propに関する正確な挙動
］がどうなるか，については、未定義である。
同じことは、有名~propについても該当する。
◎
It is permissible for an object to implement multiple interfaces that support indexed properties. However, if so, and there are conflicting definitions as to the object’s supported property indices, then it is undefined what additional properties the object will appear to have, or what its exact behavior will be with regard to its indexed properties. The same applies for named properties.
</p>

<p>
［
旧来の~platform~objが実装する，継承~階層において最も末端の~ifc
］上で定義される`有index~prop取得子$が、［
`配列~index$による~objに対する~indexingの際の挙動
］を定義する。
`有index~prop設定子$に対しても同様になる。
先祖の~ifcによる，これらの特殊~演算の定義は、この仕方で上書きできる。
◎
The indexed property getter that is defined on the derived-most interface that the legacy platform object implements is the one that defines the behavior when indexing the object with an array index. Similarly for indexed property setters. This way, the definitions of these special operations from ancestor interfaces can be overridden.
</p>

<div class="p">
<p>
所与の~platform~obj %O 上の~prop名は、
%O が次を満たす`~ifc$ %I を実装するならば，
`偽装不可~prop名@
とされる：
</p>

<ul><li>%I はその~prop名を識別子とする`~ifc~mb$を持つ, かつ
</li><li>その~mbは［
%O が実装するいずれかの~ifc
］上で`偽装不可$である。
</li></ul>

◎
A property name is an unforgeable property name on a given platform object O if the object implements an interface that has an interface member with that identifier and that interface member is unforgeable on any of the interfaces that O implements.

</div>

<p>
`取得子$の~supportは
`legacy-platform-object-getownproperty$sec
にて取扱われ、`設定子$については
`legacy-platform-object-defineownproperty$sec,
`legacy-platform-object-set$sec
にて取扱われる。
◎
Support for getters is handled in §3.8.1 [[GetOwnProperty]], and for setters in §3.8.3 [[DefineOwnProperty]] and §3.8.2 [[Set]].
</p>

			<section id="legacy-platform-object-getownproperty">
<h4>3.8.1. `GetOwnProperty^sl</h4>

<p>
どの`旧来の~platform~obj$ %O に対しても，その `GetOwnProperty^sl 内部~methは、
( ~prop名 %P )
を引数に~callされたときには，次に従って挙動し~MUST：
◎
The internal [[GetOwnProperty]] method of every legacy platform object O must behave as follows when called with property name P:
</p>



<ol class="algorithm">
	<li>
~RET
`LegacyPlatformObjectGetOwnProperty$A( %O, %P, `false^jv )
◎
Return LegacyPlatformObjectGetOwnProperty(O, P, false).
</li>
</ol>

			</section>
			<section id="legacy-platform-object-set">
<h4>3.8.2. `Set^sl</h4>

<p>
どの`旧来の~platform~obj$ %O に対しても，その `Set^sl 内部~methは、
( ~prop名 %P, 値 %V, ~ES言語~値 %Receiver )
を引数に~callされたときには，次に従って挙動し~MUST：
◎
The internal [[Set]] method of every legacy platform object O must behave as follows when called with property name P, value V, and ECMAScript language value Receiver:
</p>

<ol class="algorithm">
	<li>
<p>
~IF［
%O ~EQ %Receiver
］：
◎
If O and Receiver are the same object, then:
</p>

		<ol>
			<li>
<p>
~IF［
%O は `有index~propを~support$する
］~AND［
%P は`配列~indexで$ある
］~AND［
%O が実装するある~ifcに，`有index~prop設定子$が伴われている
］：
◎
If O supports indexed properties, P is an array index, and O implements an interface with an indexed property setter, then:
</p>
				<ol>
					<li>
( %P, %V )
を~~渡して
`有index~prop設定子を呼出す$
◎
Invoke the indexed property setter with P and V.
</li>
					<li>
~RET `true^jv
◎
Return true.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%O は `有名~propを~support$する
］~AND［
`Type$A( %P ) ~EQ `String^jt
］~AND［
%P は`配列~indexで$ない
］~AND［
%O が実装するある~ifcに，`有名~prop設定子$が伴われている
］：
◎
If O supports named properties, Type(P) is String, P is not an array index, and O implements an interface with a named property setter, then:
</p>
				<ol>
					<li>
( %P, %V )
を~~渡して
`有名~prop設定子を呼出す$
◎
Invoke the named property setter with P and V.
</li>
					<li>
~RET `true^jv
◎
Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%ownDesc ~LET
`LegacyPlatformObjectGetOwnProperty$A( %O, %P, `true^jv )
◎
Let ownDesc be LegacyPlatformObjectGetOwnProperty(O, P, true).
</li>
	<li>
? `OrdinarySetWithOwnDescriptor$A( %O, %P, %V, %Receiver, %ownDesc )
を遂行する
◎
Perform ? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).
</li>
</ol>

			</section>
			<section id="legacy-platform-object-defineownproperty">
<h4>3.8.3. `DefineOwnProperty^sl</h4>

<p>
`旧来の~platform~obj$ %O
］の `DefineOwnProperty^sl 内部~methは，［
~prop~key %P, `~pdesc$ %Desc
］を伴って~callされたときは、次の手続きに従わ~MUST：
◎
When the internal [[DefineOwnProperty]] method of a legacy platform object O is called with property key P and Property Descriptor Desc, the following steps must be taken:
</p>

<ol class="algorithm">
	<li>
<p id="cp-if-support-and-index">
~IF［
%O は `有index~propを~support$する
］~AND［
%P は `配列~indexで$ある
］：
◎
If O supports indexed properties and P is an array index, then:
</p>
		<ol>
			<li id="cp-ret-false-ifnot-IsDataDescriptor">
~IF［
`IsDataDescriptor$A( %Desc ) を~callした結果 ~EQ `false^jv
］
⇒
~RET `false^jv
◎
If the result of calling IsDataDescriptor(Desc) is false, then return false.
</li>
			<li>
~IF［
%O が実装する どの~ifcにも，`有index~prop設定子$は伴われていない
］
⇒
~RET `false^jv
◎
If O does not implement an interface with an indexed property setter, then return false.
</li>
			<li>
( %P, %Desc.`Value^sl )
を~~渡して
`有index~prop設定子を呼出す$
◎
Invoke the indexed property setter with P and Desc.[[Value]].
</li>
			<li>
~RET `true^jv
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p><!-- copy* -->
~IF［
%O は `有名~propを~support$する
］~AND［
%O は `*Global$x `拡張属性$を伴う`~ifc$を実装しない
］~AND［
`Type$A( %P ) ~EQ `String^jt
］~AND［
%P は %O の `Unforgeable$x ~prop名でない
］：
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute, Type(P) is String, and P is not an unforgeable property name of O, then:
</p>

		<ol>
			<li id="cp-let-creating">
%creating ~LET ［
%P は`被support~prop名$であるならば ~T ／
~ELSE_ ~F
］
◎
Let creating be true if P is not a supported property name, and false otherwise.
</li>
			<li>
<p>
~IF［
%O が実装するある~ifcに， `OverrideBuiltins$x `拡張属性$が伴われている
］~OR［
%O は 名前 %P の自前の~propを持たない
］：
◎
If O implements an interface with the [OverrideBuiltins] extended attribute or O does not have an own property named P, then:
</p>
				<ol>
					<li>
~IF［
%creating ~EQ ~F
］~AND［
%O が実装する どの~ifcにも，`有名~prop設定子$は伴われていない
］
⇒
~RET `false^jv
◎
If creating is false and O does not implement an interface with a named property setter, then return false.
</li>
					<li>
<p>
~IF［
%O が実装する ある~ifcに，`有名~prop設定子$が伴われている
］：
◎
If O implements an interface with a named property setter, then:
</p>
						<ol>
							<!--cp-ret-false-ifnot-IsDataDescriptor-->
							<li>
( %P, %Desc.`Value^sl )
を~~渡して
`有名~prop設定子を呼出す$
◎
Invoke the named property setter with P and Desc.[[Value]].
</li>
							<li>
~RET `true^jv
◎
Return true.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%O は `*Global$x `拡張属性$を伴う`~ifc$を実装していない
］
⇒
%Desc.`Configurable^sl ~SET `true^jv
◎
If O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute, then set Desc.[[Configurable]] to true.
</li>
	<li>
~RET `OrdinaryDefineOwnProperty$A( %O, %P, %Desc )
◎
Return OrdinaryDefineOwnProperty(O, P, Desc).
</li>
</ol>


			</section>
			<section id="legacy-platform-object-delete">
<h4>3.8.4. `Delete^sl</h4>


<p>
どの`旧来の~platform~obj$ %O においても，その `Delete^sl 内部~methは、~prop名 %P を伴って~callされたときには，次に従って挙動し~MUST。
◎
The internal [[Delete]] method of every legacy platform object O must behave as follows when called with property name P.
</p>

<ol class="algorithm">
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<li id="cp-ToUint32-2">
%index ~LET `ToUint32$A( %P )
◎
Let index be the result of calling ToUint32(P).
</li>
			<li>
~IF［
%index は `被support~prop~index$でない
］
⇒
~RET `true^jv
◎
If index is not a supported property index, then return true.
</li>
			<li>
~RET `false^jv
◎
Return false.
</li>
		</ol>
	</li>
	<li>
<p><!-- copy* -->
~IF［
%O は `有名~propを~support$する
］~AND［
%O は `*Global$x `拡張属性$を伴う`~ifc$を実装しない
］~AND［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］：
◎
If O supports named properties, O does not implement an interface with the [Global] or [PrimaryGlobal] extended attribute and the result of calling the named property visibility algorithm with property name P and object O is true, then:
</p>
		<ol>
			<li>
~IF［
%O が実装する どの~ifcにも，`有名~prop削除子$は伴われていない
］
⇒
~RET `false^jv
◎
If O does not implement an interface with a named property deleter, then return false.
</li>
			<li>
%演算 ~LET `有名~prop削除子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property deleter.
</li>
			<li>
<p id="cp-ifdef-no-id">
~IF［
%演算 は `識別子$を伴わずに定義されている
］：
◎
If operation was defined without an identifier, then:
</p>
				<ol>
					<li>
名前 %P に対し，既存の有名~propを削除するために、~ifcの記述に挙げられている
`既存の有名~propを削除する$
手続きを遂行する
◎
Perform the steps listed in the interface description to delete an existing named property with P as the name.
</li>
					<li>
~IF［
手続きから削除の失敗-が指示された
］
⇒
~RET `false^jv
◎
If the steps indicated that the deletion failed, then return false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
：
◎
Otherwise, operation was defined with an identifier:
</p>
				<ol>
					<li>
( %P )
を引数に，
%演算 の記述に挙げられている手続きを遂行する
◎
Perform the steps listed in the description of operation with P as the only argument value.
</li>
					<li>
~IF［
%演算 は `返値型$ `boolean$T を伴って宣言されている
］~AND［
その手続きから `false^V が返された
］
⇒
~RET `false^jv
◎
If operation was declared with a return type of boolean and the steps returned false, then return false.
</li>
				</ol>
			</li>
			<li id="cp-return-true">
~RET `true^jv
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は 名前 %P の自前の~propを持つ
］：
◎
If O has an own property with name P, then:
</p>
		<ol>
			<li>
~IF［
その~propは~configurableでない
］
⇒
~RET `false^jv
◎
If the property is not configurable, then return false.
</li>
			<li>
~ELSE
⇒
その~propを %O から除去する
◎
Otherwise, remove the property from O.
</li>
		</ol>
	</li>
	<!--cp-return-true-->
</ol>
			</section>
			<section id="legacy-platform-object-preventextensions">
<h4>3.8.5. `PreventExtensions^sl</h4>

<p>
`旧来の~platform~obj$の `PreventExtensions^sl 内部~methが~callされたときは、次の手続きを行う：
◎
When the [[PreventExtensions]] internal method of a legacy platform object is called, the following steps are taken:
</p>

<ol class="algorithm">
	<li>
~RET `false^jv
◎
Return false.
</li>
</ol>

<p class="note">注記:
これにより、`旧来の~platform~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^sl を失敗させることにより。
◎
Note: this keeps legacy platform objects extensible by making [[PreventExtensions]] fail for them.
</p>
			</section>
			<section id="legacy-platform-object-ownpropertykeys">
<h4>3.8.6. `OwnPropertyKeys^sl</h4>

<p>
この文書は、`~ifc$を実装している`~platform~obj$（あるいは
<a href="#es-exception-objects">例外を表現する~platform~obj</a>
）に対する，完全な~prop列挙~順序は定義しない。
が、`旧来の~platform~obj$に対しては，定義する
— 次に与える `OwnPropertyKeys^sl 内部~methを定義することにより。
◎
This document does not define a complete property enumeration order for platform objects implementing interfaces (or for platform objects representing exceptions). However, it does for legacy platform objects by defining the [[OwnPropertyKeys]] internal method as follows.
</p>

<p>
`旧来の~platform~obj$ %O の `OwnPropertyKeys^sl 内部~methの~call時には、次の手続きを行う：
◎
When the [[OwnPropertyKeys]] internal method of a legacy platform object O is called, the following steps are taken:
</p>

<ol>
	<li>
%~key~list ~LET 新たな空`~list$
— これは、いくつかの~ES［
`String^jt ／ `Symbol^jt
］値からなる。
◎
Let keys be a new empty list of ECMAScript String and Symbol values.
</li>
	<li>
~IF［
%O は`有index~propを~support$する
］
⇒
%O の~EACH( `被support~prop~index$ %~index ) に対し，昇順に
⇒
! `ToString$A( %~index ) を %~key~list に`付加-$する
◎
If O supports indexed properties, then for each index of O’s supported property indices, in ascending numerical order, append ! ToString(index) to keys.
</li>
	<li>
~IF［
%O は`有名~propを~support$する
］
⇒
%O の~EACH( `被support~prop名$ %P ) に対し
【~prop名の集合を定義する仕様により定義される順序で】
⇒
~IF［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］
⇒
%P を %~key~list に`付加-$する
◎
If O supports named properties, then for each P of O’s supported property names that is visible according to the named property visibility algorithm, append P to keys.
</li>
	<li>
%O の~EACH( 自前の~prop~key %P ) に対し，~propを作成した順に
⇒
~IF［
%P は `String^jt である
］
⇒
%P を %~key~list に`付加-$する
◎
For each P of O’s own property keys that is a String, in ascending chronological order of property creation, append P to keys.
</li>
	<li>
%O の~EACH( 自前の~prop~key %P ) に対し，~propを作成した順に
⇒
~IF［
%P は `Symbol^jt である
］
⇒
%P を %~key~list に`付加-$する
◎
For each P of O’s own property keys that is a Symbol, in ascending chronological order of property creation, append P to keys.
</li>
	<li>
~Assert:
%~key~list 内には重複する~itemは無い
◎
Assert: keys has no duplicate items.
</li>
	<li>
~RET %~key~list
◎
Return keys.
</li>
</ol>

			</section>
			<section id="legacy-platform-object-abstract-ops">
<h4 title="Abstract operations">3.8.7. 各種 抽象~演算</h4>

<p>
所与の~prop名 %P が
`配列~indexで@
あるかどうか決定するときは、次の~algoを適用する：
◎
To determine if a property name P is an array index, the following algorithm is applied:
</p>

<ol class="algorithm">
	<li>
~IF［
`Type$A( %P ) ~NEQ `String^jt
］
⇒
~RET ~F
◎
If Type(P) is not String, then return false.
</li>
	<li>
%index ~LET
! `CanonicalNumericIndexString$A( %P )
◎
Let index be ! CanonicalNumericIndexString(P).
</li>
	<li>
~IF［
%index ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If index is undefined, then return false.
</li>
	<li>
<p>
~IF［
%index ~LT 0
］~OR［
%index ~GT 2`32^sup − 1†
］
⇒
~RET ~F
◎
If index is less than 0 or is greater than or equal to 232 − 1, then return false.
</p>

<p class="note">注記：
2`32^sup − 1 は、~ESに許容される最大の配列~長さである。
◎
Note: 232 − 1 is the maximum array length allowed by ECMAScript.
</p>

【† 原文の “is greater than or equal to” は、おそらく “is greater than” の誤記】

	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

<p>
所与の有名~propを~obj上に公開するかどうかは、
`有名~propの可視性判定~algo@
を利用して決定される。
一部の有名~propは、［
`OverrideBuiltins$x `拡張属性$が利用されたかどうか
］に依存して，~obj上に公開されなくなる。
この~algoは、所与の
( ~prop名 %P, ~obj %O )
に対し，次に従って演算する：
◎
The named property visibility algorithm is used to determine if a given named property is exposed on an object. Some named properties are not exposed on an object depending on whether the [OverrideBuiltins] extended attribute was used. The algorithm operates as follows, with property name P and object O:
</p>

<ol class="algorithm">
	<li>
~IF［
%P は %O 上の`被support~prop名$でない
］
⇒
~RET ~F
◎
If P is not a supported property name of O, then return false.
</li>
	<li>
<p>
~IF［
%O は名前 %P の自前の~propを持つ
］
⇒
~RET ~F
◎
If O has an own property named P, then return false.
</p>

<p class="note">注記：
これには %O が偽装不可の~propを持つ事例も含まれる
— 実施においては、それらは常に ~objが被support~prop名を持つ前に設定しておかれ，対応する有名~propを不可視にするので。
◎
Note: This will include cases in which O has unforgeable properties, because in practice those are always set up before objects have any supported property names, and once set up will make the corresponding named properties invisible.
</p>

	</li>
	<li>
~IF［
%O が実装する ある~ifcが， `OverrideBuiltins$x `拡張属性$を持つ
］
⇒
~RET ~T
◎
If O implements an interface that has the [OverrideBuiltins] extended attribute, then return true.
</li>
	<li>
%prototype ~LET %O の `Prototype^sl 内部~propの値
◎
Initialize prototype to be the value of the internal [[Prototype]] property of O.
</li>
	<li>
<p>
~WHILE %prototype ~NEQ `null^jv ：
◎
While prototype is not null:
</p>
		<ol>
			<li>
~IF［
%prototype は `有名~prop~obj$でない
］~AND［
%prototype は 名前 %P の自前の~propを持つ
］
⇒
~RET ~F
◎
If prototype is not a named properties object, and prototype has an own property named P, then return false.
</li>
			<li>
%prototype ~SET %prototype の `Prototype^sl 内部~propの値
◎
Set prototype to be the value of the internal [[Prototype]] property of prototype.
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

<div class="note">

<p>注記：
これにより、有名~propを伴う~objに対する~prop解決が次の順序で行えるようになる：
◎
This should ensure that for objects with named properties, property resolution is done in the following order:
</p>
<ol>
	<li>
有index~prop
◎
Indexed properties.
</li>
	<li>
自前の~prop
— 偽装不可である属性／演算も含め。
◎
Own properties, including unforgeable attributes and operations.
</li>
	<li>
<p>
`OverrideBuiltins$x である場合：
◎
Then, if [OverrideBuiltins]:
</p>
		<ol>
			<li>
有名~prop
◎
Named properties.
</li>
			<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
		</ol>
	</li>
	<li>
<p>
他の場合：
◎
Otherwise, if not [OverrideBuiltins]:
</p>
		<ol>
			<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
			<li>
有名~prop
◎
Named properties.
</li>
		</ol>
	</li>
</ol>

</div>

<p>
( ~prop~名 %P, ~ES値 %V )
を~~渡して
`有index~prop設定子を呼出す@
ときは、次の手続きを遂行し~MUST：
◎
To invoke an indexed property setter with property name P and ECMAScript value V, the following steps must be performed:
</p>

<ol class="algorithm">
	<!--cp-ToUint32-2-->
	<li>
%creating ~LET ［
%index が`被support~prop~index$でないならば ~T ／
~ELSE_ ~F
］
◎
Let creating be true if index is not a supported property index, and false otherwise.
</li>
	<li>
%演算 ~LET `有index~prop設定子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the indexed property setter.
</li>
	<li id="cp-2nd-arg">
%T ~LET %演算 の 2 個目の引数の型
◎
Let T be the type of the second argument of operation.
</li>
	<li id="cp-V-toIDL-T">
%value ~LET %V を型 %T の`~IDL値に変換-$した結果
◎
Let value be the result of converting V to an IDL value of type T.
</li>
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF［
%creating ~EQ ~T
］
⇒
( ~index %index, 値 %value )
に対し，~ifcの記述に挙げられている
`新たな有index~propを設定する$
手続きを遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new indexed property with index as the index and value as the value.
</li>
			<li>
~ELSE
⇒
( ~index %index, 値 %value )
に対し，~ifcの記述に挙げられている
`既存の有index~propを設定する$
手続きを遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing indexed property with index as the index and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
( %index, %value )
を引数に，
%演算 の記述に挙げられている手続きを遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with index and value as the two argument values.
</li>
</ol>



<p>
( ~prop~名 %P, ~ES値 %V )
を~~渡して
`有名~prop設定子を呼出す@
ときは、次の手続きを遂行し~MUST：
◎
To invoke a named property setter with property name P and ECMAScript value V, the following steps must be performed:
</p>

<ol class="algorithm">
	<!--cp-let-creating-->
	<li>
%演算 ~LET `有名~prop設定子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property setter.
</li>
	<!--cp-2nd-arg-->
	<!--cp-V-toIDL-T-->
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF［
%creating ~EQ ~T
］
⇒
( 名前 %P, 値 %value )
に対し，~ifcの記述に挙げられている
`新たな有名~propを設定する$
手続きを遂行する
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new named property with P as the name and value as the value.
</li>
			<li>
~ELSE
⇒
( 名前 %P, 値 %value )
に対し，~ifcの記述に挙げられている
`既存の有名~propを設定する$
手続きを遂行する
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing named property with P as the name and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
( %P, %value )
を引数に，
%演算 の記述に挙げられている手続きを遂行する
◎
Otherwise, operation was defined with an identifier. Perform the steps listed in the description of operation with P and value as the two argument values.
</li>
</ol>


<p>
抽象~演算
`LegacyPlatformObjectGetOwnProperty@A
は、
( ~obj %O, ~prop名 %P, 真偽~値 %有名~propは無視する )
を~~渡して~callされたとき，次の手続きを遂行する:
◎
The LegacyPlatformObjectGetOwnProperty abstract operation performs the following steps when called with an object O, a property name P, and a boolean ignoreNamedProps value:
</p>

<ol class="algorithm">
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<!--cp-ToUint32-2-->
			<li>
<p>
~IF［
%index は `被support~prop~index$である
］：
◎
If index is a supported property index, then:
</p>
				<ol>
					<li>
%演算 ~LET `有index~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the indexed property getter.
</li>
					<!--cp-let-uninitialized-->
					<li><!-- copy* -->
~IF［
%演算 は `識別子$を伴わずに定義されている
］
⇒
%value ~SET ［
~index %index に対し，~ifcの記述に挙げられている
`有index~propの値を決定する$
手続きを遂行した結果
］
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of an indexed property with index as the index.
</li>
					<li><!-- copy* -->
~ELSE
⇒
%value ~SET ［
( %index )
を引数に， %演算 の記述に挙げられている手続きを遂行した結果
］
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with index as the only argument value.
</li>
					<li>
<!--cp-ret-new-desc-->
<div>
&nbsp;&nbsp; `BTT-V^desc — ここで：

						<ul>
							<!--cp-let-convert2-->
							<li>
%B ~LET ［
%O が実装するある~ifcに，`有index~prop設定子$が伴われている ならば `true^jv ／
~ELSE_ `false^jv
］
</li>
						</ul>
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with an indexed property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
Set desc.[[Enumerable]] and desc.[[Configurable]] to true.
◎
Return desc.
</div>
					</li>
				</ol>
			</li>
			<li>
%有名~propは無視する ~SET ~T
◎
Set ignoreNamedProps to true.
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は `有名~propを~support$する
］~AND［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］~AND［
%有名~propは無視する ~EQ ~F
］：
◎
If O supports named properties, the result of running the named property visibility algorithm with property name P and object O is true, and ignoreNamedProps is false, then:
</p>

		<ol>
			<li>
%演算 ~LET `有名~prop取得子$の宣言-時に利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
			<!--cp-let-uninitialized-->
			<!--cp-determine-ifndef-->
			<!--cp-set-as-desc1-->

			<li>
<!--cp-ret-new-desc-->
<div>
&nbsp;&nbsp; `BET-V^desc — ここで：

				<ul>
					<!--cp-let-convert2-->
					<li>
%B ~LET ［
%O が実装するある~ifcに，`有名~prop設定子$が伴われている ならば `true^jv ／
~ELSE_ `false^jv
］
</li>
					<li>
%E ~LET ［
%O が実装するある~ifcに， `LegacyUnenumerableNamedProperties$x `拡張属性$が伴われているならば `false^jv ／
~ELSE_ `true^jv
］
</li>
				</ul>
◎
Set desc.[[Value]] to the result of converting value to an ECMAScript value.
◎
If O implements an interface with a named property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
If O implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Configurable]] to true.
◎
Return desc.
</div>
			</li>
		</ol>
	</li>
	<!--cp-return-OrdinaryGetOwnProperty-->
</ol>

			</section>
		</section>
		<section id="es-user-objects">
<h3 title="User objects implementing callback interfaces">3.9. 呼戻~ifcを実装する利用者~obj</h3>


<p>
上の
`idl-objects$sec
に述べたように、
`呼戻~ifc$は，~scriptの中で~ES~objにより実装され得る。
次の場合分けにより、所与の~objが［
呼戻~ifcを実装している利用者~obj
］と見なされるかどうかが決定される。
◎
As described in §2.11 Objects implementing interfaces, callback interfaces can be implemented in script by an ECMAScript object. The following cases determine whether and how a given object is considered to be a user object implementing a callback interface:
</p>

<ul>
	<li>
<p>
~ifcが（下で定義される）`単一~演算~呼戻~ifc$である場合、どの~objも，その~ifcを実装するものと見なされる。
その演算（または多重定義されている演算の集合）の実装は、次で与えられる：
◎
If the interface is a single operation callback interface (defined below) then any object is considered to implement the interface. The implementation of the operation (or set of overloaded operations) is as follows:
</p>
		<ul>
			<li>
~objが`~callable$である場合、その演算（または多重定義されている演算の集合）の実装はその~callable~obj自身になる。
◎
If the object is callable, then the implementation of the operation (or set of overloaded operations) is the callable object itself.
</li>
			<li>
他の場合（すなわち~objは`~callable$でない）、その演算（または多重定義されている演算の集合）の実装は、その演算の`識別子$を~prop名【†1】
として，その~obj上の `Get^sl 内部~methを呼出した結果になる。<!--  -->
◎
Otherwise, the object is not callable. The implementation of the operation (or set of overloaded operations) is the result of invoking the internal [[Get]] method on the object with a property name that is the identifier of the operation.
</li>
		</ul>
	</li>
	<li>
<!-- `~platform~obj$でなく, かつ -->
他の場合（~ifcは`単一~演算~呼戻~ifc$でない）、どの~objも，その~ifcを実装するものと見なされる。
所与の`識別子$を伴って~ifc上に宣言される各~演算に対し、その実装は，その識別子を~prop名として，その~obj上の `Get^sl を呼出した結果になる。
◎
Otherwise, the interface is not a single operation callback interface. Any object is considered to implement the interface. For each operation declared on the interface with a given identifier, the implementation is the result of invoking [[Get]] on the object with a property name that is that identifier.
</li>
</ul>

<p>
`~ifc$上に`定数$が宣言されているとしても、~ES~objが，その~ifcを実装している`利用者~obj$と見なされるために，それらの定数に対応する~propを持つ必要はないことに注意。
◎
Note that ECMAScript objects need not have properties corresponding to constants on them to be considered as user objects implementing interfaces that happen to have constants declared on them.
</p>

<p>
`単一~演算~呼戻~ifc@
とは、次のすべてを満たす`呼戻~ifc$である：
◎
A single operation callback interface is a callback interface that:
</p>

<ul>
	<li>
別の~ifcを`継承-$するように宣言されていない。
◎
is not declared to inherit from another interface,
</li>
	<li>
`属性$を持たない。
◎
has no attributes, and
</li>
	<li>
すべてが同じ`識別子$を持つ 1 個~以上の`正則~演算$があり，他のものはない。
◎
has one or more regular operations that all have the same identifier, and no others.
</li>
</ul>


<p class="trans-note">【
例えば DOM の `EventListener$T ~ifc。
その唯一の~mbの識別子 `handleEvent^c が上述の~prop名（ †1 ）にあたる。
】</p>

<p class="trans-note">【
共通の記述を集約するため、この訳では，以下に定義される各種 手続きの中から一部分を抽出して，次の 2 つの手続き
“PrepareSettings”,
“CleanupSettings”
に~~分離する（ 手続きの名前は、当たり障りないように選んだだけで特に意味はない）：
】</p>

<div class="p">
<p>
`PrepareSettings@A( %realm, %value )
は、次を遂行する：
</p>

<ol class="algorithm"
	><li>%関連する設定群 ~LET %realm の`設定群~obj$
</li><li>%格納済み設定群 ~LET %value の`呼戻~文脈$
</li><li>%関連する設定群 で`~scriptを走らすために準備する$
</li><li>%格納済み設定群 で`呼戻子を走らすために準備する$
</li><li>~RET 組 ( %関連する設定群, %格納済み設定群 )
</li></ol>
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be XXX’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</div>

<div >
<p>
`CleanupSettings@A( %設定群~組, %completion, %T )
は、次を遂行する
— ここで：
</p>
<ul><li>%設定群~組 は `PrepareSettings$A で得られた 2 つの設定群の組
</li><li>%completion は`完了record$
</li><li>%T はある~IDL型
</li></ul>

<ol class="algorithm">
	<li>
( %関連する設定群, %格納済み設定群 ) ~LET %設定群~組
</li>
	<li>
`走らせた呼戻子を片付ける$( %格納済み設定群 )
</li>
	<li>
`走らせた~scriptを片付ける$( %関連する設定群 )
</li>
	<li>
~IF［
%completion は正常完了である
］~OR［
%T は`~promise型$でない
］
⇒
~RET %completion
</li>
	<li>
%rejectedPromise ~LET
! `Call$A(`Promise_reject$jI, `Promise$jI, «%completion.`Value^sl»)
</li>
	<li>
~RET %rejectedPromise を %T 型の`~IDL値に変換-$した結果
</li>
</ol>

◎
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and T is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»)
• Return the result of converting rejectedPromise to T.
</div>

<p>
`~Web~IDL引数~list@
は、それぞれが［
~IDL値または特殊~値 `missing^C
］である一連の値からなる`~list$である。
◎
A Web IDL arguments list is a list of values each of which is either an IDL value or the special value “missing”, which represents a missing optional argument.
</p>

<p>
所与の`~Web~IDL引数~list$ %args を
`~ES引数~listに変換-@
するときは、次の手続きを遂行する：
◎
To convert a Web IDL arguments list to an ECMAScript arguments list, given a Web IDL arguments list args, perform the following steps:
</p>

<ol class="algorithm">
	<li>
%esArgs ~LET 空`~list$
◎
Let esArgs be an empty list.
</li>
	<li>
%i ~LET 0
◎
Let i be 0.
</li>
	<li>
%count ~LET 0
◎
Let count be 0.
</li>
	<li>
<p>
~WHILE %i ~LT %args の`~size$：
◎
While i &lt; args’s size:
</p>
		<ol>
			<li>
~IF［
%arg[ %i ] ~EQ 特殊~値 `missing^C
］
⇒
`undefined^jv を %esArgs に`付加-$する
◎
If args[i] is the special value “missing”, then append undefined to esArgs.
</li>
			<li>
<p>
~ELSE（ %arg[ %i ] は~IDL値である）：
◎
Otherwise, args[i] is an IDL value:
</p>
				<ol>
					<li>
%変換-結果 ~LET
%arg[ %i ] を`~ES値に変換-$した結果
— 例外は再~投出する
◎
Let convertResult be the result of converting args[i] to an ECMAScript value. Rethrow any exceptions.
</li>
					<li>
%変換-結果 を %esArgs に付加する
◎
Append convertResult to esArgs.
</li>
					<li>
%count ~SET %i + 1
◎
Set count to i + 1.
</li>
				</ol>
			</li>
			<!--cp-inc-i-->
		</ol>
	</li>
	<li>
%esArgs を %count 個の~itemまでに切り詰める
◎
Truncate esArgs to contain count items.
</li>
	<li>
~RET %esArgs
◎
Return esArgs.
</li>
</ol>

<div class="p">
<p>
`利用者~objの演算を~callする@
ときは、所与の：
</p>

<ul ><li>`~ifc型$の値： %value
</li><li>演算~名： %演算~名（ sometimes-随意）
【 “optional” に “sometimes-” が加わると何が変わるのか？】
</li><li>`~Web~IDL引数~list$： %args
</li><li>`呼戻 this 値@： %thisArg （随意）
</li></ul>

<p>
に対し、次の手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する。
</p>

◎
To call a user object’s operation, given a callback interface type value value, sometimes-optional operation name opName, Web IDL arguments list args, and optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>

<ol class="algorithm">
	<li id="cp-let-completion">
%completion ~LET 未初期化の変数
◎
Let completion be an uninitialized variable.
</li>
	<li id="cp-let-default-thisArg">
~IF［
%thisArg は与えられていない
］
⇒
%thisArg ~LET `undefined^jv
◎
If thisArg was not given, let thisArg be undefined.
</li>
	<li>
%O ~LET %value に対応している~ES~obj
◎
Let O be the ECMAScript object corresponding to value.
</li>
	<li id="cp-let-realm-Realm">
%realm ~LET %O が`属する~Realm$
◎
Let realm be O’s associated Realm.
</li>
	<li>
%設定群~組 ~LET `PrepareSettings$A( %realm, %value )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be value’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%T ~LET 当の演算の返値型
◎
↓</li>
	<li>
<p>
当の演算の実装 %X を決定する：
◎
Determine the implementation of the operation, X:
</p>
		<ol>
			<li>
~IF［
%value の~ifcは `単一~演算~呼戻~ifc$である
］~AND［
! `IsCallable$A( %O ) ~EQ ~T
］
⇒
%X ~SET %O
◎
If value’s interface is a single operation callback interface and ! IsCallable(O) is true, then set X to O.
</li>
			<li>
<p>
~ELSE
— %演算~名 は供されてい~MUST：
◎
Otherwise, opName must be supplied:
</p>
				<ol>
					<li>
%getResult ~LET `Get$A( %O, %演算~名 )
◎
Let getResult be Get(O, opName).
</li>
					<li id="cp-set-getResult">
~IF［
%getResult は`中途完了$である：
］
⇒
~RET `CleanupSettings$A( %設定群~組, %getResult, %T )
◎
If getResult is an abrupt completion, set completion to getResult and jump to the step labeled return.
</li>
					<li>
%X ~SET %getResult.`Value^sl
◎
Set X to getResult.[[Value]].
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
! `IsCallable$A( %X ) ~EQ ~F
］：
</p>

<ol ><li>%completion ~SET 新たな `Completion$A{
`Type^sl: throw,
`Value^sl: 新たな `TypeError^jE ~obj,
`Target^sl: 空
}
</li><li>~RET `CleanupSettings$A( %設定群~組, %completion, %T )
</li></ol>

◎
If ! IsCallable(X) is false, then set completion to a new Completion{[[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty}, and jump to the step labeled return.
</li>

	<li>
~IF［
%value の~ifcは `単一~演算~呼戻~ifc$でない
］~OR［
! `IsCallable$A( %O ) ~EQ ~F
］
⇒
%thisArg ~SET %O
（提供された値を上書きする）
◎
If value’s interface is not a single operation callback interface, or if ! IsCallable(O) is false, set thisArg to O (overriding the provided value).
</li>
	<li id="cp-convert-to-es-args">
<p>
%esArgs ~LET %args を`~ES引数~listに変換-$した結果
</p>

<p>
~IF［
変換-時に例外が投出された
］
⇒
~RET `CleanupSettings$A( %設定群~組, 投出された例外, %T )
◎
Let esArgs be the result of converting args to an ECMAScript arguments list. If this throws an exception, set completion to the completion value representing the thrown exception and jump to the step labeled return.
</li>
	<li>
%callResult ~LET `Call$A( %X, %thisArg, %esArgs )
◎
Let callResult be Call(X, thisArg, esArgs).
</li>
	<li id="cp-callResult-is-abrupt">
~IF［
%callResult は`中途完了$である
］
⇒
~RET `CleanupSettings$A( %設定群~組, %callResult, %T )
◎
If callResult is an abrupt completion, set completion to callResult and jump to the step labeled return.
</li>
	<li id="cp-set-completion-callResult">
%completion ~SET
%callResult.`Value^sl を %T 型の`~IDL値に変換-$した結果
◎
Set completion to the result of converting callResult.[[Value]] to an IDL value of the same type as the operation’s return type.
</li>
	<li id="call-user-object-operation-return">
<p>
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
</p>
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the operation has a return type that is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»)
• Return the result of converting rejectedPromise to the operation’s return type.
</li>
</ol>


<div class="p">
<p>
`利用者~objの属性~値を取得する@
ときは、所与の：
</p>

<ul ><li>`~ifc型$の値： %object
</li><li>属性~名： %属性~名
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する。
</p>

◎
To get a user object’s attribute value, given a callback interface type value object and attribute name attributeName, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>


<ol class="algorithm">
	<!--cp-let-completion-->
	<li id="cp-let-O-corresponding">
%O ~LET %object に対応している~ES~obj
◎
Let O be the ECMAScript object corresponding to object.
</li>
	<li>
%T ~LET 当の属性の型
◎
↓</li>
	<!--cp-let-realm-Realm-->
	<li id="cp-PrepareSettings0">
%設定群~組 ~LET `PrepareSettings$A( %realm, %object )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be object’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%getResult ~LET `Get$A( %O, %属性~名 )
◎
Let getResult be Get(O, attributeName).
</li>
	<!--cp-set-getResult-->
	<li>
%completion ~SET
%getResult.`Value^sl を %T 型の`~IDL値に変換-$した結果
◎
Set completion to the result of converting getResult.[[Value]] to an IDL value of the same type as the attribute’s type.
</li>
	<li id="get-user-object-attribute-return">
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the attribute’s type is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»)
• Return the result of converting rejectedPromise to the attribute’s type.
</li>
</ol>


<div class="p">
<p>
`利用者~objの属性~値を設定する@
ときは、所与の：
</p>

<ul ><li>`~ifc型$の値： %object
</li><li>属性~名： %属性~名
</li><li>~IDL値： %value
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、何も返さないが，例外を投出し得る。
</p>

◎
To set a user object’s attribute value, given a callback interface type value object, attribute name attributeName, and IDL value value, perform the following steps. These steps will not return anything, but could throw an exception.
</div>

<ol class="algorithm">
	<!--cp-let-completion-->
	<!--cp-let-O-corresponding-->
	<!--cp-let-realm-Realm-->
	<!--cp-PrepareSettings0-->
	<li>
%変換-結果 ~LET %value を`~ES値に変換-$した結果
◎
Let convertResult be the result of converting value to an ECMAScript value.
</li>
	<li>
~IF［
%変換-結果 は`中途完了$である
］
⇒
~RET `CleanupSettings$A( %設定群~組, %変換-結果, `void$T )
◎
If convertResult is an abrupt completion, set completion to convertResult and jump to the step labeled return.
</li>
	<li>
%completion ~SET
`Set$A( %O, %属性~名, %変換-結果.`Value^sl, `true^jv )
◎
Set completion to Set(O, attributeName, convertResult.[[Value]], true).
</li>
	<li id="set-user-object-attribute-return">
%completion ~SET `CleanupSettings$A( %設定群~組, %completion, `void$T )
◎
Return: at this point completion will be set to an ECMAScript completion value, which is either an abrupt completion or a normal completion for the value true (as returned by Set).
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
</li>
	<li>
~RET ［
%completion は`中途完了$であるならば %completion ／
~ELSE_ `NormalCompletion$A( `void$T )
］
◎
• If completion is an abrupt completion, return completion.
• Return NormalCompletion(void).
</li>
</ol>

		</section>
		<section id="es-invoking-callback-functions">
<h3 title="Invoking callback functions">3.10. 呼戻~関数の呼出し</h3>

<p>
`呼戻~関数$値として利用されている~ES`~callable$~objの~callのされ方は、前~節で述べた，`利用者~obj$上の`演算$の~callと同様である。
◎
An ECMAScript callable object that is being used as a callback function value is called in a manner similar to how operations on user objects are called (as described in the previous section).
</p>


<div class="p">
<p>
`呼戻~関数を呼出す@
ときは、所与の：
</p>

<ul ><li>`呼戻~関数~型$の値： %callable
</li><li>`~Web~IDL引数~list$： %args
</li><li>`呼戻 this 値$： %thisArg
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する。
</p>

◎
To invoke a callback function type value callable with a Web IDL arguments list args and an optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>

<ol class="algorithm">
	<!--cp-let-completion-->
	<!--cp-let-default-thisArg-->
	<li id="cp-let-F-callable">
%F ~LET %callable に対応している~ES~obj
◎
Let F be the ECMAScript object corresponding to callable.
</li>
	<li>
%T ~LET 当の呼戻~関数の返値型
◎
↓</li>
	<li>
<p>
~IF［
! `IsCallable$A( %F ) ~EQ ~F
］：
◎
If ! IsCallable(F) is false:
</p>
		<ol>
			<li>
<p>
~IF［
%T ~EQ `void$T
］
⇒
~RET
◎
If the callback function’s return type is void, return.
</p>

<p class="note">注記：
これが生じるのは、
`TreatNonObjectAsNull$x が付与された属性による呼戻~関数に限られる。
◎
Note: This is only possible when the callback function came from an attribute marked with [TreatNonObjectAsNull].
</p>
			</li>
			<li>
~RET `undefined^jv を %T 型の`~IDL値に変換-$した結果
◎
Return the result of converting undefined to the callback function’s return type.
</li>
		</ol>
	</li>
	<li id="cp-let-realm-F-Realm">
%realm ~LET %F が`属する~Realm$
◎
Let realm be F’s associated Realm.
</li>
	<li id="cp-PrepareSettings1">
%設定群~組 ~LET `PrepareSettings$A( %realm, %callable )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be callable’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<!--cp-convert-to-es-args-->
	<li>
%callResult ~LET `Call$A( %F, %thisArg, %esArgs )
◎
Let callResult be Call(F, thisArg, esArgs).
</li>
	<!--cp-callResult-is-abrupt-->
	<!--cp-set-completion-callResult-->
	<li id="invoke-return">
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• If completion is a normal completion, return completion.
• If completion is an abrupt completion and the callback function has a return type that is not a promise type, return completion.
• Let rejectedPromise be ! Call(%Promise_reject%, %Promise%, «completion.[[Value]]»)
• Return the result of converting rejectedPromise to the callback function’s return type.
</li>
</ol>

<p>
呼戻~関数には、`構築子$として利用できるものもある。
そのような呼戻~関数の返値型は`~promise型$になっては~MUST_NOT。
◎
Some callback functions are instead used as constructors. Such callback functions must not have a return type that is a promise type.
</p>

<div class="p">
<p>
`呼戻~関数で構築-@
するときは、所与の
</p>

<ul ><li>`呼戻~関数~型$の値： %callable
</li><li>`~Web~IDL引数~list$： %args
</li></ul>

<p>
に対し，次の手続きを遂行する。
この手続きは、~IDL値を返すか，例外を投出する：
</p>
◎
To construct a callback function type value callable with a Web IDL arguments list args, perform the following steps. These steps will either return an IDL value or throw an exception.
</div>


<ol class="algorithm">
	<!--cp-let-completion-->
	<!--cp-let-F-callable-->
	<li>
~IF［
! `IsConstructor$A(%F) ~EQ `false^jv
］
⇒
~throwTypeError
◎
If ! IsConstructor(F) is false, throw a TypeError exception.
</li>
	<!--cp-let-realm-F-Realm-->
	<li>
%T ~LET 当の呼戻~関数の返値型
◎
↓</li>
	<!--cp-PrepareSettings1-->
	<!--cp-convert-to-es-args-->
	<li>
%callResult ~LET `Construct$A( %F, %esArgs )
◎
Let callResult be Construct(F, esArgs).
</li>
	<!--cp-callResult-is-abrupt-->
	<!--cp-set-completion-callResult-->
	<li>
~RET `CleanupSettings$A( %設定群~組, %completion, %T )
◎
Return: at this point completion will be set to an ECMAScript completion value.
• Clean up after running a callback with stored settings.
• Clean up after running script with relevant settings.
• Return completion.
</li>
</ol>



		</section>
		<section id="es-namespaces" class="L2">
<h3 title="Namespaces">3.11. ~ns</h3>

<div class="p">
<p>
所与の~ES大域~環境 %G にて`公開され$ている どの`~ns$ %~ns に対しても、
%G の大域~obj上に，次の特徴を有するような 対応する~propが存在し~MUST：
</p>

<ul>
	<li>
名前は %~ns の`識別子$
</li>
	<li>
値は
`~ns~obj@
と呼ばれる~obj
— その特徴は、
`namespace-object$sec
に述べる。
</li>
	<!--cp-has-attr-TFT-->
</ul>

◎
For every namespace that is exposed in a given ECMAScript global environment, a corresponding property must exist on the ECMAScript environment’s global object. The name of the property is the identifier of the namespace, and its value is an object called the namespace object.
◎
The property has the attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }. The characteristics of a namespace object are described in §3.11.1 Namespace object.
</div>

			<section id="namespace-object">
<h4 title="Namespace object">3.11.1. ~ns~obj</h4>

<p>
所与の
( `~ns$ %~ns, `~Realm$ %realm )
に対する~ns~objは、次に従って作成される：
◎
The namespace object for a given namespace namespace and Realm realm is created as follows:
</p>

<ol class="algorithm">
 	<li>
%~ns~obj ~LET
! `ObjectCreate$A( %realm の `ObjectPrototype$jI )
◎
Let namespaceObject be ! ObjectCreate(the %ObjectPrototype% of realm).
</li>
 	<li>
<p>
%~ns の`~ns~mb$であって`公開され$ている
~EACH ( `正則~属性$ %属性 ) に対し：
◎
For each exposed regular attribute attr that is a namespace member of this namespace,
</p>
		<ol>
			<li>
%F ~LET
( %属性, %~ns, %realm )
から`属性~取得子$を作成した結果
◎
Let F be the result of creating an attribute getter given attr, namespace, and realm.
</li>
			<li>
%新たな記述子 ~LET
{ [[Get]]: `false^jv, [[Enumerable]]: `true^jv, [[Configurable]]: `true^jv }
◎
Let newDesc be the PropertyDescriptor{[[Get]]: F, [[Enumerable]]: true, [[Configurable]]: true}.
</li>
			<li>
! `DefinePropertyOrThrow$A( %~ns~obj, %属性 の`識別子$, %新たな記述子 )
を遂行する
◎
Perform ! DefinePropertyOrThrow(namespaceObject, attr’s identifier, newDesc).
</li>
		</ol>
	</li>
 	<li>
<p>
%~ns の`~ns~mb$であって`公開され$ている
~EACH ( `正則~演算$ %演算 ) に対し：
◎
For each exposed regular operation op that is a namespace member of this namespace,
</p>
		<ol>
			<li>
%F ~LET `演算~関数を作成する$( %演算, %~ns, %realm )
◎
Let F be the result of creating an operation function given op, namespace, and realm.
</li>
			<li>
! `CreateDataProperty$A( %~ns~obj, %演算 の`識別子$, %F )
を遂行する
◎
Perform ! CreateDataProperty(namespaceObject, op’s identifier, F).
</li>
		</ol>
	</li>
	<li>
<p>
`公開され$ている, かつ［
%~ns の識別子を引数にとる `LegacyNamespace$x 拡張属性
］を伴う ~EACH( `~ifc$ %~ifc ) に対し：
◎
For each exposed interface interface which has the [LegacyNamespace] extended attribute with the identifier of this namespace as its argument,
</p>

		<ol>
			<li>
%I ~LET %~ifc に対応する`~ifc~obj$
◎
Let I be the interface object for interface.
</li>
			<li>
%新たな記述子 ~LET  `TFT-I^desc
◎
Let newDesc be the PropertyDescriptor{[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true, [[Value]]: I}.
</li>
			<li>
! `DefinePropertyOrThrow$A( %~ns~obj, %~ifc の`識別子$, %新たな記述子 )
を遂行する
◎
Perform ! DefinePropertyOrThrow(namespaceObject, interface’s identifier, newDesc).
</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
		<section id="es-exceptions">
<h3 title="Exceptions">3.12. 例外</h3>

			<section id="es-DOMException-specialness">
<h4 title="DOMException custom bindings">3.12.1. ~DOMException~custom言語束縛</h4>

<p>
~ES言語束縛においては、 `DOMException$T 型には，追加の要件がいくつかある：
◎
In the ECMAScript binding, the DOMException type has some additional requirements:
</p>

<ul>
	<li>
通常の`~ifc型$と違って， `DOMException$T に対する`~ifc原型~obj$は、その `Prototype^sl に，内在的~obj `ErrorPrototype$jI を持た~MUST。
◎
Unlike normal interface types, the interface prototype object for DOMException must have as its [[Prototype]] the intrinsic object %ErrorPrototype%.
</li>
	<li>
実装は、~native `Error$t ~objに［
特別な力／標準でない~prop
］を与える場合（ `stack^c ~propなど），
それらも `DOMException$T の各~instanceに公開するべきである。
◎
If an implementation gives native Error objects special powers or nonstandard properties (such as a stack property), it should also expose those on DOMException instances.
</li>
</ul>

			</section>
			<section id="es-exception-objects">
<h4 title="Exception objects">3.12.2. 例外~obj</h4>

<p>
`単純例外$は、対応する型の~native ~ES~objにより表現される。
◎
Simple exceptions are represented by native ECMAScript objects of the corresponding type.
</p>

<p>
`DOMException$T は、`DOMException$T ~ifcを実装する`~platform~obj$により表現される。
◎
A DOMException is represented by a platform object that implements the DOMException interface.
</p>

			</section>
			<section id="es-creating-throwing-exceptions">
<h4 title="Creating and throwing exceptions">3.12.3. 例外の作成と投出</h4>

<p>
［
`単純例外$／ `DOMException$T
］ %E を`作成する$ときは、所与の［
`~error名$を与える文字列 %N （ `DOMException$T の場合のみ）,
~UAにより定義される~messageを与える文字列 %M （省略時は `undefined^jv ）
］に対し，次を走らす：
◎
To create a simple exception or DOMException E, with a string giving the error name N for the DOMException case and optionally a string giving a user agent-defined message M:
</p>

<ol class="algorithm">
	<li>
<p>
%args ~LET %E の型に応じて，次で与えられる~ES~値からなる~list：
</p>
<ul><li>`DOMException$T ならば： « %M, %N »
</li><li>`単純例外$ならば： « %M »
</li></ul>
◎
If M was not specified, let M be undefined.
◎
Let args be a list of ECMAScript values determined based on the type of E:
• E is DOMException
•• args is «M, N».
• E is a simple exception
•• args is «M».
</li>
	<li>
<p>
%X ~LET %E の型に応じて，次で与えられる~obj：
</p>
<ul><li>`DOMException$T ならば：
`現在の~Realm$に属する `DOMException$T `~ifc~obj$
</li><li>`単純例外$ならば：
 `現在の~Realm$に属する， %E に対応している~ES~errorに対する`構築子$
</li></ul>
◎
Let X be an object determined based on the type of E:
• E is DOMException
•• X is the DOMException interface object from the current Realm.
• E is a simple exception
•• X is the constructor for the corresponding ECMAScript error from the current Realm.
</li>
	<li>
~RET ! `Construct$A( %X, %args )
◎
Return ! Construct(X, args).
</li>
</ol>

<p>
`単純例外$ ／ `DOMException$T
を`投出する$ときは、所与の［
`~error名$を与える文字列（ `DOMException$T の場合のみ）,
~UAにより定義される~messageを与える文字列（省略可）
］に対し，次を走らす：
◎
To throw a simple exception or DOMException, with a string giving the error name for the DOMException case and optionally a string giving a user agent-defined message:
</p>

<ol class="algorithm">
	<li>
`~THROW$ 同じ~引数で例外を`作成-$した結果
◎
Let O be the result of creating an exception with the same arguments.
◎
Throw O.
</li>
</ol>

<div class="note">
<p>
上の~algoは、`関数~obj$ %F から外へ伝播する
<a href="#es-exception-objects">例外を表現する~obj</a>を，
%F の`~Realm$（すなわち， %F の実行-時における`現在の~Realm$）に属するものに制約する。
例えば、次の~IDLを考える：
◎
The above algorithms restrict objects representing exceptions propagating out of a function object to be ones that are associated with the Realm of that function object (i.e., the current Realm at the time the function executes). For example, consider the IDL:
</p>

<pre class="webidl">
interface MathUtils {
  /* <span class="comment">
%x が負ならば `NotSupportedError$E `DOMException$T を投出する。
◎
If x is negative, throws a "NotSupportedError" DOMException.
</span> */
  double computeSquareRoot(double %x);
};
</pre>

<p>
`computeSquareRoot()^M ~methを異なる`~Realm$に属する `MathUtils^T ~objに適用した場合に投出される例外は、~objではなく，~methの`~Realm$に属する：
◎
If we apply computeSquareRoot to a MathUtils object from a different Realm, then the exception thrown will be from the Realm of the method, not the object it is applied to:
</p>

<pre class="es-code">
const %myMU = window.getMathUtils();          /* <span class="comment">
この~Realmに属する `MathUtils^T
◎
A MathUtils object from this Realm
</span> */
const %otherMU = otherWindow.getMathUtils();  /* <span class="comment">
異なる~Realmに属する `MathUtils^T
◎
A MathUtils object from a different Realm
</span> */

%myMU instanceof Object;                      /* <!--cp-eval-true--> */
%otherMU instanceof Object;                   /* <!--cp-eval-false--> */
%otherMU instanceof otherWindow.Object;       /* <!--cp-eval-true--> */

try {
  %otherMU.doComputation.call(%myMU, -1);
} catch (%e) {
  console.assert(!(%e instanceof DOMException));
  console.assert(%e instanceof otherWindow.DOMException);
}
</pre>

</div>

			</section>
			<section id="es-handling-exceptions">
<h4 title="Handling exceptions">3.12.4. 例外の取扱い</h4>

<p>
他が指定されない限り、この文書の要件に因り~ES~runtime意味論が呼出され，例外の投出により終端されたときは、その例外は~call元まで（そこで~catchされない場合は更にその~call元まで，等々）伝播し~MUST。
◎
Unless specified otherwise, whenever ECMAScript runtime semantics are invoked due to requirements in this document and end due to an exception being thrown, that exception must propagate to the caller, and if not caught there, to its caller, and so on.
</p>

<p>
<a href="#conventions" >文書~規約</a>により，この文書に指定される~algoは、［
`例外が投出された@
ときにとる正確な手続きを指定するか, または
`中途完了$を明示的に取扱う
］ことにより，投出された例外を~~捕えることもある。
◎
Per Document conventions, an algorithm specified in this document may intercept thrown exceptions, either by specifying the exact steps to take if an exception was thrown, or by explicitly handling abrupt completions.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの`~ifc$と 1 つの`例外$を定義する。
`ExceptionThrower^T 上の `valueOf^M 属性は、その値の取得-が試みられたときに常に例外を投出するように定義されている。
◎
The following IDL fragment defines two interfaces and an exception. The valueOf attribute on ExceptionThrower is defined to throw an exception whenever an attempt is made to get its value.
</p>

<pre class="webidl">
interface Dahut {
  attribute DOMString type;
};

interface ExceptionThrower {
  /* <span class="comment">
この属性は常に `NotSupportedError$E を投出し，決して値を返さない。
◎
This attribute always throws a NotSupportedError and never returns a value.
</span> */
  attribute long valueOf;
};
</pre>

<p>
~ES実装がこの~ifcを~supportしているとするとき、例外は次の~codeに従って取扱われる：
◎
Assuming an ECMAScript implementation supporting this interface, the following code demonstrates how exceptions are handled:
</p>

<pre class="es-code">
var %d = getDahut();              /* <span class="comment">
`Dahut^T の~instanceを得る。
◎
Obtain an instance of Dahut.
</span> */
var %et = getExceptionThrower();  /* <span class="comment">
`ExceptionThrower^T の~instanceを得る。
◎
Obtain an instance of ExceptionThrower.
</span> */

try {
  %d.type = { toString: function() { throw "abc"; } };
} catch (%e) {
  /* <span class="comment">
文字列 `abc^l はここで~catchされる。
何故なら、~native~objから文字列への変換の一環として匿名~関数が呼出され，
`DefaultValue^sl, ToPrimitive, ToString のいずれの~algoも，例外を~catchするように定義されていないので。
◎
The string "abc" is caught here, since as part of the conversion from the native object to a string, the anonymous function was invoked, and none of the [[DefaultValue]], ToPrimitive or ToString algorithms are defined to catch the exception.
</span> */
}

try {
  %d.type = { toString: { } };
} catch (%e) {
  /* <span class="comment">
例外はここで~catchされる。
toString ~propの値である~native~obj上で `Call^sl の呼出しが試みられるので。
◎
An exception is caught here, since an attempt is made to invoke [[Call]] on the native object that is the value of toString property.
</span> */
}

try {
  %d.type = Symbol();
} catch (%e) {
  /* <span class="comment">
例外はここで~catchされる。
`Symbol^jt 値~上で~ES `ToString$A 抽象~演算を呼出そうと試みられるので。
◎
An exception is caught here, since an attempt is made to invoke the ECMAScript ToString abstract operation on a Symbol value.
</span> */
}

%d.type = %et;
  /* <span class="comment">
~catchされなかった `NotSupportedError$E は ここで投出される。
`DefaultValue^sl ~algoは， `ExceptionThrower^T ~obj上の `valueOf^l ~propの値の取得-を試みるので。
例外はこの~code~blockの外へ伝播する。
◎
An uncaught "NotSupportedError" DOMException is thrown here, since the
[[DefaultValue]] algorithm attempts to get the value of the "valueOf" property on the ExceptionThrower object. The exception propagates out of this block of code.
</span> */
</pre>

</div>

			</section>
		</section>
	</section>
	<section id="common">
<h2 title="Common definitions">4. 共通の定義</h2>


<p>
この節では、すべての`適合~実装$が~supportし~MUST，いくつかの共通の定義を指定する。
◎
This section specifies some common definitions that all conforming implementations must support.
</p>

		<section id="ArrayBufferView">
<h3>4.1. `ArrayBufferView^T</h3>

<pre class="idl">
typedef (`Int8Array$T or `Int16Array$T or `Int32Array$T or
         `Uint8Array$T or `Uint16Array$T or `Uint32Array$T or `Uint8ClampedArray$T or
         `Float32Array$T or `Float64Array$T or `DataView$T) `ArrayBufferView$;
</pre>

<p>
`ArrayBufferView^T ~typedefは、
`ArrayBuffer$T 上の~viewを提供する~objを表現するために利用される。
◎
The ArrayBufferView typedef is used to represent objects that provide a view on to an ArrayBuffer.
</p>


		</section>
		<section id="BufferSource">
<h3>4.2. `BufferSource^T</h3>

<pre class="idl">
typedef (`ArrayBufferView$T or `ArrayBuffer$T) `BufferSource$;
</pre>


<p>
`BufferSource^T ~typedefは、
`ArrayBuffer$T ~obj自身, または
`ArrayBuffer$T 上の~viewを提供する~objを表現するために利用される。
◎
The BufferSource typedef is used to represent objects that are either themselves an ArrayBuffer or which provide a view on to an ArrayBuffer.
</p>


		</section>
		<section id="idl-DOMException">
<h3>4.3. `DOMException^T</h3>

<p>
`DOMException$T 型は、次の~IDL片により定義される`~ifc型$である：
◎
The DOMException type is an interface type defined by the following IDL fragment:
</p>

<!-- 
id="dom-domexception-domexception-message-name-message"
id="dom-domexception-domexception-message-name-name
-->
<pre class="webidl">
[
 Exposed=(Window,Worker),
  <a href="#dom-domexception-domexception">Constructor</a>(optional `DOMString$T %message = "", optional `DOMString$T %name = "Error")
]
interface `DOMException$T { /* <span class="comment">
~ES言語束縛についての下の注記も見よ。
◎
but see below note about ECMAScript binding
</span> */
  readonly attribute `DOMString$T `name$M;
  readonly attribute `DOMString$T `message$M;
  readonly attribute `unsigned short$T `code$M;

  const `unsigned short$T `INDEX_SIZE_ERR$Ec = 1;
  const `unsigned short$T `DOMSTRING_SIZE_ERR$Ec = 2;
  const `unsigned short$T `HIERARCHY_REQUEST_ERR$Ec = 3;
  const `unsigned short$T `WRONG_DOCUMENT_ERR$Ec = 4;
  const `unsigned short$T `INVALID_CHARACTER_ERR$Ec = 5;
  const `unsigned short$T `NO_DATA_ALLOWED_ERR$Ec = 6;
  const `unsigned short$T `NO_MODIFICATION_ALLOWED_ERR$Ec = 7;
  const `unsigned short$T `NOT_FOUND_ERR$Ec = 8;
  const `unsigned short$T `NOT_SUPPORTED_ERR$Ec = 9;
  const `unsigned short$T `INUSE_ATTRIBUTE_ERR$Ec = 10;
  const `unsigned short$T `INVALID_STATE_ERR$Ec = 11;
  const `unsigned short$T `SYNTAX_ERR$Ec = 12;
  const `unsigned short$T `INVALID_MODIFICATION_ERR$Ec = 13;
  const `unsigned short$T `NAMESPACE_ERR$Ec = 14;
  const `unsigned short$T `INVALID_ACCESS_ERR$Ec = 15;
  const `unsigned short$T `VALIDATION_ERR$Ec = 16;
  const `unsigned short$T `TYPE_MISMATCH_ERR$Ec = 17;
  const `unsigned short$T `SECURITY_ERR$Ec = 18;
  const `unsigned short$T `NETWORK_ERR$Ec = 19;
  const `unsigned short$T `ABORT_ERR$Ec = 20;
  const `unsigned short$T `URL_MISMATCH_ERR$Ec = 21;
  const `unsigned short$T `QUOTA_EXCEEDED_ERR$Ec = 22;
  const `unsigned short$T `TIMEOUT_ERR$Ec = 23;
  const `unsigned short$T `INVALID_NODE_TYPE_ERR$Ec = 24;
  const `unsigned short$T `DATA_CLONE_ERR$Ec = 25;
};
</pre>

<p class="note">注記：
`es-DOMException-specialness$secにて論じたように，~ES言語束縛は
`~ifc型$に対する通常のものを超える追加の要件を課す。
◎
Note: as discussed in §3.12.1 DOMException custom bindings, the ECMAScript binding imposes additional requirements beyond the normal ones for interface types.
</p>


<p>
各 `DOMException$T ~objには、
`名前@eX,
`~message@eX
が結付けられる。
いずれも`~JS文字列$とする。
◎
Each DOMException object has an associated name and message, both JavaScript strings.
</p>

<dl class="idl-def">
	<dt><dfn id="dom-domexception-domexception"><code class="idlmember">DOMException(%message, %name)</code></dfn></dt>
	<dd>
<p>
この構築子の被呼出時には、次を走らせ~MUST：
◎
The DOMException(message, name) constructor, when invoked, must run these steps:
</p>
		<ol>
			<li>
%e ~LET 新たな `DOMException$T ~obj
◎
Let e be a new DOMException object.
</li>
			<li>
%e の`名前$eX ~SET %name
◎
Set e’s name to name.
</li>
			<li>
%e の`~message$eX ~SET %message
◎
Set e’s message to message.
</li>
			<li>
~RET %e
◎
Return e.
</li>
		</ol>
</dd>

	<dt>`name@M</dt>
	<dd>
取得子は、この `DOMException$T ~objの`名前$eXを返さ~MUST。
◎
The name attribute’s getter must return this DOMException object’s name.
</dd>

	<dt>`message@M</dt>
	<dd>
取得子は、この `DOMException$T ~objの`~message$eXを返さ~MUST。
◎
The message attribute’s getter must return this DOMException object’s message.
</dd>

	<dt>`code@M</dt>
	<dd>
取得子は、`~error名~一覧$内に，この `DOMException$T ~objの`名前$eXに対応する旧来の~codeが［
あれば それ ／
なければ 0
］を返さ~MUST。
◎
The code attribute’s getter must return the legacy code indicated in the error names table for this DOMException object’s name, or 0 if no such entry exists in the table.
</dd>
</dl>

		</section>
		<section id="DOMTimeStamp">
<h3>4.4. `DOMTimeStamp^T</h3>


<pre class="idl">
typedef `unsigned long long$T `DOMTimeStamp$;
</pre>

<p>
`DOMTimeStamp^T 型は、ミリ秒数を表現するために利用される。
（何らかの起点に相対的な）絶対的な時間として，または相対的な時間差として。
この型を利用する仕様は、ミリ秒数の解釈され方も定義する必要がある。
◎
The DOMTimeStamp type is used for representing a number of milliseconds, either as an absolute time (relative to some epoch) or as a relative amount of time. Specifications that use this type will need to define how the number of milliseconds is to be interpreted.
</p>
		</section>
		<section id="Function">
<h3>4.5. `Function^T</h3>


<pre class="idl">
callback `Function$ = any (any... %arguments);
</pre>

<p>
`Function^T `呼戻~関数$型は、渡される引数や返値の種類に制約のない関数~値を表現するために利用される。
◎
The Function callback function type is used for representing function values with no restriction on what arguments are passed to it or what kind of value is returned from it.
</p>
		</section>
		<section id="VoidFunction">
<h3>4.6. `VoidFunction^T</h3>


<pre class="idl">
callback `VoidFunction$ = void ();
</pre>

<p>
`VoidFunction^T `呼戻~関数$型は
引数をとらず, 値を返さない関数~値を表現するために利用される。
◎
The VoidFunction callback function type is used for representing function values that take no arguments and do not return any value.
</p>
		</section>
	</section>
	<section id="extensibility">
<h2 title="Extensibility">5. 拡張性</h2>

~INFORMATIVE

<p>
言語束縛の要件に対する拡張は、この文書~内で定義される拡張属性と競合しない`拡張属性$を利用して指定できる。
［
私的な~projectに特有の利用
］のための拡張は、他の仕様に現れる`~IDL片$に含められるべきではない。
他の仕様の用途に要求される拡張は、この文書の将来~versionに取り込まれるためには，
<cite>Web IDL</cite> の担当グループ（この文書が書かれた時点では
<a href="http://www.w3.org/WebPlatform/WG/">W3C Web Platform Working Group</a>
）による~~調整を通すことが推奨される。
◎
Extensions to language binding requirements can be specified using extended attributes that do not conflict with those defined in this document. Extensions for private, project-specific use should not be included in IDL fragments appearing in other specifications. It is recommended that extensions that are required for use in other specifications be coordinated with the group responsible for work on Web IDL, which at the time of writing is the W3C Web Platform Working Group, for possible inclusion in a future version of this document.
</p>

<p>
この~IDL言語の他の側面は、拡張しないことが強く奨励される。
◎
Extensions to any other aspect of the IDL language are strongly discouraged.
</p>
	</section>
	<section id="referencing">
<h2 title="Referencing this specification">6. この仕様を参照するとき</h2>

~INFORMATIVE

<p>
一つ以上の`~IDL片$を利用して~Web~platform~ifcを定義する他の仕様は、この仕様を参照することになるものと期待されている。
それらの仕様には、~IDLが この仕様の記述に従って解釈されることを指示する，次の様な~~文を含ませることを勧める：
◎
It is expected that other specifications that define Web platform interfaces using one or more IDL fragments will reference this specification. It is suggested that those specifications include a sentence such as the following, to indicate that the IDL is to be interpreted as described in this specification:
</p>

<blockquote>
この仕様における各~IDL片は、この仕様が規範とする参照文献にて定義される~IDL片とともに，［
“~Web~IDL” 仕様に述べられる， <em>`適合~IDL片の集合$</em> に課される要件
］に従って、解釈され~MUST。<!--  -->
<a class="placeholder">[WEBIDL]</a>
◎
The IDL fragment in Appendix A of this specification must, in conjunction with the IDL fragments defined in this specification’s normative references, be interpreted as required for conforming sets of IDL fragments, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

<p>
加えて、この仕様を参照する仕様における，~UAのための適合性クラスは、この仕様の
`適合~実装$クラスを参照することを勧める：
◎
In addition, it is suggested that the conformance class for user agents in referencing specifications be linked to the conforming implementation class from this specification:
</p>

<blockquote>
適合 FooML ~UAは、 “~Web~IDL” 仕様の記述に則り，この仕様に示されている各~IDL片に対しても <em>`適合~実装$</em> で~MUST。
<a class="placeholder">[WEBIDL]</a>
◎
A conforming FooML user agent must also be a conforming implementation of the IDL fragment in Appendix A of this specification, as described in the “Web IDL” specification. [WEBIDL]
</blockquote>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">7. 謝辞</h2>

~INFORMATIVE

<p>
編集者は、この仕様に~~寄与された，次の方々に感謝する：
</p>

<p lang="en-x-a0">
The editor would like to thank the following people for contributing
to this specification:

Glenn Adams,
David Andersson,
L.&nbsp;David Baron,
Art Barstow,
Nils Barth,
Robin Berjon,
David Bruant,
Jan-Ivar Bruaroey,
Marcos Cáceres,
Giovanni Campagna,
Domenic Denicola,
Chris Dumez,
Michael Dyck,
Brendan Eich,
João Eiras,
Gorm Haug Eriksen,
Sigbjorn Finne,
David Flanagan,
Aryeh Gregor,
Tiancheng “Timothy” Gu,
Dimitry Golubovsky,
James Graham,
Aryeh Gregor,
Kartikaya Gupta,
Marcin Hanclik,
Jed Hartman,
Stefan Haustein,
Dominique Hazaël-Massieux,
Ian Hickson,
Björn Höhrmann,
Kyle Huey,
Lachlan Hunt,
Oliver Hunt,
Jim Jewett,
Wolfgang Keller,
Anne van Kesteren,
Olav Junker Kjær,
Takayoshi Kochi,
Magnus Kristiansen,
Takeshi Kurosawa,
Yves Lafon,
Travis Leithead,
Jim Ley,
Kevin Lindsey,
Jens Lindström,
Peter Linss,
呂康豪 (Kang-Hao Lu),
Kyle Machulis,
Mark Miller,
Ms2ger,
Andrew Oakley,
岡坂&nbsp;史紀 (Shiki Okasaka),
Jason Orendorff,
Olli Pettay,
Simon Pieters,
Andrei Popescu,
François Remy,
Tim Renouf,
Tim Ruffles,
Alex Russell,
Takashi Sakamoto,
Doug Schepers,
Jonas Sicking,
Garrett Smith,
Geoffrey Sneddon,
Jungkee Song,
Josh Soref,
Maciej Stachowiak,
Anton Tayanovskyy,
Peter Van der Beken,
Jeff Walden,
Allen Wirfs-Brock,
Jeffrey Yasskin and,
Collin Xu.
</p>

<p>
編集者が休みの間、この文書を保守されていた Sam Weinig に特別な謝意を。
◎
Special thanks also go to Sam Weinig for maintaining this document while the editor was unavailable to do so.
</p>
	</section>
	<section id="idl-grammar">
<h2 title="IDL grammar">~IDL文法</h2>

<p>
この節では、開始~記号 `Definitions$g が`~IDL片$全体に合致する，
LL(1) 文法を定義する。
◎
This section defines an LL(1) grammar whose start symbol, Definitions, matches an entire IDL fragment.
</p>

<div class="p">
<p>
文法~内の各~生成規則には、その右側に 1 個~以上の記号の並びが示される：
</p>

<ul ><li>ε は、何もなしを指示する。
</li><li>等幅~fontで示される記号は、~literalによる終端記号である。
</li><li>大文字から始まり, 斜体で示される記号は、非~終端記号である。
</li><li>小文字から始まり, 斜体で示される記号は、次に示す正規表現に合致する終端記号である（Perl 5 `PERLRE$r の正規表現~構文を利用）。
</li></ul>

◎
Each production in the grammar has on its right hand side either a non-zero sequence of terminal and non-terminal symbols, or an epsilon (ε) which indicates no symbols. Symbols that begin with an uppercase letter are non-terminal symbols. Symbols in monospaced fonts are terminal symbols. Symbols in sans-serif font that begin with a lowercase letter are terminal symbols that are matched by the regular expressions (using Perl 5 regular expression syntax [PERLRE]) as follows:
</div>

<dl class="grammar" id="terminals">
<dt id="prod-integer">`integer^g</dt>
<dd>~SLASH<code>-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)</code>~SLASH</dd>

<dt id="prod-float">`float^g</dt>
<dd>~SLASH<code>-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)</code>~SLASH</dd>

<dt id="prod-identifier">`identifier^g</dt>
<dd>~SLASH<code>_?[A-Za-z][0-9A-Z_a-z-]*</code>~SLASH</dd>

<dt id="prod-string">`string^g</dt>
<dd>~SLASH<code>"[^"]*"</code>~SLASH</dd>

<dt id="prod-whitespace">`whitespace^g</dt>
<dd>~SLASH<code>[\t\n\r ]+</code>~SLASH</dd>

<dt id="prod-comment">`comment^g</dt>
<dd>~SLASH<code>\/\/.*|\/\*(.|\n)*?\*\/</code>~SLASH</dd>

<dt id="prod-other">`other^g</dt>
<dd>~SLASH<code>[^\t\n\r 0-9A-Za-z]</code>~SLASH</dd>

</dl>

<p>
~tok化は~Unicode文字~並び `UNICODE$r に対し演算する。
~tok化の際には、最長合致が利用され~MUST。
例えば，入力~textが
“<span class="input">a1</span>”
であるなら、それは 1 個の `identifier$g に~tok化され，
`identifier$g と `integer$g には分離されない。
最長合致が［
上に挙げた，名前を持つ終端記号の いずれか
］と［
文法~内の終端記号
］のいずれにも合致し得る場合、後者の終端記号に~tok化され~MUST。
したがって、入力~text
“<span class="input">long</span>”
は，
`identifier$g `long^l ではなく，引用符で括られた終端記号 `long^sym
として~tok化され、
“<span class="input">.</span>”
は，
`other$g
ではなく，引用符で括られた終端記号
`.^sym
として~tok化される。
◎
The tokenizer operates on a sequence of Unicode characters [UNICODE]. When tokenizing, the longest possible match must be used. For example, if the input text is “a1”, it is tokenized as a single identifier, and not as a separate identifier and integer. If the longest possible match could match one of the above named terminal symbols or one of the other terminal symbols from the grammar, it must be tokenized as the latter. Thus, the input text “long” is tokenized as the quoted terminal symbol long rather than an identifier called “long”, and “.” is tokenized as the quoted terminal symbol . rather than an other.
</p>

<p>
~IDL構文においては、文字の大小は，文法~内で利用される引用符で括られた終端記号と
`identifier$g 終端記号に利用される値の，いずれにおいても~~区別される。
したがって、例えば入力~text
“<span class="input">Const</span>”
は，終端記号 `const^sym ではなく `identifier$g として~tok化され、
`識別子$ `A^l を伴う`~ifc$は， `a^l を伴うそれとは別個になり、
また，`拡張属性$ `constructor^x が `Constructor$x 拡張属性に認識されることはない。
◎
The IDL syntax is case sensitive, both for the quoted terminal symbols used in the grammar and the values used for identifier terminals. Thus, for example, the input text “Const” is tokenized as an identifier rather than the terminal symbol const, an interface with identifier “A” is distinct from one named “a”, and an extended attribute [constructor] will not be recognized as the [Constructor] extended attribute.
</p>

<p>
`whitespace$g や `comment$g からなる任意~個数の終端記号が、構文解析される入力~textにおける，他のどの終端記号の合間にも、暗黙的に許容される。
それらの `whitespace$g や `comment$g は、構文解析-時には無視される。
◎
Implicitly, any number of whitespace and comment terminals are allowed between every other terminal in the input text being parsed. Such whitespace and comment terminals are ignored while parsing.
</p>


<p>
次の LL(1) 文法の開始~記号 `Definitions$g が`~IDL片$に合致する：
◎
The following LL(1) grammar, starting with Definitions, matches an IDL fragment:
</p>

<p class="trans-note">【
見出しをクリックするとその文法~記号の~~参照元が示される（上の終端記号の表も同様）。
】</p>

<!-- place holder for the over all grammar table -->
<div id="_p-grammar-table"></div>

<p class="note">注記：
非~終端記号 `Other$g は、
`(^sym, `)^sym,
`[^sym, `]^sym,
`{^sym, `}^sym,
`,^sym
を除く，任意の 1 個の終端記号に合致する。
◎
Note: The Other non-terminal matches any single terminal symbol except for (, ), [, ], {, } and ,.
</p>

<p>
非~終端記号 `ExtendedAttribute$g は，任意の空でない終端記号の並びに合致するが（丸括弧, 角括弧, 波括弧が対になっていて, かつ `,^sym ~tokがそれらの括弧対の間にのみ現れる限り）、それらの可能な並びのうち一部のみが
この仕様で定義される`拡張属性$に利用される —
これらの拡張属性に利用される構文については
`idl-extended-attributes$sec
を見よ。
◎
While the ExtendedAttribute non-terminal matches any non-empty sequence of terminal symbols (as long as any parentheses, square brackets or braces are balanced, and the , token appears only within those balanced brackets), only a subset of those possible sequences are used by the extended attributes defined in this specification — see §2.13 Extended attributes for the syntaxes that are used by these extended attributes.
</p>
	</section>
	<section id="conventions">
<h2 title="Document conventions">表記規約</h2>


<p>
この文書では、次の表記規約／~styleが利用される：
◎
The following typographic conventions are used in this document:
</p>

<p class="trans-note">【
“†” が付与されているものは、この訳による追加の~style。
】</p>

<ul>
	<li>
用語の定義：
`用語例@
◎
Defining instances of terms: example term
</li>
	<li>
この文書で定義される用語へのリンク：
`用語例$
◎
Links to terms defined in this document or elsewhere: example term
</li>
	<li>
他の文書で定義される用語へのリンク：
<a class="dfnref" href="https://triple-underscore.github.io/WebIDL-ja.html#dfn-example-term">example term</a>
◎
↑</li>
	<li>
文法の終端記号（~literal）：
`sometoken^sym
◎
Grammar terminals: sometoken
</li>
	<li>
文法の非~終端記号（先頭は大文字）：
`ExampleGrammarSymbol^g
◎
Grammar non-terminals: ExampleGrammarNonTerminal
</li>
	<li>
文法の終端記号（生成規則, 先頭は小文字）： `identifier^g
◎
Grammar symbols: identifier
</li>
	<li>
~IDL型：`unsigned long^T
◎
IDL types: unsigned long
</li>
	<li>
~IDL~ifc~mb：`ExampleIDLMember^M†,<br>
~IDL値：`ExampleIDLValue^V†
</li>
	<li>
~ES~class： `Map^t
◎
ECMAScript classes: Map
</li>
	<li>
~ES言語~型：`Object^jt
◎
ECMAScript language types: Object
</li>
	<li>
~ES値：`undefined^jv†
</li>
	<li>
~ES内部［~prop／~meth／~slot］： `ExamplePropertyOrMethodOrSlot^sl
†
</li>
	<li>
~ES抽象~演算：
<a class="abstract">ExampleAbstractOperation</a>
†
</li>
<!-- 
~ES~obj~mb：ExampleESMember^m
-->


	<li>
~code片：
`a = b + obj.f()^c
◎
Code snippets: a = b + obj.f()
</li>
	<li>
~Unicode文字：
`U+0030 DIGIT ZERO ("0")^char
◎
Unicode characters: U+0030 DIGIT ZERO ("0")
</li>
	<li>
拡張属性：
`ExampleExtendedAttribute^x
◎
Extended attributes: [ExampleExtendedAttribute]
</li>
	<li>
注釈文や~algoにおける変数~名：
%exampleVariableName
◎
Variable names in prose and algorithms: exampleVariableName.
</li>
	<li>
文字列~literal：
`example string literal^l
†
</li>
	<li>
モデルを定義するために利用される仮想の定数~値：
`定数~例^C
†
</li>
	<li>
<p>
~IDL構文の参考例：
◎
IDL informal syntax examples:
</p>

<pre class="syntax">
interface `identifier^mk {
  /* interface_members... */
};
</pre>

<p>
（周囲の注釈文の中で論じられている構文は， mark 要素で`強調される^mk（~styleは~browserに依存する）。）
◎
(Specific parts of the syntax discussed in surrounding prose are highlighted.)
</p>
	</li>
	<li>
<p>
~IDL文法~片：
◎
IDL grammar snippets:
</p>

<dl class="grammar">
	<dt>`ExampleGrammarNonTerminal^g</dt>
	<dd>`OtherNonTerminal^g `sometoken^sym
`other$g `AnotherNonTerminal^g
ε  // <span title="nothing">nothing</span></dd>
</dl>

	</li>
	<li>
<p>
規範的でない注記：
◎
Non-normative notes:
</p>

<p class="note">注記：
これは注記。
◎
Note: This is a note.
</p>
	</li>
	<li>
<p>
規範的でない例：
◎
Non-normative examples:
</p>

<div class="example">
<p>
これは例。
◎
This is an example.
</p>
</div>
	</li>
	<li>
<p>
規範的な警告：
◎
Normative warnings:
</p>

<p class="advisement">
これは警告。
◎
This is a warning.
</p>

	</li>
	<li>
<p>
~code~block：
◎
Code blocks:
</p>

<pre class="webidl">
/* <span class="comment">
これは~IDL~code~block。
◎
This is an IDL code block.
</span> */
interface Example {
  attribute long something;
};
</pre>

<pre class="es-code">
/* <span class="comment">
これは~ES~code~block。
◎
This is an ECMAScript code block.
</span> */
window.onload = function() { window.alert("loaded"); };
</pre>

</li>
</ul>

<p>
この文書の~algoでは、次の規約が利用される：
◎
The following conventions are used in the algorithms in this document:
</p>

<ul>
	<li>
~ES`完了record$（ Completion Record ）を unwrap するための
<a href="~TC39#sec-returnifabrupt-shorthands">"!" や "?" を接頭する記法</a>
も含め，
<a href="~TC39#sec-algorithm-conventions">~ES仕様の規約</a>
を利用する。
◎
Algorithms use the conventions of the ECMAScript specification, including the ! and ? notation for unwrapping Completion Records.
</li>
	<li>
~algoは、［
値を返す／例外を投出する
］ことと，`完了record$を返すことを交換可能に扱うこともある。
すなわち、［
~RET／`~THROW$
を利用する~algo
］は［
`完了record$を返している
］ものと扱われることもあれば、`完了record$を返すものは［
値を返している／例外を投出している
］ものと扱われることもある。
同様に，例外を~catchする際に、［
投出された例外を受け入れる挙動を定義すること
］と, ［［
`完了record$の `Type^sl ~field ~EQ `throw^i
］かどうか検査すること
］とは、等価になる。
◎
Algorithms sometimes treat returning/throwing values and returning Completion Records interchangeably. That is, an algorithm that uses return/throw terminology may be treated as returning a Completion Record, while one that returns a Completion Record may be treated as returning a value or throwing an exception. Similarly, to catch exceptions, defining the behavior to adopt when an exception was thrown and checking if the Completion Record’s [[Type]] field is “throw” are equivalent.
</li>
	<li>
`完了record$は、~Web~IDL値などの~ES値でない値も包含できるよう，拡張された値である。
◎
Completion Records are extended by allowing them to contain values that are not ECMAScript values, such as Web IDL values.
</li>
</ul>

	</section>
	<section id="conformance">
<h2 title="Conformance">適合性</h2>


<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#conformance">W3C 日本語訳 共通ページ</a>
に委譲
】</p>

<p>
この仕様では、次に挙げるものが適合性クラスとして定義される：
◎
The following conformance classes are defined by this specification:
</p>

<dl>
	<dt>
`適合~IDL片の集合@
◎
conforming set of IDL fragments
</dt>
	<dd>
`~IDL片$の集合は、全体として，この仕様にて~IDL片に適用される［
“〜~MUST_NOT” , “要求される” <!-- , “〜SHALL”  -->
~levelの判定基準
］をすべて満たすとき，`適合~IDL片の集合$になる。
◎
A set of IDL fragments is considered to be a conforming set of IDL fragments if, taken together, they satisfy all of the must-, required- and shall-level criteria in this specification that apply to IDL fragments.
</dd>

	<dt>
`適合~実装@
◎
conforming implementation
</dt>
	<dd>
~UAは、自身が~supportするすべての言語束縛において，この仕様により その実装に適用される，すべての
“〜~MUST_NOT” , “要求される” <!-- , “〜SHALL”  -->
~levelの判定基準を満たすとき，
`適合~IDL片の集合$に対する`適合~実装$であるとされる。
◎
A user agent is considered to be a conforming implementation relative to a conforming set of IDL fragments if it satisfies all of the must-, required- and shall-level criteria in this specification that apply to implementations for all language bindings that the user agent supports.
</dd>
	<dt>
`適合~ES実装@
◎
conforming ECMAScript implementation
</dt>
	<dd>
~UAは、この仕様にて~ES言語束縛の実装に適用されるすべての
“〜~MUST_NOT” , “要求される” <!-- , “〜SHALL”  -->
~levelの判定基準を満たすとき，
`適合~IDL片の集合$に対する`適合~ES実装$であるとされる。
◎
A user agent is considered to be a conforming ECMAScript implementation relative to a conforming set of IDL fragments if it satisfies all of the must-, required- and shall-level criteria in this specification that apply to implementations for the ECMAScript language binding.
</dd>

</dl>


	</section>

</main></div><!-- MAIN -->
