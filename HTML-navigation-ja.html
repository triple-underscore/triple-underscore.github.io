<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Navigation and session history（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>

.jake-diagram {
  border-style: hidden none hidden hidden;
  table-layout: fixed;
  background: Canvas;
  color: CanvasText;
}

.jake-diagram, .jake-diagram :is(td, th, tr) {
  border-color: CanvasText;
}

.jake-diagram :where(th.step) {
  width: 95px;
  font-weight: normal;
}

.jake-diagram th:not(.step) {
  text-align: right;
}

.jake-diagram td.next-is-same-doc {
  border-right: dotted 2px;
}

.jake-diagram td.prev-is-same-doc {
  border-left: dotted 2px;
}

.jake-diagram .current {
  font-style: italic;
  font-weight: bold;
}

.jake-diagram .doc-0 {
  background: var(--Y-bg);
}

.jake-diagram .doc-1 {
  background: var(--O-bg);
}

.jake-diagram .doc-2 {
  background: var(--G-bg);
}

.jake-diagram .doc-3 {
  background: var(--B-bg);
}

.jake-diagram .doc-4 {
  background: var(--V-bg);
}

.jake-diagram .doc-5 {
  background: var(--R-bg);
}

.jake-diagram code {
	color: CanvasText;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 'hm': // HTTP method
	text = `\`<code class="method">${key}</code>\``;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-09-25
trans_update:2025-09-29
source_checked:250801
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/browsing-the-web.html
	abbr_url:NAVI
site_nav:browsers,network,html
nav_prev:HTMLds
nav_next:HTMLlifecycle
trans_1st_pub:2017-01-01


●●class_map
e:element
a:attr
aF:attr
et:event-type
sc:scheme
E:error
ps:pseudo
jv:js-value
sl:js-slot
jA:abstract
jt:js-type
v:value
st:attr-state
hst:status

●●tag_map
I:code
m:code
mPSe:code
mPRe:code
c:code
e:code
a:code
aF:code
sc:code
et:code
E:code
ps:code
sl:span
jA:span
jv:code
jt:code
st:i
hst:code
v:code
mt:code
V:var
i:i
wBDst:i
sub:sub
cite:cite
em:em


●●original_id_map

	旧 id
	navigationhistorybehavior-replace:hh-replace
	navigationhistorybehavior-push:hh-default
	navigationhistorybehavior-push:hh-push

	populating-a-session-history-entry:history-traversal
	populating-a-session-history-entry:traverse-the-history
	navigation-and-session-history:history
	session-history-infrastructure:the-session-history-of-browsing-contexts
	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts
	restore-persisted-state:restore-persisted-user-state
	she-other:an-entry-with-persisted-user-state
	document-state-nav-target-name:she-bc-name
	document-state-history-policy-container:she-policy-container
	navigating-across-documents:browsing-the-web
	apply-the-history-step:update-the-session-history-with-the-new-page
	session-history-traversal-parallel-queue:session-history-traversal-queue
	ongoing-navigation:concept-navigate-mature
	checking-if-unloading-is-canceled:prompt-to-unload
	checking-if-unloading-is-canceled:prompt-to-unload-a-document
	checking-if-unloading-is-canceled:checking-if-unloading-is-user-canceled
	she-classic-history-api-state:she-serialized-state

	引数
	traverse-the-history-by-a-delta:traverse-sourcedocument
	reload:reload-navigation-api-state
	reload:reload-user-involvement

●●mdn_urls
●●link_map

	●idl/ code
E.SecurityError:~WEBIDL#securityerror
I.Event:~DOM4#interface-event
I.BeforeUnloadEvent:~WINDOW#beforeunloadevent
	I.DOMException:~WEBIDL#dfn-DOMException
	I.Document:~HTMLdom#document → 文書
文書:~HTMLdom#the-document-object
	I.Element:~DOM4#interface-element → 要素
要素:~DOM4#concept-element

I.HashChangeEvent:~WINDOW#hashchangeevent
I.NavigateEvent:~HTMLnavAPI#navigateevent
I.Navigation:~HTMLnavAPI#navigation
I.NavigationActivation:~HTMLnavAPI#navigationactivation
I.NavigationType:~HTMLnavAPI#navigationtype
I.NavigationHistoryEntry:~HTMLnavAPI#navigationhistoryentry
I.NavigationHistoryBehavior:~HTMLnavAPI#navigationhistorybehavior
I.NavigationTimingType:~NAV-TIMING#dom-navigationtimingtype
I.PageRevealEvent:~HTMLnavAPI#pagerevealevent
I.PageSwapEvent:~HTMLnavAPI#pageswapevent
I.PopStateEvent:~WINDOW#popstateevent
I.ViewTransition:~CSSVT#viewtransition
I.VisibilityStateEntry:~HTMLinteraction#visibilitystateentry
I.WindowProxy:~HTMLWPROXY#windowproxy
sl.Window:~HTMLWPROXY#concept-windowproxy-window

m.cancelable:~DOM4#dom-event-cancelable
m.type:~DOM4#dom-event-type
m.isTrusted:~DOM4#dom-event-istrusted
mPRe.viewTransition:~HTMLnavAPI#dom-pagerevealevent-viewtransition
mPSe.activation:~HTMLnavAPI#dom-pageswapevent-activation
mPSe.viewTransition:~HTMLnavAPI#dom-pageswapevent-viewtransition

c.history.pushState():~WINDOW#dom-history-pushstate
c.history.replaceState():~WINDOW#dom-history-replacestate

	＠~WINDOW#dom-history-state
	＠~WINDOW#dom-beforeunloadevent-returnvalue
	＠~WINDOW#dom-location-href
	＠~WINDOW#dom-location-assign
	＠~WINDOW#dom-history-back
	＠~WINDOW#dom-window-open
	＠~WINDOW#dom-history-go
	＠~WINDOW#dom-hashchangeevent-newurl
	＠~WINDOW#dom-hashchangeevent-oldurl
	＠~WINDOW#dom-popstateevent-state
	＠~HTMLnavAPI#dom-navigateevent-scroll
	＠~HTMLnavAPI#dom-navigation-navigate
	＠~HTMLnavAPI#dom-navigationnavigateoptions-state
	＠~HTMLnavAPI#dom-navigationtransition-finished

l.auto:#dom-scrollrestoration-auto
l.manual:#dom-scrollrestoration-manual
l.push:~HTMLnavAPI#dom-navigationtype-push
l.replace:~HTMLnavAPI#dom-navigationtype-replace
l.reload:~HTMLnavAPI#dom-navigationtype-reload
l.traverse:~HTMLnavAPI#dom-navigationtype-traverse
l.navigate:~NAV-TIMING#dom-navigationtimingtype-navigate
	＠:~NAV-TIMING#dom-navigationtimingtype-reload
	＠~NAV-TIMING#dom-navigationtimingtype-back_forward
l.unsafe-none:~ORIGIN#coop-unsafe-none

sc.~about_blank:~HTMLdep#about:blank
sc.~about_srcdoc:~HTMLurl#about:srcdoc
sc.~javascript0:#the-javascript:-url-special-case
l.javascript:#the-javascript:-url-special-case

l.navigation-failure:~WINDOW#blocking-navigation-failure
l.masked:~WINDOW#blocking-masked

e.a:~HEtextlevel#the-a-element
e.div:~HEgrouping#the-div-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.input:~HEinput#the-input-element
e.object:~HEembed#the-object-element
e.textarea:~HEforms#the-textarea-element

a.id:~HTMLdom#the-id-attribute
a.dir:~HTMLdom#attr-dir
a.type:~HEinput#attr-input-type
aF.name:~HEembed#attr-iframe-name
aF.src:~HEembed#attr-iframe-src
aF.srcdoc:~HEembed#attr-iframe-srcdoc

et.beforeunload:~HTMLindex#event-beforeunload
et.change:~HTMLindex#event-change
et.click:~UIEVENTS#event-type-click
et.hashchange:~HTMLindex#event-hashchange
et.input:~UIEVENTS#event-type-input
et.navigate:~HTMLindex#event-navigate
et.navigateerror:~HTMLindex#event-navigateerror
et.pagereveal:~HTMLindex#event-pagereveal
et.pageshow:~HTMLindex#event-pageshow
et.pageswap:~HTMLindex#event-pageswap
et.popstate:~HTMLindex#event-popstate

h.Content-Type:~HTTPsem#field.content-type
	~Content-Type~metadata:~HTMLurl#content-type
h.Content-Disposition:https://httpwg.org/specs/rfc6266.html#header.field.definition
h.Cross-Origin-Opener-Policy:~ORIGIN#cross-origin-opener-policy-2
h.Location:~HTTPsem#field.location
h.Refresh:~HTMLsl#refresh
h.X-Frame-Options:~HTMLsl#x-frame-options

mt.application/atom+xml:~HTMLindex#application/atom+xml
mt.application/x-www-form-urlencoded:~URL1#concept-urlencoded
mt.multipart/form-data:~HTMLindex#multipart/form-data
mt.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
mt.text/css:~HTMLindex#text/css
mt.text/plain:~RFCx/rfc2046#section-4.1.3
	c.text/plain:~RFCx/rfc2046#section-4.1.3
mt.text/vtt:~HTMLindex#text/vtt
	＠~RFCx/rfc6068#section-2

hst.204:~HTTPsem#status.204
hst.205:~HTTPsem#status.205

v.allow-popups:~ORIGIN#attr-iframe-sandbox-allow-popups
v.allow-top-navigation-by-user-activation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-top-navigation-to-custom-protocols:~ORIGIN#attr-iframe-sandbox-allow-top-navigation-to-custom-protocols
v.allow-top-navigation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation
v.off:~HTMLautofill#attr-fe-autocomplete-off


ps.target:~HTMLselectors#selector-target

jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.StructuredSerializeForStorage:~HTMLcloning#structuredserializeforstorage

	●用語

~BF~cache:#_bf-cache
	~BF~cache:#note-bfcache

~navi~params:#navigation-params
nvP.~COOP施行n結果:#navigation-params-coop-enforcement-result
nvP.~ID:#navigation-params-id
nvP.~fetch制御器:#navigation-params-fetch-controller
nvP.~navigable:#navigation-params-navigable
nvP.~navi計時~種別:#navigation-params-nav-timing-type
nvP.予約-済み環境:#navigation-params-reserved-environment
nvP.応答:#navigation-params-response
nvP.施策~容器:#navigation-params-policy-container
nvP.早期~hintを~commitする:#navigation-params-commit-early-hints
nvP.最終-~sandbox~flag集合:#navigation-params-sandboxing
nvP.生成元:#navigation-params-origin
nvP.要請:#navigation-params-request
nvP.~opener施策:#navigation-params-coop
nvP.~about基底~URL:#navigation-params-about-base-url
nvP.利用者-関与i:#navigation-params-user-involvement

~navigableを変更している継続の状態:#changing-navigable-continuation-state
cnC.~navigable:#changing-nav-continuation-navigable
cnC.~target~entry:#changing-nav-continuation-target-entry
cnC.更新のみか:#changing-nav-continuation-update-only
cnC.表示される文書:#changing-nav-continuation-displayed-document

文書~状態:#document-state-2
dS.文書:#document-state-document
dS.履歴~施策~容器:#document-state-history-policy-container
dS.要請~referrer:#document-state-request-referrer
dS.要請~referrer施策:#document-state-request-referrer-policy
dS.起動元~生成元:#document-state-initiator-origin
dS.生成元:#document-state-origin
dS.~about基底~URL:#document-state-about-base-url
dS.入子な履歴~群:#document-state-nested-histories
dS.資源:#document-state-resource
dS.再読込みは処理待ちか:#document-state-reload-pending
dS.一度でも拡充されたか:#document-state-ever-populated
dS.~navigable名:#document-state-nav-target-name
dS.復旧されない事由~群:#document-state-not-restored-reasons

文書の復旧されない事由~群:~WINDOW#concept-document-nrr
doc.指示された部位:#the-indicated-part-of-the-document
指示された部位を選定する:#select-the-indicated-part

hH.replace:#navigationhistorybehavior-replace
hH.push:#navigationhistorybehavior-push
hH.auto:#navigationhistorybehavior-auto

入子な履歴:#nested-history
nH.~ID:#nested-history-id
nH.~entry群:#nested-history-entries

~POST資源:#post-resource
pR.要請~内容~型:#post-resource-request-content-type
pR.要請~本体:#post-resource-request-body

~session履歴~entry:#session-history-entry
shE.~URL:#she-url
shE.~scroll位置~data:#she-scroll-position
shE.~navi~API状態:#she-navigation-api-state
shE.~navi~API~key:#she-navigation-api-key
shE.~navi~API~ID:#she-navigation-api-id
shE.~scroll復旧~mode:#she-scroll-restoration-mode
shE.~step:#she-step
shE.持続される利用者~状態:#she-other
shE.文書:#she-document
shE.文書~状態:#she-document-state
shE.古典~履歴~API用の状態:#she-classic-history-api-state

前方~session履歴を~clearする:#clear-the-forward-session-history
~session履歴~entry群を取得する:#getting-session-history-entries

~session履歴~辿り並列~queue:#session-history-traversal-parallel-queue
shTP.~algo集合:#session-history-traversal-parallel-queue-algorithm-set
shTP.~target~navigable:#session-history-traversal-parallel-queue-sync-nav-steps-target-nav
shTP.同期的な~navi手続き:#session-history-traversal-parallel-queue-sync-nav-steps
~session履歴~同期~navi手続きを付加する:#tn-append-session-history-sync-nav-steps
	＠#tn-append-session-history-sync-nav-steps
~session履歴~辿り手続きを付加する:#tn-append-session-history-traversal-steps
新たな~session履歴~辿り並列~queueを開始する:#starting-a-new-session-history-traversal-parallel-queue

~source~snapshot~params:#source-snapshot-params
ssP.~downloadを許容するか:#source-snapshot-params-download
ssP.~fetch~client:#source-snapshot-params-client
ssP.~sandbox法~flag群:#source-snapshot-params-sandbox
ssP.~source施策~容器:#source-snapshot-params-policy-container
ssP.一過な作動化を有するか:#source-snapshot-params-activation

~source~snapshot~paramsを~snapshotする:#snapshotting-source-snapshot-params
~target~snapshot~paramsを~snapshotする:#snapshotting-target-snapshot-params

~target~snapshot~params:#target-snapshot-params
tsP.~sandbox法~flag群:#target-snapshot-params-sandbox

~URLと履歴の更新:#url-and-history-update-steps
~URLと履歴を更新する:#url-and-history-update-steps
	%直列形の~data:#uhus-serializeddata
	%履歴~取扱い:#uhus-historyhandling

~fetchingにより~navi~paramsを作成する:#create-navigation-params-by-fetching
	＠#create-navigation-params-by-fetching
~javascript_~URLへ~navigateする:#navigate-to-a-javascript:-url
~javascript_~URLを評価する:#evaluate-a-javascript:-url

~navigableを~URLへ~navigateする:#navigate
~navigate:#navigate
~navi:#navigate
~navi~algo:#navigate
	%応答:#navigation-response
	%履歴~取扱い:#navigation-hh
	%例外を可能化するか:#exceptions-enabled
	%文書~資源:#navigation-resource
	%~form~data~entry~list:#navigation-form-data-entry-list
	%~referrer施策:#navigation-referrer-policy
	%~navi~API状態:#navigation-navigation-api-state
	%利用者-関与i:#navigation-user-involvement
	%~source要素:#navigation-source-element
	%初期~挿入か:#navigation-initial-insertion

~naviに対する利用者-関与i:#user-navigation-involvement
~event用の~naviに対する利用者-関与i:#event-uni
i.作動化:#uni-activation
i.なし:#uni-none
i.~browser~UI:#uni-browser-ui

~naviは置換-になるモノトスルか？:#the-navigation-must-be-a-replace
~navigateすることは~sandbox法により許容され:#allowed-to-navigate
~navi~ID:#navigation-id

~scriptを走らせてもよい:#scripts-may-run-for-the-newly-created-document
~scroll復旧~mode:#scroll-restoration-mode

~srcdoc資源から~navi~paramsを作成する:#create-navigation-params-from-a-srcdoc-resource

~target履歴~entryを取得する:#getting-the-target-history-entry
~unloadは取消されたか否か検査する:#checking-if-unloading-is-canceled
履歴~objの長さか~indexの更新に限り必要になる~navigableをすべて取得する:#getting-all-navigables-that-only-need-history-object-length/index-update
現在の~session履歴~entryが変更されるか読込直される~navigableをすべて取得する:#get-all-navigables-whose-current-session-history-entry-will-change-or-reload
非同一-文書の辿りを経るかもしれない~navigableをすべて取得する:#getting-all-navigables-that-might-experience-a-cross-document-traversal
~navi~API用に~session履歴~entry群を取得する:#getting-session-history-entries-for-the-navigation-api
文書を作動中にする:#make-active
文書を作動化し直す:#reactivate-a-document
	＠#reactivate-a-document

非同一-文書~navi用に文書を非作動化する:#deactivate-a-document-for-a-cross-document-navigation
~pageswap_ev~eventを発火する:#fire-the-pageswap-event

利用された~stepを取得する:#getting-the-used-step
利用されたすべての履歴~stepを取得する:#getting-all-used-history-steps

外部~softwareに手渡す:#hand-off-to-external-software

拡充-:#attempt-to-populate-the-history-entry's-document
履歴~entryの文書を拡充するよう試みる:#attempt-to-populate-the-history-entry's-document
	%~POSTを許容するか:#attempt-to-populate-allow-post
	%完了~手続き:#attempt-to-populate-completion-steps

履歴~entryを作動化する:#activate-history-entry

履歴~objの長さと~indexを取得する:#getting-the-history-object-length-and-index
履歴~objの状態を復旧する:#restore-the-history-object-state

履歴~stepを適用する:#apply-the-history-step
辿-用に履歴~stepを適用することを再開する:#resume-applying-the-traverse-history-step
~navigableの作成／破壊~用に更新する:#update-for-navigable-creation/destruction
~push／置換-用に履歴~stepを適用する:#apply-the-push/replace-history-step
辿-用に履歴~stepを適用する:#apply-the-traverse-history-step
再読込み用に履歴~stepを適用する:#apply-the-reload-history-step

履歴~stepを適用するために文書を更新する:#update-document-for-history-step-application
履歴~取扱いの挙動:#history-handling-behavior
履歴を差分だけ辿る:#traverse-the-history-by-a-delta
	%~source文書:#traverse-sourcedocument

履歴の辿り:#traverse-the-history-by-a-delta

doc.利用者により~scrollされたか:#has-been-scrolled-by-the-user
doc.復旧-可能な~scroll可能な領域:#restorable-scrollable-regions
~scroll位置~dataを復旧する:#restore-scroll-position-data

履歴~entryから持続された状態を復旧する:#restore-persisted-state
履歴~entryに持続される状態を保存する:#save-persisted-state
指示された要素を見出す:#find-a-potential-indicated-element

i.文書の上端:#top-of-the-document
~target要素:#target-element

文書を読込む:#loading-a-document

明示的に~supportされる~JSON~MIME型:#explicitly-supported-json-mime-type
明示的に~supportされる~XML~MIME型:#explicitly-supported-xml-mime-type
最近の~entry:#latest-entry

直列形の状態:#serialized-state

~navigableを読込直す:#reload
	%~navi~API状態:#reload-navigation-api-state
	%利用者-関与i:#reload-user-involvement

進行中な~navi:#ongoing-navigation
進行中な~naviを設定する:#set-the-ongoing-navigation

非-~fetch~scheme~navi~params:#non-fetch-scheme-navigation-params
nfSnvP.~URL:#non-fetch-scheme-params-url
nfSnvP.~navigable:#non-fetch-scheme-params-navigable
nfSnvP.~target~snapshotの~sandbox法~flag群:#non-fetch-scheme-params-target-sandbox
nfSnvP.~source~snapshotは一過な作動化を有するか:#non-fetch-scheme-params-source-activation
nfSnvP.起動元~生成元:#non-fetch-scheme-params-initiator-origin
nfSnvP.~ID:#non-fetch-scheme-params-id
nfSnvP.~navi計時~種別:#non-fetch-scheme-params-nav-timing-type
nfSnvP.利用者-関与i:#non-fetch-scheme-params-user-involvement

非-~fetch~scheme文書を作成しようと試みる:#attempt-to-create-a-non-fetch-scheme-document
非同一-文書~naviを完結する:#finalize-a-cross-document-navigation

素片への~navi:#navigate-fragid
素片へ~navigateする:#navigate-fragid
素片へ~scrollするよう試行する:#try-to-scroll-to-the-fragment
素片へ~scrollする:#scroll-to-the-fragment-identifier

~beforeunload_evを発火する手続き:#steps-to-fire-beforeunload

文書を露呈する:#reveal
doc.露呈されたか:#has-been-revealed

文書を回復不能にする:#make-document-unsalvageable
文書~状態~用に復旧されない事由~群を築く:#build-not-restored-reasons-for-document-state
~top-level辿可能とその子孫~用に復旧されない事由~群を築く:#build-not-restored-reasons-for-a-top-level-traversable-and-its-descendants

	●用語（HTML


即時:~HTMLINFRA#immediately
並列~queue:~HTMLINFRA#parallel-queue
並列的:~HTMLINFRA#in-parallel
一意かつ内部的な値:~HTMLcms#unique-internal-value

~fallback基底~URL:~HTMLurl#fallback-base-url
文書~基底~URL:~HTMLurl#document-base-url
文書の~URLを設定する:~HTMLurl#set-the-url
~about_blank に合致して:~HTMLurl#matches-about:blank
~lazyに読込むことになる:~HTMLurl#will-lazy-load-element-steps
~lazyに読込んでいる要素の交差~観測ngを停止する:~HTMLurl#stop-intersection-observing-a-lazy-loading-element
~lazy読込n再開~手続き:~HTMLurl#lazy-load-resumption-steps
~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
	~HTMLurl#encoding-parsing-and-serializing-a-url → ~HTMLurl#encoding-parsing-a-url, ~URL1#concept-url-serializer

doc.初期~about_blankか:~HTMLdom#is-initial-about:blank
初期~about_blank な文書:~HTMLdom#is-initial-about:blank
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.現在の準備度:~HTMLdom#current-document-readiness
doc.~opener施策:~HTMLdom#concept-document-coop
doc.~about基底~URL:~HTMLdom#concept-document-about-base-url
doc.~BF~cacheを阻んでいる詳細:~HTMLdom#concept-document-bfcache-blocking-details
doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects
doc.読込ng中における~WebDriver-BiDi用の~navi~ID:~HTMLdom#concept-document-navigation-id

応答を~downloadとして取扱う:~HTMLlinks#handle-as-a-download
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2

~formに所有され得る~custom要素:~HEcustom#form-associated-custom-element

早期~hint:~HEmetadata#early-hints-2
早期~hint~header群を処理する:~HEmetadata#process-early-hint-headers

~autofill欄~名:~HTMLautofill#autofill-field-name
再設定-可能:~HEforms#category-reset

~objを~focusする:~HTMLinteraction#focusing-steps
連列的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
一過な作動化を有して:~HTMLinteraction#transient-activation
居残な作動化を有して:~HTMLinteraction#sticky-activation
doc.可視性~状態:~HTMLinteraction#visibility-state
~objを~focusする:~HTMLinteraction#focusing-steps
可視性~状態を更新する:~HTMLinteraction#update-the-visibility-state
連列的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
vsE.時刻印:~HTMLinteraction#visibilitystateentry-timestamp
vsE.可視性~状態:~HTMLinteraction#visibilitystateentry-state

先祖を露呈する:~HTMLinteraction#ancestor-revealing-algorithm

~iframe~srcdoc文書:~HEembed#an-iframe-srcdoc-document
処理待ちな資源~計時の開始~時刻:~HEembed#iframe-pending-resource-timing-start-time
~iframe~load~event手続き:~HEembed#iframe-load-event-steps


coOP.値:~ORIGIN#coop-struct-value
cooP.~URL:~ORIGIN#coop-enforcement-url
cooP.現在の文脈は~navi~sourceか:~ORIGIN#coop-enforcement-source
cooP.生成元:~ORIGIN#coop-enforcement-origin
cooP.~opener施策:~ORIGIN#coop-enforcement-coop

l.unsafe-none:~ORIGIN#coop-unsafe-none

pC.~CSP~list:~ORIGIN#policy-container-csp-list
pC.~referrer施策:~ORIGIN#policy-container-referrer-policy
pC.埋込元~施策:~ORIGIN#policy-container-embedder-policy
~CSPから導出される~sandbox法~flag群:~ORIGIN#csp-derived-sandboxing-flags
~fetch応答から施策~容器を作成する:~ORIGIN#creating-a-policy-container-from-a-fetch-response
生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
~navi~paramsの施策~容器を決定する:~ORIGIN#determining-navigation-params-policy-container
~navi応答の埋込元~施策に対する固守を検査する:~ORIGIN#check-a-navigation-response's-adherence-to-its-embedder-policy
~sandbox化( ~modal )~flag:~ORIGIN#sandboxed-modals-flag
~sandbox法~flag集合:~ORIGIN#sandboxing-flag-set
作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
作成時の~sandbox法~flag群を決定する:~ORIGIN#determining-the-creation-sandboxing-flags
同じ生成元~domain:~ORIGIN#same-origin-domain
同一-文書~naviを完結する:#finalize-a-same-document-navigation
同一-生成元:~ORIGIN#same-origin
sub.生成元:~ORIGIN#same-origin
応答の~opener施策を施行する:~ORIGIN#coop-enforce
施策~容器:~ORIGIN#policy-container
施策~容器を~cloneする:~ORIGIN#clone-a-policy-container
許可-済み~navigator:~ORIGIN#one-permitted-sandboxed-navigator
閲覧~文脈~sandbox化( ~custom~protocol~navi )~flag:~ORIGIN#sandboxed-custom-protocols-navigation-browsing-context-flag
閲覧~文脈~sandbox化( ~download )~flag:~ORIGIN#sandboxed-downloads-browsing-context-flag
閲覧~文脈~sandbox化( ~navi )~flag:~ORIGIN#sandboxed-navigation-browsing-context-flag
閲覧~文脈~sandbox化( 利用者-作動化を伴う~top-level~navi )~flag:~ORIGIN#sandboxed-top-level-navigation-with-user-activation-browsing-context-flag
閲覧~文脈~sandbox化( 利用者-作動化を伴わない~top-level~navi )~flag:~ORIGIN#sandboxed-top-level-navigation-without-user-activation-browsing-context-flag
閲覧~文脈~視野~生成元:#browsing-context-scope-origin
~opener施策:~ORIGIN#cross-origin-opener-policy
~opener施策の施行n結果:~ORIGIN#coop-enforcement-result
~opener施策を得する:~ORIGIN#obtain-coop
~URLは履歴~内に施策~容器を格納するよう要求するか？:~ORIGIN#requires-storing-the-policy-container-in-history
~navi応答~用に利用する閲覧~文脈を得する:~ORIGIN#obtain-browsing-context-navigation

bc.作動中な~window:~HTMLds#active-window
bc.作動中な文書:~HTMLds#active-document
bc.開いた閲覧~文脈:~HTMLds#opener-browsing-context
nav.~ID:~HTMLds#nav-id
nav.~load~event遅延-中か:~HTMLds#delaying-load-events-mode
nav.~session履歴~entry群:~HTMLds#tn-session-history-entries
nav.~session履歴~辿り~queue:~HTMLds#tn-session-history-traversal-queue
nav.~system可視性~状態:~HTMLds#system-visibility-state
nav.~target名:~HTMLds#nav-target
nav.作動中な~entry:~HTMLds#nav-active-history-entry
nav.作動中な~window:~HTMLds#nav-window
nav.作動中な文書:~HTMLds#nav-document
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
nav.入子な履歴~stepの適用-を走らせているか:~HTMLds#tn-running-nested-apply-history-step
nav.容器:~HTMLds#nav-container
nav.容器~文書:~HTMLds#nav-container-document
nav.現在の~session履歴~entry:~HTMLds#nav-current-history-entry
nav.現在の~session履歴~step:~HTMLds#tn-current-session-history-step
nav.親:~HTMLds#nav-parent
nav.~top-level辿可能:~HTMLds#nav-top
親~navigable:~HTMLds#nav-parent
nav.辿可能な~navigable:~HTMLds#nav-traversable
~Jake図式:~HTMLds#jake-diagram
~navigable:~HTMLds#navigable
~navigable容器:~HTMLds#navigable-container
~node~navigable:~HTMLds#node-navigable
~top-level辿可能:~HTMLds#top-level-traversable
先祖~navigable群:~HTMLds#ancestor-navigables
全部的に作動中:~HTMLds#fully-active
子~navigable:~HTMLds#child-navigable
子~navigable群:#_child-navigables
子孫~navigable群:~HTMLds#descendant-navigables
文書~treeに属する子~navigable群:~HTMLds#document-tree-child-navigables
属する閲覧~文脈:~HTMLds#concept-document-bc
広義-子孫~navigable群:~HTMLds#inclusive-descendant-navigables
生成元を決定する:~HTMLds#determining-the-origin
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
辿可能な~navigable:~HTMLds#traversable-navigable

doc.~pageを示しているか:~HTMLlifecycle#page-showing
doc.休止~時刻:~HTMLlifecycle#suspension-time
doc.休止された~timer~handle群:~HTMLlifecycle#suspended-timer-handles
doc.回復可能か:~HTMLlifecycle#concept-document-salvageable
multipart/x-mixed-replace 文書を読込む:~HTMLlifecycle#navigate-multipart-x-mixed-replace
完全に読込まれ:~HTMLlifecycle#completely-loaded
~HTML文書を読込む:~HTMLlifecycle#navigate-html
~media文書を読込む:~HTMLlifecycle#navigate-media
~text文書を読込む:~HTMLlifecycle#navigate-text
~DOMを有さない文書~用に~inline内容を作成する:~HTMLlifecycle#read-ua-inline
~unload~counter:~HTMLlifecycle#unload-counter
文書とその子孫たちを~unloadする:~HTMLlifecycle#unload-a-document-and-its-descendants
文書とその子孫たちを中止する:~HTMLlifecycle#abort-a-document-and-its-descendants
文書を作成して初期化する:~HTMLlifecycle#initialise-the-document-object
	＠~HTMLlifecycle#initialise-the-document-object
文書を破壊する:~HTMLlifecycle#destroy-a-document
終了n入子ng~level:~HTMLlifecycle#termination-nesting-level

~navi応答の~X-Frame-Optionsに対する固守を検査する:~HTMLsl#check-a-navigation-response's-adherence-to-x-frame-options

enV.~API用~基底~URL:~WAPI#api-base-url
enV.~ID:~WAPI#concept-environment-id
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.作動中な~sw:~WAPI#concept-environment-active-service-worker
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.実行は準備済みか:~WAPI#concept-environment-execution-ready-flag
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
aG.~event~loop:~WAPI#concept-agent-event-loop
~event~loop:~WAPI#event-loop
~naviと辿り~task~source:~WAPI#navigation-and-traversal-task-source
古典~scriptを作成する:~WAPI#creating-a-classic-script
古典~scriptを走らす:~WAPI#run-a-classic-script
~task:~WAPI#concept-task
大域~taskを~queueする:~WAPI#queue-a-global-task
既定の~script~fetch~option群:~WAPI#default-script-fetch-options
環境:~WAPI#environment
環境~設定群~obj:~WAPI#environment-settings-object
環境を破棄する手続き:~WAPI#environment-discarding-steps
関連な~agent:~WAPI#relevant-agent
関連な~realm:~WAPI#concept-relevant-realm
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
静止する:~WAPI#pause
描画を更新する:~WAPI#update-the-rendering
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
走らせた~scriptを片付ける:~WAPI#clean-up-after-running-script

作動中な~timer群が成す~map:~HTMLGAPI#map-of-active-timers
登録-済み~handler:~HTMLnavigator#dom-navigator-registerprotocolhandler
~PDF~viewerは~supportされるか:~HTMLnavigator#pdf-viewer-supported

構文解析を停止-:~HTMLparsing#stop-parsing

~entry~list:~HTMLforms#entry-list
~form提出:~HTMLforms#concept-form-submit
~form提出:~HTMLforms#concept-form-submit
再設定する~algo:~HTMLforms#concept-form-reset-control

~page遷移~eventを発火する:~HTMLnavAPI#fire-a-page-transition-event
履歴~obj:~WINDOW#doc-history
hsT.~index:~WINDOW#concept-history-index
hsT.状態:~WINDOW#concept-history-state
hsT.長さ:~WINDOW#concept-history-length
復旧されない事由~群:~WINDOW#nrr-struct
復旧されない事由の詳細:~WINDOW#nrr-details-struct
nrrd.事由~文字列:~WINDOW#nrr-details-reason
nrr.~URL:~WINDOW#nrr-url
nrr.~source:~WINDOW#nrr-src
nrr.~ID:~WINDOW#nrr-id
nrr.名前:~WINDOW#nrr-name
nrr.事由~群:~WINDOW#nrr-reasons
nrr.子~事由~群:~WINDOW#nrr-children

~navi~API:~HTMLnavAPI#window-navigation-api
~navi~API~method追跡子:~HTMLnavAPI#navigation-api-method-tracker
~naviを中止したことについて~navi~APIに伝える:~HTMLnavAPI#inform-the-navigation-api-about-aborting-navigation
新たな文書~用に~navi~API~entry群を初期化する:~HTMLnavAPI#initialize-the-navigation-api-entries-for-a-new-document
進行中の~naviの間は通常の~scroll復旧を抑止するか:~HTMLnavAPI#suppress-normal-scroll-restoration-during-ongoing-navigation
同一-文書~navi用に~navi~API~entry群を更新する:~HTMLnavAPI#update-the-navigation-api-entries-for-a-same-document-navigation
再~作動化~用に~navi~API~entry群を更新する:~HTMLnavAPI#update-the-navigation-api-entries-for-reactivation
~push／置換-／再読込み用の~navigate_ev~eventを発火する:~HTMLnavAPI#fire-a-push/replace/reload-navigate-event
辿-用の~navigate_ev~eventを発火する:~HTMLnavAPI#fire-a-traverse-navigate-event
作動化:~HTMLnavAPI#navigation-activation
nA.旧-~entry:~HTMLnavAPI#nav-activation-old-entry
nA.新-~entry:~HTMLnavAPI#nav-activation-new-entry
nA.~navi種別:~HTMLnavAPI#nav-activation-navigation-type
~navi~API~entry~indexを取得する:~HTMLnavAPI#getting-the-navigation-api-entry-index
nV.~entry~list:~HTMLnavAPI#navigation-entry-list
nhe.~session履歴~entry:~HTMLnavAPI#nhe-she
~naviの現在の~entry:~HTMLnavAPI#navigation-current-entry


	i.~navi種別:~HTMLnavAPI#fire-navigate-prr-navigationtype
	i.同一-文書か:~HTMLnavAPI#fire-navigate-prr-issamedocument
	i.行先~URL:~HTMLnavAPI#fire-navigate-prr-destinationurl
	i.古典~履歴~API用の状態:~HTMLnavAPI#fire-navigate-prr-classichistoryapistate
	i.利用者-関与i:~HTMLnavAPI#fire-navigate-prr-userinvolvement
	i.~navi~API状態:~HTMLnavAPI#fire-navigate-prr-navigationapistate


	●用語（外部
新たな~obj:~WEBIDLjs#new

sct.~item:~INFRA#struct-item
set.付加する:~INFRA#set-append
sub.大小無視:~INFRA#ascii-case-insensitive
	~Assert:~INFRA#assert
	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue
	~EACH:~INFRA#list-iterate
	~IN:~INFRA#list-contain
~byte列:~INFRA#byte-sequence
~dequeueする:~INFRA#queue-dequeue
~enqueueする:~INFRA#queue-enqueue
~item:~INFRA#list-item
~list:~INFRA#list
空:~INFRA#list-is-empty
	空にする:~INFRA#list-empty
~cloneする:~INFRA#list-clone
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
~map内に存在する:~INFRA#map-exists
~queue:~INFRA#queue
~size:~INFRA#list-size
~surrogate:~INFRA#surrogate
~tuple:~INFRA#tuple
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
和集合:~INFRA#set-union
実装定義:~INFRA#implementation-defined
拡張する:~INFRA#list-extend
有順序~集合:~INFRA#ordered-set
構造体:~INFRA#struct
置換する:~INFRA#list-replace
除去する:~INFRA#list-remove

doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
el.局所~名:~DOM4#concept-element-local-name
~HTML文書:~DOM4#html-document
~ID:~DOM4#concept-id
~eventを発火する:~DOM4#concept-event-fire
作動化の挙動:~DOM4#eventtarget-activation-behavior
~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order
文書~tree内:~DOM4#in-a-document-tree
根:~DOM4#concept-tree-root

新たな~WebDriver-BiDi~navi状態s:~HTMLdep#_new-webdriver-bidi-navigation-status
wBDst.処理待ち:~WEBDRIVER-BIDI#navigation-status-pending
wBDst.取消された:~WEBDRIVER-BIDI#navigation-status-canceled
wBDst.~commitされた:~WEBDRIVER-BIDI#navigation-status-committed
wBDst.完了した:~WEBDRIVER-BIDI#navigation-status-complete
~WebDriver-BiDi~naviが開始された:~WEBDRIVER-BIDI#webdriver-bidi-navigation-started
~WebDriver-BiDi~naviに失敗した:~WEBDRIVER-BIDI#webdriver-bidi-navigation-failed
~WebDriver-BiDi~naviは~commitされた:~WEBDRIVER-BIDI#webdriver-bidi-navigation-committed
~WebDriver-BiDi利用者~promptが閉じられた:~WEBDRIVER-BIDI#webdriver-bidi-user-prompt-closed
~WebDriver-BiDi利用者~promptが開かれた:~WEBDRIVER-BIDI#webdriver-bidi-user-prompt-opened
~WebDriver-BiDi素片へ~navigateされた:~WEBDRIVER-BIDI#webdriver-bidi-fragment-navigated
~WebDriver-BiDi履歴が更新された:~WEBDRIVER-BIDI#webdriver-bidi-history-updated

rq.再読込み~naviか:~FETCH#concept-request-reload-navigation-flag
rq.履歴~naviか:~FETCH#concept-request-history-navigation-flag
rq.置換する~client~ID:~FETCH#concept-request-replaces-client-id
rq.施策~容器:~FETCH#concept-request-policy-container
~byte列を本体として取得する:~FETCH#byte-sequence-as-a-body
~fetchを中止する:~FETCH#fetch-controller-abort
次回の手動~redirect手続きを処理する:~FETCH#fetch-controller-process-the-next-manual-redirect
~fetch制御器:~FETCH#fetch-controller
i.並列~queueを利用するか:~FETCH#fetch-useparallelqueue
i.応答の処理n:~FETCH#process-response
i.応答の早期~hintの処理n:~FETCH#fetch-processearlyhintsresponse
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.~header~list:~FETCH#concept-request-header-list
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.~referrer:~FETCH#concept-request-referrer
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.再読込み~naviか:~FETCH#concept-request-reload-navigation-flag
rq.利用者が作動化したか:~FETCH#request-user-activation
rq.履歴~naviか:~FETCH#concept-request-history-navigation-flag
rq.本体:~FETCH#concept-request-body
rq.現在の~URL:~FETCH#concept-request-current-url
rq.生成元:~FETCH#concept-request-origin
rq.置換する~client~ID:~FETCH#concept-request-replaces-client-id
rq.行先:~FETCH#concept-request-destination
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.起動元~種別:~FETCH#request-initiator-type
rq.利用者~prompt用の辿可能:~FETCH#concept-request-window
rq.~sw~mode:~FETCH#request-service-workers-mode
rq.~top-level~navi起動元~生成元:~FETCH#request-top-level-navigation-initiator-origin
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
rs.本体:~FETCH#concept-response-body
rs.状態s:~FETCH#concept-response-status
rs.計時許容に合格したか:~FETCH#concept-response-timing-allow-passed
応答の~Location~URLを得る:~FETCH#concept-response-location-url
~HTTP_S~scheme:~FETCH#http-scheme
~byte列を本体として取得する:~FETCH#byte-sequence-as-a-body
~fetchする:~FETCH#concept-fetch
~fetch~scheme:~FETCH#fetch-scheme
~fetchを中止する:~FETCH#fetch-controller-abort
~headerを設定する:~FETCH#concept-header-list-set
~network~error:~FETCH#concept-network-error
応答:~FETCH#concept-response
次回の手動~redirect手続きを処理する:~FETCH#fetch-controller-process-the-next-manual-redirect
要請:~FETCH#concept-request
非同一-生成元~資源~施策~検査:~FETCH#cross-origin-resource-policy-check
先送d~fetch~quotaを予約する:~FETCH#reserve-deferred-fetch-quota

ある種別の~navi要請は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-request
~targetにおける ある種別の~navi要請に対する応答は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-response

~UTF-8復号する:~ENCODING#utf-8-decode
~UTF-8符号化する:~ENCODING#utf-8-encode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

~referrer施策:~REFERRER-POLICY#referrer-policy
既定の~referrer施策:~REFERRER-POLICY#default-referrer-policy

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time

処理能~entryを~queueする:~TIMELINE#queue-a-performanceentry

~navi計時~entryを作成する:~NAV-TIMING#dfn-create-the-navigation-timing-entry

st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Url:~HEinput#url-state-(type=url)
st.Email:~HEinput#email-state-(type=email)

表示域:~CSS2J#viewport

文書の先頭へ~scrollする:~CSSOMVIEW#scroll-to-the-beginning-of-the-document
~targetを~viewの中へ~scrollする:~CSSOMVIEW#scroll-a-target-into-view
~scroll可能な~overflow区画:~CSSOVERFLOW3#scrollable-overflow-region
~view遷移を作動化する:~CSSVT#activate-view-transition
非同一-文書な~view遷移を設定しておく:~CSSVT#setup-cross-document-view-transition
内へ来る非同一-文書な~view遷移を解決する:~CSSVT#resolve-inbound-cross-document-view-transition
~naviは非同一-文書な~view遷移を誘発し得るか？:~CSSVT#navigation-can-trigger-a-cross-document-view-transition

~MIME型:~MIMESNIFF#mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~JSON~MIME型:~MIMESNIFF#json-mime-type
~JS~MIME型:~MIMESNIFF#javascript-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type

文字列を~byte列に~percent-復号する:~URL1#string-percent-decode
素片は除外する:~URL1:#url-equals-exclude-fragments
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
url.素片:~URL1#concept-url-fragment
~URL:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer
同等な~URL:~URL1#concept-url-equals
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode

~agent~cluster:~TC39#sec-agent-clusters
~surrounding~agent:~TC39#surrounding-agent

~fetchを取扱う~algo:~SW1#on-fetch-request-algorithm
~randomな~UUIDを生成する:https://w3c.github.io/webcrypto/#dfn-generate-a-random-uuid

~consoleに警告を報告する:~CONSOLE#report-a-warning-to-the-console

	●＠
	＠#attempt-to-populate-the-history-entry's-document
	＠#continuations-dequeue
	＠#create-navigation-params-by-fetching
	＠#dom-history-pushstate
	＠#example-sync-navigation-steps-queue-jumping-basic
	＠#finalize-a-cross-document-navigation
	＠#navigate-convert-to-replace
	＠#navigate-non-frag-sync
	＠#navigating-across-documents
	＠#navigation-and-session-history
	＠#navigation-create-document-state
	＠#note-bfcache
	＠#note-navigate-called-with-response
	＠#populating-a-session-history-entry
	＠#reactivate-a-document
	＠#reloading-and-traversing
	＠#scroll-to-fragid
	＠#sync-navigation-steps-queue-jumping-examples
	＠#sync-navigations-jump-queue
	＠#tn-append-session-history-sync-nav-steps
	＠#tn-append-session-history-traversal-steps
	＠#traverse-the-history-by-a-delta
	＠#update-document-for-history-step-application
	＠https://github.com/whatwg/html/labels/topic%3A%20javascript%3A%20URLs
	＠~HTMLcloning#structureddeserialize
	＠~HTMLindex#event-popstate
	＠~HTMLintro#how-to-read-this-specification
	＠~HTMLissue/4703
	＠~HTMLissue/5562
	＠~HTMLlifecycle#destroy-a-document
	＠~HTMLlifecycle#destroy-a-document-and-its-descendants
	＠~HTMLlifecycle#initialise-the-document-object
	＠~HTMLlifecycle#read-ua-inline
	＠~HTMLlifecycle#read-xml
	＠~HTMLlifecycle#unload-a-document
	＠~HTMLobs#attr-a-name
	＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy
	＠~RFCx/rfc6068#section-2
	＠~SW1#on-fetch-request-algorithm
	＠#example-getting-the-target-history-entry

●●words_table1

WEBDRIVER-BIDI:https://w3c.github.io/webdriver-bidi/
HTMLintro:HTML-introduction-ja.html
CONSOLE:console-ja.html

about_blank:about:blank
about_srcdoc:about:srcdoc
javascript0:javascript:
javascript_:<code class="scheme">javascript:</code> 
navigate_ev: <code class="event-type">navigate</code> 
beforeunload_ev: <code class="event-type">beforeunload</code> 
pageswap_ev: <code class="event-type">pageswap</code> 


●●words_table

	●略語など
Jake:
POST:
PDF:
UUID:
BF:
WebDriver-BiDi:

	●保安
悪用-:exploit:~
騙す:trickする:~
施行n:enforcement::施行
COOP:
X-Frame-Options:
計時許容:timing allow::計時の許容
防護-:guard:~
	安全に防護する:safeguard
警告:warning::~

	阻止される^i:Blocked
	同一-生成元かどうか:same-originness
	~CSP:Content Security Policy

	●navi／history／network
HTTP_S:HTTP(S) 
Location:
disposition:
navigator::::ナビゲータ
load:
unload:
agent:
iframe:
step:
about:
lazy:
補助:auxiliary::~
埋込元:embedder::埋め込み元
読込直す:reloadする::読み込み直す::リロードする
読込直され:reloadされ::読み込み直され::リロードされ
再読込み:reload::再読み込み::リロード
	再読込み法:reloading
回復可能:salvage 可能:~
回復不能:salvage 不能:~
	回復不能:unsalvageable

	閉じる:closeする::~
	開く:openする::~
opener:::open 元
	open:
切替n:switch:切り替え
差分:delta:~
最近の:latest:~
quota::::クォータ

	先へ進む:going forward
	後へ戻る:going back
	進む:forward
	戻る:back
	~navi~algo:~navigate~algo
	~cache用の:caching-
	~BF~cache:bfcache
	素片への~navi:fragment navigation
	他所へ~navigate:navigate away
	叩く:hitする:~
	~fetchし直:re-fetch
	前方:forward
	同じ生成元~domain$でない:cross origin-domain

	●一般処理
timer::::タイマー
job::::ジョブ
process::::プロセス
準備度:readiness:~
静止-:pause:~
並列:parallel::~
持続-:persist:~
復旧-:restore::~
復旧:restoration::~
最終-:final:~
params::::パラメタ群
作成時の:creation::~
追従-:follow:~
宛先:target:~
処理待ち:pending::~
handle::::ハンドル
休止:suspension::~
preload:
commit:
早期:early::~
完結-:finalize:~
手渡す:hand offする:~
	適切に手渡す:perform the appropriate handoff of
	手渡す:handed
次回の:next:~
保存-:save::~
昇順に:ascending orderで:~
切替える:switchする:切り替える
jump::::ジャンプ
	~jumpして巡って:jumping around
一時的:temporary:~
競争:race:~
勝つ:winする:~
勝った:winした:~
存続期間:lifetime:~
給-:supply:~
再現-:replicate:~
放棄-:abandon:~
続行-:proceed:~
和集合:union::~
拡充:population:~
	拡充し直-:repopulated
瞬時:instant:~
候補:candidate:~
back-up:back up:::バックアップ
周期的:periodical:~
決着-:settle::~
追跡子:tracker::~::トラッカー
入口:entry point:~
分岐:branch:~
非作動化-:deactivate::~::非アクティブ化
観測ng:observing::観測::オブザービング
再開:resumption::~
片付ける:clean upする::~

	起動元は許容されない^i:"initiator-disallowed"
	~beforeunload_evにより取消された^i:"canceled-by-beforeunload"
	~navigate_evにより取消された^i:"canceled-by-navigate"
	適用された^i:"applied"
	継続する^i:"continue"

	~call元:caller
	~call元:call-site
	一度でも:ever
	渡され／渡さな／渡せる:pass
	以降:onward
	以降では:onwards
	-:proceed onward
	~GOTO `非~文書^i:proceed onward
	居続ける:stay on
	格納し直-:restoreing
	同期cしなくなる:puts them out of sync with
	毎回:each time
	同時に:at the same time
	結果になる:end up
	で終える:ends up at
	新たに:newly-
	この時点で:at this point
	この地点で:at this point
	前もって:prior
	予め構文解析-:preparsed
	構築し直-:reconstruct
	経るかもしれない:might experience
	経ない:experience
	経る:go through
	少し経った後、At some point later
	上の段にて:the earlier
	済まされる:done earlier
	作成し直-:recreate
	地点:point
	起こる／起きる:happen
	する~~処理にとりかかる:move on
	次の段:the next step
	最終的に:ultimately
	~NULL化され:nulled out
	~NULL化:unset
	~~順序においては:in terms of 
	今回は:this time
	入る:enter
	今の所:right now
	以降を:onward to
	完遂-:finally finish
	終わった:ended-up
	全体を~~停止させ:put the whole thing to a halt
	構文解析-不能:unparseable
	始め／始まる:beginning
	~~開始法:beginning
	~~終了法:ending
	~queue:post
	~download:downloading
	時間がかかる:take some time
	ここまでに:after
	経ている:experiencing
	引き継がれ:carried over
	再~作動化:reactivation
	~call元:call site
	~~至る:end up in
	伝える:inform
	とらない:receive no
	~NULL 以外になった:when 〜 has

	●変数

旧-:old:~
新-:new:~
生の:raw:~
余分:extra:~

	~pageswap_ev:page swap

	%-:~baseURL
	%~COOP:coop
	%~COOP施行n結果:coopEnforcementResult
	%~CSP~navi種別:cspNavigationType
	%~Location~URL:locationURL
	%~MIME型:type
	%~POSTを許容するか:allowPOST
	%~UAは~downloadを許容するか:uaAllowsDownloading
	%~URL:url
	%~URL:-
	%~algo集合:-
	%~beforeunload_evが必要になる~navigable群:navigablesThatNeedBeforeUnload
	%~beforeunload_evは必要か:needsBeforeunload

	%~beforeunload_evが発火される文書~群:documentsToFireBeforeunload
	%~entry:entry
	%~entry~list:entryList
	%~entry~list群:entryLists
	%~entry群:entries
	%~event:event
	%~eventは発火したか:eventsFired
	%~eventを発火した結果:eventFiringResult
	%~fetchした応答:fetchedResponse
	%~fetch制御器:fetchController
	%~form~control:formControl
	%~form~data~entry~list:formDataEntryList
	%~handle:handle
	%~index:i
	%~navi:navigation
	%~navigable:navigable
	%~navigableを変更している継続:changingNavigableContinuation
	%~navigableを変更している継続~群:changingNavigableContinuations
	%~navigable群:-
	%~navigable群:navigables
	%~navigate_ev~event用の利用者-関与i:userInvolvementForNavigateEvent
	%~navigate_ev~event結果:navigateEventResult
	%~navi~API用の~entry群:entriesForNavigationAPI
	%~navi~ID:navigationId
	%~navi~ID:-
	%~navi~params:navigationParams
	%~navi計時~種別:navTimingType
	%~navi種別:navigationType
	%~referrer施策:referrerPolicy
	%~sandbox~flag群:sandboxFlags
	%~script~source:scriptSource
	%~script履歴~index:scriptHistoryIndex
	%~script履歴~長さ:scriptHistoryLength
	%~session履歴~辿り~queue:sessionHistoryTraversalQueue
	%src:src
	%~source:source
	%~source~snapshot~params:sourceSnapshotParams
	%~sourceは~downloadを許容するか:sourceAllowsDownloading
	%~source文書:sourceDocument
	%~source施策~容器:sourcePolicyContainer
	%~step:step
	%~step群:steps
	%~target~entry:targetEntry
	-:targetEntry
	%~target~entry群:targetEntries
	%~target~navigable:targetNavigable
	%~target~snapshot~params:targetSnapshotParams
	%~target~step:targetStep
	%~target~step~index:targetStepIndex
	%~targetに特有な~source~snapshot~params:potentiallyTargetSpecificSourceSnapshotParams
	%~targetは~downloadを許容するか:targetAllowsDownloading
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%~unload~promptはこの文書により取消されたか:unloadPromptCanceledByThisDocument
	%~unload~promptは取消されたか:unloadPromptCanceled
	%~unload~promptを示したか:unloadPromptShown
	%利用者~prompt~handler:userPromptHandler
	%この文書~用の~unload~promptを示したか:unloadPromptShownForThisDocument
	%一過な作動化か:hasTransientActivation
	%休止-所要時間:suspendDuration
	%何も変更していない~jobのうち完了したものの総数:completedNonchangingJobs
	%何も変更していない~jobの総数:totalNonchangingJobs
	%作動中な~entry:activeEntry
	%作動中な~timer群:activeTimers
	%作動化し直さないか:doNotReactivate
	%作動化し直される~entry:reactivatedEntry
	%例外を可能化するか:exceptionsEnabled
	%値:値
	%入子な履歴:nestedHistory
	%全~step群:allSteps
	%利用者-関与i:userInvolvement
	%利用者-関与i:userNavigationInvolvement
	%取消nを検査するか:checkForCancelation
	%同期c~naviを取扱う前に待機しなければならない~navigable群:navigablesThatMustWaitBeforeHandlingSyncNavigation
	%変更されていないが更新は必要な~navigable群:nonchangingNavigablesThatStillNeedUpdates
	%変更されている~navigable群:changingNavigables
	%子~navigable:childNavigable
	%完了~手続き:completionSteps
	%完了した~task数:completedTasks
	%完了した変更~job数:completedChangeJobs
	%宛先~realm:targetRealm
	%局所~名:-
	%履歴:history
	%履歴~entry:historyEntry
	%履歴~取扱い:historyHandling
	%履歴~施策~容器:-
	%差分:delta
	%復号-済み素片:decodedFragment
	%応答:response
	%応答~施策~容器:responsePolicyContainer
	%応答の~COOP:responseCOOP
	%応答の処理n:processResponse
	%応答の早期~hintの処理n:processEarlyHintsResponse
	%応答の生成元:responseOrigin
	%手続き:steps
	%指示された要素:potentialIndicatedElement
	%文書:document
	%文書~tree:-
	%文書~状態:-
	%文書~状態:docState
	%文書~状態:documentState
	%文書~状態~群:docStates
	%文書~群:documents
	%文書~資源:documentResource
	%文書たちの~entryは変化したか:documentsEntryChanged
	`文書を拡充した後の手続き^i:afterDocumentPopulated
	%文書を更新する:updateDocument
	%新-~URL:newURL
	%新たな~entry:newEntry
	%新たな値:newValue
	%新たな文書:newDocument
	%新たな文書か:documentIsNew
	%新たな文書の生成元:newDocumentOrigin
	%施策:施策
	%施策~容器:policyContainer
	%旧-~URL:oldURL
	%旧-文書~状態:oldDocState
	%旧-生成元:oldOrigin
	%早期~hintを~commitする:commitEarlyHints
	%早期~応答:earlyResponse
	%最終-~sandbox~flag群:finalSandboxFlags
	%最終-状態s:finalStatus
	%検査する~navigable群:navigablesToCheck
	%検査する起動元:initiatorToCheck
	%状態:state
	%現在の~URL:currentURL
	%現在の~step~index:currentStepIndex
	%現在の~step:-
	%現在の文脈は~navi~sourceか:-
	%生の~entry群:rawEntries
	%発火~用の~entry~list:entryListForFiring
	%発火~用の~navi~API状態:navigationAPIStateForFiring
	%直列形の~data:serializedData
	%符号化-済み~script~source:encodedScriptSource
	%素片:fragment
	%結果:result
	%結果~施策~容器:resultPolicyContainer
	%結果~群:results
	%継続するか:continue
	%総~task数:totalTasks
	%置換する~entry:entryToReplace
	%行先~navi~API状態:destinationNavigationAPIState
	%表示される~entry:displayedEntry
	%表示される文書:displayedDocument
	%要請:request
	%親~環境:parentEnvironment
	%設定群:settings
	%評価~状態s:evaluationStatus
	%資源:resource
	%起動元~生成元:initiatorOrigin
	%起動元~生成元~snapshot:initiatorOriginSnapshot
	%起動元~基底~URL~snapshot:initiatorBaseURLSnapshot
	%辿可能:traversable
	%開始-時の~index:startingIndex
	%開始-時の生成元:startingOrigin
	%非同一-文書を経ている~navigable群:navigablesCrossingDocuments
	%作動化~用の直前~entry:previousEntryForActivation
	%直前~entryの~index:previousEntryIndex
	%生成元:-
	%遷移:transition
	%余分な文書~状態を保存するか:saveExtraDocumentState
	%容器:container
	%容器:-
	%事由:reason
	%詳細:details
	%文書~用の復旧されない事由~群:notRestoredReasonsForDocument
	%~navigable:navigable
	%子~文書:childDocument
	%~top-level辿可能:topLevelTraversable
	%非同一-生成元な子孫~群:crossOriginDescendants
	%非同一-生成元な子孫~群は~BF~cacheを防止するか:~crossOriginDescendantsPreventsBfcache
	%非同一-生成元な~navigable:crossOriginNavigable
	%非同一-生成元な子~用の事由:reasonsForCrossOriginChild
	%~view遷移:viewTransition
	%~view遷移を誘発し得るか:potentiallyTriggerViewTransition
	%~browser~UIによる~naviか:isBrowserUINavigation
	%~unload前に~pageswap_evを発火する手続き:firePageSwapBeforeUnload
	%~view遷移~捕捉-後も~naviと伴に続行する手続き
:proceedWithNavigationAfterViewTransitionCapture
	%行先~entry:destinationEntry
	%~unload後の手続き:afterPotentialUnloads
	`~unload後の手続き^i:afterPotentialUnloads

		●UI
	~scroll法／~scrollすること:scrolling
書字方向性:directionality::~
開始位置:beginning:~
始点:starting point:~
autofill:
一過:transient::~
居残な:stickyな::居残る
viewer::::ビューア
露呈-:reveal:露わに
popup::::ポップアップ
確認-:confirm:~
確認:confirmation:~
開かれ:openされ:~
閉じら:closeさ:~
部位:part:~
欄:field::~::フィールド
	~anchor法:anchoring

	長押しする:holding down

	●仕様
外部的:external:~
固守:adherence:~
白紙状態:clean slate:~
追跡器:tracker::~::トラッカー
導入:introduction:~
助言:advice:~
推測:guess:~
	最善な推測:best-guess
究明:investigation:~
協調-:coordinate:~
図画化-:depict:~
介入-:intervene:~
周知:well-known:~
複雑:complicated:~
故意:deliberate:~
策:strategy:~
捕捉-:capture:~
軽量:lightweight:~
単直:straightforward:簡単
本当の:realな:~
metaphor::::メタファー
視点:perspective:~
想像-:imagine:~
単直:straightforward:簡単
知覚-:perceive:~
累積-:accumulate:~
理論:theory:~
	理論~上は:in theory
直面-:face:~
	直面-:in the face of
不整合:inconsistency:~
真実:truth:~
	“真実を成す~sourceは一つだけ”:a single source of truth
	“真実を成す”:the central source of truth
	一極化:centralized
機能的:functional:~
寄与-:contribute:~
競合-:conflict:~
競合:conflict:~
main::::メイン
責務:responsibility:~
	責務〜ある:responsible
定式化-:formulate:~
注視-:watch:~
的確:right:~

	課され:impose
	 ~OR↓ が満たされる:be in one of these scenarios
	それがゆえ:That's why
	際どい:edge
	際どい:racy edge
	に関する:regarding
	捉える:get a sense
	いわゆる:so-called
	調べる:look at
	場合分け:-casing
	形式上必要とされる:synthetic 〜 plumbing into the
	落胆させて:leads to 〜 sadness
	見込まれていない:unlikely
	見込みが高い:likely
	まかなう:cater
	~~保つ:left at
	関心を失った:no longer interested in
	両立:simultaneously
	担当:responsibility
	いらつく／紛らわしい／的外れである: annoying, deceptive, or pointless
	割かれる:concerned with
	せずに済む:have to do
	触れられず:remains untouched
	~~特殊な:a particular brand of
	に関する:in terms of
	とりかかる:can jump into the
	語句:words of
	語:word
	とはいえ:nevertheless
	〜に勝るものはない:will be invaluable
	場を占める:take place
	占めていた場:take place
	持ち込む:bring
	指す:refer
	諸々の:miscellaneous grab-bag of
	~~認識~perception
	壊れて:broken
	垣間見える:peeking
	混み入った:intertwined
	顕著に:exciting
	-:exciting
	必要とされるか:necessarily needs
	~~区分する:cordoning off
	一致して:line up
	話される:talked~about
	不幸な巡り合わせ:unfortunate accident
	真に:truly
	真の:true
	ようこそ:welcome
	竜の頷:dragon's maw
	厄介:worse
	ことにより:by virtue of
	以下では:In what follows
	したがって:This then
	~tag付け:tagged
	-:namely
	`NAVIGATIONTIMING$r:Navigation Timing
	~custom化-可能:customizable
	ここで、:Now
	~~知る:see
	見ている:looking
	見ること:looking
	伴い得る:may have
	する場合でも:potentially
	必要になる:necessitate
	事:fact
	紛らわし過ぎる:too confusing
	~web~platform:the platform
	助けにならない:would be unhelpful
	責務がある:responsible

	●未分類
BOM:
percent-::: %-
同等:equal::~
surrogate::::サロゲート
直列形の:serialized::~::シリアル形の
高分解能:high resolution::~
iframe-srcdoc:iframe srcdoc
srcdoc:
	table
feed:
	~feed~viewer
package::::パッケージ
		multipart
surrounding:
disk::::ディスク
保つ:keepする:~
保っ:keepし:~
	し続ける:keeping
連続的:contiguous:~
線形:linear:~
	線形~化:linearize
隣接な:adjacentな:隣接する
運ぶ:carryする:~
時機:timing:~
後続-:follow:~

	内へ来る:inbound
	-:joint
	-:foray
	^en:the tree see
	どれも:everyone
	もう一つの:one more
	残りの:the rest of
	たくさんの:a lot of
	全体を通して:throughout
	どれも:everyone
	毎回:each time
	同時に:at the same time
	結果になる:end-up
	新たに:newly-
	この時点で:at this point
	この地点で:at this point
	何らかの類の:some sort of
	前もって:prior
	箇所:place
	登録-済み:registered
	当の外部~software:target software
	Atom ~feed~viewer
	2 回:twice
	ときには:sometimes
	別として:apart from
	主に:main
	小さな:minor
	について来る:come in with
	そうしている間に，:meanwhile
	どれも:everyone
	もう一つの:one more
	残りの:the rest of
	たくさんの:a lot of
	全体を通して:throughout
	どれも:everyone
	何らかの類の:some sort of
	箇所:place
	先頭の:leading
	ごく:very
	低-:low-
	取り出した:has come out
	〜間際で:toward
	少数の:A couple of
	対を成さない:unpaired
	最~大な:greatest
	効いてない:not in play
	そのままにする:leaving
	のままにする:leave
	を成すかなりの部分〜費やされる:much of 〜 comes about
	指して:point
	指している:pointing
	もの:thing
	押して:press
	にまたがる:across
	取り戻す:free
	設定しておかれた所:setup
	為され:made
	~navi的:navigational
	占めて:occupy
	少数の:a few
	見かけ:looks
	向かう:head
	混ざって:mixされて
	含め:including
	含む:includeする
	第二の部分:second part
	部分:part
	各部:parts
	量:amount
	^en:beforeunload
	移動:moving
	伴い得る:may have
	`about:^l ~schemeを伴う:"about:"-schemed
	直前の:the previous
	最~大:greatest
	少しばかりの:some minor
	伴う:comes along with
	導いた:led to
	一回:once
	~~最新:up-to-date
	かまわない:free to
	在るために:presence

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Navigation and session history</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — ナビとセッション履歴</h1>
<p>Navigation and session history</p>

	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
所与の`~navigable$ %~navigable の
`子~navigable群@
とは、
%~navigable の`子~navigable$たちが成す`~list$を意味する
— 原文には，それらの順序が指定されていないが、
おそらく`子孫~navigable群$と同様に決定されると思われる。
（この用語は、
順序についての この記述をここに集約するため，この訳に導入している。）
</p>

		</section>
		<section id="navigation-and-session-history">
<h3 title="Navigation and session history">7.4. ~naviと~session履歴</h3>

<p>
竜の頷へようこそ。
~navi, ~session履歴, その履歴を通した辿りは、
この標準において，最も複階的な部分を成す。
◎
Welcome to the dragon's maw. Navigation, session history, and the traversal through that session history are some of the most complex parts of this standard.
</p>

<p>
基本的な概念は、
さほど困難に見えないかもしれない：
◎
The basic concept may not seem so difficult:
</p>
<ol>
	<li>
`~navigable$を見ている利用者は、
そこに呈示されている`作動中な文書$nav内の別の`~URL$へ`~navigate$する。
◎
The user is looking at a navigable that is presenting its active document. They navigate it to another URL.
</li>
	<li>
~browserは、
所与の~URLを~networkから~fetchする。
その結果を利用して
新たに`作成され＠~HTMLlifecycle#initialise-the-document-object$た`文書$で新たな`~session履歴~entry$を`拡充-$する。
◎
The browser fetches the given URL from the network, using it to populate a new session history entry with a newly-created Document.
</li>
	<li>
~browserは、
新たに拡充された~entryで，`~navigable$にて`作動中な~entry$navを更新する
— それに伴い、
利用者に示している`作動中な文書$navを更新する。
◎
The browser updates the navigable's active session history entry to the newly-populated one, and thus updates the active document that it is showing to the user.
</li>
	<li>
少し経った後，利用者は、
~browserの “戻る” ~buttonを押して，
以前の`~session履歴~entry$へ`戻る＠#traverse-the-history-by-a-delta$。
◎
At some point later, the user presses the browser back button to go back to the previous session history entry.
</li>
	<li>
~browserは、
その`~session履歴~entry$内に格納した`~URL$shEを調べて，それを利用して~fetchし直す
— その結果で，当の~entryの`文書$shEを`拡充-$する。
◎
The browser looks at the URL stored in that session history entry, and uses it to re-fetch and populate that entry's document.
</li>
	<li>
~browserは、
`~navigable$にて`作動中な~entry$navを再び更新する。
◎
The browser again updates the navigable's active session history entry.
</li>
</ol>

<p>
一部の混み入った複階性は、
次を通して垣間見える：
◎
You can see some of the intertwined complexity peeking through here, in＼
</p>
<ul>
	<li>
辿りが~navi
（すなわち、
【~session履歴~内に】
格納した~URLへの~network~fetch）
をどう生じさせ得るか。
◎
how traversal can cause a navigation (i.e., a network fetch to a stored URL),＼
</li>
	<li>
~naviを完遂したとき，利用者が的確なものを見ることを確保するために、
~session履歴~listとの~interface法は，どう必要とされるか。
◎
and how a navigation necessarily needs to interface with the session history list to ensure that when it finishes the user is looking at the right thing.＼
</li>
</ul>

<p>
が、
本当の問題は［
様々な際どい事例,
各種~web~platform特能との相互作用
］について来る：
◎
But the real problems come in with the various edge cases and interacting web platform features:
</p>
<ul>
	<li>
`子~navigable$（例： `iframe$e 内に包含されたもの）も~navigateでき, 辿れるが、
それらの~naviは，
【`親$navの】`~session履歴~entry群$navの中へ線形~化する必要がある
— 利用者は、
`辿可能な~navigable$（例：~browser~UItab）全体~用に単独の［
戻る／進む
］~UIしか有さないので。
◎
Child navigables (e.g., those contained in iframes) can also navigate and traverse, but those navigations need to be linearized into a single session history list since the user only has a single back/forward interface for the entire traversable navigable (e.g., browser tab).
</li>
	<li>
利用者は，
~session履歴~内で 2 ~step以上~辿るよう戻れるので
（例： “戻る” ~buttonを長押しすることにより）、
`子~navigable$が孕まれるとき，
同時に複数個の`~navigable$を辿る結果になり得る。
これは、
そこに孕まれる~navigableすべてにまたがって同期される必要がある
— そこには、
複数の`~event~loop$
— あるいは`~agent~cluster$さえも —
孕まれるかもしれない。
◎
Since the user can traverse back more than a single step in the session history (e.g., by holding down their back button), they can end up traversing multiple navigables at the same time when child navigables are involved. This needs to be synchronized across all of the involved navigables, which might involve multiple event loops or even agent clusters.
</li>
	<li>
~naviの間、
~serverは，［
状態s~code［
`204$hst ／ `205$hst
］,
および `Content-Disposition$h ~header
］を伴う応答を返し得る
— それは、
~naviを中止して，`~navigable$にて`作動中な文書$nav【！`作動中な文書$bc】を元のまま居続けさせる。
（辿りにより起動された~naviの間に これが起きた場合、ずっと厄介になる。）
◎
During navigation, servers can respond with 204 or 205 status codes or with `Content-Disposition: attachment` headers, which cause navigation to abort and the navigable to stay on its original active document. (This is much worse if it happens during a traversal-initiated navigation!)
</li>
	<li>
他の様々な~HTTP~header
— `Location$h, `Refresh$h, `X-Frame-Options$h, ~CSP用の~headerなど —
が、［
`~fetchする処理n＠#create-navigation-params-by-fetching$／
`文書を作成する処理n＠~HTMLlifecycle#initialise-the-document-object$
］に寄与する。
`Cross-Origin-Opener-Policy$h ~headerは、
`閲覧~文脈の選定と作成~処理n＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy$にさえも寄与する。
◎
Various other HTTP headers, such as `Location`, `Refresh`, `X-Frame-Options`, and those for Content Security Policy, contribute to either the fetching process, or the Document-creation process, or both. The `Cross-Origin-Opener-Policy` header even contributes to the browsing context selection and creation process!
</li>
	<li>
一部の~navi
（`素片への~navi＠#scroll-to-fragid$,
`単-~page~appにおける~navi＠#navigate-non-frag-sync$）
は、
同期的である
— すなわち、
~JS~codeは，~naviの結果が瞬時に観測されることを期待する。
したがって，［
`the tree see^en 内の他の`~navigable$すべての~session履歴の~viewと同期させる必要
］があり、［
競争~条件の~subjectになり得る
］ことに加え［
当の~session履歴の~viewどうしが競合している場合，それを解決する
］ことも必要になる。
◎
Some navigations (namely fragment navigations and single-page app navigations) are synchronous, meaning that JavaScript code expects to observe the navigation's results instantly. This then needs to be synchronized with the view of the session history that all other navigables in the tree see, which can be subject to race conditions and necessitate resolving conflicting views of the session history.
</li>
	<li>
~platformには、
~naviに関係する様々な［
特別な場合分けが必要になる特能
］が累積されている
— 次に挙げるものなど
⇒＃
`~javascript0$sc ~URL,
`srcdoc$aF を伴う `iframe$e,
`beforeunload$et ~event
◎
The platform has accumulated various exciting navigation-related features that need special-casing, such as javascript: URLs, srcdoc iframes, and the beforeunload event.
</li>
</ul>

<p>
以下では、
これらの複階性を［
~labelを伴う各［
節, ~algo
］の中に適切に~~区分して、
アリな所では，適切な導入を成す語句を与える
］ことにより，読者を手引きするよう試みた。
とは言え、
~naviと~session履歴を真に理解したいと望むなら，
`通例的な助言＠~HTMLintro#how-to-read-this-specification$に勝るものはない。
◎
In what follows, we have attempted to guide the reader through these complexities by appropriately cordoning them off into labeled sections and algorithms, and giving appropriate words of introduction where possible. Nevertheless, if you wish to truly understand navigation and session history, the usual advice will be invaluable.
</p>

			<section id="session-history-infrastructure">
<h4 title="Session history">7.4.1 ~session履歴</h4>

				<section id="session-history-entries">
<h5 title="Session history entries">7.4.1.1 ~session履歴~entry</h5>

<p>
`~session履歴~entry@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A session history entry is a struct with the following items:
</p>
<ul>
	<li>
`~step@shE
⇒
`pending^l ／
負でない整数
— 初期~時は `pending^l とする。
◎
step, a non-negative integer or "pending", initially "pending".
</li>
	<li>
`~URL@shE
⇒
`~URL$
◎
URL, a URL
</li>
	<li>
`文書~状態@shE
⇒
`文書~状態$
◎
document state, a document state.
</li>
	<li>
`古典~履歴~API用の状態@shE
⇒
`直列形の状態$
— 初期~時は，次の結果になるとする
⇒
`StructuredSerializeForStorage$jA( ~NULL )
◎
classic history API state, which is serialized state, initially StructuredSerializeForStorage(null).
</li>
	<li>
`~navi~API状態@shE
⇒
`直列形の状態$
— 初期~時は，次の結果になるとする
⇒
`StructuredSerializeForStorage$jA( `undefined^jv )
◎
navigation API state, which is a serialized state, initially StructuredSerializeForStorage(undefined).
</li>
	<li>
`~navi~API~key@shE
⇒
文字列
— 初期~時は，次の結果に設定される
⇒
`~randomな~UUIDを生成する$()
◎
navigation API key, which is a string, initially set to the result of generating a random UUID.
</li>
	<li>
`~navi~API~ID@shE
⇒
文字列
— 初期~時は，次の結果に設定される
⇒
`~randomな~UUIDを生成する$()
◎
navigation API ID, which is a string, initially set to the result of generating a random UUID.
</li>
	<li>
`~scroll復旧~mode@shE
⇒
`~scroll復旧~mode$
— 初期~時は `auto$l とする。
◎
scroll restoration mode, a scroll restoration mode, initially "auto".
</li>
	<li>
`~scroll位置~data@shE
⇒
`文書$shEの`復旧-可能な~scroll可能な領域$doc用の~scroll位置~data。
◎
scroll position data, which is scroll position data for the document's restorable scrollable regions.
</li>
	<li>
<p>
`持続される利用者~状態@shE
⇒
`実装定義$な何か
— 初期~時は ~NULL とする。
◎
persisted user state, which is implementation-defined, initially null
</p>

<p class="example">
例えば，一部の~UAは、
~form~controlの値を持続したいと求めるかもしれない。
◎
For example, some user agents might want to persist the values of form controls.
</p>

<p class="note">注記：
~form~controlの値を持続する~UAには、
書字方向性（要素の `dir$a 属性~値）も持続することが奨励される。
これは、［
明示的かつ既定でない書字方向性の下で，利用者が元々手入力した値
］が，履歴の辿り後に不正に表示されることを防止する。
◎
User agents that persist the value of form controls are encouraged to also persist their directionality (the value of the element's dir attribute). This prevents values from being displayed incorrectly after a history traversal when the user had originally entered the values with an explicit, non-default directionality.
</p>
	</li>
</ul>

<p>
`~session履歴~entry$の
`文書@shE
は、
当の~entryの`文書~状態$shEの`文書$dSを指す【！返す】。
◎
To get a session history entry's document, return its document state's document.
</p>

<hr>

<p id="state-object">
`直列形の状態@
は、
~UI状態を表現している~objを（ `StructuredSerializeForStorage$jA を介して）直列化したものである。
非正式には、
“状態~obj” と呼ばれることもある
— それは、［
作者から給された，~UI状態を表現している~obj
］あるいは［
`直列形の状態$を（ `StructuredDeserialize$jA を介して）逆直列化して作成される~obj
］を表す。
◎
Serialized state is a serialization (via StructuredSerializeForStorage) of an object representing a user interface state. We sometimes informally refer to "state objects", which are the objects representing user interface state supplied by the author, or alternately the objects created by deserializing (via StructuredDeserialize) serialized state.
</p>

<p>
~pageは、
~session履歴に`直列形の状態$を`追加できる＠~WINDOW#dom-history-pushstate$。
これは、
利用者（または~script）が履歴~内を後へ戻ったとき，
`逆直列化-＠~HTMLcloning#structureddeserialize$された上で`~scriptに返される＠~HTMLindex#event-popstate$。
したがって、
1 ~pageだけの~appにおいても，
作者が “~navi” の~metaphorを利用することを可能化する。
◎
Pages can add serialized state to the session history. These are then deserialized and returned to the script when the user (or script) goes back in the history, thus enabling authors to use the "navigation" metaphor even in one-page applications.
</p>

<div class="note">
<p>注記：
`直列形の状態$には、
主に二つの用途が意図されている：
◎
Serialized state is intended to be used for two main purposes:＼
</p>
<ul>
	<li>
一つは、
予め構文解析した状態の記述を`~URL$と一緒に格納して，
単純な事例では 作者が構文解析せずに済むようにすること
（それでも，元々利用者から渡された`~URL$を取扱うときは構文解析する必要があるので、
これは小さな最適化に過ぎない）。
◎
first, storing a preparsed description of the state in the URL so that in the simple case an author doesn't have to do the parsing (though one would still need the parsing for handling URLs passed around by users, so it's only a minor optimization).＼
</li>
	<li>
もう一つは、
他からは格納されない状態
— 現在の`文書$~instanceに限り適用され、
同じ~URLの新たな`文書$が開かれるとき，構築し直す必要がある状態 —
を，作者が~URLと一緒に格納できるようにすること。
◎
Second, so that the author can store state that one wouldn't store in the URL because it only applies to the current Document instance and it would have to be reconstructed if a new Document were opened.
</li>
</ul>

<p>
後者の用例には、
次が挙げられる：
◎
An example of the latter would be＼
</p>
<ul>
	<li>
利用者が後へ戻るとき、［
以前に~animateしていた~popup `div$e を同じ所在から~animateする
］よう，精確に協調するよう追跡し続ける。
◎
something like keeping track of the precise coordinate from which a popup div was made to animate, so that if the user goes back, it can be made to animate to the same location.＼
</li>
	<li>
`~URL$内の情報に基づいて，［
~serverから~fetchされる~data
］の~cacheの中への~pointerを保っておいて、［
後へ戻る／先へ進む
］ときに，
その情報を再度~fetchせずに済むようにする。
◎
Or alternatively, it could be used to keep a pointer into a cache of data that would be fetched from the server based on the information in the URL, so that when going back and forward, the information doesn't have to be fetched again.
</li>
</ul>
</div>

<hr>

<p>
`~scroll復旧~mode@
は、
~UAが ある`~session履歴~entry$へ辿ったとき，
持続される~scroll位置（もしあれば）を復旧するべきかどうかを指示する。
それは、次のいずれかをとり得る：
◎
A scroll restoration mode indicates whether the user agent should restore the persisted scroll position (if any) when traversing to an entry. A scroll restoration mode is one of the following:
</p>
<dl class="def-list">
	<dt>`auto@l</dt>
	<dd>
~naviに際して~scroll位置を復旧する責務は、
~UAにある。
◎
The user agent is responsible for restoring the scroll position upon navigation.
</dd>

	<dt>`manual@l</dt>
	<dd>
~naviに際して~scroll位置を復旧する責務は、
~pageにある。
~UAは、
それを自動的に試みない。
◎
The page is responsible for restoring the scroll position and the user agent does not attempt to do so automatically
</dd>
</dl>

				</section>
				<section id="document-state">
<h5 title="Document state">7.4.1.2 文書~状態</h5>

<p>
`文書~状態@
は、
`~session履歴~entry$の内側にある状態
— `文書$を［
呈示する方法, 必要yな場合に作成し直す方法
］に関する状態 —
を保持する。
それは、
次に挙げるものからなる：
◎
Document state holds state inside a session history entry regarding how to present and, if necessary, recreate, a Document. It has:
</p>
<ul>
	<li>
<p>
`文書@dS
⇒
~NULL ／ `文書$
— 初期~時は ~NULL とする。
◎
A document, a Document or null, initially null.
</p>

<div id="note-bfcache" class="note">
<p>注記：
履歴~entryが`作動中な~entry$navであるとき、
~entryの`文書~状態$shE内に`文書$を有する。
しかしながら，
当の`文書$が`全部的に作動中$でないとき、
それを`破壊-＠~HTMLlifecycle#destroy-a-document$して資源を取り戻すこともアリになる。
そのような事例では、
この~itemは，~NULL化されることになる。
その場合、［
`~session履歴~entry$, その`文書~状態$shE
］内の［
`~URL$shEその他の~data
］が［
~UAが当の~entryへ辿る必要を見出した事例
］で［
元の`文書$が占めていた場に新たな`文書$を持ち込む
］ために利用される。
◎
When a history entry is active, it has a Document in its document state. However, when a Document is not fully active, it's possible for it to be destroyed to free resources. In such cases, this document item will be nulled out. The URL and other data in the session history entry and document state is then used to bring a new Document into being to take the place of the original, in the case where the user agent finds itself having to traverse to the entry.
</p>

<p>
当の`文書$が`破壊-＠~HTMLlifecycle#destroy-a-document$されて`ない場合^em、
`履歴を差分だけ辿る$間に，
`作動化し直され得る＠#reactivate-a-document$。
そのような`文書$を
~browserが格納する~cacheは、
`~BF~cache@
（ `bfcache^em
— <em lang="en">back-forward cache</em>
（または、
たぶん
“`blazingly fast cache＠https://bugzilla.mozilla.org/show_bug.cgi?id=274784"$en” ）
の略語）
と呼ばれることが多い。
◎
If the Document is not destroyed, then during history traversal, it can be reactivated. The cache in which browsers store such Documents is often called a back-forward cache, or bfcache (or perhaps "blazingly fast" cache).
</p>
</div>
	</li>
	<li>
`履歴~施策~容器@dS
⇒
~NULL ／ `施策~容器$
— 初期~時は ~NULL とする。
◎
A history policy container, a policy container or null, initially null.
</li>
	<li>
`要請~referrer@dS
⇒
`client^l ／ `no-referrer^l ／ `~URL$
— 初期~時は `client^l とする。
◎
A request referrer, which is "no-referrer", "client", or a URL, initially "client".
</li>
	<li>
<p>
`要請~referrer施策@dS
⇒
`~referrer施策$
— 初期~時は`既定の~referrer施策$とする。
◎
A request referrer policy, which is a referrer policy, initially the default referrer policy.
</p>

<p class="note">注記：
`要請~referrer施策$dSは、
`履歴~施策~容器$dSの`~referrer施策$pCとは別個である。
前者は，当の文書 `の^em ~fetch用に利用される一方で、
後者は，当の文書 `による^em 【当の文書から起動される】~fetchを制御する。
◎
The request referrer policy is distinct from the history policy container's referrer policy. The former is used for fetches of this document, whereas the latter controls fetches by this document.
</p>
	</li>
	<li>
`起動元~生成元@dS
⇒
~NULL ／ `生成元$
— 初期~時は ~NULL とする。
◎
An initiator origin, which is an origin or null, initially null.
</li>
	<li>
<p>
`生成元@dS
⇒
~NULL ／ `生成元$
— 初期~時は ~NULL とする。
◎
An origin, which is an origin or null, initially null.
</p>

<p class="note">注記：
これが
`about:^l ~schemeを伴う`文書$の`生成元$docに設定した生成元である。
それをここに格納するのは、
そのような`文書$を辿りの間に格納し直すときにも利用されるからである
— そのような文書は、
~networkを訪問することなく，局所的に構築し直されるので。
それはまた、
`~session履歴~entry$が`拡充-$し直される［
前, 後
］に生成元を比較するためにも利用される。
当の生成元が変更された場合、
`~navigable名$dSは~clearされる。
◎
This is the origin that we set "about:"-schemed Documents' origin to. We store it here because it is also used when restoring these Documents during traversal, since they are reconstructed locally without visiting the network. It is also used to compare the origin before and after the session history entry is repopulated. If the origins change, the navigable target name is cleared.
</p>
	</li>
	<li>
<p>
`~about基底~URL@dS
⇒
~NULL ／ `~URL$
— 初期~時は ~NULL とする。
◎
An about base URL, which is a URL or null, initially null.
</p>

<p class="note">注記：
これは、
`about:^l ~schemeを伴う`文書$用に限り拡充され，
そのような`文書$用の`~fallback基底~URL$を与えることになる。
それは、
起動元`文書$の`文書~基底~URL$の~snapshotを成す。
◎
This will be populated only for "about:"-schemed Documents and will be the fallback base URL for those Documents. It is a snapshot of the initiator Document's document base URL.
</p>
	</li>
	<li>
`入子な履歴~群@dS
⇒
`入子な履歴$たちが成す`~list$
— 初期~時は`空$とする。
◎
Nested histories, a list of nested histories, initially an empty list.
</li>
	<li>
<p>
`資源@dS
⇒
~NULL ／ 文字列 ／ `~POST資源$
— 初期~時は ~NULL とする。
◎
A resource, a string, POST resource or null, initially null.
</p>

<p class="note">注記：
文字列は、
~HTMLとして扱われる。
これは、
`~iframe~srcdoc文書$の~sourceを格納するために利用される。
◎
A string is treated as HTML. It's used to store the source of an iframe srcdoc document.
</p>
	</li>
	<li>
`再読込みは処理待ちか@dS
⇒
真偽値
— 初期~時は ~F とする。
◎
A reload pending boolean, initially false.
</li>
	<li>
`一度でも拡充されたか@dS
⇒
真偽値
— 初期~時は ~F とする。
◎
An ever populated boolean, initially false.
</li>
	<li>
`~navigable名@dS
⇒
文字列
— 初期~時は空~文字列とする。
◎
A navigable target name string, initially the empty string.
</li>
	<li>
`復旧されない事由~群@dS
⇒
~NULL ／ `復旧されない事由~群$
— 初期~時は~NULLとする。
◎
A not restored reasons, a not restored reasons or null, initially null.
</li>
</ul>

<p>
~UAは、
`文書~状態$の`文書$dS（ ~NEQ ~NULL とする）が`全部的に作動中$でない間は，
当の`文書とその子孫たちを破壊-＠~HTMLlifecycle#destroy-a-document-and-its-descendants$してもヨイ。
◎
User agents may destroy a document and its descendants given the documents of document states with non-null documents, as long as the Document is not fully active.
</p>

<p>
その制約【`全部的に作動中$である間】は別として、
この標準は，~UAが`文書~状態$内に格納した`文書$dSを［
いつまで~cache内に保つべきか, いつ破壊するべきか
］については指定しない。
◎
Apart from that restriction, this standard does not specify when user agents should destroy the document stored in a document state, versus keeping it cached.
</p>

<hr>

<p>
`~POST資源@
は、
次に挙げるものを有する：
◎
A POST resource has:
</p>
<ul>
	<li>
<p>
`要請~本体@pR
⇒
`失敗^i ／`~byte列$
◎
A request body, a byte sequence or failure.
</p>

<p>
これは，`並列的$にしか~accessされないので、
この~byte列は，~memory内に格納される必要は無い。
しかしながら、
毎回~同じ`~byte列$を返すモノトスル。
~disk上の資源が［
変化した／もはや~accessできなくなった
］ことに因り，これがアリでない場合、
`失敗^i に設定するモノトスル。
◎
This is only ever accessed in parallel, so it doesn't need to be stored in memory. However, it must return the same byte sequence each time. If this isn't possible due to resources changing on disk, or if resources can no longer be accessed, then this must be set to failure.
</p>
	</li>
	<li>
`要請~内容~型@pR
⇒
次に挙げるいずれか
⇒＃
``^`application/x-www-form-urlencoded$mt``^ ／
``^`multipart/form-data$mt``^ ／
``^`text/plain$mt``^
◎
A request content-type, which is `application/x-www-form-urlencoded`, `multipart/form-data`, or `text/plain`.
</li>
</ul>

<hr>

<p>
`入子な履歴@
は、
次に挙げるものを有する：
◎
A nested history has:
</p>
<ul>
	<li>
<p>
`~ID@nH
⇒
`一意かつ内部的な値$
◎
An id, a unique internal value.
</p>

<p class="note">注記：
これは、
`入子な履歴$を`~navigable$に結付けるために利用される。
◎
This is used to associate the nested history with a navigable.
</p>
	</li>
	<li>
`~entry群@nH
⇒
`~session履歴~entry$たちが成す`~list$
◎
Entries, a list of session history entries.
</li>
</ul>

<p class="XXX">
これは、
後で［
何回かの再読込みにまたがって`子~navigable$を識別する仕方
］を包含することになる。
◎
This will later contain ways to identify a child navigable across reloads.
</p>

<hr>

<p>
~session履歴~内の［
連続的な~entryたち
］は、
同じ`文書~状態$shEを共有し得る。
これが生じ得るのは、
通常の`~navi$を介して初期~entryに達してから［
それに後続する~entryが `history.pushState()$c を介して追加されたとき
］である。
あるいは、
`素片への~navi$を介しても生じ得る。
◎
Several contiguous entries in a session history can share the same document state. This can occur when the initial entry is reached via normal navigation, and the following entry is added via history.pushState(). Or it can occur via navigation to a fragment.
</p>

<p class="note">注記：
同じ`文書~状態$shEを共有している すべての~entryは、
構築により連続的になる
（それらは、
単に，特定0の文書の異なる状態たちを成す）。
◎
All entries that share the same document state (and that are therefore merely different states of one particular document) are contiguous by construction.
</p>

<hr>

<p>
各`文書$は、
`最近の~entry@
を有する
— それは、［
~NULL ／ ある`~session履歴~entry$
］である。
【初期~時は ~NULL であろう。】
◎
A Document has a latest entry, a session history entry or null.
</p>

<p class="note">注記：
これは、
当の`文書$により最も近過去に表現された~entryを指す。
同じ`文書$は、
時間~越しに，多くの`~session履歴~entry$を表現し得る
— 上に説明したとおり、
連続的な`~session履歴~entry$たちは，同じ`文書~状態$shEを共有し得るので。
◎
This is the entry that was most recently represented by a given Document. A single Document can represent many session history entries over time, as many contiguous session history entries can share the same document state as explained above.
</p>

				</section>
				<section id="centralized-modifications-of-session-history">
<h5 title="Centralized modifications of session history">7.4.1.3. ~session履歴に対する改変の一極化</h5>

<p>
“真実を成す~sourceは一つだけ” を保守するため、
`辿可能な~navigable$の`~session履歴~entry群$navに対する すべての改変は，
同期される必要がある。
これは［
~session履歴が，すべての子孫`~navigable$により
— したがって複数の`~event~loop$により —
どう波及されるか
］に因り，とりわけ重要になる。
これを成遂げるため、
`~session履歴~辿り並列~queue$構造が利用される。
◎
To maintain a single source of truth, all modifications to a traversable navigable's session history entries need to be synchronized. This is especially important due to how session history is influenced by all of the descendant navigables, and thus by multiple event loops. To accomplish this, we use the session history traversal parallel queue structure.
</p>

<p>
`~session履歴~辿り並列~queue@
は、
`並列~queue$に ごく類似する。
それは、
`~algo集合@shTP
を有する。
◎
A session history traversal parallel queue is very similar to a parallel queue. It has an algorithm set, an ordered set.
◎
↓</p>

<p>
この`~algo集合$shTPは、
`有順序~集合$であり，それを成す各`~item$は、［
~algo手続き／
`同期的な~navi手続き@shTP
］いずれかである
— 後者は、［
ある`~navigable$
`~target~navigable@shTP
］を孕んでいる~~特殊な~algo手続きである。
◎
The items in a session history traversal parallel queue's algorithm set are either algorithm steps, or synchronous navigation steps, which are a particular brand of algorithm steps involving a target navigable (a navigable).
</p>

<div class="algo">
<p>
`~session履歴~辿り手続きを付加する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, ~algo手続き %手続き )
に対し
⇒
%辿可能 の`~session履歴~辿り~queue$navの`~algo集合$shTPに %手続き を`付加する$
◎
To append session history traversal steps to a traversable navigable traversable given algorithm steps steps, append steps to traversable's session history traversal queue's algorithm set.
</p>
</div>

<div class="algo">
<p>
ある`~navigable$ %~target~navigable を孕んでいる
`~session履歴~同期~navi手続きを付加する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, ~algo手続き %手続き )
に対し
⇒
%辿可能 の`~session履歴~辿り~queue$navの`~algo集合$shTPに［
`~target~navigable$shTP %~target~navigable を~targetにしている†`同期的な~navi手続き$shTP
］として %手続き を`付加する$
【† %手続き は %~target~navigable を “孕んでいる” とされる。】
◎
To append session history synchronous navigation steps involving a navigable targetNavigable to a traversable navigable traversable given algorithm steps steps, append steps as synchronous navigation steps targeting target navigable targetNavigable to traversable's session history traversal queue's algorithm set.
</p>
</div>

<div class="algo">
<p id="session-history-event-loop">
`新たな~session履歴~辿り並列~queueを開始する@
~algoは：
◎
To start a new session history traversal parallel queue:
</p>
<ol>
	<li>
%~session履歴~辿り~queue ~LET 新たな`~session履歴~辿り並列~queue$
◎
Let sessionHistoryTraversalQueue be a new session history traversal parallel queue.
</li>
	<li class="algo">
<p>
この段は、
`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
				<ol>
					<li>
%手続き ~LET %~session履歴~辿り~queue の`~algo集合$shTPから`~dequeueする$
◎
↓</li>
					<li>
~IF［
%手続き ~EQ ε
］
⇒
~CONTINUE
◎
If sessionHistoryTraversalQueue's algorithm set is empty, then continue.
◎
Let steps be the result of dequeuing from sessionHistoryTraversalQueue's algorithm set.
</li>
					<li>
%手続き()
◎
Run steps.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~session履歴~辿り~queue
◎
Return sessionHistoryTraversalQueue.
</li>
</ol>
</div>

<p id="sync-navigation-steps-queue-jumping-examples">
`同期的な~navi手続き$shTPは、
条件付きで “~queueを~jumpする” ことを許容するため，
`~algo集合$shTP内で そうであるものと~tag付けられる。
これは、
`履歴~stepを適用する手続きの中＠#sync-navigations-jump-queue$で取扱われる。
◎
Synchronous navigation steps are tagged in the algorithm set to allow them to conditionally "jump the queue". This is handled within apply the history step.
</p>

<div id="example-sync-navigation-steps-queue-jumping-basic" class="example">
<p>
次の`~Jake図式$により図画化される【！joint】~session履歴を想像してみる：
◎
Imagine the joint session history depicted by this Jake diagram:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step current">1
<tbody>

<tr><th>`top^c
<td colspan="1" class="doc-0">`/a^c
<td colspan="1" class="doc-1 current">`/b^c
</table>

<p>
~top-levelにて，次の~codeを走らせたとする：
◎
And the following code runs at the top level:
</p>

<pre class="lang-js">
history.back();
location.href = '#foo';
</pre>

<p>
欲される結果は：
◎
The desired result is:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step current">0
<th class="step">1
<th class="step">2
<tbody>

<tr><th>`top^c
<td colspan="1" class="doc-0 current">`/a^c
<td colspan="1" class="doc-1 next-is-same-doc">`/b^c
<td colspan="1" class="doc-1 prev-is-same-doc">`/b#foo^c
</table>

<p>
これは、
単直ではない
— 同期c~naviは，観測-可能になる~~順序において競争に勝つ一方で、
辿りは，手続きを`~session履歴~辿り並列~queue$に~queueする~~順序において競争に勝つので。
この結果を達成するため、
次が起こる：
◎
This isn't straightforward, as the sync navigation wins the race in terms of being observable, whereas the traversal wins the race in terms of queuing steps on the session history traversal parallel queue. To achieve this result, the following happens:
</p>
<ol>
	<li>
`history.back()＠~WINDOW#dom-history-back$m は、
差分 −1 だけ辿るよう意図された`手続きを付加する＠#tn-append-session-history-traversal-steps$。
◎
history.back() appends steps intended to traverse by a delta of −1.
</li>
	<li>
`location.href = '#foo'＠~WINDOW#dom-location-href$c は、
`作動中な~entry$navを［
~URL `/b#foo^c を伴う新たな~entry
］に同期的に変更することに加え，［
その新たな~entryについて， “真実を成す~source” に通知する
］ために`同期的な手続きを付加する＠#tn-append-session-history-sync-nav-steps$。
これは、［
`現在の~session履歴~entry$nav,
`現在の~session履歴~step$nav,
`~session履歴~entry群$nav
］を`まだ更新しない^emことに注意。
それらの更新は、
同期的には行い得ない
— 代わりに，~queueされた手続きの一部として行われなければならない。
◎
location.href = '#foo' synchronously changes the active session history entry entry to a newly-created one, with the URL /b#foo, and appends synchronous steps to notify the central source of truth about that new entry. Note that this does not yet update the current session history entry, current session history step, or the session history entries list; those updates cannot be done synchronously, and instead must be done as part of the queued steps.
</li>
	<li>
<p>
`~session履歴~辿り並列~queue$上で，
`history.back()＠~WINDOW#dom-history-back$m により~queueされた手続きを走らす：
◎
On the session history traversal parallel queue, the steps queued by history.back() run:
</p>
		<ol>
			<li>
~target履歴~stepは、［
`現在の~session履歴~step$nav（すなわち 1 ） ~PLUS 意図された差分（すなわち −1 ）
］ ~EQ 0 に決定される。
◎
The target history step is determined to be 0: the current session history step (i.e., 1) plus the intended delta of −1.
</li>
			<li>
<p>
~mainな`履歴~stepを適用する$~algoに入る。
◎
We enter the main apply the history step algorithm.
</p>

<p>
~step 0 における~URL `/a^c 用の~entryの`文書$shEが`拡充-$される。
◎
The entry at step 0, for the /a URL, has its document populated.
</p>

<p>
そうしている間に、
当の~queueが`同期的な~navi手続き$shTP用に検査される。
今や，
`location.href＠~WINDOW#dom-location-href$c 設定子により~queueされた手続きが走る
— それが完遂するまで、
辿りが文書の拡充を超える効果
（文書を~unloadする, 作動中な履歴~entryを切替える, など）
を遂行することは阻まれる。
それらの手続きは、
次が起こるようにする：
◎
Meanwhile, the queue is checked for synchronous navigation steps. The steps queued by the location.href setter now run, and block the traversal from performing effects beyond document population (such as, unloading documents and switching active history entries) until they are finished. Those steps cause the following to happen:
</p>
		<ol>
			<li>
~URL `/b#foo^c を伴う~entryが追加され、
その`~step$shEは，［
`現在の~session履歴~step$nav（すなわち 1 ） ~PLUS 1
］ ~EQ 2
に決定される。
◎
The entry with URL /b#foo is added, with its step determined to be 2: the current session history step (i.e., 1) plus 1.
</li>
			<li>
新たに追加された~entryへ全部的に切替える
— `履歴~stepを適用する$ために入子にされた~callも含めて。
これは、
最終的に `hashchange$et 様な~eventを配送することにより，
`文書を更新する＠#update-document-for-history-step-application$結果になる。
◎
We fully switch to that newly added entry, including a nested call to apply the history step. This ultimately results in updating the document by dispatching events like hashchange.
</li>
	</ol>

<p>
これらが すべて完了して，
履歴~entry `/a^c が`文書$shEで全部的に拡充されたなら、
所与の~target~step 0 の下で履歴~stepを適用する~~処理にとりかかる。
◎
Only once that is all complete, and the /a history entry has been fully populated with a document, do we move on with applying the history step given the target step of 0.
</p>

<p>
この時点で、
~URL `/b#foo^c を伴う`文書$は`~unloadされ＠~HTMLlifecycle#unload-a-document$，
~target履歴~step 0 への移動は完遂する
— その結果、
~URL `/a^c を伴う~entryが`作動中な~entry$navになり，
`現在の~session履歴~step$navは 0 になる。
◎
At this point, the Document with URL /b#foo unloads, and we finish moving to our target history step 0, which makes the entry with URL /a become the active session history entry and 0 become the current session history step.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

<div id="example-sync-navigation-steps-queue-jumping-complex" class="example">
<p>
別の もっと複階的な例。
これは、
2 つの異なる`子~navigable$
（ 2 つの `iframe$e `frames[0]^c, `frames[1]^c ）
に対し，［
それらを拡充すること
］と［
うち一方が読込まれたときの同期的な~navi
］との間における競争を孕んでいる。
次のように設定しておかれた所から開始する：
◎
Here is another more complex example, involving races between populating two different iframes, and a synchronous navigation once one of those iframes loads. We start with this setup:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step">1
<th class="step current">2
<tbody>

<tr><th>`top^c
<td colspan="3" class="doc-0 current">`/t^c

<tr><th>`frames[0]^c
<td colspan="1" class="doc-1">`/i-0-a^c
<td colspan="2" class="doc-2 current">`/i-0-b^c

<tr><th>`frames[1]^c
<td colspan="2" class="doc-3">`/i-1-a^c
<td colspan="1" class="doc-4 current">`/i-1-b^c
</table>

<p>
`history.go(-2)＠~WINDOW#dom-history-go$c を~callしたとすると、
次が生じる：
◎
and then call history.go(-2). The following then occurs:
</p>
<ol>
	<li>
<p>
`history.go(-2)^c は、
差分 −2 だけ辿るよう意図された`手続きを付加する＠#tn-append-session-history-traversal-steps$。
その手続きが走ったなら：
◎
history.go(-2) appends steps intended to traverse by a delta of −2. Once those steps run:
</p>
		<ol>
			<li>
~target~stepは、［
2 ~PLUS −2
］ ~EQ 0 に決定される。
◎
The target step is determined to be 2 + (−2) = 0.
</li>
			<li>
<p>
2 つの~iframeを並列的に`拡充-$するため，［
`/i-0-a^c, `/i-1-a^c
］への~fetchが為される。
◎
In parallel, the fetches are made to populate the two iframes, fetching /i-0-a and /i-1-a respectively.
</p>

<p>
そうしている間に，`同期的な~navi手続き$shTP用に~queueが検査される。
今の所、
そのような手続きは無い。
◎
Meanwhile, the queue is checked for synchronous navigation steps. There aren't any right now.
</p>
			</li>
			<li>
`/i-0-a^c への~fetchが，~fetch競争に勝ったとする。
`履歴~stepを適用する$作業~すべてを完遂するよう，以降を続行する
— この作業には、
当の辿りが`~navigable$ `frames[0]^c にどう影響iするか
— そこで`作動中な~entry$navを~URL `/i-0-a^c を伴う~entryに更新するなど —
も含まれる。
◎
In the fetch race, the fetch for /i-0-a wins. We proceed onward to finish all of apply the history step's work for how the traversal impacts the frames[0] navigable, including updating its active session history entry to the entry with URL /i-0-a.
</li>
			<li>
<p>
`/i-1-a^c への~fetchが完遂する前に，［
`~navigable$ `frames[0]^c にて`作動中な文書$navにおいて，
新たな文書~用に`~scriptを走らせてもよい$地点
］に達する。
そのような~scriptのうち一部は、
そこで走る：
◎
Before the fetch for /i-1-a finishes, we reach the point where scripts may run for the newly-created document in the frames[0] navigable's active document. Some such script does run:
</p>

<pre class="lang-js">
location.href = '#foo'
</pre>

<p>
これは、
~navigable `frames[0]^c にて`作動中な~entry$navを同期的に［
~URL `/i-0-a#foo^c を伴う新たに作成された~entry
］に変更した上で、
その新たな~entryについて “真実を成す~source” に通知するため，
`同期的な手続きを付加する＠#tn-append-session-history-sync-nav-steps$。
◎
This synchronously changes the frames[0] navigable's active session history entry entry to a newly-created one, with the URL /i-0-a#foo, and appends synchronous steps to notify the central source of truth about that new entry.
</p>

<p>
`以前の例＠#example-sync-navigation-steps-queue-jumping-basic$と違って、
この同期的な手続きは，
`“~queueを~jump” しない^em
— `/i-1-a^c への~fetchを完遂する前に，`辿可能な~navigable$（ `top^c ）を更新する。
何故なら、［
~navigable `frames[0]^c は，辿りの一部として すでに改められた
］ので［
その`現在の~session履歴~step$navは 2 であり，
~step 3 として新たな~entryを追加してもイミを成さない
］ことが知れるからである。
◎
Unlike in the previous example, these synchronous steps do not "jump the queue" and update the traversable before we finish the fetch for /i-1-a. This is because the navigable in question, frames[0], has already been altered as part of the traversal, so we know that with the current session history step being 2, adding the new entry as a step 3 doesn't make sense.
</p>
			</li>
			<li>
`/i-1-a^c への~fetchを完遂したなら、
辿り用に`~navigable$ `frames[1]^c を更新する~~処理を完遂するよう続行する
— これには、
そこで`作動中な~entry$navを［
~URL `/i-1-a^c を伴う~entry
］に更新することも含まれる。
◎
Once the fetch for /i-1-a finally finishes, we proceed to finish updating the frames[1] navigable for the traversal, including updating its active session history entry to the entry with URL /i-1-a.
</li>
			<li>
今や、
両~navigableとも辿りの処理を完遂した。
`現在の~session履歴~step$navを~target~step 0 に更新する。
◎
Now that both navigables have finished processing the traversal, we update the current session history step to the target step of 0.
</li>
		</ol>
	</li>
	<li>
<p>
今や、
同期的な~navi用に~queueした手続きを処理できる：
◎
Now we can process the steps that were queued for the synchronous navigation:
</p>
		<ol>
			<li>
新たな~entry `/i-0-a#foo^c が追加される
— その`~step$shE は、［
`現在の~session履歴~step$nav（すなわち 0 ） ~PLUS 1
］ ~EQ 1 に決定される。
これはまた、
既存の`前方~session履歴を~clearする$。
◎
The /i-0-a#foo entry is added, with its step determined to be 1: the current session history step (i.e., 0) plus 1. This also clears existing forward history.
</li>
			<li>
追加された新たな~entryへ全部的に切替える
— `履歴~stepを適用する$ことも含めて。
これは、
最終的に［
`hashchange$et 様な~eventを配送することにより，
`文書を更新する＠#update-document-for-history-step-application$
］ことに加え［
`現在の~session履歴~step$navを~target~step 1 に更新する
］結果になる。
◎
We fully switch to that newly added entry, including calling apply the history step. This ultimately results in updating the document by dispatching events like hashchange, as well as updating the current session history step to the target step of 1.
</li>
		</ol>
	</li>
</ol>

<p>
最終~結果は：
◎
The end result is:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step current">1
<tbody>

<tr><th>`top^c
<td colspan="2" class="doc-0 current">`/t^c

<tr><th>`frames[0]^c
<td colspan="1" class="doc-1 next-is-same-doc">`/i-0-a^c
<td colspan="1" class="doc-1 current prev-is-same-doc">`/i-0-a#foo^c

<tr><th>`frames[1]^c
<td colspan="2" class="doc-3 current">`/i-1-a^c
</table>
</div>

				</section>
				<section id="low-level-operations-on-session-history">
<h5 title="Low-level operations on session history">7.4.1.4. ~session履歴に対する低-~levelな演算</h5>

<p>
この節は、
諸々の演算を包含する
— それらは、
この標準~全体を通して，~session履歴を操作するときに遂行される。
それらが何を行っているか捉える最良な仕方は、
その~call元を調べることである。
◎
This section contains a miscellaneous grab-bag of operations that we perform throughout the standard when manipulating session history. The best way to get a sense of what they do is to look at their call sites.
</p>

<div class="algo">
<p>
`~session履歴~entry群を取得する@
~algoは、
所与の
( `~navigable$ %~navigable )
に対し：
◎
To get session history entries of a navigable navigable:
</p>
<ol>
	<li>
%辿可能 ~LET %~navigable の`辿可能な~navigable$nav
◎
Let traversable be navigable's traversable navigable.
</li>
	<li>
~Assert：
これは、
%辿可能 の`~session履歴~辿り~queue$navの中で走っている。
◎
Assert: this is running within traversable's session history traversal queue.
</li>
	<li>
~IF［
%~navigable ~EQ %辿可能
］
⇒
~RET %辿可能 の`~session履歴~entry群$nav
◎
If navigable is traversable, return traversable's session history entries.
</li>
	<li>
<p>
%文書~状態~群 ~LET 新たな`有順序~集合$
（`文書~状態$たち）
</p>

<p class="trans-note">【
この集合を成す`文書~状態$どうしの比較が何に基づくか，はっきりしない。
】</p>
◎
Let docStates be an empty ordered set of document states.
</li>
	<li>
%辿可能 の`~session履歴~entry群$navを成す
~EACH( %~entry )
に対し
⇒
%文書~状態~群 に %~entry の`文書~状態$shEを`付加する$set
◎
For each entry of traversable's session history entries, append entry's document state to docStates.
</li>
	<li>
<p>
%文書~状態~群 を成す
~EACH( %文書~状態 )
に対し：
◎
For each docState of docStates:
</p>
		<ol>
			<li>
<p>
%文書~状態 の`入子な履歴~群$dSを成す
~EACH( %入子な履歴 )
に対し：
◎
For each nestedHistory of docState's nested histories:
</p>
				<ol>
					<li>
~IF［
%入子な履歴 の`~ID$nH ~EQ %~navigable の`~ID$nav
］
⇒
~RET %入子な履歴 の`~entry群$nH
◎
If nestedHistory's id equals navigable's id, return nestedHistory's entries.
</li>
					<li>
%入子な履歴 の`~entry群$nHを成す
~EACH( %~entry )
に対し
⇒
%文書~状態~群 に %~entry の`文書~状態$shEを`付加する$set
◎
For each entry of nestedHistory's entries, append entry's document state to docStates.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~Assert：
この段に達することはない。
◎
Assert: this step is not reached.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navi~API用に~session履歴~entry群を取得する@
~algoは、
所与の
( `~navigable$ %~navigable, 整数 %~target~step )
に対し：
◎
To get session history entries for the navigation API of a navigable navigable given an integer targetStep:
</p>
<ol>
	<li>
%生の~entry群 ~LET `~session履歴~entry群を取得する$( %~navigable )
◎
Let rawEntries be the result of getting session history entries for navigable.
</li>
	<li>
%~navi~API用の~entry群 ~LET 新たな`~list$
◎
Let entriesForNavigationAPI be a new empty list.
</li>
	<li>
%開始-時の~index ~LET −1
◎
↓</li>
	<li>
<p>
%生の~entry群 を成す
~EACH( `~session履歴~entry$ %~entry )
に対し
⇒
~IF［
%~entry の`~step$shE ~LTE %~target~step
］
⇒
%開始-時の~index ~SET `max^op( %開始-時の~index, %~entry の`~step$shE )
◎
Let startingIndex be the index of the session history entry in rawEntries who has the greatest step less than or equal to targetStep.
</p>

<p class="note">注記：
なぜ %~target~step 以下の最~大な~stepにするか理解するためには、
`この例＠#example-getting-the-target-history-entry$を見よ。
◎
See this example to understand why it's the greatest step less than or equal to targetStep.
</p>

	</li>
	<li>
<p>
~Assert：
%開始-時の~index ~GTE 0
</p>

<p class="trans-note">【
この段は、
この訳による補完
（満たされない場合、以下を遂行し得ない）。
】</p>
	</li>
	<li>
%~navi~API用の~entry群 に %生の~entry群[ %開始-時の~index ] を`付加する$
◎
Append rawEntries[startingIndex] to entriesForNavigationAPI.
</li>
	<li>
%開始-時の生成元 ~LET %生の~entry群[ %開始-時の~index ] の`文書~状態$shEの`生成元$dS
◎
Let startingOrigin be rawEntries[startingIndex]'s document state's origin.
</li>
	<li>
%~index ~LET %開始-時の~index ~MINUS 1
◎
Let i be startingIndex − 1.
</li>
	<li>
<p>
~WHILE［
%~index ~GT 0
］
◎
While i &gt; 0:
</p>
		<ol>
			<li>
~IF［
%生の~entry群[ %~index ] の`文書~状態$shEの`生成元$dS
~NEQ`生成元$sub
%開始-時の生成元
］
⇒
~BREAK
◎
If rawEntries[i]'s document state's origin is not same origin with startingOrigin, then break.
</li>
			<li>
%~navi~API用の~entry群 に %生の~entry群[ %~index ] を`前付加する$
◎
Prepend rawEntries[i] to entriesForNavigationAPI.
</li>
			<li>
%~index ~DECBY 1
◎
Set i to i − 1.
</li>
		</ol>
	</li>
	<li>
%~index ~SET %開始-時の~index ~PLUS 1
◎
Set i to startingIndex + 1.
</li>
	<li>
<p>
~WHILE［
%~index ~LT %生の~entry群 の`~size$
］：
◎
While i &lt; rawEntries's size:
</p>
		<ol>
			<li>
~IF［
%生の~entry群[ %~index ] の`文書~状態$shEの`生成元$dS
~NEQ`生成元$sub
%開始-時の生成元
］
⇒
~BREAK
◎
If rawEntries[i]'s document state's origin is not same origin with startingOrigin, then break.
</li>
			<li>
%~navi~API用の~entry群 に %生の~entry群[ %~index ] を`付加する$
◎
Append rawEntries[i] to entriesForNavigationAPI.
</li>
			<li>
%~index ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
~RET %~navi~API用の~entry群
◎
Return entriesForNavigationAPI.
</li>
</ol>
</div>

<div class="algo">
<p>
`前方~session履歴を~clearする@
~algoは、
所与の
( `辿可能な~navigable$ %~navigable )
に対し：
◎
To clear the forward session history of a traversable navigable navigable:
</p>
<ol>
	<li>
~Assert：
これは
%~navigable の`~session履歴~辿り~queue$navの中で走っている。
◎
Assert: this is running within navigable's session history traversal queue.
</li>
	<li>
%~step ~LET %~navigable の`現在の~session履歴~step$nav
◎
Let step be the navigable's current session history step.
</li>
	<li>
%~entry~list群 ~LET `有順序~集合$ « %~navigable の`~session履歴~entry群$nav »
◎
Let entryLists be the ordered set « navigable's session history entries ».
</li>
	<li>
<p>
%~entry~list群 を成す
~EACH( %~entry~list )
に対し：
◎
For each entryList of entryLists:
</p>
		<ol>
			<li>
%~entry~list から次を満たす`~session履歴~entry$をすべて`除去する$
⇒
`~step$shE ~GT %~step
◎
Remove every session history entry from entryList that has a step greater than step.
</li>
			<li>
%~entry~list を成す
~EACH( %~entry )
に対し
⇒
%~entry の`文書~状態$shEの`入子な履歴~群$dSを成す
~EACH( %入子な履歴 )
に対し
⇒
%~entry~list群 に %入子な履歴 の`~entry群$nHを`付加する$set
◎
For each entry of entryList:
• For each nestedHistory of entry's document state's nested histories, append nestedHistory's entries list to entryLists.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`利用されたすべての履歴~stepを取得する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能 )
に対し：
◎
To get all used history steps that are part of traversable navigable traversable:
</p>
<ol>
	<li>
~Assert：
これは、
%辿可能 の`~session履歴~辿り~queue$navの中で走っている。
◎
Assert: this is running within traversable's session history traversal queue.
</li>
	<li>
%~step群 ~LET 新たな`有順序~集合$
（負でない整数たち）
◎
Let steps be an empty ordered set of non-negative integers.
</li>
	<li>
%~entry~list群 ~LET `有順序~集合$ « %辿可能 の`~session履歴~entry群$nav »
◎
Let entryLists be the ordered set « traversable's session history entries ».
</li>
	<li>
<p>
%~entry~list群 を成す
~EACH( %~entry~list )
に対し：
◎
For each entryList of entryLists:
</p>
		<ol>
			<li>
<p>
%~entry~list を成す
~EACH( %~entry )
に対し：
◎
For each entry of entryList:
</p>
				<ol>
					<li>
%~step群 に %~entry の`~step$shEを`付加する$set
◎
Append entry's step to steps.
</li>
					<li>
%~entry の`文書~状態$shEの`入子な履歴~群$dSを成す
~EACH( %入子な履歴 )
に対し
⇒
%~entry~list群 に %入子な履歴 の`~entry群$nHを`付加する$set
◎
For each nestedHistory of entry's document state's nested histories, append nestedHistory's entries list to entryLists.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `~listを昇順に~sortする$( %~step群 )
◎
Return steps, sorted.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="navigating-across-documents">
<h4 title="Navigation">7.4.2. ~navi</h4>

<p>
ある種の動作は、
`~navigable$を新たな資源へ`~navigate$させる。
◎
Certain actions cause a navigable to navigate to a new resource.
</p>

<p class="example">
例えば、
次が挙げられる：
⇒＃
`~hyperlinkを追う$とき／
`~form提出$／
`window.open()＠~WINDOW#dom-window-open$c ~method／
`location.assign()＠~WINDOW#dom-location-assign$c ~method
◎
For example, following a hyperlink, form submission, and the window.open() and location.assign() methods can all cause navigation.
</p>

<div class="note">
<p id="note-meaning-of-navigate">注記：
この標準においては、
語 “~navi” は，特定的に`~navi~algo$を指すが、
~web［
開発者／利用者
］の~~認識と常に一致してはいない。
例えば：
◎
Although in this standard the word "navigation" refers specifically to the navigate algorithm, this doesn't always line up with web developer or user perceptions. For example:
</p>
<ul>
	<li>
`~URLと履歴の更新$は、
いわゆる［
“単-~page~appにおける~navi” ／ “同一-文書における~navi”
］の間に利用されることが多いが、
それらは，`~navi~algo$を誘発しない。
◎
The URL and history update steps are often used during so-called "single-page app navigations" or "same-document navigations", but they do not trigger the navigate algorithm.
</li>
	<li>
`再読込み＠#reload$と`履歴の辿り$は、
ときには，~naviの一種として話される
— 【ここに挙げた】 3 つすべては，
履歴~entryの文書を`拡充-$しようと試みることが多く、
したがって，~navi的な~fetchを遂行することもあるので
（例： `NAVIGATIONTIMING$r により公開される~APIを見よ）。
が，それらは、
`~navi~algo$とは別々な，自前の入口~algoを備える。
◎
Reloads and traversals are sometimes talked about as a type of navigation, since all three will often attempt to populate the history entry's document and thus could perform navigational fetches. See, e.g., the APIs exposed Navigation Timing. But they have their own entry point algorithms, separate from the navigate algorithm. [NAVIGATIONTIMING]
</li>
	<li>
`素片への~navi$は，
常に`~navi~algo$を通して行われるが、
利用者は，それを真の~naviでなく同じ~page内を~jumpして巡っている様に知覚するかもしれない。
◎
Although fragment navigations are always done through the navigate algorithm, a user might perceive them as more like jumping around a single page, than as a true navigation.
</li>
</ul>
</div>

				<section id="navigation-supporting-concepts">
<h5 title="Supporting concepts">7.4.2.1 ~support用の概念</h5>

<p>
`~navi~algo$にとりかかる前に、
それが利用する重要な構造をいくつか確立する必要がある。
◎
Before we can jump into the navigation algorithm itself, we need to establish several important structures that it uses.
</p>

<p>
`~source~snapshot~params@
は、［
~naviを起動している`文書$の~dataを捕捉する
］ために利用される`構造体$である。
それは、
~naviが始まるに伴い~snapshotされ，
~naviの存続期間~全体を通して利用される。
それは、
次に挙げる`~item$sctからなる：
◎
The source snapshot params struct is used to capture data from a Document initiating a navigation. It is snapshotted at the beginning of a navigation and used throughout the navigation's lifetime. It has the following items:
</p>

<ul>
	<li>
`一過な作動化を有するか@ssP
⇒
真偽値
◎
has transient activation
• a boolean
</li>
	<li>
`~sandbox法~flag群@ssP
⇒
`~sandbox法~flag集合$
◎
sandboxing flags
• a sandboxing flag set
</li>
	<li>
`~downloadを許容するか@ssP
⇒
真偽値
◎
allows downloading
• a boolean
</li>
	<li>
`~fetch~client@ssP
⇒
~NULL ／`環境~設定群~obj$
— これは、
【要請の】`~client$rqにしか利用されない。
◎
fetch client
• an environment settings object or null, only to be used as a request client
</li>
	<li>
`~source施策~容器@ssP
⇒
`施策~容器$
◎
source policy container
• a policy container
</li>
</ul>

<div class="algo">
<p>
`~source~snapshot~paramsを~snapshotする@
~algoは、
所与の
( ［
~NULL ／ `文書$
］ %~source文書 )
に対し：
◎
To snapshot source snapshot params given a Document-or-null sourceDocument:
</p>
<ol>
	<li>
<p>
~IF［
%~source文書 ~EQ ~NULL
］
⇒
~RET 新たな`~source~snapshot~params$
— その
⇒＃
`一過な作動化を有するか$ssP ~SET ~T,
`~sandbox法~flag群$ssP ~SET 空な`~sandbox法~flag集合$,
`~downloadを許容するか$ssP ~SET ~T,
`~fetch~client$ssP ~SET ~NULL,
`~source施策~容器$ssP ~SET 新たな `施策~容器$
◎
If sourceDocument is null, then return a new source snapshot params with
◎
has transient activation
• true
sandboxing flags
• an empty sandboxing flag set
allows downloading
• true
fetch client
• null
source policy container
• a new policy container
</p>

<p class="note">注記：
これは、
~browser~UIが起動した~naviの事例で`しか生じない＠#assert-null-sourcedocument$。
◎
This only occurs in the case of a browser UI-initiated navigation.
</p>
	</li>
	<li>
~RET 新たな`~source~snapshot~params$
— その
⇒＃
`一過な作動化を有するか$ssP ~SET ~IS［ %~source文書 に`関連な大域~obj$は`一過な作動化を有して$いる］,
`~sandbox法~flag群$ssP ~SET %~source文書 にて`作動中な~sandbox法~flag集合$,
`~downloadを許容するか$ssP ~SET ~IS［ `閲覧~文脈~sandbox化( ~download )~flag$ ~NIN %~source文書 にて`作動中な~sandbox法~flag集合$］,
`~fetch~client$ssP ~SET %~source文書 に`関連な設定群~obj$,
`~source施策~容器$ssP ~SET `施策~容器を~cloneする$( %~source文書 の`施策~容器$doc )
◎
Return a new source snapshot params with
◎
has transient activation
• true if sourceDocument's relevant global object has transient activation; otherwise false
sandboxing flags
• sourceDocument's active sandboxing flag set
allows downloading
• false if sourceDocument's active sandboxing flag set has the sandboxed downloads browsing context flag set; otherwise true
fetch client
• sourceDocument's relevant settings object
source policy container
• a clone of sourceDocument's policy container
</li>
</ol>
</div>

<hr>

<p>
`~target~snapshot~params@
は、［
~navigateされている`~navigable$の~dataを捕捉する
］ために利用される`構造体$である。
`~source~snapshot~params$と同様に、
それは，
~naviが始まるに伴い~snapshotされ，
~naviの存続期間~全体を通して利用される。
それは、
次に挙げる`~item$sctからなる：
◎
The target snapshot params struct is used to capture data from a navigable being navigated. Like source snapshot params, it is snapshotted at the beginning of a navigation and used throughout the navigation's lifetime. It has the following items:
</p>
<ul>
	<li>
`~sandbox法~flag群@tsP
⇒
`~sandbox法~flag集合$
◎
sandboxing flags
• a sandboxing flag set
</li>
</ul>

<div class="algo">
<p>
`~target~snapshot~paramsを~snapshotする@
~algoは、
所与の
( `~navigable$ %~target~navigable )
に対し
⇒
~RET 新たな`~target~snapshot~params$
— その
⇒＃
`~sandbox法~flag群$tsP ~SET `作成時の~sandbox法~flag群を決定する$( %~target~navigable にて`作動中な閲覧~文脈$nav, %~target~navigable の`容器$nav )
◎
To snapshot target snapshot params given a navigable targetNavigable, return a new target snapshot params with sandboxing flags set to the result of determining the creation sandboxing flags given targetNavigable's active browsing context and targetNavigable's container.
</p>
</div>

<hr>

<p>
~navi処理nを成すかなりの部分は、
新たな`文書$を作成する方法を決定することに割かれる
— それは、
最終的には`文書を作成して初期化する$~algo内で起こる。
その~algoへの~parameterは、
`~navi~params@
を介して追跡される
— それは、
次に挙げる`~item$sctを伴う`構造体$である。
これらの~itemの記述に現れる %新たな文書 は、
その~algoが作成することになる`文書$を指すとする：
◎
Much of the navigation process is concerned with determining how to create a new Document, which ultimately happens in the create and initialize a Document object algorithm. The parameters to that algorithm are tracked via a navigation params struct, which has the following items:
</p>
<ul>
	<li>
`~ID@nvP
⇒
~NULL／`~navi~ID$
◎
id
• null or a navigation ID
</li>
	<li>
`~navigable@nvP
⇒
~navigateされることになる`~navigable$
◎
navigable
• the navigable to be navigated
</li>
	<li>
`要請@nvP
⇒
~NULL ／ 当の~naviを開始した`要請$
◎
request
• null or a request that started the navigation
</li>
	<li>
`応答@nvP
⇒
最終的な~navigate先を与える`応答$（`~network~error$にもなり得る）
◎
response
• a response that ultimately was navigated to (potentially a network error)
</li>
	<li>
`~fetch制御器@nvP
⇒
~NULL／`~fetch制御器$
◎
fetch controller
• null or a fetch controller
</li>
	<li>
`早期~hintを~commitする@nvP
⇒
~NULL ／ `文書$を受容する~algo
— ~algoは、
%新たな文書 が作成されてから~callされる
◎
commit early hints
• null or an algorithm accepting a Document, once it has been created
</li>
	<li>
`~COOP施行n結果@nvP
⇒
`~opener施策の施行n結果$
— 報告-用に利用され，
`閲覧~文脈~groupの切替n＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy$を生じさせるためにも利用され得る。
◎
COOP enforcement result
• an opener policy enforcement result, used for reporting and potentially for causing a browsing context group switch
</li>
	<li>
`予約-済み環境@nvP
⇒
~NULL ／ %新たな文書 用に予約される`環境$
◎
reserved environment
• null or an environment reserved for the new Document
</li>
	<li>
`生成元@nvP
⇒
%新たな文書 用に利用する`生成元$
◎
origin
• an origin to use for the new Document
</li>
	<li>
`施策~容器@nvP
⇒
%新たな文書 用に利用する`施策~容器$
◎
policy container
• a policy container to use for the new Document
</li>
	<li>
`最終-~sandbox~flag集合@nvP
⇒
%新たな文書 に課される`~sandbox法~flag集合$
◎
final sandboxing flag set
• a sandboxing flag set to impose on the new Document
</li>
	<li>
`~opener施策@nvP
⇒
%新たな文書 用に利用する`~opener施策$
◎
opener policy
• a opener policy to use for the new Document
</li>
	<li>
`~navi計時~種別@nvP
⇒
%新たな文書 用の`~navi計時~entryを作成する$ために利用される `NavigationTimingType$I 
◎
navigation timing type
• a NavigationTimingType used for creating the navigation timing entry for the new Document
</li>
	<li>
`~about基底~URL@nvP
⇒
~NULL ／ %新たな文書 の`~about基底~URL$docを拡充するために利用される`~URL$
◎
about base URL
• a URL or null used to populate the new Document's about base URL
</li>
	<li>
`利用者-関与i@nvP
⇒
`~naviに対する利用者-関与i$
— %新たな文書 用に`~navi応答~用に利用する閲覧~文脈を得する$ときに利用される。
◎
user involvement
• a user navigation involvement used when obtaining a browsing context for the new Document
</li>
</ul>

<p class="note">注記：
この標準においては、
`~navi~params$を成す各`~item$sctは，作成-時から変異することはない
— 以降，他の~algoへ渡されるのみである。
◎
Once a navigation params struct is created, this standard does not mutate any of its items. They are only passed onward to other algorithms.
</p>

<hr>

<p>
`~navi~ID@
は、
~naviの間に生成される~UUID文字列である。
それは、［
`WEBDRIVERBIDI$r 仕様と~interfaceするため
］および［
`進行中な~navi$を追跡するため
］に利用される。
◎
A navigation ID is a UUID string generated during navigation. It is used to interface with the WebDriver BiDi specification as well as to track the ongoing navigation. [WEBDRIVERBIDI]
</p>

<hr>

<p>
`文書$の作成~後には、
それに関連な`辿可能な~navigable$の`~session履歴~entry群$navも更新される。
`NavigationHistoryBehavior$I 列挙が［
`~navi~algo$に対し，~session履歴の更新に欲される種別
］を指示するために利用される。
それは、
次に挙げる値をとり得る：
◎
After Document creation, the relevant traversable navigable's session history gets updated. The NavigationHistoryBehavior enumeration is used to indicate the desired type of session history update to the navigate algorithm. It is one of the following:
</p>
<ul>
	<li>
`push@hH
⇒
定例の~navi用
— 新たな`~session履歴~entry$を追加して，
`前方~session履歴を~clearする$ことになる。
◎
"push"
• A regular navigation which adds a new session history entry, and will clear the forward session history.
</li>
	<li>
`replace@hH
⇒
~naviは`作動中な~entry$navを置換することになる。
◎
"replace"
• A navigation that will replace the active session history entry.
</li>
	<li>
`auto@hH
⇒
既定の値。
これは、
`~navigableを~URLへ~navigateする$中で，ごく早期に［
`push$hH ／ `replace$hH
］に変換される
— 通例的には `push$hH になるが、
`ある種の状況下＠#navigate-convert-to-replace$では
`replace$hH になる。
◎
"auto"
• The default value, which will be converted very early in the navigate algorithm into "push" or "replace". Usually it becomes "push", but under certain circumstances it becomes "replace" instead.
</li>
</ul>

<p>
`履歴~取扱いの挙動@
は、
`NavigationHistoryBehavior$I 用の値［
`push$hH ／ `replace$hH
］である
— すなわち、
初期~値 `auto$hH は，これらいずれかに解決した結果になる。
◎
A history handling behavior is a NavigationHistoryBehavior that is either "push" or "replace", i.e., that has been resolved away from any initial "auto" value.
</p>

<div class="algo">
<p>
`~naviは置換-になるモノトスルか？@
は、
所与の
( `~URL$ %~URL, `文書$ %文書 )
に対し
⇒
~RET ~IS ~OR↓：
◎
The navigation must be a replace, given a URL url and a Document document, if any of the following are true:
</p>
<ul>
	<li>
%~URL の`~scheme$url ~EQ `javascript$l
◎
url's scheme is "javascript"; or
</li>
	<li>
%文書 の`初期~about_blankか$doc ~EQ ~T
◎
document's is initial about:blank is true.
</li>
</ul>
</div>

<div class="note">
<p>注記：
常にではないが、
他にも `replace$hH ~naviを強制する事例は多い：
◎
Other cases that often, but not always, force a "replace" navigation are:
</p>
<ul>
	<li>
当の`文書$は`完全に読込まれ$ていない場合
◎
if the Document is not completely loaded; or
</li>
	<li>
~target`~URL$が当の`文書$の`~URL$docに等しい場合
◎
if the target URL equals the Document's URL.
</li>
</ul>
</div>

<hr>

<p>
~web~platformを成す様々な各部は、
所与の~naviに利用者が孕まれるかどうかを追跡する。
`~naviに対する利用者-関与i@
は、
次に挙げるいずれかになる：
◎
Various parts of the platform track whether a user is involved in a navigation. A user navigation involvement is one of the following:
</p>
<dl>
	<dt>
`~browser~UI@i
◎
"browser UI"
</dt>
	<dd>
当の~naviは、
利用者により，~browser~UIの仕組みを介して起動された。
◎
The navigation was initiated by the user via browser UI mechanisms.
</dd>

	<dt>
`作動化@i
◎
"activation"
</dt>
	<dd>
当の~naviは、
利用者により，ある要素~用の`作動化の挙動$を介して起動された。
◎
The navigation was initiated by the user via the activation behavior of an element.
</dd>

	<dt>
`なし@i
◎
"none"
</dt>
	<dd>
当の~naviは、
利用者により起動されたものではない。
◎
The navigation was not initiated by the user.
</dd>
</dl>

<div class="algo">
<p>
【！For convenience at certain call sites, 】
`~event用の~naviに対する利用者-関与i@
は、
所与の
( `Event$I %~event )
に対し，次に従うものと定義される：
◎
For convenience at certain call sites, the user navigation involvement for an Event event is defined as follows:
</p>
<ol>
	<li>
~Assert：
この~algoは、
`作動化の挙動$の定義を成す一部として~callされている。
◎
Assert: this algorithm is being called as part of an activation behavior definition.
</li>
	<li>
~Assert：
%~event の`type$m ~EQ "`click$et"
◎
Assert: event's type is "click".
</li>
	<li>
~RET %~event の `isTrusted$m に応じて
⇒＃
~T ならば `作動化$i ／
~F ならば `なし$i
◎
If event's isTrusted is initialized to true, then return "activation".
◎
Return "none".
</li>
</ol>
</div>

				</section>
				<section id="beginning-navigation">
<h5 title="Beginning navigation">7.4.2.2. ~naviの~~開始法</h5>

<div class="algo">
<p>
`~navigableを~URLへ~navigateする@
~algoは、
所与の
( `~navigable$ %~navigable, `~URL$ %~URL, `文書$ %~source文書 ~DF ~NULL )
および，所与の：
◎
To navigate a navigable navigable to a URL url using an optional Document-or-null sourceDocument (default null), with＼
</p>
<ul>
	<li id="navigation-resource">
［ `~POST資源$／文字列 ］ %文書~資源 ~DF ~NULL
◎
an optional POST resource, string, or null documentResource (default null),＼
</li>
	<li id="navigation-response">
`応答$ %応答 ~DF ~NULL
◎
an optional response-or-null response (default null),＼
</li>
	<li id="exceptions-enabled">
真偽値 %例外を可能化するか ~DF ~F
◎
an optional boolean exceptionsEnabled (default false),＼
</li>
	<li id="navigation-hh">
`NavigationHistoryBehavior$I %履歴~取扱い ~DF `auto$hH
◎
an optional NavigationHistoryBehavior historyHandling (default "auto"),＼
</li>
	<li id="navigation-navigation-api-state">
`直列形の状態$ %~navi~API状態 ~DF ~NULL
◎
an optional serialized state-or-null navigationAPIState (default null),＼
</li>
	<li id="navigation-form-data-entry-list">
`~entry~list$ %~form~data~entry~list ~DF ~NULL
◎
an optional entry list or null formDataEntryList (default null),＼
</li>
	<li id="navigation-referrer-policy">
`~referrer施策$ %~referrer施策 ~DF 空~文字列
◎
an optional referrer policy referrerPolicy (default the empty string),＼
</li>
	<li id="navigation-user-involvement">
`~naviに対する利用者-関与i$ %利用者-関与i ~DF `なし$i
◎
an optional user navigation involvement userInvolvement (default "none"),＼
</li>
	<li id="navigation-source-element">
`要素$ %~source要素 ~DF ~NULL
◎
an optional Element sourceElement (default null),＼
</li>
	<li id="navigation-initial-insertion">
真偽値 %初期~挿入か ~DF ~F
◎
and an optional boolean initialInsertion (default false):
</li>
</ul>

<p>
に対し：
</p>

<p class="trans-note">【
この~algoは、
単に［
“~navigateする” ／ “~navi” ／ “~navi~algo”
］などの句でも参照される。
%~source文書 は、
（ ~NULL でないならば）~naviを起動した文書を表す。
】</p>

<ol>
	<li id="navigation-navigationtype">
%~CSP~navi種別 ~LET %~form~data~entry~list に応じて
⇒＃
~NULL 以外ならば `form-submission^l ／
~NULL ならば `other^l
◎
Let cspNavigationType be "form-submission" if formDataEntryList is non-null; otherwise "other".
</li>
	<li>
%~source~snapshot~params ~LET `~source~snapshot~paramsを~snapshotする$( %~source文書 )
◎
Let sourceSnapshotParams be the result of snapshotting source snapshot params given sourceDocument.
</li>
	<li>
%起動元~生成元~snapshot ~LET 新たな`不透明な生成元$
◎
Let initiatorOriginSnapshot be a new opaque origin.
</li>
	<li>
%起動元~基底~URL~snapshot ~LET `~about_blank$sc
◎
Let initiatorBaseURLSnapshot be about:blank.
</li>
	<li>
<p>
~IF［
%~source文書 ~EQ ~NULL
］：
◎
If sourceDocument is null:
</p>
		<ol>
			<li id="assert-null-sourcedocument">
~Assert：
%利用者-関与i ~EQ `~browser~UI$i
◎
Assert: userInvolvement is "browser UI".
</li>
			<li>
~IF［
%~url の`~scheme$url ~EQ `~javascript0$sc
］
⇒
%起動元~生成元~snapshot ~SET %~navigable にて`作動中な文書$navの`生成元$doc
◎
If url's scheme is "javascript", then set initiatorOriginSnapshot to navigable's active document's origin.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%利用者-関与i ~NEQ `~browser~UI$i
◎
Assert: userInvolvement is not "browser UI".
</li>
			<li id="sandboxLinks">
<p>
~IF［
%~source文書 の`~node~navigable$が
%~source~snapshot~params の下で
%~navigable を`~navigateすることは~sandbox法により許容され$ない
］：
◎
If sourceDocument's node navigable is not allowed by sandboxing to navigate navigable given sourceSnapshotParams:
</p>
				<ol>
					<li>
~IF［
%例外を可能化するか ~EQ ~T
］
⇒
~THROW `SecurityError$E 例外
◎
If exceptionsEnabled is true, then throw a "SecurityError" DOMException.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%起動元~生成元~snapshot ~SET %~source文書 の`生成元$doc
◎
Set initiatorOriginSnapshot to sourceDocument's origin.
</li>
			<li>
%起動元~基底~URL~snapshot ~SET %~source文書 の`文書~基底~URL$
◎
Set initiatorBaseURLSnapshot to sourceDocument's document base URL.
</li>
		</ol>
	</li>
	<li>
%~navi~ID ~LET `~randomな~UUIDを生成する$()
`WEBCRYPTO$r
◎
Let navigationId be the result of generating a random UUID. [WEBCRYPTO]
</li>
	<li>
<div>
<p>
~IF［
`~surrounding~agent$ ~NEQ %~navigable にて`作動中な文書$navに`関連な~agent$
］：
</p>
		<ol>
			<li>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, この~algoの以降を継続する手続き )
</li>
			<li>
~RET
【この段は、この訳による補完。】
</li>
		</ol>
◎
If the surrounding agent is equal to navigable's active document's relevant agent, then continue these steps.＼
Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to continue these steps.
</div>

<div class="note">
<p>注記：
これを行うわけは、
%~navigable にて`作動中な文書$navを成す たくさんの~propを調べつつあるが、
それは，理論~上は適切な`~event~loop$内からしか~access可能にならないからである。
（が、
無条件に~taskを~queueすることは求まれない
— 例えば、
同一-~event~loopにおける`素片への~navi$は，同期的に効果を発揮する必要があるので。）
◎
We do this because we are about to look at a lot of properties of navigable's active document, which are in theory only accessible over in the appropriate event loop. (But, we do not want to unconditionally queue a task, since — for example — same-event-loop fragment navigations need to take effect synchronously.)
</p>

<p>
別の実装~策は、
関連な情報を
— ~taskを~queueすることなく諮れるよう —
［
各~event~loopにまたがって／
あるいは正準的な “~browser~process” の中に
］再現することである。
これは，際どい事例においては、［
関連な~propが
~target~event~loop内で変更されたが，まだ再現されてない所
］で，ここに指定されるものとは異なる結果も与え得る。
そのような際どい事例において，
これらの策のうち どれが~browserの挙動に最良に合致するかを決定するため、
更に~testすることが必要になる。
◎
Another implementation strategy would be to replicate the relevant information across event loops, or into a canonical "browser process", so that it can be consulted without queueing a task. This could give different results than what we specify here in edge cases, where the relevant properties have changed over in the target event loop but not yet been replicated. Further testing is needed to determine which of these strategies best matches browser behavior, in such racy edge cases.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%~navigable にて`作動中な文書$navの`~unload~counter$ ~GT 0
］：
◎
If navigable's active document's unload counter is greater than 0, then＼
</p>
		<ol>
			<li>
`~WebDriver-BiDi~naviに失敗した$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `取消された$wBDst, %~URL )
◎
invoke WebDriver BiDi navigation failed with navigable and a WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is url,＼
</li>
			<li>
~RET
◎
and return.
</li>
		</ol>
	</li>
	<li>
%容器 ~LET %~navigable の`容器$nav
◎
Let container be navigable's container.
</li>
	<li>
<p>
~IF［
%容器 は `iframe$e 要素である
］~AND［
`~lazyに読込むことになる$( %容器 ) ~EQ ~T
］：
◎
If container is an iframe element and will lazy load element steps given container returns true, then＼
</p>
		<ol>
			<li>
`~lazyに読込んでいる要素の交差~観測ngを停止する$( %容器 )
◎
stop intersection-observing a lazy loading element container and＼
</li>
			<li>
%容器 の`~lazy読込n再開~手続き$ ~SET ~NULL
◎
set container's lazy load resumption steps to null.
</li>
		</ol>
	</li>
	<li id="navigate-convert-to-replace">
<p>
~IF［
%履歴~取扱い ~EQ `auto$hH
］
⇒
%履歴~取扱い ~SET ［
~AND↓ が満たされるならば `replace$hH ／
~ELSE_ `push$hH
］：
</p>
		<ul>
			<li>
( %~URL, %~navigable にて`作動中な文書$navの`~URL$doc )
は`同等な~URL$である
</li>
			<li>
%起動元~生成元~snapshot
~EQ`生成元$sub
%~navigable にて`作動中な文書$navの`生成元$doc
</li>
		</ul>
◎
If historyHandling is "auto", then:
• If url equals navigable's active document's URL, and initiatorOriginSnapshot is same origin with navigable's active document's origin, then set historyHandling to "replace".
• Otherwise, set historyHandling to "push".
</li>
	<li>
~IF［
`~naviは置換-になるモノトスルか？$( %~URL, %~navigable にて`作動中な文書$nav ) ~EQ ~T
］
⇒
%履歴~取扱い ~SET `replace$hH
◎
If the navigation must be a replace given url and navigable's active document, then set historyHandling to "replace".
</li>
	<li id="navigate-fragid-step">
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
		<ul>
			<li>
%文書~資源 ~EQ ~NULL
◎
documentResource is null;
</li>
			<li>
%応答 ~EQ ~NULL
◎
response is null;
</li>
			<li>
( %~URL, %~navigable にて`作動中な~entry$navの`~URL$shE )
は、
`素片は除外する^i下で`同等な~URL$である
◎
url equals navigable's active session history entry's URL with exclude fragments set to true; and
</li>
			<li>
%~URL の`素片$url ~NEQ ~NULL
◎
url's fragment is non-null,
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
`素片へ~navigateする$( ↓ )
⇒＃
%~navigable,
%~URL,
%履歴~取扱い,
%利用者-関与i,
%~source要素,
%~navi~API状態,
%~navi~ID,
◎
Navigate to a fragment given navigable, url, historyHandling, userInvolvement, sourceElement, navigationAPIState, and navigationId.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
~IF［
%~navigable の`親$nav ~NEQ ~NULL
］
⇒
%~navigable の`~load~event遅延-中か$nav ~SET ~T
◎
If navigable's parent is non-null, then set navigable's is delaying load events to true.
</li>
	<li>
%~target~snapshot~params ~LET
`~target~snapshot~paramsを~snapshotする$( %~navigable )
◎
Let targetSnapshotParams be the result of snapshotting target snapshot params given navigable.
</li>
	<li>
`~WebDriver-BiDi~naviが開始された$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `処理待ち$wBDst, %~URL )
◎
Invoke WebDriver BiDi navigation started with navigable and a new WebDriver BiDi navigation status whose id is navigationId, status is "pending", and url is url.
</li>
	<li>
<p>
~IF［
%~navigable の`進行中な~navi$ ~EQ `traversal^l
］：
◎
If navigable's ongoing navigation is "traversal", then:
</p>
		<ol>
			<li>
`~WebDriver-BiDi~naviに失敗した$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `取消された$wBDst, %~URL )
◎
Invoke WebDriver BiDi navigation failed with navigable and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is url.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>

<p class="note">注記：
現在`履歴を辿って＠#apply-the-traverse-history-step$いる`~navigable$を~navigateしようとする試みは、
無視される。
◎
Any attempts to navigate a navigable that is currently traversing are ignored.
</p>
	</li>
	<li>
<p>
`進行中な~naviを設定する$( %~navigable, %~navi~ID )
◎
Set the ongoing navigation for navigable to navigationId.
</p>

<p class="note">注記：
これには、
他の［
%~navigable において進行中な~navi
］を中止する効果がある
— `進行中な~navi$に対する~navi変更の間の ある種の地点で、
更なる作業を放棄させることになるので。
◎
This will have the effect of aborting other ongoing navigations of navigable, since at certain points during navigation changes to the ongoing navigation will cause further work to be abandoned.
</p>
	</li>
	<li>
<p>
~IF［
%~URL の`~scheme$url ~EQ `javascript$l
］：
◎
If url's scheme is "javascript", then:
</p>
		<ol>
			<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 次の手続き )
◎
Queue a global task on the navigation and traversal task source given navigable's active window＼
</p>

<div class="algo">
手続きは
⇒
`~javascript_~URLへ~navigateする$( ↓ )
⇒＃
%~navigable,
%~URL,
%履歴~取扱い,
%~source~snapshot~params,
%起動元~生成元~snapshot,
%利用者-関与i,
%~CSP~navi種別,
%初期~挿入か
◎
to navigate to a javascript: URL given navigable, url, historyHandling, sourceSnapshotParams, initiatorOriginSnapshot, userInvolvement, cspNavigationType, and initialInsertion.
</div>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
		<ul>
			<li>
%利用者-関与i ~NEQ `~browser~UI$i
◎
userInvolvement is not "browser UI";
</li>
			<li>
( %~navigable にて`作動中な文書$navの`生成元$doc, %~source文書 の`生成元$doc )
は`同じ生成元~domain$である
◎
navigable's active document's origin is same origin-domain with sourceDocument's origin;
</li>
			<li>
%~navigable にて`作動中な文書$navの`初期~about_blankか$doc ~EQ ~F
◎
navigable's active document's is initial about:blank is false; and
</li>
			<li>
%~URL の`~scheme$urlは`~fetch~scheme$である
◎
url's scheme is a fetch scheme,
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%~navi ~LET %~navigable にて`作動中な~window$navの`~navi~API$
◎
Let navigation be navigable's active window's navigation API.
</li>
			<li>
%発火~用の~entry~list ~LET %文書~資源 に応じて
⇒＃
`~POST資源$であるならば %~form~data~entry~list ／
~ELSE_ ~NULL
◎
Let entryListForFiring be formDataEntryList if documentResource is a POST resource; otherwise, null.
</li>
			<li>
%発火~用の~navi~API状態 ~LET %~navi~API状態 に応じて
⇒＃
~NULL 以外ならば %~navi~API状態 ／
~ELSE_ `StructuredSerializeForStorage$jA( `undefined^jv )
◎
Let navigationAPIStateForFiring be navigationAPIState if navigationAPIState is not null; otherwise, StructuredSerializeForStorage(undefined).
</li>
			<li>
%継続するか ~LET `~push／置換-／再読込み用の~navigate_ev~eventを発火する$( %~navi )
— 次も与える下で
⇒＃
`~navi種別^i ~SET %履歴~取扱い,
`同一-文書か^i ~SET ~F,
`利用者-関与i^i ~SET %利用者-関与i,
`~source要素^i ~SET %~source要素,
`~form~data~entry~list^i ~SET %発火~用の~entry~list,
`行先~URL^i ~SET %~URL,
`~navi~API状態^i ~SET %発火~用の~navi~API状態
◎
Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to historyHandling, isSameDocument set to false, userInvolvement set to userInvolvement, sourceElement set to sourceElement, formDataEntryList set to entryListForFiring, destinationURL set to url, and navigationAPIState set to navigationAPIStateForFiring.
</li>
			<li>
~IF［
%継続するか ~EQ ~F
］
⇒
~RET
◎
If continue is false, then return.
</li>
		</ol>

<p class="note">注記：
~naviは，［
%利用者-関与i ~EQ `~browser~UI$i の場合 ／
`同じ生成元~domain$でない %~source文書 により起動された場合
］でも、
上の段にて`素片へ~navigateする$ことを経る場合には，
`navigate$et ~eventを発火することはアリになる。
◎
It is possible for navigations with userInvolvement of "browser UI" or initiated by a cross origin-domain sourceDocument to fire navigate events, if they go through the earlier navigate to a fragment path.
</p>
	</li>
	<li>
~IF［
%~source文書 ~EQ %~navigable の`容器~文書$nav
］
⇒
`先送d~fetch~quotaを予約する$( %~navigable の`容器$nav, %~URL の`生成元$url )
◎
If sourceDocument is navigable's container document, then reserve deferred fetch quota for navigable's container given url's origin.
</li>
	<li class="algo">
<p>
この段は、
`並列的$に走らす：
◎
In parallel, run these steps:
</p>
		<ol>
			<li>
%~unload~promptは取消されたか ~LET `~unloadは取消されたか否か検査する$( %~navigable にて`作動中な文書$navの`広義-子孫~navigable群$ )
◎
Let unloadPromptCanceled be the result of checking if unloading is canceled for navigable's active document's inclusive descendant navigables.
</li>
			<li>
<p>
~IF［
%~unload~promptは取消されたか ~NEQ `継続する^i
］~OR［
%~navigable の`進行中な~navi$ ~NEQ %~navi~ID
］：
◎
If unloadPromptCanceled is not "continue", or navigable's ongoing navigation is no longer navigationId:
</p>
				<ol>
					<li>
`~WebDriver-BiDi~naviに失敗した$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `取消された$wBDst, %~URL )
◎
Invoke WebDriver BiDi navigation failed with navigable and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is url.
</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>
			</li>
			<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 次の手続き )
◎
Queue a global task on the navigation and traversal task source given navigable's active window＼
</p>

<div class="algo">
手続きは
⇒
`文書とその子孫たちを中止する$( %~navigable にて`作動中な文書$nav )
◎
to abort a document and its descendants given navigable's active document.
</div>
			</li>
			<li id="navigation-create-document-state">
<p>
%文書~状態 ~LET 新たな`文書~状態$
— その
⇒＃
`要請~referrer施策$dS ~SET %~referrer施策,
`起動元~生成元$dS ~SET %起動元~生成元~snapshot,
`資源$dS ~SET %文書~資源,
`~navigable名$dS ~SET %~navigable の`~target名$nav
◎
Let documentState be a new document state with
◎
request referrer policy
• referrerPolicy
initiator origin
• initiatorOriginSnapshot
resource
• documentResource
navigable target name
• navigable's target name
</p>

<p class="note">注記：
`~navigable名$dSは、
様々な条件の下で~clearされ得る
— ［
当の~navi処理nの後
］かつ［
当の文書~状態を完結する前
］に。
◎
The navigable target name can get cleared under various conditions later in the navigation process, before the document state is finalized.
</p>
			</li>
			<li>
<p>
~IF［
%~URL は`~about_blank に合致して$いる
］~OR［
%~URL ~EQ `~about_srcdoc$sc
］：
◎
If url matches about:blank or is about:srcdoc, then:
</p>
				<ol>
					<li>
%文書~状態 の`生成元$dS ~SET %起動元~生成元~snapshot
◎
Set documentState's origin to initiatorOriginSnapshot.
</li>
					<li>
%文書~状態 の`~about基底~URL$dS ~SET %起動元~基底~URL~snapshot
◎
Set documentState's about base URL to initiatorBaseURLSnapshot.
</li>
				</ol>
			</li>
			<li>
%履歴~entry ~LET 新たな`~session履歴~entry$
— その
⇒＃
`~URL$shE ~SET %~URL,
`文書~状態$shE ~SET %文書~状態
◎
Let historyEntry be a new session history entry, with its URL set to url and its document state set to documentState.
</li>
			<li>
%~navi~params ~LET ~NULL
◎
Let navigationParams be null.
</li>
			<li>
<p>
~IF［
%応答 ~NEQ ~NULL
］：
◎
If response is non-null:
</p>

<div class="note">
<p id="note-navigate-called-with-response">注記：
`~navi~algo$に`応答$が給されるのは、
次に挙げるものに限られる：
◎
The navigate algorithm is only supplied with a response＼
</p>
				<ul>
					<li>
［
`object$e ／ `embed$e
］用の処理~modelの一部として。
◎
as part of the object and embed processing models,＼
</li>
					<li>
初期~応答より後における，
`multipart/x-mixed-replace 文書を読込む$ための処理。
◎
or for processing parts of multipart/x-mixed-replace responses after the initial response.
</li>
				</ul>
</div>
				<ol>
					<li>
%~source施策~容器 ~LET %~source文書 に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ `施策~容器を~cloneする$( %~source文書 の`施策~容器$doc )
◎
Let sourcePolicyContainer be a clone of the sourceDocument's policy container, if sourceDocument is not null; otherwise null.
</li>
					<li>
%施策~容器 ~LET `~navi~paramsの施策~容器を決定する$( ↓ )
⇒＃
%応答 の`~URL$rs,
~NULL,
%~source施策~容器,
%~navigable の`容器~文書$navの`施策~容器$doc,
~NULL
◎
Let policyContainer be the result of determining navigation params policy container given response's URL, null, sourcePolicyContainer, navigable's container document's policy container, and null.
</li>
					<li>
%最終-~sandbox~flag群 ~LET 次の`和集合$
⇒＃
%~target~snapshot~params の`~sandbox法~flag群$tsP,
`~CSPから導出される~sandbox法~flag群$( %施策~容器 の`~CSP~list$pC )
◎
Let finalSandboxFlags be the union of targetSnapshotParams's sandboxing flags and policyContainer's CSP list's CSP-derived sandboxing flags.
</li>
					<li>
%応答の生成元 ~LET `生成元を決定する$( ↓ )
⇒＃
%応答 の`~URL$rs,
%最終-~sandbox~flag群,
%文書~状態 の`起動元~生成元$dS
◎
Let responseOrigin be the result of determining the origin given response's URL, finalSandboxFlags, and documentState's initiator origin.
</li>
					<li>
%~COOP ~LET 新たな`~opener施策$
◎
Let coop be a new opener policy.
</li>
					<li>
%~COOP施行n結果 ~LET 新たな`~opener施策の施行n結果$
— その
⇒＃
`~URL$cooP ~SET %応答 の`~URL$rs,
`生成元$cooP ~SET %応答の生成元,
`~opener施策$cooP ~SET %~COOP,
◎
Let coopEnforcementResult be a new opener policy enforcement result with
◎
url
• response's URL
origin
• responseOrigin
opener policy
• coop
</li>
					<li>
%~navi~params ~SET 新たな`~navi~params$
— その
⇒＃
`~ID$nvP ~SET %~navi~ID,
`~navigable$nvP ~SET %~navigable,
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET %応答,
`~fetch制御器$nvP ~SET ~NULL,
`早期~hintを~commitする$nvP ~SET ~NULL,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`生成元$nvP ~SET %応答の生成元,
`施策~容器$nvP ~SET %施策~容器,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flag群,
`~opener施策$nvP ~SET %~COOP,
`~navi計時~種別$nvP ~SET `navigate$l,
`~about基底~URL$nvP ~SET %文書~状態 の`~about基底~URL$dS,
`利用者-関与i$nvP ~SET %利用者-関与i
◎
Set navigationParams to a new navigation params, with
◎
id
• navigationId
navigable
• navigable
request
• null
response
• response
fetch controller
• null
commit early hints
• null
COOP enforcement result
• coopEnforcementResult
reserved environment
• null
origin
• responseOrigin
policy container
• policyContainer
final sandboxing flag set
• finalSandboxFlags
opener policy
• coop
navigation timing type
• "navigate"
about base URL
• documentState's about base URL
user involvement
• userInvolvement
</li>
				</ol>
			</li>
			<li>
<p>
`履歴~entryの文書を拡充するよう試みる$( ↓ )
⇒＃
%履歴~entry,
%~navigable,
`navigate$l,
%~source~snapshot~params,
%~target~snapshot~params,
%利用者-関与i,
%~navi~ID,
%~navi~params,
%~CSP~navi種別
◎終
次も与える下で
⇒＃
`~POSTを許容するか^i ~SET ~T
`完了~手続き^i ~SET 次の手続き
◎
Attempt to populate the history entry's document for historyEntry, given navigable, "navigate", sourceSnapshotParams, targetSnapshotParams, userInvolvement, navigationId, navigationParams, cspNavigationType, with allowPOST set to true and completionSteps set to＼
</p>
<div class="algo">
<p>
手続きは
⇒
`~session履歴~辿り手続きを付加する$( %~navigable の`辿可能な~navigable$nav, 次の手続き )
◎
the following step:
• Append session history traversal steps to navigable's traversable to＼
</p>
<div class="algo">
手続きは
⇒
`非同一-文書~naviを完結する$( %~navigable, %履歴~取扱い, %利用者-関与i, %履歴~entry )
◎
finalize a cross-document navigation given navigable, historyHandling, userInvolvement, and historyEntry.
</div>
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

				</section>
				<section id="ending-navigation">
<h5 title="Ending navigation">7.4.2.3 ~naviの~~終了法</h5>

<p>
通例的な非同一-文書へ~navigateする事例では、
まず，`文書$で`~session履歴~entryを拡充する＠#populating-a-session-history-entry$ことになるが、
すべての~naviは
— 中止されなかったなら —
最終的に以下に与える いずれかの~algoの中へ~callする結果になる。
◎
Although the usual cross-document navigation case will first foray into populating a session history entry with a Document, all navigations that don't get aborted will ultimately end up calling into one of the below algorithms.
</p>

					</section>
					<section id="the-usual-cross-document-navigation-case">
<h6 title="The usual cross-document navigation case">7.4.2.3.1. 通例的な非同一-文書~naviの事例</h6>

<div class="algo">
<p>
`非同一-文書~naviを完結する@
~algoは、
所与の
⇒＃
`~navigable$ %~navigable,
`履歴~取扱いの挙動$ %履歴~取扱い,
`~naviに対する利用者-関与i$ %利用者-関与i,
`~session履歴~entry$ %履歴~entry
◎終
に対し：
◎
To finalize a cross-document navigation given a navigable navigable, a history handling behavior historyHandling, a user navigation involvement userInvolvement, and a session history entry historyEntry:
</p>
<ol>
	<li>
~Assert：
これは、［
%~navigable の`辿可能な~navigable$navの`~session履歴~辿り~queue$nav
］の中で走っている。
◎
Assert: this is running on navigable's traversable navigable's session history traversal queue.
</li>
	<li>
%~navigable の`~load~event遅延-中か$nav ~SET ~F
◎
Set navigable's is delaying load events to false.
</li>
	<li>
<p>
~IF［
%履歴~entry の`文書$shE ~EQ ~NULL
］
⇒
~RET
◎
If historyEntry's document is null, then return.
</p>

<p class="note">注記：
これは、［
`履歴~entryの文書を拡充しようと試みた＠#attempt-to-populate-the-history-entry's-document$が，文書を作成することなく終わった
］ことを意味する
— 例：
当の~naviは、［
後続な~navi, `204$hst 応答, 等々
］により取消された結果として。
◎
This means that attempting to populate the history entry's document ended up not creating a document, as a result of e.g., the navigation being canceled by a subsequent navigation, a 204 No Content response, etc.
</p>
	</li>
	<li id="resetBCName">
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
		<ul>
			<li>
%~navigable の`親$nav ~EQ ~NULL
◎
navigable's parent is null;
</li>
			<li>
%履歴~entry の`文書$shEが`属する閲覧~文脈$は、
次を満たさない
⇒
［
`補助~閲覧~文脈$である
］~AND［
それを`開いた閲覧~文脈$bc ~NEQ ~NULL
］
◎
historyEntry's document's browsing context is not an auxiliary browsing context whose opener browsing context is non-null; and
</li>
			<li>
%履歴~entry の`文書$shEの`生成元$doc
`is not^en【~NEQ`生成元$sub？】
%~navigable にて`作動中な文書$navの`生成元$doc
◎
historyEntry's document's origin is not navigable's active document's origin,
</li>
		</ul>
<p>
…ならば
⇒
%履歴~entry の`文書~状態$shEの`~navigable名$dS ~SET 空~文字列
◎
then set historyEntry's document state's navigable target name to the empty string.
</p>
	</li>
	<li>
%置換する~entry ~LET %履歴~取扱い に応じて
⇒＃
`replace$hH ならば %~navigable にて`作動中な~entry$nav ／
~ELSE_ ~NULL
◎
Let entryToReplace be navigable's active session history entry if historyHandling is "replace", otherwise null.
</li>
	<li>
%辿可能 ~LET %~navigable の`辿可能な~navigable$nav
◎
Let traversable be navigable's traversable navigable.
</li>
	<li>
%~target~step ~LET ~NULL
◎
Let targetStep be null.
</li>
	<li>
%~target~entry群 ~LET `~session履歴~entry群を取得する$( %~navigable )
◎
Let targetEntries be the result of getting session history entries for navigable.
</li>
	<li>
<p>
~IF［
%置換する~entry ~EQ ~NULL
］：
◎
If entryToReplace is null, then:
</p>
		<ol>
			<li>
`前方~session履歴を~clearする$( %辿可能 )
◎
Clear the forward session history of traversable.
</li>
			<li>
%~target~step ~SET %辿可能 の`現在の~session履歴~step$nav ~PLUS 1
◎
Set targetStep to traversable's current session history step + 1.
</li>
			<li>
%履歴~entry の`~step$shE ~SET %~target~step
◎
Set historyEntry's step to targetStep.
</li>
			<li>
%~target~entry群 に %履歴~entry を`付加する$
◎
Append historyEntry to targetEntries.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~target~entry群 の中で %置換する~entry を %履歴~entry で`置換する$
◎
Replace entryToReplace with historyEntry in targetEntries.
</li>
			<li>
%履歴~entry の`~step$shE ~SET %置換する~entry の`~step$shE
◎
Set historyEntry's step to entryToReplace's step.
</li>
			<li>
~IF［
%履歴~entry の`文書~状態$shEの`生成元$dS
~EQ`生成元$sub
%置換する~entry の`文書~状態$shEの`生成元$dS
］
⇒
%履歴~entry の`~navi~API~key$shE ~SET %置換する~entry の`~navi~API~key$shE
◎
If historyEntry's document state's origin is same origin with entryToReplace's document state's origin, then set historyEntry's navigation API key to entryToReplace's navigation API key.
</li>
			<li>
%~target~step ~SET %辿可能 の`現在の~session履歴~step$nav
◎
Set targetStep to traversable's current session history step.
</li>
		</ol>
	</li>
	<li>
`~push／置換-用に履歴~stepを適用する$( ↓ )
⇒＃
%辿可能,
%~target~step,
%履歴~取扱い,
%利用者-関与i
◎
Apply the push/replace history step targetStep to traversable given historyHandling and userInvolvement.
</li>
</ol>
</div>

					</section>
					<section id="the-javascript:-url-special-case">
<h6 title="The javascript: URL special case">7.4.2.3.2. 特別な事例： `~javascript0^sc ~URL</h6>

<p class="XXX">
`~javascript0$sc ~URLの仕様における様々な問題は、
課題~追跡器において`専用な~label＠https://github.com/whatwg/html/labels/topic%3A%20javascript%3A%20URLs$を付けて文書化されている。
◎
javascript: URLs have a dedicated label on the issue tracker documenting various problems with their specification.
</p>

<div class="algo">
<p>
`~javascript_~URLへ~navigateする@
~algoは、
所与の
⇒＃
`~navigable$ %~target~navigable,
`~URL$ %~URL,
`履歴~取扱いの挙動$ %履歴~取扱い,
`~source~snapshot~params$ %~source~snapshot~params,
`生成元$ %起動元~生成元,
`~naviに対する利用者-関与i$ %利用者-関与i,
文字列 %~CSP~navi種別
真偽値 %初期~挿入か
◎終
に対し：
◎
To navigate to a javascript: URL, given a navigable targetNavigable, a URL url, a history handling behavior historyHandling, a source snapshot params sourceSnapshotParams, an origin initiatorOrigin, a user navigation involvement userInvolvement, a string cspNavigationType, and a boolean initialInsertion:
</p>
<ol>
	<li>
~Assert：
%履歴~取扱い ~EQ `replace$hH
◎
Assert: historyHandling is "replace".
</li>
	<li>
`進行中な~naviを設定する$( %~target~navigable, ~NULL )
◎
Set the ongoing navigation for targetNavigable to null.
</li>
	<li>
~IF［
( %起動元~生成元, %~target~navigable にて`作動中な文書$navの`生成元$doc )
は、
`同じ生成元~domain$でない
］
⇒
~RET
◎
If initiatorOrigin is not same origin-domain with targetNavigable's active document's origin, then return.
</li>
	<li>
<p>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`施策~容器$rq ~SET %~source~snapshot~params の`~source施策~容器$ssP
◎
Let request be a new request whose URL is url and whose policy container is sourceSnapshotParams's source policy container.
</p>

<p class="note">注記：
これは、もっぱら［
次の段に形式上必要とされる`要請$
］であり，~networkを叩くことは決してない。
◎
This is a synthetic request solely for plumbing into the next step. It will never hit the network.
</p>
	</li>
	<li>
~IF［
次の結果 ~EQ `阻止される^i
］…
⇒
`ある種別の~navi要請は~CSPにより阻止されるべきか？$( %要請, %~CSP~navi種別 )
`CSP$r
◎終
…ならば
⇒
~RET
◎
If the result of should navigation request of type be blocked by Content Security Policy? given request and cspNavigationType is "Blocked", then return. [CSP]
</li>
	<li>
%新たな文書 ~LET `~javascript_~URLを評価する$( ↓ )
⇒＃
%~target~navigable,
%~URL,
%起動元~生成元,
%利用者-関与i
◎
Let newDocument be the result of evaluating a javascript: URL given targetNavigable, url, initiatorOrigin, and userInvolvement.
</li>
	<li>
<p>
~IF［
%新たな文書 ~EQ ~NULL
］：
◎
If newDocument is null:
</p>
		<ol>
			<li>
~IF［
%初期~挿入か ~EQ ~T
］~AND［
%~target~navigable にて`作動中な文書$navの`初期~about_blankか$doc ~EQ ~T
］
⇒
`~iframe~load~event手続き$( %~target~navigable の`容器$nav )
◎
If initialInsertion is true and targetNavigable's active document's is initial about:blank is true, then run the iframe load event steps given targetNavigable's container.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>

<p class="note">注記：
この事例では、［
何らかの~JS~codeが実行されたが，作成された新たな`文書$は無かった
］ので，~naviを遂行しないことになる。
◎
In this case, some JavaScript code was executed, but no new Document was created, so we will not perform a navigation.
</p>
	</li>
	<li>
~Assert：
%起動元~生成元 ~EQ %新たな文書 の`生成元$doc
◎
Assert: initiatorOrigin is newDocument's origin.
</li>
	<li>
%置換する~entry ~LET %~target~navigable にて`作動中な~entry$nav
◎
Let entryToReplace be targetNavigable's active session history entry.
</li>
	<li>
%旧-文書~状態 ~LET %置換する~entry の`文書~状態$shE
◎
Let oldDocState be entryToReplace's document state.
</li>
	<li>
%履歴~施策~容器 ~LET %旧-文書~状態 の`履歴~施策~容器$dS
◎
↓</li>
	<li>
~IF［
%履歴~施策~容器 ~NEQ ~NULL
］
⇒
%履歴~施策~容器 ~SET `施策~容器を~cloneする$( %履歴~施策~容器 )
◎
↓</li>
	<li>
%文書~状態 ~LET 新たな`文書~状態$
— その
⇒＃
`文書$dS ~SET %新たな文書,
`履歴~施策~容器$dS ~SET %履歴~施策~容器,
`要請~referrer$dS ~SET %旧-文書~状態 の`要請~referrer$dS,
`要請~referrer施策$dS ~SET %旧-文書~状態 の`要請~referrer施策$dS,
`起動元~生成元$dS ~SET %起動元~生成元,
`生成元$dS ~SET %起動元~生成元,
`~about基底~URL$dS ~SET %旧-文書~状態 の`~about基底~URL$dS,
`資源$dS ~SET ~NULL,
`一度でも拡充されたか$dS ~SET ~T,
`~navigable名$dS ~SET %旧-文書~状態 の`~navigable名$dS
◎
Let documentState be a new document state with
◎
document
• newDocument
history policy container
• a clone of the oldDocState's history policy container if it is non-null; null otherwise
request referrer
• oldDocState's request referrer
request referrer policy
• oldDocState's request referrer policy or should this be the referrerPolicy that was passed to navigate?
initiator origin
• initiatorOrigin
origin
• initiatorOrigin
about base URL
• oldDocState's about base URL
resource
• null
ever populated
• true
navigable target name
• oldDocState's navigable target name
</li>
	<li>
<p>
%履歴~entry ~LET 新たな`~session履歴~entry$
— その
⇒＃
`~URL$shE ~SET %置換する~entry の`~URL$shE,
`文書~状態$shE ~SET %文書~状態,
◎
Let historyEntry be a new session history entry, with
◎
URL
• entryToReplace's URL
document state
• documentState
</p>

<p class="note">注記：
`~URL$shE用には、
%~URL 
— すなわち、`~navi~algo$をcallした実際の `~javascript0$sc ~URL —
を`利用しない^em。
すなわち、
`~javascript0$sc ~URLは，
~session履歴~内には決して格納されないので，決して辿られない。
◎
For the URL, we do not use url, i.e. the actual javascript: URL that the navigate algorithm was called with. This means javascript: URLs are never stored in session history, and so can never be traversed to.
</p>
	</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %~target~navigable の`辿可能な~navigable$nav, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`非同一-文書~naviを完結する$( ↓ )
⇒＃
%~target~navigable,
%履歴~取扱い,
%利用者-関与i,
%履歴~entry
</div>
◎
Append session history traversal steps to targetNavigable's traversable to finalize a cross-document navigation with targetNavigable, historyHandling, userInvolvement, and historyEntry.
</li>
</ol>
</div>

<div class="algo">
<p>
`~javascript_~URLを評価する@
~algoは、
所与の
⇒＃
`~navigable$ %~target~navigable,
`~URL$ %~URL,
`生成元$ %新たな文書の生成元,
`~naviに対する利用者-関与i$ %利用者-関与i
◎終
に対し：
◎
To evaluate a javascript: URL given a navigable targetNavigable, a URL url, an origin newDocumentOrigin, and a user navigation involvement userInvolvement:
</p>
<ol>
	<li>
%~URL文字列 ~LET `~URLを直列化する$( %~URL )
◎
Let urlString be the result of running the URL serializer on url.
</li>
	<li>
%符号化-済み~script~source ~LET %~URL文字列 からから先頭の `javascript:^l を除去した結果
◎
Let encodedScriptSource be the result of removing the leading "javascript:" from urlString.
</li>
	<li>
%~script~source ~LET `~UTF-8復号する$( `文字列を~byte列に~percent-復号する$( %符号化-済み~script~source ) )
◎
Let scriptSource be the UTF-8 decoding of the percent-decoding of encodedScriptSource.
</li>
	<li>
%設定群 ~LET %~target~navigable にて`作動中な文書$navに`関連な設定群~obj$
◎
Let settings be targetNavigable's active document's relevant settings object.
</li>
	<li>
%~script ~LET `古典~scriptを作成する$( ↓ )
⇒＃
%~script~source,
%設定群,
%設定群 の`~API用~基底~URL$enV,
`既定の~script~fetch~option群$
◎
Let baseURL be settings's API base URL.
◎
Let script be the result of creating a classic script given scriptSource, settings, baseURL, and the default script fetch options.
</li>
	<li>
%評価~状態s ~LET `古典~scriptを走らす$( %~script )
◎
Let evaluationStatus be the result of running the classic script script.
</li>
	<li>
%結果 ~LET ~NULL
◎
Let result be null.
</li>
	<li>
~IF［
%評価~状態s は通常~完了である
］~AND［
%評価~状態s .`Value^sl は `String^jt である
］
⇒
%結果 ~SET %評価~状態s .`Value^sl
◎
If evaluationStatus is a normal completion, and evaluationStatus.[[Value]] is a String, then set result to evaluationStatus.[[Value]].
</li>
	<li>
~ELSE
⇒
~RET ~NULL
◎
Otherwise, return null.
</li>
	<li>
<p>
%応答 ~LET 新たな`応答$
— その
⇒＃
`~URL$rs ~SET %~target~navigable にて`作動中な文書$navの`~URL$doc,
`~header~list$rs ~SET « ( `Content-Type$h, `text/html;charset=utf-8^bl ) »,
`本体$rs ~SET `~byte列を本体として取得する$( `~UTF-8符号化する$( %結果 )
◎
Let response be a new response with
◎
URL
• targetNavigable's active document's URL
header list
• « (`Content-Type`, `text/html;charset=utf-8`) »
body
• the UTF-8 encoding of result, as a body
</p>

<p class="note">注記：
~UTF-8に符号化することは、
~HTML構文解析器が応答の本体を復号したなら，
対を成さない`~surrogate$は往復しなくなることを意味する。
◎
The encoding to UTF-8 means that unpaired surrogates will not roundtrip, once the HTML parser decodes the response body.
</p>
	</li>
	<li>
%施策~容器 ~LET %~target~navigable にて`作動中な文書$navの`施策~容器$doc
◎
Let policyContainer be targetNavigable's active document's policy container.
</li>
	<li>
%最終-~sandbox~flag群 ~LET `~CSPから導出される~sandbox法~flag群$( %施策~容器 の`~CSP~list$pC )
◎
Let finalSandboxFlags be policyContainer's CSP list's CSP-derived sandboxing flags.
</li>
	<li>
%~COOP ~LET %~target~navigable にて`作動中な文書$navの`~opener施策$doc
◎
Let coop be targetNavigable's active document's opener policy.
</li>
	<li>
%~COOP施行n結果 ~LET 新たな`~opener施策の施行n結果$
— その
⇒＃
`~URL$cooP ~SET %~URL,
`生成元$cooP ~SET %新たな文書の生成元,
`~opener施策$cooP ~SET %~COOP,
◎
Let coopEnforcementResult be a new opener policy enforcement result with
◎
url
• url
origin
• newDocumentOrigin
opener policy
• coop
</li>
	<li>
%~navi~params ~LET 新たな`~navi~params$
— その
⇒＃
`~ID$nvP ~SET %~navi~ID,
`~navigable$nvP ~SET %~target~navigable,
`要請$nvP ~SET ~NULL <span class="XXX">これは、結果の`文書$の~referrerを ~NULL にする — それは正しいのか？</span>,
`応答$nvP ~SET %応答,
`~fetch制御器$nvP ~SET ~NULL,
`早期~hintを~commitする$nvP ~SET ~NULL,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`生成元$nvP ~SET %新たな文書の生成元,
`施策~容器$nvP ~SET %施策~容器,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flag群,
`~opener施策$nvP ~SET %~COOP,
`~navi計時~種別$nvP ~SET `navigate$l,
`~about基底~URL$nvP ~SET %~target~navigable にて`作動中な文書$navの`~about基底~URL$doc,
`利用者-関与i$nvP ~SET %利用者-関与i
◎
Let navigationParams be a new navigation params, with
◎
id
• navigationId
navigable
• targetNavigable
request
• null this will cause the referrer of the resulting Document to be null; is that correct?
response
• response
fetch controller
• null
commit early hints
• null
COOP enforcement result
• coopEnforcementResult
reserved environment
• null
origin
• newDocumentOrigin
policy container
• policyContainer
final sandboxing flag set
• finalSandboxFlags
opener policy
• coop
navigation timing type
• "navigate"
about base URL
• targetNavigable's active document's about base URL
user involvement
• userInvolvement
</li>
	<li>
~RET `~HTML文書を読込む$( %~navi~params )
◎
Return the result of loading an HTML document given navigationParams.
</li>
</ol>
</div>

					</section>
					<section id="scroll-to-fragid">
<h6 title="Fragment navigations">7.4.2.3.3. 素片~navi</h6>

<div class="algo">
<p>
`素片へ~navigateする@
~algoは、
所与の
⇒＃
`~navigable$ %~navigable,
`~URL$ %~URL,
`履歴~取扱いの挙動$ %履歴~取扱い,
`~naviに対する利用者-関与i$ %利用者-関与i,
［ `要素$／ ~NULL ］ %~source要素,
［ `直列形の状態$／ ~NULL ］ %~navi~API状態,
`~navi~ID$ %~navi~ID
◎終
に対し：
◎
To navigate to a fragment given a navigable navigable, a URL url, a history handling behavior historyHandling, a user navigation involvement userInvolvement, an Element-or-null sourceElement, a serialized state-or-null navigationAPIState, and a navigation ID navigationId:
</p>
<ol>
	<li>
%~navi ~LET %~navigable にて`作動中な~window$navの`~navi~API$
◎
Let navigation be navigable's active window's navigation API.
</li>
	<li>
%行先~navi~API状態 ~LET %~navigable にて`作動中な~entry$navの`~navi~API状態$shE
◎
Let destinationNavigationAPIState be navigable's active session history entry's navigation API state.
</li>
	<li>
~IF［
%~navi~API状態 ~NEQ ~NULL
］
⇒
%行先~navi~API状態 ~SET %~navi~API状態
◎
If navigationAPIState is not null, then set destinationNavigationAPIState to navigationAPIState.
</li>
	<li>
%継続するか ~LET `~push／置換-／再読込み用の~navigate_ev~eventを発火する$( %~navi )
— 次も与える下で
⇒＃
`~navi種別^i ~SET %履歴~取扱い,
`同一-文書か^i ~SET ~T,
`利用者-関与i^i ~SET %利用者-関与i,
`~source要素^i ~SET %~source要素
`行先~URL^i ~SET %~URL,
`~navi~API状態^i ~SET %行先~navi~API状態
◎
Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to historyHandling, isSameDocument set to true, userInvolvement set to userInvolvement, sourceElement set to sourceElement, destinationURL set to url, and navigationAPIState set to destinationNavigationAPIState.
</li>
	<li>
~IF［
%継続するか ~EQ ~F
］
⇒
~RET
◎
If continue is false, then return.
</li>
	<li>
<p>
%履歴~entry ~LET 新たな`~session履歴~entry$
— その
⇒＃
`~URL$shE ~SET %~URL,
`文書~状態$shE ~SET %~navigable にて`作動中な~entry$navの`文書~状態$shE,
`~navi~API状態$shE ~SET %行先~navi~API状態,
`~scroll復旧~mode$shE ~SET %~navigable にて`作動中な~entry$navの`~scroll復旧~mode$shE
◎
Let historyEntry be a new session history entry, with
◎
URL
• url
document state
• navigable's active session history entry's document state
navigation API state
• destinationNavigationAPIState
scroll restoration mode
• navigable's active session history entry's scroll restoration mode
</p>

<div class="note">
<p>注記：
`navigation.navigate()＠~HTMLnavAPI#dom-navigation-navigate$c
で遂行された~navi用には、
`state＠~HTMLnavAPI#dom-navigationnavigateoptions-state$m ~optionにより供された値が，新たな`~navi~API状態$shE用に利用される
（値が供されなかった場合、［
`undefined^jv の直列化
］に設定されることになる）。
他の素片~navi
— 利用者が起動したものも含む —
用には、
`~navi~API状態$shEは，直前の~entryから引き継がれる。
◎
For navigations performed with navigation.navigate(), the value provided by the state option is used for the new navigation API state. (This will set it to the serialization of undefined, if no value is provided for that option.) For other fragment navigations, including user-initiated ones, the navigation API state is carried over from the previous entry.
</p>

<p>
`古典~履歴~API用の状態$shEは、
決して引き継がれない。
◎
The classic history API state is never carried over.
</p>
</div>
	</li>
	<li>
%置換する~entry ~LET ［
次が満たされるならば %~navigable にて`作動中な~entry$nav ／
~ELSE_ ~NULL
］
⇒
%履歴~取扱い ~EQ `replace$hH
◎
Let entryToReplace be navigable's active session history entry if historyHandling is "replace", otherwise null.
</li>
	<li>
%履歴 ~LET %~navigable にて`作動中な文書$navの`履歴~obj$
◎
Let history be navigable's active document's history object.
</li>
	<li>
%~script履歴~index ~LET %履歴 の`~index$hsT
◎
Let scriptHistoryIndex be history's index.
</li>
	<li>
%~script履歴~長さ ~LET %履歴 の`長さ$hsT
◎
Let scriptHistoryLength be history's length.
</li>
	<li>
<p>
~IF［
%履歴~取扱い ~EQ `push$hH
］：
◎
If historyHandling is "push", then:
</p>
		<ol>
			<li>
%履歴 の`状態$hsT ~SET ~NULL
◎
Set history's state to null.
</li>
			<li>
%~script履歴~index ~INCBY 1
◎
Increment scriptHistoryIndex.
</li>
			<li>
%~script履歴~長さ ~SET %~script履歴~index ~PLUS 1
◎
Set scriptHistoryLength to scriptHistoryIndex + 1.
</li>
		</ol>
	</li>
	<li>
%~navigable にて`作動中な文書$navの`~URL$doc ~SET %~URL
◎
Set navigable's active document's URL to url.
</li>
	<li>
%~navigable にて`作動中な~entry$nav ~SET %履歴~entry
◎
Set navigable's active session history entry to historyEntry.
</li>
	<li>
<p>
`履歴~stepを適用するために文書を更新する$( ↓ )
⇒＃
%~navigable にて`作動中な文書$nav,
%履歴~entry,
~T,
%~script履歴~index,
%~script履歴~長さ,
%履歴~取扱い
◎
Update document for history step application given navigable's active document, historyEntry, true, scriptHistoryIndex, scriptHistoryLength, and historyHandling.
</p>

<div class="note">
<p>注記：
この~algoは、
1 回の素片への~naviの結果として， 2 回~callされることになる：
◎
This algorithm will be called twice as a result of a single fragment navigation:＼
</p>
		<ul>
			<li>
1 回目は同期的に
— そこでは
⇒＃
［ %~script履歴~index, %~script履歴~長さ ］用に最善な推測~値が設定される／
`state＠~WINDOW#dom-history-state$m は ~NULL化される／
各種~eventが発火される
◎
once synchronously, where best-guess values scriptHistoryIndex and scriptHistoryLength are set, history.state is nulled out, and various events are fired;＼
</li>
			<li>
2 回目は非同期的に
— そこでは
⇒＃
［ %~script履歴~index, %~script履歴~長さ ］用の最終-値が設定される／
`state＠~WINDOW#dom-history-state$m には触れられない／
~eventは発火されない
◎
and once asynchronously, where the final values for index and length are set, history.state remains untouched, and no events are fired.
</li>
		</ul>
</div>
	</li>
	<li>
<p>
`素片へ~scrollする$( %~navigable にて`作動中な文書$nav )
◎
Scroll to the fragment given navigable's active document.
</p>

<p class="note">注記：
［
`文書$は新たなもので，関連な`~ID$はまだ構文解析されてない
］ことにより，~scrollするのに失敗した場合、［
`履歴~stepを適用するために文書を更新する$ 2 回目の非同期的な~call
］が~scrollすることを~careすることになる。
◎
If the scrolling fails because the Document is new and the relevant ID has not yet been parsed, then the second asynchronous call to update document for history step application will take care of scrolling.
</p>
	</li>
	<li>
%辿可能 ~LET %~navigable の`辿可能な~navigable$nav
◎
Let traversable be navigable's traversable navigable.
</li>
	<li>
<p>
%~navigable を孕んでいる`~session履歴~同期~navi手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history synchronous navigation steps involving navigable to traversable:
</p>

<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
`同一-文書~naviを完結する$( ↓ )
⇒＃
%辿可能,
%~navigable,
%履歴~entry,
%置換する~entry,
%履歴~取扱い
%利用者-関与i
◎
Finalize a same-document navigation given traversable, navigable, historyEntry, entryToReplace, historyHandling, and userInvolvement.
</li>
			<li>
`~WebDriver-BiDi素片へ~navigateされた$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `完了した$wBDst, %~URL )
◎
Invoke WebDriver BiDi fragment navigated with navigable and a new WebDriver BiDi navigation status whose id is navigationId, url is url, and status is "complete".
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`同一-文書~naviを完結する@
~algoは、
所与の
⇒＃
`辿可能な~navigable$ %辿可能,
`~navigable$ %~target~navigable,
`~session履歴~entry$ %~target~entry,
［`~session履歴~entry$／~NULL］ %置換する~entry,
`履歴~取扱いの挙動$ %履歴~取扱い,
`~naviに対する利用者-関与i$ %利用者-関与i,
◎終
に対し：
◎
To finalize a same-document navigation given a traversable navigable traversable, a navigable targetNavigable, a session history entry targetEntry, a session history entry-or-null entryToReplace, a history handling behavior historyHandling, and a user navigation involvement userInvolvement:
</p>

<p class="note">注記：
これは、［
`素片への~navi$,
`~URLと履歴の更新$
］により利用される
— ~session履歴に対する同期的な更新は、
それらに限られる。
これらの~algoは、
同期的であることにより，
`~top-level辿可能$の`~session履歴~辿り~queue$navの外側で遂行され、
その結果，
`~top-level辿可能$の`現在の~session履歴~step$navと同期cしなくなる
— なので、
競争~条件に因る競合を解決するため，この~algoが利用される。
◎
This is used by both fragment navigations and by the URL and history update steps, which are the only synchronous updates to session history. By virtue of being synchronous, those algorithms are performed outside of the top-level traversable's session history traversal queue. This puts them out of sync with the top-level traversable's current session history step, so this algorithm is used to resolve conflicts due to race conditions.
</p>
<ol>
	<li>
~Assert：
これは、
%辿可能 の`~session履歴~辿り~queue$navの中で走っている。
◎
Assert: this is running on traversable's session history traversal queue.
</li>
	<li>
~IF［
%~target~navigable にて`作動中な~entry$nav ~NEQ %~target~entry
］
⇒
~RET
◎
If targetNavigable's active session history entry is not targetEntry, then return.
</li>
	<li>
%~target~step ~LET ~NULL
◎
Let targetStep be null.
</li>
	<li>
%~target~entry群 ~LET `~session履歴~entry群を取得する$( %~target~navigable )
◎
Let targetEntries be the result of getting session history entries for targetNavigable.
</li>
	<li>
<p>
~IF［
%置換する~entry ~EQ ~NULL
］：
◎
If entryToReplace is null, then:
</p>
		<ol>
			<li>
`前方~session履歴を~clearする$( %辿可能 )
◎
Clear the forward session history of traversable.
</li>
			<li>
%~target~step ~SET %辿可能 の`現在の~session履歴~step$nav ~PLUS 1
◎
Set targetStep to traversable's current session history step + 1.
</li>
			<li>
%~target~entry の`~step$shE ~SET %~target~step
◎
Set targetEntry's step to targetStep.
</li>
			<li>
%~target~entry群 に %~target~entry を`付加する$
◎
Append targetEntry to targetEntries.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~target~entry群 の中で %~target~entry を %置換する~entry に`置換する$
◎
Replace entryToReplace with targetEntry in targetEntries.
</li>
			<li>
%~target~entry の`~step$shE ~SET %置換する~entry の`~step$shE
◎
Set targetEntry's step to entryToReplace's step.
</li>
			<li>
%~target~step ~SET %辿可能 の`現在の~session履歴~step$nav
◎
Set targetStep to traversable's current session history step.
</li>
		</ol>
	</li>
	<li>
<p>
`~push／置換-用に履歴~stepを適用する$( ↓ )
⇒＃
%辿可能,
%~target~step,
%履歴~取扱い,
%利用者-関与i
◎
Apply the push/replace history step targetStep to traversable given historyHandling and userInvolvement.
</p>

<p class="note">注記：
これは、
`replace$hH ~naviに対しても行われる
— それは、
複数の同期的な~naviにまたがる競争~条件を解決するので。
◎
This is done even for "replace" navigations, as it resolves race conditions across multiple synchronous navigations.
</p>
	</li>
</ol>
</div>

					</section>
					<section id="non-fetch-schemes-and-external-software">
<h6 title="Non-fetch schemes and external software">7.4.2.3.4 非-~fetch~schemeと外部~software</h6>

<p>
`非-~fetch~scheme文書を作成しようと試みる$ときの入力は、
`非-~fetch~scheme~navi~params@
である。
それは、
`~navi~params$の軽量な~versionであり、
それが運ぶ~parameterは，［
非-`~fetch~scheme$へ~navigateする事例に関連なもの
］に限られる。
それは、
次に挙げる`~item$sctからなる`構造体$である：
◎
The input to attempt to create a non-fetch scheme document is the non-fetch scheme navigation params struct. It is a lightweight version of navigation params which only carries parameters relevant to the non-fetch scheme navigation case. It has the following items:
</p>
<ul>
	<li>
`~ID@nfSnvP
⇒
~NULL ／`~navi~ID$
◎
id
• null or a navigation ID
</li>
	<li>
`~navigable@nfSnvP
⇒
当の~naviを経ている`~navigable$
◎
navigable
• the navigable experiencing the navigation
</li>
	<li>
`~URL@nfSnvP
⇒
`~URL$
◎
URL
• a URL
</li>
	<li>
`~target~snapshotの~sandbox法~flag群@nfSnvP
⇒
~naviの間に在る，`~target~snapshot~params$の`~sandbox法~flag群$tsP
◎
target snapshot sandboxing flags
• the target snapshot params's sandboxing flags present during navigation
</li>
	<li>
`~source~snapshotは一過な作動化を有するか@nfSnvP
⇒
真偽値
— 作動化の間に在る，`~source~snapshot~params$の`一過な作動化を有するか$ssPの複製
◎
source snapshot has transient activation
• a copy of the source snapshot params's has transient activation boolean present during activation
</li>
	<li>
<p>
`起動元~生成元@nfSnvP
⇒
`生成元$
— 場合によっては、［
外部~software~packageの呼出nを確認するために，利用者が直面する~prompt
］に利用される。
◎
initiator origin
• an origin possibly for use in a user-facing prompt to confirm the invocation of an external software package
</p>

<p class="note">注記：
これは、
非-`~fetch~scheme$を伴う~URLで終了~する~redirect連鎖において，
`~fetch~scheme$を伴う最後の~URLまで~redirectに追従する。
そのことにおいて、
これは，`文書~状態$shEの`起動元~生成元$dSから少し相違する。
◎
This differs slightly from a document state's initiator origin in that a non-fetch scheme navigation params's initiator origin follows redirects up to the last fetch scheme URL in a redirect chain that ends in a non-fetch scheme URL.
</p>
	</li>
	<li>
`~navi計時~種別@nfSnvP
⇒
`NavigationTimingType$I
— 新たな`文書$が作成されたならば，
それ用に`~navi計時~entryを作成する$ために利用される。
◎
navigation timing type
• a NavigationTimingType used for creating the navigation timing entry for the new Document (if one is created)
</li>
	<li>
`利用者-関与i@nfSnvP
⇒
`~naviに対する利用者-関与i$
— 新たな`文書$が作成されたならば，
それ用に`~navi応答~用に利用する閲覧~文脈を得する$ときに利用される。
◎
user involvement
• a user navigation involvement used when obtaining a browsing context for the new Document (if one is created)
</li>
</ul>

<div class="algo">
<p id="process-a-navigate-url-scheme">
`非-~fetch~scheme文書を作成しようと試みる@
~algoは、
所与の
( `非-~fetch~scheme~navi~params$ %~navi~params )
に対し：
◎
To attempt to create a non-fetch scheme document, given a non-fetch scheme navigation params navigationParams:
</p>
<ol>
	<li>
%~URL ~LET %~navi~params の`~URL$nfSnvP
◎
Let url be navigationParams's URL.
</li>
	<li>
%~navigable ~LET %~navi~params の`~navigable$nfSnvP
◎
Let navigable be navigationParams's navigable.
</li>
	<li>
<p>
~IF［
%~URL は［
%~navigable に影響しない仕組みを利用して取扱われるもの
］である（例： %~URL の`~scheme$urlは外部的に取扱われるものである）
］：
◎
If url is to be handled using a mechanism that does not affect navigable,＼
e.g., because url's scheme is handled externally, then:
</p>
		<ol>
			<li>
`外部~softwareに手渡す$( ↓ )
⇒＃
%~URL,
%~navigable,
%~navi~params の`~target~snapshotの~sandbox法~flag群$nfSnvP,
%~navi~params の`~source~snapshotは一過な作動化を有するか$nfSnvP,
%~navi~params の`起動元~生成元$nfSnvP
◎
Hand-off to external software given url, navigable, navigationParams's target snapshot sandboxing flags, navigationParams's source snapshot has transient activation, and navigationParams's initiator origin.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
<p>
~RET `~DOMを有さない文書~用に~inline内容を作成する$( ↓ )
⇒＃
%~navigable,
%~navi~params の`~ID$nfSnvP,
%~navi~params の`~navi計時~種別$nfSnvP
%~navi~params の`利用者-関与i$nfSnvP
◎
↓Handle url by displaying some sort of inline content, e.g., an error message because the specified scheme is not one of the supported protocols, or an inline prompt to allow the user to select a registered handler for the given scheme.＼
Return the result of displaying the inline content given navigable, navigationParams's id, navigationParams's navigation timing type, and navigationParams's user involvement.
</p>

<p>
これは、
所与の~scheme用に何らかの類の~inline内容を表示することにより
 %~URL を取扱う
— 例
⇒＃
指定された~schemeは~supportされる~protocolでないことを示す~error~message／
利用者が 所与の~scheme用の`登録-済み~handler$を選定することを許容する~inline~prompt
◎
↑</p>

<p class="note">注記：
登録-済み~handlerが利用されている事例では、
`~navi~algo$は，新たな~URLで再び呼出されることになる。
◎
In the case of a registered handler being used, navigate will be invoked with a new URL.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`外部~softwareに手渡す@
~algoは、
所与の
⇒＃
［`~URL$／`応答$］ %資源,
`~navigable$ %~navigable,
`~sandbox法~flag集合$ %~sandbox~flag群,
真偽値 %一過な作動化か,
`生成元$ %起動元~生成元
◎終
に対し，
~UAは次を遂行するベキである：
◎
To hand-off to external software given a URL or response resource, a navigable navigable, a sandboxing flag set sandboxFlags, a boolean hasTransientActivation, and an origin initiatorOrigin, user agents should:
</p>
<ol>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
		<ul>
			<li>
%~navigable は`~top-level辿可能$でない
◎
navigable is not a top-level traversable;
</li>
			<li>
`閲覧~文脈~sandbox化( ~custom~protocol~navi )~flag$ ~IN %~sandbox~flag群
◎
sandboxFlags has its sandboxed custom protocols navigation browsing context flag set; and
</li>
			<li>
［
`閲覧~文脈~sandbox化( 利用者-作動化を伴う~top-level~navi )~flag$ ~IN %~sandbox~flag群
］~OR［
%一過な作動化か ~EQ ~F
］
◎
sandboxFlags has its sandboxed top-level navigation with user activation browsing context flag set, or hasTransientActivation is false,
</li>
		</ul>
<p>
…ならば
⇒
~RET
（ 外部~software~packageは呼出さない。）
◎
then return without invoking the external software package.
</p>

<p class="note">注記：
~iframeの内側から外部~softwareへ向けた~naviは、
利用者からは，新たな［
~popup／~top-level~navi
］として見えることもある。
それがゆえ、
そのような~naviが~sandbox化された `iframe$e において許容されるのは，次に挙げるいずれかが指定されたときに限られる
⇒＃
`allow-popups$v,
`allow-top-navigation$v,
`allow-top-navigation-by-user-activation$v,
`allow-top-navigation-to-custom-protocols$v
◎
Navigation inside an iframe toward external software can be seen by users as a new popup or a new top-level navigation. That's why its is allowed in sandboxed iframe only when one of allow-popups, allow-top-navigation, allow-top-navigation-by-user-activation, or allow-top-navigation-to-custom-protocols is specified.
</p>
	</li>
	<li>
<p>
外部~softwareに %資源 を適切に手渡す
— 次に従う下で：
◎
Perform the appropriate handoff of resource＼
</p>
		<ul>
			<li>
当の外部~softwareを悪用しようと試みる~riskを軽減するよう試みる。
例えば，~UAは、［
%起動元~生成元 が当の外部~softwareを呼出すことを許容するかどうか
］を確認するよう，利用者に~promptすることもできる。
◎
while attempting to mitigate the risk that this is an attempt to exploit the target software. For example, user agents could prompt the user to confirm that initiatorOrigin is to be allowed to invoke the external software in question.＼
</li>
			<li>
特に，［
%一過な作動化か ~EQ ~F
］の場合、
前もって利用者の確認をとらずに，
外部~software~packageを呼出すベキでない。
◎
In particular, if hasTransientActivation is false, then the user agent should not invoke the external software package without prior user confirmation.
</li>
		</ul>

<p class="example">
例えば，当の外部~softwareの~URL~handler内には、［
ある敵対的な~pageが，~linkを~clickするよう利用者を騙す
］ように悪用できる脆弱性があるかもしれない。
◎
For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
</p>
	</li>
</ol>
</div>

				</section>
				<section id="preventing-navigation">
<h5 title="Preventing navigation">7.4.2.4. ~naviの防止-法</h5>

<p>
少数の局面は、
~navi処理nの早期に介入して，全体を~~停止させ得る。
これは，とりわけ、
~session履歴の辿りに因り，同時に複数の`~navigable$が~navigateしているとき顕著になり得る。
◎
A couple of scenarios can intervene early in the navigation process and put the whole thing to a halt. This can be especially exciting when multiple navigables are navigating at the same time, due to a session history traversal.
</p>

<div class="algo">
<p>
`~navigable$ %~source が
所与の`~source~snapshot~params$ %~source~snapshot~params の下で
`~navigable$ %~target を
`~navigateすることは~sandbox法により許容され@
るのは、
次の手続きが ~T を返すときである：
◎
A navigable source is allowed by sandboxing to navigate a second navigable target, given a source snapshot params sourceSnapshotParams, if the following steps return true:
</p>
<ol>
	<li>
~IF［
%~source ~EQ %~target
］
⇒
~RET ~T
◎
If source is target, then return true.
</li>
	<li>
~IF［
%~source は %~target の先祖である
］
⇒
~RET ~T
◎
If source is an ancestor of target, then return true.
</li>
	<li>
%~source~sandbox法~flag群 ~LET %~source~snapshot~params の`~sandbox法~flag群$ssP
◎
↓</li>
	<li>
<p>
~IF［
%~target は %~source の先祖である
］：
◎
If target is an ancestor of source, then:
</p>
		<ol>
			<li>
~IF［
%~target は`~top-level辿可能$でない
］
⇒
~RET ~T
◎
If target is not a top-level traversable, then return true.
</li>
			<li>
~IF［
%~source~snapshot~params の`一過な作動化を有するか$ssP ~EQ ~T
］~AND［
`閲覧~文脈~sandbox化( 利用者-作動化を伴う~top-level~navi )~flag$ ~IN %~source~sandbox法~flag群
］
⇒
~RET ~F
◎
If sourceSnapshotParams's has transient activation is true, and sourceSnapshotParams's sandboxing flags's sandboxed top-level navigation with user activation browsing context flag is set, then return false.
</li>
			<li>
~IF［
%~source~snapshot~params の`一過な作動化を有するか$ssP ~EQ ~F
］~AND［
`閲覧~文脈~sandbox化( 利用者-作動化を伴わない~top-level~navi )~flag$ ~IN %~source~sandbox法~flag群
］
⇒
~RET ~F
◎
If sourceSnapshotParams's has transient activation is false, and sourceSnapshotParams's sandboxing flags's sandboxed top-level navigation without user activation browsing context flag is set, then return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~target は`~top-level辿可能$である
］：
◎
If target is a top-level traversable:
</p>
		<ol>
			<li>
~IF［
%~source ~EQ %~target の`許可-済み~navigator$
］
⇒
~RET ~T
◎
If source is the one permitted sandboxed navigator of target, then return true.
</li>
			<li>
~IF［
`閲覧~文脈~sandbox化( ~navi )~flag$ ~IN %~source~sandbox法~flag群
］
⇒
~RET ~F
◎
If sourceSnapshotParams's sandboxing flags's sandboxed navigation browsing context flag is set, then return false.
</li>
			<li>
~RET ~T
◎
Return true.
</li>
		</ol>
	</li>
	<li>
~IF［
`閲覧~文脈~sandbox化( ~navi )~flag$ ~IN %~source~sandbox法~flag群
］
⇒
~RET ~F
◎
If sourceSnapshotParams's sandboxing flags's sandboxed navigation browsing context flag is set, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~unloadは取消されたか否か検査する@
~algoは、
所与の
⇒＃
`~navigable$たちが成す`~list$ %~beforeunload_evが必要になる~navigable群,
`辿可能な~navigable$ %辿可能 ~DF ε,
整数 %~target~step ~DF ε,
`~naviに対する利用者-関与i$ %~navigate_ev~event用の利用者-関与i ~DF ε
◎終
に対し，［
`~beforeunload_evにより取消された^i ／
`~navigate_evにより取消された^i ／
`継続する^i 
］を返す：
◎
To check if unloading is canceled for a list of navigables navigablesThatNeedBeforeUnload, given an optional traversable navigable traversable, an optional integer targetStep, and an optional user navigation involvement userInvolvementForNavigateEvent, run these steps. They return "canceled-by-beforeunload", "canceled-by-navigate", or "continue".
</p>
<ol>
	<li>
%~beforeunload_evが発火される文書~群 ~LET 新たな`~list$
◎
↓</li>
	<li>
%~beforeunload_evが必要になる~navigable群 を成す
~EACH( %~navigable )
に対し
⇒
%~beforeunload_evが発火される文書~群 に %~navigable にて`作動中な文書$navを`付加する$
◎
Let documentsToFireBeforeunload be the active document of each item in navigablesThatNeedBeforeUnload.
</li>
	<li>
%~unload~promptを示したか ~LET ~F
◎
Let unloadPromptShown be false.
</li>
	<li>
%最終-状態s ~LET `継続する^i
◎
Let finalStatus be "continue".
</li>
	<li>
<p>
~IF［
%辿可能 ~NEQ ε
］：
◎
If traversable was given, then:
</p>
		<ol>
			<li>
~Assert：
［
%~target~step ~NEQ ε
］~AND［
%~navigate_ev~event用の利用者-関与i ~NEQ ε
］
◎
Assert: targetStep and userInvolvementForNavigateEvent were given.
</li>
			<li>
%~target~entry ~LET `~target履歴~entryを取得する$( %辿可能, %~target~step )
◎
Let targetEntry be the result of getting the target history entry given traversable and targetStep.
</li>
			<li>
<div>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
%~target~entry ~NEQ %辿可能 の`現在の~session履歴~entry$nav
</li>
					<li>
%~target~entry の`文書~状態$shEの`生成元$dS
~EQ`生成元$sub
%辿可能 の`現在の~session履歴~entry$navの`文書~状態$shEの`生成元$dS
</li>
				</ul>
<p>
…ならば：
</p>
◎
If targetEntry is not traversable's current session history entry, and targetEntry's document state's origin is the same as traversable's current session history entry's document state's origin, then:
</div>

<div class="note">
<p>注記：
この事例では、
%辿可能 用の `navigate$et ~eventをここから発火する。
それは，
`一部の状況下＠~HTMLnavAPI#navigate-event-traverse-can-be-canceled$では取消されるかもしれないので、
後で起こる`他の辿り~navigate_ev~event＠#descendant-navigable-traversal-navigate-events$から，これを別々に行う必要がある。
◎
In this case, we're going to fire the navigate event for traversable here. Because under some circumstances it might be canceled, we need to do this separately from other traversal navigate events, which happen later.
</p>

<p>
加えて，［
`beforeunload$et ~eventは `navigate$et ~eventより前に発火する
］ことが求まれるので、
このことは，
%辿可能 用の `beforeunload$et を（適用-可能ならば）ここで発火する必要があることも意味する
— 下で，
%~beforeunload_evが発火される文書~群 に対する~loopの中から発火する代わりに。
◎
Additionally, because we want beforeunload events to fire before navigate events, this means we need to fire beforeunload for traversable here (if applicable), instead of doing it as part of the below loop over documentsToFireBeforeunload.
</p>
</div>
				<ol>
					<li>
%~eventは発火したか ~LET ~F
◎
Let eventsFired be false.
</li>
					<li>
%~beforeunload_evは必要か ~LET ~IS［
%辿可能 ~IN %~beforeunload_evが必要になる~navigable群
］
◎
Let needsBeforeunload be true if navigablesThatNeedBeforeUnload contains traversable; otherwise false.
</li>
					<li>
~IF［
%~beforeunload_evは必要か ~EQ ~T
］
⇒
%~beforeunload_evが発火される文書~群 から %辿可能 にて`作動中な文書$navを`除去する$
◎
If needsBeforeunload is true, then remove traversable's active document from documentsToFireBeforeunload.
</li>
					<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %辿可能 にて`作動中な~window$nav, 
次の手続き )
◎
Queue a global task on the navigation and traversal task source given traversable's active window to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
						<ol>
							<li>
<p>
~IF［
%~beforeunload_evは必要か ~EQ ~T
］：
◎
If needsBeforeunload is true, then:
</p>
								<ol>
									<li>
( %この文書~用の~unload~promptを示したか, %~unload~promptはこの文書により取消されたか )
~LET
`~beforeunload_evを発火する手続き$( %辿可能 にて`作動中な文書$nav, ~F )
◎
Let (unloadPromptShownForThisDocument, unloadPromptCanceledByThisDocument) be the result of running the steps to fire beforeunload given traversable's active document and false.
</li>
									<li>
~IF［
%この文書~用の~unload~promptを示したか ~EQ ~T
］
⇒
%~unload~promptを示したか ~SET ~T
◎
If unloadPromptShownForThisDocument is true, then set unloadPromptShown to true.
</li>
									<li>
~IF［
%~unload~promptはこの文書により取消されたか ~EQ ~T
］
⇒
%最終-状態s ~SET `~beforeunload_evにより取消された^i
◎
If unloadPromptCanceledByThisDocument is true, then set finalStatus to "canceled-by-beforeunload".
</li>
								</ol>
							</li>
							<li>
~IF［
%最終-状態s ~EQ `~beforeunload_evにより取消された^i
］
⇒
~RET
◎
If finalStatus is "canceled-by-beforeunload", then abort these steps.
</li>
							<li>
%~navi ~LET %辿可能 にて`作動中な~window$navの`~navi~API$
◎
Let navigation be traversable's active window's navigation API.
</li>
							<li>
%~navigate_ev~event結果 ~LET `辿-用の~navigate_ev~eventを発火する$( %~navi )
— 次も与える下で
⇒＃
`行先~履歴~entry^i ~SET %~target~entry,
`利用者-関与i^i ~SET %~navigate_ev~event用の利用者-関与i
◎
Let navigateEventResult be the result of firing a traverse navigate event at navigation given targetEntry and userInvolvementForNavigateEvent.
</li>
							<li>
~IF［
%~navigate_ev~event結果 ~EQ ~F
］
⇒
%最終-状態s ~SET `~navigate_evにより取消された^i
◎
If navigateEventResult is false, then set finalStatus to "canceled-by-navigate".
</li>
							<li>
%~eventは発火したか ~SET ~T
◎
Set eventsFired to true.
</li>
						</ol>
</div>
					</li>
					<li>
次が満たされるまで待機する
⇒
%~eventは発火したか ~EQ ~T
◎
Wait until eventsFired is true.
</li>
					<li>
~IF［
%最終-状態s ~NEQ `継続する^i
］
⇒
~RET %最終-状態s
◎
If finalStatus is not "continue", then return finalStatus.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%総~task数 ~LET %~beforeunload_evが発火される文書~群 の`~size$
◎
Let totalTasks be the size of documentsToFireBeforeunload.
</li>
	<li>
%完了した~task数 ~LET 0
◎
Let completedTasks be 0.
</li>
	<li>
<p>
%~beforeunload_evが発火される文書~群 を成す
~EACH( %文書 )
に対し
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
For each document of documentsToFireBeforeunload, queue a global task on the navigation and traversal task source given document's relevant global object to run＼
</p>
<div class="algo">
<p>
手続きは：
◎
the steps:
</p>
		<ol>
			<li>
( %この文書~用の~unload~promptを示したか, %~unload~promptはこの文書により取消されたか )
~LET `~beforeunload_evを発火する手続き$( %文書, %~unload~promptを示したか )
◎
Let (unloadPromptShownForThisDocument, unloadPromptCanceledByThisDocument) be the result of running the steps to fire beforeunload given document and unloadPromptShown.
</li>
			<li>
~IF［
%この文書~用の~unload~promptを示したか ~EQ ~T
］
⇒
%~unload~promptを示したか ~SET ~T
◎
If unloadPromptShownForThisDocument is true, then set unloadPromptShown to true.
</li>
			<li>
~IF［
%~unload~promptはこの文書により取消されたか ~EQ ~T
］
⇒
%最終-状態s ~SET `~beforeunload_evにより取消された^i
◎
If unloadPromptCanceledByThisDocument is true, then set finalStatus to "canceled-by-beforeunload".
</li>
			<li>
%完了した~task数 ~INCBY 1
◎
Increment completedTasks.
</li>
		</ol>
</div>
	</li>
	<li>
次が満たされるまで待機する
⇒
%完了した~task数 ~EQ %総~task数
◎
Wait for completedTasks to be totalTasks.
</li>
	<li>
~RET %最終-状態s
◎
Return finalStatus.
</li>
</ol>
</div>

<div class="algo">
<p>
`~beforeunload_evを発火する手続き@
は、
所与の
( `文書$ %文書, 真偽値 %~unload~promptを示したか )
に対し：
◎
The steps to fire beforeunload given a Document document and a boolean unloadPromptShown are:
</p>
<ol>
	<li>
%~unload~promptは取消されたか ~LET ~F
◎
Let unloadPromptCanceled be false.
</li>
	<li>
%文書 の`~unload~counter$ ~INCBY 1
◎
Increase the document's unload counter by 1.
</li>
	<li>
%文書 に`関連な~agent$の`~event~loop$aG の`終了n入子ng~level$ ~INCBY 1
◎
Increase document's relevant agent's event loop's termination nesting level by 1.
</li>
	<li>
%~eventを発火した結果 ~LET `~eventを発火する$( %文書 に`関連な大域~obj$, `beforeunload$et, `BeforeUnloadEvent$I )
— 次のように初期化して
⇒＃
`cancelable$m 属性 ~SET ~T
◎
Let eventFiringResult be the result of firing an event named beforeunload at document's relevant global object, using BeforeUnloadEvent, with the cancelable attribute initialized to true.
</li>
	<li>
%文書 に`関連な~agent$の`~event~loop$aGの`終了n入子ng~level$ ~DECBY 1
◎
Decrease document's relevant agent's event loop's termination nesting level by 1.
</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
		<ul>
			<li>
%~unload~promptを示したか ~EQ ~F
◎
unloadPromptShown is false;
</li>
			<li>
`~sandbox化( ~modal )~flag$ ~NIN %文書 にて`作動中な~sandbox法~flag集合$
◎
document's active sandboxing flag set does not have its sandboxed modals flag set;
</li>
			<li>
%文書 に`関連な大域~obj$は`居残な作動化を有して$いる
◎
document's relevant global object has sticky activation;
</li>
			<li>
［
%~eventを発火した結果 ~EQ ~F
］~OR［
%~event の `returnValue＠~WINDOW#dom-beforeunloadevent-returnvalue$m 属性 ~NEQ 空~文字列
］
◎
eventFiringResult is false, or the returnValue attribute of event is not the empty string; and
</li>
			<li>
~unload~promptを示すことが［
いらつく／紛らわしい／的外れである
］とは見込まれていない
◎
showing an unload prompt is unlikely to be annoying, deceptive, or pointless,
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%~unload~promptを示したか ~SET ~T
◎
Set unloadPromptShown to true.
</li>
			<li>
%利用者~prompt~handler ~LET `~WebDriver-BiDi利用者~promptが開かれた$( ↓ )
⇒＃
%文書 に`関連な大域~obj$,
`beforeunload^l,
空~文字列
◎
Let userPromptHandler be the result of WebDriver BiDi user prompt opened with document's relevant global object, "beforeunload", and "".
</li>
			<li>
~IF［
%利用者~prompt~handler ~EQ `dismiss^l
］
⇒
%~unload~promptは取消されたか ~SET ~T
◎
If userPromptHandler is "dismiss", then set unloadPromptCanceled to true.
</li>
			<li>
<p>
~IF［
%利用者~prompt~handler ~EQ `none^l
］：
◎
If userPromptHandler is "none", then:
</p>
				<ol>
					<li>
<p>
利用者に［
文書を~unloadするよう望むか確認する
］よう依頼する
— 利用者からの応答を待機している間，`静止する$
◎
Ask the user to confirm that they wish to unload the document, and pause while waiting for the user's response.
</p>

<p class="note">注記：
利用者に示される~messageは、
~custom化-可能ではなく，~UAにより決定される。
特に， `returnValue＠~WINDOW#dom-beforeunloadevent-returnvalue$m 属性の実際の値は無視される。
◎
The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual value of the returnValue attribute is ignored.
</p>
					</li>
					<li>
~IF［
利用者は~page~naviを確認しなかった
］
⇒
%~unload~promptは取消されたか ~SET ~T
◎
If the user did not confirm the page navigation, then set unloadPromptCanceled to true.
</li>
				</ol>
			</li>
			<li>
`~WebDriver-BiDi利用者~promptが閉じられた$( ↓ )
⇒＃
%文書 に`関連な大域~obj$,
`beforeunload^l,
~IS［ %~unload~promptは取消されたか ~EQ ~F ］
◎
Invoke WebDriver BiDi user prompt closed with document's relevant global object, "beforeunload", and true if unloadPromptCanceled is false or false otherwise.
</li>
		</ol>
	</li>
	<li>
%文書 の`~unload~counter$ ~DECBY 1
◎
Decrease document's unload counter by 1.
</li>
	<li>
~RET ( %~unload~promptを示したか, %~unload~promptは取消されたか )
◎
Return (unloadPromptShown, unloadPromptCanceled).
</li>
</ol>
</div>

				</section>
				<section id="aborting-navigation">
<h5 title="Aborting navigation">7.4.2.5. ~naviの中止-法</h5>

<p id="concept-navigate-mature">
各`~navigable$には、
`進行中な~navi@
がある
— それは、［
`~navi~ID$ ／ `traversal^l ／ ~NULL
］であり，
初期~時は ~NULL とする。
それは、
次のために利用される
⇒＃
~naviの中止-法を追跡する／
`辿りの間＠#apply-the-traverse-history-step$に~naviが場を占めるのを防止する
◎
Each navigable has an ongoing navigation, which is a navigation ID, "traversal", or null, initially null. It is used to track navigation aborting and to prevent any navigations from taking place during traversal.
</p>

<div class="algo">
<p>
`進行中な~naviを設定する@
~algoは、
所与の
( `~navigable$ %~navigable, %新たな値 )
に対し：
◎
To set the ongoing navigation for a navigable navigable to newValue:
</p>
<ol>
	<li>
~IF［
%~navigable の`進行中な~navi$ ~EQ %新たな値
］
⇒
~RET
◎
If navigable's ongoing navigation is equal to newValue, then return.
</li>
	<li>
`~naviを中止したことについて~navi~APIに伝える$( %~navigable )
◎
Inform the navigation API about aborting navigation given navigable.
</li>
	<li>
%~navigable の`進行中な~navi$ ~SET %新たな値
◎
Set navigable's ongoing navigation to newValue.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="reloading-and-traversing">
<h4 title="Reloading and traversing">7.4.3. 再読込み法と辿-法</h4>

<div class="algo">
<p>
`~navigableを読込直す@
~algoは、
所与の
⇒＃
`~navigable$ %~navigable,
`直列形の状態$ %~navi~API状態 ~DF ~NULL,
`~naviに対する利用者-関与i$ %利用者-関与i ~DF `なし$i
◎終
に対し：
◎
To reload a navigable navigable given an optional serialized state-or-null navigationAPIState (default null) and an optional user navigation involvement userInvolvement (default "none"):
</p>
<ol>
	<li>
<p>
~IF［
%利用者-関与i ~NEQ `~browser~UI$i
］：
◎
If userInvolvement is not "browser UI", then:
</p>
		<ol>
			<li>
%~navi ~LET %~navigable にて`作動中な~window$navの`~navi~API$
◎
Let navigation be navigable's active window's navigation API.
</li>
			<li>
%行先~navi~API状態 ~LET %~navigable にて`作動中な~entry$navの`~navi~API状態$shE
◎
Let destinationNavigationAPIState be navigable's active session history entry's navigation API state.
</li>
			<li>
~IF［
%~navi~API状態 ~NEQ  ~NULL 
］
⇒
%行先~navi~API状態 ~SET %~navi~API状態
◎
If navigationAPIState is not null, then set destinationNavigationAPIState to navigationAPIState.
</li>
			<li>
%継続するか ~LET `~push／置換-／再読込み用の~navigate_ev~eventを発火する$( %~navi )
— 次も与える下で
⇒＃
`~navi種別^i ~SET `reload$l,
`同一-文書か^i ~SET ~F,
`利用者-関与i^i ~SET %利用者-関与i,
`行先~URL^i ~SET %~navigable にて`作動中な~entry$navの`~URL$shE,
`~navi~API状態^i ~SET %行先~navi~API状態
◎
Let continue be the result of firing a push/replace/reload navigate event at navigation with navigationType set to "reload", isSameDocument set to false, userInvolvement set to userInvolvement, destinationURL set to navigable's active session history entry's URL, and navigationAPIState set to destinationNavigationAPIState.
</li>
			<li>
~IF［
%継続するか ~EQ ~F
］
⇒
~RET
◎
If continue is false, then return.
</li>
		</ol>
	</li>
	<li>
%~navigable にて`作動中な~entry$navの`文書~状態$shEの`再読込みは処理待ちか$dS ~SET ~T
◎
Set navigable's active session history entry's document state's reload pending to true.
</li>
	<li>
%辿可能 ~LET %~navigable の`辿可能な~navigable$nav
◎
Let traversable be navigable's traversable navigable.
</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history traversal steps to traversable:
</p>

<div class="algo">
手続きは
⇒
`再読込み用に履歴~stepを適用する$( %辿可能, %利用者-関与i )
◎
Apply the reload history step to traversable given userInvolvement.
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`履歴を差分だけ辿る@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, 整数 %差分, `文書$ %~source文書 ~DF ε )
に対し：
◎
To traverse the history by a delta given a traversable navigable traversable, an integer delta, and an optional Document sourceDocument:
</p>
<ol>
	<li>
%~source~snapshot~params ~LET ~NULL
◎
↓</li>
	<li>
%検査する起動元 ~LET ~NULL
◎
Let sourceSnapshotParams and initiatorToCheck be null.
</li>
	<li>
%利用者-関与i ~LET `~browser~UI$i
◎
Let userInvolvement be "browser UI".
</li>
	<li>
<p>
~IF［
%~source文書 ~NEQ ε
］：
◎
If sourceDocument is given, then:
</p>
		<ol>
			<li>
%~source~snapshot~params ~SET `~source~snapshot~paramsを~snapshotする$( %~source文書 )
◎
Set sourceSnapshotParams to the result of snapshotting source snapshot params given sourceDocument.
</li>
			<li>
%検査する起動元 ~SET %~source文書 の`~node~navigable$
◎
Set initiatorToCheck to sourceDocument's node navigable.
</li>
			<li>
%利用者-関与i ~SET `なし$i
◎
Set userInvolvement to "none".
</li>
		</ol>
	</li>
	<li>
<p>
`~session履歴~辿り手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history traversal steps to traversable:
</p>

<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%全~step群 ~LET `利用されたすべての履歴~stepを取得する$( %辿可能 )
◎
Let allSteps be the result of getting all used history steps for traversable.
</li>
			<li>
%現在の~step ~LET %辿可能 の`現在の~session履歴~step$nav
◎
↓</li>
			<li>
~Assert：
%現在の~step ~IN %全~step群
【この段は、この訳による補完】
◎
↓</li>
			<li>
%現在の~step~index ~LET %全~step群 の中における %現在の~step の~index
◎
Let currentStepIndex be the index of traversable's current session history step within allSteps.
</li>
			<li>
%~target~step~index ~LET %現在の~step~index ~PLUS %差分
◎
Let targetStepIndex be currentStepIndex plus delta.
</li>
			<li>
~IF［
%~target~step~index ~NIN %全~step群【！allSteps[targetStepIndex]】
］
⇒
~RET
◎
If allSteps[targetStepIndex] does not exist, then abort these steps.
</li>
			<li>
`辿-用に履歴~stepを適用する$( ↓ )
⇒＃
%~target~step~index【！allSteps[targetStepIndex]】,
%辿可能,
%~source~snapshot~params,
%検査する起動元,
%利用者-関与i
◎
Apply the traverse history step allSteps[targetStepIndex] to traversable, given sourceSnapshotParams, initiatorToCheck, and userInvolvement.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

			</section>
			<section id="navigate-non-frag-sync">
<h4 title="Non-fragment synchronous &quot;navigations&quot;">7.4.4 非-素片による同期的な “~navi”</h4>

<p>
`~navi~algo$は別として、
`~session履歴~entry$は，
もう一つの仕組み
— `~URLと履歴の更新$ —
を介して［
~pushされ／置換され
］得る。
これらの手続きの最も周知な~call元は，［
`history.replaceState()$c,
`history.pushState()$c
］~APIであるが、
この標準を成す様々な他の各部も，
`作動中な~entry$navに対する更新を遂行する必要がある
— それら各部は、
この手続きを利用して，それを行う。
◎
Apart from the navigate algorithm, session history entries can be pushed or replaced via one more mechanism, the URL and history update steps. The most well-known callers of these steps are the history.replaceState() and history.pushState() APIs, but various other parts of the standard also need to perform updates to the active history entry, and they use these steps to do so.
</p>

<div class="algo">
<div id="history-1">
<p>
`~URLと履歴を更新する@
~algoは、
所与の
( `文書$ %文書, `~URL$ %新-~URL )
および，所与の：
</p>
<ul>
	<li id="uhus-serializeddata">
`直列形の状態$ %直列形の~data ~DF ~NULL
</li>
	<li id="uhus-historyhandling">
`履歴~取扱いの挙動$ %履歴~取扱い ~DF `replace$hH
</li>
</ul>
<p>
に対し：
</p>
◎
The URL and history update steps, given a Document document, a URL newURL, an optional serialized state-or-null serializedData (default null), and an optional history handling behavior historyHandling (default "replace"), are:
</div>
<ol>
	<li>
%~navigable ~LET %文書 の`~node~navigable$
◎
Let navigable be document's node navigable.
</li>
	<li>
%作動中な~entry ~LET %~navigable にて`作動中な~entry$nav
◎
Let activeEntry be navigable's active session history entry.
</li>
	<li>
%直列形の状態 ~LET %直列形の~data に応じて
⇒＃
~NULL ならば %作動中な~entry の`古典~履歴~API用の状態$shE ／
~ELSE_ %直列形の~data
◎
↓</li>
	<li>
%新たな~entry ~LET 新たな`~session履歴~entry$
— その
⇒＃
`~URL$shE ~SET %新-~URL,
`古典~履歴~API用の状態$shE ~SET %直列形の状態,
`文書~状態$shE ~SET %作動中な~entry の`文書~状態$shE,
`~scroll復旧~mode$shE ~SET %作動中な~entry の`~scroll復旧~mode$shE,
`持続される利用者~状態$shE ~SET %作動中な~entry の`持続される利用者~状態$shE
◎
Let newEntry be a new session history entry, with
◎
URL
• newURL
serialized state
• if serializedData is not null, serializedData; otherwise activeEntry's classic history API state
document state
• activeEntry's document state
scroll restoration mode
• activeEntry's scroll restoration mode
persisted user state
• activeEntry's persisted user state
</li>
	<li>
<p>
~IF［
%文書 の`初期~about_blankか$doc ~EQ ~T
］
⇒
%履歴~取扱い ~SET `replace$hH
◎
If document's is initial about:blank is true, then set historyHandling to "replace".
</p>

<p class="note">注記：
この段は、
次を意味する
⇒
`初期~about_blank な文書$に対する `history.pushState()$c は、
`history.replaceState()$c の~callとして挙動する。
◎
This means that pushState() on an initial about:blank Document behaves as a replaceState() call.
</p>
	</li>
	<li>
%置換する~entry ~LET %履歴~取扱い に応じて
⇒＃
`replace$hH ならば %作動中な~entry ／
~ELSE_ 他の場合 ~NULL
◎
Let entryToReplace be activeEntry if historyHandling is "replace", otherwise null.
</li>
	<li>
<p>
~IF［
%履歴~取扱い ~EQ `push$hH
］：
◎
If historyHandling is "push", then:
</p>
		<ol>
			<li>
%文書 の`履歴~obj$の`~index$hsT ~INCBY 1
◎
Increment document's history object's index.
</li>
			<li>
%文書 の`履歴~obj$の`長さ$hsT ~SET %文書 の`履歴~obj$の`~index$hsT ~PLUS 1
◎
Set document's history object's length to its index + 1.
</li>
		</ol>

<p class="note">注記：
即時な同期的~access用に一時的な［
最善な推測~値
］が在る。
◎
These are temporary best-guess values for immediate synchronous access.
</p>
	</li>
	<li>
~IF［
%直列形の~data ~NEQ ~NULL
］
⇒
`履歴~objの状態を復旧する$( %文書, %新たな~entry )
◎
If serializedData is not null, then restore the history object state given document and newEntry.
</li>
	<li>
<p>
`文書の~URLを設定する$( %文書, %新-~URL )
◎
Set the URL given document to newURL.
</p>

<p class="note">注記：
これは，
`~navi$でも`履歴の辿り$でもないので、
`hashchange$et ~eventを発火させることはない。
◎
Since this is neither a navigation nor a history traversal, it does not cause a hashchange event to be fired.
</p>
	</li>
	<li>
%文書 の`最近の~entry$ ~SET %新たな~entry
◎
Set document's latest entry to newEntry.
</li>
	<li>
%~navigable にて`作動中な~entry$nav ~SET %新たな~entry
◎
Set navigable's active session history entry to newEntry.
</li>
	<li>
`同一-文書~navi用に~navi~API~entry群を更新する$( %文書 に`関連な大域~obj$の`~navi~API$, %新たな~entry, %履歴~取扱い )
◎
Update the navigation API entries for a same-document navigation given document's relevant global object's navigation API, newEntry, and historyHandling.
</li>
	<li>
%辿可能 ~LET %~navigable の`辿可能な~navigable$nav
◎
Let traversable be navigable's traversable navigable.
</li>
	<li>
<p>
%~navigable を孕んでいる`~session履歴~同期~navi手続きを付加する$( %辿可能, 次の手続き )
◎
Append the following session history synchronous navigation steps involving navigable to traversable:
</p>
<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
`同一-文書~naviを完結する$( ↓ )
⇒＃
%辿可能,
%~navigable,
%新たな~entry,
%置換する~entry,
%履歴~取扱い,
`なし$i
◎
Finalize a same-document navigation given traversable, navigable, newEntry, entryToReplace, historyHandling, and "none".
</li>
			<li>
`~WebDriver-BiDi履歴が更新された$( %~navigable )
◎
Invoke WebDriver BiDi history updated with navigable.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<p class="note">注記：
［
`素片への~navi$, `~URLと履歴の更新$
］は，どちらも履歴の更新を同期的に遂行するが、
素片への~naviに限り，
`履歴~stepを適用するために文書を更新する$手続きを同期的に~callする。
`~URLと履歴の更新$は、
代わりに，［
少数に選定され，他は省略された
］更新を上の~algoの内側で遂行する。
これは，いくぶん歴史的に不幸な巡り合わせであり、
この不整合は，一般に`~web開発者を落胆させている＠~HTMLissue/5562$。
このことは、
例えば `popstate$et ~eventは，［
素片への~navi用には発火されるが，
`history.pushState()$c ~call用には発火されない
］ことを意味する。
◎
Although both fragment navigation and the URL and history update steps perform synchronous history updates, only fragment navigation contains a synchronous call to update document for history step application. The URL and history update steps instead perform a few select updates inside the above algorithm, omitting others. This is somewhat of an unfortunate historical accident, and generally leads to web-developer sadness about the inconsistency. For example, this means that popstate events fire for fragment navigations, but not for history.pushState() calls.
</p>

			</section>
			<section id="populating-a-session-history-entry">
<h4 title="Populating a session history entry">7.4.5. ~session履歴~entryの拡充-法</h4>

<p>
`§ 概観＠#navigation-and-session-history$【！#history】にて説明したとおり、
`~navi＠#navigating-across-documents$も`辿り＠#reloading-and-traversing$も，次を孕む
⇒
`~session履歴~entry$を作成してから、
その`文書$shE~memberを
— それを`~navigable$の内側に呈示できるよう —
拡充しようと試みる。
◎
As explained in the overview, both navigation and traversal involve creating a session history entry and then attempting to populate its document member, so that it can be presented inside the navigable.
</p>

<p>
これは、
次のいずれかを孕む：
◎
This involves either:＼
</p>
<ul>
	<li>
`すでに与えられた応答＠#note-navigate-called-with-response$
— 当の`~session履歴~entry$内に格納された`資源$dS —
を利用すること
◎
using an already-given response; using the srcdoc resource stored in the session history entry;＼
</li>
	<li>
`~fetchingにより~navi~paramsを作成する$こと
◎
or fetching.＼
</li>
</ul>

<p>
この処理nには，いくつかの失敗~modeがあり、
その結果は，次のいずれかになる
⇒＃
何もしない（`~navigable$にて現在`作動中な文書$navを そのままにする）／
当の`~session履歴~entry$を`~error文書＠~HTMLlifecycle#read-ua-inline$で拡充する
◎
The process has several failure modes, which can either result in doing nothing (leaving the navigable on its currently-active Document) or can result in populating the session history entry with an error document.
</p>

<div class="algo">
<div>
<p>
`履歴~entryの文書を拡充するよう試みる@
~algoは、
所与の
⇒＃
`~session履歴~entry$ %~entry,
`~navigable$ %~navigable,
`NavigationTimingType$I %~navi計時~種別,
`~source~snapshot~params$ %~source~snapshot~params,
`~target~snapshot~params$ %~target~snapshot~params,
`~naviに対する利用者-関与i$ %利用者-関与i,
`~navi~ID$ %~navi~ID ~DF ~NULL,
`~navi~params$ %~navi~params ~DF ~NULL,
文字列 %~CSP~navi種別 ~DF `other^l,
◎終
および，所与の：
</p>
<ul>
	<li id="attempt-to-populate-allow-post">
真偽値 %~POSTを許容するか ~DF ~F
</li>
	<li id="attempt-to-populate-completion-steps">
~algo手続き %完了~手続き ~DF 何もしない~algo
</li>
</ul>
<p>
に対し：
</p>
◎
To attempt to populate the history entry's document for a session history entry entry, given a navigable navigable, a NavigationTimingType navTimingType, a source snapshot params sourceSnapshotParams, a target snapshot params targetSnapshotParams, a user navigation involvement userInvolvement, an optional navigation ID-or-null navigationId (default null), an optional navigation params-or-null navigationParams (default null), an optional string cspNavigationType (default "other"), an optional boolean allowPOST (default false), and optional algorithm steps completionSteps (default an empty algorithm):
</div>

<ol>
	<li>
~Assert：
これは、
`並列的$に走っている。
◎
Assert: this is running in parallel.
</li>
	<li>
~Assert：
［
%~navi~params ~NEQ ~NULL
］ならば［
%~navi~params の`応答$nvP ~NEQ ~NULL
］
◎
Assert: if navigationParams is non-null, then navigationParams's response is non-null.
</li>
	<li>
%文書~資源 ~LET %~entry の`文書~状態$shEの`資源$dS
◎
Let documentResource be entry's document state's resource.
</li>
	<li>
<p>
~IF［
%~navi~params ~EQ ~NULL
］：
◎
If navigationParams is null, then:
</p>
		<ol>
			<li>
~IF［
%文書~資源 は文字列である
］
⇒
%~navi~params ~SET `~srcdoc資源から~navi~paramsを作成する$( ↓ )
⇒＃
%~entry,
%~navigable,
%~target~snapshot~params,
%利用者-関与i,
%~navi~ID,
%~navi計時~種別
◎
If documentResource is a string, then set navigationParams to the result of creating navigation params from a srcdoc resource given entry, navigable, targetSnapshotParams, userInvolvement, navigationId, and navTimingType.
</li>
			<li>
<p>
~ELIF［
~AND↓
］…
◎
Otherwise, if all of the following are true:
</p>
				<ul>
					<li>
%~entry の`~URL$shEの`~scheme$urlは`~fetch~scheme$である
◎
entry's URL's scheme is a fetch scheme; and
</li>
					<li>
［［
%文書~資源 ~EQ ~NULL
］~OR［
%~POSTを許容するか ~EQ ~T
］］~AND［
%文書~資源 の`要請~本体$pR ~NEQ `失敗^i
］
◎
documentResource is null, or allowPOST is true and documentResource's request body is not failure,
</li>
				</ul>
<p>
…ならば
⇒
%~navi~params ~SET `~fetchingにより~navi~paramsを作成する$( ↓ )
⇒＃
%~entry,
%~navigable,
%~source~snapshot~params,
%~target~snapshot~params,
%~CSP~navi種別,
%利用者-関与i,
%~navi~ID,
%~navi計時~種別
◎
then set navigationParams to the result of creating navigation params by fetching given entry, navigable, sourceSnapshotParams, targetSnapshotParams, cspNavigationType, userInvolvement, navigationId, and navTimingType.
</p>
			</li>
			<li>
~ELIF［
%~entry の`~URL$shEの`~scheme$urlは`~fetch~scheme$でない
］
⇒
%~navi~params ~SET 新たな`非-~fetch~scheme~navi~params$
— その
⇒＃
`~ID$nfSnvP ~SET %~navi~ID,
`~navigable$nfSnvP ~SET %~navigable,
`~URL$nfSnvP ~SET %~entry の`~URL$shE,
`~target~snapshotの~sandbox法~flag群$nfSnvP ~SET %~target~snapshot~params の`~sandbox法~flag群$tsP,
`~source~snapshotは一過な作動化を有するか$nfSnvP ~SET %~source~snapshot~params の`一過な作動化を有するか$ssP,
`起動元~生成元$nfSnvP ~SET %~entry の`文書~状態$shEの`起動元~生成元$dS,
`~navi計時~種別$nfSnvP ~SET %~navi計時~種別
`利用者-関与i$nfSnvP ~SET %利用者-関与i
◎
Otherwise, if entry's URL's scheme is not a fetch scheme, then set navigationParams to a new non-fetch scheme navigation params, with
◎
id
• navigationId
navigable
• navigable
URL
• entry's URL
target snapshot sandboxing flags
• targetSnapshotParams's sandboxing flags
source snapshot has transient activation
• sourceSnapshotParams's has transient activation
initiator origin
• entry's document state's initiator origin
navigation timing type
• navTimingType
user involvement
• userInvolvement
</li>
		</ol>
	</li>
	<li id="process-a-navigate-response">
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$bc, 次の手続き )：
◎
Queue a global task on the navigation and traversal task source, given navigable's active window,＼
</p>

<div class="algo">
<p>
手続きは：
◎
to run these steps:
</p>
		<ol>
			<li>
~IF［
%~navigable の`進行中な~navi$ ~NEQ %~navi~ID
］
⇒＃
%完了~手続き()；
~RET
◎
If navigable's ongoing navigation no longer equals navigationId, then run completionSteps and abort these steps.
</li>
			<li>
<p>
%余分な文書~状態を保存するか ~LET ~T
◎
Let saveExtraDocumentState be true.
</p>

<div class="note">
<p>注記：
%~entry の`文書~状態$shEの`文書$dSを拡充する結果になる事例では、
通例的に，`文書$から一部の状態を %~entry の中へ保存することが求まれる。
これは、
未来に %~entry への辿りが生じた際に %~entry の`文書$dSが`破壊されていた＠#note-bfcache$場合に［
新たな`文書$を作成するとき，保存しておいた状態を利用できる
］ことを確保する。
◎
Usually, in the cases where we end up populating entry's document state's document, we then want to save some of the state from that Document into entry. This ensures that if there are future traversals to entry where its document has been destroyed, we can use that state when creating a new Document.
</p>

<p>
しかしながら、
一部の特定の事例では，状態を保存しても助けにならない。
そのような場合、
%余分な文書~状態を保存するか は，
この~algo内の後の段で ~F に設定される。
◎
However, in some specific cases, saving the state would be unhelpful. For those, we set saveExtraDocumentState to false later in this algorithm.
</p>
</div>
			</li>
			<li>
%文書~状態 ~LET %~entry の`文書~状態$shE
◎
↓</li>
			<li>
<p>
~IF［
%~navi~params は`非-~fetch~scheme~navi~params$である
］：
◎
If navigationParams is a non-fetch scheme navigation params, then:
</p>
				<ol>
					<li>
<p>
%文書~状態 の`文書$dS ~SET `非-~fetch~scheme文書を作成しようと試みる$( %~navi~params )
◎
Set entry's document state's document to the result of running attempt to create a non-fetch scheme document given navigationParams.
</p>

<p class="note">注記：
この結果、
%文書~状態 の`文書$dSは ~NULL に設定され得る
— 例：`外部~softwareに手渡す$とき。
◎
This can result in setting entry's document state's document to null, e.g., when handing-off to external software.
</p>
					</li>
					<li>
%余分な文書~状態を保存するか ~SET ~F
◎
Set saveExtraDocumentState to false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELIF［
~OR↓ が満たされる
］…
◎
Otherwise, if any of the following are true:
</p>
				<ul>
					<li>
%~navi~params ~EQ ~NULL
◎
navigationParams is null;
</li>
					<li>
次を遂行した結果 ~EQ `阻止される^i
`CSP$r
⇒
`~targetにおける ある種別の~navi要請に対する応答は~CSPにより阻止されるべきか？$( ↓ )
⇒＃
%~navi~params の`要請$nvP,
%~navi~params の`応答$nvP,
%~navi~params の`施策~容器$nvPの`~CSP~list$pC,
%~CSP~navi種別,
%~navigable
◎
the result of should navigation response to navigation request of type in target be blocked by Content Security Policy? given navigationParams's request, navigationParams's response, navigationParams's policy container's CSP list, cspNavigationType, and navigable is "Blocked";
</li>
					<li>
［
%~navi~params の`予約-済み環境$nvP ~NEQ ~NULL
］~AND［
次を遂行した結果 ~EQ ~F
］
⇒
`~navi応答の埋込元~施策に対する固守を検査する$( ↓ )
⇒＃
%~navi~params の`応答$nvP,
%~navigable,
%~navi~params の`施策~容器$nvPの`埋込元~施策$pC
◎
navigationParams's reserved environment is non-null and the result of checking a navigation response's adherence to its embedder policy given navigationParams's response, navigable, and navigationParams's policy container's embedder policy is false; or
</li>
					<li>
次を遂行した結果 ~EQ ~F
⇒
`~navi応答の~X-Frame-Optionsに対する固守を検査する$( ↓ )
⇒＃
%~navi~params の`応答$nvP,
%~navigable,
%~navi~params の`施策~容器$nvPの`~CSP~list$pC,
%~navi~params の`生成元$nvP
◎
the result of checking a navigation response's adherence to `X-Frame-Options` given navigationParams's response, navigable, navigationParams's policy container's CSP list, and navigationParams's origin is false,
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
<p>
%文書~状態 の`文書$dS ~SET `~DOMを有さない文書~用に~inline内容を作成する$( ↓ )
⇒＃
%~navigable,
~NULL,
%~navi計時~種別,
%利用者-関与i
◎
Set entry's document state's document to the result of creating a document for inline content that doesn't have a DOM, given navigable, null, navTimingType, and userInvolvement.＼
</p>

<p>
当の~inline内容は、
何らかの類の生じた~errorを利用者に指示するベキである。
◎
The inline content should indicate to the user the sort of error that occurred.
</p>
					</li>
					<li>
`文書を回復不能にする$( %文書~状態 の`文書$dS, `navigation-failure$l )
◎
Make document unsalvageable given entry's document state's document and "navigation-failure".
</li>
					<li>
%余分な文書~状態を保存するか ~SET ~F
◎
Set saveExtraDocumentState to false.
</li>
					<li>
<p>
~IF［
%~navi~params ~NEQ ~NULL
］：
◎
If navigationParams is not null, then:
</p>
						<ol>
							<li>
%~navi~params の`予約-済み環境$nvP用の`環境を破棄する手続き$()
◎
Run the environment discarding steps for navigationParams's reserved environment.
</li>
							<li>
`~WebDriver-BiDi~naviに失敗した$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `取消された$wBDst, %~navi~params の`応答$nvPの`~URL$rs )
◎
Invoke WebDriver BiDi navigation failed with navigable and a new WebDriver BiDi navigation status whose id is navigationId, status is "canceled", and url is navigationParams's response's URL.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li id="navigation-as-a-download">
<p>
~ELIF［
%~navi~params の`応答$nvP は
`Content-Disposition$h ~headerを有していて，
その値は~disposition型 `attachment^c を指定している
］：
◎
Otherwise, if navigationParams's response has a `Content-Disposition` header specifying the attachment disposition type, then:
</p>
				<ol>
					<li>
%~sourceは~downloadを許容するか ~LET %~source~snapshot~params の`~downloadを許容するか$ssP
◎
Let sourceAllowsDownloading be sourceSnapshotParams's allows downloading.
</li>
					<li>
%~targetは~downloadを許容するか ~LET ~IS［
`閲覧~文脈~sandbox化( ~download )~flag$ ~NIN  %~navi~params の`最終-~sandbox~flag集合$nvP
］
◎
Let targetAllowsDownloading be false if navigationParams's final sandboxing flag set has the sandboxed downloads browsing context flag set; otherwise true.
</li>
					<li>
%~UAは~downloadを許容するか ~LET ~T
◎
Let uaAllowsDownloading be true.
</li>
					<li>
任意選択で
⇒
~IF［［
~downloadを許容しない
］ことで［
敵対的になり得る~downloadから利用者を安全に防護する
］ものと予見される
］
⇒
%~UAは~downloadを許容するか ~SET ~F
◎
Optionally, the user agent may set uaAllowsDownloading to false, if it believes doing so would safeguard the user from a potentially hostile download.
</li>
					<li>
<div>
<p>
~IF［
~AND↓
］…
</p>
						<ul>
							<li>
%~sourceは~downloadを許容するか ~EQ ~T
</li>
							<li>
%~targetは~downloadを許容するか ~EQ ~T
</li>
							<li>
%~UAは~downloadを許容するか ~EQ ~T
</li>
						</ul>
◎
If sourceAllowsDownloading, targetAllowsDownloading, and uaAllowsDownloading are true, then:
</div>
<p>
…ならば
⇒
`応答を~downloadとして取扱う$( %~navi~params の`応答$nvP, %~navigable, %~navi~ID )
◎
Handle as a download navigationParams's response with navigable and navigationId.
</p>
					</li>
				</ol>
<p class="note">注記：
この分岐は、
%文書~状態 の`文書$dSを ~NULL のままにする。
◎
This branch leaves entry's document state's document as null.
</p>
			</li>
			<li>
<p>
~ELIF［
%~navi~params の`応答$nvPの`状態s$rs ~NIN { `204$hst, `205$hst }
］
⇒
%文書~状態 の`文書$dS ~SET `文書を読込む$( %~navi~params, %~source~snapshot~params, %文書~状態 の`起動元~生成元$dS )
◎
Otherwise, if navigationParams's response's status is not 204 and is not 205, then set entry's document state's document to the result of loading a document given navigationParams, sourceSnapshotParams, and entry's document state's initiator origin.
</p>

<p class="note">注記：
この結果、
%文書~状態 の`文書$dSは ~NULL に設定され得る
— 例：`外部~softwareに手渡す$とき。
◎
This can result in setting entry's document state's document to null, e.g., when handing-off to external software.
</p>
			</li>
			<li>
<p>
~IF［
%文書~状態 の`文書$dS ~NEQ ~NULL
］：
◎
If entry's document state's document is not null, then:
</p>

				<ol>
					<li>
%文書~状態 の`一度でも拡充されたか$dS ~SET ~T
◎
Set entry's document state's ever populated to true.
</li>
					<li>
<p>
~IF［
%余分な文書~状態を保存するか ~EQ ~T
］：
◎
If saveExtraDocumentState is true:
</p>
						<ol>
							<li>
%文書 ~LET %文書~状態 の`文書$dS
◎
Let document be entry's document state's document.
</li>
							<li>
%文書~状態 の`生成元$dS ~SET %文書 の`生成元$doc
◎
Set entry's document state's origin to document's origin.
</li>
							<li>
<p>
~IF［
`~URLは履歴~内に施策~容器を格納するよう要求するか？$( %文書 の`~URL$doc ) ~EQ ~T
］：
◎
If document's URL requires storing the policy container in history, then:
</p>
								<ol>
									<li>
~Assert：
%~navi~params は`~navi~params$である
（すなわち［
~NULL ／ `非-~fetch~scheme~navi~params$
］でない）。
◎
Assert: navigationParams is a navigation params (i.e., neither null nor a non-fetch scheme navigation params).
</li>
									<li>
%文書~状態 の`履歴~施策~容器$dS ~SET %~navi~params の`施策~容器$nvP
◎
Set entry's document state's history policy container to navigationParams's policy container.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%文書~状態 の`要請~referrer$dS ~EQ `client^l
］~AND［
%~navi~params は`~navi~params$である
（すなわち［
~NULL ／ `非-~fetch~scheme~navi~params$
］でない）
］：
◎
If entry's document state's request referrer is "client", and navigationParams is a navigation params (i.e., neither null nor a non-fetch scheme navigation params), then:
</p>
						<ol>
							<li>
~Assert：
%~navi~params の`要請$nvP ~NEQ ~NULL
◎
Assert: navigationParams's request is not null.
</li>
							<li>
%文書~状態 の`要請~referrer$dS ~SET %~navi~params の`要請$nvPの`~referrer$rq
◎
Set entry's document state's request referrer to navigationParams's request's referrer.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%完了~手続き()
◎
Run completionSteps.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~srcdoc資源から~navi~paramsを作成する@
~algoは、
所与の
⇒＃
`~session履歴~entry$ %~entry,
`~navigable$ %~navigable,
`~target~snapshot~params$ %~target~snapshot~params,
`~naviに対する利用者-関与i$ %利用者-関与i,
［`~navi~ID$／~NULL］ %~navi~ID,
`NavigationTimingType$I %~navi計時~種別
◎終
に対し：
◎
To create navigation params from a srcdoc resource given a session history entry entry, a navigable navigable, a target snapshot params targetSnapshotParams, a user navigation involvement userInvolvement, a navigation ID-or-null navigationId, and a NavigationTimingType navTimingType:
</p>
<ol>
	<li>
%文書~資源 ~LET %~entry の`文書~状態$shEの`資源$dS
◎
Let documentResource be entry's document state's resource.
</li>
	<li>
%応答 ~LET 新たな`応答$
— その
⇒＃
`~URL$rs ~SET `~about_srcdoc$sc,
`~header~list$rs ~SET « (`Content-Type$h, `text/html^bl ) »,
`本体$rs ~SET `~byte列を本体として取得する$( `~UTF-8符号化する$( %文書~資源 ) )
◎
Let response be a new response with
◎
URL
• about:srcdoc
header list
• « (`Content-Type`, `text/html`) »
body
• the UTF-8 encoding of documentResource, as a body
</li>
	<li>
%応答の生成元 ~LET `生成元を決定する$( ↓ )
⇒＃
%応答 の`~URL$rs,
%~target~snapshot~params の`~sandbox法~flag群$tsP,
%~entry の`文書~状態$shEの`生成元$dS
◎
Let responseOrigin be the result of determining the origin given response's URL, targetSnapshotParams's sandboxing flags, and entry's document state's origin.
</li>
	<li>
%~COOP ~LET 新たな`~opener施策$
◎
Let coop be a new opener policy.
</li>
	<li>
%~COOP施行n結果 ~LET 新たな`~opener施策の施行n結果$
— その
⇒＃
`~URL$cooP ~SET %応答 の`~URL$rs,
`生成元$cooP ~SET %応答の生成元,
`~opener施策$cooP ~SET %~COOP,
◎
Let coopEnforcementResult be a new opener policy enforcement result with
◎
url
• response's URL
origin
• responseOrigin
opener policy
• coop
</li>
	<li>
%施策~容器 ~LET `~navi~paramsの施策~容器を決定する$( ↓ )
⇒＃
%応答 の`~URL$rs,
%~entry の`文書~状態$shEの`履歴~施策~容器$dS,
~NULL,
%~navigable の`容器~文書$navの`施策~容器$doc,
~NULL
◎
Let policyContainer be the result of determining navigation params policy container given response's URL, entry's document state's history policy container, null, navigable's container document's policy container, and null.
</li>
	<li>
~RET 新たな`~navi~params$
— その
⇒＃
`~ID$nvP ~SET %~navi~ID,
`~navigable$nvP ~SET %~navigable,
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET %応答,
`~fetch制御器$nvP ~SET ~NULL,
`早期~hintを~commitする$nvP ~SET ~NULL,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`生成元$nvP ~SET %応答の生成元,
`施策~容器$nvP ~SET %施策~容器,
`最終-~sandbox~flag集合$nvP ~SET %~target~snapshot~params の`~sandbox法~flag群$tsP,
`~opener施策$nvP ~SET %~COOP,
`~navi計時~種別$nvP ~SET %~navi計時~種別,
`~about基底~URL$nvP ~SET %~entry の`文書~状態$shEの`~about基底~URL$dS
`利用者-関与i$nvP ~SET %利用者-関与i
◎
Return a new navigation params, with
◎
id
• navigationId
navigable
• navigable
request
• null
response
• response
fetch controller
• null
commit early hints
• null
COOP enforcement result
• coopEnforcementResult
reserved environment
• null
origin
• responseOrigin
policy container
• policyContainer
final sandboxing flag set
• targetSnapshotParams's sandboxing flags
opener policy
• coop
navigation timing type
• navTimingType
about base URL
• entry's document state's about base URL
user involvement
• userInvolvement
</li>
</ol>
</div>

<div class="algo">
<p id="process-a-navigate-fetch">
`~fetchingにより~navi~paramsを作成する@
~algoは、
所与の
⇒＃
`~session履歴~entry$ %~entry,
`~navigable$ %~navigable,
`~source~snapshot~params$ %~source~snapshot~params,
`~target~snapshot~params$ %~target~snapshot~params,
文字列 %~CSP~navi種別,
`~naviに対する利用者-関与i$ %利用者-関与i,
［`~navi~ID$／~NULL］ %~navi~ID,
`NavigationTimingType$I %~navi計時~種別
◎終
に対し，［
`~navi~params$／
`非-~fetch~scheme~navi~params$／
~NULL
］を返す：
◎
To create navigation params by fetching given a session history entry entry, a navigable navigable, a source snapshot params sourceSnapshotParams, a target snapshot params targetSnapshotParams, a string cspNavigationType, a user navigation involvement userInvolvement, a navigation ID-or-null navigationId, and a NavigationTimingType navTimingType, perform the following steps. They return a navigation params, a non-fetch scheme navigation params, or null.
</p>

<p class="note">注記：
この~algoは %~entry を変異する。
◎
This algorithm mutates entry.
</p>
<ol>
	<li>
~Assert：
これは、
`並列的$に走っている。
◎
Assert: this is running in parallel.
</li>
	<li>
%文書~資源 ~LET %~entry の`文書~状態$shEの`資源$dS
◎
Let documentResource be entry's document state's resource.
</li>
	<li>
<p>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~entry の`~URL$shE,
`~client$rq ~SET %~source~snapshot~params の`~fetch~client$ssP,
`行先$rq ~SET `document^l†,
`資格証~mode$rq ~SET `include^l,
`~URL資格証を利用するか$rq ~SET ~T,
`~redirect~mode$rq ~SET `manual^l,
`置換する~client~ID$rq ~SET %~navigable にて`作動中な文書$navに`関連な設定群~obj$の`~ID$enV,
`~mode$rq ~SET `navigate^l,
`~referrer$rq ~SET %~entry の`文書~状態$shEの`要請~referrer$dS,
`~referrer施策$rq ~SET %~entry の`文書~状態$shEの`要請~referrer施策$dS,
`施策~容器$rq ~SET %~source~snapshot~params の`~source施策~容器$ssP,
`利用者~prompt用の辿可能$rq ~SET %~navigable の`~top-level辿可能$nav
</p>

<p class="note">†注記：
行先は、
以下において %~navigable の`容器$navが ~NULL 以外になったとき，更新される。
</p>
◎
Let request be a new request, with
◎
url
• entry's URL
client
• sourceSnapshotParams's fetch client
destination
• "document" The destination is updated below when navigable has a container.
credentials mode
• "include"
use-URL-credentials flag
• set
redirect mode
• "manual"
replaces client id
• navigable's active document's relevant settings object's id
mode
• "navigate"
referrer
• entry's document state's request referrer
referrer policy
• entry's document state's request referrer policy
policy container
• sourceSnapshotParams's source policy container
traversable for user prompts
• navigable's top-level traversable
</li>
	<li>
~IF［
%~navigable は`~top-level辿可能$である
］
⇒
%要請 の`~top-level~navi起動元~生成元$rq ~SET %~entry の`文書~状態$shEの`起動元~生成元$dS
◎
If navigable is a top-level traversable, then set request's top-level navigation initiator origin to entry's document state's initiator origin.
</li>
	<li>
<p>
~IF［
%要請 の`~client$rq ~EQ ~NULL
］
⇒
%要請 の
⇒＃
`生成元$rq ~SET 新たな`不透明な生成元$,
`~sw~mode$rq ~SET `all^l,
`~referrer$rq ~SET `no-referrer^l
</p>

<p class="note">注記：
これは、
~browser~UIが起動した~naviの事例で`しか生じない＠#assert-null-sourcedocument$。
</p>
◎
If request's client is null:
◎
This only occurs in the case of a browser UI-initiated navigation.
◎
• Set request's origin to a new opaque origin.
• Set request's service-workers mode to "all".
• Set request's referrer to "no-referrer".
</li>
	<li>
<p>
~IF［
%文書~資源 は`~POST資源$である
］：
◎
If documentResource is a POST resource:
</p>
		<ol>
			<li>
%要請 の`~method$rq ~SET `POST^bl
◎
Set request's method to `POST`.
</li>
			<li>
%要請 の`本体$rq ~SET %文書~資源 の`要請~本体$pR
◎
Set request's body to documentResource's request body.
</li>
			<li>
%要請 の`~header~list$rq内で`~headerを設定する$(
( `Content-Type^h, %文書~資源 の`要請~内容~型$pR )
)
◎
Set `Content-Type` to documentResource's request content-type in request's header list.
</li>
		</ol>
	</li>
	<li>
~IF［
%~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~T
］
⇒
%要請 の`再読込み~naviか$rq ~SET ~T
◎
If entry's document state's reload pending is true, then set request's reload-navigation flag.
</li>
	<li>
~ELIF［
%~entry の`文書~状態$shEの`一度でも拡充されたか$dS ~EQ ~T
］
⇒
%要請 の`履歴~naviか$rq ~SET ~T
◎
Otherwise, if entry's document state's ever populated is true, then set request's history-navigation flag.
</li>
	<li>
~IF［
%~source~snapshot~params の`一過な作動化を有するか$ssP ~EQ ~T
］
⇒
%要請 の`利用者が作動化したか$rq ~SET ~T
◎
If sourceSnapshotParams's has transient activation is true, then set request's user-activation to true.
</li>
	<li>
<p>
~IF［
%~navigable の`容器$nav ~NEQ ~NULL
］：
◎
If navigable's container is non-null:
</p>
		<ol>
			<li>
~IF［
%~navigable の`容器$navは`閲覧~文脈~視野~生成元$を有する
］
⇒
%要請 の`生成元$rq ~SET その`閲覧~文脈~視野~生成元$
◎
If the navigable's container has a browsing context scope origin, then set request's origin to that browsing context scope origin.
</li>
			<li>
%局所~名 ~LET %~navigable の`容器$navの`局所~名$el
◎
↓</li>
			<li>
%要請 の`行先$rq ~SET %局所~名
◎
Set request's destination to navigable's container's local name.
</li>
			<li>
<p>
~IF［
%~source~snapshot~params の`~fetch~client$ssP ~EQ %~navigable の`容器~文書$navに`関連な設定群~obj$
］
⇒
%要請 の`起動元~種別$rq ~SET %局所~名
◎
If sourceSnapshotParams's fetch client is navigable's container document's relevant settings object, then set request's initiator type to navigable's container's local name.
</p>

<p class="note">注記：
これは、
次を確保する
⇒
資源~計時へ報告される~naviは、
容器により起動されたものに限られる
◎
This ensure that only container-initiated navigations are reported to resource timing.
</p>
			</li>
		</ol>
	</li>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%応答の生成元 ~LET ~NULL
◎
Let responseOrigin be null.
</li>
	<li>
%~fetch制御器 ~LET ~NULL
◎
Let fetchController be null.
</li>
	<li>
%現在の文脈は~navi~sourceか ~LET ~IS［
%~navigable にて`作動中な文書$navの`生成元$doc
~EQ`生成元$sub
%~entry の`文書~状態$shEの`起動元~生成元$dS
］
◎
↓</li>
	<li>
%~COOP施行n結果 ~LET 新たな`~opener施策の施行n結果$
— その
⇒＃
`~URL$cooP ~SET %~navigable にて`作動中な文書$navの`~URL$doc,
`生成元$cooP ~SET %~navigable にて`作動中な文書$navの`生成元$doc,
`~opener施策$cooP ~SET %~navigable にて`作動中な文書$navの`~opener施策$doc,
`現在の文脈は~navi~sourceか$cooP ~SET %現在の文脈は~navi~sourceか
◎
Let coopEnforcementResult be a new opener policy enforcement result, with
◎
url
• navigable's active document's URL
origin
• navigable's active document's origin
opener policy
• navigable's active document's opener policy
current context is navigation source
• true if navigable's active document's origin is same origin with entry's document state's initiator origin otherwise false
</li>
	<li>
%最終-~sandbox~flag群 ~LET 空な`~sandbox法~flag集合$
◎
Let finalSandboxFlags be an empty sandboxing flag set.
</li>
	<li>
%応答~施策~容器 ~LET ~NULL
◎
Let responsePolicyContainer be null.
</li>
	<li>
%応答の~COOP ~LET 新たな`~opener施策$
◎
Let responseCOOP be a new opener policy.
</li>
	<li>
%~Location~URL ~LET ~NULL
◎
Let locationURL be null.
</li>
	<li>
%現在の~URL ~LET %要請 の`現在の~URL$rq
◎
Let currentURL be request's current URL.
</li>
	<li>
%早期~hintを~commitする ~LET ~NULL
◎
Let commitEarlyHints be null.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
~IF［
%要請 の`予約-済み~client$rq ~NEQ ~NULL
］~AND［
%現在の~URL の`生成元$url
~NEQ`生成元$sub
%要請 の`予約-済み~client$rq の`作成時の~URL$enVの`生成元$url
］：
◎
If request's reserved client is not null and currentURL's origin is not the same as request's reserved client's creation URL's origin, then:
</p>
				<ol>
					<li>
%要請 の`予約-済み~client$rq用の`環境を破棄する手続き$()
◎
Run the environment discarding steps for request's reserved client.
</li>
					<li>
%要請 の`予約-済み~client$rq ~SET ~NULL
◎
Set request's reserved client to null.
</li>
					<li>
<p>
%早期~hintを~commitする ~SET ~NULL
◎
Set commitEarlyHints to null.
</p>

<p class="note">注記：
`早期~hint$~headerから~preloadされる~linkは、
`同一-生成元$への~redirectが生じても~preload~cache内に残り続けるが，
非同一-生成元への~redirectが生じたときは破棄される。
◎
Preloaded links from early hint headers remain in the preload cache after a same origin redirect, but get discarded when the redirect is cross-origin.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%要請 の`予約-済み~client$rq ~EQ ~NULL
］：
◎
If request's reserved client is null, then:
</p>
				<ol>
					<li>
%~top-level作成時の~URL ~LET %現在の~URL
◎
Let topLevelCreationURL be currentURL.
</li>
					<li>
%~top-level生成元 ~LET ~NULL
◎
Let topLevelOrigin be null.
</li>
					<li>
<p>
~IF［
%~navigable は`~top-level辿可能$でない
］：
◎
If navigable is not a top-level traversable, then:
</p>
						<ol>
							<li>
%親~環境 ~LET %~navigable の`親$navにて`作動中な文書$navに`関連な設定群~obj$
◎
Let parentEnvironment be navigable's parent's active document's relevant settings object.
</li>
							<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL.
</li>
							<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
Set topLevelOrigin to parentEnvironment's top-level origin.
</li>
						</ol>
					</li>
					<li>
<p>
%要請 の`予約-済み~client$rq ~SET 新たな`環境$
— その
⇒＃
`~ID$enV ~SET 一意かつ不透明な文字列,
`~target閲覧~文脈$enV ~SET %~navigable にて`作動中な閲覧~文脈$nav,
`作成時の~URL$enV ~SET %現在の~URL,
`~top-level作成時の~URL$enV ~SET %~top-level作成時の~URL,
`~top-level生成元$enV ~SET %~top-level生成元
◎
Set request's reserved client to a new environment whose id is a unique opaque string, target browsing context is navigable's active browsing context, creation URL is currentURL, top-level creation URL is topLevelCreationURL, and top-level origin is topLevelOrigin.
</p>

<p class="note">注記：
ここで作成した環境にて`作動中な~sw$enVは、
要請~URLが~sw登録に合致するならば，
~fetchの間に`~fetchを取扱う~algo＠~SW1#on-fetch-request-algorithm$の中で設定される。
`SW$r
◎
The created environment's active service worker is set in the Handle Fetch algorithm during the fetch if the request URL matches a service worker registration. [SW]
</p>
					</li>
				</ol>
			</li>
			<li>
~IF［
次の結果 ~EQ `阻止される^i
`CSP$r
］…
⇒
`ある種別の~navi要請は~CSPにより阻止されるべきか？$( %要請, %~CSP~navi種別 )
◎終
ならば
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
If the result of should navigation request of type be blocked by Content Security Policy? given request and cspNavigationType is "Blocked", then set response to a network error and break. [CSP]
</li>
			<li>
%応答 ~SET ~NULL
◎
Set response to null.
</li>
			<li>
<p>
~IF［
%~fetch制御器 ~EQ ~NULL
］
⇒
%~fetch制御器 ~SET %要請 を`~fetchする$
— 次を与える下で：
◎
If fetchController is null, then set fetchController to the result of fetching request,＼
↓ with processEarlyHintsResponse set to processEarlyHintsResponse as defined below, processResponse set to processResponse as defined below, and useParallelQueue set to true.
</p>
				<ul>
					<li class="algo">
`応答の早期~hintの処理n$i ~SET 所与の
( `応答$ %早期~応答 )
に対し，次を走らす手続き
⇒
~IF［
%早期~hintを~commitする ~EQ ~NULL
］
⇒
%早期~hintを~commitする ~SET `早期~hint~header群を処理する$( %早期~応答, %要請 の`予約-済み~client$rq )
◎
Let processEarlyHintsResponse be the following algorithm given a response earlyResponse:
• If commitEarlyHints is null, then set commitEarlyHints to the result of processing early hint headers given earlyResponse and request's reserved client.
</li>
					<li class="algo">
`応答の処理n$i ~SET 所与の
( `応答$ %~fetchした応答 )
に対し，次を走らす手続き
⇒
%応答 ~SET %~fetchした応答
◎
Let processResponse be the following algorithm given a response fetchedResponse:
• Set response to fetchedResponse.
</li>
					<li>
`並列~queueを利用するか$i ~SET ~T
◎
↑</li>
				</ul>
			</li>
			<li>
<p>
~ELSE
⇒
`次回の手動~redirect手続きを処理する$( %~fetch制御器 )
◎
Otherwise, process the next manual redirect for fetchController.
</p>

<p class="note">注記：
これによる結果、
上で［
この~loopの最初の反復の間に給した `応答の処理n$i
］が~callされ，
したがって %応答 を設定することになる。
◎
This will result in calling the processResponse we supplied above, during our first iteration through the loop, and thus setting response.
</p>

<p class="note">注記：
~naviは、
~redirectを手動で取扱う。
~web~platformにおいて，［
`mailto:＠~RFCx/rfc6068#section-2$sc に類する~URLへの~redirect
］を~careする唯一の箇所は、
~naviなので。
◎
Navigation handles redirects manually as navigation is the only place in the web platform that cares for redirects to mailto: URLs and such.
</p>
			</li>
			<li>
<p>
次が満たされるまで待機する
⇒
［
(1) %応答 ~NEQ ~NULL
］~OR［
(2) %~navigable の`進行中な~navi$ ~NEQ %~navi~ID
］
◎
Wait until either response is non-null, or navigable's ongoing navigation changes to no longer equal navigationId.
</p>

<p>
~IF［
条件 (2) が満たされた
］
⇒＃
`~fetchを中止する$( %~fetch制御器 )；
~RET
◎
If the latter condition occurs, then abort fetchController, and return.
◎
Otherwise, proceed onward.
</p>
			</li>
			<li>
<p>
~IF［
%要請 の`本体$rq ~EQ ~NULL
］
⇒
%~entry の`文書~状態$shEの`資源$dS ~SET ~NULL
◎
If request's body is null, then set entry's document state's resource to null.
</p>

<p class="note">注記：
~fetchは、
特定0の~redirectに対し，
`本体$rqを~NULL化する。
◎
Fetch unsets the body for particular redirects.
</p>
			</li>
			<li>
%応答~施策~容器 ~SET `~fetch応答から施策~容器を作成する$( %応答, %要請 の`予約-済み~client$rq )
◎
Set responsePolicyContainer to the result of creating a policy container from a fetch response given response and request's reserved client.
</li>
			<li>
%最終-~sandbox~flag群 ~SET 次の`和集合$
⇒＃
%~target~snapshot~params の`~sandbox法~flag群$tsP,
`~CSPから導出される~sandbox法~flag群$( %応答~施策~容器 の`~CSP~list$pC )
◎
Set finalSandboxFlags to the union of targetSnapshotParams's sandboxing flags and responsePolicyContainer's CSP list's CSP-derived sandboxing flags.
</li>
			<li>
<p>
%応答の生成元 ~SET `生成元を決定する$( ↓ )
⇒＃
%応答 の`~URL$rs,
%最終-~sandbox~flag群,
%~entry の`文書~状態$shEの`起動元~生成元$dS
◎
Set responseOrigin to the result of determining the origin given response's URL, finalSandboxFlags, and entry's document state's initiator origin.
</p>

<p class="note">注記：
%応答 は~redirectである場合、
%応答 の`~URL$rsは，［
%応答 の`~Location~URL＠~FETCH#concept-response-location-url$ではなく，
~redirectを そこへ導いた~URL
］になる。
◎
If response is a redirect, then response's URL will be the URL that led to the redirect to response's location URL; it will not be the location URL itself.
</p>
			</li>
			<li>
<p>
~IF［
%~navigable は`~top-level辿可能$である
］：
◎
If navigable is a top-level traversable, then:
</p>
				<ol>
					<li>
%応答の~COOP ~SET `~opener施策を得する$( %応答, %要請 の`予約-済み~client$rq )
◎
Set responseCOOP to the result of obtaining an opener policy given response and request's reserved client.
</li>
					<li>
%~COOP施行n結果 ~SET `応答の~opener施策を施行する$( ↓ )
⇒＃
%~navigable にて`作動中な閲覧~文脈$nav,
%応答 の`~URL$rs,
%応答の生成元,
%応答の~COOP,
%~COOP施行n結果,
%要請 の`~referrer$rq
◎
Set coopEnforcementResult to the result of enforcing the response's opener policy given navigable's active browsing context, response's URL, responseOrigin, responseCOOP, coopEnforcementResult, and request's referrer.
</li>
					<li>
<p>
~IF［
%最終-~sandbox~flag群 は空でない
］~AND［
%応答の~COOP の`値$coOP ~NEQ `unsafe-none$l
］
⇒＃
%応答 ~SET 適切な`~network~error$；
~BREAK
◎
If finalSandboxFlags is not empty and responseCOOP's value is not "unsafe-none", then set response to an appropriate network error and break.
</p>

<p class="note">注記：
この結果は、
~network~errorになる
— ~opener施策を利用している応答に対し，［
白紙状態を供する
］ことと［
その応答へ~navigateした結果を~sandbox化する
］ことは、
両立し得ないので。
◎
This results in a network error as one cannot simultaneously provide a clean slate to a response using opener policy and sandbox the result of navigating to that response.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
~AND↓
］…
◎
↓</p>
				<ul>
					<li>
%応答 は`~network~error$でない
◎
If response is not a network error,＼
</li>
					<li>
%~navigable は`子~navigable$である
◎
navigable is a child navigable,＼
</li>
					<li>
次を遂行した結果 ~EQ `阻止される^i
⇒
`非同一-生成元~資源~施策~検査$( ↓ )
⇒＃
%~navigable の`容器~文書$navの`生成元$doc,
%~navigable の`容器~文書$navに`関連な設定群~obj$,
%要請 の`行先$rq,
%応答,
~T
◎
and the result of performing a cross-origin resource policy check with navigable's container document's origin, navigable's container document's relevant settings object, request's destination, response, and true is blocked,＼
</li>
				</ul>
<p>
…ならば
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
then set response to a network error and break.
</p>

<p class="note">注記：
ここでは、
`非同一-生成元~資源~施策~検査$を`親~navigable$に対して走らす
— 埋込まれた内容が同一-生成元かどうかを~careするのは、［
%~navigable 自身ではなく，その`親$nav
］に対してなので。
◎
Here we're running the cross-origin resource policy check against the parent navigable rather than navigable itself. This is because we care about the same-originness of the embedded content against the parent context, not the navigation source.
</p>
			</li>
			<li>
%~Location~URL ~SET `応答の~Location~URLを得る$( %応答, %現在の~URL の`素片$url )
◎
Set locationURL to response's location URL given currentURL's fragment.
</li>
			<li>
~IF［
%~Location~URL ~IN { `失敗^i, ~NULL }
］
⇒
~BREAK
◎
If locationURL is failure or null, then break.
</li>
			<li>
~Assert：
%~Location~URL は`~URL$である。
◎
Assert: locationURL is a URL.
</li>
			<li>
%~entry の`古典~履歴~API用の状態$shE ~SET `StructuredSerializeForStorage$jA( ~NULL )
◎
Set entry's classic history API state to StructuredSerializeForStorage(null).
</li>
			<li>
%旧-文書~状態 ~LET %~entry の`文書~状態$shE
◎
Let oldDocState be entry's document state.
</li>
			<li>
%履歴~施策~容器 ~LET %旧-文書~状態 の`履歴~施策~容器$dS
◎
↓</li>
			<li>
<p>
~IF［
%履歴~施策~容器 ~NEQ ~NULL
］
⇒
%履歴~施策~容器 ~SET `施策~容器を~cloneする$( %履歴~施策~容器 )
</p>

<p class="note">注記：
ここで［
%履歴~施策~容器 ~NEQ ~NULL
］になるのは、
辿りの事例に限られる
— それは、
ここまでに，
`履歴~内に施策~容器を格納するよう要求される~URL＠~ORIGIN#requires-storing-the-policy-container-in-history$へ~navigateする間に拡充される。
</p>
◎
↓</li>
			<li>
<p>
%~entry の`文書~状態$shE ~SET 新たな`文書~状態$
— その
⇒＃
`履歴~施策~容器$dS ~SET %履歴~施策~容器,
`要請~referrer$dS ~SET %旧-文書~状態 の`要請~referrer$dS,
`要請~referrer施策$dS ~SET %旧-文書~状態 の`要請~referrer施策$dS,
`起動元~生成元$dS ~SET %旧-文書~状態 の`起動元~生成元$dS,
`生成元$dS ~SET %旧-文書~状態 の`生成元$dS,
`~about基底~URL$dS ~SET %旧-文書~状態 の`~about基底~URL$dS,
`資源$dS ~SET %旧-文書~状態 の`資源$dS,
`一度でも拡充されたか$dS ~SET %旧-文書~状態 の`一度でも拡充されたか$dS,
`~navigable名$dS ~SET %旧-文書~状態 の`~navigable名$dS
◎
Set entry's document state to a new document state, with
◎
history policy container
• a clone of the oldDocState's history policy container if it is non-null; null otherwise
request referrer
• oldDocState's request referrer
request referrer policy
• oldDocState's request referrer policy
initiator origin
• oldDocState's initiator origin
origin
• oldDocState's origin
about base URL
• oldDocState's about base URL
resource
• oldDocState's resource
ever populated
• oldDocState's ever populated
navigable target name
• oldDocState's navigable target name
</p>

<p class="note">注記：
%旧-文書~状態 を参照する~entryは、
~naviの事例では，
%~entry
— `~navigate~algo内の早期＠#navigation-create-document-state$に作成されたそれ —
に限られる。
なので、
~navi用には，この段は［
機能的には %~entry の`文書~状態$shEを更新するだけ
］である。
辿りの事例では，
%~entry に隣接な`~session履歴~entry$も %旧-文書~状態 を参照するアリ性があり、
その場合，［
%~entry の`文書~状態$shEを更新した後も，その行いを継続する
］ことになる。
◎
For the navigation case, only entry referenced oldDocState, which was created early in the navigate algorithm. So for navigations, this is functionally just an update to entry's document state. For the traversal case, it's possible adjacent session history entries also reference oldDocState, in which case they will continue doing so even after we've updated entry's document state.
◎
↑ oldDocState's history policy container is only ever non-null here in the traversal case, after we've populated it during a navigation to a URL that requires storing the policy container in history.
</p>

<div class="example">
<p>
次の`~Jake図式$のように設定しておかれた所で：
◎
The setup is given by the following Jake diagram:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step">1
<th class="step">2
<th class="step current">3
<tbody>

<tr><th>`top^c
<td colspan="1" class="doc-0 next-is-same-doc">`/a^c
<td colspan="1" class="doc-0 prev-is-same-doc next-is-same-doc">`/a#foo^c
<td colspan="1" class="doc-0 prev-is-same-doc">`/a#bar^c
<td colspan="1" class="doc-2 current">`/b^c
</table>

<p>
~step［
0, 1
］における~entryは，同じ`文書~状態$shEを共有していて、
~step 2 における~entryは，その`文書~状態$shEの`文書$dS ~EQ ~NULL
（すなわち，`~BF~cache$は効いてない）
とする。
◎
Also assume that the document state shared by the entries in steps 0, 1, and 2 has a null document, i.e., bfcache is not in play.
</p>

<p>
ここで、
~step 2 へ戻るよう辿る局面を考える。
が、
今回は `/a^c へ~fetchするとき，
~serverは `/c^c を指している `Location^h ~headerを伴わせて応答したとする
— すなわち、
%~Location~URL は `/c^c を指しているので，
~loopから ~BREAK で抜ける代わりに この段に達したとする。
◎
Now consider the scenario where we traverse back to step 2, but this time when fetching /a, the server responds with a `Location` header pointing to /c. That is, locationURL points to /c and so we have reached this step instead of breaking out of the loop.
</p>

<p>
この事例では、
~step 2 を占めている`~session履歴~entry$の`文書~状態$shEは置換されるが、
~step［
0, 1
］を占めている~entryの文書~状態は`置換されない^em。
結果の`~Jake図式$は、
次の様な見かけになる：
◎
In this case, we replace the document state of the session history entry occupying step 2, but we do not replace the document state of the entries occupying steps 0 and 1. The resulting Jake diagram looks like this:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step">1
<th class="step current">2
<th class="step">3
<tbody>

<tr><th>`top^c
<td colspan="1" class="doc-0 next-is-same-doc">`/a^c
<td colspan="1" class="doc-0 prev-is-same-doc">`/a#foo^c
<td colspan="1" class="doc-1 current">`/c#bar^c
<td colspan="1" class="doc-2">`/b^c
</table>

<p>
この置換は、
~redirect連鎖において元の~URLへ戻る結果になる場合でも
— 例えば `/c^c 自身が `/a^c を指している `Location^h ~headerを伴っていた場合でも —
遂行されることに注意。
そのような事例では、
次の様な結果になろう：
◎
Note that we perform this replacement even if we end up in a redirect chain back to the original URL, for example if /c itself had a `Location` header pointing to /a. Such a case would end up like so:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step">1
<th class="step current">2
<th class="step">3
<tbody>

<tr><th>`top^c
<td colspan="1" class="doc-0 next-is-same-doc">`/a^c
<td colspan="1" class="doc-0 prev-is-same-doc">`/a#foo^c
<td colspan="1" class="doc-1 current">`/a#bar^c
<td colspan="1" class="doc-2">`/b^c
</table>
</div>
			</li>
			<li>
<p>
~IF［
%~Location~URL の`~scheme$urlは`~HTTP_S~scheme$でない
］：
◎
If locationURL's scheme is not an HTTP(S) scheme, then:
</p>
				<ol>
					<li>
%~entry の`文書~状態$shEの`資源$dS ~SET ~NULL
◎
Set entry's document state's resource to null.
</li>
					<li>
~BREAK
◎
Break.
</li>
				</ol>
			</li>
			<li>
%現在の~URL ~SET %~Location~URL
◎
Set currentURL to locationURL.
</li>
			<li>
%~entry の`~URL$shE ~SET %現在の~URL
◎
Set entry's URL to currentURL.
</li>
		</ol>

<div class="note">
<p>注記：
この~loopの終了~時点で， ~OR↓ が満たされることになる：
◎
By the end of this loop we will be in one of these scenarios:
</p>
		<ul>
			<li>
%~Location~URL ~EQ `失敗^i
— `Location^h ~headerが構文解析-不能であったため。
◎
locationURL is failure, because of an unparseable `Location` header.
</li>
			<li>
%~Location~URL ~EQ ~NULL
— %応答 は`~network~error$であるか［
`~network~error$でない~HTTP_S応答を成功裡に~fetchしたが，
`Location^h ~headerを伴っていなかった
］ので。
◎
locationURL is null, either because response is a network error or because we successfully fetched a non-network error HTTP(S) response with no `Location` header.
</li>
			<li>
%~Location~URL は、
`~URL$であり，その`~scheme$urlは`~HTTP_S~scheme$でない。
◎
locationURL is a URL with a non-HTTP(S) scheme.
</li>
		</ul>
</div>
	</li>
	<li>
<p>
~IF［
%~Location~URL は`~URL$である
］~AND［
%~Location~URL の`~scheme$urlは`~fetch~scheme$でない
］
⇒
~RET 新たな`非-~fetch~scheme~navi~params$
— その
⇒＃
`~ID$nfSnvP ~SET %~navi~ID,
`~navigable$nfSnvP ~SET %~navigable,
`~URL$nfSnvP ~SET %~Location~URL,
`~target~snapshotの~sandbox法~flag群$nfSnvP ~SET %~target~snapshot~params の`~sandbox法~flag群$tsP,
`~source~snapshotは一過な作動化を有するか$nfSnvP ~SET %~source~snapshot~params の`一過な作動化を有するか$ssP,
`起動元~生成元$nfSnvP ~SET %応答の生成元,
`~navi計時~種別$nfSnvP ~SET %~navi計時~種別,
`利用者-関与i$nfSnvP ~SET %利用者-関与i
◎
If locationURL is a URL whose scheme is not a fetch scheme, then return a new non-fetch scheme navigation params, with
◎
id
• navigationId
navigable
• navigable
URL
• locationURL
target snapshot sandboxing flags
• targetSnapshotParams's sandboxing flags
source snapshot has transient activation
• sourceSnapshotParams's has transient activation
initiator origin
• responseOrigin
navigation timing type
• navTimingType
user involvement
• userInvolvement
</p>

<p class="note">注記：
この時点で、
%要請 の`現在の~URL$rqは，~redirect連鎖において
非-`~fetch~scheme$を伴う`~URL$へ~redirectする前の［
`~scheme$urlに`~fetch~scheme$を伴う最後の`~URL$
］になる。
この`~URL$の`生成元$urlが［
非-`~fetch~scheme$を伴う`~URL$への~navi用の起動元~生成元
］として利用されることになる。
◎
At this point, request's current URL is the last URL in the redirect chain with a fetch scheme before redirecting to a non-fetch scheme URL. It is this URL's origin that will be used as the initiator origin for navigations to non-fetch scheme URLs.
</p>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following are true:
</p>
		<ul>
			<li>
%応答 は`~network~error$である
◎
response is a network error;
</li>
			<li>
%~Location~URL ~EQ `失敗^i
◎
locationURL is failure; or
</li>
			<li>
［
%~Location~URL は`~URL$である
］~AND［
%~Location~URL の`~scheme$url は`~fetch~scheme$である
］
◎
locationURL is a URL whose scheme is a fetch scheme,
</li>
		</ul>
<p>
…ならば
⇒
~RET ~NULL
◎
then return null.
</p>

<p class="note">注記：
非-`~fetch~scheme$を伴う`~URL$への~redirectを許容する一方で、
`~HTTP_S~scheme$以外の`~fetch~scheme$を伴う`~URL$への~redirectは，
~network~errorの様に扱われる。
◎
We allow redirects to non-fetch scheme URLs, but redirects to fetch scheme URLs that aren't HTTP(S) are treated like network errors.
</p>
	</li>
	<li>
~Assert：
［
%~Location~URL ~EQ ~NULL
］~AND［
%応答 は`~network~error$でない
］
◎
Assert: locationURL is null and response is not a network error.
</li>
	<li>
%結果~施策~容器 ~LET `~navi~paramsの施策~容器を決定する$( ↓ )
⇒＃
%応答 の`~URL$rs,
%~entry の`文書~状態$shEの`履歴~施策~容器$dS,
%~source~snapshot~params の`~source施策~容器$ssP,
~NULL,
%応答~施策~容器
◎
Let resultPolicyContainer be the result of determining navigation params policy container given response's URL, entry's document state's history policy container, sourceSnapshotParams's source policy container, null, and responsePolicyContainer.
</li>
	<li>
<p>
~IF［
%~navigable の`容器$navは `iframe$e である
］~AND［
%応答 の`計時許容に合格したか$rs ~EQ ~T
］
⇒
%~navigable の`容器$navの`処理待ちな資源~計時の開始~時刻$ ~SET ~NULL
◎
If navigable's container is an iframe, and response's timing allow passed flag is set, then set navigable's container's pending resource-timing start time to null.
</p>

<p class="note">注記：
資源~計時【 `RESOURCETIMING$r 】へ報告することが `iframe$e に許容される場合、
通常の報告-法が起こるので，
その~fallback手続き†を走らす必要は無い。
【†おそらく、`~iframe~load~event手続き$の中で，`処理待ちな資源~計時の開始~時刻$ ~NEQ ~NULL のときに遂行されるそれを指す。】
◎
If the iframe is allowed to report to resource timing, we don't need to run its fallback steps as the normal reporting would happen.
</p>
	</li>
	<li>
~RET 新たな`~navi~params$
— その
⇒＃
`~ID$nvP ~SET %~navi~ID,
`~navigable$nvP ~SET %~navigable,
`要請$nvP ~SET %要請,
`応答$nvP ~SET %応答,
`~fetch制御器$nvP ~SET %~fetch制御器,
`早期~hintを~commitする$nvP ~SET %早期~hintを~commitする,
`~opener施策$nvP ~SET %応答の~COOP,
`予約-済み環境$nvP ~SET %要請 の`予約-済み~client$rq,
`生成元$nvP ~SET %応答の生成元,
`施策~容器$nvP ~SET %結果~施策~容器,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flag群,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`~navi計時~種別$nvP ~SET %~navi計時~種別,
`~about基底~URL$nvP ~SET %~entry の`文書~状態$shEの`~about基底~URL$dS,
`利用者-関与i$nvP ~SET %利用者-関与i
◎
Return a new navigation params, with
◎
id
• navigationId
navigable
• navigable
request
• request
response
• response
fetch controller
• fetchController
commit early hints
• commitEarlyHints
opener policy
• responseCOOP
reserved environment
• request's reserved client
origin
• responseOrigin
policy container
• resultPolicyContainer
final sandboxing flag set
• finalSandboxFlags
COOP enforcement result
• coopEnforcementResult
navigation timing type
• navTimingType
about base URL
• entry's document state's about base URL
user involvement
• userInvolvement
</li>
</ol>
</div>

<p>
要素は、
その`~node文書$【！`文書$】 %文書 が ~OR↓ を満たすならば
`閲覧~文脈~視野~生成元@
を有するとされる：
◎
An element has a browsing context scope origin＼
</p>
<ul>
	<li>
%文書 の`~node~navigable$は`~top-level辿可能$である
◎
if its Document's node navigable is a top-level traversable or＼
</li>
	<li>
%文書 の`先祖~navigable群$を成す どの %~navigable も次を満たす
⇒
%~navigable にて`作動中な文書$navの`生成元$doc
~EQ`生成元$sub
%文書 の`生成元$doc
◎
if all of its Document's ancestor navigables have active documents whose origins are the same origin as the element's node document's origin.＼
</li>
</ul>
<p>
要素が`閲覧~文脈~視野~生成元$を有する場合、
その値は，要素の`~node文書$の`生成元$docになる。
◎
If an element has a browsing context scope origin, then its value is the origin of the element's node document.
</p>

<p class="XXX">
この定義は、
壊れている
— 何を表出するよう意図していたか，究明が必要である。
`課題 #4703＠~HTMLissue/4703$ を見よ。
◎
This definition is broken and needs investigation to see what it was intended to express: see issue #4703.
</p>

<div class="algo">
<p>
`文書を読込む@
~algoは、
所与の
⇒＃
`~navi~params$ %~navi~params,
`~source~snapshot~params$ %~source~snapshot~params,
`生成元$ %起動元~生成元
◎終
に対し，［
`文書$／~NULL
］を返す：
◎
To load a document given navigation params navigationParams, source snapshot params sourceSnapshotParams, and origin initiatorOrigin, perform the following steps. They return a Document or null.
</p>
<ol>
	<li>
%~MIME型 ~LET %~navi~params の`応答$nvPから`算出される~MIME型$
◎
Let type be the computed type of navigationParams's response.
</li>
	<li>
~IF［
~UAは［
%~MIME型 の資源に対しては［
`~navigable$内に内容を具現化する以外の何らかの仕組み
］を利用して処理する
］よう環境設定されている
］
⇒
~GOTO `非~文書^i
◎
If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a navigable, then skip this step.＼
</li>
	<li>
<p>
%~MIME型 に応じて：
◎
Otherwise, if the type is one of the following types:
</p>
		<dl class="switch">
			<dt>
`~HTML~MIME型$
◎
an HTML MIME type
</dt>
			<dd>
~RET `~HTML文書を読込む$( %~navi~params )
◎
Return the result of loading an HTML document, given navigationParams.
</dd>

			<dt>
`明示的に~supportされる~XML~MIME型$以外の`~XML~MIME型$
◎
an XML MIME type that is not an explicitly supported XML MIME type
</dt>
			<dd>
~RET `~XML文書を読込む＠~HTMLlifecycle#read-xml$( %~navi~params, %~MIME型 )
◎
Return the result of loading an XML document given navigationParams and type.
</dd>

			<dt>
`~JS~MIME型$
◎
a JavaScript MIME type
</dt>
			<dt>
`明示的に~supportされる~JSON~MIME型$以外の`~JSON~MIME型$
◎
a JSON MIME type that is not an explicitly supported JSON MIME type
</dt>
			<dt>"`text/css$mt"</dt>
			<dt>"`text/plain$mt"</dt>
			<dt>"`text/vtt$mt"</dt>
			<dd>
~RET `~text文書を読込む$( %~navi~params, %~MIME型 )
◎
Return the result of loading a text document given navigationParams and type.
</dd>
			<dt>"`multipart/x-mixed-replace$mt"</dt>
			<dd>
~RET `multipart/x-mixed-replace 文書を読込む$( ↓ )
⇒＃
%~navi~params,
%~source~snapshot~params,
%起動元~生成元
◎
Return the result of loading a multipart/x-mixed-replace document, given navigationParams, sourceSnapshotParams, and initiatorOrigin.
</dd>
			<dt>
~UAが~supportする［
画像／ 動画 ／ 音声
］型
◎
a supported image, video, or audio type
</dt>
			<dd>
~RET `~media文書を読込む$( %~navi~params, %~MIME型 )
◎
Return the result of loading a media document given navigationParams and type.
</dd>
			<dt>`application/pdf^l</dt>
			<dt>`text/pdf^l</dt>
			<dd>
~IF［
~UAの`~PDF~viewerは~supportされるか$ ~EQ ~T
］
⇒
~RET `~DOMを有さない文書~用に~inline内容を作成する$( ↓ )
⇒＃
%~navi~params の`~navigable$nvP,
%~navi~params の`~ID$nvP,
%~navi~params の`~navi計時~種別$nvP,
%~navi~params の`利用者-関与i$nvP
◎
If the user agent's PDF viewer supported is true, return the result of creating a document for inline content that doesn't have a DOM given navigationParams's navigable, navigationParams's id, navigationParams's navigation timing type, and navigationParams's user involvement.
</dd>
			<dt>
その他
◎
Otherwise,＼
</dt>
			<dd>
~GOTO `非~文書^i
◎
proceed onward.
</dd>
		</dl>

<p>
次のいずれかに該当する`~XML~MIME型$は、
`明示的に~supportされる~XML~MIME型@
とされる
⇒＃
~UAが内容を具現化するときに，外部~appを利用するように環境設定されているもの／
~UAが専用な処理~規則を有しているもの
◎
An explicitly supported XML MIME type is an XML MIME type＼
for which the user agent is configured to use an external application to render the content, or＼
for which the user agent has dedicated processing rules.＼
</p>

<p class="example">
例えば，組込みの Atom ~feed~viewerを備える~web~browserは、
~MIME型 `application/atom+xml$mt を明示的に~supportするとされる。
◎
For example, a web browser with a built-in Atom feed viewer would be said to explicitly support the application/atom+xml MIME type.
</p>

<p>
次のいずれかに該当する`~JSON~MIME型$は、
`明示的に~supportされる~JSON~MIME型@
とされる
⇒＃
~UAが内容を具現化するときに外部~appを利用するように環境設定されているもの／
~UAが専用な処理~規則を有しているもの
◎
An explicitly supported JSON MIME type is a JSON MIME type for which the user agent is configured to use an external application to render the content, or for which the user agent has dedicated processing rules.
</p>

<p class="note">注記：
どちらの事例でも，［
外部~app／~UA
］は、［
%~navi~params の`~navigable$nvP内で直に`内容を~inlineに表示する＠~HTMLlifecycle#read-ua-inline$
］か［
`外部~softwareに手渡す$
］ことになる。
このどちらも，下に与える手続きにて起こる。
◎
In both cases, the external application or user agent will either display the content inline directly in navigationParams's navigable, or hand it off to external software. Both happen in the steps below.
</p>
	</li>
	<li>
<p id="navigate-non-Document">
`非~文書^i：
◎
↓</p>
		<ol>
			<li>
<p>
~IF［
~UAは、
%~MIME型 の新たな資源を［
何らかの類の~inline内容を表示する
］ことにより取扱う
］
⇒
~RET `~DOMを有さない文書~用に~inline内容を作成する$( ↓ )
⇒＃
%~navi~params の`~navigable$nvP,
%~navi~params の`~ID$nvP,
%~navi~params の`~navi計時~種別$nvP
%~navi~params の`利用者-関与i$nvP
</p>

<p class="example">
例えば、
次のいずれかに該当するとき
⇒＃
当の資源の内容を~nativeに具現化する／
指定された %~MIME型 を~supportしないので，~error~messageを示す
</p>
◎
If, given type, the new resource is to be handled by displaying some sort of inline content,＼
e.g., a native rendering of the content or an error message because the specified type is not supported,＼
then return the result of creating a document for inline content that doesn't have a DOM given navigationParams's navigable, navigationParams's id, navigationParams's navigation timing type, and navigationParams's user involvement.
</li>
			<li>
<p>
`外部~softwareに手渡す$( ↓ )
⇒＃
%~navi~params の`応答$nvP,
%~navi~params の`~navigable$nvP,
%~navi~params の`最終-~sandbox~flag集合$nvP,
%~source~snapshot~params の`一過な作動化を有するか$ssP,
%起動元~生成元
</p>

<p>
（この場合、
文書の %~MIME型 は %~navi~params の`~navigable$nvPには影響しない）
</p>

<p class="example">
例えば、
次のいずれかに該当するとき
⇒＃
当の資源を外部~appに手渡す／
当の資源の型は未知なので，`応答を~downloadとして取扱う$
</p>
◎
Otherwise, the document's type is such that the resource will not affect navigationParams's navigable,＼
e.g., because the resource is to be handed to an external application or because it is an unknown type that will be processed by handle as a download.＼
Hand-off to external software given navigationParams's response, navigationParams's navigable, navigationParams's final sandboxing flag set, sourceSnapshotParams's has transient activation, and initiatorOrigin.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="applying-the-history-step">
<h4 title="Applying the history step">7.4.6 履歴~stepの適用-法</h4>

<p>
~naviも辿りも，
~session履歴~内の どこへ向かうよう求まれるか案を得たなら、
その作業を成すかなりの部分は，［
その観念を`辿可能な~navigable$と関連な`文書$に適用すること
］に費やされる。
この作業は、［
~naviにおいては，一般に処理nの終了~間際で／
辿りにおいては，処理nの始めに
］生じる。
◎
For both navigation and traversal, once we have an idea of where we want to head to in the session history, much of the work comes about in applying that notion to the traversable navigable and the relevant Document. For navigations, this work generally occurs toward the end of the process; for traversals, it is the beginning.
</p>

				<section id="updating-the-traversable">
<h5 title="Updating the traversable">7.4.6.1 辿可能の更新-法</h5>

<p>
`辿可能な~navigable$が的確な~session履歴~stepで終えることを確保することは、
特に複階的である
— それは、
次を孕み得るので：
◎
Ensuring a traversable ends up at the right session history step is particularly complex, as it can involve＼
</p>
<ul>
	<li>
辿可能の`~navigable$な子孫たちにまたがって協調すること
◎
coordinating across multiple navigable descendants of the traversable,＼
</li>
	<li>
それらを並列的に`拡充-＠#populating-a-session-history-entry$すること
◎
populating them in parallel,＼
</li>
	<li>
結果の~viewが どれも同じになることを確保するよう，~back-upを同期すること
◎
and then synchronizing back up to ensure everyone has the same view of the result.＼
</li>
</ul>

<p>
これは、
次により更に複雑になる：
◎
This is further complicated by＼
</p>
<ul>
	<li>
非同一-文書~naviと一緒に混ざっている，同期的な同一-文書~naviの存在
◎
the existence of synchronous same-document navigations being mixed together with cross-document navigations,＼
</li>
	<li>
~web~pageが，ある種の相対的な時機について どのような期待を得られるようになるか
◎
and how web pages have come to have certain relative timing expectations.
</li>
</ul>

<p>
`~navigableを変更している継続の状態@
は、
`履歴~stepを適用する$間に情報を格納するために利用される
— その~algoを成す［
ある部分を継続すること
］を［
他の部分が完遂した後に限り，許容する
］よう。
それは、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A changing navigable continuation state is used to store information during the apply the history step algorithm, allowing parts of the algorithm to continue only after other parts have finished. It is a struct with:
</p>
<ul>
	<li>
`表示される文書@cnC
⇒
`文書$
◎
displayed document
• A Document
</li>
	<li>
`~target~entry@cnC
⇒
`~session履歴~entry$
◎
target entry
• A session history entry
</li>
	<li>
`~navigable@cnC
⇒
`~navigable$
◎
navigable
• A navigable
</li>
	<li>
`更新のみか@cnC
⇒
真偽値
◎
update only
• A boolean
</li>
</ul>

<hr>

<p>
`辿可能な~navigable$に対する更新は，同じ~algo
— `履歴~stepを適用する$ —
に~~至るが、
アリな各~入口は，少しばかりの~custom化を伴う：
◎
Although all updates to the traversable navigable end up in the same apply the history step algorithm, each possible entry point comes along with some minor customizations:
</p>

<div class="algo">
<p>
`~navigableの作成／破壊~用に更新する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能 )
に対し：
◎
To update for navigable creation/destruction given a traversable navigable traversable:
</p>
<ol>
	<li>
%~step ~LET %辿可能 の`現在の~session履歴~step$nav
◎
Let step be traversable's current session history step.
</li>
	<li>
~RET `履歴~stepを適用する$( ↓ )
⇒＃
%~step,
%辿可能,
~F,
~NULL,
~NULL,
`なし$i,
~NULL
◎
Return the result of applying the history step step to traversable given false, null, null, "none", and null.
</li>
</ol>
</div>

<div class="algo">
<p>
`~push／置換-用に履歴~stepを適用する@
~algoは、
所与の
⇒＃
`辿可能な~navigable$ %辿可能,
負でない整数 %~step,
`履歴~取扱いの挙動$ %履歴~取扱い,
`~naviに対する利用者-関与i$ %利用者-関与i
◎終
に対し：
◎
To apply the push/replace history step given a non-negative integer step to a traversable navigable traversable, given a history handling behavior historyHandling and a user navigation involvement userInvolvement:
</p>
<ol>
	<li>
~RET `履歴~stepを適用する$( ↓ )
⇒＃
%~step,
%辿可能,
~F,
~NULL,
~NULL,
%利用者-関与i,
%履歴~取扱い
◎
Return the result of applying the history step step to traversable given false, null, null, userInvolvement, and historyHandling.
</li>
</ol>

<p class="note">注記：
`~push／置換-用に履歴~stepを適用する$中で`履歴~stepを適用する$ときに［
`~source~snapshot~params$／起動元`~navigable$
］を渡さないのは、
それらの検査が`~navi~algo$内で済まされるからである。
◎
Apply the push/replace history step never passes source snapshot params or an initiator navigable to apply the history step. This is because those checks are done earlier in the navigation algorithm.
</p>
</div>

<div class="algo">
<p>
`再読込み用に履歴~stepを適用する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, `~naviに対する利用者-関与i$ %利用者-関与i )
に対し：
◎
To apply the reload history step to a traversable navigable traversable given user navigation involvement userInvolvement:
</p>
<ol>
	<li>
%~step ~LET %辿可能 の`現在の~session履歴~step$nav
◎
Let step be traversable's current session history step.
</li>
	<li>
~RET `履歴~stepを適用する$( ↓ )
⇒＃
%~step,
%辿可能,
~T,
~NULL,
~NULL,
%利用者-関与i,
`reload$l
◎
Return the result of applying the history step step to traversable given true, null, null, userInvolvement, and "reload".
</li>
</ol>
</div>

<p class="note">注記：
`再読込み用に履歴~stepを適用する$中で`履歴~stepを適用する$ときに［
`~source~snapshot~params$／起動元`~navigable$
］を渡さないのは、
再読込みすることは，常に
— `parent.location.reload()^c の様な事例でも —
%~navigable 自身が行ったかのように扱われるからである。
◎
Apply the reload history step never passes source snapshot params or an initiator navigable to apply the history step. This is because reloading is always treated as if it were done by the navigable itself, even in cases like parent.location.reload().
</p>

<div class="algo">
<p>
`辿-用に履歴~stepを適用する@
~algoは、
所与の
⇒＃
負でない整数 %~step,
`辿可能な~navigable$ %辿可能,
`~source~snapshot~params$ %~source~snapshot~params,
`~navigable$ %検査する起動元,
`~naviに対する利用者-関与i$ %利用者-関与i
◎終
に対し：
◎
To apply the traverse history step given a non-negative integer step to a traversable navigable traversable, with source snapshot params sourceSnapshotParams, navigable initiatorToCheck, and user navigation involvement userInvolvement:
</p>
<ol>
	<li>
~RET `履歴~stepを適用する$( ↓ )
⇒＃
%~step,
%辿可能,
~T,
%~source~snapshot~params,
%検査する起動元,
%利用者-関与i,
`traverse$l
◎
Return the result of applying the history step step to traversable given true, sourceSnapshotParams, initiatorToCheck, userInvolvement, and "traverse".
</li>
</ol>
</div>

<div class="algo">
<p>
`辿-用に履歴~stepを適用することを再開する@
~algoは、
所与の
⇒＃
負でない整数 %~step,
`辿可能な~navigable$ %辿可能,
`~naviに対する利用者-関与i$ %利用者-関与i
◎終
に対し
⇒
`履歴~stepを適用する$( ↓ )
⇒＃
%~step,
%辿可能,
~F,
~NULL,
~NULL,
%利用者-関与i,
`traverse$l
◎
To resume applying the traverse history step given a non-negative integer step, a traversable navigable traversable, and user navigation involvement userInvolvement, apply step to traversable given false, null, null, userInvolvement, and "traverse".
</p>

<p class="note">注記：
辿-を再開するときには，［
取消n,
起動元,
~source~snapshot
］に対する検査は済んでおり, 同一-文書な辿りであることも決定-済みなので、
各~引数には，~F や ~NULL を渡せる。
◎
When resuming a traverse, we are already past the cancelation, initiator, and source snapshot checks, and this traversal has already been determined to be a same-document traversal. Hence, we can pass false and null for those arguments.
</p>
</div>

<hr>

<p>
当の~algoは、
ここから。
◎
Now for the algorithm itself.
</p>

<div class="algo">
<p>
`履歴~stepを適用する@
~algoは、
所与の
⇒＃
負でない整数 %~step,
`辿可能な~navigable$ %辿可能,
真偽値 %取消nを検査するか,
［ `~source~snapshot~params$／ ~NULL ］ %~source~snapshot~params,
［ `~navigable$／ ~NULL ］ %検査する起動元,
`~naviに対する利用者-関与i$ %利用者-関与i,
［ `NavigationType$I ／ ~NULL ］%~navi種別
◎終
に対し，次に挙げるいずれか
⇒＃
`起動元は許容されない^i ／
`~beforeunload_evにより取消された^i ／
`~navigate_evにより取消された^i ／
`適用された^i
◎終
を返す：
◎
To apply the history step given a non-negative integer step to a traversable navigable traversable, with boolean checkForCancelation, source snapshot params-or-null sourceSnapshotParams, navigable-or-null initiatorToCheck, user navigation involvement userInvolvement, and NavigationType-or-null navigationType, perform the following steps. They return "initiator-disallowed", "canceled-by-beforeunload", "canceled-by-navigate", or "applied".
</p>
<ol>
	<li>
~Assert：
これは、
%辿可能 の`~session履歴~辿り~queue$navの中で走っている。
◎
Assert: This is running within traversable's session history traversal queue.
</li>
	<li>
%~target~step ~LET `利用された~stepを取得する$( %辿可能, %~step )
◎
Let targetStep be the result of getting the used step given traversable and step.
</li>
	<li>
<p>
~IF［
%検査する起動元 ~NEQ ~NULL
］：
◎
If initiatorToCheck is not null, then:
</p>
		<ol>
			<li>
~Assert：
%~source~snapshot~params ~NEQ ~NULL
◎
Assert: sourceSnapshotParams is not null.
</li>
			<li>
%~navigable群 ~LET `現在の~session履歴~entryが変更されるか読込直される~navigableをすべて取得する$()
◎
↓</li>
			<li>
%~navigable群 を成す
~EACH( %~navigable )
に対し
⇒
~IF［
%検査する起動元 が %~source~snapshot~params の下で %~navigable を`~navigateすることは~sandbox法により許容され$ない
］
⇒
~RET `起動元は許容されない^i
◎
For each navigable of get all navigables whose current session history entry will change or reload: if initiatorToCheck is not allowed by sandboxing to navigate navigable given sourceSnapshotParams, then return "initiator-disallowed".
</li>
		</ol>
	</li>
	<li>
%非同一-文書を経ている~navigable群 ~LET 
`非同一-文書の辿りを経るかもしれない~navigableをすべて取得する$( %辿可能, %~target~step )
◎
Let navigablesCrossingDocuments be the result of getting all navigables that might experience a cross-document traversal given traversable and targetStep.
</li>
	<li>
<p>
~IF［
%取消nを検査するか ~EQ ~T
］：
</p>
		<ol>
			<li>
%検査~結果 ~LET `~unloadは取消されたか否か検査する$( ↓ )
⇒＃
%非同一-文書を経ている~navigable群,
%辿可能,
%~target~step,
%利用者-関与i
</li>
			<li>
~IF［
%検査~結果 ~NEQ `継続する^i
］
⇒
~RET %検査~結果
</li>
		</ol>
◎
If checkForCancelation is true, and the result of checking if unloading is canceled given navigablesCrossingDocuments, traversable, targetStep, and userInvolvement is not "continue", then return that result.
</li>
	<li>
%変更されている~navigable群 ~LET `現在の~session履歴~entryが変更されるか読込直される~navigableをすべて取得する$( %辿可能, %~target~step )
◎
Let changingNavigables be the result of get all navigables whose current session history entry will change or reload given traversable and targetStep.
</li>
	<li>
%変更されていないが更新は必要な~navigable群 ~LET 
`履歴~objの長さか~indexの更新に限り必要になる~navigableをすべて取得する$( %辿可能, %~target~step )
◎
Let nonchangingNavigablesThatStillNeedUpdates be the result of getting all navigables that only need history object length/index update given traversable and targetStep.
</li>
	<li>
<p>
%変更されている~navigable群 を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of changingNavigables:
<p>
		<ol>
			<li>
%~navigable の`現在の~session履歴~entry$nav ~SET `~target履歴~entryを取得する$( %~navigable, %~target~step ),
◎
Let targetEntry be the result of getting the target history entry given navigable and targetStep.
◎
Set navigable's current session history entry to targetEntry.
</li>
			<li>
`進行中な~naviを設定する$( %~navigable, `traversal^l )
◎
Set the ongoing navigation for navigable to "traversal".
</li>
		</ol>
	</li>
	<li>
%変更~jobの総数 ~LET %変更されている~navigable群 の`~size$
◎
Let totalChangeJobs be the size of changingNavigables.
</li>
	<li>
%完了した変更~job数 ~LET 0
◎
Let completedChangeJobs be 0.
</li>
	<li>
<p>
%~navigableを変更している継続~群 ~LET 新たな`~queue$
（`~navigableを変更している継続の状態$たち）
◎
Let changingNavigableContinuations be an empty queue of changing navigable continuation states.
</p>

<p class="note">注記：
この~queueは、
%変更されている~navigable群 に対する演算を 2 つの部分に分割するために利用される。
特定的には、
%~navigableを変更している継続~群 は，
`第二の部分＠#continuations-dequeue$用の~dataを保持する。
◎
This queue is used to split the operations on changingNavigables into two parts. Specifically, changingNavigableContinuations holds data for the second part.
</p>
	</li>
	<li>
<p>
%変更されている~navigable群 を成す
~EACH( %~navigable )
に対し
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 次の手続き )
◎
For each navigable of changingNavigables, queue a global task on the navigation and traversal task source of navigable's active window to run the steps:
</p>

<p class="note">注記：
【この手続きの以降を成す】一連の段は、［
文書を~unloadする前に同期的な~naviを処理する
］ことを許容するよう， 2 つの部分に分割される。
状態は、
`第二の部分＠#continuations-dequeue$用に
%~navigableを変更している継続~群 内に格納される。
◎
This set of steps are split into two parts to allow synchronous navigations to be processed before documents unload. State is stored in changingNavigableContinuations for the second part.
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%表示される~entry ~LET %~navigable にて`作動中な~entry$nav
◎
Let displayedEntry be navigable's active session history entry.
</li>
			<li>
%~target~entry ~LET %~navigable の`現在の~session履歴~entry$nav
◎
Let targetEntry be navigable's current session history entry.
</li>
			<li>
%~navigableを変更している継続 ~LET `~navigableを変更している継続の状態$
— その
⇒＃
`表示される文書$cnC ~SET %表示される~entry の`文書$shE,
`~target~entry$cnC ~SET %~target~entry,
`~navigable$cnC ~SET %~navigable,
`更新のみか$cnC ~SET ~F
◎
Let changingNavigableContinuation be a changing navigable continuation state with:
◎
displayed document
• displayedEntry's document
target entry
• targetEntry
navigable
• navigable
update-only
• false
</li>
			<li>
<p>
~IF［
%表示される~entry ~EQ %~target~entry
］~AND［
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~F
］：
◎
If displayedEntry is targetEntry and targetEntry's document state's reload pending is false, then:
</p>
				<ol>
					<li>
%~navigableを変更している継続 の`更新のみか$cnC ~SET ~T
◎
Set changingNavigableContinuation's update-only to true.
</li>
					<li>
%~navigableを変更している継続~群 に %~navigableを変更している継続 を`~enqueueする$
◎
Enqueue changingNavigableContinuation on changingNavigableContinuations.
</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>

<p class="note">注記：
この事例は、
当の`作動中な~entry$navをすでに更新した`同期的な~navi＠#finalize-a-cross-document-navigation$に因り生じる。
◎
This case occurs due to a synchronous navigation which already updated the active session history entry.
</p>
			</li>
			<li>
<p>
~Assert：
%~navi種別 に応じて，次が満たされる：
◎
Switch on navigationType:
</p>
				<ul class="switch">
					<li>
`reload$l
⇒
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~T
◎
"reload"
• Assert: targetEntry's document state's reload pending is true.
</li>
					<li>
`traverse$l
⇒
%~target~entry の`文書~状態$shEの`一度でも拡充されたか$dS ~EQ ~T
◎
"traverse"
• Assert: targetEntry's document state's ever populated is true.
</li>
					<li>
`replace$l
⇒
［
%~target~entry の`~step$shE ~EQ %表示される~entry の`~step$shE
］~AND［
%~target~entry の`文書~状態$shEの`一度でも拡充されたか$dS ~EQ ~F
］
◎
"replace"
• Assert: targetEntry's step is displayedEntry's step and targetEntry's document state's ever populated is false.
</li>
					<li>
`push$l
⇒
［
%~target~entry の`~step$shE ~EQ %表示される~entry の`~step$shE ~PLUS 1
］~AND［
%~target~entry の`文書~状態$shEの`一度でも拡充されたか$dS ~EQ ~F
］
◎
"push"
• Assert: targetEntry's step is displayedEntry's step + 1 and targetEntry's document state's ever populated is false.
</li>
				</ul>
			</li>
			<li>
%旧-生成元 ~LET %~target~entry の`文書~状態$shEの`生成元$dS
◎
Let oldOrigin be targetEntry's document state's origin.
</li>
			<li id="descendant-navigable-traversal-navigate-events">
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
				<ul>
					<li>
%~navigable ~NEQ %辿可能
◎
navigable is not traversable;
</li>
					<li>
%~target~entry ~NEQ %~navigable の`現在の~session履歴~entry$nav
◎
targetEntry is not navigable's current session history entry; and
</li>
					<li>
%旧-生成元
~EQ`生成元$sub
%~navigable の`現在の~session履歴~entry$navの`文書~状態$shEの`生成元$dS
◎
oldOrigin is the same as navigable's current session history entry's document state's origin,
</li>
				</ul>
<p>
…ならば：
◎
then:
</p>
				<ol>
					<li>
%~navi ~LET %~navigable にて`作動中な~window$navの`~navi~API$
◎
Let navigation be navigable's active window's navigation API.
</li>
					<li>
`辿-用の~navigate_ev~eventを発火する$( %~navi )
— 次も与える下で
⇒＃
`行先~履歴~entry^i ~SET %~target~entry,
`利用者-関与i^i ~SET %利用者-関与i
◎
Fire a traverse navigate event at navigation given targetEntry and userInvolvement.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~target~entry の`文書$shE ~EQ ~NULL
］~OR［
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~T
］：
◎
If targetEntry's document is null, or targetEntry's document state's reload pending is true, then:
</p>
				<ol>
					<li>
%~navi計時~種別 ~LET %~target~entry の`文書$shEに応じて
⇒＃
~NULL ならば `back_forward＠~NAV-TIMING#dom-navigationtimingtype-back_forward$l ／
~ELSE_ `reload＠~NAV-TIMING#dom-navigationtimingtype-reload$l
◎
Let navTimingType be "back_forward" if targetEntry's document is null; otherwise "reload".
</li>
					<li>
%~target~snapshot~params ~LET `~target~snapshot~paramsを~snapshotする$( %~navigable )
◎
Let targetSnapshotParams be the result of snapshotting target snapshot params given navigable.
</li>
					<li>
%~targetに特有な~source~snapshot~params ~LET %~source~snapshot~params
◎
Let potentiallyTargetSpecificSourceSnapshotParams be sourceSnapshotParams.
</li>
					<li>
<p>
~IF［
%~targetに特有な~source~snapshot~params ~EQ ~NULL
］
⇒
%~targetに特有な~source~snapshot~params ~SET
`~source~snapshot~paramsを~snapshotする$( %~navigable にて`作動中な文書$nav )
◎
If potentiallyTargetSpecificSourceSnapshotParams is null, then set it to the result of snapshotting source snapshot params given navigable's active document.
</p>

<p class="note">注記：
この事例では、［
辿り／再読込み
］の明瞭な~sourceは無い。
この状況では，
%~navigable が自身を~navigateしたかのように扱われるが、
%~target~entry の元の起動元を成す一部の~prop
— `起動元~生成元$dS, `要請~referrer$dS, など —
は，
%~target~entry の`文書~状態$shE内に保全されることに注意
— それらは、
当の~naviに適切に波及することになる。
◎
In this case there is no clear source of the traversal/reload. We treat this situation as if navigable navigated itself, but note that some properties of targetEntry's original initiator are preserved in targetEntry's document state, such as the initiator origin and referrer, which will appropriately influence the navigation.
</p>
					</li>
					<li>
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~SET ~F
◎
Set targetEntry's document state's reload pending to false.
</li>
					<li>
%~POSTを許容するか ~LET %~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS
◎
Let allowPOST be targetEntry's document state's reload pending.
</li>
					<li class="algo">
<p>
この段は、
`並列的$に走らす：
◎
In parallel,＼
</p>
						<ol>
							<li>
<p>
`履歴~entryの文書を拡充するよう試みる$( ↓ )
⇒＃
%~target~entry,
%~navigable,
【%~navi計時~種別,】
%~targetに特有な~source~snapshot~params,
%~target~snapshot~params
%利用者-関与i,
◎終
次も与える下で
⇒＃
`~POSTを許容するか^i ~SET %~POSTを許容するか,
`完了~手続き^i ~SET 次の手続き：
◎
attempt to populate the history entry's document for targetEntry, given navigable, potentiallyTargetSpecificSourceSnapshotParams, targetSnapshotParams, userInvolvement, with allowPOST set to allowPOST and completionSteps set to＼
</p>

<p class="algo">
手続きは
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 下に定義する `文書を拡充した後の手続き^i )
◎
queue a global task on the navigation and traversal task source given navigable's active window to run afterDocumentPopulated.
</p>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
`即時$に
⇒
下に定義する `文書を拡充した後の手続き^i()
◎
Otherwise, run afterDocumentPopulated immediately.
</p>

<div class="algo">
<p>
`文書を拡充した後の手続き^i は：
◎
In both cases, let afterDocumentPopulated be the following steps:
</p>
				<ol>
					<li>
<p>
~IF［
%~target~entry の`文書$shE ~EQ ~NULL
］
⇒
%~navigableを変更している継続 の`更新のみか$cnC ~SET ~T
◎
If targetEntry's document is null, then set changingNavigableContinuation's update-only to true.
</p>

<p class="note">注記：
これは、
当の文書を拡充しようと試行したが，できなかったことを意味する
— 例：~serverが `204$hst を返したため。
◎
This means we tried to populate the document, but were unable to do so, e.g. because of the server returning a 204.
</p>

<div class="note">
<p>注記：
これらの失敗した［
~navi／辿り
］は、
`~navi~API＠#navigation-api$へは通達されない
（例：［
`~navi~API~method追跡子$の~promise／ `navigateerror$et ~event
］を通して）。
そうすると、［
非同一-生成元の事例では、［
他の生成元からの応答の時機についての情報
］を漏洩する
］ことに加え，［
非同一-生成元と同一-生成元の事例で異なる結果を供することは、
紛らわし過ぎる
］と判断されたので。
◎
These kinds of failed navigations or traversals will not be signaled to the navigation API (e.g., through the promises of any navigation API method tracker, or the navigateerror event). Doing so would leak information about the timing of responses from other origins, in the cross-origin case, and providing different results in the cross-origin vs. same-origin cases was deemed too confusing.
</p>

<p>
しかしながら，実装は、
この機会を利用して［
`navigation.transition.finished＠~HTMLnavAPI#dom-navigationtransition-finished$c が返す~promise用の~handlerがある場合に，それを~clearする
］こともできる
— それらは、
この時点で，決して走らなくなることが保証されるので。
加えて，実装は、
~navi~APIを成す一部が これらの~naviを起動した場合には
— なぜ［
~promiseは決着しない／~eventは発火されない
］のかが，~web開発者にとって明瞭になるよう —
`~consoleに警告を報告する$よう望むこともあろう。
◎
However, implementations could use this opportunity to clear any promise handlers for the navigation.transition.finished promise, as they are guaranteed at this point to never run. And, they might wish to report a warning to the console if any part of the navigation API initiated these navigations, to make it clear to the web developer why their promises will never settle and events will never fire.
</p>
</div>
					</li>
					<li>
<p>
~IF［
%~target~entry の`文書$shEの`生成元$doc
`is not^en【~NEQ`生成元$sub？】
%旧-生成元
］
⇒
%~target~entry の`古典~履歴~API用の状態$shE ~SET `StructuredSerializeForStorage$jA( ~NULL )
◎
If targetEntry's document's origin is not oldOrigin, then set targetEntry's classic history API state to StructuredSerializeForStorage(null).
</p>

<p class="note">注記：
これは、
`vs^en 【？】［
以前における~redirectを伴わない %~target~entry の読込n
］【から？】生成元が変化したとき，履歴~状態を~clearする。
これは、
~CSP用の~sandbox~headerにおける変化に因り，起こり得る。
◎
This clears history state when the origin changed vs a previous load of targetEntry without a redirect occuring. This can happen due to a change in CSP sandbox headers.
</p>
					</li>
					<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true:
</p>
						<ul>
							<li>
%~navigable の`親$nav ~EQ ~NULL
◎
navigable's parent is null;
</li>
							<li>
%~target~entry の`文書$shEが`属する閲覧~文脈$は次を満たさない
⇒
［
`補助~閲覧~文脈$である
］~AND［
それを`開いた閲覧~文脈$bc ~NEQ ~NULL
］
◎
targetEntry's document's browsing context is not an auxiliary browsing context whose opener browsing context is non-null; and
</li>
							<li>
%~target~entry の`文書$shEの`生成元$doc
`is not^en【~NEQ`生成元$sub？】
%旧-生成元
◎
targetEntry's document's origin is not oldOrigin,
</li>
						</ul>
<p>
…ならば
⇒
%~target~entry の`文書~状態$shEの`~navigable名$dS ~SET 空~文字列
◎
then set targetEntry's document state's navigable target name to the empty string.
</p>
					</li>
					<li>
<p>
%~navigableを変更している継続~群 に %~navigableを変更している継続 を`~enqueueする$
◎
Enqueue changingNavigableContinuation on changingNavigableContinuations.
</p>

<p class="note">注記：
この~jobの残りは、
この~algo内の`後で走る＠#continuations-dequeue$。
◎
The rest of this job runs later in this algorithm.
</p>
					</li>
				</ol>
</div>
			</li>
		</ol>
</div>
	</li>
	<li>
%同期c~naviを取扱う前に待機しなければならない~navigable群 ~LET 空な`有順序~集合$
◎
Let navigablesThatMustWaitBeforeHandlingSyncNavigation be an empty set.
</li>
	<li>
<p>
~WHILE［
%完了した変更~job数 ~NEQ %変更~jobの総数
］：
◎
While completedChangeJobs does not equal totalChangeJobs:
</p>
		<ol>
			<li>
<p>
~IF［
%辿可能 の`入子な履歴~stepの適用-を走らせているか$nav ~EQ ~F
］：
◎
If traversable's running nested apply history step is false, then:
</p>
				<ol>
					<li>
%~algo集合 ~LET %辿可能 の`~session履歴~辿り~queue$navの`~algo集合$shTP
◎
↓</li>
					<li id="sync-navigations-jump-queue">
<p>
~WHILE 無条件：
◎
While＼
↓ traversable's session history traversal queue's algorithm set contains one or more synchronous navigation steps with a target navigable not contained in navigablesThatMustWaitBeforeHandlingSyncNavigation:
</p>
						<ol>
							<li>
%手続き ~LET %~algo集合 内に次を満たす`~item$は［
在るならば それらのうち最初のもの／
無いならば ε
］
⇒
［
`同期的な~navi手続き$shTPである
］~AND［
それが孕んでいる`~target~navigable$shTP ~NIN %同期c~naviを取扱う前に待機しなければならない~navigable群
］
◎
Let steps be the first item in traversable's session history traversal queue's algorithm set that is synchronous navigation steps with a target navigable not contained in navigablesThatMustWaitBeforeHandlingSyncNavigation.
</li>
							<li>
~IF［
%手続き ~EQ ε
］
⇒
~BREAK
◎
↑</li>
							<li>
%~algo集合 から %手続き を`除去する$
◎
Remove steps from traversable's session history traversal queue's algorithm set.
</li>
							<li>
%辿可能 の`入子な履歴~stepの適用-を走らせているか$nav ~SET ~T
◎
Set traversable's running nested apply history step to true.
</li>
							<li>
%手続き()
◎
Run steps.
</li>
							<li>
%辿可能 の`入子な履歴~stepの適用-を走らせているか$nav ~SET ~F
◎
Set traversable's running nested apply history step to false.
</li>
						</ol>

<p class="note">注記：
同期的な~naviのうち［
この辿り より前に場を占めるよう意図されたもの
］は，
この地点で当の~queueを~jumpするので、［
この辿りが，そのような~naviの文書を~unloadする
］場合でも，それより前に［
%辿可能 の`~session履歴~entry群$nav内の正しい箇所
］に追加できる。
`詳細は、ここで見出せる＠#sync-navigation-steps-queue-jumping-examples$。
◎
Synchronous navigations that are intended to take place before this traversal jump the queue at this point, so they can be added to the correct place in traversable's session history entries before this traversal potentially unloads their document. More details can be found here.
</p>
					</li>
				</ol>
			</li>
			<li id="continuations-dequeue">
%~navigableを変更している継続 ~LET %~navigableを変更している継続~群 から`~dequeueする$
◎
Let changingNavigableContinuation be the result of dequeuing from changingNavigableContinuations.
</li>
			<li>
~IF［
%~navigableを変更している継続 ~EQ ε
］
⇒
~CONTINUE
◎
If changingNavigableContinuation is nothing, then continue.
</li>
			<li>
%表示される文書 ~LET %~navigableを変更している継続 の`表示される文書$cnC
◎
Let displayedDocument be changingNavigableContinuation's displayed document.
</li>
			<li>
%~target~entry ~LET %~navigableを変更している継続 の`~target~entry$cnC
◎
Let targetEntry be changingNavigableContinuation's target entry.
</li>
			<li>
%~navigable ~LET %~navigableを変更している継続 の`~navigable$cnC
◎
Let navigable be changingNavigableContinuation's navigable.
</li>
			<li>
<p>
( %~script履歴~長さ, %~script履歴~index ) ~LET `履歴~objの長さと~indexを取得する$( %辿可能, %~target~step )
◎
Let (scriptHistoryLength, scriptHistoryIndex) be the result of getting the history object length and index given traversable and targetStep.
</p>

<p class="note">注記：
これらの値は、
最後に計算されたときから変化したかもしれない。
◎
These values might have changed since they were last calculated.
</p>
			</li>
			<li>
<p>
%同期c~naviを取扱う前に待機しなければならない~navigable群 に %~navigable を`付加する$
◎
Append navigable to navigablesThatMustWaitBeforeHandlingSyncNavigation.
</p>

<p class="note">注記：
ある~navigableが，辿りにおいて この地点に達したなら、
追加的に~queueされた同期的な~navi手続きは，
この辿り より［
前ではなく，後
］に生じるよう意図された見込みが高いので、
もはや~queueを~jumpしない。
詳細は、
`ここに見出せる＠#sync-navigation-steps-queue-jumping-examples$。
◎
Once a navigable has reached this point in traversal, additionally queued synchronous navigation steps are likely to be intended to occur after this traversal rather than before it, so they no longer jump the queue. More details can be found here.
</p>
			</li>
			<li>
%~navi~API用の~entry群 ~LET `~navi~API用に~session履歴~entry群を取得する$( %~navigable, %~target~step )
◎
Let entriesForNavigationAPI be the result of getting session history entries for the navigation API given navigable and targetStep.
</li>
			<li>
<p>
~IF［
%~navigableを変更している継続 の`更新のみか$cnC ~EQ ~T
］~OR［
%~target~entry の`文書$shE ~EQ %表示される文書
］：
◎
If changingNavigableContinuation's update-only is true, or targetEntry's document is displayedDocument, then:
</p>

<p class="note">注記：
この場合、
同一-文書な~naviである
— ~unloadすることなく続行する。
◎
This is a same-document navigation: we proceed without unloading.
</p>
				<ol>
					<li>
<p>
`進行中な~naviを設定する$( %~navigable, ~NULL )
◎
Set the ongoing navigation for navigable to null.
</p>

<p class="note">注記：
これは、［
%~navigable に対し新たな`~navi$を開始する
］ことを許容する
— 一方で，辿りの間は、
それは阻まれる。
◎
This allows new navigations of navigable to start, whereas during the traversal they were blocked.
</p>
					</li>
					<li>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 下に定義する `~unload後の手続き^i )
◎
Queue a global task on the navigation and traversal task source given navigable's active window to perform afterPotentialUnloads.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%~navi種別 ~NEQ ~NULL
◎
Assert: navigationType is not null.
</li>
					<li>
`非同一-文書~navi用に文書を非作動化する$( ↓ )
⇒＃
%表示される文書,
%利用者-関与i,
%~target~entry,
%~navi種別,
下に定義する `~unload後の手続き^i
◎
Deactivate displayedDocument, given userInvolvement, targetEntry, navigationType, and afterPotentialUnloads.
</li>
				</ol>

<div class="algo">
<p>
上で利用される `~unload後の手続き^i は：
◎
In both cases, let afterPotentialUnloads be the following steps:
</p>
				<ol>
					<li>
%直前~entry ~LET %~navigable にて`作動中な~entry$nav
◎
Let previousEntry be navigable's active session history entry.
</li>
					<li>
~IF［
%~navigableを変更している継続 の`更新のみか$cnC ~EQ ~F
］
⇒
`履歴~entryを作動化する$( %~target~entry, %~navigable )
◎
If changingNavigableContinuation's update-only is false, then activate history entry targetEntry for navigable.
</li>
					<li class="algo">
%文書を更新する ~LET 次を遂行する手続き
⇒
`履歴~stepを適用するために文書を更新する$( ↓ )
⇒＃
%~target~entry の`文書$shE,
%~target~entry,
%~navigableを変更している継続 の`更新のみか$cnC,
%~script履歴~長さ,
%~script履歴~index,
%~navi種別,
%~navi~API用の~entry群,
%直前~entry
◎
Let updateDocument be an algorithm step which performs update document for history step application given targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and previousEntry.
</li>
					<li>
~IF［
%~target~entry の`文書$shE ~EQ %表示される文書
］
⇒
%文書を更新する()
◎
If targetEntry's document is equal to displayedDocument, then perform updateDocument.
</li>
					<li>
~ELSE
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~target~entry の`文書$shEに`関連な大域~obj$, %文書を更新する )
◎
Otherwise, queue a global task on the navigation and traversal task source given targetEntry's document's relevant global object to perform updateDocument.
</li>
					<li>
%完了した変更~job数 ~INCBY 1
◎
Increment completedChangeJobs.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
%何も変更していない~jobの総数 ~LET %変更されていないが更新は必要な~navigable群 の`~size$
◎
Let totalNonchangingJobs be the size of nonchangingNavigablesThatStillNeedUpdates.
</p>

<p class="note">注記：
この段の以降では、
それまでの演算~すべてが完了するまで，故意に待機する
— それらは、
`同期的な~naviの処理＠#sync-navigations-jump-queue$を含むので。
この処理は、
履歴の［
長さ, ~index
］を更新する~taskも~queueすることになる。
◎
This step onwards deliberately waits for all the previous operations to complete, as they include processing synchronous navigations which will also post tasks to update history length and index.
</p>
	</li>
	<li>
%何も変更していない~jobのうち完了したものの総数 ~LET 0
◎
Let completedNonchangingJobs be 0.
</li>
	<li>
( %~script履歴~長さ, %~script履歴~index ) ~LET `履歴~objの長さと~indexを取得する$( %辿可能, %~target~step )
◎
Let (scriptHistoryLength, scriptHistoryIndex) be the result of getting the history object length and index given traversable and targetStep.
</li>
	<li>
<p>
%変更されていないが更新は必要な~navigable群 を成す
~EACH( %~navigable )
に対し
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 次の手続き )
◎
For each navigable of nonchangingNavigablesThatStillNeedUpdates, queue a global task on the navigation and traversal task source given navigable's active window＼
</p>
<div class="algo">
<p>
手続きは：
◎
to run the steps:
</p>
		<ol>
			<li>
%文書 ~LET %~navigable にて`作動中な文書$nav
◎
Let document be navigable's active document.
</li>
			<li>
%文書 の`履歴~obj$の`~index$hsT ~SET %~script履歴~index
◎
Set document's history object's index to scriptHistoryIndex.
</li>
			<li>
%文書 の`履歴~obj$の`長さ$hsT ~SET %~script履歴~長さ
◎
Set document's history object's length to scriptHistoryLength.
</li>
			<li>
%何も変更していない~jobのうち完了したものの総数 ~INCBY 1
◎
Increment completedNonchangingJobs.
</li>
		</ol>
</div>
	</li>
	<li>
次が満たされるまで待機する
⇒
%何も変更していない~jobのうち完了したものの総数 ~EQ %何も変更していない~jobの総数
◎
Wait for completedNonchangingJobs to equal totalNonchangingJobs.
</li>
	<li>
%辿可能 の`現在の~session履歴~step$nav ~SET %~target~step
◎
Set traversable's current session history step to targetStep.
</li>
	<li>
~RET `適用された^i
◎
Return "applied".
</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-文書~navi用に文書を非作動化する@
~algoは、
所与の
⇒＃
`文書$ %表示される文書,
`~naviに対する利用者-関与i$ %利用者-関与i【！userNavigationInvolvement】,
`~session履歴~entry$ %~target~entry,
`NavigationType$I %~navi種別,
引数をとらない~algo %~unload後の手続き
◎終
に対し：
◎
To deactivate a document for a cross-document navigation given a Document displayedDocument, a user navigation involvement userNavigationInvolvement, a session history entry targetEntry, a NavigationType navigationType, and afterPotentialUnloads, which is an algorithm that receives no arguments:
</p>
<ol>
	<li>
%~navigable ~LET %表示される文書 の`~node~navigable$
◎
Let navigable be displayedDocument's node navigable.
</li>
	<li>
%~view遷移を誘発し得るか ~LET ~F
◎
Let potentiallyTriggerViewTransition be false.
</li>
	<li>
%~browser~UIによる~naviか ~LET ~IS［
%利用者-関与i【！userNavigationInvolvement】 ~EQ `~browser~UI$i
］
◎
Let isBrowserUINavigation be true if userNavigationInvolvement is "browser UI"; otherwise false.
</li>
	<li>
%~view遷移を誘発し得るか ~SET `~naviは非同一-文書な~view遷移を誘発し得るか？$( ↓ )
⇒＃
%表示される文書,
%~target~entry の`文書$shE,
%~navi種別,
%~browser~UIによる~naviか
◎
Set potentiallyTriggerViewTransition to the result of calling can navigation trigger a cross-document view-transition? given displayedDocument, targetEntry's document, navigationType, and isBrowserUINavigation.
</li>
	<li>
<p>
~IF［
%~view遷移を誘発し得るか ~EQ ~F
］：
◎
If potentiallyTriggerViewTransition is false, then:
</p>
		<ol>
			<li class="algo">
%~unload前に~pageswap_evを発火する手続き ~LET 次を走らす手続き
⇒
`~pageswap_ev~eventを発火する$( ↓ )
⇒＃
%表示される文書,
%~target~entry,
%~navi種別,
~NULL
◎
Let firePageSwapBeforeUnload be the following step:
• Fire the pageswap event given displayedDocument, targetEntry, navigationType, and null.
</li>
			<li>
<p>
`進行中な~naviを設定する$( %~navigable, ~NULL )
◎
Set the ongoing navigation for navigable to null.
</p>

<p class="note">注記：
これは、［
%~navigable に対し新たな`~navi$を開始する
］ことを許容する
— 一方で，辿りの間は、
それは阻まれる。
◎
This allows new navigations of navigable to start, whereas during the traversal they were blocked.
</p>
			</li>
			<li>
`文書とその子孫たちを~unloadする$( ↓ )
⇒＃
%表示される文書,
%~target~entry の`文書$shE,
%~unload後の手続き,
%~unload前に~pageswap_evを発火する手続き
◎
Unload a document and its descendants given displayedDocument, targetEntry's document, afterPotentialUnloads, and firePageSwapBeforeUnload.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %~navigable にて`作動中な~window$nav, 次の手続き )
◎
Otherwise, queue a global task on the navigation and traversal task source given navigable's active window to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the steps:
</p>
		<ol>
			<li class="algo">
<p>
%~view遷移~捕捉-後も~naviと伴に続行する手続き ~LET 次の手続き：
◎
Let proceedWithNavigationAfterViewTransitionCapture be the following step:
</p>
				<ol>
					<li>
<p>
`~session履歴~辿り手続きを付加する$( %~navigable の`辿可能な~navigable$nav, 次の手続き )
◎
Append the following session history traversal steps to navigable's traversable navigable:
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
						<ol>
							<li>
<p>
`進行中な~naviを設定する$( %~navigable, ~NULL )
◎
Set the ongoing navigation for navigable to null.
</p>

<p class="note">注記：
これは、［
%~navigable に対し新たな`~navi$を開始する
］ことを許容する
— 一方で，辿りの間は、
それは阻まれる。
◎
This allows new navigations of navigable to start, whereas during the traversal they were blocked.
</p>
							</li>
							<li>
`文書とその子孫たちを~unloadする$( ↓ )
⇒＃
%表示される文書,
%~target~entry の`文書$shE,
%~unload後の手続き
◎
Unload a document and its descendants given displayedDocument, targetEntry's document, and afterPotentialUnloads.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
%~view遷移 ~LET `非同一-文書な~view遷移を設定しておく$( ↓ )
⇒＃
%表示される文書,
%~target~entry の`文書$shE,
%~navi種別,
%~view遷移~捕捉-後も~naviと伴に続行する手続き
◎
Let viewTransition be the result of setting up a cross-document view-transition given displayedDocument, targetEntry's document, navigationType, and proceedWithNavigationAfterViewTransitionCapture.
</li>
			<li>
`~pageswap_ev~eventを発火する$( ↓ )
⇒＃
%表示される文書,
%~target~entry,
%~navi種別,
%~view遷移
◎
Fire the pageswap event given displayedDocument, targetEntry, navigationType, and viewTransition.
</li>
			<li>
<p>
~IF［
%~view遷移 ~EQ ~NULL
］
⇒
%~view遷移~捕捉-後も~naviと伴に続行する手続き()
◎
If viewTransition is null, then run proceedWithNavigationAfterViewTransitionCapture.
</p>

<p class="note">注記：
~view遷移が開始-済みな事例では、
%~view遷移~捕捉-後も~naviと伴に続行する手続き を~callする責務は、
~view遷移~algoにある。
◎
In the case where a view transition started, the view transitions algorithms are responsible for calling proceedWithNavigationAfterViewTransitionCapture.
</p>
			</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~pageswap_ev~eventを発火する@
~algoは、
所与の
⇒＃
`文書$ %表示される文書,
`~session履歴~entry$ %~target~entry,
`NavigationType$I %~navi種別,
［`ViewTransition$I ／ ~NULL］ %~view遷移
◎終
に対し：
◎
To fire the pageswap event given a Document displayedDocument, a session history entry targetEntry, a NavigationType navigationType, and a ViewTransition-or-null viewTransition:
</p>
<ol>
	<li>
~Assert：
これは、［
%表示される文書 に`関連な~agent$の`~event~loop$aGに対し~queueされた`~task$
］を成す一部として走っている。
◎
Assert: this is running as part of a task queued on displayedDocument's relevant agent's event loop.
</li>
	<li>
%~navi ~LET %表示される文書 に`関連な大域~obj$の`~navi~API$
◎
Let navigation be displayedDocument's relevant global object's navigation API.
</li>
	<li>
%作動化 ~LET ~NULL
◎
Let activation be null.
</li>
	<li>
<p>
~IF［
~AND↓
］：
◎
If all of the following are true:
</p>
		<ul>
			<li>
%~target~entry の`文書$shEの`生成元$doc
~EQ`生成元$sub 
%表示される文書 の`生成元$doc
◎
targetEntry's document's origin is same origin with displayedDocument's origin; and
</li>
			<li>
［
%~target~entry の`文書$shEの`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~F
］~OR［
%~target~entry の`文書$shEの`最近の~entry$ ~NEQ ~NULL
］
◎
targetEntry's document's was created via cross-origin redirects is false, or targetEntry's document's latest entry is not null,
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
<p>
%行先~entry ~LET %~navi種別 に応じて：
◎
Let destinationEntry be determined by switching on navigationType:
</p>
				<ul>
					<li>
`reload$l
⇒
`~naviの現在の~entry$( %~navi )
◎
"reload"
• The current entry of navigation
</li>
					<li>
`traverse$l
⇒
%~navi の`~entry~list$nV 内の次を満たす `NavigationHistoryEntry$I
⇒
その`~session履歴~entry$nhe ~EQ %~target~entry
◎
"traverse"
• The NavigationHistoryEntry in navigation's entry list whose session history entry is targetEntry
</li>
					<li>
`push$l ／ `replace$l
⇒
`新たな~obj$( `NavigationHistoryEntry$I, %表示される文書 に`関連な~realm$ )
— その
⇒＃
`~session履歴~entry$nhe ~SET %~target~entry
◎
"push"
"replace"
• A new NavigationHistoryEntry in displayedDocument's relevant realm with its session history entry set to targetEntry
</li>
				</ul>
			</li>
			<li>
%作動化 ~SET `新たな~obj$( `NavigationActivation$I, %表示される文書 に`関連な~realm$ )
— その
⇒＃
`旧-~entry$nA ~SET `~naviの現在の~entry$( %~navi ),
`新-~entry$nA ~SET %行先~entry,
`~navi種別$nA ~SET %~navi種別
◎
Set activation to a new NavigationActivation created in displayedDocument's relevant realm, with
• old entry
•• the current entry of navigation
• new entry
•• destinationEntry
• navigation type
•• navigationType
</li>
		</ol>

<p class="note">注記：
このことは、［
~naviの間に非同一-生成元な~redirectがあった場合
］には、［
新-文書が`~BF~cache$から復旧されている場合
］を除き，［
旧-文書の `PageSwapEvent$I における `activation$mPSe は ~NULL になる
］ことを意味する。
◎
This means that a cross-origin redirect during a navigation would result in a null activation in the old document's PageSwapEvent, unless the new document is being restored from bfcache.
</p>
	</li>
	<li>
`~eventを発火する$( %表示される文書 に`関連な大域~obj$, `pageswap$et, `PageSwapEvent$I )
— 次のように初期化して
⇒＃
`activation$mPSe ~SET %作動化,
`viewTransition$mPSe ~SET %~view遷移
◎
Fire an event named pageswap at displayedDocument's relevant global object, using PageSwapEvent with its activation set to activation, and its viewTransition set to viewTransition.
</li>
</ol>
</div>

<div class="algo">
<p>
`履歴~entryを作動化する@
~algoは、
所与の
( `~session履歴~entry$ %~entry, `~navigable$ %~navigable )
に対し：
◎
To activate history entry session history entry entry for navigable navigable:
</p>
<ol>
	<li>
`履歴~entryに持続される状態を保存する$( `~navigable$にて`作動中な~entry$nav )
◎
Save persisted state to the navigable's active session history entry.
</li>
	<li>
%新たな文書 ~LET %~entry の`文書$shE
◎
Let newDocument be entry's document.
</li>
	<li>
<p>
~Assert：
%新たな文書 の`初期~about_blankか$doc ~EQ ~F
◎
Assert: newDocument's is initial about:blank is false,＼
</p>

<p>
すなわち、
`初期~about_blank な文書$へ戻るよう辿ることは，決してない
— それは、
他所へ~navigateするときに，常に`置換される＠#navigate-convert-to-replace$ので。
◎
i.e., we never traverse back to the initial about:blank Document because it always gets replaced when we navigate away from it.
</p>
	</li>
	<li>
%~navigable にて`作動中な~entry$nav ~SET %~entry
◎
Set navigable's active session history entry to entry.
</li>
	<li>
`文書を作動中にする$( %新たな文書 )
◎
Make active newDocument.
</li>
</ol>
</div>

<div class="algo">
<p>
`利用された~stepを取得する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, 負でない整数 %~step )
に対し，負でない整数を返す：
◎
To get the used step given a traversable navigable traversable, and a non-negative integer step, perform the following steps. They return a non-negative integer.
</p>
<ol>
	<li>
%~step群 ~LET `利用されたすべての履歴~stepを取得する$( %辿可能 )
◎
Let steps be the result of getting all used history steps within traversable.
</li>
	<li>
<p>
~RET %~step群 を成す`~item$のうち，
【その`~step$shEが】 %~step 以下かつ最~大なもの
◎
Return the greatest item in steps that is less than or equal to step.
</p>

<p class="note">注記：
これは、［
`~navigable$の除去に因り，
`~step$shE %~step を伴う`~session履歴~entry$は無い状況
］をまかなう。
◎
This caters for situations where there's no session history entry with step step, due to the removal of a navigable.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`履歴~objの長さと~indexを取得する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, 負でない整数 %~step )
に対し， 2 個の負でない整数からなる`~tuple$を返す：
◎
To get the history object length and index given a traversable navigable traversable, and a non-negative integer step, perform the following steps. They return a tuple of two non-negative integers.
</p>
<ol>
	<li>
%~step群 ~LET `利用されたすべての履歴~stepを取得する$( %辿可能 )
◎
Let steps be the result of getting all used history steps within traversable.
</li>
	<li>
%~script履歴~長さ ~LET %~step群 の`~size$
◎
Let scriptHistoryLength be the size of steps.
</li>
	<li>
<p>
~Assert：
%~step ~IN %~step群
◎
Assert: steps contains step.
</p>

<p class="note">注記：
`利用された~stepを取得する$ことにより，
%~step は調整-済みと見做される。
【？】
◎
It is assumed that step has been adjusted by getting the used step.
</p>
	</li>
	<li>
%~script履歴~index ~LET %~step群 における %~step の~index
◎
Let scriptHistoryIndex be the index of step in steps.
</li>
	<li>
~RET ( %~script履歴~長さ, %~script履歴~index )
◎
Return (scriptHistoryLength, scriptHistoryIndex).
</li>
</ol>
</div>

<div class="algo">
<p>
`現在の~session履歴~entryが変更されるか読込直される~navigableをすべて取得する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, 負でない整数 %~target~step )
に対し，`~navigable$たちが成す`~list$を返す：
◎
To get all navigables whose current session history entry will change or reload given a traversable navigable traversable, and a non-negative integer targetStep, perform the following steps. They return a list of navigables.
</p>
<ol>
	<li>
%結果~群 ~LET 新たな`~list$
◎
Let results be an empty list.
</li>
	<li>
<p>
%検査する~navigable群 ~LET « %辿可能 »
◎
Let navigablesToCheck be « traversable ».
</p>

<p class="note">注記：
この~listは、
以下の~loop内で拡張される。
◎
This list is extended in the loop below.
</p>
	</li>
	<li>
<p>
%検査する~navigable群 を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of navigablesToCheck:
</p>
		<ol>
			<li>
%~target~entry ~LET `~target履歴~entryを取得する$( %~navigable, %~target~step )
◎
Let targetEntry be the result of getting the target history entry given navigable and targetStep.
</li>
			<li>
~IF［
%~target~entry ~NEQ %~navigable の`現在の~session履歴~entry$nav
］~OR［
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~T
］
⇒
%結果~群 に %~navigable を`付加する$
◎
If targetEntry is not navigable's current session history entry or targetEntry's document state's reload pending is true, then append navigable to results.
</li>
			<li>
<p>
~IF［
%~target~entry の`文書$shE ~EQ %~navigable にて`作動中な文書$nav
］~AND［
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~F
］
⇒
%検査する~navigable群 を %~navigable の`子~navigable群$で`拡張する$
◎
If targetEntry's document is navigable's document, and targetEntry's document state's reload pending is false, then extend navigablesToCheck with the child navigables of navigable.
</p>

<p class="note">注記：
`子~navigable$たちは，［
%~navigable にて`作動中な文書$navが，この辿りの一部として変更されない場合
］に限り追加され、
その結果，この~loop内で検査されるようになる。
◎
Adding child navigables to navigablesToCheck means those navigables will also be checked by this loop. Child navigables are only checked if the navigable's active document will not change as part of this traversal.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %結果~群
◎
Return results.
</li>
</ol>
</div>

<div class="algo">
<p>
`履歴~objの長さか~indexの更新に限り必要になる~navigableをすべて取得する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, 負でない整数 %~target~step )
に対し，`~navigable$たちが成す`~list$を返す：
◎
To get all navigables that only need history object length/index update given a traversable navigable traversable, and a non-negative integer targetStep, perform the following steps. They return a list of navigables.
</p>

<p class="note">注記：
他の`~navigable$は、
当の辿りにより影響iされないかもしれない。
例えば，応答が `204$hst であった場合、
現在~作動中な文書は，そのままであり続けることになる。
加えて、
`204^hst の後に “戻った” とすると，
`現在の~session履歴~entry$navは変更されるが，
`作動中な~entry$navは，すでに正しいものになる。
◎
Other navigables might not be impacted by the traversal. For example, if the response is a 204, the currently active document will remain. Additionally, going 'back' after a 204 will change the current session history entry, but the active session history entry will already be correct.
</p>
<ol>
	<li>
%結果~群 ~LET 新たな`~list$
◎
Let results be an empty list.
</li>
	<li>
<p>
%検査する~navigable群 ~LET « %辿可能 »
◎
Let navigablesToCheck be « traversable ».
</p>

<p class="note">注記：
この~listは、
以下の~loop内で拡張される。
◎
This list is extended in the loop below.
</p>
	</li>
	<li>
<p>
%検査する~navigable群 を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of navigablesToCheck:
</p>
		<ol>
			<li>
%~target~entry ~LET `~target履歴~entryを取得する$( %~navigable, %~target~step )
◎
Let targetEntry be the result of getting the target history entry given navigable and targetStep.
</li>
			<li>
<p>
~IF［
%~target~entry ~EQ %~navigable の`現在の~session履歴~entry$nav
］~AND［
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~F
］：
◎
If targetEntry is navigable's current session history entry and targetEntry's document state's reload pending is false, then:
</p>
				<ol>
					<li>
%結果~群 に %~navigable を`付加する$
◎
Append navigable to results.
</li>
					<li>
%検査する~navigable群 を %~navigable の`子~navigable群$で`拡張する$
◎
Extend navigablesToCheck with navigable's child navigables.
</li>
				</ol>
<p class="note">注記：
`子~navigable$たちは，［
%~navigable にて`作動中な文書$navが，この辿りの一部として変更されない場合
］に限り追加され、
その結果，この~loop内で検査されるようになる。
◎
Adding child navigables to navigablesToCheck means those navigables will also be checked by this loop. child navigables are only checked if the navigable's active document will not change as part of this traversal.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %結果~群
◎
Return results.
</li>
</ol>
</div>

<div class="algo">
<p>
`~target履歴~entryを取得する@
~algoは、
所与の
( `~navigable$ %~navigable, 負でない整数 %~step )
に対し，`~session履歴~entry$を返す：
◎
To get the target history entry given a navigable navigable, and a non-negative integer step, perform the following steps. They return a session history entry.
</p>
<ol>
	<li>
%~entry群 ~LET `~session履歴~entry群を取得する$( %~navigable )
◎
Let entries be the result of getting session history entries for navigable.
</li>
	<li>
~RET %~entry群 内の`~item$のうち，
その`~step$shEが %~step 以下かつ最~大なもの
◎
Return the item in entries that has the greatest step less than or equal to step.
</li>
</ol>
</div>

<div class="example" id="example-getting-the-target-history-entry">
<p>
なぜ，［
`~target履歴~entryを取得する$とき，
`~step$shEが入力~step以下かつ最~大なものを返す
］のか~~知るため、
次の`~Jake図式$を考える：
◎
To see why getting the target history entry returns the entry with the greatest step less than or equal to the input step, consider the following Jake diagram:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step">1
<th class="step">2
<th class="step">3
<tbody>

<tr><th>`top^c
<td colspan="3" class="doc-0">`/t^c
<td colspan="1" class="doc-0">`/t#foo^c

<tr><th>`frames[0]^c
<td colspan="1" class="doc-1">`/i-0-a^c
<td colspan="3" class="doc-2">`/i-0-b^c
</table>

<p>
入力~step 1 に対しては、［
~navigable `top^c 用の~target履歴~entryは、
~entry `/t^c になり，
その `~step$shE ~EQ 0 になる
］一方で［
~navigable `frames[0]^c 用の~target履歴~entryは、
~entry `/i-0-b^c になり，
その`~step$shE ~EQ 1 になる
］：
◎
For the input step 1,＼
the target history entry for the top navigable is the /t entry, whose step is 0,＼
while the target history entry for the frames[0] navigable is the /i-0-b entry, whose step is 1:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step current">1
<th class="step">2
<th class="step">3
<tbody>

<tr><th>`top^c
<td colspan="3" class="doc-0 current next-is-same-doc">`/t^c
<td colspan="1" class="doc-0 prev-is-same-doc">`/t#foo^c

<tr><th>`frames[0]^c
<td colspan="1" class="doc-1">`/i-0-a^c
<td colspan="3" class="doc-2 current">`/i-0-b^c
</table>

<p>
類似に，所与の入力~step 3 に対しては、［
`top^c ~entryの`~step$shE ~EQ 3 ／
`frames[0]^c ~entryの`~step$shE ~EQ 1
］が取得される：
◎
Similarly, given the input step 3 we get the top entry whose step is 3, and the frames[0] entry whose step is 1:
</p>

<table class="jake-diagram"><thead>
<tr><td>
<th class="step">0
<th class="step">1
<th class="step">2
<th class="step current">3
<tbody>

<tr><th>`top^c
<td colspan="3" class="doc-0 next-is-same-doc">`/t^c
<td colspan="1" class="doc-0 current prev-is-same-doc">`/t#foo^c

<tr><th>`frames[0]^c
<td colspan="1" class="doc-1">`/i-0-a^c
<td colspan="3" class="doc-2 current">`/i-0-b^c
</table>
</div>

<div class="algo">
<p>
`非同一-文書の辿りを経るかもしれない~navigableをすべて取得する@
~algoは、
所与の
( `辿可能な~navigable$ %辿可能, 負でない整数 %~target~step )
に対し，`~navigable$たちが成す`~list$を返す：
◎
To get all navigables that might experience a cross-document traversal given a traversable navigable traversable, and a non-negative integer targetStep, perform the following steps. They return a list of navigables.
</p>

<div class="note">
<p>注記：
%辿可能 の`~session履歴~辿り~queue$navの視点からは、
これらの文書は，
%~target~step により述べられる辿りの間に経るかもしれない非同一-文書な候補たちを成す。
それらは、
~target文書~用の~HTTP状態s~codeが `204$hst の場合には，非同一-文書の辿りを経ないことになる。
◎
From traversable's session history traversal queue's perspective, these documents are candidates for going cross-document during the traversal described by targetStep. They will not experience a cross-document traversal if the status code for their target document is HTTP 204 No Content.
</p>

<p>
所与の`~navigable$が非同一-文書の辿りを経るかもしれない場合、
この~algoは，［
その`子~navigable$たちではなく，当の`~navigable$
］を返すことになることに注意。
それらの子~navigableは、
辿られることなく`~unloadされる＠~HTMLlifecycle#unload-a-document$結果になる。
◎
Note that if a given navigable might experience a cross-document traversal, this algorithm will return navigable but not its child navigables. Those would end up unloaded, not traversed.
</p>
</div>
<ol>
	<li>
%結果~群 ~LET 新たな`~list$
◎
Let results be an empty list.
</li>
	<li>
<p>
%検査する~navigable群 ~LET « %辿可能 »
◎
Let navigablesToCheck be « traversable ».
</p>

<p class="note">注記：
この~listは、
以下の~loop内で拡張される。
◎
This list is extended in the loop below.
</p>
	</li>
	<li>
<p>
%検査する~navigable群 を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of navigablesToCheck:
</p>
		<ol>
			<li>
%~target~entry ~LET `~target履歴~entryを取得する$( %~navigable, %~target~step )
◎
Let targetEntry be the result of getting the target history entry given navigable and targetStep.
</li>
			<li>
<p>
~IF［
%~target~entry の`文書$shE ~NEQ %~navigable にて`作動中な文書$nav
］~OR［
%~target~entry の`文書~状態$shEの`再読込みは処理待ちか$dS ~EQ ~T
］
⇒
%結果~群 に %~navigable を`付加する$
◎
If targetEntry's document is not navigable's document or targetEntry's document state's reload pending is true, then append navigable to results.
</p>

<p class="note">注記：
%~navigable にて`作動中な~entry$navは，同期的に変更され得るが、
新たな~entryは，常に同じ`文書$を有するので、
%~navigable にて`作動中な文書$navに対しては，依拠-可能に~accessできる。
◎
Although navigable's active history entry can change synchronously, the new entry will always have the same Document, so accessing navigable's document is reliable.
</p>
			</li>
			<li>
<p>
~ELSE
⇒
%検査する~navigable群 を
%~navigable の`子~navigable群$で`拡張する$
◎
Otherwise, extend navigablesToCheck with navigable's child navigables.
</p>

<p class="note">注記：
`子~navigable$たちは，［
%~navigable にて`作動中な文書$navが，この辿りの一部として変更されない場合
］に限り追加され、
その結果，この~loop内で検査されるようになる。
◎
Adding child navigables to navigablesToCheck means those navigables will also be checked by this loop. Child navigables are only checked if the navigable's active document will not change as part of this traversal.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %結果~群
◎
Return results.
</li>
</ol>
</div>

				</section>
				<section id="updating-the-document">
<h5 title="Updating the document">7.4.6.2. 文書の更新-法</h5>

<div class="algo">
<p>
`履歴~stepを適用するために文書を更新する@
~algoは、
所与の
⇒＃
`文書$ %文書,
`~session履歴~entry$ %~entry,
真偽値 %作動化し直さないか,
整数 %~script履歴~長さ,
整数 %~script履歴~index,
［ `NavigationType$I ／ ~NULL ］%~navi種別,
`~session履歴~entry$たちが成す`~list$ %~navi~API用の~entry群 ~DF ε,
`~session履歴~entry$ %作動化~用の直前~entry ~DF ε
◎終
に対し：
◎
To update document for history step application given a Document document, a session history entry entry, a boolean doNotReactivate, integers scriptHistoryLength and scriptHistoryIndex, NavigationType-or-null navigationType, an optional list of session history entries entriesForNavigationAPI, and an optional session history entry previousEntryForActivation:
</p>
<ol>
	<li>
%新たな文書か ~LET ~IS［
%文書 の`最近の~entry$ ~EQ ~NULL
］
◎
Let documentIsNew be true if document's latest entry is null; otherwise false.
</li>
	<li>
%文書たちの~entryは変化したか ~LET ~IS［
%文書 の`最近の~entry$ ~NEQ %~entry
］
◎
Let documentsEntryChanged be true if document's latest entry is not entry; otherwise false.
</li>
	<li>
%文書 の`履歴~obj$の`~index$hsT ~SET %~script履歴~index
◎
Set document's history object's index to scriptHistoryIndex.
</li>
	<li>
%文書 の`履歴~obj$の`長さ$hsT ~SET %~script履歴~長さ
◎
Set document's history object's length to scriptHistoryLength.
</li>
	<li>
%~navi ~LET %履歴 に`関連な大域~obj$の`~navi~API$
◎
Let navigation be history's relevant global object's navigation API.
</li>
	<li>
<p>
~IF［
%文書たちの~entryは変化したか ~EQ ~T
］：
◎
If documentsEntryChanged is true, then:
</p>
		<ol>
			<li>
%旧-~URL ~LET %文書 の`最近の~entry$の`~URL$shE
◎
Let oldURL be document's latest entry's URL.
</li>
			<li>
%文書 の`最近の~entry$ ~SET %~entry
◎
Set document's latest entry to entry.
</li>
			<li>
`履歴~objの状態を復旧する$( %文書, %~entry )
◎
Restore the history object state given document and entry.
</li>
			<li>
<p>
~IF［
%新たな文書か ~EQ ~F
］：
◎
If documentIsNew is false, then:
</p>
				<ol>
					<li>
~Assert：
%~navi種別 ~NEQ ~NULL
◎
Assert: navigationType is not null.
</li>
					<li>
`同一-文書~navi用に~navi~API~entry群を更新する$( %~navi, %~entry, %~navi種別 )
◎
Update the navigation API entries for a same-document navigation given navigation, entry, and navigationType.
</li>
					<li>
<p>
`~eventを発火する$( %文書 に`関連な大域~obj$, `popstate$et, `PopStateEvent$I )
— 次のように初期化して：
◎
Fire an event named popstate at document's relevant global object, using PopStateEvent, with＼
</p>
						<ul>
							<li>
`state＠~WINDOW#dom-popstateevent-state$m 属性 ~SET %文書 の`履歴~obj$の`状態$hsT
◎
the state attribute initialized to document's history object's state and＼
</li>
							<li>
`hasUAVisualTransition＠~WINDOW#dom-popstateevent-hasuavisualtransition$m 属性 ~SET ~IS［
~UAは~cacheしてあった［
%文書 の`最近の~entry$が描画された状態
］を表示するための視覚的な遷移を行った
］
◎
hasUAVisualTransition initialized to true if a visual transition, to display a cached rendered state of the latest entry, was done by the user agent.
</li>
						</ul>
					</li>
					<li>
`履歴~entryから持続された状態を復旧する$( %~entry )
◎
Restore persisted state given entry.
</li>
					<li>
<p>
~IF［
%旧-~URL の`素片$url ~NEQ %~entry の`~URL$shEの`素片$url
］
⇒
`大域~taskを~queueする$( `~DOM操作~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
If oldURL's fragment is not equal to entry's URL's fragment, then queue a global task on the DOM manipulation task source given document's relevant global object to＼
</p>

<p class="algo">
手続きは
⇒
`~eventを発火する$( %文書 に`関連な大域~obj$, `hashchange$et, `HashChangeEvent$I )
— 次のように初期化して
⇒＃
`oldURL＠~WINDOW#dom-hashchangeevent-oldurl$m 属性 ~SET `~URLを直列化する$( %旧-~URL ),
`newURL＠~WINDOW#dom-hashchangeevent-newurl$m 属性 ~SET `~URLを直列化する$( %~entry の`~URL$shE )
◎
fire an event named hashchange at document's relevant global object, using HashChangeEvent, with the oldURL attribute initialized to the serialization of oldURL and the newURL attribute initialized to the serialization of entry's URL.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~Assert：
%~navi~API用の~entry群 ~NEQ ε
◎
Assert: entriesForNavigationAPI is given.
</li>
					<li>
`履歴~entryから持続された状態を復旧する$( %~entry )
◎
Restore persisted state given entry.
</li>
					<li>
`新たな文書~用に~navi~API~entry群を初期化する$( %~navi, %~navi~API用の~entry群,
%~entry )
◎
Initialize the navigation API entries for a new document given navigation, entriesForNavigationAPI, and entry.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all the following are true:
</p>
		<ul>
			<li>
%作動化~用の直前~entry ~NEQ ε
◎
previousEntryForActivation is given;
</li>
			<li>
%~navi種別 ~NEQ ~NULL
◎
navigationType is non-null; and
</li>
			<li>
［
%~navi種別 ~EQ `reload$l
］~OR［
%作動化~用の直前~entry の`文書$shE ~NEQ %文書
］
◎
navigationType is "reload" or previousEntryForActivation's document is not document,
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%作動化 ~LET %~navi の`作動化$
【この段は、この訳による補完】
</li>
			<li>
<p>
~IF［
%作動化 ~EQ ~NULL
］：
</p>
				<ol>
					<li>
%作動化 ~SET `新たな~obj$( `NavigationActivation$I, %~navi に`関連な~realm$ )
</li>
					<li>
%作動化 の`旧-~entry$nA ~SET ~NULL
【この段は、この訳による補完】
</li>
					<li>
%~navi の`作動化$ ~SET %作動化
</li>
				</ol>
◎
If navigation's activation is null, then set navigation's activation to a new NavigationActivation object in navigation's relevant realm.
</li>
			<li>
%直前~entryの~index ~LET `~navi~API~entry~indexを取得する$( %~navi, %作動化~用の直前~entry )
◎
Let previousEntryIndex be the result of getting the navigation API entry index of previousEntryForActivation within navigation.
</li>
			<li>
~IF［
%直前~entryの~index ~GTE 0
］
⇒
%作動化 の`旧-~entry$nA ~SET %~navi の`~entry~list$nV[ %直前~entryの~index ]
◎
If previousEntryIndex is non-negative, then set activation's old entry to navigation's entry list[previousEntryIndex].
</li>
			<li>
<p>
~ELIF［
~AND↓
］…
◎
Otherwise, if all the following are true:
</p>
				<ul class="brief">
					<li>
%~navi種別 ~EQ `replace$l
◎
navigationType is "replace";
</li>
					<li>
%作動化~用の直前~entry の`文書~状態$shEの`生成元$dS %生成元 は次を満たす
⇒
［
%生成元 ~NEQ ~NULL
］~AND［
%生成元 ~EQ`生成元$sub %文書 の`生成元$doc
］
◎
previousEntryForActivation's document state's origin is same origin with document's origin; and
</li>
					<li>
%作動化~用の直前~entry の`文書$shEの`初期~about_blankか$doc ~EQ ~F
◎
previousEntryForActivation's document's initial about:blank is false,
</li>
				</ul>
<p>
…ならば
⇒
%作動化 の`旧-~entry$nA ~SET `新たな~obj$( `NavigationHistoryEntry$I, %~navi に`関連な~realm$ )
— その
⇒＃
`~session履歴~entry$nhe ~SET %作動化~用の直前~entry
◎
then set activation's old entry to a new NavigationHistoryEntry in navigation's relevant realm, whose session history entry is previousEntryForActivation.
</p>
			</li>
			<li>
%作動化 の`新-~entry$nA ~SET `~naviの現在の~entry$( %~navi )
◎
Set activation's new entry to navigation's current entry.
</li>
			<li>
%作動化 の`~navi種別$nA ~SET %~navi種別
◎
Set activation's navigation type to navigationType.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%新たな文書か ~EQ ~T
］：
◎
If documentIsNew is true, then:
</p>
		<ol>
			<li>
%~navi~ID ~LET %文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc
◎
↓</li>
			<li>
~Assert: %~navi~ID ~NEQ ~NULL
◎
Assert: document's during-loading navigation ID for WebDriver BiDi is not null.
</li>
			<li>
`~WebDriver-BiDi~naviは~commitされた$( ↓ )
⇒＃
%~navigable,
`新たな~WebDriver-BiDi~navi状態s$( %~navi~ID, `~commitされた$wBDst, %文書 の`~URL$doc )
◎
Invoke WebDriver BiDi navigation committed with navigable and a new WebDriver BiDi navigation status whose id is document's during-loading navigation ID for WebDriver BiDi, status is "committed", and url is document's URL.
</li>

			<li>
`素片へ~scrollするよう試行する$( %文書 )
◎
Try to scroll to the fragment for document.
</li>
			<li>
この時点で、
%文書 は
`~scriptを走らせてもよい@
とされる。
◎
At this point scripts may run for the newly-created document document.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%文書たちの~entryは変化したか ~EQ ~F
］~AND［
%作動化し直さないか ~EQ ~F
］：
◎
Otherwise, if documentsEntryChanged is false and doNotReactivate is false, then:
</p>
		<ol>
			<li>
~Assert：
%~navi~API用の~entry群 ~NEQ ε
◎
Assert: entriesForNavigationAPI is given.
</li>
			<li>
`文書を作動化し直す$( %文書, %~entry, %~navi~API用の~entry群 )
◎
Reactivate document given entry and entriesForNavigationAPI.
</li>
		</ol>

<div class="note">
<p>注記：
%文書たちの~entryは変化したか が ~F をとり得るのは、
次のいずれかの理由による：
</p>
		<ul>
			<li>
`~BF~cache$から復旧している／
</li>
			<li>
すでに %文書 の`最近の~entry$を同期的に設定した同期的な~naviを非同期的に完遂している
</li>
		</ul>
<p>
引数 %作動化し直さないか は、
この どちらの事例なのかを判別する。
</p>
◎
documentsEntryChanged can be false for one of two reasons: either we are restoring from bfcache, or we are asynchronously finishing up a synchronous navigation which already synchronously set document's latest entry. The doNotReactivate argument distinguishes between these two cases.
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`履歴~objの状態を復旧する@
~algoは、
所与の
( `文書$ %文書, `~session履歴~entry$ %~entry )
に対し：
◎
To restore the history object state given Document document and session history entry entry:
</p>
<ol>
	<li>
%宛先~realm ~LET %文書 に`関連な~realm$
◎
Let targetRealm be document's relevant realm.
</li>
	<li>
%状態 ~LET ~NULL
◎
↓</li>
	<li>
~IF［
%~entry の`古典~履歴~API用の状態$shE ~NEQ ~NULL
］
⇒
%状態 ~SET `StructuredDeserialize$jA( %~entry の`古典~履歴~API用の状態$shE, %宛先~realm )
⇒
例外が投出されたときは、
~catchする（ %状態 ~EQ ~NULL のまま）
◎
Let state be StructuredDeserialize(entry's classic history API state, targetRealm). If this throws an exception, catch it and let state be null.
</li>
	<li>
%文書 の`履歴~obj$の`状態$hsT ~SET %状態
◎
Set document's history object's state to state.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書を作動中にする@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To make active a Document document:
</p>
<ol>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be document's relevant global object.
</li>
	<li>
［
%文書 が`属する閲覧~文脈$の `WindowProxy$I
］の `Window$sl 内部~slot ~SET %~window
◎
Set document's browsing context's WindowProxy's [[Window]] internal slot value to window.
</li>
	<li>
%文書 の`可視性~状態$doc ~SET %文書 の`~node~navigable$の`辿可能な~navigable$navの`~system可視性~状態$nav
◎
Set document's visibility state to document's node navigable's traversable navigable's system visibility state.
</li>
	<li>
%処理能~entry ~LET `新たな~obj$( `VisibilityStateEntry$I, 【 %文書 に`関連な~realm$】 )
◎
↓</li>
	<li>
%処理能~entry の
⇒＃
`可視性~状態$vsE ~SET %文書 の`可視性~状態$doc,
`時刻印$vsE ~SET 0
◎
↓</li>
	<li>
`処理能~entryを~queueする$( %処理能~entry )
◎
Queue a new VisibilityStateEntry whose visibility state is document's visibility state and whose timestamp is zero.
</li>
	<li>
%~window に`関連な設定群~obj$の`実行は準備済みか$enV ~SET ~T
◎
Set window's relevant settings object's execution ready flag.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書を作動化し直す@
~algoは、
所与の
⇒＃
`文書$ %文書,
`~session履歴~entry$ %作動化し直される~entry,
`~session履歴~entry$たちが成す`~list$ %~navi~API用の~entry群
◎終
に対し：
◎
To reactivate a Document document given a session history entry reactivatedEntry and a list of session history entries entriesForNavigationAPI:
</p>

<p class="note">注記：
この~algoは、
%文書 を`~BF~cache$から取り出した後
— すなわち， %文書 が再び`全部的に作動中$にされた後 —
に %文書 を更新する。
他の仕様は，この［
`全部的に作動中$な状態への変化
］を注視したいと求めるなら、［
当の変化による効果にて起こる~eventたち
］の順序付けが明瞭になるよう，［
この~algoの中へ手続きを追加する
］ことが奨励される。
◎
This algorithm updates document after it has come out of bfcache, i.e., after it has been made fully active again. Other specifications that want to watch for this change to the fully active state are encouraged to add steps into this algorithm, so that the ordering of events that happen in effect of the change is clear.
</p>
<ol>
	<li id="history-autocomplete">
%文書 内の
~EACH( 【`再設定-可能$な要素】 %~form~control )
に対し
⇒
~IF［
%~form~control の`~autofill欄~名$ ~EQ "`off$v"
］
⇒
%~form~control 用の`再設定する~algo$()
◎
For each formControl of form controls in document with an autofill field name of "off", invoke the reset algorithm for formControl.
</li>
	<li>
<p>
~IF［
%文書 の`休止された~timer~handle群$docは`空$でない
］：
◎
If document's suspended timer handles is not empty:
</p>
		<ol>
			<li>
~Assert：
%文書 の`休止~時刻$doc ~NEQ 0
◎
Assert: document's suspension time is not zero.
</li>
			<li>
%休止-所要時間 ~LET `現在の高分解能~時刻$( 【%文書 に`関連な大域~obj$】 ) ~MINUS %文書 の`休止~時刻$doc
◎
Let suspendDuration be the current high resolution time minus document's suspension time.
</li>
			<li>
%作動中な~timer群 ~LET %文書 に`関連な大域~obj$にて`作動中な~timer群が成す~map$
◎
Let activeTimers be document's relevant global object's map of active timers.
</li>
			<li>
%文書 の`休止された~timer~handle群$docを成す
~EACH( %~handle )
に対し
⇒
~IF［
%作動中な~timer群[ %~handle ] ~NEQ ε
］
⇒
%作動中な~timer群[ %~handle ] ~INCBY %休止-所要時間
◎
For each handle in document's suspended timer handles, if activeTimers[handle] exists, then increase activeTimers[handle] by suspendDuration.
</li>
		</ol>
	</li>
	<li>
`再~作動化~用に~navi~API~entry群を更新する$( ↓ )
⇒＃
%文書 に`関連な大域~obj$の`~navi~API$,
%~navi~API用の~entry群,
%作動化し直される~entry
◎
Update the navigation API entries for reactivation given document's relevant global object's navigation API, entriesForNavigationAPI, and reactivatedEntry.
</li>
	<li>
<p>
~IF［
%文書 の`現在の準備度$doc ~EQ `complete^l
］~AND［
%文書 の`~pageを示しているか$doc ~EQ ~F
］：
◎
If document's current document readiness is "complete", and document's page showing is false:
</p>
		<ol>
			<li>
%文書 の`~pageを示しているか$doc ~SET ~T
◎
Set document's page showing to true.
</li>
			<li>
%文書 の`露呈されたか$doc ~SET ~F
◎
Set document's has been revealed to false.
</li>
			<li>
`可視性~状態を更新する$( %文書, `visible^l )
◎
Update the visibility state of document to "visible".
</li>
			<li>
`~page遷移~eventを発火する$( %文書 に`関連な大域~obj$, `pageshow$et, ~T )
◎
Fire a page transition event named pageshow at document's relevant global object with true.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`素片へ~scrollするよう試行する@
~algoは、
所与の
( `文書$ %文書 )
に対し，次の手続きを`並列的$に遂行する：
◎
To try to scroll to the fragment for a Document document, perform the following steps in parallel:
</p>
<ol>
	<li>
`実装定義$な量の時間だけ待機する
（これには、［
~UAが処理能の懸念に直面したとき，利用者~体験を最適化する
］ことを許容することが意図される。）
◎
Wait for an implementation-defined amount of time. (This is intended to allow the user agent to optimize the user experience in the face of performance concerns.)
</li>
	<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the navigation and traversal task source given document's relevant global object＼
</p>

<div class="algo">
<p>
手続きは：
◎
to run these steps:
</p>
		<ol>
			<li>
~IF［
%文書 には構文解析器は無い
］~OR［
%文書 の構文解析器は`構文解析を停止-$した
］~OR［
~UAには［
利用者が`素片$urlへ~scrollすることに もはや関心を失った
］と予見する理由がある
］
⇒
~RET
◎
If document has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user is no longer interested in scrolling to the fragment, then abort these steps.
</li>
			<li>
`素片へ~scrollする$( %文書 )
◎
Scroll to the fragment given document.
</li>
			<li>
~IF［
%文書 の`指示された部位$doc ~EQ ~NULL
］
⇒
`素片へ~scrollするよう試行する$( %文書 )
◎
If document's indicated part is still null, then try to scroll to the fragment for document.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
`文書を回復不能にする@
~algoは、
所与の
( `文書$ %文書, 文字列 %事由 )
に対し：
◎
To make document unsalvageable, given a Document document and a string reason:
</p>
<ol>
	<li>
%詳細 ~LET 新たな`復旧されない事由の詳細$
— その
⇒＃
`事由~文字列$nrrd ~SET %事由
◎
Let details be a new not restored reason details whose reason is reason.
</li>
	<li>
%文書 の`~BF~cacheを阻んでいる詳細$docに %詳細 を`付加する$set
◎
Append details to document's bfcache blocking details.
</li>
	<li>
%文書 の`回復可能か$doc ~SET ~F
◎
Set document's salvageable state to false.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書~状態~用に復旧されない事由~群を築く@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To build not restored reasons for document state given Document document:
</p>
<ol>
	<li>
%文書~用の復旧されない事由~群 ~LET 新たな`復旧されない事由~群$
◎
Let notRestoredReasonsForDocument be a new not restored reasons.
</li>
	<li>
%文書~用の復旧されない事由~群 の`~URL$nrr ~SET %文書 の`~URL$doc
◎
Set notRestoredReasonsForDocument's URL to document's URL.
</li>
	<li>
%容器 ~LET %文書 の`~node~navigable$の`容器$nav
◎
Let container be document's node navigable's container.
</li>
	<li>
<p>
~IF［
%容器 は `iframe$e 要素である
］：
◎
If container is an iframe element:
</p>
		<ol>
			<li>
%src ~LET 空~文字列
◎
Let src be the empty string.
</li>
			<li>
<p>
~IF［
%容器 は `src$aF【！#dom-iframe-src】 属性を有する
］：
</p>
				<ol>
					<li>
%src ~SET %容器 の `src$aF 属性の値
</li>
					<li>
%~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( %src, %容器 の`~node文書$ )
</li>
					<li>
~IF［
%~URL ~NEQ `失敗^i
］
⇒
%src ~SET `~URLを直列化する$( %~URL )
</li>
				</ol>
◎
If container has a src attribute:
• Let src be the result of encoding-parsing-and-serializing a URL given container's src attribute's value, relative to container's node document.
• If src is failure, then set src to container's src attribute's value.
</li>
			<li>
%文書~用の復旧されない事由~群 の`~source$nrr ~SET %src
◎
Set notRestoredReasonsForDocument's src to src.
</li>
			<li>
%文書~用の復旧されない事由~群 の`~ID$nrr ~SET ［
%容器 は `id$a 属性を有するならば その値／
~ELSE_ 空~文字列
］
◎
Set notRestoredReasonsForDocument's id to container's id attribute's value, or the empty string if it has no such attribute.
</li>
			<li>
%文書~用の復旧されない事由~群 の`名前$nrr ~SET ［
%容器 は `name$aF 属性を有するならば その値 ／
~ELSE_ 空~文字列
］
◎
Set notRestoredReasonsForDocument's name to container's name attribute's value, or the empty string if it has no such attribute.
</li>
		</ol>
	</li>
	<li>
%文書~用の復旧されない事由~群 の`事由~群$nrr ~SET %文書 の`~BF~cacheを阻んでいる詳細$docを`~cloneする$
◎
Set notRestoredReasonsForDocument's reasons to a clone of document's bfcache blocking details.
</li>
	<li>
<p>
%文書 の`文書~treeに属する子~navigable群$を成す
~EACH( %~navigable )
に対し：
◎
For each navigable of document's document-tree child navigables:
</p>
		<ol>
			<li>
%子~文書 ~LET %~navigable にて`作動中な文書$nav
◎
Let childDocument be navigable's active document.
</li>
			<li>
`文書~状態~用に復旧されない事由~群を築く$( %子~文書 )
◎
Build not restored reasons for document state given childDocument.
</li>
			<li>
%文書~用の復旧されない事由~群 の`子~事由~群$nrr に次の結果を`付加する$
⇒
`文書の復旧されない事由~群$( %子~文書 )
◎
Append childDocument's not restored reasons to notRestoredReasonsForDocument's children.
</li>
		</ol>
	</li>
	<li>
%文書 の`~node~navigable$にて`作動中な~entry$navの`文書~状態$shEの`復旧されない事由~群$dS ~SET %文書~用の復旧されない事由~群
◎
Set document's node navigable's active session history entry's document state's not restored reasons to notRestoredReasonsForDocument.
</li>
</ol>
</div>

<div class="algo">
<p>
`~top-level辿可能とその子孫~用に復旧されない事由~群を築く@
~algoは、
所与の
( `~top-level辿可能$ %~top-level辿可能 )
に対し：
◎
To build not restored reasons for a top-level traversable and its descendants given top-level traversable topLevelTraversable:
</p>
<ol>
	<li>
`文書~状態~用に復旧されない事由~群を築く$( %~top-level辿可能 にて`作動中な文書$nav )
◎
Build not restored reasons for document state given topLevelTraversable's active document.
</li>
	<li>
%非同一-生成元な子孫~群 ~LET 新たな`~list$
◎
Let crossOriginDescendants be an empty list.
</li>
	<li>
<p>
%~top-level辿可能 にて`作動中な文書$navの`子孫~navigable群$を成す
~EACH( %子~navigable )
に対し
⇒
~IF［
%子~navigable にて`作動中な文書$navの`生成元$doc
~NEQ `生成元$sub
%~top-level辿可能 にて`作動中な文書$navの`生成元$doc
］
⇒
%非同一-生成元な子孫~群 に %子~navigable を`付加する$
◎
For each childNavigable of topLevelTraversable's active document's descendant navigables:
• If childNavigable's active document's origin is not same origin with topLevelTraversable's active document's origin, then append childNavigable to crossOriginDescendants.
</li>
	<li>
%非同一-生成元な子孫~群は~BF~cacheを防止するか ~LET ~F
◎
Let crossOriginDescendantsPreventsBfcache be false.
</li>
	<li>
<p>
%非同一-生成元な子孫~群 を成す
~EACH( %非同一-生成元な~navigable )
に対し：
◎
For each crossOriginNavigable of crossOriginDescendants:
</p>
		<ol>
			<li>
%非同一-生成元な子~用の事由 ~LET %非同一-生成元な~navigable にて`作動中な文書$navの`文書~状態$の`復旧されない事由~群$dS
◎
Let reasonsForCrossOriginChild be crossOriginNavigable's active document's document state's not restored reasons.
</li>
			<li>
~IF［
%非同一-生成元な子~用の事由 の`事由~群$nrrは空でない
］
⇒
%非同一-生成元な子孫~群は~BF~cacheを防止するか ~SET ~T
◎
If reasonsForCrossOriginChild's reasons is not empty, set crossOriginDescendantsPreventsBfcache to true.
</li>
			<li>
%非同一-生成元な子~用の事由 の
⇒＃
`~URL$nrr ~SET ~NULL,
`事由~群$nrr ~SET ~NULL,
`子~事由~群$nrr ~SET ~NULL
◎
Set reasonsForCrossOriginChild's URL to null.
◎
Set reasonsForCrossOriginChild's reasons to null.
◎
Set reasonsForCrossOriginChild's children to null.
</li>
		</ol>
	</li>
	<li>
~IF［
%非同一-生成元な子孫~群は~BF~cacheを防止するか ~EQ ~T
］
⇒
`文書を回復不能にする$( %~top-level辿可能 にて`作動中な文書$nav, `masked$l )
◎
If crossOriginDescendantsPreventsBfcache is true, make document unsalvageable given topLevelTraversable's active document and "masked".
</li>
</ol>
</div>

				</section>
				<section id="revealing-the-document">
<h5 title="Revealing the document">7.4.6.3 文書を露呈する</h5>

<p>
各`文書$は、
真偽値をとる
`露呈されたか@doc
を有する
— 初期~時は ~F とする。
これは、［
`pagereveal$et ~eventが`文書$の各~作動化に対し一回だけ発火される
］ことを確保するために利用される
（初期~時に描画されたとき一回, `文書を作動化し直す$各回に一回）。
◎
A Document has a boolean has been revealed, initially false. It is used to ensure that the pagereveal event is fired once for each activation of the Document (once when it's rendered initially, and once for each reactivation).
</p>

<div class="algo">
<p>
`文書を露呈する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To reveal a Document document:
</p>
<ol>
	<li>
~IF［
%文書 の`露呈されたか$doc ~EQ ~T
］
⇒
~RET
◎
If document's has been revealed is true, then return.
</li>
	<li>
%文書 の`露呈されたか$doc ~SET ~T
◎
Set document's has been revealed to true.
</li>
	<li>
%遷移 ~LET `内へ来る非同一-文書な~view遷移を解決する$( %文書 )
◎
Let transition be the result of resolving inbound cross-document view-transition for document.
</li>
	<li>
`~eventを発火する$( %文書 に`関連な大域~obj$, `pagereveal$et, `PageRevealEvent$I )
— 次のように初期化して
⇒＃
`viewTransition$mPRe 属性 ~SET %遷移
◎
Fire an event named pagereveal at document's relevant global object, using PageRevealEvent with its viewTransition set to transition.
</li>
	<li>
<p>
~IF［
%遷移 ~NEQ ~NULL
］：
◎
If transition is not null, then:
</p>
		<ol>
			<li>
`~scriptを走らすために準備する$( %文書 に`関連な設定群~obj$ )
◎
Prepare to run script given document's relevant settings object.
</li>
			<li>
`~view遷移を作動化する$( %遷移 )
◎
Activate transition.
</li>
			<li>
`走らせた~scriptを片付ける$( %文書 に`関連な設定群~obj$ )
◎
Clean up after running script given document's relevant settings object.
</li>
		</ol>

<p class="note">注記：
~view遷移を作動化すると，~promiseたちが［
解決される／却下される
］かもしれない。
この段は、［
準備する, 片付ける
］で作動化を包装することにより，
それらの~promiseが次回の描画~段より前に取扱われることを確保する。
◎
Activating a view transition might resolve/reject promises, so by wrapping the activation with prepare/cleanup we ensure those promises are handled before the next rendering step.
</p>
	</li>
</ol>
</div>

<p class="note">注記：
`pagereveal$et は，［
`描画を更新する$中で~pageの~~最新~versionを表示する最初の段
］の間に発火されることが保証されるが、
~UAは，発火する前に当の~page用に~cacheした~frameを表示してもかまわない。
これは、
~cacheされた~frameの呈示が `pagereveal$et ~handlerが在るために遅延するのを防止する。
◎
Though pagereveal is guaranteed to be fired during the first update the rendering step that displays an up-to-date version of the page, user agents are free to display a cached frame of the page before firing it. This prevents the presence of a pagereveal handler from delaying the presentation of such cached frame.
</p>

				</section>
				<section id="scrolling-to-a-fragment">
<h5 title="Scrolling to a fragment">7.4.6.4. 素片への~scroll法</h5>

<div class="algo">
<p>
`素片へ~scrollする@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To scroll to the fragment given a Document document:
</p>
<ol>
	<li>
%~target ~LET %文書 の`指示された部位$doc
◎
↓</li>
	<li>
%文書 の`~target要素$ ~SET ~NULL
◎
↓</li>
	<li>
~IF［
%~target ~EQ ~NULL
］
⇒
~RET
◎
If document's indicated part is null,＼
↑ then set document's target element to null.
</li>
	<li>
<p>
~IF［
%~target ~EQ `文書の上端$i
］
⇒
`文書の先頭へ~scrollする$( %文書 )
◎
Otherwise, if document's indicated part is top of the document, then:
• ↑ Set document's target element to null.
• Scroll to the beginning of the document for document. [CSSOMVIEW]
• Return.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%~target は要素である。
◎
Assert: document's indicated part is an element.
◎
Let target be document's indicated part.
</li>
			<li>
%文書 の`~target要素$ ~SET %~target
◎
Set document's target element to target.
</li>
			<li>
`先祖を露呈する$( %~target )
◎
Run the ancestor revealing algorithm on target.
</li>
			<li>
`~targetを~viewの中へ~scrollする$( %~target, `auto^l, `start^l, `nearest^l )
`CSSOMVIEW$r
◎
Scroll target into view, with behavior set to "auto", block set to "start", and inline set to "nearest". [CSSOMVIEW]
</li>
			<li>
`~objを~focusする$( %~target, %文書 の`表示域$ )
◎
Run the focusing steps for target, with the Document's viewport as the fallback target.
</li>
			<li>
%文書 における`連列的~focus~naviの始点$ ~SET %~target
◎
Move the sequential focus navigation starting point to target.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
`文書$ %文書 内の
`指示された部位@doc
は、
%文書 の`~URL$docの`素片$urlが識別するものが［
在るならば，それが指示するもの ／
無いならば  ~NULL 
］になる。
~nodeへの対応付けに関する`素片$urlの意味論は、
%文書 が利用している`~MIME型$を定義する仕様により定義される
（例えば、
`~XML~MIME型$における`素片$urlの処理は `RFC7303$r が担当する）。
◎
A Document's indicated part is the one that its URL's fragment identifies, or null if the fragment does not identify anything. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the MIME type used by the Document (for example, the processing of fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]
</p>

<p>
各 `文書$には、
`target$ps 疑似類を定義するために利用される
`~target要素@
がある。
それは、
初期~時は ~NULL であり，上の~algoで更新される。
◎
There is also a target element for each Document, which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.
</p>

<p>
`~HTML文書$ %文書 用には、
%文書 内の`指示された部位$docは、
次の結果になるとする
⇒
`指示された部位を選定する$( %文書, %文書 の`~URL$doc )
◎
For an HTML document document, its indicated part is the result of selecting the indicated part given document and document's URL.
</p>

<div class="algo">
<p>
`指示された部位を選定する@
~algoは、
所与の
( `~HTML文書$ %文書, `~URL$ %~URL )
に対し：
◎
To select the indicated part given a Document document and a URL url:
</p>
<ol>
	<li>
~IF［
( %文書 の`~URL$doc, %~URL )
は、
`素片は除外する^i 下で`同等な~URL$でない
］
⇒
~RET ~NULL
◎
If document's URL does not equal url with exclude fragments set to true, then return null.
</li>
	<li>
%素片 ~LET %~URL の`素片$url
◎
Let fragment be url's fragment.
</li>
	<li>
~IF［
%素片 ~EQ 空~文字列
【 ~OR %素片 ~EQ ~NULL ？】
］
⇒
~RET 特別な値
`文書の上端@i
◎
If fragment is the empty string, then return the special value top of the document.
</li>
	<li>
%指示された要素 ~LET `指示された要素を見出す$( %文書, %素片 )
◎
Let potentialIndicatedElement be the result of finding a potential indicated element given document and fragment.
</li>
	<li>
~IF［
%指示された要素 ~NEQ ~NULL
］
⇒
~RET %指示された要素
◎
If potentialIndicatedElement is not null, then return potentialIndicatedElement.
</li>
	<li>
%素片~byte列 ~LET `文字列を~byte列に~percent-復号する$( %素片 )
◎
Let fragmentBytes be the result of percent-decoding fragment.
</li>
	<li>
%復号-済み素片 ~LET `~BOMはそのままに~UTF-8復号する$( %素片~byte列 )
◎
Let decodedFragment be the result of running UTF-8 decode without BOM on fragmentBytes.
</li>
	<li>
%指示された要素 ~SET `指示された要素を見出す$( %文書, %復号-済み素片 )
◎
Set potentialIndicatedElement to the result of finding a potential indicated element given document and decodedFragment.
</li>
	<li>
~IF［
%指示された要素 ~NEQ ~NULL
］
⇒
~RET %指示された要素
◎
If potentialIndicatedElement is not null, then return potentialIndicatedElement.
</li>
	<li>
~IF［
%復号-済み素片 ~EQ`大小無視$sub `top^l
］
⇒
~RET `文書の上端$i
◎
If decodedFragment is an ASCII case-insensitive match for the string top, then return the top of the document.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

<div class="algo">
<p>
`指示された要素を見出す@
~algoは、
所与の
( `文書$ %文書, 文字列 %素片 )
に対し：
◎
To find a potential indicated element given a Document document and a string fragment, run these steps:
</p>
<ol>
	<li>
%文書~tree ~LET %文書 の`文書~tree内$にある要素
（すなわち，要素の`根$ ~EQ %文書）
からなる集合
◎
↓</li>
	<li>
~IF［
%文書~tree を成す要素に［
`~ID$ ~EQ %素片
］を満たすものは在る
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an element in the document tree whose root is document and that has an ID equal to fragment, then return the first such element in tree order.
</li>
	<li>
~IF［
%文書~tree を成す要素に［
`a$e 要素であって、
`name＠~HTMLobs#attr-a-name$a 属性を有していて，その値 ~EQ %素片
］を満たすものは在る
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an a element in the document tree whose root is document that has a name attribute whose value is equal to fragment, then return the first such element in tree order.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

				</section>
				<section id="persisted-user-state-restoration">
<h5 title="Persisted history entry state">7.4.6.5. 持続される履歴~entry状態</h5>

<div class="algo">
<p>
`履歴~entryに持続される状態を保存する@
~algoは、
所与の
( `~session履歴~entry$ %~entry )
に対し：
◎
To save persisted state to a session history entry entry:
</p>
<ol>
	<li>
%~entry の`~scroll位置~data$shEを［
%~entry の`文書$shEの`復旧-可能な~scroll可能な領域$doc
］すべての~scroll位置を包含するように設定する
◎
Set the scroll position data of entry to contain the scroll positions for all of entry's document's restorable scrollable regions.
</li>
	<li>
任意選択で
⇒
~UAが持続するよう望む状態
— 各~form欄の値など —
があれば、
それらを反映するよう，
%~entry の`持続される利用者~状態$shEを更新する
◎
Optionally, update entry's persisted user state to reflect any state that the user agent wishes to persist, such as the values of form fields.
</li>
</ol>
</div>

<div class="algo">
<p id="restore-persisted-user-state">
`履歴~entryから持続された状態を復旧する@
~algoは、
所与の
( `~session履歴~entry$ %~entry )
に対し：
◎
To restore persisted state from a session history entry entry:
</p>
<ol>
	<li>
<p>
~IF［
%~entry の`~scroll復旧~mode$shE ~EQ `auto$l
］~AND［
%~entry の`文書$shEに`関連な大域~obj$の`~navi~API$の`進行中の~naviの間は通常の~scroll復旧を抑止するか$ ~EQ ~F
］
⇒
`~scroll位置~dataを復旧する$( %~entry )
◎
If entry's scroll restoration mode is "auto", and entry's document's relevant global object's navigation API's suppress normal scroll restoration during ongoing navigation is false, then restore scroll position data given entry.
</p>

<p class="note">注記：
~UAが~scroll位置を復旧しないことは、［
~scroll位置を特定0の値（例： (0,0) ）に~~保つ
］ことは含意しない。
実際の~scroll位置は、［
~navi種別／~UAによる~cache用の策
］に依存する。
なので、
~web~appは，特定0の~scroll位置に決まるとは見做せない
— ~appには、
自身が求めるものに設定することが督促される。
◎
The user agent not restoring scroll positions does not imply that scroll positions will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.
</p>

<p class="note">注記：
それでも，［
`進行中の~naviの間は通常の~scroll復旧を抑止するか$ ~EQ ~T
］の場合、
後の時点で`~scroll位置~dataを復旧する$ことは起こるかもしれない
— 関連な `NavigateEvent$I に対し［
それを`完遂する＠~HTMLnavAPI#navigateevent-finish$ときの一部として／
その `scroll()＠~HTMLnavAPI#dom-navigateevent-scroll$c【！navigateEvent.scroll()】 ~method~callを介して
］。
◎
If suppress normal scroll restoration during ongoing navigation is true, then restoring scroll position data might still happen at a later point, as part of finishing the relevant NavigateEvent, or via a navigateEvent.scroll() method call.
</p>
	</li>
	<li>
<p>
任意選択で
⇒
%~entry の`文書$shE, その具現化を成す他の側面を更新する
— 一例として、
~UAが以前に %~entry の`持続される利用者~状態$shE内に記録した~form欄の値など。
◎
Optionally, update other aspects of entry's document and its rendering, for instance values of form fields, that the user agent had previously recorded in entry's persisted user state.
</p>

<p class="note">注記：
持続される状態が，そのような~control内に利用者~入力の書字方向性を含む場合、
これには，次に該当する要素の `dir$a 属性を更新することも含まれる
⇒
`textarea$e 要素 ／
次を満たす `input$e 要素
⇒
その `type$a 属性の状態 ~IN { `Text$st, `Search$st, `Tel$st, `Url$st, `Email$st }
◎
This can even include updating the dir attribute of textarea elements or input elements whose type attribute is in the Text, Search, Telephone, URL, or Email state, if the persisted state includes the directionality of user input in such controls.
</p>

<p class="note">注記：
この処理nの一部として，~form~controlの値を復旧しても、［
`input$et ／ `change$et
］~eventは発火されないが，
`~formに所有され得る~custom要素$の
`formStateRestoreCallback^c は誘発され得る。
◎
Restoring the value of form controls as part of this process does not fire any input or change events, but can trigger the formStateRestoreCallback of form-associated custom elements.
</p>
	</li>
</ol>
</div>

<hr>

<p>
各`文書$ %文書 には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`利用者により~scrollされたか@doc
⇒
真偽値をとり，初期~時は ~F とする。
利用者が %文書 を~scrollした時点で、
~UAは， %文書 の`利用者により~scrollされたか$docを ~T に設定するモノトスル。
◎
Each Document has a boolean has been scrolled by the user, initially false. If the user scrolls the document, the user agent must set that document's has been scrolled by the user to true.
</li>
	<li>
`復旧-可能な~scroll可能な領域@doc
⇒
%文書 の`表示域$, および［
%文書 の`~navigable容器$を除く，
%文書 内の各~scroll可能な領域【例：~CSSによる`~scroll可能な~overflow区画$】
］すべてからなる。
◎
The restorable scrollable regions of a Document document are document's viewport, and all of document's scrollable regions excepting any navigable containers.
</li>
</ul>

<p class="note">注記：
`子~navigable$たちに対する~scrollの復旧は、［
それらの`文書$用の`~session履歴~entry$
］用の状態を復旧する一部として取扱われる。
◎
Child navigable scroll restoration is handled as part of state restoration for the session history entry for those navigables' Documents.
</p>

<div class="algo">
<p>
`~scroll位置~dataを復旧する@
~algoは、
所与の
( `~session履歴~entry$ %~entry )
に対し：
◎
To restore scroll position data given a session history entry entry:
</p>
<ol>
	<li>
%文書 ~LET %~entry の`文書$shE
◎
Let document be entry's document.
</li>
	<li>
~UAは、
次を遂行するベキである
⇒
~IF［
%文書 の`利用者により~scrollされたか$doc ~EQ ~T
］
⇒
~RET
◎
If document's has been scrolled by the user is true, then the user agent should return.
</li>
	<li>
<p>
~UAは、
次を遂行するベキである
⇒
%~entry の`~scroll位置~data$shEを利用して，
%~entry の`文書$shEの`復旧-可能な~scroll可能な領域$docの各~scroll位置を復旧しようと試みる
— ［
%文書 の`利用者により~scrollされたか$doc ~EQ ~T
］になるまでは、
この試みを周期的に継続してもヨイ
◎
The user agent should attempt to use entry's scroll position data to restore the scroll positions of entry's document's restorable scrollable regions. The user agent may continue to attempt to do so periodically, until document's has been scrolled by the user becomes true.
</p>

<p class="note">注記：
これが，成功するか利用者が~scrollするまで繰返され得る`試み^emとして定式化されているのは、
`~scroll位置~data$shEにより指示される関連な内容は，
~networkから読込むまで時間がかかるかもしれない事に因る。
◎
This is formulated as an attempt, which is potentially repeated until success or until the user scrolls, due to the fact that relevant content indicated by the scroll position data might take some time to load from the network.
</p>

<p class="note">注記：
~scroll位置の復旧は、
~scroll~anchor法 `CSSSCROLLANCHORING$r により影響されるかもしれない。
◎
Scroll restoration might be affected by scroll anchoring. [CSSSCROLLANCHORING]
</p>
	</li>
</ol>
</div>

				</section>
			</section>
		</section>
</main>

