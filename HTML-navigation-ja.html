<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Browsing the Web（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'browsing-the-web',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん？]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'coop':
case 'coep':
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 'hm': // HTTP method
	text = `\`<code class="method">${key}</code>\``;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'sf': // structured fields
	text = `<sub>sf-</sub>${text}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2021-04-07
trans_update:2021-04-12
source_checked:210301
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/browsing-the-web.html
	abbr_url:NAVI
site_nav:browsers,network,html
nav_prev:HISTORY
nav_next:WAPI
trans_1st_pub:2017-01-01


●●class_map
e:element
a:attr
et:event-type
sc:scheme
E:error
dir:directive
ps:pseudo
jv:js-value
sl:js-slot
jA:abstract
jT:js-type
v:value
hst:status

●●tag_map
I:code
m:code
c:code
e:code
a:code
sc:code
et:code
E:code
dir:code
ps:code
sl:span
jA:span
jv:code
jT:code
hst:code
v:code
V:var
i:i
hH:i
sub:sub
cite:cite

●●original_urls
offline:https://html.spec.whatwg.org/multipage/offline.html

●●words_table

	●network／保安／navi
TLS:
DNS:
Content-Type:
X-Frame-Options:
HTTP_S:HTTP(S) 
COOP:
	~COOP:coop
Location:
mail::::メール
payload::::ペイロード
caching-strategy:caching strategy:::キャッシュ方策
disposition:
	~navigate法:navigating
	~network用:networking
load:
unload:
	~unload法:unloading:
部位:part:~
refresh:
強制d:forced:強制
	~secure化:secured
非冪等:non-idempotent:~
	阻止される^i:Blocked
	許容される^i:Allowed
強制的:forcible:~
悪用-:exploit:~
騙す:trickする:~
危険:dangerous:~
flags:::flag 群:フラグ群
施行n:enforcement::施行
	同一-生成元かどうか:same-originness

	●環境 ／ 閲覧
id:
agent:
iframe:
標的:target::~::ターゲット
補助:auxiliary::~
閲覧:browsing::~
	生成元が類似な:similar-origin
埋込元:embedder::埋め込み元
再読込み:reload::再読み込み::リロード
	-:component
成熟-:mature::~
現任の:incumbent:~

辿る:traverseする::~
辿った:traverseした::~
辿り:traversal::~
族:family::~
回復可能:salvage 可能:~
	回復可能でな:unsalvageable
閉じる:closeする::~
開く:openする::~
opener:::open 元
open:
切替n:switch:切り替え
未所有化:disowned::~

	-:delta
	-:jump

	●IDL / js / event
欄:field::~::フィールド
中途完了:abrupt completion::~

	●データ／構文／操作
EOF:
	LF
	LINE FEED
Record:
BOM:
hash:
percent-::: %-
tokenizer:::token 化器:トークン化器:トークナイザ
整形式性:well-formedness::~
下位型:subtype::~
同等:equal::~

作成時の:creation::~
解析器:parser::~::パーサ
直列形の:serialized::~::シリアル形の
同型:isomorphic::~
和集合:union::~
分割-:split:~
区切られ:delimitされ:~
形:form:~

	●一般処理
片付け:cleanup::~
timer::::タイマー
準備度:readiness:~
増分的:incremental:~
静止-:pause:~
続行-:proceed:~
変化あり:changed:~
持続-:persist:~
復旧-:restore::~
復旧:restoration::~
最終-:final:~
params::::パラメタ群
処置先:disposition::~
生存-:alive::~
	生存し続け:keep 〜 alive
宛先:target:~

	-:step labeled
	取消されても:cancelation
	中止-法:aborting
	再び呼出す:reinvoke
	他を阻まない:non-blocking
	最終的に:eventual
	最終的に:ultimately
	渡-:pass
	以降:onward
	終わらす:finish
	もしあれば:If the current entry ... removed.
	~call元:caller

	●UI
	右~click:right-click
	media::::メディア
modal::::モーダル
prompt:
scrolling::::スクロール処理
書字方向性:directionality::~
逐次的:sequential:~
開始位置:beginning:~
始点:starting point:~
autofill:
一過:transient::~
非一過:sticky::~
領域:region:~

	●仕様
選択肢:option:~:::オプション
外部的:external:~
自立的:stand-alone:~
在来の:preexisting:~
整合的に:consistent mannerで:~
固守:adherence:~
白紙状態:clean slate:~
確認-:confirm:~
確認:confirmation:~
	（確認を）とる:ask
	食い違いが生じる:disagree
拒否-:refuse:~
手渡す:hand offする:取り扱わせる
	適切に手渡す:perform the appropriate handoff of
究明:investigation:~
注目:attention:~
判定-:judge:~
	-:defer
指名-:designate:~
意向:intention:~
細やか:granular:~
変種:variant:~
役割:role:~
直面-:face:~
	直面-:in the face of

	actually
	-:default
	でき:possible
	なければその前に:potentially before
	ほぼ間違いなく:certainly
	他にない:nothing conspires
	同じものを与える下で:setup
	対になる:for that matter
	いらつく／紛らわしい／的外れである: annoying, deceptive, or pointless
	そうな:likely
	~~真の:real
	担当:responsible／responsibility
	:optionally
	今の所は:in the meantime
	両立:simultaneously
	〜性:〜ness
	-:decide
	関心を失った:no longer interested in:
	かいくぐる:evade
	ことにされた:supposed
	ことになった場合:face
	するよりも，~~寛容でない:are less permissive compared to doing 〜 instead
	選ぶ:choose
	したい所:hope
	-:threaded through
	指すもの:pointer
	割かれる:concerned with
	なり得る:potentially
	課され:impose
	結果になる:conclude
	~~指定していない:not prepared
	処する:deal with
	取って代わる:supersede
	紛らわしく:confused
	許容されない:disallowed
	示す:illustrate
	生じさせ:causing
	のままで:stay

	●未分類
計時情報:timing info::~
高分解能:high resolution::~
合成-:synthesize::~
表示中:showing:~
消滅-:disappear:~
埋めた:fillした:~
切替えた:switchした:切り替えた
折返す:wrapする:折り返す
発した:emitした:~
iframe-srcdoc:iframe srcdoc
table
	PI
	POST:
PLAINTEXT:
古典:classic::~::クラシック
id:
feed-viewer::::配信ビューア
offline::::オフライン
package::::パッケージ
	multipart
連続的:contiguous:~

	-:store
	登録-済み:registered
	引く:brought
	待たれる:pending
	引用用の:quoting
		成す:comprise
	消え去る:going away
	終え:finish:
	間に挟む:intervening
	戻-:back
	結果を得る:dereference
	-:mark
	量:amount
	-:parameter
	Atom
	seamless:
	time:
	word processor
	~unload中の~openは無視する:ignore-opens-during-unload
	現れる:appearする
	表:table
	当の外部~software:target software

	●変数
X:
旧-:old:~
新-:new:~
	`S$V:sourceBrowsingContext
	%B:browsingContext
	%~navi~params:navigationParams
	%~navi~COOP:navigationCOOP
	%~navi種別:navigationType
	%~sandbox~flags:sandboxFlags
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%作動中の文書の~navi生成元:activeDocumentNavigationOrigin
	%内容~型:contentType
	%応答の~COOP:responseCOOP
	%~COOP:coop
	%~COOP施行n結果:coopEnforcementResult
	%応答の生成元:responseOrigin
	-:responseRequiresBrowsingContexGroupSwitch（誤）
	-:responseRequiresBrowsingContextGroupSwitch
	%最終-~sandbox~flags:finalSandboxFlags
	%最終-応答~生成元:finalResponseOrigin
	%現任の~navi生成元:incumbentNavigationOrigin
	%現在の~URL:currentURL
	%親~環境:parentEnvironment
	%~X~frame~options:xFrameOptions
	%生~X~frame~options:rawXFrameOptions
	%応答:response
	%行先~生成元:destinationOrigin
	%施策:policy
	%値:value
	%容器~文書:containerDocument
	%容器~閲覧文脈:containerBC
	%生成元~agent~clusterを要請する:requestsOAC
	%生成元~agent~cluster~header:oacHeader
	%新たな文書:newDocument
	%旧-文書:oldDocument
	%新たな~entry:newEntry
	%~hashは変化した:hashChanged
	%明示的な履歴~navi:explicitHistoryNavigation
	%履歴の取扱い:historyHandling
	%宛先~realm:targetRealm
	%旧-~URL:oldURL
	%新-~URL:newURL
	%状態は変化した:stateChanged
	%~eventは他を阻まない:nonBlockingEvents
	-:entryToUpdate
	-:entriesToUpdate
	%現在の文脈は~sourceか？:currentContextIsSource
	%~session履歴:sessionHistory
	%~downloadは許容される:allowedToDownload
	%一過な作動化:hasTransientActivation
	%~unload計時情報:unloadTimingInfo
	%前-文書:previousDocument
	%非同一-生成元~redirectあり？:hasCrossOriginRedirects

	●指示語
最近の:latest:~
	aforementioned
	続けて:in a row
	以前の:previous
	すでに:previously
	先頭の:leading
	前もって:prior
	前／後:back or forwards
	-:earlier
	最初に:in the first place
	箇所:place
	:two
	何らかの:some sort of
	かなりの部分:much of
	次:next
	ここ:this point
	1 個の:lone


●●words_table1

about_blank:about:blank
mailto_:mailto:
javascript_:javascript:

src-embed:src
src-iframe:src
src-img:src
src-media:src

	javascript:<code class="scheme">javascript:</code>

●●original_id_map

	number-of-document-tree-child-browsing-contexts:number-of-child-browsing-contexts
	restore-persisted-state:restore-persisted-user-state

●●mdn_urls
beforeunloadevent:API/BeforeUnloadEvent
hashchangeevent:API/HashChangeEvent
	hashchangeeventinit:API/HashChangeEventInit
pagetransitionevent:API/PageTransitionEvent
	pagetransitioneventinit:API/PageTransitionEventInit
popstateevent:API/PopStateEvent
	popstateeventinit:API/PopStateEventInit

●●link_map

	●idl
E.SecurityError:~WEBIDL#securityerror

I.DOMException:~WEBIDL#idl-DOMException
I.WebSocket:~WEBSOCKET#websocket
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventSource:~HTMLsse#eventsource
I.History:~HISTORY#history-3
I.WebSocket:~WEBSOCKET#websocket
I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy
	I.Document:~HTMLdom#document → 文書
~window:~WINDOW#the-window-object
文書:~HTMLdom#the-document-object

I.BeforeUnloadEvent:#beforeunloadevent
I.HashChangeEvent:#hashchangeevent
I.HashChangeEventInit:#hashchangeeventinit
I.PageTransitionEvent:#pagetransitionevent
I.PageTransitionEventInit:#pagetransitioneventinit
I.PopStateEvent:#popstateevent
I.PopStateEventInit:#popstateeventinit

I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest

m.cancelable:~DOM4#dom-event-cancelable
m.document.domain:~ORIGIN#dom-document-domain
m.location.assign:~HISTORY#dom-location-assign
m.newURL:#dom-hashchangeevent-newurl
m.oldURL:#dom-hashchangeevent-oldurl
m.persisted:#dom-pagetransitionevent-persisted
m.preventDefault:~DOM4#dom-event-preventdefault
m.pushState:~HISTORY#dom-history-pushstate
m.replaceState:~HISTORY#dom-history-replacestate
m.returnValue:#dom-beforeunloadevent-returnvalue
m.state:#dom-popstateevent-state
m.type:~DOM4#dom-event-type
m.window.open:~WINDOW#dom-window-open
m.opener:~BROWSERS#dom-window-opener

l.auto:~HISTORY#dom-scrollrestoration-auto
l.navigate:~NAV-TIMING#dom-navigationtype-navigate
l.reload:~NAV-TIMING#dom-navigationtype-reload
l.back_forward:~NAV-TIMING#dom-navigationtype-back_forward

et.abort:~HTMLindex#event-abort
et.beforeunload:~HTMLindex#event-beforeunload
et.hashchange:~HTMLindex#event-hashchange
et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.popstate:~HTMLindex#event-popstate
et.unload:~HTMLindex#event-unload

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.a:~HEtextlevel#the-a-element
e.input:~HEinput#the-input-element
e.script:~HEscripting#the-script-element
e.textarea:~HEforms#the-textarea-element

e.img:~HEimages#the-imge-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element

a.autoplay:~HEmedia#attr-media-autoplay
a.dir:~HTMLdom#attr-dir
a.href:~HTMLlinks#attr-hyperlink-href
a.name:~HTMLobs#attr-a-name
a.type:~HEinput#attr-input-type
a.~src-embed:~HEembed#attr-embed-src
a.~src-iframe:~HEembed#attr-iframe-src
a.~src-img:~HEimages#attr-img-src
a.~src-media:~HEmedia#attr-media-src

sc.~about_blank:~HTMLdep#about:blank
sc.~mailto_:~RFCx/rfc6068#section-2
sc.~javascript_:#javascript-protocol
l.javascript:#javascript-protocol

hst.204:~HTTPsem#status.204
	~RFC7231#section-6.3.5
hst.205:~HTTPsem#status.205
	~RFC7231#section-6.3.6

dir.frame-ancestors:~CSP3#frame-ancestors

c.application/atom+xml:~HTMLindex#application/atom+xml
c.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
c.text/css:~HTMLindex#text/css
bl.text/html:~HTMLiana#text/html
c.text/plain:~RFCx/rfc2046#section-4.1.3
c.text/vtt:~HTMLindex#text/vtt

h.Content-Type:~HTTPsem#field.content-type
h.Content-Disposition:~RFCx/rfc6266
h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
	https://w3c.github.io/webappsec-referrer-policy/#referrer-policy-header-dfn
h.Refresh:~HTMLiana#refresh
h.X-Frame-Options:~HTMLiana#x-frame-options
h.Origin-Agent-Cluster:~HTMLiana#origin-agent-cluster

v.off:~HTMLautofill#attr-fe-autocomplete-off
ps.target:~HTMLselectors#selector-target

coop.unsafe-none:~ORIGIN#coop-unsafe-none
coep.unsafe-none:~ORIGIN#coep-unsafe-none


	●用語
なければその前に:#_potentially-before

~source閲覧文脈:#source-browsing-context
	%S:#source-browsing-context
~navi~params:#navigation-params
nvP.閲覧文脈:#navigation-params-browsing-context
nvP.要請:#navigation-params-request
nvP.応答:#navigation-params-response
nvP.生成元:#navigation-params-origin
nvP.最終-~sandbox~flag集合:#navigation-params-sandboxing
nvP.非同一-生成元~opener施策:#navigation-params-coop
nvP.~COOP施行n結果:#navigation-params-coop-enforcement-result
nvP.予約-済み環境:#navigation-params-reserved-environment
nvP.履歴~取扱い:#navigation-params-hh
nvP.非同一-生成元~redirectあり？:#navigation-params-has-cross-origin-redirects

履歴を取扱うときの挙動:#history-handling-behavior
i.既定:#hh-default
i.~entry更新:#hh-entry-update
i.再読込み:#hh-reload
i.置換-:#hh-replace

~navigate:#navigate
~navi:#navigate
~navigate応答を処理する:#process-a-navigate-response
~navigate~fetchを処理する:#process-a-navigate-fetch
~navigate~URL~schemeを処理する:#process-a-navigate-url-scheme
自己~naviを明示的に上書き:#explicit-self-navigation-override
素片へ~navigateする:#navigate-fragid
素片へ~scrollしようと試行する:#try-to-scroll-to-the-fragment
素片へ~scrollする:#scroll-to-the-fragment-identifier
外部~softwareに手渡す:#hand-off-to-external-software

履歴を辿る:#traverse-the-history
明示的に~supportされる~JSON~MIME型:#explicitly-supported-json-mime-type
明示的に~supportされる~XML~MIME型:#explicitly-supported-xml-mime-type

成熟した:#concept-navigate-mature
~plugin文書:#plugin-document
標的~要素:#target-element
終了n入子ng~level:#termination-nesting-level

i.非~文書~内容として取扱う:#navigate-non-Document
指示された要素を見出す:#find-a-potential-indicated-element

doc.指示された部位:#the-indicated-part-of-the-document
doc.~page表示中~flag:#page-showing
doc.回復可能~状態:#concept-document-salvageable
回復可能:#concept-document-salvageable
文書を中止する:#abort-a-document
文書を中止-:#abort-a-document
文書の読込ngを停止する:#stop-document-loading
文書を作成して初期化する:#initialise-the-document-object
作成して初期化-:#initialise-the-document-object

完全に読込まれた:#completely-loaded
完全に読込まれた時刻:#completely-loaded-time
読込ngを完全に終わらす:#completely-finish-loading
文書を~unloadする:#unload-a-document
文書を~unload:#unload-a-document
文書の~unloadを~promptする:#prompt-to-unload-a-document
~unloadは利用者から拒否された:#refused-to-allow-the-document-to-be-unloaded
文書~unload時の片付け手続き:#unloading-document-cleanup-steps
~unload中の文書の可視性~変化-時の手続き:#unloading-document-visibility-change-steps

新たな~pageで~session履歴を更新する:#update-the-session-history-with-the-new-page
~session履歴~文書の可視性を変更する手続き:#session-history-document-visibility-change-steps

V.履歴~取扱い:#navigation-hh
i.履歴~取扱い:#navigation-hh
V.履歴の取扱い:#traverse-history-hh
i.履歴の取扱い:#traverse-history-hh
V.~navi種別:#navigation-navigationtype
V.例外を可能化する:#exceptions-enabled
V.~eventは他を阻まない:#nonblockingevents
i.~eventは他を阻まない:#nonblockingevents
V.明示的な履歴~navi:#explicithistorynavigation


持続された状態を復旧する:#restore-persisted-state
持続される状態を保存する:#save-persisted-state
復旧-可能な~scroll可能な領域:#restorable-scrollable-regions

~inline内容を表示する:#read-ua-inline

~HTML文書が読込まれる:#navigate-html
	#read-html
	#read-xml
	#read-plugin
	#read-media
	#read-text
	~HISTORY#history-notes
	#navigate-fragid-step
	#read-multipart-x-mixed-replace

~navi応答の~X-Frame-Optionsに対する固守を検査する:#check-a-navigation-response's-adherence-to-x-frame-options


	●用語（HTML

即時:~HTMLINFRA#immediately
並列的:~HTMLINFRA#in-parallel
~plugin:~HTMLINFRA#plugin
~secure化でき:~HTMLINFRA#concept-plugin-secure
~target上書き:~HTMLINFRA#concept-event-target-override
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications

~Content-Type~metadata:~HTMLurl#content-type
型~情報:~HTMLurl#content-type
	相対的に構文解析-:~HTMLurl#resolve-a-url
	結果の~URL~record:~HTMLurl#resulting-url-record
	~scheme~data:~HTMLurl#concept-url-scheme-data
	~HTML文書:~HTMLINFRA#html-documents

一過な作動化:~HTMLinteraction#transient-activation
非一過な作動化:~HTMLinteraction#sticky-activation


閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
親~閲覧文脈:~BROWSERS#parent-browsing-context
子~閲覧文脈:~BROWSERS#child-browsing-context
子孫~閲覧文脈~list:~BROWSERS#list-of-the-descendant-browsing-contexts
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
bc.容器:~BROWSERS#bc-container
容器~文書:~BROWSERS#bc-container-document
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈~名:~BROWSERS#browsing-context-name
閲覧文脈~視野~生成元:~BROWSERS#browsing-context-scope-origin
~load~event遅延-中:~BROWSERS#delaying-load-events-mode
作動中の文書:~BROWSERS#active-document
作動中の~window:~BROWSERS#active-window
閲覧文脈にて作動中の文書を設定する:~BROWSERS#set-the-active-document
~navigateすることは許容されて:~BROWSERS#allowed-to-navigate
作成-時:~BROWSERS#creating-a-new-browsing-context
文書~族:~BROWSERS#document-family
生成元を決定する:~BROWSERS#determining-the-origin
tbcG.~group:~BROWSERS#tlbc-group
未所有化~flag:~BROWSERS#disowned-its-opener

~window用に環境~設定群~objを設定しておく:~WINDOW#set-up-a-window-environment-settings-object
結付けられている文書:~WINDOW#concept-document-window
文書を破棄する:~WINDOW#discard-a-document

~session履歴:~HISTORY#session-history
~session履歴~entry:~HISTORY#session-history-entry
shE.~URL:~HISTORY#she-url
shE.文書:~HISTORY#she-document
shE.~scroll復旧~mode:~HISTORY#she-scroll-restoration-mode
shE.閲覧文脈~名:~HISTORY#she-bc-name
shE.持続される利用者~状態:~HISTORY#she-other
shE.直列形の状態:~HISTORY#she-serialized-state
shE.~scroll位置~data:~HISTORY#she-scroll-position
履歴を前／後に辿る:~HISTORY#traverse-the-history-by-a-delta
現在の~entry:~HISTORY#current-entry
最近の~entry:~HISTORY#latest-entry
hsT.状態:~HISTORY#concept-history-state

生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
sub.生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
不透明な生成元:~ORIGIN#concept-origin-opaque
bc.~sandbox法~flags:~ORIGIN#concept-bc-sandboxing-flags
~sandbox法~flag集合:~ORIGIN#sandboxing-flag-set
強制d~sandbox法~flag集合:~ORIGIN#forced-sandboxing-flag-set
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
~sandbox化( ~modal )~flag:~ORIGIN#sandboxed-modals-flag
閲覧文脈~sandbox化( ~plugin )~flag:~ORIGIN#sandboxed-plugins-browsing-context-flag
作成時の~sandbox法~flagsを決定する:~ORIGIN#determining-the-creation-sandboxing-flags
非同一-生成元~opener施策を得する:~ORIGIN#obtain-coop
非同一-生成元~opener施策:~ORIGIN#cross-origin-opener-policy
非同一-生成元~opener施策の施行n結果:~ORIGIN#coop-enforcement-result
cooP.閲覧文脈~groupの切替nは必要か？:~ORIGIN#coop-enforcement-bcg-switch
cooP.報告のみに因る閲覧文脈~groupの切替nは必要か？:~ORIGIN#coop-enforcement-bcg-switch-report-only
cooP.生成元:~ORIGIN#coop-enforcement-origin
cooP.非同一-生成元~opener施策:~ORIGIN#coop-enforcement-coop
cooP.~url:~ORIGIN#coop-enforcement-url
cooP.生成元:~ORIGIN#coop-enforcement-origin
cooP.現在の文脈は~navi~sourceか？:~ORIGIN#coop-enforcement-source
coOP.値:~ORIGIN#coop-struct-value

応答の非同一-生成元~opener施策を施行する:~ORIGIN#coop-enforce

閲覧文脈~groupの切替n:~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy

~navi応答の埋込元~施策に対する固守を検査する:~ORIGIN#check-a-navigation-response's-adherence-to-its-embedder-policy
~navi応答~用に利用する閲覧文脈を得する:~ORIGIN#obtain-browsing-context-navigation
埋込元~施策を得する:~ORIGIN#obtain-an-embedder-policy

sl.Window:~WINDOW#concept-windowproxy-window

~iframe~load~event手続き:~HEembed#iframe-load-event-steps

	●WAPI
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
現任の設定群~obj:~WAPI#incumbent-settings-object
生成元が類似な~window~agentを得する:~WAPI#obtain-similar-origin-window-agent
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
tK.文書:~WAPI#concept-task-document
~task~queue:~WAPI#task-queue
~task源:~WAPI#task-source
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
要素~taskを~queueする:~WAPI#queue-an-element-task
大域~taskを~queueする:~WAPI#queue-a-global-task
環境~設定群~obj:~WAPI#environment-settings-object
大域~obj:~WAPI#global-object
履歴~辿り~task源:~WAPI#history-traversal-task-source
~network用~task源:~WAPI#networking-task-source
~script:~WAPI#concept-script
静止-:~WAPI#pause
古典~scriptを作成する:~WAPI#creating-a-classic-script
古典~scriptを走らす:~WAPI#run-a-classic-script
既定の古典~script~fetch~options:~WAPI#default-classic-script-fetch-options

環境:~WAPI#environment
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.~id:~WAPI#concept-environment-id
enV.生成元:~WAPI#concept-settings-object-origin
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~secureな文脈:~WAPI#secure-context

環境を破棄する手続き:~WAPI#environment-discarding-steps
新たな~JS~realmを作成する:~WAPI#creating-a-new-javascript-realm

~unload中の~openは無視する~counter:~HTMLdynamic#ignore-opens-during-unload-counter
登録-済み~handler:~HTMLnavigator#dom-navigator-registerprotocolhandler


	●FETCH
~ABNF:~FETCH#abnf
~fetch~scheme:~FETCH#fetch-scheme
~HTTP_S~scheme:~FETCH#http-scheme
~fetch:~FETCH#concept-fetch
~HTTP~redirect~fetch:~FETCH#concept-http-redirect-fetch
~ok状態s:~FETCH#ok-status
有構造~headerを取得する:~FETCH#concept-header-list-get-structured-header
~header~list:~FETCH#concept-header-list
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split
応答を処理する:~FETCH#process-response
非同一-生成元~資源~施策~検査:~FETCH#cross-origin-resource-policy-check
要請:~FETCH#concept-request
~network~error:~FETCH#concept-network-error
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.~client:~FETCH#concept-request-client
rq.~referrer:~FETCH#concept-request-referrer
rq.~method:~FETCH#concept-request-method
rq.~mode:~FETCH#concept-request-mode
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.置換する~client~id:~FETCH#concept-request-replaces-client-id
rq.~target閲覧文脈:~FETCH#concept-request-target-browsing-context
rq.~URL:~FETCH#concept-request-url
rq.~URL~list:~FETCH#concept-request-url-list
rq.現在の~URL:~FETCH#concept-request-current-url
rq.予約-済み~client:~FETCH#concept-request-reserved-client
rq.生成元:~FETCH#concept-request-origin
rq.行先:~FETCH#concept-request-destination
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.再読込み~navi~flag:~FETCH#concept-request-reload-navigation-flag
rq.履歴~navi~flag:~FETCH#concept-request-history-navigation-flag
rq.利用者が作動化した:~FETCH#request-user-activation
rq.~redirect回数:~FETCH#concept-request-redirect-count

応答:~FETCH#concept-response
rs.~URL:~FETCH#concept-response-url
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.状態s:~FETCH#concept-response-status
rs.~CSP~list:~FETCH#concept-response-csp-list
rs.計時情報:~FETCH#concept-response-timing-info
~Location~URLを得る:~FETCH#concept-response-location-url

	●他HTML

doc.~referrer施策:~HTMLdom#concept-document-referrer-policy
doc.非同一-生成元~opener施策:~HTMLdom#concept-document-coop
doc.埋込元~施策:~HTMLdom#concept-document-embedder-policy
doc.~referrer:~HTMLdom#the-document's-referrer
doc.許可~施策:~HTMLdom#concept-document-permissions-policy
doc.現在の準備度:~HTMLdom#current-document-readiness
doc.~load計時情報:~HTMLdom#load-timing-info
doc.前-文書の~unload計時情報:~HTMLdom#previous-document-unload-timing
作動中の構文解析器:~HTMLdom#active-parser

文書~load計時情報:~HTMLdom#document-load-timing-info
文書~unload計時情報:~HTMLdom#document-unload-timing-info
~unload~event開始~時刻:~HTMLdom#unload-event-start-time
~unload~event終了~時刻:~HTMLdom#unload-event-end-time

共用~宣言的~refresh手続き:~HEmetadata#shared-declarative-refresh-steps

消滅させる:~WEBSOCKET#make-disappear
強制的に閉じる:~HTMLsse#concept-eventsource-forcibly-close

~HTML構文解析器:~HTMLparsing#html-parser
~PLAINTEXT状態:~HTMLparsing#plaintext-state
構文解析器を中止する:~HTMLparsing#abort-a-parser
~HTML構文解析器~内で:~HTMLparsing#parser-appcache
入力~byte~stream:~HTMLparsing#the-input-byte-stream
構文解析を停止した:~HTMLparsing#stop-parsing
停止-:~HTMLparsing#stop-parsing
~tokenizer:~HTMLparsing#tokenization

st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)

~objを~focusする:~HTMLinteraction#focusing-steps
逐次的~focus~naviの始点:~HTMLinteraction#sequential-focus-navigation-starting-point
利用者による作動化により誘発され:~HTMLinteraction#triggered-by-user-activation

~XML構文解析器:~HTMLxml#xml-parser
~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
	内容を具現化するのに失敗する:~HEembed#sandboxPluginEmbed

~form提出:~HTMLforms#concept-form-submit
再設定~algo:~HTMLforms#concept-form-reset-control
~autofill欄~名:~HTMLautofill#autofill-field-name

~downloadとして:~HTMLlinks#as-a-download
~hyperlinkを追う:~HTMLlinks#following-hyperlinks-2
~downloadは許容される:~HTMLlinks#allowed-to-download

具現化されて:~HTMLrendering#being-rendered
作動中の~timer~list:~HTMLGAPI#list-of-active-timers

作動中の構文解析器は中止された？:~HTMLdynamic#active-parser-was-aborted

	●外部
実装定義:~INFRA#implementation-defined

sub.大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
	~INFRA#string-is
同型に復号する:~INFRA#isomorphic-decode
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
付加する:~INFRA#list-append
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
和集合:~INFRA#set-union
~size:~INFRA#list-size

sf.真偽値:~HEADER-STRUCTURE#sf-boolean

~tree順序:~DOM4#concept-tree-order
~ID:~DOM4#concept-id
doc.内容~型:~DOM4#concept-document-content-type
doc.種別:~DOM4#concept-document-type
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
doc.文字~符号化法:~DOM4#concept-document-encoding
~tree内:~DOM4#in-a-document-tree
~eventを作成する:~DOM4#concept-event-create
配送する:~DOM4#concept-event-dispatch
~eventを発火する:~DOM4#concept-event-fire
取消d~flag:~DOM4#canceled-flag
~node文書:~DOM4#concept-node-document
文書~要素:~DOM4#document-element
局所~名:~DOM4#concept-element-local-name

~URLを直列化する:~URL1#concept-url-serializer
~URL:~URL1#concept-url
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
同等な~URL:~URL1#concept-url-equals
~URL~record:~URL1#concept-url
	素片は除外する:~URL1:#url-equals-exclude-fragments

~UTF-8復号する:~ENCODING#utf-8-decode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

疑似類:~SELECTORS4#pseudo-class
表示域:~CSS2VISUREN#viewport
~viewの中へ~scrollする:~CSSOMVIEW#scroll-an-element-into-view
開始位置へ~scroll:~CSSOMVIEW#scroll-to-the-beginning-of-the-document

~MIME型:~MIMESNIFF#mime-type
~JSON~MIME型:~MIMESNIFF#json-mime-type
~JS~MIME型:~MIMESNIFF#javascript-mime-type
~HTML~MIME型:~MIMESNIFF#html-mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
算出される~MIME型:~MIMESNIFF#computed-mime-type
資源から算出された~MIME型:#_computed-mime-type

文書の~CSP~listを初期化する:~CSP3#initialize-document-csp
ある種別の~navi要請は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-request
~targetにおける ある種別の~navi要請に対する応答は~CSPにより阻止されるべきか？:~CSP3#should-block-navigation-response
処置先:~CSP3#policy-disposition
指令~集合:~CSP3#policy-directive-set

応答から閲覧文脈~用の許可~施策を作成する:~PERMISSIONS-POLICY#create-from-response
~headerから~referrer施策を構文解析する:~REFERRER-POLICY#parse-referrer-policy-from-header
中途完了:~TC39#sec-completion-record-specification-type
現在の~Realm~Record:~TC39#current-realm
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize
jA.Type:~TC39#sec-ecmascript-data-types-and-values

~scroll容器:~CSSOVERFLOW3#scroll-container

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
~navi計時~entryを作成する:~NAV-TIMING#dfn-create-the-navigation-timing-entry

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Browsing the web</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1 title="Browsing the web">7.10. web の閲覧</h1>
	</hgroup>

</header>

<hr>

<main id="MAIN" hidden>

		<section id="browsing-the-web">
<h3 title="Browsing the web">7.10. ~webの閲覧</h3>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="navigating-across-documents">
<h4 title="Navigating across documents">7.10.1. 文書から文書への~navigate法</h4>

<p>
ある種の動作は、`閲覧文脈$を新たな資源へ`~navigate$させる。
~UAは、この仕様に定義されるそれに加えて，閲覧文脈を明示的に~navigateさせる様々な仕方を利用者~向けに供してもヨイ。
◎
Certain actions cause the browsing context to navigate to a new resource. A user agent may provide various ways for the user to explicitly cause a browsing context to navigate, in addition to those defined in this specification.
</p>

<p class="example">
例えば 次のものは、閲覧文脈を~navigateさせ得る
⇒＃
`~hyperlinkを追う$,
`~form提出$,
`window.open()$m ~method,
`location.assign()$m ~method
◎
For example, following a hyperlink, form submission, and the window.open() and location.assign() methods can all cause a browsing context to navigate.
</p>

<p class="note">注記：
資源を識別するために必要とされる情報は、資源の~URLのみに限られない。
例えば、~HTTP `POST^hm を利用する~form提出は、~HTTP［
~method, ~payload
］も情報として有することになる。
同様に，`~iframe-srcdoc文書$は、自身が利用する~dataを知る必要がある。
◎
A resource has a URL, but that might not be the only information necessary to identify it. For example, a form submission that uses HTTP POST would also have the HTTP method and payload. Similarly, an iframe srcdoc document needs to know the data it is to use.
</p>

<p>
~navi処理nのかなりの部分は、新たな`文書$をどう作成するか決定することに割かれる。
それは、最終的には，`作成して初期化-$する~algo内で起こる。
この~algoに渡す~parametersは、次に挙げる`~item$sctからなる`構造体$
`~navi~params@
を介して追跡される：
◎
Much of the navigation process is concerned with determining how to create a new Document, which ultimately happens in the create and initialize a Document object algorithm. The parameters to this algorithm are tracked via a navigation params struct, which has the following items:
</p>
<dl class="def-list">
	<dt>
`要請@nvP
◎
request
</dt>
	<dd>
~NULL ／ 当の~naviを開始した`要請$
◎
null or a request that started the navigation
</dd>

	<dt>
`応答@nvP
◎
response
</dt>
	<dd>
最終的な~navigate先を与える`応答$（`~network~error$にもなり得る）
◎
a response that ultimately was navigated to (potentially a network error)
</dd>

	<dt>
`生成元@nvP
◎
origin
</dt>
	<dd>
新たな`文書$用に利用する`生成元$
◎
an origin to use for the new Document
</dd>

	<dt>
`最終-~sandbox~flag集合@nvP
◎
final sandboxing flag set
</dt>
	<dd>
新たな`文書$に課される`~sandbox法~flag集合$
◎
a sandboxing flag set to impose on the new Document
</dd>

	<dt>
`非同一-生成元~opener施策@nvP
◎
cross-origin opener policy
</dt>
	<dd>
新たな`文書$用に利用される`非同一-生成元~opener施策$
◎
a cross-origin opener policy to use for the new Document
</dd>

	<dt>
`~COOP施行n結果@nvP
◎
COOP enforcement result
</dt>
	<dd>
`非同一-生成元~opener施策の施行n結果$
— 報告-用に利用され，`閲覧文脈~groupの切替n$を生じさせるためにも利用され得る。
◎
a cross-origin opener policy enforcement result, used for reporting and potentially for causing a browsing context group switch
</dd>

	<dt>
`予約-済み環境@nvP
◎
reserved environment
</dt>
	<dd>
~NULL ／ 新たな`文書$用に予約される`環境$
◎
null or an environment reserved for the new Document
</dd>

	<dt>
`閲覧文脈@nvP
◎
browsing context
</dt>
	<dd>
~navigateされる（あるいは、`閲覧文脈~groupの切替n$が生じた場合には，破棄される）ことになる`閲覧文脈$
◎
the browsing context to be navigated (or discarded, if a browsing context group switch occurs)
</dd>

	<dt>
`履歴~取扱い@nvP
◎
history handling
</dt>
	<dd>
`履歴を取扱うときの挙動$を与える。
◎
a history handling behavior
</dd>

	<dt>
`非同一-生成元~redirectあり？@nvP
◎
has cross-origin redirects
</dt>
	<dd>
真偽値
◎
a boolean
</dd>
</dl>

<p class="note">注記：
この標準においては、`~navi~params$を成す各`~item$sctは，作成-時から変異することはない
— 以降，他の~algoへ渡されるのみである。
◎
Once a navigation params struct is created, this standard does not mutate any of its items. They are only passed onward to other algorithms.
</p>

<p>
`~session履歴$は、`文書$が作成された後に更新される。
`履歴を取扱うときの挙動@
は、［
~navi処理nを全体を通して欲される，~session履歴~更新の種別
］を追跡するために利用され，次のいずれかを値にとる：
◎
After Document creation, the session history gets updated. A history handling behavior is used to track the desired type of session history update throughout the navigation process. It is one of the following:
</p>
<dl class="def-list">
	<dt>
`既定@i
◎
"default"
</dt>
	<dd>
定例の~navi
— ~session履歴に新たな~entryを追加する。
◎
A regular navigation which adds a new entry to the session history.
</dd>
	<dt>
`~entry更新@i
◎
"entry update"
</dt>
	<dd>
既存の`~session履歴~entry$への~navi
— その~entryの`文書$shEが，すでに<a href="~WINDOW#discard-a-document">破棄されて</a>いた場合に利用され、その文書を作成し直す。
◎
A navigation to an existing session history entry to recreate that entry's document, which was previously discarded.
</dd>
	<dt>
`再読込み@i
◎
"reload"
</dt>
	<dd>
現在の~pageを再読込みして，`現在の~entry$を置換することが意図される~navi。
◎
A navigation intended to reload the current page and replace the current session history entry.
</dd>
	<dt>
`置換-@i
◎
"replace"
</dt>
	<dd>
再読込みでないが，`現在の~entry$を置換することになる~navi。
◎
A non-reload navigation that will replace the current session history entry.
</dd>
</dl>

<p>
`~navi$には常に、
`~source閲覧文脈@
と呼ばれる，その開始を担当していた`閲覧文脈$が孕まれる。
◎
Navigation always involves source browsing context, which is the browsing context which was responsible for starting the navigation.
</p>

<p class="trans-note">【
すなわち、`~navigate$する~algoは，~source閲覧文脈を明示的に与えずに呼出されることもあるが、その場合でも，~source閲覧文脈は その箇所の文脈から暗黙的に指定される（例：要素から誘発される~naviにおける~source閲覧文脈は、要素の`~node文書$が`属する閲覧文脈$になろう）。
】</p>

<p class="XXX">
<a href="~HTMLissue/1130">課題 #1130</a>
にて説明されるように、閲覧文脈を~sourceとして利用するのは，正しい~architectureとは言えないかもしれない。
◎
As explained in issue #1130 the use of a browsing context as source might not be the correct architecture.
</p>

<div class="algo">
<div class="p">
<p>
`閲覧文脈$ %B を %資源 へ
`~navigate@
する~algoは、次も入力にとり，以下を走らすモノトスル：
</p>
<ul>
	<li>
真偽値
`例外を可能化する@V
（省略時は ~F ）
</li>
	<li>
`履歴を取扱うときの挙動$
`履歴~取扱い@V
（省略時は `既定$i ）
</li>
	<li>
文字列
`~navi種別@V
（省略時は `other^l ）
</li>
	<li>
`~source閲覧文脈$ %S
【上述したように、これは省略され得る】
</li>
</ul>

<p class="trans-note">【
以下，この節を通して、［
%S は`~source閲覧文脈$,
%B は~navigateされる`閲覧文脈$（`~navi~params$の`閲覧文脈$nvP）
］を意図して与えられた入力を表すことにする。
これらは、同じ閲覧文脈を指す場合もある。
】</p>

◎
To navigate a browsing context browsingContext to a resource resource, with an optional boolean exceptionsEnabled (default false), an optional history handling behavior historyHandling (default "default"), and an optional string navigationType (default "other"):
</div>
<ol>
	<li>
%~navi ~LET この`~navi$~algoの~instance
◎
↓</li>
	<li>
~IF［
%資源 は`~URL$である
］
⇒
%資源 ~SET 次のようにされた新たな`要請$
⇒
`~URL$rq ~SET %資源
◎
If resource is a URL, then set resource to a new request whose url is resource.
</li>
	<li>
~IF［
%資源 は`要請$である
］~AND［
%履歴~取扱い ~EQ `再読込み$i
］
⇒
%資源 の`再読込み~navi~flag$rq ~SET ~T
◎
If resource is a request and historyHandling is "reload", then set resource's reload-navigation flag.
</li>
	<li id="sandboxLinks">
<p>
~IF［
%S は， %B を`~navigateすることは許容されて$いない
］：
◎
If the source browsing context is not allowed to navigate browsingContext, then:
</p>
		<ol>
			<li>
~IF［
%例外を可能化する ~EQ ~T
］
⇒
~THROW `SecurityError$E
◎
If exceptionsEnabled is given and is true, then throw a "SecurityError" DOMException.
</li>
			<li>
<p>
~ELSE
⇒
~UAは、［［
新たな, または %S の
］`~top-level閲覧文脈$内に %資源 を開くような選択肢
］を利用者に提供してもヨイ
— その事例では、~UAは、利用者から指名された`~top-level閲覧文脈$を，利用者がそれを独立に要請したかのように %資源 へ`~navigate$するモノトスル。
◎
Otherwise, the user agent may instead offer to open resource in a new top-level browsing context or in the top-level browsing context of the source browsing context, at the user's option, in which case the user agent must navigate that designated top-level browsing context to resource as if the user had requested it independently.
</p>

<p class="note">注記：
しかしながら，そうすることは、危険にもなり得る
— それは、利用者が［
作者による，内容を~sandbox化する明示的な要請
］を上書きすることを意味するので。
◎
Doing so, however, can be dangerous, as it means that the user is overriding the author's explicit request to sandbox the content.
</p>

<p class="trans-note">【
選択肢を提供しない場合、（原文の “`instead^en” を “`SecurityError^E の代わりに” と解釈するなら）最初の段と同じく `SecurityError$E になると見受けられる。
】</p>

			</li>
		</ol>
	</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次のいずれも満たすような，［
%B を~navigateしようとする在来の %試み
］がある
］…：
</p>

<ul><li>%試み における`~source閲覧文脈$ ~EQ %B
</li><li>%試み は`文書を~unloadする$~algoを現在~走らせている
</li></ul>

<p>
…ならば
⇒
~RET
— %試み やそれが走らせている~algoは、影響されない。
</p>

◎
If there is a preexisting attempt to navigate browsingContext, and the source browsing context is the same as browsingContext, and that attempt is currently running the unload a document algorithm, then return without affecting the preexisting attempt to navigate browsingContext.
</li>
	<li>
~IF［
%文書 に対し，`文書の~unloadを~promptする$~algoが走っている
］
⇒
~RET
— その~algoは、影響されない。
◎
If the prompt to unload algorithm is being run for the active document of browsingContext, then return without affecting the prompt to unload algorithm.
</li>
	<li>
<p>
~IF［
%資源 は`要請$である
］：
◎
↓</p>
		<ol>
			<li>
%~URL ~LET %資源 の`~URL$rq
◎
↓</li>
			<li id="navigate-fragid-step">
~IF［
%履歴~取扱い ~NEQ `再読込み$i
］~AND［
( %~URL, %文書 の`~URL$doc )
は `素片は除外する^i 下で`同等な~URL$である
］~AND［
%~URL の`素片$url ~NEQ ~NULL
］
⇒＃
`素片へ~navigateする$( %B, %~URL, %履歴~取扱い )；
~RET
◎
If historyHandling is not "reload", resource is a request, resource's url equals browsingContext's active document's URL with exclude fragments set to true, and resource's url's fragment is non-null, then:
• Navigate to a fragment given browsingContext, resource's url, and historyHandling.
• Return.
</li>
			<li>
~IF［
`履歴の取扱い$V ~EQ `既定$i
］~AND［［
( %~URL, %文書 の`~URL$doc )
は`同等な~URL$である
］~OR［
%~URL の`~scheme$url ~EQ `javascript$l
］］
⇒
`履歴の取扱い$V ~SET `置換-$i
◎
If historyHandling is "default", resource is a request, and either resource's url equals browsingContext's active document's URL or resource's url's scheme is "javascript"', then set historyHandling to "replace".
</li>
		</ol>
	</li>
	<li>
%作動中の文書の~navi生成元 ~LET %B にて`作動中の文書$の`生成元$doc
◎
Let activeDocumentNavigationOrigin be the origin of the active document of browsingContext.
</li>
	<li>
%現任の~navi生成元 ~LET ［
%~navi には `script$e 【`~script$？】が孕まれるならば `現任の設定群~obj$の`生成元$enV【！`生成元$】 ／
~ELSE_ %~navi を起動した要素の`~node文書$の`生成元$doc
］
◎
Let incumbentNavigationOrigin be the origin of the incumbent settings object, or if no script was involved, the origin of the node document of the element that initiated the navigation.
</li>
	<li>
<p>
%B を~navigateしようとする在来の
~EACH( %試み )
に対し：
</p>
		<ol>
			<li>
~IF［
%試み はすでに`成熟した$
］
⇒
~CONTINUE
</li>
			<li>
%試み を取消す
— %試み により開始された`~fetch$ ~algoの~instanceも含めて
</li>
			<li>
~IF［
%試み は，すでに新たな`文書$を`作成して初期化-$した
］
⇒
`文書を中止する$( その文書 )
</li>
		</ol>

<p>
（`成熟した$ %試み に対しては、`~session履歴~entry$がすでにあるので，後で`新たな~pageで~session履歴を更新する$~algoの中で取扱われる。）
</p>

◎
Cancel any preexisting but not yet mature attempt to navigate browsingContext, including canceling any instances of the fetch algorithm started by those attempts. If one of those attempts has already created and initialized a new Document object, abort that Document also. (Navigation attempts that have matured already have session history entries, and are therefore handled during the update the session history with the new page algorithm, later.)
</li>
	<li>
<p>
`文書の~unloadを~promptする$( %文書 )
⇒
~IF［
%文書 の`~unloadは利用者から拒否された$
］
⇒
~RET
◎
Prompt to unload the active document of browsingContext. If the user refused to allow the document to be unloaded, then return.
</p>

<p>
この段を走らせている間に %~navi が取消されたとしても、`文書の~unloadを~promptする$~algoは，完了するモノトスル。
◎
If this instance of the navigation algorithm gets canceled while this step is running, the prompt to unload algorithm must nonetheless be run to completion.
</p>
	</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort the active document of browsingContext.
</li>
	<li>
<p>
~IF［
%B は`子~閲覧文脈$である
］：
</p>
		<ol>
			<li>
%B の`~load~event遅延-中$ ~SET ~T
</li>
			<li>
後に %~navi が［
`成熟した$ ／ 
すべて走らせ終えた ／
取消された ／
中止された
］時点
— いずれかが最初に生じた時点 —
で，次を走らすようにしておく
⇒
%B の`~load~event遅延-中$ ~SET ~F
</li>
		</ol>

◎
If browsingContext is a child browsing context, then put it in the delaying load events mode.
◎
The user agent must take this child browsing context out of the delaying load events mode when this navigation algorithm later matures, or when it terminates (whether due to having run all the steps, or being canceled, or being aborted), whichever happens first.
</li>
	<li>
%~sandbox~flags ~LET `作成時の~sandbox法~flagsを決定する$( %B, %B の`容器$bc )
◎
Let sandboxFlags be the result of determining the creation sandboxing flags given browsingContext and browsingContext's container.
</li>
	<li>
%~downloadは許容される ~LET `~downloadは許容される$( %S, %B )
◎
Let allowedToDownload be the result of running the allowed to download algorithm given the source browsing context and browsingContext.
</li>
	<li>
%一過な作動化 ~LET %S にて`作動中の~window$の`一過な作動化$
◎
Let hasTransientActivation be true if the source browsing context's active window has transient activation; otherwise false.
</li>
	<li>
~RET
— ただし、以降の手続きは`並列的$に継続する。
それは、必要とされるなら %資源 を得しようと試みる。
◎
Return to whatever algorithm invoked the navigation steps and continue running these steps in parallel.
◎
This is the step that attempts to obtain resource, if necessary. Jump to the first appropriate substep:
</li>
	<li>
<p>
~IF［
%資源 は`応答$である
］：
◎
If resource is a response
</p>
		<ol>
			<li>
~Assert：
%B は`~top-level閲覧文脈$でない。
◎
Assert: browsingContext is not a top-level browsing context.
</li>
			<li>
%最終-~sandbox~flags ~LET 次の`和集合$
⇒＃
%B の`~sandbox法~flags$bc,
%資源 の`強制d~sandbox法~flag集合$
◎
Let finalSandboxFlags be the union of browsingContext's sandboxing flags and resource's forced sandboxing flag set.
</li>
			<li>
%応答の生成元 ~LET `生成元を決定する$( 次に挙げる引数 )
⇒＃
%B,
%資源 の`~URL$rs,
%最終-~sandbox~flags,
%現任の~navi生成元,
%作動中の文書の~navi生成元
◎
Let responseOrigin be the result of determining the origin given browsingContext, resource's url, finalSandboxFlags, incumbentNavigationOrigin, and activeDocumentNavigationOrigin.
</li>
	<li>
%~COOP ~LET 新たな`非同一-生成元~opener施策$
◎
Let coop be a new cross-origin opener policy.
</li>
	<li>
%~COOP施行n結果 ~LET 次のようにされた新たな`非同一-生成元~opener施策の施行n結果$
⇒＃
`閲覧文脈~groupの切替nは必要か？$cooP ~SET ~F,
`報告のみに因る閲覧文脈~groupの切替nは必要か？$cooP ~SET ~F,
`~url$cooP ~SET %資源 の`~URL$rs,
`生成元$cooP ~SET %応答の生成元,
`非同一-生成元~opener施策$cooP ~SET %~COOP,
`現在の文脈は~navi~sourceか？$cooP ~SET ~F
◎
Let coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context group switch is false, would need a browsing context group switch due to report-only is false, url is resource's url, origin is responseOrigin, cross-origin opener policy is coop, and current context is navigation source is false.
</li>
	<li>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET %資源,
`生成元$nvP ~SET %応答の生成元,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flags,
`非同一-生成元~opener施策$nvP ~SET %~COOP,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`閲覧文脈$nvP ~SET %B,
`履歴~取扱い$nvP ~SET %履歴~取扱い,
`非同一-生成元~redirectあり？$nvP ~SET ~F
◎
Let navigationParams be a new navigation params whose request is null, response is resource, origin is responseOrigin, final sandboxing flag set is finalSandboxFlags, cross-origin opener policy is coop, COOP enforcement result is coopEnforcementResult, reserved environment is null, browsing context is browsingContext, history handling is historyHandling, and has cross-origin redirects is false.
</li>
	<li>
`~navigate応答を処理する$( %~navi種別, %~downloadは許容される, %一過な作動化, %~navi~params )
◎
Run process a navigate response with navigationType, allowedToDownload, hasTransientActivation, and navigationParams.
</li>
			<li>
~RET
◎
↓</li>
		</ol>
	</li>
	<li>
~Assert：
%資源 は`要請$である。
【この段は、この訳による補完。】
◎
↓</li>
	<li>
%~scheme ~LET %資源 の`~URL$rqの`~scheme$url
◎
↓</li>
	<li>
<p>
~IF［
%~scheme ~EQ `javascript$l
］：
◎
If resource is a request whose url's scheme is "javascript"
</p>
		<ol>
			<li>
<p>
次の手続きを走らす`大域~taskを~queueする$( `~DOM操作~task源$, %B にて`作動中の~window$ )：
◎
Queue a global task on the DOM manipulation task source given browsingContext's active window to run these steps:
</p>
				<ol>
					<li>
%応答 ~LET `~javascript_$sc ~URLによる要請を実行する( %資源, %S, %B )
◎
Let response be the result of executing a javascript: URL request given resource, the source browsing context, and browsingContext.
</li>
					<li>
%最終-~sandbox~flags ~LET 次の`和集合$
⇒＃
%B の`~sandbox法~flags$bc,
%応答 の`強制d~sandbox法~flag集合$
◎
Let finalSandboxFlags be the union of browsingContext's sandboxing flags and response's forced sandboxing flag set.
</li>
					<li>
%~COOP施行n結果 ~LET 次のようにされた新たな`非同一-生成元~opener施策の施行n結果$
⇒＃
`閲覧文脈~groupの切替nは必要か？$cooP ~SET ~F,
`報告のみに因る閲覧文脈~groupの切替nは必要か？$cooP ~SET ~F,
`~url$cooP ~SET %資源 の`~URL$rq,
`生成元$cooP ~SET %作動中の文書の~navi生成元,
`非同一-生成元~opener施策$cooP ~SET %B にて`作動中の文書$の`非同一-生成元~opener施策$doc,
`現在の文脈は~navi~sourceか？$cooP ~SET ~F
◎
Let coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context group switch is false, would need a browsing context group switch due to report-only is false, url is resource's url, origin is activeDocumentNavigationOrigin, cross-origin opener policy is browsingContext's active document's cross-origin opener policy, and current context is navigation source is false.
</li>
					<li>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET %資源,
`応答$nvP ~SET %応答,
`生成元$nvP ~SET %作動中の文書の~navi生成元,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flags,
`非同一-生成元~opener施策$nvP ~SET %B にて`作動中の文書$の`非同一-生成元~opener施策$doc,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`閲覧文脈$nvP ~SET %B,
`履歴~取扱い$nvP ~SET %履歴~取扱い,
`非同一-生成元~redirectあり？$nvP ~SET ~F
◎
Let navigationParams be a new navigation params whose request is resource, response is response, origin is activeDocumentNavigationOrigin, final sandboxing flag set is finalSandboxFlags, cross-origin opener policy is browsingContext's active document's cross-origin opener policy, COOP enforcement result is coopEnforcementResult, reserved environment is null, browsing context is browsingContext, history handling is historyHandling, and has cross-origin redirects is false.
</li>
					<li>
`~navigate応答を処理する$( %~navi種別, %~downloadは許容される, %一過な作動化, %~navi~params )
◎
Run process a navigate response with navigationType, allowedToDownload, hasTransientActivation, and navigationParams.
</li>
				</ol>

<p class="example">
よって，例えば `a$e 要素の `href$a 属性に対する `~javascript_$sc ~URLが評価されるのは、その`~hyperlinkを追う$ときに限られることになる。
一方で、 `iframe$e 要素 %E の `~src-iframe$a 属性における その種の~URLは、
%E が設定しておかれるときに， %E が`入子にしている閲覧文脈$ %C の文脈~下で評価される。
結果の返り値が文字列であったなら，
%C にて`作動中の文書$を置換する（したがって %C に対応している`~window$も変更する）ことになる。
◎
So for example a javascript: URL in an href attribute of an a element would only be evaluated when the link was followed, while such a URL in the src attribute of an iframe element would be evaluated in the context of the iframe's nested browsing context when the iframe is being set up. Once evaluated, its return value (if it was a string) would replace that browsing context's active document, thus also changing the corresponding Window object.
</p>
			</li>
		</ol>
	</li>
	<li>
~ELIF［
%~scheme は`~fetch~scheme$である
］
⇒
`~navigate~fetchを処理する$( 次に挙げる引数 )
⇒＃
%資源,
%S,
%B,
%~navi種別,
%~sandbox~flags,
%~downloadは許容される,
%一過な作動化,
%現任の~navi生成元,
%作動中の文書の~navi生成元,
%履歴~取扱い
◎
If resource is a request whose url's scheme is a fetch scheme
• Run process a navigate fetch given resource, the source browsing context, browsingContext, navigationType, sandboxFlags, allowedToDownload, hasTransientActivation, incumbentNavigationOrigin, activeDocumentNavigationOrigin, and historyHandling.
</li>
	<li>
~ELSE
⇒
`~navigate~URL~schemeを処理する$( %資源 の`~URL$rq, %B, %一過な作動化 )
◎
Otherwise, resource is a request whose url's scheme is neither "javascript" nor a fetch scheme
• Run process a navigate URL scheme given resource's url, browsingContext, and hasTransientActivation.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate~fetchを処理する@
ときは、所与の
⇒＃
`要請$ %要請,
`~source閲覧文脈$ %S,
`閲覧文脈$ %B,
文字列 %~navi種別,
`~sandbox法~flag集合$ %~sandbox~flags,
真偽値 %~downloadは許容される,
真偽値 %一過な作動化,
`生成元$ %現任の~navi生成元,
`生成元$ %作動中の文書の~navi生成元,
`履歴を取扱うときの挙動$ %履歴~取扱い
◎終
に対し，次を走らす：
◎
To process a navigate fetch, given a request request, two browsing contexts sourceBrowsingContext and browsingContext, a string navigationType, a sandboxing flag set sandboxFlags, a boolean allowedToDownload, a boolean hasTransientActivation, two origins incumbentNavigationOrigin and activeDocumentNavigationOrigin, and a history handling behavior historyHandling:
</p>
<ol>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%要請 の
⇒＃
`~client$rq ~SET %S にて`作動中の文書$に`関連な設定群~obj$,
`行先$rq ~SET `document^l,
`~mode$rq ~SET `navigate^l,
`資格証~mode$rq ~SET `include^l,
`~URL資格証~利用~flag$rq ~SET ~T,
`~redirect~mode$rq ~SET `manual^l,
`置換する~client~id$rq ~SET %B にて`作動中の文書$に`関連な設定群~obj$の`~id$enV
◎
Set request's client to sourceBrowsingContext's active document's relevant settings object, destination to "document", mode to "navigate", credentials mode to "include", use-URL-credentials flag, redirect mode to "manual", and replaces client id to browsingContext's active document's relevant settings object's id.
</li>
	<li>
~IF［
%一過な作動化 ~EQ ~T
］
⇒
%要請 の`利用者が作動化した$rq ~SET ~T
◎
If hasTransientActivation is true, then set request's user-activation to true.
</li>
	<li>
<p>
~IF［
%B の`容器$bc %容器 ~NEQ ~NULL
］：
◎
If browsingContext's container is non-null:
</p>
		<ol>
			<li>
~IF［
%容器 の`閲覧文脈~視野~生成元$ %O ~NEQ ε
］
⇒
%要請 の`生成元$rq ~SET %O
◎
If the browsingContext's container has a browsing context scope origin, then set request's origin to that browsing context scope origin.
</li>
			<li>
%要請 の`行先$rq ~SET %容器 の`局所~名$
◎
Set request's destination to browsingContext's container's local name.
</li>
		</ol>
	</li>
	<li>
%応答の生成元 ~LET ~NULL
◎
Let responseOrigin be null.
</li>
	<li>
%現在の文脈は~sourceか？ ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%B にて`作動中の文書$ ~EQ`生成元$sub %S にて`作動中の文書$
◎
Let currentContextIsSource be the result of whether browsingContext's active document is same origin with sourceBrowsingContext's active document.
</li>
	<li>
%~COOP施行n結果 ~LET 次のようにされた新たな`非同一-生成元~opener施策の施行n結果$
⇒＃
`閲覧文脈~groupの切替nは必要か？$cooP ~SET ~F,
`報告のみに因る閲覧文脈~groupの切替nは必要か？$cooP ~SET ~F,
`~url$cooP ~SET %B にて`作動中の文書$の`~URL~record$,
`生成元$cooP ~SET %B にて`作動中の文書$の`生成元$doc,
`非同一-生成元~opener施策$cooP ~SET %B にて`作動中の文書$の`非同一-生成元~opener施策$doc,
`現在の文脈は~navi~sourceか？$cooP ~SET %現在の文脈は~sourceか？
◎
Let coopEnforcementResult be a new cross-origin opener policy enforcement result whose needs a browsing context group switch is false, would need a browsing context group switch due to report-only is false, url is browsingContext's active document's url, origin is browsingContext's active document's origin, cross-origin opener policy is browsingContext's active document's cross-origin opener policy, and current context is navigation source is currentContextIsSource.
</li>
	<li>
%最終-~sandbox~flags ~LET 空な`~sandbox法~flag集合$
◎
Let finalSandboxFlags be an empty sandboxing flag set.
</li>
	<li>
%~Location~URL ~LET ~NULL
◎
Let locationURL be null.
</li>
	<li>
%現在の~URL ~LET %要請 の`現在の~URL$rq
◎
Let currentURL be request's current URL.
</li>
	<li>
%非同一-生成元~redirectあり？ ~LET ~F
◎
Let hasCrossOriginRedirects be false.
</li>
	<li>
<p id="navigate-redirect-step">
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
~IF［
%~Location~URL ~NEQ ~NULL
］：
◎
If locationURL is non-null, then:
</p>
				<ol>
					<li>
~IF［
%~Location~URL の`生成元$url
~NEQ`生成元$sub
%現在の~URL の`生成元$url
］
⇒
%非同一-生成元~redirectあり？ ~SET ~T
◎
If locationURL's origin is not the same as currentURL's origin, then set hasCrossOriginRedirects to true.
</li>
					<li>
%現在の~URL ~SET %~Location~URL
◎
Set currentURL to locationURL.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%要請 の`予約-済み~client$rq ~NEQ ~NULL
］~AND［
%現在の~URL の`生成元$url
~NEQ`生成元$sub
%要請 の`予約-済み~client$rq の`作成時の~URL$enVの`生成元$url
］：
◎
If request's reserved client is not null and currentURL's origin is not the same as request's reserved client's creation URL's origin, then:
</p>
				<ol>
					<li>
%要請 の`予約-済み~client$rq 用に`環境を破棄する手続き$を走らす
◎
Run the environment discarding steps for request's reserved client.
</li>
					<li>
%要請 の`予約-済み~client$rq ~SET ~NULL
◎
Set request's reserved client to null.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%要請 の`予約-済み~client$rq ~EQ ~NULL
］：
◎
If request's reserved client is null, then:
</p>
				<ol>
					<li>
%~top-level作成時の~URL ~LET %現在の~URL
◎
Let topLevelCreationURL be currentURL.
</li>
					<li>
%~top-level生成元 ~LET ~NULL
◎
Let topLevelOrigin be null.
</li>
					<li>
<p>
~IF［
%B は`~top-level閲覧文脈$でない
］：
◎
If browsingContext is not a top-level browsing context, then:
</p>
						<ol>
							<li>
%親~環境 ~LET %B の`容器$bcに`関連な設定群~obj$
◎
Let parentEnvironment be browsingContext's container's relevant settings object.
</li>
							<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL＼
</li>
							<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
and topLevelOrigin to parentEnvironment's top-level origin.
</li>
						</ol>
					</li>
					<li>
<p>
%要請 の`予約-済み~client$rq ~SET 次のようにされた新たな`環境$
⇒＃
`~id$enV ~SET 一意かつ不透明な文字列,
`~target閲覧文脈$enV ~SET %B,
`作成時の~URL$enV ~SET %現在の~URL,
`~top-level作成時の~URL$enV ~SET %~top-level作成時の~URL,
`~top-level生成元$enV ~SET %~top-level生成元
◎
Set request's reserved client to a new environment whose id is a unique opaque string, target browsing context is browsingContext, creation URL is currentURL, top-level creation URL is topLevelCreationURL, and top-level origin is topLevelOrigin.
</p>

<p class="note">注記：
ここで作成した環境の`作動中の~sw$enVは、要請~URLが~sw登録に合致するならば，~fetchの間に
<a href="~SW1#on-fetch-request-algorithm">~fetchを取扱う~algo</a>の中で設定される。
`SW$r
◎
The created environment's active service worker is set in the Handle Fetch algorithm during the fetch if the request URL matches a service worker registration. [SW]
</p>
					</li>
				</ol>
			</li>
			<li>
~IF［
`ある種別の~navi要請は~CSPにより阻止されるべきか？$( %要請, %~navi種別 )
`CSP$r
の結果 ~EQ `阻止される^i
］
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
If the result of Should navigation request of type be blocked by Content Security Policy? given request and navigationType is "Blocked", then set response to a network error and break. [CSP]
</li>
			<li>
~IF［
%応答 ~EQ ~NULL
］
⇒
%応答 ~SET %要請 を用いて`~fetch$した結果
◎
Otherwise:
◎
If response is null, fetch request.
</li>
			<li>
~ELSE
⇒
%応答 ~SET `~HTTP~redirect~fetch$( %要請, %応答 ) を遂行した結果
◎
Otherwise, perform HTTP-redirect fetch using request and response.
</li>
			<li>
`~network用~task源$上の［
%応答 に対し`応答を処理する$
］`~task$を待機する
◎
Wait for the task on the networking task source to process response and set response to the result.
</li>
			<li>
%最終-~sandbox~flags ~SET 次の`和集合$
⇒＃
%B の`~sandbox法~flags$bc,
%応答 の`強制d~sandbox法~flag集合$
◎
Set finalSandboxFlags to the union of browsingContext's sandboxing flags and response's forced sandboxing flag set.
</li>
			<li>
%応答の生成元 ~SET `生成元を決定する$( 次に挙げる引数 )
⇒＃
%B,
%要請 の`~URL$rq,
%最終-~sandbox~flags,
%現任の~navi生成元,
%作動中の文書の~navi生成元
◎
Set responseOrigin to the result of determining the origin given browsingContext, request's url, finalSandboxFlags, incumbentNavigationOrigin, and activeDocumentNavigationOrigin.
</li>
			<li>
<p>
~IF［
%B は`~top-level閲覧文脈$である
］：
◎
If browsingContext is a top-level browsing context, then:
</p>
				<ol>
					<li>
%応答の~COOP ~SET `非同一-生成元~opener施策を得する$( %応答, %要請 の`予約-済み~client$rq )
◎
Set responseCOOP to the result of obtaining a cross-origin opener policy given response and request's reserved client.
</li>
					<li>
<p>
~IF［
%~sandbox~flags は空でない
］~AND［
%応答の~COOP の`値$coOP ~NEQ `unsafe-none$coop
］
⇒＃
%応答 ~SET 適切な`~network~error$；
~BREAK
◎
If sandboxFlags is not empty and responseCOOP's value is not "unsafe-none", then set response to an appropriate network error and break.
</p>

<p class="note">注記：
この結果は~network~errorになる
— 非同一-生成元~opener施策を利用している応答に対し，［
白紙状態を供すること,
その応答へ~navigateした結果を~sandbox化すること
］は、両立し得ないので。
◎
This results in a network error as one cannot simultaneously provide a clean slate to a response using cross-origin opener policy and sandbox the result of navigating to that response.
</p>
					</li>
					<li>
%~COOP施行n結果 ~SET `応答の非同一-生成元~opener施策を施行する$( 次に挙げる引数 )
⇒＃
%B,
%要請 の`~URL$rq,
%応答の生成元,
%応答の~COOP,
%~COOP施行n結果,
%要請 の`~referrer$rq
◎
Set coopEnforcementResult to the result of enforcing the response's cross-origin opener policy given browsingContext, request's url, responseOrigin, responseCOOP, coopEnforcementResult and request's referrer.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
%B は`子~閲覧文脈$である
］：
◎
If response is not a network error, browsingContext is a child browsing context,＼
</p>
				<ol>
					<li>
%容器 ~LET %B の`容器~文書$
◎
↓</li>
					<li>
~IF［
`非同一-生成元~資源~施策~検査$( %容器 の`生成元$doc, %容器 に`関連な設定群~obj$, %要請 の`行先$rq, %応答, ~T )
~EQ `阻止される^i
］
⇒＃
%応答 ~SET `~network~error$；
~BREAK
◎
and the result of performing a cross-origin resource policy check with browsingContext's container document's origin, browsingContext's container document's relevant settings object, request's destination, response, and true is blocked, then set response to a network error and break.
</li>
				</ol>

<p class="note">注記：
ここでは
— ~naviの`~source閲覧文脈$（ %S ）ではなく —
%B の`親~閲覧文脈$に対し，埋込まれた内容が同一-生成元かどうか~careするので、
%容器 に対し，`非同一-生成元~資源~施策~検査$を走らす。
◎
Here we're running the cross-origin resource policy check against the parent browsing context rather than sourceBrowsingContext. This is because we care about the same-originness of the embedded content against the parent context, not the navigation source.
</p>
			</li>
			<li>
%~Location~URL ~LET `~Location~URLを得る$( %応答, %現在の~URL の`素片$url )
◎
Set locationURL to response's location URL given currentURL's fragment.
</li>
			<li>
~IF［
%~Location~URL は`~URL$であって，その`~scheme$urlは`~HTTP_S~scheme$である
］
⇒
~CONTINUE
◎
If locationURL is not a URL whose scheme is an HTTP(S) scheme, then break.
</li>
			<li>
~BREAK
◎
↑</li>
		</ol>

<p class="note">注記：
~naviは、~redirectを手動で取扱う。
~naviが、~web~platformにおいて `~mailto_$sc の類の~URLへの~redirectを~careする唯一の箇所なので。
◎
Navigation handles redirects manually as navigation is the only place in the web platform that cares for redirects to mailto: URLs and such.
</p>
	</li>
	<li>
~IF［
%~Location~URL ~EQ `失敗^i
］
⇒
%応答 ~SET `~network~error$
◎
If locationURL is failure, then set response to a network error.
</li>
	<li>
<p>
~ELIF［
%~Location~URL は`~URL$である
］
⇒
%~Location~URL の`~scheme$url に応じて：
</p>
		<dl class="switch">
			<dt>`blob^l</dt>
			<dt>`file^l</dt>
			<dt>`filesystem^l</dt>
			<dt>`javascript^l</dt>
			<dd>
%応答 ~SET `~network~error$
</dd>

			<dt>`~fetch~scheme$である</dt>
			<dd>
				<ol>
					<li>
%新~要請 ~LET 新たな`要請$
</li>
					<li>
%新~要請 の`~URL$rq ~SET %~Location~URL
</li>
					<li>
`~navigate~fetchを処理する$( 次に挙げる引数 )
⇒＃
%新~要請,
%S,
%B,
%~navi種別,
%~downloadは許容される,
%一過な作動化,
%~sandbox~flags,
%現任の~navi生成元,
%作動中の文書の~navi生成元,
%履歴~取扱い
</li>
					<li>
~RET
</li>
				</ol>
			</dd>

			<dt>その他</dt>
			<dd>
				<ol>
					<li>
`~navigate~URL~schemeを処理する$( %~Location~URL, %B )
</li>
					<li>
~RET
</li>
				</ol>
			</dd>
		</dl>

◎
Otherwise, if locationURL is a URL whose scheme is "blob", "file", "filesystem", or "javascript", then set response to a network error.
◎
Otherwise, if locationURL is a URL whose scheme is a fetch scheme, then run process a navigate fetch with a new request whose url is locationURL, sourceBrowsingContext, browsingContext, navigationType, allowedToDownload, hasTransientActivation, sandboxFlags, incumbentNavigationOrigin, activeDocumentNavigationOrigin, and historyHandling, and return.
◎
Otherwise, if locationURL is a URL, run the process a navigate URL scheme given locationURL and browsingContext, and return.
</li>
	<li>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET %要請,
`応答$nvP ~SET %応答,
`生成元$nvP ~SET %応答の生成元,
`最終-~sandbox~flag集合$nvP ~SET %最終-~sandbox~flags,
`非同一-生成元~opener施策$nvP ~SET %応答の~COOP,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET %要請 の`予約-済み~client$rq,
`閲覧文脈$nvP ~SET %B,
`履歴~取扱い$nvP ~SET %履歴~取扱い,
`非同一-生成元~redirectあり？$nvP ~SET %非同一-生成元~redirectあり？
◎
Let navigationParams be a new navigation params whose request is request, response is response, origin is responseOrigin, final sandboxing flag set is finalSandboxFlags, cross-origin opener policy is responseCOOP, COOP enforcement result is coopEnforcementResult, reserved environment is request's reserved client, browsing context is browsingContext, history handling is historyHandling, and has cross-origin redirects is hasCrossOriginRedirects.
</li>
	<li>
`~navigate応答を処理する$( %~navi種別, %~downloadは許容される, %一過な作動化, %~navi~params )
◎
Run process a navigate response with navigationType, allowedToDownload, hasTransientActivation, and navigationParams.
</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate応答を処理する@
ときは、所与の
( 文字列 %~navi種別, 真偽値 %~downloadは許容される, 真偽値 %一過な作動化, `~navi~params$ %~navi~params )
に対し，次を走らす：
◎
To process a navigate response, given a string navigationType, a boolean allowedToDownload, a boolean hasTransientActivation, and a navigation params navigationParams:
</p>
<ol>
	<li>
%応答 ~LET %~navi~params の`応答$nvP
◎
Let response be navigationParams's response.
</li>
	<li>
%B ~LET %~navi~params の`閲覧文脈$nvP
◎
Let browsingContext be navigationParams's browsing context.
</li>
	<li>
<p>
%失敗 ~LET 次の下位手続きを走らせた結果：
◎
Let failure be false.
</p>
		<ol>
			<li>
~IF［
%応答 は`~network~error$である
］
⇒
~RET ~T
◎
If response is a network error, then set failure to true.
</li>
			<li>
~IF［
`~targetにおける ある種別の~navi要請に対する応答は~CSPにより阻止されるべきか？$( %~navi~params の`要請$nvP, %~navi種別, %応答, %B )
【！原文は %~navi種別, %応答 の順序が逆】
~EQ `阻止される^i
］
`CSP$r
⇒
~RET ~T
◎
Otherwise, if the result of Should navigation response to navigation request of type in target be blocked by Content Security Policy? given navigationParams's request, response, navigationType, and browsingContext is "Blocked", then set failure to true. [CSP]
</li>
			<li>
~IF［
%~navi~params の`予約-済み環境$nvP ~NEQ ~NULL
］~AND［
`~navi応答の埋込元~施策に対する固守を検査する$( %応答, %B, %~navi~params の`予約-済み環境$nvP ) ~EQ ~F
］
⇒
~RET ~T
◎
Otherwise, if navigationParams's reserved environment is non-null and the result of checking a navigation response's adherence to its embedder policy given response, browsingContext, and navigationParams's reserved environment is false, then set failure to true.
</li>
			<li>
~IF［
`~navi応答の~X-Frame-Optionsに対する固守を検査する$( %応答, %B, %~navi~params の`生成元$nvP ) ~EQ ~F
］
⇒
~RET ~T
◎
Otherwise, if the result of checking a navigation response's adherence to `X-Frame-Options` given response, browsingContext, and navigationParams's origin is false, then set failure to true.
</li>
			<li>
~RET ~F
◎
↑↑</li>
		</ol>
	<li>
<p>
~IF［
%失敗 ~EQ ~T
］：
◎
If failure is true, then:
</p>
			<ol>
				<li>
`~inline内容を表示する$( %B )
◎
Display the inline content with an appropriate error shown to the user given browsingContext.
</li>
				<li>
%~navi~params の`予約-済み環境$nvP用に`環境を破棄する手続き$を走らす
◎
Run the environment discarding steps for navigationParams's reserved environment.
</li>
				<li>
~RET
◎
Return.
</li>
			</ol>

<p class="note">注記：
`Fetch^cite `FETCH$r
により定義される~network~error
— ~DNSや~TLS ~errorなど —
が伝播される所は，ここであり、利用者に表示されることになる。
◎
This is where the network errors defined and propagated by Fetch, such as DNS or TLS errors, end up being displayed to users. [FETCH]
</p>
	</li>
	<li>
~IF［
%応答 の`状態s$rs ~IN { `204$hst, `205$hst }
］
⇒
~RET
◎
If response's status is 204 or 205, then return.
</li>
	<li>
<p>
~IF［
%応答 内に `Content-Disposition$h ~headerがあって，それは
`attachment^c ~disposition型を指定している
］：
◎
If response has a `Content-Disposition` header specifying the attachment disposition type, then:
</p>
		<ol>
			<li>
~IF［
%~downloadは許容される ~EQ ~T
］
⇒
%応答 を`~downloadとして$取扱う
◎
If allowedToDownload is true, then handle response as a download.
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
<dfn id="_computed-mime-type">%~MIME型</dfn>
~LET %応答 から`算出される~MIME型$
◎
Let type be the computed type of response.
</li>
	<li>
~IF［
~UAは［
%~MIME型 の資源に対しては［
`閲覧文脈$内に内容を具現化する以外の何らかの仕組み
］を利用して処理する
］ように環境設定されている
］
⇒
~GOTO `非~文書~内容として取扱う$i
◎
If the user agent has been configured to process resources of the given type using some mechanism other than rendering the content in a browsing context, then skip this step.＼
</li>
	<li>
<p>
%~page読込n手続き ~LET %~MIME型 に応じて：
◎
Otherwise, if the type is one of the following types, jump to the appropriate entry in the following list, and process response as described there:
</p>
		<dl class="switch">
			<dt>
`~HTML~MIME型$
◎
an HTML MIME type
</dt>
			<dd>
<a href="#read-html">§ ~HTML文書</a>
に与える手続き
【！#navigate-html】
◎
Follow the steps given in the HTML document section providing navigationParams. Once the steps have completed, return.
</dd>
			<dt>
`~XML~MIME型$であって, `明示的に~supportされる~XML~MIME型$でない
◎
an XML MIME type that is not an explicitly supported XML MIME type
</dt>
			<dd>
<a href="#read-xml">§ ~XML文書</a>
に与える手続き
◎
Follow the steps given in the XML document section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>
`~JS~MIME型$
◎
a JavaScript MIME type
</dt>
			<dt>
`~JSON~MIME型$であって, `明示的に~supportされる~JSON~MIME型$でない
◎
a JSON MIME type that is not an explicitly supported JSON MIME type
</dt>
			<dt>`text/css$c</dt>
			<dt>`text/plain$c</dt>
			<dt>`text/vtt$c</dt>
			<dd>
<a href="#read-text">§ 素な~text~file</a>
に与える手続き
◎
Follow the steps given in the plain text file section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>`multipart/x-mixed-replace$c</dt>
			<dd>
<a href="#read-multipart-x-mixed-replace">§ `multipart/x-mixed-replace^c</a>
に与える手続き
◎
Follow the steps given in the multipart/x-mixed-replace section providing navigationParams. Once the steps have completed, return.
</dd>
			<dt>
~supportされる［
画像 ／ 動画 ／ 音声
］型
◎
A supported image, video, or audio type
</dt>
			<dd>
<a href="#read-media">§ ~media</a>
に与える手続き
◎
Follow the steps given in the media section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>
内容を %B 内に具現化するときに外部~appを利用するような型
◎
A type that will use an external application to render the content in browsingContext
</dt>
			<dd>
<a href="#read-plugin">§ ~plugin</a>
に与える手続き
◎
Follow the steps given in the plugin section providing navigationParams and type. Once the steps have completed, return.
</dd>
			<dt>その他</dt>
			<dd>
ε
◎
↓</dd>
		</dl>
<p>
上の~~目的においては：
◎
↓</p>
		<ul>
			<li>
<p>
次に該当する`~XML~MIME型$は、
`明示的に~supportされる~XML~MIME型@
とされる：
◎
An explicitly supported XML MIME type is an XML MIME type＼
</p>
				<ul>
					<li>
~UAが内容を具現化するときに，外部~appを利用するように環境設定されているもの（ %B 内に直に具現化するような`~plugin$か，または別々の~app）
◎
for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの（例： 組込みの Atom ~feed-viewerを備える~web~browserは `application/atom+xml$c ~MIME型を明示的に~supportするとされる）
◎
one for which the user agent has dedicated processing rules (e.g., a web browser with a built-in Atom feed viewer would be said to explicitly support the application/atom+xml MIME type), or＼
</li>
					<li>
~UAが専用の~handlerを有しているもの
◎
one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
			<li>
<p>
次に該当する`~JSON~MIME型$は、
`明示的に~supportされる~JSON~MIME型@
とされる：
◎
An explicitly supported JSON MIME type is a JSON MIME type＼
</p>
				<ul>
					<li>
~UAが内容を具現化するときに外部~appを利用するように環境設定されているもの（ %B 内に直に具現化するような `~plugin$か，または別々の~app）
◎
for which the user agent is configured to use an external application to render the content (either a plugin rendering directly in browsingContext, or a separate application), or＼
</li>
					<li>
~UAが専用の処理~規則を有しているもの
◎
one for which the user agent has dedicated processing rules, or＼
</li>
					<li>
~UAが専用の~handlerを有しているもの
◎
one for which the user agent has a dedicated handler.
</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%~page読込n手続き ~NEQ ε
］：
</p>
		<ol>
			<li>
%~page読込n手続き( %~navi~params, %~MIME型 )
</li>
			<li>
前~段が完了するまで待機する
</li>
			<li>
~RET
</li>
		</ol>
◎
↑</li>
	<li>
<p>
`非~文書~内容として取扱う@i：
◎
Non-document content:＼
</p>
		<ol>
			<li>
<p>
~IF［
~UAは、 %~MIME型 の資源を何らかの~inline内容として表示する
］
⇒
%資源 による`~inline内容を表示する$( %B )
</p>

<p class="example">
例えば、次に該当するとき
⇒＃
~UAは、 %資源 の内容を~nativeに具現化する／
%~MIME型 は~supportされないことを示す~error~message
</p>
◎
If, given type, the new resource is to be handled by displaying some sort of inline content,＼
e.g., a native rendering of the content or an error message because the specified type is not supported, then＼
display the inline content given browsingContext, and then return.
</li>
			<li>
<p>
~ELSE（ %~MIME型 の資源は %B に影響しない ）
⇒
`外部~softwareに手渡す$( %応答, %一過な作動化 )
</p>

<p class="example">
例えば、次に該当するとき
⇒＃
%資源 を外部~appに手渡す／
%資源 は未知な型であり，`~downloadとして$処理する
</p>
◎
Otherwise, the document's type is such that the resource will not affect browsingContext,＼
e.g., because the resource is to be handed to an external application or because it is an unknown type that will be processed as a download.＼
Hand-off to external software given response and hasTransientActivation.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~navigate~URL~schemeを処理する@
ときは、所与の
( `~URL$ %~url, `閲覧文脈$ %B, 真偽値 %一過な作動化 )
に対し：
◎
To process a navigate URL scheme, given a URL url, a browsing context browsingContext, and a boolean hasTransientActivation:
</p>
<ol>
	<li>
~IF［
%~url は［
%B に影響しない仕組みを利用して取扱われるもの
］である（ %~url の`~scheme$urlは外部的に取扱われるものである）
］
⇒
`外部~softwareに手渡す$( %~url, %一過な作動化 )
◎
If url is to be handled using a mechanism that does not affect browsingContext,＼
e.g., because url's scheme is handled externally,＼
then hand-off to external software given url and hasTransientActivation.
</li>
	<li>
<p>
~ELSE（ %~url は、何らかの~inline内容を表示して取扱われるものである）
⇒
その`~inline内容を表示する$( %B )
◎
Otherwise, url is to be handled by displaying some sort of inline content,＼
e.g., an error message because the specified scheme is not one of the supported protocols, or an inline prompt to allow the user to select a registered handler for the given scheme.＼
Display the inline content given browsingContext.
</p>

<p class="example">
例えば
⇒＃
指定された~schemeは~supportされる~protocolでないことを示す~error~message／
利用者が 所与の~scheme用の`登録-済み~handler$を選定できるようにするための~inline~prompt
◎
↑</p>

<p class="note">注記：
登録-済み~handlerが利用されている事例では、`~navigate$は，新たな~URLで再び呼出されることになる。
◎
In the case of a registered handler being used, navigate will be invoked with a new URL.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`外部~softwareに手渡す@
ときは、所与の
( `~URL$または`応答$ %資源, 真偽値 %一過な作動化 )
に対し，外部~softwareに %資源 を適切に手渡すベキである
— 次に従う下で：
◎
To hand-off to external software given a URL or response resource and a boolean hasTransientActivation, user agents should perform the appropriate handoff of resource
</p>
<ul>
	<li>
当の外部~softwareを悪用しようと試みる~riskを軽減するよう試みるベキである。
例えば~UAは、［
`~source閲覧文脈$にて`作動中の文書$の`生成元$docには、当の外部~softwareを呼出すことは許容される
］かどうか，利用者に確認するよう~promptすることもできる。
◎
while attempting to mitigate the risk that this is an attempt to exploit the target software. For example, user agents could prompt the user to confirm that the source browsing context's active document's origin is to be allowed to invoke the external software in question.＼
</li>
	<li>
特に，［
%一過な作動化 ~EQ ~F
］の場合、前もって利用者に確認をとらずに，外部~software~packageを呼出すベキでない。
◎
In particular, if hasTransientActivation is false, then the user agent should not invoke the external software package without prior user confirmation.
</li>
</ul>

<p class="example">
例えば，当の外部~softwareの~URL~handler内には、［
ある敵対的な~pageが，~linkを~clickするよう利用者を騙す
］ように悪用できる脆弱性があるかもしれない。
◎
For example, there could be a vulnerability in the target software's URL handler which a hostile page would attempt to exploit by tricking a user into clicking a link.
</p>
</div>

<div class="algo">
<p>
`~javascript_@sc
~URLによる要請を実行するときは、所与の
( `要請$ %要請, %S, %B )
に対し，次を走らす：
◎
To execute a javascript: URL request, given a request request and two browsing contexts source and browsingContext, run these steps:
</p>
<ol id="concept-js-deref">
	<li>
%応答 ~LET 次のようにされた新たな`応答$
⇒
`状態s$rs ~SET `204$hst
◎
Let response be a response whose status is 204.
</li>
	<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
<p>
~IF［
次の両者とも満たされる
］…：
◎
If both of the following are true:
</p>
		<ul>
			<li>
<p>
%S にて`作動中の文書$の`生成元$doc ~EQ`生成元$sub %文書 の`生成元$doc
◎
source's active document's origin is same origin with browsingContext's active document's origin.
</p>

<p class="XXX">
<a href="~HTMLissue/2591">課題 #2591</a>
にて説明されるように、この段は働かないため，~securityの課題がある。
◎
As explained in issue #2591 this step does not work and presents a security issue.
</p>
			</li>
			<li>
次の結果 ~EQ `許容される^i
⇒
`ある種別の~navi要請は~CSPにより阻止されるべきか？$( %要請, `other^l )
`CSP$r
◎
The result of Should navigation request of type be blocked by Content Security Policy? given request and "other" is "Allowed". [CSP]
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
%~script~source ~LET `~URLを直列化する$( %要請 の`~URL$rq )
◎
Let urlString be the result of running the URL serializer on request's url.
</li>
			<li>
%~script~source ~SET %~script~source から先頭の `javascript:^l を除去した結果
◎
Let encodedScriptSource be the result of removing the leading "javascript:" from urlString.
</li>
			<li>
%~script~source ~SET `文字列を~byte列に~percent-復号する$( %~script~source )
◎
Let scriptSource be the UTF-8 decoding of the percent-decoding of encodedScriptSource.
</li>
			<li>
%~script~source ~SET `~UTF-8復号する$( %~script~source )
◎
↑</li>
			<li>
%文書 の`~URL$docを %要請 の`~URL~list$rqに付加する
◎
Append browsingContext's active document's URL to request's URL list.
</li>
			<li>
%設定群 ~LET %文書 に`関連な設定群~obj$
◎
Let settings be browsingContext's active document's relevant settings object.
</li>
			<li>
%~script ~LET
`古典~scriptを作成する$( 次に挙げる引数 )
⇒＃
%~script~source,
%設定群,
%設定群 の`~API用~基底~URL$enV,
`既定の古典~script~fetch~options$
◎
Let baseURL be settings's API base URL.
◎
Let script be the result of creating a classic script given scriptSource, settings, baseURL, and the default classic script fetch options.
</li>
			<li>
%評価~状態s ~LET `古典~scriptを走らす$( %~script )
◎
Let evaluationStatus be the result of running the classic script script.
</li>
			<li>
%結果 ~LET ［
次が満たされるならば `undefined^jv ／
~ELSE_ %評価~状態s . `Value^sl
］
⇒
［
%評価~状態s は`中途完了$である
］~OR［
%評価~状態s . `Value^sl ~EQ `empty^jv
］
◎
Let result be undefined if evaluationStatus is an abrupt completion or evaluationStatus.[[Value]] is empty, or evaluationStatus.[[Value]] otherwise.
</li>
			<li>
<div class="p">
<p>
~IF［
`Type$jA( %結果 ) ~EQ `String^jT
］：
</p>
				<ol>
					<li>
%応答 ~SET 新たな`応答$
</li>
					<li>
%応答 の`本体$rs ~SET %結果†
</li>
					<li>
%応答 の`~header~list$rs ~SET 次の~headerからなる`~header~list$
⇒＃
( `Content-Type$h / `text/html$bl ),
( `Referrer-Policy$h / %設定群 の`~referrer施策$enV )
</li>
				</ol>
◎
If Type(result) is String, then set response to a response whose header list consists of `Content-Type`/`text/html` and `Referrer-Policy`/settings's referrer policy, and whose body is result.
</div>

<p class="warning">†
文字列 %結果 と応答の`本体$rsを成す~byte列との間の正確な変換は、まだ指定されていない。
~UAの挙動が更に究明されるのが待たれる。
<a href="~HTMLissue/1129">課題 #1129</a>
を見よ。
◎
The exact conversion between the string result and the bytes that comprise a response body is not yet specified, pending further investigation into user agent behavior. See issue #1129.
</p>
		</ol>
	</li>
	<li>
~RET %応答
◎
Return response.
</li>
</ol>

<p class="XXX">
上にて~linkした特定の課題に加えて、
`issue tracker^en には， `~javascript_$sc ~URLの仕様について様々な問題を文書化している
`<a href="https://github.com/whatwg/html/labels/topic%3A%20javascript%3A%20URLs">専用の~label</a>^
］がある。
◎
In addition to the specific issues linked above, javascript: URLs have a dedicated label on the issue tracker documenting various problems with their specification.
</p>
</div>

<hr>

<div class="algo">
<p>
以下の一部の節は、ある種の事例で上の~algoから呼出され，次に与える
`文書を作成して初期化する@
手続きを利用する。
それは、所与の
( `種別$doc %種別, `内容~型$doc %内容~型, `~navi~params$ %~navi~params )
に対し，次を走らす：
◎
Some of the sections below, to which the above algorithm defers in certain cases, use the following steps to create and initialize a Document object, given a type type, content type contentType, and navigation params navigationParams:
</p>
<ol>
	<li>
%B ~LET `~navi応答~用に利用する閲覧文脈を得する$( 次に挙げる引数 )
⇒＃
%~navi~params の`閲覧文脈$nvP,
%~navi~params の`最終-~sandbox~flag集合$nvP,
%~navi~params の`非同一-生成元~opener施策$nvP,
%~navi~params の`~COOP施行n結果$nvP
◎
Let browsingContext be the result of the obtaining a browsing context to use for a navigation response given navigationParams's browsing context, navigationParams's final sandboxing flag set, navigationParams's cross-origin opener policy, and navigationParams's COOP enforcement result.
</li>
	<li>
<p>
%許可~施策 ~LET
`応答から閲覧文脈~用の許可~施策を作成する$( %B, %~navi~params の`生成元$nvP, %~navi~params の`応答$nvP )
`PERMISSIONSPOLICY$r
◎
Let permissionsPolicy be the result of creating a permissions policy from a response given browsingContext, navigationParams's origin, and navigationParams's response. [PERMISSIONSPOLICY]
</p>

<div class="note">
<p>注記：
ここで`応答から閲覧文脈~用の許可~施策を作成する$ときは、渡された`生成元$を用立てる。
%B の`容器~文書$に対し `document.domain$m が利用されていた場合、
【以下で作成され，入子にされる文書】 %文書 の`生成元$docと渡された生成元は，`同じ生成元~domain$にはなり得ない
— この手続きは %文書 が作成される前に走るので、この時点では まだ %文書 の `document.domain$m は利用し得ないので。
したがって，許可~施策の検査は、`同一-生成元$かどうか検査するよりも，~~寛容でない。
◎
The creating a permissions policy from a response algorithm makes use of the passed origin. If document.domain has been used for browsingContext's container document, then its origin cannot be same origin-domain with the passed origin, because these steps run before the document is created, so it cannot itself yet have used document.domain. Note that this means that Permissions Policy checks are less permissive compared to doing a same origin check instead.
</p>

<p>
これの動作~例は、下を見よ。
◎
See below for some examples of this in action.
</p>
</div>

	</li>
	<li>
%作成時の~URL ~LET %~navi~params の`応答$nvPの`~URL$rs
◎
Let creationURL be navigationParams's response's URL.
</li>
	<li>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］
⇒
%作成時の~URL ~SET %~navi~params の`要請$nvPの`現在の~URL$rq
◎
If navigationParams's request is non-null, then set creationURL to navigationParams's request's current URL.
</li>
	<li>
<p>
~IF［
次がすべて満たされる
］…：
◎
If＼
</p>
		<ul>
			<li>
%B の`~session履歴$は、 %B の`作成-時$に追加された初期 `~about_blank$sc `文書$ %D のみからなる
◎
browsingContext's only entry in its session history is the initial about:blank Document that was added when that browsing context was created,＼
</li>
			<li>
%~navi~params の`履歴~取扱い$nvP ~EQ `置換-$i
◎
and navigationParams's history handling is "replace",＼
</li>
			<li>
( %D の`生成元$doc, %~navi~params の`生成元$nvP )
は`同じ生成元~domain$である
◎
and that Document's origin is same origin-domain with navigationParams's origin,＼
</li>
		</ul>
<p>
…ならば
⇒
何もしない
◎
then do nothing.
</p>

<p class="note">注記：
この事例では、これから作成する新たな`文書$と初期 `~about_blank^sc 文書は，同じ`~window$を共有することになる。
◎
This means that both the initial about:blank Document, and the new Document that is about to be created, will share the same Window object.
</p>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%生成元~agent~cluster~header ~LET
%応答 の`~header~list$rsから`有構造~headerを取得する$( `Origin-Agent-Cluster$h, `~item^i )
◎
Let oacHeader be the result of getting a structured field value given `Origin-Agent-Cluster` and "item" from response's header list.
</li>
			<li>
%生成元~agent~clusterを要請する ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%生成元~agent~cluster~header ~NEQ ~NULL
］~AND［
%生成元~agent~cluster~header[ 0 ] ~EQ `真偽値$sf ~T
］
◎
Let requestsOAC be true if oacHeader is not null and oacHeader[0] is the boolean true; otherwise false.
</li>
			<li>
~IF［
%~navi~params の`予約-済み環境$nvPは`~secureな文脈$enVでない
］
⇒
%生成元~agent~clusterを要請する ~SET ~F
◎
If navigationParams's reserved environment is a non-secure context, then set requestsOAC to false.
</li>
			<li>
%~agent ~LET `生成元が類似な~window~agentを得する$( %~navi~params の`生成元$nvP, %B の`~group$tbcG, %生成元~agent~clusterを要請する )
◎
Let agent be the result of obtaining a similar-origin window agent given navigationParams's origin, browsingContext's group, and requestsOAC.
</li>
			<li>
%~realm実行~文脈 ~LET 次のように~custom化する下で，
%~agent 内で`新たな~JS~realmを作成する$
⇒＃
大域~obj用に新たな `Window$I ~objを作成する【すなわち， %B にて`作動中の~window$になる】,
大域 `this^jv 束縛には %B の `WindowProxy$I ~objを利用する
◎
Let realm execution context be the result of creating a new JavaScript realm given agent and the following customizations:
• For the global object, create a new Window object.
• For the global this binding, use browsingContext's WindowProxy object.
</li>
			<li>
%~top-level作成時の~URL ~LET %作成時の~URL
◎
Let topLevelCreationURL be creationURL.
</li>
			<li>
%~top-level生成元 ~LET %~navi~params の`生成元$nvP【！原文：リンク誤り】
◎
Let topLevelOrigin be navigationParams's origin.
</li>
			<li>
<p>
~IF［
%B は`~top-level閲覧文脈$でない
］：
◎
If browsingContext is not a top-level browsing context, then:
</p>
				<ol>
					<li>
%親~環境 ~LET %B の`容器$bcに`関連な設定群~obj$
◎
Let parentEnvironment be browsingContext's container's relevant settings object.
</li>
					<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL.
</li>
					<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
Set topLevelOrigin to parentEnvironment's top-level origin.
</li>
				</ol>
			</li>
			<li>
`~window用に環境~設定群~objを設定しておく$( 次に挙げる引数 )
⇒＃
%作成時の~URL,
%~realm実行~文脈,
%~navi~params の`予約-済み環境$nvP,
%~top-level作成時の~URL,
%~top-level生成元
◎
Set up a window environment settings object with creationURL, realm execution context, navigationParams's reserved environment, topLevelCreationURL, and topLevelOrigin.
</li>
		</ol>

<p class="note">注記：
これは通例の事例であり、これから作成する新たな`文書$は，それに伴い新たな`~window$を取得する。
◎
This is the usual case, where the new Document we're about to create gets a new Window to go along with it.
</p>
	</li>
	<li>
<p>
%文書 ~LET 次のようにされた新たな`文書$
⇒＃
`種別$doc ~SET %種別,
`内容~型$doc ~SET %内容~型,
`生成元$doc ~SET %~navi~params の`生成元$nvP,
`許可~施策$doc ~SET %許可~施策,
`作動中の~sandbox法~flag集合$ ~SET %~navi~params の`最終-~sandbox~flag集合$nvP,
`非同一-生成元~opener施策$doc ~SET %~navi~params の`非同一-生成元~opener施策$nvP
◎
Let document be a new Document, whose type is type, content type is contentType, origin is navigationParams's origin, permissions policy is permissionsPolicy, active sandboxing flag set is navigationParams's final sandboxing flag set, and cross-origin opener policy is navigationParams's cross-origin opener policy.
</p>

<p class="note">注記：
新たな`~window$に`結付けられている文書$は、後で，この~algoの~call元が`新たな~pageで~session履歴を更新する$ときに
%文書 に設定される。
その~algoは、［
`~window$, `文書$, `閲覧文脈$, `~session履歴$
］を同期する より大きな役割の一部として，`閲覧文脈にて作動中の文書を設定する$。
◎
The new Window's associated Document is set to document later, when the caller of this algorithm updates the session history with the new page. That algorithm sets the active document as part of its larger role of synchronizing the Window, Document, browsing context, and session history.
</p>

	</li>
	<li id="set-the-document's-address">
%文書 の`~URL$doc ~SET %作成時の~URL
◎
Set document's URL to creationURL.
</li>
	<li>
%文書 の`~referrer施策$doc ~SET `~headerから~referrer施策を構文解析する$( %~navi~params の`応答$nvPの `Referrer-Policy^h ~header )【！＊】
`REFERRERPOLICY$r
◎
Set document's referrer policy to the result of parsing the `Referrer-Policy` header of navigationParams's response. [REFERRERPOLICY]
</li>
	<li>
%文書 の`埋込元~施策$doc ~SET %~navi~params の`予約-済み環境$nvP に応じて
⇒＃
~NULL ならば `unsafe-none$coep ／
~ELSE_ `埋込元~施策を得する$( %~navi~params の`応答$nvP, %~navi~params の`予約-済み環境$nvP )
◎
If navigationParam's reserved environment is non-null, then set document's embedder policy to the result of obtaining an embedder policy given navigationParams's response and navigationParam's reserved environment. Otherwise, set it to "unsafe-none".
</li>
	<li>
`文書の~CSP~listを初期化する$( %文書, %~navi~params の`応答$nvP, %~navi~params の`要請$nvP )
`CSP$r
◎
Initialize a Document's CSP list given document, navigationParams's response, and navigationParams's request. [CSP]
</li>
	<li>
<p>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］：
◎
If navigationParams's request is non-null, then:
</p>
		<ol>
			<li>
%文書 の`~referrer$doc ~SET 空~文字列
◎
Set document's referrer to the empty string.
</li>
			<li>
%~referrer ~LET %~navi~params の`要請$nvPの`~referrer$rq
◎
Let referrer be navigationParams's request's referrer.
</li>
			<li>
<p>
~IF［
%~referrer は`~URL~record$である
］
⇒
%文書 の`~referrer$doc ~SET `~URLを直列化する$( %~referrer )
◎
If referrer is a URL record, then set document's referrer to the serialization of referrer.
</p>

<p class="note">注記：
`FETCH$r により、
%~referrer は，この時点で［
`~URL~record$／ `no-referrer^l
］になる。
◎
Per Fetch, referrer will be either a URL record or "no-referrer" at this point.
</p>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~load計時情報$doc ~SET 新たな`文書~load計時情報$
◎
Set document's load timing info to a new document load timing info.
</li>
	<li>
%~navi種別 ~LET %~navi~params の`履歴~取扱い$nvPに応じて
⇒＃
`既定$i ならば `navigate$l ／
`置換-$i ならば `navigate$l ／
`再読込み$i ならば `reload$l ／
`~entry更新$i ならば `back_forward$l
◎
Let historyHandling be navigationParams's history handling.
◎
Let navigationType be the result of switching on navigationParams's history handling:
• "default"
• "replace"
•• "navigate"
• "reload"
•• "reload"
• "entry update"
•• "back_forward"
</li>
	<li>
`~navi計時~entryを作成する$( 次に挙げる引数 )
⇒＃
%文書,
%~navi~params の`応答$nvPの`計時情報$rs,
%~navi~params の`要請$nvPの`~redirect回数$rq,
%~navi種別
◎
Create the navigation timing entry for document, with navigationParams's response's timing info, navigationParams's request's redirect count, and navigationType.
</li>
	<li>
<p>
~IF［
%~navi~params の`応答$nvPには `Refresh$h ~headerは在る
］：
◎
If navigationParams's response has a `Refresh` header, then:
</p>
		<ol>
			<li>
%値 ~LET `同型に復号する$( `Refresh^h の値 )
◎
Let value be the isomorphic decoding of the value of the header.
</li>
			<li>
`共用~宣言的~refresh手続き$( %文書, %値 )
◎
Run the shared declarative refresh steps with document and value.
</li>
		</ol>

<p class="XXX">
`Refresh$h ~headerが複数あるときの取扱いは、現時点では，まだ指定していない。
これは
<a href="~HTMLissue/2900">課題 #2900</a>
にて追跡されている。
◎
We do not currently have a spec for how to handle multiple `Refresh` headers. This is tracked as issue #2900.
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="example">
<p>
次の例では、子~文書には `PaymentRequest$I の利用は許容されない
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$であっても。
子~文書が初期化された時点では、 `document.domain$m は 親~文書にのみ設定されていて，子~文書にはまだ設定されてない。
◎
In this example, the child document is not allowed to use PaymentRequest, despite being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, only the parent document has set document.domain, and the child document has not.
</p>

<pre class="lang-html">
&lt;!-- https://foo.example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 document.domain = 'example.com';
&lt;/script&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
</pre>

<pre class="lang-html">
&lt;!-- https://bar.example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 document.domain = 'example.com'; /* <span class="comment">
これは、文書が初期化された後に起こる。
◎
This happens after the document is initialized
</span> */
 new PaymentRequest(…); /* <span class="comment">
利用は許容されない
◎
Not allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="example">
<p>
次の例では、子~文書には `PaymentRequest$I の利用は<em>許容される</em>
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$でなくとも。
子~文書が初期化される時点では，どちらの文書にも まだ `document.domain$m は設定されていないので、`同じ生成元~domain$の検査は，通常の`同一-生成元$の検査に~fall-backする。
◎
In this example, the child document is allowed to use PaymentRequest, despite not being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, none of the documents have set document.domain yet so same origin-domain falls back to a normal same origin check.
</p>

<pre class="lang-html">
&lt;!-- https://example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
子~文書は、下の~scriptが走る前の，この時点では初期化されている。
◎
The child document is now initialized, before the script below is run.
</span> --&gt;
&lt;script&gt;
 document.domain = 'example.com';
&lt;/script&gt;
</pre>

<pre class="lang-html">
&lt;!-- https://example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
 new PaymentRequest(…); /* <span class="comment">
利用は許容される
◎
Allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="algo">
<p>
以下の各~節にて，
`新たな~pageで~session履歴を更新する@
よう要求される所では、所与の
( `~navi~params$ %~navi~params, `文書$ %新たな文書 )
に対し，次を行うモノトスル
⇒
`大域~taskを~queueする$( `~network用~task源$, %現在の文書 に`関連な大域~obj$, 次に与える手続き )：
◎
Some of the sections below, to which the above algorithm defers in certain cases, require the user agent to update the session history with the new page, given some navigation params navigationParams and a Document newDocument. When a user agent is required to do this, it must queue a global task on the networking task source, given the relevant global object of the Document object of the current entry (not the new one), to run the following steps:
</p>
<ol>
	<li>
%~session履歴 ~LET %~navi~params の`閲覧文脈$nvPの`~session履歴$
◎
Let sessionHistory be navigationParams's browsing context's session history.
</li>
	<li>
%現在の~entry ~LET %~session履歴 の`現在の~entry$
◎
↓</li>
	<li>
%~unload計時情報 ~LET 新たな`文書~unload計時情報$
◎
Let unloadTimingInfo be a new document unload timing info.
</li>
	<li>
%前-文書 ~LET %現在の~entry の`文書$shE
◎
Let previousDocument be sessionHistory's current entry's document.
</li>
	<li>
`文書を~unloadする$( %前-文書, ε, %~unload計時情報 )
◎
Unload previousDocument with unloadTimingInfo.
</li>
	<li>
%~navi ~LET この~algoを呼出した`~navi$~algoの~instance
◎
↓</li>
	<li>
~IF［
前~段の~unloadを走らせている間に %~navi は取消された
］
⇒
~RET
⇒
~unloadは走らせ終えるモノトスルが、
%~navi は，この段を超えて走らせないモノトスル。
（特に，ここで %~navi が取消されても、一例として，文書や その子孫を~unloadする一部として生じている ~event配送-や~script実行は，中止されない。）
◎
If this instance of the navigation algorithm is canceled while this step is running the unload a document algorithm, then the unload a document algorithm must be allowed to run to completion, but this instance of the navigation algorithm must not run beyond this step. (In particular, for instance, the cancelation of this algorithm does not abort any event dispatch or script execution occurring as part of unloading the document or its descendants.)
</li>
	<li>
~IF［
%~navi~params の`非同一-生成元~redirectあり？$nvP ~EQ ~F
］~AND［
%新たな文書 の`生成元$doc ~EQ`生成元$sub %前-文書 の`生成元$doc
］
⇒
%新たな文書 の`前-文書の~unload計時情報$doc ~SET %~unload計時情報
◎
If navigationParams's has cross-origin redirects is false, and newDocument's origin is the same as previousDocument's origin, then set newDocument's previous document unload timing to unloadTimingInfo.
</li>
	<li>
<p>
%~navi~params の`履歴~取扱い$nvPに応じて：
◎
Switch on navigationParams's history handling:
</p>
		<ul class="switch">
			<li>
<p>
`~entry更新$i／`再読込み$i：
◎
"entry update"
◎
"reload"
</p>
				<ol>
					<li>
%旧-文書 ~LET %現在の~entry の`文書$shE 【 %前-文書 と同じ？】
◎
Let oldDocument be sessionHistory's current entry's document.
</li>
					<li>
%~session履歴 内の
~EACH( %~entry )
に対し
⇒
~IF［
%~entry の`文書$shE ~EQ %旧-文書
］
⇒
%~entry の`文書$shE ~SET %新たな文書
◎
For each entry of sessionHistory: if entry's document is oldDocument, then set entry's document to newDocument.
</li>
					<li>
%現在の~entry へ`履歴を辿る$
— 次を与える下で
⇒＃
`履歴の取扱い$i ~SET %~navi~params の`履歴~取扱い$nvP
◎
Traverse the history to sessionHistory's current entry with historyHandling set to navigationParams's history handling.
</li>
				</ol>
			</li>
			<li>
<p>
`置換-$i：
◎
"replace"
</p>
				<ol>
					<li>
<p>
%新たな~entry ~LET 次を伴う新たな`~session履歴~entry$
⇒＃
`~URL$shE ~SET %新たな文書 の`~URL$doc,
`文書$shE ~SET %新たな文書
◎
Let newEntry be a new session history entry whose URL is newDocument's URL and document is newDocument.
</p>

<p class="XXX">
一部の~browserは，
( %現在の~entry の`~URL$shE, %新たな文書 の`~URL$doc )
は`同等な~URL$である事例で［
%現在の~entry の`直列形の状態$shEも
%新たな~entry に複製する
］が、これは他と一貫でない。
さらなる論点は、
<a href="~HTMLissue/6213">課題 #6213</a>
を見よ。
◎
Some browsers copy over the serialized state sessionHistory's current entry in cases where its URL equals that of newDocument, but this is inconsistent. See issue #6213 for more discussion on this.
</p>
					</li>
					<li>
%~session履歴 内の %現在の~entry の後に %新たな~entry を挿入する
◎
Insert newEntry into sessionHistory after its current entry.
</li>
	<li>
%新たな~entry へ`履歴を辿る$
— 次を与える下で
⇒＃
`履歴の取扱い$i ~SET `置換-$i
◎
Traverse the history to newEntry with historyHandling set to "replace".
</li>
				</ol>
			</li>
			<li>
<p>
`既定$i：
◎
"default"
</p>
				<ol>
					<li>
<p>
%~session履歴 から［
%現在の~entry より後にある~entryをすべて
］を除去する（もしあれば）
◎
Remove all the entries in sessionHistory after its current entry. (If the current entry is the last entry in the session history, then no entries are removed.)
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
				 </li>
					<li>
%新たな~entry ~LET 次を伴う新たな`~session履歴~entry$
⇒＃
`~URL$shE ~SET %新たな文書 の`~URL$doc,
`文書$shE ~SET %新たな文書
◎
Let newEntry be a new session history entry whose URL is newDocument's URL and document is newDocument.
</li>
					<li>
%~session履歴 に %新たな~entry を`付加する$
◎
Append newEntry to sessionHistory.
</li>
					<li>
%新たな~entry へ`履歴を辿る$
◎
Traverse the history to newEntry.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
この時点で、 %~navi は
`成熟した@
とされる。
【！ %新たな文書 が`属する閲覧文脈$ ~NEQ ~NULL になる】
◎
The navigation algorithm has now matured.
</li>
	<li>
`素片へ~scrollしようと試行する$( %新たな文書 )
◎
Try to scroll to the fragment for newDocument.
</li>
</ol>
</div>

<div class="algo">
<p>
`素片へ~scrollしようと試行する@
ときは、所与の
( `文書$ %文書 )
に対し，次の手続きを`並列的$に遂行する：
◎
To try to scroll to the fragment for a Document document, perform the following steps in parallel:
</p>
<ol>
	<li>
`実装定義$な量の時間だけ待機する
（この段は、~UAが処理能の懸念に直面したとき，利用者~体験を最適化できるようにするためにある。）
◎
Wait for an implementation-defined amount of time. (This is intended to allow the user agent to optimize the user experience in the face of performance concerns.)
</li>
	<li>
<p>
次を走らす`大域~taskを~queueする$( `~network用~task源$, %文書 に`関連な大域~obj$ ）：
◎
Queue a global task on the networking task source given document's relevant global object to run these steps:
</p>
		<ol>
			<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>

<ul><li>%文書 用の構文解析器は無い
</li><li>%文書 用の構文解析器は`構文解析を停止した$
</li><li>~UAには、［
利用者が`素片$urlへ~scrollすることに関心を失った
］と予見する理由がある
</li></ul>

<p>
…ならば
⇒
~RET
</p>

◎
If document has no parser, or its parser has stopped parsing, or the user agent has reason to believe the user is no longer interested in scrolling to the fragment, then abort these steps.
</li>
			<li>
%文書 の`~URL$doc内に与えられる`素片へ~scrollする$
◎
Scroll to the fragment given in document's URL.＼
</li>
			<li>
~IF［
前~段の結果 %文書 内の`指示された部位$docを見出せなかった
］
⇒
`素片へ~scrollしようと試行する$( %文書 )
◎
If this does not find an indicated part of the document, then try to scroll to the fragment for document.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="read-html">
<h4 title="Page load processing model for HTML files">7.10.2. ~HTML~file用の~page読込n処理~model</h4>

<div class="algo">
<p>
~UAは，
`~HTML文書が読込まれる@
ことになるときは、所与の
( `~navi~params$ %~navi~params )
に対し，次を行うモノトスル：
◎
When an HTML document is to be loaded, given navigation params navigationParams, the user agent must＼
</p>
<ol>
	<li>
<p>
次の手続きを走らす`~taskを~queueする$( `~network用~task源$ )：
◎
queue a task on the networking task source to:
</p>
		<ol>
			<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
			<li>
<p>
新たな`~HTML構文解析器$を作成して %文書 に結付ける
— この構文解析器に対しては
⇒
~fetchingを走らせている間に`~network用~task源$から
`~task~queue$に入れられる各`~task$は、~fetchされた~byte列で構文解析器への`入力~byte~stream$を埋めた上で，構文解析器に入力~streamの適切な処理を遂行させるモノトスル。
◎
Create an HTML parser and associate it with the document.＼
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</p>

<p class="note">注記：
`入力~byte~stream$に渡された~byte列は、文字~並びに変換されて`~tokenizer$に渡される。
この処理nの一部は、資源の~~真の `~Content-Type~metadata$ から見出される文字~符号化法~情報に依拠する
— `資源から算出された~MIME型$は、その目的には利用されない。
◎
The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.
</p>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
加えて、~UAは次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
可用な~byte列が尽きたときは、次を走らす（これは、最終的に `load$et ~eventを発火させることになる）
⇒
構文解析器が暗黙の~EOF文字を処理するための
`大域~taskを~queueする$( `~network用~task源$, 新たに作成された`文書$に`関連な大域~obj$ )
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given the newly-created Document's relevant global object for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
	<li>
`文書$ %文書 を作成した後, かつ ~scriptが実行される前の, ほぼ間違いなく構文解析器が`停止-$する前に
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but before any script execution, certainly before the parser stops, the user agent must update the session history with the new page given navigationParams and the newly-created Document.
</li>
</ul>

			</section>
			<section id="read-xml">
<h4 title="Page load processing model for XML files">7.10.3. ~XML~file用の~page読込n処理~model</h4>

<div class="algo">
<p>
~XML~fileを~inlineに表示することになった場合、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し、次に挙げる各種 仕様に定義される要件に従う下で
⇒＃
`XML^cite `XML$r,
`Namespaces in XML^cite `XMLNS$r,
`XML Media Types^cite `RFC7303$r,
`DOM^cite `DOM$r,
関連な他の`文書$を作成するための仕様と対応する`~XML構文解析器$
◎終
次を行うモノトスル：
◎
When faced with displaying an XML file inline, provided navigation params navigationParams and a string type, user agents must follow the requirements defined in XML and Namespaces in XML, XML Media Types, DOM, and other relevant specifications＼
</p>
<ol>
	<li>
`文書を作成して初期化する$( `xml^l, %~MIME型, %~navi~params )
◎
to create and initialize a Document object given "xml", type, and navigationParams.＼
</li>
	<li>
対応する`~XML構文解析器$を作成する
◎
They must also create a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]
</li>
</ol>
</div>

<p class="note">注記：
これを書いている時点では，~XML仕様~communityは、実際には，~XMLと~DOMとがどう相互作用するか まだ指定していない。
◎
At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.
</p>

<p>
~UAは、`文書$ %文書 を作成したときは：
◎
↓</p>

<ul>
	<li>
上に挙げた各 仕様の規則に則って，文字~符号化法を決定するときには、実際の~HTTP~headerや他の~metadataのうち［
この仕様が与える~algoにより［
変異される／含意される
］~header
］でないものを利用した上で、
%文書 の`文字~符号化法$docは，そのように確立された符号化法に設定するモノトスル。
◎
The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.
</li>
	<li>
<p>
次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
</p>

<p>
その時機は
⇒＃
%文書 が完全に構文解析される前でもヨイ（したがって `増分的に具現化する^i ことになる）／
どの~script実行よりも前に行うモノトスル
</p>
◎
Then, with the newly created Document, the user agent must update the session history with the new page given navigationParams and the newly-created Document. User agents may do this before the complete document has been parsed (thus achieving incremental rendering), and must do this before any scripts are to be executed.
</li>
	<li>
構文解析-時の~error（例えば ~XML名前空間 整形式性~error）に際しては、
%文書 を変異して~inlineに報告してもヨイ。
◎
Error messages from the parse process (e.g., XML namespace well-formedness errors) may be reported inline by mutating the Document.
</li>
</ul>

			</section>
			<section id="read-text">
<h4 title="Page load processing model for text files">7.10.4. ~text~file用の~page読込n処理~model</h4>

<div class="algo">
<p>
~UAは，素な~text文書を読込むことになるときは、供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，次を行うモノトスル：
◎
When a plain text document is to be loaded, provided navigation params navigationParams and a string type, the user agent must＼
</p>
<ol>
	<li>
<p>
次の手続きを走らす`~taskを~queueする$( `~network用~task源$ )：
◎
queue a task on the networking task source to:
</p>
		<ol>
			<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
			<li>
<p>
新たな`~HTML構文解析器$を作成して %文書 に結付ける
— この構文解析器は：
◎
Create an HTML parser and associate it with the document.＼
</p>
				<ul>
					<li>
その~tokenizerが すでに次を順に行ったかのようにしておく
⇒＃
~tag名 `pre^l の開始~tag~tokenを発した；
1 個の文字 <span class="code-point">U+000A</span> （LF）を発した；
`~PLAINTEXT状態$に切替えた
◎
Act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state.＼
</li>
					<li>
~fetchingを走らせている間に`~network用~task源$から`~task~queue$に入れられる各`~task$は、構文解析器の`入力~byte~stream$を~fetchされた~byte列で埋めて，構文解析器に入力~streamの適切な処理を遂行させるモノトスル。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</li>
				</ul>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
素な~text文書である %資源 に対しては、次に挙げる要件が~UAに課される：
◎
↓</p>

<ul>
	<li>
%資源 の~byte列を
実際の文字に変換する規則，および
その~textを利用者~向けに実際に具現化する規則は、`資源から算出された~MIME型$の仕様により定義される。
◎
The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (i.e., type).
</li>
	<li>
%資源 の`文字~符号化法$docは、 %資源 の復号-時に利用された文字~符号化法に設定するモノトスル。
◎
The document's character encoding must be set to the character encoding used to decode the document.
</li>
	<li>
可用な~byte列が尽きたときは、次を走らすモノトスル（これは、最終的に `load$et ~eventを発火させることになる）
⇒
構文解析器が暗黙の~EOF文字を処理するための
`大域~taskを~queueする$( `~network用~task源$, 新たに作成した`文書$に`関連な大域~obj$ )
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given the newly-created Document's relevant global object for the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
	<li>
<p>
%資源 から`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has finished parsing, the user agent must update the session history with the new page given navigationParams and the newly-created Document.
</p>

<p class="trans-note">【
“`なければその前に@”
— 原文の “`, but potentially before^en” の意図が［
要件の一部 ／
可能性があることを示す単なる説明 ／
終える前にそうしてよいことの明示的な許可
］のどれなのか はっきりしないが、同じ要件~文の一部として `but^en 節の中に記されているので，要件と解釈する下で和訳している。
】</p>
	</li>
	<li>
<p>
`文書$の `head$e 要素に内容を追加してもヨイ
— 例：
~stylesheetへ~linkする,
~scriptを供する,
文書に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, e.g., linking to a style sheet, providing script, or giving the document a title.
</p>

<p class="note">注記：
特に、 RFC 3676 の `Format=Flowed^c 特能を~supportする~UAは、［
~textを正しく折返す／
【行頭の "&gt;" による】 引用用の特能を取扱う
］ために，何らかの~styleを適用する必要が生じることになる。
これは、例えば~CSS拡張を利用して遂行することもできる。
◎
In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.
</p>
	</li>
</ul>

			</section>
			<section id="read-multipart-x-mixed-replace">
<h4 title="Page load processing model for multipart/x-mixed-replace resources">7.10.5. `multipart/x-mixed-replace^c 資源~用の~page読込n処理~model</h4>

<p>
型 `multipart/x-mixed-replace$c を伴う資源を `閲覧文脈$内に読込むことになるときは、~UAは次に従うモノトスル：
◎
When a resource with the type multipart/x-mixed-replace is to be loaded in a browsing context, the user agent must＼
↓parse the resource using the rules for multipart types. [RFC2046]
</p>

<p class="XXX">
この~algoには`~navi~params$が渡されるが、それを正確に どう利用するかは，明瞭でない。
◎
This algorithm is passed navigation params, but it's unclear how exactly to use them.
</p>

<ul>
	<li>
`RFC2046$r による `multipart^c 型~用の規則を利用して資源を構文解析する。
◎
↑</li>
	<li>
資源から得された
~EACH( %本体~部位 )
に対し，出現順に 次を走らす
⇒
次を除いて、この節を呼出した`~navi$と同じものを与える下で，`~navigate応答を処理する$
⇒
%応答 の本体には %本体~部位 を利用する。
加えて、これまでの~~反復で ある`文書$を`作成して初期化-$していた場合、
`履歴~取扱い$nvPを `置換-$i に設定する下で行うとする。
◎
For each body part obtained from the resource, the user agent must run process a navigate response using the new body part and the same browsing context, with history handling set to "replace" if a previous body part from the same resource resulted in a creating and initializing a Document object, and otherwise using the same setup as the navigate attempt that caused this section to be invoked in the first place.
</li>
	<li>
前項による，［
各 本体~部位を，完全に自立的な資源であったかのように処理する目的
］においては、各 本体~部位に対し［
それに後続する境界に達した所で，当の資源~用の~byte列は尽きた
］かのように動作する。
◎
For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.
</li>
</ul>

<p class="note">注記：
したがって， `load$et ~event（および，対になる `unload$et ~event）は、各~本体~部位が読込まれる度に発火されることになる。
◎
Thus, load events (and for that matter unload events) do fire for each body part loaded.
</p>

			</section>
			<section id="read-media">
<h4 title="Page load processing model for media">7.10.6. ~media用の~page読込n処理~model</h4>

<div class="algo">
<p>
［
画像 ／ 動画 ／ 音声
］資源を読込むことになるときは、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，次を行うベキである：
◎
When an image, video, or audio resource is to be loaded, provided navigation params navigationParams and a string type, the user agent should:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
%文書 に `html$e 要素を付加する
◎
Append an html element to document.
</li>
	<li>
`html$e 要素に `head$e 要素を付加する
◎
Append a head element to the html element.
</li>
	<li>
`html$e 要素に `body$e 要素を付加する
◎
Append a body element to the html element.
</li>
	<li>
<p>
`body$e 要素に［
資源の~mediaに応じて，次の表の 2 列目に与えられる要素
］を付加する：
</p>

<table><thead><tr><th>~media型
<th>要素
<th>属性
</thead>

<tbody><tr><td>画像
<td>`img$e
<td>`~src-img$a

<tr><td>動画
<td>`video$e
<td>`~src-media$a

<tr><td>音声
<td>`audio$e
<td>`~src-media$a

</tbody></table>

◎
Append an element host element for the media, as described below, to the body element.
</li>
	<li>
前~段で付加した要素の［
対応する，前~段の表の 3 列目の属性
］の値 ~SET 資源の~address
◎
Set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.
◎
The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.
◎
Type of media | Element for the media | Appropriate attribute
Image | img | src
Video | video | src
Audio | audio | src
</li>
</ol>
</div>

<p>
次に，~UAは、`構文解析を停止した$かのように動作するモノトスル。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
~UAは、`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page given navigationParams and the newly-created Document.
</p>

<p>
~UAは、`文書$の `head$e 要素に内容を追加してもヨイ ／
%~host要素 に内容~属性を追加してもヨイ
— 例：
~stylesheetへの~link ／
~scriptを供する ／
文書に `title$e を与える ／
~mediaを `autoplay$a にする
等々。
◎
User agents may add content to the head element of the Document, or attributes to the element host element, e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.
</p>

			</section>
			<section id="read-plugin">
<h4 title="Page load processing model for content that uses plugins">7.10.7. ~pluginを利用する内容~用の~page読込n処理~model</h4>

<div class="algo">
<p>
外部~資源を具現化することを要する資源を読込むことになるときは、~UAは，供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，次を行うベキである：
◎
When a resource that requires an external resource to be rendered is to be loaded, provided navigation params navigationParams and a string type, the user agent should:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParmas.
</li>
	<li>
%文書 を
`~plugin文書@
とする
◎
Mark document as being a plugin document
</li>
	<li>
`文書$に `html$e 要素を付加する
◎
Append an html element to document.
</li>
	<li>
`html$e 要素に `head$e 要素を付加する
◎
Append a head element to the html element.
</li>
	<li>
`html$e 要素に `body$e 要素を付加する
◎
Append a body element to the html element.
</li>
	<li>
`body$e 要素に `embed$e 要素を付加する
◎
Append an embed to the body element
</li>
	<li>
`embed$e 要素の `~src-embed$a 属性を資源の~addressに設定する
◎
Set the src attribute of the embed element to the address of the resource.
</li>
</ol>
</div>

<p class="note">注記：
用語 `~plugin文書$は、次を確保する仕組みの一部として，
`CSP$r により利用される
⇒
`iframe$e を利用しても，
`plugin-types^dir 指令をかいくぐることはできない
【この指令は CSP から除去されたので、この注記は今やイミを成さない。】
◎
The term plugin document is used by Content Security Policy as part of the mechanism that ensures iframes can't be used to evade plugin-types directives. [CSP]
</p>

<p>
次に，~UAは、`構文解析を停止した$かのように動作するモノトスル。
◎
Then, the user agent must act as if it had stopped parsing.
</p>

<p>
~UAは、`文書$ %文書 を作成した後, かつ
~pageを構文解析し終えて`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has finished fully loading, the user agent must update the session history with the new page given navigationParams and the newly-created Document.
</p>

<p>
~UAは［
`文書$の `head$e 要素 ／
`embed$e 要素の属性
］に内容を追加してもヨイ
— 例：
~stylesheetへ~linkする,
文書に `title$e を与える,
等々。
◎
User agents may add content to the head element of the Document, or attributes to the embed element, e.g. to link to a style sheet or to give the document a title.
</p>

<p id="sandboxPluginNavigate" class="note">注記：
［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN `文書$の`作動中の~sandbox法~flag集合$
］の下で［
関連な`~plugin$を`~secure化でき$なかった
］場合には、合成された `embed$e 要素は，
<a href="~HEembed#sandboxPluginEmbed">内容を具現化するのに失敗する</a>ことになる。
◎
If the Document's active sandboxing flag set has its sandboxed plugins browsing context flag set, the synthesized embed element will fail to render the content if the relevant plugin cannot be secured.
</p>

			</section>
			<section id="read-ua-inline">
<h4 title="Page load processing model for inline content that doesn't have a DOM">7.10.8. ~DOMを有さない~inline内容~用の~page読込n処理~model</h4>

<div class="algo">
<p>
~UAは、~pageを~inlineに表示するときは、供された
( `閲覧文脈$ %B )
に対し，次を行うベキである：
◎
When the user agent is to display a user agent page inline, provided a browsing context browsingContext, the user agent should:
</p>
<ol>
	<li>
<p>
%~navi~params ~LET 次のようにされた新たな`~navi~params$
⇒＃
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET ~NULL†,
`生成元$nvP ~SET 新たな`不透明な生成元$,
`最終-~sandbox~flag集合$nvP ~SET 空~集合,
`非同一-生成元~opener施策$nvP ~SET 新たな`非同一-生成元~opener施策$,
`~COOP施行n結果$nvP ~SET 新たな`非同一-生成元~opener施策の施行n結果$,
`予約-済み環境$nvP ~SET ~NULL,
`閲覧文脈$nvP ~SET %B
◎
Let navigationParams be a new navigation params whose request is null, response is null, origin is a new opaque origin, final sandboxing flag set is an empty set, cross-origin opener policy is a new cross-origin opener policy, COOP enforcement result is a new cross-origin opener policy enforcement result, reserved environment is null, and browsing context is browsingContext.
</p>

<p class="XXX">†
次の段で~callされる~algoは、 ~NULL にされた`応答$nvPを どう処するか~~指定していない。
おそらく，代わりになる応答を合成するベキである。
◎
The algorithm called in the next step is not prepared to deal with a null response. Probably we should synthesize one instead.
</p>
	</li>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
次のいずれかを行う：
◎
Either＼
</p>
		<ul>
			<li>
%文書 を［
`文書$の通常の具現化~規則を利用して具現化されない
］ような~customな具現化に結付ける
◎
associate document with a custom rendering that is not rendered using the normal Document rendering rules, or＼
</li>
			<li>
%文書 を［
それが~UAが具現化しようと求める内容を表現する
］よう変異させる
◎
mutate document until it represents the content the user agent wants to render.
</li>
		</ul>
	</li>
</ol>
</div>

<p>
~UAは、~pageが設定しておかれたなら，`構文解析を停止した$かのように動作するモノトスル。
◎
Once the page has been set up, the user agent must act as if it had stopped parsing.
</p>

<p>
~UAは、`文書$ %文書 を作成した後, かつ
~pageを完全に設定して`なければその前に$，次を走らすモノトスル
⇒
`新たな~pageで~session履歴を更新する$( %~navi~params, %文書 )
◎
After creating the Document object, but potentially before the page has been completely set up, the user agent must update the session history with the new page given navigationParams and the newly-created Document.
</p>

			</section>
			<section id="scroll-to-fragid">
<h4 title="Navigating to a fragment">7.10.9. 素片への~navigate法</h4>

<div class="algo">
<p>
`素片へ~navigateする@
ときは、所与の
( `閲覧文脈$ %B, `~URL$ %~URL, `履歴を取扱うときの挙動$ %履歴~取扱い )
に対し，次を走らすモノトスル：
◎
To navigate to a fragment given a browsing context browsingContext, a URL url, and a history handling behavior historyHandling:
</p>
<ol>
	<li>
~Assert：
%~URL の`素片$url ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
%履歴 ~LET %B の`~session履歴$
◎
↓</li>
	<li>
<p>
~IF［
%履歴~取扱い ~NEQ `置換-$i
］
⇒
%履歴 から［
その`現在の~entry$より後にある~entryすべて
］を除去する
◎
If historyHandling is not "replace", then remove all the entries in browsingContext's session history after the current entry. (If the current entry is the last entry in the session history, then no entries are removed.)
</p>

<p class="note">注記：
これは、<a href="~HISTORY#history-notes">~UAの~UIに影響するとは限らない</a>。
◎
This doesn't necessarily have to affect the user agent's user interface.
</p>
	</li>
	<li>
`履歴~辿り~task源$から~queueされた`~task$のうち，次を満たすものすべてを除去する
⇒
`~task$の`文書$tK ~IN %B の`~top-level閲覧文脈$の`文書~族$
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in browsingContext's top-level browsing context's document family.
</li>
	<li>
%~entry ~LET 次を伴う新たな`~session履歴~entry$
⇒＃
`~URL$shE ~SET %~url,
`文書$shE ~SET `現在の~entry$の`文書$shE,
`~scroll復旧~mode$shE ~SET `現在の~entry$の`~scroll復旧~mode$shE
◎
Append a new session history entry to the session history whose URL is url, document is the current entry's document, and scroll restoration mode is the current entry's scroll restoration mode.
</li>
	<li>
%履歴 に %~entry を付加する
◎
↑</li>
	<li>
<p>
%~entry へ`履歴を辿る$
— 次を与える下で
⇒＃
`履歴の取扱い$i ~SET %履歴~取扱い,
`~eventは他を阻まない$i ~SET ~T
◎
Traverse the history to the new entry, with historyHandling set to historyHandling and with nonBlockingEvents set to true.＼
</p>

<p class="note">注記：
これは、今や文書の`~URL$docになった %~URL の`素片へ~scrollする$ことになる。
素片が指す`~ID$を有する要素が まだ構文解析されていないため，~scrollできなかった場合、代わりに，元の`~navi$~algoから呼ばれる［
`新たな~pageで~session履歴を更新する$~algo
］の最後の方で，~scrollingが~careされることになる。
◎
This will scroll to the fragment given in what is now the document's URL.
◎
If the scrolling fails because the relevant ID has not yet been parsed, then the original navigation algorithm will take care of the scrolling instead, as the last few steps of its update the session history with the new page algorithm.
</p>
	</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
%文書 の
`素片へ~scrollする@
よう要求されたときは、~UAは，次を行うモノトスル：
◎
When the user agent is required to scroll to the fragment and＼
</p>
<ol>
	<li>
%部位 ~LET %文書 内の`指示された部位$doc
◎
the indicated part of the document,＼
</li>
	<li>
~IF［
%部位 ~EQ ε
］~OR［
%部位 は`具現化されて$いない
］
⇒
~RET
◎
if any, is being rendered,＼
</li>
	<li>
<p>
次のいずれかを行う：
◎
the user agent must either＼
</p>
		<ul>
			<li>
下に述べるように，文書の~scroll位置を %部位 に変更する。
◎
change the scrolling position of the document using the following algorithm,＼
</li>
			<li>
%部位 に利用者の注目を引くような他の何らかの動作を遂行する。
◎
or perform some other action such that the indicated part of the document is brought to the user's attention. If there is no indicated part, or if the indicated part is not being rendered, then the user agent must do nothing.＼
</li>
		</ul>
	</li>
</ol>

<!-- 初期時は null なので不要な記述 -->
</div>

<div class="algo">
<p>
`文書$ %文書 の~scroll位置を %部位 に変更するときは：
◎
The aforementioned algorithm is as follows:
</p>
<ol>
	<li>
%文書 の`標的~要素$ ~SET ~NULL
◎
If there is no indicated part of the document, set the Document's target element to null.
</li>
	<li>
<p>
%部位 に応じて：
</p>

		<dl class="switch">
			<dt>`文書の上端^i
◎
If the indicated part of the document is the top of the document, then:
</dt>
			<dd>
%文書 の`開始位置へ~scroll$する `CSSOMVIEW$r
◎
Set the Document's target element to null.
◎
Scroll to the beginning of the document for the Document. [CSSOMVIEW]
</dd>

			<dt>要素である
◎
Otherwise:
</dt>
			<dd>
				<ol>
					<li>
%文書 の`標的~要素$ ~SET %部位
◎
Let target be element that is the indicated part of the document.
◎
Set the Document's target element to target.
</li>
					<li>
%部位 を`~viewの中へ~scrollする$( `auto^l, `start^l, `nearest^l )
`CSSOMVIEW$r
◎
Scroll target into view, with behavior set to "auto", block set to "start", and inline set to "nearest". [CSSOMVIEW]
</li>
					<li>
`~objを~focusする$( %部位, %文書 の`表示域$ )
◎
Run the focusing steps for target, with the Document's viewport as the fallback target.
</li>
					<li>
%文書 における`逐次的~focus~naviの始点$ ~SET %部位
◎
Move the sequential focus navigation starting point to target.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>

<p>
`文書$ %文書 内の
`指示された部位@doc
は、`素片$urlがあれば，それが指示するものになる。
`素片$urlから~nodeにどう対応付けるかの意味論は、
%文書 が利用している`~MIME型$を定義する仕様により定義される（例えば、`~XML~MIME型$用の`素片$urlの処理は `RFC7303$r が担当する）。
◎
The indicated part of the document is the one that the fragment, if any, identifies. The semantics of the fragment in terms of mapping it to a node is defined by the specification that defines the MIME type used by the Document (for example, the processing of fragments for XML MIME types is the responsibility of RFC7303). [RFC7303]
</p>

<p>
各 `文書$には、 `target$ps 疑似類を定義するために利用される
`標的~要素@
がある。
それは、初期~時は~NULLであり，上の~algoで更新される。
◎
There is also a target element for each Document, which is used in defining the :target pseudo-class and is updated by the above algorithm. It is initially null.
</p>

<div class="algo">
<p>
~HTML文書（および， `~HTML~MIME型$ ） %文書 に対しては、
%文書 内の`指示された部位$docを決定するときは，次の処理~modelに従うモノトスル。
◎
For HTML documents (and HTML MIME types), the following processing model must be followed to determine what the indicated part of the document is.
</p>
<ol>
	<li>
%素片 ~LET %文書 の`~URL$docの`素片$url
◎
Let fragment be the document's URL's fragment.
</li>
	<li>
~Assert：
%素片 ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
~IF［
%素片 ~EQ 空~文字列
］
⇒
~RET `文書の上端^i
◎
If fragment is the empty string, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with fragment returns non-null, then the return value is the indicated part of the document; return.
</li>
	<li>
%素片~byte列 ~SET `文字列を~byte列に~percent-復号する$( %素片 )
◎
Let fragmentBytes be the result of percent-decoding fragment.
</li>
	<li>
%復号-済み素片 ~LET `~BOMはそのままに~UTF-8復号する$( %素片~byte列 )
◎
Let decodedFragment be the result of running UTF-8 decode without BOM on fragmentBytes.
</li>
	<li>
~IF［
`指示された要素を見出す$( %文書, %復号-済み素片 ) ~NEQ ~NULL
］
⇒
~RET その結果
◎
If find a potential indicated element with decodedFragment returns non-null, then the return value is the indicated part of the document; return.
</li>
	<li>
~IF［
%復号-済み素片 ~EQ`大小無視$sub `top^l
］
⇒
~RET `文書の上端^i
◎
If decodedFragment is an ASCII case-insensitive match for the string top, then the indicated part of the document is the top of the document; return.
</li>
	<li>
~RET ε
◎
There is no indicated part of the document.
</li>
</ol>
</div>

<div class="algo">
<p>
`指示された要素を見出す@
ときは、所与の
( `文書$ %文書, 文字列 %素片 )
に対し，次を走らす：
◎
To find a potential indicated element given a string fragment, run these steps:
</p>
<ol>
	<li>
~IF［
%文書 の`~tree内$に［
`~ID$ ~EQ %素片
］を満たす要素はある
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an element in the document tree that has an ID equal to fragment, then return the first such element in tree order.
</li>
	<li>
~IF［
%文書 の`~tree内$に［
`name$a 属性を有していて，その値 ~EQ %素片
］を満たす `a$e 要素はある
］
⇒
~RET 該当する要素のうち，`~tree順序$で最初のもの
◎
If there is an a element in the document tree that has a name attribute whose value is equal to fragment, then return the first such element in tree order. 
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

			</section>
			<section id="history-traversal">
<h4 title="History traversal">7.10.10. 履歴の辿り</h4> 

<div class="algo">
<div class="p">
<p>
`~session履歴~entry$ %~entry へ
`履歴を辿る@
~algoは、次も入力にとり，以下を走らすモノトスル：
</p>
<ul>
	<li>
`履歴を取扱うときの挙動$
`履歴の取扱い@V
（省略時は `既定$i ）
</li>
	<li>
真偽値
`~eventは他を阻まない@V
（省略時は ~F ）
</li>
	<li>
真偽値
`明示的な履歴~navi@V
（省略時は ~F ）
</li>
</ul>
◎
To traverse the history to a session history entry entry, with an optional history handling behavior historyHandling (default "default"), an optional boolean nonBlockingEvents (default false), and an optional boolean explicitHistoryNavigation (default false):
</div>

<p class="note">注記：
この~algoは、明示的に`履歴を前／後に辿る$ときのみならず，他の状況においても呼出される
— 例えば、閲覧文脈を`~navigate$するときに，`新たな~pageで~session履歴を更新する$一部として。
◎
This algorithm is not just invoked when explicitly going back or forwards in the session history — it is also invoked in other situations, for example when navigating a browsing context, as part of updating the session history with the new page.
</p>
<ol>
	<li>
%履歴 ~LET %~entry が属する`~session履歴$
◎
↓</li>
	<li>
%B ~LET %履歴 を有する`閲覧文脈$
◎
↓</li>
	<li>
%現在の~entry ~LET %履歴 の`現在の~entry$
◎
↓</li>
	<li>
<p>
~IF［
%~entry の`文書$shE ~EQ ~NULL
］：
◎
If entry's document is null, then:
</p>
		<ol>
			<li>
~Assert：
履歴の取扱い ~EQ `既定$i
◎
Assert: historyHandling is "default".
</li>
			<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒
`~URL$rq ~SET %~entry の`~URL$shE
◎
Let request be a new request whose url is entry's URL.
</li>
			<li>
~IF［
%明示的な履歴~navi ~EQ ~T
］
⇒
%要請 の`履歴~navi~flag$rq ~SET ~T
◎
If explicitHistoryNavigation is true, then set request's history-navigation flag.
</li>
			<li>
<p>
%B を %要請 へ`~navigate$する
— 次を与える下で
⇒＃
`履歴~取扱い$i ~SET `~entry更新$i
`~source閲覧文脈$ ~SET %~entry を最初に作成したときに利用した`~source閲覧文脈$
◎
Navigate the browsing context to request with historyHandling set to "entry update". The navigation must be done using the same source browsing context as was used the first time entry was created.
</p>

<p class="note">注記：
`~navigate$ ~algoは、辿りを完了するために，この~algoを再び呼出す
— %~entry の`文書$shEは、その時点で ~NULL 以外になる。
◎
The "navigate" algorithm reinvokes this "traverse" algorithm to complete the traversal, at which point entry's document is non-null.
</p>

<p class="note">注記：
資源が非冪等~動作を利用して得されたものであった場合（ 例えば `POST^hm による~form提出）や, 資源はもはや可用でない場合（例えば~computerは今や~offlineになっていて，~pageも~cacheされていないため）など、再度そこへ~navigateできないこともある。
この事例では、~naviの結果は，以前と異なる~pageになる
— 例えば，問題を説明する~error~messageや, ~formを再度~提出する~UIを提供するなど。
◎
If the resource was obtained using a non-idempotent action, for example a POST form submission, or if the resource is no longer available, for example because the computer is now offline and the page wasn't cached, navigating to it again might not be possible. In this case, the navigation will result in a different page than previously; for example, it might be an error message explaining the problem or offering to resubmit the form.
</p>
			</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%現在の~entry に`持続される状態を保存する$
◎
Save persisted state to the current entry.
</li>
	<li>
%新たな文書 ~LET %~entry の`文書$shE
◎
Let newDocument be entry's document.
</li>
	<li>
%現在の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
	<li>
~Assert：
%現在の文書 ~EQ %現在の~entry の`文書$shE
【この段は、この訳による補完。】
</li>
	<li>
<p>
~IF［
%新たな文書 ~NEQ %現在の文書
］~OR［
%履歴~取扱い ~IN { `~entry更新$i, `再読込み$i }
］：
◎
If newDocument is different than the current entry's document, or historyHandling is "entry update" or "reload", then:
</p>
		<ol>
			<li>
`履歴~辿り~task源$から~queueされた`~task$のうち，次を満たすものすべてを除去する
⇒
`~task$の`文書$tK ~IN %B の`~top-level閲覧文脈$の`文書~族$
◎
Remove any tasks queued by the history traversal task source that are associated with any Document objects in the top-level browsing context's document family.
</li>
			<li>
<p>
~IF［
%新たな文書 の`生成元$doc ~NEQ`生成元$sub %現在の文書 の`生成元$doc
］：
◎
If newDocument's origin is not same origin with the current entry's document's origin, then:
</p>
				<ol>
					<li>
%履歴 を成す
~EACH( ~entry %e )
に対し
⇒
~IF［
%e の`文書$shEの`生成元$doc ~EQ`生成元$sub %現在の文書 の`生成元$doc
］~AND［
%e は %現在の~entry と連続的である
【<a href="~HISTORY#_contiguous">~~参照</a>】
］
⇒
%e の`閲覧文脈~名$shE ~SET %B の`閲覧文脈~名$
◎
Let entriesToUpdate be all entries in the session history whose document's origin is same origin as the active document and that are contiguous with the current entry.
◎
For each entryToUpdate of entriesToUpdate, set entryToUpdate's browsing context name to the current browsing context name.
</li>
					<li id="resetBCName">
~IF［
%B は`~top-level閲覧文脈$である
］~AND［［
%B は`補助~閲覧文脈$でない
］~OR［
%B の`未所有化~flag$ ~EQ ~T
］］
⇒
%B の`閲覧文脈~名$ ~SET 空~文字列
◎
If the browsing context is a top-level browsing context, but not an auxiliary browsing context whose disowned is false, then set the browsing context's name to the empty string.
</li>
				</ol>
			</li>
			<li>
`閲覧文脈にて作動中の文書を設定する$( %B, %新たな文書 )
◎
Set the active document of the browsing context to newDocument.
</li>
			<li>
~Assert：
%B にて`作動中の文書$ ~EQ %新たな文書
【この段は、この訳による補完。】
</li>
			<li>
<p>
~IF［
%~entry の`閲覧文脈~名$shE ~NEQ ~NULL
］：
◎
If entry's browsing context name is not null, then:
</p>
				<ol>
					<li>
%B の`閲覧文脈~名$ ~SET %~entry の`閲覧文脈~名$shE
◎
Set the browsing context's name to entry's browsing context name.
</li>
					<li>
%履歴 を成す
~EACH( ~entry %e )
に対し
⇒
~IF［
%e の`文書$shEの`生成元$doc ~EQ`生成元$sub %新たな文書 の`生成元$doc
］~AND［
%e は %~entry と連続的である【<a href="~HISTORY#_contiguous">~~参照</a>】
］
⇒
%e の`閲覧文脈~名$shE ~SET ~NULL
◎
Let entriesToUpdate be all entries in the session history whose document's origin is same origin as the new active document's origin and that are contiguous with entry.
◎
For each entryToUpdate of entriesToUpdate, set entryToUpdate's browsing context name to null.
</li>
				</ol>
			</li>
			<li id="history-autocomplete">
%新たな文書 内の
~EACH( ~form~control %E )
に対し
⇒
~IF［
%E の`~autofill欄~名$ ~EQ `off$v
］
⇒
%E の`再設定~algo$を呼出す
◎
If newDocument has any form controls whose autofill field name is "off", invoke the reset algorithm of each of those elements.
</li>
			<li>
<p>
~IF［
%新たな文書 の`現在の準備度$doc ~EQ `complete^l
］
⇒
次を走らす`大域~taskを~queueする$( `~DOM操作~task源$, %新たな文書 に`関連な大域~obj$ )
◎
If newDocument's current document readiness "complete", then queue a global task on the DOM manipulation task source given newDocument's relevant global object to run the following steps:
</p>
				<ol>
					<li>
~IF［
%新たな文書 の`~page表示中~flag$doc ~EQ ~T
］
⇒
~RET
◎
If newDocument's page showing flag is true, then abort these steps.
</li>
					<li>
%新たな文書 の`~page表示中~flag$doc ~SET ~T
◎
Set newDocument's page showing flag to true.
</li>
					<li>
<p>
`適用-可能な仕様$により定義されている
`~session履歴~文書の可視性を変更する手続き@
があれば、それらの各~手続きを
%新たな文書 を渡して走らす
◎
Run any session history document visibility change steps for newDocument that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、特定的には，
`Page Visibility^cite `PAGEVIS$r
からの利用に意図されている。
◎
This is specifically intended for use by Page Visibility. [PAGEVIS]
</p>
					</li>
					<li>
%新たな文書 に`関連な大域~obj$に向けて，名前 `pageshow$et の`~eventを発火する$( `~targetを上書きする^i )
— `PageTransitionEvent$I を利用し，次のように初期化して
⇒＃
`persisted$m 属性 ~SET ~T
◎
Fire an event named pageshow at newDocument's relevant global object, using PageTransitionEvent, with the persisted attribute initialized to true, and legacy target override flag set.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%新たな文書 の`~URL$doc ~SET %~entry の`~URL$shE
◎
Set newDocument's URL to entry's URL.
</li>
			<li>
%~hashは変化した ~LET ~F
◎
Let hashChanged be false,＼
</li>
			<li>
%旧-~URL ~LET ~NULL
◎
and let oldURL＼
</li>
			<li>
%新-~URL ~LET ~NULL
◎
and newURL be null.
</li>
			<li>
~IF［
%~entry の`~URL$shEの`素片$url ~NEQ【！identical】
%現在の~entry の`~URL$shEの`素片$url
］~AND［
%新たな文書【！%~entry の`文書$shE】 ~EQ %現在の文書
］
⇒＃
%~hashは変化した ~SET ~T；
%旧-~URL ~SET %現在の~entry の`~URL$shE；
%新-~URL ~SET %~entry の`~URL$shE；
◎
If entry's URL's fragment is not identical to the current entry's URL's fragment, and entry's document equals the current entry's document, then set hashChanged to true, set oldURL to the current entry's URL, and set newURL to entry's URL.
</li>
			<li>
~IF［
%履歴の取扱い ~EQ `置換-$i
］
⇒
%履歴 内で %~entry の直前にある~entryを除去する
◎
If historyHandling is "replace", then remove the entry immediately before entry in the session history.
</li>
			<li>
~IF［
%~entry の`持続される利用者~状態$shE ~EQ ~NULL
］~AND［
%~entry の`~URL$shEの`素片$url ~NEQ ~NULL
］
⇒
%新たな文書 を`素片へ~scrollする$
◎
If entry's persisted user state is null, and its URL's fragment is non-null, then scroll to the fragment.
</li>
			<li>
%履歴 の`現在の~entry$ ~SET %~entry
◎
Set the current entry to entry.
</li>
			<li>
%宛先~realm ~LET `現在の~Realm~Record$
◎
Let targetRealm be the current Realm Record.
</li>
			<li>
%状態 ~LET ~NULL
◎
Let state be null.
</li>
			<li>
~IF［
%~entry の`直列形の状態$shE ~NEQ ~NULL
］
⇒
%状態 ~SET `StructuredDeserialize$jA( %~entry の`直列形の状態$shE, %宛先~realm )
⇒
例外が投出されたときは、~catchして （例外は無視する）
◎
If entry's serialized state is not null, then set state to StructuredDeserialize(entry's serialized state, targetRealm). If this throws an exception, catch it and ignore the exception.
</li>
			<li>
%新たな文書 の `History$I ~objの`状態$hsT ~SET %状態
◎
Set newDocument's History object's state to state.
</li>
			<li>
%状態は変化した ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%新たな文書 の`最近の~entry$ ~NIN { ε, %~entry }
◎
Let stateChanged be true if newDocument has a latest entry, and that entry is not entry; otherwise let it be false.
</li>
			<li>
%新たな文書 の`最近の~entry$ ~SET %~entry
◎
Set newDocument's latest entry to entry.
</li>
			<li>
<div class="p">
<p>
%~eventは他を阻まない に応じて：
</p>
		<ul>
			<li>
~F
⇒
下に与える下位手続き (A) を`即時$に走らす
</li>
			<li>
~T
⇒
下に与える下位手続き (A) を走らす`大域~taskを~queueする$( `~DOM操作~task源$, %新たな文書 に`関連な大域~obj$ )
</li>
		</ul>
<p>
下位手続き (A) は、次を走らすとする：
</p>

◎
If nonBlockingEvents is false, then run the following steps immediately.＼
Otherwise, queue a global task on the DOM manipulation task source given newDocument's relevant global object to run the following steps instead.
</div>

		<ol>
			<li>
~IF［
%状態は変化した ~EQ ~T
］
⇒
%新たな文書 に`関連な大域~obj$に向けて，名前 `popstate$et の`~eventを発火する$
— `PopStateEvent$I を利用し，次のように初期化して
⇒＃
`state$m 属性 ~SET %状態
◎
If stateChanged is true, then fire an event named popstate at newDocument's relevant global object, using PopStateEvent, with the state attribute initialized to state.
</li>
			<li>
%~entry から`持続された状態を復旧する$
◎
Restore persisted state from entry.
</li>
			<li>
~IF［
%~hashは変化した ~EQ ~T
］
⇒
%B にて`作動中の~window$に向けて，名前 `hashchange$et の`~eventを発火する$
— `HashChangeEvent$I を利用し，次のように初期化して
⇒＃
`oldURL$m 属性 ~SET %旧-~URL,
`newURL$m 属性 ~SET %新-~URL
◎
If hashChanged is true, then fire an event named hashchange at the browsing context's active window, using HashChangeEvent, with the oldURL attribute initialized to oldURL and the newURL attribute initialized to newURL.
</li>
		</ol>
	</li>
</ol>
</div>

				<section id="persisted-user-state-restoration">
<h5 title="Persisted history entry state">7.10.10.1 持続される履歴~entry状態</h5>

<div class="algo">
<p>
`~session履歴~entry$ %~entry に
`持続される状態を保存する@
ときは：
◎
To save persisted state to a session history entry entry:
</p>
<ol>
	<li>
%~entry の`~scroll位置~data$shEを［
%~entry の`文書$shEの`復旧-可能な~scroll可能な領域$
］すべての~scroll位置を包含するように設定する
◎
Set the scroll position data of entry to contain the scroll positions for all of entry's document's restorable scrollable regions.
</li>
	<li>
任意選択で
⇒
各~form欄の値など，~UAが持続するよう望む状態があれば、それらを反映するように，
%~entry の`持続される利用者~状態$shEを更新する
◎
Optionally, update entry's persisted user state to reflect any state that the user agent wishes to persist, such as the values of form fields.
</li>
</ol>
</div>

<div class="algo">
<p>
`~session履歴~entry$ %~entry から
`持続された状態を復旧する@
ときは：
◎
To restore persisted state from a session history entry entry:
</p>
<ol>
	<li>
<p>
任意選択で
⇒
~IF［
%~entry の`~scroll復旧~mode$shE ~EQ `auto$l
］
⇒
%~entry の`~scroll位置~data$shEを利用して［
%~entry の`文書$shEの`復旧-可能な~scroll可能な領域$の各~scroll位置
］を復旧する
◎
If entry's scroll restoration mode is "auto", then the user agent may use entry's scroll position data to restore the scroll positions of entry's document's restorable scrollable regions.
</p>

<p class="note">注記：
~UAが~scroll位置を復旧しないことは、［
~scroll位置を特定0の値（例： (0,0) ）に~~保つ
］ことは含意しない。
実際の~scroll位置は、［
~naviの種別や,
~UAによる~caching-strategy
］に依存する。
なので、~web~appは，特定0の~scroll位置に決まるとは見做せない
— ~appには、自身が求めるものに設定することが督促される。
◎
The user agent not restoring scroll positions does not imply that scroll positions will be left at any particular value (e.g., (0,0)). The actual scroll position depends on the navigation type and the user agent's particular caching strategy. So web applications cannot assume any particular scroll position but rather are urged to set it to what they want it to be.
</p>
	</li>
	<li>
<p>
任意選択で
⇒
%~entry の`文書$shEとその具現化を成す他の側面を更新する
— 一例として，~UAが以前に %~entry の`持続される利用者~状態$shE内に記録した~form欄の値など。
◎
Optionally, update other aspects of entry's document and its rendering, for instance values of form fields, that the user agent had previously recorded in entry's persisted user state.
</p>

<p class="note">注記：
持続される状態が，そのような~controlにおける利用者~入力の書字方向性を含む場合、これには，次に該当する要素の `dir$a 属性を更新することも含まれる
⇒
`textarea$e 要素 ／
`input$e 要素のうち［
その `type$a 属性の状態 ~IN { `Text$st, `Search$st }
］を満たすもの
◎
This can even include updating the dir attribute of textarea elements or input elements whose type attribute is in either the Text state or the Search state, if the persisted state includes the directionality of user input in such controls.
</p>
	</li>
</ol>
</div>

<hr>

<p>
`文書$ %文書 の
`復旧-可能な~scroll可能な領域@
は、
%文書 の`表示域$, および［
%文書 の`子~閲覧文脈$を除く，
%文書 内の各~scroll可能な領域【~CSSによる`~scroll容器$など】
］すべてからなる。
◎
The restorable scrollable regions of a Document document are document's viewport, and all of document's scrollable regions excepting any child browsing contexts of document.
</p>

<p class="note">注記：
`子~閲覧文脈$に対する~scroll復旧は、それらにて`作動中の文書$【！' Documents】用の`~session履歴~entry$により取扱われる。
◎
Child browsing context scroll restoration is handled by the history entry for those browsing contexts' Documents.
</p>

				</section>
				<section id="the-popstateevent-interface">
<h5 title="The PopStateEvent interface">7.10.10.2. `PopStateEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PopStateEvent@I : `Event$I {
  constructor(DOMString %type, optional `PopStateEventInit$I %eventInitDict = {});

  readonly attribute any `state$m;
};

dictionary `PopStateEventInit@I : `EventInit$I {
  any state = null;
};
</pre>

<dl class="domintro">
	<dt>%event . `state$m</dt>
	<dd>
`pushState()$m ／ `replaceState()$m
に供された情報の複製を返す。
◎
Returns a copy of the information that was provided to pushState() or replaceState().
</dd>
</dl>

<dl class="idl-def">
	<dt>`state@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The state attribute must return the value it was initialized to.＼
</dd>
	<dd>
この~event用の文脈~情報を表現する。
表現される状態が`文書$の初期~状態の場合は ~NULL になる。
◎
It represents the context information for the event, or null, if the state represented is the initial state of the Document.
</dd>
</dl>

				</section>
				<section id="the-hashchangeevent-interface">
<h5 title="The HashChangeEvent interface">7.10.10.3. `HashChangeEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `HashChangeEvent@I : `Event$I {
  constructor(DOMString %type, optional `HashChangeEventInit$I %eventInitDict = {});

  readonly attribute USVString `oldURL$m;
  readonly attribute USVString `newURL$m;
};

dictionary `HashChangeEventInit@I : `EventInit$I {
  USVString oldURL = "";
  USVString newURL = "";
};
</pre>

<dl class="domintro">
	<dt>%event . `oldURL$m</dt>
	<dd>
履歴を辿る直前の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that was previously current.
</dd>
	<dt>%event . `newURL$m</dt>
	<dd>
履歴を辿った直後の`~session履歴~entry$の`~URL$を返す。
◎
Returns the URL of the session history entry that is now current.
</dd>
</dl>

<dl class="idl-def">
	<dt>`oldURL@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The oldURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、この~event用の文脈~情報
— 特定的には、履歴を辿る直前の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed from.
</dd>

	<dt>`newURL@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The newURL attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、この~event用の文脈~情報
— 特定的には、履歴を辿った直後の`~session履歴~entry$の~URL —
を表現する。
◎
It represents context information for the event, specifically the URL of the session history entry that was traversed to.
</dd>
</dl>

				</section>
				<section id="the-pagetransitionevent-interface">
<h5 title="The PageTransitionEvent interface">7.10.10.4. `PageTransitionEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `PageTransitionEvent@I : `Event$I {
  constructor(DOMString %type, optional `PageTransitionEventInit$I %eventInitDict = {});

  readonly attribute boolean `persisted$m;
};

dictionary `PageTransitionEventInit@I : `EventInit$I {
  boolean persisted = false;
};
</pre>

<dl class="domintro">
	<dt>%event . `persisted$m</dt>
	<dd>
`pageshow$et ~eventに対しては、［
当の~pageが新たに読込まれつつある（したがって `load$et ~eventが発火されることになる）ならば ~F ／
~ELSE_ ~T
］を返す。
◎
For the pageshow event, returns false if the page is newly being loaded (and the load event will fire). Otherwise, returns true.
</dd>
	<dd>
`pagehide$et ~eventに対しては、［
当の~pageが最後に消え去るときには ~F ／
~ELSE_ ~T
］を返す。
~T は、この~pageは，利用者がこの~pageに~navigateして戻った場合に（かつ，当の`文書$の`回復可能~状態$docが ~T のままであれば）再利用され得ることを意味する。
◎
For the pagehide event, returns false if the page is going away for the last time. Otherwise, returns true, meaning that the page might be reused if the user navigates back to this page (if the Document's salvageable state stays true).
</dd>
	<dd>
<p>
~pageを回復可能でなくするものには、次が含まれる：
◎
Things that can cause the page to be unsalvageable include:
</p>
		<ul>
			<li>
~UAは、当の`文書を~unload$した後に，［
その文書は，`~session履歴~entry$内で生存し続けない
］ものと裁定した
◎
The user agent decided to not keep the Document alive in a session history entry after unload
</li>
			<li>
`回復可能$でない `iframe$e があるとき
◎
Having iframes that are not salvageable
</li>
			<li>
作動中の `WebSocket$I ~objがあるとき
◎
Active WebSocket objects
</li>
			<li>
`文書を中止-$したとき
◎
Aborting a Document
</li>
		</ul>
	</dd>
</dl>

<dl class="idl-def">
	<dt>`persisted@m</dt>
	<dd>
取得子は、初期化-時の値を返すモノトスル。
◎
The persisted attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは~eventの文脈~情報を表現する。
◎
It represents the context information for the event.
</dd>
</dl>

				</section>
			</section>
			<section id="loading-documents">
<h4 title="Loading documents">7.10.11. 文書の読込n法</h4>

<p>
各 `文書$には
`完全に読込まれた時刻@
（ある時刻または ~NULL ）があり、初期~時には ~NULL とする。
◎
A Document has a completely loaded time (a time or null), which is initially null.
</p>

<p>
所与の`文書$は、`完全に読込まれた時刻$ ~NEQ ~NULL ならば
`完全に読込まれた@
ものと見なされる。
◎
A Document is considered completely loaded if its completely loaded time is non-null.
</p>

<div class="algo">
<p>
`文書$ %文書 の
`読込ngを完全に終わらす@
ときは：
◎
To completely finish loading a Document document:
</p>
<ol>
	<li>
~Assert：
%文書 が`属する閲覧文脈$ ~NEQ ~NULL
◎
Assert: document's browsing context is non-null.
</li>
	<li>
%文書 の`完全に読込まれた時刻$ ~SET 現在の時刻
◎
Set document's completely loaded time to the current time.
</li>
	<li>
%容器 ~LET %文書 が`属する閲覧文脈$の`容器$bc
◎
Let container be document's browsing context's container.
</li>
	<li>
~IF［
%容器 は `iframe$e 要素である
］
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %容器 )
⇒
`~iframe~load~event手続き$( %容器 )
◎
If container is an iframe element, then queue an element task on the DOM manipulation task source given container to run the iframe load event steps given container.
</li>
	<li>
~ELIF［
%容器 ~NEQ ~NULL
］
⇒
次を走らす`要素~taskを~queueする$ `~DOM操作~task源$, %容器 )
⇒
%容器 に向けて名前 `load$et の`~eventを発火する$
◎
Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.
</li>
</ol>
</div>

			</section>
			<section id="unloading-documents">
<h4 title="Unloading documents">7.10.12. 文書の~unload法</h4>

<div class="p">
<p>
`文書$は、次のものを持つ：
</p>
<dl>
	<dt>`回復可能~状態@doc</dt>
	<dd>
初期~時には ~T になるモノトスル。
</dd>

	<dt>`~page表示中~flag@doc</dt>
	<dd>
初期~時には ~F になるモノトスル。
この~flagは、~scriptが［
`pageshow$et, `pagehide$et
］~eventを整合的に受取る（例： `pageshow$et を間に挟むことなく 2 つの `pagehide$et ~eventを続けて受取ったり，その逆が生じることは決してない）ことを確保するために利用される。
</dd>
</dl>

◎
A Document has a salvageable state, which must initially be true, and a page showing flag, which must initially be false. The page showing flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).
</div>

<p>
各`~event~loop$は、
`終了n入子ng~level@
と呼ばれる~counterを有する
— 初期~時には 0 になるモノトスル。
◎
Event loops have a termination nesting level counter, which must initially be 0.
</p>

<div class="algo">
<p>
`文書の~unloadを~promptする@
ときは、所与の
( `文書$ %文書, %再帰的~flag ~IN { `再帰的^i, ε }（省略時は ε ） )
に対し，次を走らす：
◎
To prompt to unload, given a Document object document and optionally a recursiveFlag, run these steps:
</p>
<ol>
	<li>
`~event~loop$の`終了n入子ng~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by 1.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase the document's ignore-opens-during-unload counter by 1.
</li>
	<li>
%event ~LET `~eventを作成する$( `BeforeUnloadEvent$I )
◎
Let event be the result of creating an event using BeforeUnloadEvent.
</li>
	<li>
%event の属性を次のように初期化する
⇒＃
`type$m ~SET `beforeunload$et,
`cancelable$m ~SET ~T
◎
Initialize event's type attribute to beforeunload and its cancelable attribute true.
</li>
	<li>
%文書 に`関連な大域~obj$に向けて %event を`配送する$
◎
Dispatch: Dispatch event at document's relevant global object.
</li>
	<li>
`~event~loop$の`終了n入子ng~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by 1.
</li>
	<li>
<p>
~IF［
次がすべて満たされる
］…：
◎
If all of the following are true:
</p>
		<ul>
			<li>
`~sandbox化( ~modal )~flag$ ~NIN %文書 の`作動中の~sandbox法~flag集合$
◎
document's active sandboxing flag set does not have its sandboxed modals flag set
</li>
			<li>
%文書 に`関連な大域~obj$の`非一過な作動化$ ~EQ ~T
◎
document's relevant global object has sticky activation
</li>
			<li>
［
%event の`取消d~flag$ ~EQ ~T
］~OR［
%event の `returnValue$m 属性 ~NEQ 空~文字列
］
◎
event's canceled flag is set, or the returnValue attribute of event is not the empty string
</li>
		</ul>
<p>
…ならば
⇒
~UAは、利用者に %文書 の~unloadを望むかどうか確認をとってもヨイ：
◎
then the user agent may ask the user to confirm that they wish to unload the document.
</p>

<p class="note">注記：
利用者に示される~messageは、~custom化することはできず，~UAにより決定される。
特に、 `returnValue$m 属性の実際の値は無視される。
◎
The message shown to the user is not customizable, but instead determined by the user agent. In particular, the actual value of the returnValue attribute is ignored.
</p>
		<ul>
			<li>
~UAは，そうすることが利用者にとって［
いらつく／紛らわしい／的外れである
］と判定したときは、利用者に確認をとらないことが奨励される。
◎
The user agent is encouraged to avoid asking the user for confirmation if it judges that doing so would be annoying, deceptive, or pointless.
</li>
			<li>
~UAは，利用者に確認をとる場合には、利用者からの応答を待機している間，`静止-$するモノトスル。
◎
If the user agent asks the user for confirmation, it must pause while waiting for the user's response.
</li>
			<li>
利用者から~page~naviの確認をとれなかった場合、 %文書 の
`~unloadは利用者から拒否された@
とされる。
◎
If the user did not confirm the page navigation, then the user agent refused to allow the document to be unloaded.
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%再帰的~flag ~EQ ε
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
<p>
%文書 の`子孫~閲覧文脈~list$ 内の
~EACH( `閲覧文脈$ %B )
に対し：
◎
Let descendants be the list of the descendant browsing contexts of document.
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`文書の~unloadを~promptする$( %作動中の文書, `再帰的^i )
◎
Prompt to unload browsingContext's active document with the recursiveFlag set.
</li>
					<li>
~IF［
前~段にて，
%作動中の文書 の`~unloadは利用者から拒否された$
］
⇒
~BREAK
— その結果， %文書 についても暗黙的に`~unloadは利用者から拒否された$ことになる
◎
If the user refused to allow the document to be unloaded, then the user implicitly also refused to allow document to be unloaded; break.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease the document's ignore-opens-during-unload counter by 1.
</li>
</ol>
</div>

<div class="algo">
<p>
`文書を~unloadする@
ときは、所与の
⇒＃
`文書$ %文書,
%再帰的~flag ~IN { `再帰的^i, ε }（省略時は ε ）,
`文書~unload計時情報$または~NULL %~unload計時情報 （省略時は ~NULL ）
◎終
に対し，次を走らす：
◎
To unload a Document document, given an optional recursiveFlag and a document unload timing info-or-null unloadTimingInfo (default null):
</p>
<ol>
	<li>
`~event~loop$の`終了n入子ng~level$ ~INCBY 1
◎
Increase the event loop's termination nesting level by one.
</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~INCBY 1
◎
Increase document's ignore-opens-during-unload counter by one.
</li>
	<li>
<p>
~IF［
%文書 の`~page表示中~flag$doc ~EQ ~T
］：
◎
If document's page showing flag is false, then jump to the step labeled unload event below (i.e. skip firing the pagehide event and don't rerun the unloading document visibility change steps).
</p>
		<ol>
			<li>
%文書 の`~page表示中~flag$doc ~SET ~F
◎
Set document's page showing flag to false.
</li>
			<li>
~IF［
~UAは、［
%文書 は，（後で履歴の辿りに再利用できるよう）`~session履歴~entry$内で生存し続ける
］ものと意図しない
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the user agent does not intend to keep document alive in a session history entry (such that it can be reused later on history traversal), set document's salvageable state to false.
</li>
			<li>
%文書 に`関連な大域~obj$に向けて，名前 `pagehide$et の`~eventを発火する$( `~targetを上書きする^i )
— `PageTransitionEvent$I を利用し，次のように初期化して
⇒
`persisted$m 属性 ~SET %文書 の`回復可能~状態$doc
◎
Fire an event named pagehide at document's relevant global object, using PageTransitionEvent, with the persisted attribute initialized to true if document's salvageable state is true, and false otherwise, and legacy target override flag set.
</li>
			<li>
<p>
`適用-可能な仕様$により定義される
`~unload中の文書の可視性~変化-時の手続き@
があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any unloading document visibility change steps for document that are defined by other applicable specifications.
</p>

<p class="note">注記：
これは、特定的には，
`Page Visibility^cite `PAGEVIS$r
からの利用-に意図されている。
◎
This is specifically intended for use by Page Visibility. [PAGEVIS]
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~unload計時情報 ~NEQ ~NULL
］
⇒
%~unload計時情報 の`~unload~event開始~時刻$ ~SET `現在の高分解能~時刻$( %文書 に`関連な大域~obj$ )
◎
If unloadTimingInfo is not null, then set unloadTimingInfo's unload event start time to the current high resolution time given document's relevant global object.
</li>
	<li>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 に`関連な大域~obj$に向けて，名前 `unload$et の`~eventを発火する$( `~targetを上書きする^i )
◎
Unload event: If document's salvageable state is false, then fire an event named unload at document's relevant global object, with legacy target override flag set.
</li>
	<li>
~IF［
%~unload計時情報 ~NEQ ~NULL
］
⇒
%~unload計時情報 の`~unload~event終了~時刻$ ~SET `現在の高分解能~時刻$( %文書 の`関連な大域~obj$ )
◎
If unloadTimingInfo is not null, then set unloadTimingInfo's unload event end time to the current high resolution time given document's relevant global object.
</li>
	<li>
`~event~loop$の`終了n入子ng~level$ ~DECBY 1
◎
Decrease the event loop's termination nesting level by one.
</li>
	<li>
この仕様も含む`適用-可能な仕様$にて定義される
`文書~unload時の片付け手続き$があれば、それらの各~手続きを
%文書 を渡して走らす
◎
Run any unloading document cleanup steps for document that are defined by this specification and other applicable specifications.
</li>
	<li>
<p>
~IF［
%再帰的~flag ~EQ ε
］：
◎
If the recursiveFlag is not set, then:
</p>
		<ol>
			<li>
%子孫~list ~LET %文書 の`子孫~閲覧文脈~list$
◎
Let descendants be the list of the descendant browsing contexts of document.
</li>
			<li>
<p>
%子孫~list 内の
~EACH( `閲覧文脈$ %B )
に対し：
◎
For each browsingContext in descendants:
</p>
				<ol>
					<li>
%作動中の文書 ~LET %B にて`作動中の文書$
◎
↓</li>
					<li>
`文書を~unloadする$( %作動中の文書, `再帰的^i )
◎
Unload the active document of browsingContext with the recursiveFlag set.
</li>
					<li>
~IF［
%作動中の文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If the salvageable state of the active document of browsingContext is false, then set the salvageable state of document to false also.
</li>
				</ol>
			</li>
			<li>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
`文書を破棄する$( %文書 )
◎
If document's salvageable state is false, then discarddocument.
</li>
		</ol>
	</li>
	<li>
%文書 の`~unload中の~openは無視する~counter$ ~DECBY 1
◎
Decrease document's ignore-opens-during-unload counter by one.
</li>
</ol>
</div>

<div class="algo">
<p>
`適用-可能な仕様$は、
`文書~unload時の片付け手続き@
を定義できる。
この仕様が定義する`文書~unload時の片付け手続き$は、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
This specification defines the following unloading document cleanup steps. Other specifications can define more. Given a Document document:
</p>
<ol>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be document's relevant global object.
</li>
	<li>
~EACH( `WebSocket$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`消滅させる$
◎
For each WebSocket object webSocket whose relevant global object is window, make disappear webSocket.
</li>
	<li>
~IF［
前~段により影響された `WebSocket$I ~objはある
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
◎
If this affected any WebSocket objects, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 の`回復可能~状態$doc ~EQ ~F
］：
◎
If document's salvageable state is false, then:
</p>
		<ol>
			<li>
~EACH( `EventSource$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`強制的に閉じる$
◎
For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.
</li>
			<li>
%文書 の`~window$の`作動中の~timer~list$を空にする
◎
Empty window's list of active timers.
</li>
		</ol>
	</li>
</ol>
</div>

				<section id="the-beforeunloadevent-interface">
<h5 title="The BeforeUnloadEvent interface">7.10.12.1. `BeforeUnloadEvent^I ~interface</h5>

<pre class="idl">
[Exposed=Window]
interface `BeforeUnloadEvent@I : `Event$I {
  attribute DOMString `returnValue$m;
};
</pre>

<p class="note">注記：
`BeforeUnloadEvent$I に特有な初期化~methodはない。
◎
There are no BeforeUnloadEvent-specific initialization methods.
</p>

<p>
`BeforeUnloadEvent$I
~interfaceは、旧来の~interfaceである
— それは、~eventを取消すのみならず，
`returnValue$m 属性を空~文字列でない値に設定することで
`文書の~unloadを~promptする$処理を制御できるようにする。
作者は `returnValue$m を利用する代わりに `preventDefault()$m ~method, または~eventを取消す他の手段を利用するベキである。
◎
The BeforeUnloadEvent interface is a legacy interface which allows prompting to unload to be controlled not only by canceling the event, but by setting the returnValue attribute to a value besides the empty string. Authors should use the preventDefault() method, or other means of canceling events, instead of using returnValue.
</p>

<dl class="idl-def">
	<dt>`returnValue@m</dt>
	<dd>
この属性は、`文書の~unloadを~promptする$処理nを制御する。
◎
The returnValue attribute controls the process of prompting to unload.＼
</dd>
	<dd>
~eventの作成-時には、この属性は空~文字列に設定するモノトスル。
◎
When the event is created, the attribute must be set to the empty string.＼
</dd>
	<dd>
取得子は、この属性に最後に設定された値を返すモノトスル。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、この属性を所与の値に設定するモノトスル。
◎
On setting, the attribute must be set to the new value.
</dd>
	<dd class="note">注記：
この属性が `DOMString^I にされているのは、もっぱら歴史的な理由による。
空~文字列~以外のどの値も，利用者に確認をとるよう要請するものと扱われる。
◎
This attribute is a DOMString only for historical reasons. Any value besides the empty string will be treated as a request to ask the user for confirmation.
</dd>
</dl>

				</section>
			</section>
			<section id="aborting-a-document-load">
<h4 title="Aborting a document load">7.10.13. 文書~読込nの中止-法</h4>

<div class="algo">
<p>
`文書を中止する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To abort a Document document:
</p>
<ol>
	<li>
<p>
%文書 が`属する閲覧文脈$の
~EACH( `子~閲覧文脈$ %子 )
に対し：
</p>
		<ol>
			<li>
%子~文書 ~LET %子 にて`作動中の文書$
</li>
			<li>
`文書を中止する$( %子~文書 )
</li>
			<li>
~IF［
%子~文書 の`回復可能~状態$doc ~EQ ~F
］
⇒
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Abort the active documents of every child browsing context. If this results in any of those Document objects having their salvageable state set to false, then set document's salvageable state to false also.
</li>
	<li>
<p>
~IF［
%文書 の文脈~下にある`~fetch$~algoの~instanceたちがある
］
⇒
</p>
		<ol>
			<li>
<p>
それらを取消す
— 以降
⇒＃
それらに対し`~queueされ$る`~task$は破棄する ／
それらに対し~networkから受信される更なる~dataは破棄する
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
</li>
		</ol>

◎
Cancel any instances of the fetch algorithm in the context of document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 には`作動中の構文解析器$がある
］：
◎
If document has an active parser, then:
</p>
		<ol>
			<li>
%文書 の`作動中の構文解析器は中止された？$ ~SET ~T
◎
Set document's active parser was aborted to true.
</li>
			<li>
その`構文解析器を中止する$
◎
Abort that parser.
</li>
			<li>
%文書 の`回復可能~状態$doc ~SET ~F
◎
Set document's salvageable state to false.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
~UAは、利用者が明示的に`文書を中止する$~algoを呼出すことを許容してもヨイ。
利用者がそれをした場合，その`文書$ %文書 が`作動中の文書$であるならば、~UAは，`文書を中止する$~algoを呼出す前に次を行うベキである
⇒
次を走らす`~taskを~queueする$
⇒
%文書 に`関連な大域~obj$に向けて，名前 `abort$et の`~eventを発火する$
◎
User agents may allow users to explicitly invoke the abort a document algorithm for a Document. If the user does so, then, if that Document is an active document, the user agent should queue a task to fire an event named abort at that Document object's relevant global object before invoking the abort algorithm.
</p>
</div>

<div class="algo">
<p>
`文書の読込ngを停止する@
ときは、所与の
( `文書$ %文書 )
に対し，次を走らす：
◎
To stop document loading given a Document object document, run these steps:
</p>
<ol>
	<li>
~IF［
%文書 は`作動中の文書$でない
］
⇒
~RET
◎
If document is not an active document, then return.
</li>
	<li>
%閲覧文脈 ~LET %文書 が`属する閲覧文脈$
◎
Let browsingContext be document's browsing context.
</li>
	<li>
~IF［
%閲覧文脈 を`~navigate$しようとする既存の試みがある
］~AND［
その試みは`文書を~unloadする$~algoを現在~走らせていない
］
⇒
その`~navi$を取消す
◎
If there is an existing attempt to navigate browsingContext and that attempt is not currently running the unload a document algorithm, then cancel that navigation.
</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
</ol>
</div>

			</section>
			<section id="the-x-frame-options-header">
<h4 title="The X-Frame-Options header">7.10.14. `X-Frame-Options^h ~header</h4>

<p>
`X-Frame-Options$h ~HTTP応答~headerは、［
`文書$は`子~閲覧文脈$の内側に どう読込まれてもよいか
］を制御する，旧来の仕方である。
それは、［
同じ状況に対し，もっと細やかな制御を供する
`frame-ancestors$dir ~CSP指令 `CSP$r
］により，廃用にされた。
それは、元々は
`HTTP Header Field X-Frame-Options^cite `RFC7034$r
にて定義されたが，ここでの定義と処理~modelは、その文書に取って代わる。
◎
The `X-Frame-Options` HTTP response header is a legacy way of controlling whether and how a Document may be loaded inside of a child browsing context. It is obsoleted by the frame-ancestors CSP directive, which provides more granular control over the same situations. It was originally defined in HTTP Header Field X-Frame-Options, but the definition and processing model here supersedes that document. [CSP] [RFC7034]
</p>

<p class="note">注記：
特に，
`HTTP Header Field X-Frame-Options^cite
は、その~header値~用の変種として `ALLOW-FROM^bl も指定したが，それは実装されていない。
◎
In particular, HTTP Header Field X-Frame-Options specified an `ALLOW-FROM` variant of the header, but that is not to be implemented.
</p>

<p class="note">注記：
下に与える処理~modelにより、
`X-Frame-Options$h ~headerは，同じ`応答$内に
~CSP `frame-ancestors$dir 指令も利用された場合には無視される。
◎
Per the below processing model, if both a CSP frame-ancestors directive and an `X-Frame-Options` header are used in the same response, then `X-Frame-Options` is ignored.
</p>

<p>
［
~web開発者／適合性~検査器
］向けとして，その値の`~ABNF$は：
◎
For web developers and conformance checkers, its value ABNF is:
</p>

<pre class="bnf">
X-Frame-Options = "DENY" / "SAMEORIGIN"
</pre>

<div class="algo">
<p>
`~navi応答の~X-Frame-Optionsに対する固守を検査する@
ときは、所与の
( `応答$ %応答, `閲覧文脈$ %B, `生成元$ %行先~生成元 )
に対し：
◎
To check a navigation response's adherence to `X-Frame-Options`, given a response response, a browsing context browsingContext, and an origin destinationOrigin:
</p>
<ol>
	<li>
~IF［
%B は`子~閲覧文脈$でない
］
⇒
~RET ~T
◎
If browsingContext is not a child browsing context, then return true.
</li>
	<li>
<p>
%応答 の`~CSP~list$rsを成す
~EACH( %施策 )
に対し：
◎
For each policy of response's CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^bl
］
⇒
~CONTINUE
◎
If policy's disposition is not "enforce", then continue.
</li>
			<li>
~IF［
`frame-ancestors$dir 指令 ~IN %施策 の`指令~集合$
］
⇒
~RET ~T
◎
If policy's directive set contains a frame-ancestors directive, then return true.
</li>
		</ol>
	</li>
	<li>
%生~X~frame~options ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `X-Frame-Options$h )
◎
Let rawXFrameOptions be the result of getting, decoding, and splitting `X-Frame-Options` from response's header list.
</li>
	<li>
<p>
~IF［
%生~X~frame~options ~EQ ~NULL
］
⇒
~RET ~T
</p>
<p class="trans-note">【
この段は、この訳による補完（ %応答 内に `X-Frame-Options$h は無い）。
】</p>
	</li>
	<li>
%~X~frame~options ~LET 新たな`集合$
◎
Let xFrameOptions be a new set.
</li>
	<li>
%生~X~frame~options を成す
~EACH( %値 )
に対し
⇒
%~X~frame~options に次の結果を`付加する$set
⇒
`~ASCII小文字~化する$( %値 ) 
◎
For each value of rawXFrameOptions, append value, converted to ASCII lowercase, to xFrameOptions.
</li>
	<li>
<p>
~IF［
%~X~frame~options の`~size$ ~GT 1
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~X~frame~options を成す
~EACH( %値 )
に対し
⇒
~IF［
%値 ~IN { `deny^bl, `allowall^bl, `sameorigin^bl }
］
⇒
~RET ~F
◎
If xFrameOptions's size is greater than 1, and xFrameOptions contains any of "deny", "allowall", or "sameorigin", then return false.
</p>

<p class="note">注記：
ここでの意向は、
`X-Frame-Options$h が［
妥当な何かを行おうと試行しているが，紛らわしく現れる
］場合には，それを適用する際に 【埋込もうとする】どの試みも阻止することにある。
◎
The intention here is to block any attempts at applying `X-Frame-Options` which were trying to do something valid, but appear confused.
</p>

<p class="note">注記：
旧来の `ALLOWALL^bl 値による処理~modelに対する影響iは、ここに限られる。
◎
This is the only impact of the legacy `ALLOWALL` value on the processing model.
</p>
			</li>
			<li>
<p>
~RET ~T
◎
If xFrameOptions's size is greater than 1, then return true.
</p>

<p class="note">注記：
~headerは、複数個の妥当でない値を包含している
— この場合、~headerが まるごと省略されていたときと同じ仕方で扱う。
◎
This means it contains multiple invalid values, which we treat the same way as if the header was omitted entirely.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~X~frame~options[ 0 ] ~EQ `deny^bl
］
⇒
~RET ~F
◎
If xFrameOptions[0] is "deny", then return false.
</li>
	<li>
<p>
~IF［
%~X~frame~options[ 0 ] ~EQ `sameorigin^bl
］：
◎
If xFrameOptions[0] is "sameorigin", then:
</p>
		<ol>
			<li>
<p>
~WHILE 無条件：
</p>
				<ol>
					<li>
%容器~文書 ~LET %B の`容器~文書$
</li>
					<li>
~IF［
%容器~文書 ~EQ ~NULL
］
⇒
~BREAK
</li>
					<li>
~IF［
%容器~文書 の`生成元$doc ~NEQ`生成元$sub %行先~生成元
］
⇒
~RET ~F
</li>
					<li>
%B ~LET %容器~文書 が`属する閲覧文脈$
</li>
					<li>
~IF［
%B ~EQ ~NULL
］
⇒
~BREAK
</li>
				</ol>
◎
Let containerDocument be browsingContext's container document.
◎
While containerDocument is not null:
• If containerDocument's origin is not same origin with destinationOrigin, then return false.
• Let containerBC be containerDocument's browsing context.
• Set containerDocument to containerBC's container document, if containerBC is non-null; otherwise, null.
</li>
		</ol>
	</li>
	<li>
<p>
~RET ~T
◎
Return true.
</p>

<p class="note">注記：
ここまで達した場合、妥当でない 1 個の値からなる（旧来の［
`ALLOWALL^bl ／ `ALLOW-FROM^bl
］形も該当する）
— この場合、~headerは まるごと省略されていたかのように扱う。
◎
If we've reached this point then we have a lone invalid value (which could potentially be one the legacy `ALLOWALL` or `ALLOW-FROM` forms). These are treated as if the header were omitted entirely.
</p>
	</li>
</ol>
</div>

<hr>

<div class="example">

<p>
この~header用の様々な値の処理を
— 不適合tなものも含め —
次の表に示す：
◎
The following table illustrates the processing of various values for the header, including non-conformant ones:
</p>

<div>
<table><thead><tr><th>`X-Frame-Options$h
<th>妥当？
<th>結果

</thead><tbody><tr><td>`DENY^bl
<td>✅
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN^bl
<td>✅
<td>同一-生成元なら埋込みは許容される

<tr><td>`INVALID^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOWALL^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOW-FROM=https://example.com/^bl
<td>❌
<td>埋込みは許容される（どこからでも）

</tbody></table>
◎
`X-Frame-Options`	Valid	Result
`DENY`	✅	embedding disallowed
`SAMEORIGIN`	✅	same-origin embedding allowed
`INVALID`	❌	embedding allowed
`ALLOWALL`	❌	embedding allowed
`ALLOW-FROM=https://example.com/`	❌	embedding allowed (from anywhere)
</div>

</div>

<div class="example">

<p>
複数の値を孕んでいる，様々な不適合tな事例がどう処理されるかを，次の表に示す：
◎
The following table illustrates how various non-conformant cases involving multiple values are processed:
</p>

<div>

<table><thead>
<tr><th>`X-Frame-Options$h
<th>結果
</thead><tbody>

<tr><td>`SAMEORIGIN, SAMEORIGIN^bl
<td>同一-生成元なら埋込みは許容される

<tr><td>`SAMEORIGIN, DENY^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN,^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, ALLOWALL^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL,^bl
<td>埋込みは許容されない

<tr><td>`INVALID, INVALID^bl
<td>埋込みは許容される

</tbody></table>

◎
`X-Frame-Options`	Result
`SAMEORIGIN, SAMEORIGIN`	same-origin embedding allowed
`SAMEORIGIN, DENY`	embedding disallowed
`SAMEORIGIN,`	embedding disallowed
`SAMEORIGIN, ALLOWALL`	embedding disallowed
`SAMEORIGIN, INVALID`	embedding disallowed
`ALLOWALL, INVALID`	embedding disallowed
`ALLOWALL,`	embedding disallowed
`INVALID, INVALID`	embedding allowed
</div>

<p>
値たちが［
~commaで区切られた値を伴う 1 個の~header,
複数個の~header
］どちらで送達されようが，得される結果は同じになる。
◎
The same results are obtained whether the values are delivered in a single header whose value is comma-delimited, or in multiple headers.
</p>
</div>

			</section>
		</section>
</main>
