<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Scripting（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<style type="text/css">

.arg-list {
	display: block;
	padding-left: 2em;
	white-space: pre-line;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'scripting',
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 171013 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		jA: 'abstract',
		jv: 'js-value',
		sl: 'js-slot',
		h: 'header',
		E: 'error',
	};

	var tag_map = {
		I: 'code', // IDL interface
		E: 'code', // error
		m: 'code', // IDL member
		hd: 'code', // IDL event handler
		c: 'code',
		s: 'samp',
		e: 'code',
		a: 'code',
		sc: 'code', // URL scheme
		et: 'code', // event type
		h: 'code', // HTTP header
		jA: 'span', // 抽象演算
		jv: 'code', // JS 値
		sl: 'span', // JS internal slot
//		js: 'span', // JS other TODO
		b: 'b',
		V: 'var',
		i: 'i', // model constants
	};

	var link_map = this.link_map;
	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm':
case 'hd':
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc':
	text += ':';
	break;
case 'sl':
	text = '[[' + text + ']]';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2017-12-20
trans_update:2017-12-16
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/webappapis.html
nav_prev:NAVI
nav_next:HTMLGAPI
trans_1st_pub:2016-01-08


●●original_id_map


●●link_map


	●IDL
USVString:~WEBIDL#idl-USVString
I.GlobalEventHandlers:#globaleventhandlers
I.WindowEventHandlers:#windoweventhandlers
I.DocumentAndElementEventHandlers:#documentandelementeventhandlers
I.PromiseRejectionEvent:#promiserejectionevent
I.PromiseRejectionEventInit:#promiserejectioneventinit
I.ErrorEvent:#errorevent
I.ErrorEventInit:#erroreventinit
I.EventListener:~DOM4#callbackdef-eventlistener
I.EventHandler:#eventhandler
I.EventHandlerNonNull:#eventhandlernonnull
I.OnBeforeUnloadEventHandler:#onbeforeunloadeventhandler
I.OnBeforeUnloadEventHandlerNonNull:#onbeforeunloadeventhandlernonnull
I.OnErrorEventHandler:#onerroreventhandler
I.OnErrorEventHandlerNonNull:#onerroreventhandlernonnull

I.BeforeUnloadEvent:~NAVI#beforeunloadevent
I.Document:~HTMLdom#document
I.HTMLElement:~HTMLdom#htmlelement
I.MessagePort:~HTMLcomms#messageport

I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.ServiceWorkerGlobalScope:~SW#serviceworkerglobalscope
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.WorkletGlobalScope:https://drafts.css-houdini.org/worklets/#workletglobalscope

I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.Function:~WEBIDL#Function
I.MouseEvent:~UIEVENTS#mouseevent
I.Performance:~HRTIME#the-performance-interface
I.Navigator:~HTMLnavigator#navigator

I.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-objects


E.SyntaxError:~WEBIDL#syntaxerror
E.Error:~WEBIDL#idl-error
E.QuotaExceededError:~WEBIDL#quotaexceedederror
E.NetworkError:~WEBIDL#networkerror

	Event
m.addEventListener:~DOM4#dom-eventtarget-addeventlistener
m.currentTarget:~DOM4#dom-event-currenttarget
m.type:~DOM4#dom-event-type
m.cancelable:~DOM4#dom-event-cancelable
m.bubbles:~DOM4#dom-event-bubbles
m.isTrusted:~DOM4#dom-event-istrusted

m.relatedTarget:~UIEVENTS#dom-mouseevent-relatedtarget
m.view:~UIEVENTS#dom-uievent-view

m.colno:#dom-errorevent-colno
m.error:#dom-errorevent-error
m.filename:#dom-errorevent-filename
m.lineno:#dom-errorevent-lineno
m.message:#dom-errorevent-message

m.promise:#dom-promiserejectionevent-promise
m.reason:#dom-promiserejectionevent-reason

m.returnValue:~NAVI#dom-beforeunloadevent-returnvalue

m.document.open:~HTML5/dynamic-markup-insertion.html#dom-document-open
m.document.write:~HTML5/dynamic-markup-insertion.html#dom-document-write

m.print:~HTMLGAPI#dom-window-print
m.window.alert:~HTMLGAPI#dom-window-alert
m.opener:~BROWSERS#dom-window-opener
m.setTimeout:~HTMLGAPI#dom-settimeout

m.assign:~HISTORY#dom-location-assign
m.history.back:~HISTORY#dom-history-back
m.history.pushState:~HISTORY#dom-history-pushstate

m.click:~HTMLinteraction#dom-click
m.onmessage:~HTMLcomms#handler-messageport-onmessage
m.postMessage:~HTMLcomms#dom-window-postmessage
m.MessageChannel:~HTMLcomms#dom-messagechannel

m.now:~HRTIME#dom-performance-now
	m.Performance.now
m.getBattery:https://w3c.github.io/battery/#widl-Navigator-getBattery-Promise-BatteryManager


	●handler
hd.onabort:#handler-onabort
hd.onauxclick:#handler-onauxclick
hd.onblur:#handler-onblur
hd.oncancel:#handler-oncancel
hd.oncanplay:#handler-oncanplay
hd.oncanplaythrough:#handler-oncanplaythrough
hd.onchange:#handler-onchange
hd.onclick:#handler-onclick
hd.onclose:#handler-onclose
hd.oncontextmenu:#handler-oncontextmenu
hd.oncuechange:#handler-oncuechange
hd.ondblclick:#handler-ondblclick
hd.ondrag:#handler-ondrag
hd.ondragend:#handler-ondragend
hd.ondragenter:#handler-ondragenter
hd.ondragexit:#handler-ondragexit
hd.ondragleave:#handler-ondragleave
hd.ondragover:#handler-ondragover
hd.ondragstart:#handler-ondragstart
hd.ondrop:#handler-ondrop
hd.ondurationchange:#handler-ondurationchange
hd.onemptied:#handler-onemptied
hd.onended:#handler-onended
hd.onerror:#handler-onerror
hd.onfocus:#handler-onfocus
hd.oninput:#handler-oninput
hd.oninvalid:#handler-oninvalid
hd.onkeydown:#handler-onkeydown
hd.onkeypress:#handler-onkeypress
hd.onkeyup:#handler-onkeyup
hd.onload:#handler-onload
hd.onloadeddata:#handler-onloadeddata
hd.onloadedmetadata:#handler-onloadedmetadata
hd.onloadend:#handler-onloadend
hd.onmousedown:#handler-onmousedown
hd.onmouseenter:#handler-onmouseenter
hd.onmouseleave:#handler-onmouseleave
hd.onmousemove:#handler-onmousemove
hd.onmouseout:#handler-onmouseout
hd.onmouseover:#handler-onmouseover
hd.onmouseup:#handler-onmouseup
hd.onpause:#handler-onpause
hd.onplay:#handler-onplay
hd.onplaying:#handler-onplaying
hd.onprogress:#handler-onprogress
hd.onratechange:#handler-onratechange
hd.onreadystatechange:#handler-onreadystatechange
hd.onreset:#handler-onreset
hd.onresize:#handler-onresize
hd.onscroll:#handler-onscroll
hd.onsecuritypolicyviolation:#handler-onsecuritypolicyviolation
hd.onseeked:#handler-onseeked
hd.onseeking:#handler-onseeking
hd.onselect:#handler-onselect
hd.onstalled:#handler-onstalled
hd.onsubmit:#handler-onsubmit
hd.onsuspend:#handler-onsuspend
hd.ontimeupdate:#handler-ontimeupdate
hd.ontoggle:#handler-ontoggle
hd.onvolumechange:#handler-onvolumechange
hd.onwaiting:#handler-onwaiting
hd.onwheel:#handler-onwheel
hd.onloadstart:#handler-onloadstart
hd.oncut:#handler-oncut
hd.oncopy:#handler-oncopy
hd.onpaste:#handler-onpaste

	●handler-window
hd.onafterprint:#handler-window-onafterprint
hd.onbeforeprint:#handler-window-onbeforeprint
hd.onbeforeunload:#handler-window-onbeforeunload
hd.onhashchange:#handler-window-onhashchange
hd.onlanguagechange:#handler-window-onlanguagechange
hd.onmessage:#handler-window-onmessage
hd.onmessageerror:#handler-window-onmessageerror
hd.onoffline:#handler-window-onoffline
hd.ononline:#handler-window-ononline
hd.onpagehide:#handler-window-onpagehide
hd.onpageshow:#handler-window-onpageshow
hd.onpopstate:#handler-window-onpopstate
hd.onrejectionhandled:#handler-window-onrejectionhandled
hd.onstorage:#handler-window-onstorage
hd.onunhandledrejection:#handler-window-onunhandledrejection
hd.onunload:#handler-window-onunload

	●event
et.abort:~HTMLindex#event-abort
et.auxclick:~UIEVENTS#event-type-auxclick
et.afterprint:~HTMLindex#event-afterprint
et.beforeprint:~HTMLindex#event-beforeprint
et.beforeunload:~HTMLindex#event-beforeunload
et.blur:~HTMLindex#event-blur
et.cancel:~HTMLindex#event-cancel
et.change:~HTMLindex#event-change
et.close:~HTMLindex#event-close
et.contextmenu:~HTMLindex#event-contextmenu
et.error:~HTMLindex#event-error
et.focus:~HTMLindex#event-focus
et.hashchange:~HTMLindex#event-hashchange
et.input:~HTMLindex#event-input
et.invalid:~HTMLindex#event-invalid
et.languagechange:~HTMLindex#event-languagechange
et.load:~HTMLindex#event-load
et.message:~HTMLindex#event-message
et.messageerror:~HTMLindex#event-messageerror
et.offline:~HTMLindex#event-offline
et.online:~HTMLindex#event-online
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.popstate:~HTMLindex#event-popstate
et.readystatechange:~HTMLindex#event-readystatechange
et.rejectionhandled:~HTMLindex#event-rejectionhandled
et.reset:~HTMLindex#event-reset
et.select:~HTMLindex#event-select
et.storage:~HTMLindex#event-storage
et.submit:~HTMLindex#event-submit
et.toggle:~HTMLindex#event-toggle
et.unhandledrejection:~HTMLindex#event-unhandledrejection
et.unload:~HTMLindex#event-unload
et.cut:~HTMLindex#event-cut
et.copy:~HTMLindex#event-copy
et.paste:~HTMLindex#event-paste
et.securitypolicyviolation:~HTMLindex#event-securitypolicyviolation

et.click:~UIEVENTS#event-type-click
et.dblclick:~UIEVENTS#event-type-dblclick
et.keydown:~UIEVENTS#event-type-keydown
et.keypress:~UIEVENTS#event-type-keypress
et.keyup:~UIEVENTS#event-type-keyup
et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseenter:~UIEVENTS#event-type-mouseenter
et.mouseleave:~UIEVENTS#event-type-mouseleave
et.mousemove:~UIEVENTS#event-type-mousemove
et.mouseout:~UIEVENTS#event-type-mouseout
et.mouseover:~UIEVENTS#event-type-mouseover
et.mouseup:~UIEVENTS#event-type-mouseup
et.wheel:~UIEVENTS#event-type-wheel
et.resize:~CSSOMVIEW#eventdef-window-resize
et.scroll:~CSSOMVIEW#eventdef-document-scroll

et.canplay:~HEmedia#event-media-canplay
et.canplaythrough:~HEmedia#event-media-canplaythrough
et.cuechange:~HEmedia#event-media-cuechange
et.durationchange:~HEmedia#event-media-durationchange
et.emptied:~HEmedia#event-media-emptied
et.ended:~HEmedia#event-media-ended
et.loadeddata:~HEmedia#event-media-loadeddata
et.loadedmetadata:~HEmedia#event-media-loadedmetadata
et.loadend:~HTMLindex#event-loadend
et.loadstart:~HEmedia#event-media-loadstart
et.pause:~HEmedia#event-media-pause
et.play:~HEmedia#event-media-play
et.playing:~HEmedia#event-media-playing
et.progress:~HEmedia#event-media-progress
et.ratechange:~HEmedia#event-media-ratechange
et.seeked:~HEmedia#event-media-seeked
et.seeking:~HEmedia#event-media-seeking
et.stalled:~HEmedia#event-media-stalled
et.suspend:~HEmedia#event-media-suspend
et.timeupdate:~HEmedia#event-media-timeupdate
et.volumechange:~HEmedia#event-media-volumechange
et.waiting:~HEmedia#event-media-waiting

et.drag:~HTMLdnd#event-dnd-drag
et.dragend:~HTMLdnd#event-dnd-dragend
et.dragenter:~HTMLdnd#event-dnd-dragenter
et.dragexit:~HTMLdnd#event-dnd-dragexit
et.dragleave:~HTMLdnd#event-dnd-dragleave
et.dragover:~HTMLdnd#event-dnd-dragover
et.dragstart:~HTMLdnd#event-dnd-dragstart
et.drop:~HTMLdnd#event-dnd-drop


	●scheme
sc.javascript:~NAVI#javascript-protocol

	●要素
e.body:~HEsections#the-body-element
e.iframe:~HEembed#the-iframe-element
e.script:~HEscripting#the-script-element
e.frameset:~HTMLobs#frameset

a.type:~HEscripting#attr-script-type

	●HTTP header
h.Referer:~RFC7231#section-5.5.2
h.User-Agent


i.Anonymous:~HTMLurl#attr-crossorigin-anonymous
i.Use Credentials:~HTMLurl#attr-crossorigin-none
i.No CORS:~HTMLurl#attr-crossorigin-none


	●
非同期に完了-:#_asynchronously-complete
文書:~HTMLdom#the-document-object
	~HTMLdom#document
~window:~WINDOW#the-window-object

~scriptingは不能化されて:#concept-bc-noscript
~scriptingは可能化されて:#concept-bc-script
	可能化-:#concept-bc-script
~node用の~scriptingは可能化されて:#concept-n-script
~node用の~scriptingは不能化されて:#concept-n-noscript

~script:#concept-script

sC.設定群~obj:#settings-object
sC.~record:#concept-script-record
sC.構文解析-~error:#concept-script-parse-error
sC.再投出-用~error:#concept-script-error-to-rethrow
sC.~fetch~options:#concept-script-script-fetch-options
sC.基底~URL:#concept-script-base-url
sC.~errorは黙秘する:#muted-errors
sC.~error:#concept-module-script-error

~script~fetch~options:#script-fetch-options
既定の~classic~script~fetch~options:#default-classic-script-fetch-options
子孫~script~fetch~options:#descendant-script-fetch-options
~classic~script要請を設定しておく:#set-up-the-classic-script-request
~module~script要請を設定しておく:#set-up-the-module-script-request
sfO.暗号用~nonce:#concept-script-fetch-options-nonce
sfO.完全性~metadata:#concept-script-fetch-options-integrity
sfO.構文解析器~metadata:#concept-script-fetch-options-parser
sfO.資格証~mode:#concept-script-fetch-options-credentials
sfO.~referrer施策:#concept-script-fetch-options-referrer-policy

~classic~script:#classic-script
~classic~scriptを作成する:#creating-a-classic-script
~classic~scriptを~fetchする:#fetch-a-classic-script
~classic~scriptを走らす:#run-a-classic-script

~module~script:#module-script
~module~scriptを走らす:#run-a-module-script
~module~scriptを作成する:#creating-a-module-script
~module指定子を解決する:#resolve-a-module-specifier
~module~map:#module-map

作動中の~script:#active-script

~worker用~classic~scriptを~fetchする:#fetch-a-classic-worker-script
~workerが~importした~classic~scriptを~fetchする:#fetch-a-classic-worker-imported-script
~module~script~graphを~fetchする:#fetch-a-module-script-tree
子孫を~fetchする:#fetch-the-descendants-of-a-module-script
子孫を~fetchして~instance化する:#fetch-the-descendants-of-and-instantiate-a-module-script
最初の~errorを見出す:#finding-the-first-parse-error
単独の~module~scriptを~fetchする:#fetch-a-single-module-script
~worker用~module~script~graphを~fetchする:#fetch-a-module-worker-script-tree
~module~script~graphを~fetchする内部手続き:#internal-module-script-graph-fetching-procedure


~fetchを遂行する:#fetching-scripts-perform-fetch
V.~top-level内~flag:#fetching-scripts-is-top-level

~scriptを走らすために準備する:#prepare-to-run-script
~callbackを走らすために準備する:#prepare-to-run-a-callback
走らせた~scriptを片付ける:#clean-up-after-running-script
走らせた~callbackを片付ける:#clean-up-after-running-a-callback

~scriptを準備-:~HEscripting#prepare-a-script
~scriptは走れるかどうか検査する:#check-if-we-can-run-script
走っている~script:#running-script
走っている~scriptを中止-:#abort-a-running-script
中止-:#abort-a-running-script

非安全~応答:~HTMLurl#unsafe-response

現在の設定群~obj:#current-settings-object

環境:#environment
環境~設定群~obj:#environment-settings-object
enV.~id:#concept-environment-id
enV.作成時の~URL:#concept-environment-creation-url
enV.~target閲覧文脈:#concept-environment-target-browsing-context
enV.作動中の~service-worker:#concept-environment-active-service-worker
enV.実行~準備済み~flag:#concept-environment-execution-ready-flag
enV.~realm実行~文脈:#realm-execution-context
enV.~module~map:#concept-settings-object-module-map
enV.担当の閲覧文脈:#responsible-browsing-context
enV.担当の~event-loop:#responsible-event-loop
enV.担当の文書:#responsible-document
enV.~API用~URL文字~符号化方式:#api-url-character-encoding
enV.~API用~基底~URL:#api-base-url
enV.生成元:#concept-settings-object-origin
enV.~HTTPS状態:#https-state
enV.~referrer施策:#concept-settings-object-referrer-policy
enV.通知待ちの却下済み~promise~list:#about-to-be-notified-rejected-promises-list
enV.未決の却下済み~promiseへの弱い参照の集合:#outstanding-rejected-promises-weak-set

enV.大域~obj:#concept-settings-object-global
enV.~Realm:#environment-settings-object's-realm
	'
大域~obj:#global-object
rM.大域~obj:#concept-realm-global
rM.設定群~obj:#concept-realm-settings-object
gL.~Realm:#concept-global-object-realm

入口~某:#concept-entry-everything
入口~Realm:#concept-entry-realm
入口~実行~文脈:#entry-execution-context
入口~大域~obj:#entry-global-object
入口~設定群~obj:#entry-settings-object

現任の某:#concept-incumbent-everything
現任の設定群~obj:#incumbent-settings-object
現任の大域~obj:#concept-incumbent-global
現任の~Realm:#concept-incumbent-realm

現在の某:#concept-current-everything
現在の大域~obj:#current-global-object

某に関連する:#concept-relevant-everything
関連する設定群~obj:#relevant-settings-object
	#relevant-settings-object-for-a-global-object
関連する大域~obj:#concept-relevant-global
関連する~Realm:#concept-relevant-realm


予備の現任の設定群~obj~stack:#backup-incumbent-settings-object-stack
現任の決定-時に飛ばす~counter:#skip-when-determining-incumbent-counter
	:#calling-scripts
最上端の~scriptを有する実行~文脈:#topmost-script-having-execution-context

例外を報告する:#report-the-exception
~error報告~mode下:#in-error-reporting-mode
~errorを報告する:#report-the-error
err.取扱済み~flag:#concept-error-handled
err.取扱済みでない:#concept-error-nothandled
rej.取扱済み~flag:#concept-promise-rejection-handled
rej.取扱済みでない:#concept-promise-rejection-nothandled
実行時~script~error:#runtime-script-errors
却下済み~promiseについて通知する:#notify-about-rejected-promises
	未取扱いの~promise却下:#unhandled-promise-rejections

~event-loop:#event-loop
閲覧文脈~event-loop:#_browsing-context-event-loop
~worker~event-loop:#_worker-event-loop
~event-loopを回す:#spin-the-event-loop
	~event-loopの~spinning:#spin-the-event-loop
同期区間:#synchronous-section

~task:#concept-task
~task~queue:#task-queue
~task源:#task-source
現在~走っている~task:#currently-running-task
極小task~task源:#microtask-task-source
~DOM操作~task源:#dom-manipulation-task-source
履歴~走査~task源:#history-traversal-task-source
利用者対話~task源:#user-interaction-task-source
~network用~task源:#networking-task-source
~taskを~queueする:#queue-a-task
~queueする:#queue-a-task
~queueされ:#queue-a-task
極小taskを~queueする:#queue-a-microtask
極小task:#microtask
極小task~queue:#microtask-queue
極小task~checkpoint遂行-中~flag:#performing-a-microtask-checkpoint
極小task~checkpointを遂行する:#perform-a-microtask-checkpoint
孤立~callback極小task:#solitary-callback-microtask
複合~極小task:#compound-microtask
複合~極小task下位task:#compound-microtask-subtask
複合~極小task下位taskを実行する:#execute-a-compound-microtask-subtask
~callbackを包装する:#execute-a-compound-microtask-subtask
安定~状態を待受ける:#await-a-stable-state
一時停止-:#pause


~event~handler:#event-handlers
内部的な生の未compileの~handler:#internal-raw-uncompiled-handler
~event~handler~IDL属性:#event-handler-idl-attributes
~event~handler内容~属性:#event-handler-content-attributes
~event~handler~event型:#event-handler-event-type
~event~handler処理~algo:#the-event-handler-processing-algorithm
~event~handlerの現在の値を取得する:#getting-the-current-value-of-the-event-handler

click ~eventを発火する:#fire-a-click-event
合成~mouse~eventを発火する:#fire-a-synthetic-mouse-event
	最初の段:#step1

~memoryを共有できる:#can-share-memory-with
専用~worker~agent:#dedicated-worker-agent
~service-worker~agent:#service-worker-agent
共用~worker~agent:#shared-worker-agent
生成元が類似する~window~agent:#similar-origin-window-agent
~worklet~agent:#worklet-agent

~CSS~animationを走らせて~eventを送信する:#run-css-animations-and-send-events
描画を更新する:#update-the-rendering
~animation~frame~callbackたちを走らす:~HTMLGAPI#run-the-animation-frame-callbacks
交差観測の更新~手続き:~INTERSECTIONOBSERVER#run-the-update-intersection-observations-steps

	●~HTMLINFRA
~HTML要素:~HTMLINFRA#html-elements
並列的:~HTMLINFRA#in-parallel
文書の中へ挿入-:~HTMLINFRA#insert-an-element-into-a-document

~CORS非同一生成元:~HTMLurl#cors-cross-origin
~CORS同一生成元:~HTMLurl#cors-same-origin
~CORSになり得る要請を作成する:~HTMLurl#create-a-potential-cors-request
相対的に構文解析-:~HTMLurl#parse-a-url
Content Type ~metadata:~HTMLurl#content-type
基底~URL:~HTMLurl#document-base-url

	●~HTML 他
~JS~MIME型:~HEscripting#javascript-mime-type
x.~script:~HEscripting#the-script-element
故意的な違反:~HTMLINFRA#willful-violation
~HTML構文解析器:~HTMLparsing#html-parser
~form所有者:~HTMLforms#form-owner


	●URL1, ENCODING
~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer
~URL構文解析する:~URL1#concept-url-parser
~URL構文解析-:~URL1#concept-url-parser
~UTF-8復号する:~ENCODING#utf-8-decode
~Unicodeに復号する:~ENCODING#decode
url.~query:~URL1#concept-url-query
url.素片:~URL1#concept-url-fragment

	●DOM4
~eventを発火-:~DOM4#concept-event-fire
~event~listener:~DOM4#concept-event-listener
~eventを作成-:~DOM4#concept-event-create
配送-:~DOM4#concept-event-dispatch
取消ed~flag:~DOM4#canceled-flag
~composed~flag:~DOM4#composed-flag
木~順序:~DOM4#concept-tree-order
要素:~DOM4#concept-element
~node文書:~DOM4#concept-node-document
doc.~URL:~DOM4#concept-document-url
	:~DOM4#concept-event-listener-invoke

	●WEBIDL
~callback this 値:~WEBIDL#dfn-callback-this-value
~platform~obj:~WEBIDL#dfn-platform-object
属する大域~環境:~WEBIDL#es-platform-objects
~callback文脈:~WEBIDL#dfn-callback-context
~callback関数を呼出す:~WEBIDL#invoke-a-callback-function
x.呼出す:~WEBIDL#invoke-a-callback-function
x.変換-:~WEBIDL#es-type-mapping

	●CSSOMVIEW
~resize手続き:~CSSOMVIEW#run-the-resize-steps
~scroll手続き:~CSSOMVIEW#run-the-scroll-steps
媒体~queriesを評価して変化を報告する:~CSSOMVIEW#evaluate-media-queries-and-report-changes

	●WORKERS
~worker:~WORKERS#workers
~workerを走らす:~WORKERS#run-a-worker
~worker処理~model:~WORKERS#run-a-worker
	x.~worker~event-loop:~WORKERS#worker-event-loop
~closing~flag:~WORKERS#dom-workerglobalscope-closing
共用~worker:~WORKERS#sharedworker
構築子~url:~WORKERS#concept-sharedworkerglobalscope-constructor-url
所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set


	●BROWSERS
~navigate:~NAVI#navigate
~source閲覧文脈:~NAVI#source-browsing-context

作動中の文書:~BROWSERS#active-document
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
全部的に作動中:~BROWSERS#fully-active
入子の閲覧文脈:~BROWSERS#nested-browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
互いに関係する閲覧文脈~群:~BROWSERS#unit-of-related-browsing-contexts
互いに関係するかつ生成元も類似する閲覧文脈~群:~BROWSERS#unit-of-related-similar-origin-browsing-contexts
通して入子に:~BROWSERS#browsing-context-nested-through

結付けられている文書:~WINDOW#concept-document-window

~Location~objにより~navigate:~HISTORY#location-object-navigate

生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
作動中の~sandbox用~flag集合:~ORIGIN#active-sandboxing-flag-set
閲覧文脈~sandbox化( ~script )~flag:~ORIGIN#sandboxed-scripts-browsing-context-flag

	●FETCH
~fetch:~FETCH#concept-fetch
~MIME型を抽出する:~FETCH#concept-header-extract-mime-type
要請:~FETCH#concept-request
応答:~FETCH#concept-response
~network~error:~FETCH#concept-network-error
応答を処理する:~FETCH#process-response
~HTTPS状態~値:~FETCH#concept-https-state-value
~navi要請:~FETCH#navigation-request

rq.~client:~FETCH#concept-request-client
rq.要請~client:~FETCH#concept-request-client
rq.~mode:~FETCH#concept-request-mode
rq.~url:~FETCH#concept-request-url
rq.~referrer:~FETCH#concept-request-referrer
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.行先:~FETCH#concept-request-destination
rq.要請~URL:~FETCH#concept-request-url
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rq.暗号用~nonce~metadata:~FETCH#concept-request-nonce-metadata
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
rq.同期~flag:~FETCH#synchronous-flag

rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.~ok~status:~FETCH#ok-status
rs.~status:~FETCH#concept-response-status
rs.~url:~FETCH#concept-response-url
rs.応答~URL:~FETCH#concept-response-url
rs.種別:~FETCH#concept-response-type


	●JS
~agent~cluster:~TC39#sec-agent-clusters
~agent:~TC39#sec-agents
js.初期化-:~TC39#sec-initializehostdefinedrealm
js.~JS~realm:~TC39#sec-code-realms
js.~realm:~TC39#sec-code-realms
js.現在の~Realm~Record:~TC39#current-realm
js.現在の~JS~realm:~TC39#current-realm
js.自動的~semicolon挿入:~TC39#sec-automatic-semicolon-insertion
js.早期の~error:~TC39#early-error-rule
js.~JS実行~文脈~stack:~TC39#execution-context-stack
js.~JS実行~文脈:~TC39#sec-execution-contexts
js.走っている~JS実行~文脈:~TC39#running-execution-context
js.Use Strict Directive:~TC39#use-strict-directive
js.Directive Prologue:~TC39#directive-prologue
js.Script Record:~TC39#sec-script-records
js.Source Text Module Record:~TC39#sec-source-text-module-records
js.List:~TC39#sec-list-and-record-specification-type
js.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

	●抽象演算
jA.EnqueueJob:~TC39#sec-enqueuejob
jA.FunctionBody:~TC39#prod-FunctionBody
jA.FunctionCreate:~TC39#sec-functioncreate
jA.GetActiveScriptOrModule:~TC39#sec-getactivescriptormodule
jA.HostEnsureCanCompileStrings:~TC39#sec-hostensurecancompilestrings
jA.HostPromiseRejectionTracker:~TC39#sec-host-promise-rejection-tracker
jA.HostResolveImportedModule:~TC39#sec-hostresolveimportedmodule
jA.Evaluate:~TC39#sec-moduleevaluation
jA.NewObjectEnvironment:~TC39#sec-newobjectenvironment
jA.ParseModule:~TC39#sec-parsemodule
jA.ParseScript:~TC39#sec-parse-script
jA.RunJobs:~TC39#sec-runjobs
jA.ScriptEvaluation:~TC39#sec-runtime-semantics-scriptevaluation
jA.Instantiate:~TC39#sec-moduledeclarationinstantiation
jA.NormalCompletion:~TC39#sec-normalcompletion

jA.HostImportModuleDynamically:~JSIMPORT#sec-hostimportmoduledynamically
jA.FinishDynamicImport:~JSIMPORT#sec-finishdynamicimport
jA.HostGetImportMetaProperties:~JSIMPORTMETA#sec-hostgetimportmetaproperties

jA.EnsureCSPDoesNotBlockStringCompilation:~CSP3#can-compile-strings

c.import():~JSIMPORT#sec-import-calls
c.eval():~TC39#sec-eval-x


	要素の~inline型の挙動は~CSPにより阻止されるべきか？:~CSP3#should-block-inline

	●INFRA
構造体:~INFRA#struct
~item:~INFRA#struct-item
~map:~INFRA#ordered-map
	有順序~map
	~key集合:~INFRA#map-getting-the-keys
空:~INFRA#list-is-empty
	~NIN:~INFRA#list-contain
	~IN:~INFRA#list-contain
付加する:~INFRA#list-append
set.付加する:~INFRA#set-append
	[]:~INFRA#map-get
	~NEQ ε／ ~IN:~INFRA#map-exists
~SET:~INFRA#map-set
~list:~INFRA#list
集合:~INFRA#set
~EACH:~INFRA#list-iterate
	~CONTINUE:~INFRA#iteration-continue
~pop:~INFRA#stack-pop
~push:~INFRA#stack-push

~JS文字列:~INFRA#javascript-string
	符号単位:~INFRA#code-unit
~scalar値~文字列:~INFRA#scalar-value-string

	●他


~referrer施策:~REFERRER-POLICY#referrer-policy
x.制御-:~SW#dfn-control
~service-worker:~SW#dfn-service-worker
全screen手続き:~FULLSCREEN#run-the-fullscreen-steps

	"https://www.w3.org/Bugs/Public/show_bug.cgi?id=26603#c36"
	EnqueueJob:#enqueuejob(queuename,-job,-arguments)


●●words_table1

JSIMPORT:https://tc39.github.io/proposal-dynamic-import/
JSIMPORTMETA:https://tc39.github.io/proposal-import-meta/
INTERSECTIONOBSERVER:IntersectionObserver-ja.html
	https://w3c.github.io/IntersectionObserver/
FULLSCREEN:https://fullscreen.spec.whatwg.org/

Assert:<b>Assert</b>
Location:<code>Location</code> 
JSthis: <b>this</b>


●●words_table


API:
URL:
UTF-8:
Unicode:
HTTPS:
HTML:
DOM:
CSS:
CSP:Content Security Policy:CSP
	Document
	ECMAScript
	DOM
	CSS
	File API
	HTML
	SVG
	Hz
Web:
web:
	Window:
	Worker:
	base64:

	●IDL / JS
IDL:
JS:JavaScript
WebIDL:Web IDL
Record:
field:
	:::フィールド
interface::::インタフェース
obj:object:::オブジェクト
method::::メソッド
block::::ブロック
	-:member
node::::ノード
instance::::インスタンス
	~instance化-:instantiate
	~instance化:instantiation
	~instance化前の:pre-instantiation
	~instance化されていない:uninstantiated
mixin:

内部:internal:~
slot::::スロット
文脈:context::~
変換-:convert:~
変換:conversion:~
木:tree::~::ツリー
要素:element::~
親:parent::~
文書:document::文書
文書s:document たち::文書たち
片:fragment::~
属性:attribute::~
演算:operation:~
演算-:operate:~
抽象演算:abstract operation:~
名前:name:~
名:name:~
型:type:~
値:value:~
関数:function::~
集合:set:~
構造:structure::~
構造体:struct::~
構築子:constructor::~::コンストラクタ
構築-:construct::~
型強制-:coerce::強制
取得子:getter::~
取得-:get::~
設定子:setter::~
設定-:set::~
設定:setting::~
	設定しておく:setup／set upする
再設定-:reset::~
配列:array::~

	●nav, network, security
sandbox:
	sandboxing
	sandboxed
form::::フォーム
frame::::フレーム
top-level::::トップレベル
header::::ヘッダ
referrer::::リファラ
設定群:settings::~
閲覧文脈:browsing context::~
生成元:origin::~::オリジン
同一生成元:same-origin::~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン
施策:policy::~:ポリシー
保安:security::~:セキュリティ
特性:property::~
検査:check::~
	点検
漏洩-:leak:~
非安全:unsafe:~
所在:location:~

	●環境
入口:entry::~
	入った:enter した
	入る:enter
entry:
realm:
Realm:
agent:
worklet:
cluster:
某:〜
環境:environment::~
共有-:share::~
共用:shared::~
所有-:own::~
所有者:owner::~
大域:global::~::グローバル
worker:
window:
service-worker:service worker

	●処理モデル
schedule::::スケジュール
mode::::モード
message::::メッセージ
flag::::フラグ
algo:algorithm:::アルゴリズム
script::::スクリプト
	~scriptによる:scripted
scripting::::スクリプト処理
clean:
console::::コンソール
alert:
source::::ソース
prompt:
checkpoint:
	検点
job::::ジョブ
item:
counter::::カウンタ
	:::エントリ
現任の:incumbent:~

loop::::ループ
callback:
call:
	~call元:caller::::~
	~call法~calling::::~
stack::::スタック
push:
pop:
post::::ポスト
promise:
	~promise能力:promiseCapability
module::::モジュール
classic::::クラシック
map::::マップ
bootstrap:
import:
	~workerが~importした:worker-imported
closing:
record::::レコード
	BOM
catch:
error::::エラー
code::::コード
未compileの:uncompiled:::未コンパイルの
timer::::タイマー
system::::システム
hook::::フック
option::::オプション
options::::option 集
	parameter::::パラメタ

子孫:descendants::~
先祖:ancestor::~
根:root::~::ルート
子:child::~
指定子:specifier::~
検査-:check::~::チェック
失敗-:fail::~
失敗:failure::~
成功-:succeed::~
成功:success::~
	-:successful
	成功しな:unsuccessful
出自に:originate::~
片付け:clean-up::~
	cleanup
片付ける:clean up する::~
強制終了:killing::~
複合:compound:~
構成-:compound:~
孤立:solitary::~
	単生
走るな:do not run:~
走れ:run:~
走らす:run する:~
走らせ:run し:~
走らさ:run さ:走らさ
走れる:run できる:走れる
走せず:run せず:走らせず
走って:run して:走って
	稼働
標的:target:::ターゲット
task::::タスク
下位task:subtask::下位 task:下位タスク:サブタスク
極小task:microtask::極小 task:極小タスク:マイクロタスク
源:source::~::ソース
queue::::キュー
enqueue::::エンキュー
dequeue::::デキュー

通知-:notify:~
通知:notification:~
通知待ちの:about-to-be-notified:~
黙秘-:mute::~
再投出-:rethrow::~
	:re-throw
投出-:throw::~
例外:exception::~
未決の:outstanding::~
一時停止-:pause::~::ポーズ
問題箇所:problematic position:~
	箇所:position:~
列番号:column number:~
行番号:line number:~
行0:line:行
却下-:reject::~
却下:rejection::~
却下済み:rejected::~
解決-:resolve::~
解決:resolution::~
	解決-済み:resolved
	解決できない:unresolvable

取扱う:handle する:取り扱う
取扱える:handle できる:取り扱える
取扱われ:handle され:取り扱われ
取扱って:handle して:取り扱って
取扱い:handling:取り扱い
取扱済み:handled:取り扱い済み
未取扱いの:unhandled:未取り扱いの
未取扱0:notHandled:未取り扱い
	扱う:treat
	取り扱う:deal with
	取り扱い法:dealing with
落とす:drop する:~
早期の:early::~
再入性:reentrancy::~
再入的:reentrant::~
再開:resume:~
処理-:process:~
処理:processing:~
包装-:wrap:~
反復-:iterate:~
回す:spin する::~
	spinning
安定:stable::~
待受ける:await する::待ち受ける
停止-:stop::~
	担当の:responsible:~
	を担当するものとされる:responsibility:~
	を担当する:responsible
即応可能:responsive::~::レスポンシブ
協調-:coordinate::~
中止-:abort::~
	aborting
中途完了:abrupt completion::~
正常完了:normal completion::~
完了:completion::~
完了-:complete::~

阻止-:block::~::ブロック
阻止ed:Blocked::阻止される::ブロックされる
阻まれ:block され:~:::ブロックされ
阻んで:block して:~:::ブロックして
阻む:block する:~:::ブロックする
阻まず:block せず:~:::ブロックせず
	自他を阻まずに:non-blocking fashion

渡して:pass して:~
渡され:pass され:~
渡す:pass する:~

伝播-:propagate::~
作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
活動:activity::~::アクティビティ
動作-:act::~::アクト
動作:action::~::アクション
同期:synchronous::~
同期的:synchronous::~
同期区間:synchronous section:~
同期的な:synchronous::~
非同期的な:asynchronous::~
非同期:asynchronous::~
	古い:old:~
近過去:recent:~
遠過去:old:~
	最新:most recent:~
	最古:oldest:~
遂行-:perform:~
実行-:execute::~
実行:execution::~
実行可能な:executable::~
実行時:runtime::~
準備済み:ready::~
並列的:parallel::~
待機-:wait::~

評価-:evaluate::~
評価:evaluation::~
準備-:prepare::~

呼出-:invoke:呼び出
	呼出され／呼出した
呼出す:invoke する:呼び出す
	invocation
呼出ing:invoking:呼び出し
呼出:invocation:呼び出し
維持-:sustain:~
	〜し易いsustainable
時刻印:timestamp::~
時間:time::~
存続期間:lifetime::~
破壊-:destroy::~
継続-:continue:~
継続:continuation:~
継続的:continual:~
続行-:proceed:~

強い:strong な::~
弱い:weak な::~
参照:reference::~
参照元:referencing::~
可能化-:enable:~
	可能化-法:enabling
不能化-:disable:~
	不能化-法:disabling
入子に:nest:入れ子に
入子の:nested:入れ子の
生の:raw::~
内部的な:internal:~
内部手続き:internal procedure:~
全部的:full:~
公開-:expose:~
初期:initial:~
	初期~時:initially
初期化-:initialize:~
	初期化-時:initialize されたとき:~
状態:state::~
訪問-:visit:~
	訪問-済み:visited
追跡-:track:~
送信-:send:~
変化-:change:~
依存物:dependencies:~
依存-:depend:~
非依存:agnostic:~
	host-agnostic
graph::::グラフ
再帰的:recursive:~
重複-:duplicate:~
	重複させない:deduplicate:~
構文:syntax::~
構文上の:syntactic な::~
無視-:ignore:~
差挟まれ:interleaveされ:差し挟まれ
結合-:coalesce:~
飛ばす:skip する:~
	~~連続してimmediately after each other
予備の:backup::~
data::::データ
最上端の:topmost::~
検証-:validate::~
検証:validation::~

遭遇-:encounter:~
文:statement::~
	上層:on top of
	重ねる:layer
thread::::スレッド
main::::メイン
background::::バックグラウンド
背後:background::~
計算:computation:~
memory::::メモリ
計算資源:resource:~
高価:expensive:~
生産-:produce::~
重い:heavy な:~
	heavy-duty
	区間:section
race:::競合
同時並行的:concurrency::~
遺物:artifacts:~
発見-:discover:~
通達-:signal::~

	わかっている:we know
	とされている:marked as
	~module~script:moduleScript
	発見-済み集合:discoveredSet
	~module~map:moduleMap
	子~URL~list:childURLs
	子~module~list:childModules
	子~module:childModule
	子~構文解析-~error:childParseError

	●event
event::::イベント
event-loop:event loop:::イベントループ
listener::::リスナ
handler::::ハンドラ
capture:
trusted:
composed:
取消す:cancel する::取り消す::キャンセルする
取消され:cancel され::取り消され::キャンセルされ
取消ed:canceled::取消::キャンセル
誘発-:trigger::~
配送-:dispatch::~
発火-:fire::~
	発火-法:firing
登録-:register::~
	registering
合成:synthetic::~

	●UI
animation::::アニメーション
button::::ボタン
click::::クリック
	~boolean
byte::::バイト
閉じる:close する:~
	来る~coming::::~
custom::::カスタム
customize::::カスタマイズ
	~custom化:customizations
file::::ファイル
頻度:frequency:~
更新率:refresh rate:~
消去る:go away する:消え去る
key::::キー
keyboard::::キーボード
list::::リスト
markup::::マークアップ
mouse::::マウス
UI:user interface:UI
	~UI mouse and key ／ keyboard and mouse
private::::プライベート
	半分以上three quarters of the time
queries::::クエリ
quota::::クォータ
抑制-:reduce:~
	~~能力は抑制されることになる albeit in reduced capacity
	~releasing::::~
resize::::リサイズ
scroll::::スクロール
semicolon::::セミコロン
	~series
text::::テキスト
媒体:media::~::メディア
押下げ:pressing:~
描画:rendering:~
操作:manipulation:~
操作-:manipulate:~
	秒:seconds:~
装置:device:~
可視:visible:~
交差観測:intersection observations:~
表示-:display:~

	●network, nav
MIME:
CORS:
client::::クライアント
終了-:terminate::~
行先:destination::~
	行先に:destined
抽出-:extract::~
種別:type::~
url:
query::::クエリ
素片:fragment:::~:フラグメント
fetch:
	~fetch法:fetching
fetching::fetch 処理
status::::ステータス
ok:
metadata::::メタデータ
domain::::ドメイン
network::::ネットワーク
networking::::ネットワーク処理
network-channel:network channel:::ネットワークチャンネル
navigate::::ナビゲート
	navigating
navi:navigation:::ナビ
nonce::::ナンス
cache::::キャッシュ
頁:page:::ページ
読込まれ:load され::読み込まれ::ロードされ
読込み:loading::読み込み::ローディング
読込器:loader::読み込み器::ローダ
資源:resource::~:リソース
本体:body::~::ボディ
送達-:deliver::~
要請:request::~::リクエスト
応答:response::~::レスポンス
資格証:credentials::資格証明情報::クレデンシャル
暗号用:cryptographic::~
完全性:integrity::~

	●仕様（動詞
上書き:override:~
迂回-:bypass:~
孕む:involve する:~
孕み:involve し:~
孕まれ:involve され:~
孕んで:involve して:~
欲され:desire され:~
正当化-:justify:~
	justifiable
試行-:try:~
捉える:capture する:~
care::::ケア
懸案:concern:~
説明-:explain:~
実装-:implement:~
	implementing
実装:implementation:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
指定-:specify:~
	により指定され:-specified
挙動:behavior:ふるまい
決める:decide する:~
管理-:manage:~
決定-:determine:~
結付けら:associate さ:結び付けら
義務付けな:mandate しな:~
考える:consider する:~
表現-:represent:~
要求-:require:~
試みて:attempt して:~
試みる:attempt する:~
試みな:attempt しな:~
試みら:attempt さ:~
試み:attempt:~
課-:impose:~
達成-:achieve:~
違反:violation:~
	-:preference over
避ける:avoid する:~
直面-:face:~
作者:author:~
利用者:user:~
利用者対話:user-interaction:~
制限-:limit:~
制限:limitation:~
開発者:developer:~
定義-:define:~
定義:definition:~
	きちんと定義:well-defined::::~
意図的:intentional:~
制約:restriction:~
許容-:allow:~
導入-:introduce:~
抽象化:abstraction:~
是認-:sanction:~
統合-:integrate:~
統合:integration:~
確保-:ensure:~
影響-:affect:~
効果:effect:~
波及-:influence:~
提供-:provide:~
提供0-:offer:提供
織込んで:account して:織り込んで
組込みの:built-in:組み込みの
導出-:derive:~
適用-:apply:~
	適用できる:applicable
期待-:expect:~
希望-:hope:~
指示-:indicate:~
影響0-:impact:影響
略称-:abbreviate:~
例証-:demonstrate:~
例証:demo:~
奨励-:encourage:~
専用:dedicated:~
専用の:dedicated:~
防止-:prevent:~
	できなくさせ:prevent／impossible
体験:experience:~
	出くわす:experience:~
試験-:experiment:~
保全-:preserve:~
既存の:existing:~
発見-:discover:~
実装者:implementer:~
違反-:violate:~
変更-:change:~
時機:timing:~
含意-:imply:~
休止-:suspend:~
拘束-:constrain:~
改変-:modify:~
仕事:work:~
仕事-:work:~
受容-:accept:~
埋込まれ:embed され:埋め込まれ
	込み入った:convoluted
	注目する:interesting
	注目すべき点:notice about
望む:wish する:~
意識-:aware:~
覆され:reverse され:~
述べる:describe する:~
述べた:describe した:~
述べて:describe して:~
推奨-:recommend:~
統治-:govern:~
表面化-:surface:~
観測-:observe:~
	観測-可能:observable:~
	観測され得ない:unobservable
debug::::デバッグ
最適化:optimization:~
達-:reach:~
退出-:quit:~
予見-:believe:~

	●仕様（動詞他）
	策定を進める:going forward
	大雑把に言えば:roughly speaking
	利用できる:usable
	ひねくりまわすcontort:
	止め-:cease
	follow
	含-:include
	とる:take
	選:pick
	選ぶ:choose
	-:~sort
	保ち続ける:to keep careful track of
	保ち続ける:keep track
	しておいて:keep
	保-:keep
	利用-:use
	利用して:using
	加えて:in addition／furthermore
	呼応して:in response to
	生じ:occur
	言及-:mention
	示-:show
	結果:result
	結果の:resulting
	置-:place
	見よ:see
	起こる／起きる:happen
	検討中:considering
	採らず:take しない
	結果になる／ことになる:end up
	受け持つ:takes care
	手間をかける:take extra care
	結局:end result
	~~空にする~clear する
	はっきり:clear
	関わる:contribute:
	複雑な:complicated
	それに応じて、:in turn
	~~意図:meant
	給-:supply
	~~策定が進められ:working
	~~理解を難しくする:consequence〜confusing
	vend
	defining
	deal
	費やす:spend する
	対応-:correspond
	対にされた／:corresponding
	望ましくない:undesirable
	書き直せる:re-cast
	常に:invariably
	ひどく~~害する:highly detrimental
	say
	saying
	opposed
	lead
	合間に挟:interspersed
	思しき:sound
	定める:state
	思案中にある:mulling
	出発点:starting point


	●仕様
browser::::ブラウザ
platform::::プラットフォーム
logic::::ロジック
model::::モデル
support::::サポート
host::::ホスト
pattern::::パタン
	FINGERPRINTING
UA:user agent:UA
	序論:introduction:~
理想的:ideal:~
強く:strong に:~
手続き:steps:~
段:step:~
特定0の:particular:ある特定の
特定の:specific:~
特有の:specific な:~
	特に:specifically
明示的:explicit:~
暗黙的:implicit:~
方式:manner:~
	どう:how
技術:technologies:~
	必要:need
	必要とされ:necessary
故意的な:willful:故意による
一般:general:~
事例:case:~
事由:reason:~
理由:reason:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
下位手続き:substeps:~
概して:typical に:~
代表的:typical:~
概念:concept:~
概念的:conceptual:~
正確:exact:~
歴史的:historical:~
汎用の:generic な:~
総計:total:~
自動的:automatic:~
自明:trivial:~
明らか:obvious:~
自由:free:~
要件:requirements:~
通常は:normal には:~
通常の:normal な:~
適切:appropriate:~
関連する:relevant な:~
	関連しない:irrelevant:~
任意選択で:optional に:~
	:optional
選択肢:option:~::オプション
特色機能:feature:~
複雑問題:complication:複雑な問題
再度:again:~
定例の:regular:~
将来:future:~
特別:special:~
	対照的に:in contrast,
回避策:workaround:~
	遠回しでとっ散らかった回避策であふれる:mass of messy indirection and workarounds
尚早:premature:~
成分:component:~
技術的には:technical には:形の上では
本質的:essential:~
柔軟:flexible:~
適正:proper:~
自由度:liberal advantage:~
不変則:invariants:~
公式的:formal:~
現代の:modern:~
用語:term:~
用語体系:terminology:~
重要:important:~
間違った:wrong:~
限定句:qualification:~
妥当:valid:~
要因:factor:~
共通する:common である:~
可用:available:~
	可能:possible
可能性:possibility:~
目標:goal:~
目的:purpose:~
局面:scenario:~
互換性:compatibility:~
互換:compatible:~
側面:aspect:~
意味論:semantics:~
別法:alternative:~
	別法として:alternately
直感:intuition:~
直感的:intuitive:~
	直感的でない:unintuitive
	intuitive notion
厳密:strict:~
基盤:infrastructure:~
第三者主体:third-party:~
並行する:parallel な:~
	-:technique
通例的:usual:~
単純:simple:~
正しく:correct に:~
正しい:correct な:~
	~~正しい~right
実施:practice:~
fallback::::フォールバック
fall-back:fall back:::フォールバック
相応しく:suitable に:~
論点:discussion:~
標準:standard:~
不可欠:crucial:~
明瞭:clear:~
形式化:formalism:~
馴染みの:familiar な:~
相互作用-:interact:やりとり
注意深く:careful に:~
level::::レベル
世界:world:~
指針:guideline:~
決定的:deterministic:~
	deterministically／nondeterministically
提案:proposal:~
能力:capability:~
	●仕様（他）
	省略時は:optional
	ひな形:template
	細部:subtleties
	誤りを導き易く:can be error prone
	~~問題ない~OK
	定か:sure
	特に:in particular
	関して:with respect to
	より良く:better
	詳細:detail
	対照的に:In contrast
	不一致:inconsistency
	現時点では:currently
	概ね:roughly
	様々な箇所:various parts
	何か:something
	おそらく:perhaps
	いつの日か:one day
	とりわけ:especially
	積極的に:happily
	当分の間は:In the interim
	微妙な:subtle:~
	より円滑:less-drastic
	~~分別のある:sensible
	真っ先に挙がる:prominent
	これをもって:With this in hand
	全体を通して:throughout
	通り抜ける:throughout
	同じことだが、:equivalently
	昔ながらの:olden days
	すぐに:right away
	十分:sufficient
	十分:suffice
	並行して:alongside
	名前のみの:bare
	doc
	everything
	~~全面的にまたは~~細部的に:~globally, or in a ~finer-grained manner
	helpful
	発生:arise
	当然、:naturally
	益:benefit
	respective
	〜に則って:according
	〜に関わらず:regardless
	〜の代わりに:instead
	なり得る:potential
	しかしながら，:however
	したがって:thus
	べき:should
	例:example
	具体例:for instance
	従って，:therefore
	案:ideas

	ただ／他に何もせず~just
	道:path
	真:true
	事実:fact
	事実、:in fact
	多量の:mass of
	版:version
	status
	役立つ~~情報:helpful manner
	すぐには 〜ない:not be immediately
	以上をふまえた下で，:With all this in place
	あまりに:excessively
	hope
	:emphatically
	込み入ったもの:tricky
	-:note
	-:people think we’re doing
	[INFRA]:WHATWG Infra Standard
	not worth the trouble:手間をかけるほどもない
	likely:見込みも高い
	至極困難:quite difficult
	-:marked
	-:issue
	考えは排される:impossible to ever contemplate
	少しずつ:very slightly
	~~留意:recall
	すなわち、:, in that
	~~用法:how 〜 use

	●未分類（動詞）
包含-:contain:~
付加-:append:~
作成-:create:~
	作成-法:creating
作成:creation:~
作成時の:creation:~
持続的な:persisted:~
格納-:store:~
切替える:switch する:~
切替えら:switch さ:~
反応-:react::~
反応:reacting::~
反映-:reflect::~
	getting
合致-:match::~
	合致していない:mismatch
報告-:report::~
報告:reporting::~
変異-:mutate::~
存在-:exist:~
挿入-:insert:~
挿入:insertion:~
関係-:relate:~
関係:relation:~
無関係:unrelated:~
同値関係:equivalence relation:~
同値類:equivalence class:~
検出-:detect:~
置換-:replace:~
複製:copy:~
生成-:generate:~
走査:traversal::辿り
超過-:exceed:~
追加-:add:~
追加の:additional:~
	-:select
除去-:remove:~
返値:return value:返り値
返す:return する:~
返され:return され:~
返さ:return し:~
返した:return した:~
移動-:move:~
移動:movements:~
起動-:initiate::~

識別-:identify::~
制御-:control::~
開いた:openした:~
保持-:hold:~

	終える:finish
	増減-:incremented and decremented
	増やさ:increment さ:~
	decrement
	省略-:omit
	resuming
	long
	付与／~mark
	marked
	~anything
	始-:begin:~
	得-:obtain:~
	存続する限りas long as it exists
	~~存続する限り走らせ続けcontinually run through
	譲る:yield
	またがって:span
	放置:starving
	絞る:throttle する:~
	組:tuple
	あてがう:assign
	所与の:given
	与-:give:~
	属する／:takes place
	置く:put
	割り当て:allocate し
	~~下層:backing
	出る:going out
	行く／入る:going
	そこを占める:taking place
	PLUS:plus
	-:appear
	外へ出る:fall out
	跡を辿る:trace

	●未分類
Function:
ScriptOrModule:
真偽値:boolean::~
access::::アクセス
comment::::コメント
parameter::::パラメタ
token::::トークン
	~token化-:tokenize:~
	0:zero
inline::::インライン
target:
id:
transaction::::トランザクション
一意:unique:~
不透明:opaque::~
仮入力:placeholder::~
恒久的:permanent:~
入力:input:~
全screen:fullscreen:::全スクリーン
内容:content:~
内側:inside:~
外側:outside:~
動的:dynamic:~

	群:unit of

即時:immediate:~
基底:base::~
外部:external:~
容器:container:::コンテナ

履歴:history:~
帯域幅:bandwidth:~
引数:argument:~
情報:information:~
	-:belong
既定:default:~:::デフォルト
更新:update:~
順序:order:~
有順序:ordered:~
	無順序:unordered:~
条件:condition:~
直接的:direct:~
間接的:indirect:~
相対:relative::~
相対的:relative::~
文字:character:~
文字列:string:~
	符号単位:code unit:~
scalar::::スカラー
構文解析-:parse::~::パース
	構文解析でき:parsable
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
解析形:parsed::~::パース済み
直列化-:serialize::~::シリアル化
直列形:serialized::~::シリアル形
生成規則:production:~
復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
	種類:kind:~
空:empty:~
	開始-:start:~
範囲内:bounds 内:~

周期的:periodical:~
検索-:look up:~
data::::データ
出力:output:~
保存-:save:~
等価:equivalent:~
暗号化-:encrypt::~
暗号化:encryption::~
暗号形:encrypted::~
	暗号形~URL~list:encryptedURLs
独立:independent:~
	等しい:equal
	数:number:~
	戻-:back:~
	ずっと遅い:much slower
milli::::ミリ
	~milli秒間:milliseconds
	point

	●指示語
新たな:new:~
自前の:own:~
現在の:current:~
現在:currently:~
	現-:current:~
単独の:single:~
	1 個の:single:~
	稀:rare:~
	ごく稀:very rare
	任意:arbitrary:~
	別々の:separate
	異なる:different:~
	通り／ つ／個の:three／ two／four／five
	-:th
	一部／一環:part of
	これらの:these
	それら:they
	すべての:all
	その:that
	そのような:such
	それら／:their
	それらの:those
	-:them
	自身:itself／themselves
	ここ:here
	元々:originally
	元の:original
	別の:another
	ほぼ:mostly
	最も／ほとんどの:most
	まるごと:entirely
	まったく:entirely
	もの:thing
	上:above
	下:below
	他の:other
	他の場合:otherwise
	いくつか:several
	何か:somewhat
	前:before
	後:after
	各:each
	同じ:same
	多くの／多々:many
	当の:in question
	最初の:first
	初回:first time
	最後の:last
	個目:second
	更なる:further
	種々の:various
	複数の:multiple
	一連の:series of
	様々な:variety of
	主な:main
	別個の:distinct
	両者／両:both
	この:this
	仮の:tentative
	通:through
	介:via
	多い:often
	決して:never
	特に:in-particular
	節:section
	類似する:similar
	同様に:similarly
	-／次:next
	最終的:eventual
	前者:former
	後者:latter
	一定の／ある種の:certain:~
	:time
	どうし:pair
	consist of
	間／:among
	間:during
	等々:and so forth
	少なくとも:but is not limited to
	多くの:much
	と違って:unlike
	:others
	述べる:say
	-:th
	までの一部を担う:play a part in this whole process of getting
	戻-:back
	どこか:somewhere

	すでに:already
	今や／今:now
	まで:until
	前もって:up front
	以前の／前の／それまで:previous
	より長い:longer
	もはや:no longer
	今の所:for now
	ここでは:for now
	依然として:still
	常に:always
	後で:later
	後で:subsequently
	後の:subsequent
	時々:occasionally
	以降:the rest
	それ以降の:after all,
	早々に:early
	この時点:at this point
	~~最後に:finally
	最終:final
	次に挙がる:next
	時点:time
	この時点までに，:by now

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
Web application APIs 章の
<a href="~SPEC_URL">Scripting</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header id="head">
	<hgroup>
<h1>スクリプト処理 — Scripting</h1>

	</hgroup>
</header>

<main id="MAIN" style="display:none;">
<section id="scripting">

<h2 title="Scripting">8.1. ~scripting</h2>

		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>


<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~GOTO 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
用語 “中途完了（ abrupt completion ）” は、 `JAVASCRIPT$r にて定義される。
</p>

<p>
各種~algoのうち一部のものは、
`非同期に完了-@
する（ asynchronously complete ）ものと定義される。
その種の~algoは：
</p>

<ul>
	<li>
その結果を，それを呼出した~algoに直接的に返すことはなく、
“ %X を結果として，非同期に完了する”
と記される所で、字義通り非同期にその実行を終える。
この句は，暗黙的に ~RET も含み、~algoはそこで終了するものとする。
</li>
	<li>
その結果は、それを呼出した~algoの中で
“（〜の~algoが）非同期に完了したときは…”,
（あるいは，
“非同期に完了するまで待機する”
）という句に後続する手続きで取扱われる。
</li>
</ul>

			</section>
			<section id="introduction-12">
<h3 title="Introduction">8.1.1. 序論</h3>


<p>
作者から提供された実行可能な~codeは、種々の仕組みにより，文書の文脈において走らす。
これらの仕組みには、（少なくとも）次のものが含まれる：
◎
Various mechanisms can cause author-provided executable code to run in the context of a document. These mechanisms include, but are probably not limited to:
</p>

<ul>
	<li>
`script$e 要素の処理。
◎
Processing of script elements.
</li>
	<li>
`javascript$sc ~URLへ~navigateするとき。
◎
Navigating to javascript: URLs.
</li>
	<li>
次による~event~handler
⇒＃
DOM の `addEventListener()^m を利用して登録されたもの,
明示的な`~event~handler内容~属性$,
`~event~handler~IDL属性$,
その他
◎
Event handlers, whether registered through the DOM using addEventListener(), by explicit event handler content attributes, by event handler IDL attributes, or otherwise.
</li>
	<li>
SVG の様な，自前の~scripting特色機能を有する技術の処理。
◎
Processing of technologies like SVG that have their own scripting features.
</li>
</ul>


			</section>
			<section id="enabling-and-disabling-scripting">
<h3 title="Enabling and disabling scripting">8.1.2. ~scriptingの可能化-法と不能化-法</h3>

<p>
`閲覧文脈$ %B において，
`~scriptingは可能化されて@
いるとは、次のすべての条件が満たされることを意味する：
◎
Scripting is enabled in a browsing context when all of the following conditions are true:
</p>

<ul>
	<li>
~UAは~scriptingを~supportする。
◎
The user agent supports scripting.
</li>
	<li>
この時点で、利用者は， %B おいて~scriptingを不能化していない。
（~UAは、利用者に~scriptingを
~~全面的に, あるいは~~細部的に
— 例えば，個別の生成元ごとに — 
不能化する選択肢を提供してよい）
~FINGERPRINTING
◎
The user has not disabled scripting for this browsing context at this time. (User agents may provide users with the option to disable scripting globally, or in a finer-grained manner, e.g. on a per-origin basis.) (This is a fingerprinting vector.)
</li>
	<li id="sandboxScriptBlocked">
`閲覧文脈~sandbox化( ~script )~flag$ ~NIN ［
%B にて`作動中の文書$の`作動中の~sandbox用~flag集合$
］
◎
The browsing context's active document's active sandboxing flag set does not have its sandboxed scripts browsing context flag set.
</li>
</ul>

<p>
`~scriptingは不能化されて@
いるとは、上の否定
— `~scriptingは可能化されて$いない —
ことを意味する。
◎
Scripting is disabled in a browsing context when any of the above conditions are false (i.e. when scripting is not enabled).
</p>

<hr>

<p>
`~node用の~scriptingは可能化されて@
いるとは、所与の~node %~node に対し，［
%~node の`~node文書$が`属する閲覧文脈$ %B ~NEQ ε
］, かつ［
%B において`~scriptingは可能化されて$いる
］ことを意味する。
◎
Scripting is enabled for a node if the node's node document has a browsing context, and scripting is enabled in that browsing context.
</p>

<p>
`~node用の~scriptingは不能化されて@
いるとは、上の否定を意味する。
◎
Scripting is disabled for a node if there is no such browsing context, or if scripting is disabled in that browsing context.
</p>

			</section>
			<section id="scripting-processing-model">
<h3 title="Processing model">8.1.3. 処理~model</h3>

				<section id="definitions-2">
<h4 title="Definitions">8.1.3.1. 各種~定義</h4>

<p>
`~script@
は、 2 種の`構造体$に分けられる。
いずれにせよ、各~scriptは次の~itemを有する：
◎
A script is one of two possible structs. All scripts have:
</p>

<dl class="def-list">
	<dt>
`設定群~obj@sC
◎
A settings object
</dt>
	<dd>
`環境~設定群~obj$
— 同じ文脈に属する他の~scriptと共有されるような，種々の設定を包含する。
◎
An environment settings object, containing various settings that are shared with other scripts in the same context.
</dd>

	<dt>
`~record@sC
◎
A record
</dt>
	<dd>
~NULL, または［
`~classic~script$に対しては `Script Record$js ／
`~module~script$に対しては `Source Text Module Record$js
］。
~NULL でない場合、構文解析-済みの~scriptを表現する。
~NULL は、構文解析に失敗したことを表現する。
◎
Either a Script Record, for classic scripts; a Source Text Module Record, for module scripts; or null. In the former two cases, it represents a parsed script; null represents a failure parsing.
</dd>

	<dt>
`構文解析-~error@sC
◎
A parse error
</dt>
	<dd>
~JS値。
意味があるのは、`~record$sC ~EQ ~NULL の場合に限られ、対応する~script~source~textを構文解析できなかったことを指示する。
◎
A JavaScript value, which has meaning only if the record is null, indicating that the corresponding script source text could not be parsed.
</dd>

	<dt>
`再投出-用~error@sC
◎
An error to rethrow
</dt>
	<dd>
評価を成功させなくする~errorを表現している，~JS値。
<a href="#calling-scripts">~scriptを走らす</a>よう試みられたときには、これが再~投出されることになる。
◎
A JavaScript value representing an error that will prevent evaluation from succeeding. It will be re-thrown by any attempts to run the script.
</dd>
	<dd class="note">注記：
この例外~値は~JS仕様により提供され，決して ~NULL にならないことはわかっているので、~errorは生じなかったことを通達するときには， ~NULL を利用することにする。
◎
Since this exception value is provided by the JavaScript specification, we know that it is never null, so we use null to signal that no error has occurred.
</dd>

	<dt>
`~fetch~options@sC
◎
Fetch options
</dt>
	<dd>
`~script~fetch~options$
— ［
この~script, および それが~importする`~module~script$
］を~fetchするときに関係する，様々な~optionを包含する。
◎
A script fetch options, containing various options related to fetching this script or module scripts that it imports.
</dd>

	<dt>
`基底~URL@sC
◎
A base URL
</dt>
	<dd>
`~module指定子を解決する$ときに利用される基底~URL。
これは、外部~module~scriptに対しては，~scriptが得られた~URLになり、~inline~scriptに対しては，それを包含している文書の`基底~URL$になる。
◎
A base URL used for resolving module specifiers. This will either be the URL from which the script was obtained, for external scripts, or the document base URL of the containing document, for inline scripts.
</dd>
</dl>

<p>
`~classic~script@
は、`~script$の一種であり，次の`~item$も有する：
◎
A classic script is a type of script that has the following additional item:
</p>

<dl class="def-list">
	<dt>`~errorは黙秘する@sC
◎
A muted errors boolean
</dt>
	<dd>
真偽値。
~T ならば、この~scriptにおける~errorに対しては，~error情報は提供されなくなる。
~private情報を漏洩し得る非同一生成元~scriptに対し、~errorを黙秘するために利用される。
◎
A boolean which, if true, means that error information will not be provided for errors in this script. This is used to mute errors for cross-origin scripts, since that can leak private information.
</dd>
</dl>

<p>
`~module~script@
も`~script$の一種であるが、追加の~itemは有さない。
◎
A module script is another type of script. It has no additional items.
</p>

<p>
`作動中の~script@
は、次の~algoにより決定される：
◎
The active script is determined by the following algorithm:
</p>

<ol>
	<li>
%~record ~LET `GetActiveScriptOrModule$jA()
◎
Let record be GetActiveScriptOrModule().
</li>
	<li>
~IF［
%~record ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If record is null, return null.
</li>
	<li>
~RET %~record . `HostDefined^sl
◎
Return record.[[HostDefined]].
</li>
</ol>

<hr>

<p>
`環境@
とは、［
現在の実行~環境，または そうなり得るもの
］の設定群を識別する~objである。
各 `環境$ %環境 は、次のものを有する：
◎
An environment is an object that identifies the settings of a current or potential execution environment. An environment has the following fields:
</p>

<dl class="def-list">
	<dt>
`~id@enV
◎
An id
</dt>
	<dd>
%環境 を一意に識別する，不透明な文字列。
◎
An opaque string that uniquely identifies the environment.
</dd>

	<dt>
`作成時の~URL@enV
◎
A creation URL
</dt>
	<dd>
%環境 が結付けらている資源の所在を表現している，`~URL~record$。
◎
A URL record that represents the location of the resource with which the environment is associated.
</dd>
	<dd class="note">注記：
`環境~設定群~obj$の事例では、この~URLは `history.pushState$m などの仕組みに因り，`担当の文書$enVの`~URL$docとは別個のものにもなり得ることに注意。
◎
In the case of an environment settings object, this URL might be distinct from the environment settings object's responsible document's URL, due to mechanisms such as history.pushState().
</dd>

	<dt>
`~target閲覧文脈@enV
◎
A target browsing context
</dt>
	<dd>
~NULL, または
`~navi要請$の~target`閲覧文脈$。
◎
Null or a target browsing context for a navigation request.
</dd>

	<dt>
`作動中の~service-worker@enV
◎
An active service worker
</dt>
	<dd>
~NULL, または
%環境 を`制御-$xしている`~service-worker$。
◎
Null or a service worker that controls the environment.
</dd>

	<dt>
`実行~準備済み~flag@enV
◎
An execution ready flag
</dt>
	<dd>
~flag値
— ~ON ならば、 %環境 はすでに設定しておかれたことを指示する。
初期~時は ~OFF 。
◎
A flag that indicates whether the environment setup is done. It is initially unset.
</dd>
</dl>

<p>
`環境~設定群~obj@
%設定群 とは、`環境$であることに加え，次を得るための各種~algoも指定するものである：
◎
An environment settings object is an environment that additionally specifies algorithms for:
</p>

<dl class="def-list">
	<dt>`~realm実行~文脈@enV
◎
A realm execution context
</dt>
	<dd>
%設定群 を利用するすべての `~script$x から共有される，`~JS実行~文脈$js。
すなわち、これらの~scriptは，この`~JS~realm$js内にある。
［
`~classic~script$ ／ `~module~script$
］を走らすときは、この実行~文脈が`~JS実行~文脈~stack$jsの一番上になり，その上に当の~scriptに特有の別の実行~文脈が~pushされる。
（こう設定しておけば、［
`ParseScript$jA ／ 
`Source Text Module Record$js の `Evaluate$jA
］は，どの~Realmを利用するかを知れるようになる。）
◎
A JavaScript execution context shared by all scripts that use this settings object, i.e. all scripts in a given JavaScript realm. When we run a classic script or run a module script, this execution context becomes the top of the JavaScript execution context stack, on top of which another execution context specific to the script in question is pushed. (This setup ensures ParseScript and Source Text Module Record's Evaluate know which Realm to use.)
</dd>

	<dt>
`~module~map@enV
◎
A module map
</dt>
	<dd>
`~module~map$
— ~JS~moduleを~importするときに利用される。
◎
A module map that is used when importing JavaScript modules.
</dd>

	<dt>
`担当の閲覧文脈@enV
◎
A responsible browsing context
</dt>
	<dd>
［
%設定群 を利用する各~scriptがとる動作
］を担当するものとされる，`閲覧文脈$。
◎
A browsing context that is assigned responsibility for actions taken by the scripts that use this environment settings object.
</dd>
	<dd class="example">
例えば、~scriptが新たな`~top-level閲覧文脈$を作成して`~navigate$するとき、新たな`閲覧文脈$の`~window$の `opener$m 属性は，`担当の閲覧文脈$enVの `WindowProxy$I ~objに設定されることになる。
◎
When a script creates and navigates a new top-level browsing context, the opener attribute of the new browsing context's Window object will be set to the responsible browsing context's WindowProxy object.
</dd>

	<dt>
`担当の~event-loop@enV
◎
A responsible event loop
</dt>
	<dd>
［
どの~event-loopを利用するか，すぐには はっきりしない
］ときに利用される，`~event-loop$。
◎
An event loop that is used when it would not be immediately clear what event loop to use.
</dd>
	<dd class="trans-note">【
はっきりした時点で、特定0の~event-loopに振り分けられる（不定な~event-loopであって，他の処理に影響する前に何らかの~event-loopに確定される）ことを意味すると見られる。
】</dd>

	<dt>
`担当の文書@enV
◎
A responsible document
</dt>
	<dd>
［
%設定群 を利用する各~scriptがとる動作
］を担当するものとされる，`文書$。
◎
A Document that is assigned responsibility for actions taken by the scripts that use this environment settings object.
</dd>
	<dd class="example">
例えば、`担当の文書$enVの`~URL$docは、`文書$の`~URL$docを設定するために利用される
— それが `document.open()$m を利用して再設定された後に。
◎
For example, the URL of the responsible document is used to set the URL of the Document after it has been reset using document.open().
</dd>
	<dd>
`担当の~event-loop$enVが`閲覧文脈~event-loop$でない場合、
%設定群 は，`担当の文書$enVを持たない。
◎
If the responsible event loop is not a browsing context event loop, then the environment settings object has no responsible document.
</dd>

	<dt>
`~API用~URL文字~符号化方式@enV
◎
An API URL character encoding
</dt>
	<dd>
［［
%設定群 を利用している~script
］により~callされる~APIが，~URLを符号化する
］ときに利用する，文字~符号化方式。
◎
A character encoding used to encode URLs by APIs called by scripts that use this environment settings object.
</dd>

	<dt>
`~API用~基底~URL@enV
◎
An API base URL
</dt>
	<dd>
［［
%設定群 を利用している~script
］により~callされる~APIが，~URLを`相対的に構文解析-$する
］ときに利用する，`~URL$。
◎
A URL used by APIs called by scripts that use this environment settings object to parse URLs.
</dd>

	<dt>`生成元@enV
◎
An origin
</dt>
	<dd>
保安~検査に利用される`生成元$。
◎
An origin used in security checks.
</dd>

	<dt>
`~HTTPS状態@enV
◎
An HTTPS state
</dt>
	<dd>
`~HTTPS状態~値$
— ［［
%設定群 が結付けらている資源
］を送達するために利用されている~network-channel
］の，保安~上の特性を表現する。
◎
An HTTPS state value representing the security properties of the network channel used to deliver the resource with which the environment settings object is associated.
</dd>

	<dt>
`~referrer施策@enV
◎
A referrer policy
</dt>
	<dd>
［
%設定群 を`要請~client$rqに利用して遂行される`~fetch$
］用の，既定の`~referrer施策$。
`REFERRERPOLICY$r
◎
The default referrer policy for fetches performed using this environment settings object as a request client. [REFERRERPOLICY] 
</dd>

</dl>

<div class="p">
<p>
各 `環境~設定群~obj$に対しては、次も定義される：
</p>

<dl class="def-list">
	<dt>`通知待ちの却下済み~promise~list@enV</dt>
	<dd>
次項とともに，
<a href="#unhandled-promise-rejections">未取扱いの~promise却下</a>
を追跡するために利用される。
</dd>

	<dt>`未決の却下済み~promiseへの弱い参照の集合@enV</dt>
	<dd>
~promiseへの弱い参照からなる集合
— これらのどの参照も強い参照であっては~MUST_NOT。
実装はまた、含まれる参照の個数を自由に制限してよい
— 例えば、新たな参照が追加されたときに，古いものを除去するなど。
</dd>
</dl>
◎
An environment settings object also has an outstanding rejected promises weak set and an about-to-be-notified rejected promises list, used to track unhandled promise rejections. The outstanding rejected promises weak set must not create strong references to any of its members, and implementations are free to limit its size, e.g. by removing old entries from it when new ones are added.
</div>
				</section>
				<section id="fetching-scripts">
<h4 title="Fetching scripts">8.1.3.2. ~scriptの~fetch法</h4>

<p>
この節では、~scriptを~fetchするための各種~algoを導入する。
それらは、種々の必要な入力から［
`~classic~script$, または`~module~script$
］を得る。
◎
This section introduces a number of algorithms for fetching scripts, taking various necessary inputs and resulting in classic or module scripts.
</p>


<hr>

<p>
`~script~fetch~options@
は、次の`~item$を有する`構造体$である：
◎
Script fetch options is a struct with the following items:
</p>

<dl>
	<dt>`暗号用~nonce@sfO</dt>
	<dd>
初期~fetchに, および
~importした~moduleを~fetchするときに利用される，`暗号用~nonce~metadata$rq。
◎
The cryptographic nonce metadata used for the initial fetch and for fetching any imported modules
</dd>

	<dt>`完全性~metadata@sfO</dt>
	<dd>
初期~fetchに利用される，`完全性~metadata$rq。
◎
The integrity metadata used for the initial fetch
</dd>

	<dt>`構文解析器~metadata@sfO</dt>
	<dd>
初期~fetchに, および
~importした~moduleを~fetchするときに利用される，`構文解析器~metadata$rq。
◎
The parser metadata used for the initial fetch and for fetching any imported modules
</dd>

	<dt>`資格証~mode@sfO</dt>
	<dd>
初期~fetchに, および
— `~module~script$の場合に限り —
~importした~moduleを~fetchするときに利用される，`資格証~mode$rq。
◎
The credentials mode used for the initial fetch (for module scripts) and for fetching any imported modules (for both module scripts and classic scripts)
</dd>

	<dt>`~referrer施策@sfO</dt>
	<dd>
初期~fetch, および
~importされる~moduleの~fetchingに利用される，`~referrer施策$rq。
◎
The referrer policy used for the initial fetch and for fetching any imported modules
</dd>

</dl>

<p class="note">注記：
`~classic~script$は、 `import()$c 特色機能を介して`~module~script$を~importできることに~~留意されたし。
◎
Recall that via the import() feature, classic scripts can import module scripts.
</p>

<p>
`既定の~classic~script~fetch~options@
は、次のようにされた`~script~fetch~options$である
⇒＃
`暗号用~nonce$sfO ~SET 空~文字列,
`完全性~metadata$sfO ~SET 空~文字列,
`構文解析器~metadata$sfO ~SET `not-parser-inserted^l,
`資格証~mode$sfO ~SET `omit^l,
`~referrer施策$sfO ~SET 空~文字列
◎
The default classic script fetch options are a script fetch options whose cryptographic nonce is the empty string, integrity metadata is the empty string, parser metadata is "not-parser-inserted", credentials mode is "omit", and referrer policy is the empty string.
</p>

<p>
所与の
( `要請$ %要請, `~script~fetch~options$ %~options )
に対し，次が定義される：
◎
Given a request request and a script fetch options options, we define:
</p>

<ul>
	<li>
`~classic~script要請を設定しておく@
ときは、次のように %要請 を設定する
⇒＃
`暗号用~nonce~metadata$rq ~SET %~options の`暗号用~nonce$sfO,
`完全性~metadata$rq ~SET %~options の`完全性~metadata$sfO,
`構文解析器~metadata$rq ~SET %~options の`構文解析器~metadata$sfO,
`~referrer施策$rq ~SET %~options の`~referrer施策$sfO
◎
set up the classic script request
• Set request's cryptographic nonce metadata to options's cryptographic nonce, its integrity metadata to options's integrity metadata, its parser metadata to options's parser metadata, and its referrer policy to options's referrer policy.
, and .
</li>
	<li>
`~module~script要請を設定しておく@
ときは、次のように %要請 を設定する
⇒＃
`暗号用~nonce~metadata$rq ~SET %~options の`暗号用~nonce$sfO,
`完全性~metadata$rq ~SET %~options の`完全性~metadata$sfO,
`構文解析器~metadata$rq ~SET %~options の`構文解析器~metadata$sfO,
`資格証~mode$rq ~SET %~options の`資格証~mode$sfO,
`~referrer施策$rq ~SET %~options の`~referrer施策$sfO
◎
set up the module script request
• Set request's cryptographic nonce metadata to options's cryptographic nonce, its integrity metadata to options's integrity metadata, its parser metadata to options's parser metadata, its credentials mode to options's credentials mode, and its referrer policy to options's referrer policy.
</li>
</ul>

<p>
`子孫~script~fetch~options@
は、所与の
( `~script~fetch~options$ %~options )
に対し，次のようにされた新たな`~script~fetch~options$を返す
⇒＃
`完全性~metadata$sfO ~SET 空~文字列,
他のすべての`~item$は %~options と同じ値
◎
For any given script fetch options options, the descendant script fetch options are a new script fetch options whose items all have the same values, except for the integrity metadata, which is instead the empty string.
</p>

<hr>

<p>
これらの~algoを利用する仕様は、任意選択で
`~fetchを遂行する@
~custom~hookを給して，~algoを~customizeできる
— この~custom~hookは：
◎
The algorithms below can be customized by optionally supplying a custom perform the fetch hook,＼
</p>

<ul>
	<li>
(
`要請$,
`~top-level内~flag@V
) が入力に渡される。
◎
which takes a request and an is top-level flag.＼
</li>
	<li>
`応答$を結果とし~MUST（`~network~error$も可）。
◎
The algorithm must complete with a response (which may be a network error),＼
</li>
	<li>
`~workerが~importした~classic~scriptを~fetchする$ときは，結果を同期的に返し、他の場合は，`非同期に完了-$し~MUST。
◎
either synchronously (when using fetch a classic worker-imported script) or asynchronously (otherwise).＼
</li>
	<li>
<p>
`~top-level内~flag$V は：
</p>
		<ul>
			<li>
［
`~classic~script$に対する すべての~fetch, および［
`~module~script~graphを~fetchする$ ／
`~worker用~module~script~graphを~fetchする$
］ときの初期~fetch
］に対しては， ~ON にされる
</li>
			<li>
［
~module~script~graphを通り抜ける間に遭遇した `import^c 文による結果の~fetch
］に対しては， ~OFF にされる。
</li>
		</ul>
◎
The is top-level flag will be set for all classic script fetches, and for the initial fetch when fetching a module script graph or fetching a module worker script graph, but not for the fetches resulting from import statements encountered throughout the graph.
</li>
</ul>


<div class="note">

<p>注記：
`~fetchを遂行する$~hookを給さない，既定の場合では、以下の~algoは，単純に 所与の`要請$を`~fetch$することになるが、［
`要請$, および 結果の`応答$の検証
］に対する~algo特有の~custom化も伴う。
◎
By default, not supplying the perform the fetch will cause the below algorithms to simply fetch the given request, with algorithm-specific customizations to the request and validations of the resulting response.
</p>

<p>
~algo特有の~custom化の上層に，自前の~custom化を重ねたい仕様~策定者は、次のような`~fetchを遂行する$~hookを給すること
⇒
所与の`要請$を改変して, それを`~fetch$して, 結果の`応答$に対する特有の検証を遂行する（検証に失敗したなら`~network~error$で完了する）
◎
To layer your own customizations on top of these algorithm-specific ones, supply a perform the fetch hook that modifies the given request, fetches it, and then performs specific validations of the resulting response (completing with a network error if the validations fail).
</p>

<p>
この~hookは、より微妙な~custom化を遂行するためにも利用できる
— `応答$を~cacheしておいて，`~fetch$をまったく遂行せずに済ませるためなど。
◎
The hook can also be used to perform more subtle customizations, such as keeping a cache of responses and avoiding performing a fetch at all.
</p>

</div>

<p class="note">注記：
<cite>Service Workers</cite> `SW$r
は、この~hookとして自前の~optionを与えて，これらの~algoを走らす仕様の例である。
◎
Service Workers is an example of a specification that runs these algorithms with its own options for the hook. [SW]
</p>

<hr>

<p>
各種~algo自体は、ここから：
◎
Now for the algorithms themselves.
</p>

<p class="algo-head">
`~classic~scriptを~fetchする@
ときは、所与の (
%~url,
%設定群~obj,
%~options,
%~CORS設定,
%文字~符号化方式
)
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
新たな`~classic~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch a classic script given a url, a settings object, some options, a CORS setting, and a character encoding, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new classic script (on success).
</p>

<ol>
	<li>
%要請 ~LET
`~CORSになり得る要請を作成する$( %~url, `script^l, %~CORS設定 )
◎
Let request be the result of creating a potential-CORS request given url, "script", and CORS setting.
</li>
	<li>
%要請 の`~client$rq ~SET %設定群~obj
◎
Set request's client to settings object.
</li>
	<li>
`~classic~script要請を設定しておく$( %要請, %~options )
◎
Set up the classic script request given request and options.
</li>
	<li>
<div class="p">
<p>
~IF［
この~algoの~call元にて，`~fetchを遂行する$ ~custom手続き %C が指定されている
］：
</p>
		<ol>
			<li>
次を与える下で， %C を遂行する
⇒
%要請, ［
`~top-level内~flag$V ~SET ~ON
］
</li>
			<li>
~RET
— ただし，以降の手続きは、 %C を完了した結果の`応答$ %応答 に対し走らす
</li>
		</ol>
◎
If the caller specified custom steps to perform the fetch, perform them on request, with the is top-level flag set. Return from this algorithm, and when the custom perform the fetch steps complete with response response, run the remaining steps.
</div>

<div class="p">
<p>
~ELSE：
</p>
		<ol>
			<li>
%要請 を`~fetch$する
</li>
			<li>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$ %応答 に対し`応答を処理する$
］一部として走らす
</li>
		</ol>
◎
Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.
</div>

<p class="note">注記：
%応答 は、［
`~CORS同一生成元$, `~CORS非同一生成元$
］のいずれにもなり得る。
これは、~error報告がどう起こるかにのみ影響する。
◎
response can be either CORS-same-origin or CORS-cross-origin. This only affects how error reporting happens.
</p>
	</li>
	<li>
%応答 ~LET %応答 の`非安全~応答$
◎
Let response be response's unsafe response.
</li>
	<li>
~IF［
%応答 の`種別$rs ~EQ `error^l
］~OR［
%応答 の`~status$rs ~NIN { `~ok~status$rs }
］
⇒
~NULL を結果として，`非同期に完了-$する
◎
If response's type is "error", or response's status is not an ok status, asynchronously complete this algorithm with null, and abort these steps.
</li>
	<li>
~IF［
%応答 には`Content Type ~metadata$があって，それは
文字~符号化方式 %符号化方式 を指定する
］~AND［
~UAは %符号化方式 を~supportする
］
⇒
%文字~符号化方式 ~SET %符号化方式
（渡された %文字~符号化方式 は無視する）
◎
If response's Content Type metadata, if any, specifies a character encoding, and the user agent supports that encoding, then set character encoding to that encoding (ignoring the passed-in value).
</li>
	<li>
    <p>
%~source~text ~LET　`~Unicodeに復号する$( %文字~符号化方式, %応答 の`本体$rs )
◎
Let source text be the result of decoding response's body to Unicode, using character encoding as the fallback encoding.
</p>

<p class="note">注記：
~fileに BOM がある場合、この復号する~algoの %文字~符号化方式 は上書きされる。
◎
The decode algorithm overrides character encoding if the file contains a BOM.
</p>
   </li>
	<li>
%~errorは黙秘する ~LET ［
%応答 は`~CORS非同一生成元$であるならば ~T ／
~ELSE_ ~F
］
◎
Let muted errors be true if response was CORS-cross-origin, and false otherwise.
</li>
	<li>
%~script ~LET
`~classic~scriptを作成する$(
%~source~text,
%応答 の`~url$rs,
%~options,
%~errorは黙秘する
)
◎
Let script be the result of creating a classic script given source text, settings object, response's url, options, and muted errors.
</li>
	<li>
%~script を結果として，`非同期に完了-$する
◎
Asynchronously complete this algorithm with script.
</li>
</ol>

<p class="algo-head">
`~worker用~classic~scriptを~fetchする@
ときは、所与の
⇒＃
%~url,
%~fetch~client設定群~obj,
%行先,
%~script設定群~obj
◎終
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
新たな`~classic~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch a classic worker script given a url, a fetch client settings object, a destination, and a script settings object, run these steps. The algorithm will asynchronously complete with either null (on failure) or a new classic script (on success).
</p>

<ol>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~url$rq ~SET %~url,
`~client$rq ~SET %~fetch~client設定群~obj,
`行先$rq ~SET %行先,
`~mode$rq ~SET `same-origin^l,
`資格証~mode$rq ~SET `same-origin^l,
`構文解析器~metadata$rq ~SET `not-parser-inserted^l<!-- ＊not parser-inserted -->,
`~URL資格証~利用~flag$rq ~SET ~ON
◎
Let request be a new request whose url is url, client is fetch client settings object, destination is destination, mode is "same-origin", credentials mode is "same-origin", parser metadata is "not parser-inserted", and whose use-URL-credentials flag is set.
</li>
	<li>
<div class="p">
<p>
~IF［
この~algoの~call元にて，`~fetchを遂行する$ ~custom手続き %C が指定されている
］：
</p>
		<ol>
			<li>
次を与える下で， %C を遂行する
⇒
%要請, ［
`~top-level内~flag$V ~SET ~ON
］
</li>
			<li>
~RET
— ただし，以降の手続きは、 %C を完了した結果の`応答$ %応答 に対し走らす
</li>
		</ol>
◎
If the caller specified custom steps to perform the fetch, perform them on request, with the is top-level flag set. Return from this algorithm, and when the custom perform the fetch steps complete with response response, run the remaining steps.
</div>

<div class="p">
<p>
~ELSE：
</p>
		<ol>
			<li>
%要請 を`~fetch$する
</li>
			<li>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$ %応答 に対し`応答を処理する$
］一部として走らす
</li>
		</ol>
◎
Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.
</div>

	</li>
	<li>
%応答 ~LET %応答 の`非安全~応答$
◎
Let response be response's unsafe response.
</li>
	<li>
~IF［
%応答 の`種別$rs ~EQ `error^l
］~OR［
%応答 の`~status$rs ~NIN { `~ok~status$rs }
］
⇒
~NULL を結果として，`非同期に完了-$する
◎
If response's type is "error", or response's status is not an ok status, asynchronously complete this algorithm with null, and abort these steps.
</li>
	<li>
%~source~text ~LET `~UTF-8復号する$( %応答 の`本体$rs )
◎
Let source text be the result of UTF-8 decoding response's body.
</li>
	<li>
%~script ~LET
`~classic~scriptを作成する$(
%~source~text,
%~script設定群~obj,
%応答 の`~url$rs,
`既定の~classic~script~fetch~options$
)
◎
Let script be the result of creating a classic script using source text, script settings object, response's url, and the default classic script fetch options.
</li>
	<li>
%~script を結果として，`非同期に完了-$する
◎
Asynchronously complete this algorithm with script.
</li>
</ol>

<p class="algo-head">
`~workerが~importした~classic~scriptを~fetchする@
ときは、所与の (
%~url, %設定群~obj
)
に対し，次を走らす
— この~algoは、同期的に完了し，例外を投出する（失敗~時）か, 新たな`~classic~script$を返す（成功~時）：
◎
To fetch a classic worker-imported script given a url and a settings object, run these steps. The algorithm will synchronously complete with a classic script on success, or throw an exception on failure.
</p>

<ol>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~url$rq ~SET %~url,
`~client$rq ~SET %設定群~obj,
`行先$rq ~SET `script^l,
`構文解析器~metadata$rq ~SET `not-parser-inserted^l,
`同期~flag$rq ~SET ~ON,
`~URL資格証~利用~flag$rq ~SET ~ON
◎
Let request be a new request whose url is url, client is settings object, destination is "script", parser metadata is "not parser-inserted", synchronous flag is set, and whose use-URL-credentials flag is set.
</li>
	<li>
<p>
~IF［
この~algoの~call元にて，`~fetchを遂行する$ ~custom手続き %C が指定されている
］
⇒
%応答 ~LET 次を与える下で， %C を遂行した結果
⇒
%要請, ［
`~top-level内~flag$V ~SET ~ON
］
◎
If the caller specified custom steps to perform the fetch, perform them on request, with the is top-level flag set. Let response be the result.
</p>

<p>
~ELSE
⇒
%応答 ~LET %要請 を`~fetch$した結果
◎
Otherwise, fetch request, and let response be the result.
</p>

<p class="note">注記：
この節の他の~algoと違って，ここでの~fetchingは同期的に行われる。
したがって、ここで`~fetchを遂行する$どの手続きも，その仕事を同期的に終えることになる。
◎
Unlike other algorithms in this section, the fetching process is synchronous here. Thus any perform the fetch steps will also finish their work synchronously.
</p>
	</li>
	<li>
%応答 ~LET %応答 の`非安全~応答$
◎
Let response be response's unsafe response.
</li>
	<li>
~IF［
%応答 の`種別$rs ~EQ `error^l
］~OR［
%応答 の`~status$rs ~NIN { `~ok~status$rs }
］
⇒
~THROW `NetworkError$E
◎
If response's type is "error", or response's status is not an ok status, throw a "NetworkError" DOMException.
</li>
	<li>
%~source~text ~LET `~UTF-8復号する$( %応答 の`本体$rs )
◎
Let source text be the result of UTF-8 decoding response's body.
</li>
	<li>
%~errorは黙秘する ~LET ［
%応答 は`~CORS非同一生成元$であるならば ~T ／
~ELSE_ ~F
］
◎
Let muted errors be true if response was CORS-cross-origin, and false otherwise.
</li>
	<li>
%~script ~LET
`~classic~scriptを作成する$(
%~source~text,
%設定群~obj,
%応答 の`~url$rs,
`既定の~classic~script~fetch~options$,
%~errorは黙秘する
)
◎
Let script be the result of creating a classic script given source text, settings object, response's url, the default classic script fetch options, and muted errors.
</li>
	<li>
~RET %~script
◎
Return script.
</li>
</ol>

<p class="algo-head">
`~module~script~graphを~fetchする@
ときは、所与の (
%~url,
%設定群~obj,
%行先,
%~options
)
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
`~module~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch a module script graph given a url, a settings object, a destination, and some options, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).
</p>

<ol>
	<li>
%訪問-済み集合 ~LET « %~url »
◎
Let visited set be « url ».
</li>
	<li>
次を与える下で，`~module~script~graphを~fetchする内部手続き$を遂行する
⇒＃
%~url,
%設定群~obj,
%行先,
%~options,
%設定群~obj,
%訪問-済み集合,
`client^l,
~ON（ %~top-level~module~fetch~flag ）
◎終
— この~algoの~call元にて`~fetchを遂行する$ ~custom手続きが指定されている場合、それも渡す。
◎
Perform the internal module script graph fetching procedure given url, settings object, destination, options, settings object, visited set, "client", and with the top-level module fetch flag set. If the caller of this algorithm specified custom perform the fetch steps, pass those along as well.
</li>
	<li>
`~module~script~graphを~fetchする内部手続き$が
%結果 を結果として`非同期に完了-$した時点で，この~algoも %結果 を結果として`非同期に完了-$する
◎
When the internal module script graph fetching procedure asynchronously completes with result, asynchronously complete this algorithm with result.
</li>
</ol>

<p class="algo-head">
`~worker用~module~script~graphを~fetchする@
ときは、所与の
⇒＃
%~url,
%~fetch~client設定群~obj,
%行先,
%資格証~mode,
%~module~map設定群~obj
◎終
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
`~module~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch a module worker script graph given a url, a fetch client settings object, a destination, a credentials mode, and a module map settings object, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).
</p>

<ol>
	<li>
%訪問-済み集合 ~LET « %~url »
◎
Let visited set be « url ».
</li>
	<li>
%~options ~LET 次のようにされた`~script~fetch~options$
⇒＃
`暗号用~nonce$sfO ~SET 空~文字列,
`完全性~metadata$sfO ~SET 空~文字列,
`構文解析器~metadata$sfO ~SET `not-parser-inserted^l,
`資格証~mode$sfO ~SET %資格証~mode,
`~referrer施策$sfO ~SET 空~文字列
◎
Let options be a script fetch options whose cryptographic nonce is the empty string, integrity metadata is the empty string, parser metadata is "not-parser-inserted", credentials mode is credentials mode, and referrer policy is the empty string.
</li>
	<li>
次を与える下で，`~module~script~graphを~fetchする内部手続き$を遂行する
⇒＃
%~url,
%~fetch~client設定群~obj,
%行先,
%~options,
%~module~map設定群~obj
%訪問-済み集合,
`client^l,
~ON（ %~top-level~module~fetch~flag ）
◎終
— この~algoの~call元にて`~fetchを遂行する$ ~custom手続きが指定されている場合、それも渡す。
◎
Perform the internal module script graph fetching procedure given url, fetch client settings object, destination, options, module map settings object, visited set, "client", and with the top-level module fetch flag set. If the caller of this algorithm specified custom perform the fetch steps, pass those along as well.
</li>
	<li>
`~module~script~graphを~fetchする内部手続き$が
%結果 を結果として`非同期に完了-$した時点で，この~algoも %結果 を結果として`非同期に完了-$する
◎
When the internal module script graph fetching procedure asynchronously completes with result, asynchronously complete this algorithm with result.
</li>
</ol>

<hr>

<p>
以下の各種~algoは、［
`~module~script~graphを~fetchする$／
`~scriptを準備-$する
］の一部を成すものとして，この仕様の内部~利用のみに~~意図されている。
他の仕様は、これらを直接的に利用するべきではない。
◎
The following algorithms are meant for internal use by this specification only as part of fetching a module script graph or preparing a script, and should not be used directly by other specifications.
</p>

<p class="algo-head">
`~module~script~graphを~fetchする内部手続き@
を遂行するときは、所与の
⇒＃
%~url,
%~fetch~client設定群~obj,
%行先,
%~options,
%~module~map設定群~obj,
%訪問-済み集合,
%~referrer,
%~top-level~module~fetch~flag
◎終
に対し，次の手続きを遂行する。
この~algoは、［
~NULL （失敗~時） ／
`~module~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To perform the internal module script graph fetching procedure given a url, a fetch client settings object, a destination, a some options, a module map settings object, a visited set, a referrer, and a top-level module fetch flag, perform these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).
</p>

<ol>
	<li>
~Assert：
%~url ~IN %訪問-済み集合
◎
Assert: visited set contains url.
</li>
	<li>
<p>
次を与える下で，`単独の~module~scriptを~fetchする$
⇒＃
%~url,
%~fetch~client設定群~obj,
%行先,
%~options,
%~module~map設定群~obj,
%~referrer,
%~top-level~module~fetch~flag
◎終
— この~algoの~call元にて`~fetchを遂行する$ ~custom手続きが指定されている場合、それも渡す。
◎
Fetch a single module script given url, fetch client settings object, destination, options, module map settings object, referrer, and the top-level module fetch flag. If the caller of this algorithm specified custom perform the fetch steps, pass those along while fetching a single module script.
</li>
	<li>
<p>
~RET
— 前~段の~fetchが %結果 を結果として`非同期に完了-$したときは、以下を走らす：
◎
Return from this algorithm, and run the following steps when fetching a single module script asynchronously completes with result:
</p>
		<ol>
			<li>
~IF［
%結果 ~EQ ~NULL
］
⇒
~NULL を結果として，`非同期に完了-$する
◎
If result is null, asynchronously complete this algorithm with null, and abort these steps.
</li>
			<li>
<p>
%~top-level~module~fetch~flag に応じて：
</p>
				<dl class="switch">
					<dt>~ON</dt>
					<dd>
%結果 の`子孫を~fetchして~instance化する$( %行先, %訪問-済み集合 )
</dd>

					<dt>~OFF</dt>
					<dd>
%結果 の`子孫を~fetchする$( %行先, %訪問-済み集合 )
</dd>
				</dl>
◎
If the top-level module fetch flag is set, fetch the descendants of and instantiate result given destination and visited set. Otherwise, fetch the descendants of result given the same arguments.
</li>
			<li>
前~段のいずれかの~algoが %最終~結果 を結果として，`非同期に完了-$したときは
⇒
%最終~結果 を結果として，`非同期に完了-$する
◎
When the appropriate algorithm asynchronously completes with final result, asynchronously complete this algorithm with final result.
</li>
		</ol>
	</li>
</ol>

<p class="algo-head">
`単独の~module~scriptを~fetchする@
ときは、所与の
⇒＃
%~url,
%~fetch~client設定群~obj,
%行先,
%~options,
%~module~map設定群~obj,
%~referrer,
%~top-level~module~fetch~flag
◎終
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
`~module~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch a single module script, given a url, a fetch client settings object, a destination, some options, a module map settings object, a referrer, and a top-level module fetch flag, run these steps. The algorithm will asynchronously complete with either null (on failure) or a module script (on success).
</p>

<ol>
	<li>
%~module~map ~LET %~module~map設定群~obj の`~module~map$enV
◎
Let moduleMap be module map settings object's module map.
</li>
	<li>
~IF［
%~module~map[ %~url ] ~EQ `fetching^l
］
⇒
%~module~map[ %~url ] が変化するまで，この段で`並列的$に待機した上で、`~network用~task源$を用いて，この手続きの以降の部分を続行する`~taskを~queueする$
◎
If moduleMap[url] is "fetching", wait in parallel until that entry's value changes, then queue a task on the networking task source to proceed with running the following steps.
</li>
	<li>
~IF［
%~module~map[ %~url ] ~NEQ ε
］
⇒
%~module~map[ %~url ] を結果として，`非同期に完了-$する
◎
If moduleMap[url] exists, asynchronously complete this algorithm with moduleMap[url], and abort these steps.
</li>
	<li>
%~module~map[ %~url ] `~SET$ `fetching^l
◎
Set moduleMap[url] to "fetching".
</li>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~url$rq ~SET %~url,
`行先$rq ~SET %行先,
`~mode$rq ~SET `cors^l,
`~referrer$rq ~SET %~referrer,
`~client$rq ~SET %~fetch~client設定群~obj
◎
Let request be a new request whose url is url, destination is destination, mode is "cors", referrer is referrer, and client is fetch client settings object.
</li>
	<li>
`~module~script要請を設定しておく$( %要請, %~options )
◎
Set up the module script request given request and options.
</li>
	<li>
<div class="p">
<p>
~IF［
この~algoの~call元にて，`~fetchを遂行する$ ~custom手続き %C が指定されている
］：
</p>
		<ol>
			<li>
次を与える下で， %C を遂行する
⇒
%要請, ［
`~top-level内~flag$V ~SET %~top-level~module~fetch~flag
］
</li>
			<li>
~RET
— ただし，以降の手続きは、 %C を完了した結果の`応答$ %応答 に対し走らす
</li>
		</ol>

◎
If the caller specified custom steps to perform the fetch, perform them on request, setting the is top-level flag if the top-level module fetch flag is set. Return from this algorithm, and when the custom perform the fetch steps complete with response response, run the remaining steps.
</div>

<div class="p">
<p>
~ELSE：
</p>
		<ol>
			<li>
%要請 を`~fetch$する
</li>
			<li>
~RET
— ただし，以降の手続きは、［
~fetchした結果の`応答$ %応答 に対し`応答を処理する$
］一部として走らす
</li>
		</ol>
◎
Otherwise, fetch request. Return from this algorithm, and run the remaining steps as part of the fetch's process response for the response response.
</div>

<p class="note">注記：
%応答 は、常に`~CORS同一生成元$になる。
◎
response is always CORS-same-origin.
</p>
   </li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
If any of the following conditions are met, set moduleMap[url] to null, asynchronously complete this algorithm with null, and abort these steps:
</p>

		<ul>
			<li>
%応答 の`種別$rs ~EQ `error^l
◎
response's type is "error"
</li>
			<li>
%応答 の`~status$rsは`~ok~status$rsでない
◎
response's status is not an ok status
</li>
			<li>
`~MIME型を抽出する$( %応答 の`~header~list$rs )
の結果は、~parameterは無視して，`~JS~MIME型$でない
◎
The result of extracting a MIME type from response's header list (ignoring parameters) is not a JavaScript MIME type
</li>
		</ul>

<p>
…ならば
⇒＃
%~module~map[ %~url ] `~SET$ ~NULL；
~NULL を結果として，`非同期に完了-$する
◎
↑</p>

<p class="note">注記：
歴史的~理由から、`~classic~scriptを~fetchする$ときは，~MIME型は検査されない。
対照的に，~module~scriptは、正しい~MIME型でなければ，読込みに失敗することになる。
◎
For historical reasons, fetching a classic script does not include MIME type checking. In contrast, module scripts will fail to load if they are not of a correct MIME type.
</p>
	</li>
	<li>
%~source~text ~LET `~UTF-8復号する$( %応答 の`本体$rs )
◎
Let source text be the result of UTF-8 decoding response's body.
</li>
	<li>
%~module~script ~LET `~module~scriptを作成する$(
%~source~text,
%~module~map設定群~obj,
%応答 の`~url$rs,
%~options
)
◎
Let module script be the result of creating a module script given source text, module map settings object, response's url, and options.
</li>
	<li>
<p>
%~module~map[ %~url ] `~SET$ %~module~script；<br>
%~module~script を結果として，`非同期に完了-$する
◎
Set moduleMap[url] to module script, and asynchronously complete this algorithm with module script.
</p>

<p class="note">注記：
`~module~map$は`要請~URL$rqを~keyとする一方で，`~module~script$の`基底~URL$sCは`応答~URL$rsに設定されるのは、意図的である。
前者は~fetchを重複させないために利用される一方で、後者は~URL解決に利用される。
◎
It is intentional that the module map is keyed by the request URL, whereas the base URL for the module script is set to the response URL. The former is used to deduplicate fetches, while the latter is used for URL resolution.
</p>

</li>
</ol>


<p class="algo-head">
`~module~script$ %~module~script の
`子孫を~fetchする@
ときは、所与の
( %行先, %訪問-済み集合 )
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
`~module~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch the descendants of a module script module script, given a destination and a visited set, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).
</p>

<ol>
	<li>
%~record ~LET %~module~script の`~record$sC
◎
↓</li>
	<li>
~IF［
%~record ~EQ ~NULL
］
⇒
%~module~script を結果として，`非同期に完了-$する
◎
If module script's record is null, then asynchronously complete this algorithm with module script and abort these steps.
◎
Let record be module script's record.
</li>
	<li>
~IF［
%~record . `RequestedModules^sl は`空$である
］
⇒
%~module~script を結果として，`非同期に完了-$する
◎
If record.[[RequestedModules]] is empty, asynchronously complete this algorithm with module script.
</li>
	<li>
%~url~list ~LET 新たな空`~list$
◎
Let urls be a new empty list.
</li>
	<li>
<p>
%~record . `RequestedModules^sl 内の `~EACH$( 文字列 %要請された何か ) に対し：
◎
For each string requested of record.[[RequestedModules]],
</p>
		<ol>
			<li>
%~url ~LET `~module指定子を解決する$( %~module~script, %要請された何か )
◎
Let url be the result of resolving a module specifier given module script and requested.
</li>
			<li>
~Assert：
%~url ~NEQ `失敗^i
— 以前にも、同じ引数で，`~module指定子を解決する$のに成功している。
◎
Assert: url is never failure, because resolving a module specifier must have been previously successful with these same two arguments.
</li>
			<li>
<p>
~IF［
%~url ~NIN %訪問-済み集合
］：
◎
If visited set does not contain url, then:
</p>
				<ol>
					<li>
%~url~list に %~url を`付加する$
◎
Append url to urls.
</li>
					<li>
%訪問-済み集合 に %~url を`付加する$set
◎
Append url to visited set.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~options ~LET `子孫~script~fetch~options$( %~module~script の`~fetch~options$sC )
◎
Let options be the descendant script fetch options for module script's fetch options.
</li>

	<li>
<p>
%~url~list 内の `~EACH$( %~url ) に対し
⇒
次を与える下で，`~module~script~graphを~fetchする内部手続き$を遂行する
⇒＃
%~url,
%~options,
%行先,
%~module~script の`設定群~obj$sC,
%~module~script の`設定群~obj$sC,
%訪問-済み集合,
%~module~script の`基底~URL$sC,
~OFF（ %~top-level~module~fetch~flag ）
◎終
— この~algoの~call元にて`~fetchを遂行する$ ~custom手続きが指定されている場合、それも渡す。
◎
For each url in urls, perform the internal module script graph fetching procedure given url, options, destination, module script's settings object, module script's settings object, visited set, module script's base URL, and with the top-level module fetch flag unset. If the caller of this algorithm specified custom perform the fetch steps, pass those along while performing the internal module script graph fetching procedure.
</p>

<p>
これらの`~module~script~graphを~fetchする内部手続き$の呼出は、互いに並列的に遂行されるべきである
— そうするかどうかに関わらず：
◎
These invocations of the internal module script graph fetching procedure should be performed in parallel to each other.
</p>
		<ol>
			<li>
~IF［
ある呼出が ~NULL を結果として`非同期に完了-$した
］
⇒
~NULL を結果として，`非同期に完了-$する
◎
If any of the invocations of the internal module script graph fetching procedure asynchronously complete with null, asynchronously complete this algorithm with null, aborting these steps.
</li>
			<li>
~ELSE
— したがって［
すべての呼出が `非同期に完了-$する
］まで待機した上で
⇒
%~module~script を結果として，`非同期に完了-$する
◎
Otherwise, wait until all of the internal module script graph fetching procedure invocations have asynchronously completed. Asynchronously complete this algorithm with module script.
</li>
		</ol>
	</li>
</ol>


<p class="algo-head">
`~module~script$ %~module~script の
`子孫を~fetchして~instance化する@
ときは、所与の
( %行先, %訪問-済み集合 （省略時は空`集合$） )
に対し，次を走らす
— この~algoは、［
~NULL （失敗~時） ／
`~module~script$（成功~時）
］を結果として，`非同期に完了-$する：
◎
To fetch the descendants of and instantiate a module script module script, given a destination and an optional visited set, run these steps. The algorithm will asynchronously complete with either null (on failure) or with module script (on success).
• If visited set was not given, let it be an empty set.
</p>

<ol>
	<li>
%~module~script の`子孫を~fetchする$( %行先, %訪問-済み集合 )
◎
Fetch the descendants of module script, given destination and visited set.
</li>
	<li>
~RET
— ただし、［
前~段の`子孫を~fetchする$
］が， %結果 を結果として `非同期に完了-$したときには、以下を走らす：
◎
Return from this algorithm, and run the following steps when fetching the descendants of a module script asynchronously completes with result.
</li>
	<li>
<p>
~IF［
%結果 ~EQ ~NULL
］
⇒
%結果 を結果として，`非同期に完了-$する
◎
If result is null, then asynchronously complete this algorithm with result.
</p>

<p class="note">注記：
この事例では， 1 個~以上の子孫において、~fetchingに~errorが生じている。
よって、~instance化しようとは試みない。
◎
In this case, there was an error fetching one or more of the descendants. We will not attempt to instantiate.
</p>
	</li>
	<li>
%構文解析-~error ~LET `最初の~errorを見出す$( %結果 )
◎
Let parse error be the result of finding the first parse error given result.
</li>
	<li>
<p>
~IF［
%構文解析-~error ~EQ ~NULL
］：
◎
If parse error is null, then:
</p>

		<ol>
			<li>
<p>
( %結果 の`~record$sC ) . `Instantiate$jA()
を遂行する
◎
Let record be result's record.
◎
Perform record.Instantiate().
</p>

<p class="note">注記：
この段は、当の~moduleの~instance化されていない依存物すべてに対し，
`Instantiate$jA を再帰的に~callすることになる。
◎
This step will recursively call Instantiate on all of the module's uninstantiated dependencies.
</p>


<p>
この段で例外 %E が投出されたときは
⇒
%結果 の`再投出-用~error$sC ~SET %E
◎
If this throws an exception, set result's error to rethrow to that exception.
</p>
			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%結果 の`再投出-用~error$sC ~SET %構文解析-~error
◎
Otherwise, set result's error to rethrow to parse error.
</li>
	<li>
%結果 を結果として，`非同期に完了-$する
◎
Asynchronously complete this algorithm with result.
</li>
</ol>

<p>
`最初の~errorを見出す@
ときは、所与の
( 根 %~module~script, %発見-済み集合 （省略時は新たな`集合$） )
に対し，次を走らす：
◎
To find the first parse error given a root moduleScript and an optional discoveredSet:
</p>

<ol>
	<li>
%~module~map ~LET %~module~script の`設定群~obj$sCの`~module~map$enV
◎
Let moduleMap be moduleScript's settings object's module map.
◎
If discoveredSet was not given, let it be an empty set.
</li>
	<li>
%発見-済み集合 に %~module~script を`付加する$set
<!--＊ list-append -->
◎
Append moduleScript to discoveredSet.
</li>
	<li>
~IF［
%~module~script の`~record$sC ~EQ ~NULL
］
⇒
~RET %~module~script の`構文解析-~error$sC
◎
If moduleScript's record is null, then return moduleScript's parse error.
</li>
	<li>
%子~指定子~list ~LET ( %~module~script の`~record$sC ) . `RequestedModules^sl
◎
Let childSpecifiers be the value of moduleScript's record's [[RequestedModules]] internal slot.
</li>
	<li>
%子~URL~list ~LET 新たな`~list$
◎
Let childURLs be the list＼
</li>
	<li>
<p>
%子~指定子~list 内の~EACH( %~item ) に対し
⇒
%子~URL~list に次の結果を`付加する$
⇒
`~module指定子を解決する$( %~module~script, %~item )
</p>

<p class="note">注記：
どの %~item に対しても，この結果が `失敗^i になることはない
— さもなければ， %~module~script 自身が構文解析-~errorとされている筈なので。
</p>
◎
obtained by calling resolve a module specifier once for each item of childSpecifiers, given moduleScript and that item. (None of these will ever fail, as otherwise moduleScript would have been marked as itself having a parse error.)
</li>
	<li>
%子~module~list ~LET 新たな`~list$
◎
Let childModules be the list＼
</li>
	<li>
%子~URL~list  内の~EACH( %~item ) に対し
⇒
%子~module~list に %~module~map[ %~item ] を`付加する$
◎
obtained by getting each value in moduleMap whose key is given by an item of childURLs.
</li>
	<li>
<p>
%子~module~list 内の`~EACH$( %子~module ) に対し：
◎
For each childModule of childModules:
</p>
		<ol>
			<li>
~Assert：
%子~module は`~module~script$である
（すなわち、 %子~module ~NIN { `fetching^l, ~NULL } ）
— この時点までに、［
~graph内の， %~module~script を根とする すべての`~module~script$
］に対する~fetchは，成功したことになる。
◎
Assert: childModule is a module script (i.e., it is not "fetching" or null); by now all module scripts in the graph rooted at moduleScript will have successfully been fetched.
</li>
			<li>
~IF［
%子~module ~IN %発見-済み集合
］
⇒
~CONTINUE
◎
If discoveredSet already contains childModule, continue.
</li>
			<li>
%子~構文解析-~error ~LET `最初の~errorを見出す$( %子~module, %発見-済み集合 )
◎
Let childParseError be the result of finding the first parse error given childModule and discoveredSet.
</li>
			<li>
~IF［
%子~構文解析-~error ~NEQ ~NULL
］
⇒
~RET %子~構文解析-~error
◎
If childParseError is not null, return childParseError.
</li>
		</ol>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

				</section>
				<section id="creating-scripts">
<h4 title="Creating scripts">8.1.3.3. ~scriptの作成-法</h4>

<p class="algo-head">
`~classic~scriptを作成する@
ときは、所与の
⇒＃
`~JS文字列$ %~source,
`環境~設定群~obj$ %設定群,
`~URL$ %基底~URL, 
`~script~fetch~options$ %~options,
真偽値 %~errorは黙秘する （省略時は ~F ）
◎終
に対し，次を走らす：
◎
To create a classic script, given a JavaScript string source, an environment settings object settings, a URL baseURL, some script fetch options options, and an optional muted errors boolean:
• If muted errors was not provided, let it be false.
</p>

<ol>
	<li>
~IF［
%設定群 の`担当の閲覧文脈$enVにおいて `~scriptingは不能化されて$いる
］
⇒
%~source ~SET 空~文字列
◎
If scripting is disabled for settings's responsible browsing context, then set source to the empty string.
</li>
	<li>
%~script ~LET 新たな`~classic~script$
◎
Let script be a new classic script that this algorithm will subsequently initialize.
</li>
	<li>
%~script の
⇒＃
`設定群~obj$sC ~SET %設定群,
`~errorは黙秘する$sC ~SET %~errorは黙秘する,
`構文解析-~error$sC ~SET ~NULL,
`再投出-用~error$sC ~SET ~NULL
◎
Set script's settings object to settings.
◎
Set script's muted errors to muted errors.
◎
Set script's parse error and error to rethrow to null.
</li>
	<li>
<p>
%結果 ~LET `ParseScript$jA( %~source, %設定群 の`~Realm$enV, %~script )
◎
Let result be ParseScript(source, settings's Realm, script).
</p>

<p class="note">注記：
ここで最後の~parameterに %~script を渡すことにより，［
%結果 . `HostDefined^sl ~EQ %~script
］になることが確保される。
◎
Passing script as the last parameter here ensures result.[[HostDefined]] will be script.
</p>
	</li>
	<li>
<p>
~IF［
%結果 は ~errorたちの`~list$である
］：
◎
If result is a list of errors, then:
</p>
		<ol>
			<li>
%~script の
⇒＃
`構文解析-~error$sC  ~SET %結果[0],
`再投出-用~error$sC ~SET %結果[0]
◎
Set script's parse error and its error to rethrow to result[0].
</li>
	<li>
~RET %~script
◎
Return script.
</li>
		</ol>
	</li>
	<li>
%~script の
⇒＃
`~record$sC ~SET %結果,
`基底~URL$sC ~SET %基底~URL,
`~fetch~options$sC ~SET %~options
◎
Set script's record to result.
◎
Set script's base URL to baseURL.
◎
Set script's fetch options to options.
</li>
	<li>
~RET %~script
◎
Return script.
</li>
</ol>

<p>
`~module~scriptを作成する@
ときは、所与の
⇒＃
`~JS文字列$ %~source,
`環境~設定群~obj$ %設定群,
`~URL~record$ %基底~URL,
`~script~fetch~options$ %~options
◎終
に対し，次を走らす：
◎
To create a module script, given a JavaScript string source, an environment settings object settings, a URL baseURL, and some script fetch options options:
</p>

<ol>
	<li>
~IF［
%設定群 の`担当の閲覧文脈$enVにおいて `~scriptingは不能化されて$いる
］
⇒
%~source ~SET 空~文字列
◎
If scripting is disabled for settings's responsible browsing context, then set source to the empty string.
</li>
	<li>
%~script ~LET 新たな`~module~script$
◎
Let script be a new module script that this algorithm will subsequently initialize.
</li>
	<li>
%~script の
⇒＃
`設定群~obj$sC ~SET %設定群,
`構文解析-~error$sC ~SET ~NULL,
`再投出-用~error$sC ~SET ~NULL
◎
Set script's settings object to settings.
◎
Set script's parse error and error to rethrow to null.
</li>
	<li>
<p>
%結果 ~LET `ParseModule$jA( %~source, %設定群 の`~Realm$enV, %~script )
◎
Let result be ParseModule(source, settings's Realm, script).
</p>

<p class="note">注記：
ここで最後の~parameterに %~script を渡すことにより，［
%結果 . `HostDefined^sl ~EQ %~script
］になることが確保される。
◎
Passing script as the last parameter here ensures result.[[HostDefined]] will be script.
</p>
	</li>
	<li>
<p>
~IF［
%結果 は ~errorたちの`~list$である
］：
◎
If result is a list of errors, then:
</p>
		<ol>
			<li>
%~script の`構文解析-~error$sC ~SET %結果[0]
◎
Set script's parse error to result[0].
</li>
	<li>
~RET %~script
◎
Return script.
</li>
		</ol>
	</li>
	<li id="validate-requested-module-specifiers">
<p>
%結果 . `RequestedModules^sl 内の ~EACH( 文字列 %要請された何か ) に対し：
◎
For each string requested of result.[[RequestedModules]]:
</p>
		<ol>
			<li>
%~url ~LET `~module指定子を解決する$( %~script, %要請された何か )
◎
Let url be the result of resolving a module specifier given script and requested.
</li>
			<li>
<p>
~IF［
%~url ~EQ `失敗^i
］：
◎
If url is failure, then:
</p>

				<ol>
					<li>
%~error ~LET 新たな `TypeError$js 例外
◎
Let error be a new TypeError exception.
</li>
					<li>
%~script の`構文解析-~error$sC ~SET %~error
◎
Set script's parse error to error.
</li>
					<li>
~RET %~script
◎
Return script.
</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
この段は、本質的に，要請された~module指定子すべてを検証する。
解決できない~module指定子は，構文解析できなかったのと同じに扱い、後で~moduleを~instance化するような考えは排される。
◎
This step is essentially validating all of the requested module specifiers. We treat a module with unresolvable module specifiers the same as one that cannot be parsed; in both cases, a syntactic issue makes it impossible to ever contemplate instantiating the module later.
</p>
	</li>
	<li>
%~script の
⇒＃
`~record$sC ~SET %結果,
`基底~URL$sC ~SET %基底~URL,
`~fetch~options$sC ~SET %~options
◎
Set script's record to result.
◎
Set script's base URL to baseURL.
◎
Set script's fetch options to options.
</li>
	<li>
~RET %~script
◎
Return script.
</li>
</ol>

				</section>
				<section id="calling-scripts">
<h4 title="Calling scripts">8.1.3.4. ~scriptの~call法</h4>

<p>
`~classic~scriptを走らす@
ときは、所与の (
`~classic~script$ %~script,
真偽値 %~errorは再投出する （省略時は ~F ）
)
に対し，次を走らす：
◎
To run a classic script given a classic script script and an optional rethrow errors boolean:
• If rethrow errors is not given, let it be false.
</p>

<ol>
	<li>
%設定群 ~LET %~script の`設定群~obj$sC
◎
Let settings be the settings object of script.
</li>
	<li>
~IF［
`~scriptは走れるかどうか検査する$( %設定群 ) ~EQ `走るな^i
］
⇒
~RET
◎
Check if we can run script with settings. If this returns "do not run" then return.
</li>
	<li>
`~scriptを走らすために準備する$( %設定群 )
◎
Prepare to run script given settings.
</li>
	<li>
%評価~status ~LET ~NULL
◎
Let evaluationStatus be null.
</li>
	<li>
~IF［
%~script の`再投出-用~error$sC ~NEQ ~NULL
］
⇒
%評価~status ~SET `Completion^js{
`Type^sl: `throw^js,
`Value^sl: %~script の`再投出-用~error$sC,
`Target^sl: `empty^js
}
◎
If script's error to rethrow is not null, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: script's error to rethrow, [[Target]]: empty }.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
<p>
%評価~status ~SET `ScriptEvaluation$jA( %~script の`~record$sC )
</p>

<p>
~IF［
~UAは`走っている~scriptを中止-$したため，
`ScriptEvaluation$jA は完了しなかった
］：
</p>
				<ol>
					<li>
`走らせた~scriptを片付ける$( %設定群 )
</li>
					<li>
~RET `undefined^jv
</li>
				</ol>
			</li>
		</ol>

◎
Otherwise, set evaluationStatus to ScriptEvaluation(script's record).
◎
If ScriptEvaluation does not complete because the user agent has aborted the running script, leave evaluationStatus as null.
</li>
	<li>
<p>
~IF［
%評価~status は中途完了である
］：
◎
If evaluationStatus is an abrupt completion, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~errorは再投出する ~EQ ~T
］：
</p>
				<ol>
					<li>
`走らせた~scriptを片付ける$( %設定群 )
</li>
					<li>
~THROW ［
%~script の`~errorは黙秘する$sC
］に応じて
⇒
~T ならば `NetworkError$E ／
~F ならば %評価~status . `Value^sl
</li>
				</ol>
◎
If rethrow errors is true and script's muted errors is false, then:
• Clean up after running script with settings.
• Rethrow evaluationStatus.[[Value]].
◎
If rethrow errors is true and script's muted errors is true, then:
• Clean up after running script with settings.
• Throw a "NetworkError" DOMException.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise, rethrow errors is false. Perform the following steps:
</p>

				<ol>
					<li>
`例外を報告する$( %~script, %評価~status . `Value^sl )
◎
Report the exception given by evaluationStatus.[[Value]] for script.
</li>
					<li>
`走らせた~scriptを片付ける$( %設定群 )
◎
Clean up after running script with settings.
</li>
					<li>
~RET `undefined^jv
◎
Return undefined.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（ %評価~status は正常完了である）：
</p>
		<ol>
			<li>
`走らせた~scriptを片付ける$( %設定群 )
</li>
			<li>
~RET %評価~status . `Value^sl
</li>
		</ol>

<p class="note">注記：
返される値は、 `javascript$sc ~URL手続き以外からは利用されない。
</p>

◎
Clean up after running script with settings.
◎
If evaluationStatus is a normal completion, return evaluationStatus.[[Value]].
◎
This value is only ever used by the javascript: URL steps.
◎
If we've reached this point, evaluationStatus was left as null because the script was aborted prematurely during evaluation. Return undefined.
</li>
</ol>

<p>
`~module~scriptを走らす@
ときは、所与の (
`~module~script$ %~script,
真偽値 %~errorは再投出する （省略時は ~F ）
)
に対し，次を走らす：
◎
To run a module script given a module script script, with an optional rethrow errors boolean:
• If rethrow errors is not given, let it be false.
</p>

<ol>
	<li>
%設定群 ~LET %~script の`設定群~obj$sC
◎
Let settings be the settings object of script.
</li>
	<li>
~IF［
`~scriptは走れるかどうか検査する$( %設定群 ) ~EQ `走るな^i
］
⇒
~RET
◎
Check if we can run script with settings. If this returns "do not run" then return.
</li>
	<li>
`~scriptを走らすために準備する$( %設定群 )
◎
Prepare to run script given settings.
</li>
	<li>
%評価~status ~LET ~NULL
◎
Let evaluationStatus be null.
</li>
	<li>
~IF［
%~script の`再投出-用~error$sC ~NEQ ~NULL
］
⇒
%評価~status ~SET `Completion^js{
`Type^sl: `throw^js,
`Value^sl: %~script の`再投出-用~error$sC,
`Target^sl: `empty^js
}
◎
If script's error to rethrow is not null, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: script's error to rethrow, [[Target]]: empty }.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~record ~LET %~script の`~record$sC
◎
Let record be script's record.
</li>
			<li>
<p>
%評価~status ~SET %~record . `Evaluate$jA()
◎
Set evaluationStatus to record.Evaluate().
</p>

<p class="note">注記：
この段は、~moduleの依存物すべてを再帰的に評価することになる。
◎
This step will recursively evaluate all of the module's dependencies.
</p>

<p>
~IF［
~UAが`走っている~scriptを中止-$したため， `Evaluate$jA は完了しなかった
］
⇒
%評価~status ~SET `Completion^js{
`Type^sl: `throw^js,
`Value^sl:  新たな `QuotaExceededError$E 例外,
`Target^sl: `empty^js
}
◎
If Evaluate fails to complete as a result of the user agent aborting the running script, then set evaluationStatus to Completion { [[Type]]: throw, [[Value]]: a new "QuotaExceededError" DOMException, [[Target]]: empty }.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%評価~status は中途完了である
］：
◎
If evaluationStatus is an abrupt completion, then:
</p>
		<ol>
			<li>
~IF［
%~errorは再投出する ~EQ ~T
］
⇒
~THROW %評価~status . `Value^sl
◎
If rethrow errors is true, rethrow the exception given by evaluationStatus.[[Value]].
</li>
			<li>
~ELSE
⇒
`例外を報告する$( %~script, %評価~status . `Value^sl )
◎
Otherwise, report the exception given by evaluationStatus.[[Value]] for script.
</li>
		</ol>
	</li>
	<li>
`走らせた~scriptを片付ける$( %設定群 )
◎
Clean up after running script with settings.
</li>
</ol>

<p class="algo-head">
`~scriptは走れるかどうか検査する@
ときは、所与の
( `環境~設定群~obj$ %設定群 )
に対し，次を走らす
— これは、［
`走れ^i, `走るな^i
］のいずれかを返す：
◎
The steps to check if we can run script with an environment settings object settings are as follows. They return either "run" or "do not run".
</p>

<ol>
	<li>
~IF［
%設定群 の`大域~obj$enVは`~window$である
］~AND［
%設定群 の`文書$は`全部的に作動中$でない
］
⇒
~RET `走るな^i
◎
If the global object specified by settings is a Window object whose Document object is not fully active, then return "do not run".
</li>
	<li>
~IF［
%設定群 により指定される`担当の閲覧文脈$enVにおいて
`~scriptingは不能化されて$いる
］
⇒
~RET `走るな^i
◎
If scripting is disabled for the responsible browsing context specified by settings, then return "do not run".
</li>
	<li>
~RET `走れ^i
◎
Return "run".
</li>
</ol>

<p class="algo-head">
`~scriptを走らすために準備する@
ときは、所与の
( `環境~設定群~obj$ %設定群 )
に対し，次を走らす：
◎
The steps to prepare to run script with an environment settings object settings are as follows:
</p>

<ol>
	<li>
`~JS実行~文脈~stack$jsに［
%設定群 の`~realm実行~文脈$enV
］を~pushする
— この時点で、それが`走っている~JS実行~文脈$jsになる。
◎
Push settings's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript execution context.
</li>
</ol>

<p class="algo-head">
`走らせた~scriptを片付ける@
ときは、所与の
( `環境~設定群~obj$ %設定群 )
に対し，次を走らす：
◎
The steps to clean up after running script with an environment settings object settings are as follows:
</p>

<ol>
	<li>
~Assert：
%設定群 の`~realm実行~文脈$enVは、`走っている~JS実行~文脈$jsである
◎
Assert: settings's realm execution context is the running JavaScript execution context.
</li>
	<li>
`~JS実行~文脈~stack$jsから， %設定群 の`~realm実行~文脈$enVを除去する
◎
Remove settings's realm execution context from the JavaScript execution context stack.
</li>
	<li>
~IF［
`~JS実行~文脈~stack$jsは空になった
］
⇒
`極小task~checkpointを遂行する$
（これが~scriptを走らす場合、この~algoは，再入的に呼出されることになる。）
◎
If the JavaScript execution context stack is now empty, perform a microtask checkpoint. (If this runs scripts, these algorithms will be invoked reentrantly.)
</li>
</ol>

<p class="note">注記：
これらの~algoは、ある~scriptが別の~scriptを直接的に~callすることにより呼出されることはないが、間接的な方式で再入的に呼出され得る
— 例えば、~scriptが~eventを配送したとき，その~eventに対し~event~listenerが登録されている場合。
◎
These algorithms are not invoked by one script directly calling another, but they can be invoked reentrantly in an indirect manner, e.g. if a script dispatches an event which has event listeners registered.
</p>

<p>
`走っている~script@
とは、`走っている~JS実行~文脈$jsの~ScriptOrModule成分の `HostDefined^sl ~field内の `script$e である。
◎
The running script is the script in the [[HostDefined]] field in the ScriptOrModule component of the running JavaScript execution context.
</p>

				</section>
				<section id="realms-settings-objects-global-objects">
<h4 title="Realms, settings objects, and global objects">8.1.3.5. ~realm, 設定群~obj, 大域~obj</h4>

<p>
`大域~obj@
とは、`~JS~realm$jsの `GlobalObject^sl ~fieldである~JS~objである。
◎
A global object is a JavaScript object that is the [[GlobalObject]] field of a JavaScript realm.
</p>

<p class="note">注記：
この仕様では、すべての`~JS~realm$jsは，［［
`Window$I, `WorkerGlobalScope$I 
］いずれかの~objである`大域~obj$
］で`初期化-$jsされる。
◎
In this specification, all JavaScript realms are initialized with global objects that are either Window or WorkerGlobalScope objects.
</p>

<p>
［
`~JS~realm$js %~Realm, `大域~obj$ %G, `環境~設定群~obj$ %設定群
］は、常に，互いに 1:1:1 に対応する：
◎
There is always a 1-to-1-to-1 mapping between JavaScript realms, global objects, and environment settings objects:
</p>

<ul>
	<li>
<p>
%~Realm 視点からは：
</p>
		<ul>
			<li>
%~Realm の `HostDefined^sl ~fieldが， %設定群 を与える
— %設定群 を指して %~Realm の
`設定群~obj@rM
という。
</li>
			<li>
%~Realm の `GlobalObject^sl ~fieldが， %G を与える
— %G を指して %~Realm の
`大域~obj@rM
という。
</li>
		</ul>

◎
A JavaScript realm has a [[HostDefined]] field, which contains the Realm's settings object.
◎
A JavaScript realm has a [[GlobalObject]] field, which contains the Realm's global object.
</li>
	<li>
<p>
%G 視点からは：
</p>
		<ul>
			<li>
%G は， %~Realm が`初期化-$jsされる間に作成される。
%~Realm を指して %G の
`~Realm@gL
という。
</li>
			<li id="relevant-settings-object-for-a-global-object">
%G は， %設定群 と並行して作成される。
%設定群 は %G に`関連する設定群~obj$と呼ばれる。
</li>
		</ul>

◎
Each global object in this specification is created during the initialization of a corresponding JavaScript realm, known as the global object's Realm.
◎
Each global object in this specification is created alongside a corresponding environment settings object, known as its relevant settings object.
</li>
	<li>
<p>
%設定群 視点からは：
</p>
		<ul>
			<li>
%設定群 の`~realm実行~文脈$enVの~Realm成分が， %~Realm を与える
— %~Realm を指して %設定群 の
`~Realm@enV
という。
</li>
			<li>
対応する %G （すなわち， %設定群 の`~Realm$enVの `GlobalObject^sl ~field）を指して %設定群 の
`大域~obj@enV
という。
</li>
		</ul>
◎
An environment settings object's realm execution context's Realm component is the environment settings object's Realm.
◎
An environment settings object's Realm then has a [[GlobalObject]] field, which contains the environment settings object's global object.
</li>
</ul>

<hr>

<p>
この仕様~全体を通して、~algoの手続きを定義するときに，どの`~JS~realm$jsが利用されるか
— あるいは，同じことだが、どの`大域~obj$／`環境~設定群~obj$が利用されるか —
を指示することが重要になることは、よくある。
一般に、少なくとも次の 4 種いずれかで指示される：
◎
When defining algorithm steps throughout this specification, it is often important to indicate what JavaScript realm is to be used—or, equivalently, what global object or environment settings object is to be used. In general, there are at least four possibilities:
</p>

<dl>
	<dt>`入口~某@ （ entry 某）</dt>
	<dd>
これは、現在~走っている~script動作を起動した~scriptに対応する
【もしあれば】
：
すなわち、［
作者~codeの中へ~callした~UA
］の中へ~callした［
関数／~script
］。
◎
This corresponds to the script that initiated the currently running script action: i.e., the function or script that the user agent called into when it called into author code.
</dd>

	<dt>`現任の某@ （ incumbent 某）</dt>
	<dd>
<p>
これは、作者による［
関数／~script
］のうち，次のいずれかに該当するものに対応する：
</p>

<ul><li>~stack上で最も近過去に入ったもの
</li><li>現在~走っている~callbackを 元々~scheduleしたもの
</li>
</ul>

◎
This corresponds to the most-recently-entered author function or script on the stack, or the author function or script that originally scheduled the currently-running callback.
</dd>

	<dt>`現在の某@ （ current 某）</dt>
	<dd>
これは、現在~走っている関数~objに対応する。
これには、~JSとして実装されていないかもしれないような，~UAに組込みの関数も含まれる（それは`現在の~JS~realm$jsから導出される）。
◎
This corresponds to the currently-running function object, including built-in user-agent functions which might not be implemented as JavaScript. (It is derived from the current JavaScript realm.)
</dd>

	<dt>`某に関連する@ （ 某に relevant な）</dt>
	<dd>
どの`~platform~obj$にも`関連する~Realm$がある
— それは概ね，その~objの作成-元である`~JS~realm$jsである。
~algoを書くときに，［
`関連する~Realm$が重要になり得るような`~platform~obj$
］として，真っ先に挙がるのは、現在~走っている関数~objの `this^b 値になる。
<!-- ＊ -->
一部の事例では、引数のそれなど，`関連する~Realm$が重要になるものが他にもあり得る。
◎
Every platform object has a relevant Realm, which is roughly the JavaScript realm in which it was created. When writing algorithms, the most prominent platform object whose relevant Realm might be important is the this value of the currently-running function object. In some cases, there can be other important relevant Realms, such as those of any arguments.
</dd>
</dl>

 
<p>
［
`入口~某$ ／ `現任の某$ ／ `現在の某$
］の概念は，限定句なしに利用できる一方で、`某に関連する$の概念は，特定0の`~platform~obj$に適用され~MUSTことに注意。
◎
Note how the entry, incumbent, and current concepts are usable without qualification, whereas the relevant concept must be applied to a particular platform object.
</p>

<div class="example">

<p>
次の各~頁を考える。
ここでは、
`a.html^s は~browser~window内に読込まれていて，
`b.html^s は 示されているように `iframe$e 内に読込まれていて，
`c.html^s, `d.html^s は省略されている（単純に，空~文書でもよい）
とする：
◎
Consider the following pages, with a.html being loaded in a browser window, b.html being loaded in an iframe as shown, and c.html and d.html omitted (they can simply be empty documents):
</p>

<!-- 
Entry page
Incumbent page
-->
<pre>
&lt;!-- a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;入口~頁&lt;/title&gt;

&lt;iframe src="b.html"&gt;&lt;/iframe&gt;
&lt;button onclick="frames[0].hello()"&gt;Hello&lt;/button&gt;

&lt;!--b.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;現任の頁&lt;/title&gt;

&lt;iframe src="c.html" id="c"&gt;&lt;/iframe&gt;
&lt;iframe src="d.html" id="d"&gt;&lt;/iframe&gt;

&lt;script&gt;
  const %c = document.querySelector("#c").contentWindow;
  const %d = document.querySelector("#d").contentWindow;

  window.hello = () =&gt; {
    %c.print.call(%d);
  };
&lt;/script&gt;
</pre>

<p>
各~頁は、自前の`閲覧文脈$を有し，したがって自前の［
`~JS~realm$js, `大域~obj$, `環境~設定群~obj$
］を有する。
◎
Each page has its own browsing context, and thus its own JavaScript realm, global object, and environment settings object.
</p>

<p>
`a.html^s 内の~buttonの押下げに呼応して
`print()$m ~methodが~callされたときは：
◎
When the print() method is called in response to pressing the button in a.html, then:
</p>

<ul>
	<li>
`入口~Realm$は、
`a.html^s のそれになる。
◎
The entry Realm is that of a.html.
</li>
	<li>
`現任の~Realm$は、
`b.html^s のそれになる。
◎
The incumbent Realm is that of b.html.
</li>
	<li>
`現在の~Realm~Record$jsは、 `c.html^s のそれになる（走っている~codeは、 `c.html^s に属する `print()$m ~methodなので）。
◎
The current Realm is that of c.html (since it is the print() method from c.html whose code is running).
</li>
	<li>
`print()$m ~methodが~callされている~objに`関連する~Realm$は、
`d.html^s のそれになる。
◎
The relevant Realm of the object on which the print() method is being called is that of d.html.
</li>
</ul>

</div>

<p class="warning">
`現任の某$, `入口~某$
の概念は、あまりに複雑で直感的でないので，新たな仕様には利用されるべきでない。
既存の利用は，~platformからほぼ除去すべく~~策定が進められている。
`現任の某$ については，
<a href="https://github.com/whatwg/html/issues/1430">issue #1430</a>
を、`入口~某$ については，
<a href="https://github.com/whatwg/html/issues/1431">issue #1431</a>
を見よ。
◎
The incumbent and entry concepts should not be used by new specifications, as they are excessively complicated and unintuitive to work with. We are working to remove almost all existing uses from the platform: see issue #1430 for incumbent, and issue #1431 for entry.
</p>

<p>
一般に，~web~platform仕様は、`某に関連する$の概念を，演算-対象の~obj（通例的には現在の~methodの `this^b 値になる）に適用して利用するべきである。
これは、~JS仕様と合致していない
— そこでは、一般に，`現在の某$が既定として利用されている（例：
`Array.prototype.map^c の結果を構築する際に利用されるべき `Array^c 構築子が属する`~JS~realm$jsを決定するときなど）。
が、この不一致は，策定を進めるためには受容する必要があるものとして，~platformに埋込まれている。
◎
In general, web platform specifications should use the relevant concept, applied to the object being operated on (usually the this value of the current method). This mismatches the JavaScript specification, where current is generally used as the default (e.g. in determining the JavaScript realm whose Array constructor should be used to construct the result in Array.prototype.map). But this inconsistency is so embedded in the platform that we have to accept it going forward.
</p>

<p>
構築子においては、 `this^b 値がまだないので，`現在の某$ の概念が適切な既定になることに注意。
◎
Note that in constructors, where there is no this value yet, the current concept is the appropriate default.
</p>

<div class="example">
<p>
`某に関連する$の概念が，`現在の某$の概念よりも一般に良い既定になる理由の一つは、複数回にわたり返されるような持続的な~objを作成するときに，その方が相応しくなるからである。
例えば `getBattery()$m ~method `BATTERY$r
は、それが呼出された `Navigator$I ~objに`関連する~Realm$内に~promiseを作成する。
これは、次に影響0する：
◎
One reason why the relevant concept is generally a better default choice than the current concept is that it is more suitable for creating an object that is to be persisted and returned multiple times. For example, the navigator.getBattery() method creates promises in the relevant Realm for the Navigator object on which it is invoked. This has the following impact: [BATTERY]
</p>

<pre>&lt;!-- outer.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;関連する~Realmの例証： outer 頁&lt;/title&gt;
&lt;script&gt;
  function doTest() {
    const %promise = navigator.getBattery.call(frames[0].navigator);

    console.log(%promise instanceof Promise);           // logs false
    console.log(%promise instanceof frames[0].Promise); // logs true

    frames[0].hello();
  }
&lt;/script&gt;
&lt;iframe src="inner.html" onload="doTest()"&gt;&lt;/iframe&gt;

&lt;!-- inner.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="ja"&gt;
&lt;title&gt;関連する~Realmの例証： inner 頁&lt;/title&gt;
&lt;script&gt;
  function hello() {
    const %promise = navigator.getBattery();

    console.log(%promise instanceof Promise);        // logs true
    console.log(%promise instanceof parent.Promise); // logs false
  }
&lt;/script&gt;
</pre>

<p>
`getBattery()$m ~methodの~algoが，代わりに`現在の~Realm~Record$jsを利用した場合、すべての結果が覆されることになる。
すなわち、 `outer.html^s 内の `getBattery()$m に対する最初の~callの後、
`inner.html^s 内の `Navigator$I ~objは，
`outer.html^s の`~JS~realm$jsにて作成された
`Promise^c ~objを恒久的に格納することになる結果、
`hello()^c 関数の内側における同様の~callは， “間違った” ~realmからの~promiseを返すことになる。
これは望ましくないので、~algoは、上の~commentで指示されるような~~分別のある結果を与える，`関連する~Realm$を代わりに利用する。
◎
If the algorithm for the getBattery() method had instead used the current Realm, all the results would be reversed. That is, after the first call to getBattery() in outer.html, the Navigator object in inner.html would be permanently storing a Promise object created in outer.html's JavaScript realm, and calls like that inside the hello() function would thus return a promise from the "wrong" realm. Since this is undesirable, the algorithm instead uses the relevant Realm, giving the sensible results indicated in the comments above.
</p>

</div>

<hr>

<p>
この節の以降では、［
`入口~某$, `現任の某$, `現在の某$, `某に関連する$
］の概念について，公式的に定義する。
◎
The rest of this section deals with formally defining the entry, incumbent, current, and relevant concepts.
</p>

					<section id="entry">
<h5 title="Entry">8.1.3.5.1. 入口~某</h5>

<p>
<a href="#calling-scripts">~script~call時の処理-</a>
は、`~realm実行~文脈$enVを，`~JS実行~文脈~stack$jsに
— 他の`~JS実行~文脈$jsの合間に挟みながら —
［
~push／~pop
］することになる。
◎
The process of calling scripts will push or pop realm execution contexts onto the JavaScript execution context stack, interspersed with other execution contexts.
</p>

<p>
これをもって，
`入口~実行~文脈@
は、`~JS実行~文脈~stack$js内の~itemのうち，最も近過去に~pushされた`~realm実行~文脈$enVとして定義される。
`入口~Realm@
は、`入口~実行~文脈$の~Realm成分で与えられる。
◎
With this in hand, we define the entry execution context to be the most recently pushed item in the JavaScript execution context stack that is a realm execution context. The entry Realm is the entry execution context's Realm component.
</p>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
`入口~設定群~obj@
は、`入口~Realm$の`設定群~obj$rMである。
◎
Then, the entry settings object is the environment settings object of the entry Realm.
</li>
	<li>
`入口~大域~obj@
は、`入口~Realm$の`大域~obj$rMである。
◎
Similarly, the entry global object is the global object of the entry Realm.
</li>
</ul>

					</section>
					<section id="incumbent">
<h5 title="Incumbent">8.1.3.5.2. 現任の某</h5>

<p>
各`~JS実行~文脈$jsは、自身の~code評価~状態の一部として，初期~時は 0 の
`現任の決定-時に飛ばす~counter@
値を包含し~MUST。
この値は、［
`~callbackを走らすために準備する$ ／
`走らせた~callbackを片付ける$
］処理-において，増減されることになる。
◎
All JavaScript execution contexts must contain, as part of their code evaluation state, a skip-when-determining-incumbent counter value, which is initially zero. In the process of preparing to run a callback and cleaning up after running a callback, this value will be incremented and decremented.
</p>

<p>
どの`~event-loop$にも，
`予備の現任の設定群~obj~stack@
が結付けられ、初期~時は空にされる。
それは 大雑把に言えば、［
~stack上に作者~codeは無いが、走らされた現在の~algoは，作者~codeが 何らかの仕方で担当している
］ときに，`現任の設定群~obj$を決定するために利用される。
この~stackは，［
`~callbackを走らすために準備する$ ／
`走らせた~callbackを片付ける$
］処理-から操作される。
`WEBIDL$r
◎
Every event loop has an associated backup incumbent settings object stack, initially empty. Roughly speaking, it is used to determine the incumbent settings object when no author code is on the stack, but author code is responsible for the current algorithm having been run in some way. The process of preparing to run a callback and cleaning up after running a callback manipulate this stack. [WEBIDL]
</p>

<p>
［
~WebIDLを利用して 作者~codeを`呼出す$x ／
<a href="#enqueuejob(queuename,-job,-arguments)">`EnqueueJob^jA</a>
が~promise~jobを呼出す
］ときは、次の~algoを利用して，［
`現任の設定群~obj$を決定するときに関連する~data
］を追跡する：
◎
When Web IDL is used to invoke author code, or when EnqueueJob invokes a promise job, they use the following algorithms to track relevant data for determining the incumbent settings object:
</p>

<p class="algo-head">
`~callbackを走らすために準備する@
ときは、所与の
( `環境~設定群~obj$ %設定群 )
に対し，次を走らす：
◎
To prepare to run a callback with an environment settings object settings:
</p>

<ol>
	<li>
`予備の現任の設定群~obj~stack$に %設定群 を~pushする
◎
Push settings onto the backup incumbent settings object stack.
</li>
	<li>
%文脈 ~LET `最上端の~scriptを有する実行~文脈$
◎
Let context be the topmost script-having execution context.
</li>
	<li>
~IF［
%文脈 ~NEQ ~NULL
］
⇒
%文脈 の`現任の決定-時に飛ばす~counter$ ~INCBY 1
◎
If context is not null, increment context's skip-when-determining-incumbent counter.
</li>
</ol>
<p class="algo-head">
`走らせた~callbackを片付ける@
ときは、所与の
( `環境~設定群~obj$ %設定群 )
に対し，次に従う：
◎
To clean up after running a callback with an environment settings object settings:
</p>

<ol>
	<li>
<p>
%文脈 ~LET `最上端の~scriptを有する実行~文脈$
◎
Let context be the topmost script-having execution context.
</p>

<p class="note">注記：
これは、この手続きの呼出と対にされた［
`~callbackを走らすために準備する$呼出
］の内側の，`最上端の~scriptを有する実行~文脈$と同じになる。
◎
This will be the same as the topmost script-having execution context inside the corresponding invocation of prepare to run a callback.
</p>
	</li>
	<li>
~IF［
%文脈 ~NEQ ~NULL
］
⇒
%文脈 の`現任の決定-時に飛ばす~counter$ ~DECBY 1
◎
If context is not null, decrement context's skip-when-determining-incumbent counter.
</li>
	<li>
~Assert：
`予備の現任の設定群~obj~stack$の最上端の~entry ~EQ %設定群
◎
Assert: the topmost entry of the backup incumbent settings object stack is settings.
</li>
	<li>
`予備の現任の設定群~obj~stack$から %設定群 を除去する
◎
Remove settings from the backup incumbent settings object stack.
</li>
</ol>

<p>
ここで，
`最上端の~scriptを有する実行~文脈@
は、［
`~JS実行~文脈~stack$jsの最上端の~entry %~entry が［
%~entry の~ScriptOrModule成分 ~NEQ ~NULL
］を満たすならば %~entry ／
~ELSE_ ~NULL
］とする。
◎
Here, the topmost script-having execution context is the topmost entry of the JavaScript execution context stack that has a non-null ScriptOrModule component, or null if there is no such entry in the JavaScript execution context stack.
</p>

<p class="algo-head">
以上をふまえた下で，
`現任の設定群~obj@
は、次に従って決定される：
◎
With all this in place, the incumbent settings object is determined as follows:
</p>

<ol>
	<li>
%文脈 ~LET `最上端の~scriptを有する実行~文脈$
◎
Let context be the topmost script-having execution context.
</li>
	<li>
<p>
~IF［
%文脈 ~EQ ~NULL
］~OR［
%文脈 の`現任の決定-時に飛ばす~counter$ ~GT 0
］：
◎
If context is null, or if context's skip-when-determining-incumbent counter is greater than zero, then:
</p>

		<ol>
			<li>
<p>
~Assert:
`予備の現任の設定群~obj~stack$は空でない
◎
Assert: the backup incumbent settings object stack is not empty.
</p>

<p class="note">注記：
この ~Assert は、［［
<a href="#calling-scripts">~scriptを~callする</a> ／
~WebIDLにより ~callbackを`呼出す$x
］ことにより誘発されたものではない~algo
］の内側から`現任の設定群~obj$を得ようと試行したときには，失敗することになる。
例えば、［
`~event-loop$の一部として周期的に走らされる~algoであって，作者~codeは孕まれていないもの
］が，それを試行したときなど。
そのような事例では、`現任の某$ の概念は利用できない。
◎
This assert would fail if you try to obtain the incumbent settings object from inside an algorithm that was triggered neither by calling scripts nor by Web IDL invoking a callback. For example, it would trigger if you tried to obtain the incumbent settings object inside an algorithm that ran periodically as part of the event loop, with no involvement of author code. In such cases the incumbent concept cannot be used.
</p>
	</li>
	<li>
~RET `予備の現任の設定群~obj~stack$の最上端の~entry
◎
Return the topmost entry of the backup incumbent settings object stack.
</li>
		</ol>
	</li>
	<li>
~RET %文脈 の~Realm成分の`設定群~obj$rM
◎
Return context's Realm component's settings object.
</li>
</ol>

<p>
以上により、次も定義される：
◎
↓</p>

<ul>
	<li>
`現任の~Realm@
は、`現任の設定群~obj$の`~Realm$enVである。
◎
Then, the incumbent Realm is the Realm of the incumbent settings object.
</li>
	<li>
`現任の大域~obj@
は、`現任の設定群~obj$の`大域~obj$enVである。
◎
Similarly, the incumbent global object is the global object of the incumbent settings object.
</li>
</ul>

<hr>

<p>
以下に示す一連の例は、各種 仕組みが `現任の某$ の概念の定義にどう関わるかを，はっきりさせるために意図されている：
◎
The following series of examples is intended to make it clear how all of the different mechanisms contribute to the definition of the incumbent concept:
</p>

<div class="example">
<p>
次のごく単純な例を考える：
◎
Consider the following very simple example:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;iframe&gt;&lt;/iframe&gt;
&lt;script&gt;
  new frames[0].MessageChannel();
&lt;/script&gt;
</pre>

<p>
`MessageChannel()$m 構築子が，新たな `MessagePort$I ~objの所有者として利用する`現任の設定群~obj$を検索するとき、`最上端の~scriptを有する実行~文脈$は， `script$e 要素に対応している それになる：
それは、`~classic~scriptを走らす$~algoの間に，
`ScriptEvaluation$jA() の一部として，`~JS実行~文脈~stack$jsに~pushされたものである。
~WebIDL~callbackの呼出は孕まれないので、この文脈の`現任の決定-時に飛ばす~counter$は 0 であり、したがってそれが，`現任の設定群~obj$を決定するために利用される。
その結果は、 `window^c の`環境~設定群~obj$になる。
◎
When the MessageChannel() constructor looks up the incumbent settings object to use as the owner of the new MessagePort objects, the topmost script-having execution context will be that corresponding to the script element: it was pushed onto the JavaScript execution context stack as part of ScriptEvaluation during the run a classic script algorithm. Since there are no Web IDL callback invocations involved, the context's skip-when-determining-incumbent counter is zero, so it is used to determine the incumbent settings object; the result is the environment settings object of window.
</p>

<p>
（この例では、 `frames[0]^c の`環境~設定群~obj$は，全く孕まれない。
それが`現在の設定群~obj$になるが、 `MessageChannel()$m 構築子は，現在の某ではなく 現任の某についてのみ~careする。）
◎
(In this example, the environment settings object of frames[0] is not involved at all. It is the current settings object, but the MessageChannel() constructor cares only about the incumbent, not current.)
</p>

</div>

<div class="example">
<p>
次に、もっと複雑な例を考える：
◎
Consider the following more complicated example:
</p>

<pre>
&lt;!DOCTYPE html&gt;
&lt;iframe&gt;&lt;/iframe&gt;
&lt;script&gt;
  const %bound = frames[0].postMessage.bind(frames[0], "some data", "*");
  window.setTimeout(%bound);
&lt;/script&gt;
</pre>

<p>
ここで，注目する`環境~設定群~obj$には、［
`window^c のそれ, `frames[0]^c のそれ
］の 2 つがある。
ここでの懸案は、
`postMessage()$m 用の~algoを実行した時点で，何が`現任の設定群~obj$になるか？
である。
◎
There are two interesting environment settings objects here: that of window, and that of frames[0]. Our concern is: what is the incumbent settings object at the time that the algorithm for postMessage() executes?
</p>

<p>
その~algoを起こした担当の作者~scriptは， `frames[0]^c ではなく `window^c 内で実行されているので、直感的に捉えるなら，
<!-- notion  -->
`window^c のそれになるべきである。
この直感は、［
`現任の某$ の概念は、非同期な~algoの呼出ing（この事例では `setTimeout()$m を介するそれ）により変化するべきでない
］と捉えることもできる。
◎
It should be that of window, to capture the intuitive notion that the author script responsible for causing the algorithm to happen is executing in window, not frames[0]. Another way of capturing the intuition here is that invoking algorithms asynchronously (in this case via setTimeout()) should not change the incumbent concept.
</p>

<p>
上で与えた手続きが、直感的に欲される結果として，どうやって
`window^c に`関連する設定群~obj$を与えてくれるかを，以下に説明する。
◎
Let us now explain how the steps given above give us our intuitively-desired result of window's relevant settings object.
</p>

<p>
%bound が ~WebIDL~callback型に`変換-$xされるとき、`現任の設定群~obj$は， （先に示した単純な例と同じ方式で） `window^c に対応しているそれになる。
~WebIDLは、これを，結果の~callback値の`~callback文脈$として格納する。
◎
When bound is converted to a Web IDL callback type, the incumbent settings object is that corresponding to window (in the same manner as in our simple example above). Web IDL stores this as the resulting callback value's callback context.
</p>

<p>
`setTimeout()$m により~postされた`~task$が実行されるとき、その~task用の~algoは，~WebIDLを利用して 格納された~callback値を`呼出す$x。
それに応じて、~WebIDLは，上述した［
`~callbackを走らすために準備する$
］~algoを~callする。
これは、格納された`~callback文脈$を，`予備の現任の設定群~obj~stack$に~pushする。
この時点（~timer~taskの内側）では，その~stack上には作者~codeは無いので、`最上端の~scriptを有する実行~文脈$は ~NULL であり，`現任の決定-時に飛ばす~counter$は増やされない。
◎
When the task posted by setTimeout() executes, the algorithm for that task uses Web IDL to invoke the stored callback value. Web IDL in turn calls the above prepare to run a callback algorithm. This pushes the stored callback context onto the backup incumbent settings object stack. At this time (inside the timer task) there is no author code on the stack, so the topmost script-having execution context is null, and nothing gets its skip-when-determining-incumbent counter incremented.
</p>

<p>
次に、~callbackの呼出ingは， %bound を~callする。
それに応じて、 `frames[0]^c の `postMessage()$m ~methodが~callされる。
`postMessage()$m ~algoが`現任の設定群~obj$を検索するとき，~stack上にはまだ作者~codeはない
— `bound()^c 関数は、単に組込みの~methodを直接的に~callするだけなので。
よって、`最上端の~scriptを有する実行~文脈$は ~NULL になる：
`~JS実行~文脈$js ~stackは、 `postMessage()$m に対応している実行~文脈
— それも，`ScriptEvaluation$jA 文脈や，それに類するものを伴わないもの —
のみを包含する。
◎
Invoking the callback then calls bound, which in turn calls the postMessage() method of frames[0]. When the postMessage() algorithm looks up the incumbent settings object, there is still no author code on the stack, since the bound function just directly calls the built-in method. So the topmost script-having execution context will be null: the JavaScript execution context stack only contains an execution context corresponding to postMessage(), with no ScriptEvaluation context or similar below it.
</p>

<p>
`予備の現任の設定群~obj~stack$に~fall-backするのは、ここである。
上に注記されたように、この~stackは，最上端の~entryとして `window^c に`関連する設定群~obj$を包含することになる。
よって、それが `postMessage()$m ~algoを実行している間に`現任の設定群~obj$として利用されるものになる。
◎
This is where we fall back to the backup incumbent settings object stack. As noted above, it will contain as its topmost entry the relevant settings object of window. So that is what is used as the incumbent settings object while executing the postMessage() algorithm.
</p>
</div>

<div class="example">
<p>
~~最後に、もっと込み入った例を考える：
◎
Consider this final, even more convoluted example:
</p>

<pre>
&lt;!-- a.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;button&gt;click me&lt;/button&gt;
&lt;iframe&gt;&lt;/iframe&gt;
&lt;script&gt;
const %bound = frames[0].location.assign.bind(
    frames[0].location,
    "https://example.com/"
);
document.querySelector("button").addEventListener("click", %bound);
&lt;/script&gt;

&lt;!-- b.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;iframe src="a.html"&gt;&lt;/iframe&gt;
&lt;script&gt;
  const %iframe = document.querySelector("iframe");
  %iframe.onload = function onLoad() {
    %iframe.contentWindow.document.querySelector("button").click();
  };
&lt;/script&gt;
</pre>

<p>
ここでも，注目する`環境~設定群~obj$には、［
`a.html^c のそれ, `b.html^c のそれ
］の 2 つがある。
`assign()$m ~methodが`~Location~objにより~navigate$する~algoを誘発するとき、何が`現任の設定群~obj$になるか？
それは、前のように直感的には， `a.html^c のそれになるべきである：
`click$et ~listenerは，元々は `a.html^c により~scheduleされたので、
`b.html^c を孕んでいる何かが その~listenerを発火させたとしても，
`現任の某$が担当するのは `a.html^c のそれになる。
◎
Again there are two interesting environment settings objects in play: that of a.html, and that of b.html. When the location.assign() method triggers the Location-object navigate algorithm, what will be the incumbent settings object? As before, it should intuitively be that of a.html: the click listener was originally scheduled by a.html, so even if something involving b.html causes the listener to fire, the incumbent responsible is that of a.html.
</p>

<p>
ここでの~callbackに対する~~設定は、前の例に類似する：
%bound が ~WebIDL~callback型に`変換-$xされるとき、`現任の設定群~obj$は， `a.html^c に対応しているそれになり、~callbackの`~callback文脈$に格納される。
◎
The callback setup is similar to the previous example: when bound is converted to a Web IDL callback type, the incumbent settings object is that corresponding to a.html, which is stored as the callback's callback context.
</p>

<p>
`b.html^c の内側で `click$m ~methodが~callされたとき、~methodは， `a.html^c の内側にある~buttonへ向けて `click$et ~eventを`配送-$する。
この~event配送-の一部として，`~callbackを走らすために準備する$~algoが実行される時点では、~stack上には作者~codeが<em>ある</em>。
`最上端の~scriptを有する実行~文脈$は、 `onLoad()^c 関数のそれであり，その`現任の決定-時に飛ばす~counter$は 増やされる。
加えて、 `a.html^c の`環境~設定群~obj$（ `EventHandler$I の`~callback文脈$として格納されている）が，`予備の現任の設定群~obj~stack$に~pushされる。
◎
When the click() method is called inside b.html, it dispatches a click event on the button that is inside a.html. This time, when the prepare to run a callback algorithm executes as part of event dispatch, there is author code on the stack; the topmost script-having execution context is that of the onLoad function, whose skip-when-determining-incumbent counter gets incremented. Additionally, a.html's environment settings object (stored as the EventHandler's callback context) is pushed onto the backup incumbent settings object stack.
</p>

<p>
この時点で［
`~Location~objにより~navigate$する~algoが`現任の設定群~obj$を検索する
］ときの，`最上端の~scriptを有する実行~文脈$は、依然として `onLoad^c 関数 のそれである（ `bound()^c 関数を~callbackとして利用している事実に因る）。
しかしながら，その`現任の決定-時に飛ばす~counter$ 値は 1 なので、`予備の現任の設定群~obj~stack$に~fall-backする。
これは、期待されるように `a.html^c の`環境~設定群~obj$を与えてくれる。
◎
Now, when the Location-object navigate algorithm looks up the incumbent settings object, the topmost script-having execution context is still that of the onLoad function (due to the fact we are using a bound function as the callback). Its skip-when-determining-incumbent counter value is one, however, so we fall back to the backup incumbent settings object stack. This gives us the environment settings object of a.html, as expected.
</p>

<p>
これは、
~navigateするのは `a.html^c の内側の `iframe$e であっても，
`~source閲覧文脈$として利用されるのは `a.html^c 自身であることを意味することに注意。
それが、`要請~client$rqを決定する。
おそらくこれが、
<a href="https://www.w3.org/Bugs/Public/show_bug.cgi?id=26603#c36">~web~platform上で，現任の某の概念の利用を正当化できる唯一のものである</a>。
他のすべての事例における その概念の利用は，単に~~理解を難しくするだけであり、いつの日か［
`現在の某$ ／ `某に関連する$
］のうち適切な方を利用するよう切替えられるものと希望されている。
◎
Note that this means that even though it is the iframe inside a.html that navigates, it is a.html itself that is used as the source browsing context, which determines among other things the request client. This is perhaps the only justifiable use of the incumbent concept on the web platform; in all other cases the consequences of using it are simply confusing and we hope to one day switch them to use current or relevant as appropriate.
</p>
</div>

					</section>
					<section id="current">
<h5 title="Current">8.1.3.5.3. 現在の某</h5>

 
<p>
~JS仕様は、
`現在の~Realm~Record$jsを定義している
— “現在の~Realm” と略称されることもある。
`JAVASCRIPT$r
◎
The JavaScript specification defines the current Realm Record, sometimes abbreviated to the "current Realm". [JAVASCRIPT]
</p>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
`現在の設定群~obj@
は、`現在の~Realm~Record$jsの`設定群~obj$rMである。
◎
Then, the current settings object is the environment settings object of the current Realm Record.
</li>
	<li>
`現在の大域~obj@
は、`現在の~Realm~Record$jsの`大域~obj$rMである。
◎
Similarly, the current global object is the global object of the current Realm Record.
</li>
</ul>

					</section>
					<section id="relevant">
<h5 title="Relevant">8.1.3.5.4. 某に関連する</h5>

<div class="p">
<p>
この節では、所与の`~platform~obj$を単に %P と記す。
</p>

<p>
%P に
`関連する設定群~obj@
は、次に従って定義される：
</p>

◎
The relevant settings object for a platform object is defined as follows:
</div>

<dl class="switch">
	<dt>
%P は`大域~obj$である場合：
◎
If the object is a global object
</dt>
	<dd>
この仕様における各 `大域~obj$ %P は、対応する ある`環境~設定群~obj$ %設定群 と並行して作成される
— そのような %設定群 。
◎
Each global object in this specification is created alongside a corresponding environment settings object; that is its relevant settings object.
</dd>

	<dt>
他の場合：
◎
Otherwise
</dt>
	<dd>
%P が`属する大域~環境$に`関連する設定群~obj$。
◎
The relevant settings object for a non-global platform object o is the environment settings object whose global object is the global object of the global environment associated with o.
</dd>
	<dd class="note">注記：
“〜が`属する大域~環境$”
（ global environment associated with 〜 ）
の概念は、現代の~JS仕様と その`~JS~realm$jsの概念が~~出現する以前の，昔ながらのものである。
~WebIDL仕様が更新されたときには、どの`~platform~obj$にも `~JS~realm$jsが結付けられ、この定義は，それらの用語で書き直せるようになることが期待されている。
`JAVASCRIPT$r
`WEBIDL$r
◎
The "global environment associated with" concept is from the olden days, before the modern JavaScript specification and its concept of realms. We expect that as the Web IDL specification gets updated, every platform object will have a Realm associated with it, and this definition can be re-cast in those terms. [JAVASCRIPT] [WEBIDL]
</dd>
</dl>

<p>
これにより、次も定義される：
◎
↓</p>

<ul>
	<li>
%P に
`関連する~Realm@
は、
%P に`関連する設定群~obj$の`~Realm$enVである。
◎
Then, the relevant Realm for a platform object is the Realm of its relevant settings object.
</li>
	<li>
%P に
`関連する大域~obj@
は、
%P に`関連する設定群~obj$の`大域~obj$enVである。
◎
Similarly, the relevant global object for a platform object is the global object of its relevant settings object.
</li>
</ul>

					</section>
				</section>
				<section id="killing-scripts">
<h4 title="Killing scripts">8.1.3.6. ~scriptの強制終了</h4>

<p>
`走っている~scriptを中止-@
する必要が生じることはときどきある
— ~JS仕様はその可能性について織込んでいないが。
これは、［
`ScriptEvaluation$jA ／ 
`Source Text Module Record$js の `Evaluate$jA
］の呼出があれば即時に止めた上で，
`finally^c ~blockの様な通常の仕組みを誘発することなく，`~JS実行~文脈~stack$jsを空にする。
`JAVASCRIPT$r
◎
Although the JavaScript specification does not account for this possibility, it's sometimes necessary to abort a running script. This causes any ScriptEvaluation or Source Text Module Record Evaluate invocations to cease immediately, emptying the JavaScript execution context stack without triggering any of the normal mechanisms like finally blocks. [JAVASCRIPT]
</p>

<p>
~UAは、~scriptに~~割り振る計算資源に制限を課してよい
— 例えば［
CPU ~quota ／
~memory ／
実行~時間の総計 ／
帯域幅
］に対する制限など。
~scriptがこれらの制限-を超過したときは、~UAは，次のいずれかをしてよい：
◎
User agents may impose resource limitations on scripts, for example CPU quotas, memory limits, total execution time limits, or bandwidth limitations. When a script exceeds a limit, the user agent may either＼
</p>

<div class="p">
<ul><li>`QuotaExceededError$E 例外を投出する
</li><li>例外を投出せずに~scriptを`中止-$する
</li><li>利用者に~promptする
</li><li>~script実行を絞る
</li></ul>

◎
throw a "QuotaExceededError" DOMException, abort the script without an exception, prompt the user, or throttle script execution.
</div>

<div class="example">
<p>
例えば、次の~scriptは，決して終了しない。
~UAは、数~秒~待機した後に，利用者に［
~scriptを終了するか，そのまま継続させるか
］を~promptすることもできる。
◎
For example, the following script never terminates. A user agent could, after waiting for a few seconds, prompt the user to either terminate the script or let it continue.
</p>

<pre>
&lt;script&gt;
 while (true) { /* loop */ }
&lt;/script&gt;
</pre>

</div>

<div class="p">
<p>
~UAには、次のときには，利用者が~scriptingを不能化できるようにすることが奨励される：
</p>

<ul>
	<li>
~scriptが利用者に~promptしたとき（例えば `window.alert()$m ~APIを利用して）。
</li>
	<li>
~scriptの動作が何らかの制限-を超過したとき（例えば、時間~制限-）。
</li>
</ul>

◎
User agents are encouraged to allow users to disable scripting whenever the user is prompted either by a script (e.g. using the window.alert() API) or because of a script's actions (e.g. because it has exceeded a time limit).
</div>

<p>
~scriptが実行-中の間に，~scriptingが不能化された場合、~scriptは即時に終了されるべきである。
◎
If scripting is disabled while a script is executing, the script should be terminated immediately.
</p>

<p>
~UAは、利用者が［
`閲覧文脈$を何もさせずに閉じる目的で，特に~scriptを不能化する
］ことを許容してよい。
◎
User agents may allow users to specifically disable scripts just for the purposes of closing a browsing context.
</p>

<p class="example">
例えば上の例で言及した~promptは、［
`unload$et ~event~handlerを走せず，ただ頁~全体を閉じる仕組み
］を利用者に提供0することもできる。
◎
For example, the prompt mentioned in the example above could also offer the user with a mechanism to just close the page entirely, without running any unload event handlers.
</p>

				</section>
				<section id="integration-with-the-javascript-job-queue">
<h4 title="Integration with the JavaScript job queue">8.1.3.7. ~JS~job~queueとの統合</h4>

<p>
~JS仕様は、［
~cleanな 【手が加えられていない】
`~JS実行~文脈~stack$jsによる~promise演算を，一定の順序でどう実行するか
］についての ある種の不変則を指定するために、［
~JS~job, および ~job~queue
］の抽象化を定義している。
しかしながら，この仕様を書いている時点では、
~JS仕様 `JAVASCRIPT$r の `EnqueueJob$jA の定義は，~HTMLを~host環境として統合できるほど十分に柔軟でない。
◎
The JavaScript specification defines the JavaScript job and job queue abstractions in order to specify certain invariants about how promise operations execute with a clean JavaScript execution context stack and in a certain order. However, as of the time of this writing the definition of EnqueueJob in that specification is not sufficiently flexible to integrate with HTML as a host environment. [JAVASCRIPT]
</p>

<p class="note">注記：
これは厳密には真でない。
事実、それらの~algoの多くの
“実装により定義される”
とされている各~節に与えられる自由度を利用して、この目的のために それをひねくりまわすことも可能ではある。
しかしながら、技術的には，実装により定義される挙動の範囲内として是認される仕方ではあっても、結局は，本質的に~job~queueの基盤をまるごと迂回するような，遠回しでとっ散らかった回避策であふれることになる。
ここでは、この道は採らない代わりに，以下の各~下位~節に与える`故意的な違反$を導入する。
◎
This is not strictly true. It is in fact possible, by taking liberal advantage of the many "implementation defined" sections of the algorithm, to contort it to our purposes. However, the end result is a mass of messy indirection and workarounds that essentially bypasses the job queue infrastructure entirely, albeit in a way that is technically sanctioned within the bounds of implementation-defined behavior. We do not take this path, and instead introduce the following willful violation.
</p>

<p>
そのようなわけで、~UAは，~JS仕様~内のそれに代わって，以下に述べる定義を利用し~MUST。
これらは、~JS仕様により~enqueueされる~promise~jobが，~UAの`~event-loop$の中に適正に統合されることを確保する。
◎
As such, user agents must instead use the following definition in place of that in the JavaScript specification. These ensure that the promise jobs enqueued by the JavaScript specification are properly integrated into the user agent's event loops.
</p>

<p>
~UAは、~JS仕様の `RunJobs$jA 抽象演算を利用しては~MUST_NOT。
◎
The RunJobs abstract operation from the JavaScript specification must not be used by user agents.
</p>

					<section id="enqueuejob(queuename,-job,-arguments)">
<h5>8.1.3.7.1. `EnqueueJob^jA(%queueName , %job , %arguments )</h5>

<p class="algo-head">
~JS仕様の `EnqueueJob$jA 抽象演算を~callすると記されている所では、それに代わって，次の~algoが利用され~MUST：
◎
When the JavaScript specification says to call the EnqueueJob abstract operation, the following algorithm must be used in place of JavaScript's EnqueueJob:
</p>

<ol>
	<li>
~Assert：
%queueName ~EQ `PromiseJobs^l
（ ~UAは、 `ScriptJobs^l を利用してはならない）
◎
Assert: queueName is "PromiseJobs". ("ScriptJobs" must not be used by user agents.)
</li>
	<li>
<p>
%~job設定群 ~LET 何らかの適切な`環境~設定群~obj$
◎
Let job settings be some appropriate environment settings object.
</p>

<p class="warning">
ここで利用すべき`環境~設定群~obj$をどう指定するかは、まだはっきりしていない。
実施においては、これは，~jobを実行している間に`入口~某$の概念が正しく指定されていないことを意味する。
<a href="https://github.com/whatwg/html/pull/1189#issuecomment-224950188">issue #1189 における論点</a>
を見よ。
◎
It is not yet clear how to specify the environment settings object that should be used here. In practice, this means that the entry concept is not correctly specified while executing a job. See discussion in issue #1189.
</p>
	</li>
	<li>
%現任の設定群 ~LET `現任の設定群~obj$
◎
Let incumbent settings be the incumbent settings object.
</li>
	<li>
%作動中の~script ~LET `作動中の~script$
◎
Let active script be the active script.
</li>
	<li>
~Assert：
%作動中の~script ~NEQ ~NULL
— ~JS仕様が~jobを~enqueueするのは、~scriptが作動中の間に限られるので。
◎
Assert: active script is not null, as jobs are only enqueued by the JavaScript specification while a script is active.
</li>
	<li>
%~script実行~文脈 ~LET 次のようにされた新たな`~JS実行~文脈$js
⇒＃
~Function~field ~SET ~NULL,
~Realm~field ~SET %作動中の~script の`設定群~obj$sCの`~Realm$enV,
~ScriptOrModule成分 ~SET %作動中の~script の`~record$sC
◎
Let script execution context be a new JavaScript execution context, with its Function field set to null, its Realm field set to active script's settings object's Realm, and its ScriptOrModule set to active script's record.
</li>
	<li>
<p>
%~job設定群 の`担当の~event-loop$enV上に，次の手続きを遂行する`極小taskを~queueする$：
◎
Queue a microtask, on job settings's responsible event loop, to perform the following steps:
</p>

    <ol>
		<li>
~IF［
`~scriptは走れるかどうか検査する$( %~job設定群 ) ~EQ `走るな^i 
］
⇒
~RET
◎
Check if we can run script with job settings. If this returns "do not run" then return.
</li>
		<li>
<p>
`~scriptを走らすために準備する$( %~job設定群 )
◎
Prepare to run script with job settings.
</p>

<p class="note">
これは、当の~jobが走っている間，`入口~某$の概念に影響する。
◎
This affects the entry concept while the job runs.
</p>
			</li>
			<li>
<p>
`~callbackを走らすために準備する$( %現任の設定群 )
◎
Prepare to run a callback with incumbent settings.
</p>

<p class="note">
これは、当の~jobが走っている間，`現任の某$の概念に影響する。
◎
This affects the incumbent concept while the job runs.
</p>
			</li>
			<li>
<p>
`~JS実行~文脈~stack$jsに %~script実行~文脈 を`~push$する
◎
Push script execution context onto the JavaScript execution context stack.
</p>

<p class="note">
これは，
`Promise.resolve("...").then(eval)^c の様な事例において、当の~jobが走っている間，`作動中の~script$に影響する
— `eval()$c は特定0の`~script$を出自にしない組込みの関数であり、そこでは他に作動中の~scriptは無いので。
◎
This affects the active script while the job runs, in cases like Promise.resolve("...").then(eval) where there would otherwise be no active script since eval() is a built-in function that does not originate from any particular script.
</p>
			</li>
			<li>
%結果 ~LET ［
%job により指定される抽象演算
］( %arguments )
を遂行した結果
◎
Let result be the result of performing the abstract operation specified by job, using the elements of arguments as its arguments.
</li>
			<li>
`~JS実行~文脈~stack$jsから %~script実行~文脈 を`~pop$する
◎
Pop script execution context from the JavaScript execution context stack.
</li>
			<li>
`走らせた~callbackを片付ける$( %現任の設定群 )
◎
Clean up after running a callback with incumbent settings.
</li>
			<li>
`走らせた~scriptを片付ける$( %~job設定群 )
◎
Clean up after running script with job settings.
</li>
			<li>
~IF［
%結果 は中途完了である
］
⇒
`例外を報告する$( 当の~script, %結果 . `Value^sl )
◎
If result is an abrupt completion, report the exception given by result.[[Value]].
</li>
		</ol>
   </li>
</ol>

					</section>
				</section>
				<section id="integration-with-the-javascript-module-system">
<h4 title="Integration with the JavaScript module system">8.1.3.8. ~JS~module~systemとの統合</h4>

<p>
~JS仕様は、~moduleのための構文, および
その処理~modelにおける ~hostに非依存な部分を定義する。
この仕様は、その処理~modelの残りの部分
— ~module~systemが［
`type$a 属性が `module^l に設定された `script$e 要素
］を介して~bootstrapされる方法，および
~moduleが［
~fetchされ, 解決され, 実行される
］方法
— を定義する。
`JAVASCRIPT$r
◎
The JavaScript specification defines a syntax for modules, as well as some host-agnostic parts of their processing model. This specification defines the rest of their processing model: how the module system is bootstrapped, via the script element with type attribute set to "module", and how modules are fetched, resolved, and executed. [JAVASCRIPT]
</p>

<p class="note">注記：
~JS仕様は，［
“script” vs. “module”
］の用語を通して記されているが、この仕様は，一般に［
`~classic~script$ vs. `~module~script$
］の用語を通して記される
— 両者とも `script$e 要素を利用するので。
◎
Although the JavaScript specification speaks in terms of "scripts" versus "modules", in general this specification speaks in terms of classic scripts versus module scripts, since both of them use the script element.
</p>

<div class="p">
<p>
`~module~map@
とは、`~URL~record$から［
次のいずれかとして与えられる値
］への`~map$である。
</p>

<ul ><li>`~module~script$
</li><li>~NULL
— 失敗した~fetchを表現するために利用される
</li><li>`fetching^l
— 【~fetch後に前 2 項のいずれかの値に確定される，】
仮入力~値
</li></ul>
◎
A module map is a map of URL records to values that are either a module script, null (used to represent failed fetches), or a placeholder value "fetching".＼
</div>

<p>
`~module~map$は、［
~importされた~JS~moduleが［
~fetchされ, 構文解析され, 評価される
］のは，［
`文書$／`~worker$
］ごとに一度限りになる
］ことを確保するために利用される。
◎
Module maps are used to ensure that imported JavaScript modules are only fetched, parsed, and evaluated once per Document or worker.
</p>

<div class="example">

<p>
`~module~map$は ~URLを~keyとするので、次の~codeは，
`~module~map$内に 3 個の別々の~entryを作成させることになる
— それらの結果は 3 個の異なる~URLになるので：
◎
Since module maps are keyed by URL, the following code will create three separate entries in the module map, since it results in three different URLs:
</p>

<pre>import "https://example.com/module.js";
import "https://example.com/module.js#map-buster";
import "https://example.com/module.js?debug=true";
</pre>

<p>
すなわち、~URLの［
`~query$url, `素片$url
］の違いは無視されず，`~module~map$内に別個の~entryを作成させる。
したがって、 3 回の別々の~fetch, 3 回の別々の~module評価が遂行されることになる。
◎
That is, URL queries and fragments can be varied to create distinct entries in the module map; they are not ignored. Thus, three separate fetches and three separate module evaluations will be performed.
</p>

<p>
対照的に、次の~codeにより`~module~map$内に作成される~entryは 1 個だけになる
— これらの入力を`~URL構文解析-$した結果の`~URL$は、互いに等しくなるので：
◎
In contrast, the following code would only create a single entry in the module map, since after applying the URL parser to these inputs, the resulting URL records are equal:
</p>

<pre>
import "https://example.com/module2.js";
import "https:example.com/module2.js";
import "https://///example.com\\module2.js";
import "https://example.com/foo/../module2.js";
</pre>

<p>
よって、この~codeにより生じる~fetch, および~module評価は 1 回だけになる。
◎
So in this second example, only one fetch and one module evaluation will occur.
</p>

<p>
この挙動は、`共用~worker$が構文解析された`構築子~url$を~keyとするときと同じであることに注意。
◎
Note that this behavior is the same as how shared workers are keyed by their parsed constructor url.
</p>
</div>

<p class="algo-head">
`~module指定子を解決する@
手続きは、所与の (
`~script$ %~script,
`~JS文字列$ %指定子
)
に対し，次を走らす
— これは［
`~URL~record$, `失敗^i
］のいずれかを返す：
◎
To resolve a module specifier given a script script and a JavaScript string specifier, perform the following steps. It will return either a URL record or failure.
</p>

<ol>
	<li>
%~URL ~LET `~URL構文解析する$( %指定子 )
◎
Apply the URL parser to specifier.＼
</li>
	<li>
~IF［
%~URL ~NEQ `失敗^i
］
⇒
~RET %~URL
◎
If the result is not failure, return the result.
</li>
	<li>
<p>
~IF［
%指定子 の頭部は［
`/^l, `./^l, `../^l
］のいずれにも一致しない（文字 `/^l は U+002F SOLIDUS, 文字 `.^l は U+002E FULL STOP ）
］
⇒
~RET `失敗^i
◎
If specifier does not start with the character U+002F SOLIDUS (/), the two-character sequence U+002E FULL STOP, U+002F SOLIDUS (./), or the three-character sequence U+002E FULL STOP, U+002E FULL STOP, U+002F SOLIDUS (../), return failure.
</p>

<p class="note">注記：
この制約は、将来に，“~~名前のみの” ~import指定子
—
<samp>import `jquery^l</samp>
や
<samp>import `web/crypto^l</samp>
の様な指定子 —
に特別な意味を与えるような，~custom~module読込器を許容できるようにするためにある。
今の所は、そのような~importは，相対~URLとして扱われることなく失敗することになる。
◎
This restriction is in place so that in the future we can allow custom module loaders to give special meaning to "bare" import specifiers, like import "jquery" or import "web/crypto". For now any such imports will fail, instead of being treated as relative URLs.
</p>

	</li>
	<li>
~RET
`~URL構文解析する$( %指定子, %~script の`基底~URL$sC )
◎
Return the result of applying the URL parser to specifier with script's base URL as the base URL.
</li>
</ol>

<div class="example" id="module-specifier-examples">

<p>
次のものは、上の~algoに則って妥当な~module指定子になる：
◎
The following are valid module specifiers according to the above algorithm:
</p>

<ul ><li>`https://example.com/apples.js^l
</li><li>`http:example.com\pears.mjs^l
（ `http://example.com/pears.mjs^l になる
— 段 1 は基底~URLなしで構文解析するので）
◎
http:example.com\pears.mjs (becomes http://example.com/pears.mjs as step 1 parses with no base URL)
</li><li>`//example.com/bananas^l
</li><li>`./strawberries.js.cgi^l
</li><li>`../lychees^l
</li><li>`/limes.jsx^l
</li><li>`data:text/javascript,export default 'grapes';^l
</li><li>`blob:https://whatwg.org/d0360e2f-caee-469f-9a2f-87d5b0456f6f^l
</li></ul>

<p>
次のものは，上の~algoに則って妥当な~module指定子になるが、`単独の~module~scriptを~fetchする$ときには，常に失敗にされる：
◎
The following are valid module specifiers according to the above algorithm, but will invariably cause failures when they are fetched:
</p>

<ul ><li>`javascript:export default 'artichokes';^l
</li><li>`data:text/plain,export default 'kale';^l
</li><li>`about:legumes^l
</li><li>`wss://example.com/celery^l
</li></ul>

<p>
次のものは、上の~algoに則って妥当な~module指定子にならない：
◎
The following are not valid module specifiers according to the above algorithm:
</p>

<ul ><li>`https://eggplant:b/c^l
</li><li>`pumpkins.js^l
</li><li>`.tomato^l
</li><li>`..zucchini.js^l
</li><li>`.\yam.es^l
</li></ul>

</div>

					<section id="hostresolveimportedmodule(referencingmodule,-specifier)">
<h5>8.1.3.8.1. `HostResolveImportedModule^jA( %referencingScriptOrModule, %specifier )</h5>

<p class="algo-head">
~JSは、その抽象演算
`HostResolveImportedModule$jA( %referencingScriptOrModule, %指定子 )
を，実装により定義されるものと~~規定しており、
<cite>import()</cite> 提案により少しずつ更新されている。
`JAVASCRIPT$r 
`JSIMPORT$r
~UAは、次の実装を利用し~MUST：
◎
JavaScript contains an implementation-defined HostResolveImportedModule abstract operation, very slightly updated by the import() proposal. User agents must use the following implementation: [JAVASCRIPT] [JSIMPORT]
</p>

<ol>
	<li>
%参照元~script ~LET %referencingScriptOrModule . `HostDefined^sl
◎
Let referencing script be referencingScriptOrModule.[[HostDefined]].
</li>
	<li>
%~module~map ~LET
%参照元~script の`設定群~obj$sCの`~module~map$enV
◎
Let moduleMap be referencing script's settings object's module map.
</li>
	<li>
%~url ~LET `~module指定子を解決する$( %参照元~script, %指定子 )
◎
Let url be the result of resolving a module specifier given referencing script and specifier.
</li>
	<li>
~Assert：
%~url ~NEQ `失敗^i
— 以前にも、同じ引数で，`~module指定子を解決する$のに成功している。
◎
Assert: url is never failure, because resolving a module specifier must have been previously successful with these same two arguments.
</li>
	<li>
%解決-済み~module~script ~LET %~module~map[ %~url ]
◎
Let resolved module script be moduleMap[url].＼
</li>
	<li>
~Assert：
%解決-済み~module~script は`~module~script$である（すなわち，
%解決-済み~module~script ~NIN { ε, ~NULL, `fetching^l }
）
◎
(This entry must exist for us to have gotten to this point.)
◎
Assert: resolved module script is a module script (i.e., is not null or "fetching").
</li>
	<li>
~Assert：
%解決-済み~module~script の`~record$sC ~NEQ ~NULL
◎
Assert: resolved module script's record is not null.
</li>
	<li>
~RET %解決-済み~module~script の`~record$sC
◎
Return resolved module script's record.
</li>
</ol>

					</section>
					<section id="hostimportmoduledynamically(referencingscriptormodule,-specifier,-promisecapability)">

<h5>8.1.3.8.2 `HostImportModuleDynamically^jA( %referencingScriptOrModule, %指定子, %~promise能力 )</h5>

<p>
<cite>import()</cite> 提案 `JSIMPORT$r
には、実装により定義される `HostImportModuleDynamically$jA 抽象演算がある。
~UAは、次の実装を利用し~MUST：
◎
The import() proposal contains an implementation-defined HostImportModuleDynamically abstract operation. User agents must use the following implementation: [JSIMPORT]
</p>

<ol>
	<li>
%参照元~script ~LET %referencingScriptOrModule . `HostDefined^sl
◎
Let referencing script be referencingScriptOrModule.[[HostDefined]].
</li>
	<li>
<p>
次の下位手続きは`並列的$に走らす：
◎
Run the following steps in parallel:
</p>

		<ol>
			<li>
%~url ~LET `~module指定子を解決する$( %参照元~script, %指定子 )
◎
Let url be the result of resolving a module specifier given referencing script and specifier.
</li>
			<li>
<p>
~IF［
%~url ~EQ `失敗^i
］：
◎
If url is failure, then:
</p>

				<ol>
					<li>
%完了 ~LET `Completion^js{
`Type^sl: `throw^js,
`Value^sl: 新たな `TypeError$js,
`Target^sl: `empty^js
}
◎
Let completion be Completion { [[Type]]: throw, [[Value]]: a new TypeError, [[Target]]: empty }.
</li>
					<li>
`FinishDynamicImport$jA(
%referencingScriptOrModule,
%指定子,
%~promise能力,
%完了
)
を遂行する
◎
Perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion).
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%~options ~LET `子孫~script~fetch~options$( %参照元~script の`~fetch~options$sC )
◎
Let options be the descendant script fetch options for referencing script's fetch options.
</li>
			<li>
`~module~script~graphを~fetchする$(
%~url,
%設定群~obj,
`script^l,
%~options
)
◎
Fetch a module script graph given url, settings object, "script", and options.＼
</li>
			<li>
前~段の~algoが %結果 を結果として，`非同期に完了-$するまで待機する
◎
Wait until the algorithm asynchronously completes with result.
</li>
			<li>
<p>
~IF［
%結果 ~EQ ~NULL
］：
◎
If result is null, then:
</p>

				<ol>
					<li>
%完了 ~LET `Completion^js{
`Type^sl: `throw^js,
`Value^sl: 新たな `TypeError$js,
`Target^sl: `empty^js
}
◎
Let completion be Completion { [[Type]]: throw, [[Value]]: a new TypeError, [[Target]]: empty }.
</li>
					<li>
`FinishDynamicImport$jA(
%referencingScriptOrModule,
%指定子,
%~promise能力,
%完了
)
を遂行する
◎
Perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, completion).
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
`~module~scriptを走らす$( %結果, ~T )
◎
Run the module script result, with the rethrow errors boolean set to true.
</li>
			<li>
~IF［
前~段で走らせた~module~scriptから例外が投出された
］
⇒
`FinishDynamicImport$jA(
%referencingScriptOrModule,
%指定子,
%~promise能力,
投出された例外~完了
)
を遂行する
◎
If running the module script throws an exception, then perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, the thrown exception completion).
</li>
			<li>
~ELSE
⇒
`FinishDynamicImport$jA(
%referencingScriptOrModule,
%指定子,
%~promise能力,
`NormalCompletion$jA( `undefined^jv )
)
を遂行する
◎
Otherwise, perform FinishDynamicImport(referencingScriptOrModule, specifier, promiseCapability, NormalCompletion(undefined)).
</li>
		</ol>
	</li>
	<li>
~RET `undefined^jv
◎
Return undefined.
</li>
</ol>

					</section>

					</section>
					<section id="hostgetimportmetaproperties">
<h5 title="HostGetImportMetaProperties(moduleRecord)">8.1.3.8.3. `HostGetImportMetaProperties^jA( %moduleRecord )</h5>

<p>
<cite>import.meta</cite>
提案 `JSIMPORTMETA$r
には、実装により定義される `HostGetImportMetaProperties$jA 抽象演算がある。
~UAは、次の実装を利用し~MUST：
◎
The import.meta proposal contains an implementation-defined HostGetImportMetaProperties abstract operation. User agents must use the following implementation: [JSIMPORTMETA]
</p>

<ol>
	<li>
%~module~script ~LET %moduleRecord . `HostDefined^sl
◎
Let module script be moduleRecord.[[HostDefined]].
</li>
	<li>
%~URL文字列 ~LET `~URLを直列化する$( %~module~script の`基底~URL$sC )
◎
Let urlString be module script's base URL, serialized.
</li>
	<li>
~RET « `Record^js{ `Key^sl: `url^l, `Value^sl: %~URL文字列 } »
◎
Return « Record { [[Key]]: "url", [[Value]]: urlString } ».
</li>
</ol>

				</section>
				<section id="integration-with-the-javascript-agent-formalism">
<h4 title="Integration with the JavaScript agent formalism">8.1.3.9. ~JS~agent形式化との統合</h4>

<p>
~JSは、`~agent$の概念を定義している。
ここでは、以下に挙げる 5 種の型の`~agent$を定義する
— この標準が，存続期間をより良く取扱えるときが来るまでは、~UAは，それらを適切な時機に割り当て~MUST。
◎
JavaScript defines the concept of an agent. Until such a time that this standard has a better handle on lifetimes, we define five types of agents that user agents must allocate at the appropriate time.
</p>

<p class="note">注記：
将来，この仕様が存続期間をより良く取扱えるときが来れば、いつ［
`~agent$ ／ `~agent~cluster$
］作成されるかを正確に定義することになる。
◎
In the future, when this specification has a better handle on lifetimes, we hope to define exactly when agents and agent clusters are created.
</p>

<p class="XXX">
~JSは、`~agent$をより詳細に定義するものと期待されている
— それは特に，`~Realm$gLの集合を保持する：
<a href="https://github.com/tc39/ecma262/issues/882">tc39/ecma262 issue #882</a>
。
◎
JavaScript is expected to define agents in more detail; in particular that they hold a set of realms: tc39/ecma262 issue #882.
</p>

<dl class="def-list">
	<dt>`生成元が類似する~window~agent@</dt>
	<dd>
<p>
次を満たすような`~agent$：
</p>
<ul ><li>`CanBlock^sl ~EQ ~F
</li><li>その`~realm$jsの集合は、ある`互いに関係するかつ生成元も類似する閲覧文脈~群$ %U に対し，次を満たす `Window$I ~objすべての`~Realm$gLからなる
⇒
~objに`関連する設定群~obj$の`担当の閲覧文脈$enV ~IN %U
</li></ul>

◎
An agent whose [[CanBlock]] is false and whose set of realms consists of all realms of Window objects whose relevant settings object's responsible browsing context is in the same unit of related similar-origin browsing contexts.
</dd>
	<dd class="note">注記：
2 つの `Window$I ~objは、`同一生成元$であっても，それらが属する［
`生成元が類似する~window~agent$
］は異なることもある
— 具体例として、それぞれが自前の［
`互いに関係するかつ生成元も類似する閲覧文脈~群$
］に属する場合。
◎
Two Window objects that are same origin can be in different similar-origin window agents, for instance if they are each in their own unit of related similar-origin browsing contexts.
</dd>

	<dt>`専用~worker~agent@</dt>
	<dd>
<p>
次を満たすような`~agent$：
</p>
<ul ><li>`CanBlock^sl ~EQ ~T
</li><li>その`~realm$jsの集合は、ある `DedicatedWorkerGlobalScope$I ~objの`~Realm$gLのみからなる
</li></ul>
◎
An agent whose [[CanBlock]] is true and whose set of realms consists of a single DedicatedWorkerGlobalScope object's Realm.
</dd>

	<dt>`共用~worker~agent@</dt>
	<dd>
<p>
次を満たすような`~agent$：
</p>
<ul ><li>`CanBlock^sl ~EQ ~T
</li><li>その`~realm$jsの集合は、ある `SharedWorkerGlobalScope$I ~objの`~Realm$gLのみからなる
</li></ul>
◎
An agent whose [[CanBlock]] is true and whose set of realms consists a single SharedWorkerGlobalScope object's Realm.
</dd>

	<dt>`~service-worker~agent@</dt>
	<dd>
<p>
次を満たすような`~agent$：
</p>
<ul ><li>`CanBlock^sl ~EQ ~F
</li><li>その`~realm$jsの集合は、ある `ServiceWorkerGlobalScope$I ~objの`~Realm$gLのみからなる
</li></ul>

◎
An agent whose [[CanBlock]] is false and whose set of realms consists of a single ServiceWorkerGlobalScope object's Realm.
</dd>

	<dt>`~worklet~agent@</dt>
	<dd>
<p>
次を満たすような`~agent$：
</p>
<ul ><li>`CanBlock^sl ~EQ ~F
</li><li>その`~realm$jsの集合は、ある `WorkletGlobalScope$I ~objの`~Realm$gLのみからなる
</li></ul>

◎
An agent whose [[CanBlock]] is false and whose set of realms consists of a single WorkletGlobalScope object's Realm.
</dd>
	<dd class="note">注記：
複数の~realmを伴うことになる~workletに対しては、それらすべてを同じ~agent内に置く方が 概念的にはきれいになるかもしれないが、実施においては観測-可能でない。
◎
While conceptually it might be cleaner for worklets that end up with multiple realms to put all those in the same agent, it is not observable in practice.
</dd>
</dl>

				</section>
				<section id="integration-with-the-javascript-agent-cluster-formalism">
<h4 title="Integration with the JavaScript agent cluster formalism">8.1.3.10. ~JS~agent~cluster形式化との統合</h4>

<p>
2 つの`~agent$は、
`~memoryを共有できる@
こともある。
`~memoryを共有できる$という関係は、同値関係を定義する。
`~agent~cluster$は、この関係に関して同じ同値類に属するすべての`~agent$からなる。
◎
Can share memory with defines an equivalence relation. An agent cluster consists of all agents in the same equivalence class with respect to the can share memory with equivalence relation.
</p>

<ul>
	<li>
<div class="p">
<p>
先ず，
( `~agent$ %A, `~agent$ %B ) 
は、次をすべて満たすならば，`~memoryを共有できる$とされる：
</p>
		<ul>
			<li>
%A は［
`生成元が類似する~window~agent$ ／
`専用~worker~agent$ ／
`共用~worker~agent$ ／
`~service-worker~agent$
］である
</li>
			<li>
%B は`専用~worker~agent$である
 </li>
			<li>
［［
%B に属する（唯一の）`~realm$jsの`大域~obj$rM
］の`所有者~集合$
］内に，次を満たす~itemがある
⇒
~itemに`関連する~Realm$ ~IN %A
</li>
		</ul>
◎
A similar-origin window agent, dedicated worker agent, shared worker agent, or service worker agent, agent, can share memory with any dedicated worker agent whose single realm's global object's owner set contains an item whose relevant Realm belongs to agent.
</div>

<p class="note">注記：
ここでは、`所有者~集合$は `Document$I ~objを包含し得ることを利用している。
◎
We use item above as an owner set can contain Document objects.
</p>

<p class="XXX">
`~worklet~agent$は…
現在、~workletには明瞭に定義されている所有者がない
— <a href="https://github.com/w3c/css-houdini-drafts/issues/224">w3c/css-houdini-drafts issue #224</a>
を見よ。
◎
A worklet agent … currently worklets have no clearly defined owner, see: w3c/css-houdini-drafts issue #224.
</p>
	</li>
	<li>
<p>
次のいずれかを満たす
( `~agent$ %A, `~agent$ %B )
も、`~memoryを共有できる$とされる：
◎
In addition, any agent A can share memory with:
</p>

		<ul>
			<li>
%A ~EQ %B
◎
A,
</li>
			<li>
( %B, %A ) は`~memoryを共有できる$
◎
any agent B such that B can share memory with A, and
</li>
			<li>
ある`~agent$ %C が存在して，［
( %A, %C ) は`~memoryを共有できる$
］~AND［
( %C, %B ) は`~memoryを共有できる$
］
◎
any agent B such that there exists an agent C, where A can share memory with C and C can share memory with B.
</li>
		</ul>
<p class="trans-note">【
すなわち、最初に与えた関係から，
反射律, 対称律, 推移律
を満たすように拡張して得られる同値関係になる。
】</p>

	</li>
</ul>

<p>
`~agent~cluster$の概念は、~JS~memory~modelを定義するために不可欠である
— 特に どの`~agent$の間で `SharedArrayBuffer$I ~objの~~下層~dataを共有できるかにおいて。
◎
The agent cluster concept is crucial for defining the JavaScript memory model, and in particular among which agents the backing data of SharedArrayBuffer objects can be shared.
</p>

<div class="example">
<p>
次に挙げる大域~objどうしは、同じ`~agent~cluster$内にあり，互いの~memoryを共有する `SharedArrayBuffer$I ~instanceを利用できる：
◎
The following pairs of global objects are each within the same agent cluster, and thus can use SharedArrayBuffer instances to share memory with each other:
</p>

 <ul>
	<li>
`Window$I ~objと,
それが作成した専用~worker。
◎
A Window object and a dedicated worker that it created.
</li>
	<li>
~worker（型は問わない）と,
それが作成した専用~worker。
◎
A worker (of any type) and a dedicated worker it created.
</li>
	<li>
`Window$I ~objと,
それが作成した `iframe$e 要素の `Window$I ~objであって，互いに`同じ生成元~domain$になれるもの。
◎
A Window object A and the Window object of an iframe element that A created that could be same origin-domain with A.
</li>
	<li>
`Window$I ~objと,
それを開いた `Window$I ~objであって，互いに`同じ生成元~domain$であるもの。
◎
A Window object and a same origin-domain Window object that opened it.
</li>
</ul>

<p>
次に挙げる大域~objどうしは、同じ`~agent~cluster$に<em>属さない</em>ので，~memoryを共有できない：
◎
The following pairs of global objects are not within the same agent cluster, and thus cannot share memory:
</p>

<ul>
	<li>
`Window$I ~objと,
それが作成した共用~worker。
◎
A Window object and a shared worker it created.
</li>
	<li>
~worker（型は問わない）と,
それが作成した共用~worker。
◎
A worker (of any type) and a shared worker it created.
</li>
	<li>
`Window$I ~objと,
それが作成した~service-worker。
◎
A Window object and a service worker it created.
</li>
	<li>
`Window$I ~objと,
それが作成した `iframe$e 要素の `Window$I ~objであって，互いに`同じ生成元~domain$になれないもの。
◎
A Window object and the Window object of an iframe element that A created that cannot be same origin-domain with A.
</li>
</ul>
</div>
				</section>
				<section id="runtime-script-errors">
<h4 title="Runtime script errors">8.1.3.11. 実行時~script~error</h4>

<div class="p">
<p class="algo-head">
~UAは、
`~errorを報告する@
よう要求されたときは、所与の
⇒＃
`~script$： %~script,
問題箇所： ( %行番号, %列番号 ),
`大域~obj$： %標的
◎終
に対し，以下を走らせ~MUST。
この手続きは、その結果として，~errorの
`取扱済み~flag@err
を ~ON にし得る
— 各~errorには，この~flagが結付けられ、初期~時は ~OFF （すなわち，~errorは
`取扱済みでない@err
）にされる。
</p>

◎
When the user agent is required to report an error for a particular script script with a particular position line:col, using a particular target target, it must run these steps, after which the error is either handled or not handled:
</div>

<ol>
	<li>
~IF［
%標的 は`~error報告~mode下$にある
］
⇒
~RET
<!-- 
~errorの取扱済み~flag$err ~SET ~OFF
 -->
◎
If target is in error reporting mode, then abort these steps; the error is not handled.
</li>
	<li>
%標的 を
`~error報告~mode下@
におく
◎
Let target be in error reporting mode.
</li>
	<li>
%~message ~LET 
~errorについて役立つ~~情報を述べるような，~UAにより定義される文字列
~FINGERPRINTING
◎
Let message be a user-agent-defined string describing the error in a helpful manner.
(This is a fingerprinting vector.)
</li>
	<li>
<p>
%~error値 ~LET 次の様な，~errorを表現する~obj：
</p>

<ul><li>~catchされなかった例外の事例では、投出された値になる。
</li><li>~JS~errorの事例では、 `Error$E ~objになる。
</li><li>対応する値がない場合、代わりに ~NULL値が利用され~MUST。
</li></ul>

◎
Let errorValue be the value that represents the error: in the case of an uncaught exception, that would be the value that was thrown; in the case of a JavaScript error that would be an Error object. If there is no corresponding value, then the null value must be used instead.
</li>
	<li>
<p>
%~url文字列 ~LET 
`~URLを直列化する$( %~script が得られた資源に対応する`~URL~record$ )
◎
Let urlString be the result of applying the URL serializer to the URL record that corresponds to the resource from which script was obtained.
</p>

<p class="note">注記：
~scriptを包含している資源は、概して，例えば［
~inline `script$e 要素 ／
`~event~handler内容~属性$
］に対しては，構文解析した`文書$の~fileになり、外部~scriptに対しては，それを含んでいる~JS~fileになる。
動的に生成される~scriptに対するときでも、~UAには，~scriptの元の~sourceを保ち続けるよう試みることが強く奨励される。
例えば、~HTMLの構文解析-時に，外部~scriptが `document.write()$m ~APIを利用して~inline `script$e 要素を挿入した場合、当の~scriptとして［
その~scriptを包含している資源の~URL
］が報告され，行番号として［
`document.write()$m ~callの所, あるいは
その~callに渡された文字列が最初に構築された所
］の行0が報告されるのが、理想的になる。
当然、これを実装するには，自明でない部分もある。
◎
The resource containing the script will typically be the file from which the Document was parsed, e.g. for inline script elements or event handler content attributes; or the JavaScript file that the script was in, for external scripts. Even for dynamically-generated scripts, user agents are strongly encouraged to attempt to keep track of the original source of a script. For example, if an external script uses the document.write() API to insert an inline script element during parsing, the URL of the resource containing the script would ideally be reported as being the external script, and the line number might ideally be reported as the line with the document.write() call or where the string passed to that call was first constructed. Naturally, implementing this can be somewhat non-trivial.
</p>

<p class="note">注記：
同様に，~UAには、文書が構文解析されるに伴い文書を変異させるような
`document.write()$m ~callや，複数~行0にまたがっている`~event~handler内容~属性$に直面したとしても、元の行番号を保ち続けることが奨励される。
◎
User agents are similarly encouraged to keep careful track of the original line numbers, even in the face of document.write() calls mutating the document as it is parsed, or event handler content attributes spanning multiple lines.
</p>
	</li>
	<li>
~IF［
%~script の`~errorは黙秘する$sC ~EQ ~T
］
⇒＃
%~message ~SET `Script error.^l,
%~url文字列 ~SET 空~文字列,
%行番号 ~SET 0,
%列番号 ~SET 0,
%~error値 ~SET ~NULL
◎
If script's muted errors is true, then set message to "Script error.", urlString to the empty string, line and col to 0, and errorValue to null.
</li>
	<li>
%未取扱0 ~LET %標的 に向けて，次のように初期化された`~eventを発火-$した結果
⇒＃
`ErrorEvent$I を利用する,
名前 `error$et,
`cancelable$m ~SET ~T,
`message$m ~SET %~message,
`filename$m ~SET %~url文字列,
`lineno$m ~SET %行番号,
`colno$m ~SET %列番号,
`error$m ~SET %~error値
◎
Let notHandled be the result of firing an event named error at target, using ErrorEvent, with the cancelable attribute initialized to true, the message attribute initialized to message, the filename attribute initialized to urlString, the lineno attribute initialized to line, the colno attribute initialized to col, and the error attribute initialized to errorValue.
</li>
	<li>
%標的 を`~error報告~mode下$から外す
◎
Let target no longer be in error reporting mode.
</li>
	<li>
<p>
~errorの`取扱済み~flag$err ~SET［
%未取扱0 ~EQ ~F ならば ~ON ／
~ELSE_ ~OFF
］
◎
If notHandled is false, then the error is handled. Otherwise, the error is not handled.
</p>

<p class="note">注記：
~event~handlerが ~T を返した場合、`~event~handler処理~algo$に従って， %~event は取消されることになる。
◎
Returning true in an event handler cancels the event per the event handler processing algorithm.
</p>
	</li>
</ol>

					<section id="runtime-script-errors-in-documents">
<h5 title="Runtime script errors in documents">8.1.3.11.1. 文書における実行時~script~error</h5>

<div class="p">
<p class="algo-head">
`例外を報告する@
ときは、所与の (
`~script$ %~script,
例外 %例外
) に対し，次を走らせ~MUST：
</p>

<ol>
	<li>
次を与える下で，その`~errorを報告する$
⇒＃
~script： %~script,
問題箇所： %~script を包含している資源~内の問題箇所 ( 行番号, 列番号 ),
標的： %~script の`設定群~obj$sCの`大域~obj$enV
</li>
	<li>
~IF［
%例外 の`取扱済み~flag$err ~EQ ~OFF
］
⇒
任意選択で、 %例外 を~UAの開発者~consoleに報告する
</li>
</ol>

◎
When the user agent is to report an exception E, the user agent must report the error for the relevant script, with the problematic position (line number and column number) in the resource containing the script, using the global object specified by the script's settings object as the target. If the error is still not handled after this, then the error may be reported to a developer console.
</div>

					</section>
					<section id="the-errorevent-interface">
<h5 title="The ErrorEvent interface">8.1.3.11.2. `ErrorEvent^I ~interface</h5>

<pre class="idl">
[Constructor(DOMString type, optional `ErrorEventInit$I %eventInitDict),
 Exposed=(Window,Worker)]
interface `ErrorEvent@I : `Event$I {
  readonly attribute DOMString `message$m;
  readonly attribute USVString `filename$m;
  readonly attribute unsigned long `lineno$m;
  readonly attribute unsigned long `colno$m;
  readonly attribute any `error$m;
};

dictionary `ErrorEventInit@I : `EventInit$I {
  DOMString %message = "";
  USVString %filename = "";
  unsigned long %lineno = 0;
  unsigned long %colno = 0;
  any %error = null;
};
</pre>

<dl class="idl-def">
	<dt>`message@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The message attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、~error~messageを表現する。
◎
It represents the error message.
</dd>

	<dt>`filename@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The filename attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、~scriptにおいて~errorが元々生じた所の`~URL$を表現する。
◎
It represents the URL of the script in which the error originally occurred.
</dd>

	<dt>`lineno@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The lineno attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、~scriptにおいて~errorが元々生じた所の行番号を表現する。
◎
It represents the line number where the error occurred in the script.
</dd>

	<dt>`colno@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The colno attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、~scriptにおいて~errorが元々生じた所の列番号を表現する。
◎
It represents the column number where the error occurred in the script.
</dd>

	<dt>`error@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The error attribute must return the value it was initialized to.＼
</dd>
	<dd>
これは、適切になる所では，~errorを表現している~objに設定される（例：
~catchされなかった DOM 例外の事例では、例外~objになる）。
◎
Where appropriate, it is set to the object representing the error (e.g., the exception object in the case of an uncaught DOM exception).
</dd>
</dl>

					</section>
				</section>
				<section id="unhandled-promise-rejections">
<h4 title="Unhandled promise rejections">8.1.3.12. 未取扱いの~promise却下</h4>

<p>
同期的な`実行時~script~error$に加えて、~scriptは，非同期的な~promise却下に出くわすこともある
— それは、［
`unhandledrejection$et, `rejectionhandled$et
］~eventを介して追跡される。
◎
In addition to synchronous runtime script errors, scripts may experience asynchronous promise rejections, tracked via the unhandledrejection and rejectionhandled events.
</p>

<p class="algo-head">
`却下済み~promiseについて通知する@
ときは、所与の (
`環境~設定群~obj$ %設定群~obj
) に対し，次を走らせ~MUST：
◎
When the user agent is to notify about rejected promises on a given environment settings object settings object, it must run these steps:
</p>

<ol>
	<li>
%~list ~LET
%設定群~obj の`通知待ちの却下済み~promise~list$enVの複製
◎
Let list be a copy of settings object's about-to-be-notified rejected promises list.
</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET
◎
If list is empty, return.
</li>
	<li>
%設定群~obj の`通知待ちの却下済み~promise~list$enVを~~空にする
◎
Clear settings object's about-to-be-notified rejected promises list.
</li>
	<li>
<p>
次の下位手続きを走らす`~taskを~queueする$：
◎
Queue a task to run the following substep:
</p>
		<ol>
			<li>
<p>
%~list 内の~EACH ( ~promise  %p ) に対し：
◎
For each promise p in list:
</p>
				<ol>
					<li>
~IF［
%p の `PromiseIsHandled^sl 内部~slot ~EQ ~T
］
⇒
~CONTINUE
◎
If p's [[PromiseIsHandled]] internal slot is true, continue to the next iteration of the loop.
</li>
					<li>
%未取扱0 ~LET %設定群~obj の`大域~obj$enVに向けて，次のように初期化された`~eventを発火-$した結果
⇒＃
`PromiseRejectionEvent$I ~interfaceを利用する,
名前 `unhandledrejection$et,
`cancelable$m ~SET ~T,
`promise$m ~SET %p,
`reason$m ~SET %p の `PromiseResult^sl 内部~slotの値
◎
Let notHandled be the result of firing an event named unhandledrejection at settings object's global object, using PromiseRejectionEvent, with the cancelable attribute initialized to true, the promise attribute initialized to p, and the reason attribute initialized to the value of p's [[PromiseResult]] internal slot.
</li>
					<li>
~IF［
%未取扱0 ~EQ ~F
］
⇒
この~promise却下の`取扱済み~flag$rej ~SET ~ON
◎
If notHandled is false, then the promise rejection is handled. Otherwise, the promise rejection is not handled.
</li>
					<li>
~IF［
%p の `PromiseIsHandled^sl 内部~slot ~EQ ~F
］
⇒
%設定群~obj の`未決の却下済み~promiseへの弱い参照の集合$enVに %p を追加する
◎
If p's [[PromiseIsHandled]] internal slot is false, add p to settings object's outstanding rejected promises weak set.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p>
この~algoは，~promise却下の
`取扱済み~flag@rej
を ~ON にし得る
— 各~promise却下には，この~flagが結付けられ、初期~時は ~OFF にされる（すなわち，~promise却下は
`取扱済みでない@rej
）。
これは、~script~errorに対する`取扱済み~flag$errと並行する概念である。
この~algoの結果、却下の`取扱済み~flag$rejが依然として ~OFF ならば、その却下は，~UAの開発者~consoleに報告されてよい。
◎
This algorithm results in promise rejections being marked as handled or not handled. These concepts parallel handled and not handled script errors. If a rejection is still not handled after this, then the rejection may be reported to a developer console.
</p>

					<section id="the-hostpromiserejectiontracker-implementation">
<h5 title="HostPromiseRejectionTracker(promise, operation)">8.1.3.12.1. `HostPromiseRejectionTracker^jA (%promise, %operation)</h5>

<p class="algo-head">
~JS `JAVASCRIPT$r は、その抽象演算
`HostPromiseRejectionTracker$jA( %promise, %演算 )
を，実装により定義されるものと~~規定している。
~UAは、次の実装を利用し~MUST：
◎
JavaScript contains an implementation-defined HostPromiseRejectionTracker(promise, operation) abstract operation. User agents must use the following implementation: [JAVASCRIPT]
</p>

<ol>
	<li>
<p>
%~script ~LET `走っている~script$
◎
Let script be the running script.
</li>
	<li>
~IF［
%~script の`~errorは黙秘する$sC ~EQ ~T
］
⇒
~RET
◎
If script's muted errors is true, terminate these steps.
</li>
	<li>
%設定群~obj ~LET %~script の`設定群~obj$sC
◎
Let settings object be script's settings object.
</li>
	<li>
%~list ~LET %設定群~obj の`通知待ちの却下済み~promise~list$enV
◎
↓</li>
	<li>
<p>
%演算 に応じて：
</p>
		<dl class="switch">
			<dt>
`reject^l
◎
If operation is "reject",
</dt>
			<dd>
%~list に %promise を追加する
◎
Add promise to settings object's about-to-be-notified rejected promises list.
</dd>

			<dt>
`handle^l
◎
If operation is "handle",
</dt>
			<dd>
				<ol>
					<li>
~IF［
%promise ~IN %~list
］
⇒＃
%~list から %promise を除去する；
~RET
◎
If settings object's about-to-be-notified rejected promises list contains promise, remove promise from that list and abort these steps.
</li>
					<li>
%弱い参照の集合 ~LET %設定群~obj の`未決の却下済み~promiseへの弱い参照の集合$enV
◎
↓</li>
					<li>
~IF［
%promise ~NIN %弱い参照の集合
］
⇒
~RET
◎
If settings object's outstanding rejected promises weak set does not contain promise, return.
</li>
					<li>
%弱い参照の集合 から %promise を除去する
◎
Remove promise from settings object's outstanding rejected promises weak set.
</li>
					<li>
次を走らす`~taskを~queueする$
⇒
%設定群~obj の`大域~obj$enVに向けて，次のように初期化された`~eventを発火-$する
⇒＃
`PromiseRejectionEvent$I ~interfaceを利用する,
名前 `rejectionhandled$et,
`promise$m ~SET %promise,
`reason$m ~SET %promise の `PromiseResult^sl 内部~slotの値
◎
Queue a task to fire an event named rejectionhandled at settings object's global object, using PromiseRejectionEvent, with the promise attribute initialized to promise, and the reason attribute initialized to the value of promise's [[PromiseResult]] internal slot.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

					</section>
					<section id="the-promiserejectionevent-interface">
<h5 title="The PromiseRejectionEvent interface">8.1.3.12.2. `PromiseRejectionEvent^I ~interface</h5>

<pre class="idl">
[Constructor(DOMString type, `PromiseRejectionEventInit$I %eventInitDict),
 Exposed=(Window,Worker)]
interface `PromiseRejectionEvent@I : `Event$I {
  readonly attribute Promise&lt;any&gt; `promise$m;
  readonly attribute any `reason$m;
};

dictionary `PromiseRejectionEventInit@I : `EventInit$I {
  required Promise&lt;any&gt; %promise;
  any %reason;
};
</pre>

<dl class="idl-def">
	<dt>`promise@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、この通知が~~対象にしている~promiseを表現する。
◎
The promise attribute must return the value it was initialized to. It represents the promise which this notification is about.
</dd>

	<dt>`reason@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
これは、~promiseの却下~事由を表現する。
◎
The reason attribute must return the value it was initialized to. It represents the rejection reason for the promise.
</dd>
</dl>

					</section>
				</section>
				<section id="hostensurecancompilestrings(callerrealm,-calleerealm)">
<h5>8.1.3.13. `HostEnsureCanCompileStrings^jA(%callerRealm, %calleeRealm)</h5>

<p class="algo-head">
~JS `JAVASCRIPT$r は、その抽象演算
`HostEnsureCanCompileStrings$jA( %callerRealm, %calleeRealm )
を，実装により定義されるものと~~規定している。
~UAは、次の実装を利用し~MUST：
◎
JavaScript contains an implementation-defined HostEnsureCanCompileStrings(callerRealm, calleeRealm) abstract operation. User agents must use the following implementation: [JAVASCRIPT]
</p>

<ol>
	<li>
Perform ? `EnsureCSPDoesNotBlockStringCompilation$jA( %callerRealm, %calleeRealm)
`CSP$r
◎
Perform ? EnsureCSPDoesNotBlockStringCompilation(callerRealm, calleeRealm). [CSP]
</li>
</ol>

  				</section>
			</section>
			<section id="event-loops">
<h3 title="Event loops">8.1.4. ~event-loop</h3> 

				<section id="definitions-3">
<h4 title="Definitions">8.1.4.1. 各種~定義</h4>

<p>
~UAは、この節に述べる
`~event-loop@
を利用して，［
~event, 利用者対話, ~script, 描画, ~networking, 等々
］を互いに協調させ~MUST。
~event-loopには、次の 2 種類がある：
◎
To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. There are two kinds of event loops:＼
</p>

<div class="p">

<dl class="def-list">
	<dt>`閲覧文脈~event-loop@</dt>
	<dd>
`閲覧文脈$用のもの。
</dd>

	<dt>`~worker~event-loop@</dt>
	<dd>
`~worker$用のもの。
【<a href="~WORKERS#worker-event-loop">参照</a>】
</dd>
</dl>

◎
those for browsing contexts, and those for workers.
</div>

<div>
<p>
`閲覧文脈~event-loop$は：
</p>

<ul>
	<li>
~UAごとに， 1 個~以上~MUST。
</li>
	<li>
各［
`互いに関係するかつ生成元も類似する閲覧文脈~群$
］ごとに， 1 個~以下で~MUST。
</li>
</ul>

◎
There must be at least one browsing context event loop per user agent, and at most one per unit of related similar-origin browsing contexts.
</div>

<p class="note">注記：
［
`互いに関係する閲覧文脈~群$
］ %U に対し，`~event-loop$が 2 個~以上あるとすると、［
%U 内のある［
`互いに関係するかつ生成元も類似する閲覧文脈~群$
］から，
%U 内の別の［
それ
］へ切替える
］ように`閲覧文脈$が`~navigate$されたときに、複雑問題が発生する。
この仕様は、現時点では，この複雑問題をどう取扱うかは述べていない。
◎
When there is more than one event loop for a unit of related browsing contexts, complications arise when a browsing context in that group is navigated such that it switches from one unit of related similar-origin browsing contexts to another. This specification does not currently describe how to handle these complications.
</p>

<p>
`閲覧文脈~event-loop$は、常に， 1 個~以上の`閲覧文脈$に属する
— そのような`閲覧文脈$すべてが消去ると同時に，`~event-loop$も消去る。
`閲覧文脈$は、常に，その活動に協調している`~event-loop$を持つ。
◎
A browsing context event loop always has at least one browsing context. If such an event loop's browsing contexts all go away, then the event loop goes away as well. A browsing context always has an event loop coordinating its activities.
</p>

<p>
`~worker~event-loop$は，より単純であり、各~workerごとに， 1 個の`~event-loop$を持つ。
`~worker処理~model$が、その`~event-loop$の存続期間を管理する。
◎
Worker event loops are simpler: each worker has one event loop, and the worker processing model manages the event loop's lifetime.
</p>

<hr>

<p>
`~event-loop$は、 1 個以上の
`~task~queue@
を持つ。
`~task~queue$は何個かの
`~task@
からなる有順序~listである。
その各~taskは、次に挙げるような仕事を担当する~algoである：
◎
An event loop has one or more task queues. A task queue is an ordered list of tasks, which are algorithms that are responsible for such work as:
</p>

<dl>
	<dt>
~eventの配送-
◎
Events
</dt>
	<dd>
特定0の `EventTarget$I ~objに向けて `Event$I ~objを`配送-$するときは、専用の~taskで行われることが多い。
◎
Dispatching an Event object at a particular EventTarget object is often done by a dedicated task.
</dd>
	<dd class="note">注記：
すべての~eventが`~task~queue$を利用して配送されるわけではない。
他の~taskの中で配送されるものも多々ある。
◎
Not all events are dispatched using the task queue, many are dispatched during other tasks.
</dd>

	<dt>
構文解析
◎
Parsing
</dt>
	<dd>
`~HTML構文解析器$が，~byte列を~token化して結果の~token列を処理することは、概して~taskになる。
◎
The HTML parser tokenizing one or more bytes, and then processing any resulting tokens, is typically a task.
</dd>

	<dt>
~callback
◎
Callbacks
</dt>
	<dd>
~callbackに対する~callは、専用の~taskで行われることが多い。
◎
Calling a callback is often done by a dedicated task.
</dd>

	<dt>
資源の利用
◎
Using a resource
</dt>
	<dd>
~algoが ある資源を`~fetch$するとき，その~fetchingが他を阻まずに行われる場合、［
資源の一部または~~全部が可用になったときの処理
］は，何らかの~taskにより遂行される。
◎
When an algorithm fetches a resource, if the fetching occurs in a non-blocking fashion then the processing of the resource once some or all of the resource is available is performed by a task.
</dd>

	<dt>
DOM 操作に対する反応
◎
Reacting to DOM manipulation
</dt>
	<dd>
一部の要素は、要素が`文書の中へ挿入-$されるときなど， DOM 操作に呼応して誘発されるような~taskを有する。
◎
Some elements have tasks that trigger in response to DOM manipulation, e.g. when that element is inserted into the document.
</dd>
</dl>

<div class="p">
<p>
`閲覧文脈~event-loop$内の各`~task$には、`文書$が結付けられる
— それは、~taskに応じて次で与えられる文書になる：
</p>

<dl class="switch">
	<dt>~taskは 要素の文脈~下で~queueされたものである場合</dt>
	<dd>
要素の`~node文書$。
</dd>

	<dt>~taskは `閲覧文脈$の文脈~下で~queueされたものである場合</dt>
	<dd>
~queueされた時点で，`閲覧文脈$にて`作動中の文書$。
</dd>

	<dt>~taskは `~script$［ により／に向けて ］~queueされたものである場合</dt>
	<dd>
~scriptの`設定群~obj$sCにより指定される`担当の文書$enV。
</dd>

</dl>

◎
Each task in a browsing context event loop is associated with a Document; if the task was queued in the context of an element, then it is the element's node document; if the task was queued in the context of a browsing context, then it is the browsing context's active document at the time the task was queued; if the task was queued by or for a script then the document is the responsible document specified by the script's settings object.
</div>

<p>
`~task$は、特定の`~event-loop$向けに意図される。
それは、［
`~task$に結付けられている［
`文書$ ／ `~worker$
］のための`~task$
］を取扱っている`~event-loop$である。
◎
A task is intended for a specific event loop: the event loop that is handling tasks for the task's associated Document or worker.
</p>

<p class="algo-head">
~UAは，
`~taskを~queueする@
ときは、所与の
( `~task$ %~task )
に対し，［
関連する`~event-loop$に属する いずれかの`~task~queue$
］に %~task を追加し~MUST。
◎
When a user agent is to queue a task, it must add the given task to one of the task queues of the relevant event loop.
</p>

<div class="p">
<p>
どの`~task$も，特定の
`~task源@
から来るものとして定義される：
</p>
<ul>
	<li>
［
特定0の`~task源$からの，特定0の`~event-loop$を行先にする
］ような，すべての~taskは、常に同じ`~task~queue$に追加され~MUST
— 例えば
⇒＃
`文書$の~timerにより生成される各~callback ／
~mouse移動により`文書$上に発火される各~event ／
`文書$の構文解析器により~queueされる各~task
</li>
	<li>
一方で、異なる`~task源$からの`~task$は，異なる`~task~queue$内に置かれてよい。
</li>
</ul>
◎
Each task is defined as coming from a specific task source. All the tasks from one particular task source and destined to a particular event loop (e.g. the callbacks generated by timers of a Document, the events fired for mouse movements over that Document, the tasks queued for the parser of that Document) must always be added to the same task queue, but tasks from different task sources may be placed in different task queues.
</div>

<p class="example">
例えば~UAは、［
~mouse／~key
］~eventに対しては， 1 個の`~task~queue$（ `利用者対話~task源$ ）をあてがい、他のすべてに対しては，別のものをあてがうこともできる。
その上で，~UAは、~UIを即応可能に保ちつつ,
他の~task~queueも放置しないよう，［
~keyboard／~mouse
］~eventに時間の半分以上をあてがいつつ, 残りを他の~taskにあてがうこともできる
— どの`~task源$においても，その中の各~eventは必ず順序通りに処理しつつ。
◎
For example, a user agent could have one task queue for mouse and key events (the user interaction task source), and another for everything else. The user agent could then give keyboard and mouse events preference over other tasks three quarters of the time, keeping the interface responsive but not starving other task queues, and never processing events from any one task source out of order.
</p>

<div class="p">
<p>
各`~event-loop$は、次のものを持つ：
</p>
<dl class="def-list">
	<dt>`現在~走っている~task@</dt>
	<dd>
初期~時は ~NULL とする。
</dd>
	<dd>
再入性を取扱うために利用される。
</dd>

	<dt>`極小task~checkpoint遂行-中~flag@</dt>
	<dd>
初期~時は ~OFF とする。
</dd>
	<dd>
`極小task~checkpointを遂行する$~algoが再入的に呼出されるのを防止するために利用される。
</dd>
</dl>
◎
Each event loop has a currently running task. Initially, this is null. It is used to handle reentrancy. Each event loop also has a performing a microtask checkpoint flag, which must initially be false. It is used to prevent reentrant invocation of the perform a microtask checkpoint algorithm.
</div>

				</section>
				<section id="event-loop-processing-model">
<h4 title="Processing model">8.1.4.2. 処理~model</h4> 

<p class="algo-head">
`~event-loop$ %~loop は、存在する限り，次の手続きを継続的に（反復的に）走らせ続け~MUST：
◎
An event loop must continually run through the following steps for as long as it exists:
</p>

<ol>
	<li id="step1">
<p>
%~task ~LET 次をすべて満たすように選ばれる`~task$：
</p>

<ul ><li>%~task が属する`~task~queue$ %~queue は %~loop に属する
</li><li>%~loop は`閲覧文脈~event-loop$であるならば、 %~task に結付けらている`文書$は`全部的に作動中$である。
</li><li>%~task は、上述に該当する~taskのうち， %~queue 内で最も遠過去のものである
— ~UAは %~queue としてどの`~task~queue$を選んでもよい。
</li></ul>

◎
Let oldestTask be the oldest task on one of the event loop's task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue.＼
</li>
	<li>
<p>
~IF［
該当する %~task はある
］：
◎
If there is no task to select, then jump to the microtasks step below.
</p>
		<ol>
			<li>
%~loop の`現在~走っている~task$ ~SET %~task
◎
Set the event loop's currently running task to oldestTask.
</li>
			<li>
%~task を走らす
◎
Run oldestTask.
</li>
			<li>
%~loop の`現在~走っている~task$ ~SET ~NULL
◎
Set the event loop's currently running task back to null.
</li>
			<li>
%~task を %~queue から除去する
◎
Remove oldestTask from its task queue.
</li>
		</ol>
	</li>
	<li>
`極小task~checkpointを遂行する$
◎
Microtasks: Perform a microtask checkpoint.
</li>
	<li>
<p>
~IF［
%~loop は`閲覧文脈~event-loop$である
］
⇒
以下に従って
`描画を更新する@：
◎
Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.
</p>

		<ol>
			<li>
%now ~LET
`Performance$I ~objの `now()$m ~methodから返される値
`HRT$r
◎
Let now be the value that would be returned by the Performance object's now() method. [HRT]
</li>
			<li>
<p>
%文書s ~LET
%~loop に結付けられている`文書$たちの~list
— それらの順序は、次の条件を満たさ~MUST（条件~以外は任意）
⇒
~list内のどの 2 つの`文書$ %D1, %D2 に対しても：
◎
Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:
</p>

				<ul>
					<li>
%D2 が`属する閲覧文脈$は %D1 を`通して入子に$されているならば、
%D2 は %D1 より後になる。
◎
Any Document B that is nested through a Document A must be listed after A in the list.
</li>
					<li>
%D1, %D2 が`属する閲覧文脈$は，いずれも
同じある`文書$ %D 内の`閲覧文脈~容器$ %E1, %E2 （同順）を`通して入子に$されているならば、［
~listにおける %D1, %D2 の順序
］は，［
%D における`木~順序$による %E1, %E2 の順序
］に合致する。
◎
If there are two documents A and B whose browsing contexts are both nested browsing contexts and their browsing context containers are both elements in the same Document C, then the order of A and B in the list must match the relative tree order of their respective browsing context containers in C.
</li>
				</ul>

<p>
以下において %文書s 内の ~EACH ( `文書$ ) にわたって反復する手続きでは、この順序で処理され~MUST。
◎
In the steps below that iterate over docs, each Document must be processed in the order it is found in the list.
</p>
			</li>
			<li>
<p>
%文書s 内の`文書$のうち，［
それが`属する閲覧文脈$ %B が，次のいずれかに該当するもの
］すべてを %文書s から除去する：
◎
↓</p>

				<ul>
					<li>
<p>
%B の`~top-level閲覧文脈$は、この時点で描画を更新しても益はないと予見される。
◎
If there are top-level browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context's top-level browsing context is in B.
</p>

<div class="note">
<p>注記：
`~top-level閲覧文脈$の描画を更新しても益はないかどうかは、更新~頻度など，種々の要因に依存する。
例えば~browserは、更新率 60Hz を達成しようと試みている場合、この手続きは、毎 1/60 秒（およそ 16.7ms ）ごとのみに必要とされる。
~browserは、`~top-level閲覧文脈$はこの更新率を維持できないときは，その`文書$の集合に対しては，~frameを時々落とすのではなく，より維持し易い 30Hz に落とすこともある。
（この仕様は、描画をいつ更新するかについて，特定0の~modelを何ら義務付けない。）
同様に、`~top-level閲覧文脈$が背後に~~回されている場合、~UAは，その頁をずっと遅い 4Hz あるいは，もっと落とすよう決めることもある。
◎
Whether a top-level browsing context would benefit from having its rendering updated depends on various factors, such as the update frequency. For example, if the browser is attempting to achieve a 60Hz refresh rate, then these steps are only necessary every 60th of a second (about 16.7ms). If the browser finds that a top-level browsing context is not able to sustain this rate, it might drop to a more sustainable 30Hz for that set of Documents, rather than occasionally dropping frames. (This specification does not mandate any particular model for when to update the rendering.) Similarly, if a top-level browsing context is in the background, the user agent might decide to drop that page to a much slower 4Hz, or even less.
</p>

<p>
~browserが描画の更新を飛ばす他の~~理由として、ある種の`~task$たちを~~連続して実行して，間に差挟まれるのは`極小task~checkpointを遂行する$ことにのみになることを確保することが挙げられる（例えば，`~animation~frame~callbackたちを走らす$こともなく）。 
例えば~UAは、描画の更新を挟まずに，複数の~timer~callbackを結合したいと望むかもしれない。
◎
Another example of why a browser might skip updating the rendering is to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). For example, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.
</p>
</div>
					</li>
					<li>
<p>
%B は、`入子の閲覧文脈$であって，この時点で描画を更新しても益はないと予見される。
◎
If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.
</p>

<p class="note">注記：
`~top-level閲覧文脈$と同様、`入子の閲覧文脈$の描画を更新しても益はないかどうかは、様々な要因に依存する。
例えば，~UAは、第三者主体の内容の描画に費やす資源を減らしたいと望むかもしれない
— とりわけ利用者から現在~可視でない, あるいは資源が拘束されている下では。
その場合、~browserは，その種の内容に対する描画の更新を，頻度を落としたり, やめるよう決めることもできる。
◎
As with top-level browsing contexts, a variety of factors can influence whether it is profitable for a browser to update the rendering of nested browsing contexts. For example, a user agent might wish to spend less resources rendering third-party content, especially if it is not currently visible to the user or if resources are constrained. In such cases, the browser could decide to update the rendering for such content infrequently or never.
</p>
					</li>
				</ul>
			</li>
			<li>
<p>
この段の中の各~段における “~EACH( %文書 ) ” は、
%文書s 内の`文書$のうち，［
当の段を走らす時点において，`全部的に作動中$である
］ものたちに対し，順に繰り~~返すものとする：
◎
↓
</p>
				<ol>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`~resize手続き$を走らす
`CSSOMVIEW$r
◎
For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOMVIEW]
</li>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`~scroll手続き$を走らす
`CSSOMVIEW$r
◎
For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOMVIEW]
</li>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`媒体~queriesを評価して変化を報告する$
`CSSOMVIEW$r
◎
For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOMVIEW]
</li>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`~CSS~animationを走らせて~eventを送信する@
`CSSANIMATIONS$r
◎
For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSSANIMATIONS]
</li>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`全screen手続き$を走らす
`FULLSCREEN$r
◎
For each fully active Document in docs, run the fullscreen steps for that Document, passing in now as the timestamp. [FULLSCREEN]
</li>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`~animation~frame~callbackたちを走らす$
◎
For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.
</li>
					<li>
~EACH( %文書 ) に対し
⇒
( 時刻印: %now ) を渡して，
%文書 に対する
`交差観測の更新~手続き$を走らす
`INTERSECTIONOBSERVER$r
◎
For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp. [INTERSECTIONOBSERVER]
</li>
					<li>
~EACH( %文書 ) に対し
⇒
［
%文書, および それが`属する閲覧文脈$
］の描画や~UIを，現在の状態を反映するように更新する。
◎
For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p >
~ELIF［
%~loop は`~worker~event-loop$である
］~AND［
%~loop 内のどの`~task~queue$も空である
］~AND［
`WorkerGlobalScope$I ~objの`~closing~flag$  ~EQ ~ON
］：
</p>
		<ol>
			<li>
この手続きは中止した上で， %~loop を破壊する
</li>
			<li>
<a href="~WORKERS#workers">~Web~worker 節</a>
にて述べられる`~workerを走らす$手続きを再開する
</li>
		</ol>
◎
If this is a worker event loop (i.e. one running for a WorkerGlobalScope), but there are no tasks in the event loop's task queues and the WorkerGlobalScope object's closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.
</li>
</ol>

<hr>

<p>
各`~event-loop$は、
`極小task~queue@
を有する。
`極小task@
とは、元々は，［
`~task~queue$ではなく，`極小task~queue$
］に~queueされるものとされた`~task$である。
`極小task$には、
`孤立~callback極小task@,
`複合~極小task@
の 2 種類がある。
◎
Each event loop has a microtask queue. A microtask is a task that is originally to be queued on the microtask queue rather than a task queue. There are two kinds of microtasks: solitary callback microtasks, and compound microtasks.
</p>

<p class="note">注記：
この仕様は、`孤立~callback極小task$のみを定義する。
`複合~極小task$を利用する各~仕様は、`~event-loopを回す$~algoを取扱うために，`~callbackを包装する$手間をかける必要がある。
◎
This specification only has solitary callback microtasks. Specifications that use compound microtasks have to take extra care to wrap callbacks to handle spinning the event loop.
</p>

<p class="algo-head">
~algoにて
`極小taskを~queueする@
ことが要求される所では、関連する`~event-loop$の`極小task~queue$に 当の`極小task$を付加し~MUST
— 
`極小task~task源@
が、そのような`極小task$の`~task源$である。
◎
When an algorithm requires a microtask to be queued, it must be appended to the relevant event loop's microtask queue; the task source of such a microtask is the microtask task source.
</p>

<p class="note">注記：
`極小task$は、定例の`~task~queue$に移動されることもある
— その初期 【初回の？】 実行の間に，それが`~event-loopを回す$場合には。
その事例では、`極小task~task源$が`~task源$として利用される。
通常は、`極小task$の`~task源$は関連しない。
◎
It is possible for a microtask to be moved to a regular task queue, if, during its initial execution, it spins the event loop. In that case, the microtask task source is the task source used. Normally, the task source of a microtask is irrelevant.
</p>

<p class="algo-head">
~UAは、
`極小task~checkpointを遂行する@
ときは，次を走らせ~MUST：
◎
When a user agent is to perform a microtask checkpoint,＼
</p>

<ol>
	<li>
~IF［
`極小task~checkpoint遂行-中~flag$ ~EQ ~ON
］
⇒
~RET
◎
if the performing a microtask checkpoint flag is false, then the user agent must run the following steps:
</li>
	<li>
%~loop ~LET 当の`~event-loop$
◎
↓</li>
	<li>
`極小task~checkpoint遂行-中~flag$ ~SET ~ON
◎
Set the performing a microtask checkpoint flag to true.
</li>
	<li>
<p>
~WHILE［
%~loop の`極小task~queue$は空でない
］：
◎
While the event loop's microtask queue is not empty:
</p>
		<ol>
			<li>
%極小task ~LET %~loop の`極小task~queue$上の最も遠過去の`極小task$
◎
Let oldestMicrotask be the oldest microtask on the event loop's microtask queue.
</li>
			<li>
%~loop の`現在~走っている~task$ ~SET %極小task
◎
Set the event loop's currently running task to oldestMicrotask.
</li>
			<li>
<p>
%極小task を走らす
◎
Run oldestMicrotask.
</p>

<p class="note">注記：
これは、~scriptによる~callbackの呼出ingを孕むかもしれず，最終的に `走らせた~scriptを片付ける$手続きを~callする結果、この~algoが再度~callされることになる。
`極小task~checkpoint遂行-中~flag$を利用しているのは、その再入性を避けるためである。
◎
This might involve invoking scripted callbacks, which eventually calls the clean up after running script steps, which call this perform a microtask checkpoint algorithm again, which is why we use the performing a microtask checkpoint flag to avoid reentrancy.
</p>
			</li>
			<li>
%~loop の`現在~走っている~task$ ~SET ~NULL
◎
Set the event loop's currently running task back to null.
</li>
	<li>
%極小task を`極小task~queue$から除去する
◎
Remove oldestMicrotask from the microtask queue.
</li>
		</ol>
	</li>
	<li>
~EACH( `環境~設定群~obj$ %設定群 ) に対し
⇒
~IF［
%設定群 の`担当の~event-loop$enV ~EQ %~loop
］
⇒
%設定群 に対し，`却下済み~promiseについて通知する$
◎
For each environment settings object whose responsible event loop is this event loop, notify about rejected promises on that environment settings object.
</li>
	<li>
<a href="~INDEXEDDB#cleanup-indexed-database-transactions">Indexed Database ~transactionを片付ける</a>
◎
Cleanup Indexed Database transactions.
</li>
	<li>
`極小task~checkpoint遂行-中~flag$ ~SET ~OFF
◎
Set the performing a microtask checkpoint flag to false.
</li>
</ol>

<p class="algo-head">
~UAは、`複合~極小task$が走っている間に［
所与の `手続き^V を走らすような
`複合~極小task下位taskを実行する@
］よう要求されたときは、次を走らせ~MUST：
◎
If, while a compound microtask is running, the user agent is required to execute a compound microtask subtask to run a series of steps, the user agent must run the following steps:
</p>

<ol>
	<li>
%親 ~LET %~loop の`現在~走っている~task$
（現在~走っている`複合~極小task$）。
◎
Let parent be the event loop's currently running task (the currently running compound microtask).
</li>
	<li>
%下位task ~LET
`極小task~task源$を`~task源$とする， `手続き^V を走らす新たな`~task$
— この`極小task$を指して，
`複合~極小task下位task@
という。
◎
Let subtask be a new task that consists of running the given series of steps. The task source of such a microtask is the microtask task source. This is a compound microtask subtask.
</li>
	<li>
%~loop の`現在~走っている~task$ ~SET %下位task 
◎
Set the event loop's currently running task to subtask.
</li>
	<li>
%下位task を走らす
◎
Run subtask.
</li>
	<li>
%~loop の`現在~走っている~task$ ~SET %親 
◎
Set the event loop's currently running task back to parent.
</li>
</ol>

<hr>

<p class="algo-head">
~UAは、`並列的$に走っている %~algo において，
`安定~状態を待受ける@
ときは、次の手続きを走らす`極小taskを~queueする$と同時に，
%~algo 自身の実行は いったん停止し~MUST（その実行は、下の手続きに述べるように，極小taskを走らせたとき再開される）：
◎
When an algorithm running in parallel is to await a stable state, the user agent must queue a microtask that runs the following steps, and must then stop executing (execution of the algorithm resumes when the microtask is run, as described in the following steps):
</p>

<ol>
	<li>
%~algo 内の
`同期区間@
を走らす
◎
Run the algorithm's synchronous section.
</li>
<li>
%~algo の記述にしたがって，適切になるなら、
%~algo の`並列的$な実行を再開する
◎
Resumes execution of the algorithm in parallel, if appropriate, as described in the algorithm's steps.
</li>
</ol>

<p class="note">注記：
%~algo 内の`同期区間$は、~~記号 ⌛ が付与される段として与えられる。
【が，和訳では、その~~記号に代えて，明示的な~markupによる下位手続きとして与えることもある。】
◎
Steps in synchronous sections are marked with ⌛.
</p>

<hr>

<p class="algo-head">
~algoにて，所与の条件 %目標 が満たされるまで
`~event-loopを回す@
と記されている所では、~UAは，次を走らせ~MUST：
◎
When an algorithm says to spin the event loop until a condition goal is met, the user agent must run the following steps:
</p>

<ol>
	<li>
<p>
%~task ~LET `~event-loop$の`現在~走っている~task$
◎
Let task be the event loop's currently running task.
</p>

<p class="note">注記：
これは、`極小task$の場合もある
— その事例では、`孤立~callback極小task$になる。
これは、［
`複合~極小task下位task$ ／
`極小task$でない定例の`~task$
］の場合もある。
これが`複合~極小task$になることは、<em>ない</em>。
◎
This might be a microtask, in which case it is a solitary callback microtask. It could also be a compound microtask subtask, or a regular task that is not a microtask. It will not be a compound microtask.
</p>
	</li>
	<li>
%~task源 ~LET %~task の`~task源$
◎
Let task source be task's task source.
</li>
	<li>
%旧~stack ~LET 
`~JS実行~文脈~stack$jsの複製
◎
Let old stack be a copy of the JavaScript execution context stack.
</li>
	<li>
`~JS実行~文脈~stack$jsを空にする
◎
Empty the JavaScript execution context stack.
</li>
	<li>
`極小task~checkpointを遂行する$
◎
Perform a microtask checkpoint.
</li>
	<li>
<p>
%~task を停止して，それを呼出した~algoを何であれ再開できるようにする一方で、この手続きは
【~taskを呼出した~algoと】
`並列的$に継続する
◎
Stop task, allowing whatever algorithm that invoked it to resume, but continue these steps in parallel.
</p>

<div class="note">
<p>注記：
これは、次のいずれかの~algoを継続させる：
</p>
<ul>
	<li>
`~event-loop$の~main手続き
【<a href="#event-loop-processing-model">処理~model節</a>】
</li>
	<li>
`極小task~checkpointを遂行する$
</li>
	<li>
`複合~極小task下位taskを実行する$
</li>
</ul>

◎
This causes one of the following algorithms to continue: the event loop's main set of steps, the perform a microtask checkpoint algorithm, or the execute a compound microtask subtask algorithm.
</div>

	</li>
	<li>
%目標 が満たされるまで待機する
◎
Wait until the condition goal is met.
</li>
	<li>
%継続~task ~LET 新たな何もしない`~task$
◎
↓</li>
	<li>
`~task源$ %~task源 から， %継続~task を`~queueする$
◎
Queue a task to continue running these steps, using the task source task source.＼
</li>
	<li>
%継続~task が走らされるまで待機する
◎
Wait until this new task runs before continuing these steps.
</li>
	<li>
`~JS実行~文脈~stack$jsを %旧~stack に置換する
◎
Replace the JavaScript execution context stack with the old stack.
</li>
	<li>
~RET
— ~call元へ~~制御を返す
◎
Return to the caller.
</li>
</ol>

<p class="trans-note">【
上で停止された %~task はどうなる？
（ %旧~stack に置換した時点から）自動的に再開されるのか？
】</p>

<hr>

<p class="algo-head">
歴史的~理由から、この仕様の~algoのうち一部は，`~task$ %~task が走っている間，所与の %目標 が満たされるまで、~UAに
`一時停止-@
することを要求する。
これは、次の手続きを走らすことを意味する：
◎
Some of the algorithms in this specification, for historical reasons, require the user agent to pause while running a task until a condition goal is met. This means running the following steps:
</p>

<ol>
	<li>
必要とされるなら、［
`文書$ ／ `閲覧文脈$
］の描画や~UIを，現在の状態を反映するように更新する
◎
If necessary, update the rendering or user interface of any Document or browsing context to reflect the current state.
</li>
	<li>
<p>
%目標 が満たされるまで待機する
— ~UAが %~task を`一時停止-$している間は：
</p>
		<ul>
			<li>
%~task が属している`~event-loop$は、他の`~task$を走らせては~MUST_NOT。
</li>
			<li>
`現在~走っている~task$における~script実行は、阻まれ~MUST。
</li>
			<li>
~UAは、利用者~入力に対しては即応可能であり続けるべきである
— しかしながら、`~event-loop$は何もしなくなるので，~~能力は抑制されることになる。
</li>
		</ul>
◎
Wait until the condition goal is met. While a user agent has a paused task, the corresponding event loop must not run further tasks, and any script in the currently running task must block. User agents should remain responsive to user input while paused, however, albeit in a reduced capacity since the event loop will not be doing anything.
</li>
</ol>

<div class="warning">
<p>
`一時停止-$は、とりわけ，複数の文書が単独の`~event-loop$を共有している局面では、利用者~体験をひどく~~害する。
~UAには、既存の内容との互換性を保全しつつ可能なら，`一時停止-$の別法
— `~event-loopを回す$, あるいは単純に あらゆる種類の実行を休止させずに，続行するなど —
を試験することが奨励される。
より円滑で~web互換な別法が発見されたなら、この仕様は，積極的にそれを取り入れることになる。
◎
Pausing is highly detrimental to the user experience, especially in scenarios where a single event loop is shared among multiple documents. User agents are encouraged to experiment with alternatives to pausing, such as spinning the event loop or even simply proceeding without any kind of suspended execution at all, insofar as it is possible to do so while preserving compatibility with existing content. This specification will happily change if a less-drastic alternative is discovered to be web-compatible.
</p>

<p>
実装者は、~UAが試験し得る様々な別法が，`~event-loop$の挙動の微妙な側面
— `~task$や`極小task$の時機も含め —
を変更し得ることを，当分の間は意識しておくべきである。
実装は、そうすることが `一時停止-$演算に含意される正確な意味論に違反するとしても，試験し続けるべきである。
◎
In the interim, implementers should be aware that the variety of alternatives that user agents might experiment with can change subtle aspects of event loop behavior, including task and microtask timing. Implementations should continue experimenting even if doing so causes them to violate the exact semantics implied by the pause operation.
</p>
</div>

				</section>
				<section id="generic-task-sources">
<h4 title="Generic task sources">8.1.4.3. 汎用の~task源</h4>

<p>
次に挙げる`~task源$は、［
この／他の
］仕様における，互いにほぼ無関係な，いくつもの特色機能により利用される：
◎
The following task sources are used by a number of mostly unrelated features in this and other specifications.
</p>

<dl class="def-list">
	<dt>
`~DOM操作~task源@
◎
The DOM manipulation task source
</dt>
	<dd>
この`~task源$は、 DOM 操作に反応する特色機能のために利用される
— 要素が`文書の中へ挿入-$されたときに，他を阻まずに起きるものなど。
◎
This task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is inserted into the document.
</dd>

	<dt>
`利用者対話~task源@
◎
The user interaction task source
</dt>
	<dd>
この`~task源$は、利用者対話に反応する特色機能のために利用される
— 例えば［
~keyboard／~mouse
］入力。
◎
This task source is used for features that react to user interaction, for example keyboard or mouse input.
</dd>
	<dd>
利用者~入力に呼応して送信される~event（例： `click$et ~event `UIEVENTS$r ）は、`利用者対話~task源$により`~queueされ$る`~task$を利用して発火され~MUST。
◎
Events sent in response to user input (e.g. click events) must be fired using tasks queued with the user interaction task source. [UIEVENTS]
</dd>

	<dt>
`~network用~task源@
◎
The networking task source
</dt>
	<dd>
この`~task源$は、~network活動に呼応して誘発される特色機能のために利用される。
◎
This task source is used for features that trigger in response to network activity.
</dd>

	<dt>
`履歴~走査~task源@
◎
The history traversal task source
</dt>
	<dd>
この`~task源$は、
`history.back()$m
や, それに類似する~APIへの~callを~queueするために利用される。
◎
This task source is used to queue calls to history.back() and similar APIs.
</dd>
</dl>

				</section>
				<section id="event-loop-for-spec-authors">
<h4 title="Dealing with the event loop from other specifications">8.1.4.4. 他の仕様における~event-loopの取り扱い法</h4>

<p>
`~event-loop$と正しく相互作用するように仕様を書くことは、込み入ったものにもなり得る。
これは、この仕様による，同時並行的~modelに独立な用語体系
—
“~main~thread” ／ “~background~thread上で”
の様な，その種の~modelに特有の馴染みの用語に代えて，
“`~event-loop$”, “`並列的$”
などの語 —
の~~用法により構成される。
◎
Writing specifications that correctly interact with the event loop can be tricky. This is compounded by how this specification uses concurrency-model-independent terminology, so we say things like "event loop" and "in parallel" instead of using more familiar model-specific terms like "main thread" or "on a background thread".
</p>

<p>
既定では、仕様~textは，一般に`~event-loop$上で走る。
これは、公式的な
<a href="#event-loop-processing-model">~event-loop処理~model</a>
から外へ出る
— すなわち，ほとんどの~algoは、跡を辿れば，最終的には そこへ`~queueされ$る`~task$に戻る。<!-- ＊ -->
◎
By default, specification text generally runs on the event loop. This falls out from the formal event loop processing model, in that you can eventually trace most algorithms back to a task queued there.
</p>

<p class="example">
~JS~method用のどの~algo手続きも、作者~codeがその~methodを~callすることにより，呼出されることになる。
また、作者~codeが走れるのは，~queueされた~taskを介してのみであり、通例的に，
<a href="~HEscripting#script-processing-model">`script^e 処理~model</a>
内のどこかを出自にしている。
◎
The algorithm steps for any JavaScript method will be invoked by author code calling that method. And author code can only be run via queued tasks, usually originating somewhere in the script processing model.
</p>

<p>
この出発点から上書きするときの指針は：
仕様が遂行する必要がある仕事のうち［
`並列的$に遂行しなければ`~event-loop$を阻むことになる
］ものは，何であれ そのように遂行され~MUST。
これには、少なくとも次が含まれる：
◎
From this starting point, the overriding guideline is that any work a specification needs to perform that would otherwise block the event loop must instead be performed in parallel with it. This includes (but is not limited to):
</p>

<ul>
	<li>
重い計算を遂行するとき。
◎
performing heavy computation;
</li>
	<li>
利用者に~promptを表示するとき。
◎
displaying a user-facing prompt;
</li>
	<li>
外側の~systemも孕み得る（すなわち， “~UA処理-の外へ出る” ）ような演算を遂行するとき。
◎
performing operations which could require involving outside systems (i.e. "going out of process").
</li>

</ul>

<p>
次に挙がる複雑問題は，~algoの`並列的$な区間であり、そこでは，特定の［
`~JS~realm$js ／ `大域~obj$ ／ `環境~設定群~obj$
］に結付けられた~objを 作成したり操作しては~MUST_NOT（馴染みの用語で定めるなら、~main~threadによる遺物に，~background~threadから直接的に~accessしては~MUST_NOT）。
そうすると，~JS~codeから観測-可能な~data~raceが生じることになる
— ~algoのそれ以降の手続きは、~JS~codeと<em>`並列的$</em>に走っているので。
◎
The next complication is that, in algorithm sections that are in parallel, you must not create or manipulate objects associated to a specific JavaScript realm, global, or environment settings object. (Stated in more familiar terms, you must not directly access main-thread artifacts from a background thread.) Doing so would create data races observable to JavaScript code, since after all, your algorithm steps are running in parallel to the JavaScript code.
</p>

<p>
しかしながら，仕様~levelの~data構造
— `INFRA$r にて定義されるものなど —
は、操作できる。
それらは~realmに非依存であり，~JSに直接的に公開されることは決してなく，特有の変換（ Web IDL による`変換-$xを介するものが多い）がそこを占めることはないので。
`WEBIDL$r
◎
You can, however, manipulate specification-level data structures and values from the WHATWG Infra Standard, as those are realm-agnostic. They are never directly exposed to JavaScript without a specific conversion taking place (often via Web IDL). [INFRA] [WEBIDL]
</p>

<p>
次に，観測-可能な~JS~objの世界に影響させるためには、次に従わ~MUST：
◎
To affect the world of observable JavaScript objects, then, you must＼
</p>

<ul>
	<li>
そのような操作は、それを遂行する~taskとして`~queueする$こと。
これは、当の手続きが，`~event-loop$にて起こる他の~taskの合間に適正に差挟まれることを確保する。
◎
queue a task to perform any such manipulations. This ensures your steps are properly interleaved with respect to other things happening on the event loop.＼
</li>
	<li>
加えて，`~taskを~queueする$ときは`~task源$も選ぶこと。
これは、自他の手続きの相対的な遂行-順序を統治する。
どの`~task源$を利用するか定かでない場合は、
<a href="#generic-task-sources">汎用の~task源</a>
から，最も適用できると思しきものを選ぶこと。
◎
Furthermore, you must choose a task source when queueing a task; this governs the relative order of your steps versus others. If you are unsure which task source to use, pick one of the generic task sources that sounds most applicable.
</li>
</ul>

<p>
`~taskを~queueする$ほとんどの呼出は、暗黙的に
“関連する`~event-loop$”
— すなわち，文脈から明らかなもの —
を利用する。
~algoが複数の~event-loopを孕むような文脈から呼出されることは、ごく稀にしかないので。
例えば`~worker$の操作を取り扱うような仕様を書いていない限り、この引数は，`~taskを~queueする$ときには省略できる（複数の大域~objを孕むような文脈と違って，それは あらゆるときに起きているので）。
◎
Most invocations of queue a task implicitly use "the relevant event loop", i.e., the one that is obvious from context. That is because it is very rare for algorithms to be invoked in contexts involving multiple event loops. (Unlike contexts involving multiple global objects, which happen all the time!) So unless you are writing a specification which, e.g., deals with manipulating workers, you can omit this argument when queueing a task.
</p>

<p>
以上をまとめれば、非同期に仕事する必要がある~algo用の代表的なひな形は，次のようになる：
◎
Putting this all together, we can provide a template for a typical algorithm that needs to do work asynchronously:
</p>

<ol>
	<li>
同期的に設定しておく仕事があれば，まずそれを行う
— 依然として`~event-loop$上にある間に。
これは、`~JS~realm$jsに特有の~JS値を，~realmに非依存な仕様~levelの値に
変換することも含み得る。
◎
Do any synchronous setup work, while still on the event loop. This may include converting realm-specific JavaScript values into realm-agnostic specification-level values.
</li>
	<li>
高価にもなり得る，次を行うような一連の段を、`並列的$に遂行する
⇒
~realmにまったく非依存な値に演算して，~realmに非依存な結果を生産する
◎
Perform a set of potentially-expensive steps in parallel, operating entirely on realm-agnostic values, and producing a realm-agnostic result.
</li>
	<li>
指定された`~task源$から，次を走らす`~taskを~queueする$
⇒
~realmに非依存な結果を変換して、`~event-loop$上の，~JS~objが成す観測-可能な世界における観測-可能な効果に戻す
◎
Queue a task, on a specified task source, to convert the realm-agnostic result back into observable effects on the observable world of JavaScript objects on the event loop.
</li>
</ol>

<div id="example-event-loop-using-algorithm" class="example">

<p>
渡された［
一連の`~scalar値~文字列$からなる`~list$
］ %入力 を，~URLとして構文解析した上で “暗号化する” ~algoの例：
◎
The following is an algorithm that "encrypts" a passed-in list of scalar value strings input, after parsing them as URLs:
</p>

<ol>
	<li>
%~url~list ~LET 空`~list$
◎
Let urls be an empty list.
</li>
	<li>
<p>
%入力 内の `~EACH$( %文字列 ) に対し：
◎
For each string of input:
</p>
		<ol>
			<li>
%解析形 ~LET %文字列 を`現在の設定群~obj$に`相対的に構文解析-$した結果
◎
Let parsed be the result of parsing string relative to the current settings object.
</li>
			<li>
IF［
%解析形 ~EQ `失敗^i
］
⇒
~RET `SyntaxError$E 例外で却下される~promise
◎
If parsed is failure, return a promise rejected with a "SyntaxError" DOMException.
</li>
			<li>
%直列形 ~LET `~URLを直列化する$( %解析形 )
◎
Let serialized be the result of applying the URL serializer to parsed.
</li>
			<li>
%~url~list に %直列形 を`付加する$
◎
Append serialized to urls.
</li>
		</ol>
	</li>
	<li>
%~realm ~LET `現在の~JS~realm$js
◎
Let realm be the current Realm Record.
</li>
	<li>
%p ~LET 新たな~promise
◎
Let p be a new promise.
</li>
	<li>
<p>
次の手続きは`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%暗号形~URL~list ~LET 空`~list$
◎
Let encryptedURLs be an empty list.
</li>
			<li>
<p>
%~url~list 内の `~EACH$( %~url ) に対し：
◎
For each url of urls:
</p>
				<ol>
					<li>
100 ~milli秒間~待機する
— 暗号化の重い計算は、その間に行われるとする。
◎
Wait 100 milliseconds, so that people think we're doing heavy-duty encryption.
</li>
					<li>
%暗号形 ~LET 前~段の間に %~url から導出された新たな`~JS文字列$
<!-- whose nth code unit is equal to url's nth code unit plus 13 -->
◎
Let encrypted be a new JavaScript string derived from url, whose nth code unit is equal to url's nth code unit plus 13.
</li>
					<li>
%暗号形~URL~list に %暗号形 を`付加する$
◎
Append encrypted to encryptedURLs.
</li>
				</ol>
			</li>
			<li>
<p>
`~network用~task源$から，次の手続きを遂行する`~taskを~queueする$：
◎
Queue a task, on the networking task source, to perform the following steps:
</p>

				<ol>
					<li>
%配列 ~LET %暗号形~URL~list を
%~realm 内の~JS配列に`変換-$xした結果
◎
Let array be the result of converting encryptedURLs to a JavaScript array, in realm.
</li>
					<li>
%配列 で %p を解決する
◎
Resolve p with array.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>

<p>
この~algoには、注目すべき点がいくつかある：
◎
Here are several things to notice about this algorithm:
</p>

<ul>
	<li>
前もって，`~event-loop$上で~URLの構文解析を行っている
— `並列的$な手続きに入る前に。
これが必要とされるのは、構文解析が依存している`現在の設定群~obj$は，`並列的$に行った後における`現在の設定群~obj$ではなくなるためである。
◎
It does its URL parsing up front, on the event loop, before going to the in parallel steps. This is necessary, since parsing depends on the current settings object, which would no longer be current after going in parallel.
</li>
	<li>
別法として、`現在の設定群~obj$の`~API用~基底~URL$enVへの参照を保存してから，`並列的$な手続きの間にそれを利用しても等価になる。
しかしながら，上の例が行なっているように、前もって可能な限り多くの仕事を行うことが推奨される。
正しい値を保存しようと試みるのは、誤りを導き易くなりがちなので
— 例えば、`~API用~基底~URL$enVに代えて，単に`現在の設定群~obj$を保存した場合、~raceが生じ得ることになる。
◎
Alternately, it could have saved a reference to the current settings object's API base URL and used it during the in parallel steps; that would have been equivalent. However, we recommend instead doing as much work as possible up front, as this example does. Attempting to save the correct values can be error prone; for example, if we'd saved just the current settings object, instead of its API base URL, there would have been a potential race.
</li>
	<li>
`~JS文字列$の`~list$を、初期~手続きから`並列的$な手続きに暗黙的に渡している。
`~list$, `~JS文字列$とも，`~JS~realm$jsには非依存なので、そうしても~~問題ない。
◎
It implicitly passes a list of JavaScript strings from the initial steps to the in parallel steps. This is OK, as both lists and JavaScript strings are realm-agnostic.
</li>
	<li>
“高価な計算” は、`並列的$な手続きの間に遂行している（入力~URLごとに 100~milli秒間~待機して）
— したがって~main`~event-loop$は阻んでいない。
◎
It performs "expensive computation" (waiting for 100 milliseconds per input URL) during the in parallel steps, thus not blocking the main event loop.
</li>
	<li>
`並列的$な手続きの間は、決して，観測-可能な~JS~objとしての~promiseを［
作成-／操作-
］していない。
%p は，その手続きに入る前に作成され、当の目的で特に`~queueされ$た`~task$の中で操作されている。
◎
Promises, as observable JavaScript objects, are never created and manipulated during the in parallel steps. p is created before entering those steps, and then is manipulated during a task that is queued specifically for that purpose.
</li>
	<li>
~JS配列~objの作成は，~queueされた~taskの中で行われ、その配列を どの~realm内に作成するかも注意深く指定している
— ~realmはもはや、文脈からは明らかでないので。
◎
The creation of a JavaScript array object also happens during the queued task, and is careful to specify which realm it creates the array in since that is no longer obvious from context.
</li>
</ul>

<p>
（最後の 2 点については、
<a href="https://github.com/w3ctag/promises-guide/issues/52">w3ctag/promises-guide#52</a>,
<a href="https://github.com/heycam/webidl/issues/135">heycam/webidl#135</a>,
<a href="https://github.com/heycam/webidl/issues/371">heycam/webidl#371</a>
も見よ
— 上述した~promiseの解決~patternの細部については、依然として思案中にある）
◎
(On these last two points, see also w3ctag/promises-guide#52, heycam/webidl#135, and heycam/webidl#371, where we are still mulling over the subtleties of the above promise-resolution pattern.)
</p>

<p>
上とは別に、この~algoが［
~IDL <code>sequence&lt;`USVString$&gt;</code> 型~値を入力にとるような，~Web~IDLにより指定される演算
］から~callされるときには、［
作者から入力として提供された`~JS~realm$jsに特有の~JS~obj
］から［
~realmに非依存な <code>sequence&lt;`USVString$&gt;</code> 型
］への自動的な変換もあることに注意。
それは、入力を［
一連の`~scalar値~文字列$からなる`~list$
］として扱うことになる。
なので、当の仕様の構造に依存して，［
~main`~event-loop$上で起こり，`並列的$に走らすに準備済みにする処理-の一部を担うような，暗黙的な他の手続き
］もあり得る。
◎
Another thing to note is that, in the event this algorithm was called from a Web IDL-specified operation taking a sequence&lt;USVString&gt;, there was an automatic conversion from realm-specific JavaScript objects provided by the author as input, into the realm-agnostic sequence&lt;USVString&gt; Web IDL type, which we then treat as a list of scalar value strings. So depending on how your specification is structured, there may be other implicit steps happening on the main event loop that play a part in this whole process of getting you ready to go in parallel.
</p>

  </div>
				</section>
			</section>
			<section id="events">
<h3 title="Events">8.1.5. ~event</h3>

				<section id="event-handler-attributes">
<h4 title="Event handlers">8.1.5.1. ~event~handler</h4>

<p>
多くの~objには
`~event~handler@
が指定され得る。
これらは、指定された~objに対する，非~capture~event~listenerとして動作する。
`DOM$r
◎
Many objects can have event handlers specified. These act as non-capture event listeners for the object on which they are specified. [DOM]
</p>

<p>
`~event~handler$の名前は、常に `on^l から開始し，~handlerに意図される~event名が後続する。
◎
An event handler has a name, which always starts with "on" and is followed by the name of the event for which it is intended.
</p>

<p>
`~event~handler$の値は［
~NULL,
~callback~obj,
`内部的な生の未compileの~handler$
］いずれかをとる。
`EventHandler$I ~callback関数~型は、これが~scriptに どう公開されるかを述べる。
初期~時には、 `~event~handler$の値は~NULLに設定され~MUST。
◎
An event handler has a value, which is either null, or is a callback object, or is an internal raw uncompiled handler. The EventHandler callback function type describes how this is exposed to scripts. Initially, an event handler's value must be set to null.
</p>

<p>
各~event~handlerは、次の 2 通りの仕方で公開される：
◎
Event handlers are exposed in one of two ways.
</p>

<ul>
	<li>
`~event~handler~IDL属性$として：
この仕方は、すべての~event~handlerに共通する。
◎
The first way, common to all event handlers, is as an event handler IDL attribute.
</li>
	<li>
`~event~handler内容~属性$として：
［
`~HTML要素$ ／ `~window$
］上の~event~handlerのうち一部は、この仕方でも公開される。
◎
The second way is as an event handler content attribute. Event handlers on HTML elements and some of the event handlers on Window objects are exposed in this way.
</li>
</ul>

<hr>

<p>
`~event~handler~IDL属性@
は、~obj上の特定の`~event~handler$に対応する，同じ~obj上の~IDL属性である。
その名前は、`~event~handler$の名前と同じである。
◎
An event handler IDL attribute is an IDL attribute for a specific event handler. The name of the IDL attribute is the same as the name of the event handler.
</p>

<p class="algo-head">
`~event~handler~IDL属性$は：
◎
Event handler IDL attributes,＼
</p>

<ul>
	<li>
設定子は、次を走らせ~MUST
⇒
属性に対応している`~event~handler$ ~SET 所与の値
◎
on setting, must set the corresponding event handler to their new value, and＼
</li>
	<li>
取得子は、次を走らせ~MUST
⇒
~RET `~event~handlerの現在の値を取得する$( 属性に対応している`~event~handler$ )
◎
on getting, must return the result of getting the current value of the event handler in question.
</li>
</ul>

<p class="algo-head">
`~event~handler~IDL属性$が、存在しない~objの`~event~handler$を公開する場合：
◎
If an event handler IDL attribute exposes an event handler of an object that doesn't exist,＼
</p>

<ul>
	<li>
取得子は、常に~NULLを返さ~MUST。
◎
it must always return null on getting and＼
</li>
	<li>
設定子は、何もしては~MUST_NOT。
◎
must do nothing on setting.
</li>
</ul>

<p class="note">注記：
これは特に、対応している`~window$を有さない `body$e 要素~上の`~event~handler~IDL属性$に起こり得る。
【~windowのそれを反映する~IDL属性】
◎
This can happen in particular for event handler IDL attribute on body elements that do not have corresponding Window objects.
</p>

<p class="note">注記：
ある種の~event~handler~IDL属性には追加の要件がある
— 特に `MessagePort$I ~objの `onmessage$m 属性。
◎
Certain event handler IDL attributes have additional requirements, in particular the onmessage attribute of MessagePort objects.
</p>

<hr>

<p>
`~event~handler内容~属性@
は、~obj上の特定の`~event~handler$に対応する，同じ~obj上の内容~属性である。
その名前は、`~event~handler$の名前と同じである。
◎
An event handler content attribute is a content attribute for a specific event handler. The name of the content attribute is the same as the name of the event handler.
</p>

<p>
`~event~handler内容~属性$に指定する値は、［
`自動的~semicolon挿入$js後に，
`FunctionBody$jA 生成規則に合致するように構文解析される
］ような，妥当な~JS~codeを包含してい~MUST。
◎
Event handler content attributes, when specified, must contain valid JavaScript code which, when parsed, would match the FunctionBody production after automatic semicolon insertion.
</p>

<p class="algo-head">
`~event~handler内容~属性$ %属性 の設定子は、次の手続きを実行する：
◎
When an event handler content attribute is set, execute the following steps:
</p>

<ol>
	<li>
~IF［［
( %属性 を有している`要素$, `script attribute^l, 所与の値 )
を与える下で，
<a href="~CSP3#should-block-inline">要素の~inline型の挙動は~CSPにより阻止されるべきか？</a>
`CSP$r を実行した結果
］ ~EQ `阻止ed^i
］
⇒
~RET
◎
If the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "script attribute", and the attribute's value, then return. [CSP]
</li>
	<li>
対応している`~event~handler$ ~SET
次の組からなる，`内部的な生の未compileの~handler$
⇒＃
~script本体： %属性 に対する新たな値；
~script本体の所在： %属性 がこの値に設定された場所
◎
Set the corresponding event handler to an internal raw uncompiled handler consisting of the attribute's new value and the script location where the attribute was set to this value
</li>
</ol>

<p class="algo-head">
`~event~handler内容~属性$の除去-時には、~UAは，対応している`~event~handler$を~NULLに設定し~MUST。
◎
When an event handler content attribute is removed, the user agent must set the corresponding event handler to null.
</p>

<hr>

<div class="p">

<p class="algo-head">
`EventTarget$I ~interfaceを実装している要素または~obj %T 上の`~event~handler$ %H が，最初に非 ~NULL 値に設定されるときは、~UAは、
%T に結付けられている［
`~event~listener$の~list
］に，次の組からなる`~event~listener$を付加し~MUST：
</p>

<ul>
	<li>
`type^i ： %H に対応する
`~event~handler~event型@
</li>
	<li>
`callback^i ： ［
1 個の引数をとる関数であって、
%H, およびその引数を与える下で，`~event~handler処理~algo$を実行するもの
］への参照を表現している，~Web~IDL `EventListener$I ~instanceを作成した結果
</li>
</ul>

<p>
`EventListener$I の`~callback文脈$は、任意のものをとれる
— それは `~event~handler処理~algo$には影響0しない。
`DOM$r
</p>
◎
When an event handler H of an element or object T implementing the EventTarget interface is first set to a non-null value, the user agent must append an event listener to the list of event listeners associated with T with type set to the event handler event type corresponding to H and callback set to the result of creating a Web IDL EventListener instance representing a reference to a function of one argument that executes the steps of the event handler processing algorithm, given H and its argument. The EventListener's callback context can be arbitrary; it does not impact the steps of the event handler processing algorithm. [DOM]
</div>

<p class="note">注記：
`callback^i は、 %H 自身<em>ではない</em>ことに注意。
どの`~event~handler$も、同じ `~callback^i 
— すなわち，下に定義される~algo —
を登録する結果になる。
その~algoが、~~正しい~callbackを呼出すこと, および
その~callbackが返す値の処理を受け持つ。
◎
The callback is emphatically not the event handler itself. Every event handler ends up registering the same callback, the algorithm defined below, which takes care of invoking the right callback, and processing the callback's return value.
</p>

<div class="note">
<p>注記：
~event~listenerの付加-が起こるのは、 %H の値が初回に設定されるときに限られる。
~listenerたちは、登録-順に~callされるので、 %T 上の特定0の~event型に対する~event~listenerたちは，常に次の順序で~callされる：
</p>

<ol>
	<li>
%H が最初に非 ~NULL 値に設定される前に，
%T 上の `addEventListener()$m で登録された~listenerたち
</li>
	<li>
現在， %H に設定されている~callbackがあれば，その~listener
</li>
	<li>
%H が最初に非 ~NULL 値に設定された<em>後に</em>，
%T 上の `addEventListener()$m で登録された~listenerたち
</li>
</ol>

◎
This only happens the first time the event handler's value is set. Since listeners are called in the order they were registered, the order of event listeners for a particular event type will always be first the event listeners registered with addEventListener() before the first time the event handler was set to a non-null value, then the callback to which it is currently set, if any, and finally the event listeners registered with addEventListener() after the first time the event handler was set to a non-null value.
</div>

<div class="example">

<p>
~event~listenerが呼出される順序を，次の~codeで例証する。
利用者がこの例の~buttonを~clickしたとき、頁は，順に~text［
`一^l, `二^l, `三^l, `四^l
］を伴う 4 回の~alertを示すことになる。
◎
This example demonstrates the order in which event listeners are invoked. If the button in this example is clicked by the user, the page will show four alerts, with the text "ONE", "TWO", "THREE", and "FOUR" respectively.
</p>

<pre>
&lt;button id="test"&gt;Start Demo&lt;/button&gt;
&lt;script&gt;
  var %button = document.getElementById('test');
  %button.addEventListener(
    'click', function(){ alert('一') }, false
  );
  %button.setAttribute(
    'onclick', "alert('この~alertは呼ばれない')"
  ); /* <span class="comment">
~event~handler~listenerはこの時点で登録される。
◎
event handler listener is registered here</span> */

  %button.addEventListener(
    'click', function(){ alert('三') }, false
  );
  %button.onclick = function(){ alert('二'); };
  %button.addEventListener(
    'click', function(){ alert('四') }, false
  );
&lt;/script&gt;
</pre>

</div>

<p class="note">注記：
~event~objが実装する~interfaceは、`~event~handler$が誘発されるかどうかには波及しない。
◎
The interfaces implemented by the event object do not influence whether an event handler is triggered or not.
</p>

<p class="algo-head">
`~event~handler処理~algo@
は、所与の (
`~event~handler$ %H ,
`Event$I ~obj %E
) に対し，次を走らす：
◎
The event handler processing algorithm for an event handler H and an Event object E is as follows:
</p>

<ol>
	<li>
%~callback ~LET `~event~handlerの現在の値を取得する$( %H )
◎
Let callback be the result of getting the current value of the event handler H.
</li>
	<li>
~IF［
%~callback ~EQ ~NULL
］
⇒
~RET
◎
If callback is null, then return.
</li>
	<li>
`特別~error~event取扱い^V ~LET ［［
%E は `ErrorEvent$I ~objである
］~AND［
%E の `type$m ~EQ `error$et
］~AND［
%E の `currentTarget$m は
`WindowOrWorkerGlobalScope$I ~mixinを実装する
］ならば ~T ／
~ELSE_ ~F
］
◎
Let special error event handling be true if E is an ErrorEvent object, E's type is error, and E's currentTarget implements the WindowOrWorkerGlobalScope mixin. Otherwise, let special error event handling be false.
</li>
	<li>
<p>
%返値 ~LET `~callback関数を呼出す$(
%~callback, 
次に与える引数~list,
%E の`currentTarget$m （`~callback this 値$）
)
⇒
引数~listは `特別~error~event取扱い^V に応じて
⇒
~F ならば %E のみ ／
~T ならば 順に %E の (
`message$m,
`filename$m,
`lineno$m,
`colno$m,
`error$m
)
属性~値
◎
Process the Event object E as follows:
◎
If special error event handling is true
• Invoke callback with five arguments, the first one having the value of E's message attribute, the second having the value of E's filename attribute, the third having the value of E's lineno attribute, the fourth having the value of E's colno attribute, the fifth having the value of E's error attribute, and with the callback this value set to E's currentTarget. Let return value be the callback's return value. [WEBIDL]
◎
Otherwise
• Invoke callback with one argument, the value of which is the Event object E, with the callback this value set to E's currentTarget. Let return value be the callback's return value. [WEBIDL]
</p>

<p>
%~callback から例外が投出されたときは、そのまま伝播させるとする（したがって、この手続きも終える）。
（例外は、
<a href="~DOM4#concept-event-listener-invoke">DOM ~event配送-~logic</a>
へ伝播し，その`例外を報告する$ことになる。）
◎
If an exception gets thrown by the callback, end these steps and allow the exception to propagate. (It will propagate to the DOM event dispatch logic, which will then report the exception.)
</p>

	</li>
	<li>
<p>
~IF［
%E は `BeforeUnloadEvent$I ~objである
］~AND［
%E の `type$m ~EQ `beforeunload$et
］：
◎
Process return value as follows:
◎
If E is a BeforeUnloadEvent object and E's type is beforeunload
</p>

<p class="note">注記：
この事例では、`~event~handler~IDL属性$の型は `OnBeforeUnloadEventHandler$I 型になるので、
%返値 は［
~NULL または `DOMString^I
］型に型強制されることになる。
◎
In this case, the event handler IDL attribute's type will be OnBeforeUnloadEventHandler, so return value will have been coerced into either null or a DOMString.
</p>
		<ol>
			<li>
~IF［
%返値 ~EQ ~NULL
］
⇒
~RET
◎
If return value is not null, then:
</li>
			<li>
%E の`取消ed~flag$ ~SET ~ON
◎
Set E's canceled flag.
</li>
			<li>
~IF［
%E の `returnValue$m 属性~値 ~EQ 空~文字列
］
⇒
%E の `returnValue$m 属性~値 ~SET %返値
◎
If E's returnValue attribute's value is the empty string, then set E's returnValue attribute's value to return value.
</li>
		</ol>
	</li>
	<li>
~ELIF［
`特別~error~event取扱い^V ~EQ ~T
］
⇒
~IF［
%返値 ~EQ ~T
］
⇒
%E の`取消ed~flag$ ~SET ~ON
◎
If special error event handling is true
• If return value is true, then set E's canceled flag.
	</li>
	<li>
<p>
~ELIF［
%返値 ~EQ ~F
］
⇒
%E の`取消ed~flag$ ~SET ~ON
◎
Otherwise
• If return value is false, then set E's canceled flag.
</p>

<p class="note">注記：
［
%E の `type$m ~EQ `beforeunload$et 
］だが［
%E は `BeforeUnloadEvent$I ~objでない
］がため，この段に来た場合、 %返値 は決して ~F にならない
— すでに［
~NULL または `DOMString^I
］型に型強制されているので。
◎
If we've gotten to this "Otherwise" clause because E's type is beforeunload but E is not a BeforeUnloadEvent object, then return value will never be false, since in such cases return value will have been coerced into either null or a DOMString.
</p>

   </li>
</ol>

<hr>

<p>
`EventHandler$I ~callback関数~型は、~event~handlerに利用される~callbackを表現する。
それは、次の~WebIDLで表現される：
◎
The EventHandler callback function type represents a callback used for event handlers. It is represented in Web IDL as follows:
</p>

<pre class="idl">
[TreatNonObjectAsNull]
callback `EventHandlerNonNull@I = any (`Event$I event);
typedef `EventHandlerNonNull$I? `EventHandler@I;
</pre>

<p class="note">注記：
~JSにおいては、どの `Function$I ~objもこの~interfaceを実装する。
◎
In JavaScript, any Function object implements this interface.
</p>

<div class="example">

<p>
例えば、次の文書~片で：
◎
For example, the following document fragment:
</p>

<pre>
&lt;body onload="alert(this)" onclick="alert(this)"&gt;
</pre>

<p>
文書が読込まれたときは
`[object Window]^l
が~alertされ、利用者が頁~内のどこかを~clickしたなら
`[object HTMLBodyElement]^l
が~alertされる。
◎
...leads to an alert saying "[object Window]" when the document is loaded, and an alert saying "[object HTMLBodyElement]" whenever the user clicks something in the page.
</p>

</div>

<div class="note">

<p>注記：
関数の返値は，~eventが取消されるかどうかに影響する
— 上で述べたように、返値 ~EQ ~F の場合，~eventは取消される。
◎
The return value of the function affects whether the event is canceled or not: as described above, if the return value is false, the event is canceled.
</p>

<p>
歴史的~理由から、~platformには 2 つの例外がある
◎
There are two exceptions in the platform, for historical reasons:
</p>

<ul>
	<li>
大域~obj上の `onerror$hd ~handlerは、
`true^jv を返した場合に~eventを取消すことになる。
◎
The onerror handlers on global objects, where returning true cancels the event
</li>
	<li>
`onbeforeunload$hd ~handlerは、
`null^jv でも `undefined^jv でもない値を返した場合に~eventを取消すことになる。
◎
The onbeforeunload handler, where returning any non-null and non-undefined value will cancel the event.
</li>
	</ul>
</div>

<p>
歴史的~理由から、
`onerror$hd ~handlerは，異なる引数をとる:
◎
For historical reasons, the onerror handler has different arguments:
</p>

<pre class="idl">
[TreatNonObjectAsNull]
callback `OnErrorEventHandlerNonNull@I = any (
    (`Event$I or DOMString) %event,
    optional DOMString %source,
    optional unsigned long %lineno,
    optional unsigned long %colno,
    optional any %error
);
typedef `OnErrorEventHandlerNonNull$I? `OnErrorEventHandler@I;
</pre>

<div class="example">
<pre>
window.onerror = (message, source, lineno, colno, error) =&gt; { … };
</pre>
</div>

<p>
同様に、
`onbeforeunload$hd ~handlerは，異なる値を返す：
◎
Similarly, the onbeforeunload handler has a different return value:
</p>

<pre class="idl">
[TreatNonObjectAsNull]
callback `OnBeforeUnloadEventHandlerNonNull@I = DOMString? (`Event$I %event);
typedef `OnBeforeUnloadEventHandlerNonNull$I? `OnBeforeUnloadEventHandler@I;
</pre>
<hr>

<p>
`内部的な生の未compileの~handler@
は、次の情報の組である：
◎
An internal raw uncompiled handler is a tuple with the following information:
</p>

<ul>
	<li>
未compileの~script本体
◎
An uncompiled script body
</li>
	<li>
~script本体が出自にしている所在
— ~errorを報告する必要がある場合に限り。
◎
A location where the script body originated, in case an error needs to be reported
</li>
</ul>

<p class="algo-head">
~UAは
`~event~handlerの現在の値を取得する@
ときは、所与の
( `~event~handler$ %H )
に対し，次を走らせ~MUST：
◎
When the user agent is to get the current value of the event handler H, it must run these steps:
</p>

<ol>
	<li>
~IF［
%H の値は、`内部的な生の未compileの~handler$でない
］
⇒
~RET %H の値
◎
If H's value is an internal raw uncompiled handler, run these substeps:
</li>
	<li>
<p>
( %要素, %文書 ) ~LET %H に応じて：
</p>
		<dl class="switch">
			<dt>ある要素 %E の`~event~handler$である</dt>
			<dd>
( %E, %E の`~node文書$ )
</dd>

			<dt>ある`~window$ %W の`~event~handler$である</dt>
			<dd>
( ~NULL, %W に`結付けられている文書$ )
</dd>
			</dl>
◎
If H is an element's event handler, then let element be the element, and document be the element's node document.
◎
Otherwise, H is a Window object's event handler: let element be null, and let document be H's associated Document.
</li>
	<li>
~IF［
%文書 に対する`~scriptingは不能化されて$いる
］
⇒
~RET ~NULL
◎
If scripting is disabled for document, then return null.
</li>
	<li>
%~script ~LET %H の値
◎
↓</li>
	<li>
%本体 ~LET %~script の未compileの~script本体
◎
Let body be the uncompiled script body in the internal raw uncompiled handler.
</li>
	<li>
%所在 ~LET %~script の~script本体が出自にしている所在
◎
Let location be the location where the script body originated, as given by the internal raw uncompiled handler.
</li>
	<li>
%~form所有者 ~LET ~NULL
◎
↓</li>
	<li>
~IF［
%要素 ~NEQ ~NULL 
］~AND［
%要素 には`~form所有者$ %F がある
］
⇒
%~form所有者 ~LET %F
◎
If element is not null and element has a form owner, let form owner be that form owner. Otherwise, let form owner be null.
</li>
	<li>
%設定群~obj ~LET %文書 に`関連する設定群~obj$
◎
Let settings object be the relevant settings object of document.
</li>
	<li>
<p>
~IF［
%本体 は `FunctionBody$jA として構文解析できない
］~OR［
構文解析-時に`早期の~error$jsが検出された
］：
◎
If body is not parsable as FunctionBody or if parsing detects an early error, then follow these substeps:
</p>

		<ol>
			<li>
%H の値 ~SET ~NULL
◎
Set H's value to null.
</li>
			<li>
次を与える下で，`~errorを報告する$
⇒＃
~script： 適切な `~script$ 【？】
問題箇所： %所在 における適切な問題箇所 ( 行番号, 列番号 )
標的： %設定群~obj の`大域~obj$enV
◎
Report the error for the appropriate script and with the appropriate position (line number and column number) given by location, using settings object's global object.＼
</li>
			<li>
~IF［
~errorの`取扱済み~flag$err ~EQ ~OFF
］
⇒
~UAは、開発者~consoleに~errorを報告してよい
◎
If the error is still not handled after this, then the error may be reported to a developer console.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
%strict ~LET［［
%本体 は［
`Use Strict Directive$js を包含する `Directive Prologue$js
］から始まる
］ならば ~T ／
~ELSE_ ~F
］
◎
If body begins with a Directive Prologue that contains a Use Strict Directive then let strict be true, otherwise let strict be false.
</li>
	<li>
<p>
`~JS実行~文脈~stack$jsに［
%設定群~obj の`~realm実行~文脈$enV
］を~pushする
— それが，現在 `走っている~JS実行~文脈$jsになる
◎
Push settings object's realm execution context onto the JavaScript execution context stack; it is now the running JavaScript execution context.
</p>

<p class="note">
これは、後の `FunctionCreate$jA の呼出が正しい`~JS~realm$jsに属するようにするため，必要とされる。
◎
This is necessary so the subsequent invocation of FunctionCreate takes place in the correct JavaScript Realm.
</p>

	</li>
	<li>
<p>
%関数 ~LET 次を引数に `FunctionCreate$jA を~callした結果：
◎
Let function be the result of calling FunctionCreate, with arguments:
</p>
		<dl>
			<dt>%kind</dt>
			<dd>Normal</dd>

			<dt>%ParameterList</dt>
			<dd>
				<dl class="switch">
					<dt>
%H は`~window$の `onerror$hd `~event~handler$である場合：
◎
If H is an onerror event handler of a Window object
</dt>
					<dd>
%関数 は、次に与える名前の 5 個の引数をとる
⇒
(
`event^c,
`source^c,
`lineno^c,
`colno^c,
`error^c
)
◎
Let the function have five arguments, named event, source, lineno, colno, and error.
</dd>

					<dt>
他の場合：
◎
Otherwise
</dt>
					<dd>
%関数 は、単独の引数
( `event^c )
をとる
◎
Let the function have a single argument called event.
</dd>
				</dl>
			</dd>

			<dt>%Body</dt>
			<dd>
%本体 を構文解析した結果
◎
The result of parsing body above.
</dd>

			<dt>%Scope</dt>
			<dd>
				<ol>
					<li>
~IF［
%H は要素の`~event~handler$である
］
⇒
%Scope ~LET
`NewObjectEnvironment$jA( %文書, %大域~環境 )
◎
If H is an element's event handler, then let Scope be NewObjectEnvironment(document, the global environment).
</li>
					<li>
~ELSE （すなわち %H は`~window$の`~event~handler$である）
⇒
%Scope ~LET %大域~環境
◎
Otherwise, H is a Window object's event handler: let Scope be the global environment.
</li>
					<li>
~IF［
%~form所有者 ~NEQ ~NULL
］
⇒
%Scope ~SET `NewObjectEnvironment$jA(%~form所有者, %Scope )
◎
If form owner is not null, let Scope be NewObjectEnvironment(form owner, Scope).
</li>
					<li>
~IF［
%要素 ~NEQ ~NULL
］
⇒
%Scope ~SET `NewObjectEnvironment$jA( %要素, %Scope )
◎
If element is not null, let Scope be NewObjectEnvironment(element, Scope).
</li>
				</ol>
			</dd>

			<dt>%Strict</dt>
			<dd>
%strict
◎
The value of strict.
</dd>
		</dl>
	</li>
	<li>
%設定群~obj の`~realm実行~文脈$enVを，`~JS実行~文脈~stack$jsから除去する
◎
Remove settings object's realm execution context from the JavaScript execution context stack.
</li>
	<li>
%H の値 ~SET 次のようにされた~Web~IDL~callback関数を作成した結果
⇒＃
その~obj参照 ~SET %関数,
その`~callback文脈$ ~SET %設定群~obj
◎
Set H's value to the result of creating a Web IDL callback function whose object reference is function and whose callback context is settings object.
</li>
	<li>
~RET %H の値
◎
Return H's value.
</li>
</ol>

				</section>
				<section id="event-handlers-on-elements,-document-objects,-and-window-objects">
<h4 title="Event handlers on elements, Document objects, and Window objects">8.1.5.2. ［ 要素 ／ 文書 ／ ~window ］上の各種~event~handler</h4>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`~HTML要素$においては、［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］の両者として，~supportされ~MUST。
</li>
	<li>
［
`文書$ ／ `~window$
］においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements, as both event handler content attributes and event handler IDL attributes; and that must be supported by all Document and Window objects, as event handler IDL attributes:
</div>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onabort@hd
<td>`abort$et
<tr><td>`onauxclick@hd
<td>`auxclick$et
<tr><td>`oncancel@hd
<td>`cancel$et
<tr><td>`oncanplay@hd
<td>`canplay$et
<tr><td>`oncanplaythrough@hd
<td>`canplaythrough$et
<tr><td>`onchange@hd
<td>`change$et 
<tr><td>`onclick@hd
<td>`click$et 
<tr><td>`onclose@hd
<td>`close$et 
<tr><td>`oncontextmenu@hd
<td>`contextmenu$et 
<tr><td>`oncuechange@hd
<td>`cuechange$et
<tr><td>`ondblclick@hd
<td>`dblclick$et 
<tr><td>`ondrag@hd
<td>`drag$et
<tr><td>`ondragend@hd
<td>`dragend$et
<tr><td>`ondragenter@hd
<td>`dragenter$et
<tr><td>`ondragexit@hd
<td>`dragexit$et
<tr><td>`ondragleave@hd
<td>`dragleave$et
<tr><td>`ondragover@hd
<td>`dragover$et
<tr><td>`ondragstart@hd
<td>`dragstart$et 
<tr><td>`ondrop@hd
<td>`drop$et
<tr><td>`ondurationchange@hd
<td>`durationchange$et
<tr><td>`onemptied@hd
<td>`emptied$et
<tr><td>`onended@hd
<td>`ended$et
<tr><td>`oninput@hd
<td>`input$et
<tr><td>`oninvalid@hd
<td>`invalid$et
<tr><td>`onkeydown@hd
<td>`keydown$et 
<tr><td>`onkeypress@hd
<td>`keypress$et 
<tr><td>`onkeyup@hd
<td>`keyup$et 
<tr><td>`onloadeddata@hd
<td>`loadeddata$et
<tr><td>`onloadedmetadata@hd
<td>`loadedmetadata$et
<tr><td>`onloadend@hd
<td>`loadend$et
<tr><td>`onloadstart@hd
<td>`loadstart$et
<tr><td>`onmousedown@hd
<td>`mousedown$et 
<tr><td>`onmouseenter@hd
<td>`mouseenter$et 
<tr><td>`onmouseleave@hd
<td>`mouseleave$et 
<tr><td>`onmousemove@hd
<td>`mousemove$et 
<tr><td>`onmouseout@hd
<td>`mouseout$et 
<tr><td>`onmouseover@hd
<td>`mouseover$et 
<tr><td>`onmouseup@hd
<td>`mouseup$et 
<tr><td>`onwheel@hd
<td>`wheel$et 
<tr><td>`onpause@hd
<td>`pause$et
<tr><td>`onplay@hd
<td>`play$et
<tr><td>`onplaying@hd
<td>`playing$et
<tr><td>`onprogress@hd
<td>`progress$et
<tr><td>`onratechange@hd
<td>`ratechange$et
<tr><td>`onreset@hd
<td>`reset$et
<tr><td>`onsecuritypolicyviolation@hd
<td>`securitypolicyviolation$et
<tr><td>`onseeked@hd
<td>`seeked$et
<tr><td>`onseeking@hd
<td>`seeking$et
<tr><td>`onselect@hd
<td>`select$et  
<tr><td>`onstalled@hd
<td>`stalled$et
<tr><td>`onsubmit@hd
<td>`submit$et 
<tr><td>`onsuspend@hd
<td>`suspend$et
<tr><td>`ontimeupdate@hd
<td>`timeupdate$et
<tr><td>`ontoggle@hd
<td>`toggle$et
<tr><td>`onvolumechange@hd
<td>`volumechange$et
<tr><td>`onwaiting@hd
<td>`waiting$et

</tbody></table>

<hr>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
［
`body$e, `frameset$e
］要素を除く `~HTML要素$においては、［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］の両者として，~supportされ~MUST。
</li>
	<li>
`文書$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
	<li>
`~window$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
	<li>
前項に対応する［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］が、当の`~window$に`結付けられている文書$が所有する［
`body$e ／ `frameset$e
］要素において公開され~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements other than body and frameset elements, as both event handler content attributes and event handler IDL attributes; that must be supported by all Document objects, as event handler IDL attributes; and that must be supported by all Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler content attributes and event handler IDL attributes exposed on all body and frameset elements that are owned by that Window object's associated Document:
</div>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onblur@hd
<td>`blur$et 
<tr><td>`onerror@hd
<td>`error$et
<tr><td>`onfocus@hd
<td>`focus$et 
<tr><td>`onload@hd
<td>`load$et
<tr><td>`onresize@hd
<td>`resize$et
<tr><td>`onscroll@hd
<td>`scroll$et
</tbody></table>

<hr>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`~window$においては，`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
	<li>
前項に対応する［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］が、当の`~window$に`結付けられている文書$が所有する［
`body$e ／ `frameset$e
］要素において公開され~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by Window objects, as event handler IDL attributes on the Window objects themselves, and with corresponding event handler content attributes and event handler IDL attributes exposed on all body and frameset elements that are owned by that Window object's associated Document:
</div>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onafterprint@hd
<td>`afterprint$et
<tr><td>`onbeforeprint@hd
<td>`beforeprint$et
<tr><td>`onbeforeunload@hd
<td>`beforeunload$et
<tr><td>`onhashchange@hd
<td>`hashchange$et 
<tr><td>`onlanguagechange@hd
<td>`languagechange$et 
<tr><td>`onmessage@hd
<td>`message$et 
<tr><td>`onmessageerror@hd
<td>`messageerror$et
<tr><td>`onoffline@hd
<td>`offline$et 
<tr><td>`ononline@hd
<td>`online$et 
<tr><td>`onpagehide@hd
<td>`pagehide$et 
<tr><td>`onpageshow@hd
<td>`pageshow$et 
<tr><td>`onpopstate@hd
<td>`popstate$et 
<tr><td>`onrejectionhandled@hd
<td>`rejectionhandled$et
<tr><td>`onstorage@hd
<td>`storage$et 
<tr><td>`onunhandledrejection@hd
<td>`unhandledrejection$et
<tr><td>`onunload@hd
<td>`unload$et 
</tbody></table>

<hr>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`~HTML要素$においては、［
`~event~handler内容~属性$,
`~event~handler~IDL属性$
］の両者として，~supportされ~MUST。
</li>
	<li>
`文書$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported by all HTML elements, as both event handler content attributes and event handler IDL attributes; and that must be supported by all Document objects, as event handler IDL attributes:
</div>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`oncut@hd
<td>`cut$et
<tr><td>`oncopy@hd
<td>`copy$et
<tr><td>`onpaste@hd
<td>`paste$et
</tbody></table>

<hr>

<div class="p">
<p>
以下に挙げる各種`~event~handler$, および
対応する各種`~event~handler~event型$は：
</p>

<ul>
	<li>
`文書$においては、`~event~handler~IDL属性$として，~supportされ~MUST。
</li>
</ul>

◎
The following are the event handlers (and their corresponding event handler event types) that must be supported on Document objects as event handler IDL attributes:
</div>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onreadystatechange@hd
<td>`readystatechange$et
</tbody></table>

					<section id="idl-definitions">
<h5 title="IDL definitions">8.1.5.2.1. IDL 定義</h5>

<!-- 
#handler-xxx
 -->

<pre class="idl">
interface mixin `GlobalEventHandlers@I {
  attribute EventHandler `onabort$hd;
  attribute EventHandler `onauxclick$hd;
  attribute EventHandler `onblur$hd;
  attribute EventHandler `oncancel$hd;
  attribute EventHandler `oncanplay$hd;
  attribute EventHandler `oncanplaythrough$hd;
  attribute EventHandler `onchange$hd;
  attribute EventHandler `onclick$hd;
  attribute EventHandler `onclose$hd;
  attribute EventHandler `oncontextmenu$hd;
  attribute EventHandler `oncuechange$hd;
  attribute EventHandler `ondblclick$hd;
  attribute EventHandler `ondrag$hd;
  attribute EventHandler `ondragend$hd;
  attribute EventHandler `ondragenter$hd;
  attribute EventHandler `ondragexit$hd;
  attribute EventHandler `ondragleave$hd;
  attribute EventHandler `ondragover$hd;
  attribute EventHandler `ondragstart$hd;
  attribute EventHandler `ondrop$hd;
  attribute EventHandler `ondurationchange$hd;
  attribute EventHandler `onemptied$hd;
  attribute EventHandler `onended$hd;
  attribute `OnErrorEventHandler$I `onerror$hd;
  attribute EventHandler `onfocus$hd;
  attribute EventHandler `oninput$hd;
  attribute EventHandler `oninvalid$hd;
  attribute EventHandler `onkeydown$hd;
  attribute EventHandler `onkeypress$hd;
  attribute EventHandler `onkeyup$hd;
  attribute EventHandler `onload$hd;
  attribute EventHandler `onloadeddata$hd;
  attribute EventHandler `onloadedmetadata$hd;
  attribute EventHandler `onloadend$hd;
  attribute EventHandler `onloadstart$hd;
  attribute EventHandler `onmousedown$hd;
  [LenientThis] attribute EventHandler `onmouseenter$hd;
  [LenientThis] attribute EventHandler `onmouseleave$hd;
  attribute EventHandler `onmousemove$hd;
  attribute EventHandler `onmouseout$hd;
  attribute EventHandler `onmouseover$hd;
  attribute EventHandler `onmouseup$hd;
  attribute EventHandler `onwheel$hd;
  attribute EventHandler `onpause$hd;
  attribute EventHandler `onplay$hd;
  attribute EventHandler `onplaying$hd;
  attribute EventHandler `onprogress$hd;
  attribute EventHandler `onratechange$hd;
  attribute EventHandler `onreset$hd;
  attribute EventHandler `onresize$hd;
  attribute EventHandler `onscroll$hd;
  attribute EventHandler `onsecuritypolicyviolation$hd;
  attribute EventHandler `onseeked$hd;
  attribute EventHandler `onseeking$hd;
  attribute EventHandler `onselect$hd;
  attribute EventHandler `onstalled$hd;
  attribute EventHandler `onsubmit$hd;
  attribute EventHandler `onsuspend$hd;
  attribute EventHandler `ontimeupdate$hd;
  attribute EventHandler `ontoggle$hd;
  attribute EventHandler `onvolumechange$hd;
  attribute EventHandler `onwaiting$hd;
};
</pre>
<!-- #handler-window-xxxx -->
<pre class="idl">
interface mixin `WindowEventHandlers@I {
  attribute EventHandler `onafterprint$hd;
  attribute EventHandler `onbeforeprint$hd;
  attribute `OnBeforeUnloadEventHandler$I `onbeforeunload$hd;
  attribute EventHandler `onhashchange$hd;
  attribute EventHandler `onlanguagechange$hd;
  attribute EventHandler `onmessage$hd;
  attribute EventHandler `onmessageerror$hd;
  attribute EventHandler `onoffline$hd;
  attribute EventHandler `ononline$hd;
  attribute EventHandler `onpagehide$hd;
  attribute EventHandler `onpageshow$hd;
  attribute EventHandler `onpopstate$hd;
  attribute EventHandler `onrejectionhandled$hd;
  attribute EventHandler `onstorage$hd;
  attribute EventHandler `onunhandledrejection$hd;
  attribute EventHandler `onunload$hd;
};

interface mixin `DocumentAndElementEventHandlers@I {
  attribute EventHandler `oncopy$hd;
  attribute EventHandler `oncut$hd;
  attribute EventHandler `onpaste$hd;
};
</pre>

					</section>
				</section>
				<section id="event-firing">
<h4 title="Event firing">8.1.5.3. ~eventの発火-法</h4>

<p>
ある種の演算や~methodは、要素に向けて~eventを発火するものと定義される。
例えば， `HTMLElement$I 上の `click()$m ~methodは、要素に向けて `click$et ~eventを発火するものと定義される。
`UIEVENTS$r
◎
Certain operations and methods are defined as firing events on elements. For example, the click() method on the HTMLElement interface is defined as firing a click event on the element. [UIEVENTS]
</p>

<p class="algo-head">
`合成~mouse~eventを発火する@
ときは、所与の
( %標的, %e, %非~trusted~flag )
— 順に
( ~eventの配送-先, ~event名, ~flag値（省略時は ~OFF ） )
を与える —
に対し，次の手続きを走らす：
◎
Firing a synthetic mouse event named e at target, with an optional not trusted flag, means running these steps:
</p>

<ol>
	<li>
%~event ~LET `MouseEvent$I を用いて`~eventを作成-$した結果
◎
Let event be the result of creating an event using MouseEvent.
</li>
	<li>
<p>
以下に従って， %~event の各種~属性その他を初期化する：
◎
↓</p>
		<ol>
			<li>
`type$m ~SET %e
◎
Initialize event's type attribute to e.
</li>
			<li>
`bubbles$m ~SET ~T
◎
↓</li>
			<li>
`cancelable$m ~SET ~T
◎
Initialize event's bubbles and cancelable attributes to true.
</li>
			<li>
`~composed~flag$ ~SET ~ON
◎
Set event's composed flag.
</li>
			<li>
~IF［
%非~trusted~flag ~EQ ~ON
］
⇒
`isTrusted$m ~SET ~F
◎
If the not trusted flag is set, initialize event's isTrusted attribute to false.
</li>
			<li>
［
`ctrlKey^m, `shiftKey^m, `altKey^m, `metaKey^m
］は、~key入力~装置の現在の状態に則って初期化する（可用でない~keyに対しては ~F にする）
◎
Initialize event's ctrlKey, shiftKey, altKey, and metaKey attributes according to the current state of the key input device, if any (false for any keys that are not available).
</li>
			<li>
`view$m ~SET %標的 の`~node文書$の`~window$が［
あれば それ／
なければ ~NULL
］
◎
Initialize event's view attribute to target's node document's Window object, if any, and null otherwise.
</li>
			<li>
`getModifierState()^m ~methodは、~key入力~装置の現在の状態を適切に述べる値を返すようにする
◎
event's getModifierState() method is to return values appropriately describing the current state of the key input device.
</li>
		</ol>
	</li>
	<li>
~RET %標的 に向けて %~event を`配送-$した結果
◎
Return the result of dispatching event at target.
</li>
</ol>

<p>
%標的 に向けて
`click ~eventを発火する@
とは、 %標的 に向けて 名前 `click^et の`合成~mouse~eventを発火する$ことを意味する。
◎
Firing a click event at target means firing a synthetic mouse event named click at target.
</p>

				</section>
			</section>
		</section>

</main><!-- MAIN -->
