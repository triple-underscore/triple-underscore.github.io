<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Nesting Module （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand,
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const link_map = this.link_map;
	let context_prop = '';
	const class_map = this.class_map;
	const tag_map = this.tag_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'v': // css values
	href = context_prop + key;
	break;
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
	}
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Nesting Module
spec_date:2023-01-10
trans_update:2023-01-11
source_checked:221027
page_state_key:CSS
original_url:https://drafts.csswg.org/css-nesting/
	abbr_url:CSSNESTING
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2019-07-04


●●class_map
p:property
css:css
ps:pseudo
pe:pseudo
at:at-rule
v:value
e:element
U:code-point
cn:cp-name

●●tag_map
p:code
t:var
css:code
ps:code
pe:code
at:code
v:code
e:code
c:code
m:code
I:code
U:span
cn:span
em:em
i:i

●●original_id_map


●●link_map

	●IDL

SameObject:~WEBIDLjs#SameObject
unsigned long:~WEBIDL#idl-unsigned-long
undefined:~WEBIDL#idl-undefined
CSSOMString:~CSSOM1#cssomstring

I.CSSRuleList:~CSSOM1#cssrulelist
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration
I.CSSStyleRule:~CSSOM1#cssstylerule
I.CSSMediaRule:~CSSCOND#cssmediarule

m.cssRules:#dom-cssstylerule-cssrules
m.deleteRule:#dom-cssstylerule-deleterule
m.insertRule:#dom-cssstylerule-insertrule
m.childRules:~CSSOM1#dom-cssgroupingrule-cssrules

	●
e.div:~HEgrouping#the-div-element

	●CSS
css.&amp;:#selectordef-
ps.where():~SELECTORS4#where-pseudo
ps.is():~SELECTORS4#matches-pseudo
ps.scope:~SELECTORS4#scope-pseudo

p.color:~CSSCOLOR#propdef-color
p.grid-auto-flow:~CSSGRID#propdef-grid-auto-flow

t.declaration-list:~CSSSYN#typedef-declaration-list
t.selector-list:~SELECTORS4#typedef-selector-list
t.relative-selector-list:~SELECTORS4#typedef-relative-selector-list
t.style-block:~CSSSYN#typedef-style-block
t.stylesheet:~CSSSYN#typedef-stylesheet
t.scope-start:~CASCADE6#typedef-scope-start
t.scope-end:~CASCADE6#typedef-scope-end

at.layer:~CASCADE#at-ruledef-layer
at.scope:~CASCADE6#at-ruledef-scope
at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.container:~CSSCONTAIN3#at-ruledef-container

入子な~style規則:#nested-style-rule
入子な条件付き規則:#conditionals
入子な~group規則:#nested-group-rules
入子ng選択子:#nesting-selector

詳細度:~SELECTORS4#specificity
選択子:~SELECTORS4#selector
型~選択子:~SELECTORS4#type-selector
単体~選択子:~SELECTORS4#simple
複体~選択子:~SELECTORS4#complex
合体~選択子:~SELECTORS4#compound
選択子~list:~SELECTORS4#selector-list
相対~選択子:~SELECTORS4#relative-selector
結合子:~SELECTORS4#selector-combinator

~cascade:~CASCADE#cascade
出現順序:~CASCADE#cascade-order
	~CASCADE#cascade-sort
~style規則:~CSSSYN#style-rule
~at-規則:~CSSSYN#at-rule
宣言:~CSSSYN#declaration

~CSS識別子:~CSSVAL#css-css-identifier
関数-記法:~CSSVAL#functional-notation

条件付き~group規則:~CSSCOND#conditional-group-rule

~CSS規則~listから規則を除去する:~CSSOM1#remove-a-css-rule
~CSS規則~listに規則を挿入する:~CSSOM1#insert-a-css-rule
~CSS規則を直列化する:~CSSOM1#serialize-a-css-rule
子~規則~list:~CSSOM1#concept-css-rule-child-css-rules
宣言~群:~CSSOM1#cssstyledeclaration-declarations
選択子~list:~SELECTORS4#selector-list

●●words_table1

CASCADE6:https://drafts.csswg.org/css-cascade-6/
CSSCONTAIN3:https://drafts.csswg.org/css-contain-3/

●●words_table

	●CSS
単体:simple::~
複体:complex::~
合体:compound::~
詳細度:specificity::~
条件付き:conditional::~
	条件付き規則:conditional
CSSOM:
宣言~群:declarations:宣言 list::宣言リスト
出現順序:order of appearance:~

	^v:red
	^v:blue
	視野~付き:scoping

	●構造
直な:directな:~
	~group分け:grouping
入子を:nest-::入れ子を
入子法:nesting::入れ子法
	それらの順序:relative order
参照r:refer:参照
不可分:atomic:~

	●構文
接頭-:prefix::~
先読み:lookahead:~
糖衣:sugar::~
	糖衣を外す:desugar
集約-:aggregate:~
重複:duplication:~
周囲の:surrounding:~
勝つ:winする:~
	勝つ:lose
導入部:prelude::~
混合-:mix:~
量:amount:~
展開-:expand:~

	混合-法:mixing
	片:bit of
	来る:come
	記され:written
	書く:write
	〜を書くための:〜-writing
	明らかにする:tell
	明らかになる:can tell
	明らかにならない:can't tell
	中で一緒にされ:directly appended together
	識別子:ident
	混在させ:intermix
	~~入力:seeing
	積み上げる:stack up
	わずかな:small
	短い:small
	二重にする:doubled-up
	回数:repetition
	何回も繰返される:have significant repetition
	来る:come
	先頭に置く必要はない:n’t have to be at the beginning of
	先頭:very start of
	先頭の:initial

	●仕様
際限ない:unboundedな:~
保守能:maintainability:~
編集-:edit:~
編集:editing:~
背後:behind:~
素朴:naive:~
機能-:function:~
複雑:complicated:~
採用-:adopt:~
想定-:suppose:~
普通の:ordinaryな:~
対処-:work around:~
指数関数的:exponential:~
爆発:explosion:~
膨大:massive:~
不用意:accidental:~
適度:reasonable:~
判定-:judge:~
経験的:heuristical:~
導入:introduction:~
variation::::バリエーション
trade-off::::トレードオフ
比較的:relativeに:~
緩めた:relaxした:~
問い:question:~
open:

	~module性:modularity
	アリ性:possibility
	受容-可能でない:unacceptable
	高める:increase
	見える:look
	さほど〜でない:moderately
	それこそが:that is, after all
	要:the entire point
	適用-可能:applicable
	これまでの:to date
	-:portion of 〜 for one version of the [CSS3COLOR] module
	可能に:able to
	一致する:equivalent
	~~新たに得る:gain
	最終的に:finally
	最終的:eventual
	〜かどうか調べる:looking for
	ついて来る:comes with
	課-:impose
	~~分別:apart
	以前からある:predate
	多くが〜こともあって:largely because
	遥かに超える:much, much more!
	最悪な~~事態:the worst
	解消される:eliminate 〜 entirely
	作れる:make
	それほど多量に:as much
	築き上げる:build up
	有用さを少し減らす:making 〜 slightly less useful
	注意:notably
	〜だけで:on 's own
	ではなぜ:That skirts the question, tho:
	役立たずに見える:silly
	^en:versus
	少し書き方を違えるだけで可能:be written, they just need to be slightly rephrased
	〜を除けば:with exception
	少なくとも:at minimum
	と併用する例:Example usage with
	事実:fact
	変化しない:unchanged

	●未分類
重合する:overlapする:重なり合う
連結-:concatenate:~
megabyte::::メガバイト
component::::コンポーネント
付する:attachする:~

	Sass
	BEM
	^v:blue
	^v:red

	得られ:get
	遅く:slower
	他にも:besides
	可能:able
	小さな:small
	最も近い:nearest
	最も高い:highest
	より高い:larger
	最も高い:largest
	〜を問わず:of either 〜
	いくつもの:lots of
	他:otherwise
	-:individual
	同時に:simultaneous
	上の:the previous
	先掲の:the earlier
	順序どおり:in order


●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 4＞. URL: https://drafts.csswg.org/css-cascade-4/
[CSS-CASCADE-6]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 6＞. URL: https://drafts.csswg.org/css-cascade-6/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color/
[CSS-NESTING-1]
    Tab Atkins Jr.; Adam Argyle. ＜CSS Nesting Module＞. URL: https://drafts.csswg.org/css-nesting/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. ＜CSS Color Module Level 3＞. URL: https://drafts.csswg.org/css-color-3/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-CONTAIN-3]
    Tab Atkins Jr.; Florian Rivoal; Miriam Suzanne. ＜CSS Containment Module Level 3＞. URL: https://drafts.csswg.org/css-contain-3/
[CSS-GRID-2]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. ＜CSS Grid Layout Module Level 2＞. URL: https://drafts.csswg.org/css-grid-2/
[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Nesting Module</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-nesting-1/
公表履歴
	https://www.w3.org/standards/history/css-nesting-1
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-nesting-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="https://nerdy.dev/">Adam Argyle</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-nesting-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-nesting-1
</script>

<body>

<header>
	<hgroup>
<h1>CSS Nesting Module</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~moduleは、`~style規則$を別の規則の内側に
— 親~規則の選択子に相対的な子~規則の選択子を伴わせて —
入子にする能を導入する。
これは、~CSS~stylesheetの~module性と保守能を高める。
◎
This module introduces the ability to nest one style rule inside another, with the selector of the child rule relative to the selector of the parent rule. This increases the modularity and maintainability of CSS stylesheets.
</p>

<p class="trans-note">【
この仕様が定義する構文は、
まだ確定的ではなく，変更されるかもしれない
— いくつかの代替が<a href="https://github.com/w3c/csswg-drafts/blob/main/css-nesting-1/proposals.md">提案されている</a>。
】</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この~moduleは、別の`~style規則$の中に~style規則を入子にするための~supportを述べる
— それは、内縁~規則の選択子が，外縁~規則に合致した要素を参照できるようにする。
この特能は、関係し合う~styleたちを~CSS文書の中の単独の構造に集約できるようにして，可読性と保守能を改善する。
◎
This module describes support for nesting a style rule within another style rule, allowing the inner rule’s selector to reference the elements matched by the outer rule. This feature allows related styles to be aggregated into a single structure within the CSS document, improving readability and maintainability.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、 `CSS21$r 構文解析器~modelを拡張する新たな構文解析器~規則を導入する。
また、 `SELECTORS4$r ~moduleを拡張する選択子も導入する。
◎
This module introduces new parser rules that extend the [CSS21] parser model. This module introduces selectors that extend the [SELECTORS4] module.
</p>

		</section>
		<section id="values">
<h3 title="Values">1.2. 値</h3>

<p>
この仕様は、新たな~propや値は定義しない。
◎
This specification does not define any new properties or values.
</p>

		</section>
		<section id="motivation">
<h3 title="Motivation">1.3. 動機</h3>

<p>
さほど複雑でない~web~page用の~CSSであっても、
互いに関係する内容を~styleする目的に，いくつもの重複を含むことが多い。
例えば、
次の~CSS~markup【！for one version of the [CSS-COLOR-3] module】は，
互いに関係する~style規則をいくつか含んでいるが：
◎
The CSS for even moderately complicated web pages often include lots of duplication for the purpose of styling related content. For example, here is a portion of the CSS markup for one version of the [CSS-COLOR-3] module:
</p>

<pre class="lang-css">
table.colortable td {
  text-align:center;
}
table.colortable td.c {
  text-transform:uppercase;
}
table.colortable td:first-child, table.colortable td:first-child+td {
  border:1px solid black;
}
table.colortable th {
  text-align:center;
  background:black;
  color:white;
}
</pre>

<p>
入子法を用いれば，次の様に~group化できるようになる：
◎
Nesting allows the grouping of related style rules, like this:
</p>

<pre class="lang-css">
table.colortable {
  &amp; td {
    text-align:center;
    &amp;.c { text-transform:uppercase }
    &amp;:first-child, &amp;:first-child + td { border:1px solid black }
  }
  &amp; th {
    text-align:center;
    background:black;
    color:white;
  }
}
</pre>

<p>
重複を除去することの他にも、関係する規則の~group分けは，結果の~CSSの可読性と保守能を改善する。
◎
Besides removing duplication, the grouping of related rules improves the readability and maintainability of the resulting CSS.
</p>

		</section>
	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="nesting">
<h2 title="Nesting Style Rules">2. ~style規則の入子法</h2>

<p>
~style規則は、
他の~style規則の内側に入子にできる。
これらの
`入子な~style規則@
は、
普通の~style規則と正確に同じ様に動作する
— すなわち、
選択子を介して，要素に~prop群を結付ける —
が、
それらは親~規則の選択子~文脈を “継承する” ことで，選択子を
— 場合によっては複数回~繰返す必要なく —
親の選択子の上に更に築くことを許容する。
◎
Style rules can be nested inside of other styles rules. These nested style rules act exactly like ordinary style rules—associating properties with elements via selectors—but they "inherit" their parent rule’s selector context, allowing them to further build on the parent’s selector without having to repeat it, possibly multiple times.
</p>

<p>
`入子な~style規則$は、
その`選択子$が［
`~CSS識別子$／`関数-記法$
］から開始し得ないことを除けば，
通常の~style規則と正確に同じ様になる。
加えて、
`入子な~style規則$には，`相対~選択子$を利用できる。
◎
A nested style rule is exactly like a normal style rule, with the exception that its selector cannot start with an identifier or functional notation. Additionally, nested style rules can use relative selectors.
</p>

<div class="example">
<p>
すなわち、
次の様な入子な~style規則は：
◎
That is, a nested style rule like:
</p>

<pre class="lang-css">
.foo {
  color: red;

  .bar {
    color: blue;
  }
}
</pre>

<p>
妥当であり，
次と等価になる：
◎
is valid, and equivalent to:
</p>

<pre class="lang-css">
.foo {
  color: red;
}
.foo .bar {
  color: blue;
}
</pre>

<p>
入子にされた規則は、［
`入子ng選択子$を利用して，
親~規則に合致した要素を直に参照rする
］ことも［
`相対~選択子$の構文を利用して，
“子孫” 以外の関係性を指定する
］こともできる。
◎
The nested rule can also use the nesting selector to directly refer to the parent rule’s matched elements, or use relative selector syntax to specify relationships other than "descendant".
</p>

<pre class="lang-css">
.foo {
  color: red;

  &amp;:hover {
    color: blue;
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to:
</span> */

.foo { color: red; }
.foo:hover { color: blue; }
</pre>

<pre class="lang-css">
.foo {
  color: red;

  + .bar {
    color: blue;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to:
</span> */

.foo { color: red; }
.foo + .bar { color: blue; }
</pre>
</div>

<div class="example">
<p>
しかしながら、
入子な選択子が識別子から開始している場合（言い換えれば、`型~選択子$），妥当でない：
◎
However, starting the nested selector with an identifier (a type selector, in other words) is invalid:
</p>

<pre class="lang-css">
div {
  color: red;

  input {
    margin: 1em;
  }
}
/* <span class="comment">
`input^css は識別子なので，妥当でない。
◎
Invalid, because "input" is an identifier.
</span> */
</pre>

<p>
そのような選択子でも、
少し書き方を違えるだけで可能になる：
◎
Such selectors can still be written, they just need to be slightly rephrased:
</p>

<pre class="lang-css">
div {
  color: red;

  &amp; input { margin: 1em; }
  /* <span class="comment">
妥当になる
— もはや，識別子から開始していないので。
◎
valid, no longer starts with an identifier
</span> */

  :is(input) { margin: 1em; }
  /* <span class="comment">
~colonから開始しているので、
妥当になり，上の規則と等価になる。
◎
valid, starts with a colon, and equivalent to the previous rule.
</span> */
}
</pre>
</div>

<details class="note">
<summary>
なぜ，入子にされた規則の選択子には制約があるのか？
◎
Why are there restrictions on nested rule selectors?
</summary>

<p>
あいにく，素朴に［
`~style規則$の内側に別の~style規則を入子にする
］だけでは、
多義的になる。
選択子の構文【 `selector-list$t 】と宣言の構文【 `declaration-list$t 】は重合するので、
所与の~text片が［
宣言，ある~style規則の開始
］どちらなのか明らかにするため，実装には際限ない先読みが要求される。
◎
Nesting style rules naively inside of other style rules is, unfortunately, ambiguous—the syntax of a selector overlaps with the syntax of a declaration, so an implementation requires unbounded lookahead to tell whether a given bit of text is a declaration or the start of a style rule.
</p>

<p>
例えば，ある構文解析器に対する~~入力が
`color:hover ...^css から開始している場合、
それが［
`color$p ~prop（無効な値 `hover^v に設定されている）,
`color^e 要素~用の選択子
］どちらなのかは明らかにならない。
この相違を［
妥当な~propを成すかどうか調べることで明らかにする
］ことにさえ依拠できない
— そうすると、
構文解析は［
実装が どの~prop【あるいは，~propのどの値】を~supportするか
］に依存するようになり，時を経れば変化し得ることにもなる。
◎
For example, if a parser starts by seeing color:hover ..., it can’t tell whether that’s the color property (being set to an invalid value...) or a selector for a &lt;color&gt; element. It can’t even rely on looking for valid properties to tell the difference; this would cause parsing to depend on which properties the implementation supported, and could change over time.
</p>

<p>
この問題は、
入子な~style規則が`~CSS識別子$から開始するのを禁止することで対処される
— 識別子から開始する`宣言$【！`宣言~群$】は，どれも~prop名を与えるので、
構文解析器にとっては［
`宣言$, `~style規則$
］どちらを構文解析しているかは即時に明らかになる。
◎
Forbidding nested style rules from starting with an identifier works around this problem—all declarations start with an identifier giving the property name, so the parser can immediately tell whether it’s parsing a declaration or style rule.
</p>

<p>
一部の非~browserによる入子な規則の実装は、
この要件を課さない。
~propと選択子の~~分別を明らかにすることは、
ほとんどの事例では`最終的^emにはアリだが，
そのためには構文解析器に際限ない先読みが要求される。
すなわち，構文解析器は、［
どちらの仕方で解釈するよう想定されているか明らかになる
］まで，未知な量の内容を保持する必要も生じ得る。
これまでの~CSSは，［
より効率的な構文解析~algoを許容する
］よう［
構文解析において，既知な わずかな量の先読みしか要求していない
］ので、
際限ない先読みは，一般に［
~browserによる~CSSの実装においては、
受容-可能でない
］と見なされる。
◎
Some non-browser implementations of nested rules do not impose this requirement. It is, in most cases, eventually possible to tell properties and selectors apart, but doing so requires unbounded lookahead in the parser; that is, the parser might have to hold onto an unknown amount of content before it can tell which way it’s supposed to be interpreting it. CSS to date requires only a small, known amount of lookahead in its parsing, which allows for more efficient parsing algorithms, so unbounded lookahead is generally considered unacceptable among browser implementations of CSS.
</p>
</details>

		<section id="syntax">
<h3 title="Syntax">2.1. 構文</h3>

<p>
`~style規則$の内容は、
既存の`宣言~群$に加えて，今や［
`入子な~style規則$, `~at-規則$
］も受容する。
◎
The contents of style rules now accepts nested style rules and at-rules, in addition to the existing declarations.
</p>

<p>
`入子な~style規則$は、
入子にされない規則とは，次に挙げる仕方で相違する：
◎
Nested style rules differ from non-nested rules in the following ways:
</p>
<ul>
	<li>
`入子な~style規則$の選択子は、
［
`~CSS識別子$／`関数-記法$
］から開始してはナラナイ。
◎
The selector of nested style rules must not start with an identifier or a functional notation.
</li>
	<li>
`入子な~style規則$は、
その .導入部として `relative-selector-list$t を受容する
（ `selector-list$t だけでなく）。
`相対~選択子$は、
`入子ng選択子$により表現される要素に相対的になる。
◎
A nested style rule accepts a &lt;relative-selector-list&gt; as its prelude (rather than just a &lt;selector-list&gt;). Any relative selectors are relative to the elements represented by the nesting selector.
</li>
	<li>
`relative-selector-list$t を成す各~選択子のうち［
`結合子$から開始しないが，`入子ng選択子$を包含するもの
］は、
`相対~選択子$ではないものと解釈される。
◎
If a selector in the &lt;relative-selector-list&gt; does not start with a combinator but does contain the nesting selector, it is interpreted as a non-relative selector.
</li>
</ul>

<p>
入子な~style規則が どう構文解析されるかについての精確な詳細は、
`CSS-SYNTAX-3$r にて定義される。
◎
The precise details of how nested style rules are parsed are defined in [CSS-SYNTAX-3].
</p>

<p>
無効な`入子な~style規則$は、
その内容【すなわち，宣言~block】とともに無視されるが，
その親~規則を無効~化することはない。
◎
An invalid nested style rule is ignored, along with its contents, but does not invalidate its parent rule.
</p>

<div class="example">
<p>
例えば，以下に挙げる入子ngは、
妥当になる：
◎
For example, the following nestings are valid:
</p>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css （`入子ng選択子$）は、
それだけでも選択子として利用できる：
◎
&amp; can be used on its own
</span> */
.foo {
  color: blue;
  &amp; &gt; .bar { color: red; }
  &gt; .baz { color: green; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo &gt; .bar { color: red; }
  .foo &gt; .baz { color: green; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`合体~選択子$における `&amp;^css は、
親の選択子を精緻化する：
◎
or in a compound selector, refining the parent’s selector
</span> */
.foo {
  color: blue;
  &amp;.bar { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo.bar { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
選択子~listを成す各~選択子は、
どれも，親に相対的になる：
◎
multiple selectors in the list are all relative to the parent
</span> */
.foo, .bar {
  color: blue;
  + .baz, &amp;.qux { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo, .bar { color: blue; }
  :is(.foo, .bar) + .baz,
  :is(.foo, .bar).qux { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css は、
単独の選択子~内で複数回~利用できる：
◎
&amp; can be used multiple times in a single selector
</span> */
.foo {
  color: blue;
  &amp; .bar &amp; .baz &amp; .qux { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo .bar .foo .baz .foo .qux { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css は、
選択子の先頭に置く必要はない：
◎
&amp; doesn’t have to be at the beginning of the selector
</span> */

.foo {
  color: red;
  .parent &amp; {
    color: blue;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  .parent .foo { color: blue; }
*/

.foo {
  color: red;
  :not(&amp;) {
    color: blue;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  :not(.foo) { color: blue; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`相対~選択子$を利用する場合、
先頭の `&amp;^css が自動的に含意される：
◎
But if you use a relative selector, an initial &amp; is implied automatically
</span> */
.foo {
  color: red;
  + .bar + &amp; { color: blue; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  .foo + .bar + .foo { color: blue; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
いくぶん役立たずに見えるが、
`&amp;^css だけでも利用できる：
◎
Somewhat silly, but &amp; can be used all on its own, as well.
</span> */
.foo {
  color: blue;
  &amp; { padding: 2ch; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo { padding: 2ch; }

  <span class="comment">
あるいは：
◎
// or
</span>

  .foo {
    color: blue;
    padding: 2ch;
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
これも役立たずに見えるが、
`&amp;^css を二重にすることもできる：
◎
Again, silly, but can even be doubled up.
</span> */
.foo {
  color: blue;
  &amp;&amp; { padding: 2ch; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo.foo { padding: 2ch; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
親~選択子は、
任意に複雑にできる：
◎
The parent selector can be arbitrarily complicated
</span> */
.error, #404 {
  &amp;:hover &gt; .baz { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  :is(.error, #404):hover &gt; .baz { color: red; }
*/

.ancestor .el {
  .other-ancestor & { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .other-ancestor :is(.ancestor .el) { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
入子な選択子も、
任意に複雑にできる：
◎
As can the nested selector
</span> */
.foo {
  &amp; :is(.bar, &amp;.baz) { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo :is(.bar, .foo.baz) { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
選択子を複数~levelに入子にして “積み上げる” ：
◎
Multiple levels of nesting "stack up" the selectors
</span> */
figure {
  margin: 0;

  &gt; figcaption {
    background: hsl(0 0% 0% / 50%);

    &gt; p {
      font-size: .9rem;
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  figure { margin: 0; }
  figure &gt; figcaption { background: hsl(0 0% 0% / 50%); }
  figure &gt; figcaption &gt; p { font-size: .9rem; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
~cascade層（ `layer$at ）と併用する例：
◎
Example usage with Cascade Layers
</span> */
@layer base {
  html {
    block-size: 100%;

    &amp; body {
      min-block-size: 100%;
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @layer base {
    html { block-size: 100%; }
    html body { min-block-size: 100%; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
~cascade層を入子にする例：
◎
Example nesting Cascade Layers
</span> */
@layer base {
  html {
    block-size: 100%;

    @layer support {
      &amp; body {
        min-block-size: 100%;
      }
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @layer base {
    html { block-size: 100%; }
  }
  @layer base.support {
    html body { min-block-size: 100%; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
視野~付き（ `scope$at ）と併用する例：
◎
Example usage with Scoping
</span> */
@scope (.card) to (&gt; header) {
  :scope {
    inline-size: 40ch;
    aspect-ratio: 3/4;
				
    &gt; header {
      border-block-end: 1px solid white;
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @scope (.card) to (&gt; header) {
    :scope { inline-size: 40ch; aspect-ratio: 3/4; }
    :scope &gt; header { border-block-end: 1px solid white; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
視野~付きを入子にする例：
◎
Example nesting Scoping
</span> */
.card {
  inline-size: 40ch;
  aspect-ratio: 3/4;

  @scope (&amp;) to (&gt; header &gt; *) {
    :scope &gt; header {
      border-block-end: 1px solid white;
    }
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .card { inline-size: 40ch; aspect-ratio: 3/4; }
  @scope (.card) to (&gt; header &gt; *) {
    :scope &gt; header { border-block-end: 1px solid white; }
  }
*/
</pre>

<p>
一方で、
以下に挙げるものは，妥当でない：
◎
But these are not valid:
</p>

<pre class="lang-css">
/* <span class="comment">
識別子から開始している入子な選択子：
◎
Selector starts with an identifier
</span> */
.foo {
  color: blue;
  div {
    color: red;
  }
}
</pre>
</div>

<div class="note">
<p>注記：
［
~CSSを生成する~toolのうち，入子ngを処理するもの
］には、
作者が［
選択子を文字列として連結して，
複数の入子ng~levelにまたがる 1 個の`単体~選択子$を築き上げる
］ことを許容するものもある。
これは，ときには、
【！ `https://en.wikipedia.org/wiki/CSS#:~:text=bem%20(block%2C%20element%2C%20modifier)^】
<abbr title="Block, Element, Modifier">BEM</abbr>
の様に，
階層的な~patternを成す名前で利用されることもある
— 当の選択子が内部的に何回も繰返されるとき、
その回数を抑制するためとして。
◎
 Some CSS-generating tools that preprocess nesting will concatenate selectors as strings, allowing authors to build up a single simple selector across nesting levels. This is sometimes used with hierarchical name patterns like BEM to reduce repetition across a file, when the selectors themselves have significant repetition internally.
</p>

<p>
例えば、
ある~componentが~class `.foo^css を利用していて，
ある入子な~componentが~class `.fooBar^css を利用している場合、
<a href="https://sass-lang.com/">Sass</a>
においては，次のように書くこともできる：
◎
For example, if one component uses the class .foo, and a nested component uses .fooBar, you could write this in Sass as:
</p>

<pre class="lang-css">
.foo {
  color: blue;
  &amp;Bar { color: red; }
}
/* <span class="comment">
は、
Sass においては，次と等価になる：
◎
In Sass, this is equivalent to
</span>
   .foo { color: blue; }
   .fooBar { color: red; }
*/
</pre>

<p>
あいにく、
この［
文字列に基づく解釈
］は，作者が［
当の入子な規則~内に`型~選択子$を追加しようと試みる
］とき多義的になる。
例えば `Bar^css は、
~HTMLにおける妥当な<a href="~HEcustom">~custom要素~名</a>`である^em†。
【† <a href="~HEcustom#valid-custom-element-name">妥当な~custom要素~名</a>の構文に合致していないが、いずれにせよ，未知な要素の名前として解釈されよう。】
◎
Unfortunately, this string-based interpretation is ambiguous with the author attempting to add a type selector in the nested rule. Bar, for example, is a valid custom element name in HTML.
</p>

<p>
~CSSは、
これを行わない
— 入子な選択子~成分は、
不可分に解釈され，文字列のように連結されない：
◎
CSS doesn’t do this: the nested selector components are interpreted atomically, and not string-concatenated:
</p>

<pre class="lang-css">
.foo {
  color: blue;
  &amp;Bar { color: red; }
}
/* <span class="comment">
は、
~CSSにおいては，
代わりに次と等価になる：
◎
In CSS, this is instead equivalent to
</span>
   .foo { color: blue; }
   Bar.foo { color: red; }
*/
</pre>
</div>

		</section>
		<section id="conditionals">
<h3 title="Nesting Other At-Rules">2.2. 他の~at-規則の入子法</h3>

<p>
`入子な~style規則$に加えて、
この仕様は，`~style規則$の内側に
`入子な~group規則@
も許容する。
~at-規則のうち，その本体が`~style規則$を包含し得るものは、
`~style規則$の内側にも，規則を入子にできる。
◎
In addition to nested style rules, this specification allows nested group rules inside of style rules: any at-rule whose body contains style rules can be nested inside of a style rule as well.
</p>

<p>
`入子な~group規則$が，この仕方で入子にされたときは、
当の規則の内容は、
`stylesheet$t としてではなく， `style-block$t として構文解析される：
◎
When nested in this way, the contents of a nested group rule are parsed as &lt;style-block&gt; rather than &lt;stylesheet&gt;:
</p>
<ul>
	<li>
`~style規則$は、
`入子な~style規則$になり，
その`入子ng選択子$の定義を最も近い先祖の`~style規則$からとる。
◎
Style rules are nested style rules, with their nesting selector taking its definition from the nearest ancestor style rule.
</li>
	<li>
~prop【宣言】は、
直に利用でき，
`&amp; {...}^css ~block内に入子にされたかのように動作する。
◎
Properties can be directly used, acting as if they were nested in a &amp; {...} block.
</li>
</ul>

<p class="note">注記：
特定的に，次に挙げる規則は、
`入子な~group規則$になる能力がある
⇒＃
すべての`条件付き~group規則$（ `media$at, `supports$at ）,
`layer$at,
`scope$at,
`container$at
◎
Specifically, these rules are capable of being nested group rules:
• all the conditional group rules (@media, @supports)
• @layer
• @scope
• @container
</p>

<p>
そのような`入子な~group規則$の意味と挙動は、
他においては，他が指定されない限り変化しない。
◎
The meanings and behavior of such nested group rules is otherwise unchanged, unless otherwise specified.
</p>

<div class="example">
<p>
例えば、
次に挙げる条件付き規則の入子ngは，妥当になる：
◎
For example, the following conditional nestings are valid:
</p>

<pre class="lang-css">
/* <span class="comment">
~propは直に利用できる：
◎
Properties can be directly used
</span> */
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo {
    display: grid;
				
    @media (orientation: landscape) {
      &amp; {
        grid-auto-flow: column;
      }
    }
  }
*/

/* <span class="comment">
最終的に次と等価になる：
◎
finally equivalent to
</span>
  .foo { display: grid; }

  @media (orientation: landscape) {
    .foo {
      grid-auto-flow: column;
    }
  }
*/

/* <span class="comment">
条件付きも更に入子にできる：
◎
Conditionals can be further nested
</span> */
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;

    @media (min-width &gt; 1024px) {
      max-inline-size: 1024px;
    }
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { display: grid; }

  @media (orientation: landscape) {
    .foo {
      grid-auto-flow: column;
    }
  }

  @media (orientation: landscape) and (min-width &gt; 1024px) {
    .foo {
      max-inline-size: 1024px;
    }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
~cascade層（ `layer$at ）を入子にする例：
◎
Example nesting Cascade Layers
</span> */
html {
  @layer base {
    block-size: 100%;

    @layer support {
      &amp; body {
        min-block-size: 100%;
      }
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @layer base {
    html { block-size: 100%; }
  }
  @layer base.support {
    html body { min-block-size: 100%; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
視野~付き（ `scope$at ）を入子にする例：
◎
Example nesting Scoping
</span> */
.card {
  inline-size: 40ch;
  aspect-ratio: 3/4;

  @scope (&amp;) {
    :scope {
      border: 1px solid white;
    }
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .card { inline-size: 40ch; aspect-ratio: 3/4; }
  @scope (.card) {
    :scope { border-block-end: 1px solid white; }
  }
*/
</pre>
</div>

<p>
直に入子にされたすべての~propは、［
順序どおり一緒に収集され，
選択子 `&amp;$css を伴う`入子な~style規則$内に入子にされ，
他のすべての子~規則より前に配置された
］かのように扱われる。
◎
All directly-nested properties are treated as if they were collected together, in order, and nested in a nested style rule with the selector &amp;, and placed before all other child rules.
</p>

<div class="example">
<p>
例えば，先掲の例：
◎
For example, the earlier example:
</p>

<pre class="lang-css">
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to:
</span> */
  .foo {
    display: grid;

    @media (orientation: landscape) {
      &amp; {
        grid-auto-flow: column;
      }
    }
  }
*/
</pre>

<p>
事実，`正確に^em等価になり、
正確に同じ~CSSOM構造を生産する。
【 `media^at を表現する】 `CSSMediaRule$I ~objは、
その `childRules$m 属性~内に［
`grid-auto-flow$p ~propを包含している 1 個の `CSSStyleRule$I ~obj
］を有することになる。
◎
is in fact exactly equivalent, producing the exact same CSSOM structure. The CSSMediaRule object will have a single CSSStyleRule object in its .childRules attribute, containing the grid-auto-flow property.
</p>
</div>

<p class="issue">
直列化~規則を<a href="https://github.com/w3c/csswg-drafts/issues/7850#issuecomment-1288883780">この~comment</a>にあるとおり改変する必要がある
— 最初の子~規則が `&amp; {...}^css のときには、
包装している規則を除去するよう。
◎
Need to modify the serialization rules, as in this comment, to remove the wrapping rule when the first child rule is &amp; {...}.
</p>

			<section id="nesting-at-scope">
<h4 title="Nested @scope Rules">2.2.1. 入子な `scope^at 規則</h4>

<p>
所与の `scope$at 規則 %規則 に対し：
◎
↓</p>
<ul>
	<li>
%規則 が`入子な~group規則$を成すときは、
%規則 の `scope-start$t における `&amp;$css 選択子は，最も近い先祖~style規則に合致した要素を参照rする。
◎
When the @scope rule is a nested group rule, an &amp; in the &lt;scope-start&gt; selector refers to the elements matched by the nearest ancestor style rule.
</li>
	<li>
%規則 の［
本体~内の~style規則／ `scope-end$t
］における `&amp;$css 選択子は、［
%規則 の `scope-start$t 選択子に合致している要素
］に合致するものとして扱われる。
【この段落の原文は，そのまま訳すと意味が通らないので、訳を改めている。】
◎
For the purposes of the style rules in its body and its own &lt;scope-end&gt; selector, the @scope rule is treated as an ancestor style rule, matching the elements matched by its &lt;scope-start&gt; selector.
</li>
</ul>

<div class="example">
<p>
すなわち、
次の~codeは：
◎
That is, the following code:
</p>

<pre class="lang-css">
.parent {
  color: blue;

  @scope (&amp; &gt; .scope) to (&amp; .limit) {
    &amp; .content {
      color: red;
    }
  }
}
</pre>

<p>
次と等価になる：
◎
is equivalent to:
</p>

<pre class="lang-css">
.parent { color: blue; }
@scope (.parent &gt; .scope) to (.parent &gt; .scope .limit) {
  .parent &gt; .scope .content {
    color: red;
  }
}
</pre>
</div>

			</section>
		</section>
		<section id="mixing">
<h3 title="Mixing Nesting Rules and Declarations">2.3. 入子ng規則と宣言の混合-法</h3>

<p>
~style規則が［
宣言, ［
`入子な~style規則$／`入子な~group規則$【！入子な条件付き~group規則】
］］両者を包含するときでも，
これら 3 種すべてを任意に混合できる。
しかしながら，前者と後者の相対的な順序は、
どの仕方でも保全されない。
◎
When a style rule contains both declarations and nested style rules or nested conditional group rules, all three can be arbitrarily mixed. However, the relative order of declarations vs other rules is not preserved in any way.
</p>

<div class="example">
<p>
例えば、
次の~codeでは：
◎
For example, in the following code:
</p>

<pre class="lang-css">
article {
  color: green;
  &amp; { color: blue; }
  color: red;
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span> */
article {
  color: green;
  color: red;
  &amp; { color: blue; }
}
</pre>
</div>

<p>
`出現順序$を決定する目的においては、［
`入子な~style規則$／
`入子な~group規則$【！入子な条件付き~group規則】
］は，その親~規則より`後^emに来るものと見なされる。
◎
For the purpose of determining the Order Of Appearance, nested style rules and nested conditional group rules are considered to come after their parent rule.
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-css">
article {
  color: blue;
  &amp; { color: red; }
}
</pre>

<p>
両~宣言とも，その詳細度は同じ (0,0,1) になるが、
入子な規則は親~規則より`後に来る^emものと見なされるので，
宣言 `color: red^css の方が~cascadeに勝つ。
◎
Both declarations have the same specificity (0,0,1), but the nested rule is considered to come after its parent rule, so the color: red declarations wins the cascade.
</p>

<p>
他方，次の例では：
◎
On the other hand, in this example:
</p>

<pre class="lang-css">
article {
  color: blue;
  :where(&amp;) { color: red; }
}
</pre>

<p>
`where()$ps 疑似類により`入子ng選択子$の詳細度は 0 に抑制されるので，
宣言 `color: red^css の詳細度は (0,0,0) になり、
`出現順序$が考慮される前に，
宣言 `color: blue^css の方が勝つ。
◎
The :where() pseudoclass reduces the specificity of the nesting selector to 0, so the color: red declaration now has a specificity of (0,0,0), and loses to the color: blue declaration before "Order Of Appearance" comes into consideration.
</p>
</div>

		</section>
	</section>
	<section id="nest-selector">
<h2 title="Nesting Selector: the &amp; selector">3. 入子ng選択子： `&amp;^css 選択子</h2>

<p>
`入子な~style規則$を利用するときには、
親~規則に合致した要素を参照r可能にならなければならない。
それこそが、
`入子法の要^emを成す。
これを成遂げるため、
この仕様は，
`&amp;@css
（ `0026^U `AMPERSAND^cn ）として記される新たな選択子として，
`入子ng選択子@
（ `nesting selector^en ）を定義する。
◎
When using a nested style rule, one must be able to refer to the elements matched by the parent rule; that is, after all, the entire point of nesting. To accomplish that, this specification defines a new selector, the nesting selector, written as &amp; (U+0026 AMPERSAND).
</p>

<p>
`入子ng選択子$は、
`入子な~style規則$の選択子~内で利用されたときは，親~規則に合致した要素を表現する。
他の文脈~内で利用されたときは、
その文脈において `scope$ps に合致する【！the same】要素を表現する
（他が指定されない限り）。
◎
When used in the selector of a nested style rule, the nesting selector represents the elements matched by the parent rule. When used in any other context, it represents the same elements as :scope in that context (unless otherwise defined).
</p>

<div class="note">
<p>注記：
`入子ng選択子$による糖衣は、
それを［
親~style規則の選択子を `is()$ps 選択子で包装したもの
］に置換することより外せる（ `desugar^en できる）。
例えば：
◎
The nesting selector can be desugared by replacing it with the parent style rule’s selector, wrapped in an :is() selector. For example,
</p>

<pre class="lang-css">
a, b {
  &amp; c { color: blue; }
}
</pre>

<p>
は、
次に等価になる：
◎
is equivalent to
</p>

<pre class="lang-css">
:is(a, b) c { color: blue; }
</pre>
</div>

<p>
`入子ng選択子$は、
疑似要素を表現し得ない
（ `is()$ps 疑似類の挙動に一致する）。
◎
The nesting selector cannot represent pseudo-elements (identical to the behavior of the :is() pseudo-class).
</p>

<div class="example">
<p>
例えば、
次の~style規則においては：
◎
For example, in the following style rule:
</p>

<pre class="lang-css">
.foo, .foo::before, .foo::after {
  color: red;

  &amp;:hover { color: blue; }
}
</pre>

<p>
`&amp;$css は，
`.foo^css に合致した要素に限り表現する
— 言い換えれば，次と等価になる：
◎
the &amp; only represents the elements matched by .foo; in other words, it’s equivalent to:
</p>

<pre class="lang-css">
.foo, .foo::before, .foo::after {
  color: red;
}
.foo:hover {
  color: blue;
}
</pre>
</div>

<p class="issue">
この制約は緩めたいが、［
`is()$ps, `&amp;$css
］両者に対し同時に行う必要がある
— それらは、
意図的に，同じ下層の仕組みの上に築かれるので。
（ `7433$issue ）
◎
We’d like to relax this restriction, but need to do so simultaneously for both :is() and &amp;, since they’re intentionally built on the same underlying mechanisms. (Issue 7433)
</p>

<p>
`入子ng選択子$の`詳細度$は、［
親~style規則の`選択子~list$を成す各`複体~選択子$の`詳細度$
］のうち最も高いものに等しい（ `is()$ps の挙動と一致する）。
◎
The specificity of the nesting selector is equal to the largest specificity among the complex selectors in the parent style rule’s selector list (identical to the behavior of :is()).
</p>

<div class="example">
<p>
例えば，次の~style規則が与えられたなら：
◎
For example, given the following style rules:
</p>

<pre class="lang-css">
#a, b {
  &amp; c { color: blue; }
}
.foo c { color: red; }
</pre>

<p>
次の様な~DOM構造においては：
◎
Then in a DOM structure like
</p>

<pre class="lang-html">&lt;b class=foo&gt;
  &lt;c&gt;Blue text&lt;/c&gt;
&lt;/b&gt;
</pre>

<p>
~textの色は、
`red^v ではなく `blue^v になる。
`&amp;$css の詳細度は［
`#a^css の詳細度 (1,0,0),
`b^css の詳細度 (0,0,1)
］のうち高い方 (1,0,0) になるので、
選択子~全体 `&amp; c^css の詳細度は (1,0,1) になる,
— それは `.foo c^css の詳細度 (0,1,1) より高い。
◎
The text will be blue, rather than red. The specificity of the &amp; is the larger of the specificities of #a ([1,0,0]) and b ([0,0,1]), so it’s [1,0,0], and the entire &amp; c selector thus has specificity [1,0,1], which is larger than the specificity of .foo c ([0,1,1]).
</p>

<p>
これは、［
入子ngを外して，入子にされない規則に手動で展開した場合に得られる結果
］とは`異なる^emことに注意。
そうした場合、
宣言 `color: blue^css は、
詳細度 (1,0,1) の選択子 `#a c^css ではなく，
詳細度 (0,0,2) の選択子 `b c^css に合致するので。
◎
Notably, this is different than the result you’d get if the nesting were manually expanded out into non-nested rules, since the color: blue declaration would then be matching due to the b c selector ([0,0,2]) rather than #a c ([1,0,1]).
</p>
</div>

<details class="note">
<summary>
なぜ、
入子にされない規則とは詳細度が異なるのか？
◎
Why is the specificity different than non-nested rules?
</summary>

<p>
`入子ng選択子$の詳細度は、
意図的に， `is()$ps 疑似類と同じ規則を利用するようにしてある。
それは、
各~引数の中で最も高い詳細度を利用するだけであり，
実際に合致した選択子が`どれなのか^emを追跡しない。
◎
The nesting selector intentionally uses the same specificity rules as the :is() pseudoclass, which just uses the largest specificity among its arguments, rather than tracking which selector actually matched.
</p>

<p>
これは、
処理能の理由から要求される。
選択子の詳細度を［
どれだけ精確に合致したかに依存して，アリなものが複数ある
］ようにした場合、
選択子の照合は，ずっと複雑で遅くなる。
◎
This is required for performance reasons; if a selector has multiple possible specificities, depending on how precisely it was matched, it makes selector matching much more complicated and slower.
</p>

<p>
ではなぜ `&amp;$css を `is()$ps の用語で定義するのか？
一部の非~browserによる［
入子法の様な機能性
］の実装は、
その多くが `is()^ps の導入~以前からあることもあって，
その糖衣を
— `is()^ps を通して外すことなく —
直に外す。
しかしながら，これには`有意な問題^emがついて来る
— 一部の（適度に共通的な）事例では、
指数関数的な爆発のアリ性に因り，不用意に`膨大^emな選択子を生産し得るので。
◎
That skirts the question, tho: why do we define &amp; in terms of :is()? Some non-browser implementations of Nesting-like functionality do not desugar to :is(), largely because they predate the introduction of :is() as well. Instead, they desugar directly; however, this comes with its own significant problems, as some (reasonably common) cases can accidentally produce massive selectors, due to the exponential explosion of possibilities.
</p>

<pre class="lang-css">
.a1, .a2, .a3 {
  .b1, .b3, .b3 {
    .c1, .c2, .c3 {
      ...;
    }
  }
}

/* <span class="comment">
素朴に糖衣を外したとすると：
◎
naively desugars to
</span> */
.a1 .b1 .c1,
.a1 .b1 .c2,
.a1 .b1 .c3,
.a1 .b2 .c1,
.a1 .b2 .c2,
.a1 .b2 .c3,
.a1 .b3 .c1,
.a1 .b3 .c2,
.a1 .b3 .c3,
.a2 .b1 .c1,
.a2 .b1 .c2,
.a2 .b1 .c3,
.a2 .b2 .c1,
.a2 .b2 .c2,
.a2 .b2 .c3,
.a2 .b3 .c1,
.a2 .b3 .c2,
.a2 .b3 .c3,
.a3 .b1 .c1,
.a3 .b1 .c2,
.a3 .b1 .c3,
.a3 .b2 .c1,
.a3 .b2 .c2,
.a3 .b2 .c3,
.a3 .b3 .c1,
.a3 .b3 .c2,
.a3 .b3 .c3 {...}
</pre>

<p>
ここには、
入子ng~levelが 3 つあり，
各~levelは 3 個の選択子からなる~listを伴う
— 糖衣を外した結果， 27 個の選択子が生産される。
［
~listに もっと選択子を追加する／
もっと入子ng~levelを追加する／
入子な規則をもっと複階的にする
］ことで，［
何~megabyteもの（あるいは，それを遥かに超える）選択子に展開される
］ような比較的~短い規則を作れる。
◎
Here, three levels of nesting, each with three selectors in their lists, produced 27 desugared selectors. Adding more selectors to the lists, adding more levels of nesting, or making the nested rules more complex can make a relatively small rule expand into multiple megabytes of selectors (or much, much more!).
</p>

<p>
一部の~CSS~toolは、
一部の~variationを経験的に破棄することにより，この最悪な~~事態を避ける
— なので、
それほど多量に出力せずとも，`おそらく^em正しいものになろう【？】。
が、
それは~UAに可用な~optionではない。
◎
Some CSS tools avoid the worst of this by heuristically discarding some variations, so they don’t have to output as much but are still probably correct, but that’s not an option available to UAs.
</p>

<p>
この問題は、
代わりに `is()$ps を通して糖衣を外すことで解消される
— それは、
詳細度の有用さを少し減らす~costを伴うが，適度な~trade-offと判定された。
◎
Desugaring with :is() instead eliminates this problem entirely, at the cost of making specificity slightly less useful, which was judged a reasonable trade-off.
</p>
</details>

<p>
`入子ng選択子$は、
`合体~選択子$内のどこでも許容される
— ［
`合体~選択子$の中の順序付けに対する通常の制約
］に違反することになる，`型~選択子$の前であっても。
◎
The nesting selector is allowed anywhere in a compound selector, even before a type selector, violating the normal restrictions on ordering within a compound selector.
</p>

<div class="example">
<p>
例えば， `&amp;div^css は、
次を意味する妥当な入子ng選択子である
⇒
“何であれ，親~規則が合致するものに
— それが `div^e 要素でもある場合に限り —
合致する”
◎
For example, &amp;div is a valid nesting selector, meaning "whatever the parent rules matches, but only if it’s also a div element".
</p>

<p>
`div&amp;^css として書いても，同じ意味を伴うことになるが、
それは，`入子な~style規則$を開始するには妥当でなくなる
（が、選択子の先頭~以外には，利用できる）。
◎
It could also be written as div&amp; with the same meaning, but that wouldn’t be valid to start a nested style rule (but it could be used somewhere other than the very start of the selector).
</p>
</div>

	</section>
	<section id="cssom">
<h2 title="CSSOM">4. ~CSSOM</h2>

		<section id="cssom-style">
<h3 title="Modifications to CSSStyleRule">4.1. `CSSStyleRule^I に対する改変</h3>

<p>
~CSS~style規則は、入子な規則を有する能を~~新たに得る：
◎
CSS style rules gain the ability to have nested rules:
</p>

<pre class="idl">
partial interface `CSSStyleRule$I {
  [`SameObject$] readonly attribute `CSSRuleList$I `cssRules$m;
  `unsigned long$ `insertRule$m(`CSSOMString$ %rule, optional `unsigned long$ %index = 0);
  `undefined$ `deleteRule$m(`unsigned long$ %index);
};
</pre>

<div class="algo">
`cssRules@m
取得子~手続きは
⇒
~RET コレの`子~規則~list$を表現している `CSSRuleList$I ~obj
◎
The cssRules attribute must return a CSSRuleList object for the child CSS rules.
</div>

<div class="algo">
`insertRule(rule, index)@m
~method手続きは
⇒
~RET `~CSS規則~listに規則を挿入する$( コレの`子~規則~list$, %rule, %index )
◎
The insertRule(rule, index) method must return the result of invoking insert a CSS rule rule into the child CSS rules at index.
</div>

<div class="algo">
`deleteRule(index)@m
~method手続きは
⇒
`~CSS規則~listから規則を除去する$( コレの`子~規則~list$, %index )

◎
The deleteRule(index) method must remove a CSS rule from the child CSS rules at index.
</div>

<p class="note">注記：
入子な規則を伴う `CSSStyleRule$I の直列化は、
`CSSOM$r の`~CSS規則を直列化する$ことを介して，
すでに きちんと定義されている。
◎
Note: Serialization of CSSStyleRule with nested rules are already well-defined by [CSSOM], via serialize a CSS rule.
</p>

<div class="issue">
<p>
`cssRules^m を［
`CSSStyleRule$I, `CSSStyleDeclaration$I
］どちらに付するか
（前者は、ここで述べたとおり／
後者は、将来の作業と整合するよう，
`style^c 属性が入子な規則も有することを許容する）
は、
依然として~openな問いである。
◎
Whether we attach .cssRules to CSSStyleRule, as described here, or to CSSStyleDeclaration (to be consistent with future work allowing `style` attributes to have nested rules) is still an open question.
</p>

<p>
また，それを `style^c 属性に付することは、
既存の~codeが `rule.style=""^c を設定して，…を期待して …† を意味する。
【†文が途切れていて意図不明。】
◎
Also, attaching it to .style means existing code setting rule.style="" and expecting
</p>

<p>
（ `7850$issue ）
◎
(Issue 7850)
</p>
</div>

		</section>
	</section>
</main></div>
