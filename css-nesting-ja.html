<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Nesting Module （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand,
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const link_map = this.link_map;
	let context_prop = '';
	const class_map = this.class_map;
	const tag_map = this.tag_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'v': // css values
	href = context_prop + key;
	break;
case 'm':
case 'mS':
case 'mN':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
	}
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Nesting Module
spec_date:2022-01-04
trans_update:2022-01-06
source_checked:210827
page_state_key:CSS
original_url:https://drafts.csswg.org/css-nesting/
	abbr_url:CSSNESTING
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2022,permissive
trans_1st_pub:2019-07-04


●●class_map
p:property
css:css
ps:pseudo
pe:pseudo
at:at-rule
v:value
e:element
U:code-point
cn:cp-name

●●tag_map
p:code
t:var
css:code
ps:code
pe:code
at:code
v:code
e:code
c:code
m:code
mS:code
mN:code
I:code
U:span
cn:span
em:em
i:i

●●original_id_map


●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
PutForwards:~WEBIDLjs#PutForwards
unsigned long:~WEBIDL#idl-unsigned-long
undefined:~WEBIDL#idl-undefined
CSSOMString:~CSSOM1#cssomstring

I.CSSNestingRule:#cssnestingrule
I.CSSRule:~CSSOM1#cssrule
I.CSSRuleList:~CSSOM1#cssrulelist
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration
I.CSSStyleRule:~CSSOM1#cssstylerule

mN.cssRules:#dom-cssnestingrule-cssrules
mN.deleteRule:#dom-cssnestingrule-deleterule
mN.insertRule:#dom-cssnestingrule-insertrule
mN.selectorText:#dom-cssnestingrule-selectortext
mN.style:#dom-cssnestingrule-style

mS.cssRules:#dom-cssstylerule-cssrules
mS.deleteRule:#dom-cssstylerule-deleterule
mS.insertRule:#dom-cssstylerule-insertrule
	mS.selectorText:~CSSOM1#dom-cssstylerule-selectortext

m.cssText:~CSSOM1#dom-cssstyledeclaration-csstext

	●CSS
at.nest:#at-ruledef-nest
css.&amp;:#selectordef-
ps.where():~SELECTORS4#where-pseudo
ps.is():~SELECTORS4#matches-pseudo
p.color:~CSSCOLOR#propdef-color
t.declaration-list:~CSSSYN#typedef-declaration-list
t.selector-list:~SELECTORS4#typedef-selector-list
t.style-block:~CSSSYN#typedef-style-block
t.stylesheet:~CSSSYN#typedef-stylesheet


直に入子に:#direct-nesting
入子な~style規則:#nested-style-rule
入子な条件付き規則:#conditionals
入子な条件付き~group規則:#nested-conditional-group-rules
入子ng選択子:#nesting-selector
入子を包含して:#nest-containing
入子を接頭して:#nest-prefixed

詳細度:~SELECTORS4#specificity
型~選択子:~SELECTORS4#type-selector
単体~選択子:~SELECTORS4#simple
複体~選択子:~SELECTORS4#complex
合体~選択子:~SELECTORS4#compound
選択子~list:~SELECTORS4#selector-list
選択子:~SELECTORS4#selector

~cascade:~CASCADE#cascade
出現順序:~CASCADE#cascade-order
	~CASCADE#cascade-sort
~style規則:~CSSSYN#style-rule
	宣言:~CSSSYN#declaration

条件付き~group規則:~CSSCOND#conditional-group-rule

~CSS規則~listから規則を除去する:~CSSOM1#remove-a-css-rule
~CSS規則~listに規則を挿入する:~CSSOM1#insert-a-css-rule
~CSS規則を直列化する:~CSSOM1#serialize-a-css-rule
宣言~block:~CSSOM1#css-declaration-block
子~規則~list:~CSSOM1#concept-css-rule-child-css-rules
宣言~群:~CSSOM1#cssstyledeclaration-declarations
宣言~群を直列化する:~CSSOM1#serialize-a-css-declaration-block
所有者~node:~CSSOM1#cssstyledeclaration-owner-node
指定d順序:~CSSOM1#concept-declarations-specified-order
算出-済みか:~CSSOM1#cssstyledeclaration-computed-flag
親~CSS規則:~CSSOM1#cssstyledeclaration-parent-css-rule
選択子~list:~SELECTORS4#selector-list
選択子~listとして構文解析する:~CSSOM1#parse-a-group-of-selectors
選択子~listを直列化する:~CSSOM1#serialize-a-group-of-selectors

●●words_table1

●●words_table

	●CSS
単体:simple::~
複体:complex::~
合体:compound::~
詳細度:specificity::~
条件付き:conditional::~
	条件付き規則:conditional
CSSOM:
宣言~群:declarations:宣言 list::宣言リスト
出現順序:order of appearance:~

	^v:red
	^v:blue

	●構造
直な:directな:~
	~group分け:grouping
入子を:nest-::入れ子を
入子法:nesting::入れ子法
	それらの順序:relative order
参照r:refer:参照

	●構文
接頭-:prefix::~
先読み:lookahead:~
糖衣:sugar::~
	糖衣を外す:desugar
集約-:aggregate:~
重複:duplication:~
周囲の:surrounding:~
勝つ:winする:~
	勝つ:lose
導入部:prelude::~
混合-:mix:~
量:amount:~
展開-:expand:~

	混合-法:mixing
	片:bit of
	来る:come
	記され:written
	書き方:how they’re written
	書く:write
	〜を書くための:〜-writing
	明らかにする:tell
	明らかになる:can tell
	明らかにならない:can't tell
	中で一緒にされ:directly appended together
	識別子:ident
	混在させ:intermix
	~~入力:seeing
	積み上げる:stack up
	配列し直-:rearrange
	わずかな:small
	短い:small
	二重にする:doubled-up
	回数:repetition
	何回も繰返される:have significant repetition
	来る:come

	●仕様
際限ない:unboundedな:~
保守能:maintainability:~
編集-:edit:~
編集:editing:~
背後:behind:~
危険要因:hazard:~
素朴:naive:~
機能-:function:~
課す:imposeする:~
課され:imposeされ:~
良さげ:nice:~
予期せず:unexpectedに:~
複雑:complicated:~
採用-:adopt:~
想定-:suppose:~
組織化-:organize:~
	組織化-:organization
普通の:ordinaryな:~
密接:close:~
対処-:work around:~
指数関数的:exponential:~
爆発:explosion:~
膨大:massive:~
不用意:accidental:~
適度:reasonable:~
判定-:judge:~
経験的:heuristical:~
導入:introduction:~
refactor:
variation::::バリエーション
trade-off::::トレードオフ
比較的:relativeに:~

	~module性:modularity
	アリ性:possibility
	受容-可能でない:unacceptable
	高める:increase
	見える:look
	さほど〜でない:moderately
	許容されない:disallow
	難を覚える:find 〜 challenging
	それこそが:that is, after all
	また:As well
	要:the entire point
	適用-可能:applicable
	脆さ:fragile
	これまでの:to date
	同じに:identically
	-:portion of 〜 for one version of the [CSS3COLOR] module
	-:tho,
	可能に:able to refer
	一致する:equivalent
	-:Tie into
	〜ようになる:presence
	在る場合:In the presence of
	~~新たに得る:gain
	このように:how it
	最終的に:finally
	別として:aside from
	何もかも:everything
	〜かどうか調べる:looking for
	多少の違い:slight difference
	ついて来る:comes with
	課-:impose
	~~分別:apart
	~~調整-:tune
	以前からある:predate
	多くが〜こともあって:largely because
	遥かに超える:much, much more!
	最悪な~~事態:the worst
	解消される:eliminate 〜 entirely
	作れる:make
	それほど多量に:as much
	築き上げる:build up
	有用さを少し減らす:making 〜 slightly less useful
	注意:notably
	〜だけで／それ自体:on 's own
	最終的:eventual
	ではなぜ:That skirts the question, tho:
	役立たずに見える:silly
	^en:versus

	●未分類
重合する:overlapする:重なり合う
連結-:concatenate:~
megabyte::::メガバイト
component::::コンポーネント

	Sass
	BEM

	^v:blue
	^v:red

	得られる:get
	遅く:slower
	%規則~list:rules
	%宣言~群:decls

	●指示語
	他にも:besides
	より少ない:fewer
	一体として:as a whole
	可能:able
	小さな:small
	最も近い:nearest
	最も高い:highest
	より高い:larger
	最も高い:largest
	〜を問わず:of either 〜
	いくつもの:lots of
	他:otherwise
	-:individual


●●ref_normative

[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. 15 December 2021. WD. URL: https://www.w3.org/TR/css-color-4/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. 23 December 2021. CR. URL: https://www.w3.org/TR/css-conditional-3/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. 24 December 2021. CR. URL: https://www.w3.org/TR/css-syntax-3/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. 26 August 2021. WD. URL: https://www.w3.org/TR/cssom-1/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. ＜CSS Color Module Level 3＞. 5 August 2021. REC. URL: https://www.w3.org/TR/css-color-3/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Nesting Module</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-nesting-1/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-nesting-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="https://nerdy.dev/">Adam Argyle</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-nesting-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-nesting-1
</script>

<body>

<header>
	<hgroup>
<h1>CSS Nesting Module</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~moduleは、`~style規則$を別の規則の内側に
— 親~規則の選択子に相対的な子~規則の選択子を伴わせて —
入子にする能を導入する。
これは、~CSS~stylesheetの~module性と保守能を高める。
◎
This module introduces the ability to nest one style rule inside another, with the selector of the child rule relative to the selector of the parent rule. This increases the modularity and maintainability of CSS stylesheets.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この~moduleは、別の`~style規則$の中に~style規則を入子にするための~supportを述べる
— それは、内縁~規則の選択子が，外縁~規則に合致した要素を参照できるようにする。
この特能は、関係し合う~styleたちを~CSS文書の中の単独の構造に集約できるようにして，可読性と保守能を改善する。
◎
This module describes support for nesting a style rule within another style rule, allowing the inner rule’s selector to reference the elements matched by the outer rule. This feature allows related styles to be aggregated into a single structure within the CSS document, improving readability and maintainability.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、 `CSS21$r 構文解析器~modelを拡張する新たな構文解析器~規則を導入する。
また、 `SELECTORS4$r ~moduleを拡張する選択子も導入する。
◎
This module introduces new parser rules that extend the [CSS21] parser model. This module introduces selectors that extend the [SELECTORS4] module.
</p>

		</section>
		<section id="values">
<h3 title="Values">1.2. 値</h3>

<p>
この仕様は、新たな~propや値は定義しない。
◎
This specification does not define any new properties or values.
</p>

		</section>
		<section id="motivation">
<h3 title="Motivation">1.3. 動機</h3>

<p>
さほど複雑でない~web~page用の~CSSであっても、
互いに関係する内容を~styleする目的に，いくつもの重複を含むことが多い。
例えば、次の~CSS~markup【！for one version of the [CSS-COLOR-3] module】は，互いに関係する~style規則をいくつか含んでいるが：
◎
The CSS for even moderately complicated web pages often include lots of duplication for the purpose of styling related content. For example, here is a portion of the CSS markup for one version of the [CSS-COLOR-3] module:
</p>

<pre class="lang-css">
table.colortable td {
  text-align:center;
}
table.colortable td.c {
  text-transform:uppercase;
}
table.colortable td:first-child, table.colortable td:first-child+td {
  border:1px solid black;
}
table.colortable th {
  text-align:center;
  background:black;
  color:white;
}
</pre>

<p>
入子法を用いれば，次の様に~group化できるようになる：
◎
Nesting allows the grouping of related style rules, like this:
</p>

<pre class="lang-css">
table.colortable {
  &amp; td {
    text-align:center;
    &amp;.c { text-transform:uppercase }
    &amp;:first-child, &amp;:first-child + td { border:1px solid black }
  }
  &amp; th {
    text-align:center;
    background:black;
    color:white;
  }
}
</pre>

<p>
重複を除去することの他にも、関係する規則の~group分けは，結果の~CSSの可読性と保守能を改善する。
◎
Besides removing duplication, the grouping of related rules improves the readability and maintainability of the resulting CSS.
</p>

		</section>
	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="nesting">
<h2 title="Nesting Style Rules">2. ~style規則の入子法</h2>

<p>
~style規則は、他の~style規則の内側に入子にできる。
これらの
`入子な~style規則@
は、普通の~style規則と正確に同じ様に動作する
— すなわち、選択子を介して，要素に~prop群を結付ける —
が、
それらは親~規則の選択子~文脈を “継承する” ことで，選択子を
— 場合によっては複数回~繰返す必要なく —
親の選択子の上に更に築くことを許容する。
◎
Style rules can be nested inside of other styles rules. These nested style rules act exactly like ordinary style rules—associating properties with elements via selectors—but they "inherit" their parent rule’s selector context, allowing them to further build on the parent’s selector without having to repeat it, possibly multiple times.
</p>

<p>
`入子な~style規則$を作成するための構文には、
次に挙げる 2 つがあり，互いに密接に関係する：
◎
There are two closely-related syntaxes for creating nested style rules:
</p>
<ul>
	<li>
`直に入子に$する
⇒
`入子な~style規則$は，親~規則の内側で通常通り記されるが、
その選択子は，`入子を接頭して$いるとする要件を伴う。
◎
Direct nesting, where the nested style rule is written normally inside the parent rule, but with the requirement that the nested style rule’s selector is nest-prefixed.
</li>
	<li>
`nest$at 規則
⇒
`入子な~style規則$の選択子に対し課される拘束は、より少ない。
◎
The @nest rule, which imposes less constraints on the nested style rule’s selector.
</li>
</ul>

<p>
書き方における多少の違いは別として、
これら両~手法は，機能性に関しては正確に等価になる。
◎
Aside from the slight difference in how they’re written, both methods are exactly equivalent in functionality.
</p>

<details class="note">
<summary>
なぜ，何もかも直に入子にできないのか？
◎
Why can’t everything be directly nested?
</summary>

<p>
あいにく，素朴に［
`~style規則$の内側に別の~style規則を入子にする
］だけでは、多義的になる。
選択子の構文【 `selector-list$t 】と宣言の構文【 `declaration-list$t 】は重合するので、所与の~text片が［
宣言，ある~style規則の開始
］どちらなのか明らかにするため，実装には際限ない先読みが要求される。
◎
Nesting style rules naively inside of other style rules is, unfortunately, ambiguous—the syntax of a selector overlaps with the syntax of a declaration, so an implementation requires unbounded lookahead to tell whether a given bit of text is a declaration or the start of a style rule.
</p>

<p>
例えば，ある構文解析器に対する~~入力が
`color:hover ...^css から開始している場合、
それが［
`color$p ~prop（無効な値 `hover^v に設定されている）,
`color^e 要素~用の選択子
］どちらなのかは明らかにならない。
この相違を［
妥当な~propを成すかどうか調べることで明らかにする
］ことにさえ依拠できない
— そうすると、構文解析は［
実装が どの~prop【あるいは，~propのどの値】を~supportするか
］に依存するようになり，時を経れば変化し得ることにもなる。
◎
For example, if a parser starts by seeing color:hover ..., it can’t tell whether that’s the color property (being set to an invalid value...) or a selector for a &lt;color&gt; element. It can’t even rely on looking for valid properties to tell the difference; this would cause parsing to depend on which properties the implementation supported, and could change over time.
</p>

<p>
この問題は、［
直に入子にされた~style規則には，`入子を接頭して$いる選択子を利用するよう要求する
］ことで対処される
— `&amp;$css は，宣言の一部を`決して^em成し得ないので、
構文解析器にとっては［
選択子を構文解析しようとしていて，入子な~style規則であること
］が即時に明らかになる。
◎
Requiring directly-nested style rules to use nest-prefixed selectors works around this problem—an &amp; can never be part of a declaration, so the parser can immediately tell it’s going to be parsing a selector, and thus a nested style rule.
</p>

<p>
一部の非~browserによる入子な規則の実装は、この要件を課さない。
~propと選択子の~~分別を明らかにすることは、
ほとんどの事例では`最終的^emにはアリだが，
そのためには構文解析器に際限ない先読みが要求される。
すなわち，構文解析器は、［
どちらの仕方で解釈するよう想定されているか明らかになる
］まで，未知な量の内容を保持する必要も生じ得る。
これまでの~CSSは，［
より効率的な構文解析~algoを許容する
］よう［
構文解析において，既知な わずかな量の先読みしか要求していない
］ので、
際限ない先読みは，一般に［
~browserによる~CSSの実装においては、受容-可能でない
］と見なされる。
◎
Some non-browser implementations of nested rules do not impose this requirement. It is, in most cases, eventually possible to tell properties and selectors apart, but doing so requires unbounded lookahead in the parser; that is, the parser might have to hold onto an unknown amount of content before it can tell which way it’s supposed to be interpreting it. CSS to date requires only a small, known amount of lookahead in its parsing, which allows for more efficient parsing algorithms, so unbounded lookahead is generally considered unacceptable among browser implementations of CSS.
</p>
</details>

		<section id="direct">
<h3 title="Direct Nesting">2.1. 直な入子法</h3>

<p>
~style規則は、その選択子が
`入子を接頭して@
いる（ `nest-prefixed^en ）ならば，別の~style規則の中に
`直に入子に@
できる：
◎
A style rule can be directly nested within another style rule if its selector is nest-prefixed.
</p>
<ul>
	<li>
`複体~選択子$が`入子を接頭して$いるためには、その最初の`合体~選択子$の最初の`単体~選択子$が，`入子ng選択子$（ `&amp;^css ）になっていなければナラナイ。
◎
To be nest-prefixed, a nesting selector must be the first simple selector in the first compound selector of the selector.＼
</li>
	<li>
`選択子~list$が`入子を接頭して$いるためには、~list内のどの`複体~選択子$も`入子を接頭して$いなければナラナイ。
◎
If the selector is a list of selectors, every complex selector in the list must be nest-prefixed for the selector as a whole to be nest-prefixed.
</li>
</ul>

<div class="example">
<p>
例えば，以下に挙げる入子ngは、妥当になる：
◎
For example, the following nestings are valid:
</p>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css は、それだけでも選択子として利用できる：
◎
&amp; can be used on its own
</span> */
.foo {
  color: blue;
  &amp; &gt; .bar { color: red; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo &gt; .bar { color: red; }
*/

/* <span class="comment">
あるいは、`合体~選択子$内で，親の選択子を精緻化する：
◎
or in a compound selector, refining the parent’s selector
</span> */
.foo {
  color: blue;
  &amp;.bar { color: red; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo.bar { color: red; }
*/

/* <span class="comment">
選択子~listを成す各~選択子は、
どれも `&amp;^css から開始しなければならない：
◎
multiple selectors in the list must all start with &amp;
</span> */
.foo, .bar {
  color: blue;
  &amp; + .baz, &amp;.qux { color: red; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo, .bar { color: blue; }
  :is(.foo, .bar) + .baz,
  :is(.foo, .bar).qux { color: red; }
*/

/* <span class="comment">
`&amp;^css は、単独の選択子~内で複数回~利用できる：
◎
&amp; can be used multiple times in a single selector
</span> */
.foo {
  color: blue;
  &amp; .bar &amp; .baz &amp; .qux { color: red; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo .bar .foo .baz .foo .qux { color: red; }
*/

/* <span class="comment">
いくぶん役立たずに見えるが、
`&amp;^css だけでも利用できる。
◎
Somewhat silly, but can be used all on its own, as well.
</span> */
.foo {
  color: blue;
  &amp; { padding: 2ch; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo { padding: 2ch; }

// <span class="comment">
あるいは
◎
or
</span>

  .foo {
    color: blue;
    padding: 2ch;
  }
*/

/* <span class="comment">
これも役立たずに見えるが、二重にすることもできる。
◎
Again, silly, but can even be doubled up.
</span> */
.foo {
  color: blue;
  &amp;&amp; { padding: 2ch; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo.foo { padding: 2ch; }
*/

/* <span class="comment">
親~選択子は、任意に複雑にできる：
◎
The parent selector can be arbitrarily complicated
</span> */
.error, #404 {
  &amp;:hover &gt; .baz { color: red; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  :is(.error, #404):hover &gt; .baz { color: red; }
*/

/* <span class="comment">
同じく，入子な選択子も：
◎
As can the nested selector
</span> */
.foo {
  &amp;:is(.bar, &amp;.baz) { color: red; }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo:is(.bar, .foo.baz) { color: red; }
*/

/* <span class="comment">
選択子を複数~levelに入子にして “積み上げる” ：
◎
Multiple levels of nesting "stack up" the selectors
</span> */
figure {
  margin: 0;

  &amp; &gt; figcaption {
    background: hsl(0 0% 0% / 50%);

    &amp; &gt; p {
      font-size: .9rem;
    }
  }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  figure { margin: 0; }
  figure &gt; figcaption { background: hsl(0 0% 0% / 50%); }
  figure &gt; figcaption &gt; p { font-size: .9rem; }
*/
</pre>

<p>
一方で、以下に挙げるものは，妥当でない：
◎
But these are not:
</p>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css がまったく無い：
◎
No &amp; at all
</span> */
.foo {
  color: blue;
  .bar {
    color: red;
  }
}

/* <span class="comment">
`&amp;^css が最初の`単体~選択子$でない：
◎
&amp; isn’t the first simple selector
</span> */
.foo {
  color: blue;
  .bar&amp; {
    color: red;
  }
}

/* <span class="comment">
選択子~list内に，
最初の`単体~選択子$が `&amp;^css でないものがある：
◎
&amp; isn’t the first selector of every one in the list
</span> */
.foo, .bar {
  color: blue;
  &amp; + .baz, .qux { color: red; }
}
</pre>

<p>
最後の無効な例は、［
一体としての選択子が `&amp;$css で開始するので、
形上では多義的ではない
］が，編集-時の危険要因になる
— 当の規則が~refactorされ，
~listを成す最初の選択子を除去したり，
~list内の選択子たちを配列し直した場合、
その結果
— 通常は、常に妥当であり続けるはずの結果 —
は多義的になり，無効な選択子になる。
◎
The last example here isn’t technically ambiguous, since the selector as a whole does start with an &amp;, but it’s an editing hazard—if the rule is refactored to remove the first selector or rearrange the selectors in the list, which normally would always remain valid, it would result in a now-ambiguous invalid selector.
</p>
</div>

<div class="note">
<p>注記：
~CSSを生成する一部の~toolは、選択子を文字列の様に連結して，
複数の入子ng~levelにまたがる 1 個の単体~選択子を築き上げることを作者に許容する。
これは、
【！`https://en.wikipedia.org/wiki/CSS#:~:text=bem%20(block%2C%20element%2C%20modifier)"^】
<abbr title="Block, Element, Modifier">BEM</abbr>
の様な選択子を組織化する手法により，ときどき利用される
— 当の選択子が内部的に何回も繰返されるとき、その回数を抑制するためとして。
◎
Some CSS-generating tools will concatenate selectors like strings, allowing authors to build up a single simple selector across nesting levels. This is sometimes used by selector-organization methods like BEM to reduce repetition across a file, when the selectors themselves have significant repetition internally.
</p>

<p>
例えば、
ある~componentが~class `.foo^css を利用していて，
ある入子な~componentが~class `.foo__bar^css を利用している場合、
<a href="https://sass-lang.com/">Sass</a>
においては，これを次のように書くこともできる：
◎
For example, if one component uses the class .foo, and a nested component uses .foo__bar, you could write this in Sass as:
</p>

<pre class="lang-css">
.foo {
  color: blue;
  &amp;__bar { color: red; }
}
/* <span class="comment">
Sass においては、これは次と等価になる：
◎
In Sass, this is equivalent to
</span>
   .foo { color: blue; }
   .foo__bar { color: red; }
*/
</pre>

<p>
あいにく，この手法は、一般における選択子~構文と整合でない
— 最善でも、［
特に選択子を書くための実施
］に~~調整された経験則を要求する
— ［
作者が いつ それを求めるか
`, versus^en
作者が 当の入子にされる規則~内に`型~選択子$を追加しようと試みる
］【？】を認識するための。
例えば `__bar^css は、
~HTMLにおける妥当な <a href="~HEcustom">~custom要素~名</a>`である^em。
◎
Unfortunately, this method is inconsistent with selector syntax in general, and at best requires heuristics tuned to particularly selector-writing practices to recognize when the author wants it, versus the author attempting to add a type selector in the nested rule. __bar, for example, is a valid custom element name in HTML.
</p>

<p>
そのようなわけで、~CSSでは，これは行えない
— 入子な選択子~成分は、それ自体として解釈され， “連結-” されない：
◎
As such, CSS can’t do this; the nested selector components are interpreted on their own, and not "concatenated":
</p>

<pre class="lang-css">
.foo {
  color: blue;
  &amp;__bar { color: red; }
}
/* <span class="comment">
これは、~CSSにおいては、代わりに次と等価になる：
◎
In CSS, this is instead equivalent to
</span>
   .foo { color: blue; }
   __bar.foo { color: red; }
*/
</pre>
</div>

		</section>
		<section id="at-nest">
<h3 title="The Nesting At-Rule: @nest">2.2. ~at-ruleの入子法： `nest^at</h3>

<p>
`直に入子に$する手法は良さげに見えるが，いくぶん脆さもある。
`.foo &amp;^css の様な一部の妥当な入子ng選択子は，ここでは許容されないことに加え、ある種の仕方で編集すると予期せず規則を無効にし得る。
また、一部の作者は，周囲の宣言から入子ngを視覚的に判別することに難を覚えることもある。
◎
While direct nesting looks nice, it is somewhat fragile. Some valid nesting selectors, like .foo &amp;, are disallowed, and editing the selector in certain ways can make the rule invalid unexpectedly. As well, some authors find the nesting challenging to distinguish visually from the surrounding declarations.
</p>

<p>
これらすべての課題を援助するため、この仕様は `nest$at 規則を定義する。
~style規則を妥当に入子にするために課される制約は、こちらの方が少ない。
その構文は：
◎
To aid in all these issues, this specification defines the @nest rule, which imposes fewer restrictions on how to validly nest style rules. Its syntax is:
</p>

<pre class="prod">
`nest@at = @nest `selector-list$t { `style-block$t }
</pre>

<p>
`nest$at 規則が妥当になるのは、`~style規則$の内側に限られる。
他の文脈（特に, ~stylesheetの~top-level）内で利用された場合、
当の規則は無効になる。
◎
The @nest rule is only valid inside of a style rule. If used in any other context (particularly, at the top-level of a stylesheet) the rule is invalid.
</p>

<p>
`nest$at 規則は、`入子な~style規則$と同じに機能する。
それは、ある選択子から開始する
— ~~後続する~blockは、当の選択子に合致する要素に適用される宣言~群を包含する。
この~blockは，`~style規則$の~blockと同じに扱われるので、
`~style規則$内で妥当なもの（追加的な `nest$at 規則など）は，ここでも妥当になる。
◎
The @nest rule functions identically to a nested style rule: it starts with a selector, and contains a block of declarations that apply to the elements the selector matches. That block is treated identically to a style rule’s block, so anything valid in a style rule (such as additional @nest rules) is also valid here.
</p>

<p>
`nest$at と`直に入子に$された`~style規則$との唯一の相違は、
利用する選択子に対する拘束にある
— 前者の選択子は
`入子を包含して@
（ `nest-containing^en ）いなければナラナイ
— それは、`入子を接頭して$いなければナラナイ後者より，拘束されない：
◎
The only difference between @nest and a directly nested style rule is that the selector used in a @nest rule is less constrained: it only must be nest-containing,＼
</p>
<ul>
	<li>
`複体~選択子$は、`どこか^emに`入子ng選択子$を包含するならば，`入子を包含して$いるとされる
— 各~選択子の開始に要求されるのではなく。
◎
which means it contains a nesting selector in it somewhere, rather than requiring it to be at the start of each selector.＼
</li>
	<li>
`選択子~list$は、それを成す どの`複体~選択子$も`入子を包含して$いるならば，`入子を包含して$いるとされる。
◎
A list of selectors is nest-containing if all of its individual complex selectors are nest-containing.
</li>
</ul>

<div class="example">
<p>
`直に入子に$することで行えることは，
`nest$at 規則でも行えるので、
次は妥当になる：
◎
Anything you can do with direct nesting, you can do with an @nest rule, so the following is valid:
</p>

<pre class="lang-css">
.foo {
  color: red;
  @nest &amp; &gt; .bar {
    color: blue;
  }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  .foo &gt; .bar { color: blue; }
*/
</pre>

<p>
一方で `nest$at は， `&amp;$css で開始しない選択子も許容するので、
次に挙げるものも妥当になる：
◎
But @nest allows selectors that don’t start with an &amp;, so the following are also valid:
</p>

<pre class="lang-css">
.foo {
  color: red;
  @nest .parent &amp; {
    color: blue;
  }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  .parent .foo { color: blue; }
*/

.foo {
  color: red;
  @nest :not(&amp;) {
    color: blue;
  }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  :not(.foo) { color: blue; }
*/
</pre>

<p>
一方で、次に挙げるものは無効になる：
◎
But the following are invalid:
</p>

<pre class="lang-css">
.foo {
  color: red;
  @nest .bar {
    color: blue;
  }
}
/* <span class="comment">
これは、入子ng選択子が無いので，無効になる。
◎
Invalid because there’s no nesting selector
</span> */

.foo {
  color: red;
  @nest &amp; .bar, .baz {
    color: blue;
  }
}
/* <span class="comment">
これは、選択子~list内に`入子ng選択子$を伴わないものがあるので，無効になる
◎
Invalid because not all selectors in the list contain a nesting selector
</span> */
</pre>
</div>

<div class="example">
<p>
`直に入子に$された`~style規則$と `nest$at 規則は、任意に混合できる。
例えば：
◎
Directly nested style rules and @nest rules can be arbitrarily mixed. For example:
</p>

<pre class="lang-css">
.foo {
  color: blue;
  @nest .bar &amp; {
    color: red;
    &amp;.baz {
      color: green;
    }
  }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .bar .foo { color: red; }
  .bar .foo.baz { color: green; }
</pre>
</div>

		</section>
		<section id="conditionals">
<h3 title="Nesting Conditional Rules">2.3. 条件付き規則の入子法</h3>

<p>
`nest$at 規則と`直に入子に$された~style規則に加えて、
この仕様は，`~style規則$の内側に
`入子な条件付き~group規則@
も許容する。
◎
In addition to @nest rules and directly nested style rules, this specification allows nested conditional group rules inside of style rules.
</p>

<p>
`条件付き~group規則$が，この仕方で入子にされたときは、
当の規則の内容は、 `stylesheet$t としてではなく， `style-block$t として構文解析される：
◎
When nested in this way, the contents of a conditional group rule are parsed as &lt;style-block&gt; rather than &lt;stylesheet&gt;:
</p>

<ul>
	<li>
~propは、直に利用でき，親~規則と同じ要素に適用される
（`条件付き~group規則$が合致する【その条件が満たされる】ならば）。
◎
Properties can be directly used, applying to the same elements as the parent rule (when the conditional group rule matches)
</li>
	<li>
`~style規則$は，`直に入子に$されたものと扱われるので、
その選択子は`入子を接頭して$いなければナラナイ
— その`入子ng選択子$は、
その定義を最も近い先祖の`~style規則$からとる。
◎
Style rules are treated as directly nested, and so must have nest-prefixed selectors, with their nesting selector taking its definition from the nearest ancestor style rule.
</li>
	<li>
`nest$at 規則も許容される
— その中の`入子ng選択子$もまた、
その定義を最も近い先祖の`~style規則$からとる。
◎
@nest rules are allowed, again with their nesting selector taking its definition from the nearest ancestor style rule.
</li>
</ul>

<p class="note">注記：
このことは、［
`入子ng選択子$を伴わない “通常の” ~style規則は、
`入子な条件付き~group規則$内では無効になる
］ことを含意する。
◎
Note: This implies that "normal" style rules, without a nesting selector, are invalid in a nested conditional group rule.
</p>

<div class="example">
<p>
例えば，次に挙げる条件付き規則の入子ngは、妥当になる：
◎
For example, the following conditional nestings are valid:
</p>

<pre class="lang-css">
/* <span class="comment">
~propは直に利用できる
◎
Properties can be directly used
</span> */
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
/* <span class="comment">
これは、次と等価になり：
◎
equivalent to
</span>
  .foo {
    display: grid;

    @media (orientation: landscape) {
      &amp; {
        grid-auto-flow: column;
      }
    }
  }
*/
/* <span class="comment">
最終的に次と等価になる：
◎
finally equivalent to
</span>
  .foo { display: grid; }

  @media (orientation: landscape) {
    .foo {
      grid-auto-flow: column;
    }
  }
*/

/* <span class="comment">
条件付きも更に入子にできる
◎
Conditionals can be further nested
</span> */
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;

    @media (min-width &gt; 1024px) {
      max-inline-size: 1024px;
    }
  }
}
/* <span class="comment">
これは、次と等価になる：
◎
equivalent to
</span>
  .foo { display: grid; }

  @media (orientation: landscape) {
    .foo {
      grid-auto-flow: column;
    }
  }

  @media (orientation: landscape) and (min-width &gt; 1024px) {
    .foo {
      max-inline-size: 1024px;
    }
  }
*/
</pre>

<p>
が、次に挙げるものは無効になる：
◎
But the following are invalid:
</p>

<pre class="lang-css">
.foo {
  color: red;

  @media (min-width: 480px) {
    &amp; h1, h2 { color: blue; }
  }
}
/* <span class="comment">
これは、選択子~list内に`入子ng選択子$を伴わないものがあるので，無効になる。
◎
Invalid because not all selectors in the list contain a nesting selector
</span> */

.foo {
  color: red;

  @nest @media (min-width: 480px) {
    &amp; { color: blue; }
  }
}
/* <span class="comment">
これは、［
`nest^at は，その導入部に選択子を期待するが、
代わりに条件付き~group規則が供されている
］ので，無効になる。
◎
Invalid because @nest expects a selector prelude, instead a conditional group rule was provided
</span> */
</pre>
</div>

		</section>
		<section id="mixing">
<h3 title="Mixing Nesting Rules and Declarations">2.4. 入子ng規則と宣言の混合-法</h3>

<p>
~style規則が宣言と［
`入子な~style規則$／`入子な条件付き~group規則$
］どちらも包含するときは、宣言が最初に来なければナラナイ。
— 入子な規則より`後に^em生じる宣言は、どれも無効になり，無視される。
◎
When a style rule contains both declarations and nested style rules or nested conditional group rules, the declarations must come first, followed by the nested rules. Declarations occuring after a nested rule are invalid and ignored.
</p>

<div class="example">
<p>
例えば，次の~codeでは：
◎
For example, in the following code:
</p>

<pre class="lang-css">
article {
  color: green;
  &amp; { color: blue; }
  color: red;
}
</pre>

<p>
宣言 `color: red^css は、`入子な~style規則$より後に生じているので，無効になり無視される。
◎
The color: red declaration is invalid and ignored, since it occurs after the nested style rule.
</p>

<p>
しかしながら，次の例のように、
入子な規則は，無効な宣言より後に生じていても妥当になる：
◎
However, further nested rules are still valid, as in this example:
</p>

<pre class="lang-css">
article {
  color: green;
  &amp; { color: blue; }
  color: red;
  &amp;.foo { color: yellow; } /* <span class="comment">
これは妥当。
◎
valid!
</span> */
}
</pre>
</div>

<p>
`出現順序$を決定する目的においては、［
`入子な~style規則$／
`入子な条件付き~group規則$
］は，その親~規則より`後^emに来るものと見なされる。
◎
For the purpose of determining the Order Of Appearance, nested style rules and nested conditional group rules are considered to come after their parent rule.
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-css">
article {
  color: blue;
  &amp; { color: red; }
}
</pre>

<p>
両~宣言とも，その詳細度は同じ (0,0,1) になるが、
入子な規則は親~規則より`後に来る^emものと見なされるので，
宣言 `color: red^css の方が~cascadeに勝つ。
◎
Both declarations have the same specificity (0,0,1), but the nested rule is considered to come after its parent rule, so the color: red declarations wins the cascade.
</p>

<p>
他方，次の例では：
◎
On the other hand, in this example:
</p>

<pre class="lang-css">
article {
  color: blue;
  @nest :where(&amp;) { color: red; }
}
</pre>

<p>
`where()$ps 疑似類により`入子ng選択子$の詳細度は 0 に抑制されるので，
宣言 `color: red^css の詳細度は (0,0,0) になり、
`出現順序$が考慮される前に，
宣言 `color: blue^css の方が勝つ。
◎
The :where() pseudoclass reduces the specificity of the nesting selector to 0, so the color: red declaration now has a specificity of (0,0,0), and loses to the color: blue declaration before "Order Of Appearance" comes into consideration.
</p>
</div>

		</section>
	</section>
	<section id="nest-selector">
<h2 title="Nesting Selector: the &amp; selector">3. 入子ng選択子： `&amp;^css 選択子</h2>

<p>
`入子な~style規則$を利用するときには、親~規則に合致した要素を参照r可能にならなければならない。
それこそが、`入子法の要^emを成す。
これを成遂げるため、この仕様は，
`&amp;@css
（ `0026^U `AMPERSAND^cn ）として記される新たな選択子として，
`入子ng選択子@
（ `nesting selector^en ）を定義する。
◎
When using a nested style rule, one must be able to refer to the elements matched by the parent rule; that is, after all, the entire point of nesting. To accomplish that, this specification defines a new selector, the nesting selector, written as &amp; (U+0026 AMPERSAND).
</p>

<p>
`入子ng選択子$は、`入子な~style規則$の選択子~内で利用されたときは，親~規則に合致した要素を表現する。
他の文脈~内で利用されたときは、何も表現しない（すなわち、妥当ではあるが，どの要素にも合致しない）。
◎
When used in the selector of a nested style rule, the nesting selector represents the elements matched by the parent rule. When used in any other context, it represents nothing. (That is, it’s valid, but matches no elements.)
</p>

<div class="note">

<p>注記：
`入子ng選択子$による糖衣は、それを［
親~style規則の選択子を `is()$ps 選択子で包装したもの
］に置換することより外せる（ `desugar^en できる）。
例えば：
◎
The nesting selector can be desugared by replacing it with the parent style rule’s selector, wrapped in an :is() selector. For example,
</p>

<pre class="lang-css">
a, b {
  &amp; c { color: blue; }
}
</pre>

<p>
は、次に等価になる：
◎
is equivalent to
</p>

<pre class="lang-css">
:is(a, b) c { color: blue; }
</pre>
</div>

<p>
`入子ng選択子$の`詳細度$は、［
親~style規則の`選択子~list$を成す各`複体~選択子$の`詳細度$
］のうち最も高いものに等しい（ `is()$ps の挙動と一致する）。
◎
The specificity of the nesting selector is equal to the largest specificity among the complex selectors in the parent style rule’s selector list (identical to the behavior of :is()).
</p>

<div class="example">
<p>
例えば，次の~style規則が与えられたなら：
◎
For example, given the following style rules:
</p>
<pre class="lang-css">
#a, b {
  &amp; c { color: blue; }
}
.foo c { color: red; }
</pre>

<p>
次の様な~DOM構造においては：
◎
Then in a DOM structure like
</p>

<pre class="lang-html">
&lt;b class=foo&gt;
  &lt;c&gt;Blue text&lt;/c&gt;
&lt;/b&gt;
</pre>

<p>
~textの色は、 `red^v ではなく `blue^v になる。
`&amp;$css の詳細度は［
`#a^css の詳細度 (1,0,0),
`b^css の詳細度 (0,0,1)
］のうち高い方 (1,0,0) になるので、
選択子~全体 `&amp; c^css の詳細度は (1,0,1) になる,
— それは `.foo c^css の詳細度 (0,1,1) より高い。
◎
The text will be blue, rather than red. The specificity of the &amp; is the larger of the specificities of #a ([1,0,0]) and b ([0,0,1]), so it’s [1,0,0], and the entire &amp; c selector thus has specificity [1,0,1], which is larger than the specificity of .foo c ([0,1,1]).
</p>

<p>
これは、［
入子ngを外して，入子にされない規則に手動で展開した場合に得られる結果
］とは`異なる^emことに注意。
そうした場合、
宣言 `color: blue^css は、
詳細度 (1,0,1) の選択子 `#a c^css ではなく，
詳細度 (0,0,2) の選択子 `b c^css に合致するので。
◎
Notably, this is different than the result you’d get if the nesting were manually expanded out into non-nested rules, since the color: blue declaration would then be matching due to the b c selector ([0,0,2]) rather than #a c ([1,0,1]).
</p>
</div>

<details class="note">
<summary>
なぜ、入子にされない規則とは詳細度が異なるのか？
◎
Why is the specificity different than non-nested rules?
</summary>

<p>
`入子ng選択子$の詳細度は、意図的に，
`is()$ps 疑似類と同じ規則を利用するようにしてある。
それは、各~引数の中で最も高い詳細度を利用するだけであり，
実際に合致した選択子が`どれなのか^emを追跡しない。
◎
The nesting selector intentionally uses the same specificity rules as the :is() pseudoclass, which just uses the largest specificity among its arguments, rather than tracking which selector actually matched.
</p>

<p>
これは、処理能の理由から要求される。
選択子の詳細度を［
どれだけ精確に合致したかに依存して，アリなものが複数ある
］ようにした場合、
選択子の照合は，ずっと複雑で遅くなる。
◎
This is required for performance reasons; if a selector has multiple possible specificities, depending on how precisely it was matched, it makes selector matching much more complicated and slower.
</p>

<p>
ではなぜ `&amp;$css を `is()$ps の用語で定義するのか？
一部の非~browserによる［
入子法の様な機能性
］の実装は、
その多くが `is()^ps の導入~以前からあることもあって，
その糖衣を
— `is()^ps を通して外すことなく —
直に外す。
しかしながら，これには`有意な問題^emがついて来る
— 一部の（適度に共通的な）事例では、
指数関数的な爆発のアリ性に因り，不用意に`膨大^emな選択子を生産し得るので。
◎
That skirts the question, tho: why do we define &amp; in terms of :is()? Some non-browser implementations of Nesting-like functionality do not desugar to :is(), largely because they predate the introduction of :is() as well. Instead, they desugar directly; however, this comes with its own significant problems, as some (reasonably common) cases can accidentally produce massive selectors, due to the exponential explosion of possibilities.
</p>

<pre class="lang-css">
.a1, .a2, .a3 {
  &amp; .b1, &amp; .b3, &amp; .b3 {
    &amp; .c1, &amp; .c2, &amp; .c3 {
      ...;
    }
  }
}

/* <span class="comment">
素朴に糖衣を外したとすると：
◎
naively desugars to
</span> */
.a1 .b1 .c1,
.a1 .b1 .c2,
.a1 .b1 .c3,
.a1 .b2 .c1,
.a1 .b2 .c2,
.a1 .b2 .c3,
.a1 .b3 .c1,
.a1 .b3 .c2,
.a1 .b3 .c3,
.a2 .b1 .c1,
.a2 .b1 .c2,
.a2 .b1 .c3,
.a2 .b2 .c1,
.a2 .b2 .c2,
.a2 .b2 .c3,
.a2 .b3 .c1,
.a2 .b3 .c2,
.a2 .b3 .c3,
.a3 .b1 .c1,
.a3 .b1 .c2,
.a3 .b1 .c3,
.a3 .b2 .c1,
.a3 .b2 .c2,
.a3 .b2 .c3,
.a3 .b3 .c1,
.a3 .b3 .c2,
.a3 .b3 .c3 {...}
</pre>

<p>
ここには、入子ng~levelが 3 つあり，
各~levelは 3 個の選択子からなる~listを伴う
— 糖衣を外した結果， 27 個の選択子が生産される。
［
~listに もっと選択子を追加する／
もっと入子ng~levelを追加する／
入子な規則をもっと複階的にする
］ことで，［
何~megabyteもの（あるいは，それを遥かに超える）選択子に展開される
］ような比較的~短い規則を作れる。
◎
Here, three levels of nesting, each with three selectors in their lists, produced 27 desugared selectors. Adding more selectors to the lists, adding more levels of nesting, or making the nested rules more complex can make a relatively small rule expand into multiple megabytes of selectors (or much, much more!).
</p>

<p>
一部の~CSS~toolは、
一部の~variationを経験的に破棄することにより，この最悪な~~事態を避ける
— なので、それほど多量に出力せずとも，`おそらく^em正しいものになろう【？】。
が、それは~UAに可用な~optionではない。
◎
Some CSS tools avoid the worst of this by heuristically discarding some variations, so they don’t have to output as much but are still probably correct, but that’s not an option available to UAs.
</p>

<p>
この問題は、代わりに `is()$ps を通して糖衣を外すことで解消される
— それは、詳細度の有用さを少し減らす~costを伴うが，適度な~trade-offと判定された。
◎
Desugaring with :is() instead eliminates this problem entirely, at the cost of making specificity slightly less useful, which was judged a reasonable trade-off.
</p>
</details>

<p>
`入子ng選択子$は、`合体~選択子$内のどこでも許容される
— ［
`合体~選択子$の中の順序付けに対する通常の制約
］に違反することになる，`型~選択子$の前であっても。
◎
The nesting selector is allowed anywhere in a compound selector, even before a type selector, violating the normal restrictions on ordering within a compound selector.
</p>

<div class="example">
<p>
例えば， `&amp;div^css は、次を意味する妥当な入子ng選択子である
⇒
“何であれ，親~規則が合致するものに
— それが `div^e 要素でもある場合に限り —
合致する”
◎
For example, &amp;div is a valid nesting selector, meaning "whatever the parent rules matches, but only if it’s also a div element".
</p>

<p>
`div&amp;^css として書いても，同じ意味を伴うことになるが、
それは，`直に入子に$された`~style規則$を開始するには妥当でなくなる。
◎
It could also be written as div&amp; with the same meaning, but that wouldn’t be valid to start a directly nested style rule.
</p>
</div>


	</section>
	<section id="cssom">
<h2 title="CSSOM">4. ~CSSOM</h2>

		<section id="cssom-style">
<h3 title="Modifications to CSSStyleRule">4.1. `CSSStyleRule^I に対する改変</h3>

<p>
~CSS~style規則は、入子な規則を有する能を~~新たに得る：
◎
CSS style rules gain the ability to have nested rules:
</p>

<pre class="idl">
partial interface `CSSStyleRule$I {
  [`SameObject$] readonly attribute `CSSRuleList$I `cssRules$mS;
  `unsigned long$ `insertRule$mS(`CSSOMString$ %rule, optional `unsigned long$ %index = 0);
  `undefined$ `deleteRule$mS(`unsigned long$ %index);
};
</pre>

<div class="algo">
`cssRules@mS
取得子~手続きは
⇒
~RET コレの`子~規則~list$を表現している `CSSRuleList$I ~obj
◎
The cssRules attribute must return a CSSRuleList object for the child CSS rules.
</div>

<div class="algo">
`insertRule(rule, index)@mS
~method手続きは
⇒
~RET `~CSS規則~listに規則を挿入する$( コレの`子~規則~list$, %rule, %index )
◎
The insertRule(rule, index) method must return the result of invoking insert a CSS rule rule into the child CSS rules at index.
</div>

<div class="algo">
`deleteRule(index)@mS
~method手続きは
⇒
`~CSS規則~listから規則を除去する$( コレの`子~規則~list$, %index )

◎
The deleteRule(index) method must remove a CSS rule from the child CSS rules at index.
</div>

		</section>
		<section id="cssom-nesting">
<h3 title="The CSSNestingRule Interface">4.2. `CSSNestingRule^I ~interface</h3>

<p>
`CSSNestingRule$I ~interfaceは
`nest$at 規則を表現する：
◎
The CSSNestingRule interfaces represents a @nest rule:
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSNestingRule@I : `CSSRule$I {
  attribute `CSSOMString$ `selectorText$mN;
  [`SameObject$, `PutForwards$=`cssText$m] readonly attribute `CSSStyleDeclaration$I `style$mN;
  [`SameObject$] readonly attribute `CSSRuleList$I `cssRules$mN;
  `unsigned long$ `insertRule$mN(`CSSOMString$ %rule, optional `unsigned long$ %index = 0);
  `undefined$ `deleteRule$mN(`unsigned long$ %index);
};
</pre>

<p>
以下の定義に現れる “この規則” は、当の `CSSNestingRule$I ~obj（コレ）が表現している `nest$at 規則を指すとする。
◎
↓</p>


<div class="algo">
<p>
`selectorText@mN
取得子~手続きは
⇒
~RET `選択子~listを直列化する$( この規則の`選択子~list$ )
◎
The selectorText attribute, on getting, must return the result of serializing the associated selector list.＼
</p>
</div>

<div class="algo">
<p>
`selectorText$mN【！`selectorText$mS】
設定子~手続きは：
◎
On setting the selectorText attribute these steps must be run:
</p>
<ol>
	<li>
%選択子 ~LET `選択子~listとして構文解析する$( 所与の値 )
◎
Run the parse a group of selectors algorithm on the given value.
</li>
	<li>
~IF［
%選択子 ~NEQ ~NULL
］
⇒
この規則の`選択子~list$ ~SET %選択子
◎
If the algorithm returns a non-null value replace the associated selector list with the returned value.
◎
Otherwise, if the algorithm returns a null value, do nothing.
</li>
</ol>
</div>

<div class="algo">
<p>
`style@mN
取得子~手続きは
⇒
~RET 次に挙げる~propを伴う`宣言~block$【！~style規則】を表現している`CSSStyleDeclaration$I ~obj
⇒＃
`算出-済みか$ ~SET ~F,
`宣言~群$ ~SET `指定d順序$による，この規則~内で宣言された宣言たち,
`親~CSS規則$ ~SET コレ,
`所有者~node$ ~SET ~NULL
◎
The style attribute must return a CSSStyleDeclaration object for the style rule, with the following properties:
◎
computed flag
• Unset.
◎
declarations
• The declared declarations in the rule, in specified order.
◎
parent CSS rule
• The this object.
◎
owner node
• Null.
</p>
</div>

<div class="algo">
<p>
`cssRules@mN
取得子~手続きは
⇒
~RET この規則の`子~規則~list$を表現している `CSSRuleList$I ~obj
◎
The cssRules attribute must return a CSSRuleList object for the child CSS rules.
</p>
</div>

<div class="algo">
<p>
`insertRule(rule, index)@mN
~method手続きは
⇒
~RET `~CSS規則~listに規則を挿入する$( この規則の`子~規則~list$, %rule, %index )
◎
The insertRule(rule, index) method must return the result of invoking insert a CSS rule rule into the child CSS rules at index.
</p>
</div>

<div class="algo">
<p>
`deleteRule(index)@mN
~method手続きは
⇒
`~CSS規則~listから規則を除去する$( この規則の`子~規則~list$, %index )
◎
The deleteRule(index) method must remove a CSS rule from the child CSS rules at index.
</p>
</div>

<div class="algo">
<p>
`CSSNestingRule$I ~objを直列化するときは、次の手続きの結果を返す：
◎
To serialize a CSSNestingRule: return the result of the following steps:
</p>
<ol>
	<li>
%結果 ~LET 空~文字列
◎
↓</li>
	<li>
%結果 に次を順に付加する
⇒＃
"<code class="literal">@nest</code>",
`0020^U `SPACE^cn,
`選択子~listを直列化する$( この規則の`選択子~list$ ),
`0020^U `SPACE^cn,
`007B^U `LEFT CURLY BRACKET^cn ({)
◎
Let s initially be the string "@nest" followed by a single SPACE (U+0020).
◎
Append to s the result of performing serialize a group of selectors on the rule’s associated selectors, followed by the string " {", i.e., a single SPACE (U+0020), followed by LEFT CURLY BRACKET (U+007B).
</li>
	<li>
%宣言~群 ~LET `宣言~群を直列化する$( この規則の`宣言~block$の`宣言~群$ )
◎
Let decls be the result of performing serialize a CSS declaration block on the rule’s associated declarations, or null if there are no such declarations.
</li>
	<li>
%規則~list ~LET この規則の`子~規則~list$
◎
Let rules be the result of performing serialize a CSS rule on each rule in the rule’s cssRules list, or null if there are no such rules.
</li>
	<li>
<p>
~IF［
%規則~list は空である
］：
</p>
		<ol>
			<li>
~IF［
%宣言~群 ~NEQ 空~文字列（すなわち、`宣言~群$は空でない）
］
⇒
%結果 に次を順に付加する
⇒＃
`0020^U `SPACE^cn,
%宣言~群
</li>
			<li>
%結果 に次を付加する
⇒
`0020^U `SPACE^cn
</li>
		</ol>
◎
If decls and rules are both null, append " }" to s (i.e. a single SPACE (U+0020) followed by RIGHT CURLY BRACKET (U+007D)) and return s.
If rules is null:
• Append a single SPACE (U+0020) to s
• Append decls to s
• Append " }" to s (i.e. a single SPACE (U+0020) followed by RIGHT CURLY BRACKET (U+007D)).
• Return s.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
~IF［
%宣言~群 ~NEQ 空~文字列
］
⇒
%結果 に次を順に付加する
⇒＃
改行文字【 `000A^U (LF) ？】,
`0020^U `SPACE^cn,
`0020^U `SPACE^cn,
%宣言~群
</li>
			<li>
%規則~list を成す
~EACH( %規則 )
に対し
⇒
%結果 に次を順に付加する
⇒＃
改行文字,
`0020^U `SPACE^cn,
`0020^U `SPACE^cn,
`~CSS規則を直列化する$( %規則 )
</li>
			<li>
%結果 に 改行文字を付加する
</li>
		</ol>
◎
Otherwise:
• If decls is not null, prepend it to rules.
• For each rule in rules:
•• Append a newline followed by two spaces to s.
•• Append rule to s. 
• Append a newline followed by RIGHT CURLY BRACKET (U+007D) to s.
• Return s.
</li>
	<li>
%結果 に次を付加する
⇒
`007D^U `RIGHT CURLY BRACKET^cn (})
◎
↑↑</li>
	<li>
~RET %結果
◎
↑↑</li>
</ol>
</div>

		</section>
	</section>
</main></div>
