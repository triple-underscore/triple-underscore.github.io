<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Nesting Module （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand,
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const link_map = this.link_map;
	let context_prop = '';
	const class_map = this.class_map;
	const tag_map = this.tag_map;

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'v': // css values
	href = context_prop + key;
	break;
case 'm':
	{
		const n = text.indexOf('(');
		if(n > 0){
			key = text.slice(0, n);
			text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
		}
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Nesting Module
spec_date:2023-10-09
trans_update:2023-10-10
source_checked:221027
page_state_key:CSS
original_url:https://drafts.csswg.org/css-nesting/
	abbr_url:CSSNESTING
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2023,permissive
trans_1st_pub:2019-07-04


●●class_map
p:property
css:css
ps:pseudo
pe:pseudo
at:at-rule
v:value
e:element
U:code-point
cn:cp-name

●●tag_map
p:code
t:var
css:code
ps:code
pe:code
at:code
v:code
e:code
c:code
m:code
I:code
U:span
cn:span
em:em
i:i

●●original_id_map


●●link_map

	●IDL

I.CSSStyleRule:~CSSOM1#cssstylerule
I.CSSMediaRule:~CSSCOND#cssmediarule

m.cssRules:~CSSOM1#dom-cssgroupingrule-cssrules
m.childRules:~CSSOM1#dom-cssgroupingrule-cssrules

	●
e.div:~HEgrouping#the-div-element

	●CSS
css.&amp;:#selectordef-
ps.where():~SELECTORS4#where-pseudo
ps.is():~SELECTORS4#matches-pseudo
ps.scope:~SELECTORS4#scope-pseudo

p.color:~CSSCOLOR#propdef-color
p.grid-auto-flow:~CSSGRID#propdef-grid-auto-flow

t.selector-list:~SELECTORS4#typedef-selector-list
t.relative-selector-list:~SELECTORS4#typedef-relative-selector-list
t.forgiving-selector-list:~SELECTORS4#typedef-forgiving-selector-list
t.scope-start:~CASCADE6#typedef-scope-start
t.scope-end:~CASCADE6#typedef-scope-end
t.block-contents:~CSSSYN#typedef-block-contents
t.rule-list:~CSSSYN#typedef-rule-list
t.delim-token:~CSSSYN#typedef-delim-token

at.layer:~CASCADE#at-ruledef-layer
at.scope:~CASCADE6#at-ruledef-scope
at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.container:~CSSCONTAIN3#at-ruledef-container

入子な~style規則:#nested-style-rule
入子な条件付き規則:#conditionals
入子な~group規則:#nested-group-rules
入子ng選択子:#nesting-selector
入子ng選択子を包含して:#contain-the-nesting-selector

詳細度:~SELECTORS4#specificity
選択子:~SELECTORS4#selector
型~選択子:~SELECTORS4#type-selector
単純-選択子:~SELECTORS4#simple
複階-選択子:~SELECTORS4#complex
複合-選択子:~SELECTORS4#compound
選択子~list:~SELECTORS4#selector-list
相対~選択子:~SELECTORS4#relative-selector
結合子:~SELECTORS4#selector-combinator
子孫~結合子:~SELECTORS4#descendant-combinator
無効な選択子:~SELECTORS4#invalid-selector
無特能:~SELECTORS4#featureless

~cascade:~CASCADE#cascade
出現順序:~CASCADE#cascade-order
	~CASCADE#cascade-sort
~style規則:~CSSSYN#style-rule
~at-規則:~CSSSYN#at-rule
宣言:~CSSSYN#declaration

条件付き~group規則:~CSSCOND#conditional-group-rule

宣言~群:~CSSOM1#cssstyledeclaration-declarations

~monkey~patch:~DESIGN-PRINCIPLES#monkey-patch

●●words_table1

CASCADE6:https://drafts.csswg.org/css-cascade-6/
CSSCONTAIN3:https://drafts.csswg.org/css-contain-3/

●●words_table

	●CSS
単純-:simple::~
詳細度:specificity::~
CSSOM:
	宣言~群:declarations
出現順序:order of appearance:~
無特能:featureless::~
supports:

	^v:red
	^v:blue
	視野~付き:scoping
	優先され:win／:lose
	条件付き規則:conditional

	●構造
直な:directな:~
入子を:nest-::入れ子を
入子法:nesting::入れ子法
	入子法:Nesting
	それらの順序:relative order
参照r:refer:参照

	●構文
接頭-:prefix::~
糖衣:sugar::~
	糖衣を外す:desugar
集約-:aggregate:~
周囲の:surrounding:~
導入部:prelude::~
混合-:mix:~
量:amount:~
展開-:expand:~
遭遇-:encounter:~
変形-:transform::~
	変形するもの:transformation

	混合-法:mixing
	来る:come
	来な:come
	記され:written
	書く:write
	書きたい:write
	書ける:write
	〜を書くための:〜-writing
	書かれ:written
	書き直せ:rewritten
	中で一緒にされ:directly appended together
	識別子:ident
	混ぜこぜに:intermix
	積み上げる:stack up
	短い:small
	二重にする:doubled-up
	回数:repetition
	何回も繰返される:have significant repetition
	先頭に置く必要はない:n’t have to be at the beginning of
	先頭:very start of
	先頭の:initial
	そのまま:as-is

	●仕様
保守能:maintainability:~
編集-:edit:~
編集:editing:~
背後:behind:~
素朴:naive:~
機能-:function:~
複雑:complicated:~
採用-:adopt:~
普通の:ordinaryな:~
指数関数的:exponential:~
爆発:explosion:~
膨大:massive:~
不用意:accidental:~
適度:reasonable:~
判定-:judge:~
経験的:heuristical:~
導入:introduction:~
variation::::バリエーション
trade-off::::トレードオフ
比較的:relativeに:~
緩めた:relaxした:~
回復:recovery:~
monkey:
patch::::パッチ
元々:originalに:~
捕える:catchする:~
句-:phrase:~
完璧:perfect:~
忠実:faithful:~
大幅:drastic:~
違法:illegal:~
説明書き:explainer:~
馴染み:familiar:~
手軽:handy:~

	~module性:modularity
	アリ性:possibility
	受容-可能でない:unacceptable
	高める:increase
	見える:look
	それこそが:that is, after all
	要:the entire point
	適用-可能:applicable
	これまでの:to date
	-:portion of 〜 for one version of the [CSS3COLOR] module
	可能に:able to
	一致する:equivalent
	最終的に:finally
	〜かどうか調べる:looking for
	ついて来る:comes with
	課-:impose
	以前からある:predate
	多くが〜こともあって:largely because
	遥かに超える:much, much more!
	最悪な~~事態:the worst
	解消される:eliminate 〜 entirely
	作れる:make
	それほど多量に:as much
	築き上げる:build up
	有用さを少し減らす:making 〜 slightly less useful
	注意:notably
	〜だけで:on 's own
	ではなぜ:That skirts the question, tho:
	役立たずに見える:silly
	^en:versus
	少なくとも:at minimum
	と併用する例:Example usage with
	事実:fact
	変化しない:unchanged
	特有な働き:specifics of how 〜 work
	かまわない^em:can freely
	読み難く:harder to read
	紛らわしく:confusing
	ため、:sake
	入子な規則を~supportしない:older
	ことになろう:also happen to
	特に:notably
	~~含まれる:counts as
	課され:impose
	〜だけが変更される:just
	`SELECTORS-4$r:Selectors
	~version付け:versioning
	幸いにも:luckily
	この仕様:CSS Nesting
	そもそも:in the first place
	できるようにする:lets you
	あったとする:imagine you have some
	-:notice
	~~簡潔:compact
	併用:mix
	およそ:nearly

	●未分類
重合しな:overlapしな:重なり合わな
連結-:concatenate:~
megabyte::::メガバイト
component::::コンポーネント
付する:attachする:~
前処理器:preprocessor::~::プリプロセッサ
hover:
深く:deepに:~

	Sass
	BEM
	^v:blue
	^v:red

	得られ:get
	遅く:slower
	可能:able
	小さな:small
	最も近い:nearest
	最も高い:highest
	より高い:larger
	最も高い:largest
	〜を問わず:of either 〜
	いくつもの:lots of
	他:otherwise
	-:individual
	同時に:simultaneous
	上の:the previous
	先掲の:the earlier
	順序どおり:in order
	在る下で:presence
	変わり:vary
	何か:anything
	合致するものは無い:fails to match anything
	それでも:continue
	含む:include
	絶対~化:absolutize
	近く:closely
	何~層でも:more than one 〜 in as many levels
	直前の:the previous


●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 4＞. URL: https://drafts.csswg.org/css-cascade-4/
[CSS-CASCADE-6]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 6＞. URL: https://drafts.csswg.org/css-cascade-6/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/

●●ref_informative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-CONTAIN-3]
    Tab Atkins Jr.; Florian Rivoal; Miriam Suzanne. ＜CSS Containment Module Level 3＞. URL: https://drafts.csswg.org/css-contain-3/
[CSS-GRID-2]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. ＜CSS Grid Layout Module Level 2＞. URL: https://drafts.csswg.org/css-grid-2/
[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. URL: https://drafts.csswg.org/css-ui-4/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Nesting Module</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-nesting-1/
公表履歴
	https://www.w3.org/standards/history/css-nesting-1
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-nesting-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="https://nerdy.dev/">Adam Argyle</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-nesting-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-nesting-1
</script>

<body>

<header>
	<hgroup>
<h1>CSS Nesting Module</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この~moduleは、
`~style規則$を別の規則の内側に
— 親~規則の`選択子$に相対的な，子~規則の`選択子$を伴わせて —
入子にする能を導入する。
これは、~CSS~stylesheetの~module性と保守能を高める。
◎
This module introduces the ability to nest one style rule inside another, with the selector of the child rule relative to the selector of the parent rule. This increases the modularity and maintainability of CSS stylesheets.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
この~moduleは、別の`~style規則$の中に~style規則を入子にするための~supportを述べる
— それは、内縁~規則の選択子が，外縁~規則に合致した要素を参照できるようにする。
この特能は、関係し合う~styleたちを~CSS文書の中の単独の構造に集約できるようにして，可読性と保守能を改善する。
◎
This module describes support for nesting a style rule within another style rule, allowing the inner rule’s selector to reference the elements matched by the outer rule. This feature allows related styles to be aggregated into a single structure within the CSS document, improving readability and maintainability.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは：
◎
This module＼
</p>
<ul>
	<li>
`CSS21$r 構文解析器~modelを拡張する新たな構文解析器~規則を導入する。
◎
introduces new parser rules that extend the [CSS21] parser model.＼
</li>
	<li>
`SELECTORS-4$r ~moduleを拡張する選択子を導入する。
◎
It introduces selectors that extend the [SELECTORS-4] module.＼
</li>
	<li>
`CSSOM$r【！CSSOM-1】 ~moduleに定義された一部の~IDLと~algoを拡張して改変する。
◎
It extends and modifies some IDL and algorithms defined in the [CSSOM-1] module.
</li>
</ul>

		</section>
		<section id="values">
<h3 title="Values">1.2. 値</h3>

<p>
この仕様は、新たな~propや値は定義しない。
◎
This specification does not define any new properties or values.
</p>

		</section>
	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="explainer">
<h2 title="Explainer">2. 説明書き</h2>

◎非規範的

<p>
もっと~~簡潔な仕方で書きたい~CSSがあったとする：
◎
Imagine you have some CSS that you’d like to write in a more compact way.
</p>

<pre class="lang-css">
.foo {
  color: green;
}
.foo .bar {
  font-size: 1.4rem;
}
</pre>

<p>
そのような~codeは、
入子法により次のように書ける：
◎
With Nesting, you can write such code as:
</p>

<pre class="lang-css">
.foo {
  color: green;
  .bar {
    font-size: 1.4rem;
  }
}
</pre>

<p>
`Sass＠https://sass-lang.com/$ その他の~CSS前処理器において
~styleを入子にしていた作者は、
これが，ごく馴染みであることを見出すことになろう。
◎
If you’ve been nesting styles in Sass or other CSS preprocessors, you will find this very familiar.
</p>

<p>
どの規則も，親~style規則の内側に入子にできる：
◎
You can nest any rules inside of a parent style rule:
</p>

<pre class="lang-css">
main {
  div { ... }
  .bar { ... }
  #baz { ...}
  :has(p) { ... }
  ::backdrop { ... }
  [lang|="zh"] { ... }
  * { ... }
}
</pre>

<p>
既定では、
子~規則の選択子は，
`子孫~結合子$を挟んで親~規則と接続するものと見做されるが、
入子な選択子は，どの結合子からでも開始するよう変更できる：
◎
By default, the child rule’s selector is assumed to connect to the parent rule by a descendant combinator, but you can start the nested selector with any combinator to change that:
</p>

<pre class="lang-css">
main {
  + article { ... }
  &gt; p { ... }
  ~ main { ... }
}
</pre>

<p>
新たな選択子 `&amp;$css は、
親~選択子に合致した要素を明示的に参照rできるようにする。
なので、
直前の例は，次のように書くこともできた：
◎
The new &amp; selector lets you refer to the elements matched by the parent selector explictly, so the previous examples could have been written as:
</p>


<pre class="lang-css">
main {
  &amp; + article { ... }
  &amp; &gt; p { ... }
  &amp; ~ main { ... }
}
</pre>

<p>
`&amp;$css は、
入子な選択子の中の他の所在に配置することで，親~規則と子~規則の間に他の関係性を指示できる。
例えば、
次の~CSSは：
◎
But you can place the &amp; in other locations within the nested selector, to indicate other types of relationships between the parent and child rule. For example, this CSS:
</p>

<pre class="lang-css">
ul {
  padding-left: 1em;
}
.component ul {
  padding-left: 0;
}
</pre>

<p>
入子ngを利用して，次のように書き直せる：
◎
Can be rewritten using Nesting as:
</p>


<pre class="lang-css">
ul {
  padding-left: 1em;
  .component &amp; {
    padding-left: 0;
  }
}
</pre>

<p>
ここでも、
`&amp;$css は，
“それが，入子な選択子を置くよう求まれる所”
とする仕方を与える。
◎
Again, the &amp; gives you a way to say “this is where I want the nested selector to go”.
</p>

<p>
それはまた、
選択子の合間に~space【すなわち、`子孫~結合子$】を挟みたくないときにも，手軽になる。
例えば、
次の~codeは：
◎
It’s also handy when you don’t want a space between your selectors. For example:
</p>


<pre class="lang-css">
a {
  color: blue;
  &amp;:hover {
    color: lightblue;
  }
}
</pre>

<p>
`a:hover {^css と同じ結果を得る。
`&amp;$css を伴わない場合、
`a :hover {^css
（ `a^css と `:hover^css の合間に~spaceがある）
と同じ結果になり，
~hover~linkを~styleするのに失敗することになる。
◎
Such code yields the same result as a:hover {. Without the &amp;, you’d get a :hover {—notice the space between a and :hover—which would fail to style your hover link.
</p>

<p>
すでに入子にされた~CSSの内側に~CSSを入子にするよう，
欲されるだけ何~層でも深く入子にできる。
入子法は、［
`容器~query＠~CSSCONTAIN3#container-query$／
`~supports~query＠~CSSCOND#supports-queries$／
`媒体~query＠~MQ5#media-query$／
`~cascade層＠~CASCADE#cascade-layers$
］とも併用できる。
（およそ）何でも他のものの内側に置ける。
◎
You can nest more than one layer deep—nesting CSS inside already-nested CSS—in as many levels as you desire. You can mix Nesting with Container Queries, Supports Queries, Media Queries, and/or Cascade Layers however you want. (Nearly) anything can go inside of anything.
</p>

	</section>
	<section id="nesting">
<h2 title="Nesting Style Rules">3. ~style規則の入子法</h2>

<p>
`~style規則$は、
他の~style規則の内側に入子にできる。
これらの
`入子な~style規則@
は、
普通の~style規則と正確に同じ様に動作する
— すなわち、
選択子を介して，要素に~prop群を結付ける —
が、
それらは親~規則の選択子~文脈を “継承する” ことで，選択子を
— 場合によっては複数回~繰返す必要なく —
親の選択子の上に更に築くことを許容する。
◎
Style rules can be nested inside of other styles rules. These nested style rules act exactly like ordinary style rules—associating properties with elements via selectors—but they "inherit" their parent rule’s selector context, allowing them to further build on the parent’s selector without having to repeat it, possibly multiple times.
</p>

<p>
`入子な~style規則$は、
`相対~選択子$を利用できることを除けば，
通常の~style規則と正確に同じ様になる
— それは、
暗黙的に，親~規則に合致した要素から相対的になる。
◎
A nested style rule is exactly like a normal style rule, except that it can use can use relative selectors, which are implicitly relative to the elements matched by the parent rule.
</p>

<div class="example">
<p>
すなわち、
次の様な入子な~style規則は：
◎
That is, a nested style rule like:
</p>

<pre class="lang-css">
.foo {
  color: red;

  a {
    color: blue;
  }
}
</pre>

<p>
妥当であり，
次と等価になる：
◎
is valid, and equivalent to:
</p>

<pre class="lang-css">
.foo {
  color: red;
}
.foo a {
  color: blue;
}
</pre>

<p class="trans-note">【
この事例では、
`a^css は`相対~選択子$であり，
その先頭には暗黙な`子孫~結合子$が在ると見なされる。
】</p>

<p>
入子にされた規則は、［
`入子ng選択子$を利用して，
親~規則に合致した要素を直に参照rする
］ことも［
`相対~選択子$の構文を利用して，
“子孫” 以外の関係性を指定する
］こともできる。
◎
The nested rule can also use the nesting selector to directly refer to the parent rule’s matched elements, or use relative selector syntax to specify relationships other than "descendant".
</p>

<pre class="lang-css">
.foo {
  color: red;

  &amp;:hover {
    color: blue;
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to:
</span> */

.foo { color: red; }
.foo:hover { color: blue; }
</pre>

<pre class="lang-css">
.foo {
  color: red;

  + .bar {
    color: blue;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to:
</span> */

.foo { color: red; }
.foo + .bar { color: blue; }
</pre>
</div>

		<section id="syntax">
<h3 title="Syntax">3.1. 構文</h3>

<p>
`~style規則$の内容は、
既存の`宣言~群$に加えて，今や［
`入子な~style規則$, `~at-規則$
］も受容する。
◎
The contents of style rules now accepts nested style rules and at-rules, in addition to the existing declarations.
</p>

<p>
`入子な~style規則$は、
入子にされない規則とは，次に挙げる仕方で相違する：
◎
Nested style rules differ from non-nested rules in the following ways:
</p>
<ul>
	<li>
`入子な~style規則$は、
その .導入部として `relative-selector-list$t を受容する
（ `selector-list$t だけでなく）。
`相対~選択子$は、
`入子ng選択子$により表現される要素に相対的になる。
◎
A nested style rule accepts a &lt;relative-selector-list&gt; as its prelude (rather than just a &lt;selector-list&gt;). Any relative selectors are relative to the elements represented by the nesting selector.
</li>
	<li>
`relative-selector-list$t を成す各~選択子のうち［
`結合子$から開始しないが，`入子ng選択子を包含して$いるもの
］は、
`相対~選択子$ではないものと解釈される。
◎
If a selector in the &lt;relative-selector-list&gt; does not start with a combinator but does contain the nesting selector, it is interpreted as a non-relative selector.
</li>
</ul>

<p>
入子な~style規則が どう構文解析されるかについての精確な詳細は、
`CSS-SYNTAX-3$r にて定義される†。
◎
The precise details of how nested style rules are parsed are defined in [CSS-SYNTAX-3].
</p>

<p class="trans-note">【†
現在のそれは、
この仕様の更新（ `8662$issue ）をまだ反映していない。
】【
入子にされた構成子は［
`宣言$, `~style規則$
］どちらを開始しているのか紛らわしくもなり得るが
（例： `color:hover ...^css は、［
無効な値 `hover^v を伴う `color$p ~propの宣言,
`color^e 要素~用の選択子を伴う規則
］どちらに解釈するべきか？）、
まず宣言として構文解析するよう試行され，
失敗した場合は規則として構文解析されることになるようだ
（ `7961$issue の`この~comment＠~CSSissue/7961#issuecomment-1489883575$ ）。
】</p>

<p>
無効な`入子な~style規則$は、
その内容【すなわち，宣言~block】とともに無視されるが，
その親~規則を無効~化することはない。
◎
An invalid nested style rule is ignored, along with its contents, but does not invalidate its parent rule.
</p>

<div class="example">
<p>
例えば，以下に挙げる入子ngは、
妥当になる：
◎
For example, the following nestings are valid:
</p>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css （`入子ng選択子$）は、
それだけでも選択子として利用できる：
◎
&amp; can be used on its own
</span> */
.foo {
  color: blue;
  &amp; &gt; .bar { color: red; }
  &gt; .baz { color: green; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo &gt; .bar { color: red; }
  .foo &gt; .baz { color: green; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`複合-選択子$における `&amp;^css は、
親の選択子を精緻化する：
◎
or in a compound selector, refining the parent’s selector
</span> */
.foo {
  color: blue;
  &amp;.bar { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo.bar { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
選択子~listを成す各~選択子は、
どれも，親に相対的になる：
◎
multiple selectors in the list are all relative to the parent
</span> */
.foo, .bar {
  color: blue;
  + .baz, &amp;.qux { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo, .bar { color: blue; }
  :is(.foo, .bar) + .baz,
  :is(.foo, .bar).qux { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css は、
単独の選択子~内で複数回~利用できる：
◎
&amp; can be used multiple times in a single selector
</span> */
.foo {
  color: blue;
  &amp; .bar &amp; .baz &amp; .qux { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo .bar .foo .baz .foo .qux { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`&amp;^css は、
選択子の先頭に置く必要はない：
◎
&amp; doesn’t have to be at the beginning of the selector
</span> */

.foo {
  color: red;
  .parent &amp; {
    color: blue;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  .parent .foo { color: blue; }
*/

.foo {
  color: red;
  :not(&amp;) {
    color: blue;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  :not(.foo) { color: blue; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
`相対~選択子$を利用する場合、
先頭の `&amp;^css が自動的に含意される：
◎
But if you use a relative selector, an initial &amp; is implied automatically
</span> */
.foo {
  color: red;
  + .bar + &amp; { color: blue; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: red; }
  .foo + .bar + .foo { color: blue; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
いくぶん役立たずに見えるが、
`&amp;^css だけでも利用できる：
◎
Somewhat silly, but &amp; can be used all on its own, as well.
</span> */
.foo {
  color: blue;
  &amp; { padding: 2ch; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo { padding: 2ch; }

  <span class="comment">
あるいは：
◎
// or
</span>

  .foo {
    color: blue;
    padding: 2ch;
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
これも役立たずに見えるが、
`&amp;^css を二重にすることもできる：
◎
Again, silly, but can even be doubled up.
</span> */
.foo {
  color: blue;
  &amp;&amp; { padding: 2ch; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { color: blue; }
  .foo.foo { padding: 2ch; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
親~選択子は、
任意に複雑にできる：
◎
The parent selector can be arbitrarily complicated
</span> */
.error, #404 {
  &amp;:hover &gt; .baz { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  :is(.error, #404):hover &gt; .baz { color: red; }
*/

.ancestor .el {
  .other-ancestor & { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .other-ancestor :is(.ancestor .el) { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
入子な選択子も、
任意に複雑にできる：
◎
As can the nested selector
</span> */
.foo {
  &amp; :is(.bar, &amp;.baz) { color: red; }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo :is(.bar, .foo.baz) { color: red; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
選択子を複数~levelに入子にして “積み上げる” ：
◎
Multiple levels of nesting "stack up" the selectors
</span> */
figure {
  margin: 0;

  &gt; figcaption {
    background: hsl(0 0% 0% / 50%);

    &gt; p {
      font-size: .9rem;
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  figure { margin: 0; }
  figure &gt; figcaption { background: hsl(0 0% 0% / 50%); }
  figure &gt; figcaption &gt; p { font-size: .9rem; }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
~cascade層（ `layer$at ）と併用する例：
◎
Example usage with Cascade Layers
</span> */
@layer base {
  html {
    block-size: 100%;

    body {
      min-block-size: 100%;
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @layer base {
    html { block-size: 100%; }
    html body { min-block-size: 100%; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
~cascade層を入子にする例：
◎
Example nesting Cascade Layers
</span> */
@layer base {
  html {
    block-size: 100%;

    @layer support {
      body {
        min-block-size: 100%;
      }
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @layer base {
    html { block-size: 100%; }
  }
  @layer base.support {
    html body { min-block-size: 100%; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
視野~付き（ `scope$at ）と併用する例：
◎
Example usage with Scoping
</span> */
@scope (.card) to (&gt; header) {
  :scope {
    inline-size: 40ch;
    aspect-ratio: 3/4;
				
    &gt; header {
      border-block-end: 1px solid white;
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @scope (.card) to (&gt; header) {
    :scope { inline-size: 40ch; aspect-ratio: 3/4; }
    :scope &gt; header { border-block-end: 1px solid white; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
視野~付きを入子にする例：
◎
Example nesting Scoping
</span> */
.card {
  inline-size: 40ch;
  aspect-ratio: 3/4;

  @scope (&amp;) to (&gt; header &gt; *) {
    :scope &gt; header {
      border-block-end: 1px solid white;
    }
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .card { inline-size: 40ch; aspect-ratio: 3/4; }
  @scope (.card) to (&gt; header &gt; *) {
    :scope &gt; header { border-block-end: 1px solid white; }
  }
*/
</pre>
</div>

<div class="note">
<p>注記：
［
~CSSを生成する~toolのうち，入子ngを処理するもの
］には、
作者が［
選択子を文字列として連結して，
複数の入子ng~levelにまたがる 1 個の`単純-選択子$を築き上げる
］ことを許容するものもある。
これは，ときには、
【！ `https://en.wikipedia.org/wiki/CSS#:~:text=bem%20(block%2C%20element%2C%20modifier)^】
<abbr title="Block, Element, Modifier">BEM</abbr>
の様に，
階層的な~patternを成す名前で利用されることもある
— 当の選択子が内部的に何回も繰返されるとき、
その回数を抑制するためとして。
◎
 Some CSS-generating tools that preprocess nesting will concatenate selectors as strings, allowing authors to build up a single simple selector across nesting levels. This is sometimes used with hierarchical name patterns like BEM to reduce repetition across a file, when the selectors themselves have significant repetition internally.
</p>

<p>
例えば、
ある~componentが~class `.foo^css を利用していて，
ある入子な~componentが~class `.fooBar^css を利用している場合、
`Sass＠https://sass-lang.com/$
においては，次のように書くこともできる：
◎
For example, if one component uses the class .foo, and a nested component uses .fooBar, you could write this in Sass as:
</p>

<pre class="lang-css">
.foo {
  color: blue;
  &amp;Bar { color: red; }
}
/* <span class="comment">
は、
Sass においては，次と等価になる：
◎
In Sass, this is equivalent to
</span>
  .foo { color: blue; }
  .fooBar { color: red; }
*/
</pre>

<p>
これは、
~CSSにおいては許容されない
— `入子ng選択子$【！nesting】は、
構文を変形するものではなく，親~選択子が実際に合致する要素に合致するので。
◎
This is not allowed in CSS, as nesting is not a syntax transformation, but rather matches on the actual elements the parent selector matches.
</p>

<p>
そもそも，選択子 `&amp;Bar^css は、
~CSSにおいては妥当でない
— `Bar^css が成す部分は、
`型~選択子$であり，`複合-選択子$においては最初に来なければならないので。
（すなわち、
`Bar&amp;^css と書かれなければならない）。
なので、
この仕様の構文は，幸いにも当の前処理器【すなわち Sass 】の構文とは重合しない。
◎
It is also true that the selector &amp;Bar is invalid in CSS in the first place, as the Bar part is a type selector, which must come first in the compound selector. (That is, it must be written as Bar&amp;.) So, luckily, there is no overlap between CSS Nesting and the preprocessor syntax.
</p>
</div>

<div class="algo">
<p>
`選択子$は、
次を満たすとき，
`入子ng選択子を包含して@
いるとされる
⇒
`any type of^en 選択子として
【当の文脈に適切な種別の`選択子の文法＠~SELECTORS4#grammar$に則って】
`構文解析-＠~CSSSYN#css-parse-something-according-to-a-css-grammar$した結果、
次を満たす `delim-token$t に遭遇した
⇒
.値 ~EQ `&amp;^l
（ `0026^U `AMPERSAND^cn ）
◎
A selector is said to contain the nesting selector if, when it was parsed as any type of selector, a &lt;delim-token&gt; with the value "&amp;" (U+0026 AMPERSAND) was encountered.
</p>

<p class="note">注記：
これは、
`:is(:unknown(&amp;), .bar)^css の様な事例
を捕えるため，この明示的な方式で句される。
この選択子には、
`&amp;$css を包含する唯一の部分として，未知な選択子（ `unknown()^ps ）がある
（未知なので、
その引数が選択子として構文解析されるよう`意味されたもの^emか否か，知る仕方は無い）。
この未知な選択子は、［
より新たな~browserにおいては、
完璧に妥当な選択子として~supportされる
］`ようになるかもしれず^em，［
構文解析は、
無関係な~version付けの課題に依存しないことが求まれる
］ので、
依然として`入子ng選択子を包含して$いるものと扱われる。
◎
Note: This is phrased in this explicit manner so as to catch cases like :is(:unknown(&amp;), .bar), where an unknown selector (which, being unknown, we have no way of knowing whether the argument is meant to be parsed as a selector or not) is the only part of the selector that contains an &amp;. As that might be a perfectly valid selector that’s only supported by newer browsers, and we don’t want parsing to be dependent on unrelated versioning issues, we treat it as still containing the nesting selector.
</p>
</div>

<p>
`forgiving-selector-list$t を成す~itemは、
`入子ng選択子を包含して$いるが`無効な選択子$であっても，
破棄されることなく正確にそのまま保全される。
（これは、
当の選択子を照合するときの挙動を変更しない
— それでも、
無効な選択子に合致するものは無いが。
選択子の直列化だけが変更される。）
◎
If a &lt;forgiving-selector-list&gt; has an item that contains the nesting selector but is invalid, that item is preserved exactly as-is rather than being discarded. (This does not change the matching behavior of the selector—an invalid selector still fails to match anything—just the serialization of the selector.)
</p>

<p class="issue">
前~段落は、
`&amp;$css を `SELECTORS-4$r へ移動するに伴い，そこへ移動する必要がある。
これは，`~monkey~patch$であるが、
便利~用にここに与えている。
◎
The preceding paragraph needs to move to Selectors when we move &amp; itself to Selectors; I’m monkey-patching for convenience here.
</p>

		</section>
		<section id="conditionals">
<h3 title="Nesting Other At-Rules">3.2. 他の~at-規則の入子法</h3>

<p>
`入子な~style規則$に加えて、
この仕様は，`~style規則$の内側に
`入子な~group規則@
も許容する
⇒
~at-規則のうち，その本体が`~style規則$を包含し得るものは、
他の`~style規則$の内側に入子にできる。
◎
In addition to nested style rules, this specification allows nested group rules inside of style rules: any at-rule whose body contains style rules can be nested inside of a style rule as well.
</p>

<p>
`入子な~group規則$が，この仕方で入子にされたときは、
当の規則の内容は、
`rule-list$t としてではなく，
`block-contents$t として構文解析される：
◎
When nested in this way, the contents of a nested group rule's block are parsed as &lt;block-contents&gt; rather than &lt;rule-list&gt;:
</p>
<ul>
	<li>
【本体~内の】各`~style規則$は、
`入子な~style規則$になり，
その`入子ng選択子$の定義を最も近い先祖の`~style規則$からとる。
◎
Style rules are nested style rules, with their nesting selector taking its definition from the nearest ancestor style rule.
</li>
	<li>
~prop【宣言】は、
直に利用でき，
`&amp; {...}^css ~block内に入子にされたかのように動作する。
◎
Properties can be directly used, acting as if they were nested in a &amp; {...} block.
</li>
</ul>

<p class="note">注記：
特定的に，次に挙げる規則は、
`入子な~group規則$になる能力がある
⇒＃
すべての`条件付き~group規則$（ `media$at, `supports$at ）,
`layer$at,
`scope$at,
`container$at
◎
Specifically, these rules are capable of being nested group rules:
• all the conditional group rules (@media, @supports)
• @layer
• @scope
• @container
</p>

<p>
そのような`入子な~group規則$の意味と挙動は、
他においては，他が指定されない限り変化しない。
◎
The meanings and behavior of such nested group rules is otherwise unchanged, unless otherwise specified.
</p>

<div class="example">
<p>
例えば、
次に挙げる条件付き規則の入子ngは，妥当になる：
◎
For example, the following conditional nestings are valid:
</p>

<pre class="lang-css">
/* <span class="comment">
~propは直に利用できる：
◎
Properties can be directly used
</span> */
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo {
    display: grid;
				
    @media (orientation: landscape) {
      &amp; {
        grid-auto-flow: column;
      }
    }
  }
*/

/* <span class="comment">
最終的に次と等価になる：
◎
finally equivalent to
</span>
  .foo { display: grid; }

  @media (orientation: landscape) {
    .foo {
      grid-auto-flow: column;
    }
  }
*/

/* <span class="comment">
条件付きも更に入子にできる：
◎
Conditionals can be further nested
</span> */
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;

    @media (min-width &gt; 1024px) {
      max-inline-size: 1024px;
    }
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .foo { display: grid; }

  @media (orientation: landscape) {
    .foo {
      grid-auto-flow: column;
    }
  }

  @media (orientation: landscape) and (min-width &gt; 1024px) {
    .foo {
      max-inline-size: 1024px;
    }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
~cascade層（ `layer$at ）を入子にする例：
◎
Example nesting Cascade Layers
</span> */
html {
  @layer base {
    block-size: 100%;

    @layer support {
      &amp; body {
        min-block-size: 100%;
      }
    }
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  @layer base {
    html { block-size: 100%; }
  }
  @layer base.support {
    html body { min-block-size: 100%; }
  }
*/
</pre>

<pre class="lang-css">
/* <span class="comment">
視野~付き（ `scope$at ）を入子にする例：
◎
Example nesting Scoping
</span> */
.card {
  inline-size: 40ch;
  aspect-ratio: 3/4;

  @scope (&amp;) {
    :scope {
      border: 1px solid white;
    }
  }
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span>
  .card { inline-size: 40ch; aspect-ratio: 3/4; }
  @scope (.card) {
    :scope { border-block-end: 1px solid white; }
  }
*/
</pre>
</div>

<p>
直に入子にされたすべての~propは、［
順序どおり一緒に収集され，
選択子 `&amp;$css を伴う`入子な~style規則$内に入子にされ，
他のすべての子~規則より前に配置された
］かのように扱われる。
このことは、
~CSSOM【！~OM】内も含む
（すなわち，
`cssRules$m 属性は、
実際に，この`入子な~style規則$
— 直に入子にされたすべての~propを包含している規則 —
から開始する）。
◎
All directly-nested properties are treated as if they were collected together, in order, and nested in a nested style rule with the selector &amp;, and placed before all other child rules. This includes in the OM. (That is, the cssRules attribute actually starts with this nested style rule, containing all the directly-nested properties.)
</p>

<div class="example">
<p>
例えば，先掲の例：
◎
For example, the earlier example:
</p>

<pre class="lang-css">
.foo {
  display: grid;

  @media (orientation: landscape) {
    grid-auto-flow: column;
  }
}
/* <span class="comment">
は、
次と等価になる：
◎
equivalent to:
</span> */
  .foo {
    display: grid;

    @media (orientation: landscape) {
      &amp; {
        grid-auto-flow: column;
      }
    }
  }
*/
</pre>

<p>
事実，`正確に^em等価になり、
正確に同じ~CSSOM構造を生産する。
【 `media^at を表現する】 `CSSMediaRule$I ~objは、
その `childRules$m 属性~内に［
`grid-auto-flow$p ~propを包含している 1 個の `CSSStyleRule$I ~obj
］を有することになる。
◎
is in fact exactly equivalent, producing the exact same CSSOM structure. The CSSMediaRule object will have a single CSSStyleRule object in its .childRules attribute, containing the grid-auto-flow property.
</p>
</div>

<p class="note">注記：
このことは、
そのような規則を直列化した結果は，それが元々書かれた~~形から相違することを意味する
— 直列化においては、
直に入子にされた~propは`無い^em。

◎
Note: This does mean that the serialization of such rules will differ from how they were originally written, with no directly-nested properties in the serialization.
</p>

			<section id="nesting-at-scope">
<h4 title="Nested @scope Rules">3.2.1. 入子な `scope^at 規則</h4>

<p>
所与の `scope$at 規則 %規則 に対し：
◎
↓</p>
<ul>
	<li>
%規則 が`入子な~group規則$を成すときは、
%規則 の `scope-start$t における `&amp;$css 選択子は，最も近い先祖~style規則に合致した要素を参照rする。
◎
When the @scope rule is a nested group rule, an &amp; in the &lt;scope-start&gt; selector refers to the elements matched by the nearest ancestor style rule.
</li>
	<li>
%規則 の［
本体~内の~style規則／ `scope-end$t
］における `&amp;$css 選択子は、［
%規則 の `scope-start$t 選択子に合致している要素
］に合致するものとして扱われる。
【この段落の原文は，そのまま訳すと意味が通らないので、訳を改めている。】
◎
For the purposes of the style rules in its body and its own &lt;scope-end&gt; selector, the @scope rule is treated as an ancestor style rule, matching the elements matched by its &lt;scope-start&gt; selector.
</li>
</ul>

<div class="example">
<p>
すなわち、
次の~codeは：
◎
That is, the following code:
</p>

<pre class="lang-css">
.parent {
  color: blue;

  @scope (&amp; &gt; .scope) to (&amp; .limit) {
    &amp; .content {
      color: red;
    }
  }
}
</pre>

<p>
次と等価になる：
◎
is equivalent to:
</p>

<pre class="lang-css">
.parent { color: blue; }
@scope (.parent &gt; .scope) to (.parent &gt; .scope .limit) {
  .parent &gt; .scope .content {
    color: red;
  }
}
</pre>
</div>

			</section>
		</section>
		<section id="mixing">
<h3 title="Mixing Nesting Rules and Declarations">3.3. 入子ng規則と宣言の混合-法</h3>

<p>
~style規則が［
宣言, ［
`入子な~style規則$／`入子な~group規則$
］］両者を包含するときでも，
これら 3 種すべてを任意に混合できる。
しかしながら，前者と後者の相対的な順序は、
どの仕方でも保全されない。
◎
When a style rule contains both declarations and nested style rules or nested group rules, all three can be arbitrarily mixed. However, the relative order of declarations vs other rules is not preserved in any way.
</p>

<div class="example">
<p>
例えば、
次の~codeでは：
◎
For example, in the following code:
</p>

<pre class="lang-css">
article {
  color: green;
  &amp; { color: blue; }
  color: red;
}

/* <span class="comment">
は、
次と等価になる：
◎
equivalent to
</span> */
article {
  color: green;
  color: red;
  &amp; { color: blue; }
}
</pre>
</div>

<p>
`出現順序$を決定する目的においては、［
`入子な~style規則$／`入子な~group規則$
］は，その親~規則より`後^emに来るものと見なされる。
◎
For the purpose of determining the Order Of Appearance, nested style rules and nested group rules are considered to come after their parent rule.
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-css">
article {
  color: blue;
  &amp; { color: red; }
}
</pre>

<p>
両~宣言とも，その詳細度は同じ (0,0,1) になるが、
入子な規則は親~規則より`後に来る^emものと見なされるので，
宣言 `color: red^css の方が~cascadeにおいて優先される。
◎
Both declarations have the same specificity (0,0,1), but the nested rule is considered to come after its parent rule, so the color: red declarations wins the cascade.
</p>

<p>
他方，次の例では：
◎
On the other hand, in this example:
</p>

<pre class="lang-css">
article {
  color: blue;
  :where(&amp;) { color: red; }
}
</pre>

<p>
`where()$ps 疑似類により`入子ng選択子$の詳細度は 0 に抑制されるので，
宣言 `color: red^css の詳細度は (0,0,0) になり、
`出現順序$が考慮される前に，
宣言 `color: blue^css の方が優先される。
◎
The :where() pseudoclass reduces the specificity of the nesting selector to 0, so the color: red declaration now has a specificity of (0,0,0), and loses to the color: blue declaration before "Order Of Appearance" comes into consideration.
</p>
</div>

<p class="note">注記：
この挙動は、［
多くの既存の前処理器に基づく入子法の挙動と合致する
］ことに加え，［
既存の `CSSStyleRule$I ~objに対し，大幅な変更を要求することなく、
規則を~CSSOM内で忠実に表出できる
］ことを確保する。
◎
Note: This behavior both matches many existing preprocessor-based nesting behaviors, and ensures that a rule can be faithfully expressed in the CSSOM without requiring drastic changes to the existing CSSStyleRule object.
</p>

<p class="note">注記：
宣言と入子な規則は，混ぜこぜにしても`かまわない^emが、
そうすると，いくぶん［
読み難く／紛らわしく
］なる
— すべての~prop【宣言】は、
すべての規則より前に来た`かのように動作する^emので。
可読性を高めるため、
作者には，［
~style規則~内の~propすべてを入子な規則より前に置く
］ことが推奨される。
（そうすれば、
入子な規則を~supportしない~UAにおいても，少し良く動作することになろう
— 入子な規則より後に現れている~propは、
構文解析と~error回復に特有な働きに因り，飛ばせるようになるので。）
◎
Note: While one can freely intermix declarations and nested rules, it’s harder to read and somewhat confusing to do so, since all the properties act as if they came before all the rules. For readability’s sake, it’s recommended that authors put all their properties first in a style rule, before any nested rules. (This also happens to act slightly better in older user agents; due to specifics of how parsing and error-recovery work, properties appearing after nested rules can get skipped.)
</p>

<p class="note">注記：
他の型の規則と同様に，入子ngが在る下では、
~style規則を直列化した結果は，それが元々書かれた~~形から変わり得る。
特に、
直に入子にされた~propはすべて，
どの入子な規則よりも前に直列化されることになる
— それが，~propを規則より前に書く`別の理由^emでもある。
◎
Note: Like with other types of rules, the serialization of style rules in the presence of nesting can vary from how they were originally written. Notably, all directly-nested properties will be serialized before any nested rules, which is another reason to write properties before rules.
</p>

		</section>
	</section>
	<section id="nest-selector">
<h2 title="Nesting Selector: the &amp; selector">4. 入子ng選択子： `&amp;^css 選択子</h2>

<p>
`入子な~style規則$を利用するときには、
親~規則に合致した要素を参照r可能にする必要がある【！must】。
それこそが，`入子法の要^em を成す。
これを成遂げるため、
この仕様は，
`&amp;@css
（ `0026^U `AMPERSAND^cn ）として記される新たな選択子として
`入子ng選択子@
（ `nesting selector^en ）を定義する。
◎
When using a nested style rule, one must be able to refer to the elements matched by the parent rule; that is, after all, the entire point of nesting. To accomplish that, this specification defines a new selector, the nesting selector, written as &amp; (U+0026 AMPERSAND).
</p>

<p>
`入子ng選択子$は、
`入子な~style規則$の選択子~内で利用されたときは，親~規則に合致した要素を表現する。
他の文脈~内で利用されたときは†、
その文脈において `scope$ps に合致する【！the same】要素を表現する
（他が指定されない限り）。
◎
When used in the selector of a nested style rule, the nesting selector represents the elements matched by the parent rule. When used in any other context, it represents the same elements as :scope in that context (unless otherwise defined).
</p>

<p class="trans-note">【†
したがって、
~top-level（入子にされない文脈）でも利用できることになる
（通例的には有用にならないであろうが）。
】</p>

<div class="note">
<p>注記：
`入子ng選択子$による糖衣は、
それを［
親~style規則の選択子を `is()$ps 選択子で包装したもの
］に置換することより外せる（ `desugar^en できる）。
例えば：
◎
The nesting selector can be desugared by replacing it with the parent style rule’s selector, wrapped in an :is() selector. For example,
</p>

<pre class="lang-css">
a, b {
  &amp; c { color: blue; }
}
</pre>

<p>
は、
次に等価になる：
◎
is equivalent to
</p>

<pre class="lang-css">
:is(a, b) c { color: blue; }
</pre>
</div>

<p>
`入子ng選択子$は、
疑似要素を表現し得ない
（ `is()$ps 疑似類の挙動に一致する）。
◎
The nesting selector cannot represent pseudo-elements (identical to the behavior of the :is() pseudo-class).
</p>

<div class="example">
<p>
例えば、
次の~style規則においては：
◎
For example, in the following style rule:
</p>

<pre class="lang-css">
.foo, .foo::before, .foo::after {
  color: red;

  &amp;:hover { color: blue; }
}
</pre>

<p>
`&amp;$css は，
`.foo^css に合致した要素に限り表現する
— 言い換えれば，次と等価になる：
◎
the &amp; only represents the elements matched by .foo; in other words, it’s equivalent to:
</p>

<pre class="lang-css">
.foo, .foo::before, .foo::after {
  color: red;
}
.foo:hover {
  color: blue;
}
</pre>
</div>

<p class="issue">
この制約は緩めたいが、［
`is()$ps, `&amp;$css
］両者に対し同時に行う必要がある
— それらは、
意図的に，同じ下層の仕組みの上に築かれるので。
（ `7433$issue ）
◎
We’d like to relax this restriction, but need to do so simultaneously for both :is() and &amp;, since they’re intentionally built on the same underlying mechanisms. (Issue 7433)
</p>

<p>
`入子ng選択子$の`詳細度$は、［
親~style規則の`選択子~list$を成す各`複階-選択子$の`詳細度$
］のうち最も高いものに等しい（ `is()$ps の挙動と一致する）。
◎
The specificity of the nesting selector is equal to the largest specificity among the complex selectors in the parent style rule’s selector list (identical to the behavior of :is()).
</p>

<div class="example">
<p>
例えば，次の~style規則が与えられたなら：
◎
For example, given the following style rules:
</p>

<pre class="lang-css">
#a, b {
  &amp; c { color: blue; }
}
.foo c { color: red; }
</pre>

<p>
次の様な~DOM構造においては：
◎
Then in a DOM structure like
</p>

<pre class="lang-html">&lt;b class=foo&gt;
  &lt;c&gt;Blue text&lt;/c&gt;
&lt;/b&gt;
</pre>

<p>
~textの色は、
`red^v ではなく `blue^v になる。
`&amp;$css の詳細度は［
`#a^css の詳細度 (1,0,0),
`b^css の詳細度 (0,0,1)
］のうち高い方 (1,0,0) になるので、
選択子~全体 `&amp; c^css の詳細度は (1,0,1) になる,
— それは `.foo c^css の詳細度 (0,1,1) より高い。
◎
The text will be blue, rather than red. The specificity of the &amp; is the larger of the specificities of #a ([1,0,0]) and b ([0,0,1]), so it’s [1,0,0], and the entire &amp; c selector thus has specificity [1,0,1], which is larger than the specificity of .foo c ([0,1,1]).
</p>

<p>
これは、［
入子ngを外して，入子にされない規則に手動で展開した場合に得られる結果
］とは`異なる^emことに注意。
そうした場合、
宣言 `color: blue^css は、
詳細度 (1,0,1) を伴う選択子 `#a c^css ではなく，
詳細度 (0,0,2) を伴う選択子 `b c^css に合致するので。
◎
Notably, this is different than the result you’d get if the nesting were manually expanded out into non-nested rules, since the color: blue declaration would then be matching due to the b c selector ([0,0,2]) rather than #a c ([1,0,1]).
</p>
</div>

<details class="note">
<summary>
なぜ、
入子にされない規則とは詳細度が異なるのか？
◎
Why is the specificity different than non-nested rules?
</summary>

<p>
`入子ng選択子$の詳細度は、
意図的に， `is()$ps 疑似類と同じ規則を利用するようにしてある。
それは、
各~引数の中で最も高い詳細度を利用するだけであり，
実際に合致した選択子が`どれなのか^emを追跡しない。
◎
The nesting selector intentionally uses the same specificity rules as the :is() pseudoclass, which just uses the largest specificity among its arguments, rather than tracking which selector actually matched.
</p>

<p>
これは、
処理能の理由から要求される。
選択子の詳細度を［
どれだけ精確に合致したかに依存して，アリなものが複数ある
］ようにした場合、
選択子の照合は，ずっと複雑で遅くなる。
◎
This is required for performance reasons; if a selector has multiple possible specificities, depending on how precisely it was matched, it makes selector matching much more complicated and slower.
</p>

<p>
ではなぜ `&amp;$css を `is()$ps の用語で定義するのか？
一部の非~browserによる［
入子法の様な機能性
］の実装は、
その多くが `is()^ps の導入~以前からあることもあって，
その糖衣を
— `is()^ps を通して外すことなく —
直に外す。
しかしながら，これには`有意な問題^emがついて来る
— 一部の（適度に共通的な）事例では、
指数関数的な爆発のアリ性に因り，不用意に`膨大^emな選択子を生産し得るので。
◎
That skirts the question, tho: why do we define &amp; in terms of :is()? Some non-browser implementations of Nesting-like functionality do not desugar to :is(), largely because they predate the introduction of :is() as well. Instead, they desugar directly; however, this comes with its own significant problems, as some (reasonably common) cases can accidentally produce massive selectors, due to the exponential explosion of possibilities.
</p>

<pre class="lang-css">
.a1, .a2, .a3 {
  .b1, .b3, .b3 {
    .c1, .c2, .c3 {
      ...;
    }
  }
}

/* <span class="comment">
素朴に糖衣を外したとすると：
◎
naively desugars to
</span> */
.a1 .b1 .c1,
.a1 .b1 .c2,
.a1 .b1 .c3,
.a1 .b2 .c1,
.a1 .b2 .c2,
.a1 .b2 .c3,
.a1 .b3 .c1,
.a1 .b3 .c2,
.a1 .b3 .c3,
.a2 .b1 .c1,
.a2 .b1 .c2,
.a2 .b1 .c3,
.a2 .b2 .c1,
.a2 .b2 .c2,
.a2 .b2 .c3,
.a2 .b3 .c1,
.a2 .b3 .c2,
.a2 .b3 .c3,
.a3 .b1 .c1,
.a3 .b1 .c2,
.a3 .b1 .c3,
.a3 .b2 .c1,
.a3 .b2 .c2,
.a3 .b2 .c3,
.a3 .b3 .c1,
.a3 .b3 .c2,
.a3 .b3 .c3 {...}
</pre>

<p>
ここには、
入子ng~levelが 3 つあり，
各~levelは 3 個の選択子からなる~listを伴う
— 糖衣を外した結果， 27 個の選択子が生産される。
［
~listに もっと選択子を追加する／
もっと入子ng~levelを追加する／
入子な規則をもっと複階的にする
］ことで，［
何~megabyteもの（あるいは，それを遥かに超える）選択子に展開される
］ような比較的~短い規則を作れる。
◎
Here, three levels of nesting, each with three selectors in their lists, produced 27 desugared selectors. Adding more selectors to the lists, adding more levels of nesting, or making the nested rules more complex can make a relatively small rule expand into multiple megabytes of selectors (or much, much more!).
</p>

<p>
一部の~CSS~toolは、
一部の~variationを経験的に破棄することにより，この最悪な~~事態を避ける
— なので、
それほど多量に出力せずとも，`おそらく^em正しいものになろう【？】。
が、
それは~UAに可用な~optionではない。
◎
Some CSS tools avoid the worst of this by heuristically discarding some variations, so they don’t have to output as much but are still probably correct, but that’s not an option available to UAs.
</p>

<p>
この問題は、
代わりに `is()$ps を通して糖衣を外すことで解消される
— それは、
詳細度の有用さを少し減らす~costを伴うが，適度な~trade-offと判定された。
◎
Desugaring with :is() instead eliminates this problem entirely, at the cost of making specificity slightly less useful, which was judged a reasonable trade-off.
</p>
</details>

<p>
`入子ng選択子$は、
`無特能$な要素に合致する能力がある
— そのような要素が親~規則に合致した場合には。
◎
The nesting selector is capable of matching featureless elements, if they were matched by the parent rule.
</p>

<p>
`複合-選択子$内では，`入子ng選択子$が どこに位置しようが挙動における相違は無いが
（すなわち、
`&amp;.foo^css と `.foo&amp;^css は同じ要素たちに合致する）、
それでも，［
`複合-選択子$内に`型~選択子$が在る場合、
それは最初に来なければならない
］とする既存の規則は適用される
（すなわち、
`&amp;div^css は違法であり，
代わりに `div&amp;^css と書かれなければならない）。
◎
While the position of a nesting selector in a compound selector does not make a difference in its behavior (that is, &amp;.foo and .foo&amp; match the same elements), the existing rule that a type selector, if present, must be first in the compound selector continues to apply (that is, &amp;div is illegal, and must be written div&amp; instead).
</p>

	</section>
	<section id="cssom">
<h2 title="CSSOM">5. ~CSSOM</h2>

<p class="note">注記：
`CSSOM-1$r は、
今や， `CSSStyleRule$I は子~規則を有し得るものと定義する。
◎
Note: [CSSOM-1] now defines that CSSStyleRule can have child rules.
</p>

<p>
`入子な~style規則$内の`相対~選択子$を直列化するときは、
当の選択子に暗黙な`入子ng選択子$を挿入して絶対~化するモノトスル。
◎
When serializing a relative selector in a nested style rule, the selector must be absolutized, with the implied nesting selector inserted.
</p>

<p>
`入子な~group規則$を直列化するときは、
もっぱら，子~規則で直列化する
【その本体~内の宣言たちは，常に子~規則として直列化する】
モノトスル。
◎
When serializing a nested group rule, it must serialize solely with child rules.
</p>

<div class="example">
<p>
例えば，選択子 `&gt; .foo^css は、
`&amp; &gt; .foo^css として直列化することになる。
◎
For example, the selector &gt; .foo will serialize as &amp; &gt; .foo.
</p>

<p>
次の様な`入子な~group規則$は：
◎
A nested group rule like:
</p>

<pre class="lang-css">
.foo {
  @media (prefers-color-scheme: dark) {
    color: white;
    background: black;
  }
}
</pre>

<p>
次のように直列化することになる：
◎
will serialize as:
</p>


<pre class="lang-css">
.foo {
  @media (prefers-color-scheme: dark) {
    &amp; {
      color: white;
      background: black;
    }
  }
}
</pre>
</div>


<p class="note">注記：
これらの規則は、
当の規則が他の文脈
— 入子にされない文脈も含む —
へ移動されても妥当になることを確保する。
また、
直列化が~CSSOMの構造に近く合致することも確保する。
◎
Note: These rules ensure that the rules in question are valid to be moved to other contexts, including non-nested ones. It also ensures that the serialization closely matches the structure of the CSSOM.
</p>

	</section>
</main></div>
