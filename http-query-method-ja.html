<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>The HTTP QUERY Method（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<style>
#table-1 td {
	min-width: 6em;
	max-width: 12em;
}
</style>

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:The HTTP QUERY Method
spec_date:2025-07-14
trans_update:2025-07-16
source_checked:250319
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-safe-method-w-body.html
	abbr_url:HTTPquery
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2024-01-02

●●class_map

●●tag_map

●●original_id_map

references:
normative:
informative:

●●mdn_urls

●●link_map

h.Accept-Query:#field.accept-query
m.QUERY:#query

~query内容:#query-content
~URI~query~parameter:#uri-query-parameter

~cache~key:~HTTPcache#cache-key

有構造~field:~STRUCTURED-FIELDS#structured-field
有構造~header:~STRUCTURED-FIELDS#structured-header
~sf~item:~STRUCTURED-FIELDS#sf-item
~sf~list:~STRUCTURED-FIELDS#sf-list
~sf~token:~STRUCTURED-FIELDS#sf-token
~sf文字列:~STRUCTURED-FIELDS#sf-string
~sf~parameter群:~STRUCTURED-FIELDS#sf-parameters
~sf~parameter:~STRUCTURED-FIELDS#sf-parameter

	●§
A.4:#example.content-location.location.indirect

●●words_table1
sf:<sub>sf-</sub>

●●words_table

	●略語
	XSLT:
	JSONPath:

	●処理
	通過-:pass through
	事前に:ahead of time
	得られた:yield
	開始し直-:restart

	●仕様
機能:function:~
協調-:coordinate:~
組入れな:incorporateしな:組み入れな
処置:disposition::~
隙間:gap:~
	隙間を~~埋める:spans the gap between
配役-:cast:~
選んで:chooseして:~
表記上の:notationalな:~
偽陽性:false positive:~
各個人:individuals:~
参加-:participate:~
特質:property:~:::プロパティ

	による難がある:suffers from
	に関して:with regard to
	ではなく:as opposed to
	事前に明らか:readily apparent
	はい:Yes
	〜によっては:depending
	効率的でない:inefficient
	有意でない:insignificant
	互いに協調していない:uncoordinated
	挙げる:illustrate
	~~説明:illustrate
	~~説明:illustration
	無い下では:absent
	長大過ぎる:too voluminous
	巨大:large
	望ましい:desirable
	従って:per
	違えて:differently
	~~簡潔にする:for brevity

	●言い換え
	~MIME型$:media type
	算出-用の:computing
	発見-可能:discoverable
	~target~URI$:the effective request URI
	要請~target$:Request URI
	要請~target$:request URI
	算出-用の:computing
	`内容~符号法$:content encoding
	~~代替策:variation
	~redirectされない:with direct response
	~redirectされない:direct
	~redirectされる:indirect
	と伴に:while identifying
	主張していること:claim
	〜によっては:certain
	どちらを選んでも:the choice of
	~~見かけ:appearする
	~UA:user client
	指示する:denote
	~JSON `RFC8259$r 化された:JSON-shaped ([RFC8259])
	再び為す:redo
	する限りにおいて:provided that
	動機になる:motivate
	〜され得ること:potential for 〜ing


	●未分類
locate:
予行:preflight::~::プリフライト
wildcard::::ワイルドカード
不定期:indefinite:~

	前回に:the previously
	見込みが高い:likely
	たった今:just
	〜安全とされる:-safelisted
	先頭に:leading
	短い:short
	年:year


●●ref_key_map
XSLT:XSLT3

●●ref_normative

[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
[HTTP-CACHING]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Caching＞, STD 98, ~RFC9111, June 2022,
[STRUCTURED-FIELDS]
    Nottingham, M. and P-H. Kamp, ＜Structured Field Values for HTTP＞, ~RFC9651, September 2024

●●ref_informative

[FETCH]
    WHATWG, ＜FETCH＞
    URL: https://fetch.spec.whatwg.org
[RFC6838]
    Freed, N., Klensin, J., and T. Hansen, ＜Media Type Specifications and Registration Procedures＞, BCP 13, ~RFC6838
[RFC8259]
    Bray, T., Ed., ＜The JavaScript Object Notation (JSON) Data Interchange Format＞, STD 90, ~RFC8259
[RFC9535]
    Gössner, S., Ed., Normington, G., Ed., and C. Bormann, Ed., ＜JSONPath: Query Expressions for JSON＞, ~RFC9535
[URL]
    WHATWG, ＜URL＞
    URL: https://url.spec.whatwg.org
[XSLT]
    Kay, M., ＜XSL Transformations (XSLT) Version 3.0＞, W3C Recommendation REC-xslt-30-20170608, 8 June 2017
    URL: https://www.w3.org/TR/xslt-30/

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公表された，
<a href="~SPEC_URL">The HTTP QUERY Method</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Workgroup
	HTTP
公表者
	<a href="https://httpwg.org/">HTTP Working Group</a>
位置付け
	Internet-Draft
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	<a href="mailto:julian.reschke@greenbytes.de">Julian Reschke</a> (greenbytes GmbH)
	<a href="mailto:jasnell@gmail.com">James M Snell</a> (Cloudflare)
	<a href="mbishop@evequefou.be">Mike Bishop</a> (Akamai)

課題追跡
	https://github.com/httpwg/http-extensions/labels/query-method
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-safe-method-w-body/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-safe-method-w-body.xml
HTTP WG mailing list
	ietf-http-wg@w3.org
	<a href="https://lists.w3.org/Archives/Public/ietf-http-wg/">archive</a>

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
現在の Internet-Draft のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP QUERY メソッド</h1>
<p lang="en">The HTTP QUERY Method</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section>
◎要約

<p>
この仕様は、
~HTTP用に `QUERY$m `~method$を定義する。
`QUERY^m は、
`要請~target$に対し，［
同封された`内容$を`安全$かつ【！/】`冪等$な方式で処理して，その結果で応答する
］よう要請する。
これは， `POST$m 要請に類似するが、
部分的な状態~変更の懸念を伴うことなく，自動的に［
繰返せる／開始し直せる
］。
◎
This specification defines the QUERY method for HTTP. A QUERY requests that the request target process the enclosed content in a safe/idempotent manner and then respond with the result of that processing. This is similar to POST requests but can be automatically repeated or restarted without concern for partial state changes.
</p>

	</section>
	<section>
<h2 title="Editorial Note">編集上の注記</h2>

<p>
この注記は、
~RFCとして公表する前に除去されることになる。
【以下，この節の内容は、冒頭の “この文書についての詳細” に移譲。】
◎
This note is to be removed before publishing as an RFC.
</p>

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2025 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
この仕様は、
`QUERY$m `~method$を定義する
— ~HTTPにおいて，次のような`要請$を為すための手段として：
◎
This specification defines the HTTP QUERY request method as a means of making＼
</p>
<ul>
	<li>
`安全$かつ`冪等$である
◎
a safe, idempotent request (Section 9.2 of [HTTP])＼
</li>
	<li>
その`内容$は、［
当の要請が`~target資源$により どう処理されるようになるか
］を述べる
◎
containing content that describes how the request is to be processed by the target resource.
</li>
</ul>

<p>
これが望ましくなるのは、［
要請~内に伝達される~dataが，
要請の~URI【`要請~target$】の中へ符号化するには長大過ぎる
］ときが，最も多い。
例えば、
次の~query~patternは，共通的にある：
◎
Most often, this is desirable when the data conveyed in a request is too voluminous to be encoded into the request's URI. For example, this is a common query pattern:
</p>

<pre class="lang-http">
GET /feed?q=foo&amp;limit=10&amp;sort=-published HTTP/1.1
Host: example.org
</pre>

<p>
しかしながら，~queryに伴われる~parameterが［
複階的／巨大
］な場合、
それを`要請~target$【！要請~URI】内に符号化することは，
最善な~optionではないであろう
— なぜなら：
◎
However, for a query with parameters that are complex or large, encoding it in the request URI may not be the best option because
</p>
<ul>
	<li>
~URIの~size上限は、
事前に既知でないことが多い
— 要請は、
互いに協調しない多くの~systemを通過し得るので。
（が、
`HTTP$r `~URI参照＠~HTTPinfra#uri.references§
は［
`送信者$, `受信者$
］に 8000 ~octet以上を~supportするよう推奨していることに注意）。
◎
often size limits are not known ahead of time because a request can pass through many uncoordinated systems (but note that Section 4.1 of [HTTP] recommends senders and recipients to support at least 8000 octets),
</li>
	<li>
~dataの種類によっては、
`~target~URI$内に表出することは，効率的でない
— そのような~dataを妥当な~URIの中へ符号化することには~overheadがあるので。
◎
expressing certain kinds of data in the target URI is inefficient because of the overhead of encoding that data into a valid URI, and
</li>
	<li>
~queryを`要請~target$【！要請~URI】の中へ直に符号化することは、
実質的に，~query入力を成す あらゆるアリな組合nそれぞれを別個な`資源$として配役することでもある。
◎
encoding queries directly into the request URI effectively casts every possible combination of query inputs as distinct resources.
</li>
</ul>

<p>
`GET$m ~methodを利用することの代替として、
多くの実装は， `POST$m ~methodを用立てて~queryを遂行する
— 下の例で~~説明されるとおり。
この事例では、
~query演算に対する入力は，要請の`内容$として渡される
— `要請~target$【！request URI】の `query$p 成分を利用するのではなく。
◎
As an alternative to using GET, many implementations make use of the HTTP POST method to perform queries, as illustrated in the example below. In this case, the input to the query operation is passed as the request content as opposed to using the request URI's query component.
</p>

<div class="example">
<p>
ある~queryを要請している `POST$m の典型的な利用：
◎
A typical use of HTTP POST for requesting a query is:
</p>

<pre class="lang-http">
POST /feed HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded

q=foo&amp;limit=10&amp;sort=-published
</pre>
</div>

<p>
しかしながら，この~~代替策には、
`GET$m と同じ【異なる？】基本的な制限による難
— 要請の送信-先である［
`資源$や`~server$
］に特有な知識が無い下では、
`安全$かつ`冪等$な~queryを遂行するかどうかが，事前に明らかでない難 —
がある。
◎
This variation, however, suffers from the same basic limitation as GET in that it is not readily apparent -- absent specific knowledge of the resource and server to which the request is being sent -- that a safe, idempotent query is being performed.
</p>

<p>
`QUERY^m ~methodは、
`GET$m の利用と `POST$m の利用の隙間を~~埋める解決策を供する
— 上の例が，次として表出されるよう：
◎
The QUERY method provides a solution that spans the gap between the use of GET and POST, with the example above being expressed as:
</p>

<pre class="lang-http">
QUERY /feed HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded

q=foo&amp;limit=10&amp;sort=-published
</pre>

<p>
~query演算への入力は、
`POST$m と同じく，要請の`内容$として渡される
— `要請~target$【！要請~URI】の一部としてではなく。
しかしながら， `POST$m と違って、
この~methodは明示的に`安全$かつ`冪等$であり，
~cachingや自動的な再試行の様な機能を運用することを許容する。
◎
As with POST, the input to the query operation is passed as the content of the request rather than as part of the request URI. Unlike POST, however, the method is explicitly safe and idempotent, allowing functions like caching and automatic retries to operate.
</p>

<div>
<p>
これら関連な各~methodの特質を次の表tに要約すると：
</p>
<table id="table-1"><thead><tr>
<th>
<th>`GET$m
<th>`QUERY$m
<th>`POST$m
<tbody>

<tr>
<td>`安全$か
<td>はい
<td>はい
<td>いいえになり得る

<tr>
<td>`冪等$か
<td>はい
<td>はい
<td>いいえになり得る

<tr>
<td>`~cache可能$か
<td>はい
<td>はい
<td>はい
— ただし，未来の［
`GET$m ／ `HEAD$m
］要請~用に限る。

<tr>
<td>`内容$（本体）
<td>“定義された意味論は無い”
<td>期待される（意味論は`~target資源$に従う）
<td>期待される（意味論は`~target資源$に従う）

</table>
◎
Summarizing:
◎
Table 1: Summary of relevant method properties
｜GET｜QUERY｜POST
Safe｜yes｜yes｜potentially no
Idempotent｜yes｜yes｜potentially no
Cacheable｜yes｜yes｜yes, but only for future GET or HEAD requests
Content (body)｜"no defined semantics"｜expected (semantics per target resource) 	expected (semantics per target resource)
</div>

	</section>
	<section id="terminology">
<h3 title="Terminology">1.1. 各種用語</h3>

<p>
この文書は、
`HTTP$r `各種用語と中核~概念＠~HTTPinfra#terminology§
にて定義される各種用語を利用する。
◎
This document uses terminology defined in Section 3 of [HTTP].
</p>

<div>
<p>
加えて，次に挙げる用語も利用する：
</p>
<ul>
	<li>
`~URI~query~parameter@
は、
~URIの `query$p 成分~内の~parameterを指す。
</li>
	<li>
`~query内容@
は、
`QUERY$m 要請の`内容$を指す。
</li>
</ul>
◎
Furthermore, it uses the terms URI query parameter for parameters in the query component of a URI (Section 4.2.2 of [HTTP]) and query content for the request content (Section 6.4 of [HTTP]) of a QUERY request.
</div>

	</section>
	<section id="notational.conventions">
<h3 title="Notational Conventions">1.2. 表記上の規約</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

	</section>
	<section id="query">
<h2 title="QUERY">2. `QUERY^m</h2>

<p>
`QUERY^m ~methodは、
~server側の~queryを起動するために利用される。
`GET$m ~methodは、［
`~target~URI$により識別される`資源$の`表現$
］を返すよう~serverに要請するが
（ `HTTP$r `~target資源の決定-法＠~HTTPsem#target.resource§
にて定義されるとおり），それとは違って：
`QUERY^m ~methodは、［
当の資源にある何らかの~dataが成す集合
］にわたって［
（要請の`内容$により述べられる）
~query演算を遂行する
］よう~serverに依頼するために利用される。
対する応答~内に返される`内容$は、
`~target~URI$により識別される`資源$の`表現$とは見做せない。
◎
The QUERY method is used to initiate a server-side query. Unlike the HTTP GET method, which requests that a server return a representation of the resource identified by the target URI (as defined by Section 7.1 of [HTTP]), the QUERY method is used to ask the server to perform a query operation (described by the request content) over some set of data at the resource. The content returned in response to a QUERY cannot be assumed to be a representation of the resource identified by the target URI.
</p>

<p>
~queryは、［
`QUERY^m 要請の`内容$ %内容,
%内容 の`~MIME型$
］が定義する。
実装は、
%内容 が【その~MIME型に則って】適切な~query意味論を供する限りにおいて，
%内容 を利用してもヨイ
— 当の~MIME型が何であれ。
◎
The content of the request and it's media type define the query. Implementations MAY use a request content of any media type with the QUERY method, provided that it has appropriate query semantics.
</p>

<p>
`~target~URI$の `query$p 成分【！query part】は、
一般におけるすべての`~method$と同じく，
~queryされている`資源$の識別-法の一部を成すものであり、
したがって，実際の~queryの一部を成すものではない。
`~URI~query~parameter$【！URI's query part】が~queryの結果に［
直に影響するか否か, どう影響するか
］は、
実装に特有であり，この仕様の視野から外れる。
◎
As for all HTTP methods in general, the target URI's query part takes part in identifying the resource being queried and therefore is not part of the actual query. Whether and how the URI's query part directly affects the result of the query is implementation specific and out of scope for this specification.
</p>

<p>
`QUERY^m 要請は、
`要請~target$【！要請~URI】により識別される`資源$に関して`安全$かつ`冪等$である
— すなわち、
識別された資源の状態を改めない。
しかしながら，~serverには、
`QUERY^m 要請を処理している間に，
算出-用の資源や~memory資源を割振ることが
— さらには、
追加的な`資源$を作成して，
それを通して応答を検索取得できるようにすることも —
期待され得る。
◎
QUERY requests are both safe and idempotent with regard to the resource identified by the request URI. That is, QUERY requests do not alter the state of the identified resource. However, while processing a QUERY request, a server can be expected to allocate computing and memory resources or even create additional HTTP resources through which the response can be retrieved.
</p>

<p>
`QUERY^m 要請に対する成功裡な応答には、
当の演算の最終-処置として，何らかの指示を供することが期待される。
一例として，
ある成功裡な~queryにおいて得られた結果が無い場合、
`204$st 応答により表現できる。
当の応答が`内容$を内包する場合、
それが，演算の結果を述べるものと期待される。
◎
A successful response to a QUERY request is expected to provide some indication as to the final disposition of the operation. For instance, a successful query that yields no results can be represented by a 204 (No Content, Section 15.3.5 of [HTTP]) response. If the response includes content, it is expected to describe the results of the operation.
</p>

		<section id="content-location">
<h3 title="Content-Location Response Field">2.1. `Content-Location^h 応答~field</h3>

<p>
`QUERY^m 要請に対する成功裡な応答（ `2xx$st0 ）は、［
当の演算の結果に対応している`資源$
］用の識別子を包含する `Content-Location$h ~header `HTTP$r も内包できる。
これは、［
~clientは、
指示された~URIへ `GET$m 要請を送信することで，
たった今 遂行した~query演算の結果を検索取得できる
］ものと［
~serverが主張している
］ことを表現する。
指示された資源は一時的かもしれない。
◎
A successful response (2xx, Section 15.3 of [HTTP]) can include a Content-Location header field containing an identifier for a resource corresponding to the results of the operation; see Section 8.7 of [HTTP] for details. This represents a claim from the server that a client can send a GET request for the indicated URI to retrieve the results of the query operation just performed. The indicated resource might be temporary.
</p>

<p>
その例は、
`A.4.1＠#example.content-location§を見よ。
◎
See Appendix A.4.1 for an example.
</p>

		</section>
		<section id="location">
<h3 title="Location Response Field">2.2. `Location^h 応答~field</h3>

<p>
`~server$は、
未来の利用-用に，当の~query演算を識別する`資源$を作成できる
— あるいは【作成-済みなそれが在るならば，それを】~locateできる。
`~server$は、
それを行う場合には，応答の `Location$h ~header `HTTP$r 内に当の資源の~URIを内包できる。
これは、［
`~client$は、
指示された~URIへ `GET$m 要請を送信することで，
たった今 遂行した~query演算を`~query内容$を送信し直すことなく繰返せる
］ものと主張していることを表現する。
この資源は、
一時的かもしれない
— 未来の要請が失敗した場合、
~clientは，［
元の `QUERY^m 資源と前回に提出した`内容$
］を再び利用して試行し直せる。
◎
A server can create or locate a resource that identifies the query operation for future use. If the server does so, the URI of the resource can be included in the Location header field of the response (see Section 10.2.2 of [HTTP]). This represents a claim that a client can send a GET request to the indicated URI to repeat the query operation just performed without resending the query content. This resource might be temporary; if a future request fails, the client can retry using the original QUERY resource and the previously submitted content.
</p>

<p>
その例は、
`A.4.2＠#example.location§
を見よ。
◎
See Appendix A.4.2 for an example.
</p>

		</section>
		<section id="redirection">
<h3 title="Redirection">2.3. ~redirection</h3>

<p>
`~server$は、
一部の事例では， `QUERY^m 要請に対し間接的に応答することを選んでもよい
— `~UA$を異なる~URIへ~redirectすることにより
（ `HTTP$r `3xx§st を見よ）。
~redirect応答の意味論は、
他の~methodと相違しない。
◎
In some cases, the server may choose to respond indirectly to the QUERY request by redirecting the user agent to a different URI (see Section 15.4 of [HTTP]). The semantics of the redirect response do not differ from other methods.
</p>

<p>
一例として、
`303$st 応答は，
`Location$h ~fieldが代替-~URIを識別することを指示することになる
— そこから， `GET$m 要請を利用して結果を検索取得できるような
（ `2xx$st0 応答における `Location$h ~fieldの利用も，この利用事例を受持つ）。
◎
For instance, a 303 (See Other, Section 15.4.4 of [HTTP]) response would indicate that the Location field identifies an alternate URI from which the results can be retrieved using a GET request (this use case is also covered by the use of the Location response field in a 2xx response).
</p>

<p>
他方，`状態s~code$［
`307$st, `308$st
］は、［
`Location$h ~fieldにより指定された~URIに対し `QUERY^m 要請を再び為す
］よう，~UAに要請するために利用できる。
◎
On the other hand, response codes 307 (Temporary Redirect, Section 15.4.8 of [HTTP]) and 308 (Permanent Redirect, Section 15.4.9 of [HTTP]) can be used to request the user agent to redo the QUERY request on the URI specified by the Location field.
</p>

<p>
`例＠#examples§ にて，
`QUERY^m 要請に対する成功裡な応答を成す様々な規範的でない例を挙げる。
◎
Various non-normative examples of successful QUERY responses are illustrated in Appendix A.
</p>

		</section>
		<section id="conditional">
<h3 title="Conditional Requests">2.4. 条件付き要請</h3>

<p>
条件付き `QUERY^m 要請に対する応答~内に`選定された表現$
（すなわち、
`内容~折衝$（もしあれば）の後における~query結果）が返されるのは、
`HTTP$r `条件付き要請＠~HTTPsem#conditional.requests§【内の特に，`事前条件の評価＠~HTTPsem#evaluation§】にて定義されるとおり，
`条件付き要請~header$（たち）により述べられる状況下に限られる。
◎
A conditional QUERY requests that the selected representation (i.e., the query results, after any content negotiation) be returned in the response only under the circumstances described by the conditional header field(s), as defined in Section 13 of [HTTP].
</p>

		</section>
		<section id="caching">
<h3 title="Caching">2.5. ~cache法</h3>

<p>
`QUERY^m ~methodに対する応答は、
`~cache可能$である
— ~cacheは、
それを利用して，後続な `QUERY^m 要請を満足してもヨイ
（ `HTTP-CACHING$r `~cacheからの応答の構築-法＠~HTTPcache#constructing.responses.from.caches§
に従う下で）。
◎
The response to a QUERY method is cacheable; a cache MAY use it to satisfy subsequent QUERY requests as per Section 4 of [HTTP-CACHING]).
</p>

<p>
`QUERY^m 要請~用の`~cache~key$ `HTTP-CACHING$r には、
当の要請の`内容$を組入れなければナラナイ。
◎
The cache key for a QUERY request (see Section 2 of [HTTP-CACHING]) MUST incorporate the request content.
</p>

<p>
~cacheは、
~cache効率を改善するためとして，
まず【内容における】意味論的に有意でない相違点を除去してもヨイ
— 一例として，次に行うことにより：
◎
Caches MAY remove semantically insignificant differences first, thereby improving cache efficiency.
◎
For instance, by
</p>
<ul>
	<li>
`内容~符号法$（たち）を除去する。
◎
removing content encoding(s) (Section 8.4 of [HTTP]).
</li>
	<li>
<p>
当の要請が `Content-Type$h ~fieldを伴う場合、
その値に与えられた`~MIME型$ %~MIME型 を利用して：
◎
↓</p>
		<ul>
			<li>
%~MIME型 の下位型を成す接尾辞
（例： "`+json^c"
— `RFC6838$r `4.2.8＠~RFCx/rfc6838#section-4.2.8§
を見よ）
により指示される形式~規約に関する知識に基づいて正規化する。
◎
normalizing based upon knowledge of format conventions, as indicated by any media subtype suffix in the request's Content-Type field (e.g., "+json", see Section 4.2.8 of [RFC6838]).
</li>
			<li>
%~MIME型 により指示される［
当の`内容$自体の意味論に関する知識
］に基づいて正規化する。
◎
normalizing based upon knowledge of the semantics of the content itself, as indicated by the request's Content-Type field.
</li>
		</ul>
	</li>
</ul>

<p>
そのような形式変換は、
もっぱら，`~cache~key$を生成する目的で遂行されることに注意
— それは、
当の要請~自体を変更するものではない。
◎
Note that any such transformation is performed solely for the purpose of generating a cache key; it does not change the request itself.
</p>

<p>
~clientは、
`no-transform＠~HTTPcache#cache-request-directive.no-transform$dir ~cache指令を利用して，
そのような形式変換が起こらないよう望むことを指示できる
（が、
この指令は，助言的でしかないことに注意）。
◎
Clients can indicate, using the "no-transform" cache directive (Section 5.2.1.6 of [HTTP-CACHING]), that they wish that no such transformation happens (but note that this directive is just advisory).
</p>

		</section>
		<section id="range">
<h3 title="Range Requests">2.6. 範囲~要請</h3>

<p>
`QUERY^m ~method用の`範囲~要請$の意味論は、
— `HTTP$r `範囲~要請＠~HTTPsem#range.requests§にて定義されるとおり，
`GET$m 用のそれと一致する。
◎
The semantics of Range Requests for QUERY are identical to those for GET, as defined in Section 14 of [HTTP].
</p>

		</section>
	</section>
	<section id="field.accept-query">
<h2 title="The &quot;Accept-Query&quot; Header Field">3. `Accept-Query^h ~header</h2>

<p>
`資源$は、
`QUERY^m ~method用の~supportと伴に［
当の資源に利用してもよい特定の~query形式の`~MIME型$（たち）
］を直に通達するためとして，
`Accept-Query^h 応答~headerを利用できる。
◎
The "Accept-Query" response header field can be used by a resource to directly signal support for the QUERY method while identifying the specific query format media type(s) that may be used.
</p>

<div>
<p>
`Accept-Query^h は、
`有構造~field$の構文 `STRUCTURED-FIELDS$r を利用して，
~MIME型~範囲【！media range】（ `media-range$p `HTTP$r ）たちを包含する。
それは、
`有構造~header$であり，その`~field値$として`~sf~list$をとる
— この~listを成す各`~sf~item$の：
</p>
<ul>
	<li>
値は、［
`~sf~token$／`~sf文字列$
］である
— それは、［
`media-range$p を成す `parameters$p 以外の部分
］を表現する。
</li>
	<li>
`~sf~parameter群$は、
`media-range$p を成す `parameters$p を表現する。
それを成す各`~sf~parameter$の値は、［
`~sf~token$／`~sf文字列$
］である。
</li>
</ul>
◎
Accept-Query contains a list of media ranges (Section 12.5.1 of [HTTP]) using "Structured Fields" syntax ([STRUCTURED-FIELDS]). Media ranges are represented by a List Structured Header Field of either Tokens or Strings, containing the media range value without parameters.
◎
Media type parameters, if any, are mapped to Structured Field Parameters of type String or Token.＼
</div>

<p>
［
`~sf~token$, `~sf文字列$
］どちらを選んでも，意味論的には有意でない。
すなわち、
`受信者$は`~sf~token$を`~sf文字列$へ変換してもヨイが，
それらの処理-法を受信した型に基づいて違えてはナラナイ。
◎
The choice of Token vs. String is semantically insignificant. That is, recipients MAY convert Tokens to Strings, but MUST NOT process them differently based on the received type.
</p>

<p>
~MIME型には，`~sf~token$へは正確に対応付けられないものもある
— 一例として、
それらは先頭に数字を許容する。
その様な事例では、
`~sf文字列$を利用する必要がある。
◎
Media types do not exactly map to Tokens, for instance they allow a leading digit. In cases like these, the String format needs to be used.
</p>

<p>
~MIME型~範囲における~wildcard（ `*^c ）の利用として~supportされるのは、
次のいずれかに限られる：
◎
The only supported uses of wildcards are＼
</p>
<ul>
	<li>
"`*/*^c"
⇒
どの~MIME型【！型】にも合致する,
◎
"*/*", which matches any type,＼
</li>
	<li>
"`<var>type</var>/*^c"
⇒
指示された~MIME型【！型】 %type を成すどの下位型にも合致する。
◎
or "xxxx/*", which matches any subtype of the indicated type.
</li>
</ul>

<p>
この~headerの`~field値$に~listされる~MIME型たちの順序は、
有意でない。
◎
The order of types listed in the field value is not significant.
</p>

<p>
`Accept-Query^h ~fieldの値は、
~server上の同じ~pathを共有する あらゆる~URIに適用される
— 言い換えれば、
~URIの `query$p 成分は無視される。
同じ`資源$への要請たちが異なる `Accept-Query^h 値を返す場合、
最も近過去に受信した新鮮な値が利用される
（ `HTTP-CACHING$r `鮮度＠~HTTPcache#expiration.model§
に従って）。
◎
The value of the Accept-Query field applies to every URI on the server that shares the same path; in other words, the query component is ignored. If requests to the same resource return different Accept-Query values, the most recently received fresh value (per Section 4.2 of [HTTP-CACHING]) is used.
</p>

<div class="example">
<p>
例：
◎
Example:
</p>
<pre class="lang-http">Accept-Query: "application/jsonpath", application/sql;charset="UTF-8"
</pre>
</div>

<p>
この~field用の構文は，他の~field
— `Accept$h `HTTP$r など —
の構文と~~見かけは類似するが、
`有構造~field$であるので，
`STRUCTURED-FIELDS$r `4＠~STRUCTURED-FIELDS#text§
にて指定されるとおりに処理しなければナラナイ。
◎
Although the syntax for this field appears to be similar to other fields, such as "Accept" (Section 12.5.1 of [HTTP]), it is a Structured Field and thus MUST be processed as specified in Section 4 of [STRUCTURED-FIELDS].
</p>

	</section>
	<section id="name-security-considerations">
<h2 title="Security Considerations">4. ~securityの考慮点</h2>

<p>
`QUERY^m ~methodは、
`HTTP$r にて述べられるとおり，［
すべての`~method$と同じ一般な~security考慮点
］の~subjectになる。
◎
The QUERY method is subject to the same general security considerations as all HTTP methods as described in [HTTP].
</p>

<p>
`QUERY^m ~methodは、［
~URI内（例： `query$p 成分）に要請~情報を渡すこと
］の代替として利用できる。
一部の事例では、
これが選好される
— ~URIは、
要請の`内容$よりも［
~logされたり，`媒介者$により処理される
］見込みが高いので。
特に【！other】，当の~queryが敏感な情報を包含する事例では、
~URIが~logされ得ることが，
`GET$m よりも `QUERY^m を利用する動機にもなろう。
◎
It can be used as an alternative to passing request information in the URI (e.g., in the query component). This is preferred in some cases, as the URI is more likely to be logged or otherwise processed by intermediaries than the request content. In other cases, where the query contains sensitive information, the potential for logging of the URI might motivate the use of QUERY over GET.
</p>

<p>
~serverは、
所与の `QUERY^m 要請 %要請 に対し，
その結果を表現する一時的な`資源$を作成する場合
（例： `Location$h や `Content-Location$h ~fieldにおける利用-用に）、
%要請 が［
~logさせ得ない敏感な情報
］を包含する場合には，この資源の~URIを［
%要請 を成す敏感な部位を内包しない
］ように選ぶベキである。
◎
If a server creates a temporary resource to represent the results of a QUERY request (e.g., for use in the Location or Content-Location field) and the request contains sensitive information that cannot be logged, then the URI of this resource SHOULD be chosen such that it does not include any sensitive portions of the original request content.
</p>

<p>
`~cache$が `QUERY^m 要請の`内容$を不正に
— あるいは、
要請の`~target資源$【！the resource】が当の内容を処理する方法とは有意に異なる仕方で —
正規化する場合【`~cache法＠#caching§ を見よ】、
その結果が偽陽性である場合に，不正な応答を返し得る。
◎
Caches that normalize QUERY content incorrectly or in ways that are significantly different from how the resource processes the content can return an incorrect response if normalization results in a false positive.
</p>

<p>
`~CORS＠~FETCH#http-cors-protocol$（ `Cross-Origin Resource Sharing^en ）を実装している`~UA$からの `QUERY^m 要請には、
`~CORS予行~要請＠~FETCH#cors-preflight-request$が要求されることになる
— `QUERY^m は、
`~CORS安全とされる~method＠~FETCH#cors-safelisted-method$ではないので。
`FETCH$r
◎
A QUERY request from user agents implementing CORS (Cross-Origin Resource Sharing) will require a "preflight" request, as QUERY does not belong to the set of CORS-safelisted methods (see "Methods" in [FETCH]).
</p>

	</section>
	<section id="iana.considerations">
<h2 title="IANA Considerations">5. ~IANA考慮点</h2>

		<section id="method.registration">
<h3 title="Registration of QUERY method">5.1. `QUERY^m ~methodの登録</h3>

<p>
~IANAには、
`~HTTP~method~registry＠~IANA-a/http-methods$cite
内に `QUERY^m ~methodを追加するよう要請される
（ `HTTP$r `~method~registry＠~HTTPinfra#method.registry§
を見よ）。
◎
IANA is requested to add the QUERY method to the HTTP Method Registry at &lt;http://www.iana.org/assignments/http-methods&gt; (see Section 16.3.1 of [HTTP]).
</p>

<div>
<table id="table-2"><thead><tr>
<th>~method名
<th>`安全$か
<th>`冪等$か
<th>仕様
<tbody>

<tr>
<td>`QUERY^m
<td>はい
<td>はい
<td>`§ 2＠#query$

</table>
◎
Table 2
Method Name｜Safe｜Idempotent｜Specification
QUERY｜Yes｜Yes｜Section 2
</div>

		</section>
		<section id="field.registration">
<h3 title="Registration of Accept-Query field">5.2. `Accept-Query^h ~fieldの登録</h3>

<p>
~IANAには、
`~HTTP~field名~registry＠~IANA-a/http-fields$cite
内に `Accept-Query^h ~fieldを追加するよう要請される
（ `HTTP$r `~field名~registry＠~HTTPinfra#fields.registry§
を見よ）。
◎
IANA is requested to add the Accept-Query field to the HTTP Field Name Registry at &lt;https://www.iana.org/assignments/http-fields&gt; (see Section 16.1.1 of [HTTP]).
</p>

<div>
<table id="table-3"><thead><tr>
<th>~field名
<th>位置付け
<th>有構造~型
<th>参照
<th>~comment
<tbody>

<tr>
<td>`Accept-Query^h
<td>恒久的
<td>`~sf~list$
<td>`3＠#field.accept-query§
<td>
</table>
◎
Table 3
Field Name｜Status｜Structured Type｜Reference｜Comments
Accept-Query｜permanent｜｜Section 3 of this document.｜
</div>

		</section>
	</section>
	<section id="examples">
<h2 title="Examples">付録 A. 例</h2>

<p>
以下に挙げる各~例は、
~~説明~目的に限られる。
このような短い~queryを実際に送信する必要がある場合、
`GET$m を利用する方が良くなる見込みが高い。
◎
The examples below are for illustrative purposes only; if one needs to send queries that are actually this short, it is likely better to use GET.
</p>

<p>
ほとんどの例では、
【 `QUERY^m 要請の`内容$の】`~MIME型$には `application/x-www-form-urlencoded＠~URL1#application/x-www-form-urlencoded$c `URL$r が利用される
（~browser~UAが `POST$m 要請に利用するものと同じ）。
~~簡潔にするため、
`Content-Length$h ~fieldは省略される。
◎
The media type used in most examples is "application/x-www-form-urlencoded" (as used in POST requests from browser user clients, defined in "application/x-www-form-urlencoded" in [URL]). The Content-Length fields have been omitted for brevity.
</p>

		<section id="example.simple">
<h3 title="A.1. Simple Query">A.1. 単純な~query</h3>

<p>
~redirectされない単純な~query：
◎
A simple query with a direct response:
</p>

<pre class="lang-http">
QUERY /contacts HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Accept: application/json

select=surname,givenname,email&amp;limit=10&amp;match=%<!--＊-->22email=*@example.*%<!--＊-->22
</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json

[
  { "surname": "Smith",
    "givenname": "John",
    "email": "smith@example.org" },
  { "surname": "Jones",
    "givenname": "Sally",
    "email": "sally.jones@example.com" },
  { "surname": "Dubois",
    "givenname": "Camille",
    "email": "camille.dubois@example.net" }
]
</pre>

		</section>
		<section id="example.discovery.method">
<h3 title="A.2. Discovery of QUERY support">A.2. `QUERY^m ~supportの発見</h3>

<p>
`OPTIONS$m ~methodは、
`QUERY^m 用の~supportを発見するための単純な仕方を供する：
◎
A simple way to discover support for QUERY is provided by the OPTIONS (Section 9.3.7 of [HTTP]) method:
</p>

<pre class="lang-http">
OPTIONS /contacts HTTP/1.1
Host: example.org

</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Allow: GET, QUERY, OPTIONS, HEAD
</pre>

<p>
応答の `Allow$h ~fieldは、
指定された資源が~supportする~methodたちが成す集合を指示する。
◎
The Allow response field (Section 10.2.1 of [HTTP]) denotes the set of supported methods on the specified resource.
</p>

<p>
`OPTIONS$m の利用に対する代替もある。
一例として、
`QUERY^m 要請は，~server~supportの知識がなくとも試行できる。
~serverは、
当の要請に対し［
それを処理する
］ことも［
`状態s~code$ `4xx$st0 
— `405$st など —
で， `Allow$h ~fieldも内包して応答する
］こともできる。
◎
There are alternatives to the use of OPTIONS. For instance, a QUERY request can be tried without prior knowledge of server support. The server would then either process the request, or could respond with a 4xx status such as 405 (Method Not Allowed, Section 15.5.6 of [HTTP]), including the Allow response field.
</p>

		</section>
		<section id="example.discovery.formats">
<h3 title="A.3. Discovery of QUERY Formats">A.3. `QUERY^m 形式の発見</h3>

<p>
`QUERY^m 用に~supportされる`~MIME型$の発見は、
`Accept-Query$h 応答~fieldを介してアリになる：
◎
Discovery of supported media types for QUERY is possible via the Accept-Query (Section 3) response field:
</p>

<pre class="lang-http">
HEAD /contacts HTTP/1.1
Host: example.org

</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/xhtml
Accept-Query: application/x-www-form-urlencoded, application/sql
</pre>

<p>
応答の `Accept-Query$h が包含することになる~MIME型【！要請~method】は、
~accessされている資源に依存する。
◎
Responses to which request methods will contain Accept-Query will depend on the resource being accessed.
</p>

<p>
`Accept-Query$h の検査に対する代替は、
`QUERY^m 要請を為してから，
対する応答が `4xx$st0 状態s
— `415$st など —
を伴う事例では，その `Accept$h ~fieldを検分することである：
◎
An alternative to checking Accept-Query would be to make a QUERY request, and then -- in case of a 4xx status such as 415 (Unsupported Media Type, Section 15.5.16 of [HTTP]) response -- to inspect the Accept (Section 12.5.1 of [HTTP]) response field:
</p>

<pre class="lang-http">
HTTP/1.1 415 Unsupported Media Type
Content-Type: application/xhtml
Accept: application/x-www-form-urlencoded, application/sql
</pre>

		</section>
		<section id="example.content-location.location.indirect">
<h3 title="A.4. Content-Location, Location, and Indirect Responses">A.4. `Content-Location^h, `Location^h, ~redirectされる応答</h3>

<p>
`2.1＠#content-location§, `2.1＠#location§にて述べたとおり、
`QUERY^m 要請に対する成功裡な【！success】応答（ `2xx$st0 ）内の［
`Content-Location$h, `Location$h
］~fieldは，
`GET$m 要請に対し応答することになる代替-資源
— ［
応答~内に受信した結果
］あるいは［
同じ演算を遂行する未来の要請
］用の資源 —
を識別する仕方を供する。
`A.1＠#example.simple§の例と同じ要請：
◎
As described in Sections 2.1 and 2.2, the Content-Location and Location response fields in success responses (2xx, Section 15.3 of [HTTP]) provide a way to identify alternate resources that will respond to GET requests, either for the received result of the request, or for future requests to perform the same operation. Going back to the example from Appendix A.1:
</p>

<pre class="lang-http">
QUERY /contacts HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Accept: application/json

select=surname,givenname,email&amp;limit=10&amp;match=%<!--＊-->22email=*@example.*%<!--＊-->22
</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Content-Location: /contacts/stored-results/17
Location: /contacts/stored-queries/42
Last-Modified: Sat, 25 Aug 2012 23:34:45 GMT
Date: Sun, 17 Nov 2024, 16:10:24 GMT

[
  { "surname": "Smith",
    "givenname": "John",
    "email": "smith@example.org" },
  { "surname": "Jones",
    "givenname": "Sally",
    "email": "sally.jones@example.com" },
  { "surname": "Dubois",
    "givenname": "Camille",
    "email": "camille.dubois@example.net" }
]
</pre>

			<section id="example.content-location">
<h4 title="A.4.1. Using Content-Location">A.4.1. `Content-Location^h の利用-法</h4>

<p>
`Content-Location$h 応答~fieldは、
当の応答の結果を保持している資源を識別する。
◎
The Content-Location response field received above identifies a resource holding the result for the QUERY response it appeared on:
</p>

<p>
`A.4§の応答~内に出現したそれへの `GET^m 要請：
</p>

<pre class="lang-http">
GET /contacts/stored-results/17 HTTP/1.1
Host: example.org
Accept: application/json

</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Last-Modified: Sat, 25 Aug 2012 23:34:45 GMT
Date: Sun, 17 Nov 2024, 16:10:25 GMT

[
  { "surname": "Smith",
    "givenname": "John",
    "email": "smith@example.org" },
  { "surname": "Jones",
    "givenname": "Sally",
    "email": "sally.jones@example.com" },
  { "surname": "Dubois",
    "givenname": "Camille",
    "email": "camille.dubois@example.net" }
]
</pre>

<p>
~serverが，この資源を不定期に実装することは、
保証されないことに注意。
なので，~clientは、
~error応答の後に新たな［
代替な所在
］を得するためには，
元の `QUERY^m 要請を再び為す必要がある。
◎
Note that there's no guarantee that the server will implement this resource indefinitely, so, after an error response, the client would need to redo the original QUERY request in order to obtain a new alternative location.
</p>

			</section>
			<section id="example.location">
<h4 title="A.4.2. Using Location">A.4.2. `Location^h の利用-法</h4>

<p>
`Location$h 応答~fieldは、
`GET$m に対し，次で応答することになる資源を識別する
⇒
元の `QUERY^m 要請と同じ処理nに同じ~parameterを与えたとするときの現在の結果
◎
The Location response field identifies a resource that will respond to GET with a current result for the same process and parameters as the original QUERY request.
</p>

<p>
`A.4§の応答~内に出現したそれへの `GET^m 要請：
</p>

<pre class="lang-http">
GET /contacts/stored-queries/42 HTTP/1.1
Host: example.org
Accept: application/json

</pre>

<p>
この例では、
対する応答は，［
`Last-Modified$h ~fieldが指示する日付 `2024-11-17T16:12:01Z^c にて，
1 個の~entryが除去された
］ため，
2 個の~entryしか包含していない：
◎
In this example, one entry was removed at 2024-11-17T16:12:01Z (as indicated in the Last-Modified field), so the response only contains two entries:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Last-Modified: Sun, 17 November 2024, 16:12:01 GMT
ETag: "42-1"
Date: Sun, 17 Nov 2024, 16:13:17 GMT

[
  { "surname": "Smith",
    "givenname": "John",
    "email": "smith@example.org" },
  { "surname": "Dubois",
    "givenname": "Camille",
    "email": "camille.dubois@example.net" }
]
</pre>

<p>
次を伴う後続な条件付き `GET$m 要請：
◎
↓ Assuming that the server still exposes the resource and that there was no change in the query result,＼
a subsequent conditional GET request with
</p>

<pre class="lang-http">
If-None-Match: "42-1"
</pre>

<p>
による結果は、［
当の~serverは、
依然として当の資源を公開する
］かつ［
当の~queryに対する結果が以前の時点から変化していない
］と見做すなら，
`304$st 応答になる。
◎
would result in a 304 response (Not Modified, Section 15.4.5 of [HTTP]).
</p>

			</section>
			<section id="example.indirect">
<h4 title="A.4.3. Indirect Responses">A.4.3. ~redirectされる応答</h4>

<p>
~serverは、
`状態s~code$ `303$st を利用して，`~redirectされる応答＠#redirection$を送信できる。
◎
Servers can send "indirect" responses (Section 2.3) using the status code 303 (See Other, Section 15.4.4 of [HTTP]).
</p>

<p>
`A.4§の要請に対しては、
~serverは，次で応答するかもしれない：
◎
Given the request at the beginning of Appendix A.4, a server might respond with:
</p>

<pre class="lang-http">
HTTP/1.1 303 See Other
Content-Type: text/plain
Date: Sun, 17 Nov 2024, 16:13:17 GMT
Location: /contacts/stored-queries/42

See stored query at "/contacts/stored-queries/42".
</pre>

<p>
これは、
当の~query用に返される結果【すなわち，応答の`内容$】が無いことを除いて，
~redirectされない応答に `Location$h を内包することに類似する。
これは、
代替な資源しか［
`生成-$しない／再利用しない
］ことを~serverに許容する。
この資源は、
`A.4.2＠#example.location§にて示したとおり利用することもできる。
◎
This is similar to including Location on a direct response, except that no result for the query is returned. This allows the server to only generate or reuse an alternative resource. This resource could then be used as shown in Appendix A.4.2.
</p>

			</section>
		</section>
		<section id="example.more.query.formats">
<h3 title="A.5. More Query Formats">A.5. 別の~query形式</h3>

<p>
次の例は、
~JSON `RFC8259$r 化された~RFC正誤表~databaseに対する要請を示す。
◎
The following examples show requests on a JSON-shaped ([RFC8259]) database of RFC errata.
</p>

<p>
次の要請は、
`XSLT^cite `XSLT$r を利用して［
年ごと, 定義-済みな正誤表~種別ごと
］に要約された正誤表~情報を抽出する。
◎
The request below uses XSLT ([XSLT]) to extract errata information summarized per year and the defined errata types.
</p>

<pre class="lang-http">
QUERY /errata.json HTTP/1.1
Host: example.org
Content-Type: application/xslt+xml
Accept: application/xml, text/csv

&lt;transform xmlns="http://www.w3.org/1999/XSL/Transform"
  xmlns:j="http://www.w3.org/2005/xpath-functions"
  version="3.0"&gt;

  &lt;output method="text"/&gt;

  &lt;param name="input"/&gt;

  &lt;variable name="json"
    select="json-to-xml(unparsed-text($input))"/&gt;

  &lt;variable name="sc"&gt;errata_status_code&lt;/variable&gt;
  &lt;variable name="sd"&gt;submit_date&lt;/variable&gt;

  &lt;template match="/"&gt;
    &lt;text&gt;year, total, rejected, verified, hdu, reported&lt;/text&gt;
    &lt;text&gt;&amp;#10;&lt;/text&gt;
    &lt;variable name="en" select="$json//j:map"/&gt;
    &lt;for-each-group select="$en"
      group-by="substring-before(j:string[@key=$sd],'-')"&gt;
      &lt;sort select="current-grouping-key()"/&gt;
      &lt;variable name="year" select="current-grouping-key()"/&gt;
      &lt;variable name="errata" select=
        "$en[$year=substring-before(j:string[@key=$sd],'-')]"/&gt;
      &lt;value-of select="concat(
        $year,
        ', ',
        count($errata),
        ', ',
        count($errata['Rejected'=j:string[@key=$sc]]),
        ', ',
        count($errata['Verified'=j:string[@key=$sc]]),
        ', ',
        count(
          $errata['Held for Document Update'=j:string[@key=$sc]]),
        ', ',
        count($errata['Reported'=j:string[@key=$sc]]),
        '&amp;#10;')"/&gt;
    &lt;/for-each-group&gt;
  &lt;/template&gt;

&lt;/transform&gt;
</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: text/csv
Accept-Query: "application/jsonpath", "application/xslt+xml"
Date: Wed, 19 Feb 2025, 17:10:01 GMT

year, total, rejected, verified, hdu, reported
2000, 14, 0, 14, 0, 0
2001, 72, 1, 70, 1, 0
2002, 124, 8, 104, 12, 0
2003, 63, 0, 61, 2, 0
2004, 89, 1, 83, 5, 0
2005, 156, 10, 96, 50, 0
2006, 444, 54, 176, 214, 0
2007, 429, 48, 188, 193, 0
2008, 423, 52, 165, 206, 0
2009, 331, 39, 148, 144, 0
2010, 538, 80, 232, 222, 4
2011, 367, 47, 170, 150, 0
2012, 348, 54, 149, 145, 0
2013, 341, 61, 169, 106, 5
2014, 342, 73, 180, 72, 17
2015, 343, 79, 145, 89, 30
2016, 295, 46, 122, 82, 45
2017, 303, 46, 120, 84, 53
2018, 350, 61, 118, 98, 73
2019, 335, 47, 131, 94, 63
2020, 387, 68, 117, 123, 79
2021, 321, 44, 148, 63, 66
2022, 358, 37, 198, 40, 83
2023, 262, 38, 121, 33, 70
2024, 322, 33, 125, 23, 141
9999, 1, 0, 0, 1, 0
</pre>

<p>
応答の `Accept-Query$h ~fieldは、［
別の~query形式として `JSONPath^cite `RFC9535$r も~supportされる
］ことを指示していることに注意。
【その形式を利用する】次の要請は、
2024年以降に提出された正誤表のうち，却下されたもの【種別 "`Rejected^c" 】すべての識別子を報告することになろう：
◎
Note the Accept-Query response field indicating that another query format -- JSONPath ([RFC9535]) -- is supported as well. The request below would report the identifiers of all rejected errata submitted since 2024:
</p>

<pre class="lang-http">
QUERY /errata.json HTTP/1.1
Host: example.org
Content-Type: application/jsonpath
Accept: application/json

$..[
     ?@.errata_status_code=="Rejected"
     &amp;&amp; @.submit_date&gt;"2024"
   ]
   ["doc-id"]
</pre>

<p>
対する応答：
◎
Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Content-Type: application/json
Accept-Query: "application/jsonpath", "application/xslt+xml"
Date: Thu, 20 Feb 2025, 09:55:42 GMT
Last-Modified: Thu, 20 Feb 2025 06:10:01 GMT

[
  "RFC1185","RFC8407","RFC6350","RFC8467","RFC1157","RFC9543",
  "RFC9076","RFC7656","RFC2822","RFC9460","RFC2104","RFC6797",
  "RFC9499","RFC9557","RFC2131","RFC2328","RFC9001","RFC3325",
  "RFC9438","RFC2526","RFC2985","RFC7643","RFC9132","RFC6376",
  "RFC9110","RFC9460","RFC7748","RFC9497","RFC8463","RFC4035",
  "RFC7239","RFC9083","RFC9537","RFC9537","RFC9420","RFC9000",
  "RFC9656","RFC9110","RFC2324","RFC2549","RFC6797","RFC2549",
  "RFC8894"
]
</pre>

		</section>
	</section>
	<section id="change.log">
<h2 title="Appendix B. Change Log">変更~log</h2>

<p>
この節は、
~RFCとして公表する前に除去されることになる。
【以下，この節の内容は、未訳。】
◎
This section is to be removed before publishing as an RFC.
</p>

	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p>
様々な［
案／考査／~feedback
］を寄せられた~HTTP~WGの~memberすべてに。
◎
We thank all members of the HTTP Working Group for ideas, reviews, and feedback.
</p>

<p>
次に挙げる各個人には、
特に感謝する：
◎
The following individuals deserve special recognition:＼
</p>

<div lang="en">
Carsten Bormann, Mark Nottingham, Martin Thomson, Michael Thornburgh, Roberto Polli, Roy Fielding, and Will Hawkins.
</div>

	</section>
	<section id="contributors">
<h2 title="Contributors">貢献者</h2>

<p>
`Ashok Malhotra^en 氏は、
早期から論に参加して，この仕様を導いた。
◎
Ashok Malhotra participated in early discussions leading to this specification:
◎
Ashok Malhotra
Email: malhotrasahib@gmail.com
</p>

	</section>
</main></div>
