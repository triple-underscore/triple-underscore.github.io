<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Retrofit Structured Fields for HTTP（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<style>
/* cookie 属性 */
.cookie-attr {
	font-weight: normal;
	color: var(--text-color-3);
}

caption {
	min-width: 20em;
}
</style>

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">
●●options

spec_title:Retrofit Structured Fields for HTTP
spec_date:2023-05-26
trans_update:2023-05-31
source_checked:220526
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-retrofit.html
abbr_url:HTTPretrofit
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2022-08-12

●●class_map
a:cookie-attr

●●tag_map
a:code

●●original_id_map

●●mdn_urls

●●link_map

h.ALPN:~RFCx/rfc7639#section-2
h.Accept-Patch:~HTTPpatch#accept-patch
h.Accept-Post:~TR/ldp#header-accept-post
h.Access-Control-Allow-Credentials:~FETCH#http-access-control-allow-credentials
h.Access-Control-Allow-Headers:~FETCH#http-access-control-allow-headers
h.Access-Control-Allow-Methods:~FETCH#http-access-control-allow-methods
h.Access-Control-Allow-Origin:~FETCH#http-access-control-allow-origin
h.Access-Control-Expose-Headers:~FETCH#http-access-control-expose-headers
h.Access-Control-Max-Age:~FETCH#http-access-control-max-age
h.Access-Control-Request-Headers:~FETCH#http-access-control-request-headers
h.Access-Control-Request-Method:~FETCH#http-access-control-request-method
h.Alt-Svc:~RFCx/rfc7838#section-3
h.Alt-Used:~RFCx/rfc7838#section-5
h.CDN-Loop:~RFCx/rfc8586#section-2
h.Clear-Site-Data:~TR/clear-site-data/#header
h.Cross-Origin-Resource-Policy:~FETCH#http-cross-origin-resource-policy
h.DNT:~TR/tracking-dnt/#dnt-header-field
h.Expect-CT:~RFCx/rfc9163#section-2
h.Keep-Alive:~HTTPv1#compatibility.with.http.1.0.persistent.connections
h.Origin:~FETCH#http-origin
h.Prefer:~RFCx/rfc7240#section-2
h.Preference-Applied:~RFCx/rfc7240#section-3
h.Sec-WebSocket-Extensions:~RFC6455#section-11.3.2
h.Sec-WebSocket-Protocol:~RFC6455#section-11.3.4
h.Sec-WebSocket-Version:~RFC6455#section-11.3.5
h.Server-Timing:~SERVER-TIMING#dfn-server-timing-header-field
h.Surrogate-Control:~TR/edge-arch/
h.Timing-Allow-Origin:~RESOURCE-TIMING#dfn-timing-allow-origin
h.Upgrade-Insecure-Requests:~UPGRADE-INSECURE-REQUESTS#upgrade-insecure-requests-http-request-header-field
h.X-Content-Type-Options:~FETCH#http-x-content-type-options
h.X-Frame-Options:~HTMLlifecycle#x-frame-options
h.X-XSS-Protection:https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection

a.Expires:~HTTPcookie#attribute-expires
a.Max-Age:~HTTPcookie#attribute-max-age
a.Domain:~HTTPcookie#attribute-domain
a.Path:~HTTPcookie#attribute-path
a.Secure:~HTTPcookie#attribute-secure
a.HttpOnly:~HTTPcookie#attribute-httponly
a.SameSite:~HTTPcookie#attribute-samesite

有構造~field:~STRUCTURED-FIELDS#structured-field
~sf~item:~STRUCTURED-FIELDS#sf-item
~sf~key:~STRUCTURED-FIELDS#sf-key
~sf~list:~STRUCTURED-FIELDS#sf-list
~sf~parameter:~STRUCTURED-FIELDS#sf-parameter
~sf~token:~STRUCTURED-FIELDS#sf-token
~sf整数:~STRUCTURED-FIELDS#sf-integer
~sf文字列:~STRUCTURED-FIELDS#sf-string
~sf真偽値:~STRUCTURED-FIELDS#sf-boolean
~sf日時:~STRUCTURED-FIELDS#sf-date
~sf辞書:~STRUCTURED-FIELDS#sf-dictionary
~sf~parameter群:~STRUCTURED-FIELDS#sf-parameters
~sf裸~item:~STRUCTURED-FIELDS#sf-bare-item
~sf内縁~list:~STRUCTURED-FIELDS#sf-inner-list
~sf~byte列:~STRUCTURED-FIELDS#sf-binary
~sf~decimal:~STRUCTURED-FIELDS#sf-decimal


●●words_table1
RFC6455:RFC6455-ja.html
HTTPtargetedcache:http-targeted-cache-control-ja.html
HTTPcachestatus:http-cache-status-ja.html
HTTPproxystatus:http-proxy-status-ja.html
HTTPch:http-client-hints-ja.html
HTTPcookie:http-cookie-ext-ja.html
UPGRADE-INSECURE-REQUESTS:webappsec-upgrade-insecure-requests-ja.html

sf:<sub>sf-</sub>

●●words_table

	●略語／名称
IPv6:
ALPN:
HTTP3:HTTP/3

	~HTTP~field名~registry^cite:"Hypertext Transfer Protocol (HTTP) Field Name Registry"

	●構文
角括弧:brackets:~
裸:bare::~
decimal:::10 進数
接頭-:prefix::~

	~backslashによる~escape法:backslash-escaping
	~escape法:quoting
	quoted-string$p :quoted strings
	範囲~単位$:range-units
	~UTC 1970年 1月 1日 00:00:00:00:00:00 UTC on 1 January 1970
	parameters$p:parameters
	DIGIT$P:number
	`weak$p を伴うもの:weakness flag
	実体~tag:entity-tag
	すべて小文字に:all-lowercase
	ALPHA$P:~alphabetic character
	から始まる:begin with
	始まっている:beginning
	空白のみ:whitespace-only
	~sf~key$:key
	~F また~parameterの不在:0 or unset
	構文解析された `cookie-date$p:parsed-cookie-date

	●保安
変動:variance:~

	●仕様
収束:convergence:~
但書き:caveat:~
表記上の:notational:~
場当的:ad hoc:場当たり的
流儀:fashion:~
決定論的:deterministic:~
類似性:similarity:~
黙って:silentに:~
収容-:accommodate:~
現実化-:realise:実現
増強-:enhance:~
呈さな:exhibitしな:~
強調-:highlight:~

	互換でなく:incompatible
	より長期的:longer term
	長期的:long-term
	珍しくない:not uncommon
	ないはずだが:shouldn't~be
	大勢を占めている:vast majority
	可能でない:unable
	可能でない:not be able
	かなりの:considerable
	結果的に:net
	したがって、〜できない:This prevents
	のうち選定されたもの:a selection of
	大部分の:bulk of
	仕立て上げる:making
	成している:making up
	挙げられよう:might be advisable
	注記:note
	選ばれ:chosen
	誤って:mistakenly
	同じ行に挙げられた:paired with...
	異なるように:differently
	見込みが高い:likely
	一部を〜として選定する:nominates a selection of
	-:nominated registrations
	列:column
	持ち込む:bring
	広く:widely-
	そうでないもの 〜 そのような:some will not 〜 unsuccessful
	大多数:majority

	●未分類
retrofit:
消費器:consumer::~
優先順位:precedence:~

	除外する:minus
	~field値:payload
	有構造~field$:Structured Field
	有構造~field$用の値:Structured Field Value
	有構造~field$用の値:Structured Field value
	有構造~型:Structured Type
	~retrofit有構造~field:Retrofit Structured Fields
	~MIME:media
	~Internet:internet
	~cookie~属性~registry^cite:Cookie Attribute Registry
	相手の端点:peer
	互いの端点:both peers
	`下流$にある次の:next-hop
	少数の:small
	先立つ:prior
	より大きい:larger
	`STRUCTURED-FIELDS$r :RFC8941
	へ向けた:toward
	より広い:wider
	広く:widely
	最後に:finally

●●ref_data
RFC6265BIS=副     ~/http-cookie-ext-ja.html

●●ref_key_map
COOKIES:RFC6265BIS

●●ref_normative

[COOKIES]
    Bingler, S., West, M., and J. Wilander, ＜Cookies: HTTP State Management Mechanism＞, Work in Progress, Internet-Draft, draft-ietf-httpbis-rfc6265bis, URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis
[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[STRUCTURED-FIELDS]
    Nottingham, M. and P. Kamp, ＜Structured Field Values for HTTP＞, Work in Progress, Internet-Draft
    URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-sfbis

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公表された，
<a href="~SPEC_URL">Retrofit Structured Fields for HTTP</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Workgroup
	<a href="https://httpwg.org/">HTTP</a>
位置付け
	Internet-Draft
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	<a href="https://www.mnot.net/">Mark Nottingham</a>, Prahran, Australia, <a href="mailto:mnot@mnot.net">mnot@mnot.net</a>
課題追跡
	https://github.com/httpwg/http-extensions/labels/retrofit
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-retrofit/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-retrofit.md

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
現在の Internet-Draft のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP 用の retrofit 有構造フィールド</h1>
<p>Retrofit Structured Fields for HTTP</p>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="section-abstract">
◎要約

<p>
この仕様は、
既存の~HTTP~fieldのうち，その構文が`有構造~field$と：
◎
↓</p>
<ul>
	<li>
互換であるものを選定する
— それらを`有構造~field$のように取扱えるよう
（それらは、ある種の但書きの~subjectにもなる）。
◎
This specification nominates a selection of existing HTTP fields whose values are compatible with Structured Fields syntax, so that they can be handled as such (subject to certain caveats).
</li>
	<li>
互換でないもののうち一部を追加的に収容するため，
それらの意味論から`有構造~field$への対応付けも定義する
— それらを~HTTP`~message$内に伝達する方法は指定しないが。
◎
To accommodate some additional fields whose syntax is not compatible, it also defines mappings of their semantics into Structured Fields. It does not specify how to convey them in HTTP messages.
</li>
</ul>

<p class="trans-note">【
~retrofitの意味：
“~~昔からあるものを現代のものとして（ `retro^en ）収まるようにする（ `fit^en ）” 
】</p>

	</section>
	<section>
<h2 title="About This Document">この文書について</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#about-this-draft$に移譲。
】</p>

<!-- 
https://datatracker.ietf.org/doc/draft-ietf-httpbis-retrofit/

Source for this draft and an issue tracker can be found at https://github.com/httpwg/http-extensions/labels/retrofit.
-->

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2023 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
`~HTTP用の有構造~field値^cite `STRUCTURED-FIELDS$r は、
新たな~HTTP~field用の値に利用するため，
構文解析~algoと直列化~algoが結付けられた~data~modelを導入した。
`有構造~field$として定義された~fieldが持ち込む利点には、
次が含まれる：
◎
Structured Field Values for HTTP [STRUCTURED-FIELDS] introduced a data model with associated parsing and serialization algorithms for use by new HTTP field values. Fields that are defined as Structured Fields can bring advantages that include:
</p>
<ul>
	<li>
相互運用能と~securityが改善される
⇒
精確に定義された［
構文解析~algo, 直列化~algo
］は、
~ABNFや注釈文だけを伴って定義された~field用には，概して可用でない。
◎
Improved interoperability and security: precisely defined parsing and serialisation algorithms are typically not available for fields defined with just ABNF and/or prose.
</li>
	<li>
共通な実装の再利用
⇒
他の~field用の多くの構文解析器は、［
単独の~fieldか, 少数の~fieldからなる族
］に特有である。
◎
Reuse of common implementations: many parsers for other fields are specific to a single field or a small family of fields.
</li>
	<li>
正準的な形
⇒
各~型~用に決定論的な直列化~algoが定義されたので、
`有構造~field$には，正準的な表現がある。
◎
Canonical form: because a deterministic serialisation algorithm is defined for each type, Structure Fields have a canonical representation.
</li>
	<li>
~API~supportが増強される
⇒
定例の~data~modelにより，
`~field値$を実装において~nativeな~data構造として公開することが，より容易になる。
◎
Enhanced API support: a regular data model makes it easier to expose field values as a native data structure in implementations.
</li>
	<li>
代替な直列化
⇒
`STRUCTURED-FIELDS$r は，
その~data~modelの~textな直列化を定義するが、
他の，より効率的な下層の~data~modelの直列化もアリになる。
◎
Alternative serialisations: While [STRUCTURED-FIELDS] defines a textual serialisation of that data model, other, more efficient serialisations of the underlying data model are also possible.
</li>
</ul>

<p>
しかしながら，これらの便益が現実化されるためには、
`~field$は，`有構造~field$として定義される必要がある。
既存の`~field$の多くは、
そうでなく，~Internet上の~HTTP流通において見られる大部分の［
`~header$／`~trailer$
］を成している。
◎
However, a field needs to be defined as a Structured Field for these benefits to be realised. Many existing fields are not, making up the bulk of header and trailer fields seen in HTTP traffic on the internet.
</p>

<p>
この仕様は、
これらの便益を現実化できるよう，［
既存の~HTTP~fieldのうち選定されたものを`有構造~field$として どう取扱えるか
］を定義して、
それらを~retrofit有構造~fieldに仕立て上げる。
◎
This specification defines how a selection of existing HTTP fields can be handled as Structured Fields, so that these benefits can be realised -- thereby making them Retrofit Structured Fields.
</p>

<p>
これは、
次の 2 つの技法を利用して行われる：
◎
It does so using two techniques.＼
</p>
<ul>
	<li>
`互換な~field＠#compatible§は、
当の~fieldに定義された構文と`有構造~field$における構文との類似性に因り，
`有構造~field$であったかのように取扱える~fieldを挙げる。
◎
Section 2 lists compatible fields -- those that can be handled as if they were Structured Fields due to the similarity of their defined syntax to that in Structured Fields.＼
</li>
	<li>
`対応付けられる~field＠#mapped§は、
当の~fieldの構文を下層の~data~modelの中へ形式変換してから，
`有構造~field$により定義される~data~modelの中へ対応付ける必要がある~fieldを挙げる。
◎
Section 3 lists mapped fields -- those whose syntax needs to be transformed into an underlying data model which is then mapped into that defined by Structured Fields.
</li>
</ul>

		<section id="using-retrofit-structured-fields">
<h3 title="Using Retrofit Structured Fields">1.1. ~retrofit有構造~fieldの利用-法</h3>

<p>
広く配備された既存の~HTTP~fieldに~data構造を~retrofitすることには、
相互運用能と~securityを確約するよう，注意深い取扱いが要求される。
この節では、
~retrofit有構造~fieldを利用する応用~用に考慮点を強調する。
◎
Retrofitting data structures onto existing and widely-deployed HTTP fields requires careful handling to assure interoperability and security. This section highlights considerations for applications that use Retrofit Structured Fields.
</p>

<p>
~HTTP流通~内で見られる~field値のうち大多数は，成功裡に［
構文解析される／対応付けられる
］ことが可能になるはずだが、
そうでないものもある。
~retrofit有構造~fieldを利用している応用は，
そのような値をどう取扱うことになるかを定義する必要がある。
◎
While the majority of field values seen in HTTP traffic should be able to be parsed or mapped successfully, some will not. An application using Retrofit Structured Fields will need to define how unsuccessful values will be handled.
</p>

<p>
例えば，`有構造~field$用の~data型を利用して~field値を公開する~APIは、
当の~fieldが成功裡に［
構文解析され／対応付けられ
］なかった事例では，その値を文字列として可用にするかもしれない。
◎
For example, an API that exposes field values using Structured Fields data types might make the field value available as a string in cases where the field did not successfully parse or map.
</p>

<p>
`対応付けられる~field＠#mapped§に述べられる~field値は、
各自の~fieldの元の構文とは互換でない
— なので、［
それらを処理している各~主体が，その形を成す~field値~用に~supportを明示的に指示した場合
］を除き，利用し得ない。
~retrofit有構造~fieldを利用している応用は、
互いの~supportを折衝する方法を定義する必要がある。
◎
The mapped field values described in Section 3 are not compatible with the original syntax of their fields, and so cannot be used unless parties processing them have explicitly indicated their support for that form of the field value. An application using Retrofit Structured Fields will need to define how to negotiate support for them.
</p>

<p>
例えば，`有構造~field$の利点をとるために各~fieldに代替な直列化を利用する場合、
その前に，［
互いの端点が直列化を適切に取扱うことを確約するための折衝を仕組み
］を明示的に確立する必要がある。
◎
For example, an alternative serialization of fields that takes advantage of Structured Fields would need to establish an explicit negotiation mechanism to assure that both peers would handle that serialization appropriately before using it.
</p>

<p>
`~securityの考慮点＠#security§も見よ。
◎
See also the security considerations in Section 5.
</p>
		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.2. 表記上の規約</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

		</section>
	</section>
	<section id="compatible">
<h2 title="Compatible Fields">2. 互換な~field</h2>

<p>
~HTTP~fieldのうち，`表t 1＠#compatible-fields$ に挙げるものは、
`STRUCTURED-FIELDS$r に挙げられた~top-level型に対応している［
構文解析, 直列化
］~algoに則って，`有構造~field$用の値として取扱える値をとる
— `但書き＠#compatible-caveats§の~subjectになる下で。
◎
The HTTP fields listed in Table 1 have values that can be handled as Structured Field Values according to the parsing and serialisation algorithms in [STRUCTURED-FIELDS] corresponding to the listed top-level type, subject to the caveats in Section 2.1.
</p>

<p>
この表tの 2 列目に挙げる~top-level型は、［
当の~fieldに定義される構文
］および［
~Internetにおける実際の流通
］との互換性を得るように選ばれた。
しかしながら、
これらの~fieldの~instanceすべてが`有構造~field$用の値として成功裡に構文解析されるとは限らない。
これは、［
当の`~field値$が明瞭に妥当でないこと／
妥当であるが，`有構造~field$として構文解析-可能でないこと
］どちらによることもある。
◎
The top-level types are chosen for compatibility with the defined syntax of the field as well as with actual internet traffic. However, not all instances of these fields will successfully parse as a Structured Field Value. This might be because the field value is clearly invalid, or it might be because it is valid but not parseable as a Structured Field.
</p>

<p>
この仕様を利用している応用は、
その要件に依存して，そのような`~field値$を取扱う方法を考慮する必要がある。
そのような値［
を却下する／
を不透明な文字列として扱う／
から場当的な流儀で`有構造~field$用の値を回復しようと試みる
］などが挙げられよう。
◎
An application using this specification will need to consider how to handle such field values. Depending on its requirements, it might be advisable to reject such values, treat them as opaque strings, or attempt to recover a Structured Field Value from them in an ad hoc fashion.
</p>

<div>
<table><caption id="compatible-fields">表t 1：
互換な~field
</caption>
<thead><tr>
<th>~field名
<th>有構造~型
<tbody>

<tr><td>`Accept$h
<td>`~sf~list$

<tr><td>`Accept-Encoding$h
<td>`~sf~list$

<tr><td>`Accept-Language$h
<td>`~sf~list$

<tr><td>`Accept-Patch$h
<td>`~sf~list$

<tr><td>`Accept-Post$h
<td>`~sf~list$

<tr><td>`Accept-Ranges$h
<td>`~sf~list$

<tr><td>`Access-Control-Allow-Credentials$h
<td>`~sf~item$

<tr><td>`Access-Control-Allow-Headers$h
<td>`~sf~list$

<tr><td>`Access-Control-Allow-Methods$h
<td>`~sf~list$

<tr><td>`Access-Control-Allow-Origin$h
<td>`~sf~item$

<tr><td>`Access-Control-Expose-Headers$h
<td>`~sf~list$

<tr><td>`Access-Control-Max-Age$h
<td>`~sf~item$

<tr><td>`Access-Control-Request-Headers$h
<td>`~sf~list$

<tr><td>`Access-Control-Request-Method$h
<td>`~sf~item$

<tr><td>`Age$h
<td>`~sf~item$

<tr><td>`Allow$h
<td>`~sf~list$

<tr><td>`ALPN$h
<td>`~sf~list$

<tr><td>`Alt-Svc$h
<td>`~sf辞書$

<tr><td>`Alt-Used$h
<td>`~sf~item$

<tr><td>`Cache-Control$h
<td>`~sf辞書$

<tr><td>`CDN-Loop$h
<td>`~sf~list$

<tr><td>`Clear-Site-Data$h
<td>`~sf~list$

<tr><td>`Connection$h
<td>`~sf~list$

<tr><td>`Content-Encoding$h
<td>`~sf~list$

<tr><td>`Content-Language$h
<td>`~sf~list$

<tr><td>`Content-Length$h
<td>`~sf~list$

<tr><td>`Content-Type$h
<td>`~sf~item$

<tr><td>`Cross-Origin-Resource-Policy$h
<td>`~sf~item$

<tr><td>`DNT$h
<td>`~sf~item$

<tr><td>`Expect$h
<td>`~sf辞書$

<tr><td>`Expect-CT$h
<td>`~sf辞書$

<tr><td>`Host$h
<td>`~sf~item$

<tr><td>`Keep-Alive$h
<td>`~sf辞書$

<tr><td>`Max-Forwards$h
<td>`~sf~item$

<tr><td>`Origin$h
<td>`~sf~item$

<tr><td>`Pragma$h
<td>`~sf辞書$

<tr><td>`Prefer$h
<td>`~sf辞書$

<tr><td>`Preference-Applied$h
<td>`~sf辞書$

<tr><td>`Retry-After$h
<td>`~sf~item$

<tr><td>`Sec-WebSocket-Extensions$h
<td>`~sf~list$

<tr><td>`Sec-WebSocket-Protocol$h
<td>`~sf~list$

<tr><td>`Sec-WebSocket-Version$h
<td>`~sf~item$

<tr><td>`Server-Timing$h
<td>`~sf~list$

<tr><td>`Surrogate-Control$h
<td>`~sf辞書$

<tr><td>`TE$h
<td>`~sf~list$

<tr><td>`Timing-Allow-Origin$h
<td>`~sf~list$

<tr><td>`Trailer$h
<td>`~sf~list$

<tr><td>`Transfer-Encoding$h
<td>`~sf~list$

<tr><td>`Upgrade-Insecure-Requests$h
<td>`~sf~item$

<tr><td>`Vary$h
<td>`~sf~list$

<tr><td>`X-Content-Type-Options$h
<td>`~sf~item$

<tr><td>`X-Frame-Options$h
<td>`~sf~item$

<tr><td>`X-XSS-Protection$h
<td>`~sf~list$
</table>

◎
Table 1: Compatible Fields
◎
Field Name｜Structured Type
Accept｜List
Accept-Encoding｜List
Accept-Language｜List
Accept-Patch｜List
Accept-Post｜List
Accept-Ranges｜List
Access-Control-Allow-Credentials｜Item
Access-Control-Allow-Headers｜List
Access-Control-Allow-Methods｜List
Access-Control-Allow-Origin｜Item
Access-Control-Expose-Headers｜List
Access-Control-Max-Age｜Item
Access-Control-Request-Headers｜List
Access-Control-Request-Method｜Item
Age｜Item
Allow｜List
ALPN｜List
Alt-Svc｜Dictionary
Alt-Used｜Item
Cache-Control｜Dictionary
CDN-Loop｜List
Clear-Site-Data｜List
Connection｜List
Content-Encoding｜List
Content-Language｜List
Content-Length｜List
Content-Type｜Item
Cross-Origin-Resource-Policy｜Item
DNT｜Item
Expect｜Dictionary
Expect-CT｜Dictionary
Host｜Item
Keep-Alive｜Dictionary
Max-Forwards｜Item
Origin｜Item
Pragma｜Dictionary
Prefer｜Dictionary
Preference-Applied｜Dictionary
Retry-After｜Item
Sec-WebSocket-Extensions｜List
Sec-WebSocket-Protocol｜List
Sec-WebSocket-Version｜Item
Server-Timing｜List
Surrogate-Control｜Dictionary
TE｜List
Timing-Allow-Origin｜List
Trailer｜List
Transfer-Encoding｜List
Upgrade-Insecure-Requests｜Item
Vary｜List
X-Content-Type-Options｜Item
X-Frame-Options｜Item
X-XSS-Protection｜List
</div>

		<section id="compatible-caveats">
<h3 title="Caveats">2.1. 但書き</h3>

<p>
互換性に関しては、
次に挙げる但書きにも注意：
◎
Note the following caveats regarding compatibility:
</p>
<dl>
	<dt>
構文解析の相違点：
◎
Parsing differences:
</dt>
	<dd>
<p>
一部の値は、
元々指定された構文に則って妥当であっても，
`有構造~field$として構文解析することに失敗し得る。
例えば：
◎
Some values may fail to parse as Structured Fields, even though they are valid according to their originally specified syntax. For example,＼
</p>
		<ul>
			<li>
~HTTPの~parameter名（ `parameter-name$p `HTTP$r ）は，文字大小無視であり、
`~sf辞書$に基づく多くの~field
（例：
`Cache-Control$h,
`Expect-CT$h,
`Pragma$h,
`Prefer$h,
`Preference-Applied$h,
`Surrogate-Control$h ）
でも，~keyは文字大小無視であるが、
`有構造~field$においては，すべて小文字にすることが要求される。
【`~sf~key$を見よ。】
◎
HTTP parameter names are case-insensitive (per Section 5.6.6 of [HTTP]), but Structured Fields require them to be all-lowercase.＼
Likewise, many Dictionary-based fields (e.g., Cache-Control, Expect-CT, Pragma, Prefer, Preference-Applied, Surrogate-Control) have case-insensitive keys.＼
</li>
			<li>
~HTTPの `parameters$p 規則（ `HTTP$r ）は，区切子 "`;^c" の前に空白を許容するが、
`有構造~field$においては，そうでない。
【`~sf~parameter群$を見よ。】
◎
Similarly, the parameters rule in HTTP (see Section 5.6.6 of [HTTP]) allows whitespace before the ";" delimiter, but Structured Fields does not.＼
</li>
			<li>
~HTTPの `quoted-string$p （ `HTTP$r ）は，
ほとんどの文字に対し~backslashによる~escape法を許容するが、
`有構造~field$における文字列において~escapeできる文字は，［
"`\^c", `DQUOTE$P
］に限られる。
【`~sf文字列$を見よ。】
◎
And, Section 5.6.4 of [HTTP] allows backslash-escaping most characters in quoted strings, whereas Structured Field Strings only escape "\" and DQUOTE.＼
</li>
		</ul>
<p>
典型的な流通にて見られる~fieldは、
これらの挙動【の相違】を呈さないものが大勢を占めている。
◎
The vast majority of fields seen in typical traffic do not exhibit these behaviors.
</p>
</dd>

	<dt>
~errorの取扱い
◎
Error handling:
</dt>
	<dd>
現在の~HTTP~header用に指定された（または，単に広く実装された）構文解析~algoは、
~errorの取扱いなど，詳細において`有構造~field$用のものと相違し得る。
例えば、
~HTTPが［
`Cache-Control$h ~headerにて繰返された`~cache指令$
］に対し指定する優先順位は，［
この~headerに対応付けられる，`~sf辞書$を値にとる有構造~field
］によりアテガわれるものとは異なる。
◎
Parsing algorithms specified (or just widely implemented) for current HTTP headers may differ from those in Structured Fields in details such as error handling. For example, HTTP specifies that repeated directives in the Cache-Control header field have a different precedence than that assigned by a Dictionary structured field (which Cache-Control is mapped to).
</dd>

	<dt>
`~sf~token$の制限
◎
Token limitations:
</dt>
	<dd>
`有構造~field$における~token（`~sf~token$）は，［
`ALPHA$P ／ "`*^c"
］から始まることが要求される一方で、
~HTTPにおける~token（ `token$p ）は，より広い範囲の文字を許容する。
したがって、
対応付けられた値においては，前者以外の文字から始まる~tokenは利用できない。
例えば，［
`~MIME型$, `~field名$, `~method$, `範囲~単位$, 文字, `転送~符号法$
］のうち［
`DIGIT$P ／ "`*^c" 以外の特殊~文字
］から始まるものは、
~HTTP~protocol要素としては妥当になり得るが，
`~sf~token$としては表現-可能でない。
◎
In Structured Fields, tokens are required to begin with an alphabetic character or "*", whereas HTTP tokens allow a wider range of characters. This prevents use of mapped values that begin with one of these characters. For example, media types, field names, methods, range-units, character and transfer codings that begin with a number or special character other than "*" might be valid HTTP protocol elements, but will not be able to be represented as Structured Field Tokens.
</dd>

	<dt>
`~sf整数$の制限
◎
Integer limitations:
</dt>
	<dd>
`有構造~field$における整数（`~sf整数$）は、
15 桁までである
— より大きい値は表現-可能でない。
◎
Structured Fields Integers can have at most 15 digits; larger values will not be able to be represented in them.
</dd>

	<dt>
~IPv6~literal
◎
IPv6 Literals:
</dt>
	<dd>
~IPv6~literal~addressを値に包含する~field
（ `CDN-Loop$h, `Host$h, `Origin$h など ）
は、
`~sf~token$として表現-可能でない
— それらを区切るために利用される角括弧は、
`~sf~token$においては許容されないので。
◎
Fields whose values contain IPv6 literal addresses (such as CDN-Loop, Host, and Origin) are not able to be represented as Structured Fields Tokens, because the brackets used to delimit them are not allowed in Tokens.
</dd>

	<dt>
空な`~field値$
◎
Empty Field Values:
</dt>
	<dd>
［
空な／空白のみからなる
］`~field値$は、
`有構造~field$においては~errorと見なされる。
互換な~fieldにおいては、
これら空な~fieldは，当の~fieldを黙って無視するべきであることを指示する。
◎
Empty and whitespace-only field values are considered errors in Structured Fields. For compatible fields, an empty field indicates that the field should be silently ignored.
</dd>

	<dt>
`Alt-Svc$h
◎
Alt-Svc:
</dt>
	<dd>
一部の~ALPN~token（例： `h3-Q43^c ）は、
`~sf~key$の構文に適合しないので，`~sf~token$として表現し得ない。
~HTTP3の最終-~version【 ~RFC 9114 】は `h3^c ~tokenを利用するので、
これは，長期的な課題にはならないはずだが、
将来の~tokenは，この前提に再び違反し得る。
◎
Some ALPN tokens (e.g., h3-Q43) do not conform to key's syntax, and therefore cannot be represented as a Token. Since the final version of HTTP/3 uses the h3 token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.
</dd>

	<dt>
`Content-Length$h
◎
Content-Length:
</dt>
	<dd>
`Content-Length$h は、
`~sf~list$として定義されることに注意
— 実装が複数個の値を誤って送信することは珍しくないので。
その取扱い要件は、
`HTTP$r `Content-Length§h を見よ。
◎
Note that Content-Length is defined as a List because it is not uncommon for implementations to mistakenly send multiple values. See Section 8.6 of [HTTP] for handling requirements.
</dd>

	<dt>
`Retry-After$h
◎
Retry-After:
</dt>
	<dd>
表現できる値は、
`delta-seconds$p に限られる
— `HTTP-date$p【！http-date】 を包含している値は、
`有構造~field$用の値として伝達するためには， `delta-seconds$p に変換する必要がある。
◎
Only the delta-seconds form of Retry-After can be represented; a Retry-After value containing a http-date will need to be converted into delta-seconds to be conveyed as a Structured Field Value.
</dd>
</dl>

		</section>
	</section>
	<section id="mapped">
<h2 title="Mapped Fields">3. 対応付けられる~field</h2>

<p>
一部の`~field$用の値の構文は、
`有構造~field$用の値として成功裡に構文解析できない。
代わりに，`有構造~field$用の値に対応付けることが必要yである。
◎
Some HTTP field values have syntax that cannot be successfully parsed as Structured Field values. Instead, it is necessary to map them into a Structured Field value.
</p>

<div class="example">
<p>
例えば、
`Date$h `~header$は，日時を運ぶ：
◎
For example, the Date HTTP header field carries a date:
</p>

<pre class="lang-http">
Date: Sun, 06 Nov 1994 08:49:37 GMT
</pre>

<p>
その値は、
次のように対応付けられよう：
◎
Its value would be mapped to:
</p>

<pre class="lang-http">
@784111777
</pre>
</div>

<p>
`互換な~field＠#compatible§ に挙げたものと違って，
これらの表現は、
当の~fieldの元の構文とは互換でない
— それらは、
明示的にかつ一義的に~supportされない限り，利用してはナラナイ。
このことは、
例えば［
~HTTPにおいて，それらを`下流$にある次の`受信者$へ送信する
］ためには，先立つ折衝が要求されることを意味する。
この仕様は、
それを行う方法は定義しない。
◎
Unlike those listed in Section 2, these representations are not compatible with the original fields' syntax, and MUST NOT be used unless they are explicitly and unambiguously supported. For example, this means that sending them to a next-hop recipient in HTTP requires prior negotiation. This specification does not define how to do so.
</p>

		<section id="urls">
<h3 title="URLs">3.1. ~URL</h3>

<p>
`表t 2＠#url-fields$ に挙げる`~field名$は、
その値を`~sf文字列$として扱うことにより，
`有構造~field$用の値に対応付けれる。
◎
The field names in Table 2 have values that can be mapped into Structured Field values by treating the original field's value as a String.

</p>

<div>
<table><caption id="url-fields">表t 2：
~URLを値にとる~field
</caption>
<thead>
<tr><th>~field名
<tbody>

<tr><td>`Content-Location$h
<tr><td>`Location$h
<tr><td>`Referer$h
</table>

◎
Table 2: URL Fields
◎
Field Name
Content-Location
Location
Referer
</div>

<div class="example">
<p>
例えば、
次の `Location$h ~field：
◎
For example, this Location field
</p>

<pre class="lang-http">
Location: https://example.com/foo
</pre>

<p>
の値を対応付けた結果は：
◎
would have a mapped value of:
</p>

<pre class="lang-http">
"https://example.com/foo"
</pre>
</div>

		</section>
		<section id="dates">
<h3 title="Dates">3.2. 日時</h3>

<p>
`表t 3＠#date-fields$ に挙げる`~field名$
【言い換えれば、 `HTTP-date$p を値にとる`単数~field$】
は、
その値を［
`HTTP$r `日時の形式＠~HTTPinfra#http.date§に則って構文解析した結果
］を`~sf日時$として表現することにより，`有構造~field$用の値に対応付けれる。
◎
The field names in Table 3 have values that can be mapped into Structured Field values by parsing their payload according to Section 5.6.7 of [HTTP] and representing the result as a Date.
</p>

<div>
<table><caption id="date-fields">表t 3：
日時~field
</caption>
<thead>
<tr><th>~field名
<tbody>

<tr><td>`Date$h
<tr><td>`Expires$h
<tr><td>`If-Modified-Since$h
<tr><td>`If-Unmodified-Since$h
<tr><td>`Last-Modified$h
</table>

◎
Table 3: Date Fields
◎
Field Name
Date
Expires
If-Modified-Since
If-Unmodified-Since
Last-Modified
</div>

<div class="example">
<p>
例えば `Expires$h ~fieldの値は、
次に対応付けることもできる：
◎
For example, an Expires field's value could be mapped as:
</p>

<pre class="lang-http">
@1659578233
</pre>
</div>

		</section>
		<section id="etags">
<h3 title="ETags">3.3. `ETag^h</h3>

<p>
`ETag$h ~headerの値（ `entity-tag$p ）は、
次を伴う`~sf~item$で表現することにより，
`有構造~field$用の値に対応付けれる：
◎
The field value of the ETag header field can be mapped into a Structured Field value by representing＼
</p>
<ul>
	<li>
~field値を成す `opaque-tag$p を`~sf文字列$として表現する
（当の~itemの値を成す）。
◎
the entity-tag as a String,＼
</li>
	<li>
~field値を成す `weak$p の有無を`~sf真偽値$をとる "`w^c" ~parameterとして表現する
（当の~itemの`~sf~parameter群$を成す）。
ここで、［
~T は弱い`実体~tag$であること／
~F また~parameterの不在は，強い`実体~tag$であること
］を指示する。
◎
and the weakness flag as a Boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.
</li>
</ul>

<div class="example">
<p>
例えば、
次の `ETag$h ~header：
◎
For example, this ETag header field:
</p>

<pre class="lang-http">
ETag: W/"abcdef"
</pre>

<p>
の値を対応付けた結果は：
◎
would have a mapped value of:
</p>

<pre class="lang-http">
"abcdef"; w
</pre>
</div>

<div class="p">
<p>
`If-None-Match$h の`~field値$は、
次により`有構造~field$用の値に対応付けれる：
</p>
<ul>
	<li>
~field値が "`*^c" のときは、
`~sf~token$として表現する。
</li>
	<li>
他の場合、
~field値を成す各 `entity-tag$p を上で述べたとおりの構造で表現して，
それらの`~sf~item$からなる`~sf~list$として表現する。
</li>
</ul>
◎
If-None-Match's field value can be mapped into a Structured Field value which is a List of the structure described above. When a field value contains "*", it is represented as a Token.
</div>

<p>
同様に，
`If-Match$h の`~field値$は、
同じ方式で`有構造~field$用の値に対応付けれる。
◎
Likewise, If-Match's field value can be mapped into a Structured Field value in the same manner.
</p>

<div class="example">
<p>
例えば、
次の `If-None-Match^h ~field：
◎
For example, this If-None-Match field:
</p>

<pre class="lang-http">
If-None-Match: W/"abcdef", "ghijkl", *
</pre>

<p>
の値を対応付けた結果は：
◎
would have a mapped value of:
</p>

<pre class="lang-http">
"abcdef"; w, "ghijkl", *
</pre>
</div>

		</section>
		<section id="cookies">
<h3 title="Cookies">3.4. ~cookie</h3>

<p>
［
`Cookie$h ／ `Set-Cookie$h
］ `COOKIES$r ~fieldは、
それを成す~cookieたちが成す`~sf~list$で表現することにより，`有構造~field$用の値に対応付けれる。
◎
The field values of the Cookie and Set-Cookie fields [COOKIES] can be mapped into Structured Fields Lists.
</p>

<p>
各~cookieは， 2 個の`~sf~item$
— ~cookie名と~cookie値 —
を包含している`~sf内縁~list$として表現される。
~cookie名は、
常に`~sf文字列$になる。
~cookie値は、［
`~sf文字列$以外の`~sf裸~item$の~textな表現として成功裡に構文解析できるならば，それ
（`~sf~byte列$／`~sf~decimal$／`~sf整数$／`~sf~token$／`~sf真偽値$）／
~ELSE_ `~sf文字列$
］になる。
◎
In each case, a cookie is represented as an Inner List containing two Items; the cookie name and value. The cookie name is always a String; the cookie value is a String, unless it can be successfully parsed as the textual representation of another, bare Item structured type (e.g., Byte Sequence, Decimal, Integer, Token, or Boolean).
</p>

<p>
~cookie属性たちは、
各~parameterの名前を小文字に強制した上で，
当の`~sf内縁~list$の`~sf~parameter群$に対応付けられる。
~cookie属性の値は、
当の属性~用に特有な型が定義される場合を除き，`~sf文字列$になる。
この仕様は、
`表t 4＠#cookie-params$ にて，
既存の~cookie属性~用の型を定義する。
◎
Cookie attributes map to Parameters on the Inner List, with the parameter name being forced to lowercase. Cookie attribute values are Strings unless a specific type is defined for them. This specification defines types for existing cookie attributes in Table 4.
</p>

<div>
<table><caption id="cookie-params">表t 4：
`Set-Cookie$h ~parameter型
</caption>
<thead>
<tr><th>~parameter名
<th>有構造~型
<tbody>

<tr><td>`Domain$a
<td>`~sf文字列$

<tr><td>`HttpOnly$a
<td>`~sf真偽値$

<tr><td>`Expires$a
<td>`~sf日時$

<tr><td>`Max-Age$a
<td>`~sf整数$

<tr><td>`Path$a
<td>`~sf文字列$

<tr><td>`Secure$a
<td>`~sf真偽値$

<tr><td>`SameSite$a
<td>`~sf~token$
</table>

◎
Table 4: Set-Cookie Parameter Types
◎
Parameter Name｜Structured Type
Domain｜String
HttpOnly｜Boolean
Expires｜Date
Max-Age｜Integer
Path｜String
Secure｜Boolean
SameSite｜Token
</div>


<p>
`Expires$a 属性は、
構文解析された `cookie-date＠~HTTPcookie#p.cookie-date$p 
（ `COOKIES$r `日付＠~HTTPcookie#cookie-date§ を見よ）
を成す`~sf日時$による表現に対応付けられる。
◎
The Expires attribute is mapped to a Date representation of parsed-cookie-date (see Section 5.1.1 of [COOKIES]).
</p>

<div class="example">
<p>
例えば、
次の `Set-Cookie^h ~field：
◎
For example, this Set-Cookie field:
</p>

<pre class="lang-http">
Set-Cookie: Lang=en-US; Expires=Wed, 09 Jun 2021 10:18:14 GMT; samesite=Strict; secure
</pre>

<p>
の値を対応付けた結果は：
◎
would have a mapped value of:
</p>

<pre class="lang-http">
("Lang" "en-US"); expires=@1623233894; samesite=Strict; secure
</pre>

<p>
次の `Cookie^h ~field：
◎
And this Cookie field:
</p>

<pre class="lang-http">
Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
の値を対応付けた結果は：
◎
would have a mapped value of:
</p>

<pre class="lang-http">
("SID" "31d4d96e407aad42"), ("lang" "en-US")
</pre>
</div>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">4. ~IANA考慮点</h2>

<p>
【この文書は、以下に挙げる行為を~IANAに依頼する。】
</p>

<p>
`~HTTP~field名~registry＠~IANA-a/http-fields/$cite
に対し：
◎
↓</p>
<ul>
	<li>
<p>
次の注記を追加する：
◎
Please add the following note to the "Hypertext Transfer Protocol (HTTP) Field Name Registry":
</p>
		<ul>
			<li>
“有構造~型” 列における接頭辞 "`*^c" は、
それが~retrofit型である
（すなわち、~nativeに有構造ではない）ことを指示する
— ~RFC nnnn 【~RFCとして公表されたときの，この仕様】を見よ。
◎
A prefix of "*" in the Structured Type column indicates that it is a retrofit type (i.e., not natively Structured); see RFC nnnn.
</li>
		</ul>
	</li>
	<li>
新たな列 “有構造~型（ `Structured Type^en ）” を追加する
— `表t 1＠#compatible-fields$（ § 2 ）に挙げた各~field名に対し，
それにアテガわれた有構造~型【！値】を
— それが~retrofit型であることを指示する "`*^c" を接頭した上で —
対応する~registry~entryに伴わせる。
◎
Then, add a new column, "Structured Type", with the values from Section 2 assigned to the nominated registrations, prefixing each with "*" to indicate that it is a retrofit type.
</li>
</ul>

<p>
`表t 4＠#cookie-params$ の情報を利用して，
`COOKIES$r により確立された `~cookie属性~registry＠~HTTPcookie#cookie-attribute-registry$cite に新たな列 “有構造~型” を追加する。
◎
Finally, add a new column to the "Cookie Attribute Registry" established by [COOKIES] with the title "Structured Type", using information from Table 4.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">5. ~securityの考慮点</h2>

<p>
`2＠#compatible§は、
既存の~HTTP~fieldのうち［
`STRUCTURED-FIELDS$r にて定義される~algoで構文解析でき, 直列化できるもの
］を識別する。
既存の構文解析器の挙動からの変動は、
悪用-可能かもしれない
— 特に、
`連鎖$内のある実装（例：`媒介者$）を~targetにすることを攻撃者に許容する場合に。
しかしながら、
すでに配備された構文解析器にも かなりの変動がある
— より長期的には、
単独の構文解析~algoへ向けた収束は，
結果的に~securityの便益が得られる見込みが高い。
◎
Section 2 identifies existing HTTP fields that can be parsed and serialised with the algorithms defined in [STRUCTURED-FIELDS]. Variances from existing parser behavior might be exploitable, particularly if they allow an attacker to target one implementation in a chain (e.g., an intermediary). However, given the considerable variance in parsers already deployed, convergence towards a single parsing algorithm is likely to have a net security benefit in the longer term.
</p>

<p>
`対応付けられる~field＠#mapped§は、
既存の~fieldの代替な表現を定義する。
`下流$にある消費器は，当の`~message$を［
自身が代替な表現を認識するかどうかに応じて異なるものに解釈する
］かもしれないので、
実装は，そのような`~field値$を`生成-$することは
— それらの~supportを相手の端点と折衝していない限り —
禁制される。
この仕様は，そのような折衝の仕組みを定義しないが、
そのような定義は，そうすることによる含意を注意深く考慮する必要がある。
◎
Section 3 defines alternative representations of existing fields. Because downstream consumers might interpret the message differently based upon whether they recognise the alternative representation, implementations are prohibited from generating such values unless they have negotiated support for them with their peer. This specification does not define such a mechanism, but any such definition needs to consider the implications of doing so carefully.
</p>

	</section>
</main></div>
