<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Retrofit Structured Fields for HTTP（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<style>
/* cookie 属性 */
.cookie-attr {
	font-weight: normal;
	color: var(--text-color-3);
}

caption {
	min-width: 20em;
}
</style>

<script src="common0.js"></script>
<script src="http-common.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">
●●options

spec_title:Retrofit Structured Fields for HTTP
spec_date:2022-09-26
trans_update:2022-09-30
source_checked:220727
original_url:https://httpwg.org/http-extensions/draft-ietf-httpbis-retrofit.html
abbr_url:HTTPretrofit
spec_status:IETFID
page_state_key:HTTP
no_original_dfn:true
ref_rfc:true
	ref_id_prefix:
site_nav:network,http
trans_1st_pub:2022-08-12

●●class_map
a:cookie-attr

●●tag_map
a:code

●●original_id_map

●●mdn_urls

●●link_map

h.ALPN:~RFCx/rfc7639#section-2
h.Accept-CH:~HTTPch#accept-ch
h.Accept-Patch:~HTTPpatch#accept-patch
h.Accept-Post:~TR/ldp#header-accept-post
h.Access-Control-Allow-Credentials:~FETCH#http-access-control-allow-credentials
h.Access-Control-Allow-Headers:~FETCH#http-access-control-allow-headers
h.Access-Control-Allow-Methods:~FETCH#http-access-control-allow-methods
h.Access-Control-Allow-Origin:~FETCH#http-access-control-allow-origin
h.Access-Control-Expose-Headers:~FETCH#http-access-control-expose-headers
h.Access-Control-Max-Age:~FETCH#http-access-control-max-age
h.Access-Control-Request-Headers:~FETCH#http-access-control-request-headers
h.Access-Control-Request-Method:~FETCH#http-access-control-request-method
h.Alt-Svc:~RFCx/rfc7838#section-3
h.Alt-Used:~RFCx/rfc7838#section-5
h.CDN-Cache-Control:~HTTPtargetedcache#cdn-cache-control
h.CDN-Loop:~RFCx/rfc8586#section-2
h.Cache-Status:~HTTPcachestatus#field
h.Clear-Site-Data:~TR/clear-site-data/#header
h.Cross-Origin-Embedder-Policy-Report-Only:~ORIGIN#cross-origin-embedder-policy-report-only
h.Cross-Origin-Embedder-Policy:~ORIGIN#cross-origin-embedder-policy
h.Cross-Origin-Opener-Policy-Report-Only:~ORIGIN#cross-origin-opener-policy-report-only
h.Cross-Origin-Opener-Policy:~ORIGIN#cross-origin-opener-policy-2
h.Cross-Origin-Resource-Policy:~FETCH#http-cross-origin-resource-policy
h.Expect-CT:~RFCx/rfc9163#section-2
h.Keep-Alive:~HTTPv1#compatibility.with.http.1.0.persistent.connections
h.Origin-Agent-Cluster:~ORIGIN#origin-agent-cluster
h.Origin:~FETCH#http-origin
h.Prefer:~RFCx/rfc7240#section-2
h.Preference-Applied:~RFCx/rfc7240#section-3
h.Priority:~RFCx/rfc9218#section-5
h.Proxy-Status:~HTTPproxystatus#header
h.Sec-WebSocket-Extensions:~RFC6455#section-11.3.2
h.Sec-WebSocket-Protocol:~RFC6455#section-11.3.4
h.Sec-WebSocket-Version:~RFC6455#section-11.3.5
h.Server-Timing:~SERVER-TIMING#dfn-server-timing-header-field
h.Surrogate-Control:~TR/edge-arch/
h.Timing-Allow-Origin:~RESOURCE-TIMING#dfn-timing-allow-origin
h.X-Content-Type-Options:~FETCH#http-x-content-type-options
h.X-Frame-Options:~NAVI#x-frame-options
h.X-XSS-Protection:https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection

a.Expires:~HTTPcookie#attribute-expires
a.Max-Age:~HTTPcookie#attribute-max-age
a.Domain:~HTTPcookie#attribute-domain
a.Path:~HTTPcookie#attribute-path
a.Secure:~HTTPcookie#attribute-secure
a.HttpOnly:~HTTPcookie#attribute-httponly
a.SameSite:~HTTPcookie#attribute-samesite

有構造~field:~STRUCTURED-FIELDS#structured-field
p.sf-date:#p.sf-date
~sf日時:#sf-date
~sf~item:~STRUCTURED-FIELDS#sf-item
~sf~key:~STRUCTURED-FIELDS#sf-key
~sf~list:~STRUCTURED-FIELDS#sf-list
~sf~parameter:~STRUCTURED-FIELDS#sf-parameter
~sf~token:~STRUCTURED-FIELDS#sf-token
~sf整数:~STRUCTURED-FIELDS#sf-integer
~sf文字列:~STRUCTURED-FIELDS#sf-string
~sf真偽値:~STRUCTURED-FIELDS#sf-boolean
~sf辞書:~STRUCTURED-FIELDS#sf-dictionary
~sf~parameter群:~STRUCTURED-FIELDS#sf-parameters
~sf裸~item:~STRUCTURED-FIELDS#sf-bare-item
~sf内縁~list:~STRUCTURED-FIELDS#sf-inner-list
~sf~byte列:~STRUCTURED-FIELDS#sf-binary
~sf~decimal:~STRUCTURED-FIELDS#sf-decimal

整数を直列化する:~STRUCTURED-FIELDS#ser-integer
整数または~decimalを構文解析する:~STRUCTURED-FIELDS#parse-number


●●words_table1
RFC6455:RFC6455-ja.html
HTTPtargetedcache:http-targeted-cache-control-ja.html
HTTPcachestatus:http-cache-status-ja.html
HTTPproxystatus:http-proxy-status-ja.html
HTTPch:http-client-hints-ja.html
HTTPcookie:http-cookie-ext-ja.html

sf:<sub>sf-</sub>

●●words_table

	●略語／名称
IPv6:
ALPN:
Unix:
Epoch:
	~Epoch:epoch
HTTP3:HTTP/3

	~HTTP~field名~registry^cite:"Hypertext Transfer Protocol (HTTP) Field Name Registry"

	●構文
角括弧:brackets:~
裸:bare::~
decimal:::10 進数
接頭-:prefix::~

	小文字~化を強制すること:force-lowercasing
	~backslashによる~escape法:backslash-escaping
	~escapeを外す:unescaping
	~escape法:quoting
	quoted-string$p :quoted strings
	範囲~単位$:range-units
	~UTC 1970年 1月 1日 00:00:00:00:00:00 UTC on 1 January 1970
	parameters$p:parameters
	DIGIT$P:number
	`weak$p を伴うもの:weakness flag
	実体~tag:entity-tag
	すべて小文字に:all-lowercase
	ALPHA$P:~alphabetic character
	から始まる:begin with
	始まっている:beginning
	空白のみ:whitespace-only
	~sf~key$:key
	~F また~parameterの不在:0 or unset
	構文解析された `cookie-date$p:parsed-cookie-date
	$p:link-param
	$p:delta-seconds
	^p:date-time
	^p:time-offset
	^p:time-secfrac

	●処理
	`~sf日時$:Date
	%入力~整数:input_integer
	-:input_date
	%入力~文字列:input_string
	%出力~日時:output_date

	●保安
変動:variance:~
標的:target:~

	●仕様
収束:convergence:~
但書き:caveat:~
表記上の:notational:~
場当的:ad hoc:場当たり的
流儀:fashion:~
決定論的:deterministic:~
類似性:similarity:~
黙って:silentに:~
収容-:accommodate:~
現実化-:realise:実現
増強-:enhance:~

	互換でなく:incompatible
	より長期的:longer term
	長期的:long-term
	珍しくない:not uncommon
	ないはずだが:shouldn't~be
	大勢を占めている:vast majority
	可能でない:unable
	可能でない:not be able
	かなりの:considerable
	結果的に:net
	したがって、〜できない:This prevents
	のうち選定されたもの:a selection of
	大部分の:bulk of
	仕立て上げる:making
	成している:making up
	挙げられよう:might be advisable
	注記:note
	選ばれ:chosen
	誤って:mistakenly
	同じ行に挙げられた:paired with...
	異なるように:differently
	見込みが高い:likely
	一部を〜として選定する:nominates a selection of
	-:nominated registrations
	列:column

	●未分類
retrofit:
無構造:unstructured::~
消費器:consumer::~
閏秒:leap seconds:~
	〜からの秒数:number of delta seconds
	〜からの秒数:delta in seconds

	除外する:minus
	~field値:payload
	有構造~field$:Structured Field
	有構造~型:Structured Type
	~retrofit有構造~field:~Retrofit Structured Fields
	~MIME:media
	~Internet:internet
	~cookie~属性~registry^cite:Cookie Attribute Registry
	相手の端点:peer

	●他
	少数の:small
	先立つ:prior
	より大きい:larger
	`STRUCTURED-FIELDS$r :RFC8941
	へ向けた:toward
	より広い:wider
	最後に:finally

●●ref_key_map

●●ref_normative

[COOKIES]
    Chen, L., Englehardt, S., West, M., and J. Wilander, ＜Cookies: HTTP State Management Mechanism＞, Work in Progress, Internet-Draft, draft-ietf-httpbis-rfc6265bis-10, 24 April 2022, URL: https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-10
[HTTP]
    Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., ＜HTTP Semantics＞, STD 97, ~RFC9110, June 2022
[RFC2119]
    Bradner, S., ＜Key words for use in RFCs to Indicate Requirement Levels＞, BCP 14, ~RFC2119, March 1997
[RFC3339]
    Klyne, G. and C. Newman, ＜Date and Time on the Internet: Timestamps＞, ~RFC3339, July 2002

[RFC8174]
    Leiba, B., ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞, BCP 14, ~RFC8174, May 2017
[RFC8288]
    Nottingham, M., ＜Web Linking＞, ~RFC8288, October 2017
[STRUCTURED-FIELDS]
    Nottingham, M. and P-H. Kamp, ＜Structured Field Values for HTTP＞, ~RFC8941, February 2021


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により Internet-Draft として公表された，
<a href="~SPEC_URL">Retrofit Structured Fields for HTTP</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

公表者
	<a href="https://httpwg.org/">HTTP Working Group</a>
位置付け
	Internet-Draft
更新
	RFC 8941 （認可されたならば）
意図される位置付け
	Standards Track
失効日
	日付から半年後
編集／著作者アドレス
	<a href="https://www.mnot.net/">Mark Nottingham</a>, Prahran, Australia, <a href="mailto:mnot@mnot.net">mnot@mnot.net</a>
課題追跡
	https://github.com/httpwg/http-extensions/labels/retrofit
履歴
	https://datatracker.ietf.org/doc/draft-ietf-httpbis-retrofit/
commit 履歴
	https://github.com/httpwg/http-extensions/commits/main/draft-ietf-httpbis-retrofit.md

HTTP 拡張仕様草案
	https://github.com/httpwg/http-extensions#draft-http-extension-specifications
現在の Internet-Draft のリスト
	https://datatracker.ietf.org/drafts/current/
</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTTP 用の retrofit 有構造フィールド</h1>
<p>Retrofit Structured Fields for HTTP</p>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="section-abstract">
~ABSTRACT

<p>
この仕様は、
既存の~HTTP~fieldのうち一部を`有構造~field$と互換な構文を有するものとして選定する
— それらを`有構造~field$のように取扱えるよう
（それらは、ある種の但書きの~subjectにもなる）。
◎
This specification nominates a selection of existing HTTP fields as having syntax that is compatible with Structured Fields, so that they can be handled as such (subject to certain caveats).
</p>

<p>
また、
構文が互換でない~fieldのうち一部を追加的に収容するため，
それらの意味論から新たな`有構造~field$への対応付けも定義する。
この仕様は、
それらの利用を折衝する方法は指定しない。
◎
To accommodate some additional fields whose syntax is not compatible, it also defines mappings of their semantics into new Structured Fields. It does not specify how to negotiate their use.
</p>

<p>
それらの対応付けのうち 1 つは、
新たな有構造~field~data型として`~sf日時$の導入を要求する。
◎
One of those mappings requires introduction of a new Structured Fields data type, Date.
</p>

<p class="trans-note">【
~retrofitの意味：
“~~昔からあるものを現代のものに（ `retro^en ）~~適するよう合わせる（ `fit^en ）” 
】</p>

	</section>
	<section>
<h2 title="About This Document">この文書について</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#about-this-draft$に移譲。
】</p>

<!-- 
https://datatracker.ietf.org/doc/draft-ietf-httpbis-retrofit/

Source for this draft and an issue tracker can be found at https://github.com/httpwg/http-extensions/labels/retrofit.
-->

	</section>
	<section id="status-of-memo">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status-draft$に移譲。
】</p>

	</section>
	<section id="copyright">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
`~HTTP用の有構造~field値^cite `STRUCTURED-FIELDS$r は、
新たな~HTTP~field用の値に利用するため，
構文解析~algoと直列化~algoが結付けられた~data~modelを導入した。
`有構造~field$として定義された~fieldは、
次に挙げるものなど，
いくつかの便益を現実化できる：
◎
Structured Field Values for HTTP [STRUCTURED-FIELDS] introduced a data model with associated parsing and serialization algorithms for use by new HTTP field values. Fields that are defined as Structured Fields can realise a number of benefits, including:
</p>
<ul>
	<li>
相互運用能と~securityが改善される
⇒
精確に定義された［
構文解析~algo, 直列化~algo
］は、
~ABNFや注釈文だけを伴って定義された~field用には，概して可用でない。
◎
Improved interoperability and security: precisely defined parsing and serialisation algorithms are typically not available for fields defined with just ABNF and/or prose.
</li>
	<li>
共通な実装の再利用
⇒
他の~field用の多くの構文解析器は、［
単独の~fieldか, 少数の~fieldからなる族
］に特有である。
◎
Reuse of common implementations: many parsers for other fields are specific to a single field or a small family of fields.
</li>
	<li>
正準的な形
⇒
各~型~用に決定論的な直列化~algoが定義されたので、
`有構造~field$には，正準的な表現がある。
◎
Canonical form: because a deterministic serialisation algorithm is defined for each type, Structure Fields have a canonical representation.
</li>
	<li>
~API~supportが増強される
⇒
定例の~data~modelにより，
`~field値$を実装において~nativeな~data構造として公開することが，より容易になる。
◎
Enhanced API support: a regular data model makes it easier to expose field values as a native data structure in implementations.
</li>
	<li>
代替な直列化
⇒
`STRUCTURED-FIELDS$r は，
その~data~modelの~textな直列化を定義するが、
他の，より効率的な下層の~data~modelの直列化もアリになる。
◎
Alternative serialisations: While [STRUCTURED-FIELDS] defines a textual serialisation of that data model, other, more efficient serialisations of the underlying data model are also possible.
</li>
</ul>

<p>
しかしながら，これらの便益が現実化されるためには、
`~field$は，`有構造~field$として定義される必要がある。
既存の`~field$の多くは、
そうでなく，~Internet上の~HTTP流通において見られる大部分の［
`~header$／`~trailer$
］を成している。
◎
However, a field needs to be defined as a Structured Field for these benefits to be realised. Many existing fields are not, making up the bulk of header and trailer fields seen in HTTP traffic on the internet.
</p>

<p>
この仕様は、
これらの便益を現実化できるよう，［
既存の~HTTP~fieldのうち選定されたものを`有構造~field$として どう取扱えるか
］を定義して、
それらを~retrofit有構造~fieldに仕立て上げる。
◎
This specification defines how a selection of existing HTTP fields can be handled as Structured Fields, so that these benefits can be realised -- thereby making them Retrofit Structured Fields.
</p>

<p>
これは、
次の 2 つの技法を利用して行われる：
◎
It does so using two techniques.＼
</p>
<ul>
	<li>
`2＠#compatible§は、
互換な~field
— 当の~fieldに定義された構文と`有構造~field$における構文との類似性に因り，
`有構造~field$であったかのように取扱える~field —
を挙げる。
◎
Section 2 lists compatible fields -- those that can be handled as if they were Structured Fields due to the similarity of their defined syntax to that in Structured Fields.＼
</li>
	<li>
`3＠#mapped§は、
対応付けられる~field
— 当の~fieldの構文を下層の~data~modelの中へ形式変換してから，
`有構造~field$により定義される~data~modelの中へ対応付ける必要がある~field —
を挙げる。
◎
Section 3 lists mapped fields -- those whose syntax needs to be transformed into an underlying data model which is then mapped into that defined by Structured Fields.
</li>
</ul>

<p>
実装は、
互換な~fieldを`有構造~field$として
— `2＠#compatible§に与える但書きの~subjectになる下で —
構文解析して直列化できるが、
`送信者$は、
`3＠#mapped§に挙げる対応付けられた~fieldを生成できないことに注意
— それらは、
先立つ折衝を伴わない限り，［
`受信者$により解され，動作する
］ものとは期待できない。
この仕様は、
そのような折衝の仕組みは定義しない。
◎
Note that while implementations can parse and serialise compatible fields as Structured Fields subject to the caveats in Section 2, a sender cannot generate mapped fields from Section 3 and expect them to be understood and acted upon by the recipient without prior negotiation. This specification does not define such a mechanism.
</p>

		</section>
		<section id="notational-conventions">
<h3 title="Notational Conventions">1.1. 表記上の規約</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.
</p>

<p>
この文書は、
`RFC3339$r から次に挙げる規則を利用する
【と記されているが、（まだ）利用されていない】
⇒＃
`date-time^p,
`time-offset^p,
`time-secfrac^p
◎
This document uses the date-time, time-offset, and time-secfrac rules from [RFC3339].
</p>

	</section>
	<section id="compatible">
<h2 title="Compatible Fields">2. 互換な~field</h2>

<p>
~HTTP~fieldのうち，
`表 1＠#compatible-fields$ の 1 列目に挙げられるものは、
通例的に，それらの値を
`STRUCTURED-FIELDS$r に挙げられた［
構文解析, 直列化
］~algoに則って，
`有構造~field$として取扱える
— 以下に挙げる但書きの~subjectになる下で。
◎
The HTTP fields listed in Table 1 can usually have their values handled as Structured Fields according to the listed parsing and serialisation algorithms in [STRUCTURED-FIELDS], subject to the listed caveats.
</p>

<p>
この表の 2 列目に挙げられた型は、［
当の~fieldに定義される構文
］および［
~Internetにおける実際の流通
］との互換性を得るように選ばれた。
しかしながら、
これらの~fieldの~instanceすべてが成功裡に構文解析されるとは限らない。
これは、［
当の`~field値$が明瞭に妥当でないこと／
妥当であるが，`有構造~field$として構文解析-可能でないこと
］どちらによることもある。
◎
The listed types are chosen for compatibility with the defined syntax of the field as well as with actual internet traffic. However, not all instances of these fields will successfully parse. This might be because the field value is clearly invalid, or it might be because it is valid but not parseable as a Structured Field.
</p>

<p>
この仕様を利用している応用は、
その要件に依存して，そのような`~field値$を取扱う方法を考慮する必要がある。
そのような値［
を却下する／
を不透明な文字列として扱う／
から場当的な流儀で有構造~field値を回復しようと試みる
］などが挙げられよう。
◎
An application using this specification will need to consider how to handle such field values. Depending on its requirements, it might be advisable to reject such values, treat them as opaque strings, or attempt to recover a structured value from them in an ad hoc fashion.
</p>

<div>
<table><caption id="compatible-fields">表 1：
互換な~field
</caption>
<thead><tr>
<th>~field名
<th>有構造~型
</thead><tbody>

<tr><td>`Accept$h
<td>`~sf~list$

<tr><td>`Accept-Encoding$h
<td>`~sf~list$

<tr><td>`Accept-Language$h
<td>`~sf~list$

<tr><td>`Accept-Patch$h
<td>`~sf~list$

<tr><td>`Accept-Post$h
<td>`~sf~list$

<tr><td>`Accept-Ranges$h
<td>`~sf~list$

<tr><td>`Access-Control-Allow-Credentials$h
<td>`~sf~item$

<tr><td>`Access-Control-Allow-Headers$h
<td>`~sf~list$

<tr><td>`Access-Control-Allow-Methods$h
<td>`~sf~list$

<tr><td>`Access-Control-Allow-Origin$h
<td>`~sf~item$

<tr><td>`Access-Control-Expose-Headers$h
<td>`~sf~list$

<tr><td>`Access-Control-Max-Age$h
<td>`~sf~item$

<tr><td>`Access-Control-Request-Headers$h
<td>`~sf~list$

<tr><td>`Access-Control-Request-Method$h
<td>`~sf~item$

<tr><td>`Age$h
<td>`~sf~item$

<tr><td>`Allow$h
<td>`~sf~list$

<tr><td>`ALPN$h
<td>`~sf~list$

<tr><td>`Alt-Svc$h
<td>`~sf辞書$

<tr><td>`Alt-Used$h
<td>`~sf~item$

<tr><td>`Cache-Control$h
<td>`~sf辞書$

<tr><td>`CDN-Loop$h
<td>`~sf~list$

<tr><td>`Clear-Site-Data$h
<td>`~sf~list$

<tr><td>`Connection$h
<td>`~sf~list$

<tr><td>`Content-Encoding$h
<td>`~sf~list$

<tr><td>`Content-Language$h
<td>`~sf~list$

<tr><td>`Content-Length$h
<td>`~sf~list$

<tr><td>`Content-Type$h
<td>`~sf~item$

<tr><td>`Cross-Origin-Resource-Policy$h
<td>`~sf~item$

<tr><td>`Expect$h
<td>`~sf辞書$

<tr><td>`Expect-CT$h
<td>`~sf辞書$

<tr><td>`Host$h
<td>`~sf~item$

<tr><td>`Keep-Alive$h
<td>`~sf辞書$

<tr><td>`Max-Forwards$h
<td>`~sf~item$

<tr><td>`Origin$h
<td>`~sf~item$

<tr><td>`Pragma$h
<td>`~sf辞書$

<tr><td>`Prefer$h
<td>`~sf辞書$

<tr><td>`Preference-Applied$h
<td>`~sf辞書$

<tr><td>`Retry-After$h
<td>`~sf~item$

<tr><td>`Sec-WebSocket-Extensions$h
<td>`~sf~list$

<tr><td>`Sec-WebSocket-Protocol$h
<td>`~sf~list$

<tr><td>`Sec-WebSocket-Version$h
<td>`~sf~item$

<tr><td>`Server-Timing$h
<td>`~sf~list$

<tr><td>`Surrogate-Control$h
<td>`~sf辞書$

<tr><td>`TE$h
<td>`~sf~list$

<tr><td>`Timing-Allow-Origin$h
<td>`~sf~list$

<tr><td>`Trailer$h
<td>`~sf~list$

<tr><td>`Transfer-Encoding$h
<td>`~sf~list$

<tr><td>`Vary$h
<td>`~sf~list$

<tr><td>`X-Content-Type-Options$h
<td>`~sf~item$

<tr><td>`X-Frame-Options$h
<td>`~sf~item$

<tr><td>`X-XSS-Protection$h
<td>`~sf~list$

</tbody>
</table>

◎
Table 1: Compatible Fields
◎
Field Name｜Structured Type
Accept｜List
Accept-Encoding｜List
Accept-Language｜List
Accept-Patch｜List
Accept-Post｜List
Accept-Ranges｜List
Access-Control-Allow-Credentials｜Item
Access-Control-Allow-Headers｜List
Access-Control-Allow-Methods｜List
Access-Control-Allow-Origin｜Item
Access-Control-Expose-Headers｜List
Access-Control-Max-Age｜Item
Access-Control-Request-Headers｜List
Access-Control-Request-Method｜Item
Age｜Item
Allow｜List
ALPN｜List
Alt-Svc｜Dictionary
Alt-Used｜Item
Cache-Control｜Dictionary
CDN-Loop｜List
Clear-Site-Data｜List
Connection｜List
Content-Encoding｜List
Content-Language｜List
Content-Length｜List
Content-Type｜Item
Cross-Origin-Resource-Policy｜Item
Expect｜Dictionary
Expect-CT｜Dictionary
Host｜Item
Keep-Alive｜Dictionary
Max-Forwards｜Item
Origin｜Item
Pragma｜Dictionary
Prefer｜Dictionary
Preference-Applied｜Dictionary
Retry-After｜Item
Sec-WebSocket-Extensions｜List
Sec-WebSocket-Protocol｜List
Sec-WebSocket-Version｜Item
Server-Timing｜List
Surrogate-Control｜Dictionary
TE｜List
Timing-Allow-Origin｜List
Trailer｜List
Transfer-Encoding｜List
Vary｜List
X-Content-Type-Options｜Item
X-Frame-Options｜Item
X-XSS-Protection｜List
</div>

<p>
互換性に関しては、
次に挙げる但書きにも注意：
◎
Note the following caveats regarding compatibility:
</p>
<dl>
	<dt>
［
`~sf~parameter$／`~sf辞書$
］の`~sf~key$
◎
Parameter and Dictionary keys:
</dt>
	<dd>
~HTTPの~parameter名（ `parameter-name$p `HTTP$r ）は，文字大小無視であるが、
`有構造~field$においては，すべて小文字にすることが要求される。
典型的な流通にて見られる~parameterは，すべて小文字にされたものが大勢を占めているが、
構文解析-時に~parameterの小文字~化を強制することで，互換性を改善できる。
同様に、
`~sf辞書$に基づく多くの~fieldでは
（例：
`Cache-Control$h,
`Expect-CT$h,
`Pragma$h,
`Prefer$h,
`Preference-Applied$h,
`Surrogate-Control$h ），
~keyは文字大小無視なので、
構文解析-時に小文字~化を強制することで，互換性を改善できる。
◎
HTTP parameter names are case-insensitive (per Section 5.6.6 of [HTTP]), but Structured Fields require them to be all-lowercase. Although the vast majority of parameters seen in typical traffic are all-lowercase, compatibility can be improved by force-lowercasing parameters when parsing. Likewise, many Dictionary-based fields (e.g., Cache-Control, Expect-CT, Pragma, Prefer, Preference-Applied, Surrogate-Control) have case-insensitive keys, and compatibility can be improved by force-lowercasing them when parsing.
</dd>

	<dt>
`~sf~parameter$の区切り
◎
Parameter delimitation:
</dt>
	<dd>
~HTTPの `parameters$p 規則（ `HTTP$r ）は，
区切子 "`;^c" の前に空白を許容するが、
`有構造~field$は，そうでない。
そのような空白を構文解析-時に許容することで，互換性を改善できる。
◎
The parameters rule in HTTP (see Section 5.6.6 of [HTTP]) allows whitespace before the ";" delimiter, but Structured Fields does not. Compatibility can be improved by allowing such whitespace when parsing.
</dd>

	<dt>
`~sf文字列$の~escape法
◎
String quoting:
</dt>
	<dd>
~HTTPの `quoted-string$p （ `HTTP$r ）は、
ほとんどの文字に対し，~backslashによる~escape法を許容するが、
`有構造~field$における文字列（`~sf文字列$）において~escapeできる文字は，［
"`\^c", `DQUOTE$P
］に限られる。
他の文字の~escapeを構文解析する前に外すことで，互換性を改善できる。
◎
Section 5.6.4 of [HTTP] allows backslash-escaping most characters in quoted strings, whereas Structured Field Strings only escape "\" and DQUOTE. Compatibility can be improved by unescaping other characters before parsing.
</dd>

	<dt>
`~sf~token$の制限
◎
Token limitations:
</dt>
	<dd>
`有構造~field$における~token（`~sf~token$）は，［
`ALPHA$P ／ "`*^c"
］から始まることが要求される一方で、
~HTTPにおける~token（ `token$p ）は，より広い範囲の文字を許容する。
したがって、
対応付けられた値においては，前者以外の文字から始まる~tokenは利用できない。
例えば，［
`~MIME型$, `~field名$, `~method$, `範囲~単位$, 文字, `転送~符号法$
］のうち［
`DIGIT$P ／ "`*^c" 以外の特殊~文字
］から始まるものは、
~HTTP~protocol要素としては妥当になり得るが，
`~sf~token$としては表現-可能でない。
◎
In Structured Fields, tokens are required to begin with an alphabetic character or "*", whereas HTTP tokens allow a wider range of characters. This prevents use of mapped values that begin with one of these characters. For example, media types, field names, methods, range-units, character and transfer codings that begin with a number or special character other than "*" might be valid HTTP protocol elements, but will not be able to be represented as Structured Field Tokens.
</dd>

	<dt>
`~sf整数$の制限
◎
Integer limitations:
</dt>
	<dd>
`有構造~field$における整数（`~sf整数$）は、
15 桁までである
— より大きい値は表現-可能でない。
◎
Structured Fields Integers can have at most 15 digits; larger values will not be able to be represented in them.
</dd>

	<dt>
~IPv6~literal
◎
IPv6 Literals:
</dt>
	<dd>
~IPv6~literal~addressを値に包含する~field
（ `CDN-Loop$h, `Host$h, `Origin$h など ）
は、
`~sf~token$として表現-可能でない
— それらを区切るために利用される角括弧は、
`~sf~token$においては許容されないので。
◎
Fields whose values contain IPv6 literal addresses (such as CDN-Loop, Host, and Origin) are not able to be represented as Structured Fields Tokens, because the brackets used to delimit them are not allowed in Tokens.
</dd>

	<dt>
空な`~field値$
◎
Empty Field Values:
</dt>
	<dd>
［
空な／空白のみからなる
］`~field値$は、
`有構造~field$においては~errorと見なされる。
互換な~fieldにおいては、
これら空な~fieldは，当の~fieldを黙って無視するべきであることを指示する。
◎
Empty and whitespace-only field values are considered errors in Structured Fields. For compatible fields, an empty field indicates that the field should be silently ignored.
</dd>

	<dt>
`Alt-Svc$h
◎
Alt-Svc:
</dt>
	<dd>
一部の~ALPN~token（例： `h3-Q43^c ）は、
`~sf~key$の構文に適合しないので，`~sf~token$として表現し得ない。
~HTTP3の最終-~version【 ~RFC 9114 】は `h3^c ~tokenを利用するので、
これは，長期的な課題にはならないはずだが、
将来の~tokenは，この前提に再び違反し得る。
◎
Some ALPN tokens (e.g., h3-Q43) do not conform to key's syntax, and therefore cannot be represented as a Token. Since the final version of HTTP/3 uses the h3 token, this shouldn't be a long-term issue, although future tokens may again violate this assumption.
</dd>

	<dt>
`Content-Length$h
◎
Content-Length:
</dt>
	<dd>
`Content-Length$h は、
`~sf~list$として定義されることに注意
— 実装が複数個の値を誤って送信することは珍しくないので。
その取扱い要件は、
`HTTP$r `Content-Length§h を見よ。
◎
Note that Content-Length is defined as a List because it is not uncommon for implementations to mistakenly send multiple values. See Section 8.6 of [HTTP] for handling requirements.
</dd>

	<dt>
`Retry-After$h
◎
Retry-After:
</dt>
	<dd>
表現できる値は、
`delta-seconds$p に限られる
— `HTTP-date$p【！http-date】 を包含している値は、
有構造~field値として伝達するためには， `delta-seconds$p に変換する必要がある。
◎
Only the delta-seconds form of Retry-After can be represented; a Retry-After value containing a http-date will need to be converted into delta-seconds to be conveyed as a Structured Field Value.
</dd>
</dl>

	</section>
	<section id="mapped">
<h2 title="Mapped Fields">3. 対応付けられる~field</h2>

<p>
一部の`~field$の値の構文は、
`有構造~field$として成功裡に構文解析できない。
代わりに，代替な名前を伴う別々な`有構造~field$の中へ対応付けることが必要とされる。
◎
Some HTTP field values have syntax that cannot be successfully parsed as Structured Fields. Instead, it is necessary to map them into a separate Structured Field with an alternative name.
</p>

<div class="example">
<p>
例えば、
`Date$h `~header$は，日時を運ぶ：
◎
For example, the Date HTTP header field carries a date:
</p>

<pre class="lang-http">
Date: Sun, 06 Nov 1994 08:49:37 GMT
</pre>

<p>
その値は、
次のように対応付けられよう：
◎
Its value would be mapped to:
</p>

<pre class="lang-http">
SF-Date: @784111777
</pre>
</div>

<p>
`2＠#compatible§と同じく、
これらの~fieldは，`有構造~field$において妥当にならない値を運ぶことは可能でないので、
この仕様を利用している応用は，そのような値を~supportする方法が必要になる。
それらを取扱うことは、
概して，元の~field名を利用することで足る。
◎
As in Section 2, these fields are unable to carry values that are not valid Structured Fields, and so an application using this specification will need to how to support such values. Typically, handling them using the original field name is sufficient.
</p>

<p>
以下に挙げられる各~field名は、
置換~field名【 `SF-^c が接頭されたもの】, および［
その元の値を`有構造~field$の中へ対応付ける手段
］を指示する。
◎
Each field name listed below indicates a replacement field name and a means of mapping its original value into a Structured Field.
</p>

		<section id="urls">
<h3 title="URLs">3.1. ~URL</h3>

<p>
`表 2＠#url-fields$ の 1 列目に挙げる`~field名$は、
その値を`~sf文字列$として扱うことにより，
同じ行の 2 列目に挙げる`有構造~field$の中へ対応付けれる。
◎
The field names in Table 2 (paired with their mapped field names) have values that can be mapped into Structured Fields by treating the original field's value as a String.
</p>

<div>
<table><caption id="url-fields">表 2：
~URLを値にとる~field
</caption>
<thead><tr><th>~field名
<th>対応付けられる~field名
</thead><tbody>

<tr><td>`Content-Location$h
<td>`SF-Content-Location^h

<tr><td>`Location$h
<td>`SF-Location^h

<tr><td>`Referer$h
<td>`SF-Referer^h

</tbody></table>

◎
Table 2: URL Fields
◎
Field Name｜Mapped Field Name
Content-Location｜SF-Content-Location
Location｜SF-Location
Referer｜SF-Referer
</div>

<div class="example">
<p>
例えば、
次の `Location$h ~fieldは：
◎
For example, this Location field
</p>

<pre class="lang-http">
Location: https://example.com/foo
</pre>

<p>
次に対応付けることもできる：
◎
could be mapped as:
</p>

<pre class="lang-http">
SF-Location: "https://example.com/foo"
</pre>
</div>

		</section>
		<section id="dates">
<h3 title="Dates">3.2. 日時</h3>

<p>
`表 3＠#date-fields$ の 1 列目に挙げる`~field名$
【言い換えれば、 `HTTP-date$p を値にとる`単数~field$】
は、［
同じ行の 2 列目に挙げられた`有構造~field$
］の中へ対応付けれる
— その値を［
`HTTP$r `日時の形式＠~HTTPinfra#http.date§に則って構文解析した結果
］を［
~Unix~Epoch（~UTC 1970年 1月 1日 00:00:00 ）からの秒数に
— 閏秒は除外して —
換算した結果
］の整数【！Integer number】を［
`付録 A＠#date-type§にて定義される`有構造~field$用の~data型 `~sf日時$
］として表現することにより。
◎
The field names in Table 3 (paired with their mapped field names) have values that can be mapped into Structured Fields by parsing their payload according to Section 5.6.7 of [HTTP] and representing the result as an Integer number of seconds delta from the Unix Epoch (00:00:00 UTC on 1 January 1970, excluding leap seconds), using the Date Structured Fields data type defined in Appendix A.
</p>

<div>
<table><caption id="date-fields">表 3：
日時~field
</caption>
<thead>
<tr>
<th>~field名
<th>対応付けられる~field名

</thead><tbody>
<tr><td>`Date$h
<td>`SF-Date^h

<tr><td>`Expires$h
<td>`SF-Expires^h

<tr><td>`If-Modified-Since$h
<td>`SF-If-Modified-Since^h

<tr><td>`If-Unmodified-Since$h
<td>`SF-If-Unmodified-Since^h

<tr><td>`Last-Modified$h
<td>`SF-Last-Modified^h

</tbody>
</table>

◎
Table 3: Date Fields
◎
Field Name｜Mapped Field Name
Date｜SF-Date
Expires｜SF-Expires
If-Modified-Since｜SF-If-Modified-Since
If-Unmodified-Since｜SF-If-Unmodified-Since
Last-Modified｜SF-Last-Modified
</div>

<div class="example">
<p>
例えば `Expires$h ~fieldは、
次に対応付けることもできる：
◎
For example, an Expires field could be mapped as:
</p>

<pre class="lang-http">
SF-Expires: @1659578233
</pre>
</div>

		</section>
		<section id="etags">
<h3 title="ETags">3.3. `ETag^h</h3>

<p>
`ETag$h ~headerの値（ `entity-tag$p ）は、
次を伴う`~sf~item$で表現することにより，
`SF-ETag^h `有構造~field$の中へ対応付けれる：
◎
The field value of the ETag header field can be mapped into the SF-ETag Structured Field by representing＼
</p>
<ul>
	<li>
~field値を成す `opaque-tag$p を`~sf文字列$として表現する
（当の~itemの値を成す）。
◎
the entity-tag as a String,＼
</li>
	<li>
~field値を成す `weak$p の有無を`~sf真偽値$をとる "`w^c" ~parameterとして表現する
（当の~itemの`~sf~parameter群$を成す）。
ここで、［
~T は弱い`実体~tag$であること／
~F また~parameterの不在は，強い`実体~tag$であること
］を指示する。
◎
and the weakness flag as a Boolean "w" parameter on it, where true indicates that the entity-tag is weak; if 0 or unset, the entity-tag is strong.
</li>
</ul>

<div class="example">
<p>
例えば、
次は：
◎
For example, this:
</p>

<pre class="lang-http">
ETag: W/"abcdef"
</pre>

<p>
次に対応付けれる：
</p>

<pre class="lang-http">
SF-ETag: "abcdef"; w
</pre>
</div>

<div class="p">
<p>
`If-None-Match$h の`~field値$は、
次により `SF-If-None-Match^h `有構造~field$の中へ対応付けれる：
</p>
<ul>
	<li>
~field値が "`*^c" のときは、
`~sf~token$として表現する。
</li>
	<li>
他の場合、
~field値を成す各 `entity-tag$p を上で述べたとおりの構造で表現して，
それらの`~sf~item$からなる`~sf~list$として表現する。
</li>
</ul>
◎
If-None-Match's field value can be mapped into the SF-If-None-Match Structured Field, which is a List of the structure described above. When a field value contains "*", it is represented as a Token.
</div>

<p>
同様に，
`If-Match$h の`~field値$は、
同じ方式で `SF-If-Match^h `有構造~field$の中へ対応付けれる。
◎
Likewise, If-Match's field value can be mapped into the SF-If-Match Structured Field in the same manner.
</p>

<div class="example">
<p>
例えば：
◎
For example:
</p>

<pre class="lang-http">
SF-If-None-Match: "abcdef"; w, "ghijkl", *
</pre>
</div>

		</section>
		<section id="links">
<h3 title="Links">3.4. ~link</h3>

<p>
`Link$h ~header `RFC8288$r の`~field値$は、
`~sf~list$を値にとる `SF-Link^h `有構造~field$の中へ対応付けれる
— 【~field値を成す各 `link-value＠~HTTPweblink#p.link-value$p が~listを成す各~item（`~sf~item$）を与え，それを成す】［
`URI-Reference＠~HTTPweblink#p.URI-Reference$p を`~sf文字列$／
一連の `link-param＠~HTTPweblink#p.link-param$p を`~sf~parameter群$
］と見なすことにより。
◎
The field value of the Link header field [RFC8288] can be mapped into the SF-Link List Structured Field by considering the URI-Reference as a String, and link-param as Parameters.
</p>

<div class="example">
<p>
例えば、次は：
◎
For example, this:
</p>

<pre class="lang-http">
Link: &lt;/terms&gt;; rel="copyright"; anchor="#foo"
</pre>

<p>
次に対応付けれる：
◎
can be mapped to:
</p>

<pre class="lang-http">
SF-Link: "/terms"; rel="copyright"; anchor="#foo"
</pre>
</div>

		</section>
		<section id="cookies">
<h3 title="Cookies">3.5. ~cookie</h3>

<p>
［
`Cookie$h ／ `Set-Cookie$h
］ `COOKIES$r の`~field値$は、
それを成す一連の~cookieからなる`~sf~list$で表現することにより，［
`SF-Cookie^h ／ `SF-Set-Cookie^h
］`有構造~field$の中へ対応付けれる。
◎
The field values of the Cookie and Set-Cookie fields [COOKIES] can be mapped into the SF-Cookie Structured Field (a List) and SF-Set-Cookie Structured Field (a List), respectively.
</p>

<p>
各~cookieは， 2 個の`~sf~item$
— ~cookie名と~cookie値 —
を包含している`~sf内縁~list$として表現される。
~cookie名は、
常に`~sf文字列$になる。
~cookie値は、［
`~sf文字列$以外の`~sf裸~item$の~textな表現として成功裡に構文解析できるならば，それ
（`~sf~byte列$／`~sf~decimal$／`~sf整数$／`~sf~token$／`~sf真偽値$）／
~ELSE_ `~sf文字列$
］になる。
◎
In each case, a cookie is represented as an Inner List containing two Items; the cookie name and value. The cookie name is always a String; the cookie value is a String, unless it can be successfully parsed as the textual representation of another, bare Item structured type (e.g., Byte Sequence, Decimal, Integer, Token, or Boolean).
</p>

<p>
一連の~cookie属性は、
各~parameterの名前を小文字に強制した上で，
当の`~sf内縁~list$の`~sf~parameter群$に対応付けられる。
~cookie属性の値は、
当の属性~用に特有な型が定義される場合を除き，`~sf文字列$になる。
この仕様は、
`表 4＠#cookie-params$ にて，
既存の~cookie属性~用の型を定義する。
◎
Cookie attributes map to Parameters on the Inner List, with the parameter name being forced to lowercase. Cookie attribute values are Strings unless a specific type is defined for them. This specification defines types for existing cookie attributes in Table 4.
</p>

<div>
<table><caption id="cookie-params">表 4：
`Set-Cookie$h ~parameter型
</caption>
<thead>
<tr>
<th>~parameter名
<th>有構造~型
</thead><tbody>

<tr><td>`Domain$a
<td>`~sf文字列$

<tr><td>`HttpOnly$a
<td>`~sf真偽値$

<tr><td>`Expires$a
<td>`~sf日時$＊

<tr><td>`Max-Age$a
<td>`~sf整数$

<tr><td>`Path$a
<td>`~sf文字列$

<tr><td>`Secure$a
<td>`~sf真偽値$

<tr><td>`SameSite$a
<td>`~sf~token$

</tbody></table>

◎
Table 4: Set-Cookie Parameter Types
◎
Parameter Name｜Structured Type
Domain｜String
HttpOnly｜Boolean
Expires｜Integer
Max-Age｜Integer
Path｜String
Secure｜Boolean
SameSite｜Token
</div>


<p>
`Expires$a 属性は、
`~sf日時$＊による表現
— 構文解析された `cookie-date＠~HTTPcookie#p.cookie-date$p 
（ `COOKIES$r `日付＠~HTTPcookie#cookie-date§ を見よ）
に対応付けられる。
◎
The Expires attribute is mapped to a Date representation of parsed-cookie-date (see Section 5.1.1 of [COOKIES]).
</p>

<div class="example">
<p>
例えば、
次の無構造な~fieldは：
◎
For example, these unstructured fields:
</p>

<pre class="lang-http">
Set-Cookie: lang=en-US; Expires=Wed, 09 Jun 2021 10:18:14 GMT; samesite=Strict; secure
</pre>

<pre class="lang-http">
Cookie: SID=31d4d96e407aad42; lang=en-US
</pre>

<p>
次に対応付けれる：
◎
can be mapped into:
</p>

<pre class="lang-http">
SF-Set-Cookie: ("lang" "en-US"); expires=@1623233894＊; samesite=Strict; secure
</pre>

<pre class="lang-http">
SF-Cookie: ("SID" "31d4d96e407aad42"), ("lang" "en-US")
</pre>
</div>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">4. ~IANA考慮点</h2>

<p>
【この文書は、以下に挙げる行為を~IANAに依頼する。】
</p>

<p>
`~HTTP~field名~registry＠~IANA-a/http-fields/$cite
に対し：
◎
↓</p>
<ul>
	<li>
<p>
次の注記を追加する：
◎
Please add the following note to the "Hypertext Transfer Protocol (HTTP) Field Name Registry":
</p>
		<ul>
			<li>
“有構造~型” 列は、
`~field値$の型（ `STRUCTURED-FIELDS$r ）を次のいずれかとして指示する（もし在れば）
⇒
`~sf辞書$／`~sf~list$／`~sf~item$
◎
The "Structured Type" column indicates the type of the field (per RFC8941), if any, and may be "Dictionary", "List" or "Item".＼
</li>
			<li>
【型に付与された】接頭辞 "`*^c" は、
それが~retrofit型である
（すなわち、~nativeに有構造でない）ことを指示する
— `この仕様^r を見よ。
◎
A prefix of "*" indicates that it is a retrofit type (i.e., not natively Structured); see [this specification].
</li>
			<li>
［
`ALPHA$P ／ "`*^c"
］以外の文字から始まる`~field名$は、
`~sf~token$として表現-可能でないので，
それを指す【値に含む】~fieldの中へ対応付けられると互換でなくなり得ることに注意。
`この仕様^r を見よ。
◎
Note that field names beginning with characters other than ALPHA or "*" will not be able to be represented as a Structured Fields Token, and therefore may be incompatible with being mapped into fields that refer to it; see [this specification].
</li>
		</ul>
	</li>
	<li>
新たな列 “有構造~型” を追加する
— `表 1＠#compatible-fields$（ § 2 ）に挙げた各~field名に対し，
それにアテガわれた有構造~型【！値】を
— それが~retrofit型であることを指示する "`*^c" を接頭した上で —
対応する~registry~entryに伴わせる。
◎
Then, add a new column, "Structured Type", with the values from Section 2 assigned to the nominated registrations, prefixing each with "*" to indicate that it is a retrofit type.
</li>
	<li>
<p>
`表 5＠#new-fields$ に挙げる各~field名を追加する
— 次も伴わせて
⇒＃
対応する有構造~型,
位置付け “恒久的”,
この文書への参照
◎
Then, add the field names in Table 5, with the corresponding Structured Type as indicated, a status of "permanent" and referring to this document.
</p>

<div>
<table><caption id="new-fields">表 5：
新たな~field
</caption>
<thead><tr>
<th>~field名
<th>有構造~型
</thead><tbody>

<tr><td>`SF-Content-Location^h
<td>`~sf~item$

<tr><td>`SF-Cookie^h
<td>`~sf~list$

<tr><td>`SF-Date^h
<td>`~sf~item$

<tr><td>`SF-ETag^h
<td>`~sf~item$

<tr><td>`SF-Expires^h
<td>`~sf~item$

<tr><td>`SF-If-Match^h
<td>`~sf~list$

<tr><td>`SF-If-Modified-Since^h
<td>`~sf~item$

<tr><td>`SF-If-None-Match^h
<td>`~sf~list$

<tr><td>`SF-If-Unmodified-Since^h
<td>`~sf~item$

<tr><td>`SF-Link^h
<td>`~sf~list$

<tr><td>`SF-Last-Modified^h
<td>`~sf~item$

<tr><td>`SF-Location^h
<td>`~sf~item$

<tr><td>`SF-Referer^h
<td>`~sf~item$

<tr><td>`SF-Set-Cookie^h
<td>`~sf~list$

</tbody></table>

◎
Table 5: New Fields
◎
Field Name｜Structured Type
SF-Content-Location｜Item
SF-Cookie｜List
SF-Date｜Item
SF-ETag｜Item
SF-Expires｜Item
SF-If-Match｜List
SF-If-Modified-Since｜Item
SF-If-None-Match｜List
SF-If-Unmodified-Since｜Item
SF-Link｜List
SF-Last-Modified｜Item
SF-Location｜Item
SF-Referer｜Item
SF-Set-Cookie｜List
</div>

	</li>
	<li>
<p>
`表 6＠#existing-fields$ に挙げる既存の各~registry~entryに対し，
そこに指示された有構造~型を追加する。
◎
Then, add the indicated Structured Type for each existing registry entry listed in Table 6.
</p>

<div>
<table><caption id="existing-fields">表 6：
既存の~field
</caption>
<thead><tr>
<th>~field名
<th>有構造~型

</thead>
<tbody>
<tr><td>`Accept-CH$h
<td>`~sf~list$

<tr><td>`Cache-Status$h
<td>`~sf~list$

<tr><td>`CDN-Cache-Control$h
<td>`~sf辞書$

<tr><td>`Cross-Origin-Embedder-Policy$h
<td>`~sf~item$

<tr><td>`Cross-Origin-Embedder-Policy-Report-Only$h
<td>`~sf~item$

<tr><td>`Cross-Origin-Opener-Policy$h
<td>`~sf~item$

<tr><td>`Cross-Origin-Opener-Policy-Report-Only$h
<td>`~sf~item$

<tr><td>`Origin-Agent-Cluster$h
<td>`~sf~item$

<tr><td>`Priority$h
<td>`~sf辞書$

<tr><td>`Proxy-Status$h
<td>`~sf~list$

</tbody>
</table>

◎
Table 6: Existing Fields 
◎
Field Name｜Structured Type
Accept-CH｜List
Cache-Status｜List
CDN-Cache-Control｜Dictionary
Cross-Origin-Embedder-Policy｜Item
Cross-Origin-Embedder-Policy-Report-Only｜Item
Cross-Origin-Opener-Policy｜Item
Cross-Origin-Opener-Policy-Report-Only｜Item
Origin-Agent-Cluster｜Item
Priority｜Dictionary
Proxy-Status｜List
</div>

	</li>
</ul>

<p>
`表 4＠#cookie-params$ の情報を利用して，
`COOKIES$r により確立された `~cookie属性~registry＠~HTTPcookie#cookie-attribute-registry$cite に新たな列 “有構造~型” を追加する。
◎
Finally, add a new column to the "Cookie Attribute Registry" established by [COOKIES] with the title "Structured Type", using information from Table 4.
</p>

	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">5. ~securityの考慮点</h2>

<p>
`2＠#compatible§は、
既存の~HTTP~fieldのうち［
`STRUCTURED-FIELDS$r にて定義される~algoで構文解析でき, 直列化できるもの
］を識別する。
既存の構文解析器の挙動からの変動は、
悪用-可能かもしれない
— 特に、
`連鎖$内のある実装（例：`中継者$）を標的にすることを攻撃者に許容する場合に。
しかしながら、
すでに配備された構文解析器にも かなりの変動がある
— より長期的には、
単独の構文解析~algoへ向けた収束は，
結果的に~securityの便益が得られる見込みが高い。
◎
Section 2 identifies existing HTTP fields that can be parsed and serialised with the algorithms defined in [STRUCTURED-FIELDS]. Variances from existing parser behavior might be exploitable, particularly if they allow an attacker to target one implementation in a chain (e.g., an intermediary). However, given the considerable variance in parsers already deployed, convergence towards a single parsing algorithm is likely to have a net security benefit in the longer term.
</p>

<p>
`3＠#mapped§ は、
既存の~fieldの代替な表現を定義する。
`下流$にある消費器は，当の`~message$を［
自身が代替な表現を認識するかどうかに応じて異なるように解釈する
］かもしれないので、
実装は，そのような~fieldを`生成する$ことは
— それらの~supportを相手の端点と折衝していない限り —
禁制される。
この仕様は，そのような折衝の仕組みを定義しないが、
そのような定義は，そうすることによる含意を注意深く考慮する必要がある。
◎
Section 3 defines alternative representations of existing fields. Because downstream consumers might interpret the message differently based upon whether they recognise the alternative representation, implementations are prohibited from generating such fields unless they have negotiated support for them with their peer. This specification does not define such a mechanism, but any such definition needs to consider the implications of doing so carefully.
</p>

	</section>
	<section id="date-type">
<h2 title="Appendix A. The Date Structured Type">付録 A. 有構造~型：~sf日時</h2>

<p>
この節は、
新たな有構造~field~data型として，
`~sf日時@
（ `Date^en ）を定義する。
◎
This section defines a new Structured Fields data type, Date.
</p>

<p>
`~sf日時$の~data~modelは、
`~sf整数$に類似する
【~dataとしては，~sf整数と同じだが、直列化-法は異なる】
— それは、［
~UTC 1970年 1月 1日 00:00:00
］からの［
閏秒は除外した（場合によっては負な）秒数
］を表現する。
◎
Dates have a data model that is similar to Integers, representing a (possibly negative) delta in seconds from January 1, 1970 00:00:00 UTC, excluding leap seconds.
</p>

<p>
`~sf日時$用の~ABNFは：
◎
The ABNF for Dates is:
</p>

<pre class="bnf">
`sf-date@p
	= "@" ["-"] 1*15`DIGIT$P
</pre>

<div class="example">
<p>
例えば：
◎
For example:
</p>
<pre class="lang-http">
Example-Date: @1659578233
</pre>
</div>

		<section id="serialising-a-date">
<h3 title="A.1. Serialising a Date">A.1. `~sf日時$の直列化-法</h3>

<p>
所与の
( %入力~整数 )
に対し，［
~HTTP`~field値$に利用するに相応しい~ASCII文字列
］を返す：
◎
Given a Date as input_integer, return an ASCII string suitable for use in an HTTP field value.
</p>
<ol>
	<li>
%出力 ~LET "`@^c"
◎
Let output be "@".
</li>
	<li>
%出力 に次の結果を付加する
⇒
`整数を直列化する$( %入力~整数 ) `STRUCTURED-FIELDS$r
◎
Append to output the result of running Serializing an Integer with input_date (see Section 4.1.4 of [STRUCTURED-FIELDS]).
</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

		</section>
		<section id="parsing-a-date">
<h3 title="A.2. Parsing a Date">A.2. `~sf日時$の構文解析-法</h3>

<p class="trans-note">【
この節にて暗黙的に適用される規約（ %位置↗ 記法など）については、
`STRUCTURED-FIELDS$r `有構造~fieldの構文解析-法＠~STRUCTURED-FIELDS#text-parse§
の~algoを見よ。
】</p>

<p>
%入力~文字列 から`~sf日時$を構文解析して返す：
◎
Given an ASCII string as input_string, return a Date. input_string is modified to remove the parsed value.
</p>
<ol>
	<li>
~IF［
%位置↗ ~NEQ "`@^c"
］
⇒
構文解析を失敗させる
◎
If the first character of input_string is not "@", fail parsing.
</li>
	<li>
%位置 ~INCBY 1
◎
Discard the first character of input_string.
</li>
	<li>
%出力~日時 ~LET %入力~文字列 から`整数または~decimalを構文解析する$
`STRUCTURED-FIELDS$r
◎
Let output_date be the result of running Parsing an Integer or Decimal with input_string (see Section 4.2.4 of [STRUCTURED-FIELDS]).
</li>
	<li>
~IF［
%出力~日時 は`~sf~decimal$である
］
⇒
構文解析を失敗させる
◎
If output_date is a Decimal, fail parsing.
</li>
	<li>
~RET %出力~日時
◎
Return output_date.
</li>
</ol>

		</section>
	</section>
</main></div>
