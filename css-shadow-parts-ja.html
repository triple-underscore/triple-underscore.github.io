<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Shadow Parts</title>
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r':
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'p':
	break;
case 'ps':
	text = ':' + key;
	break;
case 'pe':
	text = '::' + key;
	break;
case 't':
	text = '&lt;' + key + '&gt;';
	href= '#typedef-' + key;
	break;
case 'l':
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'U':
	text = 'U+' + key;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
case 'en':
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
case 'issue':
	text = 'Issue #' + key;
	href="~CSSissue/" + key;
	break;
default:
}


if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Shadow Parts
spec_date:2018-11-08
trans_update:2018-11-11
source_checked:181001
page_state_key:CSS
original_url:https://drafts.csswg.org/css-shadow-parts-1/
spec_status:ED
abbr_url:CSSSHADOWPARTS
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:selector,css
conformance:css
copyright:2018,permissive
trans_1st_pub:2018-10-03


●●class_map
p:property
ps:pseudo
pe:pseudo
css:css
e:element
a:attr
v:value
t:type
U:code-point

●●tag_map
I:code
m:code
p:code
ps:code
pe:code
at:code
t:var
css:code
e:code
a:code
v:code
c:code
em:em
mk:mark
U:span

●●original_id_map


●●words_table


	●内容／構造
DOM:
part:
shadow:
component:::コンポーネント
encapsulation:::カプセル化
host:::ホスト
文書:document::~
子孫:descendant::~
有順序:ordered::~
順序:order::~
木:tree::~:ツリー
部分木:subtree::~:部分ツリー
根:root::~:ルート
構造:structure::~
	構造を持つ何か:structured
構造上の:structural な::~
要素:element::~
入子の:nested::入れ子の
包含-:contain::~
出自の:originating::~
空:empty:~
分離-:separate:~
下位-:sub-:~

内側:inside::~
外側:outside::~
内縁:inner::~
外縁:outer::~
内部:internal::~
内部的:internal::~
閉じた:closed::~
回送-:forward::~
	回送-法:forwarding

	奥深く継承-:letting inheritance push the values down to
	分け隔てる:separating out
	外縁~根:outerRoot
	内縁~根:~innerRoot
	外縁~名:outerName
	内縁~名:innerName
	外縁~名:outerIdent
	内縁~名:innerIdent

	●演算／処理

	●構文
space:
comma:::カンマ
DOMToken:
	COLON
	COMMA
pair:::ペア
token:::トークン
構文:syntax::~
小構文:microsyntax::~
構文解析-:parse::~:パース
構文解析:parsing::~:パース
未解析の:unparsed::未パースの
	で区切られた／区切りの:-separated
符号位置:code point::~
	並び:sequence
収集-:collect::~
名:name::~
名前:name::~
命名-:name::~
文字列:string::~
文字:character::~
位置:position:~
変数:variable:~
入力:input::~
妥当:valid::~

tagname:::タグ名
wild-card:::ワイルドカード

	-:initially
	空~文字列:empty
	~INCBY:Consume the U+003A COLON character.
	-:This skips past any leading delimiters
	~EQ ε:If the end of the input has been reached

	●CSS
CSS:
prop:property::プロパティ
style:::スタイル
	~styleし過ぎる:over-styling
styling:::スタイル付け
stylesheet:style sheet::スタイルシート
theme:::テーマ
疑似要素:pseudo-element::~
疑似類:pseudo-class::疑似クラス
継承-:inherit::~
選択-:select::~
	選択-可能な:selectable
選択子:selector::~:セレクタ
規則:rule::~
結合子:combinator::~


	●仕様
API:
algo:algorithm::アルゴリズム
profile:::プロファイル
不用意:accidental:~
事例:case:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
	より良い:better
アリ:possible:可能
任意の:arbitrary な:~
処理能:performance:~
動機:motivation:~
単純:simple:~
問題:problem:~

	場合によっては:possibly
安全:safe:~
安定的:stable:~
実際:actual:~
将来:future:~
	必要:need:~
情報:information:~
明示的:explicit:~
有用:useful:~
機能性:functionality:~
正確:exact:~
特定の:specific な:~
状況:situation:~
理由:reason:~
	両面:both 〜reason
理論的:theoretical:~
略記:shorthand:~
目的:purpose:~
知識:knowledge:~
簡便:convenient:~
	要約:abstract:~
詳細:details:~
	-:It’s important to
	でなくとも:regardless
関連する:relevant な:~
	類似する:similar な
高価:expensive:~
強力:powerful:~
便益:benefit:~
明白:obvious:~
機会:chance:~
防壁:barrier:~
高処理能:performant:~
一貫する:consistent な:~
elegant:::エレガント
利用性:usability:使い勝手
表層:surface:~

	~~判明した:turned out to be
	選ばれた~chosen
	おかしくする~wrong
	より困難に:harder:~
	ある目的で:purposely
	あきらめる:surrender
	得られる:bring
	馬鹿げている:ridiculous
	悪くする:even worse
	基づく:based
	に加えて:in addition to
	焼き直し:rehash
	おそれ:fear
	かまわない:okay
	現時点:at the moment
	総称される:collectively
	適用され過ぎて:over-applying
	触れずに:leaving〜untouched
	処理能に関係する:performance-related
	とても上手く:very well
	様な:like
	何ら:absolutely zero
	一助:help
	されていようが:no matter
	単に:merely
	残された:this left us with
	ずっと:much more／far more／much
	組み合わせは膨大になる:combinatorial explosion
	-:we
	に対するときと同じに:identically
	同程度に:as〜~as
	微細にわたり:too much of 〜 scrutiny
	元も~~子もない:for its own good
	能力:capable
	すなわち:That is

	●仕様（動詞
作者:author:~
	作者:you
保守-:maintain:~
働く:work する:~
利用者:user:~
制御:control:~
利用事例:use-case:~
取扱う:handle する:取り扱う
定義-:define:~
導入-:introduce:~
序論:introduction:~
影響-:affect:~
意味され:mean され:意図され
意図-:intend:~
抑制-:reduce:~
指定-:specify:~
提供-:offer:~
提案-:propose:~
望む:wish する:~
求めら:want:~
無視-:ignore:~
遣取-:interact:やりとり
見なす:consider する:~
考慮-:consider:~
裁定-:decide:~
要求-:require:~
許容-:allow:~
述べら:describe さ:~
追加的な:additional な:追加の
適用-:apply:~
関係-:relate:~
無為に:defeat:~
広告-:advertise:~
組込みの:built-in:~
公表-:publish:~
複合-:compound:~
力:power:~
落とせ:drop でき:~
拡張:extension:~

	利用-:use:~
	利用:using:~
	利用し易く:usable:~
	利用して:using
	注記:Note
	に注意:note that
	立ち往かない:fall down
	束ねる:bundling
	生き続ける:live
	違え:differently
	にする:making
	されるだけの:happen
	自身の好きなように:to do with as it will
	みなされる:can be thought of

	●未分類（動詞
export:
公開-:expose::~
	公開-法:exposing
取得-:get::~
取得子:getter::~
変更-:change::~
変更:change::~
追加-:add::~
追加:addition::~
付加-:append::~
設定-:set::~
合致-:match::~
除去-:remove::~
除去:removal::~
除外-:exclude::~
表現-:represent:~
計算-:calculate:~
計算-:calculation:~
呈示-:present:~
組合する:combine する:組み合せる
組合わせ:combination:組み合せ
選択的:selective:~
回復:recovery:~
	~error回復:error-recovery
重複-:duplicate:~
対応関係:mapping::対応付け
対応付ける:map する::~
	与え:give
	対応-:correspond
	渡す:pass
	-:confirm
	除-:except


	●未分類
IDL:
map:::マップ
集合:set::~
list:::リスト
entry:::エントリ
key:
値:value::~
属性:attribute::~
文脈:context::~
obj:object::オブジェクト
live:
access:::アクセス
button:::ボタン
custom:::カスタム
error:::エラー
interface:::インタフェース
label:::ラベル
markup:::マークアップ
	-:method
target:
text:::テキスト

局所的:local::~:ローカル
局所:local::~:ローカル
大域:global::~:グローバル
名前空間:namespace::~
頁:page::ページ
色:color::~
見かけ:look:~
	要素:el
	^e:template
	とも称される:also known as
	-:issue
	返す:return
	-:keyed
	^v:red
	`x-panel^e:the panel
	^en:parts
	^en:superglobal
	Shadow DOM
	~~形の:shape


	●指示語
新たな:new:~
特定0の:particular:ある特定の
全部的:full:~
自前の:own:~

	最初の:first
	次の:second
	最終的に:eventually
	1 個の:one
	代わりに:instead
	いくつかの:several
	この:this
	これらの:these
	しかしながら，:however
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:their
	それらを:them
	一定の:certain
	一致:identical

	両者:both
	何か:something
	例えば:for example
	依然として:still
	全体:entire
	各:each
	同じ:same
	多くの:many
	後:after
	決して:never
	異なる:different
	自身:itself
	複数の:multiple
	~alone:
	介:via
	他の:other
	他の場合:otherwise
	のみ:alone
	ただ:just the
	何もかも:everything
	何百もの:hundreds of
	節:section
	結果の:resulting
	以前に:previous
	-:against
	無い:never 〜 anything
	その他:anything else
	-:nothing
	どこか:anywhere
	何個か:a number of
	結果:result


●●words_table1
gt3:&gt;&gt;&gt;

●●link_map

	●IDL
SameObject:~WEBIDL#SameObject
PutForwards:~WEBIDL#PutForwards

I.Element:~DOM4#element
I.DOMTokenList:~DOM4#domtokenlist

m.part:#dom-element-part
m.value:~DOM4#dom-domtokenlist-value


	●css
pe.part():#selectordef-part
ps.hover:~SELECTORS4#hover-pseudo

a.part:#element-attrdef-html-global-part
a.exportparts:##element-attrdef-html-global-exportparts

t.ident:~CSSVAL#typedef-ident


	●用語

~part名~list:#element-part-name-list
~part名~map:#element-part-name-map
~part要素~map:#shadow-root-part-element-map


	●用語（外部
~custom~prop:~CSSVAR#custom-property

~live~profile:~SELECTORS4#live-profile
出自の要素:~SELECTORS4#originating-element
構造上の疑似類:~SELECTORS4#structural-pseudo-classes

map.存在-:~INFRA#map-exists
文字列:~INFRA#string
有順序~map:~INFRA#ordered-map
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append

位置~変数:~INFRA#string-position-variable
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points

~shadow~host:~DOM4#element-shadow-host
~shadow根:~DOM4#concept-shadow-root
~shadow木:~DOM4#concept-shadow-tree
tL.要素:~DOM4#_dtl-element
tL.属性の局所~名:~DOM4#_dtl-localname



●●ref_normative

[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 10 October 2018. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 February 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 

●●
	ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Shadow Parts</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-shadow-parts-1">GitHub Issues</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)
	<a href="mailto:fergal@chromium.org">Fergal Daly</a> (Google)
Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-shadow-parts-1/Overview.bs">GitHub Editor</a>

</script>

</head><body>

<header>
	<hgroup>
<h1 id="title">CSS Shadow Parts</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、 `~shadow~host$上に `part()$pe 疑似要素を定義する。
それは、`~shadow~host^が自身の`~shadow木$から選ばれた要素たちを，~styling目的~用に外側にある頁へ選択的に公開することを許容する。
◎
This specification defines the ::part() pseudo-element on shadow hosts, allowing shadow hosts to selectively expose chosen elements from their shadow tree to the outside page for styling purposes.
</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~shadow~DOMは、頁から何個かの “~component”
— ~markupが成す部分木であって、その詳細は，外側~頁でなく~component自身に限り関連するもの —
に分離することを，作者に許容する。
これは、頁を成す ある~part用に意味された ある~styleが，不用意に適用され過ぎて、頁の異なる~partの見かけをおかしくする機会を抑制する。
しかしながら，この~styling防壁により、頁が~componentと遣取するのも，より困難になる
— 実際にそうするよう`求められた^emときに。
◎
Shadow DOM allows authors to separate their page into "components", subtrees of markup whose details are only relevant to the component itself, not the outside page. This reduces the chance of a style meant for one part of the page accidentally over-applying and making a different part of the page look wrong. However, this styling barrier also makes it harder for a page to interact with its components when it actually wants to do so.
</p>

<p>
この仕様は、 `part()$pe 疑似要素を定義する。
それは、［
`~shadow木$内にある, ある目的で公開された特定の要素を，外側にある頁の文脈から~styleする
］ことを，作者に許容する。
これらの疑似要素は、`~custom~prop$（それは、外側~頁が，自身の好きなように特定0の値（~theme色など）を~componentに渡せるようにする）と組合することにより
— ~encapsulationを保守しつつ，すべての制御をあきらめることなく —
~componentと外側~頁が安全かつ強力な仕方で遣取することを許容する。
◎
This specification defines the ::part() pseudo-element, which allows an author to style specific, purposely exposed elements in a shadow tree from the outside page’s context. In combination with custom properties, which let the outside page pass particular values (such as theme colors) into the component for it to do with as it will, these pseudo-elements allow components and the outside page to interact in safe, powerful ways, maintaining encapsulation without surrendering all control.
</p>

		</section>
		<section id="motivation">
<h3 title="Motivation">1.1. 動機</h3>

<p>
~custom要素の能力が
— 組込みの要素と同程度に —
全部的に有用になるためには、次がアリになるベキである：
要素を成す各~partを外側から~styleすること／
~custom要素の作者が，外側から正確に何を~styleできるか制御すること／
~custom要素が~styling用に安定的な “~API” を呈示すること。
すなわち、~custom要素を成す ある~partを~styleするために利用される選択子は、要素の内部的な詳細についての知識を［
公開する／要求する
］ベキでない。
~custom要素の作者は、選択子には触れずに，要素の内部的な詳細を変更-可能になるベキである。
◎
For custom elements to be fully useful and as capable as built-in elements it should be possible for parts of them to be styled from outside. Exactly what can be styled from outside should be controlled by the element author. Also, it should be possible for a custom element to present a stable "API" for styling. That is, the selector used to style a part of a custom element should not expose or require knowledge of the internal details of the element. The custom element author should be able to change the internal details of the element while leaving the selectors untouched.
</p>

<p>
~shadow木の内側に対する~styling用として以前に提案された `~gt3^css 結合子
【“~shadowを貫く結合子” 】
は、`強力~過ぎて^em~~元も~~子もないことが~~判明した
— それは~componentの内部~構造を微細にわたりに公開し過ぎるため、 `Shadow DOM^cite を利用することで得られる~encapsulationの便益の一部を無為にしていた。
この理由から, および他の処理能に関係する理由から、 `~gt3^css 結合子は最終的に`~live~profile$から除去された。
◎
The previous proposed method for styling inside the shadow tree, the &gt;&gt;&gt; combinator, turned out to be too powerful for its own good; it exposed too much of a component’s internal structure to scrutiny, defeating some of the encapsulation benefits that using Shadow DOM brings. For this, and other performance-related reasons, the &gt;&gt;&gt; combinator was eventually removed from the live profile.
</p>

<p>
唯一残された，~shadow木の中まで~styleする仕方は、`~custom~prop$の利用である：
~componentは、［
一定の`~custom~prop^を利用して，自身の内部を~styleする
］よう広告する
— 外縁~頁は、自身が望む~propを`~shadow~host$上に設定することができ，値を必要な所まで奥深く継承させられる。
これは、多くの単純な~theme法の利用事例には，とても上手く働く。
◎
This left us with using custom properties as the only way to style into a shadow tree: the component would advertise that it uses certain custom properties to style its internals, and the outer page could then set those properties as it wished on the shadow host, letting inheritance push the values down to where they were needed. This works very well for many simple theming use-cases.
</p>

<p>
しかしながら，これでは立ち往かない事例もある。
ある~componentが，自身の~shadow木~内の何かに任意の~stylingを許容したいと望む場合、何百もの`~custom~prop$を定義する他に仕方がない（制御を許容したいと望む~CSS~propごとに 1 個ずつ）
— それは、利用性, 処理能の両面で明白に馬鹿げている。
この状況は、作者が~componentの~styleを `hover$ps の様な疑似類に基づいて違えたいと望む場合，さらに複合される
— ~componentは、利用する`~custom~prop^を各~疑似類~用に重複する必要がある（ `:hover:focus^css の様な各~組合わせごとに必要なので、組み合わせは膨大になる）。
これは、利用性と処理能の問題をさらに悪くする。
◎
However, there are some cases where this falls down. If a component wishes to allow arbitrary styling of something in its shadow tree, the only way to do so is to define hundreds of custom properties (one per CSS property they wish to allow control of), which is obviously ridiculous for both usability and performance reasons. The situation is compounded if authors wish to style the component differently based on pseudo-classes like :hover; the component needs to duplicate the custom properties used for each pseudo-class (and each combination, like :hover:focus, resulting in a combinatorial explosion). This makes the usability and performance problems even worse.
</p>

<p>
`part()$pe は、この事例を ずっと~elegantかつ高処理能に取扱うために導入される。
`~custom~prop$名の中に何もかも束ねるのでなく、機能性は，元々意味された様に選択子と~style規則~構文~内に生き続ける。
これは、~componentの作者にも, 利用者にも，ずっと利用し易くなり、処理能はずっと良くなるベキであり，より良い~encapsulation／~API表層を許容する。
◎
We introduce ::part() to handle this case much more elegantly and performantly. Rather than bundling everything into custom property names, the functionality lives in selectors and style rule syntax, like it’s meant to. This is far more usable for both component authors and component users, should have much better performance, and allows for better encapsulation/API surface.
</p>

<p>
`part()$pe は、`理論的には，新たな力は何ら提供しない^emことに注意。
それは， `~gt3^css 結合子の焼き直しではなく、作者が`~custom~prop$ですでに行える何か用の，単純で, より簡便で, 一貫する構文である。
要素を成すある~part（`~shadow~part~map^）を明示的に “公表して”，単に包含されるだけの下位-~partから分け隔てることは、~encapsulationの一助にもなる
— 作者は、不用意に~styleし過ぎるおそれなしに `part()^pe を利用できるので。
◎
It’s important to note that ::part() offers absolutely zero new theoretical power. It is not a rehash of the &gt;&gt;&gt; combinator, it is simply a more convenient and consistent syntax for something authors can already do with custom properties. By separating out the explicitly "published" parts of an element (the shadow part map from the sub-parts that it merely happens to contain, it also helps with encapsulation, as authors can use ::part() without fear of accidental over-styling.
</p>

	</section>
	<section id="exposing">
<h2 title="Exposing a Shadow Element:">2. ~shadow要素の公開-法</h2>

<p>
`~shadow木$内の要素は、［
`part$a, `exportparts$a
］属性を利用して，木の外側へ
— ~stylesheetによる~styling用に —
~exportできる。
◎
Elements in a shadow tree may be exported for styling by stylesheets outside the tree using the part and exportparts attributes.
</p>

<p>
各~要素は、次のものを持つ：
◎
↓</p>

<dl class="def-list">
	<dt>
`~part名~list@
【 `part$a 属性で拡充される】
◎
Each element has a part name list＼
</dt>
	<dd>
何個かの~tokenからなる`有順序~集合$。
◎
which is an ordered set of tokens.
</dd>

	<dt>
`~part名~map@
【 `exportparts$a 属性で拡充される】
◎
Each element has a part name map＼
</dt>
	<dd>
`有順序~map$
— その各~entryは、`文字列$である~key（この要素の外側にある選択子~向けに公開する~partの名前）を，［
何個かの`文字列$からなる`有順序~集合$
］である値（この要素の内側にある選択-可能な~partの名前）に対応付ける。
◎
which is an ordered map, with keys that are strings (part names to expose to selectors outside this element) and values that are ordered sets of strings (part names that are selectable inside this element).
</dd>
</dl>


<p>
各 `~shadow根$は、［
`文字列$である~keyを，何個かの要素が成す`有順序~集合$である値
］に対応付ける
`~part要素~map@
を持つものとみなされる。
◎
Each shadow root can be thought of as having a part element map with keys that are strings and values that are ordered sets of elements.
</p>

<p>
`~part要素~map$は、この仕様にて~style計算するための~algoの一部としてのみ述べられる
— それを計算することは 高価にもなり得るので
【実装には，実際に必要になるまで~part要素~mapを計算しない裁量の余地がある（次の段落に述べるような変更があっても）】
。
それはまた、~DOMを介して公開されることはない
— 公開すると、閉じた~shadow根の内側にある要素への~accessを許容するので。
◎
The part element map is described only as part of the algorithm for calculating style in this spec. It is not exposed via the DOM, as calculating it may be expensive and exposing it could allow access to elements inside closed shadow roots.
</p>

<p>
`~part要素~map$は、要素の追加や除去, および
~DOM内の要素の［
`~part名~list$, `~part名~map$
］に対する変更により影響される。
◎
Part element maps are affected by the addition and removal of elements and changes to the part name lists and part name maps of elements in the DOM.
</p>

<p>
~shadow根 %外縁~根 の`~part要素~map$を計算するときは：
◎
To calculate the part element map of a shadow root, outerRoot:
</p>

<ol>
	<li>
%外縁~part要素~map ~LET %外縁~根 の`~part要素~map$
◎
↓</li>
	<li>
%外縁~part要素~map を空にする
【この段は、この訳による補完。さもなければ、計算し直す度に~mapは肥大する一方になる。】
</li>
	<li>
<p>
%外縁~根 の中の
~EACH( 【子孫？】要素 %要素 )
に対し：
◎
For each element, el within outerRoot
</p>
		<ol>
			<li>
%要素 の`~part名~list$を成す
~EACH( %名前 )
に対し
⇒
%要素 を %外縁~part要素~map[ %名前 ] に`付加する$set
◎
For each name in el’s part name list, add el to outerRoot’s part element map under the key name.
</li>
			<li>
~IF［
%要素 は`~shadow~host$でない
］
⇒
~CONTINUE
◎
If el is a shadow host itself then＼
</li>
			<li>
%内縁~根 ~LET %要素 が~hostしている~shadow根
◎
let innerRoot be its shadow root:
</li>
			<li>
%内縁~根 の`~part要素~map$を計算する
【前回の計算と同じ結果になることが判っていれば、実装はこの段を省ける。】
◎
Calculate innerRoot’s part element map.
</li>
			<li>
%内縁~part要素~map ~LET %内縁~根 の`~part要素~map$
◎
↓</li>
			<li>
%要素 の`~part名~map$を成す
~EACH( %外縁~名 → %内縁~名たち )
に対し
⇒
%内縁~名たち を成す
~EACH( ~token %内縁~名 )
に対し
⇒
~IF［
%内縁~part要素~map[ %内縁~名 ] ~NEQ ε
］
⇒
%内縁~part要素~map[ %内縁~名 ] を成す
~EACH( 要素 %E )
に対し
⇒
%E を %外縁~part要素~map[ %外縁~名 ] に`付加する$set
◎
For each key, outerName, in el’s part name map and for each token innerName under that key look up innerName in innerRoot’s shadow part element map to get a (possibly empty) set of elements and add these elements to outerRoot’s part element map under outerName
</li>
		</ol>
	</li>
</ol>


<p class="issue">
`~part要素~map$を成す各~entryの値は有順序にする必要はない。
この~~要件は落とせないか？
【`有順序~集合$の定義に注記されているように，実装は順序が観測され得ないならば順序なしとしても扱えるので、この段落~自体も必要ない。】
◎
There is no need for the part element map values to be ordered, can we drop that?
</p>



		<section id="part-attr">
<h3 title="Naming a Shadow Element: the part attribute">2.1. ~shadow要素の命名-法： `part$a 属性</h3>

<p>
~shadow木~内のどの要素にも
`part@a
属性を指定できる。
これは、要素を`~shadow木$の外側に公開するために利用される。
◎
Any element in a shadow tree can have a part attribute. This is used to expose the element outside of the shadow tree.
</p>

<p>
`part$a 属性は、何個かの［
この要素の~part名を表現している~token
］からなる，~space区切りの~listとして構文解析される。
◎
The part attribute is parsed as a space-separated list of tokens representing the part names of this element.
</p>

<p class="note">注記：
同じ~partに複数の名前を与えてもかまわない。
“~part名” は、 `id^a や~tagnameではなく， `class^a に類似するものと見なすベキである。
◎
Note: It’s okay to give a part multiple names. The "part name" should be considered similar to a class, not an id or tagname.
</p>

<pre class="example">&lt;style&gt;
  c-e`::part(textspan)^mk { color: red; }
&lt;/style&gt;

&lt;template id="c-e-template"&gt;
  &lt;span `part="textspan"^mk&gt;<span class="comment">
この~textの色は `red^v になる
◎
This text will be red
</span>&lt;/span&gt;
&lt;/template&gt;
&lt;c-e&gt;&lt;/c-e&gt;
&lt;script&gt;
  /* <span class="comment">
`template^e を，~custom要素 `c-e^e として追加する
◎
Add template as custom element c-e
</span> */
  ...
&lt;/script&gt;
</pre>


		</section>
		<section id="exportparts-attr">
<h3 title="Forwarding a Shadow Element: the exportparts attribute">2.2. ~shadow要素の回送-法： `exportparts$a 属性</h3>

<p>
~shadow木~内のどの要素にも
`exportparts@a
属性を指定できる。
要素は ある`~shadow木$ %~shadow木 内の`~shadow~host$である場合、これは，［
要素が~hostしている`~shadow木$の内側にある~partたちを， %~shadow木 の外側にある規則で~styleする
］のを許容するために利用される（それらが［
%~shadow木 内にある， `part$a 属性で命名された要素
］であったかのように）。
【文書~木~内にある, または~shadow~hostでない要素には、効果はない。】
◎
Any element in a shadow tree can have a exportparts attribute. If the element is a shadow host, this is used to allow styling of parts from hosts inside the shadow tree by rules outside this the shadow tree (as if they were elements in the same tree as the host, named by a part attribute).
</p>

<p>
`exportparts$a 属性は、［
何個かの~part対応関係からなる，~comma区切りの~list
］として構文解析される。
各~part対応関係は、次のいずれかで与えられる：
◎
The exportparts attribute is parsed as a comma-separated list of part mappings. Each part mapping is one of:
</p>

<dl class="switch">
	<dt>
<code class="value">%内縁~名 : %外縁~名</code>
◎
innerIdent : outerIdent
</dt>
	<dd>
これは、要素の`~part名~map$に
«[ %内縁~名 → %外縁~名 ]»
を追加する。
◎
this adds «[ outerIdent → innerIdent ]» to el’s part name map.
</dd>

	<dt>`ident^t</dt>
	<dd>
<code class="value">`ident^t : `ident^t</code>
の略記。
◎
Is shorthand for ident : ident.
</dd>

	<dt>
その他
◎
anything else
</dt>
	<dd>
［
~error回復／将来の互換性
］用にあり、無視される。
◎
Ignored for error-recovery / future compatibility.
</dd>
</dl>


<p class="note">注記：
下位-~partから複数個の名前へ~mapしてもかまわない。
◎
Note: It’s okay to map a sub-part to several names.
</p>

<p class="issue">
"`ident1 : ident2, ident1 : ident3, ...^v"
の略記として
"`ident1 : ident2 ident3 ...^v"
を許容するかどうか裁定する。
（ `2411$issue ）
◎
Decide whether to allow "ident1 : ident2 ident3 ..." as shorthand for "ident1 : ident2, ident1 : ident3, ...". &lt;https://github.com/w3c/csswg-drafts/issues/2411&gt;
</p>


<p class="issue">
~wild-cardによる回送-法
— 例： `exportparts="button-* buttons"^a —
を許容するかどうか裁定する。
下位-~partたちを，回送することなく［
明示的に除外すること, あるいは除外する仕組み
］を考慮する。
（ `2411$issue ）
◎
Decide whether to allow wild-card forwarding, e.g exportparts="button-* buttons". Consider excluding sub-parts that have been explicitly forwarded. Consider a mechanism to exclude sub-parts without forwarding them. &lt;https://github.com/w3c/csswg-drafts/issues/2411&gt;
</p>

<div class="example">

<pre>
&lt;style&gt;
  c-e`::part(textspan)^mk { color: red; }
&lt;/style&gt;

&lt;template id="c-e-outer-template"&gt;
  &lt;c-e-inner `exportparts="innerspan:textspan"^mk&gt;&lt;/c-e-inner&gt;
&lt;/template&gt;

&lt;template id="c-e-inner-template"&gt;
  &lt;span `part="innerspan"^mk&gt;
    <span class="comment">
この~textの `color^p は `red^v になる
— 包含している~shadow~hostは，
`innerspan^v を `textspan^v として文書へ回送し，それは文書~styleに合致するので。
◎
This text will be red because the containing shadow host forwards innerspan to the document as "textspan" and the document style matches it.
</span>
  &lt;/span&gt;
  &lt;span `part="textspan"^mk&gt;
    <span class="comment">
この~textの `color^p は `red^v にならない
— 文書~style内の `textspan^v は、回送されない場合には，内縁~custom要素の内側にある~partには合致し得ないので。
◎
This text will not be red because textspan in the document style cannot match against the part inside the inner custom element if it is not forwarded.
</span>
  &lt;/span&gt;
&lt;/template&gt;

&lt;c-e&gt;&lt;/c-e&gt;
&lt;script&gt;
  /* <span class="comment">
各 `template^e を，~custom要素 `c-e^e, `c-e-inner^e として追加する。
◎
Add template as custom elements c-e-inner, c-e-outer
</span> */
    ...
&lt;/script&gt;
</pre>

</div>



		</section>
	</section>
	<section id="part-theme">
<h2 title="Selecting a Shadow Element: the ::part() pseudo-element">3. ~shadow要素の選択-法： `part()^pe 疑似要素</h2>

<p>
`part()@pe
疑似要素は、
`part$a 属性を介して公開された要素を選択することを，作者に許容する。
その構文は：
◎
The ::part() pseudo-element allows you to select elements that have been exposed via a part attribute. The syntax is:
</p>

<pre class="prod">
::part() = ::part( `ident$t )
</pre>

<p>
`part()$pe 疑似要素は、その`出自の要素$ %~host は`~shadow~host$である場合に限り，次を満たすどの要素にも合致する
⇒
要素 ~IN %~host が~hostしている`~shadow根$の`~part要素~map$[ 指定された `ident$t ]
◎
The ::part() pseudo-element only matches anything when the originating element is a shadow host. If the originating element’s shadow root’s part element map contains the specified &lt;ident&gt;, ::part() matches the element or elements keyed to that &lt;ident&gt;. Otherwise, it matches nothing.
</p>

<div class="example">

<p>
例えば、ある~custom~button（ `id="special-button"^a ）が，~styling用に（ `part="label"^a を介して）公開される `label^l 要素を【その~buttonが~hostしている~shadow木~内に】包含する場合、作者は，
`#special-button::part(label)^css
でそれを選択できる。
◎
For example, if you have a custom button that contains a "label" element that is exposed for styling (via part="label"), you can select it with #the-button::part(label).
</p>
</div>


<p>
~shadow~part用の疑似要素【すなわち `part()^pe 】は、その後に追加的な疑似類もとれる
— `x-button::part(label):hover^css など —
が、局所的な要素~情報ではなく木~情報に基づいて合致するような［
`構造上の疑似類$その他の疑似類
］には，決して合致しない。
◎
The shadow-part pseudo-elements can take additional pseudo-classes after them, such as x-button::part(label):hover, but never match the structural pseudo-classes or any other pseudo-classes that match based on tree information rather than local element information.
</p>

<p>
~shadow~part用の疑似要素は、その後に追加的な疑似要素もとれる
— `x-button::part(label)::before^css など —
が、追加的な~shadow~part用の疑似要素には，決して合致しない。
◎
The shadow-part pseudo-elements also can take additional pseudo-elements after them, such as x-button::part(label)::before, but never match additional shadow-part pseudo-elements.
</p>

<div class="example">

<p>
例えば
`x-panel::part(confirm-button)::part(label)^css
に合致するものは無い。
合致すると，構造上の情報を意図される以上に公開することになるので。
◎
For example, x-panel::part(confirm-button)::part(label) never matches anything. This is because doing so would expose more structural information than is intended.
</p>

<p>
依然として、
`x-panel::theme(label)^css の様な選択子で，入子の~labelを~targetできる。
しかしながら，これは、`x-panel^e 内にある他の~buttonの~labelも選択することになる。
◎
One can still target the nested label with a selector like x-panel::theme(label). However, this will also select the labels of any other buttons in the panel.
</p>

<p>
`x-panel^e の内部的な “confirm” ~buttonが
`part="label =&gt; confirm-label"^a
の様な何かを利用して，~buttonの内部~partたちを `x-panel^e の自前の`~part要素~map$へ回送していた場合、
`x-panel::part(confirm-label)^css の様な選択子は、他のどの~labelも無視して，ただ 1 つの~buttonの~labelを選択することになる。
◎
If the &lt;x-panel&gt;’s internal confirm button had used something like part="label =&gt; confirm-label" to forward the button’s internal parts up into the panel’s own part element map, then a selector like x-panel::part(confirm-label) would select just the one button’s label, ignoring any other labels.
</p>

</div>

	</section>
	<section id="idl">
<h2 title="Extensions to the Element Interface">4. `Element$I ~interfaceに対する拡張</h2>

＊
<pre class="idl">
partial interface `Element$I {
  [`SameObject$, `PutForwards$=`value$m] readonly attribute `DOMTokenList$I `part$m;
};
</pre>

<dl class="idl-def">
	<dt>`part$m</dt>
	<dd>
取得子は、次のようにされた `DOMTokenList$I ~objを返すモノトスル
⇒＃
`要素$tL ~SET 此れ,
`属性の局所~名$tL ~SET `part^l
◎
The part attribute’s getter must return a DOMTokenList object whose associated element is the context object and whose associated attribute’s local name is part.＼
</dd>
	<dd>
この特定0の `DOMTokenList^I ~objを成す~token集合は、要素の `parts^en とも称される。
◎
The token set of this particular DOMTokenList object are also known as the element’s parts.
</dd>
</dl>

<p class="issue">
これを~DOM仕様における `superglobal^en 【すべての名前空間より上位の大域~属性】として定義する。
`exportparts$a を，構造を持つ何かとして［
取得する／設定する
］ための~IDLを定義する。
（ `2414$issue ）
◎
Define this as a superglobal in the DOM spec. Issue(w3c/csswg-drafts#2414): Define IDL for structured setting and getting of `exportparts`. &lt;https://github.com/w3c/csswg-drafts/issues/2414&gt;
</p>

	</section>
	<section id="parsing">
<h2 title="Microsyntaxes for parsing">5. 構文解析~用の小構文</h2>

		<section id="parsing-mapping">
<h3 title="Rules for parsing part mappings">5.1. ~part対応関係を構文解析する規則</h3>

<p>
`妥当な~part対応関係^は、文字 `003A^U `COLON^smb で区切られた~DOMTokenの~pairであって，他の文字（例：~space文字）は含まないものである。
各~DOMTokenは、文字［
`003A^U `COLON^smb ／ `002C^U `COMMA^smb
］を包含してはナラナイ。
◎
A valid part mapping is a pair of DOMTokens separated by a U+003A COLON charater, with no other characters (e.g. no space characters). The DOMTokens must not contain U+003A COLON or U+002C COMMA characters.
</p>

<p class="trans-note">【
~spaceは `0020^U 以外の空白（改行や `TAB^smb ）も含むかどうかは言及されていない。
定義されていない用語~DOMTokenは、明らかに制御~文字なども含むべきでないと思われるが，言及されていない。
】</p>

<p>
~part対応関係を構文解析する規則は、所与の
( 文字列 %入力 )
に対し，次に従う：
◎
The rules for parsing a part mapping are as follows:
• Let input be the string being parsed.
</p>

<ol>
	<li>
%位置 ~LET %位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%入力 内の %位置 から文字 { ~space, `003A^U `COLON^smb } からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are space characters or U+003A COLON characters. This skips past any leading delimiters.
</li>
	<li>
%最初の~token ~LET %入力 内の %位置 から
{ ~space, `003A^U `COLON^smb }
以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not space characters or U+003A COLON characters, and let first token be the result.
</li>
	<li>
~IF［
%最初の~token ~EQ 空~文字列
］
⇒
~RET `~error^i
◎
If first token is empty then return error.
</li>
	<li>
%入力 内の %位置 から~space文字からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are space characters.
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET ~pair( %最初の~token, %最初の~token )
◎
If the end of the input has been reached, return the pair first token, first token
</li>
	<li>
~IF［
%位置↗ ~NEQ `003A^U `COLON^smb
］
⇒
~RET `~error^i
◎
If character at position is not a U+003A COLON character, return error.
</li>
	<li>
%位置 ~INCBY 1
◎
Consume the U+003A COLON character.
</li>
	<li>
%入力 内の %位置 から~spaceからなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are space characters.
</li>
	<li>
%次の~token ~LET %入力 内の %位置 から
{ ~space, `003A^U `COLON^smb }
以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not space characters or U+003A COLON characters. and let second token be the result.
</li>
	<li>
~IF［
%次の~token ~EQ 空~文字列
］
⇒
~RET `~error^i
◎
If second token is empty then return error.
</li>
	<li>
~RET 
~pair( %最初の~token, %次の~token )
◎
Return the pair first token, second token.
</li>
</ol>

		</section>
		<section id="parsing-mapping-list">
<h3 title="Rules for parsing a list of part mappings">5.2. ~part対応関係が成す~listを構文解析する規則</h3>

<p>
`妥当な~part対応関係~list^は、文字 `002C^U `COMMA^smb で区切られた何個かの妥当な~part対応関係からなり，他の文字（例：~space文字）は含まないものである。
◎
A valid list of part mappings is a number of valid part mappings separated by a U+002C COMMA charater, with no other characters (e.g. no space characters).
</p>

<p>
~part対応関係が成す~listを構文解析する規則は、所与の
( 文字列 %入力 )
に対し，次に従う：
◎
The rules for parsing a list of part mappings are as follow:
• Let input be the string being parsed.
</p>

<ol>
	<li>
%位置 ~LET %位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%対応関係~list ~LET 空~list
◎
Let mappings be an initially empty list of pairs of DOMTokens. This list will be the result of this algorithm.
</li>
	<li>
%入力 内の %位置 から
{ ~space, `002C^U `COMMA^smb, `003A^U `COLON^smb }
からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are space characters, U+002C COMMA or U+003A COLON characters. This skips past any leading delimiters.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%未解析の対応関係 ~LET %入力 内の %位置 から
`002C^U `COMMA^smb 以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not U+002C COMMA characters, and let unparsed mapping be the result.
</li>
			<li>
%対応関係 ~LET ~part対応関係を構文解析する規則を利用して %未解析の対応関係 を構文解析した結果
◎
Let mapping be the result of parsing unparsed mapping using the rules for parsing part mappings.
</li>
			<li>
~IF［
%対応関係 ~NEQ `~error^i
］
⇒
%対応関係~list に %対応関係 を付加する
◎
If mapping is an error, continue.
◎
Append mapping to mappings.
</li>
		</ol>
	</li>
	<li>
~RET %対応関係~list
◎
↑↑</li>
</ol>

		</section>
	</section>
</main></div>

