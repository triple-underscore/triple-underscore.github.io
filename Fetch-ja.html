<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Fetch Standard （日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>

code {
	white-space:nowrap;
}

td > pre {
	margin: 0;
}

.settings-parameter,
.frame-type {
	font-family: sans-serif0, sans-serif;
	color: var(--K-color);
}

@supports (grid-template-columns: subgrid) and (display: contents) {

#_credentials-combinations {
	min-width: 30em;
	max-width: 45em;
	grid-template-columns: 8em 1fr 4em;
	tr {
		grid-template-areas:
			"資格証 Allow-Origin 共有"
			"資格証 Allow-Credentials 共有"
			"注記 注記 注記"
		;
		> *:nth-child(1) {
			grid-area: 資格証;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: Allow-Origin;
		}
		> *:nth-child(3) {
			grid-area: Allow-Credentials;
		}
		> *:nth-child(4) {
			grid-area: 共有;
		}
		> *:nth-child(5) {
			grid-area: 注記;
		}
	}
}
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let idl_ifc = '';

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;
let quote = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'h': // http header
	quote = '`';
	break;
case 'hm': // http method
	quote = '`';
	break;
case 'bl': // byte sequence literal
	quote = '`';
	break;
case 'l':
	quote = '"';
	break;
case 'I':
	if(indicator === '@'){
		idl_ifc = key;
	}
	break;
case 'RqI': // RequestInit member
	href = `#dom-requestinit-${key.toLowerCase()}`;
	break;
case 'RsI': // ResponseInit member
	href = `#dom-responseinit-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = '#dom-' + (
		(key === idl_ifc) ? idl_ifc : `${idl_ifc}-${key}`
	).toLowerCase();
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'dir': // CSP directive
	href = `~CSP3#${key}`;
	break;
case 'e':
	text = `&lt;${text}&gt;`;
	break;
case 'X': // byte value
	text = `0x${key}`;
	break;
case 'at':
	text = `@${key}`;
	break;
case 'U':
	text = `U+${text}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
case 'mF': // IDL member (File)
case 'st': // http responce status code
case 'E': // error name
case 'i': // model constants
case 'A': // abstract opration
case 'V': // variables
case 'p': // protocol element
case 'Z': // escape
default: //
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}
return `${quote}${text}${quote}`;

	}
}
// TODO: 各 enum 定数にも id を付与する
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Fetch
spec_date:2024-12-19
trans_update:2025-03-02
source_checked:231107
spec_status:LS
original_url:https://fetch.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:network,http,security,storage
copyright:,whatwg
trans_1st_pub:2013-04-27

●●class_map
e:element
a:attr
E:error
et:event-type
h:header
hm:method
st:status
dir:directive
p:protocol
css:css
at:css
l:literal
bl:literal
X:hex-value
v:value
U:code-point
cn:cp-name
jv:js-value
jt:js-type
jA:abstract
ft:frame-type
sp:settings-parameter

●●tag_map
I:code
m:code
mF:code
et:code
RqI:code
RsI:code
E:code
h:code
hm:code
l:code
bl:code
c:code
at:code
css:code
e:code
a:code
p:var
st:code
dir:code
s:samp
v:span
V:var
i:i
X:span
U:span
cn:span
jv:code
jt:code
jA:span
ft:code
sp:code
cite:cite
em:em
sub:sub

●●original_id_map

dom-headers-iterable:
	forbidden-request-header:forbidden-header-name
	concept-body-consume-body:concept-body-package-data

●●mdn_urls
http-access-control-allow-credentials:HTTP/Headers/Access-Control-Allow-Credentials
http-access-control-allow-headers:HTTP/Headers/Access-Control-Allow-Headers
http-access-control-allow-methods:HTTP/Headers/Access-Control-Allow-Methods
http-access-control-allow-origin:HTTP/Headers/Access-Control-Allow-Origin
http-access-control-expose-headers:HTTP/Headers/Access-Control-Expose-Headers
http-access-control-max-age:HTTP/Headers/Access-Control-Max-Age
http-access-control-request-headers:HTTP/Headers/Access-Control-Request-Headers
http-access-control-request-method:HTTP/Headers/Access-Control-Request-Method
http-origin:HTTP/Headers/Origin
http-x-content-type-options:HTTP/Headers/X-Content-Type-Options
http-cross-origin-resource-policy:HTTP/Headers/Cross-Origin-Resource-Policy

headers:API/Headers
body:API/Body
request:API/Request
requestdestination:API/RequestDestination
response:API/Response
	typedefdef-headersinit:API/HeadersInit
	requestinit:API/RequestInit
	requestmode:API/RequestMode
	requestinfo:API/RequestInfo
	requestcredentials:API/RequestCredentials
	requestcache:API/RequestCache
	requestredirect:API/RequestRedirect
	responseinit:API/ResponseInit
	responsetype:API/ResponseType
	bodyinit:API/BodyInit
	typedefdef-xmlhttprequestbodyinit:API/XMLHttpRequestBodyInit

●●link_map

	●HTTP header/methods
h.Access-Control-Allow-Credentials:#http-access-control-allow-credentials
h.Access-Control-Allow-Headers:#http-access-control-allow-headers
h.Access-Control-Allow-Methods:#http-access-control-allow-methods
h.Access-Control-Allow-Origin:#http-access-control-allow-origin
h.Access-Control-Expose-Headers:#http-access-control-expose-headers
h.Access-Control-Max-Age:#http-access-control-max-age
h.Access-Control-Request-Headers:#http-access-control-request-headers
h.Access-Control-Request-Method:#http-access-control-request-method
h.Origin:#http-origin
h.X-Content-Type-Options:#http-x-content-type-options
h.Cross-Origin-Resource-Policy:#http-cross-origin-resource-policy
h.Sec-Purpose:#http-sec-purpose

h.Accept-Charset:~HTTPsem#field.accept-charset
h.Accept-Encoding:~HTTPsem#field.accept-encoding
h.Accept-Language:~HTTPsem#field.accept-language
h.Accept:~HTTPsem#field.accept
h.Allow:~HTTPsem#field.allow
h.Authorization:~HTTPsem#field.authorization
h.Cache-Control:~HTTPcache#field.cache-control
h.Connection:~HTTPsem#field.connection
h.Content-Disposition:https://httpwg.org/specs/rfc6266.html#header.field.definition
h.Content-Encoding:~HTTPsem#field.content-encoding
h.Content-Language:~HTTPsem#field.content-language
h.Content-Length:~HTTPsem#field.content-length
h.Content-Location:~HTTPsem#field.content-location
h.Content-Range:~HTTPsem#field.content-range
h.Content-Type:~HTTPsem#field.content-type
h.Date:~HTTPinfra#field.date
h.DNT:~TR/tracking-dnt/#dnt-header-field
	h.DNT:https://datatracker.ietf.org/doc/html/draft-mayer-do-not-track

h.ETag:~HTTPsem#field.etag
h.Expect:~HTTPsem#field.expect
h.Expires:~HTTPcache#field.expires
h.Host:~HTTPsem#field.host
h.If-Match:~HTTPsem#field.if-match
h.If-Modified-Since:~HTTPsem#field.if-modified-since
h.If-None-Match:~HTTPsem#field.if-none-match
h.If-Range:~HTTPsem#field.if-range
h.If-Unmodified-Since:~HTTPsem#field.if-unmodified-since
h.Keep-Alive:~HTTPv1#compatibility.with.http.1.0.persistent.connections
h.Last-Modified:~HTTPsem#field.last-modified
h.Location:~HTTPsem#field.location
h.Pragma:~HTTPcache#field.pragma
h.Proxy-Authenticate:~HTTPsem#field.proxy-authenticate
h.Range:~HTTPsem#field.range
h.Referer:~HTTPsem#field.referer
h.Sec-Fetch-Dest:~FETCH-METADATA#http-headerdef-sec-fetch-dest
h.Server-Timing:~SERVER-TIMING#dfn-server-timing-header-field
h.TE:~HTTPsem#field.te
h.Trailer:~HTTPinfra#field.trailer
h.Transfer-Encoding:~HTTPv1#field.transfer-encoding
h.Upgrade:~HTTPsem#field.upgrade
h.User-Agent:~HTTPsem#field.user-agent
h.Vary:~HTTPsem#field.vary
h.Via:~HTTPsem#field.via
h.WWW-Authenticate:~HTTPsem#field.www-authenticate

h.Link:~HTTPweblink#field.link
h.Cookie:~HTTPcookie#sane-cookie
h.Set-Cookie:~HTTPcookie#sane-set-cookie
h.Timing-Allow-Origin:~RESOURCE-TIMING#dfn-timing-allow-origin

Content-Security-Policy:~CSP3#header-content-security-policy
Strict-Transport-Security:~RFCx/rfc6797#section-6.1

	●mehods
hm.CONNECT:~HTTPsem#CONNECT
hm.DELETE:~HTTPsem#DELETE
hm.GET:~HTTPsem#GET
hm.HEAD:~HTTPsem#HEAD
hm.OPTIONS:~HTTPsem#OPTIONS
hm.POST:~HTTPsem#POST
hm.PUT:~HTTPsem#PUT
hm.TRACE:~HTTPsem#TRACE
hm.TRACK:#biblio-httpverbsec2

p.field-name:~HTTPinfra#p.field-name
p.field-value:~HTTPinfra#p.field-value
p.method:~HTTPsem#p.method
p.delta-seconds:~HTTPcache#p.delta-seconds
p.reason-phrase:~HTTPv1#p.reason-phrase
p.status-code:~HTTPv1#p.status-code
	p.wildcard
	p.field-name-or-wildcard
	p.origin-or-null

	●status code
st.101:~HTTPsem#status.101
st.103:~HTTPearlyhints#early-hints
st.200:~HTTPsem#status.200
st.204:~HTTPsem#status.204
st.205:~HTTPsem#status.205
st.206:~HTTPsem#status.206
st.3xx:~HTTPsem#status.3xx
st.301:~HTTPsem#status.301
st.302:~HTTPsem#status.302
st.303:~HTTPsem#status.303
st.304:~HTTPsem#status.304
st.307:~HTTPsem#status.307
st.308:~HTTPsem#status.308
st.401:~HTTPsem#status.401
st.403:~HTTPsem#status.403
st.407:~HTTPsem#status.407
st.421:~HTTPsem#status.421

	●HTML 要素
e.head:~HEmetadata#the-head-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element
e.script:~HEscripting#the-script-element
e.a:~HEtextlevel#the-a-element
e.picture:~HEimages#the-picture-element
e.audio:~HEmedia#the-audio-element
e.embed:~HEembed#the-embed-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element
e.object:~HEembed#the-object-element
e.source:~HEimages#the-source-element
e.track:~HEtrack#the-track-element
e.video:~HEmedia#the-video-element
e.frame:~HTMLobs#frame
e.image:~SVGembedded#elementdef-image


	●idl interface／type

Exposed:~WEBIDLjs#Exposed
NewObject:~WEBIDLjs#NewObject
SameObject:~WEBIDLjs#SameObject

E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.AbortError:~WEBIDL#aborterror
E.TypeError:~WEBIDL#exceptiondef-typeerror
E.SyntaxError:~WEBIDL#syntaxerror

undefined:~WEBIDL#idl-undefined
boolean:~WEBIDL#idl-boolean
unsigned short:~WEBIDL#idl-unsigned-short
DOMString:~WEBIDL#idl-DOMString
USVString:~WEBIDL#idl-USVString
ByteString:~WEBIDL#idl-ByteString
Promise:~WEBIDL#idl-promise
sequence:~WEBIDL#idl-sequence
record:~WEBIDL#idl-record
any:~WEBIDL#idl-any

I.BufferSource:~WEBIDL#BufferSource
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.Uint8Array:~WEBIDL#idl-Uint8Array
	I.DOMException:~WEBIDL#idl-DOMException

I.Body:#body
I.BodyInit:#bodyinit
I.Headers:#headers
I.HeadersInit:#typedefdef-headersinit
I.ReadableStream:~STREAMS#readablestream
I.ReadableStreamDefaultReader:~STREAMS#readablestreamdefaultreader
I.TransformStream:~STREAMS#transformstream
I.Request:#request
I.RequestCache:#requestcache
I.RequestCredentials:#requestcredentials
I.RequestDestination:#requestdestination
I.RequestDuplex:#enumdef-requestduplex
I.RequestPriority:#enumdef-requestpriority
I.RequestInfo:#requestinfo
I.RequestInit:#requestinit
I.RequestMode:#requestmode
I.RequestRedirect:#requestredirect
I.Response:#response
I.ResponseInit:#responseinit
I.ResponseType:#responsetype
I.XMLHttpRequestBodyInit:#typedefdef-xmlhttprequestbodyinit

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.AbortSignal:~DOM4#abortsignal
I.Blob:~FILEAPI#blob
I.File:~FILEAPI#file
I.FormData:~XHR#formdata
I.XMLHttpRequest:~XHR#xmlhttprequest
I.XMLHttpRequestUpload:~XHR#xmlhttprequestupload
I.WebSocket:~WEBSOCKET#websocket
I.URLSearchParams:~URL1#urlsearchparams
I.Document:~DOM4#document
I.Window:~WINDOW#window
I.Worker:~WORKERS#worker
I.SharedWorker:~WORKERS#sharedworker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.ServiceWorkerGlobalScope:~SW1#serviceworkerglobalscope
I.ReferrerPolicy:~REFERRER-POLICY#enumdef-referrerpolicy
I.EventSource:~HTMLsse#eventsource


I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope
I.URL:~URL1#url

	■Headers
m.new Headers:#dom-headers
	m.delete:#dom-headers-delete
	m.get:#dom-headers-get
	m.getSetCookie:#dom-headers-getsetcookie
	m.has:#dom-headers-has
	m.set:#dom-headers-set
	m.value:#dom-headers-value
	m.iterable:#dom-headers-iterable

	■Body
	m.body:#dom-body-body
	m.bodyUsed:#dom-body-bodyused
	m.arrayBuffer:#dom-body-arraybuffer
	m.blob:#dom-body-blob
	m.bytes:#dom-body-bytes
	m.formData:#dom-body-formdata
	m.json:#dom-body-json
	m.text:#dom-body-text

	■BodyInit

	■Request
m.new Request:#dom-request
	m.method:#dom-request-method
	m.url:#dom-request-url
	m.headers:#dom-request-headers
	m.destination:#dom-request-destination
	m.referrer:#dom-request-referrer
	m.referrerPolicy:#dom-request-referrerpolicy
	m.mode:#dom-request-mode
	m.credentials:#dom-request-credentials
	m.cache:#dom-request-cache
	m.redirect:#dom-request-redirect
	m.integrity:#dom-request-integrity
	m.keepalive:#dom-request-keepalive
	m.isReloadNavigation:#dom-request-isreloadnavigation
	m.isHistoryNavigation:#dom-request-ishistorynavigation
	m.signal:#dom-request-signal
	m.duplex:#dom-request-duplex
	m.clone:#dom-request-clone

	■RequestInfo

	■RequestInit
	m.method:#dom-requestinit-method
	m.headers:#dom-requestinit-headers
	m.body:#dom-requestinit-body
	m.referrer:#dom-requestinit-referrer
	m.referrerPolicy:#dom-requestinit-referrerpolicy
	m.mode:#dom-requestinit-mode
	m.credentials:#dom-requestinit-credentials
	m.cache:#dom-requestinit-cache
	m.redirect:#dom-requestinit-redirect
	m.integrity:#dom-requestinit-integrity
	m.keepalive:#dom-requestinit-keepalive
	m.signal:#dom-requestinit-signal
	m.window:#dom-requestinit-window

	■RequestDestination
	m."":#dom-requestdestination
	m.audio:#dom-requestdestination-audio
	m.audioworklet:#dom-requestdestination-audioworklet
	m.document:#dom-requestdestination-document
	m.embed:#dom-requestdestination-embed
	m.font:#dom-requestdestination-font
	m.image:#dom-requestdestination-image
	m.manifest:#dom-requestdestination-manifest
	m.object:#dom-requestdestination-object
	m.paintworklet:#dom-requestdestination-paintworklet
	m.report:#dom-requestdestination-report
	m.script:#dom-requestdestination-script
	m.sharedworker:#dom-requestdestination-sharedworker
	m.style:#dom-requestdestination-style
	m.track:#dom-requestdestination-track
	m.video:#dom-requestdestination-video
	m.worker:#dom-requestdestination-worker
	m.xslt:#dom-requestdestination-xslt

	■RequestMode
	m.navigate:#dom-requestmode-navigate
	m.same-origin:#dom-requestmode-same-origin
	m.no-cors:#dom-requestmode-no-cors
	m.cors:#dom-requestmode-cors

	■RequestCredentials
	m.omit:#dom-requestcredentials-omit
	m.same-origin:#dom-requestcredentials-same-origin
	m.include:#dom-requestcredentials-include

	■RequestCache
	m.default:#dom-requestcache-default
	m.no-store:#dom-requestcache-no-store
	m.reload:#dom-requestcache-reload
	m.no-cache:#dom-requestcache-no-cache
	m.force-cache:#dom-requestcache-force-cache
	m.only-if-cached:#dom-requestcache-only-if-cached

	■RequestRedirect
	m.follow:#dom-requestredirect-follow
	m.error:#dom-requestredirect-error
	m.manual:#dom-requestredirect-manual

	■Response
m.new Response:#dom-response
	m.error:#dom-response-error
	m.redirect:#dom-response-redirect
	m.status:#dom-response-status
	m.json:#dom-response-json
	m.type:#dom-response-type
	m.url:#dom-response-url
	m.redirected:#dom-response-redirected
	m.status:#dom-response-status
	m.ok:#dom-response-ok
	m.statusText:#dom-response-statustext
	m.headers:#dom-response-headers
	m.clone:#dom-response-clone

	■ResponseInit
	m.status:#dom-responseinit-status
	m.statusText:#dom-responseinit-statustext
	m.headers:#dom-responseinit-headers

	■ResponseType
	m.basic:#dom-responsetype-basic
	m.cors:#dom-responsetype-cors
	m.default:#dom-responsetype-default
	m.error:#dom-responsetype-error
	m.opaque:#dom-responsetype-opaque
	m.opaqueredirect:#dom-responsetype-opaqueredirect

m.fetch:#dom-global-fetch
m.response.ok:#dom-response-ok
m.navigator.sendBeacon:~BEACON#sec-sendBeacon-method
m.self.importScripts:~WORKERS#dom-workerglobalscope-importscripts
m.navigator.serviceWorker.register:~SW1#dom-serviceworkercontainer-register

mF.size:~FILEAPI#dfn-size
mF.type:~FILEAPI#dfn-type
mF.name:~FILEAPI#dfn-name

et.fetch:~SW1#service-worker-global-scope-fetch-event

at.font-face:~CSSFONT#font-face-rule
at.import:~CASCADE#at-ruledef-import

	●URL
~HTTP_S~scheme:#http-scheme
~fetch~scheme:#fetch-scheme
局所~scheme:#local-scheme
局所的:#is-local
i.~keepalive:#keepalive

	●message 構成子
認証~entry:#authentication-entry
~proxy認証~entry:#proxy-authentication-entry

~HTTP~tab-or-space:#http-tab-or-space
~HTTP~tab-or-space~byte:#http-tab-or-space-byte
~HTTP空白:#http-whitespace
~HTTP空白~byte:#http-whitespace-byte
~HTTP改行~byte:#http-newline-byte
資格証:#credentials

~ABNF:#abnf

	●~header~list
~header~list:#concept-header-list
~headerを付加する:#concept-header-list-append
~headerを削除する:#concept-header-list-delete
~headerを設定する:#concept-header-list-set
有構造~field値を取得する:#concept-header-list-get-structured-header
有構造~field値を設定する:#concept-header-list-set-structured-header
~headerを結合する:#concept-header-list-combine
~header~listを~sortして結合する:#concept-header-list-sort-and-combine
~header名たちを小文字~化して~sortした集合に変換する:#convert-header-names-to-a-sorted-lowercase-set

~header~listから値を取得する:#concept-header-list-get
~header~listから値を抽出する:#extract-header-list-values
~header~listから値を取得して復号して分割する:#concept-header-list-get-decode-split
~header~listから~MIME型を抽出する:#concept-header-extract-mime-type
~header~listから長さを抽出する:#header-list-extract-a-length
~header値を復号して分割する:#header-value-get-decode-and-split

要請~Origin~headerを付加する:#append-a-request-origin-header

	●~header
~header:#concept-header
~header名:#header-name
~header値:#header-value
名前に持つ~header:#_headers-of-name
hd.包含する:#header-list-contains
hd.名前:#concept-header-name
hd.値:#concept-header-value
値を正規化する:#concept-header-value-normalize
~headerから値を抽出する:#extract-header-values
値を抽出-:#extract-header-values
~HTTP引用符付き文字列を収集する:#collect-an-http-quoted-string

~CORS安全とされる要請~header:#cors-safelisted-request-header
~CORS安全でない要請~header名たち:#cors-unsafe-request-header-names
~CORS安全でない要請~header~byte:#cors-unsafe-request-header-byte
~CORSなしで安全とされる要請~header名:#no-cors-safelisted-request-header-name
~CORSなしで安全とされる要請~header:#no-cors-safelisted-request-header
~CORS非~wildcard要請~header名:#cors-non-wildcard-request-header-name
禁止~要請~header:#forbidden-request-header
禁止~応答~header名:#forbidden-response-header-name
要請~本体~header名:#request-body-header-name
~CORS安全とされる応答~header名:#cors-safelisted-response-header-name
特権的~CORSなし要請~header名:#privileged-no-cors-request-header-name

既定の User-Agent 値:#default-user-agent-value
文書 Accept ~header値:#document-accept-header-value


	●method
~method:#concept-method
~methodを正規化する:#concept-method-normalize
md.正規化-:#concept-method-normalize
禁止~method:#forbidden-method
~CORS安全とされる~method:#cors-safelisted-method

	●status
状態s:#concept-status
~null本体~状態s:#null-body-status
~ok状態s:#ok-status
~redirect状態s:#redirect-status

	●本体
本体:#concept-body
bd.長さ:#concept-body-total-bytes
bd.~source:#concept-body-source
bd.~stream:#concept-body-stream
本体を~cloneする:#concept-body-clone
本体と型:#body-with-type
bwT.本体:#body-with-type-body
bwT.型:#body-with-type-type

~byte列を本体として取得する:#byte-sequence-as-a-body
本体を全部的に読取る:#body-fully-read
本体を増分的に読取る:#body-incrementally-read
本体を増分的に読取る~loop:#incrementally-read-loop

	●要請
要請:#concept-request
rq.~method:#concept-request-method
rq.~URL:#concept-request-url
rq.局所~URLに限るか:#local-urls-only-flag
rq.~header~list:#concept-request-header-list
rq.安全でない要請か:#unsafe-request-flag
rq.本体:#concept-request-body
rq.~client:#concept-request-client
rq.予約-済み~client:#concept-request-reserved-client
rq.置換する~client~ID:#concept-request-replaces-client-id
rq.~window:#concept-request-window
rq.~keepaliveか:#request-keepalive-flag
rq.~sw~mode:#request-service-workers-mode
rq.起動元~種別:#request-initiator-type
rq.起動元:#concept-request-initiator
rq.行先:#concept-request-destination
rq.優先度:#request-priority
rq.内部的な優先度:#request-internal-priority
rq.生成元:#concept-request-origin
rq.施策~容器:#concept-request-policy-container
rq.~referrer:#concept-request-referrer
rq.~referrer施策:#concept-request-referrer-policy
rq.~mode:#concept-request-mode
rq.~CORS予行を利用するか:#use-cors-preflight-flag
rq.資格証~mode:#concept-request-credentials-mode
rq.~URL資格証を利用するか:#concept-request-use-url-credentials-flag
rq.~cache~mode:#concept-request-cache-mode
rq.~redirect~mode:#concept-request-redirect-mode
rq.完全性~metadata:#concept-request-integrity-metadata
rq.暗号用~nonce~metadata:#concept-request-nonce-metadata
rq.構文解析器~metadata:#concept-request-parser-metadata
rq.再読込み~naviか:#concept-request-reload-navigation-flag
rq.履歴~naviか:#concept-request-history-navigation-flag
rq.利用者が作動化したか:#request-user-activation
rq.具現化を阻んでいるか:#request-render-blocking
rq.~URL~list:#concept-request-url-list
rq.現在の~URL:#concept-request-current-url
rq.~redirect回数:#concept-request-redirect-count
rq.応答~tainting:#concept-request-response-tainting
rq.~no-cache時には~cache制御~headerを改変しないか:#no-cache-prevent-cache-control
rq.済んだか:#done-flag
rq.計時許容に失敗したか:#timing-allow-failed

要請の生成元は~taintされたか？:#concept-request-tainted-origin
要請の生成元を直列化する:#serializing-a-request-origin
要請の生成元を~byte直列化する:#byte-serializing-a-request-origin
応答~URLを報告-用に直列化する:#serialize-a-response-url-for-reporting
非同一-生成元~資源~施策~内部~検査:#cross-origin-resource-policy-internal-check
非同一-生成元~埋込元~施策~CORP違反~報告を~queueする:#queue-a-cross-origin-embedder-policy-corp-violation-report

要請を~cloneする:#concept-request-clone
~scriptに類する:#request-destination-script-like
範囲~headerを追加する:#concept-request-add-range-header
単純な範囲~header値を構文解析する:#simple-range-header-value
内容~範囲を築く:#build-a-content-range

下位資源~要請:#subresource-request
非~下位資源~要請:#non-subresource-request
~navi要請:#navigation-request

~Cross-Origin-Embedder-Policyは資格証を許容するか？:#cross-origin-embedder-policy-allows-credentials

	●応答
応答:#concept-response
rs.種別:#concept-response-type
rs.中止されたか:#concept-response-aborted
rs.~URL:#concept-response-url
rs.~URL~list:#concept-response-url-list
rs.状態s:#concept-response-status
rs.状態s~message:#concept-response-status-message
rs.~header~list:#concept-response-header-list
rs.本体:#concept-response-body
rs.~cache状態:#concept-response-cache-state
rs.~CORSに公開される~header名~list:#concept-response-cors-exposed-header-name-list
rs.範囲が要請されたか:#concept-response-range-requested-flag
rs.要請は資格証を含むか:#response-request-includes-credentials
rs.計時許容に合格したか:#concept-response-timing-allow-passed
rs.本体~報:#concept-response-body-info
rs.~sw計時~報:#response-service-worker-timing-info
rs.非同一-生成元~redirectはあるか:#response-has-cross-origin-redirects

応答の~Location~URLを得る:#concept-response-location-url

応答を~cloneする:#concept-response-clone

~network~error:#concept-network-error
中止~network~error:#concept-aborted-network-error
適切な~network~error:#appropriate-network-error

絞込み応答:#concept-filtered-response
不透明~redirect絞込み応答:#concept-filtered-response-opaque-redirect
内部~応答:#concept-internal-response
基本~絞込み応答:#concept-filtered-response-basic
~CORS絞込み応答:#concept-filtered-response-cors
不透明な絞込み応答:#concept-filtered-response-opaque
新鮮な応答:#concept-fresh-response
非新鮮な応答:#concept-stale-response
~stale-while-revalidate応答:#concept-stale-while-revalidate-response

	●group／接続／port／区分

~fetch~group:#concept-fetch-group
~fetch記録:#concept-fetch-record
fR.要請:#concept-fetch-record-request
fR.制御器:#concept-fetch-record-fetch
~fetch~groupを終了する:#concept-fetch-group-terminate

接続~pool:#concept-connection-pool
接続を得する:#concept-connection-obtain
接続:#concept-connection
cN.~key:#connection-key
cN.生成元:#connection-origin
cN.資格証を伴うか:#connection-credentials
新たな接続~用の設定:#new-connection-setting

~network区分~key:#network-partition-key
~network区分~keyを決定する:#determine-the-network-partition-key
要請の~network区分~keyを決定する:#request-determine-the-network-partition-key
~HTTP~cache区分を決定する:#determine-the-http-cache-partition
不良~port:#bad-port
要請の~fetchingは，不良~portに因り阻止されるべきか？:#block-bad-port

生成元を解決-:#resolve-an-origin
生成元を解決する:#resolve-an-origin
接続を作成する:#create-a-connection

	●計時
接続~計時~報:#connection-timing-info

計時~報:#concept-connection-timing-info
cT.接続~開始~時刻:#connection-timing-info-connection-start-time
cT.~domain検索~開始~時刻:#connection-timing-info-domain-lookup-start-time
cT.~domain検索~終了~時刻:#connection-timing-info-domain-lookup-end-time
cT.接続~終了~時刻:#connection-timing-info-connection-end-time
cT.~secure接続~開始~時刻:#connection-timing-info-secure-connection-start-time
cT.折衝した~ALPN~protocol~ID:#connection-timing-info-alpn-negotiated-protocol
cT.~ALPNで折衝した~protocol:#connection-timing-info-alpn-negotiated-protocol

不透明な計時~報を作成する:#create-an-opaque-timing-info
全部的な計時~報を抽出する:#extract-full-timing-info
次回の手動~redirect手続きを処理する:#fetch-controller-process-the-next-manual-redirect

~fetch計時~報:#fetch-timing-info
fT.開始~時刻:#fetch-timing-info-start-time
fT.~redirect後からの開始~時刻:#fetch-timing-info-post-redirect-start-time
fT.終了~時刻:#fetch-timing-info-end-time
fT.最終-~sw開始~時刻:#fetch-timing-info-final-service-worker-start-time
fT.~redirect終了~時刻:#fetch-timing-info-redirect-end-time
fT.~redirect開始~時刻:#fetch-timing-info-redirect-start-time
fT.最終-接続~計時~報:#fetch-timing-info-final-connection-timing-info
fT.最終-~network要請~開始~時刻:#fetch-timing-info-final-network-request-start-time
fT.最初の非最終-~network応答~開始~時刻:#fetch-timing-info-first-interim-network-response-start-time
fT.最終-~network応答~開始~時刻:#fetch-timing-info-final-network-response-start-time
fT.~server計時~header群:#fetch-timing-info-server-timing-headers
fT.具現化を阻んでいるか:#fetch-timing-info-render-blocking

応答~本体~報:#response-body-info
fT.符号化された~size:#fetch-timing-info-encoded-body-size
fT.復号した~size:#fetch-timing-info-decoded-body-size
fT.内容~型:#response-body-info-content-type

計時を報告する:#finalize-and-report-timing
接続~計時~報を記録する:#record-connection-timing-info
接続~計時~報を切詰めて粗化する:#clamp-and-coarsen-connection-timing-info

	●fetch処理／予行／cache／CORS

~fetch:#concept-fetch
~fetchする:#concept-fetch
~fetching:#concept-fetch
休止-:#concept-fetch-suspend
再開-:#concept-fetch-resume

~fetch制御器:#fetch-controller
fC.状態:#fetch-controller-state
fC.全部的な計時~報:#fetch-controller-full-timing-info
fC.計時を報告する手続き:#fetch-controller-report-timing-steps
fC.次回の手動~redirect手続き:#fetch-controller-next-manual-redirect-steps
~fetchを中止する:#fetch-controller-abort
~fetchを終了する:#fetch-controller-terminate
終了-:#fetch-controller-terminate
直列化された中止-事由:#fetch-controller-serialized-abort-reason
直列化された中止-事由を逆直列化する:#deserialize-a-serialized-abort-reason

~fetch~taskを~queueする:#queue-a-fetch-task

~fetch~params:#fetch-params
fP.要請:#fetch-params-request
fP.~taskの行先:#fetch-params-task-destination
fP.要請の本体~chunk長さの処理n:#fetch-params-process-request-body
fP.要請の本体~終了~時の処理n:#fetch-params-process-request-end-of-body
fP.応答の早期~hintの処理n:#fetch-params-process-early-hints-response
fP.応答の処理n:#fetch-params-process-response
fP.応答の本体~終了~時の処理n:#fetch-params-process-response-end-of-body
fP.応答の本体を消費する処理n:#fetch-params-process-response-consume-body
fP.非同一-生成元~能力は隔離されるか:#fetch-params-cross-origin-isolated-capability
fP.計時~報:#fetch-params-timing-info
fP.制御器:#fetch-params-controller
fP.中止された:#fetch-params-aborted
fP.取消された:#fetch-params-canceled
fP.~preloadされる応答の候補:#fetch-params-preloaded-response-candidate

~main~fetch:#concept-main-fetch
~scheme~fetch:#concept-scheme-fetch
~HTTP~fetch:#concept-http-fetch
~HTTP~redirect~fetch:#concept-http-redirect-fetch
~HTTP~network-or-cache~fetch:#concept-http-network-or-cache-fetch
~HTTP~network~fetch:#concept-http-network-fetch
~CORS予行~fetch:#cors-preflight-fetch-0
~fetch応答を引渡す:#fetch-finale
要請~環境を決定する:#request-determine-the-environment
~clientから要請を拡充する:#populate-request-from-client

V.要請の本体~chunk長さの処理n:#process-request-body
V.要請の本体~終了~時の処理n:#process-request-end-of-body
V.応答の早期~hintの処理n:#fetch-processearlyhintsresponse
V.応答の処理n:#process-response
V.応答の本体~終了~時の処理n:#fetch-processresponseendofbody
V.応答の本体を消費する処理n:#process-response-end-of-body
V.並列~queueを利用するか:#fetch-useparallelqueue

i.要請の本体~chunk長さの処理n:#process-request-body
i.要請の本体~終了~時の処理n:#process-request-end-of-body
i.応答の早期~hintの処理n:#fetch-processearlyhintsresponse
i.応答の処理n:#process-response
i.応答の本体~終了~時の処理n:#fetch-processresponseendofbody
i.応答の本体を消費する処理n:#process-response-end-of-body
i.並列~queueを利用するか:#fetch-useparallelqueue
i.不依拠-可能を要求するか:#obtain-a-connection-requireunreliable
i.~HTTP3に限るか:#obtain-a-connection-http3only

内容~符号法sを取扱う:#handle-content-codings

	// cache
~CORS予行~cache:#concept-cache
~cache~entry:#cache-entry
~cache~entryを~clearする:#concept-cache-clear
新たな~cache~entryを作成する:#concept-cache-create-entry
~cache合致する:#concept-cache-match
~methodも合致している~cache~entry:#concept-cache-match-method
~header名も合致している~cache~entry:#concept-cache-match-header

cc.~key:#concept-cache-key
cc.~byte直列化した生成元:#concept-cache-origin
cc.~URL:#concept-cache-url
cc.資格証の有無:#concept-cache-credentials
cc.寿命:#concept-cache-max-age
cc.~header名:#concept-cache-header-name
cc.~method:#concept-cache-method

	●CORS／他

~CORS検査:#concept-cors-check
~CORS非同一-生成元:#cors-cross-origin
~CORS~protocol:#cors-protocol
~CORS同一-生成元:#cors-same-origin
~CORS要請:#cors-request
~CORS予行~要請:#cors-preflight-request

非同一-生成元~資源~施策~検査:#cross-origin-resource-policy-check
~TAO検査:#concept-tao-check

整数を直列化する:#serialize-an-integer

行先の素:#concept-potential-destination
行先に翻訳する:#concept-potential-destination-translate

~data_URL処理器:#data-url-processor
~data_URL構造体:#data-url-struct
dU.本体:#data-url-struct-body
dU.~MIME型:#data-url-struct-mime-type

~HTTP~redirectの不可分な取扱い:#atomic-http-redirect-handling
応答は~metadata~listに合致するか？:~SRI1#does-response-match-metadatalist
~nosniffかどうか決定する:#determine-nosniff
~HTTP引用符付き文字列を収集する:#collect-an-http-quoted-string

旧来~用に符号化法を抽出する:#legacy-extract-an-encoding

	●Stream

c.body.getReader():~STREAMS#rs-get-reader

~chunk:~STREAMS#chunk
読取n要請:~STREAMS#read-request
rR.~chunk手続き:~STREAMS#read-request-chunk-steps
rR.~close手続き:~STREAMS#read-request-close-steps
rR.~error手続き:~STREAMS#read-request-error-steps
RS.~byte読取り~support付きで設定しておく:~STREAMS#readablestream-set-up-with-byte-reading-support
	取消~algo:~STREAMS#readablestream-set-up-cancelalgorithm
	~pull~algo:~STREAMS#readablestream-set-up-pullalgorithm
RS.読取器を取得する:~STREAMS#readablestream-get-a-reader
RS.~proxyを作成する:~STREAMS#readablestream-create-a-proxy
RS.~byte列から~pullする:~STREAMS#readablestream-pull-from-bytes
RS.~chunkを~enqueueする:~STREAMS#readablestream-enqueue
RS.~closeする:~STREAMS#readablestream-close
RS.~errorにする:~STREAMS#readablestream-error
RS.取消す:~STREAMS#readablestream-cancel
RS.二叉化する:~STREAMS#readablestream-tee
RS.読取n可能:~STREAMS#readablestream-readable
RS.~errorした:~STREAMS#readablestream-errored
RS.妨げられている:~STREAMS#is-readable-stream-disturbed
RS.~lockされている:~STREAMS#readablestream-locked
RS.もっと~dataが必要:~STREAMS#readablestream-need-more-data

RSR.~chunkを読取る:~STREAMS#readablestreamdefaultreader-read-a-chunk
RSR.すべての~byteを読取る:~STREAMS#readablestreamdefaultreader-read-all-bytes

RS.通して~pipeする:~STREAMS#readablestream-pipe-through

TS.設定しておく:~STREAMS#transformstream-set-up
TS.~chunkを~enqueueする:~STREAMS#transformstream-enqueue
恒等変換~stream:~STREAMS#identity-transform-stream


	●Fetch API
~fetch_~callを中止する:#abort-fetch
本体と型を抽出する:#concept-bodyinit-extract
本体と型を安全に抽出する:#bodyinit-safely-extract

~guardで検証する:#headers-validate

Hl.~header~list:#concept-headers-header-list
Hl.~guard:#concept-headers-guard
Hl.~headerを付加する:#concept-headers-append
Hl.付加する:#concept-headers-append
~objで埋める:#concept-headers-fill
~Headers用の~guard:#headers-guard

特権的~CORSなし要請~headerを除去する:#concept-headers-remove-privileged-no-cors-request-headers

~Request~objを作成する:#request-create
Rq.要請:#concept-request-request
Rq.~Headers:#request-headers
Rq.通達:#request-signal

~Response~objを作成する:#response-create
~Response~objを初期化する:#initialize-a-response
Rs.応答:#concept-response-response
Rs.~Headers:#response-headers

Bd.利用-不能:#body-unusable
Bd.本体:#concept-body-body
本体を消費する:#concept-body-consume-body
~MIME型を取得する:#concept-body-mime-type

	●INFRA
実装定義:~INFRA#implementation-defined
ときは中止する:~INFRA#abort-when
中止されたときは:~INFRA#if-aborted
	~BREAK:~INFRA#iteration-break
	~CONTINUE:~INFRA#iteration-continue

真偽値:~INFRA#boolean
~byte列:~INFRA#byte-sequence
byte.から開始して:~INFRA#byte-sequence-starts-with
長さ:~INFRA#byte-sequence-length
~byte小文字~化する:~INFRA#byte-lowercase
~byte大文字~化する:~INFRA#byte-uppercase
~byte大小無視:~INFRA#byte-case-insensitive
~JSON~byte列を~JS値に構文解析する:~INFRA#parse-json-bytes-to-a-javascript-value
文字列:~INFRA#string
~scalar値~文字列:~INFRA#scalar-value-string
文字:~INFRA#code-point
~ASCII空白:~INFRA#ascii-whitespace
~ASCII文字列:~INFRA#ascii-string
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII数字:~INFRA#ascii-digit
符号位置:~INFRA#code-point
位置~変数:~INFRA#string-position-variable
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
から開始して:~INFRA#string-starts-with
~forgiving-base64復号する:~INFRA#forgiving-base64-decode
同型に符号化する:~INFRA#isomorphic-encode
同型に復号する:~INFRA#isomorphic-decode
~JS値を~JSON~byte列に直列化する:~INFRA#serialize-a-javascript-value-to-json-bytes
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace

構造体:~INFRA#struct
~tuple:~INFRA#tuple
sct.~item:~INFRA#struct-item
空:~INFRA#list-is-empty
~cloneする:~INFRA#list-clone
map.空:~INFRA#map-is-empty
~list:~INFRA#list
~item:~INFRA#list-item
~size:~INFRA#list-size
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
包含して:~INFRA#list-contain
	~EACH:~INFRA#list-iterate
	~EACH:~INFRA#map-iterate
	:~INFRA#map-exists
有順序~集合:~INFRA#ordered-set
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~listを昇順に~sortする:~INFRA#list-sort-in-ascending-order
未満の~byte列:~INFRA#byte-less-than

	●外部（HTTP
~field名:~HTTPinfra#field-name
~field値:~HTTPinfra#field-value
~field行l:~HTTPinfra#field-line
~field行l値:~HTTPinfra#field-line-value
単数~field:~HTTPinfra#singleton-field
~ABNF~list拡張:~HTTPinfra#abnf.extension
~header節:~HTTPinfra#header-section
~trailer:~HTTPinfra#trailer-field
内容:~HTTPinfra#message-content
	payload body → 内容
~HTTP応答:~HTTPinfra#response
~HTTP要請:~HTTPinfra#request

~target~URI:~HTTPsem#target-URI
条件付き要請:~HTTPsem#conditional-request
要請~method:~HTTPsem#methods
内容~符号法:~HTTPsem#content.codings
状態s~code:~HTTPsem#status-code
応答~状態s~code:~HTTPsem#status-code
非最終-応答:~HTTPsem#interim-response
最終-応答:~HTTPsem#final-response
安全:~HTTPsem#safe-method
	~realm:~HTTPsem#realm


現在の齢:~HTTPcache#age.calculations
鮮度~維持期間:~HTTPcache#calculating.freshness.lifetime
	:~HTTPcache#age.calculations
	新鮮:~HTTPcache#fresh
	非新鮮:~HTTPcache#stale

有構造~field値:~STRUCTURED-FIELDS#structured-field-name-value
有構造~fieldを直列化する:~STRUCTURED-FIELDS#text-serialize
有構造~fieldを構文解析する:~STRUCTURED-FIELDS#text-parse
有構造~header:~STRUCTURED-FIELDS#structured-header
~sf~token:~STRUCTURED-FIELDS#sf-token

媒介者:~HTTPinfra#intermediary

不依拠-可能:~WT-OVERVIEW#unreliable

	●外部（HTML

大域~taskを~queueする:~WAPI#queue-a-global-task
~network用~task~source:~WAPI#networking-task-source
大域~obj:~WAPI#global-object
関連な大域~obj:~WAPI#concept-relevant-global
現在の設定群~obj:~WAPI#current-settings-object
関連な設定群~obj:~WAPI#relevant-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
環境:~WAPI#environment
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~ID:~WAPI#concept-environment-id
enV.~target閲覧~文脈:~WAPI#concept-environment-target-browsing-context
enV.大域~obj:~WAPI#concept-settings-object-global
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.埋込元~施策:#concept-settings-object-embedder-policy
enV.生成元:~WAPI#concept-settings-object-origin
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
enV.~secureな文脈:~WAPI#secure-context

関連な~realm:~WAPI#concept-relevant-realm
~script~fetch~option群:~WAPI#script-fetch-options
~event~loop:~WAPI#event-loop

nav.作動中な文書:~HTMLds#nav-document
先祖~navigable群:~HTMLds#ancestor-navigables
子~navigable:~HTMLds#child-navigable

結付けられた文書:~WINDOW#concept-document-window

生成元:~ORIGIN#concept-origin
o.~host:~ORIGIN#concept-origin-host
o.~scheme:~ORIGIN#concept-origin-scheme
同一-生成元:~ORIGIN#same-origin
sub.生成元:~ORIGIN#same-origin
成分組~生成元:~ORIGIN#concept-origin-tuple
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元を直列化-:~ORIGIN#ascii-serialisation-of-an-origin
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
~site:~ORIGIN#site
~siteを得する:~ORIGIN#obtain-a-site
~scheme無しで同じ~site:~ORIGIN#schemelessly-same-site

施策~容器:~ORIGIN#policy-container
施策~容器を~cloneする:~ORIGIN#clone-a-policy-container
pC.埋込元~施策:~ORIGIN#policy-container-embedder-policy
pC.~referrer施策:~ORIGIN#policy-container-referrer-policy

embP.報告のみの報告先:~ORIGIN#embedder-policy-report-only-reporting-endpoint
embP.報告先:~ORIGIN#embedder-policy-reporting-endpoint
embP.報告のみの値:~ORIGIN#embedder-policy-report-only-value
embP.値:~ORIGIN#embedder-policy-value-2
埋込元~施策~値:~ORIGIN#embedder-policy-value
i.~COEP報告~種別:~ORIGIN#coep-report-type

l.require-corp:~ORIGIN#coep-require-corp
l.unsafe-none:~ORIGIN#coep-unsafe-none
l.credentialless:~ORIGIN#coep-credentialless

並列的:~HTMLINFRA#in-parallel
並列~queue:~HTMLINFRA#parallel-queue
新たな並列~queueを開始する:~HTMLINFRA#starting-a-new-parallel-queue
手続きを~enqueueする:~HTMLINFRA#enqueue-the-following-steps

~preloadされる資源を消費する:~HTMLlinks#consume-a-preloaded-resource

~mp_form_data境界~文字列:~HTMLforms#multipart%2Fform-data-boundary-string
~mp_form_dataとして符号化する:~HTMLforms#multipart%2Fform-data-encoding-algorithm

~navi:~HTMLnav#navigate
~navigate:~HTMLnav#navigate
~navi~algo:~HTMLnav#navigate
~navi~params:~HTMLnav#navigation-params
nvP.予約-済み環境:~HTMLnav#navigation-params-reserved-environment

	●外部（他

~realm:~TC39#realm
現在の~realm:~TC39#current-realm
~Record:~TC39#sec-list-and-record-specification-type

jA.StructuredSerialize:~HTMLcloning#structuredserialize
jA.StructuredDeserialize:~HTMLcloning#structureddeserialize

例外:~WEBIDL#dfn-exception
~interface:~WEBIDL#dfn-interface
~promise型:~WEBIDL#idl-promise
連列~型:~WEBIDL#idl-sequence
~record型:~WEBIDL#idl-record
反復される値~pair群:~WEBIDL#dfn-value-pairs-to-iterate-over

保持された~byte列の複製を取得する:~WEBIDLjs#dfn-get-buffer-source-copy
~buffer~sourceを~byte列から作成する:~WEBIDLjs#_buffersource-create
	~WEBIDLjs#arraybufferview-create → ~WEBIDLjs#_buffersource-create
	~WEBIDLjs#arraybuffer-create → ~WEBIDLjs#_buffersource-create

内包-:~WEBIDL#include

新たな:~WEBIDLjs#new
新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with

符号化法:~ENCODING#encoding
~labelから符号化法を取得する:~ENCODING#concept-encoding-get
enc.~UTF-8:~ENCODING#utf-8
~UTF-8符号化する:~ENCODING#utf-8-encode
~UTF-8復号する:~ENCODING#utf-8-decode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

~URL:~URL1#concept-url
	誤）~TR/pub-manifest/#dfn-url
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
url.~domain:~URL1#concept-domain
url.~scheme:~URL1#concept-url-scheme
url.素片:~URL1#concept-url-fragment
url.生成元:~URL1#concept-url-origin
url.~path:~URL1#concept-url-path
url.~host:~URL1#concept-url-host
url.~port:~URL1#concept-url-port
url.~username:~URL1#concept-url-username
url.~password:~URL1#concept-url-password
url.~blob~URL~entry:~URL1#concept-url-blob-entry

~host:~URL1#concept-host
公共~接尾辞:~URL1#host-public-suffix
~IP~address:~URL1#ip-address
~IPv6~address:~URL1#concept-ipv6

資格証を含んで:~URL1#include-credentials
~form_urlencoded直列化器:~URL1#concept-urlencoded-serializer
~form_urlencoded構文解析器:~URL1#concept-urlencoded-parser
~parameter~list:~URL1#concept-urlsearchparams-list
i.素片は除外する:~URL1#url-serializer-exclude-fragment
~URLの~usernameを設定する:~URL1#set-the-username
~URLの~passwordを設定する:~URL1#set-the-password
文字列を~byte列に~percent-復号する:~URL1#string-percent-decode
素片~付き絶対~URL文字列:~URL1#absolute-url-with-fragment-string

fD.~entry~list:~XHR#concept-formdata-entry-list
fD.~entry:~HTMLforms#form-entry
	廃）fD.~entry:~XHR#concept-formdata-entry

~streamを取得する:~FILEAPI#blob-get-stream
~blobを切出す:~FILEAPI#slice-blob
~blob~objを得する:~FILEAPI#blob-url-obtain-object

~CSP指令:~CSP3#csp-directives

~WebSocket接続を確立する:~WEBSOCKET#concept-websocket-establish
~WebSocket接続を得する:~WEBSOCKET#concept-websocket-connection-obtain

~referrer施策:~REFERRER-POLICY#referrer-policy
	#concept-referrer-policy
既定の~referrer施策:~REFERRER-POLICY#default-referrer-policy
~referrerを決定-:~REFERRER-POLICY#determine-requests-referrer
~referrer施策を設定する:~REFERRER-POLICY#set-requests-referrer-policy-on-redirect

報告を生成して~queueする:~REPORTING#generate-and-queue-a-report

資源~計時を~markする:~RESOURCE-TIMING#dfn-mark-resource-timing

依存~中止-通達を作成する:~DOM4#create-a-dependent-abort-signal
通達に~algoを追加する:~DOM4#abortsignal-add
aB.中止-事由:~DOM4#abortsignal-abort-reason
aB.中止-済み:~DOM4#abortsignal-aborted
doc.生成元:~DOM4#concept-document-origin
要素:~DOM4#concept-element
~node文書:~DOM4#concept-node-document

~MIME型:~MIMESNIFF#mime-type
~JS~MIME型:~MIMESNIFF#javascript-mime-type
~MIME型を構文解析する:~MIMESNIFF#parse-a-mime-type
~MIME型を~byte列に直列化する:~MIMESNIFF#serialize-a-mime-type-to-bytes
~essence:~MIMESNIFF#mime-type-essence
~parameter群:~MIMESNIFF#parameters
	:~MIMESNIFF#serialize-a-mime-type
~supportされる~MIME型を最小~化する:~MIMESNIFF#minimize-a-supported-mime-type

~fetchを取扱う:~SW1#handle-fetch
~sw計時~報:~SW1#service-worker-timing-info

~fetch~metadata~headerたちを付加する:~FETCH-METADATA#abstract-opdef-append-the-fetch-metadata-headers-for-a-request

相対的な高分解能~時刻:~HRTIME#dfn-relative-high-resolution-time
時刻を粗化する:~HRTIME#dfn-coarsen-time
粗化した共有される現在の時刻:~HRTIME#dfn-coarsened-shared-current-time
安全でない共有される現在の時刻:~HRTIME#dfn-unsafe-shared-current-time


●●words_table1

SRI1:webappsec-subresource-integrity-ja.html
BEACON:beacon-ja.html
RFC6454:RFC6454-ja.html
UPGRADE1:webappsec-upgrade-insecure-requests-ja.html
	https://w3c.github.io/webappsec-upgrade-insecure-requests/
FETCH-METADATA:webappsec-fetch-metadata-ja.html
HTTPearlyhints:http-status-code-103-ja.html
SERVER-TIMING:server-timing-ja.html
WIKIPEDIA:https://en.wikipedia.org/wiki
WT-OVERVIEW:webtrans-overview-ja.html
WT-HTTP3:webtrans-http3-ja.html
HTTPdatagram:http-datagram-ja.html

sf:<sub>sf-</sub>
mp_form_data:<code>multipart/form-data</code> 
form_urlencoded:<code>application/x-www-form-urlencoded</code> 
	Origin:<code class="header">Origin</code>
data_URL:<code class="scheme">data:</code> URL 
stale-while-revalidate:<code class="directive">stale-while-revalidate</code> 
fetch_:<code>fetch()</code> 
Accept: `<code class="header">Accept</code>` 
User

●●words_table


	●名称／略称
WebSocket:
HTTP2:HTTP/2
HTTP3:HTTP/3
HTTP1x:HTTP/1.x
	~HTTP1x:HTTP/1
	HTTP/1.0
	HTTP/1.1
HTTP_S:HTTP(S) 
IPv6:
IPv4:
IP:
DNS:
HTTPS-RR:HTTPS RR
Fetch:
WebTransport:
UDP:
TLS:
TCP:
ALPN:
	~ALPN~protocol~ID:ALPN Protocol ID
SOCKS:
CORP:
COEP:
TAO:
	~CORSなし:no-CORS:
Origin:
Cross-Origin-Embedder-Policy:
XSS:cross-site scripting:XSS

	非同一-生成元~埋込元~施策:Cross-Origin Embedder Policy
	~HTTP用の拡張-可能な優先度~scheme^cite:Extensible Prioritization Scheme for HTTP
	~web生成元の概念^cite:Web Origin Concept
	資源の計時^cite:Resource Timing
	~naviの計時^cite:Navigation Timing
	~referrer施策^cite:Referrer Policy
	~CSP `CSP$r:<cite>Content Security Policy</cite>
	~HTML^cite:HTML
	Returning Values from Forms: multipart/form-data^cite

	●構文／直列化
BOM:
wildcard:
percent-::: %-
tab-or-space:tab or space:tab／space
forgiving-base64:
文字大小:case::~
	文字大小~法:casing:~
同型:isomorphic::~
改行:newline::~
部位:part:~
	成功した:successful
剥ぐ:stripする::~
引用符付き:quoted::~
逆直列化-:deserialize::~::逆シリアル化

	頭部:leading／:start
	尾部:trailing／:end
	-:end
	順に~~連結-:prepend
	10 進数:decimal number

	●data型／操作／構造
null:
multimap:
Record:
	( ~key, 値 ):key-value
	value:
成分組:tuple::~
	組:tuple
作成時の:creation::~
昇順:ascending order:~
単数:singleton:::~
内包-:include::~
連結-:concatenate::~
	順に連結-:Append
段階:stage:~

	作成-時:creation
	初期~時:initially
	~GT 0:positive
	~IN:contain
	~header~list:headers
	KiB:kibibyte

	●一般処理／stream/promise／IDL
Headers:
Response:
Request:
close:
open:
chunk::::チャンク
	~chunkごと:chunk-by-chunk
二叉化-:tee::~
function:
済んだ:done:~
main:
process::::プロセス
params::::パラメタ群
排他的:exclusive:~
妨げら:disturbさ::~
不可分:atomic::~
ok:
早期:early::~
優先度:priority::~
中止:aborted::~
	中止-済み:aborted
休止:suspension::~
	構築-法:constructing
漸進的:progressive:~
不定期:indefinite:~
再帰:recursive:~
計時許容:timing allow::計時の許容
合格-:pass::~
並列:parallel::~
策:strategy::~
増分的:incremental::~
引渡す:hand overする::引き渡す
引渡され:hand overされ::引き渡され
	引渡す:handover
完結-:finalize::~
合成な:syntheticな:~
候補:candidate:~
切詰めて:clampして:切り詰めて
検索:lookup::~
pipe::::パイプ
形式変換:transform::~
恒等変換:identity transform::~
書出n:flush::書き出し
競争-:race:~
時間切れ:timeout:~
呼出法:invoke 法:呼び出し法
設定法:setting up::~
入出力:I/O::~
高分解能:high-resolution::~
発-:emit:~
粗化-:coarsen:粗く
切出す:sliceする::切り出す
切出した:sliceした::切り出した
post::::ポスト
background::::バックグラウンド

	情報:info
	読取n可能:readable::読み取り可能
	かかった時間:time interval
	かかった時間:interval
	かかる時間:time needed
	時間~切れ:timed out
	〜後からの:post-〜
	highWaterMark
	時点が来る:moment arrives
	突き合わせて:against
	end-of-stream:stream 終端
	~stream化:stream
	何もしない:no-op
	失敗した:not succeed
	回数:number of times
	設定しておく:setup
	具現化を阻んで:render-blocking
	具現化を阻む:render-blocking
	近いうち:shortly
	どう扱うかを~page訪問~回数に応じて違える:treat it differently when counting page visits
	1 を加えて:increment
	その~threadの外で:breaks off

	●変数
	%~blob:blob
	%~blob~URL~entry:blobURLEntry
	%~URL:url
	%内部~応答:internalResponse
	%範囲~値:rangeValue
	%範囲~header値:rangeHeader
	%~header名:headerName
	%~header名~群:headerNames
	%~header群:headers
	%headers:headers（Headers）
	%headers:-
	%~HTTP要請:httpRequest
	%~HTTP~cache:httpCache
	%再検証-要請:revalidateRequest
	%再検証-中か:revalidatingFlag
	%格納-済み応答:storedResponse
	%init:init
	%名前:name
	%名前~群:names
	%~method群:methods
	%互換~method:-
	%~method:-
	%安全でない名前~群:unsafeNames
	%安全でないかもしれない名前~群:potentiallyUnsafeNames
	%安全な値の合計~size:safelistValueSize
	%最初の~token:firstToken
	%~MIME型:mimeType
	%開始~位置:positionStart
	%一時的~MIME型:temporaryMimeType
	%一時的な値:temporaryValue
	-:quoteOrBackslash
	%値:value
	%値:temporaryValue
	%~header値:value
	%値~群:values
	%値~群:parsedValues
	%値~群:-
	%値を抽出するか:extract-value
	%候補~値:candidateValue
	%直列化した生成元:serializedOrigin
	%有構造~値:structuredValue
	%直列化した値:serializedValue
	%直列化した~URL:serializedURL
	%ws:ws
	%rs:rs
	%報告先:endpoint
	%設定群~obj:settingsObject
	%~navi用か:forNavigation
	%埋込元~施策:embedderPolicy
	%報告のみ:reportOnly
	%回送-応答:forwardResponse
	%埋込元~施策~値:embedderPolicyValue
	%~top-level生成元:topLevelOrigin
	%~top-level~site:topLevelSite
	%読取器:reader
	%読取n要請:readRequest
	%~byte列:bs
	%~byte列:bytes
	%~error:e
	%~network区分~key:networkPartitionKey
	%第二~key:secondKey
	%処置:disposition
	-:ignoreType
	%入力~本体:inputBody
	%最終-本体:finalBody
	%最終-本体:inputOrInitBody
	%初期~本体:initBody
	%本体と型:bodyWithType
	%本体と型:body
	%本体:body
	%型:type
	%内容~型
	%~Location~URL:locationURL
	%~Location:locationURL
	%~Location:location
	%~sw用の要請:requestForServiceWorker
	%~referrer値:referrerValue

	%~pull~algo:pullAlgorithm
	%取消~algo:cancelAlgorithm
	%~stream:stream
	%~realm:realm
	%~Request~obj:requestObject
	%~Response~obj:responseObject
	%~Response~obj:response
	%~cloneした~Request~obj:clonedRequestObject
	%~cloneした通達:clonedSignal
	%~cloneした要請:clonedRequest
	%~cloneした応答~clonedResponse
	%関連な~realm:relevantRealm
	%~taskの行先:taskDestination
	%~fetch~params:fetchParams
	%再検証-~fetch~params:-
	%予行~fetch~params:-
	%~HTTP~fetch~params:httpFetchParams
	%要請:request
	%要請または応答:requestOrResponse
	%要請:req（誤 request
	%要請の本体~終了~時の処理n:processRequestEndOfBody
	%要請の本体~chunk長さの処理n:processRequestBodyChunkLength
	-:continueAlgorithm
	%並列~queueを利用するか:%useParallelQueue
	%応答:response
	%応答:_response_
	%応答~状態s:responseStatus
	%応答の処理n:processResponse
	%応答の早期~hintの処理n:processEarlyHintsResponse
	%応答の本体~終了~時の処理n:processResponseEndOfBody
	%応答の本体~終了~時の処理n用の~task:processResponseEndOfBodyTask
	%応答の本体を消費する処理n:processResponseConsumeBody
	-:doneAlgorithm
	%~CORS予行を為すか:makeCORSPreflight
	%資格証を含めるか:includeCredentials
	%資格証を伴うか:credentials
	%認証~fetchか:isAuthenticationFetch
	%~NULLまたは~byte列:nullOrBytes
	%本体~chunkの処理n:processBodyChunk
	%本体~終了~時の処理n:processEndOfBody
	%本体~errorの処理n:processBodyError
	%本体の処理n:processBody
	%成功~手続き:successSteps
	%~error手続き:~errorSteps
	-:continueAlgorithm
	%要請~素片:requestFragment
	%接続~群:connections
	%不依拠-可能を要求するか:requireUnreliable
	%新たな接続~fetchか:isNewConnectionFetch
	%新たな接続を強制するか:forceNewConnection
	%新たな接続を強制するか:forceNew
	%新たな接続:newConnection
	%Content-Length~header値:contentLengthHeaderValue
	%内容~長さ:contentLength
	%計時~報:timingInfo
	%非同一-生成元~能力は隔離されるか:crossOriginIsolatedCapability
	%既定の開始~時刻:defaultStartTime
	%接続:connection
	%大域~obj:global
	%大域~obj:globalObject
	%~sw開始~時刻:serviceWorkerStartTime
	%-:handleFetchDone
	%形式変換~stream:transformStream
	%形式変換~algo:transformAlgorithm
	%恒等変換~algo:identityTransformAlgorithm
	%再帰的か:recursive
	%局所的に中止されたか:locallyAborted
	%~cache状態:cacheState
	%~host群:hosts
	%内容~範囲:contentRange
	%範囲~始端:rangeStart
	%範囲~始端~値:rangeStartValue
	%範囲~終端:rangeEnd
	%範囲~終端~値:rangeEndValue
	%最後の~URL:lastURL
	%~preloadされる応答~可用~時の手続き:onPreloadedResponseAvailable
	%~preloadされる資源を見出したか:foundPreloadedResource
	%制御器:controller
	%中止-事由:abortReason
	%中止-事由:-
	GOTO `fallback^i:fallbackError
	%直列化した~error:serializedError
	%逆直列化した~error:deserializedError
	%~keepaliveか:keepalive
	%~fallback符号化法:fallbackEncoding
	%符号化法:tentativeEncoding
	%安全でない終了~時刻:unsafeEndTime
	%本体~報:bodyInfo
	%長さ:length
	%~byte列を~JS値に変換する:convertBytesToJSValue
	%結果:result
	%空白を許容するか:allowWhitespace
	%全部的な長さ:fullLength
	%直列化した全部的な長さ:serializedFullLength
	%切出した~blob:slicedBlob
	%切出した本体と型:slicedBodyWithType
	%切出した長さ:slicedLength
	%直列化した切出した長さ:serializedSlicedLength
	%内容:contents
	%通達:signal
	%通達~群:signals
	%要請~環境:requestEnvironment
	%~top-levelの~naviか:isTopLevelNavigation
	%~naviまたは環境:navigationOrEnvironment
	%~client:-

	●URL
hostname::::ホスト名
username::::ユーザ名
password::::パスワード
blob:
dataURL:data URL

URI:
	location:::ロケーション
	期限

	●ネットワーク／HTTP(S)
essence:
charset:
http:
loopback::::ループバック
Location:
keepalive:
network-or-cache::::ネットワーク-or-キャッシュ
preload:
prefetch:
再読込み:reload::再読み込み::リロード
	~download法:downloading
trailer::::トレイラ
tunnel::::トンネル
hop:
	参照元
	~cache法:caching
no-cache:
dispatch:
handshake::::ハンドシェイク
pool::::プール
offline::::オフライン
	file
報告先:reporting endpoint::~
端点間:end-to-end::~::エンドツーエンド
内容形式:format::~::フォーマット
	伝送-済み:transmitted

為され:makeされ:~
為さな:makeしな:~
為して:makeして:~
為した:makeした:~
発行-:issue::~

保管庫:store::~::ストア
	本体の終端:end-of-body
	応答~header:response-header
	出自に:originate from
無効化-:invalidate::~
	無効化-法:invalidation
再検証-:revalidate::~
	再検証-中:revalidating
新鮮化-:fresh::~
	新鮮化-法:freshening
新鮮:fresh::~
非新鮮:stale::~
鮮度:freshness::~
維持期間:lifetime::~
齢:age::~
寿命:max-age:::~
有効期限:expiry:~

符号法:coding::~::コーディング
符号法s:codings::符号法たち::コーディングたち
昇格-:upgrade::~::アップグレード
重み:weight::~
	通信-法:communicating
非最終-:interim::~
最終-:final::~
返信-:send back::~
交換-:exchange:~
	交換すること:exchange
半二重:half-duplex::~
全二重:full-duplex::~
公共:public:~
不依拠-:unrely:~
	不依拠-可能:unreliable

	~navi~algo:navigate algorithm
	“最終”:final
	範囲~付き:ranged
	~cache制御:cache-control
	~fetch側:fetcher
	~redirect器:redirector
	資源~計時:Resource Timing
	資源~計時:resource-timing
	^sp:SETTINGS_ENABLE_WEBTRANSPORT
	SETTINGS_H3_DATAGRAM^sp:H3_DATAGRAM
	^i:False Start
	^i:ServerHello
	^i:ClientHello
	^i:Finished
	^i:early data

	●保安／CSP／HTTPS／認証／CORS／MIX
tainting:
taint:
nonce::::ナンス
intranet::::イントラネット
guard::::ガード
nosniff:
	阻止-法:blocking
	阻止される^i:blocked
	許容される^i:allowed
埋込元:embedder::埋め込み元
認証:authentication::~
認証-:authenticate::~
	認証-済み:authenticated
	~proxy認証:proxy-authentication
権限付与:authorization::~
証明書:certificate::~
inflight:::伝送中の
予行:preflight::~::プリフライト
	予行を伴わずに:non-preflighted
	CORS-preflight
hash::::ハッシュ
	違反報告
	不透明~redirect:opaque-redirect
暗号用:cryptographic::~
混在d:mixed::混在
firewall::::ファイアウォール
side-channel:side channel:::サイドチャネル
	別の:side-channel
	安全でない:unsafe
安全とさ:safelistさ::~
安全とし:safelistし::~
	安全とされていない:non-safelisted
秘匿情報:secret:~
悪用:exploit:~
悪用-:exploit:~
特権的:privileged::~
	特権的でない:unprivileged
無毒化-:sanitize::~
私的:private::~
処置:disposition::~
防護-:guard:~
	信用に価し得る:potentially trustworthy
	疑わしい:in doubt
	報告-用:for reporting
	計時~攻撃:timing

	●仕様
内部状態管理:bookkeeping detail:~
	内部状態管理~用に:as a bookkeeping detail
不用意:accidental:~
一時的:temporary:~
都合よい:convenientな:~
無害:harmless:~
土台:ground:~
曖昧:vague:~
普通の:ordinary:~
一般論:general:~
合法:legal:~
	合法でない:illegal
透過的:transparent:~
条項:caveat:~
正常:normal:~
今後の:future:~
単直:straightforward:簡単
網羅的:exhaustive:~
多用途:versatile:~
素朴:naïve:~
致命的:fatal:~
増補-:augment:~
必要最小限:minimal:~
申請-:file:~
精緻:fine:~
	より精緻:finer
複雑:complicated:~
一様:uniform:~

opt-in::::オプトイン
	~opt-in:opt-into
末端-:end:~:::エンド
給-:supply:~
想定-:suppose:~
統一-:unify:~
発展-:evolve:~
遭遇-:encounter:~
制限付き:limited:~
考案-:invent:~
被っ:incurし:~
妨害-:disrupt:~
	妨害する:disruptive
保つ:keepする:~
保って:keepして:~
目指す:aimする:~
誤認-:mistake:~
	ものと誤認して:mistakenly
選んで:chooseして:~
選ぶ:chooseする:~
尊重-:respect:~
裁量:discretion:~
討論:considered discussion:~
意味合い:nuance:~
採用-:adopt:~
助言:advice:~
分野:domain:~
専門家:expert:~
本質:essence:~
現実:reality:~
自由度:freedom:~
方策:tactics:~
誂える:tailorする:~
審査-:vet:~
漏れる:leakする:~
築かな:buildしな:~
現今の:contemporaryな:~
必要十分:adequate:~
参照r:refer:参照
	を指して:refer to
種類:kind:~
口語的:colloquial:~
見越され:anticipateされ:~
高度な:advanced:~
情報用の:informativeな:~
宿題:exercise:~
機能-:function:~
	機能させる:functional
	機能-法:functioning

	^en:helper
	用途:usage
	~~強く:highly
	一貫性を得る:consistent
	省略時は:optional
	明瞭でない:unclear
	最終的に:eventual
	~~用語:specification device
	し易く:assist
	規範的でない:informative
	必要:need／
	すなわち:Namely,
	べき／ベキ:should
	大雑把に言えば:In broad strokes
	~~区分:division
	背景情報:background reading
	比較的:relatively
	低~level:low-level
	高~levelから見れば At a high level,
	まだ:currently
	今の所:for now
	全般に渡り:Throughout
	それなりに／~~相応に:fairly
	世代ごとに:to the next.
	常で:and used to
	様々なものと~~複雑に入り組んでいる:quite involved
	~~暗黙の前提:underlying assumption
	~~起きた:has precedent
	向けの／に向かうに先立ち:on the way
	時点で:Suddenly
	ほぼ間違いなく:highly likely
	見込みが高い:more likely
	かまわない:fine
	ascribe:帰するとみなされ
	足りる:suffices
	今では、:nowadays
	要している:necessitating
	昔から:the old days
	上層:top of
	慎重に事を~~運ぶ:extreme care
	でなくする方へ~~働く:rather
	代替として:alternatively
	およそ役に立たない:rather useless
	功罪:for better or worse
	悪化-:bad／worse
	~~策定:made
	誤記:misspelling
	すなわち:This means
	どうやっても:anyway
	-:a.k.a
	[INFRA]:Infra
	長年にわたり:over the years
	大多数:major
	~~寛容にされて:rather forgiving
	大部分は:largely
	当面の間は:for the moment
	事:fact
	結果:outcome
	すなわち:means
	他になく:can be 〜 only
	むしろ:rather
	まったく:perfectly
	申し分ない:fine
	〜を問わず:for non- 〜 as well as
	利用されない:unused
	含まない／含めない:exclude
	結付きを断つ:disassociateする
	どの〜から利用されるか:relationship
	discourage
	前提に:assume
	もたらす
	〜できreliable
	観測-可能にならないこと:non-observability
	考慮-:consideration
	該当-:pertain
	関わる:pertain
	判別できない:indistinguishable
	探-:seek
	対処-:deal with
	置き換える:supplants
	書き下ろされ:written down
	助け:help
	~~規定する:stipulates
	みなされる:counts as a
	~~無視して:not paying attention
	知る:know
	~~整理:sorted through
	問われない:not matter
	問われる:for that matter
	~~対照的に:as opposed
	必ず:make sure
	促す:prompt
	呼ばれ:known
	興味を引く:interesting
	調べて:looking at
	際どい:edge
	〜以外にない:exclusively
	~~実際:indeed
	は別として:apart from
	ここでは定められない:tied down
	`~Fetch標準^cite:Fetch Standard
	経ない限り:without having
	べき:ought
	委ねる:left to
	~~仔細:the particulars
	~~縁遠い:not pertinent
	に転換する:turn into
	選び取る:pick
	選り好む:favor
	絡んでくる:come into play
	に過ぎないが…:rather
	別として:aside
	いずれにせよ:nonetheless
	〜した上で:coupled with
	たくさん:a lot of
	役立ち〜:helpful
	最後に，:ultimately
	最終的に:ultimately
	表す／表し:denote
	表記-:denote
	仕立て上げ:make
	^en:okay
	~~調整:tune
	アリでないもの:than what is possible with
	遡って解きほぐす:unwind
	に従って:as per
	ごく:very
	得る:get
	旧い:older
	〜しないこと。:ought not
	通す仕方:by way of
	特に認められた:blessed
	による否定的な~~影響は無い:ought not to have any negative repercussions
	形式上必要な:dummy
	事前に:ahead of time
	見渡して:Browse through
	しっかり~~具体化する:Make sure 〜 fleshed out
	考え抜く:Think through
	考えられる:think
	解明-:figure out
	頻度は他より低い:less frequently
	調べる:see
	事始め:to get started
	単なる〜ない:much more
	~webに公開される:web-exposed
	上で言及した:aforementioned
	の他にも:apart from
	~~自前で:by yourself
	責務:responsible to
	心配-:worry

	●未分類
露呈-:reveal::露わに
捕捉-:capture::~
捕える:catchする::~
浪費-:waste:~
翻訳-:translate:~
維持-:retain:~
担当の:responsibleな::~
絞込み:filtered::絞り込み::フィルタ済み
	はじく:filter out
埋める:fillする:~
回送-:forward::~
再生-:play:~
	再生し直す:replay
区分:partition:~
埋めれ:fillでき:~
未登録:non-registered:~
次回の:next:~
依存:dependent:~
投入-:feed:~

	格納-済み:stored
	改変されてない:unmodified
	利用-不能:unusable
	予約-済み:reserved
	外で残存:outlive
	-:mark
	:consist
	~INCBY:increase
	やめた:stop
	追-:follow
	層の重ね方:layering
	欠く:lack／:without
	染め:taint
	在る:there are any
	無い:does not contain
	指す:pointer
	残り続ける:stay alive
	やり直す:go through〜again
	出くわした:met
	出くわしたとき:moment 〜 seen
	束ねる:bind
	結果は〜になる:ends up
	渡-:pass
	過ぎた:pass
	消え去った:goes away
	重複し得る:potentially duplicate
	前後~pageへの:a.k.a. back-foward navigation
	〜:range
	-:document
	〜別に分けられる:keyed on
	秒数:seconds／number of seconds
	-:subset
	~call元:caller
	~call元:call site
	~secureでない:non-secure
	付与-:attach
	回数:count
	送信し直-:resend
	作成し直-:recreate
	置く:put
	側:-side
	側:-
	下限:lower limit
	上限:upper limit
	終端を含む:denotes an inclusive
	あらゆるもの:everything
	~~特有なもの:particulars
	以前の:previous
	以前に:previously
	後に:subsequently
	過去の:earlier
	一部／一環:part of
	ある:certain／particular
	〜時には:upon
	今度:now
	広く:widely
	と同じく:as well as
	上限がある:bound
	~NULL でないこと:nullity
	時機:timing
	残りわずかしかない:there’s only a few bytes of
	すべての`符号位置~並びを収集する$:the remainder of
	先頭:first／
	末尾:last
	先頭, 末尾も含む:inclusive
	もっぱら:solely
	以外の:excluding
	一体としての:whole
	他のもの:others
	側:-side
	種々の／各種／様々:various
	最短な:shortest possible
	何らかの:any of
	一部分:part of
	何かに〜ない:anything
	の中／過ぎていない:within
	直前の:previous
	直前:immmediately before
	直前:immediately before
	直後:immediately after
	地点:point
	以降の:the remaining
	併せて:alongside
	たくさんの:a lot of
	もっと早くに:earlier
	背後:behind
	ままにして:leave
	残りの／の残り:the rest of
	全体が:in its entirety
	側:side
	〜内部の:-internal

●●ref_key_map
ORIGIN:RFC6454
HTTP3:RFC9114
REFERRER:REFERRERPOLICY
SW:SERVICEWORKERS
HTTP3DATAGRAM:RFC9297

●●ref_data
FETCHMETADATA=副       ~/webappsec-fetch-metadata-ja.html
WEBTRANSPORTHTTP3=副   ~/webtrans-http3-ja.html

●●ref_normative

[ABNF]
    D. Crocker, Ed.; P. Overell. ＜Augmented BNF for Syntax Specifications: ABNF＞. January 2008. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc5234
[BEACON]
    Ilya Grigorik; Alois Reitbauer. ＜Beacon＞. URL: https://w3c.github.io/beacon/
[COOKIES]
    A. Barth. ＜HTTP State Management Mechanism＞. April 2011. Proposed Standard. URL: https://httpwg.org/specs/rfc6265.html
[CSP]
    Mike West; Antonio Sartori. ＜Content Security Policy Level 3＞. URL: https://w3c.github.io/webappsec-csp/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH-METADATA]
    Mike West. ＜Fetch Metadata Request Headers＞. URL: https://w3c.github.io/webappsec-fetch-metadata/
[FILEAPI]
    Marijn Kruisselbrink. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HSTS]
    J. Hodges; C. Jackson; A. Barth. ＜HTTP Strict Transport Security (HSTS)＞. November 2012. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6797
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[HTTP]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. ＜HTTP Semantics＞. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9110.html
[HTTP-CACHING]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. ＜HTTP Caching＞. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9111.html
[HTTP1]
    R. Fielding, Ed.; M. Nottingham, Ed.; J. Reschke, Ed.. ＜HTTP/1.1＞. June 2022. Internet Standard. URL: https://httpwg.org/specs/rfc9112.html
[HTTP3]
    M. Bishop, Ed.. ＜HTTP/3＞. June 2022. Proposed Standard. URL: https://httpwg.org/specs/rfc9114.html
[HTTP3-DATAGRAM]
    D. Schinazi; L. Pardue. ＜HTTP Datagrams and the Capsule Protocol＞. August 2022. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9297
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MIMESNIFF]
    Gordon P. Hemsley. ＜MIME Sniffing Standard＞. Living Standard. URL: https://mimesniff.spec.whatwg.org/
[MIX]
    Emily Stark; Mike West; Carlos IbarraLopez. ＜Mixed Content＞. URL: https://w3c.github.io/webappsec-mixed-content/
[REFERRER]
    Jochen Eisinger; Emily Stark. ＜Referrer Policy＞. URL: https://w3c.github.io/webappsec-referrer-policy/
[REPORTING]
    Douglas Creager; Ian Clelland; Mike West. ＜Reporting API＞. URL: https://w3c.github.io/reporting/
[RESOURCE-TIMING]
    Yoav Weiss; Noam Rosenthal. ＜Resource Timing＞. URL: https://w3c.github.io/resource-timing/
[RFC7405]
    P. Kyzivat. ＜Case-Sensitive String Support in ABNF＞. December 2014. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7405
[RFC7578]
    L. Masinter. ＜Returning Values from Forms: multipart/form-data＞. July 2015. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7578
[RFC9218]
    K. Oku; L. Pardue. ＜Extensible Prioritization Scheme for HTTP＞. June 2022. Proposed Standard. URL: https://httpwg.org/specs/rfc9218.html
[RFC9651]
    M. Nottingham; P-H. Kamp. ＜Structured Field Values for HTTP＞. September 2024. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9651
[SRI]
    Devdatta Akhawe; et al. ＜Subresource Integrity＞. URL: https://w3c.github.io/webappsec-subresource-integrity/
[STALE-WHILE-REVALIDATE]
    M. Nottingham. ＜HTTP Cache-Control Extensions for Stale Content＞. May 2010. Informational. URL: https://httpwg.org/specs/rfc5861.html
[STREAMS]
    Adam Rice; et al. ＜Streams Standard＞. Living Standard. URL: https://streams.spec.whatwg.org/
[SVCB]
    Ben Schwartz; Mike Bishop; Erik Nygren. ＜Service binding and parameter specification via the DNS (DNS SVCB and HTTPS RRs)＞. URL: https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https
[SW]
    Jake Archibald; Marijn Kruisselbrink. ＜Service Workers＞. URL: https://w3c.github.io/ServiceWorker/
[TLS]
    E. Rescorla. ＜The Transport Layer Security (TLS) Protocol Version 1.3＞. August 2018. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8446
[UPGRADE-INSECURE-REQUESTS]
    Mike West. ＜Upgrade Insecure Requests＞. URL: https://w3c.github.io/webappsec-upgrade-insecure-requests/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[WEBSOCKETS]
    Adam Rice. ＜WebSockets Standard＞. Living Standard. URL: https://websockets.spec.whatwg.org/
[WEBTRANSPORT-HTTP3]
    V. Vasiliev. ＜WebTransport over HTTP/3＞. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3
[XHR]
    Anne van Kesteren. ＜XMLHttpRequest Standard＞. Living Standard. URL: https://xhr.spec.whatwg.org/

●●ref_informative

[HTTPVERBSEC1]
    ＜Multiple vendors' web servers enable HTTP TRACE method by default.＞. URL: https://www.kb.cert.org/vuls/id/867593
[HTTPVERBSEC2]
    ＜Microsoft Internet Information Server (IIS) vulnerable to cross-site scripting via HTTP TRACK method.＞. URL: https://www.kb.cert.org/vuls/id/288308
[HTTPVERBSEC3]
    ＜HTTP proxy default configurations allow arbitrary TCP connections.＞. URL: https://www.kb.cert.org/vuls/id/150227
[NAVIGATION-TIMING]
    Zhiheng Wang. ＜Navigation Timing＞. 17 December 2012. REC. URL: https://www.w3.org/TR/navigation-timing/
[ORIGIN]
    A. Barth. ＜The Web Origin Concept＞. December 2011. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6454
[RFC1035]
    P. Mockapetris. ＜Domain names - implementation and specification＞. November 1987. Internet Standard. URL: https://www.rfc-editor.org/rfc/rfc1035
[RFC2397]
    L. Masinter. ＜The "data" URL scheme＞. August 1998. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc2397
[RFC6960]
    S. Santesson; et al. ＜X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP＞. June 2013. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6960
[RFC7301]
    S. Friedl; et al. ＜Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension＞. July 2014. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7301
[RFC7918]
    A. Langley; N. Modadugu; B. Moeller. ＜Transport Layer Security (TLS) False Start＞. August 2016. Informational. URL: https://www.rfc-editor.org/rfc/rfc7918
[RFC8470]
    M. Thomson; M. Nottingham; W. Tarreau. ＜Using Early Data in HTTP＞. September 2018. Proposed Standard. URL: https://httpwg.org/specs/rfc8470.html
[RFC9163]
    E. Stark. ＜Expect-CT Extension for HTTP＞. June 2022. Experimental. URL: https://www.rfc-editor.org/rfc/rfc9163


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">Fetch Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/fetch">GitHub whatwg/fetch</a> (<a href="https://github.com/whatwg/fetch/issues/new/choose">new issue</a>, <a href="https://github.com/whatwg/fetch/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	https://github.com/whatwg/fetch/commits
	<a href="https://fetch.spec.whatwg.org/commit-snapshots/5dfed9d6c57598afd969ddde663cb9693e0c149b/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/fetchstandard">@fetchstandard</a>

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/fetch">web-platform-tests fetch/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/fetch">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）
	<a href="https://htmlspecs.com/fetch/" hreflang="zh-hans" lang="zh-hans" rel="alternate">简体中文</a>

</script>

</head>
<body>

<header>
<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDUiIGZpbGw9IiNmZmYiIHN0cm9rZT0iIzNjNzkwYSIgc3Ryb2tlLXdpZHRoPSIxMCIvPgo8cGF0aCBkPSJtMzQsNTVhNjAsNjAsMCwwLDAsMjAsLTIwYTYsMTAsMCwwLDEsMTMsLTFhMTAsNiwwLDAsMSwtMSwxM2E2MCw2MCwwLDAsMCwtMjAsMjBhNiwxMCwwLDAsMSwtMTMsMWExMCw2LDAsMCwxLDEsLTEzIiBmaWxsPSIjM2M3OTBhIi8+Cjwvc3ZnPgo="
></a>
	<hgroup>
<h1>Fetch</h1>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
`~Fetch標準^cite は、
要請（ `request^en ）, 応答（ `response^en ）, および
この 2 つを束ねる処理-
— ~fetching（ `fetching^en ） —
を定義する。
◎
The Fetch standard defines requests, responses, and the process that binds them: fetching.
</p>

<p class="trans-note">【
“`fetch^en”
— 一般英語の語義としては（どこか離れた所から） “取って来る”。
~network上の資源への~~取得~accessには、
伝統的にこの語が利用されているようだ
（とは言え、この仕様の文脈においては，~HTTP `GET$hm に限られるわけではない）。
単なる “~~取得” では語義が広過ぎるので
（ “`get^en”, “`obtain^en”, “`retrieve^en”, 等々），
訳語としては “資源~~取得” , “~~取得をかける” などが考えられるが、
この訳では原語のまま記す。
】</p>

	</section>

<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<p>
目標は、
~fetchingを~web~platform全体にわたって統一すること，
それが孕む あらゆるものに一貫した取扱いを供することである
— 次に挙げるものも含め：
◎
The goal is to unify fetching across the web platform and provide consistent handling of everything that involves, including:
</p>

<div>
<ul>
	<li>
各種~URL~scheme
</li>
	<li>
~redirect
</li>
	<li>
非同一-生成元（ `cross-origin^en, “生成元~間をまたがる” ）の意味論
【`同一-生成元$（ `same-origin^en ）の否定でもある。】
</li>
	<li>CSP `CSP$r
【 “`Content Security Policy^en” （ “内容保安施策” ）の略語。この訳では、一貫してこの略語を利用する。】
</li>
	<li>
Fetch Metadata `FETCH-METADATA$r
</li>
	<li>
~sw `SW$r
</li>
	<li>
混在d内容（ `Mixed Content^en ） `MIX$r
</li>
	<li>
~secureでない要請の昇格-（ `Upgrade Insecure Requests^en ）
`UPGRADE-INSECURE-REQUESTS$r
</li>
	<li>
`Referer$h ~header `REFERRER$r
</li>
</ul>

◎
• URL schemes
• Redirects
• Cross-origin semantics
• CSP [CSP]
• Fetch Metadata [FETCH-METADATA]
• Service workers [SW]
• Mixed Content [MIX]
• Upgrade Insecure Requests [UPGRADE-INSECURE-REQUESTS]
• `Referer` [REFERRER]
</div>

<p>
そうするため、
元々は `~web生成元の概念^cite `ORIGIN$r にて定義された［
~HTTP `Origin$h ~headerの意味論
］にも取って代わる。
◎
To do so it also supersedes the HTTP `Origin` header semantics originally defined in The Web Origin Concept. [ORIGIN]
</p>

	</section>
	<section id="preface">
<h2 title="Preface">1. 序</h2>

<p>
資源の~fetchingは、
高~levelから見れば，要請を送ったら応答が返ってくる，それなりに単純な演算である。
しかしながら，その演算の詳細は、［
様々なものと~~複雑に入り組んでいるため，注意深く書き下ろされていなかった
］のが常であり，~APIの~~世代ごとに異なっている。
◎
At a high level, fetching a resource is a fairly simple operation. A request goes in, a response comes out. The details of that operation are however quite involved and used to not be written down carefully and differ from one API to the next.
</p>

<p>
数多くの~APIが資源を~fetchする能を供する
— 例えば
⇒＃
~HTMLの `img$e, `script$e 要素 ／
~CSSの `cursor^css, `list-style-image^css ／
~JS~APIの `navigator.sendBeacon()$m, `self.importScripts()$m
◎
Numerous APIs provide the ability to fetch a resource, e.g. HTML’s img and script element, CSS' cursor and list-style-image, the navigator.sendBeacon() and self.importScripts() JavaScript APIs.＼
</p>

<p>
`~Fetch標準^cite は、
これらの特能~用に統一された~architectureを供する。
それらすべてが、
~fetchingの様々な側面
— ~redirectや CORS ~protocolなど —
に関して一貫するよう。
◎
The Fetch Standard provides a unified architecture for these features so they are all consistent when it comes to various aspects of fetching, such as redirects and the CORS protocol.
</p>

<p>
`~Fetch標準^cite は、
`fetch()$m ~JS~APIも定義する。
それは、
~networkingの機能性のほとんどを
~~相応に低~levelな抽象-化の下で公開する。
◎
The Fetch Standard also defines the fetch() JavaScript API, which exposes most of the networking functionality at a fairly low level of abstraction.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
この仕様の外で定義された，ほとんどの［
~HTTP~header名／
~HTTP~method名／
~HTTP応答~状態s~code／
`~CSP指令$
］には、
それを定義する仕様（和訳）への~linkを追加している
（これらの~linkは、
原文~仕様にはあてがわれていない）。
</p>

	</section>
	<section id="terminology">
<h2 title="Infrastructure">2. 基盤</h2>

<p>
この仕様は `INFRA$r に依存する。
◎
This specification depends on the Infra Standard. [INFRA]
</p>

<p>
この仕様は、
次に挙げる標準による各種用語を利用する
⇒
`ABNF$r
`ENCODING$r
`HTML$r
`HTTP$r
`MIMESNIFF$r
`STREAMS$r
`URL$r
`WEBIDL$r
`WEBSOCKETS$r
◎
This specification uses terminology from ABNF, Encoding, HTML, HTTP, MIME Sniffing, Streams, URL, Web IDL, and WebSockets. [ABNF] [ENCODING] [HTML] [HTTP] [MIMESNIFF] [STREAMS] [URL] [WEBIDL] [WEBSOCKETS]
</p>

<p>
`~ABNF@
は、
~HTTP, および `RFC7405$r により増補された~ABNFを意味する
（特に，~HTTPによる # の追加【`~ABNF~list拡張$】）。
◎
ABNF means ABNF as augmented by HTTP (in particular the addition of #) and RFC 7405. [RFC7405]
</p>

<hr>

<p>
`資格証@
は、［
~HTTP~cookie ／ ~TLS~client証明書 ／ （~HTTP認証~用の）`認証~entry$
］の総称である。
`COOKIES$r `TLS$r `HTTP$r
◎
Credentials are HTTP cookies, TLS client certificates, and authentication entries (for HTTP authentication). [COOKIES] [TLS] [HTTP]
</p>

<hr>

<p>
`~fetch~params@
は、
次に挙げる`~item$sctからなる`構造体$であり，
`~fetch$~algoの内部状態管理~用に利用される：
◎
A fetch params is a struct used as a bookkeeping detail by the fetch algorithm. It has the following items:
</p>
<dl class="def-list">
	<dt>
`要請@fP
◎
request
</dt>
	<dd>
`要請$
◎
A request.
</dd>

	<dt>
`要請の本体~chunk長さの処理n@fP
（既定は ~NULL ）
◎
process request body chunk length (default null)
</dt>
	<dt>
`要請の本体~終了~時の処理n@fP
（既定は ~NULL ）
◎
process request end-of-body (default null)
</dt>
	<dt>
`応答の早期~hintの処理n@fP
（既定は ~NULL ）
◎
process early hints response (default null)
</dt>
	<dt>
`応答の処理n@fP
（既定は ~NULL ）
◎
process response (default null)
</dt>
	<dt>
`応答の本体~終了~時の処理n@fP
（既定は ~NULL ）
◎
process response end-of-body (default null)
</dt>
	<dt>
`応答の本体を消費する処理n@fP
（既定は ~NULL ）
◎
process response consume body (default null)
</dt>
	<dd>
~NULL ／~algo
【これらの~algoがとる引数については、`~fetching$を見よ。】
◎
Null or an algorithm.
</dd>

	<dt>
`~taskの行先@fP
（既定は ~NULL ）
◎
task destination (default null)
</dt>
	<dd>
~NULL／`大域~obj$／`並列~queue$
◎
Null, a global object, or a parallel queue.
</dd>

	<dt>
`非同一-生成元~能力は隔離されるか@fP
（既定は ~F ）
◎
cross-origin isolated capability (default false)
</dt>
	<dd>
真偽値
◎
A boolean.
</dd>

	<dt>
`制御器@fP
（既定は新たな`~fetch制御器$）
◎
controller (default a new fetch controller)
</dt>
	<dd>
`~fetch制御器$
◎
A fetch controller.
</dd>

	<dt>
`計時~報@fP
◎
timing info
</dt>
	<dd>
`~fetch計時~報$
◎
A fetch timing info.
</dd>

	<dt>
`~preloadされる応答の候補@fP
（既定は ~NULL ）
◎
preloaded response candidate (default null)
</dt>
	<dd>
~NULL ／ `pending^l ／ `応答$
◎
Null, "pending", or a response.
</dd>
</dl>

<p>
`~fetch制御器@
は、
次に挙げる`~item$sctからなる`構造体$であり，
`~fetch$の~call元が［
~fetchが開始された後に，当の~fetchに対し ある種の演算を遂行する
］ことを可能化するために利用される：
◎
A fetch controller is a struct used to enable callers of fetch to perform certain operations on it after it has started. It has the following items:
</p>
<dl class="def-list">
	<dt>
`状態@fC
（既定は `ongoing^l ）
◎
state (default "ongoing")
</dt>
	<dd>
`ongoing^l ／ `terminated^l ／ `aborted^l
◎
"ongoing", "terminated", or "aborted"
</dd>

	<dt>
`全部的な計時~報@fC
（既定は ~NULL ）
◎
full timing info (default null)
</dt>
	<dd>
~NULL／`~fetch計時~報$
◎
Null or a fetch timing info.
</dd>

	<dt>
`計時を報告する手続き@fC
（既定は ~NULL ）
◎
report timing steps (default null)
</dt>
	<dd>
~NULL／［
`大域~obj$を受容する~algo
］
◎
Null or an algorithm accepting a global object.
</dd>

	<dt>
`直列化された中止-事由@
(既定は ~NULL )
◎
serialized abort reason (default null)
</dt>
	<dd>
~NULL ／`~Record$
（ `StructuredSerialize$jA の結果）。
◎
Null or a Record (result of StructuredSerialize).
</dd>

	<dt>
`次回の手動~redirect手続き@fC
（既定は ~NULL ）
◎
next manual redirect steps (default null)
</dt>
	<dd>
~NULL ／［
何も受容しない~algo
］
◎
Null or an algorithm accepting nothing.
</dd>
</dl>

<div class="algo">
<p>
`計時を報告する@
~algoは、
所与の
( `~fetch制御器$ %制御器, `大域~obj$ %大域~obj )
に対し：
◎
To report timing for a fetch controller controller given a global object global:
</p>
<ol>
	<li>
~Assert：
%制御器 の`計時を報告する手続き$fC ~NEQ ~NULL
◎
Assert: controller’s report timing steps is non-null.
</li>
	<li>
%制御器 の`計時を報告する手続き$fC( %大域~obj )
◎
Call controller’s report timing steps with global.
</li>
</ol>
</div>

<div class="algo">
<p>
`次回の手動~redirect手続きを処理する@
~algoは、
所与の
( `~fetch制御器$ %制御器 )
に対し：
◎
To process the next manual redirect for a fetch controller controller:
</p>
<ol>
	<li>
~Assert：
%制御器 の`次回の手動~redirect手続き$fC ~NEQ ~NULL
◎
Assert: controller’s next manual redirect steps is non-null.
</li>
	<li>
%制御器 の`次回の手動~redirect手続き$fC()
◎
Call controller’s next manual redirect steps.
</li>
</ol>
</div>

<div class="algo">
<p>
`全部的な計時~報を抽出する@
~algoは、
所与の
( `~fetch制御器$ %制御器 )
に対し：
◎
To extract full timing info given a fetch controller controller:
</p>
<ol>
	<li>
~Assert：
%制御器 の`全部的な計時~報$fC ~NEQ ~NULL
◎
Assert: controller’s full timing info is non-null.
</li>
	<li>
~RET %制御器 の`全部的な計時~報$fC
◎
Return controller’s full timing info.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetchを中止する@
~algoは、
所与の
( `~fetch制御器$ %制御器, %~error（省略時は ε ） )
に対し：
◎
To abort a fetch controller controller with an optional error:
</p>
<ol>
	<li>
%制御器 の`状態$fC ~SET `aborted^l
◎
Set controller’s state to "aborted".
</li>
	<li>
<p>
~IF［
%~error ~NEQ ε
］：
</p>
		<ol>
			<li>
<p>
%制御器 の`直列化された中止-事由$ ~SET `StructuredSerialize$jA( %~error )
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~GOTO `~fallback^i
</p>
			</li>
			<li>
~RET
</li>
		</ol>
◎
Let fallbackError be an "AbortError" DOMException.
◎
Set error to fallbackError if it is not given.
◎
Let serializedError be StructuredSerialize(error). If that threw an exception, catch it, and let serializedError be StructuredSerialize(fallbackError).
◎
Set controller’s serialized abort reason to serializedError.
</li>
	<li>
`~fallback^i
⇒
%制御器 の`直列化された中止-事由$ ~SET `StructuredSerialize$jA( 【新たな】 `AbortError$E 例外 )
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`直列化された中止-事由を逆直列化する@
~algoは、
所与の
( ［
~NULL／`~Record$
］ %中止-事由, `~realm$ %~realm )
に対し：
◎
To deserialize a serialized abort reason, given null or a Record abortReason and a realm realm:
</p>
<ol>
	<li>
<p>
~IF［
%中止-事由 ~NEQ ~NULL
］：
</p>
		<ol>
			<li>
<p>
%逆直列化した~error ~SET `StructuredDeserialize$jA( %中止-事由, %~realm )
</p>

<p>
例外が投出されたときは、
~catchして
⇒
~GOTO `~fallback^i
</p>
			</li>
			<li>
~IF［
%逆直列化した~error ~NEQ `undefined^jv
］
⇒
~RET %逆直列化した~error
</li>
		</ol>
◎
Let fallbackError be an "AbortError" DOMException.
◎
Let deserializedError be fallbackError.
◎
If abortReason is non-null, then set deserializedError to StructuredDeserialize(abortReason, realm). If that threw an exception or returned undefined, then set deserializedError to fallbackError.
◎
Return deserializedError.
</li>
	<li>
`~fallback^i
⇒
~RET 【 %~realm に属する新たな】 `AbortError$E 例外
◎
↑</li>
</ol>
</div>

<div class="algo">
<p>
`~fetchを終了する@
~algoは、
所与の
( `~fetch制御器$ %制御器 )
に対し
⇒
%制御器 の`状態$fC ~SET `terminated^l
◎
To terminate a fetch controller controller, set controller’s state to "terminated".
</p>
</div>

<p>
所与の`~fetch~params$ %~fetch~params は、
次を満たすとき
`中止された@fP
とされる
⇒
%~fetch~params の`制御器$fPの`状態$fC ~EQ `aborted^l
◎
A fetch params fetchParams is aborted if its controller’s state is "aborted".
</p>

<p>
所与の`~fetch~params$ %~fetch~params は、
次を満たすとき
`取消された@fP
とされる
⇒
%~fetch~params の`制御器$fPの`状態$fC ~IN { `aborted^l, `terminated^l }
◎
A fetch params fetchParams is canceled if its controller’s state is "aborted" or "terminated".
</p>

<p>
`~fetch計時~報@
は、
次に挙げる`~item$sctからなる`構造体$であり，［
`資源の計時^cite `RESOURCE-TIMING$r ／
`~naviの計時^cite `NAVIGATION-TIMING$r
］に必要な計時~情報を保守するために利用される：
◎
A fetch timing info is a struct used to maintain timing information needed by Resource Timing and Navigation Timing. It has the following items: [RESOURCE-TIMING] [NAVIGATION-TIMING]
</p>
<dl class="def-list">
	<dt>
`開始~時刻@fT
（既定は 0 ）
◎
start time (default 0)
</dt>
	<dt>
`~redirect開始~時刻@fT
（既定は 0 ）
◎
redirect start time (default 0)
</dt>
	<dt>
`~redirect終了~時刻@fT
（既定は 0 ）
◎
redirect end time (default 0)
</dt>
	<dt>
`~redirect後からの開始~時刻@fT
（既定は 0 ）
◎
post-redirect start time (default 0)
</dt>
	<dt>
`最終-~sw開始~時刻@fT
（既定は 0 ）
◎
final service worker start time (default 0)
</dt>
	<dt>
`最終-~network要請~開始~時刻@fT
（既定は 0 ）
◎
final network-request start time (default 0)
</dt>
	<dt>
`最初の非最終-~network応答~開始~時刻@fT
（既定は 0 ）
◎
first interim network-response start time (default 0)
</dt>
	<dt>
`最終-~network応答~開始~時刻@fT
（既定は 0 ）
◎
final network-response start time (default 0)
</dt>
	<dt>
`終了~時刻@fT
（既定は 0 ）
◎
end time (default 0)
</dt>
	<dd>
`DOMHighResTimeStamp$I 値
◎
A DOMHighResTimeStamp.
</dd>

	<dt>
`最終-接続~計時~報@fT
（既定は ~NULL )
◎
final connection timing info (default null)
</dt>
	<dd>
~NULL ／ `接続~計時~報$
◎
Null or a connection timing info.
</dd>

	<dt>
`~server計時~header群@fT
（既定は « » )
◎
server-timing headers (default « »)
</dt>
	<dd>
文字列たちが成す`~list$
◎
A list of strings.
</dd>

	<dt>
`具現化を阻んでいるか@fT
（既定は ~F )
◎
render-blocking (default false)
</dt>
	<dd>
真偽値
◎
A boolean.
</dd>
</dl>

<p>
`応答~本体~報@
は、
次に挙げる`~item$sctからなる`構造体$であり，［
`資源の計時^cite `RESOURCE-TIMING$r ／
`~naviの計時^cite `NAVIGATION-TIMING$r
］に必要な情報を保守するために利用される：
◎
A response body info is a struct used to maintain information needed by Resource Timing and Navigation Timing. It has the following items: [RESOURCE-TIMING] [NAVIGATION-TIMING]
</p>
<dl class="def-list">
	<dt>
`符号化された~size@fT
（既定は 0 ）
◎
encoded size (default 0)
</dt>
	<dt>
`復号した~size@fT
（既定は 0 ）
◎
decoded size (default 0)
</dt>
	<dd>
整数【！number】
◎
A number.
</dd>
	<dd class="trans-note">【
`内容~符号法$により符号化された`内容$の~size，
それを復号した結果の~sizeを~byte数で与える。
（内容~符号法は適用されてない場合、同じになる。）
】</dd>

	<dt>
`内容~型@fT
（既定は空~文字列）
◎
content type (default the empty string)
</dt>
	<dd>
`~ASCII文字列$
◎
An ASCII string.
</dd>
</dl>

<div class="algo">
<p>
`不透明な計時~報を作成する@
~algoは、
所与の
( `~fetch計時~報$ %計時~報 )
に対し
⇒
~RET 新たな`~fetch計時~報$
⇒＃
`開始~時刻$fT ~SET %計時~報 の`開始~時刻$fT,
`~redirect後からの開始~時刻$fT ~SET %計時~報 の`開始~時刻$fT
◎
To create an opaque timing info, given a fetch timing info timingInfo, return a new fetch timing info whose start time and post-redirect start time are timingInfo’s start time.
</p>
</div>

<div class="algo">
<p>
`~fetch~taskを~queueする@
~algoは、
所与の
( ~algo %~algo, ［
`大域~obj$／`並列~queue$
］ %~taskの行先 )
に対し，
%~taskの行先 に応じて：
◎
To queue a fetch task, given an algorithm algorithm, a global object or a parallel queue taskDestination, run these steps:
</p>

<ul class="switch">
	<li>
`並列~queue$である
⇒
%~taskの行先 に`手続きを~enqueueする$( %~algo )
◎
If taskDestination is a parallel queue, then enqueue algorithm to taskDestination.
</li>
	<li>
`大域~obj$である
⇒
`大域~taskを~queueする$( `~network用~task~source$, %~taskの行先, %~algo )
◎
Otherwise, queue a global task on the networking task source with taskDestination and algorithm.
</li>
</ul>
</div>

<hr>

<div class="algo">
<p>
`整数を直列化する@
~algoは、
所与の
( 整数 %n )
に対し
⇒
~RET %n を最短な 10 進数で表現する文字列
◎
To serialize an integer, represent it as a string of the shortest possible decimal number.
</p>

<p class="XXX">
これは、
`INFRA$r にて もっと記述的な~algoに置換されることになる。
`Infra 課題 #201＠https://github.com/whatwg/infra/issues/201$
を見よ。
◎
This will be replaced by a more descriptive algorithm in Infra. See infra/201.
</p>
</div>

		<section id="url">
<h3 title="URL">2.1. ~URL</h3>

<p>
次に挙げるものが
`局所~scheme@
である
⇒＃
`about^l,
`blob^l,
`data^l
◎
A local scheme is "about", "blob", or "data".
</p>

<p>
`~URL$が
`局所的@
であるとは、
その`~scheme$urlが`局所~scheme$であることを意味する。
◎
A URL is local if its scheme is a local scheme.
</p>

<p class="note">注記：
この定義は、
`~referrer施策^cite `REFERRER$r
からも利用される。
◎
This definition is also used by Referrer Policy. [REFERRER]
</p>

<p>
次に挙げるものが
`~HTTP_S~scheme@
である
⇒＃
`http^l,
`https^l
◎
An HTTP(S) scheme is "http" or "https".
</p>

<p>
次に挙げるものが
`~fetch~scheme@
である
⇒＃
`about^l,
`blob^l,
`data^l,
`file^l,
`~HTTP_S~scheme$
◎
A fetch scheme is "about", "blob", "data", "file", or an HTTP(S) scheme.
</p>

<p class="note">注記：
`~HTTP_S~scheme$, `~fetch~scheme$
は~HTMLからも利用される。
`HTML$r
◎
HTTP(S) scheme and fetch scheme are also used by HTML. [HTML]
</p>

		</section>
		<section id="http">
<h3 title="HTTP">2.2. ~HTTP</h3>

<p>
`~fetching$は，単なる~HTTPを超えるものを包摂するが、
~HTTPからいくつかの概念を流用し，それらを［
他の手段（例えば `data^c ~URL）を通して得された資源
］に対してもあてはめる。
◎
While fetching encompasses more than just HTTP, it borrows a number of concepts from HTTP and applies these to resources obtained via other means (e.g., data URLs).
</p>

<p>
`~HTTP~tab-or-space@
は［
`0009^U `TAB^cn ／ `0020^U `SPACE^cn
］である。
◎
An HTTP tab or space is U+0009 TAB or U+0020 SPACE.
</p>

<p>
`~HTTP空白@
は［
`000A^U `LF^cn ／ `000D^U `CR^cn ／ `~HTTP~tab-or-space$
］である。
◎
HTTP whitespace is U+000A LF, U+000D CR, or an HTTP tab or space.
</p>

<p class="note">注記：
`~HTTP空白$が有用になるのは、
~HTTP~headerの文脈の外側で再利用される特定の構成子（例：`~MIME型$）に限られる。
~HTTP~header値~用には，`~HTTP~tab-or-space$の利用が選好され、
その文脈の外側では，`~ASCII空白$が選好される。
`~ASCII空白$と違って、
これは `000C^U `FF^cn を含まない。
◎
HTTP whitespace is only useful for specific constructs that are reused outside the context of HTTP headers (e.g., MIME types). For HTTP header values, using HTTP tab or space is preferred, and outside that context ASCII whitespace is preferred. Unlike ASCII whitespace this excludes U+000C FF.
</p>

<p>
`~HTTP改行~byte@
は、［
`0A^X `LF^smb ／ `0D^X `CR^smb
］である。
◎
An HTTP newline byte is 0x0A (LF) or 0x0D (CR).
</p>

<p>
`~HTTP~tab-or-space~byte@
は、［
`09^X `HT^smb ／ `20^X `SP^smb
］である。
◎
An HTTP tab or space byte is 0x09 (HT) or 0x20 (SP).
</p>

<p>
`~HTTP空白~byte@
は、［
`~HTTP改行~byte$ ／ `~HTTP~tab-or-space~byte$
］である。
◎
An HTTP whitespace byte is an HTTP newline byte or HTTP tab or space byte.
</p>

<div class="algo">
<p>
`~HTTP引用符付き文字列を収集する@
~algoは、
所与の
( `文字列$ %入力, `位置~変数$ %位置, %値を抽出するか ~IN { `値を抽出する^i, ε }（省略時は ε ） )
に対し：
◎
To collect an HTTP quoted string from a string input, given a position variable position and an optional boolean extract-value (default false):
</p>
<ol>
	<li>
%開始~位置 ~LET %位置
◎
Let positionStart be position.
</li>
	<li>
%値 ~LET 空~文字列
◎
Let value be the empty string.
</li>
	<li>
~Assert：
%位置↗ ~EQ `0022^U `"^smb
◎
Assert: the code point at position within input is U+0022 (").
</li>
	<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
%値 に次の結果を付加する
⇒
%入力 内の %位置 から { `0022^U `"^smb, `005C^U `\^smb } 以外の`符号位置~並びを収集する$
◎
Append the result of collecting a sequence of code points that are not U+0022 (") or U+005C (\) from input, given position, to value.
</li>
			<li>
~Assert：
%位置↗ ~IN { ε, `0022^U `"^smb, `005C^U `\^smb }
◎
If position is past the end of input, then break.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `005C^U `\^smb
］：
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
~IF［
%位置↗ ~NEQ ε
］
⇒＃
%値 に %位置↗ を付加する；
%位置 ~INCBY 1；
~CONTINUE
</li>
					<li>
%値 に `005C^U `\^smb を付加する
</li>
				</ol>

◎
Let quoteOrBackslash be the code point at position within input.
◎
Advance position by 1.
◎
If quoteOrBackslash is U+005C (\), then:
• If position is past the end of input, then append U+005C (\) to value and break.
• Append the code point at position within input to value.
• Advance position by 1.
</li>
			<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
%位置 ~INCBY 1
◎
↑↓</li>
			<li>
~BREAK
◎
Otherwise:
• Assert: quoteOrBackslash is U+0022 (").
• Break.
</li>
		</ol>
	</li>
	<li>
~IF［
%値を抽出するか ~EQ `値を抽出する^i
］
⇒
~RET %値
◎
If extract-value is true, then return value.
</li>
	<li>
~RET %入力 の中の［
%開始~位置 から ( %位置 ~MINUS 1 ) まで
］を成す`符号位置$並び
【！inclusive は先頭のみ（例：この時点で %位置↗ は ε かもしれない）】
◎
Return the code points from positionStart to position, inclusive, within input.
</li>
</ol>

<div class="example">
<table><thead>
<tr><th>入力
<th>出力
<th>出力（ `値を抽出する^i ）
<th>最終- %位置 値†
<tbody>

<tr><td>`<mark>"\</mark>^l
<td>`"\^l
<td>`\^l
<td>2

<tr><td>`<mark>"Hello"</mark> World^l
<td>`"Hello"^l
<td>`Hello^l
<td>7

<tr><td>`<mark>"Hello \\ World\""</mark>^l
<td>`"Hello \\ World\""^l
<td>`Hello \ World"^l
<td>18
</table>

<p><small>†
この例では、
`位置~変数$ %位置 は，常に 0 から開始するとする。
</small></p>

◎
Input 	Output 	Output with extract-value set to true 	Final position variable value
""\" 	""\" 	"\" 	2
""Hello" World" 	""Hello"" 	"Hello" 	7
""Hello \\ World\""" 	""Hello \\ World\""" 	"Hello \ World"" 	18
◎
The position variable always starts at 0 in these examples.
</div>
</div>

			<section id="methods">
<h4 title="Methods">2.2.1. ~method</h4>

<p>
`~method@
は、
`method$p ~token生成規則に合致する`~byte列$である。
【~HTTPにおける`要請~method$に対応する。】
◎
A method is a byte sequence that matches the method token production.
</p>

<p>
`~CORS安全とされる~method@
は、
次のいずれかの`~method$である
⇒＃
`GET$hm,
`HEAD$hm,
`POST$hm
◎
A CORS-safelisted method is a method that is `GET`, `HEAD`, or `POST`.
</p>

<p>
`禁止~method@
は、
次のいずれかに`~byte大小無視$で合致する`~method$である
`HTTPVERBSEC1$r
`HTTPVERBSEC2$r
`HTTPVERBSEC3$r
⇒＃
`CONNECT$hm,
`TRACE$hm,
`TRACK$hm
◎
A forbidden method is a method that is a byte-case-insensitive match for `CONNECT`, `TRACE`, or `TRACK`. [HTTPVERBSEC1], [HTTPVERBSEC2], [HTTPVERBSEC3]
</p>

<div class="algo">
<div>
<p>
`~methodを正規化する@
~algoは、
所与の
( `~method$ %~method )
に対し：
</p>
<ol>
	<li>
<p>
« `DELETE$hm, `GET$hm, `HEAD$hm, `OPTIONS$hm, `POST$hm, `PUT$hm »
を成す
~EACH( %互換~method )
に対し
⇒
~IF［
%~method と %互換~method は`~byte大小無視$で合致する
］
⇒
~RET %互換~method
</li>
	<li>
~RET %~method
</li>
</ol>
◎
To normalize a method, if it is a byte-case-insensitive match for `DELETE`, `GET`, `HEAD`, `OPTIONS`, `POST`, or `PUT`, byte-uppercase it.
</div>

<p class="note">注記：
`~method$は実際には “文字大小区別” であるが、［
後方-互換性, 各種~API間の一貫性
］を得るため，`正規化-$mdが行われる。
◎
Normalization is done for backwards compatibility and consistency across APIs as methods are actually "case-sensitive".
</p>
</div>

<p class="example" id="example-normalization">
`patch^hm を利用した結果は、
ほぼ間違いなく `405 Method Not Allowed^bl になるであろう。
`PATCH^hm の方がずっと成功する見込みが高い。
◎
Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.
</p>

<p class="note">注記：
`~method$に制約はない。
`CHICKEN^hm （ `CHECKIN^hm の誤記ではない）でも，まったく受容-可能である。
`正規化-$mdされるものを除き、
文字大小~法についての制約もない。
一貫性を得るため，大文字が奨励されるが、
`Egg^hm や `eGg^hm でもかまわない。
◎
There are no restrictions on methods. `CHICKEN` is perfectly acceptable (and not a misspelling of `CHECKIN`). Other than those that are normalized there are no casing restrictions either. `Egg` or `eGg` would be fine, though uppercase is encouraged for consistency.
</p>

			</section>
			<section id="terminology-headers">
<h4 title="Headers">2.2.2. ~header</h4>

<p class="note">注記：
~HTTPは、
一般に，~headerを指して［
“~field” ／ “~header~field”
］という。
~web~platformは、
より口語的な用語 “~header” を利用する。
`HTTP$r
◎
HTTP generally refers to a header as a "field" or "header field". The web platform uses the more colloquial term "header". [HTTP]
</p>

<p>
`~header~list@
は、
`~header$たちが成す`~list$であり，
初期~時は « » とする。
◎
A header list is a list of zero or more headers. It is initially « ».
</p>

<p class="trans-note">【
~HTTPにおける~messageの`~header節$に対応する。
現時点では、
この仕様には`~trailer$は現れない。
】</p>

<p class="note">注記：
`~header~list$は、
本質的には特化された~multimapである
— すなわち、
( ~key, 値 ) が成す~pairたちが成す有順序~listであって，~keyが重複し得るものである。
`Set-Cookie$h 以外の~headerは，
~client側~JSに公開されるときには常に結合されるので、
実装は
— `Set-Cookie^h ~header用の~data構造も~supportする限り —
より効率的な表現を選ぶこともできる。
◎
A header list is essentially a specialized multimap: an ordered list of key-value pairs with potentially duplicate keys. Since headers other than `Set-Cookie` are always combined when exposed to client-side JavaScript, implementations could choose a more efficient representation, as long as they also support an associated data structure for `Set-Cookie` headers.
</p>

<div class="algo">
<p>
`~header~list$ %~list から
`有構造~field値を取得する@
~algoは、
所与の
( `~header名$ %名前, 文字列 %型 )
に対し，［
~NULL／`有構造~field値$
］を返す：
◎
To get a structured field value given a header name name and a string type from a header list list, run these steps. They return null or a structured field value.
</p>
<ol>
	<li>
~Assert：
%型 ~IN { `辞書^i, `~list^i, `~item^i }
【！"dictionary", "list", or "item"】
◎
Assert: type is one of "dictionary", "list", or "item".
</li>
	<li>
%値 ~LET `~header~listから値を取得する$( %~list, %名前 )
◎
Let value be the result of getting name from list.
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If value is null, then return null.
</li>
	<li>
%結果 ~LET `有構造~fieldを構文解析する$( %値, %型 )
◎
Let result be the result of parsing structured fields with input_string set to value and header_type set to type.
</li>
	<li>
~IF［
前~段の構文解析に失敗した
］
⇒
~RET ~NULL
◎
If parsing failed, then return null.
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="note">注記：
`有構造~field値を取得する$は、［
`~header$が無いこと,
その`値$hdを`有構造~field値$として構文解析するのに失敗したこと
］を意図的に判別しない。
これは、
~web~platformにわたる一様な処理を確保する。
◎
Get a structured field value intentionally does not distinguish between a header not being present and its value failing to parse as a structured field value. This ensures uniform processing across the web platform.
</p>
</div>

<div class="algo">
<p>
`~header~list$ %~list 内で
`有構造~field値を設定する@
~algoは、
所与の
( `~tuple$( `~header名$ %名前, `有構造~field値$ %有構造~値 ) )
に対し：
◎
To set a structured field value given a tuple (header name name, structured field value structuredValue), in a header list list:
</p>
<ol>
	<li>
%直列化した値 ~LET `有構造~fieldを直列化する$( %有構造~値 )
◎
Let serializedValue be the result of executing the serializing structured fields algorithm on structuredValue.
</li>
	<li>
%~list 内で`~headerを設定する$( ( %名前, %直列化した値 ) )
◎
Set (name, serializedValue) in list.
</li>
</ol>

<p class="note">注記：
`有構造~field値$は、
興味を引く効率的な仕方で［
~HTTPが（最終的に）直列化できる~obj
］として定義される。
~fetchは，当面の間は、
`~header値$を`~byte列$に限り~supportする。
すなわち、
これらの~objを`~header~list$内に設定するためには，直列化を介する他になく、
`~header~list$から得するためには，構文解析する他にない。
将来には、
それらが~objである事は，端点間で保全されるであろう。
`RFC9651$r
◎
Structured field values are defined as objects which HTTP can (eventually) serialize in interesting and efficient ways. For the moment, Fetch only supports header values as byte sequences, which means that these objects can be set in header lists only via serialization, and they can be obtained from header lists only by parsing. In the future the fact that they are objects might be preserved end-to-end. [RFC9651]
</p>
</div>

<hr>

<p>
`~header~list$ %~list が`~header名$ %名前 を
`包含する@hd
とは、
%~list 内に %名前 を`名前に持つ~header$が在る
— そのような`~header$を %~list が`包含して$いる —
ことをいう。
◎
A header list list contains a header name name if list contains a header whose name is a byte-case-insensitive match for name.
</p>

<p class="trans-note">【
この訳（および，この仕様を参照している和訳）では、
この用語は利用せず，直に
“%~list 内に %名前 を`名前に持つ~header$が在る”
（その否定は “無い” ）と記す。
】</p>

<div class="algo">
<p>
`~header~listから値を取得する@
~algoは，所与の
( `~header~list$ %~list, `~header名$ %名前 )
に対し，［
~NULL ／`~header値$
］を返す：
◎
To get a header name name from a header list list, run these steps. They return null or a header value.
</p>
<ol>
	<li>
~IF［
%~list 内に %名前 を`名前に持つ~header$は無い
］
⇒
~RET ~NULL
◎
If list does not contain name, then return null.
</li>
	<li>
~RET %~list 内の［
%名前 を`名前に持つ~header$
］すべての`値$hdを互いに［
`2C^X `20^X
］並びで分離して順に~~連結した結果
◎
Return the values of all headers in list whose name is a byte-case-insensitive match for name, separated from each other by 0x2C 0x20, in order.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~listから値を取得して復号して分割する@
~algoは、
所与の
( `~header~list$ %~list, `~header名$ %名前 )
に対し，［
~NULL ／`文字列$たちが成す`~list$
］を返す：
◎
To get, decode, and split a header name name from header list list, run these steps. They return null or a list of strings.
</p>
<ol>
	<li>
%値 ~LET `~header~listから値を取得する$( %~list, %名前 )
◎
Let value be the result of getting name from list.
</li>
	<li>
~IF［
%値 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If value is null, then return null.
</li>
	<li>
~RET `~header値を復号して分割する$( %値 )
◎
Return the result of getting, decoding, and splitting value.
</li>
</ol>
</div>

<div class="example">
<p>
`~header~listから値を取得して復号して分割する$が、
その引数 %名前 に `A^bl が与えられた下で，実施において どう機能するかを次に示す：
◎
This is how get, decode, and split functions in practice with `A` as the name argument:
</p>

<table><thead>
<tr><th>
（~network上の）~header列
◎
Headers (as on the network)
<th>出力
<tbody>

<tr><td><pre class="lang-http">
A: nosniff,
</pre>
<td rowspan="2">« `nosniff^l, "" »

<tr><td><pre class="lang-http">
A: nosniff
B: sniff
A:
</pre>

<tr><td><pre class="lang-http">
A:
B: sniff
</pre>
<td>« "" »

<tr><td><pre class="lang-http">
B: sniff
</pre>
<td>~NULL

<tr><td><pre class="lang-http">
A: text/html;", x/x
</pre>
<td rowspan="2">« `text/html;", x/x^l »

<tr><td><pre class="lang-http">
A: text/html;"
A: x/x
</pre>

<tr><td><pre class="lang-http">
A: x/x;test="hi",y/y
</pre>
<td rowspan="2">« `x/x;test="hi"^l, `y/y^l »

<tr><td><pre class="lang-http">
A: x/x;test="hi"
C: **bingo**
A: y/y
</pre>

<tr><td><pre class="lang-http">
A: x / x,,,1
</pre>
<td rowspan="2">« `x / x^l, "", "", `1^l »

<tr><td><pre class="lang-http">
A: x / x
A: ,
A: 1
</pre>

<tr><td><pre class="lang-http">
A: "1,2", 3
</pre>
<td rowspan="2">« `"1,2"^l, `3^l »

<tr><td><pre class="lang-http">
A: "1,2"
D: 4
A: 3
</pre>
</table>
</div>

<div class="algo">
<p>
`~header値を復号して分割する@
~algoは、
所与の
( `~header値$ %~header値 )
に対し，`文字列$たちが成す`~list$を返す：
◎
To get, decode, and split a header value value, run these steps. They return a list of strings.
</p>
<ol>
	<li>
%入力 ~LET `同型に復号する$( %~header値 )
◎
Let input be the result of isomorphic decoding value.
</li>
	<li>
%位置 ~LET %入力 内の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%値~群 ~LET 新たな`~list$
◎
Let values be a list of strings, initially « ».
</li>
	<li>
%値 ~LET 空~文字列
◎
Let temporaryValue be the empty string.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
<p>
%値 に次の結果を付加する
⇒
%入力 内の %位置 から { `0022^U `"^smb, `002C^U `,^smb } 以外の`符号位置~並びを収集する$
◎
Append the result of collecting a sequence of code points that are not U+0022 (") or U+002C (,) from input, given position, to temporaryValue.
</p>

<p class="note">注記：
結果は空~文字列にもなり得る。
◎
The result might be the empty string.
</p>
			</li>
			<li>
<p>
~IF［
%位置↗ ~EQ `0022^U `"^smb
］：
◎
If position is not past the end of input and the code point at position within input is U+0022 ("):
</p>
				<ol>
					<li>
%値 に次の結果を付加する
⇒
`~HTTP引用符付き文字列を収集する$( %入力, %位置 )
◎
Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.
</li>
					<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~CONTINUE
◎
If position is not past the end of input, then continue.
</li>
				</ol>
			</li>
			<li>
%値 から［
頭部, 尾部
］を成すすべての`~HTTP~tab-or-space$を除去する
◎
Remove all HTTP tab or space from the start and end of temporaryValue.
</li>
			<li>
%値~群 に %値 を`付加する$
◎
Append temporaryValue to values.
</li>
			<li>
%値 ~SET 空~文字列
◎
Set temporaryValue to the empty string.
</li>
			<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET %値~群
◎
If position is past the end of input, then return values.
</li>
			<li>
~Assert：
%位置↗ ~EQ `002C^U `,^smb
◎
Assert: the code point at position within input is U+002C (,).
</li>
			<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
上の~algoは、
特に認められた~call元を除き，直に呼出されることはない。
代わりに，`~header~listから値を取得して復号して分割する$を利用すること。
◎
Except for blessed call sites, the algorithm directly above is not to be invoked directly. Use get, decode, and split instead.
</p>
</div>

<div class="algo">
<p>
`~header~list$ %~list に
`~headerを付加する@
~algoは、
所与の
( `~header$ ( %名前, %値 ) )
に対し：
◎
To append a header (name, value) to a header list list:
</p>
<ol>
	<li>
<p>
~IF［
%~list 内に［
%名前 を`名前に持つ~header$
］は在る
］
⇒
%名前 ~SET そのような`~header$のうち最初のものの`名前$hd
◎
If list contains name, then set name to the first such header’s name.
</p>

<p class="note">注記：
これは、
%~list 内に該当する`~header$がすでにあれば，
その`名前$hdの文字大小を再利用させる。
該当する~headerが複数あれば、
それらすべての名前は同じ文字大小にされることになる。
◎
This reuses the casing of the name of the header already in list, if any. If there are multiple matched headers their names will all be identical.
</p>
	</li>
	<li>
%~list に ( %名前, %値 ) を`付加する$
◎
Append (name, value) to list.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~list$ %~list から
`~headerを削除する@
~algoは、
所与の
( `~header名$ %名前 )
に対し
⇒
%~list から［
%名前 を`名前に持つ~header$
］をすべて`除去する$
◎
To delete a header name name from a header list list, remove all headers whose name is a byte-case-insensitive match for name from list.
</p>
</div>

<div class="algo">
<p>
`~header~list$ %~list 内で
`~headerを設定する@
~algoは、
所与の
( `~header$ ( %名前, %値 ) )
に対し：
◎
To set a header (name, value) in a header list list:
</p>
<ol>
	<li>
~IF［
%~list 内に［
%名前 を`名前に持つ~header$
］は在る
］
⇒
そのような`~header$のうち
⇒＃
最初のものに対しては，その`値$hd ~SET %値；
他のものは， %~list から`除去する$
◎
If list contains name, then set the value of the first such header to value and remove the others.
</li>
	<li>
~ELSE
⇒
%~list に ( %名前, %値 ) を`付加する$
◎
Otherwise, append (name, value) to list.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~list$ %~list 内で
`~headerを結合する@
~algoは、
所与の
( `~header$ ( %名前, %値 ) )
に対し：
◎
To combine a header (name, value) in a header list list:
</p>
<ol>
	<li>
~IF［
%~list 内に［
%名前 を`名前に持つ~header$
］は在る
］
⇒
そのような`~header$のうち，最初のものに対し
⇒
その`値$hdの末尾に［
`2C^X, `20^X, %値
］を順に付加する
◎
If list contains name, then set the value of the first such header to its value, followed by 0x2C 0x20, followed by value.
</li>
	<li>
~ELSE
⇒
%~list に ( %名前, %値 ) を`付加する$
◎
Otherwise, append (name, value) to list.
</li>
</ol>

<p class="note">注記：
`~headerを結合する$は、
もっぱら［
`XMLHttpRequest$I 用／
`~WebSocket接続を確立する$ため
］に在る。
◎
Combine is used by XMLHttpRequest and the WebSocket protocol handshake.
</p>
</div>

<div class="algo">
<p>
`~header名たちを小文字~化して~sortした集合に変換する@
~algoは、
所与の
( `名前$hdたちが成す`~list$ %~header名~群 )
に対し，`~header名$たちが成す`有順序~集合$を返す：
◎
To convert header names to a sorted-lowercase set, given a list of names headerNames, run these steps. They return an ordered set of header names.
</p>
<ol>
	<li>
%~header名~集合 ~LET 新たな`有順序~集合$
◎
Let headerNamesSet be a new ordered set.
</li>
	<li>
%~header名~群 を成す
~EACH( %名前 )
に対し
⇒
%~header名~集合 に次の結果を`付加する$set
⇒
`~byte小文字~化する$( %名前 )
◎
For each name of headerNames, append the result of byte-lowercasing name to headerNamesSet.
</li>
	<li>
~RET 
`~listを昇順に~sortする$( %~header名~集合, `未満の~byte列$ )
◎
Return the result of sorting headerNamesSet in ascending order with byte less than.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~listを~sortして結合する@
~algoは、
所与の
( `~header~list$ %~list )
に対し，`~header~list$を返す：
◎
To sort and combine a header list list, run these steps. They return a header list.
</p>
<ol>
	<li>
%~header群 ~LET 新たな`~header~list$
◎
Let headers be a header list.
</li>
	<li>
%名前~群 ~LET `~header名たちを小文字~化して~sortした集合に変換する$( %~list 内のすべての`~header$の`名前$hd )
◎
Let names be the result of convert header names to a sorted-lowercase set with all the names of the headers in list.
</li>
	<li>
<p>
%名前~群 を成す
~EACH( %名前 )
に対し：
◎
For each name of names:
</p>
		<ol>
			<li>
<p>
~IF［
%名前 ~EQ `set-cookie^bl
］
⇒
%値~群 を成す
~EACH( %名前 を`名前に持つ~header$ %~header )
に対し
⇒
%~header群 に ( %名前, %~header の`値$hd ) を`付加する$
◎
If name is `set-cookie`, then:
• Let values be a list of all values of headers in list whose name is a byte-case-insensitive match for name, in order.
• For each value of values:
•• Append (name, value) to headers.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%値 ~LET `~header~listから値を取得する$( %~list, %名前 )
◎
Let value be the result of getting name from list.
</li>
					<li>
~Assert：
%値 ~NEQ ~NULL
◎
Assert: value is non-null.
</li>
					<li>
%~header群 に ( %名前, %値 ) を`付加する$
◎
Append (name, value) to headers.
</li>
				</ol>
			</li>
		</ol>
	<li>
~RET %~header群
◎
Return headers.
</li>
</ol>
</div>

<hr>

<p>
`~header@
は、
`~tuple$であり，
`~header名$を与える
`名前@hd
,
`~header値$を与える
`値@hd
からなる。
◎
A header is a tuple that consists of a name (a header name) and value (a header value).
</p>

<p class="trans-note">【
［
`~header$／`名前$hd／`値$hd
］は、
~HTTPにおける［
`~field行l$／`~field名$／`~field行l値$
］に対応する。
】</p>

<p>
所与の`~header名$ %名前 を
`名前に持つ~header@
とは、
`~header$であって，その`名前$hdが［
`~byte大小無視$で %名前 に合致する
］ものを指す。
</p>

<p class="trans-note">【
言い換えれば、
`~header名$は，常に`~byte大小無視$で比較される
— 元々の~HTTP~protocolが，~header名の文字大小を区別しないので。
】【
この用語は、
他所を簡便に記すために，この訳にて導入している。
】</p>

<p>
`~header名@
は、
`field-name$p ~token生成規則に合致する`~byte列$である。
◎
A header name is a byte sequence that matches the field-name token production.
</p>

<p class="trans-note">【
どの`~byte列$も、
ある`~header名$に`~byte大小無視$で合致するならば，`~header名$になる。
】</p>

<p>
`~header値@
は、
~AND↓ を満たす`~byte列$である：
◎
A header value is a byte sequence that matches the following conditions:
</p>
<ul>
	<li>
［
頭部, 尾部
］を成す`~HTTP~tab-or-space~byte$は無い。
◎
Has no leading or trailing HTTP tab or space bytes.
</li>
	<li>
［
`00^X `NUL^smb, `~HTTP改行~byte$
］を包含しない。
◎
Contains no 0x00 (NUL) or HTTP newline bytes.
</li>
</ul>

<p class="trans-note">【
定義により、
`~header値$は空な~byte列もとり得る。
】</p>

<p class="note">注記：
`~header値$は、
`field-value$p ~token生成規則の用語では定義されない
— それは、
`配備-済みな内容と互換でない＠https://github.com/httpwg/http-core/issues/215$ので。
◎
The definition of header value is not defined in terms of the field-value token production as it is not compatible with deployed content.
</p>

<div class="algo">
<p>
`値を正規化する@
~algoは、
所与の
( `~byte列$ %値 )
に対し
⇒
~RET %値 から［
頭部, 尾部
］を成す`~HTTP空白~byte$並びを除去した結果
◎
To normalize a byte sequence potentialValue, remove any leading and trailing HTTP whitespace bytes from potentialValue.
</p>
</div>

<hr>

<div class="algo">
<p>
（`~header$用の）所与の
( %名前, %値 )
は、
次の手続きが ~T を返すならば，
`~CORS安全とされる要請~header@
を成すとされる：
◎
To determine whether a header (name, value) is a CORS-safelisted request-header, run these steps:
</p>
<ol>
	<li>
~IF［
%値 の`長さ$ ~GT 128
］
⇒
~RET ~F
◎
If value’s length is greater than 128, then return false.
</li>
	<li>
<p>
［
%名前 は、
次に挙げるどれと`~byte大小無視$で合致するか
］に応じて：
◎
Byte-lowercase name and switch on the result:
</p>

		<ul class="switch">
			<li>
`Accept$h
⇒
~IF［
%値 を成す ある~byteは、
`~CORS安全でない要請~header~byte$である
］
⇒
~RET ~F
◎
If value contains a CORS-unsafe request-header byte, then return false.
</li>
			<li>
<p>
`Accept-Language$h ／
`Content-Language$h ：
</p>
				<ol>
					<li>
~IF［
%値 を成す ある~byteは、
次に挙げる どれでもない
］…
⇒＃
`20^X `SP^smb,
`2A^X `*^smb,
`2C^X `,^smb,
`2D^X `-^smb,
`2E^X `.^smb,
`30^X `0^smb 〜 `39^X `9^smb,
`3B^X `;^smb,
`3D^X `=^smb,
`41^X `A^smb 〜 `5A^X `Z^smb,
`61^X `a^smb 〜 `7A^X `z^smb,
◎終
…ならば
⇒
~RET ~F
</li>
				</ol>
◎
If value contains a byte that is not in the range 0x30 (0) to 0x39 (9), inclusive, is not in the range 0x41 (A) to 0x5A (Z), inclusive, is not in the range 0x61 (a) to 0x7A (z), inclusive, and is not 0x20 (SP), 0x2A (*), 0x2C (,), 0x2D (-), 0x2E (.), 0x3B (;), or 0x3D (=), then return false.
</li>
			<li>
<p>
`Content-Type$h：
</p>
				<ol>
					<li>
~IF［
%値 を成す ある~byteは、
`~CORS安全でない要請~header~byte$である
］
⇒
~RET ~F
◎
If value contains a CORS-unsafe request-header byte, then return false.
</li>
					<li>
%~MIME型 ~LET `~MIME型を構文解析する$( `同型に復号する$( %値 ) )
◎
Let mimeType be the result of parsing the result of isomorphic decoding value.
</li>
					<li>
~IF［
%~MIME型 ~EQ `失敗^i
］
⇒
~RET ~F
◎
If mimeType is failure, then return false.
</li>
					<li>
~IF［
%~MIME型 の`~essence$ ~NIN { `application/x-www-form-urlencoded^l, `multipart/form-data^l, `text/plain^l }
］
⇒
~RET ~F
◎
If mimeType’s essence is not "application/x-www-form-urlencoded", "multipart/form-data", or "text/plain", then return false.
</li>
			</ol>

<p class="warning">
これは、
`~header~listから~MIME型を抽出する$ を意図的に利用しない。
その~algoは~~寛容にされており、
~serverが実装することは期待されていないので。
◎
This intentionally does not use extract a MIME type as that algorithm is rather forgiving and servers are not expected to implement it.
</p>

<div class="example">
<p>
`~header~listから~MIME型を抽出する$ が利用された場合、
次の要請からは~CORS予行~要請は生じなくなり，
~server上の素朴な構文解析器は要請の本体を~JSONとして扱うかもしれない：
◎
If extract a MIME type were used the following request would not result in a CORS preflight and a naïve parser on the server might treat the request body as JSON:
</p>

<pre class="lang-js">
fetch("https://victim.example/naïve-endpoint", {
  method: "POST",
  headers: [
    ["Content-Type", "application/json"],
    ["Content-Type", "text/plain"]
  ],
  credentials: "include",
  body: JSON.stringify(exerciseForTheReader)
});
</pre>
</div>
			</li>
			<li>
<p>
`Range$h：
</p>
				<ol>
					<li>
%範囲~値 ~LET `単純な範囲~header値を構文解析する$( %値, ~F )
◎
Let rangeValue be the result of parsing a single range header value given value and false.
</li>
					<li>
~IF［
%範囲~値 ~EQ `失敗^i
］
⇒
~RET ~F
◎
If rangeValue is failure, then return false.
</li>
					<li>
~IF［
%範囲~値[ 0 ] ~EQ ~NULL
］
⇒
~RET ~F
◎
If rangeValue[0] is null, then return false.
</li>
				</ol>
<p class="note">注記：
歴史的に，~web~browserは［
`bytes=-500^bl などの範囲
］を発してこなかったので、
この~algoは，それらを安全としない。
◎
As web browsers have historically not emitted ranges such as `bytes=-500` this algorithm does not safelist them.
</p>
			</li>
			<li>
その他
⇒
~RET ~F
◎
Otherwise
• Return false.
</li>
		</ul>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<p class="note">注記：
~CORS安全とされる `Content-Type$h ~headerには，制限付きな例外がある
— `§ ~CORS~protocol例外＠#cors-protocol-exceptions$
を見よ。
◎
There are limited exceptions to the `Content-Type` header safelist, as documented in CORS protocol exceptions.
</p>

<p>
次に挙げる~byteは、
`~CORS安全でない要請~header~byte@
とされる
⇒＃
`0^X 〜 `08^X,
`0A^X 〜 `1F^X,
`22^X `"^smb,
`28^X `(^smb,
`29^X `)^smb,
`3A^X `:^smb,
`3C^X `&lt;^smb,
`3E^X `&gt;^smb,
`3F^X `?^smb,
`40^X `@^smb,
`5B^X `[^smb,
`5C^X `\^smb,
`5D^X `]^smb,
`7B^X `{^smb,
`7D^X `}^smb,
`7F^X `DEL^smb
◎
A CORS-unsafe request-header byte is a byte byte for which one of the following is true:
• byte is less than 0x20 and is not 0x09 HT
• byte is 0x22 ("), 0x28 (left parenthesis), 0x29 (right parenthesis), 0x3A (:), 0x3C (&lt;), 0x3E (&gt;), 0x3F (?), 0x40 (@), 0x5B ([), 0x5C (\), 0x5D (]), 0x7B ({), 0x7D (}), or 0x7F DEL.
</p>

<div class="algo">
<p>
`~CORS安全でない要請~header名たち@
を決定する
~algoは、
所与の
( `~header~list$ %~header群 )
に対し：
◎
The CORS-unsafe request-header names, given a header list headers, are determined as follows:
</p>
<ol>
	<li>
%安全でない名前~群 ~LET 新たな`~list$
◎
Let unsafeNames be a new list.
</li>
	<li>
%安全でないかもしれない名前~群 ~LET 新たな`~list$
◎
Let potentiallyUnsafeNames be a new list.
</li>
	<li>
%安全な値の合計~size ~LET 0
◎
Let safelistValueSize be 0.
</li>
	<li>
<p>
%~header群 を成す
~EACH( %~header )
に対し：
◎
For each header of headers:
</p>
		<ol>
			<li>
%名前 ~LET %~header の`名前$hd
◎
↓</li>
			<li>
%値 ~LET %~header の`値$hd
◎
↓</li>
			<li>
~IF［
( %名前, %値 ) は`~CORS安全とされる要請~header$を成さない
］
⇒
%安全でない名前~群 に %名前 を`付加する$
◎
If header is not a CORS-safelisted request-header, then append header’s name to unsafeNames.
</li>
			<li>
~ELSE
⇒＃
%安全でないかもしれない名前~群 に %名前 を`付加する$；
%安全な値の合計~size ~INCBY %値 の`長さ$
◎
Otherwise, append header’s name to potentiallyUnsafeNames and increase safelistValueSize by header’s value’s length.
</li>
		</ol>
	</li>
	<li>
~IF［
%安全な値の合計~size ~GT 1024
］
⇒
%安全でないかもしれない名前~群 を成す
~EACH( %名前 )
に対し
⇒
%安全でない名前~群 に %名前 を`付加する$
◎
If safelistValueSize is greater than 1024, then for each name of potentiallyUnsafeNames, append name to unsafeNames.
</li>
	<li>
~RET `~header名たちを小文字~化して~sortした集合に変換する$( %安全でない名前~群 )
◎
Return the result of convert header names to a sorted-lowercase set with unsafeNames.
</li>
</ol>
</div>

<p>
`~CORS非~wildcard要請~header名@
とは、［
次に挙げるいずれかに`~byte大小無視$で合致する`~header名$
］である
⇒＃
`Authorization$h
◎
A CORS non-wildcard request-header name is a header name that is a byte-case-insensitive match for `Authorization`.
</p>

<p>
`特権的~CORSなし要請~header名@
とは、［
次に挙げるいずれかに`~byte大小無視$で合致する`~header名$
］である
⇒＃
`Range$h
◎
A privileged no-CORS request-header name is a header name that is a byte-case-insensitive match for one of
• `Range`
</p>

<div class="note">
<p>注記：
これらは，特権的~APIにより設定され得る~headerであり、
それを結付けている要請~objが複製される場合には 保全されるが，
その要請が特権的でない~APIにより改変された場合には 除去されることになる。
◎
These are headers that can be set by privileged APIs, and will be preserved if their associated request object is copied, but will be removed if the request is modified by unprivileged APIs.
</p>

<p>
`Range$h ~headerは，［
`~downloadする＠~HTMLlinks#downloading-hyperlinks$ ／
`~mediaを~fetchする＠~HEmedia#concept-media-load-resource$
］ときに共通的に利用される。
◎
`Range` headers are commonly used by downloads and media fetches.
</p>

<p>
特定0の要請に`範囲~headerを追加する$ために，ある `helper^en 【？】が供される。
◎
A helper is provided to add a range header to a particular request.
</p>
</div>

<div class="p">
<p>
所与の
( `~header名$たちが成す`~list$ %~list )
内の
`~CORS安全とされる応答~header名@
とは、
~AND↓ を満たす`~header名$である：
</p>
<ul>
	<li>
`禁止~応答~header名$でない
</li>
	<li>
次に挙げるいずれかに`~byte大小無視$で合致する
⇒＃
%~list を成すいずれかの`~item$,
`Cache-Control$h,
`Content-Language$h,
`Content-Length$h,
`Content-Type$h,
`Expires$h,
`Last-Modified$h,
`Pragma$h
</li>
</ul>
◎
A CORS-safelisted response-header name, given a list of header names list, is a header name that is a byte-case-insensitive match for one of
• `Cache-Control`
• `Content-Language`
• `Content-Length`
• `Content-Type`
• `Expires`
• `Last-Modified`
• `Pragma`
• Any item in list that is not a forbidden response-header name.
</div>

<p>
`~CORSなしで安全とされる要請~header名@
とは、［
次に挙げるいずれかに`~byte大小無視$で合致する`~header名$
］である
⇒＃
`Accept$h,
`Accept-Language$h,
`Content-Language$h,
`Content-Type$h
◎
A no-CORS-safelisted request-header name is a header name that is a byte-case-insensitive match for one of
• `Accept`
• `Accept-Language`
• `Content-Language`
• `Content-Type`
</p>

<div class="algo">
<p>
（`~header$用の）所与の
( %名前, %値 )
が
`~CORSなしで安全とされる要請~header@
を成すとは、
~AND↓ が満たされることをいう：
◎
To determine whether a header (name, value) is a no-CORS-safelisted request-header, run these steps:
</p>
<ul>
	<li>
%名前 は`~CORSなしで安全とされる要請~header名$である
◎
If name is not a no-CORS-safelisted request-header name, then return false.
</li>
	<li>
( %名前, %値 ) は`~CORS安全とされる要請~header$を成す
◎
Return whether (name, value) is a CORS-safelisted request-header.
</li>
</ul>
</div>

<div class="algo">
<p>
（`~header$用の）所与の
( %名前, %値 )
が
`禁止~要請~header@
を成すとは、
~OR↓ が満たされることをいう：
◎
A header (name, value) is forbidden request-header if these steps return true:
</p>
<ul>
	<li>
%名前 は次に挙げるいずれかに`~byte大小無視$で合致する
⇒＃
`Accept-Charset$h,
`Accept-Encoding$h,
`Access-Control-Request-Headers$h,
`Access-Control-Request-Method$h,
`Connection$h,
`Content-Length$h,
`Cookie$h,
`Cookie2^h,
`Date$h,
`DNT$h 【 `Do Not Track^en 】,
`Expect$h,
`Host$h,
`Keep-Alive$h,
`Origin$h,
`Referer$h,
`Set-Cookie$h,
`TE$h,
`Trailer$h,
`Transfer-Encoding$h,
`Upgrade$h,
`Via$h
◎
If name is a byte-case-insensitive match for one of:
• `Accept-Charset`
• `Accept-Encoding`
• `Access-Control-Request-Headers`
• `Access-Control-Request-Method`
• `Connection`
• `Content-Length`
• `Cookie`
• `Cookie2`
• `Date`
• `DNT`
• `Expect`
• `Host`
• `Keep-Alive`
• `Origin`
• `Referer`
• `Set-Cookie`
• `TE`
• `Trailer`
• `Transfer-Encoding`
• `Upgrade`
• `Via`
◎
then return true.
</li>
	<li>
［
`~byte小文字~化する$( %名前 ) の結果
］は［
`proxy-^bl,
`sec-^bl
］いずれか`から開始して$byteいる
◎
If name when byte-lowercased starts with `proxy-` or `sec-`, then return true.
</li>
	<li>
<p>
~AND↓：
◎
↓</p>
		<ul>
			<li>
%名前 は次に挙げるいずれかに`~byte大小無視$で合致する
⇒＃
`X-HTTP-Method^h,
`X-HTTP-Method-Override^h,
`X-Method-Override^h
◎
If name is a byte-case-insensitive match for one of:
• `X-HTTP-Method`
• `X-HTTP-Method-Override`
• `X-Method-Override`
then:
</li>
			<li>
［
`~header値を復号して分割する$( %値 ) の結果
］を成す ある %~method は
次を満たす
⇒
［
`同型に符号化する$( %~method ) の結果
］は`禁止~method$である
◎
Let parsedValues be the result of getting, decoding, and splitting value.
◎
For each method of parsedValues: if the isomorphic encoding of method is a forbidden method, then return true.
◎
↑↑ Return false.
</li>
		</ul>
	</li>
</ul>

<div class="note">
<p>注記：
これらは、
全部的に~UAの制御~下に留め置くため，禁止される。
◎
These are forbidden so the user agent remains in full control over them.
</p>

<p>
`Sec-^h から開始される`~header名$は、
次を許容するため，予約される
⇒
~APIから安全に［
`XMLHttpRequest$I `XHR$r など，
開発者による制御が許容される`~header$が含まれた`~fetch$
］を行えるような，新種の`~header$を創出する。
◎
Header names starting with `Sec-` are reserved to allow new headers to be minted that are safe from APIs using fetch that allow control over headers by developers, such as XMLHttpRequest. [XHR]
</p>

<p>
`Set-Cookie^h ~headerは、
意味論的には応答~headerであり，要請においては有用でない。
`Set-Cookie^h ~headerたちは，結合し得ないので、
`Headers$I ~objにおいて，より複階的な取扱いが要求される。
この複階性が要請の中へ漏れるのを避けるため、
それは，ここでは禁止される。
◎
The `Set-Cookie` header is semantically a response header, so it is not useful on requests. Because `Set-Cookie` headers cannot be combined, they require more complex handling in the Headers object. It is forbidden here to avoid leaking this complexity into requests.
</p>
</div>
</div>

<p>
`禁止~応答~header名@
とは、［
次のいずれかに`~byte大小無視$で合致する`~header名$
］である
⇒＃
`Set-Cookie$h,
`Set-Cookie2^h
◎
A forbidden response-header name is a header name that is a byte-case-insensitive match for one of:
• `Set-Cookie`
• `Set-Cookie2`
</p>

<p>
`要請~本体~header名@
とは、［
次のいずれかに`~byte大小無視$で合致する`~header名$
］である
⇒＃
`Content-Encoding$h
`Content-Language$h
`Content-Location$h
`Content-Type$h
◎
A request-body-header name is a header name that is a byte-case-insensitive match for one of:
• `Content-Encoding`
• `Content-Language`
• `Content-Location`
• `Content-Type`
</p>

<hr>

<div class="algo">
<p>
`~headerから値を抽出する@
~algoは、
所与の
( `~header$ %~header )
に対し：
◎
To extract header values given a header header, run these steps:
</p>
<ol>
	<li>
%~header の`値$hdを［
%~header の`名前$hd用の`~ABNF$
］に従って構文解析する
【 ~HTTPの `§ ~field行lの構文解析＠~HTTPv1#field.parsing$】
◎
If parsing header’s value, per the ABNF for header’s name, fails, then return failure.
</li>
	<li>
~RET［
前~段に失敗したならば `失敗^i ／
~ELSE_ 前~段による結果を成す 1 個以上の`値$hd
］
◎
Return one or more values resulting from parsing header’s value, per the ABNF for header’s name.
</li>
</ol>
</div>

<div class="algo">
<p>
`~header~listから値を抽出する@
~algoは、
所与の
( `~header~list$ %~header群, `~header名$ %名前 )
に対し：
◎
To extract header list values given a header name name and a header list list, run these steps:
</p>
<ol>
	<li>
%~list ~LET %~header群 を成す［
%名前 を`名前に持つ~header$
］すべてからなる~list
◎
↓</li>
	<li>
~IF［
%~list は空である
］
⇒
~RET ~NULL
◎
If list does not contain name, then return null.
</li>
	<li>
<p>
~IF［［
%名前 用の`~ABNF$
］にて許容されている`~header$の個数 は 1 個†
］~AND［
%~list 内に複数個の`~header$がある
］
⇒
~RET `失敗^i
◎
If the ABNF for name allows a single header and list contains more than one, then return failure.
</p>

<p class="note">注記：
異なる~errorの取扱いが必要な場合††、
事前に~~目的の`~header$を抽出すること。
◎
If different error handling is needed, extract the desired header first.
</p>

<p class="trans-note">【†
すなわち、
%名前 は`単数~field$の名前を与えている。
】【††
~HTTPの
`§ ~fieldの順序＠~HTTPinfra#fields.order$
の注記（ `Set-Cookie$h ）に加え，
§ `Content-Length$h の最後の方の記述なども該当するように見受けられる。
】</p>

	</li>
	<li>
%値~群 ~LET 新たな`~list$
◎
Let values be an empty list.
</li>
	<li>
<p>
%~list を成す
~EACH( `~header$ %~header )
に対し：
◎
For each header header list contains whose name is name:
</p>
		<ol>
			<li>
%抽出- ~LET `~headerから値を抽出する$( %~header )
◎
Let extract be the result of extracting header values from header.
</li>
			<li>
~IF［
%抽出- ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If extract is failure, then return failure.
</li>
			<li>
%抽出- を成す
~EACH( `値$hd %値 )
に対し
⇒
%値~群 に %値 を付加する
◎
Append each value in extract, in order, to values.
</li>
		</ol>
	</li>
	<li>
~RET %値~群†
◎
Return values.
</li>
</ol>

<p class="trans-note">【†
`単数~field$である場合、
この手続きを呼出している所では，
結果の %値~群 は暗黙的に その最初の値と同一視されている。
】</p>
</div>

<div class="algo">
<p>
`内容~範囲を築く@
~algoは、
所与の
( 整数 %範囲~始端, 整数 %範囲~終端, 整数 %全部的な長さ )
に対し
⇒
~RET 次に挙げる~byte列を順に連結した結果
⇒＃
`bytes ^bl,
`同型に符号化する$( `整数を直列化する$( %範囲~始端 ) ),
`2D^X `-^smb,
`同型に符号化する$( `整数を直列化する$( %範囲~終端 ) ),
`2F^X `/^smb,
`同型に符号化する$( `整数を直列化する$( %全部的な長さ ) )
</p>
◎
To build a content range given an integer rangeStart, an integer rangeEnd, and an integer fullLength, run these steps:
• Let contentRange be `bytes `.
• Append rangeStart, serialized and isomorphic encoded, to contentRange.
• Append 0x2D (-) to contentRange.
• Append rangeEnd, serialized and isomorphic encoded to contentRange.
• Append 0x2F (/) to contentRange.
• Append fullLength, serialized and isomorphic encoded to contentRange.
• Return contentRange.
</div>

<div class="algo">
<p>
`単純な範囲~header値を構文解析する@
~algoは、
所与の
( `~byte列$ %値, 真偽値 %空白を許容するか )
に対し：
◎
To parse a single range header value from a byte sequence value and a boolean allowWhitespace, run these steps:
</p>
<ol>
	<li>
%~data ~LET `同型に復号する$( %値 )
◎
Let data be the isomorphic decoding of value.
</li>
	<li>
~IF［
%~data は `bytes^l `から開始して$いない
］
⇒
~RET `失敗^i
◎
If data does not start with "bytes", then return failure.
</li>
	<li>
%位置 ~LET %~data を成す 5 番の`文字$を指している`位置~変数$
◎
Let position be a position variable for data, initially pointing at the 5th code point of data.
</li>
	<li>
~IF［
%空白を許容するか ~EQ ~T
］
⇒
%~data 内の %位置 から`~HTTP~tab-or-space$からなる`符号位置~並びを収集する$
◎
If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from data given position.
</li>
	<li>
~IF［
%位置↗ ~NEQ `003D^U `=^smb
］
⇒
~RET `失敗^i
◎
If the code point at position within data is not U+003D (=), then return failure.
</li>
	<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
	<li>
~IF［
%空白を許容するか ~EQ ~T
］
⇒
%~data 内の %位置 から`~HTTP~tab-or-space$からなる`符号位置~並びを収集する$
◎
If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from data given position.
</li>
	<li>
%範囲~始端 ~LET %~data 内の %位置 から`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Let rangeStart be the result of collecting a sequence of code points that are ASCII digits, from data given position.
</li>
	<li>
%範囲~始端~値 ~LET %範囲~始端 に応じて
⇒＃
空~文字列ならば ~NULL ／
~ELSE_ %範囲~始端 を 10 進数として解釈した結果
◎
Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the empty string; otherwise null.
</li>
	<li>
~IF［
%空白を許容するか ~EQ ~T
］
⇒
%~data 内の %位置 から`~HTTP~tab-or-space$からなる`符号位置~並びを収集する$
◎
If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from data given position.
</li>
	<li>
~IF［
%位置↗ ~NEQ `002D^U `-^smb
］
⇒
~RET `失敗^i
◎
If the code point at position within data is not U+002D (-), then return failure.
</li>
	<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
	<li>
~IF［
%空白を許容するか ~EQ ~T
］
⇒
%~data 内の %位置 から`~HTTP~tab-or-space$からなる`符号位置~並びを収集する$
◎
If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from data given position.
</li>
	<li>
%範囲~終端 ~LET %~data 内の %位置 から`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Let rangeEnd be the result of collecting a sequence of code points that are ASCII digits, from data given position.
</li>
	<li>
%範囲~終端~値 ~LET %範囲~終端 に応じて
⇒＃
空~文字列ならば ~NULL ／
~ELSE_ %範囲~終端 を 10 進数として解釈した結果
◎
Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd is not the empty string; otherwise null.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not past the end of data, then return failure.
</li>
	<li>
~IF［
%範囲~終端~値 ~EQ ~NULL
］~AND［
%範囲~始端~値 ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If rangeEndValue and rangeStartValue are null, then return failure.
</li>
	<li>
~IF［
%範囲~始端~値 ~NEQ ~NULL
］~AND［
%範囲~終端~値 ~NEQ ~NULL
］~AND［
%範囲~始端~値 ~GT %範囲~終端~値
］
⇒
~RET `失敗^i
◎
If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is greater than rangeEndValue, then return failure.
</li>
	<li>
<p>
~RET ( %範囲~始端~値, %範囲~終端~値 )
◎
Return (rangeStartValue, rangeEndValue).
</p>

<p class="note">注記：
範囲の［
終端／始端
］は省略できる
— 例： ［
`bytes=0-^bl ／ `bytes=-500^bl
］は妥当な範囲になる。
◎
The range end or start can be omitted, e.g., `bytes=0-` or `bytes=-500` are valid ranges.
</p>
	</li>
</ol>

<p class="note">注記：
この~algoは，［
`Range$h ~headerに許容される値の下位集合
］に対し成功するが、
~UAが［
~mediaを要請する／~downloadを再開する
］ときに最も共通的に利用される形である。
この形式による範囲~header値は、
`範囲~headerを追加する$を利用して設定できる。
◎
Parse a single range header value succeeds for a subset of allowed range header values, but it is the most common form used by user agents when requesting media or resuming downloads. This format of range header value can be set using add a range header.
</p>
</div>

<hr>

<p>
`既定の User-Agent 値@
は、
`User-Agent$h `~header$用に定義される，`実装定義$な`~header値$である。
◎
A default `User-Agent` value is an implementation-defined header value for the `User-Agent` header.
</p>

<p>
`文書 Accept ~header値@
は、
次に与える【 `Accept$h ~header用の】`~header値$である
⇒
`text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8^bl
◎
The document `Accept` header value is `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`.
</p>

			</section>
			<section id="statuses">
<h4 title="Statuses">2.2.3. 状態s</h4>

<p>
`状態s@
は、
範囲 { 0 〜 999 } に入る整数である。
【~HTTPにおける応答の`状態s~code$に対応する（~HTTPは 600 以上の状態s~codeを定義しないが）。】
◎
A status is an integer in the range 0 to 999, inclusive.
</p>

<p class="XXX">
`課題 #1156＠https://github.com/whatwg/fetch/issues/1156$
にて，［
~HTTP1xの `status-code$p から この概念への対応付け
］における様々な際どい事例が作業されている。
◎
Various edge cases in mapping HTTP/1’s status-code to this concept are worked on in issue #1156.
</p>

<p>
次に挙げる`状態s$は、
`~null本体~状態s@
であるとされる
⇒＃
`101$st,
`103$st,
`204$st,
`205$st,
`304$st
◎
A null body status is a status that is 101, 103, 204, 205, or 304.
</p>

<p>
次の範囲に入る`状態s$は、
`~ok状態s@
であるとされる
⇒
`200^st 〜 `299^st
◎
An ok status is a status in the range 200 to 299, inclusive.
</p>

<p>
次に挙げる`状態s$は、
`~redirect状態s@
であるとされる
⇒＃
`301$st,
`302$st,
`303$st,
`307$st,
`308$st
◎
A redirect status is a status that is 301, 302, 303, 307, or 308.
</p>

			</section>
			<section id="bodies">
<h4 title="Bodies">2.2.4. 本体</h4>

<p>
`本体@
（ `body^en ）は、
次に挙げるものからなる：
◎
A body consists of:
</p>
<ul>
	<li>
`~stream@bd
⇒
`ReadableStream$I ~obj
◎
A stream (a ReadableStream object).
</li>
	<li>
`~source@bd
⇒
~NULL／
`~byte列$ ／
`Blob$I ~obj／
`FormData$I ~obj
— 初期~時は ~NULL とする。
◎
A source (null, a byte sequence, a Blob object, or a FormData object), initially null.
</li>
	<li>
`長さ@bd
⇒
~NULL ／ 整数
— 初期~時は 0 とする。
◎
A length (null or an integer), initially null.
</li>
</ul>

<p class="trans-note">【
本体は、
~HTTPにおける~messageの`内容$に対応する。
】</p>

<div class="algo">
<p>
`本体を~cloneする@
~algoは、
所与の
( `本体$ %本体 )
に対し：
◎
To clone a body body, run these steps:
</p>
<ol>
	<li>
« %out1, %out2 » ~LET
%本体 の`~stream$bdを`二叉化する$RS()
◎
Let « out1, out2 » be the result of teeing body’s stream.
</li>
	<li>
%本体 の`~stream$bd ~SET %out1
◎
Set body’s stream to out1.
</li>
	<li>
<p>
~RET 新たな`本体$
— その
⇒＃
`~stream$bd ~SET %out2；
他の~memberは %本体 から複製する†
</p>

<p class="trans-note">【†
すなわち，［
`長さ$bd ~SET %本体 の`長さ$bd,
`~source$bd ~SET %本体 の`~source$bd
］を意味すると思われるが、
~sourceが~objである場合に［
新たな~instanceを作成するよう複製する必要もある
］か否かは，はっきりしない。
】</p>
◎
Return a body whose stream is out2 and other members are copied from body.
</li>
</ol>
</div>

<div class="algo">
<p>
`~byte列を本体として取得する@
~algoは、
所与の
( `~byte列$ %~byte列 )
に対し
⇒
~RET 次の結果の`本体$bwT
⇒
`本体と型を安全に抽出する$( %~byte列 )
◎
To get a byte sequence bytes as a body, return the body of the result of safely extracting bytes.
</p>
</div>

<hr>

<div class="algo">
<p>
`本体を増分的に読取る@
~algoは、
所与の
⇒＃
%本体,
%本体~chunkの処理n,
%本体~終了~時の処理n,
%本体~errorの処理n,
%~taskの行先
◎終
に対し：
◎
To incrementally read a body body, given an algorithm processBodyChunk, an algorithm processEndOfBody, an algorithm processBodyError, and an optional null, parallel queue, or global object taskDestination (default null), run these steps.＼
</p>
<ol>
	<li>
~Assert
⇒＃
%本体 は `本体$である／
%本体~chunkの処理n は `~byte列$を受容する~algoである／
%本体~終了~時の処理n は 引数をとらない~algoである／
%本体~errorの処理n は 例外を受容する~algoである／
%~taskの行先 （省略時は ~NULL ）は ［~NULL／`並列~queue$／`大域~obj$］である
◎
processBodyChunk must be an algorithm accepting a byte sequence. processEndOfBody must be an algorithm accepting no arguments. processBodyError must be an algorithm accepting an exception.
</li>
	<li>
~IF［
%~taskの行先 ~EQ ~NULL
］
⇒
%~taskの行先 ~SET `新たな並列~queueを開始する$()
◎
If taskDestination is null, then set taskDestination to the result of starting a new parallel queue.
</li>
	<li>
<p>
%読取器 ~LET %本体 の`~stream$bd用の`読取器を取得する$RS()
◎
Let reader be the result of getting a reader for body’s stream.
</p>

<p class="note">注記：
この演算は例外を投出しない。
◎
This operation will not throw an exception.
</p>
	</li>
	<li>
`本体を増分的に読取る~loop$( ↓ )
⇒＃
%読取器,
%~taskの行先,
%本体~chunkの処理n,
%本体~終了~時の処理n,
%本体~errorの処理n
◎
Perform the incrementally-read loop given reader, taskDestination, processBodyChunk, processEndOfBody, and processBodyError.
</li>
</ol>
</div>

<div class="algo">
<p>
`本体を増分的に読取る~loop@
を遂行する
~algoは、
所与の
⇒＃
%読取器,
%~taskの行先,
~algo %本体~chunkの処理n,
~algo %本体~終了~時の処理n,
~algo %本体~errorの処理n
◎終
に対し：
◎
To perform the incrementally-read loop, given a ReadableStreamDefaultReader object reader, parallel queue or global object taskDestination, algorithm processBodyChunk, algorithm processEndOfBody, and algorithm processBodyError:
</p>
<ol>
	<li>
~Assert
⇒＃
%読取器 は `ReadableStreamDefaultReader$I ~objである／
%~taskの行先 は ［ `並列~queue$／`大域~obj$ ］である
◎
↑</li>
	<li>
<p>
%読取n要請 ~LET 新たな`読取n要請$
— その：
◎
Let readRequest be the following read request:
</p>
		<ul>
			<li class="algo">
<p>
`~chunk手続き$rRは、
所与の
( %~chunk )
に対し：
◎
chunk steps, given chunk
• Let continueAlgorithm be null.
</p>
				<ol>
					<li>
<p>
~IF［
%~chunk は `Uint8Array$I ~objでない
］
⇒
`~fetch~taskを~queueする$( 次の手続き, %~taskの行先 )
</p>

<div class="algo">
手続きは
⇒
%本体~errorの処理n( `TypeError$E )
</div>
◎
If chunk is not a Uint8Array object, then set continueAlgorithm to this step: run processBodyError given a TypeError.
◎
↓</li>
					<li>
<p>
~ELSE：
</p>
						<ol>
							<li>
<p>
%~byte列 ~LET %~chunk に`保持された~byte列の複製を取得する$
</p>

<p class="note">注記：
実装には、［
アリな所では，この複製を避ける策を利用する
］ことが，強く奨励される。
</p>
							</li>
							<li>
<p>
`~fetch~taskを~queueする$( 次の手続き, %~taskの行先 )：
</p>

<div class="algo">
<p>
手続きは：
</p>
								<ol>
									<li>
%本体~chunkの処理n( %~byte列 )
</li>
									<li>
`本体を増分的に読取る~loop$( ↓ )
⇒＃
%読取器,
%~taskの行先,
%本体~chunkの処理n,
%本体~終了~時の処理n,
%本体~errorの処理n
</li>
								</ol>
</div>
							</li>
						</ol>
◎
Otherwise:
• Let bytes be a copy of chunk.
• Implementations are strongly encouraged to use an implementation strategy that avoids this copy where possible.
• Set continueAlgorithm to these steps:
•• Run processBodyChunk given bytes.
•• Perform the incrementally-read loop given reader, taskDestination, processBodyChunk, processEndOfBody, and processBodyError.
◎
Queue a fetch task given continueAlgorithm and taskDestination.
</li>
				</ol>
			</li>
			<li class="algo">
`~close手続き$rRは
⇒
`~fetch~taskを~queueする$( %本体~終了~時の処理n, %~taskの行先 )
◎
close steps
• Queue a fetch task given processEndOfBody and taskDestination.
</li>
			<li class="algo">
<p>
`~error手続き$rRは、
所与の
( %~error )
に対し
⇒
`~fetch~taskを~queueする$( 次の手続き, %~taskの行先 )
</p>

<div class="algo">
手続きは
⇒
%本体~errorの処理n( %~error )
</div>
◎
error steps, given e
• Queue a fetch task to run processBodyError given e, with taskDestination.
</li>
		</ul>
	</li>
	<li>
%読取器 から`~chunkを読取る$RSR( %読取n要請 )
◎
Read a chunk from reader given readRequest.
</li>
</ol>
</div>

<div class="algo">
<p>
`本体を全部的に読取る@
~algoは、
所与の
⇒＃
`本体$ %本体,
%本体の処理n,
%本体~errorの処理n,
［~NULL／`並列~queue$／`大域~obj$］ %~taskの行先（省略時は ~NULL ）
◎終
に対し：
◎
To fully read a body body, given an algorithm processBody, an algorithm processBodyError,＼
and an optional null, parallel queue, or global object taskDestination (default null), run these steps.＼
</p>
<ol>
	<li>
<p>
~Assert
⇒＃
%本体の処理n は ( `~byte列$ ) を受容する~algoである／
%本体~errorの処理n は ( 省略可能な`例外$† ) を受容する~algoである
</p>

<p class="trans-note">【†
省略時に何を与えるか指定されていないが、
最後の段から，~JS `undefined^jv 値になるものと推定される。
】</p>
◎
processBody must be an algorithm accepting a byte sequence. processBodyError must be an algorithm optionally accepting an exception.
</li>
	<li>
~IF［
%~taskの行先 ~EQ ~NULL
］
⇒
%~taskの行先 ~SET `新たな並列~queueを開始する$()
◎
If taskDestination is null, then set taskDestination to the result of starting a new parallel queue.
</li>
	<li class="algo">
<p>
%成功~手続き ~LET 所与の
( `~byte列$ %~byte列 )
に対し，次を走らす手続き
⇒
`~fetch~taskを~queueする$( 次の手続き, %~taskの行先 )
</p>

<div class="algo">
手続きは
⇒
%本体の処理n( %~byte列 )
</div>
◎
Let successSteps given a byte sequence bytes be to queue a fetch task to run processBody given bytes, with taskDestination.
</li>
	<li class="algo">
<p>
%~error手続き ~LET 所与の
( 省略可能な %例外 )
に対し，次を走らす手続き
⇒
`~fetch~taskを~queueする$( 次の手続き, %~taskの行先 )
</p>

<div class="algo">
手続きは
⇒
%本体~errorの処理n( %例外 )
</div>
◎
Let errorSteps optionally given an exception exception be to queue a fetch task to run processBodyError given exception, with taskDestination.
</li>
	<li>
<p>
%読取器 ~LET %本体 の`~stream$bd用の`読取器を取得する$RS()
</p>

<p>
例外 %e が投出されたときは、
~catchして
⇒＃
%~error手続き( %e )；
~RET
</p>
◎
Let reader be the result of getting a reader for body’s stream. If that threw an exception, then run errorSteps with that exception and return.
</li>
	<li>
~RET %読取器 から`すべての~byteを読取る$RSR( %成功~手続き, %~error手続き )
◎
Read all bytes from reader, given successSteps and errorSteps.
</li>
</ol>
</div>

<hr>

<div class="p">
<p>
`本体と型@
は、
( `本体$bwT, `型$bwT ) が成す`~tuple$である：
</p>
<ul>
	<li>
`本体@bwT
は、
ある`本体$を与える。
</li>
	<li>
`型@bwT
は、［
ある`~header値$／~NULL
］を与える。
【この~header値は、 `Content-Type$h 用に意図される。】
</li>
</ul>
◎
A body with type is a tuple that consists of a body (a body) and a type (a header value or null).
</div>

<hr>

<div class="algo">
<p>
`内容~符号法sを取扱う@
~algoは、
所与の
( 内容~符号法s† %符号法s, ~byte列 %~byte列 )
に対し
【† 複数の`内容~符号法$が重ねて適用されることもあり得る】
：
◎
To handle content codings given codings and bytes, run these steps:
</p>
<ol>
	<li>
~IF［
~UAは %符号法s 【を成す いずれかの符号法】を~supportしない
］
⇒
~RET %~byte列
◎
If codings are not supported, then return bytes.
</li>
	<li>
~RET ［
次の結果は~errorでないならば その結果 ／
~ELSE_ `失敗^i
］
⇒
~HTTPに従って， %~byte列 を %符号法s で復号する
`HTTP$r
◎
Return the result of decoding bytes with codings as explained in HTTP, if decoding does not result in an error, and failure otherwise. [HTTP]
</li>
</ol>
</div>

			</section>
			<section id="requests">
<h3 title="Requests">2.2.5. 要請</h3>

<p class="note">注記：
この節は、
要請がどう働くかを詳細に文書化する。
事始めは、
`§ 要請の設定法＠#fetch-elsewhere-request$を見よ。
◎
This section documents how requests work in detail. To get started, see Setting up a request.
</p>

<p>
`要請@
（ `request^en ）は、
`~fetch$への入力を与える。
【~HTTPにおける`要請~message＠~HTTPinfra#request$に対応する。】
◎
The input to fetch is a request.
</p>

<p>
各 `要請$には、
以下に挙げるものが結付けられる。
各~項には，それがとり得る値を示す。
他が言明されない限り、［
見出しの括弧内に与える値
］を既定~値としてとるものとする：
◎
↓</p>

<dl class="def-list">
	<dt>
`~method@rq
（ `GET$hm ）
◎
A request has an associated method＼
</dt>
	<dd>
`~method$
◎
(a method). Unless stated otherwise it is `GET`.
</dd>
	<dd class="note">注記：
これは、
`~HTTP~fetch$にて述べられるとおり，
~redirectの間に【 `POST$hm から】 `GET$hm に更新され得る。
【参考：状態s~code `3xx$st の注記】
◎
This can be updated during redirects to `GET` as described in HTTP fetch.
</dd>

	<dt>
`~URL@rq
◎
A request has an associated URL＼
</dt>
	<dd>
`~URL$
◎
(a URL).
</dd>
	<dd class="note">注記：
実装には、［
これが，`要請$の`~URL~list$rq内の最初の`~URL$を指す
］ようにすることが奨励される。
これは、［
もっぱら，~Fetchの中へ~hookする他の標準の便利~用
］に，別個な~fieldとして供されている。
◎
Implementations are encouraged to make this a pointer to the first URL in request’s URL list. It is provided as a distinct field solely for the convenience of other standards hooking into Fetch.
</dd>
	<dd class="trans-note">【
資源の~fetch先
— ~HTTPにおける`~target~URI$に対応する。
】</dd>

	<dt>
`局所~URLに限るか@rq
（ ~F ）
◎
A request has an associated local-URLs-only flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise it is unset.
</dd>

	<dt>
`~header~list@rq
（ « » ）
◎
A request has an associated header list＼
</dt>
	<dd>
`~header~list$
◎
(a header list). Unless stated otherwise it is « ».
</dd>

	<dt>
`安全でない要請か@rq
（ ~F ）
◎
A request has an associated unsafe-request flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise it is unset.
</dd>
	<dd class="note">注記：
`安全でない要請か$rqは、［
給された`~method$rqと`~header~list$rqに基づいて `~CORS予行~fetch$が行われる
］ようにするために，いくつかの~API
— `fetch()$m や `XMLHttpRequest$I など —
により ~T にされる。
これは、
~APIにおいて`禁止~method$や`禁止~要請~header$を~~合法にするものではない。
◎
The unsafe-request flag is set by APIs such as fetch() and XMLHttpRequest to ensure a CORS-preflight fetch is done based on the supplied method and header list. It does not free an API from outlawing forbidden methods and forbidden request-headers.
</dd>

	<dt>
`本体@rq
（ ~NULL ）
◎
A request has an associated body＼
</dt>
	<dd>
~NULL ／ `~byte列$ ／ `本体$
◎
(null, a byte sequence, or a body). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
`本体$の中へは、
`~fetch$における早期に`~byte列$が`安全に抽出される＠#bodyinit-safely-extract$ことになる。
この~fieldは、
ある種の~redirectに因り，
`~HTTP~fetch$の一部として ~NULL に設定され得る。
◎
A byte sequence will be safely extracted into a body early on in fetch. As part of HTTP fetch it is possible for this field to be set to null due to certain redirects.
</dd>

	<dt>
`~client@rq
◎
A request has an associated client＼
</dt>
	<dd>
~NULL ／`環境~設定群~obj$
◎
(null or an environment settings object).
</dd>
	<dd class="trans-note">【
~HTMLにおいては、
これは，`~navi~algo$の起動元（ %~source文書 ）に対応する。
】</dd>

	<dt>
`予約-済み~client@rq
（ ~NULL ）
◎
A request has an associated reserved client＼
</dt>
	<dd>
~NULL ／ `環境$ ／ `環境~設定群~obj$
◎
(null, an environment, or an environment settings object). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
これが利用されるのは、
~navi要請, ~worker要請に限られ，
~sw要請には利用されない。
それは［
`~navi要請$用には`環境$ ／
~worker要請~用には`環境~設定群~obj$
］を参照する。
◎
This is only used by navigation requests and worker requests, but not service worker requests. It references an environment for a navigation request and an environment settings object for a worker request.
</dd>
	<dd class="trans-note">【
~HTMLにおいては、
これは，`~navi~params$の`予約-済み環境$nvPに利用される。
】</dd>

	<dt>
`置換する~client~ID@rq
（ 空~文字列 ）
◎
A request has an associated replaces client id＼
</dt>
	<dd>
文字列
◎
(a string). Unless stated otherwise it is the empty string.
</dd>
	<dd class="note">注記：
これが利用されるのは、
~navi要請に限られる。
それは、
`~target閲覧~文脈$enVにて`作動中な文書$navの`環境~設定群~obj$の`~ID$enVになる。
◎
This is only used by navigation requests. It is the id of the target browsing context’s active document’s environment settings object.
</dd>

	<dt>
`~window@rq
（ `client^l ）
◎
A request has an associated window＼
</dt>
	<dd>
`client^l ／
`no-window^l ／
次を満たす`環境~設定群~obj$
⇒
その`大域~obj$enVは `Window$I ~objである
◎
("no-window", "client", or an environment settings object whose global object is a Window object). Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
値 `client^l は、
`~fetching$の間に［
`no-window^l ／ `要請$の`~client$rq
］に変更される。
この値は、
各種~標準が
— `要請$の`~window$rqを明示的に設定する必要なく —
~fetchingを簡便に利用する仕方を供する。
◎
The "client" value is changed to "no-window" or request’s client during fetching. It provides a convenient way for standards to not have to explicitly set request’s window.
</dd>

	<dt>
`~keepaliveか@rq
（ ~F ）
◎
A request has an associated boolean keepalive.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise it is false.
</dd>
	<dd class="note">注記：
これを利用すれば、
要請は`環境~設定群~obj$の外で残存できるようになる
— 例えば［
`navigator.sendBeacon()$m ~method／~HTML `img$e 要素 ／
【~CSPの`違反~報告＠~CSP3#report-violation$】
］は、
これを利用する。
これが ~T にされた要請は、
追加的な処理~要件の~subjectになる。
◎
This can be used to allow the request to outlive the environment settings object, e.g., navigator.sendBeacon() and the HTML img element use this. Requests with this set to true are subject to additional processing requirements.
</dd>

	<dt>
`起動元~種別@rq
（ ~NULL ）
◎
A request has an associated initiator type,＼
</dt>
	<dd>
~NULL ／
次に挙げるいずれかの文字列 `RESOURCE-TIMING$r
⇒＃
`audio^l,
`beacon^l,
`body^l,
`css^l,
`early-hints^l,
`embed^l,
`fetch^l,
`font^l,
`frame^l,
`iframe^l,
`image^l,
`img^l,
`input^l,
`link^l,
`object^l,
`ping^l,
`script^l,
`track^l,
`video^l,
`xmlhttprequest^l,
`other^l
◎
which is null, "audio", "beacon", "body", "css", "early-hints", "embed", "fetch", "font", "frame", "iframe", "image", "img", "input", "link", "object", "ping", "script", "track", "video", "xmlhttprequest", or "other". Unless stated otherwise it is null. [RESOURCE-TIMING]
</dd>

	<dt>
`~sw~mode@rq
（ `all^l ）
◎
A request has an associated service-workers mode,＼
</dt>
	<dd>
`all^l ／
`none^l
◎
that is "all" or "none". Unless stated otherwise it is "all".
</dd>
	<dd class="note">
<p>注記：
これは、［
どの~swが，この~fetch用の `fetch$et ~eventを受取るか
］を決定する：
◎
This determines which service workers will receive a fetch event for this fetch.
</p>
		<dl>
			<dt>`all^l</dt>
			<dd>
関連な~swが，この~fetch用の `fetch$et ~eventを取得することになる。
◎
Relevant service workers will get a fetch event for this fetch.
</dd>

			<dt>`none^l</dt>
			<dd>
どの~swも，この~fetch用の~eventを取得しない。
◎
No service workers will get events for this fetch.
</dd>
		</dl>
	</dd>

	<dt>
`起動元@rq
（ 空~文字列 ）
◎
A request has an associated initiator,＼
</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`download^l,
`imageset^l,
`manifest^l,
`prefetch^l,
`prerender^l,
`xslt^l
◎
which is the empty string, "download", "imageset", "manifest", "prefetch", "prerender", or "xslt". Unless stated otherwise it is the empty string.
</dd>

<dd class="note">注記：
`要請$の`起動元$rqは、
さしあたり特に細分化されてはいない
— 他の仕様からそう要求されてはいないので。
これは、
首に `CSP$r や `MIX$r を定義し易くするために~~導入した~~用語であり，
~JSには公開されない。
◎
A request’s initiator is not particularly granular for the time being as other specifications do not require it to be. It is primarily a specification device to assist defining CSP and Mixed Content. It is not exposed to JavaScript. [CSP] [MIX]
</dd>

	<dt>
`行先@rq
（ 空~文字列 ）
◎
A request has an associated destination,＼
</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`audio^l,
`audioworklet^l,
`document^l,
`embed^l,
`font^l,
`frame^l,
`iframe^l,
`image^l,
`json^l,
`manifest^l,
`object^l,
`paintworklet^l,
`report^l,
`script^l,
`serviceworker^l,
`sharedworker^l,
`style^l,
`track^l,
`video^l,
`webidentity^l,
`worker^l,
`xslt^l
◎
which is the empty string, "audio", "audioworklet", "document", "embed", "font", "frame", "iframe", "image", "json", "manifest", "object", "paintworklet", "report", "script", "serviceworker", "sharedworker", "style", "track", "video", "webidentity", "worker", or "xslt". Unless stated otherwise it is the empty string.
</dd>
	<dd class="note">注記：
これらは `RequestDestination$I に反映されるが、［
`serviceworker^l ／ `webidentity^l
］は除く
— それらの行先を伴う~fetchは、
~swを飛ばすので。
◎
These are reflected on RequestDestination except for "serviceworker" and "webidentity" as fetches with those destinations skip service workers.
</dd>
	<dd>
<p>
`要請$の`行先$rqのうち，次に挙げるものは
`~scriptに類する@
とされる
⇒＃
`audioworklet^l,
`paintworklet^l,
`script^l,
`serviceworker^l,
`sharedworker^l,
`worker^l
◎
A request’s destination is script-like if it is "audioworklet", "paintworklet", "script", "serviceworker", "sharedworker", or "worker".
</p>

<p class="warning">
`~scriptに類する$ものを利用する~algoは、
`xslt^l も考慮するベキである
— それも~script実行を生じさせ得るので。
上に挙げていないわけは、
常に関連するとは限らず，
異なる挙動が要求されることもあるためである。
◎
Algorithms that use script-like should also consider "xslt" as that too can cause script execution. It is not included in the list as it is not always relevant and might require different behavior.
</p>
	</dd>

	<dd class="note">
<p id="destination-table">
次の表tは、
`要請$の各種［
`起動元$rq,
`行先$rq
］が，どの［
~CSP指令, 特能
］から利用されるかを描き出したものである。
表tは、
特能に関しては網羅的ではない。
特能には、
その仕様にて関連な値が定義される必要がある：
◎
The following table illustrates the relationship between a request’s initiator, destination, CSP directives, and features. It is not exhaustive with respect to features. Features need to have the relevant values defined in their respective standards.
</p>

<div style="overflow:auto;">
<table><thead>
<tr><th>
`起動元$rq
◎
Initiator
<th>
`行先$rq
◎
Destination
<th>
`~CSP指令$
◎
CSP directive
<th>特能
◎
Features
<tbody>

<tr><td rowspan="21">""
<td>`report^l
<td>-
<td>CSP, NEL による報告

<tr><td>`document^l
<td>-
<td>~HTMLの`~navi~algo$（~top-levelに限る）
◎
HTML’s navigate algorithm (top-level only).

<tr><td>`frame^l
<td>`child-src$dir
<td>~HTMLの `frame$e 要素

<tr><td>`iframe^l
<td>`child-src$dir
<td>~HTMLの `iframe$e 要素

<tr><td>""
<td>`connect-src$dir
<td><span class="preline"
>`navigator.sendBeacon()$m,
`EventSource$I,
~HTMLの `a ping=""^e,
~HTMLの `area ping=""^e,
`fetch()$m,
`XMLHttpRequest$I,
`WebSocket$I,
Cache API【？】
</span>

<tr><td>`object^l
<td>`object-src$dir
<td>~HTMLの `object$e 要素

<tr><td>`embed^l
<td>`object-src$dir
<td>~HTMLの `embed$e 要素

<tr><td>`audio^l
<td>`media-src$dir
<td>~HTMLの `audio$e 要素

<tr><td>`font^l
<td>`font-src$dir
<td>~CSSの `font-face^at 規則

<tr><td>`image^l
<td>`img-src$dir
<td><span class="preline"
>~HTMLの `img src^e,
`/favicon.ico^c 資源,
SVG の `image$e 要素,
</span>
~CSSの［
`background-image^css, `cursor^css, `list-style-image^css, …
］~prop
【`参照＠~CSSIMAGE#image-values$】

<tr><td>`audioworklet^l
<td>`script-src$dir
<td>`audioWorklet.addModule()^m

<tr><td>`paintworklet^l
<td>`script-src$dir
<td>`CSS.paintWorklet.addModule()^m

<tr><td>`script^l
<td>`script-src$dir
<td>~HTMLの `script$e 要素, `self.importScripts()$m

<tr><td>`serviceworker^l
<td>`child-src$dir, `script-src$dir, `worker-src$dir
<td>`navigator.serviceWorker.register()$m

<tr><td>`sharedworker^l
<td>`child-src$dir, `script-src$dir, `worker-src$dir
<td>`SharedWorker$I

<tr><td>`webidentity^l
<td>`connect-src$dir
<td>`Federated Credential Management^en 要請

<tr><td>`worker^l
<td>`child-src$dir, `script-src$dir, `worker-src$dir
<td>`Worker$I

<tr><td>`json^l
<td>`child-src$dir
<td>`import "..." with { type: "json" }^c

<tr><td>`style^l
<td>`style-src$dir
<td>
~HTMLの `link rel=stylesheet^e,
~CSSの `import^at 規則,
`import "..." with { type: "css" }^c

<tr><td>`track^l
<td>`media-src$dir
<td>~HTMLの `track$e 要素

<tr><td>`video^l
<td>`media-src$dir
<td>~HTMLの `video$e 要素

<tr><td>`download^l
<td>""
<td>-
<td>~HTMLの `download=""^a, “~link先を保存…” UI

<tr><td>`imageset^l
<td>`image^l
<td>`img-src$dir
<td>~HTMLの `img srcset^e, `picture$e 要素

<tr><td>`manifest^l
<td>`manifest^l
<td>`manifest-src$dir
<td>~HTMLの `link rel=manifest^e 要素

<tr><td>`prefetch^l
<td>""
<td>`default-src$dir
（特定な指令は無い）
<td>~HTMLの `link rel=prefetch^e 要素

<tr><td>`prerender^l
<td>同上
<td>同上
<td>~HTMLの `link rel=prerender^e 要素

<tr><td>`xslt^l
<td>`xslt^l
<td>`script-src$dir
<td>`&lt;?xml-stylesheet&gt;^c
</table>
</div>

<p>
~CSPの `form-action$dir 指令は、
~HTMLの［
~navigate／~form提出
］~algoに直に~hookする必要がある。
◎
CSP’s form-action needs to be a hook directly in HTML’s navigate or form submission algorithm.
</p>

<p>
~CSPは、
各種~CSP指令~用に，［
`要請$の`~client$rqの`大域~obj$enVに`結付けられた文書$の`先祖~navigable群$
］についても検査する必要がある。
◎
CSP will also need to check request’s client’s global object’s associated Document’s ancestor navigables for various CSP directives.
</p>

	</dd>

	<dt>
`優先度@rq
（ `auto^l ）
◎
A request has an associated priority,＼
</dt>
	<dd>
`high^l ／
`low^l ／
`auto^l
◎
which is "high", "low", or "auto". Unless stated otherwise it is "auto".
</dd>

	<dt>
`内部的な優先度@rq
（ ~NULL ）
◎
A request has an associated internal priority＼
</dt>
	<dd>
~NULL ／ `実装定義$な~obj
【`~~説明＠#_stream-priority$】
◎
(null or an implementation-defined object). Unless otherwise stated it is null.
</dd>

	<dt>
`生成元@rq
（ `client^l ）
◎
A request has an associated origin,＼
</dt>
	<dd>
<p>
`client^l ／ `生成元$
◎
which is "client" or an origin. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
`client^l は、
`~fetching$の間に`生成元$に変化する。
この値は、
各種~標準が
— `要請$の`生成元$rqを設定する必要なく —
~fetchingを簡便に利用する仕方を供する。
◎
"client" is changed to an origin during fetching. It provides a convenient way for standards to not have to set request’s origin.
</dd>

	<dt>
`施策~容器@rq
（ `client^l ）
◎
A request has an associated policy container,＼
</dt>
	<dd>
`client^l ／ `施策~容器$
◎
which is "client" or a policy container. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
`client^l は、
`~fetching$の間に`施策~容器$に変化する。
この値は、
各種~標準が
— `要請$の`施策~容器$rqを設定する必要なく —
~fetchingを簡便に利用する仕方を供する。
◎
"client" is changed to a policy container during fetching. It provides a convenient way for standards to not have to set request’s policy container.
</dd>

	<dt>
`~referrer@rq
（ `client^l ）
◎
A request has an associated referrer,＼
</dt>
	<dd>
`no-referrer^l ／
`client^l ／
`~URL$
◎
which is "no-referrer", "client", or a URL. Unless stated otherwise it is "client".
</dd>
	<dd class="note">注記：
`client^l は、
`~fetching$の間に［
`no-referrer^l ／ `~URL$
］に変化する。
この値は、
各種~標準が
— `要請$の`~referrer$rqを設定する必要なく —
~fetchingを簡便に利用する仕方を供する。
◎
"client" is changed to "no-referrer" or a URL during fetching. It provides a convenient way for standards to not have to set request’s referrer.
</dd>

	<dt>
`~referrer施策@rq
（ 空~文字列 ）
◎
A request has an associated referrer policy,＼
</dt>
	<dd>
`~referrer施策$ `REFERRER$r
◎
which is a referrer policy. Unless stated otherwise it is the empty string. [REFERRER]
</dd>
	<dd class="note">注記：
これは、［
この`要請$に利用される~referrer施策
］を上書きするために利用され得る。
◎
This can be used to override the referrer policy to be used for this request.
</dd>

	<dt>
`~mode@rq
（ `no-cors^l ）
◎
A request has an associated mode,＼
</dt>
	<dd>
次のいずれか
⇒＃
`same-origin^l,
`cors^l,
`no-cors^l,
`navigate^l,
`websocket^l
◎
which is "same-origin", "cors", "no-cors", "navigate", or "websocket". Unless stated otherwise, it is "no-cors".
</dd>
	<dd class="note">
<p>注記：
これらの値の意味は：
◎
↓</p>
		<dl>
			<dt>`same-origin^l</dt>
			<dd>
要請が同一-生成元~URLになることを確保するために利用される。
要請を同一-生成元~URLにできなかった場合、
`~fetch$は`~network~error$を返すことになる。
◎
Used to ensure requests are made to same-origin URLs. Fetch will return a network error if the request is not made to a same-origin URL.
</dd>

			<dt>`cors^l</dt>
			<dd>
`応答~tainting$rq が `cors^l に設定される要請を`~CORS要請$にする
— その事例では、
要請された資源が`~CORS~protocol$に［
解されなかった／意図的に関与しないものである
］場合には，~fetchは`~network~error$を返すことになる。
◎
For requests whose response tainting gets set to "cors", makes the request a CORS request — in which case, fetch will return a network error if the requested resource does not understand the CORS protocol, or if the requested resource is one that intentionally does not participate in the CORS protocol.
</dd>

			<dt>`no-cors^l</dt>
			<dd>
要請が［
`~CORS安全とされる~method$,
`~CORS安全とされる要請~header$
］を利用するよう制約する。
成功~時には、
~fetchは`不透明な絞込み応答$を返すことになる。
◎
Restricts requests to using CORS-safelisted methods and CORS-safelisted request-headers. Upon success, fetch will return an opaque filtered response.
</dd>

			<dt>`navigate^l</dt>
			<dd>
これは、
特別な~modeであり，
文書~間で`~navigate$【！~WINDOW#blocking-navigating】するときに限り利用される。
◎
This is a special mode used only when navigating between documents.
</dd>

			<dt>`websocket^l</dt>
			<dd>
これは、
特別な~modeであり，
`~WebSocket接続を確立する$ときに限り利用される。
◎
This is a special mode used only when establishing a WebSocket connection.
</dd>
		</dl>
	</dd>
	<dd class="note">注記：
`要請$の既定の`~mode$rqは `no-cors^l であるが、
標準には［
新たな特能には利用しない
］ことが~~強く奨励される。
それは、
むしろ安全でない。
◎
Even though the default request mode is "no-cors", standards are highly discouraged from using it for new features. It is rather unsafe.
</dd>

	<dt>
`~CORS予行を利用するか@rq
（ ~F ）
◎
A request has an associated use-CORS-preflight flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>
	<dd class="note">注記：
`~CORS予行~要請$が生じるための条件にはいくつかあるが、［
`~CORS予行を利用するか$rq ~EQ ~T
］であることは，その 1 つである。
これは、
次のいずれかの場合に ~T にされる
⇒＃
`XMLHttpRequestUpload$I ~obj上に登録されている~event~listenerがある ／
要請に `ReadableStream$I ~objが利用されている
◎
The use-CORS-preflight flag being set is one of several conditions that results in a CORS-preflight request. The use-CORS-preflight flag is set if either one or more event listeners are registered on an XMLHttpRequestUpload object or if a ReadableStream object is used in a request.
</dd>

	<dt>
`資格証~mode@rq
（ `same-origin^l ）
◎
A request has an associated credentials mode,＼
</dt>
	<dd>
`omit^l ／
`same-origin^l ／
`include^l
◎
which is "omit", "same-origin", or "include". Unless stated otherwise, it is "same-origin".
</dd>
	<dd class="note">
<p>注記：
これらの値の意味は：
◎
↓</p>
		<dl>
			<dt>`omit^l</dt>
			<dd>
この要請には、
資格証を含めない。
返信された応答~内に資格証が在っても，無視させる。
◎
Excludes credentials from this request, and causes any credentials sent back in the response to be ignored.
</dd>

			<dt>`same-origin^l</dt>
			<dd>
同一-生成元~URLにされた要請には、
資格証を含める。
同一-生成元~URLから返信された応答~内に資格証が在れば，利用する。
◎
Include credentials with requests made to same-origin URLs, and use any credentials sent back in responses from same-origin URLs.
</dd>

			<dt>`include^l</dt>
			<dd>
この要請には、
常に資格証を含める。
返信された応答~内に資格証が在れば，常に利用する。
◎
Always includes credentials with this request, and always use any credentials sent back in the response.
</dd>
		</dl>
	</dd>
	<dd class="note">注記：
`要請$の`資格証~mode$rqは、
`~fetch$の間，`資格証$の~flowを制御する。
`要請$の`~mode$rq が `navigate^l のときは、
その`資格証~mode$rqは `include^l と見做される
— 他の値は、
現時点では，`~fetch$に織り込まれていない。
`~HTML^cite がここの所で変更された場合、
この標準も対応する変更が必要になる。
◎
Request’s credentials mode controls the flow of credentials during a fetch. When request’s mode is "navigate", its credentials mode is assumed to be "include" and fetch does not currently account for other values. If HTML changes here, this standard will need corresponding changes.
</dd>

	<dt>
`~URL資格証を利用するか@rq
（ ~F ）
◎
A request has an associated use-URL-credentials flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>
	<dd class="note">注記：
この~flagが ~T をとるときは、［
`要請$の`~URL$rqが`資格証を含んで$いて
【！`~username$url, `~password$url がある】，
`要請$用に可用な`認証~entry$がある
］場合に，`認証~entry$より`~URL$の資格証が選好される。
`~URL$内に資格証を置くことは忌避されるので、
現代の仕様は，この~flagを ~T に設定するのを避けるが、
一部の旧い特能は，互換性の理由から ~T に設定する。
◎
When this flag is set, when a request’s URL has a username and password, and there is an available authentication entry for the request, then the URL’s credentials are preferred over that of the authentication entry. Modern specifications avoid setting this flag, since putting credentials in URLs is discouraged, but some older features set it for compatibility reasons.
</dd>

	<dt>
`~cache~mode@rq
（ `default^l ）
◎
A request has an associated cache mode,＼
</dt>
	<dd>
次のいずれか
⇒＃
`default^l,
`no-store^l,
`reload^l,
`no-cache^l,
`force-cache^l,
`only-if-cached^l
◎
which is "default", "no-store", "reload", "no-cache", "force-cache", or "only-if-cached". Unless stated otherwise, it is "default".
</dd>
	<dd class="note">注記：
		<dl>
			<dt>`default^l</dt>
			<dd>
<p>
`~fetch$は、
~networkへ向かうに先立ち，
~HTTP~cacheを検分する。
~HTTP~cache内に要請に合致している［
(1) `新鮮な応答$が在る ／
(2) `~stale-while-revalidate応答$が在る／
(3) `非新鮮な応答$が在る ／
(4) 応答は無い
］とするとき：
</p>

				<ul>
					<li>
(1) ／ (2)
の場合、
合致したそれを返す。
</li>
					<li>
(2) の場合、
条件付き~network~fetchも為して，
対する応答で~HTTP~cache内の合致したそれを更新する。
</li>
					<li>
(3) の場合、
条件付き~network~fetchを為して，
対する応答で~HTTP~cache内の合致したそれを更新した上で，
その結果を返す。
</li>
					<li>
(4) の場合、
条件付き~でない~network~fetchを為して，
対する応答を返した上で，
その応答で~HTTP~cacheも更新する。
</li>
				</ul>
<p>
`HTTP$r
`HTTP-CACHING$r
`STALE-WHILE-REVALIDATE$r
</p>
◎
Fetch will inspect the HTTP cache on the way to the network. If the HTTP cache contains a matching fresh response it will be returned. If the HTTP cache contains a matching stale-while-revalidate response it will be returned, and a conditional network fetch will be made to update the entry in the HTTP cache. If the HTTP cache contains a matching stale response, a conditional network fetch will be returned to update the entry in the HTTP cache. Otherwise, a non-conditional network fetch will be returned to update the entry in the HTTP cache. [HTTP] [HTTP-CACHING] [STALE-WHILE-REVALIDATE]
</dd>

			<dt>`no-store^l</dt>
			<dd>
~fetchは、
~HTTP~cacheが全く無かったかのように挙動する。
◎
Fetch behaves as if there is no HTTP cache at all.
</dd>

			<dt>`reload^l</dt>
			<dd>
~fetchは、
~networkへ向かう際には，
~HTTP~cacheが全く無かったかのように挙動する。
それがため、
通常の要請を作成して，
対する応答で~HTTP~cacheを更新する。
◎
Fetch behaves as if there is no HTTP cache on the way to the network. Ergo, it creates a normal request and updates the HTTP cache with the response.
</dd>

			<dt>`no-cache^l</dt>
			<dd>
~fetchは、
~HTTP~cache内に要請に合致する応答が
在るならば `条件付き要請$ ／
無いならば 通常の要請
］を作成した上で，
対する応答で~HTTP~cacheを更新する。
◎
Fetch creates a conditional request if there is a response in the HTTP cache and a normal request otherwise. It then updates the HTTP cache with the response.
</dd>

			<dt>`force-cache^l</dt>
			<dd>
~fetchは、
~HTTP~cache内に要請に合致する応答が在るならば，
それが非新鮮であっても利用する。
そのような応答は無いならば、
通常の要請を作成した上で，対する応答で~HTTP~cacheを更新する
◎
Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it creates a normal request and updates the HTTP cache with the response.
</dd>

			<dt>`only-if-cached^l</dt>
			<dd>
~fetchは、
~HTTP~cache内に要請に合致する応答が在るならば，
それが非新鮮であっても利用する。
そのような応答は無いならば、
~network~errorを返す。
（利用できるのは、［
`要請$の`~mode$rq ~EQ `same-origin^l
］の場合に限られる。
~cacheされた~redirectは、［
`要請$の`~redirect~mode$rq ~EQ `follow^l
］~AND［
どの~redirectも`要請$の`~mode$rqに違反しない
］と見做す下で，追従することになる。）
◎
Fetch uses any response in the HTTP cache matching the request, not paying attention to staleness. If there was no response, it returns a network error. (Can only be used when request’s mode is "same-origin". Any cached redirects will be followed assuming request’s redirect mode is "follow" and the redirects do not violate request’s mode.)
</dd>
		</dl>

<p>
`~cache~mode$rqが `default^l の場合、
`~header~list$rq内に［
次のいずれかを`名前に持つ~header$
］が在るならば，`~fetch$により `no-store^l に設定される
⇒＃
`If-Modified-Since$h,
`If-None-Match$h,
`If-Unmodified-Since$h,
`If-Match$h,
`If-Range$h
◎
If header list contains `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache mode to "no-store" if it is "default".
</p>
	</dd>

	<dt>
`~redirect~mode@rq
（ `follow^l ）
◎
A request has an associated redirect mode,＼
</dt>
	<dd>
`follow^l ／
`error^l ／
`manual^l
◎
which is "follow", "error", or "manual". Unless stated otherwise, it is "follow".
</dd>
	<dd class="note">
<p>注記：
これらの値の意味は：
◎
↓</p>
		<dl>
			<dt>`follow^l</dt>
			<dd>
資源の~fetch時に被ったすべての~redirectに追従する。
◎
Follow all redirects incurred when fetching a resource.
</dd>

			<dt>`error^l</dt>
			<dd>
要請が~redirectに出くわしたときには、
`~network~error$を返す。
◎
Return a network error when a request is met with a redirect.
</dd>

			<dt>`manual^l</dt>
			<dd>
要請が~redirectに出くわしたときには、
~swが当の~redirectを~offlineで再生し直すのを許容するため，
`不透明~redirect絞込み応答$を検索取得する。
他の場合、
`~HTTP~redirectの不可分な取扱い$に違反しないよう，
応答は`~network~error$と判別-不能になる。
◎
Retrieves an opaque-redirect filtered response when a request is met with a redirect, to allow a service worker to replay the redirect offline. The response is otherwise indistinguishable from a network error, to not violate atomic HTTP redirect handling.
</dd>
		</dl>
	</dd>

	<dt>
`完全性~metadata@rq
（空~文字列）
◎
A request has associated＼
</dt>
	<dd>
文字列
◎
integrity metadata (a string). Unless stated otherwise, it is the empty string.
</dd>
	<dd class="trans-note">【
~fetchした結果の~dataが，要請する側が期待する~dataと正確に一致するかどうか検証するための~data。
`SRI$r
】</dd>

	<dt>
`暗号用~nonce~metadata@rq
（空~文字列）
◎
A request has associated＼
</dt>
	<dd>
文字列
◎
cryptographic nonce metadata (a string). Unless stated otherwise, it is the empty string.
</dd>

	<dt>
`構文解析器~metadata@rq
（空~文字列）
◎
A request has associated parser＼
</dt>
	<dd>
空~文字列 ／
`parser-inserted^l ／
`not-parser-inserted^l
◎
metadata which is the empty string, "parser-inserted", or "not-parser-inserted". Unless otherwise stated, it is the empty string.
</dd>
	<dd class="trans-note">【
例えば，~scriptが`構文解析-時に挿入されたものかどうか＠~HEscripting#parser-inserted$を表す。
】</dd>
	<dd class="note">注記：
`要請$の［
`暗号用~nonce~metadata$rq,
`構文解析器~metadata$rq
］は、
一般に，`要請$を作成する責を負う~HTML要素~上の各種［
属性, ~flag
］から拡充される【~HTMLの`~script~fetch~option群$も見よ】。
これらは、
~CSPの各種~algoにおいて，所与の文脈の下で［
要請, または応答
］を阻止するかどうか決定するために利用される。
`CSP$r
◎
A request’s cryptographic nonce metadata and parser metadata are generally populated from attributes and flags on the HTML element responsible for creating a request. They are used by various algorithms in Content Security Policy to determine whether requests or responses are to be blocked in a given context. [CSP]
</dd>

	<dt>
`再読込み~naviか@rq
（ ~F ）
◎
A request has an associated reload-navigation flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>
	<dd class="note">注記：
これは、
~HTMLの`~navi~algo$により排他的に利用される。
`HTML$r
◎
This flag is for exclusive use by HTML’s navigate algorithm. [HTML]
</dd>

	<dt>
`履歴~naviか@rq
（ ~F ）
◎
A request has an associated history-navigation flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>
	<dd class="note">注記：
これは、
~HTMLの`~navi~algo$により排他的に利用される。
`HTML$r
◎
This flag is for exclusive use by HTML’s navigate algorithm. [HTML]
</dd>

	<dt>
`利用者が作動化したか@rq
（ ~F ）
◎
A request has an associated boolean user-activation.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is false.
</dd>
	<dd class="note">注記：
これは、
~HTMLの`~navi~algo$により排他的に利用される。
`HTML$r
◎
This is for exclusive use by HTML’s navigate algorithm. [HTML] 
</dd>

	<dt>
`具現化を阻んでいるか@rq
（ ~F ）
◎
A request has an associated boolean render-blocking.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is false.
</dd>
	<dd class="note">注記：
この~flagは、
~HTMLの具現化を阻む仕組みにより排他的に利用される。
`HTML$r
◎
This flag is for exclusive use by HTML’s render-blocking mechanism. [HTML]
</dd>

	<dt>
`~URL~list@rq
（ « `要請$の`~URL$rqの複製 » ）
◎
A request has an associated URL list＼
</dt>
	<dd>
1 個~以上の`~URL$たちが成す`~list$
◎
(a list of one or more URLs). Unless stated otherwise, it is a list containing a copy of request’s URL.
</dd>
	<dd class="trans-note">【
生じた各~redirectに対し，
~redirect先~URLが付加されることになる
（`~HTTP~redirect~fetch$を見よ）。
】</dd>

	<dt>
`現在の~URL@rq
◎
A request has an associated current URL.＼
</dt>
	<dd>
`~URL~list$rq内の最後の`~URL$を指す。
◎
It is a pointer to the last URL in request’s URL list.
</dd>

	<dt>
`~redirect回数@rq
（ 0 ）
◎
A request has an associated redirect count.＼
</dt>
	<dd>
負でない整数
◎
Unless stated otherwise, it is zero.
</dd>

	<dt>
`応答~tainting@rq
（ `basic^l ）
◎
A request has an associated response tainting,＼
</dt>
	<dd>
`basic^l ／
`cors^l ／
`opaque^l
◎
which is "basic", "cors", or "opaque". Unless stated otherwise, it is "basic".
</dd>
	<dd class="trans-note">【
この要請に対する応答は、
何に “~~染まる” か。
ある種の~security施策を与える
（`絞込み応答$の~~種類として反映されることになる）。
】</dd>

	<dt>
`~no-cache時には~cache制御~headerを改変しないか@rq
（ ~F ）
◎
A request has an associated prevent no-cache cache-control header modification flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>

	<dt>
`済んだか@rq
（ ~F ）
◎
A request has an associated done flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>

	<dt>
`計時許容に失敗したか@rq
（ ~F ）
◎
A request has an associated timing allow failed flag.＼
</dt>
	<dd>
真偽値
◎
Unless stated otherwise, it is unset.
</dd>
</dl>

<hr>

<p class="note">注記：
`要請$の次に挙げるものは、
`~fetch$ ~algoの内部状態管理~用に利用される
⇒＃
`~URL~list$rq,
`現在の~URL$rq,
`~redirect回数$rq,
`応答~tainting$rq,
`済んだか$rq,
`計時許容に失敗したか$rq
◎
A request’s URL list, current URL, redirect count, response tainting, done flag, and timing allow failed flag are used as bookkeeping details by the fetch algorithm.
</p>

<hr>

<p>
`下位資源~要請@
とは、
次のいずれかを`行先$rqとする`要請$である
⇒＃
`audio^l,
`audioworklet^l,
`font^l,
`image^l,
`json^l,
`manifest^l,
`paintworklet^l,
`script^l,
`style^l,
`track^l,
`video^l,
`xslt^l,
空~文字列
◎
A subresource request is a request whose destination is "audio", "audioworklet", "font", "image", "json", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", or the empty string.
</p>

<p>
`非~下位資源~要請@
とは、
次のいずれかを`行先$rqとする`要請$である
⇒＃
`document^l,
`embed^l,
`frame^l,
`iframe^l,
`object^l,
`report^l,
`serviceworker^l,
`sharedworker^l,
`worker^l
◎
A non-subresource request is a request whose destination is "document", "embed", "frame", "iframe", "object", "report", "serviceworker", "sharedworker", or "worker".
</p>

<p class="trans-note">【
`下位資源~要請$と排他的であるが、
その論理的な否定
— すべての要請のうち，下位資源~要請ではないもの —
ではないことに注意。
】</p>

<p>
`~navi要請@
とは、
次のいずれかを`行先$rqとする`要請$である
⇒＃
`document^l,
`embed^l,
`frame^l,
`iframe^l,
`object^l,
◎
A navigation request is a request whose destination is "document", "embed", "frame", "iframe", or "object".
</p>

<p class="note">注記：
これらの用語の用法については`~fetchを取扱う$を見よ。
`SW$r
◎
See handle fetch for usage of these terms. [SW]
</p>

<hr>

<div class="algo">
<p>
`要請の生成元は~taintされたか？@
は、
所与の
( `要請$ %要請 )
に対し：
◎
A request request has a redirect-tainted origin if these steps return true:
</p>
<ol>
	<li>
~Assert：
%要請 の`生成元$rq ~NEQ `client^l
◎
Assert: request’s origin is not "client".
</li>
	<li>
%最後の~URL ~LET ~NULL
◎
Let lastURL be null.
</li>
	<li>
<p>
%要請 の`~URL~list$rqを成す
~EACH( %~URL )
に対し：
◎
For each url of request’s URL list:
</p>
		<ol>
			<li>
~IF［
%最後の~URL ~EQ ~NULL
］
⇒＃
%最後の~URL ~SET %~URL；
~CONTINUE
◎
If lastURL is null, then set lastURL to url and continue.
</li>
			<li>
~IF［
%~URL の`生成元$url
~NEQ`生成元$sub
%最後の~URL の`生成元$rq
］~AND［
%要請 の`生成元$rq
~NEQ`生成元$sub
%最後の~URL の`生成元$url
］
⇒
~RET ~T
◎
If url’s origin is not same origin with lastURL’s origin and request’s origin is not same origin with lastURL’s origin, then return true.
</li>
			<li>
%最後の~URL ~SET %~URL
◎
Set lastURL to url.
</li>
		</ol>
	</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<div class="algo">
<p>
`要請の生成元を直列化する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
Serializing a request origin, given a request request, is to run these steps:
</p>
<ol>
	<li>
~Assert：
%要請 の`生成元$rq ~NEQ `client^l
◎
Assert: request’s origin is not "client".
</li>
	<li>
~IF［
`要請の生成元は~taintされたか？$( %要請 ) ~EQ ~T
］
⇒
~RET `null^l
◎
If request has a redirect-tainted origin, then return "null".
</li>
	<li>
~RET `生成元を直列化する$( %要請 の`生成元$rq )
◎
Return request’s origin, serialized.
</li>
</ol>
</div>

<div class="algo">
<p>
`要請の生成元を~byte直列化する@
~algoは、
所与の
( `要請$ %要請 )
に対し
⇒
~RET `同型に符号化する$( `要請の生成元を直列化する$( %要請 ) )
◎
Byte-serializing a request origin, given a request request, is to return the result of serializing a request origin with request, isomorphic encoded.
</p>
</div>

<hr>

<div class="algo">
<p>
`要請を~cloneする@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To clone a request request, run these steps:
</p>
<ol>
	<li>
%新~要請 ~LET
%要請 の`本体$rqを除いた部分の複製
◎
Let newRequest be a copy of request, except for its body.
</li>
	<li>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］
⇒
%新~要請 の`本体$rq ~SET `本体を~cloneする$( %要請 の`本体$rq )
◎
If request’s body is non-null, set newRequest’s body to the result of cloning request’s body.
</li>
	<li>
~RET %新~要請
◎
Return newRequest.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`範囲~headerを追加する@
~algoは、
所与の
( `要請$ %要請, 整数 %先頭, 整数 %末尾 （省略時は ε ）)
に対し：
◎
To add a range header to a request request, with an integer first, and an optional integer last, run these steps:
</p>
<ol>
	<li>
~Assert：
［
%末尾 ~EQ ε
］~OR［
%先頭 ~LTE %末尾
］
◎
Assert: last is not given, or first is less than or equal to last.
</li>
	<li>
%範囲~値 ~LET `bytes=^bl
◎
Let rangeValue be `bytes=`.
</li>
	<li>
%範囲~値 に次の結果を付加する
⇒
`同型に符号化する$( `整数を直列化する$( %先頭 ) )
◎
Serialize and isomorphic encode first, and append the result to rangeValue.
</li>
	<li>
%範囲~値 に `2D^X （ `-^bl ）を付加する
◎
Append 0x2D (-) to rangeValue.
</li>
	<li>
~IF［
%末尾 ~NEQ ε
］
⇒
%範囲~値 に次の結果を付加する
⇒
`同型に符号化する$( `整数を直列化する$( %末尾 ) )
◎
If last is given, then serialize and isomorphic encode it, and append the result to rangeValue.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Range$h,  %範囲~値 )
)
◎
Append (`Range`, rangeValue) to request’s header list.
</li>
</ol>

<p class="note">注記：
範囲~headerが表す~byte範囲は、
先頭, 末尾も含む。
( %先頭, %末尾 ) ~EQ ( 0, 500 ) ならば 501 個の~byteからなる範囲になる。
◎
A range header denotes an inclusive byte range. There a range header where first is 0 and last is 500, is a range of 501 bytes.
</p>

<p class="note">注記：
複数の応答を 1 個の論理的な資源に組合せる特能は、
歴史的に~security~bugの~sourceになる。
部分的~応答に対処する特能に対する~security考査を探されたし。
◎
Features that combine multiple responses into one logical resource are historically a source of security bugs. Please seek security review for features that deal with partial responses.
</p>
</div>

<hr>

<div class="algo">
<p>
`応答~URLを報告-用に直列化する@
~algoは、
所与の
( `応答$ %応答 )
に対し：
◎
To serialize a response URL for reporting, given a response response, run these steps:
</p>
<ol>
	<li>
%応答 の`~URL~list$rsは`空$でない
◎
Assert: response’s URL list is not empty.
</li>
	<li>
<p>
%~URL ~LET %応答 の`~URL~list$rs[ 0 ] の複製
◎
Let url be a copy of response’s URL list[0].
</p>

<p class="note">注記：
~redirect~targetについての情報が漏洩するのを避けるため、
これは， %応答 の`~URL$rsではない
（`~CSP報告-用の類似な考慮点＠~CSP3#security-violation-reports$も見よ）。
`CSP$r
◎
This is not response’s URL in order to avoid leaking information about redirect targets (see similar considerations for CSP reporting too). [CSP]
</p>
	</li>
	<li>
`~URLの~usernameを設定する$( %~URL, 空~文字列 )
◎
Set the username given url and the empty string.
</li>
	<li>
`~URLの~passwordを設定する$( %~URL, 空~文字列 )
◎
Set the password given url and the empty string.
</li>
	<li>
~RET `~URLを直列化する$( %~URL, `素片は除外する$i )
◎
Return the serialization of url with exclude fragment set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`~Cross-Origin-Embedder-Policyは資格証を許容するか？@
は、
所与の
( `要請$ %要請 )
に対し：
◎
To check if Cross-Origin-Embedder-Policy allows credentials, given a request request, run these steps:
</p>
<ol>
	<li>
~Assert：
%要請 の`生成元$rq ~NEQ `client^l
◎
Assert: request’s origin is not "client".
</li>
	<li>
<p>
~RET ~IS ~OR↓：
</p>
		<ul>
			<li>
%要請 の`~mode$rq ~NEQ `no-cors^l
</li>
			<li>
%要請 の`~client$rq ~EQ ~NULL
</li>
			<li>
%要請 の`~client$rqの`施策~容器$enVの`埋込元~施策$pCの`値$embP ~NEQ `credentialless$l
</li>
			<li>
<p>
~AND↓：
</p>
				<ul>
					<li>
%要請 の`生成元$rq
~EQ`生成元$sub
%要請 の`現在の~URL$rqの`生成元$url
</li>
					<li>
`要請の生成元は~taintされたか？$( %要請 ) ~EQ ~F
</li>
				</ul>
			</li>
		</ul>
◎
If request’s mode is not "no-cors", then return true.
◎
If request’s client is null, then return true.
◎
If request’s client’s policy container’s embedder policy’s value is not "credentialless", then return true.
◎
If request’s origin is same origin with request’s current URL’s origin and request does not have a redirect-tainted origin, then return true.
◎
Return false.
</li>
</ol>
</div>

			</section>
			<section id="responses">
<h3 title="Responses">2.2.6. 応答</h3>

<p>
`応答@
（ `response^en ）とは、
`~fetch$の結果である。
`応答$は、
時間~越しに発展していくものであり，
その各種~fieldすべてが直ぐに可用になるわけではない。
【~HTTPにおける`応答~message＠~HTTPinfra#response$に対応する。】
◎
The result of fetch is a response. A response evolves over time. That is, not all its fields are available straight away.
</p>

<p>
各 `応答$には、
以下に挙げるものが結付けられる。
各~項には，それがとり得る値を示す。
他が言明されない限り、［
見出しの括弧内に与える値
］を既定~値としてとるものとする：
◎
↓</p>

<dl class="def-list">
	<dt>
`種別@rs
（ `default^l ）
◎
A response has an associated type＼
</dt>
	<dd>
次のいずれか
⇒＃
`basic^l,
`cors^l,
`default^l,
`error^l,
`opaque^l,
`opaqueredirect^l
◎
which is "basic", "cors", "default", "error", "opaque", or "opaqueredirect". Unless stated otherwise, it is "default".
</dd>

	<dt>
`中止されたか@rs
（ ~F ）
◎
A response can have an associated aborted flag,＼
</dt>
	<dd>
真偽値
◎
which is initially unset.
</dd>
	<dd class="note">注記：
これは、
~T ならば［
開発者／末端-利用者
］が要請を意図的に中止したことを指示する。
◎
This indicates that the request was intentionally aborted by the developer or end-user.
</dd>

	<dt>
`~URL@rs
◎
A response has an associated URL.＼
</dt>
	<dd>
`~URL~list$rsを成す最後の`~URL$を指す
— `~URL~list$rsが`空$ならば ~NULL とする。
◎
It is a pointer to the last URL in response’s URL list and null if response’s URL list is empty.
</dd>

	<dt>
`~URL~list@rs
（ « » ）
◎
A response has an associated URL list＼
</dt>
	<dd>
`~URL$たちが成す`~list$
◎
(a list of zero or more URLs). Unless stated otherwise, it is « ».
</dd>
	<dd class="note">注記：
この~listは、
最初と最後の`~URL$を除いて，~scriptには公開されない
— そうすると`~HTTP~redirectの不可分な取扱い$に違反するので。
◎
Except for the first and last URL, if any, a response’s URL list is not directly exposed to script as that would violate atomic HTTP redirect handling.
</dd>

	<dt>
`状態s@rs
（ `200$st ）
◎
A response has an associated status,＼
</dt>
	<dd>
`状態s$
◎
which is a status. Unless stated otherwise it is 200.
</dd>

	<dt>
`状態s~message@rs
（ 空`~byte列$ ）
◎
A response has an associated status message.＼
</dt>
	<dd>
`~byte列$
◎
Unless stated otherwise it is the empty byte sequence.
</dd>
	<dd class="note">注記：
~HTTP2接続~越しの応答においては、
その状態s~messageは，常に空な~byte列になる
— ~HTTP2はそれを~supportしないので。
◎
Responses over an HTTP/2 connection will always have the empty byte sequence as status message as HTTP/2 does not support them.
</dd>
	<dd class="trans-note">【
~HTTP1xの文脈では，応答の `reason-phrase$p を表現する。
】</dd>

	<dt>
`~header~list@rs
（ « » ）
◎
A response has an associated header list＼
</dt>
	<dd>
`~header~list$
◎
(a header list). Unless stated otherwise it is « ».
</dd>

	<dt>
`本体@rs
（ ~NULL ）
◎
A response has an associated body＼
</dt>
	<dd>
~NULL ／`本体$
◎
(null or a body). Unless stated otherwise it is null.
</dd>
	<dd class="note">注記：
~networkの`応答$の`本体$rsにおいては、
その［
`~source$bd ／ `長さ$bd
］の概念は常に ~NULL になる。
◎
The source and length concepts of a network’s response’s body are always null.
</dd>

	<dt>
`~cache状態@rs
（ 空~文字列 ）
◎
A response has an associated cache state＼
</dt>
	<dd>
次のいずれか
⇒＃
空~文字列,
`local^l,
`validated^l
◎
(the empty string, "local", or "validated"). Unless stated otherwise, it is the empty string.
</dd>
	<dd class="note">注記：
これは、［
`SW$r ／ `RESOURCE-TIMING$r
］用途に意図される。
◎
This is intended for usage by Service Workers and Resource Timing. [SW] [RESOURCE-TIMING]
</dd>

	<dt>
`~CORSに公開される~header名~list@rs
（空~list）
◎
A response has an associated CORS-exposed header-name list＼
</dt>
	<dd>
`~header$の`名前$hdたちが成す~list
◎
(a list of zero or more header names). The list is empty unless otherwise specified.
</dd>
	<dd class="note">注記：
`応答$の`~CORSに公開される~header名~list$rsは、
概して［
`Access-Control-Expose-Headers$h ~headerから`値を抽出-$した結果
］に設定されることになる。
この~listは、［
`~CORS絞込み応答$において公開する~headerを決定するとき
］に利用される。
◎
A response will typically get its CORS-exposed header-name list set by extracting header values from the `Access-Control-Expose-Headers` header. This list is used by a CORS filtered response to determine which headers to expose.
</dd>

	<dt>
`範囲が要請されたか@rs
（ ~F ）
◎
A response has an associated range-requested flag,＼
</dt>
	<dd>
真偽値
◎
which is initially unset.
</dd>
	<dd class="note">注記：
これは、［
過去の範囲~付き要請からの部分的~応答が，
範囲~要請を為さなかった~APIに供される
］のを防止するために利用される。
これの用途については、
その攻撃の詳細な記述を見よ。
◎
This is used to prevent a partial response from an earlier ranged request being provided to an API that didn’t make a range request. See the flag’s usage for a detailed description of the attack.
</dd>

	<dt>
`要請は資格証を含むか@rs
（ ~T ）
◎
A response has an associated request-includes-credentials＼
</dt>
	<dd>
真偽値
◎
(a boolean), which is initially true.
</dd>

	<dt>
`計時許容に合格したか@rs
（ ~F ）
◎
A response has an associated timing allow passed flag,＼
</dt>
	<dd>
真偽値
◎
which is initially unset.
</dd>
	<dd class="note">注記：
これは、
~fetchの~call元が［
返された応答に対し これを調べて，
~fetchされた資源に対する敏感な計時~dataは許容されるか否か
］を決定できるようにするために利用される。
これはまた，~redirectに対する応答に対しては［
~redirect連鎖における直前の応答にて ~T
］ならば ~T に設定する必要があるので、
要請の`計時許容に失敗したか$rqを利用して内部的に追跡される。
◎
This is used so that the caller to a fetch can determine if sensitive timing data is allowed on the resource fetched by looking at the flag of the response returned. Because the flag on the response of a redirect has to be set if it was set for previous responses in the redirect chain, this is also tracked internally using the request’s timing allow failed flag.
</dd>

	<dt>
`本体~報@rs
（新たな`応答~本体~報$）
◎
A response has an associated body info＼
</dt>
	<dd>
`応答~本体~報$
◎
(a response body info). Unless stated otherwise, it is a new response body info.
</dd>

	<dt>
`~sw計時~報@rs
（ ~NULL ）
◎
A response has an associated service worker timing info＼
</dt>
	<dd>
~NULL ／ `~sw計時~報$
◎
(null or a service worker timing info), which is initially null.
</dd>

	<dt>
`非同一-生成元~redirectはあるか@rs
（ ~F ）
◎
A response has an associated has-cross-origin-redirects＼
</dt>
	<dd>
真偽値
◎
(a boolean), which is initially false.
</dd>
</dl>

<hr>

<div class="p">
<p>
`~network~error@
は、
~AND↓ を満たすようにされた`応答$である：
</p>

<ul ><li>`種別$rs ~EQ `error^l
</li><li>`状態s$rs ~EQ 0
</li><li>`状態s~message$rs ~EQ 空な~byte列
</li><li>`~header~list$rs ~EQ ある`空$な`~list$
</li><li>`本体$rs ~EQ ~NULL
</li><li>`本体~報$rs ~EQ ある新たな`応答~本体~報$
</li></ul>

◎
A network error is a response whose type is "error", status is 0, status message is the empty byte sequence, header list is « », body is null, and body info is a new response body info.
</div>

<p>
`中止~network~error@
とは、
次を満たす`~network~error$である
⇒
`中止されたか$rs ~EQ ~T
◎
An aborted network error is a network error whose aborted flag is set.
</p>


<div class="algo">
<p>
`適切な~network~error@
を作成するときは、
所与の
( `~fetch~params$ %~fetch~params )
に対し：
◎
To create the appropriate network error given fetch params fetchParams:
</p>
<ol>
	<li>
~Assert：
%~fetch~params は`取消された$fP
◎
Assert: fetchParams is canceled.
</li>
	<li>
~IF［
%~fetch~params は`中止された$fP
］
⇒
~RET `中止~network~error$
◎
Return an aborted network error if fetchParams is aborted;＼
</li>
	<li>
~RET `~network~error$
◎
otherwise return a network error.
</li>
</ol>
</div>

<hr>

<p>
`絞込み応答@
は、
それに結付けられた`応答$の【一部分に】制限された~viewを提供する`応答$である。
この結付けられた`応答$は、
`絞込み応答$の
`内部~応答@
（`~network~error$でも`絞込み応答$でもない`応答$）を通して~accessできる。
◎
A filtered response is a response that offers a limited view on an associated response. This associated response can be accessed through filtered response’s internal response (a response that is neither a network error nor a filtered response).
</p>

<p>
他が言明されない限り、
`絞込み応答$に結付けられた概念（その`本体$rsなど）は，
その`内部~応答$に結付けられた概念を参照rする。
（これに対する例外は、
以下において［
`絞込み応答$の各種 具象-型
］を定義する所で挙げられる。）
◎
Unless stated otherwise a filtered response’s associated concepts (such as its body) refer to the associated concepts of its internal response. (The exceptions to this are listed below as part of defining the concrete types of filtered responses.)
</p>

<div class="note">
<p>注記：
`~fetch$ ~algoは，情報が不用意に漏洩されないことを確保するため、［
`応答の処理n$i, あるいは等価な~parameter
］を通す仕方により，~call元に`絞込み応答$を公開する。
各~仕様の~algoは、
旧来の理由から情報を露呈する必要がある場合
— 例：画像~dataを復号器に投入するため —
には，結付けられた`内部~応答$を利用できる。
◎
The fetch algorithm by way of processResponse and equivalent parameters exposes filtered responses to callers to ensure they do not accidentally leak information. If the information needs to be revealed for legacy reasons, e.g., to feed image data to a decoder, the associated internal response can be used by specification algorithms.
</p>

<p>
新たな仕様は、［
`不透明な絞込み応答$／`不透明~redirect絞込み応答$
］を更に築かないこと。
これらは旧来の構成子であり、
現今の~computer~architectureの下では，常に必要十分に保護できるとは限らないので。
◎
New specifications ought not to build further on opaque filtered responses or opaque-redirect filtered responses. Those are legacy constructs and cannot always be adequately protected given contemporary computer architecture.
</p>
</div>

<div class="p">
<p>
`基本~絞込み応答@
とは、
~AND↓ を満たすようにされた`絞込み応答$である：
</p>
<ul>
	<li>
`種別$rs ~EQ `basic^l
</li>
	<li>
`~header~list$rsは、
`内部~応答$の`~header~list$rsから 次に該当する`~header$は除外したものからなる
⇒
`名前$hdは `禁止~応答~header名$である
</li>
</ul>
◎
A basic filtered response is a filtered response whose type is "basic" and header list excludes any headers in internal response’s header list whose name is a forbidden response-header name.
</div>

<div class="p">
<p>
`~CORS絞込み応答@
とは、
~AND↓ を満たすようにされた`絞込み応答$である：
</p>
<ul>
	<li>
`種別$rs ~EQ `cors^l
</li>
	<li>
`~header~list$rsは、
`内部~応答$の`~header~list$rsから［
次を満たす`~header名$を`名前に持つ~header$は除外したもの
］からなる
⇒
`内部~応答$の`~CORSに公開される~header名~list$rs内の`~CORS安全とされる応答~header名$でない
</li>
</ul>
◎
A CORS filtered response is a filtered response whose type is "cors" and header list excludes any headers in internal response’s header list whose name is not a CORS-safelisted response-header name, given internal response’s CORS-exposed header-name list.
</div>

<div>
<p>
`不透明な絞込み応答@
とは、
~AND↓ を満たすようにされた`絞込み応答$である：
</p>

<ul ><li>`種別$rs ~EQ `opaque^l
</li><li>`~URL~list$rs ~EQ ある`空$な`~list$
</li><li>`状態s$rs ~EQ 0
</li><li>`状態s~message$rs ~EQ 空な~byte列
</li><li>`~header~list$rs ~EQ ある`空$な`~list$
</li><li>`本体$rs ~EQ ~NULL
</li><li>`本体~報$rs ~EQ ある新たな`応答~本体~報$
</li></ul>

◎
An opaque filtered response is a filtered response whose type is "opaque", URL list is « », status is 0, status message is the empty byte sequence, header list is « », body is null, and body info is a new response body info.
</div>

<div>
<p>
`不透明~redirect絞込み応答@
とは、
~AND↓ を満たすようにされた`絞込み応答$である：
</p>

<ul ><li>`種別$rs ~EQ `opaqueredirect^l
</li><li>`状態s$rs ~EQ 0
</li><li>`状態s~message$rs ~EQ 空な~byte列
</li><li>`~header~list$rs ~EQ ある`空$な`~list$
</li><li>`本体$rs ~EQ ~NULL
</li><li>`本体~報$rs ~EQ ある新たな`応答~本体~報$
</li></ul>

◎
An opaque-redirect filtered response is a filtered response whose type is "opaqueredirect", status is 0, status message is the empty byte sequence, header list is « », body is null, and body info is a new response body info.
</div>

<div class="note">注記：

<p>
`不透明~redirect絞込み応答$に対しては、
~redirectは後続しないので，`~URL~list$rsが公開されても無害である。
◎
Exposing the URL list for opaque-redirect filtered responses is harmless since no redirects are followed.
</p>

<p>
言い換えれば、［
`不透明な絞込み応答$, `不透明~redirect絞込み応答$
］と`~network~error$とは，ほとんど判別できない。
新たな~APIを導入する際には、
情報を漏洩させなくするため，仕様の内部~algoには
`内部~応答$を利用しないこと。
◎
In other words, an opaque filtered response and an opaque-redirect filtered response are nearly indistinguishable from a network error. When introducing new APIs, do not use the internal response for internal specification algorithms as that will leak information.
</p>

<p>
これはまた、
`response.ok$m などの~JS~APIが返す結果は，
およそ役に立たないことを意味する。
◎
This also means that JavaScript APIs, such as response.ok, will return rather useless results.
</p>
</div>

<div class="example">
<p>
`応答$の`種別$rsは、
`type＠#dom-response-type$m 取得子を通して~scriptに公開される：
◎
The type of a response is exposed to script through the type getter:
</p>

<pre class="lang-js">
console.log(new Response().type); // "default"

console.log((await fetch("/")).type); // "basic"

console.log((await fetch("https://api.example/status")).type); // "cors"

console.log((await fetch("https://crossorigin.example/image", { mode: "no-cors" })).type); // "opaque"

console.log((await fetch("/surprise-me", { redirect: "manual" })).type); // "opaqueredirect"
</pre>

<p>
（ここでは、［
各種~資源は存在する，
`https://api.example/status^c は適切な~CORS~headerを伴う，
`/surprise-me^c は`~redirect状態s$を利用する
］ものと見做す。）
◎
(This assumes that the various resources exist, https://api.example/status has the appropriate CORS headers, and /surprise-me uses a redirect status.)
</p>
</div>

<hr>

<div class="algo">
<p>
`応答を~cloneする@
~algoは、
所与の
( `応答$ %応答 )
に対し：
◎
To clone a response response, run these steps:
</p>
<ol>
	<li>
~IF［
%応答 は`絞込み応答$である
］
⇒
~RET 新たな`絞込み応答$
— その
⇒＃
`内部~応答$ ~SET `応答を~cloneする$( %応答 の`内部~応答$ )；
他の部分は %応答 と一致する
◎
If response is a filtered response, then return a new identical filtered response whose internal response is a clone of response’s internal response.
</li>
	<li>
%新~応答 ~LET %応答 の`本体$rsを除いた部分の複製
◎
Let newResponse be a copy of response, except for its body.
</li>
	<li>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］
⇒
%新~応答 の`本体$rs ~SET `本体を~cloneする$( %応答 の`本体$rs )
◎
If response’s body is non-null, then set newResponse’s body to the result of cloning response’s body.
</li>
	<li>
~RET %新~応答
◎
Return newResponse.
</li>
</ol>
</div>

<hr>

<p>
`新鮮な応答@
とは、
次を満たす`応答$である
⇒
`現在の齢$は`鮮度~維持期間$を過ぎていない
`HTTP-CACHING$r
◎
A fresh response is a response whose current age is within its freshness lifetime.
</p>

<p>
`~stale-while-revalidate応答@
とは、
次を満たす`応答$である
⇒
［
`新鮮な応答$でない
］~AND［
`現在の齢$は
`~stale-while-revalidate維持期間＠https://httpwg.org/specs/rfc5861.html#n-the-stale-while-revalidate-cache-control-extension$
【！~RFCx/rfc5861#section-3】
`STALE-WHILE-REVALIDATE$r
を過ぎていない
］
◎
A stale-while-revalidate response is a response that is not a fresh response and whose current age is within the stale-while-revalidate lifetime. [HTTP-CACHING] [STALE-WHILE-REVALIDATE]
</p>

<p class="trans-note">【
~stale-while-revalidate `Cache-Control$h 指令を伴わない応答は、
該当し得ないことになる（維持期間は “無い” ので）。
】</p>

<p>
`非新鮮な応答@
とは、
次を満たす`応答$である
⇒
［
`新鮮な応答$でない
］~AND［
`~stale-while-revalidate応答$でない
］
◎
A stale response is a response that is not a fresh response or a stale-while-revalidate response.
</p>

<p class="trans-note">【
`~HTTPが定義する非新鮮＠~HTTPcache#stale$（新鮮の否定）より狭義になる。
】</p>

<hr>

<div class="algo">
<p>
`応答の~Location~URLを得る@
~algoは、
所与の
( `応答$ %応答, ~NULLまたは`~ASCII文字列$ %要請~素片 )
に対し，［
~NULL ／ `失敗^i ／ `~URL$
］を返す：
◎
The location URL of a response response, given null or an ASCII string requestFragment, is the value returned by the following steps. They return null, failure, or a URL.
</p>
<ol>
	<li>
~IF［
%応答 の`状態s$rsは`~redirect状態s$でない
］
⇒
~RET ~NULL
◎
If response’s status is not a redirect status, then return null.
</li>
	<li>
%~Location ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Location$h )
◎
Let location be the result of extracting header list values given `Location` and response’s header list.
</li>
	<li>
<p>
~IF［
%~Location は`~header値$である
］
⇒
%~Location ~SET `~URL構文解析する$( %~Location, %応答 の`~URL$rs )
◎
If location is a header value, then set location to the result of parsing location with response’s URL.
</p>

<p class="note">注記：
%応答 が `new Response()$m 構築子を通して構築されていた場合、
%応答 の`~URL$rsは ~NULL になる
— その結果，
%~Location が成功裡に構文解析されるのは、
それが`素片~付き絶対~URL文字列$である場合に限られることになる。
◎
If response was constructed through the Response constructor, response’s URL will be null, meaning that location will only parse successfully if it is an absolute-URL-with-fragment string.
</p>
	</li>
	<li>
<p>
~IF［
%~Location は`~URL$である
］~AND［
%~Location の`素片$url ~EQ ~NULL
］
⇒
%~Location の`素片$url ~SET %要請~素片
◎
If location is a URL whose fragment is null, then set location’s fragment to requestFragment.
</p>

<p class="note">注記：
この段は、
合成な応答【構築子を通して構築されたそれ】が（~~実際，すべてのそれが）［
~HTTPにより定義される~redirectに対し，その処理~modelに従う
］ことを確保する。
`HTTP$r
◎
This ensures that synthetic (indeed, all) responses follow the processing model for redirects defined by HTTP. [HTTP]
</p>
	</li>
	<li>
~RET %~Location
◎
Return location.
</li>
</ol>

<div class="note">
<p>注記：
`応答の~Location~URLを得る$ ~algoが利用されるのは、
次に挙げる所~以外にない：
</p>
<ul>
	<li>
この標準における~redirectの取扱い
</li>
	<li>
`~HTML^cite `HTML$r の`~navi~algo$†（それは、~redirectを手動で取扱う）
【†特に、その中で`~fetchingにより~navi~paramsを作成する＠~HTMLnav#create-navigation-params-by-fetching$とき。】
</li>
</ul>
◎
The location URL algorithm is exclusively used for redirect handling in this standard and in HTML’s navigate algorithm which handles redirects manually. [HTML]
</div>
</div>

			</section>
			<section id="miscellaneous">
<h4 title="Miscellaneous">2.2.7. その他</h4>

<div class="p">
<p>
`行先の素@
（ `potential destination^en ）は、
次のいずれかである：
</p>

<ul ><li>`fetch^l
</li><li>空~文字列でない`行先$rq
</li></ul>

◎
A potential destination is "fetch" or a destination which is not the empty string.
</div>

<div class="algo">
<p>
`行先に翻訳する@
~algoは、
所与の
( `行先の素$ %行先の素 )
に対し：
◎
To translate a potential destination potentialDestination, run these steps:
</p>
<ol>
	<li>
~IF［
%行先の素 ~EQ `fetch^l
］
⇒
~RET 空~文字列
◎
If potentialDestination is "fetch", then return the empty string.
</li>
	<li>
~Assert：
%行先の素 は`行先$rqである
◎
Assert: potentialDestination is a destination.
</li>
	<li>
~RET %行先の素
◎
Return potentialDestination.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="authentication-entries">
<h3 title="Authentication entries">2.3. 認証~entry</h3>

<p>
`認証~entry@
／
`~proxy認証~entry@
は、［
~HTTP認証／~HTTP~proxy認証
］に利用される［
~username, ~password, ~realm†
］の組であり，1 つ以上の`要請$に結付けられる。
【† ~HTTPの`~realm＠~HTTPsem#realm$ 】
◎
An authentication entry and a proxy-authentication entry are tuples of username, password, and realm, used for HTTP authentication and HTTP proxy authentication, and associated with one or more requests.
</p>

<p>
~UAは、［
~HTTP~cookieと, それに類する追跡~機能性
］が一緒に~clearされることを，許容するベキである。
◎
User agents should allow both to be cleared together with HTTP cookies and similar tracking functionality.
</p>

<p>
更なる詳細は~HTTPにて定義される。
`HTTP$r
`HTTP-CACHING$r
◎
Further details are defined by HTTP. [HTTP] [HTTP-CACHING]
</p>
		</section>
		<section id="fetch-groups">
<h3 title="Fetch groups">2.4. ~fetch~group</h3>

<p>
各 `環境~設定群~obj$には、
`~fetch~group@
が結付けられる。
◎
Each environment settings object has an associated fetch group.
</p>

<p>
各`~fetch~group$は、
`~fetch記録@
たちが成す有順序~listを保持する。
◎
A fetch group holds an ordered list of fetch records.
</p>

<p>
各`~fetch記録$には、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`要請@fR
⇒
`要請$
◎
A fetch record has an associated request (a request).
</li>
	<li>
`制御器@fR
⇒
`~fetch制御器$ ／ ~NULL
◎
A fetch record has an associated controller (a fetch controller or null).
</li>
</ul>

<hr>

<div class="algo">
<p>
`~fetch~groupを終了する@
~algoは、
所与の
( `~fetch~group$ %G )
に対し
⇒
%G を成す
~EACH( `~fetch記録$ %記録 )
に対し
⇒
~IF［
%記録 の`制御器$fR ~NEQ ~NULL
］
⇒
~IF［
%記録 の`要請$fRは［［
`済んだか$rq ~EQ ~F
］~OR［
`~keepaliveか$rq ~EQ ~F
］］を満たす
］
⇒
`~fetchを終了する$( %記録 の`制御器$fR )
◎
When a fetch group is terminated, for each associated fetch record whose fetch record’s controller is non-null, and whose request’s done flag is unset or keepalive is false, terminate the fetch record’s controller.
</p>
</div>

		</section>
		<section id="resolving-domains">
<h3 title="Resolving domains">2.5. ~domainの解決-法</h3>

<div class="algo">
<p>
◎追跡路
`生成元を解決する@
~algoは、
所与の
( `~network区分~key$ %~key, `生成元$ %生成元 )
に対し：
◎
(This is a tracking vector.)
To resolve an origin, given a network partition key key and an origin origin: 
</p>
<ol>
	<li>
%~host ~LET %生成元 の`~host$o
◎
↓</li>
	<li>
~IF［
%~host は`~IP~address$である
］
⇒
~RET « %~host »
◎
If origin’s host is an IP address, then return « origin’s host ».
</li>
	<li>
~IF［
%~host の`公共~接尾辞$ ~IN { `localhost^l, `localhost.^l }
］
⇒
~RET « `::1^c, `127.0.0.1^c »
【順に，~IPv6, ~IPv4用の~loopback~address】
◎
If origin’s host’s public suffix is "localhost" or "localhost.", then return « ::1, 127.0.0.1 ».
</li>
	<li>
<p>
%生成元 を［
1 個~以上の`~IP~address$たちが成す`集合$
］に転換する`実装定義$な演算を遂行する
◎
Perform an implementation-defined operation to turn origin into a set of one or more IP addresses.
</p>

<p>
加えて、
`~IP~address$を超える接続~情報を取得するために，他の`実装定義$な演算を遂行してもよい。
例えば， %生成元 の`~scheme$oは`~HTTP_S~scheme$である場合、
実装は，~HTTPS-RR【~HTTPS資源~record】 `SVCB$r 用の~DNS~queryを遂行することもあろう。
◎
It is also implementation-defined whether other operations might be performed to get connection information beyond just IP addresses. For example, if origin’s scheme is an HTTP(S) scheme, the implementation might perform a DNS query for HTTPS RRs. [SVCB]
</p>
	</li>
	<li>
~IF［
前~段の演算は成功した
］
⇒
~RET 結果の集合と追加的な`実装定義$な情報
◎
If this operation succeeds, return the set of IP addresses and any additional implementation-defined information.
</li>
	<li>
~RET `失敗^i
◎
Return failure.
</li>
</ol>

<p>
`生成元を解決-$した結果は~cacheしてもヨイ
— ~cacheした場合、
%~key を~cache~keyの一部として利用するベキである。
◎
The results of resolve an origin may be cached. If they are cached, key should be used as part of the cache key.
</p>

<div class="note">
<p>注記：
この演算は、
概して，~DNSを孕むことになろう
— そのような~cache法は、
~DNS~server上で， %~key を織り込まない下で起こり得る。
%~key を局所的に織り込むことも，実装に依存してアリでないかもしれない。
`RFC1035$r
◎
Typically this operation would involve DNS and as such caching can happen on DNS servers without key being taken into account. Depending on the implementation it might also not be possible to take key into account locally. [RFC1035]
</p>

<p>
返される`~IP~address$たちの順序は、
呼出nの回ごとに相違し得る。
◎
The order of the IP addresses that the resolve an origin algorithm can return can differ between invocations.
</p>

<p>
~~仔細は、
（~cache~keyは別として）ここでは定められない
— それらは、
`~Fetch標準^cite が確立する~systemから~~縁遠いので。
他の文書は、
まず，~Fetch標準~communityとの討論を経ない限り、
この~primitiveの上に築かれるべきでない。
◎
The particulars (apart from the cache key) are not tied down as they are not pertinent to the system the Fetch Standard establishes. Other documents ought not to build on this primitive without having a considered discussion with the Fetch Standard community first.
</p>
</div>
</div>

		</section>
		<section id="connections">
<h3 title="Connections">2.6. 接続</h3>

<div>
<p>
各~UAには
`接続~pool@
が結付けられる
— それは、
`接続@
たちが成す`有順序~集合$である。
</p>

<p>
各 `接続$には、
次に挙げるものが結付けられる：
</p>
<ul>
	<li>
`~key@cN
⇒
`~network区分~key$
</li>
	<li>
`生成元@cN
⇒
`生成元$
</li>
	<li>
`資格証を伴うか@cN
⇒
真偽値
</li>
	<li>
`計時~報@
⇒
`接続~計時~報$
</li>
</ul>

<p>
`接続$どうしは、
これらのうち
( `~key$cN, `生成元$cN, `資格証を伴うか$cN )
が成す組で識別される。
</p>
◎
A user agent has an associated connection pool. A connection pool is an ordered set of zero or more connections. Each connection is identified by an associated key (a network partition key), origin (an origin), and credentials (a boolean).
◎
Each connection has an associated timing info (a connection timing info).
</div>

<p>
`接続~計時~報@
は、
次に挙げる`~item$sctからなる`構造体$であり，［
接続を得する処理nに該当する計時~情報を保守する
］ために利用される：
◎
A connection timing info is a struct used to maintain timing information pertaining to the process of obtaining a connection. It has the following items:
</p>

<dl class="def-list">
	<dt>
`~domain検索~開始~時刻@cT
（既定は 0 ）
◎
domain lookup start time (default 0)
</dt>
	<dt>
`~domain検索~終了~時刻@cT
（既定は 0 ）
◎
domain lookup end time (default 0)
</dt>
	<dt>
`接続~開始~時刻@cT
（既定は 0 ）
◎
connection start time (default 0)
</dt>
	<dt>
`接続~終了~時刻@cT
（既定は 0 ）
◎
connection end time (default 0)
</dt>
	<dt>
`~secure接続~開始~時刻@cT
（既定は 0 ）
◎
secure connection start time (default 0)
</dt>
	<dd>
`DOMHighResTimeStamp$I
◎
A DOMHighResTimeStamp.
</dd>

	<dt>
`折衝した~ALPN~protocol~ID@cT
（既定は空な`~byte列$）
◎
ALPN negotiated protocol (default the empty byte sequence)
</dt>
	<dd>
`~byte列$
◎
A byte sequence.
</dd>
</dl>

<div class="algo">
<p>
`接続~計時~報を切詰めて粗化する@
~algoは、
所与の
( `接続~計時~報$ %計時~報,
`DOMHighResTimeStamp$I %既定の開始~時刻,
真偽値 %非同一-生成元~能力は隔離されるか )
に対し：
◎
To clamp and coarsen connection timing info, given a connection timing info timingInfo, a DOMHighResTimeStamp defaultStartTime, and a boolean crossOriginIsolatedCapability, run these steps:
</p>
<ol>
	<li>
~IF［
%計時~報 の`接続~開始~時刻$cT ~LT %既定の開始~時刻
］
⇒
~RET 新たな`接続~計時~報$
— その
⇒＃
`~domain検索~開始~時刻$cT ~SET %既定の開始~時刻,
`~domain検索~終了~時刻$cT ~SET %既定の開始~時刻,
`接続~開始~時刻$cT ~SET %既定の開始~時刻,
`接続~終了~時刻$cT ~SET %既定の開始~時刻,
`~secure接続~開始~時刻$cT ~SET %既定の開始~時刻,
`折衝した~ALPN~protocol~ID$cT ~SET %計時~報 の`折衝した~ALPN~protocol~ID$cT
◎
If timingInfo’s connection start time is less than defaultStartTime, then return a new connection timing info whose domain lookup start time is defaultStartTime, domain lookup end time is defaultStartTime, connection start time is defaultStartTime, connection end time is defaultStartTime, secure connection start time is defaultStartTime, and ALPN negotiated protocol is timingInfo’s ALPN negotiated protocol.
</li>
	<li>
~RET 新たな`接続~計時~報$
— その
⇒＃
`~domain検索~開始~時刻$cT ~SET `時刻を粗化する$( %計時~報 の`~domain検索~開始~時刻$cT, %非同一-生成元~能力は隔離されるか ),
`~domain検索~終了~時刻$cT ~SET `時刻を粗化する$( %計時~報 の`~domain検索~終了~時刻$cT, %非同一-生成元~能力は隔離されるか ),
`接続~開始~時刻$cT ~SET `時刻を粗化する$( %計時~報 の`接続~開始~時刻$cT, %非同一-生成元~能力は隔離されるか ),
`接続~終了~時刻$cT ~SET `時刻を粗化する$( %計時~報 の`接続~終了~時刻$cT, %非同一-生成元~能力は隔離されるか ),
`~secure接続~開始~時刻$cT ~SET `時刻を粗化する$( %計時~報 の`接続~終了~時刻$cT, %非同一-生成元~能力は隔離されるか ),
`折衝した~ALPN~protocol~ID$cT ~SET %計時~報 の`折衝した~ALPN~protocol~ID$cT
◎
Return a new connection timing info whose domain lookup start time is the result of coarsen time given timingInfo’s domain lookup start time and crossOriginIsolatedCapability, domain lookup end time is the result of coarsen time given timingInfo’s domain lookup end time and crossOriginIsolatedCapability, connection start time is the result of coarsen time given timingInfo’s connection start time and crossOriginIsolatedCapability, connection end time is the result of coarsen time given timingInfo’s connection end time and crossOriginIsolatedCapability, secure connection start time is the result of coarsen time given timingInfo’s connection end time and crossOriginIsolatedCapability, and ALPN negotiated protocol is timingInfo’s ALPN negotiated protocol.
</li>
</ol>
</div>

<hr>

<p>
`新たな接続~用の設定@
は、
次に挙げるいずれかをとる
⇒＃
`no^l,
`yes^l,
`yes-and-dedicated^l
◎
A new connection setting is "no", "yes", or "yes-and-dedicated".
</p>

<div class="algo">
<p>
`接続を得する@
~algoは、
所与の
⇒＃
`~network区分~key$ %~key,
`~URL$ %~URL,
真偽値 %資格証を伴うか,
`新たな接続~用の設定$ %新たな（省略時は `no^l ）,
真偽値 `不依拠-可能を要求するか@i （省略時は ~F ）
◎終
に対し：
◎
To obtain a connection, given a network partition key key, URL url, boolean credentials, an optional new connection setting new (default "no"), and an optional boolean requireUnreliable (default false), run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%新たな ~EQ `no^l
］：
◎
If new is "no", then:
</p>
		<ol>
			<li>
%接続~群 ~LET ~UAの`接続~pool$を成す`接続$のうち，次を満たすものたちが成す集合
⇒
( `~key$cN, `生成元$cN, `資格証を伴うか$cN ) ~EQ ( %~key, %~URL の`生成元$url, %資格証を伴うか )
◎
Let connections be a set of connections in the user agent’s connection pool whose key is key, origin is url’s origin, and credentials is credentials.
</li>
			<li>
<p>
~IF［
%接続~群 は空でない
］：
</p>
				<ol>
					<li>
~IF［
%不依拠-可能を要求するか ~EQ ~F
］
⇒
~RET %接続~群 の中の どれか一つ
</li>
					<li>
~IF［
%接続~群 を成す ある`接続$は、
`不依拠-可能$な~transportを~supportする能力がある
（例：~HTTP3）
］
⇒
~RET そのようないずれかの`接続$
</li>
				</ol>
◎
If connections is not empty and requireUnreliable is false, then return one of connections.
◎
If there is a connection capable of supporting unreliable transport in connections, e.g., HTTP/3, then return that connection.
</li>
		</ol>
	</li>
	<li>
<p>
%~proxy群 ~LET %~URL 用の~proxyたちを`実装定義$な方式で見出した結果
— 無い場合は « `DIRECT^l »
◎
Let proxies be the result of finding proxies for url in an implementation-defined manner. If there are no proxies, let proxies be « "DIRECT" ».
</p>

<p class="note">注記：
ここは、
標準でない技術
— `Web Proxy Auto-Discovery Protocol (WPAD)＠~WIKIPEDIA/Web_Proxy_Auto-Discovery_Protocol$en,
`proxy auto-config (PAC)＠~WIKIPEDIA/Proxy_auto-config$en
など —
が絡んでくる所である。
`DIRECT^l 値は、
この特定0の %~URL 用には~proxyを利用しないことを意味する。
◎
This is where non-standard technology such as Web Proxy Auto-Discovery Protocol (WPAD) and proxy auto-config (PAC) come into play. The "DIRECT" value means to not use a proxy for this particular url.
</p>
	</li>
	<li>
%計時~報 ~LET 新たな`接続~計時~報$
◎
Let timingInfo be a new connection timing info.
</li>
	<li>
<p>
%~proxy群 を成す
~EACH( %~proxy )
に対し：
◎
For each proxy of proxies:
</p>
		<ol>
			<li>
%計時~報 の`~domain検索~開始~時刻$cT ~SET `安全でない共有される現在の時刻$
◎
Set timingInfo’s domain lookup start time to the unsafe shared current time.
</li>
			<li>
%~host群 ~LET « %~URL の`生成元$urlの`~host$o »
◎
Let hosts be « url’s origin’s host ».
</li>
			<li>
~IF［
%~proxy ~EQ `DIRECT^l
］
⇒
%~host群 ~SET `生成元を解決する$( %~key, %~URL の`生成元$url ) 
◎
If proxy is "DIRECT", then set hosts to the result of running resolve an origin given key and url’s origin.
</li>
			<li>
~IF［
%~host群 ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If hosts is failure, then continue.
</li>
			<li>
%計時~報 の`~domain検索~終了~時刻$cT ~SET `安全でない共有される現在の時刻$
◎
Set timingInfo’s domain lookup end time to the unsafe shared current time.
</li>
			<li>
<p>
%接続 ~LET 次に従って得られる`接続$：
◎
Let connection be the result of running this step:＼
</p>
				<ul>
					<li class="algo">
次を
— `実装定義$な回数だけ，互いに`並列的$に —
走らす
⇒
`接続を作成する$( ↓ )
⇒＃
%~key,
%~URL の`生成元$url,
%資格証,
%~proxy,
%~host群 の中から`実装定義$に選ばれた`~host$,
%計時~報,
%不依拠-可能を要求するか
◎
run create a connection given key, url’s origin, credentials, proxy, an implementation-defined host from hosts, timingInfo, and requireUnreliable an implementation-defined number of times, in parallel from each other,＼
</li>
					<li>
前項にて走らせた 少なくとも一つが値を返すまで待機した上で、
返された値たちから，`実装定義$な方式で一つを選定する
— 他の値のうち`接続$である（ `失敗^i でない）ものは、
~closeしてもヨイ。
◎
and wait for at least 1 to return a value.＼
In an implementation-defined manner, select a value to return from the returned values and return it.＼
Any other returned values that are connections may be closed.
</li>
				</ul>

<p class="note">注記：
この段は、
本質的には，［
`生成元を解決-$した結果から，
1 個以上の`~IP~address$を選び取ること
］を実装に許容する
（ %~proxy ~EQ `DIRECT^l と見做すなら）
— ［
それらを互いに競争させる,
`~IPv6~address$を選り好む,
時間切れの事例では試行し直す,
等々
］の下で。
◎
Essentially this allows an implementation to pick one or more IP addresses from the return value of resolve an origin (assuming proxy is "DIRECT") and race them against each other, favor IPv6 addresses, retry in case of a timeout, etc.
</p>
			</li>
			<li>
~IF［
%接続 ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If connection is failure, then continue.
</li>
			<li>
~IF［
%新たな ~NEQ `yes-and-dedicated^l
］
⇒
~UAの`接続~pool$に %接続 を`付加する$set
◎
If new is not "yes-and-dedicated", then append connection to the user agent’s connection pool.
</li>
			<li>
~RET %接続
◎
Return connection.
</li>
		</ol>
	</li>
	<li>
~RET `失敗^i
◎
Return failure.
</li>
</ol>

<p class="note">注記：
これは，意図的にやや曖昧にされている
— 接続~管理に関して，たくさんの意味合いがあり、
実装者の裁量に委ねるのが最善なので。
これを述べることは、
`link rel=preconnect^e による特能を説明する助けになることに加え，
`接続$は `資格証を伴うか$cN 別に分けられることを明瞭に~~規定する。
後者は、
例えば，~TLS~session識別子が［
`資格証を伴うか$cNが互いに異なる`接続$たち
］にまたがって再利用されないことを明確化する。
◎
This is intentionally a little vague as there are a lot of nuances to connection management that are best left to the discretion of implementers. Describing this helps explain the &lt;link rel=preconnect&gt; feature and clearly stipulates that connections are keyed on credentials. The latter clarifies that, e.g., TLS session identifiers are not reused across connections whose credentials are false with connections whose credentials are true.
</p>
【！ See https://github.com/whatwg/fetch/issues/114#issuecomment-143500095 for when we make WebSocket saner 】
</div>

<hr>

<div class="algo">
<p>
`接続を作成する@
~algoは、
所与の
⇒＃
`~network区分~key$ %~key,
`生成元$ %生成元,
真偽値 %資格証,
文字列 %~proxy,
`~host$ %~host,
`接続~計時~報$ %計時~報,
真偽値 %不依拠-可能を要求するか,
◎終
に対し：
◎
To create a connection, given a network partition key key, origin origin, boolean credentials, string proxy, host host, connection timing info timingInfo, and boolean requireUnreliable, run these steps:
</p>
<ol>
	<li>
%計時~報 の`接続~開始~時刻$cT ~SET `安全でない共有される現在の時刻$
◎
Set timingInfo’s connection start time to the unsafe shared current time.
</li>
	<li>
%接続 ~LET 新たな`接続$
— その
⇒＃
`~key$cN ~SET %~key,
`生成元$cN ~SET %生成元,
`資格証を伴うか$cN ~SET %資格証,
`計時~報$ ~SET %計時~報
◎
Let connection be a new connection whose key is key, origin is origin, credentials is credentials, and timing info is timingInfo.＼
</li>
	<li>
<p>
次に挙げる各~条項に従う下で、
%接続 を利用して,
［
%~proxy, %生成元
］も織り込んで,
%~host への~HTTP接続を確立する
`HTTP$r
`HTTP1$r
`TLS$r
— それに伴い、
%接続 に対し`接続~計時~報を記録する$：
◎
Record connection timing info given connection and use connection to establish an HTTP connection to host, taking proxy and origin into account, with the following caveats: [HTTP] [HTTP1] [TLS]
</p>
		<ul>
			<li>
<p>
［
%不依拠-可能を要求するか ~EQ ~T
］の場合、
`不依拠-可能$な~transport能力がある接続（例：~HTTP3 `HTTP3$r ）を確立する
— そうするときは、
~WebTransport用に必要yな~optionを可能化する
◎
If requireUnreliable is true, then establish a connection capable of unreliable transport, e.g., an HTTP/3 connection. [HTTP3]
◎
When establishing a connection capable of unreliable transport, enable options that are necessary for WebTransport.＼
</p>

<div>
<p>
~HTTP3用には、
このことは，初期 `SETTINGS＠~HTTPv3#frame-settings$ft ~frame内に次を内包することを意味する：
</p>
				<ul>
					<li>
1 を値に伴う `SETTINGS_ENABLE_WEBTRANSPORT^sp
`WEBTRANSPORT-HTTP3$r
【 `SETTINGS_WEBTRANSPORT_MAX_SESSIONS＠~WT-HTTP3#SETTINGS_WEBTRANSPORT_MAX_SESSIONS$sp に`置換された＠https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-http3/commit/36d915d36e5abf568f4a6cf6e92c8fa8151602a5$。】
</li>
					<li>
1 を値に伴う `SETTINGS_H3_DATAGRAM＠~HTTPdatagram#setting$sp【！H3_DATAGRAM】
`HTTP3-DATAGRAM$r
</li>
				</ul>
◎
For HTTP/3, this means including SETTINGS_ENABLE_WEBTRANSPORT with a value of 1 and H3_DATAGRAM with a value of 1 in the initial SETTINGS frame. [WEBTRANSPORT-HTTP3] [HTTP3-DATAGRAM]
</div>
			</li>
			<li>
［
%資格証を伴うか ~EQ ~F
］の場合、
~TLS~client証明書は送信しない
◎
If credentials is false, then do not send a TLS client certificate.
</li>
		</ul>
	</li>
	<li>
~IF［
前~段にて接続を確立するのに失敗した
（例：［
~UDP／~TCP／~TLS
］の~error）
］
⇒
~RET `失敗^i
◎
If establishing a connection does not succeed (e.g., a UDP, TCP, or TLS error), then return failure.
</li>
	<li>
<p>
%計時~報 の`折衝した~ALPN~protocol~ID$cT ~SET
次に挙げる各~条項に従う下で得られた
%接続 の~ALPN~protocol~ID `RFC7301$r：
◎
Set timingInfo’s ALPN negotiated protocol to connection’s ALPN Protocol ID, with the following caveats: [RFC7301]
</p>
		<ul>
			<li>
~proxyが環境設定されているときは
⇒＃
~tunnel接続が確立された場合、~tunnelされた~protocolの~ALPN~protocol~IDになるモノトスル／
他の場合、~proxyへの最初の~hopの~ALPN~protocol~IDになるモノトスル
◎
When a proxy is configured, if a tunnel connection is established then this must be the ALPN Protocol ID of the tunneled protocol, otherwise it must be the ALPN Protocol ID of the first hop to the proxy.
</li>
			<li>
<p>
~UAが試験的な未登録な~protocolを利用している事例では、
~protocol折衝~用に~ALPN~protocol~IDが
⇒＃
利用されたならば、それを利用するモノトスル／
利用されなかったならば、別の記述的な文字列を利用してもヨイ
◎
In case the user agent is using an experimental, non-registered protocol, the user agent must use the used ALPN Protocol ID, if any. If ALPN was not used for protocol negotiations, the user agent may use another descriptive string.
</p>

<p class="note">注記：
%計時~報 の`折衝した~ALPN~protocol~ID$cTは、
利用-中にある~network~protocolを識別するために意図される
— それが実際にどう折衝されたかに関わらず。
すなわち，~ALPNが当の~network~protocolを折衝するために利用されていない場合でも、
これは，利用-中にある~protocolを指示する~ALPN~protocol~IDになる。
◎
timingInfo’s ALPN negotiated protocol is intended to identify the network protocol in use regardless of how it was actually negotiated; that is, even if ALPN is not used to negotiate the network protocol, this is the ALPN Protocol IDs that indicates the protocol in use.
</p>
	</li>
</ul>

<p class="note">注記：
~IANAは、
`~ALPN~protocol~IDたちが成す~list＠~IANA-a/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids$を保守する。
◎
IANA maintains a list of ALPN Protocol IDs.
</p>
	</li>
	<li>
~RET %接続
◎
Return connection.
</li>
</ol>
</div>

<hr>

<p>
所与の
( `接続$ %接続 )
に対し，
`接続~計時~報を記録する@
ときは、
%接続 の`計時~報$ %計時~報 について以下に挙げる要件を観測する：
◎
To record connection timing info given a connection connection, let timingInfo be connection’s timing info and observe these requirements:
</p>
<ul>
	<li>
<p>
%計時~報 の`接続~終了~時刻$cTは、［
~server／~proxy
］への接続を確立した直後における`安全でない共有される現在の時刻$になるベキである
— 次に従う下で：
◎
timingInfo’s connection end time should be the unsafe shared current time immediately after establishing the connection to the server or proxy, as follows:
</p>
		<ul>
			<li>
返される時刻は、
次にかかった時間も含めるモノトスル
⇒＃
~transport接続を確立するための時間／
~SOCKS認証などの他のものにかかった時間／
資源を要請するための~TLS~handshakeを十分に完了するための時間
◎
The returned time must include the time interval to establish the transport connection, as well as other time intervals such as SOCKS authentication. It must include the time interval to complete enough of the TLS handshake to request the resource.
</li>
			<li>
~UAが この接続~用に~TLS `False Start^i を利用している場合、
~serverの `Finished^i ~messageを受信するまでかかる時間は含めないモノトスル。
`RFC7918$r
◎
If the user agent used TLS False Start for this connection, this interval must not include the time needed to receive the server’s Finished message. [RFC7918]
</li>
			<li>
~UAが~handshakeを全部的に完了するまで待機することなく，
`early data^i を伴う要請を送信する場合、
~serverの `ServerHello^i ~messageを受信するまでかかる時間は含めないモノトスル。
`RFC8470$r
◎
If the user agent sends the request with early data without waiting for the full handshake to complete, this interval must not include the time needed to receive the server’s ServerHello message. [RFC8470]
</li>
			<li>
~UAが~handshakeを全部的に完了するまで待機してから当の要請を送信する場合、
全部的な~TLS~handshakeにかかった時間を含めるとする
— 他の要請が %接続 上で `early data^i を利用して送信されたとしても。
◎
If the user agent waits for full handshake completion to send the request, this interval includes the full TLS handshake even if other requests were sent using early data on connection.
</li>
		</ul>

<p class="example">
~UAは、
~TLS 1.3 越しに ~HTTP2接続を確立して，
`GET$hm 要請と `POST$hm 要請を送信するとする。
~UAは、
時刻 %t1 に `ClientHello^i を送信してから，
`early data^i を伴う `GET^hm 要請を送信する一方で、
`POST^hm 要請は`安全$でないので（ `HTTP$r ），
それを送信する前に~handshakeが完了する時刻 %t2 まで待機したとする。
どちらの要請にも同じ接続が利用されるが、［
`GET^hm 要請は %t1 ／
`POST^hm 要請は %t2
］を接続~終了~時刻として報告する。
◎
Suppose the user agent establishes an HTTP/2 connection over TLS 1.3 to send a GET request and a POST request. It sends the ClientHello at time t1 and then sends the GET request with early data. The POST request is not safe ([HTTP], section 9.2.1), so the user agent waits to complete the handshake at time t2 before sending it. Although both requests used the same connection, the GET request reports a connection end time of t1, while the POST request reports t2.
</p>

	</li>
	<li>
~secureな~transportが利用されている場合、
%計時~報 の`~secure接続~開始~時刻$cTは，
%接続 を~secure化するための~handshake処理nを開始する直前における`安全でない共有される現在の時刻$になるベキである。
`TLS$r
◎
If a secure transport is used, timingInfo’s secure connection start time should be the result of calling unsafe shared current time immediately before starting the handshake process to secure connection. [TLS]
</li>
	<li>
%接続 は~HTTP3接続である場合、
%計時~報 の［
`接続~開始~時刻$cT, `~secure接続~開始~時刻$cT
］は，等しくならなければならない
（~HTTP3における~secure~transport~handshake処理nは、
初期~時に接続を設定しておく一部として遂行される。）
`HTTP3$r
◎
If connection is an HTTP/3 connection, timingInfo’s connection start time and timingInfo’s secure connection start time must be equal. (In HTTP/3 the secure transport handshake process is performed as part of the initial connection setup.) [HTTP3]
</li>
</ul>

<p class="note">注記：
`接続~計時~報を切詰めて粗化する$~algoは、
次を確保する
⇒＃
再利用される接続の詳細は公開されないこと／
時刻~値は粗化されること
◎
The clamp and coarsen connection timing info algorithm ensures that details of reused connections are not exposed and time values are coarsened.
</p>

		</section>
		<section id="network-partition-keys">
<h3 title="Network partition keys">2.7. ~network区分~key</h3>

<p>
`~network区分~key@
は、
次の 2 つからなる~tupleである
⇒
( `~site$, ~NULL または`実装定義$な値 )
◎
A network partition key is a tuple consisting of a site and null or an implementation-defined value.
</p>

<div class="algo">
<p>
`~network区分~keyを決定する@
~algoは、
所与の
( `環境$ %環境 )
に対し：
◎
To determine the network partition key, given an environment environment:
</p>
<ol>
	<li>
%~top-level生成元 ~LET %環境 の`~top-level生成元$enV
◎
Let topLevelOrigin be environment’s top-level origin.
</li>
	<li>
~IF［
%~top-level生成元 ~EQ ~NULL
］
⇒
%~top-level生成元 ~SET %環境 の`~top-level作成時の~URL$enVの`生成元$url
◎
If topLevelOrigin is null, then set topLevelOrigin to environment’s top-level creation URL’s origin.
</li>
	<li>
~Assert：
%~top-level生成元 は`生成元$である
◎
Assert: topLevelOrigin is an origin.
</li>
	<li>
%~top-level~site ~LET `~siteを得する$( %~top-level生成元 )
◎
Let topLevelSite be the result of obtaining a site, given topLevelOrigin.
</li>
	<li>
<p>
%第二~key ~LET ~NULL または`実装定義$な値
◎
Let secondKey be null or an implementation-defined value.
</p>

<p class="XXX">
第二~keyは、
意図的に少し曖昧にされている
— より精緻な点で、
依然として発展しているので。
`課題 #1035＠https://github.com/whatwg/fetch/issues/1035$
を見よ。
◎
The second key is intentionally a little vague as the finer points are still evolving. See issue #1035.
</p>
	</li>
	<li>
~RET ( %~top-level~site, %第二~key )
◎
Return (topLevelSite, secondKey).
</li>
</ol>
</div>

<div class="algo">
<p>
`要請の~network区分~keyを決定する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To determine the network partition key, given a request request:
</p>
<ol>
	<li>
~IF［
%要請 の`予約-済み~client$rq ~NEQ ~NULL
］
⇒
~RET `~network区分~keyを決定する$( %要請 の`予約-済み~client$rq )
◎
If request’s reserved client is non-null, then return the result of determining the network partition key given request’s reserved client.
</li>
	<li>
~IF［
%要請 の`~client$rq ~NEQ ~NULL
］
⇒
~RET `~network区分~keyを決定する$( %要請 の`~client$rq )
◎
If request’s client is non-null, then return the result of determining the network partition key given request’s client.
</li>
	<li>
~RET ~NULL 
◎
Return null.
</li>
</ol>
</div>

		</section>
		<section id="http-cache-partitions">
<h3 title="HTTP cache partitions">2.8. ~HTTP~cache区分</h3>

<div class="algo">
<p>
`~HTTP~cache区分を決定する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To determine the HTTP cache partition, given a request request:
</p>
<ol>
	<li>
%~key ~LET `要請の~network区分~keyを決定する$( %要請 )
◎
Let key be the result of determining the network partition key given request.
</li>
	<li>
~IF［
%~key ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If key is null, then return null.
</li>
	<li>
~RET %~key に結付けられた一意な~HTTP~cache
`HTTP-CACHING$r
◎
Return the unique HTTP cache associated with key. [HTTP-CACHING]
</li>
</ol>
</div>

		</section>
		<section id="port-blocking">
<h3 title="Port blocking">2.9. ~portの阻止-法</h3>

<p class="note">注記：
新たな~protocolは、［
~ALPNを利用している~TLS
］を通して折衝することにより，~portを阻止する必要を避けれる。
その事例では、
~protocolは，`~HTTP要請$を通して偽装し得なくなる。
`RFC7301$r
◎
New protocols can avoid the need for blocking ports by negotiating the protocol through TLS using ALPN. The protocol cannot be spoofed through HTTP requests in that case. [RFC7301]
</p>

<div class="algo">
<p>
`要請の~fetchingは，不良~portに因り阻止されるべきか？@
どうか決定するときは、
所与の
( `要請$ %要請 )
に対し：
◎
To determine whether fetching a request request should be blocked due to a bad port:
</p>
<ol>
	<li>
%~URL ~LET %要請 の`現在の~URL$rq
◎
Let url be request’s current URL.
</li>
	<li>
~IF［
%~URL の`~scheme$urlは`~HTTP_S~scheme$である
］~AND［
%~URL の`~port$urlは`不良~port$である
］
⇒
~RET `阻止される^i
◎
If url’s scheme is an HTTP(S) scheme and url’s port is a bad port, then return blocked.
</li>
	<li>
~RET `許容される^i
◎
Return allowed.
</li>
</ol>
</div>

<p>
次の表tの一列目に挙げられる`~port$urlは、
`不良~port@
であるとされる：
◎
A port is a bad port if it is listed in the first column of the following table.
</p>

<div style="column-width:12em; column-gap:1em;">
<table><thead>
<tr><th>~port
<th>代表的な~service
<tbody>

<tr><td>1<td>tcpmux
<tr><td>7<td>echo
<tr><td>9<td>discard
<tr><td>11<td>systat
<tr><td>13<td>daytime
<tr><td>15<td>netstat
<tr><td>17<td>qotd
<tr><td>19<td>chargen
<tr><td>20<td>ftp-data
<tr><td>21<td>ftp
<tr><td>22<td>ssh
<tr><td>23<td>telnet
<tr><td>25<td>smtp
<tr><td>37<td>time
<tr><td>42<td>name
<tr><td>43<td>nicname
<tr><td>53<td>domain
<tr><td>69<td>tftp
<tr><td>77<td>—
<tr><td>79<td>finger
<tr><td>87<td>—
<tr><td>95<td>supdup
<tr><td>101<td>hostname
<tr><td>102<td>iso-tsap
<tr><td>103<td>gppitnp
<tr><td>104<td>acr-nema
<tr><td>109<td>pop2
<tr><td>110<td>pop3
<tr><td>111<td>sunrpc
<tr><td>113<td>auth
<tr><td>115<td>sftp
<tr><td>117<td>uucp-path
<tr><td>119<td>nntp
<tr><td>123<td>ntp
<tr><td>135<td>epmap
<tr><td>137<td>netbios-ns
<tr><td>139<td>netbios-ssn
<tr><td>143<td>imap
<tr><td>161<td>snmp
<tr><td>179<td>bgp
<tr><td>389<td>ldap
<tr><td>427<td>svrloc
<tr><td>465<td>submissions
<tr><td>512<td>exec
<tr><td>513<td>login
<tr><td>514<td>shell
<tr><td>515<td>printer
<tr><td>526<td>tempo
<tr><td>530<td>courier
<tr><td>531<td>chat
<tr><td>532<td>netnews
<tr><td>540<td>uucp
<tr><td>548<td>afp
<tr><td>554<td>rtsp
<tr><td>556<td>remotefs
<tr><td>563<td>nntps
<tr><td>587<td>submission
<tr><td>601<td>syslog-conn
<tr><td>636<td>ldaps
<tr><td>989<td>ftps-data
<tr><td>990<td>ftps
<tr><td>993<td>imaps
<tr><td>995<td>pop3s
<tr><td>1719<td>h323gatestat
<tr><td>1720<td>h323hostcall
<tr><td>1723<td>pptp
<tr><td>2049<td>nfs
<tr><td>3659<td>apple-sasl
<tr><td>4045<td>npp
<tr><td>4190<td>sieve
<tr><td>5060<td>sip
<tr><td>5061<td>sips
<tr><td>6000<td>x11
<tr><td>6566<td>sane-port
<tr><td>6665<td>ircu
<tr><td>6666<td>ircu
<tr><td>6667<td>ircu
<tr><td>6668<td>ircu
<tr><td>6669<td>ircu
<tr><td>6679<td>osaut
<tr><td>6697<td>ircs-u
<tr><td>10080<td>amanda
</table>
</div>

		</section>
		<section id="should-response-to-request-be-blocked-due-to-mime-type?">
<h3 title="Should response to request be blocked due to its MIME type?">2.10. 要請に対する応答は，~MIME型に因り阻止されるべきか？</h3>

<div class="algo">
<p>
この~algoは、
所与の
( `要請$ %要請, `応答$ %応答 )
に対し：
◎
Run these steps:
</p>
<ol>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
<p>
~RET［
~AND↓ が満たされるならば `阻止される^i ／
~ELSE_ `許容される^i
］：
</p>
		<ul>
			<li>
%要請 の`行先$rqは`~scriptに類する$
</li>
			<li>
%~MIME型 ~NEQ `失敗^i
</li>
			<li>
%~MIME型 の`~essence$ %~essence は、
次を満たす
⇒
［
%~essence は［
`audio/^l, `image/^l, `video/^l
］いずれか`から開始して$いる
］~OR［
%~essence ~EQ `text/csv^l
］
</li>
		</ul>
◎
If mimeType is failure, then return allowed.
◎
Let destination be request’s destination.
◎
If destination is script-like and one of the following is true, then return blocked:
• mimeType’s essence starts with "audio/", "image/", or "video/".
• mimeType’s essence is "text/csv".
◎
Return allowed.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="http-extensions">
<h2 title="HTTP extensions">3. ~HTTP拡張</h2>

		<section id="origin-header">
<h3 title="Origin header">3.1. `Origin^h ~header</h3>

<p>
`Origin@h
要請`~header$は、
`~fetch$ が出自にしている生成元を指示する。
◎
The `Origin` request header indicates where a fetch originates from.
</p>

<p class="note">注記：
`Origin$h ~headerは、
`Referer$h ~headerの`~path$url情報を露呈しない~versionである
<small>（この~header名は、本来の英語の綴り “Referrer” と異なることに注意）</small>。
この~headerは、
`~HTTP~fetch$のうち，［［
`要請$の`応答~tainting$rq ~EQ `cors^l
］の下で行われるもの ／
`要請$の`~method$rqに［
`GET$hm, `HEAD$hm
］以外を利用するもの
］すべてに利用される。
互換性の拘束に因り、
すべての`~fetch$に内包されることはない。
◎
The `Origin` header is a version of the `Referer` [sic] header that does not reveal a path. It is used for all HTTP fetches whose request’s response tainting is "cors", as well as those where request’s method is neither `GET` nor `HEAD`. Due to compatibility constraints it is not included in all fetches.
</p>

<p>
`Origin$h ~headerにアリな`値$hdは、
次の返り値~すべてからなる
⇒
`要請の生成元を~byte直列化する$( 任意の`要請$ )
◎
Its possible values are all the return values of byte-serializing a request origin, given a request.
</p>

<p class="note">注記：
これは、
`ORIGIN$r による定義【`参照＠~RFC6454#section-7.1$】を置き換える。
【具体的には、複数個の生成元は内包できなくされている。】
◎
This supplants the definition in The Web Origin Concept. [ORIGIN]
</p>

<hr>

<div class="algo">
<p>
`要請~Origin~headerを付加する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To append a request `Origin` header, given a request request, run these steps:
</p>
<ol>
	<li>
~Assert：
%要請 の`生成元$rq ~NEQ `client^l
◎
Assert: request’s origin is not "client".
</li>
	<li>
%直列化した生成元 ~LET `要請の生成元を~byte直列化する$( %要請 )
◎
Let serializedOrigin be the result of byte-serializing a request origin with request.
</li>
	<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］~OR［
%要請 の`~mode$rq ~EQ `websocket^l
］：
</p>
		<ol>
			<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Origin^h, %直列化した生成元 )
)
</li>
			<li>
~RET
</li>
		</ol>
◎
If request’s response tainting is "cors" or request’s mode is "websocket", then append (`Origin`, serializedOrigin) to request’s header list.
</li>
	<li>
~IF［
%要請 の`~method$rq ~IN { `GET$hm, `HEAD$hm }
］
⇒
~RET
◎
Otherwise, if request’s method is neither `GET` nor `HEAD`, then:
</li>
	<li>
<p>
~IF［
%要請 の`~mode$rq ~NEQ `cors^l
］：
◎
If request’s mode is not "cors",＼
</p>
		<ol>
			<li>
<p>
%要請 の`~referrer施策$rqに応じて：
◎
then switch on request’s referrer policy:
</p>
				<dl class="switch">
					<dt>`no-referrer^l</dt>
					<dd>
%直列化した生成元 ~SET `null^bl
◎
Set serializedOrigin to `null`.
</dd>

					<dt>`no-referrer-when-downgrade^l</dt>
					<dt>`strict-origin^l</dt>
					<dt>`strict-origin-when-cross-origin^l</dt>
					<dd>
~IF［
%要請 の`生成元$rqは`成分組~生成元$である
］~AND［
%要請 の`生成元$rqの`~scheme$o【！ its %~scheme】
~EQ `https^l
］~AND［
%要請 の`現在の~URL$rqの`~scheme$url【！%~scheme】 ~NEQ `https^l
］
⇒
%直列化した生成元 ~SET `null^bl
◎
If request’s origin is a tuple origin, its scheme is "https", and request’s current URL’s scheme is not "https", then set serializedOrigin to `null`.
</dd>

					<dt>`same-origin^l</dt>
					<dd>
~IF［
%要請 の`生成元$rq
~NEQ`生成元$sub
%要請 の`現在の~URL$rqの`生成元$url
］
⇒
%直列化した生成元 ~SET `null^bl
◎
If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.
</dd>

					<dt>
その他
◎
Otherwise
</dt>
					<dd>
何もしない
◎
Do nothing.
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Origin^h, %直列化した生成元 )
)
◎
Append (`Origin`, serializedOrigin) to request’s header list.
</li>
</ol>

<p class="note">注記：
`要請$の`~referrer施策$rqは、
すべての~fetchに織り込まれる
— ~fetch側が明示的に自身の`生成元$を~serverと共有するよう
（例えば`~CORS~protocol$の利用を介して）~opt-inしていなくとも。
◎
A request’s referrer policy is taken into account for all fetches where the fetcher did not explicitly opt into sharing their origin with the server, e.g., via using the CORS protocol.
</p>
</div>

		</section>
		<section id="http-cors-protocol">
<h3 title="CORS protocol">3.2. ~CORS~protocol</h3>

<p>
`~CORS~protocol@
は、［
応答を非同一-生成元と共有すること
］および［
~HTMLの `form$e 要素でアリなものより多用途な`~fetch$
］を許容するためにある。
それは、
~HTTPの上層にあり，［
自身が他の`生成元$と共有し得るものである
］ものと宣言することを応答に許容する。
◎
To allow sharing responses cross-origin and allow for more versatile fetches than possible with HTML’s form element, the CORS protocol exists. It is layered on top of HTTP and allows responses to declare they can be shared with other origins.
</p>

<p class="note">注記：
これには、
~firewallの背後（~intranet）で応答から~dataが漏洩することを防止するため，~opt-inの仕組みが必要になる。
加えて，`資格証$を含む`要請$にも、
敏感になり得る~dataが漏洩することを防止するため，~opt-inが必要になる。
◎
It needs to be an opt-in mechanism to prevent leaking data from responses behind a firewall (intranets). Additionally, for requests including credentials it needs to be opt-in to prevent leaking potentially-sensitive data.
</p>

<p>
この節では、
`~CORS~protocol$のうち，~server開発者に関わる部分を説明する。
~UAに課される要件は、
`［ その新たな~HTTP~header ］の構文＠#http-new-header-syntax$を除き，
`~fetch$~algoの一部として与えられる。
◎
This section explains the CORS protocol as it pertains to server developers. Requirements for user agents are part of the fetch algorithm, except for the new HTTP header syntax.
</p>

<p class="trans-note">【
したがって、
この節に現れる “できる” は，一般に~serverが動作主であることを表す。
】</p>

			<section id="general">
<h4 title="General">3.2.1. 一般論</h4>

<p>
`~CORS~protocol$は、［
応答が非同一-生成元の下でも共有し得るものになるかどうか
］を指示する，一群の~headerからなる。
◎
The CORS protocol consists of a set of headers that indicates whether a response can be shared cross-origin.
</p>

<p>
`要請$が~HTMLの `form$e 要素ではアリでないものを孕む場合、［
`要請$の`現在の~URL$rqが`~CORS~protocol$を~supportする
］ことを確保する必要があるので，`~CORS予行~要請$が遂行される。
◎
For requests that are more involved than what is possible with HTML’s form element, a CORS-preflight request is performed, to ensure request’s current URL supports the CORS protocol.
</p>

			</section>
			<section id="http-requests">
<h4 title="HTTP requests">3.2.2. ~HTTP要請</h4>

<p>
`~CORS要請@
とは、
`Origin$h ~headerを内包している`~HTTP要請$である。
が、［
そのような要請が`~CORS~protocol$に関与している
］とは，依拠-可能に識別できない
— この~headerは、［
`GET$hm, `HEAD$hm
］以外の`~method$rqを伴う どの`要請$にも内包されるので。
◎
A CORS request is an HTTP request that includes an `Origin` header. It cannot be reliably identified as participating in the CORS protocol as the `Origin` header is also included for all requests whose method is neither `GET` nor `HEAD`.
</p>

<p>
`~CORS予行~要請@
とは、
`~CORS~protocol$が解されるか否か検査するための`~CORS要請$である。
それは、
`~method$に `OPTIONS$hm を利用する。
◎
A CORS-preflight request is a CORS request that checks to see if the CORS protocol is understood. It uses `OPTIONS` as method＼
</p>

<p>
`~CORS予行~要請$は、
次に挙げる`~header$を内包する：
◎
and includes the following header:
</p>
<dl class="def-list">
	<dt>`Access-Control-Request-Method@h</dt>
	<dd>
同じ資源に対する今後の`~CORS要請$に利用され得る
【要請~側が希望する】
`~method$を指示する。
◎
Indicates which method a future CORS request to the same resource might use.
</dd>
</dl>

<p>
`~CORS予行~要請$は、
次に挙げる`~header$も内包し得る：
◎
A CORS-preflight request can also include the following header:
</p>
<dl>
	<dt>`Access-Control-Request-Headers@h</dt>
	<dd>
同じ資源に対する今後の`~CORS要請$に利用され得る
【要請~側が希望する】
`~header$を指示する。
◎
Indicates which headers a future CORS request to the same resource might use.
</dd>
</dl>

			</section>
			<section id="http-responses">
<h4 title="HTTP responses">3.2.3. ~HTTP応答</h4>

<p>
`~CORS要請$に対する`~HTTP応答$には、
次に挙げる`~header$を内包できる：
◎
An HTTP response to a CORS request can include the following headers:
</p>

<dl class="def-list">
	<dt>`Access-Control-Allow-Origin@h</dt>
	<dd>
応答~内に次のうちどれを返すかを介して，応答が共有し得るものになるかどうかを指示する
⇒＃
`Origin$h 要請`~header$の~literal`値$hd（ `null^bl もとり得る）,
`*^bl
◎
Indicates whether the response can be shared, via returning the literal value of the `Origin` request header (which can be `null`) or `*` in a response.
</dd>

	<dt>`Access-Control-Allow-Credentials@h</dt>
	<dd>
［
`要請$の`資格証~mode$rq ~EQ `include^l
］のときに，応答が共有し得るものになるかどうかを指示する。
◎
Indicates whether the response can be shared when request’s credentials mode is "include".
</dd>
	<dd class="note">注記：
`要請$の`資格証~mode$rqは、
`~CORS予行~要請$の際には常に `same-origin^l になる
— すなわち，資格証を除外する —
が，後続な`~CORS要請$では そうでないこともある。
したがって、
`~CORS予行~要請$に対する~HTTP応答の中でも，
~supportの有無が指示される必要がある。
◎
For a CORS-preflight request, request’s credentials mode is always "same-origin", i.e., it excludes credentials, but for any subsequent CORS requests it might not be. Support therefore needs to be indicated as part of the HTTP response to the CORS-preflight request as well.
</dd>
</dl>

<p>
`~CORS予行~要請$に対する~HTTP応答には、
次に挙げる`~header$を内包できる：
◎
An HTTP response to a CORS-preflight request can include the following headers:
</p>

<dl class="def-list">
	<dt>`Access-Control-Allow-Methods@h</dt>
	<dd>
`~CORS~protocol$の目的において，`応答$の`~URL$rsが~supportする`~method$を指示する。
◎
Indicates which methods are supported by the response’s URL for the purposes of the CORS protocol.
</dd>
	<dd class="note">注記：
`Allow$h `~header$は`~CORS~protocol$の目的には関連しない。
◎
The `Allow` header is not relevant for the purposes of the CORS protocol.
</dd>

	<dt>`Access-Control-Allow-Headers@h</dt>
	<dd>
`~CORS~protocol$の目的において，`応答$の`~URL$rsが~supportする`~header$を指示する。
◎
Indicates which headers are supported by the response’s URL for the purposes of the CORS protocol.
</dd>

	<dt>`Access-Control-Max-Age@h</dt>
	<dd>
［
`Access-Control-Allow-Methods$h ／
`Access-Control-Allow-Headers$h
］`~header$から供される情報を~cacheし得る期間
【~UAが~cache内に保持してもよい最長な期間】
を秒数（既定は 5 ）で指示する。
◎
Indicates the number of seconds (5 by default) the information provided by the `Access-Control-Allow-Methods` and `Access-Control-Allow-Headers` headers can be cached.
</dd>
</dl>

<p>
`~CORS予行~要請$でない`~CORS要請$に対する~HTTP応答には、
次に挙げる`~header$を内包できる：
◎
An HTTP response to a CORS request that is not a CORS-preflight request can also include the following header:
</p>

<dl class="def-list">
	<dt>`Access-Control-Expose-Headers@h</dt>
	<dd>
応答の一部として公開できる
【~web~APIに公開することを許可する】
`~header$たちを，`名前$hdたちが成す~listにより指示する。
◎
Indicates which headers can be exposed as part of the response by listing their names.
</dd>
</dl>

<hr>

<p>
`~CORS要請$に対する成功裡な~HTTP応答は
— すなわち、
~server開発者が，それを共有させたいと意図する所では —
［
上に言明した`~header$のうち当の応答が内包するもの
］が［
当の要請に合致している`値$hd
］を伴う限り，どの`状態s$も利用できる。
◎
A successful HTTP response, i.e., one where the server developer intends to share it, to a CORS request can use any status, as long as it includes the headers stated above with values matching up with the request.
</p>

<p>
`~CORS予行~要請$に対する成功裡な~HTTP応答は、
`~ok状態s$（すなわち `200$st ／ `204$st ）に制約されることを除いて，
類似する。
◎
A successful HTTP response to a CORS-preflight request is similar, except it is restricted to an ok status, e.g., 200 or 204.
</p>

<p>
他の種類の~HTTP応答は、
成功裡でない
— 共有されなくなるか，`~CORS予行~要請$は失敗することになる。
いずれにせよ、
~serverが遂行する作業は，［
計時~攻撃などの~side-channelを通して漏洩され得る
］ことを自覚すること。
~server開発者は、
これを明示的に表すよう望むなら，
`403$st `状態s$を
— 関連な`~header$を省略した上で —
利用できる。
◎
Any other kind of HTTP response is not successful and will either end up not being shared or fail the CORS-preflight request. Be aware that any work the server performs might nonetheless leak through side channels, such as timing. If server developers wish to denote this explicitly, the 403 status can be used, coupled with omitting the relevant headers.
</p>

<p class="note">注記：
欲されるなら， “失敗” も共有させ得るが、
その場合の応答は，成功裡な~HTTP応答に仕立て上げられることになる。
`~CORS予行~要請$でない`~CORS要請$に対する成功裡な~HTTP応答の`状態s$が，
`403$st も含めて何でもありなわけは、
そのためである。
◎
If desired, “failure” could also be shared, but that would make it a successful HTTP response. That is why for a successful HTTP response to a CORS request that is not a CORS-preflight request the status can be anything, including 403.
</p>

<p>
最後に、
~server開発者には，~HTTP応答をどう取扱うかにおいて たくさんの自由度があり、
その方策は［
`~CORS予行~要請$に対する応答,
それに後続する`~CORS要請$に対する応答
］において相違し得る：
◎
Ultimately server developers have a lot of freedom in how they handle HTTP responses and these tactics can differ between the response to the CORS-preflight request and the CORS request that follows it:
</p>

<ul>
	<li>
開発者は、
静的な応答を供せる。
これは、
~cacheしている`媒介者$たちと伴に働くようにするとき，役立ち得る。
静的な応答は、
`~CORS要請$に依存して，成功裡になることもならないこともある。
これは `okay^en【漏洩の心配はない？】。
◎
They can provide a static response. This can be helpful when working with caching intermediaries. A static response can both be successful and not successful depending on the CORS request. This is okay.
</li>
	<li>
開発者は、
`~CORS要請$に~~調整された動的な応答を供せる。
これは、
次のときに役立ち得る
⇒＃
応答の本体を特定の生成元~用に誂えるとき／
応答には資格証が必要で，生成元たちが成すある集合に対し成功裡になるとき
◎
They can provide a dynamic response, tuned to CORS request. This can be helpful when the response body is to be tailored to a specific origin or a response needs to have credentials and be successful for a set of origins.
</li>
</ul>

			</section>
			<section id="http-new-header-syntax">
<h4 title="HTTP new-header syntax">3.2.4. ［ 新たな~HTTP~header ］の構文</h4>

<p>
`~CORS~protocol$に利用される`~header$の`値$hd用の`~ABNF$は：
◎
ABNF for the values of the headers used by the CORS protocol:
</p>

<pre class="bnf">
Access-Control-Request-Method
	= `method$p
Access-Control-Request-Headers
	= 1#`field-name$p

wildcard
	= "*"
Access-Control-Allow-Origin
	= origin-or-null / wildcard
Access-Control-Allow-Credentials
	= `%s^"true" ; <span class="comment">文字大小区別</span>
Access-Control-Expose-Headers
	= #`field-name$p
Access-Control-Max-Age
	= `delta-seconds$p
Access-Control-Allow-Methods
	= #`method$p
Access-Control-Allow-Headers
	= #`field-name$p
</pre>

<p class="note">注記：
［
`Access-Control-Expose-Headers^h ／
`Access-Control-Allow-Methods^h ／
`Access-Control-Allow-Headers^h
］応答`~header$用の`値$hd `*^blは、［
`資格証$を伴わない`要請$
］に対しては，~wildcardとみなされる。
そのような`要請$に対しては、
値 `*^bl をとる［
`~header名$／`~method$
］のみに合致させる仕方はない。
◎
For `Access-Control-Expose-Headers`, `Access-Control-Allow-Methods`, and `Access-Control-Allow-Headers` response headers, the value `*` counts as a wildcard for requests without credentials. For such requests there is no way to solely match a header name or method that is `*`.
</p>

			</section>
			<section id="cors-protocol-and-credentials">
<h4 title="CORS protocol and credentials">3.2.5. ~CORS~protocolと資格証</h4>

【！ non-normative】

<p>
［
`要請$の`資格証~mode$rq ~EQ `include^l
］のときには、
`~fetch$において`資格証$を含ませること以外にも，
`~CORS~protocol$の機能-法に影響iがある。
◎
When request’s credentials mode is "include" it has an impact on the functioning of the CORS protocol other than including credentials in the fetch.
</p>

<div class="example" id="example-xhr-credentials">
<p>
昔から、
`XMLHttpRequest$I を利用して，
`要請$の`資格証~mode$rqを `include^l に設定できていたが：
◎
In the old days, XMLHttpRequest could be used to set request’s credentials mode to "include":
</p>

<pre class="lang-js">
var %client = new XMLHttpRequest()
%client.open("GET", "./")
%client.withCredentials = true
/* … */
</pre>

<div class="p">
<p>
今では次で足りる：
</p>

<pre class="lang-js">
fetch("./", { credentials:"include" }).then(/* … */)
</pre>

◎
Nowadays, fetch("./", { credentials:"include" }).then(/* … */) suffices.
</div>
</div>

<p>
`要請$の`資格証~mode$rqが~serverから観測-可能になることは、
必要yでない。
`要請$に`資格証$が存在するときに限り、
そのことから観測できる。
そうであっても、
`~CORS予行~要請$が`資格証$を含むことは，決してないことに注意。
◎
A request’s credentials mode is not necessarily observable on the server; only when credentials exist for a request can it be observed by virtue of the credentials being included. Note that even so, a CORS-preflight request never includes credentials.
</p>

<p>
したがって~server開発者は、［
`資格証$で “染められた（ `tainted^en ）” 応答を，共有させれるかどうか
］を裁定する必要がある。
また、［
`~CORS予行~要請$を要している`要請$が，`資格証$を内包し得るかどうか
］も裁定する必要がある。
一般的に言えば，［
応答を共有させる ／
`資格証$を伴う要請を許容する
］ことは安全でなくする方へ~~働くので、
慎重に事を~~運んで，
`confused deputy problem＠~WIKIPEDIA/Confused_deputy_problem$en
（混乱した使節の~~問題）を避ける必要がある。
◎
The server developer therefore needs to decide whether or not responses "tainted" with credentials can be shared. And also needs to decide if requests necessitating a CORS-preflight request can include credentials. Generally speaking, both sharing responses and allowing requests with credentials is rather unsafe, and extreme care has to be taken to avoid the confused deputy problem.
</p>

<p>
`資格証$を伴う応答を共有させるためには、［
`Access-Control-Allow-Origin$h,
`Access-Control-Allow-Credentials$h
］`~header$が重要になる。
次の表tに、
`https://rabbit.invalid/^s
へ向けた要請~用の種々の［
合法である／合法でない
］組合nを~~説明する：
◎
To share responses with credentials, the `Access-Control-Allow-Origin` and `Access-Control-Allow-Credentials` headers are important. The following table serves to illustrate the various legal and illegal combinations for a request to https://rabbit.invalid/:
</p>

<table class="grid-table" id="_credentials-combinations">
<tbody><tr><th>
要請の`資格証~mode$rq
◎
Request’s credentials mode
<th>`Access-Control-Allow-Origin$h
<th>`Access-Control-Allow-Credentials$h
<th>共有されるか？
◎
Shared?
<th>注記
◎
Notes
<tr>
<td>`omit^l
<td>`*^bl
<td>なし
<td>✅
<td>—

<tr><td>`omit^l
<td>`*^bl
<td>`true^bl
<td>✅
<td>
資格証~mode ~NEQ `include^l の場合、
`Access-Control-Allow-Credentials$h は無視される。
◎
If credentials mode is not "include", then `Access-Control-Allow-Credentials` is ignored.

<tr><td>`omit^l
<td>`https://rabbit.invalid/^bl
<td>なし
<td>❌
<td>
`生成元を直列化-$した結果の末尾は、
~slashではない。
◎
A serialized origin has no trailing slash.

<tr><td>`omit^l
<td>`https://rabbit.invalid^bl
<td>なし
<td>✅
<td>—

<tr><td>`include^l
<td>`*^bl
<td>`true^bl
<td>❌
<td>
資格証~mode ~EQ `include^l の場合、
`Access-Control-Allow-Origin$h は `*^bl にできない。
◎
If credentials mode is "include", then `Access-Control-Allow-Origin` cannot be `*`.

<tr><td>`include^l
<td>`https://rabbit.invalid^bl
<td>`true^bl
<td>✅
<td>—

<tr><td>`include^l
<td>`https://rabbit.invalid^bl
<td>`True^bl
<td>❌
<td>
`true^bl は（~byte）文字大小区別。
◎
`true` is (byte) case-sensitive.
</table>

<p>
同様に、
応答~header［
`Access-Control-Expose-Headers$h ／
`Access-Control-Allow-Methods$h ／
`Access-Control-Allow-Headers$h
］の値として `*^bl を利用できるのは，［
`要請$の`資格証~mode$rq ~NEQ `include^l
］のときに限られる。
◎
Similarly, `Access-Control-Expose-Headers`, `Access-Control-Allow-Methods`, and `Access-Control-Allow-Headers` response headers can only use `*` as value when request’s credentials mode is not "include".
</p>

			</section>
			<section id="cors-protocol-examples">
<h4 title="Examples">3.2.6. 例</h4>

<div class="example" id="example-simple-cors">
<p>
`https://foo.invalid/^s にある~scriptは、
`https://bar.invalid/^s から何か~dataを~fetchするよう求めているとする
（`資格証$も応答~headerへの~accessも重要でないとする）：
◎
A script at https://foo.invalid/ wants to fetch some data from https://bar.invalid/. (Neither credentials nor response header access is important.)
</p>

<pre class="lang-js" id="unicorn">
var %url = "https://bar.invalid/api?key=\
730d67a37d7f3d802e96396d00280768773813fbe726d116944d814422fc1a45\
&amp;data=about:unicorn";
fetch(%url).then(%success, %failure)
</pre>

<p>
`foo.invalid^s の開発者からはまったく透過的になるが、
これには，`~CORS~protocol$が利用される
— ~UAは、
`~CORS~protocol$の一環として，
要請~内に `Origin$h ~headerを内包させることになる：
◎
This will use the CORS protocol, though this is entirely transparent to the developer from foo.invalid. As part of the CORS protocol, the user agent will include the `Origin` header in the request:
</p>

<pre class="lang-http">
Origin: https://foo.invalid
</pre>

<p>
~UAは、
`bar.invalid^s から応答を受信したとき，
`Access-Control-Allow-Origin$h 応答~headerを検証yすることになる。
その値が［
`https://foo.invalid^bl ／ `*^bl
］ならば，
%success ~callbackが呼出され、
他の値, あるいは~headerが無い場合には，
%failure ~callbackが呼出されることになる。
◎
Upon receiving a response from bar.invalid, the user agent will verify the `Access-Control-Allow-Origin` response header. If its value is either `https://foo.invalid` or `*`, the user agent will invoke the success callback. If it has any other value, or is missing, the user agent will invoke the failure callback.
</p>
</div>

<div class="example" id="example-cors-with-response-header">
<p>
`foo.invalid^s の開発者が，今度は、
応答~headerにも~accessしつつ，
`bar.invalid^s から何か~dataを~fetchするよう求めたとする：
◎
The developer of foo.invalid is back, and now wants to fetch some data from bar.invalid while also accessing a response header.
</p>

<pre class="lang-js">
fetch(%url).then(%response =&gt; {
  var %hsts = %response.headers.get("strict-transport-security"),
      %csp = %response.headers.get("content-security-policy")
  log(%hsts, %csp)
})
</pre>

<p>
`bar.invalid^s は、
先の例と同じく，
正しい `Access-Control-Allow-Origin$h 応答~headerを供したとする。
%hsts, %csp
どちらも、
その値は `Access-Control-Expose-Headers$h 応答~headerに依存することになる。
例えば、
応答が次の~headerを内包していたとする：
◎
bar.invalid provides a correct `Access-Control-Allow-Origin` response header per the earlier example. The values of hsts and csp will depend on the `Access-Control-Expose-Headers` response header. For example, if the response included the following headers
</p>

<pre class="lang-http">
`Content-Security-Policy$: `default-src$dir 'self'
`Strict-Transport-Security$: max-age=31536000; includeSubdomains; preload
Access-Control-Expose-Headers: Content-Security-Policy
</pre>

<p>
この場合、
応答が両~headerとも内包していたとしても，
%hsts は ~NULL,
%csp は `default-src 'self'^l
になる。
何故なら、
`bar.invalid^s は，［
`Access-Control-Expose-Headers$h 応答~header内にそれらの~header名を~listする
］ことにより［
各~headerごとに明示的に共有させる必要がある
］ので。
◎
then hsts would be null and csp would be "default-src 'self'", even though the response did include both headers. This is because bar.invalid needs to explicitly share each header by listing their names in the `Access-Control-Expose-Headers` response header.
</p>

<p>
代替として、
`bar.invalid^s は，［
`資格証$を含まない要請に対し，自身による応答~headerすべてを共有させる
］よう求めるなら［
`Access-Control-Expose-Headers$h 応答~headerの値に `*^bl を利用する
］こともできる。
`資格証$を含む要請に対しては、
応答~header名は明示的に~listされる必要があり，
`*^bl は利用できない。
◎
Alternatively, if bar.invalid wanted to share all its response headers, for requests that do not include credentials, it could use `*` as value for the `Access-Control-Expose-Headers` response header. If the request would have included credentials, the response header names would have to be listed explicitly and `*` could not be used.
</p>
</div>

<div class="example" id="example-cors-with-credentials">
<p>
`foo.invalid^s の開発者が今度は、
`資格証$も含ませつつ，
`bar.invalid^s から何か~dataを~fetchしようとしたとする。
`資格証$には明示的な~opt-inが要求されるので、
もはや開発者にとっては，
`~CORS~protocol$周りで透過的でなくなる：
◎
The developer of foo.invalid returns, now fetching some data from bar.invalid while including credentials. This time around the CORS protocol is no longer transparent to the developer as credentials require an explicit opt-in:
</p>

<pre class="lang-js">
fetch(%url, { credentials:"include" }).then(%success, %failure)
</pre>

<p>
これもまた、
`bar.invalid^s が内包させた `Set-Cookie$h 応答~headerを全部的に機能させる
（さもなければ【？】無視される）。
◎
This also makes any `Set-Cookie` response headers bar.invalid includes fully functional (they are ignored otherwise).
</p>

<p>
~UAは、
関連な`資格証$があれば，
それも要請~内に必ず含ませる。
また、
応答にも，より厳密な要件を課す
— `bar.invalid^s からの応答には、
`Access-Control-Allow-Origin$h ~header用に `https://foo.invalid^bl を~listする必要があることに加え
（`資格証$が孕まれる下では `*^bl は許容されない），
`Access-Control-Allow-Credentials$h ~headerも在る必要がある：
◎
The user agent will make sure to include any relevant credentials in the request. It will also put stricter requirements on the response. Not only will bar.invalid need to list `https://foo.invalid` as value for the `Access-Control-Allow-Origin` header (`*` is not allowed when credentials are involved), the `Access-Control-Allow-Credentials` header has to be present too: 
</p>

<pre class="lang-http">
Access-Control-Allow-Origin: https://foo.invalid
Access-Control-Allow-Credentials: true
</pre>

<p>
応答が，これらの値を伴うこれら 2 つの~headerを内包していない場合、
%failure ~callbackが呼出される。
しかしながら、
`Set-Cookie$h 応答~headerは尊重されることになる。
◎
If the response does not include those two headers with those values, the failure callback will be invoked. However, any `Set-Cookie` response headers will be respected.
</p>
</div>

			</section>
			<section id="cors-protocol-exceptions">
<h4 title="CORS protocol exceptions">3.2.7. ~CORS~protocolの例外</h4>

<p>
いくつかの仕様は、
~CORS安全とされる~headerに対する制限付きな例外を，安全とされていない［
`Content-Type$h ~header値
］用に許容していた。
そのような例外は、
~web内容が誘発し得る要請のうち［
~web内容が制御し得るのは、
必要最小限な［
~header／本体
］に限られるもの
］用に~~策定された。
したがって、
~serverは，［
非同一-生成元に属する~web内容には，［
次に挙げる，安全とされていない［
`Content-Type$h ~header値
］を伴う要請
］を［
予行を伴わずに誘発する
］ことが許容される
］ものと予期するベキである：
◎
Specifications have allowed limited exceptions to the CORS safelist for non-safelisted `Content-Type` header values. These exceptions are made for requests that can be triggered by web content but whose headers and bodies can be only minimally controlled by the web content. Therefore, servers should expect cross-origin web content to be allowed to trigger non-preflighted requests with the following non-safelisted `Content-Type` header values:
</p>

<ul ><li>`application/csp-report^bl `CSP$r
</li><li>`application/expect-ct-report+json^bl `RFC9163$r
</li><li>`application/xss-auditor-report^bl
</li><li>`application/ocsp-request^bl `RFC6960$r
</li></ul>

<p>
各~仕様は、
新たな例外を導入することを避けるベキである
— そうする場合、
~security上の帰結を注意深く考慮するベキである。
新たな例外は、
`課題を申請して＠https://github.com/whatwg/fetch/issues/new$提案できる。
◎
Specifications should avoid introducing new exceptions and should only do so with careful consideration for the security consequences. New exceptions can be proposed by filing an issue.
</p>

			</section>
		</section>
		<section id="content-length-header">
<h3 title="Content-Length header">3.3. `Content-Length^h ~header</h3>

<p>
`Content-Length$h ~headerは，大部分は~HTTPにて定義されているが、
その処理~modelは，ここに定義される
— ~HTTPが定義する~modelは、
~web内容と互換でないので。
`HTTP$r
◎
The `Content-Length` header is largely defined in HTTP. Its processing model is defined here as the model defined in HTTP is not compatible with web content. [HTTP]
</p>

<div class="algo">
<p>
`~header~listから長さを抽出する@
~algoは、
所与の
( `~header~list$ %~header群 )
に対し：
◎
To extract a length from a header list headers, run these steps:
</p>
<ol>
	<li>
%値~群 ~LET `~header~listから値を取得して復号して分割する$( %~header群, `Content-Length^h )
◎
Let values be the result of getting, decoding, and splitting `Content-Length` from headers.
</li>
	<li>
~IF［
%値~群 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If values is null, then return null.
</li>
	<li>
%候補~値 ~LET ~NULL
◎
Let candidateValue be null.
</li>
	<li>
<p>
%値~群 を成す
~EACH( %値 )
に対し：
◎
For each value of values:
</p>
		<ol>
			<li>
~IF［
%候補~値 ~EQ ~NULL
］
⇒
%候補~値 ~SET %値
◎
If candidateValue is null, then set candidateValue to value.
</li>
			<li>
~ELIF［
%値 ~NEQ %候補~値
］
⇒
~RET `失敗^i
◎
Otherwise, if value is not candidateValue, return failure.
</li>
		</ol>
	</li>
	<li>
~IF［
%候補~値 ~EQ 空~文字列
］~OR［
%候補~値 内に`~ASCII数字$でない`文字$がある
］
⇒
~RET ~NULL
◎
If candidateValue is the empty string or has a code point that is not an ASCII digit, then return null.
</li>
	<li>
~RET %候補~値 を 10 進数として解釈した結果
◎
Return candidateValue, interpreted as decimal number.
</li>
</ol>
</div>

		</section>
		<section id="content-type-header">
<h3 title="Content-Type header">3.4. `Content-Type^h ~header</h3>

<p>
`Content-Type$h ~headerは，大部分は~HTTPにて定義されているが、
その処理~modelは，ここに定義される
— ~HTTPが定義する~modelは、
~web内容と互換でないので。
`HTTP$r
◎
The `Content-Type` header is largely defined in HTTP. Its processing model is defined here as the model defined in HTTP is not compatible with web content. [HTTP]
</p>

<div class="algo">
<p>
`~header~listから~MIME型を抽出する@
~algoは、
所与の
( `~header~list$ %~headerたち )
に対し，［
`失敗^i ／`~MIME型$
］を返す：
◎
To extract a MIME type from a header list headers, run these steps. They return failure or a MIME type.
</p>
<ol>
	<li>
%~charset ~LET ~NULL
◎
Let charset be null.
</li>
	<li>
%~essence ~LET ~NULL
◎
Let essence be null.
</li>
	<li>
%~MIME型 ~LET ~NULL
◎
Let mimeType be null.
</li>
	<li>
%値~群 ~LET `~header~listから値を取得して復号して分割する$( %~headerたち, `Content-Type$h )
◎
Let values be the result of getting, decoding, and splitting `Content-Type` from headers.
</li>
	<li>
~IF［
%値~群 ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If values is null, then return failure.
</li>
	<li>
<p>
%値~群 を成す
~EACH( %値 )
に対し：
◎
For each value of values:
</p>
		<ol>
			<li>
%一時的~MIME型 ~LET `~MIME型を構文解析する$( %値 )
◎
Let temporaryMimeType be the result of parsing value.
</li>
			<li>
~IF［
%一時的~MIME型 ~EQ `失敗^i
］~OR［
%一時的~MIME型 の`~essence$ ~EQ `*/*^l
］
⇒
~CONTINUE
◎
If temporaryMimeType is failure or its essence is "*/*", then continue.
</li>
			<li>
%~MIME型 ~SET %一時的~MIME型
◎
Set mimeType to temporaryMimeType.
</li>
			<li>
%~parameter群 ~LET %~MIME型 の`~parameter群$
◎
↓</li>
			<li>
<p>
~IF［
%~MIME型 の`~essence$ ~NEQ %~essence
］：
◎
If mimeType’s essence is not essence, then:
</p>
				<ol>
					<li>
%~charset ~SET ~NULL
◎
Set charset to null.
</li>
					<li>
~IF［
%~parameter群[ `charset^l ] ~NEQ ε
］
⇒
%~charset ~SET %~parameter群[ `charset^l ]
◎
If mimeType’s parameters["charset"] exists, then set charset to mimeType’s parameters["charset"].
</li>
					<li>
%~essence ~SET %~MIME型 の`~essence$
◎
Set essence to mimeType’s essence.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~parameter群[ `charset^l ] ~EQ ε
］~AND［
%~charset ~NEQ ~NULL
］
⇒
%~parameter群[ `charset^l ] ~SET %~charset
◎
Otherwise, if mimeType’s parameters["charset"] does not exist, and charset is non-null, set mimeType’s parameters["charset"] to charset.
</li>
		</ol>
	</li>
	<li>
~IF［
%~MIME型 ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If mimeType is null, then return failure.
</li>
	<li>
~RET %~MIME型
◎
Return mimeType.
</li>
</ol>

<p class="warning">
`~header~listから~MIME型を抽出する$から返された結果が［
`失敗^i の場合／
`~MIME型$であって，
その`~essence$は所与の内容形式~用には不正である場合
］、
致命的な~errorとして扱う。
既存の~web~platform特能は、
この~patternに常に従ってはいなかった
— それは、
長年にわたり，それらの特能における~security脆弱性を成す大多数の~sourceであった。
対照的に，`~MIME型$の`~parameter群$は、
概して安全に無視できる。
◎
When extract a MIME type returns failure or a MIME type whose essence is incorrect for a given format, treat this as a fatal error. Existing web platform features have not always followed this pattern, which has been a major source of security vulnerabilities in those features over the years. In contrast, a MIME type’s parameters can typically be safely ignored.
</p>
</div>

<div class="example">
<p>
`~header~listから~MIME型を抽出する$ が、
実施においてどう機能するかを次に示す：
◎
This is how extract a MIME type functions in practice:
</p>

<table><thead>
<tr><th>
（~network上の）~header列
◎
Headers (as on the network)
<th>
（`直列化された＠~MIMESNIFF#serialize-a-mime-type$）出力
◎
Output (serialized)
<tbody>

<tr><td><pre class="lang-http">
Content-Type: text/plain;charset=gbk, text/html
</pre>
<td>`text/html^c

<tr><td><pre class="lang-http">
Content-Type: text/html;charset=gbk;a=b, text/html;x=y
</pre>
<td rowspan="2">`text/html;x=y;charset=gbk^c

<tr><td><pre class="lang-http">
Content-Type: text/html;charset=gbk;a=b
Content-Type: text/html;x=y
</pre>

<tr><td><pre class="lang-http">
Content-Type: text/html;charset=gbk
Content-Type: x/x
Content-Type: text/html;x=y
</pre>
<td>`text/html;x=y^c

<tr><td><pre class="lang-http">
Content-Type: text/html
Content-Type: cannot-parse
</pre>
<td rowspan="3">`text/html^c

<tr><td><pre class="lang-http">
Content-Type: text/html
Content-Type: */*
</pre>

<tr><td><pre class="lang-http">
Content-Type: text/html
Content-Type:
</pre>
</table>
</div>

<div class="algo">
<p>
`旧来~用に符号化法を抽出する@
~algoは、
所与の
( ［ `失敗^i ／`~MIME型$ ］ %~MIME型, `符号化法$ %~fallback符号化法 )
に対し：
◎
To legacy extract an encoding given failure or a MIME type mimeType and an encoding fallbackEncoding, run these steps:
</p>
<ol>
	<li>
~IF［
%~MIME型 ~EQ `失敗^i
］
⇒
~RET %~fallback符号化法
◎
If mimeType is failure, then return fallbackEncoding.
</li>
	<li>
%~label ~LET %~MIME型 【の`~parameter群$】[ `charset^l ]
◎
↓</li>
	<li>
~IF［
%~label ~EQ ε
］
⇒
~RET %~fallback符号化法
◎
If mimeType["charset"] does not exist, then return fallbackEncoding.
</li>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label )
◎
Let tentativeEncoding be the result of getting an encoding from mimeType["charset"].
</li>
	<li>
~IF［
%符号化法 ~EQ `失敗^i
］
⇒
~RET %~fallback符号化法
◎
If tentativeEncoding is failure, then return fallbackEncoding.
</li>
	<li>
~RET %符号化法
◎
Return tentativeEncoding.
</li>
</ol>

<p class="note">注記：
この~algoは、
`~header~listから~MIME型を抽出する$~algoと容易に組合できるよう，
%~MIME型 として `失敗^i も許容する。
“旧来” と表記されているのは、
現代の形式は，`~UTF-8$encを排他的に利用するからである。
◎
This algorithm allows mimeType to be failure so it can be more easily combined with extract a MIME type.
◎
It is denoted as legacy as modern formats are to exclusively use UTF-8.
</p>
</div>

		</section>
		<section id="x-content-type-options-header">
<h3 title="X-Content-Type-Options header">3.5. `X-Content-Type-Options^h ~header</h3>

<p>
`X-Content-Type-Options@h
応答`~header$は、
次を要求するために利用できる
⇒
`応答$の `Content-Type$h `~header$を`要請$の`行先$rqと突き合わせて検査する。
◎
The `X-Content-Type-Options` response header can be used to require checking of a response’s `Content-Type` header against the destination of a request.
</p>

<div class="algo">
<p>
`~nosniffかどうか決定する@
~algoは、
所与の
( `~header~list$ %~list )
に対し：
◎
To determine nosniff, given a header list list, run these steps:
</p>
<ol>
	<li>
%値~群 ~LET `~header~listから値を取得して復号して分割する$( %~list, `X-Content-Type-Options$h )
◎
Let values be the result of getting, decoding, and splitting `X-Content-Type-Options` from list.
</li>
	<li>
~IF［
%値~群 ~EQ ~NULL
］
⇒
~RET ~F
◎
If values is null, then return false.
</li>
	<li>
~IF［
%値~群[ 0 ] は `nosniff^l に`~ASCII大小無視$で合致する
］
⇒
~RET ~T
◎
If values[0] is an ASCII case-insensitive match for "nosniff", then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
［
~web開発者／適合性~検査器
］は、
`X-Content-Type-Options$h 用の`値$hdに，次の`~ABNF$を利用しなければナラナイ：
◎
Web developers and conformance checkers must use the following value ABNF for `X-Content-Type-Options`:
</p>

<pre class="bnf">
X-Content-Type-Options
	= "nosniff" ; <span class="comment">大小無視</span>
</pre>

			<section id="should-response-to-request-be-blocked-due-to-nosniff?">
<h4 title="Should response to request be blocked due to nosniff?">3.5.1. 要請に対する応答は，~nosniffに因り阻止されるべきか？</h4>

<div class="algo">
<p>
この~algoは、
所与の
( `要請$ %要請, `応答$ %応答 )
に対し：
◎
Run these steps:
</p>
<ol>
	<li>
~IF［
`~nosniffかどうか決定する$( %応答 の`~header~list$rs ) ~EQ ~F
］
⇒
~RET `許容される^i
◎
If determine nosniff with response’s header list is false, then return allowed.
</li>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
	<li>
%行先 ~LET %要請 の`行先$rq
◎
Let destination be request’s destination.
</li>
	<li>
<p>
~RET［
~OR↓ が満たされるならば `阻止される^i ／
~ELSE_ `許容される^i
］：
</p>
		<ul>
			<li>
［
%行先 は`~scriptに類する$
］~AND［［
%~MIME型 ~EQ `失敗^i
］~OR［
%~MIME型 は`~JS~MIME型$でない
］］
</li>
			<li>
［
%行先 ~EQ `style^l
］~AND［［
%~MIME型 ~EQ `失敗^i
］~OR［
%~MIME型 の`~essence$ ~NEQ `text/css^l
］］
</li>
		</ul>
◎
If destination is script-like and mimeType is failure or is not a JavaScript MIME type, then return blocked.
◎
If destination is "style" and mimeType is failure or its essence is not "text/css", then return blocked.
◎
Return allowed.
</li>
</ol>

<p class="note">注記：
ここで考慮される`要請$の`行先$rqは、［
`~scriptに類する$もの／ `style^l
］に限られる
— どの悪用も，これらに該当するので。
また、
ここで `image^l も考慮すると，
配備-済みな内容と互換にならなくなる。
◎
Only request destinations that are script-like or "style" are considered as any exploits pertain to them. Also, considering "image" was not compatible with deployed content.
</p>
</div>

			</section>
		</section>
		<section id="cross-origin-resource-policy-header">
<h3 title="Cross-Origin-Resource-Policy header">3.6. `Cross-Origin-Resource-Policy^h ~header</h3>

<p>
`Cross-Origin-Resource-Policy@h
応答`~header$は、
次を要求するために利用できる
⇒
［
`要請$の`~mode$rq ~EQ `no-cors^l
］のときには、
`要請$の`現在の~URL$rqの`生成元$urlを`要請$の`生成元$rqと突き合わせて検査する
◎
The `Cross-Origin-Resource-Policy` response header can be used to require checking a request’s current URL’s origin against a request’s origin when request’s mode is "no-cors".
</p>

<p>
その`値$hd用の`~ABNF$は：
◎
Its value ABNF:
</p>

<pre class="bnf">
Cross-Origin-Resource-Policy
	= `%s^"same-origin" / `%s^"same-site" / `%s^"cross-origin"; <span class="comment">文字大小区別</span>

</pre>

<p class="trans-note">【
~CORPは、［
非同一-生成元~資源~施策／この~header名
］の略称を表す。
】</p>

<div class="algo">
<p>
`非同一-生成元~資源~施策~検査@
を遂行する
~algoは、
所与の
⇒＃
`生成元$【！`生成元$url】 %生成元,
`環境~設定群~obj$ %設定群~obj,
文字列 %行先,
`応答$ %応答,
真偽値 %~navi用か （省略時は ~F ）
◎終
に対し：
◎
To perform a cross-origin resource policy check, given an origin origin, an environment settings object settingsObject, a string destination, a response response, and an optional boolean forNavigation, run these steps:
• Set forNavigation to false if it is not given.
</p>
<ol>
	<li>
%埋込元~施策 ~LET %設定群~obj の`施策~容器$enVの`埋込元~施策$pC
◎
Let embedderPolicy be settingsObject’s policy container’s embedder policy.
</li>
	<li>
<p>
~IF［
`非同一-生成元~資源~施策~内部~検査$( %生成元, `unsafe-none$l, %応答, %~navi用か )
~EQ `阻止される^i
］
⇒
~RET `阻止される^i
◎
If the cross-origin resource policy internal check with origin, "unsafe-none", response, and forNavigation returns blocked, then return blocked.
</p>

<p class="note">注記：
この段が必要になるのは、
下に与える非同一-生成元~埋込元~施策に関係しない違反は，
報告するよう求まれないからである。
◎
This step is needed because we don’t want to report violations not related to Cross-Origin Embedder Policy below.
</p>
	</li>
	<li>
~IF［
`非同一-生成元~資源~施策~内部~検査$( %生成元 , %埋込元~施策 の`報告のみの値$embP, %応答, %~navi用か )
~EQ `阻止される^i
］
⇒
`非同一-生成元~埋込元~施策~CORP違反~報告を~queueする$( %応答, %設定群~obj, %行先, ~T )
◎
If the cross-origin resource policy internal check with origin, embedderPolicy’s report only value, response, and forNavigation returns blocked, then queue a cross-origin embedder policy CORP violation report with response, settingsObject, destination, and true.
</li>
	<li>
~IF［
`非同一-生成元~資源~施策~内部~検査$( %生成元, %埋込元~施策 の`値$embP, %応答, %~navi用か )
~EQ `許容される^i
］
⇒
~RET `許容される^i
◎
If the cross-origin resource policy internal check with origin, embedderPolicy’s value, response, and forNavigation returns allowed, then return allowed.
</li>
	<li>
`非同一-生成元~埋込元~施策~CORP違反~報告を~queueする$( %応答, %設定群~obj, %行先, ~F )
◎
Queue a cross-origin embedder policy CORP violation report with response, settingsObject, destination, and false.
</li>
	<li>
~RET `阻止される^i
◎
Return blocked.
</li>
</ol>

<p class="note">注記：
~HTMLの`~navi~algo$に限り，この検査を %~navi用か に ~T を与える下で利用する
— それはまた、
入子な【`子~navigable$に対する】~navi用には，常に この検査を利用する。
他の場合、
%応答 は［
`不透明な絞込み応答$の`内部~応答$か，そうなるもの
］になる。
`HTML$r
◎
Only HTML’s navigate algorithm uses this check with forNavigation set to true, and it’s always for nested navigations. Otherwise, response is either the internal response of an opaque filtered response or a response which will be the internal response of an opaque filtered response. [HTML]
</p>
</div>

<div class="algo">
<p>
`非同一-生成元~資源~施策~内部~検査@
を遂行する
~algoは、
所与の
⇒＃
`生成元$【！`生成元$url】 %生成元,
`埋込元~施策~値$ %埋込元~施策~値,
`応答$ %応答,
真偽値 %~navi用か
◎終
に対し：
◎
To perform a cross-origin resource policy internal check, given an origin origin, an embedder policy value embedderPolicyValue, a response response, and a boolean forNavigation, run these steps:
</p>
<ol>
	<li>
~IF［
%~navi用か ~EQ ~T
］~AND［
%埋込元~施策~値 ~EQ `unsafe-none$l
］
⇒
~RET `許容される^i
◎
If forNavigation is true and embedderPolicyValue is "unsafe-none", then return allowed.
</li>
	<li>
<p>
%施策 ~LET `~header~listから値を取得する$( %応答 の`~header~list$rs, `Cross-Origin-Resource-Policy$h )
◎
Let policy be the result of getting `Cross-Origin-Resource-Policy` from response’s header list.
</p>

<p class="note">注記：
`Cross-Origin-Resource-Policy: same-site, same-origin^bl
にされた場合、［
%埋込元~施策~値 ~EQ `unsafe-none$l【すなわち ~NEQ `require-corp$l 】
］である限り，以下において %施策 が何かに合致することは決してないので，
`許容される^i を返すことになる。
`Cross-Origin-Resource-Policy$h ~headerが複数個ある場合も同じ効果になる。
【すなわち，`~field値$が複数個の~tokenを含む場合、~headerが無かったときと同じになる。】
◎
This means that `Cross-Origin-Resource-Policy: same-site, same-origin` ends up as allowed below as it will never match anything, as long as embedderPolicyValue is "unsafe-none". Two or more `Cross-Origin-Resource-Policy` headers will have the same effect.
</p>
	</li>
	<li>
~IF［
%施策 ~NIN { `same-origin^bl, `same-site^bl, `cross-origin^bl }
］
⇒
%施策 ~SET ~NULL
◎
If policy is neither `same-origin`, `same-site`, nor `cross-origin`, then set policy to null.
</li>
	<li>
<p>
~IF［
%施策 ~EQ ~NULL
］~AND［
~OR↓
］…
</p>
		<ul>
			<li>
［
%埋込元~施策~値 ~EQ `credentialless$l
］~AND［［
%応答 の`要請は資格証を含むか$rs ~EQ ~T
］~OR［
%~navi用か ~EQ ~T
］］
</li>
			<li>
%埋込元~施策~値 ~EQ `require-corp$l
</li>
		</ul>
<p>
…ならば
⇒
%施策 ~SET `same-origin^bl
</p>
◎
If policy is null, then switch on embedderPolicyValue:
◎
"unsafe-none"
• Do nothing.
◎
"credentialless"
• Set policy to `same-origin` if:
•• response’s request-includes-credentials is true, or
•• forNavigation is true. 
◎
"require-corp"
• Set policy to `same-origin`.
</li>
	<li>
<p>
%施策 に応じて：
◎
Switch on policy:
</p>
		<dl class="switch">
			<dt>~NULL</dt>
			<dt>`cross-origin^bl</dt>
			<dd>
~RET `許容される^i
◎
Return allowed.
</dd>
			<dt>`same-origin^bl</dt>
			<dd>
~RET ［
次が満たされるならば `許容される^i ／
~ELSE_ `阻止される^i
］
⇒
%生成元
~EQ`生成元$sub
%応答 の`~URL$rsの`生成元$url
◎
If origin is same origin with response’s URL’s origin, then return allowed.
◎
Otherwise, return blocked.
</dd>
			<dt>`same-site^bl</dt>
			<dd>
<p>
~RET ［
~AND↓ が満たされるならば `許容される^i ／
~ELSE_ `阻止される^i
］：
</p>
				<ul>
					<li>
( %生成元, %応答 の`~URL$rsの`生成元$url )
は、
`~scheme無しで同じ~site$である
</li>
					<li>
［
%生成元 の`~scheme$url ~EQ `https^l
］~OR［
%応答 の`~URL$rsの`~scheme$url ~NEQ `https^l
］
</li>
				</ul>
◎
If all of the following are true
• origin is schemelessly same site with response’s URL’s origin
• origin’s scheme is "https" or response’s URL’s scheme is not "https"
then return allowed.
◎
Otherwise, return blocked.
</dd>
			<dd class="note">注記：
`Cross-Origin-Resource-Policy: same-site^bl
は、
要請している生成元【 %生成元 】が~secureでない場合，
~secureな~transportを介して送達された応答は【条件に】合致すると見なさない
— それらの~hostが~secureか否かを除けば【すなわち，~scheme無しで】同じ~siteであっても。
~secureに~transportされた応答が合致するのは、
【要請の】起動元が~secureに~transportされた場合に限られることになる。
◎
`Cross-Origin-Resource-Policy: same-site` does not consider a response delivered via a secure transport to match a non-secure requesting origin, even if their hosts are otherwise same site. Securely-transported responses will only match a securely-transported initiator.
</dd>
		</dl>
	</li>
</ol>
</div>

<div class="algo">
<p>
`非同一-生成元~埋込元~施策~CORP違反~報告を~queueする@
~algoは、
所与の
⇒＃
`応答$ %応答,
`環境~設定群~obj$ %設定群~obj,
文字列 %行先,
真偽値 %報告のみ
◎終
に対し：
◎
To queue a cross-origin embedder policy CORP violation report, given a response response, an environment settings object settingsObject, a string destination, and a boolean reportOnly, run these steps:
</p>
<ol>
	<li>
%施策 ~LET %設定群~obj の`施策~容器$enVの`埋込元~施策$pC
◎
↓</li>
	<li>
%報告先 ~LET %報告のみ に応じて
⇒＃
~T ならば %施策 の`報告のみの報告先$embP／
~F ならば %施策 の`報告先$embP
◎
Let endpoint be settingsObject’s policy container’s embedder policy’s report only reporting endpoint if reportOnly is true and settingsObject’s policy container’s embedder policy’s reporting endpoint otherwise.
</li>
	<li>
%直列化した~URL ~LET `応答~URLを報告-用に直列化する$( %応答 )
◎
Let serializedURL be the result of serializing a response URL for reporting with response.
</li>
	<li>
%処置 ~LET %報告のみ に応じて
⇒＃
~T ならば `reporting^l ／
~F ならば `enforce^l
◎
Let disposition be "reporting" if reportOnly is true; otherwise "enforce".
</li>
	<li>
<p>
%本体 ~LET 次に挙げる~propを包含している新たな `Object^jt：
</p>

<table><thead>
<tr><th>~key
<th>値
<tbody>

<tr><td>`type^l
<td>`corp^l

<tr><td>`blockedURL^l
<td>%直列化した~URL

<tr><td>`destination^l
<td>%行先

<tr><td>`disposition^l
<td>%処置
</table>

◎
Let body be a new object containing the following properties:
◎
key｜value
"type"｜"corp"
"blockedURL"｜serializedURL
"destination"｜destination
"disposition"｜disposition
</li>
	<li>
`報告を生成して~queueする$( %設定群~obj の`大域~obj$enV, `~COEP報告~種別$i, %報告先, %本体 )
`REPORTING$r
◎
Generate and queue a report for settingsObject’s global object given the "coep" report type, endpoint, and body. [REPORTING]
</li>
</ol>
</div>

		</section>

		<section id="sec-purpose-header">
<h3 title="Sec-Purpose header">3.7. `Sec-Purpose^h ~header</h3>

<p>
`Sec-Purpose@h
~HTTP要請~headerは、
次をを指定する
⇒
当の要請が~serveする目的は、［
利用者により即時に利用するために資源を要請すること
］以外にある。
◎
The `Sec-Purpose` HTTP request header specifies that the request serves one or more purposes other than requesting the resource for immediate use by the user.
</p>

<p>
`Sec-Purpose$h ~headerは、
`有構造~header$であり，
その値は`~sf~token$でなければナラナイ。
◎
The `Sec-Purpose` header field is a structured header whose value must be a token.
</p>

<p>
`Sec-Purpose$h ~header用に定義される値は、
`~sf~token$ `prefetch^v しかない。
それは、
次を指示する
⇒
当の要請の目的は、
近いうち必要になると見越される資源を~fetchすることである。
◎
The sole token defined is prefetch. It indicates the request’s purpose is to fetch a resource that is anticipated to be needed shortly.
</p>


<p class="note">注記：
~serverは、
これを次に利用できる
⇒
~prefetch【に対する応答】が~cacheされるときの有効期限を調整する／
当の~prefetchを許容しない／
当の~prefetchをどう扱うかを~page訪問~回数に応じて違える
◎
The server can use this to adjust the caching expiry for prefetches, to disallow the prefetch, or to treat it differently when counting page visits.
</p>

		</section>
	</section>
	<section id="fetching">
<h2 title="Fetching">4. ~fetching</h2>

<p class="note">注記：
次の~algoが、
`~fetching$を定義する。
それは，大雑把に言えば、
`要請$, および［
演算の間の様々な地点で走らす~algoたち
］を~~入力にとる。
下に挙げる
1, 2 個目の~algoは~uploadを捕捉するために利用でき，
他の【！the last two】~algoには`応答$が渡される。
◎
The algorithm below defines fetching. In broad strokes, it takes a request and one or more algorithms to run at various points during the operation. A response is passed to the last two algorithms listed below. The first two algorithms can be used to capture uploads.
</p>

<div class="algo">
<div class="p">
<p>
所与の`要請$ %要請 を
`~fetchする@
~algoは、
所与の：
</p>
<ul>
	<li>
`要請の本体~chunk長さの処理n@V
⇒
~NULL（省略時）／
伝送される~byte数を表現する整数を受容する~algo
</li>
	<li>
`要請の本体~終了~時の処理n@V
⇒
~NULL（省略時）／
引数をとらない~algo
</li>
	<li>
`応答の早期~hintの処理n@V
⇒
~NULL（省略時）／
`応答$を受容する~algo
</li>
	<li>
`応答の処理n@V
⇒
~NULL（省略時）／
`応答$を受容する~algo
</li>
	<li>
`応答の本体~終了~時の処理n@V
⇒
~NULL（省略時）／
`応答$を受容する~algo
</li>
	<li>
`応答の本体を消費する処理n@V
⇒
~NULL（省略時）／ 次を受容する~algo
⇒
`応答$, ［
~NULL ／ `失敗^i ／`~byte列$
］
</li>
	<li>
`並列~queueを利用するか@V
⇒
真偽値（省略時は ~F ）
</li>
</ul>

<p>
に対し，ある`~fetch制御器$を返す：
</p>
◎
To fetch, given a request request,＼
an optional algorithm processRequestBodyChunkLength,＼
an optional algorithm processRequestEndOfBody,＼
an optional algorithm processEarlyHintsResponse,＼
an optional algorithm processResponse,＼
an optional algorithm processResponseEndOfBody,＼
an optional algorithm processResponseConsumeBody,＼
and an optional boolean useParallelQueue (default false),＼
run the steps below.＼
If given, processRequestBodyChunkLength must be an algorithm accepting an integer representing the number of bytes transmitted.＼
If given, processRequestEndOfBody must be an algorithm accepting no arguments.＼
If given, processEarlyHintsResponse must be an algorithm accepting a response.＼
If given, processResponse must be an algorithm accepting a response.＼
If given, processResponseEndOfBody must be an algorithm accepting a response.＼
If given, processResponseConsumeBody must be an algorithm accepting a response and null, failure, or a byte sequence.
</div>

<p>
~UAは、
進行中な~fetchを
`休止-@
するよう，依頼されることもある。
~UAは、
その休止~要請を受容しても無視してもヨイ。
休止された~fetchは、
`再開-@
できる。
~UAは、
進行中な~fetchが，当の要請に対する［
~HTTP~cache内の応答
］を更新している場合には，
休止~要請を無視するベキである。
◎
The user agent may be asked to suspend the ongoing fetch. The user agent may either accept or ignore the suspension request. The suspended fetch can be resumed. The user agent should ignore the suspension request if the ongoing fetch is updating the response in the HTTP cache for the request.
</p>

<div class="note">
<p>注記：
~OR↓ が満たされる場合、
~UAは，`要請$に対する~HTTP~cache内の~entryを更新しない：
</p>
<ul>
	<li>
要請の`~cache~mode$rq ~EQ `no-store^l
</li>
	<li>
応答の `Cache-Control$h ~header値は `no-store^dir を含む `HTTP-CACHING$r
</li>
</ul>
◎
The user agent does not update the entry in the HTTP cache for a request if request’s cache mode is "no-store" or a `Cache-Control: no-store` header appears in the response. [HTTP-CACHING]
</div>

<ol>
		<li>
<p>
~Assert：
［
%要請 の`~mode$rq ~EQ `navigate^l
］~OR［
%応答の早期~hintの処理n ~EQ ~NULL
］
◎
Assert: request’s mode is "navigate" or processEarlyHintsResponse is null.
</p>

<p class="note">注記：
早期~hint
（ `early hints^en ）
（`応答$のうち，その`状態s$rs ~EQ `103$st なるもの）
の処理は、
~navi用に限り審査される。
◎
Processing of early hints (responses whose status is 103) is only vetted for navigations.
</p>
	</li>
	<li>
%~taskの行先 ~LET ~NULL
◎
Let taskDestination be null.
</li>
	<li>
%非同一-生成元~能力は隔離されるか ~LET ~F
◎
Let crossOriginIsolatedCapability be false.
</li>
	<li>
`~clientから要請を拡充する$( %要請 )
◎
Populate request from client given request.
</li>
	<li>
<p>
~IF［
%要請 の`~client$rq ~NEQ ~NULL
］：
◎
If request’s client is non-null, then:
</p>
		<ol>
			<li>
%~taskの行先 ~SET %要請 の`~client$rqの`大域~obj$enV
◎
Set taskDestination to request’s client’s global object.
</li>
			<li>
%非同一-生成元~能力は隔離されるか ~SET %要請 の`~client$rqの`非同一-生成元~能力は隔離されるか？$enV
◎
Set crossOriginIsolatedCapability to request’s client’s cross-origin isolated capability.
</li>
		</ol>
	</li>
	<li>
~IF［
%並列~queueを利用するか ~EQ ~T
］
⇒
%~taskの行先 ~SET `新たな並列~queueを開始する$()
◎
If useParallelQueue is true, then set taskDestination to the result of starting a new parallel queue.
</li>
	<li>
%開始~時刻 ~LET `粗化した共有される現在の時刻$( %非同一-生成元~能力は隔離されるか )
◎
↓</li>
	<li>
%計時~報 ~LET 新たな`~fetch計時~報$
— その
⇒＃
`開始~時刻$fT ~SET %開始~時刻,
`~redirect後からの開始~時刻$fT ~SET %開始~時刻,
`具現化を阻んでいるか$fT ~SET %要請 の`具現化を阻んでいるか$rq
◎
Let timingInfo be a new fetch timing info whose start time and post-redirect start time are the coarsened shared current time given crossOriginIsolatedCapability, and render-blocking is set to request’s render-blocking.
</li>
	<li>
%~fetch~params ~LET 新たな`~fetch~params$
— その
⇒＃
`要請$fP ~SET %要請,
`計時~報$fP ~SET %計時~報,
`要請の本体~chunk長さの処理n$fP ~SET %要請の本体~chunk長さの処理n
`要請の本体~終了~時の処理n$fP ~SET %要請の本体~終了~時の処理n,
`応答の早期~hintの処理n$fP ~SET %応答の早期~hintの処理n,
`応答の処理n$fP ~SET %応答の処理n,
`応答の本体を消費する処理n$fP ~SET %応答の本体を消費する処理n,
`応答の本体~終了~時の処理n$fP ~SET %応答の本体~終了~時の処理n,
`~taskの行先$fP ~SET %~taskの行先,
`非同一-生成元~能力は隔離されるか$fP ~SET %非同一-生成元~能力は隔離されるか
◎
Let fetchParams be a new fetch params whose request is request, timing info is timingInfo, process request body chunk length is processRequestBodyChunkLength, process request end-of-body is processRequestEndOfBody, process early hints response is processEarlyHintsResponse, process response is processResponse, process response consume body is processResponseConsumeBody, process response end-of-body is processResponseEndOfBody, task destination is taskDestination, and cross-origin isolated capability is crossOriginIsolatedCapability.
</li>
	<li>
~IF［
%要請 の`本体$rqは`~byte列$である
］
⇒
%要請 の`本体$rq ~SET `~byte列を本体として取得する$( %要請 の`本体$rq )
◎
If request’s body is a byte sequence, then set request’s body to request’s body as a body.
</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following conditions are true:
</p>
		<ul>
			<li>
%要請 の`~URL$rqの`~scheme$urlは`~HTTP_S~scheme$である
◎
request’s URL’s scheme is an HTTP(S) scheme
</li>
			<li>
%要請 の`~mode$rq ~IN { `same-origin^l, `cors^l, `no-cors^l }
◎
request’s mode is "same-origin", "cors", or "no-cors"
</li>
			<li>
%要請 の`~window$rq は`環境~設定群~obj$である
◎
request’s window is an environment settings object
</li>
			<li>
%要請 の`~method$rq ~EQ `GET^bl
◎
request’s method is `GET`
</li>
			<li>
［
%要請 の`安全でない要請か$rq ~EQ ~F
］~OR［
%要請 の`~header~list$rqは`空$である
］
◎
request’s unsafe-request flag is not set or request’s header list is empty
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
~Assert：
%要請 の`生成元$rq ~EQ`生成元$sub  %要請 の`~client$rqの`生成元$enV
◎
Assert: request’s origin is same origin with request’s client’s origin.
</li>
			<li class="algo">
%~preloadされる応答~可用~時の手続き ~LET 
所与の
( `応答$ %応答 )
に対し，次を走らす~algo
⇒
%~fetch~params の`~preloadされる応答の候補$fP ~SET %応答
◎
Let onPreloadedResponseAvailable be an algorithm that runs the following step given a response response: set fetchParams’s preloaded response candidate to response.
</li>
			<li>
%~preloadされる資源を見出したか ~LET 
%要請 の`~window$rq用に`~preloadされる資源を消費する$( ↓ )
⇒＃
%要請 の`~URL$rq,
%要請 の`行先$rq,
%要請 の`~mode$rq,
%要請 の`資格証~mode$rq,
%要請 の`完全性~metadata$rq,
%~preloadされる応答~可用~時の手続き
◎
Let foundPreloadedResource be the result of invoking consume a preloaded resource for request’s window, given request’s URL, request’s destination, request’s mode, request’s credentials mode, request’s integrity metadata, and onPreloadedResponseAvailable.
</li>
			<li>
~IF［
%~preloadされる資源を見出したか ~EQ ~T
］~AND［
%~fetch~params の`~preloadされる応答の候補$fP ~EQ ~NULL
］
⇒
%~fetch~params の`~preloadされる応答の候補$fP ~SET `pending^l
◎
If foundPreloadedResource is true and fetchParams’s preloaded response candidate is null, then set fetchParams’s preloaded response candidate to "pending".
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%要請 の`~header~list$rq内に［
`Accept$h を`名前に持つ~header$
］は無い
］：
◎
If request’s header list does not contain `Accept`, then:
</p>
		<ol>
			<li>
%値 ~LET `*/*^bl
◎
Let value be `*/*`.
</li>
			<li>
~IF［
%要請 の`起動元$rq ~EQ `prefetch^l
］
⇒
%値 ~SET `文書 Accept ~header値$
◎
If request’s initiator is "prefetch", then set value to the document `Accept` header value.
</li>
			<li>
<p>
~ELSE
⇒
~UAは、
次に従うベキである
⇒
%値 ~SET %要請 の`行先$rqに応じて：
</p>
				<ul class="switch">
					<li>
`document^l ／
`frame^l ／
`iframe^l
⇒
`文書 Accept ~header値$
◎
"document"
"frame"
"iframe"
the document `Accept` header value
</li>
					<li>
`image^l
⇒
`image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5^bl
</li>
					<li>
`json^l
⇒
`application/json,*/*;q=0.5^bl
</li>
					<li>
`style^l
⇒
`text/css,*/*;q=0.1^bl
</li>
				</ul>

◎
Otherwise, the user agent should set value to the first matching statement, if any, switching on request’s destination:
• "document"
• "frame"
• "iframe"
•• the document `Accept` header value
• "image"
•• `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
• "json"
•• `application/json,*/*;q=0.5`
• "style"
•• `text/css,*/*;q=0.1`
</li>
			<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Accept$h, %値 )
)
◎
Append (`Accept`, value) to request’s header list.
</li>
		</ol>
	</li>
	<li>
~IF［
%要請 の`~header~list$rq内に［
`Accept-Language$h を`名前に持つ~header$
］は無い
］
⇒
~UAは、
次を行うベキである
⇒
%要請 の`~header~list$rqに`~headerを付加する$(
( `Accept-Language$h, 適切な`~header値$ )
)
◎

If request’s header list does not contain `Accept-Language`, then user agents should append (`Accept-Language, an appropriate header value) to request’s header list.
</li>
	<li>
<p>
~IF［
%要請 の`内部的な優先度$rq ~EQ ~NULL
］
⇒
%要請 の`優先度$rq ~SET `実装定義$な方式で，
%要請 の［
`優先度$rq,
`起動元$rq,
`行先$rq,
`具現化を阻んでいるか$rq
］を利用する~obj
◎
If request’s internal priority is null, then use request’s priority, initiator, destination, and render-blocking in an implementation-defined manner to set request’s internal priority to an implementation-defined object.
</p>

<div class="note" id="_stream-priority">
<p>
注記：
`実装定義$な~objは、
次に挙げるものを包摂し得る：
◎
The implementation-defined object could encompass＼
</p>
		<ul>
			<li>
~HTTP2用には、
~streamの［
重み, 依存関係
］。
◎
stream weight and dependency for HTTP/2,＼
</li>
			<li>
`~HTTP用の拡張-可能な優先度~scheme^cite `RFC9218$r にて利用される優先度
— 当の~transportに適用されるならば。
◎
priorities used in Extensible Prioritization Scheme for HTTP for transports where it applies (including HTTP/3),＼
</li>
			<li>
~HTTP1x用には、
~fetchにおける［
配送-, 処理
］に優先度を与えるために利用される，以上に挙げたものと等価な情報。
◎
and equivalent information used to prioritize dispatch and processing of HTTP/1 fetches. [RFC9218]
</li>
		</ul>
	</div>
	</li>
	<li>
<p>
~IF［
%要請 は`下位資源~要請$である
］：
◎
If request is a subresource request, then:
</p>
		<ol>
			<li>
%記録 ~LET 新たな`~fetch記録$
— その
⇒＃
`要請$fR ~SET %要請,
`制御器$fR ~SET %~fetch~params の`制御器$fP
◎
Let record be a new fetch record whose request is request and controller is fetchParams’s controller.
</li>
			<li>
［
%要請 の`~client$rqの`~fetch~group$を成す，`~fetch記録$たちが成す~list
］に %記録 を付加する
◎
Append record to request’s client’s fetch group list of fetch records.
</li>
		</ol>
	</li>
	<li>
`~main~fetch$( %~fetch~params )
◎
Run main fetch given fetchParams.
</li>
	<li>
~RET %~fetch~params の`制御器$fP
◎
Return fetchParams’s controller.
</li>
</ol>
</div>

<div class="algo">
<p>
`~clientから要請を拡充する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To populate request from client given a request request:
</p>
<ol>
	<li>
%~client ~LET %要請 の`~client$rq
◎
↓</li>
	<li>
~IF［
%要請 の`~window$rq ~EQ `client^l
］
⇒
%要請 の`~window$rq ~SET ［
次が満たされるならば %~client ／
~ELSE_ `no-window^l
］
⇒
［
%~client ~NEQ ~NULL
【この条件は、この訳による補完】
］~AND［
%~client の`大域~obj$enVは `Window$I ~objである
］
◎
If request’s window is "client", then: set request’s window to request’s client if request’s client’s global object is a Window object; otherwise "no-window".
</li>
	<li>
~IF［
%要請 の`生成元$rq ~EQ `client^l
］
⇒
%要請 の`生成元$rq ~SET %~client の`生成元$enV
【 %~client ~EQ ~NULL の場合にどうなるか指定されていない。】
◎
If request’s origin is "client", then set request’s origin to request’s client’s origin.
</li>
	<li>
~IF［
%要請 の`施策~容器$rq ~EQ `client^l
］
⇒
%要請 の`施策~容器$rq ~SET %~client に応じて
⇒＃
~NULL ならば 新たな`施策~容器$／
~ELSE_ `施策~容器を~cloneする$( %~client の`施策~容器$enV ) `HTML$r
◎
If request’s policy container is "client":
• If request’s client is non-null, then set request’s policy container to a clone of request’s client’s policy container. [HTML]
• Otherwise, set request’s policy container to a new policy container.
</li>
</ol>
</div>

		<section id="main-fetch">
<h3 title="Main fetch">4.1. ~main~fetch</h3>

<div class="algo">
<p>
`~main~fetch@
を遂行する
~algoは、
所与の
( `~fetch~params$ %~fetch~params, 真偽値 %再帰的か（省略時は ~F ） )
に対し：
◎
To main fetch, given a fetch params fetchParams and an optional boolean recursive (default false), run these steps:
</p>

<ol>
	<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
Let request be fetchParams’s request.
</li>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
~IF［
%要請 の`局所~URLに限るか$rq ~EQ ~T
］~AND［
%要請 の`現在の~URL$rqは`局所的$でない
］
⇒
%応答 ~SET `~network~error$
◎
If request’s local-URLs-only flag is set and request’s current URL is not local, then set response to a network error.
</li>
	<li>
%要請 に対する
`~CSP違反を報告する＠~CSP3#report-for-request$
◎
Run report Content Security Policy violations for request.
</li>
	<li>
`適切になるなら，要請を信用に価し得る~URLに昇格する＠~UPGRADE1#upgrade-request$( %要請 )
`UPGRADE$r
◎
Upgrade request to a potentially trustworthy URL, if appropriate.
</li>
	<li>
`適切になるなら，混在d内容への要請を信用に価し得る~URLに昇格する＠~MIXED-CONTENT#upgrade-algorithm$( %要請 )
`MIX$r
◎
Upgrade a mixed content request to a potentially trustworthy URL, if appropriate.
</li>
	<li>
<p>
~IF［
次のいずれかの結果 ~EQ `阻止される^i
］…
</p>
		<ul>
			<li>
`要請の~fetchingは，不良~portに因り阻止されるべきか？$( %要請 )
</li>
			<li>
`要請の~fetchingは，混在d内容として阻止されるべきか？＠~MIXED-CONTENT#should-block-fetch$( %要請 )
</li>
			<li>
`要請は~CSPにより阻止されるべきか？＠~CSP3#should-block-request$( %要請 )
</li>
		</ul>
<p>
…ならば
⇒
%応答 ~SET `~network~error$
</p>

◎
If should request be blocked due to a bad port, should fetching request be blocked as mixed content, or should request be blocked by Content Security Policy returns blocked, then set response to a network error.
</li>
	<li>
~IF［
%要請 の`~referrer施策$rq ~EQ 空~文字列
］
⇒
%要請 の`~referrer施策$rq ~SET %要請 の`施策~容器$rqの`~referrer施策$pC
◎
If request’s referrer policy is the empty string, then set request’s referrer policy to request’s policy container’s referrer policy.
</li>
	<li>
<p>
~IF［
%要請 の`~referrer$rq ~NEQ `no-referrer^l
］
⇒
%要請 の`~referrer$rq ~SET
%要請 の`~referrerを決定-$した結果
`REFERRER$r
◎
If request’s referrer is not "no-referrer", then set request’s referrer to the result of invoking determine request’s referrer. [REFERRER]
</p>

<p class="note">注記：
`~referrer施策^cite 仕様にて言明されたとおり、
~UAは，%要請 の`~referrer$rqに対し［
それを常に `no-referrer^l で上書きする／
そこには より敏感でない情報を公開する
］~optionを末端-利用者に供せる。
◎
As stated in Referrer Policy, user agents can provide the end user with options to override request’s referrer to "no-referrer" or have it expose less sensitive information.
</p>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
Set request’s current URL’s scheme to "https" if all of the following conditions are true:
</p>
		<ul>
			<li>
%要請 の`現在の~URL$rqの`~scheme$url ~EQ `http^l
◎
request’s current URL’s scheme is "http"
</li>
			<li>
%要請 の`現在の~URL$rqの`~host$urlは`~domain$urlである
◎
request’s current URL’s host is a domain
</li>
			<li>
%要請 の`現在の~URL$rqの`~host$urlの`公共~接尾辞$ ~NIN { `localhost^l, `localhost.^l }
◎
request’s current URL’s host’s public suffix is not "localhost" or "localhost."
</li>
			<li>
<p>
~OR↓：
◎
↓</p>
				<ul>
					<li>
<p>
%要請 の`現在の~URL$rqの`~host$urlを
`HSTS$r `§ Known HSTS Host Domain Name Matching＠~RFCx/rfc6797#section-8.2$en
に従って照合した結果は、
次のいずれかである：
</p>

<ul lang="en">
<li>superdomain match with an asserted `includeSubDomains^dir directive
<li>congruent match (with or without an asserted `includeSubDomains^dir directive)
</ul>

◎
Matching request’s current URL’s host per Known HSTS Host Domain Name Matching results in either a superdomain match with an asserted includeSubDomains directive or a congruent match (with or without an asserted includeSubDomains directive) [HSTS];＼
</li>
					<li>
<p>
%要請 用の~DNS解決は、
`SVCB$r `§ HTTP Strict Transport Security＠https://datatracker.ietf.org/doc/html/draft-ietf-dnsop-svcb-https#section-9.5$en
に従って，合致している~HTTPS-RR【~HTTPS資源~record】を見出した
◎
or DNS resolution for the request finds a matching HTTPS RR per section 9.5 of [SVCB]. [HSTS] [SVCB]
</p>

<p class="note">注記：
すべての~DNS演算は，一般に`実装定義$なので、
~DNS解決が~HTTPS-RRを包含するか否かが どう決定されるかも`実装定義$になる。
~DNS演算は，伝統的に`接続を得する$よう試みるまで遂行されないので、
~UAは，~DNS演算を［
もっと早くに遂行する／
局所~DNS~cacheに諮る／
~fetch~algo内の後の方まで待機する
］必要があるかもしれない
— その結果， %要請 の`現在の~URL$rqの`~scheme$urlを変更する必要を発見した際には、
~logicを遡って解きほぐすことにもなり得る。
◎
As all DNS operations are generally implementation-defined, how it is determined that DNS resolution contains an HTTPS RR is also implementation-defined. As DNS operations are not traditionally performed until attempting to obtain a connection, user agents might need to perform DNS operations earlier, consult local DNS caches, or wait until later in the fetch algorithm and potentially unwind logic on discovering the need to change request’s current URL’s scheme.
</p>
					</li>
				</ul>
			</li>
		</ul>
<p>
…ならば
⇒
%要請 の`現在の~URL$rqの`~scheme$url ~SET `https^l
◎
↑</p>
	</li>
	<li>
<p>
~IF［
%再帰的か ~EQ ~F
］：
</p>
		<ol>
			<li class="algo">
この段は、
`並列的$に走らす
⇒
~GOTO `~main~fetchの継続^i
</li>
			<li>
~RET
</li>
		</ol>
◎
If recursive is false, then run the remaining steps in parallel.
</li>
	<li>
<p>
`~main~fetchの継続^i
◎
↑</p>

<p>
~IF［
%応答 ~EQ ~NULL
］
⇒
%応答 ~SET 次の手続きを走らせた結果
◎
If response is null, then set response to the result of running＼
</p>

<div class="algo">
<p>
手続きは：
◎
the steps corresponding to the first matching statement:
</p>
		<ol>
			<li>
<p>
~IF［
%~fetch~params の`~preloadされる応答の候補$fP ~NEQ ~NULL
］：
◎
fetchParams’s preloaded response candidate is non-null
</p>
				<ol>
					<li>
次が満たされるまで待機する
⇒
%~fetch~params の`~preloadされる応答の候補$fP ~NEQ `pending^l
◎
Wait until fetchParams’s preloaded response candidate is not "pending".
</li>
					<li>
~Assert：
%~fetch~params の`~preloadされる応答の候補$fPは`応答$である
◎
Assert: fetchParams’s preloaded response candidate is a response.
</li>
					<li>
~RET %~fetch~params の`~preloadされる応答の候補$fP
◎
Return fetchParams’s preloaded response candidate.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
［
%要請 の`現在の~URL$rqの`生成元$
~EQ`生成元$sub
%要請 の`生成元$rq
］~AND［
%要請 の`応答~tainting$rq ~EQ `basic^l
］
◎
request’s current URL’s origin is same origin with request’s origin, and request’s response tainting is "basic"
</li>
					<li>
%要請 の`現在の~URL$rqの`~scheme$url ~EQ `data^l
◎
request’s current URL’s scheme is "data"
</li>
					<li>
%要請 の`~mode$rq ~IN { `navigate^l, `websocket^l }
◎
request’s mode is "navigate" or "websocket"
</li>
				</ul>
<p>
…ならば：
</p>
				<ol>
					<li>
%要請 の`応答~tainting$rq ~SET `basic^l
◎
Set request’s response tainting to "basic".
</li>
					<li>
~RET `~scheme~fetch$( %~fetch~params )
◎
Return the result of running scheme fetch given fetchParams.
</li>
				</ol>

<p class="note">注記：
~HTMLは、［
`~scheme$url ~EQ `data^l
］なる`~URL$から作成された どの［
文書 ／ ~worker
］に対しても，一意かつ`不透明な生成元$をアテガう。
~swは、［
`~scheme$url ~IN `~HTTP_S~scheme$
］なる`~URL$からのみ作成される。
`HTML$r
`SW$r
◎
HTML assigns any documents and workers created from URLs whose scheme is "data" a unique opaque origin. Service workers can only be created from URLs whose scheme is an HTTP(S) scheme. [HTML] [SW]
</p>
			</li>
			<li>
~IF［
%要請 の`~mode$rq ~EQ `same-origin^l
］
⇒
~RET `~network~error$
◎
request’s mode is "same-origin"
• Return a network error.
</li>
			<li>
<p>
~IF［
%要請 の`~mode$rq ~EQ `no-cors^l
］：
◎
request’s mode is "no-cors"
</p>
				<ol>
					<li>
~IF［
%要請 の`~redirect~mode$rq ~NEQ `follow^l
］
⇒
~RET `~network~error$
◎
If request’s redirect mode is not "follow", then return a network error.
</li>
					<li>
%要請 の`応答~tainting$rq ~SET `opaque^l
◎
Set request’s response tainting to "opaque".
</li>
					<li>
~RET `~scheme~fetch$( %~fetch~params )
◎
Return the result of running scheme fetch given fetchParams.
</li>
				</ol>
			</li>
			<li>
~IF［
%要請 の`現在の~URL$rqの`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~RET `~network~error$
◎
request’s current URL’s scheme is not an HTTP(S) scheme
• Return a network error.
</li>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
%要請 の`~CORS予行を利用するか$rq ~EQ ~T
◎
request’s use-CORS-preflight flag is set
</li>
					<li>
［
%要請 の`安全でない要請か$rq ~EQ ~T
］~AND［［
%要請 の`~method$rqは `~CORS安全とされる~method$でない
］~OR［
`~CORS安全でない要請~header名たち$( %要請 の`~header~list$rq ) は空でない
］］
◎
request’s unsafe-request flag is set and either request’s method is not a CORS-safelisted method or CORS-unsafe request-header names with request’s header list is not empty
</li>
				</ul>
<p>
…ならば：
</p>
				<ol>
					<li>
%要請 の`応答~tainting$rq ~SET `cors^l
◎
Set request’s response tainting to "cors".
</li>
					<li>
%~CORS予行~付き応答 ~LET `~HTTP~fetch$( %~fetch~params, ~T )
◎
Let corsWithPreflightResponse be the result of running HTTP fetch given fetchParams and true.
</li>
					<li>
~IF［
%~CORS予行~付き応答 は`~network~error$である
］
⇒
`~cache~entryを~clearする$( %要請 )
◎
If corsWithPreflightResponse is a network error, then clear cache entries using request.
</li>
					<li>
~RET %~CORS予行~付き応答
◎
Return corsWithPreflightResponse.
</li>
				</ol>
			</li>
			<li>
%要請 の`応答~tainting$rq ~SET `cors^l
◎
Otherwise
• Set request’s response tainting to "cors".
</li>
			<li>
~RET `~HTTP~fetch$( %~fetch~params )
◎
• Return the result of running HTTP fetch given fetchParams.
</li>
		</ol>
</div>
	</li>
	<li>
~IF［
%再帰的か ~EQ ~T
］
⇒
~RET %応答
◎
If recursive is true, then return response.
</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
%応答 は`絞込み応答$でない
］：
◎
If response is not a network error and response is not a filtered response, then:
</p>
		<ol>
			<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］：
◎
If request’s response tainting is "cors", then:
</p>
				<ol>
					<li>
%~header名~群 ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Expose-Headers$h )
◎
Let headerNames be the result of extracting header list values given `Access-Control-Expose-Headers` and response’s header list.
</li>
					<li>
<p>
~IF［
%~header名~群 ~NIN { ~NULL, `失敗^i }
］：
◎
↓</p>
						<ol>
							<li>
~IF［
%要請 の`資格証~mode$rq ~NEQ `include^l
］~AND［
`*^bl ~IN %~header名~群
］
⇒
%応答 の`~CORSに公開される~header名~list$rs ~SET
%応答 の`~header~list$rs内の各`~header$の`名前$hdたちが成す~list
— ここで、
各~名前は，~list内で一意にする
◎
If request’s credentials mode is not "include" and headerNames contains `*`, then set response’s CORS-exposed header-name list to all unique header names in response’s header list.
</li>
							<li>
<p>
~ELSE
⇒
%応答 の`~CORSに公開される~header名~list$rs ~SET %~header名~群
◎
Otherwise, if headerNames is non-null or failure, then set response’s CORS-exposed header-name list to headerNames.
</p>

<p class="note">注記：
この時点でも， %~header名~群 のいずれかは `*^bl であり得るが、
合致する`~header$は［
`名前$hd ~EQ `*^bl
］を満たすものに限られることになる。
◎
One of the headerNames can still be `*` at this point, but will only match a header whose name is `*`.
</p>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
%応答 ~SET
%応答 を`内部~応答$とする`絞込み応答$であって，
%要請 の`応答~tainting$rqに応じて 次で与えられるもの：
◎
Set response to the following filtered response with response as its internal response, depending on request’s response tainting:
</p>

				<dl class="switch compact">
					<dt>`basic^l</dt>
					<dd>
`基本~絞込み応答$
◎
basic filtered response
</dd>

					<dt>`cors^l</dt>
					<dd>
`~CORS絞込み応答$
◎
CORS filtered response
</dd>

					<dt>`opaque^l</dt>
					<dd>
`不透明な絞込み応答$
◎
opaque filtered response
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
%内部~応答 ~LET %応答 に応じて
⇒＃
`~network~error$であるならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Let internalResponse be response, if response is a network error; otherwise response’s internal response.
</li>
	<li>
<p>
~IF［
%内部~応答 の`~URL~list$rsは`空$である
］
⇒
%内部~応答 の`~URL~list$rs ~SET %要請 の`~URL~list$rqを`~cloneする$
◎
If internalResponse’s URL list is empty, then set it to a clone of request’s URL list.
</p>

<p class="note">注記：
`応答$の`~URL~list$rsは、
空になり得る
— 例： `about:^c ~URLを~fetchするとき。
◎
A response’s URL list can be empty, e.g., when fetching an about: URL.
</p>
	</li>
	<li>
~IF［
`要請の生成元は~taintされたか？$( %要請 ) ~EQ ~T
］
⇒
%内部~応答 の`非同一-生成元~redirectはあるか$rs ~SET ~T
◎
If request has a redirect-tainted origin, then set internalResponse’s has-cross-origin-redirects to true.
</li>
	<li>
~IF［
%要請 の`計時許容に失敗したか$rq ~EQ ~F
］
⇒
%内部~応答 の`計時許容に合格したか$rs ~SET ~T
◎
If request’s timing allow failed flag is unset, then set internalResponse’s timing allow passed flag.
</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
次のいずれかの結果 ~EQ `阻止される^i
］…
◎
If response is not a network error and any of the following returns blocked
</p>
		<ul>
			<li>
`要請に対する応答は，混在d内容として阻止されるべきか？＠~MIXED-CONTENT#should-block-response$( %要請, %内部~応答 )
◎
should internalResponse to request be blocked as mixed content
</li>
			<li>
`要請に対する応答は，~CSPにより阻止されるべきか？＠~CSP3#should-block-response$( %要請, %内部~応答 )
◎
should internalResponse to request be blocked by Content Security Policy
</li>
			<li>
`要請に対する応答は，~MIME型に因り阻止されるべきか？＠#should-response-to-request-be-blocked-due-to-mime-type?$( %要請, %内部~応答 )
◎
should internalResponse to request be blocked due to its MIME type
</li>
			<li>
`要請に対する応答は，~nosniffに因り阻止されるべきか？＠#should-response-to-request-be-blocked-due-to-nosniff?$( %要請, %内部~応答 )
◎
should internalResponse to request be blocked due to nosniff
</li>
		</ul>
<p>
…ならば
⇒
( %応答, %内部~応答 ) ~SET ( `~network~error$, `~network~error$ )
【！同一の個？ 】
◎
then set response and internalResponse to a network error.
</p>
	</li>
	<li>
<p>
~IF［
%応答 の`種別$rs ~EQ `opaque^l
］~AND［
%内部~応答 の`状態s$rs ~EQ `206$st
］~AND［
%内部~応答 の`範囲が要請されたか$rs ~EQ ~T
］~AND［
%要請 の`~header~list$rq内に［
`Range$h を`名前に持つ~header$
］は無い
］
⇒＃
%応答 ~SET `~network~error$；
%内部~応答 ~SET `~network~error$
◎
If response’s type is "opaque", internalResponse’s status is 206, internalResponse’s range-requested flag is set, and request’s header list does not contain `Range`, then set response and internalResponse to a network error.
</p>

<div class="note">
<p>注記：
伝統的に，~APIは、
範囲が要請されなかった場合でも範囲~付き応答を受容する。
この段は、［
過去の範囲~付き要請からの部分的~応答
］が，範囲~要請を為さなかった~APIに供されることを防止する。
◎
Traditionally, APIs accept a ranged response even if a range was not requested. This prevents a partial response from an earlier ranged request being provided to an API that did not make a range request.
</p>

<details>
<summary>
この段は、
次のような攻撃を防止する：
◎
Further details
◎
The above steps prevent the following attack:
</summary>

<p>
~media要素を利用して，非同一-生成元~HTML資源のある範囲が要請されたとする。
これは妥当でない~mediaになるが、
応答の~cloneへの参照は，~sw内に維持され得る。
これは、
後で~script要素の~fetchに対する応答として利用され得る。
部分的~応答が妥当な~JSであった場合（一体としての資源はそうでなくとも）、
それを実行すると私的~dataが漏洩されることになる。
◎
A media element is used to request a range of a cross-origin HTML resource. Although this is invalid media, a reference to a clone of the response can be retained in a service worker. This can later be used as the response to a script element’s fetch. If the partial response is valid JavaScript (even though the whole resource is not), executing it would leak private data.
</p>
</details>
</div>

	</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［［
%要請 の`~method$rq ~IN { `HEAD$hm, `CONNECT$hm }
］~OR［
%内部~応答 の`状態s$rs
は `~null本体~状態s$である
］］
⇒
%内部~応答 の`本体$rs ~SET ~NULL
— 以降、
本体への~enqueueはすべて~~無視する
◎
If response is not a network error and either request’s method is `HEAD` or `CONNECT`, or internalResponse’s status is a null body status, set internalResponse’s body to null and disregard any enqueuing toward it (if any).
</p>

<p class="note">注記：
これは、
~HTTPに違反する~server用に ~errorの取扱いを標準~化する。
◎
This standardizes the error handling for servers that violate HTTP.
</p>
	</li>
	<li>
<p>
~IF［
%要請 の`完全性~metadata$rq ~NEQ 空~文字列
］：
◎
If request’s integrity metadata is not the empty string, then:
</p>
		<ol>
			<li class="algo">
%本体~errorの処理n ~LET 次を走らす手続き
⇒
`~fetch応答を引渡す$( %~fetch~params, `~network~error$ )
◎
Let processBodyError be this step: run fetch response handover given fetchParams and a network error.
</li>
			<li>
~IF［
%応答 の`本体$rs ~EQ ~NULL
］
⇒＃
%本体~errorの処理n()；
~RET
◎
If response’s body is null, then run processBodyError and abort these steps.
</li>
			<li class="algo">
<p>
%本体の処理n ~LET 所与の
( %~byte列 )
に対し，次を走らす手続き：
◎
Let processBody given bytes be these steps:
</p>
				<ol>
					<li>
~IF［
`応答は~metadata~listに合致するか？$( %~byte列, %要請 の`完全性~metadata$rq ) ~EQ ~F
`SRI$r
］
⇒＃
%本体~errorの処理n()；
~RET
◎
If bytes do not match request’s integrity metadata, then run processBodyError and abort these steps. [SRI]
</li>
					<li>
%応答 の`本体$rs ~SET `~byte列を本体として取得する$( %~byte列 )
◎
Set response’s body to bytes as a body.
</li>
					<li>
`~fetch応答を引渡す$( %~fetch~params, %応答 )
◎
Run fetch response handover given fetchParams and response.
</li>
				</ol>
			</li>
			<li>
`本体を全部的に読取る$( ↓ )
⇒＃
%応答 の`本体$rs,
%本体の処理n,
%本体~errorの処理n
◎
Fully read response’s body given processBody and processBodyError.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
`~fetch応答を引渡す$( %~fetch~params, %応答 )
◎
Otherwise, run fetch response handover given fetchParams and response.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~fetch応答を引渡す@
~algoは、
所与の
( `~fetch~params$ %~fetch~params, `応答$ %応答 )
に対し：
◎
The fetch response handover, given a fetch params fetchParams and a response response, run these steps:
</p>
<ol>
	<li>
%計時~報 ~LET %~fetch~params の`計時~報$fP
◎
Let timingInfo be fetchParams’s timing info.
</li>
	<li>
<p>
~IF［
%応答 は`~network~error$でない
］~AND［
%~fetch~params の`要請$fPの`~client$rqは`~secureな文脈$enVである
］
⇒
%計時~報 の`~server計時~header群$fT ~SET 
`~header~listから値を取得して復号して分割する$( %応答 の`内部~応答$の`~header~list$rs, `Server-Timing$h )
◎
If response is not a network error and fetchParams’s request’s client is a secure context, then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting `Server-Timing` from response’s internal response’s header list.
</p>

<p class="note">注記：
%応答 の`内部~応答$を利用することは、
安全である
— `Server-Timing$h ~headerの~dataを公開すること【するか否か】は、
`Timing-Allow-Origin$h ~headerを通して防護されるので。
◎
Using _response_’s internal response is safe as exposing `Server-Timing` header data is guarded through the `Timing-Allow-Origin` header.
</p>

<p>
~UAは、
`Server-Timing$h ~headerを~secureでない文脈からの要請にも公開するものと裁定してもヨイ。
◎
The user agent may decide to expose `Server-Timing` headers to non-secure contexts requests as well.
</p>
	</li>
	<li class="algo">
<p>
%応答の本体~終了~時の処理n ~LET 次を走らす手続き：
◎
Let processResponseEndOfBody be the following steps:
</p>
		<ol>
			<li>
%安全でない終了~時刻 ~LET `安全でない共有される現在の時刻$
◎
Let unsafeEndTime be the unsafe shared current time.
</li>
			<li>
~IF［
%~fetch~params の`要請$fPの`行先$rq ~EQ `document^l
］
⇒
%~fetch~params の`制御器$fPの`全部的な計時~報$fC ~SET %~fetch~params の`計時~報$fP
◎
If fetchParams’s request’s destination is "document", then set fetchParams’s controller’s full timing info to fetchParams’s timing info.
</li>
			<li class="algo">
<p>
%~fetch~params の`制御器$fPの`計時を報告する手続き$fC ~SET 所与の
( `大域~obj$ %大域~obj )
に対し，次を走らす手続き：
◎
Set fetchParams’s controller’s report timing steps to the following steps given a global object global:
</p>
				<ol>
					<li>
~IF［
%~fetch~params の`要請$fPの`~URL$rqの`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~RET
◎
If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.
</li>
					<li>
%計時~報 の`終了~時刻$fT ~SET `相対的な高分解能~時刻$( %安全でない終了~時刻, %大域~obj )
◎
Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.
</li>
					<li>
%~cache状態 ~LET %応答 の`~cache状態$rs
◎
Let cacheState be response’s cache state.
</li>
					<li>
%本体~報 ~LET %応答 の`本体~報$rs
◎
Let bodyInfo be response’s body info.
</li>
					<li>
<p>
~IF［
%応答 の`計時許容に合格したか$rs ~EQ ~F
］
⇒＃
%計時~報 ~SET `不透明な計時~報を作成する$( %計時~報 ),
%~cache状態 ~SET 空~文字列
◎
If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an opaque timing info for timingInfo and set cacheState to the empty string.
</p>

<p class="note">注記：
この段は、
%応答 が`~network~error$である事例を受持つ。
◎
This covers the case of response being a network error.
</p>
					</li>
					<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
↓</li>
					<li>
%応答~状態s ~LET 0
◎
Let responseStatus be 0.
</li>
					<li>
<p>
~IF［
%要請 の`~mode$rq ~NEQ `navigate^l
］~OR［
%応答 の`非同一-生成元~redirectはあるか$rs ~EQ ~F
］：
◎
If fetchParams’s request’s mode is not "navigate" or response’s has-cross-origin-redirects is false:
</p>
						<ol>
							<li>
%応答~状態s ~SET %応答 の`状態s$rs
◎
Set responseStatus to response’s status.
</li>
							<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
◎
Let mimeType be the result of extracting a MIME type from response’s header list.
</li>
							<li>
~IF［
%~MIME型 ~NEQ `失敗^i
］
⇒
%本体~報 の`内容~型$fT ~SET `~supportされる~MIME型を最小~化する$( %~MIME型 )
◎
If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.
</li>
						</ol>
					</li>
					<li>
~IF［
%要請 の`起動元~種別$rq ~NEQ ~NULL
］
⇒
`資源~計時を~markする$( ↓ )
⇒＃
%計時~報,
%要請 の`~URL$rq,
%要請 の`起動元~種別$rq,
%大域~obj,
%~cache状態,
%本体~報,
%応答~状態s
◎
If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo, fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo, and responseStatus.
</li>
				</ol>
			</li>
			<li class="algo">
<p>
%応答の本体~終了~時の処理n用の~task ~LET 次の手続き：
◎
Let processResponseEndOfBodyTask be the following steps:
</p>
				<ol>
					<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
↓</li>
					<li>
%要請 の`済んだか$rq ~SET ~T
◎
Set fetchParams’s request’s done flag.
</li>
					<li>
~IF［
%~fetch~params の`応答の本体~終了~時の処理n$fP ~NEQ ~NULL
］
⇒
%~fetch~params の`応答の本体~終了~時の処理n$fP( %応答 )
◎
If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process response end-of-body given response.
</li>
					<li>
~IF［
%要請 の`起動元~種別$rq ~NEQ ~NULL
］~AND［
%要請 の`~client$rqの`大域~obj$enV ~EQ %~fetch~params の`~taskの行先$fP
］
⇒
%~fetch~params の`制御器$fPの`計時を報告する手続き$fC( %要請 の`~client$rqの`大域~obj$enV )
◎
If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s global object is fetchParams’s task destination, then run fetchParams’s controller’s report timing steps given fetchParams’s request’s client’s global object.
</li>
				</ol>
			</li>
			<li>
`~fetch~taskを~queueする$( %応答の本体~終了~時の処理n用の~task, %~fetch~params の`~taskの行先$fP )
◎
Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~fetch~params の`応答の処理n$fP ~NEQ ~NULL
］
⇒
`~fetch~taskを~queueする$( 次の手続き, %~fetch~params の`~taskの行先$fP )
</p>

<div class="algo">
手続きは
⇒
%~fetch~params の`応答の処理n$fP( %応答 )
</div>
◎
If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s process response given response, with fetchParams’s task destination.
</li>
	<li>
%内部~応答 ~LET %応答 に応じて
⇒＃
`~network~error$であるならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Let internalResponse be response, if response is a network error; otherwise response’s internal response.
</li>
	<li>
~IF［
%内部~応答 の`本体$rs ~EQ ~NULL
］
⇒
%応答の本体~終了~時の処理n()
◎
If internalResponse’s body is null, then run processResponseEndOfBody.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%形式変換~stream ~LET 新たな `TransformStream$I
◎
Let transformStream be a new TransformStream.
</li>
			<li class="algo">
%恒等変換~algo ~LET 所与の
( %~chunk )
に対し，次を走らす~algo
⇒
%形式変換~stream に`~chunkを~enqueueする$TS( %~chunk )
◎
Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.
</li>
			<li>
%形式変換~stream を`設定しておく$TS
— 次を与える下で
⇒＃
`形式変換~algo^i ~SET %恒等変換~algo,
`書出n~algo^i ~SET %応答の本体~終了~時の処理n
◎
Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm set to processResponseEndOfBody.
</li>
			<li>
%内部~応答 の`本体$rsの`~stream$bd ~SET %内部~応答 の`本体$rs の`~stream$bdを %形式変換~stream を`通して~pipeする$RS
◎
Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.
</li>
</ol>

<p class="note">注記：
この `TransformStream$I は、
当の~streamが終端に達したとき通知を受信する目的に必要になる
— それ以外については`恒等変換~stream$になる。
◎
This TransformStream is needed for the purpose of receiving a notification when the stream reaches its end, and is otherwise an identity transform stream.
</p>
	</li>
	<li>
<p>
~IF［
%~fetch~params の`応答の本体を消費する処理n$fP ~NEQ ~NULL
］：
◎
If fetchParams’s process response consume body is non-null, then:
</p>
		<ol>
			<li class="algo">
%本体の処理n ~LET
所与の
( %~NULLまたは~byte列 )
に対し，次を走らす手続き
⇒
%~fetch~params の`応答の本体を消費する処理n$fP( %応答, %~NULLまたは~byte列 )
◎
Let processBody given nullOrBytes be this step: run fetchParams’s process response consume body given response and nullOrBytes. 
</li>
			<li class="algo">
%本体~errorの処理n ~LET 次を走らす手続き
⇒
%~fetch~params の`応答の本体を消費する処理n$fP( %応答, `失敗^i )
◎
Let processBodyError be this step: run fetchParams’s process response consume body given response and failure.
</li>
			<li>
<p>
~IF［
%内部~応答 の`本体$rs ~EQ ~NULL
］
⇒
`~fetch~taskを~queueする$( 次の手続き, %~fetch~params の`~taskの行先$fP )
</p>

<div class="algo">
手続きは
⇒
%本体の処理n( ~NULL )
</div>
◎
If internalResponse’s body is null, then queue a fetch task to run processBody given null, with fetchParams’s task destination.
</li>
			<li>
~ELSE
⇒
`本体を全部的に読取る$( ↓ )
⇒＃
%内部~応答 の`本体$rs,
%本体の処理n,
%本体~errorの処理n,
%~fetch~params の`~taskの行先$fP
◎
Otherwise, fully read internalResponse’s body given processBody, processBodyError, and fetchParams’s task destination.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="scheme-fetch">
<h3 title="Scheme fetch">4.2. ~scheme~fetch</h3>

<div class="algo">
<p>
`~scheme~fetch@
を遂行する
~algoは、
所与の
( `~fetch~params$ %~fetch~params )
に対し：
◎
To scheme fetch, given a fetch params fetchParams:
</p>
<ol>
	<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET `適切な~network~error$( %~fetch~params )
◎
If fetchParams is canceled, then return the appropriate network error for fetchParams.
</li>
	<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
Let request be fetchParams’s request.
</li>
	<li>
<p>
%要請 の`現在の~URL$rq の`~scheme$urlに応じて：
◎
Switch on request’s current URL’s scheme and run the associated steps:
</p>
		<dl class="switch">
			<dt>`about^l</dt>
			<dd>
<p>
~IF［
%要請 の`現在の~URL$rqの`~path$url ~EQ 文字列 `blank^l
］
⇒
~RET 新たな`応答$
— その
⇒＃
`状態s~message$rs ~SET `OK^bl,
`~header~list$rs ~SET « ( `Content-Type$h, `text/html;charset=utf-8^bl ) »,
`本体$rs ~SET `~byte列を本体として取得する$( 空な~byte列 )
◎
If request’s current URL’s path is the string "blank", then return a new response whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) », and body is the empty byte sequence as a body.
</p>

<p class="note">注記：
`about:config^l に類する`~URL$は、
`~navi$の間に取扱われ，`~fetch$の文脈~下では`~network~error$になる。
◎
URLs such as "about:config" are handled during navigation and result in a network error in the context of fetching.
</p>
			</dd>

			<dt>`blob^l</dt>
			<dd>
				<ol>
					<li>
%~blob~URL~entry ~LET %要請 の`現在の~URL$rqの`~blob~URL~entry$url `FILEAPI$r
◎
Let blobURLEntry be request’s current URL’s blob URL entry.
</li>
					<li>
<p>
~IF［
%要請 の`~method$rq ~NEQ `GET$hm
］~OR［
%~blob~URL~entry ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If request’s method is not `GET` or blobURLEntry is null, then return a network error. [FILEAPI]
</p>

<p class="note">注記：
`GET^hm `~method$に制約することには、
相互運用可能にする以外に有用な目的はない。
◎
The `GET` method restriction serves no useful purpose other than being interoperable.
</p>
					</li>
					<li>
%要請~環境 ~LET `要請~環境を決定する$( %要請 )
◎
Let requestEnvironment be the result of determining the environment given request.
</li>
					<li>
%~top-levelの~naviか ~LET ~IS［
%要請 の`行先$rq ~EQ `document^l
］
◎
Let isTopLevelNavigation be true if request’s destination is "document"; otherwise, false.
</li>
					<li>
~IF［
%~top-levelの~naviか ~EQ ~F
］~AND［
%要請~環境 ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If isTopLevelNavigation is false and requestEnvironment is null, then return a network error.
</li>
					<li>
%~naviまたは環境 ~LET %~top-levelの~naviか に応じて
⇒＃
~T ならば `navigation^l ／
~F ならば %要請~環境
◎
Let navigationOrEnvironment be the string "navigation" if isTopLevelNavigation is true; otherwise, requestEnvironment.
</li>
					<li>
%~blob ~LET `~blob~objを得する$( %~blob~URL~entry, %~naviまたは環境 )
◎
Let blob be the result of obtaining a blob object given blobURLEntry and navigationOrEnvironment.
</li>
					<li>
~IF［
%~blob は `Blob$I ~objでない
］
⇒
~RET `~network~error$
◎
If blob is not a Blob object, then return a network error.
</li>
					<li>
%応答 ~LET 新たな`応答$
◎
Let response be a new response.
</li>
					<li>
%全部的な長さ ~LET %~blob の `size$mF
◎
Let fullLength be blob’s size.
</li>
					<li>
%直列化した全部的な長さ ~LET `同型に符号化する$( `整数を直列化する$( %全部的な長さ ) )
◎
Let serializedFullLength be fullLength, serialized and isomorphic encoded.
</li>
					<li>
%型 ~LET %~blob の `type$mF
◎
Let type be blob’s type.
</li>
					<li>
<p>
~IF［
%要請 の`~header~list$rq内に `Range$h を`名前に持つ~header$は在る
］：
◎
If request’s header list does not contain `Range`:
</p>
						<ol>
							<li>
%本体と型 ~LET `本体と型を安全に抽出する$( %~blob )
◎
Let bodyWithType be the result of safely extracting blob.
</li>
							<li>
%応答 の`状態s~message$rs ~SET `OK^bl
◎
Set response’s status message to `OK`.
</li>
							<li>
%応答 の`本体$rs ~SET %本体と型 の`本体$bwT
◎
Set response’s body to bodyWithType’s body.
</li>
							<li>
%応答 の`~header~list$rs ~SET « 次に挙げる~header »
⇒＃
( `Content-Length$h, %直列化した全部的な長さ ),
( `Content-Type$h, %型 )
◎
Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
%応答 の`範囲が要請されたか$rs ~SET ~T
◎
Set response’s range-requested flag.
</li>
							<li>
%範囲~header値 ~LET `~header~listから値を取得する$( %要請 の`~header~list$rq, `Range$h )
◎
Let rangeHeader be the result of getting `Range` from request’s header list.
</li>
							<li>
%範囲~値 ~LET `単純な範囲~header値を構文解析する$( %範囲~header値, ~T )
◎
Let rangeValue be the result of parsing a single range header value given rangeHeader and true.
</li>
							<li>
~IF［
%範囲~値 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If rangeValue is failure, then return a network error.
</li>
							<li>
( %範囲~始端, %範囲~終端 ) ~LET %範囲~値
◎
Let (rangeStart, rangeEnd) be rangeValue.
</li>
							<li>
<p>
~IF［
%範囲~始端 ~EQ ~NULL
］：
◎
If rangeStart is null:
</p>
								<ol>
									<li>
%範囲~始端 ~SET %全部的な長さ ~MINUS %範囲~終端
◎
Set rangeStart to fullLength − rangeEnd.
</li>
									<li>
%範囲~終端 ~SET %範囲~始端 ~PLUS %範囲~終端 ~MINUS 1
◎
Set rangeEnd to rangeStart + rangeEnd − 1.
</li>
								</ol>
							</li>
							<li>
<p>
~ELSE：
◎
Otherwise:
</p>
								<ol>
									<li>
~IF［
%範囲~始端 ~GTE %全部的な長さ
］
⇒
~RET `~network~error$
◎
If rangeStart is greater than or equal to fullLength, then return a network error.
</li>
									<li>
~IF［
%範囲~終端 ~EQ ~NULL
］~OR［
%範囲~終端 ~GTE %全部的な長さ
］
⇒
%範囲~終端 ~SET %全部的な長さ ~MINUS 1
◎
If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set rangeEnd to fullLength − 1.
</li>
								</ol>
							</li>
							<li>
<p>
%切出した~blob ~LET `~blobを切出す$( %~blob, %範囲~始端, %範囲~終端 ~PLUS 1, %型 )
◎
Let slicedBlob be the result of invoking slice blob given blob, rangeStart, rangeEnd + 1, and type.
</p>

<p class="note">注記：
`Range$h【！range】 ~header用の`~byte範囲＠~HTTPsem#byte-range$は，終端を含むが、
`~blobを切出す$ ~algoの入力~範囲は，そうでない
— %範囲~終端 に 1 を加えているのは、
そのためである。
◎
A range header denotes an inclusive byte range, while the slice blob algorithm input range does not. To use the slice blob algorithm, we have to increment rangeEnd.
</li>
							<li>
%切出した本体と型 ~LET `本体と型を安全に抽出する$( %切出した~blob )
◎
Let slicedBodyWithType be the result of safely extracting slicedBlob.
</li>
							<li>
%応答 の`本体$rs ~SET %切出した本体と型 の`本体$bwT
◎
Set response’s body to slicedBodyWithType’s body.
</li>
							<li>
%直列化した切出した長さ ~LET `同型に符号化する$( `整数を直列化する$( %切出した~blob の `size$mF ) )
◎
Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.
</li>
							<li>
%内容~範囲 ~LET `内容~範囲を築く$( %範囲~始端, %範囲~終端, %全部的な長さ )
◎
Let contentRange be the result of invoking build a content range given rangeStart, rangeEnd, and fullLength.
</li>
							<li>
%応答 の`状態s$rs ~SET `206$st
◎
Set response’s status to 206.
</li>
							<li>
%応答 の`状態s~message$rs ~SET `Partial Content^bl
◎
Set response’s status message to `Partial Content`.
</li>
							<li>
%応答 の`~header~list$rs ~SET « 次に挙げる~header »
⇒＃
( `Content-Length$h, %直列化した切出した長さ ),
( `Content-Type$h, %型 ),
( `Content-Range$h, %内容~範囲 )
◎
Set response’s header list to « (`Content-Length`, serializedSlicedLength), (`Content-Type`, type), (`Content-Range`, contentRange) ».
</li>
						</ol>
					</li>
					<li>
~RET %応答
◎
Return response.
</li>
				</ol>
			</dd>

			<dt>`data^l</dt>
			<dd>
				<ol>
					<li>
%~dataURL構造体 ~LET `~data_URL処理器$( %要請 の`現在の~URL$rq )
◎
Let dataURLStruct be the result of running the data: URL processor on request’s current URL.
</li>
					<li>
~IF［
%~dataURL構造体 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If dataURLStruct is failure, then return a network error.
</li>
					<li>
%~MIME型 ~LET `~MIME型を~byte列に直列化する$( %~dataURL構造体 の`~MIME型$dU )
◎
Let mimeType be dataURLStruct’s MIME type, serialized.
</li>
					<li>
~RET 新たな`応答$
— その
⇒＃
`状態s~message$rs ~SET `OK^bl,
`~header~list$rs ~SET « ( `Content-Type$h, %~MIME型 ) »,
`本体$rs ~SET `~byte列を本体として取得する$( %~dataURL構造体 の`本体$dU )
◎
Return a new response whose status message is `OK`, header list is « (`Content-Type`, mimeType) », and body is dataURLStruct’s body as a body.
</li>
				</ol>
			</dd>

			<dt>`file^l</dt>
			<dd>
今の所、
あいにく `file:^c `~URL$については，読者への宿題として残される。
◎
For now, unfortunate as it is, file: URLs are left as an exercise for the reader.
</dd>
			<dd>
疑わしい場合は`~network~error$を返すこと。
◎
When in doubt, return a network error.
</dd>

			<dt>`~HTTP_S~scheme$</dt>
			<dd>
~RET `~HTTP~fetch$( %~fetch~params )
◎
Return the result of running HTTP fetch given fetchParams.
</dd>
		</dl>
	</li>
	<li>
~RET `~network~error$
◎
Return a network error.
</li>
</ol>
</div>

<div class="algo">
<p>
`要請~環境を決定する@
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To determine the environment, given a request request:
</p>
<ol>
	<li>
~IF［
%要請 の`予約-済み~client$rq ~NEQ ~NULL
］
⇒
~RET %要請 の`予約-済み~client$rq
◎
If request’s reserved client is non-null, then return request’s reserved client.
</li>
	<li>
~IF［
%要請 の`~client$rq ~NEQ ~NULL
］
⇒
~RET %要請 の`~client$rq
◎
If request’s client is non-null, then return request’s client.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>
</div>

		</section>
		<section id="http-fetch">
<h3 title="HTTP fetch">4.3. ~HTTP~fetch</h3>

<div class="algo">
<p>
`~HTTP~fetch@
を遂行する
~algoは、
所与の
( `~fetch~params$ %~fetch~params, 真偽値 %~CORS予行を為すか（省略時は ~F ） )
に対し：
◎
To HTTP fetch, given a fetch params fetchParams and an optional boolean makeCORSPreflight (default false), run these steps:
</p>
<ol>
	<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
Let request be fetchParams’s request.
</li>
	<li>
%応答 ~LET ~NULL
◎
Let response and internalResponse be null.
</li>
	<li>
%内部~応答 ~LET ~NULL
◎
↑</li>
	<li>
<p>
~IF［
%要請 の`~sw~mode$rq ~EQ `all^l
］：
◎
If request’s service-workers mode is "all", then:
</p>
		<ol>
			<li>
%~sw用の要請 ~LET `要請を~cloneする$( %要請 )
◎
Let requestForServiceWorker be a clone of request.
</li>
			<li>
<p>
~IF［
%~sw用の要請 の`本体$ ~NEQ ~NULL
］：
◎
If requestForServiceWorker’s body is non-null, then:
</p>
				<ol>
					<li>
%形式変換~stream ~LET 新たな `TransformStream$I
◎
Let transformStream be a new TransformStream.
</li>
					<li class="algo">
<p>
%形式変換~algo ~LET 所与の
( %~chunk )
に対し，次を走らす手続き：
◎
Let transformAlgorithm given chunk be these steps:
</p>
						<ol>
							<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET
◎
If fetchParams is canceled, then abort these steps.
</li>
							<li>
~IF［
%~chunk は `Uint8Array$I ~objでない
］
⇒
`~fetchを終了する$( %~fetch~params の`制御器$fP )
◎
If chunk is not a Uint8Array object, then terminate fetchParams’s controller.
</li>
							<li>
<p>
~ELSE
⇒
%形式変換~stream に`~chunkを~enqueueする$RS( %~chunk )
◎
Otherwise, enqueue chunk in transformStream.＼
</p>

<p>
この段においては、
~UAは，次を行ってもヨイ
⇒＃
~chunkを`実装定義$な実用的な~sizeに分割した上で，結果の各`~chunkを~enqueueする$RS／
~chunkたちを`実装定義$な実用的な~sizeに連結した上で，結果の`~chunkを~enqueueする$RS
◎
The user agent may split the chunk into implementation-defined practical sizes and enqueue each of them.＼
The user agent also may concatenate the chunks into an implementation-defined practical size and enqueue it.
</p>
							</li>
						</ol>
					</li>
					<li>
%形式変換~stream を`設定しておく$TS
— 次を与える下で
⇒＃
`形式変換~algo^i ~SET %形式変換~algo
◎
Set up transformStream with transformAlgorithm set to transformAlgorithm.
</li>
					<li>
%~sw用の要請 の`本体$の`~stream$bd ~SET ［
%~sw用の要請 の`本体$の`~stream$bd
］を %形式変換~stream を`通して~pipeする$RS
◎
Set requestForServiceWorker’s body’s stream to the result of requestForServiceWorker’s body’s stream piped through transformStream.
</li>
				</ol>
			</li>
			<li>
%~sw開始~時刻 ~LET `粗化した共有される現在の時刻$( %~fetch~params の`非同一-生成元~能力は隔離されるか$fP )
◎
Let serviceWorkerStartTime be the coarsened shared current time given fetchParams’s cross-origin isolated capability.
</li>
			<li>
%応答 ~SET `~fetchを取扱う$( %~sw用の要請, %~fetch~params の`制御器$fP, %~fetch~params の`非同一-生成元~能力は隔離されるか$fP )
`HTML$r
`SW$r
◎
Set response to the result of invoking handle fetch for requestForServiceWorker, with fetchParams’s controller and fetchParams’s cross-origin isolated capability. [HTML] [SW]
</li>
			<li>
<p>
~IF［
%応答 ~NEQ ~NULL
］：
◎
If response is non-null, then:
</p>
				<ol>
					<li>
%~fetch~params の`計時~報$fPの`最終-~sw開始~時刻$fT ~SET %~sw開始~時刻
◎
Set fetchParams’s timing info’s final service worker start time to serviceWorkerStartTime.
</li>
					<li>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］
⇒
%要請 の`本体$rqを`取消す$RS( `undefined^jv )
◎
If request’s body is non-null, then cancel request’s body with undefined.
</li>
					<li>
%内部~応答 ~SET %応答 に応じて
⇒＃
`絞込み応答$でないならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Set internalResponse to response, if response is not a filtered response; otherwise to response’s internal response.
</li>
					<li>
<p>
~IF［
~OR↓
］…
◎
If one of the following is true
</p>
						<ul>
							<li>
%応答 の`種別$rs ~EQ `error^l
◎
response’s type is "error"
</li>
							<li>
［
%要請 の`~mode$rq ~EQ `same-origin^l
］~AND［
%応答 の`種別$rs ~EQ `cors^l
］
◎
request’s mode is "same-origin" and response’s type is "cors"
</li>
							<li>
［
%要請 の`~mode$rq ~NEQ `no-cors^l
］~AND［
%応答 の`種別$rs ~EQ `opaque^l
］
◎
request’s mode is not "no-cors" and response’s type is "opaque"
</li>
							<li>
［
%要請 の`~redirect~mode$rq ~NEQ `manual^l
］~AND［
%応答 の`種別$rs ~EQ `opaqueredirect^l
］
◎
request’s redirect mode is not "manual" and response’s type is "opaqueredirect"
</li>
							<li>
［
%要請 の`~redirect~mode$rq ~NEQ `follow^l
］~AND［
%応答 の`~URL~list$rsの`~size$ ~GT 1
］
◎
request’s redirect mode is not "follow" and response’s URL list has more than one item.
</li>
						</ul>
<p>
…ならば
⇒
~RET `~network~error$：
◎
then return a network error.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
		<ol>
			<li>
<p>
~IF［
%~CORS予行を為すか ~EQ ~T
］~AND［
~OR↓
］…
◎
If makeCORSPreflight is true and one of these conditions is true:
</p>

				<ul>
					<li>
<p>
［
`~methodも合致している~cache~entry$( %要請, %要請 の`~method$rq ) は空である
］~AND［
~OR↓
］：
</p>
						<ul>
							<li>
%要請 の`~method$rqは `~CORS安全とされる~method$でない
</li>
							<li>
%要請 の`~CORS予行を利用するか$rq ~EQ ~T
</li>
						</ul>
◎
There is no method cache entry match for request’s method using request, and either request’s method is not a CORS-safelisted method or request’s use-CORS-preflight flag is set.
</li>
					<li>
`~CORS安全でない要請~header名たち$( %要請 の`~header~list$rq )
内のある名前に対し
⇒
`~header名も合致している~cache~entry$( %要請, 名前 ) は空である
◎
There is at least one item in the CORS-unsafe request-header names with request’s header list for which there is no header-name cache entry match using request.
</li>
				</ul>
<p>
…ならば：
◎
Then:
</p>
				<ol>
					<li>
%予行~応答 ~LET `~CORS予行~fetch$( %要請 )
◎
Let preflightResponse be the result of running CORS-preflight fetch given request.
</li>
					<li>
~IF［
%予行~応答 は`~network~error$である
］
⇒
~RET %予行~応答
◎
If preflightResponse is a network error, then return preflightResponse.
</li>
				</ol>

<p class="note">注記：
この段は、
`~CORS予行~cache$を検査した上で，相応しい~entryがなければ`~CORS予行~fetch$を遂行し、
成功したならば この~cacheを拡充する。
`~CORS予行~fetch$の目的は、
`~fetch$された資源が`~CORS~protocol$下に~~置かれることを確保することである。
この~cacheは、
`~CORS予行~fetch$の回数を最小限にするためにある。
◎
This step checks the CORS-preflight cache and if there is no suitable entry it performs a CORS-preflight fetch which, if successful, populates the cache. The purpose of the CORS-preflight fetch is to ensure the fetched resource is familiar with the CORS protocol. The cache is there to minimize the number of CORS-preflight fetches.
</p>

			</li>
			<li>
<p>
~IF［
%要請 の`~redirect~mode$rq ~EQ `follow^l
］
⇒
%要請 の`~sw~mode$rq ~SET `none^l
◎
If request’s redirect mode is "follow", then set request’s service-workers mode to "none".
</p>

<p class="note">注記：
（~swとは~~対照的に）~networkから来る~redirectは、
~swには公開されない。
◎
Redirects coming from the network (as opposed to from a service worker) are not to be exposed to a service worker.
<p>
			</li>
			<li>
%内部~応答 ~SET `~HTTP~network-or-cache~fetch$( %~fetch~params )
◎
Set response and internalResponse to the result of running HTTP-network-or-cache fetch given fetchParams.
</li>
			<li>
%応答 ~SET %内部~応答
◎
↑</li>
			<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］~AND［
`~CORS検査$( %要請, %応答 ) ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If request’s response tainting is "cors" and a CORS check for request and response returns failure, then return a network error.
</p>

<p class="note">注記：
`~CORS検査$は、［
`状態s$rs ~IN { `304$st, `407$st } なる`応答$ ／
それが問われる~swからの`応答$
］には適用されないので、
ここで適用される。
◎
As the CORS check is not to be applied to responses whose status is 304 or 407, or responses from a service worker for that matter, it is applied here.
</p>
			</li>
			<li>
~IF［
`~TAO検査$( %要請, %応答 ) ~EQ `失敗^i
］
⇒
%要請 の`計時許容に失敗したか$rq ~SET ~T
◎
If the TAO check for request and response returns failure, then set request’s timing allow failed flag.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`opaque^l ~IN { %要請 の`応答~tainting$rq, %応答 の`種別$rs }
］~AND［
`非同一-生成元~資源~施策~検査$( %要請 の`生成元$rq, %要請 の`~client$rq, %要請 の`行先$rq, %内部~応答 )
~EQ `阻止される^i
］
⇒
~RET `~network~error$
◎
If either request’s response tainting or response’s type is "opaque", and the cross-origin resource policy check with request’s origin, request’s client, request’s destination, and internalResponse returns blocked, then return a network error.
</p>

<p class="note">注記：
`非同一-生成元~資源~施策~検査$は、［
~network／~sw
］から来た応答~用に走る。
これは、
`~CORS検査$とは異なる
— ［
%要請 の`~client$rq,
~sw
］の埋込元~施策は異なり得るので。
◎
The cross-origin resource policy check runs for responses coming from the network and responses coming from the service worker. This is different from the CORS check, as request’s client and the service worker can have different embedder policies.
</p>
	</li>
	<li>
<p>
~IF［
%内部~応答 の`状態s$rsは`~redirect状態s$である
］：
◎
If internalResponse’s status is a redirect status:
</p>
		<ol>
			<li>
<p>
~IF［
%内部~応答 の`状態s$rs ~NEQ `303$st
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
`接続$は~HTTP2を利用している
］
⇒
~UAは `RST_STREAM^c ~frameを伝送してもヨイ
— また，そうすることが奨励される。
◎
If internalResponse’s status is not 303, request’s body is non-null, and the connection uses HTTP/2, then user agents may, and are even encouraged to, transmit an RST_STREAM frame.
</p>

<p class="note">注記：
ある種の~communityにおいては、
`303$st は特別な状態sに帰するとみなされ，除外される。
◎
303 is excluded as certain communities ascribe special status to it.
</p>
			</li>
			<li>
<p>
%要請 の`~redirect~mode$rq に応じて：
◎
Switch on request’s redirect mode:
</p>
				<ul class="switch">
					<li>
`error^l
⇒
%応答 ~SET `~network~error$
◎
"error"
• Set response to a network error.
</li>
					<li>
<p>
`manual^l ：
◎
"manual"
</p>
						<ol>
							<li>
~IF［
%要請 の`~mode$rq ~EQ `navigate^l
］：
<span class="block algo">
%~fetch~params の`制御器$fPの`次回の手動~redirect手続き$fC ~SET 次を走らす手続き
⇒
`~HTTP~redirect~fetch$( %~fetch~params, %応答 )
</span>
◎
If request’s mode is "navigate", then set fetchParams’s controller’s next manual redirect steps to run HTTP-redirect fetch given fetchParams and response.
</li>
							<li>
~ELSE
⇒
%応答 ~SET %内部~応答 を`内部~応答$とする，`不透明~redirect絞込み応答$
◎
Otherwise, set response to an opaque-redirect filtered response whose internal response is internalResponse.
</li>
						</ol>
					</li>
					<li>
`follow^l
⇒
%応答 ~SET `~HTTP~redirect~fetch$( %~fetch~params, %応答 )
◎
"follow"
• Set response to the result of running HTTP-redirect fetch given fetchParams and response.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
~RET %応答
◎
Return response.＼
</p>

<p class="note">注記：
手続きはここで終わるが、
その後も概して，
%内部~応答 の`本体$rsの`~stream$bdには ~byte列が~enqueueされ続ける。
◎
Typically internalResponse’s body’s stream is still being enqueued to after returning.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="http-redirect-fetch">
<h3 title="HTTP-redirect fetch">4.4. ~HTTP~redirect~fetch</h3>

<div class="algo">
<p>
`~HTTP~redirect~fetch@
を遂行する
~algoは、
所与の
( `~fetch~params$ %~fetch~params, `応答$ %応答 )
に対し：
◎
To HTTP-redirect fetch, given a fetch params fetchParams and a response response, run these steps:
</p>
<ol>
	<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
Let request be fetchParams’s request.
</li>
	<li>
%内部~応答 ~LET %応答 に応じて
⇒＃
`絞込み応答$でないならば %応答 ／
~ELSE_ %応答 の`内部~応答$
◎
Let internalResponse be response, if response is not a filtered response; otherwise response’s internal response.
</li>
	<li>
%~Location~URL ~LET `応答の~Location~URLを得る$( %内部~応答, %要請 の`現在の~URL$rqの`素片$url )
◎
Let locationURL be internalResponse’s location URL given request’s current URL’s fragment.
</li>
	<li>
~IF［
%~Location~URL ~EQ ~NULL
］
⇒
~RET %応答
◎
If locationURL is null, then return response.
</li>
	<li>
~IF［
%~Location~URL ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If locationURL is failure, then return a network error.
</li>
	<li>
~IF［
%~Location~URL の`~scheme$urlは`~HTTP_S~scheme$でない
］
⇒
~RET `~network~error$
◎
If locationURL’s scheme is not an HTTP(S) scheme, then return a network error.
</li>
	<li>
~IF［
%要請 の`~redirect回数$rq ~EQ 20
］
⇒
~RET `~network~error$
◎
If request’s redirect count is 20, then return a network error.
</li>
	<li>
%要請 の`~redirect回数$rq ~INCBY 1
◎
Increase request’s redirect count by 1.
</li>
	<li>
~IF［
%要請 の`~mode$rq ~EQ `cors^l
］~AND［
%~Location~URL は`資格証を含んで$いる
］~AND［
%要請 の`生成元$rq
<em>~NEQ`生成元$sub</em>
%~Location~URL の`生成元$url
］
⇒
~RET `~network~error$
◎
If request’s mode is "cors", locationURL includes credentials, and request’s origin is not same origin with locationURL’s origin, then return a network error.
</li>
	<li>
<p>
~IF［
%要請 の`応答~tainting$rq ~EQ `cors^l
］~AND［
%~Location~URL は`資格証を含んで$いる
］
⇒
~RET `~network~error$
◎
If request’s response tainting is "cors" and locationURL includes credentials, then return a network error.
</p>

<p class="note">注記：
これは、
非同一-生成元~資源による同一-生成元~URLへの~redirectを捕える。
◎
This catches a cross-origin resource redirecting to a same-origin URL.
</p>
	</li>
	<li>
~IF［
%内部~応答 の`状態s$rs ~NEQ `303$st
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If internalResponse’s status is not 303, request’s body is non-null, and request’s body’s source is null, then return a network error.
</li>
	<li>
<p>
~IF［［
%内部~応答 の`状態s$rs ~IN { `301$st, `302$st }
］~AND［
%要請 の`~method$rq ~EQ `POST$hm
］］~OR［［
%内部~応答 の`状態s$rs ~EQ `303$st
］~AND［
%要請 の`~method$rq ~NIN { `GET$hm, `HEAD$hm }
］］：
◎
If one of the following is true
• internalResponse’s status is 301 or 302 and request’s method is `POST`
• internalResponse’s status is 303 and request’s method is not `GET` or `HEAD`
◎
then:
</p>
		<ol>
			<li>
%要請 の
⇒＃
`~method$rq ~SET `GET$hm；
`本体$rq ~SET ~NULL
◎
Set request’s method to `GET` and request’s body to null.
</li>
			<li>
`要請~本体~header名$を成す
~EACH( %~header名 )
に対し
⇒
%要請 の`~header~list$rqから`~headerを削除する$( %~header名 )
◎
For each headerName of request-body-header name, delete headerName from request’s header list.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%要請 の`現在の~URL$rqの`生成元$url
~NEQ`生成元$sub
%~Location~URL の`生成元$url
］
⇒
`~CORS非~wildcard要請~header名$を成す
~EACH( %~header名 )
に対し
⇒
%要請 の`~header~list$rqから`~headerを削除する$( %~header名 )
◎
If request’s current URL’s origin is not same origin with locationURL’s origin, then for each headerName of CORS non-wildcard request-header name, delete headerName from request’s header list.
</p>

<p class="note">注記：
すなわち、
初期~要請より後に別の生成元に出くわしたときには，
`Authorization$h ~headerは除去される。
◎
I.e., the moment another origin is seen after the initial request, the `Authorization` header is removed.
</p>
	</li>
	<li>
<p>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］
⇒
%要請 の`本体$rq ~SET 次の結果の`本体$bwT
⇒
`本体と型を安全に抽出する$( %要請 の`本体$rqの`~source$bd )
◎
If request’s body is non-null, then set request’s body to the body of the result of safely extracting request’s body’s source.
</p>

<p class="note">注記：
`~source$bdが ~NULL でないことは、
すでに検査~済み。
◎
request’s body’s source’s nullity has already been checked.
</p>
	</li>
	<li>
%計時~報 ~LET %~fetch~params の`計時~報$fP
◎
Let timingInfo be fetchParams’s timing info.
</li>
	<li>
%終了~時刻 ~LET `粗化した共有される現在の時刻$( %~fetch~params の`非同一-生成元~能力は隔離されるか$fP )
◎
↓</li>
	<li>
%計時~報 の
⇒＃
`~redirect終了~時刻$fT ~SET %終了~時刻,
`~redirect後からの開始~時刻$fT ~SET %終了~時刻
◎
Set timingInfo’s redirect end time and post-redirect start time to the coarsened shared current time given fetchParams’s cross-origin isolated capability.
</li>
	<li>
~IF［
%計時~報 の`~redirect開始~時刻$fT ~EQ 0
］
⇒
%計時~報 の`~redirect開始~時刻$fT ~SET %計時~報 の`開始~時刻$fT
◎
If timingInfo’s redirect start time is 0, then set timingInfo’s redirect start time to timingInfo’s start time.
</li>
	<li>
%要請 の`~URL~list$rqに %~Location~URL を付加する
◎
Append locationURL to request’s URL list.
</li>
	<li>
`~referrer施策を設定する$( %要請, %内部~応答 )
`REFERRER$r
◎
Invoke set request’s referrer policy on redirect on request and internalResponse. [REFERRER]
</li>
	<li>
%再帰的か ~LET ~T
◎
Let recursive be true.
</li>
	<li>
<p>
~IF［
%要請 の`~redirect~mode$rq ~EQ `manual^l
］：
◎
If request’s redirect mode is "manual", then:
</p>
		<ol>
			<li>
~Assert：
%要請 の`~mode$rq ~EQ `navigate^l
◎
Assert: request’s mode is "navigate".
</li>
			<li>
%再帰的か ~SET ~F
◎
Set recursive to false.
</li>
		</ol>
	</li>
	<li>
<p>
~RET `~main~fetch$( %~fetch~params, %再帰的か )
◎
Return the result of running main fetch given fetchParams and recursive.
</p>

<p class="note">注記：
%要請 の`応答~tainting$rqが正しくなるよう、
`~main~fetch$を呼出す必要がある。
◎
This has to invoke main fetch to get request’s response tainting correct.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="http-network-or-cache-fetch">
<h3 title="HTTP-network-or-cache fetch">4.5. ~HTTP~network-or-cache~fetch</h3>

<div class="algo">
<p>
`~HTTP~network-or-cache~fetch@
を遂行する
~algoは、
所与の
( `~fetch~params$ %~fetch~params,
真偽値 %認証~fetchか（省略時は ~F ）,
真偽値 %新たな接続~fetchか（省略時は ~F ）
)
に対し：
◎
To HTTP-network-or-cache fetch, given a fetch params fetchParams, an optional boolean isAuthenticationFetch (default false), and an optional boolean isNewConnectionFetch (default false), run these steps:
</p>

<p class="note">注記：
`HTTP-CACHING$r に従って，
`部分的な内容＠~HTTPsem#status.206$の~cache法を~supportする実装もあるが、
~browser~cacheからは広く~supportされていない。
◎
Some implementations might support caching of partial content, as per HTTP Caching. However, this is not widely supported by browser caches. [HTTP-CACHING]
</p>

<ol>
	<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
Let request be fetchParams’s request.
</li>
	<li>
%~HTTP~fetch~params ~LET ~NULL
◎
Let httpFetchParams be null.
</li>
	<li>
%~HTTP要請 ~LET ~NULL
◎
Let httpRequest be null.
</li>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%格納-済み応答 ~LET ~NULL
◎
Let storedResponse be null.
</li>
	<li>
%~HTTP~cache ~LET ~NULL
◎
Let httpCache be null.
</li>
	<li>
%再検証-中か ~LET ~F
◎
Let the revalidatingFlag be unset.
</li>
	<li>
<p>
この段の中は、
%~fetch~params が`取消された$fP`ときは中止する$：
◎
Run these steps, but abort when fetchParams is canceled:
</p>
		<ol>
			<li>
~IF［
%要請 の`~window$rq ~EQ `no-window^l
］~AND［
%要請 の`~redirect~mode$rq ~EQ `error^l
］
⇒＃
%~HTTP~fetch~params ~SET %~fetch~params；
%~HTTP要請 ~SET %要請
◎
If request’s window is "no-window" and request’s redirect mode is "error", then set httpFetchParams to fetchParams and httpRequest to request.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
<p>
%~HTTP要請 ~SET `要請を~cloneする$( %要請 )
◎
Set httpRequest to a clone of request.
</p>

<p class="note">注記：
実装は、［
%要請 の`本体$rq の`~source$bd ~EQ ~NULL
］のときは，［
%要請 の`本体$rq の`~stream$bdを二叉化するのを避ける
］ことが奨励される
— その事例では、
必要になる本体は 1 個だけなので
（例えば、~redirectや認証は，~fetchを失敗させることになる）。
◎
Implementations are encouraged to avoid teeing request’s body’s stream when request’s body’s source is null as only a single body is needed in that case. E.g., when request’s body’s source is null, redirects and authentication will end up failing the fetch.
</p>
					</li>
					<li>
%~HTTP~fetch~params ~SET %~fetch~params の複製
◎
Set httpFetchParams to a copy of fetchParams.
</li>
					<li>
%~HTTP~fetch~params の`要請$fP ~SET %~HTTP要請
◎
Set httpFetchParams’s request to httpRequest.
</li>
				</ol>
			</li>
			<li>
<p>
%資格証を含めるか ~LET ~IS ~OR↓：
</p>
				<ul>
					<li>
%要請 の`資格証~mode$rq ~EQ `include^l
</li>
					<li>
［
%要請 の`資格証~mode$rq ~EQ `same-origin^l
］~AND［
`応答~tainting$rq ~EQ `basic^l
］
</li>
				</ul>
◎
Let includeCredentials be true if one of
• request’s credentials mode is "include"
• request’s credentials mode is "same-origin" and request’s response tainting is "basic"
◎
is true; otherwise false.
</li>
			<li>
~IF［
`~Cross-Origin-Embedder-Policyは資格証を許容するか？$( %要請 ) ~EQ ~F
］
⇒
%資格証を含めるか ~SET ~F
◎
If Cross-Origin-Embedder-Policy allows credentials with request returns false, then set includeCredentials to false.
</li>
			<li>
%内容~長さ ~LET %~HTTP要請 の`本体$rqに応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ その`長さ$bd
◎
Let contentLength be httpRequest’s body’s length, if httpRequest’s body is non-null; otherwise null.
</li>
			<li>
%Content-Length~header値 ~LET ~NULL
◎
Let contentLengthHeaderValue be null.
</li>
			<li>
~IF［
%~HTTP要請 の`本体$rq ~EQ ~NULL
］~AND［
%~HTTP要請 の`~method$rq ~IN { `POST$hm, `PUT$hm }
］
⇒
%Content-Length~header値 ~SET `0^bl
◎
If httpRequest’s body is null and httpRequest’s method is `POST` or `PUT`, then set contentLengthHeaderValue to `0`.
</li>
			<li>
~IF［
%内容~長さ ~NEQ ~NULL
］
⇒
%Content-Length~header値 ~SET `同型に符号化する$( `整数を直列化する$( %内容~長さ ) )
◎
If contentLength is non-null, then set contentLengthHeaderValue to contentLength, serialized and isomorphic encoded.
</li>
			<li>
~IF［
%Content-Length~header値 ~NEQ ~NULL
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Content-Length$h, %Content-Length~header値 )
)
◎
If contentLengthHeaderValue is non-null, then append (`Content-Length`, contentLengthHeaderValue) to httpRequest’s header list.
</li>
			<li>
<p>
~IF［
%内容~長さ ~NEQ ~NULL
］~AND［
%~HTTP要請 の`~keepaliveか$rq ~EQ ~T
］：
◎
If contentLength is non-null and httpRequest’s keepalive is true, then:
</p>
				<ol>
					<li>
%~inflight~keepalive~byte数 ~LET 0
◎
Let inflightKeepaliveBytes be 0.
</li>
					<li>
%~group ~LET %~HTTP要請 の`~client$rqの`~fetch~group$
◎
Let group be httpRequest’s client’s fetch group.
</li>
					<li>
%~inflight記録~list ~LET ［
%~group 内の`~fetch記録$のうち，その`要請$fRが次を満たすもの
］たちが成す同順の~list
⇒
［
`~keepaliveか$rq ~EQ ~T
］~AND［
`済んだか$rq ~EQ ~F
］
◎
Let inflightRecords be the set of fetch records in group whose request’s keepalive is true and done flag is unset.
</li>
					<li>
<p>
%~inflight記録~list を成す
~EACH( %~fetch記録 )
に対し：
◎
For each fetchRecord of inflightRecords:
</p>
						<ol>
							<li>
%~inflight要請 ~LET %~fetch記録 の`要請$fR
◎
Let inflightRequest be fetchRecord’s request.
</li>
							<li>
%~inflight~keepalive~byte数 ~INCBY
%~inflight要請 の`本体$rqの`長さ$bd
◎
Increment inflightKeepaliveBytes by inflightRequest’s body’s length.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
( %内容~長さ ~PLUS %~inflight~keepalive~byte数 ) ~GT 64 KiB
］
⇒
~RET `~network~error$
◎
If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
</p>

<p class="note">注記：
この~~上限 64 KiB 【 `kibibyte^en — 1024 ~byte単位】は、［
`環境~設定群~obj$の外で残存することが許容され, 本体を包含する要請
【~CSP違反~報告など】
］に対し、
その~sizeには上限があり，要請が不定期に残り続けないことを確保するためにある。
◎
The above limit ensures that requests that are allowed to outlive the environment settings object and contain a body, have a bounded size and are not allowed to stay alive indefinitely.
</p>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~HTTP要請 の`~referrer$rqは`~URL$である
］：
◎
If httpRequest’s referrer is a URL, then:
</p>
				<ol>
					<li>
%~referrer値 ~LET `同型に符号化する$( `~URLを直列化する$( %~HTTP要請 の`~referrer$rq ) )
◎
Let referrerValue be httpRequest’s referrer, serialized and isomorphic encoded.
</li>
					<li>
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Referer$h, %~referrer値 )
◎
Append (`Referer`, referrerValue) to httpRequest’s header list.
</li>
				</ol>
			</li>
			<li>
`要請~Origin~headerを付加する$( %~HTTP要請 )
◎
Append a request `Origin` header for httpRequest.
</li>
			<li>
`~fetch~metadata~headerたちを付加する$( %~HTTP要請 )
`FETCH-METADATA$r
◎
Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
</li>
			<li>
~IF［
%~HTTP要請 の`起動元$rq ~EQ `prefetch^l
］
⇒
%~HTTP要請 の`~header~list$rq内で`有構造~field値を設定する$( `Sec-Purpose$h, `~sf~token$型の値 `prefetch^l )
◎
If httpRequest’s initiator is "prefetch", then set a structured field value given (`Sec-Purpose`, the token prefetch) in httpRequest’s header list.
</li>
			<li>
~IF［
%~HTTP要請 の`~header~list$rq内に［
`User-Agent$h を`名前に持つ~header$
］は無い
］
⇒
~UAは、
次を行うベキである
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `User-Agent$h, `既定の User-Agent 値$ )
)
◎
If httpRequest’s header list does not contain `User-Agent`, then user agents should append (`User-Agent`, default `User-Agent` value) to httpRequest’s header list.
</li>
					<li>
~IF［
%~HTTP要請 の`~cache~mode$rq ~EQ `default^l
］~AND［
%~HTTP要請 の`~header~list$rq内に［
`If-Modified-Since$h ／
`If-None-Match$h ／
`If-Unmodified-Since$h ／
`If-Match$h ／
`If-Range$h
］を`名前に持つ~header$は在る
］
⇒
%要請 の`~cache~mode$rq ~SET `no-store^l
◎
If httpRequest’s cache mode is "default" and httpRequest’s header list contains `If-Modified-Since`, `If-None-Match`, `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set httpRequest’s cache mode to "no-store".
</li>
			<li>
~IF［
%~HTTP要請 の`~cache~mode$rq ~EQ `no-cache^l
］~AND［
%~HTTP要請 の`~no-cache時には~cache制御~headerを改変しないか$rq ~EQ ~F
］~AND［
%~HTTP要請 の`~header~list$rq内に［
`Cache-Control$h を`名前に持つ~header$
］は無い
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Cache-Control$h, `max-age=0^bl )
)
◎
If httpRequest’s cache mode is "no-cache", httpRequest’s prevent no-cache cache-control header modification flag is unset, and httpRequest’s header list does not contain `Cache-Control`, then append (`Cache-Control`, `max-age=0`) to httpRequest’s header list.
</li>
			<li>
<p>
~IF［
%~HTTP要請 の`~cache~mode$rq ~IN
{ `no-store^l, `reload^l }
］：
◎
If httpRequest’s cache mode is "no-store" or "reload", then:
</p>
				<ol>
					<li>
~IF［
%~HTTP要請 の`~header~list$rq内に［
`Pragma$h を`名前に持つ~header$
］は無い
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Pragma$h, `no-cache^bl )
)
◎
If httpRequest’s header list does not contain `Pragma`, then append (`Pragma`, `no-cache`) to httpRequest’s header list.
</li>
					<li>
~IF［
%~HTTP要請 の`~header~list$rq内に［
`Cache-Control$h を`名前に持つ~header$
］は無い
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Cache-Control$h, `no-cache^bl )
)
◎
If httpRequest’s header list does not contain `Cache-Control`, then append (`Cache-Control`, `no-cache`) to httpRequest’s header list.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~HTTP要請 の`~header~list$rq内に［
`Range$h を`名前に持つ~header$
］は在る
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Accept-Encoding$h, `identity^bl )
)
◎
If httpRequest’s header list contains `Range`, then append (`Accept-Encoding`, `identity`) to httpRequest’s header list.
</p>

<div class="note">
<p>注記：
これは、
符号化された`応答$の ある部位に対し `内容~符号法sを取扱う$ときの失敗を避ける。
◎
This avoids a failure when handling content codings with a part of an encoded response.
</p>

<p>
加えて，
`多くの~server＠https://jakearchibald.github.io/accept-encoding-range-test/$は、［
`identity^bl 以外の符号化法を受容する場合には、
`Range$h ~headerは無視する
］ものと誤認している。
◎
Additionally, many servers mistakenly ignore `Range` headers if a non-identity encoding is accepted.
</p>
</div>

	</li>
	<li>
<p>
~HTTPに則って %~HTTP要請 の`~header~list$rqを改変する
— %~HTTP要請 の`~header~list$rq内に［
所与の`~header$の`名前$hdを`名前に持つ~header$
］が在る場合には、
それを`付加-＠#concept-header-list-append$しないこと。
◎
Modify httpRequest’s header list per HTTP. Do not append a given header if httpRequest’s header list contains that header’s name.
</p>

<p class="note">注記：
この段は、
何かもっと規範的な~~形にしたい。
次に挙げる`~header$などは、
必要yなら，この時点で`付加-＠#concept-header-list-append$される
⇒
`Accept-Encoding$h,
`Connection$h,
`DNT^h,
`Host$h
◎
It would be great if we could make this more normative somehow. At this point headers such as `Accept-Encoding`, `Connection`, `DNT`, and `Host`, are to be appended if necessary.
</p>

<p>
この時点では、
次に挙げる`~header$は内包しないモノトスル
⇒
`Accept$h,
`Accept-Charset$h,
`Accept-Language$h
◎
`Accept`, `Accept-Charset`, and `Accept-Language` must not be included at this point.
</p>

<p class="note">注記：
［
`Accept$h, `Accept-Language$h
］は、
すでに内包されている
（ `fetch()$m が利用されていない限り
— それは、
既定では後者を内包しない）。
また， `Accept-Charset$h は、
内包しても，~byte列を浪費するだけである。
詳細は、
`~HTTP~header層の~~区分＠#http-header-layer-division$を見よ。
◎
`Accept` and `Accept-Language` are already included (unless fetch() is used, which does not include the latter by default), and `Accept-Charset` is a waste of bytes. See HTTP header layer division for more details.
</p>

			</li>
			<li>
<p>
`(A)^i：<br>
~IF［
%資格証を含めるか ~EQ ~T
］：
◎
If includeCredentials is true, then:
</p>
				<ol>
					<li>
<p>
~IF［
~UAは %~HTTP要請 用の~cookieを阻止するように環境設定されていない
（ `COOKIES$r `§ ~privacyの考慮点＠~HTTPcookie#privacy-considerations$ を見よ）
］：
◎
If the user agent is not configured to block cookies for httpRequest (see section 7 of [COOKIES]), then:
</p>
						<ol>
							<li>
%~cookie ~LET 次を与える下で，
`"cookie-string" ~algo＠~HTTPcookie#cookie$ `COOKIES$r を走らせた結果
⇒
( ~UAの~cookie保管庫, %~HTTP要請 の`現在の~URL$rq )
◎
Let cookies be the result of running the "cookie-string" algorithm (see section 5.4 of [COOKIES]) with the user agent’s cookie store and httpRequest’s current URL.
</li>
							<li>
~IF［
%~cookie ~NEQ 空~文字列
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Cookie$h, %~cookie )
)
◎
If cookies is not the empty string, then append (`Cookie`, cookies) to httpRequest’s header list.
</li>
						</ol>
					</li>
					<li>
~IF［
%~HTTP要請 の`~header~list$rq内に［
`Authorization$h を`名前に持つ~header$
］は在る
］
⇒
~BREAK `(A)^i
◎
If httpRequest’s header list does not contain `Authorization`, then:
</li>
					<li>
%権限付与~値 ~LET ~NULL
◎
Let authorizationValue be null.
</li>
					<li>
~IF［
%~HTTP要請 用の`認証~entry$は在る
］~AND［［
%~HTTP要請 の`~URL資格証を利用するか$rq ~EQ ~F
］~OR［
%~HTTP要請 の`現在の~URL$rqは`資格証を含んで$いない
］］
⇒
%権限付与~値 ~SET `認証~entry$
◎
If there’s an authentication entry for httpRequest and either httpRequest’s use-URL-credentials flag is unset or httpRequest’s current URL does not include credentials, then set authorizationValue to authentication entry.
</li>
					<li>
~ELIF［
%~HTTP要請 の`現在の~URL$rqは`資格証を含んで$いる
］~AND［
%認証~fetchか ~EQ ~T
］
⇒
%権限付与~値 ~SET %~HTTP要請 の`現在の~URL$rqを
<span class="XXX">`Authorization$h 値に変換-</span>
した結果
◎
Otherwise, if httpRequest’s current URL does include credentials and isAuthenticationFetch is true, set authorizationValue to httpRequest’s current URL, converted to an `Authorization` value.
</li>
					<li>
~IF［
%権限付与~値 ~NEQ ~NULL
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `Authorization$h, %権限付与~値 )
)
◎
If authorizationValue is non-null, then append (`Authorization`, authorizationValue) to httpRequest’s header list.
</li>
				</ol>
			</li>
			<li>
<p>
`~proxy認証~entry$がある場合、
それを適切に利用する
◎
If there’s a proxy-authentication entry, use it as appropriate.
</p>

<p class="note">注記：
ここでは意図的に %~HTTP要請 の`資格証~mode$rqに依存しないようにされている。
◎
This intentionally does not depend on httpRequest’s credentials mode.
</p>
			</li>
			<li>
%~HTTP~cache ~SET `~HTTP~cache区分を決定する$( %~HTTP要請 )
◎
Set httpCache to the result of determining the HTTP cache partition, given httpRequest.
</li>
			<li>
~IF［
%~HTTP~cache ~EQ ~NULL
］
⇒
%~HTTP要請 の`~cache~mode$rq~SET `no-store^l
◎
If httpCache is null, then set httpRequest’s cache mode to "no-store".
</li>
			<li>
<p>
`(B)^i：<br>

~IF［
%~HTTP要請 の`~cache~mode$rq ~NIN { `no-store^l, `reload^l }
］：
◎
If httpRequest’s cache mode is neither "no-store" nor "reload", then:
</p>
				<ol>
					<li>
<p>
%格納-済み応答 ~SET 
`HTTP-CACHING$r
`§ ~cache からの応答の構築-法＠~HTTPcache#constructing.responses.from.caches$に従って，
%~HTTP~cache から応答を選定した結果
⇒
~IF［
該当する応答はない
］
⇒
~BREAK `(B)^i
</p>

<p class="note">注記：
~HTTPにより義務付けられたとおり、
これには，依然として `Vary$h `~header$も織り込まれる。
</p>

◎
Set storedResponse to the result of selecting a response from the httpCache, possibly needing validation, as per the "Constructing Responses from Caches" chapter of HTTP Caching, if any. [HTTP-CACHING]
◎
As mandated by HTTP, this still takes the `Vary` header into account.
◎
If storedResponse is non-null, then:
</li>
					<li>
<p>
~IF［
`~cache~mode$rq ~EQ `default^l
］~AND［
%格納-済み応答 は`~stale-while-revalidate応答$である
］~AND［
%~HTTP要請 の`~client$rq ~NEQ ~NULL
］：
◎
If cache mode is "default", storedResponse is a stale-while-revalidate response, and httpRequest’s client is non-null, then:
</p>
						<ol>
							<li>
%応答 ~SET %格納-済み応答
◎
Set response to storedResponse.
</li>
							<li>
%応答 の`~cache状態$rs ~SET `local^l
◎
Set response’s cache state to "local".
</li>
							<li>
%再検証-要請 ~LET `要請を~cloneする$( %要請 )
◎
Let revalidateRequest be a clone of request.
</li>
							<li>
%再検証-要請 の
⇒＃
`~cache~mode$rq ~SET `no-cache^l,
`~no-cache時には~cache制御~headerを改変しないか$rq ~SET ~T,
`~sw~mode$rq ~SET `none^l
◎
Set revalidateRequest’s cache mode set to "no-cache".
◎
Set revalidateRequest’s prevent no-cache cache-control header modification flag.
◎
Set revalidateRequest’s service-workers mode set to "none".
</li>
							<li>
%再検証-~fetch~params ~LET 新たな`~fetch~params$
— その
⇒＃
`要請$fP ~SET %再検証-要請
◎
↓</li>
							<li class="algo">
<p>
この段は、
`並列的$に遂行する
⇒
`~main~fetch$( %再検証-~fetch~params )
◎
In parallel, run main fetch given a new fetch params whose request is revalidateRequest.
</p>

<p class="note">注記：
この~fetchに意味されるのは，
%~HTTP~cache の状態を更新することに限られ、
対する応答は，別の~cache~accessまで利用されないことになる。
現在の要請に対する応答には、
`非新鮮な応答$が利用されることになる。
この~fetchは，~clientの文脈で発行されるので、
消え去った場合，当の要請（ %再検証-要請 ）は終了されることになる。
◎
This fetch is only meant to update the state of httpCache and the response will be unused until another cache access. The stale response will be used as the response to current request. This fetch is issued in the context of a client so if it goes away the request will be terminated.
</p>
							</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
~IF［
%格納-済み応答 は`非新鮮な応答$である
］
⇒
%再検証-中か ~SET ~T
◎
If storedResponse is a stale response, then set the revalidatingFlag.
</li>
							<li>
<p>
~IF［
%再検証-中か ~EQ ~T
］~AND［
%~HTTP要請 の`~cache~mode$rq ~NIN { `force-cache^l, `only-if-cached^l }
］：
◎
If the revalidatingFlag is set and httpRequest’s cache mode is neither "force-cache" nor "only-if-cached", then:
</p>
								<ol>
									<li>
~IF［
%格納-済み応答 の`~header~list$rs内に［
`ETag$h を`名前に持つ~header$ %~header
］は在る†
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `If-None-Match$h, %~header の`値$hd )
)
◎
If storedResponse’s header list contains `ETag`, then append (`If-None-Match`, `ETag`'s value) to httpRequest’s header list.
</li>
									<li>
~IF［
%格納-済み応答 の`~header~list$rs内に［
`Last-Modified$h を`名前に持つ~header$ %~header
］は在る†
］
⇒
%~HTTP要請 の`~header~list$rqに`~headerを付加する$(
( `If-Modified-Since$h, %~header の`値$hd )
)
◎
If storedResponse’s header list contains `Last-Modified`, then append (`If-Modified-Since`, `Last-Modified`'s value) to httpRequest’s header list.
</li>
								</ol>

<p class="trans-note">【†
該当する`~header$は、
1 つしかないものと見做されている。
】</p>

<p class="note">注記：
`HTTP-CACHING$r
`§ 検証~要請の送信-法＠~HTTPcache#validation.sent$
も見よ。
◎
See also the "Sending a Validation Request" chapter of HTTP Caching. [HTTP-CACHING]
</p>
							</li>
							<li>
~ELSE
⇒＃
%応答 ~SET %格納-済み応答；
%応答 の`~cache状態$rs ~SET `local^l
◎
Otherwise, set response to storedResponse and set response’s cache state to "local".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
前~段が`中止されたときは$
⇒
~RET `適切な~network~error$( %~fetch~params )
◎
If aborted, then return the appropriate network error for fetchParams.
</li>
	<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
		<ol>
			<li>
~IF［
%~HTTP要請 の`~cache~mode$rq ~EQ `only-if-cached^l
］
⇒
~RET `~network~error$
◎
If httpRequest’s cache mode is "only-if-cached", then return a network error.
</li>
			<li>
%回送-応答 ~LET `~HTTP~network~fetch$( %~HTTP~fetch~params, %資格証を含めるか, %新たな接続~fetchか )
◎
Let forwardResponse be the result of running HTTP-network fetch given httpFetchParams, includeCredentials, and isNewConnectionFetch.
</li>
			<li>
<p>
~IF［
%~HTTP要請 の`~method$rqは`安全$でない
］~AND［
%回送-応答 の`状態s$rs ~IN { `200^st 〜 `399^st }
］：
</p>
				<ol>
					<li>
`HTTP-CACHING$r
`§ 格納-済み応答の無効化-法＠~HTTPcache#invalidation$
に従って，
%~HTTP~cache 内の適切な格納-済み応答たちを無効化する
</li>
					<li>
%格納-済み応答 ~SET ~NULL
</li>
				</ol>
◎
If httpRequest’s method is unsafe and forwardResponse’s status is in the range 200 to 399, inclusive, invalidate appropriate stored responses in httpCache, as per the "Invalidating Stored Responses" chapter of HTTP Caching, and set storedResponse to null. [HTTP-CACHING]
</li>
			<li>
<p>
~IF［
%再検証-中か ~EQ ~T
］~AND［
%回送-応答 の`状態s$rs ~EQ `304$st
］：
◎
If the revalidatingFlag is set and forwardResponse’s status is 304, then:
</p>
				<ol>
					<li>
<p>
`HTTP-CACHING$r
`§ 検証に際しての，格納-済み応答の新鮮化-法＠~HTTPcache#freshening.responses$
に従って，
%回送-応答 の`~header~list$rsを利用して
%格納-済み応答 の`~header~list$rsを更新する
◎
Update storedResponse’s header list using forwardResponse’s header list, as per the "Freshening Stored Responses upon Validation" chapter of HTTP Caching. [HTTP-CACHING]
</p>

<p class="note">注記：
これは、
~cache内の格納-済み応答も更新する。
◎
This updates the stored response in cache as well.
</p>
					</li>
					<li>
%応答 ~SET %格納-済み応答
◎
Set response to storedResponse.
</li>
					<li>
%応答 の`~cache状態$rs ~SET `validated^l
◎
Set response’s cache state to "validated".
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%応答 ~EQ ~NULL
］：
◎
If response is null, then:
</p>
				<ol>
					<li>
%応答 ~SET %回送-応答
◎
Set response to forwardResponse.
</li>
					<li>
<p>
`HTTP-CACHING$r
`§ ~cache内への応答の格納-法＠~HTTPcache#response.cacheability$
に従って，
%~HTTP~cache 内に［
%~HTTP要請, %回送-応答
］を格納する
◎
Store httpRequest and forwardResponse in httpCache, as per the "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
</p>

<p class="note">注記：
%回送-応答 が`~network~error$である場合、
これは実質的に，その~network~errorを~cacheする
— それは “否定的~cache法（ `negative caching^en ）” と称されることもある。
◎
If forwardResponse is a network error, this effectively caches the network error, which is sometimes known as "negative caching".
</p>

<p class="note">注記：
結付けられた`本体~報$rsは、
当の応答と併せて~cache内に格納される。
◎
The associated body info is stored in the cache alongside the response.
</p>
					</li>
		 		</ol>
			</li>
		</ol>
	</li>
	<li>
%応答 の`~URL~list$rs ~SET %~HTTP要請 の`~URL~list$rqを`~cloneする$
◎
Set response’s URL list to a clone of httpRequest’s URL list.
</li>
	<li>
~IF［
%~HTTP要請 の`~header~list$rq内に［
`Range$h を`名前に持つ~header$
］は在る
］
⇒
%応答 の`範囲が要請されたか$rs ~SET ~T
◎
If httpRequest’s header list contains `Range`, then set response’s range-requested flag.
</li>
	<li>
%応答 の`要請は資格証を含むか$rs ~SET %資格証を含めるか
◎
Set response’s request-includes-credentials to includeCredentials.
</li>
	<li>
<p>
~IF［
%応答 の`状態s$rs ~EQ `401$st
］~AND［
%~HTTP要請 の`応答~tainting$rq ~NEQ `cors^l
］~AND［
%資格証を含めるか ~EQ ~T
］~AND［
%要請 の`~window$rqは`環境~設定群~obj$である
］：
◎
If response’s status is 401, httpRequest’s response tainting is not "cors", includeCredentials is true, and request’s window is an environment settings object, then:
</p>
		<ol>
			<li class="XXX">課題：
`WWW-Authenticate$h ~header
が複数個ある場合, 与えられていない場合, その構文解析,
についてのテスト
◎
Needs testing: multiple `WWW-Authenticate` headers, missing, parsing issues.
</li>
			<li>
<p>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］：
◎
If request’s body is non-null, then:
</p>
				<ol>
					<li>
~IF［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If request’s body’s source is null, then return a network error.
</li>
					<li>
%要請 の`本体$rq ~SET 次の結果の`本体$bwT
⇒
`本体と型を安全に抽出する$( %要請 の`本体$rqの`~source$bd )
◎
Set request’s body to the body of the result of safely extracting request’s body’s source.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%要請 の`~URL資格証を利用するか$rq ~EQ ~F
］~OR［
%認証~fetchか ~EQ ~T
］：
◎
If request’s use-URL-credentials flag is unset or isAuthenticationFetch is true, then:
</p>
				<ol>
					<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET `適切な~network~error$( %~fetch~params )
◎
If fetchParams is canceled, then return the appropriate network error for fetchParams.
</li>
					<li>
( %~username, %~password ) ~LET
%要請 の`~window$rq
において，末端-利用者に
( ~username, ~password )
の~~入力を促して得られた結果
【~~入力が拒否された場合について言及されていない。`中止~network~error$を返す？】
◎
Let username and password be the result of prompting the end user for a username and password, respectively, in request’s window.
</li>
					<li>
`~URLの~usernameを設定する$( %要請 の`現在の~URL$rq, %~username )
◎
Set the username given request’s current URL and username.
</li>
					<li>
`~URLの~passwordを設定する$( %要請 の`現在の~URL$rq, %~password )
◎
Set the password given request’s current URL and password.
</li>
				</ol>
			</li>
			<li>
%応答 ~SET `~HTTP~network-or-cache~fetch$( %~fetch~params, ~T )
◎
Set response to the result of running HTTP-network-or-cache fetch given fetchParams and true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%応答 の`状態s$rs ~EQ `407$st
］：
◎
If response’s status is 407, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`~window$rq ~EQ `no-window^l
］
⇒
~RET `~network~error$
◎
If request’s window is "no-window", then return a network error.
</li>
			<li class="XXX">課題：
`Proxy-Authenticate$h ~header
が複数個ある場合, 与えられていない場合, その構文解析,
についてのテスト
◎
Needs testing: multiple `Proxy-Authenticate` headers, missing, parsing issues.
</li>
			<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET `適切な~network~error$( %~fetch~params )
◎
If fetchParams is canceled, then return the appropriate network error for fetchParams.
</li>
			<li>
<p>
%要請 の`~window$rqにおいて、
末端-利用者に対し 適切に【認証に関する手続きを】促して，
その結果を`~proxy認証~entry$として保存する
`HTTP$r
◎
Prompt the end user as appropriate in request’s window and store the result as a proxy-authentication entry. [HTTP]
</p>

<p class="note">注記：
~proxy認証~周辺の詳細は~HTTPにて定義される。
◎
Remaining details surrounding proxy authentication are defined by HTTP.
</p>
			</li>
			<li>
%応答 ~SET `~HTTP~network-or-cache~fetch$( %~fetch~params )
◎
Set response to the result of running HTTP-network-or-cache fetch given fetchParams.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If all of the following are true
</p>
		<ul>
			<li>
%応答 の`状態s$rs ~EQ `421$st
◎
response’s status is 421
</li>
			<li>
%新たな接続~fetchか ~EQ ~F
◎
isNewConnectionFetch is false
</li>
			<li>
［
%要請 の`本体$rq ~EQ ~NULL
］~OR［［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqの`~source$bd ~NEQ ~NULL
］］
◎
request’s body is null, or request’s body is non-null and request’s body’s source is non-null
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET `適切な~network~error$( %~fetch~params )
◎
If fetchParams is canceled, then return the appropriate network error for fetchParams.
</li>
			<li>
%応答 ~SET `~HTTP~network-or-cache~fetch$( %~fetch~params, %認証~fetchか, ~T )
◎
Set response to the result of running HTTP-network-or-cache fetch given fetchParams, isAuthenticationFetch, and true.
</li>
		</ol>
	</li>
	<li>
~IF［
%認証~fetchか ~EQ ~T
］
⇒
［
%要請, および所与の~realm
］用の`認証~entry$を作成する
◎
If isAuthenticationFetch is true, then create an authentication entry for request and the given realm.
</li>
	<li>
<p>
~RET %応答
</p>

<p class="note">注記：
手続きはここで終わるが、
その後も概して，
%応答 の`本体$rsの`~stream$bdには~enqueueされ続ける。
</p>
◎
Return response. Typically response’s body’s stream is still being enqueued to after returning.
</li>
</ol>
</div>

		</section>
		<section id="http-network-fetch">
<h3 title="HTTP-network fetch">4.6. ~HTTP~network~fetch</h3>

<div class="algo">
<p>
`~HTTP~network~fetch@
を遂行する
~algoは、
所与の
( `~fetch~params$ %~fetch~params,
真偽値 %資格証を含めるか（省略時は ~F ）,
真偽値 %新たな接続を強制するか（省略時は ~F ）
)
に対し：
◎
To HTTP-network fetch, given a fetch params fetchParams, an optional boolean includeCredentials (default false), and an optional boolean forceNewConnection (default false), run these steps:
</p>
<ol>
	<li>
%要請 ~LET %~fetch~params の`要請$fP
◎
Let request be fetchParams’s request.
</li>
	<li>
%応答 ~LET ~NULL
◎
Let response be null.
</li>
	<li>
%計時~報 ~LET %~fetch~params の`計時~報$fP
◎
Let timingInfo be fetchParams’s timing info.
</li>
	<li>
%~network区分~key ~LET `要請の~network区分~keyを決定する$( %要請 )
◎
Let networkPartitionKey be the result of determining the network partition key given request.
</li>
	<li>
%新たな接続 ~LET %新たな接続を強制するか に応じて
⇒＃
~T ならば `yes^l ／
~F ならば `no^l
◎
Let newConnection be "yes" if forceNewConnection is true; otherwise "no".
</li>
	<li>
<p>
%接続 ~LET %要請 の`~mode$rqに応じて，次を遂行した結果：
◎
Switch on request’s mode:
</p>
		<ul class="switch">
			<li>
`websocket^l
⇒
`~WebSocket接続を得する$( %要請 の`現在の~URL$rq )
◎
"websocket"
• Let connection be the result of obtaining a WebSocket connection, given request’s current URL.
</li>
			<li>
~ELSE_
⇒
`接続を得する$( %~network区分~key, %要請 の`現在の~URL$rq, %資格証を含めるか, %新たな接続 )
◎
Otherwise
• Let connection be the result of obtaining a connection, given networkPartitionKey, request’s current URL, includeCredentials, and newConnection.
</li>
		</ul>
	</li>
	<li>
<p>
この段の中は、
%~fetch~params が`取消された$fP`ときは中止する$：
◎
Run these steps, but abort when fetchParams is canceled:
</p>
		<ol>
			<li>
~IF［
%接続 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If connection is failure, then return a network error.
</li>
			<li>
%計時~報 の`最終-接続~計時~報$fT ~SET `接続~計時~報を切詰めて粗化する$( 
%接続 の`計時~報$,
%計時~報 の`~redirect後からの開始~時刻$fT,
%~fetch~params の`非同一-生成元~能力は隔離されるか$fP
)
◎
Set timingInfo’s final connection timing info to the result of calling clamp and coarsen connection timing info with connection’s timing info, timingInfo’s post-redirect start time, and fetchParams’s cross-origin isolated capability.
</li>
			<li>
~IF［
%接続 は~HTTP1x接続である
］~AND［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］
⇒
~RET `~network~error$
◎
If connection is an HTTP/1.x connection, request’s body is non-null, and request’s body’s source is null, then return a network error.
</li>
			<li>
%計時~報 の`最終-~network要請~開始~時刻$fT ~SET `粗化した共有される現在の時刻$( %~fetch~params の`非同一-生成元~能力は隔離されるか$fP )
◎
Set timingInfo’s final network-request start time to the coarsened shared current time given fetchParams’s cross-origin isolated capability.
</li>
			<li>
<p>
%応答 ~SET 次に挙げる各~条項に従う下で、
%要請 を利用して, %接続 越しに`~HTTP要請$を為した結果：
◎
Set response to the result of making an HTTP request over connection using request with the following caveats:
</p>
				<ul>
					<li>
~HTTPによる関連な要件に従うこと。
`HTTP$r
`HTTP-CACHING$r
◎
Follow the relevant requirements from HTTP. [HTTP] [HTTP-CACHING]
</li>
					<li>
<p>
［
%要請 の`本体$rq ~NEQ ~NULL
］かつ［
%要請 の`本体$rqの`~source$bd ~EQ ~NULL
］の場合、
64 KiB 以下の~bufferを用意して，
%要請 の`本体$rqの一部を その~buffer内に格納してもヨイ。
~UAは、［
その~bufferの~sizeを超えて %要請 の`本体$rqを読取る
］かつ［
%要請 を送信し直す必要がある
］場合には，代わりに`~network~error$を返すこと。
◎
If request’s body is non-null, and request’s body’s source is null, then the user agent may have a buffer of up to 64 kibibytes and store a part of request’s body in that buffer. If the user agent reads from request’s body beyond that buffer’s size and the user agent needs to resend request, then instead return a network error.
</p>

<div class="note">
<p>注記：
送信し直すのは、
例えば，接続が時間~切れになったときに必要になる。
%要請 の`本体$rqの`~source$bdが：
◎
The resending is needed when the connection is timed out, for example.
</p>
						<ul>
							<li>
~NULL でないときは、
~bufferは必要ない
— %要請 の`本体$rqは，~sourceから作成し直せるので。
◎
The buffer is not needed when request’s body’s source is non-null, because request’s body can be recreated from it.
</li>
							<li>
~NULL のときは、
`本体$rqは `ReadableStream$I ~objから作成されたこと，
したがって作成し直せないことを意味する
— ~bufferが必要になるわけは、
それである。
◎
When request’s body’s source is null, it means body is created from a ReadableStream object, which means body cannot be recreated and that is why the buffer is needed.
</li>
						</ul>
</div>
					</li>
					<li class="algo">
<p>
~WHILE 無条件：
【すなわち、~HTTP~serverから`最終-応答$が返されるか接続が~errorになるまで，各`~HTTP応答$に対し以下の手続きを繰返す】
：
◎
While true:
</p>
						<ol>
							<li>
%計時~報 の`最終-~network応答~開始~時刻$fT ~SET ［
~UAの~HTTP構文解析器が当の応答を成す最初の~byte
（例：~HTTP2用の~frame~header~byte列／~HTTP1x用の応答~状態s行l）
を受信した直後
］における，
`粗化した共有される現在の時刻$( %~fetch~params の`非同一-生成元~能力は隔離されるか$fP )
◎
Set timingInfo’s final network-response start time to the coarsened shared current time given fetchParams’s cross-origin isolated capability, immediately after the user agent’s HTTP parser receives the first byte of the response (e.g., frame header bytes for HTTP/2 or response status line for HTTP/1.x).
</li>
							<li>
当の~HTTP応答の`~header節$全体が伝送されるまで待機する
◎
Wait until all the HTTP response headers are transmitted.
</li>
							<li>
%状態s ~LET 当の~HTTP応答の`状態s~code$
◎
Let status be the HTTP response’s status code.
</li>
							<li>
<p>
~IF［
%状態s ~IN { `100^st 〜 `199^st }
］：
◎
If status is in the range 100 to 199, inclusive:
</p>
								<ol>
									<li>
~IF［
%計時~報 の`最初の非最終-~network応答~開始~時刻$fT ~EQ 0
］
⇒
%計時~報 の`最初の非最終-~network応答~開始~時刻$fT ~SET %計時~報 の`最終-~network応答~開始~時刻$fT
◎
If timingInfo’s first interim network-response start time is 0, then set timingInfo’s first interim network-response start time to timingInfo’s final network-response start time.
</li>
									<li>
~IF［
%要請 の`~mode$rq ~EQ `websocket^l
］~AND［
%状態s ~EQ `101$st
］
⇒
~BREAK
◎
If request’s mode is "websocket" and status is 101, then break.
</li>
									<li>
<p>
~IF［
%状態s ~EQ `103$st
］~AND［
%~fetch~params の`応答の早期~hintの処理n$fP ~NEQ ~NULL
］
⇒
`~fetch~taskを~queueする$( 次の手続き, †)
</p>

<div class="algo">
手続きは
⇒
%~fetch~params の`応答の早期~hintの処理n$fP( `応答$†† )
</div>

<p class="trans-note">【†
2 個目の引数が指定されていない
— %~fetch~params の`~taskの行先$fP ？
】【††
どの応答を指すのか指定されていない
— 当の~HTTP応答を表現する`応答$？
】</p>
◎
If status is 103 and fetchParams’s process early hints response is non-null, then queue a fetch task to run fetchParams’s process early hints response, with response.
</li>
									<li>
~CONTINUE
◎
Continue.
</li>
								</ol>

<p class="note">注記：
この種類の`~HTTP応答$【`非最終-応答$】には、
最終的に， “最終” ~HTTP応答【`最終-応答$】が後続する。
◎
These kind of HTTP responses are eventually followed by a "final" HTTP response.
</p>
							</li>
							<li>
~BREAK
◎
Break.
</li>
						</ol>
					</li>
				</ul>

<p class="note">注記：
~Fetch層と~HTTP層の正確な重ね方は、
依然として~~整理される必要がある。
したがって、
ここでの %応答 は，`応答$と`~HTTP応答$の両者を表現する。
◎
The exact layering between Fetch and HTTP still needs to be sorted through and therefore response represents both a response and an HTTP response here.
</p>

				<ul>
					<li class="algo">
<p>
`~HTTP要請$による結果，~TLS~client証明書~dialogになるときは：
◎
If the HTTP request results in a TLS client certificate dialog, then:
</p>
						<ol>
							<li>
~IF［
%要請 の`~window$rqは`環境~設定群~obj$である
］
⇒
%要請 の`~window$rqにて~dialogを可用にする
◎
If request’s window is an environment settings object, make the dialog available in request’s window.
</li>
							<li>
~ELSE
⇒
~RET `~network~error$
◎
Otherwise, return a network error.
</li>
						</ol>
					</li>
					<li class="algo">
<p>
%要請 の`本体$rq %本体 を伝送する~algoは：
◎
To transmit request’s body body, run these steps:
</p>
						<ol>
							<li>
<p>
~IF［
%本体 ~EQ ~NULL
］：
</p>
								<ol>
									<li>
%要請の本体~終了~時の処理n ~LET %~fetch~params の`要請の本体~終了~時の処理n$fP
</li>
									<li>
~IF［
%要請の本体~終了~時の処理n ~NEQ ~NULL
］
⇒
`~fetch~taskを~queueする$( %要請の本体~終了~時の処理n, %~fetch~params の`~taskの行先$fP )
</li>
									<li>
~RET
</li>
								</ol>
◎
If body is null and fetchParams’s process request end-of-body is non-null, then queue a fetch task given fetchParams’s process request end-of-body and fetchParams’s task destination.
◎
Otherwise, if body is non-null:
</li>
							<li class="algo">
<p>
%本体~chunkの処理n ~LET 所与の
( %~byte列 )
に対し，次を走らす手続き：
◎
Let processBodyChunk given bytes be these steps:
</p>
								<ol>
									<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET
◎
If fetchParams is canceled, then abort these steps.
</li>
									<li class="algo">
この段は、
`並列的$に走らす
⇒
%~byte列 を伝送する
【この段は具体的に何をする？】
◎
Run this step in parallel: transmit bytes.
</li>
									<li>
%要請の本体~chunk長さの処理n ~LET %~fetch~params の`要請の本体~chunk長さの処理n$fP
◎
↓</li>
									<li>
~IF［
%要請の本体~chunk長さの処理n ~NEQ ~NULL
］
⇒
%要請の本体~chunk長さの処理n( %~byte列 の`長さ$ )
◎
If fetchParams’s process request body chunk length is non-null, then run fetchParams’s process request body chunk length given bytes’s length.
</li>
								</ol>
							</li>
							<li class="algo">
<p>
%本体~終了~時の処理n ~LET 次を走らす手続き：
◎
Let processEndOfBody be these steps:
</p>
								<ol>
									<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET
◎
If fetchParams is canceled, then abort these steps.
</li>
									<li>
%要請の本体~終了~時の処理n ~LET %~fetch~params の`要請の本体~終了~時の処理n$fP
◎
↓</li>
									<li>
~IF［
%要請の本体~終了~時の処理n ~NEQ ~NULL
］
⇒
%要請の本体~終了~時の処理n()
◎
If fetchParams’s process request end-of-body is non-null, then run fetchParams’s process request end-of-body.
</li>
								</ol>
							</li>
							<li class="algo">
<p>
%本体~errorの処理n ~LET
所与の
( %~error )
に対し，次を走らす手続き：
◎
Let processBodyError given e be these steps:
</p>
								<ol>
									<li>
~IF［
%~fetch~params は`取消された$fP
］
⇒
~RET
◎
If fetchParams is canceled, then abort these steps.
</li>
									<li>
~IF［
%~error は `AbortError$E 例外である
］
⇒
`~fetchを中止する$( %~fetch~params の`制御器$fP )
◎
If e is an "AbortError" DOMException, then abort fetchParams’s controller.
</li>
									<li>
~ELSE
⇒
`~fetchを終了する$( %~fetch~params の`制御器$fP )
◎
Otherwise, terminate fetchParams’s controller.
</li>
								</ol>
							</li>
							<li>
`本体を増分的に読取る$( ↓ )
⇒＃
%要請 の`本体$rq,
%本体~chunkの処理n,
%本体~終了~時の処理n,
%本体~errorの処理n,
%~fetch~params の`~taskの行先$fP
◎
Incrementally read request’s body given processBodyChunk, processEndOfBody, processBodyError, and fetchParams’s task destination.
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
前~段が`中止されたときは$：
◎
If aborted, then:
</p>
		<ol>
			<li>
~IF［
%接続 は~HTTP2を利用している
］
⇒
`RST_STREAM^c ~frameを伝送する
◎
If connection uses HTTP/2, then transmit an RST_STREAM frame.
</li>
			<li>
~RET `適切な~network~error$( %~fetch~params )
◎
Return the appropriate network error for fetchParams.
</li>
		</ol>
	</li>
	<li>
<p>
%~buffer ~LET 空な`~byte列$
◎
Let buffer be an empty byte sequence.
</p>

<p class="note">注記：
これは、［
~UAの~network層の内側にある内部~buffer
］を表現する。
◎
This represents an internal buffer inside the network layer of the user agent.
</p>
	</li>
	<li class="algo">
<p>
%~pull~algo ~LET 次の手続き：
◎
Let pullAlgorithm be the followings steps:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
			<li class="algo">
<p>
この段は、
`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
~IF［
%~buffer の~size ~LT ~UAが選ぶ下限
］~AND［
進行中な~fetchは`休止-$している
］
⇒
当の~fetchを`再開-$する
◎
If the size of buffer is smaller than a lower limit chosen by the user agent and the ongoing fetch is suspended, resume the fetch.
</li>
					<li>
次が満たされるまで待機する
⇒
%~buffer は空でない
◎
Wait until buffer is not empty.
</li>
					<li>
<p>
`~fetch~taskを~queueする$( 次の手続き, %~fetch~params の`~taskの行先$fP )
◎
Queue a fetch task to run the following steps, with fetchParams’s task destination.
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
						<ol>
							<li>
%~stream の中へ`~byte列から~pullする$RS( %~buffer )
◎
Pull from bytes buffer into stream.
</li>
							<li>
~IF［
%~stream は`~errorした$RS
］
⇒
`~fetchを終了する$( %~fetch~params の`制御器$fP )
◎
If stream is errored, then terminate fetchParams’s controller.
</li>
							<li>
`~promiseを解決する$( %~promise, `undefined^jv )
◎
Resolve promise with undefined.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return promise.
</li>
		</ol>
	</li>
	<li class="algo">
%取消~algo ~LET 次の手続き
⇒
`~fetchを中止する$( %~fetch~params の`制御器$fP, 所与の %事由 【？】)
◎
Let cancelAlgorithm be an algorithm that aborts fetchParams’s controller with reason, given reason.
</li>
	<li>
%~stream ~LET `新たな$ `ReadableStream$I
◎
Let stream be a new ReadableStream.
</li>
	<li>
%~stream を`~byte読取り~support付きで設定しておく$RS
— 次を与える下で
⇒＃
`~pull~algo^i ~SET %~pull~algo,
`取消~algo^i ~SET %取消~algo
◎
Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm, cancelAlgorithm set to cancelAlgorithm.
</li>
	<li>
%応答 の`本体$rs ~SET 新たな`本体$
— その
⇒
`~stream$bd ~SET %~stream
◎
Set response’s body to a new body whose stream is stream.
</li>
	<li>
◎追跡路
~IF［
%資格証を含めるか ~EQ ~T
］~AND［
~UAは %要請 用の~cookieを阻止するように環境設定されていない
（ `COOKIES$r `§ ~privacyの考慮点＠~HTTPcookie#privacy-considerations$を見よ）
］
⇒
%応答 の`~header~list$rsを成す
~EACH( `Set-Cookie$h を`名前に持つ~header$ %~header )
に対し
⇒
次を与える下で，
`COOKIES$r の
`"set-cookie-string" 構文解析~algo＠~HTTPcookie#set-cookie$を走らす
⇒
( %~header の`値$hd, %要請 の`現在の~URL$rq )
◎
(This is a tracking vector.)
If includeCredentials is true and the user agent is not configured to block cookies for request (see section 7 of [COOKIES]), then run the "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on the value of each header whose name is a byte-case-insensitive match for `Set-Cookie` in response’s header list, if any, and request’s current URL.
</li>
	<li class="algo">
<p>
この段は、
`並列的$に走らす：
◎
Run these steps in parallel:
</p>
		<ol>
			<li>
<p>
この段の中は、
%~fetch~params が`取消された$fP`ときは中止する$：
◎
Run these steps, but abort when fetchParams is canceled:
</p>
<p>
~WHILE 無条件：
◎
While true:
</p>
				<ol>
					<li>
<p>
~IF［
%応答 の`内容$から 1 個 以上の~byteが伝送された
］：
◎
If one or more bytes have been transmitted from response’s message body, then:
</p>
						<ol>
							<li>
%~byte列 ~LET 伝送された~byte列
◎
Let bytes be the transmitted bytes.
</li>
							<li>
%符号法s ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Content-Encoding$h )
◎
Let codings be the result of extracting header list values given `Content-Encoding` and response’s header list.
</li>
							<li>
%応答 の`本体~報$rsの`符号化された~size$fT ~INCBY %~byte列 の`長さ$
◎
Increase response’s body info’s encoded size by bytes’s length.
</li>
							<li>
<p>
%~byte列 ~SET `内容~符号法sを取扱う$( %符号法s, %~byte列 )
◎
Set bytes to the result of handling content codings given codings and bytes.
</p>

<p class="note">注記：
これは、
依拠-可能であった `Content-Length^h `~header$を依拠-不能にする。
◎
This makes the `Content-Length` header unreliable to the extent that it was reliable to begin with.
</p>
							</li>
							<li>
%応答 の`本体~報$rsの`復号した~size$fT ~INCBY %~byte列 の`長さ$
◎
Increase response’s body info’s decoded size by bytes’s length.
</li>
							<li>
~IF［
%~byte列 ~EQ `失敗^i
］
⇒
`~fetchを終了する$( %~fetch~params の`制御器$fP )
◎
If bytes is failure, then terminate fetchParams’s controller.
</li>
							<li>
%~buffer に %~byte列 を付加する
◎
Append bytes to buffer.
</li>
							<li>
~IF［
%~buffer の~size ~GT ~UAが選ぶ上限
］
⇒
進行中な~fetchを`休止-$するよう，~UAに依頼する
◎
If the size of buffer is larger than an upper limit chosen by the user agent, ask the user agent to suspend the ongoing fetch.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%応答 の`内容$用の~byte列の伝送は，正常に終えられた
］
⇒
~IF［
%~stream は`読取n可能$RSである
］
⇒＃
%~stream を`~closeする$RS()；
~BREAK
◎
Otherwise, if the bytes transmission for response’s message body is done normally and stream is readable, then close stream, and abort these in-parallel steps.
</li>
				</ol>
			</li>
			<li>
<p>
前~段が`中止されたときは$：
◎
If aborted, then:
</p>
				<ol>
					<li>
<p>
~IF［
%~fetch~params は`中止された$fP
］：
◎
If fetchParams is aborted, then:
</p>
						<ol>
							<li>
%応答 の`中止されたか$rs ~SET ~T
◎
Set response’s aborted flag.
</li>
							<li>
<p>
~IF［
%~stream は`読取n可能$RSである
］：
</p>
								<ol>
									<li>
%~error ~LET `直列化された中止-事由を逆直列化する$( %~fetch~params の`制御器$fPの`直列化された中止-事由$, `実装定義$な`~realm$ )
</li>
									<li>
%~stream を`~errorにする$RS( %~error )
</li>
								</ol>
◎
If stream is readable, then error stream with the result of deserialize a serialized abort reason given fetchParams’s controller’s serialized abort reason and an implementation-defined realm.
</li>
						</ol>
					</li>
					<li>
~ELIF［
%~stream は`読取n可能$RSである
］
⇒
%~stream を`~errorにする$RS( `TypeError$E )
◎
Otherwise, if stream is readable, error stream with a TypeError.
</li>
					<li>
~IF［
%接続 は~HTTP2を利用している
］
⇒
`RST_STREAM^c ~frameを伝送する
◎
If connection uses HTTP/2, then transmit an RST_STREAM frame.
</li>
					<li>
<p>
~ELSE
⇒
~UAは接続を~closeするベキである
— そうすると処理能が悪化するときは除いて
◎
Otherwise, the user agent should close connection unless it would be bad for performance to do so.
</p>

<p class="note">注記：
一例として，~UAは、
再利用-可能な接続にて，伝送する~byte数が残りわずかしかないと知るならば、
接続を~openしたまま保つこともできる。
この事例では、
接続を~closeして 次の~fetch用に~handshake処理-をやり直すと，悪化することもあるので。
◎
For instance, the user agent could keep the connection open if it knows there’s only a few bytes of transfer remaining on a reusable connection. In this case it could be worse to close the connection and go through the handshake process again for the next fetch.
</p>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
この段を`並列的$に走らせているのは、
この時点では， %応答 の`本体$rsが関連するかどうか明瞭でないためである
（ %応答 は~redirectかもしれない）。
◎
These are run in parallel as at this point it is unclear whether response’s body is relevant (response might be a redirect).
</p>
	</li>
	<li>
<p>
~RET %応答
</p>

<p class="note">注記：
手続きはここで終わるが、
その後も概して，
%応答 の`本体$rsの`~stream$bdには~enqueueされ続ける。
</p>
◎
Return response. Typically response’s body’s stream is still being enqueued to after returning.
</li>
</ol>
</div>

		</section>
		<section id="cors-preflight-fetch">
<h3 title="CORS-preflight fetch">4.7. ~CORS予行~fetch</h3>

<p class="note">注記：
これは、
実質的には，`~CORS~protocol$が解されるか否か見るための~UA実装であり、
`~CORS予行~要請$と呼ばれている。
成功したときは、
`~CORS予行~fetch$の回数を最小限にするために，`~CORS予行~cache$を拡充する。
◎
This is effectively the user agent implementation of the check to see if the CORS protocol is understood. The so-called CORS-preflight request. If successful it populates the CORS-preflight cache to minimize the number of these fetches.
</p>

<div class="algo">
<p>
`~CORS予行~fetch@
を遂行する
~algoは、
所与の
( `要請$ %要請 )
に対し：
◎
To CORS-preflight fetch, given a request request, run these steps:
</p>
<ol>
	<li>
<p>
%予行 ~LET 新たな`要請$
— その
⇒＃
`~method$rq ~SET `OPTIONS$hm,
`~URL~list$rq ~SET %要請 の`~URL~list$rqを`~cloneする$,
`起動元$rq ~SET %要請 の`起動元$rq,
`行先$rq ~SET %要請 の`行先$rq,
`生成元$rq ~SET %要請 の`生成元$rq,
`~referrer$rq ~SET %要請 の`~referrer$rq,
`~referrer施策$rq ~SET %要請 の`~referrer施策$rq,
`~mode$rq ~SET `cors^l,
`応答~tainting$rq ~SET `cors^l
◎
Let preflight be a new request whose method is `OPTIONS`, URL list is a clone of request’s URL list, initiator is request’s initiator, destination is request’s destination, origin is request’s origin, referrer is request’s referrer, referrer policy is request’s referrer policy, mode is "cors", and response tainting is "cors".
</p>

<p class="note">注記：
%予行 の`~sw~mode$rqは問われない
— この~algoは、
`~HTTP~fetch$ではなく，
`~HTTP~network-or-cache~fetch$を利用するので。
◎
The service-workers mode of preflight does not matter as this algorithm uses HTTP-network-or-cache fetch rather than HTTP fetch.
</p>
	</li>
	<li>
%予行 の`~header~list$rqに`~headerを付加する$(
( `Accept$h, `*/*^bl )
)
◎
Append (`Accept`, `*/*`) to preflight’s header list.
</li>
	<li>
%予行 の`~header~list$rqに`~headerを付加する$(
( `Access-Control-Request-Method$h, %要請 の`~method$rq )
)
◎
Append (`Access-Control-Request-Method`, request’s method) to preflight’s header list.
</li>
	<li>
%~header群 ~LET
`~CORS安全でない要請~header名たち$( %要請 の`~header~list$rq )
◎
Let headers be the CORS-unsafe request-header names with request’s header list.
</li>
	<li>
<p>
~IF［
%~header群 は`空$でない
］：
◎
If headers is not empty, then:
</p>
		<ol>
			<li>
%値 ~LET %~header群 を成す各~itemを順に， `,^bl で分離して~~連結した結果
◎
Let value be the items in headers separated from each other by `,`.
</li>
			<li>
%予行 の`~header~list$rqに`~headerを付加する$(
( `Access-Control-Request-Headers$h, %値 )
)
◎
Append (`Access-Control-Request-Headers`, value) to preflight’s header list.
</li>
		</ol>
<p class="note">注記：
ここで`~headerを結合する$を利用しないのは意図的である。
これは［
`2C^X `20^X
］並びによる仕方で実装されてはいないので
— 功罪はあれど。
◎
This intentionally does not use combine, as 0x20 following 0x2C is not the way this was implemented, for better or worse.
</p>
	</li>
	<li>
%予行~fetch~params ~LET 新たな`~fetch~params$
— その
⇒＃
`要請$fP ~SET %予行
◎
↓</li>
	<li>
%応答 ~LET `~HTTP~network-or-cache~fetch$( %予行~fetch~params )
◎
Let response be the result of running HTTP-network-or-cache fetch given a new fetch params whose request is preflight.
</li>
	<li>
<p>
~IF［
`~CORS検査$( %要請, %応答 ) ~EQ `成功^i
］~AND［
%応答 の`状態s$rs は`~ok状態s$である
］：
◎
If a CORS check for request and response returns success and response’s status is an ok status, then:
</p>

<p class="note">注記：
正しい`資格証~mode$rqの利用を確保するため、
`~CORS検査$は， %予行 ではなく %要請 に対して行う。
◎
The CORS check is done on request rather than preflight to ensure the correct credentials mode is used.
</p>
		<ol>
			<li>
%~method群 ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Allow-Methods$h )
◎
Let methods be the result of extracting header list values given `Access-Control-Allow-Methods` and response’s header list.
</li>
			<li>
%~header名~群 ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Allow-Headers$h )
◎
Let headerNames be the result of extracting header list values given `Access-Control-Allow-Headers` and response’s header list.
</li>
			<li>
~IF［
%~method群 ~EQ `失敗^i
］~OR［
%~header名~群 ~EQ `失敗^i
］
⇒
~RET `~network~error$
◎
If either methods or headerNames is failure, return a network error.
</li>
			<li>
<p>
~IF［
%~method群 ~EQ ~NULL
］~AND［
`~CORS予行を利用するか$rq ~EQ ~T
］
⇒
%~method群 ~SET « %要請 の`~method$rq »
◎
If methods is null and request’s use-CORS-preflight flag is set, then set methods to a new list containing request’s method.
</p>

<p class="note">注記：
これにより、
単に［
%要請 の`~CORS予行を利用するか$rq ~EQ ~T
］であることに因り生じる`~CORS予行~fetch$も，`~cacheされる＠#concept-cache$。
◎
This ensures that a CORS-preflight fetch that happened due to request’s use-CORS-preflight flag being set is cached.
</p>
			</li>
			<li>
~IF［
%要請 の`~method$rq ~NIN %~method群
］~AND［
%要請 の`~method$rqは`~CORS安全とされる~method$でない
］~AND［［
%要請 の`資格証~mode$rq ~EQ `include^l
］~OR［
`*^bl ~NIN %~method群
］］
⇒
~RET `~network~error$
◎
If request’s method is not in methods, request’s method is not a CORS-safelisted method, and request’s credentials mode is "include" or methods does not contain `*`, then return a network error.
</li>
			<li>
<p>
%要請 の`~header~list$rqを成す
~EACH( %~header )
に対し：
</p>
				<ol>
					<li>
~IF［
%~header は %~header名~群 を成すある名前を`名前に持つ~header$である
］
⇒
~CONTINUE
</li>
					<li>
~IF［
%~header は ある`~CORS非~wildcard要請~header名$を`名前に持つ~header$である
］
⇒
~RET `~network~error$
</li>
				</ol>
◎
If one of request’s header list’s names is a CORS non-wildcard request-header name and is not a byte-case-insensitive match for an item in headerNames, then return a network error.
</li>
			<li>
~IF［
%要請 の`資格証~mode$rq ~EQ `include^l
］~OR［
`*^bl ~NIN %~header名~群
］
⇒
`~CORS安全でない要請~header名たち$( %要請 の`~header~list$rq )
を成す
~EACH( %安全でない~header名 )
に対し
⇒
%~header名~群 を成す
~EACH( %~header名 )
に対し
⇒
~IF［
( %安全でない~header名, %~header名 )
は`~byte大小無視$で合致する
］
⇒
~RET `~network~error$
◎
For each unsafeName of the CORS-unsafe request-header names with request’s header list, if unsafeName is not a byte-case-insensitive match for an item in headerNames and request’s credentials mode is "include" or headerNames does not contain `*`, return a network error.
</li>
			<li>
%寿命 ~LET `~header~listから値を抽出する$( %応答 の`~header~list$rs, `Access-Control-Max-Age$h )
◎
Let max-age be the result of extracting header list values given `Access-Control-Max-Age` and response’s header list.
</li>
			<li>
~IF［
%寿命 ~IN { `失敗^i, ~NULL }
］
⇒
%寿命 ~SET 5
◎
If max-age is failure or null, then set max-age to 5.
</li>
			<li>
~IF［
%寿命 ~GT 環境により課される`寿命$ccの上限
］
⇒
%寿命 ~SET その上限
◎
If max-age is greater than an imposed limit on max-age, then set max-age to the imposed limit.
</li>
			<li>
~IF［
~UAは`~CORS予行~cache$を供していない
］
⇒
~RET %応答
◎
If the user agent does not provide for a cache, then return response.
</li>
			<li>
<p>
%~method群 を成す
~EACH( %~method )
に対し：
</p>
				<ol>
					<li>
%~entry群 ~LET `~methodも合致している~cache~entry$( %要請, %~method )
</li>
					<li>
~IF［
%~entry群 は空でない
］
⇒
%~entry群 を成す
~EACH( %~entry )
に対し
⇒
%~entry の`寿命$cc ~SET %寿命
</li>
					<li>
~ELSE
⇒
`新たな~cache~entryを作成する$( %要請, %寿命, %~method, ~NULL )
</li>
				</ol>
◎
For each method in methods for which there is a method cache entry match using request, set matching entry’s max-age to max-age.
◎
For each method in methods for which there is no method cache entry match using request, create a new cache entry with request, max-age, method, and null.
</li>
			<li>
<p>
%~header名~群 を成す
~EACH( %~header名 )
に対し：
</p>
				<ol>
					<li>
%~entry群 ~LET `~header名も合致している~cache~entry$( %要請, %~header名 )
</li>
					<li>
~IF［
%~entry群 ~NEQ ε
］
⇒
%~entry群 を成す
~EACH( %~entry )
に対し
⇒
%~entry の`寿命$cc ~SET %寿命
</li>
					<li>
<p>
~ELSE
⇒
`新たな~cache~entryを作成する$( %要請, %寿命, ~NULL, %~header名 )
</li>
				</ol>
◎
For each headerName in headerNames for which there is a header-name cache entry match using request, set matching entry’s max-age to max-age.
◎
For each headerName in headerNames for which there is no header-name cache entry match using request, create a new cache entry with request, max-age, null, and headerName.
</li>
			<li>
~RET %応答
◎
Return response.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET `~network~error$
◎
Otherwise, return a network error.
</li>
</ol>
</div>

		</section>
		<section id="cors-preflight-cache">
<h3 title="CORS-preflight cache">4.8. ~CORS予行~cache</h3>

<p>
各~UAは、
`~CORS予行~cache@
を持つ
— それは、
`~cache~entry$たちが成す`~list$である。
◎
A user agent has an associated CORS-preflight cache. A CORS-preflight cache is a list of cache entries.
</p>

<p>
各
`~cache~entry@
は、
次に挙げるものからなる：
◎
A cache entry consists of:
</p>
<ul>
	<li>
`~key@cc
⇒
`~network区分~key$
◎
key (a network partition key)
</li>
	<li>
`~byte直列化した生成元@cc
⇒
`~byte列$
◎
byte-serialized origin (a byte sequence)
</li>
	<li>
`~URL@cc
⇒
`~URL$
◎
URL (a URL)
</li>
	<li>
`寿命@cc
⇒
秒数
◎
max-age (a number of seconds)
</li>
	<li>
`資格証の有無@cc
⇒
`有り^i ／ `無し^i
◎
credentials (a boolean)
</li>
	<li>
`~method@cc
⇒
~NULL ／
`*^bl ／
`~method$
◎
method (null, `*`, or a method)
</li>
	<li>
`~header名@cc
⇒
~NULL ／
`*^bl ／
`~header名$
◎
header name (null, `*`, or a header name)
</li>
</ul>

<p class="trans-note">【
`~method$ccと`~header名$ccは，両立しない~fieldであり、
常に，
一方は ~NULL,
他方は非 ~NULL になる。
】</p>

<p>
`~cache~entry$は、
格納されてから`寿命$ccに指定された秒数だけ過ぎた時点で，除去するモノトスル
— その時点が来る前に除去してもヨイ。
◎
Cache entries must be removed after the seconds specified in their max-age field have passed since storing the entry. Cache entries may be removed before that moment arrives.
</p>

<div class="algo">
<p>
`新たな~cache~entryを作成する@
~algoは、
所与の
( %要請, %寿命, %~method, %~header名 )
に対し：
◎
To create a new cache entry, given request, max-age, method, and headerName, run these steps:
</p>
<ol>
	<li>
%~entry ~LET 新たな`~cache~entry$
— その
⇒＃
`~key$cc ~SET `要請の~network区分~keyを決定する$( %要請 ),
`~byte直列化した生成元$cc ~SET `要請の生成元を~byte直列化する$( %要請 ),
`~URL$cc ~SET %要請 の`現在の~URL$rq,
`寿命$cc ~SET %寿命,
`資格証の有無$cc ~SET ［%要請 の`資格証~mode$rq ~EQ `include^l ならば `有り^i ／ ~ELSE_ `無し^i ］,
`~method$cc ~SET %~method,
`~header名$cc ~SET %~header名
◎
Let entry be a cache entry, initialized as follows:
◎
key
• The result of determining the network partition key given request
byte-serialized origin
• The result of byte-serializing a request origin with request
URL
• request’s current URL
max-age
• max-age
credentials
• True if request’s credentials mode is "include", and false otherwise
method
• method
header name
• headerName
</li>
	<li>
`~CORS予行~cache$に［
新たな`~cache~entry$
］を`付加する$
◎
Append entry to the user agent’s CORS-preflight cache.
</li>
</ol>
</div>

<div class="algo">
<p>
`~cache~entryを~clearする@
~algoは、
所与の
( %要請 )
に対し：
</p>
<ol>
	<li>
<p>
~UAの`~CORS予行~cache$から， ~AND↓ を満たす`~cache~entry$をすべて除去する：
</p>
		<ul>
			<li>
`~key$cc ~EQ `要請の~network区分~keyを決定する$( %要請 )
</li>
			<li>
`~byte直列化した生成元$cc ~EQ `要請の生成元を~byte直列化する$( %要請 )
</li>
			<li>
`~URL$cc ~EQ %要請 の`現在の~URL$rq
</li>
		</ul>
	</li>
</ol>
◎
To clear cache entries, given a request, remove any cache entries in the user agent’s CORS-preflight cache whose key is the result of determining the network partition key given request, byte-serialized origin is the result of byte-serializing a request origin with request, and URL is request’s current URL.
</div>

<p>
~AND↓ を満たす`~cache~entry$は、
%要請 に
`~cache合致する@
とされる：
◎
There is a cache entry match for a cache entry entry with request if＼
</p>
<ul>
	<li>
`~key$cc ~EQ `要請の~network区分~keyを決定する$( %要請 )
◎
entry’s key is the result of determining the network partition key given request,＼
</li>
	<li>
`~byte直列化した生成元$cc ~EQ `要請の生成元を~byte直列化する$( %要請 )
◎
entry’s byte-serialized origin is the result of byte-serializing a request origin with request,＼
</li>
	<li>
`~URL$cc ~EQ %要請 の`現在の~URL$rq
◎
entry’s URL is request’s current URL,＼
</li>
	<li>
［
`資格証の有無$cc ~EQ `有り^i
］~OR［［
`資格証の有無$cc ~EQ `無し^i
］~AND［
%要請 の`資格証~mode$rq ~NEQ `include^l
］］
◎
and one of
• entry’s credentials is true
• entry’s credentials is false and request’s credentials mode is not "include".
is true.
</li>
</ul>

<div class="algo">
<p>
`~methodも合致している~cache~entry@
は、
所与の
( %要請, %~method )
に対し，~UAの`~CORS予行~cache$内にある，次を満たす`~cache~entry$たちが成す集合を返す
⇒
［
%要請 に`~cache合致する$
］~AND［
`~method$cc ~IN { %~method, `*^bl }
］
◎
There is a method cache entry match for method using request when there is a cache entry in the user agent’s CORS-preflight cache for which there is a cache entry match with request and its method is method or `*`.
</p>

<p class="trans-note">【†
原文からは、
該当する~entryは高々 1 個のように解釈できそうだが，
複数あり得るかもしれない
— はっきりしないので、
この用語を利用している箇所も含め，複数あり得るとみなして訳している。
次の用語も同様。
】</p>
</div>

<div class="algo">
<p>
`~header名も合致している~cache~entry@
は、
所与の
( %要請, %~header名 )
に対し，~UAの`~CORS予行~cache$内にある，次を満たす`~cache~entry$たちが成す集合を返す
⇒
［
%要請 に`~cache合致する$
］~AND［
( ~entryの`~header名$cc %名前, %~header名 )
は ~OR↓ を満たす
］：
◎
There is a header-name cache entry match for headerName using request when there is a cache entry in the user agent’s CORS-preflight cache for which there is a cache entry match with request and＼
</p>

<div class="p">
<ul>
	<li>
%名前 は %~header名 に`~byte大小無視$で合致する
</li>
	<li>
［
%名前 ~EQ `*^bl
］~AND［
%~header名 は`~CORS非~wildcard要請~header名$でない
］
</li>
</ul>

◎
one of
• its header name is a byte-case-insensitive match for headerName
• its header name is `*` and headerName is not a CORS non-wildcard request-header name
is true.
</div>
</div>

		</section>
		<section id="cors-check">
<h3 title="CORS check">4.9. ~CORS検査</h3>

<div class="algo">
<p>
`~CORS検査@
を遂行する
~algoは、
所与の
( %要請, %応答 )
に対し：
◎
To perform a CORS check for a request and response, run these steps:
</p>
<ol>
	<li>
%生成元 ~LET `~header~listから値を取得する$( %応答 の`~header~list$rs, `Access-Control-Allow-Origin$h )
◎
Let origin be the result of getting `Access-Control-Allow-Origin` from response’s header list.
</li>
	<li>
<p>
~IF［
%生成元 ~EQ ~NULL
］
⇒
~RET `失敗^i
◎
If origin is null, then return failure.
</p>

<p class="note">注記：
~NULL は `null^bl でないことに注意。
◎
Null is not `null`.
</p>
	</li>
	<li>
~IF［
%要請 の`資格証~mode$rq ~NEQ `include^l
］~AND［
%生成元 ~EQ `*^bl
］
⇒
~RET `成功^i
◎
If request’s credentials mode is not "include" and origin is `*`, then return success.
</li>
	<li>
~IF［
`要請の生成元を~byte直列化する$( %要請 ) ~NEQ %生成元
］
⇒
~RET `失敗^i
◎
If the result of byte-serializing a request origin with request is not origin, then return failure.
</li>
	<li>
~IF［
%要請 の`資格証~mode$rq ~NEQ `include^l
］
⇒
~RET `成功^i
◎
If request’s credentials mode is not "include", then return success.
</li>
	<li>
%資格証を伴うか ~LET `~header~listから値を取得する$( %応答 の`~header~list$rs, `Access-Control-Allow-Credentials$h )
◎
Let credentials be the result of getting `Access-Control-Allow-Credentials` from response’s header list.
</li>
	<li>
~IF［
%資格証を伴うか ~EQ `true^bl
］
⇒
~RET `成功^i
◎
If credentials is `true`, then return success.
</li>
	<li>
~RET `失敗^i
◎
Return failure.
</li>
</ol>
</div>

		</section>
		<section id="tao-check">
<h3 title="TAO check">4.10. ~TAO検査</h3>

<p class="trans-note">【
~TAOは `Timing-Allow-Origin$h （計時を許容する生成元）の略称。
】</p>

<p>
`~TAO検査@
を遂行する
~algoは、
所与の
( %要請, %応答 )
に対し：
◎
To perform a TAO check for a request and response, run these steps:
</p>
<ol>
	<li>
~Assert：
%要請 の`生成元$rq ~NEQ `client^l
◎
Assert: request’s origin is not "client".
</li>
	<li>
~IF［
%要請 の`計時許容に失敗したか$rq ~EQ ~T
］
⇒
~RET `失敗^i
◎
If request’s timing allow failed flag is set, then return failure.
</li>
	<li>
%値~群 ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `Timing-Allow-Origin$h )
◎
Let values be the result of getting, decoding, and splitting `Timing-Allow-Origin` from response’s header list.
</li>
	<li>
~IF［
`*^l ~IN %値~群
］
⇒
~RET `成功^i
◎
If values contains "*", then return success.
</li>
	<li>
~IF［
`要請の生成元を直列化する$( %要請 ) ~IN %値~群
］
⇒
~RET `成功^i
◎
If values contains the result of serializing a request origin with request, then return success.
</li>
	<li>
<p>
~IF［
%要請 の`~mode$rq ~EQ `navigate^l
］~AND［
%要請 の`現在の~URL$rqの`生成元$url
~NEQ`生成元$sub
%要請 の`生成元$rq
］
⇒
~RET `失敗^i
◎
If request’s mode is "navigate" and request’s current URL’s origin is not same origin with request’s origin, then return failure.
</p>

<p class="note">注記：
これは、
`子~navigable$【！nested navigable】の~navi用に必要yである。
そこでは、
%要請 の`生成元$rqは容器~文書の`生成元$docになり，
`~TAO検査$は失敗を返すことになる。
~navi計時は`~TAO検査$の結果を決して検証しないので、
入子な文書は，全部的な計時~情報への~accessを依然として有することになる一方で、
容器~文書は，そうならない。
◎
This is necessary for navigations of a nested navigable. There, request’s origin would be the container document’s origin and the TAO check would return failure. Since navigation timing never validates the results of the TAO check, the nested document would still have access to the full timing information, but the container document would not.
</p>
	</li>
	<li>
~IF［
%要請 の`応答~tainting$rq ~EQ `basic^l
］
⇒
~RET `成功^i
◎
If request’s response tainting is "basic", then return success.
</li>
	<li>
~RET `失敗^i
◎
Return failure.
</li>
</ol>

		</section>
	</section>
	<section id="fetch-api">
<h2 title="Fetch API">5. ~fetch~API</h2>

<p class="note">注記：
`fetch()$m ~methodは、
資源を`~fetch$するための比較的 低~levelな~APIであり，
`XMLHttpRequest$I より少しばかり土台を受持つ
— 現時点では、
要請の進捗（応答の進捗ではなく）がいつ来るか【を~~報告する~~機能】を欠いているが。
◎
The fetch() method is relatively low-level API for fetching resources. It covers slightly more ground than XMLHttpRequest, although it is currently lacking when it comes to request progression (not response progression).
</p>

<div class="example" id="fetch-blob-example">
<p>
`fetch()$m ~methodは、
ごく単直に，資源を`~fetch$した上で その内容を `Blob$I として抽出する：
◎
The fetch() method makes it quite straightforward to fetch a resource and extract its contents as a Blob:
</p>

<pre class="lang-js">
fetch(`/music/pk/altes-kamuffel.flac^l)
  .then(%res =&gt; %res.blob()).then(%playBlob);
</pre>

<p>
特定0の応答~headerの~logをとりたいだけなら：
◎
If you just care to log a particular response header:
</p>

<pre class="lang-js">
fetch(`/^l, {method:`HEAD^l})
  .then(%res =&gt; log(%res.headers.get(`strict-transport-security^l)));
</pre>

<p>
特定0の応答~headerを検査してから，非同一-生成元の資源を成す応答を処理するよう求めるなら：
◎
If you want to check a particular response header and then process the response of a cross-origin resource:
</p>

<pre class="lang-js">
fetch(`https://pk.example/berlin-calling.json^l, {mode:`cors^l})
  .then(%res =&gt; {
    if(%res.headers.get(`content-type^l) && (
       %res.headers.get(`content-type^l)
         .toLowerCase()
         .indexOf(`application/json^l) &gt;= 0
      )
    ) {
      return %res.json();
    } else {
      throw new TypeError();
    }
  }).then(processJSON);
</pre>

<p>
~URL~query~parameterで作業するよう求めるなら：
◎
If you want to work with URL query parameters:
</p>

<pre class="lang-js">
var %url = new URL(`https://geo.example.org/api^l),
    %params = {lat:35.696233, long:139.570431};
Object.keys(%params).forEach(
    %key =&gt; %url.searchParams.append(%key, params[%key])
);
fetch(%url).then(/* … */);
</pre>

<p>
本体~dataを漸進的に受信するよう求めるなら：
◎
If you want to receive the body data progressively:
</p>

<pre class="lang-js">
function consume(%reader) {
  var %total = 0
  return pump();

  function pump() {
    return %reader.read().then(({%done, %value}) =&gt; {
      if (%done) {
        return;
      }
      %total += %value.byteLength;
      log(``^受信した~byte数 ${%value.byteLength} （総~byte数 ${%total} ）``^
      );
      return pump();
    })
  }
}

fetch(`/music/pk/altes-kamuffel.flac^l)
  .then(%res =&gt; consume(%res.body.getReader()))
  .then( () =&gt; log(
    `~memory内に全部~~貯めこむことなく，本体~全体を消費できました！^l
  ))
  .catch(%e =&gt; log(`何かまずいことが起きました： ^l + %e))
</pre>
<!-- 
received ${value.byteLength} bytes (${total} bytes in total)
"consumed the entire body without keeping the whole thing in memory!"
"something went wrong: "
-->
</div>

		<section id="headers-class">
<h3 title="Headers class">5.1. `Headers^I ~class</h3>

<pre class="idl">
typedef (
   `sequence$&lt;`sequence$&lt;`ByteString$&gt;&gt;
   or `record$&lt;`ByteString$, `ByteString$&gt;
) `HeadersInit@I;

[`Exposed$=(Window,Worker)]
interface `Headers@I {
  `Headers$mc(optional `HeadersInit$I %init);

  `undefined$ `append$m(`ByteString$ %name, `ByteString$ %value);
  `undefined$ `delete$m(`ByteString$ %name);
  `ByteString$? `get$m(`ByteString$ %name);
  `sequence$&lt;`ByteString$&gt; `getSetCookie$m();
  `boolean$ `has$m(`ByteString$ %name);
  `undefined$ `set$m(`ByteString$ %name, `ByteString$ %value);
  `iterable$m&lt;`ByteString$, `ByteString$&gt;;
};
</pre>

<p>
各 `Headers$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
<p>
`~header~list@Hl
⇒
`~header~list$
— 初期~時は空
◎
A Headers object has an associated header list (a header list), which is initially empty.＼
</p>

<p class="note">注記：
これは、
何か他の~objの`~header~list$を指すこともある。
例えば `Request$I ~objの`要請$のそれを指すなど。
◎
This can be a pointer to the header list of something else, e.g., of a request as demonstrated by Request objects.
</p>
	</li>
	<li>
<p>
`~guard@Hl
⇒
`~Headers用の~guard$
</p>
◎
A Headers object also has an associated guard, which is a headers guard.＼
</li>
</ul>

<p>
`~Headers用の~guard@
は、
次に挙げるいずれかである
⇒＃
`immutable^l,
`request^l,
`request-no-cors^l,
`response^l,
`none^l
◎
A headers guard is "immutable", "request", "request-no-cors", "response" or "none".
</p>

<hr>

<dl class="domintro">

	<dt>%headers = `new Headers([init])$m</dt>
	<dd>
新たな `Headers$I ~objを作成する。
%init を利用して，その内部の~header~listを埋めれる
— 下の例のように。
◎
Creates a new Headers object. init can be used to fill its internal header list, as per the example below.
</dd>
	<dd class="example">
<pre>
const %meta = { "Content-Type": "text/xml", "Breaking-Bad": "&lt;3" };
new Headers(%meta);

/* <span class="comment">
上の~codeは、
次と等価になる：
◎
The above is equivalent to
</span> */
const %meta2 = [
  [ "Content-Type", "text/xml" ],
  [ "Breaking-Bad", "&lt;3" ]
];
new Headers(%meta2);
</pre>
	</dd>

	<dt>%headers . `append(name, value)$m</dt>
	<dd>
%headers に~headerを付加する。
◎
Appends a header to headers.
</dd>

	<dt>%headers . `delete(name)$m</dt>
	<dd>
%headers から~headerを除去する。
◎
Removes a header from headers.
</dd>

	<dt>%headers . `get(name)$m</dt>
	<dd>
%name を名前に持つ~headerすべての値を［
~commaと~space
］で分離した文字列として返す。
◎
Returns as a string the values of all headers whose name is name, separated by a comma and a space.
</dd>

	<dt>%headers . `getSetCookie()$m</dt>
	<dd>
`Set-Cookie$h を名前に持つ~headerすべての値たちが成す~listを返す。
◎
Returns a list of the values for all headers whose name is `Set-Cookie`.
</dd>

	<dt>%headers . `has(name)$m</dt>
	<dd>
%name を名前に持つ~headerは在るかどうかを返す。
◎
Returns whether there is a header whose name is name.
</dd>

	<dt>%headers . `set(name, value)$m</dt>
	<dd>
%name を名前に持つ~headerのうち，最初の~headerの値を置換して残りは除去する。
◎
Replaces the value of the first header whose name is name with value and removes any remaining headers whose name is name.
</dd>

	<dt>for(const [%name, %value] of %headers)</dt>
	<dd>
%headers は反復できる（ `iterable$m ）。
◎
headers can be iterated over.
</dd>
</dl>

<hr>

<div class="algo">
<p>
`~guardで検証する@
~algoは、
所与の
( `~byte列$ %名前, `~byte列$ %値, `Headers$I ~obj %headers )
に対し：
◎
To validate a header (name, value) for a Headers object headers:
</p>
<ol>
	<li>
~IF［
%名前 は`~header名$でない
］~OR［
%値 は`~header値$でない
］
⇒
~THROW `TypeError$E
◎
If name is not a header name or value is not a header value, then throw a TypeError.
</li>
	<li>
<p>
%headers の`~guard$Hlに応じて：
</p>
		<ul class="switch">
			<li>
`immutable^l
⇒
~THROW `TypeError$E
</li>
			<li>
`request^l
⇒
~IF［
( %名前, %値 )
は`禁止~要請~header$を成す
］
⇒
~RET ~F
</li>
			<li>
`response^l
⇒
~IF［
%名前 は`禁止~応答~header名$である
］
⇒
~RET ~F
</li>
			<li>
`request-no-cors^l
⇒
何もしない†
◎
↓</li>
		</ul>
◎
If headers’s guard is "immutable", then throw a TypeError.
◎
If headers’s guard is "request" and (name, value) is a forbidden request-header, then return false.
◎
If headers’s guard is "response" and name is a forbidden response-header name, then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>

<p class="note">† 注記：
`request-no-cors^l に対しては、
この~algoとは別々に検証される
— 事例ごとに処理法が異なるので。
◎
Steps for "request-no-cors" are not shared as you cannot have a fake value (for delete()) that always succeeds in CORS-safelisted request-header.
</p>
</div>

<div class="algo">
<p>
`Headers$I ~obj %headers に
`~headerを付加する@Hl
~algoは、
所与の
( `~byte列$ %名前, `~byte列$ %値 )
に対し：
◎
To append a header (name, value) to a Headers object headers, run these steps:
</p>
<ol>
	<li>
%値 ~SET `値を正規化する$( %値 )
◎
Normalize value.
</li>
	<li>
~IF［
`~guardで検証する$( %名前, %値, %headers ) ~EQ ~F
］
⇒
~RET
◎
If validating (name, value) for headers returns false, then return.
</li>
	<li>
<p>
~IF［
%headers の`~guard$Hl ~EQ `request-no-cors^l
］：
◎
If headers’s guard is "request-no-cors":
</p>
		<ol>
			<li>
%一時的な値 ~LET `~header~listから値を取得する$( %headers の`~header~list$Hl, %名前 )
◎
Let temporaryValue be the result of getting name from headers’s header list.
</li>
			<li>
~IF［
%一時的な値 ~EQ ~NULL
］
⇒
%一時的な値 ~SET %値
◎
If temporaryValue is null, then set temporaryValue to value.
</li>
			<li>
~ELSE
⇒
%一時的な値 に次を順に付加する
⇒＃
`2C^X,
`20^X,
%値
◎
Otherwise, set temporaryValue to temporaryValue, followed by 0x2C 0x20, followed by value.
</li>
			<li>
~IF［
( %名前, %一時的な値 )
は`~CORSなしで安全とされる要請~header$を成さない
］
⇒
~RET
◎
If (name, temporaryValue) is not a no-CORS-safelisted request-header, then return.
</li>
		</ol>
	</li>
	<li>
%headers の`~header~list$Hlに`~headerを付加する$(
( %名前, %値 )
)
◎
Append (name, value) to headers’s header list.
</li>
	<li>
~IF［
%headers の`~guard$Hl ~EQ `request-no-cors^l
］
⇒
%headers から`特権的~CORSなし要請~headerを除去する$
◎
If headers’s guard is "request-no-cors", then remove privileged no-CORS request-headers from headers.
</li>
</ol>
</div>

<div class="algo">
<p>
`Headers$I ~obj %headers を
`~objで埋める@
~algoは、
所与の
( ~obj %~obj )
に対し：
◎
To fill a Headers object headers with a given object object, run these steps:
</p>
<ol>
	<li>
<p>
~IF［
%~obj は~IDL`連列~型$である
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~obj を成す
~EACH( %~header )
に対し：
◎
If object is a sequence, then for each header of object:
</p>
				<ol>
					<li>
~IF［
%~header の`~size$ ~NEQ 2
］
⇒
~THROW `TypeError$E
◎
If header’s size is not 2, then throw a TypeError.
</li>
					<li>
%headers に`~headerを付加する$Hl( %~header[ 0 ], %~header[ 1 ] )
◎
Append (header[0], header[1]) to headers.
</li>
				</ol>
			</li>
		</ol>
	<li>
~ELSE
（ %~obj は~IDL`~record型$【！`~Record$】である ）
⇒
%~obj を成す
~EACH( %~key → %値 )
に対し
⇒
%headers に`~headerを付加する$Hl( %~key, %値 )
◎
Otherwise, object is a record, then for each key → value of object, append (key, value) to headers.
</li>
</ol>
</div>

<div class="algo">
<p>
`Headers$I ~obj %headers から
`特権的~CORSなし要請~headerを除去する@
~algoは：
◎
To remove privileged no-CORS request-headers from a Headers object (headers), run these steps:
</p>
<ol>
	<li>
`特権的~CORSなし要請~header名$を成す
~EACH( %~header名 )
に対し
⇒
%headers の`~header~list$Hlから`~headerを削除する$( %~header名 )
◎
For each headerName of privileged no-CORS request-header names:
• Delete headerName from headers’s header list.
</li>
</ol>

<p class="note">注記：
これは、
%headers が特権的でない~codeにより改変されたときに~callされる。
◎
This is called when headers are modified by unprivileged code.
</p>
</div>

<div class="algo">
<p>
`new Headers(init)@m
構築子~手続きは：
◎
The new Headers(init) constructor steps are:
</p>
<ol>
	<li>
コレの`~guard$Hl ~SET `none^l
◎
Set this’s guard to "none".
</li>
	<li>
~IF［
%init ~NEQ ε
］
⇒
コレ を`~objで埋める$( %init )
◎
If init is given, then fill this with init.
</li>
</ol>
</div>

<div class="algo">
`append(name, value)@m
~method手続きは
⇒
~RET コレに`~headerを付加する$Hl( %name, %value )
◎
The append(name, value) method steps are to append (name, value) to this.
</div>

<div class="algo">
<p>
`delete(name)@m
~method手続きは：
◎
The delete(name) method steps are:
</p>
<ol>
	<li>
<p>
~IF［
`~guardで検証する$( %name, 空な`~byte列$, コレ ) ~EQ ~F
］
⇒
~RET
◎
If validating (name, ``) for this returns false, then return.
</p>

<p class="note">注記：
形式上必要な空な~byte列を渡すことによる否定的な~~影響は無い。
◎
Passing a dummy header value ought not to have any negative repercussions. 
</p>
	</li>
	<li>
~IF［
コレの`~guard$Hl ~EQ `request-no-cors^l
］~AND［
%name は`~CORSなしで安全とされる要請~header名$でない
］~AND［
%name は`特権的~CORSなし要請~header名$でない
］
⇒
~RET
◎
If this’s guard is "request-no-cors", name is not a no-CORS-safelisted request-header name, and name is not a privileged no-CORS request-header name, then return.
</li>
	<li>
~IF［
コレの`~header~list$Hl内に［
%name を`名前に持つ~header$
］は無い
］
⇒
~RET
◎
If this’s header list does not contain name, then return.
</li>
	<li>
コレの`~header~list$Hlから`~headerを削除する$( %name )
◎
Delete name from this’s header list.
</li>
	<li>
~IF［
コレの`~guard$Hl ~EQ `request-no-cors^l
］
⇒
コレから`特権的~CORSなし要請~headerを除去する$
◎
If this’s guard is "request-no-cors", then remove privileged no-CORS request-headers from this.
</li>
</ol>
</div>

<div class="algo">
<p>
`get(name)@m
~method手続きは：
◎
The get(name) method steps are:
</p>
<ol>
	<li>
~IF［
%name は`~header名$でない
］
⇒
~THROW `TypeError$E
◎
If name is not a header name, then throw a TypeError.
</li>
	<li>
~RET `~header~listから値を取得する$( コレの`~header~list$Hl, %name )
◎
Return the result of getting name from this’s header list.
</li>
</ol>
</div>

<div class="algo">
<p>
`getSetCookie()@m
~method手続きは：
</p>
<ol>
	<li>
%値~群 ~LET 新たな`~list$
</li>
	<li>
コレの`~header~list$Hlを成す
~EACH( `Set-Cookie$h を`名前に持つ~header$ %~header )
に対し
⇒
%値~群 に %~header の`値$hdを`付加する$
</li>
	<li>
~RET %値~群
</li>
</ol>

◎
The getSetCookie() method steps are:
• If this’s header list does not contain `Set-Cookie`, then return « ».
• Return the values of all headers in this’s header list whose name is a byte-case-insensitive match for `Set-Cookie`, in order.
</div>

<div class="algo">
<p>
`has(name)@m
~method手続きは：
◎
The has(name) method steps are:
</p>
<ol>
	<li>
~IF［
%name は`~header名$でない
］
⇒
~THROW `TypeError$E
◎
If name is not a header name, then throw a TypeError.
</li>
	<li>
~RET ~IS［
コレの`~header~list$Hl内に［
%name を`名前に持つ~header$
］は在る
］
◎
Return true if this’s header list contains name; otherwise false.
</li>
</ol>
</div>

<div class="algo">
<p>
`set(name, value)@m
~method手続きは：
◎
The set(name, value) method steps are:
</p>
<ol>
	<li>
%value ~SET `値を正規化する$( %value )
◎
Normalize value.
</li>
	<li>
~IF［
`~guardで検証する$( %name, %value, コレ ) ~EQ ~F
］
⇒
~RET
◎
If validating (name, value) for this returns false, then return.
</li>
	<li>
~IF［
コレの`~guard$Hl ~EQ `request-no-cors^l
］~AND［
( %name, %value )
は`~CORSなしで安全とされる要請~header$を成さない
］
⇒
~RET
◎
If this’s guard is "request-no-cors" and (name, value) is not a no-CORS-safelisted request-header, then return.
</li>
	<li>
コレの`~header~list$Hl内で`~headerを設定する$(
( %name, %value )
)
◎
Set (name, value) in this’s header list.
</li>
	<li>
~IF［
`~guard$Hl ~EQ `request-no-cors^l
］
⇒
コレから`特権的~CORSなし要請~headerを除去する$
◎
If this’s guard is "request-no-cors", then remove privileged no-CORS request-headers from this.
</li>
</ol>
</div>

<div class="algo">
`iterable@m
における`反復される値~pair群$は、
次の結果で与えられる
⇒
`~header~listを~sortして結合する$( コレの`~header~list$Hl )
◎
The value pairs to iterate over are the return value of running sort and combine with this’s header list.
</div>

		</section>
		<section id="bodyinit-unions">
<h3 title="BodyInit unions">5.2. `BodyInit^I 共用体</h3>

<pre class="idl">
typedef (
  `Blob$I or
  `BufferSource$I or
  `FormData$I or
  `URLSearchParams$I or
  `USVString$
) `XMLHttpRequestBodyInit@I

typedef (`ReadableStream$I or `XMLHttpRequestBodyInit$I) `BodyInit@I;
</pre>

<div class="algo">
<p>
`本体と型を安全に抽出する@
~algoは、
所与の
( %~obj )
に対し，`本体と型$を返す：
◎
To safely extract a body with type from a byte sequence or BodyInit object object, run these steps:
</p>
<ol>
	<li>
~Assert：
%~obj は［
`~byte列$ ／ `BodyInit$I ~obj
］である。
◎
↑</li>
	<li>
~IF［
%~obj は `ReadableStream$I ~objである
］
⇒
~Assert：
%~obj は次を満たしていない
⇒
［
`妨げられている$RS
］~OR［
`~lockされている$RS
］
◎
If object is a ReadableStream object, then:
• Assert: object is neither disturbed nor locked.
</li>
	<li>
~RET `本体と型を抽出する$( %~obj )
◎
Return the result of extracting object.
</li>
</ol>

<p class="note">注記：
`本体と型を安全に抽出する$演算は、
例外を投出しないことが保証される，`本体と型を抽出する$演算である。
◎
The safely extract operation is a subset of the extract operation that is guaranteed to not throw an exception.
</p>
</div>

<div class="algo">
<p>
`本体と型を抽出する@
~algoは、
所与の
( %~obj,
%~keepaliveか ~IN { `~keepalive@i, ε }（省略時は ε ）
【！boolean keepalive (default false)】
)
に対し，`本体と型$を返す：
◎
To extract a body with type from a byte sequence or BodyInit object object, with an optional boolean keepalive (default false), run these steps:
</p>
<ol>
	<li>
~Assert：
%~obj は［
`~byte列$ ／ `BodyInit$I ~obj
］である。
◎
↑</li>
	<li>
%~stream ~LET ~NULL
◎
Let stream be null.
</li>
	<li>
~IF［
%~obj は `ReadableStream$I ~objである
］
⇒
%~stream ~SET %~obj
◎
If object is a ReadableStream object, then set stream to object.
</li>
	<li>
~ELIF［
%~obj は `Blob$I ~objである
］
⇒
%~stream ~SET %~obj の`~streamを取得する$()
◎
Otherwise, if object is a Blob object, set stream to the result of running object’s get stream.
</li>
	<li>
~ELSE
⇒＃
%~stream ~SET `新たな$ `ReadableStream$I ~obj；
%~stream を`~byte読取り~support付きで設定しておく$RS
◎
Otherwise, set stream to a new ReadableStream object, and set up stream with byte reading support.
</li>
	<li>
~Assert：
%~stream は `ReadableStream$I ~objである。
◎
Assert: stream is a ReadableStream object.
</li>
	<li>
%動作 ~LET ~NULL
◎
Let action be null.
</li>
	<li>
%~source ~LET ~NULL
◎
Let source be null.
</li>
	<li>
%長さ ~LET ~NULL
◎
Let length be null.
</li>
	<li>
%型 ~LET ~NULL
◎
Let type be null.
</li>
	<li>
<p>
%~obj に応じて：
◎
Switch on object:
</p>
		<dl class="switch">
			<dt>`Blob$I</dt>
			<dd>
				<ol>
					<li>
%~source ~SET %~obj
◎
Set source to object.
</li>
					<li>
%長さ ~SET %~obj の `size$mF
◎
Set length to object’s size.
</li>
					<li>
~IF［
%~obj の `type$mF 属性 ~NEQ 空な~byte列
］
⇒
%型 ~SET その属性~値
◎
If object’s type attribute is not the empty byte sequence, set type to its value.
</li>
				</ol>
			</dd>

			<dt>
`~byte列$
◎
byte sequence
</dt>
			<dd>
%~source ~SET %~obj
◎
Set source to object.
</dd>

			<dt>`BufferSource$I</dt>
			<dd>
%~source ~SET %~obj に`保持された~byte列の複製を取得する$
◎
Set source to a copy of the bytes held by object.
</dd>

			<dt>`FormData$I</dt>
			<dd>
				<ol>
					<li class="algo">
%動作 ~SET 次を走らす手続き
⇒
~RET `~mp_form_dataとして符号化する$( %~obj の`~entry~list$fD, `~UTF-8$enc )
◎
Set action to this step: run the multipart/form-data encoding algorithm, with object’s entry list and UTF-8.
</li>
					<li>
%~source ~SET %~obj
◎
Set source to object.
</li>
					<li>
%長さ ~SET 
<span class="XXX">
不明瞭
— これを改善することについては、
`~HTML 課題 #6424＠~HTMLissue/6424$ を見よ
</span>
◎
Set length to unclear, see html/6424 for improving this.
</li>
					<li>
%型 ~SET `multipart/form-data; boundary=^bl
◎
Set type to `multipart/form-data; boundary=`,＼
</li>
					<li>
%型 に次を付加する
⇒
%動作 により生成されることになる `~mp_form_data境界~文字列$
◎
followed by the multipart/form-data boundary string generated by the multipart/form-data encoding algorithm.
</li>
				</ol>
			</dd>

			<dt>`URLSearchParams$I</dt>
			<dd>
				<ol>
					<li>
%~source ~SET `~form_urlencoded直列化器$( %~obj の`~parameter~list$ )
◎
Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.
</li>
					<li>
%型 ~SET `application/x-www-form-urlencoded;charset=UTF-8^bl
◎
Set type to `application/x-www-form-urlencoded;charset=UTF-8`.
</li>
				</ol>
			</dd>

			<dt>`~scalar値~文字列$</dt>
			<dd>
				<ol>
					<li>
%~source ~SET `~UTF-8符号化する$( %~obj )
◎
Set source to the UTF-8 encoding of object.
</li>
					<li>
%型 ~SET `text/plain;charset=UTF-8^bl
◎
Set type to `text/plain;charset=UTF-8`.
</li>
				</ol>
			</dd>

			<dt>`ReadableStream$I</dt>
			<dd>
				<ol>
					<li>
~IF［
%~keepaliveか ~EQ `~keepalive$i
］~OR［
%~obj は`妨げられている$RS
］~OR［
%~obj は`~lockされている$RS
］
⇒
~THROW `TypeError$E
◎
If keepalive is true, then throw a TypeError.
◎
If object is disturbed or locked, then throw a TypeError.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
<p>
~IF［
%~source は`~byte列$である
］
⇒
%動作 ~SET 次の手続き
</p>

<div class="algo">
手続きは
⇒
~RET %~source
`and length to source’s length^en
【意図不明。 %長さ ~SET %~source の`長さ$？】
</div>
◎
If source is a byte sequence, then set action to a step that returns source and length to source’s length.
</li>
	<li>
<p>
~IF［
%動作 ~NEQ ~NULL
］：
◎
If action is non-null, then run these steps in parallel:
</p>
		<ol>
			<li class="algo">
<p>
次に従う下で %動作 を`並列的$に走らす：
◎
Run action.
</p>
				<ul>
					<li>
<p>
【 %動作 の途中結果から】
1 個以上の~byte %~byte列 が可用になるたびに：
</p>
						<ol>
							<li>
%~chunk ~LET `~buffer~sourceを~byte列から作成する$( `Uint8Array$I, %~byte列【, ここに必要な~realm引数はまだ指定されていない】 )
</li>
							<li>
%~stream に`~chunkを~enqueueする$RS( %~chunk )
</li>
						</ol>
◎
Whenever one or more bytes are available and stream is not errored, enqueue the result of creating a Uint8Array from the available bytes into stream.
</li>
					<li>
前項により %~stream が`~errorした$RSときは
⇒
この段を終える
【この場合、次項を飛ばしても同じ結果になると見受けられる。】
◎
↑</li>
					<li>
%動作 を走らせ終えたときは
⇒
%~stream を`~closeする$RS()
◎
When running action is done, close stream.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
%本体 ~LET 新たな`本体$
— その
⇒＃
`~stream$bd ~SET %~stream,
`~source$bd ~SET %~source,
`長さ$bd ~SET %長さ
◎
Let body be a body whose stream is stream, source is source, and length is length.
</li>
	<li>
~RET
( %本体, %型 )
◎
Return (body, type).
</li>
</ol>
</div>

		</section>
		<section id="body-mixin">
<h3 title="Body mixin">5.3. `Body^I ~mixin</h3>

<pre class="idl">
interface mixin `Body@I {
  readonly attribute `ReadableStream$I? `body$m;
  readonly attribute `boolean$ `bodyUsed$m;
  [`NewObject$] `Promise$&lt;`ArrayBuffer$I&gt; `arrayBuffer$m();
  [`NewObject$] `Promise$&lt;`Blob$I&gt; `blob$m();
  [`NewObject$] `Promise$&lt;`Uint8Array$I&gt; `bytes$m();
  [`NewObject$] `Promise$&lt;`FormData$I&gt; `formData$m();
  [`NewObject$] `Promise$&lt;`any$&gt; `json$m();
  [`NewObject$] `Promise$&lt;`USVString$&gt; `text$m();
};
</pre>

<p class="note">注記：
~HTMLなど，~network層に依存させたくない内容形式が、
ここで公開されることにはならないであろう。
むしろ、
~HTML構文解析器~APIが，~streamを受容するようになるであろう。
【`参考＠https://lists.w3.org/Archives/Public/public-whatwg-archive/2014Jun/thread.html#msg72$】
【`~HTML 課題 #2993＠~HTMLissue/2993$】
◎
Formats you would not want a network layer to be dependent upon, such as HTML, will likely not be exposed here. Rather, an HTML parser API might accept a stream in due course.
</p>

<p>
`Body$I ~interface~mixinを`内包-$している各~objには、
次に挙げるものが結付けられる：
◎
Objects including the Body interface mixin have an associated＼
</p>
<ul>
	<li>
`本体@Bd
⇒
~NULL ／ `本体$
◎
body (null or a body).
</li>
</ul>

<p>
`Body$I ~interface~mixinを`内包-$している~objは、
次を満たすとき，
`利用-不能@Bd
という
⇒
［
その`本体$Bd %本体 ~NEQ ~NULL
］~AND［
%本体 の`~stream$bdは、
`妨げられている$RSか`~lockされている$RS
］
◎
An object including the Body interface mixin is said to be unusable if its body is non-null and its body’s stream is disturbed or locked.
</p>

<hr>

<dl class="domintro">
	<dt>%requestOrResponse . `body$m</dt>
	<dd>
%requestOrResponse の本体を
`ReadableStream$I として返す。
◎
Returns requestOrResponse’s body as ReadableStream.
</dd>

	<dt>%requestOrResponse . `bodyUsed$m</dt>
	<dd>
%requestOrResponse の本体は読取られたかどうかを返す。
◎
Returns whether requestOrResponse’s body has been read from.
</dd>

	<dt>%requestOrResponse . `arrayBuffer()$m</dt>
	<dd>
%requestOrResponse の本体で
— `ArrayBuffer$I として —
充足される~promiseを返す。
◎
Returns a promise fulfilled with requestOrResponse’s body as ArrayBuffer.
</dd>

	<dt>%requestOrResponse . `blob()$m</dt>
	<dd>
%requestOrResponse の本体で
— `Blob$I として —
充足される~promiseを返す。
◎
Returns a promise fulfilled with requestOrResponse’s body as Blob.
</dd>

	<dt>%requestOrResponse . `bytes()$m</dt>
	<dd>
%requestOrResponse の本体で
— `Uint8Array$I として —
充足される~promiseを返す。
◎
Returns a promise fulfilled with requestOrResponse’s body as Uint8Array.
</dd>

	<dt>%requestOrResponse . `formData()$m</dt>
	<dd>
%requestOrResponse の本体で
— `FormData$I として —
充足される~promiseを返す。
◎
Returns a promise fulfilled with requestOrResponse’s body as FormData.
</dd>

	<dt>%requestOrResponse . `json()$m</dt>
	<dd>
%requestOrResponse の本体で
— ~JSONとして構文解析されたものとして —
充足される~promiseを返す。
◎
Returns a promise fulfilled with requestOrResponse’s body parsed as JSON.
</dd>

	<dt>%requestOrResponse . `text()$m</dt>
	<dd>
%requestOrResponse の本体で
— 文字列として —
充足される~promiseを返す。
◎
Returns a promise fulfilled with requestOrResponse’s body as string.
</dd>
</dl>

<hr>

<div class="algo">
<p>
`~MIME型を取得する@
~algoは、
所与の
( ［
`Request$I ／ `Response$I
］~obj %要請または応答 )
に対し：
◎
To get the MIME type, given a Request or Response object requestOrResponse:
</p>
<ol>
	<li>
%~header群 ~LET %要請または応答 に応じて
⇒＃
`Request$I ~objであるならば %要請または応答 の`要請$Rqの`~header~list$rq ／
`Response$I ~objであるならば %要請または応答 の`応答$Rsの`~header~list$rs
◎
Let headers be null.
◎
If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.
◎
Otherwise, set headers to requestOrResponse’s response’s header list.
</li>
	<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %~header群 )
◎
Let mimeType be the result of extracting a MIME type from headers.
</li>
	<li>
~IF［
%~MIME型 ~EQ `失敗^i
］
⇒
~RET ~NULL
◎
If mimeType is failure, then return null.
</li>
	<li>
~RET %~MIME型
◎
Return mimeType.
</li>
</ol>
</div>

<div class="algo">
`body@m
取得子~手続きは
⇒
~RET コレの`本体$Bd %本体 に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %本体 の`~stream$bd
◎
The body getter steps are to return null if this’s body is null; otherwise this’s body’s stream.
</div>

<div class="algo">
`bodyUsed@m
取得子~手続きは
⇒
~RET ~IS［
コレの`本体$Bd %本体 ~NEQ ~NULL
］~AND［
%本体 の`~stream$bdは`妨げられている$RS
］
◎
The bodyUsed getter steps are to return true if this’s body is non-null and this’s body’s stream is disturbed; otherwise false.
</div>

<div class="algo">
<p>
`本体を消費する@
~algoは、
所与の
( `Body$I を`内包-$している~obj %~obj, ~algo %~byte列を~JS値に変換する )
に対し：
◎
The consume body algorithm, given an object that includes Body object and an algorithm that takes a byte sequence and returns a JavaScript value or throws an exception convertBytesToJSValue, runs these steps:
</p>
<ol>
	<li>
~Assert：
%~byte列を~JS値に変換する は、
所与の`~byte列$に対し，~JS値を返すか例外を投出する。
◎
↑</li>
	<li>
~IF［
%~obj は`利用-不能$Bdである
］
⇒
~RET `却下される~promise$( `TypeError$E 例外 )
◎
If object is unusable, then return a promise rejected with a TypeError.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
%~error手続き ~LET 所与の
( %~error )
に対し，次を走らす手続き
⇒
`~promiseを却下する$( %~promise, %~error )
◎
Let errorSteps given error be to reject promise with error.
</li>
	<li class="algo">
<p>
%成功~手続き ~LET 所与の
( `~byte列$ %~data )
に対し，次を走らす手続き：
</p>
		<ol>
			<li>
<p>
%結果 ~LET %~byte列を~JS値に変換する( %~data )
</p>

<p>
例外 %e が投出されたときは、
~catchして
⇒＃
%~error手続き( %e )；
~RET
</p>
			</li>
			<li>
`~promiseを解決する$( %~promise, %結果 )
</li>
		</ol>
◎
Let successSteps given a byte sequence data be to resolve promise with the result of running convertBytesToJSValue with data. If that threw an exception, then run errorSteps with that exception. 
</li>
	<li>
~IF［
%~obj の`本体$Bd ~EQ ~NULL
］
⇒
%成功~手続き( 空な`~byte列$ )
◎
If object’s body is null, then run successSteps with an empty byte sequence.
</li>
	<li>
~ELSE
⇒
`本体を全部的に読取る$( ↓ )
⇒＃
%~obj の`本体$Bd,
%成功~手続き,
%~error手続き,
%~obj に`関連な大域~obj$
◎
Otherwise, fully read object’s body given successSteps, errorSteps, and object’s relevant global object.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`arrayBuffer()@m
~method手続きは
⇒
~RET `本体を消費する$( コレ, 次の手続き )
◎
The arrayBuffer() method steps are to return the result of running consume body with this and the following step＼
</p>

<p class="algo">
手続きは、
所与の
( `~byte列$ %~byte列 )
に対し
⇒
~RET `~buffer~sourceを~byte列から作成する$( `ArrayBuffer$I, %~byte列, コレに`関連な~realm$ )
◎
given a byte sequence bytes: return the result of creating an ArrayBuffer from bytes in this’s relevant realm.
</p>

<p class="note">注記：
この~methodは、
`RangeError$E で却下され得る。
◎
The above method can reject with a RangeError.
</p>
</div>

<div class="algo">
<p>
`blob()@m
~method手続きは
⇒
~RET
`本体を消費する$( コレ, 次の手続き )
◎
The blob() method steps are to return the result of running consume body with this and the following step＼
</p>

<p class="algo">
手続きは、
所与の
( `~byte列$ %~byte列 )
に対し
⇒
~RET 新たな `Blob$I
— その
⇒＃
内容【`~byte列~data＠~FILEAPI#_ref-bytes$】 ~SET %~byte列,
`type$mF 属性 ~SET `~MIME型を取得する$( コレ )
◎
given a byte sequence bytes:＼
return a Blob whose contents are bytes and whose type attribute is the result of get the MIME type with this.
</p>
</div>

<div class="algo">
<p>
`bytes()@m
~method手続きは
⇒
~RET
`本体を消費する$( コレ, 次の手続き )
◎
The bytes() method steps are to return the result of running consume body with this and the following step＼
</p>

<p class="algo">
手続きは、
所与の
( `~byte列$ %~byte列 )
に対し
⇒
~RET `~buffer~sourceを~byte列から作成する$( `Uint8Array$I, %~byte列, コレに`関連な~realm$ )
◎
given a byte sequence bytes:＼
return the result of creating a Uint8Array from bytes in this’s relevant realm.
</p>
</div>

<div class="algo">
<p>
`formData()@m
~method手続きは
⇒
~RET `本体を消費する$( コレ, 次の手続き )
◎
The formData() method steps are to return the result of running consume body with this and the following steps＼
</p>

<div class="algo">
<p>
手続きは、
所与の
( `~byte列$ %~byte列 )
に対し：
◎
given a byte sequence bytes:
</p>
<ol>
	<li>
%~MIME型 ~LET `~MIME型を取得する$( コレ )
◎
Let mimeType be the result of get the MIME type with this.
</li>
	<li>
%~entry群 ~LET `失敗^i
◎
↓</li>
	<li>
<p>
`(A)^i ：
◎
↓</p>
		<ol>
			<li>
~IF［
%~MIME型 ~EQ ~NULL
］
⇒
~BREAK `(A)^i
◎
If mimeType is non-null, then switch on mimeType’s essence and run the corresponding steps:
</li>
			<li>
<p>
~IF［
%~MIME型 の`~essence$ ~EQ `multipart/form-data^l
］：
◎
"multipart/form-data"
</p>
				<ol>
					<li>
<p>
`Returning Values from Forms: multipart/form-data^cite `RFC7578$r
に則って、
( %~MIME型 の `boundary^bl ~parameterの値 )
を与える下で，
%~byte列 を構文解析する
— それにより得られた各 部位 %部位 に対しては、［
%部位 の中の `Content-Disposition$h ~headerが `filename^bl ~parameterを包含するかどうか
］に応じて，［
次に与える値を値にとる`~entry$fD
］に構文解析するモノトスル：
◎
Parse bytes, using the value of the `boundary` parameter from mimeType, per the rules set forth in Returning Values from Forms: multipart/form-data. [RFC7578]
</p>
						<ul class="switch">
							<li>
<p>
包含する場合、
新たな `File$I ~obj
— その：
</p>
								<ul>
									<li>
内容【`~byte列~data＠~FILEAPI#_ref-bytes$】 ~SET %部位 の内容
</li>
									<li>
`name$mF 属性の値 ~SET `filename^bl ~parameterの値
</li>
									<li>
`type$mF 属性の値 ~SET %部位 内に `Content-Type$h ~headerが［
在るならば その~header値 ／
無いならば `text/plain^bl （ `RFC7578$r § 4.4 に定義される既定）
］
</li>
								</ul>
◎
Each part whose `Content-Disposition` header contains a `filename` parameter must be parsed into an entry＼
whose value is a File object whose contents are the contents of the part. The name attribute of the File object must have the value of the `filename` parameter of the part. The type attribute of the File object must have the value of the `Content-Type` header of the part if the part has such header, and `text/plain` (the default defined by [RFC7578] section 4.4) otherwise.
</li>
							<li>
<p>
包含しない場合、
次の結果
⇒
`~BOMはそのままに~UTF-8復号する$( %部位 の内容 )
◎
Each part whose `Content-Disposition` header does not contain a `filename` parameter must be parsed into an entry whose value is the UTF-8 decoded without BOM content of the part.＼
</p>

<p class="note">注記：
これは、［
`Content-Type$h ~header ／ `charset^bl ~parameter
］の有無やその値に関わらず行われる。
◎
This is done regardless of the presence or the value of a `Content-Type` header and regardless of the presence or the value of a `charset` parameter.
</p>
							</li>
						</ul>
<p class="note">注記：
%部位 が［
`Content-Disposition$h ~headerが `name^bl ~parameterを包含していて，
`_charset_^bl を値にとる
］場合でも、
他の部位と同様に構文解析され，符号化法は変更されない。
◎
A part whose `Content-Disposition` header contains a `name` parameter whose value is `_charset_` is parsed like any other part. It does not change the encoding.
</p>
					</li>
					<li>
~IF［
何らかの事由で，前~段が失敗した
］
⇒
~BREAK `(A)^i
◎
If that fails for some reason, then throw a TypeError.
</li>
					<li>
%~entry群 ~SET 構文解析した結果の`~entry$fDたちが成す~list
◎
Return a new FormData object, appending each entry, resulting from the parsing operation, to its entry list.
</li>
				</ol>

<p class="XXX">課題：
上述は `multipart/form-data^bl に必要なものの~~概略であり、
より詳細な構文解析~仕様が書かれることになる。
~~協力を歓迎する。
◎
The above is a rough approximation of what is needed for `multipart/form-data`, a more detailed parsing specification is to be written. Volunteers welcome.
</p>
			</li>
			<li>
~ELIF［
%~MIME型 の`~essence$ ~EQ `application/x-www-form-urlencoded^l
］
⇒
%~entry群 ~SET `~form_urlencoded構文解析器$( %~byte列 )
◎
"application/x-www-form-urlencoded"
• Let entries be the result of parsing bytes.
• Return a new FormData object whose entry list is entries.
</li>
		</ol>
	</li>
	<li>
~IF［
%~entry群 ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
Throw a TypeError.
</li>
	<li>
~RET 新たな `FormData$I ~obj
— その
⇒＃
`~entry~list$fD ~SET %~entry群
◎
↑↑</li>
</ol>
</div>
</div>

<div class="algo">
<p>
`json()@m
~method手続きは
⇒
~RET `本体を消費する$( コレ, `~JSON~byte列を~JS値に構文解析する$ )
◎
The json() method steps are to return the result of running consume body with this and parse JSON from bytes.
</p>

<p class="note">注記：
この~methodは、
`SyntaxError$E で却下され得る。
◎
The above method can reject with a SyntaxError.
</p>
</div>

<div class="algo">
<p>
`text()@m
~method手続きは
⇒
~RET `本体を消費する$( コレ, `~UTF-8復号する$ )
◎
The text() method steps are to return the result of running consume body with this and UTF-8 decode.
</p>
</div>

		</section>
		<section id="request-class">
<h3 title="Request class">5.4. `Request^I ~class</h3>

<pre class="idl">
typedef (`Request$I or `USVString$) `RequestInfo@I;

[`Exposed$=(Window,Worker)]
interface `Request@I {
  `Request$mc(`RequestInfo$I %input, optional `RequestInit$I %init = {});

  readonly attribute `ByteString$ `method$m;
  readonly attribute `USVString$ `url$m;
  [`SameObject$] readonly attribute `Headers$I `headers$m;

  readonly attribute `RequestDestination$I `destination$m;
  readonly attribute `USVString$ `referrer$m;
  readonly attribute `ReferrerPolicy$I `referrerPolicy$m;
  readonly attribute `RequestMode$I `mode$m;
  readonly attribute `RequestCredentials$I `credentials$m;
  readonly attribute `RequestCache$I `cache$m;
  readonly attribute `RequestRedirect$I `redirect$m;
  readonly attribute `DOMString$ `integrity$m;
  readonly attribute `boolean$ `keepalive$m;
  readonly attribute `boolean$ `isReloadNavigation$m;
  readonly attribute `boolean$ `isHistoryNavigation$m;
  readonly attribute `AbortSignal$I `signal$m;
  readonly attribute `RequestDuplex$I `duplex$m;

  [`NewObject$] `Request$I `clone$m();
};
`Request$I includes `Body$I;

dictionary `RequestInit@I {
  `ByteString$ `method@RqI;
  `HeadersInit$I `headers@RqI;
  `BodyInit$I? `body@RqI;
  `USVString$ `referrer@RqI;
  `ReferrerPolicy$I `referrerPolicy@RqI;
  `RequestMode$I `mode@RqI;
  `RequestCredentials$I `credentials@RqI;
  `RequestCache$I `cache@RqI;
  `RequestRedirect$I `redirect@RqI;
  `DOMString$ `integrity@RqI;
  `boolean$ `keepalive@RqI;
  `AbortSignal$I? `signal@RqI;
  `RequestDuplex$I `duplex@RqI;
  `RequestPriority$I `priority@RqI;
  `any$ `window@RqI; /* <span class="comment">
~NULL にしか設定できない。
◎
can only be set to null
</span> */
 };

enum `RequestDestination@I {
  "", "audio", "audioworklet", "document", "embed", "font", "frame", "iframe", "image", "json", "manifest", "object", "paintworklet", "report", "script", "sharedworker", "style",  "track", "video", "worker", "xslt"
};
enum `RequestMode@I {
  "navigate", "same-origin", "no-cors", "cors"
};
enum `RequestCredentials@I {
  "omit", "same-origin", "include"
};
enum `RequestCache@I {
  "default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"
};
enum `RequestRedirect@I {
  "follow", "error", "manual"
};
enum `RequestDuplex@I {
  "half"
};
enum `RequestPriority@I {
  "high", "low", "auto"
};
</pre>

<p class="note">注記：
`serviceworker^l が `RequestDestination$I から省略されているのは、
~JSからは観測し得ないからである。
それでも，実装は、
`行先$rqとして それを~supportする必要がある。
`websocket^l が `RequestMode$I から省略されているのは、
~JSからは観測し得ないからである。
◎
"serviceworker" is omitted from RequestDestination as it cannot be observed from JavaScript. Implementations will still need to support it as a destination. "websocket" is omitted from RequestMode as it cannot be used nor observed from JavaScript.
</p>

<p>
各 `Request$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`要請@Rq
⇒
`要請$
◎
A Request object has an associated request (a request).
</li>
	<li>
`~Headers@Rq
⇒
~NULL ／ `Headers$I ~obj
— 初期~時は ~NULL
◎
A Request object also has an associated headers (null or a Headers object), initially null.
</li>
	<li>
`通達@Rq
⇒
~NULL ／ `AbortSignal$I ~obj
— 初期~時は ~NULL
◎
A Request object has an associated signal (null or an AbortSignal object), initially null.
</li>
</ul>

<p class="trans-note">【
［
`~Headers$Rq, `通達$Rq
］は、
`Request$I ~objの作成-時に非 ~NULL に設定されることになる。
】</p>

<p>
`Request$I ~objの`本体$Bdは、
その`要請$Rqの`本体$rqを指す。
◎
A Request object’s body is its request’s body.
</p>

<hr>

<!-- 
`Request@I
-->

<dl class="domintro">
	<dt>%request  = `new Request$m(%input [, %init])</dt>
	<dd>
新たな `Request$I ~obj %request を返す
— その `url$m ~propは、
%input に応じて［
文字列ならば %input ／
`Request$I ~objであるならば %input の `url$m
］にされる。
◎
Returns a new request whose url property is input if input is a string, and input’s url if input is a Request object.
</dd>
	<dd>
<p>
%init 引数は、
~objであり，次に挙げる~propを設定できる：
◎
The init argument is an object whose properties can be set as follows:
</p>

		<dl>
			<dt>`method$RqI</dt>
			<dd>
%request の `method$m を設定する文字列。
◎
A string to set request’s method.
</dd>

			<dt>`headers$RqI</dt>
			<dd>
%request の `headers$m 用の `Headers$I ~objを設定する値を次のいずれかとして与える
⇒＃
~obj~literal【~JS Object 値】,
それぞれが 2 個の~itemからなる配列たちが成す配列
◎
A Headers object, an object literal, or an array of two-item arrays to set request’s headers.
</dd>

			<dt>`body$RqI</dt>
			<dd>
%request の`本体$rqを設定する［
`BodyInit$I ~obj, または ~NULL
］。
◎
A BodyInit object or null to set request’s body.
</dd>

			<dt>`referrer$RqI</dt>
			<dd>
%request の`~referrer$rqを設定する文字列
— 次のいずれか
⇒＃
同一-生成元~URL,
`about:client^l,
空~文字列
◎
A string whose value is a same-origin URL, "about:client", or the empty string, to set request’s referrer.
</dd>

			<dt>`referrerPolicy$RqI</dt>
			<dd>
%request の `referrerPolicy$m を設定する`~referrer施策$。
◎
A referrer policy to set request’s referrerPolicy.
</dd>

			<dt>`mode$RqI</dt>
			<dd>
%request の `mode$m を設定する文字列
— 要請は次のどちらになるかを指示する
⇒＃
~CORSを利用する／
同一-生成元~URLに制約される
◎
A string to indicate whether the request will use CORS, or will be restricted to same-origin URLs. Sets request’s mode.＼
</dd>
				<dd>
%input に文字列が与えられた場合の既定は `cors^l になる。
◎
If input is a string, it defaults to "cors".
</dd>

			<dt>`credentials$RqI</dt>
			<dd>
<p>
%request の `credentials$m を設定する文字列
— 次の表tのどの行が適用されるかを指示する：
</p>
<table><thead>
<tr><th>要請に伴う資格証は，いつ送信されるか
<th>返信された応答~内に資格証がある場合，いつ利用されるか
<tbody>

<tr><td>常に送信される
<td>常に利用される
<tr><td>決して送信されない
<td>決して利用されない
<tr><td>同一-生成元~URLに限り送信される
<td>同一-生成元~URLから受信した場合に限り利用される
</table>
◎
A string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL＼
— as well as whether any credentials sent back in the response will be used always, never, or only when received from a same-origin URL. Sets request’s credentials.＼
</dd>
				<dd>
%input に文字列が与えられた場合の既定は `same-origin^l になる。
【どの値がどれに対応するかは、`資格証~mode$rqを見よ。】
◎
If input is a string, it defaults to "same-origin".
</dd>

			<dt>`cache$RqI</dt>
			<dd>
%request の `cache$m を設定する文字列
— 要請は~browserの~cacheとどうヤリトリするかを指示する。
◎
A string indicating how the request will interact with the browser’s cache to set request’s cache.
</dd>

			<dt>`redirect$RqI</dt>
			<dd>
%request の `redirect$m を設定する
— %request は~redirectに際し，次のどれにするかを指示する
⇒＃
追従する ／
~errorにする ／
その~redirectを`不透明~redirect絞込み応答$として返す【！ ＊in an opaque fashion】
◎
A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request’s redirect.
</dd>

			<dt>`integrity$RqI</dt>
			<dd>
%request の `integrity$m を設定する文字列
— %request により~fetchされる資源の暗号用~hashを与える。
◎
A cryptographic hash of the resource to be fetched by request. Sets request’s integrity.
</dd>

			<dt>`keepalive$RqI</dt>
			<dd>
%request の `keepalive$m を設定する真偽値。
◎
A boolean to set request’s keepalive.
</dd>

			<dt>`signal$RqI</dt>
			<dd>
%request の `signal$m を設定する `AbortSignal$I 。
◎
An AbortSignal to set request’s signal.
</dd>

			<dt>`window$RqI</dt>
			<dd>
~NULL 以外の値はとり得ない。
%request と `Window$I との結付きを断つために利用される。
◎
Can only be null. Used to disassociate request from any Window.
</dd>

			<dt>`duplex$RqI</dt>
			<dd>
妥当な値は `half^l しかなく、
半二重（ `half-duplex^en ）な~fetchを起動するためにある
（すなわち、
~UAは，応答を処理する前に要請~全体を送信する）。
値 `full^l は将来の利用-用に予約-済みであり、
全二重（ `full-duplex^en ）な~fetchを起動するためにある
（すなわち、
~UAは，要請~全体を送信する前に，応答を処理できる）
（ `full^l を定義している
`課題 #1254＠https://github.com/whatwg/fetch/issues/1254$
を見よ）。
この~memberは、
`body$RqI が `ReadableStream$I ~objであるときは，設定される必要がある。
◎
"half" is the only valid value and it is for initiating a half-duplex fetch (i.e., the user agent sends the entire request before processing the response). "full" is reserved for future use, for initiating a full-duplex fetch (i.e., the user agent can process the response before sending the entire request). This member needs to be set when body is a ReadableStream object. See issue #1254 for defining "full".
</dd>

			<dt>`priority$RqI</dt>
			<dd>
%要請 の`優先度$rqを設定する文字列。
◎
A string to set request’s priority.
</dd>
		</dl>
	</dd>

	<dt>%request . `method$m</dt>
	<dd>
%request の~HTTP~methodを返す。
既定では `GET^l 。
◎
Returns request’s HTTP method, which is "GET" by default.
</dd>

	<dt>%request . `url$m</dt>
	<dd>
%request の~URLを文字列として返す。
◎
Returns the URL of request as a string.
</dd>

	<dt>%request . `headers$m</dt>
	<dd>
%request に結付けられた~headerたちからなる `Headers$I ~objを返す。
この~objには、
~UAにより~network層にて追加される~headerは，織り込まれないことに注意
— 例：`Host^l ~headerなど。
◎
Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the "Host" header.
</dd>

	<dt>%request . `destination$m</dt>
	<dd>
%request により要請される資源の種類を返す
— 例： `document^l ／ `script^l 。
◎
Returns the kind of resource requested by request, e.g., "document" or "script".
</dd>

	<dt>%request . `referrer$m</dt>
	<dd>
<p>
%request の~referrerを返す。
その値は：
</p>
		<ul>
			<li>
%init 内に明示的に設定された場合、
同一-生成元~URLになり得る。
</li>
			<li>
空~文字列は、
~referrerなしを指示する。
</li>
			<li>
大域【環境？~obj？】の既定の~referrerになるときは、
`about:client^l になる。
</li>
		</ul>
<p>
これは、［
~fetchする間に為される要請の `Referer$h ~header
］の値を決定するときに利用される。
</p>
◎
Returns the referrer of request. Its value can be a same-origin URL if explicitly set in init, the empty string to indicate no referrer, and "about:client" when defaulting to the global’s default. This is used during fetching to determine the value of the `Referer` header of the request being made.
</dd>

	<dt>%request . `referrerPolicy$m</dt>
	<dd>
%request に結付けられた~referrer施策を返す。
これは、
~fetchする間に %request の~referrer値を算出するときに利用される。
◎
Returns the referrer policy associated with request. This is used during fetching to compute the value of the request’s referrer.
</dd>

	<dt>%request . `mode$m</dt>
	<dd>
%request に結付けられた`~mode$rqを返す。
それは，文字列であり、
要請が［
~CORSを利用する, 
同一-生成元~URLに制約される
］のいずれになるかを指示する。
◎
Returns the mode associated with request, which is a string indicating whether the request will use CORS, or will be restricted to same-origin URLs.
</dd>

	<dt>%request . `credentials$m</dt>
	<dd>
%request に結付けられた`資格証~mode$rqを返す。
それは，文字列であり、
送信される要請に，資格証を［
常に伴わせる, 決して伴わせない, 同一-生成元~URLに限り伴わせる
］のいずれになるかを指示する。
◎
Returns the credentials mode associated with request, which is a string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL.
</dd>

	<dt>%request . `cache$m</dt>
	<dd>
%request に結付けられた`~cache~mode$rqを返す。
それは，文字列であり、［
要請を~fetchする際に~browserの~cacheとどうヤリトリするか
］を指示する。
◎
Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser’s cache when fetching.
</dd>

	<dt>%request . `redirect$m</dt>
	<dd>
%request に結付けられた`~redirect~mode$rqを返す。
それは，文字列であり、［
~fetchする間，要請に対する~redirectはどう取扱われるか
］を指示する。
既定では、
`要請$は~redirectに追従することになる。
◎
Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.
</dd>

	<dt>%request . `integrity$m</dt>
	<dd>
%request の下位資源~完全性~metadataを返す。
それは、
~fetchされる資源の暗号用~hashを与える。
その値は、
空白で分離された【！multiple】~hashたちからなる。
`SRI$r
◎
Returns request’s subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]
</dd>

	<dt>%request . `keepalive$m</dt>
	<dd>
%request が［
それを作成した大域~objの外で残存できるかどうか
］を指示する，真偽値を返す。
◎
Returns a boolean indicating whether or not request can outlive the global in which it was created.
</dd>

	<dt>%request . `isReloadNavigation$m</dt>
	<dd>
%request が［
再読込み~navi用かどうか
］を指示する，真偽値を返す。
◎
Returns a boolean indicating whether or not request is for a reload navigation.
</dd>

	<dt>%request . `isHistoryNavigation$m</dt>
	<dd>
%request が［
（前後~pageへの）履歴~navi用かどうか
］を指示する，真偽値を返す。
◎
Returns a boolean indicating whether or not request is for a history navigation (a.k.a. back-foward navigation).
</dd>

	<dt>%request . `signal$m</dt>
	<dd>
%request に結付けられた通達を返す。
それは， `AbortSignal$I ~objであり、［
%request は中止されたかどうか, および
その中止-~event~handler
］を指示する。
◎
Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler.
</dd>

	<dt>%request . `duplex$m</dt>
	<dd>
`half^l を返す
— これは、
当の~fetchは半二重になることを意味する
（すなわち、
~UAは，要請~全体を送信した後に対する応答を処理する）。
◎
Returns "half", meaning the fetch will be half-duplex (i.e., the user agent sends the entire request before processing the response).＼
</dd>
	<dd>
将来においては、
`full^l も返し得る
— これは、
当の~fetchは全二重になることを意味する
（すなわち、
~UAは，要請~全体を送信する前に対する応答を処理できる）
【！to indicate that the fetch will be full-duplex】。
【！ class="note"】
`full^l を定義している
`課題 #1254＠https://github.com/whatwg/fetch/issues/1254$
を見よ。
◎
In future, it could also return "full", meaning the fetch will be full-duplex (i.e., the user agent can process the response before sending the entire request) to indicate that the fetch will be full-duplex. See issue #1254 for defining "full".
</dd>

	<dt>%request . `clone()$m</dt>
	<dd>
%request の~cloneを返す。
◎
Returns a clone of request.
</dd>
</dl>

<hr>

<div class="algo">
<p>
`~Request~objを作成する@
~algoは、
所与の
( `要請$ %要請, `~Headers用の~guard$ %~guard, `AbortSignal$I ~obj %通達, `~realm$ %~realm )
に対し：
◎
To create a Request object, given a request request, headers guard guard, AbortSignal object signal, and realm realm: 
</p>
<ol>
	<li>
%headers ~LET %~realm に属する`新たな$ `Headers$I ~obj
— その
⇒＃
`~header~list$Hl ~SET %要請 の`~header~list$rq,
`~guard$Hl ~SET %~guard
◎
↓</li>
	<li>
%~Request~obj ~LET %~realm に属する`新たな$ `Request$I ~obj
— その
⇒＃
`要請$Rq ~SET %要請,
`~Headers$Rq ~SET %headers,
`通達$Rq ~SET %通達
◎
Let requestObject be a new Request object with realm.
◎
Set requestObject’s request to request.
◎
Set requestObject’s headers to a new Headers object with realm, whose headers list is request’s headers list and guard is guard.
◎
Set requestObject’s signal to signal.
</li>
	<li>
~RET %~Request~obj
◎
Return requestObject.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`new Request(input, init)@m
構築子~手続きは：
◎
The new Request(input, init) constructor steps are:
</p>
<ol>
	<li>
%要請 ~LET ~NULL
◎
Let request be null.
</li>
	<li>
%~fallback~mode ~LET ~NULL
◎
Let fallbackMode be null.
</li>
	<li>
%基底~URL ~LET コレに`関連な設定群~obj$の`~API用~基底~URL$enV
◎
Let baseURL be this’s relevant settings object’s API base URL.
</li>
	<li>
%通達 ~LET ~NULL
◎
Let signal be null.
</li>
	<li>
<p>
~IF［
%input は文字列である
］：
◎
If input is a string, then:
</p>
		<ol>
			<li>
%構文解析した~URL ~LET `~URL構文解析する$( %input, %基底~URL )
◎
Let parsedURL be the result of parsing input with baseURL.
</li>
			<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
			<li>
~IF［
%構文解析した~URL は`資格証を含んで$いる
］
⇒
~THROW `TypeError$E
◎
If parsedURL includes credentials, then throw a TypeError.
</li>
			<li>
%要請 ~SET 新たな`要請$
— その
⇒
`~URL$rq ~SET %構文解析した~URL
◎
Set request to a new request whose URL is parsedURL.
</li>
			<li>
%~fallback~mode ~SET `cors^l
◎
Set fallbackMode to "cors".
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%input は `Request$I ~objである。
◎
Assert: input is a Request object.
</li>
			<li>
%要請 ~SET %input の`要請$Rq
◎
Set request to input’s request.
</li>
			<li>
%通達 ~SET %input の`通達$Rq
◎
Set signal to input’s signal.
</li>
		</ol>
	</li>
	<li>
%生成元 ~LET コレに`関連な設定群~obj$の`生成元$enV
◎
Let origin be this’s relevant settings object’s origin.
</li>
	<li>
%~window ~LET `client^l
◎
Let window be "client".
</li>
	<li>
~IF［
%要請 の`~window$rqは`環境~設定群~obj$である
］~AND［
%要請 の`~window$rqの`生成元$enV
~EQ`生成元$sub
%生成元
］
⇒
%~window ~SET %要請 の`~window$rq
◎
If request’s window is an environment settings object and its origin is same origin with origin, then set window to request’s window.
</li>
	<li>
<p>
%init[ "`window$RqI" ] に応じて：
</p>
		<ul class="switch">
			<li>
ε
⇒
何もしない
</li>
			<li>
~NULL
⇒
%~window ~SET `no-window^l
</li>
			<li>
その他
⇒
~THROW `TypeError$E
</li>
		</ul>
◎
If init["window"] exists and is non-null, then throw a TypeError.
◎
If init["window"] exists, then set window to "no-window".
</li>
	<li>
<p>
%要請 ~SET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %要請 の`~URL$rq,
`~method$rq ~SET %要請 の`~method$rq,
`~header~list$rq ~SET %要請 の`~header~list$rqの複製,
`安全でない要請か$rq ~SET ~T,
`~client$rq ~SET コレに`関連な設定群~obj$,
`~window$rq ~SET %~window,
`内部的な優先度$rq ~SET %要請 の`内部的な優先度$rq,
`生成元$rq ~SET %要請 の`生成元$rq†,
`~referrer$rq ~SET %要請 の`~referrer$rq,
`~referrer施策$rq ~SET %要請 の`~referrer施策$rq,
`~mode$rq ~SET %要請 の`~mode$rq,
`資格証~mode$rq ~SET %要請 の`資格証~mode$rq,
`~cache~mode$rq ~SET %要請 の`~cache~mode$rq,
`~redirect~mode$rq ~SET %要請 の`~redirect~mode$rq,
`完全性~metadata$rq ~SET %要請 の`完全性~metadata$rq,
`~keepaliveか$rq ~SET %要請 の`~keepaliveか$rq,
`再読込み~naviか$rq ~SET %要請 の`再読込み~naviか$rq,
`履歴~naviか$rq ~SET %要請 の`履歴~naviか$rq,
`~URL~list$rq ~SET %要請 の`~URL~list$rqを`~cloneする$,
`起動元~種別$rq ~SET `fetch^l
</p>

<p class="note">注記†：
`生成元$の伝播が有意になるのは、［
~swにより取扱われている~navi要請
］用に限られる。
この局面においては、
要請の生成元は，現在の~clientのそれとは異なり得る。
</p>
◎
Set request to a new request with the following properties:
◎
URL
• request’s URL.
method
• request’s method.
header list
• A copy of request’s header list.
unsafe-request flag
• Set.
client
• This’s relevant settings object.
window
• window.
internal priority
• request’s internal priority.
origin
• request’s origin.＼
The propagation of the origin is only significant for navigation requests being handled by a service worker. In this scenario a request can have an origin that is different from the current client.
referrer
• request’s referrer.
referrer policy
• request’s referrer policy.
mode
• request’s mode.
credentials mode
• request’s credentials mode.
cache mode
• request’s cache mode.
redirect mode
• request’s redirect mode.
integrity metadata
• request’s integrity metadata.
keepalive
• request’s keepalive.
reload-navigation flag
• request’s reload-navigation flag.
history-navigation flag
• request’s history-navigation flag.
URL list
• A clone of request’s URL list.
initiator type
• "fetch".
</li>
	<li>
<p>
~IF［
%init は`空$mapでない
］：
◎
If init is not empty, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`~mode$rq ~EQ `navigate^l
］
⇒
%要請 の`~mode$rq ~SET `same-origin^l
◎
If request’s mode is "navigate", then set it to "same-origin".
</li>
			<li>
%要請 の
⇒＃
`再読込み~naviか$rq ~SET ~F,
`履歴~naviか$rq ~SET ~F,
`生成元$rq ~SET `client^l,
`~referrer$rq ~SET `client^l,
`~referrer施策$rq ~SET 空~文字列,
`~URL$rq ~SET %要請 の`現在の~URL$rq,
`~URL~list$rq ~SET « %要請 の`~URL$rq »
◎
Unset request’s reload-navigation flag.
◎
Unset request’s history-navigation flag.
◎
Set request’s origin to "client".
◎
Set request’s referrer to "client".
◎
Set request’s referrer policy to the empty string.
◎
Set request’s URL to request’s current URL.
◎
Set request’s URL list to « request’s URL ».
</li>
		</ol>

<p class="note">注記：
これは、
~swが要請
— 例えば，非同一-生成元~stylesheetからの画像 —
を “~redirect” して 改変を加えたときに、
元の~source（すなわち，非同一-生成元~stylesheet）から来たのでなく，
その~swから来たように現れることを確保するために行われる。
元の~sourceは，~swと同じ種類の要請~すら生成できないかもしれないので、
このことは重要になる。
これが行われないと、
元の~sourceを信用する~serviceは，悪用されかねない
— そこまで行き着くことは まず無さそうだが。
◎
This is done to ensure that when a service worker "redirects" a request, e.g., from an image in a cross-origin style sheet, and makes modifications, it no longer appears to come from the original source (i.e., the cross-origin style sheet), but instead from the service worker that "redirected" the request. This is important as the original source might not even be able to generate the same kind of requests as the service worker. Services that trust the original source could therefore be exploited were this not done, although that is somewhat farfetched.
</p>

	</li>
	<li>
%~referrer ~LET %init[ "`referrer$RqI" ]
◎
↓</li>
	<li>
<p>
~IF［
%~referrer ~NEQ ε
］：
◎
If init["referrer"] exists, then:
• Let referrer be init["referrer"].
</p>
		<ol>
			<li>
~IF［
%~referrer ~EQ 空~文字列
］
⇒＃
%要請 の`~referrer$rq ~SET `no-referrer^l
◎
If referrer is the empty string, then set request’s referrer to "no-referrer".
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%構文解析した~referrer ~LET `~URL構文解析する$( %~referrer, %基底~URL )
◎
Let parsedReferrer be the result of parsing referrer with baseURL.
</li>
					<li>
~IF［
%構文解析した~referrer ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedReferrer is failure, then throw a TypeError.
</li>
					<li>
<p>
~IF［
~OR↓
］…
◎
If one of the following is true
</p>

						<ul>
							<li>
%構文解析した~referrer は次を満たす
⇒
［
`~scheme$url ~EQ `about^l
］~AND［
`~path$url ~EQ 文字列 `client^l
］
◎
parsedReferrer’s scheme is "about" and path is the string "client"
</li>
							<li>
%構文解析した~referrer の`生成元$url
~NEQ`生成元$sub
%生成元
◎
parsedReferrer’s origin is not same origin with origin
</li>
						</ul>
<p>
…ならば
⇒
%要請 の`~referrer$rq ~SET `client^l
◎
then set request’s referrer to "client".
</p>

					</li>
					<li>
~ELSE
⇒
%要請 の`~referrer$rq ~SET %構文解析した~referrer
◎
Otherwise, set request’s referrer to parsedReferrer.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%init[ "`referrerPolicy$RqI" ] ~NEQ ε
］
⇒
%要請 の`~referrer施策$rq ~SET その値
◎
If init["referrerPolicy"] exists, then set request’s referrer policy to it.
</li>
	<li>
%~mode ~LET ［
%init[ "`mode$RqI" ] ~NEQ ε ならば その値 ／
~ELSE_ %~fallback~mode
］
◎
Let mode be init["mode"] if it exists, and fallbackMode otherwise.
</li>
	<li>
~IF［
%~mode ~EQ `navigate^l
］
⇒
~THROW `TypeError$E
◎
If mode is "navigate", then throw a TypeError.
</li>
	<li>
~IF［
%~mode ~NEQ ~NULL
］
⇒
%要請 の`~mode$rq ~SET %~mode
◎
If mode is non-null, set request’s mode to mode.
</li>
	<li>
~IF［
%init[ "`credentials$RqI" ] ~NEQ ε
］
⇒
%要請 の`資格証~mode$rq ~SET その値
◎
If init["credentials"] exists, then set request’s credentials mode to it.
</li>
	<li>
~IF［
%init[ "`cache$RqI" ] ~NEQ ε
］
⇒
%要請 の`~cache~mode$rq ~SET その値
◎
If init["cache"] exists, then set request’s cache mode to it.
</li>
	<li>
~IF［
%要請 の`~cache~mode$rq ~EQ `only-if-cached^l
］~AND［
%要請 の`~mode$rq ~NEQ `same-origin^l
］
⇒
~THROW `TypeError$E
◎
If request’s cache mode is "only-if-cached" and request’s mode is not "same-origin", then throw a TypeError.
</li>
	<li>
~IF［
%init[ "`redirect$RqI" ] ~NEQ ε
］
⇒
%要請 の`~redirect~mode$rq ~SET その値
◎
If init["redirect"] exists, then set request’s redirect mode to it.
</li>
	<li>
~IF［
%init[ "`integrity$RqI" ] ~NEQ ε
］
⇒
%要請 の`完全性~metadata$rq ~SET その値
◎
If init["integrity"] exists, then set request’s integrity metadata to it.
</li>
	<li>
%要請 の`~keepaliveか$rq ~SET ~IS［
%init[ "`keepalive$RqI" ] ~EQ ~T
【！init["keepalive"] exists】
］
◎
If init["keepalive"] exists, then set request’s keepalive to it.
</li>
	<li>
%~method ~LET %init[ "`method$RqI" ]
◎
↓</li>
	<li>
<p>
~IF［
%~method ~NEQ ε
］：
◎
If init["method"] exists, then:
• Let method be init["method"].
</p>
		<ol>
			<li>
~IF［
%~method は`~method$でない
］~OR［
%~method は`禁止~method$である
］
⇒
~THROW `TypeError$E
◎
If method is not a method or method is a forbidden method, then throw a TypeError.
</li>
			<li>
%要請 の`~method$rq  ~SET `~methodを正規化する$( %~method )
◎
Normalize method.
◎
Set request’s method to method.
</li>
		</ol>
	</li>
	<li>
~IF［
%init[ "`signal$RqI" ] ~NEQ ε
］
⇒
%通達 ~SET その値
◎
If init["signal"] exists, then set signal to it.
</li>
	<li>
<p>
~IF［
%init[ "`priority$RqI" ] ~NEQ ε
］：
◎
If init["priority"] exists, then:
</p>
		<ol>
			<li>
~IF［
%要請 の`内部的な優先度$rq ~NEQ ~NULL
］
⇒
%要請 の`内部的な優先度$rqを`実装定義$な方式で更新する
◎
If request’s internal priority is not null, then update request’s internal priority in an implementation-defined manner.
</li>
			<li>
~ELSE
⇒
%要請 の`優先度$rq ~SET %init[ "`priority$RqI" ]
◎
Otherwise, set request’s priority to init["priority"].
</li>
		</ol>
	</li>
	<li>
コレの`要請$Rq ~SET %要請
◎
Set this’s request to request.
</li>
	<li>
%通達~群 ~LET ［
%通達 ~NEQ ~NULL ならば « %通達 » ／
~ELSE_ « »
］
◎
Let signals be « signal » if signal is non-null; otherwise « ».
</li>
	<li>
コレの`通達$Rq ~SET `依存~中止-通達を作成する$( %通達~群, `AbortSignal$I, コレに`関連な~realm$ )
◎
Set this’s signal to the result of creating a dependent abort signal from signals, using AbortSignal and this’s relevant realm.
</li>
	<li>
コレの`~Headers$Rq ~SET コレに`関連な~realm$に属する`新たな$ `Headers$I ~obj
— その
⇒＃
`~header~list$Hl ~SET %要請 の`~header~list$rq,
`~guard$Hl ~SET `request^l
◎
Set this’s headers to a new Headers object with this’s relevant realm, whose header list is request’s header list and guard is "request".
</li>
	<li>
<p>
~IF［
コレの`要請$Rqの`~mode$rq ~EQ `no-cors^l
］：
◎
If this’s request’s mode is "no-cors", then:
</p>
		<ol>
			<li>
~IF［
コレの`要請$Rqの`~method$rqは `~CORS安全とされる~method$でない
］
⇒
~THROW `TypeError$E
◎
If this’s request’s method is not a CORS-safelisted method, then throw a TypeError.
</li>
			<li>
コレの`~Headers$Rqの`~guard$Hl  ~SET `request-no-cors^l
◎
Set this’s headers’s guard to "request-no-cors".
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%init は`空$mapでない
］：
◎
If init is not empty, then:
</p>

<p class="note">注記：
%headers は，この~mode【 %~mode ？】では許容されない~headerを包含するかもしれないので、
この段で無毒化される。
他の場合、
それは以前に無毒化されたか，特権的~APIによる設定-時から改変されてない。
◎
The headers are sanitized as they might contain headers that are not allowed by this mode. Otherwise, they were previously sanitized or are unmodified since they were set by a privileged API.
</p>
		<ol>
			<li>
%headers ~LET %init[ "`headers$RqI" ]
◎
↓</li>
			<li>
~IF［
%headers ~EQ ε
］
⇒
%headers ~SET コレの`~Headers$Rqの複製
— `~header~list$Hlも含めて複製する
◎
Let headers be a copy of this’s headers and its associated header list.
◎
If init["headers"] exists, then set headers to init["headers"].
</li>
			<li>
コレの`~Headers$Rqの`~header~list$Hlを空にする
◎
Empty this’s headers’s header list.
</li>
			<li>
~IF［
%headers は `Headers$I ~objである
］
⇒
%headers の`~header~list$Hlを成す
~EACH( %~header )
に対し
⇒
コレの`~Headers$Rqに`~headerを付加する$Hl( %~header の`名前$hd, %~header の`値$hd )
◎
If headers is a Headers object, then for each header of its header list, append header to this’s headers.
</li>
			<li>
~ELSE
⇒
コレの`~Headers$Rqを`~objで埋める$( %headers )
◎
Otherwise, fill this’s headers with headers.
</li>
		</ol>
	</li>
	<li>
%入力~本体 ~LET %input に応じて
⇒＃
`Request$I ~objであるならば %input の`要請$Rqの`本体$rq ／
~ELSE_ ~NULL
◎
Let inputBody be input’s request’s body if input is a Request object; otherwise null.
</li>
	<li>
%本体~member ~LET %init[ "`body$RqI" ]
◎
↓</li>
	<li>
~IF［
%本体~member ~EQ ε
］
⇒
%本体~member ~SET ~NULL
◎
↓</li>
	<li>
~IF［［
%本体~member ~NEQ ~NULL
］~OR［
%入力~本体 ~NEQ ~NULL
］］~AND［
%要請 の`~method$rq ~IN { `GET$hm, `HEAD$hm }
］
⇒
~THROW `TypeError$E
◎
If either init["body"] exists and is non-null or inputBody is non-null, and request’s method is `GET` or `HEAD`, then throw a TypeError.
</li>
	<li>
%初期~本体 ~LET ~NULL
◎
Let initBody be null.
</li>
	<li>
<p>
~IF［
%本体~member ~NEQ ~NULL
］：
◎
If init["body"] exists and is non-null, then:
</p>
		<ol>
			<li>
%本体と型 ~LET %要請 の`~keepaliveか$rq に応じて
⇒＃
~T ならば `本体と型を抽出する$( %本体~member, `~keepalive$i ) ／
~F ならば `本体と型を抽出する$( %本体~member )
◎
Let bodyWithType be the result of extracting init["body"], with keepalive set to request’s keepalive.
</li>
			<li>
%初期~本体 ~SET %本体と型 の`本体$bwT
◎
Set initBody to bodyWithType’s body.
</li>
			<li>
%型 ~LET %本体と型 の`型$bwT
◎
Let type be bodyWithType’s type.
</li>
			<li>
~IF［
%型 ~NEQ ~NULL
］~AND［［
コレの`~Headers$Rqの`~header~list$Hl
］内に［
`Content-Type$h を`名前に持つ~header$
］は無い
］
⇒
コレの`~Headers$Rqに`~headerを付加する$Hl( `Content-Type$h, %型 )
◎
If type is non-null and this’s headers’s header list does not contain `Content-Type`, then append (`Content-Type`, type) to this’s headers.
</li>
		</ol>
	</li>
	<li>
%最終-本体【！inputOrInitBody（不要）】 ~LET ［
%初期~本体 ~NEQ ~NULL ならば %初期~本体 ／
~ELSE_ %入力~本体
］
◎
Let inputOrInitBody be initBody if it is non-null; otherwise inputBody.
</li>
	<li>
<p>
~IF［
%最終-本体 ~NEQ ~NULL
］~AND［
%最終-本体 の`~source$bd ~EQ ~NULL
］：
◎
If inputOrInitBody is non-null and inputOrInitBody’s source is null, then:
</p>
		<ol>
			<li>
~IF［
%初期~本体 ~NEQ ~NULL
］~AND［
%init[ "`duplex$RqI" ] ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If initBody is non-null and init["duplex"] does not exist, then throw a TypeError.
</li>
			<li>
~IF［
コレの`要請$Rqの`~mode$rq ~NIN { `same-origin^l, `cors^l }
］
⇒
~THROW `TypeError$E
◎
If this’s request’s mode is neither "same-origin" nor "cors", then throw a TypeError.
</li>
			<li>
コレの`要請$Rqの`~CORS予行を利用するか$rq ~SET ~T
◎
Set this’s request’s use-CORS-preflight flag.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%初期~本体 ~EQ ~NULL
］~AND［
%入力~本体 ~NEQ ~NULL
］：
◎
↑Let finalBody be inputOrInitBody.
◎
If initBody is null and inputBody is non-null, then:
</p>
		<ol>
			<li>
~IF［
%input は`利用-不能$Bdである
］
⇒
~THROW `TypeError$E
◎
If input is unusable, then throw a TypeError.
</li>
		<li>
%最終-本体 ~SET `~proxyを作成する$RS( %入力~本体 )
◎
Set finalBody to the result of creating a proxy for inputBody.
</li>
		</ol>
	</li>
	<li>
コレの`要請$Rqの`本体$rq ~SET %最終-本体
◎
Set this’s request’s body to finalBody.
</li>
</ol>
</div>

<div class="algo">
`method@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~method$rq
◎
The method getter steps are to return this’s request’s method.
</div>

<div class="algo">
`url@m
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレの`要請$Rqの`~URL$rq )
◎
The url getter steps are to return this’s request’s URL, serialized.
</div>

<div class="algo">
`headers@m
取得子~手続きは
⇒
~RET コレの`~Headers$Rq
◎
The headers getter steps are to return this’s headers.
</div>

<div class="algo">
`destination@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`行先$rq
◎
The destination getter are to return this’s request’s destination.
</div>

<div class="algo">
`referrer@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~referrer$rq %~referrer に応じて
⇒＃
`no-referrer^l ならば空~文字列／
`client^l ならば `about:client^l／
~ELSE_ `~URLを直列化する$( %~referrer )
◎
The referrer getter steps are:
• If this’s request’s referrer is "no-referrer", then return the empty string.
• If this’s request’s referrer is "client", then return "about:client".
• Return this’s request’s referrer, serialized.
</div>

<div class="algo">
`referrerpolicy@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~referrer施策$rq
◎
The referrerPolicy getter steps are to return this’s request’s referrer policy.
</div>

<div class="algo">
`mode@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~mode$rq
◎
The mode getter steps are to return this’s request’s mode.
</div>

<div class="algo">
`credentials@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`資格証~mode$rq
◎
The credentials getter steps are to return this’s request’s credentials mode.
</div>

<div class="algo">
`cache@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~cache~mode$rq
◎
The cache getter steps are to return this’s request’s cache mode.
</div>

<div class="algo">
`redirect@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~redirect~mode$rq
◎
The redirect getter steps are to return this’s request’s redirect mode.
</div>

<div class="algo">
`integrity@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`完全性~metadata$rq
◎
The integrity getter steps are to return this’s request’s integrity metadata.
</div>

<div class="algo">
`keepalive@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`~keepaliveか$rq
◎
The keepalive getter steps are to return this’s request’s keepalive.
</div>

<div class="algo">
`isReloadNavigation@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`再読込み~naviか$rq
◎
The isReloadNavigation getter steps are to return true if this’s request’s reload-navigation flag is set; otherwise false.
</div>

<div class="algo">
`isHistoryNavigation@m
取得子~手続きは
⇒
~RET コレの`要請$Rqの`履歴~naviか$rq
◎
The isHistoryNavigation getter steps are to return true if this’s request’s history-navigation flag is set; otherwise false.
</div>

<div class="algo">
`signal@m
取得子~手続きは
⇒
~RET コレの`通達$Rq
◎
The signal getter steps are to return this’s signal.
</div>

<div class="algo">
`duplex@m
取得子~手続きは
⇒
~RET `half^l
◎
The duplex getter steps are to return "half".
</div>

<div class="algo">
<p>
`clone()@m
~method手続きは：
◎
The clone() method steps are:
</p>
<ol>
	<li>
~IF［
コレは`利用-不能$Bdである
］
⇒
~THROW `TypeError$E
◎
If this is unusable, then throw a TypeError.
</li>
	<li>
%~cloneした要請 ~LET `要請を~cloneする$( コレの`要請$Rq )
◎
Let clonedRequest be the result of cloning this’s request.
</li>
	<li>
~Assert：
コレの`通達$Rq ~NEQ ~NULL
◎
Assert: this’s signal is non-null.
</li>
	<li>
%~cloneした通達 ~LET `依存~中止-通達を作成する$( « コレの`通達$Rq », `AbortSignal$I, コレに`関連な~realm$ )
◎
Let clonedSignal be the result of creating a dependent abort signal from « this’s signal », using AbortSignal and this’s relevant realm.
</li>
	<li>
%~cloneした~Request~obj ~LET `~Request~objを作成する$( %~cloneした要請, コレの`~Headers$Rqの`~guard$Hl, %~cloneした通達, コレに`関連な~realm$ )
◎
Let clonedRequestObject be the result of creating a Request object, given clonedRequest, this’s headers’s guard, clonedSignal and this’s relevant realm.
</li>
	<li>
~RET %~cloneした~Request~obj
◎
Return clonedRequestObject.
</li>
</ol>
</div>

		</section>
		<section id="response-class">
<h3 title="Response class">5.5. `Response^I ~class</h3>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `Response@I {
  `Response$mc(optional `BodyInit$I? %body = null, optional `ResponseInit$I %init = {});

  [`NewObject$] static `Response$I `error$m();
  [`NewObject$] static `Response$I `redirect$m(
      `USVString$ %url,
      optional `unsigned short$ %status = 302
  );
  [`NewObject$] static `Response$I `json$m(
      `any$ %data,
      optional `ResponseInit$I %init = {}
  );

  readonly attribute `ResponseType$I `type$m;

  readonly attribute `USVString$ `url$m;
  readonly attribute `boolean$ `redirected$m;
  readonly attribute `unsigned short$ `status$m;
  readonly attribute `boolean$ `ok$m;
  readonly attribute `ByteString$ `statusText$m;
  [`SameObject$] readonly attribute `Headers$I `headers$m;

  [`NewObject$] `Response$I `clone$m();
};
`Response$I includes `Body$I;

dictionary `ResponseInit@I {
  `unsigned short$ `status@RsI = 200;
  `ByteString$ `statusText@RsI = "";
  `HeadersInit$I `headers@RsI;
};

enum `ResponseType@I {
  "basic", "cors", "default", "error", "opaque", "opaqueredirect"
};
</pre>

<!-- 
`Response@I
-->

<p>
各 `Response$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<ul>
	<li>
`応答@Rs
⇒
`応答$
◎
A Response object has an associated response (a response).
</li>
	<li>
`~Headers@Rs
⇒
~NULL ／ `Headers$I ~obj
— 初期~時は ~NULL
◎
A Response object also has an associated headers (null or a Headers object), initially null.
</li>
</ul>

<p>
`Response$I ~objの`本体$Bdは、
その`応答$Rsの`本体$rsを指す。
◎
A Response object’s body is its response’s body.
</p>

<dl class="domintro">
	<dt>%response = `new Response(body = null [, init])$m</dt>
	<dd>
`Response$I を作成して，その本体を %body にする
— ［
状態s,
状態s~message,
~header~list
］は、
%init により供される。
◎
Creates a Response whose body is body, and status, status message, and headers are provided by init.
</dd>

	<dt>%response = `Response$I . `error()$m</dt>
	<dd>
~network~errorを表現する `Response$I を作成する。
◎
Creates network error Response.
</dd>

	<dt>%response = `Response$I . `redirect(url, status = 302)$m</dt>
	<dd>
~redirectを表現する `Response$I を作成する
— 状態sに %status を伴い， %url へ~redirectするような。
◎
Creates a redirect Response that redirects to url with status status.
</dd>

	<dt>%response = `Response$I . `json(data [, init])$m</dt>
	<dd>
`Response$I を作成して，その本体を ~JSONに符号化された %~data にする
— ［
状態s,
状態s~message,
~header~list
］は、
%init により供される。
◎
Creates a Response whose body is the JSON-encoded data, and status, status message, and headers are provided by init.
</dd>

	<dt>%response . `type$m</dt>
	<dd>
%response の種別を返す
— 例： `cors^l 。
◎
Returns response’s type, e.g., "cors".
</dd>

	<dt>%response . `url$m</dt>
	<dd>
%response に~URLが［
在るならば それ／
無いならば空~文字列
］を返す。
◎
Returns response’s URL, if it has one; otherwise the empty string.
</dd>

	<dt>%response . `redirected$m</dt>
	<dd>
%response は、
~redirectを通して得されたかどうかを返す。
◎
Returns whether response was obtained through a redirect.
</dd>

	<dt>%response . `status$m</dt>
	<dd>
%response の状態sを返す。
◎
Returns response’s status.
</dd>

	<dt>%response . `ok$m</dt>
	<dd>
%response の状態sは`~ok状態s$であるかどうかを返す。
◎
Returns whether response’s status is an ok status.
</dd>

	<dt>%response . `statusText$m</dt>
	<dd>
%response の状態s~messageを返す。
◎
Returns response’s status message.
</dd>

	<dt>%response . `headers$m</dt>
	<dd>
%response の~header~listを `Headers$I として返す。
◎
Returns response’s headers as Headers.
</dd>

	<dt>%response . `clone()$m</dt>
	<dd>
%response の~cloneを返す。
◎
Returns a clone of response.
</dd>
</dl>

<hr>

<div class="algo">
<p>
`~Response~objを作成する@
~algoは、
所与の
( `応答$ %応答, `~Headers用の~guard$ %~guard, `~realm$ %~realm )
に対し：
◎
To create a Response object, given a response response, headers guard guard, and realm realm, run these steps:
</p>
<ol>
	<li>
%headers ~LET %~realm に属する`新たな$ `Headers$I ~obj
— その
⇒＃
`~header~list$Hl ~SET %応答 の`~header~list$rs,
`~guard$Hl ~SET %~guard
◎
↓</li>
	<li>
%~Response~obj ~LET %~realm に属する`新たな$ `Response$I ~obj
— その
⇒＃
`応答$Rs ~SET %応答,
`~Headers$Rs ~SET %headers
◎
Let responseObject be a new Response object with realm.
◎
Set responseObject’s response to response.
◎
Set responseObject’s headers to a new Headers object with realm, whose headers list is response’s headers list and guard is guard.
</li>
	<li>
~RET %~Response~obj
◎
Return responseObject.
</li>
</ol>
</div>

<div class="algo">
<p>
`~Response~objを初期化する@
~algoは、
所与の
( `Response$I ~obj %~Response~obj【！response】, `ResponseInit$I %init, ［
~NULL ／ `本体と型$
］ %本体と型【！body】 )
に対し：
◎
To initialize a response, given a Response object response, ResponseInit init, and null or a body with type body:
</p>
<ol>
	<li>
~IF［
%init[ "`status$RsI" ] ~NIN { `200^st 〜 `599^st }
］
⇒
~THROW `RangeError$E
◎
If init["status"] is not in the range 200 to 599, inclusive, then throw a RangeError.
</li>
	<li>
~IF［
%init[ "`statusText$RsI" ] ~NEQ 空~文字列
］~AND［
%init[ "`statusText$RsI" ] は
`reason-phrase$p ~token生成規則に合致しない
］
⇒
~THROW `TypeError$E
◎
If init["statusText"] is not the empty string and does not match the reason-phrase token production, then throw a TypeError.
</li>
	<li>
%応答 ~LET %~Response~obj の`応答$Rs
◎
↓</li>
	<li>
%応答 の
⇒＃
`状態s$rs ~SET %init[ "`status$RsI" ],
`状態s~message$rs ~SET %init[ "`statusText$RsI" ]
◎
Set response’s response’s status to init["status"].
◎
Set response’s response’s status message to init["statusText"].
</li>
	<li>
~IF［
%init[ "`headers$RsI" ] ~NEQ ε
］
⇒
%~Response~obj の`~Headers$Rsを`~objで埋める$( %init[ "`headers$RsI" ] )
◎
If init["headers"] exists, then fill response’s headers with init["headers"].
</li>
	<li>
<p>
~IF［
%本体と型 ~NEQ ~NULL
］：
◎
If body is non-null, then:
</p>
		<ol>
			<li>
<p>
~IF［
%応答 の`状態s$rsは`~null本体~状態s$である
］
⇒
~THROW `TypeError$E
◎
If response’s status is a null body status, then throw a TypeError.
</p>

<p class="note">注記：
`101$st, `103$st は、
この段には影響しない
— それは、
他所におけるその利用に因り，`~null本体~状態s$に含まれているので。
◎
101 and 103 are included in null body status due to their use elsewhere. They do not affect this step.
</p>
			</li>
			<li>
%応答 の`本体$rs ~SET %本体と型 の`本体$bwT
◎
Set response’s body to body’s body.
</li>
			<li>
%型 ~LET %本体と型 の`型$bwT
◎
↓</li>
			<li>
~IF［
%型 ~NEQ ~NULL
］~AND［
%応答 の`~header~list$rs内に［
`Content-Type$h を`名前に持つ~header$
］は無い
］
⇒
%応答 の`~header~list$rsに`~headerを付加する$(
( `Content-Type$h, %型 )
)
◎
If body’s type is non-null and response’s header list does not contain `Content-Type`, then append (`Content-Type`, body’s type) to response’s header list.
</li>
		</ol>
	</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`new Response(body, init)@m
構築子~手続きは：
◎
The new Response(body, init) constructor steps are:
</p>
<ol>
	<li>
%応答 ~LET 新たな`応答$
◎
↓</li>
	<li>
コレの`応答$Rs ~SET %応答
◎
Set this’s response to a new response.
</li>
	<li>
コレの`~Headers$Rs ~SET コレに`関連な~realm$に属する`新たな$ `Headers$I ~obj
— その
⇒＃
`~header~list$Hl ~SET %応答 の`~header~list$rs,
`~guard$Hl ~SET `response^l
◎
Set this’s headers to a new Headers object with this’s relevant realm, whose header list is this’s response’s header list and guard is "response".
</li>
	<li>
%本体と型 ~LET %body に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ `本体と型を抽出する$( %body )
◎
Let bodyWithType be null.
◎
If body is non-null, then set bodyWithType to the result of extracting body.
</li>
	<li>
`~Response~objを初期化する$( コレ, %init, %本体と型 )
◎
Perform initialize a response given this, init, and bodyWithType.
</li>
</ol>
</div>

<div class="algo">
`error()@m
静的~method手続きは
⇒
~RET `~Response~objを作成する$( 新たな`~network~error$, `immutable^l, `現在の~realm$ )
◎
The static error() method steps are to return the result of creating a Response object, given a new network error, "immutable", and the current realm.
</div>

<div class="algo">
<p>
`redirect(url, status)@m
静的~method手続きは：
◎
The static redirect(url, status) method steps are:
</p>
<ol>
	<li>
%構文解析した~URL ~LET `~URL構文解析する$( %url, `現在の設定群~obj$の`~API用~基底~URL$enV )
◎
Let parsedURL be the result of parsing url with current settings object’s API base URL.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `TypeError$E
◎
If parsedURL is failure, then throw a TypeError.
</li>
	<li>
~IF［
%status は `~redirect状態s$でない
］
⇒
~THROW `RangeError$E
◎
If status is not a redirect status, then throw a RangeError.
</li>
	<li>
%~Response~obj ~LET `~Response~objを作成する$( 新たな`応答$, `immutable^l, `現在の~realm$ )
◎
Let responseObject be the result of creating a Response object, given a new response, "immutable", and the current realm.
</li>
	<li>
%~Response~obj の`応答$Rsの`状態s$rs ~SET %status
◎
Set responseObject’s response’s status to status.
</li>
	<li>
%値 ~LET `同型に符号化する$( `~URLを直列化する$( %構文解析した~URL ) )
◎
Let value be parsedURL, serialized and isomorphic encoded.
</li>
	<li>
%~Response~obj の`応答$Rsの`~header~list$rsに`~headerを付加する$(
( `Location$h, %値 )
)
◎
Append (`Location`, value) to responseObject’s response’s header list.
</li>
	<li>
~RET %~Response~obj
◎
Return responseObject.
</li>
</ol>
</div>

<div class="algo">
<p>
`json(data, init)@m
静的~method手続きは：
◎
The static json(data, init) method steps are:
</p>
<ol>
	<li>
%~byte列 ~LET `~JS値を~JSON~byte列に直列化する$( %data )
◎
Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
</li>
	<li>
%本体と型【！body】 ~LET `本体と型を抽出する$( %~byte列 )
◎
Let body be the result of extracting bytes.
</li>
	<li>
%~Response~obj ~LET `~Response~objを作成する$( 新たな`応答$, `response^l, `現在の~realm$ )
◎
Let responseObject be the result of creating a Response object, given a new response, "response", and the current realm.
</li>
	<li>
%本体と型 の`型$bwT ~SET `application/json^l
◎
↓</li>
	<li>
`~Response~objを初期化する$( %~Response~obj, %init, %本体と型 )
◎
Perform initialize a response given responseObject, init, and (body, "application/json").
</li>
	<li>
~RET %~Response~obj
◎
Return responseObject.
</li>
</ol>
</div>

<div class="algo">
`type@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`種別$rs
◎
The type getter steps are to return this’s response’s type.
</div>

<div class="algo">
`url@m
取得子~手続きは
⇒
~RET コレの`応答$Rs の`~URL$rs %~URL に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `~URLを直列化する$( %~URL, `素片は除外する$i )
◎
The url getter steps are to return the empty string if this’s response’s URL is null; otherwise this’s response’s URL, serialized with exclude fragment set to true.
</div>

<div class="algo">
<p>
`redirected@m
取得子~手続きは
⇒
~RET ~IS［
コレの`応答$Rsの`~URL~list$rsの`~size$ ~GT 1
］
◎
The redirected getter steps are to return true if this’s response’s URL list’s size is greater than 1; otherwise false.
</p>

<p class="note">注記：
~redirectの結果による`応答$をはじくときは、
~APIを通して直に行う
— 例えば
`fetch(url, { redirect:"error" })^c
のように。
こうすれば、
安全でないものにもなり得る`応答$が不用意に漏洩されるのを~~防げる。
◎
To filter out responses that are the result of a redirect, do this directly through the API, e.g., fetch(url, { redirect:"error" }). This way a potentially unsafe response cannot accidentally leak.
</p>
</div>

<div class="algo">
`status@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`状態s$rs
◎
The status getter steps are to return this’s response’s status.
</div>

<div class="algo">
`ok@m
取得子~手続きは
⇒
~RET ~IS［
コレの`応答$Rsの`状態s$rsは`~ok状態s$である
］
◎
The ok getter steps are to return true if this’s response’s status is an ok status; otherwise false.
</div>

<div class="algo">
`statusText@m
取得子~手続きは
⇒
~RET コレの`応答$Rsの`状態s~message$rs
◎
The statusText getter steps are to return this’s response’s status message.
</div>

<div class="algo">
`headers@m
取得子~手続きは
⇒
~RET コレの`~Headers$Rs
◎
The headers getter steps are to return this’s headers.
</div>

<div class="algo">
<p>
`clone()@m
~method手続きは：
◎
The clone() method steps are:
</p>
<ol>
	<li>
~IF［
コレは`利用-不能$Bdである
］
⇒
~THROW `TypeError$E
◎
If this is unusable, then throw a TypeError.
</li>
	<li>
%~cloneした応答 ~LET `応答を~cloneする$( コレの`応答$Rs )
◎
Let clonedResponse be the result of cloning this’s response.
</li>
	<li>
~RET `~Response~objを作成する$( %~cloneした応答, コレの`~Headers$Rsの`~guard$Hl, コレに`関連な~realm$ )
◎
Return the result of creating a Response object, given clonedResponse, this’s headers’s guard, and this’s relevant realm.
</li>
</ol>
</div>

		</section>
		<section id="fetch-method">
<h3 title="Fetch method">5.6. `fetch^m ~method</h3>

<pre class="idl">
partial interface mixin `WindowOrWorkerGlobalScope$I {
  [`NewObject$] `Promise$&lt;`Response$I&gt; `fetch$m(
      `RequestInfo$I %input,
      optional `RequestInit$I %init = {}
  );
};
</pre>

<div class="algo">
<p>
`fetch(input, init)@m
~method手続きは：
◎
The fetch(input, init) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li>
%~Request~obj ~LET 新たな `Request$I ~obj
◎
↓</li>
	<li>
%~Request~obj 上の `new Request$m 構築子~手続き( %input, %init )
【！構築子の初期~値を呼出した結果】
⇒
例外が投出された場合は
⇒＃
`~promiseを却下する$( %~promise, その例外 )；
~RET %~promise
◎
Let requestObject be the result of invoking the initial value of Request as constructor with input and init as arguments. If this throws an exception, reject p with it and return p.
</li>
	<li>
%要請 ~LET %~Request~obj の`要請$Rq
◎
Let request be requestObject’s request.
</li>
	<li>
<p>
~IF［
%~Request~obj の`通達$Rqは`中止-済み$aBである
］：
◎
If requestObject’s signal is aborted, then:
</p>
		<ol>
			<li>
`~fetch_~callを中止する$( %~promise, %要請, ~NULL, %~Request~obj の`通達$Rqの`中止-事由$aB )
◎
Abort the fetch() call with p, request, null, and requestObject’s signal’s abort reason.
</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</li>
	<li>
%大域~obj ~LET %要請 の`~client$rqの`大域~obj$enV
◎
Let globalObject be request’s client’s global object.
</li>
	<li>
~IF［
%大域~obj は `ServiceWorkerGlobalScope$I ~objである
］
⇒
%要請 の`~sw~mode$rq ~SET `none^l
◎
If globalObject is a ServiceWorkerGlobalScope object, then set request’s service-workers mode to "none".
</li>
	<li>
%~Response~obj ~LET ~NULL
◎
Let responseObject be null.
</li>
	<li>
%関連な~realm ~LET コレに`関連な~realm$
◎
Let relevantRealm be this’s relevant realm.
</li>
	<li>
<p>
%局所的に中止されたか ~LET ~F
◎
Let locallyAborted be false.
</p>

<p class="note">注記：
これは、
~fetchの~callと同じ~threadから中止するよう要請されたとき，
~promiseを却下する時機を予測-可能にするためにある。
◎
This lets us reject promises with predictable timing, when the request to abort comes from the same thread as the call to fetch.
</p>
	</li>
	<li>
%制御器 ~LET ~NULL
◎
Let controller be null.
</li>
	<li>
<p>
`通達に~algoを追加する$( %~Request~obj の`通達$Rq, 次の手続き )
◎
Add the following abort steps to requestObject’s signal:
</p>

<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%局所的に中止されたか ~SET ~T
◎
Set locallyAborted to true.
</li>
			<li>
~Assert：
%制御器 ~NEQ ~NULL
◎
Assert: controller is non-null.
</li>
			<li>
%中止-事由 ~LET %~Request~obj の`通達$Rqの`中止-事由$aB
◎
↓</li>
			<li>
`~fetchを中止する$( %制御器, %中止-事由 )
◎
Abort controller with requestObject’s signal’s abort reason.
</li>
			<li>
`~fetch_~callを中止する$( %~promise, %要請, %~Response~obj, %中止-事由 )
◎
Abort the fetch() call with p, request, responseObject, and requestObject’s signal’s abort reason.
</li>
		</ol>
</div>
	</li>
	<li>
<p>
%制御器 ~SET %要請 を`~fetchする$
— 次を与える下で：
◎
Set controller to the result of calling fetch given request＼
</p>
		<ul>
			<li class="algo">
<p>
`応答の処理n$i ~SET 所与の
( %応答 )
に対し，次を走らす手続き：
◎
and processResponse given response being these steps:
</p>
				<ol>
					<li>
~IF［
%局所的に中止されたか ~EQ ~T
］
⇒
~RET
◎
If locallyAborted is true, then abort these steps.
</li>
					<li>
<p>
~IF［
%応答 の`中止されたか$rs ~EQ ~T
］：
◎
If response’s aborted flag is set, then:
</p>
						<ol>
							<li>
%逆直列化した~error ~LET `直列化された中止-事由を逆直列化する$( %制御器 の`直列化された中止-事由$, %関連な~realm )
◎
Let deserializedError be the result of deserialize a serialized abort reason given controller’s serialized abort reason and relevantRealm.
</li>
							<li>
`~fetch_~callを中止する$( %~promise, %要請, %~Response~obj, %逆直列化した~error )
◎
Abort the fetch() call with p, request, responseObject, and deserializedError.
</li>
							<li>
~RET
◎
Abort these steps.
</li>
						</ol>
					</li>
					<li>
~IF［
%応答 は`~network~error$である
］
⇒＃
`~promiseを却下する$( %~promise, `TypeError$E )；
~RET
◎
If response is a network error, then reject p with a TypeError and abort these steps.
</li>
					<li>
%~Response~obj ~SET `~Response~objを作成する$( %応答, `immutable^l, %関連な~realm )
◎
Set responseObject to the result of creating a Response object, given response, "immutable", and relevantRealm.
</li>
					<li>
`~promiseを解決する$( %~promise, %~Response~obj )
◎
Resolve p with responseObject.
</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>
</div>

<div class="algo">
<p>
`~fetch_~callを中止する@
~algoは、
所与の
( %~promise, %要請, %~Response~obj, %~error )
に対し：
◎
To abort a fetch() call with a promise, request, responseObject, and an error:
</p>
<ol>
	<li>
<p>
`~promiseを却下する$( %~promise, %~error )
◎
Reject promise with error.
</p>

<p class="note">注記：
%~promise がすでに充足されていた場合、
これは何もしない。
◎
This is a no-op if promise has already fulfilled.
</p>
	</li>
	<li>
~IF［
%要請 の`本体$rq ~NEQ ~NULL
］~AND［
%要請 の`本体$rqは`読取n可能$RSである
］
⇒
%要請 の`本体$rqを`取消す$RS( %~error )
◎
If request’s body is non-null and is readable, then cancel request’s body with error.
</li>
	<li>
~IF［
%~Response~obj ~EQ ~NULL
］
⇒
~RET
◎
If responseObject is null, then return.
</li>
	<li>
%応答 ~LET %~Response~obj の`応答$Rs
◎
Let response be responseObject’s response.
</li>
	<li>
~IF［
%応答 の`本体$rs ~NEQ ~NULL
］~AND［
%応答 の`本体$rsは`読取n可能$RSである
］
⇒
%応答 の`本体$rsを`~errorにする$RS( %~error )
◎
If response’s body is non-null and is readable, then error response’s body with error.
</li>
</ol>
</div>

		</section>
		<section id="garbage-collection">
<h3 title="Garbage collection">5.7. ~garbage収集</h3>

<p>
~UAは、
進行中な~fetchを
— その終了nが~scriptを通して観測-可能にならないならば —
`終了-$してもヨイ。
◎
The user agent may terminate an ongoing fetch if that termination is not observable through script.
</p>

<p class="note">注記：
“~scriptを通して観測-可能にならない”
とは、［
`fetch()$m の引数や返り値を通して観測-可能にはならない
］ことを意味する。
~serverとの別の通信-法を通して可能になるものなど，他の仕方は含まれない。
◎
"Observable through script" means observable through fetch()’s arguments and return value. Other ways, such as communicating with the server through a side-channel are not included.
</p>

<p class="note">注記：
~serverは、
~garbage収集が~~起きたことを観測できる
— 例えば［
`WebSocket$I ／ `XMLHttpRequest$I
］~objを通してなど。
◎
The server being able to observe garbage collection has precedent, e.g., with WebSocket and XMLHttpRequest objects.
</p>

<div class="example" id="terminate-examples">
<p>
終了nは観測され得ないので、
~UAは，~fetchを終了させれる：
◎
The user agent can terminate the fetch because the termination cannot be observed.
</p>

<pre class="lang-js">
fetch(`https://www.example.com/^l)
</pre>

<p>
終了nは~promiseを通して観測され得るので、
~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch because the termination can be observed through the promise.
</p>

<pre class="lang-js">
window.promise = fetch(`https://www.example.com/^l)
</pre>

<p>
結付けられた本体は観測-可能にならないので、
~UAは~fetchを終了させれる：
◎
The user agent can terminate the fetch because the associated body is not observable.
</p>

<pre class="lang-js">
window.promise = fetch(`https://www.example.com/^l)
  .then(%res =&gt; %res.headers);
</pre>

<p>
終了nは観測され得ないので、
~UAは~fetchを終了させれる：
◎
The user agent can terminate the fetch because the termination cannot be observed.
</p>

<pre class="lang-js">
fetch(`https://www.example.com/^l)
  .then(%res =&gt; %res.body.getReader().closed);
</pre>

<p>
~promise~obj用に~handlerを登録すれば，終了nを観測できるので、
~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch because one can observe the termination by registering a handler for the promise object.
</p>

<pre class="lang-js">
window.promise = fetch(`https://www.example.com/^l)
  .then(%res =&gt; %res.body.getReader().closed);
</pre>

<p>
登録された~handlerを介して終了nが観測-可能になるので、
~UAは~fetchを終了させれない：
◎
The user agent cannot terminate the fetch as termination would be observable via the registered handler.
</p>

<pre class="lang-js">
fetch(`https://www.example.com/^l)
  .then(%res =&gt; {
    %res.body.getReader().closed
      .then(() =&gt; console.log(`~streamは~closeされた！^l));
  });
</pre>
【！stream closed!】
<p>
（上の例が観測-可能にならないことは、
組込みの［
~prop, 関数
］
— `body.getReader()$c など —
が上書きされていないことを前提にしている。）
◎
(The above examples of non-observability assume that built-in properties and functions, such as body.getReader(), have not been overwritten.)
</p>
</div>

		</section>
	</section>
	<section id="data-urls">
<h2 title="data: URLs">6. ~data_URL</h2>

<p>
~data_URLについての規範的でない記述は、
`RFC2397$r を見よ。
この節は、
その~RFCの規範的な処理~要件を，
配備-済み内容と互換になるよう置換する。
◎
For an informative description of data: URLs, see RFC 2397. This section replaces that RFC’s normative processing requirements to be compatible with deployed content. [RFC2397]
</p>

<div class="p">
<p>
`~data_URL構造体@
は、
次に挙げる`~item$sctからなる`構造体$である：
</p>
<dl class="def-list">
	<dt>
`~MIME型@dU</dt>
	<dd>
`~MIME型$。
</dd>

	<dt>
`本体@dU</dt>
	<dd>
`~byte列$。
</dd>
</dl>

◎
A data: URL struct is a struct that consists of a MIME type (a MIME type) and a body (a byte sequence).
</div>

<div class="algo">
<p>
`~data_URL処理器@
は、
所与の
( `~URL$ %~dataURL )
に対し：
◎
The data: URL processor takes a URL dataURL and then runs these steps:
</p>
<ol>
	<li>
~Assert：
%~dataURL の`~scheme$url ~EQ `data^l
◎
Assert: dataURL’s scheme is "data".
</li>
	<li>
%入力 ~LET `~URLを直列化する$( %~dataURL, `素片は除外する$i )
◎
Let input be the result of running the URL serializer on dataURL with exclude fragment set to true.
</li>
	<li>
%入力 から頭部を成す `data:^l を除去する
◎
Remove the leading "data:" from input.
</li>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position point at the start of input.
</li>
	<li>
%~MIME型 ~LET %入力 内の %位置 から `002C^U `,^smb 以外の`符号位置~並びを収集する$
◎
Let mimeType be the result of collecting a sequence of code points that are not equal to U+002C (,), given position.
</li>
	<li>
<p>
%~MIME型 ~LET `前後の~ASCII空白~列を剥ぐ$( %~MIME型 )
◎
Strip leading and trailing ASCII whitespace from mimeType.
</p>

<p class="note">注記：
これが除去する`符号位置$は、
`0020^U `SPACE^cn に限られる。
◎
This will only remove U+0020 SPACE code points, if any.
</p>
	</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET `失敗^i
◎
If position is past the end of input, then return failure.
</li>
	<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
	<li>
%復号-済み本体 ~LET %入力 内の %位置 からすべての`符号位置~並びを収集する$
◎
Let encodedBody be the remainder of input.
</li>
	<li>
%本体 ~LET `文字列を~byte列に~percent-復号する$( %復号-済み本体 )
◎
Let body be the percent-decoding of encodedBody.
</li>
	<li>
<p>
~IF［
%~MIME型 は次の順の並びに合致する
］…
⇒＃
任意の文字列 %S,
`003B^U `;^smb,
0 個~以上の `0020^U `SPACE^cn,
`~ASCII大小無視$で `base64^l に合致する文字列
◎終
…ならば：
◎
If mimeType ends with U+003B (;), followed by zero or more U+0020 SPACE, followed by an ASCII case-insensitive match for "base64", then:
</p>
		<ol>
			<li>
%文字列~本体 ~LET `同型に復号する$( %本体 )
◎
Let stringBody be the isomorphic decode of body.
</li>
			<li>
%本体 ~SET `~forgiving-base64復号する$( %文字列~本体 )
◎
Set body to the forgiving-base64 decode of stringBody.
</li>
			<li>
~IF［
%本体 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If body is failure, then return failure.
</li>
			<li>
%~MIME型 ~SET %S
◎
Remove the last 6 code points from mimeType.
◎
Remove trailing U+0020 SPACE code points from mimeType, if any.
◎
Remove the last U+003B (;) from mimeType.
</li>
		</ol>
	</li>
	<li>
~IF［
%~MIME型 は `003B^U `;^smb `から開始して$いる
］
⇒
%~MIME型 ~SET 次を順に~~連結した結果
⇒＃
`text/plain^l,
%~MIME型
◎
If mimeType starts with ";", then prepend "text/plain" to mimeType.
</li>
	<li>
%~MIME型~record ~LET `~MIME型を構文解析する$( %~MIME型 )
◎
Let mimeTypeRecord be the result of parsing mimeType.
</li>
	<li>
~IF［
%~MIME型~record ~EQ `失敗^i
］
⇒
%~MIME型~record ~SET `text/plain;charset=US-ASCII^c
◎
If mimeTypeRecord is failure, then set mimeTypeRecord to text/plain;charset=US-ASCII.
</li>
	<li>
~RET 新たな`~data_URL構造体$
— その
⇒＃
`~MIME型$dU ~SET %~MIME型~record,
`本体$dU ~SET %本体
◎
Return a new data: URL struct whose MIME type is mimeTypeRecord and body is body.
</li>
</ol>
</div>

	</section>
	<section id="background-reading">
<h2 title="Background reading">背景情報</h2>

<p>
`この節（および その下位節）は規範的でない。^em
◎
This section and its subsections are informative only.
</p>

		<section id="http-header-layer-division">
<h3 title="HTTP header layer division">~HTTP~header層の~~区分</h3>

<div class="p">
<p>
~fetchingの目的においては、
次に挙げる層がある：
</p>
<ol>
	<li>
~API層
⇒
開発者は、
この層において~headerを設定できる
（概して， `Request$I ~objを通して）。
</li>
	<li>
早期~fetch層
（~HTMLの `img^e 要素, ~CSSの `background-image^css ~propなど）
⇒
`Accept$h, `Accept-Language$h は、
（概して，~UAにより）この層にて設定される。
</li>
	<li>
~sw層
⇒
~API層と同様に，開発者は、
この層において~headerを設定できる。
</li>
	<li>
~network＆~cache層
⇒
`Accept-Encoding$h, `Host$h, `Referer$h など，
~UAにより制御される他のほとんどの~headerは、
この層において設定される。
</li>
</ol>

<p>
`禁止~要請~header$については、
開発者が制御できる部分はほとんどないが，
`Accept$h を制御したり,
`Referer$h を拘束する／省略させる手段【`~referrer施策$】はある。
</p>

◎
For the purposes of fetching, there is an API layer (HTML’s img, CSS’s background-image), early fetch layer, service worker layer, and network &amp; cache layer. `Accept` and `Accept-Language` are set in the early fetch layer (typically by the user agent). Most other headers controlled by the user agent, such as `Accept-Encoding`, `Host`, and `Referer`, are set in the network &amp; cache layer. Developers can set headers either at the API layer or in the service worker layer (typically through a Request object). Developers have almost no control over forbidden request-headers, but can control `Accept` and have the means to constrain and omit `Referer` for instance.
</div>

		</section>
		<section id="atomic-http-redirect-handling">
<h3 title="Atomic HTTP redirect handling">~HTTP~redirectの不可分な取扱い</h3>

<p>
~redirect
（`応答$のうち，［
その`状態s$rs, または
その`内部~応答$の`状態s$rs
］が `~redirect状態s$であるもの）
は、
~APIには公開されない。
仮に~redirectを公開したなら，~XSS攻撃を通して情報が漏洩されることになる。
◎
Redirects (a response whose status or internal response’s (if any) status is a redirect status) are not exposed to APIs. Exposing redirects might leak information not otherwise available through a cross-site scripting attack.
</p>

<p class="example" id="example-xss-redirect">
［
`HttpOnly^bl 付きの `Cookie$h
］が含まれる~URL
（例： `https://example.org/auth^s ）
への~fetchが，秘匿情報を包含する~URL
（例： `https://other-origin.invalid/<em>4af955781ea1c84a3b11</em>^s ）
への~redirectになることもある。
仮に~redirectが公開されたなら、
この秘匿情報は，~XSS攻撃により入手されることになる。
◎
A fetch to https://example.org/auth that includes a Cookie marked HttpOnly could result in a redirect to https://other-origin.invalid/4af955781ea1c84a3b11. This new URL contains a secret. If we expose redirects that secret would be available through a cross-site scripting attack.
</p>

		</section>
		<section id="basic-safe-cors-protocol-setup">
<h3 title="Basic safe CORS protocol setup">安全な~CORS~protocolを設定しておくための基本</h3>

<p>
IP 認証や~firewallを通して~dataが保護されている資源（不幸なことに，未だに ありふれている）に対する`~CORS~protocol$の利用は、
<strong>安全でない</strong>。
（`~CORS~protocol$を考案する必要が生じた理由は、
それである。）
◎
For resources where data is protected through IP authentication or a firewall (unfortunately relatively common still), using the CORS protocol is unsafe. (This is the reason why the CORS protocol had to be invented.)
</p>

<p>
しかしながら、
次の`~header$を利用している場合は<strong>安全である</strong>：
【！otherwise】
◎
However, otherwise using the following header is safe:
</p>

<pre class="lang-http">
Access-Control-Allow-Origin: *
</pre>

<p>
資源が~cookieや~HTTP認証に基づく追加的な情報を公開するときでも、
上の`~header$の利用は，それを露呈しない。
これは、
curl や wget などにより すでに共有されているかのごとく，
資源を `XMLHttpRequest$I などの~APIと共有する。
◎
Even if a resource exposes additional information based on cookie or HTTP authentication, using the above header will not reveal it. It will share the resource with APIs such as XMLHttpRequest, much like it is already shared with curl and wget.
</p>

<p>
したがって，言い換えれば、
当の資源が［
~webに接続している どの機器からも（ curl や wget などを利用して）~accessし得るもの
］でないならば，
上述の`~header$は内包されない。
~accessし得る場合、
それを内包することは，まったく申し分ない。
◎
Thus in other words, if a resource cannot be accessed from a random device connected to the web using curl and wget the aforementioned header is not to be included. If it can be accessed however, it is perfectly fine to do so.
</p>

		</section>
		<section id="cors-protocol-and-http-caches">
<h3 title="CORS protocol and HTTP caches">~CORS~protocolと~HTTP~cache</h3>

<p>
`~CORS~protocol$の要件が，［
`Access-Control-Allow-Origin$hを［
`*^bl ／ 静的な`生成元$
］に設定する
］より複雑なものである場合、
`Vary$h を利用することになる。
`HTML$r
`HTTP$r
`HTTP-CACHING$r
◎
If CORS protocol requirements are more complicated than setting `Access-Control-Allow-Origin` to * or a static origin, `Vary` is to be used. [HTML] [HTTP] [HTTP-CACHING]
</p>

<div class="example" id="example-vary-origin">
<pre class="lang-http">
Vary: Origin
</pre>
</div>

<p>
~serverは、
ある資源において［
その資源への要請が`~CORS要請$である場合に限り，応答~内に
`Access-Control-Allow-Origin$h を送信する
］よう環境設定されているとする。
このとき、
`Vary$h が`利用されない^emと何が起こるか考える。
~UAが その資源への非`~CORS要請$に対する応答を受信したとき
（例えば、`~navi要請$の結果として）、
~UAは，
`Access-Control-Allow-Origin$h を欠く応答
— “非~CORS応答” —
を~cacheすることになる。
~UAは、
後で同じ資源への`~CORS要請$に遭遇した場合にも，
この “非~CORS応答” を利用することになる。
◎
In particular, consider what happens if `Vary` is not used and a server is configured to send `Access-Control-Allow-Origin` for a certain resource only in response to a CORS request. When a user agent receives a response to a non-CORS request for that resource (for example, as the result of a navigation request), the response will lack `Access-Control-Allow-Origin` and the user agent will cache that response. Then, if the user agent subsequently encounters a CORS request for the resource, it will use that cached response from the previous non-CORS request, without `Access-Control-Allow-Origin`.
</p>

<p>
同じ局面で `Vary: Origin^bl を利用した場合、
`Access-Control-Allow-Origin$h を含む応答を~UAに`~fetch$させ，
~cacheされた “非~CORS応答” が利用されることはなくなる。
◎
But if `Vary: Origin` is used in the same scenario described above, it will cause the user agent to fetch a response that includes `Access-Control-Allow-Origin`, rather than using the cached response from the previous non-CORS request that lacks `Access-Control-Allow-Origin`.
</p>

<p>
しかしながら，~serverは、
ある資源に対し，
`Access-Control-Allow-Origin$h を［
`*^bl ／ 静的な`生成元$
］に設定する場合には、
その資源~用の応答~内には
— `~CORS要請$かどうかを問わず —
常に `Access-Control-Allow-Origin$h を送信するよう環境設定して，
`Vary$h は利用しないこと。
◎
However, if `Access-Control-Allow-Origin` is set to * or a static origin for a particular resource, then configure the server to always send `Access-Control-Allow-Origin` in responses for the resource — for non-CORS requests as well as CORS requests — and do not use `Vary`.
</p>

		</section>
		<section id="websocket-protocol">
<h3 title="WebSockets">~WebSocket</h3>

<p>
`WebSocket$I ~objは、
接続を確立する一部として，特別な種類の`~fetch$を起動する
（`~mode$rq `websocket^l を伴う`要請$を利用して）
— それは、
多くの~fetch施策~裁定（ `HSTS$r など）を `WebSocket$I が共有することを許容する。
その結果，~fetchは、
専用な接続を得するため最終的に `WEBSOCKETS$r の中へ~callする。
◎
As part of establishing a connection, the WebSocket object initiates a special kind of fetch (using a request whose mode is "websocket") which allows it to share in many fetch policy decisions, such HTTP Strict Transport Security (HSTS). Ultimately this results in fetch calling into WebSockets to obtain a dedicated connection. [WEBSOCKETS] [HSTS]
</p>

<p class="note">注記：
~Fetchは，以前は［
`~WebSocket接続を得する$,
`~WebSocket接続を確立する$
］を直に定義していたが、
今や どちらも `WEBSOCKETS$r にて定義される。
◎
Fetch used to define obtain a WebSocket connection and establish a WebSocket connection directly, but both are now defined in WebSockets. [WEBSOCKETS]
</p>

		</section>
	</section>
	<section id="fetch-elsewhere">
<h2 title="Using fetch in other standards">他の標準における~fetchの利用-法</h2>

<p>
`~fetching$は、
本質においては，`要請$を`応答$に交換することに過ぎないが、
現実においては，標準にとって正しく採用して利用するには複階的な仕組みである。
この節は、
いくつか助言を与えることを目指す。
◎
In its essence fetching is an exchange of a request for a response. In reality it is rather complex mechanism for standards to adopt and use correctly. This section aims to give some advice.
</p>

<p class="warning">
常に分野の専門家に考査を依頼すること。
◎
Always ask domain experts for review.
</p>

<p class="XXX">
これは、
進捗-中な作業である。
◎
This is a work in progress.
</p>

		<section id="fetch-elsewhere-request">
<h3 title="Setting up a request">要請の設定法</h3>

<p>
`~fetching$における最初の段は、
`要請$を作成して，それを成す`~item$sctたちを拡充することである。
◎
The first step in fetching is to create a request, and populate its items.
</p>

<p>
まずは、
~HTTP `HTTP$r により定義されるとおり，`要請$の［
`~URL$rq, `~method$rq
］の設定から開始すること
⇒
`要請$の`~method$rqが［
`POST$hm ／ `PUT$hm 
］で，本体が必要になる場合、
`要請$の`本体$rqを［
`~byte列$または新たな`本体$
］に設定すること
— 後者の場合、
`本体$の`~stream$bdには， `ReadableStream$I を作成してあてがうこと。
◎
Start by setting the request’s URL and method, as defined by HTTP. If your `POST` or `PUT` request needs a body, you set request’s body to a byte sequence, or to a new body whose stream is a ReadableStream you created. [HTTP]
</p>

<p>
`行先~表t＠#destination-table$内の指導を利用して，
`要請$の`行先$rqを選ぶこと：
◎
Choose your request’s destination using the guidance in the destination table.＼
</p>
<ul>
	<li>
`行先$rqは、
~CSP `CSP$r に影響することに加え，他の含意
— `Sec-Fetch-Dest$h ~headerなど —
もあるので、
単なる情報用の~metadataではない。
◎
Destinations affect Content Security Policy and have other implications such as the `Sec-Fetch-Dest` header, so they are much more than informative metadata.＼
</li>
	<li>
新たな特能に`行先~表t＠#destination-table$内に無い`行先$rqが要求される場合、
そのことを論じるための`課題を申請されたし＠https://github.com/whatwg/fetch/issues/new?title=What%20destination%20should%20my%20feature%20use$。
◎
If a new feature requires a destination that’s not in the destination table, please file an issue to discuss. [CSP]
</li>
</ul>

<p>
`要請$の`~client$rqを当の~fetchを演算している`環境~設定群~obj$に設定すること：
◎
Set your request’s client to the environment settings object you’re operating in.＼
</p>
<ul>
	<li>
~webに公開される~APIは、
一般に，~Web~IDLで定義される
— ある`~interface$を実装する~objは、
どれも，それに利用できる`関連な設定群~obj$がある。
例えば，ある`要素$に結付けられた`要請$は、
`要請$の`~client$rqを［
当の要素の`~node文書$に`関連な設定群~obj$
］に設定することになろう。
◎
Web-exposed APIs are generally defined with Web IDL, for which every object that implements an interface has a relevant settings object you can use. For example, a request associated with an element would set the request’s client to the element’s node document’s relevant settings object.＼
</li>
	<li>
次に該当するものにおいては、
`~client$rqは ~NULL 以外になるベキである
⇒＃
［~JS／~HTML／~CSS］により直に~webに公開される特能／
`Document$I 用の他の下位資源
◎
All features that are directly web-exposed by JavaScript, HTML, CSS, or other Document subresources should have a client.
</li>
</ul>

<p>
当の`~fetching$が~webには直に公開されない場合
（例：当の要請が
— 現在の［
`Window$I ／ `Worker$I
］に依拠することなく —
~backgroundで送信される場合）：
◎
If your fetching is not directly web-exposed, e.g., it is sent in the background without relying on a current Window or Worker,＼
</p>
<ul>
	<li>
`要請$の`~client$rqは ~NULL のままにして，代わりに`要請$の［
`生成元$rq,
`施策~容器$rq,
`~sw~mode$rq,
`~referrer$rq
］を適切な値に設定すること
（例：それらを事前に`環境~設定群~obj$から複製することにより）。
◎
leave request’s client as null and set the request’s origin, policy container, service-workers mode, and referrer to appropriate values instead, e.g., by copying them from the environment settings object ahead of time.＼
</li>
	<li>
これらのより高度な事例では、
当の~fetchが［
~CSP `CSP$r／`~referrer施策$ `REFERRER$r
］をどう取扱うかについての詳細をしっかり~~具体化すること。
◎
In these more advanced cases, make sure the details of how your fetch handles Content Security Policy and referrer policy are fleshed out.＼
</li>
	<li>
同時並行性を取扱うこと
（ `§ ~fetchの呼出法と応答の処理-法＠#fetch-elsewhere-fetch$を見よ）
— ~fetch用の~callbackは，`並列~queue$に~postされることになるので。
◎
Also make sure you handle concurrency, as callbacks (see Invoking fetch and processing responses) would be posted on a parallel queue. [REFERRER] [CSP]
</li>
</ul>

<p>
非同一-生成元~資源を どの仕方で取扱うよう意図するのか，考え抜くこと：
◎
Think through the way you intend to handle cross-origin resources.＼
</p>
<ul>
	<li>
特能には，`同一-生成元$内でしか働かないものもある
— その事例では、
`要請$の`~mode$rqを `same-origin^l に設定すること。
他の場合，~webに公開される新たな特能ならば、
`要請$の`~mode$rqは，ほぼ常に `cors^l に設定するベキである。
◎
Some features may only work in the same origin, in which case set your request’s mode to "same-origin". Otherwise, new web-exposed features should almost always set their mode to "cors".＼
</li>
	<li>
［
当の特能は~webに公開されない場合
］あるいは［
~CORSを伴わずに非同一-生成元~資源を~fetchする別の理由があると考えられる場合
］、
そのことを論じるための`課題を申請されたし＠https://github.com/whatwg/fetch/issues/new?title=Does%20my%20request%20require%20CORS$。
◎
If your feature is not web-exposed, or you think there is another reason for it to fetch cross-origin resources without CORS, please file an issue to discuss.
</li>
</ul>

<p>
非同一-生成元~要請に対しては、
要請に`資格証$を含めるか否かも決定すること
⇒
含める場合、
`要請$の`資格証~mode$rqを `include^l に設定すること。
◎
For cross-origin requests, also determines if credentials are to be included with the requests, in which case set your request’s credentials mode to "include".
</p>

<p>
当の~fetchは、［
`資源の計時^cite `RESOURCE-TIMING$r に報告される必要があるか否か
］および［
どの`起動元~種別$rqを伴わせるか
］を解明すること
⇒
`要請$に ~NULL 以外の`起動元~種別$rqを渡した場合、［
~fetchが済んで，対する`応答$が全部的に~downloadされた
］なら，
`資源の計時^citeに自動的に報告されることになる。
◎
Figure out if your fetch needs to be reported to Resource Timing, and with which initiator type. By passing an initiator type to the request, reporting to Resource Timing will be done automatically once the fetch is done and the response is fully downloaded. [RESOURCE-TIMING]
</p>

<p>
要請には追加的な~HTTP~headerが要求される場合：
◎
If your request requires additional HTTP headers,＼
</p>
<ul>
	<li>
`要請$の`~header~list$rqを［
それらの~headerを包含する`~header~list$
］に設定すること
（例： « ( `My-Header-Name^h, `My-Header-Value^bl ) » ）。
◎
set its header list to a header list that contains those headers, e.g., « (`My-Header-Name`, `My-Header-Value`) ».＼
</li>
	<li>
~custom~headerの送信は、
`~CORS予行~fetch$を要求するなどの含意を伴い得るので，
~careの下で取扱うこと。
◎
Sending custom headers may have implications, such as requiring a CORS-preflight fetch, so handle with care.
</li>
</ul>

<p>
既定の~cache法の仕組みを上書きするよう求める場合
（例：この`要請$用には~cache法を不能化する）
⇒
要請の`~cache~mode$rqを `default^l 以外の値に設定すること。
◎
If you want to override the default caching mechanism, e.g., disable caching for this request, set the request’s cache mode to a value other than "default".
</p>

<p>
要請は~redirectを~supportするよう求まれるかどうか決定すること
⇒
~supportしない場合、
その`~redirect~mode$rq を `error^l に設定すること。
◎
Determine whether you want your request to support redirects. If you don’t, set its redirect mode to "error".
</p>

<p>
`要請$用の残りの~parameterを見渡して，
他に何か関連なものがあるか調べること
⇒
残りの~parameterは、
特別な目的~用にあるものが多く，
利用される頻度は他より低い
— それらは、
この標準の `§ 要請＠#requests$にて詳細に文書化される。
◎
Browse through the rest of the parameters for request to see if something else is relevant to you. The rest of the parameters are used less frequently, often for special purposes, and they are documented in detail in the § 2.2.5 Requests section of this standard.
</p>

		</section>
		<section id="fetch-elsewhere-fetch">
<h3 title="Invoking fetch and processing responses">~fetchの呼出法と応答の処理-法</h3>

<p>
`~fetch$演算は、
`要請$は別として，いくつかの省略可能な引数もとる。
それらの引数には，~algoをとるものがあり、
ある~taskから
（あるいは［
`並列~queueを利用するか$i ~EQ ~T
］の場合は`並列~queue$内で）
~callされることになる：
◎
Aside from a request the fetch operation takes several optional arguments. For those arguments that take an algorithm: the algorithm will be called from a task (or in a parallel queue if useParallelQueue is true).
</p>

<p>
設定しておいた`要請$を`~fetch$するとき，どの~algoを渡すか決定するためには、
対する`応答$をどう処理したいか
— 特に，どの段階で~callbackを受信したいか —
を決定すること：
◎
Once the request is set up, to determine which algorithms to pass to fetch, determine how you would like to process the response, and in particular at what stage you would like to receive a callback:
</p>

<dl>
	<dt>
完了の際
◎
Upon completion
</dt>
	<dd>
ほとんどの~call元は、
`応答$を［
その`本体$rsを成す全体が`~byte列$の中へ読取られてから処理する
］よう取扱う
— 例えば、
`~script資源＠~WAPI#fetch-a-classic-script$や`~style資源＠~CSSVAL#fetch-a-style-resource$。
◎
This is how most callers handle a response, for example scripts and style resources. The response’s body is read in its entirety into a byte sequence, and then processed by the caller.
</dd>
	<dd>
<p>
完了の際に`応答$を処理するためには、
`~fetch$の `応答の本体を消費する処理n$i 引数に~algoを渡すこと。
その~algoには、
`応答$および［
全部的に読取られた（当の応答の`内部~応答$の）`本体$rsを表現している引数
］が渡される。
後者の引数がとり得る値の意味は：
◎
To process a response upon completion, pass an algorithm as the processResponseConsumeBody argument of fetch. The given algorithm is passed a response and an argument representing the fully read body (of the response’s internal response). The second argument’s values have the following meaning:
</p>
		<ul class="switch">
			<li>
~NULL
⇒
%応答 の`本体$rsは ~NULL になった
— ［
%応答 は`~network~error$である／
%応答 の`状態s$rsは`~null本体~状態s$にある
］ことに因り。
◎
null
• The response’s body is null, due to the response being a network error or having a null body status.
</li>
			<li>
`失敗^i
⇒
%応答 の`本体$rsの内容を`読取る＠#body-fully-read$よう試みたが失敗した
— 例：入出力~errorに因り。
◎
failure
• Attempting to fully read the contents of the response’s body failed, e.g., due to an I/O error.
</li>
			<li>
<p>
`~byte列$
⇒
%応答 の`本体$rsの`内部~応答$の内容を`読取る＠#body-fully-read$ことに成功した。
◎
a byte sequence
• Fully reading the contents of the response’s internal response’s body succeeded.
</p>

<p class="warning">
全部的な内容を包含している`~byte列$は、
`~mode$rqが `no-cors^l にされた`要請$にも渡されることになる。
~call元は、
そのような内容を取扱うときは，気を付ける必要がある
— それは、
要請している`生成元$からは，~access可能になるべきでないので。
例えば，
~call元は `no-cors^l `応答$の内容を利用して利用者に画像~内容を直に表示し得るが、
それらの画像~内容は，それらを埋込んでいる文書~内の~scriptには直に公開されるべきでない。
◎
A byte sequence containing the full contents will be passed also for a request whose mode is "no-cors". Callers have to be careful when handling such content, as it should not be accessible to the requesting origin. For example, the caller may use contents of a "no-cors" response to display image contents directly to the user, but those image contents should not be directly exposed to scripts in the embedding document.
</p>
			</li>
		</ul>
	</dd>
	<dd class="example">
		<ol>
			<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET `https://stuff.example.com/^c,
`~client$rq ~SET コレに`関連な設定群~obj$
◎
Let request be a request whose URL is https://stuff.example.com/ and client is this’s relevant settings object.
</li>
			<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request, with＼
</p>
				<ul>
					<li class="algo">
<p>
`応答の本体を消費する処理n$i ~SET 所与の
( `応答$ %応答, ［ ~NULL ／ `失敗^i ／ `~byte列$ ］ %内容 )
に対し，次を走らす手続き：
◎
processResponseConsumeBody set to the following steps given a response response and null, failure, or a byte sequence contents:
</p>
						<ol>
							<li>
~IF［
%内容 ~IN { ~NULL, `失敗^i }
］
⇒
利用者に~errorを呈示する
◎
If contents is null or failure, then present an error to the user.
</li>
							<li>
~ELSE
⇒
%内容 を構文解析して、
その結果に対し
— %応答 からの~metadataを考慮する下で —
当の特能に特有な自前の演算を遂行する
◎
Otherwise, parse contents considering the metadata from response, and perform your own operations on it.
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
	</dd>

	<dt>
まず~header，
それから~chunkごと
◎
Headers first, then chunk-by-chunk
</dt>
	<dd>
一部の事例では
— 例えば、
動画を再生しているときや画像を漸進的に読込んでいるとき —
~fetchの~call元は、
応答を~stream化して，それを成す~chunkたちを 1 個ずつ処理するよう求めることもあろう。
~headerたちが処理されたなら、
`応答$は~call元に引渡され，
~call元は そこから継続する。
◎
In some cases, for example when playing video or progressively loading images, callers might want to stream the response, and process it one chunk at a time. The response is handed over to the fetch caller once the headers are processed, and the caller continues from there.
</dd>
	<dd>
`応答$を~chunkごとに処理するためには、
`~fetch$の`応答の処理n$i 引数に~algoを渡すこと。
その~algoには、
応答の~headerたちが受信されたとき，`応答$が渡される
— 加えて、
`応答$の`本体$rsの`~stream$bdを読取って当の応答の残りを~downloadする責務がある。
◎
To process a response chunk-by-chunk, pass an algorithm to the processResponse argument of fetch. The given algorithm is passed a response when the response’s headers have been received and is responsible for reading the response’s body’s stream in order to download the rest of the response.＼
</dd>
	<dd>
便利~用に，
`応答の本体~終了~時の処理n$i 引数に~algoを渡してもヨイ
— それは、
当の応答と その`本体$rsの読取りが全部的に完遂されたとき，~callされる。
`応答の本体を消費する処理n$i と違って、［
`応答の処理n$i ／
`応答の本体~終了~時の処理n$i
］引数を渡しても，
当の応答が全部的に読取られる保証はないことに注意
— それを読取る責務は、
~call元~自身にある。
◎
For convenience, you may also pass an algorithm to the processResponseEndOfBody argument, which is called once you have finished fully reading the response and its body. Note that unlike processResponseConsumeBody, passing the processResponse or processResponseEndOfBody arguments does not guarantee that the response will be fully read, and callers are responsible to read it themselves.
</dd>
	<dd>
`応答の処理n$i 引数は、
`応答$の`本体$rsをまったく取扱うことなく，`応答$の［
`~header~list$rs／`状態s$rs
］を取扱うためにも有用になる。
これは例えば、
`~ok状態s$でない応答を取扱うときに利用される。
◎
The processResponse argument is also useful for handling the response’s header list and status without handling the body at all. This is used, for example, when handling responses that do not have an ok status.
</dd>
	<dd class="example">
		<ol>
			<li>
%要請 ~LET `要請$
— その
⇒＃
`~URL$rq ~SET `https://stream.example.com/^c,
`~client$rq ~SET コレに`関連な設定群~obj$
◎
Let request be a request whose URL is https://stream.example.com/ and client is this’s relevant settings object.
</li>
			<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request, with＼
</p>
				<ul>
					<li class="algo">
<p>
`応答の処理n$i ~SET 所与の
( `応答$ %応答 )
に対し，次を走らす手続き：
◎
processResponse set to the following steps given a response response:
</p>
						<ol>
							<li>
~IF［
%応答 は`~network~error$である
］
⇒
利用者に~errorを呈示する
◎
If response is a network error, then present an error to the user.
</li>
							<li>
~ELIF［
%応答 の`状態s$rsは`~ok状態s$でない
］
⇒
利用者に何らかの~fallback値を呈示する
◎
Otherwise, if response’s status is not an ok status, present some fallback value to the user.
</li>
							<li>
<p>
~ELSE：
</p>
								<ol>
									<li>
%読取器 ~LET `応答$の`本体$rsの`~stream$bd用に`読取器を取得する$RS
</li>
									<li>
%~MIME型 ~LET `~header~listから~MIME型を抽出する$( %応答 の`~header~list$rs )
</li>
									<li>
%読取器 を %~MIME型 により識別される~MIME型に適切な仕方で処理する
</li>
								</ol>
◎
Otherwise, get a reader for response’s body’s stream, and process in an appropriate way for the MIME type identified by extracting a MIME type from response’s headers list.
</li>
						</ol>
					</li>
				</ul>
			</li>
		</ol>
	</dd>

	<dt>
応答を無視する
◎
Ignore the response
</dt>
	<dd>
`応答$はまったく必要ない事例もある
— 例：
`navigator.sendBeacon()＠~BEACON#dom-navigator-sendbeacon$c 。
［
応答を処理すること／
`~fetch$に対し~callbackを渡すこと
］は，任意選択なので、
~callbackを省略すると，応答を期待しない下で`~fetch$することになる。
そのような事例では，`応答$の`本体$rsの`~stream$bdは破棄されるので、
~call元は，内容が不必要に~downloadされないか心配する必要はない。
◎
In some cases, there is no need for a response at all, e.g., in the case of navigator.sendBeacon(). Processing a response and passing callbacks to fetch is optional, so omitting the callback would fetch without expecting a response. In such cases, the response’s body’s stream will be discarded, and the caller does not have to worry about downloading the contents unnecessarily.
</dd>
	<dd class="example">
		<ol>
			<li>
%要請 ~SET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET `https://fire-and-forget.example.com/^c,
`~method$rq ~SET `POST^hm,
`~client$rq ~SET コレに`関連な設定群~obj$
</li>
			<li>
`要請$を`~fetchする$
</li>
		</ol>
◎
Fetch a request whose URL is https://fire-and-forget.example.com/, method is `POST`, and client is this’s relevant settings object.
</dd>
</dl>

<p>
応答を取扱うための各種~callbackの他にも、
`~fetch$は，高度な事例~用に追加的な~callbackたちを受容する：
◎
Apart from the callbacks to handle responses, fetch accepts additional callbacks for advanced cases.＼
</p>
<dl>
	<dt>
`応答の早期~hintの処理n$i
◎
processEarlyHintsResponse＼
</dt>
	<dd>
`応答$のうち［
その`状態s$rs が `103$st
］を満たすもの用に特定的に意図される。
（現時点で それを取扱うものは、
`~navi$に限られる。）
◎
is intended specifically for responses whose status is 103, and is currently handled only by navigations.＼
</dd>

	<dt>
`要請の本体~chunk長さの処理n$i
◎
processRequestBodyChunkLength and＼
</dt>
	<dt>
`要請の本体~終了~時の処理n$i
◎
processRequestEndOfBody＼
</dt>
	<dd>
これらは、
~call元に対し，要請~本体の~uploadがどこまで進捗したかを通知する。
◎
notify the caller of request body uploading progress.
</dd>
</dl>

<p>
`~fetch$演算は、
それを~callした所と同じ~thread内から開始され，
その内部的な演算を
— その~threadの外で —
`並列的$に走らすことに注意。
上で言及した~callbackは、
所与の`~event~loop$に~postされる
— それは、
既定では，`~client$rqの`大域~obj$enV用のそれになる。
応答を`並列的$に処理して，~main~threadとのヤリトリを~~自前で取扱うためには、
`並列~queueを利用するか$i を ~T に設定する下で`~fetchする$こと。
◎
Note that the fetch operation starts in the same thread from which it was called, and then breaks off to run its internal operations in parallel. The aforementioned callbacks are posted to a given event loop which is, by default, the client’s global object. To process responses in parallel and handle interactions with the main thread by yourself, fetch with useParallelQueue set to true.
</p>

		</section>
		<section id="fetch-elsewhere-ongoing">
<h3 title="Manipulating an ongoing fetch">進行中な~fetchの操作-法</h3>

<p>
すでに開始した`~fetch$演算を操作するときは、
`~fetch$を~callしたとき返された`~fetch制御器$を利用すること。
例えば、
`~fetch制御器$を［
利用者／~page~logic
］に因り`中止-＠#fetch-controller-abort$しても，
~browserに内部的な状況下に因り`終了-$してもヨイ。
◎
To manipulate a fetch operation that has already started, use the fetch controller returned by calling fetch. For example, you may abort the fetch controller due the user or page logic, or terminate it due to browser-internal circumstances.
</p>

<p>
［
終了する／中止する
］ことに加えて、
~call元は，次を行ってもヨイ：
◎
In addition to terminating and aborting, callers may＼
</p>
<ul>
	<li>
`計時を報告する$
— これが，`起動元~種別$rqを渡すことにより自動的に行われなかった場合には。
◎
report timing if this was not done automatically by passing the initiator type,＼
</li>
	<li>
`全部的な計時~報を抽出-＠#extract-full-timing-info$した結果を~call元の側で取扱う。
（これを行うものは、
`~navi$に限られる。）
◎
or extract full timing info and handle it on the caller side (this is done only by navigations).＼
</li>
</ul>

<p>
`~fetch制御器$は、［
`~redirect~mode$rqが `manual^l に設定された`要請$
］用にも，`次回の手動~redirect手続きを処理する$ために利用される。
◎
The fetch controller is also used to process the next manual redirect for requests with redirect mode set to "manual".
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様の策定に~~貢献された次の方々に感謝する：
</p>

`—＠#_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`—＠#_ipr1@

	</section>
</main></div>

<div hidden>

<div lang="en" id="_acks1">
<p>
Thanks to

Adam Barth,
Adam Lavin,
Alan Jeffrey,
Alexey Proskuryakov,
Andreas Kling,
Andrés Gutiérrez,
Andrew Sutherland,
Andrew Williams,
Ángel González,
Anssi Kostiainen,
Arkadiusz Michalski,
Arne Johannessen,
Artem Skoretskiy,
Arthur Barstow,
Arthur Sonzogni,
Asanka Herath,
Axel Rauschmayer,
Ben Kelly,
Benjamin Gruenbaum,
Benjamin Hawkes-Lewis,
Bert Bos,
Björn Höhrmann,
Boris Zbarsky,
Brad Hill,
Brad Porter,
Bryan Smith,
Caitlin Potter,
Cameron McCormack,
Carlo Cannas,
白丞祐 (Cheng-You Bai),
Chirag S Kumar,
Chris Needham,
Chris Rebert,
Clement Pellerin,
Collin Jackson,
Daniel Robertson,
Daniel Veditz,
Dave Tapuska,
David Benjamin,
David Håsäther,
David Orchard,
Dean Jackson,
Devdatta Akhawe,
Domenic Denicola,
Dominic Farolino,
Dominique Hazaël-Massieux,
Doug Turner,
Douglas Creager,
Eero Häkkinen,
Ehsan Akhgari,
Emily Stark,
Eric Lawrence,
Eric Orth,
Feng Yu,
François Marier,
Frank Ellerman,
Frederick Hirsch,
Frederik Braun,
Gary Blackwood,
Gavin Carothers,
Glenn Maynard,
Graham Klyne,
Gregory Terzian,
Hal Lockhart,
Hallvord R. M. Steen,
Harris Hancock,
Henri Sivonen,
Henry Story,
Hiroshige Hayashizaki,
Honza Bambas,
Ian Hickson,
Ilya Grigorik,
isonmad,
Jake Archibald,
James Graham,
Janusz Majnert,
Jeena Lee,
Jeff Carpenter,
Jeff Hodges,
Jeffrey Yasskin,
Jensen Chappell,
Jeremy Roman,
Jesse M. Heines,
Jianjun Chen,
Jinho Bang,
Jochen Eisinger,
John Wilander,
Jonas Sicking,
Jonathan Kingston,
Jonathan Watt,
<span lang="ko">최종찬</span> (Jongchan Choi),
Jordan Stephens,
Jörn Zaefferer,
Joseph Pecoraro,
Josh Matthews,
jub0bs,
Julian Krispel-Samsel,
Julian Reschke,
<span lang="ko">송정기</span> (Jungkee Song),
Jussi Kalliokoski,
Jxck,
Kagami Sascha Rosylight,
Keith Yeung,
Kenji Baheux,
Lachlan Hunt,
Larry Masinter,
Liam Brummitt,
Linus Groh,
Louis Ryan,
Luca Casonato,
Lucas Gonze,
Łukasz Anforowicz,
<span lang="zh">呂康豪</span> (Kang-Hao Lu),
Maciej Stachowiak,
Malisa,
Manfred Stock,
Manish Goregaokar,
Marc Silbey,
Marcos Caceres,
Marijn Kruisselbrink,
Mark Nottingham,
Mark S. Miller,
Martin Dürst,
Martin O’Neal,
Martin Thomson,
Matt Andrews,
Matt Falkenhagen,
Matt Menke,
Matt Oshry,
Matt Seddon,
Matt Womer,
Mhano Harkness,
Michael Ficarra,
Michael Kohler,
Michael™ Smith,
Mike Pennisi,
Mike West,
Mohamed Zergaoui,
Mohammed Zubair Ahmed,
Moritz Kneilmann,
Ms2ger,
Nico Schlömer,
Nicolás Peña Moreno,
Nidhi Jaju,
Nikhil Marathe,
Nikki Bee,
Nikunj Mehta,
Noam Rosenthal,
Odin Hørthe Omdal,
Olli Pettay,
Ondřej Žára,
O. Opsec,
Patrick Meenan,
Perry Jiang,
Philip Jägenstedt,
R. Auburn,
Raphael Kubo da Costa,
Robert Linder,
Rondinelly,
Rory Hewitt,
Ross A. Baker,
Ryan Sleevi,
Sam Atkins,
Samy Kamkar,
Sébastien Cevey,
Sendil Kumar N,
Shao-xuan Kang,
Sharath Udupa,
Shivakumar Jagalur Matt,
Shivani Sharma,
Sigbjørn Finne,
Simon Pieters,
Simon Sapin,
Simon Wülker,
Srirama Chandra Sekhar Mogali,
Stephan Paul,
Steven Salat,
Sunava Dutta,
Surya Ismail,
Tab Atkins-Bittner,
Takashi Toyoshima,
<span lang="ja">吉野剛史</span> (Takeshi Yoshino),
Thomas Roessler,
Thomas Steiner,
Thomas Wisniewski,
Tiancheng "Timothy" Gu,
Tobie Langel,
Tom Schuster,
Tomás Aparicio,
triple-underscore,
<span lang="ja">保呂毅</span> (Tsuyoshi Horo),
Tyler Close,
Ujjwal Sharma,
Vignesh Shanmugam,
Vladimir Dzhuvinov,
Wayne Carr,
Xabier Rodríguez,
Yehuda Katz,
Yoav Weiss,
Youenn Fablet,
Yoichi Osato,
<span lang="ja">平野裕</span> (Yutaka Hirano), and
Zhenbin Xu

for being awesome.
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>
(<a href="https://www.apple.com/">Apple</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>).
</p>
</div>

<div lang="en" id="_ipr1">
<p>
Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.
</p>

<p>
This is the Living Standard. Those interested in the patent-review version should view the <a href="https://fetch.spec.whatwg.org/review-drafts/2024-12/">Living Standard Review Draft</a>.
</p>
</div>

</div>

