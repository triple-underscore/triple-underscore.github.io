<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Infra（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>

.hex-value {
	font-family: sans-serif0, sans-serif;
}

.char-symbol {
	color: gray;
	font-family: monospace;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN0',
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170815 spec
}

function expand(){

	var class_map = {
		U: 'code-point',
		X: 'hex-value',
		A: 'abstract',
		jv: 'js-value'
	};

	var tag_map = {
		c: 'code',
		U: 'span',
		X: 'span',
		i: 'i',
		V: 'var',
		A: 'span',
		jv: 'span',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // byte literal
	text = '`<code class="literal">' + text + '</code>`';
	break;
case 'U': // Unicode code point
	text = 'U+' + text;
	break;
case 'X': // byte value
	text = '0x' + text;
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2018-01-06
trans_update:2018-01-07
spec_status:LS
original_url:https://infra.spec.whatwg.org/
ref_id_prefix:biblio-
ref_id_lowercase:true
copyright:2018,whatwg
trans_1st_pub:2016-11-25


●●original_id_map


●●link_map
真偽値:#boolean

~byte:#byte
~byte列:#byte-sequence
~byte大小無視:#byte-case-insensitive
~byte大文字~化する:#byte-uppercase
~byte小文字~化する:#byte-lowercase
byte.長さ:#byte-sequence-length

同型に復号する:#isomorphic-decode
同型に符号化する:#isomorphic-encode

~scalar値~文字列:#scalar-value-string
~JS文字列:#javascript-string
文字列:#string
~ASCII~byte:#ascii-byte
符号単位:#code-unit
符号位置:#code-point
文字:#code-point
~scalar値~文字列に変換する:#javascript-string-convert
jStr.長さ:#javascript-string-length
str.長さ:#string-length
	~TC39#sec-ecmascript-language-types-string-type

~surrogate:#surrogate
~scalar値:#scalar-value
非文字:#noncharacter
制御文字:#control
~ASCII符号位置:#ascii-code-point
~ASCII英字:#ascii-alpha
~ASCII英数字:#ascii-alphanumeric
~ASCII英大文字:#ascii-upper-alpha
~ASCII英小文字:#ascii-lower-alpha

~ASCII数字:#ascii-digit
~ASCII空白:#ascii-whitespace
~ASCII~tabや~ASCII改行文字:#ascii-tab-or-newline
~C0制御文字:#c0-control
~C0制御文字や~space:#c0-control-or-space
~ASCII~hex数字:#ascii-hex-digit
~ASCII~hex数字（大文字）:#ascii-upper-hex-digit
~ASCII~hex数字（小文字）:#ascii-lower-hex-digit

~ASCII文字列:#ascii-string
~ASCII大小無視:#ascii-case-insensitive
~ASCII大文字~化:#ascii-uppercase
~ASCII大文字~化する:#ascii-uppercase
~ASCII小文字~化する:#ascii-lowercase

位置~変数:#string-position-variable
符号位置~並びを収集する:#collect-a-sequence-of-code-points
~ASCII空白を読飛ばす:#skip-ascii-whitespace
~ASCII空白で分割する:#split-on-ascii-whitespace
~commaで分割する:#split-on-commas
区切子で厳密に分割する:#strictly-split
~ASCII空白を剥いで縮約する:#strip-and-collapse-ascii-whitespace
前後の~ASCII空白~列を剥ぐ:#strip-leading-and-trailing-ascii-whitespace
改行文字を剥ぐ:#strip-newlines
連結する:#string-concatenate


~byte列を~JSONとして構文解析する:#parse-json-from-bytes

~forgiving-base64復号する:#forgiving-base64-decode
~forgiving-base64符号化する:#forgiving-base64-encode

~list:#list
~size:#list-size
~item:#list-item
存在-:#list-contain
包含して:#list-contain
~IN:#list-contain
空:#list-is-empty
空にする:#list-empty
除去-:#list-remove
除去する:#list-remove
付加する:#list-append
前付加する:#list-prepend
挿入する:#list-insert
置換する:#list-replace
~clone:#list-clone
~cloneする:#list-clone

反復する:#list-iterate
~EACH:#list-iterate

有順序~集合:#ordered-set
set.付加する:#set-append
set.前付加する:#set-prepend
set.置換-:#set-replace
set.置換する:#set-replace
交差集合:#set-intersection
下位集合:#set-subset
上位集合:#set-superset
和集合:#set-union

範囲:#the-range


~stack:#stack
~pushする:#stack-push
~popする:#stack-pop

~queue:#queue
~dequeueする:#queue-dequeue
~enqueueする:#queue-enqueue

有順序~map:#ordered-map
map.~key:#map-key
map.値:#map-value
map.~entry:#map-entry
map.~size:#map-size
map.空:#map-is-empty
map.反復する:#map-iterate
~keyたちを取得する:#map-getting-the-keys
値たちを取得する:#map-getting-the-values
~entryを包含して:#map-exists
	map.包含して:#map-exists
	map.存在-:#map-exists
	~map内に存在する:#map-exists
値を取得する:#map-get
	map.取得する:#map-get
値を設定する:#map-set
	map.設定する:#map-set
map.除去する:#map-remove
~entryを除去する:#map-remove

map.~EACH:#map-iterate

構造体:#struct
~pair:#pair
~tuple:#tuple
sct.~item:#struct-item
sct.名前:#struct-name
	#structs


継続-:#iteration-continue
~WHILE:#iteration-while
~CONTINUE:#iteration-continue
~BREAK:#iteration-break
~Assert:#assert


~HTML名前空間:#html-namespace
~MathML名前空間:#mathml-namespace
~SVG名前空間:#svg-namespace
~XLink名前空間:#xlink-namespace
~XML名前空間:#xml-namespace
~XMLNS名前空間:#xmlns-namespace

List:~TC39#sec-list-and-record-specification-type
~UTF-8符号化する:~ENCODING#utf-8-encode
~UTF-8復号する:~ENCODING#utf-8-decode

故意的な違反:#willful-violation

A.Call:~TC39#sec-call
%JSONParse%:~TC39#sec-json.parse


●●words_table1


●●words_table



	●制御
制御-:control:~
制御:control:~
終了-:terminate:~
自動的:automatic:~
再投出-:rethrow:~
投出:throw:~
継続-:continue:~
演算-:operate:~
演算:operation:~
flow::::フロー
call:
	~call元:caller
	~call元の:calling
例外:exception:~
遂行-:perform:~
動作:action:~
catch:
反復:iteration:~
反復-:iterate:~
手続き:steps:~
下位手続き:substeps:~
段:step:~
飛ばす:skip する:~
飛ばし:skip し:~
	残りの:remaining
停止-:stop:~
	各:each
条件:condition:~
合致-:match:~
操作-:manipulate:~
block::::ブロック
繰返す:repeat する:繰り返す
表明:assertion:~
宣言-:declare:~
視野:scope::~::スコープ
error::::エラー
失敗:failure:~
走らす:run する:~

	●未分類
JS:JavaScript
HTML:
MathML:
SVG:
XLink:
XML:
XMLNS:
HTTP:
header::::ヘッダ
browser::::ブラウザ
mark-up:mark up:::マークアップ
名前空間:namespace::~
code::::コード
知覚:perception:~
computer-architecture:computer architecture:::コンピュータアーキテクチャ
単独の:single:~
速度:speed:~
memory::::メモリ
engine::::エンジン
消費:consumption:~
達-:reach:~

対応付ける:mapする:~
処理-:process:~
入子に:nest:入れ子に
要素:element:~
	要素は見つかった:elementSeen
組合せ:combination:組み合わせ
欠いて:lack して:~
	:activation behavior
	になる:become
	行え:done
	~~範囲を超え:out-of-bounds
	真:true
	偽:false
	数:number
	返す:return
	生じ:occur

	●表記
二重引用符:double quotes:~
等幅:monospace::~
font::::フォント
backtick::::バッククォート
引用符:quotation marks:~
丸括弧:parentheses:~
接頭-:prefix:~
有限:finite:~
角括弧:square brackets:~
内側:inside:~
literal::::リテラル
comma::::カンマ
slash::::スラッシュ
具現化-:render:~
具現化形:rendered form:~
表現:representation:~
表現-:represent:~
表記法:notation:~
表記規約:conventions:~
	表記を簡便にする:notational convenience
	表記:say／denote／...
	括って:surrounding
	区切った／区切って:separated
言明:statement:~
言明-:state:~
	~~指示:instruction
	余分の:extra
	少し短い:slightly shorter
	3 桁:three-digit
	前置する:precede
	開始-:start:~
	0 番から数える:zero-based
	書き:write
	後続-:follow:~
	〜:inclusive

	●文字／文字列／byte列
ASCII:
Unicode:
C0:
space:
data::::データ
byte::::バイト
	byte列:bytes
bit::::ビット
16-bit::::16ビット
hex:16 進
hex-num:hexadecimal number:16 進数
無符号:unsigned:~
整数:integer:~
長さ:length:~

文字:character::~
非文字:noncharacter::~
文字列:string::~
制御文字:control::~
数字:digit::~
符号位置:code point::~
符号単位:code unit::~
符号化方式:encoding::~
UTF-8:
符号化-:encode::~::エンコード
復号-:decode::~::デコード
tab:
scalar::::スカラー
surrogate::::サロゲート
英字:alpha::~
英大文字:upper alpha::~
英小文字:lower alpha::~
英数字:alphanumeric::~
改行文字:newline::~
空白:whitespace::~
大小無視:case-insensitive:~
大文字:uppercase::~
小文字:lowercase::~
	~~大文字:capital letter
	~~大文字化:capitalize
構文:syntax::~

構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
直列化-:serialize::~::シリアル化
読飛ばす:skip する:読み飛ばす
token::::トークン
縮約-:collapse::~
位置:position::~
収集-:collect::~
剥ぐ:strip する::~
剥いで:strip して::~
剥いだ:strip した::~
厳密:strict::~
区切子:delimiter::~
分離子:separator::~
連結-:concatenate::~
緩く:lenient に:~
散在-:intersperse:~
分割-:split::~
変数:variable::~
追跡-:track:~
入出力:I/O:~
入力:input:~
出力:output:~
孤立した:isolated:~
変換-:convert:~
変換:conversion:~
同型に:isomorphic::~
JSON:
forgiving-base64:
base64:
	大目に:forgiving:~

	連続する:consecutive な／
	1 個の:single
	を満たす:meet
	1 個~以上:one or more
	先頭の文字を指している pointing at the start of 

	に加え、in addition to



	●data 構造
primitive:
真偽値:boolean::~
data::::データ
map::::マップ
list::::リスト
stack::::スタック
集合:set::~
部分集合:subset:~
下位集合:subset::~
上位集合:superset::~
和集合:union::~
交差集合:intersection::~

構造体:struct::~
entry::::エントリ
item::::アイテム
key::::キー
pair::::ペア
size::::サイズ
status::::ステータス
text::::テキスト
tuple::::タプル
index:
indexing::::index アクセス
IDL:
push:
pop:
queue::::キュー
enqueue::::エンキュー
dequeue::::デキュー
instance::::インスタンス
構造:structure::~
型:type::~
派生型:derivative::~
無順序:unordered::~
有順序:ordered::~
順序:order::~
	~~昇順:consecutively increasing order
空:empty::~
連列:sequence::~
付加-:append::~
前付加-:prepend::~
追加-:add::~
追加の:additional::~
除去-:remove::~
更新-:update::~
取得-:get::~
設定-:set::~
置換-:replace::~
挿入-:insert::~
clone::::クローン
存在-:exist::~
列挙:enumeration::~
検索-:look up::~
包含-:contain::~
作成-:create::~
新たな:new::~
内容:content::~
値:value::~
範囲:range::~
名前:name::~
名:name::~
命名-:name::~
命名:naming::~
一意:unique:~
変異不可:immutable:~
浅い:shallow な::~

	●仕様
algo:algorithm:::アルゴリズム
規範的:normative:~
	規範的でない:non-normative
図式:diagram:~
明示的:explicit:~
keyword::::キーワード
解釈-:interpret:~
出現-:appear:~
命令的:imperative:~
導入-:introduce:~
	意味-:mean:~
	意味:meaning:~
等価:equivalent:~
一般:general:~
実装-:implement:~
実装:implementation:~
含意-:imply:~
	-:implies
意図-:intend:~
意図的:intentional:~
処理能:performance::~::パフォーマンス
		処理能を高める:performant／performance 〜 to get 
排他的:exclusive:~
要件:requirements:~
注釈文:prose:~
各種用語:terminology:~
目標:goal:~
規約:conventions:~
用法:usage:~
依存-:depend:~
	依存する他の仕様:dependencies
避ける:avoid する:~
多義性:ambiguity:~
各種用語:terminology:~
相互参照:cross-reference:~
強く:strong に:~
奨励-:encourage:~
適合性:conformance:~
制限-:limit:~
読易い:readable な:読み易い
読易く:readable に:読み易く
	より読易く:improve readability
	読み易さ:legibility
	考えられる:considered
動機:motivation:~
	動機にある:motivated by
仕様:spec:~
level::::レベル
意味論:semantics:~
際どい:edge:~
	とりわけ:especially
複雑な:complex:~
供-:provide:~
共通の:common:~
共通して:common に:~
共通的に:common に:よく
変種:variant:~
文脈:context:~
定義:definition:~
定義-:define:~
改変-:modify:~
特定0の:particular:ある特定の
相互運用性:interoperability:~
開発者:developer:~
公開:expose:~
最適化-:optimize:~
観測-:observe:~
	観測し得ない:not observable
事実:fact:~
	に基づいて:based on
	依然として:still
通常の:normal な:~
見做す:assume する:~
既定:default:~
指名-:designate:~
指定-:specify:~
事例:case:~
web:
platform::::プラットフォーム
示唆:suggestion:~
	歓迎する:welcome
曖昧:vague:~
共有-:share:~
理解:understanding:~
働いて:work して:~
上手く:well に:~
語彙:vocabulary:~
期待-:expect:~
慣例的:conventional:~
慣例:conventional:~
要求-:require:~
推奨-:recommend:~
任意選択:optional:~
文書:document:~
	文書~化:document
多義性:ambiguities:~
地盤:ground:~
一貫する:consistentになる:~
概念:concept:~
定型文:boilerplate:~
集約-:deduplicate:~
混同-:confuse:~
	confusion
既存の:existing:~
揃える:align する:~
簡便:convenient:~
由来-:originate:~
特定の:specific:~
方式:manner:~
目指す:aim する:~
築かれ:build され:~
標準:standard:~
標準の:standard な:~
	標準:Standard
	標準~化-:standardize
基礎的:fundamental:~
適切:appropriate:~
策定者:author:~
正しく:correct に:~
反映-:reflect:~
変更:changes:~
変更-:change:~
変化-:change:~
将来非互換な:future breaking:~
仕方:way:~
孕む:involve する:~
含意:implication:~
実際の:actual な:~
一義的:unambigious:~
多義的:ambiguous:~
明確化-:clarify:~
明瞭:clear:~
冗長:verbose:~
許容-:allow:~
不変則:invariant:~
重要:important:~
適用-:apply:~
	applicable
網羅的:exhaustive:~
課題:issue:~
利用者:user:~
有用:useful:~
	利用:use
	利用-:use
分野:field:~
最善:best:~
生産的:productive:~
競う:compete する:~
指示-:indicate:~
報告-:report:~
取組まれ:address され:取り組まれ
概して:typical に:~
便宜:convenience:~
例示-:demonstrate:~
柔軟性:flexibility:~
壊す:break する:~
実質的:effective:~
暗黙的:implicit:~
既知:known:~
理由:reason:~
実際:actual:~
実際の:actual な:~
実施:practice:~
保全-:preserve:~
相互作用-:interact:やりとり
依拠-:rely:~
	あいにく:unfortunately
状況下:circumstances:~
故意的な:willful:故意による
違反:violation:~
違反-:violate:~
競合-:conflict:~
準拠性:compliance:~
破戒:transgression:~
commit:
発行-:publish:~
長年の:long-standing:~
	注記-:note
欲され:desire され:欲され
対称:symmetric:~
	symmetry
取扱い:handling:取り扱い
稀:rare:まれ
波及-:influence:~
特殊:special:~
交換可能:interchangeable:~

	特に:In particular
	~~区別:distinction
	~~不要な:immaterial
	必要性:needs
	必要:need
	~~提出-:file
	したがって:therefore
	見込みが高い:likely
	無理な注文:insurmountable task
	ここに記したように:As illustrated,
	挙げられている:outlined
	年月に耐え得る:stand the test of time
	時を経:over time
	対して，:as opposed to
	易くなる:in order to help
	-:editors
	-:ensure
	再掲:repeat:~
	用立てる:make use
	加えて:additionally:~
	-:ability:~
	介して:via
	表す:express
	働きかける:working with
	言い回し:phrasing
	句され:phrase され:記され
	-:titled
	-:statement
	item
	もたらし:lead to
	~~拡張-:expand
	-:explain:~
	置き場:place
	帰属させるには そぐわない:without a good home
	様々にしている:divergent
	-:mark
	されたし:please
	具体例として:for instance
	普及度:how common
	分枝する／分枝:code path
	残して:left over
	称される:known
	し難い:difficult
	ためだけの:nonsense 〜 for the purpose of
	限り:as long as
	満たされ:met
	こともある:sometimes
	help／-:易くする
	扱い難い代物:tricky
	後で〜ことになる:comes into play
	もよくある:It is even fairly typical for
	節:section
	-:kind
	可能:possible
	meant
	per
	れることも:sometimes
	指す／称する:refer
	べき:should
	-:conversely

	●指示語
	所与の:given:与えられた
	異なる:different
	様々な:different
	多様な:wide variety of
	この:this
	その:that
	それらの:their
	それら:they
	それらの:those
	それらを:them
	ほとんど:almost
	そのような:such
	常に:always
	必ず:only ever be
	他の場合:otherwise
	他の:other
	対応:correspond
	複数の:multiple
	後続の:subsequent
	種々の:variety of
	同じ:same
	少数の:small:~
	元の:original
	〜元:original
	最初の:first
	両者:both
	2 個の:two
	上の:above
	別の:another
	:between
	種々の:variety
	多数:many
	すべて:all
	何か:something
	最後の:last:~
	最初の:first:~
	重ねて現れ:twice
	末尾:the end of
	先頭:the beginning of
	の個数:number of
	そのまま:leaving 〜 as-is
	成す／からなる:consist
	逆に、reverse
	end-up
	後者
	前者
	多くの:many
	ある種の:certain
	前:previous
	〜以前の:pre-
	結果:result
	自身:itself／themselves
	代わりに:instead

●●ref_normative

[ECMA-262]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[RFC20]
    V.G. Cerf. ASCII format for network interchange. October 1969. Internet Standard. URL: https://tools.ietf.org/html/rfc20 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC4648]
    S. Josefsson. The Base16, Base32, and Base64 Data Encodings. October 2006. Proposed Standard. URL: https://tools.ietf.org/html/rfc4648 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 

●●ref_informative

[RFC8174]
    B. Leiba. Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words. May 2017. Best Current Practice. URL: https://tools.ietf.org/html/rfc8174 

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">Infra Standard</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata
Participate:
	<a href="https://github.com/whatwg/infra">GitHub whatwg/infra</a>(<a href="https://github.com/whatwg/infra/issues/new">new issue</a>, <a href="https://github.com/whatwg/infra/issues">open issues</a>)
	<a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>

Commits:
	<a href="https://github.com/whatwg/infra/commits">GitHub whatwg/infra/commits</a>
	<a href="https://infra.spec.whatwg.org/commit-snapshots/09a4b97ff908cd8cc2f6e61b53ddac7d6ee29f2f/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/infrastandard">@infrastandard</a>

Tests:
	<a href="https://github.com/w3c/web-platform-tests/tree/master/infra">web-platform-tests infra/</a> (<a href="https://github.com/w3c/web-platform-tests/labels/infra">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>


</head>
<body>

<header id="head">

<a
	href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZwoJeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCIKCXN0cm9rZT0iIzNjNzkwYSIKPgo8c3R5bGU+CmNpcmNsZSB7CglmaWxsOiB3aGl0ZTsKCXN0cm9rZS13aWR0aDogMTA7Cn0KcGF0aCB7CglmaWxsOiB0cmFuc3BhcmVudDsKfQpwYXRoLmRhc2hlZCB7CglzdHJva2UtZGFzaGFycmF5OiAzLDE7Cn0KPC9zdHlsZT4KCjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjQ1Ii8+Cgo8cGF0aCBkPSJNNTAsMTUgTDE1LDUwIEw1MCw4NSBMODUsNTAgWiIvPgo8cGF0aCBkPSJNMTUsNTAgTDQ1LDU1IEw4NSw1MCIvPgo8cGF0aCBkPSJNNTAsMTUgTDQ1LDU1IEw1MCw4NSIvPgoKPHBhdGggZD0iTTE1LDUwIEw1NSw0NSBMODUsNTAiIGNsYXNzPSJkYXNoZWQiLz4KPHBhdGggZD0iTTUwLDE1IEw1NSw0NSBMNTAsODUiIGNsYXNzPSJkYXNoZWQiLz4KPC9zdmc+Cg=="
></a>

	<hgroup>
<h1 id="title">基盤 — Infra</h1>
	</hgroup>
</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様 Infra Standard は、それを基に築かれる標準の基礎的な概念を定義することを目指す。
◎
The Infra Standard aims to define the fundamental concepts upon which standards are built.
</p>

	</section>


<main id="MAIN0">

	<section id="goals">
<h2 title="Goals">目標</h2>

<ul>
	<li>
各種 標準における定型文を集約する。
◎
Deduplicate boilerplate in standards.
</li>
	<li>
各種 標準における
規約, 各種用語, ~data構造
を揃える。
◎
Align standards on conventions, terminology, and data structures.
</li>
	<li>
複数の標準から利用されている概念のうち，それらの標準に帰属させるには そぐわないものの置き場とする。
◎
Be a place for concepts used by multiple standards without a good home.
</li>
	<li>
多義的になる概念を明確化して，明瞭かつ読易い~algo的~注釈文を書き易くする。
◎
Help write clear and readable algorithmic prose by clarifying otherwise ambiguous concepts.
</li>
</ul>

<p>
他にも目標の示唆があれば歓迎する。
◎
Suggestions for more goals welcome.
</p>


	</section>
	<section id="usage">
<h2 title="Usage">1. 用法</h2>

<p>
文書 %X にてこの仕様を用立てるときは、
<q>%X  は Infra Standard に依存する。</q>
等と記す。
加えて，多義性を避けるため、各種用語を相互参照することも奨励される。
◎
To make use of the Infra Standard in a document titled X, use X depends on the Infra Standard. Additionally, cross-referencing terminology is encouraged to avoid ambiguity.
</p>

<p>
仕様の策定者には、自身の仕様を
<a href="https://github.com/whatwg/infra/wiki/Dependent-specs">この仕様に依存している仕様の~list</a>
に追加しておくことも奨励される。
そうしておけば、この仕様に将来非互換な変更が加えられても，依存する他の仕様に正しく反映させ易くなるので。
◎
Specification authors are also encouraged to add their specification to the list of dependent specifications in order to help the editors ensure that any future breaking changes to the Infra Standard are correctly reflected by any such dependencies. 
</p>

	</section>
	<section id="conventions">
<h2 title="Conventions">2. 表記規約</h2>

		<section id="conformance">
<h3 title="Conformance">2.1. 適合性</h3>

<p>
規範的でないものと明示的に記された節に加え，すべての表明, 図式, 例, 注記は、規範的ではない。
他のすべては規範的である。
◎
All assertions, diagrams, examples, and notes are non-normative, as are all sections explicitly marked non-normative. Everything else is normative.
</p>

<div class="p">
<p>
次の各種~keywordは、 `RFC2119$r に則って解釈されるものとする：
</p>

<table>
<thead><tr><th>原語
<th>和訳表記
</thead><tbody>

<tr><td>`MUST^en
<td>〜しなければ<em class="rfc2119">ならない</em>

<tr><td>`MUST NOT^en
<td>〜しては<em class="rfc2119">ならない</em>

<tr><td>`REQUIRED^en
<td><em class="rfc2119">要求され</em>る

<tr><td>`SHALL^en
<td>— †

<tr><td>`SHALL NOT^en
<td>— †

<tr><td>`SHOULD^en
<td>〜する<em class="rfc2119">べき</em>である

<tr><td>`SHOULD NOT^en
<td>〜する<em class="rfc2119">べき</em>でない

<tr><td>`SHOULD NOT^en
<td>〜しない<em class="rfc2119">べき</em>である

<tr><td>`RECOMMENDED^en
<td>〜することが<em class="rfc2119">推奨され</em>る

<tr><td>`NOT RECOMMENDED^en
<td><em class="rfc2119">推奨され</em>ない

<tr><td>`NOT RECOMMENDED^en
<td>〜しないことが<em class="rfc2119">推奨され</em>る

<tr><td>`MAY^en
<td>〜しても<em class="rfc2119">よい</em>

<tr><td>`OPTIONAL^en
<td><em class="rfc2119">任意選択</em>で〜

</tbody></table>

<p class="trans-note">【†
事実上、 SHALL が利用されている箇所は，皆無に近い（この仕様を参照しない仕様も含め）。
実質的に MUST （MUST NOT）と同義なので、現れたとしても，和訳では MUST と同じ表記を用いることにする。
】</p>

◎
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in RFC 2119. [RFC2119]
</div>

<p>
これらの~keywordは，小文字で記されても等価な意味になり、規範的でない内容に現れることはない†。
◎
These keywords have equivalent meaning when written in lowercase and cannot appear in non-normative content.
</p>

<p class="trans-note">【†
また、現れたとしても，その内容が規範的とされるわけではない。
】</p>

<p class="note">注記：
これは RFC 8174 に対する`故意的な違反$であり、読み易さ, および［
RFC 8174 以前の， IETF 以外から発行された多くの文書における、長年の実施
］を保全するよう欲されていることが，動機にある。
`RFC8174$r
◎
This is a willful violation of RFC 8174, motivated by legibility and a desire to preserve long-standing practice in many non-IETF-published pre-RFC 8174 documents. [RFC8174]
</p>

<p>
上のすべては、この標準, および この標準を利用する文書に適用し得る。
この標準を利用する文書は、~keywordの利用を［
"must", "must not", "should", "may"
］のみに制限すること, および それらを小文字で記す†ことが奨励される
— その方が一般に読易くなると考えられるので。
◎
All of the above is applicable to both this standard and any document that uses this standard. Documents using this standard are encouraged to limit themselves to "must", "must not", "should", and "may", and to use these in their lowercase form as that is generally considered to be more readable.
</p>

<p class="trans-note">【†
和訳では、これらに対応する和訳表記は ~mark-upされずに記される。
】【
和訳に固有の詳細は、
<a href="index.html#rfc2119-phrase">RFC 2119 が規定する句に利用される対訳</a>
も参照されたし。
】</p>

<div class="p">
<p>
規範的でない内容には、代わりに，次を利用できる：
</p>

<table>
<thead><tr><th>原語
<th>和訳表記（括弧内は否定形）
</thead><tbody>

<tr><td>`strongly encouraged^en, `strongly discouraged^en
<td>
（〜しないことが）強く奨励される

<tr><td>`encouraged^en, `discouraged^en
<td>
（〜しないことが）奨励される, （奨励されない）

<tr><td>`can^en, `cannot^en
<td>
〜できる（できない）,
〜し得る（得ない）,
〜になり得る（得ない）,
〜になる（ならない）［
こと／場合／とき
］がある,
（〜［
する／になる
］ことはない）,
等々

<tr><td>`could^en, `could not^en
<td>
〜する（しない）こともできる,
〜になる（ならない）こともある,
〜も〜できる,
〜にもなり得る,
等々

<tr><td>`might^en, `might not^en
<td>
〜（［
しない／ でない／にならない／等々
］）かもしれない,
（同）であろう,
（同）こともあろう,
（同）ときもある,
等々

</tbody></table>

◎
For non-normative content "strongly encouraged", "strongly discouraged", "encouraged", "discouraged", "can", "cannot", "could", "could not", "might", and "might not" can be used instead.
</div>


		</section>
		<section id="other-specs">
<h3 title="Compliance with other specifications">2.2. 他の仕様への準拠性</h3>

<p>
一般に，仕様は、他の多様な仕様と相互作用したり, それらに依拠する。
あいにく，ある種の状況下では、互いに競合する必要性により，仕様が他の仕様による要件に違反することが要求される。
これが生じたときは、この仕様を利用している文書は，そのような破戒を
`故意的な違反@
（ `willful violation^en ）として表記して，その違反の理由を注記するべきである。
◎
In general, specifications interact with and rely on a wide variety of other specifications. In certain circumstances, unfortunately, conflicting needs require a specification to violate the requirements of other specifications. When this occurs, a document using the Infra Standard should denote such transgressions as a willful violation, and note the reason for that violation.
</p>

<p class="example" id="example-willful-violation">
前~節の
<a href="#conformance">適合性</a> 
では、［
この仕様により~commitされた RFC 8174 への`故意的な違反$
］を文書~化している。
◎
The previous section, §2.1 Conformance, documents a willful violation of RFC 8174 committed by the Infra Standard.
</p>

		</section>
		<section id="terminology">
<h3 title="Terminology">2.3. 各種用語</h3>

<p>
“または”, “いずれか”
などの句（ “`or^en” ）は、特に断らない限り，あるいは排他的としか解釈し得ない場合を除き、排他的でないとする。
排他的になるときは、
“片方”, “いずれかのみ”
等々の句でそう記される。
◎
The word "or", in cases where both inclusive "or" and exclusive "or" are possible (e.g., "if either width or height is zero"), means an inclusive "or" (implying "or both"), unless it is called out as being exclusive (with "but not both").
</p>

		</section>
	</section>
	<section id="algorithms">
<h2 title="Algorithms">3. ~algo</h2>


<p class="trans-note">【
この節の内容は、和訳における ~SYMBOL_DEF_REFと重複する。
その表記規約は，この仕様が作成される以前からあり、この仕様を参照する仕様のみならず，このサイトの大多数の和訳に利用されている。
そのため、この節に定義される一部の原文~keywordは，その表記規約に整合するように違えている。
】</p>

<p>
~algo, あるいは ~algoの一部として命令的†に句される要件（
“頭部の空白~並びを取り除く”, “~F を返す”
など）は、当の~algoや手続きを導入するときに利用された~keyword（ “~MUST”, 等）を意味するものと解釈するものとする。
そのような~keywordが用いられていない所では “~MUST” が含意される。
◎
Algorithms, and requirements phrased in the imperative as part of algorithms (such as "strip any leading spaces" or "return false") are to be interpreted with the meaning of the keyword (e.g., "must") used in introducing the algorithm or step. If no such keyword is used, must is implied.
</p>

<p class="trans-note">【†
英語では命令形であるが、和訳では単に “現在形”。
】</p>


<div class="example" id="example-algorithms">
<p>
例えば、仕様にて，次のように記されている所では…：
◎
For example, were the spec to say:
</p>

<blockquote>
<p>
オレンジを食べるときは、次をし~MUST：
◎
To eat an orange, the user must:
</p>
<ol>
	<li>
オレンジの皮を剥く
◎
Peel the orange.
</li>
	<li>
オレンジを切り分ける
◎
Separate each slice of the orange.
</li>
	<li>
切り分けたオレンジを食べる
◎
Eat the orange slices.
</li>
</ol>
</blockquote>

<p>
…次に等価になる：
◎
it would be equivalent to the following:
</p>

<blockquote>
<p>
オレンジを食べるときは：
◎
To eat an orange:
</p>
<ol>
	<li>
オレンジの皮を剥か~MUST
◎
The user must peel the orange.
</li>
	<li>
オレンジを切り分け~MUST
◎
The user must separate each slice of the orange.
</li>
	<li>
切り分けたオレンジを食べ~MUST
◎
The user must eat the orange slices.
</li>
</ol>

</blockquote>

<p>
ここでの~keywordは “~MUST” である。
◎
Here the key word is "must".
</p>

<p>
上の例で ~algoの導入-時に，単に
“オレンジを食べるときは、次を行う”
等と記されたときも、同じく “~MUST” が含意される。
◎
Modifying the above example, if the algorithm was introduced only with "To eat an orange:", it would still have the same meaning, as "must" is implied.
</p>

<p class="trans-note">【
“次をする~SHOULDである／しても~MAY…”
と記されていても，個々の段には “~MUST” が含意される
— そのような “~SHOULD／~MAY” は、 <em>手続き全体</em>（その句の視野にある一連の段）を “するかしないか” にかかる。
】</p>

</div>

<p class="trans-note">【
~algoに限らず，和訳では、同様の規約を，要件の箇条書き等にも利用している
— 例：
“次を満たさ~MUST： （…箇条書き…）”
】</p>

<p>
~algoや特定の手続きとして句されている適合性~要件は、~~最終的な結果が等価になる限り，どのような方式で実装されても~MAY（特に、各種~algoは，追い易いように意図されており、処理能を高めることは意図されていない。）
◎
Conformance requirements phrased as algorithms or specific steps may be implemented in any manner, so long as the end result is equivalent. (In particular, the algorithms are intended to be easy to follow, and not intended to be performant.)
</p>

<p class="note">注記：
処理能を正しく高めることは扱い難い代物である
— ［
利用者の知覚,
~computer-architecture,
様々な型の入力
］がそれに波及し、これらの普及度も 時を経れば変化し得るので。
具体例として，［
単独の~algoとして標準~化されたもの
］用の［
~JS~engineにおける~code
］は、速度や~memory消費を最適化するため，多数に分枝する見込みが高い。
それらの~code分枝すべてを標準~化するのは 無理な注文であり，生産的でない
— 単独の~algoほどに年月に耐え得るものではないので。
したがって、処理能については互いに競う分野に残しておくのが最善である。
◎
Performance is tricky to get correct as it is influenced by user perception, computer architectures, and different types of input that can change over time in how common they are. For instance, a JavaScript engine likely has many different code paths for what is standardized as a single algorithm, in order to optimize for speed or memory consumption. Standardizing all those code paths would be an insurmountable task and not productive as they would not stand the test of time as well as the single algorithm would. Therefore performance is best left as a field to compete over.
</p>

		<section id="variables">
<h3 title="Variables">3.1. 変数</h3>

<p>
変数は、
"~LET"
【原文では “`let^en”】
で宣言され，
"~SET"
【原文では “`set^en”】
で変更される。
◎
A variable is declared with "let" and changed with "set".
</p>

<p class="example" id="example-variable">
%~list ~LET 新たな`~list$
◎
Let list be a new list.
</p>

<div class="example" id="example-variable-null">

<ol>
	<li>
%値 ~LET ~NULL
◎
Let value be null.
</li>
	<li>
~IF［
%入力 は`文字列$である
］
⇒
%値 ~SET %入力
◎
If input is a string, then set value to input.
</li>
	<li>
~ELSE
⇒
%値 ~SET `~UTF-8復号する$( %入力 )
◎
Otherwise, set value to input, UTF-8 decoded.
</li>
	<li>
`~Assert$：
%値 は`文字列$である
◎
Assert: value is a string.
</li>
</ol>

</div>

<p class="example">
%activationTarget ~LET ［
次が満たされるならば %target ／
~ELSE_ ~NULL
］
⇒
［
%isActivationEvent ~EQ ~T
］~AND［
%target `has activation behavior^en
］
◎
Let activationTarget be target, if isActivationEvent is true and target has activation behavior, and null otherwise.
</p>


<p>
変数は、宣言される前に利用されては~MUST_NOT。
変数の
<a href="https://en.wikipedia.org/wiki/Scope_(computer_science)#Block_scope">視野は~block</a>である†。
変数は、複数~回 宣言されては~MUST_NOT。
◎
Variables must not be used before they are declared. Variables are block scoped. Variables must not be declared more than once per algorithm.
</p>

<p class="trans-note">【†
とは言え，実際の仕様では、当の変数が，［
それを宣言した~algoが~callしている，他所の下位手続き
］からも参照されるように記されていることもときどきある。
】</p>

		</section>
		<section id="algorithm-control-flow">
<h3 title="Control flow">3.2. 制御~flow</h3>

<p>
~algoの制御~flowにて
“~RET” ／ “~THROW （例外の投出）”
【原文では “`return^en” ／ “`throw^en”】
として記される要件は、それが記されている~algoを終了させる。
“~RET” に値が与えられている場合、その値が~call元に渡される。
“~THROW” は，~call元でも自動的に所与の値を再投出させ，~call元の~algoも終了させる。
~call元においては、注釈文により，例外を “~catchして” 別の動作を遂行することもある。
◎
The control flow of algorithms is such that a requirement to "return" or "throw" terminates the algorithm the statement was in. "Return" will hand the given value, if any, to its caller. "Throw" will make the caller automatically rethrow the given value, if any, and thereby terminate the caller’s algorithm. Using prose the caller has the ability to "catch" the exception and perform another action.
</p>

<p class="trans-note">【
和訳においては、
“下位手続き” と記された~algo
— ある~algoの中に入子にされた手続き —
の中の ~RET は，その下位手続きのみを終了させる。
他が指定されない限り、入子にしている~algoは終了されない。
<small>
（原文では “`abort these steps^en” と記されることが多いが、表記を一貫させるため，和訳では ~RET に統一している。）</small>
】</p>

		</section>
		<section id="algorithm-iteration">
<h3 title="Iteration">3.3. 反復</h3>
<p>
一連の段を，ある条件に達するまで繰返す種々の仕方がある。
◎
There’s a variety of ways to repeat a set of steps until a condition is reached.
</p>

<p class="note">注記：
この標準は，これについて（まだ）網羅的でない。
何か必要であれば，課題を~~提出されたし。
◎
The Infra Standard is not (yet) exhaustive on this; please file an issue if you need something.
</p>

<dl>
	<dt>~EACH ( … ) に対し… 【原文では “`For each …^en”】</dt>
	<dd>
［
~list（およびその派生型）の`反復する$ ／
~mapの`反復する$map
］に定義されるものと同様。
◎
For each
◎
As defined for lists (and derivatives) and maps.
</dd>
	<dd class="trans-note">【
和訳では、`~list$や`有順序~map$に限らず，順序が定義される何であれ ~EACH( … ) の表記を利用している（特に断らない限り，先頭から順に反復する）。
例えば：
“文字列 %S を成す ~EACH( %文字 ) に対し…”
】</dd>

	<dt>`~WHILE@ 【原文では “`While …^en”】</dt>
	<dd>
条件が満たされる限り，一連の段を繰返す~~指示。
◎
While
◎
An instruction to repeat a set of steps as long as a condition is met.
</dd>
	<dd class="example" id="example-while">
<p>
~WHILE %条件 ~EQ `満たされる^l ：
◎
While condition is "met":
</p>
		<ol>
			<li>
…
</li>
		</ol>
	</dd>
</dl>

<p>
反復の~flowは、
`~CONTINUE@
／
`~BREAK@
【原文では “`continue^en” ／ “`break^en”】
と記される要件を介して制御できる。
`~CONTINUE$は、反復における残りの手続きを飛ばして，次の~itemの~~処理に~~移行する
— 次の~itemがなければ，そこで反復は停止する。
`~BREAK$は、反復における残りの手続きを飛ばすことに加えて，反復も停止する。
◎
An iteration’s flow can be controlled via requirements to continue or break. Continue will skip over any remaining steps in an iteration, proceeding to the next item. If no further items remain, the iteration will stop. Break will skip over any remaining steps in an iteration, and skip over any remaining items as well, stopping the iteration.
</p>


<div class="example" id="example-break-continue">

<p>
`~list$ « 1, 2, 3, 4 » 
— 以下 %list  と記す —
が与えられた下では、次の注釈文は［
1, 2, 3, 4
］の順に %演算 を遂行することになる：
◎
Let example be the list « 1, 2, 3, 4 ». The following prose would perform operation upon 1, then 2, then 3, then 4:
</p>

<ol>
	<li>
<p>
%list 内の`~EACH$( %item ) に対し：
◎
For each item in example:
</p>
		<ol>
			<li>
%item 上で %演算 を遂行する
◎
Perform operation on item.
</li>
		</ol>
	</li>
</ol>

<p>
次の注釈文は、［
1, 2, 4
］の順に %演算 を遂行し， 3 は飛ばすことになる：
◎
The following prose would perform operation upon 1, then 2, then 4. 3 would be skipped.
</p>

<ol>
	<li>
<p>
%list 内の`~EACH$( %item ) に対し：
◎
For each item in example:
</p>
		<ol>
			<li>
~IF［
%item ~EQ 3
］
⇒
`~CONTINUE$
◎
If item is 3, then continue.
</li>
			<li>
%item 上で %演算 を遂行する
◎
Perform operation on item.
</li>
		</ol>
	</li>
</ol>

<p>
次の注釈文は、［
1, 2
］の順に %演算 を遂行し，［
3, 4
］は飛ばすことになる：
◎
The following prose would perform operation upon 1, then 2. 3 and 4 would be skipped.
</p>

<ol>
	<li>
<p>
%list 内の`~EACH$( %item ) に対し：
◎
For each item in example:
</p>
		<ol>
			<li>
~IF［
%item ~EQ 3
］
⇒
`~BREAK$
◎
If item is 3, then break.
</li>
			<li>
%item 上で %演算 を遂行する
◎
Perform operation on item.
</li>
		</ol>
	</li>
</ol>

</div>

		</section>
		<section id="assertions">
<h3 title="Assertions">3.4. 表明</h3>

<p>
~algoに不変則を言明している表明（ `assertion^en ）を追加すると、より読易くなることもある。
そのためには、
"`~Assert@："
【原文では “`Assert:^en”】
に続けて，真になる筈の言明（ `statement^en ）を記す。
言明が偽になる場合、この標準を利用している当の文書における課題であることを指示するので，報告され, 取組まれるべきである。
◎
To improve readability, it can sometimes help to add assertions to algorithms, stating invariants. To do this, write "Assert:", followed by a statement that must be true. If the statement ends up being false that indicates an issue with the document using the Infra Standard that should be reported and addressed.
</p>

<p class="note">注記：
言明は必ず真になるので、実装にとっての含意はない。
◎
Since the statement can only ever be true, it has no implications for implementations.
</p>

<div class="example" id="example-assert">

<ol>
	<li>
%x ~LET `Aperture Science^l
◎
Let x be "Aperture Science".
</li>
	<li>
`~Assert$：
%x ~EQ `Aperture Science^l
◎
Assert: x is "Aperture Science".
</li>
</ol>

</div>

		</section>
	</section>
	<section id="primitive-data-types">
<h2 title="Primitive data types">4. ~primitive~data型</h2>

		<section id="nulls">
<h3 title="Nulls">4.1. ~NULL</h3>

<p>
値 ~NULL は、値を欠いていることを指示するために利用される。
~NULL は、~JS `null^jv 値 `ECMA-262$r と交換可能に利用され得る。
◎
The value null is used to indicate the lack of a value. It can be used interchangeably with the JavaScript null value. [ECMA-262]
</p>

<p class="trans-note">【
したがって、表記上も区別されない。
和訳では、［
~JS `null^jv ／ ~IDL ~NULL
］値と区別する
— 仕様~levelの値であることを明確化する —
ため，
~NULL に代えて特殊~値 ε を用いることもある。
】</p>


<div class="example">
<ol>
	<li>
%要素 ~LET ~NULL
◎
Let element be null.
</li>
</ol>
</div>

<div class="example">
<ol>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
If input is the empty string, then return null.
</li>
</ol>
</div>

		</section>
		<section id="booleans">
<h3 title="Booleans">4.2. 真偽値</h3>


<p>
`真偽値@
（ `boolean^en ）は、［
~T または ~F
］をとるとする。
◎
A boolean is either true or false.
</p>

<div class="example">
<ol>
	<li>
%要素は見つかった ~LET ~F
◎
Let elementSeen be false.
</li>
</ol>
</div>
		</section>
		<section id="bytes">
<h3 title="Bytes">4.3. ~byte</h3>

<p>
`~byte@
（ `byte^en ）は、範囲 { `00^X 〜 `FF^X } に入る数を表す 8 個の~bitの並びであり、
2 桁の~hex-numで表現される，
◎
A byte is a sequence of eight bits, represented as a double-digit hexadecimal number in the range 0x00 to 0xFF, inclusive.
</p>

<p>
`~ASCII~byte@
は、範囲 { `00^X (NUL) 〜 `7F^X (DEL) } に入る`~byte$である。
ここに記したように、`~ASCII~byte$には，［
<cite>ASCII format for Network Interchange</cite>
`RFC20$r の
<a href="~IETF/rfc20#section-2">Standard Code</a>
節に挙げられている表現
］が丸括弧で括られて後続してもよい
— ただし， `28^X, `29^X は除く。
それらに対しては、順に，
"`(left parenthesis)^en",
"`(right parenthesis)^en"
が後続してもよい†。
◎
An ASCII byte is a byte in the range 0x00 (NUL) to 0x7F (DEL), inclusive. As illustrated, an ASCII byte, excluding 0x28 and 0x29, may be followed by the representation outlined in the Standard Code section of ASCII format for Network Interchange, between parentheses. [RFC20]
◎
0x28 may be followed by "(left parenthesis)" and 0x29 by "(right parenthesis)".
</p>

<p class="trans-note">【†
和訳では、例外なく `28^X `(^smb, 等々と記すことにする。
】</p>

<p class="example" id="example-byte-notation">
次の結果は、`符号位置$ `0049^U `I^smb になる
⇒
`~UTF-8復号する$( `49^X `I^smb )
◎
0x49 (I) when UTF-8 decoded becomes the code point U+0049 (I).
</p>

		</section>
		<section id="byte-sequences">
<h3 title="Byte sequences">4.4. ~byte列</h3>


<p>
`~byte列@
（ `byte sequence / bytes^en ）は、 0 個~以上の`~byte$からなる連列であり，一連の~byteを~spaceで区切って表現される。
どの~byteも範囲 { `20^X (SP) 〜 `7E^X `~^smb } 内に入る~byte列は，文字列としても記され得るが、実際の`文字列$と混同されないよう，引用符に代えて ~backtick（ backtick, "`" ）で括られる。
◎
A byte sequence is a sequence of bytes, represented as a space-separated sequence of bytes. Byte sequences with bytes in the range 0x20 (SP) to 0x7E (~), inclusive, can alternately be written as a string, but using backticks instead of quotation marks, to avoid confusion with an actual string.
</p>

<p class="trans-note">【
（参考） ~byte列による値は、~IDLにおいては `ByteString^c 型で表現される。
】</p>

<div class="example" id="example-byte-sequence-notation">

<p>
~byte列［
`48^X `49^X
］は、 `HI^bl とも表現される。
◎
0x48 0x49 can also be represented as `HI`.
</p>

<p>
`Content-Type^bl などの~HTTP~headerは、`~byte列$である。
◎
Headers, such as `Content-Type`, are byte sequences.
</p>

<p class="trans-note">【
和訳では，~HTTP~header名のような~keywordに対しては、`文字列$との区別が~~不要な所では，~backtickは省略することもある。
】</p>

</div>


<p class="note">注記：
`文字列$から`~byte列$を取得するときは、`~UTF-8符号化する$ `ENCODING$r の利用が奨励される。
稀な状況下では、`同型に符号化する$必要があるかもしれない。
◎
To get a byte sequence out of a string, using UTF-8 encode from the Encoding Standard is encouraged. In rare circumstances isomorphic encode might be needed. [ENCODING] 
</p>

<p>
`~byte列$の
`長さ@byte
（ `length^en ）は、それが包含する`~byte$の個数である。
◎
A byte sequence’s length is the number of bytes it contains.
</p>

<p class="algo-head">
`~byte小文字~化する@
ときは、所与の
( `~byte列$ %入力 )
に対し，次を返す
⇒
%入力 内の各［
%~byte ~IN { `41^X `A^smb 〜 `5A^X `Z^smb }
］を［
%~byte ~PLUS `20^X
］に置換して得られる`~byte列$
◎
To byte-lowercase a byte sequence, increase each byte it contains, in the range 0x41 (A) to 0x5A (Z), inclusive, by 0x20.
</p>

<p class="trans-note">【
他に解釈しようがない場合を除き， %入力 を改変することはない
— 単に
“%何か を~byte小文字~化する”
と記された場合に限り、
“%何か ~SET `~byte小文字~化する$( %何か )”
の略記を表す。
（次の “~byte大文字~化する” も同様。）
】</p>

<p class="algo-head">
`~byte大文字~化する@
ときは、所与の
( `~byte列$ %入力 )
に対し，次を返す
⇒
%入力 内の各［
%~byte ~IN { `61^X `a^smb 〜 `7A^X `z^smb }
］を［
%~byte ~MINUS `20^X
］に置換して得られる`~byte列$
◎
To byte-uppercase a byte sequence, subtract each byte it contains, in the range 0x61 (a) to 0x7A (z), inclusive, by 0x20.
</p>

<p class="algo-head">
2 つの`~byte列$ %A, %B が
`~byte大小無視@
で合致するとは、次が満たされることを意味する
⇒
`~byte小文字~化する$( %A ) ~EQ `~byte小文字~化する$( %B )
◎
A byte sequence A is a byte-case-insensitive match for a byte sequence B, if the byte-lowercase of A is the byte-lowercase of B.
</p>

<div class="p">
<p class="algo-head">
`同型に復号する@
ときは、所与の
( `~byte列$ %入力 )
に対し，次をすべて満たす`文字列$ %出力 を返す：
</p>

<ul>
	<li>
%出力 の`長さ$str ~EQ %入力 の`長さ$byte
</li>
	<li>
任意の %N `~IN$ { 1 〜 %入力 の`長さ$byte } に対し
⇒
%出力 の %N 個目の`符号単位$の値 ~EQ %入力 の %N 個目の`~byte$の値
</li>
</ul>

◎
To isomorphic decode a byte sequence input, return a string whose length is equal to input’s length and whose code points have the same values as input’s bytes, in the same order.
</div>

		</section>
		<section id="code-points">
<h3 title="Code points">4.5. 符号位置</h3>

<p>
`符号位置@
（ `code point^en ）†は，~Unicode符号位置であり、概して， "U+" が接頭された 4 〜 6 桁の~hex-numで表現される††。
◎
A code point is a Unicode code point and is represented as a four-to-six digit hexadecimal number, typically prefixed with "U+".
</p>

<p class="trans-note">【†
訳語の “~~符号位置” は~Unicode特有であり，他の符号化方式の “符号点” に相当する。
】【††
範囲は `0000^U 〜 `10FFFF^U
】</p>

<p>
`符号位置$には，［
その名前,
丸括弧で括られたその具現化形,
この両者
］が後続してもよい。
読み易さのため，この標準を利用している文書には、［［
具現化できない`符号位置$, および
`0028^U, `0029^U†
］には その名前 ／
他の場合は丸括弧で括られた具現化形
］を後続させることが奨励される。
◎
A code point may be followed by its name, by its rendered form between parentheses when it is not U+0028 or U+0029, or by both. Documents using the Infra Standard are encouraged to follow code points by their name when they cannot be rendered or are U+0028 or U+0029, and their rendered form between parentheses otherwise, for legibility.
</p>

<p class="trans-note">【†
和訳では、 `0028^U, `0029^U に対しても，
`0028^U `(^smb, 
`0029^U `)^smb
と記すことにする。
】</p>


<p>
`符号位置$の名前は、~Unicode標準にて定義され，`~ASCII大文字~化$されて表現される。
`UNICODE$r
◎
A code point’s name is defined in the Unicode Standard and represented in ASCII uppercase. [UNICODE]
</p>


<div class="example" id="example-code-point-notation">
<p>
🤔 と具現化される`符号位置$は、 `1F914^U として表現される。
◎
The code point rendered as 🤔 is represented as U+1F914.
</p>

<p>
この`符号位置$を指すときは、
"`1F914^U `🤔^smb"
と表記して，余分の内容を供することもある。
文書は、いくぶん冗長に
"`1F914^U THINKING FACE `🤔^smb"
と表記することも許容される。
◎
When referring to that code point, we might say "U+1F914 (🤔)", to provide extra context. Documents are allowed to use "U+1F914 THINKING FACE (🤔)" as well, though this is somewhat verbose.
</p>
</div>

<p class="example" id="example-code-point-notation-hard-to-render">
`000A^U などの一義的に具現化し難い`符号位置$は、
“`000A^U LF”
のように表記できる。
`0029^U は，具現化できるが丸括弧の括りが揃わなくなるので
“`0029^U RIGHT PARENTHESIS”
のように表記できる。
【が，和訳では、上述したように，他と同様に記すことにする。】
◎
Code points that are difficult to render unambigiously, such as U+000A, can be referred to as "U+000A LF". U+0029 can be referred to as "U+0029 RIGHT PARENTHESIS", because even though it renders, this avoids unmatched parentheses.
</p>

<p>
`符号位置$は、`文字$（ `character^en ）と称されることもあり，ある種の文脈では "U+" に代えて "0x" が接頭される。
【 "0x" は、主に，数値としての値が念頭に置かれている場合に用いられる。】
◎
Code points are sometimes referred to as characters and in certain contexts are prefixed with "0x" rather than "U+".
</p>

<p>
次の各種 `符号位置$の集合が定義される：
◎
↓</p>

<dl class="def-list">
	<dt>
`~surrogate@
◎
A surrogate＼
</dt>
	<dd>
{ `D800^U 〜 `DFFF^U }
◎
is a code point that is in the range U+D800 to U+DFFF, inclusive.
</dd>
	<dd class="trans-note">【
すなわち，代用対（ surrogate pair ）を成し得る`符号位置$
】</dd>

	<dt>
`~scalar値@
◎
A scalar value＼
</dt>
	<dd>
`~surrogate$でない`符号位置$
◎
is a code point that is not a surrogate. 
</dd>

	<dt>
`非文字@
◎
A noncharacter＼
</dt>
	<dd>
{
`FDD0^U 〜 `FDEF^U,
`FFFE^U, `FFFF^U,
`1FFFE^U, `1FFFF^U,
`2FFFE^U, `2FFFF^U,
`3FFFE^U, `3FFFF^U,
`4FFFE^U, `4FFFF^U,
`5FFFE^U, `5FFFF^U,
`6FFFE^U, `6FFFF^U,
`7FFFE^U, `7FFFF^U,
`8FFFE^U, `8FFFF^U,
`9FFFE^U, `9FFFF^U,
`AFFFE^U, `AFFFF^U,
`BFFFE^U, `BFFFF^U,
`CFFFE^U, `CFFFF^U,
`DFFFE^U, `DFFFF^U,
`EFFFE^U, `EFFFF^U,
`FFFFE^U, `FFFFF^U,
`10FFFE^U, `10FFFF^U
}
◎
is a code point that is in the range U+FDD0 to U+FDEF, inclusive, or U+FFFE, U+FFFF, U+1FFFE, U+1FFFF, U+2FFFE, U+2FFFF, U+3FFFE, U+3FFFF, U+4FFFE, U+4FFFF, U+5FFFE, U+5FFFF, U+6FFFE, U+6FFFF, U+7FFFE, U+7FFFF, U+8FFFE, U+8FFFF, U+9FFFE, U+9FFFF, U+AFFFE, U+AFFFF, U+BFFFE, U+BFFFF, U+CFFFE, U+CFFFF, U+DFFFE, U+DFFFF, U+EFFFE, U+EFFFF, U+FFFFE, U+FFFFF, U+10FFFE, or U+10FFFF. 
</dd>
	<dd class="trans-note">【
~Unicodeにて
<a href="https://www.unicode.org/faq/private_use.html#noncharacters">恒久的に予約済み</a>
（未定義）とされている符号位置。
ここに挙げられたものは、
<a href="https://www.unicode.org/faq/private_use.html#nonchar4">そこに挙げられているもの</a>
と一致する。
】【
その名に反して，これらも`文字$である。
】</dd>

	<dt>
`~ASCII符号位置@
◎
An ASCII code point＼
</dt>
	<dd>
{ `0000^U NULL 〜 `007F^U DELETE }
◎
is a code point in the range U+0000 NULL to U+007F DELETE, inclusive.
</dd>

	<dt>
`~ASCII~tabや~ASCII改行文字@
◎
An ASCII tab or newline＼
</dt>
	<dd>
{ `0009^U TAB, `000A^U LF, `000D^U CR }
◎
is U+0009 TAB, U+000A LF, or U+000D CR.
</dd>

	<dt>
`~ASCII空白@
◎
ASCII whitespace＼
</dt>
	<dd>
{ `0009^U TAB, `000A^U LF, `000C^U FF, `000D^U CR, `0020^U SPACE }
◎
is U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, or U+0020 SPACE. 
</dd>
	<dd class="note">注記：
空白（ `whitespace^en ）は数えられない名詞（ mass noun ）である。
【したがって、複数個あり得る場合でも原文では単数形で記される。】
◎
"Whitespace" is a mass noun. 
</dd>

	<dt>
`~C0制御文字@
◎
A C0 control＼
</dt>
	<dd>
{ `0000^U NULL 〜 `001F^U INFORMATION SEPARATOR ONE }
◎
is a code point in the range U+0000 NULL to U+001F INFORMATION SEPARATOR ONE, inclusive.
</dd>

	<dt>
`~C0制御文字や~space@
◎
A C0 control or space＼
</dt>
	<dd>
{ `~C0制御文字$, `0020^U SPACE }
◎
is a C0 control or U+0020 SPACE.
</dd>

	<dt>
`制御文字@
◎
A control＼
</dt>
	<dd>
{
`~C0制御文字$,
`007F^U DELETE 〜 `009F^U APPLICATION PROGRAM COMMAND
}
◎
is a C0 control or a code point in the range U+007F DELETE to U+009F APPLICATION PROGRAM COMMAND, inclusive.
</dd>

	<dt>
`~ASCII数字@
◎
An ASCII digit＼
</dt>
	<dd>
{ `0030^U `0^smb 〜 `0039^U `9^smb }
◎
is a code point in the range U+0030 (0) to U+0039 (9), inclusive.
</dd>

	<dt>
`~ASCII~hex数字（大文字）@
◎
An ASCII upper hex digit＼
</dt>
	<dd>
{ `~ASCII数字$, `0061^U `A^smb 〜 `0066^U `F^smb }
◎
is an ASCII digit or a code point in the range U+0041 (A) to U+0046 (F), inclusive.
</dd>

	<dt>
`~ASCII~hex数字（小文字）@
◎
An ASCII lower hex digit＼
</dt>
	<dd>
{ `~ASCII数字$, `0061^U `a^smb 〜 `0066^U `f^smb }
◎
is an ASCII digit or a code point in the range U+0061 (a) to U+0066 (f), inclusive.
</dd>

	<dt>
`~ASCII~hex数字@
◎
An ASCII hex digit＼
</dt>
	<dd>
{ `~ASCII数字$, `0041^U 〜 `0046^U , `0061^U 〜 `0066^U }
◎
is an ASCII upper hex digit or ASCII lower hex digit.
</dd>

	<dt>
`~ASCII英大文字@
◎
An ASCII upper alpha＼
</dt>
	<dd>
{ `0041^U `A^smb 〜 `0046^U `Z^smb }
◎
is a code point in the range U+0041 (A) to U+005A (Z), inclusive. 
</dd>

	<dt>
`~ASCII英小文字@
◎
An ASCII lower alpha＼
</dt>
	<dd>
{ `0061^U `a^smb 〜 `0066^U `Z^smb }
◎
is a code point in the range U+0061 (a) to U+007A (z), inclusive. 
</dd>

	<dt>
`~ASCII英字@
◎
An ASCII alpha＼
</dt>
	<dd>
{ `~ASCII英小文字$, `~ASCII英大文字$ }
◎
is an ASCII upper alpha or ASCII lower alpha.
</dd>

	<dt>
`~ASCII英数字@
◎
An ASCII alphanumeric＼
</dt>
	<dd>
{ `~ASCII数字$, `~ASCII英字$ }
◎
is an ASCII digit or ASCII alpha.
</dd>
</dl>

		</section>
		<section id="strings">
<h3 title="Strings">4.6. 文字列</h3>

<p>
`~JS文字列@
は、
0 個以上の［
`符号単位@
（ `code unit^en ）とも称される，無符号~16-bit整数
］からなる連列である。
◎
A JavaScript string is a sequence of unsigned 16-bit integers, also known as code units.
</p>

<div class="note">
<p>注記：
これは、~Unicode標準による “符号単位” の定義-法†と異なる。
特に，~Unicode標準が定義するそれを排他的に指すときは、
“~Unicode~16-bit文字列”
と称される。
`UNICODE$r
◎
This is different from how the Unicode Standard defines "code unit". In particular it refers exclusively to how the Unicode Standard defines it for Unicode 16-bit strings. [UNICODE]
</p>

<p class="trans-note">【†
<a href="https://www.unicode.org/versions/Unicode9.0.0/ch03.pdf#G7404">参照先</a>
— 具体的には、孤立した~surrogateが現れてはならない，などの制約がある。
】</p>

</div>

<p>
`~JS文字列$の
`長さ@jStr
（ `length^en ）は、それが包含する`符号単位$の個数とする。
◎
A JavaScript string’s length is the number of code units it contains.
</p>

<p>
`~JS文字列$は、~JS仕様の
<a href="~TC39#sec-ecmascript-language-types-string-type">String 型</a>
節に定義される変換を施すことにより，`符号位置$を包含しているものとも解釈できる。
`ECMA-262$r
◎
A JavaScript string can also be interpreted as containing code points, per the conversion defined in The String Type section of the JavaScript specification. [ECMA-262]
</p>

<p class="note">注記：
この変換~処理-は、各~surrogate~pairは 対応する`~scalar値$に変換し，各 孤立した~surrogateは 対応する`符号位置$
— 実質的にはそのまま —
に対応付ける。
◎
This conversion process converts surrogate pairs into their corresponding scalar value and maps isolated surrogates to their corresponding code point, leaving them effectively as-is.
</p>

<p class="example" id="example-javascript-string-in-code-points">
`符号単位$列［
`D83D^X, `DCA9^X, `D800^X,
］が成す`~JS文字列$は、`符号位置$を包含するものと解釈されるときは，`符号位置$列［
`1F4A9^U, `D800^U
］になる。
◎
A JavaScript string consisting of the code units 0xD83D, 0xDCA9, and 0xD800, when interpreted as containing code points, would consist of the code points U+1F4A9 and U+D800.
</p>

<p>
`~scalar値~文字列@
は、
0 個以上の`~scalar値$からなる連列である。
◎
A scalar value string is a sequence of scalar values.
</p>

<p class="note">注記：
`~scalar値~文字列$は、後で`~UTF-8符号化する$ことになるような，入出力その他の演算に有用になる。
◎
A scalar value string is useful for any kind of I/O or other kind of operation where UTF-8 encode comes into play.
</p>

<p class="trans-note">【（参考）
~IDLにおいては、~JS文字列による値は `DOMString^c 型,
~scalar値~文字列による値は `USVString^c 型
で表現される。
】</p>


<p>
`文字列@
（ `string^en ）は、［
`~JS文字列$, `~scalar値~文字列$
］のいずれかを指すときに利用できる
— 文脈から どちらを意味するか明瞭であるか，その~~区別が~~重要でない所であれば。
`文字列$は、二重引用符で括られ，等幅~fontで表記される。
◎
String can be used to refer to either a JavaScript string or scalar value string, when it is clear from the context which is meant or when the distinction is immaterial. Strings are denoted by double quotes and monospace font.
</p>

<p class="example" id="example-string-notation">
`Hello, world!^l は文字列を表す。
◎
"Hello, world!" is a string.
</p>

<p>
`文字列$の
`長さ@str
（ `length^en ）は、それが包含する`符号位置$の個数とする。
◎
A string’s length is the number of code points it contains.
</p>

<p>
所与の`~JS文字列$ %S を
`~scalar値~文字列に変換する@
ときは、次を返す
⇒
%S の中の各`~surrogate$を `FFFD^U に置換して得られる`~scalar値~文字列$
◎
To convert a JavaScript string into a scalar value string, replace any surrogates with U+FFFD.
</p>

<p class="note">注記：
ここで置換されるのは、常に，孤立した~surrogateになる
— ~JS文字列は，変換するに先立って`符号位置$を包含しているものと解釈され、~surrogate~pairは，その時点ですでに`~scalar値$に変換されているので。
◎
The replaced surrogates are always isolated surrogates, since the process of interpreting the JavaScript string as containing code points will have converted surrogate pairs into scalar values.
</p>

<p>
`~scalar値~文字列$は、常に，暗黙的に`~JS文字列$としても利用できる／され得る
— 前者は【変換を介して】後者の部分集合と~~見なせるので。
その逆は、［
当の`~JS文字列$が`~surrogate$を包含しないことが既知である
］場合に限り，可能になる。
他の場合、`~scalar値~文字列に変換する$が遂行され~MUST。
◎
A scalar value string can always be used as JavaScript string implicitly since it is a subset. The reverse is only possible if the JavaScript string is known to not contain surrogates; otherwise a conversion must be performed.
</p>

<p class="note">注記：
実装は、実際に表現している結果が［
`~JS文字列$, `~scalar値~文字列$
］どちらになるかに依存して，明示的な変換を要する見込みが高い。
処理能と~memoryの理由から、`~JS文字列$のみに複数の実装を備わせる実装もよくある。
◎
An implementation likely has to perform explicit conversion, depending on how it actually ends up representing JavaScript and scalar value strings. It is even fairly typical for implementations to have multiple implementations of just JavaScript strings for performance and memory reasons.
</p>

<p class="algo-head">
`同型に符号化する@
ときは、所与の
( `文字列$ %入力 )
に対し，次を走らす：
◎
To isomorphic encode a string input, run these steps:
</p>

<ol>
	<li>
`~Assert$：
%入力 内に `00FF^U より大きい`符号位置$はない。
◎
Assert: input contains no code points greater than U+00FF.
</li>
	<li>
<p>
~RET 次をいずれも満たすような`~byte列$ %出力：
</p>
		<ul>
			<li>
%出力 の`長さ$byte ~EQ %入力 の`長さ$str
</li>
			<li>
任意の %N `~IN$ { 1 〜 %入力 の`長さ$str } に対し
⇒
%出力 の %N 個目の`~byte$の値 ~EQ %入力 の %N 個目の`符号単位$の値
</li>
		</ul>
◎
Return a byte sequence whose length is equal to input’s length and whose bytes have the same values as input’s code points, in the same order.
</li>
</ol>


<hr>

<p>
`~ASCII文字列@
は、`~ASCII符号位置$のみからなる`文字列$である。
◎
An ASCII string is a string whose code points are all ASCII code points.
</p>


<p class="algo-head">
`~ASCII小文字~化する@
ときは、所与の
( `文字列$ %入力 )
に対し，次を返す
⇒
%入力 内の各`~ASCII英大文字$を，それぞれに対応する`~ASCII英小文字$に置換して得られる`文字列$
◎
To ASCII lowercase a string, replace all ASCII upper alphas in the string with their corresponding code point in ASCII lower alpha.
</p>

<p class="trans-note">【
他に解釈しようがない場合を除き， %入力 を改変することはない
— 単に
“%何か を~ASCII小文字~化する”
と記された場合に限り、
“%何か ~SET `~ASCII小文字~化する$( %何か )”
の略記を表す（が、特に~algoの中では，この種の略記は可能な限り避けている）。
この節に現れる，文字列を返す他の~algoも同様。
】</p>


<p class="algo-head">
`~ASCII大文字~化する@
ときは、所与の
( `文字列$ %入力 )
に対し，次を返す
⇒
%入力 内の各`~ASCII英小文字$を，それぞれに対応する`~ASCII英大文字$に置換して得られる`文字列$
◎
To ASCII uppercase a string, replace all ASCII lower alphas in the string with their corresponding code point in ASCII upper alpha.
</p>

<p class="algo-head">
2 つの`文字列$ %A, %B が
`~ASCII大小無視@
で合致するとは、次が満たされることを意味する
⇒
`~ASCII小文字~化する$( %A ) ~EQ `~ASCII小文字~化する$( %B )
◎
A string A is an ASCII case-insensitive match for a string B, if the ASCII lowercase of A is the ASCII lowercase of B.
</p>

<p class="trans-note">【
和訳では、`文字列$ %A, %B が`~ASCII大小無視$で合致することを，
“ %A ~EQ<sub>大小無視</sub> %B ”
とも表記する。
】【
和訳では、`~ASCII大小無視$の代わりに`~ASCII小文字~化する$（または大文字~化する）を利用して，等価な記述に変形することもある（そうした方が簡潔になる所など）。
】</p>

<hr>

<p class="algo-head">
`改行文字を剥ぐ@
ときは、所与の
( `文字列$ %S )
に対し
⇒
%S から［
{ `000A^U LF, `000D^U CR }
に入る`符号位置$
］すべてを除去した結果を返す
◎
To strip newlines from a string, remove any U+000A LF and U+000D CR code points from the string. 
</p>

<p class="algo-head">
`前後の~ASCII空白~列を剥ぐ@
ときは、所与の
( `文字列$ %S )
に対し
⇒
%S の［
先頭, 末尾
］から連続するすべての`~ASCII空白$を除去した結果を返す
◎
To strip leading and trailing ASCII whitespace from a string, remove all ASCII whitespace that are at the start or the end of the string.
</p>

<div class="p">
<p class="algo-head">
`~ASCII空白を剥いで縮約する@
ときは、所与の
( `文字列$ %S )
に対し，次を走らす：
</p>

<ol>
	<li>
%S ~SET `前後の~ASCII空白~列を剥ぐ$( %S )
</li>
	<li>
~RET %S 内の［
1 個~以上~連続する［
`~ASCII空白$である`符号位置$
］並び
］すべてを，それぞれ［
1 個の`符号位置$ `0020^U SPACE
］に置換した結果
</li>
</ol>

◎
To strip and collapse ASCII whitespace in a string, replace any sequence of one or more consecutive code points that are ASCII whitespace in the string with a single U+0020 SPACE code point, and then remove any leading and trailing ASCII whitespace from that string.
</div>

<hr>

<div >
<p>
この仕様, および
この仕様を参照する仕様が定義する，文字列を構文解析する いくつかの~algoは、次の変数を利用する：
</p>

<ul>
	<li>
通例的に %入力 と命名される，構文解析される文字列を保持する変数。
</li>
	<li>
<p>
通例的に %位置 と命名される
`位置~変数@
（ `position variable^en ）は、 %入力 の中の位置を追跡し，次に構文解析する文字†を指す。
</p>

<p class="trans-note">【†
“次”, “文字” の意味は、通例
— %入力 が`~JS文字列$であっても —
`符号単位$ではなく`符号位置$に基づく
— この節の冒頭に述べたように解釈する下で。
`符号単位$に基づく必要がある場合、その旨が付記されることになる。
<small>（
他の仕様も含め、`位置~変数$を利用している どの構文解析も，（特に指定されない限り）`符号位置$に基づいて比較を行なっている。
たいていの構文解析~algoは，~ASCII範囲の文字に基づいて分岐している
— したがって，`~surrogate$は関わらない —
ので、この違いが有意になるのは，およそ`長さ$jStrが関わる場合に限られるであろう。
）</small>
】</p>
	</li>
</ul>



<p>
【加えて、和訳では次の規約／表記も用いる：】
</p>

<ul>
	<li>
`位置~変数$は，内部的には整数であり、増減操作を通して，構文解析する文字を追跡するとする
— 正~整数 %N を加算すれば、現在の文字から %N 個先の文字を指すように移動することになる。
（通例，初期~時には %入力 内のある文字に相対的に与えられるので（例： “最初の符号位置を指す位置~変数”, 等々）、どの数から数えるかが有意になることは，ほとんどない。
また、減算されることもほとんどない。）
</li>
	<li>
`位置~変数$ %位置 に対する %位置↗ という表記は、 %位置 が指している文字を表すとする。
( %位置 ~PLUS %N )↗ という表記は、 %位置 から %N 個先の文字を表すことになる（
( %位置 ~PLUS 0 )↗ ~EQ %位置 ↗ 。
まず現れないが、 %N が負ならば %位置 より前になる）。
</li>
	<li>
%位置 が %入力 の外を指している場合の %位置↗ は、特殊~値 ε をとるものとする（特に， %入力 が空~文字列の場合、常に ε になる）。
</li>
</ul>

◎
↓</div>

<p class="algo-head">
`文字列$ %入力 内の［
~call元~algoの`位置~変数$ %位置
］から条件 %条件 を満たす
`符号位置~並びを収集する@
ときは：
◎
To collect a sequence of code points meeting a condition condition from a string input, given a position variable position tracking the position of the calling algorithm within input:
</p>

<ol>
	<li>
%結果 ~LET 空`文字列$
◎
Let result be the empty string.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］~AND［
%位置↗ は %条件 を満たす
］：
◎
While position doesn’t point past the end of input and the code point at position within input meets the condition condition:
</p>
		<ol>
			<li>
%結果 の末尾に %位置↗ を付加する
◎
Append that code point to the end of result.
</li>
			<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

<p class="note">注記：
収集された`符号位置$を返すことに加え、この~algoは，~call元~algoの`位置~変数$を更新する。
◎
In addition to returning the collected code points, this algorithm updates the position variable in the calling algorithm.
</p>

<p class="trans-note">【
この~algoは、 %入力, %位置 を省略して~callされることもある。
その場合、~call元の同じ名前の変数を暗黙的に指すことになる。
次の`~ASCII空白を読飛ばす$についても同様。
】</p>

<p class="algo-head">
`文字列$ %入力 内の［
~call元~algoの`位置~変数$ %位置
］から
`~ASCII空白を読飛ばす@
ときは
⇒
%入力 内の %位置 から
`~ASCII空白$からなる`符号位置~並びを収集する$
— 収集された結果は利用されないが、 %位置 は更新される。
◎
To skip ASCII whitespace within a string input given a position variable position, collect a sequence of code points that are ASCII whitespace from input given position. The collected code points are not used, but position is still updated.
</p>

<hr>

<p class="algo-head">
`区切子で厳密に分割する@
ときは、所与の
( `文字列$ %入力, `符号位置$ %区切子 )
に対し，次を走らす：
◎
To strictly split a string input on a particular delimiter code point delimiter:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%~token~list ~LET 新たな空`~list$（`文字列$からなる）
◎
Let tokens be a list of strings, initially empty.
</li>
	<li>
%~token ~LET 
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集する$
◎
Let token be the result of collecting a sequence of code points that are not equal to delimiter from input, given position.
</li>
	<li>
%~token~list に %~token を`付加する$
◎
Append token to tokens.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%位置 ~INCBY 1
— これは、 %区切子 を読飛ばす。
◎
Advance position to the next code point in input. (This skips past the delimiter.)
</li>
			<li>
%~token ~LET
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集する$
◎
Let token be the result of collecting a sequence of code points that are not equal to delimiter from input, given position.
</li>
			<li>
%~token~list に %~token を`付加する$
◎
Append token to tokens.
</li>
		</ol>
	</li>
	<li>
~RET %~token~list
◎
Return tokens.
</li>
</ol>

<p class="note">注記：
この~algoは、 “厳密に” 分割する
— 対して，後述の共通的に利用される変種［
`~ASCII空白で分割する$,
`~commaで分割する$
］は いずれも、散在する`~ASCII空白$を種々の仕方で孕むように，より “緩く” 分割する。
◎
This algorithm is a "strict" split, as opposed to the commonly-used variants for ASCII whitespace and for commas below, which are both more lenient in various ways involving interspersed ASCII whitespace.
</p>

<p class="trans-note">【
%入力 が空~文字列でも，空~文字列のみからなる~listを返すことになる（結果の~listの`~size$は常に， %入力 内の区切子の個数 ~PLUS 1 になる）。
】</p>

<p class="algo-head">
`~ASCII空白で分割する@
ときは、所与の
( `文字列$ %入力 )
に対し，次を走らす：
◎
To split a string input on ASCII whitespace:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%~token~list ~LET 新たな空`~list$（`文字列$からなる）
◎
Let tokens be a list of strings, initially empty.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%~token ~LET 
%入力 内の %位置 から
`~ASCII空白$以外の`符号位置~並びを収集する$
◎
Let token be the result of collecting a sequence of code points that are not ASCII whitespace from input, given position.
</li>
			<li>
%~token~list に %~token を`付加する$
◎
Append token to tokens.
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
		</ol>
	</li>
	<li>
~RET %~token~list
◎
Return tokens.
</li>
</ol>

<p class="trans-note">【
%入力 が`~ASCII空白$のみからなる場合に限り，結果は空~listになる。
】</p>


<p class="algo-head">
`~commaで分割する@
ときは、所与の
( `文字列$ %入力 )
に対し，次を走らす：
◎
To split a string input on commas:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%~token~list ~LET 新たな空`~list$（`文字列$からなる）
◎
Let tokens be a list of strings, initially empty.
</li>
	<li>

<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>

<p>
%~token ~LET 
%入力 内の %位置 から
`002C^U `,^smb でない
`符号位置~並びを収集する$
◎
Let token be the result of collecting a sequence of code points that are not U+002C (,) from input, given position.
</p>

<p class="note">注記：
%~token は、空~文字列にもなり得る。
◎
token might be the empty string.
</li>
			<li>
%~token から`前後の~ASCII空白~列を剥ぐ$
◎
Strip leading and trailing ASCII whitespace from token.
</li>
			<li>
%~token~list に %~token を`付加する$
◎
Append token to tokens.
</li>
			<li>
<p>
~IF［
%位置↗ ~NEQ ε
］：
◎
If position is not past the end of input, then:
</p>
				<ol>
					<li>
`~Assert$：
%位置↗ ~EQ `002C^U `,^smb
◎
Assert: the code point at position within input is U+002C (,).
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position by 1.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~token~list
◎
Return tokens.
</li>
</ol>

<p class="trans-note">【
%入力 が空~文字列の場合に限り，結果は空~listになる。
】</p>

<p class="algo-head">
`文字列$の`~list$ %~list を
文字列 %分離子 （省略時は空~文字列）で
`連結する@
ときは、次を走らす：
◎
To concatenate a list of strings list, using an optional separator string separator, run these steps:
</p>

<ol>
	<li>
~IF［
%~list は`空$である
］
⇒
~RET 空~文字列
◎
If list is empty, then return the empty string.
◎
If separator is not given, then set separator to the empty string.
</li>
	<li>
%結果 ~LET %~list[0]
◎
↓</li>
	<li>
~EACH( %index ~IN { 1 〜 ( %~list の`~size$ − 1 ) } ) に対し，昇順に
⇒
%結果 に次を順に付加する
⇒＃
%分離子,
%~list[ %index ]
◎
Return a string whose contents are list’s items, in order, separated from each other by separator.
</li>
	<li>
~RET %結果
◎
↑</li>
</ol>

<p class="example">
集合 %集合 を直列化するときは、次の結果を返す
⇒
%集合 を `0020^U SPACE で`連結する$
◎
To serialize a set set, return the concatenation of set using U+0020 SPACE.
</p>


		</section>
	</section>

	<section id="data-structures">
<h2 title="Data structures">5. ~data構造</h2>

<p class="trans-note">【
<a href="#algorithms">~algo</a>
節の冒頭に述べたのと同じ理由で、この節に現れる記号［
ε, 〜 , ~EACH( … ), ~IN, ~NIN, ~SET
］は，和訳に固有の表記である。
】</p>

<p>
仕様は、慣例的に，共有されている意味論の理解に基づいて
種々の曖昧な仕様~levelの~data構造に対し演算していた。
これは，一般に上手く働いているが、際どい事例では多義性をもたらし得る
— 反復の順序，あるいは
~itemを`有順序~集合$に`付加する$setとき，その集合が`~item$をすでに`包含して$いた場合に何が起こるかなど。
それはまた、表記法や言い回しを様々にしている
— とりわけ，`有順序~map$のような より複雑な~data構造の周りで。
◎
Conventionally, specifications have operated on a variety of vague specification-level data structures, based on shared understanding of their semantics. This generally works well, but can lead to ambiguities around edge cases, such as iteration order or what happens when you append an item to an ordered set that the set already contains. It has also led to a variety of divergent notation and phrasing, especially around more complex data structures such as maps.
</p>

<p>
この標準は、共通の地盤を作成するため，共通して用いられる 少数の~data構造，および それらに働きかけるための 表記法や言い回しを供する。
◎
This standard provides a small set of common data structures, along with notation and phrasing for working with them, in order to create common ground.
</p>

		<section id="lists">
<h3 title="Lists">5.1. ~list</h3>

<p>
`~list@
（ `list^en ）は、仕様~levelの型である。
その各~instanceは、有限個の
`~item@
（ `item^en ）からなる有順序~連列である。
◎
A list is a specification type consisting of a finite ordered sequence of items.
</p>

<p class="trans-note">【
単に，新たな`~list$を作成するときは、他が指定されない限り，`空$にされているとする（したがって、`~list$でもある他の仕様~levelの型（`有順序~集合$など）も同様になる）。
】</p>

<p>
表記を簡便にするため、`~list$を表す~literal構文も利用できる
— そのためには、~list内の各`~item$どうしを~commaで区切った上で, 全体を文字 «, » で括る。
~list用の~indexing構文も利用できる
— そのためには，角括弧（ [, ] ）の内側に 0 番から数える~indexを与える。
~indexは，`存在-$について~~述べる場合を除いて，~~範囲を超えられない。
◎
For notational convenience, a literal syntax can be used to express lists, by surrounding the list by « » characters and separating its items with a comma. An indexing syntax can be used by providing a zero-based index into a list inside square brackets. The index cannot be out-of-bounds, except when used with exists.
</p>

<p class="example" id="example-list-notation">
%example ~EQ
`~list$ « `a^l, `b^l, `c^l, `a^l »
が与えられた下では、
%example[1] は `文字列$ `b^l を表す。
◎
Let example be the list « "a", "b", "c", "a" ». Then example[1] is the string "b".
</p>

<hr>

<ul>
	<li>
`有順序~集合$でない`~list$ %L に所与の`~item$ %item を
`付加する@
ときは
⇒
%item を %L の末尾に追加する
◎
To append to a list that is not an ordered set is to add the given item to the end of the list.
</li>
	<li>
<p>
`有順序~集合$でない`~list$ %L に所与の`~item$ %item を
`前付加する@
ときは
⇒
%item を %L の先頭に追加する
◎
To prepend to a list that is not an ordered set is to add the given item to the beginning of the list.
</p>

</li>
	<li>
<p>
`有順序~集合$でない`~list$ %L の中で
`置換する@
ときは、
%L 内の［
所与の %条件 に合致する`~item$
］すべてを，所与の`~item$ %item に置換する（合致するものが無ければ何もしない）。
◎
To replace within a list that is not an ordered set is to replace all items from the list that match a given condition with the given item, or do nothing if none do. 
</p>

<p class="note">注記：
`~list$が`有順序~集合$でもあるときには、上の定義は改変される
— 下に与える［
`付加する$set ／ `前付加する$set ／ `置換する$set
］を見よ。
◎
The above definitions are modified when the list is an ordered set; see below for ordered set append, prepend, and replace.
</p>
	</li>
	<li>
<p>
`~list$ %L の中に所与の`~item$ %item を %index の前に
`挿入する@
ときは：
</p>
		<ol>
			<li>
`~Assert$：
0 ~LTE %index ~LT ( %L の`~size$ )
</li>
			<li>
~IF［
%index ~EQ 0
］
⇒
%L に %item を`前付加する$
</li>
			<li>
~ELSE
⇒
%L 内の %L[%index − 1] と %L[%index ] の合間に %item を追加する
</li>
		</ol>
◎
To insert an item into a list before an index is to add the given item to the list between the given index − 1 and the given index. If the given index is 0, then prepend the given item to the list.
</li>

	<li>
<p>
`~list$ %L から所与の %条件 に合致する`~item$を
`除去する@
ときは
⇒
［
%条件 に合致する %L 内の`~item$
］すべてを %L から除去する（合致するものが無ければ何もしない）
◎
To remove zero or more items from a list is to remove all items from the list that match a given condition, or do nothing if none do.
</p>

<div class="example" id="example-list-remove">
<p>
%L ~EQ `~list$ « %x, %y, %z, %x »
から %x を`除去する$ときは、
%L から %x に等しいすべての~itemを除去する。
結果の %L は、 « %y, %z » に等価になる。
◎
Removing x from the list « x, y, z, x » is to remove all items from the list that are equal to x. The list now is equivalent to « y, z ».
</p>

<p>
%L ~EQ `~list$ « `a^l, `b^l, `ab^l, `ba^l »
から［
`文字列$ `a^l で開始する~item
］すべてを`除去する$ときは、~item［
`a^l,  `ab^l
］を除去する。
結果の %L は、 « `b^l, `ba^l » に等価になる。
◎
Removing all items that start with the string "a" from the list « "a", "b", "ab", "ba" » is to remove the items "a" and "ab". The list is now equivalent to « "b", "ba" ».
</p>
</div>

	 </li>
	<li>
`~list$ %L を
`空にする@
ときは
⇒
%L 内のすべての`~item$
【すなわち，条件 “無条件” に合致する~item】
を`除去する$
◎
To empty a list is to remove all of its items.
</li>
	<li>
<p>
`~list$ %L が`~item$ %item を
`包含して@
いるとは、 %L 内に %item が現れることをいう。
（ “`包含して$いない” は、その否定を表す。）
</p>

<p>
“ %item ~IN %L ” とも表記される。
（ “ %item ~NIN %L ” は、その否定を表す。）
</p>

<p>
`~list$ %L が~index %index 番の`~item$を`包含して$いることを
“%L[ %index ] は`存在-$する”
ともいう。
（ “`存在-$しない” は、その否定を表す。）
</p>

<!-- 
“ %L[ %index ] ~NEQ ε” とも表記される。
（ “ %L[ %index ] ~EQ ε” は、その否定を表す。）
-->

◎
A list contains an item if it appears in the list. We can also denote this by saying that, for a list list and an index index, "list[index] exists".
</li>
	<li>
`~list$ %L の
`~size@
（ `size^en ）とは、 %L が`包含して$いる`~item$の個数をいう。
【重複する~instanceも別々に数える。】
◎
A list’s size is the number of items the list contains.
</li>
	<li>
`~list$ %L が
`空@
（ `empty^en ）であるとは、［
%L の`~size$ ~EQ 0
］であることをいう。
◎
A list is empty if its size is zero.
</li>
	<li>
<p>
`~list$ %L 内の各`~item$に対し~list順に，一連の段を遂行するように
`反復する@
（ `iterate over^en ）ときは、
“ %L 内の`~EACH$( %item ) に対し：”
という句の下で，後続の注釈文にて %item に対し演算する。
</p>

<p class="trans-note">【
和訳では、 “反復する” は利用せず，もっぱら “~EACH(…)” を表記に利用している。
】【
仕様には、逆順の~listに変換するなどにより，実質的に逆順に反復している箇所もたまにある。
そのような箇所は，和訳では、
“~EACH( %item ) に対し，<em>逆順に</em>”
のような句により，表記を簡約することもある。
】</p>

◎
To iterate over a list, performing a set of steps on each item in order, use phrasing of the form "For each item of list", and then operate on item in the subsequent prose.
</li>
	<li>
<div class="p">
<p>
`~list$ %L を
`~cloneする@
ときは：
</p>

		<ol>
			<li>
%~clone ~LET %L と同じ型の
<!-- of the same designation -->
新たな`~list$
【すなわち、 %L が`~stack$なら 新たな`~stack$，等々】
</li>
			<li>
%L 内の`~EACH$( %~item ) に対し
⇒
%~clone に %~item を`付加する$
</li>
			<li>
~RET %~clone
</li>
		</ol>

<p>
結果の %~clone は、 %L と同じ`~item$たちを同じ順序で`包含して$いることになる。
</p>
◎
To clone a list list is to create a new list clone, of the same designation, and, for each item of list, append item to clone, so that clone contains the same items, in the same order as list.
</div>

<p class="note">注記：
`~item$自身は~cloneされないので、これは “浅い~clone” である。
◎
Note: This is a "shallow clone", as the items themselves are not cloned in any way.
</p>

<p class="example">
%L が`有順序~集合$
« `a^l, `b^l, `c^l »
であったなら，
%L を`~clone$して作成される新たな`有順序~集合$ %~clone において、
%~clone 内の`文字列$ `a^l を `foo^l で`置換-$setした結果は
« `foo^l, `b^l, `c^l »
になるが，
%L[ 0 ] は `a^l のまま変わらない。
◎
Let original be the ordered set « "a", "b", "c" ». Cloning original creates a new ordered set clone, so that replacing "a" with "foo" in clone gives « "foo", "b", "c" », while original[0] is still the string "a".
</p>
	</li>
</ul>

<hr>

<p>
`~list$型は、~JS仕様に由来する（その仕様では、 "`List$" と~~大文字化されている）。
ここでは、参照し易くするため，その定義を再掲して、`~list$を操作するための語彙を~~拡張する。
~JSが`List$を期待する所では、ここに定義される`~list$を利用できる
— それらは同じ型である。
`ECMA-262$r
◎
The list type originates from the JavaScript specification (where it is capitalized, as List); we repeat some elements of its definition here for ease of reference, and provide an expanded vocabulary for manipulating lists. Whenever JavaScript expects a List, a list as defined here can be used; they are the same type. [ECMA-262]
</p>

			<section id="stacks">
<h4 title="Stacks">5.1.1. ~stack</h4>

<p>
`~list$は，
`~stack@
（ `stack^en ）であると指名されることもある。
~stackは`~list$であるが、［
`付加する$ ／ `前付加する$ ／ `除去する$
］を用いる代わりに，以下に定義する句を用いて演算するのが慣例である。
◎
Some lists are designated as stacks. A stack is a list, but conventionally, the following operations are used to operate on it, instead of using append, prepend, or remove.
</p>

<ul>
	<li>
`~stack$ %S に %item を
`~pushする@
ときは
⇒
%S に %item を`付加する$
◎
To push onto a stack is to append to it.
</li>
	<li>
<p>
`~stack$ %S から
`~popする@
ときは：
</p>
		<ol>
			<li>
<p>
~IF［
%S は`空$である
］
⇒
~RET ε
</p>

<p class="trans-note">【
原文では “`return nothing^en” 。
通例的には “何も返さない” と訳される所であるが、あたかも，  “ε（ `nothing^en ）”
という何もないことを表現する特別な定数があって，それを返すものと解釈しても矛盾することはなく、そうした方が表記するに都合が良いので，そのようにしている。
】</p>
			</li>
			<li>
%item ~LET %S の最後の`~item$
</li>
			<li>
%S から %item を`除去する$
</li>
			<li>
~RET %item
</li>
		</ol>

◎
To pop from a stack is to remove its last item and return it, if the stack is not empty, or to return nothing otherwise.
</li>
</ul>

<p>
`~stack$は`~list$であるが、
“`~EACH$(…) に対し…”
は利用されては~MUST_NOT
— 代わりに［
`~WHILE$, `~popする$
］の組合せの方が適切である。
◎
Although stacks are lists, for each must not be used with them; instead, a combination of while and pop is more appropriate.
</p>

<p class="trans-note">【
しかしながら、ときには，`~popする$ことなく反復することも必要になり得る
— その様な場合、和訳では “~EACH(…)” を利用することもある。
そこでは、（ “逆順に”, 等の句が付記されない限り，）`~list$と同じく先頭から順に`反復する$ことを意味する。
】</p>

			</section>
			<section id="queues">
<h4 title="Queues">5.1.2. ~queue</h4>

<p>
`~list$は
`~queue@
（ `queue^en, ~~待ち~~行列）であると指名されることもある。
~queueは`~list$であるが、［
`付加する$ ／ `前付加する$ ／ `除去する$
］を用いる代わりに，以下に定義する句を用いて演算するのが慣例である。
◎
Some lists are designated as queues. A queue is a list, but conventionally, the following operations are used to operate on it, instead of using append, prepend, or remove.
</p>

<ul>
	<li>
`~queue$ %Q に %item を
`~enqueueする@
ときは
⇒
%Q に %item を`付加する$
◎
To enqueue in a queue is to append to it.
</li>
	<li>

<p>
`~queue$ %Q から
`~dequeueする@
ときは：
</p>
		<ol>
			<li>
~IF［
%Q は`空$である
］
⇒
~RET ε
【`~popする$ときと同様に】
</li>
			<li>
%item ~LET %Q 内の最初の`~item$
</li>
			<li>
%Q から %item を`除去する$
</li>
			<li>
~RET %item
</li>
		</ol>
◎
To dequeue from a queue is to remove its first item and return it, if the queue is not empty, or to return nothing if it is.
</li>
</ul>

<p>
`~queue$は`~list$であるが、
“`~EACH$(…) に対し…”
は利用されては~MUST_NOT
— 代わりに［
`~WHILE$, `~dequeueする$
］の組合せの方が適切である。
◎
Although queues are lists, for each must not be used with them; instead, a combination of while and dequeue is more appropriate.
</p>

<p class="trans-note">【
しかしながら，`~stack$に対するときと同様に、和訳では，`~dequeueする$ことなく`反復する$必要がある場合には “~EACH(…)” を利用することもある。
】</p>


			</section>
			<section id="sets">
<h4 title="Sets">5.1.3. 集合</h4>

<p>
`~list$は
`有順序~集合@
（ `ordered set^en ）であると指名されることもある。
有順序~集合は、`~list$であって，かつ［
同じ`~item$が重ねて現れては~MUST_NOTとする，追加の意味論
］を伴う。
◎
Some lists are designated as ordered sets. An ordered set is a list with the additional semantic that it must not contain the same item twice.
</p>

<p class="note">注記：
~web~platformにおける ほとんどすべての事例では、無順序ではなく<em>有順序</em>集合が要求される
— 相互運用性のため、集合の内容が開発者に公開されるときの列挙~順序は，各~browser間で一貫することが要求されるので。
また，順序が重要でない事例でも、有順序~集合が利用される
— その場合、実装は，順序が観測され得ない事実に基づいて最適化できる。
◎
Almost all cases on the web platform require an ordered set, instead of an unordered one, since interoperability requires that any developer-exposed enumeration of the set’s contents be consistent between browsers. In those cases where order is not important, we still use ordered sets; implementations can optimize based on the fact that the order is not observable.
</p>

<ul>
	<li>
`有順序~集合$ %S に 所与の `~item$ %item を
`付加する@set
ときは
⇒
%S が %item を`包含して$いない場合に限り
⇒
`~list$用の通常の`付加する$演算を遂行する
◎
To append to an ordered set is to do nothing if the set already contains the given item, or to perform the normal list append operation otherwise.
</li>
	<li>
`有順序~集合$ %S に 所与の`~item$ %item を
`前付加する@set
ときは
⇒
%S が %item を`包含して$いない場合に限り
⇒
`~list$用の通常の`前付加する$演算を遂行する
◎
To prepend to an ordered set is to do nothing if the set already contains the given item, or to perform the normal list prepend operation otherwise.
</li>
	<li>
<p>
`有順序~集合$ %S の中で，所与の
%item を %replacement に
`置換する@set
ときは
⇒
%S が［
%item, %replacement
］のいずれかを`包含して$いる場合に限り
⇒
それらのうち最初のものは %replacement に置換した上で，他のものはすべて %S から除去する
◎
To replace within an ordered set set, given item and replacement: if set contains item or replacement, then replace the first instance of either with replacement and remove all other instances. 
</p>

<div class="example" id="example-set-replace">
<p>
`有順序~集合$ %S の中で、 `a^l を `c^l に`置換-$setした結果は：
</p>
<ul><li>%S ~EQ « `a^l, `b^l, `c^l » ならば， « `c^l, `b^l » になる。
</li><li>%S ~EQ « `c^l, `b^l, `a^l » ならば， « `c^l, `b^l » になる。
</li></ul>
◎
Replacing "a" with "c" within the ordered set « "a", "b", "c" » gives « "c", "b" ». Within « "c", "b", "a" » it gives « "c", "b" » as well.
</div>

	</li>
	<li>
<p>
( `有順序~集合$ %A, `有順序~集合$ %B )
は、次を満たすならば，［
%A は %B の
`下位集合@
（ `subset^en, “部分集合” ）である／
%B は %A の
`上位集合@
である
］とされる
⇒
%B は、 %A が`包含して$いるどの`~item$も `包含して$いる
◎
An ordered set set is a subset of another ordered set superset (and conversely, superset is a superset of set) if, for each item of set, superset contains item.
</p>

<p class="note">注記：
`有順序~集合$は、自身の`下位集合$であり, `上位集合$でもあることになる。
◎
This implies that an ordered set is both a subset and a superset of itself.
</p>

<p class="trans-note">【
［
%A ／ %B
］を成す~itemたちの順序は、織り込まれない。
】</p>

	</li>
	<li>
<p>
( `有順序~集合$ %A, `有順序~集合$ %B )
の
`交差集合@
（ `intersection^en ）は、次の結果で与えられる：
</p>
		<ol>
			<li>
%S ~LET 新たな`有順序~集合$
</li>
			<li>
`~EACH$( %~item `~IN$ %A ) に対し
⇒
~IF［
%~item `~IN$ %B
］
⇒
%S に %~item を`付加する$set
</li>
			<li>
~RET %S
</li>
		</ol>

<p class="trans-note">【
%A を成す~itemたちの順序に加えて、
%A, %B の順序も，結果の %S を成す~itemたちの順序に有意になる。
一方で、 %B を成す~itemたちの順序は関わらない。
】</p>


◎
The intersection of ordered sets A and B, is the result of creating a new ordered set set and, for each item of A, if B contains item, appending item to set.
</li>
	<li>
<p>
( `有順序~集合$ %A, `有順序~集合$ %B )
の
`和集合@
（ `union^en ）は、次の結果で与えられる：
</p>

		<ol>
			<li>
%S ~LET %A を`~cloneする$
</li>
			<li>
`~EACH$( %~item `~IN$ %B ) に対し
⇒
%S に %~item を`付加する$set
</li>
			<li>
~RET %S
</li>
		</ol>

<p class="trans-note">【
［
%A ／ %B
］を成す~itemたちの順序に加えて、
%A, %B の順序も，結果の %S を成す~itemたちの順序に有意になる 。
】</p>

◎
The union of ordered sets A and B, is the result of cloning A as set and, for each item of B, appending item to set.
</li>
</ul>

<hr>

<p>
`範囲@
{ %n 〜 %m }
という表記†は、［
%n 以上 %m 以下（ %n ~LTE %m とする††）
］の整数すべてからなる，~~昇順による, 新たな`有順序~集合$を作成する。
◎
The range n to m, inclusive, creates a new ordered set containing all of the integers from n up to and including m in consecutively increasing order, as long as m is greather than or equal to n.
</p>

<p class="trans-note">【†
原文では “`range n to m, inclusive^en”
】【††
和訳では、（この仕様が作成される以前から，）［
%n ~GT %m
］の場合にも この表記を用いている（空~集合を作成することになる）。
】</p>


<p class="example" id="example-the-range">
`~EACH$( %n `~IN$ `範囲$ { 1 〜 4 } ) に対し…
◎
For each n in the range 1 to 4, inclusive, …
</p>

			</section>
		</section>
		<section id="maps">
<h3 title="Maps">5.2. ~map</h3>

<p>
`有順序~map@
（ `ordered map^en ）は、仕様~levelの型である。
その各~instanceは、有限~個の［
`~key@map
（ `key^en ）/
`値@map
（ `value^en ）
］~pairからなる有順序~連列であり, かつ
同じ`~key$mapが重ねて現れないものである。
これらの各~pairは、
`~entry@map
（ `entry^en ）と呼ばれる。
【順序が重要でない場合は】 単に “~map” と称されることもある。
◎
An ordered map, or sometimes just "map", is a specification type consisting of a finite ordered sequence of key/value pairs, with no key appearing twice. Each key/value pair is called an entry.
</p>

<p class="note">注記：
`有順序~集合$と同様に，実装~間での相互運用性のため、~mapも既定で有順序であるものと見做す必要がある。
◎
As with ordered sets, by default we assume that maps need to be ordered for interoperability among implementations.
</p>

<p class="trans-note">【
単に，新たな`有順序~map$を作成するときは、他が指定されない限り，`空$mapにされているとする。
】</p>

<p>
`有順序~map$は、~literal構文を利用して表すこともできる
— そのためには、各 `~entry$mapを
"%~key → %値"
の形に記し, 各~entryどうしを~commaで区切った上で, 全体を文字 «[, ]» で括る。
`値$mapを［
検索する／設定する
］ための~indexing構文も利用できる
— そのためには，角括弧の内側に`~key$mapを与える。
◎
A literal syntax can be used to express ordered maps, by surrounding the ordered map with «[ ]» characters, denoting each of its entries as key → value, and separating its entries with a comma. An indexing syntax can be used to look up and set values by providing a key inside square brackets. 
</p>

<p class="example" id="example-map-notation">
%M ~EQ `有順序~map$ «[ `a^l → `x^bl, `b^l → `y^bl ]»
が与えられた下では、
%M[`a^l] は `~byte列$ `x^bl を表す。
◎
Let example be the ordered map «[ "a" → `x`, "b" → `y` ]». Then example["a"] is the byte sequence `x`.
</p>


<hr>

<ul>
	<li>
<p>
`有順序~map$ %M 内の `~key$map %K に対応する
`値を取得する@
ときは、次を返す
⇒
%M は［
%K を`~key$mapとする`~entryを包含して$いる
］ならば その`値$map ／
~ELSE_ ε （ “なし” ）
</p>

<p>
この演算は、
“ %M[ %K ] ”
とも表記される。
【和訳では、もっぱら，この表記を用いている。】
</p>
◎
To get the value of an entry in an ordered map given a key is to retrieve the value of any existing entry if the map contains an entry with the given key, or to return nothing otherwise. We can also use the indexing syntax explained above.
</li>
	<li>
<p>
`有順序~map$ %M 内の `~key$map %K に対応する
`値を設定する@
ときは、所与の値 %V に対し：
</p>

		<ol>
			<li>
~IF［
%M[ %K ] ~NEQ ε
］
⇒
%M 内の［
%K を`~key$mapとする`~entry$map
］の`値$map ~SET %V
</li>
			<li>
~ELSE
⇒
%M の末尾に新たな`~entry$map ( %K → %V ) を追加する
</li>
		</ol>

<p>
この演算は、
“ %M[ %K ] ~SET  %V ”
とも表記される。
【和訳では、もっぱら，この表記を用いている。】
</p>
◎
To set the value of an entry in an ordered map to a given value is to update the value of any existing entry if the map contains an entry with the given key, or if none such exists, to add a new entry with the given key/value to the end of the map. We can also denote this by saying, for an ordered map map, key key, and value value, "set map[key] to value".
</li>
	<li>
<p>
`有順序~map$ %M から
所与の %条件 に合致する
`~entryを除去する@
ときは
⇒
%M 内の［
%条件 に合致する`~entry$map
］すべてを %M から除去する（合致するものが無ければ何もしない）
</p>

<p>
“ %M[ %K ] ~SET ε ”
という表記は、
%M から条件［
%K を`~key$mapとする
］に合致する`~entryを除去する$ことを意味する。
【これは、和訳に固有の表記である。】
</p>
◎
To remove an entry from an ordered map is to remove all entries from the map that match a given condition, or do nothing if none do. If the condition is having a certain key, then we can also denote this by saying, for an ordered map map and key key, "remove map[key]".
</li>
	<li>
<p>
`有順序~map$ %M が
`~key$map %K を伴う
`~entryを包含して@
いるとは、［
%K を`~key$mapとする`~entry$map
］が %M 内に存在することを意味する。
</p>

<p>
この条件は、`値を取得する$ときの表記を用いて
“ %M[ %K ] ~NEQ ε ”
と記しても同じなので，そう表記されることもある（
“ %M[ %K ] ~EQ ε ”
は、その否定を表すことになる）。
【和訳では、もっぱら，この表記を用いている。】
</p>
◎
An ordered map contains an entry with a given key if there exists an entry with that key. We can also denote this by saying that, for an ordered map map and key key, "map[key] exists".
</li>
	<li>
<p>
`有順序~map$ %M の
`~keyたちを取得する@
ときは：
</p>
		<ol>
			<li>
%S ~LET 新たな`有順序~集合$
</li>
			<li>
%M 内の`~EACH$map( `~entry$map %K → %V ) に対し
⇒
%S に %K を`付加する$set
</li>
			<li>
~RET %S
</li>
		</ol>
◎
To get the keys of an ordered map, return a new ordered set whose items are each of the keys in the map’s entries.
</li>
	<li>
<p>
`有順序~map$ %M の
`値たちを取得する@
ときは：
</p>
		<ol>
			<li>
%L ~LET 新たな`~list$
</li>
			<li>
%M 内の`~EACH$map( `~entry$map %K → %V ) に対し
⇒
%L に %V を`付加する$
</li>
			<li>
~RET %L
</li>
		</ol>
◎
To get the values of an ordered map, return a new list whose items are each of the values in the map’s entries.
</li>
	<li>
`有順序~map$ %M の
`~size@map
（ `size^en ）は、次の結果の`~size$とする
⇒
%M の`~keyたちを取得する$
◎
An ordered map’s size is the size of the result of running get the keys on the map.
</li>
	<li>
`有順序~map$ %M が
`空@map
（ `empty^en ）であるとは、［
%M の`~size$map ~EQ 0
］であることをいう。
◎
An ordered map is empty if its size is zero.
</li>
	<li>
`有順序~map$ %M を順に
`反復する@map
ときは、
“ %M 内の`~EACH$map( `~entry$map %K → %V ) に対し：”
という句の下で，後続の注釈文にて［
%K, %V
］に対し演算する。
【和訳に固有の規約は、~list用の`反復する$を見よ。】
◎
To iterate over an ordered map, performing a set of steps on each entry in order, use phrasing of the form "For each key → value of map", and then operate on key and value in the subsequent prose.
</li>
</ul>

		</section>
		<section id="structs">
<h3 title="Structs">5.3. 構造体</h3>

<p>
`構造体@
（ `struct^en ）は、仕様~levelの型である。
その各~instanceは、有限~個の
`~item@sct
（ `item^en ）からなる集合であって，各`~item$sctには［
一意, かつ変異不可
］である
`名前@sct
（ `name^en ）がある。
◎
A struct is a specification type consisting of a finite set of items, each of which has a unique and immutable name.
</p>

<p class="trans-note">【
各`~item$sctには、暗黙的に “値” もある
— すなわち、`~item$sct自身が，`名前$sctに対応する “値” と同一視されている。
その点で`有順序~map$に似るが、`~key$mapにあたる`名前$sctの集合は固定的になる。
】</p>

<hr>

<p>
`名前$sctの順序が定義されている`構造体$は、
`~tuple@
（ `tuple^en, “組” ）とも称される。
表記の便宜~用に、`~tuple$を表すための~literal構文も利用できる
— そのためには、~tuple内の各`~item$sctどうしを~commaで区切った上で, 全体を丸括弧で括る。
この表記法を利用するときは、各`名前$sctが何であるか
【~literal内の各~値がどの名前に対応するか】
が，文脈から明瞭になる必要がある。
これは、当の`~tuple$の最初の~instanceに名前を前置することにより行える。
◎
Structs with a defined order are also known as tuples. For notational convenience, a literal syntax can be used to express tuples, by surrounding the tuple with parenthesis and separating its items with a comma. To use this notation, the names need to be clear from context. This can be done by preceding the first instance with the name given to the tuple.
</p>


<div class="example" id="example-tuple">
<p>
~HTTP~statusは、［
~code（ 3 桁の数 ）, ~text（ ~byte列 ）
］からなる`~tuple$の例である。
◎
A status is an example tuple consisting of a code (a three-digit number) and text (a byte sequence).
</p>

<p>
その用法を例示するためだけの，~status~tupleを操作する~algoを示す：
◎
A nonsense algorithm that manipulates status tuples for the purpose of demonstrating their usage is then:
</p>

<ol>
	<li>
%~status例 ~LET ~status ( 200, `OK^bl )
◎
Let statusInstance be the status (200, `OK`).
</li>
	<li>
%~status例 ~SET ( 301, `FOO BAR^bl )
◎
Set statusInstance to (301, `FOO BAR`).
</li>
	<li>
~IF［
%~status例 の~code ~EQ 404
］
⇒
…
◎
If statusInstance’s code is 404, then …
</li>
</ol>

</div>

<p class="note">注記：
`構造体$が`~tuple$に限られないのは、意図的である。
この標準を利用する文書は、依存する他の仕様に利用されている~literal構文を壊すことなく，自身の構造体に新たな`名前$sctを追加する柔軟性も必要になるかもしれず、そのような事例では~tupleは適切にならないので。
◎
It is intentional that not all structs are tuples. Documents using the Infra Standard might need the flexibility to add new names to their struct without breaking literal syntax used by their dependencies. In that case a tuple is not appropriate.
</p>

<hr>
<p>
2 個の `~item$sctからなる`~tuple$は
`~pair@
（ `pair^en ）とも称される。
`~pair$に対しては、少し短い~literal構文も利用できる
— そのためには
2 個の `~item$sct を~slash（ "/" ）で区切って表記する。
◎
Tuples with two items are also known as pairs. For pairs, a slightly shorter literal syntax can be used, separating the two items with a / character.
</p>

<p class="example" id="example-pair">
上の~tuple %~status例 を別の仕方で表せば，
200 / `OK^bl
になる。
◎
Another way of expressing our statusInstance tuple above would be as 200/`OK`.
</p>

		</section>
	</section>
	<section id="json">
<h2 title="JSON">6. ~JSON</h2>

<p>
`~byte列を~JSONとして構文解析する@
ときは、所与の
( %~byte列 )
に対し、次の手続きを走らす：
◎
To parse JSON from bytes given bytes, run these steps:
</p>

<ol>
	<li>
%jsonText ~LET `~UTF-8復号する$( %~byte列 )
`ENCODING$r
◎
Let jsonText be the result of running UTF-8 decode on bytes. [ENCODING]
</li>
	<li>
<p>
~RET
? `Call$A( `%JSONParse%$, `undefined^jv, «%jsonText» )
`ECMA-262$r
◎
Return ? Call(%JSONParse%, undefined, « jsonText »). [ECMA-262]
</p>

<p class="note">注記：
この段では、~JS仕様の表記規約を利用している。
◎
The conventions used in this step are those of the JavaScript specification.
</p>
	</li>
</ol>


	</section>
	<section id="forgiving-base64">
<h2 title="Forgiving base64">7. ~forgiving-base64</h2>

<p class="algo-head">
`~forgiving-base64符号化する@
ときは、所与の
( `~byte列$ %~data )
に対し，［
`RFC4648$r, 4 節に定義される~base64~algo
］を %~data に適用した結果の文字列を返す。
◎
To forgiving-base64 encode given a byte sequence data, apply the base64 algorithm defined in section 4 of RFC 4648 to data and return the result. [RFC4648]
</p>

<p class="note">注記：
これが，
“`~forgiving-base64符号化する$”
と命名されているのは、
“`~forgiving-base64復号する$”
と対称にするためである
— 後者は、ある種の入力~用に~errorの取扱いを定義するので， RFC によるものと異なる。
◎
This is named forgiving-base64 encode for symmetry with forgiving-base64 decode, which is different from the RFC as it defines error handling for certain inputs.
</p>

<p class="trans-note">【
“符号化-”, “復号-”
の命名は、~byte列の方が “元の~dataである” ことに基づく。
】</p>

<p class="algo-head">
`~forgiving-base64復号する@
ときは、所与の
( 文字列 %~data )
に対し，次を走らす：
◎
To forgiving-base64 decode given a string data, run these steps:
</p>

<ol>
	<li>
%~data からすべての`~ASCII空白$を除去する
◎
Remove all ASCII whitespace from data.
</li>
	<li>
~IF［
%~data の`長さ$strは 4 の倍数である
］
⇒
次を 2 回 繰り返す
⇒
~IF［
%~data の最後の`符号位置$ ~EQ `003D^U `=^smb
］
⇒
%~data から最後の`符号位置$を除去する
◎
If data’s length divides by 4 leaving no remainder, then:
• If data ends with one or two U+003D (=) code points, then remove them from data.
</li>
	<li>
%不足個数 ~LET 
( %~data の`長さ$strを 4 の倍数に切り上げた結果 ) − %~data の`長さ$str
◎
↓</li>
	<li>
~IF［
%不足個数 ~EQ 3
］
⇒
~RET `失敗^i
◎
If data’s length divides by 4 leaving a remainder of 1, then return failure.
</li>
	<li>
%~data 内 の~EACH( `符号位置$ %C ) に対し
⇒
~IF［
%C ~NIN { `002B^U `+^smb, `002F^U `/^smb, `~ASCII英数字$ }
］
⇒
~RET `失敗^i
◎
If data contains a code point that is not one of
• U+002B (+)
• U+002F (/)
• ASCII alphanumeric 
then return failure.
</li>
	<li>
%出力 ~LET 空`~byte列$
◎
Let output be an empty byte sequence.
◎
Let buffer be an empty buffer that can have bits appended to it.
</li>
	<li>
%~data の末尾に %不足個数 個の `0041^U `A^smb を付加する
◎
↓↓</li>
	<li>
%位置 ~LET %~data の先頭を指している`位置~変数$
◎
Let position be a position variable for data, initially pointing at the start of data.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position does not point past the end of data:
</p>
		<ol>
			<li>
%buffer ~LET 0
◎
↓</li>
			<li>
<p>
次を 4 回 繰り返す：
</p>
				<ol>
					<li>
%行 ~LET `RFC4648$r の表［
Table 1: The Base 64 Alphabet
］内の，次を満たす行
⇒
行の 2 列目に与えられている`符号位置$ ~EQ %位置↗
</li>
					<li>
%buffer ~SET ( %buffer ~MUL 64 ) ~PLUS ( %行 の 1 列目に与えられる整数 )
</li>
					<li>
%位置 ~INCBY 1
</li>
				</ol>
◎
Find the code point pointed to by position in the second column of Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in the first cell of the same row. [RFC4648]
◎
Append the six bits corresponding to number, most significant bit first, to buffer.
</li>
			<li>
( %m1, %m2, %m3 ) ~LET 次の等式を満たす，範囲 { 0 〜 255 } に入る 3 個の整数
⇒
( %m1 ~MUL 256 ~MUL 256 ) ~PLUS ( %m2 ~MUL 256 ) ~PLUS %m3 ~EQ %buffer
◎
If buffer has accumulated 24 bits, interpret them as three 8-bit big-endian numbers.＼
</li>
			<li>
%出力 に［
%m1, %m2, %m3
］を値にとる`~byte$たちを順に付加する
◎
Append three bytes with values equal to those numbers to output, in the same order, and then empty buffer.
◎
Advance position by 1.
</li>
		</ol>
	</li>
	<li>
<p>
%出力 の末尾から %不足個数 個の`~byte$を除去する
◎
If buffer is not empty, it contains either 12 or 18 bits. If it contains 12 bits, then discard the last four and interpret the remaining eight as an 8-bit big-endian number. If it contains 18 bits, then discard the last two and interpret the remaining 16 as two 8-bit big-endian numbers. Append the one or two bytes with values equal to those one or two numbers to output, in the same order.
</p>

<p class="note">注記：
入力 %~data は 1 文字あたり 6 ~bit, %出力 は 1 ~byteあたり 8 ~bit の~dataを表現するので、( %不足個数 × 2 ) 個の~bitが，入力の末尾から切り捨てられることになる。
例えば 2 つの入力
`YQ^l （ 6 ~bit表現 24, 16 ）, `YR^l （ 6 ~bit表現 24, 17 ）
に対する結果はいずれも `a^bl になる。
◎
The discarded bits mean that, for instance, "YQ" and "YR" both return `a`.
</p>
	</li>
	<li>
~RET %出力
◎
Return output.
</li>
</ol>

	</section>
	<section id="namespaces">
<h2 title="Namespaces">8. 名前空間</h2>

<div>
<p>
次の名前空間（ `namespace^en ）が定義される：
</p>

<table><tbody><tr><th>`~HTML名前空間@
<td>`http://www.w3.org/1999/xhtml^l

<tr><th>`~MathML名前空間@
<td>`http://www.w3.org/1998/Math/MathML^l

<tr><th>`~SVG名前空間@
<td>`http://www.w3.org/2000/svg^l

<tr><th>`~XLink名前空間@
<td>`http://www.w3.org/1999/xlink^l

<tr><th>`~XML名前空間@
<td>`http://www.w3.org/XML/1998/namespace^l

<tr><th>`~XMLNS名前空間@
<td>`http://www.w3.org/2000/xmlns/^l

</tbody></table>

◎
The HTML namespace is "http://www.w3.org/1999/xhtml".
◎
The MathML namespace is "http://www.w3.org/1998/Math/MathML".
◎
The SVG namespace is "http://www.w3.org/2000/svg".
◎
The XLink namespace is "http://www.w3.org/1999/xlink".
◎
The XML namespace is "http://www.w3.org/XML/1998/namespace".
◎
The XMLNS namespace is "http://www.w3.org/2000/xmlns/".
</div>
	</section>

</main></div><!-- id="MAIN" -->

	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
次の方々からの協力に感謝する：
</p>

<div lang="en-x-a0">

<p>
Many thanks to

Addison Phillips,
Aryeh Gregor,
Chris Rebert,
Daniel Ehrenberg,
Dominic Farolino,
Jake Archibald,
Jungkee Song,
Leonid Vasilyev,
Malika Aubakirova,
Michael™ Smith,
Mike West,
Ms2ger,
Philip Jägenstedt,
Rashaun "Snuggs" Stovall,
Sergey Shekyan,
Simon Pieters,
Tab Atkins,
Tobie Langel,
triple-underscore,
and Xue Fuqiao

for being awesome!
</p>

<p>
This standard is written by
<a href="https://annevankesteren.nl/" lang="nl">Anne van Kesteren</a>(
<a href="https://www.mozilla.org/">Mozilla</a>,
<a href="mailto:annevk@annevk.nl">annevk@annevk.nl</a>
)
and
<a href="https://domenic.me/">Domenic Denicola</a>(
<a href="https://www.google.com/">Google</a>,
<a href="mailto:d@domenic.me">d@domenic.me</a>
).
</p>

<p>
Copyright © 2018 WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution
4.0 International License</a>.</p>

</div>

	</section>
