<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Cascading and Inheritance Level 5 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">
<style>
samp {
	white-space: nowrap;
}

@supports (display: grid) and (display: contents) {

#_samples_matrix {
	min-width: 30em;
	max-width: 50em;
}

#_samples_matrix tr {
	grid-template-areas:
		"index prop prop prop prop prop"
		"index 宣言 宣言 宣言 宣言 宣言"
		"index cascade 指定 算出 使用 実際"
	;
	grid-template-columns: 3em 1fr 1fr 1fr 1fr 1fr;
}

#_samples_matrix tr > *:nth-child(1) {
	grid-area: index;
	border-left-width: 0;
}

#_samples_matrix tr > *:nth-child(2) {
	grid-area: prop;
	border-left-width: 0;
}

#_samples_matrix tr > *:nth-child(3) {
	grid-area: 宣言;
}

#_samples_matrix tr > *:nth-child(4) {
	grid-area: cascade;
}

#_samples_matrix tr > *:nth-child(5) {
	grid-area: 指定;
}

#_samples_matrix tr > *:nth-child(6) {
	grid-area: 算出;
}

#_samples_matrix tr > *:nth-child(7) {
	grid-area: 使用;
}

#_samples_matrix tr > *:nth-child(8) {
	grid-area: 実際;
}
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 'p':
	{
		const i = text.indexOf(':');
		if( i > 0 ){
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i+1)}</code>`;
		}
	}
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Cascading and Inheritance Level 5
spec_date:2022-03-30
trans_update:2022-04-04
source_checked:211027
page_state_key:CSS
original_url:https://drafts.csswg.org/css-cascade-5/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2022,permissive
trans_1st_pub:2012-07-07

●●class_map
p:property
d:descriptor
at:at-rule
f:func
ps:pseudo
pe:pseudo
css:css
u:unit
v:value
t:type
e:element
a:attr

●●tag_map
p:code
d:code
v:code
f:code
at:code
ps:code
pe:code
t:var
css:code
u:code
e:code
a:code
m:code
I:code
c:code
V:var
em:em
i:i

●●original_id_map

●●mdn_urls
propdef-all:CSS/all
at-ruledef-import:CSS/@import

●●words_table1
CSSCOND4:https://drafts.csswg.org/css-conditional-4/

●●words_table

	●cascade
import:
important:
default::::デフォルト
	~default法:defaulting
cascaded::::カスケード
	~cascade法:cascading
非略式:longhand::~

全域:wide::~
出現順序:order of appearance:~
	現れた順序:appearance order
	出現:occurrence／:occurence
継承法:inheritance::~
宣言d:declared::宣言
絞込み:filtering::絞り込み

重み:weight:~
優先順位:precedence:~
	優先:win
	優先:take precedence over
	優先:order of precedence
	より優先度が低い:below
	最優先:winning
	~~選定-:win/choose
	優先-
	低いものから順に:in order from lowest to highest

巻戻し:rolling back::~
巻戻す:roll backする::~
巻戻され:roll backされ::~
	^en:revert

出自:origin::~
詳細度:specificity::~

別名n:name alias::別名
別名化:aliasing::~
別名化-:alias::~

消去-:erase:~

未層:unlayered::~
	未層:un-layered
	層~化された:layered
区分:segment:~

	〜に算出される:computed
	~styleの算出d値:computed style
	`~cascade層$の`名前$ly:layer-names
	名前を定義している:name-defining

	●layout
table:
flex:
駒:item:::アイテム
row:

	●CSS
CSSOM:
条件付き:conditional::~
条件付きで:conditionalに::~
無条件:unconditional::~
定義表:definition table:~
keyframe:
supports:
	~animateされた:animated
	媒体:medium
	~cascade層:Cascade Layer／cascade layer

	●構文
展開-:expand::~
展開:expansion::~
連結-:concatenate::~
丸括弧:parentheses:~
差挟む:interleaveする:差し挟む
差挟まれ:interleaveされ:差し挟まれ
	挟まずに:no intervening
一文:statement::~
	無名:unnamed／un-named → 匿名
period::::ピリオド

	接頭辞~付き:-prefixed
	出現:appearance
	出現-:occurring
	括られ:wrapped
	そのまま:literally
	文字列そのまま:bare string
	規則~block:rule-block
	丸括弧が~~追加:extra set of parentheses

	●fetch／保安
Content-Type:
	資源:file
自由:free:~
推定-:infer:~

	●処理
変形-:transform::~
翻訳-:translate:~
獲得-:acquire:~
近似-:approximate:~
稼働中:running 時:~
代用-:substitute::~
続行-:proceed:~
accessor::::アクセス子
偽:false:~
真:true:~
	`真^i に評価される:true
入する:enterする:入る
比較照合-:collate:~

	終えた:has
	経て:result of
	経る:process
	〜を経ることで:By way of
	絞られ:-
	絞り:-
	絞る:-
	準備が整った:ready
	重い, あるいは並列化し難い:expensive or hard-to-parallelize operations
	取り込:import
	取り込:draw
	取り消:erasing
	増やす:increases

	●構造
light:
encapsulation::::カプセル化
virtual:
有限個の:finiteな:~
推移的:transitive:~
	各部:parts
	属-:belong／
	組み替え:manipulation
	包装する:wrapper
	順序し直:re-order
	配列し直す:re-arrange
	合間に〜挟まれ:intercepted
	方が低い／より低い:lower
	外縁な層を視野に:in an outer layer-scope
	層の順序-法:layer-ordering
	~source順序:source-order
	~treeに留まる:tree-abiding
	連続して:consecutive
	先んじて:in advance, before
	~shadow~DOM:Shadow DOM

	●仕様
競合:conflict:~
中核的:core:~
透過的:transparent:~
可用性:availability:~
理論的:theoretical:~
不注意:careless:~
不知に:inadvertentに:知らずに
適応-:accommodate:~
拡げる:expandする:~
依存性:dependencies:~
吹飛ばさ:blow away さ:吹き飛ばさ
黙示-:imply:~
可能性:possibility:~
team::::チーム
組織化-:organize:~
指図-:direct:~
原則:principle:~
	原則として:in principle
供与-:contribute:~
切替えた:switchした:切り替えた
逃れる:escapeする:~
衝突:collision:~
framework::::フレームワーク
寄与-:contribute:~
尊重-:respect:~
自明:trivial:~
	自明でない:non-trivial
snapshot::::スナップショット

	Level
	力関係:balance of power／balance
	~化:ize
	どちらが〜されようが:regardless of whether
	〜な限り:as far as
	特能~support:feature-support
	:Incorporation of
	こともある:may
	同様:like／similar
	同じく:As with
	同じに:
	-:関わらず
	関係にある:relationship
	一括して:-
	一方で:but／:while／:whereas
	別として:-
	根幹を成す:fundamentalな
	単に:simply
	段階:step
	意味
	意味的に:in meaning
	どうにかして:somehow
	手による:-
	の際に:in preparation for
	~~字義通りの~~意味:where it comes from
	ある:available
	ことになり得る:potentially
	可能になる:enable
	点で:in terms of
	加えて:furthermore
	であっても:nonetheless
	に依存させ:–dependent
	expectations
	~~考慮:attempts to create
	考慮-:considerations in mind
	選ぶ:choose
	選ばれ:chosen
	選ばれ:-
	施した:made
	書き直せ:rewritten
	知れる:learned
	~~避け:-
	~~除外-:not qualified
	仕上げる:make
	仕立てる:be made
	記され:written
	要する:need
	記す:writing
	機能-:function
	調べれ:probing
	ほぼ違わない:almost exactly like
	~~簡潔に記す:brevity
	関して／:concern
	または:option
	さらに:in advance
	当然ながら:of course
	せずに済ませ:avoid
	満たす:satisfy
	でしかない:mere
	逆も同様:vice versa
	読まずとも:without having to read
	~~明らか:apparent
	一意になる:have unique identities
	供する:gain
	助けに:helpful
	-:help
	元に戻した:Revert
	主要な:major
	指して:refer／to
	~~導出-:-
	のときと違って 〜 ~~含められ:collapse

	●未分類
theme::::テーマ
component::::コンポーネント
private::::プライベート
基準:reference:~
視覚系:visual:~
italic:
携帯:handheld:~
仮想の:fictional:~
併合-:merge::~
隠した:hideした:~
隠され:hideされ:~
参照r:refer:参照
収容-:accommodate:~
付され:attachされ:~
	〜に付された:〜-attached
nullable:::null 可能

	-:slotted
	^en:case-mapping
	持-
	挙げ:-
	置き換わる:result of putting
	戻す:-
	消失した:missing
	現れ:appear
	現れ:-
	総称-:-
	呼ばれ:-
	備える:possess
	及ぼし
	白紙状態:blank slate
	整数幅の画素境界:borders with integer pixel widths
	orphan 行数:how many orphan lines
	表:table
	行:line
	高
	高い:higher
	方が〜高い:higher
	源とする:sourced form
	混ぜ合わせる:blend
	来て:come
	高いものから順に:in descending order
	越え:cross
	ある要素~用の既定:element defaults
	-:when invoked
	FULL STOP:full-stop
	名前が一致する:identically-named
	下位-~file:sub-file
	組み込まれ:subsume
	所与の名前を伴う:named
	基づくように:basis
	一つしかない:singular
	〜を自覚-:-aware
	^e:span
	一行目:First line
	二行目:Second line
	混在させ:mixed
	`未層$な:without further nesting
	-:block layer-assignment
	媒体~query:media-query
	色~scheme:color-scheme
	あてがう:place
	一箇所:in one place
	課す:place
	その場で:in place
	に代えて:in place of
	在った所:in place of
	箇所:place

	●指示語
旧い:old:~
最終-:final:~

	欄:line
	外から:the outer page
	多い
	多く
	左右-
	当該の
	大元の:originating
	後続-:follow
	後続の:-
	後述の:see below
	対象:target
	対象に:targeted by
	地点:at the point
	大きな:large
	最後:Finally
	最終的:final
	一群の:a set of
	一度だけ:only once
	の一つに:one of
	一つも:no
	こともある:sometimes
	以下
	以前:earlier
	以外
	個
	個以上
	各種:-
	種:-
	他方:-
	無い
	§:chapter
	組
	より新しい:newer
	新たに:New in
	先行-:precede
	先行-:previous
	逆に:opposite
	逆に:invert
	当該:this
	間の
	並び
	付け
	同時
	同順
	しばらくの間:for a while
	の下で:on par with
	時点:time
	それ以外の点では:They otherwise
	方が低い／より低い:lower
	低い:-
	幅
	応じて
	更に
	語
	限-
	引数:value
	冒頭:up front

	●訳注
	原則的
	付記-
	捉えら
	連鎖的
	開始時
	補間
	変わらない
	全般
	共通
	句
	考えら
	思われる
	本来は
	旨を
	曖昧に
	見られ
	見受け
	誤解
	高次の
	限定-
	関連の
	意図的に
	概念
	概念的
	細分化-
	判断-
	辿った
	逆転-
	織り込んだ
	行われ
	処理規則
	言い換えれば
	要因
	参考
	役割
	少ない
	何が
	中間
	有無
	末端の
	所では
	順位
	順位付け


●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
FrozenArray:~WEBIDL#idl-frozen-array
CSSOMString:~CSSOM1#cssomstring

I.CSSLayerStatementRule:#csslayerstatementrule
I.CSSLayerBlockRule:#csslayerblockrule
I.CSSImportRule:~CSSOM1#cssimportrule
I.CSSGroupingRule:~CSSOM1#cssgroupingrule
I.CSSRule:~CSSOM1#cssrule

m.layerName:#dom-cssimportrule-layername
m.name:#dom-csslayerblockrule-name
m.nameList:#dom-csslayerstatementrule-namelist

c.getComputedStyle():~CSSOM1#dom-window-getcomputedstyle

	●css
at.font-face:~CSSFONT#at-font-face-rule
at.keyframes:~CSSANIM#at-ruledef-keyframes
at.import:#at-ruledef-import
at.supports:~CSSCOND#at-ruledef-supports
at.media:~CSSCOND#at-ruledef-media
at.charset:~CSSSYN#at-ruledef-charset
at.namespace:~CSSNS#at-ruledef-namespace
at.layer:#at-ruledef-layer

pe.before:~CSSPSEUDO#selectordef-before
pe.after:~CSSPSEUDO#selectordef-after
pe.first-line:~CSSPSEUDO#selectordef-first-line

p.all:#propdef-all

p.flex:~CSSFLEX#propdef-flex
p.background:~CSSBG#propdef-background
p.background-color:~CSSBG#propdef-background-color
p.background-image:~CSSBG#propdef-background-image
p.border:~CSSBG#propdef-border
p.border-bottom-width:~CSSBG#propdef-border-bottom-width
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-right-width:~CSSBG#propdef-border-right-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.border-image:~CSSBG#propdef-border-image
p.border-width:~CSSBG#propdef-border-width
p.border-style:~CSSBG#propdef-border-style
p.border-color:~CSSBG#propdef-border-color

p.break-before:~CSSBREAK#propdef-break-before
p.page-break-before:~CSS22/page.html#propdef-page-break-before
p.orphans:~CSSBREAK#propdef-orphans

p.color:~CSSCOLOR#propdef-color

p.font-family:~CSSFONT#propdef-font-family
p.font-size-adjust:~CSSFONT#propdef-font-size-adjust
	~CSSWG/css-fonts-4
p.font-size:~CSSFONT#propdef-font-size
p.font-style:~CSSFONT#propdef-font-style
p.font-variant:~CSSFONT#propdef-font-variant
p.font-weight:~CSSFONT#propdef-font-weight
p.font:~CSSFONT#propdef-font

p.list-style-position:~CSSLIST#propdef-list-style-position
p.text-align:~CSSTEXT#propdef-text-align
p.text-indent:~CSSTEXT#propdef-text-indent
p.text-transform:~CSSTEXT#propdef-text-transform

p.direction:~CSSWM#propdef-direction
p.unicode-bidi:~CSSWM#propdef-unicode-bidi
p.writing-mode:~CSSWM#propdef-writing-mode
p.text-orientation:~CSSWM#propdef-text-orientation

p.height:~SIZING#propdef-height
p.line-height:~CSS2VISUDET#propdef-line-height
p.page-break-after:~CSS22/page.html#propdef-page-break-after
p.width:~SIZING#propdef-width
p.display:~CSSDISP#propdef-display
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y

v.initial:#valdef-all-initial
v.inherit:#valdef-all-inherit
v.unset:#valdef-all-unset
v.revert:#valdef-all-revert
v.revert-layer:#valdef-all-revert-layer

v.handheld:~MQ5#valdef-media-handheld
	~CSS22/media.html#media-types
v.currentcolor:~CSSCOLOR#valdef-color-currentcolor

f.url:~CSSVAL#funcdef-url
f.supports:~CSSCOND4#funcdef-supports

t.url:~CSSVAL#url-value
t.string:~CSSVAL#string-value
t.length:~CSSVAL#length-value
t.media-query-list:~MQ5#typedef-media-query-list
t.media-query:~MQ5#typedef-media-query
t.supports-condition:~CSSCOND#typedef-supports-condition
t.supports-decl:~CSSCOND#typedef-supports-decl
	t.declaration:？
t.layer-name:#typedef-layer-name
t.import-condition:#typedef-import-condition

t.ident:~CSSVAL#typedef-ident
t.length-percentage:~CSSVAL#typedef-length-percentage
t.color:~CSSCOLOR#typedef-color

t.declaration-value:~CSSSYN#typedef-declaration-value
t.ident-token:~CSSSYN#typedef-ident-token
t.delim-token:~CSSSYN#typedef-delim-token
t.stylesheet:~CSSSYN#typedef-stylesheet


u.em:~CSSVAL#em
u.ex:~CSSVAL#ex
u.ch:~CSSVAL#ch
u.vh:~CSSVAL#valdef-length-vh
u.vw:~CSSVAL#valdef-length-vw

css.!important:#importance

e.audio:~HEmedia#the-audio-element
e.s:~HEtextlevel#the-s-element
e.slot:~HEscripting#the-slot-element
e.link:~HEmetadata#the-link-element
e.style:~HEmetadata#the-style-element
e.p:~HEgrouping#the-p-element
e.div:~HEgrouping#the-div-element
e.span:~HEtextlevel#the-span-element

a.dir:~HTMLdom#attr-dir


	●用語
~prop:#css-property
~important:#important
~importantな宣言:#important
通常の宣言:#normal
~import条件:#import-conditions
	~import条件:~CSSWG/css-cascade-4/#import-conditions
~default法:#defaulting
	下の表:#stages-examples
~cascadeの出力:#output-of-the-cascade
~cascade:#cascade
~cascade法:#cascading
~cascaded値:#cascaded-value
略式~prop:#shorthand-property
下位prop:#longhand
設定し直すのみ:#reset-only-sub-property
旧来の別名n:#legacy-name-alias
旧来の別名~値:#css-legacy-value-alias
旧来の略式~prop:#legacy-shorthand

継承:#inheritance
継承d~prop:#inherited-property
継承d値:#inherited-value
初期~値:#initial-value
算出d値:#computed-value
使用~値:#used-value
指定d値:#specified-value
実際の値:#actual-value
宣言d値:#declared-value

適用され:#apply
適用される宣言:#_applied-declarations

cC.出自と重要度:#cascade-origin
cC.重要度:#cascade-origin
cC.出自:#cascade-origin
cC.文脈:#cascade-context
~encapsulation文脈:#encapsulation-contexts
cC.要素に付された~style:#style-attr
cC.層:#cascade-layering
未層:#_un-layered
cC.詳細度:#cascade-specificity
cC.出現順序:#cascade-order

出自:#origin
~UA出自:#cascade-origin-ua
~UA~stylesheet:#cascade-origin-ua
作者~出自:#cascade-origin-author
作者~呈示~用~hint出自:#author-presentational-hint-origin
利用者~出自:#cascade-origin-user
~animation出自:#cascade-origin-animation
遷移~出自:#cascade-origin-transition

~cascade層:#cascade-layers
ly.名前:#layer-name

~sort判定基準:#cascade-sort

一文~構文:#layer-empty
~block構文:#layer-block

~cascadeに依存する~keyword:#cascade-dependent-keyword

	●用語（CSS
~CSS全域~keyword:~CSSVAL#css-wide-keywords
~keyword:~CSSVAL#css-keyword

~CSS識別子:~CSSVAL#css-css-identifier

~at-rule:~CSSSYN#at-rule
~block~at-rule:~CSSSYN#block-at-rule
一文~at-rule:~CSSSYN#statement-at-rule
宣言:~CSSSYN#declaration
	宣言（宣言~群）:~CSSOM1#cssstyledeclaration-declarations

~style属性:~CSSSTYLEATTR#style-attribute0
~supportする:~CSSCOND#support-definition
~supports~query:~CSSCOND#supports-queries
条件付き~group規則:~CSSCOND#conditional-group-rule
媒体~query:~MQ5#media-query
媒体~query~list:~MQ5#media-query-list

表示~型:~CSSDISP#display-type
~box:~CSSDISP#box
匿名~box:~CSSDISP#anonymous
~box~tree:~CSSDISP#box-tree
~text~node:~CSSDISP#text-nodes
要素:~CSSDISP#elements
行内~box:~CSSDISP#inline-box
~text連なり:~CSSDISP#text-run

根~行内~box:~CSSINLINE#root-inline-box

~prop宣言:~CSSSYN#css-property-declarations
環境~符号化法:~CSSSYN#environment-encoding
~custom~prop:~CSSVAR#custom-property

解決d値:~CSSOM1#resolved-values
最終-~CSS~stylesheet~list:~CSSOM1#documentorshadowroot-final-css-style-sheets

仮想の~tag列:~CSSPSEUDO#fictional-tag-sequence
~treeに留まる疑似要素:~CSSPSEUDO#tree-abiding

~tree文脈:~CSSSCOPING#tree-context
平坦~化された要素~tree:~CSSSCOPING#flat-tree

~flex駒:~CSSFLEX#flex-item

選択子:~SELECTORS4#selector
疑似要素:~SELECTORS4#pseudo-element
詳細度:~SELECTORS4#specificity

~box断片:~CSSBREAK#box-fragment


	~CSS2VISUREN#box-gen
	~CSSWM#text-direction
	CSSImportRule.styleSheet
	~HTMLurl#content-type
	~HTMLrendering#the-css-user-agent-style-sheet-and-presentational-hints
	~SVG11/styling.html#UsingPresentationAttributes

容器~query:~CSSWG/css-contain-3/#container-query

	●用語（他
~DOM~tree:~DOM4#concept-tree
~shadow~tree:~DOM4#concept-shadow-tree
~light~tree:~DOM4#concept-light-tree
~shadowも含む~tree順序:~DOM4#concept-shadow-including-tree-order
過去互換~mode:~DOM4#concept-document-quirks
doc.生成元:~DOM4#concept-document-origin
接続されて:~DOM4#connected

rs.~URL:~FETCH#concept-response-url
~network~error:~FETCH#concept-network-error

v.stylesheet:~HTMLlinks#link-type-stylesheet

url.生成元:~URL1#concept-url-origin

~Content-Type~metadata:~HTMLurl#content-type
同一-生成元:~ORIGIN#same-origin
呈示~属性:~SVGstyling#TermPresentationAttribute
	~SVG11/styling.html#UsingPresentationAttributes

~MIME型:~MIMESNIFF#mime-type

●●ref_normative

[CSS-2021]
    Tab Atkins Jr.; Elika Etemad; Florian Rivoal. ＜CSS Snapshot 2021＞. 31 December 2021. NOTE. URL: https://www.w3.org/TR/css-2021/
[CSS-ANIMATIONS-1]
    Dean Jackson; et al. ＜CSS Animations Level 1＞. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. 26 July 2021. CR. URL: https://www.w3.org/TR/css-backgrounds-3/
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 4＞. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 4＞. 13 January 2022. CR. URL: https://www.w3.org/TR/css-cascade-4/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. 15 December 2021. WD. URL: https://www.w3.org/TR/css-color-4/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. 13 January 2022. CR. URL: https://www.w3.org/TR/css-conditional-3/
[CSS-CONDITIONAL-5]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 5＞. 21 December 2021. WD. URL: https://www.w3.org/TR/css-conditional-5/
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Display Module Level 3＞. 3 September 2021. CR. URL: https://www.w3.org/TR/css-display-3/
[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. ＜CSS Fonts Module Level 4＞. 21 December 2021. WD. URL: https://www.w3.org/TR/css-fonts-4/
[CSS-FONTS-5]
    Myles Maxfield; Chris Lilley. ＜CSS Fonts Module Level 5＞. 21 December 2021. WD. URL: https://www.w3.org/TR/css-fonts-5/
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. ＜CSS Pseudo-Elements Module Level 4＞. 31 December 2020. WD. URL: https://www.w3.org/TR/css-pseudo-4/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. 3 April 2014. WD. URL: https://www.w3.org/TR/css-scoping-1/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. 24 December 2021. CR. URL: https://www.w3.org/TR/css-syntax-3/
[CSS-TRANSITIONS-1]
    David Baron; et al. ＜CSS Transitions＞. 11 October 2018. WD. URL: https://www.w3.org/TR/css-transitions-1/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. 16 December 2021. WD. URL: https://www.w3.org/TR/css-values-4/
[CSS-VARIABLES-1]
    Tab Atkins Jr.. ＜CSS Custom Properties for Cascading Variables Module Level 1＞. 11 November 2021. CR. URL: https://www.w3.org/TR/css-variables-1/
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 3＞. 10 December 2019. REC. URL: https://www.w3.org/TR/css-writing-modes-3/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. 26 August 2021. WD. URL: https://www.w3.org/TR/cssom-1/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[MEDIAQ]
    Florian Rivoal; Tab Atkins Jr.. ＜Media Queries Level 4＞. 25 December 2021. CR. URL: https://www.w3.org/TR/mediaqueries-4/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECT]
    Tantek Çelik; et al. ＜Selectors Level 3＞. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Box Alignment Module Level 3＞. 24 December 2021. WD. URL: https://www.w3.org/TR/css-align-3/
[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. ＜CSS Fragmentation Module Level 3＞. 4 December 2018. CR. URL: https://www.w3.org/TR/css-break-3/
[CSS-CONTAIN-2]
    Tab Atkins Jr.; Florian Rivoal; Vladimir Levin. ＜CSS Containment Module Level 2＞. 16 December 2020. WD. URL: https://www.w3.org/TR/css-contain-2/
[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. ＜CSS Flexible Box Layout Module Level 1＞. 19 November 2018. CR. URL: https://www.w3.org/TR/css-flexbox-1/
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. ＜CSS Inline Layout Module Level 3＞. 27 August 2020. WD. URL: https://www.w3.org/TR/css-inline-3/
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Lists and Counters Module Level 3＞. 17 November 2020. WD. URL: https://www.w3.org/TR/css-lists-3/
[CSS-PAGE-3]
    Elika Etemad; Simon Sapin. ＜CSS Paged Media Module Level 3＞. 18 October 2018. WD. URL: https://www.w3.org/TR/css-page-3/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. 17 December 2021. WD. URL: https://www.w3.org/TR/css-sizing-3/
[CSS-STYLE-ATTR]
    Tantek Çelik; Elika Etemad. ＜CSS Style Attributes＞. 7 November 2013. REC. URL: https://www.w3.org/TR/css-style-attr/
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. ＜CSS Text Module Level 3＞. 22 April 2021. CR. URL: https://www.w3.org/TR/css-text-3/
[CSS-TEXT-4]
    Elika Etemad; et al. ＜CSS Text Module Level 4＞. 18 March 2022. WD. URL: https://www.w3.org/TR/css-text-4/
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. ＜CSS Writing Modes Level 4＞. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより公開された
<a href="~SPEC_URL">CSS Cascading and Inheritance Level 5</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-cascade-5/
公表履歴
	https://www.w3.org/standards/history/css-cascade-5

実装報告
	https://wpt.fyi/results/css/css-cascade
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-cascade-5">CSSWG Issues Repository</a>

編集
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="http://miriamsuzanne.com/contact">Miriam E. Suzanne</a> (Invited Expert)
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	https://github.com/w3c/csswg-drafts/blob/main/css-cascade-5/Overview.bs
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-cascade-5

</script>

</head>

<body>

<header>
	<hgroup>
<h1>CSS におけるカスケード法と継承 — CSS Cascading and Inheritance Level 5</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~CSS~moduleは、
~style規則を比較照合する方法, および
すべての要素の すべての~CSS~propに値をどうアテガうか、
について述べる。
値は、
`~cascade法$と`継承$を経ることで，すべての要素の すべての~propに伝播される。
◎
This CSS module describes how to collate style rules and assign values to all properties on all elements. By way of cascading and inheritance, values are propagated for all properties on all elements.
</p>

<p>
この~levelにて新たに定義されるものは、
`~cascade層$である。
◎
New in this level is cascade layers.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、
編集者草案の公な複製です…
【以下、この節の他の内容は，~SOTD-CSSに移譲。】
</p>

<p>
次に挙げる特能は
<a href="~CSScommon#at-risk">~risk下</a>
にあり，勧告候補の~~期間に落とされるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>
<ul>
	<li>
`revert-layer$v ~keyword
◎
the revert-layer keyword
</li>
</ul>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSは、
`~prop@
と呼ばれる，有限個の［
文書の具現化を指図する~parameter
］からなる集合を定義する。
各`~prop$には、
名前
（例： `color$p, `font-size$p, `border-style$p ）,
値~空間
（例： `color$t, `length-percentage$t, <code class="prod">[ solid | dashed | dotted | … ]</code> ）
に加え，当の文書の具現化に対し定義される挙動がある。
~propの値は、
`~prop宣言$を介して，文書の様々な各部にアテガわれる
— それら宣言は、
【選択子などを介して】結付けられた［
要素／~box
］の~propに値
（例： `red^v ／ `12pt^v ／ `dotted^v ）
をアテガう。
◎
CSS defines a finite set of parameters, called properties, that direct the rendering of a document. Each property has a name (e.g., color, font-size, or border-style), a value space (e.g., &lt;color&gt;, &lt;length-percentage&gt;, [ solid | dashed | dotted | … ]), and a defined behavior on the rendering of the document. Properties values are assigned to various parts of the document via property declarations, which assign the property a value (e.g. red, 12pt, dotted) for the associated element or box.
</p>

<p>
~CSSの根幹を成す設計~原則の一つに`~cascade法$
（ ~cascade処理規則, `cascading^en ）
がある。
これにより、
複数の~stylesheetを文書の呈示に波及させれるようになる。
同じ［要素, ~prop］の組合nに対し，複数の`宣言$が与えられている下での値の競合は、
どうにかして解決する必要がある。
◎
One of the fundamental design principles of CSS is cascading, which allows several style sheets to influence the presentation of a document. When different declarations try to set a value for the same element/property combination, the conflicts must somehow be resolved.
</p>

<p>
逆に、［要素, ~prop］の組合nに値を設定する`宣言$が無い場合についても，解決される必要がある。
この場合、
値は，`継承$や~propの`初期~値$を通して見出される。
◎
The opposite problem arises when no declarations try to set a value for an element/property combination. In this case, a value is be found by way of inheritance or by looking at the property’s initial value.
</p>

<p>
`~cascade法$と`~default法$を経ることにより、
入力に与えられた一群の`宣言$から，各~要素の各~prop用の`指定d値$が出力される。
◎
The cascading and defaulting process takes a set of declarations as input, and outputs a specified value for each property on each element.
</p>

<p>
この仕様は、
文書~内の すべての要素の すべての~propに対し，
各自の指定d値を見出すための規則を述べる。
~page文脈および その~margin~boxの下で，
指定d値を見出すための規則は、
`css-page-3$r にて述べられる。
◎
The rules for finding the specified value for all properties on all elements in the document are described in this specification. The rules for finding the specified values in the page context and its margin boxes are described in [css-page-3].
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
`この節は規範的である。^em
◎
This section is normative.
</p>

<p>
この~moduleは、
`CSS2$r § 6 に定義される［
~prop値のアテガわれ方, ~cascade法, 継承
］用の規則を置換して，それらを拡張する。
◎
This module replaces and extends the rules for assigning property values, cascading, and inheritance defined in [CSS2] chapter 6.
</p>

<p>
他の~CSS~moduleは、
ここに定義される構文と特能の一部の定義を拡げるかもしれない。
◎
Other CSS modules may expand the definitions of some of the syntax and features defined here.＼
</p>

<p class="example">
例えば `MEDIAQ$r は、
この~moduleと組合せる下で，この仕様に利用される `media-query$t 値~型の定義を拡げる。
◎
For example, the Media Queries Level 4 specification, when combined with this module, expands the definition of the &lt;media-query&gt; value type as used in this specification.
</p>

<p>
この仕様の目的においては、
`~text~node$は、
それに結付けられている`要素$の子~要素であり，~propたちの全部的な集合を備えているものとする。
~text~nodeは 選択子の対象になれないので、
その算出d値すべては，`~default法$を通してアテガわれる。
◎
For the purpose of this specification, text nodes are treated as element children of their associated element, and possess the full set of properties; since they cannot be targeted by selectors all of their computed values are assigned by defaulting.
</p>

		</section>
	</section>
	<section id="at-import">
<h2 title="Importing Style Sheets: the @import rule">2. ~stylesheetの~import法： `import^at 規則</h2>

<p>
`import@at
規則は、
他の~stylesheetから~style規則を~importする（取り込む）ことを，作者【！利用者】に許容する。
`import$at 規則が妥当な~stylesheetを指しているならば、
~UAは，当の規則が在った所に その内容が記されていたかのように扱うモノトスル
— ただし、
次の 2 つの例外がある：
◎
The @import rule allows users to import style rules from other style sheets. If an @import rule refers to a valid stylesheet, user agents must treat the contents of the stylesheet as if they were written in place of the @import rule, with two exceptions:
</p>
<ul>
	<li>
特定0の~stylesheetに限り適用されるものと明示的に定義された特能
（例：`namespace$at 規則）は、
~importした~stylesheet内で利用されていても，~importされた~stylesheetには適用されないし，その逆も同様になる。
◎
If a feature (such as the @namespace rule) explicitly defines that it only applies to a particular stylesheet, and not any imported ones, then it doesn’t apply to the imported stylesheet.
</li>
	<li>
~stylesheet内の複数の構成子の順序に依拠する特能
（例： “`namespace$at 規則には、 `import$at 以外の規則は先行してはならない” とする要件）
が適用されるのは、
同じ~stylesheet内の構成子どうしに限られる。
◎
If a feature relies on the relative ordering of two or more constructs in a stylesheet (such as the requirement that @namespace rules must not have any other rules other than @import preceding it), it only applies between constructs in the same stylesheet.
</li>
</ul>

<p class="example">
例えば，［
~importされた~stylesheet内の~style規則
］の中の各`宣言$は、
それを~importした~stylesheetの中の `import$at の地点に 当の~style規則がそのまま記されたかのように，~cascadeとヤリトリする。
◎
For example, declarations in style rules from imported stylesheets interact with the cascade as if they were written literally into the stylesheet at the point of the @import.
</p>

<div class="p">
<p>
`import$at 規則 %規則 は、
次の両者を満たす箇所になければナラナイ
— さもなければ， %規則 は無効になる：
</p>
<ul>
	<li>
同じ~stylesheet内で %規則 に先行している他の妥当な［
~at-rule／~style規則
］は、［
`charset$at ／
`一文~構文$による【！empty】 `layer$at 規則
］に限られる。
</li>
	<li>
別の `import$at 規則が先行しているならば、
それと %規則 の合間に他の妥当な［
~at-rule／~style規則
］は無い。
</li>
</ul>
◎
Any @import rules must precede all other valid at-rules and style rules in a style sheet (ignoring @charset and empty @layer definitions) and must not have any other valid at-rules or style rules between it and previous @import rules, or else the @import rule is invalid.＼
</div>

<p>
`import$at の構文は：
◎
The syntax of @import is:
</p>

<pre class="prod">
@import
	[ `url$t | `string$t ]
	[ layer | layer(`layer-name$t) ]?
	`import-condition$t ;

`import-condition@t
	= [ supports( [ `supports-condition$t | `declaration^t ] ) ]?
	  `media-query-list$t? ;
</pre>

<p>
ここで：
◎
where:
</p>
<ul>
	<li>
`url$t ／ `string$t
は、
~importされることになる~stylesheetの~URLを与える。
◎
the &lt;url&gt; or &lt;string&gt; gives the URL of the style sheet to be imported.
</li>
	<li>
<p>
省略可能な［
`layer^v ~keyword／
`layer^f 関数
］は、［
匿名な自前の`~cascade層$／
所与の名前を伴う`~cascade層$
］に~stylesheetの内容をアテガう。
◎
the optional layer keyword or layer() function assigns the contents of the style sheet into its own anonymous cascade layer or into the named cascade layer.
</p>

<p>
この`~cascade層$は、
当の~importが~stylesheetを読込むのに失敗しようが，
<a href="#layer-ordering">層~順序</a>で追加されるが、
`~import条件$の~subjectになる
（適切な`条件付き~group規則$内に包装された `layer$at 規則により宣言されたときと同じく）。
◎
The layer is added to the layer order even if the import fails to load the stylesheet, but is subject to any import conditions (just as if declared by an @layer rule wrapped in the appropriate conditional group rules).
</p>
	</li>
	<li>
`~import条件@
とも称される，省略可能な `import-condition$t は、［
当の~stylesheetが，どのような条件の下で適用されるか
］を言明する。
◎
the optional &lt;import-condition&gt; states the conditions under which it applies.
</li>
</ul>

<div class="example">
<p>
次の
<a href="#conditional-import">条件付き `import^at 規則</a>
は、
~UAが
`display:flex$p
を`~supportする$場合に限り，~stylesheetを読込むことに加え、
<a href="~MQ5#width">表示域~横幅</a>が `400px^v
<a href="~MQ5#mq-min-max">以下</a>の携帯~機器【 `handheld$v 】に限り，~stylesheetを適用する：
◎
The following conditional @import rule only loads the style sheet when the UA supports display: flex, and only applies the style sheet on a handheld device with a maximum viewport width of 400px.
</p>

<pre class="lang-css">
@import url("narrow.css") supports(display: flex) handheld and (max-width: 400px);
</pre>
</div>

<div class="example">
<p>
次の~importは、
 2 つの`~cascade層$
— 順に， `framework.component^v 層, 【！無名】匿名~層 —
の中に~stylesheetを読込む：
◎
The following layer imports load the style sheets into the framework.component layer, and an un-named layer, respectively:
</p>

<pre class="lang-css">
@import url("tabs.css") layer(framework.component);
@import url("override.css") layer();
</pre>
</div>

<p>
`string$t が供されている場合、
それは，同じ引数を伴う 1 個の `url$t として解釈するモノトスル。
◎
If a &lt;string&gt; is provided, it must be interpreted as a &lt;url&gt; with the same value.
</p>

<div class="example">
<p>
次の 2 行（ `url$f によるものと, 文字列そのままのもの）は、
意味的に等価な `import$at 構文になる：
◎
The following lines are equivalent in meaning and illustrate both @import syntaxes (one with url() and one with a bare string):
</p>

<pre class="lang-css">
@import "mystyle.css";
@import url("mystyle.css");
</pre>
</div>

		<section id="conditional-import">
<h3 title="Conditional @import Rules">2.1. 条件付き `import^at 規則</h3>

<p>
`~import条件$は、［
ある媒体／ある特能の~support
］に依存する~importを許容する。
`~import条件$が無い下では，無条件に~importされる
（`~import条件$の `media-query-list$t に値 `all^v を指定しても，同じ効果になる）。
`~import条件$が合致しない場合、
~importされる~stylesheet内の規則は適用されない
— ~importされる~stylesheetが，所与の`媒体~query$を伴う［
`media$at ／ `supports$at
］~blockで括られたときとちょうど同じく。
◎
The import conditions allow the import to be media– or feature-support–dependent. In the absence of any import conditions, the import is unconditional. (Specifying all for the &lt;media-query-list&gt; has the same effect.) If the import conditions do not match, the rules in the imported stylesheet do not apply, exactly as if the imported stylesheet were wrapped in @media and/or @supports blocks with the given conditions.
</p>

<div class="example">
<p>
`import$at 規則を媒体に依存させる例を以下に示す：
◎
The following rules illustrate how @import rules can be made media-dependent:
</p>

<pre class="lang-css">
@import url("fineprint.css") print;
@import url("bluish.css") projection, tv;
@import url("narrow.css") handheld and (max-width: 400px);
</pre>
</div>

<p>
したがって~UAは、
`~import条件$が合致しない条件付き~importについては，~fetchしなくともヨイ。
加えて，~importによる~stylesheetの適用が `supports-condition$t により阻まれる場合、
その~stylesheetは（他の~linkを通して読込まれない限り）~fetchしないモノトスル
— その~import規則に対応する `CSSImportRule.styleSheet^c 値は、
（他の~linkを通して読込まれる場合でも） ~NULL を返すモノトスル。
◎
User agents may therefore avoid fetching a conditional import as long as the import conditions do not match. Additionally, if a &lt;supports-condition&gt; blocks the application of the imported style sheet, the UA must not fetch the style sheet (unless it is loaded through some other link) and must return null for the import rule’s CSSImportRule.styleSheet value (even if it is loaded through some other link).
</p>

<div class="example">
<p>
作者が、
より新しい~UAの~network処理能には影響iしないよう，旧来の~UAに~fallback規則を供する方法を，次の規則に示す：
◎
The following rule illustrates how an author can provide fallback rules for legacy user agents without impacting network performance on newer user agents:
</p>

<pre class="lang-css">
@import url("fallback-layout.css") supports(not (display: flex));
@supports (display: flex) {
  ...
}
</pre>
</div>

<p>
`~import条件$は、
`media-query-list$t で与えられ，
`媒体~query~list$として構文解析され, 解釈される。
`supports-condition$t は、
`[[~supports query]]^en 【`~supports~query$？】として構文解析され, 解釈される。
`supports-condition$t に代えて `declaration^t が与えられた場合、
`supports-decl$t として解釈した上で（すなわち，暗黙の丸括弧が~~追加される）,
`supports-condition$t として扱うモノトスル。
◎
The import conditions are given by &lt;media-query-list&gt;, which is parsed and interpreted as a media query list, and &lt;supports-condition&gt;, is parsed and interpreted as a [[supports query]]. If a &lt;declaration&gt; is given in place of a &lt;supports-condition&gt;, it must be interpreted as a &lt;supports-decl&gt; (i.e. the extra set of parentheses is implied) and treated as a &lt;supports-condition&gt;.
</p>

<div class="example">
<p>
例えば、
次の 2 行は等価になる：
◎
For example, the following two lines are equivalent:
</p>

<pre class="lang-css">
@import "mystyle.css" supports(display: flex);
@import "mystyle.css" supports((display: flex));
</pre>
</div>

<p>
`~import条件$の評価とその全部的な構文は
<a href="~MQ5">Media Queries</a>
`MEDIAQ$r, および
<a href="~CSSCOND">CSS Conditional Rules</a>
`CSS-CONDITIONAL-3$r
にて定義される。
◎
The evaluation and full syntax of the import conditions are defined by the Media Queries [MEDIAQ] and CSS Conditional Rules [CSS-CONDITIONAL-3] specifications.
</p>

		</section>
		<section id="import-processing">
<h3 title="Processing Stylesheet Imports">2.2. ~importによる~stylesheetの処理</h3>

<p>
同じ~stylesheetが文書~内の複数の箇所から~importまたは~linkされている場合、
~UAは，それらの~linkをそれぞれが独立な~stylesheetを指しているかのように処理するモノトスル。
◎
When the same style sheet is imported or linked to a document in multiple places, user agents must process (or act as though they do) each link as though the link were to an independent style sheet.
</p>

<p class="note">注記：
これは、
資源の~fetch法に要件を課すものではない
— ~stylesheetは［
~CSSOMに どう反映されるか／
この仕様も含む各~仕様において どう利用されるか
］に課される要件になる。
複数箇所から~linkされている, あるいは複数回~importされたとしても，適切な~cache法の下で 一度だけ~stylesheetを~fetchすることは、
ごく適切な~UAのふるまいになる。
◎
Note: This does not place any requirements on resource fetching, only how the style sheet is reflected in the CSSOM and used in specs such as this one. Assuming appropriate caching, it is perfectly appropriate for a UA to fetch a style sheet only once, even though it’s linked or imported multiple times.
</p>

<p>
~importされた~stylesheetが属する`出自$は、
それを~importした~stylesheetが属する`出自$と同じになる。
◎
The cascade origin of an imported style sheet is the cascade origin of the style sheet that imported it.
</p>

	<p>
~importされた~stylesheetの`環境~符号化法$は、
それを~importした~stylesheetの符号化法で与えられる。
`css-syntax-3$r
◎
The environment encoding of an imported style sheet is the encoding of the style sheet that imported it. [css-syntax-3]
</p>

		</section>
		<section id="content-type">
<h3 title="Content-Type of CSS Style Sheets">2.3. ~CSS~stylesheetの~Content-Type</h3>

<p>
~host文書 %文書 に~importされる~stylesheetの処理は、
~link先の資源 %資源 の実際の型【 “~MIME型” 】に依存する：
◎
The processing of imported style sheets depends on the actual type of the linked resource:
</p>
<ul>
	<li>
<p>
次のいずれかが満たされるならば、
型は `text/css^c であるものと扱われる：
</p>
		<ul>
			<li>
%資源 には`~Content-Type~metadata$は無い
</li>
			<li>
［
%文書 は`過去互換~mode$下にある
］~AND［
( %文書 の`生成元$doc, %資源 の`~URL$rsの`生成元$url )
は`同一-生成元$である
］
</li>
		</ul>
◎
If the resource does not have Content-Type metadata, the type is treated as text/css.
◎
If the host document is in quirks mode, and the host document’s origin is same origin with the linked resource response’s URL’s origin, the type is treated as text/css.
</li>
	<li>
他の場合、
型は %資源 の`~Content-Type~metadata$により決定される。
◎
Otherwise, the type is determined from its Content-Type metadata.
</li>
</ul>

<p>
%資源 は、
その型に応じて［
`text/css^c ならば ~CSS~stylesheet／
~ELSE_ `~network~error$
］として解釈するモノトスル。
◎
If the linked resource’s type is text/css, it must be interpreted as a CSS style sheet. Otherwise, it must be interpreted as a network error.
</p>

<p class="trans-note">【
参考：上の処理~modelは、
~HTML仕様に定義される~link型 `stylesheet$v のそれに倣うよう定義されている。
】</p>

		</section>
	</section>
	<section id="shorthand">
<h2 title="Shorthand Properties">3. 略式~prop</h2>

<p>
作者が数種の~propの値を単独の~propで一括して指定できるようにするため、
一部の~propは
`略式~prop@
（ `shorthand property^en, または略して `shorthand^en ）
とされている。
`略式~prop$は、
そのすべての非略式
`下位prop@
（ `longhand sub-property^en, または略して［
`longhand^en ／ `sub-property^en
］）
を，その場で展開されたかのように設定する。
◎
Some properties are shorthand properties, meaning that they allow authors to specify the values of several properties with a single property. A shorthand property sets all of its longhand sub-properties, exactly as if expanded in place.
</p>

<p>
`略式~prop$から値が省略されて “消失した” 各`下位prop$には、
他から定義されない限り，その`初期~値$がアテガわれる。
◎
When values are omitted from a shorthand form, unless otherwise defined, each “missing” sub-property is assigned its initial value.
</p>

<div class="note">
<p>注記：
すなわち，`略式~prop$宣言は常に、
その`すべて^emの`下位prop$を設定する
— それらが明示的に設定されなくても。
不注意に`略式~prop$を利用した場合，一部の`下位prop$を不知に設定し直すことになりかねないが、
注意して利用すれば，不知に他の~sourceから~cascadeされた`下位prop$を設定し直して，“白紙状態” に戻すことを保証してくれる。
◎
This means that a shorthand property declaration always sets all of its sub-properties, even those that are not explicitly set. Carelessly used, this might result in inadvertently resetting some sub-properties. Carefully used, a shorthand can guarantee a “blank slate” by resetting sub-properties inadvertently cascaded from other sources.
</p>

<p>
例えば，
`background-color:green$p
ではなく
`background:green$p
と記すことにより、［
それまでのどこかの`宣言$で、
`background-image$p による画像が背景に設定されている
］かもしれないときでも，背景を`色だけ^emにするよう上書きできる†。
◎
For example, writing background: green rather than background-color: green ensures that the background color overrides any earlier declarations that might have set the background to an image with background-image.
</p>

<p class="trans-note">【†
`出現順序$cCにより~sortした結果として，そうなる
— `出自$cCや`詳細度$cCなど，より優先される`~sort判定基準$に基づいて選定される宣言d値まで上書きするわけではない。
】</p>
</div>

<div class="example">
<p>
例えば，CSS Level 1 の `font$p ~propは、
`font-style$p,
`font-variant$p,
`font-weight$p,
`font-size$p,
`line-height$p,
`font-family$p
を一括して設定するための，`略式~prop$である。
したがって，次の様な複数の宣言は：
◎
For example, the CSS Level 1 font property is a shorthand property for setting font-style, font-variant, font-weight, font-size, line-height, and font-family all at once. The multiple declarations of this example:
</p>

<pre class="lang-css">
h1 {
  font-weight: bold;
  font-size: 12pt;
  line-height: 14pt;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
</pre>

<p>
次の様に書き直せる
◎
can therefore be rewritten as
</p>

<pre class="lang-css">
h1 { font: bold 12pt/14pt Helvetica }
</pre>

<p>
`font$p に対する新たな`下位prop$が更に導入されれば、
略式~prop宣言は，それらも その初期~値に設定し直すことになる。
◎
As more font sub-properties are introduced into CSS, the shorthand declaration resets those to their initial values as well.
</p>
</div>

<p class="trans-note">【
次の様な場合もあることに注意：
`border-width$p のような~propは、
略式~prop
`border$p の下位propであると同時に，下位propに［
`border-top-width$p, `border-left-width$p, … 等々
］を持つ略式~propでもある。
この様な場合の `border$p の “下位prop” は、
連鎖的に辿った末端の下位propを指しているように見受けられる
— が、
この場合の “中間” の~prop
（この例では `border-width$p 等々）が，
下位propに［含まれる／含まれない］のどちらに定義されているのかは、
はっきりしない
【！展開については、末端のもののみに限定され， “中間” のものは除外されると推定されるが】
— どちらに解釈したとしても，~cascadeに現れる結果は変わらないと見受けられるので
<small>
（末端の下位propに限定する必要がある所では，その旨を付記した方が誤解は少ないであろう）
</small>。
あるいは、
そうなることを利用して，意図的に曖昧に定義されているように思われる。
実際、
何が［
略式~prop／下位prop
］と見なされるかは，実装にも依存する —
仕様が拡張されて、
それまでは末端の~propであったものが，より細分化された下位propを持つ様になることもあるので
（例： `overflow$p ~propに対する `overflow-x$p, `overflow-y$p ）。

】</p>

<p>
一部の`略式~prop$は、
その`下位prop$の値に直には対応しないような，異なる構文や特別な~keywordを持ち得る
（そのような`略式~prop$は，その値の展開を明示的に定義することになる）。
◎
In some cases, a shorthand might have different syntax or special keywords that don’t directly correspond to values of its sub-properties. (In such cases, the shorthand will explicitly define the expansion of its values.)
</p>

<p>
また、
略式~propにおいて
`設定し直すのみ@
になる`下位prop$もある：
それは、
他の`下位prop$と同様に，略式~propの中で未指定な値を初期~値に設定し直すが、
それ以外の値に設定する構文が，略式~propに備わっていないものである【 `~CSS全域~keyword$は別として】。
例えば， `border$p 略式~propは、
`border-image$p をその初期~値 `none^v に設定し直すが，それ以外の値に設定する構文を備えていない。
`css-backgrounds-3$r
◎
In other cases, a property might be a reset-only sub-property of the shorthand: Like other sub-properties, it is reset to its initial value by the shorthand when unspecified, but the shorthand might not include syntax to set the sub-property to any of its other values. For example, the border shorthand resets border-image to its initial value of none, but has no syntax to set it to anything else. [css-backgrounds-3]
</p>

<p>
`略式~prop$が いずれかの`~CSS全域~keyword$ `css-values-3$r として指定されている場合、
そのすべての`下位prop$は，`設定し直すのみ$のものも含め，その~keywordに設定される。
（これらの~keywordは、
略式~propに限らず，単独の`宣言$の中で他の値と組合できないことに注意。）
◎
If a shorthand is specified as one of the CSS-wide keywords [css-values-3], it sets all of its sub-properties to that keyword, including any that are reset-only sub-properties. (Note that these keywords cannot be combined with other values in a single declaration, not even in a shorthand.)
</p>

<p>
`略式~prop$を `!important$css を伴わせて宣言することは、
そのすべての`下位prop$を `!important$css を伴わせて宣言することに等価になる。
◎
Declaring a shorthand property to be !important is equivalent to declaring all of its sub-properties to be !important.
</p>

		<section id="aliasing">
<h3 title="Property Aliasing">3.1. ~propの別名化</h3>

<p>
~propの名前は、
変更されることもある
— ~vendor接頭辞~付き~propなど，しばらくの間 ~supportされた後に標準~化されるときなど。
互換性の理由から，元の名前も依然として~supportされる必要があるが、
新たな名前が選好される。
これを成遂げるため、
~CSSでは，旧い構文を新たな構文の “別名にする” 2 つの仕方を定義する：
◎
Properties sometimes change names after being supported for a while, such as vendor-prefixed properties being standardized. The original name still needs to be supported for compatibility reasons, but the new name is preferred. To accomplish this, CSS defines two different ways of “aliasing” old syntax to new syntax.
</p>

<dl class="def-list">
	<dt>
`旧来の別名n@
（ `legacy name alias^en ）
◎
legacy name aliases
</dt>
	<dd>
旧い~prop用の値の構文が，新たな~prop用のそれと一致する場合、
旧い~prop名は新たな~propの別名にされる
— 構文解析-時点で，文字大小~対応付け演算の下で新たな~prop名に変換することにより。
この変換は、
~CSSOMにおいても［
文字列~引数／~prop~accessor
］に適用される
— 旧い~prop名~向けの要請は、
透過的に新たな~prop名に転送される。
◎
When the old property’s value syntax is identical to that of the new property, the two names are aliased with an operation on par with case-mapping: at parse time, the old property is converted into the new property. This conversion also applies in the CSSOM, both for string arguments and property accessors: requests for the old property name transparently transfer to the new property name instead.
</dd>
	<dd class="example">
例えば `old-name^p は `new-name^p 用の`旧来の別名n$である場合、
<code>getComputedStyle(%el).oldName</code>
は `newName^c ~propに算出される~styleを返すことになり，
<code>el.style.setPropertyValue(`old-name^l, `value^l)</code>
は `new-name^p ~propを `value^l に設定することになる。
◎
For example, if old-name is a legacy name alias for new-name, getComputedStyle(el).oldName will return the computed style of the newName property, and el.style.setPropertyValue("old-name", "value") will set the new-name property to "value".
</dd>

	<dt>
`旧来の略式~prop@
（ `legacy shorthand^en ）
◎
legacy shorthands
</dt>
	<dd>
旧い~propの構文が新たな~propの構文とは別個なものである場合、
旧い~prop名は，`略式~prop$の仕組みを利用して 新たな~prop名の別名にされる。
旧い~propは、
【新たな~propを下位propとする】
`旧来の略式~prop$であるものと定義され，その利用は`非推奨に^emされる。
それ以外の点では、
定例の略式と正確に同じに挙動する
— ~CSSOMにより宣言が直列化されるときには，旧い名前を利用しないこと除いて。
`CSSOM$r
◎
When the old property has a distinct syntax from the new property, the two names are aliased using the shorthand mechanism. These shorthands are defined to be legacy shorthands, and their use is deprecated. They otherwise behave exactly as regular shorthands, except that the CSSOM will not use them when serializing declarations. [CSSOM]
</dd>
	<dd class="example">
<p>
例えば， `page-break-*^p ~propは、
`break-*^p ~prop用の`旧来の略式~prop$である
（ `css-break-3$r <a href="~CSSBREAK#page-break-properties">§ ~page分断~propの別名</a>を見よ）。
◎
For example, the page-break-* properties are legacy shorthands for the break-* properties (see CSS Fragmentation 3 § 3.4 Page Break Aliases: the page-break-before, page-break-after, and page-break-inside properties).
</p>

<p>
`page-break-before$p が `always^v に設定された場合、
他の略式が行う様に構文解析-時点で `break-before$p に展開される。
同様に， `break-before^p が `page^v に設定された場合、
<code>getComputedStyle(%el).pageBreakBefore</code>
を~callしたときには `always^l を返すことになる。
しかしながら，
~style~blockを直列化するとき
（~CSSOM <a href="~CSSOM1#serializing-css-values">§ ~CSS値の直列化-法</a>を見よ）
には、［
`page-break-before^p, `break-before^p
］のどちらが指定されようが，直列化する略式として `page-break-before^p ~propが選ばれることは決してなく、
常に `break-before^p が選ばれることになる。
◎
Setting page-break-before: always expands to break-before: page at parse time, like other shorthands do. Similarly, if break-before: page is set, calling getComputedStyle(el).pageBreakBefore will return "always". However, when serializing a style block (see CSSOM 1 § 6.7.2 Serializing CSS Values), the page-break-before property will never be chosen as the shorthand to serialize to, regardless of whether it or break-before was specified; instead, break-before will always be chosen.
</p>
	</dd>
</dl>

		</section>
		<section id="all-shorthand">
<h3 title="Resetting All Properties: the all property">3.2. すべての~propを設定し直す： `all^p ~prop</h3>

◎名 `all@p
◎値 `initial$v | `inherit$v | `unset$v | `revert$v | `revert-layer$v
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎ア 個々の~propを見よ
◎順 文法に従う
◎表終

<p>
`all$p ~propは、［
`direction$p, `unicode-bidi$p
］を除く，`すべての~CSS~prop^emを設定し直す`略式~prop$である。
`~CSS全域~keyword$のみが，その値として受容される。
また、
`~custom~prop$ `css-variables-1$r は設定し直さない。
◎
The all property is a shorthand that resets all CSS properties except direction and unicode-bidi. It only accepts the CSS-wide keywords. It does not reset custom properties [css-variables-1].
</p>

<p class="note">
除かれた［
`direction$p, `unicode-bidi$p
］~propは、
実際には~markup~levelの特能であり，
<a href="~CSSWM#text-direction">作者~stylesheetには設定されるべきでない</a>
（それらは、
~UAが~supportしていない文書~言語を~styleするための~CSS~propとしてのみ存在する）
`css-writing-modes-3$r
。
作者は、
~HTMLの `dir$a 属性などの，適切な~markupを代わりに利用するべきである。
◎
Note: The excepted CSS properties direction and unicode-bidi are actually markup-level features, and should not be set in the author’s style sheet. (They exist as CSS properties only to style document languages not supported by the UA.) Authors should use the appropriate markup, such as HTML’s dir attribute, instead. [css-writing-modes-3]
</p>

<div class="example">
<p>
例えば，要素~上に
`all:initial$p
が指定された場合、
すべての継承は阻まれる
— その要素の すべての~propは、［
作者, 利用者, UA
］~levelの~cascadeの中に規則が一つも現れなかったかのように，設定し直されることになる。
◎
For example, if an author specifies all: initial on an element, it will block all inheritance and reset all properties, as if no rules appeared in the author, user, or user-agent levels of the cascade.
</p>

<p>
これは、［
ある~page内に含められる “~widget” の根~要素が，外から~styleを継承しないことが望まれる
］ときに有用になり得る。
ただし、
その要素に適用される “既定の” ~styleも
（例：~UA~stylesheetが `div^e などの塊~要素にあてがう `display:block$p など），
吹飛ばされることに注意。
◎
This can be useful for the root element of a "widget" included in a page, which does not wish to inherit the styles of the outer page. Note, however, that any "default" style applied to that element (such as, e.g. display: block from the UA style sheet on block elements such as &lt;div&gt;) will also be blown away.
</p>
</div>

		</section>
	</section>
	<section id="value-stages">
<h2 title="Value Processing">4. 値の処理</h2>

<p>
~UAは，文書を構文解析して文書~treeを構築し終えたならば、
~tree内のどの要素にも，および 対応する整形~構造の中のどの~boxにも，［
その~propのうち，~~目的の媒体~型に適用されるものすべて
］に対し値をアテガうモノトスル。
◎
Once a user agent has parsed a document and constructed a document tree, it must assign, to every element in the tree, and correspondingly to every box in the formatting structure, a value to every property that applies to the target media type.
</p>

<p>
所与の［
要素／~box
］の~CSS~propの最終的な値は、
次のような複数の段階を経て計算される：
◎
The final value of a CSS property for a given element or box is the result of a multi-step calculation:
</p>
<ol>
	<li>
すべての`宣言d値$
— 要素に`適用される宣言$たちの値 —
を収集する。
どの要素にも，`宣言d値$は~propごとに
0 個以上いくつでもあり得る。
◎
First, all the declared values applied to an element are collected, for each property on each element. There may be zero or many declared values applied to the element.
</li>
	<li>
`~cascade法$により，`~cascaded値$を得る。
どの要素にも，`~cascaded値$は~propごとに
0 個または 1 個だけある。
◎
Cascading yields the cascaded value. There is at most one cascaded value per property per element.
</li>
	<li>
`~default法$により，`指定d値$を得る。
どの要素にも，`指定d値$は~propごとに 1 個だけある。
◎
Defaulting yields the specified value. Every element has exactly one specified value per property.
</li>
	<li>
値の依存性を解決して，`算出d値$を得る†。
どの要素にも，`算出d値$は~propごとに 1 個だけある。
【† 百分率~値など — 結果は［他の要素の~prop／同じ要素の他の~prop］の値に依存し得る。】
◎
Resolving value dependencies yields the computed value. Every element has exactly one computed value per property.
</li>
	<li>
文書の整形【~layoutなど】を経ることで，`使用~値$を得る。
要素の~propに`使用~値$があるのは、
要素に~propが`適用され$る場合に限られる。
◎
Formatting the document yields the used value. An element only has a used value for a given property if that property applies to the element.
</li>
	<li>
最後に，`使用~値$は、
表示~環境による拘束に基づいて，`実際の値$に変形される。
`使用~値$と同じく、
`実際の値$があるのは，要素に~propが`適用され$る場合に限られる。
◎
Finally, the used value is transformed to the actual value based on constraints of the display environment. As with the used value, there may or may not be an actual value for a given property on an element.
</li>
</ol>

<p>
~CSS値の処理に関与する要素は、
文書に`接続されて$いて，文書の`平坦~化された要素~tree$の一部を成すものに限られる。
他の要素には、
~style`宣言$が（例えば`~style属性$により）アテガわれたとしても，［
`宣言d値$,
`~cascaded値$,
`指定d値$,
`算出d値$,
`使用~値$,
`実際の値$
］は無い。
◎
Elements that are not connected or are not part of the document’s flattened element tree do not participate in CSS value processing, and do not have declared, cascaded, specified, computed, used, or actual values, even if they potentially have style declarations assigned to them (for example, by a style attribute).
</p>

		<section id="declared">
<h3 title="Declared Values">4.1. 宣言d値</h3>

<p>
所与の［
要素, ~prop
］に対し、
各`~prop宣言$のうち要素に`適用される宣言$が，要素の~prop用の
`宣言d値@
（ `declared value^en ）を供与する。
詳細は、
<a href="#filtering">§ 宣言の絞込み</a>
を見よ。
◎
Each property declaration applied to an element contributes a declared value for that property associated with the element. See Filtering Declarations for details.
</p>

<p>
これらの値から、
`~cascade$による処理を経て，
1 個の “最優先な値” が~~選定される。
◎
These values are then processed by the cascade to choose a single “winning value”.
</p>

			<section id="value-aliasing">
<h4 title="Value Aliasing">4.1.1. 値の別名化</h4>

<p>
一部の~prop値は、
`旧来の別名~値@
とされる。
そのような旧来の構文は，構文解析-時点で新たな構文に変換され、
`宣言d値$は，構文解析される入力と異なる結果になる。
これらの別名は、
概して，旧来の互換性~要件を取扱うために利用される
— <a href="~CSSSNAPSHOT#vendor-prefix">~vendor接頭辞~付き</a>の値を 等価な標準な値へ変換するときなど。
◎
Some property values have legacy value aliases: at parse time, the legacy syntax is converted into the new syntax, resulting in a declared value different from the parsed input. These aliases are typically used for handling legacy compatibility requirements, such as converting vendor-prefixed values to their standard equivalents.
</p>

			</section>
		</section>
		<section id="cascaded">
<h3 title="Cascaded Values">4.2. ~cascaded値</h3>

<p>
`~cascaded値@
（ `cascaded value^en ）は、
`~cascade$の結果を表現する。
それは、
一群の`宣言d値$から，~cascadeを経て（`~cascadeの出力$の中で~sortされて）~~選定された値である。
`~cascadeの出力$が空になる場合、
`~cascaded値$は無い。
◎
The cascaded value represents the result of the cascade: it is the declared value that wins the cascade (is sorted first in the output of the cascade). If the output of the cascade is an empty list, there is no cascaded value.
</p>

<p class="trans-note">【
`~cascaded値$の概念には，その値を与えた “最優先な” 宣言も暗黙的に含まれ、
<a href="#revert">§ ~cascade出自の巻戻し</a>
など，この仕様の他所から参照される。
】</p>

		</section>
		<section id="specified">
<h3 title="Specified Values">4.3. 指定d値</h3>

<p>
`指定d値@
（ `specified value^en ）は、
~stylesheet作者が要素の~propに意図した値である。
多くの事例では，`~cascaded値$が`指定d値$になるが、
`~cascaded値$が無い場合は，`~default法$を通して`指定d値$が~~導出される
— これにより、
どの要素のどの~propにも，`指定d値$の存在が保証される。
~propの`~cascaded値$が`~CSS全域~keyword$である場合、
特別に取扱われ，`指定d値$を その~keywordから要求される値に設定する。
<a href="#defaulting-keywords">§ 明示的な~default法</a>
を見よ。
◎
The specified value is the value of a given property that the style sheet authors intended for that element. It is the result of putting the cascaded value through the defaulting processes, guaranteeing that a specified value exists for every property on every element.
◎
In many cases, the specified value is the cascaded value. However, if there is no cascaded value at all, the specified value is defaulted. The CSS-wide keywords are handled specially when they are the cascaded value of a property, setting the specified value as required by that keyword, see § 7.3 Explicit Defaulting.
</p>

		</section>
		<section id="computed">
<h3 title="Computed Values">4.4. 算出d値</h3>

<p>
`算出d値@
（ `computed value^en ）とは、
`指定d値$を，~prop定義表の “算出d値” 欄に従って解決した結果である。
一般に，指定d値は`継承$による伝播の際に絶対~化される。
◎
The computed value is the result of resolving the specified value as defined in the “Computed Value” line of the property definition table, generally absolutizing it in preparation for inheritance.
</p>

<p class="trans-note">【
各種~CSS仕様において、
単に
“%foo ~propの値”
と記されたときは，およそ，算出d値を指し
（ “〜に算出される” という句も同様）、
“%foo ~propに`指定された^em値”
と記されたときは，およそ，指定d値を指すと見受けられる。
しかしながら、
どちらを指すかは文脈に応じて判断する必要もあるかもしれない。
あるいは、
どちらに解釈しようが結果は同じになる場合も，単に “~propの値” と記されることもあろう。
】</p>

<p class="note">注記：
`継承$において親から子へ転送される値は、
`指定d値$ではなく`算出d値$である。
歴史的な理由から、
`getComputedStyle()$c 関数 `CSSOM$r
は，`算出d値$を返すとは限らず，`使用~値$を返すこともある
【この関数が返す値は`解決d値$と呼ばれる】
。
`算出d値$は，抽象的な~data表現であり、
その定義は，~data表現を反映する
— ~dataがどう直列化されるかではなく。
例えば、
直列化の規則には［
構文解析の間に黙示された，ある種の値
］を［
結果からは省略することを許容しているもの
］が多いが、
そのような値であっても`算出d値$の一部を成す。
◎
Note: The computed value is the value that is transferred from parent to child during inheritance. For historical reasons, it is not necessarily the value returned by the getComputedStyle() function, which sometimes returns used values. [CSSOM] Furthermore, the computed value is an abstract data representation: their definitions reflect that data representation, not how that data is serialized. For example, serialization rules often allow omitting certain values which are implied during parsing; but those values are nonetheless part of the computed value.
</p>

<div class="example">
<p>
`指定d値$は、
絶対的な値
（すなわち、
`red^v や `2mm^v など，別の値に相対的でない値），
相対的な値
（すなわち、
`auto^v や `2em^v など，別の値に相対的な値）
どちらもとり得る。
一般に、
相対的な値から算出d値を得るときは，絶対~化される：
◎
A specified value can be either absolute (i.e., not relative to another value, as in red or 2mm) or relative (i.e., relative to another value, as in auto, 2em). Computing a relative value generally absolutizes it:
</p>
<ul>
	<li>
相対~単位
（ `em$u, `ex$u, `vh$u, `vw$u ）
を伴う値は、
適切な基準~sizeを乗算して絶対~化するモノトスル。
◎
values with relative units (em, ex, vh, vw) must be made absolute by multiplying with the appropriate reference size
</li>
	<li>
一定の~keyword
（例： `smaller^v, `bolder^v ）
は、
それらの定義に則って置換するモノトスル。
◎
certain keywords (e.g., smaller, bolder) must be replaced according to their definitions
</li>
	<li>
一部の~propに対する百分率~値は、
（~propにて定義される）基準~値と乗算するモノトスル。
◎
percentages on some properties must be multiplied by a reference value (defined by the property)
</li>
	<li>
妥当な相対~URLは、
絶対~URLに解決するモノトスル。
◎
valid relative URLs must be resolved to become absolute.
</li>
</ul>

<p>
<a href="#stages-examples">下の表</a>の
例 (f), (g), (h) を見よ。
◎
See examples (f), (g) and (h) in the table below.
</p>
</div>

<div class="note">
<p>注記：
一般に，`指定d値$を解決して`算出d値$を得るときは、
文書の~layoutや，他の［
重い／並列化し難い
］演算
— ~network要請を解決したり，要素やその親 以外から値を検索取得するなど —
は、
アリな限り~~避けられている。
◎
Note: In general, the computed value resolves the specified value as far as possible without laying out the document or performing other expensive or hard-to-parallelize operations, such as resolving network requests or retrieving values other than from the element and its parent.
</p>

<p class="trans-note">【
言い換えれば，算出d値は、
概ね，~stylesheet, 文書~tree, その他の確定的な情報のみから決定でき，
（~layout開始時には未知な）他の要因からは左右されない値を表す。
】【
参考：
~CSSによる~animationや遷移における値の補間は、
<a href="~CSSVAL#combining-values">算出d値に基づいて行われる</a>。
】</p>
</div>

<p>
`算出d値$は、
要素に~propが`適用され$ないとしても，存在する。
しかしながら、
要素に`適用され$るかどうかに応じて，`算出d値$の決定-法が変化する~propもある。
◎
The computed value exists even when the property does not apply. However, some properties may change how they determine the computed value based on whether the property applies to the element.
</p>

		</section>
		<section id="used">
<h3 title="Used Values">4.5. 使用~値</h3>

<p>
`使用~値@
（ `used value^en ）は、
`算出d値$を［
文書の整形に利用される絶対的な理論的な値
］に仕上げる計算を完了した結果である。
◎
The used value is the result of taking the computed value and completing any remaining calculations to make it the absolute theoretical value used in the formatting of the document.
</p>

<p class="trans-note">【
他の各種~CSS仕様によく現れる， “使用〜（ `used^en 〜）” のような句も、
同様の概念を表すと見受けられる。
<small>
（<a href="index.html#spec-list-css">この~siteの各~CSS仕様の日本語訳</a>に現れる語 “使用” は、
~~原則的に，この意味と考えられる `used^en の対訳に限って利用している。
他の `used^en には、
別の対訳（ “利用される” など）が利用されるが、
中には，この意味の “使用” を指すものもあるかもしれない。
）
</small>
】</p>

<p class="example">
例えば，宣言
`width:auto$p
は、
要素の先祖の~layoutを知ることなしには，長さに解決し得ない。
したがって`使用~値$は `100px^v のような絶対的な長さになる一方で，`算出d値$は `auto^v になる。
`CSS2$r
◎
For example, a declaration of width: auto can’t be resolved into a length without knowing the layout of the element’s ancestors, so the computed value is auto, while the used value is an absolute length, such as 100px. [CSS2]
</p>

<p class="example">
別の例として，
`div^e は `break-before$p の算出d値に `auto^v をとり得るが、
その使用~値
`page^v
を，その最初の子からの伝播を通して獲得する。
`css-break-3$r
◎
As another example, a &lt;div&gt; might have a computed break-before value of auto, but acquire a used break-before value of page by propagation from its first child. [css-break-3]
</p>

<p>
~propの`使用~値$は、
それが`適用され$ない型の［
要素／~box
］においては無い。
◎
If a property does not apply to this element or box type then it has no used value for that property.
</p>

<p class="example">
例えば， `flex$p ~propの`使用~値$は、
`~flex駒$でない要素には無い。
◎
For example, the flex property has no used value on elements that aren’t flex items.
</p>

			<section id="applies-to">
<h4 title="Applicable Properties">4.5.1. 適用-可能な~prop</h4>

<p>
~propは、
その適用-対象
— その定義表の “適用対象” 欄に挙げられている型の［
要素／~box
］† —
に限り，
`適用され@
る
— 他の［
要素／~box
］に対し，直に効果を及ぼすことはない。
◎
If a property does not apply to an element or box type—as noted in its “Applies to” line—this means it does not directly take effect on that type of box or element.
</p>

<p class="note">注記：
~propが`適用され$ないとしても、
`間接的^emな整形~効果はあり得る
— その`算出d値$が，他の`適用され$る~propの算出に影響する場合には。
また，当然ながら、
（常に存在する）算出d値のうち継承されるものは，子孫に効果を及ぼし得る。
◎
Note: A property that does not apply can still have indirect formatting effects if its computed value affects the computation of other properties that do apply; and of course its computed value, which always exists, can still inherit to descendants and take effect on them.
</p>

<p class="trans-note">【†
適用-対象に要素~型が挙げられる事例は、
ごく限られる（~SVG仕様など）。
それは、
実際には要素が生成する~boxを意味する
（例えば， `display:none$p にされた要素には、
ほとんどの~propは適用されない）。
】【†
適用-対象には、
要素や~boxの他にも，
“~text” が挙げられることもある。
それは、［
~propは、
要素の内容を成す`~text連なり$に継承され，効果を発揮する
］ことを意味する
（したがって，`継承d~prop$に限られる）
— 例えば、
要素は~boxは生成しないが，その内容は具現化される事例
（要素の `display$p が `contents^v の場合）
でも。
（ “~text” は、
以前は，概して`行内~box$として挙げられていたが、
そのような事例に~~適応するために導入された
— <a href="~CSSissue/5303">課題 #5303</a>
に論点がある。）
】</p>

<div class="example">
<p>
［
`writing-mode$p ／ `text-orientation$p
］~propは，~table~rowには`適用され$ないが
（すなわち、
~table~rowや その子がどう~lay-outされるかには影響しない）、
それらを そのような~boxに設定した場合，
`ch$u などの~fontに相対的な単位の計算には依然として影響する
— したがって、
他の~propのうち `length$t を値にとるものにも，場合によっては影響する。
◎
Even though writing-mode and text-orientation do not apply to table rows (they do not affect how the table row or its children are laid out), setting them on such boxes will still affect the calculation of font relative units such as ch, and thus possibly any property that takes a &lt;length&gt;.
</p>
</div>

<div class="example">
<p>
`text-transform$p は，`行内~box$にしか`適用され$ないが†、
それを~HTML `p$e 要素（既定では `display:block$p ）に設定すれば，効果を及ぼすことになる
— ~propは、
段落の匿名な`根~行内~box$へ継承され，それが包含する~textには適用されるので。
【最新の仕様では、 “~text” に`適用され$るものと定義されている。】
◎
Setting text-transform on an HTML p element (which is display: block by default) will have an effect, even though text-transform only applies to inline boxes, because the property inherits into the paragraph’s anonymous root inline box and applies to the text it contains.
</p>
</div>

<p class="note">注記：
“すべての要素”
に`適用され$るものと定義された~propは、
すべての［
要素~型／`表示~型$
］に`適用され$るが，どの型の`疑似要素$にも`適用され$るとは限らない
— 疑似要素には、
自前の［
特有な具現化~modelや他の制約
］があるものが多いので。
しかしながら，［
`before$pe ／ `after$pe
］疑似要素は、
通常の要素と ほぼ違わない~boxを生成するものと定義されるので，
“すべての要素” に`適用され$る~propを どれも受容するものと定義される。
`疑似要素$についての更なる情報は `CSS-PSEUDO-4$r を見よ。
【他の疑似要素に対しては、一般に，個々の疑似要素の定義にて，`適用され$る~propの~listが指定される。】
◎
Note: A property defined to apply to “all elements” applies to all elements and display types, but not necessarily to all pseudo-element types, since pseudo-elements often have their own specific rendering models or other restrictions. The ::before and ::after pseudo-elements, however, are defined to generate boxes almost exactly like normal elements and are therefore defined accept all properties that apply to “all elements”. See [CSS-PSEUDO-4] for more information about pseudo-elements.
</p>

			</section>
		</section>
		<section id="actual">
<h3 title="Actual Values">4.6. 実際の値</h3>

<p>
`使用~値$は、
原則として，【具現化-用に】利用する準備が整った値であるが、
所与の環境においては直に用立てれないこともある。
例えば~UAは，整数幅の画素境界にしか描画できないかもしれず、
その場合，`使用~値$による幅を近似する必要も生じ得る。
あるいは，要素の~font~sizeは、
~fontの可用性や
`font-size-adjust$p ~prop値に基づいて，調整を要する。
`実際の値@
（ `actual value^en ）とは、
使用~値に そのような調整を施した後の値である。
◎
A used value is in principle ready to be used, but a user agent may not be able to make use of the value in a given environment. For example, a user agent may only be able to render borders with integer pixel widths and may therefore have to approximate the used width. Also, the font size of an element may need adjustment based on the availability of fonts or the value of the font-size-adjust property. The actual value is the used value after any such adjustments have been made.
</p>

<p class="trans-note">【
`実際の値$は、
概念的には，~CSSが定義する~modelからは決定し得ない外部の要因も織り込んだ結果と捉えられる。
そのため、
この用語が他の~CSS仕様に現れることは，ほとんどない
— ~CSSからは、
具体的な要件として定義し得ないので
（実際の値に基づくような挙動は別として）。
】</p>

<p class="note">注記：
要素の実際の値を調べれば、
文書の~layoutについて多くを知れる。
しかしながら、
すべての情報が実際の値に記録されるわけではない。
例えば， `page-break-after$p ~propの実際の値は、
要素の後に~page分断があるかどうかを反映しない。
同様に， `orphans$p の実際の値は、
要素の中の実際の orphan 行数を反映しない。
<a href="#stages-examples">下の表</a>の例 (j), (k) を見よ。
◎
Note: By probing the actual values of elements, much can be learned about how the document is laid out. However, not all information is recorded in the actual values. For example, the actual value of the page-break-after property does not reflect whether there is a page break or not after the element. Similarly, the actual value of orphans does not reflect how many orphan lines there is in a certain element. See examples (j) and (k) in the table below.
</p>

		</section>
		<section id="stages-examples">
<h3 title="Examples">4.7. 例</h3>

<div style="overflow:auto;">
<table id="_samples_matrix" class="grid-table">
<caption>
~CSS値の算出の例
— 指定d値~列の “†” は初期~値
◎
Examples of CSS Value Computation
</caption>

<thead><tr><th>
<th style="min-width:12em;">~prop
<th><span >~~選定された宣言</span>
<th>~cascaded値
<th>指定d値
<th>算出d値
<th>使用~値
<th>実際の値
</thead>

<!-- 
Property
Winning declaration
Cascaded value
Specified value
Computed value
Used value
Actual value
-->

<tbody><tr><td>(a)
<th>`text-align$p
<td>`text-align:left^p
<td>`left^v
<td>`left^v
<td>`left^v
<td>`left^v
<td>`left^v

<tr><td>(b)
<th>
`border-top-width$p ／
`border-right-width$p ／
`border-bottom-width$p ／
`border-left-width$p
<td>`border-width:inherit^p
<td>`inherit$v
<td>`4.2px^v
<td>`4.2px^v
<td>`4.2px^v
<td>`4px^v

<tr><td>(c)
<th>`width$p
<td><small title="(none)">(なし)</small>
<td><small title="(none)">(なし)</small>
<td>`auto^v†
<td>`auto^v
<td>`120px^v
<td>`120px^v

<tr><td>(d)
<th>`list-style-position$p
<td>`list-style-position:inherit^p
<td>`inherit$v
<td>`inside^v
<td>`inside^v
<td>`inside^v
<td>`inside^v

<tr><td>(e)
<th>`list-style-position$p
<td>`list-style-position:initial^p
<td>`initial$v
<td>`outside^v†
<td>`outside^v
<td>`outside^v
<td>`outside^v

<tr><td>(f)
<th>`font-size$p
<td>`font-size:1.2em^p
<td>`1.2em^v
<td>`1.2em^v
<td>`14.1px^v
<td>`14.1px^v
<td>`14px^v

<tr><td>(g)
<th>`width$p
<td>`width:80%^p
<td>`80%^v
<td>`80%^v
<td>`80%^v
<td>`354.2px^v
<td>`354px^v

<tr><td>(h)
<th>`width$p
<td>`width:auto^p
<td>`auto^v
<td>`auto^v
<td>`auto^v
<td>`134px^v
<td>`134px^v

<tr><td>(i)
<th>`height$p
<td>`height:auto^p
<td>`auto^v
<td>`auto^v
<td>`auto^v
<td>`176px^v
<td>`176px^v

<tr><td>(j)
<th>`page-break-after$p
<td><small>(なし)</small>
<td><small>(なし)</small>
<td>`auto^v†
<td>`auto^v
<td>`auto^v
<td>`auto^v

<tr><td>(k)
<th>`orphans$p
<td>`orphans:3^p
<td>`3^v
<td>`3^v
<td>`3^v
<td>`3^v
<td>`3^v
</tbody></table></div>

		</section>
		<section id="fragments">
<h3 title="Per-Fragment Value Processing">4.8. 断片ごとの値の処理</h3>

<p>
ある種の~CSS特能は、
値の処理に対し，断片ごとに基づくように干渉し得る。
例えば、
`CSS-PSEUDO-4$r
<a href="~CSSPSEUDO#first-line-inheritance">§ 継承と `first-line^pe 疑似要素</a>
を見よ
— それは、
 `first-line$pe 疑似要素の中の断片~用に継承を改める。
そのような事例において，個々の断片に異なる`指定d値$が与えられた所では、
`算出d値$に基づいて解決される他の~propの値（ `currentcolor$v や `em$u 単位など）は，
`~box断片$ごとに解決される。
値に対する後続の処理は、
各~断片に対し，通常通り続行される。
◎
Certain CSS features can interfere with value processing on a per-fragment basis. See for example CSS Pseudo-Elements 4 § 2.1.3 Inheritance and the ::first-line Pseudo-element which alters inheritance for fragments within the ::first-line pseudo-element. In such cases, where individual fragments are given different specified values, any values that resolve based on the computed value of other properties (such as currentcolor or em units) are resolved per box fragment. Subsequent value processing proceeds as normal in each fragment.
</p>

<p>
~APIのうち，値は（`~box断片$ごとではなく）`~box$ごとに一つしかないと見做すものは、
`~treeに留まる疑似要素$以外の`疑似要素$による効果を無視するモノトスル
（例えば， `first-line$pe による~styleには、
`getComputedStyle()$c が返す値に対する効果は無い）。
◎
APIs that assume a singular value per box (rather than per box fragment) must ignore the effects of non-tree-abiding pseudo-elements. (For example, ::first-line styles have no effect on the value returned by getComputedStyle().)
</p>

<div class="example">
<p>
例えば，次の~markupが与えられたとき：
◎
For example, given the following markup:
</p>

<pre class="lang-css">
&lt;div&gt;&lt;span&gt;一行目&lt;br /&gt;二行目&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;一行目&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;一行目&lt;br&gt;&lt;span&gt;二行目&lt;/span&gt;&lt;/div&gt;
&lt;style&gt;
div { color: blue; }
div::first-line { color: yellow; }
span { border: thin solid currentcolor; }
&lt;/style&gt;
</pre>

<p>
各 `div$e 内の~text［
“一行目” ／ “二行目”
］の色は［
`yellow^v ／ `blue^v
］になり、
`span$e を成す各~行lを包装する各~断片~用の~borderの色は，当の断片の色に合致する。
◎
In each div, the “First line” text is yellow and the “Second line” text is blue; the border for each fragment of the spans that wrap each line matches that color.
</p>

<p>
しかしながら，
`getComputedStyle()$c は、
3 個の `span^e どれに対しても，
`border-color$p 用には `blue^l を返すことになる
— 断片を自覚しない~APIにおいては、
`first-line$pe 疑似要素による効果は無視されるので。
◎
However, getComputedStyle() on all three of the spans will return "blue" for border-color, because the effects of a ::first-line pseudo-element are ignored for APIs that aren’t fragment-aware.
</p>
</div>

		</section>
	</section>
	<section id="filtering">
<h2 title="Filtering">5. 絞込み</h2>

<p>
`宣言d値$を見出すためには、
実装はまず，各~要素ごとに要素に`適用される宣言$すべてを識別するモノトスル。
次【のすべて】を満たす`宣言$が，要素に
`適用される宣言@
とされる
【`~prop^emが要素に “`適用され$る” こととは、意味が異なることに注意】
：
◎
In order to find the declared values, implementations must first identify all declarations that apply to each element. A declaration applies to an element if:
</p>
<ul>
	<li>
当の文書に現在 適用されている~stylesheetに属する。
◎
It belongs to a style sheet that currently applies to this document.
</li>
	<li>
`偽^i に評価される`条件付き~group規則$ `CSS-CONDITIONAL-3$r により~~除外されていない。
◎
It is not qualified by a conditional rule [CSS-CONDITIONAL-3] with a false condition.
</li>
	<li>
それが属する~style規則の`選択子$は、
要素に合致している
（必要とされるなら，<a href="~SELECTORS4#scoping">視野~法</a>も織り込んで）。
`SELECT$r
◎
It belongs to a style rule whose selector matches the element. [SELECT] (Taking scoping into account, if necessary.)
</li>
	<li>
構文として妥当である
— すなわち，宣言の~propは既知な~prop名であり, かつ 宣言の値は その~propの構文に合致している。
◎
It is syntactically valid: the declaration’s property is a known property name, and the declaration’s value matches the syntax for that property.
</li>
</ul>

<p>
これらの適用される`宣言$の値が、
各~要素の各~prop用の`宣言d値$の~listを成す。
この~list内のどれが選ばれるかは、
次節の`~cascade法$にて与えられる。
◎
The values of the declarations that apply form, for each property on each element, a list of declared values. The next section, the cascade, prioritizes these lists.
</p>

	</section>
	<section id="cascading">
<h2 title="Cascading">6. ~cascade法</h2>

<p>
`~cascade@
（~cascade~~処理）は、［
所与の要素の所与の~prop用の`宣言d値$たちが成す，無順序~list
］から、
以下に従って決定される優先順位により，それらの`宣言$を~sortした上で、
【その中で最も優先される】単独の`~cascaded値$を出力する。
◎
The cascade takes an unordered list of declared values for a given property on a given element, sorts them by their declaration’s precedence as determined below, and outputs a single cascaded value.
</p>

		<section id="cascade-sort">
<h3 title="Cascade Sorting Order">6.1. ~cascadeの~sort順序</h3>

<p>
~cascadeにおいては、
`宣言$たちは，以下の判定基準に則って~sortされる
— 先に挙げるものほど，後続の判定基準より優先される：
◎
The cascade sorts declarations according to the following criteria, in descending order of precedence:
</p>

<dl class="def-list">
	<dt>
`出自と重要度@cC
（ `origin^en と `importance^en ）
◎
Origin and Importance
</dt>
	<dd>
<p>
`宣言$が属する`出自$は、
~~字義通りの~~意味に基づく。
宣言が`~importantな宣言$になるかどうかは、
`!important$css を伴って宣言されているかどうかに基づく。
各種`出自$【と`~important$が成す組】の優先順位は、
高いものから順に，次で与えられる：
◎
The origin of a declaration is based on where it comes from and its importance is whether or not it is declared with !important (see below). The precedence of the various origins is, in descending order:
</p>
		<ol>
			<li>
遷移~宣言 `css-transitions-1$r
◎
Transition declarations [css-transitions-1]
</li>
			<li>
`~UA出自$に属する`~importantな宣言$
◎
Important user agent declarations
</li>
			<li>
`利用者~出自$に属する`~importantな宣言$
◎
Important user declarations
</li>
			<li>
`作者~出自$に属する`~importantな宣言$
◎
Important author declarations
</li>
			<li>
~animation宣言 `css-animations-1$r
◎
Animation declarations [css-animations-1]
</li>
			<li>
`作者~出自$に属する`通常の宣言$
◎
Normal author declarations
</li>
			<li>
`利用者~出自$に属する`通常の宣言$
◎
Normal user declarations
</li>
			<li>
`~UA出自$に属する`通常の宣言$
◎
Normal user agent declarations
</li>
		</ol>

<p>
上の~listの中で，より先に挙げた`出自$に属する宣言が より後に挙げた`出自$に属する宣言よりも優先される。
◎
Declarations from origins earlier in this list win over declarations from later origins.
</p>

<p class="trans-note">【
~importantの有無により，［
作者／利用者／~UA
］宣言の優先順位は逆になる。
】</p>

	</dd>

	<dt>
`文脈@cC
（ `context^en ）
◎
Context
</dt>
	<dd>
文書~言語は、
相異なる
`~encapsulation文脈@
を源とする`宣言$たちを混ぜ合わせる~~仕組みを供することもある
— ~DOM【！`DOM$r】内の`~shadow~tree$を成す入子な`~tree文脈$など。
◎
A document language can provide for blending declarations sourced from different encapsulation contexts, such as the nested tree contexts of shadow trees in the [DOM].
</dd>
	<dd>
<p>
異なる`~encapsulation文脈$ %A, %B を源とする宣言どうしを比較する場合、
%A が %B を入子にしているならば
⇒＃
`通常の宣言$どうしでは， %A を源とする宣言が優先される／
`~importantな宣言$どうしでは， %B を源とする宣言が優先される
◎
When comparing two declarations that are sourced from different encapsulation contexts, then for normal rules the declaration from the outer context wins, and for important rules the declaration from the inner context wins.＼
</p>

<p class="trans-note">【
間接的に入子にしている場合、
推移的に定義されることになる。
】【
“源とする” とは，具体的には、
当の宣言は［
その文脈から~linkされた／その文脈に埋込まれた
］~stylesheet内にある
（あるいは、
その文脈~内の ある要素の`~style属性$内にある）
ことを意味する。
】</p>

<p>
この目的においては、
~DOMを成す`~tree文脈$は，`~shadowも含む~tree順序$で入子にされるものと見なされる。
◎
For this purpose, [DOM] tree contexts are considered to be nested in shadow-including tree order.
</p>

<p class="note">注記：
このことは、
実質的に，次を意味する
⇒
`~encapsulation文脈$に属する宣言のうち
⇒＃
`通常の宣言$は，外縁~文脈（ %A ）から容易に上書きできる既定を設定できる／
`~importantな宣言$は，外縁~文脈からは上書きし得ない要件を施行できる
◎
Note: This effectively means that normal declarations belonging to an encapsulation context can set defaults that are easily overridden by the outer context, while important declarations belonging to an encapsulation context can enforce requirements that cannot be overridden by the outer context.
</p>
	</dd>

	<dt>
`要素に付された~style@cC
（ `element attached styles^en ）
◎
Element-Attached Styles
</dt>
	<dd>
要素に直に付された`宣言$
（<a href="~CSSSTYLEATTR#interpret">~style属性の内容</a>など）
は、
他の宣言
— `選択子$を介して要素に対応付けられる~style規則に属する宣言 —
のうち［
同じ`重要度$cC（`通常の宣言$／`~importantな宣言$）を伴うもの
］より優先される。
`css-style-attr$r を見よ。
◎
Separately for normal and important declarations, declarations that are attached directly to an element (such as the contents of a style attribute) rather than indirectly mapped by means of a style rule selector take precedence over declarations the same importance that are mapped via style rule.
◎
See [css-style-attr].
</dd>
	<dd class="note">注記：
非~CSS呈示~用~hint（呈示~用~markupなど）は、
別々に取扱われる
— <a href="#preshint">§ 非~CSS呈示~用~hint</a>を見よ。
◎
Note: Non-CSS presentational hints (such as presentational markup) are handled separately, see § 6.5 Precedence of Non-CSS Presentational Hints.
</dd>

	<dt>
`層@cC
（ `layer^en ）
◎
Layers
</dt>
	<dd>
各［
`出自$cC／`文脈$cC
］の中の`宣言$は、
ある`~cascade層$に明示的にアテガうこともできる。
この段の目的においては、
`未層@
（ `un-layered^en ／ `unlayered^en ）な宣言
— 明示的な`~cascade層$にアテガわれていない宣言 —
は、
暗黙的な最終-層に追加される。
◎
Declarations within each origin and context can be explicitly assigned to a cascade layer. For the purpose of this step, any declaration not assigned to an explicit layer is added to an implicit final layer.
</dd>
	<dd>
~cascade層は、
（宣言と同様に）出現順序により~sortされる
— <a href="#layer-ordering">§ 層の順序-法</a>を見よ。
異なる`~cascade層$に属する宣言どうしを比較するときは
⇒＃
`通常の宣言$どうしでは，より後の層に属する方が優先される／
`~importantな宣言$どうしでは，より前の層に属する方が優先される
【`通常の宣言$と`~importantな宣言$の比較は、`重要度$cCに従う。】
◎
Cascade layers (like declarations) are sorted by order of appearance, see § 6.4.3 Layer Ordering. When comparing declarations that belong to different layers, then for normal rules the declaration whose cascade layer is latest in the layer order wins, and for important rules the declaration whose cascade layer is earliest wins.
</dd>
	<dd class="note">注記：
これは、［
`通常の宣言$, `~importantな宣言$
］の優先順位と同じ~logicに従う
— したがって、
どちらの設定に対しても，
`!important$css ~flagは同じ “上書き” の目的を保守する。
◎
Note: This follows the same logic used for precedence of normal and important origins, thus the !important flag maintains the same “override” purpose in both settings.
</dd>

	<dt>
`詳細度@cC
（ `specificity^en ）
◎
Specificity
</dt>
	<dd>
各`宣言$は、
それが現れる~style規則の`選択子$と同じ詳細度を有する。
選択子の`詳細度$を算出する方法は、
`SELECT$r にて述べられる。
詳細度が高いものほど優先される。
◎
The Selectors module [SELECT] describes how to compute the specificity of a selector. Each declaration has the same specificity as the style rule it appears in. The declaration with the highest specificity wins.
</dd>

	<dt>
`出現順序@cC
（ `order of appearance^en ）
◎
Order of Appearance
</dt>
	<dd>
<p>
文書~順序
【~stylesheet内に現れる順序】
において より後に現れる`宣言$ほど優先される。
この目的においては：
◎
The last declaration in document order wins. For this purpose:
</p>
		<ul>
			<li>
~stylesheetたちは、
`最終-~CSS~stylesheet~list$と同じに順序付けられる。
◎
Style sheets are ordered as in final CSS style sheets.
</li>
			<li>
`import$at 規則で~importされた~stylesheet内の宣言は、
その規則が その~stylesheetで代用されたかのように，順序付けられる。
◎
Declarations from imported style sheets are ordered as if their style sheets were substituted in place of the @import rule.
</li>
			<li>
大元の文書から独立に~linkされた複数の~stylesheet内の宣言は、
それらの~stylesheetが，~host文書~言語により決定される~link順で連結されたかのように扱われる。
◎
Declarations from style sheets independently linked by the originating document are treated as if they were concatenated in linking order, as determined by the host document language.
</li>
			<li>
`~style属性$ `CSS-STYLE-ATTR$r 内の宣言は、
その属性が現れた要素たちの文書~順序に則って順序付けられ，どの~stylesheetよりも後に配置される。
◎
Declarations from style attributes are ordered according to the document order of the element the style attribute appears on, and are all placed after any style sheets. [!CSSSTYLEATTR]
</li>
		</ul>
	</dd>
</dl>

<p>
`~cascadeの出力@
は、
各~要素の各~prop用のすべての`宣言d値$を，この節に述べた規則に従って~sortした~listである
（空にもなり得る）。
◎
The output of the cascade is a (potentially empty) sorted list of declared values for each property on each element.
</p>

		</section>
		<section id="cascading-origins">
<h3 title="Cascading Origins">6.2. ~cascade法における出自</h3>

<p>
各~style規則には、
`出自@
（ `cascade origin^en ）がある
— それは、
規則が~cascadeのどの段階に入るかを決定する。
~CSSは、
中核的な`出自$として，次の 3 種を定義する：
◎
Each style rule has a cascade origin, which determines where it enters the cascade. CSS defines three core origins:
</p>

<dl class="def-list">
	<dt>
`作者~出自@
（ `author origin^en ）
◎
Author Origin
</dt>
	<dd>
文書~言語の規約に則って，~source文書~用に作者が指定する~stylesheet。
例えば~HTMLでは，文書~内に含められたり, 外部へ~linkされ得る。
◎
The author specifies style sheets for a source document according to the conventions of the document language. For instance, in HTML, style sheets may be included in the document or linked externally.
</dd>

	<dt>
`利用者~出自@
（ `user origin^en ）
◎
User Origin
</dt>
	<dd>
利用者は、
特定0の文書~用に，~style情報を指定することもある。
例えば，利用者が~stylesheetを包含する~fileを指定することもあれば、
~UAが利用者~stylesheet（あるいはそのように挙動するもの）を生成する~UIを供することもある。
◎
The user may be able to specify style information for a particular document. For example, the user may specify a file that contains a style sheet or the user agent may provide an interface that generates a user style sheet (or behaves as if it did).
</dd>

	<dt>
`~UA出自@
（ `user agent origin^en ）
◎
User-Agent Origin
</dt>
	<dd>
適合~UAは、
既定の~stylesheet（あるいはそのように挙動するもの）を適用するモノトスル。
~UAの既定の~stylesheetは、
文書~言語の要素を，文書~言語にて一般に期待されている呈示を満たす仕方で呈示するべきである
（例：視覚系~browserは、
~HTMLの `em^e 要素を~italic~fontで呈示するなど）
— 例：
<a href="~HTMLrendering#the-css-user-agent-style-sheet-and-presentational-hints">~HTMLの~UA~stylesheet</a>
`HTML$r。
◎
Conforming user agents must apply a default style sheet (or behave as if they did). A user agent’s default style sheet should present the elements of the document language in ways that satisfy general presentation expectations for the document language (e.g., for visual browsers, the EM element in HTML is presented using an italic font). See e.g. the HTML user agent style sheet. [HTML]
</dd>
</dl>

<p class="trans-note">【
この仕様も含む~CSS仕様 全般にわたり、
この出自を指して，
“〜`~levelの^em~style” と記されたり，（
“作者`~levelの^em…” , “~UA`~levelの^em…”
等々），更に省略して
“利用者~style”,
等々と記されることが多い。
】</p>

<p>
~CSSに対する拡張は、
次に挙げる追加的な`出自$も定義する：
◎
Extensions to CSS define the following additional origins:
</p>

<dl class="def-list">
	<dt>
`~animation出自@
（ `animation origin^en ）
◎
Animation Origin
</dt>
	<dd>
CSS Animations `css-animations-1$r
は、
その効果を稼働中に表現する， “~virtualな” 規則を生成する。
◎
CSS Animations [css-animations-1] generate “virtual” rules representing their effects when running.
</dd>

	<dt>
`遷移~出自@
（ `transition origin^en ）
◎
Transition Origin
</dt>
	<dd>
CSS Transitions `css-transitions-1$r
も、
その効果を稼働中に表現する， “~virtualな” 規則を生成する。
◎
Like CSS Animations, CSS Transitions [css-transitions-1] generate “virtual” rules representing their effects when running.
</dd>
</dl>

		</section>
		<section id="importance">
<h3 title="Important Declarations: the !important annotation">6.3. ~important宣言： `!important^css</h3>

<p>
~CSSでは、
作者~stylesheetと利用者~stylesheetの力関係も~~考慮されている。
既定では、
作者~stylesheet内の規則が利用者~stylesheet内のそれを上書きし，利用者~stylesheet内の規則が~UAの既定の~stylesheet内の規則を上書きする。
`宣言$を`~importantな宣言$にして~cascadeにおける重みを増やすことにより，この優先順位を逆にできる。
◎
CSS attempts to create a balance of power between author and user style sheets. By default, rules in an author’s style sheet override those in a user’s style sheet, which override those in the user-agent’s default style sheet. To balance this, a declaration can be marked important, which increases its weight in the cascade and inverts the order of precedence.
</p>

<p>
各`宣言$のうち，次に該当するものは、
`~importantな宣言@
（ “重要な宣言” ）とされ，他のすべては
`通常の宣言@
とされる
⇒
`css-syntax-3$r にて定義されるとおりに `!important^css 注釈を伴う
— すなわち、
その値【 `declaration-value$t 】を成す最後の 2 個の（空白でも~commentでもない）~tokenは，順に次で与えられている
⇒＃
区切子~token【`delim-token$t】 `!^l,
識別子~token【`ident-token$t】 `important^l
◎
A declaration is important if it has a !important annotation as defined by [css-syntax-3], i.e. if the last two (non-whitespace, non-comment) tokens in its value are the delimiter token ! followed by the identifier token important. All other declarations are normal (non-important).
</p>

<div class="example">
<pre class="lang-css">
[hidden] { display: none !important; }
</pre>
</div>

<p>
`~importantな宣言$は、
`通常の宣言$より優先される。
［
作者~stylesheet／利用者~stylesheet
］は`~importantな宣言$を包含してもヨイ。
`利用者~出自$に属する`~importantな宣言$は、
`作者~出自$に属する`~importantな宣言$を上書きする。
この~CSS特能は、
呈示に対する制御を［
特別な要件（大きな~font, 色の組合n, 等々）がある利用者
］に与えることで，文書の~accessibilityを改善する。
◎
An important declaration takes precedence over a normal declaration. Author and user style sheets may contain important declarations, with user-origin important declarations overriding author-origin important declarations. This CSS feature improves accessibility of documents by giving users with special requirements (large fonts, color combinations, etc.) control over presentation.
</p>

<p>
`~importantな宣言$は、
その`出自$に関わらず，どの~animationよりも優先される。
これにより、
作者は，重要な事例で~animateされた値を上書きできるようになる
（~animateされた値は、
通常は，他のすべての規則を上書きする）。
`css-animations-1$r
◎
Important declarations from all origins take precedence over animations. This allows authors to override animated values in important cases. (Animated values normally override all other rules.) [css-animations-1]
</p>

<p>
`~UA~stylesheet$も，`~importantな宣言$を包含してヨイ。
これらは、
他のすべての［
`作者~出自$／`利用者~出自$
］に属する宣言を上書きする。
◎
User-agent style sheets may also contain important declarations. These override all author and user declarations.
</p>

<div class="example">
<p>
次の例の 利用者~stylesheet内の 1 個目の規則が包含する宣言は、
`!important^css を伴うので，作者~stylesheetの対応する宣言を上書きする。
2 個目の規則についても `!important^css を伴うので同様に優先されることになる。
しかしながら，利用者~stylesheet内の 3 個目の宣言には `!important^css は無いので、
作者~stylesheetの中の（`略式~prop$の~styleを設定する） 2 個目の規則の方が優先されることになる。
また、
 3 個目の作者~規則より `!important^css を伴う 2 個目の作者~規則の方が優先されることになる。
すなわち， `!important^css を伴う宣言は、
同じ作者~stylesheetの中でも機能する。
◎
The first rule in the user’s style sheet in the following example contains an !important declaration, which overrides the corresponding declaration in the author’s style sheet. The declaration in the second rule will also win due to being marked !important. However, the third declaration in the user’s style sheet is not !important and will therefore lose to the second rule in the author’s style sheet (which happens to set style on a shorthand property). Also, the third author rule will lose to the second author rule since the second declaration is !important. This shows that !important declarations have a function also within author style sheets.
</p>

<pre class="lang-css">
/* <span class="comment">
利用者による~stylesheet
◎
From the user’s style sheet
</span> */
p { text-indent: 1em !important }
p { font-style: italic !important }
p { font-size: 18pt }

/* <span class="comment">
作者による~stylesheet
◎
From the author’s style sheet
</span> */
p { text-indent: 1.5em !important }
p { font: normal 12pt sans-serif !important }
p { font-size: 24pt }
</pre>

<table><thead><tr><th>
~prop
◎
Property
<th>最優先な値
◎
Winning value
</thead><tbody>

<tr><th>`text-indent$p
<td>`1em^v

<tr><th>`font-style$p
<td>`italic^v

<tr><th>`font-size$p
<td>`12pt^v

<tr><th>`font-family$p
<td>`sans-serif^v
</tbody></table>
</div>

		</section>
		<section id="layering">
<h3 title="Cascade Layers">6.4. ~cascade層</h3>

<p>
`出自$が作者~styleと利用者~styleの間に力関係を供するのと同じ仕方で、
`~cascade層@
は，同じ`出自$の中での力関係を組織化する有構造な仕方を供する。
単独の`~cascade層$の中の規則たちは、
一緒に~cascadeする
— 層の外側にある~style規則は、
そこに差挟まれないよう。
◎
In the same way that cascade origins provide a balance of power between user and author styles, cascade layers provide a structured way to organize and balance concerns within a single origin. Rules within a single cascade layer cascade together, without interleaving with style rules outside the layer.
</p>

<p>
作者は、~style付けの懸念になる様々なもの
— 要素~用の既定の~style, 第三者-主体による~library, ~theme, ~component, 上書き, その他 —
に対し，それぞれを表現する~cascade層を作成して、
それらを明示的な仕方で順序し直せる
— 各~層にまたがる競合を解決するために、
各~層の中の選択子や`詳細度$cCを改めることも，`出現順序$cCに依拠することもなく。
◎
Authors can create layers to represent element defaults, third-party libraries, themes, components, overrides, and other styling concerns—and are able to re-order the cascade of layers in an explicit way, without altering selectors or specificity within each layer, or relying on order of appearance to resolve conflicts across layers.
</p>

<div class="example">
<p>
例えば次は、
明示的な `reset^v 層を生成する
— その~cascadeにおける優先順位は、
`未層$な~styleよりも低い：
◎
For example, the following generates an explicit reset layer, with lower cascade precedence than any unlayered styles:
</p>

<pre class="lang-css">
audio {
  /* <span class="comment">
暗黙的な最終-層
— 詳細度 ( 0,0,1 )
◎
specificity of 0,0,1 - implicit (final) layer
</span> */
  display: flex;
}

@layer reset {
  audio[controls] {
    /* <span class="comment">
明示的な `reset^v 層
— 詳細度 ( 0,1,1 )
◎
specificity of 0,1,1 - explicit "reset" layer
</span> */
    display: block;
  }
}
</pre>

<p>
`audio$e 要素に対する`未層$な宣言は、
`audio[controls]^css に対する明示的に層~化された宣言より優先される
— 前者の方が詳細度が低くても，`出現順序$cCで最初に来ていても。
◎
The unlayered declarations on the audio element take precedence over the explicitly layered declarations on audio[controls]—even though the unlayered styles have a lower specificity, and come first in the order of appearance.
</p>
</div>

<p>
名前を定義している`~at-rule$
— `keyframes$at や `font-face$at など —
が`~cascade層$の内側で定義された場合も、
名前の衝突を解決するときに層~順序を利用する。
◎
Name-defining at-rules such as @keyframes or @font-face that are defined inside cascade layers also use the layer order when resolving name collisions.
</p>

<div class="example">
<p>
例えば，作者は、
ある~frameworkからの~animationを上書きすることもできる
— より優先順位が高い層~内に同じ名前を伴う~keyframe群を供することにより：
◎
For example, authors could override the animation from a framework, by providing keyframes with the same name in a higher-precedence layer:
</p>

<pre class="lang-css">
/* <span class="comment">
次の規則が層~順序を確立するので、
`override^v 層が優先される。
◎
establish the layer order, so the "override" layer takes precedence
</span> */
@layer framework, override;

@layer override {
  @keyframes slide-left {
    from { translate: 0; }
    to { translate: -100% 0; }
  }
}

@layer framework {
  @keyframes slide-left {
    from { margin-left: 0; }
    to { margin-left: -100%; }
  }
}

.sidebar { animation: slide-left 300ms; }
</pre>

<p>
この事例では，
`framework^v 層より `override^v 層の方が~cascadeにおける優先順位が高いので、
`slide-left^v は， `translate^p ~propを利用して~animateすることになる
— `margin-left^p ではなく。
◎
In this case the override layer has a higher cascade precedence than the framework layer, so slide-left will animate using the translate property rather than margin-left.
</p>
</div>

			<section id="layer-declaration">
<h4 title="Declaring Cascade Layers">6.4.1. ~cascade層の宣言-法</h4>

<p>
~cascade層は、
次のいずれかを利用して宣言できる：
◎
Cascade layers can be declared:
</p>
<ul>
	<li>
<p>
［
`layer^v ~keyword ／ `layer^f 関数
］を伴う `import$at 規則
⇒
これは、［
~importされた~fileの内容
］を［
当の宣言が参照rする層
］の中へアテガう。
</p>
<p class="trans-note">【
これらは、
 “層~化された~import（ `layered import^en ）” とも称される
】</p>
◎
using an @import rule with the layer keyword or layer() function, assigning the contents of the imported file into that layer.
</li>
	<li>
`~block構文$による `layer$at 規則
⇒
これは、［
その子~style規則（~block内で宣言された規則）たち
］を［
当の宣言が参照rする層
］の中へアテガう。
◎
using a @layer block at-rule, assigning its child style rules into that layer.
</li>
	<li>
`一文~構文$による `layer$at 規則
⇒
これは、
規則をアテガうことなく，有名~層を宣言する。
◎
using a @layer statement at-rule, declaring a named layer without assigning any rules.
</li>
</ul>

<p class="trans-note">【
これらの規則は、
層~規則（ `layer rule^en ）と総称される。
】</p>

<p class="issue">
［
`link$e ／ `style$e
］要素を`~cascade層$にアテガうための属性を供するか？
[`5853$issue]
◎
Provide an attribute for assigning link or style elements to cascade layers? [Issue #w3c/csswg-drafts#5853]
</p>

			</section>
			<section id="layer-names">
<h4 title="Layer Naming and Nesting">6.4.2. 層の命名と入子ng</h4>

<p>
各`~cascade層$には、
【それを一意に識別する】
`名前@ly
がある
— それは， 1 個以上の［
入子ngを成す各~levelの層を表現する区分（ `segment^en ）
］からなる~listである：
◎
A cascade layer has a layer name, which is an ordered list representing each level of layer nesting,＼
</p>
<ul>
	<li>
各~区分は、
（`~CSS識別子$として）命名される【有名~層に対応する】か,
匿名である【匿名~層に対応する】
◎
each segment of which can be named (as a CSS identifier) or anonymous.＼
</li>
	<li>
区分たちの順序は、
入子にされた順序を表現する
（したがって，ある層が別の層の内側に入子にされるとき、
これは，それらの名前
【それらを宣言した層~規則が供した区分】
を連結したものになる。）
◎
(Thus, when a layer is nested inside of another layer, this concatenates their names.)＼
</li>
</ul>
<p>
入子にされた層とは、
別の層の視野の中で宣言されたものである
— 具体的には
⇒＃
`~block構文$による `layer$at 規則の内側にある `layer$at 規則 ／
層~化された `import$at 規則で~importされる~stylesheet内にある【！の内側にある】層~規則
◎
One layer is nested in another when it is declared within the scope of another layer, e.g. an @layer rule inside another @layer, a layered @import inside a layered import, or an @layer rule inside a layered import.
</p>

<p>
2 つの`名前$lyは、
同じ順序で同じ区分を包含するならば，同じ`~cascade層$を表現する。
しかしながら，匿名な区分は、
各【宣言の】出現ごとに一意になる。
匿名な区分であっても、
中に入子にされた層たちからは共有されることに注意。
◎
Layer names represent the same cascade layer if they contain the same segments in the same order; however anonymous segments have unique identities for each occurrence. Note that nesting can cause multiple layers to share the same anonymous segment.
</p>

<div class="example">
<p>
明示的な層~識別子は、
同じ`~cascade層$に複数の~style~blockをアテガう仕方を供する。
次の例では、［
`headings.css^v,
`links.css^v
］の内容は，
`audio[controls]^css 規則と同じ層の中で一緒に~cascadeされる：
◎
Explicit layer identifiers provide a way to assign multiple style blocks to a single layer. In the following example, the contents of headings.css and links.css are cascaded within the same layer as the audio[controls] rule:
</p>

<pre class="lang-css">
@import url(headings.css) layer(default);
@import url(links.css) layer(default);

@layer default {
  audio[controls] {
    display: block;
  }
}
</pre>
</div>

<div class="example">
<p>
次の例において `framework^v 内に入子にされた `framework.base^v 層は、
~top-levelの `base^v 層とは別個になる：
◎
In this example, the nested framework.base layer is distinct from the top-level base layer:
</p>

<pre class="lang-css">
@layer base {
  p { max-width: 70ch; }
}

@layer framework {
  @layer base {
    p { margin-block: 0.75em; }
  }

  @layer theme {
    p { color: #222; }
  }
}
</pre>

<p>
結果の各~層は、
~treeとして表現できる：
◎
The resulting layers can be represented as a tree:
</p>

<ol>
	<li>`base^v
	<li>`framework^v
		<ol>
			<li>`base^v
			<li>`theme^v
		</ol>
	</li>
</ol>

<p>
あるいは、
入子な識別子【たちが成す`名前$ly】を伴う平坦な~listとして：
◎
or as a flat list with nested identifiers:
</p>
<ol>
	<li>`base^v
	<li>`framework.base^v
	<li>`framework.theme^v
</ol>
</div>

<p>
明示的な`名前$lyは、
構文上は，［
`layer$at ／ `import$at
］規則~内の `layer-name$t により表現される
— それは、
1 個以上の `ident$t ~tokenからなる~listであり，空白を挟まずに~periodで分離されて連結される：
◎
Syntactically, an explicit layer name is represented by the &lt;layer-name&gt; in @layer and @import rules, which is a period-separated list of &lt;ident&gt; tokens with no intervening white space:
</p>

<pre class="prod">
`layer-name@t = `ident$t [ '.' `ident$t ]*
</pre>

<p>
`layer-name$t 内の `ident$t として`~CSS全域~keyword$が利用された場合、
当の規則は構文解析-時点で無効になる
— それらは、
将来の利用-用に予約される。
複数個の識別子が~periodで連結されているときは、
その順序で入子にされた層を表現するための略式になる。
◎
The CSS-wide keywords are reserved for future use, and cause the rule to be invalid at parse time if used as an &lt;ident&gt; in the &lt;layer-name&gt;. When multiple identifiers are concatenated with a period, this is a shorthand representing those layers nested in order.
</p>

<div class="example">
<pre class="lang-css">
@layer framework {
  @layer default {
     p { margin-block: 0.75em; }
  }

  @layer theme {
    p { color: #222; }
  }
}

@layer framework.theme {
  /* <span class="comment">
ここに置かれた~styleは、
`framework^v 層の内側にある `theme^v 層に追加されることになる。
◎
These styles will be added to the theme layer inside the framework layer
</span> */
  blockquote { color: rebeccapurple; }
}
</pre>
</div>

<p class="note">注記：
入子な層は、
その親~層から “逃れる” ことはできない
— すなわち、
入子な層の内側から，外側にある層を参照することはできない。
◎
Note: A nested layer cannot “escape” its parent layer to reference layers outside itself.
</p>

<div class="example">
<p>
もう少し複階的な例
【この例は、この訳による追加。】
</p>

<pre class="lang-css">
@layer X /* <span class="comment">
この規則が宣言する層の`名前$lyは `X^v （以下同様）
</span> */ {
  @layer Y /* `X.Y^v */
}

@layer A /* `A^v */ {
  @layer A /* `A.A^v */ {
    @layer B /* `A.A.B^v */ {
      ...
    }
  }

  @layer B /* `A.B^v */ { ... }

  @layer A.B /* <span class="comment">
`A.B^v ではなく `A.A.B^v
</span> */ { ... }

  @layer X.Y /* <span class="comment">
`X.Y^v ではなく `A.X.Y^v
（層 `A^v の中から外側にある層 `X^v や `X^v の中の層を参照rすることはできない）
</span> */ { ... }
}

@layer A.B /* <span class="comment">
~top-levelにあるので、
そのまま `A.B^v
</span> */
</pre>

<p class="trans-note">【†
上の例で、
層 `A.X.Y^v は，層 `A.X^v の存在を含意するが，そのような層は宣言されていない
— この場合、
同じ箇所の直前に暗黙的に そのような層が宣言されていると見做されるのか？
】</p>
</div>

				<section id="unnamed-layers">
<h5 title="Anonymous Layers">6.4.2.1. 匿名な層</h5>

<div class="p">
<p>
次のいずれかに該当する層~規則は、
それが宣言する`~cascade層$†の`名前$lyに，一意かつ匿名な区分を供する
— したがって，当の層は、
外側からは参照し得なくなる：
</p>
<ul>
	<li>
`layer-name$t が省略された `layer$at 規則
</li>
	<li>
`layer^v ~keyword（それは `layer-name$t を供さない）を利用している `import$at 規則
</li>
</ul>

<p class="trans-note">【†
そのような`~cascade層$
— すなわち、
その`名前$lyを成す最後の区分は匿名である~cascade層 —
も、
単に “匿名~層（ `anonymous layer^en ）” と称される。
原文では、
 “無名~層（ `unnamed layer^en ）” と称されている箇所もあるが、
意味は同じなので，この訳では一律に “匿名” で記すことにする。
】</p>

◎
When a @layer rule omits its &lt;layer-name&gt;, or an @import rule uses the layer keyword (which does not provide a &lt;layer-name&gt;), its layer name gains a unique anonymous segment; it therefore cannot be referenced from the outside.
</div>

<div class="example">
<p>
匿名な層~宣言は、
各~出現ごとに一意な`~cascade層$を表現する。
したがって：
◎
Each occurrence of an anonymous layer declaration represents a unique cascade layer, thus:
</p>
<ul>
	<li>
<p>
各~匿名な層~規則は、
各自の~styleを別々な【！無名】匿名~層の中へあてがう
— 各 出現は、
別個な匿名な名前で参照しているので。
◎
Multiple unnamed layer rules place their styles into separate layers, as each occurrence is referencing a distinct anonymous layer name.
</p>

<pre class="lang-css">
@layer { /* <span class="comment">層 1</span> */ }
@layer { /* <span class="comment">層 2</span> */ }
</pre>
</li>
	<li>
<p>
同じ【！無名】匿名~層の中では、
同じ名前を伴う各~子~層は，同じ~cascade層を参照rする
— それらは同じ匿名な親~層を共有するので。
◎
Within a single unnamed layer, child layers with the same name refer to the same cascade layer, because they share the same anonymous parent layer.
</p>

<pre class="lang-css">
@layer {
  @layer foo { /* <span class="comment">層 1</span> */ }
  @layer foo { /* <span class="comment">これも層 1</span> */ }
}
</pre>
</li>
	<li>
<p>
一方で、
同じ区分~名を伴う子~層であっても，別々な【！無名】匿名~層に属するものどうしは、
異なる`~cascade層$を参照rする
— 親である それら匿名~層は、
互いに別個なので。
◎
Whereas in separate unnamed layers, child layers with the same name refer to different cascade layers, because they have distinct anonymous parent layers.
</p>

<pre class="lang-css">
@layer {
  @layer foo { /* <span class="comment">層 1</span> */ }
}
@layer {
  @layer foo { /* <span class="comment">層 2</span> */ }
}
</pre>
	</li>
</ul>
</div>

<div class="example">
<p>
`layer-name$t を伴わずに宣言された層は、
外部から~styleを［
配列し直す／追加する
］ための~hookを供さない。
◎
A layer declared without a &lt;layer-name&gt; does not provide any external hook for re-arranging or adding styles.
</p>

<p>
これは、
~~簡潔に記すための便利~用でしかないこともあるが，
例えば次に利用することもできる：
◎
While this can be a mere convenience for brevity, it can also be used＼
</p>
<ul>
	<li>
ある~teamにおいて、
~codeを組織化する規約を強制する仕方として
（例：当の層に属するすべての~codeは、
一箇所で定義しなければならない）
◎
by teams as a way to force an organizing convention (all code in that layer must be defined in the same place),＼
</li>
	<li>
ある~libraryが一群の “~privateな” 層
— 作者からの操作~用には公開したくないと求める，内部的な層 —
を併合して隠したいと求めるとき
◎
or by libraries wanting to merge &amp; hide a set of internal “private” layers that they don’t want exposed to author manipulation:
</li>
</ul>

<pre class="lang-css">
/* bootstrap-base.css */
/* <span class="comment">
各~下位-~fileを包装する【！無名】匿名~層
◎
unnamed wrapper layers around each sub-file
</span> */
@import url(base-forms.css) layer;
@import url(base-links.css) layer;
@import url(base-headings.css) layer;
</pre>

<pre class="lang-css">
/* bootstrap.css */
/* <span class="comment">
`base^v 層~内に組み込まれた内部的な各~名前は、
~accessから隠される。
◎
the internal names are hidden from access, subsumed in "base"
</span> */
@import url(bootstrap-base.css) layer(base);
</pre>

<pre class="lang-css">
/* author.css */
/* <span class="comment">
作者は、
`bootstrap.base^v 層には~accessできるが，【！無名】匿名~層の中へはできない。
◎
author has access to bootstrap.base layer, but not into unnamed layers
</span> */
@import url(bootstrap.css) layer(bootstrap);

/* <span class="comment">
`bootstrap^v 層に追加的な~styleを追加する：
◎
Adds additional styles to the bootstrap layer:
</span> */
@layer bootstrap {...}
</pre>
</div>

				</section>
			</section>
			<section id="layer-ordering">
<h4 title="Layer Ordering">6.4.3. 層の順序-法</h4>

<p>
`~cascade層$たちは、
各~層を最初に宣言した規則が現れる順序に基づいて~sortされる
— 入子な各`~cascade層$は，［
その親の層の中で，どの`未層$な規則よりも前に~sortされる
］よう~group化される。
◎
Cascade layers are sorted by the order in which they first are declared, with nested layers grouped within their parent layer. Unlayered rules are sorted later than any layered rules within the same parent layer (if any).
</p>

<div class="example">
<p>
次の層~規則が与えられたとき：
◎
Given the following layer rules:
</p>

<pre class="lang-css">
/* <span class="comment">
`未層$な~styleは、
層~順序においては最後に来る
◎
unlayered styles come last in the layer order
</span> */
h1 { color: darkslateblue; }

@layer reset.type {
  strong { font-weight: bold; }
}

@layer framework {
  .title { font-weight: 100; }

  @layer theme {
    h1, h2 { color: maroon; }
  }
}

@layer reset {
  [hidden] { display: none; }
}
</pre>

<div>
<p>
まず、
外縁~層が~sortされる
— それに伴い、
`未層$な~style規則は，［
明示的な層より優先順位が高い（より後に来る），暗黙的な外縁~層
］に追加される：
</p>
<ol>
	<li>`reset^v
	<li>`framework^v
	<li>（暗黙的な外縁~層）
</li>
</ol>

◎
The outer layers are sorted first, with any unlayered style rules added to an implicit outer layer which has higher precedence than (comes after) the explicit layers:
• reset
• framework
• (implicit outer layer)
</div>

<div>
<p>
他の層の中に入子にされた層は、
現れた順序で~sortされる。
各~層の中の【！更に入子にされていない】`未層$な~style規則は、
類似に［
明示的に入子にされた層より後にある，当の層の暗黙的な下位-層
］に追加される：
</p>
<ol>
	<li>`reset.type^v
	<li>`reset^v （暗黙的な下位-層）
	<li>`framework.theme^v
	<li>`framework^v （暗黙的な下位-層）
	<li>（暗黙的な外縁~層）
</ol>
◎
Within each layer, nested layers are sorted in appearance order, and style rules without further nesting are similarly added to an implicit sub-layer after the explicitly nested layers:
• reset.type
• reset (implicit sub-layer)
• framework.theme
• framework (implicit sub-layer)
• (implicit outer layer)
</div>
</div>

<p>
`条件付き~group規則$の内側で定義された~cascade層が層~順序に寄与するのは、
次のいずれかの場合に限られる：【！`6407$issue】
◎
Layers that are defined inside of a conditional group rule do not contribute to the layer order＼
</p>
<ul>
	<li>
当の条件は `真^i に評価される
◎
unless the condition is true＼
</li>
	<li>
当の条件付き~group規則を評価した結果は、
文書~内の要素に応じて異なり得る
◎
or unless the conditional group rule can evaluate differently for different elements in the document.
</li>
</ul>

<p class="note">注記：
層~順序は当の文書に大域的なので、［
要素に敏感な`条件付き~group規則$
］の内側で定義される`~cascade層$は
— 規則の条件に関わらず —
大域的な層~順序を確立するときに収容される必要がある。
しかしながら，文書に大域的な条件（ `media$at, `supports$at など）は、
そのような `layer$at 規則を条件付きで収容できる。
◎
Note: Since the layer order is global to the document, any layers defined inside an element-sensitive conditional group rule need to be accommodated when establishing the global layer order, regardless of the rule’s condition. Conditions that are global to the document, however (such as @media and @supports) can accommodate such @layer rules conditionally.
</p>

<div class="example">
<p>
例えば，次による層~順序は、
媒体~条件が合致するかどうかに依存することになる：
◎
For example, the following layer order will depend on which media conditions match:
</p>

<pre class="lang-css">
@media (min-width: 30em) {
  @layer layout {
    .title { font-size: x-large; }
  }
}

@media (prefers-color-scheme: dark) {
  @layer theme {
    .title { color: white; }
  }
}

@layer theme, layout;
</pre>

<p>
最初の`媒体~query$が表示域~寸法に基づいて合致する場合、
`layout^v 層の方が層~順序において最初に来ることになる。
色~scheme選好~query（ `prefers-color-scheme^d ）【のみ】が合致するか，どちらの条件も `偽^i に評価される場合、
`theme^v 層の方が層~順序において最初に来ることになる。
◎
If the first media-query matches based on viewport dimensions, then the layout layer will come first in the layer order. If the color-scheme preference query matches, or if neither condition is true, then theme will come first in the layer order.
</p>

<p>
作者は，この挙動を避けたいと求めるならば、
層の明示的な順序-法を確立することで，条件付き規則の内側で新たな層が定義されるのを避けれる。
【上の例では、末尾にある`一文~構文$による `layer^at 規則を先頭へ移動するなど。】
◎
Authors who want to avoid this behavior can establish an explicit ordering of layers in advance, and avoid defining new layers inside conditional rules.
</p>
</div>

<p class="note">注記：
`~cascade層$の視野は、
その［
`出自$と`~encapsulation文脈$
］に絞られる。
なので、
~light~DOM内の層たちの順序は，~shadow~DOM内の層たちの順序には
— 互いの`名前$lyが一致していても —
影響iしない
（その逆も同様になる）。
◎
Note: Cascade layers are scoped to their origin and context, so the ordering of layers in the light DOM has no impact on the order of identically-named layers in the shadow DOM (and vice versa).
</p>

<p class="issue">
`未層$な~style群にも，層~順序を【個別的にではなく，一群として】明示的に指定することを作者に許容するか？
[`6323$issue]
◎
Allow authors to explicitly place unlayered styles in the layer order [Issue #6323]
</p>

			</section>
			<section id="at-layer">
<h4 title="Declaring Layers Inline: the @layer rule">6.4.4. ~cascade層を~inlineに宣言する： `layer^at 規則</h4>

<p>
`layer@at
規則は、
`~cascade層$を宣言する
— それは、
【`~block構文$により】~style規則をアテガう~optionを伴う。
◎
The @layer rule declares a cascade layer, with the option to assign style rules.
</p>

				<section id="layer-block">
<h5 title="Assigning Styles Inline: the @layer block at-rule">6.4.4.1. ~styleを~inlineにアテガう： ~block~at-ruleを成す `layer^at</h5>

<p>
~block構文による `layer$at 規則
— `~block~at-rule$を成す `layer$at —
は、
その子~style規則を特定0の`名前$lyを伴う`~cascade層$にアテガう。
その構文は：
◎
The @layer block at-rule assigns its child style rules to a particular named cascade layer. This block layer-assignment syntax is:
</p>

<pre class="prod">
@layer `layer-name$t? {
  `stylesheet$t
}
</pre>

<p>
この構文による `layer$at 規則に対する制約と処理は、
`真^i に評価される`条件付き~group規則$ `CSS-CONDITIONAL-3$r
と同じになる。
◎
Such @layer block rules have the same restrictions and processing as a conditional group rule [CSS-CONDITIONAL-3] with a true condition.
</p>

<div class="example">
<p>
例えば，
`layer$at と `media$at
は、
次のように混在させれる：
◎
For example, @layer and @media can be mixed:
</p>

<pre class="lang-css">
@layer framework {
  h1, h2 { color: maroon; background: white;}

  @media (prefers-color-scheme: dark) {
    h1, h2 { color: red; background: black; }
  }
}
</pre>
</div>

<p class="note">注記：
~block構文による `layer$at は、
`import$at 規則たちの合間に差挟むことはできない。
◎
Note: @layer block at-rules cannot be interleaved with @import rules.
</p>

				</section>
				<section id="layer-empty">
<h5 title="Declaring Without Styles: the @layer statement at-rule">6.4.4.2. ~styleを伴わない宣言-法： 一文~at-ruleを成す `layer^at</h5>

<p>
一文~構文†による `layer$at 規則
— `一文~at-rule$を成す `layer^at —
は、
`名前$lyのみを供する
— それは、
~style規則をアテガうことなく，新たな`~cascade層$を定義するために利用できる：
◎
The @layer rule can also be used to define new layers without assigning any style rules, by providing only the layer name:
</p>

<pre class="prod">
@layer `layer-name$t#;
</pre>

<p class="trans-note">【†
原文では “空な `layer^at 規則” と称されている箇所もあるが、
この訳では，一律に “一文~構文” と記すことにする
（~blockの内容が空な`~block構文$と紛らわしいので）。
】</p>

<p>
一文~構文による `layer$at 規則は、［
`import$at ／ `namespace$at
］規則より前でも許容され
（ただし， `charset$at 規則が在る場合は、
それより後），
`~block構文$による `layer$at 規則が許容される所ならどこでも許容される。
◎
Such empty @layer rules are allowed before @import and @namespace rules (after the @charset rule, if any) as well as everywhere @layer block at-rules are allowed.
</p>

<div class="note">
<p>注記：
`layer$at 規則は、
次に挙げる箇所では許容されない
— そのような箇所にある場合、
後続の［
`import$at ／ `namespace$at
］規則が，無視されることになる
⇒＃
2 つの `import^at 規則の合間／
2 つの `namespace^at 規則の合間／
`import^at 規則と `namespace^at 規則の合間†／
</p>

<p class="trans-note">【
`import^at 規則に関しては、
このことは
`import^at 規則が許容される箇所についての要件から導出される。
`namespace^at 規則
（それは、 `import^at より後にしか許容されない）
に関しては、
`layer^at 規則との関係は（ `namespace^at の仕様~内には）まだ指定されていない。
】【†
原文の記述は、
この箇所は含まれないようにも解釈できそうだが、
`6522$issue の記述から，含まれると見受けられる。
】</p>
◎
Note: No @layer rules are allowed between @import and @namespace rules. Any @layer rule that comes after an @import or @namespace rule will cause any subsequent @import or @namespace rules to be ignored.
</div>

<p>
一文~構文においては、
`~block構文$と違って，
~commaで分離された複数個の層の`名前$lyを供せる
— それは、
それらの層を指定した順序で宣言する。
◎
Unlike the block syntax, multiple comma-separated layer names can be provided in this syntax, declaring each of the layers in the order specified.
</p>

<p class="note">注記：
層の順序付けは、
層の名前の最初の出現により定義されるので
（ <a href="#layer-ordering">§ 層の順序-法</a>を見よ）、
この規則は，それらの層の順序を
— ~stylesheet全体を読まずとも，順序が~~明らかになるよう —
冒頭で宣言することを~pageに許容する。
それはまた、
~inlineな層を~importされる層たちの合間に差挟むことも許容する
— それは、
`~block構文$ではアリでない。
◎
Note: Since layer ordering is defined by first occurrence of the layer name (see § 6.4.3 Layer Ordering), this rule allows a page to declare the order of its layers up front, so that their order is apparent without having to read the entire style sheet. It also allows inline layers to be interleaved with imported layers, which is not possible with the block syntax.
</p>

<div class="example">
<p>
一文~構文は、
層たちの順序を確立することも許容する
— 各~層に~style規則を追加する順序に関わらず。
どの `import$at 規則よりも先んじて層たちの順序を確立することは，助けになり得る。
◎
The statement syntax allows establishing a layer order in advance, regardless of the order in which style rules are added to each layer. It can be helpful to establish that layer order in advance, before any @import rules.＼
</p>

<p>
次の例では、
~importされた `theme.css^v ~style規則は，
後で `default^v ~block内に追加される~style規則を上書きすることになる
— これらの層の順序は、
すでに確立-済みなので：
◎
In this example, the imported theme.css style rules will override any rules added in the later default block since the order of layers has already been established:
</p>

<pre class="lang-css">
@layer default, theme, components;
@import url(theme.css) layer(theme);

@layer default {
  audio[controls] {
    display: block;
  }
}
</pre>

<p>
`import$at 規則を 2 つの `layer$at 規則の合間に配置することで，順序を確立することもアリである。
次の例は、
同じ結果を得ることになる：
◎
It’s also possible to have @import rules help establish the order, by placing them between @layer rules. This example will have the same result:
</p>

<pre class="lang-css">
@layer default;
@import url(theme.css) layer(theme);
@layer components;

@layer default {
  audio[controls] {
    display: block;
  }
}
</pre>

<p>
しかしながら，複数個の［
`import$at ／ `namespace$at 
］規則は、
他の規則が差挟まれることなく連続していなければならない。
次の例は、
妥当でない：
◎
However, @import and @namespace rules must be consecutive, without any intervening rules. The following is invalid:
</p>

<pre class="lang-css">
@import url(default.css) layer(default);
@layer theme;
@import url(components.css) layer(components);

@layer theme {
  audio[controls] {
    display: block;
  }
}
</pre>
</div>

				</section>
			</section>
		</section>
		<section id="preshint">
<h3 title="Precedence of Non-CSS Presentational Hints">6.5. ~CSSによるものでない呈示~用~hintの優先順位</h3>

<p>
~UAは、
~source文書の~markup内の呈示~用~hint†を尊守してもヨイ。
例えば `HTML$r における `bgcolor^a 属性や `s$e 要素。
文書~言語に基づく~style付けは，すべて、
対応する~CSS規則に翻訳した上で，次のいずれかの出自に属する規則として`~cascade$に入するモノトスル：
◎
The UA may choose to honor presentational hints in a source document’s markup, for example the bgcolor attribute or s element in [HTML]. All document language-based styling must be translated to corresponding CSS rules and enter the cascade as rules in either＼
</p>
<ul>
	<li>
`~UA出自$
◎
the UA-origin or＼
</li>
	<li>
<p>
`作者~呈示~用~hint出自@
— これは：
</p>
		<ul>
			<li>
定例の［
`~UA出自$と`作者~出自$
］の合間にある，特別~目的な出自である。
</li>
			<li>
`~cascade$の目的においては，独立な`出自$として扱われるが、
`revert$v ~keywordの目的においては，
`作者~出自$の一部を成すものと見なされる
（が、
 `revert-layer$v ~keywordにおいては，そうでない）。
【したがって、`作者~出自$の中で利用される `revert$v は，`作者~呈示~用~hint出自$に属する規則も一緒に巻戻すことになる。】
</li>
		</ul>
◎
a special-purpose author presentational hint origin between the regular user origin and the author origin.＼
For the purpose of cascading this author presentational hint origin is treated as an independent origin; however for the purpose of the revert keyword (but not for the revert-layer keyword) it is considered part of the author origin.
</li>
</ul>

<p>
文書~言語は、
そのような呈示~用~hintが，この どちらの`出自$に属するものとして~cascadeに入するかを定義してもヨイ
— その場合、
~UAは，それに則って挙動するモノトスル。
例えば，~SVGは、
その`呈示~属性$を`作者~出自$に対応付けている。
◎
A document language may define whether such a presentational hint enters the cascade as UA-origin or author-origin; if so, the UA must behave accordingly. For example, [SVG11] maps its presentation attributes into the author origin.
</p>

<p class="trans-note">【†
呈示~用~hint（ `presentational hint^en ）
— 本来は~CSSが受持つべき，呈示~用の役割も担う（担っていた）~markup
（参考：<a href="~HTMLrendering#presentational-hints">~HTMLが定義する呈示~用~hint</a>）。
これらの規則の`詳細度$cCは、
この仕様では定義されない
— 過去においては、
詳細度 ( 0, 0, 0 ) になるものと定義されていたが。
したがって、
他が指定されない限り，詳細度で~sortされることもない
（`作者~呈示~用~hint出自$は、
独立な出自を成すので，詳細度を定義する必要もない）。
】</p>

<p class="note">注記：
呈示~用~hintのうち，`~UA出自$に属する規則として`~cascade$に入するものは、［
`作者~出自$／`利用者~出自$
］に属する~styleで上書きできる。
`作者~呈示~用~hint出自$に属する規則として`~cascade$に入するものは、
`作者~出自$に属する~styleで上書きできるが、
`利用者~出自$に属する`~important$でない~styleからは，上書きできない。
~host言語は、
これらを考慮した上で，呈示~用~hint用に適切な`出自$を選ぶべきである。
◎
Note: Presentational hints entering the cascade as UA-origin rules can be overridden by author-origin or user-origin styles. Presentational hints entering the cascade as author presentational hint origin rules can be overridden by author-origin styles, but not by non-important user-origin styles. Host languages should choose the appropriate origin for presentational hints with these considerations in mind.
</p>

		</section>
	</section>
	<section id="defaulting">
<h2 title="Defaulting">7. ~default法</h2>

<p>
`~cascade$の結果（`~cascadeの出力$）が空である場合、
他の何らかの仕方で`指定d値$を見出すモノトスル。
`継承d~prop$は、
その既定の値（ `default^en ）を，`継承$を通して親~要素から取り込む。
他のすべての~propは、
その`初期~値$を既定の値としてとる。
~stylesheet作者は、［
`inherit$v ／ `initial$v
］~keywordを通して，明示的に［
継承／初期化
］を要請できる。
◎
When the cascade does not result in a value, the specified value must be found some other way. Inherited properties draw their defaults from their parent element through inheritance; all other properties take their initial value. Authors can explicitly request inheritance or initialization via the inherit and initial keywords.
</p>

		<section id="initial-values">
<h3 title="Initial Values">7.1. 初期~値</h3>

<p>
各~propには、
その~prop定義表にて，その
`初期~値@
（ `initial value^en ）が定義される。
~prop %P が`継承d~prop$でない, かつ所与の要素において %P の`~cascaded値$は無い場合、
その要素における %P の`指定d値$は %P の`初期~値$になる。
◎
Each property has an initial value, defined in the property’s definition table. If the property is not an inherited property, and the cascade does not result in a value, then the specified value of the property is its initial value.
</p>

		</section>
		<section id="inheriting">
<h3 title="Inheritance">7.2. 継承法</h3>

<p>
~prop値は
`継承@
（ `inheritance^en ）により，親~要素から その各~子~要素へ伝播する。
要素の~propの
`継承d値@
（ `inherited value^en ）は、
要素の親~要素の~propの`算出d値$で与えられる。
親~要素がない根~要素~用の`継承d値$は、
~propの`初期~値$で与えられる。
◎
Inheritance propagates property values from parent elements to their children. The inherited value of a property on an element is the computed value of the property on the element’s parent element. For the root element, which has no parent element, the inherited value is the initial value of the property.
</p>

<p>
継承は、
~shadowを伴う~DOM~treeに対しては，`平坦~化された要素~tree$に対し演算する。
◎
For a [DOM] tree with shadows, inheritance operates on the flattened element tree.＼
</p>

<p class="note">注記：
すなわち，ある `slot$e 要素 %slot にアテガわれた要素は、
~styleを
— `~light~tree$の親から直にではなく —
%slot から継承する。
◎
This means that slotted elements inherit from the slot they’re assigned to, rather than directly from their light tree parent.＼
</p>

<p class="note">注記：
各 `疑似要素$は、
その定義に述べられる，`仮想の~tag列$ `CSS-PSEUDO-4$r に則って~prop値を継承する。
◎
Pseudo-elements inherit according to the fictional tag sequence described for each pseudo-element. [CSS-PSEUDO-4]
</p>

<p>
一部の~propは、
その~prop定義表にて，
`継承d~prop@
（ `inherited property^en ）であるものと定義される。
これは、
`~cascaded値$が無いときは，その値が`継承$により決定されることを意味する。
◎
Some properties are inherited properties, as defined in their property definition table. This means that, unless the cascade results in a value, the value will be determined by inheritance.
</p>

<p>
~propを明示的に継承させることもできる。
`inherit$v ~keywordを見よ。
◎
A property can also be explicitly inherited. See the inherit keyword.
</p>

<p class="note">注記：
継承は，文書~treeに従うものであり、
生成される`~box~tree$における組み替え
— 合間に`匿名~box$が挟まれるなど —
からは影響されないことに注意。
◎
Note: Inheritance follows the document tree and is not intercepted by anonymous boxes, or otherwise affected by manipulations of the box tree.
</p>

		</section>
		<section id="defaulting-keywords">
<h3 title="Explicit Defaulting">7.3. 明示的な~default法</h3>

<p>
以下では、
各種`~CSS全域~keyword$を定義する。
これらの値をとる~prop宣言は、
特定0の`~default法$の挙動を明示的に指定する。
`css-values-3$r
にて指定される様に、
すべての~CSS~propは，これらの値を受容する。
◎
Several CSS-wide property values are defined below; declaring a property to have these values explicitly specifies a particular defaulting behavior. As specified in CSS Values and Units [css-values-3], all CSS properties can accept these values.
</p>

<p>
~keyword［
`revert$v, `revert-layer$v
］は、
`~cascadeに依存する~keyword@
である
— その利用は、
一部の文脈では制約され得る
（他の`~CSS全域~keyword$は許容される一方で）。
◎
The keywords revert and revert-layer are cascade-dependent keywords; some contexts may restrict their use while allowing the other CSS-wide keywords.
</p>

			<section id="initial">
<h4 title="Resetting a Property: the initial keyword">7.3.1. ~propを設定し直す： `initial^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`initial@v
~keywordになる場合、
その`指定d値$は，~propの`初期~値$にされる。
◎
If the cascaded value of a property is the initial keyword, the property’s specified value is its initial value.
</p>

			</section>
			<section id="inherit">
<h4 title="Explicit Inheritance: the inherit keyword">7.3.2. 明示的な継承： `inherit^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`inherit@v
~keywordになる場合、
その~propの`継承d値$が，`指定d値$および`算出d値$を与える。
◎
If the cascaded value of a property is the inherit keyword, the property’s specified and computed values are the inherited value.
</p>

			</section>
			<section id="inherit-initial">
<h4 title="Erasing All Declarations: the unset keyword">7.3.3. すべての宣言を取り消す ： `unset^v ~keyword</h4>

<p>
所与の要素において，~propの`~cascaded値$が
`unset@v
~keywordになる場合、
当の~propは［
`継承d~prop$であるならば `inherit$v ／
~ELSE_ `initial$v
］として扱われる。
この~keywordは、
実質的に，それまでに`~cascade$に出現した すべての†`宣言d値$を消去して、
~prop（`略式~prop$の場合は，そのすべての下位prop）に応じて適切に，正しく［
継承する／継承しない
］ようにする。
◎
If the cascaded value of a property is the unset keyword, then if it is an inherited property, this is treated as inherit, and if it is not, this is treated as initial. This keyword effectively erases all declared values occurring earlier in the cascade, correctly inheriting or not as appropriate for the property (or all longhands of a shorthand).
</p>

<p class="trans-note">【†
“それまでに … すべての”
— これは、
`出現順序$cCに従って~sortされるものに限られる。
`出自$cCや`詳細度$cCなど，より優先される`~sort判定基準$に基づいて選定される宣言d値まで消去するわけではない。
】</p>

			</section>
			<section id="revert">
<h4 title="Rolling Back Cascade Origins: the revert keyword">7.3.4. ~cascade出自の巻戻し： `revert^v ~keyword</h4>

<p class="trans-note">【
巻戻し（ `rolling back^en ）：
`~cascaded値$を，より優先順位が低い`出自$cCに属する宣言のみに基づくよう “戻す” 。
】【
以下の定義は、
`重要度$cCがどう織り込まれるのかはっきりしない。
】</p>

<p>
所与の要素において，~propの`~cascaded値$が
`revert@v
~keywordになる場合の挙動は、
その`宣言$が属する`出自$に依存する：
◎
If the cascaded value of a property is the revert keyword, the behavior depends on the cascade origin to which the declaration belongs:
</p>
<ul class="switch">
	<li>
`~UA出自$
⇒
`unset$v に等価。
◎
user-agent origin
• Equivalent to unset.
</li>
	<li>
`利用者~出自$
⇒
`~cascaded値$を~UA~levelへ巻戻す。
すなわち，~propの`指定d値$は、［
当の要素の~prop用の規則は、［
`作者~出自$／`利用者~出自$
］においては指定されなかった
【言い換えれば、`適用される宣言$は無かった】
］かのように計算される。
◎
user origin
• Rolls back the cascaded value to the user-agent level, so that the specified value is calculated as if no author-origin or user-origin rules were specified for this property on this element.
</li>
	<li>
`作者~出自$
⇒
`~cascaded値$を利用者~levelへ巻戻す。
すなわち，~propの`指定d値$は、［
当の要素の~prop用の規則は、
`作者~出自$においては指定されなかった
］かのように計算される。
`revert$v の目的においては、
この出自には`~animation出自$も含まれる。
◎
author origin
• Rolls back the cascaded value to the user level, so that the specified value is calculated as if no author-origin rules were specified for this property on this element. For the purpose of revert, this origin includes the Animation origin.
</li>
</ul>

			</section>
			<section id="revert-layer">
<h4 title="Rolling Back Cascade Layers: the revert-layer keyword">7.3.5. ~cascade層の巻戻し： `revert-layer^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`revert-layer@v
~keywordになる場合、
当の~cascaded値は，それを与えた宣言 %宣言 が属する`~cascade層$ %層 より優先度が低い`~cascade層$へ巻戻される
— すなわち，~propの`指定d値$は、［
当の要素の~prop用の規則は，［
%層, および次に該当する所
］においては指定されなかった
］かのように計算される
⇒
~cascadeにおいて［
%層 に属する`通常の宣言$,
%層 に属する`~importantな宣言$【！normal and important levels】
］の合間に~sortされることになる所。
◎
If the cascaded value of a property is the revert-layer keyword, the cascaded value is rolled back to the layer below, so that the specified value＼
is calculated as if no rules were specified in the current cascade layer＼
—or between its normal and important levels in the cascade—for this property on this element.＼
</p>

<p>
ただし， %宣言 が［
`~important$な`要素に付された~style$cC
］内にある場合
（この場合の %層 は、
`要素に付された~style$cCすべてからなると~~見なされる）、
“合間に~sortされることになる所”
— この場合、
`~animation出自$, `作者~出自$に属する`~important$な規則 —
のうち，前者に限り `revert^en される
【後者は、指定d値の計算に織り込まれる】。
◎
For revert-layer in important element-attached styles, however, it only reverts the element-attached styles and the intervening animation origin, and not any of the intervening author-origin important rules.
</p>

<p class="note">注記：
`revert-layer$v 値が属する`出自$の中で，より優先順位が低い`宣言$が無い場合、
`~cascaded値$は，より優先順位が低い`出自$へ巻戻されることになる。
◎
Note: If there are no lower-precedence declarations in the same cascade origin as the revert-layer value, the cascaded value will roll back to the previous origin.
</p>

<p class="note">注記：
この目的においては、
`~animation出自$は
— `revert$v のときと違って，`作者~出自$には~~含められないので —
自前の`~cascade層$を形成する。
◎
Note: The animation origin is not collapsed with the author origin for this purpose as it is for revert, and thus effectively forms its own cascade layer.
</p>

			</section>
		</section>
	</section>
	<section id="layer-apis">
<h2 title="Layer APIs">8. 層~API</h2>

		<section id="extensions-to-cssimportrule-interface">
<h3 title="Extensions to the CSSImportRule interface">8.1. `CSSImportRule^I ~interfaceに対する拡張</h3>

<p>
`CSSImportRule^I ~interfaceは、
次に従って拡張される：
◎
The CSSImportRule interface is extended as follows:
</p>

<pre class="idl">
partial interface `CSSImportRule$I {
  readonly attribute `CSSOMString$? `layerName$m;
};
</pre>

<p>
`layerName@m
属性は、
当の【 `import$at 】~at-ruleが層を宣言している【 “層~化されている” 】ならば，
その`名前$lyを表現する
— 宣言された層は匿名な場合、
空~文字列になる。
層は宣言されていない場合、
 ~NULL になる。
◎
Its layerName attribute represents the layer name declared in the at-rule itself, and is an empty string if the layer is anonymous, or null if the at-rule does not declare a layer.
</p>

		</section>
		<section id="the-csslayerblockrule-interface">
<h3 title="The CSSLayerBlockRule interface">8.2.  `CSSLayerBlockRule^I ~interface</h3>

<p>
`CSSLayerBlockRule$I ~interfaceは、
`~block構文$による `layer$at を表現する：
◎
The CSSLayerBlockRule interface represents the @layer block rule:
</p>

<pre class="idl">
[`Exposed$=Window]
interface `CSSLayerBlockRule@I : `CSSGroupingRule$I {
  readonly attribute `CSSOMString$ `name$m;
};
</pre>

<p>
`name@m
属性は、
当の~at-ruleにより宣言された`名前$ly（ `layer-name$t ）を表現する
— 当の層が匿名な場合、
空~文字列になる。
◎
Its name attribute represents the layer name declared by the at-rule itself, and is an empty string if the layer is anonymous.
</p>

<div class="example">
<p>
例えば、［
当の~at-ruleを入子にしている `layer^at 規則の名前
］は追加されない。
◎
For example, additional nested context is not added from wrapping layer rules.
</p>

<pre class="lang-css">
@layer outer {
  @layer foo.bar { }
}
</pre>

<p>
この事例では、
内縁 `layer$at 規則の `name$m は `foo.bar^l になる
（ `outer.foo.bar^l ではなく）。
◎
in this case the name of the inner @layer rule is “foo.bar” (and not “outer.foo.bar”).
</p>
</div>

		</section>
		<section id="the-csslayerstatementrule-interface">
<h3 title="The CSSLayerStatementRule interface">8.3. `CSSLayerStatementRule^I ~interface</h3>

<p>
`CSSLayerStatementRule$I ~interfaceは、
`一文~構文$による `layer$at を表現する：
◎
The CSSLayerStatementRule interface represents the @layer statement:
</p>


<pre class="idl">
[`Exposed$=Window]
interface `CSSLayerStatementRule@I : `CSSRule$I {
  readonly attribute `FrozenArray$&lt;`CSSOMString$&gt; `nameList$m;
};
</pre>

<p>
`nameList@m
属性は、
当の~at-ruleにより宣言された`名前$lyからなる~listを表現する
— 各~名前は、
`CSSLayerBlockRule$I の `name$m 属性と同じ規則に従って正規化される。
◎
Its nameList attribute represents the list of layer names declared by the at-rule, normalized following the same rule as the CSSLayerBlockRule’s name attribute.
</p>

		</section>
	</section>
	<section id="changes">
<h2 title="Changes">9. 変更点</h2>

<dl>
	<dt id="changes-2022-01">
<a href="~TR/2022/CR-css-cascade-5-20220113/">2022年 1月 13日 勧告候補~snapshot</a>
からの自明でない変更点
◎
9.1. Changes since the 13 Jan 2022 Candidate Recommendation Snapshot
◎
Non-trivial changes since the Candidate Recommendation Snapshot:
</dt>
	<dd>
【まだ無い。】
</dd>

	<dt id="changes-2021-10">
<a href="~TR/2021/WD-css-cascade-5-20211015/">2021年 10月 15日 作業草案</a>
からの自明でない変更点
◎
9.2. Changes since the 15 Oct 2021 Working Draft
◎
Non-trivial changes since the 15 October 2021 Working Draft:
</dt>
	<dd>
`~import条件$【！@import media queries and supports conditions】用の文法~styleを更新した。
◎
Updated grammar style for @import media queries and supports conditions
</dd>
	<dd>
構文解析-時点の別名を関数-記法【~keyword以外の~prop値】にも許容した。
（ `6193$issue ）
◎
Allowed functional notation parse-time aliases (Issue 6193)
</dd>
	<dd>
`CSSImportRule$I の `layerName$m を~nullableにした
（ `6576$issue ）
◎
Made CSSImportRule.layerName nullable (Issue 6576)
</dd>
	<dd>
~style属性における `revert-layer$v は、
作者~層を `revert^en しないことを明確化した。
（ `6743$issue ）
◎
Clarified that revert-layer in style attr does not revert author layers (Issue 6743)
</dd>
	<dd>
［
~style属性／~keyframe群
］に対する `revert-layer$v 【の挙動】を明確化した。
（ `6743$issue ）
◎
Clarified revert-layer on style attr and keyframes (Issue 6743)
</dd>

	<dd>
<a href="#value-aliasing">§ 値の別名化</a>
を追加した
（ `6193$issue ）
◎
Added § 4.1.1 Value Aliasing section. (Issue 6193)
</dd>
	<dd>
<a href="#layer-apis">§ 層~API</a>
を追加した。
（ `6576$issue ）
◎
Added § 8 Layer APIs section. (Issue 6576)
</dd>
	<dd>
`revert-layer$v ~keywordが［
~style属性／ `keyframes$at ~at-rule
］内で利用されたときの挙動を明確化した
（ `6743$issue ）
◎
Clarified the behavior of revert-layer keyword when used in the style attribute or @keyframes at-rule. (Issue 6743)
</dd>
	<dd>
`import$at 規則~上の［
`layer^v ~keyword, `layer^f 関数
］の挙動を明確化した。
（ `6776$issue ）
◎
Clarified the behavior of the layer keyword and layer() function on @import rules. (Issue 6776)
</dd>

	<dt id="changes-2021-08">
<a href="~TR/2021/WD-css-cascade-5-20210829/">2021年 8月 29日 作業草案</a>
からの変更点
◎
9.3. Changes since the 29 August 2021 Working Draft
◎
Changes since the 29 August 2021 Working Draft include:
</dt>
	<dd>
`未層$な~styleの順序付けを元に戻した。
（【！changes-2021-06】<a href="#changes-2021-03">以前の変更点</a>, `6284$issue を見よ）
◎
Revert the ordering of unlayered styles. (See § 9.4 Changes since the 8 June 2021 Working Draft and Issue 6284)
</dd>
	<dd>
呈示~用~hintは、
`CSS-CASCADE-4$r の更新に合致するよう，
`~cascade層$に代えて`作者~呈示~用~hint出自$を利用するものと定義した。
（ `6659$issue ）
◎
Defined presentational hints to use the author presentational hint origin instead of layers, matching update to [CSS-CASCADE-4]. (Issue 6659)
</dd>

	<dt id="changes-2021-06">
<a href="~TR/2021/WD-css-cascade-5-20210608/">2021年 6月 8日 作業草案</a>
からの有意な変更点
◎
9.4. Changes since the 8 June 2021 Working Draft
◎
Significant changes since the 8 June 2021 Working Draft include:
</dt>
	<dd>
`~cascade層$の`名前$lyにおける将来の利用-用に，`~CSS全域~keyword$を予約した。
（ `6323$issue ）
◎
Reserve the CSS-wide keywords for future use in layer-names. (Issue 6323)
</dd>
	<dd>
`layer$at 規則は、
大域的な条件付き規則を尊重するが【条件の真偽を問うが】、
`容器~query$などの大域的でない条件~内で宣言されるときは，層~順序に常に適用される
【条件の真偽を問わず，層~順序の一部を成す】
ことを明確化した。
（ `6407$issue ）
◎
Clarify that @layer rules respect global conditional rules, but are always applied to the layer order when declared in non-global conditions such as a container query. (Issue 6407)
</dd>
	<dd>
名前を定義している~at-ruleは、
名前の衝突を解決するときに層~順序に従うとした
— 詳細度の解決と類似に。
（ `6404$issue ）
◎
Name-defining at-rules follow layer order for collision resolution, similar to specificity resolution. (Issue 6404)
</dd>
	<dd>
`layer$at 規則が 2 つの［
`import$at ／ `namespace$at
］規則の合間に差挟まれるのは許容しないようにした。
（ `6522$issue ）
◎
Disallow interleaving of @layer with @import or @namespace rules. (Issue 6522)
</dd>

	<dt id="changes-2021-03">
<a href="~TR/2021/WD-css-cascade-5-20210319/">2021年 3月 19日 作業草案</a>
からの有意な変更点
◎
9.5. Changes since the 19 March 2021 Working Draft
◎
Significant changes since the 19 March 2021 Working Draft include:
</dt>
	<dd>
通常の出自に属する`未層$な~style【`未層$な`通常の宣言$】に対し、
その優先順位を最高としていたのを最低とするよう順序付けを切替えた。
（ `6284$issue ）
【が、上述したとおり，元に戻された。】
◎
Switched the ordering of unlayered styles from highest to lowest precedence in the normal origins. (Issue 6284)
</dd>

	<dt id="changes-2021-01">
<a href="~TR/2021/WD-css-cascade-5-20210119/">2021年 1月 19日 最初の公な作業草案</a>
からの有意な変更点
◎
9.6. Changes since the 19 January 2021 Working Draft
◎
Significant changes since the 19 January 2021 First Public Working Draft include:
</dt>
	<dd>
`layer$at 利用していた`~cascade層$の~import構文を
`import$at を利用するよう切替えた。
（ `5681$issue ）
◎
Switched layer import syntax from using @layer to using @import. (Issue 5681)
</dd>
	<dd>
`revert-layer$v ~keywordを追加した。
（ `5793$issue ）
◎
Added revert-layer keyword. (Issue 5793)
</dd>

	<dt id="additions-l4">
<a href="~TR/css-cascade-4/">~level 4</a>
からの追加
◎
9.7. Additions Since Level 4
◎
The following features have been added since Level 4:
</dt>
	<dd>
`~cascade$の`~sort判定基準$に`~cascade層$を追加した
（加えて、
~cascade層と適切に相互作用するよう，
~style属性を`~sort判定基準$を成す別個な段階として定義した）。
◎
Added cascade layers to the cascade sort criteria (and defined style attributes as a distinct step of the cascade sort criteria so that they interact appropriately).
</dd>

	<dd>
`~cascade層$を定義するための `layer$at 規則を導入した。
◎
Introduced the @layer rule for defining cascade layers.
</dd>
	<dd>
`import$at の定義に［
`layer^v ~keyword／ `layer^f 関数
］~optionを追加した。
◎
Added layer/layer() option to @import definition.
</dd>
	<dd>
それまでの【すなわち，より優先順位が低い】`~cascade層$へ巻戻すための~keyword `revert-layer$v を導入した。
◎
Introduced the revert-layer keyword for rolling back values to previous layers.
</dd>

	<dt id="additions-l3">
<a href="~TR/css-cascade-3/">~level 3</a>
からの追加
◎
9.8. Additions Since Level 3
◎
The following features have been added since Level 3:
</dt>
	<dd>
~cascadeの巻戻し用の `revert$v ~keywordを導入した。
◎
Introduced revert keyword, for rolling back the cascade.
</dd>
	<dd>
supports 条件付き `import$at 規則~用に `supports$f 構文を導入した。
◎
Introduced supports() syntax for supports-conditional @import rules.
</dd>
	<dd>
~shadow~DOM `DOM$r
に適応するため，`~cascade$の`~sort判定基準$に`~encapsulation文脈$を追加した。
◎
Added encapsulation context to the cascade sort criteria to accommodate Shadow DOM. [DOM]
</dd>
	<dd>
~CSSが旧来の構文を~supportするために利用する，~propを別名化する仕組みを 2 つ定義した。
<a href="#aliasing">§ ~propの別名化</a>を見よ。
◎
Defined the property two aliasing mechanisms CSS uses to support legacy syntaxes. See § 3.1 Property Aliasing.
</dd>

	<dt id="changes-2">
<a href="~TR/CSS2/cascade.html">~level 2</a>
からの追加
◎
9.9. Additions Since Level 2
◎
The following features have been added since Level 2:
</dt>
	<dd>
`all$p 略式~prop
◎
The all shorthand
</dd>
	<dd>
`initial$v ~keyword
◎
The initial keyword
</dd>
	<dd>
`unset$v ~keyword
◎
The unset keyword
</dd>
	<dd>
［
~animation, 遷移
］を`~cascade$の中に組入れた。
◎
Incorporation of animations and transitions into the cascade.
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に貢献された次の方々に：
</p>

<p lang="en">
David Baron,
Tantek Çelik,
Florian Rivoal,
Noam Rosenthal,
Simon Sapin,
Jen Simmons,
and Boris Zbarsky
contributed to this specification.
</p>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacy／~securityの考慮点</h2>

<ul>
	<li>
~cascade処理nは、［
同一-生成元, 非同一-生成元
］の~stylesheetを判別しないため、
文書に適用される~styleの算出d値から，非同一-生成元~stylesheetの内容を推定するのも可能になる。
◎
The cascade process does not distinguish between same-origin and cross-origin stylesheets, enabling the content of cross-origin stylesheets to be inferred from the computed styles they apply to a document.
</li>
	<li>
~style規則の適用を介して表出される［
利用者~選好, ~UAの既定
］は、
~cascade処理nにより公開されるので，それらが文書に適用した~styleの算出d値から推定できる。
◎
User preferences and UA defaults expressed via application of style rules are exposed by the cascade process, and can be inferred from the computed styles they apply to a document.
</li>
	<li>
`import$at 規則は、
非同一-生成元からの~stylesheetを読込む際に
<a href="~FETCH#cors-protocol">~CORS~protocol</a>
を適用せず，それらを自由に~importして適用するのを許容する。
◎
The @import rule does not apply the CORS protocol to loading cross-origin stylesheets, instead allowing them to be freely imported and applied.
</li>
	<li>
`import$at 規則は、
`~Content-Type~metadata$を伴わない資源を
（または、
~host文書は`過去互換~mode$下にある場合は，同一-生成元からのどの資源も）
【その`~MIME型$を】 `text/css^c と見做す
— その結果、
次も許容することになり得る
⇒＃
任意な資源を~pageの中へ~importして~CSSとして解釈する／
文書に適用される~styleの算出d値から敏感な~dataを推定する
◎
The @import rule assumes that resources without Content-Type metadata (or any same-origin file if the host document is in quirks mode) are text/css, potentially allowing arbitrary files to be imported into the page and interpreted as CSS, potentially allowing sensitive data to be inferred from the computed styles they apply to a document.
</li>
</ul>

	</section>
</main></div>

