<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS におけるカスケード法と継承 — CSS Cascading and Inheritance Level 5 （日本語訳）</title>


<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<style>
samp {
	white-space: nowrap;
}

#_samples_matrix tr > * {
	vertical-align: top;
}

#_samples_matrix tr > *:nth-child(3) > * {
	display: inline-block;
	width: 0;
	white-space: nowrap;
}

#_samples_matrix tr > *:nth-child(n+4) {
	padding: 2em 0.2em 0;
	/* border-left: solid #EEE 1px; */
}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%\w+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'pe': 
	text = `::${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
default:
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Cascading and Inheritance Level 5
spec_date:2021-01-11
trans_update:2021-01-13
source_checked:201214
page_state_key:CSS
original_url:https://drafts.csswg.org/css-cascade-5/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2021,permissive
trans_1st_pub:2012-07-07

●●class_map
p:property
at:at-rule
f:func
ps:pseudo
pe:pseudo
css:css
u:unit
v:value
t:type
P:production
e:element
a:attr

●●tag_map
p:code
v:code
f:code
at:code
ps:code
pe:code
t:var
P:code
css:code
u:code
e:code
a:code
m:code
I:code
c:code
V:var
em:em
i:i

●●original_id_map

●●mdn_urls
propdef-all:CSS/all
at-ruledef-import:CSS/@import

●●words_table1


●●words_table

	●cascade
import:
important:
default::::デフォルト
	~default法:defaulting
cascaded::::カスケード
	~cascade法:cascading
非略式:longhand::~

全域:wide::~
出現順序:order of appearance:~
継承法:inheritance::~
宣言d:declared::宣言
絞込み:filtering::絞り込み

重み:weight:~
優先順位:precedence:~
優先度:priority:~
	優先:win
	優先:take precedence over
	優先:order of priority
	最優先:winning
	~~選定-:win/choose
	優先-
	低いものから順に:in order from lowest to highest

巻戻し:rolling back::~
巻戻す:roll backする::~

出自:origin::~
詳細度:specificity::~

別名n:name alias::別名
別名化:aliasing::~
別名化-:alias::~

消去-:erase:~
多層化-:layer::~
	多層化-法:layering
	別々の層に分ける:layer
未層:un-layered::~

	適用-対象:applies to
	〜に算出される:computed
	~styleの算出d値:computed style

	●layout
flex:
駒:item:::アイテム
分断:break::~

	●CSS
CSSOM:
条件付き:conditional::~
無条件:unconditional::~
定義表:definition table:~
単位:unit::~
背景:background::~
色:color::~
呈示用:presentational:呈示
	欄:line

	~animateされた:animated
	媒体:medium
	~cascade層:Cascade Layer／cascade layer

	●構文
区切子:delimiter::~
展開-:expand::~
展開:expansion::~
連結-:concatenate::~
丸括弧:parentheses:~
	接頭辞~付き:-prefixed
結合-:combine::~
無名:unnamed:~
	無名:Un-Named

	●fetch／保安
Content-Type:
request::::リクエスト
	資源:file
自由:free:~
推定-:infer:~

	●仕様
競合:conflict:~
中核的:core:~
透過的:transparent:~
可用性:availability:~
理論的:theoretical:~
不注意:careless:~
不知に:inadvertentに:知らずに
適応-:accommodate:~
拡げる:expandする:~
依存性:dependencies:~
響かす:impactする:~
吹飛:吹き飛
	吹飛ばす:blow away
黙示-:imply:~
可能性:possibility:~
省略可能:optional:~
team::::チーム
組織化-:organize:~

	Level
	力関係:balance of power／balance
	~化:ize
	どちらが〜されようが:regardless of whether
	〜な限り:as far as
	特能~support:feature-support
	個々の:particular
	:Incorporation of
	こともある:may
	同様:like／similar
	同じく:As with
	同じに:
	-:関わらず
	関係にある:relationship
	一括して:-
	一方で:but／:while／:whereas
	~~仕組み:By way of
	別として:-
	根底をなす:fundamental
	単に:simply
	段階
	意味
	意味的に:in meaning
	どうにかして:somehow
	手による:-
	の際に:in preparation for
	~~字義通りの~~意味:where it comes from
	ある:available
	ことになり得る:potentially
	可能になる:enable
	点で:in terms of
	加えて:furthermore
	であっても:nonetheless
	原則として:in principle
	に依存させ:–dependent
	expectations
	~~考慮:attempts to create
	考慮-:considerations in mind
	選ぶ:choose
	選ばれ:chosen
	選ばれ:-
	施した:made
	書き直せ:rewritten
	知れる:learned
	~~避け:-
	~~除外-:not qualified
	仕上げる:make
	仕立てる:be made
	記され:written
	要する:need
	記す:writing
	機能-:function
	課す:place
	調べれ:probing
	ほぼ違わない:almost exactly like
	~~簡潔に記す:brevity
	関して／:concern
	または:option
	さらに:in advance

	●未分類
shadow:
	~shadow~DOM:Shadow DOM
light:
encapsulation::::カプセル化
theme::::テーマ
component::::コンポーネント
private::::プライベート

平坦:flat::~
変形-:transform::~
翻訳-:translate:~
獲得-:acquire:~
近似-:approximate:~
稼働中:running 時:~
乗算-:multiply:~
代用-:substitute::~
accessor::::アクセス子
基準:reference:~
視覚系:visual:~
italic:
偽:false:~
真:true:~
	`真^i に評価される:true
携帯:handheld:~
推移的:transitive:~
入する:enterする:入る
仮想の:fictional:~
糖衣:sugar::~
	構文~糖衣:syntax-sugar
併合-:merge::~
隠した:hideした:~
隠され:hideされ:~

	-:slotted
	^en:case-mapping
	属-:belong／
	組み替え:manipulation
	括られ:wrapped
	持-
	挙げ:-
	指して:refer／to
	合間に〜挟まれ:intercepted
	置き換わる:result of putting
	取り込:import
	取り込:draw
	取り消:erasing
	増やす:increases
	戻す:-
	消失した:missing
	せずに済ませ:avoid
	満たす:satisfy
	現れ:appear
	現れ:-
	終えた:has
	経て:result of
	経る:process
	絞られ:-
	絞り:-
	絞る:-
	総称-:-
	置かれ:placed
	出現-:occurring
	呼ばれ:-
	及ぼし
	specification
	備える:possess
	その場で:in place
	場所:place
	そのまま:literally
	文字列そのまま:bare string
	白紙状態:blank slate
	準備が整った:ready
	主要な:major
	重い, あるいは並列化し難い:expensive or hard-to-parallelize operations
	比較照合-:collate:~
	整数幅の画素境界:borders with integer pixel widths
	行:line
	orphan 行数:how many orphan lines
	表:table
	行:line
	高
	高い:higher
	高いものから順に:in descending order
	~~導出-:-
	源とする:sourced form
	混ぜ合わせる:blend
	来て:come
	包装する:wrapper
	付与-:attach
	越えられ:cross
	ある要素~用の既定:element defaults
	-:when invoked
	~source順序:source-order
	順序し直:re-order
	方が低い／より低い:lower
	外縁な層を視野に:in an outer layer-scope
	FULL STOP:full-stop
	規則~block:rule-block
	配列し直す:re-arrange
	層の順序付け:layer-ordering
	名前が一致する:identically-named
	下位-~file:sub-file
	組み込まれ:subsume

	●指示語
旧い:old:~
別個:distinct:~
最終-:final:~

	外の
	多い
	多く
	左右-
	当該の
	大元の:originating
	後続-:follow
	後続の:-
	後述の:see below
	対象:target
	対象に:targetted by
	地点:at the point
	大きな:large
	最後:Finally
	最終的:final
	一連の:a set of／-
	一度だけ:only once
	の一つに:one of
	一切の:no
	こともある:sometimes
	以下
	以前:earlier
	以外
	個
	個以上
	各種:-
	種:-
	他方:-
	無い
	章:chapter
	節:section
	組
	より新しい:newer
	新たに:New in
	先行-:precede
	先頭に置かれ:placed at the start
	逆に:opposite
	逆に:invert
	当該:this
	間の
	~~仕組みを通して:By way of
	並び
	付け
	同時
	同順
	しばらくの間:for a while
	の下で:on par with
	時点:time
	それ以外の点では:They otherwise
	方が低い／より低い:lower
	低い:-
	幅
	応じて
	更に
	語
	限-
	引数:value
	一箇所:in one place
	一連の:set of

	●訳注
	原則的
	付記-
	捉えら
	連鎖的
	開始時
	補間
	変わらない
	全般
	共通
	句
	委譲
	考えら
	思われる
	本来は
	旨を
	曖昧に
	見られ
	見受け
	誤解
	高次の
	限定-
	関連の
	意図的に
	概念
	概念的
	細分化-
	判断-
	辿った
	逆転-
	織り込んだ
	行われ
	処理規則
	言い換えれば
	要因
	参考
	発行時点
	役割
	少ない
	何が
	中間
	有無
	末端の
	所では
	順位
	順位付け


●●link_map



at.import:#at-ruledef-import
at.supports:~CSSCOND#at-ruledef-supports
at.media:~CSSCOND#at-ruledef-media
at.charset:~CSSSYN#at-ruledef-charset
at.namespace:~CSSNS#at-ruledef-namespace
at.layer:#at-ruledef-layer
at.layers:#at-ruledef-layers

pe.before:~CSSPSEUDO#selectordef-before
pe.after:~CSSPSEUDO#selectordef-after

p.all:#propdef-all

p.flex:~CSSFLEX#propdef-flex
p.background:~CSSBG#propdef-background
p.background-color:~CSSBG#propdef-background-color
p.background-image:~CSSBG#propdef-background-image
p.border:~CSSBG#propdef-border
p.border-bottom-width:~CSSBG#propdef-border-bottom-width
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-right-width:~CSSBG#propdef-border-right-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.border-image:~CSSBG#propdef-border-image
p.border-width:~CSSBG#propdef-border-width

p.break-before:~CSSBREAK#propdef-break-before
p.page-break-before:~CSS22/page.html#propdef-page-break-before
p.orphans:~CSSBREAK#propdef-orphans

p.font-family:~CSSFONT#propdef-font-family
p.font-size-adjust:~CSSFONT#propdef-font-size-adjust
	~CSSWG/css-fonts-4
p.font-size:~CSSFONT#propdef-font-size
p.font-style:~CSSFONT#propdef-font-style
p.font-variant:~CSSFONT#propdef-font-variant
p.font-weight:~CSSFONT#propdef-font-weight
p.font:~CSSFONT#propdef-font

p.list-style-position:~CSSLIST#propdef-list-style-position
p.text-align:~CSSTEXT#propdef-text-align
p.text-indent:~CSSTEXT#propdef-text-indent

p.direction:~CSSWM#propdef-direction
	~TR/css3-writing-modes/#direction0
p.unicode-bidi:~CSSWM#propdef-unicode-bidi
	~TR/css3-writing-modes/#unicode-bidi0

p.height:~SIZING#propdef-height
p.line-height:~CSS2VISUDET#propdef-line-height
p.page-break-after:~CSS22/page.html#propdef-page-break-after
p.width:~SIZING#propdef-width
p.display:~CSSDISP#propdef-display
	~CSS2VISUREN#propdef-display
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.overflow-x:~CSSOVERFLOW3#propdef-overflow-x
p.overflow-y:~CSSOVERFLOW3#propdef-overflow-y


v.initial:#valdef-all-initial
v.inherit:#valdef-all-inherit
v.unset:#valdef-all-unset
v.revert:#valdef-all-revert

v.handheld:~MQ5#valdef-media-handheld
	~CSS22/media.html#media-types

f.url:~CSSVAL#funcdef-url

t.url:~CSSVAL#url-value
t.string:~CSSVAL#string-value
t.media-query-list:~MQ5#typedef-media-query-list
t.media-query:#typedef-media-query
	t.media-query:~MQ5#typedef-media-query
t.supports-condition:#typedef-supports-condition
	t.supports-condition:~CSSCOND#typedef-supports-condition
t.declaration:#typedef-declaration
t.layer-ident:#typedef-layer-layer-ident

t.ident:~CSSVAL#typedef-ident

t.declaration-value:~CSSSYN#typedef-declaration-value
t.ident-token:~CSSSYN#typedef-ident-token
t.delim-token:~CSSSYN#typedef-delim-token
t.stylesheet:~CSSSYN#typedef-stylesheet


P.supports_condition:~TR/css3-conditional/#supports_condition
	~CSSCOND#typedef-supports-condition
P.supports_declaration_condition:~TR/css3-conditional/#supports_declaration_condition
P.media_query_list:~TR/css3-mediaqueries/#syntax
	~MQ5#typedef-media-query-list
P.declaration:~CSS22/syndata.html#tokenization


u.em:~CSSVAL#em
u.ex:~CSSVAL#ex
u.vh:~CSSVAL#vh
u.vw:~CSSVAL#vw

css.!important:#importance

e.s:~HEtextlevel#the-s-element
e.slot:~HEscripting#the-slot-element
e.link:~HEmetadata#the-link-element
e.style:~HEmetadata#the-style-element

a.dir:~HTMLdom#attr-dir

c.getComputedStyle():~CSSOM1#dom-window-getcomputedstyle


	●用語
~important:#important
~importantな宣言:#important
通常の宣言:#normal
~import条件:#import-conditions
~default法:#defaulting
	下の表:#stages-examples
~cascadeの出力:#output-of-the-cascade
~cascade:#cascade
~cascade法:#cascading
~cascaded値:#cascaded-value
略式~prop:#shorthand-property
下位prop:#longhand
設定し直すのみ:#reset-only-sub-property
旧来の別名n:#legacy-name-alias
旧来の略式~prop:#legacy-shorthand

継承:#inheritance
継承d~prop:#inherited-property
継承d値:#inherited-value
初期~値:#initial-value
算出d値:#computed-value
使用~値:#used-value
指定d値:#specified-value
実際の値:#actual-value
宣言d値:#declared-value

適用-対象:#applies-to
要素に適用され:#_applied-to

cC.出自と重要度:#cascade-origin
cC.重要度:#cascade-origin
cC.出自:#cascade-origin
cC.文脈:#cascade-context
~encapsulation文脈:#encapsulation-contexts
cC.~style属性:#style-attr
cC.層:#cascade-layering
未層:#_un-layered
cC.詳細度:#cascade-specificity
cC.出現順序:#cascade-order

出自:#origin
~UA出自:#cascade-origin-ua
~UA~stylesheet:#cascade-origin-ua
作者~出自:#cascade-origin-author
利用者~出自:#cascade-origin-user
~animation出自:#cascade-origin-animation
遷移~出自:#cascade-origin-transition

~cascade層:#cascade-layers
ly.名前:#layer-name
	層~名:#layer-name

	●用語（CSS
~CSS全域~keyword:~CSSVAL#common-keywords
~CSS識別子:~CSSVAL#css-identifier
	~CSS識別子:~CSSSYN#identifier

~style属性:~CSSSTYLEATTR#style-attribute0
~supportする:~CSSCOND#support-definition
媒体~query:~MQ5#media-query
条件付き~group規則:~CSSCOND#conditional-group-rule

表示~型:~CSSDISP#display-type
匿名~box:~CSSDISP#anonymous
~box~tree:~CSSDISP#box-tree
~text~node:~CSSDISP#text-nodes
要素:~CSSDISP#elements

環境~符号化法:~CSSSYN#environment-encoding
~custom~prop:~CSSVAR#custom-property
解決d値:~CSSOM1#resolved-values
仮想の~tag列:~CSSPSEUDO#fictional-tag-sequence

~tree文脈:~CSSSCOPING#tree-context
平坦~化された要素~tree:~CSSSCOPING#flat-tree

~flex駒:~CSSFLEX#flex-item
選択子:~SELECTORS4#selector
疑似要素:~SELECTORS4#pseudo-element

	~CSS2VISUREN#box-gen
	~CSSWM#text-direction
	~SELECTORS4#specificity
	CSSImportRule.styleSheet
	~HTMLurl#content-type
	~HTMLrendering#the-css-user-agent-style-sheet-and-presentational-hints
	~SVG11/styling.html#UsingPresentationAttributes


	●用語（他
~DOM~tree:~DOM4#concept-tree
~shadow~tree:~DOM4#concept-shadow-tree
~light~tree:~DOM4#concept-light-tree
~shadowも含む~tree順序:~DOM4#concept-shadow-including-tree-order
過去互換~mode:~DOM4#concept-document-quirks

~Content-Type~metadata:~HTMLurl#content-type
同一-生成元:~ORIGIN#same-origin
呈示~属性:~SVGstyling#TermPresentationAttribute
	~SVG11/styling.html#UsingPresentationAttributes

~MIME型:~MIMESNIFF#mime-type

●●ref_normative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 18 December 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 31 December 2020. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. CSS Scoping Module Level 1. 3 April 2014. WD. URL: https://www.w3.org/TR/css-scoping-1/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-TRANSITIONS-1]
    David Baron; et al. CSS Transitions. 11 October 2018. WD. URL: https://www.w3.org/TR/css-transitions-1/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 10 December 2019. REC. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/ 
[CSS3-CONDITIONAL]
    David Baron; Elika Etemad; Chris Lilley. CSS Conditional Rules Module Level 3. 8 December 2020. CR. URL: https://www.w3.org/TR/css-conditional-3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[MEDIAQ]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 21 July 2020. CR. URL: https://www.w3.org/TR/mediaqueries-4/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 

●●ref_informative

[CSS-ALIGN-3]
    Elika Etemad; Tab Atkins Jr.. CSS Box Alignment Module Level 3. 21 April 2020. WD. URL: https://www.w3.org/TR/css-align-3/ 
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 22 December 2020. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 3. 4 December 2018. CR. URL: https://www.w3.org/TR/css-break-3/ 
[CSS-BREAK-4]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 4. 18 December 2018. WD. URL: https://www.w3.org/TR/css-break-4/ 
[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. CSS Flexible Box Layout Module Level 1. 19 November 2018. CR. URL: https://www.w3.org/TR/css-flexbox-1/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. CSS Lists and Counters Module Level 3. 17 November 2020. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-PAGE-3]
    Elika Etemad; Simon Sapin. CSS Paged Media Module Level 3. 18 October 2018. WD. URL: https://www.w3.org/TR/css-page-3/ 
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. CSS Box Sizing Module Level 3. 18 December 2020. WD. URL: https://www.w3.org/TR/css-sizing-3/ 
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. CSS Text Module Level 3. 22 December 2020. CR. URL: https://www.w3.org/TR/css-text-3/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 24 January 2020. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより公開された
<a href="~SPEC_URL">CSS Cascading and Inheritance Level 5</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-cascade-5/

課題追跡
	<a href="https://github.com/w3c/csswg-drafts/labels/css-cascade-5">    CSSWG Issues Repository </a>

編集
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)
	<a href="http://miriamsuzanne.com/contact">Miriam E. Suzanne</a> (Invited Expert)
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	https://github.com/w3c/csswg-drafts/blob/master/css-cascade-5/Overview.bs
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/master/css-cascade-5

</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">CSS におけるカスケード法と継承 — CSS Cascading and Inheritance Level 5</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
この~CSS~moduleは、~style規則を比較照合する方法, および
すべての要素の すべての~CSS~propに値をどうアテガうか、について述べる。
値は、`~cascade法$, および継承の~~仕組みを通して，すべての要素の すべての~propに伝播される。
◎
This CSS module describes how to collate style rules and assign values to all properties on all elements. By way of cascading and inheritance, values are propagated for all properties on all elements.
</p>

<p>
この~levelにて新たに定義されるものは、`~cascade層$である。
◎
New in this level is cascade layers.
</p>

~CSSisaLANG

	</section>
	<section id="status">
~STATUSofTHIS

<p>
`この節では、発行時点における…^em
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
最後の草案からの主要な変更点については、<a href="#changes">§ 変更点</a>に。
◎
For changes since the last draft, see the Changes section.
</p>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
~CSSの根底をなす設計原則の一つに`~cascade法$（ ~cascade処理規則, `cascading^en ）がある。
これにより、複数の~stylesheetを文書の呈示に波及させれるようになる。
同じ ［要素, ~prop］ の組合nに対し，複数の宣言が与えられている下での値の競合は、どうにかして解決する必要がある。
◎
One of the fundamental design principles of CSS is cascading, which allows several style sheets to influence the presentation of a document. When different declarations try to set a value for the same element/property combination, the conflicts must somehow be resolved.
</p>

<p>
逆に、 ［要素, ~prop］ の組合nに値を設定する宣言が無い場合についても，解決される必要がある。
この場合、値は，`継承$や~propの`初期~値$を通して見出される。
◎
The opposite problem arises when no declarations try to set a the value for an element/property combination. In this case, a value is be found by way of inheritance or by looking at the property’s initial value.
</p>

<p>
`~cascade法$と`~default法$を経ることにより，入力に与えられた一連の宣言から、各~要素の各~prop用の`指定d値$が出力される。
◎
The cascading and defaulting process takes a set of declarations as input, and outputs a specified value for each property on each element.
</p>

<p>
この仕様は、文書~内のすべての要素の すべての~propについて，それぞれの指定d値を見出すための規則を述べる。
~page文脈およびその~margin~boxの下で，指定d値を見出すための規則は、
`css-page-3$r にて述べられる。
◎
The rules for finding the specified value for all properties on all elements in the document are described in this specification. The rules for finding the specified values in the page context and its margin boxes are described in [css-page-3].
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
`この節は規範的である。^em
◎
This section is normative.
</p>

<p>
この~moduleは、
`CSS2$r § 6 に定義される［
~prop値のアテガわれ方, ~cascade法, 継承
］用の規則を置換して，それらを拡張する。
◎
This module replaces and extends the rules for assigning property values, cascading, and inheritance defined in [CSS2] chapter 6.
</p>

<p>
他の~CSS~moduleは、ここに定義される構文と特能の一部の定義を拡げるかもしれない。
◎
Other CSS modules may expand the definitions of some of the syntax and features defined here.＼
</p>

<p class="example">
例えば Media Queries Level 4 仕様は、この~moduleと組合せる下で，この仕様に利用される `media-query$t 値~型の定義を拡げる。
◎
For example, the Media Queries Level 4 specification, when combined with this module, expands the definition of the &lt;media-query&gt; value type as used in this specification.
</p>

<p>
この仕様の目的においては、`~text~node$は、それに結付けられている`要素$の子~要素であり，~propたちの全部的な集合を備えているものとする。
~text~nodeは 選択子の対象になれないので、その算出d値すべては，`~default法$を通してアテガわれる。
◎
For the purpose of this specification, text nodes are treated as element children of their associated element, and possess the full set of properties; since they cannot be targetted by selectors all of their computed values are assigned by defaulting.
</p>

		</section>
	</section>
	<section id="at-import">
<h2 title="Importing Style Sheets: the @import rule">2. ~stylesheetの~import法： `import^at 規則</h2>

<p>
`import@at
規則により，利用者は 他の~stylesheetから~style規則を~import（取り込む）できるようになる。
`import$at 規則が妥当な~stylesheetを指しているならば、
~UAは、次の 2 つの例外を除き，
`import$at 規則の場所にその内容が記されていたかのように扱うモノトスル：
◎
The @import rule allows users to import style rules from other style sheets. If an @import rule refers to a valid stylesheet, user agents must treat the contents of the stylesheet as if they were written in place of the @import rule, with two exceptions:
</p>
<ul>
	<li>
ある特能（ `namespace$at 規則など）が，［
適用されるのは特定0の~stylesheetに限られ，~importされたそれには適用されない
］ものと明示的に定義している場合、それは~importされた~stylesheetには適用されない。
◎
If a feature (such as the @namespace rule) explicitly defines that it only applies to a particular stylesheet, and not any imported ones, then it doesn’t apply to the imported stylesheet.
</li>
	<li>
ある特能が，~stylesheet内の複数の構成子どうしの順序に依拠する場合（ `namespace$at 規則には， `import$at 以外の規則は先行してはならないとする要件など）、それが適用されるのは，同じ~stylesheet内の構成子どうしに限られる。
◎
If a feature relies on the relative ordering of two or more constructs in a stylesheet (such as the requirement that @namespace rules must not have any other rules other than @import preceding it), it only applies between constructs in the same stylesheet.
</li>
</ul>

<p class="example">
例えば，［
~importされた~stylesheet内の~style規則
］の中の各~宣言は、それを~importした~stylesheetの中の `import$at の地点に 当の~style規則がそのまま記されたかのように，~cascadeとヤリトリする。
◎
For example, declarations in style rules from imported stylesheets interact with the cascade as if they were written literally into the stylesheet at the point of the @import.
</p>

<p>
~stylesheet内では、
`import$at 規則は，（ `charset$at は無視して）他のすべての妥当な［
~at-rule／~style規則
］より先行していなければナラナイ。
さもなければ `import$at 規則は無効とされる。
`import$at の構文は次で与えられる：
◎
Any @import rules must precede all other valid at-rules and style rules in a style sheet (ignoring @charset), or else the @import rule is invalid. The syntax of @import is:
</p>

<pre class="prod">
@import [ `url$t | `string$t ]
   [ supports( [ `supports-condition$t | `declaration$t ] ) ]?
   `media-query-list$t? ;
</pre>

<p>
`url$t ／ `string$t
は、~importされることになる~stylesheetの~URLを与える。
`~import条件@
と総称される，省略可能な［
<span class="prod">[ `supports-condition$t | `declaration$t ]</span> ／
`media-query-list$t
］は、当の~stylesheetが どのような条件の下で適用されるかを言明する。
◎
where the &lt;url&gt; or &lt;string&gt; gives the URL of the style sheet to be imported, and the optional [&lt;supports-condition&gt;|&lt;declaration&gt;] and &lt;media-query-list&gt; (collectively, the import conditions) state the conditions under which it applies.
</p>

<div class="example">
<p>
次の
<a href="#conditional-import">条件付き `import^at 規則</a>
は、~UAが
<code class="css">`display$p: `flex^v</code>
を`~supportする$場合に限り，~stylesheetを読込むことに加え、
<a href="~MQ5#width">表示域~横幅</a>が `400px^v
<a href="~MQ5#mq-min-max">以下</a>の携帯~機器【 `handheld$v 】に限り，~stylesheetを適用する：
◎
The following conditional @import rule only loads the style sheet when the UA supports display: flex, and only applies the style sheet on a handheld device with a maximum viewport width of 400px.
</p>

<pre class="lang-css">
@import url("narrow.css") supports(display: flex) handheld and (max-width: 400px);
</pre>

</div>

<p>
`string$t が供されている場合、それは，同じ引数を伴う 1 個の `url$t として解釈するモノトスル。
◎
If a &lt;string&gt; is provided, it must be interpreted as a &lt;url&gt; with the same value.
</p>

<div class="example">

<p>
次の 2 行（ `url$f によるものと, 文字列そのままのもの）は、意味的に等価な `import$at 構文になる：
◎
The following lines are equivalent in meaning and illustrate both @import syntaxes (one with url() and one with a bare string):
</p>

<pre class="lang-css">
@import "mystyle.css";
@import url("mystyle.css");
</pre>

</div>

		<section id="conditional-import">
<h3 title="Conditional @import Rules">2.1. 条件付き `import^at 規則</h3>

<p>
~importは，`~import条件$により，［
媒体／特能~support
］に依存させることもできる。
`~import条件$が無い下では，無条件に~importされる（その
`media-query-list$t 用の値 `all^v を指定しても，同じ効果になる）。
`~import条件$が合致しない場合、~importされる~stylesheet内の規則は適用されない
— ~importされた~stylesheetが，所与の媒体~queryを伴う［
`media$at ／ `supports$at
］~blockで括られたときとちょうど同じに。
◎
The import conditions allow the import to be media– or feature-support–dependent. In the absence of any import conditions, the import is unconditional. (Specifying all for the &lt;media-query-list&gt; has the same effect.) If the import conditions do not match, the rules in the imported stylesheet do not apply, exactly as if the imported stylesheet were wrapped in @media and/or @supports blocks with the given conditions.
</p>

<div class="example">

<p>
`import$at 規則を媒体に依存させる例を以下に示す：
◎
The following rules illustrate how @import rules can be made media-dependent:
</p>

<pre class="lang-css">
@import url("fineprint.css") print;
@import url("bluish.css") projection, tv;
@import url("narrow.css") handheld and (max-width: 400px);
</pre>

</div>

<p>
従って~UAは、`~import条件$が合致しない条件付き~importについては，~fetchせずに済ませられる。
加えて、~importによる~stylesheetの適用が `supports-condition$t により阻まれる場合には、その~stylesheetを（他の~linkを通して読込まれるのでない限り）~fetchしてはならず、その~import規則に対応する `CSSImportRule.styleSheet^c 値は，（他の~linkを通して読込まれる場合でも） ~NULL を返すモノトスル。
◎
User agents may therefore avoid fetching a conditional import as long as the import conditions do not match. Additionally, if a &lt;supports-condition&gt; blocks the application of the imported style sheet, the UA must not fetch the style sheet (unless it is loaded through some other link) and must return null for the import rule’s CSSImportRule.styleSheet value (even if it is loaded through some other link).
</p>

<div class="example">
<p>
作者が、より新しい~UAの~network処理能に響かすことなく，旧来の~UAに~fallback規則を供する方法を，次の規則に示す：
◎
The following rule illustrates how an author can provide fallback rules for legacy user agents without impacting network performance on newer user agents:
</p>

<pre class="lang-css">
@import url("fallback-layout.css") supports(not (display: flex));
@supports (display: flex) {
  ...
}
</pre>

</div>

<p>
`media-query@t
は、
`media_query_list$P 生成規則に対応し，`媒体~query$として解釈される。
`supports-condition@t
は、
`supports_condition$P 生成規則に対応し，
`supports$at 条件として解釈される。
`supports-condition$t に代えて
`declaration@t
（ `declaration$P 生成規則）が与えられた場合、
`supports_declaration_condition$P 生成規則として解釈した上で（すなわち，暗黙の丸括弧が追加される），
`supports-condition$t として扱うモノトスル。
◎
A &lt;media-query&gt; corresponds to the media_query_list production and is interpreted as a media query, and a &lt;supports-condition&gt; corresponds to a supports_condition production and is interpreted as an @supports condition. If a &lt;declaration&gt; (a declaration production) is given in place of a &lt;supports-condition&gt;, it must be interpreted as a supports_declaration_condition production (i.e. the extra set of parentheses is implied) and treated as a &lt;supports-condition&gt;.
</p>

<div class="example">
<p>
例えば、次の 2 行は等価になる：
◎
For example, the following two lines are equivalent:
</p>

<pre class="lang-css">
@import "mystyle.css" supports(display: flex);
@import "mystyle.css" supports((display: flex));
</pre>
</div>

<p>
`~import条件$の評価とその全部的な構文は
<a href="~TR/css3-mediaqueries/">Media Queries</a>
`MEDIAQ$r, および
<a href="~CSSCOND">CSS Conditional Rules</a>
`CSS3-CONDITIONAL$r
にて定義される。
◎
The evaluation and full syntax of the import conditions are defined by the Media Queries [MEDIAQ] and CSS Conditional Rules [CSS3-CONDITIONAL] specifications.
</p>

		</section>
		<section id="import-processing">
<h3 title="Processing Stylesheet Imports">2.2. ~importによる~stylesheetの処理</h3>

<p>
同じ~stylesheetが文書~内の複数の場所から~importまたは~linkされている場合、 ~UAは，それらの~linkをそれぞれが独立な~stylesheetを指しているかのように処理するモノトスル。
◎
When the same style sheet is imported or linked to a document in multiple places, user agents must process (or act as though they do) each link as though the link were to an independent style sheet.
</p>

<p class="note">注記：
これは、資源の~fetchingに要件を課すものではない。
~stylesheetは［
~CSSOMに どう反映されるか／
この仕様などの各種~仕様において どう利用されるか
］に課される要件になる。
複数箇所から~linkされている, あるいは複数回~importされたとしても，適切な~cache法の下で 一度だけ~stylesheetを~fetchすることは、ごく適切な~UAのふるまいになる。
◎
Note: This does not place any requirements on resource fetching, only how the style sheet is reflected in the CSSOM and used in specs such as this one. Assuming appropriate caching, it is perfectly appropriate for a UA to fetch a style sheet only once, even though it’s linked or imported multiple times.
</p>

<p>
~importされた~stylesheetが属する`出自$は、それを~importした~stylesheetが属する`出自$と同じになる。
◎
The origin of an imported style sheet is the origin of the style sheet that imported it.
</p>

	<p>
~importされた~stylesheetの`環境~符号化法$は、それを~importした~stylesheetの符号化法で与えられる。
`css-syntax-3$r
◎
The environment encoding of an imported style sheet is the encoding of the style sheet that imported it. [css-syntax-3]
</p>

		</section>
		<section id="content-type">
<h3 title="Content-Type of CSS Style Sheets">2.3. ~CSS~stylesheetの~Content-Type</h3>

<div class="p">

<p>
~importされた~stylesheetの処理は、~link先の資源の実際の型【 “~MIME型” 】に依存する
— 型は、次にしたがって決定される：
</p>
<ul>
	<li>
~host文書が`過去互換~mode$下にある, かつ
~host文書と~importされた~stylesheetは`同一-生成元$である場合
⇒
`text/css^c
</li>
	<li>
他の場合、資源に`~Content-Type~metadata$が伴われているならば
⇒
型は その~metadataにより決定される
</li>
	<li>
他の場合
⇒
`text/css^c
</li>
</ul>

◎
The processing of imported style sheets depends on the actual type of the linked resource. If the resource does not have Content-Type metadata, or the host document is in quirks mode and has the same origin as the imported style sheet, the type of the linked resource is text/css. Otherwise, the type is determined from its Content-Type metadata.
</div>

<p>
~link先の資源の型が `text/css^c である場合、~CSS~stylesheetとして解釈するモノトスル。
他の場合、~network~errorとして解釈するモノトスル。
◎
If the linked resource’s type is text/css, it must be interpreted as a CSS style sheet. Otherwise, it must be interpreted as a network error.
</p>

		</section>
	</section>
	<section id="shorthand">
<h2 title="Shorthand Properties">3. 略式~prop</h2>

<p>
作者が数種の~propの値を単独の~propで一括して指定できるようにするため、一部の~propは
`略式~prop@
（
`shorthand property^en, または略して `shorthand^en
）とされている。
`略式~prop$は、そのすべての非略式
`下位prop@
（
`longhand sub-property^en, または略して［
`longhand^en ／ `sub-property^en
］）を，その場で展開されたかのように設定する。
◎
Some properties are shorthand properties, meaning that they allow authors to specify the values of several properties with a single property. A shorthand property sets all of its longhand sub-properties, exactly as if expanded in place.
</p>

<p>
`略式~prop$から値が省略されて “消失した” それぞれの`下位prop$には、他から定義されない限り，その`初期~値$がアテガわれる。
◎
When values are omitted from a shorthand form, unless otherwise defined, each “missing” sub-property is assigned its initial value.
</p>

<div class="note">
<p>注記：
すなわち，`略式~prop$宣言は常に、その`すべて^emの`下位prop$を設定する
— それらが明示的に設定されなくても。
不注意に`略式~prop$を利用した場合，一部の`下位prop$を不知に設定し直すことになりかねないが、注意して利用すれば，不知に他の~sourceから~cascadeされた`下位prop$を設定し直して，“白紙状態” に戻すことを保証してくれる。
◎
This means that a shorthand property declaration always sets all of its sub-properties, even those that are not explicitly set. Carelessly used, this might result in inadvertently resetting some sub-properties. Carefully used, a shorthand can guarantee a “blank slate” by resetting sub-properties inadvertently cascaded from other sources.
</p>

<p>
例えば，
<code class="css">`background-color$p: `green^v;</code>
ではなく
<code class="css">`background$p: `green^v;</code>
と記すことにより、以前のどこかの宣言で 背景に `background-image$p による画像が設定されているかもしれないときでも，背景を`色だけ^emにするよう上書きできる†。
◎
For example, writing background: green rather than background-color: green ensures that the background color overrides any earlier declarations that might have set the background to an image with background-image.
</p>

<p class="trans-note">【†
`出現順序$cCにより~sortした結果として，そうなる
— `出自$cCや`詳細度$cCなど，より優先される<a href="#cascade-sort">~sort判定基準</a>に基づいて選定される宣言d値まで上書きするわけではない。
】</p>

</div>

<div class="example">

<p>
例えば，CSS Level 1 の `font$p ~propは、
`font-style$p,
`font-variant$p,
`font-weight$p,
`font-size$p,
`line-height$p,
`font-family$p
を一括して設定するための，`略式~prop$である。
したがって，次の様な複数の宣言は：
◎
For example, the CSS Level 1 font property is a shorthand property for setting font-style, font-variant, font-weight, font-size, line-height, and font-family all at once. The multiple declarations of this example:
</p>

<pre class="lang-css">
h1 {
  font-weight: bold;
  font-size: 12pt;
  line-height: 14pt;
  font-family: Helvetica;
  font-variant: normal;
  font-style: normal;
}
</pre>

<p>
次の様に書き直せる
◎
can therefore be rewritten as
</p>

<pre class="lang-css">
h1 { font: bold 12pt/14pt Helvetica }
</pre>

<p>
`font$p に対する新たな`下位prop$が更に導入されれば、略式~prop宣言は，それらも その初期~値に設定し直すことになる。
◎
As more font sub-properties are introduced into CSS, the shorthand declaration resets those to their initial values as well.
</p>

</div>

<p class="trans-note">【
次の様な場合もあることに注意：
`border-width$p のような~propは、略式~prop
`border$p の下位propであると同時に，下位propに［
`border-top-width$p, `border-left-width$p, … 等々
］を持つ略式~propでもある。
この様な場合の `border$p の “下位prop” は、連鎖的に辿った末端の下位propを指しているように見受けられる
— が、この場合の “中間” の~prop（この例では
`border-width$p 等々）が，下位propに［含まれる／含まれない］のどちらに定義されているのかは、はっきりしない
【！展開については、末端のもののみに限定され， “中間” のものは除外されると推定されるが】
— どちらに解釈したとしても，~cascadeに現れる結果は変わらないと見受けられるので
<small>（末端の下位propに限定する必要がある所では，その旨を付記した方が誤解は少ないであろう）</small>。
あるいは、そうなることを利用して，意図的に曖昧に定義されているように思われる。
実際、何が［
略式~prop／下位prop
］と見なされるかは，実装にも依存する —
仕様が拡張されて、それまでは末端の~propであったものが，より細分化された下位propを持つ様になることもあるので（例えば
`overflow$p ~propに対する
`overflow-x$p, `overflow-y$p
）。

】</p>

<p>
一部の`略式~prop$は、その`下位prop$の値に直には対応しないような，異なる構文や特別な~keywordを持ち得る（そのような`略式~prop$は，その値の展開を明示的に定義することになる）。
◎
In some cases, a shorthand might have different syntax or special keywords that don’t directly correspond to values of its sub-properties. (In such cases, the shorthand will explicitly define the expansion of its values.)
</p>

<p>
また、略式~propにおいて
`設定し直すのみ@
になる`下位prop$もある：
それは、他の`下位prop$と同様に，略式~propの中で値が指定されていなければ 初期~値に設定し直すが、それ以外の値に設定する構文が，略式~propに備わっていないものである【 `~CSS全域~keyword$は別として】。
例えば， `border$p 略式~propは、
`border-image$p をその初期~値 `none^v に設定し直すが，それ以外の値に設定する構文を備えていない。
`css-backgrounds-3$r
◎
In other cases, a property might be a reset-only sub-property of the shorthand: Like other sub-properties, it is reset to its initial value by the shorthand when unspecified, but the shorthand might not include syntax to set the sub-property to any of its other values. For example, the border shorthand resets border-image to its initial value of none, but has no syntax to set it to anything else. [css-backgrounds-3]
</p>

<p>
`略式~prop$が いずれかの`~CSS全域~keyword$ `css-values-3$r として指定されている場合、そのすべての`下位prop$は，`設定し直すのみ$のものも含め，その~keywordに設定される。
（これらの~keywordは、略式~propに限らず，単独の宣言の中で他の値と組合できないことに注意。）
◎
If a shorthand is specified as one of the CSS-wide keywords [css-values-3], it sets all of its sub-properties to that keyword, including any that are reset-only sub-properties. (Note that these keywords cannot be combined with other values in a single declaration, not even in a shorthand.)
</p>

<p>
`略式~prop$を `!important$css を伴わせて宣言することは、そのすべての`下位prop$を `!important$css を伴わせて宣言することに等価になる。
◎
Declaring a shorthand property to be !important is equivalent to declaring all of its sub-properties to be !important.
</p>

		<section id="aliasing">
<h3 title="Aliasing">3.1. 別名化</h3>

<p>
~propの名前は、変更されることもある
— ~vendor接頭辞~付き~propなど，しばらくの間 ~supportされた後に標準~化されるときなど。
互換性の理由から，元の名前も依然として~supportされる必要があるが、新たな名前が選好される。
これを成遂げるため、~CSSでは，旧い構文を新たな構文の “別名にする” 2 つの仕方を定義する：
◎
Properties sometimes change names after being supported for a while, such as vendor-prefixed properties being standardized. The original name still needs to be supported for compatibility reasons, but the new name is preferred. To accomplish this, CSS defines two different ways of “aliasing” old syntax to new syntax.
</p>

<dl class="def-list">
	<dt>
`旧来の別名n@
（ `legacy name alias^en ）
◎
legacy name aliases
</dt>
	<dd>
旧い~propの構文が，新たな~propの構文による値~空間に一致するか その下位集合である場合、旧い~prop名は新たな~propの別名にされる
— 構文解析-時点で，文字大小~対応付け演算の下で新たな~prop名に変換することにより。
この変換は、~CSSOMにおいても，文字列~引数, ~prop~accessorの両者に適用される
— 旧い~prop名~向けの要請は、透過的に，新たな~prop名に転送される。
◎
When the old property’s syntax is identical to or a subset of the value space of the new property’s syntax, the two names are aliased with an operation on par with case-mapping: at parse time, the old property is converted into the new property. This conversion also applies in the CSSOM, both for string arguments and property accessors: requests for the old property name transparently transfer to the new property name instead.
</dd>
	<dd class="example">
例えば `old-name^p は `new-name^p 用の`旧来の別名n$である場合、
<code>getComputedStyle(%el).oldName</code>
は `newName^c ~propに算出される~styleを返すことになり，
<code>el.style.setPropertyValue(`old-name^l, `value^l)</code>
は `new-name^p ~propを `value^l に設定することになる。
◎
For example, if old-name is a legacy name alias for new-name, getComputedStyle(el).oldName will return the computed style of the newName property, and el.style.setPropertyValue("old-name", "value") will set the new-name property to "value".
</dd>

	<dt>
`旧来の略式~prop@
（ `legacy shorthand^en ）
◎
legacy shorthands
</dt>
	<dd>
旧い~propの構文が新たな~propの構文とは別個なものである場合、旧い~prop名は，`略式~prop$の仕組みを利用して 新たな~prop名の別名にされる。
旧い~propは、【新たな~propを下位propとする】
`旧来の略式~prop$であるものと定義され，その利用は`非推奨に^emされる。
それ以外の点では、定例の略式と正確に同じに挙動する
— ~CSSOMにより宣言が直列化されるときには，旧い名前を利用しないこと除いて。
`CSSOM$r
◎
When the old property has a distinct syntax from the new property, the two names are aliased using the shorthand mechanism. These shorthands are defined to be legacy shorthands, and their use is deprecated. They otherwise behave exactly as regular shorthands, except that the CSSOM will not use them when serializing declarations. [CSSOM]
</dd>
	<dd class="example">
<p>
例えば， `page-break-*^p ~propは、
`break-*^p ~prop用の`旧来の略式~prop$である（
<a href="~CSSBREAK#page-break-properties">§~page分断~propの別名</a>
`css-break-3$r を見よ）。
◎
For example, the page-break-* properties are legacy shorthands for the break-* properties (see CSS Fragmentation 3 §3.4 Page Break Aliases: the page-break-before, page-break-after, and page-break-inside properties).
</p>

<p>
`page-break-before$p が `always^v に設定された場合、他の略式が行う様に構文解析-時点で `break-before$p に展開される。
同様に， `break-before^p が `page^v に設定された場合、
<code>getComputedStyle(%el).pageBreakBefore</code>
を~callしたときには `always^l を返すことになる。
しかしながら，
~style~blockを直列化するとき（
~CSSOMの
<a href="~CSSOM1#serializing-css-values">§~CSS値の直列化-法</a>
を見よ）には、［
`page-break-before^p, `break-before^p
］のどちらが指定されようが，直列化する略式として `page-break-before^p ~propが選ばれることは決してなく、
常に `break-before^p が選ばれることになる。
◎
Setting page-break-before: always expands to break-before: page at parse time, like other shorthands do. Similarly, if break-before: page is set, calling getComputedStyle(el).pageBreakBefore will return "always". However, when serializing a style block (see CSSOM 1 §5.7.2 Serializing CSS Values), the page-break-before property will never be chosen as the shorthand to serialize to, regardless of whether it or break-before was specified; instead, break-before will always be chosen.
</p>
	</dd>
</dl>

		</section>
		<section id="all-shorthand">
<h3 title="Resetting All Properties: the all property">3.2. すべての~propを設定し直す： `all^p ~prop</h3>

◎名 `all@p
◎値 `initial$v | `inherit$v | `unset$v | `revert$v
◎初 個々の~propを見よ
◎適 個々の~propを見よ
◎継 個々の~propを見よ
◎百 個々の~propを見よ
◎算 個々の~propを見よ
◎ア 個々の~propを見よ
◎順 文法に従う
◎表終

<p>
`all$p ~propは、［
`direction$p, `unicode-bidi$p
］を除く，`すべての~CSS~prop^emを設定し直す`略式~prop$である。
`~CSS全域~keyword$のみが，その値として受容される。
また、`~custom~prop$は設定し直さない
`css-variables-1$r
。
◎
The all property is a shorthand that resets all CSS properties except direction and unicode-bidi. It only accepts the CSS-wide keywords. It does not reset custom properties [css-variables-1].
</p>

<p class="note">
除かれた［
`direction$p, `unicode-bidi$p
］~propは、実際には~markup~levelの特能であり，
<a href="~CSSWM#text-direction">作者~stylesheetには設定されるべきでない</a>
（それらは、~UAが~supportしていない文書~言語を~styleするための~CSS~propとしてのみ存在する）
`css-writing-modes-3$r
。
作者は、~HTMLの `dir$a 属性などの，適切な~markupを代わりに利用するべきである。
◎
Note: The excepted CSS properties direction and unicode-bidi are actually markup-level features, and should not be set in the author’s style sheet. (They exist as CSS properties only to style document languages not supported by the UA.) Authors should use the appropriate markup, such as HTML’s dir attribute, instead. [css-writing-modes-3]
</p>

<div class="example">

<p>
例えば，要素~上に
<code class="css">`all$p: `initial^v;</code>
が指定された場合、すべての継承は阻まれ，その要素の すべての~propは［
作者, 利用者, UA
］~levelの~cascadeの中に一切の規則が現れなかったかのように，設定し直されることになる。
◎
For example, if an author specifies all: initial on an element it will block all inheritance and reset all properties, as if no rules appeared in the author, user, or user-agent levels of the cascade.
</p>

<p>
これは、~page外の~styleの継承が望まれないような，~page内に含められた “~widget” の根~要素に有用になり得る。
ただし、その要素に適用される “既定の” ~style（例えば
`div^e などの塊~要素に対し，~UA~stylesheetからあてがわれる
<code class="css">`display$p: `block^v;</code>
など）も，吹飛ばされることに注意。
◎
This can be useful for the root element of a "widget" included in a page, which does not wish to inherit the styles of the outer page. Note, however, that any "default" style applied to that element (such as, e.g. display: block from the UA style sheet on block elements such as &lt;div&gt;) will also be blown away.
</p>

</div>

		</section>
	</section>
	<section id="value-stages">
<h2 title="Value Processing">4. 値の処理</h2>

<p>
~UAは、文書を構文解析して文書~treeを構築し終えたならば，~tree内のどの要素に対しても，および 対応する整形~構造の中のどの~boxに対しても、その~propのうち，~~目的の媒体~型を適用~対象にするものすべてに対し，値をアテガうモノトスル。
◎
Once a user agent has parsed a document and constructed a document tree, it must assign, to every element in the tree, and correspondingly to every box in the formatting structure, a value to every property that applies to the target media type.
</p>

<p>
所与の［
要素／~box
］の~CSS~propの最終的な値は、次の様な複数の段階を経て計算される：
◎
The final value of a CSS property for a given element or box is the result of a multi-step calculation:
</p>

<ol>
	<li>
最初に、各 要素に対し，要素を`適用-対象$とする各~propに対し，［
`要素に適用され$る`宣言d値$
］すべてが収集される。
そのような`宣言d値$は、各~要素の各~propごとに，
0 個以上いくつでもあり得る。
◎
First, all the declared values applied to an element are collected, for each property on each element. There may be zero or many declared values applied to the element.
</li>
	<li>
`~cascade法$により，`~cascaded値$を得る。
どの要素にも，`~cascaded値$は~propごとに
0 個または 1 個だけある。
◎
Cascading yields the cascaded value. There is at most one cascaded value per property per element.
</li>
	<li>
`~default法$により，`指定d値$を得る。
どの要素にも，`指定d値$は~propごとに 1 個だけある。
◎
Defaulting yields the specified value. Every element has exactly one specified value per property.
</li>
	<li>
値の依存性【百分率など】を解決して，`算出d値$を得る。
どの要素にも，`算出d値$は~propごとに 1 個だけある。
◎
Resolving value dependencies yields the computed value. Every element has exactly one computed value per property.
</li>
	<li>
文書の整形【~layoutなど】を経ることで，`使用~値$を得る。
要素の~propに`使用~値$があるのは、要素が~propの`適用-対象$である場合に限られる。
◎
Formatting the document yields the used value. An element only has a used value for a given property if that property applies to the element.
</li>
	<li>
最後に，`使用~値$は、表示~環境による拘束に基づいて，`実際の値$に変形される。
`使用~値$と同じく、`実際の値$があるのは，要素が~propの`適用-対象$である場合に限られる。
◎
Finally, the used value is transformed to the actual value based on constraints of the display environment. As with the used value, there may or may not be an actual value for a given property on an element.
</li>
</ol>

		<section id="declared">
<h3 title="Declared Values">4.1. 宣言d値</h3>

<p>
`要素に適用され$る各~prop宣言が、その要素の~prop用の
`宣言d値@
（ `declared value^en ）を与える。
詳細は、
<a href="#filtering">§ 宣言の絞込み</a>
を見よ。
◎
Each property declaration applied to an element contributes a declared value for that property associated with the element. See Filtering Declarations for details.
</p>

<p>
これらの値から、`~cascade$による処理を経て，
1 個の “最優先な値” が~~選定される。
◎
These values are then processed by the cascade to choose a single “winning value”.
</p>

		</section>
		<section id="cascaded">
<h3 title="Cascaded Values">4.2. ~cascaded値</h3>

<p>
`~cascaded値@
（ `cascaded value^en ）は、`~cascade$の結果を表現する。
それは、一連の`宣言d値$から，~cascadeを経て（`~cascadeの出力$の中で~sortされて）~~選定された値である。
`~cascadeの出力$が空になる場合、`~cascaded値$は無い。
◎
The cascaded value represents the result of the cascade: it is the declared value that wins the cascade (is sorted first in the output of the cascade). If the output of the cascade is an empty list, there is no cascaded value.
</p>

		</section>
		<section id="specified">
<h3 title="Specified Values">4.3. 指定d値</h3>

<p>
`指定d値@
（ `specified value^en ）は、~stylesheet作者が要素の~propに意図した値である。
多くの事例では，`~cascaded値$が`指定d値$になるが、`~cascaded値$が無い場合は，`~default法$を通して`指定d値$が~~導出される
— これにより、どの要素のどの~propにも，`指定d値$の存在が保証される。
~propの`~cascaded値$が`~CSS全域~keyword$である場合、特別に取扱われ，`指定d値$を その~keywordから要求される値に設定する。
<a href="#defaulting-keywords">§ 明示的な~default法</a>
を見よ。
◎
The specified value is the value of a given property that the style sheet authors intended for that element. It is the result of putting the cascaded value through the defaulting processes, guaranteeing that a specified value exists for every property on every element.
◎
In many cases, the specified value is the cascaded value. However, if there is no cascaded value at all, the specified value is defaulted. The CSS-wide keywords are handled specially when they are the cascaded value of a property, setting the specified value as required by that keyword, see § 7.3 Explicit Defaulting.
</p>

		</section>
		<section id="computed">
<h3 title="Computed Values">4.4. 算出d値</h3>

<p>
`算出d値@
（ `computed value^en ）とは、
`指定d値$を，~prop定義表の “算出d値” 欄に従って解決した結果である。
一般に，指定d値は`継承$による伝播の際に絶対~化される。
◎
The computed value is the result of resolving the specified value as defined in the “Computed Value” line of the property definition table, generally absolutizing it in preparation for inheritance.
</p>

<p class="trans-note">【
各種~CSS仕様において、単に
“%foo ~propの値”
と記されたときは，およそ，算出d値を指し（ “〜に算出される” という句も同様）、
“%foo ~propに`指定された^em値”
と記されたときは，およそ，指定d値を指すと見受けられる。
しかしながら、どちらを指すかは文脈に応じて判断する必要もあるかもしれない。
あるいは、どちらに解釈しようが結果は同じになる場合も，単に “~propの値” と記されることもあろう。
】</p>

<p class="note">注記：
`継承$において親から子へ転送される値は、`指定d値$ではなく`算出d値$である。
歴史的な理由から、
`getComputedStyle()$c 関数 `CSSOM$r
は，`算出d値$を返すとは限らず，`使用~値$を返すこともある
【この関数が返す値は`解決d値$と呼ばれる】
。
`算出d値$は，抽象的な~data表現であり、その定義は，~data表現を反映する
— ~dataがどう直列化されるかではなく。
例えば、直列化の規則には，構文解析の間に黙示された ある種の値を省略できるようにしているものが多いが、そのような値であっても`算出d値$の一部を成す。
◎
Note: The computed value is the value that is transferred from parent to child during inheritance. For historical reasons, it is not necessarily the value returned by the getComputedStyle() function, which sometimes returns used values. [CSSOM] Furthermore, the computed value is an abstract data representation: their definitions reflect that data representation, not how that data is serialized. For example, serialization rules often allow omitting certain values which are implied during parsing; but those values are nonetheless part of the computed value.
</p>

<div class="example">
<p>
`指定d値$は、絶対的な値（すなわち、
`red^v や `2mm^v
など，別の値に相対的でない値）
または相対的な値（すなわち、
`auto^v や `2em^v
など，別の値に相対的な値）のいずれもとり得る。
一般に、相対的な値から算出d値を得るときは，絶対~化される：
◎
A specified value can be either absolute (i.e., not relative to another value, as in red or 2mm) or relative (i.e., relative to another value, as in auto, 2em). Computing a relative value generally absolutizes it:
</p>
<ul>
	<li>
相対的~単位（
`em$u, `ex$u, `vh$u, `vw$u
）を伴う値は、適切な基準~sizeを乗算して絶対~化するモノトスル。
◎
values with relative units (em, ex, vh, vw) must be made absolute by multiplying with the appropriate reference size
</li>
	<li>
一定の~keyword（例えば
`smaller^v, `bolder^v
）は、それらの定義に則って置換するモノトスル。
◎
certain keywords (e.g., smaller, bolder) must be replaced according to their definitions
</li>
	<li>
一部の~propに対する百分率~値は、（~propにて定義される）基準~値と乗算するモノトスル。
◎
percentages on some properties must be multiplied by a reference value (defined by the property)
</li>
	<li>
妥当な相対~URLは、絶対~URLに解決するモノトスル。
◎
valid relative URLs must be resolved to become absolute.
</li>
</ul>

<p>
<a href="#stages-examples">下の表</a>の
例 (f), (g), (h) を見よ。
◎
See examples (f), (g) and (h) in the table below.
</p>

</div>

<div class="note">
<p>注記：
一般に，`指定d値$を解決して`算出d値$を得る際には、文書の~layoutや，他の重い, あるいは並列化し難い演算
— ~network~requestを解決したり, 要素やその親 以外から値を検索取得するなど —
は、アリな限り~~避けられている。
◎
Note: In general, the computed value resolves the specified value as far as possible without laying out the document or performing other expensive or hard-to-parallelize operations, such as resolving network requests or retrieving values other than from the element and its parent.
</p>

<p class="trans-note">【
言い換えれば，算出d値は、概ね，~stylesheet, 文書~tree, その他の確定的な情報のみから決定でき，（~layout開始時には未知な）他の要因からは左右されない値を表す。
】【
参考：
~CSSによる~animationや遷移における値の補間は、
<a href="~CSSVAL#combining-values">算出d値に基づいて行われる</a>。
】</p>
</div>

<p>
`算出d値$は、要素が~propの`適用-対象$でないとしても，存在する。
しかしながら、要素が`適用-対象$であるかどうかに応じて，`算出d値$の決定-法が変化する~propもある。
◎
The computed value exists even when the property does not apply. However, some properties may change how they determine the computed value based on whether the property applies to the element.
</p>

		</section>
		<section id="used">
<h3 title="Used Values">4.5. 使用~値</h3>

<p>
`使用~値@
（ `used value^en ）は、`算出d値$を［
文書の整形に利用される絶対的な理論的な値
］に仕上げる計算を完了した結果である。
◎
The used value is the result of taking the computed value and completing any remaining calculations to make it the absolute theoretical value used in the formatting of the document.
</p>

<p class="trans-note">【
他の各種~CSS仕様によく現れる， “使用〜（ `used^en 〜）” のような句も、同様の概念を表すと見られる。
<small>（
<a href="index.html#spec-list-css">この~siteの CSS 関連の日本語訳</a>
に現れる語 “使用” は、~~原則的に，この意味と考えられる `used^en の対訳に限って利用している。
他の意味の `used^en には、別の対訳（ “利用される” など）が利用されるが、中には，この意味の “使用” を指すものもあるかもしれない。
）</small>
】</p>

<p class="example">
例えば，宣言
<code class="css">`width$p: `auto^v</code>
は、要素の先祖の~layoutを知ることなしには，長さに解決され得ない。
したがって`使用~値$は `100px^v のような絶対的な長さになる一方で，`算出d値$は `auto^v になる。
`CSS2$r
◎
For example, a declaration of width: auto can’t be resolved into a length without knowing the layout of the element’s ancestors, so the computed value is auto, while the used value is an absolute length, such as 100px. [CSS2]
</p>

<p class="example">
別の例として，
`div^e は `break-before$p の算出d値に `auto^v をとり得るが、その使用~値
`page^v
を，その最初の子からの伝播を通して獲得する。
`css-break-3$r
◎
As another example, a &lt;div&gt; might have a computed break-before value of auto, but acquire a used break-before value of page by propagation from its first child. [css-break-3]
</p>

<p>
~propは、その
`適用-対象@
— すなわち，その~prop定義表の “適用対象” 欄に挙げられているもの —
以外の型の［
要素／~box
］に対しては，整形~効果は無く、したがって，その~prop用の`使用~値$も無い。
◎
If a property does not apply to this element or box type—as noted in its “Applies to” line—then it has no formatting effect on that type of box or element, and therefore has no used value for that property.
</p>

<p class="trans-note">【
個々の~prop`宣言^emが “`要素に適用され$る” のとは、意味が異なることに注意（そのことを明確化するため，この訳では語尾に “対象” を付与している）。
】【
`適用-対象$には、［
要素／~box
］以外もあり得る。
特に， “~text” が挙げられた場合、要素が~boxを生成しないときでも，その内容は具現化される場合には（
<code class="css">`display$p: `contents^v</code>
），内容を成す~textに対し整形~効果があることを表す。
】</p>

<p class="example">
例えば， `flex$p ~propは、`~flex駒$でない要素に対しては`使用~値$は無い。
◎
For example, the flex property has no used value on elements that aren’t flex items.
</p>

<p class="note">注記：
~propのうち， “すべての要素” に適用されるものと定義されたものは、すべての［
要素~型／`表示~型$
］に適用されるが，どの`疑似要素$~型にも適用されるとは限らない
— 疑似要素には、自前の特有な具現化~modelや他の制約があることが多いので。
しかしながら，［
`before$pe ／ `after$pe
］疑似要素は、通常の要素と ほぼ違わない~boxを生成するものと定義されるので，
“すべての要素” に適用される~propすべてを受容するものと定義される。
`疑似要素$についての更なる情報は `CSS-PSEUDO-4$r を見よ。
◎
Note: A property defined to apply to “all elements” applies to all elements and display types, but not necessarily to all pseudo-element types, since pseudo-elements often have their own specific rendering models or other restrictions. The ::before and ::after pseudo-elements, however, are defined to generate boxes almost exactly like normal elements and are therefore defined accept all properties that apply to “all elements”. See [CSS-PSEUDO-4] for more information about pseudo-elements.
</p>

		</section>
		<section id="actual">
<h3 title="Actual Values">4.6. 実際の値</h3>

<p>
`使用~値$は、原則として，【具現化-用に】利用する準備が整った値であるが、所与の環境においては直に用立てれないこともある。
例えば~UAは，整数幅の画素境界にしか描画できないかもしれず、その場合，`使用~値$による幅を近似させる必要も生じ得る。
あるいは，要素の~font~sizeは、~fontの可用性や
`font-size-adjust$p ~prop値に基づいて，調整を要する。
`実際の値@
（ `actual value^en ）とは、使用~値に そのような調整を施した後の値である。
◎
A used value is in principle ready to be used, but a user agent may not be able to make use of the value in a given environment. For example, a user agent may only be able to render borders with integer pixel widths and may therefore have to approximate the used width. Also, the font size of an element may need adjustment based on the availability of fonts or the value of the font-size-adjust property. The actual value is the used value after any such adjustments have been made.
</p>

<p class="trans-note">【
`実際の値$は、概念的には，~CSSが定義する~modelからは決定し得ない外部の要因も織り込んだ結果と捉えられる。
そのため、この用語が他の~CSS仕様に現れることは，ほとんどない
— ~CSSからは、具体的な要件として定義し得ないので（実際の値に基づくような挙動は別として）。
】</p>

<p class="note">注記：
要素の実際の値を調べれば、文書の~layoutについて多くを知れる。
しかしながら、すべての情報が実際の値に記録されるわけではない。
例えば， `page-break-after$p ~propの実際の値は、要素の後に~page分断があるかどうかを反映しない。
同様に， `orphans$p の実際の値は、要素の中の実際の orphan 行数を反映しない。
<a href="#stages-examples">下の表</a>の例 (j), (k) を見よ。
◎
Note: By probing the actual values of elements, much can be learned about how the document is laid out. However, not all information is recorded in the actual values. For example, the actual value of the page-break-after property does not reflect whether there is a page break or not after the element. Similarly, the actual value of orphans does not reflect how many orphan lines there is in a certain element. See examples (j) and (k) in the table below.
</p>

		</section>
		<section id="stages-examples">
<h3 title="Examples">4.7. 例</h3>

<div style="overflow:auto;">
<table class="data" id="_samples_matrix">
<caption>
~CSS値の算出の例
— 指定d値~列の “†” は初期~値
◎
Examples of CSS Value Computation
</caption>

<thead><tr><th>
<th style="min-width:12em;">~prop
<th><span >~~選定された宣言</span>
<th>~cascaded値
<th>指定d値
<th>算出d値
<th>使用~値
<th>実際の値
</thead>

<!-- 
Property
Winning declaration
Cascaded value
Specified value
Computed value
Used value
Actual value
-->

<tbody><tr><td>(a)
<th>`text-align$p
<td><code class="css">text-align: left</code>
<td>`left^v
<td>`left^v
<td>`left^v
<td>`left^v
<td>`left^v

<tr><td>(b)
<th>`border-top-width$p,<br>`border-right-width$p,<br>`border-bottom-width$p,<br>`border-left-width$p
<td><code class="css">border-width: inherit</code>
<td>`inherit$v
<td class="say">`4.2px^v
<td>`4.2px^v
<td>`4.2px^v
<td>`4px^v

<tr><td>(c)
<th>`width$p
<td><small title="(none)">(なし)</small>
<td><small title="(none)">(なし)</small>
<td>`auto^v†
<td>`auto^v
<td>`120px^v
<td>`120px^v

<tr><td>(d)
<th>`list-style-position$p
<td><code class="css">list-style-position: inherit</code>
<td>`inherit$v
<td class="say">`inside^v
<td>`inside^v
<td>`inside^v
<td>`inside^v

<tr><td>(e)
<th>`list-style-position$p
<td><code class="css">list-style-position: initial</code>
<td>`initial$v
<td>`outside^v†
<td>`outside^v
<td>`outside^v
<td>`outside^v

<tr><td>(f)
<th>`font-size$p
<td><code class="css">font-size: 1.2em</code>
<td>`1.2em^v
<td>`1.2em^v
<td class="say">`14.1px^v
<td>`14.1px^v
<td>`14px^v

<tr><td>(g)
<th>`width$p
<td><code class="css">width: 80%</code>
<td>`80%^v
<td>`80%^v
<td>`80%^v
<td class="say">`354.2px^v
<td>`354px^v

<tr><td>(h)
<th>`width$p
<td><code class="css">width: auto</code>
<td>`auto^v
<td>`auto^v
<td>`auto^v
<td class="say">`134px^v
<td>`134px^v

<tr><td>(i)
<th>`height$p
<td><code class="css">height: auto</code>
<td>`auto^v
<td>`auto^v
<td>`auto^v
<td class="say">`176px^v
<td>`176px^v

<tr><td>(j)
<th>`page-break-after$p
<td><small>(なし)</small>
<td><small>(なし)</small>
<td>`auto^v†
<td>`auto^v
<td>`auto^v
<td>`auto^v

<tr><td>(k)
<th>`orphans$p
<td><code class="css">orphans: 3</code>
<td>`3^v
<td>`3^v
<td>`3^v
<td>`3^v
<td>`3^v
</tbody></table></div>

			</section>
		</section>
	<section id="filtering">
<h2 title="Filtering">5. 絞込み</h2>

<p>
`宣言d値$を見出すためには、実装はまず，各~要素ごとに`要素に適用され$るすべての宣言を識別するモノトスル。
所与の宣言は、次【のすべて】が満たされるならば
`要素に適用され@
る：
◎
In order to find the declared values, implementations must first identify all declarations that apply to each element. A declaration applies to an element if:
</p>
<ul>
	<li>
当の文書に現在 適用されている~stylesheetに属している。
◎
It belongs to a style sheet that currently applies to this document.
</li>
	<li>
`偽^i に評価される`条件付き~group規則$ `CSS3-CONDITIONAL$r により~~除外されていない。
◎
It is not qualified by a conditional rule [CSS3-CONDITIONAL] with a false condition.
</li>
	<li>
それが属する~style規則の`選択子$は、要素に合致している。
`SELECT$r
◎
It belongs to a style rule whose selector matches the element. [SELECT]
</li>
	<li>
構文として妥当である
— すなわち，宣言の~propは既知な~prop名であり, かつ 宣言の値は その~propの構文に合致している。
◎
It is syntactically valid: the declaration’s property is a known property name, and the declaration’s value matches the syntax for that property.
</li>
</ul>

<p>
これらの適用される宣言の値が、各~要素の各~prop用の`宣言d値$の~listを成す。
この~list内のどれが選ばれるかは、次節の`~cascade法$にて与えられる。
◎
The values of the declarations that apply form, for each property on each element, a list of declared values. The next section, the cascade, prioritizes these lists.
</p>

	</section>
	<section id="cascading">
<h2 title="Cascading">6. ~cascade法</h2>

<p>
`~cascade@
（~cascade~~処理）は、［
所与の要素の所与の~prop用の`宣言d値$たちが成す，無順序~list
］から、以下に従って決定される優先順位により，それらの宣言を~sortした上で、
【その中で最も優先度の高い】
単独の`~cascaded値$を出力する。
◎
The cascade takes an unordered list of declared values for a given property on a given element, sorts them by their declaration’s precedence as determined below, and outputs a single cascaded value.
</p>

		<section id="cascade-sort">
<h3 title="Cascade Sorting Order">6.1. ~cascadeの~sort順序</h3>

<p>
~cascadeにおいては、宣言たちは，以下の判定基準に則って~sortされる
— 先に示すものほど，後続の判定基準より優先される：
◎
The cascade sorts declarations according to the following criteria, in descending order of priority:
</p>

<dl class="def-list">
	<dt>
`出自と重要度@cC
（ `origin^en と `importance^en ）
◎
Origin and Importance
</dt>
	<dd>
<p>
宣言が属する`出自$は、~~字義通りの~~意味に基づく。
宣言が`~importantな宣言$になるかどうかは、
`!important$css を伴って宣言されているかどうかに基づく。
各種`出自$【と`~important$が成す組】の優先順位は、高いものから順に，次で与えられる：
◎
The origin of a declaration is based on where it comes from and its importance is whether or not it is declared with !important (see below). The precedence of the various origins is, in descending order:
</p>
		<ol>
			<li>
遷移~宣言 `css-transitions-1$r
◎
Transition declarations [css-transitions-1]
</li>
			<li>
`~UA出自$に属する`~importantな宣言$
◎
Important user agent declarations
</li>
			<li>
`利用者~出自$に属する`~importantな宣言$
◎
Important user declarations
</li>
			<li>
`作者~出自$に属する`~importantな宣言$
◎
Important author declarations
</li>
			<li>
~animation宣言 `css-animations-1$r
◎
Animation declarations [css-animations-1]
</li>
			<li>
`作者~出自$に属する`通常の宣言$
◎
Normal author declarations
</li>
			<li>
`利用者~出自$に属する`通常の宣言$
◎
Normal user declarations
</li>
			<li>
`~UA出自$に属する`通常の宣言$
◎
Normal user agent declarations
</li>
		</ol>

<p>
上の~listの中で，より先に挙げた`出自$に属する宣言が より後に挙げた`出自$に属する宣言よりも優先される。
◎
Declarations from origins earlier in this list win over declarations from later origins.
</p>

<p class="trans-note">【
~importantの有無により，［
作者／利用者／~UA
］宣言の優先順位は逆になる。
】</p>

	</dd>

	<dt>
`文脈@cC
（ `context^en ）
◎
Context
</dt>
	<dd>
文書~言語は、相異なる
`~encapsulation文脈@
を源とする宣言たちを混ぜ合わせる~~仕組みを供することもある
— ~DOM【！`DOM$r】内の`~shadow~tree$を成す入子な`~tree文脈$など。
◎
A document language can provide for blending declarations sourced from different encapsulation contexts, such as the nested tree contexts of shadow trees in the [DOM].
</dd>
	<dd>
<p>
異なる`~encapsulation文脈$ %A, %B を源とする宣言どうしを比較する場合、
%A が %B を入子にしているならば
⇒＃
`通常の宣言$どうしでは， %A を源とする宣言が優先される／
`~importantな宣言$どうしでは， %B を源とする宣言が優先される
◎
When comparing two declarations that are sourced from different encapsulation contexts, then for normal rules the declaration from the outer context wins, and for important rules the declaration from the inner context wins.＼
</p>

<p class="trans-note">【
間接的に入子にしている場合、推移的に定義されることになる。
】【
“源とする” とは，具体的には、当の宣言は［
その文脈から~linkされた／その文脈に埋込まれた
］~stylesheet内にある（あるいは、その文脈~内の ある要素の`~style属性$内にある）ことを意味する。
】</p>

<p>
この目的においては、~DOMを成す`~tree文脈$は，`~shadowも含む~tree順序$で入子にされるものと見なされる。
◎
For this purpose, [DOM] tree contexts are considered to be nested in shadow-including tree order.
</p>

<p class="note">注記：
このことは、実質的に，次を意味する
⇒
`~encapsulation文脈$に属する宣言のうち
⇒＃
`通常の宣言$は，外縁~文脈（ %A ）から容易に上書きできる既定を設定できる／
`~importantな宣言$は，外縁~文脈からは上書きし得ない要件を施行できる
◎
Note: This effectively means that normal declarations belonging to an encapsulation context can set defaults that are easily overridden by the outer context, while important declarations belonging to an encapsulation context can enforce requirements that cannot be overridden by the outer context.
</p>
	</dd>

	<dt>
`~style属性@cC
（ `style attribute^en ）
◎
The Style Attribute
</dt>
	<dd>
要素に直に付与された宣言（
<a href="~CSSSTYLEATTR#interpret">~style属性の内容</a>など）は、［
`選択子$を介して要素に対応付けられる~style規則
］に属する他の宣言のうち［
同じ`重要度$cC（`通常の宣言$／`~importantな宣言$）を伴うもの
］より優先される。
◎
Separately for normal and important declarations, declarations that are attached directly to an element (such as the contents of a style attribute) rather than indirectly mapped by means of a style rule selector take precedence over declarations the same importance that are mapped via style rule.
</dd>

	<dt>
`層@cC
（ `layer^en ）
◎
Layers
</dt>
	<dd>
各［
`出自$cC／`文脈$cC
］の中の宣言は、ある`~cascade層$に明示的にアテガうこともできる。
この段の目的においては、
`未層@
（ `un-layered^en ）な宣言
— 明示的な層にアテガわれていない宣言 —
は、暗黙的な最終-層に追加される。
◎
Declarations within each origin and context can be explicitly assigned to a cascade layer. For the purpose of this step, any declaration not assigned to an explicit layer is added to an implicit final layer.
</dd>
	<dd>
~cascade層は、（宣言の様に）出現順序により順序付けられる。
異なる`~cascade層$に属する宣言どうしを比較するときは
⇒＃
`通常の宣言$どうしでは，より後の層に属する方が優先される／
`~importantな宣言$どうしでは，より前の層に属する方が優先される
【`通常の宣言$と`~importantな宣言$の比較は、`重要度$cCに従うことになる。】
◎
Cascade layers (like declarations) are ordered by order of appearance. When comparing declarations that belong to different layers, then for normal rules the declaration whose cascade layer is last wins, and for important rules the declaration whose cascade layer is first wins.
</dd>
	<dd class="note">注記：
これは、`通常の宣言$と`~importantな宣言$を別々な層に分けるために利用される`~important$な`出自$と同じ~logicに従う
— どちらの設定に対しても， `!important$css ~flagは同じ “上書き” の目的を保守するよう。
◎
Note: This follows the same logic used for layering normal and important origins, so that the !important flag maintains the same “override” purpose in both settings.
</dd>

	<dt>
`詳細度@cC
（ `specificity^en ）
◎
Specificity
</dt>
	<dd>
各 宣言は、それが現れる~style規則の`選択子$と同じ詳細度を有する。
選択子の
<a href="~SELECTORS4#specificity">詳細度を算出する方法</a>
は、
`SELECT$r にて述べられている。
詳細度が高いものほど優先される。
◎
The Selectors module [SELECT] describes how to compute the specificity of a selector. Each declaration has the same specificity as the style rule it appears in. The declaration with the highest specificity wins.
</dd>

	<dt>
`出現順序@cC
（ `order of appearance^en ）
◎
Order of Appearance
</dt>
	<dd>
<p>
文書~順序
【~stylesheet内に現れる順序】
において より後に現れる宣言ほど優先される。
この目的においては：
◎
The last declaration in document order wins. For this purpose:
</p>
		<ul>
			<li>
`import$at 規則で~importされた~stylesheet内の宣言は、その規則が その~stylesheetで代用されたかのように，順序付けられる。
◎
Declarations from imported style sheets are ordered as if their style sheets were substituted in place of the @import rule.
</li>
			<li>
大元の文書から独立に~linkされた複数の~stylesheet内の宣言は、それらの~stylesheetが，~host文書~言語により決定される~link順で連結されたかのように扱われる。
◎
Declarations from style sheets independently linked by the originating document are treated as if they were concatenated in linking order, as determined by the host document language.
</li>
			<li>
`~style属性$内の宣言は、その属性が現れた要素たちの文書~順序に則って順序付けられ，どの~stylesheetよりも後に置かれる。
◎
Declarations from style attributes are ordered according to the document order of the element the style attribute appears on, and are all placed after any style sheets.
</li>
		</ul>
	</dd>
</dl>

<p>
`~cascadeの出力@
は、各~要素の各~prop用のすべての`宣言d値$を，この節に述べた規則に従って~sortした~listである（空にもなり得る）。
◎
The output of the cascade is a (potentially empty) sorted list of declared values for each property on each element.
</p>

		</section>
		<section id="cascading-origins">
<h3 title="Cascading Origins">6.2. ~cascade法における出自</h3>

<p>
各~style規則には、
`出自@
（ `cascade origin^en ）がある
— それは、規則が~cascadeのどの段階に入るかを決定する。
~CSSは、中核的な`出自$として，次の 3 種を定義する：
◎
Each style rule has a cascade origin, which determines where it enters the cascade. CSS defines three core origins:
</p>

<dl class="def-list">
	<dt>
`作者~出自@
（ `author origin^en ）
◎
Author Origin
</dt>
	<dd>
文書~言語の規約に則って，~source文書~用に作者が指定する~stylesheet。
例えば~HTMLでは，文書~内に含められたり, 外部へ~linkされ得る。
◎
The author specifies style sheets for a source document according to the conventions of the document language. For instance, in HTML, style sheets may be included in the document or linked externally.
</dd>

	<dt>
`利用者~出自@
（ `user origin^en ）
◎
User Origin
</dt>
	<dd>
利用者は、個々の文書~用に，~style情報を指定することもある。
例えば，利用者が~stylesheetを包含する~fileを指定することもあれば、
~UAが利用者~stylesheet（あるいはそのように挙動するもの）を生成する~UIを供することもある。
◎
The user may be able to specify style information for a particular document. For example, the user may specify a file that contains a style sheet or the user agent may provide an interface that generates a user style sheet (or behaves as if it did).
</dd>

	<dt>
`~UA出自@
（ `user agent origin^en ）
◎
User-Agent Origin
</dt>
	<dd>
適合~UAは、既定の~stylesheet（あるいはそのように挙動するもの）を適用するモノトスル。
~UAの既定の~stylesheetは、文書~言語の要素を，文書~言語にて一般に期待されている呈示を満たす仕方で呈示するべきである（例えば 視覚系~browserは，~HTMLの `em^e 要素を~italic~fontで呈示するなど）
— 例：
<a href="~HTMLrendering#the-css-user-agent-style-sheet-and-presentational-hints">~HTMLの~UA~stylesheet</a>
`HTML$r。
◎
Conforming user agents must apply a default style sheet (or behave as if they did). A user agent’s default style sheet should present the elements of the document language in ways that satisfy general presentation expectations for the document language (e.g., for visual browsers, the EM element in HTML is presented using an italic font). See e.g. the HTML user agent style sheet. [HTML]
</dd>
</dl>

<p class="trans-note">【
この仕様も含む~CSS仕様 全般にわたり、この出自を指して，
“〜`~levelの^em~style” と記されたり，（
“作者`~levelの^em…” , “~UA`~levelの^em…”
等々），更に省略して
“利用者~style”,
等々と記されることが多い。
】</p>

<p>
~CSSに対する拡張は、次に挙げる追加的な`出自$も定義する：
◎
Extensions to CSS define the following additional origins:
</p>

<dl class="def-list">
	<dt>
`~animation出自@
（ `animation origin^en ）
◎
Animation Origin
</dt>
	<dd>
CSS Animations `css-animations-1$r
は、稼働中にその効果を表現する， “virtual” 規則を生成する。
◎
CSS Animations [css-animations-1] generate “virtual” rules representing their effects when running.
</dd>

	<dt>
`遷移~出自@
（ `transition origin^en ）
◎
Transition Origin
</dt>
	<dd>
CSS Animations 同様，
CSS Transitions `css-transitions-1$r
も、稼働中にその効果を表現する， “virtual” 規則を生成する。
◎
Like CSS Animations, CSS Transitions [css-transitions-1] generate “virtual” rules representing their effects when running.
</dd>
</dl>

		</section>
		<section id="importance">
<h3 title="Important Declarations: the !important annotation">6.3. ~important宣言： `!important^css</h3>

<p>
~CSSでは、作者~stylesheetと利用者~stylesheetの力関係も~~考慮されている。
既定では、作者~stylesheet内の規則が利用者~stylesheet内のそれを上書きし，利用者~stylesheet内の規則が~UAの既定の~stylesheet内の規則を上書きする。
宣言を`~importantな宣言$にして~cascadeにおける重みを増やすことにより，この優先順位を逆にできる。
◎
CSS attempts to create a balance of power between author and user style sheets. By default, rules in an author’s style sheet override those in a user’s style sheet, which override those in the user-agent’s default style sheet. To balance this, a declaration can be marked important, which increases its weight in the cascade and inverts the order of precedence.
</p>

<p>
宣言のうち、次に該当するものは
`~importantな宣言@
とされ，他のすべては
`通常の宣言@
とされる
⇒
`css-syntax-3$r にて定義されるとおりに `!important^css 注釈を伴う
— すなわち、その値【`declaration-value$t】
の中の最後の 2 個の（空白でも~commentでもない）~tokenは，順に次で与えられている
⇒＃
区切子~token【`delim-token$t】 `!^l,
識別子~token【`ident-token$t】 `important^l
◎
A declaration is important if it has a !important annotation as defined by [css-syntax-3], i.e. if the last two (non-whitespace, non-comment) tokens in its value are the delimiter token ! followed by the identifier token important. All other declarations are normal (non-important).
</p>

<div class="example">

<pre class="lang-css">
[hidden] { display: none !important; }
</pre>

</div>

<p>
`~importantな宣言$は、`通常の宣言$より優先される。
［
作者~stylesheet／利用者~stylesheet
］は`~importantな宣言$を包含してもヨイ。
`利用者~出自$に属する`~importantな宣言$は、`作者~出自$に属する`~importantな宣言$を上書きする。
この~CSS特能を利用すれば、利用者の手による，呈示~制御~用の特別な要件（大きな~font, 色の組合n, 等々）を与えることで、文書の~accessibilityも向上させられる。
◎
An important declaration takes precedence over a normal declaration. Author and user style sheets may contain important declarations, with user-origin important declarations overriding author-origin important declarations. This CSS feature improves accessibility of documents by giving users with special requirements (large fonts, color combinations, etc.) control over presentation.
</p>

<p>
`~importantな宣言$は、その`出自$に関わらず，どの~animationよりも優先される。
これにより、作者は，重要な事例で~animateされた値を上書きできるようになる（~animateされた値は、通常は，他のすべての規則を上書きする）。
`css-animations-1$r
◎
Important declarations from all origins take precedence over animations. This allows authors to override animated values in important cases. (Animated values normally override all other rules.) [css-animations-1]
</p>

<p>
`~UA~stylesheet$も，`~importantな宣言$を包含してヨイ。
これらは、他のすべての［
`作者~出自$／`利用者~出自$
］に属する宣言を上書きする。
◎
User-agent style sheets may also contain important declarations. These override all author and user declarations.
</p>

<div class="example">

<p>
次の例の 利用者~stylesheet内の 1 個目の規則が包含する宣言は、
`!important^css を伴うので，作者~stylesheetの対応する宣言を上書きする。
2 個目の規則についても `!important^css を伴うので同様に優先されることになる。
しかしながら，利用者~stylesheet内の 3 個目の宣言には `!important^css は無いので、作者~stylesheetの中の（`略式~prop$の~styleを設定する） 2 個目の規則の方が優先されることになる。
また、 3 個目の作者~規則より `!important^css を伴う 2 個目の作者~規則の方が優先されることになる。
すなわち， `!important^css を伴う宣言は、同じ作者~stylesheetの中でも機能する。
◎
The first rule in the user’s style sheet in the following example contains an !important declaration, which overrides the corresponding declaration in the author’s style sheet. The declaration in the second rule will also win due to being marked !important. However, the third declaration in the user’s style sheet is not !important and will therefore lose to the second rule in the author’s style sheet (which happens to set style on a shorthand property). Also, the third author rule will lose to the second author rule since the second declaration is !important. This shows that !important declarations have a function also within author style sheets.
</p>

<pre class="lang-css">
/* <span class="comment">
利用者による~stylesheet
◎
From the user’s style sheet
</span> */
p { text-indent: 1em !important }
p { font-style: italic !important }
p { font-size: 18pt }

/* <span class="comment">
作者による~stylesheet
◎
From the author’s style sheet
</span> */
p { text-indent: 1.5em !important }
p { font: normal 12pt sans-serif !important }
p { font-size: 24pt }
</pre>

<table><thead><tr><th>
~prop
◎
Property
<th>最優先な値
◎
Winning value
</thead><tbody>

<tr><th>`text-indent$p
<td>`1em^v

<tr><th>`font-style$p
<td>`italic^v

<tr><th>`font-size$p
<td>`12pt^v

<tr><th>`font-family$p
<td>`sans-serif^v
</tbody></table>

</div>

		</section>
		<section id="layering">
<h3 title="Cascade Layers">6.4. ~cascade層</h3>

<p>
`出自$が作者~styleと利用者~styleの間に力関係を供するのと同じ仕方で、
`~cascade層@
は，同じ`出自$の中での力関係を組織化する有構造な仕方を供する。
作者は、~style付けの懸念になる様々なもの
— ある要素~用の既定, 第三者主体による~library, ~theme, ~component, 上書き, その他 —
に対し，それぞれを表現する~cascade層を作成して、それらを明示的な仕方で順序し直せる
— 各~層の中の選択子や詳細度を改めることも，各~層にまたがる競合を解決するために~source順序に依拠することもなく。
◎
In the same way that cascade origins provide a balance of power between user and author styles, cascade layers provide a structured way to organize and balance concerns within a single origin. Authors can create layers to represent element defaults, third-party libraries, themes, components, overrides, and other styling concerns—and are able to re-order the cascade of layers in an explicit way, without altering selectors or specificity within each layer, or relying on source-order to resolve conflicts across layers.
</p>

<div class="example">

<p>
例えば，次は、`名前$ly `defaults^v を伴う明示的な層を生成する
— その~cascadeにおける重みは、（その前に与える）`未層$な~styleよりも低い：
◎
For example, the following generates an explicit defaults layer, with lower cascade weight than any un-layered styles:
</p>
<pre class="lang-css">
audio {
  /* <span class="comment">
暗黙的な最終-層
— 詳細度 ( 0,0,1 )
◎
specificity of 0,0,1 - implicit (final) layer
</span> */
  display: flex;
}

@layer defaults {
  audio[controls] {
    /* <span class="comment">
明示的な `defaults^v 層
— 詳細度 ( 0,1,1 )
◎
specificity of 0,1,1 - explicit "defaults" layer
</span> */
    display: block;
  }
}
</pre>

<p>
`audio^e 要素~上の`未層$な宣言は、
`audio[controls]^css 上の明示的な~cascade層に属する宣言より優先される
— 前者の方が詳細度は低くても，~source順序で最初に来ていても。
◎
The un-layered declarations on the audio element take precedence over the explicitly layered declarations on audio[controls] —even though the un-layered styles have a lower specificity, and come first in the source order.
</p>
</div>

<p class="issue">
~cascade層~用にも `revert$v に類似な~keywordは必要か？
（ `5793$issue ）
◎
Do we need a keyword similar to `revert`, but for cascade layers? &lt;https://github.com/w3c/csswg-drafts/issues/5793&gt;
</p>


			<section id="at-layer">
<h4 title="Declaring Cascade Layers: the @layer rule">6.4.1. ~cascade層の宣言-法： `layer^at 規則</h4>

<p>
`layer@at
規則は、明示的な`~cascade層$を定義する
— それは、~style規則を［
~block／~import
］としてアテガう：
◎
The @layer rule defines an explicit cascade layer, with the option to assign style rules as either a block or an import.
</p>
<ul>
	<li>
<p>
その~import構文は：
◎
The import syntax is:
</p>

<pre class="prod">
@layer `layer-ident$t? `url$t;
</pre>

<p>
この構文による `layer$at 規則に対する制約と処理は、指示された`~cascade層$にアテガわれることを除けば，
`import$at と同じになる（
<a href="#at-import">§ ~stylesheetの~import法</a>
を見よ）。
◎
Such @layer import rules have the same restrictions and processing as @import (see § 2 Importing Style Sheets: the @import rule), except that the imported rules are assigned to the indicated layer.
</p>

<p class="issue">
`layer$at は多層化される~url~importを取扱う適正な仕方なのか？
（ `5681$issue ）
◎
Is @layer the proper way to handle layered url imports? &lt;https://github.com/w3c/csswg-drafts/issues/5681&gt;
</p>

	</li>
	<li>
<p>
その~block構文は：
◎
The block syntax is:
</p>

<pre class="prod">
@layer `layer-ident$t? {
  `stylesheet$t
}
</pre>

<p>
この構文による `layer$at 規則に対する制約と処理は、
`真^i に評価される`条件付き~group規則$【！条件付き規則】
`CSS-CONDITIONAL-3$r
と同じになる。
◎
Such @layer block rules have the same restrictions and processing as a conditional rule [CSS-CONDITIONAL-3] with a true condition.
</p>
	</li>
</ul>

<p class="trans-note">【
~import構文で~importされた~stylesheet内にある `layer$at 規則は、
<a href="#nested-layers">入子な層</a>を定義するものと解釈されることになる。
~import構文は、~block構文における `stylesheet$t を［
~import構文の `url^t が参照する~stylesheetの内容
］に置換したものと等価になるので。
】</p>

<div>
<p>
どちらの構文においても，省略可能な
`layer-ident@t
は、`~CSS識別子$（ `ident$t ）であり，ある`~cascade層$を識別する
`名前@ly
（ `layer name^en ）を表現する：
</p>
<ul>
	<li>
所与の名前に対し、同じ［
`出自$, `文脈$cC
］（かつ，視野を同じくするもの
— <a href="#nested-layers">§ 入子な層</a>
を見よ）の中で，それを`名前$lyに供する `layer$at 規則のうち
⇒＃
最初に現れるものは，（その名前の）新たな`~cascade層$を作成する／
他のものは，その同じ`~cascade層$に自身の~style規則をアテガう
</li>
	<li>
`名前$lyを供さない `layer$at 規則は、常に，新たな`~cascade層$を作成する。
【したがって，これらは、各 `layer^at ごとに別々な層を成すことになる（前項とは対照的に）。】
</li>
</ul>
◎
In both cases the optional &lt;layer-ident&gt; is a CSS identifier (&lt;ident&gt;) that represents its layer name. If the layer name matches that of a cascade layer already defined within this origin and context (and same layer scope, see § 6.4.1.1 Nested Layers), then its style rules are assigned to that same cascade layer. Otherwise, or if no &lt;layer-ident&gt; is provided, a new cascade layer is created.
</div>

<p class="note">注記：
層の`名前$lyの照合は、~shadow~DOMの境界を越えることはない
— ~light~DOM内の層たちの順序は、~shadow~DOM内の［
それらと`名前$lyが一致する層たち
］の順序には影響iしない。
◎
Note: Layer name matching does not cross the shadow DOM boundary, so the ordering of layers in the light DOM has no impact on the order of identically-named layers in the shadow DOM.
</p>

<p class="issue">
`~cascade層$を複数の`~encapsulation文脈$にまたがって再利用するための構文を供するか？
（ `5854$issue ）
◎
Provide a syntax for re-using cascade layers across encapsulation context? &lt;https://github.com/w3c/csswg-drafts/issues/5854&gt;
</p>

<p>
`layer$at 規則は、`名前$lyのみを供することで，［
~style規則をアテガうことなく新たな`~cascade層$を定義する
］ためにも利用できる：
◎
The @layer rule can also be used to define new layers without assigning any style rules, by providing only a layer name:
</p>

<pre class="prod">
@layer `layer-ident$t;
</pre>

<p>
`名前$lyのみを供する `layer$at 規則†は、他の構文（~import／~block）による `layer^at 規則が許容される所なら，どこでも許容される。
◎
Such empty @layer are allowed anywhere either import @layer or block @layer rules are allowed.
</p>

<p class="trans-note">【†
原文では “空な `layer^at 規則” と称されているが、［
~blockの内容が空な，~block構文による `layer^at 規則
］と紛らわしいので，この訳では直に “名前のみを供する” と記すことにする。
】</p>

<p class="issue">
［
`link$e ／ `style$e
］要素を`~cascade層$にアテガうための属性を供する。
（ `5853$issue ）
◎
Provide an attribute for assigning link or style elements to cascade layers &lt;https://github.com/w3c/csswg-drafts/issues/5853&gt;
</p>

<div class="example">

<p>
~cascade層の`名前$ly【！識別子】は、省略可能ではあるが，単独の層に複数の~style~blockを適用する仕方を供する。
次の例における［
`headings.css^v,
`links.css^v
］の内容は、
`audio[controls]^css 規則と同じ層の中で~cascadeされる：
◎
Layer identifiers are optional, but provide a way to apply multiple style blocks to a single layer. In the following example, the contents of headings.css and links.css are cascaded within the same layer as the audio[controls] rule:
</p>

<pre class="lang-css">@layer default url(headings.css);
@layer default url(links.css);

@layer default {
  audio[controls] {
    display: block;
  }
}
</pre>
</div>

<div class="example">

<p>
`名前$lyのみを供する【！識別子のみの】構文は、層たちの順序を確立することも許容する
— 各~層に~style規則を追加する順序に関わらず。
◎
The identifier-only syntax allows establishing a layer order in advance, regardless of the order in which style rules are added to each layer.
</p>

<p>
次の例では、~importされた `theme.css^v ~style規則は，後で `default^v ~block内に追加される~style規則を上書きすることになる
— これらの層の順序は、すでに確立-済みなので。
◎
In this example, the imported theme.css style rules will override any rules added in the later default block since the order of layers has already been established.
</p>

<pre class="lang-css">@layer default;
@layer theme;
@layer components;

@layer theme url(theme.css);

@layer default {
  audio[controls] {
    display: block;
  }
}
</pre>

<p>
<a href="#at-layers">§ `layers^at 規則</a>
も見よ。
◎
See also § 6.4.2 Layer-Declaring Shorthand: the @layers rule.
</p>
</div>

				<section id="nested-layers">
<h5 title="Nested Layers">6.4.1.1. 入子な層</h5>

<p>
`layer$at 規則が入子にされた場合、その`名前$lyの視野は，その親~層の中に限られる。
◎
When @layer rules are nested, layer names are scoped to their parent layer.
</p>

<div class="example">

<p>
次の例において `framework^v 内に入子にされた `default^v 層は、~top-levelの `default^v 層とは別個になる：
◎
In this example, the nested framework default layer is distinct from the top-level default layer:
</p>

<pre class="lang-css">
@layer default {
  p { max-width: 70ch; }
}

@layer framework {
  @layer default {
    p { margin-block: 0.75em; }
  }

  @layer theme {
    p { color: #222; }
  }
}
</pre>

<p>
結果の各~層は、~treeとして表現できる：
◎
The resulting layers can be represented as a tree:
</p>

<ol>
	<li>
`default^v
</li>
	<li>
<p>
`framework^v
</p>
		<ol>
			<li>
`default^v
</li>
			<li>
`theme^v
</li>
		</ol>
	</li>
</ol>

<p>
あるいは、入子な`名前$ly【！識別子】を伴う平坦な~listとして：
◎
or as a flat list with nested identifiers:
</p>
<ol>
	<li>
`default^v
</li>
	<li>
`framework.default^v
</li>
	<li>
`framework.theme^v
</li>
</ol>
</div>

<p>
入子な層の中から外縁な層を視野にする`名前$lyを参照するのはアリでないが、外縁な視野から入子な層を参照するのはアリである
— それらの`名前$ly【！識別子】を文字
<span class="code-point">U+002E</span>
<span class="cp-name">FULL STOP</span>
（ `.^l ）で結合することにより。
◎
It is not possible for nested layers to reference a layer name in an outer layer’s scope, but it is possible to reference nested layers from an outer scope, by combining identifiers with a full stop (. U+002E) character.
</p>

<div class="example">

<pre class="lang-css">
@layer framework {
  @layer default {
    p { margin-block: 0.75em; }
  }

  @layer theme {
    p { color: #222; }
  }
}

@layer framework.theme {
  /* <span class="comment">
ここに置かれた~styleは、
`framework^v 層の内側にある `theme^v 層に追加されることになる。
◎
These styles will be added to the theme layer inside the framework layer
</span> */
  blockquote { color: rebeccapurple; }
}
</pre>
</div>

<p>
この構文†は、入子な層を定義するための略式として供される。
それは、各`名前$lyを供する `layer$at 規則を順に入子にして宣言するのと同じ効果になる。
◎
This syntax is provided as a shorthand for defining nested layers, and has the same effect as declaring each layer name inside nested @layer rules.
</p>

<p class="trans-note">【†
本当は，この構文~用の生成規則も追加的に定義する必要がある
— `layer-ident$t は、`~CSS識別子$であり，文字 `.^l を許容しないので。
】</p>

<div class="example">

<p>
すなわち，この略式~構文は、［
新たな層を定義する／層たちの順序を確立する
］ためにも利用できる。
◎
That means the shorthand syntax can also be used in defining new layers, and establishing layer order.
</p>

<p>
次の例は、
`framework.default^v より前に，
`framework.theme^v を定義する：
◎
The following example defines framework.theme before framework.default:
</p>

<pre class="lang-css">
@layer framework.theme {
  blockquote { color: rebeccapurple; }
}

@layer framework {
  @layer default {
     p { margin-block: 0.75em; }
  }

  @layer theme {
    p { color: #222; }
  }
}
</pre>

<p>
`framework.theme^v 略式は、純粋に，次の非略式~用の構文~糖衣である：
◎
The framework.theme shorthand is purely syntax sugar for the following longhand:
</p>

<pre class="lang-css">
@layer framework {
  @layer theme {
    blockquote { color: rebeccapurple; }
  }
}
</pre>
</div>

<p class="issue">
入子な層に付加するための適切な構文は何か？
（ `5791$issue ）
◎
What is the appropriate syntax for appending to nested layers? &lt;https://github.com/w3c/csswg-drafts/issues/5791&gt;
</p>

				</section>
				<section id="unnamed-layers">
<h5 title="Un-Named Layers">6.4.1.2. 無名な層</h5>

<div class="example">

<p>
`名前$lyを伴わない~cascade層は、外部から［
配列し直す／~styleを追加する
］ための~hookは供さない。
◎
Layers without an identifier are also added to the layer order when invoked, but only describe a single rule-block or file import without .
</p>

<p>
そのような無名な層は、ほとんどの利用事例では，~~簡潔に記すための構文~糖衣でしかなく、明示的な`名前$lyでなく，きちんと組織化された~source順序に依拠する。
しかしながら、例えば次に利用することもできる
⇒
ある~teamにおいて~codeを組織化する規約を “強制する” 仕方として（例：ある層に属する~codeは、すべて，一箇所で定義しなければならない）／
ある~libraryが［
作者からの操作~用には公開しないよう求まれる，内部的な “~privateな” 層
］を併合して隠したいと求めるとき
◎
In most use-cases this would only be syntax-sugar for brevity —relying on well-organized source-order rather than any explicit names. However, it could be used by teams as a way to "force" an organizing convention (all layer code must be defined in one place), or by libraries wanting to merge &amp; hide a set of internal "private" layers that they don’t want exposed to author manipulation:
</p>

<pre class="lang-css">
/* bootstrap-base.css */
/* <span class="comment">
各~下位-~fileを包装する無名な層
◎
unnamed wrapper layers around each sub-file
</span> */
@layer url(base-forms.css);
@layer url(base-links.css);
@layer url(base-headings.css);

/* bootstrap.css */
/* <span class="comment">
`base^v 層~内に組み込まれた内部的な各~名前は、~accessから隠される。
◎
the intrnal names are hidden from access, subsumed in "base"
</span> */
@layer base url(bootstrap-base.css);

/* author.css */
/* <span class="comment">
作者は、
`bootstrap.base^v 層には~accessできるが，無名な層の中へはできない。
◎
author has access to bootstrap.base layer, but not into unnamed layers
</span> */
@layer bootstrap url(bootstrap.css);
</pre>
</div>

<p class="issue">
無名な~cascade層は許容されるべきか？
（ `5792$issue ）
◎
Should unnamed cascade layers be allowed? &lt;https://github.com/w3c/csswg-drafts/issues/5792&gt;
</p>

			</section>
			<section id="at-layers">
<h4 title="Layer-Declaring Shorthand: the @layers rule">6.4.2. 層を宣言する略式： `layers^at 規則</h4>

<p>
`layers@at
規則は、明示的な`~cascade層$が成す~listを優先度が低いものから順に述べる。
その構文は：
◎
The @layers rule describes a list of explicit cascade layers, in order from lowest to highest priority. Its syntax is:
</p>

<pre class="prod">
@layers `layer-ident$t [, `layer-ident$t]* ;
</pre>

<p>
これは，有名~層の順序を確立するための略式として供される。
その効果は、所与の各`名前$lyに対し，その`名前$lyのみを供する【！empty @layer 】 `layer$at 規則を順に宣言するのと同じになる。
◎
This is provided as a shorthand for establishing the order of named layers, and has the same effect as declaring each layer name in order in its own empty @layer rule.
</p>

<div class="example">

<p>
次の例は、同じ結果になる。
◎
The following examples have the same result.
</p>

<p>
`名前$ly【！識別子】のみを供する複数個の `layer$at 規則を利用している：
◎
Using multiple @layer rules with identifier only:
</p>

<pre class="lang-css">
@layer default;
@layer theme;
@layer components;
</pre>

<p>
`layers$at 略式~構文を利用している：
◎
Using the @layers shorthand syntax:
</p>

<pre class="lang-css">
@layers default, theme, components;
</pre>
</div>

<p>
`layers$at 規則は、【！不要： `名前$lyのみを供する／空な】
`layer$at 規則が許容される所なら，どこでも許容される。
◎
@layers rules are allowed anywhere an empty @layer rule is allowed.
</p>

<p class="issue">
`layers^at を `layer^at に改称する。
（ `5855$issue ）
◎
Rename @layers to @layer &lt;https://github.com/w3c/csswg-drafts/issues/5855&gt;
</p>

<div class="example">

<p>【この例は、この訳による追加】</p>

<p>
次のように記された場合：
</p>

<pre class="lang-css">
@layers C, B, A;
@layer A;
@layers D, A, C;
@layer B;
</pre>

<p>
次のように解釈されるので：
</p>

<pre class="lang-css">
@layer C;
@layer B;
@layer A;
@layer A;
@layer D;
@layer A;
@layer C;
@layer B;
</pre>

<p>
結果の順序は、
C, B, A, D
になる
— 順序を決定する目的においては，最初に現れたものに限り織り込まれるので。
</p>
</div>

				</section>
			</section>
		</section>
		<section id="preshint">
<h3 title="Precedence of Non-CSS Presentational Hints">6.5. ~CSSによるものでない呈示用~hintの優先順位</h3>

<p>
~UAは、~source文書の~markup内の呈示用~hint†を尊守してもヨイ。
例えば `HTML$r における `bgcolor^a 属性や `s$e 要素。
文書~言語に基づくすべての~style付けは、対応する~CSS規則に翻訳した上で，［
`~UA出自$に属する規則, あるいは［
`詳細度$cC 0 を伴って作者~stylesheetの先頭に置かれた，`作者~出自$に属する規則
］］として，~cascadeに入するモノトスル。
文書~言語は、そのような呈示用~hintが［
`~UA出自$／`作者~出自$
］のどちらに属するものとして`~cascade$に入するかを定義してもヨイ。
その場合、~UAは，それに則って挙動するモノトスル。
例えば，~SVGでは、その`呈示~属性$を作者~levelに対応付けている。
◎
The UA may choose to honor presentational hints in a source document’s markup, for example the bgcolor attribute or s element in [HTML]. All document language-based styling must be translated to corresponding CSS rules and either enter the cascade as UA-origin rules or be treated as author-origin rules with a specificity of zero placed at the start of the author style sheet. A document language may define whether such a presentational hint enters the cascade as UA-origin or author-origin; if so, the UA must behave accordingly. For example, [SVG11] maps its presentation attributes into the author level.
</p>

<p class="trans-note">【†
“`presentational hints^en”
— 本来は~CSSが受持つべき，呈示~用の役割も担う~markup
（参考：<a href="~HTMLrendering#presentational-hints">~HTMLが定義する呈示用~hint</a>）
】</p>

<p class="note">注記：
呈示用~hintのうち，`~UA出自$に属する規則として~cascadeに入するものは、［
`作者~出自$／`利用者~出自$
］に属する~styleで上書きできる。
`作者~出自$に属する規則として~cascadeに入するものは、`作者~出自$に属する~styleで上書きできるが、`利用者~出自$に属する`~important$でない~styleからは，上書きできない。
~host言語は、これらを考慮した上で，呈示用~hint用に適切な`出自$を選ぶべきである。
◎
Note: Presentational hints entering the cascade as UA-origin rules can be overridden by author-origin or user-origin styles. Presentational hints entering the cascade as author-origin rules can be overridden by author-origin styles, but not by non-important user-origin styles. Host languages should choose the appropriate origin for presentational hints with these considerations in mind.
</p>

		</section>
	</section>
	<section id="defaulting">
<h2 title="Defaulting">7. ~default法</h2>

<p>
`~cascade$の結果（`~cascadeの出力$）が空である場合、他の何らかの仕方で`指定d値$を見出すモノトスル。
`継承d~prop$は、その既定の値（ `default^en ）を，`継承$を通して親~要素から取り込む。
他のすべての~propは、その`初期~値$を既定の値としてとる。
~stylesheet作者は、［
`inherit$v ／ `initial$v
］~keywordを通して，明示的に［
継承／初期化
］を要請できる。
◎
When the cascade does not result in a value, the specified value must be found some other way. Inherited properties draw their defaults from their parent element through inheritance; all other properties take their initial value. Authors can explicitly request inheritance or initialization via the inherit and initial keywords.
</p>

		<section id="initial-values">
<h3 title="Initial Values">7.1. 初期~値</h3>

<p>
各種~propには、それぞれの~prop定義表にて，その
`初期~値@
（ `initial value^en ）が定義される。
要素の~prop %P が`継承d~prop$でなく, かつ %P の`~cascaded値$も無い場合、その要素の %P の`指定d値$は， %P の`初期~値$で与えられる。
◎
Each property has an initial value, defined in the property’s definition table. If the property is not an inherited property, and the cascade does not result in a value, then the specified value of the property is its initial value.
</p>

		</section>
		<section id="inheriting">
<h3 title="Inheritance">7.2. 継承法</h3>

<p>
~prop値は
`継承@
（ `inheritance^en ）により，親~要素から その各~子~要素へ伝播する。
要素の~propの
`継承d値@
（ `inherited value^en ）は、要素の親~要素の~propの`算出d値$で与えられる。
親~要素がない根~要素~用の`継承d値$は、~propの`初期~値$で与えられる。
◎
Inheritance propagates property values from parent elements to their children. The inherited value of a property on an element is the computed value of the property on the element’s parent element. For the root element, which has no parent element, the inherited value is the initial value of the property.
</p>

<p>
継承は、~shadowを伴う~DOM~treeに対しては，`平坦~化された要素~tree$に対し演算する。
◎
For a [DOM] tree with shadows, inheritance operates on the flattened element tree.＼
</p>

<p class="note">注記：
すなわち，ある `slot$e 要素 %slot にアテガわれた要素は、~styleを
— `~light~tree$の親から直にではなく —
%slot から継承する。
◎
This means that slotted elements inherit from the slot they’re assigned to, rather than directly from their light tree parent.＼
</p>

<p class="note">注記：
各 `疑似要素$は、その定義に述べられる，`仮想の~tag列$ `CSS-PSEUDO-4$r に則って~prop値を継承する。
◎
Pseudo-elements inherit according to the fictional tag sequence described for each pseudo-element. [CSS-PSEUDO-4]
</p>

<p>
一部の~propは、その~prop定義表にて，
`継承d~prop@
（ `inherited property^en ）であるものと定義される。
これは、`~cascaded値$が無いときは，その値が`継承$により決定されることを意味する。
◎
Some properties are inherited properties, as defined in their property definition table. This means that, unless the cascade results in a value, the value will be determined by inheritance.
</p>

<p>
~propを明示的に継承させることもできる。
`inherit$v ~keywordを見よ。
◎
A property can also be explicitly inherited. See the inherit keyword.
</p>

<p class="note">注記：
継承は，文書~treeに従うものであり、生成される`~box~tree$における組み替え
— 合間に`匿名~box$が挟まれるなど —
からは影響されないことに注意。
◎
Note: Inheritance follows the document tree and is not intercepted by anonymous boxes, or otherwise affected by manipulations of the box tree.
</p>

		</section>
		<section id="defaulting-keywords">
<h3 title="Explicit Defaulting">7.3. 明示的な~default法</h3>

<p>
以下では、各種`~CSS全域~keyword$を定義する。
これらの値をとる~prop宣言は、特定0の`~default法$の挙動を明示的に指定する。
`css-values-3$r
にて指定される様に、すべての~CSS~propは，これらの値を受容する。
◎
Several CSS-wide property values are defined below; declaring a property to have these values explicitly specifies a particular defaulting behavior. As specified in CSS Values and Units Level 3 [css-values-3], all CSS properties can accept these values.
</p>

			<section id="initial">
<h4 title="Resetting a Property: the initial keyword">7.3.1. ~propを設定し直す： `initial^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`initial@v
~keywordになる場合、その`指定d値$は，~propの`初期~値$にされる。
◎
If the cascaded value of a property is the initial keyword, the property’s specified value is its initial value.
</p>

			</section>
			<section id="inherit">
<h4 title="Explicit Inheritance: the inherit keyword">7.3.2. 明示的な継承： `inherit^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`inherit@v
~keywordになる場合、その~propの`継承d値$が，`指定d値$および`算出d値$を与える。
◎
If the cascaded value of a property is the inherit keyword, the property’s specified and computed values are the inherited value.
</p>

			</section>
			<section id="inherit-initial">
<h4 title="Erasing All Declarations: the unset keyword">7.3.3. すべての宣言を取り消す ： `unset^v ~keyword</h4>

<p>
~propの`~cascaded値$が
`unset@v
~keywordになる場合、当の~propは［
`継承d~prop$であるならば `inherit$v ／
~ELSE_ `initial$v
］として扱われる。
この~keywordは、実質的に，それまでに`~cascade$に出現した すべての†`宣言d値$を消去して、~prop（`略式~prop$の場合は，そのすべての下位prop）に応じて適切に，正しく［
継承する／継承しない
］ようにする。
◎
If the cascaded value of a property is the unset keyword, then if it is an inherited property, this is treated as inherit, and if it is not, this is treated as initial. This keyword effectively erases all declared values occurring earlier in the cascade, correctly inheriting or not as appropriate for the property (or all longhands of a shorthand).
</p>

<p class="trans-note">【†
“それまでに … すべての”
— これは、`出現順序$cCに従って~sortされるものに限られる。
`出自$cCや`詳細度$cCなど，より優先される<a href="#cascade-sort">~sort判定基準</a>に基づいて選定される宣言d値まで消去するわけではない。
】</p>

			</section>
			<section id="revert">
<h4 title="Rolling Back The Cascade: the revert keyword">7.3.4. ~cascadeの巻戻し： `revert^v ~keyword</h4>

<p class="trans-note">【
巻戻し（ `rolling back^en ）：
~prop値を，他の`出自$†による既定の値（他の出自に属する宣言により，当の~propに指定されている値）に “戻す” 。
（† 下の定義により、通常は，優先順位がより低い出自による~style
— `~importantな宣言$対しては， “より高い” に逆転することになる。）
】</p>

<p>
~propの`~cascaded値$が
`revert@v
~keywordになる場合の挙動は、その宣言が属する`出自$に依存する：
◎
If the cascaded value of a property is the revert keyword, the behavior depends on the cascade origin to which the declaration belongs:
</p>
<ul class="switch">
	<li>
`~UA出自$
⇒
`unset$v に等価。
◎
user-agent origin
• Equivalent to unset.
</li>
	<li>
`利用者~出自$
⇒
`~cascaded値$を~UA~levelに巻戻す。
すなわち，当の要素の~propの`指定d値$は、［
~propには，［
`作者~出自$／`利用者~出自$
］に属する規則は指定されなかった
］かのように計算される。
◎
user origin
• Rolls back the cascaded value to the user-agent level, so that the specified value is calculated as if no author-origin or user-origin rules were specified for this property on this element.
</li>
	<li>
`作者~出自$
⇒
`~cascaded値$を利用者~levelに巻戻す。
すなわち，当の要素の~propの`指定d値$は、［
~propには，`作者~出自$に属する規則は指定されなかった
］かのように計算される。
`revert$v の目的においては、この出自には`~animation出自$も含まれる。
◎
author origin
• Rolls back the cascaded value to the user level, so that the specified value is calculated as if no author-origin rules were specified for this property on this element. For the purpose of revert, this origin includes the Animation origin.
</li>
</ul>

			</section>
		</section>
	</section>
	<section id="changes">
<h2 title="Changes">8. 変更点</h2>

<dl>
	<dt id="additions-l4">
<a href="~TR/css-cascade-4/">~level 4</a>
からの追加
◎
8.1. Additions Since Level 4
◎
The following features have been added since Level 4:
</dt>
	<dd>
`~cascade$の~sort判定基準に`~cascade層$を<a href="#cascade-layering">追加した</a>。
◎
Added cascade layers to the cascade sort criteria.
</dd>
	<dd>
~style属性を`~cascade$の~sort判定基準における別個な段として定義した。
◎
Defined style attributes as a distinct step of the cascade sort criteria.
</dd>
	<dd>
`~cascade層$を定義するための `layer$at 規則を導入した。
◎
Introduced the @layer rule for defining cascade layers
</dd>
	<dd>
複数の`~cascade層$を［
定義する／順序し直す
］ための `layers$at 規則を導入した。
◎
Introduced the @layers rule for defining and re-ordering multiple layers
</dd>

	<dt id="additions-l3">
<a href="~TR/css-cascade-3/">~level 3</a>
からの追加
◎
8.2. Additions Since Level 3
◎
The following features have been added since Level 3:
</dt>
	<dd>
~cascadeの巻戻し用の `revert$v ~keywordを導入した。
◎
Introduced revert keyword, for rolling back the cascade.
</dd>
	<dd>
supports 条件付き `import$at 規則~用に `supports^f 構文を導入した。
◎
Introduced supports() syntax for supports-conditional @import rules.
</dd>
	<dd>
~shadow~DOM `DOM$r
に適応するため，`~cascade$の~sort判定基準に`~encapsulation文脈$を追加した。
◎
Added encapsulation context to the cascade sort criteria to accommodate Shadow DOM. [DOM]
</dd>
	<dd>
~CSSが旧来の構文を~supportするために利用する，~propを別名化する仕組みを 2 つ定義した。
<a href="#aliasing">§ 別名化</a>を見よ。
◎
Defined the property two aliasing mechanisms CSS uses to support legacy syntaxes. See See § 3.1 Aliasing.
</dd>

	<dt id="changes-2">
<a href="~TR/CSS2/cascade.html">~level 2</a>
からの追加
◎
8.3. Additions Since Level 2
◎
The following features have been added since Level 2:
</dt>
	<dd>
`all$p 略式~prop
◎
The all shorthand
</dd>
	<dd>
`initial$v ~keyword
◎
The initial keyword
</dd>
	<dd>
`unset$v ~keyword
◎
The unset keyword
</dd>
	<dd>
［
~animation, 遷移
］を`~cascade$の中に組入れた。
◎
Incorporation of animations and transitions into the cascade.
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
この仕様に貢献された次の方々に：
</p>

<p lang="en-x-a0">
David Baron, Tantek Çelik, Florian Rivoal, Simon Sapin, Jen Simmons, and Boris Zbarsky contributed to this specification.
</p>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacyと~securityの考慮点</h2>

<ul>
	<li>
~cascade処理-は、［
同一-生成元, 非同一-生成元
］の~stylesheetを判別しないため、文書に適用される~styleの算出d値から，非同一-生成元~stylesheetの内容を推定するのも可能になる。
◎
The cascade process does not distinguish between same-origin and cross-origin stylesheets, enabling the content of cross-origin stylesheets to be inferred from the computed styles they apply to a document.
</li>
	<li>
~style規則の適用を介して表出される［
利用者~選好, ~UAの既定
］は、~cascade処理-により公開されるので，それらが文書に適用した~styleの算出d値から推定できる。
◎
User preferences and UA defaults expressed via application of style rules are exposed by the cascade process, and can be inferred from the computed styles they apply to a document.
</li>
	<li>
`import$at 規則は、非同一-生成元からの~stylesheetを読込む際に
<a href="~FETCH#cors-protocol">~CORS~protocol</a>
を適用せず，それらを自由に~importして適用するのを許容する。
◎
The @import rule does not apply the CORS protocol to loading cross-origin stylesheets, instead allowing them to be freely imported and applied.
</li>
	<li>
`import$at 規則は、`~Content-Type~metadata$を伴わない資源を（または、~host文書は`過去互換~mode$下にある場合は、同一-生成元からのどの資源も）【その`~MIME型$を】 `text/css^c と見做す
— その結果、次も許容することになり得る
⇒＃
任意な資源を~pageの中へ~importして~CSSとして解釈する／
文書に適用される~styleの算出d値から敏感な~dataを推定する
◎
The @import rule assumes that resources without Content-Type metadata (or any same-origin file if the host document is in quirks mode) are text/css, potentially allowing arbitrary files to be imported into the page and interpreted as CSS, potentially allowing sensitive data to be inferred from the computed styles they apply to a document.
</li>
</ul>

	</section>
</main></div>
