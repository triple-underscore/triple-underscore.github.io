<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Common microsyntaxes（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'common-microsyntaxes',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/❝.|%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return (
`<span class="code-point">U+00${match[1].charCodeAt(0).toString(16).toUpperCase()}</span> (<span class="char-symbol">${match[1]}</span>)`
		);
	default://%
		return `<var>${match.slice(1)}</var>`;
	}
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-05-15
trans_update:2025-05-16
source_checked:241021
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/common-microsyntaxes.html
	abbr_url:HTMLcms
nav_prev:HTMLINFRA
nav_next:HTMLurl
trans_1st_pub:2016-01-28


●●class_map
e:element
a:attr
st:attr-state
jA:abstract
t:type
U:code-point
v:value

●●tag_map
I:code
m:code
c:code
e:code
a:code
st:i
v:code
p:code
jA:span
V:var
t:var
mark:mark
i:i
U:span
cite:cite
sub:sub

●●original_id_map

●●link_map



e.input:~HEinput#the-input-element
e.time:~HEtextlevel#the-time-element
e.progress:~HEforms#the-progress-element
e.frameset:~HTMLobs#frameset

a.id:~HTMLdom#the-id-attribute
a.checked:~HEinput#attr-input-checked
a.disabled:~HTMLforms#attr-fe-disabled
a.max:~HEforms#attr-progress-max

a.usemap:~HEimages#attr-hyperlink-usemap
a.datetime:~HEedits#attr-mod-datetime

st.Number:~HEinput#number-state-(type=number)

	●
列挙d属性:#enumerated-attribute
真偽-属性:#boolean-attribute
妥当でない値~用の既定の状態:#invalid-value-default
欠落~値~用の既定の状態:#missing-value-default
正準的な~keyword:#canonical-keyword

要素~型:~HTMLINFRA#element-type

一意かつ内部的な値:#unique-internal-value
新たな一意かつ内部的な値:#new-unique-internal-value


	●構文
Base10:#_base-ten-integer
Frac10:#_base-ten-fractional

妥当な整数:#valid-integer
妥当な負でない整数:#valid-non-negative-integer

妥当な浮動小数点数:#valid-floating-point-number
妥当な浮動小数点数~list:#valid-list-of-floating-point-numbers
浮動小数点数として最良な表現:#best-representation-of-the-number-as-a-floating-point-number

整数として構文解析する:#rules-for-parsing-integers
負でない整数として構文解析する:#rules-for-parsing-non-negative-integers
浮動小数点数として構文解析する:#rules-for-parsing-floating-point-number-values
浮動小数点数~listとして構文解析する:#rules-for-parsing-a-list-of-floating-point-numbers

~commaで分離された~token集合:#set-of-comma-separated-tokens
~space等で分離された~token集合:#set-of-space-separated-tokens

	●date＆time
日時:#concept-datetime
大域的~日時:#concept-datetime
局所的~日時:#concept-datetime-local
偏差:#concept-timezone
時間帯:#time-zones
日付:#concept-date
時刻:#concept-time
年月t:#concept-month
月日t:#concept-yearless-date
年週t:#concept-week
月tの日t数:#number-of-days-in-month-month-of-year-year
週t数:#week-number-of-the-last-day
最後の日tの週t番号:#week-number-of-the-last-day
時間長:#concept-duration
時間長~成分:#duration-time-component
時間長~成分の縮尺:#duration-time-component-scale
遡及~Gregorian日付:#proleptic-gregorian-date
遡及~Gregorian暦:#proleptic-gregorian-calendar

妥当な偏差~文字列:#valid-time-zone-offset-string
妥当な大域的~日時~文字列:#valid-global-date-and-time-string
妥当な局所的~日時~文字列:#valid-local-date-and-time-string
妥当な月日t文字列:#valid-yearless-date-string
妥当な日付~文字列:#valid-date-string
妥当な省略あり日時~文字列:#valid-date-string-with-optional-time
妥当な時刻~文字列:#valid-time-string
妥当な時間長~文字列:#valid-duration-string
妥当な年月t文字列:#valid-month-string
妥当な正規化-済み局所的~日時~文字列:#valid-normalised-local-date-and-time-string
妥当な年週t文字列:#valid-week-string

大域的~日時~文字列を構文解析する:#parse-a-global-date-and-time-string
局所的~日時~文字列を構文解析する:#parse-a-local-date-and-time-string
偏差~文字列を構文解析する:#parse-a-time-zone-offset-string
偏差~成分を構文解析する:#parse-a-time-zone-offset-component
月日t文字列を構文解析する:#parse-a-yearless-date-string
月日t成分を構文解析する:#parse-a-yearless-date-component
省略あり日時~文字列を構文解析する:#parse-a-date-or-time-string
日付~文字列を構文解析する:#parse-a-date-string
日付~成分を構文解析する:#parse-a-date-component
時刻~文字列を構文解析する:#parse-a-time-string
時刻~成分を構文解析する:#parse-a-time-component
時間長~文字列を構文解析する:#parse-a-duration-string
年月t文字列を構文解析する:#parse-a-month-string
年月t成分を構文解析する:#parse-a-month-component
年週t文字列を構文解析する:#parse-a-week-string

	●CSS
寸法~listとして構文解析する:#rules-for-parsing-a-list-of-dimensions
寸法~値として構文解析する:#rules-for-parsing-dimension-values
非~zero寸法~値として構文解析する:#rules-for-parsing-non-zero-dimension-values

旧来の色~値として構文解析する:#rules-for-parsing-a-legacy-colour-value

~hash名~参照として構文解析する:#rules-for-parsing-a-hash-name-reference
妥当な~hash名~参照:#valid-hash-name-reference

利用者の環境に合致して:#matches-the-environment
妥当な媒体~query~list:#valid-media-query-list
t.media-query-list:~MQ5#typedef-media-query-list

反映する:~HTMLcdom#reflect

	●外部
~list:~INFRA#list
~size:~INFRA#list-size
付加する:~INFRA#list-append
位置~変数:~INFRA#string-position-variable
符号位置:~INFRA#code-point
cp.値:~INFRA#code-point-value
符号位置~長さ:~INFRA#string-code-point-length
	符号位置~長さ:characters long
符号位置~部分文字列:~INFRA#code-point-substring
終端までを成す符号位置~部分文字列:~INFRA#code-point-substring-to-the-end-of-the-string
一致-:~INFRA#string-is
~ASCII大小無視:~INFRA#ascii-case-insensitive
sub.大小無視:~INFRA#ascii-case-insensitive
~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points

~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order

jA.ToString:~TC39#sec-tostring

有名~色:~CSSCOLOR#named-color


●●words_table1

FORMSintro:HTML-forms-intro-ja.html

●●words_table



	●仕様
協調-:coordinate:~
	読み易い:readable
受渡し:round-tripping:受け渡し
誤解釈:misinterpreting:~
	注記

	織り込
	織り込:takes into account
	当時の:contemporary
傾向:tend:~
文化的:cultural:~
政治的裁定:policy decisions:~
政治的駆引き:political footballs:政治的駆け引き
永劫:forever:~
注目:notable:~
偏向:bias:~

	する限りにおいて:insofar
	きちんと:well
	気まぐれな:very whimsical
	出来事:event
	~~実用されている:real
	大きく変わる:greatly vary
	成句的な:idiom
	その逆も同様:vice versa

	●構文
SPACE:
zero::::ゼロ
hash::::ハッシュ
	hash-name
hex::16 進
	16 進:hexadecimal
値なし:missing value:~

	正規化-済み:normalized
読飛ばす:skipする:読み飛ばす
剥ぐ:stripする:~
基本多言語面:basic multilingual plane::~
符号:sign:~
有符号:signed:~
実数:number:~
倍精度:double-precision:~
浮動小数点数:floating-point number:~
仮数:significand:~
小数:fraction:~
	小数~部:fractional part
指数:exponent:~

小構文:microsyntax::~

一義化子:-disambiguator:~
部分文字列:substring::~

	-:subcomponent
	尾部:trailing
	頭部:leading
	順に
	Advance position to the next character
	hash-name
	micro-parser:
	space::::
	失敗:fail
	無用な文字~並び:garbage
	偶数:even

	●暦
Gregorian::::グレゴリオ
Julian::::ユリウス
London::::ロンドン
	^en:Greenwich
ISO8601:ISO 8601
Roman-Emperor:Roman Emperor::ローマ皇帝
Nero::::ネロ
UT1::::
UTC::::
	February
	October
	SI
	USA
遡及:proleptic::~

閏:leap::~

年t:year::年
月t:month::月
年月t:year＆month::年＆月
月日t:month＆date::月＆日
日t:day::日
週t:week::週
年週t:year＆week::年＆週
時t:hour::時
分t:minute::分
秒t:second::秒
週年t:week-year::週年
年なし:yearless::~
日時:date＆time::~
時間帯:time zone::~
	時刻:moments in time
偏差:time-zone offset::~

milli::::ミリ
	~milli秒t:millisecond
夏時間:daylight saving time::~
太陽時:Earth solar time::~
時間長:duration::~
	時間長~成分:duration time component:
	~~時間:hour
暦:calendar::~
暦付け:calendaring::~
最大日数:maxday::~
	-:maxweek

番号:number:~

水曜:Wednesday::~
火曜:Thursday::~
月曜:Monday::~
七日間:seven-day period:~

地域:area:~
地域化-:localize::~::ローカル化
生誕:birth:~
誕生日:birthday:~
真昼:noon:~
期間:period:~
東海岸:east-coast:~
真夜中:midnight:~
経度:longitude:~
縮尺:scale:~
外部補間-:extrapolate:~
前近代:ancient times:~
比較的近代:relatively recent decades:~
世紀:century:~
中頃:mid:~
制定:formation:~
	1 月:January
	12 月:December
	timezone
	timezonehour
	timezoneminute
	~~曖昧な:vaguer moments

	●CSS
red:
green:
blue:
RGB:

	●未分類
刻む:tickする:~
無毒化:sanitization::~
減算-:subtract:~
近似-:approximate:~
近似:approximation:~
重複-:duplicate:~
混在させ:mixし:~
check::::チェック
checkbox::::チェックボックス
zero::::ゼロ
	literal
伝送路:wire:~
当地域:place:~

	整数 ~IN :8-bit numbers in
	-:increment
	現れる
	加えて
	加える
	有-
	残りの
	示す:show
	表す
	記され
	課され
	選ぶ
	呼ばれ
	指して
	指す:refer／point
	書いて
	書き
	満た
	対応付けら
	遡って:backward
	用い
	表記
	表記規約
	指している:pointer into
	-:arbitrary
	数
	伴う
	入って
	単に
	場合
	何
	内
	列
	対し
	後の
	応じて
	成す
	所で
	方
	方法
	有無
	生
	最も小さい:smallest
	最短な:shortest
	〜の倍数:divisible
	超える
	近い

	進んでいる:ahead of
	INCBY:advance position
	:care
	:count
	:followed by
	:forcibly
	:moment
	~zero詰めされ:zero-padded
	:part
	:past
	:refer
	:sum
	:four
	ずっと:much more
	掛けた:scaleした
	一方
	一部
	下
	両方
	中の
	乗
	互いに
	他
	以上
	以下
	以前の:previous／predate
	それまで:previously
	以外
	先頭
	別
	前後
	前述
	次
	片方
	様々な:various
	自体も
	複数の
	該当-
	限ら
	限り
	非


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~SPEC_URL">§ Common microsyntaxes</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — 共通な小構文</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="common-microsyntaxes">
<h3 title="Common microsyntaxes">2.3. 共通な小構文</h3>

<p>
~HTMLでは，様々な所で，日付や実数などを表現する特定0の~data型を受容する。
この節では、
それらの形式による内容に対する適合性の判定基準, および
それらを構文解析する方法について述べる。
◎
There are various places in HTML that accept particular data types, such as dates or numbers. This section describes what the conformance criteria for content in those formats is, and how to parse them.
</p>

<p class="note">注記：
実装者には、以下に述べる構文の構文解析を実装するにあたり，第三者-主体による~libraryの利用を考慮するときは、
注意深く精査することが強く督促される。
例えば、
日付~libraryにおける~errorの取扱いは、
この仕様にて要求されるものから相違する挙動を実装している~~可能性が高い。
~error取扱いの挙動は、
この仕様にて利用される構文に類似な日付~構文を述べる仕様では，定義されていないことが多いため、
実装によって大きく異なる傾向にある。
◎
Implementers are strongly urged to carefully examine any third-party libraries they might consider using to implement the parsing of syntaxes described below. For example, date libraries are likely to implement error handling behavior that differs from what is required in this specification, since error-handling behavior is often not defined in specifications that describe date syntaxes similar to those used in this specification, and thus implementations tend to vary greatly in how they handle errors.
</p>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

			</section>
			<section id="common-parser-idioms">
<h4 title="Common parser idioms">2.3.1. 共通な成句的な構文解析器</h4>

<p>
以下に述べる一部の構文解析器は、
構文解析される文字列を保持する変数 %入力,
および 次に構文解析される文字を指す変数 %位置 を用いる~patternに従う。
【詳細は、以下に現れる %位置↗ という表記も含め，`位置~変数$を参照されたし。】
◎
Some of the micro-parsers described below follow the pattern of having an input variable that holds the string being parsed, and having a position variable pointing at the next character to parse in input.
</p>

			</section>
			<section id="boolean-attributes">
<h4 title="Boolean attributes">2.3.2. 真偽-属性</h4>

<p>
いくつかの内容~属性は、
`真偽-属性@
であるとされる。
要素に真偽-属性が［
在ることは ~T 値 ／
無いことは ~F 値
］を表現する。
◎
A number of attributes are boolean attributes. The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value.
</p>

<p>
真偽-属性は、
在るならば，［
その値 ~IN`大小無視$sub { 空~文字列, 属性の正準的な名前 }
］でなければナラナイ（ 属性~値の頭部にも尾部にも空白は許容されない）。
◎
If the attribute is present, its value must either be the empty string or a value that is an ASCII case-insensitive match for the attribute's canonical name, with no leading or trailing whitespace.
</p>

<p class="note">注記：
真偽-属性に対しては，値［
`true^l ／ `false^l
］は許容されない。
~F 値を表現するためには、
属性~自体も省略する必要がある。
◎
The values "true" and "false" are not allowed on boolean attributes. To represent a false value, the attribute has to be omitted altogether.
</p>

<div class="example">

<p>
~checkされ, かつ不能化された（ `checked^en ＆ `disabled^en ）~checkboxの例をここに示す。
［
`checked$a, `disabled$a
］属性は、
どちらも真偽-属性である。
◎
Here is an example of a checkbox that is checked and disabled. The checked and disabled attributes are the boolean attributes.
</p>

<pre class="lang-html">
&lt;label&gt;&lt;input
    type=checkbox
    `checked^mark
    name=cheese
    `disabled^mark
&gt; Cheese&lt;/label&gt;
</pre>

<p>
これは、
次のように書いても等価になる：
◎
This could be equivalently written as this:
</p>

<pre class="lang-html">
&lt;label&gt;&lt;input
    type=checkbox
    `checked=checked^mark
    name=cheese
    `disabled=disabled^mark
&gt; Cheese&lt;/label&gt;
</pre>

<p>
次のように書き方を混在させても依然として等価になる：
◎
You can also mix styles; the following is still equivalent:
</p>

<pre class="lang-html">
&lt;label&gt;&lt;input
    type='checkbox'
    `checked^mark
    name=cheese
    `disabled=""^mark
&gt; Cheese&lt;/label&gt;
</pre>
</div>

			</section>
			<section id="keywords-and-enumerated-attributes">
<h4 title="Keywords and enumerated attributes">2.3.3. ~keyword, 列挙d属性</h4>

<div class="p">
<p>
一部の内容~属性は、
`列挙d属性@
とされ，次が指定される：
</p>
<ul>
	<li>
ある有限~個の状態たちが成す集合 %S
</li>
	<li>
~keywordたちが成す集合 %K
</li>
	<li>
%K から %S への対応付け
</li>
	<li>
`妥当でない値~用の既定の状態@
⇒
ε ／
ある状態 ~IN %S
</li>
	<li>
`欠落~値~用の既定の状態@
⇒
ε ／
ある状態 ~IN %S
</li>
</ul>

<p>
要素~上の`列挙d属性$の状態は、
%S 内の いずれかの状態になるか， ε （ 状態は “無い” ）になる。
状態は、
属性の値と上に挙げたものを組合せることにより導出される。
</p>

<p class="trans-note">【
他所を簡潔に述べるため、
この訳では， ε を導入して定義を少し改めている。
各種 既定の状態の定義における ε は、
“状態は指定されない”
ことを表す。
】</p>

◎
Some attributes, called enumerated attributes, take on a finite set of states. The state for such an attribute is derived by combining the attribute's value, a set of keyword/state mappings given in the specification of each attribute, and two possible special states that can also be given in the specification of the attribute. These special states are the invalid value default and the missing value default.
</div>

<p class="note">注記：
複数の~keywordが同じ状態に対応付けられることもある。
◎
Multiple keywords can map to the same state.
</p>

<p class="trans-note">【
各種 既定の状態には、
それに対応付けられる~keywordが無いものもある。
】</p>

<p class="note">注記：
空~文字列が妥当な~keywordになることもある。
`欠落~値~用の既定の状態$が適用されるのは、
当の属性が`欠落な^emときに限られ，
値に空~文字列を伴う属性が在るときではないことに注意。
◎
The empty string can be a valid keyword. Note that the missing value default applies only when the attribute is missing, not when it is present with an empty string value.
</p>

<div class="algo">
<p>
%要素 上の`列挙d属性$ %属性 の状態を決定するときは、
次の手続きを利用する：
◎
To determine the state of an attribute, use the following steps:
</p>
<ol>
	<li>
~IF［
%要素 は %属性 を有さない
］
⇒
~RET %属性 の`欠落~値~用の既定の状態$
◎
If the attribute is not specified:
• If the attribute has a missing value default state defined, then return that missing value default state.
• Otherwise, return no state.
</li>
	<li>
~IF［
%属性 用の~keywordに［
%属性 の値 ~EQ`大小無視$sub ~keyword
］を満たすものがある
］
⇒
~RET その~keywordに対応する状態
◎
If the attribute's value is an ASCII case-insensitive match for one of the keywords defined for the attribute, then return the state represented by that keyword.
</li>
	<li>
~RET %属性 の`妥当でない値~用の既定の状態$
◎
If the attribute has an invalid value default state defined, then return that invalid value default state.
◎
Return no state.
</li>
</ol>
</div>

<p>
著作~適合性の目的においては、
要素に ある列挙d属性を指定する場合，
その値は［
当の属性~用の適合な~keywordのうち，いずれか
］に`~ASCII大小無視$で合致しなければナラナイ
— 頭部にも尾部にも空白を伴うことなく。
【そのような空白を伴う~keywordが定義されることは、決してない。】
◎
For authoring conformance purposes, if an enumerated attribute is specified, the attribute's value must be an ASCII case-insensitive match for one of the conforming keywords for that attribute, with no leading or trailing whitespace.
</p>

<div class="algo">
<p>
`反映する$目的においては、
各 状態には，
`正準的な~keyword@
が定義される
— それは、
当の状態に対応付けられる~keywordたちが成す集合を %K とするとき，
次に従って決定される：
◎
For reflection purposes, states which have any keywords mapping to them are said to have a canonical keyword. This is determined as follows:
</p>
<ul class="switch">
	<li>
%K は空な場合
⇒
ε （ “存在しない” ）†
</li>
	<li>
%K は 1 個の~keywordのみからなる場合
⇒
その~keyword
◎
If there is only one keyword mapping to the given state, then it is that keyword.
</li>
	<li>
%K 内には`適合^emな~keywordが 1 つだけ在る場合
⇒
その~keyword
◎
If there is only one conforming keyword mapping to the given state, then it is that conforming keyword.
</li>
	<li>
%K 内には`適合^emな~keywordが 2 つだけ在って，一方は空~文字列である場合
⇒
もう一方の~keyword
◎
If there are two conforming keywords mapping to the given state, and one is the empty string, then the canonical keyword will be the conforming keyword that is not the empty string.
</li>
	<li>
他の場合
⇒
%K 内の ある~keywordが、
当の属性により`正準的な~keyword$として指定されることになる
◎
Otherwise, the canonical keyword for the state will be explicitly given in the specification for the attribute.
</li>
</ul>

<p class="trans-note">【†
ここでも，
他所を簡潔に述べるため、
この訳では， ε をとり得るよう定義を改めている。
】</p>
</div>

			</section>
			<section id="numbers">
<h4 title="Numbers">2.3.4. 実数</h4>

<p>
所与の［
0 個以上の`~ASCII数字$
］たちが成す文字列 %s に対し：
</p>

<ul>
	<li class="algo">
<p>
`Base10@
( %s )
は、
次を走らせた結果を返す：
</p>
		<ol>
			<li>
%結果 ~LET 0
</li>
			<li>
%s を成す
~EACH( 文字 %d )
に対し，先頭から順に
⇒
%結果 ~SET ( %結果 ~MUL 10 ) ~PLUS ( %d の`値$cp ~MINUS ❝0 の`値$cp （すなわち， %d を 10 進数として解釈した結果） )
</li>
			<li>
~RET %結果
</li>
		</ol>
	</li>
	<li class="algo">
`Frac10@
( %s )
は、
次の結果を返す
⇒
`Base10$( %s ) ~DIV ( 10 の ( %s の`符号位置~長さ$ ) 乗 )
</li>
</ul>

<p class="trans-note">【
これらの~algoは、
以下を簡潔に述べるために，この訳にて導入したものである。
原文には， `Base10$ にあたる~algoは定義されていない
（単に， “10 進数として解釈する” と記されている）
が、
それに依存する `Frac10$ を利用している箇所には~algoが与えられているので，等価になるものをここに定義している。
】</p>

				<section id="signed-integers">
<h5 title="Signed integers">2.3.4.1. 有符号~整数</h5>

<div class="p">
<p>
次の並びからなる文字列は
`妥当な整数@
とされる：
</p>

<ol>
	<li>
0 〜 1 個の文字 ❝-
</li>
	<li>
1 個以上の`~ASCII数字$
</li>
</ol>

◎
A string is a valid integer if it consists of one or more ASCII digits, optionally prefixed with a U+002D HYPHEN-MINUS character (-).
</div>

<p>
`妥当な整数$は
⇒
❝- を［
伴わないならば 1 ／
伴うならば −1
］ ~MUL `Base10$( その中の数字~列 ) を表現する。
◎
A valid integer without a U+002D HYPHEN-MINUS (-) prefix represents the number that is represented in base ten by that string of digits. A valid integer with a U+002D HYPHEN-MINUS (-) prefix represents the number represented in base ten by the string of digits that follows the U+002D HYPHEN-MINUS, subtracted from zero.
</p>

<div class="algo">
<p>
`整数として構文解析する@
規則は、
所与の
 ( 文字列 %入力 )
に対し，［
整数 ／ `失敗^i
］を返す：
【！以下略：When invoked, ...】
◎
The rules for parsing integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either an integer or an error.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%符号 ~LET 1
◎
Let sign have the value "positive".
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
<p>
%位置↗ に応じて：
◎
If position is past the end of input, return an error.
</p>
		<dl class="switch">
			<dt>❝-
◎
If the character indicated by position (the first character) is a U+002D HYPHEN-MINUS character (-):</dt>
			<dd>
				<ol>
					<li>
%符号 ~LET −1
◎
Let sign be "negative".
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
◎
If position is past the end of input, return an error.
</li>
				</ol>
			</dd>

			<dt>❝+
◎
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):
</dt>
			<dd>
				<ol>
					<li>
%位置 ~INCBY 1
（ `+^l は無視されるが適合ではない。）
◎
Advance position to the next character. (The "+" is ignored, but it is not conforming.)
◎
If position is past the end of input, return an error.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET `失敗^i
◎
If the character indicated by position is not an ASCII digit, then return an error.
</li>
	<li>
%値 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position, and＼
</li>
	<li>
~RET %符号 ~MUL `Base10$( %値 )
◎
interpret the resulting sequence as a base-ten integer. Let value be that integer.
◎
If sign is "positive", return value, otherwise return the result of subtracting value from zero.
</li>
</ol>
</div>

				</section>
				<section id="non-negative-integers">
<h5 title="Non-negative integers">2.3.4.2. 負でない整数</h5>

<p>
1 個以上の`~ASCII数字$からなる文字列は
`妥当な負でない整数@
とされる。
◎
A string is a valid non-negative integer if it consists of one or more ASCII digits.
</p>

<p>
`妥当な負でない整数$は、
`Base10$( その数字~列 )
を表現する。
◎
A valid non-negative integer represents the number that is represented in base ten by that string of digits.
</p>

<div class="algo">
<p>
`負でない整数として構文解析する@
規則は、
所与の
 ( 文字列 %入力 )
に対し，［
負でない整数 ／ `失敗^i
］を返す：
◎
The rules for parsing non-negative integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either zero, a positive integer, or an error.
</p>

<ol>
	<li>
%値 ~LET `整数として構文解析する$( %入力 )
◎
Let input be the string being parsed.
◎
Let value be the result of parsing input using the rules for parsing integers.
</li>
	<li>
~IF［
%値 ~EQ `失敗^i
］~OR［
%値 ~LT 0
］
⇒
~RET `失敗^i
◎
If value is an error, return an error.
◎
If value is less than zero, return an error.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>
</div>

				</section>
				<section id="floating-point-numbers">
<h5 title="Floating-point numbers">2.3.4.3. 浮動小数点数</h5>

<p>
次の並びが成す文字列は、
`妥当な浮動小数点数@
とされる：
◎
A string is a valid floating-point number if it consists of:
</p>

<ol>
	<li>
“符号~部” ：
0 〜 1 個の ❝-
◎
Optionally, a U+002D HYPHEN-MINUS character (-).
</li>
	<li>
<p>
次の両方, または片方のみによる並び：
◎
One or both of the following, in the given order:
</p>
		<ol>
			<li>
“整数~部” ：
1 個以上の`~ASCII数字$が成す並び
◎
A series of one or more ASCII digits.
</li>
			<li>
<p>
次の並び：
◎
Both of the following, in the given order:
</p>
				<ol>
					<li>
1 個の ❝.
◎
A single U+002E FULL STOP character (.).
</li>
					<li>
“小数~部” ：
1 個以上の`~ASCII数字$が成す並び
◎
A series of one or more ASCII digits.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
“指数~部” ：
空~文字列, または
次の並び：
◎
Optionally:
</p>
		<ol>
			<li>
1 個の［
❝e, または ❝E
］
◎
Either a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E).
</li>
			<li>
“指数~部の符号~部” ：
0 〜 1 個の［
❝-, または ❝+
］
◎
Optionally, a U+002D HYPHEN-MINUS character (-) or U+002B PLUS SIGN character (+).
</li>
			<li>
“指数~部の数字~列” ：
1 個以上の`~ASCII数字$が成す並び
◎
A series of one or more ASCII digits.
</li>
		</ol>
	</li>
</ol>

<div class="p">
<p>
`妥当な浮動小数点数$は、
( %符号 ~MUL %仮数 ~MUL ( 10 の %指数 乗 ) )
で得される数を表現する
— ここで：
</p>

<ul>
	<li>
%符号 ~EQ ［
前述の “符号~部” ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
</li>
	<li>
<p>
%仮数 ~EQ %整数 ~PLUS %小数
— ここで：
</p>
		<ul>
			<li>
%整数 ~EQ 前述の “整数~部” が［
あれば `Base10$( “整数~部” ) ／
なければ 0
］
</li>
			<li>
%小数 ~EQ 前述の “小数~部” が［
あれば `Frac10$( “小数~部” ) ／
なければ 0
］
</li>
		</ul>
	</li>
	<li>
<p >
%指数 ~EQ ［
前述の “指数~部” ~NEQ 空~文字列ならば
( %符号 ~MUL %指数 ) ／
~ELSE_ 0
］
— ここで：
</p>
		<ul>
			<li >
%符号 ~EQ ［
前述の “指数~部の符号~部” ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
</li>
			<li >
%指数 ~EQ `Base10$( 前述の “指数~部の数字~列” )
</li>
		</ul>
	</li>
</ul>

◎
A valid floating-point number represents the number obtained by multiplying the significand by ten raised to the power of the exponent, where the significand is the first number, interpreted as base ten (including the decimal point and the number after the decimal point, if any, and interpreting the significand as a negative number if the whole string starts with a U+002D HYPHEN-MINUS character (-) and the number is not zero), and where the exponent is the number after the E, if any (interpreted as a negative number if there is a U+002D HYPHEN-MINUS character (-) between the E and the number and the number is not zero, or else ignoring a U+002B PLUS SIGN character (+) between the E and the number if there is one). If there is no E, then the exponent is treated as zero.
</div>

<p class="note">注記：
Infinity, NaN（ `Not-a-Number^en ）いずれの値も，`妥当な浮動小数点数$ではない。
◎
The Infinity and Not-a-Number (NaN) values are not valid floating-point numbers.
</p>

<p class="note">注記：
`妥当な浮動小数点数$の概念は、
概して，作者に許容されるものを制約する利用に限られる。
一方で、
~UAに課される要件には，`浮動小数点数として構文解析する$規則が利用される
（例： `progress$e 要素の `max$a 属性 ）。
しかしながら，一部の事例では、
文字列が`妥当な浮動小数点数$かどうか検査することも~UA要件に含まれる
（例：
`Number$st 状態にある `input$e 要素~用の`値の無毒化＠~HEinput#value-sanitization-algorithm$ ／
`srcset^a 属性を`構文解析する~algo＠~HEimages#parse-a-srcset-attribute$）。
◎
The valid floating-point number concept is typically only used to restrict what is allowed for authors, while the user agent requirements use the rules for parsing floating-point number values below (e.g., the max attribute of the progress element). However, in some cases the user agent requirements include checking if a string is a valid floating-point number (e.g., the value sanitization algorithm for the Number state of the input element, or the parse a srcset attribute algorithm).
</p>

<p>
実数 %n に対する
`浮動小数点数として最良な表現@
は、
`ToString$jA( %n ) を走らせて得される文字列である。
`ToString()^jA 抽象-演算の結果は一意に決定されるとは限らない
— 特定0の値に対する `ToString()^jA の結果として複数の文字列がアリな場合、
~UAは常に同じ結果を返すモノトスル
（他の~UAは相違する値を利用するかもしれないが）。
◎
The best representation of the number n as a floating-point number is the string obtained from running ToString(n). The abstract operation ToString is not uniquely determined. When there are multiple possible strings that could be obtained from ToString for a particular value, the user agent must always return the same string for that value (though it may differ from the value used by other user agents).
</p>

<div class="algo">
<p>
`浮動小数点数として構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
実数 ／ `失敗^i
］を返す：
◎
The rules for parsing floating-point number values are as given in the following algorithm. This algorithm must be aborted at the first step that returns something. This algorithm will return either a number or an error.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
◎
Let value have the value 1.
◎
Let divisor have the value 1.
◎
Let exponent have the value 1.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
◎
If position is past the end of input, return an error.
↓</li>
	<li>
%符号 ~LET ［
%位置↗ ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
◎
If the character indicated by position is a U+002D HYPHEN-MINUS character (-):
• Change value and divisor to −1.
• Advance position to the next character.
• If position is past the end of input, return an error.
↓</li>
	<li>
~IF［
%位置↗ ~IN { ❝-, ❝+ }
］
⇒
%位置 ~INCBY 1
（ `+^l は適合でないが無視される）
◎
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):
• Advance position to the next character. (The "+" is ignored, but it is not conforming.)
• If position is past the end of input, return an error.
</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~IF［
%位置↗ ~NEQ ❝.
］~OR［
( %位置 ~PLUS 1 )↗ ~NIN `~ASCII数字$
］
⇒
~RET `失敗^i
◎
↑↓</li>
	<li>
%値 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
	<li>
%値 ~SET `Base10$( %値 )
◎
If the character indicated by position is a U+002E FULL STOP (.), and that is not the last character in input, and the character after the character indicated by position is an ASCII digit, then set value to zero and jump to the step labeled fraction.
◎
If the character indicated by position is not an ASCII digit, then return an error.
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply value by that integer.
◎
If position is past the end of input, jump to the step labeled conversion.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝.
]：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%小数~部 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
</li>
			<li>
%値 ~INCBY `Frac10$( %小数~部 )
</li>
		</ol>

◎
Fraction: If the character indicated by position is a U+002E FULL STOP (.), run these substeps:
• Advance position to the next character.
• If position is past the end of input, or if the character indicated by position is not an ASCII digit, U+0065 LATIN SMALL LETTER E (e), or U+0045 LATIN CAPITAL LETTER E (E), then jump to the step labeled conversion.
• If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E), skip the remainder of these substeps.
•• Fraction loop: Multiply divisor by ten.
••Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
••Advance position to the next character.
••If position is past the end of input, then jump to the step labeled conversion.
••If the character indicated by position is an ASCII digit, jump back to the step labeled fraction loop in these substeps.
</li>
	<li>
<p>
~IF［
%位置↗ ~IN { ❝e, ❝E }
］：
◎
If the character indicated by position is U+0065 (e) or a U+0045 (E), then:
</p>
		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
◎
If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
%指数 ~SET ［
%位置↗ ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
◎
If the character indicated by position is a U+002D HYPHEN-MINUS character (-):
• Change exponent to −1.
• Advance position to the next character.
• If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
~IF［
%位置↗ ~IN { ❝-, ❝+ }
］
⇒
%位置 ~INCBY 1
◎
Otherwise, if the character indicated by position is a U+002B PLUS SIGN character (+):
• Advance position to the next character.
• If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
%冪 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
			<li>
%指数 ~SET %指数 ~MUL `Base10$( %冪 )
◎
If the character indicated by position is not an ASCII digit, then jump to the step labeled conversion.
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply exponent by that integer.
</li>
			<li>
%値 ~SET %値 ~MUL ( 10 の %指数 乗 )
◎
Multiply value by ten raised to the exponentth power.
</li>
		</ol>
	</li>
	<li>
%値 ~SET %値 ~MUL %符号
◎
↑↑</li>
	<li>
%S ~LET ［［
有限 IEEE 754 倍精度 浮動小数点数たちが成す集合
］から −0 を除いた集合
］に 2 個の特別な値［
%max ~EQ ( 2 の 1024 乗 ),
%min ~EQ −( 2 の 1024 乗 )
］を追加した集合
◎
Conversion: Let S be the set of finite IEEE 754 double-precision floating-point values except −0, but with two special values added: 21024 and −21024.
</li>
	<li>
%結果 ~LET
%S 内の数であって， %値 に最も近いもの
— ここで、
%値 が %S 内の 2 個の数に等しく近い場合は、
仮数が偶数である方を選ぶ
（この目的においては、
%max, %min の仮数は偶数と見なす）。
◎
Let rounded-value be the number in S that is closest to value, selecting the number with an even significand if there are two equally close values. (The two special values 21024 and −21024 are considered to have even significands for this purpose.)
</li>
	<li>
~IF［
%結果 ~IN { %max, %min }
］
⇒
~RET `失敗^i
◎
If rounded-value is 21024 or −21024, return an error.
</li>
	<li>
~RET %結果
◎
Return rounded-value.
</li>
</ol>

<p class="trans-note">【
この訳では、
等価な結果が得られるように，原文の~algoをかなり簡約している。
】</p>
</div>

				</section>
				<section id="percentages-and-dimensions">
<h5 title="Percentages and lengths">2.3.4.4. 百分率, 長さ</h5>

<div class="algo">
<p>
`寸法~値として構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
( 実数, 種別 ) が成す組 ／ `失敗^i
］を返す
— ここで、
実数は 0.0 以上,
種別は［
`百分率^i, `長さ^i
］のいずれかである：
◎
The rules for parsing dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than or equal to 0.0, or failure; if a number is returned, then it is further categorized as either a percentage or a length.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a position variable for input, initially pointing at the start of input.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET `失敗^i
◎
If position is past the end of input or the code point at position within input is not an ASCII digit, then return failure.
</li>
	<li>
%値 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position, and＼
</li>
	<li>
%値 ~SET `Base10$( %値 )
◎
interpret the resulting sequence as a base-ten integer. Let value be that number.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝.
］：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%小数~部 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
</li>
			<li>
%値 ~INCBY `Frac10$( %小数~部 )
</li>
		</ol>
◎
↓↓If position is past the end of input, then return value as a length.
◎
If the code point at position within input is U+002E (.), then:
• Advance position by 1.
• ↓↓If position is past the end of input or the code point at position within input is not an ASCII digit, then return the current dimension value with value, input, and position.
• Let divisor have the value 1.
• While true:
•• Multiply divisor by ten.
•• Add the value of the code point at position within input, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
•• Advance position by 1.
•• If position is past the end of input, then return value as a length.
•• If the code point at position within input is not an ASCII digit, then break.
</li>
	<li id="current-dimension-value">
~IF［
%位置↗ ~EQ ❝%
］
⇒
~RET ( %値, `百分率^i )
◎
Return the current dimension value with value, input, and position.
◎
The current dimension value, given value, input, and position, is determined as follows:
• If position is past the end of input, then return value as a length.
• If the code point at position within input is U+0025 (%), then return value as a percentage.
• Return value as a length.
</li>
	<li>
~RET ( %値, `長さ^i )
◎
↑</li>
</ol>
</div>

				</section>
				<section id="nonzero-percentages-and-lengths">
<h5 title="Nonzero percentages and lengths">2.3.4.5. 非~zeroの百分率と長さ</h5>

<div class="algo">
<p>
`非~zero寸法~値として構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［［
( 0.0 以上の実数, 種別 ~IN { `百分率^i, `長さ^i } )
が成す組
］ ／ `失敗^i
］を返す：
◎
The rules for parsing nonzero dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.
</p>

<ol>
	<li>
%V ~LET `寸法~値として構文解析する$( %入力 )
◎
Let input be the string being parsed.
◎
Let value be the result of parsing input using the rules for parsing dimension values.
</li>
	<li>
~IF［
%V ~EQ `失敗^i
］~OR ［
%V ~EQ 0
］
⇒
~RET `失敗^i
◎
If value is an error, return an error.
◎
If value is zero, return an error.
</li>
	<li>
~RET %V
◎
If value is a percentage, return value as a percentage.
◎
Return value as a length.
</li>
</ol>
</div>

				</section>
				<section id="lists-of-floating-point-numbers">
<h5 title="Lists of floating-point numbers">2.3.4.6. 浮動小数点数~list</h5>

<p>
❝, で分離された，
0 個以上の`妥当な浮動小数点数$からなる文字列は、
`妥当な浮動小数点数~list@
とされる。
分離子は、
他の文字（`~ASCII空白$など）を含まない。
加えて，許容される 浮動小数点数の個数 には、
制約が課されることもある。
◎
A valid list of floating-point numbers is a number of valid floating-point numbers separated by U+002C COMMA characters, with no other characters (e.g. no ASCII whitespace). In addition, there might be restrictions on the number of floating-point numbers that can be given, or on the range of values allowed.
</p>

<div class="algo">
<p>
`浮動小数点数~listとして構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，次に従う：
◎
The rules for parsing a list of floating-point numbers are as follows:
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%実数~list ~LET 空~list
— この~listが~algoの結果になる。
◎
Let numbers be an initially empty list of floating-point numbers. This list will be the result of this algorithm.
</li>
	<li>
%区切子 ~LET { `~ASCII空白$, ❝,, ❝; }
◎
↓</li>
	<li>
%入力 内の %位置 から
%区切子 からなる`符号位置~並びを収集する$
— これは、
頭部を成す区切子を読飛ばす。
◎
Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past any leading delimiters.
</li>
	<li>
<p>
~WHILE ( %位置↗ ~NEQ ε )：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%入力 内の %位置 から
{ %区切子, `~ASCII数字$, ❝., ❝- }
以外の`符号位置~並びを収集する$
— これは、
頭部を成す無用な文字~並びを読飛ばす。
◎
Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, U+003B SEMICOLON, ASCII digits, U+002E FULL STOP, or U+002D HYPHEN-MINUS characters from input given position. This skips past leading garbage.
</li>
			<li>
%実数~文字列 ~LET 
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position, and let unparsed number be the result.
</li>
			<li>
%実数 ~LET `浮動小数点数として構文解析する$( %実数~文字列 )
◎
Let number be the result of parsing unparsed number using the rules for parsing floating-point number values.
</li>
			<li>
~IF［
%実数 ~EQ `失敗^i
］
⇒
%実数 ~SET 0
◎
If number is an error, set number to zero.
</li>
			<li>
%実数~list に %実数 を付加する
◎
Append number to numbers.
</li>
			<li>
%入力 内の %位置 から
%区切子 からなる`符号位置~並びを収集する$
— これは、
次の区切子を読飛ばす。
◎
Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past the delimiter.
</li>
		</ol>
	<li>
~RET %実数~list
◎
Return numbers.
</li>
</ol>
</div>

				</section>
				<section id="lists-of-dimensions">
<h5 title="Lists of dimensions">2.3.4.7. 寸法~list</h5>

<p class="trans-note">【
この節に与える
`寸法~listとして構文解析する@
規則を利用しているものは、
廃用にされた `frameset$e 要素の `cols^a, `rows^a 属性しかないので
（`参照元＠~HTMLLS#frames-and-framesets$），
和訳は省略する。
】</p>

				</section>
			</section>
			<section id="dates-and-times">
<h4 title="Dates and times">2.3.5. 日時（日付と時刻）</h4>

<div class="algo">
<p>
以下の各種~algoに用いられる
`月tの日t数@
は、
所与の
( %年t, %月t )
に対し，次で与えられる：
</p>
<ol>
	<li>
~IF［
%月t ~IN { 1, 3, 5, 7, 8, 10, 12 }
］
⇒
~RET 31
</li>
	<li>
~IF［
%月t ~IN { 4, 6, 9, 11 }
］
⇒
~RET 30
</li>
	<li>
~Assert：
%月t ~EQ 2
</li>
	<li>
<p>
~RET ［
%年t は ~OR↓ を満たすならば 29 ／
~ELSE_ 28
］
</p>
		<ul>
			<li>
%年t ~EQ ε
</li>
			<li>
%年t は 400 の倍数である
</li>
			<li>
［
%年t は 4 の倍数である
］~AND［
%年t は 100 の倍数でない
］
</li>
		</ul>
	</li>
</ol>

<p>
これは、
~Gregorian暦による閏~年tを織り込んだものである。
`GREGORIAN$r
</p>

◎
In the algorithms below, the number of days in month month of year year is: 31 if month is 1, 3, 5, 7, 8, 10, or 12; 30 if month is 4, 6, 9, or 11; 29 if month is 2 and year is a number divisible by 400, or if year is a number divisible by 4 but not by 100; and 28 otherwise. This takes into account leap years in the Gregorian calendar. [GREGORIAN]
</div>

<p>
この節にて定義される 日時~構文に利用される
`~ASCII数字$列は、
基数 10 の数を表出する。
◎
When ASCII digits are used in the date and time syntaxes defined in this section, they express numbers in base ten.
</p>

<p class="note">注記：
ここに述べる各種~形式は，~ISO8601形式の下位集合に対応するものとして意図されるが、
この仕様は，~ISO8601よりずっと詳細に構文解析~規則を定義する。
したがって実装者には、
下に述べる構文解析~規則を実装するときに日付~構文解析~libraryを利用する際には，その前に，注意深く精査することが奨励される
— その種の~ISO8601~libraryは、
日時を正確に同じ方式で構文解析していないかもしれないので。
`ISO8601$r
◎
While the formats described here are intended to be subsets of the corresponding ISO8601 formats, this specification defines parsing rules in much more detail than ISO8601. Implementers are therefore encouraged to carefully examine any date parsing libraries before using them to implement the parsing rules described below; ISO8601 libraries might not parse dates and times in exactly the same manner. [ISO8601]
</p>

<p>
この仕様における
`遡及~Gregorian暦@
とは、
現代の~Gregorian暦を 0001 年tまで遡って外部補間したものを意味する。
`遡及~Gregorian暦$における日付は、
その暦が当時（または当地域）は利用-中になかったとしても，その暦を利用して記述され、
明示的に
`遡及~Gregorian日付@
と称されることもある。
`GREGORIAN$r
◎
Where this specification refers to the proleptic Gregorian calendar, it means the modern Gregorian calendar, extrapolated backwards to year 1. A date in the proleptic Gregorian calendar, sometimes explicitly referred to as a proleptic-Gregorian date, is one that is described using that calendar even if that calendar was not in use at the time (or place) in question. [GREGORIAN]
</p>

<p class="note">注記：
この仕様における伝送路~形式としての~Gregorian暦の利用は、
文化的な偏向が孕まれた裁定の結果，恣意的に選ばれたものである。
次も見よ
⇒＃
~formにおける`日付, 時刻, 数の形式を論じる節＠~FORMSintro#input-author-notes$（作者~向け）／
`~form~controlを地域化する際の実装~上の注記＠~HEinput#input-impl-notes$／
`time$e 要素
◎
The use of the Gregorian calendar as the wire format in this specification is an arbitrary choice resulting from the cultural biases of those involved in the decision. See also the section discussing date, time, and number formats in forms (for authors), implementation notes regarding localization of form controls, and the time element.
</p>

				<section id="months">
<h5 title="Months">2.3.5.1. 年月t</h5>

<p>
`年月t@
（ `month^en ）は、
日t 成分を伴わない（日t 成分は ε にされた）`日付$である。
◎
A month consists of a specific proleptic-Gregorian date with no time-zone information and no date information beyond a year and a month. [GREGORIAN]
</p>

<p class="trans-note">【
原文の語 “`month^en” には、
暗黙的に年tも含まれている
（ “暦の中のある年tの中のある月t” ）。
単独の月t 成分と混同されないよう、
この定義を指す `month^en は， “年月t” と表記することにする。
】</p>

<p>
次の並びからなる文字列は、
`年月t$を表現している
`妥当な年月t文字列@
とされる：
◎
A string is a valid month string representing a year year and month month if it consists of the following components in the given order:
</p>

<ol>
	<li>
年t 成分を表現する，次を満たす文字列 %年t
⇒
［
%年t は 4 個以上の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %年t ) ~NEQ 0
］
◎
Four or more ASCII digits, representing year, where year &gt; 0
</li>
	<li>
❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
月t 成分を表現する，次を満たす文字列 %月t
⇒
［
%月t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %月t ) ~IN { 1 〜 12 }
］
◎
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
</li>
</ol>

<div class="algo">
<p>
`年月t文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`年月t$ ／ `失敗^i
］を返す：
◎
The rules to parse a month string are as follows. This will return either a year and month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `年月t成分を構文解析する$
◎
↓</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
Parse a month component to obtain year and month. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Return year and month.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の %入力 内の %位置 から
`年月t成分を構文解析する@
規則は、［
`年月t$ ／ `失敗^i
］を返す：
◎
The rules to parse a month component, given an input string and a position, are as follows. This will return either a year and a month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%年t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%年t の`符号位置~長さ$ ~LT 4
］
⇒
~RET `失敗^i
◎
If the collected sequence is not at least four characters long, then fail.＼
</li>
	<li>
%年t数 ~SET `Base10$( %年t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let year be that number.
</li>
	<li>
~IF［
%年t数 ~EQ 0
］
⇒
~RET `失敗^i
◎
If year is not a number greater than zero, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%月t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%月t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%月t数 ~SET `Base10$( %月t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let month be that number.
</li>
	<li>
~IF［
%月t数 ~NIN { 1 〜 12 }
］
⇒
~RET `失敗^i
◎
If month is not a number in the range 1 ≤ month ≤ 12, then fail.
</li>
	<li>
~RET `日付$( %年t数, %月t数, ε )
◎
Return year and month.
</li>
</ol>
</div>

				</section>
				<section id="dates">
<h5 title="Dates">2.3.5.2. 日付</h5>

<div class="p">
<p>
`日付@
（ `date^en ）は、
時間帯~情報は伴わない特定の`遡及~Gregorian日付$ `GREGORIAN$r
を表し， 3 個の正な整数
( 年t, 月t, 日t )
成分からなる。
</p>

<p>
“日付( %年t, %月t, %日t )”
という表記は、
( 年t, 月t, 日t )
成分が，順に
( %年t, %月t, %日t )
にされた`日付$を表すとする。
同様に、
“日付( %年t, %月t, ε )”
という表記は `年月t$を表し，
“日付( ε, %月t, %日t )”
という表記は `月日t$を表すとする。
</p>

◎
A date consists of a specific proleptic-Gregorian date with no time-zone information, consisting of a year, a month, and a day. [GREGORIAN]
</div>

<p>
次の並びからなる文字列は、
`日付$を表現している
`妥当な日付~文字列@
とされる：
◎
A string is a valid date string representing a year year, month month, and day day if it consists of the following components in the given order:
</p>

<ol>
	<li>
( 年t, 月t ) 成分を表現する，`妥当な年月t文字列$
◎
A valid month string, representing year and month
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
日t 成分を表現する，次を満たす文字列 %日t
⇒
［
2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %日t ) ~IN { 1 〜 `月tの日t数$( %年t数, %月t数 ) }
］
◎
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and year year
</li>
</ol>

<div class="algo">
<p>
`日付~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`日付$ ／ `失敗^i
］を返す：
◎
The rules to parse a date string are as follows. This will return either a date, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day.＼
</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Let date be the date with year year, month month, and day day.
◎
Return date.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の %入力 内の %位置 から
`日付~成分を構文解析する@
規則は、［
`日付$ ／ `失敗^i
］を返す：
◎
The rules to parse a date component, given an input string and a position, are as follows. This will return either a year, a month, and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%日付 ~LET `年月t成分を構文解析する$
◎
Parse a month component to obtain year and month.＼
</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
 If this returns nothing, then fail.
</li>
	<li>
%最大日数 ~LET `月tの日t数$( %日付 の年t 成分, %日付 の月t 成分 )
◎
Let maxday be the number of days in month month of year year.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%日t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%日t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%日t数 ~SET `Base10$( %日t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let day be that number.
</li>
	<li>
~IF［
%日t数 ~NIN { 1 〜 %最大日数 }
］
⇒
~RET `失敗^i
◎
If day is not a number in the range 1 ≤ day ≤ maxday, then fail.
</li>
	<li>
%日付 の 日t 成分 ~SET %日t数
◎
↓</li>
	<li>
~RET %日付
◎
Return year, month, and day.
</li>
</ol>
</div>

				</section>
				<section id="yearless-dates">
<h5 title="Yearless dates">2.3.5.3. 月日t</h5>

<p>
`月日t@
（ `yearless date^en, “年なし日付” ）は、
年t 成分を伴わない（年t 成分は ε にされた）`日付$である。
◎
A yearless date consists of a Gregorian month and a day within that month, but with no associated year. [GREGORIAN]
</p>

<p class="trans-note">【
この訳では、
他と表記法を一貫させるため， “月日t” と表記する。
】</p>

<p>
次の並びからなる文字列は、
`月日t$を表現している
`妥当な月日t文字列@
とされる：
◎
A string is a valid yearless date string representing a month month and a day day if it consists of the following components in the given order:
</p>

<ol>
	<li>
0 個または 2 個の ❝-
◎
Optionally, two U+002D HYPHEN-MINUS characters (-)
</li>
	<li>
月t 成分を表現する，次を満たす文字列 %月t
⇒
［
%月t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %月t ) ~IN { 1 〜 12 }
］
◎
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
日t 成分を表現する，次を満たす文字列 %日t
⇒
［
%日t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %日t ) ~IN { 1 〜 `月tの日t数$( ε, `Base10$( %月t ) ) }
］
◎
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and any arbitrary leap year (e.g. 4 or 2000)
</li>
</ol>

<p class="note">注記：
言い換えれば、［
%月t ~EQ `02^l
］ならば、
年t数が閏~年tであったかのように，日t数は 29 もとり得る。
◎
In other words, if the month is "02", meaning February, then the day can be 29, as if the year was a leap year.
</p>

<div class="algo">
<p>
`月日t文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`月日t$ ／ `失敗^i
］を返す：
◎
The rules to parse a yearless date string are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `月日t成分を構文解析する$
◎
Parse a yearless date component to obtain month and day.＼
</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Return month and day.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の %入力 内の %位置 から
`月日t成分を構文解析する@
規則は、［
`月日t$ ／ `失敗^i
］を返す：
◎
The rules to parse a yearless date component, given an input string and a position, are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%seq ~LET %入力 内の %位置 から
❝- からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are U+002D HYPHEN-MINUS characters (-) from input given position.＼
</li>
	<li>
~IF［
%seq の`符号位置~長さ$ ~NIN { 0, 2 }
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly zero or two characters long, then fail.
</li>
	<li>
%月t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%月t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%月t数 ~SET `Base10$( %月t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let month be that number.
</li>
	<li>
~IF［
%月t数 ~NIN { 1 〜 12 }
］
⇒
~RET `失敗^i
◎
If month is not a number in the range 1 ≤ month ≤ 12, then fail.
◎
Let maxday be the number of days in month month of any arbitrary leap year (e.g. 4 or 2000).
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%日t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%日t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%日t数 ~SET `Base10$( %日t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let day be that number.
</li>
	<li>
~IF［
%日t数 ~NIN { 1 〜 `月tの日t数$( ε, %月t数 ) }
］
⇒
~RET `失敗^i
◎
If day is not a number in the range 1 ≤ day ≤ maxday, then fail.
</li>
	<li>
~RET `日付$( ε, %月t数, %日t数 )
◎
Return month and day.
</li>
</ol>
</div>

				</section>
				<section id="times">
<h5 title="Times">2.3.5.4. 時刻</h5>

<div class="p">
<p>
`時刻@
（ `time^en ）は、
時間帯~情報を伴わない特定の時刻を表す，
( 時t, 分t, 秒t )
成分からなる。
時t, 分t
成分は整数であり、
秒t 成分は 小数~部も伴われ得る数である。
</p>

<p>
“時刻( %時t, %分t, %秒t )”
という表記は、
( 時t, 分t, 秒t )
成分が，順に
( %時t, %分t, %秒t )
にされた`時刻$を表すとする。
</p>

◎
A time consists of a specific time with no time-zone information, consisting of an hour, a minute, a second, and a fraction of a second.
</div>

<p>
次の並びからなる文字列は、
`時刻$を表現している
`妥当な時刻~文字列@
とされる：
◎
A string is a valid time string representing an hour hour, a minute minute, and a second second if it consists of the following components in the given order:
</p>

<ol>
	<li>
時t 成分を表現する，次を満たす文字列 %時t
⇒
［
%時t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %時t ) ~IN { 0 〜 23 }
］
◎
Two ASCII digits, representing hour, in the range 0 ≤ hour ≤ 23
</li>
	<li>
1 個の ❝:
◎
A U+003A COLON character (:)
</li>
	<li>
分t 成分を表現する，次を満たす文字列 %分t
⇒
［
%分t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %分t ) ~IN { 0 〜 59 }
］
◎
Two ASCII digits, representing minute, in the range 0 ≤ minute ≤ 59
</li>
	<li>
<p>
空~文字列（ 秒t 成分 0 を表現する）, または
秒t 成分を表現する次の並び：
◎
If second is nonzero, or optionally if second is zero:
</p>
		<ol>
			<li>
1 個の ❝:
◎
A U+003A COLON character (:)
</li>
			<li>
秒t 成分の整数~部を表現する，次を満たす文字列 %秒t
⇒
［
%秒t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %秒t ) ~IN { 0 〜 59 }
］
◎
Two ASCII digits, representing the integer part of second, in the range 0 ≤ s ≤ 59
</li>
			<li>
<p>
空~文字列（ 秒t 成分は整数である）, または
秒tの小数~部を表現する 次の並び：
◎
If second is not an integer, or optionally if second is an integer:
</p>
				<ol>
					<li>
1 個の ❝.
◎
A U+002E FULL STOP character (.)
</li>
					<li>
1 〜 3 個の`~ASCII数字$
◎
One, two, or three ASCII digits, representing the fractional part of second
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
秒t 成分は 60, 61 にはなり得ないので、
閏~秒tは表現できない。
◎
The second component cannot be 60 or 61; leap seconds cannot be represented.
</p>

<p class="trans-note">【
秒t 成分の小数~部は、
`妥当な時刻~文字列$としては 3 桁までにされているが，以下の構文解析-規則の中では 上限はない。
】</p>

<div class="algo">
<p>
`時刻~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`時刻$ ／ `失敗^i
］を返す：
◎
The rules to parse a time string are as follows. This will return either a time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析する$
◎
Parse a time component to obtain hour, minute, and second.＼
</li>
	<li>
~IF［
%時刻 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %時刻
◎
Let time be the time with hour hour, minute minute, and second second.
◎
Return time.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の %入力 内の %位置 から
`時刻~成分を構文解析する@
規則は、［
`時刻$ ／ `失敗^i
］を返す：
◎
The rules to parse a time component, given an input string and a position, are as follows. This will return either an hour, a minute, and a second, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%時t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%時t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%時t数 ~SET `Base10$( %時t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let hour be that number.
</li>
	<li>
~IF［
%時t数 ~NIN { 0 〜 23 }
］
⇒
~RET `失敗^i
◎
If hour is not a number in the range 0 ≤ hour ≤ 23, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝:
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%分t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%分t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%分t数 ~SET `Base10$( %分t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let minute be that number.
</li>
	<li>
~IF［
%分t数 ~NIN { 0 〜 59 }
］
⇒
~RET `失敗^i
◎
If minute is not a number in the range 0 ≤ minute ≤ 59, then fail.
</li>
	<li>
%秒t数 ~LET 0
◎
Let second be 0.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝:
］：
◎
If position is not beyond the end of input and the character at position is U+003A (:), then:
</p>
		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character in input.
</li>
			<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］~OR［
( %位置 ~PLUS 1 )↗ ~NIN `~ASCII数字$
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input, or at the last character in input, or if the next two characters in input starting at position are not both ASCII digits, then fail.
</li>
			<li>
%秒t数 ~SET `Base10$( ［
%位置↗, ( %位置 ~PLUS 1 )↗
］並びからなる文字列
)
◎
↓</li>
			<li>
%位置 ~INCBY 2
◎
↓</li>
			<li>
%小数~部 ~LET %入力 内の %位置 から
{ `~ASCII数字$, ❝. } からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are either ASCII digits or U+002E FULL STOP characters from input given position.＼
</li>
			<li>
<p >
~IF［
%小数~部 ~NEQ 空~文字列
］：
</p>
				<ol>
					<li>
~IF［
%小数~部 の先頭の文字 ~NEQ ❝.
］
⇒
~RET `失敗^i
</li>
					<li>
%小数~部 から先頭の文字を除去する
</li>
					<li>
~IF［
%小数~部 ~EQ 空~文字列
］~OR［
%小数~部 に ❝. が含まれている
］
⇒
~RET `失敗^i
</li>
					<li>
%秒t数 ~INCBY `Frac10$( %小数~部 )
</li>
				</ol>
◎
If the collected sequence is three characters long, or if it is longer than three characters long and the third character is not a U+002E FULL STOP character, or if it has more than one U+002E FULL STOP character, then fail. Otherwise, interpret the resulting sequence as a base-ten number (possibly with a fractional part). Set second to that number.
</li>
		</ol>
	</li>
	<li>
~IF［
%秒t数 ~LT 0
］~OR［
60 ~LTE %秒t数
］
⇒
~RET `失敗^i
◎
If second is not a number in the range 0 ≤ second &lt; 60, then fail.
</li>
	<li>
~RET `時刻$( %時t数, %分t数, %秒t数 )
◎
Return hour, minute, and second.
</li>
</ol>
</div>

				</section>
				<section id="local-dates-and-times">
<h5 title="Local dates and times">2.3.5.5. 局所的~日時</h5>

<p>
`局所的~日時@
（ `local date and time^en ）は、
時間帯は伴わない，
( `日付$, `時刻$ )
成分が成す組である。
形式的には、
偏差~成分が ε にされた`日時$として表出される。
`GREGORIAN$r
◎
A local date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, but expressed without a time zone. [GREGORIAN]
</p>

<p>
次の並びからなる文字列は、
`局所的~日時$を表現している
`妥当な局所的~日時~文字列@
とされる：
◎
A string is a valid local date and time string representing a date and time if it consists of the following components in the given order:
</p>

<ol>
	<li>
日付 成分を表現する，`妥当な日付~文字列$
◎
A valid date string representing the date
</li>
	<li>
1 個の［
❝T, または `0020^U SPACE
］
◎
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
</li>
	<li>
時刻 成分を表現する，`妥当な時刻~文字列$
◎
A valid time string representing the time
</li>
</ol>

<p>
`妥当な局所的~日時~文字列$は、［
その時刻 成分を表現する文字列が，それが表現する時刻をアリな限り最短な文字列で表出する
］ならば、
`妥当な正規化-済み局所的~日時~文字列@
とされる
（例えば，時刻の 秒t 成分が~zeroならば、
秒t 成分を表現する文字列を まるごと省略する）。
◎
A string is a valid normalized local date and time string representing a date and time if it consists of the following components in the given order:
• A valid date string representing the date
• A U+0054 LATIN CAPITAL LETTER T character (T)
• A valid time string representing the time, expressed as the shortest possible string for the given time (e.g. omitting the seconds component entirely if the given time is zero seconds past the minute)
</p>

<div class="algo">
<p>
`局所的~日時~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`局所的~日時$ ／ `失敗^i
］を返す：
◎
The rules to parse a local date and time string are as follows. This will return either a date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day.＼
</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NIN { ❝T, `0020^U SPACE }
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析する$
◎
Parse a time component to obtain hour, minute, and second.＼
</li>
	<li>
~IF［
%時刻 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET `日時$( %日付, %時刻, ε )
◎
Let date be the date with year year, month month, and day day.
◎
Let time be the time with hour hour, minute minute, and second second.
◎
Return date and time.
</li>
</ol>
</div>

				</section>
				<section id="time-zones">
<h5 title="Time zones">2.3.5.6. 時間帯</h5>

<div class="p">
<p>
`偏差@
（ `time-zone offset^en ）は、
2 個の有符号~整数
( 時t, 分t )
成分からなる。
</p>

<p class="trans-note">【
偏差は、
~UTCからの偏差
— すなわち，時間帯（ `time zone^en ） —
を表す。
データとしては，時間帯も偏差も同じであり、
何が念頭に置かれるか以外に違いはない。
】</p>

<p>
“偏差( %時t, %分t )”
という表記は、
( 時t, 分t )
成分が，順に
( %時t, %分t )
にされた`偏差$を表すとする。
</p>

◎
A time-zone offset consists of a signed number of hours and minutes.
</div>

<p>
次のいずれかで与えられる文字列は、
偏差を表現している
`妥当な偏差~文字列@
とされる：
◎
A string is a valid time-zone offset string representing a time-zone offset if it consists of either:
</p>

<ul>
	<li>
時間帯が~UTC
【すなわち，偏差( 0, 0 )】
の場合に限り
⇒
1 個の ❝Z
◎
A U+005A LATIN CAPITAL LETTER Z character (Z), allowed only if the time zone is UTC
</li>
	<li>
<p>
または、
次の並びからなる文字列：
◎
Or, the following components, in the given order:
</p>
		<ol>
	<li>
偏差の各~成分の符号を表現する，
❝+ , または ❝-
— ただし，偏差の両~成分とも~zeroの場合、
後者は許容されない。
◎
Either a U+002B PLUS SIGN character (+) or, if the time-zone offset is not zero, a U+002D HYPHEN-MINUS character (-), representing the sign of the time-zone offset
</li>
	<li>
偏差の時t 成分を表現する，次を満たす文字列 %時t
⇒
［
%時t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %時t ) ~IN { 0 〜 23 }
］
◎
Two ASCII digits, representing the hours component hour of the time-zone offset, in the range 0 ≤ hour ≤ 23
</li>
	<li>
0 〜 1 個の ❝:
◎
Optionally, a U+003A COLON character (:)
</li>
	<li>
偏差の分t 成分を表現する，次を満たす文字列 %分t
⇒
［
%分t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %分t ) ~IN { 0 〜 59 }
］
◎
Two ASCII digits, representing the minutes component minute of the time-zone offset, in the range 0 ≤ minute ≤ 59
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
この形式は、
範囲
{ −23:59 〜 +23:59 }
の偏差を許容する。
今現在，実施においては、
実際の時間帯の範囲は
{ −12:00 〜 +14:00 }
であり，実際の時間帯の分t 成分は、
常に ［
00, 30, 45
］のいずれかにされている。
しかしながら、
永劫にそうあり続ける保証はない
— 時間帯は政治的駆引きにも利用されており、
気まぐれな政治的裁定の~subjectになるので。
◎
This format allows for time-zone offsets from -23:59 to +23:59. Right now, in practice, the range of offsets of actual time zones is -12:00 to +14:00, and the minutes component of offsets of actual time zones is always either 00, 30, or 45. There is no guarantee that this will remain so forever, however, since time zones are used as political footballs and are thus subject to very whimsical policy decisions.
</p>

<p class="note">注記：
偏差を［
正式な時間帯の制定~以前の歴史的な時刻
］と併用する際の詳細~については、
下の § `大域的~日時$における用法についての注記, および例も見よ。
◎
See also the usage notes and examples in the global date and time section below for details on using time-zone offsets with historical times that predate the formation of formal time zones.
</p>

<div class="algo">
<p>
`偏差~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
偏差 ／ `失敗^i
］を返す：
◎
The rules to parse a time-zone offset string are as follows. This will return either a time-zone offset, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%偏差 ~LET `偏差~成分を構文解析する$
◎
Parse a time-zone offset component to obtain timezonehours and timezoneminutes.＼
</li>
	<li>
~IF［
%偏差 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %偏差
◎
Return the time-zone offset that is timezonehours hours and timezoneminutes minutes from UTC.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の %入力 内の %位置 から
`偏差~成分を構文解析する@
規則は、［
`偏差$ ／ `失敗^i
］を返す：
◎
The rules to parse a time-zone offset component, given an input string and a position, are as follows. This will return either time-zone hours and time-zone minutes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%符号 ~LET %位置↗
◎
↓</li>
	<li>
~IF［
%符号 ~NIN { ❝+, ❝-, ❝Z }
］
⇒
~RET `失敗^i
◎
↓↓</li>
	<li>
%位置 ~INCBY 1
◎
↓</li>
	<li>
~IF［
%符号 ~EQ ❝Z
］
⇒
~RET `偏差$( 0, 0 )
◎
↓↓If the character at position is a U+005A LATIN CAPITAL LETTER Z character (Z), then:
• Let timezonehours be 0.
• Let timezoneminutes be 0.
• ↑Advance position to the next character in input.
◎
Otherwise, if the character at position is either a U+002B PLUS SIGN (+) or a U+002D HYPHEN-MINUS (-), then:
• If the character at position is a U+002B PLUS SIGN (+), let sign be "positive". Otherwise, it's a U+002D HYPHEN-MINUS (-); let sign be "negative".
• ↑Advance position to the next character in input.
</li>
	<li>
%時t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
• Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
%分t ~LET ε
◎
• Let s be the collected sequence.
</li>
	<li>
<p>
~IF［
%時t の`符号位置~長さ$ ~EQ 2
］：
</p>
		<ol>
			<li>
~IF［
%位置↗ ~NEQ ❝:
］
⇒
~RET `失敗^i
</li>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%分t ~SET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
</li>
			<li>
~IF［
%分t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
</li>
		</ol>
◎
• If s is exactly two characters long, then:
•• Interpret s as a base-ten integer. Let timezonehours be that number.
•• If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise, move position forwards one character.
•• Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let timezoneminutes be that number.
</li>
	<li>
~ELIF［
%時t の`符号位置~長さ$ ~EQ 4
］
⇒
( %時t, %分t ) ~SET %時t の ( 最初の 2 文字, 最後の 2 文字 )
◎
• If s is exactly four characters long, then:
•• Interpret the first two characters of s as a base-ten integer. Let timezonehours be that number.
•• Interpret the last two characters of s as a base-ten integer. Let timezoneminutes be that number.
</li>
	<li>
~ELSE
⇒
~RET `失敗^i
◎
• Otherwise, fail.
</li>
	<li>
( %時t数, %分t数 ) ~LET ( `Base10$( %時t ), `Base10$( %分t ) )
◎
↑</li>
	<li>
~IF［
%時t数 ~NIN { 0 〜 23 }
］~OR［
%分t数 ~NIN { 0 〜 59 }
］
⇒
~RET `失敗^i
◎
• If timezonehours is not a number in the range 0 ≤ timezonehours ≤ 23, then fail.
• If sign is "negative", then negate timezonehours.
• If timezoneminutes is not a number in the range 0 ≤ timezoneminutes ≤ 59, then fail.
• If sign is "negative", then negate timezoneminutes.
</li>
	<li>
~IF［
%符号 ~EQ ❝-
］
⇒
~RET `偏差$( %時t数 ~MUL −1, %分t数 ~MUL −1 )
◎
↑</li>
	<li>
~RET `偏差$( %時t数, %分t数 )
◎
↑↑Otherwise, fail.
◎
Return timezonehours and timezoneminutes.
</li>
</ol>
</div>

				</section>
				<section id="global-dates-and-times">
<h5 title="Global dates and times">2.3.5.7. 大域的~日時</h5>

<div class="p">
<p>
`大域的~日時@
（ `global date and time^en ）は、
( `日付$, `時刻$, `偏差$ )
成分が成す組で表される。
</p>

<p class="trans-note">【
［
`日付$, `時刻$
］成分のみで，~UTC世界時（地域に依存しない日時）が表現される。
`偏差$ 成分は、［
利用者に呈示する（`局所的~日時$に変換するなど） ／
文字列に直列化して外部に渡す
］ときに利用される付帯~情報になる。
】</p>

<p>
“日時( %日付, %時刻, %偏差 )”
という表記は、
( `日付$, `時刻$, `偏差$ )
成分が，順に
( %日付, %時刻, %偏差 )
にされた`大域的~日時$を表出する（ %偏差 ~NEQ ε ならば）。
同様に、
“日時( %日付, %時刻, ε )”
という表記は `局所的~日時$を表出するとする。
</p>

◎
A global date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, expressed with a time-zone offset, consisting of a signed number of hours and minutes. [GREGORIAN]
</div>

<p>
次の並びからなる文字列は、
`大域的~日時$を表現している
`妥当な大域的~日時~文字列@
とされる：
◎
A string is a valid global date and time string representing a date, time, and a time-zone offset if it consists of the following components in the given order:
</p>

<ol>
	<li>
日付 成分を表現する，`妥当な日付~文字列$
◎
A valid date string representing the date
</li>
	<li>
1 個の［
❝T または `0020^U SPACE
］
◎
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
</li>
	<li>
時刻 成分を表現する，`妥当な時刻~文字列$
◎
A valid time string representing the time
</li>
	<li>
偏差 成分を表現する，`妥当な偏差~文字列$
◎
A valid time-zone offset string representing the time-zone offset
</li>
</ol>

<p>
［
20 世紀~中頃における~UTCの制定~以前の日付
］による時刻は、
次を通して表出され, 解釈されなければナラナイ
⇒
~UT1世界時の用語（経度 0° の地点における当時の太陽時）
— ~UTC（ SI 単位による秒t数で刻む ~UT1の，近似）ではなく。
◎
Times in dates before the formation of UTC in the mid-twentieth century must be expressed and interpreted＼
in terms of UT1 (contemporary Earth solar time at the 0° longitude), not UTC (the approximation of UT1 that ticks in SI seconds).＼
</p>

<p>
［
時間帯の制定~以前の日付
］による時刻は、［
次を近似する明示的な時間帯
］を伴う~UT1時刻として表出され, 解釈されなければナラナイ
⇒
当時における，［
適切な局所的~時刻,
~London `Greenwich^en の所在にて観測される時刻
］の間の相違
◎
Time before the formation of time zones must be expressed and interpreted as UT1 times with explicit time zones that approximate＼
the contemporary difference between the appropriate local time and the time observed at the location of Greenwich, London.
</p>

<div class="example">
<p>
`妥当な大域的~日時~文字列$として記される日付の例を以下に挙げる：
◎
The following are some examples of dates written as valid global date and time strings.
</p>

<dl>
	<dt>`0037-12-13 00:00Z^l</dt>
	<dd>
~London時刻を利用している地域における，~Nero（~Roman-Emperor）の誕生日の真夜中。
これに実際に対応する日付についての更なる論点については下を見よ。
◎
Midnight in areas using London time on the birthday of Nero (the Roman Emperor). See below for further discussion on which date this actually corresponds to.
</dd>

	<dt>`1979-10-14T12:00:00.001-04:00^l</dt>
	<dd>
USA 東海岸の夏時間にて利用-中にある時間帯における，［
1979 年 10 月 14 日
］の真昼から 1 ~milli秒t後。
◎
One millisecond after noon on October 14th 1979, in the time zone in use on the east coast of the USA during daylight saving time.
</dd>

	<dt>`8592-01-01T02:09+02:09^l</dt>
	<dd>
~UTCによる［
8592 年 1 月 1 日
］の真夜中。
この時刻には、
~UTCより 2 ~~時間 9 分 進んでいる時間帯が結付けられている
— それは、
現在~~実用されている時間帯ではないが，許容される。
◎
Midnight UTC on the 1st of January, 8592. The time zone associated with that time is two hours and nine minutes ahead of UTC, which is not currently a real time zone, but is nonetheless allowed.
</dd>
</dl>

<p>
これらの日付について注目すべき点は：
◎
Several things are notable about these dates:
</p>

<ul>
	<li>
4 桁に満たない年tは~zero詰めされる必要がある。
`37-12-13^l は妥当な日付でない。
◎
Years with fewer than four digits have to be zero-padded. The date "37-12-13" would not be a valid date.
</li>
	<li>
`T^l に代えて~SPACEを用いる場合、
1 個の~SPACEでなければナラナイ。
文字列
`2001-12-21&nbsp;&nbsp;12:00Z^l
（成分~間に 2 個の~SPACEがある）は、
成功裡に構文解析されない。
◎
If the "T" is replaced by a space, it must be a single space character. The string "2001-12-21 12:00Z" (with two spaces between the components) would not be parsed successfully.
</li>
	<li>
［
~Gregorian暦が導入される以前の時刻
］を一義的に識別するため
（~UTCの制定~以前の時刻を一義的に識別できるようにする限りにおいて）、
日付は，先ず［
当の時刻にて利用-中にあった暦（例： ~Julian暦 ）から，~Gregorian暦に変換する
］必要がある。
~Nero生誕の日付は、
~Julian暦においては
37 年 12 月 15 日
であり，
`遡及~Gregorian暦$においては
37 年 12 月 13 日
になる。
◎
To unambiguously identify a moment in time prior to the introduction of the Gregorian calendar (insofar as moments in time before the formation of UTC can be unambiguously identified), the date has to be first converted to the Gregorian calendar from the calendar in use at the time (e.g. from the Julian calendar). The date of Nero's birth is the 15th of December 37, in the Julian Calendar, which is the 13th of December 37 in the proleptic Gregorian calendar.
</li>
	<li>
［
時刻, 偏差
］両~成分とも省略可能でない。
◎
The time and time-zone offset components are not optional.
</li>
	<li>
0001 年t より前の日付は、
この~versionの~HTMLにおいては，日時として表現できない。
◎
Dates before the year one can't be represented as a datetime in this version of HTML.
</li>
	<li>
前近代における特定の出来事の時刻は、
最良でも近似である
— 時刻は比較的近代まで，きちんと協調されても測定されてもいなかったので。
◎
Times of specific events in ancient times are, at best, approximations, since time was not well coordinated or measured until relatively recent decades.
</li>
	<li>
偏差は、
夏時間に基づいて相違する。
◎
Time-zone offsets differ based on daylight saving time.
</li>
</ul>
</div>

<div class="algo">
<p>
`大域的~日時~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`大域的~日時$ ／ `失敗^i
］を返す：
◎
The rules to parse a global date and time string are as follows. This will return either a time in UTC, with associated time-zone offset information for round-tripping or display purposes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day.＼
</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NIN { ❝T, `0020^U SPACE }
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析する$
◎
Parse a time component to obtain hour, minute, and second.＼
</li>
	<li>
~IF［
%時刻 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input, then fail.
</li>
	<li>
%偏差 ~LET `偏差~成分を構文解析する$
◎
Parse a time-zone offset component to obtain timezonehours and timezoneminutes.＼
</li>
	<li>
~IF［
%偏差 ~EQ `失敗^i
］
⇒
~RET `失敗^i
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
( %日付, %時刻 ) ~LET ( %日付, %時刻 ) から %偏差 を減算した結果†
— この結果が~UTC時間帯における時刻を表す。
◎
Let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes. That moment in time is a moment in the UTC time zone.
</li>
	<li>
~RET `日時$( %日付, %時刻, %偏差 )
◎
Let timezone be timezonehours hours and timezoneminutes minutes from UTC.
◎
Return time and timezone.
</li>
</ol>

<p class="trans-note">【†
“減算する” ための具体的な~algoは、
この仕様には述べられていない。
%入力 においては，年t 成分に対する
`~zeroは許容されていない＠#parse-a-month-component$が、
減算した結果の年tは，~zeroになり得る。
】</p>
</div>

				</section>
				<section id="weeks">
<h5 title="Weeks">2.3.5.8. 年週t</h5>

<div class="p">
<p>
`年週t@
（ `week^en ）は、
2 個の正な整数
( 週年t, 週t )
成分からなり，`遡及~Gregorian暦$における ある［
月曜から開始する七日間
］を表現する。
この暦付け~systemにおける各 週年tは、
そのような七日間を 52 回または 53 回 有する
— 下に定義されるように。
~Gregorian日付［
1969 年 12 月 29 日の月曜（ 1969-12-29 ）
］から開始する七日間は、［
週年t 1970 における第 1 週t
］として定義される。
ある週年tにおける各 週tは、
1 から連列的に付番される。
ある週年tにおける第 1 週tより前の週tは、
その前の週年tにおける最後の週tであり，その逆も同様である。
`GREGORIAN$r
</p>

<p class="trans-note">【
`年月t$のときと同様に、
この訳では “年週t” と表記する。
】</p>

<p>
“年週t( %週年t, %週t )”
という表記は、
( 週年t, 週t )
成分が，順に
( %週年t, %週t )
にされた`年週t$を表すとする。
</p>

◎
A week consists of a week-year number and a week number representing a seven-day period starting on a Monday. Each week-year in this calendaring system has either 52 or 53 such seven-day periods, as defined below. The seven-day period starting on the Gregorian date Monday December 29th 1969 (1969-12-29) is defined as week number 1 in week-year 1970. Consecutive weeks are numbered sequentially. The week before the number 1 week in a week-year is the last week in the previous week-year, and vice versa. [GREGORIAN]
</div>

<div class="p">
<p>
週年t %Y の
`最後の日tの週t番号@
— “週t数( %Y )” とも表記される —
は、
~OR↓ が満たされるならば 53 とされ，他の場合は 52 とされる：
</p>

<ul>
	<li>
［［
`遡及~Gregorian暦$における年t %Y
］の最初の日t（ 1 月 1 日 ）の曜日
］は、
火曜である
</li>
	<li>
<p>
［
前項の曜日は 水曜である
］~AND［
%Y は ~OR↓ を満たす
］：
</p>
		<ul>
			<li>
400 の倍数である
</li>
			<li>
［
4 の倍数である
］~AND［
100 の倍数でない
］
</li>
		</ul>
	</li>
</ul>

◎
A week-year with a number year has 53 weeks if it corresponds to either a year year in the proleptic Gregorian calendar that has a Thursday as its first day (January 1st), or a year year in the proleptic Gregorian calendar that has a Wednesday as its first day (January 1st) and where year is a number divisible by 400, or a number divisible by 4 but not by 100. All other week-years have 52 weeks.
◎
The week number of the last day of a week-year with 53 weeks is 53; the week number of the last day of a week-year with 52 weeks is 52.
</div>

<p class="note">注記：
年末年始の特定0の日tにおける週年tと，`遡及~Gregorian暦$における その日tを包含する年tとは、
異なることもある。
週年t %Y における最初の週tは、
~Gregorian年t %Y の最初の火曜を包含する週tである
【そうなるように、年週tは定義されている】
。
◎
The week-year number of a particular day can be different than the number of the year that contains that day in the proleptic Gregorian calendar. The first week in a week-year y is the week that contains the first Thursday of the Gregorian year y.
</p>

<p class="note">注記：
現代の目的においては、
ここに定義される`年週t$は、
`ISO8601$r に定義される週tと等価になる。
◎
For modern purposes, a week as defined here is equivalent to ISO weeks as defined in ISO 8601. [ISO8601]
</p>

<p>
次の並びからなる文字列は、
`年週t$を表現している
`妥当な年週t文字列@
とされる：
◎
A string is a valid week string representing a week-year year and week week if it consists of the following components in the given order:
</p>

<ol>
	<li>
年週tの週年t 成分を表現する，次を満たす文字列 %週年t
⇒
［
%週年t は 4 個以上の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %週年t ) ~NEQ 0
］
◎
Four or more ASCII digits, representing year, where year &gt; 0
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
1 個の ❝W
◎
A U+0057 LATIN CAPITAL LETTER W character (W)
</li>
	<li>
年週tの週t 成分を表現する，次を満たす文字列 %週t
⇒
［
%週t は 2 個の`~ASCII数字$が成す並びである
］~AND［
`Base10$( %週t ) ~IN { 1 〜 `週t数$( %週年t が表現する週年t ) }
］
◎
Two ASCII digits, representing the week week, in the range 1 ≤ week ≤ maxweek, where maxweek is the week number of the last day of week-year year
</li>
</ol>

<div class="algo">
<p>
`年週t文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`年週t$ ／ `失敗^i
］を返す：
◎
The rules to parse a week string are as follows. This will return either a week-year number and week number, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%年t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%年t の`符号位置~長さ$ ~LT 4
］
⇒
~RET `失敗^i
◎
If the collected sequence is not at least four characters long, then fail.＼
</li>
	<li>
%年t数 ~SET `Base10$( %年t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let year be that number.
</li>
	<li>
~IF［
%年t数 ~EQ 0
］
⇒
~RET `失敗^i
◎
If year is not a number greater than zero, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝W
］
⇒
~RET `失敗^i
◎
If position is beyond the end of input or if the character at position is not a U+0057 LATIN CAPITAL LETTER W character (W), then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%週t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%週t の`符号位置~長さ$ ~NEQ 2
］
⇒
~RET `失敗^i
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%週t数 ~SET `Base10$( %週t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the week.
</li>
	<li>
~IF［
%週t数 ~NIN { 1 〜 `週t数$( %年t数 ) }
］
⇒
~RET `失敗^i
◎
Let maxweek be the week number of the last day of year year.
◎
If week is not a number in the range 1 ≤ week ≤ maxweek, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET 
`年週t$( %年t数, %週t数 )
◎
Return the week-year number year and the week number week.
</li>
</ol>
</div>

				</section>
				<section id="durations">
<h5 title="Durations">2.3.5.9. 時間長</h5>

<p>
`時間長@
（ `duration^en ）は、
（負でない）秒t数である。
◎
A duration consists of a number of seconds.
</p>

<p class="note">注記：
月t数と秒t数は，比較-可能でないので
（月tは精確な秒t数を表さない
— その正確な長さは，測定し始める精確な日tに依存する期間である）、
この仕様にて定義される`時間長$には，月tは含められない
（したがって月t数 12 に等価な年tも）。
記述できるのは、
特定の秒t数を述べる時間長に限られる。
◎
Since months and seconds are not comparable (a month is not a precise number of seconds, but is instead a period whose exact length depends on the precise day from which it is measured) a duration as defined in this specification cannot include months (or years, which are equivalent to twelve months). Only durations that describe a specific number of seconds can be described.
</p>

<p>
次のいずれかからなる文字列は、
`時間長$を表現している
`妥当な時間長~文字列@
とされる：
◎
A string is a valid duration string representing a duration t if it consists of either of the following:
</p>

<ul>
	<li>
<p>
文字 ❝P に［
次の並びが成す空でない文字列
］を付加して得られる文字列
— その中で与えられる
( 日t数, 時t数, 分t数, 秒t数 )
に対する
( 日t数 ~MUL 86400 ~PLUS 時t数 ~MUL 3600 ~PLUS 分t数 ~MUL 60 ~PLUS 秒t数 )
が、
`時間長$を与える
（どの空~文字列も 0 に解釈する）：
◎
A literal U+0050 LATIN CAPITAL LETTER P character followed by one or more of the following subcomponents, in the order given, where the number of days, hours, minutes, and seconds corresponds to the same number of seconds as in t:
</p>
		<ol>
			<li>
日t数を表現する［
空~文字列／次の並び
］
⇒＃
1 個以上の`~ASCII数字$,
1 個の ❝D
◎
One or more ASCII digits followed by a U+0044 LATIN CAPITAL LETTER D character, representing a number of days.
</li>
			<li>
<p>
空~文字列
— ( 時t数, 分t数, 秒t数 ) いずれも 0 を表現する —
または、
文字 ❝T に［
次の並びが成す空でない文字列
］を付加して得られる文字列：
◎
A U+0054 LATIN CAPITAL LETTER T character followed by one or more of the following subcomponents, in the order given:
</p>

				<ol>
					<li>
時t数を表現する［
空~文字列／次の並び
］
⇒＃
1 個以上の`~ASCII数字$,
1 個の ❝H
◎
One or more ASCII digits followed by a U+0048 LATIN CAPITAL LETTER H character, representing a number of hours.
</li>
					<li>
分t数を表現する［
空~文字列／次の並び
］
⇒＃
1 個以上の`~ASCII数字$,
1 個の ❝M
◎
One or more ASCII digits followed by a U+004D LATIN CAPITAL LETTER M character, representing a number of minutes.
</li>
					<li>
<p>
秒t数を表現する［
空~文字列／次の並び
］：
◎
The following components:
</p>

						<ol>
							<li>
1 個以上の`~ASCII数字$
◎
One or more ASCII digits, representing a number of seconds.
</li>
							<li>
秒tの小数~部を表現する［
空~文字列／次の並び
］
⇒＃
1 個の ❝.,
1 〜 3 個の`~ASCII数字$
◎
Optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.
</li>
							<li>
1 個の ❝S
◎
A U+0053 LATIN CAPITAL LETTER S character.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
これは、
この仕様にて日時に関係する他の各種 小構文に定義される形式と同じく，
`ISO8601$r にて定義されるいずれかの形式に基づく。
◎
This, as with a number of other date- and time-related microsyntaxes defined in this specification, is based on one of the formats defined in ISO 8601. [ISO8601]
</p>
	</li>
	<li>
<p>
任意の順序による， 1 個以上の各種 `時間長~成分$
— それぞれの`時間長~成分の縮尺$は互いに異なるような。
それぞれが表現する秒t数の総和が、
`時間長$を与える。
◎
One or more duration time components, each with a different duration time component scale, in any order; the sum of the represented seconds being equal to the number of seconds in t.
</p>

<p>
次の並びからなる文字列が
`時間長~成分@
（ `duration time component^en ）とされる：
◎
A duration time component is a string consisting of the following components:
</p>

<ol>
	<li>
0 個以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
1 個以上の `~ASCII数字$
— 時間~単位~数を表現し、
( この数 ~MUL 下に指定される`時間長~成分の縮尺$ )
が，この時間長~成分の秒t数を表現する。
◎
One or more ASCII digits, representing a number of time units, scaled by the duration time component scale specified (see below) to represent a number of seconds.
</li>
	<li>
`時間長~成分の縮尺$ ~EQ 1 の場合（すなわち，単位は秒t）に限り
⇒
空~文字列, または 秒tの小数~部を表現する次の並び
⇒＃
1 個の ❝.,
1 〜 3 個の`~ASCII数字$
◎
If the duration time component scale specified is 1 (i.e. the units are seconds), then, optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.
</li>
	<li>
0 個以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
<p>
次の表tの最初の列に与えるいずれかの文字
— 同じ行の “縮尺” の列が
`時間長~成分の縮尺@
を与える：
</p>

<table><thead>
<tr><th>文字
<th>単位
<th>縮尺

<tbody><tr><td>❝W, ❝w
<td>週t
<td>604800

<tr><td>❝D, ❝d
<td>日t
<td>86400

<tr><td>❝H, ❝h
<td>時t
<td>3600

<tr><td>❝M, ❝m
<td>分t
<td>60

<tr><td>❝S, ❝s
<td>秒t
<td>1
</table>

◎
One of the following characters, representing the duration time component scale of the time unit used in the numeric part of the duration time component:
• U+0057 LATIN CAPITAL LETTER W character
• U+0077 LATIN SMALL LETTER W character
•• Weeks. The scale is 604800.
• U+0044 LATIN CAPITAL LETTER D character
• U+0064 LATIN SMALL LETTER D character
•• Days. The scale is 86400.
• U+0048 LATIN CAPITAL LETTER H character
• U+0068 LATIN SMALL LETTER H character
•• Hours. The scale is 3600.
• U+004D LATIN CAPITAL LETTER M character
• U+006D LATIN SMALL LETTER M character
•• Minutes. The scale is 60.
• U+0053 LATIN CAPITAL LETTER S character
• U+0073 LATIN SMALL LETTER S character
•• Seconds. The scale is 1.
</li>
	<li>
0 個以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
</ol>

<p class="note">注記：
これは、
~ISO8601のどの形式に基づくものでもない。
これは、
~ISO8601時間長~形式より，ヒトが読み易い代替を与えるために意図されている。
◎
This is not based on any of the formats in ISO 8601. It is intended to be a more human-readable alternative to the ISO 8601 duration format.
</p>

	</li>
</ul>

<div class="algo">
<p>
`時間長~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`時間長$ ／ `失敗^i
］を返す：
◎
The rules to parse a duration string are as follows. This will return either a duration or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
( %月t数, %秒t数, %成分なしか )
~LET ( 0, 0, ~T )
◎
Let months, seconds, and component count all be zero.
</li>
	<li>

<p>
%M一義化子 ~LET `分t^i
◎
Let M-disambiguator be minutes.
</p>

<p class="note">注記：
%M一義化子 が他にとり得る値は `月t^i である。
これは、
月t数と分t数に同じ単位を利用している
~ISO8601時間長における "M" 単位を一義化するために利用される。
月t数は %入力 に許容されないが、
将来との互換性をとるため, および
他の文脈においては妥当になるような~ISO8601時間長の誤解釈を避けるために構文解析される。
◎
This flag's other value is months. It is used to disambiguate the "M" unit in ISO8601 durations, which use the same unit for months and minutes. Months are not allowed, but are parsed for future compatibility and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.
</p>

	</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
◎
If position is past the end of input, then fail.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝P 
］：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%M一義化子 ~SET `月t^i
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
		</ol>

◎
If the character in input pointed to by position is a U+0050 LATIN CAPITAL LETTER P character, then advance position to the next character, set M-disambiguator to months, and skip ASCII whitespace within input given position.
</li>
	<li>

<p>
~WHILE %位置↗ ~NEQ ε：
【！ ＊】
◎
While true:
• Let units be undefined. It will be assigned one of the following values: years, months, weeks, days, hours, minutes, and seconds.
• Let next character be undefined. It is used to process characters from the input.
• If position is past the end of input, then break.
</p>
		<ol>
			<li>
( %単位, %縮尺 ) ~LET ( ε, ε )
◎
↑</li>
			<li>
<p>
~IF［
%位置↗ ~EQ ❝T
］：
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
%M一義化子 ~SET `分t^i
</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
					<li>
~CONTINUE
</li>
				</ol>

【！T が複数個連続していても許容される】
◎
If the character in input pointed to by position is a U+0054 LATIN CAPITAL LETTER T character, then advance position to the next character, set M-disambiguator to minutes, skip ASCII whitespace within input given position, and continue.
</li>
			<li>
~IF［
%位置↗ ~NIN { `~ASCII数字$, ❝. }
］
⇒
~RET `失敗^i
◎
↓</li>
			<li>
%N ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
			<li>
%N ~SET `Base10$( %N )
◎
Set next character to the character in input pointed to by position.
• If next character is a U+002E FULL STOP character (.), then let N equal zero. (Do not advance position. That is taken care of below.)
• Otherwise, if next character is an ASCII digit, then collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as a base-ten integer, and let N be that number.
• Otherwise, next character is not part of a number; fail.
• If position is past the end of input, then fail.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ ❝.
］：
◎
Set next character to the character in input pointed to by position, and this time advance position to the next character. (If next character was a U+002E FULL STOP character (.) before, it will still be that character this time.)
◎
If next character is U+002E (.), then:
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
%s ~LET %入力 内の %位置 から`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position. Let s be the resulting sequence.
</li>
					<li>
~IF［
%s ~EQ 空~文字列
］
⇒
~RET `失敗^i
◎
If s is the empty string, then fail.
</li>
					<li>
%N ~INCBY `Frac10$( %s )
◎
Let length be the number of characters in s.
◎
Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.
◎
Increment N by fraction.
</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
					<li>
%s ~SET %位置↗
</li>
					<li>
%位置 ~INCBY 1
</li>
					<li>
~IF［
%s ~NIN { ❝S, ❝s }
］
⇒
~RET `失敗^i
◎
If position is past the end of input, then fail.
◎
Set next character to the character in input pointed to by position, and advance position to the next character.
◎
If next character is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN SMALL LETTER S character, then fail.
</li>
					<li>
%単位 ~SET `秒t^i
◎
Set units to seconds.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
If next character is ASCII whitespace, then skip ASCII whitespace within input given position, set next character to the character in input pointed to by position, and advance position to the next character.
</li>
					<li>
<p>
( %単位, %縮尺, %M一義化子 ) ~SET 
%位置↗ に応じて，次の表tで与えられる値：
</p>

<table><thead>
<tr><th>%位置↗
<th>%単位
<th>%縮尺
<th>%M一義化子

<tbody><tr><td>❝Y, ❝y
<td>`年t^i
<td>ε
<td>`月t^i

<tr><td>❝M, ❝m
<td>%M一義化子
<td>60
<td>%M一義化子

<tr><td>❝W, ❝w
<td>`週t^i
<td>604800
<td>`分t^i

<tr><td>❝D, ❝d
<td>`日t^i
<td>86400
<td>`分t^i

<tr><td>❝H, ❝h
<td>`時t^i
<td>3600
<td>`分t^i

<tr><td>❝S, ❝s
<td>`秒t^i
<td>1
<td>`分t^i

<tr><td>その他
<td>ε
<td>ε
<td>ε
</table>

◎
If next character is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL LETTER Y character, set units to years and set M-disambiguator to months.
◎
If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is months, then set units to months.
◎
If next character is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL LETTER W character, set units to weeks and set M-disambiguator to minutes.
◎
If next character is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL LETTER D character, set units to days and set M-disambiguator to minutes.
◎
If next character is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL LETTER H character, set units to hours and set M-disambiguator to minutes.
◎
If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is minutes, then set units to minutes.
◎
If next character is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL LETTER S character, set units to seconds and set M-disambiguator to minutes.
</li>
					<li>
%位置 ~INCBY 1
◎
↑</li>
					<li>
~IF［
%単位 ~EQ ε
］
⇒
~RET `失敗^i
◎
Otherwise, if next character is none of the above characters, then fail.
</li>
				</ol>
			</li>
			<li>
%成分なしか ~SET ~F
◎
Increment component count.
</li>
			<li>
<p>
%単位 に応じて：
</p>

<dl class="switch">
	<dt>`年t^i</dt>
	<dd>
%月t数 ~INCBY %N ~MUL 12
</dd>

	<dt>`月t^i</dt>
	<dd>
%月t数 ~INCBY %N
</dd>

	<dt>その他</dt>
	<dd>
%秒t数 ~INCBY %N ~MUL %縮尺
</dd>
</dl>

◎
Let multiplier be 1.
◎
If units is years, multiply multiplier by 12 and set units to months.
◎
If units is months, add the product of N and multiplier to months.
◎
Otherwise:
• If units is weeks, multiply multiplier by 7 and set units to days.
• If units is days, multiply multiplier by 24 and set units to hours.
• If units is hours, multiply multiplier by 60 and set units to minutes.
• If units is minutes, multiply multiplier by 60 and set units to seconds.
• Forcibly, units is now seconds. Add the product of N and multiplier to seconds.
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
		</ol>
	</li>
	<li>
~IF［
%成分なしか ~EQ ~T
］
⇒
~RET `失敗^i
◎
If component count is zero, fail.
</li>
	<li>
~IF［
%月t数 ~NEQ 0
］
⇒
~RET `失敗^i
◎
If months is not zero, fail.
</li>
	<li>
~RET `時間長$( %秒t数 )
◎
Return the duration consisting of seconds seconds.
</li>
</ol>
</div>

				</section>
				<section id="vaguer-moments-in-time">
<h5 title="Vaguer moments in time">2.3.5.10. ~~曖昧な時刻</h5>

<p class="trans-note">【
この節に与える定義を利用しているものは、［
`ins^e ／ `del^e
］要素の `datetime$a 属性しかない
（特に， `time$e 要素の同名の属性には関わらない）。
】</p>

<p>
次のいずれかの文字列は、
`妥当な省略あり日時~文字列@
とされる：
◎
A string is a valid date string with optional time if it is also one of the following:
</p>

<ul>
	<li>
`妥当な日付~文字列$
◎
A valid date string
</li>
	<li>
`妥当な大域的~日時~文字列$
◎
A valid global date and time string
</li>
</ul>

<hr>

<div class="algo">
<p>
`省略あり日時~文字列を構文解析する@
規則は、
所与の
( 文字列 %入力 )
に対し，［
`日付$ ／ `時刻$ ／ `大域的~日時$ ／ `失敗^i
］を返す：
◎
The rules to parse a date or time string are as follows. The algorithm will return either a date, a time, a global date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%開始~位置 ~SET %位置 と同じ位置
◎
Set start position to the same position as position.
</li>
	<li>
%時刻 ~LET `失敗^i
◎
Set the date present and time present flags to true.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day. If this fails, then set the date present flag to false.
</li>
	<li>
<p>
~IF［
%日付 ~EQ `失敗^i
］~OR［
%位置↗ ~IN { ❝T, `0020^U SPACE }
］：
</p>
		<ol>
			<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
%位置 ~SET %開始~位置
</li>
			<li>
~ELSE
⇒
%位置 ~INCBY 1
</li>
			<li>
%時刻 ~LET `時刻~成分を構文解析する$
</li>
			<li>
~IF［
%時刻 ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
		</ol>
◎
If date present is true, and position is not beyond the end of input, and the character at position is either a U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character, then advance position to the next character in input.
◎
Otherwise, if date present is true, and either position is beyond the end of input or the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then set time present to false.
◎
Otherwise, if date present is false, set position back to the same position as start position.
◎
If the time present flag is true, then parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.
</li>
	<li>
<p>
~IF［
%日付 ~NEQ `失敗^i
］~AND［
%時刻 ~NEQ `失敗^i
］：
</p>
		<ol>
			<li>
%偏差 ~LET `偏差~成分を構文解析する$
</li>
			<li>
~IF［
%偏差 ~EQ `失敗^i
］
⇒
~RET `失敗^i
</li>
		</ol>
◎
If the date present and time present flags are both true, but position is beyond the end of input, then fail.
◎
If the date present and time present flags are both true, parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET `失敗^i
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~IF［
%時刻 ~EQ `失敗^i
］
⇒
~RET %日付
◎
If the date present flag is true and the time present flag is false, then let date be the date with year year, month month, and day day, and return date.
</li>
	<li>
~IF［
%日付 ~EQ `失敗^i
］
⇒
~RET %時刻
◎
Otherwise, if the time present flag is true and the date present flag is false, then let time be the time with hour hour, minute minute, and second second, and return time.
</li>
	<li>
( %日付, %時刻 ) ~LET ( %日付, %時刻 ) から %偏差 を減算した結果
◎
Otherwise, let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes, that moment in time being a moment in the UTC time zone;＼
</li>
	<li>
~RET `日時$( %日付, %時刻, %偏差 )
◎
let timezone be timezonehours hours and timezoneminutes minutes from UTC; and return time and timezone.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="colors">
<h4 title="Legacy Colors">2.3.6. 旧来の色</h4>

<div class="algo">
<p>
一部の廃用にされた旧来の属性は、
`旧来の色~値として構文解析する@
規則を利用して色を構文解析する。
それは、
所与の
( 文字列 %入力 )
に対し，［
~CSS色／ `失敗^i
］を返す：
◎
Some obsolete legacy attributes parse colors using the rules for parsing a legacy color value, given a string input. They will return either a CSS color or failure.
</p>
<ol>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET `失敗^i
◎
If input is the empty string, then return failure.
</li>
	<li>
%入力 ~SET `前後の~ASCII空白~列を剥ぐ$( %入力 )
◎
Strip leading and trailing ASCII whitespace from input.
</li>
	<li>
~IF［
%入力 ~EQ`大小無視$sub `transparent^l
］
⇒
~RET `失敗^i
◎
If input is an ASCII case-insensitive match for "transparent", then return failure.
</li>
	<li>
<p>
~IF［
%入力 ~IN`大小無視$sub { `有名~色$ }
］
⇒
~RET %入力 が与える~keywordに対応する~CSS色
`CSSCOLOR$r
◎
If input is an ASCII case-insensitive match for one of the named colors, then return the CSS color corresponding to that keyword. [CSSCOLOR]
</p>

<p class="note">注記：
【！`CSS2 による~system色＠~TR/css3-color/#css2-system$】
CSS2 にあった`非推奨にされた~system色＠~CSSCOLOR#deprecated-system-colors$は認識されない。
◎
CSS2 System Colors are not recognized.
</p>
	</li>
	<li>
%成分~群 ~LET « »
◎
↓</li>
	<li>
<p>
~IF［
~AND↓
］…
<p>
		<ul>
			<li>
%入力 の`符号位置~長さ$ ~EQ 4
</li>
			<li>
%入力 を成す 0 番 の文字 ~EQ ❝#
</li>
			<li>
%入力 を成す 0 番~以外の文字は，いずれも`~ASCII~hex数字$である
</li>
		</ul>
<p>
…ならば
⇒
« 1, 2, 3 » を成す
~EACH( %i )
に対し
⇒
%成分~群 に次を`付加する$
⇒
2 個の［
%入力 を成す %i 番の文字
］が成す文字列
</p>
◎
If input's code point length is four, and the first character in input is U+0023 (#), and the last three characters of input are all ASCII hex digits, then:
• Let result be a CSS color.
• Interpret the second character of input as a hexadecimal digit; let the red component of result be the resulting number multiplied by 17.
• Interpret the third character of input as a hexadecimal digit; let the green component of result be the resulting number multiplied by 17.
• Interpret the fourth character of input as a hexadecimal digit; let the blue component of result be the resulting number multiplied by 17.
• Return result.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%入力 内の次を満たす`符号位置$（すなわち，基本多言語面に含まれない文字）すべてを `00^l に置換する
⇒
その`値$cp ~GT `FFFF^U の`値$cp
◎
Replace any code points greater than U+FFFF in input (i.e., any characters that are not in the basic multilingual plane) with "00".
</li>
			<li>
~IF［
%入力 の`符号位置~長さ$ ~GT 128
］
⇒
%入力 ~SET `符号位置~部分文字列$( %入力, 0, 128 )
◎
If input's code point length is greater than 128, truncate input, leaving only the first 128 characters.
</li>
			<li>
~IF［
%入力 を成す 0 番 の文字 ~EQ ❝#
］
⇒
%入力 ~SET %入力 の 1 から`終端までを成す符号位置~部分文字列$
◎
If the first character in input is U+0023 (#), then remove it.
</li>
			<li>
%入力 内の次を満たす文字~すべてを ❝0 に置換する
⇒
`~ASCII~hex数字$でない
◎
Replace any character in input that is not an ASCII hex digit with U+0030 (0).
</li>
			<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
%入力 ~SET `000^l
◎
↓</li>
			<li>
~WHILE［
%入力 の`符号位置~長さ$は 3 の倍数でない
］
⇒
%入力 に ❝0 を付加する
◎
While input's code point length is zero or not a multiple of three, append U+0030 (0) to input.
</li>
			<li>
%成分~長さ ~LET %入力 の`符号位置~長さ$ ~DIV 3
◎
↓</li>
			<li>
« 0, 1, 2 » を成す
~EACH( %i )
に対し
⇒
%成分~群 に次の結果を`付加する$
⇒
`符号位置~部分文字列$( %入力, %成分~長さ ~MUL %i, %成分~長さ )
◎
Split input into three strings of equal code point length, to obtain three components. Let length be the code point length that all of those components have (one third the code point length of input).
</li>
			<li>
<p>
~IF［
%成分~長さ ~GT 8
］：
</p>
				<ol>
					<li>
« 0, 1, 2 » を成す
~EACH( %i )
に対し
⇒
%成分~群[ %i ] ~SET %成分~群[ %i ] の ( %成分~長さ ~MINUS 8 ) から`終端までを成す符号位置~部分文字列$
</li>
					<li>
%成分~長さ ~SET 8
</li>
				</ol>
◎
If length is greater than 8, then remove the leading length-8 characters in each component, and let length be 8.
</li>
			<li>
<p>
~WHILE ［
%成分~長さ ~GT 2
］：
</p>
				<ol>
					<li>
%成分~群 を成す
~EACH( %成分 )
に対し
⇒
~IF［
%成分 を成す 0 番 の文字 ~NEQ ❝0
］
⇒
~BREAK
</li>
					<li>
« 0, 1, 2 » を成す
~EACH( %i )
に対し
⇒
%成分~群[ %i ] ~SET %成分~群[ %i ] の 1 から`終端までを成す符号位置~部分文字列$
</li>
					<li>
%成分~長さ ~DECBY 1
</li>
				</ol>
◎
While length is greater than two and the first character in each component is U+0030 (0), remove that character and reduce length by one.
</li>
			<li>
~IF［
%成分~長さ ~GT 2
］
⇒
« 0, 1, 2 » を成す
~EACH( %i )
に対し
⇒
%成分~群[ %i ] ~SET `符号位置~部分文字列$( %成分~群[ %i ], 0, 2 )
◎
If length is still greater than two, truncate each component, leaving only the first two characters in each.
</li>
		</ol>
	</li>
	<li>
%~RGB ~LET « »
◎
Let result be a CSS color.
</li>
	<li>
%成分~群 を成す
~EACH( %成分 )
に対し
⇒
%~RGB に次を`付加する$
⇒
%成分 を~hex数字~列として整数に解釈した結果
◎
Interpret the first component as a hexadecimal number; let the red component of result be the resulting number.
◎
Interpret the second component as a hexadecimal number; let the green component of result be the resulting number.
◎
Interpret the third component as a hexadecimal number; let the blue component of result be the resulting number.
</li>
	<li>
~RET 新たな~CSS色
— その
⇒＃
~red成分 ~SET %~RGB[ 0 ],
~green成分 ~SET %~RGB[ 1 ],
~blue成分 ~SET %~RGB[ 2 ]
◎
Return result.
</li>
</ol>
</div>

			</section>
			<section id="space-separated-tokens">
<h4 title="Space-separated tokens">2.3.7. ~space等で分離された~token列</h4>

<p>
`~space等で分離された~token集合@
とは、［
1 個以上の`~ASCII空白$が成す並び
］で分離された，
~tokenたちが成す文字列である（空にもなり得る）
— ここでの~tokenとは、
次を満たす文字列とする
⇒
［
空でない
］~AND［
どの文字も`~ASCII空白$でない
］
◎
A set of space-separated tokens is a string containing zero or more words (known as tokens) separated by one or more ASCII whitespace, where words consist of any string of one or more characters, none of which are ASCII whitespace.
</p>

<p>
`~space等で分離された~token集合$は、
`~ASCII空白$たちが成す並びが，その［
頭部／尾部
］を成していてもヨイ。
◎
A string containing a set of space-separated tokens may have leading or trailing ASCII whitespace.
</p>

<div>
<p>
`~space等で分離された~token集合$には、
次が付記されることもある：
</p>
<ul>
	<li>
“一意”
が付記されている場合、
どの 2 つの~tokenも`一致-$しないことが要求される。
</li>
	<li>
“大小無視で一意”
が付記されている場合、
どの 2 つの~tokenも`~ASCII大小無視$で合致しないことが要求される。
</li>
	<li>
“有順序”
が付記されている場合、
順序も有意義とされる
（付記されていない場合、
そうでない）。
</li>
</ul>

<p>
（ “大小無視で一意” と “一意” は，排他的である一方、
“有順序” は，他と伴に付記され得る。）
</p>

<p class="trans-note">【
“一意” は作者~向けの要件を与える一方で、
“有順序” は，実質的に~UA向けの要件（順序を保つこと）を与える。
】【
原文では，［
一意か否か（および，それは大小無視か否か）,
<span id="ordered-set-of-unique-space-separated-tokens">有順序</span>か<span id="unordered-set-of-unique-space-separated-tokens">否か</span>
］の区別を いくつかの用語に分けて定義しているが、
この訳では一つの用語に統合して，
これらの有無で区別することにする。
】</p>

◎
An unordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated.
◎
An ordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated but where the order of the tokens is meaningful.
</div>

<p>
文脈によっては、
許容される~tokenたちが成す集合が定義されることもある。
そのような場合、
どの~tokenも，この集合に入っていなければナラナイ
【大小無視ならば、それも織り込む下で】
— さもなければ、
値は不適合とされる。
そのような集合が特に供されていない場合、
どの~tokenも適合することになる。
◎
Sets of space-separated tokens sometimes have a defined set of allowed values. When a set of allowed values is defined, the tokens must all be from that list of allowed values; other values are non-conforming. If no such set of allowed values is provided, then all values are conforming.
◎
↑↑How tokens in a set of space-separated tokens are to be compared (e.g. case-sensitively or not) is defined on a per-set basis.
</p>

			</section>
			<section id="comma-separated-tokens">
<h4 title="Comma-separated tokens">2.3.8. ~commaで分離された~token列</h4>

<p>
`~commaで分離された~token集合@
とは、
❝, で分離された，
次を満たす文字列（ “前後に空白を伴い得る~token” ）たちが成す文字列である（空にもなり得る）
⇒
次の結果（ “~token” ）を成すどの文字も ❝, でない
⇒
`前後の~ASCII空白~列を剥ぐ$( 当の文字列 )
◎
A set of comma-separated tokens is a string containing zero or more tokens each separated from the next by a single U+002C COMMA character (,), where tokens consist of any string of zero or more characters, neither beginning nor ending with ASCII whitespace, nor containing any U+002C COMMA characters (,), and optionally surrounded by ASCII whitespace.
</p>

<p class="trans-note">【
ここでは、
“前後の~ASCII空白~列を剥ぐ” を利用して，原文による定義を等価に簡約している。
】</p>

<p class="example">
一例として、
文字列 ` a ,b,,d d ^l は，
4 個の~token［
`a^l, `b^l, 空~文字列, `d d^l
］からなる。
各~tokenの前後にある空白たちは、
~tokenの一部を成さない。
空~文字列も~tokenとされる。
◎
For instance, the string " a ,b,,d d " consists of four tokens: "a", "b", the empty string, and "d d". Leading and trailing whitespace around each token doesn't count as part of the token, and the empty string can be a token.
</p>

<p class="trans-note">【
`~commaで分離された~token集合$が空~文字列であった場合、［
1 個の空~文字列~tokenのみからなる集合, 空~集合
］どちらに解釈されるかは，
この用語を利用している各所における構文解析-法に従うことになる
（多くの場合、
`~commaで分割される＠~INFRA#split-on-commas$
— したがって空~集合に解釈される）。
】</p>

<p>
`~commaで分離された~token集合$には、
何が妥当な~tokenを成すかについて，更なる制約が~~課されることもあり、
その場合の各~tokenはその制約を満たさなければナラナイ。
さもなければ、
値は不適合とされる。
【！制約が指定されていなければ，すべての値が適合。】
◎
Sets of comma-separated tokens sometimes have further restrictions on what consists a valid token. When such restrictions are defined, the tokens must all fit within those restrictions; other values are non-conforming. If no such restrictions are specified, then all values are conforming.
</p>

			</section>
			<section id="syntax-references">
<h4 title="References">2.3.9. 参照</h4>

<p class="trans-note">【
この節に与える定義を利用しているものは、［
`img^e ／ `object^e
］要素の `usemap$a 属性しかない。
】</p>

<div class="p">
<p>
次の並びからなる文字列は、
`要素~型$ %型 の要素への
`妥当な~hash名~参照@
とされる：
</p>

<ol>
	<li>
❝#
</li>
	<li>
次を満たす ある要素 %要素 の `name^a 属性の値
⇒
［
%要素 は【所与の文字列を与えている属性を有する要素と】同じ`~tree$内にある
］~AND［
%要素 の`要素~型$ ~EQ %型
］~AND［
%要素 は `name^a 属性を有する
］
</li>
</ol>

◎
A valid hash-name reference to an element of type type is a string consisting of a U+0023 NUMBER SIGN character (#) followed by a string which exactly matches the value of the name attribute of an element with type type in the same tree.
</div>

<div class="algo">
<p>
`要素~型$ %型 を指す
`~hash名~参照として構文解析する@
規則は、
所与の
( 文字列 %入力, 文脈~node %視野 )
に対し，次に従う：
◎
The rules for parsing a hash-name reference to an element of type type, given a context node scope, are as follows:
</p>

<ol>
	<li>
~IF［
%入力 内に ❝# はない
］
⇒
~RET ~NULL
◎
If the string being parsed does not contain a U+0023 NUMBER SIGN character, or＼
</li>
	<li>
%~hash ~LET %入力 内の最初の ❝# より後の文字すべてからなる文字列
◎
＼
</li>
	<li>
~IF［
%~hash ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
if the first such character in the string is the last character in the string, then return null.
◎
Let s be the string from the character immediately after the first U+0023 NUMBER SIGN character in the string being parsed up to the end of that string.
</li>
	<li>
<p>
~RET ［
%視野 を根とする~tree
］内に次を満たす要素は［
在るならば それらのうち`~tree順序$で最初のもの ／
無いならば ~NULL
］
⇒
［
要素の`要素~型$ ~EQ %型
］~AND［
%~hash ~IN { 要素の `id$a 属性~値, 要素の `name^a 属性~値 }
］
◎
Return the first element of type type in scope's tree, in tree order, that has an id or name attribute whose value is s, or null if there is no such element.
</p>

<p class="note">注記：
`id$a 属性は、
構文解析-時には織り込まれるが，その値が`妥当な~hash名~参照$かどうか決定するときには利用されない。
すなわち， `id$a 属性に基づいて要素を指すような~hash名~参照は、
（その要素が同じ値をとる `name^a 属性も有していない限り）
適合性~errorとされる。
◎
Although id attributes are accounted for when parsing, they are not used in determining whether a value is a valid hash-name reference. That is, a hash-name reference that refers to an element based on id is a conformance error (unless that element also has a name attribute with the same value).
</p>
	</li>
</ol>
</div>

			</section>
			<section id="mq">
<h4 title="Media queries">2.3.10. 媒体~query</h4>

<p>
次を満たす文字列は、
`妥当な媒体~query~list@
とされる
⇒
`Media Queries^cite `MQ$r
の `media-query-list$t 生成規則に合致する
◎
A string is a valid media query list if it matches the &lt;media-query-list&gt; production of Media Queries. [MQ]
</p>

<p>
~OR↓ を満たす文字列は、
`利用者の環境に合致して@
いるとされる：
◎
A string matches the environment of the user＼
</p>
<ul>
	<li>
0 個以上の`~ASCII空白$のみからなる
◎
if it is the empty string, a string consisting of only ASCII whitespace, or＼
</li>
	<li>
`Media Queries^cite `MQ$r
による定義に則って，利用者の環境に合致している媒体~query~list
◎
is a media query list that matches the user's environment according to the definitions given in Media Queries. [MQ]
</li>
</ul>

			</section>
			<section id="unique-values">
<h4 title="Unique internal values">2.3.11 一意かつ内部的な値</h4>

<p>
`一意かつ内部的な値@
は、
直列化-可能かつ値どうしを比較-可能な，
~scriptには決して公開されない値である。
◎
A unique internal value is a value that is serializable, comparable by value, and never exposed to script.
</p>

<p class="algo">
`新たな一意かつ内部的な値@
を作成するときは、
それまで この~algoが決して返さなかった，`一意かつ内部的な値$を返す。
◎
To create a new unique internal value, return a unique internal value that has never previously been returned by this algorithm.
</p>

			</section>
		</section>
</main>

