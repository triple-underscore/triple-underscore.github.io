<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Common microsyntaxes（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style>
.js {
	color: green;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'common-microsyntaxes',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170608 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		st: 'attr-state',
		jA: 'abstract',
		t: 'type',
		U: 'code-point',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		st: 'span',
		v: 'code',
		p: 'code',
		jA: 'span',
		V: 'var',
		t: 'var',
		mark: 'mark',
		i: 'i',
		U: 'span',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/❝.|%[\w\-~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	switch(match[0]) {
	case '❝':
		return ( '<span class="code-point">U+00'
			+ match[1].charCodeAt(0).toString(16).toUpperCase()
			+ '</span> (<span class="char-symbol">' + match[1] + '</span>)'
		);
	default://%
		return '<var>' + match.slice(1) + '</var>';
	}
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2018-03-05
trans_update:2018-03-06
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/common-microsyntaxes.html
nav_prev:HTMLINFRA
nav_next:HTMLurl
trans_1st_pub:2016-01-28


●●original_id_map


●●link_map



e.input:~HEinput#the-input-element
e.time:~HEtextlevel#the-time-element
e.progress:~HEforms#the-progress-element

a.id:~HTMLdom#the-id-attribute
a.checked:~HEinput#attr-input-checked
a.disabled:~HTMLforms#attr-fe-disabled
a.max:~HEforms#attr-progress-max

a.usemap:~HEimages#attr-hyperlink-usemap
a.datetime:~HEedits#attr-mod-datetime

st.Number:~HEinput#number-state-(type=number)
st.Color:~HEinput#color-state-(type=color)

	●
White_Space 文字:#white_space

列挙ed属性:#enumerated-attribute
真偽~属性:#boolean-attribute
妥当でない値~用の既定:#invalid-value-default
値なし用の既定:#missing-value-default
要素~型:~HTMLINFRA#element-type

	●構文
Base10:#_base-ten-integer
Frac10:#_base-ten-fractional

位置~変数:~INFRA#string-position-variable
~ASCII空白:~INFRA#ascii-whitespace
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII~hex数字（小文字）:~INFRA#ascii-lower-hex-digit-lower
~ASCII空白を読飛ばす:~INFRA#skip-ascii-whitespace
~commaで分割する:~INFRA#split-on-commas
前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ACI:~INFRA#ascii-case-insensitive
	文字~数:~INFRA#javascript-string-length

妥当な整数:#valid-integer
妥当な非負~整数:#valid-non-negative-integer

妥当な浮動小数点数:#valid-floating-point-number
妥当な浮動小数点数~list:#valid-list-of-floating-point-numbers
浮動小数点数として最良の表現:#best-representation-of-the-number-as-a-floating-point-number

整数として構文解析する:#rules-for-parsing-integers
非負~整数として構文解析する:#rules-for-parsing-non-negative-integers
浮動小数点数として構文解析する:#rules-for-parsing-floating-point-number-values
浮動小数点数~listとして構文解析する:#rules-for-parsing-a-list-of-floating-point-numbers

~comma区切りの~token集合:#set-of-comma-separated-tokens
空白区切りの~token集合:#set-of-space-separated-tokens
空白区切りの一意な~tokenからなる無順序~集合:#unordered-set-of-unique-space-separated-tokens
空白区切りの一意な~tokenからなる有順序~集合:#ordered-set-of-unique-space-separated-tokens

	●date＆time
日時:#concept-datetime
大域的~日時:#concept-datetime
局所的~日時:#concept-datetime-local
偏差:#concept-timezone
時間帯:#time-zones
日付:#concept-date
時刻:#concept-time
年月t:#concept-month
月日t:#concept-yearless-date
年週t:#concept-week
月tの日t数:#number-of-days-in-month-month-of-year-year
週t数:#week-number-of-the-last-day
最後の日tの週t番号:#week-number-of-the-last-day
時間長:#concept-duration
時間長~成分:#duration-time-component
時間長~成分の縮尺:#duration-time-component-scale
遡及~Gregorian日付:#proleptic-gregorian-date
遡及~Gregorian暦:#proleptic-gregorian-calendar

妥当な偏差~文字列:#valid-time-zone-offset-string
妥当な大域的~日時~文字列:#valid-global-date-and-time-string
妥当な局所的~日時~文字列:#valid-local-date-and-time-string
妥当な月日t文字列:#valid-yearless-date-string
妥当な日付~文字列:#valid-date-string
妥当な省略あり日時~文字列:#valid-date-string-with-optional-time
妥当な時刻~文字列:#valid-time-string
妥当な時間長~文字列:#valid-duration-string
妥当な年月t文字列:#valid-month-string
妥当な正規化済みの局所的~日時~文字列:#valid-normalised-local-date-and-time-string
妥当な年週t文字列:#valid-week-string

大域的~日時~文字列を構文解析する:#parse-a-global-date-and-time-string
局所的~日時~文字列を構文解析する:#parse-a-local-date-and-time-string
偏差~文字列を構文解析する:#parse-a-time-zone-offset-string
偏差~成分を構文解析する:#parse-a-time-zone-offset-component
月日t文字列を構文解析する:#parse-a-yearless-date-string
月日t成分を構文解析する:#parse-a-yearless-date-component
省略あり日時~文字列を構文解析する:#parse-a-date-or-time-string
日付~文字列を構文解析する:#parse-a-date-string
日付~成分を構文解析する:#parse-a-date-component
時刻~文字列を構文解析する:#parse-a-time-string
時刻~成分を構文解析する:#parse-a-time-component
時間長~文字列を構文解析する:#parse-a-duration-string
年月t文字列を構文解析する:#parse-a-month-string
年月t成分を構文解析する:#parse-a-month-component
年週t文字列を構文解析する:#parse-a-week-string

	●CSS
寸法~listとして構文解析する:#rules-for-parsing-a-list-of-dimensions
寸法~値として構文解析する:#rules-for-parsing-dimension-values
非~zero寸法~値として構文解析する:#rules-for-parsing-non-zero-dimension-values

単純~色:#simple-colour
妥当な単純~色:#valid-simple-colour
妥当な小文字~単純~色:#valid-lowercase-simple-colour
単純~色として構文解析する:#rules-for-parsing-simple-colour-values
単純~色を直列化する:#rules-for-serialising-simple-colour-values
旧来の色~値として構文解析する:#rules-for-parsing-a-legacy-colour-value

~hash名~参照として構文解析する:#rules-for-parsing-a-hash-name-reference
妥当な~hash名~参照:#valid-hash-name-reference

利用者の環境に合致して:#matches-the-environment
妥当な媒体~query~list:#valid-media-query-list
t.&lt;media-query-list&gt;:~MQ4#typedef-media-query-list

	●
木:~DOM4#concept-tree
木~順序:~DOM4#concept-tree-order

jA.ToString:~TC39#sec-tostring

有名~色:~CSSCOLOR#named-color


●●words_table1


ACI:<sub>大小無視</sub>
hrefM:href
nameM:name
nameO:name
nameF:name
namedItem0:namedItem
length0:length
this:<b class="js">this</b>


●●words_table



	●仕様（動詞

作者:author:~
依存-:depend:~
保持-:hold:~
保証:guarantee:~
利用者:user:~
制約-:restrict:~
制約:restriction:~
協調-:coordinate:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
受容-:accept:~
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
実装者:implementer:~
導入-:introduce:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
指定-:specify:~
検分-:examine:~
無視-:ignore:~
督促-:urge:~
考慮-:consider:~
要求-:require:~
見なす:consider する:~
解釈-:interpret:~
記述-:describe:~
許容-:allow:~
論じる:discuss する:~
論点:discussion:~
述べる:describe する:~
適合-:conform:~
適合:conforming:~
適合性:conformance:~
	読み易い:readable
記述-:describe:~
記述:description:~
受渡し:round-tripping:受け渡し
認識-:recognize:~
結付けら:associate さ:結び付けら
誤解釈:misinterpreting:~
挙動:behavior:ふるまい
	注記
	~~可能性が高い:likely:~
	混み入った:complicated:~
	織り込
	織り込:takes into account
	当時の:contemporary

	●仕様
UA:user agent:UA
version::::バージョン
仕様:spec:~
事例:case:~
互換性:compatibility:~
傾向:tend:~
公式的な:formal:~
共通の:common:~
判定基準:criteria:~
同義語:synonym:~
実施:practice:~
実際:actual:~
実際の:actual:~
将来:future:~
廃用に:obsolete:~
強く:strong に:~
恣意的:arbitrary:~
情報:information:~
文化的:cultural:~
政治的決断:policy decisions:~
政治的駆引き:political footballs:政治的駆け引き
方式:manner:~
既定:default:~:::デフォルト
既定の:default:~:::デフォルト
旧来の:legacy:~
明示的:explicit:~
最善:best:~
最良の:best な:~
概して:typical に:~
正確:exact:~
歴史的:historical:~
永劫:forever:~
決断:decision:~
注意深く:careful に:~
注目:notable:~
特別:special:~
特定0の:particular:ある特定の
特定の:specific な:~
現代の:modern:~
理由:reason:~
用法:usage:~
用語:term:~
目的:purpose:~
第三者主体:third-party:~
精確:precise:~
要件:requirements:~
詳細:details:~
詳細に:detail:~
適切:appropriate:~
手続き:steps:~
供-:provide:~
	例:example:~
	具体的には:for instance
	依然として:still:~
	可能:possible
	異なる:different:~
	場合によっては:possibly
	しかしながら，:however
	したがって:therefore
	したがって:thus
	する限りにおいて:insofar
	きちんと:well
	気まぐれな:very whimsical
	出来事:event
	~~実用されている:real
	多い:often
	大きく変わる:greatly vary
	必要-:need
	必要とされ:necessary
	成句的な:idiom
	〜に基づく:based
	その逆も同様:vice versa
	類似する:similar
	更なる:further

	●
node::::ノード
要素:element:~
木:tree::~::ツリー
根:root::~::ルート
視野:scope::~
文書:document:~
属性:attribute:~
列挙ed:enumerated:列挙

HTML:

	●構文
ASCII:
SPACE:
zero::::ゼロ
error::::エラー
comma::::カンマ
hash::::ハッシュ
	hash-name
hex::16 進
	16 進:hexadecimal
keyword::::キーワード
token::::トークン
値:value:~
値なし:missing value:~

構文:syntax::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアル化
正規化済みの:normalized:~
位置:position:~
読飛ばす:skip する:読み飛ばす
分割-:split:~
剥ぐ:strip する:~
区切りの:-separated:~
区切られ:separate され:~
	区切り:separator:~
区切子:delimiter:~
空白区切りの:space-separated:~
収集-:collect:~

合致-:match:~
妥当:valid:~
	妥当でない:invalid:~

符号位置:code point:~
基本多言語面:basic multilingual plane::~
文字:character:~
小文字:lowercase:~
文字列:string:~
	大小無視:case-insensitive:~
文字大小区別:case-sensitive:~
空:empty:~
空白:whitespace:~

符号:sign:~
有符号:signed:~
	基数:base:~
数字:digit:~
	数:number:~
整数:integer:~
実数:number:~
倍精度:double-precision:~
浮動小数点数:floating-point number:~
仮数:significand:~
小数:fraction:~
	小数~部:fractional part
指数:exponent:~

小構文:microsyntax::~
形式:format:~
正準的な:canonical:~
生成規則:production:~

一義化-:disambiguate:~
一義化子:-disambiguator:~
成分:component:~
	-:subcomponent
尾部:trailing:~
頭部:leading:~
頭部の:leading:~
単位:unit:~

有順序:ordered:~
無順序:unordered::~
順序:order:~
	順々に:sequentially
	順に
	Advance position to the next character
	hash-name
	micro-parser:
	space::::
	ε:fail
	並び:sequence:~
	無用な文字~並び:garbage
	偶数:even

	●暦
Gregorian::::グレゴリオ
Julian::::ユリウス
London::::ロンドン
ISO8601:ISO 8601
Roman-Emperor:Roman Emperor::ローマ皇帝
Nero::::ネロ
UT1::::
UTC::::
	February
	October
	SI
	USA
遡及:proleptic::~
	proleptic-Gregorian:~
閏:leap::~

年t:year::年
月t:month::月
年月t:year＆month::年＆月
月日t:month＆date::月＆日
日t:day::日
週t:week::週
年週t:year＆week::年＆週
時t:hour::時
分t:minute::分
秒t:second::秒
週年t:week-year::週年
年なし:yearless::~
日付:date::~
日時:date＆time::~

時刻:time::~
	時刻:moments in time
時間帯:time zone::~
	時間帯:offset:~
偏差:time-zone offset::~

milli::::ミリ
	~milli秒t:millisecond
夏時間:daylight saving time::~
太陽時:Earth solar time::~
時間長:duration::~
	時間長~成分:duration time component:
暦:calendar::~
暦付け:calendaring::~
最大日数:maxday::~
	-:maxweek

番号:number:~

水曜:Wednesday::~
火曜:Thursday::~
月曜:Monday::~
七日間:seven-day period:~

地域:area:~
地域化-:localize::~
大域的:global::~::グローバル
局所的:local::~::ローカル
生誕:birth:~
誕生日:birthday:~
真昼:noon:~
期間:period:~
東海岸:east-coast:~
真夜中:midnight:~
経度:longitude:~
縮尺:scale:~
外部補間-:extrapolate:~
前近代:ancient times:~
比較的近代:relatively recent decades:~
世紀:century:~
中頃:mid:~
制定:formation:~
	1 月:January
	12 月:December
	timezone
	timezonehour
	timezoneminute
	漠然とした:vaguer moments

	●CSS
red:
green:
blue:
媒体:media::~:メディア
query::::クエリ
寸法:dimension:~
色:color:~
百分率:percentage::~
不透明度:opacity:~
空間:space:~

相対:relative::~
絶対:absolute::~

	●未分類（動詞
	所与の:given:与えられた
	与-:give:~
決定-:determine:~
不能化-:disable:~
付加-:append:~
入力:input:~
刻む:tick する:~
包含-:contain:~
名:name:~
名前:name:~
在する:present する:在る
	-:increment
変換-:convert:~
変数:variable:~
	~~存在:presence:存在
	不在:absence:~
	不在:absent:~
有名:named:~
比較-:compare:~
比較可能:comparable:~
消毒:sanitization::~
減算-:subtract:~
測定-:measure:~
相違-:differ:~
相違:difference:~
省略-:omit:~
省略可:optional:~
置換-:replace:~
表現-:represent:~
表現:representation:~
表示-:display:~
観測-:observe:~
識別-:identify:~
走らせ:run し:~
近似-:approximate:~
近似:approximation:~
重複-:duplicate:~
開始-:start:~
除去-:remove:~
追加-:add:~
関係-:relate:~
避ける:avoid する:~
混在させ:mixし:~
	利用-:use:~
	返-:return:~
	利用-:use:~
	対応-:correspond:~
	現れる
	に則って:according
	に基づく:based
	加えて
	加える
	含-:include
	従う:follow
	得-:obtain
	有-
	残され
	残りの
	示す:show
	表す
	記され
	課され
	選ぶ
	呼ばれ
	指して
	指す:refer／point
	書いて
	書き
	満た
	対応付けら
	除-:except
	見よ:see
	在-:present
	得-:obtain
	含-:include
	表す:express
	遡って:backward
	用い
	表記
	表記規約

	●未分類
list::::リスト
pointer::::ポインタ
algo:algorithm:::アルゴリズム
check::::チェック
checkbox::::チェックボックス
data::::データ
graphics::::グラフィックス
library::::ライブラリ
pattern::::パタン
form::::フォーム
control::::コントロール
library::::ライブラリ
system::::システム
zero::::ゼロ
	literal
一意:unique:~
型:type:~
真偽:boolean:~
内容:content:~
単純:simple:~
参照:reference:~
抽象演算:abstract operation:~
文脈:context:~
有限:finite:~
状態:state:~
環境:environment:~
種別:type:~
等価:equivalent:~
範囲:range:~
規則:rule:~
詳細:details:~
長さ:length:~
集合:set:~

一義的:unambiguous:~
下位集合:subset:~
人:human:~
代替:alternative:~
伝送路:wire:~
当地域:place:~
成功裡:successful:~
所在:location:~
偏向:bias:~


	任意の:arbitrary
	-:arbitrary
	数
	伴う
	入って
	単に
	場合
	何
	内
	列
	対し
	後の
	応じて
	成す
	所で
	方
	方法
	常に:always
	有無
	生
	等し:equal
	等しく:equally
	最も小さい:smallest
	最短の:shortest
	負:negative
	非負:non-negative
	〜の倍数:divisible
	超える
	近い

	-:arbitrary
	進んでいる:ahead of
	INCBY:advance position
	:care
	:count
	:followed by
	:forcibly
	:moment
	~zero詰めされ:zero-padded
	:part
	:past
	:refer
	対象:subject
	:sum
	:four
	〜の代わりに:instead
	あり続ける:remain
	ずっと:much more
	掛けた:scaleした


	いくつかの:several
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	それらを:them
	まるごと:entirely
	もの:thing
	一方
	一部
	下
	下:below
	両方
	中の
	乗
	互いに
	今や:now
	他
	他の:other
	他の場合:otherwise
	以上
	以下
	以前の:previous／predate
	以外
	個:two／three
	個目／ つ:two／second／third／fifth
	先頭
	別
	前:before
	前後
	前述
	各:each
	同じ:same
	常に:always
	後:after
	最初の:first
	最後の:last
	次
	片方
	現在:currently
	異なる:different
	様々な:various
	等々:etc
	節:section
	結果:result
	結果の:resulting
	自体も
	複数の
	該当-
	間:between
	限ら
	限り
	非


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
Common infrastructure 章の
<a href="~SPEC_URL">Common microsyntaxes</a>
節を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>


<header id="head">
	<hgroup>
<h1>共通の小構文 — Common microsyntaxes</h1>

	</hgroup>

</header>

<main id="MAIN" style="display:none;">

		<section id="common-microsyntaxes">
<h2 title="Common microsyntaxes">2.3. 共通の小構文</h2>

<p>
~HTMLでは，様々な所で，日付や実数などを表現する特定0の~data型を受容する。
この節では、それらの形式による内容に対する適合性の判定基準, および
それらを構文解析する方法について述べる。
◎
There are various places in HTML that accept particular data types, such as dates or numbers. This section describes what the conformance criteria for content in those formats is, and how to parse them.
</p>

<p class="note">注記：
実装者には、以下に述べる構文の構文解析を実装するにあたり，第三者主体による~libraryの利用を考慮するときは、注意深く検分することが強く督促される。
例えば、日付~libraryにおける~errorの取扱いは、この仕様にて要求されるものから相違する挙動を実装している~~可能性が高い。
~error取扱いの挙動は、この仕様にて利用される構文に類似する日付~構文を述べる仕様では，定義されていないことが多いため、実装によって大きく異なる傾向にある。
◎
Implementers are strongly urged to carefully examine any third-party libraries they might consider using to implement the parsing of syntaxes described below. For example, date libraries are likely to implement error handling behavior that differs from what is required in this specification, since error-handling behavior is often not defined in specifications that describe date syntaxes similar to those used in this specification, and thus implementations tend to vary greatly in how they handle errors.
</p>

			<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ε, ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>


			</section>
			<section id="common-parser-idioms">
<h3 title="Common parser idioms">2.3.1. 共通の成句的な構文解析器</h3>

<p>
`White_Space 文字@
とは…
【以下，この段落の内容は、この用語を利用している<a href="~HEtables#empty-cell">唯一の箇所</a>に述べる。】
◎
The White_Space characters are those that have the Unicode property "White_Space" in the Unicode PropList.txt data file. [UNICODE]
◎
This is not to be confused with the "White_Space" value (abbreviated "WS") of the "Bidi_Class" property in the Unicode.txt data file.
</p>

<p>
以下に述べる一部の構文解析器は、構文解析される文字列を保持する変数 %入力,
および 次に構文解析される文字を指す変数 %位置 を用いる~patternに従う。
【詳細は、以下に現れる %位置↗ という表記も含め，`位置~変数$を参照されたし。】
◎
Some of the micro-parsers described below follow the pattern of having an input variable that holds the string being parsed, and having a position variable pointing at the next character to parse in input.
</p>

			</section>
			<section id="boolean-attributes">
<h3 title="Boolean attributes">2.3.2. 真偽~属性</h3>

<p>
一部の内容~属性は、
`真偽~属性@
とされている。
要素~上の真偽~属性の~~存在は ~T 値を表現し、不在は ~F 値を表現する：
◎
A number of attributes are boolean attributes. The presence of a boolean attribute on an element represents the true value, and the absence of the attribute represents the false value.
</p>

<p>
真偽~属性は、在するならば，［
その値 ~IN`~ACI$ { 空~文字列, 属性の正準的な名前 }
］で~MUST（ 属性~値の 頭部／尾部 に空白は許容されない）。
◎
If the attribute is present, its value must either be the empty string or a value that is an ASCII case-insensitive match for the attribute's canonical name, with no leading or trailing whitespace.
</p>

<p class="note">注記：
真偽~属性に対する、値［
`true^l ／ `false^l
］は許容されない。
~F 値を表現するためには、属性~自体も省略される必要がある。
◎
The values "true" and "false" are not allowed on boolean attributes. To represent a false value, the attribute has to be omitted altogether.
</p>

<div class="example">

<p>
~checkされ, かつ不能化されている（ checked ＆ disabled ）~checkboxの例をここに示す。
`checked$a, `disabled$a
属性はいずれも真偽~属性である。
◎
Here is an example of a checkbox that is checked and disabled. The checked and disabled attributes are the boolean attributes.
</p>

<pre class="html-code">
&lt;label&gt;&lt;input
    type=checkbox
    `checked^mark
    name=cheese
    `disabled^mark
&gt; Cheese&lt;/label&gt;
</pre>

<p>
これは、次のように書いても等価になる：
◎
This could be equivalently written as this:
</p>

<pre class="html-code">
&lt;label&gt;&lt;input
    type=checkbox
    `checked=checked^mark
    name=cheese
    `disabled=disabled^mark
&gt; Cheese&lt;/label&gt;
</pre>

<p>
次のように書き方を混在させても依然として等価になる：
◎
You can also mix styles; the following is still equivalent:
</p>

<pre class="html-code">
&lt;label&gt;&lt;input
    type='checkbox'
    `checked^mark
    name=cheese
    `disabled=""^mark
&gt; Cheese&lt;/label&gt;
</pre>

</div>

			</section>
			<section id="keywords-and-enumerated-attributes">
<h3 title="Keywords and enumerated attributes">2.3.3. ~keyword, 列挙ed属性</h3>

<div class="p">
<p>
一部の内容~属性は、［
とり得る値は，有限~個の~keywordからなる集合に属する
］ものと定義されている。
そのような属性は、
`列挙ed属性@
と呼ばれる。
各~keywordは、特定0の <em>状態</em> に対応付けられるものと定義される（複数の~keywordが同じ状態に対応付けられることもある
— それらの~keywordは，互いに同義語になる。
加えて，~keywordのうち一部には、歴史的~理由に限り，仕様に残されているものもある
— その種のものは非~適合とされる）。
加えて、次の 2 つの既定~状態が定義されることもある：
</p>

<ul ><li>`妥当でない値~用の既定@
</li><li>`値なし用の既定@
</li></ul>


◎
Some attributes are defined as taking one of a finite set of keywords. Such attributes are called enumerated attributes. The keywords are each defined to map to a particular state (several keywords might map to the same state, in which case some of the keywords are synonyms of each other; additionally, some of the keywords can be said to be non-conforming, and are only in the specification for historical reasons). In addition, two default states can be given. The first is the invalid value default, the second is the missing value default.
</div>

<p>
`列挙ed属性$に指定する値は、［
値 ~IN`~ACI$ { 所与の~keyword集合のうち，非~適合とされていないもの }
］を満たさ~MUST（値の［
頭部／尾部
］に空白は許容されない）。
◎
If an enumerated attribute is specified, the attribute's value must be an ASCII case-insensitive match for one of the given keywords that are not said to be non-conforming, with no leading or trailing whitespace.
</p>

<div class="p">
<p class="algo-head">
( `列挙ed属性$ %A, ~keyword集合 %S )
が与えられた下で，要素において %A が表現する状態は、次に従って決定される：
</p>

<ol>
	<li>
<p>
~IF［
要素は %A を有する
］：
</p>
		<ol>
			<li>
~IF［
%A の値 ~IN`~ACI$ %S
］
⇒
~RET その値に対応する状態
</li>
			<li>
~IF［
%A には `妥当でない値~用の既定$が定義されている
］
⇒
~RET その状態
</li>
		</ol>
	</li>
	<li>
~ELIF［
%A には `値なし用の既定$が定義されている
］
⇒
~RET その状態
</li>
	<li>
~RET ε （表現される状態はない）
</li>
</ol>

◎
When the attribute is specified, if its value is an ASCII case-insensitive match for one of the given keywords then that keyword's state is the state that the attribute represents. If the attribute value matches none of the given keywords, but the attribute has an invalid value default, then the attribute represents that state. Otherwise, there is no default, and invalid values mean that there is no state represented.
◎
When the attribute is not specified, if there is a missing value default state defined, then that is the state represented by the (missing) attribute. Otherwise, the absence of the attribute means that there is no state represented.
</div>

<p class="note">注記：
空~文字列も妥当な~keywordになり得る。
◎
The empty string can be a valid keyword.
</p>


			</section>
			<section id="numbers">
<h3 title="Numbers">2.3.4. 実数</h3>

<p>
所与の`~ASCII数字$列 %s （空~文字列でもよい）に対し：
</p>

<ul>
	<li>
<p>
`Base10@ ( %s ) は、次を走らせた結果を返す：
</p>
		<ol>
			<li>
%結果 ~LET 0
</li>
			<li>
%s 内の ~EACH( 文字 %d ) に対し，先頭から順に
⇒
%結果 ~SET ( %結果 × 10 ) + ( %d を 10 進数として解釈した結果（すなわち， %d の符号位置から ❝0 を減算した結果） )
</li>
			<li>
~RET %結果
</li>
		</ol>
	</li>
	<li>
`Frac10@ ( %s ) は、［
`Base10$( %s )  ÷ ( 10 の ( %s の文字~数 ) 乗 )
］を返す。
</li>
</ul>

<p class="trans-note">【
これらは、以下を簡潔に記述するために，この訳にて定義したものである。
原文には， `Base10$ にあたる~algoは定義されていない（単に， “10 進数として解釈-” と記されている）が、それに依存する `Frac10$ を利用している箇所には~algoが与えられているので，等価になるものをここに定義している。
】</p>

				<section id="signed-integers">
<h4 title="Signed integers">2.3.4.1. 有符号~整数</h4>


<div class="p">
<p>
次の並びからなる文字列は
`妥当な整数@
とされる：
</p>

<ol>
	<li>
0 〜 1 個の文字 ❝-
</li>
	<li>
1 個以上の`~ASCII数字$
</li>
</ol>

◎
A string is a valid integer if it consists of one or more ASCII digits, optionally prefixed with a U+002D HYPHEN-MINUS character (-).
</div>

<p>
`妥当な整数$は
⇒
❝- を［
伴わないならば 1 ／
伴うならば −1
］ × `Base10$( その中の数字~列 ) を表現する。
◎
A valid integer without a U+002D HYPHEN-MINUS (-) prefix represents the number that is represented in base ten by that string of digits. A valid integer with a U+002D HYPHEN-MINUS (-) prefix represents the number represented in base ten by the string of digits that follows the U+002D HYPHEN-MINUS, subtracted from zero.
</p>

<p class="algo-head">
`整数として構文解析する@
規則は、所与の
 ( 文字列 %入力 )
に対し，［
整数, ~error
］のいずれかを返す：
<!-- すべて略
When invoked, the steps must be followed in the order given, aborting at the first step that returns a value
 -->
◎
The rules for parsing integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either an integer or an error.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%符号 ~LET 1
◎
Let sign have the value "positive".
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
<p>
%位置↗ に応じて：
◎
If position is past the end of input, return an error.
</p>
		<dl class="switch">
			<dt>❝-
◎
If the character indicated by position (the first character) is a U+002D HYPHEN-MINUS character (-):</dt>
			<dd>
				<ol>
					<li>
%符号 ~LET −1
◎
Let sign be "negative".
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
◎
If position is past the end of input, return an error.
</li>
				</ol>
			</dd>

			<dt>❝+
◎
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):
</dt>
			<dd>
				<ol>
					<li>
%位置 ~INCBY 1
（ `+^l は無視されるが適合ではない。）
◎
Advance position to the next character. (The "+" is ignored, but it is not conforming.)
◎
If position is past the end of input, return an error.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET ~error
◎
If the character indicated by position is not an ASCII digit, then return an error.
</li>
	<li>
%値 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position, and＼
</li>
	<li>
~RET %符号 × `Base10$( %値 )
◎
interpret the resulting sequence as a base-ten integer. Let value be that integer.
◎
If sign is "positive", return value, otherwise return the result of subtracting value from zero.
</li>
</ol>


				</section>
				<section id="non-negative-integers">
<h4 title="Non-negative integers">2.3.4.2. 非負~整数</h4>

<p>
1 個以上の`~ASCII数字$からなる文字列は
`妥当な非負~整数@
とされる。
◎
A string is a valid non-negative integer if it consists of one or more ASCII digits.
</p>

<p>
`妥当な非負~整数$は、
`Base10$( その数字~列 )
を表現する。
◎
A valid non-negative integer represents the number that is represented in base ten by that string of digits.
</p>


<p class="algo-head">
`非負~整数として構文解析する@
規則は、所与の
 ( 文字列 %入力 )
に対し，［
非負~整数, ~error
］のいずれかを返す：
◎
The rules for parsing non-negative integers are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either zero, a positive integer, or an error.
</p>

<ol>
	<li>
%値 ~LET `整数として構文解析する$( %入力 )
◎
Let input be the string being parsed.
◎
Let value be the result of parsing input using the rules for parsing integers.
</li>
	<li>
~IF［
%値 ~EQ ~error
］~OR［
%値 ~LT 0
］
⇒
~RET ~error
◎
If value is an error, return an error.
◎
If value is less than zero, return an error.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>


				</section>
				<section id="floating-point-numbers">
<h4 title="Floating-point numbers">2.3.4.3. 浮動小数点数</h4>

<p>
次の並びからなる文字列は、
`妥当な浮動小数点数@
とされる：
◎
A string is a valid floating-point number if it consists of:
</p>

<ol>
	<li>
“符号~部” ：
0 〜 1 個の ❝-
◎
Optionally, a U+002D HYPHEN-MINUS character (-).
</li>
	<li>
<p>
次の両方, または片方のみによる並び：
◎
One or both of the following, in the given order:
</p>
		<ol>
			<li>
“整数~部” ：
1 個以上の`~ASCII数字$からなる並び
◎
A series of one or more ASCII digits.
</li>
			<li>
<p>
次の並び：
◎
Both of the following, in the given order:
</p>
				<ol>
					<li>
1 個の ❝.
◎
A single U+002E FULL STOP character (.).
</li>
					<li>
“小数~部” ：
1 個以上の`~ASCII数字$からなる並び
◎
A series of one or more ASCII digits.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
“指数~部” ：
空~文字列, または
次の並び：
◎
Optionally:
</p>

		<ol>
			<li>
1 個の［
❝e, または ❝E
］
◎
Either a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E).
</li>
			<li>
“指数~部の符号~部” ：
0 〜 1 個の［
❝-, または ❝+
］
◎
Optionally, a U+002D HYPHEN-MINUS character (-) or U+002B PLUS SIGN character (+).
</li>
			<li>
“指数~部の数字~列” ：
1 個以上の`~ASCII数字$からなる並び
◎
A series of one or more ASCII digits.
</li>
		</ol>
	</li>
</ol>


<div class="p">
<p>
`妥当な浮動小数点数$は、
( %符号 × %仮数 × ( 10 の %指数 乗 ) )
で得られる数を表現する
— ここで：
</p>

<ul>
	<li>
%符号 ~EQ ［
前述の “符号~部” ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
</li>
	<li>
<p>
%仮数 ~EQ %整数 + %小数
— ここで：
</p>
		<ul>
			<li>
%整数 ~EQ 前述の “整数~部” が［
あれば `Base10$( “整数~部” ) ／
なければ 0
］
</li>
			<li>
%小数 ~EQ 前述の “小数~部” が［
あれば `Frac10$( “小数~部” ) ／
なければ 0
］
</li>
		</ul>
	</li>
	<li>
<p >
%指数 ~EQ ［
前述の “指数~部” ~NEQ 空~文字列ならば
( %符号 × %指数 ) ／
~ELSE_ 0
］
— ここで：
</p>
		<ul>
			<li >
%符号 ~EQ ［
前述の “指数~部の符号~部” ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
</li>
			<li >
%指数 ~EQ `Base10$( 前述の “指数~部の数字~列” )
</li>
		</ul>
	</li>
</ul>

◎
A valid floating-point number represents the number obtained by multiplying the significand by ten raised to the power of the exponent, where the significand is the first number, interpreted as base ten (including the decimal point and the number after the decimal point, if any, and interpreting the significand as a negative number if the whole string starts with a U+002D HYPHEN-MINUS character (-) and the number is not zero), and where the exponent is the number after the E, if any (interpreted as a negative number if there is a U+002D HYPHEN-MINUS character (-) between the E and the number and the number is not zero, or else ignoring a U+002B PLUS SIGN character (+) between the E and the number if there is one). If there is no E, then the exponent is treated as zero.
</div>

<p class="note">注記：
Infinity, NaN（ Not-a-Number ）いずれの値も，`妥当な浮動小数点数$ではない。
◎
The Infinity and Not-a-Number (NaN) values are not valid floating-point numbers.
</p>

<p class="note">注記：
`妥当な浮動小数点数$の概念は、概して，作者に許容されるものを制約する利用に限られる。
一方で、~UAに課される要件には，`浮動小数点数として構文解析する$規則が利用される（例： `progress$e 要素の `max$a 属性 ）。
しかしながら，一部の事例では、文字列が`妥当な浮動小数点数$かどうか検査することも~UA要件に含まれる（例：
`Number$st 状態にある `input$e 要素~用の
<a href="~HEinput#value-sanitization-algorithm">値の消毒</a> ／
`srcset^a 属性を
<a href="~HEimages#parse-a-srcset-attribute">構文解析する</a>
~algo）。
◎
The valid floating-point number concept is typically only used to restrict what is allowed for authors, while the user agent requirements use the rules for parsing floating-point number values below (e.g., the max attribute of the progress element). However, in some cases the user agent requirements include checking if a string is a valid floating-point number (e.g., the value sanitization algorithm for the Number state of the input element, or the parse a srcset attribute algorithm).
</p>


<p>
実数 %n に対する
`浮動小数点数として最良の表現@
は、 `ToString$jA( %n ) を走らせて得られる文字列である。
`ToString()^jA 抽象演算の結果は一意に決定されるとは限らない
— 特定0の値に対する `ToString()^jA の結果として複数の文字列が可能な場合、~UAは常に同じ結果を返さ~MUST（他の~UAは相違する値を利用するかもしれないが）。
◎
The best representation of the number n as a floating-point number is the string obtained from running ToString(n). The abstract operation ToString is not uniquely determined. When there are multiple possible strings that could be obtained from ToString for a particular value, the user agent must always return the same string for that value (though it may differ from the value used by other user agents).
</p>

<p class="algo-head">
`浮動小数点数として構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
実数, ~error
］のいずれかを返す：
◎
The rules for parsing floating-point number values are as given in the following algorithm. This algorithm must be aborted at the first step that returns something. This algorithm will return either a number or an error.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
◎
Let value have the value 1.
◎
Let divisor have the value 1.
◎
Let exponent have the value 1.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
◎
If position is past the end of input, return an error.
↓</li>
	<li>
%符号 ~LET ［
%位置↗ ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
◎
If the character indicated by position is a U+002D HYPHEN-MINUS character (-):
• Change value and divisor to −1.
• Advance position to the next character.
• If position is past the end of input, return an error.
↓</li>
	<li>
~IF［
%位置↗ ~IN { ❝-, ❝+ }
］
⇒
%位置 ~INCBY 1
（ `+^l は適合でないが無視される）
◎
Otherwise, if the character indicated by position (the first character) is a U+002B PLUS SIGN character (+):
• Advance position to the next character. (The "+" is ignored, but it is not conforming.)
• If position is past the end of input, return an error.
</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~IF［
%位置↗ ~NEQ ❝.
］~OR［
( %位置 + 1 )↗ ~NIN `~ASCII数字$
］
⇒
~RET ~error
◎
↑↓</li>
	<li>
%値 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
	<li>
%値 ~SET `Base10$( %値 )
◎
If the character indicated by position is a U+002E FULL STOP (.), and that is not the last character in input, and the character after the character indicated by position is an ASCII digit, then set value to zero and jump to the step labeled fraction.
◎
If the character indicated by position is not an ASCII digit, then return an error.
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply value by that integer.
◎
If position is past the end of input, jump to the step labeled conversion.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝.
]：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%小数~部 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
</li>
			<li>
%値 ~INCBY `Frac10$( %小数~部 )
</li>
		</ol>

◎
Fraction: If the character indicated by position is a U+002E FULL STOP (.), run these substeps:
• Advance position to the next character.
• If position is past the end of input, or if the character indicated by position is not an ASCII digit, U+0065 LATIN SMALL LETTER E (e), or U+0045 LATIN CAPITAL LETTER E (E), then jump to the step labeled conversion.
• If the character indicated by position is a U+0065 LATIN SMALL LETTER E character (e) or a U+0045 LATIN CAPITAL LETTER E character (E), skip the remainder of these substeps.
•• Fraction loop: Multiply divisor by ten.
••Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
••Advance position to the next character.
••If position is past the end of input, then jump to the step labeled conversion.
••If the character indicated by position is an ASCII digit, jump back to the step labeled fraction loop in these substeps.
</li>
	<li>
<p>
~IF［
%位置↗ ~IN { ❝e, ❝E }
］：
◎
If the character indicated by position is U+0065 (e) or a U+0045 (E), then:
</p>

		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
◎
If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
%指数 ~SET ［
%位置↗ ~EQ ❝- ならば −1 ／
~ELSE_ 1
］
◎
If the character indicated by position is a U+002D HYPHEN-MINUS character (-):
• Change exponent to −1.
• Advance position to the next character.
• If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
~IF［
%位置↗ ~IN { ❝-, ❝+ }
］
⇒
%位置 ~INCBY 1
◎
Otherwise, if the character indicated by position is a U+002B PLUS SIGN character (+):
• Advance position to the next character.
• If position is past the end of input, then jump to the step labeled conversion.
</li>
			<li>
%冪 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
			<li>
%指数 ~SET %指数 × `Base10$( %冪 )
◎
If the character indicated by position is not an ASCII digit, then jump to the step labeled conversion.
◎
Collect a sequence of code points that are ASCII digits from input given position, and interpret the resulting sequence as a base-ten integer. Multiply exponent by that integer.
</li>
			<li>
%値 ~SET %値 × ( 10 の %指数 乗 )
◎
Multiply value by ten raised to the exponentth power.
</li>
		</ol>
	</li>
	<li>
%値 ~SET %値 × %符号
◎
↑↑</li>
	<li>
%S ~LET ［［
有限 IEEE 754 倍精度 浮動小数点数の集合
］から −0 を除いた集合
］に 2 個の特別な値［
%max ~EQ ( 2 の 1024  乗 ),
%min ~EQ −( 2 の 1024 乗 )
］を追加した集合
◎
Conversion: Let S be the set of finite IEEE 754 double-precision floating-point values except −0, but with two special values added: 21024 and −21024.
</li>
	<li>
%結果 ~LET
%S 内の数であって， %値 に最も近いもの
— ここで、%値 が %S 内の 2 個の数に等しく近い場合は、仮数が偶数である方を選ぶ（この目的においては、 %max, %min の仮数は偶数と見なす）。
◎
Let rounded-value be the number in S that is closest to value, selecting the number with an even significand if there are two equally close values. (The two special values 21024 and −21024 are considered to have even significands for this purpose.)
</li>
	<li>
~IF［
%結果 ~IN { %max, %min }
］
⇒
~RET ~error
◎
If rounded-value is 21024 or −21024, return an error.
</li>
	<li>
~RET %結果
◎
Return rounded-value.
</li>
</ol>

<p class="trans-note">【
この訳では、等価な結果が得られるように，原文の~algoをかなり簡約している。
】</p>

				</section>
				<section id="percentages-and-dimensions">
<h4 title="Percentages and lengths">2.3.4.4. 百分率, 長さ</h4>

<p class="algo-head">
`寸法~値として構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
( 実数, 種別 ) の組, ~error
］のいずれかを返す
— ここで、実数は 0.0 以上,
種別は［
`百分率^i, `長さ^i
］のいずれかである：
◎
The rules for parsing dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than or equal to 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
	<li>
~IF［
%位置↗ ~EQ ❝+
］
⇒
%位置 ~INCBY 1
◎
If position is past the end of input, return an error.
◎
If the character indicated by position is a U+002B PLUS SIGN character (+), advance position to the next character.
</li>
	<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET ~error
◎
If position is past the end of input, return an error.
◎
If the character indicated by position is not an ASCII digit, then return an error.
</li>
	<li>
%値 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position, and＼
</li>
	<li>
%値 ~SET `Base10$( %値 )
◎
interpret the resulting sequence as a base-ten integer. Let value be that number.
◎
If position is past the end of input, return value as a length.
↓</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝.
］：
◎
If the character indicated by position is a U+002E FULL STOP character (.):
</p>

		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character.
</li>
			<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］
⇒
~RET ( %値, `長さ^i )
◎
If position is past the end of input, or if the character indicated by position is not an ASCII digit, then return value as a length.
</li>
			<li>
%小数~部 ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
			<li>
%値 ~INCBY `Frac10$( %小数~部 )
◎
Let divisor have the value 1.
◎
Fraction loop: Multiply divisor by ten.
◎
Add the value of the character indicated by position, interpreted as a base-ten digit (0..9) and divided by divisor, to value.
◎
Advance position to the next character.
◎
If position is past the end of input, then return value as a length.
◎
If the character indicated by position is an ASCII digit, return to the step labeled fraction loop in these substeps.
</li>
		</ol>
	</li>
	<li>
~IF［
%位置↗ ~EQ ❝%
］
⇒
~RET ( %値, `百分率^i )
◎
If position is past the end of input, return value as a length.
◎
If the character indicated by position is a U+0025 PERCENT SIGN character (%), return value as a percentage.
</li>
	<li>
~RET ( %値, `長さ^i )
◎
Return value as a length.
</li>
</ol>


				</section>
				<section id="non-zero-percentages-and-lengths">
<h4 title="Non-zero percentages and lengths">2.3.4.5. 非~zeroの百分率と長さ</h4>

<p class="algo-head">
`非~zero寸法~値として構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［［
( 0.0 以上の実数, 種別（`百分率^i または `長さ^i ）) の組
］, ~error
］のいずれかを返す：
◎
The rules for parsing nonzero dimension values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a number greater than 0.0, or an error; if a number is returned, then it is further categorized as either a percentage or a length.
</p>

<ol>
	<li>
%V ~LET `寸法~値として構文解析する$( %入力 )
◎
Let input be the string being parsed.
◎
Let value be the result of parsing input using the rules for parsing dimension values.
</li>
	<li>
~IF［
%V ~EQ ~error
］~OR ［
%V ~EQ 0
］
⇒
~RET ~error
◎
If value is an error, return an error.
◎
If value is zero, return an error.
</li>
	<li>
~RET %V
◎
If value is a percentage, return value as a percentage.
◎
Return value as a length.
</li>
</ol>


				</section>
				<section id="lists-of-floating-point-numbers">
<h4 title="Lists of floating-point numbers">2.3.4.6. 浮動小数点数~list</h4>

<p>
❝, で互いに区切られた，
0 個以上の`妥当な浮動小数点数$からなる文字列は、
`妥当な浮動小数点数~list@
とされる。
区切りには他の文字（`~ASCII空白$など）は含まない。
加えて，許容される 浮動小数点数の個数 には、制約が課されることもある。
◎
A valid list of floating-point numbers is a number of valid floating-point numbers separated by U+002C COMMA characters, with no other characters (e.g. no ASCII whitespace). In addition, there might be restrictions on the number of floating-point numbers that can be given, or on the range of values allowed.
</p>

<p class="algo-head">
`浮動小数点数~listとして構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，次に従う：
◎
The rules for parsing a list of floating-point numbers are as follows:
</p>


<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%実数~list ~LET 空~list
— この~listが~algoの結果になる。
◎
Let numbers be an initially empty list of floating-point numbers. This list will be the result of this algorithm.
</li>
	<li>
%区切子 ~LET { `~ASCII空白$, ❝,, ❝; }
◎
↓</li>
	<li>
%入力 内の %位置 から
%区切子 からなる`符号位置~並びを収集する$
— これは、頭部の区切子を読飛ばす。
◎
Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past any leading delimiters.
</li>
	<li>
<p>
~WHILE ( %位置↗ ~NEQ ε )：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%入力 内の %位置 から
{ %区切子, `~ASCII数字$, ❝., ❝- }
以外の`符号位置~並びを収集する$
— これは、頭部の無用な文字~並びを読飛ばす。
◎
Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, U+003B SEMICOLON, ASCII digits, U+002E FULL STOP, or U+002D HYPHEN-MINUS characters from input given position. This skips past leading garbage.
</li>
			<li>
%実数~文字列 ~LET 
%入力 内の %位置 から
%区切子 以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position, and let unparsed number be the result.
</li>
			<li>
%実数 ~LET `浮動小数点数として構文解析する$( %実数~文字列 )
◎
Let number be the result of parsing unparsed number using the rules for parsing floating-point number values.
</li>
			<li>
~IF［
%実数 ~EQ ~error
］
⇒
%実数 ~SET 0
◎
If number is an error, set number to zero.
</li>
			<li>
%実数~list に %実数 を付加する
◎
Append number to numbers.
</li>
			<li>
%入力 内の %位置 から
%区切子 からなる`符号位置~並びを収集する$
— これは、次の区切子を読飛ばす。
◎
Collect a sequence of code points that are ASCII whitespace, U+002C COMMA, or U+003B SEMICOLON characters from input given position. This skips past the delimiter.
</li>
		</ol>
	<li>
~RET %実数~list
◎
Return numbers.
</li>
</ol>


				</section>
				<section id="lists-of-dimensions">
<h4 title="Lists of dimensions">2.3.4.7. 寸法~list</h4>


<p class="algo-head">
`寸法~listとして構文解析する@
規則は、所与の
( 文字列 %生~入力 )
に対し，［
0 個以上の［
( 実数, 単位 ) の組
］からなる~listを返す
— ここで、単位は［
`百分率^i, `相対^i, `絶対^i
］のいずれかである：
◎
The rules for parsing a list of dimensions are as follows. These rules return a list of zero or more pairs consisting of a number and a unit, the unit being one of percentage, relative, and absolute.
</p>

<ol>
	<li>
~IF［
%生~入力 の最後の文字 ~EQ ❝,
］
⇒
%生~入力 から最後の文字を除去する
◎
Let raw input be the string being parsed.
◎
If the last character in raw input is a U+002C COMMA character (,), then remove that character from raw input.
</li>
	<li>
%~token列 ~LET `~commaで分割する$( %生~入力 )
◎
Split the string raw input on commas. Let raw tokens be the resulting list of tokens.
</li>
	<li>
%結果 ~LET 空~list
◎
Let result be an empty list of number/unit pairs.
</li>
	<li>

<p>
%~token列 内の ~EACH ( ~token %入力 ) に対し：
◎
For each token in raw tokens, run the following substeps:
</p>

		<ol>
			<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the token.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
			<li>
%値 ~LET 0
◎
Let value be the number 0.
◎
Let unit be absolute.
</li>
			<li>
<p>
%位置↗ に応じて：
</p>
				<dl class="switch">
					<dt>
ε
◎
If position is past the end of input,＼
</dt>
					<dd>
						<ol>
							<li>
%結果 に組 ( %値, `相対^i ) を追加する
</li>
							<li>
~CONTINUE
</li>
						</ol>
◎
set unit to relative and jump to the last substep.
</dd>
					<dt>
`~ASCII数字$
◎
If the character at position is an ASCII digit,＼
</dt>
					<dd>
						<ol>
							<li>
%s ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
</li>
							<li>
%値 ~INCBY `Base10$( %s )
</li>
						</ol>
◎
collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as an integer in base ten, and increment value by that integer.
</dd>
					<dt>
❝.
◎
If the character at position is U+002E (.), then:
</dt>
					<dd>
						<ol>
							<li>
%s ~LET
%入力 内の %位置 から
{ `~ASCII空白$, `~ASCII数字$ }
からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points consisting of ASCII whitespace and ASCII digits from input given position. Let s be the resulting sequence.
</li>
							<li>
%s からすべての`~ASCII空白$を除去する
◎
Remove all ASCII whitespace in s.
</li>
							<li>
%値 ~INCBY `Frac10$( %s )
◎
If s is not the empty string, then:
• Let length be the number of characters in s (after the spaces were removed).
• Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.
• Increment value by fraction.
</li>
						</ol>
					</dd>
				</dl>
			</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
			<li>
<p>
%単位 ~LET %位置↗ に応じて，次で与えられる単位：
</p>
				<dl class="switch">
					<dt>❝%</dt>
					<dd>
`百分率^i
◎
If the character at position is a U+0025 PERCENT SIGN character (%), then set unit to percentage.
</dd>
					<dt>❝*</dt>
					<dd>
`相対^i
◎
Otherwise, if the character at position is a U+002A ASTERISK character (*), then set unit to relative.
</dd>
					<dt>その他</dt>
					<dd>
`絶対^i
</dd>
				</dl>
			</li>
			<li>
%結果 に組 ( %値, %単位 )
を追加する
◎
Add an entry to result consisting of the number given by value and the unit given by unit.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return the list result.
</li>
</ol>


				</section>
			</section>
			<section id="dates-and-times">
<h3 title="Dates and times">2.3.5. 日時（日付と時刻）</h3>

<div>
<p>
以下の各種~algoにおける，所与の
( %年t, %月t )
に対する
`月tの日t数@
は、次で与えられる：
</p>

<dl class="switch">
	<dt>%月t ~IN { 1, 3, 5, 7, 8, 10, 12 } の場合：</dt>
	<dd>31</dd>

	<dt>%月t ~IN { 4, 6, 9, 11 } の場合：</dt>
	<dd>30</dd>

	<dt>%月t ~EQ 2 の場合：</dt>
	<dd>
<p>
次のいずれかが満たされるならば 29：
</p>

<ul ><li>%年t ~EQ ε
</li><li>%年t は 400 の倍数である
</li><li>［
%年t は 4 の倍数である
］~AND［
%年t は 100 の倍数でない
］
</li></ul>
	</dd>
	<dd>
~ELSE_ 28
</dd>
</dl>

<p>
これは~Gregorian暦による閏~年tを織り込んだものである。
`GREGORIAN$r
</p>

◎
In the algorithms below, the number of days in month month of year year is: 31 if month is 1, 3, 5, 7, 8, 10, or 12; 30 if month is 4, 6, 9, or 11; 29 if month is 2 and year is a number divisible by 400, or if year is a number divisible by 4 but not by 100; and 28 otherwise. This takes into account leap years in the Gregorian calendar. [GREGORIAN]
</div>

<p>
この節にて定義される 日時~構文に利用される
`~ASCII数字$列は、基数 10 の数を表す。
◎
When ASCII digits are used in the date and time syntaxes defined in this section, they express numbers in base ten.
</p>


<p class="note">注記：
ここに述べる各種~形式は，~ISO8601形式の下位集合に対応するものとして意図されるが、この仕様は，~ISO8601よりずっと詳細に構文解析~規則を定義する。
したがって実装者には、下に述べる構文解析~規則を実装するときに日付~構文解析~libraryを利用する際には，その前に，注意深く検分することが奨励される
— その種の~ISO8601~libraryは、日時を正確に同じ方式で構文解析していないかもしれないので。
`ISO8601$r
◎
While the formats described here are intended to be subsets of the corresponding ISO8601 formats, this specification defines parsing rules in much more detail than ISO8601. Implementers are therefore encouraged to carefully examine any date parsing libraries before using them to implement the parsing rules described below; ISO8601 libraries might not parse dates and times in exactly the same manner. [ISO8601]
</p>


<p>
この仕様における
`遡及~Gregorian暦@
とは、現代の~Gregorian暦を 0001 年tまで遡って外部補間したものを意味する。
`遡及~Gregorian暦$における日付は、その暦が当時（または当地域）にて利用されていなかったとしても，その暦を利用して記述され、明示的に
`遡及~Gregorian日付@
と称されることもある。
`GREGORIAN$r
◎
Where this specification refers to the proleptic Gregorian calendar, it means the modern Gregorian calendar, extrapolated backwards to year 1. A date in the proleptic Gregorian calendar, sometimes explicitly referred to as a proleptic-Gregorian date, is one that is described using that calendar even if that calendar was not in use at the time (or place) in question. [GREGORIAN]
</p>

<p class="note">注記：
この仕様における伝送路~形式としての~Gregorian暦の利用は、文化的な偏向に孕まれるものによる決断の結果，恣意的に選ばれたものである。
~formにおける（作者~向けの）
<a href="~FORMSintro#input-author-notes">日付, 時刻, 数の形式</a>
を論じる節, および
<a href="~HEinput#input-impl-notes">~form~controlを地域化する際の実装~上の注記</a>,
`time$e 要素も見よ。
◎
The use of the Gregorian calendar as the wire format in this specification is an arbitrary choice resulting from the cultural biases of those involved in the decision. See also the section discussing date, time, and number formats in forms (for authors), implementation notes regarding localization of form controls, and the time element.
</p>


				<section id="months">
<h4 title="Months">2.3.5.1. 年月t</h4>

<p>
`年月t@
（ month ）は、日t 成分を伴わない（日t 成分は ε にされた）`日付$である。
◎
A month consists of a specific proleptic-Gregorian date with no time-zone information and no date information beyond a year and a month. [GREGORIAN]
</p>

<p class="trans-note">【
原文の語 “month” には、暗黙的に年tも含まれている（ “暦の中のある年tの中のある月t” ）。
単独の月t 成分と混同されないよう、この定義を指す month は， “年月t” と表記することにする。
】</p>

<p>
次の並びからなる文字列は、`年月t$を表現している
`妥当な年月t文字列@
とされる：
◎
A string is a valid month string representing a year year and month month if it consists of the following components in the given order:
</p>

<ol>
	<li>
年t 成分を表現する，次を満たす文字列 %年t
⇒
［
%年t は 4 個以上の`~ASCII数字$並びである
］~AND［
`Base10$( %年t ) ~NEQ 0
］
◎
Four or more ASCII digits, representing year, where year &gt; 0
</li>
	<li>
❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
月t 成分を表現する，次を満たす文字列 %月t
⇒
［
%月t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %月t ) ~IN { 1 〜 12 }
］
◎
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
</li>
</ol>


<p class="algo-head">
`年月t文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`年月t$, ε
］のいずれかを返す：
◎
The rules to parse a month string are as follows. This will return either a year and month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `年月t成分を構文解析する$
◎
↓</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
Parse a month component to obtain year and month. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Return year and month.
</li>
</ol>

<p class="algo-head">
所与の %入力 内の %位置 から
`年月t成分を構文解析する@
規則は、［
`年月t$, ε
］のいずれかを返す。
◎
The rules to parse a month component, given an input string and a position, are as follows. This will return either a year and a month, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%年t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%年t の文字~数 ~LT 4
］
⇒
~RET ε
◎
If the collected sequence is not at least four characters long, then fail.＼
</li>
	<li>
%年t ~SET `Base10$( %年t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.
</li>
	<li>
~IF［
%年t ~EQ 0
］
⇒
~RET ε
◎
If year is not a number greater than zero, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%月t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%月t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%月t数 ~SET `Base10$( %月t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.
</li>
	<li>
~IF［
%月t数 ~NIN { 1 〜 12 }
］
⇒
~RET ε
◎
If month is not a number in the range 1 ≤ month ≤ 12, then fail.
</li>
	<li>
~RET `日付$( %年t数, %月t数, ε )
◎
Return year and month.
</li>
</ol>


				</section>
				<section id="dates">
<h4 title="Dates">2.3.5.2. 日付</h4>


<div class="p">

<p>
`日付@
（ date ）は、時間帯~情報は伴わない特定の`遡及~Gregorian日付$ `GREGORIAN$r
を表し， 3 個の正~整数
( 年t, 月t, 日t )
成分からなる。
</p>

<p>
“日付( %年t, %月t, %日t )”
という表記は、
( 年t, 月t, 日t )
成分が，順に
( %年t, %月t, %日t )
にされた`日付$を表すとする。
同様に、
“日付( %年t, %月t, ε )”
という表記は `年月t$を表し，
“日付( ε, %月t, %日t )”
という表記は `月日t$を表すとする。
</p>

◎
A date consists of a specific proleptic-Gregorian date with no time-zone information, consisting of a year, a month, and a day. [GREGORIAN]
</div>


<p>
次の並びからなる文字列は、`日付$を表現している
`妥当な日付~文字列@
とされる：
◎
A string is a valid date string representing a year year, month month, and day day if it consists of the following components in the given order:
</p>

<ol>
	<li>
( 年t, 月t ) 成分を表現する，`妥当な年月t文字列$
◎
A valid month string, representing year and month
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
日t 成分を表現する，次を満たす文字列 %日t
⇒
［
2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %日t ) ~IN { 1 〜 `月tの日t数$( %年t数, %月t数 ) }
］
◎
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and year year
</li>
</ol>


<p class="algo-head">
`日付~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`日付$, ε
］のいずれかを返す：
◎
The rules to parse a date string are as follows. This will return either a date, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day.＼
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Let date be the date with year year, month month, and day day.
◎
Return date.
</li>
</ol>

<p class="algo-head">
所与の %入力 内の %位置 から
`日付~成分を構文解析する@
規則は、［
`日付$, ε
］のいずれかを返す：
◎
The rules to parse a date component, given an input string and a position, are as follows. This will return either a year, a month, and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%日付 ~LET `年月t成分を構文解析する$
◎
Parse a month component to obtain year and month.＼
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
 If this returns nothing, then fail.
</li>
	<li>
%最大日数 ~LET `月tの日t数$( %日付 の年t 成分, %日付 の月t 成分 )
◎
Let maxday be the number of days in month month of year year.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%日t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%日t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%日t数 ~SET `Base10$( %日t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.
</li>
	<li>
~IF［
%日t数 ~NIN { 1 〜 %最大日数 }
］
⇒
~RET ε
◎
If day is not a number in the range 1 ≤ day ≤ maxday, then fail.
</li>
	<li>
%日付 の 日t 成分 ~SET %日t数
◎
↓</li>
	<li>
~RET %日付
◎
Return year, month, and day.
</li>
</ol>


				</section>
				<section id="yearless-dates">
<h4 title="Yearless dates">2.3.5.3. 月日t</h4>

<p>
`月日t@
（ yearless date, “年なし日付” ）は、年t 成分を伴わない（年t 成分は ε にされた）`日付$である。
◎
A yearless date consists of a Gregorian month and a day within that month, but with no associated year. [GREGORIAN]
</p>

<p class="trans-note">【
この訳では、他と表記法を一貫させるため， “月日t” と表記する。
】</p>

<p>
次の並びからなる文字列は、`月日t$を表現している
`妥当な月日t文字列@
とされる：
◎
A string is a valid yearless date string representing a month month and a day day if it consists of the following components in the given order:
</p>

<ol>
	<li>
0 個または 2 個の ❝-
◎
Optionally, two U+002D HYPHEN-MINUS characters (-)
</li>
	<li>
月t 成分を表現する，次を満たす文字列 %月t
⇒
［
%月t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %月t ) ~IN { 1 〜 12 }
］
◎
Two ASCII digits, representing the month month, in the range 1 ≤ month ≤ 12
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
日t 成分を表現する，次を満たす文字列 %日t
⇒
［
%日t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %日t ) ~IN { 1 〜 `月tの日t数$( ε, `Base10$( %月t ) ) }
］
◎
Two ASCII digits, representing day, in the range 1 ≤ day ≤ maxday where maxday is the number of days in the month month and any arbitrary leap year (e.g. 4 or 2000)
</li>
</ol>

<p class="note">注記：
言い換えれば、［
%月t ~EQ `02^l
］ならば、年t数が閏~年tであったかのように，日t数は 29 もとり得る。
◎
In other words, if the month is "02", meaning February, then the day can be 29, as if the year was a leap year.
</p>


<p class="algo-head">
`月日t文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`月日t$, ε
］のいずれかを返す：
◎
The rules to parse a yearless date string are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `月日t成分を構文解析する$
◎
Parse a yearless date component to obtain month and day.＼
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %日付
◎
Return month and day.
</li>
</ol>

<p class="algo-head">
所与の %入力 内の %位置 から
`月日t成分を構文解析する@
規則は、［
`月日t$, ε
］のいずれかを返す：
◎
The rules to parse a yearless date component, given an input string and a position, are as follows. This will return either a month and a day, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%seq ~LET %入力 内の %位置 から
❝- からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are U+002D HYPHEN-MINUS characters (-) from input given position.＼
</li>
	<li>
~IF［
%seq の文字~数 ~NIN { 0, 2 }
］
⇒
~RET ε
◎
If the collected sequence is not exactly zero or two characters long, then fail.
</li>
	<li>
%月t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%月t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%月t数 ~SET `Base10$( %月t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the month.
</li>
	<li>
~IF［
%月t数 ~NIN { 1 〜 12 }
］
⇒
~RET ε
◎
If month is not a number in the range 1 ≤ month ≤ 12, then fail.
◎
Let maxday be the number of days in month month of any arbitrary leap year (e.g. 4 or 2000).
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%日t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%日t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%日t数 ~SET `Base10$( %日t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the day.
</li>
	<li>
~IF［
%日t数 ~NIN { 1 〜 `月tの日t数$( ε, %月t数 ) }
］
⇒
~RET ε
◎
If day is not a number in the range 1 ≤ day ≤ maxday, then fail.
</li>
	<li>
~RET `日付$( ε, %月t数, %日t数 )
◎
Return month and day.
</li>
</ol>


				</section>
				<section id="times">
<h4 title="Times">2.3.5.4. 時刻</h4>

<div class="p">

<p>
`時刻@
（ time ）は、時間帯~情報を伴わない特定の時刻を表す，
( 時t, 分t, 秒t )
成分からなる。
時t, 分t
成分は整数であり、秒t 成分は 小数~部も伴われ得る数である。
</p>

<p>
“時刻( %時t, %分t, %秒t )”
という表記は、
( 時t, 分t, 秒t )
成分が，順に
( %時t, %分t, %秒t )
にされた`時刻$を表すとする。
</p>

◎
A time consists of a specific time with no time-zone information, consisting of an hour, a minute, a second, and a fraction of a second.
</div>


<p>
次の並びからなる文字列は、`時刻$を表現している
`妥当な時刻~文字列@
とされる：
◎
A string is a valid time string representing an hour hour, a minute minute, and a second second if it consists of the following components in the given order:
</p>

<ol>
	<li>
時t 成分を表現する，次を満たす文字列 %時t
⇒
［
%時t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %時t ) ~IN { 0 〜 23 }
］
◎
Two ASCII digits, representing hour, in the range 0 ≤ hour ≤ 23
</li>
	<li>
1 個の ❝:
◎
A U+003A COLON character (:)
</li>
	<li>
分t 成分を表現する，次を満たす文字列 %分t
⇒
［
%分t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %分t ) ~IN { 0 〜 59 }
］
◎
Two ASCII digits, representing minute, in the range 0 ≤ minute ≤ 59
</li>
	<li>
<p>
空~文字列（秒t 成分 0 を表現する）, または
秒t 成分を表現する次の並び：
◎
If second is nonzero, or optionally if second is zero:
</p>
		<ol>
			<li>
1 個の ❝:
◎
A U+003A COLON character (:)
</li>
			<li>
秒t 成分の整数~部を表現する，次を満たす文字列 %秒t
⇒
［
%秒t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %秒t ) ~IN { 0 〜 59 }
］
◎
Two ASCII digits, representing the integer part of second, in the range 0 ≤ s ≤ 59
</li>
			<li>
<p>
空~文字列（ 秒t 成分は整数である）, または
秒tの小数~部を表現する 次の並び：
◎
If second is not an integer, or optionally if second is an integer:
</p>
				<ol>
					<li>
1 個の ❝.
◎
A U+002E FULL STOP character (.)
</li>
					<li>
1 〜 3 個の`~ASCII数字$
◎
One, two, or three ASCII digits, representing the fractional part of second
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
秒t 成分は 60, 61 にはなり得ないので、閏~秒tは表現できない。
◎
The second component cannot be 60 or 61; leap seconds cannot be represented.
</p>

<p class="trans-note">【
秒t 成分の小数~部は、`妥当な時刻~文字列$としては 3 桁までにされているが，以下の構文解析-規則の中では 上限はない。
】</p>


<p class="algo-head">
`時刻~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`時刻$, ε
］のいずれかを返す：
◎
The rules to parse a time string are as follows. This will return either a time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析する$
◎
Parse a time component to obtain hour, minute, and second.＼
</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %時刻
◎
Let time be the time with hour hour, minute minute, and second second.
◎
Return time.
</li>
</ol>

<p class="algo-head">
所与の %入力 内の %位置 から
`時刻~成分を構文解析する@
規則は、［
`時刻$, ε
］のいずれかを返す：
◎
The rules to parse a time component, given an input string and a position, are as follows. This will return either an hour, a minute, and a second, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%時t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%時t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%時t数 ~SET `Base10$( %時t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the hour.
</li>
	<li>
~IF［
%時t数 ~NIN { 0 〜 23 }
］
⇒
~RET ε
◎
If hour is not a number in the range 0 ≤ hour ≤ 23, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝:
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%分t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%分t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%分t数 ~SET `Base10$( %分t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the minute.
</li>
	<li>
~IF［
%分t数 ~NIN { 0 〜 59 }
］
⇒
~RET ε
◎
If minute is not a number in the range 0 ≤ minute ≤ 59, then fail.
</li>
	<li>
%秒t数 ~LET 0
◎
Let second be 0.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝:
］：
◎
If position is not beyond the end of input and the character at position is U+003A (:), then:
</p>

		<ol>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next character in input.
</li>
			<li>
~IF［
%位置↗ ~NIN `~ASCII数字$
］~OR［
( %位置 + 1 )↗ ~NIN `~ASCII数字$
］
⇒
~RET ε
◎
If position is beyond the end of input, or at the last character in input, or if the next two characters in input starting at position are not both ASCII digits, then fail.
</li>
			<li>
%秒t数 ~SET `Base10$( ［
%位置↗, ( %位置 + 1 )↗
］並びからなる文字列
)
◎
↓</li>
			<li>
%位置 ~INCBY 2
◎
↓</li>
			<li>
%小数~部 ~LET %入力 内の %位置 から
{ `~ASCII数字$, ❝. } からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are either ASCII digits or U+002E FULL STOP characters from input given position.＼
</li>
			<li>
<p >
~IF［
%小数~部 ~NEQ 空~文字列
］：
</p>
				<ol>
					<li>
~IF［
%小数~部 の先頭の文字 ~NEQ ❝.
］
⇒
~RET ε
</li>
					<li>
%小数~部 から先頭の文字を除去する
</li>
					<li>
~IF［
%小数~部 ~EQ 空~文字列
］~OR［
%小数~部 に ❝. が含まれている
］
⇒
~RET ε
</li>
					<li>
%秒t数 ~INCBY `Frac10$( %小数~部 )
</li>
				</ol>
◎
If the collected sequence is three characters long, or if it is longer than three characters long and the third character is not a U+002E FULL STOP character, or if it has more than one U+002E FULL STOP character, then fail. Otherwise, interpret the resulting sequence as a base-ten number (possibly with a fractional part). Set second to that number.
</li>
		</ol>
	</li>
	<li>
~IF［
%秒t数 ~LT 0
］~OR［
60 ~LTE %秒t数
］
⇒
~RET ε
◎
If second is not a number in the range 0 ≤ second &lt; 60, then fail.
</li>
	<li>
~RET `時刻$( %時t数, %分t数, %秒t数 )
◎
Return hour, minute, and second.
</li>
</ol>


				</section>
				<section id="local-dates-and-times">
<h4 title="Local dates and times">2.3.5.5. 局所的~日時</h4>

<p>
`局所的~日時@
（ local date and time ）は、時間帯は伴わない，
( `日付$, `時刻$ )
成分の組からなる。
`GREGORIAN$r
形式的には、偏差~成分が ε にされた`日時$として表される。
◎
A local date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, but expressed without a time zone. [GREGORIAN]
</p>

<p>
次の並びからなる文字列は、`局所的~日時$を表現している
`妥当な局所的~日時~文字列@
とされる：
◎
A string is a valid local date and time string representing a date and time if it consists of the following components in the given order:
</p>

<ol>
	<li>
日付 成分を表現する，`妥当な日付~文字列$
◎
A valid date string representing the date
</li>
	<li>
1 個の［
❝T, または `0020^U SPACE
］
◎
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
</li>
	<li>
時刻 成分を表現する，`妥当な時刻~文字列$
◎
A valid time string representing the time
</li>
</ol>

<p>
`妥当な局所的~日時~文字列$は、［
その時刻 成分を表現する文字列が，それが表現する時刻を可能な限り最短の文字列で表現する
］ならば、
`妥当な正規化済みの局所的~日時~文字列@
とされる（例えば，時刻の 秒t 成分が~zeroならば、秒t 成分を表現する文字列を まるごと省略する）。
◎
A string is a valid normalized local date and time string representing a date and time if it consists of the following components in the given order:
• A valid date string representing the date
• A U+0054 LATIN CAPITAL LETTER T character (T)
• A valid time string representing the time, expressed as the shortest possible string for the given time (e.g. omitting the seconds component entirely if the given time is zero seconds past the minute)
</p>

<p class="algo-head">
`局所的~日時~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`局所的~日時$, ε
］のいずれかを返す：
◎
The rules to parse a local date and time string are as follows. This will return either a date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day.＼
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NIN { ❝T, `0020^U SPACE }
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析する$
◎
Parse a time component to obtain hour, minute, and second.＼
</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET `日時$( %日付, %時刻, ε )
◎
Let date be the date with year year, month month, and day day.
◎
Let time be the time with hour hour, minute minute, and second second.
◎
Return date and time.
</li>
</ol>

				</section>
				<section id="time-zones">
<h4 title="Time zones">2.3.5.6. 時間帯</h4>

<div class="p">

<p>
`偏差@
（ time-zone offset ）は、 2 個の有符号~整数
( 時t, 分t )
成分からなる。
</p>

<p class="trans-note">【
偏差は、~UTCからの偏差
— すなわち，時間帯（ time zone ） —
を表す。
データとしては，時間帯も偏差も同じであり、何が念頭に置かれるか以外に違いはない。
】</p>

<p>
“偏差( %時t, %分t )”
という表記は、
( 時t, 分t )
成分が，順に
( %時t, %分t )
にされた`偏差$を表すとする。
</p>

◎
A time-zone offset consists of a signed number of hours and minutes.
</div>

<p>
次のいずれかで与えられる文字列は、
偏差を表現している
`妥当な偏差~文字列@
とされる：
◎
A string is a valid time-zone offset string representing a time-zone offset if it consists of either:
</p>


<ul>
	<li>
時間帯が~UTC
【すなわち，偏差( 0, 0 )】
の場合に限り
⇒
1 個の ❝Z
◎
A U+005A LATIN CAPITAL LETTER Z character (Z), allowed only if the time zone is UTC
</li>
	<li>
<p>
または、次の並びからなる文字列：
◎
Or, the following components, in the given order:
</p>

		<ol>
	<li>
偏差の各~成分の符号を表現する，
❝+ , または ❝-
— ただし，偏差の両~成分とも~zeroの場合、後者は許容されない。
◎
Either a U+002B PLUS SIGN character (+) or, if the time-zone offset is not zero, a U+002D HYPHEN-MINUS character (-), representing the sign of the time-zone offset
</li>
	<li>
偏差の時t 成分を表現する，次を満たす文字列 %時t
⇒
［
%時t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %時t ) ~IN { 0 〜 23 }
］
◎
Two ASCII digits, representing the hours component hour of the time-zone offset, in the range 0 ≤ hour ≤ 23
</li>
	<li>
0 〜 1 個の ❝:
◎
Optionally, a U+003A COLON character (:)
</li>
	<li>
偏差の分t 成分を表現する，次を満たす文字列 %分t
⇒
［
%分t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %分t ) ~IN { 0 〜 59 }
］
◎
Two ASCII digits, representing the minutes component minute of the time-zone offset, in the range 0 ≤ minute ≤ 59
</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
この形式は、範囲
{ −23:59 〜 +23:59 }
の偏差を許容する。
今現在，実施においては、実際の時間帯の範囲は
{ −12:00 〜 +14:00 }
であり，実際の時間帯の分t 成分は、常に ［
00, 30, 45
］のいずれかにされている。
しかしながら、永劫にそうあり続ける保証はない
— 時間帯は政治的駆引きにも利用されており、気まぐれな政治的決断の対象になるので。
◎
This format allows for time-zone offsets from -23:59 to +23:59. Right now, in practice, the range of offsets of actual time zones is -12:00 to +14:00, and the minutes component of offsets of actual time zones is always either 00, 30, or 45. There is no guarantee that this will remain so forever, however, since time zones are used as political footballs and are thus subject to very whimsical policy decisions.
</p>

<p class="note">注記：
偏差を［
公式的な時間帯の制定~以前の歴史的~時刻
］と併用する際の詳細については、下の`大域的~日時$ 節における用法についての注記, および例も見よ。
◎
See also the usage notes and examples in the global date and time section below for details on using time-zone offsets with historical times that predate the formation of formal time zones.
</p>


<p class="algo-head">
`偏差~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
偏差, ε
］のいずれかを返す：
◎
The rules to parse a time-zone offset string are as follows. This will return either a time-zone offset, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%偏差 ~LET `偏差~成分を構文解析する$
◎
Parse a time-zone offset component to obtain timezonehours and timezoneminutes.＼
</li>
	<li>
~IF［
%偏差 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET %偏差
◎
Return the time-zone offset that is timezonehours hours and timezoneminutes minutes from UTC.
</li>
</ol>

<p class="algo-head">
所与の %入力 内の %位置 から
`偏差~成分を構文解析する@
規則は、［
`偏差$, ε
］のいずれかを返す：
◎
The rules to parse a time-zone offset component, given an input string and a position, are as follows. This will return either time-zone hours and time-zone minutes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%符号 ~LET %位置↗
◎
↓</li>
	<li>
~IF［
%符号 ~NIN { ❝+, ❝-, ❝Z }
］
⇒
~RET ε
◎
↓↓</li>
	<li>
%位置 ~INCBY 1
◎
↓</li>
	<li>
~IF［
%符号 ~EQ ❝Z
］
⇒
~RET `偏差$( 0, 0 )
◎
If the character at position is a U+005A LATIN CAPITAL LETTER Z character (Z), then:
• Let timezonehours be 0.
• Let timezoneminutes be 0.
• Advance position to the next character in input.
</li>
	<li>
%時t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
	<li>
%分t ~LET ε
◎
↑↑Otherwise, if the character at position is either a U+002B PLUS SIGN (+) or a U+002D HYPHEN-MINUS (-), then:
◎
↓If the character at position is a U+002B PLUS SIGN (+), let sign be "positive". Otherwise, it's a U+002D HYPHEN-MINUS (-); let sign be "negative".
◎
↑Advance position to the next character in input.
◎
Collect a sequence of code points that are ASCII digits from input given position. Let s be the collected sequence.
</li>
	<li>
<p>
~IF［
%時t の文字~数 ~EQ 2
］：
</p>

		<ol>
			<li>
~IF［
%位置↗ ~NEQ ❝:
］
⇒
~RET ε
</li>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%分t ~SET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
</li>
			<li>
~IF［
%分t の文字~数 ~NEQ 2
］
⇒
~RET ε
</li>
		</ol>
◎
If s is exactly two characters long, then:
• Interpret s as a base-ten integer. Let that number be the timezonehours.
• If position is beyond the end of input or if the character at position is not a U+003A COLON character, then fail. Otherwise, move position forwards one character.
• Collect a sequence of code points that are ASCII digits from input given position. If the collected sequence is not exactly two characters long, then fail. Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the timezoneminutes.
</li>
	<li>
~ELIF［
%時t の文字~数 ~EQ 4
］
⇒
( %時t, %分t ) ~SET  %時t の ( 最初の 2 文字, 最後の 2 文字 )
◎
If s is exactly four characters long, then:
• Interpret the first two characters of s as a base-ten integer. Let that number be the timezonehours.
• Interpret the last two characters of s as a base-ten integer. Let that number be the timezoneminutes.
</li>
	<li>
~ELSE
⇒
~RET ε
◎
Otherwise, fail.
</li>
	<li>
( %時t数, %分t数 ) ~LET ( `Base10$( %時t ), `Base10$( %分t ) )
◎
↑</li>
	<li>
~IF［
%時t数 ~NIN { 0 〜 23 }
］~OR［
%分t数 ~NIN { 0 〜 59 }
］
⇒
~RET ε
◎
If timezonehours is not a number in the range 0 ≤ timezonehours ≤ 23, then fail.
◎
If sign is "negative", then negate timezonehours.
◎
If timezoneminutes is not a number in the range 0 ≤ timezoneminutes ≤ 59, then fail.
◎
If sign is "negative", then negate timezoneminutes.
</li>
	<li>
~IF［
%符号 ~EQ ❝-
］
⇒
~RET `偏差$( %時t数 × −1, %分t数 × −1 )
◎
↑</li>
	<li>
~RET `偏差$( %時t数, %分t数 )
◎
↑↑Otherwise, fail.
◎
Return timezonehours and timezoneminutes.
</li>
</ol>


				</section>
				<section id="global-dates-and-times">
<h4 title="Global dates and times">2.3.5.7. 大域的~日時</h4>

<div class="p">

<p>
`大域的~日時@
（ global date and time ）は、
( `日付$, `時刻$, `偏差$ )
成分の組で表される。
</p>

<p class="trans-note">【
［
`日付$, `時刻$
］成分のみで，~UTC世界時（地域に依存しない日時）が表現される。
`偏差$ 成分は、［
利用者に呈示する（`局所的~日時$に変換するなど） ／
文字列に直列化して外部に渡す
］ときに利用される付帯~情報になる。
】</p>

<p>
“日時( %日付, %時刻, %偏差 )”
という表記は、
( `日付$, `時刻$, `偏差$ )
成分が，順に
( %日付, %時刻, %偏差 )
にされた`大域的~日時$を表す（ %偏差 ~NEQ ε ならば）。
同様に、
“日時( %日付, %時刻, ε )”
という表記は `局所的~日時$を表すとする。
</p>

◎
A global date and time consists of a specific proleptic-Gregorian date, consisting of a year, a month, and a day, and a time, consisting of an hour, a minute, a second, and a fraction of a second, expressed with a time-zone offset, consisting of a signed number of hours and minutes. [GREGORIAN]
</div>


<p>
次の並びからなる文字列は、`大域的~日時$を表現している
`妥当な大域的~日時~文字列@
とされる：
◎
A string is a valid global date and time string representing a date, time, and a time-zone offset if it consists of the following components in the given order:
</p>

<ol>
	<li>
日付 成分を表現する，`妥当な日付~文字列$
◎
A valid date string representing the date
</li>
	<li>
1 個の［
❝T または `0020^U SPACE
］
◎
A U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character
</li>
	<li>
時刻 成分を表現する，`妥当な時刻~文字列$
◎
A valid time string representing the time
</li>
	<li>
偏差 成分を表現する，`妥当な偏差~文字列$
◎
A valid time-zone offset string representing the time-zone offset
</li>
</ol>

<div >
<p>
20 世紀~中頃における~UTCの制定~以前の日付による時刻は、~UT1世界時の用語（経度 0° の地点における当時の太陽時）を通して表され, 解釈され~MUST
— ~UTC（ SI 単位による秒t数で刻む ~UT1の，近似）ではなく。
時間帯の制定~以前の時刻は、次の 2 つを伴う~UT1時刻として表され, 解釈され~MUST：
</p>

<ul ><li>適切な局所的~時刻
</li><li>London Greenwich の所在にて観測される時刻との間の 当時の相違を近似するような，明示的な時間帯
</li></ul>

◎
Times in dates before the formation of UTC in the mid twentieth century must be expressed and interpreted in terms of UT1 (contemporary Earth solar time at the 0° longitude), not UTC (the approximation of UT1 that ticks in SI seconds). Time before the formation of time zones must be expressed and interpreted as UT1 times with explicit time zones that approximate the contemporary difference between the appropriate local time and the time observed at the location of Greenwich, London.
</div>


<div class="example">
<p>
`妥当な大域的~日時~文字列$として記される日付の例を以下に挙げる：
◎
The following are some examples of dates written as valid global date and time strings.
</p>

<dl>
	<dt>`0037-12-13 00:00Z^l</dt>
	<dd>
~London時刻を利用している地域における，~Nero（~Roman-Emperor）の誕生日の真夜中。
これに実際に対応する日付についての更なる論点については下を見よ。
◎
Midnight in areas using London time on the birthday of Nero (the Roman Emperor). See below for further discussion on which date this actually corresponds to.
</dd>

	<dt>`1979-10-14T12:00:00.001-04:00^l</dt>
	<dd>
USA 東海岸の夏時間に利用-中の時間帯における，［
1979 年 10 月 14 日
］の真昼から 1 ~milli秒t後。
◎
One millisecond after noon on October 14th 1979, in the time zone in use on the east coast of the USA during daylight saving time.
</dd>

	<dt>`8592-01-01T02:09+02:09^l</dt>
	<dd>
~UTCによる［
8592 年 1 月 1 日
］の真夜中。
この時刻には、~UTCより 2 時間 9 分 進んでいる時間帯が結付けられている
— それは、現在~~実用されている時間帯ではないが，許容される。
◎
Midnight UTC on the 1st of January, 8592. The time zone associated with that time is two hours and nine minutes ahead of UTC, which is not currently a real time zone, but is nonetheless allowed.
</dd></dl>

<p>
これらの日付について注目すべき点は：
◎
Several things are notable about these dates:
</p>

<ul>
	<li>
4 桁に満たない年tは~zero詰めされる必要がある。
`37-12-13^l は妥当な日付でない。
◎
Years with fewer than four digits have to be zero-padded. The date "37-12-13" would not be a valid date.
</li>
	<li>
`T^l に代えて~SPACEが用いられる場合、 1 個の~SPACEで~MUST。
文字列
`2001-12-21&nbsp;&nbsp;12:00Z^l
（成分~間に 2 個の~SPACEがある）は、成功裡に構文解析されない。
◎
If the "T" is replaced by a space, it must be a single space character. The string "2001-12-21 12:00Z" (with two spaces between the components) would not be parsed successfully.
</li>
	<li>
~Gregorian暦が導入される以前の時刻を一義的に識別するため（~UTCの制定~以前の時刻を一義的に識別できるようにする限りにおいて）、日付は、先ず当の時刻が利用している暦（例： ~Julian暦 ）から，~Gregorian暦に変換される必要がある。
~Nero生誕の日付は、~Julian暦においては
37 年 12 月 15 日
であり，`遡及~Gregorian暦$においては
37 年 12 月 13 日
になる。
◎
To unambiguously identify a moment in time prior to the introduction of the Gregorian calendar (insofar as moments in time before the formation of UTC can be unambiguously identified), the date has to be first converted to the Gregorian calendar from the calendar in use at the time (e.g. from the Julian calendar). The date of Nero's birth is the 15th of December 37, in the Julian Calendar, which is the 13th of December 37 in the proleptic Gregorian calendar.
</li>
	<li>
時刻, 偏差 いずれの成分も省略可ではない。
◎
The time and time-zone offset components are not optional.
</li>
	<li>
0001 年t より前の日付は、この~versionの~HTMLにおいては，日時として表現できない。
◎
Dates before the year one can't be represented as a datetime in this version of HTML.
</li>
	<li>
前近代における特定の出来事の時刻は、最善でも近似である
— 時刻は比較的近代まで，きちんと協調されても測定されてもいなかったので。
◎
Times of specific events in ancient times are, at best, approximations, since time was not well coordinated or measured until relatively recent decades.
</li>
	<li>
偏差は、夏時間に基づいて相違する。
◎
Time-zone offsets differ based on daylight saving time.
</li>
</ul>

</div>

<p class="algo-head">
`大域的~日時~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`大域的~日時$, ε
］のいずれかを返す：
<!-- 
受渡しや表示-目的に~UTCからに偏差~情報も伴う ＊時刻,
-->
◎
The rules to parse a global date and time string are as follows. This will return either a time in UTC, with associated time-zone offset information for round-tripping or display purposes, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day.＼
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NIN { ❝T, `0020^U SPACE }
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%時刻 ~LET `時刻~成分を構文解析する$
◎
Parse a time component to obtain hour, minute, and second.＼
</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~EQ ε
］
⇒
~RET ε
◎
If position is beyond the end of input, then fail.
</li>
	<li>
%偏差 ~LET `偏差~成分を構文解析する$
◎
Parse a time-zone offset component to obtain timezonehours and timezoneminutes.＼
</li>
	<li>
~IF［
%偏差 ~EQ ε
］
⇒
~RET ε
◎
If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
( %日付, %時刻 ) ~LET ( %日付, %時刻 ) から %偏差 を減算した結果†
— この結果が~UTC時間帯における時刻を表す。
◎
Let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes. That moment in time is a moment in the UTC time zone.
</li>
	<li>
~RET `日時$( %日付, %時刻, %偏差 )
◎
Let timezone be timezonehours hours and timezoneminutes minutes from UTC.
◎
Return time and timezone.
</li>
</ol>


<p class="trans-note">【†
“減算する” ための具体的な~algoは、この仕様には述べられていない。
%入力 においては，年t 成分に対する
<a href="#parse-a-month-component">~zeroは許容されていない</a>
が、減算した結果の年tは，~zeroになり得る。
】</p>


				</section>
				<section id="weeks">
<h4 title="Weeks">2.3.5.8. 年週t</h4>

<div class="p">

<p>
`年週t@
（ week ）は、 2 個の正~整数
( 週年t, 週t )
成分からなり，`遡及~Gregorian暦$における ある［
月曜から開始する七日間
］を表現する。
この暦付け~systemにおける各 週年tは、そのような七日間を 52 回または 53 回 有する
— 下に定義されるように。
~Gregorian日付［
1969 年 12 月 29 日の月曜（ 1969-12-29 ）
］から開始する七日間は、［
週年t 1970 における第 1 週t
］として定義される。
ある週年tにおける各 週tは、 1 から順々に付番される。
ある週年tにおける第 1 週tより前の週tは、その前の週年tにおける最後の週tであり，その逆も同様である。
`GREGORIAN$r
</p>

<p class="trans-note">【
`年月t$のときと同様に、この訳では “年週t” と表記する。
】</p>

<p>
“年週t( %週年t, %週t )”
という表記は、
( 週年t, 週t )
成分が，順に
( %週年t, %週t )
にされた`年週t$を表すとする。
</p>

◎
A week consists of a week-year number and a week number representing a seven-day period starting on a Monday. Each week-year in this calendaring system has either 52 or 53 such seven-day periods, as defined below. The seven-day period starting on the Gregorian date Monday December 29th 1969 (1969-12-29) is defined as week number 1 in week-year 1970. Consecutive weeks are numbered sequentially. The week before the number 1 week in a week-year is the last week in the previous week-year, and vice versa. [GREGORIAN]
</div>


<div class="p">

<p>
週年t %Y の
`最後の日tの週t番号@
— “週t数( %Y )” とも表記される —
は、次のいずれかが満たされるならば 53 とされ，他の場合は 52 とされる：
</p>

<ul>
	<li>
［［
`遡及~Gregorian暦$における年t %Y
］の最初の日t（ 1 月 1 日 ）の曜日
］は、火曜である
</li>
	<li>
<p>
［
前項の曜日は 水曜である
］~AND［
%Y は 次のいずれかを満たす
］：
</p>

<ul ><li>400 の倍数である
</li><li>［
4 の倍数である
］~AND［
100 の倍数でない
］
</li></ul>

	</li>
</ul>

◎
A week-year with a number year has 53 weeks if it corresponds to either a year year in the proleptic Gregorian calendar that has a Thursday as its first day (January 1st), or a year year in the proleptic Gregorian calendar that has a Wednesday as its first day (January 1st) and where year is a number divisible by 400, or a number divisible by 4 but not by 100. All other week-years have 52 weeks.
◎
The week number of the last day of a week-year with 53 weeks is 53; the week number of the last day of a week-year with 52 weeks is 52.
</div>

<p class="note">注記：
年末年始の特定0の日tにおける週年tと，`遡及~Gregorian暦$における その日tを包含する年tとは、異なることもある。
週年t %Y における最初の週tは、~Gregorian年t %Y の最初の火曜を包含する週tである
【そうなるように、年週tは定義されている】
。
◎
The week-year number of a particular day can be different than the number of the year that contains that day in the proleptic Gregorian calendar. The first week in a week-year y is the week that contains the first Thursday of the Gregorian year y.
</p>

<p class="note">注記：
現代の目的においては、ここに定義される`年週t$は、
`ISO8601$r に定義される週tと等価になる。
◎
For modern purposes, a week as defined here is equivalent to ISO weeks as defined in ISO 8601. [ISO8601]
</p>

<p>
次の並びからなる文字列は、`年週t$を表現している
`妥当な年週t文字列@
とされる：
◎
A string is a valid week string representing a week-year year and week week if it consists of the following components in the given order:
</p>

<ol>
	<li>
年週tの週年t 成分を表現する，次を満たす文字列 %週年t
⇒
［
%週年t は 4 個以上の`~ASCII数字$並びである
］~AND［
`Base10$( %週年t ) ~NEQ 0
］
◎
Four or more ASCII digits, representing year, where year &gt; 0
</li>
	<li>
1 個の ❝-
◎
A U+002D HYPHEN-MINUS character (-)
</li>
	<li>
1 個の ❝W
◎
A U+0057 LATIN CAPITAL LETTER W character (W)
</li>
	<li>
年週tの週t 成分を表現する，次を満たす文字列 %週t
⇒
［
%週t は 2 個の`~ASCII数字$並びである
］~AND［
`Base10$( %週t ) ~IN { 1 〜 `週t数$( %週年t が表現する週年t ) }
］
◎
Two ASCII digits, representing the week week, in the range 1 ≤ week ≤ maxweek, where maxweek is the week number of the last day of week-year year
</li>
</ol>


<p class="algo-head">
`年週t文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`年週t$, ε
］のいずれかを返す：
◎
The rules to parse a week string are as follows. This will return either a week-year number and week number, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%年t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%年t の文字~数 ~LT 4
］
⇒
~RET ε
◎
If the collected sequence is not at least four characters long, then fail.＼
</li>
	<li>
%年t数 ~SET `Base10$( %年t )

◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the year.
</li>
	<li>
~IF［
%年t数 ~EQ 0
］
⇒
~RET ε
◎
If year is not a number greater than zero, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝-
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is not a U+002D HYPHEN-MINUS character, then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
~IF［
%位置↗ ~NEQ ❝W
］
⇒
~RET ε
◎
If position is beyond the end of input or if the character at position is not a U+0057 LATIN CAPITAL LETTER W character (W), then fail.＼
</li>
	<li>
%位置 ~INCBY 1
◎
Otherwise, move position forwards one character.
</li>
	<li>
%週t ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position.＼
</li>
	<li>
~IF［
%週t の文字~数 ~NEQ 2
］
⇒
~RET ε
◎
If the collected sequence is not exactly two characters long, then fail.＼
</li>
	<li>
%週t数 ~SET `Base10$( %週t )
◎
Otherwise, interpret the resulting sequence as a base-ten integer. Let that number be the week.
</li>
	<li>
~IF［
%週t数 ~NIN { 1 〜 `週t数$( %年t数 ) }
］
⇒
~RET ε
◎
Let maxweek be the week number of the last day of year year.
◎
If week is not a number in the range 1 ≤ week ≤ maxweek, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~RET 
`年週t$( %年t数, %週t数 )
◎
Return the week-year number year and the week number week.
</li>
</ol>


				</section>
				<section id="durations">
<h4 title="Durations">2.3.5.9. 時間長</h4>

<p>
`時間長@
（ duration ）は、（負でない）秒t数である。
◎
A duration consists of a number of seconds.
</p>

<p class="note">注記：
月t数と秒t数は，比較可能でないので（月tは精確な秒t数を表さない
— その正確な長さは，測定し始める精確な日tに依存する期間である）、この仕様にて定義される`時間長$には，月tは含められない（したがって月t数 12 に等価な年tも）。
特定の秒t数を述べる時間長のみ，記述できる。
◎
Since months and seconds are not comparable (a month is not a precise number of seconds, but is instead a period whose exact length depends on the precise day from which it is measured) a duration as defined in this specification cannot include months (or years, which are equivalent to twelve months). Only durations that describe a specific number of seconds can be described.
</p>

<p>
次のいずれかからなる文字列は、`時間長$を表現している
`妥当な時間長~文字列@
とされる：
◎
A string is a valid duration string representing a duration t if it consists of either of the following:
</p>

<ul>
	<li>
<p>
文字 ❝P に［
次の並びが成す空でない文字列
］を付加して得られる文字列
— その中で与えられる
( 日t数, 時t数, 分t数, 秒t数 )
に対する
( 日t数 × 86400 + 時t数  × 3600 + 分t数 × 60 + 秒t数 )
が、`時間長$を与える（どの空~文字列も 0 に解釈する）：
◎
A literal U+0050 LATIN CAPITAL LETTER P character followed by one or more of the following subcomponents, in the order given, where the number of days, hours, minutes, and seconds corresponds to the same number of seconds as in t:
</p>

		<ol>
			<li>
日t数を表現する，空~文字列 または 次の並び
⇒＃
1 個以上の`~ASCII数字$,
1 個の ❝D
◎
One or more ASCII digits followed by a U+0044 LATIN CAPITAL LETTER D character, representing a number of days.
</li>
			<li>
<p>
空~文字列
—  ( 時t数, 分t数, 秒t数 ) いずれも 0 を表現する —
または、文字 ❝T に［
次の並びが成す空でない文字列
］を付加して得られる文字列：
◎
A U+0054 LATIN CAPITAL LETTER T character followed by one or more of the following subcomponents, in the order given:
</p>

				<ol>
					<li>
時t数を表現する，空~文字列 または 次の並び
⇒＃
1 個以上の`~ASCII数字$,
1 個の ❝H
◎
One or more ASCII digits followed by a U+0048 LATIN CAPITAL LETTER H character, representing a number of hours.
</li>
					<li>
分t数を表現する，空~文字列 または 次の並び
⇒＃
1 個以上の`~ASCII数字$,
1 個の ❝M
◎
One or more ASCII digits followed by a U+004D LATIN CAPITAL LETTER M character, representing a number of minutes.
</li>
					<li>
<p>
秒t数を表現する，空~文字列 または 次の並び：
◎
The following components:
</p>

		  				<ol>
							<li>
1 個以上の`~ASCII数字$
◎
One or more ASCII digits, representing a number of seconds.
</li>
							<li>
秒tの小数~部を表現する，空~文字列 または 次の並び
⇒＃
1 個の ❝.,
1 〜 3 個の`~ASCII数字$
◎
Optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.
</li>
							<li>
1 個の ❝S
◎
A U+0053 LATIN CAPITAL LETTER S character.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
これは、この仕様にて 日時に関係する他の各種 小構文に定義されるように，
`ISO8601$r にて定義される各種~形式のいずれかに基づく。
◎
This, as with a number of other date- and time-related microsyntaxes defined in this specification, is based on one of the formats defined in ISO 8601. [ISO8601]
</p>
	</li>
	<li>
<p>
任意の順序による， 1 個以上の各種 `時間長~成分$
— それぞれの`時間長~成分の縮尺$は互いに異なるような。
それぞれが表現する秒t数の総和が、`時間長$を与える。
◎
One or more duration time components, each with a different duration time component scale, in any order; the sum of the represented seconds being equal to the number of seconds in t.
</p>

<p>
次の並びからなる文字列が
`時間長~成分@
（ duration time component ）とされる：
◎
A duration time component is a string consisting of the following components:
</p>

<ol>
	<li>
0 個以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
1 個以上の `~ASCII数字$
— 時間~単位~数を表現し、
( この数 × 下に指定される`時間長~成分の縮尺$ )
が，この時間長~成分の秒t数を表現する。
◎
One or more ASCII digits, representing a number of time units, scaled by the duration time component scale specified (see below) to represent a number of seconds.
</li>
	<li>
`時間長~成分の縮尺$ ~EQ 1 の場合（すなわち，単位は秒t）に限り
⇒
空~文字列, または 秒tの小数~部を表現する次の並び
⇒＃
1 個の ❝.,
1 〜 3 個の`~ASCII数字$
◎
If the duration time component scale specified is 1 (i.e. the units are seconds), then, optionally, a U+002E FULL STOP character (.) followed by one, two, or three ASCII digits, representing a fraction of a second.
</li>
	<li>
0 個以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
	<li>
<p>
次の表の最初の列に与えるいずれかの文字
— 同じ行の “縮尺” の列が
`時間長~成分の縮尺@
を与える：
</p>

<table>
<thead><tr><th>文字
<th>単位
<th>縮尺
</thead>

<tbody><tr><td>❝W, ❝w
<td>週t
<td>604800

<tr><td>❝D, ❝d
<td>日t
<td>86400

<tr><td>❝H, ❝h
<td>時t
<td>3600

<tr><td>❝M, ❝m
<td>分t
<td>60

<tr><td>❝S, ❝s
<td>秒t
<td>1
</tbody></table>

◎
One of the following characters, representing the duration time component scale of the time unit used in the numeric part of the duration time component:
• U+0057 LATIN CAPITAL LETTER W character
• U+0077 LATIN SMALL LETTER W character
•• Weeks. The scale is 604800.
• U+0044 LATIN CAPITAL LETTER D character
• U+0064 LATIN SMALL LETTER D character
•• Days. The scale is 86400.
• U+0048 LATIN CAPITAL LETTER H character
• U+0068 LATIN SMALL LETTER H character
•• Hours. The scale is 3600.
• U+004D LATIN CAPITAL LETTER M character
• U+006D LATIN SMALL LETTER M character
•• Minutes. The scale is 60.
• U+0053 LATIN CAPITAL LETTER S character
• U+0073 LATIN SMALL LETTER S character
•• Seconds. The scale is 1.
</li>
	<li>
0 個以上の`~ASCII空白$
◎
Zero or more ASCII whitespace.
</li>
</ol>

<p class="note">注記：
これは、~ISO8601のどの形式に基づくものでもない。
これは、~ISO8601時間長~形式より，人から読み易い代替を与えるために意図されている。
◎
This is not based on any of the formats in ISO 8601. It is intended to be a more human-readable alternative to the ISO 8601 duration format.
</p>

	</li>
</ul>

<p class="algo-head">
`時間長~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`時間長$, ε
］のいずれかを返す：
◎
The rules to parse a duration string are as follows. This will return either a duration or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
( %月t数, %秒t数, %空 )
~LET ( 0, 0, ~T )
◎
Let months, seconds, and component count all be zero.
</li>
	<li>

<p>
%M一義化子 ~LET `分t^i
◎
Let M-disambiguator be minutes.
</p>

<p class="note">注記：
%M一義化子 が他にとり得る値は `月t^i である。
これは、月t数と分t数に同じ単位を利用している
~ISO8601時間長における "M" 単位を一義化するために利用される。
月t数は %入力 に許容されないが、将来との互換性をとるため, および
他の文脈においては妥当になるような~ISO8601時間長の誤解釈を避けるために構文解析される。
◎
This flag's other value is months. It is used to disambiguate the "M" unit in ISO8601 durations, which use the same unit for months and minutes. Months are not allowed, but are parsed for future compatibility and to avoid misinterpreting ISO8601 durations that would be valid in other contexts.
</p>

	</li>
	<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
◎
If position is past the end of input, then fail.
</li>
	<li>
<p>
~IF［
%位置↗ ~EQ ❝P 
］：
</p>
		<ol>
			<li>
%位置 ~INCBY 1
</li>
			<li>
%M一義化子 ~SET `月t^i
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
		</ol>

◎
If the character in input pointed to by position is a U+0050 LATIN CAPITAL LETTER P character, then advance position to the next character, set M-disambiguator to months, and skip ASCII whitespace within input given position.
</li>
	<li>

<p>
~WHILE %位置↗ ~NEQ ε：
<!-- ＊ -->
◎
While true:
• Let units be undefined. It will be assigned one of the following values: years, months, weeks, days, hours, minutes, and seconds.
• Let next character be undefined. It is used to process characters from the input.
• If position is past the end of input, then break.
</p>

		<ol>
			<li>
( %単位, %縮尺 ) ~LET ( ε, ε )
◎
↑</li>
			<li>
<p>
~IF［
%位置↗ ~EQ ❝T 
］：
</p>
				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
%M一義化子 ~SET `分t^i
</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
</li>
					<li>
~CONTINUE
</li>
				</ol>

<!-- 
T が複数個連続していても許容される
-->

◎
If the character in input pointed to by position is a U+0054 LATIN CAPITAL LETTER T character, then advance position to the next character, set M-disambiguator to minutes, skip ASCII whitespace within input given position, and continue.
</li>
			<li>
~IF［
%位置↗ ~NIN { `~ASCII数字$, ❝. }
］
⇒
~RET ε
◎
↓</li>
			<li>
%N ~LET %入力 内の %位置 から
`~ASCII数字$からなる`符号位置~並びを収集する$
◎
↓</li>
			<li>
%N ~SET `Base10$( %N )
◎
Set next character to the character in input pointed to by position.
• If next character is a U+002E FULL STOP character (.), then let N equal zero. (Do not advance position. That is taken care of below.)
• Otherwise, if next character is an ASCII digit, then collect a sequence of code points that are ASCII digits from input given position, interpret the resulting sequence as a base-ten integer, and let N be that number.
• Otherwise next character is not part of a number; fail.
• If position is past the end of input, then fail.
</li>
			<li>
<p>
~IF［
%位置↗ ~EQ ❝.
］：
◎
Set next character to the character in input pointed to by position, and this time advance position to the next character. (If next character was a U+002E FULL STOP character (.) before, it will still be that character this time.)
◎
If next character is U+002E (.), then:
</p>

				<ol>
					<li>
%位置 ~INCBY 1
</li>
					<li>
%s ~LET %入力 内の %位置 から`~ASCII数字$からなる`符号位置~並びを収集する$
◎
Collect a sequence of code points that are ASCII digits from input given position. Let s be the resulting sequence.
</li>
					<li>
~IF［
%s ~EQ 空~文字列
］
⇒
~RET ε
◎
If s is the empty string, then fail.
</li>
					<li>
%N ~INCBY `Frac10$( %s )
◎
Let length be the number of characters in s.
◎
Let fraction be the result of interpreting s as a base-ten integer, and then dividing that number by 10length.
◎
Increment N by fraction.
</li>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
					<li>
%s ~SET %位置↗
</li>
					<li>
%位置 ~INCBY 1
</li>
					<li>
~IF［
%s ~NIN { ❝S, ❝s }
］
⇒
~RET ε
◎
If position is past the end of input, then fail.
◎
Set next character to the character in input pointed to by position, and advance position to the next character.
◎
If next character is neither a U+0053 LATIN CAPITAL LETTER S character nor a U+0073 LATIN SMALL LETTER S character, then fail.
</li>
					<li>
%単位 ~SET `秒t^i
◎
Set units to seconds.
</li>
				</ol>

			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>

				<ol>
					<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
If next character is ASCII whitespace, then skip ASCII whitespace within input given position, set next character to the character in input pointed to by position, and advance position to the next character.
</li>
					<li>
<p>
( %単位, %縮尺, %M一義化子 ) ~SET 
%位置↗ に応じて，次の表で与えられる値：
</p>

<table>
<thead><tr><th>%位置↗
<th>%単位
<th>%縮尺
<th>%M一義化子
</thead>

<tbody><tr><td>❝Y, ❝y
<td>`年t^i
<td>ε
<td>`月t^i

<tr><td>❝M, ❝m
<td>%M一義化子
<td>60
<td>%M一義化子

<tr><td>❝W, ❝w
<td>`週t^i
<td>604800
<td>`分t^i

<tr><td>❝D, ❝d
<td>`日t^i
<td>86400
<td>`分t^i

<tr><td>❝H, ❝h
<td>`時t^i
<td>3600
<td>`分t^i

<tr><td>❝S, ❝s
<td>`秒t^i
<td>1
<td>`分t^i

<tr><td>その他
<td>ε
<td>ε
<td>ε

</tbody></table>

◎
If next character is a U+0059 LATIN CAPITAL LETTER Y character, or a U+0079 LATIN SMALL LETTER Y character, set units to years and set M-disambiguator to months.
◎
If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is months, then set units to months.
◎
If next character is a U+0057 LATIN CAPITAL LETTER W character or a U+0077 LATIN SMALL LETTER W character, set units to weeks and set M-disambiguator to minutes.
◎
If next character is a U+0044 LATIN CAPITAL LETTER D character or a U+0064 LATIN SMALL LETTER D character, set units to days and set M-disambiguator to minutes.
◎
If next character is a U+0048 LATIN CAPITAL LETTER H character or a U+0068 LATIN SMALL LETTER H character, set units to hours and set M-disambiguator to minutes.
◎
If next character is a U+004D LATIN CAPITAL LETTER M character or a U+006D LATIN SMALL LETTER M character, and M-disambiguator is minutes, then set units to minutes.
◎
If next character is a U+0053 LATIN CAPITAL LETTER S character or a U+0073 LATIN SMALL LETTER S character, set units to seconds and set M-disambiguator to minutes.
</li>
					<li>
%位置 ~INCBY 1
◎
↑</li>
					<li>
~IF［
%単位 ~EQ ε
］
⇒
~RET ε
◎
Otherwise if next character is none of the above characters, then fail.
</li>
				</ol>
			</li>
			<li>
%空 ~SET ~F
◎
Increment component count.
</li>
			<li>
<p>
%単位 に応じて：
</p>

<dl class="switch">
	<dt>`年t^i</dt>
	<dd>
%月t数 ~INCBY %N × 12
</dd>

	<dt>`月t^i</dt>
	<dd>
%月t数 ~INCBY %N
</dd>

	<dt>その他</dt>
	<dd>
%秒t数 ~INCBY %N × %縮尺
</dd>
</dl>

◎
Let multiplier be 1.
◎
If units is years, multiply multiplier by 12 and set units to months.
◎
If units is months, add the product of N and multiplier to months.
◎
Otherwise:
• If units is weeks, multiply multiplier by 7 and set units to days.
• If units is days, multiply multiplier by 24 and set units to hours.
• If units is hours, multiply multiplier by 60 and set units to minutes.
• If units is minutes, multiply multiplier by 60 and set units to seconds.
• Forcibly, units is now seconds. Add the product of N and multiplier to seconds.
</li>
			<li>
%入力 内の %位置 から`~ASCII空白を読飛ばす$
◎
Skip ASCII whitespace within input given position.
</li>
		</ol>
	</li>
	<li>
~IF［
%空 ~EQ ~T
］
⇒
~RET ε
◎
If component count is zero, fail.
</li>
	<li>
~IF［
%月t数 ~NEQ 0
］
⇒
~RET ε
◎
If months is not zero, fail.
</li>
	<li>
~RET `時間長$( %秒t数 )
◎
Return the duration consisting of seconds seconds.
</li>
</ol>


				</section>
				<section id="vaguer-moments-in-time">
<h4 title="Vaguer moments in time">2.3.5.10. 漠然とした時刻</h4>


<p class="trans-note">【
この節に与える定義を利用しているものは、［
`ins^e ／ `del^e
］要素の `datetime$a 属性しかない（特に， `time$e 要素の同名の属性には関わらない）。
】</p>

<p>
次のいずれかの文字列は、
`妥当な省略あり日時~文字列@
とされる：
◎
A string is a valid date string with optional time if it is also one of the following:
</p>

<ul>
	<li>
`妥当な日付~文字列$
◎
A valid date string
</li>
	<li>
`妥当な大域的~日時~文字列$
◎
A valid global date and time string
</li>
</ul>


<hr>

<p class="algo-head">
`省略あり日時~文字列を構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`日付$, `時刻$, `大域的~日時$, ε
］のいずれかを返す：
◎
The rules to parse a date or time string are as follows. The algorithm will return either a date, a time, a global date and time, or nothing. If at any point the algorithm says that it "fails", this means that it is aborted at that point and returns nothing.
</p>

<ol>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let input be the string being parsed.
◎
Let position be a pointer into input, initially pointing at the start of the string.
</li>
	<li>
%開始-位置- ~SET %位置 と同じ位置
◎
Set start position to the same position as position.
</li>
	<li>
%時刻 ~LET ε
◎
Set the date present and time present flags to true.
</li>
	<li>
%日付 ~LET `日付~成分を構文解析する$
◎
Parse a date component to obtain year, month, and day. If this fails, then set the date present flag to false.
</li>
	<li>
<p>
~IF［
%日付 ~EQ ε
］~OR［
%位置↗ ~IN { ❝T, `0020^U SPACE }
］：
</p>
		<ol>
			<li>
~IF［
%日付 ~EQ ε
］
⇒
%位置 ~SET %開始-位置
</li>
			<li>
~ELSE
⇒
%位置 ~INCBY 1
</li>
			<li>
%時刻 ~LET `時刻~成分を構文解析する$
</li>
			<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET ε
</li>
		</ol>
◎
If date present is true, and position is not beyond the end of input, and the character at position is either a U+0054 LATIN CAPITAL LETTER T character (T) or a U+0020 SPACE character, then advance position to the next character in input.
◎
Otherwise, if date present is true, and either position is beyond the end of input or the character at position is neither a U+0054 LATIN CAPITAL LETTER T character (T) nor a U+0020 SPACE character, then set time present to false.
◎
Otherwise, if date present is false, set position back to the same position as start position.
◎
If the time present flag is true, then parse a time component to obtain hour, minute, and second. If this returns nothing, then fail.
</li>
	<li>
<p>
~IF［
%日付 ~NEQ ε
］~AND［
%時刻 ~NEQ ε
］：
</p>
		<ol>
			<li>
%偏差 ~LET `偏差~成分を構文解析する$
</li>
			<li>
~IF［
%偏差 ~EQ ε
］
⇒
~RET ε
</li>
		</ol>
◎
If the date present and time present flags are both true, but position is beyond the end of input, then fail.
◎
If the date present and time present flags are both true, parse a time-zone offset component to obtain timezonehours and timezoneminutes. If this returns nothing, then fail.
</li>
	<li>
~IF［
%位置↗ ~NEQ ε
］
⇒
~RET ε
◎
If position is not beyond the end of input, then fail.
</li>
	<li>
~IF［
%時刻 ~EQ ε
］
⇒
~RET %日付
◎
If the date present flag is true and the time present flag is false, then let date be the date with year year, month month, and day day, and return date.
</li>
	<li>
~IF［
%日付 ~EQ ε
］
⇒
~RET %時刻
◎
Otherwise, if the time present flag is true and the date present flag is false, then let time be the time with hour hour, minute minute, and second second, and return time.
</li>
	<li>
( %日付, %時刻 ) ~LET ( %日付, %時刻 ) から %偏差 を減算した結果
◎
Otherwise, let time be the moment in time at year year, month month, day day, hours hour, minute minute, second second, subtracting timezonehours hours and timezoneminutes minutes, that moment in time being a moment in the UTC time zone;＼
</li>
	<li>
~RET `日時$( %日付, %時刻, %偏差 )
◎
let timezone be timezonehours hours and timezoneminutes minutes from UTC; and return time and timezone.
</li>
</ol>

				</section>
			</section>
			<section id="colors">
<h3 title="Colors">2.3.6. 色</h3>

<p class="trans-note">【
`旧来の色~値として構文解析する$を除き，この節に与える定義を利用しているものは、
`Color$st 状態にある `input$e 要素しかない。
】</p>

<p>
`単純~色@
は、3 個の［
範囲 { 0 〜 255 } に入る 8-bit 数
］からなり，順に sRGB 色~空間~内の色の
( ~red, ~green, ~blue )
成分を表現する。
`SRGB$r
◎
A simple color consists of three 8-bit numbers in the range 0..255, representing the red, green, and blue components of the color respectively, in the sRGB color space. [SRGB]
</p>

<p>
次の並びが成す文字列 %s は、
`妥当な単純~色@
とされる：
◎
A string is a valid simple color if it is exactly seven characters long, and＼
</p>

<ol>
	<li>
1 個の文字 ❝#
◎
the first character is a U+0023 NUMBER SIGN character (#), and＼
</li>
	<li>
6 個の`~ASCII~hex数字$並び
— この 6 文字を成す各 2 文字ずつが、順に，色の
( ~red, ~green, ~blue )
成分を~hex数字による整数で表現する。
◎
the remaining six characters are all ASCII hex digits, with the first two digits representing the red component, the middle two digits representing the green component, and the last two digits representing the blue component, in hexadecimal.
</li>
</ol>

<p>
次を満たす文字列は、
`妥当な小文字~単純~色@
とされる
⇒
［
`妥当な単純~色$である
］~AND［
範囲 { ❝A 〜 ❝F } に入る文字は含まれていない
］
◎
A string is a valid lowercase simple color if it is a valid simple color and doesn't use any characters in the range U+0041 LATIN CAPITAL LETTER A to U+0046 LATIN CAPITAL LETTER F.
</p>


<p class="algo-head">
`単純~色として構文解析する@
規則は、所与の
( 文字列 %入力 )
に対し，［
`単純~色$, ~error
］のいずれかを返す：
◎
The rules for parsing simple color values are as given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a simple color or an error.
</p>

<ol>
	<li>
~IF［
%入力 は`妥当な単純~色$でない
］
⇒
~RET ~error
◎
Let input be the string being parsed.
◎
If input is not exactly seven characters long, then return an error.
◎
If the first character in input is not a U+0023 NUMBER SIGN character (#), then return an error.
◎
If the last six characters of input are not all ASCII hex digits, then return an error.
</li>
	<li>
~RET %入力 の
( 2 〜 3 個目, 4 〜 5 個目, 6 〜 7 個目 )
の各 文字~並びを，順に~hex数字~列として整数に解釈した結果を
( ~red, ~green, ~blue )
成分とする`単純~色$
◎
Let result be a simple color.
◎
Interpret the second and third characters as a hexadecimal number and let the result be the red component of result.
◎
Interpret the fourth and fifth characters as a hexadecimal number and let the result be the green component of result.
◎
Interpret the sixth and seventh characters as a hexadecimal number and let the result be the blue component of result.
◎
Return result.
</li>
</ol>

<p class="algo-head">
`単純~色を直列化する@
規則は、所与の
( `単純~色$ %C )
に対し，`妥当な小文字~単純~色$を返す：
◎
The rules for serializing simple color values given a simple color are as given in the following algorithm:
</p>

<ol>
	<li>
%結果 ~LET
1 個の ❝# からなる文字列
◎
Let result be a string consisting of a single U+0023 NUMBER SIGN character (#).
</li>
	<li>
%C 内の~EACH ( 成分 %成分 ) に対し，［
~red, ~green, ~blue
］の順に
⇒
%結果 に［
%成分 を［
2 個の~hex数字
］に変換した結果
］を付加する
— ここで、数字には`~ASCII~hex数字（小文字）$を利用し，必要なら先頭に~zeroを付け加えるとする。
◎
Convert the red, green, and blue components in turn to two-digit hexadecimal numbers using ASCII lower hex digits, zero-padding if necessary, and append these numbers to result, in the order red, green, blue.
</li>
	<li>
~RET %結果
◎
Return result, which will be a valid lowercase simple color.
</li>
</ol>

<hr>

<p class="algo-head">
一部の廃用にされた旧来の属性は、色を構文解析するときに，より混み入った
`旧来の色~値として構文解析する@
規則を利用する。
それは，次の~algoで与えられ、所与の文字列 %入力 に対し［
`単純~色$, ~error
］のいずれかを返す：
◎
Some obsolete legacy attributes parse colors in a more complicated manner, using the rules for parsing a legacy color value, which are given in the following algorithm. When invoked, the steps must be followed in the order given, aborting at the first step that returns a value. This algorithm will return either a simple color or an error.
</p>

<ol>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
~RET ~error
◎
Let input be the string being parsed.
◎
If input is the empty string, then return an error.
</li>
	<li>
%入力 ~SET `前後の~ASCII空白~列を剥ぐ$( %入力 )
◎
Strip leading and trailing ASCII whitespace from input.
</li>
	<li>
~IF［
%入力 ~EQ`~ACI$ `transparent^l
］
⇒
~RET ~error
◎
If input is an ASCII case-insensitive match for the string "transparent", then return an error.
</li>
	<li>

<p>
~IF［
%入力 ~IN`~ACI$ { `有名~色$ }
］
⇒
~RET %入力 が与える~keywordに対応する`単純~色$
`CSSCOLOR$r
◎
If input is an ASCII case-insensitive match for one of the named colors, then return the simple color corresponding to that keyword. [CSSCOLOR]
</p>

<p class="note">注記：
<a href="~TR/css3-color/#css2-system">CSS2 による~system色</a>
は認識されない。
<!-- ~CSSCOLOR#system-colors -->
◎
CSS2 System Colors are not recognized.
</p>
	</li>
	<li>
<p>
~IF［
%入力 は［
❝#, 3 個の`~ASCII~hex数字$
］の並びである
］
⇒
~RET 次のようにされた`単純~色$
⇒
( ~red, ~green, ~blue )
成分 ~SET 順に，
%入力 の (2, 3, 4) 個目の文字を［
(~hex数字として整数に解釈した結果 ) × 17
］
◎
If input is four characters long, and the first character in input is U+0023 (#), and the last three characters of input are all ASCII hex digits, then:
• Let result be a simple color.
• Interpret the second character of input as a hexadecimal digit; let the red component of result be the resulting number multiplied by 17.
• Interpret the third character of input as a hexadecimal digit; let the green component of result be the resulting number multiplied by 17.
• Interpret the fourth character of input as a hexadecimal digit; let the blue component of result be the resulting number multiplied by 17.
• Return result.
</li>
	<li>
%入力 内の `FFFF^U を超える符号位置（すなわち，基本多言語面に含まれない文字）すべてを `00^l に置換する
◎
Replace any characters in input that have a code point greater than U+FFFF (i.e., any characters that are not in the basic multilingual plane) with the two-character string "00".
</li>
	<li>
%入力 ~SET %入力 の最初の 128 文字までの文字列
◎
If input is longer than 128 characters, truncate input, leaving only the first 128 characters.
</li>
	<li>
~IF［
%入力 の最初の文字 ~EQ ❝#
］
⇒
%入力 から最初の文字を除去する
◎
If the first character in input is a U+0023 NUMBER SIGN character (#), remove it.
</li>
	<li>
%入力 内の非`~ASCII~hex数字$はすべて ❝0 に置換する
◎
Replace any character in input that is not an ASCII hex digit with the character U+0030 DIGIT ZERO (0).
</li>
	<li>
~IF［
%入力 ~EQ 空~文字列
］
⇒
%入力 ~SET `000^l
◎
↓</li>
	<li>
%L ~LET ［
%入力 を成す文字~数 ~DIV 3
］を整数に切り上げた結果
◎
↓</li>
	<li>
%入力 に［
%L ~MUL 3 ~MINUS %入力 を成す文字~数
］個の  ❝0 を付加する
◎
While input's length is zero or not a multiple of three, append a U+0030 DIGIT ZERO (0) character to input.
</li>
	<li>
( %R, %G, %B ) ~LET 順に， %入力 の
( 最初の %L 個, 次の %L 個, 最後の %L 個 )
の文字からなる文字列
◎
Split input into three strings of equal length, to obtain three components. Let length be the length of those components (one third the length of input).
</li>
	<li>
<p>
~IF［
%L ~GT 8
］
</p>
		<ol>
			<li>
( %R, %G, %B ) を成す ~EACH( %成分 ) を次の結果に置換する
⇒
%成分 から頭部の ( %L ~MINUS 8 ) 個の文字を除去する
</li>
			<li>
%L ~SET 8
</li>
		</ol>
◎
If length is greater than 8, then remove the leading length-8 characters in each component, and let length be 8.
</li>
	<li>
<p>
~WHILE ［
%L ~GT 2
］~AND［
( %R, %G, %B ) の最初の文字はいずれも ~EQ ❝0
］：
</p>
		<ol>
			<li>
( %R, %G, %B ) を成す ~EACH( %成分 ) を次の結果に置換する
⇒
%成分 から最初の文字を除去する
</li>
			<li>
%L ~DECBY 1
</li>
		</ol>
◎
While length is greater than two and the first character in each component is a U+0030 DIGIT ZERO (0) character, remove that character and reduce length by one.
</li>
	<li>
~IF［
%L ~GT 2
］
⇒
( %R, %G, %B ) を成す ~EACH( %成分 ) を次の結果に置換する
⇒
%成分 の先頭から 2 個の文字が成す文字列
◎
If length is still greater than two, truncate each component, leaving only the first two characters in each.
</li>
	<li>
~RET 次のようにされた`単純~色$
⇒
( ~red, ~green, ~blue )
成分 ~SET 順に，
( %R, %G, %B ) を~hex数字~列として整数に解釈した結果
◎
Let result be a simple color.
◎
Interpret the first component as a hexadecimal number; let the red component of result be the resulting number.
◎
Interpret the second component as a hexadecimal number; let the green component of result be the resulting number.
◎
Interpret the third component as a hexadecimal number; let the blue component of result be the resulting number.
◎
Return result.
</li>
</ol>


<hr>

<p class="note">注記：
<a href="~HEcanvas#canvas-context-2d">2D ~graphics文脈</a>
は、不透明度も取扱う別々の色~構文を有する。
◎
The 2D graphics context has a separate color syntax that also handles opacity.
</p>


			</section>
			<section id="space-separated-tokens">
<h3 title="Space-separated tokens">2.3.7. 空白区切りの~token列</h3>

<p>
`空白区切りの~token集合@
とは、［
1 個以上の`~ASCII空白$並び
］で互いに区切られた， 0 個以上の~tokenからなる文字列である
— ここでの~tokenとは、次を満たす~~任意の文字列とする
⇒
［
空でない
］~AND［
どの文字も`~ASCII空白$でない
］
◎
A set of space-separated tokens is a string containing zero or more words (known as tokens) separated by one or more ASCII whitespace, where words consist of any string of one or more characters, none of which are ASCII whitespace.
</p>

<p>
`空白区切りの~token集合$は：
◎
↓</p>

<ul>
	<li>
［
頭部／尾部
］に`~ASCII空白$並びがあってもよい。
◎
A string containing a set of space-separated tokens may have leading or trailing ASCII whitespace.
</li>
	<li>
その中の どの~tokenも重複していないならば、
`空白区切りの一意な~tokenからなる無順序~集合@
という。
◎
An unordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated.
</li>
	<li>
その中の どの~tokenも重複していない, かつ
順序も有意義とされるならば、
`空白区切りの一意な~tokenからなる有順序~集合@
という。
【この定義は、作者~向けの要件（構文）に加えて，~UA向けの要件（順序を保つこと）も含ませている。】
◎
An ordered set of unique space-separated tokens is a set of space-separated tokens where none of the tokens are duplicated but where the order of the tokens is meaningful.
</li>
	<li>
文脈によっては、許容される~tokenの集合が定義されることもある。
そのような場合、どの~tokenも，この集合に入ってい~MUST
— さもなければ、値は非~適合とされる。
そのような集合が特に供されていない場合、どの~tokenも適合することになる。
◎
Sets of space-separated tokens sometimes have a defined set of allowed values. When a set of allowed values is defined, the tokens must all be from that list of allowed values; other values are non-conforming. If no such set of allowed values is provided, then all values are conforming.
</li>
</ul>

<p class="note">注記：
`空白区切りの~token集合$内の各~tokenを比較する方法（文字大小区別かどうかなど）は、~token集合ごとに定義される。
◎
How tokens in a set of space-separated tokens are to be compared (e.g. case-sensitively or not) is defined on a per-set basis.
</p>

			</section>
			<section id="comma-separated-tokens">
<h3 title="Comma-separated tokens">2.3.8. ~comma区切りの~token列</h3>

<p>
`~comma区切りの~token集合@
とは、［
1 個の ❝,
］で互いに区切られた， 0 個以上の［
次を満たす~~任意の文字列（ “前後~空白~可の~token” ）
］である
⇒
`前後の~ASCII空白~列を剥ぐ$( 文字列 )
の結果（ “~token” ）を成すどの文字も ❝, でない
◎
A set of comma-separated tokens is a string containing zero or more tokens each separated from the next by a single U+002C COMMA character (,), where tokens consist of any string of zero or more characters, neither beginning nor ending with ASCII whitespace, nor containing any U+002C COMMA characters (,), and optionally surrounded by ASCII whitespace.
</p>

<p class="trans-note">【
ここでは、 “前後の~ASCII空白~列を剥ぐ” を利用して，原文による定義を等価に簡約している。
】</p>


<p class="example">
具体的には、文字列 
` a ,b,,d d ^l
は、 4 個の~token［
`a^l, `b^l, 空~文字列, `d d^l
］からなる。
各~tokenの［
頭部／尾部
］の空白は、~tokenの一部をなさず，空~文字列も~tokenとされる。
◎
For instance, the string " a ,b,,d d " consists of four tokens: "a", "b", the empty string, and "d d". Leading and trailing whitespace around each token doesn't count as part of the token, and the empty string can be a token.
</p>

<p>
`~comma区切りの~token集合$には、何が妥当な~tokenを成すかについて，更なる制約が~~課されることもあり、その場合の各~tokenはその制約を満たさ~MUST。
さもなければ、値は非~適合とされる。
<!-- ＊
制約が指定されていなければ，すべての値適合。
 -->
◎
Sets of comma-separated tokens sometimes have further restrictions on what consists a valid token. When such restrictions are defined, the tokens must all fit within those restrictions; other values are non-conforming. If no such restrictions are specified, then all values are conforming.
</p>

			</section>
			<section id="syntax-references">
<h3 title="References">2.3.9. 参照</h3>

<p class="trans-note">【
この節に与える定義を利用しているものは、［
`img^e ／ `object^e
］要素の `usemap$a 属性しかない。
】</p>

<div class="p">
<p>
次の並びからなる文字列は、`要素~型$ %型 の要素への
`妥当な~hash名~参照@
とされる：
</p>

<ol>
	<li>
❝#
</li>
	<li>
次を満たすような，ある要素 %要素 の `name^a 属性の値
⇒
［
%要素 は【所与の文字列を与えている属性を有する要素と】同じ`木$内にある
］~AND［
%要素 の`要素~型$ ~EQ %型
］~AND［
%要素 は `name^a 属性を有する
］
</li>
</ol>

◎
A valid hash-name reference to an element of type type is a string consisting of a U+0023 NUMBER SIGN character (#) followed by a string which exactly matches the value of the name attribute of an element with type type in the same tree.
</div>

<p class="algo-head">
`要素~型$ %型 を指す
`~hash名~参照として構文解析する@
規則は、所与の
( 文字列 %入力, 文脈~node %視野 )
に対し，次に従う：
◎
The rules for parsing a hash-name reference to an element of type type, given a context node scope, are as follows:
</p>

<ol>
	<li>
~IF［
%入力 内に ❝# はない
］
⇒
~RET ~NULL
◎
If the string being parsed does not contain a U+0023 NUMBER SIGN character, or＼
</li>
	<li>
%~hash ~LET %入力 内の最初の ❝# より後の文字すべてからなる文字列
◎
＼
</li>
	<li>
~IF［
%~hash ~EQ 空~文字列
］
⇒
~RET ~NULL
◎
if the first such character in the string is the last character in the string, then return null.
◎
Let s be the string from the character immediately after the first U+0023 NUMBER SIGN character in the string being parsed up to the end of that string.
</li>
	<li>
<div class="p">
<p>
~RET ［
%視野 を根とする木
］内に次の両者とも満たす要素は［
在るならば それらのうち `木~順序$で最初のもの ／
無いならば ~NULL
］：
</p>

<ul ><li>`要素~型$ ~EQ %型
</li><li>%~hash ~IN { 要素の `id$a 属性~値, 要素の `name^a 属性~値 }
</li></ul>

◎
Return the first element of type type in scope's tree, in tree order, that has an id or name attribute whose value is s, or null if there is no such element.
</div>

<p class="note">注記：
`id$a 属性は、構文解析-時には織り込まれるが，その値が`妥当な~hash名~参照$かどうか決定するときには利用されない。
すなわち， `id$a 属性に基づいて要素を指すような~hash名~参照は、（その要素が同じ値をとる `name^a 属性も有していない限り）適合性~errorとされる。
◎
Although id attributes are accounted for when parsing, they are not used in determining whether a value is a valid hash-name reference. That is, a hash-name reference that refers to an element based on id is a conformance error (unless that element also has a name attribute with the same value).
</p>
	</li>
</ol>


			</section>
			<section id="mq">
<h3 title="Media queries">2.3.10. 媒体~query</h3>

<p>
Media Queries 仕様 `MQ$r の
`&lt;media-query-list&gt;$t
生成規則に合致する文字列は
`妥当な媒体~query~list@
とされる。
◎
A string is a valid media query list if it matches the &lt;media-query-list&gt; production of the Media Queries specification. [MQ]
</p>

<div class="p">
<p>
次のいずれかに該当する文字列は、
`利用者の環境に合致して@
いるとされる：
</p>

<ul ><li>0 個以上の`~ASCII空白$のみからなる文字列
</li><li>Media Queries 仕様による定義に則って，利用者の環境に合致している 媒体~query~list
</li>
</ul>

◎
A string matches the environment of the user if it is the empty string, a string consisting of only ASCII whitespace, or is a media query list that matches the user's environment according to the definitions given in the Media Queries specification. [MQ]
</div>

			</section>
		</section>
</main>

