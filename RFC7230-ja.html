<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 7230 — HTTP/1.1: Message Syntax and Routing （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<script src="common0.js"></script>
<script src="RFC723X.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">

●●options

spec_title:RFC 7230 — HTTP/1.1: Message Syntax and Routing
trans_update:2018-05-19
page_state_key:HTTP
original_url:https://httpwg.org/specs/rfc7230.html
spec_status:IETFPR
abbr_url:7230
no_original_dfn:true
trans_1st_pub:2014-12-07

●●mdn_urls
header.transfer-encoding:HTTP/Headers/Transfer-Encoding
header.content-length:HTTP/Headers/Content-Length
header.te:HTTP/Headers/TE
header.trailer:HTTP/Headers/Trailer
header.host:HTTP/Headers/Host
header.via:HTTP/Headers/Via
header.connection:HTTP/Headers/Connection
header.upgrade:HTTP/Headers/Upgrade
	header.close:HTTP/Headers/Close
compatibility.with.http.1.0.persistent.connections:HTTP/Headers/Keep-Alive
	header.keep-alive:HTTP/Headers/Keep-Alive

●●link_map

wc.214:~7234#warn.214

c.trailers:#trailers-token
c.http:#http.uri
c.https:#https.uri
c.keep-alive:#compatibility.with.http.1.0.persistent.connections

	p.example-list
	p.example-list-elmt
	P.VT
	P.FF
	P.NUL

~trailer節:#trailer
~trailer~field:#trailer-field
要請の改変子:~7231#request.header.fields
接続:#connection
参加者:#participant
役割:#role
	権限:#p.authority
権限的:#authoritative
権限的~応答:#authoritative
応答待ち要請:#outstanding-request
~cache可能:#cacheable
~cache:#cache
空~行l:#empty-line
	既定の~TCP~port
	dir.no-transform:~7234#section-5.2.1.6／

	`reserved＊3986#section-2.2
	userinfo:3986#section-3.2.1
	絶対~形:#section-5.3.2
	正規の形
	却下-:#conformance


●●section_map


1:introduction
1.1:intro.requirements
1.2:notation
2:architecture
2.1:operation
2.2:implementation-diversity
2.3:intermediaries
2.4:caches
2.5:conformance
2.6:http.version
2.7:uri
2.7.1:http.uri
2.7.2:https.uri
2.7.3:uri.comparison
3:http.message
3.1:start.line
3.1.1:request.line
3.1.2:status.line
3.2:header.fields
3.2.1:field.extensibility
3.2.2:field.order
3.2.3:whitespace
3.2.4:field.parsing
3.2.5:field.limits
3.2.6:field.components
3.3:message.body
3.3.1:header.transfer-encoding
3.3.2:header.content-length
3.3.3:message.body.length
3.4:incomplete.messages
3.5:message.robustness
4:transfer.codings
4.1:chunked.encoding
4.1.1:chunked.extension
4.1.2:chunked.trailer.part
4.1.3:decoding.chunked
4.2:compression.codings
4.2.1:compress.coding
4.2.2:deflate.coding
4.2.3:gzip.coding
4.3:header.te
4.4:header.trailer
5:message.routing
5.1:target-resource
5.2:connecting.inbound
5.3:request-target
5.3.1:origin-form
5.3.2:absolute-form
5.3.3:authority-form
5.3.4:asterisk-form
5.4:header.host
5.5:effective.request.uri
5.6:associating.response.to.request
5.7:message.forwarding
5.7.1:header.via
5.7.2:message.transformations
6:connection.management
6.1:header.connection
6.2:persistent.establishment
6.3:persistent.connections
6.3.1:persistent.retrying.requests
6.3.2:pipelining
6.4:persistent.concurrency
6.5:persistent.failures
6.6:persistent.tear-down
6.7:header.upgrade
7:abnf.extension
8:IANA.considerations
8.1:header.field.registration
8.2:uri.scheme.registration
8.3:internet.media.type.http
8.3.1:internet.media.type.message.http
8.3.2:internet.media.type.application.http
8.4:transfer.coding.registry
8.4.1:transfer.coding.registry.procedure
8.4.2:transfer.coding.registration
8.5:content.coding.registration
8.6:upgrade.token.registry
8.6.1:upgrade.token.registry.procedure
8.6.2:upgrade.token.registration
9:security.considerations
9.1:establishing.authority
9.2:risks.intermediaries
9.3:attack.protocol.element.length
9.4:response.splitting
9.5:request.smuggling
9.6:message.integrity
9.7:message.confidentiality
9.8:privacy.of.server.log.information
10:acks
11:rfc.references
A:compatibility
A.1:changes.from.1.0
A.1.1:changes.to.simplify.multihomed.web.servers.and.conserve.ip.addresses
A.1.2:compatibility.with.http.1.0.persistent.connections
A.1.3:introduction.of.transfer-encoding
A.2:changes.from.rfc.2616
B:collected.abnf


●●words_table1
	HTTP11: <a href="#version-1.1">HTTP/1.1</a> 
HTTP1x: HTTP/1.x 
smith:~smith


●●words_table


UNIX:
US-ASCII:
IP:
DNS:
critical:
黙って:silentに:~
intercept:
interception:
multihomed:
annotation:
captive:
social:
subscription:
randomization:
	long polling
エスケープ:quote::~
command-line::::コマンドライン
off-line::::オフライン
multibyte::::マルチバイト
multicast::::マルチキャスト
broadcast::::ブロードキャスト
overflow::::オーバーフロー
phishing::::フィッシング
routine::::ルーチン
	誤りのあるfaulty:
加速器:accelerator::~::アクセラレータ
background::::バックグラウンド
hung::::ハング
malware::::マルウェア
pipe::::パイプ
pipeline::::パイプライン
superset::::拡張集合:スーパーセット
worldwide:
digital::::デジタル
point::::ポイント
scale::::スケール
	~scale能:scalability

流れる:flowする:~
正規の:normal::~
正規:normal::~
完全修飾:fully qualified::~
発展-:evolve:~
区割り:partitioning:~
空白列:linear whitespace::~

大陸間:transoceanic:~
復唱:echo:~
科学的:scientific:~
終了子:terminator::~::ターミネータ
縮約-:collapse:~
医療:medical:~
薬剤相互作用:drug interaction:薬の飲み合わせ
解体:tear-down:~
解凍:decompression:~
分析:analysis:~
知覚:perception:~
知覚-:perceive:~
誤誘導:mislead:~
調べて:surveyして:~
販促:promotional:~
迂回-:bypass:~
ピリオド:period::~

入力用:incoming:~

公正な:fair:~

負荷分散-:load balance:~
負荷分散:load balancing:~
匿名化:anonymization:~
単線:linear:~
印字可能:visual:~
危険:dangerous:~
場当的:ad hoc:場当たり的
幾千:thousands:~
急増:proliferation:~
疑似匿名:pseudonymous:~
規制:regulations:~
参照先の:referring:~
不整合:inconsistency:~
一対一:one-to-one:~
相互通信:interaction::~
画像処理:imaging:~
決定的:critical:~
再整形:reformatting:~
確認-:confirm:~
確認:confirmation:~
	読み易くreadability を improve
丸括弧:parentheses:~
順位:rank:~
被害:damage:~
良実践:good practice:良い実践
細工:craft:~
高遅延:high-latency:~
自動訂正:autocorrect:~
普及-:prevalent:~
密入:smuggling:~
切落して:truncateして:切り落として
法律:laws:~
正当化:justify:~
混雑-:congest:~
混雑:congestion:~
真正性:authenticity::~
隣接点:neighbor::~
厳格:stringent:~
制限時間:timeout::~
変名:variation:~
免除-:exempt:~
仮の:hypothetical:~
統制:control:~
単一の:single:~
非公開の:non-public:~
付番方式:numbering scheme:~
小数点:decimal point:~
後続-:follow:~
同時並行性:concurrency:~
招く:inviteする:~
巡る:crawlする:~
無分別:unwise:~
行動様式:reading pattern:~
関心事:subjects of interest:~
不特定多数の:multitude:~
銘柄:branding:~
流出:publish:~

家電:household appliance:~
	home appliance
firmware::::ファームウェア
視聴覚機器:stereo::~
計測機器:scale:~
交通camera:traffic camera:交通カメラ
住宅用自動化設備:home automation unit:~
事務機械:office machine:OA 機器
自律型robot:autonomous robot:自律型ロボット
ニュースフィード:news feed:~
	ad selectors:
動画配信:video-delivery::動画配信::ビデオ配信
携帯:mobile::~::モバイル
形状:shape:~

trace:::追跡
因子:factor:~
	求まれてない:unwanted
確立法:establishment::~
	~~外部:outside
無視r:disregard:無視することに
審査:examination:~
不法な:bogus:~
中間:intermediation:~
仮想:virtual::~
保って:keepして:~
確約-:assure:~
濫用的:abusive:~
動詞:verb:~
国別:national:~
破損-:corrupt:~
寛容:lenient:~
悪化-:exacerbate:~
意向:intention:意図
本物の:realな:~
梱包:packaging:~
稼働時:run-time:~
再符号され:recode::符号し直され::コードし直され
集めら:gatherさ:~
解決s:solve:解決
指向な:-oriented:指向の
古代の:ancientな:~
改訂履歴:revision::~
不用意:accidental:~
必要最小限:minimal:~
書込n:write::書き込み
書込め:writeでき::書き込め
適応的:adaptive:~
隠蔽-:obscure:~
見合う:reasonableな:~
実効性:effectiveness:~
取戻せ:reclaimでき:取り戻せ
策:strategy:~
権利:right:~
防御策:defense:~
連合-:federate:~
一掃-:purge:~
促進-:promote:~
強要-:insist:~
多様:diverse:~
多様性:diversity:~
個人識別可能:personally identifiable:~
企業:corporate:~
頻繁:frequent:~
算術的:arithmetic:~
過程:process:~
符号変換:transcoding::~::トランスコーディング
符号変換器:transcoder::~::トランスコーダ
責任-:responsible::~
到着-:arrive:~
連絡:contact:~
応答待ち:outstanding::~
変更s:changes:変更
外向けの:outgoing:~
移行:transition::~
数的:numeric:~
数字列:numerals:~
発行-:issue:~

●●
~web~site:website
多量ではない:not so much 
回復-不能:unrecoverable
圧縮-済み:compressed
符号化-済み:encoded
運用~上の:operational
虚偽:false
~~事前の:advance
直の:immediate
~~直に~code化:hard-coded
恒久的に居残る:stays forever
窓口:point of
サイズや形状が様々な:in a multitude of shapes and sizes
全てintact
:notion
:escaping
:concatenating
:concatenate
時点:at time
いわゆる:a.k.a.
~~全体:whole
そのようなわけで:as such
~~参照:refer
通り抜けられるようにする:satisfy〜through
またがって:across して
またがる:across する
余儀なくされ:necessitated
1 個以上の:(s)
長過ぎる:too long
head-of-line blocking
:auditing
:fraud control
〜されたなら、／一度:once
以上の~version:or later
誰も:anyone
見え難い:obscure
もたらす／:cause
締めくくる:conclude
いくらでも:full
適度に~~確信できた:reasonably certain
機会:chance／
好機:opportunity
読み易く:consistent readability
引換え:commission:引き換え
自身から見て予見される:believe
何種類かの:some type(s)
見せかけ:look like／apparent
重い処理を要する:takes significant 〜 processing
~~適用する:target
その場その場:on the fly
~~閉じた:closed
なり得る:potential
~~供する:serveする
一連の:sequence
欠けている:missing
`DQUOTE$P :double-quote ~mark
定める:label
:own unique
~via:〜を通して／介して／挟む
~~全般:overall
見込まれる:potential
~~領域:space
他にアテガって:reassign
視る:view
称され:refer
まちまち:varying ways
周知:commonly known
受け持つ:partake
多岐に渡る:vary widely
変遷:changed over the course of
変わり続け:continue changing
long polling
message回送:message-forwarding
travel:渡り歩く
遡行する
unsecured
version付け:versioning
最下~層のものから昇順に:layer-ascending order
長過ぎる:too long
資質からして:in natureに
補強:aid
目立つ様に:prominently
繋がる:becomes an avenue
長大:very long
~~恒久的:forever
~~余計な:extraneous
~~上限:ceiling
再~識別-:re-identified
acceptableでない:unacceptable
信用に価する:trustworthy
目を向け:regard
~direct:at the direction of

●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により PROPOSED STANDARD として公表された，
RFC 7230
<a href="~SPEC_URL">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

公表者
	Internet Engineering Task Force (IETF)
RFC
	7230
分類
	Standards Track
廃用
	<a href="https://www.rfc-editor.org/rfc/rfc2145">RFC 2145</a>, <a href="https://www.rfc-editor.org/rfc/rfc2616">RFC 2616</a>
更新
	<a href="https://www.rfc-editor.org/rfc/rfc2817">RFC 2817</a>, <a href="https://www.rfc-editor.org/rfc/rfc2818">RFC 2818</a>
ISSN
	2070-1721
編集
	R. Fielding, Adobe;
	J. Reschke, greenbytes
日付
	2014 年 6 月
現在の位置付け, 正誤表, フィードバックの方法
	https://www.rfc-editor.org/info/rfc7230

</script>


</head>
<body>

<header>
	<hgroup>
<h1><abbr title="Hypertext Transfer Protocol (version 1.1)">HTTP/1.1</abbr>： メッセージの構文と経路制御</h1>
<h2>RFC 7230, Message Syntax and Routing</h2>
	</hgroup>

</header>

<div id="MAIN" hidden>
	<section>
~ABSTRACT

<div class="p">
<p>
~HTTP（ Hypertext Transfer Protocol ）は、分散型の協調的な~hypertext情報~system用の、`~stateless$な~app~levelの~protocolである。
この文書は、次について述べる：
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document＼
</p>

<ul>
	<li>
~HTTP~architectureとそれに結付けられる各種用語の概観を供する。
◎
provides an overview of HTTP architecture and its associated terminology,＼
</li>
	<li>
~URI （ Uniform Resource Identifier ）の `scheme$p として， "`http$c" と "`https$c" 
を定義する。
◎
defines the "http" and "https" Uniform Resource Identifier (URI) schemes,＼
</li>
	<li>
`~HTTP11$~message構文, および構文解析の要件を定義する。
◎
defines the HTTP/1.1 message syntax and parsing requirements, and＼
</li>
	<li>
実装に関係する~securityの懸念を述べる。
◎
describes related security concerns for implementations.
</li>
</ul>
</div>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status$に移譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="section-1">
<h2 title="Introduction">1. 序論</h2>

<p>
Hypertext Transfer Protocol（ HTTP ）は、［
~network~based，~hypertext情報~system
］における柔軟な相互通信~用の［
拡張-可能な意味論, および
自己-記述的な~message`~payload$
］を利用する，`~stateless$な~app~levelの［
要請, 応答
］~protocolである。
この文書は、［
`~HTTP11$仕様を総集的に形成する一連の文書
］のうち，~~最初のものである：
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information systems. This document is the first in a series of documents that collectively form the HTTP/1.1 specification:
</p>

<ol>
	<li>
~messageの構文と経路制御
— "Message Syntax and Routing" （この文書）
</li>
	<li>
`意味論と内容＠~7231$
— "Semantics and Content" `7231$R
</li>
	<li>
`条件付き要請＠~7232$
— "Conditional Requests" `7232$R
</li>
	<li>
`範囲~要請＠~7233$
— "Range Requests" `7233$R
</li>
	<li>
`~caching＠~7234$
— "Caching" `7234$R
</li>
	<li>
`認証＠~7235$
— "Authentication" `7235$R
</li>
</ol>

<p>
この`~HTTP11$仕様は、
`2616$R, `2145$R
を廃用にする（~HTTP~version付けにおいて）。
この仕様はまた、以前に
`2817$R にて定義された［
~tunnelを確立するための `CONNECT$m の利用
］を更新し，
`2818$R にて非正式に述べられていた［
"`https$c" ~URI~scheme
］を定義する。
◎
This HTTP/1.1 specification obsoletes RFC 2616 and RFC 2145 (on HTTP versioning). This specification also updates the use of CONNECT to establish a tunnel, previously defined in RFC 2817, and defines the "https" URI scheme that was described informally in RFC 2818.
</p>

<p>
~HTTPは、情報~system用の汎用~interface~protocolである。
それは、［
供される資源の型に依存しない，`~client$向けの統一的~interface
］を提示することにより，［
~serviceがどのように実装されるか，についての詳細
］は隠すように設計されている。
同様に `~server$も，各~clientの目的について意識する必要はない：
~HTTP要請は、［
特定の型の~clientや,
予め決定された手続きを適用すること
］に結付けられずに，他から隔離して考慮できる。
その結果、多くの異なる文脈~下で ~protocolを効果的に利用でき、実装も，それらの文脈から独立に発展できるようになる。
◎
HTTP is a generic interface protocol for information systems. It is designed to hide the details of how a service is implemented by presenting a uniform interface to clients that is independent of the types of resources provided. Likewise, servers do not need to be aware of each client's purpose: an HTTP request can be considered in isolation rather than being associated with a specific type of client or a predetermined sequence of application steps. The result is a protocol that can be used effectively in many different contexts and for which implementations can evolve independently over time.
</p>

<p>
~HTTPは、［
非~HTTP情報~systemとの間で 互いの通信を翻訳するための，中間~protocol
］としての利用も念頭に，設計されてもいる。
~HTTP `~proxy$／`~gateway$は、それらの多様な~protocolを［
`~client$により ~HTTP~serviceと同じ仕方で視て操作できるような，~hypertext形式
］に翻訳することにより，代替~情報~serviceへの~accessを供せる。
◎
HTTP is also designed for use as an intermediation protocol for translating communication to and from non-HTTP information systems. HTTP proxies and gateways can provide access to alternative information services by translating their diverse protocols into a hypertext format that can be viewed and manipulated by clients in the same way as HTTP services.
</p>

<div class="p">
<p>
この柔軟性による帰結の一つは、~interfaceの背後で生じるものからは，~protocolを定義し得ないことである。
代わりに，次を定義することに制限される：
◎
One consequence of this flexibility is that the protocol cannot be defined in terms of what occurs behind the interface. Instead, we are limited to defining＼
</p>

<ul>
	<li>
通信の構文
◎
the syntax of communication,＼
</li>
	<li>
受信される通信の意図
◎
the intent of received communication, and＼
</li>
	<li>
受信者に期待される挙動
◎
the expected behavior of recipients.＼
</li>
</ul>

<p>
各~通信を他から隔離して考慮するならば、成功裡に終わる動作に対応する変化は，`~server$が供する観測-可能な~interfaceを通して反映される~OUGHT。
しかしながら、複数の~clientが，並列的かつ~~大体は違う目的で動作するであろうから、そのような変化が［
単独の応答の視野を超えて観測-可能になる
］ことは要求できない。
◎
If the communication is considered in isolation, then successful actions ought to be reflected in corresponding changes to the observable interface provided by servers. However, since multiple clients might act in parallel and perhaps at cross-purposes, we cannot require that such changes be observable beyond the scope of a single response.
</p>
</div>

<p>
この文書は、~HTTPにて［
利用される／~~参照される
］~architecture上の要素について述べ，［
"`http$c", "`https$c"
］~URI~schemeを定義する。
また、［
~network運用, 接続の管理
］の~~全般について述べ，~HTTP ~messageの［
~frame法, 回送-法
］に課される要件を定義する。
その目標は、［
~HTTP~messageの取扱いに必要とされ, ~message意味論には依存しない
］ような，すべての仕組みを定義し、それにより，［
~message構文解析器, ~message回送~中継者
］に課される要件の 完全な集合を定義することである。
◎
This document describes the architectural elements that are used or referred to in HTTP, defines the "http" and "https" URI schemes, describes overall network operation and connection management, and defines HTTP message framing and forwarding requirements. Our goal is to define all of the mechanisms necessary for HTTP message handling that are independent of message semantics, thereby defining the complete set of requirements for message parsers and message-forwarding intermediaries.
</p>

		<section id="section-1.1">
<h3 title="Requirements Notation">1.1. 要件の表記法</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
</p>

<p>
適合性の判定基準, および
~errorの取扱いに関する考慮点は、
`2.5$sec にて定義される。
◎
Conformance criteria and considerations regarding error handling are defined in Section 2.5.
</p>

		</section>
		<section id="section-1.2">
<h3 title="Syntax Notation">1.2. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
`~HTTP日本語訳 共通~page＠~HTTPcommon#syntax-notation$に移譲。
】</p>

<p>
`総集的~ABNF＠~723Xabnf#abnf-7230$
にて、他の文書から取込まれた規則, および
すべての`~list演算子$を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7, that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix B shows the collected grammar with all list operators expanded to standard ABNF notation.
◎
The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).
◎
As a convention, ABNF rule names prefixed with "obs-" denote "obsolete" grammar rules that appear for historical reasons.
</p>

		</section>
	</section>
	<section id="section-2">
<h2 title="Architecture">2. ~architecture</h2>

<p>
~HTTP は、 World Wide Web（ WWW ）~architecture用に作成され，［
~worldwide~hypertext~systemにおける~scale能の必要性
］を~supportするために，時と伴に発展してきた。
その~architectureの多くは、~HTTPを定義するために利用される［
各種用語, および構文~生成規則
］に反映されている。
◎
HTTP was created for the World Wide Web (WWW) architecture and has evolved over time to support the scalability needs of a worldwide hypertext system. Much of that architecture is reflected in the terminology and syntax productions used to define HTTP.
</p>

		<section id="section-2.1">
<h3 title="Client/Server Messaging">2.1. ~client／~serverによる~messaging</h3>

<div class="p">

<p>
~HTTPは、［
依拠-可能な［
~transport層や~session層
］の接続にまたがって，`~message$を交換する（`6$sec）
］ことにより運用される，`~stateless$な［
要請／応答
］~protocolである。
◎
HTTP is a stateless request/response protocol that operates by exchanging messages (Section 3) across a reliable transport- or session-layer "connection" (Section 6).＼
</p>

<ul>
	<li>
~HTTP
`~client@
とは、 1 個~以上の~HTTP要請を送信する目的で，`~server$への接続を確立する~programである。
◎
An HTTP "client" is a program that establishes a connection to a server for the purpose of sending one or more HTTP requests.＼
</li>
	<li>
~HTTP
`~server@
とは、~HTTP要請に対し，その接続を受容し、`~client$への~serviceとして，~HTTP応答を送信する~programである。
◎
An HTTP "server" is a program that accepts connections in order to service HTTP requests by sending HTTP responses.
</li>
</ul>
</div>

<div class="p">

<p>
2 つの用語 “`~client$”, “`~server$” が指すのは、［
特定0の接続~用に，これらの~programが遂行する`役割$
］に限られる。
同じ~programが［
ある接続~上では~clientになると~~同時に，他の接続~上では~server
］として動作し得る。
◎
The terms "client" and "server" refer only to the roles that these programs perform for a particular connection. The same program might act as a client on some connections and a server on others.＼
</p>

<p class="trans-note">【
語
`接続@
は、~messageの経路（後述の，接続の`連鎖$）全体ではなく，隣接する ある 2 つの
`参加者@
（連鎖に属する~node）間の接続を指すことに注意（個々の参加者から直に見えるのは，隣の参加者だけなので）。
】</p>

<ul>
	<li>
用語
`~UA@
（利用者~agent）は、［
要請を起動する任意の`~client$~program
］を指し，様々なものがある
⇒
~browser,
~spider（~web~based~robot）,
~command-line~tool,
~custom~app,
携帯~app,
等々
◎
The term "user agent" refers to any of the various client programs that initiate a request, including (but not limited to) browsers, spiders (web-based robots), command-line tools, custom applications, and mobile apps.＼
</li>
	<li>
用語
`生成元~server@
は、［
所与の`~target資源$に対する`権限的~応答$
］を出生できる~programを指す。
◎
The term "origin server" refers to the program that can originate authoritative responses for a given target resource.＼
</li>
	<li>
用語
`送信者@
／
`受信者@
は、所与の~messageを［
送信する／受信する
］任意の実装を指す。
◎
The terms "sender" and "recipient" refer to any implementation that sends or receives a given message, respectively.
</li>
</ul>
</div>

<p>
~HTTPは、［
`~target資源$と, 資源~間の関係性
］を指示するために，
<abbr title="Uniform Resource Identifier">URI</abbr> 標準 `3986$R
に依拠する。
~messageは、［［
Internet mail `5322$R ／
<abbr title="Multipurpose Internet Mail Extensions">MIME</abbr> `2045$R
］に利用されるものに類似な形式
］で渡される（HTTP と~MIME~messageとの間の相違点については、
`7231$R `付録 A＠~7231#appendix-A$
を見よ）。
◎
HTTP relies upon the Uniform Resource Identifier (URI) standard [RFC3986] to indicate the target resource (Section 5.1) and relationships between resources. Messages are passed in a format similar to that used by Internet mail [RFC5322] and the Multipurpose Internet Mail Extensions (MIME) [RFC2045] (see Appendix A of [RFC7231] for the differences between HTTP and MIME messages).
</p>

<p>
ほとんどの~HTTP通信は、［
`~URI$により識別される何らかの`資源$
］の`表現$に対する，検索取得 要請（ `GET$m ）からなる。
最も単純な事例では、これは，［
`~UA$（ `UA^var ）と`生成元~server$（ `O^var ）との間の，単独の双方向-接続（ `===^c ）
］を介して成遂げられるであろう：
◎
Most HTTP communication consists of a retrieval request (GET) for a representation of some resource identified by a URI. In the simplest case, this might be accomplished via a single bidirectional connection (===) between the user agent (UA) and the origin server (O).
</p>

<pre class="presentation">
       要請   &gt;
  `UA^var ======================================= `O^var
                              &lt;   応答
</pre>

<div class="p">

<p>
`~client$は、~HTTP要請を`~server$へ送信する。
それは、順に 次のものからなる，要請~messageの形をとる：
◎
A client sends an HTTP request to a server in the form of a request message,＼
</p>

<ol>
	<li>
<p>
順に，次のものからなる `request-line$p 
⇒＃
`~method$,
`~URI$,
`~protocol~version$
◎
beginning with a request-line that includes a method, URI, and protocol version (Section 3.1.1), followed by＼
</li>
	<li>
次を包含している，いくつかの`~header$
⇒
`要請の改変子$／`~client$情報／`表現~metadata$
◎
header fields containing request modifiers, client information, and representation metadata (Section 3.2),＼
</li>
	<li>
`~header節$の終端を指示する`空~行l$
◎
an empty line to indicate the end of the header section, and＼
</li>
	<li>
最後に、`~payload本体$を包含している`~message本体$（もし在れば）
◎
finally a message body containing the payload body (if any, Section 3.3).
</li>
</ol>
</div>

<div class="p">

<p>
`~server$は、`~client$からの要請に対し，［
1 個~以上の~HTTP応答~message
］を送信して，応答する。
そのそれぞれは、順に，次のものからなる：
◎
A server responds to a client's request by sending one or more HTTP response messages, each＼
</p>

<ol>
	<li>
順に次を内包する， `status-line$p 
⇒＃
`~protocol~version$,
成功~codeまたは~error~code（ `状態s~code$ ）,
~textな`事由~句$
◎
beginning with a status line that includes the protocol version, a success or error code, and textual reason phrase (Section 3.1.2),＼
</li>
	<li>
<p>
次を包含する， 0 個~以上の `~header$
⇒
~server情報／資源~metadata／`表現~metadata$
◎
possibly followed by header fields containing server information, resource metadata, and representation metadata (Section 3.2),＼
</li>
	<li>
`~header節$の終端を指示する`空~行l$
◎
an empty line to indicate the end of the header section, and＼
</li>
	<li>
最後に、`~payload本体$を包含している`~message本体$（もし在れば）
◎
finally a message body containing the payload body (if any, Section 3.3).
</li>
</ol>
</div>

<p>
`6.3$sec にて定義されるように、同じ接続が，複数の［
要請／応答
］の交換に利用されることもある。
◎
A connection might be used for multiple request/response exchanges, as defined in Section 6.3.
</p>

<div class="example">

<p>
代表的な例として、 URI
"`http://www.example.com/hello.txt^c"
へ向けた `GET$m 要請における，~message交換の様子を次に示す：
◎
The following example illustrates a typical message exchange for a GET request (Section 4.3.1 of [RFC7231]) on the URI "http://www.example.com/hello.txt":
</p>

<p>
~clientによる要請：
◎
Client request:
</p>

<pre class="lang-http">
GET /hello.txt HTTP/1.1
User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
Host: www.example.com
Accept-Language: en, mi
</pre>

<p>
~serverからの応答：
◎
Server response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: "34aa387-d-1568eb00"
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain

Hello World! My payload includes a trailing CRLF.
</pre>

</div>

		</section>
		<section id="section-2.2">
<h3 title="Implementation Diversity">2.2. 実装の多様性</h3>

<p>
~HTTPの設計を考慮するとき、［
すべての`~UA$は 一般用~browserで, すべての`生成元~server$は 巨大な公共~web~siteである
］ような考えに陥り易いが、実施においては，あてはまらない。
~HTTP`~UA$には、次のものも普通に見られる：［
家電,
視聴覚機器,
計測機器,
~firmware更新~script,
~command-line~program,
携帯~app,
~sizeや形状が様々な通信~機器
］, 等々。

同様に、~HTTP `生成元~server$には，次のものも普通に見られる：［
住宅用自動化設備,
環境設定-可能な~network用~component,
事務機械,
自律型robot,
ニュースフィード,
交通camera,
ad selector 【“広告セレクタ”】,
動画配信~platform
］, 等々。
◎
When considering the design of HTTP, it is easy to fall into a trap of thinking that all user agents are general-purpose browsers and all origin servers are large public websites. That is not the case in practice. Common HTTP user agents include household appliances, stereos, scales, firmware update scripts, command-line programs, mobile apps, and communication devices in a multitude of shapes and sizes. Likewise, common HTTP origin servers include home automation units, configurable networking components, office machines, autonomous robots, news feeds, traffic cameras, ad selectors, and video-delivery platforms.
</p>

<p>
用語 “`~UA$” は、要請の時点に［
~software~agentと直にヤリトリしているヒト利用者が居る
］ことを含意するわけではない。
多くの事例で、`~UA$は~backgroundにて稼働するように ~installされ, あるいは環境設定されていて，その結果を（あるいは，その中の関心がある／誤りがありそうな部分のみを）今後の検分~用に保存する。
例えば，~spiderは、概して，所与の~URIから開始して，~Webを~hypertext~graphとして巡る間、一定の挙動に従うように環境設定される。
◎
The term "user agent" does not imply that there is a human user directly interacting with the software agent at the time of a request. In many cases, a user agent is installed or configured to run in the background and save its results for later inspection (or save only a subset of those results that might be interesting or erroneous). Spiders, for example, are typically given a start URI and configured to follow certain behavior while crawling the Web as a hypertext graph.
</p>

<p>
~HTTP実装の多様性は、すべての`~UA$が［
利用者に向けて対話的に何かを示唆したり,
~securityや~privacyに関する懸念のために必要十分な警告を供せる
］わけではないことを意味する。
この仕様が［
利用者~向けに~errorを報告する
］ことを要求する，少数の事例では、そのような報告が［
~error~consoleや~log~fileにのみ観測-可能である
］ことも受容-可能である。
同様に，自動化~動作についても、［
続行する前に利用者による確認を要する
］ような要件は，［
~~事前の環境設定の選択,
稼働時~option,
安全でない動作に対する単純な回避法
］などを介して~~満たされ得る
—
確認は、利用者がすでにその選択を済ませていた場合には，いかなる［
特定の利用者~interfaceや, 通常~処理の中断
］も含意しない。
◎
The implementation diversity of HTTP means that not all user agents can make interactive suggestions to their user or provide adequate warning for security or privacy concerns. In the few cases where this specification requires reporting of errors to the user, it is acceptable for such reporting to only be observable in an error console or log file. Likewise, requirements that an automated action be confirmed by the user before proceeding might be met via advance configuration choices, run-time options, or simple avoidance of the unsafe action; confirmation does not imply any specific user interface or interruption of normal processing if the user has already made that choice.
</p>

		</section>
		<section id="section-2.3">
<h3 title="Intermediaries">2.3. 中継者</h3>

<p>
~HTTPは、要請が接続の
`連鎖@
を通り抜けられるようにするため，
`中継者@
の利用も可能化する。
~HTTP中継者は、 3 種の共通な形［
`~proxy$,
`~gateway$,
`~tunnel$
］がある。
一部の事例では、単独の中継者が，各~要請の資質に基づいて 自身の挙動を［
`生成元~server$,
`~proxy$,
`~gateway$,
`~tunnel$
］のいずれかに切替えながら，動作することもある。
◎
HTTP enables the use of intermediaries to satisfy requests through a chain of connections. There are three common forms of HTTP intermediary: proxy, gateway, and tunnel. In some cases, a single intermediary might act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.
</p>

<pre class="presentation">
       &gt;             &gt;             &gt;             &gt;
  `UA^var =========== `A^var =========== `B^var =========== `C^var =========== `O^var
             &lt;             &lt;             &lt;             &lt;
</pre>

<div class="p">
<p>
上の図は、`~UA$と `生成元~server$の間に挟まれた， 3 つの`中継者$（
`A^var,  `B^var,  `C^var
）を示している。
`連鎖$の端から端まで届けられる［
要請／応答
］~messageは、 4 つの別々な接続を渡り歩くことになる。
~HTTP通信~optionには、次のいずれかに適用されるものもある：
◎
The figure above shows three intermediaries (A, B, and C) between the user agent and origin server. A request or response message that travels the whole chain will pass through four separate connections. Some HTTP communication options might apply＼
</p>

<ul>
	<li>
最も近い, 非`~tunnel$の，隣接点との接続のみ
【 `隣点間@（ hop-by-hop ） 】
◎
only to the connection with the nearest, non-tunnel neighbor,＼
</li>
	<li>
連鎖の
`端点@
にのみ
◎
only to the endpoints of the chain, or＼
</li>
	<li>
連鎖~沿いにある すべての接続
【 `端点間@（ end-to-end ）】
◎
to all connections along the chain.＼
</li>
</ul>

<p>
また，上の図式は単線だが、各~参加者は，同時に複数の通信に参加し得る。
例えば `B^var は、 `A^var からの要請を取扱うと同時に，［
`A^var 以外の多数の~clientからの要請を受信していたり,
`C^var 以外の`~server$向けの要請を回送している
］こともあり得る。
同様に，今後の要請が、異なる経路による接続
— 多くの場合、負荷分散~用の動的~環境設定に基づく —
を通して送信されることもあり得る。
◎
Although the diagram is linear, each participant might be engaged in multiple, simultaneous communications. For example, B might be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's request. Likewise, later requests might be sent through a different path of connections, often based on dynamic configuration for load balancing.
</p>
</div>

<p>
用語
`上流@
／
`下流@
は、［
~messageが流れる方向
］に関係して，要件を述べるときに用いられる：
すべての~messageは上流から下流へ流れる。
用語
`内方@
／
`外方@
は、［
要請が経路制御される方向
］に関係して，要件を述べるときに用いられる：
“内方” は`生成元~server$へ向かうことを意味し，
“外方” は`~UA$へ向かうことを意味する。
◎
The terms "upstream" and "downstream" are used to describe directional requirements in relation to the message flow: all messages flow from upstream to downstream. The terms "inbound" and "outbound" are used to describe directional requirements in relation to the request route: "inbound" means toward the origin server and "outbound" means toward the user agent.
</p>

<p>
`~proxy@
は、［
何らかの型の絶対~URIへ向けた要請を受信したときには、［
~HTTP~interfaceを通した翻訳
］を介して，その要請を充足しようと試みる
］ような，~message回送~agentであり、通例的に，`~client$の局所的な環境設定~規則を介して，~clientにより選定される。
翻訳には、［
"`http$c" ~URIへ向けた~proxy要請のような必要最小限なもの
］もある一方，［
全面的に異なる~app~levelの~protocolへの／からの翻訳を要する要請
］もあり得る。
`~proxy$は、［
~security,
~annotation~service†,
共用~caching
］の~~目的で，［
組織~内の~HTTP要請を，共通な`中継者$を通して~group分けする
］ために利用されることが多い。
一部の`~proxy$は、~messageを回送する際に，［
選定された
~message／`~payload$
に`形式変換$を適用する
］ように設計されている。
◎
A "proxy" is a message-forwarding agent that is selected by the client, usually via local configuration rules, to receive requests for some type(s) of absolute URI and attempt to satisfy those requests via translation through the HTTP interface. Some translations are minimal, such as for proxy requests for "http" URIs, whereas other requests might require translation to and from entirely different application-level protocols. Proxies are often used to group an organization's HTTP requests through a common intermediary for the sake of security, annotation services, or shared caching. Some proxies are designed to apply transformations to selected messages or payloads while they are being forwarded, as described in Section 5.7.2.
</p>

<p class="trans-note">【†
元の~dataに追加的な情報
— “~~注釈（ annotation ）” —
を付加するような~serviceを意味するとみられる（例えば，用語に~linkを補完するなど）。
】</p>

<div class="p">
<p>
`~gateway@
（いわゆる “逆~proxy” ）は，`中継者$の一種であり、`外方$への接続に対しては`生成元~server$として動作しつつ，受信された要請を翻訳して `内方$の別の`~server$たちへ回送する。
~gatewayは、次のために利用されることが多い：
◎
A "gateway" (a.k.a. "reverse proxy") is an intermediary that acts as an origin server for the outbound connection but translates received requests and forwards them inbound to another server or servers. Gateways are often used＼
</p>

<ul>
	<li>
旧来の, あるいは信用できない情報~serviceを~encapsulateする。
◎
to encapsulate legacy or untrusted information services,＼
</li>
	<li>
“加速器” による~cachingを通して~server処理能を改善する。
◎
to improve server performance through "accelerator" caching, and＼
</li>
	<li>
複数の~machineにまたがる［
~HTTP~serviceの区割りや負荷分散
］を可能化する。
◎
to enable partitioning or load balancing of HTTP services across multiple machines.
</li>
</ul>
</div>

<p>
`生成元~server$に適用-可能な，すべての~HTTP要件は、`~gateway$の`外方$への通信にも適用される。
`~gateway$は、自身が欲する任意の~protocol
— この仕様の対象外である，~HTTPに対する私的~拡張も含む —
を利用して`内方$`~server$と通信する。
しかしながら、第三者-主体の~HTTP~serverと相互運用したいと望む HTTP-to-HTTP `~gateway$は、［
~gatewayの`内方$への接続
］に課される`~UA$要件にも適合する~OUGHT。
◎
All HTTP requirements applicable to an origin server also apply to the outbound communication of a gateway. A gateway communicates with inbound servers using any protocol that it desires, including private extensions to HTTP that are outside the scope of this specification. However, an HTTP-to-HTTP gateway that wishes to interoperate with third-party HTTP servers ought to conform to user agent requirements on the gateway's inbound connection.
</p>

<p>
`~tunnel@
は、~messageを変更することなく， 2 つの接続の間を盲目的に中継するように動作する。
いったん作動中になった~tunnelは、それが~HTTP要請により起動されたとしても，~HTTP通信の主体とは見なされない。
~tunnelが存在し得るのは、［
中継された接続の両~端
］が~closeされるまでである。
~tunnelは、［
共用~firewall~proxyを通した機密的~通信
］を確立するために， TLS（ Transport Layer Security, `5246$R）が利用されるときなど、［
`中継者$を通した仮想~接続
］を拡張するために利用される。
◎
A "tunnel" acts as a blind relay between two connections without changing the messages. Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel might have been initiated by an HTTP request. A tunnel ceases to exist when both ends of the relayed connection are closed. Tunnels are used to extend a virtual connection through an intermediary, such as when Transport Layer Security (TLS, [RFC5246]) is used to establish confidential communication through a shared firewall proxy.
</p>

<p>
上の`中継者$の類別は、［
~HTTP通信における参加者
］として動作しているもののみが考慮される。
中継者には、［
~network~protocol~stackの より低~層
］で動作して，［
~message送信者についての知識や許可
］なしに［
~HTTP流通を~filterしたり~redirectする
］ものもある。
~network中継者は，（~protocol~levelでは）中間者~攻撃かどうか判別できないので、［
~HTTP意味論を誤解して違反することに因る，~securityの欠陥や相互運用能の問題
］が導入されることも多い。
◎
The above categories for intermediary only consider those acting as participants in the HTTP communication. There are also intermediaries that can act on lower layers of the network protocol stack, filtering or redirecting HTTP traffic without the knowledge or permission of message senders. Network intermediaries are indistinguishable (at a protocol level) from a man-in-the-middle attack, often introducing security flaws or interoperability problems due to mistakenly violating HTTP semantics.
</p>

<p>
例えば， “~interception~proxy” `3040$R （ “透過的~proxy” `1919$R や “~captive~portal” としても周知）は、~clientにより選定されるものではない点で，~HTTP`~proxy$とは相違する。
代わりに，~interception~proxyは、［
外向けの~TCP~port 80 ~packet
］を（ときには他の共通的な~port上の流通も），~filterしたり~redirectする。
~interception~proxyは、［［
公共~network~access~pointにて，局所的でない~Internet~serviceの利用を許容する
］に先立って，~account~subscriptionを施行する手段
］として, あるいは［
~network利用e施策を施行する企業~firewall
］の中で，共通的に見出される。
◎
For example, an "interception proxy" [RFC3040] (also commonly known as a "transparent proxy" [RFC1919] or "captive portal") differs from an HTTP proxy because it is not selected by the client. Instead, an interception proxy filters or redirects outgoing TCP port 80 packets (and occasionally other common port traffic). Interception proxies are commonly found on public network access points, as a means of enforcing account subscription prior to allowing use of non-local Internet services, and within corporate firewalls to enforce network usage policies.
</p>

<p>
~HTTPは、
`~stateless@
な~protocolとして定義されている
— すなわち、各~要請~messageは，互いに隔離されても解せることを意味する。
多くの実装は、［
~proxyされた接続を再利用したり，
複数の~serverにまたがって要請を動的に負荷分散する
］ときに，［
~HTTPの~statelessな設計
］に依存する。
よって，`~server$は、［
同じ接続~上の 2 つの要請
］を，同じ`~UA$からのものと見做してはナラナイ
— その接続が［
~secure化されていて，その~UAに特有である
］のでない限り。
一部の非~標準~HTTP拡張（例： `4559$R）は、この要件に違反していることが既知であり、~securityの および相互運用能の問題を起こす。
◎
HTTP is defined as a stateless protocol, meaning that each request message can be understood in isolation. Many implementations depend on HTTP's stateless design in order to reuse proxied connections or dynamically load balance requests across multiple servers. Hence, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent. Some non-standard HTTP extensions (e.g., [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems.
</p>

		</section>
		<section id="section-2.4">
<h3 title="Caches">2.4. ~cache</h3>

<p>
`~cache@
とは、［
以前に受け取った応答~messageの局所的な格納域
］であり，それらの~messageの［
~storage, 検索取得, 削除
］を制御する下位~systemである。
`~cache$は、`~cache可能$な応答を，［
未来の, 等価な要請
］に要する［
応答~時間や, ~network帯域幅 消費量
］を抑制するために格納する。
どの［
`~client$／`~server$
］も，`~cache$を使役してヨイ
—
`~tunnel$として動作している~serverは，~cacheを利用し得ないが。
◎
A "cache" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used by a server while it is acting as a tunnel.
</p>

<p>
`~cache$による効果は、［
要請／応答
］の連鎖が
— ［
`連鎖$沿いにある いずれかの参加者
］が［
その要請に適用-可能な ~cache済み応答
］を持つときには —
短縮されることである。
次の図に、ある要請に対し， `B^var が~cache済み複製を持っている
— それは［
~~以前に
【ある~UAによる，その要請と等価な要請に対し】
 `O^var から（ `C^var を介して）受信した応答
］の複製であり，［
`UA^var や `A^var には まだ~cacheされていない
］とする —
ときの結果を示す：
◎
The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request that has not been cached by UA or A.
</p>

<pre class="presentation">
          &gt;             &gt;
     `UA^var =========== `A^var =========== `B^var - - - - - - `C^var - - - - - - `O^var
                &lt;             &lt;
</pre>

<p>
応答~messageは、［
後続の要請に対する回答に利用するためとして，複製を`~cache$に格納することが許容される
］とき，
`~cache可能@
であるという。
応答が~cache可能であるとしても、［
特定0の要請に対し，~cache済み応答が いつ利用できるか
］について，［
`~client$や`生成元~server$により，追加的な拘束が設置される
］こともある。
［
`~cache$の挙動, および
~cache可能な応答
］に課される~HTTP要件は、 `7234-2$rfc にて定義される。
◎
A response is "cacheable" if a cache is allowed to store a copy of the response message for use in answering subsequent requests. Even when a response is cacheable, there might be additional constraints placed by the client or by the origin server on when that cached response can be used for a particular request. HTTP requirements for cache behavior and cacheable responses are defined in Section 2 of [RFC7234].
</p>

<p>
World Wide Webや, 巨大な組織の内側にまたがって配備されている`~cache$には、多種多様な~architectureや環境設定がある。
これらには、次のものも含まれる：［
大陸間~帯域幅を節約するための，~proxy~cacheの国別~階層
］, ［
~cache~entryを~broadcastしたり~multicastする，協調的な~system
］, ［
~off-line／高遅延 環境の下で利用するために，
事前fetchされた~cache~entryの~archive
］, 等々。
◎
There is a wide variety of architectures and configurations of caches deployed across the World Wide Web and inside large organizations. These include national hierarchies of proxy caches to save transoceanic bandwidth, collaborative systems that broadcast or multicast cache entries, archives of pre-fetched cache entries for use in off-line or high-latency environments, and so on.
</p>

		</section>
		<section id="section-2.5">
<h3 title="Conformance and Error Handling">2.5. 適合性, および~errorの取扱い</h3>

<div class="p">

<p>
この仕様は、［
~HTTP通信における参加者の
`役割@
］に則って，適合性の判定基準を~~適用する。
よって，~HTTP要件は、それにより拘束される挙動に依存して，次のものに設置される：
</p>

<ul ><li>`送信者$
</li><li>`受信者$
</li><li>`~client$
</li><li>`~server$
</li><li>`~UA$
</li><li>`中継者$
</li><li>`生成元~server$
</li><li>`~proxy$
</li><li>`~gateway$
</li><li>`~cache$
</li></ul>
◎
This specification targets conformance criteria according to the role of a participant in HTTP communication. Hence, HTTP requirements are placed on senders, recipients, clients, servers, user agents, intermediaries, origin servers, proxies, gateways, or caches, depending on what behavior is being constrained by the requirement.＼
</div>

<p>
また，［
単独の通信の視野を超えて適用される
］ときには、追加的な（~social）要件が，［
実装／資源~所有者／~protocol要素~登録
］に設置されることもある。
◎
Additional (social) requirements are placed on implementations, resource owners, and protocol element registrations when they apply beyond the scope of a single communication.
</p>

<p>
要件の中で，［
~protocol要素を作成すること
］を，［
受信された要素を 単に`下流$へ回送すること
］から相違化して記す所では、前者に対し，動詞
“`生成する@”
が， “送信する” に代わって利用される。
◎
The verb "generate" is used instead of "send" where a requirement differentiates between creating a protocol element and merely forwarding a received element downstream.
</p>

<p>
実装は、［
~HTTPにおいて自身が受け持つ各 `役割$に結付けられる，すべての要件
］に準拠するならば、適合すると見なされる。
◎
An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.
</p>

<div class="p">

<p>
適合性には、~protocol要素の［
構文, 意味論
］の両者が含まれる。
`送信者$は、次に挙げるものを，~message内に`生成し$てはナラナイ：
◎
Conformance includes both the syntax and semantics of protocol elements.＼
</p>

<ul>
	<li>
［
その送信者にとって，虚偽であることが既知である
］ような意味を伝達する~protocol要素。
◎
A sender MUST NOT generate protocol elements that convey a meaning that is known by that sender to be false.＼
</li>
	<li>
［
対応ng~ABNF規則により定義される文法
］に合致しない~protocol要素。
◎
A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules.＼
</li>
	<li>
［
他の`役割$（すなわち，その~messageに対し送信者が持たない`役割$）を持つ参加者
］のみに`生成する$ことが許容されている，［
~protocol要素／構文~代替
］。
◎
Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).
</li>
</ul>
</div>

<div class="p">

<p>
`受信者$は，受信した~protocol要素を構文解析するときは、次のいずれも~~満たすような，どの値も構文解析できなければナラナイ：
◎
When a received protocol element is parsed, the recipient MUST be able to parse any value of＼
</p>

<ul>
	<li>
受信者の`役割$に適用-可能である，かつ
◎
reasonable length that is applicable to the recipient's role and＼
</li>
	<li>
対応ng~ABNF規則にて定義される文法に合致する，かつ
◎
that matches the grammar defined by the corresponding ABNF rules.＼
</li>
	<li>
その要素に見合う長さである。
◎
↓↓＼
</li>
</ul>

<p>
受信される~protocol要素には，構文解析されないものもあることに注意。
例えば，~messageを回送している`中継者$は、~構文解析器により `header-field$p から汎用の［
`field-name$p, `field-value$p
］成分を取り出しつつ,
`field-value$p の内側まではそれ以上 構文解析せずに，`~header$を回送することもある。
◎
Note, however, that some received protocol elements might not be parsed. For example, an intermediary forwarding a message might parse a header-field into generic field-name and field-value components, but then forward the header field without further parsing inside the field-value.
</p>

</div>

<p>
~HTTPにおける多くの~protocol要素は，特定の長さ制限を設けていない
— 何故なら，［
適切になるであろう長さ
］は、実装の［
配備~文脈や目的
］に依存して，多岐に渡るので。
よって，［
`送信者$と`受信者$との間の相互運用能
］は、［
各種~protocol要素に見合う長さに関して，共有されている期待
］に依存する。
更には，一部の~protocol要素に対しては、［
それに見合う長さであると共通的に解されているもの
］は，過去 20 年に渡る~HTTP利用に伴って変遷しており、また，今後も変わり続けるものと予期されている。
◎
HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation. Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element. Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past two decades of HTTP use and is expected to continue changing in the future.
</p>

<p>
`受信者$は、最小限，［［
他の~message内の同じ~protocol要素
］に対し，自身が`生成し$得る値の長さ
］以上の長さの~protocol要素を，構文解析して処理できなければナラナイ。
例えば，［
自前の`資源$に 長大な~URI参照を公表する`生成元~server$
］は、［
`要請~target$として受信された，同じ参照
］を構文解析して処理できる必要がある。
◎
At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages. For example, an origin server that publishes very long URI references to its own resources needs to be able to parse and process those same references when received as a request target.
</p>

<p>
`受信者$は、受信された~protocol要素を，［
この仕様がそれに定義する意味論
— この仕様に対する拡張も含む
］に則って解釈しなければナラナイ
— ただし、受信者が［
送信者が，それらの意味論に含意されるものを不正に実装している
］ものと，（経験または環境設定を通して）決定できたときは除く。
例えば，`生成元~server$は、［
`User-Agent$h ~headerの検分
］から，［［
ある種の`内容~符号法$の受領に際し失敗する
］と既知である，特定の実装~version
］が指示されたときには、［
受信された `Accept-Encoding$h ~headerの内容
］を無視rするであろう。
◎
A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics. For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.
</p>

<p>
他が注記されない限り，`受信者$は、妥当でない構成子から，利用~可能な~protocol要素を回復しようと試みてヨイ。
~HTTPは、［
~securityへの直接的な影響iがある
］ときを除いて，［
~errorを取扱う特定の仕組み
］を定義しない
—
~errorを取扱うに際し要求される策は、~protocolの~appごとに異なるので。
例えば、~Web~browserは，［
応答の `Location$h ~headerが~ABNFに則って構文解析できない
］ときに 透過的な回復を望むかもしれないが、~system制御~clientは，いかなる形の~error回復も 危険と見なすかもしれない。
◎
Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct. HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies. For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.
</p>

		</section>
		<section id="section-2.6">
<h3 title="Protocol Versioning">2.6. ~protocolの~version付け</h3>

<p>
~HTTPは、~protocolの各
`~version^dfn
を指示するために，
"<code class="grammar">&lt;`major^var&gt;.&lt;`minor^var&gt;</code>"
による付番方式を利用する。
この仕様が定義する`~version番号$は，
"<dfn id="version-1.1">`1.1^c</dfn>"
である。
~protocol~versionは、それ一体として，［［
その~versionに対応する~HTTPの仕様
］にて挙げられた要件の集合
］に，`送信者$が適合していることを指示する。
◎
HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol. This specification defines version "1.1". The protocol version as a whole indicates the sender's conformance with the set of requirements laid out in that version's corresponding specification of HTTP.
</p>

<p>
~HTTP~messageの~versionは、［
~messageの最初の行l内の `HTTP-version$p ~field
］により指示される。
`HTTP-version$p は文字大小区別である。
◎
The version of an HTTP message is indicated by an HTTP-version field in the first line of the message. HTTP-version is case-sensitive.
</p>

<pre class="bnf">
`HTTP-version@p  = `HTTP-name$p "/" `DIGIT$P "." `DIGIT$P
`HTTP-name@p     = %x48.54.54.50 ; "HTTP", case-sensitive
</pre>

<div class="p">
<p>
~HTTP
`~version番号@
は、［
"." （ピリオド／小数点）で分離される 2 個の~decimal桁（ `DIGIT$P ）
］からなる：
◎
The HTTP version number consists of two decimal digits separated by a "." (period or decimal point).＼
</p>

<ul>
	<li>
1 個目の桁
— `~major~version@ —
は、~HTTP~messaging構文を指示する。
◎
The first digit ("major version") indicates the HTTP messaging syntax, whereas＼
</li>
	<li>
<p>
2 個目の桁
— `~minor~version@ —
は、最初の桁による`~major~version$の下で，`送信者$が［
適合する, かつ
未来の通信においても解せる
］ような，最も高い~minor~versionを指示する。
◎
the second digit ("minor version") indicates the highest minor version within that major version to which the sender is conformant and able to understand for future communication.＼
</p>

<p>
`~minor~version$は、`送信者$が［
~protocolの後方-互換な~subset
］のみを利用しているときでも，［
送信者の通信~能力
］を広告し、従って［
未来の［
（~serverによる）応答／（~clientによる）要請
］において，より高度な特能も利用できる
］ことを，受信者に知らせる。
◎
The minor version advertises the sender's communication capabilities even when the sender is only using a backwards-compatible subset of the protocol, thereby letting the recipient know that more advanced features can be used in response (by servers) or in future requests (by clients).
</p>
	</li>
</ul>

</div>

<p>
~versionが［
~HTTP10 `1945$R あるいは未知
］の`受信者$に向けて送信される`~HTTP11$~messageは、［
より新たな特能すべてが無視されたなら，妥当な~HTTP10~messageとして解釈できる
］ように構築される。
この仕様は、一部の新たな特能に対し，次が守られるように［
受信者~versionの要件
］を設置する：
`送信者$は、自身が当の特能に適合するとしても，［
環境設定や, ~messageの受領を通して，受信者が~HTTP11を~supportする
］ことを決定するまでは、互換な特能のみを利用する。
◎
When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [RFC1945] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored. This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.
</p>

<p>
`~header$の解釈は、［
同じ`~major$ ~HTTP~version下の`~minor~version$間
］では，変わらない
— ［
そのような~headerが無い下での，`受信者$の既定の挙動
］は，変わり得るが。
他から指定されない限り，［
`~HTTP11$にて定義される~header
］は，すべての［
~HTTP1x~version†
］に対しても定義される。
特に，［
`Host$h ／ `Connection$h
］~headerは、［
~HTTP11への適合性を広告するかどうか
］に関わらず，すべての［
~HTTP1x実装†
］にて実装される~OUGHT。
【† ~HTTP10も含まれることになる】
◎
The interpretation of a header field does not change between minor versions of the same major HTTP version, though the default behavior of a recipient in the absence of such a field can change. Unless specified otherwise, header fields defined in HTTP/1.1 are defined for all versions of HTTP/1.x. In particular, the Host and Connection header fields ought to be implemented by all HTTP/1.x implementations whether or not they advertise conformance with HTTP/1.1.
</p>

<p>
新たな`~header$を，［
~protocol~versionを変更する
］ことなく，導入できる
— ［
それに定義される意味論
］において，［
それを認識しない`受信者$が，それを安全に無視する
］ことが許容されるならば。
~headerの拡張能は `3.2.1$sec にて論じられる。
◎
New header fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them. Header field extensibility is discussed in Section 3.2.1.
</p>

<p>
~HTTP~messageを処理する`中継者$（すなわち，`~tunnel$として動作するもの以外のすべての`中継者$）は、自身が回送する~message内に，［
自前の `HTTP-version$p
］を送信しなければナラナイ。
言い換えれば，`中継者$には、~messageの［
受信, 送信
］の両者において，［
その~message内の~protocol~versionが，自身が適合する~versionに合致する
］ことが確保されない限り、［
~HTTP~messageの最初の行lを盲目的に回送する
］ことは，許容されない。
仮に， `HTTP-version$p を書換えないまま~HTTP~messageが回送された場合、`下流$の`受信者$が［
その`送信者$の~versionを，［［
~message送信者との今後の通信
］用に［
安全に利用できる特能
］を決定する
］ために利用している
］ときに，通信~errorになるかもしれない。
◎
Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages. In other words, they are not allowed to blindly forward the first line of an HTTP message without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.
</p>

<div class="p">
<p>
`~client$が要請~内に送信する~versionは：
◎
A client SHOULD send a request version＼
</p>

<ul>
	<li>
<p>
次を満たす，最も高い~versionにするベキである：
</p>
		<ul>
			<li>
~client自身が適合している，かつ
</li>
			<li>
その`~major~version$は、［
`~server$が~supportする，最も高い~version
］が~clientに既知である場合は，それ以下である。
</li>
		</ul>
◎
equal to the highest version to which the client is conformant and whose major version is no higher than the highest version supported by the server, if this is known.＼
</li>
	<li>
~client自身が適合していなければナラナイ。
◎
A client MUST NOT send a version to which it is not conformant.
</li>
</ul>

</div>

<p>
`~client$は、［
~serverが~HTTP仕様を不正に実装している
］ことが既知である場合，［
より低い~versionによる要請
］を送信してヨイ
— ただし，それは、~clientが，少なくとも 1 回は通常の要請を試みて，［
`応答~状態s~code$や`~header$（例： `Server$h ）
］から［
~serverが より高い要請~versionを不適正に取扱う
］ことを決定できた後に限られる。
◎
A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions.
</p>

<div class="p">
<p>
`~server$が，要請に対する応答に送信する~versionは：
◎
A server SHOULD send a response version＼
</p>

<ul>
	<li>
<p>
次を満たす，最も高い~versionにするベキである：
</p>
		<ul>
			<li>
~server自身が適合している，かつ
</li>
			<li>
その`~major~version$は、その要請にて受信されたもの以下である。
</li>
		</ul>
◎
equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request.＼
</li>
	<li>
~server自身が適合していなければナラナイ。
◎
A server MUST NOT send a version to which it is not conformant.＼
</li>
</ul>

<p>
`~server$は、何らかの事由で［
`~client$の`~major$~protocol~version
］に対する~serviceの拒否を望むときは，
`505$st 応答を送信できる。
◎
A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.
</p>
</div>

<div class="p">
<p>
`~server$は、~clientによる要請に対し，［
その~clientが，~HTTP仕様を不正に実装していて, 後継~versionの応答を正しく処理できない
］ことが，既知または疑わしいならば、~HTTP10応答を送信してヨイ
— 例えば、次が既知であるときなど：
◎
A server MAY send an HTTP/1.0 response to a request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as＼
</p>

<ul>
	<li>
~clientが、［
`~version番号$を正しく構文解析する
］ことに失敗する。
◎
when a client fails to parse the version number correctly or＼
</li>
	<li>
`中継者$が、所与の［
~protocolの`~minor~version$
］に自身が適合しないときにも， `HTTP-version$p を盲目的に回送する。
◎
when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol.＼
</li>
</ul>

<p>
そのような［
~protocolの降格
］は、［
特定の~client属性により誘発されたもの
］でない限り，遂行されるベキでない
— 例えば：
1 個~以上の要請~header（例： `User-Agent$h ）が、［［
~errorにあることが既知である，ある~client
【~client実装~version】
］が送信する値
］に，一意に合致するときなど。
◎
Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.
</p>
</div>

<div class="p">

<p>
~HTTPの~version付けは、次を意図して設計されている：
◎
The intention of HTTP's versioning design is that＼
</p>

<ul>
	<li>
`~major$番号が増分されるのは、［
互換でない~message構文が導入される
］場合に限られる。
◎
the major number will only be incremented if an incompatible message syntax is introduced, and that＼
</li>
	<li>
`~minor$番号が増分されるのは、~protocolに加えられた変更sにより，［
~message意味論が追加されるか,
`送信者$に追加的な能力が含意される
］場合に限られる。
◎
the minor number will only be incremented when changes made to the protocol have the effect of adding to the message semantics or implying additional capabilities of the sender.＼
</li>
</ul>

<p>
しかしながら、［
`2068$R から `2616$R までに導入された変更点
］に対しては，`~minor~version$は増分されていない。
また，この改訂では、［
~protocolに対するそのような変更s
］は，特に避けられている。
◎
However, the minor version was not incremented for the changes introduced between [RFC2068] and [RFC2616], and this revision has specifically avoided any such changes to the protocol.
</p>
</div>

<div class="p">
<p>
`受信者$は：
◎
↓</p>

<ul>
	<li>
受信した~HTTP~messageが［
自身が実装する`~major~version$番号 `A^var を伴いつつ，
自身が実装するものより高い`~minor~version$番号 `B^var を伴う
］ときには、その~messageを，［
`B^var は、 `A^var の中で 自身が適合する，最も高い`~minor~version$であった
］かのように処理するベキである。
◎
When an HTTP message is received with a major version number that the recipient implements, but a higher minor version number than what the recipient implements, the recipient SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant.＼
</li>
	<li>
［
自身がまだ~supportを指示していないうちに，［
自身が~supportするより高い`~minor~version$を伴う~message
］が送信されてきた
］ときには、その~messageを［［
同じ`~major~version$のどの実装
］からも安全に処理できる程度に，十分に後方-互換である
］ものと見做せる。
◎
A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.
</li>
</ul>

</div>

		</section>
		<section id="section-2.7">
<h3 title="Uniform Resource Identifiers">2.7. URI</h3>

<p>
~HTTP~~全体に渡り、
`~URI^dfn
（ Uniform Resource Identifiers `3986$R — 統一的~資源~識別子）が，［
`資源$を識別するための手段
］に利用される。
~URI参照は、［
要請を~targetするため ／
~redirectを指示するため ／
関係性を定義する
］ために利用される。
◎
Uniform Resource Identifiers (URIs) [RFC3986] are used throughout HTTP as the means for identifying resources (Section 2 of [RFC7231]). URI references are used to target requests, indicate redirects, and define relationships.
</p>

<p>
下に挙げる各種~定義は、~URIの汎用~構文から採用されている：
【 ";" 以下の~commentは訳者補足】
◎
↓</p>

<pre class="bnf">
`URI-reference@p = &lt;URI-reference, `3986-4.1$rfc&gt; ; `~URI参照^com
`absolute-URI@p  = &lt;absolute-URI, `3986-4.3$rfc&gt; ; `絶対~URI^com
`relative-part@p = &lt;relative-part, `3986-4.2$rfc&gt; ; `相対~URI（~query以下を除く）^com
`scheme@p        = &lt;scheme, `3986-3.1$rfc&gt; ; `~URI~scheme^com
`authority@p     = &lt;authority, `3986-3.2$rfc&gt; ; `権限^com
`uri-host@p      = &lt;`host@p, `3986-3.2.2$rfc&gt; ; `~host^com
`port@p          = &lt;port, `3986-3.2.3$rfc&gt; ; `~port^com
`path-abempty@p  = &lt;path-abempty, `3986-3.3$rfc&gt; ; `~path（空もあり）^com
`segment@p       = &lt;segment, `3986-3.3$rfc&gt; ; `~pathの一階層^com
`query@p         = &lt;query, `3986-3.4$rfc&gt; ; `~query^com
`fragment@p      = &lt;fragment, `3986-3.5$rfc&gt; ; `素片~識別子^com
</pre>

<p>
加えて，次の規則も定義される：
◎
↓</p>

<pre class="bnf">
`absolute-path@p = 1*( "/" `segment$p )
`partial-URI@p   = `relative-part$p [ "?" `query$p ]
</pre>

<div class="p">

<p>
`absolute-path$p 規則は、［
空でない `path$p 成分を包含し得る~protocol要素
］用に定義される。
（この規則は、［
"`//^c" から始まる `path^p
］を許容しない点で，［
`URI-reference$p における空 `path^p の利用
］を許容していた `3986$R の `path-abempty^p 規則から少し相違する）。
◎
The definitions of "URI-reference", "absolute-URI", "relative-part", "scheme", "authority", "port", "host", "path-abempty", "segment", "query", and "fragment" are adopted from the URI generic syntax. An "absolute-path" rule is defined for protocol elements that can contain a non-empty path component. (This rule differs slightly from the path-abempty rule of RFC 3986, which allows for an empty path to be used in references, and path-absolute rule, which does not allow paths that begin with "//".)＼
</p>

<p>
`partial-URI$p 規則は、［
相対~URIを包含できるが，その中に `fragment$p 成分は包含できない
］ような~protocol要素~用に定義される。
◎
A "partial-URI" rule is defined for protocol elements that can contain a relative URI but not a fragment component.
</p>

<p class="trans-note">【
`path@p
— `3986-3.3$rfc による定義を指すように思われるが、明示的な参照は記されていない。
`*-path^p, `path-*^p も含めた総称のようにも思われる。
】【
相対~URI — `relative-ref^p, `3986-4.2$rfc
】</p>

</div>

<div class="p">

<p>
~HTTPにおける，［
~URI参照を許容する 各~protocol要素
］では、その~ABNF生成規則により，［
要素に許容されるのは，次のいずれかである
］ことを指示することになる：
◎
Each protocol element in HTTP that allows a URI reference will indicate in its ABNF production whether the element allows＼
</p>

<ul>
	<li>
任意の形による参照（ `URI-reference$p ）
◎
any form of reference (URI-reference),＼
</li>
	<li>
`absolute-form$p（ `absolute-URI$p ）による~URIのみ
◎
only a URI in absolute form (absolute-URI),＼
</li>
	<li>
`path$p 成分, および `query$p 成分（省略可能）のみ
◎
only the path and optional query components, or＼
</li>
	<li>
前項と前前項の組合n
◎
some combination of the above.＼
</li>
</ul>

<p>
他から指示されない限り、~URI参照は，`実効~要請~URI$に相対的に構文解析される。
◎
Unless otherwise indicated, URI references are parsed relative to the effective request URI (Section 5.5).
</p>

</div>

			<section id="section-2.7.1">
<h4 title="http URI Scheme">2.7.1. `http^c ~URI~scheme</h4>

<p>
"`http^c" ~URI~schemeは、ここにて定義される：
その目的は、［［
所与の `port$p 上の~TCP （`0793$R）接続
］を~listenしていると~~見込まれる~HTTP`生成元~server$
］により統治される階層的 名前空間への結付けに則って，【資源の】識別子を創出することである。
◎
The "http" URI scheme is hereby defined for the purpose of minting identifiers according to their association with the hierarchical namespace governed by a potential HTTP origin server listening for TCP ([RFC0793]) connections on a given port.
</p>

<pre class="bnf">
`http-URI@p = "http:" "//" `authority$p `path-abempty$p [ "?" `query$p ]
            <del>[ "#" `fragment$p ]</del>
</pre>

<p class="trans-note">【
`fragment^p 部分の削除は、`4251$errataによる~~修正（ Verified: 2015-02-01 ）による。
】</p>

<p>
"`http^c" ~URI用の`生成元~server$は、 `authority$p 成分により識別される
— それは、［
`host$p 識別子, および
省略可能な~TCP `port$p
］（`3986-3.2.2$rfc）を内包する。
［
階層的 `path$p, および
省略可能な `query$p
］成分は、［
その`生成元~server$の名前空間の中で，`~target資源$になり得るもの
］への識別子を~~供する。
`3986-3.5$rfcにて定義されるように、省略可能な `fragment$p 成分により，~URI~schemeから独立に，副次的な資源を間接的に識別することが可能になる。
◎
The origin server for an "http" URI is identified by the authority component, which includes a host identifier and optional TCP port ([RFC3986], Section 3.2.2). The hierarchical path component and optional query component serve as an identifier for a potential target resource within that origin server's name space. The optional fragment component allows for indirect identification of a secondary resource, independent of the URI scheme, as defined in Section 3.5 of [RFC3986].
</p>

<p>
`送信者$は、［
`host$p 識別子が空にされた "`http^c" ~URI
］を`生成し$てはナラナイ。
そのような~URI参照を処理する`受信者$は、それを妥当でないものとして却下しなければナラナイ。
◎
A sender MUST NOT generate an "http" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.
</p>

<p>
`host$p 識別子が~IP~addressとして供された場合、［
その~IP~addressにて指示された~TCP `port$p
］上の~listener（もし在れば）が，`生成元~server$になる。
`host$p が登録-済みの名前である場合、その名前は，［
その`生成元~server$の~addressを見出す
］ための間接的~識別子として，［
~DNSなどの名前~解決~service
］にて利用される。
`port$p 下位成分が，空 または与えられていない場合の既定の~TCP~portは、 80 （ WWW ~service用に予約された~port）になる。
◎
If the host identifier is provided as an IP address, the origin server is the listener (if any) on the indicated TCP port at that IP address. If host is a registered name, the registered name is an indirect identifier for use with a name resolution service, such as DNS, to find an address for that origin server. If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default.
</p>

<p>
所与の~URIが `authority$p 成分を伴うとしても、［
その `host$p ＆ `port$p 上の接続を~listenしている~HTTP`~server$が常にある
］ことを含意するわけではないことに注意。
~URIは，誰もが創出できる。
`authority$p 成分が決定するものは、［
誰が，［
識別される`資源$を~targetする要請
］に対し `権限的$に応答する権利を持つか
］である。
その名前空間は、［
登録-済みの 名前＆~IP~address
］の委任される資質により，連合される
— それは、［
指示された `host$p ＆ `port$p, および
そこに~HTTP~serverが在るかどうか
］の統制に基づく。
権限の確立に関係する~securityの考慮点については、 `9.1$sec を見よ。
◎
Note that the presence of a URI with a given authority component does not imply that there is always an HTTP server listening for connections on that host and port. Anyone can mint a URI. What the authority component determines is who has the right to respond authoritatively to requests that target the identified resource. The delegated nature of registered names and IP addresses creates a federated namespace, based on control over the indicated host and port, whether or not an HTTP server is present. See Section 9.1 for security considerations related to establishing authority.
</p>

<div class="p">

<p>
"`http^c" ~URIが［［
指示された`資源$への~access
］を呼び出す文脈
］の下で利用されるときは：
◎
When an "http" URI is used within a context that calls for access to the indicated resource,＼
</p>

<ul>
	<li>
<p>
`~client$は、次による~accessを試みてヨイ：
◎
a client MAY attempt access by＼
</p>
		<ol>
			<li>
`host$p から~IP~addressへ解決する。
◎
resolving the host to an IP address,＼
</li>
			<li>
その~addressの, 指示された `port$p 上への，~TCP接続を確立する。
◎
establishing a TCP connection to that address on the indicated port, and＼
</li>
			<li>
~HTTP要請`~message$を
— ~URIを識別する~data （`5$sec）を包含させた上で —
`~server$へ送信する。
◎
sending an HTTP request message (Section 3) containing the URI's identifying data (Section 5) to the server.＼
</li>
		</ol>
	</li>
	<li>
~serverが、前項の要請に対し，［
`7231-6$rfc にて述べられるように，暫定的（`7231-6.2$rfc）でない~HTTP応答`~message$で応答する
］ならば、その応答は［
~clientの要請に対する`権限的$な回答
］と見なされる。
◎
If the server responds to that request with a non-interim HTTP response message, as described in Section 6 of [RFC7231], then that response is considered an authoritative answer to the client's request.
</li>
</ul>

</div>

<p>
~HTTPは ~transport~protocolに依存しないが、
"`http^c" `scheme$p は，~TCP~based~serviceに特有である
— 名前~委任の過程で権限を確立するときに，~TCPに依存するので。
［
何らかの他の下層~接続~protocol
］に基づく~HTTP~serviceは、大概は，異なる~URI~schemeを利用して識別されることになるであろう
— ちょうど，（下に述べる） "`https$c" `scheme$p が［
`端点間$の~secure化された接続を要求する`資源$
］に利用されるのと同様に。
他の~protocolも［
"`http^c" の下で識別される資源への~access
］を供するために利用され得る
— 権限的~interfaceのみが，~TCPに特有になる。
◎
Although HTTP is independent of the transport protocol, the "http" scheme is specific to TCP-based services because the name delegation process depends on TCP for establishing authority. An HTTP service based on some other underlying connection protocol would presumably be identified using a different URI scheme, just as the "https" scheme (below) is used for resources that require an end-to-end secured connection. Other protocols might also be used to provide access to "http" identified resources -- it is only the authoritative interface that is specific to TCP.
</p>

<p>
［
`authority$p （権限）用の~URIの汎用~構文
］には、［［
~URI内に利用者~認証~情報を内包させる
］ための，非推奨にされた
`userinfo@p
下位成分（`3986-3.2.1$rfc）
］も含まれている。
一部の実装は、 `userinfo^p 成分を，［
認証~情報の内部~環境設定
］に用立てる
— ［
~command呼出し時の~option,
環境設定~file,
~bookmark~list
］などの中など。
そのような利用eは［
利用者~識別子や~password
］を公開するであろうが。
`送信者$は、 "`http^c" ~URI参照が［
`要請~target$または`~header値$
］として~message内に`生成され$るときに，［
`userinfo$p 下位成分（および その "`@^c" 区切子）
］を`生成し$てはナラナイ。
`受信者$は、［
信用できない源から受信される "`http^c" ~URI参照
］を利用する前に， `userinfo$p を構文解析した上で，在る場合は~errorとして扱うベキである
—
それは、~phishing攻撃の~~目的で，権限を隠蔽するために利用された可能性が高いので。
【`5964$errataに報告あり（ Reported: 2020-01-23 ）：詳細は参照先に。】
◎
The URI generic syntax for authority also includes a deprecated userinfo subcomponent ([RFC3986], Section 3.2.1) for including user authentication information in the URI. Some implementations make use of the userinfo component for internal configuration of authentication information, such as within command invocation options, configuration files, or bookmark lists, even though such usage might expose a user identifier or password. A sender MUST NOT generate the userinfo subcomponent (and its "@" delimiter) when an "http" URI reference is generated within a message as a request target or header field value. Before making use of an "http" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.
</p>

			</section>
			<section id="section-2.7.2">
<h4 title="https URI Scheme">2.7.2. `https^c ~URI~scheme</h4>

<p>
"`https^c" ~URI~schemeは、ここにて定義される：
その目的は
— ［
TLS で~secure化された接続 （`5246$R）
］用に，［
所与の~TCP `port$p を~listenしていると~~見込まれる~HTTP`生成元~server$
］により統治される階層的~名前空間への結付けに則って —
識別子を創出することである。
◎
The "https" URI scheme is hereby defined for the purpose of minting identifiers according to their association with the hierarchical namespace governed by a potential HTTP origin server listening to a given TCP port for TLS-secured connections ([RFC5246]).
</p>

<div class="p">

<p>
"`http$c" `scheme$p に対し 上に挙げた，すべての要件は、
"`https^c" `scheme$p にも課される
— ただし／加えて：
◎
All of the requirements listed above for the "http" scheme are also requirements for the "https" scheme,＼
</p>

<ul>
	<li>
`port$p 下位成分が［
空／与えられていない
］ときの既定の~TCP~portは， 80 ではなく 443 になる。
◎
except that TCP port 443 is the default if the port subcomponent is empty or not given, and＼
</li>
	<li>
`~UA$は、最初の~HTTP要請の送信に先立って，［
その`生成元~server$への接続が，［
`端点間$の強い暗号化
］の利用を通して，~secure化されている
］ことを確保しなければナラナイ。
◎
the user agent MUST ensure that its connection to the origin server is secured through the use of strong encryption, end-to-end, prior to sending the first HTTP request.
</li>
</ul>

</div>

<pre class="bnf">
`https-URI@p = "https:" "//" `authority$p `path-abempty$p [ "?" `query$p ]
            <del>[ "#" `fragment$p ]</del>
</pre>

<p class="trans-note">【
`fragment^p 部分の削除は、`4252$errataによる~~修正（ Verified: 2015-02-01 ）による。
】</p>

<p>
"`https^c" ~URI~schemeは、権限を確立する際に，~TLSと~TCPの両者に依存することに注意。
［
"`https^c" `scheme$p を介して可用にされた`資源$
］は、
"`http$c" `scheme$p を伴うものと，同一性を共有しない
— それらの資源~識別子が［
同じ権限（同じ~TCP~portを~listenしている同じ~host）
］を指示するとしても。
それらは 別個な名前空間であり，別個な`生成元~server$と見なされる。
しかしながら、［
~host~domain全体に適用されるように定義された，~HTTPに対する拡張
— ~Cookie~protocol `6265$R など
］により，［
ある~serviceから設定された情報
］による［
~host~domainに合致する~groupに属する，他の~serviceとの通信
］への影響iが許容されることもある。
◎
Note that the "https" URI scheme depends on both TLS and TCP for establishing authority. Resources made available via the "https" scheme have no shared identity with the "http" scheme even if their resource identifiers indicate the same authority (the same host listening to the same TCP port). They are distinct namespaces and are considered to be distinct origin servers. However, an extension to HTTP that is defined to apply to entire host domains, such as the Cookie protocol [RFC6265], can allow information set by one service to impact communication with other services within a matching group of host domains.
</p>

<p>
［［
"`https^c" の下で識別される`資源$
］への権限的~access
］用の処理nは、 `2818$R にて定義される。
◎
The process for authoritative access to an "https" identified resource is defined in [RFC2818].
</p>

			</section>
			<section id="section-2.7.3">
<h4 title="http and https URI Normalization and Comparison">2.7.3. http／https ~URI の正規化と比較</h4>

<p>
［
"`http$c" ／ "`https$c"
］`scheme$p は，~URIの汎用~構文に適合するので、そのような~URIは，［
`3986-6$rfc にて定義される~algo
］に則って，［
上で述べられた，それぞれの `scheme$p に対する既定~port
］を利用して，正規化され, 比較される。
◎
Since the "http" and "https" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in Section 6 of [RFC3986], using the defaults described above for each scheme.
</p>

<p>
［
~portが［
`scheme$p に対する既定の~port
］に等しい
］ならば， `port$p 下位成分は省略するのが、正規の形である。
空な `path$p 成分は、［［
`OPTIONS$m 要請の`要請~target$
］として， `absolute-form$p で利用されている
］場合を除き，絶対~path "`/^c" に等価であり、正規の形においては，代わりに ~path "`/^c" を供する。
`scheme$p＆`host$p は、文字大小無視であり，正規には小文字により供される
— 他のすべての成分は、文字大小区別の下で比較される。
`reserved^p 集合（ `3986-2.2$rfc ）に属さない どの文字も、［
それを~percent符号化した~octet列（`3986-2.1$rfc）
］に等価になる：
正規の形では，それらは符号化しない。
◎
If the port is equal to the default port for a scheme, the normal form is to omit the port subcomponent. When not being used in absolute form as the request target of an OPTIONS request, an empty path component is equivalent to an absolute path of "/", so the normal form is to provide a path of "/" instead. The scheme and host are case-insensitive and normally provided in lowercase; all other components are compared in a case-sensitive manner. Characters other than those in the "reserved" set are equivalent to their percent-encoded octets: the normal form is to not encode them (see Sections 2.1 and 2.2 of [RFC3986]).
</p>
<!-- 
reserved      = gen-delims / sub-delims
 gen-delims    = ":/?#[]@"
 sub-delims    = "!$&'()*+,;="
-->
<div class="example">

<p>
例えば、次の 3 つの~URIは、等価になる：
◎
For example, the following three URIs are equivalent:
</p>

<pre>
http://example.com:80/~smith/home.html
http://EXAMPLE.com/%7Esmith/home.html
http://EXAMPLE.com:/%7esmith/home.html
</pre>

</div>

			</section>
		</section>
	</section>
	<section id="section-3">
<h2 title="Message Format">3. ~message形式</h2>

<div class="p">
<p>
すべての`~HTTP11$~messageは、 `start-line$p と, それに後続する~octet列からなる。
後者は，［
Internet Message Format `5322$R に類似な形式
］であり、次の並びからなる：
◎
All HTTP/1.1 messages consist of a start-line followed by a sequence of octets in a format similar to the Internet Message Format [RFC5322]:＼
</p>

<ul>
	<li>
~zero個以上の`~header$からなる
`~header節@
（ “header section” ）
◎
zero or more header fields (collectively referred to as the "headers" or the "header section"),＼
</li>
	<li>
~header節の終端を指示する`空~行l$
◎
an empty line indicating the end of the header section, and＼
</li>
	<li>
省略可能な`~message本体$
◎
an optional message body.
</li>
</ul>

</div>

<pre class="bnf">
`HTTP-message@p   = `start-line$p
                 *( `header-field$p `CRLF$P )
                 <dfn id="empty-line">CRLF</dfn>
                 [ `message-body$p ]
</pre>

<div class="p">

<p>
~HTTP~messageを構文解析するための通常の手続-は、次の様になる：
◎
The normal procedure for parsing an HTTP message is to＼
</p>

<ol>
	<li>
`start-line$p の構造を読取る。
◎
read the start-line into a structure,＼
</li>
	<li>
`空~行l$に遭遇するまで，各`~header$を［
`~header名$を~keyとする~hash~table
］に読取る。
◎
read each header field into a hash table by field name until the empty line, and then＼
</li>
	<li>
前段までに構文解析された~dataを利用して、［
`~message本体$が予期されるかどうか
］を決定する。
◎
use the parsed data to determine if a message body is expected.＼
</li>
	<li>
~message本体の~~存在が指示された場合、それを~octetの~streamとして，［
`~message本体~長さ$に等しい量だけ読取られるか, 接続が~closeされる
］まで，読取る。
◎
If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.
</li>
</ol>

</div>

<p>
`受信者$は、~HTTP~messageを，［
~US-ASCII `USASCII$r の~supersetである符号化法による，~octet列
］として構文解析しなければナラナイ。
特定の符号化法について目を向けずに，~HTTP~messageを［
~Unicode文字の~streamとして構文解析する
］ことは、~securityの脆弱性をもたらす
— それは、［
~octet `LF$P を包含する，妥当でない~multibyte文字~並び
］の取扱いが、文字列~処理~libraryにより，まちまちなことに因る。
文字列~based構文解析器を ~protocol要素の中で安全に利用できるのは、その要素が，~messageから抽出された後に限られる
—
~messageを構文解析して，個々の~headerを取り出した後の`~header値$の中など。
◎
A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field-value after message parsing has delineated the individual fields.
</p>

<p>
~HTTP~messageは、［
増分的に処理する／`下流$へ回送する
］ときには，~streamとして構文解析できる。
しかしながら，`受信者$は、増分的~送達による部分的~messageには，依拠できない
—
一部の実装は、［
~network効率性,
~security検査,
`~payload$`形式変換$
］の~~目的で，~message回送を~bufferしたり遅延させるので。
◎
An HTTP message can be parsed as a stream for incremental processing or forwarding downstream. However, recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or payload transformations.
</p>

<div class="p">

<p>
`送信者$は、［
`start-line$p と最初の`~header$の合間
］に`空白$を送信してはナラナイ。
そのような`空白$を受信した`受信者$は、次のいずれかを行わなければナラナイ：
◎
A sender MUST NOT send whitespace between the start-line and the first header field. A recipient that receives whitespace between the start-line and the first header field MUST either＼
</p>
<ul>
	<li>
~messageを妥当でないものとして却下する。
◎
reject the message as invalid or＼
</li>
	<li>
空白が先行する各~行lを，それ以上~処理せずに消費する（すなわち、［
適正に形成された~headerが受信されるか, または`~header節$が終了される
］まで，後続の, 空白が先行する どの行lも無視する）。
◎
consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).
</li>
</ul>
</div>

<p>
［
要請にそのような空白が在ること
］は、［
その~headerを無視させたり,
その後の行lを新たな要請として処理させる
］ような，~serverを騙す試みの~~可能性がある
— そのいずれにせよ、［
要請`連鎖$内の他の実装
］が，［
同じ~messageを異なるように解釈する
］場合に、~securityの脆弱性になり得る。
同様に，［
応答にそのような空白が在ること
］に対し、無視する~clientもあれば，構文解析を止める~clientもある。
◎
The presence of such whitespace in a request might be an attempt to trick a server into ignoring that field or processing the line after it as a new request, either of which might result in a security vulnerability if other implementations within the request chain interpret the same message differently. Likewise, the presence of such whitespace in a response might be ignored by some clients or cause others to cease parsing.
</p>

		<section id="section-3.1">
<h3 title="Start Line">3.1. `start-line^p</h3>

<div class="p">

<p>
~HTTP~messageは、［
~clientから~serverへ流れる要請
］か［
~serverから~clientへ流れる応答
］のいずれかになる。
この 2 つの型の~messageは、次の点でのみ相違する：
◎
An HTTP message can be either a request from client to server or a response from server to client. Syntactically, the two types of message differ only in＼
</p>

<ul>
	<li>
`start-line$p の構文は［
要請に対しては `request-line$p ／
応答に対しては `status-line$p
］になる。
◎
the start-line, which is either a request-line (for requests) or＼
</li>
	<li>
`~message本体$の長さを決定する~algo。
◎
a status-line (for responses), and in the algorithm for determining the length of the message body (Section 3.3).
</li>
</ul>
</div>

<p>
理論~上は、`~client$も要請を受信でき, `~server$も応答を受信できる
—
それらは `start-line$p 形式の相違点から判別できるので。
しかしながら，実施においては、~serverは，要請のみを予期するように実装され（応答は，未知なまたは妥当でない`要請~method$と解釈される）、~clientは，応答のみを予期するように実装されている。
◎
In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats, but, in practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method) and clients are implemented to only expect a response.
</p>

<pre class="bnf">
`start-line@p     = `request-line$p / `status-line$p
</pre>

<p class="trans-note">【
これは、~messageの “最初の行l（ first line ）” とも称されている。
】</p>

			<section id="section-3.1.1">
<h4 title="Request Line">3.1.1. `request-line^p</h4>

<p>
`request-line$p の構文は、次で与えられる：
◎
A request-line begins with a method token, followed by a single space (SP), the request-target, another single space (SP), the protocol version, and ends with CRLF.
</p>

<pre class="bnf">
`request-line@p   = `method$p `SP$P `request-target$p `SP$P `HTTP-version$p `CRLF$P
</pre>

<p>
`method$p `token^p は、［
`~target資源$上で遂行される`要請~method$
］を指示する。
要請~methodは、文字大小区別である。
◎
The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.
</p>

<pre class="bnf">
`method@p         = `token$p
</pre>

<p>
要請~methodについては、［
~HTTP~method~registryに関する情報や,
新たな~methodを定義する際の考慮点
］も含めて，この仕様の `7231-4$rfc にて定義される。
◎
The request methods defined by this specification can be found in Section 4 of [RFC7231], along with information regarding the HTTP method registry and considerations for defining new methods.
</p>

<p>
`request-target$p は、［
要請を適用する~targetになる`資源$
］を識別するものであり， `5.3$sec にて定義される。
◎
The request-target identifies the target resource upon which to apply the request, as defined in Section 5.3.
</p>

<p>
`受信者$は、［
`request-line$p を構文解析して（`3.5$sec）各~成分を取り出す
］ときに，概して`空白$で分割する
— それら 3 つの成分には，空白は許容されないので。
が、あいにく，一部の`~UA$は［
~hypertext参照に見出される空白
］を適正に［
符号化する／除外する
］ことに失敗する
— その結果，許容されない それらの文字を `request-target$p 内に送信することになる。
◎
Recipients typically parse the request-line into its component parts by splitting on whitespace (see Section 3.5), since no whitespace is allowed in the three components. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent in a request-target.
</p>

<div class="p">
<p>
`受信者$は、妥当でない `request-line$p に対しては：
◎
Recipients of an invalid request-line＼
</p>

<ul>
	<li>
<p>
次のいずれかで応答するベキである：
◎
SHOULD respond with either＼
</p>

		<ul>
			<li>`400$st ~error
◎
a 400 (Bad Request) error or＼
</li>
			<li>
［
適正に符号化された `request-target$p
］を伴う `301$st ~redirect
◎
a 301 (Moved Permanently) redirect with the request-target properly encoded.＼
</li>
		</ul>
	</li>
	<li>
~redirectせずに，要請を自動訂正して処理しようと試みるベキでない
— 妥当でない `request-line$p は、要請`連鎖$沿いにある~security~filterを迂回するために，故意に細工されている~~可能性もあるので。
◎
A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.
</li>
</ul>
</div>

<div class="p">
<p>
~HTTPは、 `2.5$sec にて述べたように，
`request-line$p の長さに対する定義済み制限を設置しない。
`~server$は：
◎
HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.5.＼
</p>

<ul>
	<li>
［
自身が実装するより長い `method$p
］を受信したときは、状態s~code `501$st で応答するベキである。
◎
A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code.＼
</li>
	<li>
［［
自身が望んで構文解析する どの`~URI$
］よりも長い `request-target$p
］を受信したときは、 `414$st で応答しなければナラナイ。
◎
A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 6.5.12 of [RFC7231]).
</li>
</ul>
</div>

<p>
実施においては、
`request-line$p の長さには，様々な場当的な制限が見出される。
すべての~HTTP［`送信者$／`受信者$］に，［
この長さとして，最小限 ~octet数で 8000 以上を~supportする
］ことが`推奨される^2119。
◎
Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.
</p>

			</section>
			<section id="section-3.1.2">
<h4 title="Status Line">3.1.2. 状態s行l</h4>

<p>
応答~messageの最初の行lは，状態s行lと呼ばれ、その構文は，次で与えられる：
◎
The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, another space, a possibly empty textual phrase describing the status code, and ending with CRLF.
</p>

<pre class="bnf">
`status-line@p = `HTTP-version$p `SP$P `status-code$p `SP$P `reason-phrase$p `CRLF$P
</pre>

<div class="p">

<p>
`status-code$p 要素は，応答の`状態s~code$を~~表す 3 桁の整数~codeであり、`~server$が［
対応ng，`~client$からの要請
］を，解して, 充足しようと試みた結果を述べる。
応答~messageの残りの部分は、その状態s~codeに定義されている意味論に照らし合わせて，解釈される。
`状態s~code$の意味論についての，次も含む情報は、 `7231-6$rfc を見よ：
◎
The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request. The rest of the response message is to be interpreted in light of the semantics defined for that status code. See Section 6 of [RFC7231] for information about the semantics of status codes, including＼
</p>

<ul>
	<li>
状態s~codeの最初の桁で指示される，応答の`応答class$
◎
the classes of status code (indicated by the first digit),＼
</li>
	<li>
この仕様にて定義される状態s~code
◎
the status codes defined by this specification,＼
</li>
	<li>
新たな状態s~codeを定義するにあたっての考慮点
◎
considerations for the definition of new status codes, and＼
</li>
	<li>
~IANA~registry
◎
the IANA registry.
</li>
</ul>
</div>

<pre class="bnf">
`status-code@p    = 3`DIGIT$P
</pre>

<p>
`reason-phrase$p 要素は、もっぱら［
数的 `状態s~code$に結付けられた，~textな記述
］を供する目的で存在する（空でもよい）
— そのほとんどは［
対話的~text~clientにより より頻繁に利用されていた，早期の~Internet~app~protocol
］に， out of deference to 【従わない？】。
`~client$は、`reason-phrase$p の内容を無視するベキである。
◎
The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients. A client SHOULD ignore the reason-phrase content.
</p>

<pre class="bnf">
`reason-phrase@p  = *( `HTAB$P / `SP$P / `VCHAR$P / `obs-text$p )
</pre>

			</section>
		</section>
		<section id="section-3.2">
<h3 title="Header Fields">3.2. ~header（ ~header~field ）</h3>

<p class="trans-note">【
この訳に現れる語 “<em >~header</em>” は、 “`~header節$” を除き，ほぼすべて “~header~field” の略記である。
】</p>

<p>
各
<dfn>~header</dfn>
（ `header-field^p ）の構文は、次で与えられる：
◎
Each header field consists of a case-insensitive field name followed by a colon (":"), optional leading whitespace, the field value, and optional trailing whitespace.
</p>

<pre class="bnf">
`header-field@p   = `field-name$p ":" `OWS$p `field-value$p `OWS$p

`field-name@p     = `token$p
`field-value@p    = *( `field-content$p / `obs-fold$p )
`field-content@p  = `field-vchar$p [ 1*( `SP$P / `HTAB$P ) `field-vchar$p ]
`field-vchar@p    = `VCHAR$P / `obs-text$p

`obs-fold@p       = `CRLF$P 1*( `SP$P / `HTAB$P )
               ; <span
	class="comment"
	title="obsolete line folding ; see section 3.2.4"
	>廃用にされた行l折返し — `3.2.4$secを見よ</span>
</pre>

<p class="trans-note">【
`4189$errataによる~~修正あり（ Held for Document Update: 2015-04-22 ）（詳細は参照先に）：
】</p>

<p>
`field-name$p は、文字大小無視であり，`~header$の名前
— `~header名@ —
を与える。
`field-value$p は、その~headerの値
— `~header値@ —
を与える。
◎
↑</p>

<p>
`field-name$p ~tokenは、対応ng `field-value$p を，［
その名前の~headerにより定義される意味論
］を有するものと定める。
例えば， `Date$h ~headerは、［
それが出現する~messageの，出生時の時刻印
］を包含しているものと定義される。
◎
The field-name token labels the corresponding field-value as having the semantics defined by that header field. For example, the Date header field is defined in Section 7.1.1.2 of [RFC7231] as containing the origination timestamp for the message in which it appears.
</p>

			<section id="section-3.2.1">
<h4 title="Field Extensibility">3.2.1. ~headerの拡張能</h4>

<p>
`~header$は、いくらでも拡張-可能である：
（大概は新たな意味論を定義するような）新たな`~header名$の導入にも,
所与の~messageに利用される~headerの個数にも，制限はない。
既存の~headerは、この仕様の各~文書, および
他の多くの~~外部~仕様にて定義される。
◎
Header fields are fully extensible: there is no limit on the introduction of new field names, each presumably defining new semantics, nor on the number of header fields used in a given message. Existing fields are defined in each part of this specification and in many other specifications outside this document set.
</p>

<div class="p">

<p>
新たな~headerは、次のいくつかが行われ得るように定義できる：
◎
New header fields can be defined such that,＼
</p>

<ul>
	<li>
`受信者$により解されるときの［
以前に定義された`~header$の解釈
］を，上書きしたり, 増強する。
◎
when they are understood by a recipient, they might override or enhance the interpretation of previously defined header fields,＼
</li>
	<li>
要請を評価する際の`事前条件$を定義する。
◎
define preconditions on request evaluation, or＼
</li>
	<li>
応答の意味を精緻化する。
◎
refine the meaning of responses.
</li>
</ul>

</div>

<div class="p">

<p>
`~proxy$は、各［
未認識`~header$
］を回送しなければナラナイ
— 次のいずれかの場合を除いて：
◎
A proxy MUST forward unrecognized header fields unless＼
</p>

<ul>
	<li>
その`~header名$が `Connection$h ~header値に~listされている。
◎
the field-name is listed in the Connection header field (Section 6.1) or＼
</li>
	<li>
`~proxy$がそのような~headerを，阻止する, あるいは`形式変換-$するように，特に環境設定されている。
◎
the proxy is specifically configured to block, or otherwise transform, such fields.＼
</li>
</ul>

<p>
他の`受信者$は、各［
未認識`~header$
］を無視するベキである。
◎
Other recipients SHOULD ignore unrecognized header fields.＼
</p>

<p>
これらの要件により、配備されている`中継者$における更新を事前に要求することなく，~HTTPの機能性を増強することが可能になる。
◎
These requirements allow HTTP's functionality to be enhanced without requiring prior update of deployed intermediaries.
</p>

</div>

<p>
定義される すべての`~header$は、 `7231-8.3$rfc にて述べられるように，
~IANAにより
"Message Headers" ~registryにて登録される~OUGHT。
◎
All defined header fields ought to be registered with IANA in the "Message Headers" registry, as described in Section 8.3 of [RFC7231].
</p>

			</section>
			<section id="section-3.2.2">
<h4 title="Field Order">3.2.2. ~headerの順序</h4>

<p>
`~header$が受信される順序は、`~header名$が互いに相違するものどうしでは，有意でない。
しかしながら、［
要請における `Host$h, 応答における `Date$h などの，`制御~data$を包含する~header
］を最初に送信することは，良実践とされる
— 実装は、より早期に，~messageを取扱わないものと裁定できるようになるので。
`~server$は、要請の`~header節$全体が受信されるまで，要請をその`~target資源$に適用してはナラナイ
—  後に続く~headerは、要請~処理に影響iするような［
`条件付き要請$ ／
認証~時の`資格証$ ／
故意に誤誘導するように重複された~header
］を内包することもあるので。
◎
The order in which header fields with differing field names are received is not significant. However, it is good practice to send header fields that contain control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible. A server MUST NOT apply a request to the target resource until the entire request header section is received, since later header fields might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing.
</p>

<div class="p">

<p>
次のいずれかの場合を除き、`送信者$は，同じ~message内に［
`~header名$が同じである複数の`~header$
］を`生成し$てはナラナイ：
◎
A sender MUST NOT generate multiple header fields with the same field name in a message unless either＼
</p>

<ul>
	<li>
その~header名に対する`~header値$~全体が，
`~commaで分離された~list＠#abnf.extension$
（すなわち，
<code>#(`values^p)</code>
）として定義されている。
◎
the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or＼
</li>
	<li>
その~header名は，よく知られた例外（下に注記される）である。
◎
the header field is a well-known exception (as noted below).
</li>
</ul>

</div>

<p>
`受信者$は、~messageの意味論を変更することなく［
`~header名$が同じである複数の`~header$
］を 1 個の［
"<code>`field-name$p: `field-value$p</code>" ~pair
］に
`結合-@
してヨイ
— ［
それらのうち，最初の`~header値$
］に，後続の各~header値を，現れた順に［
~commaで分離した上で, 付加する
］ことにより。
したがって、［
同じ`~header名$の，いくつかの~header
］が受信される順序は，［
結合された~header値の解釈
］において有意になる —
`~proxy$は、~messageを回送するときに，これらの`~header値$の順序を変更してはナラナイ。
◎
A recipient MAY combine multiple header fields with the same field name into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma. The order in which header fields with the same field name are received is therefore significant to the interpretation of the combined field value; a proxy MUST NOT change the order of these field values when forwarding a message.
</p>

<p class="note">注記：
`Set-Cookie^h ~header（`6265$R）は，~list構文を利用せず、実施においては，同じ応答~message内に複数~個~出現することが多い。
すなわち，［
同じ名前の複数の~headerに課される 上の要件
］に違反している。
それは， 1 個の `field-value$p に結合できないので、`受信者$は，
~headerを処理する際に
`Set-Cookie$h を特別~事例として取扱う~OUGHT。
（
詳細は `Kri2001$r
`付録 A.2.3＠http://arxiv.org/abs/cs.SE/0105018#appendix-A.2.3$
に）
◎
Note: In practice, the "Set-Cookie" header field ([RFC6265]) often appears multiple times in a response message and does not use the list syntax, violating the above requirements on multiple header fields with the same name. Since it cannot be combined into a single field-value, recipients ought to handle "Set-Cookie" as a special case while processing header fields. (See Appendix A.2.3 of [Kri2001] for details.)
</p>

			</section>
			<section id="section-3.2.3">
<h4 title="Whitespace">3.2.3. 空白</h4>

<p>
この仕様は、空白列（ linear whitespace ）の利用を記すときに，次の 3 つの規則を利用する：
◎
This specification uses three rules to denote the use of linear whitespace: OWS (optional whitespace), RWS (required whitespace), and BWS ("bad" whitespace).
</p>

<dl>
	<dt>`OWS@p （省略可能な空白）</dt>
	<dd>
<p>
この規則は、［
~zero個~以上の~octetからなる空白列
］が出現し得る所で利用される。
`送信者$は、各~protocol要素に対し：
◎
The OWS rule is used where zero or more linear whitespace octets might appear. For protocol elements＼
</p>

		<ul>
			<li>
［
読み易くするため，省略可能な空白が選好される所
］では、［
省略可能な空白を 1 個の `SP$P として`生成する$
］ベキである。
◎
where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP;＼
</li>
			<li>
他の所では、~messageを~filterする際に， `OWS$p を`生成する$ベキでない
— ただし、［
妥当でない／求まれてない
］~protocol要素
］を white out する
【空白に置換する？】
ために必要になる場合は除く。
◎
otherwise, a sender SHOULD NOT generate optional whitespace except as needed to white out invalid or unwanted protocol elements during in-place message filtering.
</li>
		</ul>
	</dd>

	<dt>`RWS@p （要求される空白）</dt>
	<dd>
この規則は、［
各~field~tokenを分離するために，［
1 個~以上の~octetからなる空白列
］が要求される
］ときに，利用される。
`送信者$は、 `RWS$p として 1 個の `SP$P を`生成する$ベキである。
◎
The RWS rule is used when at least one linear whitespace octet is required to separate field tokens. A sender SHOULD generate RWS as a single SP.
</dd>

	<dt>`BWS@p （“不良” 空白）</dt>
	<dd>
この規則は、［
もっぱら歴史的な理由のため，省略可能な空白が文法にて許容される所
］で利用される。
`送信者$は、~message内に `BWS$p を`生成し$てはナラナイ。
`受信者$は、~protocol要素を解釈する前に，そのような不良~空白を構文解析して除去しなければナラナイ。
◎
The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.
</dd>
</dl>

<pre class="bnf">
`OWS$p            = *( `SP$P / `HTAB$P )
               ; `省略可能な空白^com
`RWS$p            = 1*( `SP$P / `HTAB$P )
               ; `要求される空白^com
`BWS$p            = `OWS$p
               ; `“不良” 空白^com
</pre>

			</section>
			<section id="section-3.2.4">
<h4 title="Field Parsing">3.2.4. ~headerの構文解析</h4>

<p>
~messageは、［
個々の`~header名$に依存しない，汎用~algo
］を利用して構文解析される。
所与の`~header値$の内容は、~message解釈の今後の段階（通例的に，~messageの`~header節$全体が処理された後になる）まで，構文解析されない。
その帰結として、この仕様は，［
以前の版 【RFC 2068】 で行われていたような，各［
"`Field-Name: Field Value^c" ~pair
］を定義する~ABNF規則
］を利用しない。
代わりに、各［
登録-済みの`~header名$
］に則って命名される各種 ~ABNF規則
【例えば `Content-Length$p 】
を利用する
—
そこでの規則は、その~headerに対応する`~header値$（すなわち、汎用~header構文解析器により，`~header節$から `field-value$p が抽出された後の値）が妥当になるための文法を，定義する。
◎
Messages are parsed using a generic algorithm, independent of the individual header field names. The contents within a given field value are not parsed until a later stage of message interpretation (usually after the message's entire header section has been processed). Consequently, this specification does not use ABNF rules to define each "Field-Name: Field Value" pair, as was done in previous editions. Instead, this specification uses ABNF rules that are named according to each registered field name, wherein the rule defines the valid grammar for that field's corresponding field values (i.e., after the field-value has been extracted from the header section by a generic field parser).
</p>

<p>
`~header$における `field-name$p と~colonの合間には，`空白$は許容されない。
過去においては，［
そのような空白の取扱いにおける相違点
］から、
要請の経路制御／応答の取扱い
に，~securityの脆弱性が導かれていた。
［
~headerにそのような空白を内包するような要請~message
］を受信した`~server$は、状態s~code `400$st で応答して，それを却下しなければナラナイ。
`~proxy$は、~messageを`下流$に回送する前に，応答~messageから そのような空白すべてを除去しなければナラナイ。
◎
No whitespace is allowed between the header field-name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject any received request message that contains whitespace between a header field-name and colon with a response code of 400 (Bad Request). A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.
</p>

<p>
`~header値$の前後には、省略可能な空白（ `OWS$p ）が，先行したり, 後続し得る
—
ヒトから読み易くするため、 `field-value$p には， 1 個の `SP$P を先行させることが選好される。
~header値 自体は、頭部／尾部の`空白$を内包しない：
~header値の［
最初の非~空白~octetより前 ／ 最後の非~空白~octetより後
］に生じる `OWS$p は、［
~headerから~header値を抽出する
］ときには，構文解析器により除外される~OUGHT。
◎
A field value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field-value is preferred for consistent readability by humans. The field value does not include any leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field value or after the last non-whitespace octet of the field value ought to be excluded by parsers when extracting the field value from a header field.
</p>

<div class="trans-note">
<p>【
`5163$errataに報告あり（ Reported: 2017-10-20 ）：
】</p>
<blockquote>
`field-content$p 内の~tokenの合間にある，省略可能な空白の意味論は、すべて `SP^P と同じであり、それらの［
`SP^P ／ `HTAB^P
］並びは，［
~field値を解釈する前, あるいは~messageを下流に回送する前
］に 1 個の `SP^P に置換されてもヨイ。
◎
All optional whitespace between tokens in field-content has the same semantics as SP. Any sequence of SP / HTAB that occurs between tokens in field-content MAY be replaced with a single SP before interpreting the field value or forwarding the message downstream.
</blockquote>
</div>

<p>
歴史的に、~HTTP~header値は，複数~行lにも渡れるように拡張されていた
— 2 行l~目 以降の各~行lに， 1 個~以上の［
`SP$P や `HTAB$P
］を先行させること（ `obs-fold$p ）により。
この仕様は、［
~MIME型 `message/http$c の中
］を除いて，そのような行l折返しを非推奨にする。
`送信者$は、行l折返しを内包する（すなわち， `obs-fold$p 規則に合致する部分を包含するような `field-value$p がある）ような~messageを
— ~MIME型 `message/http^c への梱包を意図するときを除き —
`生成し$てはナラナイ。
◎
Historically, HTTP header field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the message/http media type (Section 8.3.1). A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type.
</p>

<p>
［
`message/http$c ~containerの中でない要請~message内
］に `obs-fold$p を受信したときは：
◎
↓</p>

<ul>
	<li>
<p>
`~server$は、次のいずれかを行わなければナラナイ：
◎
A server that receives an obs-fold in a request message that is not within a message/http container MUST either＼
</p>

		<ul>
			<li>
`400$st を送信して，~messageを却下する — それには，［［
廃用にされた行l折返しは，受容-可能でない
］ことを説明する表現
］が伴われることが好ましい。
◎
reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or＼
</li>
			<li>
［
`~header値$を解釈したり, ~messageを`下流$へ回送する
］に先立って、受信された各 `obs-fold$p を， 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
</li>
		</ul>
	</li>
	<li>
<p>
`~proxy$／`~gateway$は、次のいずれかを行わなければナラナイ：
◎
A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either＼
</p>

		<ul>
			<li>
~messageを破棄して， `502$st 応答に置換する — それには，［［
受容-可能でない行l折返しが受信された
］ことを説明する表現
］が伴われることが好ましい。
◎
discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or＼
</li>
			<li>
［
`~header値$を解釈したり, ~messageを`下流$へ回送する
］に先立って、受信された各 `obs-fold$p を， 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.
</li>
		</ul>
	</li>
	<li>
<p>
`~UA$は、次を行わなければナラナイ：
◎
A user agent that receives an obs-fold in a response message that is not within a message/http container MUST＼
</p>
		<ul>
			<li>
［
`~header値$を解釈する
］に先立って、受信された各 `obs-fold$p を， 1 個~以上の `SP$P ~octetで置換する。
◎
replace each received obs-fold with one or more SP octets prior to interpreting the field value.
</li>
		</ul>
</li>
</ul>

<p>
歴史的に，~HTTPは、ISO-8859-1 ~charset `ISO-8859-1$r の~textによる~header内容を許容し、他の~charsetの~supportは， `2047$R 符号化法の利用を通してのみ許容してきた。
実施においては、ほとんどの~HTTP~header値は［
~US-ASCII~charset `USASCII$r の~subset
］のみを利用している。
新たに定義される~headerは、その`~header値$を，~US-ASCII~octetに制限するベキである。
`受信者$は、`~header$内容 内の他の~octet（ `obs-text$p ）を，不透明な~dataとして扱うベキである。
◎
Historically, HTTP has allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. In practice, most HTTP header field values use only a subset of the US-ASCII charset [USASCII]. Newly defined header fields SHOULD limit their field values to US-ASCII octets. A recipient SHOULD treat other octets in field content (obs-text) as opaque data.
</p>

			</section>
			<section id="section-3.2.5">
<h4 title="Field Limits">3.2.5. ~headerの長さ制限</h4>

<p>
`2.5$sec にて述べたように、~HTTPは、［
各`~header$の長さ ／
`~header節$~~全体の長さ
］に，定義済み制限を設置しない。
実施においては、個々の~headerの長さには，特定の~header意味論に依存して，様々な場当的 制限が見出されることも多い。
◎
HTTP does not place a predefined limit on the length of each header field or on the length of the header section as a whole, as described in Section 2.5. Various ad hoc limitations on individual header field length are found in practice, often depending on the specific field semantics.
</p>

<p>
`~server$は、［
自身が望んで処理する大きさ
］を超えるような［
`~header$, または`~header節$
］を伴う要請を受信したときは，［
適切な `4xx$st 状態s~code
］で応答しなければナラナイ。
そのような~headerを【代わりに】無視することは、`要請~密入$攻撃に対する~serverの脆弱性を高めることになる。
◎
A server that receives a request header field, or set of fields, larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code. Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 9.5).
</p>

<p>
`~client$は、［
自身が望んで処理する大きさを超えるような`~header$
］を受信したときは、その~headerの意味論にて［
その値（たち）が落とされても，［
~message~frame法や, 応答の意味論
］を変更することなく，安全に無視できる
］ならば、その~headerを破棄するか, その`~header値$（たち）を切落してヨイ。
◎
A client MAY discard or truncate received header fields that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.
</p>

			</section>
			<section id="section-3.2.6">
<h4 title="Field Value Components">3.2.6. ~header値の成分</h4>

<p>
ほとんどの~HTTP~header値は、いくつかの共通な構文~成分（
`token$p,  `quoted-string$p , `comment$p
）を利用して定義され，それらの成分は［
`空白$や, 特定の区切子~文字
］で分離される。
区切子は［
~US-ASCII印字可能~文字（ `VCHAR^P ）のうち，
`token$p 内には許容されないもの
］の集合（
`DQUOTE$P および "<code>(),/:;&lt;=&gt;?@[\]{}</code>"
）から選択される：
◎
Most HTTP header field values are defined using common syntax components (token, quoted-string, and comment) separated by whitespace or specific delimiting characters. Delimiters are chosen from the set of US-ASCII visual characters not allowed in a token (DQUOTE and "(),/:;&lt;=&gt;?@[\]{}").
</p>

<pre class="bnf">
`token@p          = 1*`tchar$p

`tchar@p          = "!" / "#" / "$" / "%" / "&amp;" / "'" / "*"
               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
               / `DIGIT$P / `ALPHA$P
               ; <span
	class="comment"
	title="any VCHAR, except delimiters"
>区切子を除く，任意の `VCHAR$P</span>
</pre>

<p>
~textによる文字列は、二重引用符（ `DQUOTE^P ）で括られていれば，単独の値として構文解析される：
◎
A string of text is parsed as a single value if it is quoted using double-quote marks.
</p>

<pre class="bnf">
`quoted-string@p  = `DQUOTE$P *( `qdtext$p / `quoted-pair$p ) `DQUOTE$P
`qdtext@p         = `HTAB$P / `SP$P / %x21 / %x23-5B / %x5D-7E / `obs-text$p
`obs-text@p       = %x80-FF
</pre>

<!-- 
正誤表による修正済み（ "/" と "%x21" 合間の空白抜け
https://www.rfc-editor.org/errata/eid4891
-->

<p>
一部の~HTTP~headerでは、丸括弧（ "`(^c", "`)^c" ）で括ることで，~commentを内包させられる。
~commentが許容されるのは、［
`~header値$の定義の一部に "`comment$p" を包含している`~header$
］内に限られる：
◎
Comments can be included in some HTTP header fields by surrounding the comment text with parentheses. Comments are only allowed in fields containing "comment" as part of their field value definition.
</p>

<pre class="bnf">
`comment@p        = "(" *( `ctext$p / `quoted-pair$p / `comment$p ) ")"
`ctext@p          = `HTAB$P / `SP$P / %x21-27 / %x2A-5B / %x5D-7E / `obs-text$p
</pre>

<p>
構成子［
`quoted-string$p ／ `comment$p
］の中では、 1 個の~octetをエスケープする仕組みとして，~backslash（"`\^c"）を利用できる。
`受信者$は、 `quoted-string$p による値を処理するときには、
`quoted-pair$p を，それが［
~backslashの直後の~octetに置換されていた
］かのように取扱わなければナラナイ。
◎
The backslash octet ("\") can be used as a single-octet quoting mechanism within quoted-string and comment constructs. Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.
</p>

<pre class="bnf">
`quoted-pair@p    = "\" ( `HTAB$P / `SP$P / `VCHAR$P / `obs-text$p )
</pre>

<div class="p">
<p>
`送信者$は、［
`quoted-string$p ／ `comment$p
］内に `quoted-pair$p を`生成する$ベキでない
— 次に挙げる~octetをエスケープするときを除いて：
◎
↓</p>

<ul>
	<li>
`quoted-string$p の中の［
`DQUOTE$P, ~backslash
］
◎
A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string.＼
</li>
	<li>
`comment$p の中の［
丸括弧, ~backslash
］
◎
A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses ["(" and ")"] and backslash octets occurring within that comment.
</li>
</ul>
</div>

			</section>
		</section>
		<section id="section-3.3">
<h3 title="Message Body">3.3. ~message本体</h3>

<p>
~HTTP~messageの~message本体（もし在れば）は、［
その要請／応答の，
`~payload本体@
］を運ぶために，利用される。
`転送~符号法$が適用されて（`3.3.1$sec）いない限り、~message本体は，~payload本体と~~同じになる。
◎
The message body (if any) of an HTTP message is used to carry the payload body of that request or response. The message body is identical to the payload body unless a transfer coding has been applied, as described in Section 3.3.1.
</p>

<p class="trans-note">【
すなわち、~message本体は，~messageに埋め込まれた~dataそのままを意味し、~payload本体は，`転送~符号法$による符号化は［
施されていない／復号された
］~dataを意味する（端点からの視点では、~payload本体は，［
中継者を透過的な~~存在と見なした下で，実質的にやりとりされる本体~data
］と捉えられる）。
<!-- 
転送~符号法の機能が無い世界での~message本体
あるいは、転送~符号法により相互に変換し得るものを同一視した下での， ~dataの “同値類”
-->
この仕様の以前の版も含め、~payload本体は， “entity body（実体~本体）” と称されることもある。
】</p>

<pre class="bnf">
`message-body@p = *`OCTET$P
</pre>

<p>
［
~message内にいつ~message本体が許容されるか
］の規則は、要請と応答で相違する。
◎
The rules for when a message body is allowed in a message differ for requests and responses.
</p>

<p>
要請に~message本体が在ることは、［
`Content-Length$h または`Transfer-Encoding$h 
］~headerにより通達され、その~message~frame法が，`~method$の意味論に依存することはない
— ~methodが，~message本体の利用について何も定義していなくても。
◎
The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field. Request message framing is independent of method semantics, even if the method does not define any use for a message body.
</p>

<div class="p">
<p>
応答~内の~message本体の有無は、［
それが応答している要請の`~method$
］, および［
`応答~状態s~code$（`3.1.2$sec）
］の両者に依存する：
◎
The presence of a message body in a response depends on both the request method to which it is responding and the response status code (Section 3.1.2).＼
</p>

<ul>
	<li>
`HEAD$m 要請~methodに対する応答は、~message本体を決して内包しない
— 何故なら、応答~headerたち（
例： `Transfer-Encoding$h, `Content-Length$h, 等々
）が結付けられているとしても，それらは［
要請~methodが `GET$m であったとするときにとる値
］のみを指示するとされているので。
◎
Responses to the HEAD request method (Section 4.3.2 of [RFC7231]) never include a message body because the associated response header fields (e.g., Transfer-Encoding, Content-Length, etc.), if present, indicate only what their values would have been if the request method had been GET (Section 4.3.1 of [RFC7231]).＼
</li>
	<li>
`CONNECT$m 要請~methodに対する `2xx$st 応答は、~message本体を持たない代わりに，`~tunnel$~modeに切替える。
◎
2xx (Successful) responses to a CONNECT request method (Section 4.3.6 of [RFC7231]) switch to tunnel mode instead of having a message body.＼
</li>
	<li>
すべての［
`1xx$st／`204$st／`304$st 
］応答は、~message本体を内包しない。
◎
All 1xx (Informational), 204 (No Content), and 304 (Not Modified) responses do not include a message body.＼
</li>
	<li>
他のすべての応答は，~message本体を~~実際に内包する
— 長さ~zeroにもなり得るが。
◎
All other responses do include a message body, although the body might be of zero length.
</li>
</ul>

</div>

			<section id="section-3.3.1">
<h4 title="Transfer-Encoding">3.3.1. `Transfer-Encoding^h</h4>

<p>
`Transfer-Encoding$h ~headerは、一連の［
`~message本体$を形成するために，`~payload本体$に適用された（または適用されることになる）`転送~符号法$
］に対応する，一連の`転送~符号法~名$を~listする：
◎
The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body. Transfer codings are defined in Section 4.
</p>

<pre class="bnf">
`Transfer-Encoding@p = 1#`transfer-coding$p
</pre>

<div class="p">
<p>
`Transfer-Encoding$h は、［［
7-bit ~transport~service （`2045-6$rfc）越しに，~binary~dataの安全~transport
］を可能化するために設計された，~MIMEの `Content-Transfer-Encoding$h ~header
］に相似的である。
しかしながら，安全~transportは、転送~protocolを 8bit-clean にするという，異なる面に力点を置いている。
~HTTPにおける `Transfer-Encoding$h には、首に，次が意図されている：
◎
Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended＼
</p>

<ul>
	<li>
動的に`生成され$る`~payload$を正確aに区切る。
◎
to accurately delimit a dynamically generated payload and＼
</li>
	<li>
`~payload$に適用されている符号化法が、［
~transportの効率性のためのみ
］であるか, ［
選定された`資源$の特性に因る~securityのため
］かを判別する。
◎
to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.
</li>
</ul>

</div>

<div class="p">

<p>
`受信者$は、［
`~chunked転送~符号法$
］を構文解析できなければナラナイ
— 何故ならそれは、［
`~payload本体$~sizeが予め既知でない下で，~messageを~frame化する
］ときに，不可欠な役割を担うので。
◎
A recipient MUST be able to parse the chunked transfer coding (Section 4.1) because it plays a crucial role in framing messages when the payload body size is not known in advance.＼
</p>

<p>
`送信者$は：
◎
＼</p>
<ul>
	<li>
`~message本体$に対し，複数回の~chunk化を適用してはナラナイ（すなわち，すでに~chunk化された~messageを更に~chunk化することは許容されない）。
◎
A sender MUST NOT apply chunked more than once to a message body (i.e., chunking an already chunked message is not allowed).＼
</li>
	<li>
`~chunked$以外の`転送~符号法$が，要請`~payload本体$に適用された場合、［
~messageが適正に~frame化される
］ことを確保するために，~chunkedを
`最終~転送~符号法@
として適用しなければナラナイ。
◎
If any transfer coding other than chunked is applied to a request payload body, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed.＼
</li>
	<li>
`~chunked$以外の`転送~符号法$が，応答`~payload本体$に適用された場合、［
~chunkedを`最終~転送~符号法$として適用する
］か, または［
接続を~closeして~messageを終了させ
］なければナラナイ。
◎
If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.
</li>
</ul>
</div>

<div class="example">

<p>
例えば、次のものは：
◎
For example,
</p>

<pre class="lang-http">
Transfer-Encoding: gzip, chunked
</pre>

<p>
`~payload本体$が，~message本体を形成する際に［
"`gzip$c" 符号法を利用して圧縮された上で，
~chunked符号法を利用して~chunk化されている
］ことを指示する。
◎
indicates that the payload body has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.
</p>

</div>

<p>
`Content-Encoding$h と~~違って、
`Transfer-Encoding$h は，~messageの~propertyであり，表現のそれではない：
［
要請／応答
］`連鎖$沿いにある どの`受信者$も，受信された`転送~符号法$（たち）を復号したり,
`~message本体$に追加的な`転送~符号法$（たち）を適用してヨイ
— `Transfer-Encoding$h `~header値$にも，対応ng変更sを加えた上で。
［
符号化~parameterについての追加的な情報
］も、［
この仕様で定義されない他の~header
］にて供され得る。
◎
Unlike Content-Encoding (Section 3.1.2.1 of [RFC7231]), Transfer-Encoding is a property of the message, not of the representation, and any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field-value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.
</p>

<p>
`Transfer-Encoding$h は、［
`HEAD$m 要請に対する応答 ／
`GET$m 要請に対する `304$st 応答
］内に，送信されてヨイ
— この いずれも~message本体を内包しない —
それは、［
要請が条件付きでない `GET$m だとしたときに，`生成元~server$が~message本体に適用することになる`転送~符号法$
］を指示する。
しかしながら，この指示は，要求はされない
— 応答`連鎖$上にある どの`受信者$も（`生成元~server$も含む）、不要になり次第，転送~符号法を除去できるので。
◎
Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 4.1 of [RFC7232]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.
</p>

<div class="p">
<p>
`~server$は、次に挙げるどの応答にも，
`Transfer-Encoding$h ~headerを送信してはナラナイ：
◎
A server MUST NOT send a Transfer-Encoding header field in＼
</p>

<ul>
	<li>
状態s~codeに［
`1xx$st ／ `204$st 
］を伴う応答
◎
any response with a status code of 1xx (Informational) or 204 (No Content).＼
</li>
	<li>
`CONNECT$m 要請に対する `2xx$st 応答
◎
A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).
</li>
</ul>
</div>

<div class="p">
<p>
`Transfer-Encoding$h は、`~HTTP11$にて追加された。
［
~HTTP10の~supportのみを広告している実装
］は、一般に，転送~符号化-済み`~payload$を処理する方法を解さないものと見做されている：
◎
Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process a transfer-encoded payload.＼
</p>

<ul>
	<li>
`~client$は、［
~serverが~HTTP11（以上の~version）の要請を取扱える
］ことを知っていない限り，［
`Transfer-Encoding$h を包含している要請
］を送信してはナラナイ
— そのような知識は、［
特定の利用者~環境設定
］や［
先に受信された応答の`~version$を記憶する
］形をとるであろう。
◎
A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response.＼
</li>
	<li>
`~server$は、対応ng要請が［
~HTTP11（以上の~version）
］を指示していない限り，［
`Transfer-Encoding$h を包含している応答
］を送信してはナラナイ。
◎
A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later).
</li>
</ul>
</div>

<p>
`~server$は、［
自身が解さない`転送~符号法$を伴う要請~message
］を受信したときには， `501$st で応答するベキである。
◎
A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).
</p>

			</section>
			<section id="section-3.3.2">
<h4 title="Content-Length">3.3.2. `Content-Length^h</h4>

<p>
~messageが `Transfer-Encoding$h ~headerを持たないとき，
`Content-Length$h ~headerにより，［
`~payload本体$に見越される，~octet数による~size
］を，~decimal~~表現で供せる。
［
~payload本体を内包する~message
］における `Content-Length$h の`~header値$は、［
本体（および~message）が終端する所を決定するために必要とされる，~frame法~情報
］を供する。
［
~payload本体を内包しない~message
］における `Content-Length$h は、［
選定された`表現$の~size
］を指示する：
◎
When a message does not have a Transfer-Encoding header field, a Content-Length header field can provide the anticipated size, as a decimal number of octets, for a potential payload body. For messages that do include a payload body, the Content-Length field-value provides the framing information necessary for determining where the body (and message) ends. For messages that do not include a payload body, the Content-Length indicates the size of the selected representation (Section 3 of [RFC7231]).
</p>

<pre class="bnf">
`Content-Length@p = 1*`DIGIT$P
</pre>

<div class="example">

<p>
例：
◎
An example is
</p>

<pre class="lang-http">
Content-Length: 3495
</pre>

</div>

<p class="trans-note">【
構文としては，先頭の 0 も許容されているが、例えば "`011^c" を数として解釈するときは， 11 と見なすと見受けられる（先頭の 0 を 8 進数に解釈するなどとは述べられていない）。
】</p>

<p>
`送信者$は
⇒
`Transfer-Encoding$h ~headerを包含する どの~messageにも， `Content-Length$h ~headerを送信してはナラナイ。
◎
A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.
</p>

<div class="p">

<p>
`~UA$は：
◎
↓</p>

<ul>
	<li>
［
`Transfer-Encoding$h を送信しない
］, かつ［
同封される`~payload本体$用の意味が，`要請~method$に定義されている
］ときは、［
要請~message内に `Content-Length$h
］を送信するベキである。
例えば， `POST$m 要請においては、
`Content-Length$h ~headerは，その値が 0 であっても，通常は送信される（値 0 は`~payload本体$が空であることを指示する）。
◎
A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body. For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body).＼
</li>
	<li>
［
要請~messageが`~payload本体$を包含しない
］かつ［
~method意味論からも そのような本体は見越されない
］ときは、
`Content-Length$h ~headerを送信するベキでない。
◎
A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.
</li>
</ul>
</div>

<p>
`~server$は：
◎
↓</p>

<ul>
	<li>
［
`HEAD$m 要請に対する応答
］内に `Content-Length$h ~headerを送信してヨイ
— ただし，その際の`~header値$は、［
同じ要請に `GET$m ~methodが利用されたとするときに，応答の`~payload本体$~内に送信することになる~octet数
］に等しい，~decimal~~表現
］にしなければナラナイ。
◎
A server MAY send a Content-Length header field in a response to a HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.
</li>
<li>
［
条件付き `GET$m 要請に対する `304$st 応答
］内に `Content-Length$h ~headerを送信してヨイ
— ただし，その際の`~header値$は、［
同じ要請に対し `200$st 応答を送信したとするときに，応答の`~payload本体$~内に送信することになる ~octet数
］に等しい，~decimal~~表現にしなければナラナイ。
◎
A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 4.1 of [RFC7232]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.
</li>
<li>
［
状態s~codeに［
`1xx$st または `204$st
］を伴う，どの応答
］内にも, および［
`CONNECT$m 要請に対する，どの `2xx$st 応答
］内にも， `Content-Length$h ~headerを送信してはナラナイ。
◎
A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).
</li>
</ul>

<p>
上に定義された各種~事例を除き、
`Transfer-Encoding$h が無い下では，
`生成元~server$は［
`~header節$の送信を完了するに先立って，`~payload本体$~sizeが既知である
］ときには， `Content-Length$h ~headerを送信するベキである。
これにより、`下流$の各`受信者$は，［
転送の進捗を測定する ／
受信される~messageがいつ完了するかを知る ／
追加的な要請~用に接続を後で再利用する
］ことが可能になる。
◎
Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.
</p>

<p>
`Content-Length$h ~headerに対する~zero以上のどの値も，妥当である。
［
`~payload$の長さに対する定義済み制限
］は無いので、`受信者$は，それを構文解析する際に［
~decimal数字列が巨大になり得ることや, 整数~変換の桁溢れ
］を見越して，それらによる~errorを防がなければナラナイ（`9.3$sec）。
◎
Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 9.3).
</p>

<div class="p">
<p>
受信した~messageの `Content-Length$h ~headerが，［
複数あって，その`~header値$がどれも一致する~decimal値†である
］, または［
1 個だけあって，その`~header値$が同一の~decimal値からなる~listである（例：
`Content-Length: 42, 42^c ）
］場合††、`上流$の~message処理器が，［
`Content-Length$h ~headerを重複して`生成し$たか, または`結合-$した
］ことを指示している。
そのような場合，`受信者$は、［
`~message本体$の長さを決定する ／ ~messageを回送する
］に先立って，次のいずれかを行わなければナラナイ：
◎
If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., "Content-Length: 42, 42"), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either＼
</p>

<ul>
	<li>
~messageを妥当でないものとして却下する。
◎
reject the message as invalid or＼
</li>
	<li>
重複された`~header値$を［
~decimal値を包含している， 1 個の妥当な`Content-Length$h ~header
］に置換する。
◎
replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.
</li>
</ul>

<p class="trans-note">【†
はっきりしないが， “~decimal値” とは、
“~decimal数として解釈した結果の数”
の略記（ "`011^c" と "`11^c" は，~decimal値として一致すると見なす）と思われる。
】【††
異なる値が混じっている場合、
`次節の記述＠#invalid-Content-Length-value$
から回復-不能な~errorになる。
】</p>
</div>

<p class="note">注記：
~HTTPにおける［
~message~frame法のための `Content-Length$h の利用
］は、［
~MIMEにおける同じ~headerの利用
］から有意に相違する
— そこでの `Content-Length^h は、~MIME型 "`message/external-body^c" の中でのみ利用される，省略可能な~headerである。
◎
Note: HTTP's use of Content-Length for message framing differs significantly from the same field's use in MIME, where it is an optional field used only within the "message/external-body" media-type.
</p>

			</section>
			<section id="section-3.3.3">
<h4 title="Message Body Length">3.3.3. ~message本体の長さ</h4>

<p>
`~message本体$の長さ（以下，
`本体~長さ@
）は、［
以下に挙げる項目のうち，その~messageが該当する~~最初の項目
］に対応する記述に従って決定される：
◎
The length of a message body is determined by one of the following (in order of precedence):
</p>

<dl class="switch">
	<dt>
`HEAD$m 要請に対する応答である
◎
1. Any response to a HEAD request and＼
</dt>
	<dt>
`1xx$st／ `204$st／ `304$st 応答である
◎
any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code＼
</dt>
	<dd>
~message内にどのような~headerの有無に関わらず，常に［
一連の~headerの後の最初の`空~行l$
］で終了される。
従って，~message本体を包含し得ない。
◎
is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body.
</dd>

	<dt>
`CONNECT$m 要請に対する， `2xx$st 応答である
◎
2. Any 2xx (Successful) response to a CONNECT request＼
</dt>
	<dd>
これは，接続が、［
`~header節$を締めくくる`空~行l$の直後から，`~tunnel$になる
］ことを含意する。
`~client$は、そのような~message内に受信された どの［
`Content-Length$h ／ `Transfer-Encoding$h
］~headerも，無視しなければナラナイ。
◎
implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.
</dd>

	<dt>
`Transfer-Encoding$h ~headerが在る
◎
↓</dt>
	<dd>
		<dl class="switch">
			<dt>
`最終~転送~符号法$は`~chunked$である
◎
3. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 4.1) is the final encoding,＼
</dt>
			<dd>
`本体~長さ$は、~chunked~dataを，［
その転送~符号法により，~dataの完了が指示される
］まで読取って復号することにより，決定される。
◎
the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.＼
</dd>

			<dt>
`最終~転送~符号法$は`~chunked$でない
◎
＼</dt>
			<dd>
				<dl class="switch">
					<dt>
応答である場合
◎
If a Transfer-Encoding header field is present in a response and the chunked transfer coding is not the final encoding,＼
</dt>
					<dd>
`本体~長さ$は、~serverにより~closeされるまで 接続を読取ることにより，決定される。
◎
the message body length is determined by reading the connection until it is closed by the server.＼
</dd>

					<dt>
要請である場合
◎
If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding,＼
</dt>
					<dd>
`本体~長さ$は、依拠-可能に決定し得ない
— ~serverは、状態s~code `400$st で応答した上で，接続を~closeしなければナラナイ。
◎
the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.＼
</dd>
				</dl>
			</dd>
		</dl>
<p>
受信した~messageが［
`Transfer-Encoding$h, `Content-Length$h
］の両~headerを伴う場合、
`Transfer-Encoding$h が `Content-Length$h を上書きする。
そのような~messageは［
`要請~密入$や`応答~分割$
］を遂行する試みを指示しているかもしれないので、［
~errorとして取扱われる~OUGHT
］。
`送信者$は，［
そのような~messageを`下流$へ回送する
］に先立って［
受信された `Content-Length$h ~header
］を除去しなければナラナイ。
◎
If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.
</p>
	</dd>

	<dt>
`~header値$が相違する，複数の `Content-Length$h ~headerが在る†
◎
4. If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or＼
</dt>
	<dt>
妥当でない値をとる `Content-Length$h ~headerが在る
◎
a single Content-Length header field having an invalid value, then＼
</dt>
	<dd class="trans-note">【†
文面からは，［
"`Content-Length: 42, 42^c",
"`Content-Length: 42^c"
の 2 個があるような場合
］も該当しそうだが、意味論的には "`Content-Length: 42^c" が 3 個ある（あるいは、どこかで`結合-$された結果， "`Content-Length: 42, 42, 42^c" が 1 個ある）のと同じであり，該当しないと解釈できそうでもある。
】</dd>
	<dd>
<p id="invalid-Content-Length-value">
~message~frame法は妥当でないので、`受信者$は，それを回復-不能な~errorとして扱った上で，次に従って動作しなければナラナイ：
◎
the message framing is invalid and the recipient MUST treat it as an unrecoverable error.＼
</p>
		<dl class="switch">
			<dt>
要請である場合
◎
If this is a request message,＼
</dt>
			<dd>
~serverは、状態s~code `400$st で応答した上で，接続を~closeする。
◎
the server MUST respond with a 400 (Bad Request) status code and then close the connection.＼
</dd>

			<dt>
`~proxy$が受信した応答である場合
◎
If this is a response message received by a proxy,＼
</dt>
			<dd>
`~proxy$は、~serverへの接続を~closeし,
受信された応答を破棄した上で，~clientに向けて［
`502$st 応答
］を送信する。
◎
the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad Gateway) response to the client.＼
</dd>

			<dt>
~UAが受信した応答である場合
◎
If this is a response message received by a user agent,＼
</dt>
			<dd>
`~UA$は、~serverへの接続を~closeした上で，受信された応答を破棄する。
◎
the user agent MUST close the connection to the server and discard the received response.
</dd>
		</dl>
	</dd>

	<dt>
妥当な `Content-Length$h ~headerが在る
◎
</dt>
	<dd>
その~decimal値が、~octet数による，予期される`本体~長さ$を定義する。
［
送信者が接続を~closeした
］または［
受信者が，指示された~octet数が受信される前に制限時間を超えた
］場合、`受信者$は，~messageが`不完全$であると見なして接続を~closeしなければナラナイ。
◎
5. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.
</dd>

	<dt>
要請である
◎
</dt>
	<dd>
`本体~長さ$は~zeroである（~message本体は無い
【“長さ~zeroの本体を内包する” と記されるべき？】
）。
◎
6. If this is a request message and none of the above are true, then the message body length is zero (no message body is present).
</dd>

	<dt>
他の場合
◎
7. Otherwise,
</dt>
	<dd>
すなわち，`本体~長さ$が宣言されていない応答~messageになるので、
`本体~長さ$は［
~serverが接続を~closeするに先立って受信された~octet数
］により決定される。
◎
this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.
</dd>
</dl>

<p>
~messageが［
成功裡に完了し，~closeで区切られたもの
］なのか,［
~network失敗により中断され，部分的に受信されたもの
］なのかを判別する仕方はないので、`~server$は，アリな所では、自身が`生成する$~messageを［
符号化法または長さ
【 `Transfer-Encoding$h または `Content-Length$h 】
］で区切るベキである。
~closeで区切る特能は、首に［
~HTTP10との後方~互換性
］用に存在する。
◎
Since there is no way to distinguish a successfully completed, close-delimited message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.
</p>

<p>
`~server$は、［
`~message本体$は包含するが
`Content-Length$h は包含しない
］要請に対し，
`411$st で応答して却下してヨイ。
◎
A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).
</p>

<p>
~chunked以外の`転送~符号法$が適用されていない限り，［
`~message本体$を包含している要請
］を送信する`~client$は、その`本体~長さ$が予め既知であるときは，［
`~chunked転送~符号法$
］ではなく［
妥当な `Content-Length$h ~header
］を利用するベキである
— 一部の既存の~serviceは、`~chunked転送~符号法$を解するにも関わらず，~chunkedに対し状態s~code `411$st で応答するので。
これは概して、そのような~serviceが，［
呼び出される手前の所に， `Content-Length$h を要求する`~gateway$を挟む
］ように実装されていて、~serverが，要請~全体を処理する前に~bufferできない／するつもりがないためである。
◎
Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content-length in advance of being called and the server is unable or unwilling to buffer the entire request before processing.
</p>

<p>
［
`~message本体$を包含している要請
］を送信する`~UA$は、［
`~server$が`~HTTP11$（以上の~version）の要請を取扱える
］ことを知っていない場合には，［
妥当な `Content-Length$h ~header
］を送信しなければナラナイ
—
そのような知識は、特定の利用者~環境設定や, ~~直前に受信された応答の`~version$を記憶する形をとるであろう。
◎
A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.
</p>

<div class="p">
<p>
［
接続~上の最後の要請に対する最終~応答が完全に†受信された
］かつ［
読取る追加的な~dataが残っている
］場合、`~UA$は，次のいずれかを~~行ってヨイ：
◎
If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY＼
</p>

<p class="trans-note">【†
この “完全に” は、上で決定される`本体~長さ$（ `Content-Length^h に指示される長さなど）まで（本体を持たないとされている場合は，`~header節$全体まで），を意味すると見られる。
】</p>

<ul>
	<li>
残っている~dataを破棄する。
◎
discard the remaining data or＼
</li>
	<li>
その~dataが~~直前の応答~本体の一部である†かどうか，決定することを試みる。
◎
attempt to determine if that data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect.＼
</li>
</ul>

<p>†
これが~~起こるのは、［
~~直前の~messageの `Content-Length$h 値が不正である
］事例が該当し得る。
`~client$は、そのような余分な~dataを，別々な応答として［
処理n,
~cache,
回送-
］してはナラナイ
— そのような挙動は，~cache汚染に対し脆弱になるので。
◎
A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.
</p>
</div>

			</section>
		</section>
		<section id="section-3.4">
<h3 title="Handling Incomplete Messages">3.4. 不完全な~messageの取扱い</h3>

<p>
`不完全$な要請~messageを受信した`~server$は、接続を~closeするに先立って，~error応答を送信してヨイ。
そのような要請は、通例的に［
要請が取消されたり，制限時間による例外が誘発された
］ことに因る。
◎
A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.
</p>

<p>
`不完全$な応答~messageを受信した`~client$は、その~messageを不完全なものと記録しなければナラナイ。
そのような応答は、接続が尚早に~closeされたときや,
`~chunked転送~符号法$と思しきものの復号に失敗したときに，生じ得る。
不完全な応答に対する`~cache$についての要件は、`7234-3$rfcにて定義される。
◎
A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3 of [RFC7234].
</p>

<p>
応答が［
`~header節$の中途で（すなわち，`空~行l$が受信される前に）終了した
］かつ［
その`状態s~code$は、応答の全部的な意味を，~headerに依拠して伝達する可能性がある
］場合、`~client$は，その意味が伝達されたものと見做せないので、次にとる動作を決定するために，要請を繰返す必要が~~生じ得る。
◎
If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.
</p>

<div class="p">
<p>
次のとき、~messageは
`不完全@
とされる：
</p>

<ul>
	<li>
`~message本体$の`転送~符号法$に`~chunked$が利用されていて，符号化を終了させる［
~size~zeroの~chunk
］が受信されなかったとき。
</li>
	<li>
`Content-Length$h が利用されていて，その値より［
受信された~message本体の（~octet数による）~size
］が小さいとき。
</li>
</ul>
◎
A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received. A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length.＼
</div>

<p>
`~chunked転送~符号法$も `Content-Length$h も持たない応答は，［
接続の~closure
］により終了されるので、［
`~header節$は全て受信された
］限りにおいて，［
受信された~message本体の~octet数
］に関わらず 完全と見なされる。
◎
A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, thus, is considered complete regardless of the number of message body octets received, provided that the header section was received intact.
</p>

		</section>
		<section id="section-3.5">
<h3 title="Message Parsing Robustness">3.5. ~message構文解析の堅牢性</h3>

<p>
早期の~server~appには，［
`CRLF$P で終了されていない`~message本体$
］の内容を読取るのに失敗するものもあるため、古い~HTTP10~UA実装は，その対処法として，
`POST$m 要請の後に余分な `CRLF$P を送信することがある。
`~HTTP11$`~UA$は、要請の前後に `CRLF$P を付け足してはナラナイ。
`~UA$は、要請~message本体を `CRLF$P で終了させたいときには，その `CRLF$P の分も`~message本体~長さ$に数えなければナラナイ。
◎
Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.
</p>

<p>
堅牢性の~~観点からは、［
`request-line$p を受信して, 構文解析する
］ことを予期している`~server$は、［
`request-line$p に先立って受信された，空~行l
］を，少なくとも 1 行l以上は無視するベキである。
◎
In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.
</p>

<p>
［
`start-line$p ／各`~header$
］に対する行l終了子は， `CRLF$P ~octet並びであるが、`受信者$は，［
1 個の `LF$P ~octet
］を行l終了子として認識して, 先行する `CR$P を無視してヨイ。
◎
Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.
</p>

<p>
文法~規則
`request-line$p, `status-line$p
は，［
各種~成分~要素どうしが 1 個の `SP$P ~octetで分離される
］ことを要求しているが、`受信者$は，代わりに
空白で区切られる単語~境界を構文解析した上で，終了子の `CRLF$P は別として，頭部／尾部の空白は無視しつつ, 任意の形による空白を `SP$P 分離子と扱ってヨイ
—
そのような空白は、 1 個~以上の，次の~octetからなり得る：［
`SP$P,
`HTAB$P,
`VT^P  (%x0B),
`FF^P  (%x0C), ［
`CRLF$P の一部でない `CR$P
］］。
しかしながら、寛容な構文解析-法は，［
~messageに対し複数の`受信者$が居て，それぞれの堅牢性のための解釈が互いに異なる<!-- each has its own unique -->
］場合に，~securityの脆弱性になり得る（`9.5$secを見よ）。
◎
Although the request-line and status-line grammar rules require that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 9.5).
</p>

<p>
`~server$は、［
~HTTP要請~messageのみを~listenしている
］とき, あるいは［［
`start-line$p から出現するものが，~HTTP要請~messageになるかどうか
］を処理している
］ときに，［
`HTTP-message$p 文法に合致しない~octet列
］を受信したときには、上に挙げた堅牢性の例外を除き，［
`400$st 応答
］で応答するベキである。
◎
When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response.
</p>

		</section>
	</section>
	<section id="section-4">
<h2 title="Transfer Codings">4. 転送~符号法</h2>

<p>
`転送~符号法^dfn（ `transfer-coding$p ）は、［［
~networkを通した “安全~transport”
］を確保するために，`~payload本体$に適用-［
された／
され得る／
させる必要が~~生じ得る
］ような，符号化法の形式変換
］を指示するために利用される。
転送~符号法は、~messageの~propertyである点で，［
転送されている`表現$の~propertyである，`内容~符号法$
］から相違する。
◎
Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a payload body in order to ensure "safe transport" through the network. This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.
</p>

<pre class="bnf">
`transfer-coding@p    = "`chunked$c"
                   / "`compress$c"
                   / "`deflate$c"
                   / "`gzip$c"
                   / `transfer-extension$p
`transfer-extension@p = `token$p *( `OWS$p ";" `OWS$p `transfer-parameter$p )
</pre>

<p>
`transfer-parameter$p は、
<del><code>`name^var</code>, または</del>
<code> `name^var=`value^var</code>
~pairの形をとる：
◎
Parameters are in the form of a name or name=value pair.
</p>

<pre class="bnf">
`transfer-parameter@p = `token$p `BWS$p "=" `BWS$p ( `token$p / `quoted-string$p )
</pre>

<p class="trans-note">【
“<code>`name^var</code>, または”
の削除は、`4839$errataによる~~修正による（ Verified: 2017-02-16 ）
】</p>
<!-- Errata ID: 4838 Rejected -->

<p>
すべての`転送~符号法~名$は、文字大小無視であり，［
`8.4$sec にて定義されるように，
HTTP Transfer Coding ~registryに登録される
］~OUGHT。
それらは、
`TE$h や `Transfer-Encoding$h
~header内で利用される。
◎
All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 8.4. They are used in the TE (Section 4.3) and Transfer-Encoding (Section 3.3.1) header fields.
</p>

<p class="trans-note">【
`4683$errataによる~~修正あり（ Held for Document Update: 2016-05-05 ）：
<q>
`transfer-parameter$p の
<code>`name^var</code>
部分は文字大小無視であり，
"`q^c" にされてはナラナイ （ `TE^h ~headerの一部として利用された場合に多義的になるので）
</q>
】
◎
The name part of a transfer-parameter is case insensitive and MUST not
be "q" (as this would be ambiguous when used as part of the TE header).
</p>

		<section id="section-4.1">
<h3 title="Chunked Transfer Coding">4.1. ~chunked転送~符号法</h3>

<div class="p">
<p>
`~chunked転送~符号法^dfn
（ "`chunked^c" ）は、`~payload本体$を，次の並びとして転送するために包装する：
◎
The chunked transfer coding wraps the payload body in order to transfer it as＼
</p>

<ol>
	<li>
一連の~chunk
— 各~chunkは，自前の~size指示子（ `chunk-size$p ）を~~供する。
◎
a series of chunks, each with its own size indicator,＼
</li>
	<li>
`任意選択^2119で，いくつかの~headerを包含する`~trailer節$。
◎
followed by an OPTIONAL trailer containing header fields.＼
</li>
</ol>

<p>
~chunkedは、［
未知~sizeの内容~stream
］を，［
長さで区切られる，一連の~buffer
］として転送できるようにする。
これにより、送信者が 接続の持続性を維持しつつ，受信者は いつ~message全体が受信されたかを知ることが~~可能になる。
◎
Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.
</p>

</div>

<pre class="bnf">
`chunked-body@p   = *`chunk$p
                 `last-chunk$p
                 `trailer-part$p
                 `CRLF$P

`chunk@p          = `chunk-size$p [ `chunk-ext$p ] `CRLF$P
                 `chunk-data$p `CRLF$P
`chunk-size@p     = 1*`HEXDIG$P
`last-chunk@p     = 1*("0") [ `chunk-ext$p ] `CRLF$P

`chunk-data@p     = 1*OCTET ; <span class="comment" title="a sequence of chunk-size octets">~~長さ `chunk-size^p の~octet列</span>
</pre>

<p>
`chunk-size$p ~fieldは、［
~octet数による `chunk-data$p の~size
］を指示する，［
いくつかの~hex桁からなる文字列
］である。
~chunked転送~符号法が完了するのは、［
`chunk-size$p ~zeroの~chunk
— 場合によっては`~trailer節$も後続する —
が受信され，最後に 空~行lにより終了された
］ときである。
◎
The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer, and finally terminated by an empty line.
</p>

<p>
`受信者$は、［
~chunked転送~符号法
］を構文解析して復号できなければナラナイ。
◎
A recipient MUST be able to parse and decode the chunked transfer coding.
</p>

			<section id="section-4.1.1">
<h4 title="Chunk Extensions">4.1.1. ~chunk拡張</h4>

<p>
`~chunked$符号化により、各~chunkは，
`chunk-size$p の直後に~zero個~以上の
`~chunk拡張^dfn
（ `chunk-ext$p ）を内包させられるようになる
— その~~目的は、［
~chunkごとの~metadata（署名や~hashなど）,
~messageの中途を制御する情報,
~message本体~sizeの~randomization
］を給することである。
◎
The chunked encoding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size.
</p>

<pre class="bnf">
`chunk-ext@p      = *( <ins>`BWS$p</ins> ";" <ins>`BWS$p</ins> `chunk-ext-name$p [ <ins>`BWS$p</ins> "=" <ins>`BWS$p</ins> `chunk-ext-val$p ] )

`chunk-ext-name@p = `token$p
`chunk-ext-val@p  = `token$p / `quoted-string$p
</pre>

<p class="trans-note">【
挿入された 4 個の `BWS$p は、`4667$errataによる~~修正による（ Verified: 2016-10-07 ）。
首に後方~互換性のため。
】</p>

<p>
`~chunked$による符号化は，接続ごとに特有であり、［
より高~levelの~appが，それらの拡張を検分する機会を得る
］より前に，`受信者$たち（`中継者$も含む）により，除去されたり再符号される見込みが高い。
よって，`~chunk拡張$の利用は、一般に，特化された~HTTP~serviceに制限される
— 例えば：［
“long polling” （~clientと~serverは，~chunk拡張の利用に関する期待を共有する）
］や, ［
`端点間$の~secure化された接続の中での~padding
］用など。
◎
The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, use of chunk extensions is generally limited to specialized HTTP services such as "long polling" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.
</p>

<p>
`受信者$は、［
未認識`~chunk拡張$
］を無視しなければナラナイ。
`~server$は、［
要請~内に受信される~chunk拡張の総~長さ
］を［
供される~serviceに見合う量
］に制限する~OUGHT：
［
~messageの他の各部に適用される，長さ制限や制限時間
］と同じ仕方で、かつ
その量を超過したときは，［
適切な `4xx$st 応答
］を`生成する$ことで。
◎
A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.
</p>

			</section>
			<section id="section-4.1.2">
<h4 title="Chunked Trailer Part">4.1.2. ~chunked~trailer節</h4>

<div class="p">
<p>
`送信者$は、~chunk化された~messageの末尾に
`~trailer節@
（ `trailer-part$p ）と呼ばれる~dataを内包させられる。
それは、`~message本体$が送信される間に，動的に`生成し$得る~metadata
— ~message完全性~検査, ~digital署名, 後処理~状態sなど —
を給するためにあり、
`~trailer~field@
（ `trailer field^en ）と呼ばれる，いくつかの追加的な~fieldからなる。
◎
A trailer allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.＼
</p>

<p class="trans-note">【
“~trailer節” は、原文では単に “~trailer（ `trailer^en ）” と称されているが、
“~trailer” は~trailer~fieldの略称を表すこともあるので，（改訂-下にある~HTTP仕様による呼称に倣って）名称を改めている。
】</p>


<p>
各`~trailer~field$の構文は、`~header$と一致する
— それらは~messageの`~header節$ではなく，~chunked~trailer節~内に送信されるが：
◎
The trailer fields are identical to header fields, except they are sent in a chunked trailer instead of the message's header section.
</p>
</div>

<pre class="bnf">
`trailer-part@p   = *( `header-field$p `CRLF$P )
</pre>

<div class="p">

<p>
`送信者$は、`~trailer節$内に，次に挙げるいずれかに必要とされる`~header$を
`~trailer~field$として`生成し$てはナラナイ：
◎
A sender MUST NOT generate a trailer that contains a field necessary for＼
</p>

<ul>
	<li>
~message~frame法（例： `Transfer-Encoding$h や`Content-Length$h）
◎
message framing (e.g., Transfer-Encoding and Content-Length),＼
</li>
	<li>
経路制御（例： `host$p）
◎
routing (e.g., Host),＼
</li>
	<li>
`要請の改変子$（例： `制御~header$や`条件付き~header$）
◎
request modifiers (e.g., controls and conditionals in Section 5 of [RFC7231]),＼
</li>
	<li>
認証（例： `7235$R, `6265$R を見よ）
◎
authentication (e.g., see [RFC7235] and [RFC6265]),＼
</li>
	<li>
応答~制御~data（例： `7231-7.1$rfc ）
◎
response control data (e.g., see Section 7.1 of [RFC7231]), or＼
</li>
	<li>
`~payload$を処理する方法を決定するもの（例：
`Content-Encoding$h, `Content-Type$h, `Content-Range$h, `Trailer$h
）。
◎
determining how to process the payload (e.g., Content-Encoding, Content-Type, Content-Range, and Trailer).
</li>
</ul>
</div>

<div class="p">
<p>
［
~chunk化され，空でない`~trailer節$を包含している~message
］を受信した`受信者$は、その各`~trailer~field$を：
◎
When a chunked message containing a non-empty trailer is received, the recipient＼
</p>

<ul>
	<li>
［
それらが~messageの`~header節$に付加されていた
］かのように，処理してヨイ
— ただし、
◎
MAY process the fields (aside from those forbidden above) as if they were appended to the message's header section.＼
</li>
	<li>
それらのうち，［
上述の，`~trailer節$内に送信することが禁止されている`~trailer~field$
］は、無視しなければナラナイ（~errorと見なす）
— その種の`~trailer~field$が前項と同様に処理された場合、外部~security~filterが迂回されるかもしれないので。
◎
A recipient MUST ignore (or consider as an error) any fields that are forbidden to be sent in a trailer, since processing them as if they were present in the header section might bypass external security filters.
</li>
</ul>
</div>

<div class="p">

<p>
`~server$は、要請が［
`TE$h ~headerを内包していて, かつ
その値が "`trailers$c" を包含している
］
— すなわち、`~trailer節$を受容-可能であることを指示している —
のでない限り：
◎
Unless the request includes a TE header field indicating "trailers" is acceptable, as described in Section 4.3,＼
</p>

<ul>
	<li>
［
自身から見て［
`~UA$による受信が必要とされる
］と予見される`~trailer~field$
］を`生成する$ベキでない。
◎
a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive.＼
</li>
	<li>
［
一連の`~trailer~field$は，`~UA$までの経路を経る間に黙って破棄され得る
］ものと見做す~OUGHT。
この要件により、`中継者$は、応答~全体を~bufferすることなく，［
`~chunked$が解除された
【<a href="#section-4.1.3" >復号された</a>】
~message
］を~HTTP10`受信者$に向けて回送できるようになる。
◎
Without a TE containing "trailers", the server ought to assume that the trailer fields might be silently discarded along the path to the user agent. This requirement allows intermediaries to forward a de-chunked message to an HTTP/1.0 recipient without buffering the entire response.
</li>
</ul>
</div>

			</section>
			<section id="section-4.1.3">
<h4 title="Decoding Chunked">4.1.3. ~chunkedの復号-法</h4>

<p>
`~chunked転送~符号法$を復号する処理nは、次の疑似~codeで表現できる：
◎
A process for decoding the chunked transfer coding can be represented in pseudo-code as:
</p>

<div class="p">

<ol>
	<li>
`長さ^var ~LET 0
</li>
	<li>
`本体^var ~LET 空
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
［
`chunk-size$p, `chunk-ext$p （もしあれば）, `CRLF$P
］を読取る
</li>
			<li>
~IF［
`chunk-size$p ~EQ 0 ）
］
⇒
~BREAK
</li>
			<li>
［
`chunk-data$p, `CRLF$P
］を読取る
</li>
			<li>
`本体^var に `chunk-data$p を付加する
</li>
			<li>
`長さ^var ~SET `長さ^var + `chunk-size$p
</li>
		</ol>
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
`f^var ~LET 次の`~trailer~field$を読取った結果
</li>
			<li>
~IF［
`f^var は空である
］
⇒
~BREAK
</li>
			<li>
~IF［
`f^var は`~trailer節$内に送信することが許容されている
］
⇒
既存の`~header節$に `f^var を付加する
</li>
		</ol>
	</li>
	<li>
`Content-Length$h の`~header値$ ~SET `長さ^var
</li>
	<li>
`Transfer-Encoding$h から "`chunked$c" を除去する
</li>
	<li>
既存の`~header節$から `Trailer$h を除去する
</li>
	<li>
~RET `本体^var
</li>
</ol>

<pre lang="en" class="_en">
length := 0
read chunk-size, chunk-ext (if any), and CRLF
while (chunk-size &gt; 0) {
   read chunk-data and CRLF
   append chunk-data to decoded-body
   length := length + chunk-size
   read chunk-size, chunk-ext (if any), and CRLF
}
read trailer field
while (trailer field is not empty) {
   if (trailer field is allowed to be sent in a trailer) {
       append trailer field to existing header fields
   }
   read trailer-field
}
Content-Length := length
Remove "chunked" from Transfer-Encoding
Remove Trailer from existing header fields
</pre>
</div>

			</section>
		</section>
		<section id="section-4.2">
<h3 title="Compression Codings">4.2. 圧縮~符号法</h3>

<p>
~messageの`~payload$を圧縮するときには、以下に定義される各種
`圧縮~符号法^dfn
を利用できる。
◎
The codings defined below can be used to compress the payload of a message.
</p>

			<section id="section-4.2.1">
<h4 title="Compress Coding">4.2.1. "`compress^c" 符号法</h4>

<p>
"`compress^c" 符号法は、共通的に［
~UNIX~file圧縮~program “compress”
］により生産される，［
適応的 Lempel-Ziv-Welch（ LZW ）符号法 `Welch$r
］である。
`受信者$は、 "`x-compress^c" を "`compress^c" と等価と見なすベキである。
◎
The "compress" coding is an adaptive Lempel-Ziv-Welch (LZW) coding [Welch] that is commonly produced by the UNIX file compression program "compress". A recipient SHOULD consider "x-compress" to be equivalent to "compress".
</p>

			</section>
			<section id="section-4.2.2">
<h4 title="Deflate Coding">4.2.2. "`deflate^c" 符号法</h4>

<p>
"`deflate^c" 符号法は、
“zlib” ~data形式 `1950$R であり，［
Lempel-Ziv (LZ77）圧縮~algoと, Huffman 符号法が組合された， “deflate” 圧縮-済み~data~stream `1951$R
］を包含する。
◎
The "deflate" coding is a "zlib" data format [RFC1950] containing a "deflate" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.
</p>

<p class="note">注記：
一部の適合しない実装は、
"`deflate^c" 圧縮-済み~dataを，zlib で包装せずに送信する。
◎
Note: Some non-conformant implementations send the "deflate" compressed data without the zlib wrapper.
</p>

			</section>
			<section id="section-4.2.3">
<h4 title="Gzip Coding">4.2.3. "`gzip^c" 符号法</h4>

<p>
"`gzip^c" 符号法は、［
32-bit CRC（ Cyclic Redundancy Check ）が伴われた LZ77 符号法
］であり，［
“gzip” ~file圧縮~program `1952$R
］により共通的に生産される。
`受信者$は、 "`x-gzip^c" を， "`gzip^c" と等価と見なすベキである。
◎
The "gzip" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]. A recipient SHOULD consider "x-gzip" to be equivalent to "gzip".
</p>

			</section>
		</section>
		<section id="section-4.3">
<h3 title="TE">4.3. `TE^h</h3>

<div class="p">
<p>
要請~内の `TE$h ~headerは、次の 2 つを指示する：
◎
The "TE" header field in a request indicates＼
</p>

<ul>
	<li>
`~client$が、`~chunked$の他に，応答にて受容する用意がある`転送~符号法$。
◎
what transfer codings, besides chunked, the client is willing to accept in response, and＼
</li>
	<li>
`~client$は、`~chunked転送~符号法$にて`~trailer~field$を受容する用意があるかどうか。
◎
whether or not the client is willing to accept trailer fields in a chunked transfer coding.
</li>
</ul>
</div>

<p>
`TE$h `~header値$は、~commaで分離された~listであり，その各要素は［
`転送~符号法~名$ ／ ~keyword "`trailers$c"†
］を与える
— 各 転送~符号法~名には、 0 個以上の~parameter（ `4$sec を見よ）も許容される。
`~client$は、`TE$h 内に，`転送~符号法~名$として "`chunked$c" を送信してはナラナイ
— `~HTTP11$`受信者$に対しては、`~chunked$は常に受容-可能なので。
【† 構文上は、複数個の "`trailers^c" も（余計であるが）許容されている。】
◎
The TE field-value consists of a comma-separated list of transfer coding names, each allowing for optional parameters (as described in Section 4), and/or the keyword "trailers". A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.
</p>

<pre class="bnf">
`TE@p        = #`t-codings$p
`t-codings@p = "`trailers$c" / ( `transfer-coding$p [ `t-ranking$p ] )
`t-ranking@p = `OWS$p ";" `OWS$p "q=" `rank$p
`rank@p      = ( "0" [ "." 0*3`DIGIT$P ] )
           / ( "1" [ "." 0*3("0") ] )
</pre>

<div class="example">

<p>
`TE$h の利用を示す 3 つの例：
◎
Three examples of TE use are below.
</p>

<pre class="lang-http">
TE: deflate
TE:
TE: trailers, deflate;q=0.5
</pre>

</div>

<div class="p">

<p>
~keyword
"`trailers@c"
が在る場合、［
`4.1.2$sec にて定義されるように，`~client$が
— 自身および`下流$の~clientたちに利するため —
`~chunked転送~符号法$内に`~trailer~field$を受容する用意がある
］ことを指示する。
`中継者$からの要請においては、これは，次のいずれか【または両方？】を含意する：
◎
The presence of the keyword "trailers" indicates that the client is willing to accept trailer fields in a chunked transfer coding, as defined in Section 4.1.2, on behalf of itself and any downstream clients. For requests from an intermediary, this implies that either:＼
</p>

<ul>
	<li>
`下流$のすべての~clientは、回送された応答~内の`~trailer~field$を受容する用意がある。
◎
(a) all downstream clients are willing to accept trailer fields in the forwarded response; or,＼
</li>
	<li>
`中継者$は、`下流$の受信者たちに利するため，応答を~bufferしようと試みることになる。
◎
(b) the intermediary will attempt to buffer the response on behalf of downstream recipients.＼
</li>
</ul>

<p>
`~HTTP11$は、［
~chunked応答の~sizeを，［
`中継者$が応答~全体を~bufferできることが確約される
］ように制限する
］ような，いかなる手段も定義しないことに注意。
◎
Note that HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response.
</p>
</div>

<div class="p">

<p>
複数の`転送~符号法$が受容-可能なとき、`~client$は，［
文字大小無視 "`q=^c" ~parameter（ `rank$p ）
］を利用して，それらの符号法の選好を順位~付けてヨイ。
順位~値は、範囲 0 〜 1 の実数を表し，値が大きいほど選好される（`内容~折衝$~headerにて利用される`品質値$（ “qvalue” ）に類似する）：
◎
When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive "q" parameter (similar to the qvalues used in content negotiation fields, Section 5.3.1 of [RFC7231]). The rank value is a real number in the range 0 through 1, where＼
</p>

<ul>
	<li>
`0.001^c は，最も選好されないことを表す。【小数部は 3 桁までなので】
◎
0.001 is the least preferred and＼
</li>
	<li>
`1^c は，最も選好されることを表す。
◎
1 is the most preferred;＼
</li>
	<li>
`0^c は， “受容-可能でない” ことを意味する。
◎
a value of 0 means "not acceptable".
</li>
</ul>
</div>

<p>
［
`TE$h の`~header値$が空または，
`TE$h ~headerが無い
］場合に受容-可能な`転送~符号法$は、"`chunked$c" のみである。
転送~符号法を伴わない~messageは、常に受容-可能である。
◎
If the TE field-value is empty or if no TE field is present, the only acceptable transfer coding is chunked. A message with no transfer coding is always acceptable.
</p>

<p>
`TE$h ~headerは，直の接続にのみ適用されるので、
`TE$h の`送信者$は，［
`TE^h の意味論を~supportしない`中継者$による `TE^h ~headerの回送
］を防ぐため，
`Connection$h ~headerの中に "`TE^c" `接続~option$も送信しなければナラナイ。
◎
Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a "TE" connection option within the Connection header field (Section 6.1) in order to prevent the TE field from being forwarded by intermediaries that do not support its semantics.
</p>

		</section>
		<section id="section-4.4">
<h3 title="Trailer">4.4. `Trailer^h</h3>

<p>
`送信者$は、［
`~chunked転送~符号法$により符号化された`~message本体$
］を内包する~messageの末尾に，［［
いくつかの`~trailer~field$
］から形成される~metadata
］も送信したいと欲するときには、本体の前に［
どの`~trailer~field$が`~trailer節$内に在るか
］を指示する `Trailer$h ~headerを`生成する$ベキである。
これにより、`受信者$は，［
本体の処理を開始する前に，その~metadataの受領を準備する
］ことが可能になる。
これは、［
~messageが~stream化されていて
］, かつ［
受信者が，完全性~検査をその場その場で確認することが望ましい
］場合に有用になる。
◎
When a message includes a message body encoded with the chunked transfer coding and the sender desires to send metadata in the form of trailer fields at the end of the message, the sender SHOULD generate a Trailer header field before the message body to indicate which fields will be present in the trailers. This allows the recipient to prepare for receipt of that metadata before it starts processing the body, which is useful if the message is being streamed and the recipient wishes to confirm an integrity check on the fly.
</p>

<pre class="bnf">
`Trailer@p = 1#`field-name$p
</pre>

		</section>
	</section>
	<section id="section-5">
<h2 title="Message Routing">5. ~messageの経路制御</h2>

<div class="p">

<p>
~HTTP要請~messageの経路制御は、各`~client$により，次に基づいて決定される
⇒＃
`~target資源$,
~clientの~proxy環境設定,
`内方$への接続の確立法／再利用
◎
HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection.＼
</div>

<p>
対応ng応答の経路制御は、同じ接続`連鎖$を，~clientまで遡る。
◎
The corresponding response routing follows the same connection chain back to the client.
</p>

		<section id="section-5.1">
<h3 title="Identifying a Target Resource">5.1. ~target資源の識別-法</h3>

<p>
~HTTPは、一般用~computerから家電までに渡る，多種多様な~appで利用される。
一部の事例では、通信~optionは，~clientの環境設定~内に~~直に~code化されている。
しかしながら，大多数の~HTTP~clientは、一般用 ~Web~browserと同じ［
`資源$を識別するための仕組みと, 環境設定~技法
］に依拠する。
◎
HTTP is used in a wide variety of applications, ranging from general-purpose computers to home appliances. In some cases, communication options are hard-coded in a client's configuration. However, most HTTP clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers.
</p>

<p>
~HTTP通信は、何らかの目的で`~UA$から起動される。
その目的は、`要請の意味論$と,
それらの意味論が適用される
`~target資源^dfn
との組合nである。
`~target資源$の識別子には、概して，`~URI$参照が利用される
—
`~UA$は、
`~target~URI@
を得するために，それを `absolute-form$p に解決することになる。
参照~内の `fragment$p 成分については、もし在れば，~target~URIからは除外される
— `fragment$p 識別子は、`~client$側の処理 （`3986-3.5$rfc ）に予約されているので。
◎
HTTP communication is initiated by a user agent for some purpose. The purpose is a combination of request semantics, which are defined in [RFC7231], and a target resource upon which to apply those semantics. A URI reference (Section 2.7) is typically used as an identifier for the "target resource", which a user agent would resolve to its absolute form in order to obtain the "target URI". The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing ([RFC3986], Section 3.5).
</p>

		</section>
		<section id="section-5.2">
<h3 title="Connecting Inbound">5.2. 内方への接続-法</h3>

<p>
`~target~URI$が決定されたなら、`~client$は，［
欲されている意味論を成遂げるためには，~network要請が必要とされるかどうか
］, および［
必要とされるなら，その要請をどこへ~directするか
］を裁定する必要がある。
◎
Once the target URI is determined, a client needs to decide whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.
</p>

<p>
`~client$が`~cache$ `7234$R を備えていて, かつ
それにより要請を充足できる場合、要請は，通例的に，最初にそこへ~directされる。
◎
If the client has a cache [RFC7234] and the request can be satisfied by it, then the request is usually directed there first.
</p>

<p>
代表的な`~client$は、［
要請が`~cache$により充足できない
］場合に［
要請を充足するために利用される`~proxy$があるかどうか
］を決定するため，自身の環境設定を検査することになる。
~proxy環境設定は，実装~依存であるが，［
URI 接頭辞の照合,
選択的な権限の照合,
または その両者
］に基づくことが多く、~proxy自身は，通例的に［
"`http$c" ／ "`https$c"
］~URIにより識別される。
適用-可能な`~proxy$がある場合、~clientは，［
その~proxyへの接続を確立する（または再利用する）
］ことにより，`内方$へ接続する。
◎
If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an "http" or "https" URI. If a proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy.
</p>

<p>
適用-可能な`~proxy$はない場合、代表的な`~client$は，［
`~target資源$に対する権限へ直に接続する
］ために，［
通例的に`~target~URI$の `scheme$p ごとに特有な，~handler~routine
］を呼出すことになる。
これが どう成遂げられるかは、~target~URIの `scheme$p に依存し，それを~~規定する仕様により定義される
— この仕様が，［［
"`http$c" ／ "`https$c"
］`scheme$p を解決するために，`生成元~server$~accessを どのように定義しているか
］に類似な。
◎
If no proxy is applicable, a typical client will invoke a handler routine, usually specific to the target URI's scheme, to connect directly to an authority for the target resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification, similar to how this specification defines origin server access for resolution of the "http" (Section 2.7.1) and "https" (Section 2.7.2) schemes.
</p>

<p>
接続の管理に関する~HTTP要件は、`6$secにて定義される。
◎
HTTP requirements regarding connection management are defined in Section 6.
</p>

		</section>
		<section id="section-5.3">
<h3 title="Request Target">5.3. 要請~target</h3>

<p>
`内方$への接続を得したなら、`~client$は，送信する~HTTP要請`~message$に［
`~target~URI$から導出された
`要請~target^dfn（ `request-target$p ）
］を伴わせる。
`要請~target$には、［
要請されている~method, および
要請が`~proxy$へ向けたものかどうか
］の両者に依存して， 4 種の別個な形式がある：
◎
Once an inbound connection is obtained, the client sends an HTTP request message (Section 3) with a request-target derived from the target URI. There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.
</p>

<pre class="bnf">
`request-target@p = `origin-form$p
               / `absolute-form$p
               / `authority-form$p
               / `asterisk-form$p
</pre>

			<section id="section-5.3.1">
<h4>5.3.1. `origin-form^p</h4>

<p>
`request-target$p の最も共通的な形は、 `origin-form$p である：
◎
The most common form of request-target is the origin-form.
</p>

<pre class="bnf">
`origin-form@p    = `absolute-path$p [ "?" `query$p ]
</pre>

<p>
`~client$は、［［
`CONNECT$m または`~server-wide$ `OPTIONS$m
］（詳細は後述）以外の要請
］を，`生成元~server$へ直に為すときは、［
`~target~URI$の［
`absolute-path$p, `query$p
］成分
］のみを， `request-target$p として送信しなければナラナイ。
［
`~target~URI$の `path$p 成分が空
］の場合、~clientは，［
`request-target$p の `origin-form$p の中の `path$p
］として ［ "`/^c" ］を送信しなければナラナイ。
`5.4$sec にて定義されるように， `Host$h ~headerも送信することになる。
◎
When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send only the absolute path and query components of the target URI as the request-target. If the target URI's path component is empty, the client MUST send "/" as the path within the origin-form of request-target. A Host header field is also sent, as defined in Section 5.4.
</p>

<div class="example">

<p>
例えば，~clientが、［
次で識別される`資源$
］の`表現$を検索取得したいと望むときは：
◎
For example, a client wishing to retrieve a representation of the resource identified as
</p>

<pre>
http://www.example.org/where?q=now
</pre>

<p>
［
~host "`www.example.org^c" の~port 80
］への~TCP接続を，`生成元~server$から直に~openして（または再利用して）、次の 2 行l：
◎
directly from the origin server would open (or reuse) a TCP connection to port 80 of the host "www.example.org" and send the lines:
</p>

<pre class="lang-http">
GET /where?q=now HTTP/1.1
Host: www.example.org
</pre>

<p>
および，後続して要請~messageの残りの部分を，送信することになるだろう。
◎
followed by the remainder of the request message.
</p>

</div>

			</section>
			<section id="section-5.3.2">
<h4>5.3.2. `absolute-form^p</h4>

<p>
`~client$は、［［
`CONNECT$m または`~server-wide$ `OPTIONS$m 要請
］（詳細は後述）以外の要請
］を，`~proxy$へ向けて為すときは、
`request-target$p として［
`absolute-form$p による`~target~URI$
］を送信しなければナラナイ。
◎
When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in absolute-form as the request-target.
</p>

<pre class="bnf">
`absolute-form@p  = `absolute-URI$p
</pre>

<p>
要請を受けた`~proxy$は、［
アリなら，それに対し有効な`~cache$で~serviceする
］か, あるいは、~clientに利するため［
次の`内方$~proxy~serverへ向けて
］または［
 `request-target$p により指示される`生成元~server$へ向けて直に
］同じ要請を為す。
そのような~messageの “回送-法” に課される要件は、 `5.7$sec にて定義される。
◎
The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf to either the next inbound proxy server or directly to the origin server indicated by the request-target. Requirements on such "forwarding" of messages are defined in Section 5.7.
</p>

<div class="example">

<p>
`absolute-form$p による `request-target$p を伴う `request-line$p の例：
◎
An example absolute-form of request-line would be:
</p>

<pre class="lang-http">
GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1
</pre>

</div>

<p>
［
~HTTPの将来の`~version$における，すべての要請にわたる `absolute-form$p への移行
］を許容するため、`~server$は，［
要請~内の `absolute-form$p
］を受容しなければナラナイ
— ~HTTP11~clientが，それらを`~proxy$向けの要請~内にのみ送信することになるとしても。
◎
To allow for transition to the absolute-form for all requests in some future version of HTTP, a server MUST accept the absolute-form in requests, even though HTTP/1.1 clients will only send them in requests to proxies.
</p>

			</section>
			<section id="section-5.3.3">
<h4>5.3.3. `authority-form^p</h4>

<p>
`authority-form$p による `request-target$p が利用されるのは、
`CONNECT$m 要請に限られる：
◎
The authority-form of request-target is only used for CONNECT requests (Section 4.3.6 of [RFC7231]).
</p>

<pre class="bnf">
`authority-form@p = `authority$p
</pre>

<p>
`~client$は，［
1 個~以上の`~proxy$
］を通した`~tunnel$を確立するために， `CONNECT$m 要請を為すときは、`~target~URI$の `authority$p 成分（ただし， `userinfo$p および, その "`@^c" 区切子は除外する）のみを， `request-target$p として送信しなければナラナイ。
◎
When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the target URI's authority component (excluding any userinfo and its "@" delimiter) as the request-target. For example,
</p>

<div class="example">
<p>
`authority-form$p による `request-target$p を伴う `request-line$p の例：
</p>

<pre class="lang-http">
CONNECT www.example.com:80 HTTP/1.1
</pre>
</div>

			</section>
			<section id="section-5.3.4">
<h4>5.3.4. `asterisk-form^p</h4>

<p>
`asterisk-form$p による `request-target$p が利用されるのは、`~server-wide$に適用される `OPTIONS$m 要請に限られる。
◎
The asterisk-form of request-target is only used for a server-wide OPTIONS request (Section 4.3.7 of [RFC7231]).
</p>

<pre class="bnf">
`asterisk-form@p  = "*"
</pre>

<p>
`~client$が，`~server$に対し `~server-wide$ `OPTIONS$m のみを
— その~serverにおける特定の名前の`資源$を~~指すことなく —
要請したいと望むときは、
`request-target$p として［
"`*^c" (%x2A）
］のみを送信しなければナラナイ。
◎
When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only "*" (%x2A) as the request-target. For example,
</p>

<div class="example">
<p>
`asterisk-form$p による `request-target$p を伴う `request-line$p の例：
</p>

<pre class="lang-http">
OPTIONS * HTTP/1.1
</pre>
</div>

<p>
`~proxy$は、［［［［
~pathが空で, `query$p 成分がない，`~URI$
］を与える `absolute-form$p 
］による `request-target$p 
］を伴う，`OPTIONS$m 要請
］を受信したとき，［
自身が要請`連鎖$上の最後の`~proxy$になる
］ならば、［
その要請を，指示された`生成元~server$へ向けて回送する
］ときに，
`request-target$p として "`*^c" を送信しなければナラナイ。
◎
If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of "*" when it forwards the request to the indicated origin server.
</p>

<div class="example">
<p>
例えば、次の要請は：
◎
For example, the request
</p>

<pre class="lang-http">
OPTIONS http://www.example.org:8001 HTTP/1.1
</pre>

<p>
最終`~proxy$においては、［
~host "`www.example.org^c" の~port 8001
］へ接続した後，次の様に回送されることになるだろう：
◎
would be forwarded by the final proxy as
</p>

<pre class="lang-http">
OPTIONS * HTTP/1.1
Host: www.example.org:8001
</pre>

<p>
—
◎
after connecting to port 8001 of host "www.example.org".
</p>

</div>

			</section>
		</section>
		<section id="section-5.4">
<h3>5.4. `Host^h</h3>

<p>
要請~内の `Host^h ~headerは、［
`~target~URI$からの［
`host$p ＆ `port$p 情報
］］を供して、`生成元~server$が，［
単独の~IP~address上にて複数の~host名に対する要請
］を~serviceしている間でも，`資源$を互いに判別できるようにする：
◎
The "Host" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.
</p>

<pre class="bnf">
`Host@p = `uri-host$p [ ":" `port$p ] ; `2.7.1$sec
</pre>

<div class="p">
<p>
`~client$は、すべての［
`~HTTP11$要請~message
］内に， `Host$h ~headerを送信しなければナラナイ
— その際の `Host$h `~header値$には、［
`~target~URI$が `authority$p 成分を内包するかどうか
］に応じて，次を送信しなければナラナイ：
◎
A client MUST send a Host header field in all HTTP/1.1 request messages.＼
</p>

<ul>
	<li>
内包する場合
⇒
`authority$p 成分から［
`userinfo$p 下位成分と その "`@^c" 区切子
］（もしあれば）を除外した結果。
◎
If the target URI includes an authority component, then a client MUST send a field-value for Host that is identical to that authority component, excluding any userinfo subcomponent and its "@" delimiter (Section 2.7.1).＼
</li>
	<li>
<p>
内包しない（または未定義な）場合
⇒
空。
◎
If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field-value.
</p>

<p class="trans-note">【
`5216$errataに報告あり（ Reported: 2017-12-25 ）：
`2.7.1$sec の記述に基づき，
“この場合、受信者は，この要請を却下しなければナラナイ。”
】</p>

	</li>
</ul>
</div>

<p>
`Host$h `~header値$は，要請を取扱うときに決定的な情報なので、`~UA$は `Host$h を，［
`request-line$p に後続する最初の~header
］として`生成する$ベキである。
◎
Since the Host field-value is critical information for handling a request, a user agent SHOULD generate Host as the first header field following the request-line.
</p>

<div class="example">

<p>
例えば、［
&lt;`http://www.example.org/pub/WWW/^c&gt;
に対する`生成元~server$
］へ向けた `GET$m 要請 は、次で始まることになるだろう：
◎
For example, a GET request to the origin server for &lt;http://www.example.org/pub/WWW/&gt; would begin with:
</p>

<pre class="lang-http">
GET /pub/WWW/ HTTP/1.1
Host: www.example.org
</pre>

</div>

<p>
`~client$は、
`request-target$p が `absolute-form$p であっても，
`~HTTP11$要請~内に `Host$h ~headerを送信しなければナラナイ。
これにより、 `Host$h 情報を［
`Host$h が実装されていない古代の~HTTP10~proxy
］を通して回送することも可能になるので。
◎
A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.
</p>

<div class="p">
<p>
［［
`absolute-form$p による `request-target$p 
］を伴う要請
］を受信した`~proxy$は：
◎
When a proxy receives a request with an absolute-form of request-target,＼
</p>

<ul>
	<li>
受信された `Host$h ~header（もし在れば）は無視して、代わりにそれを［
`request-target$p の`host$p 情報
］に置換しなければナラナイ。
◎
the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target.＼
</li>
	<li>
その要請を回送するときは、［
受信された `Host$h `~header値$
］をそのまま回送せずに，［［
受信された `request-target$p 
］に基づく新たな `Host$h `~header値$
］を`生成し$なければナラナイ。
◎
A proxy that forwards such a request MUST generate a new Host field-value based on the received request-target rather than forward the received Host field-value.
</li>
</ul>
</div>

<p>
`Host$h ~headerは，［
~app~levelの経路制御の仕組み
］として動作するので、~malwareにとっては，`共用~cache$を汚染したり,
要請を意図されていない`~server$へ~redirectさせる，格好の標的になる。
~interception`~proxy$は、特に，［
要請を内部~serverへ~redirectしたり,
`共用~cache$内の~cache~keyとして利用する
］ときに `Host$h `~header値$に依拠していて，［
~interceptされた接続が，~hostに対する妥当な~IP~addressを~targetしているかどうか
］を最初に検証yしていない場合に、脆弱になる。
◎
Since the Host header field acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server. An interception proxy is particularly vulnerable if it relies on the Host field-value for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.
</p>

<div class="p">

<p>
`~server$は、次のいずれかに該当するどの要請~messageに対しても，状態s~code `400$st で応答しなければナラナイ：
◎
A server MUST respond with a 400 (Bad Request) status code＼
</p>

<ul>
	<li>
`~HTTP11$~messageであって， `Host$h ~headerを欠如するもの。
◎
to any HTTP/1.1 request message that lacks a Host header field and＼
</li>
	<li>
複数個の `Host$h ~headerを包含するもの。
◎
to any request message that contains more than one Host header field or＼
</li>
	<li>
包含する `Host$h ~headerの`~header値$が妥当でないもの。
◎
a Host header field with an invalid field-value.
</li>
</ul>

</div>

		</section>
		<section id="section-5.5">
<h3 title="Effective Request URI">5.5. 実効~要請~URI</h3>

<div class="p">
<p>
`request-target$p は，［
`~UA$の`~target~URI$の一部分のみ
］を包含することが多いので、`~server$は，［
要請に対し適正に~serviceする
］ために，意図された~targetを
`実効~要請~URI^dfn
として再構築する。
この再構築は、次の両者を孕む：
◎
Since the request-target often contains only part of the user agent's target URI, a server reconstructs the intended target as an "effective request URI" to properly service the request. This reconstruction involves both＼
</p>

<ul>
	<li>
~serverに局所的な環境設定
◎
the server's local configuration and＼
</li>
	<li>
［
`request-target$p ／ `Host$h ~header ／ 接続~文脈
］内で通信されている情報
◎
information communicated in the request-target, Host header field, and connection context.
</li>
</ul>
</div>

<p>
`~UA$にとっては、`実効~要請~URI$が，`~target~URI$になる。
◎
For a user agent, the effective request URI is the target URI.
</p>

<p>
`request-target$p は `absolute-form$p であるならば：
`実効~要請~URI$は， `request-target$p と同じである。
◎
If the request-target is in absolute-form, the effective request URI is the same as the request-target. Otherwise, the effective request URI is constructed as follows:
</p>

<p>
他の場合、`実効~要請~URI$は，次の様に構築される：
</p>

<ol>
	<li>
<p>
`実効~要請~URI$ に利用される `scheme$p は：
</p>
		<ol>
			<li>
~serverの環境設定（または`外方$`~gateway$）にて，固定的な~URI `scheme$p が供されているならば：
その `scheme$p 。
</li>
			<li>
他の場合，［
要請は TLS で~secure化された~TCP接続~越しに受信された
］ならば：
"`https$c" 。
</li>
			<li>
他の場合：
"`http$c" 。
</li>
		</ol>

◎
If the server's configuration (or outbound gateway) provides a fixed URI scheme, that scheme is used for the effective request URI. Otherwise, if the request is received over a TLS-secured TCP connection, the effective request URI's scheme is "https"; if not, the scheme is "http".
</li>
	<li>
<p>
`実効~要請~URI$ の `authority$p 成分は：
</p>
		<ol>
			<li>
~serverの環境設定（または`外方$`~gateway$）にて，固定的な~URI `authority$p 成分を供しているならば：
その `authority$p 。
</li>
			<li>
他の場合，［
`request-target$p は `authority-form$p である
］ならば：
`request-target$p と同じ。
</li>
			<li>
他の場合，［
`Host$h ~headerが給されていて，その`~header値$が空でない
］ならば：
`Host$h `~header値$と同じ。
</li>
			<li>
他の場合：
~serverに環境設定された既定の名前
— 更に，［
接続の入力用~TCP~port番号が［
`実効~要請~URI$の `scheme$p に対する既定の~port
］と相違する場合は，［
~colon （"`:^c"）, および（~decimal形による）その入力用~port番号
］も付加する。
</li>
		</ol>

◎
If the server's configuration (or outbound gateway) provides a fixed URI authority component, that authority is used for the effective request URI. If not, then if the request-target is in authority-form, the effective request URI's authority component is the same as the request-target. If not, then if a Host header field is supplied with a non-empty field-value, the authority component is the same as the Host field-value. Otherwise, the authority component is assigned the default name configured for the server and, if the connection's incoming TCP port number differs from the default port for the effective request URI's scheme, then a colon (":") and the incoming port number (in decimal form) are appended to the authority component.
</li>
	<li>
<p>
`実効~要請~URI$の［
結合された `path$p ＆ `query$p 成分
］は、 `request-target$p の形式に応じて，次で与えられる：
</p>
		<dl class="switch">
			<dt>`authority-form$p</dt>
			<dt>`asterisk-form$p </dt>
			<dd>
空。
</dd>

			<dt>`origin-form$p</dt>
			<dd>
`request-target$p と同じ。
</dd>
		</dl>

◎
If the request-target is in authority-form or asterisk-form, the effective request URI's combined path and query component is empty. Otherwise, the combined path and query component is the same as the request-target.
</li>
	<li>
<p>
`実効~要請~URI$は、［
上述の様に決定された各~成分, および 文字列 "`://^c"
］を，次の順で連結した結果の
`absolute-URI$p 形
【 `absolute-form$p 】
になる：
</p>

<ol><li>`scheme$p
</li><li>"`://^c"
</li><li>`authority$p
</li><li>結合された `path$p ＆ `query$p 成分
</li></ol>
◎
The components of the effective request URI, once determined as above, can be combined into absolute-URI form by concatenating the scheme, "://", authority, and combined path and query component.
</li>
</ol>

<div class="example">

<p>
例 1：
~secureでない~TCP接続~越しに受信された，次の~message：
◎
Example 1: the following message received over an insecure TCP connection
</p>

<pre class="lang-http">
GET /pub/WWW/TheProject.html HTTP/1.1
Host: www.example.org:8080
</pre>

<p>
に対する`実効~要請~URI$は：
◎
has an effective request URI of
</p>

<pre>
http://www.example.org:8080/pub/WWW/TheProject.html
</pre>

<p>
例 2：
TLS で~secure化された~TCP接続~越しに受信された，次の~message：
◎
Example 2: the following message received over a TLS-secured TCP connection
</p>

<pre class="lang-http">
OPTIONS * HTTP/1.1
Host: www.example.org
</pre>

<p>
に対する`実効~要請~URI$は：
◎
has an effective request URI of
</p>

<pre>
https://www.example.org
</pre>

</div>

<p>
［
`Host$h ~headerを欠如する~HTTP10要請
］の`受信者$は、［
`実効~要請~URI$の `authority$p 成分
］を推測するために，経験則（例： 特定0の~hostに一意な何かに対する，~URI~pathの審査）の利用が必要になることもある。
◎
Recipients of an HTTP/1.0 request that lacks a Host header field might need to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to guess the effective request URI's authority component.
</p>

<div class="p">
<p>
`実効~要請~URI$が構築されたなら、`生成元~server$は，［
その~URIに対する~serviceを，［
要請が受信された接続
］を介して供するかどうか
］を裁定する必要がある。
例えば，受信された要請の［［
`request-target$p や `Host$h ~header
］の中の情報
］は，故意に, あるいは不用意に誤って［
接続が~~確立されている ~host＆~port とは相違するもの
］を~directしているかもしれない。
信用された`~gateway$からの接続であれば，その不整合は予期されたものかもしれないが、他の場合，次の試みを指示しているかもしれない
⇒＃
~security~filterを迂回する ／
非公開の内容を送達させるよう，~serverを騙す ／
~cacheを汚染する
◎
Once the effective request URI has been constructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received. For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received request-target or Host header field differs from the host or port upon which the connection has been made. If the connection is from a trusted gateway, that inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache.＼
</p>

<p>
~messageの経路制御に関する~securityの考慮点については、`9$secを見よ。
◎
See Section 9 for security considerations regarding message routing.
</p>
</div>

		</section>
		<section id="section-5.6">
<h3 title="Associating a Response to a Request">5.6. 応答から要請への結付法</h3>

<p>
~HTTPには、［
所与の要請~message
］を［
1 個~以上の，対応ng応答~message
］に結付けるような要請~識別子は，ない。
よって，その結付けは［
同じ接続~上で要請が為された順序が，応答が到着した順序に正確に対応する
］ことに依拠する。
1 個の要請に対し複数個の応答~messageが生じるのは、［
同じ要請に対する最終~応答に， 1 個~以上の `1xx$st 応答が先行する
］ときに限られる。
◎
HTTP does not include a request identifier for associating a given request message with its corresponding one or more response messages. Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection. More than one response message per request only occurs when one or more informational responses (1xx, see Section 6.2 of [RFC7231]) precede a final response to the same request.
</p>

<p>
`~client$は、接続~上に，
`応答待ち要請@
— まだ最終（非 `1xx$st ）応答が受信されていない要請 —
が複数個あるときには、［
それらの要請からなる，送信した順序による~list
］を保守し、［
その接続~上で応答~messageが受信された
］ときには，［
~listから~~先頭の要請を抜き取って，受信した応答に結付ける
］ことが`要求される^2119。
◎
A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response.
</p>

		</section>
		<section id="section-5.7">
<h3 title="Message Forwarding">5.7. ~messageの回送</h3>

<p>
`2.3$sec にて述べたように，`中継者$は、［
~HTTP要請＆応答の処理
］に際して，種々の`役割$に基いて~serveし得る。
`中継者$には、［
処理能や可用性を改善する
］ために利用されるものもあれば，［
~access制御~用／内容を~filterするため
］に利用されるものもある。
~HTTP~streamは，［
~pipe＆~filter ~architecture
］に類似な特性を有するので、~streamのいずれの方向についても，`中継者$が増強-（または干渉-）し得る限度に，内来的な制限はない。
◎
As described in Section 2.3, intermediaries can serve a variety of roles in the processing of HTTP requests and responses. Some intermediaries are used to improve performance or availability. Others are used for access control or to filter content. Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.
</p>

<p>
`~tunnel$として動作しない`中継者$は、`6.1$secによる指定-に従って，
`Connection$h ~headerを実装しなければナラナイ
— 加えて、一連の~headerを回送する際には，［
自身宛の接続のみに意図されているもの
］を除外しなければナラナイ。
◎
An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.1, and exclude fields from being forwarded that are only intended for the incoming connection.
</p>

<p>
`中継者$は、自身宛の~messageを回送してはナラナイ
— それが，無限~要請~loopから保護されていない限り【？】
。
一般に，`中継者$は、自前の~server名
— ［
別名,
局所的な変名,
~literal~IP~address
］も含む —
を認識して，そのような要請に対し直に応答する~OUGHT。
◎
An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop. In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.
</p>

			<section id="section-5.7.1">
<h4>5.7.1. `Via^h</h4>

<div class="p">

<p>
`Via$h ~headerは、［
~emailにおける "Received" ~header（`5322-3.6.7$rfc）
］に類似な，次のものを指示する
⇒＃
中継~protocolが在ること ／
要請においては、 `~UA$ ↔ ︎`~server$ 間にある，`受信者$たち ／
応答においては、 `生成元~server$ ↔ `~client$ 間にある，`受信者$たち
◎
The "Via" header field indicates the presence of intermediate protocols and recipients between the user agent and the server (on requests) or between the origin server and the client (on responses), similar to the "Received" header field in email (Section 3.6.7 of [RFC5322]).＼
</p>

<p>
`Via$h は、次の用途に利用できる
⇒＃
各~message回送-の追跡 ／
要請~loopを避ける ／
［ 要請／応答 ］`連鎖$沿いにある送信者たちの~protocol能力を識別する
◎
Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.
</p>

</div>

<pre class="bnf">
`Via@p = 1#( `received-protocol$p `RWS$p `received-by$p [ `RWS$p `comment$p ] )

`received-protocol@p = [ `protocol-name$p "/" ] `protocol-version$p
`received-by@p       = ( `uri-host$p [ ":" `port$p ] ) / `pseudonym$p
`pseudonym@p         = `token$p
</pre>

<p class="trans-note">【
“`pseudonym^p” ＝ “pseudo” + “anonymous” ＝“疑似匿名（仮名）”
】</p>

<p>
`Via$h `~header値$の各~entryは、［
~messageを回送した，`~proxy$や`~gateway$
］を表現する。
各`中継者$は、［
~messageがどのように受信されたかについての，自前の情報
］を，［
`受信者$たちが回送した順序が保たれる
］ように付加する。
◎
Multiple Via field values represent each proxy or gateway that has forwarded the message. Each intermediary appends its own information about how the message was received, such that the end result is ordered according to the sequence of forwarding recipients.
</p>

<div class="p">
<p>
`~proxy$は、回送する各~message内に，以下に述べるように［
適切な `Via$h ~header
］を送信しなければナラナイ。
◎
A proxy MUST send an appropriate Via header field, as described below, in each message that it forwards.＼
</p>

<p>
HTTP-to-HTTP `~gateway$は：
◎
An HTTP-to-HTTP gateway＼
</p>

<ul>
	<li>
`内方$への各~要請~message内には、適切な `Via$h ~headerを送信しなければナラナイ。
◎
MUST send an appropriate Via header field in each inbound request message and＼
</li>
	<li>
【外方へ】
回送する各~応答~messageには、 `Via$h ~headerを送信してヨイ。
◎
MAY send a Via header field in forwarded response messages.
</li>
</ul>
</div>

<p>
`received-protocol$p は、下流の`中継者$たちに対し，［
~messageの`上流$の`送信者$により利用された［
~protocolとその`~version$
］］を指示する。
すなわち， `Via$h `~header値$は、［
`下流$の`受信者$からも可視であり続ける
］ような［［
要請／応答
］`連鎖$にて広告された~protocol能力
］を記録する
— これは、`2.6$sec にて述べたように，［
どの［
後方-互換でない特能
］が，［
応答，あるいは今後の要請
］の中で利用するときに，安全になり得るか
］を決定するときに，有用になり得る。
~~簡潔にするため、受信される~protocolが~HTTPであるときは，
`received-protocol$p 内の `protocol-name^p は省略される
【されてヨイ？されなければナラナイ？】
。
◎
For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 2.6. For brevity, the protocol-name is omitted when the received protocol is HTTP.
</p>

<p>
［
`~header値$の `received-by$p の部位
］は，通常は［
受信者`~server$, または［
~messageを~~後続へ回送した`~client$
］］の［
`host$p, および省略可能な `port$p 番号
］になる。
しかしながら，［
本物の~hostは敏感な情報である
］と見なされる場合、`送信者$は，それを `pseudonym$p に置換してヨイ。
`port$p が供されていない場合、`受信者$は，それを［
`received-protocol$p の既定の~TCP~port上で受信されたことを意味している
］と解釈してヨイ
— 当の~protocolに既定の~TCP~portが定義されている限り。
◎
The received-by portion of the field value is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default TCP port, if any, for the received-protocol.
</p>

<p>
`送信者$は、各`受信者$の~softwareを識別するために
【識別する側とされる側が逆？】
，
`Via$h ~header内に `comment$p を`生成し$てヨイ
— ［
`User-Agent$h や`Server$h ~header
］に相似的な。
しかしながら、［
`Via$h ~header内のすべての~comment
］は，任意選択~であり、受信者は，~messageを回送するに先立って，それらを除去してヨイ。
◎
A sender MAY generate comments in the Via header field to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional, and a recipient MAY remove them prior to forwarding the message.
</p>

<div class="example">

<div class="p">
<p>
例えば，要請~messageが：
◎
For example, a request message could＼
</p>

<ol>
	<li>
~HTTP10`~UA$から［
~code名 "`fred^c" の内部~proxy
］に向けて送信され，
◎
be sent from an HTTP/1.0 user agent to an internal proxy code-named "fred",＼
</li>
	<li>
その内部~proxyは，それを［
`p.example.net^c にある公共~proxy
］に向けて回送するときに~HTTP11を利用し，
◎
which uses HTTP/1.1 to forward the request to a public proxy at p.example.net,＼
</li>
	<li>
その公共~proxyは，それを［
`www.example.com^c にある`生成元~server$
］に向けて回送して，完了した
◎
which completes the request by forwarding it to the origin server at www.example.com.＼
</li>
</ol>

<p>
とするとき、
`www.example.com^c にて受信される要請は，次の `Via$h ~headerを持つことになるだろう：
◎
The request received by www.example.com would then have the following Via header field:
</p>
</div>

<pre class="lang-http">
Via: 1.0 fred, 1.1 p.example.net
</pre>

</div>

<p>
［
~network~firewallを通る~portal
］として利用される`中継者$は、明示的に可能化されていない限り，［
~firewall領域の中の~hostたち
］の［
名前＆~port
］を回送するベキでない。
可能化されていない場合、そのような`中継者$は，［
~firewallの背後の~hostを表すような，各 `received-by$p `host$p
］を［
その~hostに適切な `pseudonym$p
］に置換するベキである。
◎
An intermediary used as a portal through a network firewall SHOULD NOT forward the names and ports of hosts within the firewall region unless it is explicitly enabled to do so. If not enabled, such an intermediary SHOULD replace each received-by host of any host behind the firewall by an appropriate pseudonym for that host.
</p>

<p>
`中継者$は、
`Via$h ~headerの中の，部分的な［［
`received-protocol$p 値がすべて一致する
］ような，~~連続する一連の~entry
］を，単独の~entryに結合してヨイ。
◎
An intermediary MAY combine an ordered subsequence of Via header field entries into a single such entry if the entries have identical received-protocol values.＼
</p>

<div class="example">

<p>
例えば：
◎
For example,
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy
</pre>

<p>
は、次の様に縮約することもできる：
◎
could be collapsed to
</p>

<pre class="lang-http">
Via: 1.0 ricky, 1.1 mertz, 1.0 lucy
</pre>

</div>

<div class="p">

<p>
`送信者$は：
◎
↓</p>

<ul>
	<li>
複数の~entryを，結合するベキでない
— ただし、それらすべてが同じ組織の制御~下にあり，かつ
それらの~hostがすでに `pseudonym$p に置換されている場合は除く。
◎
A sender SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms.＼
</li>
	<li>
［
`received-protocol$p 値が互いに異なる，複数の~entry
］を 1 個に結合してはナラナイ。
◎
A sender MUST NOT combine entries that have different received-protocol values.
</li>
</ul>
</div>

			</section>
			<section id="section-5.7.2">
<h4 title="Transformations">5.7.2. 形式変換</h4>

<p>
一部の`中継者$は、［
~messageとその`~payload$を，`形式変換する^dfn
］ための特能を有している。
例えば，`~proxy$には、［
~cache~~領域を節約したり,
遅い~link上の 流通~量を抑制する
］ために，画像~形式を変換するものもある。
しかしながら、これらの形式変換が［［
医療~画像処理や科学的~data分析などの~criticalな応用
］に意図されている~payload
］に適用されるとき，運用~上の問題が生じるかもしれない
— 特に、受信された~payloadが元と一致することを確保するために，完全性~検査や~digital署名が利用されている下では。
◎
Some intermediaries include features for transforming messages and their payloads. A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. However, operational problems might occur when these transformations are applied to payloads intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the payload received is identical to the original.
</p>

<p>
［
~messageを，意味論的に有意義な仕方で改変する
］ように［
設計され／環境設定され
］ている HTTP-to-HTTP `~proxy$は、
`形式変換ng~proxy@
と呼ばれる（改変するとは、通常の~HTTP処理に要求されるものを超えて，［
元の`送信者$にとって有意になる, あるいは
`下流$の`受信者$にとって有意になり得る
］ような仕方で~messageを変更することを意味する）。
例えば，形式変換ng~proxyには、［
共用~annotation~server（応答を，局所的~annotation~databaseへの参照を内包するように 改変する）,
~malware~filter,
形式~符号変換器,
~privacy~filter
］などとして，動作しているものもあるかもしれない。
そのような`形式変換$は、~client（または~client組織）が何であれ，［
`~client$が欲して`~proxy$を選定した
］ことが~~前提にあるとされる。
◎
An HTTP-to-HTTP proxy is called a "transforming proxy" if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients). For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter. Such transformations are presumed to be desired by whichever client (or client organization) selected the proxy.
</p>

<p>
`~proxy$は：
◎
↓</p>

<ul>
	<li>
<p>
受信した `request-target$p に［
完全修飾~domain名でない `host$p 名
］が伴われる場合には、要請を回送するときに，自前の~domainを
受信された`host$p 名に追加してヨイ。
◎
If a proxy receives a request-target with a host name that is not a fully qualified domain name, it MAY add its own domain to the host name it received when forwarding the request.＼
</p>

<p>
［
`request-target$p が完全修飾~domain名を包含する
］場合には，
`host$p 名を変更してはナラナイ。
◎
A proxy MUST NOT change the host name if the request-target contains a fully qualified domain name.
</p>

	</li>
	<li>
［
受信した `request-target$p を，次の`内方$`~server$へ回送する
］ときには，［
`absolute-path$p ＆ `query$p
］部を改変してはナラナイ
— ただし，上に注記された［
空~pathを "`/^c" または "`*^c" に置換する
］場合を除く。
◎
A proxy MUST NOT modify the "absolute-path" and "query" parts of the received request-target when forwarding it to the next inbound server, except as noted above to replace an empty path with "/" or "*".
</li>
	<li>
［
`転送~符号法$を，適用したり除去する
］ことを通して，`~message本体$を改変してヨイ。
◎
A proxy MAY modify the message body through application or removal of a transfer coding (Section 4).
</li>
	<li>
<!-- ＊ -->［
`no-transform^dir `Cache-Control$h 指令を包含する~message
］に対しては、その`~payload$を`形式変換-$してはナラナイ。
◎
A proxy MUST NOT transform the payload (Section 3.3 of [RFC7231]) of a message that contains a no-transform cache-control directive (Section 5.2 of [RFC7234]).
</li>
	<li>
<p>
［
`no-transform^dir `Cache-Control$h 指令を包含しない~message
］に対しては、その`~payload$を`形式変換-$してヨイ。
その際には、~message内に，［
`warn-code$p `214$wc ( `Transformation Applied^ph )
を伴う `Warning$h ~header
］を（もしなければ）追加しなければナラナイ。
</p>

<p>
加えて，［
`200$st 応答の`~payload$
］を`形式変換-$するときは、［
`応答~状態s~code$を `203$st に変更する
］ことにより，［
`下流$の`受信者$たち
］に，［
`形式変換$が適用されている
］ことを伝えることもできる。
</p>
◎
A proxy MAY transform the payload of a message that does not contain a no-transform cache-control directive. A proxy that transforms a payload MUST add a Warning header field with the warn-code of 214 ("Transformation Applied") if one is not already in the message (see Section 5.5 of [RFC7234]). A proxy that transforms the payload of a 200 (OK) response can further inform downstream recipients that a transformation has been applied by changing the response status code to 203 (Non-Authoritative Information) (Section 6.3.4 of [RFC7231]).
</li>
	<li>
<p>
次についての情報を供する~headerは，改変するベキでない：
◎
A proxy SHOULD NOT modify header fields that provide information about＼
</p>
		<ul>
			<li>
通信`連鎖$の両`端点$
◎
the endpoints of the communication chain,＼
</li>
			<li>
`資源$の状態
◎
the resource state, or＼
</li>
			<li>
`選定された表現$（`~payload$について以外の）
◎
the selected representation (other than the payload)＼
</li>
		</ul>
<p>
— ただし，次に該当するときは除く：
◎
unless＼
</p>
		<ul>
			<li>
~headerの定義が，そのような改変を特に許容している。
◎
the field's definition specifically allows such modification or＼
</li>
			<li>
~privacyや~securityのために，改変が必要と判断される。
◎
the modification is deemed necessary for privacy or security.
</li>
		</ul>
	</li>
</ul>

			</section>
		</section>
	</section>
	<section id="section-6">
<h2 title="Connection Management">6. 接続の管理</h2>

<p>
~HTTP~messagingは、［
下層の［
~transport／~session
］層における接続~protocolたち
］に依存しない。
~HTTPは、［［
各~要請の順序~通りの送達と，それらに対応する各~応答の順序~通りの送達
］が依拠-可能に~transportされる
］ことのみを~~前提にする。
~HTTP［
要請／応答
］の構造から［
下層~transport~protocolの~data単位
］上への対応付けは、この仕様の対象外である。
◎
HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s). HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses. The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.
</p>

<p>
`5.2$sec にて述べたように，~HTTP相互通信に利用される［
特定の接続~protocol
］は、［
`~client$環境設定, および`~target~URI$
］により決定される。
例えば， "`http$c" ~URI~schemeは、［［
既定の~TCP~port 80
］を伴う［
~TCP over ~IPの既定の接続
］］を指示するが、~clientは，［
何らかの他の［
接続 ／ ~port ／ ~protocol
］を介した~proxy
］を利用するようにも環境設定され得る。
◎
As described in Section 5.2, the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI. For example, the "http" URI scheme (Section 2.7.1) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.
</p>

<div class="p">
<p>
~HTTP実装には、接続の管理に参加することが期待されている
— それには，次が含まれる：
◎
HTTP implementations are expected to engage in connection management, which includes＼
</p>

<ul>
	<li>
現在の接続の状態を保守する。
◎
maintaining the state of current connections,＼
</li>
	<li>
新たな接続を確立したり, 既存の接続を再利用する。
◎
establishing a new connection or reusing an existing connection,＼
</li>
	<li>
接続~上にて受信された~messageを処理する。
◎
processing messages received on a connection,＼
</li>
	<li>
接続の失敗を検出する。
◎
detecting connection failures, and＼
</li>
	<li>
各~接続を~closeする。
◎
closing each connection.＼
</li>
</ul>

<p>
ほとんどの`~client$は、複数の接続
— 同じ~server`端点$に対する複数個の接続も含む —
を，並列的に保守する。
ほとんどの`~server$は、［
公正な利用は可能化しつつ，~DoS攻撃を検出する
］ために，［
要請の~queueを制御しながら, 幾千もの同時的~接続を保守する
］ように設計されている。
◎
Most clients maintain multiple connections in parallel, including more than one connection per server endpoint. Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.
</p>
</div>

		<section id="section-6.1">
<h3>6.1. `Connection^h</h3>

<p>
`Connection$h ~headerにより、`送信者$は，［
現在の接続に欲される制御~option
］を指示できるようになる。
`~proxy$／`~gateway$ は、`下流$の`受信者$たちが混同しないように，~messageを回送する前に，［
受信されたどの接続~option
］も【以下に述べる様に】 除去する, もしくは置換しなければナラナイ。
◎
The "Connection" header field allows the sender to indicate desired control options for the current connection. In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message.
</p>

<div class="p">

<p>
`送信者$は、［
現在の接続~用の／についての制御~情報を給する
］ために［
`Connection$h 以外の~header
］を利用するときには，［
対応ng `field-name$p
］を `Connection$h ~headerの中に~listしなければナラナイ。
◎
When a header field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field-name within the Connection header field.＼
</p>

<p>
`~proxy$／`~gateway$は、受信した~message `M^var を回送する前に，次を行わなければナラナイ：
◎
A proxy or gateway MUST＼
</p>

<ol>
	<li>
`M^var 内の `Connection$h ~header値を，構文解析する。
◎
parse a received Connection header field before a message is forwarded and,＼
</li>
	<li>
この~header内の各 `connection-option$p に対し， `M^var から［
`connection-option$p と同じ名前を伴う，すべての~header
］を除去する。
◎
for each connection-option in this field, remove any header field(s) from the message with the same name as the connection-option, and then＼
</li>
	<li>
［
`M^var から `Connection$h ~headerを除去する
］か, あるいは［
`M^var 内の `Connection$h の値を 自前の接続~optionで置換する
］。
◎
remove the Connection header field itself (or replace it with the intermediary's own connection options for the forwarded message).
</li>
</ol>

</div>

<p>
すなわち， `Connection$h ~headerは、［
直接の`受信者$のみに意図された
`隣点間~header@
］と,［
`連鎖$上のすべての`受信者$に意図された
`端点間~header@
］を判別できるようにする，宣言的な仕方を供する
— それは、~messageを自己-記述的にすることで，［
古い`中継者$により盲目的に回送されるおそれ
］なく，［
接続ごとに特有な，将来の拡張
］を配備できるようにする。
◎
Hence, the Connection header field provides a declarative way of distinguishing header fields that are only intended for the immediate recipient ("hop-by-hop") from those fields that are intended for all recipients on the chain ("end-to-end"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.
</p>

<p>
`Connection$h ~header値の文法は、次で与えられる：
◎
The Connection header field's value has the following grammar:
</p>

<pre class="bnf">
`Connection@p        = 1#`connection-option$p
`connection-option@p = `token$p
</pre>

<p>
`connection-option$p が各
`接続~option@
を与える。
それは、文字大小無視である。
◎
Connection options are case-insensitive.
</p>

<p>
`送信者$は、［
`~payload$を受け取るすべての`受信者$向けに意図された~header
］に対応するような`接続~option$を，送信してはナラナイ。
例えば， `Cache-Control$h は、接続~optionとしては，決して適切にならない。
◎
A sender MUST NOT send a connection option corresponding to a header field that is intended for all recipients of the payload. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [RFC7234]).
</p>

<p>
`接続~option$は，常に［
~message内に在る~header
］に対応するとは限らない
—
結付けられる~parameterがない接続~optionに対しては、［
接続ごとに特有な~header
］は不要になり得るので。
対照的に，［
対応する接続~optionを伴わずに受信された，
接続ごとに特有な~header
］は、通例的に［
~headerが`中継者$により不適正に回送された
］ことを指示するので，`受信者$は無視する~OUGHT。
◎
The connection options do not always correspond to a header field present in the message, since a connection-specific header field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific header field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.
</p>

<p>
仕様~策定者が，新たな`接続~option$を定義するときは、既存の`~header名$を調べて，［
新たな接続~optionが，すでに配備されている~headerと同じ名前を共有しない
］ことを確保する~OUGHT。
新たな接続~optionを定義することは、本質的に，その`~header名$を［
接続~optionに関係する追加的な情報
］を運ぶために予約することを~~意味し、送信者にとっては，その`~header名$を他の何かに利用することが無分別になるので。
◎
When defining new connection options, specification authors ought to survey existing header field names and ensure that the new connection option does not share the same name as an already deployed header field. Defining a new connection option essentially reserves that potential field-name for carrying additional information related to the connection option, since it would be unwise for senders to use that field-name for anything else.
</p>

<p>
`~close_接続~option@
は、`送信者$が，［
この接続が，応答の完了の後に~closeされる
］ことを他へ通達するためのものとして，定義される。
例えば：
◎
The "close" connection option is defined for a sender to signal that this connection will be closed after completion of the response. For example,
</p>

<div class="example">

<pre class="lang-http">
Connection: close
</pre>

</div>

<p>
要請, 応答のいずれにおいても、この~headerは，［
`送信者$が，現在の［
要請／応答
］が完了した（`6.6$sec）後に，接続を~closeしようとしている
］ことを指示する。
◎
in either the request or the response header fields indicates that the sender is going to close the connection after the current request/response is complete (Section 6.6).
</p>

<p>
［
`持続的な接続$を~supportしない`~client$
］は、毎~要請~messageごとに，`~close_接続~option$を送信しなければナラナイ。
◎
A client that does not support persistent connections MUST send the "close" connection option in every request message.
</p>

<p>
［
`持続的な接続$を~supportしない`~server$
］は、［
状態s~codeが `1xx$st でない
］ような毎~応答~messageごとに，`~close_接続~option$を送信しなければナラナイ。
◎
A server that does not support persistent connections MUST send the "close" connection option in every response message that does not have a 1xx (Informational) status code.
</p>

		</section>
		<section id="section-6.2">
<h3 title="Establishment">6.2. 確立法</h3>

<p>
接続が，様々な［
~transport／~session
］層の~protocolを介して確立される方法について述べることは、この仕様の視野を超える。
各~接続は、 1 個の~transport~linkのみに適用される。
◎
It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols. Each connection applies to only one transport link.
</p>

		</section>
		<section id="section-6.3">
<h3 title="Persistence">6.3. 持続性</h3>

<p>
`~HTTP11$では、
`持続的な接続^dfn
は，既定で利用できる
— これは、単独の接続~越しに，複数の［
要請や応答
］を運べるようにする。
`~close_接続~option$は、［
接続が現在の［
要請／応答
］の後に持続しない
］ことを通達するために利用される。
~HTTP実装は、`持続的な接続$を~supportするベキである。
◎
HTTP/1.1 defaults to the use of "persistent connections", allowing multiple requests and responses to be carried over a single connection. The "close" connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections.
</p>

<p>
`受信者$は、［
最も近過去に受信された~message
］の［
`~protocol~version$と `Connection$h ~header（もし在れば)
］に基づいて，［
接続が現在の応答の後にも持続することになるかどうか
］を決定する：
◎
A recipient determines whether a connection is persistent or not based on the most recently received message's protocol version and Connection header field (if any):
</p><!-- (or not) based on／or (not based on) -->

<ol>
	<li>
`~close_接続~option$が在るならば、持続しない。
◎
• If the "close" connection option is present, the connection will not persist after the current response; else,
</li>
	<li>
他の場合，［
受信された~protocolが`~HTTP11$（以上の~version）である
］ならば、持続する。
◎
• If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,
</li>
	<li>
<p>
他の場合，［
次の 4 条件のいずれも満たされる
］ならば、持続する：
</p>

<ul><li>受信された~protocolは~HTTP10である。
</li><li>"`keep-alive$c" `接続~option$が在る。
</li><li><del>受信者は~proxyでない。</del>
<ins>~messageは`~proxy$宛の要請ではない。</ins>†
</li><li>受信者は［
~HTTP10 による "`keep-alive$c" の仕組み
］を望んで尊守する。
</li></ul>

<p class="trans-note">【†
`4205$errataによる~~修正（ Verified: 2014-12-25）：
<del>, the recipient is not a proxy</del>
<ins >in a message that is not a request to a proxy</ins>
】</p>

◎
• If the received protocol is HTTP/1.0, the "keep-alive" connection option is present, the recipient is not a proxy, and the recipient wishes to honor the HTTP/1.0 "keep-alive" mechanism, the connection will persist after the current response; otherwise,
</li>
	<li>
他の場合，持続しない。
◎
• The connection will close after the current response.
</li>
</ol>

<p>
`~client$は、自身が，［
`~close_接続~option$を送信する, または受信する
］または［
`keep-alive$c" `接続~option$を伴わない~HTTP10応答を受信する
］まで、`持続的な接続$上に，追加的な要請を送信してヨイ。
◎
A client MAY send additional requests on a persistent connection until it sends or receives a "close" connection option or receives an HTTP/1.0 response without a "keep-alive" connection option.
</p>

<p>
持続的であり続けるためには、接続~上の どの~messageも，その長さが~message自身により定義される必要がある（ `3.3$sec — すなわち，長さは接続の~closureにより定義されるものではない）。
`~server$は、［
要請`~message本体$全体を読取る
］, または［
自身が応答を送信した後に接続を~closeする
］のいずれかをしなければナラナイ
— さもなければ［
`持続的な接続$上に残っている~data
］が，その次の要請として誤解釈されることになる。
同様に、`~client$は，［
後続の要請に同じ接続を再利用する
］ことを意図するならば［
応答~message本体~全体
］を読取らなければナラナイ。
◎
In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 3.3. A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.
</p>

<p>
`~proxy$~serverは、~HTTP10`~client$と伴に `持続的な接続$を保守してはナラナイ（多くの~HTTP10~clientにより実装されている `Keep-Alive$h ~headerに伴われる問題の，情報と論点については、 `2068-19.7.1$rfcを見よ）。
◎
A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).
</p>

<p>
~HTTP10~clientに対する後方~互換性についての更なる情報は、
`付録 A.1.2＠#appendix-A.1.2$ に。
◎
See Appendix A.1.2 for more information on backwards compatibility with HTTP/1.0 clients.
</p>

			<section id="section-6.3.1">
<h4 title="Retrying Requests">6.3.1. 要請の再試行</h4>

<p>
意向の有無に関わらず，接続はいつでも~closeできる。
実装は、［
非同期的な~close~eventから回復する必要があるかどうか
］を見越しておく~OUGHT。
◎
Connections can be closed at any time, with or without intention. Implementations ought to anticipate the need to recover from asynchronous close events.
</p>

<p>
`~client$は、`内方$への接続が尚早に~closeされたときは，［
中止された一連の要請
］を，それらすべてが`冪等~method$を持つならば、新たな接続を~openして，自動的に再~伝送してヨイ。
`~proxy$は、非~冪等~要請を自動的に再試行してはナラナイ。
◎
When an inbound connection is closed prematurely, a client MAY open a new connection and automatically retransmit an aborted sequence of requests if all of those requests have idempotent methods (Section 4.2.2 of [RFC7231]). A proxy MUST NOT automatically retry non-idempotent requests.
</p>

<div class="p">

<p>
`~UA$は、［
非 `冪等~method$を伴う要請
］を自動的に再試行してはナラナイ
— ただし，何らかの手段により次のいずれかを行い得るときは除く：
◎
A user agent MUST NOT automatically retry a request with a non-idempotent method unless it has＼
</p>

<ul>
	<li>
~methodに関わらず，実際に`要請の意味論$が`冪等$であることを知る。
◎
some means to know that the request semantics are actually idempotent, regardless of the method, or＼
</li>
	<li>
元の要請は決して【~target資源に】適用されていないことを検出する。
◎
some means to detect that the original request was never applied.＼
</li>
</ul>

<p>
例えば，［
所与の`資源$に対する `POST$m 要請が安全である
］ことを（設計または環境設定を通して）知る`~UA$は、その要請を自動的に繰返せる。
同様に，［
~version制御~repository上で運用するように特に設計された~UA
］は、部分的~失敗~条態から，概ね次の流れで回復するであろう：
◎
For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically. Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by＼
</p>

<ol>
	<li>
接続が失敗した後に，`~target資源$の改訂履歴を検査する。
◎
checking the target resource revision(s) after a failed connection,＼
</li>
	<li>
部分的に適用された変更を復帰するか修正する。
◎
reverting or fixing any changes that were partially applied,＼
</li>
	<li>
しかる後，その失敗した要請を自動的に再試行する。
◎
and then automatically retrying the requests that failed.
</li>
</ol>

</div>

<p>
`~client$は［
失敗した自動的な再試行-
］を自動的に再試行するベキでない。
◎
A client SHOULD NOT automatically retry a failed automatic retry.
</p>

			</section>
			<section id="section-6.3.2">
<h4 title="Pipelining">6.3.2. ~pipeline化</h4>

<p>
［
`持続的な接続$を~supportする`~client$
］は、自身の要請を，~pipeline化してヨイ（すなわち，各~応答を待機せずに，複数の要請を送信する）。
`~server$は、［
~pipeline化された一連の要請
］を，［
それらすべてが`安全~method$を持つ
］場合には，並列的に処理してヨイ
— その際には、［
要請が受信された順序と同じ順序
］で，対応ng応答を送信しなければナラナイ。
◎
A client that supports persistent connections MAY "pipeline" its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 4.2.1 of [RFC7231]), but it MUST send the corresponding responses in the same order that the requests were received.
</p>

<p>
要請を~pipeline化する`~client$は、［
対応ng応答のすべてを受信する前に 接続が~closeされた
］場合は，未~回答の要請を再試行するベキである。
接続が失敗した（接続が，~serverによる最後の完全な応答により明示的に~closeされていない）後に［
要請の~pipeline化を再試行する
］ときは、`~client$は，［
接続が確立された直後
］に~pipeline化してはナラナイ
— ［
先の~pipelineに残っている要請のうち，~~最初のもの
］が、~error応答をもたらした可能性があり，［
複数の要請が［
尚早に~closeされた接続
］上に送信される
］場合に再び失われ得るので（`6.6$sec にて述べる~TCP~reset問題を見よ）。
◎
A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 6.6).
</p>

<p>
`冪等~method$は、~pipelineにとって有意である
— それらは，接続~失敗の後に自動的に再試行できるので。
`~UA$は、非~冪等~methodの後に，［
その~methodに対する最終 `応答~状態s~code$
］が受信されるまでは，要請を~pipeline化するベキでない
— ただし，`~UA$が［
~pipeline化された一連の要請を孕んでいる
部分的~失敗~条態
］を［
検出し, それを回復する手段を持っている
］場合は除く。
◎
Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to pipelining because they can be automatically retried after a connection failure. A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.
</p>

<div class="p">

<p>
~pipeline化された要請たちを受信した`中継者$は、それらを`内方$へ回送するときには，~pipeline化してもヨイ
— 要請を安全に~pipeline化できるかどうかは，`外方$の~UAたちに依拠して決定できるので。
~pipeline化している`中継者$は、ある応答を受信する前に，`内方$への接続が失敗した場合には：
◎
An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined. If the inbound connection fails before receiving a response, the pipelining intermediary＼
</p>

<ul>
	<li>
すべての要請が`冪等~method$を持つならば、［
要請たちのうち，対応ng応答がまだ受信されていないもの
］の再試行-を試みてヨイ。
◎
MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods;＼
</li>
	<li>
他の場合、受信された応答はすべて回送してから，対応ng`外方$への接続（たち）を~closeするベキである
— `外方$の~UAたちが，それに則って回復できるようにするため。
◎
otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.
</li>
</ul>

</div>

			</section>
		</section>
		<section id="section-6.4">
<h3 title="Concurrency">6.4. 同時並行性</h3>

<p>
`~client$は、所与の`~server$に対し保守する［
同時~open接続~数
］を制限する~OUGHT。
◎
A client ought to limit the number of simultaneous open connections that it maintains to a given server.
</p>

<p>
~HTTPの以前の改訂では、接続~数に特定の~~上限を設けていたが、これは，多くの~appにとり実用的でないことが判っている。
そのため，この仕様は、特定0の最大~接続~数を義務付けない
— 代わりに、~clientが複数の接続を~openするにあたっては，保守的になることを奨励する。
◎
Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.
</p>

<p>
複数~接続は、概して， “head-of-line blocking” 問題
— ［
`~server$側に重い処理を要したり, 巨大な`~payload$を持つ
］ような要請が、同じ接続~上の後続の要請を阻むこと —
を避けるために利用される。
しかしながら、接続のそれぞれは，~server資源を消費する。
更には、複数の接続が利用された場合，混雑した~networkに，望ましくない副作用をもたらし得る。
◎
Multiple connections are typically used to avoid the "head-of-line blocking" problem, wherein a request that takes significant server-side processing and/or has a large payload blocks subsequent requests on the same connection. However, each connection consumes server resources. Furthermore, using multiple connections can cause undesirable side effects in congested networks.
</p>

<p>
`~server$は、単独の~clientからの過度の~open接続~数など，［
濫用的あるいは, ~DoS攻撃の特性を有している
］と判断した流通を，却下することもあることに注意。
◎
Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.
</p>

		</section>
		<section id="section-6.5">
<h3 title="Failures and Timeouts">6.5. 失敗と制限時間</h3>

<p>
`~server$は、通例的に，何らかの制限時間~値を持つ
— それを超過したときには，作動中でない接続を最早~保守しなくなるような。
`~proxy$~serverは、この値をより高くすることもある
— `~client$は、同じ~proxy~serverを通して，更なる接続を~~確立する見込みが高いので。
`持続的な接続$の利用は、［
`~client$／`~server$
］いずれに対しても，［
この制限時間の長さ（または その有無）
］に要件を設置しない。
◎
Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.
</p>

<p>
制限時間を望む［
`~client$／`~server$
］は、接続~上に上品な~closeを発行するベキである。
実装は、［
~open接続にて受信される~closure通達
］を常時~監視して，それに対し適切に応答するベキである
— 接続の両~側に向けて~closureを促すことで，割振られた~system資源を取戻せるようになるので。
◎
A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.
</p>

<p>
［
`~client$／`~server$／`~proxy$
］は、~transport接続をいつでも~closeしてヨイ。
例えば、~serverが “遊休~中” の接続を~closeするものと裁定したと同時に，~clientが新たな要請の送信を開始することもあり得る
— その場合、~server視点からは，遊休~中に接続が~closeされているように見える一方で、~client視点からは，要請は進捗~中に見えることになる。
◎
A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the "idle" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.
</p>

<p>
`~server$は、アリなときは，`持続的な接続$を維持させ, ［
一時的な過負荷は、下層~transportの~flow制御の仕組みにより解決できる
］ようにするベキである
—
`~client$が再試行する期待に基づいて，接続を終了させる技法は、~network混雑を悪化させ得るので。
◎
A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads, rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.
</p>

<p>
［
`~message本体$を送信している`~client$
］は、要請を伝送している間，［
~network接続における~error応答
］を監視するベキである。
~clientは、［［
`~server$が，~message本体を受信することを望まず，接続を~closeしている
］ことを指示する応答
］を受け取ったときには，本体の伝送処理を即時に止めた上で，自身の側の接続を~closeするベキである。
◎
A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.
</p>

		</section>
		<section id="section-6.6">
<h3 title="Tear-down">6.6. 解体</h3>

<p>
`Connection$h ~headerは、`~close_接続~option$を供する
— それは、`送信者$が［［
現在の［
要請/応答
］~pair
］の後に，接続を~closeしたいと望む
］ときに送信されるベキである。
◎
The Connection header field (Section 6.1) provides a "close" connection option that a sender SHOULD send when it wishes to close the connection after the current request/response pair.
</p>

<div class="p">
<p>
`~close_接続~option$を包含させた要請を送信した`~client$は：
◎
A client that sends a "close" connection option＼
</p>

<ul>
	<li>
同じ接続~上に，更なる要請を送信してはナラナイ。
◎
MUST NOT send further requests on that connection (after the one containing "close") and＼
</li>
	<li>
この要請に対応する最終~応答~messageを読取ったときは，その接続を~closeしなければナラナイ。
◎
MUST close the connection after reading the final response message corresponding to this request.
</li>
</ul>
</div>

<div class="p">

<p>
`~close_接続~option$が包含された要請を受信した`~server$は：
◎
A server that receives a "close" connection option＼
</p>

<ul>
	<li>
［
その要請に対する最終~応答
］を送信した後に［
接続の~close（下を見よ）
］を起動しなければナラナイ。
◎
MUST initiate a close of the connection (see below) after it sends the final response to the request that contained "close".＼
</li>
	<li>
加えて，その最終~応答~内に［
`~close_接続~option$
］を送信するベキである。
◎
The server SHOULD send a "close" connection option in its final response on that connection.＼
</li>
	<li>
［
その接続~上に受信された, どの更なる要請
］も，処理してはナラナイ。
◎
The server MUST NOT process any further requests received on that connection.
</li>
</ul>

</div>

<div class="p">
<p>
`~close_接続~option$を包含させた応答を送信した`~server$は：
◎
A server that sends a "close" connection option＼
</p>

<ul>
	<li>
接続の~close（下を見よ）を起動しなければナラナイ。
◎
MUST initiate a close of the connection (see below) after it sends the response containing "close".＼
</li>
	<li>
その接続~上に受信された, どの更なる要請も，処理してはナラナイ。
◎
The server MUST NOT process any further requests received on that connection.
</li>
</ul>

</div>

<div class="p">
<p>
`~close_接続~option$が包含された応答~messageを受信した`~client$は：
◎
A client that receives a "close" connection option＼
</p>

<ul>
	<li>
その接続~上の要請の送信を止めた上で，その応答を読取った後に，接続を~closeしなければナラナイ
◎
MUST cease sending requests on that connection and close the connection after reading the response message containing the "close";＼
</li>
	<li>
【その応答を受信する前に】
同じ接続~上に，追加的な［
~pipeline化された要請
］を送信していた場合、［
それらが`~server$により処理される
］ものと見做すベキでない。
◎
if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.
</li>
</ul>
</div>

<p>
`~server$が［
~TCP接続の即時~close
］を遂行した場合、［
`~client$が最後の~HTTP応答を読取れなくなる
］有意な~riskがある：
~server【側の~TCP~stack】が，［
全部的に~closeされた接続
］上で［
~clientから追加的な~data
］を受信した場合
— 例えば、~clientが，~serverの応答を受信する前に送信した 別の要請など —
~serverの~TCP~stackは、~clientへ向けて，~reset~packetを送信することになる。
が、あいにく，~reset~packet【を受け取った~client側の~TCP~stack】は、［
~clientの~HTTP構文解析器が，入力~bufferを読取って解釈する
］前に，~clientから承認されないまま，~bufferを消去し得る。
◎
If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response. If the server receives additional data from the client on a fully closed connection, such as another request that was sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.
</p>

<div class="p">

<p>
~TCP~reset問題を避けるため、`~server$は概して，次の段階を踏んで接続を~closeする：
◎
To avoid the TCP reset problem, servers typically close a connection in stages.＼
</p>

<ol>
	<li>
［
読取n, 書込n
］接続のうち，書込n側のみを~closeする。
◎
First, the server performs a half-close by closing only the write side of the read/write connection.＼
</li>
	<li>
<p>
次のいずれかの時点まで，接続からの読取りを継続する：
◎
The server then continues to read from the connection＼
</p>
		<ul>
			<li>
~clientによる，対応ng~closeを受信したとき。
◎
until it receives a corresponding close by the client, or＼
</li>
			<li>
［
~clientが［
`~server$の最後の応答を包含している~packetたちを承認した
］ことについて，~serverが自前の~TCP~stackが受信した
］ことを、~serverが適度に~~確信できたとき。
◎
until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response.＼
</li>
		</ul>
	</li>
	<li>
接続を全部的に~closeする。
◎
Finally, the server fully closes the connection.
</li>
</ol>

</div>

<p>
~reset問題が［
~TCP に固有なのか，他の~transport接続~protocolにも見出され得るのか
］は、未知である。
◎
It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.
</p>

		</section>
		<section id="section-6.7">
<h3>6.7. `Upgrade^h</h3>

<p>
`Upgrade$h ~headerは、［［
ある接続~上で，`~HTTP11$から 何らかの他の~protocolへ移行する
］ための単純な仕組み
］を意図して供されている。
`~client$は、［［
`~server$が最終~応答を送信する
］前に，［
1 個~以上の他の~protocol
］に切替えてもらうよう，~serverを招く
］ために，［
要請の `Upgrade$h ~header
］内に，［
選好順による，~protocolの~list
］を送信してヨイ。
`~server$は、その接続~上で，現在の~protocolを利用し続けたいと望むならば，［
受信された `Upgrade$h ~header
］を無視してヨイ。
`Upgrade$h を利用して，~protocol変更を強要することはできない。
◎
The "Upgrade" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection. A client MAY send a list of protocols in the Upgrade header field of a request to invite the server to switch to one or more of those protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.
</p>

<pre class="bnf">
`Upgrade@p          = 1#`protocol$p

`protocol@p         = `protocol-name$p ["/" `protocol-version$p]
`protocol-name@p    = `token$p
`protocol-version@p = `token$p
</pre>

<div class="p">
<p>
`101$st 応答を送信する`~server$は：
◎
A server that sends a 101 (Switching Protocols) response＼
</p>

<ul>
	<li>
`Upgrade$h ~headerを送信して、切替えようとしている接続に対し，
1 個~以上の新たな~protocolを指示しなければナラナイ。
◎
MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched;＼
</li>
	<li>
切替えようとしている~protocol層が複数ある場合，それらを，最下~層のものから昇順に~listしなければナラナイ。
◎
if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order.＼
</li>
	<li>
~protocolを［［［
~clientによる，対応ng要請
］の `Upgrade$h ~header
］内に指示されていないもの
］に切替えてはナラナイ。
◎
A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field.＼
</li>
	<li>
［
~clientにより指示された 選好~順序
］を無視することを選択して，［
要請の資質や, ~server上の現在の負荷などの，他の因子に基づく新たな†~protocol（たち）
］を選定してヨイ。
【† “新たな” — 前項に反しない中で】
◎
A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.
</li>
</ul>

</div>

<p>
`~server$は：
</p>

<ul>
	<li>
`426$st 応答を送信するときは、［
受容-可能な~protocolを指示する
］ために，［
選好順による， `Upgrade$h ~header
］を送信しなければナラナイ。
◎
A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.
</li>
	<li>
他の応答においても、未来の要請~用に適切になるときは，［
選好順による， `Upgrade$h ~header
］を送信して，［
自身が［
~listされた~protocolに昇格するための~support
］を実装している
］ことを広告してヨイ。
◎
A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.
</li>
</ul>

<div class="example">

<p>
~clientにより送信される仮の例を次に示す：
◎
The following is a hypothetical example sent by a client:
</p>

<pre class="lang-http">
GET /hello.txt HTTP/1.1
Host: www.example.com
Connection: upgrade
Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
</pre>

</div>

<p>
~protocol変更~後の［
~app~levelの通信の能力や資質
］は、［
選択される新たな~protocol（たち）
］に全面的に依存する。
しかしながら，`~server$は、
`101$st 応答を送信した直後に［
新たな~protocolの中で 元の要請に等価なものを受信した
］かのように，応答を継続するものと期待されている（すなわち、~protocolが変更された後であっても，~serverは依然として［
まだ充足するべき`応答待ち要請$
］を持ち，［
要請の繰返し
］を要求することなく，そうするものと期待されている）。
◎
The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).
</p>

<p>
例えば，~serverが、［
`GET$m 要請にて `Upgrade$h ~headerが受信された
］下で，~protocolを切替えるものと裁定した場合には、まず［
HTTP/1.1 `101$st ~message
］で応答した直ぐ後に，［
新たな~protocolにおける［
`~target資源$上の `GET$m に対する応答
］に等価なもの
］が後続する。
これにより、追加的な往来による待時間~costなしに，［
~HTTPと同じ意味論を有する~protocol
］へ接続を昇格できるようになる。
`~server$は、新たな~protocolが［
受信された~message意味論
］を尊守し得ない場合は，~protocolを切替えてはナラナイ
—
`OPTIONS$m 要請は，どの~protocolからも尊守し得る。
◎
For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.
</p>

<div class="example">

<p>
上に示された仮の要請に対する応答~例を，次に示す：
◎
The following is an example response to the above hypothetical request:
</p>

<pre class="lang-http">
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: HTTP/2.0

<span class="comment"
>[…… "`GET /hello.txt^c" 要請に対し，適切な応答により~data~streamを
HTTP/2.0 に切替える（その新たな~protocolによる定義に従って）…… ]
◎
[... data stream switches to HTTP/2.0 with an appropriate response
(as defined by new protocol) to the "GET /hello.txt" request ...]</span>
</pre>

</div>

<p>
`Upgrade$h を送信する`送信者$は、［
`Upgrade$h が［
~listされた~protocolを実装していない`中継者$
］により不用意に回送される
］ことを防ぐために，［
"`upgrade^c" `接続~option$を包含する `Connection$h ~header
］も送信しなければナラナイ。
`~server$は、［
~HTTP10要請にて受信された `Upgrade$h ~header
］を無視しなければナラナイ。
◎
When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.1) that contains an "upgrade" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols. A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.
</p>

<p>
`~client$は、［
要請~messageを完全に送信し終える
］まで，接続~上にて昇格された~protocolの利用を~~開始できない（すなわち、~clientは，~messageの中途で［
送信している~protocol
］を変更できない）。
`~server$が，
`Upgrade$h と［
`~100cont 期待$を伴う `Expect$h ~header
］の両者を受信したときは、
`101$st 応答を送信する前に，
`100$st 応答を送信しなければナラナイ。
◎
A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the "100-continue" expectation (Section 5.1.1 of [RFC7231]), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.
</p>

<p>
`Upgrade$h ~headerは，［
既存の接続の上層にある~protocolの切替
］にのみ適用される。
それは［
下層~接続の（~transport）~protocolの切替
］, あるいは［
既存の通信を異なる接続に切替えること
］には利用し得ない。
その種の目的には、
`3xx$st 応答の利用が，より適切である。
◎
The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 6.4 of [RFC7231]).
</p>

<p>
この仕様は、［
~HTTP`~version$規則, および
この仕様に対する将来の更新
］に定義されるように，［
Hypertext Transfer Protocol 族
］に利用するための ~protocol名として， "`HTTP^c" のみを定義する。
追加的な~tokenは，
`8.6$sec にて定義される登録~手続-を利用して
~IANAにより登録される~OUGHT。
◎
This specification only defines the protocol name "HTTP" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 2.6 and future updates to this specification. Additional tokens ought to be registered with IANA using the registration procedure defined in Section 8.6.
</p>

		</section>
	</section>
	<section id="section-7">
<h2 title="ABNF List Extension: #rule">7. ~ABNF ~list拡張： <code >#`規則^var</code></h2>

<p>
一部の`~header値$の定義を読み易くするため、
`5234$R の~ABNF規則に対する拡張
<code >#`規則^var</code>
が利用される：
◎
A #rule extension to the ABNF rules of [RFC5234] is used to improve readability in the definitions of some header field values.
</p>

<p>
構成子 "`#^c" は、~commaで区切られた要素からなる~listを定義するために，
"`*^c" と類似に定義される。
全部的な形は，
<code>&lt;`n^var&gt;#&lt;`m^var&gt;`<var>element</var>^p</code>
であり、［［
1 個の~comma （"`,^c"）とその前後の省略可能な空白（ `OWS$p ）
］で互いに分離される，
`n^var 個〜 `m^var 個までの
`<var>element</var>^p
］を指示する。
◎
A construct "#" is defined, similar to "*", for defining comma-delimited lists of elements. The full form is "&lt;n&gt;#&lt;m&gt;element" indicating at least &lt;n&gt; and at most &lt;m&gt; elements, each separated by a single comma (",") and optional whitespace (OWS).
</p>

<p>
`送信者$は、~list構成子を利用するどの生成規則に対しても，［
空な［
~list要素
］］を`生成し$てはナラナイ。
言い換えれば、送信者は，［
次の構文を充足する~list
］を`生成し$なければナラナイ：
◎
In any production that uses the list construct, a sender MUST NOT generate empty list elements. In other words, a sender MUST generate lists that satisfy the following syntax:
</p>

<pre class="bnf">
1#`element^var =&gt; `element^var *( `OWS$p "," `OWS$p `element^var )
</pre>

<p>
および：
◎
and:
</p>

<pre class="bnf">
#`element^var =&gt; [ 1#`element^var ]
</pre>

<p>
`n^var &gt;= 1, `m^var &gt; 1 に対し：
◎
and for n &gt;= 1 and m &gt; 1:
</p>

<pre class="bnf">
&lt;`n^var&gt;#&lt;`m^var&gt;`element^var =&gt; `element^var &lt;`n-1^var&gt;*&lt;`m-1^var&gt;( `OWS$p "," `OWS$p `element^var )
</pre>

<p>
旧来の~list規則との互換性のため、`受信者$は，［
適度な数の空~list要素
］を構文解析しつつ，それを超える分は無視しなければナラナイ
— ［
送信者が値を併合する際にやりがちな誤りを取扱うに十分
］かつ［
~DoS攻撃の仕組みとして利用し得るほど多量ではない
］ような。
言い換えれば、受信者は，次の構文を充足する どの~listも受容しなければナラナイ：
◎
For compatibility with legacy list rules, a recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism. In other words, a recipient MUST accept lists that satisfy the following syntax:
</p>

<pre class="bnf">
#`element^var =&gt; [ ( "," / `element^var ) *( `OWS$p "," [ `OWS$p `element^var ] ) ]

1#`element^var =&gt; *( "," `OWS$p ) `element^var *( `OWS$p "," [ `OWS$p `element^var ] )
</pre>

<p class="trans-note">【
`5257$errataに報告あり（ Reported: 2018-02-07 ）：
この構文には後方-互換でない部分があるので、修正されるべき（詳細は参照先に）。
】</p>

<p>
空~要素は、在る要素に数えられない。
例えば，次の~ABNF生成規則が与えられたとき：
◎
Empty elements do not contribute to the count of elements present. For example, given these ABNF productions:
</p>

<pre class="bnf">
`example-list^p      = 1#`example-list-elmt^p
`example-list-elmt^p = `token$p
</pre>

<div class="example">

<p>
次のいずれも、 `example-list^p に対する妥当な値になる（二重引用符は含まない — それは，区切りを示すためのみに在る）：
◎
Then the following are valid values for example-list (not including the double quotes, which are present for delimitation only):
</p>

<pre>
"foo,bar"
"foo ,bar,"
"foo , ,bar,charlie"
</pre>

<p class="trans-note">【
`4169$errata（ Verified: 2014-11-10 ）に従って， "`charlie^c" の尾部にあった空白は削除-済み
】</p>

<p>
対照的に，次のいずれも，妥当でない値になる
— `example-list^p 生成規則には， 1 個~以上の空でない要素が要求されるので：
◎
In contrast, the following values would be invalid, since at least one non-empty element is required by the example-list production:
</p>

<pre>
""
","
",   ,"
</pre>

</div>

<p>
`付録 B＠#appendix-B$
にて，受信者~用の［
~list構成子が展開された後の，総集的な~ABNF
］を示す。
◎
Appendix B shows the collected ABNF for recipients after the list constructs have been expanded.
</p>

	</section>
	<section id="section-8">
<h2 title="IANA Considerations">8. ~IANA 考慮点</h2>

		<section id="section-8.1">
<h3 title="Header Field Registration">8.1. ~headerの登録</h3>

<p>
~HTTP~headerは、
`Message Headers ~registry＠~IANA-a/message-headers/$
にて保守され，登録される。
◎
HTTP header fields are registered within the "Message Headers" registry maintained at &lt;http://www.iana.org/assignments/message-headers/&gt;.
</p>

<p>
この文書は、次の各種~HTTP~headerを定義する。
それに伴い，
"Permanent Message Header Field Names"
~registryは更新された（`BCP90$r を見よ）。
◎
This document defines the following HTTP header fields, so the "Permanent Message Header Field Names" registry has been updated accordingly (see [BCP90]).
</p>

<div>
<table><thead><tr><td>`~header名$
<td>~protocol
<td>位置付け
</thead>

<tbody><tr><td>`Connection$h
<td>http
<td>standard

<tr><td>`Content-Length$h
<td>http
<td>standard

<tr><td>`Host$h
<td>http
<td>standard

<tr><td>`TE$h
<td>http
<td>standard

<tr><td>`Trailer$h
<td>http
<td>standard

<tr><td>`Transfer-Encoding$h
<td>http
<td>standard

<tr><td>`Upgrade$h
<td>http
<td>standard

<tr><td>`Via$h
<td>http
<td>standard

</tbody></table>
<pre lang="en" class="_en">
   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | Section 6.1   |
   | Content-Length    | http     | standard | Section 3.3.2 |
   | Host              | http     | standard | Section 5.4   |
   | TE                | http     | standard | Section 4.3   |
   | Trailer           | http     | standard | Section 4.4   |
   | Transfer-Encoding | http     | standard | Section 3.3.1 |
   | Upgrade           | http     | standard | Section 6.7   |
   | Via               | http     | standard | Section 5.7.1 |
   +-------------------+----------+----------+---------------+
</pre>

</div>

<p>
更には、 `~header名$ `Close^h が "reserved" として登録された
— ［
その名前を~HTTP~headerとして利用する
］ことは、［
`Connection$h ~headerの `~close_接続~option$
］と競合するかもしれないので。
◎
Furthermore, the header field-name "Close" has been registered as "reserved", since using that name as an HTTP header field might conflict with the "close" connection option of the Connection header field (Section 6.1).
</p>

<div>
<table><thead><tr><td>`~header名$
<td>~protocol
<td>位置付け
<td>参照
</thead>

<tbody><tr><td>`Close^h
<td>`http$c
<td>reserved
<td>この節

</tbody></table>
<pre lang="en" class="_en">
   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | Section 8.1 |
   +-------------------+----------+----------+-------------+
</pre>

</div>

<p>
変更管理者は~IETF-orgである。
◎
The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</p>

		</section>
		<section id="section-8.2">
<h3 title="URI Scheme Registration">8.2. ~URI~schemeの登録</h3>

<p>
~IANAは、
`URI Schemes ~registry＠~IANA-a/uri-schemes/$
`BCP115$r を保守する。
◎
IANA maintains the registry of URI Schemes [BCP115] at &lt;http://www.iana.org/assignments/uri-schemes/&gt;.
</p>

<p>
この文書は、次の~URI~schemeを定義する。
それに伴い、 "Permanent URI Schemes" ~registryは，更新された。
◎
This document defines the following URI schemes, so the "Permanent URI Schemes" registry has been updated accordingly.
</p>

<div >
<table><thead><tr><td>~URI~scheme
<td>記述
</thead>

<tbody><tr><td>`http$c
<td>Hypertext Transfer Protocol

<tr><td>`https$c
<td>Hypertext Transfer Protocol Secure

</tbody></table>
<pre lang="en" class="_en">
   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | Section 2.7.1 |
   | https      | Hypertext Transfer Protocol Secure | Section 2.7.2 |
   +------------+------------------------------------+---------------+
</pre>

</div>

		</section>
		<section id="section-8.3">
<h3 title="Internet Media Type Registration">8.3. ~MIME型の登録</h3>

<p>
~IANAは、
`~MIME型~registry＠~IANA-a/media-types$
`BCP13$r を保守する。
◎
IANA maintains the registry of Internet media types [BCP13] at &lt;http://www.iana.org/assignments/media-types&gt;.
</p>

<p>
この文書は、~MIME型［
`message/http$c,
`application/http$c
］用の仕様として~serveする。
次のものが~IANAにより登録された。
◎
This document serves as the specification for the Internet media types "message/http" and "application/http". The following has been registered with IANA.
</p>

			<section id="section-8.3.1">
<h4 title="Internet Media Type message/http">8.3.1. ~MIME型 `message/http^c</h4>

<p>
`message/http^c 型は、単独の~HTTP［
要請／応答
］~messageを，同封するために利用し得る
— それが、すべての "message" 型に対し，行lの長さと符号化法に関して ~MIME制約を順守する限りにおいて。
◎
The message/http type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all "message" types regarding line length and encodings.
</p>

<dl>
	<dt></dt>
	<dd>
</dd>

	<dt></dt>
	<dd>
</dd>
</dl>
<dl>
	<dt>
型~名
◎
Type name:
</dt>
	<dd>
`message^c
</dd>

	<dt>
下位型~名
◎
Subtype name:
</dt>
	<dd>
`http^c
</dd>

	<dt>
要求される~parameter
◎
Required parameters:
</dt>
	<dd>
N/A
</dd>

	<dt>
省略可能な~parameter
◎
Optional parameters:
</dt>
	<dd>
<p>
`version^var, `msgtype^var
</p>
		<dl>
			<dt>`version^var</dt>
			<dd>
同封された~messageの `HTTP-version$p 番号（例： "`1.1^c" ）。
無い場合の`~version$は、本体の最初の行lから決定し得る。
◎
The HTTP-version number of the enclosed message (e.g., "1.1"). If not present, the version can be determined from the first line of the body.
</dd>

			<dt>`msgtype^var</dt>
			<dd>
~message型 — "`request^c" または "`response^c" 。
無い場合の型は、本体の最初の行lから決定し得る。
◎
The message type -- "request" or "response". If not present, the type can be determined from the first line of the body.
</dd>
		</dl>
	</dd>
	<dt>
符号化法に対する考慮点
◎
Encoding considerations:
</dt>
	<dd>
"`7bit^c", "`8bit^c", "`binary^c" のみ許可される
◎
only "7bit", "8bit", or "binary" are permitted
</dd>

	<dt>
~securityの考慮点
◎
Security considerations:
</dt>
	<dd>
`9$secを見よ
</dd>

	<dt>
相互運用能の考慮点
◎
Interoperability considerations:
</dt>
	<dd>
N/A
</dd>

	<dt>
公表された仕様
◎
Published specification:
</dt>
	<dd>
この仕様（`8.3.1$secを見よ）
</dd>

	<dt>
この~MIME型を利用する~app
◎
Applications that use this media type:
</dt>
	<dd>
N/A
</dd>

	<dt>
`fragment$p 識別子に対する考慮点
◎
Fragment identifier considerations:
</dt>
	<dd>
N/A
</dd>

	<dt>
追加的な情報
◎
Additional information:
</dt>
	<dd>
		<dl>
			<dt>Magic number(s):</dt>
			<dt>Deprecated alias names for this type:</dt>
			<dt>File extension(s):</dt>
			<dt>Macintosh file type code(s):</dt>
			<dd>N/A</dd>
		</dl>
	</dd>

	<dt>
Person and email address to contact for further information:
</dt>
	<dd>
`著作者連絡先$に。
◎
See Authors' Addresses section.
</dd>

	<dt>
意図される利用e
◎
Intended usage:
</dt>
	<dd>
COMMON
</dd>

	<dt>
利用e上の制約
◎
Restrictions on usage:
</dt>
	<dd>
N/A
</dd>

	<dt>
著作者
◎
Author:
</dt>
	<dd>
`著作者連絡先$に。
◎
See Authors' Addresses section.
</dd>

	<dt>
変更管理者
◎
Change controller:
</dt>
	<dd>
IESG
</dd>
</dl>

			</section>
			<section id="section-8.3.2">
<h4 title="Internet Media Type application/http">8.3.2. ~MIME型 `application/http^c</h4>

<p>
`application/http^c 型は、~pipeline化された 1 個~以上の~HTTP［
要請~messageのみ／応答~messageのみ
］を同封するときに利用できる。
◎
The application/http type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).
</p>

<dl>
	<dt>
型~名
◎
Type name:
</dt>
	<dd>
`application^c
</dd>

	<dt>
下位型~名
◎
Subtype name:
</dt>
	<dd>
`http^c
</dd>

	<dt>
要求される~parameter
◎
Required parameters:
</dt>
	<dd>
N/A
</dd>

	<dt>
省略可能な~parameter
◎
Optional parameters:
</dt>
	<dd>
<p>
`version^var, `msgtype^var
</p>
		<dl>
			<dt>`version^var</dt>
			<dd>
同封された~messageの `HTTP-version$p 番号（例："`1.1^c" ）。
無い場合の`~version$は、本体の最初の行lから決定し得る。
◎
The HTTP-version number of the enclosed messages (e.g., "1.1"). If not present, the version can be determined from the first line of the body.
</dd>

			<dt>`msgtype^var</dt>
			<dd>
~message型 — "`request^c" または "`response^c" 。
無い場合の型は、本体の最初の行lから決定し得る。
◎
The message type -- "request" or "response". If not present, the type can be determined from the first line of the body.
</dd>
		</dl>
	</dd>

	<dt>
符号化法に対する考慮点
◎
Encoding considerations:
</dt>
	<dd>
この型により同封された［
一連の~HTTP~message
］は、 "binary" 形式になる
— ~emailを介して伝送されるときは、［
適切な `Content-Transfer-Encoding$h
］の利用が要求される。
◎
HTTP messages enclosed by this type are in "binary" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email.
</dd>

	<dt>
~securityの考慮点
◎
Security considerations:
</dt>
	<dd>
`9$secを見よ
</dd>

	<dt>
相互運用能の考慮点
◎
Interoperability considerations:
</dt>
	<dd>
N/A
</dd>

	<dt>
公表された仕様
◎
Published specification:
</dt>
	<dd>
この仕様（ `8.3.2$secを見よ）
</dd>

	<dt>
この~MIME型を利用する~app
◎
Applications that use this media type:
</dt>
	<dd>
N/A
</dd>

	<dt>
`fragment$p 識別子に対する考慮点
◎
Fragment identifier considerations:
</dt>
	<dd>
N/A
</dd>

	<dt>
追加的な情報
◎
Additional information:
</dt>
	<dd>
		<dl>
			<dt>Deprecated alias names for this type:</dt>
			<dt>Magic number(s):</dt>
			<dt>File extension(s):</dt>
			<dt>Macintosh file type code(s):</dt>
			<dd>N/A</dd>
		</dl>
</dd>

	<dt>
Person and email address to contact for further information:
</dt>
	<dd>
`著作者連絡先$に。
◎
See Authors' Addresses section.
</dd>

	<dt>
意図される利用e
◎
Intended usage:
</dt>
	<dd>
COMMON
</dd>

	<dt>
利用e上の制約
◎
Restrictions on usage:
</dt>
	<dd>
N/A
</dd>

	<dt>
著作者
◎
Author:
</dt>
	<dd>
`著作者連絡先$に。
◎
See Authors' Addresses section.
</dd>

	<dt>
変更管理者
◎
Change controller:
</dt>
	<dd>
IESG
</dd>
</dl>

			</section>
		</section>
		<section id="section-8.4">
<h3 title="Transfer Coding Registry">8.4. 転送~符号法~registry</h3>

<p>
`転送~符号法~名$~用の名前空間は、
`HTTP Transfer Coding Registry＠~IANA-a/http-parameters$
にて保守され，定義される。
◎
The "HTTP Transfer Coding Registry" defines the namespace for transfer coding names. It is maintained at &lt;http://www.iana.org/assignments/http-parameters&gt;.
</p>

			<section id="section-8.4.1">
<h4 title="Procedure">8.4.1. 手続-</h4>

<p>
登録にあたっては、次の~fieldを内包しなければナラナイ：
◎
Registrations MUST include the following fields:
</p>

<ul>
	<li>
名前
◎
• Name
</li>
	<li>
記述
◎
• Description
</li>
	<li>
仕様~textへの~pointer
◎
• Pointer to specification text
</li>
</ul>

<p>
各 `転送~符号法~名$は、`内容~符号法~名$と重なってはナラナイ
— 符号化法の形式変換が一致していない限り（ 4.2 節に定義される各種 `圧縮~符号法$に該当するものなど）。
◎
Names of transfer codings MUST NOT overlap with names of content codings (Section 3.1.2.1 of [RFC7231]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 4.2.
</p>

<p>
この名前空間に追加される値は、`~IETFによる考査$を要し，［
この仕様にて定義される`転送~符号法$の目的
］に適合しなければナラナイ。
◎
Values to be added to this namespace require IETF Review (see Section 4.1 of [RFC5226]), and MUST conform to the purpose of transfer coding defined in this specification.
</p>

<p>
~program名は，符号化~形式の識別子としては望ましくないので、将来の符号化法には用いないことが奨励される。
◎
Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.
</p>

			</section>
			<section id="section-8.4.2">
<h4 title="Registration">8.4.2. 登録</h4>

<p>
"HTTP Transfer Coding Registry"
は、以下の登録により更新された：
◎
The "HTTP Transfer Coding Registry" has been updated with the registrations below:
</p>

<div>
<table><thead><tr><td>名前
<td>記述
</thead>

<tbody><tr><td>"`chunked$c"
<td>一連の~chunkによる転送

<tr><td>"`compress$c"
<td>UNIX "compress" ~data形式 `Welch$r

<tr><td>"`deflate$c"
<td>
"zlib" ~data形式 `1950$R の内側の "deflate" 圧縮-済み~data `1951$R

<tr><td>"`gzip$c"
<td>GZIP ~file形式 `1952$R

<tr><td>"`x-compress^c"
<td>非推奨d（ "`compress$c" の別名）

<tr><td>"`x-gzip^c"
<td>非推奨d（ "`gzip$c" の別名）

</tbody></table>
<pre lang="en" class="_en">
   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | Section 4.1   |
   | compress   | UNIX "compress" data format [Welch]  | Section 4.2.1 |
   | deflate    | "deflate" compressed data            | Section 4.2.2 |
   |            | ([RFC1951]) inside the "zlib" data   |               |
   |            | format ([RFC1950])                   |               |
   | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |
   | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |
   | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |
   +------------+--------------------------------------+---------------+
</pre>

</div>

			</section>
		</section>
		<section id="section-8.5">
<h3 title="Content Coding Registration">8.5. 内容~符号法~登録</h3>

<p>
~IANAは、
`HTTP Content Coding Registry＠~IANA-a/http-parameters$
を保守する。
◎
IANA maintains the "HTTP Content Coding Registry" at &lt;http://www.iana.org/assignments/http-parameters&gt;.
</p>

<p>
"HTTP Content Coding Registry"
は、以下の登録により更新された：
◎
The "HTTP Content Coding Registry" has been updated with the registrations below:
</p>

<div>
<table><thead><tr><td>名前
<td>記述
</thead>

<tbody><tr><td>"`compress$c"
<td>UNIX "compress" ~data形式 `Welch$r

<tr><td>"`deflate$c"
<td>
"zlib" ~data形式 `1950$R の内側の "deflate" 圧縮-済み~data `1951$R

<tr><td>"`gzip$c"
<td>GZIP file format `1952$R

<tr><td>"`x-compress^c"
<td>非推奨d（ "`compress$c" の別名）

<tr><td>"`x-gzip^c"
<td>非推奨d（ "`gzip$c" の別名）

</tbody></table>
<pre lang="en" class="_en">
   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX "compress" data format [Welch]  | Section 4.2.1 |
   | deflate    | "deflate" compressed data            | Section 4.2.2 |
   |            | ([RFC1951]) inside the "zlib" data   |               |
   |            | format ([RFC1950])                   |               |
   | gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |
   | x-compress | Deprecated (alias for compress)      | Section 4.2.1 |
   | x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |
   +------------+--------------------------------------+---------------+
</pre>

</div>

		</section>
		<section id="section-8.6">
<h3 title="Upgrade Token Registry">8.6. `Upgrade^h ~token~registry</h3>

<p>
［
`Upgrade$h ~header内の~protocolを識別するために利用される，
`protocol-name$p ~token
］用の名前空間は、
`Hypertext Transfer Protocol (HTTP) Upgrade Token Registry＠~IANA-a/http-upgrade-tokens$
（ HTTP `Upgrade^h ~token~registry）にて保守され，定義される。
◎
The "Hypertext Transfer Protocol (HTTP) Upgrade Token Registry" defines the namespace for protocol-name tokens used to identify protocols in the Upgrade header field. The registry is maintained at &lt;http://www.iana.org/assignments/http-upgrade-tokens&gt;.
</p>

			<section id="section-8.6.1">
<h4 title="Procedure">8.6.1. 手続-</h4>

<p>
登録-済みの各~protocol名は、［
連絡~先~情報
］, および［［
接続が，昇格された後にどのように処理されるか
］について詳細を述べる仕様の集合（省略可能）
］に結付けられる。
◎
Each registered protocol name is associated with contact information and an optional set of specifications that details how the connection will be processed after it has been upgraded.
</p>

<p>
登録は、
"First Come First Served"
に基づいて行われ（`5226-4.1$rfc），次の規則の~subjectになる：
◎
Registrations happen on a "First Come First Served" basis (see Section 4.1 of [RFC5226]) and are subject to the following rules:
</p>

<ol>
	<li>
一度~登録された `protocol-name$p ~tokenは、登録されたまま~~恒久的に居残る。
◎
1. A protocol-name token, once registered, stays registered forever.
</li>
	<li>
登録は、登録に対する責任-主体を命名しなければナラナイ。
◎
2. The registration MUST name a responsible party for the registration.
</li>
	<li>
登録は、連絡~窓口を命名しなければナラナイ。
◎
3. The registration MUST name a point of contact.
</li>
	<li>
登録は、［
その~tokenに結付けられる仕様の集合
］を命名してヨイ。
そのような仕様は、公に可用になる必要はない。
◎
4. The registration MAY name a set of specifications associated with that token. Such specifications need not be publicly available.
</li>
	<li>
登録は、［
登録の時点でその~tokenに結付けられる［
予期される "`protocol-version$p" ~tokenからなる集合
］］を命名するベキである。
◎
5. The registration SHOULD name a set of expected "protocol-version" tokens associated with that token at the time of registration.
</li>
	<li>
責任-主体は、いつでも登録を変更してヨイ。
~IANAは、そのような変更sすべての記録-を保って，要請に応じて，それらを可用にすることになる。
◎
6. The responsible party MAY change the registration at any time. The IANA will keep a record of all such changes, and make them available upon request.
</li>
	<li>
IESG は、
`protocol$p ~tokenに対する責任-主体を他にアテガってヨイ。
これは通常，責任-主体に連絡をとれなくなったときに限られる。
◎
7. The IESG MAY reassign responsibility for a protocol token. This will normally only be used in the case when a responsible party cannot be contacted.
</li>
</ol>

<p>
HTTP Upgrade Tokens 用の，この登録~手続-
以前に `2817-7.2$rfc にて定義されたものを置換する。
◎
This registration procedure for HTTP Upgrade Tokens replaces that previously defined in Section 7.2 of [RFC2817].
</p>

			</section>
			<section id="section-8.6.2">
<h4 title="Upgrade Token Registration">8.6.2. `Upgrade^h ~tokenの登録</h4>

<p>
`Upgrade^h ~token~registry内の "`HTTP^c" ~entryは、次の登録により更新された：
◎
The "HTTP" entry in the upgrade token registry has been updated with the registration below:
</p>

<div>
<table><thead><tr><td>値
<td>記述
<td>予期される~version~token
<td>参照
</thead>

<tbody><tr><td>HTTP
<td>Hypertext Transfer Protocol
<td>任意の `DIGIT.DIGIT^c （例： "`2.0^c" ）
<td>`2.6$sec

</tbody></table>
<pre lang="en" class="_en">
   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | Section 2.6 |
   |       | Protocol             | (e.g, "2.0")         |             |
   +-------+----------------------+----------------------+-------------+
</pre>

</div>

<p>
責任-主体は~IETF-orgである。
◎
The responsible party is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</p>

			</section>
		</section>
	</section>
	<section id="section-9">
<h2 title="Security Considerations">9. ~securityの考慮点</h2>

<p>
この節は、［
開発者／情報~provider／利用者
］に，~HTTP~messageの［
構文, 構文解析, 経路制御
］に関連な，既知な~securityの考慮点を伝えることを~~意図している。
~HTTPの［
意味論／`~payload$
］についての，~securityの考慮点は、`7231$R にて取組まれる。
◎
This section is meant to inform developers, information providers, and users of known security considerations relevant to HTTP message syntax, parsing, and routing. Security considerations about HTTP semantics and payloads are addressed in [RFC7231].
</p>

		<section id="section-9.1">
<h3 title="Establishing Authority">9.1. 権限の確立</h3>

<p>
~HTTPは、
`権限的~応答@
の~~概念（ notion ）に依拠する：
それは、［
応答~messageの出生時における`~target資源$の状態
］が与えられた下で
— 要請に対する，最も適切な応答になるように — 
`~target~URI$の中で識別される権限（ `authority$p ）により決定される（または, ~directされる）応答である。
［
`共用~cache$などの非~権限的な源から，応答を供すること
］は，［
処理能や可用性の向上に有用になる
］ことが多いが、安全に利用できるのは，源が信用できる限度までであり、さもなければ応答は信用できないものになる。
◎
HTTP relies on the notion of an authoritative response: a response that has been determined by (or at the direction of) the authority identified within the target URI to be the most appropriate response for that request given the state of the target resource at the time of response message origination. Providing a response from a non-authoritative source, such as a shared cache, is often useful to improve performance and availability, but only to the extent that the source can be trusted or the distrusted response can be safely used.
</p>

<div class="p">

<p>
あいにく、権限の確立は 困難にもなり得る。
例えば，~phishingは、［
権限に対する利用者の知覚
］に対する攻撃である。
その知覚は、~hypertext内に類似な銘柄が呈示されることで，誤誘導され得る
— 場合によっては［
`authority$p 成分（権限）をごまかす `userinfo$p
］でも補強されて。
`~UA$は、~phishing攻撃による影響iを，次により抑制できる：
◎
Unfortunately, establishing authority can be difficult. For example, phishing is an attack on the user's perception of authority, where that perception can be misled by presenting similar branding in hypertext, possibly aided by userinfo obfuscating the authority component (see Section 2.7.1). User agents can reduce the impact of phishing attacks＼
</p>

<ul>
	<li>
利用者が何らかの動作をとるに先立って、`~target~URI$を，利用者から検分し易くする。
◎
by enabling users to easily inspect a target URI prior to making an action,＼
</li>
	<li>
`userinfo$p が在るときは、それを目立つ様に~~区別する（または却下する）。
◎
by prominently distinguishing (or rejecting) userinfo when present, and＼
</li>
	<li>
参照先の文書が［
未知な, あるいは信用できない
］源からのものであるときは，格納されている`資格証$や~cookieを送信しない。
◎
by not sending stored credentials and cookies when the referring document is from an unknown or untrusted source.
</li>
</ul>

</div>

<p>
登録-済みの名前が `authority$p 成分~内に利用されるとき、
"`http$c" ~URI~schemeは，［
`権限的~応答$がどこで見出せるかを決定する
］ときに［
利用者に局所的な名前~解決~service
］に依拠する。
これは、利用者の［
~network~host~table ／
~cacheされている名前 ／
名前~解決~library
］に対するどの攻撃も，権限の確立に対する攻撃に繋がることを意味する。
同様に、［
利用者が~DNS（ Domain Name Service ）用に選択した~server
］, および［
解決の結果を得するときに用いた，~server階層
］は，［
~address対応付けの真正性
］にも影響iし得る
— 真正性を改善する仕方の一つには、 DNS Security Extensions（ DNSSEC, `4033$R ）がある。
◎
When a registered name is used in the authority component, the "http" URI scheme (Section 2.7.1) relies on the user's local name resolution service to determine where it can find authoritative responses. This means that any attack on a user's network host table, cached names, or name resolution libraries becomes an avenue for attack on establishing authority. Likewise, the user's choice of server for Domain Name Service (DNS), and the hierarchy of servers from which it obtains resolution results, could impact the authenticity of address mappings; DNS Security Extensions (DNSSEC, [RFC4033]) are one way to improve authenticity.
</p>

<p>
更には、~IP~addressが得された後の，［
"`http$c" ~URI に対する権限の確立
］は、［
Internet Protocol 経路制御に対する攻撃
］に脆弱である。
◎
Furthermore, after an IP address is obtained, establishing authority for an "http" URI is vulnerable to attacks on Internet Protocol routing.
</p>

<div class="p">

<p>
"`https$c" `scheme$p は、［
権限の確立に対する，前述したような攻撃の可能性
］の多くを防ぐ（または少なくとも露呈する）ことを意図している
— 次のいずれも~~満たされる限りにおいて：
◎
The "https" scheme (Section 2.7.2) is intended to prevent (or at least reveal) many of these potential attacks on establishing authority, provided that＼
</p>

<ul>
	<li>
折衝される~TLS接続は~secure化されている。
◎
the negotiated TLS connection is secured and＼
</li>
	<li>
`~client$は、自身が通信している`~server$の同一性を，`~target~URI$の `authority$p 成分（`2818$R）に合致するかどうかにより，適正に検証yしている。
◎
the client properly verifies that the communicating server's identity matches the target URI's authority component (see [RFC2818]).＼
</li>
</ul>

<p>
そのような検証yを正しく実装することが、困難なこともある（ `Georgiev$r ）。
◎
Correctly implementing such verification can be difficult (see [Georgiev]).
</p>
</div>

		</section>
		<section id="section-9.2">
<h3 title="Risks of Intermediaries">9.2. 中継者の~risk</h3>

<p>
~HTTP`中継者$は，本質的に中間者であり、従って［
中間者~攻撃の~~機会
］を表現する。
［
中継者が稼働する~system
］が弱体化されると、深刻な［
~security／~privacy
］問題になり得る。
中継者は，［［
~securityに関係する情報
］,［
個々の［
利用者／組織
］についての個人-情報
］,［
利用者と内容~providerに所属している~proprietary情報
］］へも~accessし得るかもしれない。
弱体化された, もしくは［
~securityや~privacyへの考慮点
］に目を向けずに［
実装された／環境設定された
］中継者は、その引き換えに広範な攻撃に晒され得る。
◎
By their very nature, HTTP intermediaries are men-in-the-middle and, thus, represent an opportunity for man-in-the-middle attacks. Compromise of the systems on which the intermediaries run can result in serious security and privacy problems. Intermediaries might have access to security-related information, personal information about individual users and organizations, and proprietary information belonging to users and content providers. A compromised intermediary, or an intermediary implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks.
</p>

<p>
［
`共用~cache$を包含する`中継者$
］は、`7234-8$rfc にて述べられるように，~cache汚染~攻撃に とりわけ脆弱である。
◎
Intermediaries that contain a shared cache are especially vulnerable to cache poisoning attacks, as described in Section 8 of [RFC7234].
</p>

<p>
実装者たちは、［
設計と coding に際しての裁定, および
運用者に供する環境設定~option（とりわけ，既定の環境設定）
］による，~privacyや~securityに対する含意を考慮する必要がある。
◎
Implementers need to consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to operators (especially the default configuration).
</p>

<p>
利用者は、`中継者$が，それらを稼働させている~~人々以上に信用に価するものにはならないことを意識しておく必要がある
—
~HTTP自身は、この問題を解決sできない。
◎
Users need to be aware that intermediaries are no more trustworthy than the people who run them; HTTP itself cannot solve this problem.
</p>

		</section>
		<section id="section-9.3">
<h3 title="Attacks via Protocol Element Length">9.3. ~protocol要素の長さを介した攻撃</h3>

<p>
~HTTPは，大方，文字で区切られる~textな~header利用するので、構文解析器は，［
長大な（または とても遅い）~data~streamの送信に基づく攻撃
］に脆弱になることが多い
— 特に，実装が［
定義済み長さがない~protocol要素
］を予期している所では。
◎
Because HTTP uses mostly textual, character-delimited fields, parsers are often vulnerable to attacks based on sending very long (or very slow) streams of data, particularly where an implementation is expecting a protocol element with no predefined length.
</p>

<p>
相互運用能を促進するため、
`request-line$p, および各種`~header$には，最低限の~size制限についての 特定の推奨が為される。
これらは、［［
資源が制限された実装でも~support可能になる
］ような最低限の推奨になる
］ように選択されている
— ほとんどの実装は，相当に高い制限を選択することになると予期されている。
◎
To promote interoperability, specific recommendations are made for minimum size limits on request-line (Section 3.1.1) and header fields (Section 3.2). These are minimum recommendations, chosen to be supportable even by implementations with limited resources; it is expected that most implementations will choose substantially higher limits.
</p>

<p>
`~server$は［
`request-target$p が長過ぎる（`7231-6.5.12$rfc）, あるいは
要請~payloadが巨大~過ぎる（`7231-6.5.11$rfc）
］ような~messageを却下できる。
［
容量~制限に関係する追加的な状態s~code
］が，~HTTPの拡張 `6585$R により定義されている。
◎
A server can reject a message that has a request-target that is too long (Section 6.5.12 of [RFC7231]) or a request payload that is too large (Section 6.5.11 of [RFC7231]). Additional status codes related to capacity limits have been defined by extensions to HTTP [RFC6585].
</p>

<p>
`受信者$は、［
自身が処理する他の~protocol要素の限度
］を注意深く制限する~OUGHT。
それらの一部には、次も含まれる：［
`要請~method$,
応答~状態s句
【 `reason-phrase$p, `事由~句$ 】,
`~header値$,
数的な値,
本体~chunk
］。
そのような処理における制限の失敗は、~buffer~overflowや算術的な桁溢れ, あるいは~DoS攻撃への脆弱性を高める結果になり得る。
◎
Recipients ought to carefully limit the extent to which they process other protocol elements, including (but not limited to) request methods, response status phrases, header field-names, numeric values, and body chunks. Failure to limit such processing can result in buffer overflows, arithmetic overflows, or increased vulnerability to denial-of-service attacks.
</p>

		</section>
		<section id="section-9.4">
<h3 title="Response Splitting">9.4. 応答~分割</h3>

<p>
`応答~分割^dfn
（いわゆる `CRLF$P 注入）は、~Web利用eに対する様々な攻撃で共通的に利用される技法であり，［
~HTTP~message~frame法の，行lに基づく資質
］と［
`持続的な接続$における，要請から応答への順序~付けられた結付け
］を悪用する
`Klein$r
。
この技法は、特に，［
要請が`共用~cache$を通して渡される
］ときに被害を大きくし得る。
◎
Response splitting (a.k.a, CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]. This technique can be particularly damaging when the requests pass through a shared cache.
</p>

<p>
応答~分割は、［
要請の何らかの~parameter
— 後に，復号され, 応答の何らかの~headerの中に 復唱されるような~parameter —
の中に，攻撃者が符号化-済み~dataを送信できる
］ような，`~server$における脆弱性（通例的に~app~serverの中）を悪用する。
~dataが，［
それを復号した結果が，応答が終端され, 後続の応答が始まる
］ように見せかけて細工されていた場合、応答は分割され，［
2 番目であるように見せかけた応答
］の内容が攻撃者により制御される。
しかる後，攻撃者は、［
同じ`持続的な接続$ 上に，他の何らかの要請を為して
］，`受信者$（`中継者$も含む）に［
分割-の~~後半部分が， 2 番目の要請に対する`権限的$な回答である
］と信じ込ませることも可能になる。
◎
Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response. If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split and the content within the apparent second response is controlled by the attacker. The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.
</p>

<p>
例えば，［
`request-target$p の中の~parameter
］は、［
~app~serverにより読取られ, ~redirectの中で再利用される
］結果、同じ~parameterが応答の `Location$h ~header内に復唱され得る。
~parameterが［
~appにより復号され，応答~header内に置かれる
］ときに，適正に符号化されない下では、攻撃者は、［
符号化-済みの `CRLF$P ~octetその他の内容
］を送信して，~appの単独の応答を 2 個~以上の応答に見せかけられるようになる。
◎
For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response. If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses.
</p>

<p>
応答~分割に対抗する共通的な防御策は、要請の中の［
符号化-済みの `CR$P `LF$P 並びに見せかけた~data
］を~filterするものであるが、それは［
~app~serverが~URIの復号しか遂行していない
］ことを前提にしている
— より見え難い~data形式変換：［
~charset符号変換,
~XML実体~翻訳,
base64 復号,
sprintf 再整形,
等々
］は~~考慮されていない。
それより，［
~serverの中核~protocol~library
］以外のどこであれ，［
`~header節$の中に `CR$P や `LF$P を送信する
］ことを防ぐ方が、効果的な軽減策になる
— それは、~headerの出力を［
不良~octetを~filterする~API
］に制約して，［
~app~serverが~protocol~streamへ直に書込めなくする
］ことを意味する。
◎
A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., "%0D" and "%0A"). However, that assumes the application server is only performing URI decoding, rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc. A more effective mitigation is to prevent anything other than the server's core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream.
</p>

		</section>
		<section id="section-9.5">
<h3 title="Request Smuggling">9.5. 要請~密入</h3>

<p>
要請~密入（`Linhart$r）は、［
様々な受信者~間での，~protocol構文解析-法における相違点
］を悪用して，［
無害に見せかけた要請
］の中に［
（さもなければ施策により阻止されるか不能化されるような）追加的な要請
］を隠す技法である。
`応答~分割$と同様に、要請~密入は，~HTTP利用eにおいて種々の攻撃を導き得る。
◎
Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request. Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.
</p>

<p>
この仕様は、［
要請~密入の実効性
］を抑制するため、特に，~message~frame法に関して，［
要請の構文解析に課される新たな要件（`3.3.3$sec）
］を導入した。
◎
This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 3.3.3, to reduce the effectiveness of request smuggling.
</p>

		</section>
		<section id="section-9.6">
<h3 title="Message Integrity">9.6. ~messageの完全性</h3>

<p>
~HTTPは、［［
~messageの完全性を確保する
］ための特定の仕組み
］を定義しない。
代わりに［
下層~transport~protocolの~error検出~能
］, および［［
完全かどうかを検出する
］ための［
長さや, ~chunkで区切られる~frame法
］の利用
］に依拠する。
［
~hash関数や, 内容に適用される~digital署名
］などの［
完全性のための追加的な仕組み
］は、各種［
拡張-可能な~metadata~header
］を介して，選択的に，~messageに追加できる。
歴史的に、［
単一の，完全性の仕組み
］の欠如は，［
ほとんどの~HTTP通信が正式でない性向にあること
］を根拠に正当化されていた。
しかしながら、情報~accessの仕組みとして，~HTTPが普及した結果、［
~message完全性の検証yが不可欠な環境
］下での利用は，増加している。
◎
HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness. Additional integrity mechanisms, such as hash functions or digital signatures applied to the content, can be selectively added to messages via extensible metadata header fields. Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication. However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial.
</p>

<p>
`~UA$には、［
完全性が必要な環境~下でも、環境設定により，~messageの完全性の失敗を検出して報告できる
］ようにする手段を実装することが奨励される。
例えば，［
医療~履歴や薬剤相互作用についての情報
］を視るために利用されている~browserは、［
そのような情報が転送の間に［
不完全である／失効した／破損した
］ことが~protocolにより検出された
］ことを，利用者に指示できることが必要とされる。
そのような仕組みは，［
~UA拡張や, 応答に~message完全性~metadataが在ること
］を介して選択的に可能化できるであろう。
`~UA$は、そのような検証yが欲されるときは、最小限，［
応答~messageは完全か`不完全$かを，利用者が判別できる
］ような，何らかの指示を供する~OUGHT。
◎
User agents are encouraged to implement configurable means for detecting and reporting failures of message integrity such that those means can be enabled within environments for which integrity is necessary. For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer. Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response. At a minimum, user agents ought to provide some indication that allows a user to distinguish between a complete and incomplete response message (Section 3.4) when such verification is desired.
</p>

		</section>
		<section id="section-9.7">
<h3 title="Message Confidentiality">9.7. ~messageの機密性</h3>

<p>
~HTTPは、［
~messageの機密性が欲されるときに，それを供する
］にあたり，下層の~transport~protocolに依拠する。
~HTTPは、［
多くの異なる形をとる，暗号化された接続
］にも利用し得るように，［
~transport~protocolに依存しない
］ように特に設計されてきた。
そのような~transportの選定は、［
選択された~URI~schemeや, ~UA環境設定
］により識別されている。
◎
HTTP relies on underlying transport protocols to provide message confidentiality when that is desired. HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many different forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.
</p>

<p>
機密的~接続を要求する`資源$を識別するためには、
"`https$c" `scheme^p を利用できる。
◎
The "https" scheme can be used to identify resources that require a confidential connection, as described in Section 2.7.2.
</p>

		</section>
		<section id="section-9.8">
<h3 title="Privacy of Server Log Information">9.8. ~server~log情報の~privacy</h3>

<p>
`~server$は、［
期間に渡る利用者の要請についての個人-~data
］を保存する立場にあり，［
利用者の行動様式や関心事
］も識別し得る。
特に，［
`中継者$に集められた~log情報
］は、［
不特定多数の~siteにまたがる，~UA との相互通信の履歴
］を包含することが多く，個々の利用者を~traceし得る。
◎
A server is in the position to save personal data about a user's requests over time, which might identify their reading patterns or subjects of interest. In particular, log information gathered at an intermediary often contains a history of user agent interaction, across a multitude of sites, that can be traced to individual users.
</p>

<p>
~HTTP~log情報は，その資質からして機密的なので、その取扱いは，法律や規制により拘束されることが多い。
~log情報は、~secureに格納された上で，その分析に際しては適切な指針に従う必要がある。
［
個々の~entryの中の個人-情報の匿名化
］も補助になるが、一般に，本物の~log~traceから［
他の~access特性による相関
］に基づいて再~識別されることを防ぐには十分でない。
そのようなわけで、［
特定の`~client$に対し~keyされる~access~trace
］の流出は，~keyが疑似匿名であっても安全とは言えない。
◎
HTTP log information is confidential in nature; its handling is often constrained by laws and regulations. Log information needs to be securely stored and appropriate guidelines followed for its analysis. Anonymization of personal information within individual entries helps, but it is generally not sufficient to prevent real log traces from being re-identified based on correlation with other access characteristics. As such, access traces that are keyed to a specific client are unsafe to publish even if the key is pseudonymous.
</p>

<p>
盗聴や不用意な流出の~riskを最小限にするためには、個人識別可能な情報
— ［
利用者~識別子,
~IP~address,
利用者が供した `query$p ~parameter
］なども含む
— は，［
~security／ auditing【監査】／ fraud control【不正行為の~~規制】
などの，運用~上の必要性を~supportする
］ことが必要とされなくなり次第，~log情報から一掃される~OUGHT。
◎
To minimize the risk of theft or accidental publication, log information ought to be purged of personally identifiable information, including user identifiers, IP addresses, and user-provided query parameters, as soon as that information is no longer necessary to support operational needs for security, auditing, or fraud control.
</p>

		</section>
	</section>
	<section id="section-10">
<h2 title="Acknowledgments">10. 謝辞</h2>

<p class="trans-note">【
この節の内容は、
`RFC723X 共通~page＠~723X#acknowledgments$
に移譲。
】</p>

	</section>
	<section id="section-11">
<h2 title="References">11. 参照文献</h2>

<p class="trans-note">【
この節の内容は、
`RFC723X 共通~page＠~723X#references$
に移譲。
】</p>

	</section>

	<section id="appendix-A">
<h2 title="Appendix A. HTTP Version History">付録 A. HTTP ~versionの歴史</h2>

<p>
~HTTPは 1990 年から利用されてきた。
後に~HTTP09と称されるようになった最初の~versionは、
~Internetをまたがる~hypertext~data転送~用の単純な~protocolで，［
~metadataの無い単独の要請~method（`GET$m ）
］のみを利用していた。
`1945$Rにより定義された~HTTP10には、［
~metadataの転送や, ［
要請／応答
］意味論を改変する
］ことを許容するために［
ある範囲の`要請~method$と, ~MIME に似た~messaging
］が追加された。
しかしながら、
~HTTP10は［
階層的~proxy,
~caching,
`持続的な接続$の必要性,
名前~based仮想~host
］の効果を十分に考慮点に入れてなかった。
更に、［
自身を "HTTP/1.0" と称して，不完全に実装された~app
］の急増から、［
通信-中の 2 つの~appが互いの~~真の能力を決定する
］ための，~protocol~version変更が~~余儀なくされた。
◎
HTTP has been in use since 1990. The first version, later referred to as HTTP/0.9, was a simple protocol for hypertext data transfer across the Internet, using only a single request method (GET) and no metadata. HTTP/1.0, as defined by [RFC1945], added a range of request methods and MIME-like messaging, allowing for metadata to be transferred and modifiers placed on the request/response semantics. However, HTTP/1.0 did not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or name-based virtual hosts. The proliferation of incompletely implemented applications calling themselves "HTTP/1.0" further necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities.
</p>

<div class="p">

<p>
`~HTTP11$は、次により，~HTTP10との互換性が保たれている：
◎
HTTP/1.1 remains compatible with HTTP/1.0 by＼
</p>

<ul>
	<li>
依拠-可能な実装を可能化する，より厳格な要件を含めている。
◎
including more stringent requirements that enable reliable implementations,＼
</li>
	<li>
追加された特能は、［
~HTTP10受信者からは安全に無視されるもの
］, あるいは［［
~HTTP11への適合性を広告する主体
］と通信するときにのみ送信されるもの
］に限られている。
◎
adding only those features that can either be safely ignored by an HTTP/1.0 recipient or only be sent when communicating with a party advertising conformance with HTTP/1.1.
</li>
</ul>

</div>

<div class="p">

<p>
~HTTP11は、以前の~versionを~supportし易くなるように，設計された。
一般用`~HTTP11$`~server$は、次ができる~OUGHT：
◎
HTTP/1.1 has been designed to make supporting previous versions easy. A general-purpose HTTP/1.1 server ought to be able to＼
</p>

<ul>
	<li>
~HTTP10の形式による，妥当な要請も解する。
◎
understand any valid request in the format of HTTP/1.0,＼
</li>
	<li>
［
~HTTP10~clientにより解される（または安全に無視される）特能
］のみを利用する~HTTP11~messageに対し，適切に応答する。
◎
responding appropriately with an HTTP/1.1 message that only uses features understood (or safely ignored) by HTTP/1.0 clients.＼
</li>
</ul>

<p>
同様に、［
~HTTP11~clientは，妥当な~HTTP10応答を解する
］ものと予期できる。
◎
Likewise, an HTTP/1.1 client can be expected to understand any valid HTTP/1.0 response.
</p>
</div>

<p>
~HTTP09は，要請~内の~headerを~supportしなかったので、［
名前~based仮想~host（ `Host$h ~headerの検分による`資源$の選定）
］を~supportするための仕組みも無かった。
［
名前~based仮想~host
］を実装する どの`~server$も，~HTTP09の~supportを不能化する~OUGHT。
事実、［
~HTTP09として出現するほとんどの要請
］は，［
`request-target$p を適正に符号化できない~client
］により，［
不良に構築された~HTTP1x要請
］である。
◎
Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field). Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.
</p>

		<section id="appendix-A.1">
<h3 title="A.1. Changes from HTTP/1.0">A.1. ~HTTP10からの変更点</h3>

<p>
この節では、［
~HTTP10, ~HTTP11
］`~version$間の~~主要な相違点を要約する。
◎
This section summarizes major differences between versions HTTP/1.0 and HTTP/1.1.
</p>

			<section id="appendix-A.1.1">
<h4 title="A.1.1. Multihomed Web Servers">A.1.1. ~multihomed~web~server</h4>

<div class="p">

<p>
次に挙げる要件は、~HTTP11により定義された中でも最も重要な変更点である：
</p>

<ul>
	<li>
`~client$／`~server$は、 `Host$h ~headerを~supportし，~HTTP11要請に それが欠けているときは~errorを報告する。
</li>
	<li>
絶対~URI （ `absolute-URI$p ）を受容する（ `5.3$sec ）。
</li>
</ul>

◎
The requirements that clients and servers support the Host header field (Section 5.4), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 5.3) are among the most important changes defined by HTTP/1.1.
</div>

<p>
古い~HTTP10~clientは、［
~IP~addressと~serverとの関係性が一対一である
］ものと見做していた
— ［
要請に意図された~server
］を判別するために確立された仕組みは、［
要請により~directされる~IP~address
］の他になかった。
`Host$h ~headerは、~HTTP11の開発中に導入され，ほとんどの~HTTP10~browserに すぐに実装されたが、完全な採用を確保するため，すべての~HTTP11要請に 追加的な要件が設置された。
これが書かれた時点では、ほとんどの~HTTP~based~serviceが、
`Host$h ~headerに依存して，要請を~targetしている。
◎
Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism for distinguishing the intended server of a request than the IP address to which that request was directed. The Host header field was introduced during the development of HTTP/1.1 and, though it was quickly implemented by most HTTP/1.0 browsers, additional requirements were placed on all HTTP/1.1 requests in order to ensure complete adoption. At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests.
</p>

			</section>
			<section id="appendix-A.1.2">
<h4 title="A.1.2. Keep-Alive Connections">A.1.2. `Keep-Alive^h 接続</h4>

<p>
~HTTP10における各~接続は、要請に先立って~clientにより確立され，
`~server$により応答が送信された後に~closeされていた。
しかしながら，一部の実装は、`持続的な接続$の［
`2068-19.7.1$rfcによる，明示的に折衝される~version（ `Keep-Alive$h ）
］を実装している。
◎
In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. However, some implementations implement the explicitly negotiated ("Keep-Alive") version of persistent connections described in Section 19.7.1 of [RFC2068].
</p>

<p>
一部の`~client$／`~server$は、［
これらの以前の~approachが，`持続的な接続$と互換になる
］ことを望むかもしれない
— それらに対し、［
"`Connection: keep-alive^c" 要請~headerにより，明示的に折衝する
］ことにより。
しかしながら、~HTTP10持続的な接続の試験的~実装には，~~誤りのあるものもある
— 例えば，~HTTP10~proxy~serverが `Connection$h を解さない場合、その~headerを次の`内方$~serverへ誤って回送することになる結果，接続を~hungさせることになるだろう。
◎
Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a "Connection: keep-alive" request header field. However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.
</p>

<p>
解決策の一つとして、［
特に~proxyへ~targetする，
`Proxy-Connection^h ~header
］の導入も試みられた。
実施においては、これも機能しなかった。
何故なら，~proxyは、複数~層にて配備されていることが多く，上に論じたのと同じ問題を持ち込むので。
◎
One attempted solution was the introduction of a Proxy-Connection header field, targeted specifically at proxies. In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above.
</p>

<p>
そのため、`~client$には，どの要請にも
`Proxy-Connection^h ~header
を送信しないことが奨励される。
◎
As a result, clients are encouraged not to send the Proxy-Connection header field in any requests.
</p>

<p>
`~client$には、要請における
<code>`Connection$p: keep-alive</code>
の利用にあたり，注意深く考慮することも奨励される
— それは，~HTTP10~serverとの持続的な接続を可能化できるが、それを利用する~clientは， “~hung” した要請（それは，［
~clientが~headerの送信を停止する~OUGHT
］ことを指示する）について接続を監視する必要が~~生じる
— したがって、~proxyを利用~中の~clientは，この仕組みを全く利用しない~OUGHT。
◎
Clients are also encouraged to consider the use of Connection: keep-alive in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for "hung" requests (which indicate that the client ought stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.
</p>

			</section>
			<section id="appendix-A.1.3">
<h4 title="A.1.3. Introduction of Transfer-Encoding">A.1.3. `Transfer-Encoding^h の導入</h4>

<p>
~HTTP11は、 `転送~符号法$用に `Transfer-Encoding$h ~headerを導入する。
それは、［
~MIME準拠の~protocol越しに~HTTP~messageを回送する
］に先立って復号される必要がある。
◎
HTTP/1.1 introduces the Transfer-Encoding header field (Section 3.3.1). Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.
</p>

			</section>
		</section>
		<section id="appendix-A.2">
<h3 title="A.2. Changes from RFC 2616">A.2. RFC 2616 からの変更点</h3>

<ul>
	<li>
~HTTPによる~error取扱いの~approachが説明された。
（`2.5$sec）
◎
HTTP's approach to error handling has been explained. (Section 2.5)
</li>
	<li>
`HTTP-version$p ~ABNF生成規則は、文字大小区別であると明確化された。
加えて、`~version番号$は， 1 桁に制約された
—
いくつもの実装が，複数~桁による~version番号を不正に取扱う事実が既知なので。
（`2.6$sec）
◎
The HTTP-version ABNF production has been clarified to be case-sensitive. Additionally, version numbers have been restricted to single digits, due to the fact that implementations are known to handle multi-digit version numbers incorrectly. (Section 2.6)
</li>
	<li>
`userinfo$p （すなわち， `username^p と `password^p ）は、~HTTP／~HTTPS ~URIには許容されなくされた
—
伝送路~上のそれらの伝送に関係する ~securityの課題があるので。
（`2.7.1$sec）
◎
Userinfo (i.e., username and password) are now disallowed in HTTP and HTTPS URIs, because of security issues related to their transmission on the wire. (Section 2.7.1)
</li>
	<li>
~HTTPS~URI~schemeは、今や，この仕様により定義される
— 以前には， `2818-2.4$rfc にて定義されていた。
更には、`端点間$の~securityも含意する（`2.7.2$sec）。
◎
The HTTPS URI scheme is now defined by this specification; previously, it was done in Section 2.4 of [RFC2818]. Furthermore, it implies end-to-end security. (Section 2.7.2)
</li>
	<li>
~HTTP~messageは、実装により~bufferし得る／されることも多く，~streamとして可用にされることもあるが、
~HTTPは，根本的に~message指向な~protocolである。
相互運用能を向上するため、様々な~protocol要素に対し，~supportされる最小~sizeが示唆されている。
（`3$sec）
◎
HTTP messages can be (and often are) buffered by implementations; despite it sometimes being available as a stream, HTTP is fundamentally a message-oriented protocol. Minimum supported sizes for various protocol elements have been suggested, to improve interoperability. (Section 3)
</li>
	<li>
［
`field-name$p の前後の妥当でない空白
］は、今や，却下されることが要求される。
それを受容することは、~securityの脆弱性を表現するので。
`~header$を定義している ~ABNF生成規則は、今や，`~header値$を~listするのみである。
（`3.2$sec）
◎
Invalid whitespace around field-names is now required to be rejected, because accepting it represents a security vulnerability. The ABNF productions defining header fields now only list the field value. (Section 3.2)
</li>
	<li>
［
ある種の文法~生成規則の合間の暗黙的な空白列
］についての規則は、除去された
— 今や，`空白$は、~ABNF内で特に定義されている所でのみ許容される。
（`3.2.3$sec）
◎
Rules about implicit linear whitespace between certain grammar productions have been removed; now whitespace is only allowed where specifically defined in the ABNF. (Section 3.2.3)
</li>
	<li>
複数~行lに~~渡る（“行l折返し”）~headerは、非推奨にされた。
（`3.2.4$sec）
◎
Header fields that span multiple lines ("line folding") are deprecated. (Section 3.2.4)
</li>
	<li>
<p>
［
`comment$p ／ `quoted-string$p
］~text内では、 `NUL^P ~octetは最早~許容されず，~backslash~escapeの取扱いが明確化された。
`HTAB$P 以外の制御~文字の~escapingに対する `quoted-pair$p 規則は、最早~許容されない。
［
~header†／`事由~句$
］内の非~US-ASCII内容は、廃用にされ，不透明にされた（ `TEXT^t 規則は除去された）。
（`3.2.6$sec）
</p>

<p class="trans-note">【†
`4779$errataによる~~修正あり（ Held for Document Update: 2016-10-07 ）：
“~header” → “~header値”
】</p>

◎
The NUL octet is no longer allowed in comment and quoted-string text, and handling of backslash-escaping in them has been clarified. The quoted-pair rule no longer allows escaping control characters other than HTAB. Non-US-ASCII content in header fields and the reason phrase has been obsoleted and made opaque (the TEXT rule was removed). (Section 3.2.6)
</li>
	<li>
［
不法な `Content-Length$h ~header
］は、今や，受信者により，~errorとして取扱われることが要求される。
（`3.3.2$sec）
◎
Bogus Content-Length header fields are now required to be handled as errors by recipients. (Section 3.3.2)
</li>
	<li>
［
`~message本体~長さ$を決定するための~algo
］は、［
それが影響する，すべての特別~事例（例： ~methodや`状態s~code$により駆動されるもの）
］を指示し、［
新たな~protocol要素は，そのような特別~事例を定義できない
］ことが、明確化された。
`CONNECT$m は、~message本体~長さを決定する際の，新たな特別~事例になる。
"`multipart/byteranges^c"
は、最早，~message本体~長さを決定する検出-法にならない。
（`3.3.3$sec）
◎
The algorithm for determining the message body length has been clarified to indicate all of the special cases (e.g., driven by methods or status codes) that affect it, and that new protocol elements cannot define such special cases. CONNECT is a new, special case in determining message body length. "multipart/byteranges" is no longer a way of determining message body length detection. (Section 3.3.3)
</li>
	<li>
"`identity^c" `転送~符号法$ ~tokenは、除去された。
（`3.3$sec, `4$sec）
◎
The "identity" transfer coding token has been removed. (Sections 3.3 and 4)
</li>
	<li>
~chunk長さは、［
~chunk~headerと`~trailer節$
］内の~octet数を含まない。
`~chunk拡張$における行l折返しは、許容されない。
（`4.1$sec）
◎
Chunk length does not include the count of the octets in the chunk header and trailer. Line folding in chunk extensions is disallowed. (Section 4.1)
</li>
	<li>
"`deflate$c" 内容~符号法の意味が，明確化された。
（`4.2.2$sec）
◎
The meaning of the "deflate" content coding has been clarified. (Section 4.2.2)
</li>
	<li>
`request-target$p を定義するためとして，
RFC 1808 による `abs_path^c に代わって，
RFC 3986 の `segment$p ＆ `query$p 成分が利用された。
`asterisk-form$p による `request-target$p は，
`OPTIONS$m ~methodでのみ許容される。
（`5.3$sec）
◎
The segment + query components of RFC 3986 have been used to define the request-target, instead of abs_path from RFC 1808. The asterisk-form of the request-target is only allowed with the OPTIONS method. (Section 5.3)
</li>
	<li>
用語 “`実効~要請~URI$” が導入された。
（`5.5$sec）
◎
The term "Effective Request URI" has been introduced. (Section 5.5)
</li>
	<li>
`~gateway$は、もう `Via$h ~headerを`生成する$必要はなくなった。
（`5.7.1$sec）
◎
Gateways do not need to generate Via header fields anymore. (Section 5.7.1)
</li>
	<li>
正確にいつ，`~close_接続~option$を送信する必要があるのかが、明確化された。
また、 `Connection$h ~header内には，`隣点間~header$のみが出現することが要求される
— この仕様にて`隣点間~header$として定義されたからといって，それが免除される
【それらの~header名を `Connection^h ~header内では省略できる】
わけではない。
（`6.1$sec）
◎
Exactly when "close" connection options have to be sent has been clarified. Also, "hop-by-hop" header fields are required to appear in the Connection header field; just because they're defined as hop-by-hop in this specification doesn't exempt them. (Section 6.1)
</li>
	<li>
接続~数を`~server$あたり 2 個までにしていた制限は、除去された。
`冪等$な一連の要請を再試行することは、最早，要求されない。
~serverが尚早に接続を~closeするような ある種の状況下で，要請を再試行する要件は、除去された。
また、［
~serverが接続を尚早に~closeすることが，いつ許容されるか
］についての，一部の~~余計な要件は、除去された。
（`6.3$sec）
◎
The limit of two connections per server has been removed. An idempotent sequence of requests is no longer required to be retried. The requirement to retry requests under certain circumstances when the server prematurely closes the connection has been removed. Also, some extraneous requirements about when servers are allowed to close connections prematurely have been removed. (Section 6.3)
</li>
	<li>
`Upgrade$h ~headerの意味論は、今や，どの応答にも
— `101$st でない応答にも —
定義される（これは `2817$R を組入れている）。
更には、`~header値$の順序は，今や有意である。
（`6.7$sec）
◎
The semantics of the Upgrade header field is now defined in responses other than 101 (this was incorporated from [RFC2817]). Furthermore, the ordering in the field value is now significant. (Section 6.7)
</li>
	<li>
~list生成規則~内の空~list要素（例： "`, ,^c" を包含している~list~header）は、非推奨にされた。
（`7$sec）
◎
Empty list elements in list productions (e.g., a list header field containing ", ,") have been deprecated. (Section 7)
</li>
	<li>
`転送~符号法$の登録は、今や，`~IETFによる考査$を要する。
（`8.4$sec）
◎
Registration of Transfer Codings now requires IETF Review (Section 8.4)
</li>
	<li>
以前に `2817-7.2$rfc にて定義されていた
Upgrade Token Registry
は、今や，この仕様が定義する。
（`8.6$sec）
◎
This specification now defines the Upgrade Token Registry, previously defined in Section 7.2 of [RFC2817]. (Section 8.6)
</li>
	<li>
~HTTP09要請を~supportする期待は除去された。
（ `付録 A＠#appendix-A$ ）
◎
The expectation to support HTTP/0.9 requests has been removed. (Appendix A)
</li>
	<li>
要請における
`Keep-Alive$h および `Proxy-Connection^h
~headerについての課題, および，後者は全く利用しないことが奨励されることを指摘。
（ `付録 A.1.2＠#appendix-A.1.2$ ）
◎
Issues with the Keep-Alive and Proxy-Connection header fields in requests are pointed out, with use of the latter being discouraged altogether. (Appendix A.1.2)
</li>
</ul>

		</section>
	</section>
	<section id="appendix-B">
<h2 title="Appendix B. Collected ABNF" data-cycling=".bnf">付録 B. 総集的~ABNF</h2>

<p class="trans-note">【
この節の内容は、
`総集的~ABNF＠~723Xabnf#abnf-7230$
に移譲。
】</p>

	</section>
</main></div>
