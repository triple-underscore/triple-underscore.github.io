<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Preload （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
//		original_url: 'https://w3c.github.io/preload/',
		original_url: 'https://www.w3.org/TR/preload/',
		spec_status: 'WD',
		ref_data: '.ref_data',
		ref_id_prefix: 'bib-', //＊
//		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 170718 spec

	return options;
}

function expand(mapping1){

	var class_map = {
		l: 'literal',
		E: 'error',
		e: 'element',
		a: 'attr',
		h: 'header',
		at: 'css',
		css: 'css',
		dir: 'directive',
		et: 'event-type',
		v: 'value',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		e: 'code',
		a: 'code',
		c: 'code',
		et: 'code',
		h: 'code',
		E: 'code',
		l: 'code',
		at: 'code',
		css: 'code',
		dir: 'code',
		v: 'code',
		M: 'code',
		st: 'span',
		i: 'i',
	};

	var link_map = this.link_map;

	E('MAIN').innerHTML = Util.generateSource(this, mapping1, function(source){
		return source.replace(
			/%[\w~一-鿆]+|`(.+?)([$@!\^])(\w*)/g,
			create_html
		);
	});
	return;

	function create_html(match, key, indicator, klass){


if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"'
	break;
case 'at': 
	text = '@' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>



<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
</script>

<!--%links -->
<script type="text/plain" id="_link_map">

I.XMLHttpRequest:~XHR#xmlhttprequest
I.SharedWorker:~WORKERS#sharedworker
I.Worker:~WORKERS#worker
m.fetch():~FETCH#dom-global-fetch
m.importScripts():~WORKERS#dom-workerglobalscope-importscripts
m.as:~HEmetadata#dom-link-as
	m.href:~HEmetadata#dom-link-href
	m.rel:~HEmetadata#dom-link-rel

e.link:~HEmetadata#the-link-element
e.audio:~HEmedia#the-audio-element
e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.image:~SVG11/struct.html#ImageElement
e.img:~HEimages#the-img-element
e.object:~HEembed#the-object-element
e.head:~HEmetadata#the-head-element
e.picture:~HEimages#the-picture-element
e.script:~HEscripting#the-script-element
e.track:~HEmedia#the-track-element
e.video:~HEmedia#the-video-element
e.frame:~HTMLobs#frame

h.Accept:~RFC7231#section-5.3.2
h.Link:http://tools.ietf.org/html/rfc5988

a.href:~HEmetadata#attr-link-href
a.crossorigin:~HEmetadata#attr-link-crossorigin
	a.crossorigin:~HEscripting#attr-script-crossorigin
a.as:~HEmetadata#attr-link-as
a.async:~HEscripting#attr-script-async
a.defer:~HEscripting#attr-script-defer
a.media:~HEmetadata#attr-link-media
	a.imageset＊？
	a.srcset:~HEimages#attr-source-srcset
a.srcset:~HEimages#attr-img-srcset
a.type:#attr-link-type

v.prefetch:~RESOURCE-HINTS#dfn-prefetch
v.preload:#dfn-preload

dir.preload:#_directive-preload
dir.connect-src:~CSP3#connect-src
dir.no-cache:~RFC7234#section-5.2.2.2
	nopush

at.font-face:~CSSFONTS#at-ruledef-font-face
at.import:~CASCADE#at-ruledef-import

~preload~link:#dfn-preload-link
適切な時機:#dfn-appropriate-times
~preload資源が得られた:#dfn-preload-resource-has-been-obtained

	権限を有する:https://httpwg.github.io/specs/rfc7540.html#authority
	権限を有する:~RFC7230#section-9.1
~load~eventを遅延-:~HTMLparsing#delay-the-load-event

環境に合致-:~HTMLcms#matches-the-environment
妥当な媒体~query~list:~HTMLcms#valid-media-query-list

外部~資源~link:~HTMLlinks#external-resource-link

文書の中へ挿入され:~HTMLINFRA#insert-an-element-into-a-document

資源を得る:~HEmetadata#concept-link-obtain

生成元:~ORIGIN#concept-origin

文書:~DOM4#concept-document
文書~木~内:~DOM4#in-a-document-tree
~node文書:~DOM4#concept-node-document

構文解析できる~MIME型:~MIMESNIFF#parsable-mime-type
~supportされない~MIME型:~MIMESNIFF#supported-by-the-user-agent

要請の行先:~FETCH#concept-request-destination
</script>

<!--%置換語 -->

<script type="text/plain" id="words_table1">
RESOURCE-HINTS:resource-hints-ja.html
CSP2:CSP-ja.html
</script>

<!--%語彙 -->
<script type="text/plain" id="words_table">

link::::リンク
script::::スクリプト
font::::フォント
外部:external:~
媒体:media::~::メディア
query::::クエリ
資源:resource::~:リソース
必須の:critical::~
具現化-:render::~
具現化:rendering::~
可用:available:~
可用性:availability:~
頁:page:::ページ
内容:content::~

	●最適化／処理
load:
preload:
signal:
schedule::::スケジュール
投機的:speculative::~
最適化-:optimize::~
最適化:optimization::~
処理-:process::~
	処理-中の:in-process
処理:processing::~
先取的:pre-emptive:先取り的
処理能:performance::~
処理能上の:performance::~
	処理能が~~重要な:performant
先送り:defer::~
遅延:latency::~
遅延-:delay::~
優先度:priority::~
優先度付け:prioritization::~
中止-:abort:~
作成-:create:~
実行-:execute:~
読込み:loading::読み込み
	~~起動-:dispatch::~
	事前に:ahead of time
策:strategy::~
排せる:eliminate できる:~
可視:visible::~
情報:information:~
	見えなくなる:hide
被る:incur する:~
被らな:incur しな:~
往来:roundtrip::~
予見-:believe:~
早期の:earlier:~
早期:early:~
	早くに:as early as
阻む:block する::~::ブロックする
阻んで:block して::~::ブロックして
阻まれ:block され::~::ブロックされ
阻まな:block しな::~::ブロックしな
	具現化を阻まない:non-render-blocking
実行:execution:~
分離-:separate:~
	切り離す:decouple
	ひとまとめに:couple
commit:
関係-:relate:~
関係:relation::~
順序:order:~
順序付け:ordering:~
宣言-:declare::~
宣言:declaration::~
宣言的:declarative::~
指令:directive:~
重複:duplicate:~
二重:double:~
即時:immediate:~
時機:time:~
不能化-:disable:~
可能化-:enable:~
	可能になる／できるようにする:enable

		●network／保安
HTTP:
URL:
MIME:
CDN:
proxy::::プロキシ
IANA:
navi:navigation:::ナビ
client::::クライアント
server::::サーバ
site::::サイト
cache::::キャッシュ
download::::ダウンロード
payload::::ペイロード
fetch::::
fetching::::fetch 処理
header::::ヘッダ
	header:header field
push:
要請:request::~::リクエスト
応答:response::~::レスポンス
応答-:respond::~::レスポンド
起動-:initiate::~
送達-:deliver::~
発行-:make::~
生成-:generate::~
生成:generation::~
生成元:origin::~::オリジン
内容型:content-type::~
折衝-:negotiate::~
接続:connection::~
確立-:establish::~
行先:destination::~
再検証:revalidation:~
送信-:send:~
起動元:initiator::~
種別:type::~


CSP:
CORS:
policy::::ポリシー
security::::セキュリティ
privacy::::プライバシー
複雑化:complications:~
予防策:precautions:~
施行-:enforce::~
権限:authority:~
	権限を有する:authoritative

	●仕様
API:
UA:user agent:UA
model::::モデル
pattern::::パタン
logic::::ロジック
custom::::カスタム
事例:case:~
仕様:spec:~
	例:example:~
特有の:specific な:~
特色機能:feature:~
自動的:automatic:~
自動化-:automate:~
任意選択:option:~
任意選択の:optional:~
	任意選択で外す:opt-out
関連する:relevant な:~
低次:low-level::~
依存関係:dependency:~
便益:benefit:~
候補:candidate:~
実施:practice:~
意味論:semantics:~
意味論的:semantical:~
正しい:correct な:~
有意:significant:~
概念的:conceptual:~
機能性:functionality:~
特定0の:particular:ある特定の
運用上の:operational:~
相互運用性:interoperability:~
詳細な:detailed:~
論点:discussion:~
適正:proper:~
判定基準:criteria:~
問題:problem:~
効果:effect:~
実質的:effective:~
	:in effect
妥当:valid:~
義務的:mandatory:~
視点:perspective:~
重い:serious な:~
将来:future:~
	将来まで耐え得る:future-proof
代償:penalty:~
非依存:agnostic:~
不安定:brittle:~
今日:today:~
実践的な:hands-on:~
木目細かな:fine-grained:~
利用事例:use case::~::ユースケース
能力:capability:~
	能力を備える:capable
	欠落している:missing:
	満たされ:met
	なり:becomes
	に則って:accordingly
	満たされ:met
	いつ, どう:when and how
	どこで, どう:how and where
	不必要な:unnecessary
	必要:need
	必要とされ:necessary
	加えて:additionally
	加えて:in addition to
	それにより:thus
	しかしながら，:however
	べき:should
	因り／ため:due
	含-:include
	可能:possible
	果たせない:not possible to deliver
	利する:on behalf of
	必要がある:must
	べき:ought
	上に、:worse

		●仕様（動詞
subject::対象
app:application:::アプリ
browser::::ブラウザ
support::::サポート
	~supportされない:unsupported
依拠-:rely:~
保証-:guarantee:~
保証:guarantee:~
利用-:use:~
制御:control:~
制限-:limit:~
取組む:address する:取り組む
定義-:define:~
実装-:implement:~
実装:implementation:~
抑制-:reduce:~
拘束:constraints:~
拡張:extension:~
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
提供-:provide:~
改善-:improve:~
既定の:default::~::デフォルト
手段:means:~
文脈:context:~
条件:condition:~
条件付き:conditional:~
最小化-:minimize:~
無視-:ignore:~
欲され:desire され:~
求めら:want さ:~
概して:typical に:~
決める:decide する:~
確保-:ensure:~
競合-:conflict:~
競合:contention::~
考慮点:considerations:~
要件:requirements:~
要求-:require:~
	見よ:see:~
観測-:observe:~
許容-:allow:~
遂行-:perform:~
達成-:achieve:~
適切:appropriate:~
適合性:conformance:~
適用-:apply:~
適用:application:~
避ける:avoid する:~
開発者:developer:~
影響-:affect:~
意味-:mean:~
意図-:intend:~
懸念:concern:~
推定-:infer:~
管理:management:~
考慮-:consider:~
奨励-:encourage:~
	例示-:illustrate
	もたらす:introduce:~
	序論:introduction:~
	謝辞:acknowledgment

		●未分類（動詞
変更-:change:~
省略-:omit:~
	結果:result:~
設定-:set:~
設定群:settings:~
除去-:remove:~
追加-:add:~
追加の:additional:~
構文解析器:parser::~::パーサ
構文解析-:parse::~::パース
浅く:shallow に::~
混在して:mix され:~
	偽造する:creating a fake
所与の:given:与えられた
初期:initial:~
初期化-:initialize:~
包含-:contain:~
参照-:reference::~
参照:reference::~
登録-:register::~
合致-:match::~
照合:matching::~
既存の:existing:~
未知の:unknown:~
検出-:detect:~
	detection
検査:check::~::チェック
検索取得-:retrieve::~
検証0-:verify::検証
注入-:inject::~
消費-:consume::~
消費者:consumer::~
築く:build する::~
築ける:build できる::~
結付けら:associate さ:結び付けら

相違-:differ:~
相違:difference:~
移動-:move:~
挿入-:insert:~
	含-:include
	対応-:correspond
	得-:obtain
	始-:begin
	置く:place する
	やりとり:communicate
	保ち続けられ:retain
	flush

		●未分類
DOM:
JS:JavaScript
CSS:
SVG:
HTML:
IDL:
call:
callback:
live:
prop:property:::プロパティ
event::::イベント
listen::::リッスン
level::::レベル
list::::リスト
markup::::マークアップ
memory::::メモリ
node::::ノード
primitive::::
target::::
stylesheet::::スタイルシート
keyword::::キーワード
main::::メイン
group::::グループ
tag::::タグ
木:tree::~::ツリー
環境:environment:~
等価:equivalent:~
	類似的:similar:~
値:value:~
名:name:~
記述:description:~
属性:attribute::~
文書:document::~
要素:element::~
型:type::~
文字列:string:~
状態:state::~
画像:image:~
空:empty:~
規則:rule:~
存続期間:lifetime:~
	~~指示する:refer
	Fetch

		●指示語
全部的:full:~
現在の:current:~
	現在:currently:~
過去の:past:~
	個の:one／four
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それらの:those
	それらの:their
	それらを:them
	他の場合:otherwise
	恣意的な:arbitrary
	別の:another
	間:between
	上:above
	両者:both
	介:via
	他の:other
	前:before
	後:after
	節:section
	各:each
	同じ:same
	多い:often
	最後に:finally
	多くの:many
	等々:etc
	等々:and so on
	〜に基づく:based
	後続の:subsequent:~
	更に:further
	こともある:sometimes
	中へ:into
	何らかの:some
	であろう:might
	と見られる:may
	一方で:while 
	あるいは:alternatively
	全く:outright
	の様な:like
	一方で:whereas
	ほとんどの／たいていの:most
	-:no longer
	高い:high
	低:low-
	高:high-
	後の:later
	後に:later time
	以前に／まだ:previously
	-:previous
	に加え、:as well as
	多量の:abundance
	re-
	少なくとも:at least
	-:across

</script>

<!--% style -->
<style>
#_preload-directive-example > tr > td:first-child {
	white-space: pre-line;
}
#_preload-directive-example > tr {
	border-top: solid thin silver;
}

</style>

</head>

<body>

<div style="display:none;">
<input type="hidden" id="_page_config" value="" />
</div>


<aside class="trans-meta">
<h1>Preload 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong>作業草案</strong>として公開された
<a id="_SPEC_URL">Preload</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2017-09-01</time>
（公開：<time>2017-08-21</time> ）
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>

<header>
<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1>Preload — 事前読み込み</h1>
<h2>2017 年 8 月 30 日付 作業草案</h2>
	</hgroup>

<details><summary>仕様メタデータ</summary>
<script type="text/plain" id="_spec-metadata">
このバージョン
	https://www.w3.org/TR/2017/WD-preload-20170830/

最新発行バージョン
	https://www.w3.org/TR/preload/

最新の編集者草案
	https://w3c.github.io/preload/

以前のバージョン
	https://www.w3.org/TR/2017/WD-preload-20170823/

テスト一式
	https://github.com/w3c/web-platform-tests/tree/master/preload

編集
	<a href="https://www.igvita.com/">Ilya Grigorik</a>, <a href="https://google.com/">Google</a>, <a href="mailto:igrigorik@gmail.com">igrigorik@gmail.com</a>
	<a href="https://blog.yoav.ws/">Yoav Weiss</a>, <a href="https://akamai.com/">Akamai</a>, <a href="mailto:yoav@yoav.ws">yoav@yoav.ws</a>

Participate:
	<a href="https://github.com/w3c/preload/">  GitHub w3c/preload</a>
	<a href="https://github.com/w3c/preload/issues/">  File a bug</a>
	<a href="https://github.com/w3c/preload/commits/gh-pages">  Commit history</a>
</script></details>

<div id="_copyright" data-year="2017">　</div>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">

<p>
この仕様は、 `link$e 要素に利用できる `preload$v ~keywordを定義する。
この~keywordは、［
早期~fetchを起動し，資源の~fetchingを その実行から分離する
］ような，宣言的な~fetch~primitiveを提供する。
◎
This specification defines the preload keyword that may be used with link elements. This keyword provides a declarative fetch primitive that initiates an early fetch and separates fetching from resource execution.
</p>
	</section>
	<section id="sotd">
<p>
この節では、発行時点における…
<!-- 
これは編集者草案の公開の複製です…
-->
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
この文書は
<a href="https://www.w3.org/webperf/">Web Performance</a>
Working Group により作業草案として、
W3C 勧告になることを意図して制作されました。
コメントは、
<a href="mailto:public-web-perf@w3.org?subject=%5Bpreload%5D">public-web-perf@w3.org</a>
宛まで（
<a href="mailto:public-web-perf-request@w3.org?subject=subscribe">subscribe</a>,
<a href="https://lists.w3.org/Archives/Public/public-web-perf/">archives</a>
）
◎
This document was published by the Web Performance Working Group as a Working Draft. This document is intended to become a W3C Recommendation. Comments regarding this document are welcome. Please send them to public-web-perf@w3.org (subscribe, archives) with [preload] at the start of your email's subject. 
</p>

	</section>

<main id="MAIN0">

	<section id="dependencies">
<h2 title="Dependencies">1. 依存関係</h2>

<p class="trans-note">【
この節の内容の和訳は、省略する。
<small>原文のこの節の内容（他の仕様で定義される用語への参照）は、仕様の更新に伴い，本文と乖離しているように見受けられる。</small>
】</p>

	</section>
	<section id="introduction">
<h2 title="Introduction">2. 序論</h2>

<p>
多くの~appは、資源がいつ~fetchされ, 処理され, 文書に適用されるかに関する，木目細かな制御を要求する。
例えば，資源~競合を抑制して初期~loadの処理能を改善するため、~appは，一部の資源の読込みと処理を先送りすることもある。
この挙動は、概して，資源~fetchingを［
~appにより定義される，資源~読込み用の~custom~logic
］の中へ移動することにより達成される
— すなわち，資源~fetchは、特定0の~app条件が満たされたとき［
注入された要素／ `XMLHttpRequest$I
］を介して起動される。
◎
Many applications require fine-grained control over when resources are fetched, processed, and applied to the document. For example, the loading and processing of some resources may be deferred by the application to reduce resource contention and improve performance of the initial load. This behavior is typically achieved by moving resource fetching into custom resource loading logic defined by the application - i.e. resource fetches are initiated via injected elements, or via XMLHttpRequest, when particular application conditions are met.
</p>

<p>
しかしながら，一部の資源に対しては、可能な限り早くに~fetchする必要はあるが，その処理や実行~logicは ~appに特有の要件の~subjectになるような事例もある
— 例えば、依存関係の管理, 条件付き読込み, 順序付け保証, 等々。
現在、処理能上の代償なしには，この挙動を果たせない。
◎
However, there are also cases where some resources need to be fetched as early as possible, but their processing and execution logic is subject to application-specific requirements - e.g. dependency management, conditional loading, ordering guarantees, and so on. Currently, it is not possible to deliver this behavior without a performance penalty.
</p>

<ul>
	<li>
既存の要素のいずれか（例： `img$e, `script$e, `link$e ）を介して資源を宣言した場合，資源の~fetchingと実行はひとまとめにされる。
その一方で，~appには、~fetchはしつつ，資源の実行は何らかの条件が満たされるまで遅延するよう求められることもある。
◎
Declaring a resource via one of the existing elements (e.g. img, script, link) couples resource fetching and execution. Whereas, an application may want to fetch, but delay execution of the resource until some condition is met.
</li>
	<li>
上の挙動を避けるために，資源を `XMLHttpRequest$I を用いて~fetchすることにした場合、資源~宣言は，~UAの~DOMと~preload構文解析器からは見えなくなるので，重い 処理能上の代償を被る。
そのような資源~fetchが~~起動されるのは，関連する~JSが実行されるときに限られ、たいていの頁では それを阻んでいる~scriptが多量にあるため、有意な遅延-がもたらされ，~appの処理能に影響する。
◎
Fetching resources with XMLHttpRequest to avoid above behavior incurs a serious performance penalty by hiding resource declarations from the user agent's DOM and preload parsers. The resource fetches are only dispatched when the relevant JavaScript is executed, which due to abundance of blocking scripts on most pages introduces significant delays and affects application performance.
</li>
</ul>

<p>
`link$e 要素~上の `preload$v ~keywordは、上の利用事例
— 早期~fetchを起動すること, および~fetchingを資源の実行から分離すること —
に取組むような，低次かつ宣言的な~fetch~primitiveを提供する。
そうすることで、~appが
— ［
~UAから資源が見えなくなることで，資源~fetchingが遅延される代償
］を被ることなく —
資源の読込み, 実行それぞれに対する~customな挙動を築けるようにする。
◎
The preload keyword on link elements provides a declarative fetch primitive that addresses the above use case of initiating an early fetch and separating fetching from resource execution. As such, preload keyword serves as a low-level primitive that enables applications to build custom resource loading and execution behaviors without hiding resources from the user agent and incurring delayed resource fetching penalties.
</p>

<p>
`preload$v ~keywordを利用すれば、~appは ，例えば~CSS資源に対する［
早期, 高~優先度, 具現化を阻まない
］~fetchを起動でき、より適切な時機に~CSSを適用できる：
◎
For example, the application can use the preload keyword to initiate early, high-priority, and non-render-blocking fetch of a CSS resource that can then be applied by the application at appropriate time:
</p>

<pre class="example html" title="Using markup">
&lt;!-- <span class="comment">
宣言的な~markupを介して，~stylesheet資源を~preloadする
◎
preload stylesheet resource via declarative markup
</span> --&gt;
&lt;link rel="preload" href="/styles/other.css" as="style"&gt;

&lt;!-- <span class="comment">
または、~JSを介して，~stylesheet資源を~preloadする
◎
or, preload stylesheet resource via JavaScript
</span> --&gt;
&lt;script&gt;
var %資源 = document.createElement("link");
%資源.rel = "preload";
%資源.as = "style";
%資源.href = "styles/other.css";
document.head.appendChild(%資源);
&lt;/script&gt;
</pre>

<pre class="example http" title="Using HTTP Header">
Link: &lt;https://example.com/other/styles.css&gt;; rel=preload; as=style
</pre>

<p>
上に例示したように，資源は［
宣言的な~markup ／
`Link$h ~HTTP~header `RFC5988$r ／
~scheduleされた~JS
］を介して指定できる。
`preload$v をどこで, どう利用できるかについて，より実践的な例は、<a href="#use-cases">利用事例</a>節を見よ。
◎
As above examples illustrate, the resource can be specified via declarative markup, Link HTTP header ([RFC5988]), or scheduled via JavaScript. See use cases section for more hands-on examples of how and where preload can be used.
</p>
	</section>
	<section id="link-type-preload">
<h2 title="Link type preload">3. ~link型 `preload^v</h2>

<p>
`preload@v
~keywordは、 `link$e 要素に利用でき，
`~preload~link@
— 資源とその~fetch~propを宣言するために利用される`外部~資源~link$ —
を作成する。
◎
The preload keyword may be used with link elements. This keyword creates an external resource link (preload link) that is used to declare a resource and its fetch properties.
</p>

<p class="note" title="feature detection">注記：
`preload$v ~keywordが早期の~fetchを起動する最適化として利用された場合、特色機能を検出する追加の検査は必要とされない
— ~preloadを~supportする~browserは、無視することなく早期の~fetchを起動して，以前のように資源を~fetchすることになる。
他の場合
— ~appは，資源を~preloadする~fetchに依拠したいと意図する場合 —
この
<a href="https://gist.github.com/igrigorik/a02f2359f3bc50ca7a9c">特色機能を検出する検査</a>
を実行すれば，~supportされているか検証0できる。
◎
If the preload keyword is used as an optimization to initiate earlier fetch then no additional feature detection checks are necessary: browsers that support preload will initiate earlier fetch, and those that do not will ignore it and fetch the resource as previously. Otherwise, if the application intends to rely on preload to fetch the resource, then it can execute a feature detection check to verify that it is supported.
</p>

<p class="note" title="relationship to prefetch">注記：
`prefetch$v , `preload$v
ともに資源と その~fetch~propを宣言するが、~UAが資源がいつ, どう~fetchするかにおいて相違する。
`prefetch$v は、後続の~naviにより利用されるであろう資源のための，低~優先度, 任意選択の~fetchになる。
他方， `preload$v は、現在の~naviに必要とされる資源のための，高~優先度, 義務的な~fetchになる。
開発者は、資源~競合を最小化するか, ~load処理能を最適化するかに則って，それぞれを利用するべきである。
◎
Both prefetch and preload declare a resource and its fetch properties, but differ in how and when the resource is fetched by the user agent: prefetch is an optional and low-priority fetch for a resource that might be used by a subsequent navigation; preload is a mandatory and high-priority fetch for a resource that is necessary for the current navigation. Developers should use each one accordingly to minimize resource contention and optimize load performance.
</p>
		<section id="processing">
<h2 title="Processing">3.1. 処理</h2>

<p>
`資源を得る$
`適切な時機@
は，次に挙げられる：
◎
The appropriate times to obtain the resource are:
</p>

<ul>
	<li>
~UAが `RFC5988$r を~supportしている場合には、`文書$を作成してから，
`Link$h ~headerを介して指定される`~preload~link$を処理するとき。
◎
When the user agent that supports [RFC5988] creates a Document and processes Link headers that contain a preload link.
</li>
	<li>
`~preload~link$を与える `link$e 要素が`文書の中へ挿入され$たとき。
◎
When the preload link's link element is inserted into a document.
</li>
	<li>
`link$e 要素が`文書~木~内$にある下で，要素~上に`~preload~link$が作成されたとき。
◎
When the preload link is created on a link element that is already in a document tree.
</li>
	<li>
<p>
`~preload~link$を与える `link$e 要素が`文書~木~内$にある下で：
◎
↓</p>

		<ul>
			<li>
要素の `href$a 属性が変更されたとき。
◎
When the href attribute of the link element of a preload link that is already in a document tree is changed.
</li>
			<li>
要素の `crossorigin$a 属性が［
設定-／変更-／除去-
］されたとき。
◎
When the crossorigin attribute of the link element of a preload link that is already in a document tree is set, changed, or removed.
</li>
			<li>
要素の `as$a 属性が［
以前に得られた外部~資源への`要請の行先$
］に合致しない値に［
設定-／変更-
］されたとき。
◎
When the as attribute of the link element of a preload link that is already in a document tree is set or changed to a value that does not or no longer matches the request destination of the previous obtained external resource, if any.
</li>
			<li>
要素は `as$a 属性を有していて, その値は［
~supportされない`要請の行先$
］を指定していたことに因り，まだ資源を得ていない下で、
`as$a 属性が［
設定-／変更-／除去-
］されたとき。
◎
When the as attribute of the link element of a preload link that is already in a document tree but was previously not obtained due to the as attribute specifying an unsupported request destination is set, removed, or changed.
</li>
			<li>
要素は `type$a 属性を有していて, その値は［
`要請の行先$用として［
`構文解析できる~MIME型$でないもの ／ `~supportされない~MIME型$
］を指定していたことに因り，まだ資源を得ていない下で、
`type$a 属性が［
設定-／変更-／除去-
］されたとき。
◎
When the type attribute of the link element of a preload link that is already in a document tree but was previously not obtained due to the type attribute not specifying a parsable MIME type or specifying an unsupported MIME type for the request destination is set, removed, or changed.
</li>
			<li>
要素は `media$a 属性を有していて, その値は［
`妥当な媒体~query~list$でない ／ `環境に合致-$しない
］ことに因り，まだ資源を得ていない下で、
`media$a 属性が［
設定-／変更-／除去-
］されたとき。
◎
When the media attribute of the link element of a preload link that is already in a document tree but was not previously obtained due the media attribute's value being not a valid media query list or one that does not match the environment is set, removed, or changed.
</li>
		</ul>
	</li>
</ul>

<p>
~UAは、`~preload~link$を与える `link$e 要素の `href$a 属性が［
変更- ／ 除去- ／ 空~文字列に設定-
］されたときは、現在の要請を中止する~SHOULDである。
◎
The user agent SHOULD abort the current request if the href attribute of the link element of a preload link is changed, removed, or its value is set to an empty string.
</p>

<p>
~UAは、上に挙げた時機に， `link$e 要素に与えられた`資源を得る$ことが要求される。
◎
At these times, the user agent must obtain the resource given by the link element.
</p>

<p>
`~preload~link$要素に与えられた資源を得るときでも、それにより，要素の`~node文書$の`~load~eventを遅延-$しては~MUST_NOT。
◎
Obtaining the resource given by a preload link element MUST NOT delay the load event of the element's node document.
</p>

<p>
`~preload資源が得られた@
なら、~UAは~fetch~group
【<a href="~FETCH#concept-fetch-group" >~fetch~group</a>？】
の応答~cacheに要請を追加する必要がある。
◎
Once a preload resource has been obtained, the user agent must add request to fetch group's response cache.
</p>


<div class="note">
<p>注記：
すべての~browser実装は、~HTTP~cacheに加えて，何~levelかの追加の~cacheを提供する。
それは、~HTTP~cacheより前に~liveになることもあれば（例：
~HTTP/2 ~serverにより~pushされる応答は、概して，~client要請が発行されるまで ~HTTP~cacheには~commitされない）、~HTTP~cacheより後に~liveになることもある（例： 処理-中の~memory~cache）。
今日では、これらの~cacheは定義されておらず， Fetch ~APIにて定義される必要がある（
<a href="https://github.com/whatwg/fetch/issues/354">関係する論点</a>
を見よ）。
◎
In addition to the HTTP cache, all browser implementations provide one or more levels of additional caches, which sometimes live before the HTTP cache (e.g. HTTP/2 server push responses are typically not committed to HTTP cache until a client request is made), and after the HTTP cache (e.g. in-process memory caches). These caches are not defined today and need to be defined in Fetch API— see related discussion.
</p>

<p>
~preloadされた応答は、概念的には，~HTTP~cacheに~commitされるべきである
— それは、~clientにより起動され，~memory~cache内にも可用になり，少なくとも~fetch~groupの存続期間に~~現れて以降は再~利用できるので。
◎
Conceptually, a preloaded response ought to be committed to the HTTP cache, as it is initiated by the client, and also be available in the memory cache and be re-usable at least once within the lifetime of a fetch group.
</p>

</div>

<p class="note">注記：
`Link$h ~HTTP応答~headerは、どの型の`要請の行先$に対しても，処理されるべきである。
◎
Link HTTP response header should be processed for all types of request destination.
</p>

<p>
~UAは、現在の頁~文脈に対し，資源を自動的に［
実行-／適用-
］しては~MUST_NOT。
◎
The user agent MUST NOT automatically execute or apply the resource against the current page context.
</p>

<p class="note">注記：
例えば，~JS資源が`~preload~link$を介して~fetchされ，対する応答が `no-cache$dir 指令を包含する場合、~fetchされた応答は，~UAにより保ち続けられた上で、後に（ 例えば  `script$e ~tagその他の手段を介して）合致する同じ~navi要請で~fetchされたとき，即時に可用にされる。
これにより、［
~preload~linkを介して起動される初期~資源~fetchから，同じ資源を要請している後の~fetchまで
］の間，~UAは［
不必要な再検証 ／ 重複~download
］を被らないことが確保される。
◎
For example, if a JavaScript resource is fetched via a preload link and the response contains a no-cache directive, the fetched response is retained by the user agent and is made immediately available when fetched with a matching same navigation request at a later time - e.g. via a script tag or other means. This ensures that the user agent does not incur an unnecessary revalidation, or a duplicate download, between the initial resource fetch initiated via the preload link and a later fetch requesting the same resource.
</p>
		</section>
		<section id="as-attribute">
<h2 title="as attribute">3.2. `as^a 属性</h2>

<p class="note">注記：
`HTML$r は、 `as$a 内容~属性（および `as$m ~IDL属性）を定義する。
この属性は、次を保証するために必要とされる：
正しい優先度付け,
要請との照合,
正しい `CSP3$r ~policyの適用,
適切な `Accept$h 要請~headerを設定すること。
◎
[HTML] defines the as content and IDL attributes. The attribute is necessary to guarantee correct prioritization, request matching, application of the correct [CSP3] policy, and setting of the appropriate Accept request header. 
</p>

<p>
資源が `Link$h ~header `RFC5988$r を介して宣言されている場合、
`as$a 属性に~~相当するものは、［
`as^c ~link拡張~target属性
］を介して定義される（ `RFC5988$r, 5.4 節）。
◎
When the resource is declared via the Link header field ([RFC5988]), the resource's as attribute is defined via the as link-extension target attribute. ([RFC5988] section 5.4)
</p>

<div class="example">

<p>
資源を~preloadする指令（右列）と，それを消費するもの（左列）の例：
◎
Example directives to preload a resource that will be consumed by...
</p>

<table><thead><tr><th>消費者◎consumer
<th>`preload^v 指令◎Preload directive
</thead><tbody id="_preload-directive-example">

<tr><td>`audio$e 要素
<td>`&lt;link rel=preload as=audio href=...&gt;^c

<tr><td>`video$e 要素
<td>`&lt;link rel=preload as=video href=...&gt;^c

<tr><td>`track$e 要素
<td>`&lt;link rel=preload as=track href=...&gt;^c

<tr><td>`script$e 要素 ／
`Worker$I の `importScripts()$m
<td>`&lt;link rel=preload as=script href=...&gt;^c

<tr><td>`&lt;link rel=stylesheet&gt;^c ／
~CSS `import$at 規則
<td>`&lt;link rel=preload as=style href=...&gt;^c

<tr><td>~CSS `font-face$at 規則
<td>`&lt;link rel=preload as=font href=...&gt;^c

<tr><td>`img$e 要素 ／
`picture$e 要素 ／
`srcset$a 属性 ／
`imageset^c 【？】
<td>`&lt;link rel=preload as=image href=...&gt;^c

<tr><td>~SVG `image$e 要素 ／
各種~CSS `*-image^css
<td>`&lt;link rel=preload as=image href=...&gt;^c

<tr><td>`XMLHttpRequest$I ／
`fetch()$m
<td>`&lt;link rel=preload as=fetch crossorigin href=...&gt;^c

<tr><td>`Worker$I ／
`SharedWorker$I
<td>`&lt;link rel=preload as=worker href=...&gt;^c

<tr><td>`embed$e 要素
<td>`&lt;link rel=preload as=embed href=...&gt;^c

<tr><td>`object$e 要素
<td>`&lt;link rel=preload as=object href=...&gt;^c

<tr><td>`iframe$e 要素 ／
`frame$e 要素
<td>`&lt;link rel=preload as=document href=...&gt;^c

</tbody></table>

</div>

		</section>
		<section id="server-push-(http/2)">
<h2 title="Server Push (HTTP/2)">3.3. ~server~push（ HTTP/2 ）</h2>

<p>
~HTTP/2 `RFC7540$r においては、~serverは，~clientに向けて応答を先取的に送信すること（ “~push” ）が許容される。
~pushされてきた応答は、意味論的には 次に等価になる：
~serverがある要請に応答し、~UAは
— ~preloadされた応答と同様に —
それを保ち続け、その応答は，~appにより起動された要請に合致したとき ~appにより実行される。
そのようなわけで，~app視点からは、［
~preloadによる応答を消費すること, ~server~pushによる応答を消費すること
］の間に相違はない。
◎
HTTP/2 ([RFC7540]) allows a server to pre-emptively send ("push") responses to the client. A pushed response is semantically equivalent to a server responding to a request and, similar to a preloaded response, is retained by the user agent and executed by the application when matched with a request initiated by the application. As such, from an application perspective, there is no difference between consuming a preload or a server push response.
</p>

<p>
~serverは、~appにより定義された`~preload~link$に対し，それが~serverが
<a href="https://httpwg.github.io/specs/rfc7540.html#authority">権限を有する</a>
資源を指すならば、~server~pushを起動して~MAY。
そのような~server~pushにより、宣言された`~preload~link$資源~用の ~clientから~server向けの要請による往来は，排せるようになる。
［
`Link$h ~header `RFC5988$r を介して宣言された資源に対しては，~server~pushを利用しない
］ことが欲される場合、開発者は 任意選択で，
`nopush^c ~target属性 （ `RFC5988$r 5.4 節）を介して任意選択で外す~signalを~server向けに提供して~MAY。
例えば：
◎
The server MAY initiate server push for preload link resources defined by the application for which it is authoritative. Initiating server push eliminates the request roundtrip between client and server for the declared preload link resource. Optionally, if the use of server push is not desired for a resource declared via the Link header field ([RFC5988]), the developer MAY provide an opt-out signal to the server via the nopush target attribute ([RFC5988] section 5.4). For example:
</p>

<div class="example">

<pre class="http-code">
Link: &lt;/app/style.css&gt;; rel=preload; as=style; nopush
Link: &lt;/app/script.js&gt;; rel=preload; as=script
</pre>

<div class="p">
<p>
この例の各 `Link^h は、 HTTP/2 ~push能力を備えている~serverに，順に次を指示する：
</p>

<ul><li>`/app/style.css^c は、~pushしないべきである（例：生成元は、~cache内にすでにあることを指示する追加の情報を有していると見られる）。
</li><li>`/app/script.js^c は、~server~pushの候補として考慮されるべきである。
</li></ul>
◎
The above example indicates to an HTTP/2 push capable server that /app/style.css should not be pushed (e.g. the origin may have additional information indicating that it may already be in cache), while /app/script.js should be considered as a candidate for server push.
</div>
</div>

<div class="p">
<p>
`~preload~link$用に~server~pushを起動することは、任意選択の最適化である
— 例えば~serverは、次に該当する場合には，そのような~pushを省略するかもしれない：
</p>

<ul>
	<li>
~clientの~cache内に応答は可用であると予見されるとき。
~clientは、当の資源が欠落しているときには，［
`preload^v 指令, 関連する~cacheの検査
］を処理して，~server向け要請を起動することになる。
</li>
	<li>
可用な~server資源その他の判定基準などの運用上の懸念があるとき。
</li>
</ul>

<p>
最後に，~server~pushの利用は、折衝される ~HTTP/2 接続~設定群の~subjectになる：
~clientは、~server~pushの利用を制限したり, 全く不能化することもある。
したがって~appは，~server~pushの可用性／利用には依拠できない。
</p>

◎
Initiating server push for a preload link is an optional optimization. For example, the server might omit initiating push if it believes that the response is available in the client's cache: the client will process the preload directive, check the relevant caches, and initiate the request to the server if the resource is missing. Alternatively, the server might omit initiating push due to operational concerns, such as available server resources or other criteria. Finally, the use of server push is subject to negotiated HTTP/2 connection settings: the client may limit or outright disable the use of server push. Applications cannot rely on the availability and use of server push.
</div>

		</section>
	</section>
	<section id="conformance">
<h2 title="Conformance">6. 適合性</h2>

<p>
この仕様が適合性を課す対象は、~UAのみである。
◎
There is only one class of product that can claim conformance to this specification: a user agent.
</p>

<p class="trans-note">【
この節の他の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="use-cases">
<h2 title="Use cases">A. 利用事例</h2>

~INFORMATIVE

		<section id="early-fetch-of-critical-resources">
<h2 title="Early fetch of critical resources">A.1. 必須の資源の早期~fetch</h2>

<p>
ほとんどの~UAは、~main文書の構文解析器が~scriptに因り阻まれている間に，~preload構文解析器を利用して資源の早期~fetchを起動する。
しかしながら，~preload構文解析器は、~JSは実行せず、概して，~CSSの構文解析-に限り浅く遂行する。
このことは、［
~JSや~CSSの中で指定される資源
］に対する~fetchは、関連する文書の構文解析器が資源~宣言を処理できるようになるまで，遅延されることを意味する。
◎
Preload parsers are used by most user agents to initiate early resource fetches while the main document parser is blocked due to a blocking script. However, the preload parsers do not execute JavaScript, and typically only perform a shallow parse of CSS, which means that the fetch of resources specified within JavaScript and CSS is delayed until the relevant document parser is able to process the resource declaration.
</p>

<p>
~JS／~CSS
の中で指定されるほとんどの資源~宣言は、投機的な構文解析器からは実質的に “見えなくなる” ため，処理能上の代償を被る。
~appは、これに取組むため，［
頁~処理能を改善するために，~UAが早期に~fetchする必要がある資源
］を，`~preload~link$を利用して宣言的に指定できる：
◎
In effect, most resources declarations specified within JavaScript and CSS are "hidden" from the speculative parsers and incur a performance penalty. To address this, the application can use a preload link to declaratively specify which resources the user agent must fetch early to improve page performance:
</p>

<pre class="example html" title="Early fetch of critical resources">
&lt;link rel="preload" href="/assets/font.woff2" as="font" type="font/woff2"&gt;
&lt;link rel="preload" href="/style/other.css" as="style"&gt;
&lt;link rel="preload" href="//example.com/resource" as="fetch" crossorigin&gt;
&lt;link rel="preload" href="https://fonts.example.com/font.woff2" as="font" crossorigin type="font/woff2"&gt;
</pre>

<p>
上の~markupは、 4 個の資源
— ~font資源, ~stylesheet, 別の生成元からの未知の資源~型, 別の生成元からの~font資源 —
それぞれに対し，~fetchを起動する。
各~fetchは、適切な要請~headerと優先度で初期化され、未知の型は `XMLHttpRequest$I による要請で起動される~fetchと等価になる。
更には、これらの要請が構文解析器や `load^et ~eventを阻むことはない。
◎
Above markup initiates four resource fetches: a font resource, a stylesheet, an unknown resource type from another origin, and a font resource from another origin. Each fetch is initialized with appropriate request headers and priority - the unknown type is equivalent to a fetch initiated XMLHttpRequest request. Further, these requests do not block the parser or the load event.
</p>

<p class="note">注記：
`crossorigin$a 属性が伴われた~fontや画像など，~CORSが可能化された資源~用の~preload~linkは、資源が適正に利用されるようにするためには， `crossorigin$a 属性も有している必要がある。
◎
Preload links for CORS enabled resources, such as fonts or images with a crossorigin attribute, must also include a crossorigin attribute, in order for the resource to be properly used.
</p>
		</section>
		<section id="early-fetch-and-application-defined-execution">
<h2 title="Early fetch and application defined execution">A.2. 早期~fetchと~appにより定義される実行</h2>

<p>
~appは、 1 つ以上の資源の早期~fetchを起動する`~preload~link$を利用できることに加え、各~応答がいつ, どう文書に適用されるべきかを与える~custom~logicを提供できる。
~appは次を行える：
◎
The preload link can be used by the application to initiate early fetch of one or more resources, as well as to provide custom logic for when and how each response should be applied to the document. The application may:
</p>

<ul>
	<li>
各~資源を可用になり次第~即時に適用することに決める。
◎
Decide to immediately apply each resource as it becomes available.
</li>
	<li>
各~資源が，~appに特有の何らかの順序で適用されることを確保する。
◎
Ensure that resources are applied in some application specific order.
</li>
	<li>
恣意的な［
資源または~app
］による判定基準に基づいて、資源を条件付きで適用する。
◎
Apply resources conditionally based on arbitrary resource or application criteria.
</li>
	<li>
~appによる条件が満たされるまで，資源の適用を先送りする。
◎
Defer resource application until some application condition is met.
</li>
</ul>

<p>
`~preload~link$は、低次かつ内容型に非依存な~primitiveを提供する。
それは、~appが
— 資源~読込みが遅延される代償を被ることなく —
資源の読込み, 実行それぞれに~customな挙動を築けるようにする。
◎
The preload link provides a low-level and content-type agnostic primitive that enables applications to build custom resource loading and execution behaviors without incurring the penalty of delayed resource loading.
</p>

<p>
例えば`~preload~link$は、~appが［
今日では `script$e 要素にしか可用でない［
`async$a ／ `defer$a
］の様な意味論
］を，どの内容型にも提供することを可能化する：
可用になり次第，即時に資源を適用することは、 `async$a の機能性を提供する。
一方で，何らかの順序付け~logicを追加することは、 `defer$a 機能性を可能化する。
更には，この挙動は、いくつかの内容型が混在していても定義できる
— ~appは、各~資源がいつ, どう適用されるかについて全部的な制御を有する。
◎
For example, preload link enables the application to provide async and defer like semantics, which are only available on script elements today, but for any content-type: applying the resource immediately after it is available provides async functionality, whereas adding some ordering logic enables defer functionality. Further, this behavior can be defined across a mix of content-types - the application is in full control over when and how each resource is applied.
</p>

<pre class="example html">
&lt;script&gt;
  function preloadFinished(e) { ... }
  function preloadError(e)  { ... }
&lt;/script&gt;
&lt;!-- <span class="comment">
`load^et ／ `error^et ~eventを~listenする
◎
listen for load and error events
</span> --&gt;
&lt;link rel="preload" href="app.js" as="script" onload="preloadFinished()" onerror="preloadError()"&gt;
</pre>

<p>
資源の~fetchingを その実行から切り離すことにより、`~preload~link$は，将来まで耐え得るような［
処理能が~~重要な~appが，自身に特有の資源~読込み策を築く
］ための~primitiveを提供する。
◎
By decoupling resource fetching from execution, the preload link provides a future-proof primitive for building performant application specific resource loading strategies.
</p>
		</section>
		<section id="developer,-server,-and-proxy-initiated-fetching">
<h2 title="Developer, server, and proxy-initiated fetching">A.3. 開発者／ ~server／~proxyにより起動される~fetching</h2>

<p>
開発者は、`~preload~link$を指定でき，また
~app~server／最適化~proxy（例えば~CDN）も，自動的に`~preload~link$を生成できる。
◎
The preload link can be specified by the developer, or be automatically generated by the application server or an optimization proxy (e.g. a CDN).
</p>

<pre class="example http">
Link: &lt;https://example.com/font.woff2&gt;; rel=preload; as=font; type="font/woff2"
Link: &lt;https://example.com/app/script.js&gt;; rel=preload; as=script
Link: &lt;https://example.com/logo-hires.jpg&gt;; rel=preload; as=image
Link: &lt;https://fonts.example.com/font.woff2&gt;; rel=preload; as=font; crossorigin; type="font/woff2"
</pre>

<pre class="example html">
&lt;link rel="preload" href="//example.com/widget.html" as="document"&gt;
</pre>

<pre class="example html">
&lt;script&gt;
var %資源 = document.createElement("link");
%資源.rel = "preload";
%資源.as = "document";
%資源.href = "/other/widget.html";
document.head.appendChild(%資源);
&lt;/script&gt;
</pre>


<ul>
	<li>
<p>
~appは、次を許容するような~preload~linkを指定できる：
◎
The application can specify preload links, allowing:
</p>

		<ul>
			<li>
~UAが必須の資源に対する早期~fetchを起動する。
◎
The user agent to initiate early fetch of critical resources.
</li>
			<li>
最適化~proxyが、必須の資源を事前に~fetchして，自身の~cacheの中に置く
— それにより、生成元から資源を検索取得する際の遅延を，抑制する／排する。
◎
The optimization proxy to fetch the critical resources and place them into its cache ahead of time, thus reducing or eliminating the latency of retrieving resources from origin.
</li>
		</ul>
	</li>
	<li>
<p>
最適化~proxyは、~appに利するために~preload~linkを指定できる：
◎
The optimization proxy can specify preload links on behalf of the application:
</p>
		<ul>
			<li>
~proxyは、過去の要請~patternに基づいて 必須の資源を観測-／推定して，関連する~preload~linkの生成を自動化でき、それにより頁~処理能は改善される。
◎
The proxy can observe and infer critical resources based on past request patterns, allowing it to automate generation of relevant preload links to improve page performance.
</li>
			<li>
<p>
~proxyは、生成元からの応答が阻まれている間に，推定した~preload~linkを~UAに送達できる
— ~UAは、結付けらている必須の資源に対し，早期に~fetchし始めることが可能になる。
◎
The proxy can deliver inferred preload links to the user agent while it is blocked on the response from the origin, allowing the user agent to begin early fetch of associated critical resources.
</p>
			<ul>
    			<li>
既存の最適化~proxyの多くは、 “早めに流し込む（ early flush ）” 策を実装する
— そこでは、~proxyが生成元からの応答により阻まれている間，結付けらている必須の資源への参照-が，~UAに自動的に送達される。
今日では、これは概して，結付けらている必須の資源~用の［
`XMLHttpRequest$I, `image^e, `object^e
］要請を包含するような `head$e を文書~内に偽造することにより行われる。
しかしながら，実施においては、これらの実装は不安定で，投機的に起動される要請と, 文書~構文解析器によるそれとで優先度付けが競合することが多い上に、要請の文脈~情報が欠落していることに因る結果，遅延される／二重~downloadになることもある。
`~preload~link$は、宣言的~fetch~primitiveを提供することにより，これらの問題, および
~HTTP `Link$h ~headerとの相互運用性に取組む
— それは~URL, 資源の文脈の両者とやりとりする。
◎
Many existing optimization proxies implement "early flush" strategies where references to associated critical resources are automatically delivered to the user agent while the proxy is blocked on the response from the origin. Today, this is typically done by creating a fake document head that contains XMLHttpRequest, image, and object requests for the associated critical resources. However, in practice, these implementations are brittle and often result in prioritization conflicts with requests initiated by speculative and document parsers, or worse, result in delayed or double downloads due to missing request context information. The preload link addresses these problems by providing a declarative fetch primitive, and interoperability with the HTTP Link header, that communicates both the URL and the context of the resource.
</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">B. ~IANA考慮点</h2>

<p>
以下に挙げる各種~link関係~型は、 `RFC5988$r,  6.2.1 節にしたがって，~IANAにより登録された：
◎
The link relation type below has been registered by IANA per Section 6.2.1 of [RFC5988]:
</p>


<dl>
	<dt>関係~名</dt>
	<dd>`preload@dir</dd>

	<dt>記述</dt>
	<dd>
資源は、~linkの文脈における処理において
— 具現化を阻むことなく —
早期に~loadされるべきであることを~~指示する。
◎
Refers to a resource that should be loaded early in the processing of the link's context, without blocking rendering.
</dd>

	<dt>参照</dt>
	<dd>
この仕様。
◎
W3C Preload Specification (https://www.w3.org/TR/preload/)
</dd>

	<dt>注記</dt>
	<dd>
追加の~target属性は、~linkの詳細な~fetch~propを確立する。
◎
Additional target attributes establish the detailed fetch properties of the link.
</dd>
    </dl>
	</section>
	<section id="privacy">
<h2 title="Privacy and Security">C. ~privacyと~security</h2>

~INFORMATIVE

<p>
~preloadは、
資源の早期~fetchを起動する宣言的な~fetch~primitiveであり、
~fetchingを資源の実行から分離する。
その効果は、概念的には，~scriptによる資源の~fetchを起動するのに類似するが、追加の拘束と便益もある：
◎
Preload is a declarative fetch primitive that initiates early fetch of resources and separates fetching from resource execution. In effect, it is conceptually similar to initiating a scripted fetch for a resource, but with additional constraints and benefits:
</p>


<ul>
	<li>
資源~宣言は、~HTTP~header／~HTML~markupを介して可視になる。
~UAは、~JS実行により阻まれずに，~fetchをより早期に起動できるようになる。
◎
The resource declaration is visible via HTTP headers or HTML markup, which allows the user agent to initiate the fetch earlier, and without blocking on JavaScript execution.
</li>
	<li>
応答は、実行されないし，その~payloadを検索取得するような~callbackはない。
応答は、~preloadされた応答に合致する，別の~fetchを起動することにより検索取得され，実行される（ `script^e ／ ~DOM要素 , 等々を介して）。
◎
The response is not executed and there is no callback to retrieve its payload. The response is retrieved and executed by initiating another fetch (via script, DOM element, etc) that matches the preloaded response.
</li>
	<li>
開発者は、 `as$a 属性を介して，応答を消費することになる~target文脈を指定できる。
~UAは、~preload~fetchを起動するときに、関連する~CSP~policyを施行できるようになる。
`as$a が省略された場合の ~preloadに対する既定の~security／~privacy処理は、
`fetch()$m を~callするときと同じになる
— すなわち、 `connect-src$dir 指令の~subjectになる。
◎
The developer can specify the target context that will consume the response via as attribute, which allows the user agent to enforce the relevant CSP policies when initiating the preload fetch. If as is omitted, preload defaults to same security and privacy processing as a call to fetch() - i.e. subject to connect-src.
</li>
</ul>

<p>
~site作者には、必要とされる予防策をとり、
`CSP3$r, `MIXED-CONTENT$r, `REFERRER-POLICY$r
による関連する各種~policyを指定することが奨励される
— ~browserが~preload要請を起動するときにそれらを施行できるよう。
加えて，
`Link$h ~HTTP応答~headerを介して `preload$dir 指令が提供された場合、関連する~policyも
~HTTP応答~headerとして送達されるべきである
— 例：
~CSPに対しては<a href="~CSP2#complications">処理の複雑化</a>を見よ。
◎
The site authors are encouraged to take the necessary precautions and specify the relevant [CSP3], [MIXED-CONTENT], and [REFERRER-POLICY] rules, such that the browser can enforce them when initiating the preload request. Additionally, if preload directives are provided via the Link HTTP response header, then the relevant policies should also be delivered as an HTTP response header - e.g. see Processing Complications for CSP.
</p>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">D. 謝辞</h2>

~INFORMATIVE

<p lang="en-x-a0">
This document reuses text from the [HTML] specification, edited by Ian Hickson, as permitted by the license of that specification.
</p>

	</section>

</main></div><!-- id="MAIN"／MAIN0 -->

	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative-references">
<h2 title="Normative references">文献（規範）</h2>

<script type="text/plain" class="ref_data">
[CSP3]
    Content Security Policy Level 3. Mike West. W3C. 13 September 2016. W3C Working Draft. URL: https://www.w3.org/TR/CSP3/
[DOM]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[FETCH]
    Fetch Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[HTML52]
    HTML 5.2. Steve Faulkner; Arron Eicholz; Travis Leithead; Alex Danilo; Sangwhan Moon. W3C. 8 August 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/html52/
[MIMESNIFF]
    MIME Sniffing Standard. Gordon P. Hemsley. WHATWG. Living Standard. URL: https://mimesniff.spec.whatwg.org/
[MIXED-CONTENT]
    Mixed Content. Mike West. W3C. 2 August 2016. W3C Candidate Recommendation. URL: https://www.w3.org/TR/mixed-content/
[REFERRER-POLICY]
    Referrer Policy. Jochen Eisinger; Emily Stark. W3C. 26 January 2017. W3C Candidate Recommendation. URL: https://www.w3.org/TR/referrer-policy/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[RFC5988]
    Web Linking. M. Nottingham. IETF. October 2010. Proposed Standard. URL: https://tools.ietf.org/html/rfc5988
[RFC7540]
    Hypertext Transfer Protocol Version 2 (HTTP/2). M. Belshe; R. Peon; M. Thomson, Ed.. IETF. May 2015. Proposed Standard. URL: https://tools.ietf.org/html/rfc7540
</script>

		</section>
		<section id="informative-references">
<h2 title="Informative references">文献（参考）</h2>

<script type="text/plain" class="ref_data">
[RESOURCE-HINTS]
    Resource Hints. Ilya Grigorik. W3C. 4 May 2017. W3C Working Draft. URL: https://www.w3.org/TR/resource-hints/
</script>

		</section>
	</section>
