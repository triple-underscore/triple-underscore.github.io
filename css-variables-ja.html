<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Custom Properties for Cascading Variables Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'P':
	text = `&lt;${key}&gt;`;
	break;
case 'l':
	return `"<code class="literal">${text}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Custom Properties for Cascading Variables Module Level 1
spec_date:2025-02-22
trans_update:2025-02-22
source_checked:240830
page_state_key:CSS
original_url:https://drafts.csswg.org/css-variables-1/
	abbr_url:CSSVAR
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2025,permissive
trans_1st_pub:2012-07-10


●●class_map
p:property
at:at-rule
d:descriptor
f:func
ps:pseudo
css:css
e:element
a:attr
v:value
t:type
P:production
u:unit
U:code-point
cn:cp-name

●●tag_map
p:code
v:code
f:code
at:code
d:code
ps:code
pe:code
t:var
P:code
css:code
e:code
a:code
m:code
I:code
c:code
u:code
U:span
cn:span
em:em

●●original_id_map

cssom-api:cssom

●●original_urls
variable-units:https://drafts.csswg.org/css-variables-2/

●●mdn_urls
propdef-:CSS/--*

funcdef-var:CSS/var()

●●link_map

	●IDL
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration

	＠~CSSOM1#dom-cssstyledeclaration-getpropertyvalue
	＠~CSSOM1#dom-cssstyledeclaration-setproperty
	＠~CSSOM1#dom-cssstyledeclaration-removeproperty

	●css
p.--*:#propdef-
p.all:~CASCADE#propdef-all
p.background:~CSSBG#propdef-background
p.background-color:~CSSBG#propdef-background-color
p.color:~CSSCOLOR#propdef-color
p.font-size:~CSSFONT#propdef-font-size

v.initial:~CASCADE#valdef-all-initial

at.media:~CSSCOND#at-ruledef-media
at.keyframes:~CSSANIM#at-ruledef-keyframes
at.property:~CSSPV1#at-ruledef-property

d.initial-value:~CSSPV1#descdef-property-initial-value

f.var:#funcdef-var
f.calc:~CSSVAL#funcdef-calc

u.em:~CSSVAL#em

ps.root:~SELECTORS4#root-pseudo
ps.lang():~SELECTORS4#lang-pseudo

t.custom-property-name:#typedef-custom-property-name
t.color:~CSSCOLOR#typedef-color
t.declaration-value:~CSSSYN#typedef-declaration-value
t.dashed-ident:~CSSVAL#typedef-dashed-ident

P.bad-string-token:~CSSSYN#typedef-bad-string-token
P.semicolon-token:~CSSSYN#typedef-semicolon-token
P.bad-url-token:~CSSSYN#typedef-bad-url-token
P.delim-token:~CSSSYN#typedef-delim-token
P.)-token:~CSSSYN#tokendef-close-paren
P.]-token:~CSSSYN#tokendef-close-square
P.}-token:~CSSSYN#tokendef-close-curly


	●用語
~custom~prop:#custom-property
~animationに染まって:#animation-tainted
無効が保証される値:#guaranteed-invalid-value
可変~単位~参照:#variable-unit-reference

	●用語（CSS
~importantな宣言:~CASCADE#important
算出d値:~CASCADE#computed-value
継承d値:~CASCADE#inherited-value
初期~値:~CASCADE#initial-value
指定d値:~CASCADE#specified-value
~cascaded値:~CASCADE#cascaded-value
~cascaded値の処理:~CASCADE#value-stages

~CSS全域~keyword:~CSSVAL#css-wide-keywords
~CSS識別子:~CSSVAL#css-css-identifier
次元:~CSSVAL#dimension

算出d値の時点で無効:~CSSVAL5#invalid-at-computed-value-time
任意-代入~関数:~CSSVAL5#arbitrary-substitution-function
任意-代入~関数を解決する:~CSSVAL5#resolve-an-arbitrary-substitution-function
	var() 関数を解決する:#resolve-a-var-function
代入-:~CSSVAL5#substitute-arbitrary-substitution-function
代入:~CSSVAL5#substitute-arbitrary-substitution-function
	＠~CSSVAL5#pending-substitution-value

宣言:~CSSOM1#css-declaration
	宣言~list:~CSSOM1#cssstyledeclaration-declarations
	~CSSSYN#declaration
文字大小区別か:~CSSOM1#css-declaration-case-sensitive-flag

条件付き~group規則:~CSSCOND#conditional-group-rule
	~animation~prop:~CSSANIM#animation
登録-済み~custom~prop:~CSSPV1#registered-custom-property

~animate不可:~WANIM#not-animatable

	pseudo
	https://drafts.csswg.org/selectors/#root-pseudo

	●用語他
~ASCII大小無視:~INFRA#ascii-case-insensitive
一致する:~INFRA#string-is

●●words_table1


●●words_table


	●CSS
cascaded::::カスケード
	~cascadeする:cascading
important:
全域:wide:~
CSSOM:
	下位prop:longhand
	~animate能:animatability
	塊-軸:vertical
任意-:arbitrary:~

	●構文
dash:
	直列化-法:serializing
文字大小:character case::~
	大小いずれかに:into a single casing

	区別-:sensitive
式:expression:~
括弧類:brackets:~
禁則:prohibition:~
極めて:extremeに:~
寛容:permissive:~
削られ:trimされ:~
UUID:
実数:number:~
区分:segment:~
数量-:numeric:~
綴られ:spellされ:~
裸の:bare:~
封入-:enclose:~

	〜規則:comma elision rule
	~comma:bare comma
	無に:nothing
	後続-:follow
	一連の:series of
	頭部を成す:leading
	符号位置ごとに:codepoint-by-codepoint

	●条件付き
染まっ:taintされ::~
染めら:taintさ::~
伝染的:infectious::~
有向:directed:~
循環的:cyclic::~
	循環~用の:cyclic
循環-:cycle::~
循環:cycle::~
循環依存:cyclic dependencies::~
代入-:substitute::~
代入:substitution::~
代入待ちの:pending-substitution::~
族:family:~
	設定し直:reset

	●処理一般
	~GOTO:repeatする
	ε:optional
	直列化し直す:reserialized
	解決されずに:unresolved
	%関数:func
	~RET:exit
	渡され:pass

	●仕様
無用:useless:~
現実:real-world:~
明白:obvious:~
普通の:ordinary:~
致命的:fatal:~
注力-:focus:~
給-:supply:~
陥穽:pitfall:落とし穴
困惑-:confuse:~
拡げて:expandして:~
mailing::::メーリング
単直:straightforward:簡単
不用意:accidental:~

	見つけ難い:difficult-to-spot
	により定義される:-defined
	定義し直す:redefine
	互換になれない:incompatible
	-:possible
	~~作業
	体系:scheme
	用途に見合った~~体系的な:informative
	用例:example
	多目的:many purposes
	安全弁付き~codeを書ける:defensive coding
	見かけからは~~意味を汲み取れない:seemingly-arbitrary
	最終:Last Call
	〜易く:easier to
	覚え易い:mnemonic
	誤り易い:error-prone
	誤り難く:less error-prone
	誤記:typos
	読み:read
	自由な:open-ended
	編集:editing
	従って
	~~容易い:amenable to
	妨げる:prevent
	利かない:can’t be intelligently
	利用箇所
	~~総称され:known collectively
	公開
	ときには〜ことも:sometimes
	記され:written
	驚くことに:surprisingly
	ある〜もたらす:produce some complications
	選ぶ:choose
	選んだ:-chosen
	可能性:potential
	勧める:advised
	利用されない:unused
	指す:refer
	記す:write
	意外な:knock-on
	〜について:around
	汎用~的に:generically
	この仕様:this incarnation
	生きたまま:alive
	保って:keep
	助力-:helping
	もっと踏み込んだ:strengthen
	草案:draft
	言い回し:wording
	~~説明:illustrate
	字義どおり:well
	特に注意:It is important to note that
	~~明らかに~~不規則:frankly weird
	過去の挙動:past
	~~最小限:smallest
	ただし:with one exception

	●保安
DoS:denial-of-service:DoS
	DoS:Denial-of-Service
macro::::マクロ
	~macro展開:macro-expansion
展開-:expand::~
展開:expansion::~
防御-:defend::~
防御:defense::~
仕掛けら:mountさ:~
課す:imposeする:~
累乗的:exponential:~

	使い回す:around within
	抗して:against
	昔からある:long-standing

	●未分類
作動-:act:~
調和-:match:~
裏返す:flipする:~
保存-:save:~
復唱-:echo back:~
隣接な:adjacentな:隣接する
検索置換:Find-and-Replace::~
design::::デザイン
theme::::テーマ
component::::コンポーネント
巨大:large:~
翻訳:translation:~
保存-:save:~
locale::::ロケール
退化-:degenerate:~
密に:compactに:~
流動的:fluid:~
可変:variable:~
typography::::タイポグラフィ
削る:trimする:~
合字:ligature::~
Greek:::ギリシア文字
英語:English:~
変形n:transformation::変形
照合c:collation:照合
横取り:intercept:~

	~GOTO:repeatする
	%関数:func
	取り出す:draw
	組み込む:include
	込みで:including
	辺で結ぶ:add an edge between
	散らばって:scattered throughout
	現れる:appear
	~~現れる:show up
	残され:left
	合間に挟まれ:interspersed with
	基準に:against
	そこでは:at that point
	見かけは一致する:identical-looking
	似て非なる並びが生じない:similar appearing sequences are identical
	似た様に現れる:similar-appearing
	文法を検査する:grammar-check
	~animate能:animatability
	紛れ込む:smuggle
	`.test^css:test patch
	^v:red
	倍数:multiples
	未知かもしれない:unknowable

	低い
	俺
	僕
	私
	数
	^v:blue
	^v:red
	大きい:large
	より大きな:larger
	小さな:small
	小さい:small
	集める:gather
	初回の:first
	一群の:set
	他の部分:the rest
	〜内の他の:in the rest
	至る所:elsewhere
	終えた:finally
	最終的に:finally
	最終的に:eventually
	以外のもの:anything else besides
	任意:any
	対を成さない:unmatched
	格段に:much
	相当量の:quite a bit of
	箇所
	一箇所:spot／
	類い:sort
	絶えず:ever
	一方が他方の先祖である:higher 〜 lower
	他方:to each other
	一方:while
	側
	同時に:at once
	一括して:at once
	一種の:some types of
	何でも:anything
	こともある:sometimes
	時点
	互い:each other
	何にでも:anything
	〜付き
	元
	先
	出-
	前者:first one
	後者:second
	単に:simply
	単に:just
	同様:like
	外へ
	方
	だけで済む
	数個:three or four
	末尾
	段階
	全体
	点
	渡って:across
	並び:sequence／-
	全体を通して:throughout
	通して:with／:in terms of
	に加え:and

	●訳注
	匿名
	優先順位
	捉え方
	意図-

●●ref_normative

[CSS-ANIMATIONS-1]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://drafts.csswg.org/css-animations/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-CONDITIONAL-3]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-PROPERTIES-VALUES-API-1]
    Tab Atkins Jr.; Alan Stearns; Greg Whitworth. ＜CSS Properties and Values API Level 1＞. URL: https://drafts.css-houdini.org/css-properties-values-api-1/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. URL: https://drafts.csswg.org/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VALUES-5]
    Tab Atkins Jr.; Elika Etemad; Miriam Suzanne. ＜CSS Values and Units Module Level 5＞. URL: https://drafts.csswg.org/css-values-5/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[CSSOM-1]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. URL: https://drafts.csswg.org/cssom/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://drafts.csswg.org/web-animations-1/

●●ref_informative

[CHARMOD-NORM]
    Addison Phillips; et al. ＜Character Model for the World Wide Web: String Matching＞. URL: https://w3c.github.io/charmod-norm/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-EXTENSIONS]
    Tab Atkins Jr.. ＜CSS Extensions＞. ED. URL: https://drafts.csswg.org/css-extensions/
[CSS-FONTS-4]
    Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Custom Properties for Cascading Variables Module Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-variables-1/
公表履歴
	https://www.w3.org/standards/history/css-variables-1/
実装報告
	https://wpt.fyi/results/css/css-variables
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-variables-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	https://github.com/w3c/csswg-drafts/blob/main/css-variables-1/Overview.bs
テスト一式
	https://wpt.fyi/results/css/css-variables/
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-variables-1

</script>
</head>
<body>

<header>
	<hgroup>
<h1>カスケードする変数用のカスタムプロパティ — CSS Custom Properties for Cascading Variables Module Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p class="p-summary">
この~moduleは、
すべての~CSS~propに受容される新たな~primitiveな値~型として，~cascadeする変数（ `cascading variable^en ）を導入し、
それらを定義するための~custom~propも導入する。
◎
This module introduces cascading variables as a new primitive value type that is accepted by all CSS properties, and custom properties for defining them.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
巨大な文書や~appは（あるいは小さなものですら）、
相当量の~CSSを包含し得る。
~CSS~fileの中の値の多くは、
同じ~dataを複写することになる。
例えば、
色の~~体系を確立して，全体を通して数個の色を再利用している~siteがあったとする。
この~dataを改めることは、
~CSS~fileの中に散らばっている（あるいは複数~fileにわたっている）がために，困難で誤り易い~~作業にもなりかねず、
また，検索置換も~~容易いとは限らない。
◎
Large documents or applications (and even small ones) can contain quite a bit of CSS. Many of the values in the CSS file will be duplicate data; for example, a site may establish a color scheme and reuse three or four colors throughout the site. Altering this data can be difficult and error-prone, since it’s scattered throughout the CSS file (and possibly across multiple files), and may not be amenable to Find-and-Replace.
</p>

<p>
この~moduleは、
`~custom~prop$と~~総称される，作者~定義な~propの族を導入する。
それは、
~stylesheet作者が［
自身が選んだ名前を伴う~propに任意な値をアテガって、
その値を
— `var$f 関数を通して —
文書~内の至る所にある他の~propに利用する
］ことを許容する。
これにより、［
見かけからは~~意味を汲み取れない値にも，用途に見合った~~体系的な名前を付けられる
］ようになるので，巨大な~fileも読み易くなる。
また、［
`~custom~prop$の中で一箇所の値を変更するだけで，それが定義する変数を利用している箇所すべてに自動的に伝播する
］ことになるので，
その種の~file編集も格段に容易かつ誤り難くなる。
◎
This module introduces a family of custom author-defined properties known collectively as custom properties, which allow an author to assign arbitrary values to a property with an author-chosen name, and the var() function, which allow an author to then use those values in other properties elsewhere in the document. This makes it easier to read large files, as seemingly-arbitrary values now have informative names, and makes editing such files much easier and less error-prone, as one only has to change the value once, in the custom property, and the change will propagate to all uses of that variable automatically.
</p>

		<section id="values">
<h3 title="Value Definitions">1.1. 値~定義</h3>

<p class="trans-note">【
この節の内容は、
`~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
	</section>
	<section id="defining-variables">
<h2 title="Defining Custom Properties: the --* family of properties">2. ~custom~propを定義する： ~propの族 `--*^p</h2>

<p>
この仕様は、
`~custom~prop$と呼ばれる，~~自由に~~拡張可能（ `open-ended^en ）な［
~propたちが成す集合
］を定義する。
それらは、
他の~propの値の中の `var$f 関数の`代入$値
— `var$f を置換することになる値 —
を定義するために利用される。
◎
This specification defines an open-ended set of properties called custom properties, which, among other things, are used to define the substitution value of var() functions.
</p>

◎名 `--*@p 【注釈文を見よ】
◎値 `declaration-value$t?
◎初 `無効が保証される値$
◎
the guaranteed-invalid value
◎適 すべての要素, すべての疑似要素（一部の~propに制約されるものも含む）
◎
all elements and all pseudo-elements (including those with restricted property lists)
◎継 される
◎百 受容しない
◎算
`無効が保証される値$／指定d値
— ただし，後者においては、
値~内の各~変数【 `var$f 関数／`任意-代入~関数$】には`代入-$される。
◎
specified value with variables substituted, or the guaranteed-invalid value 
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~UAには、
すべての媒体
— 視覚的でないものも含む —
に対し，この~propを~supportすることが期待される。
◎
User agents are expected to support this property on all media, including non-visual ones.
</p>

<p>
`~custom~prop@
は、
"`--^c" から開始される任意の名前の~propである
— 例えば `--foo^p の様に。
`custom-property-name@t
生成規則がこれに対応する
— それは、
`dashed-ident$t （ 2 個の~dashから開始される，任意の妥当な`~CSS識別子$）として定義される。
ただし， "`--^c" 自体は除く
— それは、
~CSSによる将来の利用~用に予約される。
`~custom~prop$は、
もっぱら［
作者／利用者
］から利用されるものである。
~CSSが ここに示されるものを超える意味を与えることは、
決してない。
◎
A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo. The &lt;custom-property-name&gt; production corresponds to this: it’s defined as any &lt;dashed-ident&gt; (a valid identifier that starts with two dashes), except -- itself, which is reserved for future use by CSS. Custom properties are solely for use by authors and users; CSS will never give them a meaning beyond what is presented here.
</p>

<p class="trans-note">【
この名前は、
~vendor接頭辞~付きの~prop
（例： `-webkit-foo^p ）
から~vendor名を取り除いたもの
（例： `--foo^p ）と捉えることもできる
（すなわち、作者~自身が “匿名な~vendor” である）。
そのような捉え方を意図して命名されたのかもしれない。
】</p>

<div class="example">
<p>
~custom~propは、
多目的に利用できる変数を定義し，
`var$f 記法で参照される。
例えば，一群の色を一貫して~designに利用する~pageは、
それらの色を~custom~propに格納した上で，変数を通して利用できる：
◎
Custom properties define variables, referenced with the var() notation, which can be used for many purposes. For example, a page that consistently uses a small set of colors in its design can store the colors in custom properties and use them with variables:
</p>

<pre class="lang-css">
`root$ps {
  --main-color: #06c;
  --accent-color: #006;
}
/* <span class="comment">
~CSS~fileの残りの部分
◎
The rest of the CSS file
</span> */
#foo h1 {
  `color$p: var(--main-color);
}
</pre>

<p>
覚え易い色の命名により、
色~codeの中の見つけ難い誤記は防止される。
~theme色が絶えず変更されようが、
~web~page内のすべての~stylesheetに渡って多数の編集を行うことなく，
単純な一箇所（~custom~propの値）の変更に注力するだけで済むようになる。
◎
The naming provides a mnemonic for the colors, prevents difficult-to-spot typos in the color codes, and if the theme colors are ever changed, focuses the change on one simple spot (the custom property value) rather than requiring many edits across all stylesheets in the webpage.
</p>

<p class="trans-note">【
`var(--main-color)^v
が参照するのは，［［
それを利用する~prop
］が適用される要素
］の `--main-color^p ~propの値になる。
この例では， `--main-color^p が文書の~根~要素（ `root$ps ）に対し宣言されているので、
その値は，
`普通の継承d~propと同様に＠#as-normal-property$
— 別の `--main-color^p で上書きされない限り —
文書~内のどの要素（および疑似要素）にも継承され、
その結果，どの `var(--main-color)^v も値 `#06c^v が代入されることになる。
】</p>
</div>

<p>
他の~CSS~propと違って、
~custom~propの名前は`~ASCII大小無視$`ではない^em。
~custom~propの名前は、
互いに`一致する$場合に限り，等しいとされる。
◎
Unlike other CSS properties, custom property names are not ASCII case-insensitive. Instead, custom property names are only equal to each other if they are identical to each other.
</p>

<div class="example">
<p>
`--foo^p と `--FOO^p は、
どちらも妥当であるが，別個な~propになる
— `var(--foo)^v を利用すれば前者,
`var(--FOO)^v を利用すれば後者を指すことになる。
◎
While both --foo and --FOO are valid, they are distinct properties —using var(--foo) will refer to the first one, while using var(--FOO) will refer to the second.
</p>

<p>
たぶん，もっと驚くことに、
`--fo&#x00F3;^p と `--foo&#x0301;^p は，別個な~propになる。
前者は［
`00F3^U `LATIN SMALL LETTER O WITH ACUTE^cn
］で綴られ，
後者は［
~ASCII "o", `0301^U `COMBINING ACUTE ACCENT^cn
］並びとして綴られるが、［
~Unicode正規化, ~localeに特有な照合c
］による複階性と陥穽を避けるため，
“`一致する$” 関係は［
2 個の文字列が等しいかどうか
］を［
符号位置ごとの直な比較
］を利用して決定する。
◎
Perhaps more surprisingly, --foó and --foó are distinct properties. The first is spelled with U+00F3 (LATIN SMALL LETTER O WITH ACUTE) while the second is spelled with an ASCII "o" followed by U+0301 (COMBINING ACUTE ACCENT), and the "identical to" relation uses direct codepoint-by-codepoint comparison to determine if two strings are equal, to avoid the complexities and pitfalls of unicode normalization and locale-specific collation.
</p>
</div>

<p>
各種［
~OS／~keyboard／入力~method
］は，~textを［
視覚的には一致するが，異なる符号位置を利用して符号化する
］こともあるので、
作者には、［
混同の可能性を避けるよう，変数~名を選ぶ
］か［
似て非なる並びが生じないことを確保するよう，
変数~名に~escapeその他の手段を利用する
］ことを勧める。
例えば， `CHARMOD-NORM$r の § 2.3 を見よ。
◎
Operating systems, keyboards, or input methods sometimes encode visually-identical text using different codepoint sequences. Authors are advised to choose variable names that avoid potential confusion or to use escapes and other means to ensure that similar appearing sequences are identical. See Section 2.3 in [CHARMOD-NORM] for examples.
</p>

<div class="example">
<p>
次の~CSSを保守している開発者は、
`.test^css がなぜ `red^v になるか困惑するかもしれない：
◎
Developers maintaining the following CSS might be confused why the test patch is red:
</p>

<pre class="lang-css">
--fijord: red;
--fĳord: green;
--ﬁjord: blue;

.test {
  background-color: var(--fijord);
}
</pre>

<p>
その理由は、
これらの~custom~propは，見かけは一致するが異なる文字~並びを利用していることにある
⇒＃
1 個目は `LATIN SMALL LETTER F^cn + `LATIN SMALL LETTER I^cn + `LATIN SMALL LETTER J^cn ／
2 個目は `LATIN SMALL LETTER F^cn + `LATIN SMALL LIGATURE IJ^cn ／
3 個目は `LATIN SMALL LIGATURE FI^cn + `LATIN SMALL LETTER J^cn
◎
The reason is that the first custom property uses the character sequence LATIN SMALL LETTER F + LATIN SMALL LETTER I + LATIN SMALL LETTER J; the second, identical-looking one uses the character sequence LATIN SMALL LETTER F + LATIN SMALL LIGATURE IJ while the third uses the character sequence LATIN SMALL LIGATURE FI + LATIN SMALL LETTER J.
</p>

<p>
なので、
この~CSSは， 3 つの別個な~custom~propを包含する
— うち 2 つは利用されない。
◎
So the CSS contains three distinct custom properties, two of which are unused.
</p>
</div>

<p>
~custom~propは、
`all$p ~propにより設定し直される<strong>ことはない</strong>。
<span class="note">
将来には、
すべての変数を設定し直す~propも定義され得る。
</span>
◎
Custom properties are not reset by the all property. We may define a property in the future that resets all variables.
</p>

<p>
他の任意の~propと同じ意味で、
~custom~propにも`~CSS全域~keyword$を利用できる。
◎
The CSS-wide keywords can be used in custom properties, with the same meaning as in any another property.
</p>

<p class="note">注記：
すなわち それらは、
通常通り`~cascaded値$の時点で解釈され，~custom~propの値のように保全されることはない†。
したがって，対応する変数が解決される時点で代入されることもない。
◎
Note: That is, they’re interpreted at cascaded-value time as normal, and are not preserved as the custom property’s value, and thus are not substituted in by the corresponding variable.
</p>

<div class="trans-note">
<p>【†
すなわち，~custom~propに対する全域~keyword値は、
`var$f 関数が解決される前
— 算出d値を得る前 —
の段階で，`指定d値$（すなわち，`初期~値$または`継承d値$）にされる。
例えば，次の~stylesheet：
</p>

<pre class="lang-css">
:root {
  --foo: red;
}
p {
  --foo: inherit;
  color: var(--foo);
}
</pre>

<p>
における
`var(--foo)^v は、［
`inherit^v `ではなく^em，
`--foo^p が継承する値
］が代入されることになる。
したがって、
`p^e 要素の `color^p
は，その先祖の［
`color^p `ではなく^em,
`--foo^p 
］~propの値（この例では `red^v ）をとることになる。
】</p>
</div>

<p class="note">注記：
この~moduleは， “変数” を作成するための［
`var$f による`~custom~prop$の利用
］に注力しているが、
~scriptから［
構文解析される／作動される
］ような，実際の~custom~propとしても利用し得る。
`CSS-EXTENSIONS$r が、
これらの利用事例を拡げて，もっと利用し易くするものと期待されている。
◎
Note: While this module focuses on the use of custom properties with the var() function to create “variables”, they can also be used as actual custom properties, parsed by and acted on by script. It’s expected that the CSS Extensions spec [CSS-EXTENSIONS] will expand on these use-cases and make them easier to do.
</p>

<p id="as-normal-property">
~custom~propは、
“普通の” ~propであり，どの要素に対しても宣言できる。
それらは、
通常の［
継承と~cascade規則
］で解決される。
それらは、［
`media$at その他の`条件付き~group規則$により条件付きにすることもできる／
~HTMLの `style^a 属性の中でも利用できる／
~CSSOMを利用して［読取る／設定する］こともできる
］等々…。
◎
Custom properties are ordinary properties, so they can be declared on any element, are resolved with the normal inheritance and cascade rules, can be made conditional with @media and other conditional rules, can be used in HTML’s style attribute, can be read or set using the CSSOM, etc.
</p>

<p>
特に、
それらは，~animateすることすらできる
— ただし、
~UAには，それらの内容を解釈するすべがないので、
他の［
補間が利かない値~pair
］に対するときと同じく，
常に， “50% の所で裏返す” 様なふるまいになる。
また、
`keyframes$at 規則の中で利用される【宣言される】どの`~custom~prop$も，
`~animationに染まって@
いるとされ、
各種~animation~prop（ `animation-*^p ）の中で `var$f 関数を介して参照されたときの扱われ方に影響する。
◎
Notably, they can even be animated, but since the UA has no way to interpret their contents, they always use the "flips at 50%" behavior that is used for any other pair of values that can’t be intelligently interpolated. However, any custom property used in a @keyframes rule becomes animation-tainted, which affects how it is treated when referred to via the var() function in an animation property.
</p>

<p class="note">注記：
離散的に~animateする他の~propと同様に、
~custom~propは，`遷移し得ない＠~TRANSITION#transitionable$。
しかしながら，`登録-済み~custom~prop$は、
それに与えた構文が離散的でない~animationの挙動を有する場合には，遷移し得る。
◎
Note: Like any other property that animates discretely, custom properties can’t be transitioned. Registered custom properties can, however, if given a syntax that has non-discrete animation behavior.
</p>

<p>
~animationに染められるのは、
“伝染的” である：
~custom~propは、
`~animationに染まって$いる~propを参照するならば，
自身も`~animationに染まって$いることになる。
◎
Animation-tainted is "infectious": custom properties which reference animation-tainted properties also become animation-tainted.
</p>

<div class="example">
<p>
次の~style規則：
◎
This style rule:
</p>

<pre class="lang-css">
:root {
  --header-color: #06c;
}
</pre>

<p>
は、
根~要素に対し名前 `--header-color^p の`~custom~prop$を宣言し，
値 "`#06c^v" をアテガう。
この~propは、
文書~内の他の要素に継承される。
その値は、
`var$f 関数を通して参照できるようになる：
◎
declares a custom property named --header-color on the root element, and assigns to it the value "#06c". This property is then inherited to the elements in the rest of the document. Its value can be referenced with the var() function:
</p>

<pre class="lang-css">
h1 { `background-color$p: var(--header-color); }
</pre>

<p>
この規則は，
<code class="css">`background-color^p: `#06c^v;</code>
と記すことに等価になるが、
変数~名から色の用途が明瞭になることに加え、
根~要素の `--header-color^p ~propの値を変更するだけで，［
文書~内の他の要素に対し利用されている すべての `var(--header-color)^v
］が一括して更新される。
◎
The preceding rule is equivalent to writing background-color: #06c;, except that the variable name makes the origin of the color clearer, and if var(--header-color) is used on other elements in the document, all of the uses can be updated at once by changing the --header-color property on the root element.
</p>
</div>

<div class="example">
<p>
同じ名前の`~custom~prop$が複数回 宣言されている場合、
標準な~cascade規則を利用して解決される。
変数は常に，同じ要素に結付けられた~custom~propの`算出d値$から値を取り出す：
◎
If a custom property is declared multiple times, the standard cascade rules help resolve it. Variables always draw from the computed value of the associated custom property on the same element:
</p>

<pre class="lang-css">
:root { --color: blue; }
div { --color: green; }
#alert { --color: red; }
* { color: var(--color); }
</pre>

<pre class="lang-html">
&lt;p&gt;僕は根~要素から `blue^v を継承しています。&lt;/p&gt;
&lt;div&gt;俺には `green^v が直に設定されている。&lt;/div&gt;
&lt;div id='alert'&gt;
  私には `red^v が直に設定されているよ。
  &lt;p&gt;自分も `red^v だけど、継承なんだな。&lt;/p&gt;
&lt;/div&gt;
◎
&lt;p&gt;I inherited blue from the root element!&lt;/p&gt;
&lt;div&gt;I got green set directly on me!&lt;/div&gt;
&lt;div id='alert'&gt;
  While I got red set directly on me!
  &lt;p&gt;I’m red too, because of inheritance!&lt;/p&gt;
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
現実における`~custom~prop$の用例として、
文字列を その利用箇所から容易に外へ分離して，国際-化の保守を援助することが挙げられる：
◎
A real-world example of custom property usage is easily separating out strings from where they’re used, to aid in maintenance of internationalization:
</p>

<pre class="lang-css">
:root,
:root:lang(en) {--external-link: "external link";}
:root:lang(el) {--external-link: "εξωτερικός σύνδεσμος";}
:root:lang(ja) {--external-link: "~~外部~~リンク";}

a[href^="http"]::after {
  content: " (" var(--external-link) ")"
}
</pre>

<p>
変数の宣言を別~fileに分けて，翻訳の保守をより単純にすることもできる。
◎
The variable declarations can even be kept in a separate file, to make maintaining the translations simpler.
</p>
</div>

		<section id="syntax">
<h3 title="Custom Property Value Syntax">2.1. ~custom~propの値の構文</h3>

<div >
<p>
`~custom~prop$に許容される構文は極めて寛容にされている。
`declaration-value$t 生成規則は、［
1 個~以上の~tokenからなり，次に挙げる~tokenは包含しない
］`任意の^em並びに合致する：
</p>
<ul>
	<li>
`bad-string-token$P
</li>
	<li>
`bad-url-token$P
</li>
	<li>
対を成さない括弧類： `)-token$P, `]-token$P, `}-token$P
</li>
	<li>
~top-levelの `semicolon-token$P
</li>
	<li>
~top-levelの `delim-token$P のうち，その.値に "`!^c" を伴うもの
</li>
</ul>

◎
The allowed syntax for custom properties is extremely permissive. The &lt;declaration-value&gt; production matches any sequence of one or more tokens, so long as the sequence does not contain &lt;bad-string-token&gt;, &lt;bad-url-token&gt;, unmatched &lt;)-token&gt;, &lt;]-token&gt;, or &lt;}-token&gt;, or top-level &lt;semicolon-token&gt; tokens or &lt;delim-token&gt; tokens with a value of "!".
</div>

<p>
加えて、
`~custom~prop$の値が `var$f 参照を包含している場合、
その `var$f 参照は，指定された `var$f 文法に則って妥当でなければナラナイ。
さもなければ、
`~custom~prop$は無効になり，無視するモノトスル。
◎
In addition, if the value of a custom property contains a var() reference, the var() reference must be valid according to the specified var() grammar. If not, the custom property is invalid and must be ignored.
</p>

<p class="note">注記：
この定義と一般~CSS構文~規則から、
~custom~propの値は，対を成さない引用符や括弧類を決して含まず、
直列化し直すとき，より大きな構文~構成子
— それを封入している~style規則など —
に効果が及ぶことはない。
◎
Note: This definition, along with the general CSS syntax rules, implies that a custom property value never includes an unmatched quote or bracket, and so cannot have any effect on larger syntax constructs, like the enclosing style rule, when reserialized.
</p>

<p class="note">注記：
~custom~propは末尾に `!important^css を伴い得るが、
これは~CSS構文解析器により~propの値から自動的に除去された上で，
当の~custom~propを~CSS~cascadeにおいて`~importantな宣言$にする。
言い換えれば、
~top-levelの文字 "`!^c" の禁則は，
`!important^css の利用を妨げるものではない
— `!important^css は、
構文を検査する前に除去されるので。
◎
Note: Custom properties can contain a trailing !important, but this is automatically removed from the property’s value by the CSS parser, and makes the custom property "important" in the CSS cascade. In other words, the prohibition on top-level "!" characters does not prevent !important from being used, as the !important is removed before syntax checking happens.
</p>

<div class="example">
<p>
例えば，次は、
妥当な~custom~propである：
◎
For example, the following is a valid custom property:
</p>

<pre class="lang-css">
--foo: if(x &gt; 5) this.width = 10;
</pre>

<p>
この値は、
通常のどの~propの中でも無効になるので，`変数^emとしては明白に無用であるが、
~JSにより［
読取る／動作させる
］用途はあり得る。
◎
While this value is obviously useless as a variable, as it would be invalid in any normal property, it might be read and acted on by JavaScript.
</p>
</div>

<p>
~custom~propの値, および［
~custom~propの中へ代入される `var$f 関数の値
］の文字大小は、
`区別され^em，作者が与えた元の文字大小を保全するモノトスル。
（多くの~CSS値は，［
`~ASCII大小無視$なので、
~UAは，それらを大小いずれかに “正準-化” できる
］が、
~custom~propには，それは許容されない。）
◎
The values of custom properties, and the values of var() functions substituted into custom properties, are case-sensitive, and must be preserved in their original author-given casing. (Many CSS values are ASCII case-insensitive, which user agents can take advantage of by "canonicalizing" them into a single casing, but that isn’t allowed for custom properties.)
</p>


<div class="note">
<p>注記：
~custom~propは，`何でも^emを包含し得るので、
その内側に何があるか解釈する方法を知る一般的な仕方は無い
（それを参照する `var$f を通して既知な~propの中へ`代入-$されるまでは）。
それらの値は
— `部分的に^em，一部の事例に限って解決されることはなく —
完全に，解決されずに残され、［
`var^f 関数が合間に挟まれた，`~CSS~token列＠~CSSSYN#tokenization$
］が成す裸の~streamになる。
◎
Because custom properties can contain anything, there is no general way to know how to interpret what’s inside of them (until they’re substituted into a known property with var()). Rather than have them partially resolve in some cases but not others, they’re left completely unresolved; they’re a bare stream of CSS tokens interspersed with var() functions.
</p>

<p>
これには、
ある意外な含意がある。
例えば，~CSSにおける相対~URLは、
当の値が現れる~stylesheetの基底~URLを基準に解決される。
しかしながら，
`/a/style.css^l に在る~stylesheet内に
<code class="css">`--my-image^p: `url(foo.jpg)^v;</code>
の様な~custom~propが~~現れる場合、
即時に絶対~URLに解決されることはない
— それを指す変数が後で
`/b/style.css^l に在る`異なる^em ~stylesheet内で
<code class="css">`background$p: `var(--my-image)^v;</code>
の様に利用された場合、
`そこでは^em `/b/foo.jpg^l に解決されることになる。
◎
This has some knock-on implications. For example, relative URLs in CSS are resolved against the base URL of the stylesheet the value appears in. However, if a custom property like --my-image: url(foo.jpg); shows up in an "/a/style.css" stylesheet, it will not resolve into an absolute URL immediately; if that variable is later used in a different "/b/style.css" stylesheet like background: var(--my-image);, it will resolve at that point to "/b/foo.jpg".
</p>
</div>

		</section>
		<section id="guaranteed-invalid">
<h3 title="Guaranteed-Invalid Values">2.2. 無効が保証される値</h3>

<p>
`~custom~prop$の初期~値は、
`無効が保証される値@
になるとする。
◎
The initial value of a custom property is a guaranteed-invalid value.
</p>

<p>
`無効が保証される値$は、
字義どおり，無効になることが保証される。
ある~propの値に それが現れた場合、
当の~propは，`算出d値の時点で無効$になる。
◎
The guaranteed-invalid value is, well, guaranteed to be invalid. If it ever appears in a property value, then at computed value time that property becomes invalid at computed-value time.
</p>

<p>
~prop以外の文脈は，`無効が保証される値$用の自前の挙動を定義することになるが、
それは，常に何らかのイミで “無効” になる。
◎
Non-property contexts will define their own behavior for the guaranteed-invalid value, but it will always be "invalid" in some sense.
</p>

<p>
`無効が保証される値$が直列化されるときは，空~文字列になるが、
~custom~propの中に
— `--foo: ;^css の様に —
実際に空な値を書いても，妥当な（空な）値になり、
`無効が保証される値$にはならない。
理由が何であれ，［
`~custom~prop$を`無効が保証される値$に手動で設定し直す
］よう求めるならば、
~keyword `initial$v 利用して行える。
◎
The guaranteed-invalid value serializes as the empty string, but actually writing an empty value into a custom property, like --foo:;, is a valid (empty) value, not the guaranteed-invalid value. If, for whatever reason, one wants to manually reset a custom property to the guaranteed-invalid value, using the keyword initial will do this.
</p>

<p class="note">注記：
［
`登録-済み~custom~prop$でない`~custom~prop$の`初期~値$を呼出す
］こと以外に［
`無効が保証される値$を作成する仕方
］は、
`任意-代入~関数$が無効になるようにする他にない。
◎
Note: Other than invoking the initial value of a non-registered custom property, the only way to create the guaranteed-invalid value is by having an invalid arbitrary substitution function.
</p>

		</section>
		<section id="cycles">
<h3 title="Resolving Dependency Cycles">2.3. 循環依存の解決-法</h3>

<p>
`~custom~prop$は、
ほとんどの所では評価されないままにされるが，
その値の中の `var$f 関数を評価することは許容されている。
そのため、
`~custom~prop$自身が自身を指す `var$f を利用していたり，
複数の`~custom~prop$が互いに他を指している場合、
循環依存が生じ得る。
◎
Custom properties are left almost entirely unevaluated, except that they allow and evaluate the var() function in their value. This can create cyclic dependencies where a custom property uses a var() referring to itself, or two or more custom properties each attempt to refer to each other.
</p>

<p>
各~要素に対し、
各`~custom~prop$に対応する~nodeからなる有向~依存関係~graphを，次のように作成する
⇒
ある`~custom~prop$ %prop1 の値が，ある`~custom~prop$ %prop2
<span class="note">
（ %prop1 と同じでもよい）
</span>
を指している `var$f 関数を包含している（ `var$f の~fallback引数も込みで）ならば、
%prop1 から %prop2 へ辺で結ぶ。
◎
For each element, create a directed dependency graph, containing nodes for each custom property. If the value of a custom property prop contains a var() function referring to the property var (including in the fallback argument of var()), add an edge between prop and the var. Edges are possible from a custom property to itself.
</p>

<p>
この依存関係~graph内に循環がある場合、
その循環を成す どの`~custom~prop$も，`算出d値の時点で無効$になる。
◎
If there is a cycle in the dependency graph, all the custom properties in the cycle are invalid at computed-value time.
</p>

<p class="note">注記：
定義-済み~propは、
ある［
依存関係の循環
］に関与する場合には，［
その値~内に無効な変数があることにより，`算出d値の時点で無効$になる
］か，循環~用に自前の取扱いを定義する（ `em$u 値を利用している `font-size$p の様に）。
それらは、
~custom~propの様に`無効が保証される値$には算出されない。
◎
Note: Defined properties that participate in a dependency cycle either end up with invalid variables in their value (becoming invalid at computed-value time), or define their own cyclic handling (like font-size using em values). They do not compute to the guaranteed-invalid value like custom properties do.
</p>

<div class="example">
<p>
変数を安全に利用する~custom~propの例を示す：
◎
This example shows a custom property safely using a variable:
</p>

<pre class="lang-css">
:root {
  --main-color: #c06;
  --accent-background: linear-gradient(
      to top, var(--main-color), white
  );
}
</pre>

<p>
`--accent-background^p ~propは
（および、
`var(--main-color)^v を利用する他の~propも同様に）、
`--main-color^p ~propが変更されたときに自動的に更新されることになる。
◎
The --accent-background property (along with any other properties that use var(--main-color)) will automatically update when the --main-color property is changed.
</p>
</div>

	<div class="example invalid-example">
<p>
他方，次の例における 2 つの変数は、
互いに依存しているので，無効な~instanceになる：
◎
On the other hand, this example shows an invalid instance of variables depending on each other:
</p>

<pre class="lang-css">
:root {
  --one: calc(var(--two) + 20px);
  --two: calc(var(--one) - 20px);
}
</pre>

<p>
`--one^p, `--two^p どちらも，
今や`算出d値の時点で無効$になり、
長さでなく`無効が保証される値$に算出される。
◎
Both --one and --two are now invalid at computed-value time, and compute to the guaranteed-invalid value rather than lengths.
</p>
</div>

<p>
`~custom~prop$の値を成す各 `var$f 関数は、
当の値が継承される`前に^em，
算出d値の時点で`解決される＠#resolve-a-var-function$
【`代入-$される】ことに特に注意。
一般に，循環依存が生じるのは、
同じ要素~上の複数の~custom~propが互いを指すときに限られる。
要素~treeの中で，一方が他方の先祖である 2 つの要素~上に定義された~custom~propの間で参照が循環することは、
決してない。
◎
It is important to note that custom properties resolve any var() functions in their values at computed-value time, which occurs before the value is inherited. In general, cyclic dependencies occur only when multiple custom properties on the same element refer to each other; custom properties defined on elements higher in the element tree can never cause a cyclic reference with properties defined on elements lower in the element tree.
</p>

<div class="example">
<p>
例えば，次の構造における、
３個の~custom~propが循環することは<strong>ない</strong>。
すべて妥当な変数を定義する：
◎
For example, given the following structure, these custom properties are not cyclic, and all define valid variables:
</p>

<pre class="lang-css">
&lt;one&gt;&lt;two&gt;&lt;three /&gt;&lt;/two&gt;&lt;/one&gt;
&lt;style&gt;
one   { --foo: 10px; }
two   { --bar: calc(var(--foo) + 10px); }
three { --foo: calc(var(--bar) + 10px); }
&lt;/style&gt;
</pre>

<p>
`one^e 要素は、
`--foo^p 用の値を定義する。
`two^e 要素は、
この値を継承することに加え，
`foo^css 変数を利用して自身の `--bar^p に値をアテガう。
最後に， `three^e 要素は、［
変数が`代入された後の^em
`--bar^p 値
］を継承する
（言い換えれば、
値 `calc(10px + 10px)^v を見る）
— それから、
その値を通して自身の `--foo^p を定義し直す。
`three^e が継承する `--bar^p 値は，
`one^e 上で定義される `--foo^p ~propへの参照をもはや包含していないので、
`var(--bar)^v 変数を利用して `--foo^p を定義することは循環的ではなく，
（通常の~propの中で変数として参照されるときは）
実際に最終的に `30px^v に解決される値を定義する。
◎
The &lt;one&gt; element defines a value for --foo. The &lt;two&gt; element inherits this value, and additionally assigns a value to --bar using the foo variable. Finally, the &lt;three&gt; element inherits the --bar value after variable substitution (in other words, it sees the value calc(10px + 10px)), and then redefines --foo in terms of that value. Since the value it inherited for --bar no longer contains a reference to the --foo property defined on &lt;one&gt;, defining --foo using the var(--bar) variable is not cyclic, and actually defines a value that will eventually (when referenced as a variable in a normal property) resolve to 30px.
</p>
</div>

		</section>
	</section>
	<section id="using-variables">
<h2 title="Using Cascading Variables: the var() notation">3. ~cascade変数の利用-法： `var^f 記法</h2>

<p>
`~custom~prop$の値は、
`var$f 関数を通して別の~propの中へ`代入-$され得る／できる。
`var$f の構文は：
◎
The value of a custom property can be substituted into the value of another property with the var() function. The syntax of var() is:
</p>

<pre class="prod">
`var@f
	= var( `custom-property-name$t, `declaration-value$t? )
</pre>

<p>
`var$f 関数は、
`任意-代入~関数$である。
◎
The var() function is an arbitrary substitution function.
</p>

<p>
関数の最初の引数が、
代入~値を~~供する`~custom~prop$†の，名前を与える。
関数に 2 個目の引数が供されている場合、
それが~fallback値になり，参照された`~custom~prop$が`無効が保証される値$をとるときの代入~値として利用される。
◎
The first argument to the function is the name of the custom property to be substituted. The second argument to the function, if provided, is a fallback value, which is used as the substitution value when the value of the referenced custom property is the guaranteed-invalid value.
</p>

<p class="trans-note">【†
代入~値を~~供する~custom~propは、［［
`var$f を値に利用する~prop
］が適用される要素
］上のそれになる。
】</p>

<p>
通例的な［
値どうしを分離していない~commaは省略するよう要求する規則
］の例外として、
何も後続していない~commaが在る場合は，［
~fallback値は空であることを指示している，妥当な `var$f
］として扱うモノトスル。
◎
In an exception to the usual comma elision rules, which require commas to be omitted when they’re not separating values, a bare comma, with nothing following it, must be treated as valid in var(), indicating an empty fallback value.
</p>

<p class="note">注記：
すなわち、
`var(--a,)^v は妥当な関数を指定している
— ~custom~prop `--a^p が［
妥当でない／欠落な
］場合、
`var$f は無に置換されるべきである。
◎
Note: That is, var(--a,) is a valid function, specifying that if the --a custom property is invalid or missing, the var() should be replaced with nothing.
</p>

<p class="note">注記：
~fallbackの構文でも、
`~custom~prop$のそれと同様に，~commaが許容される。
例えば， `var(--foo, red, blue)^v は、
~fallback値として `red, blue^v を定義する。
すなわち、
最初の~commaと関数の末尾までの間を成すすべてが，~fallback値と見なされる。
◎
Note: The syntax of the fallback, like that of custom properties, allows commas. For example, var(--foo, red, blue) defines a fallback of red, blue; that is, anything between the first comma and the end of the function is considered a fallback value.
</p>

<div class="example">
<p>
~fallback値により、
一種の安全弁付き~code（ `defensive coding^en ）を書けるようになる。
例えば，より大きな~appに組み込むための~componentを作成する場合、
変数をその~style付けに利用すれば，
当の~componentを~appの他の部分と調和させることも容易になる。
◎
The fallback value allows for some types of defensive coding. For example, an author may create a component intended to be included in a larger application, and use variables to style it so that it’s easy for the author of the larger application to theme the component to match the rest of the app.
</p>

<p>
~fallbackが無ければ、
~app作者は，当の~componentが利用するすべての変数に値を給さなければならなくなる。
~fallbackがあれば、
~component作者は，既定の値を給しておけるようになり、
~app作者は，上書きしたい変数だけ値を給すれば済むようになる。
◎
Without fallback, the app author must supply a value for every variable that your component uses. With fallback, the component author can supply defaults, so the app author only needs to supply values for the variables they wish to override.
</p>

<pre class="lang-css">
/* <span class="comment">
~componentの~style
◎
In the component’s style:
</span> */
.component .header { 
  color: var(--header-color, blue); 
}
.component .text { 
  color: var(--text-color, black); 
}
/* <span class="comment">
より大きな~appの~style：
◎
In the larger application’s style:
</span> */
.component {
  --text-color: #080;
  /* <span class="comment">
`--header-color^p は、
設定されないので，~fallback値（ `blue^v ）のまま。
◎
header-color isn’t set, and so remains blue, the fallback value
</span> */
}
</pre>
</div>

<div class="algo">
<p>
要素 %要素 に適用される~prop %~prop の値が包含している
<dfn id="resolve-a-var-function">`var$f 関数 %関数 用に`任意-代入~関数を解決する$</dfn>
ときは：
◎
To resolve a var() function:
</p>
<ol>
	<li>
%~custom~prop ~LET %関数 の 1 個目の引数により命名される［
%要素 の`~custom~prop$
］
◎
↓</li>
	<li>
%結果 ~LET %~custom~prop の値
◎
Let result be the value of the custom property named by the function’s first argument, on the element the function’s property is being applied to.
</li>
	<li>
%~fallback ~LET %関数 の 2 個目の引数は［
在るならば その値 ／
無いならば ε【！`無効が保証される値$】
］
◎
Let fallback be the value of the function’s second argument, defaulting to the guaranteed-invalid value if it doesn’t have a second argument.
</li>
	<li>
~IF［
%~custom~prop は`~animationに染まって$いる
］~AND［
%~prop は`~animate不可$である
］
⇒
%結果 ~SET  ε【！`無効が保証される値$】
◎
If the custom property named by the var()’s first argument is animation-tainted, and the var() is being used in a property that is not animatable, set result to the guaranteed-invalid value.
</li>
	<li>
~RET ( %結果, %~fallback )
◎
Return result and fallback.
</li>
</ol>
</div>

		<section id="variable-units">
<h3 title="Variable Units">3.1. 可変~単位</h3>

<p class="trans-note">【
この節は，この仕様の~level 2 に追加された主な内容であり、
編集上の都合により，この訳にて与えている。
】</p>

<p>
`~custom~prop$は、
`var$f 関数で直に参照されることに加えて，~custom単位としても参照され得る。
それは、
文書~内の
— たぶん，ある設計-~systemにより確立された —
有意な “基底~size” の倍数を容易に利用できるようにする。
◎
In addition to being referenced directly with the var() function, custom properties can be referenced as custom units, making it easy to use multiples of significant "base sizes" in a document, perhaps established by a design system.
</p>

<p>
単位として `dashed-ident$t を伴う`次元$は、
`可変~単位~参照@
（ `variable unit reference^en ）になる。
その効果, それに対する制約は、
`var$f を利用するときと一致する
— `~custom~prop$は、
当の単位の名前で参照される。
◎
A dimension whose unit is a &lt;dashed-ident&gt; is a variable unit reference. It has identical effects and restrictions to using var(); the unit name is the custom property being referenced.
</p>

<p>
唯一の相違は、
`可変~単位~参照$は
— `~custom~prop$の値が直に代入されるのではなく —
次が代入されることである
⇒
<code class="value">calc(%X * (var(%Y)))</code>
— ［
%X, %Y
］は，当の次元を成す［
数量-成分, 単位~成分
］
◎
The only difference is during substitution—rather than just substituting the custom property value directly, it substitutes as calc(X * (var(Y))), where X is numeric component of the dimension, and Y is the unit component of the dimension.
</p>

<div class="example">
<p>
例えば， “流動的な（ `fluid^en ）~typography” は、
~textを表示域の~sizeに則って~sizeする。
これのごく単純な~versionは、
次のように作成できる：
◎
For example, "fluid typography" sizes text according to the viewport size. A very simple version of this can be created as:
</p>

<pre class="lang-css">
@property --fem { /* <span class="comment">
“流動的な `em^u”
◎
"fluid em"
</span> */
  syntax: "&lt;length&gt;";
  initial-value: 2vw;
  inherits: true;
}

.fluid-type {
  font-size: 1.2--fem;
  /* <span class="comment">
は、
次と等価になる
◎
equivalent to
</span> */
  font-size: calc(1.2 * (var(--fem)));
}
</pre>

<p class="trans-note">【
`initial-value$d 記述子は，
原文では `initial^d と記されているが（過去の名前と思われる）、
現在の仕様に基づくよう改めている。
】</p>

<p>
もっと複階的な式も利用できる。
例えば，流動的な~typographyは、
~screenがごく［
大きい／小さい
］ときに退化する状況を避けるため，［
表示域に応じて，~sizeが`どこまで^em応答するか
］に関して制限sを課すよう求まれることが多い：
◎
More complex expressions can be used as well. For example, fluid typography often wants to impose limits on how much the size responds to the viewport, to avoid degenerate situations on very large or very small screens:
</p>

<pre class="lang-css">
@property --fem { /* <span class="comment">
“流動的な `em^u”
◎
"fluid em"
</span> */
  syntax: "&lt;length&gt;";
  initial-value: clamp(10px, 1vw + 1vh, 1rem);
  inherits: true;
}

.fluid-type {
  font-size: 1.2--fem;
  /* <span class="comment">
`12px^v 以上 `1.2rem^v 以下になる。
◎
Won’t get smaller than 12px, or larger than 1.2rem.
</span> */
}
</pre>

<p>
`可変~単位~参照$は，`~custom~prop$参照なので、
【子孫にて】`~custom~prop$を設定することで，通常に上書きできる。
これは、
ある~componentを汎用~的に~styleしつつ，~page上の位置に応じて特化するときに有用になり得る：
◎
As the variable unit reference is a custom property reference, it can be overridden by setting the custom property normally. This can be useful to specialize a component for a particular position on the page, while still styling it generically:
</p>

<pre class="lang-css">
@property --bs { /* <span class="comment">
塊~size
◎
block size
</span> */
  syntax: "&lt;length&gt;";
  initial-value: 8px;
  inherits: true;
}

.module {
  margin-block: 1.5--bs;
  border-block: .5--bs;
  /* <span class="comment">
塊-軸［
~margin, ~border
］を［
`12px^v, `4px^v
］にする
◎
gives a vertical margin of 12px, and vertical border of 4px
</span> */
}

.sidebar .module {
  --bs: 6px;
  /* <span class="comment">
`.sidebar^css 内では~componentが少し密になるよう，塊-軸［
~margin, ~border
］を［
`9px^v, `3px^v
］にする。
◎
Makes the components slightly more compact in the sidebar, with a vertical margin of 9px and a vertical border of 3px.
</span> */
}
</pre>
</div>

<p class="note">注記：
`可変~単位~参照$は，
~fallback値をとり得ないので
【関数-記法ではないので，~fallback値を指定し得ない】、
参照-先の`~custom~prop$が存在しない場合や`無効が保証される値$【！無効な値】になる場合，
当の単位~参照も無効になる。
代わりに，
`property$at を利用して`登録-済み~custom~prop$を作成すること
— そうすれば、
`initial-value$d 記述子の値が既定として利用されるようになるので。
◎
Note: Variable unit references can’t have fallback values, so if the referenced custom property doesn’t exist or is invalid, the unit reference will be invalid as well. Use @property to create a registered custom property, as the initial value will instead be used as the default.
</p>

<p class="note">注記：
`可変~単位~参照$は，明瞭に［
参照-先の`~custom~prop$が数量-値をとる
］ことを
（ `calc$f の中へ代入されても妥当になるよう）
期待するが、
これを施行するものは無い。
数量-値でない値を給して，
初期~値を上書きした場合、
代入した結果は，
単純に無効な~propになる
（例： 上の `--fem^u 単位の例が与えられた下で，
<code class="css">`--fem^p: `red^v;</code> を給したなら、
`font-size^p は `calc(1.2 * (red))^v になり，無効になる）。
◎
Note: While variable unit references clearly expect their referenced custom property to have a numeric value (so that it’s valid to substitute into a calc()), nothing enforces this. Supplying a non-numeric value, such as by using --fem: red; to override the initial value in the above examples, will simply result in an invalid property after substitution, like font-size: calc(1.2 * (red));.
</p>

		</section>
	</section>
	<section id="apis">
<h2 title="APIs">4. ~API</h2>

<p>
すべての`~custom~prop$`宣言$に対し、
その`文字大小区別か$は ~T に設定される。
◎
All custom property declarations have the case-sensitive flag set.
</p>

<p class="note">注記：
~custom~propは，名前の文字大小が区別されるので、
`CSSStyleDeclaration$I ~objの中に
<strong>C</strong>amel<strong>C</strong>ase
形で現れることはない。
自動的に CamelCase 化する~text変形nの類いは，これと互換になれない。
それらは、
`getPropertyValue()＠~CSSOM1#dom-cssstyledeclaration-getpropertyvalue$c, 等の~interfaceを介して，適正な名前で~accessできる。
◎
Note: Custom properties do not appear on a CSSStyleDeclaration object in camel-cased form, because their names may have both upper and lowercase letters which indicate distinct custom properties. The sort of text transformation that automatic camel-casing performs is incompatible with this. They can still be accessed by their proper name via getPropertyValue()/etc.
</p>

		<section id="serializing-custom-props">
<h3 title="Serializing Custom Properties">4.1. ~custom~propの直列化-法</h3>

<p>
~custom~propの名前を直列化した結果は、
作者から供されたものと正確に同じ符号位置~並びになるモノトスル
— 文字大小を改めることなく。
◎
Custom property names must be serialized as the exact code point sequence provided by the author, including not altering the case.
</p>

<p class="note">注記：
~customでない~propに対しては、
その名前は~ASCII範囲に制約され，`~ASCII大小無視$なので、
実装は，概して名前を小文字~化するよう直列化する。
◎
Note: For non-custom properties, property names are restricted to the ASCII range and are ASCII case-insensitive, so implementations typically serialize the name lowercased.
</p>

<p>
`~custom~prop$の［
指定d値／算出d値
］を直列化した結果は：
◎
↓</p>
<ul>
	<li>
`正確に作者が指定したとおり^emになるモノトスル。
他の~propにて生じ得る単純~化
— 指定d値を成す［
~commentを落とす／
空白を正規化する／
数量-~tokenを直列化し直す
］等々 —
ことはないよう，
および算出d値を `var$f 関数の置換~用に保存するよう。
◎
Specified values of custom properties must be serialized exactly as specified by the author (with one exception, below). Simplifications that might occur in other properties, such as dropping comments, normalizing whitespace, reserializing numeric tokens from their value, etc., must not occur.
◎
Computed values of custom properties must similarly be serialized exactly as specified by the author (with the same one exception, below), save for the replacement of any var() functions.
</li>
	<li>
<p>
ただし，値が`空^emな場合（ `--foo:;^css など†）は、
1 個の~spaceからなる文字列になるモノトスル。
</p>

<p class="trans-note">【†
下の注記から、
空~文字列が指定された場合（ `--foo: "";^css など）も同様になろう。
】</p>
◎
The one exception to serialization being precisely as specified in the source file is that an empty custom property (such as --foo:;) must serialize with a single space as its value.
</li>
</ul>

<div class="example">
<p>
例えば，次の~propが与えられられたとき：
◎
For example, given the following properties:
</p>

<pre class="lang-css">
--y: /* baz */;
--x: /* foo */ var(--y) /* bar */;
</pre>

<p>
`--x^p の指定d値の直列化は
`/* foo */ var(--y) /* bar */^l
になり，
`--x^p の算出d値の直列化は
`/* foo */ /* baz */ /* bar */^l
にならなければならない。
◎
the serialization of the specified value of --x must be "/* foo */ var(--y) /* bar */", while the serialization of the computed value of --x must be "/* foo */ /* baz */ /* bar */".
</p>

<p>
（値の頭部を成す空白は、
~CSS構文解析器により自動的に削られ，ここでは保全されないことに注意。）
◎
(Note that the leading whitespace on the value is automatically trimmed by the CSS parser; it’s not preserved here.)
</p>
</div>

<div class="note">

<p>注記：
この “正確に作者が指定したとおりに直列化する” 要件が存在するわけは、
作者は，ときには~custom~prop内に非~CSSな情報を格納することもあり、
この情報を “正規化する” と，作者~codeを非互換化する仕方で値が変化し得るからである。
◎
This "exactly as specified" requirement exists because authors sometimes store non-CSS information in custom properties, and "normalizing" this information can change it in ways that break author code.
</p>

<p>
例えば，~custom~prop内に
<code class="css">`--uuid^p: `12345678-12e3-8d9b-a456-426614174000^v</code>
の様に~UUIDが格納され、
~scriptから~accessされたとき，当の~UUIDを記されたとおり復唱することが要求されることもある。
◎
For example, storing a UUID in a custom property, like --uuid: 12345678-12e3-8d9b-a456-426614174000, requires the UUID to be echoed back out as written when it’s accessed by script.
</p>

<p>
この値は、
形上では，~CSSにより一連の隣接な［
実数／次元
］として構文解析される。
特に，区分 `-12e3^l は、
−12000 に等しい実数として構文解析される。
それを，他の文脈において［
~CSSOMにより要求されるとおり，その形で直列化し直す
］と、
作者による値の利用を致命的に非互換化することになろう。
◎
This value is technically parsed by CSS as a series of adjacent numbers and dimensions. In particular, the segment "-12e3" parses as a number, equal to -12000. Reserializing it in that form, as required by CSSOM in other contexts, would fatally break the author’s use of the value.
</p>
</div>

<div class="note">
<p>注記：
空な~custom~propを 1 個の~spaceとして直列化する要件は、
既存の~CSSOM~APIに指定された動作
— `setProperty()＠~CSSOM1#dom-cssstyledeclaration-setproperty$c に空~文字列が渡された場合には，
代わりに `removeProperty()＠~CSSOM1#dom-cssstyledeclaration-removeproperty$c として動作すること —
との互換性を得るために因る。
◎
The requirement to serialize an empty custom property as a string with a single space in it instead is due to compatibility with the existing CSSOM API. setProperty() specifies that if the passed value is an empty string it instead acts as removeProperty().
</p>

<p>
この挙動は、
~~明らかに~~不規則であり，新たな~APIにおいては行われないが、
過去の挙動は変更し得ない。
空な~propを正確aに空~文字列として直列化すると、
~custom~propの値が往復すること
— ~custom~propの値を ある要素から読取って［
同じ／他の
］要素に設定すること —
が意図されるとおりに働かなくなる。
1 個の~spaceを利用することは、
作者が意図した挙動を~アリな限り保全する一方で，
何かを不用意に非互換化する機会cを~~最小限にする
— ~JSにおいて~custom~prop値で作業している作者は、
おそらく，［
いずれにせよ，値に対し `trim()＠https://tc39.es/ecma262/multipage/text-processing.html#sec-string.prototype.trim$c を~callする
］ので。
◎
This is a frankly weird behavior, and not something we would do in new APIs. But we can’t change the past, and letting empty properties accurately serialize as the empty string would mean that round-tripping a custom property value, or reading a property on one element and setting a property on another element to the same value, wouldn’t work as intended. Using a single space preserves the author-intended behavior as much as possible, while having the smallest chance of accidentally breaking things, since authors working with custom property values in JS are probably calling trim() on the values anyway.
</p>
</div>

		</section>
	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-20220616">
`2022年 6月 16日 勧告候補~snapshot＠~TR/2022/CR-css-variables-1-20220616/$
からの変更点
◎
5.1. Changes Since the 16 June 2022 CR Snapshot
</dt>
	<dd>
【直列化における】
元の~tokenたちの合間への~comment挿入は、
正確に 1 個ではなく 0 個以上の~comment【？】を伴って起こり得ることを明確化した。
◎
Clarified that the comment-insertion can happen with 0+ comments between the original tokens, not just exactly 1.
</dd>
	<dd>
`~custom~prop$における遷移の挙動を注記において明確化した。
◎
Clarified the transition behavior of custom properties, in a note
</dd>

	<dt id="changes-20211111">
`2021年 11月 11日 勧告候補~草案＠~TR/2021/CRD-css-variables-1-20211111/$
からの変更点
◎
5.2. Changes Since the 11 November 2021 CR Draft
</dt>
	<dd>
~custom~propは，すべての疑似要素（一部の~propに制約されるものも含む）に適用されることを明確化した。
◎
Clarified that custom properties apply all pseudo-elements (including those with restricted property lists)
</dd>
	<dd>
【~custom~propの名前に関する】課題を［
結合~文字, 合字, 等々
］で~~説明する例を追加した。
◎
Added example to illustrate issues with combining characters, ligatures, etc
</dd>
	<dd>
別個な符号位置~並びを利用しつつ似た様に現れる変数~名について、
もっと踏み込んだ言い回しにした。
◎
Strengthened wording around similar-appearing variable names that use distinct codepoint sequences
</dd>
	<dd>
より視覚的に別個な言語（英語と~Greek）を例として利用することにより、
例を明確化した。
◎
Clarified an example by using more visually distinct languages as examples (English and Greek)
</dd>
	<dd>
§ ~securityと~privacyの考慮点
を別々な節に分割した。
◎
Split Security and Privacy into separate sections
</dd>

	<dt id="changes-20151203">
`2015年 12月 3日 勧告候補＠~TR/2015/CR-css-variables-1-20151203/$
からの変更点
◎
5.3. Changes Since the 03 December 2015 CR
</dt>
	<dd>
`css-syntax-3$r は，今や宣言~値から空白を自動で削るので、
空な変数でも許容されるよう，
~custom~prop文法における `declaration-value$t を省略可能にした。
（ `774$issue ）
◎
Now that [css-syntax-3] auto-trims whitespace from declaration values, made &lt;declaration-value&gt; optional in the custom property grammar, so that empty variables are still allowed. (Issue 774)
</dd>
	<dd>
類似に、
`var$f 内の空な~fallbackは妥当になるようにした。
◎
Similarly, made empty fallbacks valid in var().
</dd>
	<dd>
"`--^p" ~prop【 2 個の~dashのみ】を将来の~CSSによる利用-用に予約した。
◎
The -- property is reserved for future use by CSS.
</dd>
	<dd>
“`~animationに染まって$いる” の概念を追加した
— ［
~animate不可な~propが，何らかの~animate能に紛れ込む
］ような変数の利用-法を防止するため。
◎
Added concept of "animation-tainted", to prevent non-animatable properties from using a variable to smuggle in some animatability.
</dd>
	<dd>
`無効が保証される値$を定義した
— ~custom~propの初期~値と［
循環による失敗／代入における失敗
］の結果を もっと単直にして、
失敗が代入を通して
— 最終的に~finally~fallbackにより横取りされるまで —
伝播することを許容するため。
◎
Defined the guaranteed-invalid value to make the initial value of custom properties and the result of cycles or substitution failure more straightforward, and allow failure to propagate thru substitutions until finally intercepted by a fallback.
</dd>
	<dd>
循環は、
`算出d値の時点で無効$になる挙動を誘発するものと定義した。
◎
Defined that cycles trigger invalid at computed-value time behavior.
</dd>
	<dd>
変数を`~CSS全域~keyword$に解決することを許容した
（アリになるのは、
当の~keywordを~fallbackとして供した場合に限られる）。
◎
Allowed variables to resolve to a CSS-wide keyword (only possible by providing it as a fallback).
</dd>
	<dd>
`登録-済み~custom~prop$は、
`算出d値の時点で無効$になるときは，~customでない~propの様に動作することを明確化した。
◎
Clarified that registered custom properties act like non-custom properties when they’re invalid at computed-value time.
</dd>
	<dd>
`var$f を伴う下位propは、
その略式~propが直列化-不能になることを誘発するようにした
— `代入待ちの値＠~CSSVAL5#pending-substitution-value$を伴う下位propがすでにそうしていた様に。
◎
Made longhands with var()s also trigger their shorthands to be unserializable, like longhands with pending-substitution values already did.
</dd>
	<dd>
累乗的な代入による攻撃に抗して防御することを~UAに要求した。
◎
Required UAs to defend against exponential substitution attacks.
</dd>
	<dd>
~custom~propの`値^emを直列化する方法を定義した
（それまで、
その名前の直列化~しか指定されてなかった）。
◎
Defined how to serialize the values of custom properties (previously, only the property name’s serialization was specified).
</dd>

	<dt id="changes-20140506">
`2014年 5月 6日 最終~作業草案＠~TR/2014/WD-css-variables-1-20140506/$
からの変更点
◎
5.4. Changes since the May 6 2014 Last Call Working Draft
</dt>
	<dd>
略式~propが変数を利用している場合の，下位propの直列化を定義した。
◎
Serialization of longhands when shorthand uses a variable was defined.
</dd>
	<dd>
~DOM標準【現在は `INFRA$r 】による “大小無視” の定義へ~linkした。
◎
Link to DOM’s definition of "case-sensitive".
</dd>
	<dd>
`lang()$ps と伴に変数を利用して単純な国際-化を行う例を追加した。
◎
Added example of using variables with :lang() to do simple i18n.
</dd>
	<dd>
~custom~propにおける `var$f の利用は、
`var$f 文法に従って妥当でなければナラナイことを明確化した。
◎
Clarified that usage of var() in a custom property must be valid per the var() grammar.
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
何年にもわたり，~CSS変数の夢を生きたまま保ってこられた~CSS~WGの方々
— 特に， `Daniel Glazman^en, `David Hyatt^en 両氏 —
に感謝する。
~mailing~listにて，この仕様の開発に貢献するべく助力された人々
— 特に次に挙げる方々 —
に感謝する：
◎
Many thanks to several people in the CSS Working Group for keeping the dream of variables alive over the years, particularly Daniel Glazman and David Hyatt. Thanks to multiple people on the mailing list for helping contribute to the development of this incarnation of variables, particularly＼
</p>

<div lang="en">
Brian Kardell,
David Baron,
François Remy,
Roland Steiner,
and Shane Stephens.
</div>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p>
この仕様が定義する仕組みは、
作者が制御する~pageの中で，作者~levelの~style付け情報を使い回す以上のことはしない。
そのようなわけで、
新たな~privacyの考慮点はない。
◎
This specification defines a purely author-level mechanism for passing styling information around within a page they control. As such, there are no new privacy considerations.
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p>
`CSS-VALUES-5$r `§ 長過ぎな代入の安全な取扱い＠~CSSVAL5#long-substitution$は、［
`var$f 関数などの “~macro展開” の様な仕組み
］に対し仕掛けられ得る［
昔からある~DoS攻撃
］をとり挙げ，その攻撃に抗する防御を義務付ける。
◎
CSS Values 5 § Safely Handling Overly-Long Substitution calls out a long-standing Denial-of-Service attack that can be mounted against "macro-expansion"-like mechanisms, such as the var() function, and mandates a defense against that attack.
</p>

	</section>
</main></div>
