<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Custom Properties for Cascading Variables Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f': 
	text = `${key}()`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'at': 
	text = `@${key}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	break;
case 'P':
	text = `&lt;${key}&gt;`;
	break;
case 'issue':
	text = `課題 #${key}`;
	href = `~CSSissue/${key}`;
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Custom Properties for Cascading Variables Module Level 1
spec_date:2021-02-26
trans_update:2021-03-01
source_checked:180705
page_state_key:CSS
original_url:https://drafts.csswg.org/css-variables-1/
	abbr_url:CSSVAR
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2021,permissive
trans_1st_pub:2012-07-10


●●class_map
p:property
at:at-rule
f:func
ps:pseudo
css:css
e:element
a:attr
v:value
t:type
P:production
u:unit

●●tag_map
p:code
v:code
f:code
at:code
ps:code
pe:code
t:var
P:code
css:code
e:code
a:code
m:code
I:code
c:code
u:code
em:em

●●original_id_map

cssom-api:cssom

●●mdn_urls
propdef-:CSS/--*

funcdef-var:CSS/var

●●link_map

p.--*:#propdef-
p.all:~CASCADE#propdef-all
p.animation:~CSSANIM#propdef-animation
p.background-color:~CSSBG#propdef-background-color
p.color:~CSSCOLOR#propdef-color
p.display:~CSSDISP#propdef-display
p.font-size:~CSSFONT#propdef-font-size
p.margin-top:~CSSBOX#propdef-margin-top

v.unset:~CASCADE#valdef-all-unset
v.initial:~CASCADE#valdef-all-initial
v.transparent:~CSSCOLOR#valdef-color-transparent
v.none:~CSSDISP#valdef-display-none
v.contents:~CSSDISP#valdef-display-contents

at.media:~CSSCOND#at-ruledef-media
at.keyframes:~CSSANIM#at-ruledef-keyframes

f.var:#funcdef-var
f.calc:~CSSVAL#funcdef-calc

u.em:~CSSVAL#em

ps.root:~SELECTORS4#root-pseudo
ps.lang():~SELECTORS4#lang-pseudo

t.custom-property-name:#typedef-custom-property-name
t.color:~CSSCOLOR#typedef-color
t.declaration-value:~CSSSYN#typedef-declaration-value
t.dashed-ident:~CSSVAL#typedef-dashed-ident

P.bad-string-token:~CSSSYN#typedef-bad-string-token
P.semicolon-token:~CSSSYN#typedef-semicolon-token
P.bad-url-token:~CSSSYN#typedef-bad-url-token
P.delim-token:~CSSSYN#typedef-delim-token
P.)-token:~CSSSYN#tokendef-close-paren
P.]-token:~CSSSYN#tokendef-close-square
P.}-token:~CSSSYN#tokendef-close-curly

m.getPropertyValue():~CSSOM1#dom-cssstyledeclaration-getpropertyvalue
I.CSSStyleDeclaration:~CSSOM1#cssstyledeclaration


	●用語
~custom~prop:#custom-property
~animationに染って:#animation-tainted
算出d値の時点:#_computed-value-time
算出d値の時点で無効:#invalid-at-computed-value-time
無効が保証される値:#guaranteed-invalid-value
代用する:#substitute-a-var
代用-:#substitute-a-var
代用待ちの値:#pending-substitution-value
	代用~値:#_substitution-value

	●用語（CSS
~importantな宣言:~CASCADE#important
継承d~prop:~CASCADE#inherited-property
算出d値:~CASCADE#computed-value
継承d値:~CASCADE#inherited-value
初期~値:~CASCADE#initial-value
指定d値:~CASCADE#specified-value
略式~prop:~CASCADE#shorthand-property
下位prop:~CASCADE#longhand
~cascaded値:~CASCADE#cascaded-value
~cascaded値の処理:~CASCADE#value-stages
~cascade:~CASCADE#cascade

~CSS全域~keyword:~CSSVAL#css-wide-keywords

宣言:~CSSOM1#css-declaration
	宣言~list:~CSSOM1#cssstyledeclaration-declarations
	~CSSSYN#declaration
文字大小区別か:~CSSOM1#css-declaration-case-sensitive-flag
識別子:~CSSSYN#identifier

条件付き~group規則:~CSSCOND#conditional-group-rule
	~animation~prop:~CSSANIM#animation
登録-済み~custom~prop:~CSSPV1#registered-custom-property
全称~構文~定義:~CSSPV1#universal-syntax-definition

	pseudo
	https://drafts.csswg.org/selectors/#root-pseudo

	●用語他
~ASCII大小無視:~INFRA#ascii-case-insensitive
	大小区別:~INFRA#string-is


●●words_table1


●●words_table


	●CSS
cascaded::::カスケード
	~cascadeする:cascading
important:
全域:wide:~
色:color::~

	●構文
dash:
	直列化-法:serializing
文字大小:character case::~

	区別-:sensitive
式:expression:~
括弧類:brackets:~
連結-:concatenate:~

棄てら:throw awayさ:~
禁則:prohibition:~
極めて:extremeに:~
寛容:permissive:~
全称:universal::~

	●条件付き
染って:taintされて::染まって
有向:directed:~
循環的:cyclic::~
	循環~用の:cyclic
循環-:cycle::~
循環:cycle::~
循環依存:cyclic dependencies::~
条件付き:conditional::~
代用-:substitute::~
代用:substitution::~
代用待ちの:pending-substitution::~
	待ち~~状態にある:pending
	あてがう:fill in／go where／given
族:family:~
	設定し直:reset

	●仕様
事実:fact:~
無意味:nonsense:~
無用:useless:~
現実:real-world:~
観点:standpoint:~

判明-:realize:~
明らか:obvious:~
普通の:ordinary:~
	最終~作業草案:Last Call Working Draft
難点:difficulties:~
独特:unique:~

	見つけ難い:difficult-to-spot
	により定義される:-defined
	定義し直す:redefine
	互換になれない:incompatible
	不能:impossible
	-:possible
	~~作業
	体系:scheme
	用途に見合った~~体系的な:informative
	用例:example
	~~問題ない:fine
	多目的:many purposes
	安全弁付き~codeを書ける:defensive coding
	見かけからは~~意味を汲み取れない:seemingly-arbitrary

	〜易く:easier to
	覚え易い:mnemonic
	誤り易い:error-prone
	誤り難く:less error-prone
	誤記:typos
	概ね:more-or-less
	読み:read
	自由な:open-ended
	編集:editing
	従って
	~~容易:amenable to

	●仕様（動詞
集中-:focus:~
給-:supply:~

	~~影響-:effect
	~~指示-:tell
	仕立て上げ:make
	力点を置いて:focus
	防がれ／妨げる:prevent
	対処-:get around
	-:取り込まれ
	導
	利かない:can’t be intelligently
	銘記-:note
	利用箇所
	~~総称され:known collectively
	公開

	●保安
DoS:Denial-of-Service:DoS
macro::::マクロ
	~macro展開:macro-expansion
展開-:expand::~
展開:expansion::~
素朴:naive::~
防御:defense::~
上限:limit:~
仕掛けれ:mountでき:~
課す:imposeする:~
自動で:auto-:~

	使い回す:around within
	引き合いに出す:call out
	抗して:against
	多少高めに:relatively high
	過度に:overly-
	長い:long
	短い:short
	該当する:true
	倍に:doubles
	ほんの一手間:the work of a few minutes by hand
	十億個:billion instances
	自身が定義する:UA-defined
	1000 ~byte:kilobyte
	~~長さ:how long／how large
	昔からある:long-standing
	無さそうに見える:without 〜 seeming
	追加される~levelごと:Every additional level added

	●未分類（動詞
作動-:act:~
調和-:match:~
裏返す:flipする:~
削る:trimする:~

	取り出す:draw
	組み込む:include
	込みで:including
	繋がりの無い:has no connection
	辺で結ぶ:add an edge between
	選んだ:-chosen
	散らばって:scattered throughout
	現れる:appear
	再び直列化-:reserialized
	指す:refer
	記す:write
	取-
	在る
	挙げ:-
	-:生じ
	-:occur
	置-
	行-

	●未分類
検索置換:Find-and-Replace::~

design::::デザイン
theme::::テーマ
component::::コンポーネント
巨大:large:~

翻訳:translations:~
変形n:transformation::変形
背景:background:~

	低い
	俺
	僕
	私
	先祖
	子孫
	大小
	挟んだ:followed by
	数
	青:blue
	大きい:large

	●訳注
	語
	匿名の
	固有の
	優先順位
	捉え方
	意図-
	述べ

	●指示語

	初回の:first
	一群の:set
	残りの部分:the rest
	至る所:elsewhere
	終えた:finally
	最終的:eventually
	以外のもの:anything else besides
	任意:any
	対を成さない:unmatched
	格段に:much
	相当量の:quite a bit of
	箇所
	一箇所:spot／
	類い:sort
	絶えず:ever
	一方が他方の先祖である:higher 〜 lower
	他方:to each other
	一方:while
	側
	同時に:at once
	一括して:at once
	一種:variation
	一種の:some types of
	一部分:part of
	時点
	互い:each other
	〜付き
	以上
	伴う
	元
	先
	出-
	分け
	前
	後
	前者:first one
	後者:second
	単に:usually produces
	単に:simply
	単に:just
	各
	各種
	同様
	囲って
	外へ
	より大きな:larger
	小さな:small
	当の
	形で
	所
	方
	時に
	様
	次
	済む
	無い
	無けれ
	特に
	異なり
	種
	等
	間
	際に
	個
	数個
	最早
	末尾
	段階
	全体
	応じて
	点
	渡って:across
	並び:sequence／-
	全体を通して:throughout
	通して:with／:in terms of
	限ら
	限り
	節
	結果
	に加え:and
	別個:distinct
	類の:sort of
	わずか:mere
	およそ:nearly

●●ref_normative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. CSS Cascading and Inheritance Level 5. 19 January 2021. WD. URL: https://www.w3.org/TR/css-cascade-5/ 
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. CSS Conditional Rules Module Level 3. 8 December 2020. CR. URL: https://www.w3.org/TR/css-conditional-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 18 December 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-PROPERTIES-VALUES-API-1]
    Tab Atkins Jr.; et al. CSS Properties and Values API Level 1. 13 October 2020. WD. URL: https://www.w3.org/TR/css-properties-values-api-1/ 
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 11 November 2020. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 

●●ref_informative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 22 December 2020. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-BOX-4]
    Elika Etemad. CSS Box Model Module Level 4. 21 April 2020. WD. URL: https://www.w3.org/TR/css-box-4/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 12 November 2020. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-EXTENSIONS]
    Tab Atkins Jr.. CSS Extensions. ED. URL: https://drafts.csswg.org/css-extensions/ 
[CSS-FONTS-3]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Custom Properties for Cascading Variables Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-variables-1/
以前のバージョン
	https://www.w3.org/TR/2015/CR-css-variables-1-20151203/
	https://www.w3.org/TR/2014/WD-css-variables-1-20140506/
	https://www.w3.org/TR/2013/WD-css-variables-1-20130620/
	https://www.w3.org/TR/2013/WD-css-variables-20130312/
	https://www.w3.org/TR/2012/WD-css-variables-20120410/

テスト一式
	http://test.csswg.org/suites/css-variables-1_dev/nightly-unstable/
課題追跡
	<a href="https://github.com/w3c/csswg-drafts/labels/css-variables-1">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact">Tab Atkins Jr.</a> (Google)

Suggest an Edit for this Spec
	https://github.com/w3c/csswg-drafts/blob/main/css-variables-1/Overview.bs
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-variables-1

</script>


<!--% style-->

<style>
samp {
	white-space: nowrap;
}

</style>

</head>

<body>

<header>

	<hgroup>
<h1>カスケードする変数用の CSS カスタムプロパティ — CSS Custom Properties for Cascading Variables Module Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p class="p-summary">
この~moduleは、すべての~CSS~propに受容される新たな~primitiveな値~型として，~cascadeする変数（ `cascading variable^en ）を導入し、それらを定義するための~custom~propも導入する。
◎
This module introduces cascading variables as a new primitive value type that is accepted by all CSS properties, and custom properties for defining them.
</p>

~CSSisaLANG

	</section>
	<section id="status">

~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下，この節の内容は、<a href="css-common-ja.html#status">~CSS日本語訳~共通~page</a>／冒頭の仕様~metadataに移譲。】
</p>

	</section>


<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
巨大な文書や~appは（あるいは小さなものですら）、相当量の~CSSを包含し得る。
~CSS~fileの中の値の多くは、同じ~dataを複写することになる。
例えば、色の~~体系を確立して，全体を通して数個の色を再利用している~siteがあったとする。
この~dataを改めることは、~CSS~fileの中に散らばっている（あるいは複数~fileにわたっている）がために，困難で誤り易い~~作業にもなりかねず、また，検索置換も~~容易いとは限らない。
◎
Large documents or applications (and even small ones) can contain quite a bit of CSS. Many of the values in the CSS file will be duplicate data; for example, a site may establish a color scheme and reuse three or four colors throughout the site. Altering this data can be difficult and error-prone, since it’s scattered throughout the CSS file (and possibly across multiple files), and may not be amenable to Find-and-Replace.
</p>

<p>
この~moduleは、`~custom~prop$と~~総称される，作者~定義な~propの族を導入する。
それは、~stylesheet作者が，自身が選んだ名前を伴う~propに任意な値をアテガって、その値を
`var$f 関数を通して，文書~内の至る所にある他の~propに利用できるようにする。
これにより、見かけからは~~意味を汲み取れない値にも，用途に見合った~~体系的な名前を付けられるようになり、巨大な~fileも読み易くなる。
また、`~custom~prop$の中で一箇所の値を変更するだけで，それが定義する変数を利用している箇所すべてに自動的に伝播することになるので、その種の~file編集も格段に容易かつ誤り難くなる。
◎
This module introduces a family of custom author-defined properties known collectively as custom properties, which allow an author to assign arbitrary values to a property with an author-chosen name, and the var() function, which allow an author to then use those values in other properties elsewhere in the document. This makes it easier to read large files, as seemingly-arbitrary values now have informative names, and makes editing such files much easier and less error-prone, as one only has to change the value once, in the custom property, and the change will propagate to all uses of that variable automatically.
</p>

		<section id="values">
<h3 title="Value Definitions">1.1. 値~定義</h3>

<p class="trans-note">【
この節の内容は <a href="css-common-ja.html#values">~CSS日本語訳 共通~page</a>に移譲。
】</p>

		</section>
	</section>
	<section id="defining-variables">
<h2 title="Defining Custom Properties: the --* family of properties">2. ~custom~propを定義する： ~propの族 `--*^p</h2>

<p>
この仕様は、`~custom~prop$と呼ばれる，~~自由に~~拡張可能（ `open-ended^en ）な［
~propの集合
］を定義する。
それらは、他の~prop値の中の `var$f 関数の代用~値
— `var$f を置換することになる値 —
を定義するために利用される。
◎
This specification defines an open-ended set of properties called custom properties, which, among other things, are used to define the substitution value of var() functions.
</p>

<p class="trans-note">【
語 “~~代用（ `substitute^en ）” は、一般に，
“その場限り” の含みがある~~置換を表す
— “~~永続的な” 含みがある “`replace^en” に比して。
】</p>

◎名 `--*@p 【注釈文を見よ】
◎値 `declaration-value$t?
◎初 `無効が保証される値$
◎
the guaranteed-invalid value
◎適 すべての要素
◎継 される
◎百 受容しない
◎算
［
値の中の変数（ `var$f ）は`代用-$された結果の，指定d値
］／`無効が保証される値$
◎
specified value with variables substituted, or the guaranteed-invalid value 
◎順 文法に従う
◎ア 離散的
◎表終

<p>
~UAには、視覚的でないものも含む すべての媒体~上で，この~propを~supportすることが期待される。
◎
User agents are expected to support this property on all media, including non-visual ones.
</p>

<p>
`~custom~prop@
は、 "`--^c" から開始される任意の名前の~propである
— 例えば `--foo^p の様に。
`custom-property-name@t
生成規則がこれに対応する
— それは、 `dashed-ident$t （ 2 個の~dashから開始される，任意の妥当な`識別子$）として定義される。
ただし， "`--^c" 自身は除く
— それは、~CSSによる将来~利用~用に予約される。
`~custom~prop$は、もっぱら作者／利用者から利用されるものである。
~CSSがここに示されるものを超える意味を与えることは決してない。
◎
A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo. The &lt;custom-property-name&gt; production corresponds to this: it’s defined as any &lt;dashed-ident&gt; (a valid identifier that starts with two dashes), except -- itself, which is reserved for future use by CSS. Custom properties are solely for use by authors and users; CSS will never give them a meaning beyond what is presented here.
</p>

<p class="trans-note">【
この名前は、~vendor接頭辞~付きの~prop（例：
`-webkit-foo^p
）から~vendor名を取り除いたもの（例：
`--foo^p
）と捉えることもできる（すなわち、作者~自身が “匿名の~vendor” である）。
そのような捉え方を意図して命名されているのかもしれない。
】</p>

<div class="example">

<p>
~custom~propは、多目的に利用できる変数を定義し，
`var$f 記法で参照される。
例えば，一群の色を一貫して~designに利用する~pageは、それらの色を~custom~propに格納した上で，変数を通して利用できる：
◎
Custom properties define variables, referenced with the var() notation, which can be used for many purposes. For example, a page that consistently uses a small set of colors in its design can store the colors in custom properties and use them with variables:
</p>

<pre class="lang-css">
`root$ps {
  --main-color: #06c;
  --accent-color: #006;
}
/* <span class="comment">
~CSS~fileの残りの部分
◎
The rest of the CSS file
</span> */
#foo h1 {
  `color$p: var(--main-color);
}
</pre>

<p>
覚え易い色の命名により、色~codeの中の見つけ難い誤記は防がれ，~theme色が絶えず変更されるような場合でも、~web~page内のすべての~stylesheetに渡って多数の編集を行わずとも，単純な一箇所（~custom~prop値）の変更に集中すれば済むようになる。
◎
The naming provides a mnemonic for the colors, prevents difficult-to-spot typos in the color codes, and if the theme colors are ever changed, focuses the change on one simple spot (the custom property value) rather than requiring many edits across all stylesheets in the webpage.
</p>

<p class="trans-note">【
`var(--main-color)^v
が参照するのは，［［
それを利用する~prop
］が適用される要素
］上の
`--main-color^p
~propの値になる。
この例では，
`--main-color^p
が文書の~根~要素~上（ `root$ps ）に宣言されているので、その値は，<a href="#as-normal-property" >普通の継承d~propと同様に</a>文書~内のどの要素にも（別の
`--main-color^p
で上書きされない限り）継承され、その結果，どの
`var(--main-color)^v
も値 `#06c^v で代用されることになる。
】</p>

</div>

<p>
他の~CSS~propと異なり、~custom~prop名は`文字大小区別^である。
◎
Unlike other CSS properties, custom property names are case-sensitive.
</p>

<div>

<p class="example">
`--foo^p, `--FOO^p
はどちらも名前として妥当であるが，それらは別個な~propであり、
`var(--foo)^v の利用は前者を指す一方,
`var(--FOO)^v の利用は後者を指すことになる。
◎
While both --foo and --FOO are valid, they are distinct properties - using var(--foo) will refer to the first one, while using var(--FOO) will refer to the second.
</p>

</div>


<p>
~custom~propは，`all$p ~propにより設定し直される<strong>ことはない</strong>。
<span class="note">
将来には、すべての変数を設定し直す~propも定義され得る。
</span>
◎
Custom properties are not reset by the all property. We may define a property in the future that resets all variables.
</p>

<p>
他の任意の~propと同じ意味で、~custom~propにも `~CSS全域~keyword$を利用できる。
◎
The CSS-wide keywords can be used in custom properties, with the same meaning as in any another property.
</p>

<p class="note">注記：
すなわち それらは、通常通り`~cascaded値$の時点で解釈され，~custom~prop値のように保全されることはない†。
したがって，対応する変数が解決される時点で代用されることもない。
◎
Note: That is, they’re interpreted at cascaded-value time as normal, and are not preserved as the custom property’s value, and thus are not substituted in by the corresponding variable.
</p>

<div class="trans-note">
<p>【†
すなわち，~custom~propに対する全域~keyword値は、 `var$f 関数が解決される前
— 算出d値を得る前 —
の段階で，`指定d値$（すなわち，初期~値または継承d値）にされる。
例えば，次の~stylesheet：
</p>

<pre class="lang-css">
p {
  --foo: inherit;
  color: var(--foo);
}
</pre>

<p>
における
`var(--foo)^v は、［
`inherit^v `ではなく^em，
`--foo^p が継承する値
］で代用されることになる。
したがって、
`p^e 要素の `color^p
は，その先祖の［
`color^p `ではなく^em,
`--foo^p 
］~propの値をとることになる。
】</p>
</div>

<p class="note">注記：
この~moduleは、 “変数” を作成するための， `var$f による`~custom~prop$の利用に力点を置いているが、~scriptから構文解析-／作動されるような，実際の~custom~propとしても利用し得る。
CSS Extensions 仕様
`CSS-EXTENSIONS$r
が、これらの利用事例を拡げ，より利用し易くするものと期待されている。
◎
Note: While this module focuses on the use of custom properties with the var() function to create “variables”, they can also be used as actual custom properties, parsed by and acted on by script. It’s expected that the CSS Extensions spec [CSS-EXTENSIONS] will expand on these use-cases and make them easier to do.
</p>

<p id="as-normal-property">
~custom~propは “普通の” ~propであり，どの要素~上にも宣言できる。
それは、通常の継承と~cascade規則に従って解決され，
`media$at その他の`条件付き~group規則$にも仕立て上げれる。
また、~HTMLの `style^a 属性の中でも利用でき，
CSSOM を利用して読取る／設定することもできる，等々…。
◎
Custom properties are ordinary properties, so they can be declared on any element, are resolved with the normal inheritance and cascade rules, can be made conditional with @media and other conditional rules, can be used in HTML’s style attribute, can be read or set using the CSSOM, etc.
</p>

<p>
特に、それらは遷移させたり~animateさせることすらできる
— ただし、~UAには，それらの内容を解釈するすべがないので、他の，補間が利かない値~pairに対するときと同様に、常に，
“50% の所で裏返す”
様なふるまいになる。
また、 <a class="css">@keyframes</a> 規則の中で利用される
【宣言される】
どの`~custom~prop$も，
`~animationに染って@
いるとされ、各種~animation~prop（ `animation-*^p ）の中で `var$f 関数を介して参照されたときの扱われ方に影響する。
◎
Notably, they can even be transitioned or animated, but since the UA has no way to interpret their contents, they always use the "flips at 50%" behavior that is used for any other pair of values that can’t be intelligently interpolated. However, any custom property used in a @keyframes rule becomes animation-tainted, which affects how it is treated when referred to via the var() function in an animation property.
</p>

<div class="example">
<p>
次の~style規則：
◎
This style rule:
</p>

<pre class="lang-css">
:root {
  --header-color: #06c;
}
</pre>

<p>
は、根~要素~上に名前 `--header-color^p の`~custom~prop$を宣言し，値
"`#06c^v" をアテガう。
この~propは、文書の残りの部分の要素に継承される。
その値は `var$f 関数を通して参照できるようになる：
◎
declares a custom property named --header-color on the root element, and assigns to it the value "#06c". This property is then inherited to the elements in the rest of the document. Its value can be referenced with the var() function:
</p>

<pre class="lang-css">
h1 { `background-color$p: var(--header-color); }
</pre>

<p>
この規則は、
<samp class="css">`background-color^p: `#06c^v;</samp>
と記すことに等価であるが、変数~名から色の用途が明瞭になることに加え、根~要素~上の
`--header-color^p
~propを変更すれば，文書~内の他の要素~上で利用されているすべての
`var(--header-color)^v
が，一括して更新される。
◎
The preceding rule is equivalent to writing background-color: #06c;, except that the variable name makes the origin of the color clearer, and if var(--header-color) is used on other elements in the document, all of the uses can be updated at once by changing the --header-color property on the root element.
</p>

</div>

<div class="example">
<p>
同じ名前の`~custom~prop$が複数回 宣言されている場合、標準な~cascade規則を利用して解決される。
変数は常に，同じ要素~上に結付けられている~custom~propの`算出d値$から値を取り出す：
◎
If a custom property is declared multiple times, the standard cascade rules help resolve it. Variables always draw from the computed value of the associated custom property on the same element:
</p>

<pre class="lang-css">
:root { --color: blue; }
div { --color: green; }
#alert { --color: red; }
* { color: var(--color); }
</pre>

<pre class="lang-html">
&lt;p&gt;僕は根~要素から `blue^v を継承しています。&lt;/p&gt;
&lt;div&gt;俺には `green^v が直に設定されている。&lt;/div&gt;
&lt;div id='alert'&gt;
  私は `red^v が直に設定されているわ。
  &lt;p&gt;私も `red^v だけど、継承なんです。&lt;/p&gt;
&lt;/div&gt;
◎
&lt;p&gt;I inherited blue from the root element!&lt;/p&gt;
&lt;div&gt;I got green set directly on me!&lt;/div&gt;
&lt;div id='alert'&gt;
  While I got red set directly on me!
  &lt;p&gt;I’m red too, because of inheritance!&lt;/p&gt;
&lt;/div&gt;
</pre>


</div>

<div class="example">
<p>
現実における`~custom~prop$の用例として、文字列を その利用箇所から容易に外へ分離して，国際-化の保守を援助することが挙げられる：
◎
A real-world example of custom property usage is easily separating out strings from where they’re used, to aid in maintenance of internationalization:
</p>

<pre class="lang-css">
:root,
:root:lang(en) {--external-link: "external link";}
:root:lang(de) {--external-link: "externer Link";}
:root:lang(ja) {--external-link: "~~外部~~リンク";}

a[href^="http"]::after {
  content: " (" var(--external-link) ")"
}
</pre>

<p>
変数の宣言を別~fileに分けて，翻訳の保守をより単純にすることもできる。
◎
The variable declarations can even be kept in a separate file, to make maintaining the translations simpler.
</p>
</div>

		<section id="syntax">
<h3 title="Custom Property Value Syntax">2.1. ~custom~prop値の構文</h3>

<div >
<p>
`~custom~prop$に許容される構文は極めて寛容にされている。
`declaration-value$t 生成規則は、 1 個~以上の~tokenの並びであって, 次に挙げる~tokenは包含しないような， `任意の^em並びに合致する：
</p>

<ul ><li>`bad-string-token$P
</li><li>`bad-url-token$P
</li><li>対を成さない括弧類： `)-token$P, `]-token$P, `}-token$P
</li><li>~top-levelの `semicolon-token$P
</li><li>~top-levelの `delim-token$P のうち，その.値に "`!^c" を伴うもの
</li></ul>

◎
The allowed syntax for custom properties is extremely permissive. The &lt;declaration-value&gt; production matches any sequence of one or more tokens, so long as the sequence does not contain &lt;bad-string-token&gt;, &lt;bad-url-token&gt;, unmatched &lt;)-token&gt;, &lt;]-token&gt;, or &lt;}-token&gt;, or top-level &lt;semicolon-token&gt; tokens or &lt;delim-token&gt; tokens with a value of "!".
</div>

<p>
加えて、`~custom~prop$の値が `var$f 参照を包含している場合、その `var$f 参照は，指定された `var$f 文法に則って妥当でなければナラナイ。
さもなければ、`~custom~prop$は無効になり，無視するモノトスル。
◎
In addition, if the value of a custom property contains a var() reference, the var() reference must be valid according to the specified var() grammar. If not, the custom property is invalid and must be ignored.
</p>

<p class="note">注記：
この定義と一般~CSS構文~規則から、~custom~prop値は，対を成さない引用符や括弧類を決して含まず、再び直列化される際には，それを囲っている~style規則などの, より大きな構文~構成子には~~影響しないことになる。
◎
Note: This definition, along with the general CSS syntax rules, implies that a custom property value never includes an unmatched quote or bracket, and so cannot have any effect on larger syntax constructs, like the enclosing style rule, when reserialized.
</p>

<p class="note">注記：
~custom~propは末尾に `!important^css を伴い得るが、これは~CSS構文解析器†により~propの値から自動的に除去された上で，~custom~propを~CSS~cascadeにおいて`~importantな宣言$にする。
言い換えれば、~top-levelの文字 "`!^c" の禁則は，
`!important^css の利用を妨げるものではない。
`!important^css は構文を検査する前に除去されるので。
◎
Note: Custom properties can contain a trailing !important, but this is automatically removed from the property’s value by the CSS parser, and makes the custom property "important" in the CSS cascade. In other words, the prohibition on top-level "!" characters does not prevent !important from being used, as the !important is removed before syntax checking happens.
</p>

<p class="trans-note">【†
<a href="~CSSSYN">CSS Syntax 仕様</a>
にて定義される，~CSS構文解析器（個々の~CSS仕様に特有な構文を~~解析するものではなく，その前~段階の一般~構文を~~解析する構文解析器）を指す。
この仕様に現れる語 構文解析-の多くも，同様。
】</p>

<div class="example">

<p>
例えば，次のものは妥当な~custom~propである：
◎
For example, the following is a valid custom property:
</p>

<pre class="lang-css">
--foo: if(x &gt; 5) this.width = 10;
</pre>

<p>
この値は、通常のどの~propの中でも無効になるので，`変数^emとしては明らかに無用であるが、~JSにより読取る／動作させるような用途はあり得る。
◎
While this value is obviously useless as a variable, as it would be invalid in any normal property, it might be read and acted on by JavaScript.
</p>

</div>

<p>
［
~custom~propの値, および
~custom~propの値で代用される `var$f 関数の値
］の文字大小は、`区別され^em，作者が与えた元々の文字大小を保全するモノトスル。
（多くの~CSS値は，`~ASCII大小無視$であり、~UAは それらを大小いずれかに “正準-化” できるが、~custom~propには それは許容されない。）
◎
The values of custom properties, and the values of var() functions substituted into custom properties, are case-sensitive, and must be preserved in their original author-given casing. (Many CSS values are ASCII case-insensitive, which user agents can take advantage of by "canonicalizing" them into a single casing, but that isn’t allowed for custom properties.)
</p>

		</section>
		<section id="guaranteed-invalid">
<h3 title="Guaranteed-Invalid Values">2.2. 無効が保証される値</h3>

<p>
`~custom~prop$の初期~値は、
`無効が保証される値@
である。
<a href="#using-variables">§ ~cascade変数の利用-法</a>
に定義されるように、
`var$f を利用して，これを値にとる`~custom~prop$で代用すると、それを参照している~propは，`算出d値の時点で無効$になる。
◎
The initial value of a custom property is a guaranteed-invalid value. As defined in § 3 Using Cascading Variables: the var() notation, using var() to substitute a custom property with this as its value makes the property referencing it invalid at computed-value time.
</p>

<p>
この値が直列化されるときは，空~文字列になるが、~custom~propの中に
— `--foo: ;^css の様に —
実際に空~値を書いても，妥当な（空）値になり、`無効が保証される値$にはならない。
理由が何であれ，変数を`無効が保証される値$に手動で設定し直したいと求めるならば、~keyword `initial$v 利用して行える。
◎
This value serializes as the empty string, but actually writing an empty value into a custom property, like --foo: ;, is a valid (empty) value, not the guaranteed-invalid value. If, for whatever reason, one wants to manually reset a variable to the guaranteed-invalid value, using the keyword initial will do this.
</p>

		</section>
		<section id="cycles">
<h3 title="Resolving Dependency Cycles">2.3. 循環依存の解決-法</h3>

<p>
`~custom~prop$は、ほとんどの所では，評価されないままにされるが、その値の中の `var$f 関数の評価-は許容されている。
そのため、`~custom~prop$自身が，自身を指す `var$f を利用していたり、複数の`~custom~prop$のそれぞれが，他方を指している場合に、循環依存が生じ得る。
◎
Custom properties are left almost entirely unevaluated, except that they allow and evaluate the var() function in their value. This can create cyclic dependencies where a custom property uses a var() referring to itself, or two or more custom properties each attempt to refer to each other.
</p>

<p>
各~要素に対し、各`~custom~prop$に対応する~nodeからなる有向~依存関係~graphを，次のように作成する
⇒
ある`~custom~prop$ %prop1 の値が，ある`~custom~prop$ %prop2
<span class="note">
（ %prop1 と同じでもよい）
</span>
を指している `var$f 関数を包含している（ `var$f の~fallback引数も込みで）ならば、
%prop1 から %prop2 へ辺で結ぶ。
◎
For each element, create a directed dependency graph, containing nodes for each custom property. If the value of a custom property prop contains a var() function referring to the property var (including in the fallback argument of var()), add an edge between prop and the var. Edges are possible from a custom property to itself.
</p>

<p>
この依存関係~graph内に循環がある場合、その循環を成す どの`~custom~prop$も，`算出d値の時点で無効$になる。
◎
If there is a cycle in the dependency graph, all the custom properties in the cycle are invalid at computed-value time.
</p>

<p class="note">注記：
定義-済み~propは、ある［
依存関係の循環
］に関与する場合には，［
その値~内に無効な変数があることにより，`算出d値の時点で無効$になる
］か，または循環~用に自前の取扱いを定義する（ `em$u 値を利用している `font-size$p の様に）。
それらは、~custom~propの様に`無効が保証される値$には算出されない。
◎
Note: Defined properties that participate in a dependency cycle either end up with invalid variables in their value (becoming invalid at computed-value time), or define their own cyclic handling (like font-size using em values). They do not computed to the guaranteed-invalid value like custom properties do.
</p>

<div class="example">
<p>
変数を安全に利用する~custom~propの例を示す：
◎
This example shows a custom property safely using a variable:
</p>

<pre class="lang-css">
:root {
  --main-color: #c06;
  --accent-background: linear-gradient(
      to top, var(--main-color), white
  );
}
</pre>

<p>
`--accent-background^p ~propは（あるいは
`var(--main-color)^v を利用する他の~propも同様に）、
`--main-color^p ~propが変更されたときに自動的に更新されることになる。
◎
The --accent-background property (along with any other properties that use var(--main-color)) will automatically update when the --main-color property is changed.
</p>

</div>

	<div class="example invalid-example">
<p>
他方，次のものは、互いに依存する変数の無効な~instanceの例になる：
◎
On the other hand, this example shows an invalid instance of variables depending on each other:
</p>

<pre class="lang-css">
:root {
  --one: calc(var(--two) + 20px);
  --two: calc(var(--one) - 20px);
}
</pre>

<p>
`--one^p, `--two^p
両者とも，今や`算出d値の時点で無効$になり、長さでなく`無効が保証される値$に算出される。
◎
Both --one and --two are now invalid at computed-value time, and compute to the guaranteed-invalid value rather than lengths.
</p>

</div>

<p>
重要な点として、`~custom~prop$の値の中のどの `var$f 関数も，`算出d値の時点$で解決される
【`代用-$される】
— したがって、その値が継承されるときには，`すでに^em解決されている —
ことを銘記しておく。
一般に，循環依存が生じるのは、同じ要素~上の複数の~custom~propが互いを指すときに限られる。
要素~treeの中で，一方が他方の先祖である 2 つの要素~上に定義された~custom~propの間で参照が循環することは、決してない。
◎
It is important to note that custom properties resolve any var() functions in their values at computed-value time, which occurs before the value is inherited. In general, cyclic dependencies occur only when multiple custom properties on the same element refer to each other; custom properties defined on elements higher in the element tree can never cause a cyclic reference with properties defined on elements lower in the element tree.
</p>

<p class="trans-note">【
`算出d値の時点@
— 明示的には定義されていないが、`~cascaded値の処理$における，`算出d値$を得る段階を指すと見受けられる。
】</p>

<div class="example">
<p>
例えば，次の構造における、３個の~custom~propが循環することは<strong>ない</strong>。
すべて妥当な変数を定義する：
◎
For example, given the following structure, these custom properties are not cyclic, and all define valid variables:
</p>

<pre class="lang-css">
&lt;one&gt;&lt;two&gt;&lt;three /&gt;&lt;/two&gt;&lt;/one&gt;
&lt;style&gt;
one   { --foo: 10px; }
two   { --bar: calc(var(--foo) + 10px); }
three { --foo: calc(var(--bar) + 10px); }
&lt;/style&gt;
</pre>

<p>
`one^e 要素は、 `--foo^p に対する値を定義する。
`two^e 要素は、この値を継承することに加え， `foo^css 変数を利用して
`--bar^p に値をアテガう。
最後に， `three^e 要素は、［
変数が`代用された後の^em
`--bar^p 値
］を継承する（言い換えれば、値 `calc(10px + 10px)^v を見る）。
しかる後，その値を通して自身の `--foo^p を定義し直す。
`three^e が継承する `--bar^p 値は，
`one^e 上で定義される `--foo^p ~propへの参照をもはや包含していないので、
`var(--bar)^v 変数を利用して `--foo^p を定義することは循環的ではなく，（通常の~propの中で変数として参照されるときは）実際に最終的に `30px^v に解決される値を定義する。
◎
The &lt;one&gt; element defines a value for --foo. The &lt;two&gt; element inherits this value, and additionally assigns a value to --bar using the foo variable. Finally, the &lt;three&gt; element inherits the --bar value after variable substitution (in other words, it sees the value calc(10px + 10px)), and then redefines --foo in terms of that value. Since the value it inherited for --bar no longer contains a reference to the --foo property defined on &lt;one&gt;, defining --foo using the var(--bar) variable is not cyclic, and actually defines a value that will eventually (when referenced as a variable in a normal property) resolve to 30px.
</p>

</div>


		</section>
	</section>
	<section id="using-variables">
<h2 title="Using Cascading Variables: the var() notation">3. ~cascade変数の利用-法： `var^f 記法</h2>

<p>
`~custom~prop$は、 `var$f 関数を通して，別の~propの中で`代用-$され得る値を与える。
`var$f の構文は：
◎
The value of a custom property can be substituted into the value of another property with the var() function. The syntax of var() is:
</p>

<pre class="prod">
`var@f = var( `custom-property-name$t, `declaration-value$t? )
</pre>

<p>
要素~上の どの~propに対しても，その値を成す任意の部分に代えて、この `var$f 関数を利用できる。
`var$f 関数を、~prop値~以外
— ~prop名や選択子など —
に利用することはできない（そのようにしても、単に無効な構文になるか，変数とは繋がりの無い値になるだけである）。
◎
The var() function can be used in place of any part of a value in any property on an element. The var() function can not be used as property names, selectors, or anything else besides property values. (Doing so usually produces invalid syntax, or else a value whose meaning has no connection to the variable.)
</p>


<div class="example">

<p>
次の~codeは、~prop名として 変数の利用を試みるので，不正な例になる：
◎
For example, the following code incorrectly attempts to use a variable as a property name:
</p>

<pre class="lang-css">
.foo {
  --side: margin-top;
  var(--side): 20px;
}
</pre>

<p>
これは
<samp class="css">`margin-top^p: `20px^v;</samp>
を設定することに等価`でない^em。
2 個目の宣言は、単に無効な~prop名として構文~errorにされ，棄てられる。
◎
This is not equivalent to setting margin-top: 20px;. Instead, the second declaration is simply thrown away as a syntax error for having an invalid property name.
</p>
</div>

<p>
関数の最初の引数が、代用~値†を~~供する`~custom~prop$の，名前を与える。
関数に 2 個目の引数が供されている場合、それが~fallback値になり，参照された`~custom~prop$が`無効が保証される値$をとるときの代用~値として利用される。
◎
The first argument to the function is the name of the custom property to be substituted. The second argument to the function, if provided, is a fallback value, which is used as the substitution value when the value of the referenced custom property is the guaranteed-invalid value.
</p>

<p class="trans-note">【†
明示的に述べられていないが、代用~値を~~供するのは，［［
`var$f を値に利用する~prop
］が適用される要素
］上の~custom~propの値になる。
】</p>

<p class="note">注記：
~fallbackの構文でも、`~custom~prop$のそれと同様に，~commaが許容される。
例えば，
`var(--foo, red, blue)^v
は、~fallback
`red, blue^v
を定義する。
すなわち，最初の~commaと関数の末尾までの間のすべてが、~fallback値と見なされる。
◎
Note: The syntax of the fallback, like that of custom properties, allows commas. For example, var(--foo, red, blue) defines a fallback of red, blue; that is, anything between the first comma and the end of the function is considered a fallback value.
</p>

<div class="example">
<p>
~fallback値により、一種の安全弁付き~code（ `defensive coding^en ）を書けるようになる。
例えば，より大きな~appに組み込むための~componentを作成する場合、変数をその~style付けに利用すれば，~componentを~appの他の部分と調和させることも容易になる。
◎
The fallback value allows for some types of defensive coding. For example, an author may create a component intended to be included in a larger application, and use variables to style it so that it’s easy for the author of the larger application to theme the component to match the rest of the app.
</p>

<p>
~fallbackが無ければ、~app作者は，~componentが利用するすべての変数に値を給さなければならなくなる。
~fallbackがあれば，~component作者が既定の値を給しておけるようになり、~app作者は，上書きしたい変数だけ値を給すれば済むようになる。
◎
Without fallback, the app author must supply a value for every variable that your component uses. With fallback, the component author can supply defaults, so the app author only needs to supply values for the variables they wish to override.
</p>

<pre class="lang-css">
/* <span class="comment">
~componentの~style
◎
In the component’s style:
</span> */
.component .header { 
  color: var(--header-color, blue); 
}
.component .text { 
  color: var(--text-color, black); 
}
/* <span class="comment">
より大きな~appの~style：
◎
In the larger application’s style:
</span> */
.component {
  --text-color: #080;
  /* <span class="comment">
`--header-color^p は設定されないので~fallback値の青（ `blue^v ）のまま。
◎
header-color isn’t set, and so remains blue, the fallback value
</span> */
}
</pre>

</div>

<p>
~propが `var$f 関数を包含していて，そのどれもが構文として妥当である場合、その~propは，構文解析-時には妥当であると見做すモノトスル。
構文が検査されるのは、
`var$f 関数を`代用-$した後の，`算出d値の時点$である。
◎
If a property contains one or more var() functions, and those functions are syntactically valid, the entire property’s grammar must be assumed to be valid at parse time. It is only syntax-checked at computed-value time, after var() functions have been substituted.
</p>

<p>
<!-- 
【要素~上の】
-->
~prop %~prop の値の中の `var$f 関数 %関数 を
`代用する@
（ `substitute^en する）ときは：
◎
To substitute a var() in a property’s value:
</p>

<ol>
	<li>
%関数 の最初の引数を名前に持つ 要素~上の`~custom~prop$を以下 %custom とする。
</li>
	<li>
<p>
%custom は`~animationに染って$いる, かつ
%~prop は次のいずれかに該当する場合、以下，
%custom は初期~値をとるものと扱う：
◎
If the custom property named by the first argument to the var() function is animation-tainted, and the var() function is being used in:
</p>
		<ul>
			<li>
~animation~prop（ `animation$p ~propまたはその`下位prop$ ）である。
◎
the animation property or one of its longhands,
</li>
			<li>
`display$p ~propである，かつ
代用~後に要素の~box生成を抑止する値をとることになる（ `none$v や `contents$v など）。
◎
the display property, such that after substitution the property would have a value that suppresses the element’s box (such as none or contents)
◎
treat the custom property as having its initial value for the rest of this algorithm.
</li>
		</ul>
	</li>
	<li>
%custom が，初期~値でない値をとる場合、 %関数 をその値に置換する。
◎
If the value of the custom property named by the first argument to the var() function is anything but the initial value, replace the var() function by the value of the corresponding custom property.
</li>
	<li>
他の場合、~fallback値が %関数 の 2 個目の引数として与えられているならば，
%関数 を その~fallback値に置換する。
このとき、その~fallback値の中にも `var$f 参照が在るならば、それらも`代用する$。
◎
Otherwise, if the var() function has a fallback value as its second argument, replace the var() function by the fallback value. If there are any var() references in the fallback, substitute them as well.
</li>
	<li>
<p>
他の場合、 %~prop は，`算出d値の時点で無効$になる。
◎
Otherwise, the property containing the var() function is invalid at computed-value time.
</p>

<p class="trans-note">【
%custom が当の要素や そのどの先祖にも宣言されていない場合など
— <a href="#as-normal-property" >普通の継承d~propと同様に</a>，
%custom は初期~値をとると解釈されることになるので。
】</p>

<p class="note">注記：
%~prop を`算出d値の時点で無効$にするものは、他にもあり得る。
◎
Note: Other things can also make a property invalid at computed-value time.
</p>
	</li>
</ol>

<div class="note">
<p>注記：
`var$f が`代用-$されるのは、~CSS~token `css-syntax-3$r の~levelであり，~textな~levelではない
— 一部分だけ変数から供されるような単独の~tokenを築くことはできない：
◎
Note that var() substitution takes place at the level of CSS tokens [css-syntax-3], not at a textual level; you can’t build up a single token where part of it is provided by a variable:
</p>

<pre class="lang-css">
.foo {
  --gap: 20;
  margin-top: var(--gap)px;
}
</pre>

<p>
これは
<samp class="css">`margin-top^p: `20px^v;</samp>
（長さ）を設定することに等価`ではない^em。
<samp class="css">`margin-top^p: `20 px^v;</samp>
（値は、~spaceを挟んだ 数と識別子の並びからなる）と等価になり，単に `margin-top$p ~propに対する無効な値になる。
このような場合、 `calc$f 式を利用すれば，同じものを妥当に得られる — 次の様に：
◎
This is not equivalent to setting margin-top: 20px; (a length). Instead, it’s equivalent to margin-top: 20 px; (a number followed by an ident), which is simply an invalid value for the margin-top property. Note, though, that calc() can be used to validly achieve the same thing, like so:
</p>

<pre class="lang-css">
.foo {
  --gap: 20;
  margin-top: calc(var(--gap) * 1px);
}
</pre>

</div>

<p>
`var$f 関数は、`算出d値の時点$で`代用-$される。
宣言の中のすべての `var$f 関数が代用された時点で，宣言-済みの文法に合致しないならば、その宣言は `算出d値の時点で無効$になる。
◎
var() functions are substituted at computed-value time. If a declaration, once all var() functions are substituted in, does not match its declared grammar, the declaration is invalid at computed-value time.
</p>

<div class="example">
<p>
例えば，次の用法は、構文の観点からは~~問題ないが、変数が代用された後は無意味な結果になる：
◎
For example, the following usage is fine from a syntax standpoint, but results in nonsense when the variable is substituted in:
</p>

<pre class="lang-css">
:root { --looks-valid: 20px; }
p { background-color: var(--looks-valid); }
</pre>

<p>
`20px^v は `background-color$p
の値としては無効なので、この~propの~instanceは，代わりに
`transparent^v （ `background-color$p に対する`初期~値$）に算出される。
◎
Since 20px is an invalid value for background-color, this instance of the property computes to transparent (the initial value for background-color) instead.
</p>

<p>
~propが
`color$p
など，既定で継承されるものならば、`初期~値$ではなく`継承d値$に算出される。
◎
If the property was one that’s inherited by default, such as color, it would compute to the inherited value rather than the initial value.
</p>

</div>

		<section id="invalid-variables">
<h3 title="Invalid Variables">3.1. 無効な変数</h3>

<p>
`~custom~prop$が`無効が保証される値$をとる場合、 `var$f 関数による代用に利用できなくなる。
そのような場合、妥当な~fallbackが指定されていない限り，宣言は`算出d値の時点で無効$になる。
◎
When a custom property’s value is the guaranteed-invalid value, var() functions cannot use it for substitution. Attempting to do so makes the declaration invalid at computed-value time, unless a valid fallback is specified.
</p>

<p>
上で説明したように，宣言は，それが［
`無効が保証される値$をとる`~custom~prop$を参照する `var$f
］を包含する場合は
`算出d値の時点で無効@
になる。
あるいは，それが妥当な`~custom~prop$を利用していても、［
当の~propの値が，その中の `var$f 関数が代用された後に妥当でなくなる場合
］にも無効になる。
これが起きた場合、当の~prop %~prop の`算出d値$は，次に従って与えられる：
◎
A declaration can be invalid at computed-value time if it contains a var() that references a custom property with the guaranteed-invalid value, as explained above, or if it uses a valid custom property, but the property value, after substituting its var() functions, is invalid. When this happens, the computed value is one of the following depending on the property’s type:
</p>
<dl class="switch">
	<dt>
%~prop は登録-済みでない`~custom~prop$である場合
◎
The property is a non-registered custom property
</dt>
	<dt>
%~prop は`全称~構文~定義$を伴う`登録-済み~custom~prop$である場合
◎
The property is a registered custom property with universal syntax
</dt>
	<dd>
算出d値は、`無効が保証される値$になる。
◎
The computed value is the guaranteed-invalid value.
</dd>

	<dt>
他の場合
◎
Otherwise
</dt>
	<dd>
算出d値は、［
%~prop は`継承d~prop$であるならば，その`継承d値$／
~ELSE_ %~prop の`初期~値$
］になる
— %~prop の値として `unset$v ~keywordが指定されていたかのように。
◎
Either the property’s inherited value or its initial value depending on whether the property is inherited or not, respectively, as if the property’s value had been specified as the unset keyword.
</dd>
</dl>

<div class="example">
<p>
例えば，次の~codeでは：
◎
For example, in the following code:
</p>

<pre class="lang-css">
:root { --not-a-color: 20px; }
p { background-color: red; }
p { background-color: var(--not-a-color); }
</pre>

<p>
`p^e 要素の背景は、赤（ `red^v ）ではなく，透明
— `background-color$p の`初期~値$ `transparent$v —
になる。
`~custom~prop$自身が `unset$v されたり，無効な `var$f 関数を包含している場合も同じことが生じる。
◎
the &lt;p&gt; elements will have transparent backgrounds (the initial value for background-color), rather than red backgrounds. The same would happen if the custom property itself was unset, or contained an invalid var() function.
</p>

<p>
このことと，作者が単に~stylesheetに直に
<samp class="css">`background-color^p: `20px^v;</samp>
と記した場合のふるまいとの相違に注意されたし。
それは通常の構文~errorなので，その規則は
【<a href="~CASCADE#filtering" >~cascadeの最初の段階</a>で】
破棄され、その結果
<samp class="css">`background-color^p: `red^v;</samp>
規則が代わりに利用されることになる。
◎
Note the difference between this and what happens if the author had just written background-color: 20px directly in their stylesheet - that would be a normal syntax error, which would cause the rule to be discarded, so the background-color: red rule would be used instead.
</p>

</div>

<p class="note">注記：
`算出d値の時点で無効$の概念は、 `var$f 関数が他の構文~errorと異なり， “早期に失敗させ” 得ないがためにある。
~prop値が~UAから無効なものと判明した時点では、
【より優先順位の低い】
他の`~cascaded値$は，すでに棄てられている。
◎
Note: The invalid at computed-value time concept exists because variables can’t "fail early" like other syntax errors can, so by the time the user agent realizes a property value is invalid, it’s already thrown away the other cascaded values.
</p>
		</section>
		<section id="variables-in-shorthands">

<h3 title="Variables in Shorthand Properties">3.2. 略式~propにおける変数</h3>

<p>
`略式~prop$における `var$f 関数の利用には、独特な難点がある。
◎
The use of var() functions in shorthand properties presents some unique difficulties.
</p>

<p>
~customでない~propに対しては、略式~propの値は，構文解析-時に 対応する`下位prop$の成分に分離され、それらの下位propが`~cascade$に取り込まれた上で，~~元の略式~propの方は概ね破棄される。
しかしながら，略式~propに `var$f 関数が利用された場合、どこへどの値があてがうか~~指示できなくなる
— 事実，単独の `var$f 関数が 同時に複数の下位propの値の中で代用されることもあるので、構文解析-時には分離-不能な場合もある。
◎
For non-custom properties, the value of a shorthand property is separated out into its component longhand properties at parse time, and then the longhands themselves participate in the cascade, with the shorthand more-or-less discarded. If a var() functions is used in a shorthand, however, one can’t tell what values are meant to go where; it may in fact be impossible to separate it out at parse time, as a single var() function may substitute in the value of several longhands at once.
</p>

<p>
これに~~対処するため、実装は，次を行うモノトスル：
◎
To get around this, implementations must＼
</p>

<ul>
	<li>
下位propには、
`代用待ちの値@
をあてがう
— これは、作者からは観測-不能な，特別な値であり，［
当の略式~propは `var$f 関数を包含しているため、下位propの値は，
`var$f 関数が代用されるまで待ち~~状態にある
］ことを指示する。
◎
fill in longhands with a special, unobservable-to-authors pending-substitution value that indicates the shorthand contains a variable, and thus the longhand’s value is pending variable substitution.＼
</li>
	<li>
`代用待ちの値$は、通常通り~cascadeさせる。
◎
This value must then be cascaded as normal, and＼
</li>
	<li>
算出d値の時点で， `var$f 関数が代用され終えた所で、略式~propの値を構文解析して，下位propに対し適切な値をあてがう。
◎
at computed-value time, after var() functions are finally substituted in, the shorthand must be parsed and the longhands must be given their appropriate values at that point.
</li>
</ul>

<p>
`代用待ちの値$は、~APIによる観測-が許容される所では，空~文字列に直列化するモノトスル。
◎
Pending-substitution values must be serialized as the empty string, if an API allows them to be observed.
</p>

<p>
同様に，略式~propを直列化するときは
— `CSSOM$r は，対応する各 下位propの値を適切に連結するよう定義しているが、それに代えて —
［
明示的な `var$f 関数を伴って指定されているならば、 `var^f を包含していた元の値のまま／
他の場合，いずれかの下位propに`代用待ちの値$があてがわれているならば、空~文字列
］に直列化するモノトスル。
◎
Similarly, while [CSSOM] defines that shorthand properties are serialized by appropriately concatenating the values of their corresponding longhands, shorthands that are specified with explicit var() functions must serialize to the original, var()-containing value. For other shorthands, if any of the longhand subproperties for that shorthand have pending-substitution values then the serialized value of the shorthand must be the empty string.
</p>

		</section>
		<section id="long-variables">
<h3 title="Safely Handling Overly-Long Variables">3.3. 過度に長い変数の安全な取扱い</h3>

<p>
素朴に実装された `var$f 関数は、 “`billion laughs^en 攻撃” 【十億の笑い】の一種に利用できる：
◎
Naively implemented, var() functions can be used in a variation of the "billion laughs attack":
</p>

<div class="example">

<pre class="lang-css">
.foo {
  --prop1: lol; /* 笑 */
  --prop2: var(--prop1) var(--prop1);
  --prop3: var(--prop2) var(--prop2);
  --prop4: var(--prop3) var(--prop3);
  /* etc */
}
</pre>

<p>
この短い例では、`--prop4^p の算出d値は、
`lol lol lol lol lol lol lol lol^v
になり，元の `lol^v の複製を 8 個 包含する。
追加される~levelごとに，識別子の個数は倍になり、ほんの一手間，わずか 30 ~levelに拡張するだけで， `--prop30^p が包含する識別子は `およそ十億個^emになる。
◎
In this short example, --prop4’s computed value is lol lol lol lol lol lol lol lol, containing 8 copies of the original lol. Every additional level added to this doubles the number of identifiers; extending it to a mere 30 levels, the work of a few minutes by hand, would make --prop30 contain nearly a billion instances of the identifier.
</p>

</div>

<p>
この類の攻撃を避けるため、~UAは，［
`var$f 関数を展開した結果の~token~streamに許容される長さ
］に自身が定義する上限を課すモノトスル。
`var^f がこの上限より長い~token~streamに展開される場合、代わりに，~propは`算出d値の時点で無効$になるよう展開されるとする。
◎
To avoid this sort of attack, UAs must impose a UA-defined limit on the allowed length of the token stream that a var() function expands into. If a var() would expand into a longer token stream than this limit, it instead makes the property it’s expanding into invalid at computed-value time.
</p>

<p>
この仕様は、課すベキ上限~sizeは定義しない。
しかしながら， 1000 ~byte以上の~textを包含するような~custom~prop用の妥当な利用事例もあるので、上限は多少高めに設定することが推奨される。
◎
This specification does not define what size limit should be imposed. However, since there are valid use-cases for custom properties that contain a kilobyte or more of text, it’s recommended that the limit be set relatively high.
</p>

<p class="note">注記：
［
~UAには、資源の拘束に因り標準に違反することが許容される
］とする一般~原則は、ここにも一般に該当する。
~UAは、自身が~supportできる［
~custom~prop／識別子
］の~~長さに別々の上限を課すこともあろう。
この節が，この攻撃を特定的に引き合いに出すのは、それには長い歴史があり，初回の検分では巨大~過ぎな~~片は`無さそうに見える^emものでも行える事実があることによる。
◎
Note: The general principle that UAs are allowed to violate standards due to resource constraints is still generally true here; a UA might, separately, have limits on how long of a custom property they can support, or how large of an identifier they can support. This section calls out this attack specifically because of its long history, and the fact that it can be done without any of the pieces seeming to be too large on first inspection.
</p>

		</section>
	</section>
	<section id="apis">
<h2 title="APIs">4. ~API</h2>

<p>
すべての`~custom~prop$`宣言$に対し、その`文字大小区別か$は ~T にされる。
◎
All custom property declarations have the case-sensitive flag set.
</p>

<p class="note">注記：
~custom~propは，名前の文字大小が区別されるので、
`CSSStyleDeclaration$I ~objの中に
<strong>C</strong>amel<strong>C</strong>ase
形で現れることはない。
自動的に CamelCase 化する~text変形nの類いは，これと互換になれない。
それらは、 `getPropertyValue()$m, 等の~interfaceを介して，適正な名前で~accessできる。
◎
Note: Custom properties do not appear on a CSSStyleDeclaration object in camel-cased form, because their names may have both upper and lower case letters which indicate distinct custom properties. The sort of text transformation that automatic camel-casing performs is incompatible with this. They can still be accessed by their proper name via getPropertyValue()/etc.
</p>

		<section id="serializing-custom-props">
<h3 title="Serializing Custom Properties">4.1. ~custom~propの直列化-法</h3>

<p>
~custom~prop名を直列化するときは、作者から供された文字大小を保全するモノトスル。
◎
Custom property names must be serialized with the casing as provided by the author.
</p>

<p class="note">注記：
~customでない~propに対しては，その名前は~ASCII範囲に制約された上で, `~ASCII大小無視$になるので、実装は概して，名前を小文字~化した上で直列化する。
◎
Note: For non-custom properties, property names are restricted to the ASCII range and are ASCII case-insensitive, so implementations typically serialize the name lowercased.
</p>

		</section>
	</section>
	<section id="changes">
<h2 title="Changes">5. 変更点</h2>

<dl>
	<dt id="changes-20151203">
 2015年 12 月 3日 勧告候補からの変更点
◎
5.1. Changes Since the 03 December 2015 CR
</dt>
	<dd>
`css-syntax-3$r は、今や宣言~値からの空白を自動で削る
— そのため，~custom~prop文法における `declaration-value$t は、空な変数を依然として許容するよう，省略可能にした。
（ `774$issue ）
◎
Now that [css-syntax-3] auto-trims whitespace from declaration values, made &lt;declaration-value&gt; optional in the custom property grammar, so that empty variables are still allowed. (Issue 774)
</dd>

	<dt id="changes-20140506">
2014年 5月 6日 最終~作業草案からの変更点
◎
5.2. Changes since the May 6 2014 Last Call Working Draft
</dt>
	<dd>
略式~propが変数を利用している場合の，下位propの直列化を定義した。
◎
Serialization of longhands when shorthand uses a variable was defined.
</dd>
	<dd>
DOM による “大小無視” の定義へ~linkした。
◎
Link to DOM’s definition of "case-sensitive".
</dd>
	<dd>
`lang()$ps と伴に変数を利用して国際-化に対応する，単純な例を追加した。
◎
Added example of using variables with :lang() to do simple i18n.
</dd>
	<dd>
~custom~propにおける `var$f の利用は、
`var$f 文法に対し妥当でなければナラナイことを明確化した。
◎
Clarified that usage of var() in a custom property must be valid per the var() grammar.
</dd>
</dl>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">6. 謝辞</h2>

<p lang="en-x-a0">
Many thanks to several people in the CSS Working Group for keeping the dream of variables alive over the years, particularly Daniel Glazman and David Hyatt. Thanks to multiple people on the mailing list for helping contribute to the development of this incarnation of variables, particularly Brian Kardell, David Baron, François Remy, Roland Steiner, and Shane Stephens.
</p>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">7. ~privacyと~securityの考慮点</h2>

<p>
この仕様が定義する仕組みは、作者が制御する~pageの中で，作者~levelの~style付け情報を使い回す以上のことはしない。
そのようなわけで、新たな~privacyの考慮点はない。
◎
This specification defines a purely author-level mechanism for passing styling information around within a page they control. As such, there are no new privacy considerations.
</p>

<p>
<a href="#long-variables">§ 過度に長い変数の安全な取扱い</a>では、
`var$f 関数などの “~macro展開” の様な仕組みに対し仕掛けれる，昔からある~DoS攻撃を引き合いに出し、その攻撃に抗する防御を義務付ける。
◎
§ 3.3 Safely Handling Overly-Long Variables calls out a long-standing Denial-of-Service attack that can be mounted against "macro-expansion"-like mechanisms, such as the var() function, and mandates a defense against that attack.
</p>

	</section>
</main></div>

