<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Screen Wake Lock API（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'l': // literal
	text = `"<code class="literal">${text}</code>"`;
	break;
case 't': // typedef
	text = `&lt;${key}&gt;`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'wpt':
	href1 = `https://wpt.live/screen-wake-lock/${key}.html`;
	text = key.replace(/\..*/, '');
	if(/\.https\b/.test(key)){
		text += ' <span aria-label="セキュアな接続が要求される／requires a secure connection" title="このテストには HTTPS が要求される／Test requires HTTPS">🔒</span>';
	}
	if(/-manual\b/.test(key)){
		text += ' <span aria-label="このテストは手動で走らす必要がある／the test must be run manually" title="手動テスト／Manual test">💪</span>';
	}
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:Screen Wake Lock API
spec_date:2023-11-07
trans_update:2023-11-22
source_checked:231107
spec_status:ED
original_url:https://w3c.github.io/screen-wake-lock/
	abbr_url:SCREEEN-WAKELOCK
ref_id_prefix:bib-
ref_id_lowercase:true
site_nav:uievents
ref_id_lowercase:true
copyright:2023,permissive
trans_1st_pub:2023-11-20
conformance:w3c

●●class_map
E:error
a:attr
v:value
et:event-type
sl:js-slot
jv:js-value

●●tag_map
I:code
E:code
m:code
c:code
sl:span
et:code
a:code
v:code
jv:code
i:i
cite:cite

●●original_id_map

	auto-releasing-wake-locks:dfn-auto-releasing-wake-locks
	handling-document-loss-of-full-activity:dfn-handling-document-loss-of-full-activity
	handling-document-loss-of-visibility:dfn-handling-document-loss-of-visibility

●●mdn_urls
dom-navigator-wakelock:API/Navigator/wakeLock
dom-wakelock:API/WakeLock
dom-wakelock-request:API/WakeLock/request
dom-wakelocksentinel:API/WakeLockSentinel
dom-wakelocksentinel-released:API/WakeLockSentinel/released
dom-wakelocksentinel-type:API/WakeLockSentinel/type
dom-wakelocksentinel-release:API/WakeLockSentinel/release
dfn-release:API/WakeLockSentinel/release_event

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
SameObject:~WEBIDLjs#SameObject
SecureContext:~WEBIDLjs#SecureContext
Promise:~WEBIDL#idl-promise
boolean:~WEBIDL#idl-boolean
undefined:~WEBIDL#idl-undefined

E.NotAllowedError:~WEBIDL#notallowederror

I.WakeLock:#dom-wakelock
I.WakeLockSentinel:#dom-wakelocksentinel
I.WakeLockType:#dom-wakelocktype
I.EventHandler:~WAPI#eventhandler
I.EventTarget:~DOM4#eventtarget
I.Window:~WINDOW#window
I.DOMException:~WEBIDL#idl-DOMException
I.Document:~DOM4#document
I.Navigator:~HTMLnavigator#navigator

m.wakeLock:#dom-navigator-wakelock
m.request:#dom-wakelock-request
m.released:#dom-wakelocksentinel-released
m.type:#dom-wakelocksentinel-type
m.release:#dom-wakelocksentinel-release
m.onrelease:#dom-wakelocksentinel-onrelease

l.screen:#dom-wakelocktype-screen
l.denied:~PERMISSIONS#dom-permissionstate-denied

	●code 他

sl.ActiveLocks:#dfn-activelocks
sl.Released:#dfn-released

et.release:#dfn-release
a.allow:~HEembed#attr-iframe-allow

	●用語
~wake~lock種別:#dfn-wake-lock-type
~platform~wake~lock:#dfn-platform-wake-lock
i.~screen~wake~lock:#dfn-screen-wake-lock
~wake~lockを否認-:#dfn-deny-wake-lock
~screen~wake~lock許可~revocation~algo:#dfn-screen-wake-lock-permission-revocation-algorithm
~screen~wake~lock~task~source:#dfn-screen-wake-lock-task-source
~wake~lockを適用するよう下層の~OSに要請する:#dfn-acquire-wake-lock
~wake~lockをもはや適用しないよう下層の~OSに要請する:#dfn-release-wake-lock
~wake~lockを獲得する:#dfn-acquire-a-wake-lock
~wake~lockを解放する:#dfn-release-a-wake-lock
適用-可能:#dfn-applicable-wake-lock

	●用語（外部
~UA:~INFRA#user-agent
	~UA:#dfn-user-agent
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
空:~INFRA#list-is-empty
~list:~INFRA#list
有順序~map:~INFRA#ordered-map
	~EACH:~INFRA#list-iterate

並列的:~HTMLINFRA#in-parallel

内部~slot:~TC39#sec-object-internal-methods-and-internal-slots

	コレ:~WEBIDL#this
新たな~promise:~WEBIDLjs#a-new-promise
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決される~promise:~WEBIDLjs#a-promise-resolved-with
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve

~eventを発火する:~DOM4#concept-event-fire

利用は許容されて:~HEembed#allowed-to-use
結付けられた文書:~WINDOW#concept-document-window
全部的に作動中:~HTMLds#fully-active
~page可視性~変化-時の手続き:~HTMLinteraction#page-visibility-change-steps
doc.可視性~状態:~HTMLinteraction#visibility-state

大域~taskを~queueする:~WAPI#queue-a-global-task
現在の大域~obj:~WAPI#current-global-object
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
関連な大域~obj:~WAPI#concept-relevant-global
~task~source:~WAPI#task-source
~task:~WAPI#concept-task

既定の許容list:~PERMISSIONS-POLICY#policy-controlled-feature-default-allowlist
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature
許可~revocation~algo:~PERMISSIONS#dfn-permission-revocation-algorithm
強力な特能:~PERMISSIONS#dfn-powerful-feature
利用する許可を要請する:~PERMISSIONS#dfn-request-permission-to-use


●●words_table1


●●words_table

	●wake lock
wake:
獲得-:acquire::~
獲得:acquisition::~
解放-:release::~

	●battery
battery::::バッテリー
放電-:discharge:~
充電-:charge:~
	残量:charge
	残量:level
充電:charge:~
一過:transient:~
節約:saving:~
寿命:life:~
消耗:depletion:~
消耗-:deplete:~
容量:capacity:~
電力:power:~
電源:power source:~
引延ばす:prolongeする:引き延ばす
温存:conservation:~
コンセント:wall power:~
運用-:operate:~
休眠:deep power:~
利用度:usage:~

	電力~節約:power-saving
	消費電力:energy
	速く:faster

	●処理
	%~lock~list:lockList
	%文書
	%~lock
	%種別
	%~promise
	%状態
	%~obj
	%~handle


	●保安
revocation::取り消し
許容list:allowlist::許容 list:許容リスト

	●仕様
選択的:selective:~
正常:normal:~
	正常でない:abnormal
種類:kind:~
積極的:aggressive:~
現代化:modernize:~
邪魔-:hinder:~
一様:uniform:~
控えめ:unobtrusive:~
伝える:informする:~
末端-:end:~
重複:duplicate:~
timer::::タイマー
mobile::::モバイル
活動:activity:~
無活動:inactivity:~

	逆に:conversely
	課され:impose
	なれるようにする:let 〜 go into
	処する:deal with
	感謝-:offer our sincere thank
	勧告候補:CR
	助けにもなり:could help
	至らせ:lead
	不能になる:can lead to inability
	知る:know
	書き直:rewrite
	情報:info
	許容しない:disallow
	申し分ない:great
	索引:Index

	●言い換え
	全部的に作動中でなくなった:loss of full activity
	可視でなくなった:loss of visibility
	可視でなくなった:hidden
	%~obj に`関連な大域~obj$（ `Window$I ~obj）:the Window object that the WakeLockSentinel object's constructor was invoked from
	で識別される:named
	近くに:stationary 〜 readily
	許可~施策:Permissions Policy
	`PERMISSIONS-POLICY$r:Permissions Policy
	だけに絞って:Convert the document to purely
	一定時間無いとき:shortly after the lack of
	存在し続ける限り:existence
	適用-可能:Under the right conditions
	~screen~wake~lock~API^cite:Screen Wake Lock API
	自動的な解放-法:auto-releasing
	また:alternatively

	●未分類
component::::コンポーネント
切替えら:switchさ:切り替えら
明るさ:brightness:~
on::::オン
off::::オフ
	onに:on に turn:::オンに
	offに:off に turn:::オフに
	~onに:turn on
	~offに:turn off
	~off:blank
checkbox::::チェックボックス
check::::チェック
barcode::::バーコード
超過-:exceed:~
CPU:
走査-:scan:~
電子本:ebook:~
読んで:readして:~
recipe::::レシピ
視聴者:audience:~
退ける:dismissする:~
handle::::ハンドル
末端-:end:~
重複:duplicate:~
種類:kind:~
display::::ディスプレイ
明るさ:brightness:~
緊急:emergency:~

	ときもある:sometime
	最終的:ultimately
	置いた:has put
	より高い:higher
	目で追う:follow
	少し後:shortly after
	列挙:enum
	示す:show
	不足なく:sufficient
	より長い:longer
	指す:refer
	下げる:lower
	少ない:low
	居るかどうか:presence state
	暗く:dim
	直後:immediately after
	になる:going
	いつでも:at any time
	~prompt法:prompting
	通話:make or receive calls

●●ref_normative

[dom]
    ＜DOM Standard＞. Anne van Kesteren.  WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞.  Ecma International. URL: https://tc39.es/ecma262/multipage/
[html]
    ＜HTML Standard＞. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters.  WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[infra]
    ＜Infra Standard＞. Anne van Kesteren; Domenic Denicola.  WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/
[PERMISSIONS]
    ＜Permissions＞. Marcos Caceres; Mike Taylor.  W3C. 13 June 2023. W3C Working Draft. URL: https://www.w3.org/TR/permissions/
[PERMISSIONS-POLICY]
    ＜Permissions Policy＞. Ian Clelland.  W3C. 17 October 2023. W3C Working Draft. URL: https://www.w3.org/TR/permissions-policy-1/
[RFC2119]
    ＜Key words for use in RFCs to Indicate Requirement Levels＞. S. Bradner.  IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119
[RFC8174]
    ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞. B. Leiba.  IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[WEBIDL]
    ＜Web IDL Standard＞. Edgar Chen; Timothy Gu.  WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/


●●ref_informative

[wake-lock-use-cases]
    ＜Wake Lock: Use cases＞. Marcos Caceres; Natasha Rooney; Dominique Hazaël-Massieux.  W3C. 14 August 2014. W3C Working Group Note. URL: https://www.w3.org/TR/wake-lock-use-cases/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより
編集者草案として公開された
<a href="~SPEC_URL">Screen Wake Lock API</a>
を日本語に翻訳したものです。
~PUB

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/screen-wake-lock/
編集者草案
	https://w3c.github.io/screen-wake-lock/
公表履歴
	https://www.w3.org/standards/history/screen-wake-lock/
commit履歴
	https://github.com/w3c/screen-wake-lock/commits/
テスト一式
	https://wpt.live/screen-wake-lock/
実装報告
	https://www.w3.org/wiki/DAS/Implementations
編集
	Kenneth Rohde Christiansen (Intel Corporation)
	Raphael Kubo da Costa (Intel Corporation)
前任編集者
	<a href="mailto:bogdanovichiy@yandex-team.ru">Ilya Bogdanovich</a> (Yandex)
	<a href="mailto:alogvinov@yandex-team.ru">Andrey Logvinov</a> (Yandex)
	<a href="https://marcosc.com/">Marcos Cáceres</a> (W3C) -  Until 01 May 2022
フィードバック
	<a href="https://github.com/w3c/screen-wake-lock/">GitHub w3c/screen-wake-lock</a> (<a href="https://github.com/w3c/screen-wake-lock/pulls/">pull requests</a>, <a href="https://github.com/w3c/screen-wake-lock/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/screen-wake-lock/issues/">open issues</a>)
Quality Assurance Lead
	<a href="https://github.com/Honry">Wanming Lin (Intel)</a>

公表者
	<a href="https://www.w3.org/groups/wg/das">Devices and Sensors WG</a>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Screen Wake Lock API</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、［
~web~appが~screen~wake~lockを要請する
］ことを許容する~APIを指定する。
~screen~wake~lockは、
適用-可能【！Under the right conditions】かつ許容されたなら［
~systemが機器の~screenを~offにする
］ことを防止する。
◎
This document specifies an API that allows web applications to request a screen wake lock. Under the right conditions, and if allowed, the screen wake lock prevents the system from turning off a device's screen.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、
公表~時点における…
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>
◎非規範的

<p>
現代の~OSは、
より長い~battery寿命を達成するために，
積極的な電力~管理を実装する
— それは、
次により，電力~利用度をアリな限り制限することを意味する
⇒
~host機器は、
利用者-活動が一定時間無いときは，次のいずれかを行ってヨイとする
⇒＃
~screenの明るさを下げる／
~screenを~offにする／
~CPUを休眠~状態になれるようにする
◎
Modern operating systems achieve longer battery life by implementing aggressive power management, meaning that shortly after the lack of user activity, a host device may lower the screen brightness, turn the screen off and even let the CPU go into a deep power state, limiting power usage as much as possible.
</p>

<p>
これは，~battery寿命を引延ばすことに関しては申し分ないが、
一部の利用事例を邪魔するときもある
— 例：
~barcodeを走査している,
電子本を読んでいる,
~recipeを目で追っている,
視聴者に呈示している,
等々。
`~wake~lock：利用事例＠~TR/wake-lock-use-cases/$cite
も見よ。
◎
Though this is great for prolonged battery life, it can sometime hinder some use cases such as scanning a barcode, reading an ebook, following a recipe, presenting to an audience, and so on. See also Wake Lock: Use cases.
</p>

<p>
~wake~lockは，一般に何かが起こることを防止するが、
~UA（および下層の~OS）は，
所与の~battery状態s
（例：［
コンセントに接続されている／
放電-中にある／
~battery残量が少ない
］かどうか）
の下で~wake~lockを時間~制限してもヨイ
— 電力~節約~modeが作動化された事例では、
~wake~lockを許容しないことにしてもヨイ。
◎
A wake lock will generally prevent something from happening, but UAs (and the underlying OS) may time limit a wake lock given the battery status (wall power connected, discharging, low battery level), or even disallow wake locks in the case a power saving mode is activated.
</p>

	</section>
	<section id="wake-locks">
<h2 title="Wake Locks">2. ~wake~lock</h2>

<p>
この仕様は、
次に挙げる
`~wake~lock種別@
を定義する：
◎
This specification defines the following wake lock type:
</p>
<ul>
	<li>
<p>
`~screen~wake~lock@i
⇒
~screenが~offにすることを防止する。
~screen~wake~lockを獲得し得るのは、
可視な文書に限られる。
</p>

<p class="trans-note">【
これは、
~dataとしては，それを表現する文字列 `screen$l と同一視される。
】</p>
◎
A screen wake lock prevents the screen from turning off. Only visible documents can acquire the screen wake lock.
</li>
</ul>

<p>
この~APIにおいては、
`~wake~lock種別$は，`WakeLockType$I 列挙~値により表現される。
◎
In the API, the wake lock types are represented by the WakeLockType enum values.
</p>

<p class="note">注記：
他の仕様は、
異なる~wake~lock種別を定義し得る。
◎
Note

Other specifications might define different wake lock types.
</p>

	</section>
	<section id="policy-control">
<h2 title="Policy control">3. 施策~制御</h2>

<p>
`~screen~wake~lock~API^cite は、
文字列 `screen-wake-lock^l により識別される`施策により制御される特能$を定義する。
その`既定の許容list$は `'self'^l とする。
◎
The Screen Wake Lock API defines a policy-controlled feature identified by the string "screen-wake-lock". Its default allowlist is 'self'.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-supported-by-permissions-policy$wpt
<li>`wakelock-enabled-on-self-origin-by-permissions-policy.https.sub$wpt
<li>`wakelock-enabled-by-permissions-policy-attribute-redirect-on-load.https.sub$wpt
<li>`wakelock-enabled-by-permissions-policy-attribute.https.sub$wpt
<li>`wakelock-enabled-by-permissions-policy.https.sub$wpt
</ul>
</details>

<div class="note">
<p>注記：
`既定の許容list$ `'self'^l は、
入子にされた同一-生成元に属する~frameにおける~wake~lock用法を許容する一方で，
第三者-主体に属する内容が~wake~lockを利用するのは防止する。
◎
Note

The default allowlist of 'self' allows wake lock usage in same-origin nested frames but prevents third-party content from using wake locks.
</p>

<p>
第三者-主体~用法は
当の`~frame容器~要素＠~HTMLds#nav-container$の `allow$a 属性に `screen-wake-lock^v を指定することにより，選択的に可能化できる：
◎
Third-party usage can be selectively enabled by adding allow="screen-wake-lock" attribute to the frame container element:
</p>

<div class="example" id="example-enabling-screen-wake-lock-on-remote-content">
<p>
~remote内容に対し~screen~wake~lockを可能化する例：
◎
Example: Enabling screen wake lock on remote content
</p>

<pre class="lang-html">
&lt;iframe src="https://third-party.com" allow="screen-wake-lock"&gt;&lt;/iframe&gt;
</pre>
</div>

<p>
また、
~HTTP応答~header内に許可~施策を指定することにより，
`~screen~wake~lock~API^cite を完全に不能化できる：
◎
Alternatively, the Screen Wake Lock API can be disabled completely by specifying the permissions policy in a HTTP response header:
</p>

<div class="example" id="example-permissions-policy-header">
<p>
許可~施策~headerの例：
◎
Example: Permissions Policy header
</p>

<pre class="lang-http">Permissions-Policy: screen-wake-lock=()
</pre>
</div>

<p>
より詳細は、
`許可~施策^cite `PERMISSIONS-POLICY$r
を見よ。
◎
See Permissions Policy for more details.
</p>
</div>


	</section>
	<section id="permissions-and-user-prompts">
<h2 title="Permissions and user prompts">4. 許可と利用者~prompt</h2>

<p>
`許可~API^cite `PERMISSIONS$r は、
~web~site用に［
利用者からの許可を要請する
］ため, および［
当の~web~siteが どの許可を有するか~queryする
］ための一様な仕方を供する。
◎
The [PERMISSIONS] API provides a uniform way for websites to request permissions from users and query which permissions they have.
</p>

<p>
`~UA$は、
実装に特有な理由
— ~platform設定や利用者~選好など —
により，
特定0の `Document$I 用に特定0の`~wake~lock種別$の
`~wake~lockを否認-@
できる。
◎
A user agent can deny a wake lock of a particular wake lock type for a particular Document by any implementation-specific reason, such as platform setting or user preference.
</p>

<p>
~UAには、
次を行うことが推奨される：
◎
It is RECOMMENDED that a user agent＼
</p>
<ul>
	<li>
何らかの形を成す控えめな通知
— ~wake~lockが作動中になったとき，そのことを利用者に伝える通知 —
を示す。
◎
show some form of unobtrusive notification that informs the user when a wake lock is active,＼
</li>
	<li>
次を行う手段を利用者に供する
⇒
進行中な演算を`阻む＠#dfn-screen-wake-lock-permission-revocation-algorithm$か，
単純に当の通知を退ける
◎
as well as provides the user with the means to block the ongoing operation, or simply dismiss the notification.
</li>
</ul>

		<section id="the-screen-wake-lock-powerful-feature">
<h3 title="The &quot;screen-wake-lock&quot; powerful feature">4.1. 強力な特能 `screen-wake-lock^l</h3>

<p>
文字列 `screen-wake-lock^l により識別される`強力な特能$が、
この仕様により定義される能力を可能化する。
◎
The "screen-wake-lock" powerful feature enables the capability defined by this specification.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelockpermissiondescriptor.https$wpt
</ul>
</details>

		</section>
		<section id="permission-algorithms">
<h3 title="Permission algorithms">4.2. 許可~algo</h3>

<div class="algo">
<p>
`強力な特能$ `screen-wake-lock^l は、
`許可~revocation~algo$として，
`~screen~wake~lock許可~revocation~algo@
を定義する
— それは、
次の手続きを走らす：
◎
The "screen-wake-lock" powerful feature defines a permission revocation algorithm. To invoke the Screen Wake Lock permission revocation algorithm, run these steps:
</p>
<ol>
	<li>
%文書 ~LET `現在の大域~obj$に`結付けられた文書$
◎
Let document be the current global object's associated Document.
</li>
	<li>
%文書 . `ActiveLocks$sl[ `screen^l ] を成す
~EACH( %~lock )
に対し
⇒
`~wake~lockを解放する$( %文書, %~lock, `screen$l )
◎
Let lockList be document.[[ActiveLocks]]["screen"].
◎
For each lock in lockList:
• Run release a wake lock with document, lock, and "screen".
</li>
</ol>
</div>

		</section>
	</section>
	<section id="concepts">
<h2 title="Concepts">5. 各種~概念</h2>

<p>
この仕様~内で言及される`~task$用の`~task~source$は、
`~screen~wake~lock~task~source@
である。
◎
The task source for the tasks mentioned in this specification is the screen wake lock task source.
</p>

<p>
用語
`~platform~wake~lock@
は、
~UAが，ある~wake~lock［
の状態を~queryする／を獲得する／を解放する
］ためにヤリトリする~platform~interfaceを指す。
◎
The term platform wake lock refers to platform interfaces with which the user agent interacts to query state and acquire and release a wake lock.
</p>

<p>
`~platform~wake~lock$は、
下層の~platformにより定義されることもあれば
（例：~native~wake~lock~frameworkにおいて），
~UAにより定義されることも
— ~UAが直な~hardware制御を有する場合には —
ある。
◎
A platform wake lock can be defined by the underlying platform (e.g. in a native wake lock framework) or by the user agent, if it has direct hardware control.
</p>

	</section>
	<section id="extensions-to-the-document-interface">
<h2 title="Extensions to the Document interface">6. `Document^I ~interfaceに対する拡張</h2>

<p id="internal-slots">
各 `Document$I ~instanceは、
次に挙げる`内部~slot$を伴って作成される：
◎
6.1. Internal slots
</p>

<div>
<dl>
	<dt>`ActiveLocks@sl</dt>
	<dd>
<p>
`有順序~map$
— 各~entryの：
</p>
		<ul>
			<li>
~keyは、
ある`~wake~lock種別$【を表現する文字列】を与える。
</li>
			<li>
値は、［
この `Document$I に結付けられた `WakeLockSentinel$I ~objたちが成す`~list$
］を与える
— 初期~時は`空$とする。
</li>
		</ul>
	</dd>
</dl>

<p class="trans-note">【
この仕様を実装する~UAには、
この~mapは，~keyとして［
`~screen~wake~lock$i を表現する文字列 `screen^l
］を伴う~entryを有することが要求される。
】</p>
◎
Internal slot｜Initial value｜Description
[[ActiveLocks]]｜An ordered map mapping wake lock types to empty lists.｜An ordered map of wake lock types to a list of WakeLockSentinel objects associated with this Document.
</div>

	</section>
	<section id="extensions-to-the-navigator-interface">
<h2 title="Extensions to the Navigator interface">7. `Navigator^I ~interfaceに対する拡張</h2>

<pre class="idl">
[`SecureContext$]
partial interface `Navigator$I {
  [`SameObject$] readonly attribute `WakeLock$I `wakeLock@m;
};
</pre>

	</section>
	<section id="the-wakelock-interface">
<h2 title="The WakeLock interface">8. `WakeLock^I ~interface</h2>

<p>
`WakeLock$I ~interfaceは、［
文書が `~screen~wake~lock$i を獲得する
］ことを許容する。
◎
The WakeLock interface allows a document to acquire a screen wake lock.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-insecure-context.any$wpt
</li>
</ul>
</details>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window)]
interface `WakeLock@I {
  `Promise$&lt;`WakeLockSentinel$I&gt; `request$m(optional `WakeLockType$I %type = "screen");
};
</pre>

<div class="algo">
<p id="the-request-method">
`request(type)@m
~method手続きは：
◎
8.1. The request() method
◎
The request(type) method steps are:
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-type.https.any$wpt
</li>
</ul>
</details>

<ol>
	<li>
%文書 ~LET コレに`関連な大域~obj$に`結付けられた文書$
◎
Let document be this's relevant global object's associated Document.
</li>
	<li>
<p>
~IF［
%文書 には［
`screen-wake-lock^l で識別される`施策により制御される特能$
］の`利用は許容されて$いない
］
⇒
~RET `却下される~promise$( `NotAllowedError$E 例外 )
◎
If document is not allowed to use the policy-controlled feature named "screen-wake-lock", return a promise rejected with a "NotAllowedError" DOMException.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-disabled-by-permissions-policy.https.sub$wpt
</li>
</ul>
</details>
	</li>
	<li>
<p>
~IF［
`~UA$は %文書 用には，`~wake~lock種別$ %type の`~wake~lockを否認-$する
］
⇒
~RET `却下される~promise$( `NotAllowedError$E 例外 )
◎
If the user agent denies the wake lock of this type for document, return a promise rejected with a "NotAllowedError" DOMException.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-screen-type-on-worker.https.worker$wpt
</li>
</ul>
</details>
	</li>
	<li>
<p>
~IF［
%文書 は`全部的に作動中$でない
］
⇒
~RET `却下される~promise$( `NotAllowedError$E 例外 )
◎
If document is not fully active, return a promise rejected with with a "NotAllowedError" DOMException.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-active-document.https.window$wpt
</li>
</ul>
</details>
	</li>
	<li>
<p>
~IF［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］
⇒
~RET `却下される~promise$( `NotAllowedError$E 例外 )
◎
If document's visibility state is "hidden", return a promise rejected with "NotAllowedError" DOMException.
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-document-hidden-manual.https$wpt
</li>
</ul>
</details>
	</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%状態 ~LET `screen-wake-lock^l を`利用する許可を要請する$
◎
Let state be the result of requesting permission to use "screen-wake-lock".
</li>
			<li>
<p>
~IF［
%状態 ~EQ `denied$l
］：
◎
If state is "denied", then:
</p>
				<ol>
					<li>
<p>
`大域~taskを~queueする$( `~screen~wake~lock~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
</p>
<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `NotAllowedError$E 例外 )
</div>
◎
Queue a global task on the screen wake lock task source given document's relevant global object to reject promise with a "NotAllowedError" DOMException.
</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-request-denied.https$wpt
</li>
</ul>
</details>
			</li>
			<li>
<p>
`大域~taskを~queueする$( `~screen~wake~lock~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the screen wake lock task source given document's relevant global object to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
%文書 の`可視性~状態$doc ~EQ `hidden^l
］：
◎
If document's visibility state is "hidden", then:
</p>
						<ol>
							<li>
`~promiseを却下する$( %~promise, `NotAllowedError$E 例外 )
◎
Reject promise with a "NotAllowedError" DOMException.
</li>
							<li>
~RET
◎
Abort these steps.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%文書 . `ActiveLocks$sl[ `screen^l ] は`空$である
］
⇒
次の手続きを`並列的$に呼出す
◎
If document.[[ActiveLocks]]["screen"] is empty, then invoke the following steps in parallel:
</p>

<div class="algo">
<p>
手続きは
⇒
`~wake~lockを獲得する$( `screen$l )
◎
Invoke acquire a wake lock with "screen".
</p>

<p class="note">注記：
~wake~lockを獲得する~algoは，最終的には~OSから~lockを獲得-可能でないこともあるが、
利用者に対する指紋収集を避けるため
（例えば、
~lockを獲得することの失敗は，~battery残量が少ないことを指示し得る），
~lockの成功裡な獲得と判別-不能になる。
◎
Note

The acquire a wake lock algorithm may ultimately be unable to acquire a lock from the operating system, but this is indistinguishable from a successful lock acquisition to avoid user fingerprinting (failure to acquire a lock can indicate low battery levels, for example).
</p>
</div>

					</li>
					<li>
%~lock ~LET 新たな `WakeLockSentinel$I ~obj
— その
⇒＃
`type$m 属性 ~SET %type
◎
Let lock be a new WakeLockSentinel object with its type attribute set to type.
</li>
					<li>
%文書 . `ActiveLocks$sl[ `screen^l ] に %~lock を`付加する$
◎
Append lock to document.[[ActiveLocks]]["screen"].
</li>
					<li>
`~promiseを解決する$( %~promise, %~lock )
◎
Resolve promise with lock.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

		</section>
	
	<section id="the-wakelocksentinel-interface">
<h2 title="The WakeLockSentinel interface">9. `WakeLockSentinel^I ~interface</h2>

<pre class="idl">
[`SecureContext$, `Exposed$=(Window)]
interface `WakeLockSentinel@I : `EventTarget$I {
  readonly attribute `boolean$ `released$m;
  readonly attribute `WakeLockType$I `type$m;
  `Promise$&lt;`undefined$&gt; `release$m();
  attribute `EventHandler$I `onrelease$m;
};
</pre>

<p>
`WakeLockSentinel$I ~obj %~obj は、
その `type$m 属性が指示する`~wake~lock種別$ %種別 用の下層の`~platform~wake~lock$ %~lock への~handle %~handle を供する：
◎
A WakeLockSentinel object provides a handle to a platform wake lock,＼
</p>
<ul>
	<li>
%~handle は、［
%~obj が `release()$m により手動で解放されるか %~lock が解放される
］まで %~obj に保持される。
◎
and it holds on to it until it is either manually released or until the underlying platform wake lock is released.＼
</li>
	<li>
%~lock は、
%~handle が存在し続ける限り，作動中に保たれる。
◎
Its existence keeps a platform wake lock for a given wake lock type active,＼
</li>
	<li>
%種別 用の `WakeLockSentinel$I ~instanceすべてを解放すると、
%~lock は，解放されるようになる。
◎
and releasing all WakeLockSentinel instances of a given wake lock type will cause the underlying platform wake lock to be released.
</li>
</ul>

<p class="note">注記：
所与の~wake~lockを`~UA$が どの状況下で解放し得るかについては、
次に挙げる各節を見よ
⇒＃
`§ ~wake~lockの自動的な解放-法＠#auto-releasing-wake-locks$,
`§ 全部的に作動中でなくなった文書の取扱い＠#handling-document-loss-of-full-activity$,
`§ 可視でなくなった文書の取扱い＠#handling-document-loss-of-visibility$
◎
Note

See auto-releasing wake locks, handling document loss of full activity and handling document loss of visibility for circumstances under which a given wake lock may be released by the user agent.
</p>

<p id="internal-slots-0">
各 `WakeLockSentinel$I ~instanceは、
次に挙げる`内部~slot$を伴って作成される：
◎
9.1. Internal slots
◎
WakeLockSentinel instances are created with the following internal slots:
</p>

<div>
<dl>
	<dt>`Released@sl</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>
	<dd class="note">注記：
この `WakeLockSentinel$I が解放されたかどうかを指示する。
</dd>
</dl>

◎
Internal slot｜Initial value｜Description (non-normative)
[[Released]]｜false｜Whether the given WakeLockSentinel has been released.
</div>

<div class="algo">
<p id="the-released-attribute">
`released@m
取得子~手続きは
⇒
~RET コレ . `Released$sl
◎
9.2. The released attribute
◎
The released getter steps are to return this.[[Released]].
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-released.https$wpt
</li>
</ul>
</details>

<p class="note">注記：
`WakeLockSentinel$I が解放されたなら、
`released$m は ~T になり，それ以降は決して変化しない。
◎
Note

Once a WakeLockSentinel is released, released becomes true, and the value never changes again.
</p>
</div>

<div class="algo">
<p id="the-type-attribute">
`type@m
取得子~手続きは
⇒
~RET コレの`~wake~lock種別$
◎
9.3. The type attribute
◎
The type getter steps are to return this's wake lock type.
</p>
</div>

<div class="algo">
<p id="the-release-method">
`release()@m
~method手続きは：
◎
9.4. The release() method
◎
The release() method steps are:
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-onrelease.https$wpt
</li>
</ul>
</details>
<ol>
	<li>
~IF［
コレ . `Released$sl ~EQ ~F
］
⇒
`~wake~lockを解放する$( 【コレに`関連な大域~obj$に`結付けられた文書$】, コレ, コレの`~wake~lock種別$【！`type$m 属性 の値】 )
◎
If this's [[Released]] is false, then run release a wake lock with lock set to this and type set to the value of this's type attribute.
</li>
	<li>
~RET `解決される~promise$( `undefined^jv )
◎
Return a promise resolved with undefined.
</li>
</ol>
</div>

<p>
`onrelease@m
属性は、
名前 `onrelease^l を伴う`~event~handler$用の`~event~handler~IDL属性$である
— 対応する`~event~handler~event型$は、
`release@et
である。
◎
9.5. The onrelease attribute
◎
The onrelease attribute is an event handler IDL attribute for the "onrelease" event handler, whose event handler event type is "release".
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-onrelease.https$wpt
</li>
</ul>
</details>

<p>
`onrelease$m は、
次を~scriptに通知するために利用される
⇒
この `WakeLockSentinel$I ~objの~handleが［
`release()$m ~methodが~callされた／
当の~wake~lockが`~UA$により解放された
］ことに因り解放された。
◎
It is used to notify scripts that a given WakeLockSentinel object's handle has been released, either due to the release() method being called or because the wake lock was released by the user agent.
</p>

<p class="note">注記：
`WakeLockSentinel$I ~objの~handleが解放されたとしても、
所与の`~wake~lock種別$用の`~platform~wake~lock$が解放されたことを意味するとは限らない
【まだ解放されてない `WakeLockSentinel^I ~objが他にもあり得るので】。
それは、
`~platform~wake~lock$の `ActiveLocks$sl 内部~slotに依存する。
`~wake~lockを解放する$を見よ。
◎
Note

A WakeLockSentinel object's handle being released does not necessarily mean the platform wake lock for a given wake lock type was released. That depends on the platform wake lock's [[ActiveLocks]] internal slot. See release a wake lock.
</p>

<p class="note">注記：
`onrelease$m ~event~handlerを`利用する方法の例＠#onrelease-example$も見よ。
◎
Note

Example 2 contains an example of how to use the onrelease event handler.
</p>

		<section id="garbage-collection">
<h3 title="Garbage collection">9.6. ~garbage収集</h3>

<p>
`WakeLockSentinel$I ~obj %~obj に対しては、
~OR↓ が満たされる間は，
%~obj に`関連な大域~obj$（ `Window$I ~obj）【！the Window object that the WakeLockSentinel object's constructor was invoked from】から %~obj への強い参照が在るモノトスル：
◎
↓</p>
<ul>
	<li>
［
`release$et 用に 1 個以上の~event~listenerが登録されている
］~AND［
%~obj はまだ解放されてない
］
◎
While a WakeLockSentinel object has one or more event listeners registered for "release", and the WakeLockSentinel object hasn't already been released, there MUST be a strong reference from the Window object that the WakeLockSentinel object's constructor was invoked from to the WakeLockSentinel object itself.
</li>
	<li>
`~screen~wake~lock~task~source$に対し %~obj により~queueされた~taskが在る
◎
While there is a task queued by an WakeLockSentinel object on the screen wake lock task source, there MUST be a strong reference from the Window object that the WakeLockSentinel object's constructor was invoked from to that WakeLockSentinel object.
</li>
</ul>

		</section>
	</section>
	<section id="the-wakelocktype-enum">
<h2 title="The WakeLockType enum">10. `WakeLockType^I 列挙</h2>

<p>
この仕様は、
各`~wake~lock種別$を述べる目的で，
それらを表現する次の列挙を定義する：
◎
For the purpose of wake lock type description, this specification defines the following enumeration to represent wake lock types:
</p>

<pre class="idl">
enum `WakeLockType@I { `screen$l };
</pre>

<p>
`screen@l
は、
種別 `~screen~wake~lock$i を表現する。
◎
screen
• Screen wake lock type.
</p>

	</section>
	<section id="managing-wake-locks">
<h2 title="Managing Wake Locks">11. ~wake~lockの管理-法</h2>

<p>
この節は、
各`~wake~lock種別$に等しくかつ独立に適用される
— 特定0の`~wake~lock種別$が明示的に言及されない限り。
◎
This section applies to each wake lock type equally and independently, unless a particular wake lock type is explicitly mentioned.
</p>

<p>
`~UA$は、
所与の`~wake~lock種別$用の
`~wake~lockを適用するよう下層の~OSに要請する@
ことにより，当の~wake~lockを獲得する。
`~UA$は、
そのような要請の返り値を検査しない
— 言い換えれば、
`~UA$は，~wake~lockの獲得を<strong>助言的に限られる</strong>ものとして扱うモノトスル。
◎
The user agent acquires the wake lock by requesting the underlying operating system to apply the lock. A possible return value of the request to the underlying operating system is not checked. In other words, user agents MUST treat wake lock acquisition as advisory-only.
</p>

<p>
逆に，`~UA$は、
所与の`~wake~lock種別$用の
`~wake~lockをもはや適用しないよう下層の~OSに要請する@
ことにより，当の~wake~lockを解放する。
当の~lockは、
そのような要請が成功したときに限り，解放されたものと見なされる。
◎
Conversely, the user agent releases the wake lock by requesting the underlying operating system to no longer apply the wake lock. The lock is considered released only when the request to the operating system succeeds.
</p>

<p>
~wake~lockが
`適用-可能@
であるとは、
次が満たされることをいう
⇒
~OSは、
当の~lockの適用を許可する状態にある
（例：~batteryは不足なく充電されている）。
◎
The wake lock is applicable if the state of the operating system permits application of the lock (e.g. there is sufficient battery charge).
</p>

<p>
`~screen~wake~lock$i は、
~screenが利用者により手動で~offに切替えられた場合には，
再び~onに切替えられるまで，`適用-可能$でないモノトスル。
◎
The screen wake lock MUST NOT be applicable after the screen is manually switched off by the user until it is switched on again.
</p>

<p class="note">注記：
~wake~lockが適用-可能かどうかは、
一過な条件である
— 例：~battery残量が少なく，充電し直されたとき。
可視性~要件と同様に，これは、
自動的な~wake~lock管理の一部を成すものであり，
~wake~lockを許容するか否認するか裁定する処理nの一部を成すものではない。
◎
Note

Whether the wake lock is applicable is a transient condition, e.g. when the battery charge is low but then the battery is recharged. So like the visibility requirement, this is part of automatic wake lock management and not part of the decision process whether to allow or deny the wake lock.
</p>

		<section id="auto-releasing-wake-locks">
<h3 title="Auto-releasing wake locks">11.1. ~wake~lockの自動的な解放-法</h3>

<p>
~UAは、
いつでも`~wake~lockを解放-＠#dfn-release-a-wake-lock$してヨイ。
例えば、
次に挙げるとき：
◎
A user agent may release a wake lock at any time. For example, when:
</p>
<ul>
	<li>
正常でない演算を検出したとき
— 例：無限~loopになった／課された時間~制限sを超過した~taskが在る。
◎
It detects abnormal operation: such as infinite loops and tasks exceeding imposed time limits (if any).
</li>
	<li>
~batteryの残量が少なく放電-中と見なされるとき。
◎
Battery is considered low and discharging.
</li>
	<li>
利用者は、
何らかの種類の機器~電力~温存~modeを~onにした。
◎
The user turns on some kind of device power conservation mode.
</li>
	<li>
~OSは、
利用者が居るかどうかに基づいて，~screenを［
暗くする／~offにする
］よう環境設定されている。
◎
The operating system is configured to dim or turn off the screen based on the user presence state.
</li>
</ul>

		</section>
		<section id="handling-document-loss-of-full-activity">
<h3 title="Handling document loss of full activity">11.2. 全部的に作動中でなくなった文書の取扱い</h3>

<div class="algo">
<p>
所与の `Document$I %文書 がもはや`全部的に作動中$でなくなったときは、
~UAは，次の手続きを走らすモノトスル：
◎
When a Document document becomes no longer fully active, the user agent must run these steps:
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-active-document.https.window$wpt
</ul>
</details>

<ol>
	<li>
%文書 . `ActiveLocks$sl[ `screen^l ] を成す
~EACH( %~lock )
に対し
⇒
`~wake~lockを解放する$( %文書, %~lock, `screen$l )
◎
For each lock in document.[[ActiveLocks]]["screen"]:
• Run release a wake lock with document, lock, and "screen".
</li>
</ol>
</div>

		</section>
		<section id="handling-document-loss-of-visibility">
<h3 title="Handling document loss of visibility">11.3. 可視でなくなった文書の取扱い</h3>

<div class="algo">
<p>
この仕様は、
`~page可視性~変化-時の手続き$として
次を定義する
— それは、
所与の
( `可視性~状態$doc %状態, %文書 )
に対し：
◎
This specification defines the following page visibility change steps with visibility state state and document:
</p>

<details>
<summary>~test</summary>
<ul>
<li>`wakelock-document-hidden-manual.https$wpt
</ul>
</details>
<ol>
	<li>
~IF［
%状態 ~NEQ `hidden^l
］
⇒
~RET
◎
If state is not "hidden", abort these steps.
</li>
	<li>
%文書 . `ActiveLocks$sl[ `screen^l ] を成す
~EACH( %~lock )
に対し
⇒
`~wake~lockを解放する$( %文書, %~lock, `screen$l )
◎
For each lock in document.[[ActiveLocks]]["screen"]:
• Run release a wake lock with document, lock, and "screen".
</li>
</ol>
</div>

		</section>
		<section id="acquire-wake-lock-algorithm">
<h3 title="Acquire wake lock algorithm">11.4. ~wake~lockを獲得する~algo</h3>

<div class="algo">
<p>
`~wake~lockを獲得する@
ときは、
所与の
( `~wake~lock種別$【！種別】 %種別 )
に対し，次の手続きを走らす：
◎
To acquire a wake lock for a given type, run these steps:
</p>
<ol>
	<li>
~IF［
%種別 用の~wake~lockは`適用-可能$でない
］
⇒
~RET
◎
If the wake lock for type type is not applicable, abort these steps.
</li>
	<li>
%種別 用の`~wake~lockを適用するよう下層の~OSに要請する$
◎
Ask the underlying operating system to acquire the wake lock of type type.
</li>
</ol>
</div>

		</section>
		<section id="release-wake-lock-algorithm">
<h3 title="Release wake lock algorithm">11.5. ~wake~lockを解放する~algo</h3>

<div class="algo">
<p>
`~wake~lockを解放する@
ときは、
所与の
( %文書, %~lock, `~wake~lock種別$ %種別 )
に対し，次の手続きを走らす：
◎
To release a wake lock for a given document, lock, and type, run these steps:
</p>
<ol>
	<li>
~IF［
%~lock ~NIN  %文書 . `ActiveLocks$sl[ %種別 ]
］
⇒
~RET
◎
If document.[[ActiveLocks]][type] does not contain lock, abort these steps.
</li>
	<li>
%文書 . `ActiveLocks$sl[ %種別 ] から %~lock を`除去する$
◎
Remove lock from document.[[ActiveLocks]][type].
</li>
	<li>
<p>
~IF［
%文書 . `ActiveLocks$sl[ %種別 ] は`空$である
］
⇒
次の手続きを`並列的$に走らす
◎
If document.[[ActiveLocks]][type] is empty, then run the following steps in parallel:
</p>

<div class="algo">
<p>
手続きは：
</p>
		<ol>
			<li>
%成功か ~LET ［
次の結果が成功したならば ~T ／
~ELSE_ ~F
］
⇒
%種別 用の`~wake~lockをもはや適用しないよう下層の~OSに要請する$
◎
Ask the underlying operating system to release the wake lock of type type and let success be true if the operation succeeded, or else false.
</li>
			<li>
<p>
~IF［
%成功か ~EQ ~T
］~AND［
%種別 ~EQ `screen^l
］
⇒
~platformに特有な無活動~timerを設定し直す
— ~screenが実際に~offにされるのは、
その後になるよう
◎
If success is true and type is "screen" run the following:
• Reset the platform-specific inactivity timer after which the screen is actually turned off.
</p>

<p class="note">注記：
無活動~timerを設定し直すのは、
~wake~lockが解放された直後に~screenが~off【！blank】になるのを防止するためである。
◎
Note

Resetting the inactivity timer prevents the screen from going blank immediately after the wake lock is released.
</p>
			</li>
		</ol>
</div>
	</li>
	<li>
%~lock の `Released$sl ~SET ~T
◎
Set lock's [[Released]] to true.
</li>
	<li>
`~eventを発火する$( %~lock, `release$et )
◎
Fire an event named "release" at lock.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="security-and-privacy-considerations">
<h2 title="Security and privacy considerations">12. ~security／~privacy の考慮点</h2>

<p>
~screen~wake~lockは、
様々な機器~component
— 特に~display —
を，~lockされない場合より高い電力で運用させ得る。
これは、
望ましくない効果へ至らせ得る
— 機器が自身を自動的に~lockすることを防止して，~batteryの消耗が速くなるなど。
それは、
近くに可用な電源が無いことが多い~mobile機器において特に懸念される。
予期されない時点に~batteryが完全に消耗すると、
利用者は，通話や~network~service（緊急~call~serviceも含む）を利用-不能になる。
◎
Screen wake locks can cause various device components - particularly the display - to operate at higher power levels than they otherwise would. This can lead to undesirable effects, such as preventing the device from automatically locking itself and faster battery depletion. Faster battery depletion is of particular concern for mobile devices, which often don't have a stationary power source readily available. Complete battery depletion at an unexpected time can lead to inability of the user to make or receive calls and use network services, including the emergency call service.
</p>

<p>
実装は、
例えば［
~battery容量が少ない場合／
利用者が自身の機器を電力~節約~modeに置いた場合
］には，~screen~wake~lock用の要請を無視してもヨイ。
◎
Implementations MAY ignore requests for screen wake lock if, for example, the battery capacity is low, or the user has put their device in a power-saving mode.
</p>

<p>
~UAには、［
~screen~wake~lockがいつ作動中になったか，利用者が知ることを許容する
］よう，何らかの~UIや指示子を供することが推奨される。
そのような~UIを供することは、
末端-利用者が［
特定0の~web~appが，機器の消費電力に負な影響iがある
］ことを識別する助けにもなり、
それでも欲される場合には，そのための動作をとることも彼らに許容する。
◎
It is RECOMMENDED that a user agent provide some UI or indicator that allows the user to know when a screen wake lock is active. Providing such a UI could help end users to identify if a particular web application is having a negative energy impact on the device, and allow them to take action if so desired.
</p>

	</section>
	<section id="examples">
<h2 title="Examples">13. 例</h2>
◎非規範的

<div class="example" id="example-acquires-and-releases-a-screen-wake-lock">
<p>
~screen~wake~lockを獲得して，【一定時間後に】解放する例：
◎
Example 1: Acquires and releases a screen wake lock
</p>

<pre class="lang-js">
function tryKeepScreenAlive(%minutes) {
  navigator.wakeLock.request("screen").then(%lock =&gt; {
    setTimeout(() =&gt; %lock.release(), %minutes * 60 * 1000);
  });
}

tryKeepScreenAlive(10);
</pre>
</div>

<div class="example" id="onrelease-example">
<p>
この例は、［
ある~checkboxを~clickすることにより，~screen~wake~lockを要請する
］ことを利用者に許容することに加え、
~wake~lock状態が変化した事例では，
当の~checkboxを~checkされた状態に更新する：
◎
This example allows the user to request a screen wake lock by clicking on a checkbox, but updates the checkbox checked state in case the wake lock state changes:
◎
Example 2
</p>

<pre class="lang-js">
const %checkbox = document.createElement("input");
%checkbox.setAttribute("type", "checkbox");
document.body.appendChild(%checkbox);

const %sentinel = await navigator.wakeLock.request("screen");
%checkbox.checked = !%sentinel.released;
%sentinel.onrelease = () =&gt; %checkbox.checked = !%sentinel.released;
</pre>
</div>

<div class="example" id="example-3">
<p>
2 個の異なる~wake~lock要請を独立に作成して解放する例：
◎
In this example, two different wake lock requests are created and released independently:
◎
Example 3
</p>

<pre class="lang-js">
let %lock1 = await navigator.wakeLock.request("screen");
let %lock2 = await navigator.wakeLock.request("screen");

%lock1.release();
%lock2.release();
</pre>
</div>

	</section>
【！Conformance】
	<section id="acknowledgments">
<h2 title="A. Acknowledgments">謝辞</h2>
◎非規範的

<p>
次に挙げる方々による，この作業に対する貢献に感謝したい
⇒
`Mounir Lamouri, Sergey Konstantinov, Matvey Larionov, Dominique Hazael-Massieux, Domenic Denicola, Thomas Steiner, Anne van Kesteren^en
◎
We would like to offer our sincere thanks to Mounir Lamouri, Sergey Konstantinov, Matvey Larionov, Dominique Hazael-Massieux, Domenic Denicola, Thomas Steiner, Anne van Kesteren for their contributions to this work.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

◎非規範的

<p>
この節は、
以前の公表からの変更点を文書化する。
◎
This section documents the changes since previous publications.
</p>
<dl>
	<dt id="changes-20171214">
2017年 12月 14日 勧告候補からの変更点
◎
B.1. Changes since the 14 December 2017 CR
</dt>
	<dd>
この文書【における~screen~wake種別】を~screen~wake~lockだけに絞って，
~system~lockを新たな仕様へ移動した。
◎
Convert the document to purely screen wake lock, and move system lock to a new specification.
</dd>
	<dd>
利用者~可視~APIを書き直した。
◎
Rewrite user-visible API.
</dd>
	<dd>
可視でなくなった文書を処するため、
`WakeLock.request()^c に
`中止されたとき＠~INFRA#if-aborted$の段を追加した。
【この変更に該当する箇所は、この仕様には無い（他の仕様に移動されたと思われる）】
◎
Add an if aborted step to WakeLock.request() to deal with hidden documents.
</dd>
	<dd>
~IDL索引を追加した。
◎
Add an IDL Index.
</dd>
	<dd>
重複な規範的な言明を除去した。
◎
Remove duplicate normative statements.
</dd>
	<dd>
各~例を現代化した。
◎
Modernize the examples.
</dd>
	<dd>
注釈文に代えて内部~slotを利用するようにした。
◎
Use internal slots instead of prose.
</dd>
	<dd>
~UAが いつ`~wake~lockを解放-＠#dfn-release-a-wake-lock$してもヨイとされるかに関する情報を追加した。
◎
Add info on when the user agent may release a wake lock.
</dd>
	<dd>
文書の可視性を取扱うようにした。
◎
Handle document visibility.
</dd>
	<dd>
`ScreenWakeLock^I を構築-可能にした。
◎
Make ScreenWakeLock constructable.
</dd>
	<dd>
任意選択な許可~prompt法を統合した。
◎
Integrate optional permission prompting.
</dd>
	<dd>
［
全部的に作動中でなくなった文書,
~worker内で走っている場合
］を取扱うようにした。
【が、~workerに関する記述は，この仕様~内には無い】
◎
Handle loss of full activity, as well as running in workers.
</dd>
	<dd>
§ 序論を書き直した。
◎
Rewrite the introduction section.
</dd>
	<dd>
`Feature Policy^en（特能~施策）を
`Permissions Policy^en（許可~施策）に改称した。
◎
Rename Feature Policy to Permissions Policy.
</dd>
	<dd>
`WakeLockSentinel.released^c
を追加した。
◎
Add WakeLockSentinel.released.
</dd>
	<dd>
この仕様における~task用の~task~sourceを定義した。
◎
Define a task source for tasks in this specification.
</dd>
</dl>

	</section>
</main></div>

