<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Semantics, structure, and APIs of HTML documents（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.xattr {
	font-family: monospace0, monospace;
	color: black;
}

@supports (column-width: 11em){
	.category-list {
		column-width: 11em;
	}
	.category-list > li {
		margin: 0;
		margin-left: 1em;
		break-inside: avoid-column;
		word-break: break-all;
	}
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'dom',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mE':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'hd':
	href = `~WAPI#handler-${key}`;
	break;
case 'a':
	text = text.slice(text.indexOf('.') + 1);
	break;
case 'eO': // obslete elem
	href = `~HTMLobs#${key}`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'xA': // xattr
	text = `[${key}]`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'U': 
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}


let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2023-02-06
trans_update:2023-02-07
source_checked:220211
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/dom.html
	abbr_url:HTMLdom
nav_prev:HTMLcloning
nav_next:HEmetadata
trans_1st_pub:2016-03-11


●●class_map
e:element
eO:element
a:attr
et:event-type
ps:pseudo
P:production
p:property
st:attr-state
css:css
v:value
E:error
jv:js-value
jc:js-class
sl:js-slot
jA:abstract
xA:xattr
sc:scheme
U:code-point
uc:char-prop
cn:cp-name

●●tag_map
I:code
I0:code
m:code
mE:code
mDSM:code
E:code
hd:code
c:code
e:code
eO:code
a:code
et:code
ps:code
st:span
P:code
p:code
css:code
jA:span
jv:code
jc:code
sl:span
xA:span
sc:code
U:span
uc:span
cn:span
v:code
V:var
i:i
cite:cite
em:em

●●original_id_map

dom-document-title:document.title

●●mdn_urls
document:API/Document
documentorshadowroot:API/DocumentOrShadowRoot
	documentreadystate:API/DocumentReadyState
domstringmap:API/DOMStringMap
htmlelement:API/HTMLElement
htmlpreelement:API/HTMLPreElement
	htmlorsvgscriptelement:API/HTMLOrSVGScriptElement
	htmlorsvgelement:API/HTMLOrSVGElement
htmlunknownelement:API/HTMLUnknownElement

classes:HTML/Global_attributes/class
attr-data-*:HTML/Global_attributes/data-*
attr-dir:HTML/Global_attributes/dir
the-id-attribute:HTML/Global_attributes/id
attr-lang:HTML/Global_attributes/lang
attr-slot:HTML/Global_attributes/slot
attr-style:HTML/Global_attributes/style
attr-title:HTML/Global_attributes/title
attr-translate:HTML/Global_attributes/translate

●●link_map



	●要素
e.a:~HEtextlevel#the-a-element
e.abbr:~HEtextlevel#the-abbr-element
e.b:~HEtextlevel#the-b-element
e.bdi:~HEtextlevel#the-bdi-element
e.bdo:~HEtextlevel#the-bdo-element
e.br:~HEtextlevel#the-br-element
e.cite:~HEtextlevel#the-cite-element
e.code:~HEtextlevel#the-code-element
e.data:~HEtextlevel#the-data-element
e.dfn:~HEtextlevel#the-dfn-element
e.em:~HEtextlevel#the-em-element
e.i:~HEtextlevel#the-i-element
e.kbd:~HEtextlevel#the-kbd-element
e.mark:~HEtextlevel#the-mark-element
e.q:~HEtextlevel#the-q-element
e.rt:~HEtextlevel#the-rt-element
e.ruby:~HEtextlevel#the-ruby-element
e.s:~HEtextlevel#the-s-element
e.samp:~HEtextlevel#the-samp-element
e.small:~HEtextlevel#the-small-element
e.span:~HEtextlevel#the-span-element
e.strong:~HEtextlevel#the-strong-element
e.sub:~HEtextlevel#the-sub-and-sup-elements
e.sup:~HEtextlevel#the-sub-and-sup-elements
e.time:~HEtextlevel#the-time-element
e.u:~HEtextlevel#the-u-element
e.var:~HEtextlevel#the-var-element
e.wbr:~HEtextlevel#the-wbr-element

e.blockquote:~HEgrouping#the-blockquote-element
e.div:~HEgrouping#the-div-element
e.dl:~HEgrouping#the-dl-element
e.figure:~HEgrouping#the-figure-element
e.hr:~HEgrouping#the-hr-element
e.li:~HEgrouping#the-li-element
e.main:~HEgrouping#the-main-element
e.menu:~HEgrouping#the-menu-element
e.ol:~HEgrouping#the-ol-element
e.p:~HEgrouping#the-p-element
e.pre:~HEgrouping#the-pre-element
e.ul:~HEgrouping#the-ul-element

e.del:~HEedits#the-del-element
e.ins:~HEedits#the-ins-element

e.address:~HEsections#the-address-element
e.article:~HEsections#the-article-element
e.aside:~HEsections#the-aside-element
e.body:~HEsections#the-body-element
e.footer:~HEsections#the-footer-element
e.header:~HEsections#the-header-element
e.hgroup:~HEsections#the-hgroup-element
e.nav:~HEsections#the-nav-element
e.section:~HEsections#the-section-element
e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h2:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h3:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h4:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h5:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h6:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements

e.base:~HEmetadata#the-base-element
e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element
e.title:~HEmetadata#the-title-element

e.noscript:~HEscripting#the-noscript-element
e.script:~HEscripting#the-script-element
e.slot:~HEscripting#the-slot-element
e.template:~HEscripting#the-template-element
e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.fieldset:~HEforms#the-fieldset-element
e.form:~HEforms#the-form-element
e.label:~HEforms#the-label-element
e.meter:~HEforms#the-meter-element
e.output:~HEforms#the-output-element
e.optgroup:~HEforms#the-optgroup-element
e.option:~HEforms#the-option-element
e.progress:~HEforms#the-progress-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element

e.area:~HEimages#the-area-element
e.img:~HEimages#the-img-element
e.map:~HEimages#the-map-element
e.picture:~HEimages#the-picture-element

e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.object:~HEembed#the-object-element

e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element
e.track:~HEtrack#the-track-element

e.table:~HEtables#the-table-element
e.td:~HEtables#the-td-element
e.th:~HEtables#the-th-element
e.tr:~HEtables#the-tr-element

~SVG-svg:~SVGstruct#SVGElement
~SVG-title:~SVGstruct#TitleElement
~SVG-script:~SVGinteract#ScriptElement
~MathML-math:https://www.w3.org/Math/draft-spec/chapter2.html#interf.toplevel


	●attr（global
a.accesskey:~HTMLinteraction#the-accesskey-attribute
a.aria-*:~HTMLdep#attr-aria-*
a.aria-label:~ARIA1#aria-label
a.autocapitalize:~HTMLinteraction#attr-autocapitalize
a.autofocus:~HTMLinteraction#attr-fe-autofocus
a.contenteditable:~HTMLinteraction#attr-contenteditable
a.class:#classes
a.data-*:#attr-data-*
a.data-:#attr-data-*
a.dir:#attr-dir
a.draggable:~HTMLdnd#attr-draggable
a.enterkeyhint:~HTMLinteraction#attr-enterkeyhint
a.hidden:~HTMLinteraction#attr-hidden
a.inert:~HTMLinteraction#the-inert-attribute
a.id:#the-id-attribute
a.inputmode:~HTMLinteraction#attr-inputmode
a.is:~HEcustom#attr-is
a.itemid:~HTMLLS/microdata.html#attr-itemid
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute
a.itemref:~HTMLLS/microdata.html#attr-itemref
a.itemscope:~HTMLLS/microdata.html#attr-itemscope
a.itemtype:~HTMLLS/microdata.html#attr-itemtype
a.lang:#attr-lang
a.nonce:~HTMLurl#attr-nonce
a.role:~HTMLdep#attr-aria-role
a.slot:#attr-slot
a.spellcheck:~HTMLinteraction#attr-spellcheck
a.style:#attr-style
a.tabindex:~HTMLinteraction#attr-tabindex
a.title:#attr-title
a.translate:#attr-translate
a.~xml_lang:#attr-xml-lang
a.~xml_space:~TR/xml/#sec-white-space

	●attr
a.th.abbr:~HEtables#attr-th-abbr
a.area.alt:~HEimages#attr-area-alt
a.dir.auto:#attr-dir-auto
a.meta.content:~HEmetadata#attr-meta-content
a.controls:~HEmedia#attr-media-controls
a.download:~HTMLlinks#attr-hyperlink-download
a.href:~HTMLlinks#attr-hyperlink-href
a.img.alt:~HEimages#attr-img-alt
a.input.alt:~HEinput#attr-input-alt
a.input.placeholder:~HEinput#attr-input-placeholder
a.meta.name:~HEmetadata#attr-meta-name
a.optgroup.label:~HEforms#attr-optgroup-label
a.option.label:~HEforms#attr-option-label
a.popover:~HTMLpopover#attr-popover
a.sandbox:~HEembed#attr-iframe-sandbox
a.srcdoc:~HEembed#attr-iframe-srcdoc
a.slot.name:~HEscripting#attr-slot-name
a.script.async:~HEscripting#attr-script-async
a.textarea.placeholder:~HEforms#attr-textarea-placeholder
a.track.label:~HEtrack#attr-track-label
a.type:~HEinput#attr-input-type
a.usemap:~HEimages#attr-hyperlink-usemap
a.value:~HEinput#attr-input-value

	●IDL
xA.HTMLConstructor:#htmlconstructor
HTMLConstructor:#htmlconstructor
CEReactions:~HEcustom#cereactions
LegacyOverrideBuiltIns:~WEBIDLjs#LegacyOverrideBuiltIns
LegacyUnforgeable:~WEBIDLjs#LegacyUnforgeable
LegacyLenientThis:~WEBIDLjs#LegacyLenientThis
LegacyNullToEmptyString:~WEBIDLjs#LegacyNullToEmptyString

I.CSSStyleDeclaration:~CSSOM1#the-cssstyledeclaration-interface
I.DocumentVisibilityState:#documentvisibilitystate
I.DOMStringMap:#domstringmap
I.DOMTokenList:~DOM4#interface-domtokenlist
I.Document:#document
I0.Document:~DOM4#interface-document
I.DocumentOrShadowRoot:#documentorshadowroot
I0.DocumentOrShadowRoot:~DOM4#documentorshadowroot
I.Element:~DOM4#interface-element
I.NodeList:~DOM4#interface-nodelist
I.Text:~DOM4#interface-text
I.DocumentReadyState:#documentreadystate
I.ElementContentEditable:~HTMLinteraction#elementcontenteditable
I.ElementInternals:~HEcustom#elementinternals
I.EventHandler:~WAPI#eventhandler
I.FocusOptions:~HTMLinteraction#focusoptions
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.HTMLCollection:~DOM4#interface-htmlcollection
I.HTMLElement:#htmlelement
I.HTMLButtonElement:~HEforms#htmlbuttonelement
I.HTMLPreElement:~HEgrouping#htmlpreelement
I.HTMLHeadElement:~HEmetadata#htmlheadelement
I.HTMLMenuElement:~HEgrouping#htmlmenuelement
I.HTMLScriptElement:~HEscripting#htmlscriptelement
I.SVGScriptElement:~SVGinteract#InterfaceSVGScriptElement
I.HTMLOrSVGScriptElement:#htmlorsvgscriptelement
I.HTMLOrSVGElement:#htmlorsvgelement

I.HTMLUnknownElement:#htmlunknownelement
I.Location:~WINDOW#location
I.Window:~WINDOW#window
I.WindowProxy:~HTMLWPROXY#windowproxy

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.CustomElementRegistry:~HEcustom#customelementregistry
I.HTMLParagraphElement:~HEgrouping#htmlparagraphelement
I.SVGElement:~SVGtypes#InterfaceSVGElement

I.Selection:~SELECTIONAPI#selection
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest

E.InvalidStateError:~WEBIDL#invalidstateerror
E.InvalidCharacterError:~WEBIDL#invalidcharactererror
E.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror
E.NoModificationAllowedError:~WEBIDL#nomodificationallowederror


	●IDL member
	＊m.HTMLElement:#dom-htmlelement

m.accessKey:~HTMLinteraction#dom-accesskey
m.accessKeyLabel:~HTMLinteraction#dom-accesskeylabel
m.activeElement:~HTMLinteraction#dom-documentorshadowroot-activeelement
m.attachInternals:~HEcustom#dom-attachinternals
m.autocapitalize:~HTMLinteraction#dom-autocapitalize
m.autofocus:~HTMLinteraction#dom-fe-autofocus
m.blur:~HTMLinteraction#dom-blur
m.body:#dom-document-body
m.click:~HTMLinteraction#dom-click
m.close:~HTMLdynamic#dom-document-close
m.cookie:#dom-document-cookie
m.createDocument:~DOM4#dom-domimplementation-createdocument
m.createHTMLDocument:~DOM4#dom-domimplementation-createhtmldocument
m.currentScript:#dom-document-currentscript
m.dataset:#dom-dataset
m.defaultView:~WINDOW#dom-document-defaultview
mE.dir:#dom-dir
m.dir:#dom-document-dir
m.domain:~ORIGIN#dom-document-domain
m.draggable:~HTMLdnd#dom-draggable
m.embeds:#dom-document-embeds
m.focus:~HTMLinteraction#dom-focus
m.forceSpellCheck:~HTMLinteraction#dom-forcespellcheck
m.forms:#dom-document-forms
m.getElementsByClassName:~DOM4#dom-document-getelementsbyclassname
m.getElementsByName:#dom-document-getelementsbyname
m.getter:#dom-document-nameditem
m.hasFocus:~HTMLinteraction#dom-document-hasfocus
m.head:#dom-document-head
mE.hidden:~HTMLinteraction#dom-hidden
m.hidden:~HTMLinteraction#dom-document-hidden
m.hidePopover:~HTMLpopover#dom-hidepopover
m.href:~WINDOW#dom-location-href
m.inert:~HTMLinteraction#dom-inert
m.innerText:#dom-innertext
m.images:#dom-document-images
m.lang:#dom-lang
m.lastModified:#dom-document-lastmodified
m.links:#dom-document-links
m.location:~WINDOW#dom-document-location
m.nonce:~HTMLurl#dom-noncedelement-nonce
m.open:~HTMLdynamic#dom-document-open
m.~openW:~HTMLdynamic#dom-document-open-window
m.onreadystatechange:~WAPI#handler-onreadystatechange
m.onvisibilitychange:~WAPI#handler-onvisibilitychange
m.outerText:#dom-outertext
m.plugins:#dom-document-plugins
m.popover:~HTMLpopover#dom-popover
m.pushState:~WINDOW#dom-history-pushstate
m.readyState:#dom-document-readystate
m.referrer:#dom-document-referrer
m.scripts:#dom-document-scripts
m.showPopover:~HTMLpopover#dom-showpopover
m.spellcheck:~HTMLinteraction#dom-spellcheck
m.togglePopover:~HTMLpopover#dom-togglepopover
m.style:~CSSOM1#dom-elementcssinlinestyle-style
m.tabIndex:~HTMLinteraction#dom-tabindex
mE.title:#dom-title
m.title:#dom-document-title
m.translate:#dom-translate
m.value:~DOM4#dom-domtokenlist-value
m.visibilityState:~HTMLinteraction#dom-document-visibilitystate
m.write:~HTMLdynamic#dom-document-write
m.writeln:~HTMLdynamic#dom-document-writeln
m.designMode:~HTMLinteraction#dom-document-designmode
m.document.domain:~ORIGIN#dom-document-domain

mDSM.deleter:#dom-domstringmap-removeitem
mDSM.getter:#dom-domstringmap-nameditem
mDSM.setter:#dom-domstringmap-setitem

m.execCommand:~EXEC-COMMAND#execcommand%28%29
m.queryCommandEnabled:~EXEC-COMMAND#dom-document-querycommandenabled%28%29
m.queryCommandIndeterm:~EXEC-COMMAND#dom-document-querycommandindeterm%28%29
m.queryCommandState:~EXEC-COMMAND#dom-document-querycommandstate%28%29
m.queryCommandSupported:~EXEC-COMMAND#dom-document-querycommandsupported%28%29
m.queryCommandValue:~EXEC-COMMAND#dom-document-querycommandvalue%28%29

	●event
et.volumechange:~HEmedia#event-media-volumechange
et.readystatechange:~HTMLindex#event-readystatechange
et.DOMContentLoaded:~HTMLindex#event-domcontentloaded

	●内容属性状態
st.翻訳不可:#no-translate
st.翻訳可能:#translate-enabled

st.~ltr:#attr-dir-ltr-state
st.~rtl:#attr-dir-rtl-state
st.自動:#attr-dir-auto-state

st.Button:~HEinput#button-state-(type=button)
st.Email:~HEinput#email-state-(type=email)
st.Hidden:~HEinput#hidden-state-(type=hidden)
st.Reset:~HEinput#reset-button-state-(type=reset)
st.Search:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Tel:~HEinput#telephone-state-(type=tel)
st.Text:~HEinput#text-(type=text)-state-and-search-state-(type=search)
st.Url:~HEinput#url-state-(type=url)

v.ltr:#attr-dir-ltr
v.rtl:#attr-dir-rtl
v.auto:#attr-dir-auto
v.noreferrer:~HTMLlinks#link-type-noreferrer

	●CSS
p.direction:~CSSWM#propdef-direction
p.unicode-bidi:~CSSWM#propdef-unicode-bidi
p.content:~CSSCONTENT#propdef-content
	p.content:~CSS22/generate.html#propdef-content
p.visibility:~CSSDISP#propdef-visibility
p.display:~CSSDISP#propdef-display
	p.white-space:~CSSTEXT#propdef-white-space
	p.text-transform:~CSSTEXT#propdef-text-transform

v.table-cell:~CSSTABLE#table-cell
v.table-row:~CSSTABLE#table-row
v.table:~CSSTABLE#table
v.table-caption:~CSSTABLE#table-caption
v.contents:~CSSDISP#valdef-display-contents
v.block:~CSSDISP#valdef-display-block

	●code 他

jv.NewTarget:~TC39#sec-built-in-function-objects
jA.GetFunctionRealm:~TC39#sec-getfunctionrealm
jA.Get:~TC39#sec-get-o-p
jA.Type:~TC39#sec-ecmascript-data-types-and-values
現在の~realm:~TC39#current-realm

h.Referrer-Policy:~REFERRER-POLICY#referrer-policy-header-dfn
h.Last-Modified:~HTTPsem#field.last-modified

P.Name:https://www.w3.org/TR/xml/#NT-Name
P.cookie-string:~HTTPcookie#p.cookie-string

sc.~about_blank:~HTMLdep#about:blank

c.text/html:~HTMLiana#text/html


	●用語
要素~名:#_named-element-name
文書:#the-document-object

表現-:#represents
参照-:#referenced
分類:#content-categories
分類-:#content-categories

内容~model:#content-models
内容:#concept-html-contents
見出し内容:#heading-content-2
埋込d内容:#embedded-content-category
~fallback内容:#fallback-content
~flow内容:#flow-content-2
対話的~内容:#interactive-content-2
~metadata内容:#metadata-content-2
句ng内容:#phrasing-content-2
~sectioning内容:#sectioning-content-2
可触~内容:#palpable-content-2
~text内容:#text-content
~text:#text-content
なし:#concept-content-nothing
透過的:#transparent

要素間~空白:#inter-element-whitespace
段落:#paragraph

~scriptを~supportする要素:#script-supporting-elements-2
~html要素:#the-html-element-2
~head要素:#the-head-element-2
~body要素:#the-body-element-2
~title要素:#the-title-element-2

	分類:#concept-element-categories
	この要素を利用できる文脈:#concept-element-contexts
	text/html における~tag省略:#concept-element-tag-omission
	内容~model:#concept-element-content-model
	内容~属性:#concept-element-attributes
	~accessibilityの考慮点:#concept-element-accessibility-considerations
	~DOM~interface:#concept-element-dom

doc.~referrer:#the-document's-referrer
doc.施策~容器:#concept-document-policy-container
doc.許可~施策:#concept-document-permissions-policy
doc.~module~map:#concept-document-module-map
doc.現在の準備度:#current-document-readiness
doc.非同一-生成元~opener施策:#concept-document-coop
doc.初期~about_blankか:#is-initial-about:blank
doc.~navi~ID:#concept-document-navigation-id

初期~about_blank な文書:#is-initial-about:blank

	doc.~URL:#the-document's-address
	doc.生成元:#concept-document-origin

有名~要素:#dom-document-nameditem-filter

~custom~data属性:#custom-data-attribute
作動中の構文解析器:#active-parser
助言的~情報:#advisory-information
反cookie文書:#cookie-averse-document-object

具現化された~textを収集する:#rendered-text-collection-steps
具現化される~text素片:#rendered-text-fragment
次の~text~nodeと併合する:#merge-with-the-next-text-node

言語:#language
~ltr:#concept-ltr
~rtl:#concept-rtl
属性の方向性:#directionality-of-the-attribute
方向性有りな属性:#directionality-capable-attribute
方向性:#the-directionality
公開されている:#exposed
	双方向-~algoを孕むような具現化~要件が課される:#bidireq

翻訳-可能な属性:#translatable-attributes
翻訳可能:#translate-enabled
翻訳~mode:#translation-mode


名値~pair~listを取得する:#concept-domstringmap-pairs
dsmap.要素:#concept-domstringmap-element


doc.前-文書の~unload計時~情報:#previous-document-unload-timing
doc.~load計時~情報:#load-timing-info
doc.非同一-生成元~redirectを介して作成されたか:#was-created-via-cross-origin-redirects

文書~load計時~情報:#document-load-timing-info
文書~unload計時~情報:#document-unload-timing-info
~navi開始~時刻:#navigation-start-time
~DOM対話的~時刻:#dom-interactive-time
~DOMContentLoaded~event開始~時刻:#dom-content-loaded-event-start-time
~DOMContentLoaded~event終了~時刻:#dom-content-loaded-event-end-time
~DOM完了-時刻:#dom-complete-time
~load~event開始~時刻:#load-event-start-time
~load~event終了~時刻:#load-event-end-time
~unload~event開始~時刻:#unload-event-start-time
~unload~event終了~時刻:#unload-event-end-time
文書の現在の準備度を更新する:#update-the-current-document-readiness

具現化を阻む要素の追加ngを許容して:#allows-adding-render-blocking-elements
doc.具現化を阻んでいる要素~群:#render-blocking-element-set
具現化は阻まれて:#render-blocked
具現化を阻んで:#render-blocking
具現化を阻む:#block-rendering
具現化を阻まなくする:#unblock-rendering

	●INFRA
実装定義:~INFRA#implementation-defined

~HTML名前空間:~INFRA#html-namespace
~SVG名前空間:~INFRA#svg-namespace
~XML名前空間:~INFRA#xml-namespace

~scalar値:~INFRA#scalar-value
非文字:~INFRA#noncharacter
~ASCII空白:~INFRA#ascii-whitespace
~ASCII大文字~化する:~INFRA#ascii-uppercase
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII英大文字:~INFRA#ascii-upper-alpha
~ASCII英小文字:~INFRA#ascii-lower-alpha
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII数字:~INFRA#ascii-digit
制御~文字:~INFRA#control
符号位置~並びを収集する:~INFRA#collect-a-sequence-of-code-points
~ASCII空白を剥いで縮約する:~INFRA#strip-and-collapse-ascii-whitespace
位置~変数:~INFRA#string-position-variable
文字列:~INFRA#string
str.長さ:~INFRA#string-length

~list:~INFRA#list
除去する:~INFRA#list-remove
置換する:~INFRA#list-replace
付加する:~INFRA#list-append
前付加する:~INFRA#list-prepend
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

~HTML要素:~HTMLINFRA#html-elements
~XML互換:~HTMLINFRA#xml-compatible
無視-:~HTMLINFRA#ignore
既知な値のみに制限される:~HTMLcdom#limited-to-only-known-values
~live:~HTMLINFRA#live
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications
	示唆される既定の具現化を~supportする:~HTMLINFRA#renderingUA
閲覧~文脈から切断された:~HTMLINFRA#becomes-browsing-context-disconnected

反映する:~HTMLcdom#reflect

要素~型:~HTMLINFRA#element-type

真偽-属性:~HTMLcms#boolean-attribute
列挙d属性:~HTMLcms#enumerated-attribute
妥当でない値~用の既定:~HTMLcms#invalid-value-default
値なし用の既定:~HTMLcms#missing-value-default
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens

階層的に正しく:~HEgrouping#hierarchically-correct-main-element

	●WEBIDL
有名~propの値を決定する:~WEBIDL#dfn-determine-the-value-of-a-named-property
~supportする~prop名:~WEBIDL#dfn-supported-property-names
有名~propを~supportする:~WEBIDL#dfn-support-named-properties
既存の有名~propを削除する:~WEBIDL#dfn-delete-an-existing-named-property
新たな有名~propの値を設定する:~WEBIDL#dfn-set-the-value-of-a-new-named-property
既存の有名~propの値を設定する:~WEBIDL#dfn-set-the-value-of-an-existing-named-property
拡張属性:~WEBIDL#dfn-extended-attribute
~interface~obj:~WEBIDLjs#dfn-interface-object
~interface~prototype~obj:~WEBIDLjs#dfn-interface-prototype-object
旧来の~factory関数:~WEBIDLjs#dfn-legacy-factory-function
	廃）有名~構築子:~WEBIDLjs#dfn-named-constructor
構築子~演算:~WEBIDL#idl-constructors
構築子を上書きする手続き:~WEBIDLjs#overridden-constructor-steps
~interfaceを実装する新たな~objを作成する:~WEBIDLjs#new
	~interfaceを実装する新たな~objを内部的に作成する:~WEBIDLjs#internally-create-a-new-object-implementing-the-interface

	●DOM4
文書~要素:~DOM4#document-element
親~要素:~DOM4#parent-element
~node文書:~DOM4#concept-node-document
~node:~DOM4#interface-node
~ID:~DOM4#concept-id
doc.生成元:~DOM4#concept-document-origin
doc.~URL:~DOM4#concept-document-url
doc.内容~型:~DOM4#concept-document-content-type
子~群:~DOM4#concept-tree-child
~HTML文書:~DOM4#html-document
~XML文書:~DOM4#xml-document
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order
~shadow~tree:~DOM4#concept-shadow-tree
根:~DOM4#concept-tree-root
広義-先祖:~DOM4#concept-tree-inclusive-ancestor
~tree内にある:~DOM4#in-a-document-tree
最初の子:~DOM4#concept-tree-first-child
次の同胞？:~DOM4#concept-tree-next-sibling
前の同胞？:~DOM4#concept-tree-previous-sibling
文書片:~DOM4#_concept-documentfragment
要素:~DOM4#interface-element
要素を作成する:~DOM4#concept-create-element
子を~nodeに置換する:~DOM4#concept-node-replace
~nodeを付加する:~DOM4#concept-node-append
~dataを置換する:~DOM4#concept-cd-replace
~nodeを除去する:~DOM4#concept-node-remove
cd.~data:~DOM4#concept-cd-data
~slot:~DOM4#concept-slot
~host:~DOM4#concept-documentfragment-host
割当する:~DOM4#assign-a-slot
割当される:~DOM4#assign-a-slot

要素~interface:~DOM4#concept-element-interface
名前空間:~DOM4#concept-element-namespace
名前空間~接頭辞:~DOM4#concept-element-namespace-prefix
局所~名:~DOM4#concept-element-local-name
属性~list:~DOM4#concept-element-attribute
~is0値:~DOM4#concept-element-is-value

属性を除去する:~DOM4#concept-element-attributes-remove
属性~値を設定する:~DOM4#concept-element-attributes-set-value
~custom要素~状態:~DOM4#concept-element-custom-element-state
~custom要素~定義:~DOM4#concept-element-custom-element-definition
全~内容を~nodeで置換する:~DOM4#concept-node-replace-all
全~内容を文字列に置換する:~DOM4#string-replace-all
範囲~obj:~DOM4#concept-range
~eventを発火する:~DOM4#concept-event-fire
子~text内容:~DOM4#concept-child-text-content
子孫~text内容:~DOM4#concept-descendant-text-content

	●URL, ENCODING
~UTF-8符号化する:~ENCODING#utf-8-encode
~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom

~URL:~URL1#concept-url
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
~HTTP_S~scheme:~FETCH#http-scheme


	●CSS
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
塊~level:~CSSDISP#block-level
行内~level:~CSSDISP#inline-level
具現化されて:~HTMLrendering#being-rendered
空白~処理:~CSSTEXT#white-space-processing
~text変形:~CSSTEXT#transforming
~style属性:~CSSSTYLEATTR#style-attribute
~CSS~box:~CSSDISP#box
塊~化:~CSSDISP#blockify
外縁~表示~型:~CSSDISP#outer-display-type
絶対的に位置され:~CSSPOS#absolute-position
浮動体:~CSS2VISUREN#floats

	●用語 HTML
	●WAPI
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~handler内容~属性:~WAPI#event-handler-content-attributes
~event~handler:~WAPI#event-handlers
~script:~WAPI#concept-script
設定群~obj:~WAPI#settings-object
~module~map:~WAPI#module-map
古典~script:~WAPI#classic-script
~module~script:~WAPI#module-script
現在の大域~obj:~WAPI#current-global-object
関連な大域~obj:~WAPI#concept-relevant-global

	●syntax
開始~tag:~HTMLwriting#syntax-start-tag
終了~tag:~HTMLwriting#syntax-end-tag
~void要素:~HTMLwriting#void-elements
~HTML構文解析器:~HTMLparsing#html-parser
x.~HTML構文:~HTMLwriting#writing
~HTML構文:~HTMLwriting#syntax
~XML構文:~HTMLxml#writing-xhtml-documents
x.中止-:~HTMLparsing#abort-a-parser
x.停止-:~HTMLparsing#stop-parsing
	x.省略可能~tag:~HTMLwriting#syntax-tag-omission
~load後~task用に準備済み:~HTMLparsing#ready-for-post-load-tasks


	●browsers
属する閲覧~文脈:~HTMLds#concept-document-bc
子~navigable:~HTMLds#child-navigable
内容~navigable:~HTMLds#content-navigable
nav.作動中の文書:~HTMLds#nav-document
nav.親:~HTMLds#nav-parent
nav.作動中の~WindowProxy:~HTMLds#nav-wp
nav.作動中の~WindowProxy:~HTMLds#nav-wp

結付けられている文書:~WINDOW#concept-document-window

一意~生成元に~sandbox化され:~ORIGIN#sandboxed-origin-browsing-context-flag
不透明な生成元:~ORIGIN#concept-origin-opaque
非同一-生成元~opener施策:~ORIGIN#cross-origin-opener-policy
施策~容器:~ORIGIN#policy-container

~navigate:~HTMLnav#navigate
~navi~ID:~HTMLnav#navigation-id
文書を作成して初期化する:~HTMLlifecycle#initialise-the-document-object

	●scripting
~custom化された組込みの要素:~HEcustom#customized-built-in-element
cD.名前:~HEcustom#concept-custom-element-definition-name
cD.~prototype:~HEcustom#concept-custom-element-definition-prototype
cD.構築~stack:~HEcustom#concept-custom-element-definition-construction-stack
cD.構築子:~HEcustom#concept-custom-element-definition-constructor
cD.局所~名:~HEcustom#concept-custom-element-definition-local-name

i.すでに構築-済みを表す~marker:~HEcustom#concept-already-constructed-marker
~custom要素~構築子:~HEcustom#custom-element-constructor
昇格:~HEcustom#upgrades
~custom要素:~HEcustom#custom-elements
自律的~custom要素:~HEcustom#autonomous-custom-element
不適合tに:~HEcustom#custom-element-conformance
妥当な~custom要素~名:~HEcustom#valid-custom-element-name
~native~accessibility意味論~map:~HEcustom#native-accessibility-semantics-map

~template内容:~HEscripting#template-contents

	●HTML他
他を阻む属性:~HTMLurl#blocking-attribute
具現化を阻む能性:~HTMLurl#potentially-render-blocking

~body内に許容される:~HEmetadata#allowed-in-the-body

~hyperlink:~HTMLlinks#hyperlink

x.値:~HTMLforms#concept-fe-value
~XML構文解析器:~HTMLxml#xml-parser
~media要素:~HEmedia#media-element
~microdata:~HTMLLS/microdata.html#microdata
~pragma集合の既定の言語:~HEmetadata#pragma-set-default-language

	§:~HTMLrendering#rendering
	§:~HTMLinteraction#editing
	§:~HTMLdynamic#dynamic-markup-insertion

	●他

許可~施策:~PERMISSIONS-POLICY#permissions-policy

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time

要素における~inline型の挙動は~CSPにより阻止されるべきか？:~CSP3#should-block-inline
作動中の関数~obj:~TC39#active-function-object


双方向-字種:#_Bidirectional_Character_Types
置換され:~CSSDISP#replaced-element
	非置換:~CSSDISP#non-replaced

●●words_table1

is0:<code class="attr">is</code> 
openW:open
xml_space:xml:space
xml_lang:xml:lang
lang: <code class="attr">lang</code> 
SVG-title:SVG <code class="element">title</code>
SVG-script:SVG <code class="element">script</code>
SVG-svg:SVG <code class="element">svg</code>
MathML-math:MathML <code class="element">math</code>
about_blank:about:blank

	text/html:text/html


●●words_table



	●IDL／js
accessor::::アクセサ
古典:classic::~::クラシック
clause:
template:::
prototype:
chain:
Record:
WindowProxy:
文字列化子:stringifier:~
拡張属性:extended attribute::~
	値なし:missing value
名値:name-value:名-値

	●custom
subclass::::下位クラス:サブクラス
superclass::::上位クラス:スーパークラス
marker::::マーカ
factory::::ファクトリ
	構築-済み:constructed
構築中の:being constructed::~::コンストラクト中の
自律的:autonomous::~
昇格:upgrade::~

	●構造
要素間:inter-element::~
	key
広義-:inclusive:~
切断-:disconnect::~

	●DOM ／内容

html:
head:
body:
title:

	~group分け:grouping
microdata::::マイクロデータ
outline::::アウトライン
slot::::
	スロット
可触:palpable::~
分類-:categorize::~
分類:category::~
	類別
	categories
	大~分類:broad categories
句:phrase::~
句ng:phrasing::句::フレージング
void:
section::::セクション
sectioning::section 化::セクション化
割当する:assignする::あてがう
割当され:assignされ::あてがわれ
併合-:merge:~

透過的:transparent::~
	段落~内:intra-paragraph
見出し:heading::~
	名前空間に属さない:namespace-less


	●構文
BOM:
camel-case:
	~camel-case化:camel-cased
	~hyphen化:hyphenate
soft::::ソフト
	~soft~hyphen:soft hyphen
underscore::::アンダースコア
dash::::ダッシュ
非文字:noncharacter:~
英大文字:upper alpha:~
小構文:microsyntax::~
	~tag付け:tagged
処理命令:processing instruction::~
縮約-:collapse:~
改行:line break::~
要改行数:required line break count:要 line break 数:~
剥いで:stripして:~

地域標準時:local time zone::~
最終改変:last-modification:~
日時:date and time:~
年t:year:年
日t:day:日
月t:month:月
時t:hours:時
秒t:seconds:秒
分t:minutes:分

自由形:free-form:~

	●処理
反復的:iterative:~
近過去:recent:~
準備度:readiness::~
時間切れ:timeout::~
割込まれ:interruptされ:割り込まれ
再入的:reentrant::~

同等性:equality:~
	空でない:non-empty
	unchanged
	置換され:non-replaced
連結-:concatenate:~
	concatenation
DOMContentLoaded:
load:
	~load後:post-load
unload:
高分解能:high resolution::~
追加ng:adding:追加
	今:now
	今や:now
	~LTE:has not exceeded

	●UI ／ CSS ／ 呈示
支援技術:assistive technology:~
blind:::目の不自由な
仮入力:placeholder::~
tablet::::タブレット
typography::::タイポグラフィ
pointing::::ポインタ指示
bar::::バー
screen-reader:screen reader:::スクリーンリーダ
touch::::タッチ
tooltip::::ツールチップ
German::::ドイツ語
Arabic::::アラビア語
Belarusian::::ベラルーシ語
headphone::::ヘッドフォン
	simulator::::シミュレータ
role:
	~accessibility~API:Accessibility API
picker:::選択 UI
popover:
翻訳-:translate::~
	翻訳-可能:translatable
翻訳:translation::~
翻訳不可:no-translate::~
翻訳可能:translate-enabled::~


発音:pronunciation::~
双方向-:bidirectional::~
方向的:directional::~
方向性有り:directionality-capable::~
字種:character type::~
声:voice::~
発話:speech::~
合成:synthesis::~
地域化-:localize::~::ローカル化
読上げる:readする:読み上げる
音量:volume:~
文章:sentence:文
重合する:overlapする::重なり合う
展開-:expand:~
	expansion

	●CSS
	style付け:styling
約物:punctuation::~
右横書き:right-to-left::~
左横書き:left-to-right::~
ltr:::左横書き
rtl:::右横書き
太字:bold:~

浮動体:float::~
相殺:collapsing::~
	margin-collapsing
	行末の:at the end of lines
	行:line

	●network/security
HTTP_S:HTTP(S) 
反cookie:cookie-averse::反 cookie
	~server側:server-side

	online::::オンライン
	阻止される^i:Blocked
取込む:importする:取り込む
	読込n後:post-load:
不透明な:opaque:~
opener:::open 元

	●仕様
desktop::::デスクトップ
software::::ソフト
	さらに〜課す:extra
thema::::テーマ
	~themaによる:thematic
正当:legitimate:~
混成的:hybrid:~
私的:private:~
事実:fact:~
	mutually compatible
荒削り:crude:~
木目細かな:fine-grainedな:~
護符:talisman:~
	相違:differences
管理者:administrator:~
論題:topic:~
悲惨:disastrous:~
機械:machine:~
解決策:solution:~
問題m:matter:問題
間違った:wrongな:~
不明瞭に:straddle:~
指示書き:instructions:~
供与-:contribute:~
	confusingly
免除-:exempt:~
移行:migration:~
想定-:suppose:~
誤用-:mis-use:~
誤解釈-:misinterpret:~
警告-:warn:~
表出能:expressivity:~
能性:potential:~

	真っ直ぐ:linear
	簡便に記せるよう:convenience
	公に利用-可能:publicly-usable
	ある意味似た:reminiscent
	よる:induce
	すなわち:namely
	明らかに:clearly
	特に:most notably
	~~理解:comprehensible
	言えない:admittedly
	難しく:hard
	実は:really
	より高~levelの:higher-level
	まったく:truly
	一助:tool to help
	万能:panacea
	乏しい:poorly
	ヒトから読まれる:human-readable
	容易に:mildly easier
	著しく:quite
	意外な:surprising
	事足りる:suffice
	示して:depicted
	図:figure
	適合しない／適合でない:non-conforming
	〜に言えば:〜 speaking,
	調べる:looks at
	称され:called
	も含意する:One implication of
	何らかの~~固有な:their

	●未分類
埋めら:fillさ:~
増分:increment:~
形式変換:transform:~
変形:transform:~
省略:omission:~
往来-:round-trip:~
封入-:enclose:~
検査後の:checkout:~
	detection
参照r:refer:参照

ARIA:
cell::::セル
絞込む:filterする::絞り込む
game::::ゲーム
pragma:::
	~pragmaにより設定される:pragma-set
album::::アルバム
局所名:localname::~::ローカル名

種類:kind:~
素早く:quickに:~
	~~直行:quick
連なり:run::~
重複:duplicate:~
冗長:redundant:~
帯域外の:out of band:~
会話:conversation:~
作品:work:~
衝突:clash:~
製品:product:~
携帯端末:mobile phone::~
並列処理:multiprocess:~
自動:auto::~
署名行:byline:~
引用元:citation:~
詩:poem:~
音楽:music:~
曲:track::曲::トラック
credit:::
企業:corporate:~
基礎:basis:~
連続する:consecutiveな:~
現在:currently:~


	なりすます:impersonate
	まま:leave
	アップグレード:upgrade
	伝える:inform
	伝える／判る:tell
	判るように:would not be discoverable
	書-:write
	注意すべき点がある:Caution is advised with
	始-:begin
	後続-／従う:follow
	戻-:back
	括って:put
	易くする:help
	注目して:focused on
	現れさせ:appear
	終え:finish:
	結果になる:end up
	聴ける:hear
	見:looking
	見かけ:look 
	見かけ:look like
	記す:denote
	開く:open する
	飛ぶ:jump
	巡回:navigate around
	そらす:lateral

	compared
	consisting
	knew
	know
	letting
	become
	come
	~~無効化され:dropped
	該当:fall into
	:followed by
	goes
	having
	left
	making
	note
	noted
	notice
	選ぼ:pick
	play
	remain
	said
	say
	span
	:want
	0 を前置:zero-padded
	~~隣接する:preceded or followed
	属する:belong
	利用でき:usable
	~table用の:tabular
	とり得る~~範囲:exact value
	終端-:end
	もある:possible
	片:fragment
	interact
	~hidden
	簡略化するため:for simplicity
	地点:point
	-:certain number
	-:hyphen
	-:space ship
	AL
	BCP 47
	Browser
	Embedded
	Ernest
	LF
	LINE FEED
	MathML
	Mellblom
	Metadata
	MyTrans
	Paragraph Level
	Paragraph:
	Reset Button
	SPACE
	Search
	XSLT
	Button
	POP DIRECTIONAL FORMATTING
	POP DIRECTIONAL ISOLATE
	R
	RDF
	anywhere
	despite
	moment
	孤立している:orphan
	potential
	potentially
	proud
	~alternative
	~alternatively
	~around:
	~basically
	~broad
	~indeed
	~line
	~merely

	~noncharacter
	~onto
	~part
	~per
	~ready
	~rest
	~right
	~scriptを~supportする:script-supporting
	~true
	~tuple
	重ねて／:twice
	知らずに:unknowingly
	~very
	~wide

	~~らしきもの:sense
	~~内側の:inner-most
	~~情報を~~交換しあって working in unison communicated
	~~手段:resort:
	~~文章:quote
	~~最後の:final
	†:asterisk


	より低速:slower

	同じ節の副~見出し:subheading or subtitle (a subordinate heading for the same section)
	大きい:large
	字:letter
	存続する:lifetime
	小さい:small
	数:number
	猫:cat
	等しく:equally
	脚注:footnote
	複雑に:complicate
	解説:commentary

	●指示語
	anyone
	anything
	neither
	non
	nor
	ever
	everything
	~my
	またがって／:across
	まとめる:together
	一節:stanza
	半分:half of
	の他にも:beyond
	の他にも:even beyond
	-:third
	他にもあるThat's not all, either	'
	他の部分:the rest
	以前の:previous
	何ら:absolutely no:
	先掲の:the earlier
	先頭:at the front
	全体:entirely
	前述の:aforementioned
	多様な:wide variety
	後で:later
	時点:instant in time
	最も近い:nearest
	次:next
	種々の:various
	を除く:apart from
	前-:previous
	でもある:types of

	●変数
	%文書:-
	%~cookie値:-
	%文書~要素:document element
	%html:-
	%値:-
	%値:value
	%title:-
	%head:-
	%body:-
	%要素:-
	%要素:element
	%要素:el
	%名前:name
	%要素~群:elements
	%B:-
	%A:-
	%registry:-
	%定義:definition
	%~is0値:is value
	%~prototype:prototype
	%~realm:realm
	%slot:-
	%~node:node
	%先祖:-
	%状態:-
	%文字列:-
	%文字:-
	%T:-
	%属性:-
	%O:-
	%~list:list
	%C:-
	%~item~list:results
	%子:-
	%文字列~item:-
	%要改行数:-
	%素片:fragment
	%入力:input
	%位置:position
	%~text:text
	%~map
	%状態または~prop:stateOrProperty
	%準備度~値:readinessValue
	%B:browsingContext
	%次の同胞:next
	%前-:previous
	%前の同胞:previous
	

●●html_code_list

■document-1
<svg xmlns="http://www.w3.org/2000/svg">
 <％script>
  document.body = document.createElementNS("http://www.w3.org/1999/xhtml", "body");
  console.assert(document.body === null);
 </％script>
</svg>

■elements-1
<!DOCTYPE HTML>
<html lang="ja">
<html>
 <head>
  <title>俺のページ</title>
 </head>
 <body>
  <h1>俺のページに来たか。</h1>
  <p>俺はでかいの好きやねん！アレとか持ってるで。</p>
  <h2>俺の住処</h2>
  <p>ちっこい山小屋…。</p>
 </body>
</html>

<!DOCTYPE HTML>
<html lang="en">
 <head>
  <title>My Page</title>
 </head>
 <body>
  <h1>Welcome to my page</h1>
  <p>I like cars and lorries and have a big Jeep!</p>
  <h2>Where I live</h2>
  <p>I live in a small hut on a mountain!</p>
 </body>
</html>

■elements-2 bad
<body>
 <h1>ACME （株）</h1>
 <h2>創業 1920 年、業界一の迅速配達</h2>
 ...

<body>
 <h1>ACME Corporation</h1>
 <h2>The leaders in arbitrary fast delivery since 1920</h2>
 ...


■elements-3
<body>
 <hgroup>
  <h1>ACME （株）</h1>
  <p>創業 1920 年、業界一の迅速配達</p>
 </hgroup>
 ...

<body>
 <hgroup>
  <h1>ACME Corporation</h1>
  <p>The leaders in arbitrary fast delivery since 1920</p>
 </hgroup>
 ...

■elements-4 bad
<!DOCTYPE HTML>
<html lang="ja">
 <head> <title> 実例 </title> </head>
 <body>
  <table>
   <tr> <td> 私は猫が好きだ。 </td> </tr>
   <tr>
    <td>
     —<a href="https://example.org/~ernest/"><cite>アーネスト</cite></a>,
     1992 年の随筆から
    </td>
   </tr>
  </table>
 </body>
</html>

<!DOCTYPE HTML>
<html lang="en-GB">
 <head> <title> Demonstration </title> </head>
 <body>
  <table>
   <tr> <td> My favourite animal is the cat. </td> </tr>
   <tr>
    <td>
     —<a href="https://example.org/~ernest/"><cite>Ernest</cite></a>,
     in an essay from 1992
    </td>
   </tr>
  </table>
 </body>
</html>


■elements-5
<!DOCTYPE HTML>
<html lang="ja">
 <head> <title> 実例 </title> </head>
 <body>
  <blockquote>
   <p> 私は猫が好きだ。 </p>
  </blockquote>
  <p>
   —<a href="https://example.org/~ernest/">アーネスト</a>,
   1992 年の随筆から
  </p>
 </body>
</html>


<!DOCTYPE HTML>
<html lang="en-GB">
 <head> <title> Demonstration </title> </head>
 <body>
  <blockquote>
   <p> My favourite animal is the cat. </p>
  </blockquote>
  <p>
   —<a href="https://example.org/~ernest/">Ernest</a>,
   in an essay from 1992
  </p>
 </body>
</html>


■elements-6 bad
<label>カーペット： <input type="carpet" name="c" texture="deep pile"></label>

<label>Carpet: <input type="carpet" name="c" texture="deep pile"></label>


■elements-7
<label>カーペット： <input type="text" class="carpet" name="c" data-texture="deep pile"></label>

<label>Carpet: <input type="text" class="carpet" name="c" data-texture="deep pile"></label>

■elements-8
<template>
 <article>
  <img ＜src="{{src}}" alt="{{alt}}"＞>
  <h1></h1>
 </article>
</template>

■elements-in-the-dom-1
<figure id="module-script-graph">
  <img src="module-script-graph.svg"
       alt="モジュール A は モジュール B に依存し, B は C, D に依存する。">
  <figcaption>図 27. 単純なモジュールグラフ</figcaption>
</figure>

<figure id="module-script-graph">
  <img src="module-script-graph.svg"
       alt="Module A depends on module B, which depends
            on modules C and D.">
  <figcaption>Figure 27: a simple module graph</figcaption>
</figure>

■elements-in-the-dom-2
<a href="#module-script-graph">図 27</a> に見られるように、…

As we can see in <a href="#module-script-graph">figure 27</a>, ...

■metadata-1
<html
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:r="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
      xml:lang="en"
>
 <head>
  <title>Hedral's Home Page</title>
  <r:RDF>
   <Person xmlns="http://www.w3.org/2000/10/swap/pim/contact#"
           r:about="https://hedral.example.com/#">
    <fullName>Cat Hedral</fullName>
    <mailbox r:resource="mailto:hedral@damowmow.com"/>
    <personalTitle>Sir</personalTitle>
   </Person>
  </r:RDF>
 </head>
 <body>
  <h1>My home page</h1>
  <p>I like playing with string, I guess. Sister says squirrels are fun
  too so sometimes I follow her to play with them.</p>
 </body>
</html>

'

■transparent-1
<p><object><param><ins><map><a href="/">りんご</a></map></ins></object></p>

Apples

■paragraph-1
<section>
  <h2>段落の例</h2>
  この例の <em>1 個目の</em>段落がここにある。
  <p>これは 2 個目の段落。</p>
  <!-- これは段落でない。 -->
</section>

<section>
  <h2>Example of paragraphs</h2>
  This is the <em>first</em> paragraph in this example.
  <p>This is the second.</p>
  <!-- This is not a paragraph. -->
</section>


■paragraph-2
<section>
  <ins><h2>段落の例</h2>
  この例の <em>1 個目の</em>段落が</ins>ここにある<del>。
  <p>これは 2 個目の段落。</p></del>
  <!-- これは段落でない。 -->
</section>

<section>
  <ins><h2>Example of paragraphs</h2>
  This is the <em>first</em> paragraph in</ins> this example<del>.
  <p>This is the second.</p></del>
  <!-- This is not a paragraph. -->
</section>

■paragraph-3
<header>
 ようこそ！
 <a href="about.html">
  ここは、ロッキード社のマルチロール戦闘機 F-16、通称
  <h1>Fighting Falcon</h1>
  のページです。
 </a>
 ここでは F-16 Fighting Falcon の知られざる秘密を探っていきます。
</header>


<header>
 Welcome!
 <a href="about.html">
  This is home of...
  <h1>The Falcons!</h1>
  The Lockheed Martin multirole jet fighter aircraft!
 </a>
 This page discusses the F-16 Fighting Falcon's innermost secrets.
</header>
'

■paragraph-4
<header>
 <p>ようこそ！
 <a href="about.html">ここは、ロッキード社のマルチロール戦闘機 F-16、通称</a></p>
 <h1><a href="about.html">Fighting Falcon</a></h1>
 <p><a href="about.html">のページです。</a>
 ここでは F-16 Fighting Falcon の知られざる秘密を探っていきます。</p>
</header>


<header>
 <p>Welcome! <a href="about.html">This is home of...</a></p>
 <h1><a href="about.html">The Falcons!</a></h1>
 <p><a href="about.html">The Lockheed Martin multirole jet
 fighter aircraft!</a> This page discusses the F-16 Fighting
 Falcon's innermost secrets.</p>
</header>
'

■paragraph-5
<section>
 <h2>猫で遊ぼう</h2>
 猫シミュレータで遊びませんか。
 <object data="cats.sim">
  猫シミュレータは、次のリンクから遊べます：
  <ul>
   <li><a href="cats.sim">シミュレータ ファイルをダウンロードする</a>
   <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">オンライン シミュレータを利用する</a>
  </ul>
  Mellblom ブラウザは最新版にアップグレードすることをすすめます。
 </object>
 面白いから是非！
</section>

<section>
 <h2>My Cats</h2>
 You can play with my cat simulator.
 <object data="cats.sim">
  To see the cat simulator, use one of the following links:
  <ul>
   <li><a href="cats.sim">Download simulator file</a>
   <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator</a>
  </ul>
  Alternatively, upgrade to the Mellblom Browser.
 </object>
 I'm quite proud of it.
</section>
'

■paragraph-6
<section>
 <h2>猫で遊ぼう</h2>
 <p>猫シミュレータで遊びませんか。</p>
 <object data="cats.sim">
  <p>猫シミュレータは、次のリンクから遊べます：</p>
  <ul>
   <li><a href="cats.sim">シミュレータ ファイルをダウンロードする</a>
   <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">オンライン シミュレータを利用する</a>
  </ul>
  <p>Mellblom ブラウザは最新版にアップグレードすることをすすめます。</p>
 </object>
 <p>面白いから是非！</p>
</section>

<section>
 <h2>My Cats</h2>
 <p>You can play with my cat simulator.</p>
 <object data="cats.sim">
  <p>To see the cat simulator, use one of the following links:</p>
  <ul>
   <li><a href="cats.sim">Download simulator file</a>
   <li><a href="https://sims.example.com/watch?v=LYds5xY4INU">Use online simulator</a>
  </ul>
  <p>Alternatively, upgrade to the Mellblom Browser.</p>
 </object>
 <p>I'm quite proud of it.</p>
</section>
'

■global-attr-1 bad
<div xmlns="http://www.w3.org/1999/xhtml" dir="rtl">
 <bogus xmlns="https://example.net/ns" dir="ltr">
  <span xmlns="http://www.w3.org/1999/xhtml">
  </span>
 </bogus>
</div>

■title-1 bad
<p>今日における <abbr title="＜Hypertext
Transport Protocol＞">HTTP</abbr> には、多方からの関心があることがログから見て取れる。</p>

<p>My logs show that there was some interest in <abbr title="Hypertext
Transport Protocol">HTTP</abbr> today.</p>

■dir-1
<p dir=auto class="u1"><b><bdi>Student</bdi>:</b> How do you write "What's your name?" in Arabic?</p>
<p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> ما اسمك؟</p>
<p dir=auto class="u1"><b><bdi>Student</bdi>:</b> Thanks.</p>
<p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> That's written "شكرًا".</p>
<p dir=auto class="u2"><b><bdi>Teacher</bdi>:</b> Do you know how to write "Please"?</p>
<p dir=auto class="u1"><b><bdi>Student</bdi>:</b> "من فضلك", right?</p>

'

■style-1
<p>私の服は<span style="＜color: green;＞ background:
transparent">緑色</span>で、目は<span style="＜color: blue;＞
background: transparent">青色</span>です。</p>

■data-1
<ol>
 <li data-length="2m11s">海の彼方に</li>
 ...
</ol>

Beyond The Sea

■data-2
<p>The third <span ＜data-mytrans-de="Anspruch"＞>claim</span> covers the case of <span ＜translate="no"＞>HTML</span> markup.</p>

■data-3
<％script>
if ('PaymentRequest' in window) {
  document.documentElement.dataset.hasPaymentRequest = '';
}
<％/script>


■data-spaceship
<div
  class="spaceship"
  data-ship-id="92432"
  data-weapons="laser 2"
  data-shields="50%"
  data-x="30"
  data-y="10"
  data-z="90"
>
  <button
    class="fire"
    onclick="spaceships[this.parentNode.dataset.shipId].fire()"
  >撃つ</button>
</div>

Fire

■data-tower
<img
  class="tower"
  id="tower5"
  data-x="12"
  data-y="5"
  data-ai="robotarget"
  data-hp="46"
  data-ability="flames"
  src="towers/rocket.png"
  alt="Rocket Tower"
>

●●images
＠HTML-resources/
im｜height:157px; width:366px;｜｜.png

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Semantics, structure, and APIs of HTML documents</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — HTML 文書の意味論, 構造, API</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="dom">
<h2 title="Semantics, structure, and APIs of HTML documents">3. ~HTML文書の意味論, 構造, ~API</h2>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IF, ~THROW, 等々）の意味や定義の詳細は、
~SYMBOL_DEF_REFを~~参照されたし。
</p>

		</section>
		<section id="documents">
<h3 title="Documents">3.1. 文書</h3>

<p>
~HTML~UAにおける どの［
~XML／~HTML
］文書も， `Document$I ~obj
— 以下，単に`文書$と略記する —
により表現される。
`DOM$r
◎
Every XML and HTML document in an HTML UA is represented by a Document object. [DOM]
</p>

<p>
`文書$ %文書 の
<dfn id="the-document's-address">`~URL$doc</dfn>
は、
`DOM$r にて定義される。
それは、
%文書 の作成-時に設定され，
%文書 が存続する間に変化し得る
— 例えば、
次に挙げるとき
⇒＃
利用者が~page上の`素片へ＠~HTMLnav#navigate-fragid$`~navigate$するとき／
新たな`~URL$を渡して `pushState()$m ~methodが~callされるとき
◎
The Document object's URL is defined in DOM. It is initially set when the Document object is created, but can change during the lifetime of the Document object; for example, it changes when the user navigates to a fragment on the page and when the pushState() method is called with a new URL. [DOM]
</p>

<p class="warning">
対話的~UAは、
概して，自身の~UIにて`文書$の`~URL$docを公開する。
これは、
~siteが別の何かになりすまそうと試みたとき，
そのことが利用者に判るようにする首な仕組みである。
◎
Interactive user agents typically expose the Document object's URL in their user interface. This is the primary mechanism by which a user can tell if a site is attempting to impersonate another.
</p>

<p>
`文書$ %文書 の
<dfn id="concept-document-origin">`生成元$doc</dfn>
は、
`DOM$r にて定義される。
それは、
%文書 の作成-時に設定され，
%文書 が存続する間 `document.domain$m が設定されたときに限り変化し得る。
%文書 の`生成元$docは、
%文書 の`~URL$docの`生成元$urlと相違することもある。
例えば，`子~navigable$ %N の`作成-時^には、［
%N にて`作動中の文書$navの`生成元$doc
］は［
%N の`親$navにて`作動中の文書$navの`生成元$doc
］を継承する
— 前者の文書の`~URL$docが `~about_blank$sc であっても。
◎
The Document object's origin is defined in DOM. It is initially set when the Document object is created, and can change during the lifetime of the Document only upon setting document.domain. A Document's origin can differ from the origin of its URL; for example when a child navigable is created, its active document's origin is inherited from its parent's active document's origin, even though its active document's URL is about:blank. [DOM]
</p>

<p>
`文書$が`~script$により［
`createDocument()$m ／
`createHTMLDocument()$m
］~methodを利用して作成されたときは、
即時に，`~load後~task用に準備済み$になる。
◎
When a Document is created by a script using the createDocument() or createHTMLDocument() methods, the Document is ready for post-load tasks immediately.
</p>

<p>
`文書$の
`~referrer@doc
とは、
（ `~URL$を表現する）文字列であり，
`文書$の作成-時に設定され得る。
明示的に設定されない場合の値は、
空~文字列とする。
◎
The document's referrer is a string (representing a URL) that can be set when the Document is created. If it is not explicitly set, then its value is the empty string.
</p>

			<section id="the-document-object">
<h4 title="The Document object">3.1.1. `Document^I ~obj</h4>

<p>
この仕様は、
`DOM$r にて定義される `Document$I0 ~interfaceを有意に拡張する。
◎
DOM defines a Document interface, which this specification extends significantly.
</p>

<p class="trans-note">【
この訳では、
ここに定義される `Document$I ~interfaceを実装する~objを単に
<dfn>文書</dfn>
とも略記する。
この略記は、
この~pageに限らず，この仕様の他の~pageの和訳でも利用される
— この節を指す~linkが付与された “`文書$” は、
`Document$I ~objを表すとする
（~HTML／~XML構文で書かれた資源としての文書ではなく）。
】</p>

<pre class="idl">
enum `DocumentReadyState@I { "loading", "interactive", "complete" };
enum `DocumentVisibilityState@I { "visible", "hidden" };
typedef (`HTMLScriptElement$I or `SVGScriptElement$I) `HTMLOrSVGScriptElement@I;

[`LegacyOverrideBuiltIns$]
partial interface `Document@I {
  // <span class="comment">
`資源~metadata管理＠#resource-metadata-management$
◎
// resource metadata management
</span>
  [PutForwards=`href$m, `LegacyUnforgeable$] readonly attribute `Location$I? `location$m;
  attribute USVString `domain$m;
  readonly attribute USVString `referrer$m;
  attribute USVString `cookie$m;
  readonly attribute DOMString `lastModified$m;
  readonly attribute `DocumentReadyState$I `readyState$m;

  // <span class="comment">
`~DOM~tree~accessor＠#dom-tree-accessors$
◎
// DOM tree accessors
</span>
  `getter$m object (DOMString name);
  [`CEReactions$] attribute DOMString `title$m;
  [`CEReactions$] attribute DOMString `dir$m;
  [`CEReactions$] attribute `HTMLElement$I? `body$m;
  readonly attribute `HTMLHeadElement$I? `head$m;
  [SameObject] readonly attribute `HTMLCollection$I `images$m;
  [SameObject] readonly attribute `HTMLCollection$I `embeds$m;
  [SameObject] readonly attribute `HTMLCollection$I `plugins$m;
  [SameObject] readonly attribute `HTMLCollection$I `links$m;
  [SameObject] readonly attribute `HTMLCollection$I `forms$m;
  [SameObject] readonly attribute `HTMLCollection$I `scripts$m;
  NodeList `getElementsByName$m(DOMString %elementName);
  readonly attribute `HTMLOrSVGScriptElement$I? `currentScript$m;  /* <span class="comment">
文書~tree内の`古典~script$のみ
◎
classic scripts in a document tree only
</span> */

  /* <span class="comment">
`動的~markup挿入＠~HTMLdynamic#dynamic-markup-insertion$
◎
dynamic markup insertion
</span> */
  [`CEReactions$] `Document$I `open$m(optional DOMString %unused1, optional DOMString %unused2); /* <span class="comment">
両~引数とも無視される
◎
both arguments are ignored
</span> */
  `WindowProxy$I? `~openW$m(USVString %url, DOMString %name, DOMString %features);
  [`CEReactions$] undefined `close$m();
  [`CEReactions$] undefined `write$m(DOMString... %text);
  [`CEReactions$] undefined `writeln$m(DOMString... %text);

  /* <span class="comment">
`利用者~対話＠~HTMLinteraction#editing$
</span> */
  readonly attribute `WindowProxy$I? `defaultView$m;
  boolean `hasFocus$m();
  [`CEReactions$] attribute DOMString `designMode$m;
  [`CEReactions$] boolean `execCommand$m(DOMString %commandId, optional boolean %showUI = false, optional DOMString %value = "");
  boolean `queryCommandEnabled$m(DOMString %commandId);
  boolean `queryCommandIndeterm$m(DOMString %commandId);
  boolean `queryCommandState$m(DOMString %commandId);
  boolean `queryCommandSupported$m(DOMString %commandId);
  DOMString `queryCommandValue$m(DOMString %commandId);
  readonly attribute boolean `hidden$m;
  readonly attribute `DocumentVisibilityState$I `visibilityState$m;

  /* <span class="comment">
`文書$のみに適用される特別な`~event~handler~IDL属性$
◎
special event handler IDL attributes that only apply to Document objects
</span> */
  [`LegacyLenientThis$] attribute `EventHandler$I `onreadystatechange$m;
  attribute `EventHandler$I `onvisibilitychange$m;

  /* <span class="comment">
`廃用にされた~memberもある＠~HTMLLS/obsolete.html#Document-partial$
◎
also has obsolete members
</span> */
};
`Document$I includes `GlobalEventHandlers$I;
</pre>

<p>
各`文書$は、
次に挙げるものを持つ：
◎
↓</p>
<ul>
	<li>
`施策~容器@doc
⇒
`施策~容器$
— 初期~時は新たな`施策~容器$とする。
これは、
当の`文書$に適用される施策を包含する。
◎
Each Document has a policy container＼
(a policy container), initially a new policy container, which contains policies which apply to the Document.
</li>
	<li>
`許可~施策@doc
⇒
`許可~施策$
— 初期~時は空とする。
◎
Each Document has a permissions policy,＼
which is a permissions policy, which is initially empty.
</li>
	<li>
`~module~map@doc
⇒
`~module~map$
— 初期~時は空とする。
◎
Each Document has a module map,＼
which is a module map, initially empty.
</li>
	<li>
`非同一-生成元~opener施策@doc
⇒
`非同一-生成元~opener施策$
— 初期~時は新たな非同一-生成元~opener施策とする。
◎
Each Document has a cross-origin opener policy,＼
which is a cross-origin opener policy, initially a new cross-origin opener policy.
</li>
	<li>
`初期~about_blankか@doc
（ `is initial about:blank^en ）
⇒
真偽値
— 初期~時は ~F とする。
【この値が ~T をとる`文書$は、 “初期~about_blank な文書” とも称される。】
◎
Each Document has an is initial about:blank,＼
which is a boolean, initially false.
</li>
	<li>
`~navi~ID@doc
⇒
`~navi~ID$ ／ ~NULL
— 初期~時は ~NULL とする。
◎
Each Document has a navigation id,＼
which is a navigation ID or null, initially null.
</li>
</ul>

			</section>
			<section id="the-documentorshadowroot-interface">
<h4 title="The DocumentOrShadowRoot interface">3.1.2. `DocumentOrShadowRoot^I ~interface</h4>

<p>
この仕様は、
`DOM$r にて定義される `DocumentOrShadowRoot$I0 ~mixinを拡張する：
◎
DOM defines the DocumentOrShadowRoot mixin, which this specification extends.
</p>

<pre class="idl">
partial interface mixin `DocumentOrShadowRoot@I {
  readonly attribute `Element$I? `activeElement$m;
};
</pre>

			</section>
			<section id="resource-metadata-management">
<h4 title="Resource metadata management">3.1.3. 資源~metadataの管理</h4>

<dl class="domintro">
	<dt>%document.`referrer$m</dt>
	<dd>
利用者がこの文書へ~navigateした~~元の`文書$の`~URL$docを返す。
~navigateが阻止されていたときや，そのような文書がなければ空~文字列を返す。
◎
Returns the URL of the Document from which the user navigated to this one, unless it was blocked or there was no such document, in which case it returns the empty string.
</dd>
	<dd>
~referrerを阻止したければ `noreferrer$v ~link型を利用できる。
◎
The noreferrer link type can be used to block the referrer.
</dd>
</dl>

<div class="algo">
`referrer@m
取得子~手続きは
⇒
~RET コレの`~referrer$doc
◎
The referrer attribute must return the document's referrer.
</div>

<hr>

<dl class="domintro">
	<dt>%document.`cookie$m [ = %value ]</dt>
	<dd>
`文書$に適用されている一連の~HTTP~cookieを返す。
~cookieが無い, もしくはこの資源に適用できない場合、
空~文字列が返される。
◎
Returns the HTTP cookies that apply to the Document. If there are no cookies or cookies can't be applied to this resource, the empty string will be returned.
</dd>
	<dd>
設定して，要素の~HTTP~cookieの集合に新たな~cookieを追加できる。
◎
Can be set, to add a new cookie to the element's set of HTTP cookies.
</dd>
	<dd>
内容が`一意~生成元に~sandbox化され$ている場合
（例： `sandbox$a 属性を有する `iframe$e の中）、
取得子, 設定子のいずれに対しても，
`SecurityError$E 例外が投出されることになる。
◎
If the contents are sandboxed into a unique origin (e.g. in an iframe with the sandbox attribute), a "SecurityError" DOMException will be thrown on getting and setting.
</dd>
</dl>

<p>
`cookie@m
~IDL属性は、
文書の`~URL$docで識別される資源の~cookieを表現する。
◎
The cookie attribute represents the cookies of the resource identified by the document's URL.
</p>

<p>
次のいずれかの条件を満たすような`文書$ %文書 は、
`反cookie文書@
とされる：
◎
A Document object that falls into one of the following conditions is a cookie-averse Document object:
</p>
<ul>
	<li>
%文書 が`属する閲覧~文脈$ ~EQ ~NULL
◎
A Document object whose browsing context is null.
</li>
	<li>
%文書 の`~URL$docの`~scheme$urlは、
`~HTTP_S~scheme$ではない
◎
A Document whose URL's scheme is not an HTTP(S) scheme.
</li>
</ul>

<div class="algo">
<p id="sandboxCookies">
~FINGERPRINTING
`cookie$m 取得子~手続きは：
◎
(This is a tracking vector.)
On getting,＼
</p>
<ol>
	<li>
~IF［
コレは`反cookie文書$である
］
⇒
~RET 空~文字列
◎
if the document is a cookie-averse Document object, then the user agent must return the empty string.＼
</li>
	<li>
~IF［
コレの`生成元$docは`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
◎
Otherwise, if the Document's origin is an opaque origin, the user agent must throw a "SecurityError" DOMException.＼
</li>
	<li>
%~cookie値 ~LET “非~HTTP” ~API用の［
コレの`~URL$doc用の `cookie-string$P
］
`COOKIES$r
◎
Otherwise, the user agent must return the cookie-string for the document's URL for a "non-HTTP" API,＼
</li>
	<li>
~RET `~BOMはそのままに~UTF-8復号する$( %~cookie値 )
◎
decoded using UTF-8 decode without BOM. [COOKIES]
</li>
</ol>
</div>

<div class="algo">
<p>
`cookie$m 設定子~手続きは：
◎
On setting,＼
</p>
<ol>
	<li>
~IF［
コレは`反cookie文書$である
］
⇒
~RET
◎
if the document is a cookie-averse Document object, then the user agent must do nothing.＼
</li>
	<li>
~IF［
コレの`生成元$docは`不透明な生成元$である
］
⇒
~THROW `SecurityError$E
◎
Otherwise, if the Document's origin is an opaque origin, the user agent must throw a "SecurityError" DOMException.＼
</li>
	<li>
%~cookie値 ~LET `~UTF-8符号化する$( 所与の値 )
`ENCODING$r
◎
↓</li>
	<li>
“非~HTTP” ~APIを介して，［
コレの`~URL$doc用に，
<a href="~HTTPcookie#storage-model">%~cookie値 からなる `set-cookie-string^P を受信した</a>
］かのように動作する
`COOKIES$r
◎
Otherwise, the user agent must act as it would when receiving a set-cookie-string for the document's URL via a "non-HTTP" API, consisting of the new value encoded as UTF-8. [COOKIES] [ENCODING]
</li>
</ol>
</div>

<p class="note">注記：
`cookie$m 属性は，~frame間をまたがって~access可能なので、
~cookieに対する~path制約は，
~cookieが~siteのどの部分に送信されたか管理する一助になるに過ぎない
— それは、
どのような~security特能でもない。
◎
Since the cookie attribute is accessible across frames, the path restrictions on cookies are only a tool to help manage which cookies are sent to which parts of the site, and are not in any way a security feature.
</p>

<p class="warning">
`cookie$m 属性の取得子／設定子は、
共有される状態に同期的に~accessする。
~lockするための仕組みはないので、
並列処理~UAにおいては，
他の閲覧~文脈が~scriptを走らせている間に~cookieを改変し得る。
一例として、
~siteは，
~sessionの一意~識別子として~cookieを読取って, 値を増分してから，
~cookieの新たな値として書き戻そうと試行することもできるが、
その~siteがこれを 2 つの~browser~windowで同時に行った場合、
両~sessionに同じ “一意” 識別子を利用する結果になり，悲惨な効果を及ぼし得る。
◎
The cookie attribute's getter and setter synchronously access shared state. Since there is no locking mechanism, other browsing contexts in a multiprocess user agent can modify cookies while scripts are running. A site could, for instance, try to read a cookie, increment its value, then write it back out, using the new value of the cookie as a unique identifier for the session; if the site does this twice in two different browser windows at the same time, it might end up using the same "unique" identifier for both sessions, with potentially disastrous effects.
</p>

<hr>

<dl class="domintro">
	<dt>%document.`lastModified$m</dt>
	<dd>
~serverから報告された文書の最終改変~日時を 利用者の地域標準時に換算した結果を，
`MM/DD/YYYY&nbsp;hh:mm:ss^l の形にして返す。
◎
Returns the date of the last modification to the document, as reported by the server, in the form "MM/DD/YYYY hh:mm:ss", in the user's local time zone.
</dd>
	<dd>
最終改変~日時が既知でない場合、
代わりに現在の時刻が返される。
◎
If the last modification date is not known, the current time is returned instead.
</dd>
</dl>

<div class="algo">
<p>
`lastModified@m
取得子~手続きは、［
`文書$の~source~fileの最終改変~日時
］を［
利用者の地域標準時に換算した結果
］を［
次の並びによる形式
］にして返す
⇒＃
日付の月t成分,
`002F^U `/^smb,
日付の日t成分,
`002F^U `/^smb,
日付の年t成分,
`0020^U SPACE,
時刻の時t成分,
`003A^U `:^smb,
時刻の分t成分,
`003A^U `:^smb,
時刻の秒t成分
◎
The lastModified attribute, on getting, must return the date and time of the Document's source file's last modification, in the user's local time zone, in the following format:
• The month component of the date.
• A U+002F SOLIDUS character (/).
• The day component of the date.
• A U+002F SOLIDUS character (/).
• The year component of the date.
• A U+0020 SPACE character.
• The hours component of the time.
• A U+003A COLON character (:).
• The minutes component of the time.
• A U+003A COLON character (:).
• The seconds component of the time.
</p>

<p>
ここで：
◎
</p>
<ul>
	<li>
<p>
上の各~成分は、
次を満たすように与えるモノトスル：
</p>
		<ul>
			<li>
当の成分を基数 10 の数で表現する`~ASCII数字$列にする。
</li>
			<li>
年t成分は 4 桁~以上かつ最短にし，他の成分すべては 2 桁にする。
</li>
			<li>
前項に必要なら何個かの `0030^U `0^smb を前置する。
</li>
		</ul>
◎
All the numeric components above, other than the year, must be given as two ASCII digits representing the number in base ten, zero-padded if necessary. The year must be given as the shortest possible string of four or more ASCII digits representing the number in base ten, zero-padded if necessary.
</li>
	<li>
`文書$の~source~fileの最終改変~日時は、
利用-中の~networking~protocolに関連な特能から導出するモノトスル
— 例えば、［
文書の~HTTP `Last-Modified$h ~headerの値
］から, あるいは［
局所~file用には~file~system内の~metadata
］から。
最終改変~日時が未知な場合、
この属性は，上の形式による現在の日時を返すモノトスル。
◎
The Document's source file's last modification date and time must be derived from relevant features of the networking protocols used, e.g. from the value of the HTTP `Last-Modified` header of the document, or from metadata in the file system for local files. If the last modification date and time are not known, the attribute must return the current date and time in the above format.
</li>
</ul>
</div>

			</section>
			<section id="reporting-document-loading-status">
<h4 title="Reporting document loading status">3.1.4. 文書~読込ng状態sの報告-法</h4>

<dl class="domintro">
	<dt>%document.`readyState$m</dt>
	<dd>
`文書$を読込んでいる間は、
`loading^l を返す。
構文解析を終えた後, かつ下位資源を読込んでいる間は、
`interactive^l を返す。
すべて読込まれて以降は、
`complete^l を返す。
◎
Returns "loading" while the Document is loading, "interactive" once it is finished parsing but still loading subresources, and "complete" once it has loaded.
</dd>
	<dd>
この値が変化したときは、
`文書$に向けて
`readystatechange$et ~eventが発火される。
◎
The readystatechange event fires on the Document object when this value changes.
</dd>
	<dd>
`DOMContentLoaded$et ~eventは、［
`interactive^l に遷移した後, かつ `complete^l に遷移する前
］の，すべての下位資源
— ただし， `script.async$a 属性を有する `script$e 要素によるものは除く —
が読込まれた所で発火される。
◎
The DOMContentLoaded event fires after the transition to "interactive" but before the transition to "complete", at the point where all subresources apart from async script elements have loaded.
</dd>
</dl>

<p>
各`文書$は、
`現在の準備度@doc
を持つ
— それは、
文字列であり，初期~時は `complete^l とする。
◎
Each Document has a current document readiness, a string, initially "complete".
</p>

<p class="note">注記：
`文書を作成して初期化する$ ~algoを介して作成された`文書$に対しては、
これは，即時に
— ~scriptが当の文書の `readyState$m を観測できるようになる前に —
`loading^l に設定し直されることになる。
この既定は、
他の事例
— `初期~about_blank な文書$や`属する閲覧~文脈$が無い`文書$など —
にも適用される。
◎
For Document objects created via the create and initialize a Document object algorithm, this will be immediately reset to "loading" before any script can observe the value of document.readyState. This default applies to other cases such as initial about:blank Documents or Documents without a browsing context.
</p>

<div class="algo">
`readyState@m
取得子~手続きは
⇒
~RET コレの`現在の準備度$doc
◎
The readyState getter steps are to return this's current document readiness.
</div>

<div class="algo">
<p>
`文書の現在の準備度を更新する@
ときは、
所与の
( `文書$ %文書, %準備度~値 )
に対し：
◎
To update the current document readiness for Document document to readinessValue:
</p>
<ol>
	<li>
~IF［
%文書 の`現在の準備度$doc ~EQ %準備度~値
］
⇒
~RET
◎
If document's current document readiness equals readinessValue, then return.
</li>
	<li>
%文書 の`現在の準備度$doc ~SET %準備度~値
◎
Set document's current document readiness to readinessValue.
</li>
	<li>
<p>
~IF［
%文書 には`~HTML構文解析器$が結付けられている
］：
◎
If document is associated with an HTML parser, then:
</p>
		<ol>
			<li>
%今 ~LET `現在の高分解能~時刻$( %文書 に`関連な大域~obj$ )
◎
Let now be the current high resolution time given document's relevant global object.
</li>
			<li>
~IF［
%準備度~値 ~EQ `complete^l
］~AND［
%文書 の`~load計時~情報$docの`~DOM完了-時刻$ ~EQ 0
］
⇒
%文書 の`~load計時~情報$docの`~DOM完了-時刻$ ~SET %今
◎
If readinessValue is "complete", and document's load timing info's DOM complete time is 0, then set document's load timing info's DOM complete time to now.
</li>
			<li>
~ELIF［
%準備度~値 ~EQ `interactive^l,
］~AND［
%文書 の`~load計時~情報$docの`~DOM対話的~時刻$ ~EQ 0
］
⇒
%文書 の`~load計時~情報$docの`~DOM対話的~時刻$ ~SET %今
◎
Otherwise, if readinessValue is "interactive", and document's load timing info's DOM interactive time is 0, then set document's load timing info's DOM interactive time to now.
</li>
		</ol>
	</li>
	<li>
`~eventを発火する$( %文書, `readystatechange$et )
◎
Fire an event named readystatechange at document.
</li>
</ol>
</div>

<hr>

<p>
`文書$は、
まだ［
`停止-$xされても, `中止-$xされても
］いない［
`~HTML構文解析器$ ／ `~XML構文解析器$
］が結付けられている間は，
`作動中の構文解析器@
があるとされる。
◎
A Document is said to have an active parser if it is associated with an HTML parser or an XML parser that has not yet been stopped or aborted.
</p>

<hr>

<p>
各`文書$は、
次に挙げるものを持つ：
◎
↓</p>
<ul>
	<li>
`~load計時~情報@doc
⇒
`文書~load計時~情報$
◎
A Document has a document load timing info load timing info.
</li>
	<li>
`前-文書の~unload計時~情報@doc
⇒
`文書~unload計時~情報$
◎
A Document has a document unload timing info previous document unload timing.
</li>
	<li>
`非同一-生成元~redirectを介して作成されたか@doc
⇒
真偽値
— 初期~時は ~F とする
◎
A Document has a boolean was created via cross-origin redirects, initially false.
</li>
</ul>

<p>
`文書~load計時~情報@
は、
`構造体$であり，次に挙げる`~item$sctからなる：
◎
The document load timing info struct has the following items:
</p>
<dl class="def-list">
	<dt>
`~navi開始~時刻@
（既定は 0 ）
◎
navigation start time (default 0)
</dt>

	<dt>
`~DOM対話的~時刻@
（既定は 0 ）
◎
DOM interactive time (default 0)
</dt>
	<dt>
`~DOMContentLoaded~event開始~時刻@
（既定は 0 ）†
◎
DOM content loaded event start time (default 0)
</dt>
	<dt>
`~DOMContentLoaded~event終了~時刻@
（既定は 0 ）†
◎
DOM content loaded event end time (default 0)
</dt>
	<dt>
`~DOM完了-時刻@
（既定は 0 ）
◎
DOM complete time (default 0)
</dt>
	<dt>
`~load~event開始~時刻@
（既定は 0 ）
◎
load event start time (default 0)
</dt>
	<dt>
`~load~event終了~時刻@
（既定は 0 ）
◎
load event end time (default 0)
</dt>
	<dd>
いずれも `DOMHighResTimeStamp$I 値
◎
DOMHighResTimeStamp values
</dd>
</dl>

<p class="trans-note">【†
“~DOMContentLoaded…” は，原文では `DOM content loaded…^en （ “~DOM内容は読込まれた” ）だが、
~~実際に `DOMContentLoaded$et ~eventに関するので，この訳では直にそう記す。
】</p>

<p>
`文書~unload計時~情報@
は、
`構造体$であり，次に挙げる`~item$sctからなる：
◎
The document unload timing info struct has the following items:
</p>
<dl class="def-list">
	<dt>
`~unload~event開始~時刻@
（既定は 0 ）
◎
unload event start time (default 0)
</dt>
	<dt>
`~unload~event終了~時刻@
（既定は 0 ）
◎
unload event end time (default 0)
</dt>
	<dd>
いずれも `DOMHighResTimeStamp$I 値
◎
DOMHighResTimeStamp values
</dd>
</dl>

			</section>
			<section id="render-blocking-mechanism">
<h4 title="Render-blocking mechanism">3.1.5. 具現化を阻む仕組み</h4>

<p>
各`文書$は、
`具現化を阻んでいる要素~群@doc
（ `render-blocking element set^en ）を持つ
— それは、
要素~群が成す`集合$であり，初期~時は空とする。
◎
Each Document has a render-blocking element set, a set of elements, initially the empty set.
</p>

<p>
次を満たす`文書$ %文書 は、
`具現化を阻む要素の追加ngを許容して@
いるとされる
⇒
［
%文書 の`内容~型$doc ~EQ "`text/html$c"
］~AND［
%文書 の`~body要素$ ~EQ ~NULL
］
◎
A Document document allows adding render-blocking elements if document's content type is "text/html" and the body element of document is null.
</p>

<p>
次をいずれも満たす`文書$ %文書 は、
その
`具現化は阻まれて@
いる（ `render-blocked^en ）とされる：
◎
A Document document is render-blocked if both of the following are true:
</p>
<ul>
	<li>
［
%文書 の`具現化を阻んでいる要素~群$docは空でない
］~OR［
%文書 は`具現化を阻む要素の追加ngを許容して$いる
］
◎
document's render-blocking element set is non-empty, or document allows adding render-blocking elements.
</li>
	<li>
`現在の高分解能~時刻$( %文書 に`関連な大域~obj$ ) ~LTE `実装定義$な時間切れ値
◎
The current high resolution time given document's relevant global object has not exceeded an implementation-defined timeout value.
</li>
</ul>

<p>
次を満たす要素 %要素 は、
`具現化を阻んで@
いる（ `render-blocking^en ）とされる
⇒
［
%要素 の`~node文書$ %文書 の`具現化は阻まれて$いる
］~AND［
%要素 ~IN %文書 の`具現化を阻んでいる要素~群$doc
］
◎
An element el is render-blocking if el's node document document is render-blocked, and el is in document's render-blocking element set.
</p>

<div class="algo">
<p>
`具現化を阻む@
ときは、
所与の
( 要素 %要素 )
に対し：
◎
To block rendering on an element el:
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be el's node document.
</li>
	<li>
~IF［
%文書 は`具現化を阻む要素の追加ngを許容して$いる
］
⇒
%文書 の`具現化を阻んでいる要素~群$docに %要素 を`付加する$set
◎
If document's awaiting parser-inserted body flag is true, then append el to document's render-blocking element set.
</li>
</ol>
</div>

<div class="algo">
<p>
`具現化を阻まなくする@
ときは、
所与の
( 要素 %要素 )
に対し：
◎
To unblock rendering on an element el:
</p>
<ol>
	<li>
%文書 ~LET %要素 の`~node文書$
◎
Let document be el's node document.
</li>
	<li>
%文書 の`具現化を阻んでいる要素~群$docから %要素 を`除去する$
◎
Remove el from document's render-blocking element set.
</li>
</ol>
</div>

<p class="algo">
［
`具現化を阻んで$いる要素 %要素 が`閲覧~文脈から切断された$とき／
`具現化を阻む能性$がある要素 %要素 の`他を阻む属性$の値が変更され，その能性を失ったとき
］は、
次を遂行するモノトスル
⇒
`具現化を阻まなくする$( %要素 )
◎
Whenever a render-blocking element el becomes browsing-context disconnected, or el's blocking attribute's value is changed so that el is no longer potentially render-blocking, then unblock rendering on el.
</p>

			</section>
			<section id="dom-tree-accessors">
<h4 title="DOM tree accessors">3.1.6. ~DOM~tree~accessor</h4>

<div class="algo">
<p>
所与の`文書$ %文書 の
`~html要素@
は、
次を走らせた結果を返す：
</p>

<ol>
	<li>
%文書~要素 ~LET %文書 の`文書~要素$
</li>
	<li>
~RET［
%文書~要素 は `html$e 要素であるならば %文書~要素 ／
~ELSE_ ~NULL
］
</li>
</ol>

◎
The html element of a document is its document element, if it's an html element, and null otherwise.
</div>

<hr>

<dl class="domintro">
	<dt>%document.`head$m</dt>
	<dd>
`~head要素$を返す。
◎
Returns the head element.
</dd>
</dl>

<div class="algo">
<p>
所与の`文書$ %文書 の
`~head要素@
は、
次を走らせた結果を返す：
</p>

<ol>
	<li>
%html ~LET %文書 の`~html要素$
</li>
	<li>
~IF［
%html ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
	<li>
~RET 次を満たす要素が［
在るならば，それらのうち`~tree順序$で最初のもの ／
無いならば ~NULL
］
⇒
［
`head$e 要素である
］~AND［
親 ~EQ %html
］
</li>
</ol>

◎
The head element of a document is the first head element that is a child of the html element, if there is one, or null otherwise.
</div>

<div class="algo">
`head@m
取得子~手続きは
⇒
~RET コレの`~head要素$
◎
The head attribute, on getting, must return the head element of the document (a head element or null).
</div>

<hr>

<dl class="domintro">
	<dt>%document.`title$m [ = %value ]</dt>
	<dd>
文書の~titleを返す
— ~titleは［
~HTML用には`~title要素$／~SVG用には `~SVG-title$ 要素
］にて与えられる。
◎
Returns the document's title, as given by the title element for HTML and as given by the SVG title element for SVG.
</dd>
	<dd>
設定して文書の~titleを更新できる。
更新する適切な要素がない場合、
所与の %value は無視される。
◎
Can be set, to update the document's title. If there is no appropriate element to update, the new value is ignored.
</dd>
</dl>

<div class="algo">
<p>
所与の`文書$ %文書 の
`~title要素@
は、
%文書 内に `title$e 要素が［
在るならば それらのうち`~tree順序$で最初のもの ／
無いならば ~NULL
］を返す。
◎
The title element of a document is the first title element in the document (in tree order), if there is one, or null otherwise.
</p>
</div>

<div class="algo">
<p>
`title@m
取得子~手続きは：
◎
The title attribute must, on getting, run the following algorithm:
</p>
<ol>
	<li>
%値 ~LET 空~文字列
◎
↓</li>
	<li>
~IF［
コレの`文書~要素$ は `~SVG-svg$ 要素である
］
⇒
%値 ~SET ［
コレの`文書~要素$の子であるような，最初の `~SVG-title$ 要素
］の`子~text内容$
◎
If the document element is an SVG svg element, then let value be the child text content of the first SVG title element that is a child of the document element.
</li>
	<li>
~ELIF［
コレの`~title要素$ ~NEQ ~NULL
］
⇒
%値 ~SET その`子~text内容$
◎
Otherwise, let value be the child text content of the title element, or the empty string if the title element is null.
</li>
	<li>
~RET `~ASCII空白を剥いで縮約する$( %値 )
◎
Strip and collapse ASCII whitespace in value.
◎
Return value.
</li>
</ol>
</div>

<div class="algo">
<p>
`title$m 設定子~手続きは：
◎
On setting, the steps corresponding to the first matching condition in the following list must be run:
</p>
<ol>
	<li>
%文書~要素 ~LET コレの`文書~要素$
◎
↓</li>
	<li>
<p>
~IF［
%文書~要素 は `~SVG-svg$ 要素である
］：
◎
If the document element is an SVG svg element
</p>

		<ol>
			<li>
%title ~LET ~NULL
◎
↓</li>
			<li>
~IF［
%文書~要素 の子に `~SVG-title$ 要素はある
］
⇒
%title ~SET それらのうち最初のもの
◎
If there is an SVG title element that is a child of the document element, let element be the first such element.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%title ~SET `要素を作成する$( コレ, `title^l, `~SVG名前空間$ )
【！文書~要素 の~node文書】
◎
Let element be the result of creating an element given the document element's node document, title, and the SVG namespace.
</li>
					<li>
%文書~要素 の`最初の子$として， %title を挿入する
◎
Insert element as the first child of the document element.
</li>
				</ol>
			</li>
			<li>
%title の `全~内容を文字列に置換する$( 所与の値 )
◎
String replace all with the given value within element.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%文書~要素 は`~HTML名前空間$に属する
］：
◎
If the document element is in the HTML namespace
</p>

		<ol>
			<li>
%title ~LET コレの`~title要素$
◎
↓</li>
			<li>
%head ~LET コレの`~head要素$
◎
↓</li>
			<li>
~IF［
%title ~EQ ~NULL
］~AND［
%head ~EQ ~NULL
］
⇒
~RET
◎
If the title element is null and the head element is null, then return.
</li>
			<li>
<p>
~IF［
%title ~EQ ~NULL
］：
◎
If the title element is non-null, let element be the title element.
◎
Otherwise:
</p>
				<ol>
					<li>
%title ~SET `要素を作成する$( コレ, `title^l, `~HTML名前空間$ )
【！文書~要素 の~node文書】
◎
Let element be the result of creating an element given the document element's node document, title, and the HTML namespace.
</li>
					<li>
%head に`~nodeを付加する$( %title )
◎
Append element to the head element.
</li>
				</ol>
			</li>
			<li>
%title の `全~内容を文字列に置換する$( 所与の値 )
◎
String replace all with the given value within element.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
何もしない
◎
Otherwise
◎
Do nothing.
</li>
</ol>
</div>

<hr>

<dl class="domintro">
	<dt>%document.`body$m [ = %value ]</dt>
	<dd>
`~body要素$を返す。
◎
Returns the body element.
</dd>
	<dd>
設定して`~body要素$を置換できる。
◎
Can be set, to replace the body element.
</dd>
	<dd>
所与の要素が `body$e でも `frameset$eO でもない場合、
`HierarchyRequestError$E 例外が投出される。
◎
If the new value is not a body or frameset element, this will throw a "HierarchyRequestError" DOMException.
</dd>
</dl>

<div class="algo">
<p>
所与の`文書$ %文書 の
`~body要素@
は、
次を走らせた結果を返す：
</p>

<ol>
	<li>
%html ~LET %文書 の`~html要素$
</li>
	<li>
~IF［
%html ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
	<li>
~RET 次を満たす要素が［
在るならば，それらのうち`~tree順序$で最初のもの ／
無いならば ~NULL
］
⇒
［［
`body$e ／ `frameset$eO
］要素である
］~AND［
親 ~EQ %html
］
</li>
</ol>

◎
The body element of a document is the first of the html element's children that is either a body element or a frameset element, or null if there is no such element.
</div>

<div class="algo">
`body@m
取得子~手続きは
⇒
~RET コレの`~body要素$
◎
The body attribute, on getting, must return the body element of the document (either a body element, a frameset element, or null).＼
</div>

<div class="algo">
<p>
`body$m 設定子~手続きは：
◎
On setting, the following algorithm must be run:
</p>
<ol>
	<li>
%要素 ~LET 所与の値
◎
↓</li>
	<li>
~IF［
%要素 は［
`body$e ／ `frameset$eO
］要素でない
］
⇒
~THROW `HierarchyRequestError$E
◎
If the new value is not a body or frameset element, then throw a "HierarchyRequestError" DOMException.
</li>
	<li>
%body ~LET コレの`~body要素$
◎
↓</li>
	<li>
~IF［
%要素 ~EQ %body
］
⇒
~RET
◎
Otherwise, if the new value is the same as the body element, return.
</li>
	<li>
%文書~要素 ~LET コレの`文書~要素$
◎
↓</li>
	<li>
~IF［
%body ~NEQ ~NULL
］
⇒
%body の親の中で`子を~nodeに置換する$( %body, %要素 )
◎
Otherwise, if the body element is not null, then replace the body element with the new value within the body element's parent and return.
</li>
	<li>
~ELIF［
%文書~要素 ~EQ ~NULL
］
⇒
~THROW `HierarchyRequestError$E
◎
Otherwise, if there is no document element, throw a "HierarchyRequestError" DOMException.
</li>
	<li>
~ELSE
⇒
%文書~要素 に`~nodeを付加する$( %要素 )
◎
Otherwise, the body element is null, but there's a document element. Append the new value to the document element.
</li>
</ol>
</div>

<p class="note">注記：
`body$m 取得子は、
設定子に渡された値を返さない場合もある。
◎
The value returned by the body getter is not always the one passed to the setter.
</p>

<div class="example">
<p>
次の例では、
設定子は `body$e を成功裡に挿入する
（これは適合しないが
— ~SVGでは、
`~SVG-svg$ の子として `body$e 要素は許容されないので）。
しかしながら、
取得子は ~NULL を返すことになる
— 文書~要素は `html$e ではないので：
◎
In this example, the setter successfully inserts a body element (though this is non-conforming since SVG does not allow a body as child of SVG svg). However the getter will return null because the document element is not html.
</p>

`document-1^xCode
</div>

<hr>

<dl class="domintro">
	<dt>%document.`images$m</dt>
	<dd>
`文書$内の `img$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the img elements in the Document.
</dd>

	<dt>%document.`embeds$m</dt>

	<dt>%document.`plugins$m</dt>
	<dd>
`文書$内の `embed$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the embed elements in the Document.
</dd>

	<dt>%document.`links$m</dt>
	<dd>
`文書$内の `a$e, `area$e 要素たちのうち，
`href$a 属性を有するもの
からなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the a and area elements in the Document that have href attributes.
</dd>

	<dt>%document.`forms$m</dt>
	<dd>
`文書$内の `form$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the form elements in the Document.
</dd>

	<dt>%document.`scripts$m</dt>
	<dd>
`文書$内の `script$e 要素たち
からなる `HTMLCollection$I を返す。
◎
Returns an HTMLCollection of the script elements in the Document.
</dd>
</dl>

<div class="algo">
<p>
［
`images@m ／
`embeds@m ／
`plugins@m ／
`links@m ／
`forms@m ／
`scripts@m
］取得子~手続きは
⇒
~RET 次のようにされた `HTMLCollection$I
⇒＃
根： コレ,
~filter： 属性に応じて、
次の表の 2 列目に該当する要素のみに合致する
</p>

<table><tbody>
<tr><th>~IDL属性
<th>合致する要素

<tr><td>`images$m
<td>`img$e 要素

<tr><td>`embeds$m
<td>`embed$e 要素

<tr><td>`plugins$m
<td>`embed$e 要素

<tr><td>`links$m
<td>［
`a$e, `area$e
］要素のうち，`href$a 属性を有するもの

<tr><td>`forms$m
<td>`form$e 要素

<tr><td>`scripts$m
<td>`script$e 要素

</tbody></table>

◎
The images attribute must return an HTMLCollection rooted at the Document node, whose filter matches only img elements.
◎
The embeds attribute must return an HTMLCollection rooted at the Document node, whose filter matches only embed elements.
◎
The plugins attribute must return the same object as that returned by the embeds attribute.
◎
The links attribute must return an HTMLCollection rooted at the Document node, whose filter matches only a elements with href attributes and area elements with href attributes.
◎
The forms attribute must return an HTMLCollection rooted at the Document node, whose filter matches only form elements.
◎
The scripts attribute must return an HTMLCollection rooted at the Document node, whose filter matches only script elements.
</div>

<hr>

<dl class="domintro">
	<dt>%collection = %document.`getElementsByName(elementName【！name】)$m</dt>
	<dd>
`文書$内の要素のうち，［
`name^a 属性を有する, かつその値 ~EQ %name なるもの
］からなる `NodeList$I を返す
◎
Returns a NodeList of elements in the Document that have a name attribute with the value name.
</dd>
</dl>

<div class="algo">
<p>
`getElementsByName(elementName)@m
~method手続きは
⇒
~RET 次を満たす~nodeすべてを包含している，`~tree順序$による`~live$な `NodeList$I
⇒
［
コレ内にある`~HTML要素$である
］~AND［
`name^a 属性を有していて，その値 ~EQ【！identical】 %elementName
］
◎
The getElementsByName(elementName) method steps are to return a live NodeList containing all the HTML elements in that document that have a name attribute whose value is identical to the elementName argument, in tree order.＼
</p>

<p>
~UAは、
同じ引数で再び呼出されたときは，同じ~objを返してもヨイ。
そうでなければ，新たな~objを返すモノトスル。
◎
When the method is invoked on a Document object again with the same argument, the user agent may return the same as the object returned by the earlier call. In other cases, a new NodeList object must be returned.
</p>
</div>

<hr>

<dl class="domintro">
	<dt>%document.`currentScript$m</dt>
	<dd>
現在~実行している［
`script$e ／ `~SVG-script$
］要素を返す
— その要素が`古典~script$を表現する限りにおいて。
再入的な `script$e 実行の事例では、
まだ実行し終えてないそれらのうち，最も近過去に実行し始めたものを返す。
◎
Returns the script element, or the SVG script element, that is currently executing, as long as the element represents a classic script. In the case of reentrant script execution, returns the one that most recently started executing amongst those that have not yet finished executing.
</dd>
	<dd>
`文書$が現在~実行している［
`script$e ／ `~SVG-script$
］要素は［
無い
（例：走っている~scriptは~event~handlerであるか, 時間切れになった）,
または`~module~script$を実行している
］場合は、
~NULLを返す。
◎
Returns null if the Document is not currently executing a script or SVG script element (e.g., because the running script is an event handler, or a timeout), or if the currently executing script or SVG script element represents a module script.
</dd>
</dl>

<div class="algo">
`currentScript@m
取得子~手続きは、
最も近過去に設定された値を返す
— この属性は、
コレの作成-時には，~NULLに初期化するモノトスル。
◎
The currentScript attribute, on getting, must return the value to which it was most recently set.＼
When the Document is created, the currentScript must be initialized to null.
</div>

<p class="note">
この~APIは、［
`script$e ／ `~SVG-script$
］要素を大域的に公開するので、［
実装者, 標準
］の~communityからの支持を失っている。
そのようなわけで、
`~module~script$や`~shadow~tree$内の~scriptを走らすときのような，
より新たな文脈の下では可用ではない。
そのような文脈で走っている~scriptを［
大域的に公開することなく識別する
］ための新たな解決策を探している所である。
`課題 #1013＠~HTMLissue/1013$ を見よ。
◎
This API has fallen out of favor in the implementer and standards community, as it globally exposes script or SVG script elements. As such, it is not available in newer contexts, such as when running module scripts or when running scripts in a shadow tree. We are looking into creating a new solution for identifying the running script in such contexts, which does not make it globally available: see issue #1013.
</p>

<hr>

<div class="p">
<p id="dom-document-namedItem-which">
`Document$I ~interfaceは、
`有名~propを~supportする$。
所与の時点で`文書$ %文書 が`~supportする~prop名$は、
%文書 内のすべての`有名~要素$が供与する`要素~名$たちからなり，
それらの順序は`有名~要素$たちの`~tree順序$に従うとする
— ただし：
</p>
<ul>
	<li>
同じ要素の［
`id$a, `name^a
］両~属性が`要素~名$を与える場合、
`id$a が先とする。
</li>
	<li>
`要素~名$の重複に際しては、
後から供与される`要素~名$は無視する。
</li>
</ul>
◎
The Document interface supports named properties. The supported property names of a Document object document at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates, and with values from id attributes coming before values from name attributes when the same element contributes both:
• the value of the name content attribute for all exposed embed, form, iframe, img, and exposed object elements that have a non-empty name content attribute and are in a document tree with document as their root;
• the value of the id content attribute for all exposed object elements that have a non-empty id content attribute and are in a document tree with document as their root; and
• the value of the id content attribute for all img elements that have both a non-empty id content attribute and a non-empty name content attribute, and are in a document tree with document as their root.
</div>

<div class="algo">
<p id="dom-document-nameditem">
~UAは、
`文書$ %文書 の，所与の %名前 に対応する`有名~propの値を決定する$ときは、
次の手続きを走らすモノトスル：
◎
To determine the value of a named property name for a Document, the user agent must return the value obtained using the following steps:
</p>

<ol>
	<li>
~Assert：
%名前 は %文書 が`~supportする~prop名$である
【この段は、この訳による補完。】
</li>
	<li>
<p>
%要素~群 ~LET %文書 内の`有名~要素$のうち［
%名前 ~EQ それが供与する いずれかの`要素~名$
］を満たすものからなる~list
◎
Let elements be the list of named elements with the name name that are in a document tree with the Document as their root.
</p>

<p class="note">
定義により、
この~listは空でない。
◎
There will be at least one such element, by definition.
</p>
	</li>
	<li>
<p>
~IF［
%要素~群 は唯一の要素 %要素 からなる
］
</p>
		<ol>
			<li>
~IF［
%要素 は `iframe$e 要素である
］~AND［
%要素 の`内容~navigable$ %N ~NEQ ~NULL
］
⇒
~RET %N にて`作動中の~WindowProxy$nav
</li>
			<li>
~RET %要素
</li>
		</ol>
◎
If elements has only one element, and that element is an iframe element, and that iframe element's content navigable is not null, then return the active WindowProxy of the element's content navigable.
◎
Otherwise, if elements has only one element, return that element.
</li>
	<li>
~RET 次のようにされた `HTMLCollection$I
⇒＃
根： %文書；
~filter： %要素~群 を成す要素に限り合致する
◎
Otherwise return an HTMLCollection rooted at the Document node, whose filter matches only named elements with the name name.
</li>
</ol>
</div>

<div class="p">
<p>
次をすべて満たす要素が、
`文書$内の
`有名~要素@
とされる：
</p>
<ul>
	<li>
要素は、
文書を`根$とする`~tree内にある$
</li>
	<li>
<p>
要素は、
下の表に挙げる いずれかの行 %行 に関して，次をすべて満たす：
</p>
		<ul>
			<li>
%行 の 1 列目に挙げるものである
</li>
			<li>
%行 の 2 列目に挙げる内容~属性 %A を有していて，その値 ~NEQ 空~文字列
</li>
			<li>
%行 の 3 列目の条件を満たす
</li>
		</ul>


<table><thead><tr><th>要素
<th>内容~属性
<th>追加的な条件
</thead><tbody>

<tr><td>`embed$e
<td>`name^a
<td>`公開されている$

<tr><td>`form$e
<td>`name^a
<td>なし

<tr><td>`iframe$e
<td>`name^a
<td>なし

<tr><td>`img$e
<td>`name^a
<td>なし

<tr><td>`img$e
<td>`id$a
<td>`name^a 内容~属性を有する, かつ その値 ~NEQ 空~文字列

<tr><td>`object$e
<td>`name^a
<td>`公開されている$

<tr><td>`object$e
<td>`id$a
<td>`公開されている$

</tbody></table>

<p>
当の`有名~要素$は、
条件を満たす行ごとに，
上に述べた内容~属性 %A の値を
`要素~名@
として供与する
（該当する行が 2 つある場合、
2 つの`要素~名$を供与する）。
</p>

<p class="trans-note">【
`要素~名$は、
記述を論理的に集約するためにこの訳に導入した用語である。
】</p>

	</li>
</ul>

◎
Named elements with the name name, for the purposes of the above algorithm, are those that are either:
◎
Exposed embed, form, iframe, img, or exposed object elements that have a name content attribute whose value is name, or
◎
Exposed object elements that have an id content attribute whose value is name, or
◎
img elements that have an id content attribute whose value is name, and that have a non-empty name content attribute present also.
</div>

<div class="p">
<p>
［
`embed$e ／ `object$e
］要素は、
次のいずれも満たすならば，
`公開されている@
という：
</p>

<ul>
	<li>
どの先祖も，`公開されている$ `object$e ではない
</li>
	<li>
<p>
`embed$e 要素であるか, または
次のいずれかを満たす `object$e 要素である：
</p>
		<ul>
			<li>
`~fallback内容$を示していない
</li>
			<li>
どの子孫も，
`object$e 要素でも `embed$e 要素でもない
</li>
		</ul>
	</li>
</ul>

◎
An embed or object element is said to be exposed if it has no exposed object ancestor, and, for object elements, is additionally either not showing its fallback content or has no object or embed descendants.
</div>

<hr>

<p class="note">注記：
`Document$I ~interfaceの `dir$m 属性は、
`dir$a 内容~属性とともに定義される。
◎
The dir attribute on the Document interface is defined along with the dir content attribute.
</p>

			</section>
		</section>
		<section id="elements">
<h3 title="Elements">3.2. 要素</h3>

			<section id="semantics-2">
<h4 title="Semantics">3.2.1. 意味論</h4>

<p>
~HTMLにおける［
要素, 属性, 属性~値
］は、
（この仕様により）ある種の意味（意味論）を有するものと定義される。
例えば
⇒＃
`ol$e 要素は，有順序~listを表現する。
`lang$a 属性は，要素~内容の言語を表現する。
◎
Elements, attributes, and attribute values in HTML are defined (by this specification) to have certain meanings (semantics). For example, the ol element represents an ordered list, and the lang attribute represents the language of the content.
</p>

<p>
これらの定義は、
次を許容する：
◎
These definitions allow＼
</p>
<ul>
	<li>
~HTML処理器
— ~web~browserや探索~engineなど —
が，文書を［
呈示する／利用する
］こと
◎
HTML processors, such as web browsers or search engines, to present and use documents＼
</li>
	<li>
多様な文脈
— 作者が考慮しなかったかもしれないものも含む —
における応用
◎
and applications in a wide variety of contexts that the author might not have considered.
</li>
</ul>

<div class="example">
<p>
単純な例として、
作者が~desktop~computer用の~web~browserのみを考慮して書いた~web~pageを考える：
◎
As a simple example, consider a web page written by an author who only considered desktop computer web browsers:
</p>

`elements-1^xCode

<p>
~HTMLは，呈示ではなく`意味^emを伝達するので、
同じ~pageは，何ら変更することなく携帯端末~上の小さい~browserからも利用され得る。
携帯端末~上の~browserは、
~desktop上のときのような字の大きい見出しに代えて，例えば、
~page全体に同じ~sizeの~textを利用した上で，見出しを太字にすることもあり得る。
◎
Because HTML conveys meaning, rather than presentation, the same page can also be used by a small browser on a mobile phone, without any change to the page. Instead of headings being in large letters as on the desktop, for example, the browser on the mobile phone might use the same size text for the whole page, but with the headings in bold.
</p>

<p>
単なる~screen~sizeの相違のみならず、
同じ~pageは，［
発話~合成に基づく~browserを利用している~blind利用者
］からも等しく利用され得る
— そこでは、
例えば~headphoneを利用している利用者に向けて，
~pageを~screen上に表示する代わりに~pageを読上げる。
そのような発話~browserは、
~textを大きくする代わりに，
異なる音量やより低速な声を見出しに利用するかもしれない。
◎
But it goes further than just differences in screen size: the same page could equally be used by a blind user using a browser based around speech synthesis, which instead of displaying the page on a screen, reads the page to the user, e.g. using headphones. Instead of large text for the headings, the speech browser might use a different volume or a slower voice.
</p>

<p>
他にもある。
~browserは，~pageのどの部分が見出しであるか知るので、［
利用者が 
“［次の／前の］見出しまで飛ぶ”
キーを利用して，文書を素早く~~巡回できる
］ために利用できるような，文書の~outlineを作成できる。
そのような特能は、
とりわけ発話~browserに共通してある
— さもなければ、
利用者は，~pageを素早く~navigateするのが著しく困難なことを見出すことになろう。
◎
That's not all, either. Since the browsers know which parts of the page are the headings, they can create a document outline that the user can use to quickly navigate around the document, using keys for "jump to next heading" or "jump to previous heading". Such features are especially common with speech browsers, where users would otherwise find quickly navigating a page quite difficult.
</p>

<p>
~browserの他にも，~softwareはこの情報を用立てれる。
探索~engineは、
より効果的に，見出しを［
~pageを~indexしたり、
その結果から，~pageの下位節への~~直行~linkを供する
］ために利用できる。
各種~toolは、
目次を作成するときに見出しを利用できる
（事実，この仕様~自身もそうやって目次を生成している）。
◎
Even beyond browsers, software can make use of this information. Search engines can use the headings to more effectively index a page, or to provide quick links to subsections of the page from their results. Tools can use the headings to create a table of contents (that is in fact how this very specification's table of contents is generated).
</p>

<p>
この例では，見出しに注目していたが、
同じ原則は，~HTMLにおけるすべての意味論に適用される。
◎
This example has focused on headings, but the same principle applies to all of the semantics in HTML.
</p>
</div>

<p>
作者は、［
要素／属性／属性~値
］を［
それらに意図された適切な意味論上の目的
］以外の目的に利用してはナラナイ
— そうすると、
~softwareは~pageを正しく処理できなくなるので。
◎
Authors must not use elements, attributes, or attribute values for purposes other than their appropriate intended semantic purpose, as doing so prevents software from correctly processing the page.
</p>

<div class="example">
<p>
例えば、
次の~code片は，ある企業~siteの見出しを表現するために意図されているが、
その 2 行目は，［
下位節の見出しに意図されたものではなく、
単に同じ節の副~見出しに過ぎない
］ので適合でない。
◎
For example, the following snippet, intended to represent the heading of a corporate site, is non-conforming because the second line is not intended to be a heading of a subsection, but merely a subheading or subtitle (a subordinate heading for the same section).
</p>

`elements-2^xCode

<p>
この種の状況には、
`hgroup$e 要素を利用できる：
◎
The hgroup element can be used for these kinds of situations:
</p>

`elements-3^xCode
</div>

<div class="example">
<p>
同様に、
次の例における文書は，
構文上は正しくても適合でない
— 各~cell内に配されている~dataは，明らかに~table用の~dataではなく、
`cite$e 要素は誤用されているので：
◎
The document in this next example is similarly non-conforming, despite being syntactically correct, because the data placed in the cells is clearly not tabular data, and the cite element mis-used:
</p>

`elements-4^xCode

<p>
これは、
これらの意味論に依拠する~softwareを失敗させることになろう：
例えば、
~blind利用者に［
文書~内の~tableを~navigateする
］ことを許容する発話~browserは、
上の~~文章を~tableとして報告することになり，
利用者を惑わすことなる。
同様に，~pageから各 作品の~titleを抽出する~toolは、
"アーネスト" を
— 実際には人名であって，~titleではないのに —
作品の~titleとして抽出することになる。
◎
This would make software that relies on these semantics fail: for example, a speech browser that allowed a blind user to navigate tables in the document would report the quote above as a table, confusing the user; similarly, a tool that extracted titles of works from pages would extract "Ernest" as the title of a work, even though it's actually a person's name, not a title.
</p>

<p>
上の文書を正した~versionは、
次のようになるであろう：
◎
A corrected version of this document might be:
</p>

`elements-5^xCode
</div>

<p>
作者は、
この仕様も含む`適用-可能な仕様$により許可されていない［
要素, 属性, 属性~値
］を利用してはナラナイ。
そうすると、
~HTMLの将来の拡張が有意に難しくなるので。
◎
Authors must not use elements, attributes, or attribute values that are not permitted by this specification or other applicable specifications, as doing so makes it significantly harder for the language to be extended in the future.
</p>

<div class="example">
<p>
次の例には、
この仕様により許可されていない，適合しない［
属性~値（ `carpet^l ）, 属性（ `texture^a ）
］がある：
◎
In the next example, there is a non-conforming attribute value ("carpet") and a non-conforming attribute ("texture"), which is not permitted by this specification:
</p>

`elements-6^xCode

<p>
これを~mark-upする別の正しい仕方は：
◎
Here would be an alternative and correct way to mark this up:
</p>

`elements-7^xCode
</div>

<p id="no-browsing-context">
~DOM~nodeのうち［
その`~node文書$が`属する閲覧~文脈$ ~EQ ~NULL
］なるものに対しては、［
`~HTML構文$x ／ `~XML構文$
］による要件を除く，すべての文書 適合性~要件は免除される。
◎
DOM nodes whose node document's browsing context is null are exempt from all document conformance requirements other than the HTML syntax requirements and XML syntax requirements.
</p>

<div class="example">
<p>
特に、［
`template$e 要素の`~template内容$の`~node文書$が`属する閲覧~文脈$
］は ~NULL なので、
要素の内容には，例えば［
`内容~model＠#concept-element-content-model$要件,
属性~値に対する小構文による要件
］は適用されない。
次の例の `img$e 要素の属性には、
仮入力として，［
`template$e 要素の外側では妥当でない値
］が与えられている：
◎
In particular, the template element's template contents's node document's browsing context is null. For example, the content model requirements and attribute value microsyntax requirements do not apply to a template element's template contents. In this example an img element has attribute values that are placeholders that would be invalid outside a template element.
</p>

`elements-8^xCode

<p>
上の~markupから終了~tag `&lt;/h1&gt;^c を省略した場合、
`~HTML構文$xに違反するので，
適合性~検査器により~errorにされる。
◎
However, if the above markup were to omit the &lt;/h1&gt; end tag, that would be a violation of the HTML syntax, and would thus be flagged as an error by conformance checkers.
</p>
</div>

<p>
［
属性の値, ~text, さらには文書の構造~全体
］は、
~UAが それを処理している間に［
~scriptingを通して／他の仕組みを利用して
］動的に変更され得る。
ある時点における文書の意味論は，その時点の文書の状態により表現されるので、
文書の意味論は時間~越しに変化し得る。
~UAは、
文書の呈示を，変化が生じる度に更新するモノトスル。
◎
Through scripting and using other mechanisms, the values of attributes, text, and indeed the entire structure of the document may change dynamically while a user agent is processing it. The semantics of a document at an instant in time are those represented by the state of the document at that instant in time, and the semantics of a document can therefore change over time. User agents must update their presentation of the document as this occurs.
</p>

<p class="example">
~HTMLには、
進捗~barを記述する `progress$e 要素がある。
その `value^a 属性が~scriptにより動的に更新された場合、
~UAは，進捗の変化を示すよう具現化を更新することになる。
◎
HTML has a progress element that describes a progress bar. If its "value" attribute is dynamically updated by a script, the UA would update the rendering to show the progress changing.
</p>

			</section>
			<section id="elements-in-the-dom">
<h4 title="Elements in the DOM">3.2.2. ~DOM内の要素</h4>

<p>
~DOM内の`~HTML要素$を表現している~nodeは、
この仕様の関連な節にて挙げられる~interfaceを実装して~scriptに公開するモノトスル。
これには、
`~XML文書$内の`~HTML要素$も含まれる
— それらの文書が別の文脈~内にあるときでも
（例： XSLT 形式変換の内側）。
◎
The nodes representing HTML elements in the DOM must implement, and expose to scripts, the interfaces listed for them in the relevant sections of this specification. This includes HTML elements in XML documents, even when those documents are in another context (e.g. inside an XSLT transform).
</p>

<p>
~DOM内の要素は、
それが内在的に有する`意味^em
— 意味論とも呼ばれる —
を
`表現-@
する。
◎
Elements in the DOM represent things; that is, they have intrinsic meaning, also known as semantics.
</p>

<p class="example">
例えば、
`ol$e 要素は，有順序~listを表現する。
◎
For example, an ol element represents an ordered list.
</p>

<p>
要素は、
何らかの仕方で［
明示的／暗黙的
］に
`参照-@
できる（指せる）。
~DOM内の要素を明示的に参照する仕方の一つは、
要素に `id$a 属性を与えて，［
その値を `href$a 属性~値の`素片＠~HTMLnav#navigate-fragid$に伴わせた`~hyperlink$
］を作成することである。
しかしながら、
参照~用には~hyperlinkが必要とされているわけではない
— 当の要素を指すようなどの方式でも，事足りる。
◎
Elements can be referenced (referred to) in some way, either explicitly or implicitly. One way that an element in the DOM can be explicitly referenced is by giving an id attribute to the element, and then creating a hyperlink with that id attribute's value as the fragment for the hyperlink's href attribute value. Hyperlinks are not necessary for a reference, however; any manner of referring to the element in question will suffice.
</p>

<div class="example">
<p>
`id$a 属性が付与されている，次の `figure$e 要素を考える：
◎
Consider the following figure element, which is given an id attribute:
</p>

`elements-in-the-dom-1^xCode

<p>
`~hyperlink$に基づく`参照-$は、
次の様に `a$e 要素を利用すれば作成できる：
◎
A hyperlink-based reference could be created using the a element, like so:
</p>

`elements-in-the-dom-2^xCode

<p>
しかしながら， `figure$e 要素を`参照-$する仕方には他にも多くある：
◎
However, there are many other ways of referencing the figure element, such as:
</p>

<ul>
	<li>
“モジュール A, B, C, D が成す図に示されているように…”
◎
"As depicted in the figure of modules A, B, C, and D..."
</li>
	<li>
“図 27 において…” （~hyperlinkなしに）
◎
"In Figure 27..." (without a hyperlink)
</li>
	<li>
“図 "~~単純なモジュールグラフ" の内容から…”
◎
"From the contents of the 'simple module graph' figure..."
</li>
	<li>
“下の図における…” 
（が、
このようには`しないことが奨励される＠~HEgrouping#figure-note-about-references$）
◎
"In the figure below..." (but this is discouraged)
</li>
</ul>
</div>

<p>
`HTMLElement$I ~interfaceは、
すべての`~HTML要素$~interfaceが継承する基本的~interfaceであり，
追加的な要件がない要素に利用されるモノトスル。
◎
The basic interface, from which all the HTML elements' interfaces inherit, and which must be used by elements that have no additional requirements, is the HTMLElement interface.
</p>

<pre class="idl">
[Exposed=Window]
interface `HTMLElement@I : `Element$I {
  [`HTMLConstructor$] constructor();

  /* <span class="comment">
~metadata属性
◎
metadata attributes
</span> */
  [`CEReactions$] attribute DOMString `title$mE;
  [`CEReactions$] attribute DOMString `lang$m;
  [`CEReactions$] attribute boolean `translate$m;
  [`CEReactions$] attribute DOMString `dir$mE;

  /* <span class="comment">
`利用者~対話＠~HTMLinteraction#editing$
◎
user interaction
</span> */
  [`CEReactions$] attribute (boolean or unrestricted double or DOMString)? `hidden$mE;
  [`CEReactions$] attribute boolean `inert$m;
  undefined `click$m();
  [`CEReactions$] attribute DOMString `accessKey$m;
  readonly attribute DOMString `accessKeyLabel$m;
  [`CEReactions$] attribute boolean `draggable$m;
  [`CEReactions$] attribute boolean `spellcheck$m;
  [`CEReactions$] attribute DOMString `autocapitalize$m;

  [`CEReactions$] attribute [`LegacyNullToEmptyString$] DOMString `innerText$m;
  [`CEReactions$] attribute [`LegacyNullToEmptyString$] DOMString `outerText$m;

  `ElementInternals$I `attachInternals$m();

  /* <span class="comment">
~popover~API
◎
The popover API
</span> */
  undefined `showPopover$m();
  undefined `hidePopover$m();
  undefined `togglePopover$m(optional boolean %force);
  [`CEReactions$] attribute DOMString? `popover$m;
};

`HTMLElement$I includes `GlobalEventHandlers$I;
`HTMLElement$I includes `ElementContentEditable$I;
`HTMLElement$I includes `HTMLOrSVGElement$I;

[Exposed=Window]
interface `HTMLUnknownElement@I : `HTMLElement$I {
  /* <span class="comment">注記：
`HTMLConstructor$xA が無いのは`意図的である＠~HEcustom#customized-built-in-element-restrictions$
◎
Note: intentionally no [HTMLConstructor]
</span> */
};
</pre>

<p>
`HTMLElement$I ~interfaceは，いくつもの異種の特能に関係する
~methodや属性
を保持するので、
この~interfaceの~memberの記述は，この仕様の何~節かに散らばっている。
◎
The HTMLElement interface holds methods and attributes related to a number of disparate features, and the members of this interface are therefore described in various different sections of this specification.
</p>

<hr>

<p>
( `~HTML名前空間$, %名前 )
用の`要素~interface$は、
次に従って決定される：
◎
The element interface for an element with name name in the HTML namespace is determined as follows:
</p>

<ol>
	<li>
~IF［
%名前 ~IN {
`applet$eO,
`bgsound$eO,
`blink$eO,
`isindex$eO,
`keygen$eO,
`multicol$eO,
`nextid$eO,
`spacer$eO
}
］
⇒
~RET `HTMLUnknownElement$I
◎
If name is applet, bgsound, blink, isindex, keygen, multicol, nextid, or spacer, then return HTMLUnknownElement.
</li>
	<li>
~IF［
%名前 ~IN {
`acronym$eO, `basefont$eO, `big$eO, `center$eO, `nobr$eO, `noembed$eO, `noframes$eO, `plaintext$eO, `rb$eO, `rtc$eO, `strike$eO, `tt$eO
}
］
⇒
~RET `HTMLElement$I
◎
If name is acronym, basefont, big, center, nobr, noembed, noframes, plaintext, rb, rtc, strike, or tt, then return HTMLElement.
</li>
	<li>
~IF［
%名前 ~IN { `listing$eO, `xmp$eO }
］
⇒
~RET `HTMLPreElement$I
◎
If name is listing or xmp, then return HTMLPreElement.
</li>
	<li>
~IF［
局所~名 %名前 に対応する`要素~型$用の適切な~interfaceが，この仕様に定義されている
］
⇒
~RET その~interface
◎
Otherwise, if this specification defines an interface appropriate for the element type corresponding to the local name name, then return that interface.
</li>
	<li>
~IF［
%名前 用の適切な~interfaceが，`適用-可能な仕様$に定義されている
］
⇒
~RET それが定義している~interface
◎
If other applicable specifications define an appropriate interface for name, then return the interface they define.
</li>
	<li>
~IF［
%名前 は`妥当な~custom要素~名$である
］
⇒
~RET `HTMLElement$I
◎
If name is a valid custom element name, then return HTMLElement.
</li>
	<li>
~RET `HTMLUnknownElement$I
◎
Return HTMLUnknownElement.
</li>
</ol>

<p class="note">注記：
`妥当な~custom要素~名$の場合に，
`HTMLUnknownElement$I ではなく `HTMLElement$I を利用するのは、
未来にあり得る`昇格$に際し，［
要素の~prototype~chainを `HTMLElement$I から その~subclassへ真っ直ぐ翻訳する
］だけで済むようにするためにある
— `HTMLUnknownElement$I から無関係な~subclassへそらすような翻訳を要することなく。
◎
The use of HTMLElement instead of HTMLUnknownElement in the case of valid custom element names is done to ensure that any potential future upgrades only cause a linear transition of the element's prototype chain, from HTMLElement to a subclass, instead of a lateral one, from HTMLUnknownElement to an unrelated subclass.
</p>

<p>
~HTML要素と~SVG要素 `SVG$r から共有される特能は、
`HTMLOrSVGElement$I ~interface~mixinを利用する：
◎
Features shared between HTML and SVG elements use the HTMLOrSVGElement interface mixin: [SVG]
</p>

<pre class="idl">
interface mixin `HTMLOrSVGElement@I {
  [SameObject] readonly attribute `DOMStringMap$I `dataset$m;
  attribute DOMString `nonce$m; /* <span class="comment">
`CEReactions^xA が無いのは`意図的である＠~HTMLurl#nonce-does-not-update-dom$
◎
intentionally no [CEReactions]
</span> */

  [`CEReactions$] attribute boolean `autofocus$m;
  [`CEReactions$] attribute long `tabIndex$m;
  undefined `focus$m(optional `FocusOptions$I %options = {});
  undefined `blur$m();
};
</pre>

<div class="example">
<p>
~HTMLでも~SVGでもない要素を作成する例：
◎
An example of an element that is neither an HTML nor SVG element is one created as follows:
</p>

<pre class="lang-js">
const %el = document.createElementNS("some namespace", "example");
console.assert(%el.constructor === Element);
</pre>
</div>

			</section>
			<section id="html-element-constructors">
<h4 title="HTML element constructors">3.2.3. ~HTML要素の構築子</h4>

<p>
`~custom要素$ 特能を~supportするため、
すべての~HTML要素には，特別に挙動する構築子がある。
これは、
~IDL`拡張属性$
`HTMLConstructor@xA
を介して指示される。
それは、
所与の~interface用の`~interface~obj$が，~call時に特定の挙動を持つことを指示する
（挙動の詳細は下に定義される）。
◎
To support the custom elements feature, all HTML elements have special constructor behavior. This is indicated via the [HTMLConstructor] IDL extended attribute. It indicates that the interface object for the given interface will have a specific behavior when called, as defined in detail below.
</p>

<p>
`HTMLConstructor$xA 拡張属性は、
現れるならば，次をすべて満たしていなければナラナイ：
◎
The [HTMLConstructor] extended attribute＼
</p>

<ul>
	<li>
引数をとらない。
◎
must take no arguments,＼
</li>
	<li>
同じ~interface内では、
1 個の`構築子~演算$のみに 1 回だけ現れ，他所には現れない。
【部分的~interface定義も含めて。~interfaceを継承する~interfaceには、現れ得る。】
◎
and must only appear on constructor operations. It must appear only once on a constructor operation, and the interface must contain only the single, annotated constructor operation, and no others.＼
</li>
	<li>
注釈された構築子~演算は、
引数をとらないよう宣言されている。
◎
The annotated constructor operation must be declared to take no arguments.
</li>
</ul>

<div class="algo">
<p>
`HTMLConstructor$xA 拡張属性で注釈された`構築子~演算$を伴って宣言された~interfaceは、
次に与える`構築子を上書きする手続き$を備える：
◎
Interfaces declared with constructor operations that are annotated with the [HTMLConstructor] extended attribute have the following overridden constructor steps:
</p>
<ol>
	<li>
%registry ~LET `現在の大域~obj$の `CustomElementRegistry$I ~obj
◎
Let registry be the current global object's CustomElementRegistry object.
</li>
	<li>
<p>
~IF［
`NewTarget$jv ~EQ `作動中の関数~obj$
］
⇒
~THROW `TypeError$E
◎
If NewTarget is equal to the active function object, then throw a TypeError.
</p>

<div class="example">
<p>
これは、
~custom要素が`要素~interface$を構築子に利用して定義されたときに生じ得る：
◎
This can occur when a custom element is defined using an element interface as its constructor:
</p>

<pre class="lang-js">
%customElements.define("bad-1", HTMLButtonElement);
new HTMLButtonElement();          // (1)
document.createElement("bad-1");  // (2)
</pre>

<p>
この事例では、
`HTMLButtonElement$I の構築子を
（ (1) のように明示的に, または (2) のように暗黙的に）
実行する間、
`作動中の関数~obj$, `NewTarget$jv のいずれも `HTMLButtonElement$I 【！の構築子？】になる。
この検査がなければ、
局所~名が `bad-1^l である `HTMLButtonElement$I の~instanceを作成することもアリになる。
◎
In this case, during the execution of HTMLButtonElement (either explicitly, as in (1), or implicitly, as in (2)), both the active function object and NewTarget are HTMLButtonElement. If this check was not present, it would be possible to create an instance of HTMLButtonElement whose local name was bad-1.
</p>
</div>
	</li>
	<li>
%定義 ~LET %registry 内に［
`構築子$cD ~EQ `NewTarget$jv
］なる~entryが［
在るならば それ ／
無いならば ε
］
◎
Let definition be the entry in registry with constructor equal to NewTarget.＼
</li>
	<li>
<p>
~IF［
%定義 ~EQ ε
］
⇒
~THROW `TypeError$E
◎
If there is no such definition, then throw a TypeError.
</p>

<p class="note">
%registry 内には［
`構築子$cD ~EQ `undefined^jv
］なる~entryはあり得ないので、
この段は，~HTML要素~構築子が関数として~callされないようにもする
（その事例では `NewTarget$jv ~EQ `undefined^jv になるので）。
◎
Since there can be no entry in registry with a constructor of undefined, this step also prevents HTML element constructors from being called as functions (since in that case NewTarget will be undefined).
</p>
	</li>
	<li>
%~is0値 ~LET ~NULL
◎
Let is value be null.
</li>
	<li>
<p>
~IF［
%定義 の`局所~名$cD ~EQ %定義 の`名前$cD
（すなわち %定義 は`自律的~custom要素$用のものである）
］：
◎
If definition's local name is equal to definition's name (i.e., definition is for an autonomous custom element), then:
</p>

		<ol>
			<li>
<p>
~IF［
`作動中の関数~obj$は `HTMLElement$I でない
］
⇒
~THROW `TypeError$E
◎
If the active function object is not HTMLElement, then throw a TypeError.
</p>

<div class="example">
<p>
これが生じ得るのは、
~custom要素は局所~名を拡張しないよう定義されているが，
非 `HTMLElement$I ~classを継承している場合である：
◎
This can occur when a custom element is defined to not extend any local names, but inherits from a non-HTMLElement class:
</p>

<pre class="lang-js">
%customElements.define("bad-2", class Bad2 extends HTMLParagraphElement {});
</pre>

<p>
この事例では、
`Bad2^c の~instanceを構築するときに生じる（暗黙的な） `super()^c ~callの間、
`作動中の関数~obj$は `HTMLParagraphElement$I であり， `HTMLElement$I でない。
◎
In this case, during the (implicit) super() call that occurs when constructing an instance of Bad2, the active function object is HTMLParagraphElement, not HTMLElement.
</p>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE（すなわち， %定義 は`~custom化された組込みの要素$用のものである）
：
◎
Otherwise (i.e., if definition is for a customized built-in element):
</p>
		<ol>
			<li>
`妥当な局所~名たち^V ~LET
この仕様も含む`適用-可能な仕様$にて定義される各種~要素のうち［
`要素~interface$として`作動中の関数~obj$を利用するもの
］の，局所~名からなる集合
◎
Let valid local names be the list of local names for elements defined in this specification or in other applicable specifications that use the active function object as their element interface.
</li>
			<li>
<p>
~IF［
%定義 の`局所~名$cD ~NIN `妥当な局所~名たち^V 
］
⇒
~THROW `TypeError$E
◎
If valid local names does not contain definition's local name, then throw a TypeError.
</p>

<div class="example">
<p>
これが生じ得るのは、
~custom要素は所与の局所~名を拡張するよう定義されているが，
間違った~classを継承しているときである：
◎
This can occur when a custom element is defined to extend a given local name but inherits from the wrong class:
</p>

<pre class="lang-js">
%customElements.define("bad-3", class Bad3 extends HTMLQuoteElement {}, { extends: "p" });
</pre>

<p>
この事例では、
`Bad3^c の~instanceを構築するときに生じる（暗黙的な） `super()^c ~callの間，
`妥当な局所~名たち^V は［
`q$e, `blockquote$e
］を包含しているが、
%定義 の`局所~名$cD は `p$e であり，それに含まれてない。
◎
In this case, during the (implicit) super() call that occurs when constructing an instance of Bad3, valid local names is the list containing q and blockquote, but definition's local name is p, which is not in that list.
</p>
</div>
			</li>
			<li>
%~is0値 ~SET %定義 の`名前$cD
◎
Set is value to definition's name.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%定義 の`構築~stack$cDは空である
］：
◎
If definition's construction stack is empty, then:
</p>
		<ol>
			<li>
%要素 ~LET `~interfaceを実装する新たな~objを作成する$( `作動中の関数~obj$に対応する~interface, `現在の~realm$, `NewTarget$jv )
◎
Let element be the result of internally creating a new object implementing the interface to which the active function object corresponds, given the current realm and NewTarget.
</li>
			<li>
%要素 の
⇒＃
`~node文書$ ~SET `現在の大域~obj$に`結付けられている文書$,
`名前空間$ ~SET `~HTML名前空間$,
`名前空間~接頭辞$ ~SET ~NULL,
`局所~名$ ~SET %定義 の`局所~名$cD,
`~custom要素~状態$ ~SET `custom^l,
`~custom要素~定義$ ~SET %定義,
`~is0値$ ~SET %~is0値
◎
Set element's node document to the current global object's associated Document.
◎
Set element's namespace to the HTML namespace.
◎
Set element's namespace prefix to null.
◎
Set element's local name to definition's local name.
◎
Set element's custom element state to "custom".
◎
Set element's custom element definition to definition.
◎
Set element's is value to is value.
</li>
			<li>
~RET %要素
◎
Return element.
</li>
		</ol>

<p class="note">注記：
この段は、
作者~scriptが，新たな~custom要素を直に構築したときに生じる
— 例えば `new MyCustomElement()^c を介して。
◎
This occurs when author script constructs a new custom element directly, e.g. via new MyCustomElement().
</p>

	</li>
	<li>
%~prototype ~LET
~ABRUPT `Get$jA( `NewTarget$jv, `prototype^l)
◎
Let prototype be ? Get(NewTarget, "prototype").
</li>
	<li>
<p>
~IF［
`Type$jA( %~prototype ) ~NEQ `Object^jc
］：
◎
If Type(prototype) is not Object, then:
</p>
		<ol>
			<li>
%~realm ~LET
~ABRUPT `GetFunctionRealm$jA( `NewTarget$jv )
◎
Let realm be ? GetFunctionRealm(NewTarget).
</li>
			<li>
%~prototype ~SET
%~realm の`~interface~prototype~obj$のうち，その~interfaceは `作動中の関数~obj$の~interfaceと同じであるもの
◎
Set prototype to the interface prototype object of realm whose interface is the same as the interface of the active function object.
</li>
	</ol>

<p class="note">注記：
`作動中の関数~obj$の~realmは %~realm でないこともあるので、
より一般的な概念
— ~realm間にわたる “同じ~interface” —
を利用しており，
`~interface~obj$の同等性は~~求めていない。
この~fallbackによる挙動は
— `NewTarget$jv の~realmの利用と, そこにある適切な~prototypeを探し出すことも含め —
［
~JSに組込みの相似的な挙動, および
~Web~IDLの`~interfaceを実装する新たな~objを作成する$~algo
］に合致するように設計されている。
◎
The realm of the active function object might not be realm, so we are using the more general concept of "the same interface" across realms; we are not looking for equality of interface objects. This fallback behavior, including using the realm of NewTarget and looking up the appropriate prototype there, is designed to match analogous behavior for the JavaScript built-ins and Web IDL's internally create a new object implementing the interface algorithm.
</p>
	</li>
	<li>
%要素 ~LET %定義 の`構築~stack$cD内の最後の~entry
◎
Let element be the last entry in definition's construction stack.
</li>
	<li>
<p>
~IF［
%要素 ~EQ `すでに構築-済みを表す~marker$i
］
⇒
~THROW `InvalidStateError$E
◎
If element is an already constructed marker, then throw an "InvalidStateError" DOMException.
</p>

<div class="example">
<p>
これは、
`~custom要素~構築子$の内側で，作者~codeが［
`不適合tに$ `super()^c を~callする前に，
構築中の~classの別の~instanceを作成した
］ときに生じ得る：
◎
This can occur when the author code inside the custom element constructor non-conformantly creates another instance of the class being constructed, before calling super():
</p>

<pre class="lang-js">
let %doSillyThing = true;

class DontDoThis extends HTMLElement {
  constructor() {
    if (%doSillyThing) {
      %doSillyThing = false;
      new DontDoThis();
      /* <span class="comment">
`構築~stack$cDは今や， `すでに構築-済みを表す~marker$i を包含することになる。
◎
Now the construction stack will contain an already constructed marker.
</span> */
    }

    /* <span class="comment">
次は `InvalidStateError^E 例外で失敗することになる
◎
This will then fail with an "InvalidStateError" DOMException:
</span> */
    super();
  }
}</pre>
</div>

<div class="example">
<p>
また、
`~custom要素~構築子$の内側で，
作者~codeが `不適合tに$［
`super()^c を重ねて~callした
］ときにも生じ得る。
~JS仕様によれば、
これは，~superclassの構築子（すなわち，この~algo）を
— ~errorを投出する前に —
実際に，重ねて実行するので：
◎
This can also occur when author code inside the custom element constructor non-conformantly calls super() twice, since per the JavaScript specification, this actually executes the superclass constructor (i.e. this algorithm) twice, before throwing an error:
</p>

<pre class="lang-js">
class DontDoThisEither extends HTMLElement {
  constructor() {
    super();

    /* <span class="comment">
次の~callは 例外を投出するが、
それは
`HTMLElement^m 構築子の中へ~callした後になる。
◎
This will throw, but not until it has already called into the HTMLElement constructor
</span> */
    super();
  }
}
</pre>
</div>

	</li>
	<li>
~ABRUPT %要素.`SetPrototypeOf^sl( %prototype )
◎
Perform ? element.[[SetPrototypeOf]](prototype).
</li>
	<li>
%定義 の`構築~stack$cD内の最後の~entryを， `すでに構築-済みを表す~marker$i で置換する
◎
Replace the last entry in definition's construction stack with an already constructed marker.
</li>
	<li>
<p>
~RET %要素
◎
Return element.
</p>

<p class="note">注記：
この段に到達するのは、
通常は，~custom要素を`昇格$するときである。
`~custom要素~構築子$の内側からの `super()^c ~callにて，
<b>this</b> に既存の要素をアテガうようにするため、
その既存の要素を返す。
◎
This step is normally reached when upgrading a custom element; the existing element is returned, so that the super() call inside the custom element constructor assigns that existing element to this.
</p>

	</li>
</ol>
</div>

<p>
`HTMLConstructor$xA により含意される構築子の挙動に加えて、
`旧来の~factory関数$も有する要素もある
（その実は、
`prototype^c ~propが改変された，~factory関数である）。
◎
In addition to the constructor behavior implied by [HTMLConstructor], some elements also have named constructors (which are really factory functions with a modified prototype property).
</p>

<div class="example">
<p>
~HTML要素~用の旧来の~factory関数は、
`~custom要素~構築子$を定義するときにも，
`extends^c ~clause内で利用できる：
◎
Named constructors for HTML elements can also be used in an extends clause when defining a custom element constructor:
</p>

<pre class="lang-js">
class AutoEmbiggenedImage extends Image {
  constructor(%width, %height) {
    super(%width * 10, %height * 10);
  }
}

%customElements.define("auto-embiggened", AutoEmbiggenedImage, { extends: "img" });

const %image = new AutoEmbiggenedImage(15, 20);
console.assert(%image.width === 150);
console.assert(%image.height === 200);

</pre>
</div>

			</section>
			<section id="element-definitions">
<h4 title="Element definitions">3.2.4. 要素~定義</h4>

<p>
この仕様における各種 要素には、
次の情報を含む定義が与えられる：
◎
Each element in this specification has a definition that includes the following information:
</p>

<dl>
	<dt id="concept-element-categories">
分類
（ `Categories^en ）
</dt>
	<dd>
要素が属するとされる`分類$の~list。
これらの`分類$は、
要素の`内容~model$を定義するときに利用される。
◎
A list of categories to which the element belongs. These are used when defining the content models for each element.
</dd>

	<dt id="concept-element-contexts">
この要素を利用できる文脈
（ `Contexts in which this element can be used^en ）
</dt>
	<dd>
要素をどこで利用できるかについての，`規範的でない^em記述。
この情報は、
冗長であり，もっぱら便利~用に供される
— 自身／他の要素の内容~modelにて供される情報（次項）と~~重複するので。
◎
A non-normative description of where the element can be used. This information is redundant with the content models of elements that allow this one as a child, and is provided only as a convenience.
</dd>
	<dd class="note">
<p>注記：
簡略化するため、
ここには最も特定な期待のみ挙げられる。
◎
For simplicity, only the most specific expectations are listed.
</p>

<p>
例えば，すべての`句ng内容$は`~flow内容$でもある。
したがって，`句ng内容$である要素に対しては、
“`句ng内容$が期待される所”
のみ挙げられることになる
— この方が，より特定な期待~なので。
`~flow内容$を期待する所は、
どこであれ`句ng内容$も期待する
— したがって、
要素は，その期待も満たすことになる。
◎
For example, all phrasing content is flow content. Thus, elements that are phrasing content will only be listed as "where phrasing content is expected", since this is the more-specific expectation. Anywhere that expects flow content also expects phrasing content, and thus also meets this expectation.
</p>
	</dd>

	<dt id="concept-element-content-model">
内容~model
（ `Content model^en ）
</dt>
	<dd>
要素の子孫に含めなければナラナイ内容についての，規範的な記述。
◎
A normative description of what content must be included as children and descendants of the element.
</dd>

	<dt id="concept-element-tag-omission">
`text/html^c における~tag省略
（ `Tag omission in text/html^en ）
</dt>
	<dd>
`text/html$c 構文において，［
`開始~tag$／`終了~tag$
］を省略できるかどうかについての，`規範的でない^em記述。
この情報は、
冗長であり，もっぱら便利~用に供される
— 規範的な要件は、
`§ 省略可能な~tag＠~HTMLwriting#optional-tags$
にて与えられる。
◎
A non-normative description of whether, in the text/html syntax, the start and end tags can be omitted. This information is redundant with the normative requirements given in the optional tags section, and is provided in the element definitions only as a convenience.
</dd>
	<dd class="trans-note">【
“省略できる” とは、［
構文が妥当な~markupにおいて当の~tagを省略しても，元と同じ~DOM~treeが生成される
］
（より正確aには、［
所与の~DOM~treeを直列化した結果から当の~tagを省略しても，構文上は妥当になる
］かつ［
それを構文解析し直した結果は，
元の~treeと一致する
（開始~tagを省略した場合，その内容~属性の有無を除いて一致する）
］）
ことを意味すると考えればよいであろう。
例えば，ある条件の下で開始~tagを省略できる要素もあるが（例： `body$e ）、
その場合に省略しても，~DOM~treeには依然としてその要素が生成されることになる。
】【
開始~tagの省略が、
終了~tagの省略も含意するわけではない
— これらを省略できる条件は互いに独立であり、
省略できる開始~tagを省略して終了~tagだけ残しても，構文上は妥当になる。
】</dd>

	<dt id="concept-element-attributes">内容~属性（ `Content attributes^en ）</dt>
	<dd>
要素に指定されてもヨイ属性を挙げる，規範的な~list
（他により許容されないものは除く）。
加えて、
それらの属性についての規範的でない記述
（ ~dash（ "—" ）の左側に記される内容は規範的であり，右側の内容はそうでない）。
◎
A normative list of attributes that may be specified on the element (except where otherwise disallowed), along with non-normative descriptions of those attributes. (The content to the left of the dash is normative, the content to the right of the dash is not.)
</dd>

	<dt id="concept-element-accessibility-considerations">
~accessibilityの考慮点
（ `Accessibility considerations^en ）
</dt>
	<dd>
作者~向け：
~ARIA［
`role$a ／ `aria-*$a
］属性 `ARIA$r を利用するための適合性~要件は、
`ARIAHTML$r にて定義される。
◎
For authors: Conformance requirements for use of ARIA role and aria-* attributes are defined in ARIA in HTML. [ARIA] [ARIAHTML]
</dd>
	<dd>
実装者~向け：
~accessibility~API意味論を実装するための~UA要件は、
`HTMLAAM$r にて定義される。
◎
For implementers: User agent requirements for implementing accessibility API semantics are defined in HTML Accessibility API Mappings. [HTMLAAM]
</dd>

	<dt id="concept-element-dom">
~DOM~interface
（ `DOM interface^en ）
</dt>
	<dd>
当の要素が実装するモノトスル~DOM~interfaceについての，規範的な定義。
◎
A normative definition of a DOM interface that such elements must implement.
</dd>
</dl>

<p>
上述の定義には、［
要素が何を`表現-$するかについての記述
］, および［［
作者／実装
］に適用され得る，追加的な規範的な適合性~判定基準
］も後続する。
例が含められることもある。
◎
This is then followed by a description of what the element represents, along with any additional normative conformance criteria that may apply to authors and implementations. Examples are sometimes also included.
</p>

				<section id="attributes">
<h5 title="Attributes">3.2.4.1. 属性</h5>

<p id="attribute-text">
属性~値は文字列である。
他から指定されない限り、
`~HTML要素$の属性~値は
— 空~文字列も含め —
どのような文字列~値もとり得る
— そのような属性に指定し得る~textに制約はない。
◎
An attribute value is a string. Except where otherwise specified, attribute values on HTML elements may be any string value, including the empty string, and there is no restriction on what text can be specified in such attribute values.
</p>

				</section>
			</section>
			<section id="content-models">
<h4 title="Content models">3.2.5. 内容~model</h4>

<p>
この仕様にて定義される各~要素は、
要素に期待される`内容$を記述する，内容~modelを有する。
`~HTML要素$の内容は、
要素の内容~modelに述べられる要件に合致しなければナラナイ。
要素の
`内容@
とは、
~DOMにおける要素の子たちである。
◎
Each element defined in this specification has a content model: a description of the element's expected contents. An HTML element must have contents that match the requirements described in the element's content model. The contents of an element are its children in the DOM.
</p>

<p>
要素たちの合間には，`~ASCII空白$が常に許容される。
~UAは、［
~source~markup内の要素の合間にある~ASCII空白
］を，~DOM内では `Text$I ~nodeとして表現する。
0 個以上の`~ASCII空白$のみからなる `Text$I ~nodeは、
`要素間~空白@
と見なされる。
◎
ASCII whitespace is always allowed between elements. User agents represent these characters between elements in the source markup as Text nodes in the DOM. Empty Text nodes and Text nodes consisting of just sequences of those characters are considered inter-element whitespace.
</p>

<div class="p">
<p>
［
`要素間~空白$ ／
~comment~node ／
処理命令~node
］は、
次の文脈においては，無視するモノトスル：
</p>

<ul><li>要素の内容が要素の内容~modelに合致するかどうか確かめるとき。
</li><li>文書や要素の意味論を定義する~algoに従うとき。
</li></ul>

◎
Inter-element whitespace, comment nodes, and processing instruction nodes must be ignored when establishing whether an element's contents match the element's content model or not, and must be ignored when following algorithms that define document and element semantics.
</div>

<div class="note">
<p>注記：
したがって，これらの文脈においては：
</p>
<ul>
	<li>
2 つの要素は、［
互いの親~nodeは一致する, かつ それらの合間に［
他の要素~node,
`要素間~空白$以外の `Text$I ~node
］は無い
］ならば，`~~隣接する^i とされる。
</li>
	<li>
同様に，要素の子~nodeは、
その要素が子~nodeの他に包含するものが［
`要素間~空白$, ~comment~node, 処理命令~node
］に限られるならば，要素の唯一の子になる。
</li>
</ul>
◎
Thus, an element A is said to be preceded or followed by a second element B if A and B have the same parent node and there are no other element nodes or Text nodes (other than inter-element whitespace) between them. Similarly, a node is the only child of an element if that element contains no other nodes other than inter-element whitespace, comment nodes, and processing instruction nodes.
</div>

<p>
作者は、［
各~要素に定義される ／
他の仕様から明示的に要求される
］ような，明示的に許容される所を除いて、
`~HTML要素$を利用してはナラナイ。
~XMLが複合されている文書に対しては、
他の名前空間に属する要素の内側であっても［
その種の要素は、
関連な文脈を供するものと定義されている
］ならば，この文脈になり得る。
◎
Authors must not use HTML elements anywhere except where they are explicitly allowed, as defined for each element, or as explicitly required by other specifications. For XML compound documents, these contexts could be inside elements from other namespaces, if those elements are defined as providing the relevant contexts.
</p>

<p class="example">
`ATOM$r では、
`content^e 要素が定義されていて，［
その `type^a 属性の値が `xhtml^l のときには、
単独の~HTML `div$e 要素を包含する
］ことが要求される。
したがって， `div$e 要素は、
その仕様により明示的に規範的であるものと言明されていなくとも，
その文脈においては許容される。
◎
The Atom Syndication Format defines a content element. When its type attribute has the value xhtml, The Atom Syndication Format requires that it contain a single HTML div element. Thus, a div element is allowed in that context, even though this is not explicitly normatively stated by this specification. [ATOM]
</p>

<p>
加えて，`~HTML要素$は、
孤立している
— すなわち，親~nodeがない —
場合もある。
◎
In addition, HTML elements may be orphan nodes (i.e. without a parent node).
</p>

<div class="example">
<p>
例えば、［
`td$e 要素を利用できる場所は，
`tr$e 要素の内側のみ
］と想定されているが、［
~scriptで `td$e 要素を作成して，大域的~変数に格納する
］ことは，適合である。
◎
For example, creating a td element and storing it in a global variable in a script is conforming, even though td elements are otherwise only supposed to be used inside tr elements.
</p>

<pre class="lang-js">
var %data = {
  name: "バナナ",
  cell: document.createElement('td'),
};
</pre>
<!-- Banana -->
</div>

				<section id="the-nothing-content-model">
<h5 title="The &quot;nothing&quot; content model">3.2.5.1. “なし” 内容~model</h5>

<p>
内容~modelが
`なし@
（ `nothing^en ）とされている要素は、
次に挙げる~nodeを包含してはナラナイ
⇒＃
`要素間~空白$以外の `Text$I ~node ／
要素~node
◎
When an element's content model is nothing, the element must contain no Text nodes (other than inter-element whitespace) and no element nodes.
</p>

<p class="note">注記：
内容~modelが “なし” とされている~HTML要素のうち，ほとんどは、
簡便に記せるよう，
`~void要素$
（`~HTML構文$において `終了~tag$がない要素）
にされているが、
これらは全く別々な概念である。
◎
Most HTML elements whose content model is "nothing" are also, for convenience, void elements (elements that have no end tag in the HTML syntax). However, these are entirely separate concepts.
</p>

				</section>
				<section id="kinds-of-content">
<h5 title="Kinds of content">3.2.5.2. 内容の種類</h5>

<p>
~HTMLにおける各種~要素は、
互いに特徴が類似するいくつかの~groupに
`分類-@
される。
各~要素は，これらのうち 0 個以上のものに該当する。
この仕様においては，次に挙げる大~分類が利用される
⇒＃
`~metadata内容$／
`~flow内容$／
`~sectioning内容$／
`見出し内容$／
`句ng内容$／
`埋込d内容$／
`対話的~内容$
◎
Each element in HTML falls into zero or more categories that group elements with similar characteristics together. The following broad categories are used in this specification:
• Metadata content
• Flow content
• Sectioning content
• Heading content
• Phrasing content
• Embedded content
• Interactive content
</p>

<p class="note">注記：
要素には、
他の分類にも該当するものがある。
それらは、
この仕様の他所にて定義される。
◎
Some elements also fall into other categories, which are defined in other parts of this specification.
</p>

<p>
これらの分類は、
次のように関係する：
◎
These categories are related as follows:
</p>

<div
	style="min-height: 600px;"
	aria-describedby="_content-venn-desc"
>
<iframe
	src="HTML-resources/content-venn.svg"
	height="600" width="500"
	style="border:none"
></iframe>
</div>

<p id="_content-venn-desc">
［
`~sectioning内容$,
`見出し内容$,
`句ng内容$,
`埋込d内容$,
`対話的~内容$
］は、
いずれも，`~flow内容$でもある。
`~metadata内容$には，`~flow内容$になるものもある。
［
`~metadata内容$／`対話的~内容$
］には，`句ng内容$になるものもある。
`埋込d内容$は、
`句ng内容$でもあり，
`対話的~内容$になるものもある。
◎
Sectioning content, heading content, phrasing content, embedded content, and interactive content are all types of flow content. Metadata is sometimes flow content. Metadata and interactive content are sometimes phrasing content. Embedded content is also a type of phrasing content, and sometimes is interactive content.
</p>

<p>
他の分類も特定の目的に利用される。
例えば~form~controlは、
共通な要件を定義するために，
いくつかの分類を利用して指定される。
一部の要素には，一意な要件があり、
どの特定0の分類にもあてはまらない。
◎
Other categories are also used for specific purposes, e.g. form controls are specified using a number of categories to define common requirements. Some elements have unique requirements and do not fit into any particular category.
</p>

					<section id="metadata-content">
<h6 title="Metadata content">3.2.5.2.1. ~metadata内容</h6>

<p>
`~metadata内容@
（ `metadata content^en ）は、［
他の内容の呈示や挙動を設定しておく ／
当の文書と他の文書との関係性を設定しておく ／
その他の “帯域外の” 情報を伝達する
］内容である：
◎
Metadata content is content that sets up the presentation or behavior of the rest of the content, or that sets up the relationship of the document with other documents, or that conveys other "out of band" information.
</p>

<ul class="brief category-list">
<li>`base$e
<li>`link$e
<li>`meta$e
<li>`noscript$e
<li>`script$e
<li>`style$e
<li>`template$e
<li>`title$e
</ul>

<p>
他の名前空間に属する要素であって，
その意味論が首に~metadataに関係するもの（例： RDF ）も、
`~metadata内容$である。
◎
Elements from other namespaces whose semantics are primarily metadata-related (e.g. RDF) are also metadata content.
</p>

<div class="example">
<p>
したがって，~XML直列化においては、
RDF を次の様に利用できる：
◎
Thus, in the XML serialization, one can use RDF, like this:
</p>

`metadata-1^xCode

<p>
しかしながら，これは、
~HTML直列化においてはアリでない。
◎
This isn't possible in the HTML serialization, however.
</p>
</div>

					</section>
					<section id="flow-content">
<h6 title="Flow content">3.2.5.2.2. ~flow内容</h6>

<p>
文書の~bodyや~appにて利用されるほとんどの要素は、
`~flow内容@
（ `flow content^en ）に分類される：
◎
Most elements that are used in the body of documents and applications are categorized as flow content.
</p>

<ul class="brief category-list">
<li>`a$e
<li>`abbr$e
<li>`address$e
<li>`area$e （ `map$e 要素の子孫であるものに限る）
◎
area (if it is a descendant of a map element)
<li>`article$e
<li>`aside$e
<li>`audio$e
<li>`b$e
<li>`bdi$e
<li>`bdo$e
<li>`blockquote$e
<li>`br$e
<li>`button$e
<li>`canvas$e
<li>`cite$e
<li>`code$e
<li>`data$e
<li>`datalist$e
<li>`del$e
<li>`details$e
<li>`dfn$e
<li>`dialog$e
<li>`div$e
<li>`dl$e
<li>`em$e
<li>`embed$e
<li>`fieldset$e
<li>`figure$e
<li>`footer$e
<li>`form$e
<li>`h1$e
<li>`h2$e
<li>`h3$e
<li>`h4$e
<li>`h5$e
<li>`h6$e
<li>`header$e
<li>`hgroup$e
<li>`hr$e
<li>`i$e
<li>`iframe$e
<li>`img$e
<li>`input$e
<li>`ins$e
<li>`kbd$e
<li>`label$e
<li>`link$e （ `~body内に許容される$ものに限る）
◎
link (if it is allowed in the body)
<li>`main$e （`階層的に正しく$なるものに限る）
◎
main (if it is a hierarchically correct main element)
<li>`map$e
<li>`mark$e
<li>`~MathML-math$
<li>`menu$e
<li>`meta$e （ `itemprop$a 属性を有するものに限る）
◎
meta (if the itemprop attribute is present)
<li>`meter$e
<li>`nav$e
<li>`noscript$e
<li>`object$e
<li>`ol$e
<li>`output$e
<li>`p$e
<li>`picture$e
<li>`pre$e
<li>`progress$e
<li>`q$e
<li>`ruby$e
<li>`s$e
<li>`samp$e
<li>`script$e
<li>`section$e
<li>`select$e
<li>`slot$e
<li>`small$e
<li>`span$e
<li>`strong$e
<li>`sub$e
<li>`sup$e
<li>`~SVG-svg$
<li>`table$e
<li>`template$e
<li>`textarea$e
<li>`time$e
<li>`u$e
<li>`ul$e
<li>`var$e
<li>`video$e
<li>`wbr$e
<li>`自律的~custom要素$
<li>`~text$
</ul>

					</section>
					<section id="sectioning-content">
<h6 title="Sectioning content">3.2.5.2.3. ~sectioning内容</h6>

<p>
`~sectioning内容@
（ `sectioning content^en ）は、［
`header$e ／ `footer$e
］要素の視野を定義する内容である：
◎
Sectioning content is content that defines the scope of header and footer elements.
</p>

<ul class="brief category-list">
<li>`article$e
<li>`aside$e
<li>`nav$e
<li>`section$e
</ul>

					</section>
					<section id="heading-content">
<h6 title="Heading content">3.2.5.2.4. 見出し内容</h6>

<p>
`見出し内容@
（ `heading content^en ）は、
~sectionの見出しを定義する
（~sectionは、
`~sectioning内容$要素を利用して明示的に,
または 見出し内容~自身により暗黙的に，
~mark-upされる）：
◎
Heading content defines the heading of a section (whether explicitly marked up using sectioning content elements, or implied by the heading content itself).
</p>

<ul class="brief category-list">
<li>`h1$e
<li>`h2$e
<li>`h3$e
<li>`h4$e
<li>`h5$e
<li>`h6$e
<li>`hgroup$e （子孫に `h1^e 〜 `h6^e いずれかの要素が在るものに限る）
◎
hgroup (if it has a descendant h1 to h6 element)
</ul>

					</section>
					<section id="phrasing-content">
<h6 title="Phrasing content">3.2.5.2.5. 句ng内容</h6>

<p>
`句ng内容@
（ `phrasing content^en ）は、［
文書を成す~text／
文書を成す~textを段落~内の~levelで~mark-upする要素
］である。
`句ng内容$が成す連なりは、
`段落$を形成する：
◎
Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.
</p>

<ul class="brief category-list">
<li>`a$e
<li>`abbr$e
<li>`area$e （ `map$e 要素の子孫であるものに限る）
◎
area (if it is a descendant of a map element)
<li>`audio$e
<li>`b$e
<li>`bdi$e
<li>`bdo$e
<li>`br$e
<li>`button$e
<li>`canvas$e
<li>`cite$e
<li>`code$e
<li>`data$e
<li>`datalist$e
<li>`del$e
<li>`dfn$e
<li>`em$e
<li>`embed$e
<li>`i$e
<li>`iframe$e
<li>`img$e
<li>`input$e
<li>`ins$e
<li>`kbd$e
<li>`label$e
<li>`link$e （ `~body内に許容される$ものに限る）
◎
link (if it is allowed in the body)
<li>`map$e
<li>`mark$e
<li>`~MathML-math$
<li>`meta$e （ `itemprop$a 属性を有するものに限る）
◎
meta (if the itemprop attribute is present)
<li>`meter$e
<li>`noscript$e
<li>`object$e
<li>`output$e
<li>`picture$e
<li>`progress$e
<li>`q$e
<li>`ruby$e
<li>`s$e
<li>`samp$e
<li>`script$e
<li>`select$e
<li>`slot$e
<li>`small$e
<li>`span$e
<li>`strong$e
<li>`sub$e
<li>`sup$e
<li>`~SVG-svg$
<li>`template$e
<li>`textarea$e
<li>`time$e
<li>`u$e
<li>`var$e
<li>`video$e
<li>`wbr$e
<li>`自律的~custom要素$
<li>`~text$
</ul>

<p class="note">注記：
句ng内容に分類されるほとんどの要素は、
句ng内容に分類される要素のみを包含し得る
— ~~任意の~flow内容ではなく。
◎
Most elements that are categorized as phrasing content can only contain elements that are themselves categorized as phrasing content, not any flow content.
</p>

<p>
内容~modelの文脈における
`~text@
は、［
`なし$, または `Text$I ~node
］を意味する。
`~text$は，内容~modelに利用されることもあるが、
分類としては，`句ng内容$や`要素間~空白$
（ 0 個以上の`~ASCII空白$のみからなる `Text$I ~node）
にもなり得る。
◎
Text, in the context of content models, means either nothing, or Text nodes. Text is sometimes used as a content model on its own, but is also phrasing content, and can be inter-element whitespace (if the Text nodes are empty or contain just ASCII whitespace).
</p>

<p>
［
`Text$I ~nodeを成す文字列／
内容~属性の値
］は、
次を満たさなければナラナイ
⇒
［
`~scalar値$のみからなる
］~AND［
`非文字$は包含しない
］~AND［
`~ASCII空白$以外の`制御~文字$は包含しない
］
◎
Text nodes and attribute values must consist of scalar values, excluding noncharacters, and controls other than ASCII whitespace.＼
</p>

<p>
この仕様は、
精確な文脈に依存して，［
`Text$I ~nodeを成す文字列／
内容~属性の値
］がとり得る~~範囲に さらに拘束を課すこともある。
◎
This specification includes extra constraints on the exact value of Text nodes and attribute values depending on their precise context.
</p>

					</section>
					<section id="embedded-content-2">
<h6 title="Embedded content">3.2.5.2.6. 埋込d内容</h6>

<p>
`埋込d内容@
（ `embedded content^en ）は、
文書の中に［
別の資源を取込む／
別の語彙に属する内容を挿入する
］ような内容である：
◎
Embedded content is content that imports another resource into the document, or content from another vocabulary that is inserted into the document.
</p>

<ul class="brief category-list">
<li>`audio$e
<li>`canvas$e
<li>`embed$e
<li>`iframe$e
<li>`img$e
<li>`~MathML-math$
<li>`object$e
<li>`picture$e
<li>`~SVG-svg$
<li>`video$e
</ul>

<p>
`~HTML名前空間$以外の名前空間に属する要素であって，~metadataでない内容を伝達するものは、
この仕様にて定義される内容~modelの目的においては，
`埋込d内容$になる
（例： MathML, ~SVG ）。
◎
Elements that are from namespaces other than the HTML namespace and that convey content but not metadata, are embedded content for the purposes of the content models defined in this specification. (For example, MathML or SVG.)
</p>

<p>
埋込d内容を与える要素には、
外部~資源を利用できないとき
（例：~supportされない形式であるため）
に利用される，
`~fallback内容@
を持つものもある。
何が~fallbackにあたるのかは、
それぞれの要素~定義にて言明される。
◎
Some embedded content elements can have fallback content: content that is to be used when the external resource cannot be used (e.g. because it is of an unsupported format). The element definitions state what the fallback is, if any.
</p>

					</section>
					<section id="interactive-content">
<h6 title="Interactive content">3.2.5.2.7. 対話的~内容</h6>

<p>
`対話的~内容@
（ `interactive content^en ）は、
利用者~対話~用に特に意図されている内容である：
◎
Interactive content is content that is specifically intended for user interaction.
</p>

<ul class="brief category-list">
<li>`a$e （ `href$a 属性を有するものに限る）
◎
a (if the href attribute is present)
<li>`audio$e （ `controls$a 属性を有するものに限る）
◎
audio (if the controls attribute is present)
<li>`button$e
<li>`details$e
<li>`embed$e
<li>`iframe$e
<li>`img$e （ `usemap$a 属性を有するものに限る）
◎
img (if the usemap attribute is present)
<li>`input$e （ `type$a 属性の状態 ~NEQ `Hidden$st なるものに限る）
◎
input (if the type attribute is not in the Hidden state)
<li>`label$e
<li>`select$e
<li>`textarea$e
<li>`video$e （ `controls$a 属性を有するものに限る）
◎
video (if the controls attribute is present)
</ul>

					</section>
					<section id="palpable-content">
<h6 title="Palpable content">3.2.5.2.8. 可触~内容</h6>

<p>
一般~規則として、
内容~modelにて，何らかの`~flow内容$や`句ng内容$が許容されるような要素は、
その`内容$内に 1 個以上の［
`可触~内容$であって, `hidden$a 属性が指定されていない
］~nodeを持つべきである。
◎
As a general rule, elements whose content model allows any flow content or phrasing content should have at least one node in its contents that is palpable content and that does not have the hidden attribute specified.
</p>

<div class="note">
<p>注記：
`可触~内容$は、
次のいずれかを供して要素を空でなくする：
</p>
<ul>
	<li>
何らかの子孫
</li>
	<li>
空でない`~text$
</li>
	<li>
利用者が［
聴ける（ `audio$e 要素）／
見れる（ `video$e, `img$e, `canvas$e 要素）／
ヤリトリできる（対話的~form~controlなど）
］ような何か
</li>
</ul>
◎
Palpable content makes an element non-empty by providing either some descendant non-empty text, or else something users can hear (audio elements) or view (video, img, or canvas elements) or otherwise interact with (for example, interactive form controls).
</div>

<p>
この要件は難しいものではないが、
要素が正当に空になり得るような多くの事例がある。
例えば、［
要素が~scriptにより後で埋められるような仮入力として利用されるとき
］や［
要素は~templateの一部を成していて、
ほとんどの~pageでは埋められるが，ある~pageでは関連しないとき
］など。
◎
This requirement is not a hard requirement, however, as there are many cases where an element can be empty legitimately, for example when it is used as a placeholder which will later be filled in by a script, or when the element is part of a template and would on most pages be filled in but on some pages is not relevant.
</p>

<p>
適合性~検査器には、
この要件を充足できない要素を見出す仕組みを，
作者の著作~援助として供することが奨励される。
◎
Conformance checkers are encouraged to provide a mechanism for authors to find elements that fail to fulfill this requirement, as an authoring aid.
</p>

<p>
次に挙げる要素が
`可触~内容@
（
`palpable content^en
【（利用者が） “触れれる内容” 】
）とされる：
◎
The following elements are palpable content:
</p>

<ul class="brief category-list">
<li>`a$e
<li>`abbr$e
<li>`address$e
<li>`article$e
<li>`aside$e
<li>`audio$e （ `controls$a 属性を有するものに限る）
◎
audio (if the controls attribute is present)
<li>`b$e
<li>`bdi$e
<li>`bdo$e
<li>`blockquote$e
<li>`button$e
<li>`canvas$e
<li>`cite$e
<li>`code$e
<li>`data$e
<li>`del$e
<li>`details$e
<li>`dfn$e
<li>`div$e
<li>`dl$e （ `dt^e, `dd^e ~groupを子に持つものに限る）
◎
dl (if the element's children include at least one name-value group)
<li>`em$e
<li>`embed$e
<li>`fieldset$e
<li>`figure$e
<li>`footer$e
<li>`form$e
<li>`h1$e
<li>`h2$e
<li>`h3$e
<li>`h4$e
<li>`h5$e
<li>`h6$e
<li>`header$e
<li>`hgroup$e
<li>`i$e
<li>`iframe$e
<li>`img$e
<li>`input$e （ `type$a 属性の状態 ~NEQ `Hidden$st なるものに限る）
◎
input (if the type attribute is not in the Hidden state)
<li>`ins$e
<li>`kbd$e
<li>`label$e
<li>`main$e
<li>`map$e
<li>`mark$e
<li>`~MathML-math$
<li>`menu$e （ 1 個以上の `li$e 要素を子に持つものに限る）
◎
menu (if the element's children include at least one li element)
<li>`meter$e
<li>`nav$e
<li>`object$e
<li>`ol$e （ 1 個以上の `li$e 要素を子に持つものに限る）
◎
ol (if the element's children include at least one li element)
<li>`output$e
<li>`p$e
<li>`picture$e
<li>`pre$e
<li>`progress$e
<li>`q$e
<li>`ruby$e
<li>`s$e
<li>`samp$e
<li>`section$e
<li>`select$e
<li>`small$e
<li>`span$e
<li>`strong$e
<li>`sub$e
<li>`sup$e
<li>`~SVG-svg$
<li>`table$e
<li>`textarea$e
<li>`time$e
<li>`u$e
<li>`ul$e （ 1 個以上の `li$e 要素を子に持つものに限る）
◎
ul (if the element's children include at least one li element)
<li>`var$e
<li>`video$e
<li>`自律的~custom要素$
<li>`~text$ （`要素間~空白$でないものに限る）
◎
text that is not inter-element whitespace
</ul>

					</section>
					<section id="script-supporting-elements">
<h6 title="Script-supporting elements">3.2.5.2.9. ~scriptを~supportする要素</h6>

<p>
`~scriptを~supportする要素@
は、
それ自身は何も`表現-$しない（すなわち，具現化されない）が，
例えば利用者に機能性を供するためとして、
~scriptを~supportするために利用されるものである。
◎
Script-supporting elements are those that do not represent anything themselves (i.e. they are not rendered), but are used to support scripts, e.g. to provide functionality for the user.
</p>

<p>
次に挙げる要素が~scriptを~supportする：
◎
The following elements are script-supporting elements:
</p>

<ul class="brief category-list">
<li>`script$e
<li>`template$e
</ul>

					</section>
				</section>
				<section id="transparent-content-models">
<h5 title="Transparent content models">3.2.5.3. 透過的な内容~model</h5>

<p>
一部の要素は、
その内容~modelにおいて “透過的（ `transparent^en ）” と記述される部分を持つ
— そのような要素は、
`透過的@
と呼ばれる。
`透過的$な要素 %要素 の内容~modelは、
その親~要素の内容~modelから導出される。
すなわち、
%要素 の内容~modelにおいて “透過的” とされている所では、［
%要素 の親の内容~modelにおいて， %要素 が許容される所
］に要求されるものと同じ要素が要求される。
◎
Some elements are described as transparent; they have "transparent" in the description of their content model. The content model of a transparent element is derived from the content model of its parent element: the elements required in the part of the content model that is "transparent" are the same elements as required in the part of the content model of the parent of the transparent element in which the transparent element finds itself.
</p>

<div class="example">
<p>
一例として， `ins$e 要素は、
透過的であり、
`ruby$e 要素の子であるときは， `rt$e 要素を包含できない
— ［
`ruby$e 要素の内容~modelにおいて `ins$e 要素が許容される部分
］は，`句ng内容$を許容する部分であり、
`rt$e 要素は`句ng内容$ではないので。
◎
For instance, an ins element inside a ruby element cannot contain an rt element, because the part of the ruby element's content model that allows ins elements is the part that allows phrasing content, and the rt element is not phrasing content.
</p>
</div>

<p class="note">注記：
透過的な要素が入子にされているような事例では、
この処理nは反復的に適用される必要がある。
◎
In some cases, where transparent elements are nested in each other, the process has to be applied iteratively.
</p>

<div class="example">
<p>
次の~markup片を考える：
◎
Consider the following markup fragment:
</p>

`transparent-1^xCode

<p>
"りんご" が `a$e 要素の内側に許容されるか検査するため、
内容~modelが精査される。
`a$e 要素,
その親の `map$e 要素,
そのまた親の `ins$e 要素の内容~modelは透過的であり、
そのまた親の `object$e 要素の内容~modelにおいて `ins$e 要素が現れ得る部分もまた，透過的である。
"りんご" は~textであり，~textは句ng内容であり，［
これらの要素を挟んで “透過的” に "りんご" を包含している `p$e 要素
］の内容~modelは`句ng内容$なので、
"りんご" は許容されることになる。
◎
To check whether "Apples" is allowed inside the a element, the content models are examined. The a element's content model is transparent, as is the map element's, as is the ins element's, as is the part of the object element's in which the ins element is found. The object element is found in the p element, whose content model is phrasing content. Thus, "Apples" is allowed, as text is phrasing content.
</p>
</div>

<p>
透過的な要素に親~要素【！親】が無い場合、
その内容~modelにおいて “透過的” な部分は，
どの`~flow内容$も受容するものと扱うモノトスル。
◎
When a transparent element has no parent, then the part of its content model that is "transparent" must instead be treated as accepting any flow content.
</p>

				</section>
				<section id="paragraphs">
<h5 title="Paragraphs">3.2.5.4. 段落</h5>

<p class="note">注記：
この節に定義される用語 `段落$は、
単なる `p$e 要素の定義より広い概念であり，
文書をどう解釈するかを述べるために利用される。
`p$e 要素は、
`段落$を~mark-upするいくつかの仕方の一つに過ぎない。
◎
The term paragraph as defined in this section is used for more than just the definition of the p element. The paragraph concept defined here is used to describe how to interpret documents. The p element is merely one of several ways of marking up a paragraph.
</p>

<p>
`段落@
は，概して、
特定0の論題をいくつかの文章で論じる`句ng内容$の連なりからなり，
~typographyに見られるような~textの~blockを形成するが、
より一般的な~themaによる~group分けにも利用し得る。
一例として、
~addressは段落でもあり，［
~form／署名行／詩の一節
］の一部分も同じく段落である。
◎
A paragraph is typically a run of phrasing content that forms a block of text with one or more sentences that discuss a particular topic, as in typography, but can also be used for more general thematic grouping. For instance, an address is also a paragraph, as is a part of a form, a byline, or a stanza in a poem.
</p>

<div class="example">
<p>
次の例には、
`section^e 内に 2 個の段落がある。
また、
句ng内容を包含する，段落でない見出しもある。
~commentや`要素間~空白$は、
段落を形成しないことに注意。
◎
In the following example, there are two paragraphs in a section. There is also a heading, which contains phrasing content that is not a paragraph. Note how the comments and inter-element whitespace do not form paragraphs.
</p>

`paragraph-1^xCode
</div>

<p>
`~flow内容$における段落は、
文書から［
`a$e, `ins$e, `del$e, `map$e
］要素を除いたときの見かけを基準に定義される。
これらの要素の内容~modelは、［
混成的であり、
下の最初の 2 つの例に示されるように，段落~境界を不明瞭にし得る
］ため，問題mを複雑にするので。
◎
Paragraphs in flow content are defined relative to what the document looks like without the a, ins, del, and map elements complicating matters, since those elements, with their hybrid content models, can straddle paragraph boundaries, as shown in the first two examples below.
</p>

<p class="note">注記：
一般に，要素~間の段落~境界は、
不明瞭にしないのが最良である。
そのような~markupを保守するのは困難にもなり得る。
◎
Generally, having elements straddle paragraph boundaries is best avoided. Maintaining such markup can be difficult.
</p>

<div class="example">
<p>
次の例は、
先掲の例と同じ~markupの一部分を `ins$e, `del$e 要素で括って，
~textが変更されたことを示している
（この~markupは、
変更らしきものとは言えないが）。
この例では、
`ins$e, `del$e 要素があるにもかかわらず，
先掲の例と正確に同じ段落を成すことに注意
— `ins$e 要素は，見出しと 1 個目の段落を不明瞭にしていて、
`del$e 要素は， 2 つの段落の合間の境界を不明瞭にしている。
◎
The following example takes the markup from the earlier example and puts ins and del elements around some of the markup to show that the text was changed (though in this case, the changes admittedly don't make much sense). Notice how this example has exactly the same paragraphs as the previous one, despite the ins and del elements — the ins element straddles the heading and the first paragraph, and the del element straddles the boundary between the two paragraphs.
</p>

`paragraph-2^xCode
</div>

<p>
文書~内のすべての［
`a$e, `ins$e, `del$e, `map$e
］要素を，それぞれの`内容$に置換した結果の~DOMにおける、［
`句ng内容$も`句ng内容$以外の内容も受容する要素
］における、［
他の型の内容に割込まれないような，互いに同胞の`句ng内容$~nodeの連なり
］であって，［
`埋込d内容$でも`要素間~空白$でもない~nodeを 1 個以上含むもの
］を考える。
元の~DOMにおける段落は、
そのような各~連なりの［
最初の~nodeの直前から, 最後の~nodeの直後まで
］に存在する（段落は，したがって［
`a$e ／ `ins$e ／ `del$e ／ `map$e
］要素をまたがり得る）。
◎
Let view be a view of the DOM that replaces all a, ins, del, and map elements in the document with their contents. Then, in view, for each run of sibling phrasing content nodes uninterrupted by other types of content, in an element that accepts content other than phrasing content as well as phrasing content, let first be the first node of the run, and let last be the last node of the run. For each such run that consists of at least one node that is neither embedded content nor inter-element whitespace, a paragraph exists in the original DOM from immediately before first to immediately after last. (Paragraphs can thus span across a, ins, del, and map elements.)
</p>

<p>
適合性~検査器は、
段落どうしが互いに重合する事例に際し，作者に警告してもヨイ
（これは［
`object$e ／ `video$e ／ `audio$e ／ `canvas$e
］要素にて起こり得る。
また、［
`~SVG-svg$ ／ `~MathML-math$
］など，［
その中で更なる埋込d~HTMLを許容するような，他の名前空間に属する要素
］を通しても間接的に起こり得る。
◎
Conformance checkers may warn authors of cases where they have paragraphs that overlap each other (this can happen with object, video, audio, and canvas elements, and indirectly through elements in other namespaces that allow HTML to be further embedded therein, like SVG svg or MathML math).
</p>

<p>
`段落$はまた， `p$e 要素により明示的に形成される。
◎
A paragraph is also formed explicitly by p elements.
</p>

<p class="note">注記：
互いの段落を分離するような，句ng内容~以外の内容がない所では、
`p$e 要素を利用して個々の段落を包装できる。
◎
The p element can be used to wrap individual paragraphs when there would otherwise not be any content other than phrasing content to separate the paragraphs from each other.
</p>

<div class="example">
<p>
次の例では、
~linkは［
1 個目の段落の半分,
2 個の段落を分離している見出しすべて,
2 個目の段落の半分
］に渡る。
それは、
段落と見出しを不明瞭にする。
◎
In the following example, the link spans half of the first paragraph, all of the heading separating the two paragraphs, and half of the second paragraph. It straddles the paragraphs and the heading.
</p>

`paragraph-3^xCode

<p>
これを~mark-upする別の仕方を次に示す
— 今度は、
段落を明示的に示した上で， 1 個の~link要素を 3 個に分割する：
◎
Here is another way of marking this up, this time showing the paragraphs explicitly, and splitting the one link element into three:
</p>

`paragraph-4^xCode
</div>

<div class="example">
<p>
~fallback内容を定義する，ある種の要素を利用しているときには、
段落どうしが重合することもある。
例えば、
次の `section^e には：
◎
It is possible for paragraphs to overlap when using certain elements that define fallback content. For example, in the following section:
</p>

`paragraph-5^xCode

<p>
次が記された， 5 個の段落がある：
◎
There are five paragraphs:
</p>

<ol class="brief">
	<li>
"猫シミュレータで遊びませんか。 `object^i 面白いから是非！
— ここで、
`object^i は `object$e 要素である。
◎
The paragraph that says "You can play with my cat simulator. object I'm quite proud of it.", where object is the object element.
</li>
	<li>
"猫シミュレータは、
次のリンクから遊べます："
◎
The paragraph that says "To see the cat simulator, use one of the following links:".
</li>
	<li>
"シミュレータ ファイルをダウンロードする"
◎
The paragraph that says "Download simulator file".
</li>
	<li>
"オンライン シミュレータを~~利用する"
◎
The paragraph that says "Use online simulator".
</li>
	<li>
"Mellblom ブラウザは最新版にアップグレードすることをすすめます。"
◎
The paragraph that says "Alternatively, upgrade to the Mellblom Browser.".
</li>
</ol>

<p>
最初の段落は、
他の 4 つと重なっている。
"cats.sim" 資源を~supportする~UAは、
最初のもののみを示すことになる。
一方で，~fallbackを示す~UAは、
最初の段落の最初の文章を［
それが 2 個目のものと同じ段落であるかのように，混同して示す
］ことになり，
最後の段落を［
それが最初の段落の 2 個目の文章の開始であったかのように示す
］ことになる。
◎
The first paragraph is overlapped by the other four. A user agent that supports the "cats.sim" resource will only show the first one, but a user agent that shows the fallback will confusingly show the first sentence of the first paragraph as if it was in the same paragraph as the second one, and will show the last paragraph as if it was at the start of the second sentence of the first paragraph.
</p>

<p>
この混同を避けるには、
明示的 `p$e 要素を利用できる。
例えば：
◎
To avoid this confusion, explicit p elements can be used. For example:
</p>

`paragraph-6^xCode
</div>

				</section>
			</section>
			<section id="global-attributes">
<h4 title="Global attributes">3.2.6. 大域的な属性</h4>

<p>
次に挙げる属性は、
すべての`~HTML要素$（この仕様に定義されていないものも含む）に共通する
— どの~HTML要素に指定してもヨイ：
◎
The following attributes are common to and may be specified on all HTML elements (even those not defined in this specification):
</p>

<ul class="category-list">
<li>`accesskey$a
<li>`autocapitalize$a
<li>`autofocus$a
<li>`contenteditable$a
<li>`dir$a
<li>`draggable$a
<li>`enterkeyhint$a
<li>`hidden$a
<li>`inert$a
<li>`inputmode$a
<li>`is$a
<li>`itemid$a
<li>`itemprop$a
<li>`itemref$a
<li>`itemscope$a
<li>`itemtype$a
<li>`lang$a
<li>`nonce$a
<li>`popover$a
<li>`spellcheck$a
<li>`style$a
<li>`tabindex$a
<li>`title$a
<li>`translate$a
</ul>

<p>
これらの属性は、
この仕様により，`~HTML要素$用の属性として定義されるものに限られる。
この仕様がこれらの属性を有する要素を参照rする所では、
他の名前空間に属する要素は，これらの属性を
— 有せるものと定義されていない限り —
有するとは見なさないモノトスル。
◎
These attributes are only defined by this specification as attributes for HTML elements. When this specification refers to elements having these attributes, elements from namespaces that are not defined as having these attributes must not be considered as being elements with these attributes.
</p>

<div class="example">
<p>
例えば、
次の~XML片における `bogus^l 要素は、
~literalとして名前 `dir^l の属性を有しているが、
にもかかわらず，この仕様にて定義される `dir$a 属性は有さないとされる。
したがって，~~内側の `span$e 要素の`方向性$は、
`div$e 要素から `bogus^l 要素を通して間接的に継承される結果，
`~rtl$ （ `rtl^v ）になる。
◎
For example, in the following XML fragment, the "bogus" element does not have a dir attribute as defined in this specification, despite having an attribute with the literal name "dir". Thus, the directionality of the inner-most span element is 'rtl', inherited from the div element indirectly through the "bogus" element.
</p>

`global-attr-1^xCode
</div>

<hr>

<p>
`DOM$r は、
名前空間を問わず，どの要素~用にも［
`class@a ／ `id@a ／ `slot@a
］属性~用の~UA要件を定義している。
◎
DOM defines the user agent requirements for the class, id, and slot attributes for any element in any namespace. [DOM]
</p>

<p>
［
`class$a ／ `id$a ／ `slot$a
］属性は、
どの`~HTML要素$に指定してもヨイ。
◎
The class, id, and slot attributes may be specified on all HTML elements.
</p>

<p>
`~HTML要素$上に指定する `class$a 属性の値は、
`~space等で分離された~token集合$でなければナラナイ
— 要素が属する種々の~classを表現するような。
◎
When specified on HTML elements, the class attribute must have a value that is a set of space-separated tokens representing the various classes that the element belongs to.
</p>

<div class="note">
<p>注記：
要素に~classをあてがうことは、［
~CSSにおける選択子の~class照合 ／
~DOMにおける `getElementsByClassName()$m ~method ／
他のその種の特能
］に影響する。
◎
Assigning classes to an element affects class matching in selectors in CSS, the getElementsByClassName() method in the DOM, and other such features.
</p>

<p>
作者が `class$a 属性に利用できる~tokenには，追加的な制約はないが、
作者には，［
内容に欲される呈示ではなく，内容の資質を述べる値
］を利用することが奨励される。
◎
There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content.
</p>
</div>

<div class="p">
<p>
`~HTML要素$に指定する `id$a 属性の値は、
次のいずれも満たさなければナラナイ：
</p>
<ul>
	<li>
`~tree$内の すべての要素にわたって，要素の`~ID$（ ~NEQ ε ）は一意になる
</li>
	<li>
1 個以上の文字を包含する
</li>
	<li>
`~ASCII空白$を包含しない
</li>
</ul>
◎
When specified on HTML elements, the id attribute value must be unique amongst all the IDs in the element's tree and must contain at least one character. The value must not contain any ASCII whitespace.
</div>

<div class="note">
<p>注記：
`id$a 属性は、
要素の`~ID$（一意な識別子）を指定する。
`DOM$r
◎
The id attribute specifies its element's unique identifier (ID).
</p>

<p>
~IDがとり得る形に他の制約は無い。
特に，~IDは、［
数字のみからなる ／
数字や~underscoreから開始する ／
約物のみからなる
］等々にもなり得る。
◎
There are no other restrictions on what form an ID can take; in particular, IDs can consist of just digits, start with a digit, start with an underscore, consist of just punctuation, etc.
</p>

<p>
要素の`~ID$は、
様々な目的に利用できる。
特に、［
`素片$urlを利用して 文書の特定の部位へ~linkする ／
~scripting時に要素を~targetにする ／
特定の要素に~CSSで~styleをあてがう
］用途が多い。
◎
An element's unique identifier can be used for a variety of purposes, most notably as a way to link to specific parts of a document using fragments, as a way to target an element when scripting, and as a way to style a specific element from CSS.
</p>
</div>

<p>
`id$a 属性の値による識別子は、
不透明な文字列であり，特定0の意味が導出されるべきでない。
◎
Identifiers are opaque strings. Particular meanings should not be derived from the value of the id attribute.
</p>

<p>
`slot$a 属性には、
`~HTML要素$に特有な適合性~要件はない。
◎
There are no conformance requirements for the slot attribute specific to HTML elements.
</p>

<p class="note">注記：
`slot$a 属性は、
要素を ある~slotに`割当する$ために利用される：
`slot$a 属性を有する要素は、
次を満たすような `slot$e 要素 %slot により作成される`~slot$に`割当される$
⇒
［
%slot の `slot.name$a 属性の値は `slot$a 属性の値に合致する
］~AND［
%slot が見出される`~shadow~tree$の`根$の`~host$が，対応する `slot$a 属性~値を持つ【？】
］
◎
The slot attribute is used to assign a slot to an element: an element with a slot attribute is assigned to the slot created by the slot element whose name attribute's value matches that slot attribute's value — but only if that slot element finds itself in the shadow tree whose root's host has the corresponding slot attribute value.
</p>

<hr>

<p>
支援技術~製品が，~HTMLの［
要素／属性
］でアリなものより木目細かな~interfaceを公開することを可能化するため、
一群の`支援技術~製品~用の注釈＠#wai-aria$（~ARIA `role$a, `aria-*$a 属性）を指定できる。
`ARIA$r
◎
To enable assistive technology products to expose a more fine-grained interface than is otherwise possible with HTML elements and attributes, a set of annotations for assistive technology products can be specified (the ARIA role and aria-* attributes). [ARIA]
</p>

<hr>

<p>
次に挙げる`~event~handler内容~属性$は、
どの`~HTML要素$上に指定してもヨイ：
◎
The following event handler content attributes may be specified on any HTML element:
</p>

<ul class="category-list">
<li>`onauxclick$hd
<li>`onbeforeinput$hd
<li>`onbeforetoggle$hd
<li>`onbeforematch$hd
<li>`onblur$hd†
<li>`oncancel$hd
<li>`oncanplay$hd
<li>`oncanplaythrough$hd
<li>`onchange$hd
<li>`onclick$hd
<li>`onclose$hd
<li>`oncontextlost$hd
<li>`oncontextmenu$hd
<li>`oncontextrestored$hd
<li>`oncopy$hd
<li>`oncuechange$hd
<li>`oncut$hd
<li>`ondblclick$hd
<li>`ondrag$hd
<li>`ondragend$hd
<li>`ondragenter$hd
<li>`ondragleave$hd
<li>`ondragover$hd
<li>`ondragstart$hd
<li>`ondrop$hd
<li>`ondurationchange$hd
<li>`onemptied$hd
<li>`onended$hd
<li>`onerror$hd†
<li>`onfocus$hd†
<li>`onformdata$hd
<li>`oninput$hd
<li>`oninvalid$hd
<li>`onkeydown$hd
<li>`onkeypress$hd
<li>`onkeyup$hd
<li>`onload$hd†
<li>`onloadeddata$hd
<li>`onloadedmetadata$hd
<li>`onloadstart$hd
<li>`onmousedown$hd
<li>`onmouseenter$hd
<li>`onmouseleave$hd
<li>`onmousemove$hd
<li>`onmouseout$hd
<li>`onmouseover$hd
<li>`onmouseup$hd
<li>`onpaste$hd
<li>`onpause$hd
<li>`onplay$hd
<li>`onplaying$hd
<li>`onprogress$hd
<li>`onratechange$hd
<li>`onreset$hd
<li>`onresize$hd†
<li>`onscroll$hd†
<li>`onscrollend$hd†
<li>`onsecuritypolicyviolation$hd
<li>`onseeked$hd
<li>`onseeking$hd
<li>`onselect$hd
<li>`onslotchange$hd
<li>`onstalled$hd
<li>`onsubmit$hd
<li>`onsuspend$hd
<li>`ontimeupdate$hd
<li>`ontoggle$hd
<li>`onvolumechange$hd
<li>`onwaiting$hd
<li>`onwheel$hd
</ul>

<p class="note">注記：
“†” が付与された属性は、
`body$e 要素に指定されたときには，異なる意味になる
— その要素は、
`Window$I ~objの同じ名前の`~event~handler$を公開するので。
◎
The attributes marked with an asterisk have a different meaning when specified on body elements as those elements expose event handlers of the Window object with the same names.
</p>

<p class="note">注記：
これらの属性は，すべての要素に適用されるとしても、
すべての要素~上で有用になるわけではない。
例えば、
~UAにより発火される `volumechange$et ~eventを受取れるのは，
`~media要素$に限られる。
◎
While these attributes apply to all elements, they are not useful on all elements. For example, only media elements will ever receive a volumechange event fired by the user agent.
</p>

<hr>

<p>
どの `~HTML要素$上にも，`~custom~data属性$（例： `data-foldername^a, `data-msgid^a 等々）を指定して，~pageに特有な［
~custom~data, 状態, 注釈, 等々
］を格納できる。
◎
Custom data attributes (e.g. data-foldername or data-msgid) can be specified on any HTML element, to store custom data, state, annotations, and similar, specific to the page.
</p>

<hr>

<p>
`~HTML文書$においては、
`~HTML名前空間$に属する要素には，
`xmlns^a 属性が指定されてもヨイ
— ただし，その値が正確に
`http://www.w3.org/1999/xhtml^l
である場合，その場合に限り。
このことは、
`~XML文書$には適用されない。
◎
In HTML documents, elements in the HTML namespace may have an xmlns attribute specified, if, and only if, it has the exact value "http://www.w3.org/1999/xhtml". This does not apply to XML documents.
</p>

<p class="note">注記：
~HTMLにおいては、
`xmlns^a 属性は，何ら効果はない。
それは，基本的に護符のようなものであり、
単に，~HTMLと~XMLとの間の移行を容易にするために許容されている。
`~HTML構文解析器$により構文解析されるときには、
この属性は，どの名前空間にも属さないようにされる
— ~XMLにおける名前空間~宣言~属性の様な，
`http://www.w3.org/2000/xmlns/^l
名前空間ではなく。
◎
In HTML, the xmlns attribute has absolutely no effect. It is basically a talisman. It is allowed merely to make migration to and from XML mildly easier. When parsed by an HTML parser, the attribute ends up in no namespace, not the "http://www.w3.org/2000/xmlns/" namespace like namespace declaration attributes in XML do.
</p>

<p class="note">注記：
~XMLにおいては、
`xmlns^a 属性は，名前空間~宣言の仕組みの一部を成す
— 要素が［
名前空間が指定されていない `xmlns^a 属性
］を実際に有することはできない。
◎
In XML, an xmlns attribute is part of the namespace declaration mechanism, and an element cannot actually have an xmlns attribute in no namespace specified.
</p>

<hr>

<p>
`XML$r はまた、
`~XML文書$内のどの要素にも，
`~XML名前空間$に属する `~xml_space$a 属性の利用を許容する。
この属性は、
`~HTML要素$には効果はない
— ~HTMLにおける既定の挙動は、
空白を保全するので。
◎
XML also allows the use of the xml:space attribute in the XML namespace on any element in an XML document. This attribute has no effect on HTML elements, as the default behavior in HTML is to preserve whitespace. [XML]
</p>

<p class="note">注記：
`text/html$c 構文の下で`~HTML要素$の
`~xml_space$a 属性を直列化する仕方はない。
◎
There is no way to serialize the xml:space attribute on HTML elements in the text/html syntax.
</p>

				<section id="the-title-attribute">
<h5 title="The title attribute">3.2.6.1. `title^a 属性</h5>

<div class="p">
<p>
`title@a
属性は、
~tooltipに適切になるような，
要素~用の助言的~情報を`表現-$する。
その値は~textであり：
</p>
<ul>
	<li>
~linkに対しては、
~target資源の~titleや記述にもなり得る。
</li>
	<li>
画像に対しては，画像~creditや画像の記述にもなり得る。
</li>
	<li>
段落に対しては，その~textの脚注や解説にもなり得る。
</li>
	<li>
引用元に対しては，その~sourceについての更なる情報にもなり得る。
</li>
	<li>
`対話的~内容$に対しては，要素の利用についての ~labelや指示書きにもなり得る。
</li>
</ul>

<p>
…等々。
</p>

◎
The title attribute represents advisory information for the element, such as would be appropriate for a tooltip. On a link, this could be the title or a description of the target resource; on an image, it could be the image credit or a description of the image; on a paragraph, it could be a footnote or commentary on the text; on a citation, it could be further information about the source; on interactive content, it could be a label for, or instructions for, use of the element; and so forth. The value is text.
</div>

<p class="note">注記：
現時点では、
`title$a 属性には依拠しないことが奨励される
— 多くの~UAは、
この属性を，この仕様に要求されるように~access可能な方式で公開していない
（例：~tooltipを現れさせるために，~mouseなどの~pointing装置を要求することは、
現代の携帯端末や~tabletを用いている，~keyboard／~touchのみの利用者たちを除外することになる）。
◎
Relying on the title attribute is currently discouraged as many user agents do not expose the attribute in an accessible manner as required by this specification (e.g., requiring a pointing device such as a mouse to cause a tooltip to appear, which excludes keyboard-only users and touch-only users, such as anyone with a modern phone or tablet).
</p>

<p>
この属性が要素から省略されている場合、［［
要素の先祖`~HTML要素$であって， `title$a 属性を有するもの
］のうち，要素に最も近いもの
］が，要素に関連することを含意する。
この属性を設定すれば、
それを上書きして，［
どの先祖の助言的~情報も，要素には関連しない
］ことを明示的に言明することになる。
この属性を空~文字列に設定した場合、［
要素には助言的~情報は無い
］ことを指示する。
◎
If this attribute is omitted from an element, then it implies that the title attribute of the nearest ancestor HTML element with a title attribute set is also relevant to this element. Setting the attribute overrides this, explicitly stating that the advisory information of any ancestors is not relevant to this element. Setting the attribute to the empty string indicates that the element has no advisory information.
</p>

<p>
`title$a 属性の値の中の 各 LF 文字（ `000A^U LINE FEED ）は、
改行を表現し，在るならば 内容は複数~行lに分割される。
◎
If the title attribute's value contains U+000A LINE FEED (LF) characters, the content is split into multiple lines. Each U+000A LINE FEED (LF) character represents a line break.
</p>

<div class="example">
<p>
`title$a 属性における改行文字の利用には、
注意すべき点がある。
◎
Caution is advised with respect to the use of newlines in title attributes.
</p>

<p>
一例として，次の片の<mark>略称の中の改行</mark>は、
`実際に展開される^emことになる：
◎
For instance, the following snippet actually defines an abbreviation's expansion with a line break in it:
</p>

`title-1^xCode
</div>

<p>
［
`link$e, `abbr$e, `input$e
］など，要素には、［
`title$a 属性~用に，上に述べた意味論を超える追加的な意味論を定義するもの
］もある。
◎
Some elements, such as link, abbr, and input, define additional semantics for the title attribute beyond the semantics described above.
</p>

<div class="algo">
<p>
要素の %要素 の
`助言的~情報@
は、
次の~algoが返す値である
— 結果が空~文字列の場合、
助言的~情報は無い：
◎
The advisory information of an element is the value that the following algorithm returns, with the algorithm being aborted once a value is returned. When the algorithm returns the empty string, then there is no advisory information.
</p>

<ol>
	<li>
~IF［
%要素 は `title$a 属性を有する
］
⇒
~RET その属性~値
◎
If the element has a title attribute, then return its value.
</li>
	<li>
~IF［
%要素 の親は要素である
］
⇒
~RET %要素 の親の`助言的~情報$
◎
If the element has a parent element, then return the parent element's advisory information.
</li>
	<li>
~RET 空~文字列
◎
Return the empty string.
</li>
</ol>
</div>

<p>
~UAは、
要素に`助言的~情報$があるときには，
そのことが利用者に判るように伝えるべきである。
◎
User agents should inform the user when elements have advisory information, otherwise the information would not be discoverable.
</p>

<hr>

<p>
`title@mE
~IDL属性は、
コレの `title$a 内容~属性を`反映する$モノトスル。
◎
The title IDL attribute must reflect the title content attribute.
</p>

				</section>
				<section id="the-lang-and-xml:lang-attributes">
<h5 title="The lang and xml:lang attributes">3.2.6.2. `lang^a 属性, `~xml_lang^a 属性</h5>

<p>
どの名前空間にも属さない
`lang@a
属性
— 以下，特に `~xml_lang$a 属性と区別する所では、
“（名前空間なし）” が付記される —
は、［
要素の内容, および
~textを包含するような要素の属性
］用の首な言語†を指定する。
その値は妥当な BCP 47 言語~tagか, 空~文字列でなければナラナイ。
空~文字列は、
首な言語が未知であることを指示する。
`BCP47$r
◎
The lang attribute (in no namespace) specifies the primary language for the element's contents and for any of the element's attributes that contain text. Its value must be a valid BCP 47 language tag, or the empty string. Setting the attribute to the empty string indicates that the primary language is unknown. [BCP47]
</p>

<p class="trans-note">【†
この節の “言語” は、
もっぱら自然言語（ヒトが話す言語）を意味する。
】</p>

<p>
`~XML名前空間$に<a href="~TR/xml/#sec-lang-tag">属する `lang^a 属性</a>
— 以下，
`~xml_lang@a
属性と略記する —
は、
~XMLにて定義される。
`XML$r
◎
The lang attribute in the XML namespace is defined in XML. [XML]
</p>

<p>
要素からこれらの属性が省略された場合、
この要素の言語は，要素の親は要素であるならば 親の言語と同じになる。
◎
If these attributes are omitted from an element, then the language of this element is the same as the language of its parent element, if any.
</p>

<p>
`lang$a 属性（名前空間なし）は、
どの`~HTML要素$にも利用してもヨイ。
◎
The lang attribute in no namespace may be used on any HTML element.
</p>

<p>
`~xml_lang$a 属性は、
他の名前空間に属する要素のみならず，
`~XML文書$内の`~HTML要素$にも利用できる
— 関連な仕様がそれを許容するならば
（特に， MathML, ~SVGは、
それらの要素に指定される `~xml_lang$a 属性を許容する）。
同じ要素に［
`lang$a 属性（名前空間なし）, 
`~xml_lang$a 属性
］の両者を指定する場合、
それらは，`~ASCII大小無視$で正確に同じ値でなければナラナイ。
◎
The lang attribute in the XML namespace may be used on HTML elements in XML documents, as well as elements in other namespaces if the relevant specifications allow it (in particular, MathML and SVG allow lang attributes in the XML namespace to be specified on their elements). If both the lang attribute in no namespace and the lang attribute in the XML namespace are specified on the same element, they must have exactly the same value when compared in an ASCII case-insensitive manner.
</p>

<div class="p">
<p>
作者は、
`~HTML文書$内の`~HTML要素$に， `~xml_lang$a 属性を利用してはナラナイ。
~XMLへの／からの移行を容易にするため、
作者は，`~HTML文書$内の`~HTML要素$に対しては、［
要素には `lang$a 属性（名前空間なし）も指定されている
］場合に限り，
次をすべて満たす属性を指定してもヨイ：
</p>

<ul>
	<li>
接頭辞を持たない
</li>
	<li>
~literalとして `~xml_lang^l を局所名に持つ
</li>
	<li>
どの名前空間にも属さない
</li>
	<li>
その値は， `lang$a 属性（名前空間なし）の値と`~ASCII大小無視$で同じある
</li>
</ul>

◎
Authors must not use the lang attribute in the XML namespace on HTML elements in HTML documents. To ease migration to and from XML, authors may specify an attribute in no namespace with no prefix and with the literal localname "xml:lang" on HTML elements in HTML documents, but such attributes must only be specified if a lang attribute in no namespace is also specified, and both attributes must have the same value when compared in an ASCII case-insensitive manner.
</div>

<p class="note">注記：
そのような属性が言語~処理に効果を及ぼすことはない。
◎
The attribute in no namespace with no prefix and with the literal localname "xml:lang" has no effect on language processing.
</p>

<hr>

<div class="algo">
<p>
~UAは、
~node %~node の
`言語@
を決定するときは、
次の手続きから返される言語~tag値に基づくモノトスル：
◎
To determine the language of a node, user agents must＼
</p>

<ol>
	<li>
%要素 ~LET ［
%~node は要素であるならば %~node ／
~ELSE_ %~node の親~要素
］
◎
↓</li>
	<li>
<p>
~IF［
%要素 の`広義-先祖$に，次のいずれかを満たすものがある
］…：
</p>
		<ul>
			<li>
`~xml_lang$a 属性を有する
</li>
			<li>
`~HTML要素$であって `lang$a 属性（名前空間なし）を有する
</li>
</ul>

<p>
…ならば：
</p>
		<ol>
			<li>
%先祖 ~LET そのような要素のうち %要素 に最も近いもの
</li>
			<li>
~IF［
%先祖 は `~xml_lang$a 属性を有する
］
⇒
~RET その属性の値
— `lang$a 属性（名前空間なし）は、
有していても`無視-$する。
</li>
			<li>
~RET %先祖 の `lang$a 属性（名前空間なし）の値
</li>
		</ol>
◎
look at the nearest ancestor element (including the element itself if the node is an element) that has a lang attribute in the XML namespace set or is an HTML element and has a lang in no namespace attribute set. That attribute specifies the language of the node (regardless of its value).
◎
If both the lang attribute in no namespace and the lang attribute in the XML namespace are set on an element, user agents must use the lang attribute in the XML namespace, and the lang attribute in no namespace must be ignored for the purposes of determining the element's language.
</li>
	<li>
~IF［
`~pragma集合の既定の言語$が設定されている
］
⇒
~RET それに対応する言語~tag
◎
If node's inclusive ancestors do not have either attribute set, but there is a pragma-set default language set, then that is the language of the node.＼
</li>
	<li>
~IF［
より高~levelの~protocol（~HTTPなど）から，単独の言語~情報が報告されている
］
⇒
~RET それに対応する言語~tag
◎
If there is no pragma-set default language set, then language information from a higher-level protocol (such as HTTP), if any, must be used as the final fallback language instead.＼
</li>
	<li>
~RET 空~文字列
— ~nodeの言語は未知とされる。
より高~levelの~protocolから複数の言語が報告されている場合も含む。
◎
In the absence of any such language information, and in cases where the higher-level protocol reports multiple languages, the language of the node is unknown, and the corresponding language tag is the empty string.
</li>
</ol>
</div>

<p>
上の結果が認識できる言語~tagでない場合、
~UAは，結果を［
その言語~tagを持つ未知な
— 他のすべての言語とは別個な —
言語
］として扱うモノトスル。
言語~tagを期待する他の~serviceと［
往来する／通信する
］目的においては、
未知な言語~tagを改変せずに渡すべきであり
— 後続な~serviceが，その~dataを別の型の言語~記述として解釈しないよう —
BCP 47 言語~tagであるものと~tag付けるべきである。
`BCP47$r
◎
If the resulting value is not a recognized language tag, then it must be treated as an unknown language having the given language tag, distinct from all other languages. For the purposes of round-tripping or communicating with other services that expect language tags, user agents should pass unknown language tags through unmodified, and tagged as being BCP 47 language tags, so that subsequent services do not interpret the data as another type of language description. [BCP47]
</p>

<p class="example">
したがって一例として，
`lang="xyzzy"^a
を伴う要素は、
（例えば~CSSにより）選択子
`:lang(xyzzy)^css
に合致するが，
`:lang(abcde)^css
には合致しない
— 両者とも等しく妥当でないが。
同様に，［
~web~browserと~screen-readerが，要素の言語について~~情報を~~交換しあっている
］下では、
~browserは［
妥当でないと知っていたとしても，
言語は `xyzzy^l であったものと~screen-readerに伝える
］ことになる
— ~screen-readerが，実際に その~tagの言語を~supportしている場合もあり得るので。
~screen-readerが［
BCP 47 に加えて，別の構文による言語~名の符号化法も~supportしていて、
そこでは文字列 `xyzzy^l が~Belarusianの言語~tagであった
］としても、
~screen-readerが~textを~Belarusianとして扱い始めるのは，`不正^emになる
— `xyzzy^l は、
BCP 47 ~codeにおいては~Belarusianとされていないので
（ BCP 47 は、
~Belarusianに~code `be^l を利用する）。
◎
Thus, for instance, an element with lang="xyzzy" would be matched by the selector :lang(xyzzy) (e.g. in CSS), but it would not be matched by :lang(abcde), even though both are equally invalid. Similarly, if a web browser and screen reader working in unison communicated about the language of the element, the browser would tell the screen reader that the language was "xyzzy", even if it knew it was invalid, just in case the screen reader actually supported a language with that tag after all. Even if the screen reader supported both BCP 47 and another syntax for encoding language names, and in that other syntax the string "xyzzy" was a way to denote the Belarusian language, it would be incorrect for the screen reader to then start treating text as Belarusian, because "xyzzy" is not how Belarusian is described in BCP 47 codes (BCP 47 uses the code "be" for Belarusian).
</p>

<p>
上の結果が空~文字列の場合、［
~nodeの言語は，明示的に未知である
］と解釈するモノトスル。
◎
If the resulting value is the empty string, then it must be interpreted as meaning that the language of the node is explicitly unknown.
</p>

<hr>

<p>
~UAは、
要素の言語を，適正な処理や具現化を決定する際に利用してもヨイ
（例：適切な［
~font／発音／辞書
］の選定や，日付~pickerなどの~form~control~UIなど）。
◎
User agents may use the element's language to determine proper processing or rendering (e.g. in the selection of appropriate fonts or pronunciations, for dictionary selection, or for the user interfaces of form controls such as date pickers).
</p>

<hr>

<p>
`lang@m
~IDL属性は、
コレの `lang$a 属性（名前空間なし）を`反映する$モノトスル。
◎
The lang IDL attribute must reflect the lang content attribute in no namespace.
</p>

				</section>
				<section id="the-translate-attribute">
<h5 title="The translate attribute">3.2.6.3. `translate^a 属性</h5>

<p>
`translate@a
属性は、
`列挙d属性$であり，当の要素の［
属性~値／ 子である `Text$I ~nodeの値
］を［
~pageを地域化する際に，翻訳するか, 変えないままにするかどうか
］を指定するために利用される。
◎
The translate attribute is an enumerated attribute that is used to specify whether an element's attribute values and the values of its Text node children are to be translated when the page is localized, or whether to leave them unchanged.
</p>

<div class="p">
<p>
この属性がとり得る~keyword, および状態は、
次で与えられる：
</p>

<dl class="switch">
	<dt>空~文字列</dt>
	<dt>`yes^v</dt>
	<dd>
`yes^st 状態に対応付けられる。
</dd>

	<dt>`no^v</dt>
	<dd>
`no^st 状態に対応付けられる。
</dd>

	<dt>`値なし用の既定$</dt>
	<dt>`妥当でない値~用の既定$</dt>
	<dd>
`inherit^st 状態に対応付けられる。
</dd>
</dl>

◎
The attribute's keywords are the empty string, yes, and no. The empty string and the yes keyword map to the yes state. The no keyword maps to the no state. In addition, there is a third state, the inherit state, which is the missing value default and the invalid value default.
</div>

<p>
各~要素は（非~HTML要素であっても），
`翻訳~mode@
を持つ。
それは［
`翻訳可能$st, `翻訳不可$st
］のいずれかであり、
要素の `translate$a 属性の状態に応じて：
◎
Each element (even non-HTML elements) has a translation mode, which is in either the translate-enabled state or the no-translate state.＼
</p>

<ul class="switch">
	<li>
`yes^st
⇒
`翻訳可能$st
◎
If an HTML element's translate attribute is in the yes state, then the element's translation mode is in the translate-enabled state;＼
</li>
	<li>
`no^st
⇒
`翻訳不可$st
◎
otherwise, if the element's translate attribute is in the no state, then the element's translation mode is in the no-translate state.＼
</li>
	<li>
<p>
`inherit^st
⇒＃
要素の`親~要素$ ~NEQ ~NULL ならば要素の`親~要素$の`翻訳~mode$ ／
~ELSE_ `翻訳可能$st
</p>

<p>
要素が`~HTML要素$でない場合も、
`translate$a 属性を有さないので，この場合に該当する。
</p>
◎
Otherwise, either the element's translate attribute is in the inherit state, or the element is not an HTML element and thus does not have a translate attribute; in either case, the element's translation mode is in the same state as its parent element's, if any, or in the translate-enabled state, if the element's parent element is null.
</li>
</ul>

<p>
要素の`翻訳~mode$に応じて：
◎
↓</p>

<ul class="switch">
	<li>
`翻訳可能@st
の下では
⇒
［
要素の`翻訳-可能な属性$, および
要素の子である `Text$I ~nodeの値
］は、
~pageが地域化される際に翻訳されることになる。
◎
When an element is in the translate-enabled state, the element's translatable attributes and the values of its Text node children are to be translated when the page is localized.
</li>
	<li>
`翻訳不可@st
の下では
⇒
［
要素の属性~値, および
要素の子である `Text$I ~nodeの値
］は、
~pageが地域化される際に そのままにされる
— 例：要素が［
人名／~computer~programの名前
］を包含しているとき。
◎
When an element is in the no-translate state, the element's attribute values and the values of its Text node children are to be left as-is when the page is localized, e.g. because the element contains a person's name or a name of a computer program.
</li>
</ul>

<p>
次の表の 1 列目に挙げる要素の，同じ行の 2 列目に示される（かつ 3 列目の条件があれば，それも満たす）属性が
`翻訳-可能な属性@
とされる：
◎
The following attributes are translatable attributes:
</p>

<div >
<table>
<thead><tr><th>要素
<th>内容~属性
<th>追加的な条件／要件
</thead>

<tbody>
<tr><td>`th$e
<td>`th.abbr$a
<td>

<tr><td>`area$e
<td>`area.alt$a
<td>

<tr><td>`img$e
<td>`img.alt$a
<td>

<tr><td>`input$e
<td>`input.alt$a
<td>

<tr><td>`meta$e
<td>`meta.content$a
<td>要素の `meta.name$a 属性の値が，翻訳-可能なことが既知である~metadata名を指定する場合に限る。

<tr><td>`a$e, `area$e
<td>`download$a
<td>

<tr><td>`optgroup$e
<td>`optgroup.label$a
<td>

<tr><td>`option$e
<td>`option.label$a
<td>

<tr><td>`track$e
<td>`track.label$a
<td>

<tr><td>`~HTML要素$
<td>`lang$a
<td>翻訳に利用されている言語に合致するように “翻訳される” モノトスル。

<tr><td>`input$e
<td>`input.placeholder$a
<td>

<tr><td>`textarea$e
<td>`textarea.placeholder$a
<td>

<tr><td>`iframe$e
<td>`srcdoc$a
<td>属性は、
構文解析された上で，再帰的に処理されるモノトスル。

<tr><td>`~HTML要素$
<td>`style$a
<td>属性は、
構文解析された上で，再帰的に処理されるモノトスル。
（例： `content$p ~propの値に対し）

<tr><td>すべての`~HTML要素$
<td>`title$a
<td>

<tr><td>`input$e
<td>`value$a
<td>要素の `type$a 属性の状態 ~IN
{ `Button$st, `Reset$st }
の場合に限る。

</tbody></table>

◎
• abbr on th elements
• alt on area, img, and input elements
• content on meta elements, if the name attribute specifies a metadata name whose value is known to be translatable
• download on a and area elements
• label on optgroup, option, and track elements
• lang on HTML elements; must be "translated" to match the language used in the translation
• placeholder on input and textarea elements
• srcdoc on iframe elements; must be parsed and recursively processed
• style on HTML elements; must be parsed and recursively processed (e.g. for the values of 'content' properties)
• title on all HTML elements
• value on input elements with a type attribute in the Button state or the Reset Button state
</div>

<p>
他の仕様も他の属性を`翻訳-可能な属性$として定義してもヨイ。
例えば， `ARIA$r は、
`aria-label$a 属性を翻訳-可能として定義することになろう。
◎
Other specifications may define other attributes that are also translatable attributes. For example, ARIA would define the aria-label attribute as translatable.
</p>

<hr>

<div class="algo">
`translate@m
取得子~手続きは
⇒
~RET ［
コレの`翻訳~mode$ ~EQ `翻訳可能$st ならば ~T ／
~ELSE_ ~F
］
◎
The translate IDL attribute must, on getting, return true if the element's translation mode is translate-enabled, and false otherwise.＼
</div>

<div class="algo">
`translate$m 設定子~手続きは
⇒
コレの `translate$a 内容~属性の値 ~SET 所与の値に応じて
⇒＃
~T ならば `yes^l ／
~F ならば `no^l
◎
On setting, it must set the content attribute's value to "yes" if the new value is true, and set the content attribute's value to "no" otherwise.
</div>

<div class="example">
<p>
この例では、［
<mark>見本~keyboard入力，見本~program出力</mark>
］を除く，文書~内のすべては、
~pageが地域化される際に翻訳される：
◎
In this example, everything in the document is to be translated when the page is localized, except the sample keyboard input and sample program output:
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html lang="en"&gt; &lt;!-- 文書~要素に対しては `translate=yes^a --&gt;
 &lt;head&gt;
  &lt;title&gt;The Bee Game&lt;/title&gt; &lt;!-- 先祖から暗黙的に `translate=yes^a が継承される --&gt;
 &lt;/head&gt;
 &lt;body&gt;
  &lt;p&gt;The Bee Game is a text adventure game in English.&lt;/p&gt;
  &lt;p&gt;When the game launches, the first thing you should do is type
  &lt;kbd <mark>translate=no</mark>&gt;eat honey&lt;/kbd&gt;. The game will respond with:&lt;/p&gt;
  &lt;pre&gt;&lt;samp <mark>translate=no</mark>&gt;Yum yum! That was some good honey!&lt;/samp&gt;&lt;/pre&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>
<!-- 

— default on the document element is translate=yes —
The Bee Game
— implied translate=yes inherited from ancestors —
 </head>
 <body>
  <p>The Bee Game is a text adventure game in English.</p>
  <p>When the game launches, the first thing you should do is type
  <kbd translate=no>eat honey</kbd>. The game will respond with:</p>
  <pre><samp translate=no>Yum yum! That was some good honey!</samp></pre>
 </body>
</html>
-->

				</section>
				<section id="the-dir-attribute">
<h5 title="The dir attribute">3.2.6.4. `dir^a 属性</h5>

<p>
`dir@a
属性は、
要素の~text方向性を指定する。
この属性は`列挙d属性$であり，次の~keyword, 状態をとり得る：
◎
The dir attribute specifies the element's text directionality. The attribute is an enumerated attribute with the following keywords and states:
</p>

<dl class="switch">
	<dt>`ltr@v （ “left-to-right” ）</dt>
	<dd>
`~ltr@st
状態に対応付けられる。
◎
The ltr keyword, which maps to the ltr state
</dd>
	<dd>
要素の内容は、
明示的に，左横書き~textとして方向的に隔離されることを指示する。
◎
Indicates that the contents of the element are explicitly directionally isolated left-to-right text.
</dd>

	<dt>`rtl@v （ “right-to-left” ）</dt>
	<dd>
`~rtl@st
状態に対応付けられる。
◎
The rtl keyword, which maps to the rtl state
</dd>
	<dd>
要素の内容は、
明示的に，右横書き~textとして方向的に隔離されることを指示する。
◎
Indicates that the contents of the element are explicitly directionally isolated right-to-left text.
</dd>

	<dt>`auto@v</dt>
	<dd>
`自動@st
状態に対応付けられる。
◎
The auto keyword, which maps to the auto state
</dd>
	<dd>
［
要素の内容は、
明示的に，方向的に隔離される~textである
］こと，および［
その方向は、
当の要素の内容を利用して，（下に述べるように）~program的に決定される
］ことを指示する。
◎
Indicates that the contents of the element are explicitly directionally isolated text, but that the direction is to be determined programmatically using the contents of the element (as described below).
</dd>
	<dd class="note">注記：
この状態の下で利用される経験則は、
ごく荒削りなものである
（それは、
双方向-~algoにおける Paragraph Level 決定に相似的な方式で，
強い方向性†を備える最初の文字を調べるだけである）。
作者には、［
当の~textの方向が まったく未知で，
適用できる より良い~server側~経験則もないとき
］の最後の~~手段としてに限って，この値を利用することが督促される。
`BIDI$r
◎
The heuristic used by this state is very crude (it just looks at the first character with a strong directionality, in a manner analogous to the Paragraph Level determination in the bidirectional algorithm). Authors are urged to only use this value as a last resort when the direction of the text is truly unknown and no better server-side heuristic can be applied. [BIDI]
</dd>
	<dd class="trans-note">【†
`双方向-字種$の大分類が `Strong^uc に該当する文字。
概ね、
文字~自身から，それを利用している~textの方向性を推定できるような文字
— ~Arabicのみに利用される文字であれば、
右横書き，等々。
】</dd>
	<dd class="trans-note">【
この節に現れる
`双方向-字種@
とは、
~Unicodeに定義される
`bidirectional character type＠http://unicode.org/reports/tr9/#Bidirectional_Character_Types$en
を指す。
】</dd>

	<dd class="note">注記：
［
`textarea$e ／ `pre$e
］要素~用には、
この経験則は，段落ごとの~levelで適用される。
◎
For textarea and pre elements, the heuristic is applied on a per-paragraph level.
</dd>

	<dt>`妥当でない値~用の既定$</dt>
	<dt>`値なし用の既定$</dt>
	<dd>
状態は無い（ ε ）。
◎
The attribute has no invalid value default and no missing value default.
</dd>
</dl>

<hr>

<div class="algo">
<p>
要素（`~HTML要素$でない要素も含む） %要素 の
`方向性@
は、［
`~ltr@,
`~rtl@
］のいずれかであり，次の手続きに従って決定される：
◎
The directionality of an element (any element, not just an HTML element) is either 'ltr' or 'rtl', and is determined as per the first appropriate set of steps from the following list:
</p>

<ol>
	<li>
%状態 ~LET %要素 の `dir$a 属性の状態
◎
↓</li>
	<li>
~IF［
%状態 ~EQ `~ltr$st
］
⇒
~RET `~ltr$
◎
If the element's dir attribute is in the ltr state
• ↓
</li>
	<li>
<p >
~IF［
%状態 ~EQ ε
］~AND［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%要素 は`文書~要素$である
</li>
			<li>
［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~EQ `Tel$st
］
</li>
		</ul>
<p>
…ならば
⇒
~RET `~ltr$
</p>
◎
If the element is a document element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
◎
If the element is an input element whose type attribute is in the Telephone state, and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
◎
• The directionality of the element is 'ltr'.
</li>
	<li>
~IF［
%状態 ~EQ `~rtl$st
］
⇒
~RET `~rtl$
◎
If the element's dir attribute is in the rtl state
• The directionality of the element is 'rtl'.
</li>
	<li>
<p >
~IF［
%状態 ~EQ `自動$st
］~AND［
次のいずれかが満たされる
］…：
◎
↓</p>
		<ul>
			<li>
［
%要素 は `input$e 要素である
］~AND［
%要素 の `type$a 属性の状態 ~IN {
`Text$st,
`Search$st,
`Tel$st,
`Url$st,
`Email$st
}
］
◎
If the element is an input element whose type attribute is in the Text, Search, Telephone, URL, or Email state, and the dir attribute is in the auto state
</li>
			<li>
%要素 は `textarea$e 要素である
◎
If the element is a textarea element and the dir attribute is in the auto state
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
%文字列 ~LET %要素 の`値$x
◎
↓</li>
			<li>
~IF［
%文字列 内に［
`双方向-字種$ ~IN
{ `L^uc, `AL^uc, `R^uc }
］なる文字がある `BIDI$r
］
⇒
~IF［
そのような最初の文字の`双方向-字種$ ~NEQ `L^uc
］
⇒
~RET `~rtl$
◎
If the element's value contains a character of bidirectional character type AL or R, and there is no character of bidirectional character type L anywhere before it in the element's value, then the directionality of the element is 'rtl'. [BIDI]
</li>
			<li>
~IF［
%文字列 ~NEQ 空~文字列
］~OR［
%要素 は`文書~要素$である
］
⇒
~RET `~ltr$
◎
Otherwise, if the element's value is not the empty string, or if the element is a document element, the directionality of the element is 'ltr'.
</li>
			<li>
~RET %要素 の親~要素の`方向性$
◎
Otherwise, the directionality of the element is the same as the element's parent element's directionality.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
</p>
		<ul>
			<li>
%状態 ~EQ `自動$st
◎
If the element's dir attribute is in the auto state
</li>
			<li>
［
%状態 ~EQ ε
］~AND［
%要素 は `bdi$e 要素である
］
◎
If the element is a bdi element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
<p>
%文字 ~LET 次のいずれも満たす文字のうち，`~tree順序$で最初のもの：
◎
Find the first character in tree order that matches the following criteria:
</p>
				<ul>
					<li>
%文字 は［
%要素 のある子孫 `Text$I ~node %T
］内にある
◎
The character is from a Text node that is a descendant of the element whose directionality is being determined.
</li>
					<li>
%文字 の`双方向-字種$ ~IN { `L^uc, `AL^uc, `R^uc }
`BIDI$r
◎
The character is of bidirectional character type L, AL, or R. [BIDI]
</li>
					<li>
<p>
%T の先祖であって, %要素 の子孫でもある，どの要素も：
◎
The character is not in a Text node that has an ancestor element that is a descendant of the element whose directionality is being determined and that is either:
</p>

						<ul>
							<li>
［
`bdi$e ／ `script$e ／ `style$e ／ `textarea$e
］要素でない, かつ
◎
• A bdi element.
• A script element.
• A style element.
• A textarea element.
</li>
							<li>
その `dir$a 属性の状態 ~EQ ε
◎
An element with a dir attribute in a defined state.
</li>
						</ul>
					</li>
				</ul>
			</li>
			<li>
~IF［
そのような %文字 はある
］
⇒
~RET %文字 の`双方向-字種$ に応じて
⇒
`AL^uc, `R^uc ならば `~rtl$ ／
`L^uc ならば `~ltr$
◎
If such a character is found and it is of bidirectional character type AL or R, the directionality of the element is 'rtl'.

◎
If such a character is found and it is of bidirectional character type L, the directionality of the element is 'ltr'.
</li>
			<li>
~IF［
%要素 は`文書~要素$である
］
⇒
~RET `~ltr$
◎
Otherwise, if the element is a document element, the directionality of the element is 'ltr'.
</li>
			<li>
~RET %要素 の親~要素の`方向性$
◎
Otherwise, the directionality of the element is the same as the element's parent element's directionality.
</li>
		</ol>
	</li>
	<li>
~ELSE（ ［
%状態 ~EQ ε
］~AND［
%要素 の親は要素である
］）
⇒
~RET %要素 の親の`方向性$
◎
If the element has a parent element and the dir attribute is not in a defined state (i.e. it is not present or has an invalid value)
• The directionality of the element is the same as the element's parent element's directionality.
</li>
</ol>
</div>

<p class="note">注記：
`dir$a 属性は`~HTML要素$用に限り定義されているので、
他の名前空間に属する要素は，それを有することはなく、
自身の`方向性$を親~要素から継承するか, 親がなければ既定の`~ltr$になる。
◎
Since the dir attribute is only defined for HTML elements, it cannot be present on elements from other namespaces. Thus, elements from other namespaces always just inherit their directionality from their parent element, or, if they don't have one, default to 'ltr'.
</p>

<p class="note">注記：
この属性には、
`双方向-~algoを孕むような具現化~要件が課される＠#bidireq$。
◎
This attribute has rendering requirements involving the bidirectional algorithm.
</p>

<hr>

<div class="algo">
<p>
`~HTML要素$ %要素 の
`属性の方向性@
は、
その属性 %属性 の~textが ある方式で具現化されるときに利用され，
次の手続きにより決定される：
◎
The directionality of an attribute of an HTML element, which is used when the text of that attribute is to be included in the rendering in some manner, is determined as per the first appropriate set of steps from the following list:
</p>

<ol>
	<li>
<p>
~IF［
%属性 は`方向性有りな属性$である
］~AND［
%要素 の `dir$a 属性の状態 ~EQ `自動$st
］：
◎
If the attribute is a directionality-capable attribute and the element's dir attribute is in the auto state
</p>
		<ol>
			<li>
~IF［
%属性 の値~内に，［
`双方向-字種$ ~IN { `L^uc, `AL^uc, `R^uc }
］なる文字がある
］］
⇒
~IF［［
そのような文字のうち，（論理-順序で）最初の文字
］の`双方向-字種$ ~NEQ `L^uc
］
⇒
~RET `~rtl$
`BIDI$r
◎
Find the first character (in logical order) of the attribute's value that is of bidirectional character type L, AL, or R. [BIDI]
◎
If such a character is found and it is of bidirectional character type AL or R, the directionality of the attribute is 'rtl'.
</li>
			<li>
~RET `~ltr$
◎
Otherwise, the directionality of the attribute is 'ltr'.
</li>
		</ol>
	</li>
	<li>
~RET %要素 の`方向性$
◎
Otherwise
◎
The directionality of the attribute is the same as the element's directionality.
</li>
</ol>
</div>

<div class="p">
<p>
次の表の左列に挙げる要素の，同じ行の 2 列目に挙げる属性は、
`方向性有りな属性@
とされる：
</p>

<table>
<thead><tr><th>要素
<th>内容~属性
</thead>

<tbody>
<tr><td>`th$e
<td>`th.abbr$a

<tr><td>`area$e
<td>`area.alt$a

<tr><td>`img$e
<td>`img.alt$a

<tr><td>`input$e
<td>`input.alt$a

<tr><td>`meta$e
<td>`meta.content$a†

<tr><td>`optgroup$e
<td>`optgroup.label$a

<tr><td>`option$e
<td>`option.label$a

<tr><td>`track$e
<td>`track.label$a

<tr><td>`input$e
<td>`input.placeholder$a

<tr><td>`textarea$e
<td>`textarea.placeholder$a

<tr><td>すべての`~HTML要素$
<td>`title$a

</tbody></table>

<p>†
要素の `meta.name$a 属性が~metadata名を指定していて，その値は 機械からではなくヒトから読まれる用途が首に意図されている場合に限る。
</p>

◎
The following attributes are directionality-capable attributes:
• abbr on th elements
• alt on area, img, and input elements
• content on meta elements, if the name attribute specifies a metadata name whose value is primarily intended to be human-readable rather than machine-readable
• label on optgroup, option, and track elements
• placeholder on input and textarea elements
• title on all HTML elements 
</div>

<hr>

<dl class="domintro">
	<dt>%document.`dir$m [ = %value ]</dt>
	<dd>
`~html要素$があって，その `dir$a 属性を有するならば、
その値を返す。
◎
Returns the html element's dir attribute's value, if any.
</dd>
	<dd>
設定して，`~html要素$ の `dir$a 属性の値を［
`ltr^l, `rtl^l, `auto^l
］のいずれかに置換できる。
◎
Can be set, to either "ltr", "rtl", or "auto" to replace the html element's dir attribute's value.
</dd>
	<dd>
`~html要素$がなければ，
空~文字列を返す ／
所与の %value は無視される。
◎
If there is no html element, returns the empty string and ignores new values.
</dd>
</dl>

<p>
要素の
`dir@mE
~IDL属性は、
`既知な値のみに制限される$下で，
コレの `dir$a 内容~属性を`反映する$モノトスル。
◎
The dir IDL attribute on an element must reflect the dir content attribute of that element, limited to only known values.
</p>

<p>
`文書$の
`dir@m
~IDL属性は：
</p>
<ul class="switch">
	<li>
コレの`~html要素$ %html ~NEQ ~NULL ならば
⇒
`既知な値のみに制限される$下で，
%html の `dir$a 内容~属性を`反映する$モノトスル。
◎
The dir IDL attribute on Document objects must reflect the dir content attribute of the html element, if any, limited to only known values.＼
</li>
	<li>
他の場合
⇒＃
取得子~手続きは、空~文字列を返す／
設定子~手続きは、何もしない
◎
If there is no such element, then the attribute must return the empty string and do nothing on setting.
</li>
</ul>

<p class="note">注記：
作者には、
~text方向を指示するときは，［
~CSSを利用するのではなく， `dir$a 属性を利用する
］ことが強く奨励される。
その仕方であれば、
~CSSが無い下でも（例： 探索~engineに解釈されるとき），
文書は正しく具現化し続けられるようになるので。
◎
Authors are strongly encouraged to use the dir attribute to indicate text direction rather than using CSS, since that way their documents will continue to render correctly even in the absence of CSS (e.g. as interpreted by search engines).
</p>

<div class="example">
<p>
この~markup片は、
Instant messaging による会話のものである：
◎
This markup fragment is of an IM conversation.
</p>

`dir-1^xCode

<p>
`p$e 要素~用に相応しい~stylesheet, および既定の整列~style
— すなわち，~textを段落の始端~辺に整列する —
が与えられた下では、
結果の具現化は次のようになろう：
◎
Given a suitable style sheet and the default alignment styles for the p element, namely to align the text to the start edge of the paragraph, the resulting rendering could be as follows:
</p>

<div>
<p class="alt" hidden id="_dgm-im">
各~段落は，別々な~blockとして具現化され、
2 番目と最後の段落は右寄せに，他は左寄せにされる。
各~段落の先頭の利用者名（この例では 'Student' , 'Teacher' ）は、
右寄せの段落では右端に接合され, その左に~colon, その左に~textが来る。
◎
Each paragraph rendered as a separate block, with the paragraphs left-aligned except the second paragraph and the last one, which would  be right aligned, with the usernames ('Student' and 'Teacher' in this example) flush right, with a colon to their left, and the text first to the left of that.
</p>
</div>

<p>
先に注記したように， `dir.auto$a 値は万能ではない。
この例における~~最後の段落は，~Arabic文字から始まるので、
右横書き~textに誤解釈され， "right?" を~Arabic~textの左側に置く。
◎
As noted earlier, the auto value is not a panacea. The final paragraph in this example is misinterpreted as being right-to-left text, since it begins with an Arabic character, which causes the "right?" to be to the left of the Arabic text.
</p>
</div>

				</section>
				<section id="the-style-attribute">
<h5 title="The style attribute">3.2.6.5. `style^a 属性</h5>

<p>
`style@a
内容~属性は、
どの`~HTML要素$に設定してもヨイ。
これは、
`CSSATTR$r に定義される，`~style属性$である。
◎
All HTML elements may have the style content attribute set. This is a style attribute as defined by CSS Style Attributes. [CSSATTR]
</p>

<p>
~CSSを~supportする~UAは：
</p>

<ul>
	<li>
`要素$ %要素 に この属性が追加された, あるいは その値が変更されたときには、
`~style属性$に課される規則に則って，属性の値を構文解析するモノトスル。
`CSSATTR$r
◎
In user agents that support CSS, the attribute's value must be parsed when the attribute is added or has its value changed, according to the rules given for style attributes. [CSSATTR]
</li>
	<li>
ただし，［
次を実行した結果 ~EQ `阻止される^i
］になる場合、
この属性の値により定義される~style規則は %要素 に適用しないモノトスル
`CSP$r
⇒
`要素における~inline型の挙動は~CSPにより阻止されるべきか？$( %要素, `style attribute^l, 属性の値 )
◎
However, if the Should element's inline behavior be blocked by Content Security Policy? algorithm returns "Blocked" when executed upon the attribute's element, "style attribute", and the attribute's value, then the style rules defined in the attribute's value must not be applied to the element. [CSP]
</li>
</ul>

<p>
要素に `style$a 属性を利用する文書は、
それらの属性が除去されても，依然として~~理解でき, 利用できなければナラナイ。
◎
Documents that use style attributes on any of their elements must still be comprehensible and usable if those attributes were removed.
</p>

<p class="note">注記：
特に， `style$a 属性を利用して内容を隠す／示す, あるいは［
さもなければ文書~内に含まれないような意味を伝達する
］ものは、
適合でない。
（内容を隠す／示すときは、
`hidden$a 属性を利用せよ。）
◎
In particular, using the style attribute to hide and show content, or to convey meaning that is otherwise not included in the document, is non-conforming. (To hide and show content, use the hidden attribute.)
</p>

<hr>

<dl class="domintro">
	<dt>%element.`style$m</dt>
	<dd>
要素の `style$a 属性~用の `CSSStyleDeclaration$I ~objを返す。
◎
Returns a CSSStyleDeclaration object for the element's style attribute.
</dd>
</dl>

<p>
`style$m ~IDL属性は、
`CSSOM$r にて定義される。
◎
The style IDL attribute is defined in CSS Object Model. [CSSOM]
</p>

<div class="example">
<p>
次の例では、
色を指す単語が［
視覚-媒体において関連な色で示されるようにする
］ため，［
`span$e 要素と `style$a 属性
］を利用して~mark-upされている：
◎
In the following example, the words that refer to colors are marked up using the span element and the style attribute to make those words show up in the relevant colors in visual media.
</p>

`style-1^xCode
</div>

				</section>
				<section id="embedding-custom-non-visible-data-with-the-data-*-attributes">

<h5 title="Embedding custom non-visible data with the data-* attributes">3.2.6.6. `data-*^a 属性による~customかつ可視でない~dataの埋込み</h5>

<div class="p">
<p>
`~custom~data属性@
は、
どの名前空間にも属さない属性であって，
その名前が次のいずれも満たすものである：
</p>
<ul>
	<li>
文字列
"`data-@a"
で開始される
</li>
	<li>
`data-^l の後に 1 個以上の文字がある
</li>
	<li>
`~XML互換$である
<li>
`~ASCII英大文字$を包含しない
</li>
</ul>

◎
A custom data attribute is an attribute in no namespace whose name starts with the string "data-", has at least one character after the hyphen, is XML-compatible, and contains no ASCII upper alphas.
</div>

<p class="note">注記：
`~HTML文書$においては、［
`~HTML要素$上のすべての属性~名は，自動的に~ASCII小文字~化される
］ので，~ASCII英大文字の制約は影響しない。
◎
All attribute names on HTML elements in HTML documents get ASCII-lowercased automatically, so the restriction on ASCII uppercase letters doesn't affect such documents.
</p>

<p>
`~custom~data属性$は、［
~page／~app
］に私的な［
~custom~data, 状態, 注釈, 等々
］のうち，適切な属性や要素が無いものを格納するために意図されている。
◎
Custom data attributes are intended to store custom data, state, annotations, and similar, private to the page or application, for which there are no more appropriate attributes or elements.
</p>

<p>
これらの属性は、［
それを利用する~siteの管理者には既知でない，~software
］用途に意図されるものではない。
複数の独立な~tool用の汎用な拡張のためには、［
この仕様が拡張されて，その種の特能が明示的に供されるようになる
］か，または［
`~microdata$の様な（標準~化された語彙を伴う）技術が利用されるべき
］である。
◎
These attributes are not intended for use by software that is not known to the administrators of the site that uses the attributes. For generic extensions that are to be used by multiple independent tools, either this specification should be extended to provide the feature explicitly, or a technology like microdata should be used (with a standardized vocabulary).
</p>

<div class="example">
<p>
一例として，音楽~siteは、
~album内の各~曲を表現する一連の~list~itemに，
曲の長さを包含する~custom~data属性で注釈することもできる。
~site自身は、［
この~listを曲の長さで~sortしたり, ある長さの曲に絞込む
］ことを利用者に許容する用途に，この情報を利用できる。
◎
For instance, a site about music could annotate list items representing tracks in an album with custom data attributes containing the length of each track. This information could then be used by the site itself to allow the user to sort the list by track length, or to filter the list for tracks of certain lengths.
</p>

`data-1^xCode

<p>
しかしながら，利用者が［
その音楽~siteに結付けられてない，汎用~software
］を利用して［
この~dataに基づいて，ある長さの曲を探索する
］ような用途は、
適切でなくなる。
◎
It would be inappropriate, however, for the user to use generic software not associated with that music site to search for tracks of a certain length by looking at this data.
</p>

<p>
これらの属性は、
公に利用-可能な~metadata用の汎用な拡張の仕組みではなく，
~siteの自前の~script用途に意図されているので。
◎
This is because these attributes are intended for use by the site's own scripts, and are not a generic extension mechanism for publicly-usable metadata.
</p>
</div>

<div class="example">
<p>
同様に，~page作者は、［
利用したいと意図する翻訳~tool用の情報
］を供する~markupを書くこともできる：
◎
Similarly, a page author could write markup that provides information for a translation tool that they are intending to use:
</p>

`data-2^xCode

<p>
この例における `data-mytrans-de^a 属性は、［
句 "claim" を~Germanに翻訳するときに利用する “MyTrans” 製品
］に特有な~textを与えている。
しかしながら，句 "HTML" については、
どの言語にも翻訳しないことを伝えるため，
標準な `translate$a 属性が利用されている。
標準な属性が可用なときは、
`~custom~data属性$を利用する必要はない。
◎
In this example, the "data-mytrans-de" attribute gives specific text for the MyTrans product to use when translating the phrase "claim" to German. However, the standard translate attribute is used to tell it that in all languages, "HTML" is to remain unchanged. When a standard attribute is available, there is no need for a custom data attribute to be used.
</p>
</div>

<div class="example">
<p>
次の例では、
~custom~data属性を利用して，
`PaymentRequest$I 特能を検出した結果を格納している。
それを利用して，検査後の~pageに異なる~CSS~styleをあてがうこともできる：
◎
In this example, custom data attributes are used to store the result of a feature detection for PaymentRequest, which could be used in CSS to style a checkout page differently.
</p>

`data-3^xCode

<p>
ここでの `data-has-payment-request^a 属性は，
— その有無を検査するだけで十分なので —
実質的に`真偽-属性$として利用されているが、
作者は，望むなら、
後で何らかの値で拡充して，例えば［
特能の機能性が制限されていることを指示する
］こともできる。
◎
Here, the data-has-payment-request attribute is effectively being used as a boolean attribute; it is enough to check the presence of the attribute. However, if the author so wishes, it could later be populated with some value, maybe to indicate limited functionality of the feature.
</p>
</div>

<p>
`~custom~data属性$は、
どの`~HTML要素$にも, いくつでも, どの値を指定してもヨイ。
◎
Every HTML element may have any number of custom data attributes specified, with any value.
</p>

<p>
作者は、
そのような拡張を注意深く設計するべきである
— 当の属性が無視され，~CSSも~~無効化されたときでも、
~pageは利用-可能になるよう。
◎
Authors should carefully design such extensions so that when the attributes are ignored and any associated CSS dropped, the page is still usable.
</p>

<p>
~UAは、
これらの属性や値から，どのような実装の挙動も導出しないモノトスル。
~UA用に意図される仕様は、
これらの属性がとる値にどのような意味も定義してはナラナイ。
◎
User agents must not derive any implementation behavior from these attributes or values. Specifications intended for user agents must not define these attributes to have any meaningful values.
</p>

<p>
~JS~libraryは、
それを利用している~pageの一部と見なされるので，
`~custom~data属性$を利用してもヨイ。
多くの作者から再利用される~libraryの作者には、［
属性~名に何らかの~~固有な文字列を含めることで，衝突の~riskを抑制する
］ことが奨励される。
~library作者には、
そうすることがイミを成すなら［
属性~名に利用される正確な名前を~custom化できるようにする
］ことも奨励される
— そうすれば、
~library作者が~pageに利用され得る名前を知らずに同じ名前を選ぼうが，~libraryを利用でき、
また，特定0の~libraryの複数の~versionどうしが互換でないときでも，同じ~pageに利用できるようになるので。
◎
JavaScript libraries may use the custom data attributes, as they are considered to be part of the page on which they are used. Authors of libraries that are reused by many authors are encouraged to include their name in the attribute names, to reduce the risk of clashes. Where it makes sense, library authors are also encouraged to make the exact name used in the attribute names customizable, so that libraries whose authors unknowingly picked the same name can be used on the same page, and so that multiple versions of a particular library can be used on the same page even when those versions are not mutually compatible.
</p>

<div class="example">
<p>
例えば、
"DoQuery" ~libraryが利用する属性~名は `data-doquery-range^a の様にする一方で，
"jJo" ~libraryは `data-jjo-range^a にすることが~~想定される。
~libraryは、
利用する接頭辞を設定する~APIを供することもできる
（例：
`jJo.setDataPrefix('j2')^c のように，
属性~名を `data-j2-range^a の様な名前にするものなど）。
◎
For example, a library called "DoQuery" could use attribute names like data-doquery-range, and a library called "jJo" could use attributes names like data-jjo-range. The jJo library could also provide an API to set which prefix to use (e.g. J.setDataPrefix('j2'), making the attributes have names like data-j2-range).
</p>
</div>

<hr>

<dl class="domintro">
	<dt>%element.`dataset$m</dt>
	<dd>
要素が有している一連の `data-*$a 属性~用の簡便な~accessorを `DOMStringMap$I ~objとして返す。
◎
Returns a DOMStringMap object for the element's data-* attributes.
</dd>
	<dd>
~hyphen化された属性~名は、
~camel-case化される。
例えば、
`data-foo-bar=""^a
は，
%element`.dataset.fooBar^c
になる。
◎
Hyphenated names become camel-cased. For example, data-foo-bar="" becomes element.dataset.fooBar.
</dd>
</dl>

<div class="algo">
`dataset@m
取得子~手続きは
⇒
~RET コレ上の `data-*$a 属性を公開するような，コレを結付けている `DOMStringMap$I ~obj
◎
The dataset IDL attribute provides convenient accessors for all the data-* attributes on an element. On getting, the dataset IDL attribute must return a DOMStringMap whose associated element is this element.
</div>

<p>
`DOMStringMap$I ~interfaceは、
`dataset$m 属性に利用される。
各 `DOMStringMap$I には、
ある
`要素@dsmap
が結付けられる。
◎
The DOMStringMap interface is used for the dataset attribute. Each DOMStringMap has an associated element.
</p>

<pre class="idl">
[Exposed=Window,
 `LegacyOverrideBuiltIns$]
interface `DOMStringMap@I {
  `getter$mDSM DOMString (DOMString %name);
  [`CEReactions$] `setter$mDSM undefined (DOMString %name, DOMString %value);
  [`CEReactions$] `deleter$mDSM undefined (DOMString %name);
};
</pre>

<div class="algo">
<p>
`名値~pair~listを取得する@
ときは、
所与の
( `DOMStringMap$I ~obj %O )
に対し，次を走らす：
◎
To get a DOMStringMap's name-value pairs, run the following algorithm:
</p>

<ol>
	<li>
%~list ~LET 空~list
◎
Let list be an empty list of name-value pairs.
</li>
	<li>
<p>
%O に結付けられている`要素$dsmapの`属性~list$を成す
~EACH( 内容~属性 %属性 )
に対し：
</p>
		<ol>
			<li>
%名前 ~LET %属性 の名前
</li>
			<li>
~IF［
%名前 の最初の 5 文字 ~NEQ `data-^l
］
⇒
~CONTINUE
</li>
			<li>
%名前 ~LET %名前 から最初の 5 文字を除去した結果
</li>
			<li>
~IF［
%名前 内に`~ASCII英大文字$がある
］
⇒
~CONTINUE
</li>
			<li>
%名前 ~SET %名前 の中の各［
`002D^U `-^smb, `~ASCII英小文字$ %C
］並びを次の結果に置換した結果
⇒
`~ASCII大文字~化する$( %C )
</li>
			<li>
名値~pair
( %名前, %属性 の値 )
を %~list に追加する
</li>
		</ol>

◎
For each content attribute on the DOMStringMap's associated element whose first five characters are the string "data-" and whose remaining characters (if any) do not include any ASCII upper alphas, in the order that those attributes are listed in the element's attribute list, add a name-value pair to list whose name is the attribute's name with the first five characters removed and whose value is the attribute's value.
◎
For each name in list, for each U+002D HYPHEN-MINUS character (-) in the name that is followed by an ASCII lower alpha, remove the U+002D HYPHEN-MINUS character (-) and replace the character that followed it by the same character converted to ASCII uppercase.
</li>
	<li>
~RET %~list
◎
Return list.
</li>
</ol>
</div>

<p>
所与の時点における［
`DOMStringMap$I ~obj %O が`~supportする~prop名$
］は、
その時点における［
`名値~pair~listを取得する$( %O ) の結果
］を成す各~pairの名前からなる同順の~listとする。
◎
The supported property names on a DOMStringMap object at any instant are the names of each pair returned from getting the DOMStringMap's name-value pairs at that instant, in the order returned.
</p>

<div class="algo">
<p>
`getter@mDSM
において`有名~propの値を決定する$ときは、
所与の
( コレが`~supportする~prop名$ %名前 )
に対し
⇒
~RET ［
`名値~pair~listを取得する$( コレ ) の結果
］を成す名値~pairのうち［
名前~成分 ~EQ %名前
］なるもの【該当するものは、一意に存在する】
］の値~成分
◎
To determine the value of a named property name for a DOMStringMap, return the value component of the name-value pair whose name component is name in the list returned from getting the DOMStringMap's name-value pairs.
</div>

<div class="algo">
<p>
`setter@mDSM
において［
`新たな有名~propの値を設定する$ ／
`既存の有名~propの値を設定する$
］ときは、
所与の
( %名前, %値 )
に対し，次を走らす：
◎
To set the value of a new named property or set the value of an existing named property for a DOMStringMap, given a property name name and a new value value, run the following steps:
</p>
<ol>
	<li>
~IF［
%名前 内に［
`002D^U `-^smb, `~ASCII英小文字$
］並びがある
］
⇒
~THROW `SyntaxError$E
◎
If name contains a U+002D HYPHEN-MINUS character (-) followed by an ASCII lower alpha, then throw a "SyntaxError" DOMException.
</li>
	<li>
%名前 ~SET %名前 内の各`~ASCII英大文字$ %C を次の並びに置換した結果
⇒＃
`002D^U `-^smb,
`~ASCII小文字~化する$( %C )
◎
For each ASCII upper alpha in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.
</li>
	<li>
%名前 ~SET %名前 の先頭に文字列 `data-^l を挿入した結果
◎
Insert the string data- at the front of name.
</li>
	<li>
~IF［
%名前 は［
~XML `Name$P 生成規則
］に合致しない
］
⇒
~THROW `InvalidCharacterError$E
◎
If name does not match the XML Name production, throw an "InvalidCharacterError" DOMException.
</li>
	<li>
コレに結付けられている`要素$dsmapの`属性~値を設定する$( %名前, %値 )
◎
Set an attribute value for the DOMStringMap's associated element using name and value.
</li>
</ol>
</div>

<div class="algo">
<p>
`deleter@mDSM
において`既存の有名~propを削除する$ときは、
所与の
( %名前 )
に対し，次を走らす：
◎
To delete an existing named property name for a DOMStringMap, run the following steps:
</p>
<ol>
	<li>
%名前 ~SET %名前 内の各`~ASCII英大文字$ %C を次の並びに置換した結果
⇒＃
`002D^U `-^smb,
`~ASCII小文字~化する$( %C )
◎
For each ASCII upper alpha in name, insert a U+002D HYPHEN-MINUS character (-) before the character and replace the character with the same character converted to ASCII lowercase.
</li>
	<li>
%名前 ~SET %名前 の先頭に文字列 `data-^l を挿入した結果
◎
Insert the string data- at the front of name.
</li>
	<li>
`属性を除去する$( コレに結付けられている`要素$dsmapの名前【！局所名？】 %名前 の属性 )
◎
Remove an attribute by name given name and the DOMStringMap's associated element.
</li>
</ol>

<p class="note">注記：
この~algoは、［
先掲の，`名値~pair~listを取得する$~algoから得られる名前
］に対してのみ，
`WEBIDL$r から呼出される。
◎
This algorithm will only get invoked by Web IDL for names that are given by the earlier algorithm for getting the DOMStringMap's name-value pairs. [WEBIDL]
</p>
</div>

<div class="example">
<p>
~gameの一部として， `data-*$a 属性とともに `class$a 属性も利用する~web~pageの例：
◎
If a web page wanted an element to represent a space ship, e.g. as part of a game, it would have to use the class attribute along with data-* attributes:
</p>

`data-spaceship^xCode

<p>
~hyphen化された属性~名は，~APIにおいては~camel-case化されることに注意。
◎
Notice how the hyphenated attribute name becomes camel-cased in the API.
</p>
</div>

<div class="example">
<p>
上と似たような，次の~code片と要素が与えられたとする…：
◎
Given the following fragment and elements with similar constructions:
</p>

`data-tower^xCode

<p>
上の要素を処理する関数の例（ `splashDamage()^c ）：
◎
...one could imagine a function splashDamage() that takes some arguments, the first of which is the element to process:
</p>

<pre class="lang-js">
function splashDamage(%node, %x, %y, %damage) {

  if (
      %node.classList.contains('tower') &amp;&amp; /* <span class="comment">
`class^a 属性を検査する
</span> */
      %node.dataset.x == %x &amp;&amp; /* <span class="comment">
`data-x^a 属性を読取る
</span> */
      %node.dataset.y == %y /* <span class="comment">
`data-y^a 属性を読取る
</span> */
  ) { 
    var %hp = parseInt(%node.dataset.hp); /* <span class="comment">
`data-hp^a 属性を読取る
</span> */
    %hp = %hp - %damage;
    if (%hp &lt; 0) {
      %hp = 0;
      %node.dataset.ai = 'dead'; /* <span class="comment">
`data-ai^a 属性を設定する
</span> */
      delete %node.dataset.ability; /* <span class="comment">
`data-ability^a 属性を除去する
</span> */
    }
    %node.dataset.hp = %hp; /* <span class="comment">
`data-hp^a 属性を設定する
</span> */
  }
}</pre>
</div>

<!-- 
// checking the 'class' attribute
      node.dataset.x == x && // reading the 'data-x' attribute
      node.dataset.y == y) { // reading the 'data-y' attribute
    var hp = parseInt(node.dataset.hp); // reading the 'data-hp' attribute
    hp = hp - damage;
    if (hp < 0) {
      hp = 0;
      node.dataset.ai = 'dead'; // setting the 'data-ai' attribute
      delete node.dataset.ability; // removing the 'data-ability' attribute
    }
    node.dataset.hp = hp; // setting the 'data-hp' attribute
-->

				</section>
			</section>
			<section id="the-innertext-idl-attribute">
<h4 title="The innerText and outerText properties">3.2.7. `innerText^m, `outerText^m ~prop</h4>

<dl class="domintro">
	<dt>%element.`innerText$m [ = %value ]</dt>
	<dd>
要素の~text内容を “具現化されたままの~~形で” 返す。
◎
Returns the element's text content "as rendered".
</dd>
	<dd>
設定して，要素の内容を所与の値に置換できる。
ただし、
改行は `br$e 要素に変換される。
◎
Can be set, to replace the element's children with the given value, but with line breaks converted to br elements.
</dd>

	<dt>%element.`outerText$m [ = %value ]</dt>
	<dd>
要素の~text内容を “具現化されたままの~~形で” 返す。
◎
Returns the element's text content "as rendered".
</dd>
	<dd>
設定して，要素~自体を所与の値に置換できる。
ただし、
改行は `br$e 要素に変換される。
◎
Can be set, to replace the element with the given value, but with line breaks converted to br elements.
</dd>
</dl>

<p>
【可読性のため、この節では次の表記を用いる：】
</p>
<ul>
	<li>
`CR^i は、
符号位置 `000D^U `CARRIAGE RETURN^cn を表す。
</li>
	<li>
`LF^i は、
符号位置 `000A^U `LINE FEED^cn を表す。
</li>
	<li>
`TAB^i は、
符号位置 `0009^U `CHARACTER TABULATION^cn を表す。
</li>
</ul>

<div class="algo">
<p>
`innerText@m
／
`outerText@m
取得子~手続きは：
◎
The innerText and outerText getter steps are:
</p>
<ol>
	<li>
<p>
~IF［
コレは`具現化されて$いない
］~OR［
~UAは非~CSS~UAである
］
⇒
~RET コレの`子孫~text内容$
◎
If this is not being rendered or if the user agent is a non-CSS user agent, then return this's descendant text content.
</p>

<p class="note">注記：
この手続きは、
意外な結果を生産し得る。
`innerText$m 取得子が
`具現化されて$いない要素に対し呼出された場合，要素の~text内容が返される一方、
`具現化されて$いる要素に対し呼出された場合，［
要素の子たちのうち`具現化されて$いないもの
］の~text内容は無視される。
◎
This step can produce surprising results, as when the innerText getter is invoked on an element not being rendered, its text contents are returned, but when accessed on an element that is being rendered, all of its children that are not being rendered have their text contents ignored.
</p>
	</li>
	<li>
%~item~list ~LET 空`~list$
◎
Let results be a new empty list.
</li>
	<li>
<p>
コレの
~EACH( 子~node %~node )
に対し
⇒
`具現化された~textを収集する$( %~node )
の結果を成す
~EACH( %~item )
に対し
⇒
%~item~list に %~item を`付加する$
</p>

<p class="note">注記：
%~item~list を成す各~itemは、
`文字列$, または（ `要改行数^i を与える）正な整数になる。
`要改行数^i ~itemは、
直感的には，その地点に現れる［
~itemの値で与えられる個数の改行からなる文字列
］を意味するが、
隣接する `要改行数^i ~itemどうしは縮約し得る
— ~CSSの~margin相殺にある意味似たように。
</p>

◎
For each child node node of this:
• Let current be the list resulting in running the rendered text collection steps with node. Each item in results will either be a string or a positive integer (a required line break count).
◎
Intuitively, a required line break count item means that a certain number of line breaks appear at that point, but they can be collapsed with the line breaks induced by adjacent required line break count items, reminiscent to CSS margin-collapsing.
◎
• For each item item in current, append item to results.
</li>
	<li>
%~item~list から［
空~文字列である文字列~item
］を`除去する$
◎
Remove any items from results that are the empty string.
</li>
	<li>
%~item~list から，頭部と尾部にある［
連続する `要改行数^i ~itemたち
］を`除去する$
◎
Remove any runs of consecutive required line break count items at the start or end of results.
</li>
	<li>
%~item~list を成す各［
連続する `要改行数^i ~itemたち
］を［
それらの~itemの最大~値と同じ個数の `LF^i からなる文字列
］に`置換する$
◎
Replace each remaining run of consecutive required line break count items with a string consisting of as many U+000A LF code points as the maximum of the values in the required line break count items.
</li>
	<li>
~RET %~item~list を成す文字列~itemたちを順に連結した結果
◎
Return the concatenation of the string items in results.
</li>
</ol>
</div>

<div class="algo">
<p>
`具現化された~textを収集する@
ときは、
所与の
( `~node$ %~node )
に対し，次を走らす：
◎
The rendered text collection steps, given a node node, are as follows:
</p>
<ol>
	<li>
%~item~list ~LET 空`~list$
◎
↓</li>
	<li>
<p>
%~node の
~EACH( 子~node %子 )
に対し，`~tree順序$で：
</p>
		<ol>
			<li>
%子~item~list ~LET `具現化された~textを収集する$( %子 )
</li>
			<li>
%子~item~list を成す
~EACH( %子~item )
に対し
⇒
%~item~list に %子~item を`付加する$
</li>
		</ol>
◎
Let items be the result of running the rendered text collection steps with each child node of node in tree order, and then concatenating the results to a single list.
</li>
	<li>
~IF［
%~node の `visibility$p の`算出d値$ ~NEQ `visible^v
］
⇒
~RET %~item~list
◎
If node's computed value of 'visibility' is not 'visible', then return items.
</li>
	<li>
<p>
~IF［
%~node は`具現化されて$いない
］
⇒
~RET %~item~list
◎
If node is not being rendered, then return items.＼
</p>

<p>
この段の目的においては、
次に挙げる要素は，［
その `display$p ~propの`算出d値$ ~NEQ `none^v
］ならば、
そこに述べるように動作するものと扱うモノトスル：
◎
For the purpose of this step, the following elements must act as described if the computed value of the 'display' property is not 'none':
</p>
		<ul>
			<li>
`select$e 要素
⇒
`置換され$ない`行内~level$の【！行内】`~CSS~box$が結付けられていて、
子である各［
`optgroup$e ／ `option$e
］要素による~boxのみを子~boxとして含んでいる。
◎
select elements have an associated non-replaced inline CSS box whose child boxes include only those of optgroup and option element child nodes;
</li>
			<li>
`optgroup$e 要素
⇒
`置換され$ない`塊~level$の`~CSS~box$が結付けられていて、
子である各 `option$e 要素による~boxのみを子~boxとして含んでいる。
◎
optgroup elements have an associated non-replaced block-level CSS box whose child boxes include only those of option element child nodes; and
</li>
			<li>
`option$e 要素
⇒
`置換され$ない`塊~level$の`~CSS~box$が結付けられていて、
その子~boxは，通常通り`置換され$ない`塊~level$の`~CSS~box$である。
◎
option element have an associated non-replaced block-level CSS box whose child boxes are as normal for non-replaced block-level CSS boxes.
</li>
		</ul>

<p class="note">注記：
`display^p 値が `contents$v の場合、
%~item~list は非~空になり得る。
◎
items can be non-empty due to 'display:contents'.
</p>
	</li>
	<li>
<p>
~IF［
%~node は `Text$I ~nodeである（したがって， %~item~list は空である）
］：
◎
If node is a Text node, then＼
</p>
		<ol>
			<li>
<p>
%~node が生産した
~EACH( ~CSS~text~box )
に対し，内容~順に：
◎
for each CSS text box produced by node, in content order,＼
</p>
				<ol>
					<li>
<p>
%文字列~item ~LET［
~CSS［
`空白~処理$, `~text変形$
【！white-space, text-transform】
］の規則 `CSSTEXT$r
を，~boxの~textに適用して算出される文字列
— ここでは：
◎
compute the text of the box after application of the CSS 'white-space' processing rules and 'text-transform' rules, set items to the list of the resulting strings, and return items.＼
</p>

						<ul>
							<li>
`空白~処理$の規則は、
少しばかり改変される：
行末の縮約-可能な空白~並びは常に縮約されるが、
それらは［
その行lが当の~blockの最後の行lであるか, または
`br$e 要素で終端している
］場合に限り除去されるように。
◎
The CSS 'white-space' processing rules are slightly modified: collapsible spaces at the end of lines are always collapsed, but they are only removed if the line is the last line of the block, or it ends with a br element.＼
</li>
							<li>
~soft~hyphenは保全されるべきである
◎
Soft hyphens should be preserved. [CSSTEXT]
</li>
						</ul>
					</li>
					<li>
%~item~list に %文字列~item を`付加する$
◎
↑</li>
				</ol>
			</li>
			<li>
~RET %~item~list
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%~node は `br$e 要素である
］
⇒
%~item~list に［
1 個の `LF^i からなる文字列
］を`付加する$
◎
If node is a br element, then append a string containing a single U+000A LF code point to items.
</li>
	<li>
~IF［
%~node の `display$p の`算出d値$ ~EQ `table-cell$v
］~AND［
%~node の`~CSS~box$は、
それを封入している `table-row$v ~boxの最後の `table-cell$v ~boxではない
］
⇒
%~item~list に［
1 個の `TAB^i からなる文字列
］を`付加する$
◎
If node's computed value of 'display' is 'table-cell', and node's CSS box is not the last 'table-cell' box of its enclosing 'table-row' box, then append a string containing a single U+0009 TAB code point to items.
</li>
	<li>
~IF［
%~node の `display$p の`算出d値$ ~EQ `table-row$v
］~AND［
%~node の`~CSS~box$は［
%~node に最も近い［
%~node の先祖 `table$v ~box
］］の最後の `table-row$v ~boxではない
］
⇒
%~item~list に［
1 個の `LF^i からなる文字列
］を`付加する$
◎
If node's computed value of 'display' is 'table-row', and node's CSS box is not the last 'table-row' box of the nearest ancestor 'table' box, then append a string containing a single U+000A LF code point to items.
</li>
	<li>
%要改行数 ~LET ε
◎
↓</li>
	<li>
~IF［
%~node は `p$e 要素である
］
⇒
%要改行数 ~SET 2
◎
If node is a p element, then append 2 (a required line break count) at the beginning and end of items.
</li>
	<li>
<p>
~ELIF［
%~node の `display$p の`使用~値$は［
`塊~level$である【`外縁~表示~型$は `block$v】, または `table-caption$v
］ `CSSDISPLAY$r
］
⇒
%要改行数 ~SET 1
◎
If node's used value of 'display' is block-level or 'table-caption', then append 1 (a required line break count) at the beginning and end of items. [CSSDISPLAY]
</p>
<p class="note">注記：
`浮動体$, `絶対的に位置され$た要素は、
この分類に入る。
【`塊~化$される。】
◎
Floats and absolutely-positioned elements fall into this category.
</p>
	</li>
	<li>
<p>
~IF［
%要改行数 ~NEQ ε
］：
</p>
<ol ><li>%~item~list に %要改行数 を`前付加する$
</li><li>%~item~list に %要改行数 を`付加する$
</li></ol>
◎
↑</li>
	<li>
~RET %~item~list
◎
Return items.
</li>
</ol>
</div>

<p class="note">注記：
厳密に言えば、
ほとんどの`置換され$る要素
（例： `textarea$e, `input$e, `video$e
— ただし `button$e は除く）
の子孫~nodeは、
~CSSにより具現化されることはなく，
この~algoの目的においては`~CSS~box$を持たないことに注意。
◎
Note that descendant nodes of most replaced elements (e.g., textarea, input, and video — but not button) are not rendered by CSS, strictly speaking, and therefore have no CSS boxes for the purposes of this algorithm.
</p>

<p class="XXX">
この~algoを，`範囲~obj$上でも働くように一般~化する。
そうすれば、
`Selection$I の文字列化子の基礎に利用でき，
`範囲~obj$上に直に公開し得るようになる。
`Bugzilla bug 10583＠https://www.w3.org/Bugs/Public/show_bug.cgi?id=10583$
を見よ。
◎
This algorithm is amenable to being generalized to work on ranges. Then we can use it as the basis for Selection's stringifier and maybe expose it directly on ranges. See Bugzilla bug 10583.
</p>

<hr>

<div class="algo">
<p>
`innerText$m 設定子~手続きは：
◎
The innerText setter steps are:
</p>
<ol>
	<li>
%素片 ~LET `具現化される~text素片$( 所与の値, コレの`~node文書$ )
◎
Let fragment be the rendered text fragment for the given value given this's node document.
</li>
	<li>
コレの`全~内容を~nodeで置換する$( %素片 )
◎
Replace all with fragment within this.
</li>
</ol>
</div>

<div class="algo">
<p>
`outerText$m 設定子~手続きは：
◎
The outerText setter steps are:
</p>
<ol>
	<li>
~IF［
コレの親 ~EQ ~NULL
］
⇒
~THROW `NoModificationAllowedError$E
◎
If this's parent is null, then throw a "NoModificationAllowedError" DOMException.
</li>
	<li>
%次の同胞 ~LET コレの`次の同胞？$
◎
Let next be this's next sibling.
</li>
	<li>
%前の同胞 ~LET コレの`前の同胞？$
◎
Let previous be this's previous sibling.
</li>
	<li>
%素片 ~LET `具現化される~text素片$( 所与の値, コレの`~node文書$ )
◎
Let fragment be the rendered text fragment for the given value given this's node document.
</li>
	<li>
~IF［
%素片 の`子~群$は空である
］
⇒
%素片 に`~nodeを付加する$( 次のように設定された新たな `Text$I ~node )
⇒＃
`~data$cd ~SET 空~文字列,
`~node文書$ ~SET コレの`~node文書$
◎
If fragment has no children, then append a new Text node whose data is the empty string and node document is this's node document to fragment.
</li>
	<li>
コレの親の中で`子を~nodeに置換する$( コレ, %素片 )
◎
Replace this with fragment within this's parent.
</li>
	<li>
~IF［
%次の同胞  ~NEQ ~NULL
］~AND［
%次の同胞 の`前の同胞？$は `Text$I ~nodeである
］
⇒
`次の~text~nodeと併合する$( %次の同胞 の`前の同胞？$ )
◎
If next is non-null and next's previous sibling is a Text node, then merge with the next text node given next's previous sibling.
</li>
	<li>
~IF［
%前の同胞 は `Text$I ~nodeである
］
⇒
`次の~text~nodeと併合する$( %前の同胞 )
◎
If previous is a Text node, then merge with the next text node given previous.
</li>
</ol>
</div>

<div class="algo">
<p>
`具現化される~text素片@
は、
所与の
( 文字列 %入力, `文書$ %文書 )
に対し，次の手続きを走らせた結果を返す：
◎
The rendered text fragment for a string input given a Document document is the result of running the following steps:
</p>
<ol>
	<li>
%素片 ~LET 次のように設定された新たな`文書片$
⇒
`~node文書$ ~SET %文書
◎
Let fragment be a new DocumentFragment whose node document is document.
</li>
	<li>
%位置 ~LET %入力 の先頭の文字を指している`位置~変数$
◎
Let position be a position variable for input, initially pointing at the start of input.
◎
↓Let text be the empty string.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NEQ ε
］：
◎
While position is not past the end of input:
</p>
		<ol>
			<li>
%~text ~LET
%入力 内の %位置 から
{ `LF^i, `CR^i }
以外の`符号位置~並びを収集する$
◎
Collect a sequence of code points that are not U+000A LF or U+000D CR from input given position, and set text to the result.
</li>
			<li>
~IF［
%~text ~NEQ 空~文字列
］
⇒
%素片 に`~nodeを付加する$( 次のように設定された新たな `Text$I ~node )
⇒＃
`~data$cd ~SET %~text,
`~node文書$ ~SET %文書
◎
If text is not the empty string, then append a new Text node whose data is text and node document is document to fragment.
</li>
			<li>
<p>
~WHILE［
%位置↗ ~IN { `LF^i, `CR^i }
］：
◎
While position is not past the end of input, and the code point at position is either U+000A LF or U+000D CR:
</p>
				<ol>
					<li>
~IF［
%位置↗ ~EQ `CR^i
］~AND［
( %位置 ~PLUS 1 )↗ ~EQ `LF^i
］
⇒
%位置 ~INCBY 1
◎
If the code point at position is U+000D CR and the next code point is U+000A LF, then advance position to the next code point in input.
</li>
					<li>
%位置 ~INCBY 1
◎
Advance position to the next code point in input.
</li>
					<li>
%要素 ~LET `要素を作成する$( %文書, `br$e, `~HTML名前空間$ )
◎
↓</li>
					<li>
%素片 に`~nodeを付加する$( %要素 )
◎
Append the result of creating an element given document, br, and the HTML namespace to fragment.
</li>
				</ol>
			</li>
		</ol>
   </li>
	<li>
~RET %素片
◎
Return fragment.
</li>
</ol>
</div>

<div class="algo">
<p>
`次の~text~nodeと併合する@
ときは、
所与の
( `Text$I ~node %~node )
に対し：
◎
To merge with the next text node given a Text node node:
</p>
<ol>
	<li>
%次の同胞 ~LET %~node の`次の同胞？$
◎
Let next be node's next sibling.
</li>
	<li>
~IF［
%次の同胞 は `Text$I ~nodeでない
］
⇒
~RET
◎
If next is not a Text node, then return.
</li>
	<li>
%~node の`~dataを置換する$( %~node の`~data$cdの`長さ$str, 0, %次の同胞 の`~data$cd )
◎
Replace data with node, node's data's length, 0, and next's data.
</li>
	<li>
<p>
~IF［
%次の同胞 の親 ~NEQ ~NULL
］
⇒
`~nodeを除去する$( %次の同胞 )
◎
If next's parent is non-null, then remove next.
</p>

<p class="note">注記：
親の検査は必要とされる
— 前-段は、
変異~eventを誘発したかもしれないので。
◎
The parent check is necessary as the previous step might have triggered mutation events.
</p>
	</li>
</ol>
</div>

			</section>
			<section id="requirements-relating-to-the-bidirectional-algorithm">
<h4 title="Requirements relating to the bidirectional algorithm">3.2.8. 双方向-~algoに関係する要件</h4>

				<section id="authoring-conformance-criteria-for-bidirectional-algorithm-formatting-characters">
<h5 title="Authoring conformance criteria for bidirectional-algorithm formatting characters">3.2.8.1. 双方向-~algo整形~文字~用の著作~適合性の判定基準</h5>

<p>
`~HTML要素$における，［
`~text内容$
— `Text$I ~nodeを含むような`内容$
］／［
自由形の~textを許容するような属性~内の~text
］は、
範囲
{ `202A^U 〜 `202E^U, `2066^U 〜 `2069^U }
に入る文字（双方向-~algo整形~文字）を包含してもヨイ。
`BIDI$r
◎
Text content in HTML elements with Text nodes in their contents, and text in attributes of HTML elements that allow free-form text, may contain characters in the ranges U+202A to U+202E and U+2066 to U+2069 (the bidirectional-algorithm formatting characters). [BIDI]
</p>

<p class="note">注記：
作者には、［
`dir$a 属性,
`bdo$e 要素,
`bdi$e 要素
］を利用することが奨励される
— 双方向-~algo整形~文字を手動で保守するのでなく。
双方向-~algo整形~文字は、
~CSSとの相互作用に乏しい。
◎
Authors are encouraged to use the dir attribute, the bdo element, and the bdi element, rather than maintaining the bidirectional-algorithm formatting characters manually. The bidirectional-algorithm formatting characters interact poorly with CSS.
</p>

				</section>
				<section id="user-agent-conformance-criteria">
<h5 title="User agent conformance criteria">3.2.8.2. ~UAに課される適合性~判定基準</h5>

<p>
~UAは、［
文書や その一部を具現化する際に，文字たちの適正な順序付けを決定するとき
］には、
~Unicode双方向-~algo `BIDI$r を実装するモノトスル。
◎
User agents must implement the Unicode bidirectional algorithm to determine the proper ordering of characters when rendering documents and parts of documents. [BIDI]
</p>

<p>
~UAは、
~HTMLから~Unicode双方向-~algoへの対応付けを，
次のいずれかの仕方で行うモノトスル
`CSSGC$r：
◎
The mapping of HTML to the Unicode bidirectional algorithm must be done in one of three ways. Either the user agent must＼
</p>

<ul>
	<li>
~CSS
— 特に，~CSS［
`unicode-bidi$p, `direction$p, `content$p
］~propを実装した上で、［
`§ 具現化＠~HTMLrendering#rendering$に与えられる，これらの~propを利用している規則
］を，自身の~UA~stylesheetに含める。
◎
implement CSS, including in particular the CSS 'unicode-bidi', 'direction', and 'content' properties, and must have, in its user agent style sheet, the rules using those properties given in this specification's rendering section, or,＼
</li>
	<li>
前項であったかのように動作しつつ、
文書に指定される~stylesheetには，それを上書きさせない。
◎
alternatively, the user agent must act as if it implemented just the aforementioned properties and had a user agent style sheet that included all the aforementioned rules, but without letting style sheets specified in documents override them, or,＼
</li>
	<li>
等価な意味論を伴うような別の~style付け言語を実装する。
◎
alternatively, the user agent must implement another styling language with equivalent semantics. [CSSGC]
</li>
</ul>

<p id="bidireq">
次に挙げる要素／属性には，
`§ 具現化＠~HTMLrendering#rendering$により定義される要件が課されるが、
この節における要件に因り，すべての~UAに課される要件にもなる
（`示唆される既定の具現化を~supportする~UA＠~HTMLINFRA#renderingUA$のみならず）：
◎
The following elements and attributes have requirements defined by the rendering section that, due to the requirements in this section, are requirements on all user agents (not just those that support the suggested default rendering):
</p>

<div >
<ul><li>`dir$a 属性, および
<li>`bdi$e, `bdo$e, `br$e, `pre$e, `textarea$e, `wbr$e 要素
</ul>

◎
• dir attribute
• bdi element
• bdo element
• br element
• pre element
• textarea element
• wbr element
</div>

				</section>
			</section>
			<section id="wai-aria">
<h4 title="Requirements related to ARIA and to platform accessibility APIs">3.2.9. ~ARIA, および~platform~accessibility~APIに関係する要件</h4>

<div class="algo">
<p>
`~HTML要素$に対し~accessibility~APIの意味論を実装するにあたって，~UAに課される要件は、
`HTMLAAM$r にて定義される。
それによる規則に加えて，`~custom要素$ %要素 用の既定の~ARIA~role意味論は、
次に従って決定される：
◎
User agent requirements for implementing Accessibility API semantics on HTML elements are defined in HTML Accessibility API Mappings. In addition to the rules there, for a custom element element, the default ARIA role semantics are determined as follows: [HTMLAAM]
</p>
<ol>
	<li>
%値 ~LET %要素 の`~native~accessibility意味論~map$[ `role^l ]
◎
Let map be element's native accessibility semantics map.
</li>
	<li>
~RET %値 に応じて
⇒＃
ε ならば `~roleなし^i ／
~ELSE_ %値
◎
If map["role"] exists, then return it.
◎
Return no role.
</li>
</ol>
</div>

<div class="algo">
<p>
類似に，`~custom要素$ %要素 に対しては，名前 %状態または~prop の［
状態／~prop
］用の既定の~ARIA［
状態／~prop
］意味論は、
次に従って決定される：
◎
Similarly, for a custom element element, the default ARIA state and property semantics, for a state or property named stateOrProperty, are determined as follows:
</p>
<ol>
	<li>
%値 ~LET %要素 の`~native~accessibility意味論~map$[ %状態または~prop ]
◎
Let map be element's native accessibility semantics map.
</li>
	<li>
~RET %値 に応じて
⇒＃
ε ならば %状態または~prop 用の既定の値 ／
~ELSE_ %値
◎
If map[stateOrProperty] exists, then return it.
◎
Return the default value for stateOrProperty.
</li>
</ol>
</div>

<p class="note">
ここで参照rされる “既定の意味論” は、
`ARIA$r においては［
“~native（ `native^en ）” ／
“暗黙的（ `implicit^en ）” ／
“~host言語（ `host language^en ）”
］意味論と称されることもある。
◎
The "default semantics" referred to here are sometimes also called "native", "implicit", or "host language" semantics in ARIA. [ARIA]
</p>

<p class="note">注記：
これらの定義は、
既定の意味論は，時間~越しに変化し得ることも含意する。
これは、
組込みの要素と同じ表出能を~custom要素にも許容する
— 例えば、
`a$e 要素の既定の~ARIA~role意味論が，その `href$a 属性が［
追加される／除去される
］に伴い どう変化するかと比較して。
◎
One implication of these definitions is that the default semantics can change over time. This allows custom elements the same expressivity as built-in elements; e.g., compare to how the default ARIA role semantics of an a element change as the href attribute is added or removed.
</p>

<p>
これの動作~例は、
`§ 既定の~access可能な~role, 状態, ~propを伴う~custom要素の作成-法＠~HEcustom#custom-elements-accessibility-example$
を見よ。
◎
For an example of this in action, see the custom elements section.
</p>

<hr>

<p>
`~HTML要素$上の~ARIA［
`role$a ／ `aria-*$a
］属性の利用を検査する適合性~検査器に課される要件は、
`ARIAHTML$r にて定義される。
◎
Conformance checker requirements for checking use of ARIA role and aria-* attributes on HTML elements are defined in ARIA in HTML. [ARIAHTML]
</p>

			</section>
		</section>
	</section>
</main>
