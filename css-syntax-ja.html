<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Syntax Module Level 3 （日本語訳）</title>
<meta name="keywords" content="CSS,仕様,構文,解析,文法,スタイルシート,W3C">

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script >
var source_data;

COMMON_DATA.page_state_key = '___CSS';
COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://drafts.csswg.org/css-syntax/',
		main: 'MAIN',
		spec_status: 'ED',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		unicode_map: Util.getMapping('_unicode_map'),
		levels: '英語主体:英語寄り:漢字主体:カナ主体',
		level: 2,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked 160131 spec

	return options;
}

function expand(mapping1){
	var link_map = this.link_map;
	var unicode_map = this.unicode_map;
	var class_map = {
		at: 'at-rule', // @規則
		p: 'property',
		f: 'family', // family 名
		r: 'ref', // 参照文献
		tok: 'token', // token
		t: 'type', // typedef
		T: 'token', // token
		u: 'unit', //
		sb: 'symbol', // 
		e: 'element',
		css: 'css',
		v: 'value',
		NOTE: 'trans-note'
	}
	var tag_map = {
		i: 'i',
		tok: 'var',
		t: 'var',
		T: 'var',
		V: 'var',
		at: 'code',
		p: 'code',
		sb: 'code',
		e: 'code',
		v: 'code',
		css: 'code',
		c: 'code',
		NOTE: 'span',
	}

	if(!source_data.diagrams){
		source_data.diagrams = Object.create(null);
		repeat('#_resources > *[id]', function(e){
			source_data.diagrams[e.id] = e;
		});
	}
	Util.removeParts(source_data.diagrams);

	var nesting = '';

	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒|◎[^`<◎]*|`(.{1,30}?)([$@\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	Util.rebuildToc('MAIN0', '_toc_list0');// 目次構築
	Util.replaceParts(source_data.diagrams);// 挿入

	function create_html(match, key, indicator, klass){
if(!indicator) {
	switch(match.charAt(0)){
	case '⇒':
		nesting += '<\/span>';
		return '：<span class="block">';
	}
	//◎
	var result = nesting + '<span lang="en">' + match.slice(1) + '<\/span>';
	nesting = '';
	return result;
}

var href = '', text = key;//, prefix = '#';

switch(klass){
case '': // plain
	break;
case 'i': // ^i リンク解除（一時的？）
	break;
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'tok': // typedef
	href = '#typedef-' + key.toLowerCase() + '-token';
	text = '&lt;' + key + '-token&gt;';
	break;
case 't': // typedef
	href = '#typedef-' + key;
	text = '&lt;' + key + '&gt;';
	break;
case 'T': // tokendef
	href = '#tokendef-' + key;
	text = '&lt;~' + key + '&gt;';
	break;
/*
<dfn id=tokendef-open-square>&lt;[-token&gt;</dfn>,
*/
case 'UU':
case 'U': // code point
	text = 'U+00' + key + ' <small class="cp">' + unicode_map[key] + '</small>';
	if(klass === 'UU'){
		text += ' (<code>&#x' + key + ';</code>)';
	}
	break;
case 'at': // at-rule
	text = '@' + key;
	break;
case 'p': // property
case 'f': // func
case 'v': // css values
case 'css': // css codes
	break;
case 'V': // variables in algo
	break;
case 'sb': // symbol in the railroad
	break;
case 'e': // element
	break;
case 'c': // code
	break;
case 'dgm': // place holder for railroad diagram
	return '<a id="_dgm-' + key + '"></a>';
	break;
case 'NOTE': // trans-note
	text = '【' + key + '】';
	break;
default:
	console.log(match);
	return match;
}

var classname = class_map[klass];
var tag = tag_map[klass];
if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
//		href = href_data_map[key] || href;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	default:
		console.log(match);
		return match;
	}
}

return text;

	}//create_html
}
</script>


<!--%置換語 -->
<script type="text/plain" id="words_table1">
FFFD:U+FFFD <small class="cp">REPLACEMENT CHARACTER</small> (&#xFFFD;)
nB:<sup><a href="#anb-plus" >†</a></sup>
anb:<var>&lt;an+b&gt;</var>
AnB:<span class="css"><var>A</var>n+<var>B</var></span>
An:<span class="css"><var>A</var>n</span>

open-square:[-token
close-square:]-token
open-paren:(-token
close-paren:)-token
open-curly:{-token
close-curly:}-token

failure: <b>failure</b> 
nothing: <b>nothing</b> 

AEQ:<a href="#ascii-case_insensitive" >＝<sub>大小無視</sub></a>
DAGGER:<sup>†</sup>
APPEND: <span class="op">&lt;&lt;</span> 
EOF: <b>EOF</b> 

ASCII: ASCII 
CSS: CSS 
ID: ID 
important: <code class="css">!important</code> 

BR:；<br>
</script>


<!--%語彙 -->

<script type="text/plain" id="words_table">

	●処理
byte:::バイト
stream:::ストリーム
	処理:process:~
		processing, 
	処理規則:processing rule:~
消費:consume::~
消費側:consumer::~
前方検索:seek forward::~
	検索:looks for:~
生産:produce::~
	形成
生産物:product::~
再消費:reconsume::~
回復-:recover:~
回復:recovery:~
emit:::出力
出力:output:~
入力:input:~
現入力:current input:現在の入力
現在の:current:~
	現在:currently
次入力:next input:次の入力
挿入-:insert:~
	inserting
再挿入-:reinsert:~
付加-:append:追加
	appending
追加-:add:~
追加の:additional:~
	加えて，:additionally
除去-:remove:~
	除去して:removing
	繰り返し:repeatedly
	返す:return
	返され:returned
	返して:returning
	戻る:returning
置換-:replace:~
置換え:substitute し:置き換え
中止-:abort:~
操作-:operate:~
演算:operation:~
parameter:::パラメタ
optional:::オプション
	オプションの:~optional
	任意選択／随意的／省略可
	optionally
model:::モデル
error:::エラー
pointer:::ポインタ

	:error handling
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
入口:entry point::エントリポイント
new:::新たな
合致:match::~
	合致している:matching
	対になっていない:unmatched
小構文:microsyntax::~
flag:::フラグ
変換-:convert:~
	converting
状態機械:state-machine:~::ステートマシン
	手続き:steps
	段／段階:~step
構文的:syntactical:~
構文形:syntactic form:~
構文:syntax:~
転換-:transform:~
	３つ組:3-tuple
検証-:verify:~
検証:verification:~

生成規則:production::~
引用符:quote::~
	引用符で括る:quote
	引用符で括られ:quoted
一重引用符:single quote::~
二重引用符:double quote::~

線路図式:railroad diagram:~
		構文解析図
文字列表現:representation::~
無制約:unrestricted:制約なし

妥当:valid::~
妥当性:validity::~

algo:algorithm::アルゴリズム
呼出:invoke:呼び出
呼出され:invoke:呼び出され
呼出して:invoke して:呼び出して
	invoked, invoking
呼ばれ:call され:~
呼ぶ:call する:~
呼べる:call できる:~
	呼び出し:calling
検査:check::~
検査器:checker::~
報告:report:~
符号化方式:encoding:~::エンコーディング
	取得:get:~
hint:::ヒント
環境:environment:~
label:::ラベル
fallback:::フォールバック

escape:::エスケープ
escape-seq:escape sequence:escape 列:エスケープ列:エスケープシーケンス
	エスケープを施す:escaping
escaping:::エスケープ法:エスケーピング

復号-:decode:~::デコード
復号処理:decoding:~::デコード処理
前処理:preprocessing:~

構文解析-:parse:~::パース
構文解析error:parse error:構文解析 error:構文解析エラー:パースエラー
構文解析器:parser:~::パーサ
構文解析規則:parsing rule:~::パース規則
構文解析処理:parsing:構文解析::パース処理
構文解析法:parsing:~::パース法

tokenization::token 化:トークン化
tokenize::token 化:トークン化::トークナイズ
tokenizing::token 化処理:トークン化処理
tokenizer::token 化器:トークン化器:トークナイザ

直列化:serialization:~::シリアル化
直列化-:serialize:~::シリアライズ
直列化器:serializer:~::シリアライザ
直列化法:serializing:~::シリアライズ処理

先読み:look-ahead:~

	●符号位置
符号位置:code point::~:コードポイント
符号空間:codespace::~:コードスペース
文字:character:~
数字:digit::~
	:ディジット
英字:letter::~:レター
負符号:minus sign:~
正符号:plus sign:~
正負符号:plus or minus sign:~
hex:hex digit::16 進数字
	decimal:10 進数
整数:integer::~
改行:newline::~
符号:sign:~
surrogate:::サロゲート
空白:whitespace::~
	white space::~
大文字:uppercase letter::~
小文字:lowercase letter::~
小文字化:lowercase 化:~
	convert 〜 lower-case
代替文字:replacement character:replacement 文字:~

コロン:colon::~
セミコロン:semicolon::~
カンマ:comma::~
ハイフン:hyphen::~
スペース:space::~
アンダースコア:underscore::~
バックスラッシュ:backslash::~

終端符号位置:ending code point::~
名前開始:name-start::~
印字不能:non-printable::~

	●token 他
token:::トークン
block:::ブロック
	括弧:brace
波括弧:curly:~
丸括弧:paren:~
角括弧:square:~
	閉じ丸括弧:right parenthesis
unicode-range:::unicode 範囲
不良:bad::~
url:
comment:::コメント
成分:component::~
成分値:component value:component 値:~
有修飾:qualified::~
	有資格?
関数:function::~
関数式:function::~
関数記法:functional notation:~
区切子:delimiter:~
区切りの:separated:~
	区切る:separate
実数:number::~
単純:simple::~
単純文:simple statement:単純な文
単純化-:simplify:~
	より単純な:simpler
単位:unit::~
識別子:identifier::~
	識別子に類する:ident-like
宣言-:declare::~
宣言:declaration::~
百分率:percentage::~
導入部:prelude::~
規則:rule::~
at-rule:::at-規則

鏡像:mirror variant:~
終端ing:ending::終端
	ending token

範囲:range:~
	始端:start:~
終端:end:~
始値:start value:~
終値:end value:~

	16 進数／16 進:hexadecimal number
	ident
	10 進:base-10:~
	基数
名前:name:~
名:name:~
文字列:string:~
空文字列:empty string:~
値:value:~
型:type:~
空:empty:~
list:::リスト

数値:numeric value:~
	数による:numeric
数的:numeric:~
	numeric token
残余:remnants:~
文字大小:case:~
文字大小区別:case-sensitive:~
	文字大小は区別
文字大小無視:case-insensitive:~
	-ly
保全-:preserve:~
保全:preserved::~

本体:body:~

	●An+B
整数部:integer part:~
小数点:decimal point:~
小数部:fractional part:~
指数:exponent:~
指示子:indicator:~
group:::グループ
	グループ化
周期:step:~
offset:
	差分:offset:~
省略-:omit:~

	●CSS
style:::スタイル
stylesheet:::スタイルシート
keyframe::::キーフレーム
keyword:::キーワード
cascade:::カスケード
level:::レベル
top-level:::トップレベル
animatable:::アニメート可能
animation:::アニメーション
custom:::カスタム
	custom property
prop:property::プロパティ
import:
媒体:media::~:メディア
query:::クエリ
記述子:descriptor::~
疑似類:pseudo-class:疑似クラス
	:pseudoclass
選択子:selector::~:セレクタ
要素:element:~
規則集合:rule set::~:ルールセット
次元:dimension:~
	媒体~型:~media type
文法:grammar:~
	汎用文法:generic grammar:~
汎用:generic:~
字句走査器:lexical scanner:字句スキャナ
再走査:rescan:~
	interact with the cascade
作用:interact:~
相互作用:interaction:~
無効:invalid:~
	最上level
無視-:ignore:~
	無視して:ignoring
出自:origin:~
詳細度:specificity:~
頁:page::ページ
文書:document:~
	子:children
結合子:combinator:~

疑似属性:pseudo-attribute:~

screen:::スクリーン
紙:paper:~
speech:::スピーチ
具現化法:rendering:~::レンダリング


	●CSSOM
method:::メソッド
object:::オブジェクト
属性:attribute:~
木:tree::ツリー

	●仕様
仕様:spec:~
	specification
作者:author:~
利用者:user:~::ユーザ
UA:user agent:UA::ユーザエージェント
module:::モジュール
拡張:extension:~
特色機能:feature:~
参考:informative:~
規定:normative:~
非互換:incompatible:~
実装-:implement:~
実装:implementation:~
実装者:implementor:~
移入:import:~
言語:language:~
適合性:conformance:~
勧告候補:Candidate Recommendation:~
作業草案:Working Draft:~
公開-:expose:~
hook:::フック
bug:::バグ
新たな:new:~
互換性bug:compat bug:互換性バグ
後方互換性:backward compatibility:~
互換性:compatibility:~
互換:compatible:~
登記簿:registery::レジストリ
コンパクト:compact:~
受容-:accept:~
	accepting
実際:actual:~
	影響-:affect:~
	~~影響impact
	響く／響かない
	~~影響しない:have no effect
	照らし合わせて:against
所産:artifact:~
許容-:allow:~
適用-:apply:~
	あてがう:assign
結付ける:associate する:結び付ける

前提に:assume:~
見做す:assume する:~
	前提:assumption:~
	試みる:attempt
	試みられtry
	〜に則って:according, accordingly
変更:change:~
変更点:changes:~


公式的:formal:~
将来:future:~
将来的:future:~
上品:graceful:~
暗黙的:implicit:~
不変則:invariant:~
意図-:intend:~
意図的:intentional:~
	意図されない:unintentional
	~~意図:meant
概要:introduction:~
実用上:practice 上:~
解釈-:interpret:~
	interpreting
	直感的な把握:intuitive grasp
知識:knowledge:~
	委ねられる:leaving
制限:limit:~
	, limitation, limiting
	制限を課さない:places no limits
手動的:manually:~
維持-:maintain:~
模倣:mimic:~

倣う:align する:~
	最新の:~most recent
可用:available:~
基本的:basic:~
挙動:behavior:ふるまい
概念:concept:~
概念的:conceptual:~
	考慮:regard:~
関知-:concern:~
帰結:consequence:~
	見なさ:consider
整合する:consistent になる:~
正しい:correct な:~
正しく:correct に:~
既定:default:~
定義-:define:~
	defining
定義:definition:~
依存-:depend:~
非依存:agnostic:~
記述:description:~
記述-:describe:~
	述べ-:describe
	述-:~say
		describing
設計:design:~

実質的:effective:~
確保:ensure:~
予期-:expect:~
	予期されない:unexpected
	期待-
明示的:explicit:~
	記される:expressed
事実:fact:~
充足:fulfill:~
基礎的:fundamental:~
一般:general:~
一般的な:general:~
	転化:turn:~
	必要とする:necessary
	必要に応じて:as necessary
	必要:need
通常:normal:~
	通常のように:as normal
記法:notation:~
注記:Note:~
	今や:now

不規則:odd:~
	古い:old
	より古い:older
	元々は:originally
	外部:outside:~
概観:overview:~
関与-:participate:~
	好ましい:preferably
問題:problem:~
	問題にならない:not problematic
適正:proper:~
	-ly
注釈文:prose:~
提供-:provide:~
旧来の:legacy:~
目的:purpose:~
	理に適った:reasonable
参照-:refer:~
	〜と呼ばれているもの:what is referred to as〜
参照元:referring:~
	一定周期に位置する:regularly-spaced intervals
関連:relevant:~
要請-:request:~
要求-:require:~
	要する:require／need
要件:requirement:~
解決:resolution:~
解消:fix:~
制約的:restrictive:~
制約:restriction:~
	書直され:rewrite され:書き直され
比較的安全:fairly safe:~
節:section:~
自己完結的:self-contained:~
意味論的:semantical:~
	意味:meaning
	意味する:means
有意:significant:~
許可-:permit:~
相:phase:段階
段階:stage:~
	要点:point:~
多義性:ambiguity:~
多義的:ambiguous:~
一義的:unambiguous:~
	取って代わる:supersede
	成代わる:supersede する:取って代わる
特別:special:~
特定の:specific な:~
特定0の:particular:ある特定の
特有:specific:~
	明確には:specific には:~
	specifically
指定-:specify:~
	指定している:specifying
未指定:unspecified:~
	指定:specification
再構成:destructure:~
自立的な:stand-alone:~
視点:standpoint:~
	仕事:task:~
技術上の:technical:~
用語:term:~
翻訳-:translate:~
移行-:translate:~
扱う:treat する:~
扱って:treat して:~
往来:round-trip:~
自明:trivial:~
	自明でない:non-trivial
試行-:try:~
典型的:typical:~
	概して:typically
専用の:dedicated:~
不変:unchanged:~
未定義:undefined:~
未知の:unknown:~
有用:useful:~
	通例的:usual
	通例の:usual
一時的:temporary:~
		temporarily
文法記号:grammar term:~
投棄-:throw away:破棄
破棄-:discard:~
棄てら:drop さ:棄てら
棄てる:drop する:棄てる
	最早:anymore
低次:low-level:~
高次:high-level:~
	必要程度に特定し得る:well-specified
well-defined:
衝突-:collide:~
	合法的:legitimate:~
混同-:confuse:~
	confusing
	同一視:as identical to:~
	解説:illustrate:~
概して:typical に:~
	都合:convenient
編集上の:editorial:~
編集者:editor:~
修正-:fix:~
重要な:substantive:~

	あるべき:decent
	責を負う:responsible
	注意を払う:paying attention
	意味:meaning
	意味する:means
	意味のある:meaningful

security:::セキュリティ
secure:::セキュア
privacy:::プライバシー
whitelist:::ホワイトリスト
filter:::フィルタ
改善-:improve:~
考慮点:considerations:~
懸念:concern:~
	状況:situation
	悪化-:worsen:~
	旧い:old:~

	●他
code:::コード
BOM:byte order mark:バイト順マーク
browser:::ブラウザ
web::::ウェブ
item:::アイテム
linking-mechanism:linking mechanism:リンク機構
instance:::インスタンス
付番:index::~:インデックス
protocol:::プロトコル
header:::ヘッダ
literal:::リテラル
	〜として:-ly
ローカルファイルシステム:local file system::~
file:::ファイル
ゼロ:zero:~
	バージョン:version:~
text:::テキスト
support:::サポート
source:::ソース
pattern:::パタン
scripting:::スクリプティング
network:::ネットワーク
	ネットワーク越しに:coming over the network
data:::データ

view:::ビュー
	俯瞰
抽象:abstract:~
動作-:act:~
他全部:anything else:その他
殆どの:most:ほとんどの
出現-:appear:~
	現れる:appear
自動的:automatic:~
	始まる:begins with
構築中:build 中:~
		building
事例:case:~
	きわどい事例:corner case
	文字大小:case
分類-:categorize:~
分類:categorization:~
改変-:modify:~
一掃:clean up:~
後始末:cleaning up:~
収集:collect:~
	-ing

	左端の:column
	上端の:row
共通-:共通
全部的:full:~
複雑:complex:~
	条件:condition:~
	状況:condition:~
条件付き:conditional:~
連続する:consecutive な:~
連続的な:contiguous:~
構築-:construct:~
構築:construction:~
包含-:contain:~
	包含している:containing
内容:content:~
文脈:context:~
	後続する:continue
制御:control:~
	対応している:corresponding
作成-:create:~
検知-:detect:~
決定-:determine:~
図式:diagram:~
相違:difference:~
分割-:divide:~
効果:effect:~
	括られ:enclosed
遭遇:encounter:~
	-ing
	取り込む:to be encountered
等価:equivalent:~
評価-:evaluate:~
枯渇:exhaust:~

既存の:existing:~
見出す:find する:~
見出され:find され:~
見出せ:find でき:~
最後の:last:~
最初の:first:~
	頭部:first several
新規:fresh:~
生成-:generate:~
即時:immediate:~
不完全:incomplete:~
完全:complete:~
	being completely broken:完全に壊れる
全部的:full:~
指示-:indicate:~
情報:information:~
内側:inside:~
	側:side
内部的:internal:~
形式:format:~
正規表現:regular expression:~
所在:location:~
	make
印:mark:~
移動-:move:~
	−1:negation
	負の:negative
負数:negative:~
渡す:pass する:~
渡され:pass され:~
遂行-:perform:~
	実行-:execute
先行-:precede:~
精確:precise:~
呈示-:present:~
呈示用途の:presentational:~
	以前に:previously
印刷:print:~
到達-:reach:~
実態:reality:~
認識0:realize:認識
認識-:recognize:~
	認識されない:unrecognized
	残り:remainder
	〜に留意:~reminder…
表現-:represent:~
表現:representation:~
	representing, representation（文字列表現）
	-ed
資源:resource::~:リソース
再開-:resume:~
科学的記数法:scientific notation:~
選択:select:~
別個の:separate:~
	〜並び:sequence
	〜列:sequence
	~byte列:sequence of bytes
連なり:series:~
単独の:single:~
開始:start:~
	start...again
	開始され:start with
	開始されている:starting with
構造:structure:~
合計:total:~
最悪:at worst:~
誤用:mistake:~
一部分:portion:~
値定義構文:Value Definition Syntax:値定義の構文



	特に:in particular
	 よく似る:resemble
	それら自身:themselves
	もの:things
	正確:exact
	それなりの~~正確さfairly accurate
	量:amount
	次の:adjacent
	ほぼ:almost
	すでに:already
	:adjusting
	:afterwards
	:although
	一緒に:altogether
	常に:always
	別の:another
	戻す:back onto
	〜に基づいて:based on
	合間:between:~
	壊れ:broken
	場合:case
	欄:cell:~
	箇所:certain points
	ほぼ:certainly
	選ばれ:chosen
	項:clause:~
	閉じ:closing:~
	閉じら:close さ:~
	closed／unclosed
	開き:opening:~
	開いた:opened
	まだ閉じられていない:still open
	縮約:collapsed into
	〜からなる:~composed of 〜
	成す:comprise する
	〜からなる:consisting of
	〜からなる:consists
	〜の一部を成す:~constitute 〜
	その場で:on-demand
	表す／示され:denote
	必要に応じて:if so desired
	に反し:despite
	詳細:detail:~
		-ed
	（互いに）異なる:different
	異なる:differ
	区別する:disambiguate
	二重に:doubled
	〜の間:during
	易-:easier
	易く:easily
	十分:enough
	十分:fine
	十分な:sufficient
	全体:entire
	全然:entirely
	等しい:equal
	ever 
	あらゆるもの:everything
	すべて
	例:example
	除-:except
	例外:exception:~
	見られる:exhibit
	存在-:exist
	それなり:fairly
	少数の:few
	filled
	最終的に:eventual
	-:final
	-:finally
	見出し:heading
	細やか:fine-grained
		fine-grainted
	抜けた:finish
	次の, 従う, 後続, :follow-
	形:form
	formed
	前者:the former:~
	後者:the latter:~
	先頭:front, ...
	更なる:further
	与えられ:given
	見受けられる:we’ve gotten
	-ly
	より大きい:greater
	最大の:greatest／largest／maximum
	個々の:individual
	hence
	高い:high
	より高い:higher
	〜の利用を通して:hooking
	含-:includ-
	〜:inclusive
	初期時には:initially
	最初は:initially
	〜の代わりに:instead
		 instruct
	-:intersection
	項目
	それ自身:itself
	保つ:keep
	:please let me know
	少なくとも 1 つ以上の:at least one
	より長い:longer
	最も長い:longest
	見える:look
	調べる:looks at
	印~付き:marked
	言及:mention
	中途にある:in the middle of
	最小限の〜:minimum amount of 〜
	小さな:minor
	種々の:miscellanous:~
	混在する:mixed
	最も:most
	おおよそ:nearly
	決して:never
	次の:next
	非:non
	得る:achieve
	得る:obtain
	得られる:obtained
	生じる:occur
	もの:ones
	order
	他の:other
	その他:others
	外側の:outer
	組:pair
	一部:part
	自身による:own
	選ばれる:picked
	場所:place:~
	正の:positive
	可能:possible
	できるだけ多くの:as many as possible
	優先度:precedence
	優先-:gives precedence
	有無:presence
	在る:present
	不在:not present
	おそらく:probably
	〜を先頭に戻す:push〜back onto the front
	:question
	読み取／読まれる／読む:read
	実の:real
	２番目の:second
	当該の:respective
	~呼応する／対応する
	残りの部分:rest
	他のもの:rest
	他の:rest
	結果:result:~
	結果の:resulted
	結果の:resulting
	保ち続ける:retain
		~ly
	同じ:identical:~
	同じ:same
	見える:seen
	selecting
	送る:sending
	いくつかの:several
	短い:short
	べき:should
	現れる:showing up
	示される:shown
	示す:shows
	現れ:show up
	同様:similar
		-ly
	似る:similar
	3 番目の:third
	3 個の:three
	2 個の:two
	6 個の:six
	7 個:seven
	少しばかり:slightly
	全体を占める値:sole value
	もっぱら〜に利用される:sole use
	もっぱら:solely
	何らかの／一部の:some
	何か:something
	いくぶん:somewhat
	読み綴る:spell
	囲まれ:surrounded
	表:table
	取り込まれる:taken
	take
	taking
	依然として:still
	まだ open:still open
	次回:next time:~
	同時に，:together
	まったく:totally
	OFF:unset
	〜まで:until
	利用:use:~
	用いる:use する:~
	用いて:use して:~
	用いら:use さ:~
	種々の:varied
	多岐に渡る:wide variety of
	種々の:various
	変わり得る:vary
	先頭に位置する:very first
	とりわけ:very
	仕方:way:~
	望まれる:wish
	言い換えれば:in other words
	働く:work
	心配せずに:without worrying about
	記される:written
	それらを:them
	すべての:all
	複数の:multiple
	または:or
	非:non
	他の場合:otherwise
	前:before
	後:after
	他の:other
	この:this
	各:each
	その:its
	方法:how
	しかしながら，:However
	〜のいずれか:~either
	他のもの:anything else
	満たす:satisfy
	単に:just
	simple enough that
	respectively
	lower-, higher
	もの:things
	〜で括られた:wrapped

	[CSS-VALUES] 仕様:Values &amp; Units spec


	HTML, XML, Unicode, Media Queries, Selectors, Fonts, Syntax, CSSOM, SVG
	HTTP, IANA, WebKit, Working Group
	BAD_STRING, BAD_URI, UTF-16
</script>


<!--% 訳文 id → 原文 id -->
<script type="text/plain" id="_original_id_map">
repeatedly-consume-next-code-point:
repeatedly-consume-next-token:
curly-block:
paren-block:
square-block:
plus-or-minus:
series-of-digits:

anb-step:a
anb-offset:b

	●
whitespaces-diagram:ws*-diagram
curly-block-diagram:{}-block-diagram
paren-block-diagram:%28%29-block-diagram
square-block-diagram:[]-block-diagram

	●
consume-an-ident-like-token:consume-an-ident_like-token
non-printable-code-point:non_printable-code-point
name-start-code-point:name_start-code-point
at-rule:at_rule
parse-a-comma-separated-list-of-component-values:parse-a-comma_separated-list-of-component-values
top-level-flag:top_level-flag
consume-an-at-rule:consume-an-at_rule
non-ascii-code-point:non_ascii-code-point
</script>


<!--%links -->
<script type="text/plain" id="_link_map">
無効:#css-invalid
無視-:#css-ignored
~at-ruleを消費:#consume-an-at-rule
~comment列を消費:#consume-comments
~escapeされた符号位置を消費:#consume-an-escaped-code-point
関数式を消費:#consume-a-function
識別子に類する~tokenを消費:#consume-an-ident-like-token
実数を消費:#consume-a-number
有修飾~規則を消費:#consume-a-qualified-rule
~tokenを消費:#consume-a-token
~unicode-range~tokenを消費:#consume-a-unicode-range-token
~url~tokenを消費:#consume-a-url-token
数的~tokenを消費:#consume-a-numeric-token
成分値を消費:#consume-a-component-value
宣言~listを消費:#consume-a-list-of-declarations
宣言を消費:#consume-a-declaration
単純~blockを消費:#consume-a-simple-block
名前を消費:#consume-a-name
不良~urlの残余を消費:#consume-the-remnants-of-a-bad-url
規則~listを消費:#consume-a-list-of-rules
文字列~tokenを消費:#consume-a-string-token

構文解析error:#parse-error
~stylesheetを構文解析-:#parse-a-stylesheet
規則を構文解析-:#parse-a-rule
成分値を構文解析-:#parse-a-component-value
宣言~listを構文解析-:#parse-a-list-of-declarations
宣言~list:#parse-a-list-of-declarations
宣言を構文解析-:#parse-a-declaration
規則~listを構文解析-:#parse-a-list-of-rules
規則~list:#parse-a-list-of-rules
成分値~listを構文解析-:#parse-a-list-of-component-values
カンマ区切りの成分値~listを構文解析-:#parse-a-comma-separated-list-of-component-values
	parse a comma-separated list of component values
実数に変換-:#convert-a-string-to-a-number
~escaping:#escape-codepoint

次入力~tokenを消費:#consume-the-next-input-token
現入力~tokenを再消費:#reconsume-the-current-input-token
現入力~符号位置を再消費:#reconsume-the-current-input-code-point
何かを CSS 文法に則って構文解析する:#parse-something-according-to-a-css-grammar
~CSS~stylesheetを構文解析-:#parse-a-css-stylesheet

~fallback符号化方式を決定する:#determine-the-fallback-encoding
	~letter:#letter※

~ASCII文字大小無視:~DOM4#ascii-case-insensitive

at.charset:#at-ruledef-charset

~anb 値を直列化-:#serialize-an-anb-value

符号位置:#code-point
現入力~token:#current-input-token
現入力~符号位置:#current-input-code-point
次入力~token:#next-input-token
次入力~符号位置:#next-input-code-point
次入力~符号位置を繰り返し消費:#repeatedly-consume-next-code-point
次入力~tokenを繰り返し消費:#repeatedly-consume-next-token

~EOF符号位置:#eof-code-point
数字:#digit
~hex:#hex-digit
正負符号:#plus-or-minus
指数~指示子:#exponent-indicator
英字:#letter
小文字:#lowercase-letter
大文字:#uppercase-letter
非~ASCII符号位置:#non-ascii-code-point
名前開始~符号位置:#name-start-code-point
名前~符号位置:#name-code-point
印字不能~符号位置:#non-printable-code-point
改行:#newline
空白:#whitespace
~surrogate~符号位置:#surrogate-code-point

許容される最大の符号位置:#maximum-allowed-code-point
識別子:#identifier

環境~符号化方式:#environment-encoding

~at-rule:#at-rule
有修飾~規則:#qualified-rule
宣言:#declaration
成分値:#component-value
保全~token:#preserved-tokens
関数式:#function
単純~block:#simple-block
成分値~list:#_component-value-list

波括弧~block:#curly-block
丸括弧~block:#paren-block
角括弧~block:#square-block

復号-:#decode
	終端ing~token:#ending-token
~style規則:#style-rule
妥当な~escape:#check-if-two-code-points-are-a-valid-escape
妥当な~escapeから開始されている:#check-if-two-code-points-are-a-valid-escape
識別子を開始させる:#check-if-three-code-points-would-start-an-identifier
識別子から開始されている:#check-if-three-code-points-would-start-an-identifier

~top-level~flag:#top-level-flag

実数から開始されている:#check-if-three-code-points-would-start-a-number
実数を開始させる:#check-if-three-code-points-would-start-a-number

次の 2 個の入力~符号位置:#next-input-code-point
次の 3 個の入力~符号位置:#next-input-code-point
次の 2 ないし 3 個の入力~符号位置:#next-input-code-point
次の 3 個の入力~符号位置:#next-input-code-point
	後続の n 番目の符号位置
	後続の符号位置(n)

	符号化方式:#at-charset-encoding
~anb:#anb-production

~AnB:#anb
数字~列:#series-of-digits


16 進 整数として解釈-:#interpret-a-token-as-a-hex-integer


	●§
直列化:#serialization
前処理:#input-preprocessing
入力の前処理:#input-preprocessing
入力~byte~stream:#input-byte-stream
~tokenization:#tokenization


	`A:#a
	`B:#b
周期:#anb-step
~offset:#anb-offset


	●外部
	animations-1
css.animation-timing-function:~CSSANIM#propdef-animation-timing-function
値定義構文:~CSSVAL#value-defs
関数記法:~CSSVAL#functional-notation
CSS 識別子:~CSSVAL#identifier

t.number:~CSSVAL#number-value
t.dimension:~CSSVAL#typedef-dimension
t.string:~CSSVAL#string-value
t.translation-value:~TR/css3-transforms/#typedef-translation-value
t.color:~CSSWG/css-color-3/#colorunits

p.text-decoration:~CSSTEXTDECOR#propdef-text-decoration
p.color:~CSSWG/css-color-3/#color0

v.underline:~CSSTEXTDECOR#valdef-text-decoration-line-underline

css.attr():~CSSVAL#funcdef-attr
css.translateX():~TRANSFORM#funcdef-translatex
	ps.nth-child():~SELECTORS#nth-child-pseudo
css.url()

at.keyframes:~CSSANIM#keyframes
at.import:~CASCADE#at-ruledef-import
at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.page:~CSSPAGE#at-ruledef-page
at.font-face:~CSSFONT#at-ruledef-font-face
	#at-font-face-rule
	#font-face-rule
css.unicode-range:~CSSFONT#descdef-unicode-range
	unicode-range-desc
	#descdef-font-face-unicode-range（~CSSWG/css-fonts-3/）
	blue:csswg/css-color-4/#valdef-color-blue
	:left:~CSSPAGE#valdef-page-left
c.CSSStyleSheet:~CSSOM#cssstylesheet

選択子~list:~SELECTORS#selector-list
無効な選択子~list:~SELECTORS#invalid
~ID選択子:~SELECTORS#id-selectors
属性~選択子:~SELECTORS#attribute-selectors
column 結合子:~SELECTORS#column-combinator
結合子:~SELECTORS#combinator

	#valuea-def-color／#color0
	※？

	Selectors API:~TR/selectors-api/
	Selectors仕様:~TR/selectors/

詳細度:~CASCADE#cascade-specificity
出自:~CASCADE#origin

	conditional-1
条件付き~group規則:~CSSCOND#conditional-group-rules

Unicode 範囲指定:~CSSFONT#unicode-range-desc

~custom~prop:~CSSVAR#custom-property

規則集合:~TR/CSS21/syndata.html#rule-sets
~EOF~errorの取扱い規則:~TR/CSS21/syndata.html#unexpected-eof

	~TR/xml-stylesheet/
		疑似属性:~xml-stylesheet/#dt-pseudo-attribute
		xml-stylesheet:~xml-stylesheet/#the-xml-stylesheet-processing-instruction
		charset:~xml-stylesheet/#PA-charset


符号化方式~label:~ENCODING#label
	復号-~algo:~ENCODING#decode
符号化方式を取得:#get-an-encoding
	~ENCODING#concept-encoding-get

	Unicode 符号位置:http://unicode.org/glossary/#code_point

</script>


<script type="text/plain" id="_unicode_map">
00:NULL
08:BACKSPACE
09:CHARACTER TABULATION
0A:LINE FEED
0B:LINE TABULATION
0C:FORM FEED
0D:CARRIAGE RETURN
0E:SHIFT OUT
1F:INFORMATION SEPARATOR ONE
20:SPACE
21:EXCLAMATION MARK 
22:QUOTATION MARK
23:NUMBER SIGN
24:DOLLAR SIGN
25:PERCENTAGE SIGN
27:APOSTROPHE
28:LEFT PARENTHESIS
29:RIGHT PARENTHESIS
2A:ASTERISK
2B:PLUS SIGN
2C:COMMA
2D:HYPHEN-MINUS 
2E:FULL STOP
2F:SOLIDUS
30:DIGIT ZERO
39:DIGIT NINE
3A:COLON
3B:SEMICOLON
3C:LESS-THAN SIGN
3D:EQUALS SIGN
3E:GREATER-THAN SIGN
3F:QUESTION MARK
40:COMMERCIAL AT
41:LATIN CAPITAL LETTER A
45:LATIN CAPITAL LETTER E
46:LATIN CAPITAL LETTER F
55:LATIN CAPITAL LETTER U
5A:LATIN CAPITAL LETTER Z
5B:LEFT SQUARE BRACKET
5C:REVERSE SOLIDUS
5D:RIGHT SQUARE BRACKET
5E:CIRCUMFLEX ACCENT
5F:LOW LINE
61:LATIN SMALL LETTER A
65:LATIN SMALL LETTER E
66:LATIN SMALL LETTER F
75:LATIN SMALL LETTER U
7A:LATIN SMALL LETTER Z
7B:LEFT CURLY BRACKET
7C:VERTICAL LINE
7D:RIGHT CURLY BRACKET
7E:TILDE
7F:DELETE
	80:&lt;control&gt;
	FFFD:REPLACEMENT CHARACTER
	80:to 009F
	D800:and 
	DFFF:inclusive

</script>


<!--%style -->


<!-- ※
class="railroad-diagram" → 除去（ svg はすべて線路図式）
svg.railroad-diagram tagname → svg|tagname
埋め込み svg に名前空間宣言は不要
https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/HTML5_Parser
-->

<style>
@namespace svg url(http://www.w3.org/2000/svg);

svg|svg{
	background-color:hsl(30,20%,95%);
}
svg|path{
	stroke-width:3;
	stroke:black;
	fill:rgba(0,0,0,0);
}
svg|text{
	font:bold 14px monospace;
	text-anchor:middle;
}
svg|text.label{
	text-anchor:start;
}
svg|text.comment{
	font:italic 12px monospace;
}
svg|rect{
	stroke-width:3;
	stroke:black;
	fill:hsl(120,100%,90%);
}


dd.railroad {
	overflow: auto;
}
</style>


<style>
small.cp {
	color: gray;
}

.symbol {
	color: black;
}

td[colspan] {
	text-align:center;
}

#_ser-table_ tr > th:first-child {
	text-align: right;
}

._ser-table_ {
	margin-left: auto;
	margin-right: auto;
}

._ser-table_ td {
	text-align: center;
}

@supports (transform: rotate(-40deg)) or (-webkit-transform: rotate(-45deg)) {
	#_ser-table_ {
		padding-top: 4em;
	}
	#_ser-table_ thead > tr {
		border: none;
	}
	#_ser-table_ thead > tr > th {
		border: none;
		background: none;
		padding: 0;
		min-width: 2.5em;
		max-width: 2.5em;
		white-space: nowrap;
	}

	#_ser-table_ thead > tr > th > * {
		margin-left: 0.5em;
		overflow: visible;
		line-height: 1em;
		text-decoration: underline;
		display: block;
		-webkit-transform: rotate(-40deg);
		-webkit-transform-origin: 0% 0%;
		transform: rotate(-40deg);
		transform-origin: 0% 0%;
	}
}

</style>


</head>



<body>


<div style="display:none;">
<input type="hidden" id="_page_config" value="" />

<!--%resource pool -->
<div id="_resources">
<svg id="_dgm-comment" class="railroad-diagram" height="81" viewBox="0 0 497 81" width="497">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M86 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M86.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="30"></rect>
<text x="68.0" y="45">
/*</text></g>
<g data-type="choice" data-updown="21 20">
<path d="M96 41h0.0"></path>
<path d="M400.0 41h0.0"></path>
<path d="M96.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M380.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M116.0 21h264"></path></g>
<path d="M96.0 41h20"></path>
<path d="M380.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M116.0 41h0.0"></path>
<path d="M380.0 41h0.0"></path>
<path d="M116.0 41h10"></path>
<path d="M370.0 41h10"></path>
<path d="M126.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M370.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M126.0 41h0.0"></path>
<path d="M370.0 41h0.0"></path>
<rect height="22" width="244" x="126.0" y="30"></rect>
<text x="248.0" y="45">
anything but * followed by /</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M126.0 61h244"></path></g></g></g>
<path d="M400 41h10"></path>
<path d="M446 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M410 41h0.0"></path>
<path d="M446.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="410.0" y="30"></rect>
<text x="428.0" y="45">
*/</text></g>
<path d="M 456 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>

<svg id="_dgm-newline" class="railroad-diagram" height="152" viewBox="0 0 173 152" width="173">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="11 101">
<path d="M40 31h0.0"></path>
<path d="M132.0 31h0.0"></path>
<path d="M40.0 31h20"></path>
<path d="M112.0 31h20"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 31h8.0"></path>
<path d="M104.0 31h8.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="68.0" y="20"></rect>
<text x="86.0" y="35">
\n</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M112.0 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 61h0.0"></path>
<path d="M112.0 61h0.0"></path>
<rect height="22" rx="10" ry="10" width="52" x="60.0" y="50"></rect>
<text x="86.0" y="65">
\r\n</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<path d="M112.0 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 91h8.0"></path>
<path d="M104.0 91h8.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="68.0" y="80"></rect>
<text x="86.0" y="95">
\r</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
<path d="M112.0 121a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 121h8.0"></path>
<path d="M104.0 121h8.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="68.0" y="110"></rect>
<text x="86.0" y="125">
\f</text></g></g>
<path d="M 132 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>

<svg id="_dgm-whitespace" class="railroad-diagram" height="122" viewBox="0 0 197 122" width="197">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="11 71">
<path d="M40 31h0.0"></path>
<path d="M156.0 31h0.0"></path>
<path d="M40.0 31h20"></path>
<path d="M136.0 31h20"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 31h8.0"></path>
<path d="M128.0 31h8.0"></path>
<rect height="22" rx="10" ry="10" width="60" x="68.0" y="20"></rect>
<text x="98.0" y="35">
space</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M136.0 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 61h20.0"></path>
<path d="M116.0 61h20.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="80.0" y="50"></rect>
<text x="98.0" y="65">
\t</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<path d="M136.0 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 91h0.0"></path>
<path d="M136.0 91h0.0"></path>
<rect height="22" width="76" x="60.0" y="80"></rect>
<text x="98.0" y="95">
newline</text></g></g>
<path d="M 156 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-hex-digit" class="railroad-diagram" height="62" viewBox="0 0 233 62" width="233">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M182 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M182.0 31h0.0"></path>
<rect height="22" width="132" x="50.0" y="20"></rect>
<text x="116.0" y="35">
0-9 a-f or A-F</text></g>
<path d="M 192 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-escape" class="railroad-diagram" height="122" viewBox="0 0 441 122" width="441">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M78 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M78.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="20"></rect>
<text x="64.0" y="35">
\</text></g>
<g data-type="choice" data-updown="11 71">
<path d="M88 31h0.0"></path>
<path d="M400.0 31h0.0"></path>
<path d="M88.0 31h20"></path>
<path d="M380.0 31h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M108.0 31h30.0"></path>
<path d="M350.0 31h30.0"></path>
<rect height="22" width="212" x="138.0" y="20"></rect>
<text x="244.0" y="35">
not newline or hex digit</text></g>
<path d="M88.0 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M380.0 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="sequence" data-updown="11 41">
<path d="M108.0 61h0.0"></path>
<path d="M380.0 61h0.0"></path>
<path d="M108.0 61h10"></path>
<path d="M230.0 61h10"></path>
<g data-type="oneormore" data-updown="11 41">
<path d="M118.0 61h0.0"></path>
<path d="M230.0 61h0.0"></path>
<path d="M118.0 61h10"></path>
<path d="M220.0 61h10"></path>
<path d="M128.0 61a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
<path d="M220.0 91a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M128.0 61h0.0"></path>
<path d="M220.0 61h0.0"></path>
<rect height="22" width="92" x="128.0" y="50"></rect>
<text x="174.0" y="65">
hex digit</text></g>
<g data-type="comment" data-updown="11 11">
<path d="M128.0 91h9.5"></path>
<path d="M210.5 91h9.5"></path>
<text class="comment" x="174.0" y="96">
1 〜 6 回</text></g></g>
<g data-type="choice" data-updown="10 40">
<path d="M240.0 61h0.0"></path>
<path d="M380.0 61h0.0"></path>
<path d="M240.0 61h20"></path>
<path d="M360.0 61h20"></path>
<g data-type="skip" data-updown="0 0">
<path d="M260.0 61h100"></path></g>
<path d="M240.0 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M360.0 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M260.0 81h0.0"></path>
<path d="M360.0 81h0.0"></path>
<rect height="22" width="100" x="260.0" y="70"></rect>
<text x="310.0" y="85">
whitespace</text></g></g></g></g>
<path d="M 400 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-whitespace-token" class="railroad-diagram" height="71" viewBox="0 0 221 71" width="221">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M170 31h10"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M50 31h0.0"></path>
<path d="M170.0 31h0.0"></path>
<path d="M50.0 31h10"></path>
<path d="M160.0 31h10"></path>
<path d="M60.0 31a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M160.0 51a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 31h0.0"></path>
<path d="M160.0 31h0.0"></path>
<rect height="22" width="100" x="60.0" y="20"></rect>
<text x="110.0" y="35">
whitespace</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M60.0 51h100"></path></g></g>
<path d="M 180 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-whitespaces" class="railroad-diagram" height="81" viewBox="0 0 305 81" width="305">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="21 20">
<path d="M40 41h0.0"></path>
<path d="M264.0 41h0.0"></path>
<path d="M40.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M244.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M60.0 21h184"></path></g>
<path d="M40.0 41h20"></path>
<path d="M244.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M60.0 41h0.0"></path>
<path d="M244.0 41h0.0"></path>
<path d="M60.0 41h10"></path>
<path d="M234.0 41h10"></path>
<path d="M70.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M234.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M70.0 41h0.0"></path>
<path d="M234.0 41h0.0"></path>
<rect height="22" width="164" x="70.0" y="30"></rect>
<text x="152.0" y="45">
&lt;whitespace-token></text></g>
<g data-type="skip" data-updown="0 0">
<path d="M70.0 61h164"></path></g></g></g>
<path d="M 264 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-ident-token" class="railroad-diagram" height="130" viewBox="0 0 769 130" width="769">

<g transform="translate(.5 .5)">
<path d="M 20 51 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="41 41">
<path d="M40 61h0.0"></path>
<path d="M384.0 61h0.0"></path>
<path d="M40.0 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M364.0 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 31h134.0"></path>
<path d="M230.0 31h134.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="194.0" y="20"></rect>
<text x="212.0" y="35">
--</text></g>
<path d="M40.0 61h20"></path>
<path d="M364.0 61h20"></path>
<g data-type="sequence" data-updown="11 41">
<path d="M60.0 61h0.0"></path>
<path d="M364.0 61h0.0"></path>
<g data-type="choice" data-updown="10 40">
<path d="M60.0 61h0.0"></path>
<path d="M128.0 61h0.0"></path>
<path d="M60.0 61h20"></path>
<path d="M108.0 61h20"></path>
<g data-type="skip" data-updown="0 0">
<path d="M80.0 61h28"></path></g>
<path d="M60.0 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M108.0 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M80.0 81h0.0"></path>
<path d="M108.0 81h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="80.0" y="70"></rect>
<text x="94.0" y="85">
-</text></g></g>
<g data-type="choice" data-updown="11 41">
<path d="M128.0 61h0.0"></path>
<path d="M364.0 61h0.0"></path>
<path d="M128.0 61h20"></path>
<path d="M344.0 61h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M148.0 61h0.0"></path>
<path d="M344.0 61h0.0"></path>
<rect height="22" width="196" x="148.0" y="50"></rect>
<text x="246.0" y="65">
a-z A-Z _ or non-ASCII</text></g>
<path d="M128.0 61a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M344.0 91a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M148.0 91h64.0"></path>
<path d="M280.0 91h64.0"></path>
<rect height="22" width="68" x="212.0" y="80"></rect>
<text x="246.0" y="95">
escape</text></g></g></g></g>
<g data-type="choice" data-updown="21 49">
<path d="M384 61h0.0"></path>
<path d="M728.0 61h0.0"></path>
<path d="M384.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M708.0 41a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M404.0 41h304"></path></g>
<path d="M384.0 61h20"></path>
<path d="M708.0 61h20"></path>
<g data-type="oneormore" data-updown="11 49">
<path d="M404.0 61h0.0"></path>
<path d="M708.0 61h0.0"></path>
<path d="M404.0 61h10"></path>
<path d="M698.0 61h10"></path>
<path d="M414.0 61a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<path d="M698.0 110a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="11 41">
<path d="M414.0 61h0.0"></path>
<path d="M698.0 61h0.0"></path>
<path d="M414.0 61h20"></path>
<path d="M678.0 61h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M434.0 61h0.0"></path>
<path d="M678.0 61h0.0"></path>
<rect height="22" width="244" x="434.0" y="50"></rect>
<text x="556.0" y="65">
a-z A-Z 0-9 _ - or non-ASCII</text></g>
<path d="M414.0 61a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M678.0 91a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M434.0 91h88.0"></path>
<path d="M590.0 91h88.0"></path>
<rect height="22" width="68" x="522.0" y="80"></rect>
<text x="556.0" y="95">
escape</text></g></g>
<g data-type="skip" data-updown="0 0">
<path d="M414.0 110h284"></path></g></g></g>
<path d="M 728 61 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-function-token" class="railroad-diagram" height="62" viewBox="0 0 273 62" width="273">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M174 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M174.0 31h0.0"></path>
<rect height="22" width="124" x="50.0" y="20"></rect>
<text x="112.0" y="35">
&lt;ident-token></text></g>
<path d="M184 31h10"></path>
<path d="M222 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M194 31h0.0"></path>
<path d="M222.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="194.0" y="20"></rect>
<text x="208.0" y="35">
(</text></g>
<path d="M 232 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-at-keyword-token" class="railroad-diagram" height="62" viewBox="0 0 273 62" width="273">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M78 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M78.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="20"></rect>
<text x="64.0" y="35">
@</text></g>
<path d="M88 31h10"></path>
<path d="M222 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M98 31h0.0"></path>
<path d="M222.0 31h0.0"></path>
<rect height="22" width="124" x="98.0" y="20"></rect>
<text x="160.0" y="35">
&lt;ident-token></text></g>
<path d="M 232 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-hash-token" class="railroad-diagram" height="100" viewBox="0 0 453 100" width="453">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M78 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M78.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="20"></rect>
<text x="64.0" y="35">
#</text></g>
<path d="M88 31h10"></path>
<path d="M402 31h10"></path>
<g data-type="oneormore" data-updown="11 49">
<path d="M98 31h0.0"></path>
<path d="M402.0 31h0.0"></path>
<path d="M98.0 31h10"></path>
<path d="M392.0 31h10"></path>
<path d="M108.0 31a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<path d="M392.0 80a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="11 41">
<path d="M108.0 31h0.0"></path>
<path d="M392.0 31h0.0"></path>
<path d="M108.0 31h20"></path>
<path d="M372.0 31h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M128.0 31h0.0"></path>
<path d="M372.0 31h0.0"></path>
<rect height="22" width="244" x="128.0" y="20"></rect>
<text x="250.0" y="35">
a-z A-Z 0-9 _ - or non-ASCII</text></g>
<path d="M108.0 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M372.0 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M128.0 61h88.0"></path>
<path d="M284.0 61h88.0"></path>
<rect height="22" width="68" x="216.0" y="50"></rect>
<text x="250.0" y="65">
escape</text></g></g>
<g data-type="skip" data-updown="0 0">
<path d="M108.0 80h284"></path></g></g>
<path d="M 412 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-string-token" class="railroad-diagram" height="248" viewBox="0 0 481 248" width="481">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="21 187">
<path d="M40 41h0.0"></path>
<path d="M440.0 41h0.0"></path>
<path d="M40.0 41h20"></path>
<path d="M420.0 41h20"></path>
<g data-type="sequence" data-updown="21 79">
<path d="M60.0 41h0.0"></path>
<path d="M420.0 41h0.0"></path>
<path d="M60.0 41h10"></path>
<path d="M98.0 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M70.0 41h0.0"></path>
<path d="M98.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="70.0" y="30"></rect>
<text x="84.0" y="45">
"</text></g>
<g data-type="choice" data-updown="21 79">
<path d="M108.0 41h0.0"></path>
<path d="M372.0 41h0.0"></path>
<path d="M108.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M352.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M128.0 21h224"></path></g>
<path d="M108.0 41h20"></path>
<path d="M352.0 41h20"></path>
<g data-type="oneormore" data-updown="11 79">
<path d="M128.0 41h0.0"></path>
<path d="M352.0 41h0.0"></path>
<path d="M128.0 41h10"></path>
<path d="M342.0 41h10"></path>
<path d="M138.0 41a10 10 0 0 0 -10 10v59a10 10 0 0 0 10 10"></path>
<path d="M342.0 120a10 10 0 0 0 10 -10v-59a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="11 71">

 <path d="M138.0 41h0.0"></path>
 <path d="M342.0 41h0.0"></path>
 <path d="M138.0 41h20"></path>
 <path d="M322.0 41h20"></path>
 <g data-type="non-terminal" data-updown="11 11">

  <path d="M158.0 41h0.0"></path>
  <path d="M322.0 41h0.0"></path>
  <rect height="22" width="164" x="158.0" y="30"></rect>
  <text x="240.0" y="45">
not " \ or newline</text></g>
 <path d="M138.0 41a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
 <path d="M322.0 71a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
 <g data-type="non-terminal" data-updown="11 11">

  <path d="M158.0 71h48.0"></path>
  <path d="M274.0 71h48.0"></path>
  <rect height="22" width="68" x="206.0" y="60"></rect>
  <text x="240.0" y="75">
escape</text></g>
 <path d="M138.0 41a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
 <path d="M322.0 101a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
 <g data-type="sequence" data-updown="11 11">

  <path d="M158.0 101h10.0"></path>
  <path d="M312.0 101h10.0"></path>
  <path d="M168.0 101h10"></path>
  <path d="M206.0 101h10"></path>
  <g data-type="terminal" data-updown="11 11">

   <path d="M178.0 101h0.0"></path>
   <path d="M206.0 101h0.0"></path>
   <rect height="22" rx="10" ry="10" width="28" x="178.0" y="90"></rect>
   <text x="192.0" y="105">
\</text></g>
  <path d="M216.0 101h10"></path>
  <path d="M302.0 101h10"></path>
  <g data-type="non-terminal" data-updown="11 11">

   <path d="M226.0 101h0.0"></path>
   <path d="M302.0 101h0.0"></path>
   <rect height="22" width="76" x="226.0" y="90"></rect>
   <text x="264.0" y="105">
newline</text></g></g></g>
<g data-type="skip" data-updown="0 0">

 <path d="M138.0 120h204"></path></g></g></g>
<path d="M372.0 41h10"></path>
<path d="M410.0 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M382.0 41h0.0"></path>
<path d="M410.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="382.0" y="30"></rect>
<text x="396.0" y="45">
"</text></g></g>
<path d="M40.0 41a10 10 0 0 1 10 10v88a10 10 0 0 0 10 10"></path>
<path d="M420.0 149a10 10 0 0 0 10 -10v-88a10 10 0 0 1 10 -10"></path>
<g data-type="sequence" data-updown="21 79">
<path d="M60.0 149h0.0"></path>
<path d="M420.0 149h0.0"></path>
<path d="M60.0 149h10"></path>
<path d="M98.0 149h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M70.0 149h0.0"></path>
<path d="M98.0 149h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="70.0" y="138"></rect>
<text x="84.0" y="153">
'</text></g>
<g data-type="choice" data-updown="21 79">
<path d="M108.0 149h0.0"></path>
<path d="M372.0 149h0.0"></path>
<path d="M108.0 149a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M352.0 129a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M128.0 129h224"></path></g>
<path d="M108.0 149h20"></path>
<path d="M352.0 149h20"></path>
<g data-type="oneormore" data-updown="11 79">
<path d="M128.0 149h0.0"></path>
<path d="M352.0 149h0.0"></path>
<path d="M128.0 149h10"></path>
<path d="M342.0 149h10"></path>
<path d="M138.0 149a10 10 0 0 0 -10 10v59a10 10 0 0 0 10 10"></path>
<path d="M342.0 228a10 10 0 0 0 10 -10v-59a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="11 71">

 <path d="M138.0 149h0.0"></path>
 <path d="M342.0 149h0.0"></path>
 <path d="M138.0 149h20"></path>
 <path d="M322.0 149h20"></path>
 <g data-type="non-terminal" data-updown="11 11">

  <path d="M158.0 149h0.0"></path>
  <path d="M322.0 149h0.0"></path>
  <rect height="22" width="164" x="158.0" y="138"></rect>
  <text x="240.0" y="153">
not ' \ or newline</text></g>
 <path d="M138.0 149a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
 <path d="M322.0 179a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
 <g data-type="non-terminal" data-updown="11 11">

  <path d="M158.0 179h48.0"></path>
  <path d="M274.0 179h48.0"></path>
  <rect height="22" width="68" x="206.0" y="168"></rect>
  <text x="240.0" y="183">
escape</text></g>
 <path d="M138.0 149a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
 <path d="M322.0 209a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
 <g data-type="sequence" data-updown="11 11">

  <path d="M158.0 209h10.0"></path>
  <path d="M312.0 209h10.0"></path>
  <path d="M168.0 209h10"></path>
  <path d="M206.0 209h10"></path>
  <g data-type="terminal" data-updown="11 11">

   <path d="M178.0 209h0.0"></path>
   <path d="M206.0 209h0.0"></path>
   <rect height="22" rx="10" ry="10" width="28" x="178.0" y="198"></rect>
   <text x="192.0" y="213">
\</text></g>
  <path d="M216.0 209h10"></path>
  <path d="M302.0 209h10"></path>
  <g data-type="non-terminal" data-updown="11 11">

   <path d="M226.0 209h0.0"></path>
   <path d="M302.0 209h0.0"></path>
   <rect height="22" width="76" x="226.0" y="198"></rect>
   <text x="264.0" y="213">
newline</text></g></g></g>
<g data-type="skip" data-updown="0 0">

 <path d="M138.0 228h204"></path></g></g></g>
<path d="M372.0 149h10"></path>
<path d="M410.0 149h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M382.0 149h0.0"></path>
<path d="M410.0 149h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="382.0" y="138"></rect>
<text x="396.0" y="153">
'</text></g></g></g>
<path d="M 440 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-url-token" class="railroad-diagram" height="110" viewBox="0 0 881 110" width="881">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M222 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M222.0 41h0.0"></path>
<rect height="22" width="172" x="50.0" y="30"></rect>
<text x="136.0" y="45">
&lt;ident-token "url"></text></g>
<path d="M232 41h10"></path>
<path d="M270 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M242 41h0.0"></path>
<path d="M270.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="242.0" y="30"></rect>
<text x="256.0" y="45">
(</text></g>
<path d="M280 41h10"></path>
<path d="M334 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M290 41h0.0"></path>
<path d="M334.0 41h0.0"></path>
<rect height="22" width="44" x="290.0" y="30"></rect>
<text x="312.0" y="45">
ws*</text></g>
<g data-type="choice" data-updown="21 49">
<path d="M344 41h0.0"></path>
<path d="M728.0 41h0.0"></path>
<path d="M344.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M708.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M364.0 21h344"></path></g>
<path d="M344.0 41h20"></path>
<path d="M708.0 41h20"></path>
<g data-type="oneormore" data-updown="11 49">
<path d="M364.0 41h0.0"></path>
<path d="M708.0 41h0.0"></path>
<path d="M364.0 41h10"></path>
<path d="M698.0 41h10"></path>
<path d="M374.0 41a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<path d="M698.0 90a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="11 41">
<path d="M374.0 41h0.0"></path>
<path d="M698.0 41h0.0"></path>
<path d="M374.0 41h20"></path>
<path d="M678.0 41h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M394.0 41h0.0"></path>
<path d="M678.0 41h0.0"></path>
<rect height="22" width="284" x="394.0" y="30"></rect>
<text x="536.0" y="45">
not " ' ( ) \ ws or non-printable</text></g>
<path d="M374.0 41a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M678.0 71a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M394.0 71h108.0"></path>
<path d="M570.0 71h108.0"></path>
<rect height="22" width="68" x="502.0" y="60"></rect>
<text x="536.0" y="75">
escape</text></g></g>
<g data-type="skip" data-updown="0 0">
<path d="M374.0 90h324"></path></g></g></g>
<path d="M728 41h10"></path>
<path d="M782 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M738 41h0.0"></path>
<path d="M782.0 41h0.0"></path>
<rect height="22" width="44" x="738.0" y="30"></rect>
<text x="760.0" y="45">
ws*</text></g>
<path d="M792 41h10"></path>
<path d="M830 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M802 41h0.0"></path>
<path d="M830.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="802.0" y="30"></rect>
<text x="816.0" y="45">
)</text></g>
<path d="M 840 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-number-token" class="railroad-diagram" height="179" viewBox="0 0 713 179" width="713">

<g transform="translate(.5 .5)">
<path d="M 20 50 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="40 40">
<path d="M40 60h0.0"></path>
<path d="M108.0 60h0.0"></path>
<path d="M40.0 60a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M88.0 40a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 40h0.0"></path>
<path d="M88.0 40h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="60.0" y="29"></rect>
<text x="74.0" y="44">
+</text></g>
<path d="M40.0 60h20"></path>
<path d="M88.0 60h20"></path>
<g data-type="skip" data-updown="0 0">
<path d="M60.0 60h28"></path></g>
<path d="M40.0 60a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M88.0 80a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M60.0 80h0.0"></path>
<path d="M88.0 80h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="60.0" y="69"></rect>
<text x="74.0" y="84">
-</text></g></g>
<g data-type="choice" data-updown="11 98">
<path d="M108 60h0.0"></path>
<path d="M396.0 60h0.0"></path>
<path d="M108.0 60h20"></path>
<path d="M376.0 60h20"></path>
<g data-type="sequence" data-updown="11 20">
<path d="M128.0 60h0.0"></path>
<path d="M376.0 60h0.0"></path>
<path d="M128.0 60h10"></path>
<path d="M218.0 60h10"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M138.0 60h0.0"></path>
<path d="M218.0 60h0.0"></path>
<path d="M138.0 60h10"></path>
<path d="M208.0 60h10"></path>
<path d="M148.0 60a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M208.0 80a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M148.0 60h0.0"></path>
<path d="M208.0 60h0.0"></path>
<rect height="22" width="60" x="148.0" y="49"></rect>
<text x="178.0" y="64">
digit</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M148.0 80h60"></path></g></g>
<path d="M228.0 60h10"></path>
<path d="M266.0 60h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M238.0 60h0.0"></path>
<path d="M266.0 60h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="238.0" y="49"></rect>
<text x="252.0" y="64">
.</text></g>
<path d="M276.0 60h10"></path>
<path d="M366.0 60h10"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M286.0 60h0.0"></path>
<path d="M366.0 60h0.0"></path>
<path d="M286.0 60h10"></path>
<path d="M356.0 60h10"></path>
<path d="M296.0 60a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M356.0 80a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M296.0 60h0.0"></path>
<path d="M356.0 60h0.0"></path>
<rect height="22" width="60" x="296.0" y="49"></rect>
<text x="326.0" y="64">
digit</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M296.0 80h60"></path></g></g></g>
<path d="M108.0 60a10 10 0 0 1 10 10v19a10 10 0 0 0 10 10"></path>
<path d="M376.0 99a10 10 0 0 0 10 -10v-19a10 10 0 0 1 10 -10"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M128.0 99h84.0"></path>
<path d="M292.0 99h84.0"></path>
<path d="M212.0 99h10"></path>
<path d="M282.0 99h10"></path>
<path d="M222.0 99a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M282.0 119a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M222.0 99h0.0"></path>
<path d="M282.0 99h0.0"></path>
<rect height="22" width="60" x="222.0" y="88"></rect>
<text x="252.0" y="103">
digit</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M222.0 119h60"></path></g></g>
<path d="M108.0 60a10 10 0 0 1 10 10v58a10 10 0 0 0 10 10"></path>
<path d="M376.0 138a10 10 0 0 0 10 -10v-58a10 10 0 0 1 10 -10"></path>
<g data-type="sequence" data-updown="11 20">
<path d="M128.0 138h50.0"></path>
<path d="M326.0 138h50.0"></path>
<path d="M178.0 138h10"></path>
<path d="M216.0 138h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M188.0 138h0.0"></path>
<path d="M216.0 138h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="188.0" y="127"></rect>
<text x="202.0" y="142">
.</text></g>
<path d="M226.0 138h10"></path>
<path d="M316.0 138h10"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M236.0 138h0.0"></path>
<path d="M316.0 138h0.0"></path>
<path d="M236.0 138h10"></path>
<path d="M306.0 138h10"></path>
<path d="M246.0 138a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M306.0 158a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M246.0 138h0.0"></path>
<path d="M306.0 138h0.0"></path>
<rect height="22" width="60" x="246.0" y="127"></rect>
<text x="276.0" y="142">
digit</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M246.0 158h60"></path></g></g></g></g>
<g data-type="choice" data-updown="10 99">
<path d="M396 60h0.0"></path>
<path d="M672.0 60h0.0"></path>
<path d="M396.0 60h20"></path>
<path d="M652.0 60h20"></path>
<g data-type="skip" data-updown="0 0">
<path d="M416.0 60h236"></path></g>
<path d="M396.0 60a10 10 0 0 1 10 10v28a10 10 0 0 0 10 10"></path>
<path d="M652.0 108a10 10 0 0 0 10 -10v-28a10 10 0 0 1 10 -10"></path>
<g data-type="sequence" data-updown="40 41">
<path d="M416.0 108h0.0"></path>
<path d="M652.0 108h0.0"></path>
<g data-type="choice" data-updown="11 41">
<path d="M416.0 108h0.0"></path>
<path d="M484.0 108h0.0"></path>
<path d="M416.0 108h20"></path>
<path d="M464.0 108h20"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M436.0 108h0.0"></path>
<path d="M464.0 108h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="436.0" y="97"></rect>
<text x="450.0" y="112">
e</text></g>
<path d="M416.0 108a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M464.0 138a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M436.0 138h0.0"></path>
<path d="M464.0 138h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="436.0" y="127"></rect>
<text x="450.0" y="142">
E</text></g></g>
<g data-type="choice" data-updown="40 40">
<path d="M484.0 108h0.0"></path>
<path d="M552.0 108h0.0"></path>
<path d="M484.0 108a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M532.0 88a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M504.0 88h0.0"></path>
<path d="M532.0 88h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="504.0" y="77"></rect>
<text x="518.0" y="92">
+</text></g>
<path d="M484.0 108h20"></path>
<path d="M532.0 108h20"></path>
<g data-type="skip" data-updown="0 0">
<path d="M504.0 108h28"></path></g>
<path d="M484.0 108a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M532.0 128a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M504.0 128h0.0"></path>
<path d="M532.0 128h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="504.0" y="117"></rect>
<text x="518.0" y="132">
-</text></g></g>
<path d="M552.0 108h10"></path>
<path d="M642.0 108h10"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M562.0 108h0.0"></path>
<path d="M642.0 108h0.0"></path>
<path d="M562.0 108h10"></path>
<path d="M632.0 108h10"></path>
<path d="M572.0 108a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M632.0 128a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M572.0 108h0.0"></path>
<path d="M632.0 108h0.0"></path>
<rect height="22" width="60" x="572.0" y="97"></rect>
<text x="602.0" y="112">
digit</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M572.0 128h60"></path></g></g></g></g>
<path d="M 672 60 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-dimension-token" class="railroad-diagram" height="62" viewBox="0 0 377 62" width="377">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M182 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M182.0 31h0.0"></path>
<rect height="22" width="132" x="50.0" y="20"></rect>
<text x="116.0" y="35">
&lt;number-token></text></g>
<path d="M192 31h10"></path>
<path d="M326 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M202 31h0.0"></path>
<path d="M326.0 31h0.0"></path>
<rect height="22" width="124" x="202.0" y="20"></rect>
<text x="264.0" y="35">
&lt;ident-token></text></g>
<path d="M 336 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-percentage-token" class="railroad-diagram" height="62" viewBox="0 0 281 62" width="281">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M182 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M182.0 31h0.0"></path>
<rect height="22" width="132" x="50.0" y="20"></rect>
<text x="116.0" y="35">
&lt;number-token></text></g>
<path d="M192 31h10"></path>
<path d="M230 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M202 31h0.0"></path>
<path d="M230.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="202.0" y="20"></rect>
<text x="216.0" y="35">
%</text></g>
<path d="M 240 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-include-match" class="railroad-diagram" height="62" viewBox="0 0 137 62" width="137">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M86 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M86.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="20"></rect>
<text x="68.0" y="35">
~=</text></g>
<path d="M 96 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>

<svg id="_dgm-dash-match-token" class="railroad-diagram" height="62" viewBox="0 0 137 62" width="137">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M86 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M86.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="20"></rect>
<text x="68.0" y="35">
|=</text></g>
<path d="M 96 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-prefix-match-token" class="railroad-diagram" height="62" viewBox="0 0 137 62" width="137">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M86 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M86.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="20"></rect>
<text x="68.0" y="35">
^=</text></g>
<path d="M 96 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-suffix-match-token" class="railroad-diagram" height="62" viewBox="0 0 137 62" width="137">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M86 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M86.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="20"></rect>
<text x="68.0" y="35">
$=</text></g>
<path d="M 96 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-substring-match-token" class="railroad-diagram" height="62" viewBox="0 0 137 62" width="137">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M86 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M86.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="20"></rect>
<text x="68.0" y="35">
*=</text></g>
<path d="M 96 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-column-token-diagram" class="railroad-diagram" height="62" viewBox="0 0 137 62" width="137">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M86 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M86.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50.0" y="20"></rect>
<text x="68.0" y="35">
||</text></g>
<path d="M 96 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-CDO-token-diagram" class="railroad-diagram" height="62" viewBox="0 0 153 62" width="153">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M102 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M102.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="52" x="50.0" y="20"></rect>
<text x="76.0" y="35">
&lt;!--</text></g>
<path d="M 112 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-CDC-token-diagram" class="railroad-diagram" height="62" viewBox="0 0 145 62" width="145">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M94 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M94.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="44" x="50.0" y="20"></rect>
<text x="72.0" y="35">
--></text></g>
<path d="M 104 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>



<svg id="_dgm-stylesheet-diagram" class="railroad-diagram" height="200" viewBox="0 0 345 200" width="345">

<g transform="translate(.5 .5)">
<path d="M 20 121 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="111 49">
<path d="M40 131h0.0"></path>
<path d="M304.0 131h0.0"></path>
<path d="M40.0 131a10 10 0 0 0 10 -10v-89a10 10 0 0 1 10 -10"></path>
<path d="M284.0 22a10 10 0 0 1 10 10v89a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M60.0 22h224"></path></g>
<path d="M40.0 131h20"></path>
<path d="M284.0 131h20"></path>
<g data-type="oneormore" data-updown="101 49">
<path d="M60.0 131h0.0"></path>
<path d="M284.0 131h0.0"></path>
<path d="M60.0 131h10"></path>
<path d="M274.0 131h10"></path>
<path d="M70.0 131a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<path d="M274.0 180a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="101 41">
<path d="M70.0 131h0.0"></path>
<path d="M274.0 131h0.0"></path>
<path d="M70.0 131a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M254.0 101a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 101h0.0"></path>
<path d="M254.0 101h0.0"></path>
<rect height="22" width="164" x="90.0" y="90"></rect>
<text x="172.0" y="105">
&lt;whitespace-token></text></g>
<path d="M70.0 131a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<path d="M254.0 71a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 71h28.0"></path>
<path d="M226.0 71h28.0"></path>
<rect height="22" width="108" x="118.0" y="60"></rect>
<text x="172.0" y="75">
&lt;CDC-token></text></g>
<path d="M70.0 131a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
<path d="M254.0 41a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 41h28.0"></path>
<path d="M226.0 41h28.0"></path>
<rect height="22" width="108" x="118.0" y="30"></rect>
<text x="172.0" y="45">
&lt;CDO-token></text></g>
<path d="M70.0 131h20"></path>
<path d="M254.0 131h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 131h16.0"></path>
<path d="M238.0 131h16.0"></path>
<rect height="22" width="132" x="106.0" y="120"></rect>
<text x="172.0" y="135">
Qualified rule</text></g>
<path d="M70.0 131a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M254.0 161a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 161h44.0"></path>
<path d="M210.0 161h44.0"></path>
<rect height="22" width="76" x="134.0" y="150"></rect>
<text x="172.0" y="165">
At-rule</text></g></g>
<g data-type="skip" data-updown="0 0">
<path d="M70.0 180h204"></path></g></g></g>
<path d="M 304 131 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-rule-list" class="railroad-diagram" height="140" viewBox="0 0 345 140" width="345">

<g transform="translate(.5 .5)">
<path d="M 20 61 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="51 49">
<path d="M40 71h0.0"></path>
<path d="M304.0 71h0.0"></path>
<path d="M40.0 71a10 10 0 0 0 10 -10v-29a10 10 0 0 1 10 -10"></path>
<path d="M284.0 22a10 10 0 0 1 10 10v29a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M60.0 22h224"></path></g>
<path d="M40.0 71h20"></path>
<path d="M284.0 71h20"></path>
<g data-type="oneormore" data-updown="41 49">
<path d="M60.0 71h0.0"></path>
<path d="M284.0 71h0.0"></path>
<path d="M60.0 71h10"></path>
<path d="M274.0 71h10"></path>
<path d="M70.0 71a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<path d="M274.0 120a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
<g data-type="choice" data-updown="41 41">
<path d="M70.0 71h0.0"></path>
<path d="M274.0 71h0.0"></path>
<path d="M70.0 71a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M254.0 41a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 41h0.0"></path>
<path d="M254.0 41h0.0"></path>
<rect height="22" width="164" x="90.0" y="30"></rect>
<text x="172.0" y="45">
&lt;whitespace-token></text></g>
<path d="M70.0 71h20"></path>
<path d="M254.0 71h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 71h16.0"></path>
<path d="M238.0 71h16.0"></path>
<rect height="22" width="132" x="106.0" y="60"></rect>
<text x="172.0" y="75">
Qualified rule</text></g>
<path d="M70.0 71a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M254.0 101a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M90.0 101h44.0"></path>
<path d="M210.0 101h44.0"></path>
<rect height="22" width="76" x="134.0" y="90"></rect>
<text x="172.0" y="105">
At-rule</text></g></g>
<g data-type="skip" data-updown="0 0">
<path d="M70.0 120h204"></path></g></g></g>
<path d="M 304 71 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-at-rule-diagram" class="railroad-diagram" height="102" viewBox="0 0 589 102" width="589">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M214 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M214.0 41h0.0"></path>
<rect height="22" width="164" x="50.0" y="30"></rect>
<text x="132.0" y="45">
&lt;at-keyword-token></text></g>
<g data-type="choice" data-updown="21 20">
<path d="M224 41h0.0"></path>
<path d="M424.0 41h0.0"></path>
<path d="M224.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M404.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M244.0 21h160"></path></g>
<path d="M224.0 41h20"></path>
<path d="M404.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M244.0 41h0.0"></path>
<path d="M404.0 41h0.0"></path>
<path d="M244.0 41h10"></path>
<path d="M394.0 41h10"></path>
<path d="M254.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M394.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M254.0 41h0.0"></path>
<path d="M394.0 41h0.0"></path>
<rect height="22" width="140" x="254.0" y="30"></rect>
<text x="324.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M254.0 61h140"></path></g></g></g>
<g data-type="choice" data-updown="11 41">
<path d="M424 41h0.0"></path>
<path d="M548.0 41h0.0"></path>
<path d="M424.0 41h20"></path>
<path d="M528.0 41h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M444.0 41h0.0"></path>
<path d="M528.0 41h0.0"></path>
<rect height="22" width="84" x="444.0" y="30"></rect>
<text x="486.0" y="45">
{} block</text></g>
<path d="M424.0 41a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M528.0 71a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M444.0 71h28.0"></path>
<path d="M500.0 71h28.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="472.0" y="60"></rect>
<text x="486.0" y="75">
;</text></g></g>
<path d="M 548 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-qualified-rule-diagram" class="railroad-diagram" height="81" viewBox="0 0 385 81" width="385">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="21 20">
<path d="M40 41h0.0"></path>
<path d="M240.0 41h0.0"></path>
<path d="M40.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M220.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M60.0 21h160"></path></g>
<path d="M40.0 41h20"></path>
<path d="M220.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M60.0 41h0.0"></path>
<path d="M220.0 41h0.0"></path>
<path d="M60.0 41h10"></path>
<path d="M210.0 41h10"></path>
<path d="M70.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M210.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M70.0 41h0.0"></path>
<path d="M210.0 41h0.0"></path>
<rect height="22" width="140" x="70.0" y="30"></rect>
<text x="140.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M70.0 61h140"></path></g></g></g>
<path d="M240 41h10"></path>
<path d="M334 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M250 41h0.0"></path>
<path d="M334.0 41h0.0"></path>
<rect height="22" width="84" x="250.0" y="30"></rect>
<text x="292.0" y="45">
{} block</text></g>
<path d="M 344 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-declaration-list" class="railroad-diagram" height="102" viewBox="0 0 589 102" width="589">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M94 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M94.0 41h0.0"></path>
<rect height="22" width="44" x="50.0" y="30"></rect>
<text x="72.0" y="45">
ws*</text></g>
<g data-type="choice" data-updown="21 41">
<path d="M104 41h0.0"></path>
<path d="M548.0 41h0.0"></path>
<path d="M104.0 41h20"></path>
<path d="M528.0 41h20"></path>
<g data-type="sequence" data-updown="21 11">
<path d="M124.0 41h0.0"></path>
<path d="M528.0 41h0.0"></path>
<g data-type="choice" data-updown="21 11">
<path d="M124.0 41h0.0"></path>
<path d="M272.0 41h0.0"></path>
<path d="M124.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M252.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M144.0 21h108"></path></g>
<path d="M124.0 41h20"></path>
<path d="M252.0 41h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M144.0 41h0.0"></path>
<path d="M252.0 41h0.0"></path>
<rect height="22" width="108" x="144.0" y="30"></rect>
<text x="198.0" y="45">
Declaration</text></g></g>
<g data-type="choice" data-updown="21 11">
<path d="M272.0 41h0.0"></path>
<path d="M528.0 41h0.0"></path>
<path d="M272.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M508.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M292.0 21h216"></path></g>
<path d="M272.0 41h20"></path>
<path d="M508.0 41h20"></path>
<g data-type="sequence" data-updown="11 11">
<path d="M292.0 41h0.0"></path>
<path d="M508.0 41h0.0"></path>
<path d="M292.0 41h10"></path>
<path d="M330.0 41h10"></path>
<g data-type="terminal" data-updown="11 11">

 <path d="M302.0 41h0.0"></path>
 <path d="M330.0 41h0.0"></path>
 <rect height="22" rx="10" ry="10" width="28" x="302.0" y="30"></rect>
 <text x="316.0" y="45">
;</text></g>
<path d="M340.0 41h10"></path>
<path d="M498.0 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">

 <path d="M350.0 41h0.0"></path>
 <path d="M498.0 41h0.0"></path>
 <rect height="22" width="148" x="350.0" y="30"></rect>
 <text x="424.0" y="45">
Declaration list</text></g></g></g></g>
<path d="M104.0 41a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M528.0 71a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="sequence" data-updown="11 11">
<path d="M124.0 71h70.0"></path>
<path d="M458.0 71h70.0"></path>
<path d="M194.0 71h10"></path>
<path d="M280.0 71h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M204.0 71h0.0"></path>
<path d="M280.0 71h0.0"></path>
<rect height="22" width="76" x="204.0" y="60"></rect>
<text x="242.0" y="75">
At-rule</text></g>
<path d="M290.0 71h10"></path>
<path d="M448.0 71h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M300.0 71h0.0"></path>
<path d="M448.0 71h0.0"></path>
<rect height="22" width="148" x="300.0" y="60"></rect>
<text x="374.0" y="75">
Declaration list</text></g></g></g>
<path d="M 548 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-declaration" class="railroad-diagram" height="101" viewBox="0 0 677 101" width="677">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M174 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M174.0 41h0.0"></path>
<rect height="22" width="124" x="50.0" y="30"></rect>
<text x="112.0" y="45">
&lt;ident-token></text></g>
<path d="M184 41h10"></path>
<path d="M238 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M194 41h0.0"></path>
<path d="M238.0 41h0.0"></path>
<rect height="22" width="44" x="194.0" y="30"></rect>
<text x="216.0" y="45">
ws*</text></g>
<path d="M248 41h10"></path>
<path d="M286 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M258 41h0.0"></path>
<path d="M286.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="258.0" y="30"></rect>
<text x="272.0" y="45">
:</text></g>
<g data-type="choice" data-updown="21 20">
<path d="M296 41h0.0"></path>
<path d="M496.0 41h0.0"></path>
<path d="M296.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M476.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M316.0 21h160"></path></g>
<path d="M296.0 41h20"></path>
<path d="M476.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M316.0 41h0.0"></path>
<path d="M476.0 41h0.0"></path>
<path d="M316.0 41h10"></path>
<path d="M466.0 41h10"></path>
<path d="M326.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M466.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M326.0 41h0.0"></path>
<path d="M466.0 41h0.0"></path>
<rect height="22" width="140" x="326.0" y="30"></rect>
<text x="396.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M326.0 61h140"></path></g></g></g>
<g data-type="choice" data-updown="10 40">
<path d="M496 41h0.0"></path>
<path d="M636.0 41h0.0"></path>
<path d="M496.0 41h20"></path>
<path d="M616.0 41h20"></path>
<g data-type="skip" data-updown="0 0">
<path d="M516.0 41h100"></path></g>
<path d="M496.0 41a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M616.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M516.0 61h0.0"></path>
<path d="M616.0 61h0.0"></path>
<rect height="22" width="100" x="516.0" y="50"></rect>
<text x="566.0" y="65">
!important</text></g></g>
<path d="M 636 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-important" class="railroad-diagram" height="62" viewBox="0 0 497 62" width="497">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 31h10"></path>
<path d="M78 31h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 31h0.0"></path>
<path d="M78.0 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="20"></rect>
<text x="64.0" y="35">
!</text></g>
<path d="M88 31h10"></path>
<path d="M142 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M98 31h0.0"></path>
<path d="M142.0 31h0.0"></path>
<rect height="22" width="44" x="98.0" y="20"></rect>
<text x="120.0" y="35">
ws*</text></g>
<path d="M152 31h10"></path>
<path d="M382 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M162 31h0.0"></path>
<path d="M382.0 31h0.0"></path>
<rect height="22" width="220" x="162.0" y="20"></rect>
<text x="272.0" y="35">
&lt;ident-token "important"></text></g>
<path d="M392 31h10"></path>
<path d="M446 31h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M402 31h0.0"></path>
<path d="M446.0 31h0.0"></path>
<rect height="22" width="44" x="402.0" y="20"></rect>
<text x="424.0" y="35">
ws*</text></g>
<path d="M 456 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-component-value" class="railroad-diagram" height="182" viewBox="0 0 261 182" width="261">

<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<g data-type="choice" data-updown="11 131">
<path d="M40 31h0.0"></path>
<path d="M220.0 31h0.0"></path>
<path d="M40.0 31h20"></path>
<path d="M200.0 31h20"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 31h0.0"></path>
<path d="M200.0 31h0.0"></path>
<rect height="22" width="140" x="60.0" y="20"></rect>
<text x="130.0" y="35">
Preserved token</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M200.0 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 61h28.0"></path>
<path d="M172.0 61h28.0"></path>
<rect height="22" width="84" x="88.0" y="50"></rect>
<text x="130.0" y="65">
{} block</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<path d="M200.0 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 91h28.0"></path>
<path d="M172.0 91h28.0"></path>
<rect height="22" width="84" x="88.0" y="80"></rect>
<text x="130.0" y="95">
() block</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
<path d="M200.0 121a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 121h28.0"></path>
<path d="M172.0 121h28.0"></path>
<rect height="22" width="84" x="88.0" y="110"></rect>
<text x="130.0" y="125">
[] block</text></g>
<path d="M40.0 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
<path d="M200.0 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M60.0 151h4.0"></path>
<path d="M196.0 151h4.0"></path>
<rect height="22" width="132" x="64.0" y="140"></rect>
<text x="130.0" y="155">
Function block</text></g></g>
<path d="M 220 31 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-curly-block" class="railroad-diagram" height="81" viewBox="0 0 377 81" width="377">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M78 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M78.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="30"></rect>
<text x="64.0" y="45">
{</text></g>
<g data-type="choice" data-updown="21 20">
<path d="M88 41h0.0"></path>
<path d="M288.0 41h0.0"></path>
<path d="M88.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M268.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M108.0 21h160"></path></g>
<path d="M88.0 41h20"></path>
<path d="M268.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M108.0 41h0.0"></path>
<path d="M268.0 41h0.0"></path>
<path d="M108.0 41h10"></path>
<path d="M258.0 41h10"></path>
<path d="M118.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M258.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M118.0 41h0.0"></path>
<path d="M258.0 41h0.0"></path>
<rect height="22" width="140" x="118.0" y="30"></rect>
<text x="188.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M118.0 61h140"></path></g></g></g>
<path d="M288 41h10"></path>
<path d="M326 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M298 41h0.0"></path>
<path d="M326.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="298.0" y="30"></rect>
<text x="312.0" y="45">
}</text></g>
<path d="M 336 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-paren-block" class="railroad-diagram" height="81" viewBox="0 0 377 81" width="377">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M78 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M78.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="30"></rect>
<text x="64.0" y="45">
(</text></g>
<g data-type="choice" data-updown="21 20">
<path d="M88 41h0.0"></path>
<path d="M288.0 41h0.0"></path>
<path d="M88.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M268.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M108.0 21h160"></path></g>
<path d="M88.0 41h20"></path>
<path d="M268.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M108.0 41h0.0"></path>
<path d="M268.0 41h0.0"></path>
<path d="M108.0 41h10"></path>
<path d="M258.0 41h10"></path>
<path d="M118.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M258.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M118.0 41h0.0"></path>
<path d="M258.0 41h0.0"></path>
<rect height="22" width="140" x="118.0" y="30"></rect>
<text x="188.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M118.0 61h140"></path></g></g></g>
<path d="M288 41h10"></path>
<path d="M326 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M298 41h0.0"></path>
<path d="M326.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="298.0" y="30"></rect>
<text x="312.0" y="45">
)</text></g>
<path d="M 336 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-square-block" class="railroad-diagram" height="81" viewBox="0 0 377 81" width="377">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M78 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M78.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50.0" y="30"></rect>
<text x="64.0" y="45">
[</text></g>
<g data-type="choice" data-updown="21 20">
<path d="M88 41h0.0"></path>
<path d="M288.0 41h0.0"></path>
<path d="M88.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M268.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M108.0 21h160"></path></g>
<path d="M88.0 41h20"></path>
<path d="M268.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M108.0 41h0.0"></path>
<path d="M268.0 41h0.0"></path>
<path d="M108.0 41h10"></path>
<path d="M258.0 41h10"></path>
<path d="M118.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M258.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M118.0 41h0.0"></path>
<path d="M258.0 41h0.0"></path>
<rect height="22" width="140" x="118.0" y="30"></rect>
<text x="188.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M118.0 61h140"></path></g></g></g>
<path d="M288 41h10"></path>
<path d="M326 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M298 41h0.0"></path>
<path d="M326.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="298.0" y="30"></rect>
<text x="312.0" y="45">
]</text></g>
<path d="M 336 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>


<svg id="_dgm-function-block" class="railroad-diagram" height="81" viewBox="0 0 497 81" width="497">

<g transform="translate(.5 .5)">
<path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5" data-type="start" data-updown="10 10"></path>
<path d="M40 41h10"></path>
<path d="M198 41h10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M50 41h0.0"></path>
<path d="M198.0 41h0.0"></path>
<rect height="22" width="148" x="50.0" y="30"></rect>
<text x="124.0" y="45">
&lt;function-token></text></g>
<g data-type="choice" data-updown="21 20">
<path d="M208 41h0.0"></path>
<path d="M408.0 41h0.0"></path>
<path d="M208.0 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<path d="M388.0 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g data-type="skip" data-updown="0 0">
<path d="M228.0 21h160"></path></g>
<path d="M208.0 41h20"></path>
<path d="M388.0 41h20"></path>
<g data-type="oneormore" data-updown="11 20">
<path d="M228.0 41h0.0"></path>
<path d="M388.0 41h0.0"></path>
<path d="M228.0 41h10"></path>
<path d="M378.0 41h10"></path>
<path d="M238.0 41a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<path d="M378.0 61a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
<g data-type="non-terminal" data-updown="11 11">
<path d="M238.0 41h0.0"></path>
<path d="M378.0 41h0.0"></path>
<rect height="22" width="140" x="238.0" y="30"></rect>
<text x="308.0" y="45">
Component value</text></g>
<g data-type="skip" data-updown="0 0">
<path d="M238.0 61h140"></path></g></g></g>
<path d="M408 41h10"></path>
<path d="M446 41h10"></path>
<g data-type="terminal" data-updown="11 11">
<path d="M418 41h0.0"></path>
<path d="M446.0 41h0.0"></path>
<rect height="22" rx="10" ry="10" width="28" x="418.0" y="30"></rect>
<text x="432.0" y="45">
)</text></g>
<path d="M 456 41 h 20 m -10 -10 v 20 m 10 -20 v 20" data-type="end" data-updown="10 10"></path></g>
</svg>

	</div>
</div>


<aside class="trans-meta">
<h1>CSS Syntax Module Level 3 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により，副題の日付にて<strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">CSS Syntax Module Level 3</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p>
更新：<time>2016-05-25</time>
（公開：<time>2013-12-14</time> ）
</p>

<p>
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<div><a href="http://www.w3.org/" id="_W3C">W3C</a></div>

<h1 id="title">CSS の構文 — CSS Syntax Module Level 3</h1>
<h2 id="subtitle">2016 年 5 月 24 日付 編集者草案</h2>

<dl id="_versions">
	<dt title="This version:">このバージョン</dt>
	<dd>https://drafts.csswg.org/css-syntax/</dd>

	<dt title="Latest published version:">最新発行バージョン</dt>
	<dd>http://www.w3.org/TR/css-syntax-3/</dd>

	<dt title="Previous Versions:">以前のバージョン</dt>
	<dd>http://www.w3.org/TR/2014/CR-css-syntax-3-20140220/<dd>
	<dd>http://www.w3.org/TR/2013/WD-css-syntax-3-20131105/</dd>
	<dd>http://www.w3.org/TR/2013/WD-css-syntax-3-20130919/</dd>

	<dt title="Test Suite:">テスト一式</dt>
	<dd>http://test.csswg.org/suites/css-syntax-3_dev/nightly-unstable/</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/csswg-drafts/issues/">GitHub</a></dd>

	<dt title="Editors:">編集</dt>
	<dd><a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)</dd>
	<dd><a href="http://exyr.org/about/">Simon Sapin</a> (Mozilla)</dd>

</dl>

<small class="copyright"><a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
</small>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p class="p-summary">
この~moduleは、 CSS ~stylesheetの基本的な構造と構文を一般的な用語により述べるものである。
それは、 CSS の構文と構文解析法
— ~byte~streamを意味のある~stylesheetに転化する方法 —
を詳細に定義する。
<a href="http://www.w3.org/TR/CSS/">CSS</a>
は、（ HTML や XML などの）構造を備える文書から，
~screen, 紙, ~speech, 等々
の媒体への具現化法を記述するための言語である。
◎
This module describes, in general terms, the basic structure and syntax of CSS stylesheets. It defines, in detail, the syntax and parsing of CSS - how to turn a stream of bytes into a meaningful stylesheet. CSS is a language for describing the rendering of structured documents (such as HTML and XML) on screen, on paper, in speech, etc.
</p>


	</section>
	<section id="status">

<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下，この節の内容は
<a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>

	</section>

<nav class="toc" id="contents">
<h2 class="toc">目次</h2>
<ol id="_toc_list0"></ol></nav>


<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 概要</h2>

~INFORMATIVE

<p>
この~moduleは、~CSS~stylesheetの［
抽象~構文と構文解析法
］を定義し, 
~CSS構文を利用する他のもの（ HTML `style^c 属性など）を定義する。
◎
This module defines the abstract syntax and parsing of CSS stylesheets and other things which use CSS syntax (such as the HTML style attribute).
</p>

<p>
これは、［
Unicode `符号位置$の~stream（言い換えれば, ~text）
］から，［
~CSS~tokenの~stream
］へ変換するための一連の~algo，および［
その結果の~streamから更に［
~stylesheet, 規則, 宣言
］などからなる，いくつかの~CSS~objectへ変換する
］ための一連の~algoを定義する。
◎
It defines algorithms for converting a stream of Unicode code points (in other words, text) into a stream of CSS tokens, and then further into CSS objects such as stylesheets, rules, and declarations.
</p>

		<section id="placement">
<h3 title="Module interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、~CSS~stylesheetの［
構文と構文解析法
］を定義する。
それは，~CSS 2.1 にて定義される［
字句走査器と文法
］に取って代わる。
◎
This module defines the syntax and parsing of CSS stylesheets. It supersedes the lexical scanner and grammar defined in CSS 2.1.
</p>
		</section>
	</section>


	<section id="_conventions">
<h3 class="trans-note">【日本語訳に固有の表記規約】</h3>

<p>
この訳では，~algoや定義の記述に次の記号を用いる：
</p>

<div style="margin:1em 0 1em 2em; white-space:pre-line;"
>~LET （初期化-）, ~SET （代入）, ~EQ, ~NEQ （比較）,
~ON, ~OFF （~flag値）,
~LT, ~LTE, ~GT, ~GTE （大小比較）,
〜 （~~範囲）, { <var>…</var> } （集合）, ~IN （集合への所属）,
~IF, ~ELSE, ~ELIF, ~RET （実行制御）</div>

<!-- 
~CONTINUE
~FOR ~EACH (…)
-->

<p>
これらの意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照。
</p>

<p>
加えて、次の記法も用いる：
</p>

<table border>
	<thead><tr><th style="min-width: 10em;">記法</th><th >意味</th></tr></thead>

	<tbody>
<tr><th>`s^V ~APPEND `a^V ~APPEND `b^V ~APPEND …</th><td>
左辺の文字列 `s^V の末尾に後続の文字列 `a^V, `b^V, … を示された順に~~付加する演算を表す。
式として用いられた場合、結果の `s^V がその値になる。
</td></tr>

<tr><th>~nothing</th><td>
値が~~存在しないことを意味する，他のいかなる値とも異なる特別な値。
主に、~algoの記述を 形式化／簡潔化 するために利用される。
</td></tr>

<tr><th>`A^V ~AEQ `B^V</th><td>
`A^V と `B^V が`~ASCII文字大小無視$で合致することを表す。
</td></tr>

<tr><th>.`名前^V</th><td>
ドットが付いた `名前^V は，その `名前^V がこの仕様の処理~modelにて生産される~objectが持つ［
名前が `名前^V である~~属性~DAGGER
］であることを明示するときに利用される（文脈から明らかな所では，このドット付き表記は利用されない）。
例えば “〜の.値” は、実際には，［
"<em>値</em>" という名前の~~属性
］の値を意味する。
（~DAGGER —
<small >この訳の中の各種~定義にしばしば現れる，この意味の “~~属性” という語は、訳の都合により導入したものであり，原文には無い非公式な用語である</small>）
</td></tr>


	</tbody>
</table>


	</section>


	<section id="syntax-description">
<h2 title="Description of CSS’s Syntax">2. ~CSSの構文の記述</h2>

~INFORMATIVE

<p>
~CSS文書は，いくつかの`~style規則$
— 文書~内の要素に~styleを適用する`有修飾~規則$, あるいは
~CSS文書のための特別な処理規則や値を定義する`~at-rule$ —
からなる連なりである。
◎
A CSS document is a series of style rules—which are qualified rules that apply styles to elements in a document—and at-rules—which define special processing rules or values for the CSS document.
</p>

<p>
`有修飾~規則$は，
<dfn>.導入部</dfn>
から開始され，宣言~並びを包含している
`波括弧~block$（ `{^c, `}^c で括られた~block）
が後続する。
.導入部の意味は、その規則が現れる文脈に基づいて変わり得る
— ~style規則に対しては、それは［
その宣言が適用されることになる要素の集合
］を指定する選択子である。
各~宣言は［
名前,
コロン,
宣言~値
］の並びで与えられる。
宣言と宣言は，セミコロンで互いに区切られる。
◎
A qualified rule starts with a prelude then has a {}-wrapped block containing a sequence of declarations. The meaning of the prelude varies based on the context that the rule appears in—for style rules, it’s a selector which specifies what elements the declarations will apply to. Each declaration has a name, followed by a colon and the declaration value. Declarations are separated by semicolons.
</p>

<div class="example">

<p>
典型的な規則は、次に様な形に見えるであろう：
◎
A typical rule might look something like this:
</p>

<pre>
p &gt; a {
  color: blue;
  text-decoration: underline;
}
</pre>


<p>
上の規則における
"`p &gt; a^css"
が選択子である。
~source文書が HTML であるならば、それは
`p^e 要素の子であるような，あらゆる `a^e 要素を選択する。
◎
In the above rule, "p &gt; a" is the selector, which, if the source document is HTML, selects any &lt;a&gt; elements that are children of a &lt;p&gt; element.
</p>

<p>
"`color: blue^css"
は、選択子に合致する要素に対し，それらの `color$p ~propが値 `blue^v を持つべきであることを指定している宣言である。
同様に、それらの `text-decoration$p ~propも，値 `underline$v を持つべきであることになる。
◎
"color: blue" is a declaration specifying that, for the elements that match the selector, their color property should have the value blue. Similarly, their text-decoration property should have the value underline.
</p>

</div>


<div class="p">
<p>
~at-ruleは、それぞれの種類ごとに異なるものだが，基本的な構造は共通している：
</p>

<ul>
	<li>
それらは、`符号位置$ "<code>@</code>" で開始され, CSS ~keywordとして名前が後続する。
</li>
	<li>
一部の`~at-rule$は、その名前に［
その挙動を指定する いくつかの~CSS値
］が後続し, セミコロンで終端する，単純文である。
</li>
	<li>
他の`~at-rule$は~blockである：
それらにも，その名前にいくつかの~CSS値が後続し得るが、`有修飾~規則$と同様に，波括弧~blockで終端する。
これらの~blockの内容は，与えられた`~at-rule$に特有のものであるが、それは
`有修飾~規則$の様に 宣言~並びを包含することもあれば，追加のいくつかの［
~blockや~at-rule
］, 更には［
他の構造
］を一緒に包含することもある。
</li>
</ul>

◎
At-rules are all different, but they have a basic structure in common. They start with an "@" code point followed by their name as a CSS keyword. Some at-rules are simple statements, with their name followed by more CSS values to specify their behavior, and finally ended by a semicolon. Others are blocks; they can have CSS values following their name, but they end with a {}-wrapped block, similar to a qualified rule. Even the contents of these blocks are specific to the given at-rule: sometimes they contain a sequence of declarations, like a qualified rule; other times, they may contain additional blocks, or at-rules, or other structures altogether.
</div>

<div class="example">

<p>
ここに、`~at-rule$が包含し得る種々の構文を解説する いくつかの例を示す：
◎
Here are several examples of at-rules that illustrate the varied syntax they may contain.
</p>

<pre>
@import "my-styles.css";</pre>


<p>
`import$at `~at-rule$は、単純文である。
それは，名前の後に［
~importすべき~stylesheetを指示する 単独の［
文字列, または
関数式 `url()^css
］］をとる。
◎
The @import at-rule is a simple statement. After its name, it takes a single string or url() function to indicate the stylesheet that it should import.
</p>

<pre>
@page :left {
  margin-left: 4cm;
  margin-right: 3cm;
}
</pre>


<p>
`page$at `~at-rule$は、［
頁~選択子（~optional, この例では `:left^css 疑似類）, ［
頁の印刷~時に適用される，一連の~propからなる~block
］］の並びである。
この様に、それは［
それらの~propが，どの “要素” にも適用されず, 頁それ自身に適用される
］ことを除いて、通常の~style規則と とてもよく似る。
◎
The @page at-rule consists of an optional page selector (the :left pseudoclass), followed by a block of properties that apply to the page when printed. In this way, it’s very similar to a normal style rule, except that its properties don’t apply to any "element", but rather the page itself.
</p>

<pre>
@media print {
  body { font-size: 10pt }
}
</pre>


<p>
`media$at `~at-rule$は、［
媒体~型,
媒体~query~list（~optional）
］の並びから始まる。
その~blockは，［
`media$at 条件が充足されるときにのみ適用される
］ような規則~全体を包含する。
◎
The @media at-rule begins with a media type and a list of optional media queries. Its block contains entire rules, which are only applied when the @medias conditions are fulfilled.
</p></div>

<p>
［
~prop ／ `~at-rule$
］の名前は、常に`識別子$であり，［
`英字$または［
ハイフン, `英字$
］の並び
］から開始されなければならず，［
`英字$,
`数字$,<!-- number -->
ハイフン,
アンダースコア
］を包含し得る。
また、`~escaping$により，任意の`符号位置$を含ませることもできる
— それが， ~CSSの構文に利用されるものであっても。
◎
Property names and at-rule names are always identifiers, which have to start with a letter or a hyphen followed by a letter, and then can contain letters, numbers, hyphens, or underscores. You can include any code point at all, even ones that CSS uses in its syntax, by escaping it.
</p>

<p>
選択子の構文は、 Selectors 仕様 `SELECT$r にて定義される。
同様に，多岐に渡る~CSS値の構文は、 `CSS-VALUES$r 仕様にて定義される。
個々の`~at-rule$の特別な構文は、それらを定義する仕様の中に見出せる。
◎
The syntax of selectors is defined in the Selectors spec. Similarly, the syntax of the wide variety of CSS values is defined in the Values &amp; Units spec. The special syntaxes of individual at-rules can be found in the specs that define them.
</p>

		<section id="escaping">
<h3 title="Escaping">2.1. ~escaping</h3>

~INFORMATIVE

<p>
`識別子$や, 引用符で括られた文字列には、
`~escaping@
により，任意の Unicode `符号位置$を含ませられる。
~CSS~escape-seqは、バックスラッシュ（ "`\^c" ）で開始され, 次のいずれかが後続する：
◎
Any Unicode code point can be included in an identifier or quoted string by escaping it. CSS escape sequences start with a backslash (\), and continue with:
</p>

<ul>
	<li>
`~hex$でも`改行$でもない，任意の［
Unicode  `符号位置$
］。
この~escape-seqは，その`符号位置$に置換される。
◎
Any Unicode code point that is not a hex digits or a newline. The escape sequence is replaced by that code point.
</li>

	<li>
<p>
［
［ 1 〜 6 個の`~hex$ ］,
`空白$（~optional）
］の並び。
この~escape-seqは，［
その~hexの並びが表す数を値とする Unicode `符号位置$
］に置換される。
~optionalの空白は、 16 進~escape-seqの直後に “実の” ~hexを続けられるようにするためのものである。
◎
Or one to six hex digits, followed by an optional whitespace. The escape sequence is replaced by the Unicode code point whose value is given by the hexadecimal digits. This optional whitespace allow hexadecimal escape sequences to be followed by "real" hex digits.
</p>

<p class="example">
例えば，.値に "`&amp;B^c" を伴う`識別子$は、［
`\26 B^css,
あるいは
`\000026B^css
］のように記し得る。
◎
An identifier with the value "&amp;B" could be written as \26 B or \000026B.
</p>

<p class="note">
~escape-seqの直後に “実の” スペースを続ける場合は，二重に記されなければならないことになる。
◎
A "real" space after the escape sequence must be doubled.
</p>

	</li>
</ul>



		</section>
		<section id="error-handling">
<h3 title="Error Handling">2.2. ~errorの取扱い</h3>

~INFORMATIVE

<p>
~CSS において~errorが生じたときには、構文解析器は，通常の構文解析処理に戻る前に［
最小限の内容のみを投棄して，“上品に” 回復する
］ことを試みる。
これは、~errorが必ずしも誤用によるものとは限らないからである
—
新たな構文は，古い構文解析器からは~errorに見えるので、［
それを含ませた~stylesheetが，古い~UAにおいて完全に壊れる
］ことを心配せずに［
言語に新たな構文を追加できる
］ことが有用になる。
◎
When errors occur in CSS, the parser attempts to recover gracefully, throwing away only the minimum amount of content before returning to parsing as normal. This is because errors aren’t always mistakes—new syntax looks like an error to an old parser, and it’s useful to be able to add new syntax to the language without worrying about stylesheets that include it being completely broken in older UAs.
</p>

<p>
~error回復の精確な挙動については、構文解析器それ自身の中で 詳細に述べられているが、短い記述でも，それなりの~~正確さをもって十分に述べ得る：
◎
The precise error-recovery behavior is detailed in the parser itself, but it’s simple enough that a short description is fairly accurate.
</p>

<ul>
	<li>
~stylesheetの “~top-level” においては、
`at-keyword$tok が，`~at-rule$を開始させる。
他のものは どれも，`有修飾~規則$を開始させ、その規則の.導入部の中に含められる。
これは，無効な選択子も生産し得るが、それは ~CSS構文解析器の関知する所ではなく、最悪でも，何にも合致しない選択子になることを意味する。
◎
At the "top level" of a stylesheet, an &lt;at-keyword-token&gt; starts an at-rule. Anything else starts a qualified rule, and is included in the rule’s prelude. This may produce an invalid selector, but that’s not the concern of the CSS parser—at worst, it means the selector will match nothing.
</li>

	<li>
<p>
`~at-rule$が開始されたなら、構文解析器の視点からは，何が来ようが無効ではなく、次のいずれかに遭遇するまでのすべてが，~at-ruleの.導入部の一部になる：
</p>
		<ul>
			<li>
`semicolon$tok に遭遇したときは，その~at-ruleは即時に終端される。
</li>
			<li>
一方で，開き波括弧 `open-curly$T に遭遇したときは、その~at-ruleの本体を開始させる
—
本体に合致する~block（ `()^c, `{}^c, `[]^c のいずれかに囲まれた内容）が、［［
他のものや別の~blockの内側
］には合致されないような閉じ波括弧 `close-curly$T 
］が見出されるまで，前方検索される。
</li>
		</ul>
<p>
しかる後、その~at-ruleの内容が，~at-rule~自身の文法に則って解釈される。
</p>

◎
Once an at-rule starts, nothing is invalid from the parser’s standpoint; it’s all part of the at-rule’s prelude. Encountering a &lt;semicolon-token&gt; ends the at-rule immediately, while encountering an opening curly-brace &lt;{-token&gt; starts the at-rule’s body. The at-rule seeks forward, matching blocks (content surrounded by (), {}, or []) until it finds a closing curly-brace &lt;}-token&gt; that isn’t matched by anything else or inside of another block. The contents of the at-rule are then interpreted according to the at-rule’s own grammar.
</li>

	<li>
`有修飾~規則$の場合も，［
セミコロンが，それを終端させない
］ことを除いて，同様に働く — そのセミコロンは，単に規則の.導入部の一部に取り込まれる。
［
最初の 波括弧~block
］が見出されたなら、その内容は常に，宣言~listとして解釈される。
◎
Qualified rules work similarly, except that semicolons don’t end them; instead, they are just taken in as part of the rule’s prelude. When the first {} block is found, the contents are always interpreted as a list of declarations.
</li>

	<li>
宣言~listを解釈する際に，未知の構文に出くわしたときは、現在~構築中の宣言は，それが何であれ，構文解析器により投棄され、次のセミコロン（あるいは~blockの終端）が見出されるまで，前方検索される。
しかる後、宣言の構文解析がまた，新規に試行される。
◎
When interpreting a list of declarations, unknown syntax at any point causes the parser to throw away whatever declaration it’s currently building, and seek forward until it finds a semicolon (or the end of the block). It then starts fresh, trying to parse a declaration again.
</li>

	<li>
どの［
規則, 宣言, 関数式, 文字列, 等々
］においても，それがまだ閉じられていないにもかかわらず，~stylesheetが終端した場合、あらゆるものが自動的に閉じられる。
これは、それらを無効にはしない。
不完全にもなり得るが、その場合は，それらの文法に照らし合わせて検証される際に投棄される。
◎
If the stylesheet ends while any rule, declaration, function, string, etc. are still open, everything is automatically closed. This doesn’t make them invalid, though they may be incomplete and thus thrown away when they are verified against their grammar.
</li></ul>

<p>
各~構成子（宣言, ~style規則, ~at-rule）が構文解析されたなら、~UAは，予期される文法に照らし合わせて検査する。
文法に合致しない場合，それは
`無効@
になり、~UAは，元からそれが無かったかのように
`無視-@
することになる。
◎
After each construct (declaration, style rule, at-rule) is parsed, the user agent checks it against its expected grammar. If it does not match the grammar, it’s invalid, and gets ignored
by the UA, which treats it as if it wasn’t there at all.
</p>

		</section>
	</section>
	<section id="tokenizing-and-parsing">
<h2 title="Tokenizing and Parsing CSS">3. ~CSSの~tokenizingと構文解析法</h2>

<p>
~UAが，~text／~CSSの資源から CSSOM 木を生成するときは、この仕様に述べられる構文解析規則を利用し~MUST。
同時に，これらの規則は、~CSS構文解析器と~~呼ばれているものを定義する。
◎
User agents must use the parsing rules described in this specification to generate the CSSOM trees from text/css resources. Together, these rules define what is referred to as the CSS parser.
</p>

<p>
この仕様は、~CSS文書が構文的に正しいかどうかを調べるための，構文解析規則を定義する。
構文解析処理~algoの内側にて、
`構文解析error@
と記される箇所がある。
その際の~errorの取扱いは、~well-definedである：
~UA は，その種の問題に遭遇したときには、以下に述べられる規則に従って動作するか, または
それらの規則の適用-が望ましくないような最初の~errorに遭遇した時点で，処理を中止し~MUST。
◎
This specification defines the parsing rules for CSS documents, whether they are syntactically correct or not. Certain points in the parsing algorithm are said to be a parse errors. The error handling for parse errors is well-defined: user agents must either act as described below when encountering such problems, or must abort processing at the first error that they encounter for which they do not wish to apply the rules described below.
</p>

<p>
適合性~検査器は、文書の中に 1 個以上の［
構文解析error状況
］が在るときには、利用者に向けて，少なくとも［それら］のうち 1 つ以上を報告し~MUST。
また、複数あるときは，複数の［それら］を報告しても~MAY。
逆に、文書の中に［それら］が存在しない場合は，［それら］を報告しては~MUST_NOT。
適合性~検査器には，構文解析errorから回復することは要求されないが、それを行う場合は，~UAと同じ仕方で回復し~MUST。
◎
Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document. Conformance checkers are not required to recover from parse errors, but if they do, they must recover in the same way as user agents.
</p>

		<section id="parsing-overview">
<h3 title="Overview of the Parsing Model">3.1. 構文解析処理~modelの概観</h3>

<p>
~CSS構文解析処理への入力は、［
Unicode `符号位置$の~stream
］である。
それは、［
~tokenization~段階
］を経て［
木の構築~段階
］に渡される。
その出力は［
`CSSStyleSheet$c ~object
］である。
◎
The input to the CSS parsing process consists of a stream of Unicode code points, which is passed through a tokenization stage followed by a tree construction stage. The output is a CSSStyleSheet object.
</p>

<p class="note">注記：
~scriptingを~supportしない実装は、実際に CSSOM `CSSStyleSheet^c ~objectを作成しなくともよいが、そのような場合でも依然として、 CSSOM 木は，この仕様の残りの部分のための~modelとして利用される。
◎
Note: Implementations that do not support scripting do not have to actually create a CSSOM CSSStyleSheet object, but the CSSOM tree in such cases is still used as the model for the rest of the specification.
</p>

		</section>
		<section id="input-byte-stream">
<h3 title="The input byte stream">3.2. 入力~byte~stream</h3>

<p>
［
~stylesheetの構文解析処理における~tokenization~段階
］への入力を成す［
Unicode `符号位置$の~stream
］は、~UAにとっては，最初は（概して，~network越しに, またはローカルファイルシステムからの）~byteの~streamとして見えるであろう。
その場合、 ~UAは，特定0の文字~符号化方式に則って，それらの~byteを元の`符号位置$並びに復号しなければならないことになる。
◎
When parsing a stylesheet, the stream of Unicode code points that comprises the input to the tokenization stage might be initially seen by the user agent as a stream of bytes (typically coming over the network or from the local file system). If so, the user agent must decode these bytes into code points according to a particular character encoding.
</p>

<p>
~UAが~byte~streamを［
Unicode `符号位置$~stream
］へ復号するときは、`ENCODING$r にて定義される
`復号-@
~algo（
<a href="~ENCODING#decode" >decode</a>
）を利用し~MUST。
その~algoに渡す~fallback符号化方式は、下の手続きにより決定されるものとする。
◎
To decode the stream of bytes into a stream of code points, UAs must use the decode algorithm defined in [ENCODING], with the fallback encoding determined as follows.
</p>

<p class="note">注記：
`復号-$~algoは~BOM（ BOM ）を優先させ、見当たらなかったときにのみ~fallbackを利用する。
◎
Note: The decode algorithm gives precedence to a byte order mark (BOM), and only uses the fallback when none is found. 
</p>

<p>
以下における，［
文字列（ “（符号化方式）~label” と称される）から
`符号化方式を取得@
する~algo
］は、 `ENCODING$r 仕様にて
<a href="~ENCODING#concept-encoding-get" >定義される</a>。
◎
↓</p>

<p>
`~fallback符号化方式を決定する@
するためには：
◎
To determine the fallback encoding: 
</p>

<ol>
	<li>
~IF［［
HTTP または それに等価な~protocol
］にて定義される［
`符号化方式~label$の指定-法（例えば， Content-Type ~headerの `charset^c ~parameter）
］を通して，~labelが指定されている
］~AND［
その~labelから`符号化方式を取得$した結果 ~NEQ ~failure
］
⇒
~RET その結果
◎
If HTTP or equivalent protocol defines an encoding (e.g. via the charset parameter of the Content-Type header), get an encoding [ENCODING] for the specified value. If that does not return failure, use the return value as the fallback encoding.
</li>

	<li>
<p>
~IF［［
`stream^V の
<span class="trans-note">【
その終端を超えない
】</span>
最初の 1024 ~byteまでの部分
］の頭部が、次の~hex列に合致
］：
◎
Otherwise, check the byte stream. If the first 1024 bytes of the stream begin with the hex sequence
</p>

<pre>40 63 68 61 72 73 65 74 20 22 `~label^V 22 3B</pre>

<p>
ここで `~label^V は、各~byteが 16 進 範囲 { 0x0 〜 0x21, 0x23 〜 0x7F } に入る任意の~byte列とする。
◎
where each XX byte is a value between 016 and 2116 inclusive or a value between 2316 and 7F16 inclusive, then get an encoding for the sequence of XX bytes, interpreted as ASCII.
</p>

<div class="note">

<p>
この~byte列は、 ASCII として復号されたときに，文字列［
<code>@charset"</code> ~APPEND ［ `~label^V が表現する文字列 ］ ~APPEND <code>";</code>
］になる。
◎
What does that byte sequence mean?
◎
The byte sequence above, when decoded as ASCII, is the string "@charset "…";", where the "…" is the sequence of bytes corresponding to the encoding’s label.
</p>
</div>

		<ol>
			<li>
<p>
`符号化方式^V ~LET 
`~label^V を ASCII として解釈して得られる文字列から `符号化方式を取得$した結果
◎
↑</p>
			</li>

			<li>

<div>
<p>
~IF［ `符号化方式^V ~IN { `utf-16be^c, `utf-16le^c }］
⇒
~RET `utf-8^c
</p>

<p>
~IF［
`符号化方式^V ~NEQ ~failure
］
⇒
~RET `符号化方式^V
</p>

◎
If the return value was utf-16be or utf-16le, use utf-8 as the fallback encoding; if it was anything else except failure, use the return value as the fallback encoding.
</div>

				<div class="note">
<p>
宣言が utf-16 のときに utf-8 を利用する理由は：
符号化方式~宣言の~byte列は ASCII としては
“<code>@charset "…";</code>”
になるが、
UTF-16 は ASCII 互換でない。
好ましい行いでないが，文書~内で正しい~byte列になるように暗号的なもの（
<code>䁣桡牳整•utf-16be∻</code>
など）を与えたとき、あるいは
文書が実際には ASCII 互換の符号化方式でありつつ，符号化方式~宣言が虚偽である場合でも、
UTF-8 を既定にしておくことが，あるべき挙動になる。
◎
Why use utf-8 when the declaration says utf-16?
◎
The bytes of the encoding declaration spell out “@charset "…";” in ASCII, but UTF-16 is not ASCII-compatible. Either you’ve typed in complete gibberish (like 䁣桡牳整•utf-16be∻) to get the right bytes in the document, which we don’t want to encourage, or your document is actually in an ASCII-compatible encoding and your encoding declaration is lying.
◎
Either way, defaulting to UTF-8 is a decent answer.
</p>

<p>
これは、 HTML の `meta charset^e の挙動を模倣するものでもある。
◎
As well, this mimics the behavior of HTML’s &lt;meta charset&gt; attribute.
</p>
				</div>

<p class="note">注記：
符号化方式~宣言の構文は、名前 `charset$at の`~at-rule$の構文に<em >似ているように見えるが</em>、そのような規則は実際には存在しない
— その書き方の規則は、通常は，そのような規則を認識するときより，ずっと制約的である。
CSS において妥当な `charset$at 規則を［
スペース並び, ~comment, 一重引用符
］などを利用して生産しつつ，その符号化方式~宣言は認識されなくするような、いくつものやり方がある。
この挙動は、符号化方式~宣言をできるだけ単純なものにして，正しく実装し易くするためである。
◎
Note: Note that the syntax of an encoding declaration looks like the syntax of an at-rule named @charset, but no such rule actually exists, and the rules for how you can write it are much more restrictive than they would normally be for recognizing such a rule. A number of things you can do in CSS that would produce a valid @charset rule (if one existed), such as using multiple spaces, comments, or single quotes, will cause the encoding declaration to not be recognized. This behavior keeps the encoding declaration as simple as possible, and thus maximizes the likelihood of it being implemented correctly.
</p>

			</li>
		</ol>
	</li>

	<li>
~IF ［
参照元 文書にて`環境~符号化方式$が提供されている
］
⇒
~RET それ
◎
Otherwise, if an environment encoding is provided by the referring document, use that as the fallback encoding.
</li>

	<li>
~RET `utf-8^c
◎
Otherwise, use utf-8 as the fallback encoding.
</li>

</ol>




<div class="note">

<p>
~web上では UTF-8 が既定の符号化方式であり、~web用途の新しい~file形式の多くは，
UTF-8 符号化方式を 前提にする, あるいは要求しているが、
CSS は，どの符号化方式が主流になるか はっきりする前の段階で策定されたので、~stylesheetを自動的に UTF-8 と見做すわけにはいかない。
◎
Though UTF-8 is the default encoding for the web, and many newer web-based file formats assume or require UTF-8 encoding, CSS was created before it was clear which encoding would win, and thus can’t automatically assume the stylesheet is UTF-8.
</p>

<p>
~stylesheet作者は、［
~stylesheetを UTF-8 にした上で、
HTTP ~header（または等価な~method）にて，~stylesheetの符号化方式を UTF-8 であるものと宣言する
］か, または［
参照元 文書の符号化方式を UTF-8 として宣言する
］<em >べき</em>である。
（ HTML において これを行うには、文書の頭部（ `head^e ）に `meta charset=utf-8^e 要素を与える。）
◎
Stylesheet authors should author their stylesheets in UTF-8, and ensure that either an HTTP header (or equivalent method) declares the encoding of the stylesheet to be UTF-8, or that the referring document declares its encoding to be UTF-8. (In HTML, this is done by adding a &lt;meta charset=utf-8&gt; element to the head of the document.)
</p>

<p>
これらのいずれも可用でない場合、作者は，~stylesheetの先頭に UTF-8 BOM
<span class="trans-note">【
<a href="http://ja.wikipedia.org/wiki/UTF-8" >参考</a>
】</span>
を与えるか，あるいは正確に次に一致する文字列を与えるべきである：
◎
If neither of these options are available, authors should begin the stylesheet with a UTF-8 BOM or the exact characters
</p>

<pre>@charset "utf-8";</pre> 

</div>


<p>
［
~byte列から復号される~CSS~stylesheet
］を参照する文書~言語は、それらの各~stylesheetに対し，
`環境~符号化方式@
を定義しても~MAY。
それは、他の符号化方式~hintを入手できない, あるいは可用でないときの，~fallbackとして利用されるものである：
◎
Document languages that refer to CSS stylesheets that are decoded from bytes may define an environment encoding for each such stylesheet, which is used as a fallback when other encoding hints are not available or can not be used.
</p>

<p>
`環境~符号化方式$の概念は旧来の内容との互換性のためのみにある。
新たな形式の文書や新たな~linking-mechanismは、~stylesheetの符号化方式が明示的に提供されない下では，既定で UTF-8 になるように、`環境~符号化方式$を提供する<strong>べきでない</strong>。
◎
The concept of environment encoding only exists for compatibility with legacy content. New formats and new linking mechanisms should not provide an environment encoding, so the stylesheet defaults to UTF-8 instead in the absence of more explicit information.
</p>

<p class="note">注記：
`HTML$r の `link rel=stylesheet^e
から参照される~stylesheetの`環境~符号化方式$は、その仕様にて
<a href="http://html.spec.whatwg.org/multipage/links.html#link-type-stylesheet" >定義されている</a>。
◎
Note: [HTML] defines the environment encoding for &lt;link rel=stylesheet&gt;.
</p>

<p class="note">注記：
`CSSOM$r は 
<a href="~CSSOM#requirements-on-user-agents-implementing-the-xml-stylesheet-processing-instruction"><code>&lt;xml-stylesheet?&gt;</code> 用の環境~符号化方式</a>
を定義する。
◎
Note: [CSSOM] defines the environment encoding for &lt;xml-stylesheet?&gt;.
</p>

<p class="note">注記：
`CSS3CASCADE$r は `import$at に対する環境~符号化方式を定義する。
◎
Note: [CSS3CASCADE] defines the environment encoding for @import.
</p>

		</section>
		<section id="input-preprocessing">
<h3 title="Preprocessing the input stream">3.3. 入力~streamの前処理</h3>

<p>
入力~streamは、入力~byte~streamから復号されて得られる一連の`符号位置$からなる。
◎
The input stream consists of the code points pushed into it as the input byte stream is decoded.
</p>

<p>
実装は、入力~streamを~tokenizerに送る前に，次の`符号位置$を置換え~MUST：
◎
Before sending the input stream to the tokenizer, implementations must make the following code point substitutions:
</p>

<dl class="switch">
	<dt >［ `0D^U (CR), `0A^U (LF) ］の並び</dt>
	<dt >`0D^U (CR)</dt>
	<dt >`0C^U (FF)</dt>
	<dd>
すべて，単独の`符号位置$［
`0A^U (LF)
］に置換する。
◎
Replace any U+000D CARRIAGE RETURN (CR) code points, U+000C FORM FEED (FF) code points, or pairs of U+000D CARRIAGE RETURN (CR) followed by U+000A LINE FEED (LF), by a single U+000A LINE FEED (LF) code point.
</dd>
	<dd class="trans-note">【
当然ながら、［ CR LF ］並びの置換-が，同じ場所での単独の CR より優先される。
】</dd>

	<dt>`00^U</dt>
	<dd>
すべて，［ ~FFFD ］に置換する。
◎
Replace any U+0000 NULL code point with U+FFFD REPLACEMENT CHARACTER (&#xFFFD;).
</dd>
</dl>

		</section>
	</section>
	<section id="tokenization">
<h2 title="Tokenization">4. ~tokenization</h2>

<p>
実装は、~CSSを~tokenizeするときには，以下の一連の~algoを利用したかのように動作し~MUST。
`符号位置$の~streamを，~tokenの~streamに転換するためには、［
`EOF$tok に到達するまで繰り返し `~tokenを消費$
］しつつ，その結果の各~tokenを新たな~streamの中に収集する。
`~tokenを消費$する~algoは、構文解析処理の <em>間</em> に［
必要に応じて “その場で”， `符号位置$~streamの~tokenizeに利用できる
］ようにするため、各~呼び出しに対し，単独の~tokenを返す。
◎
Implementations must act as if they used the following algorithms to tokenize CSS. To transform a stream of code points into a stream of tokens, repeatedly consume a token until an &lt;EOF-token&gt; is reached, collecting the returned tokens into a stream. Each call to the consume a token algorithm returns a single token, so it can also be used "on-demand" to tokenize a stream of code points during parsing, if so desired.
</p>

<p>
~tokenizationの段における出力は、次に挙げる~tokenの，ゼロ個以上の並びからなる~streamである：
◎
The output of the tokenization step is a stream of zero or more of the following tokens: &lt;ident-token&gt;, &lt;function-token&gt;, &lt;at-keyword-token&gt;, &lt;hash-token&gt;, &lt;string-token&gt;, &lt;bad-string-token&gt;, &lt;url-token&gt;, &lt;bad-url-token&gt;, &lt;delim-token&gt;, &lt;number-token&gt;, &lt;percentage-token&gt;, &lt;dimension-token&gt;, &lt;include-match-token&gt;, &lt;dash-match-token&gt;, &lt;prefix-match-token&gt;, &lt;suffix-match-token&gt;, &lt;substring-match-token&gt;, &lt;column-token&gt;, &lt;whitespace-token&gt;, &lt;CDO-token&gt;, &lt;CDC-token&gt;, &lt;colon-token&gt;, &lt;semicolon-token&gt;, &lt;comma-token&gt;, &lt;[-token&gt;, &lt;]-token&gt;, &lt;(-token&gt;, &lt;)-token&gt;, &lt;{-token&gt;, and &lt;}-token&gt;.
</p>

<p class="trans-note">【
それぞれの~tokenには，それが持ち得る~~属性の名前も挙げる。
また、その~tokenが表す CSS の代表的な構成子も併記する（これは、訳者による補足であり，該当する構成子を網羅するものでもない）。
】</p>

<table>

<thead><tr><th>~token
</th><th>~~属性
</th><th>代表的な構成子（括弧内はその例）
</th></tr></thead>

<tbody><tr><td>`ident@tok
</td><td>値
</td><td>~keyword値などを表す `CSS 識別子$（ `auto^c ）
</td></tr><tr><td>`function@tok
</td><td>値
</td><td>`関数記法$の名前~部分（ `calc(^c ）
</td></tr><tr><td>`at-keyword@tok
</td><td>値
</td><td>~at-rule（ <code>@import</code> ）
</td></tr><tr><td>`hash@tok
</td><td>値, 型~flag
</td><td>`~ID選択子$（ `#ID^c ）
</td></tr><tr><td>`string@tok
</td><td>値
</td><td>文字列~値（ `"もじのならび"^c ）
</td></tr><tr><td>`bad-string@tok
</td><td>
</td><td>構文が不正な文字列~値<!-- ※ -->
</td></tr><tr><td>`url@tok
</td><td>値
</td><td>URL 値（ `url(example.png)^c ）
</td></tr><tr><td>`bad-url@tok
</td><td>
</td><td>構文が不正な URL 値<!-- ※ -->
</td></tr><tr><td>`delim@tok
</td><td>値
</td><td>単独の文字からなる一般的な区切子（`結合子$, `!imortant^css 宣言の "`!^c" など）
</td></tr><tr><td>`number@tok
</td><td>文字列表現, 数値, 型~flag
</td><td>単位の無い数値（ `123.45^c ）
</td></tr><tr><td>`percentage@tok
</td><td>文字列表現, 数値,
</td><td>百分率~値（ `33.3%^c ）
</td></tr><tr><td>`dimension@tok
</td><td>文字列表現, 数値, 型~flag, 単位
</td><td>単位~付きの数値（ `1.5em^c ）
</td></tr><tr><td>`include-match@tok
</td><td>
</td><td>`~=^c — `属性~選択子$の中の，属性の名前と値を区切るもの
</td></tr><tr><td>`dash-match@tok
</td><td>
</td><td>`|=^c — 同上
</td></tr><tr><td>`prefix-match@tok
</td><td>
</td><td><code>^=</code> — 同上
</td></tr><tr><td>`suffix-match@tok
</td><td>
</td><td><code>$=</code> — 同上
</td></tr><tr><td>`substring-match@tok
</td><td>
</td><td>`*=^c — 同上
</td></tr><tr><td>`column@tok
</td><td>
</td><td>`||^c — `column 結合子$
</td></tr><tr><td>`whitespace@tok
</td><td>
</td><td>空白
</td></tr><tr><td>`CDO@tok
</td><td>
</td><td><code>&lt;!--</code> — 埋め込み~stylesheetの中の HTML ~commentの~~開始
</td></tr><tr><td>`CDC@tok
</td><td>
</td><td><code>--&gt;</code> — 同上, HTML ~commentの~~終了
</td></tr><tr><td>`colon@tok
</td><td>
</td><td>`:^c — `宣言$の中の~propの名前と値を区切るコロン
</td></tr><tr><td>`semicolon@tok
</td><td>
</td><td>`;^c — `宣言$の並びを区切るセミコロン
</td></tr><tr><td>`comma@tok
</td><td>
</td><td>`,^c — 成分値の並びを区切るカンマ
</td></tr><tr><td>`open-square@T
</td><td>
</td><td>`[^c — 属性~選択子を括る角括弧
</td></tr><tr><td>`close-square@T
</td><td>
</td><td>`]^c — 同上
</td></tr><tr><td>`open-paren@T
</td><td>
</td><td>`(^c — `条件付き~group規則$に与える条件を括る丸括弧
</td></tr><tr><td>`close-paren@T
</td><td>
</td><td>`)^c — 同上
</td></tr><tr><td>`open-curly@T
</td><td>
</td><td>`{^c — 宣言~listを括る波括弧
</td></tr><tr><td>`close-curly@T
</td><td>
</td><td>`}^c — 同上
</td></tr>
	</tbody>
</table>

<p>
各種~~属性がとり得る値は：
</p>

<ul>
	<li>
<p>
［
`ident$tok ／
`function$tok ／
`at-keyword$tok ／
`hash$tok ／
`string$tok ／
`url$tok
］の
<dfn>値</dfn>
は，ゼロ個以上の`符号位置$からなる。
</p>

<p>
`hash$tok の
<dfn>型~flag</dfn>
は，［
"無制約" （既定）, "id"
］のいずれかである。
</p>

◎
&lt;ident-token&gt;, &lt;function-token&gt;, &lt;at-keyword-token&gt;, &lt;hash-token&gt;, &lt;string-token&gt;, and &lt;url-token&gt; have a value composed of zero or more code points. Additionally, hash tokens have a type flag set to either "id" or "unrestricted". The type flag defaults to "unrestricted" if not otherwise set.
</li>

	<li>
`delim$tok の
<dfn>値</dfn>
は，単独の`符号位置$からなる。
◎
&lt;delim-token&gt; has a value composed of a single code point.
</li>

	<li>
<p>
［
`number$tok ／
`percentage$tok ／
`dimension$tok
］の：
</p>

	<ul>
		<li>
<dfn>文字列表現</dfn>
は， 1 個以上の `符号位置$からなる
</li>
		<li>
<dfn>数値</dfn>
は，字義通り
<span class="trans-note">【文字列表現で表現される】</span>
数による値である
</li>
	</ul>

<p>
［
`number$tok ／
`dimension$tok
］の
<dfn>型~flag</dfn>
は，［
"整数" （既定）, "実数"
］のいずれかである。
</p>

<p>
`dimension$tok の
<dfn>単位</dfn>
は、 1 個以上の`符号位置$からなる。
</p>

◎
&lt;number-token&gt;, &lt;percentage-token&gt;, and &lt;dimension-token&gt; have a representation composed of one or more code points, and a numeric value. &lt;number-token&gt; and &lt;dimension-token&gt; additionally have a type flag set to either "integer" or "number". The type flag defaults to "integer" if not otherwise set. &lt;dimension-token&gt; additionally have a unit composed of one or more code points.
</li>

</ul>

<p class="note">注記：
`hash$tok の.型~flagは， Selectors 構文 `SELECT$r にて利用される。
［ 型~flag: "id" ］を伴う `hash$tok のみが，妥当な `~ID選択子$になる。
◎
Note: The type flag of hash tokens is used in the Selectors syntax [SELECT]. Only hash tokens with the "id" type are valid ID selectors.
</p>

<p class="note">技術上の注記：
ここに定義される~tokenizerが先読みに要する`符号位置$は、 3 個までにされている。
それが生産する~tokenは、 Selectors における構文解析が，~token 1 個の先読みで済むように設計されており、この不変則を維持するため，将来的には新たな~tokenが追加され得る。
◎
Note: As a technical note, the tokenizer defined here requires only three code points of look-ahead. The tokens it produces are designed to allow Selectors to be parsed with one token of look-ahead, and additional tokens may be added in the future to maintain this invariant.
</p>

		<section id="token-diagrams">
<h3 title="Token Railroad Diagrams">4.1. ~tokenの線路図式</h3>

~INFORMATIVE

<p>
この節では、~tokenizerの参考~viewを線路図式の形で呈示する。
線路図式は，明示的な構文解析器よりコンパクトでありつつ,
大抵は正規表現よりも読み取り易い。
◎
This section presents an informative view of the tokenizer, in the form of railroad diagrams. Railroad diagrams are more compact than an explicit parser, but often easier to read than an regular expression.
</p>

<p>
これらの図式は、<em>参考</em> であって, <em>不完全</em>なものである。
~tokenの “正しい” 文法は述べるが、~errorの取扱いについては全く述べない。
それらはもっぱら，各種~tokenの構文を直感的に把握し易くするために提供されている。
◎
These diagrams are informative and incomplete; they describe the grammar of "correct" tokens, but do not describe error-handling at all. They are provided solely to make it easier to get an intuitive grasp of the syntax of each token.
</p>

<p>
`foo^tok
の様な名前が付与されている図式は、~tokenを表現する。
他のものは，他の図式から参照される生成規則である。
◎
Diagrams with names such as &lt;foo-token&gt; represent tokens. The rest are productions referred to by other diagrams.
</p>

<dl>
	<dt id="comment-diagram">`comment^sb（~comment）</dt>
	<dd class="railroad">`comment^dgm</dd>

	<dt id="newline-diagram">`newline^sb（`前処理$前の改行）</dt>
	<dd class="railroad">`newline^dgm</dd>

	<dt id="whitespace-diagram">`whitespace^sb（`空白$）</dt>
	<dd class="railroad">`whitespace^dgm</dd>

	<dt id="hex-digit-diagram">`hex digit^sb（ `~hex$ ）</dt>
	<dd class="railroad">`hex-digit^dgm</dd>

	<dt id="escape-diagram">`escape^sb（~escape-seq）</dt>
	<dd class="railroad">`escape^dgm</dd>

	<dt id="whitespace-token-diagram">`whitespace$tok</dt>
	<dd class="railroad">`whitespace-token^dgm</dd>

	<dt id="whitespaces-diagram">`ws*^sb</dt>
	<dd class="railroad">`whitespaces^dgm</dd>

	<dt id="ident-token-diagram">`ident$tok</dt>
	<dd class="railroad">`ident-token^dgm</dd>

	<dt id="function-token-diagram">`function$tok</dt>
	<dd class="railroad">`function-token^dgm</dd>

	<dt id="at-keyword-token-diagram">`at-keyword$tok</dt>
	<dd class="railroad">`at-keyword-token^dgm</dd>

	<dt id="hash-token-diagram">`hash$tok</dt>
	<dd class="railroad">`hash-token^dgm</dd>

	<dt id="string-token-diagram">`string$tok</dt>
	<dd class="railroad">`string-token^dgm</dd>

	<dt id="url-token-diagram">`url$tok</dt>
	<dd class="railroad">`url-token^dgm</dd>

	<dt id="number-token-diagram">`number$tok</dt>
	<dd class="railroad">`number-token^dgm</dd>

	<dt id="dimension-token-diagram">`dimension$tok</dt>
	<dd class="railroad">`dimension-token^dgm</dd>

	<dt id="percentage-token-diagram">`percentage$tok</dt>
	<dd class="railroad">`percentage-token^dgm</dd>

	<dt id="include-match-token-diagram">`include-match$tok</dt>
	<dd class="railroad">`include-match^dgm</dd>

	<dt id="dash-match-token-diagram">`dash-match$tok</dt>
	<dd class="railroad">`dash-match-token^dgm</dd>

	<dt id="prefix-match-token-diagram">`prefix-match$tok</dt>
	<dd class="railroad">`prefix-match-token^dgm</dd>

	<dt id="suffix-match-token-diagram">`suffix-match$tok</dt>
	<dd class="railroad">`suffix-match-token^dgm</dd>

	<dt id="substring-match-token-diagram">`substring-match$tok</dt>
	<dd class="railroad">`substring-match-token^dgm</dd>

	<dt id="column-token-diagram">`column$tok</dt>
	<dd class="railroad">`column-token-diagram^dgm</dd>

	<dt id="CDO-token-diagram">`CDO$tok</dt>
	<dd class="railroad">`CDO-token-diagram^dgm</dd>

	<dt id="CDC-token-diagram">`CDC$tok</dt>
	<dd class="railroad">`CDC-token-diagram^dgm</dd>

</dl>



		</section>
		<section id="tokenizer-definitions">
<h3 title="Definitions">4.2. 定義</h3>

<p>
この節では、~tokenizationの相にて利用される，いくつかの用語を定義する。
◎
This section defines several terms used during the tokenization phase.
</p>

<p class="trans-note">【
以下の中で， ~DAGGER 印~付きの項目は、この訳による追加の定義／補完である。
】</p>

<dl>
	<dt>`符号位置@</dt>
	<dd>
1 個の
<a href="http://unicode.org/glossary/#code_point">Unicode 符号位置</a>
`UNICODE$r。
Unicode 符号空間に属する任意の値
— すなわち， { 0 〜 10FFFF （ 16 進 ） } に属する整数。
◎
A Unicode code point. [UNICODE] Any value in the Unicode codespace; that is, the range of integers from 0 to (hexadecimal) 10FFFF.
</dd>

	<dt>`次入力~符号位置@</dt>
	<dd>
入力~streamの中の，未だ消費されていない`符号位置$のうちの，最初のもの。
◎
The first code point in the input stream that has not yet been consumed.
</dd>
	<dd class="trans-note">【
“次の `n^V 個の入力~符号位置” と記されることもある（ `n^V ≤ 3 ）。
参照される範囲が~streamの末尾を越えている部分の符号位置は， ~EOF （後述）と見なされる。
】</dd>

	<dt>`現入力~符号位置@</dt>
	<dd>
すでに消費された`符号位置$のうちの，最後のもの。
◎
The last code point to have been consumed.
</dd>

	<dt>`現入力~符号位置を再消費@する</dt>
	<dd>
`現入力~符号位置$を入力~streamの先頭に戻す
<span class="trans-note">【未~消費の状態に戻す】</span>
。
すなわち、次回に`次入力~符号位置$を消費する際には，`現入力~符号位置$を再び消費することになる。
◎
Push the current input code point back onto the front of the input stream, so that the next time you are instructed to consume the next input code point, it will instead reconsume the current input code point.
</dd>

	<dt>`~EOF符号位置@</dt>
	<dd>
入力~streamの終端を表現する，
<span class="trans-note">【
他のいかなる符号位置とも異なる
】</span>
概念的な符号位置。
入力~streamが空になり次第，`次入力~符号位置$は常に，~EOF 符号位置になる。
<span class="trans-note">【
以下、単に ~EOF と記す。
】</span>
◎
A conceptual code point representing the end of the input stream. Whenever the input stream is empty, the next input code point is always an EOF code point.
</dd>

	<dt>（各種の，符号位置の範囲）</dt>
	<dd>
<p>
次の表の見出しの各~用語は、同じ行に示される，一定~範囲に属する`符号位置$を表す（記号 ∪ は和集合をとることを意味する）：
</p>

<table>
	<thead><tr><th>用語</th><th>符号位置の範囲</th></tr></thead>
	<tbody>

<tr><td>`数字@</td><td>
{ `30^UU 〜 `39^UU }
◎
A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
</td></tr>

<tr><td>`~hex@</td><td>
`数字$ ∪ { `41^UU 〜 `46^UU } ∪ { `61^UU 〜 `66^UU }
◎
A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F), or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
</td></tr>

<tr><td>`正負符号@ ~DAGGER</td><td>
{ `2B^UU, `2D^UU }
</td></tr>

<tr><td>`指数~指示子@ ~DAGGER</td><td>
{ `45^UU, `65^UU }
</td></tr>


<tr><td>`大文字@</td><td>
{ `41^UU 〜 `5A^UU }
◎
A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
</td></tr>

<tr><td>`小文字@</td><td>
{ `61^UU 〜 `7A^UU }
◎
A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
</td></tr>

<tr><td>`英字@</td><td>
`大文字$ ∪ `小文字$
◎
An uppercase letter or a lowercase letter.
</td></tr>

<tr><td>`非~ASCII符号位置@</td><td>
{ U+0080 &lt;control&gt; 〜 U+10FFFF }
◎
A code point with a value equal to or greater than U+0080 &lt;control&gt;.
</td></tr>

<tr><td>`名前開始~符号位置@</td><td>
`英字$ ∪ `非~ASCII符号位置$ ∪ { `5F^UU }
◎
A letter, a non-ASCII code point, or U+005F LOW LINE (_).
</td></tr>

<tr><td>`名前~符号位置@</td><td>
`名前開始~符号位置$ ∪ `数字$ ∪ { `2D^UU }
◎
A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
</td></tr>

<tr><td>`印字不能~符号位置@</td><td>
{ `00^U 〜 `08^U } ∪ { `0B^U } ∪ { `0E^U 〜 `1F^U } ∪ { `7F^U }
◎
A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION, or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
</td></tr>

<tr><td>`改行@</td><td>
{ `0A^U }
<span class="note">
`0D^U および `0C^U は，この定義には含められない。
それらは`前処理$の段階で `0A^U に変換されるので。
</span>
◎
U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition, as they are converted to U+000A LINE FEED during preprocessing.
</td></tr>

<tr><td>`空白@</td><td>
`改行$ ∪ { `09^U, `20^U }
◎
A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
</td></tr>

<tr><td style="white-space:nowrap;">`~surrogate~符号位置@</td><td>
{ U+D800 〜 U+DFFF }
◎
A code point between U+D800 and U+DFFF inclusive.
</td></tr>

	</tbody>
</table>

	</dd>

	<dt>`許容される最大の符号位置@</dt>
	<dd>
Unicode にて定義されている最大の`符号位置$： U+10FFFF 。
◎
The greatest code point defined by Unicode: U+10FFFF.
</dd>


	<dt>`識別子@</dt>
	<dd>
`ident$tok と同じ構文を持つ，~CSS~sourceの一部分。
［
`at-keyword$tok,
`function$tok,
［ .型~flagが "id" の `hash$tok ］,
［ `dimension$tok の.単位 ］
］の中にも現れる。
◎
A portion of the CSS source that has the same syntax as an &lt;ident-token&gt;. Also appears in &lt;at-keyword-token&gt;, &lt;function-token&gt;, &lt;hash-token&gt; with the "id" type flag, and the unit of &lt;dimension-token&gt;.
</dd>

	<dt>“〜の符号位置を消費” ~DAGGER</dt>
	<dd>
~streamの先頭から，“〜” に記された部分の符号位置を取り去った上で、取り去られた最後の符号位置を，現入力~符号位置にあてがうことを意味する（言い換えれば、現入力~符号位置を指している~pointerを， “〜” に記された部分の最後の符号位置を指すように移動させる）。
“消費” が現れる所では、常にそのような副作用が伴われる。
“〜の符号位置を消費した結果” と記されたときは，消費された（取り去られた）符号位置の並びによる文字列を表す。
</dd>

	<dt>“~streamから`次入力~符号位置を繰り返し消費@する：” ~DAGGER</dt>
	<dd>
<p>
次を繰り返し実行することを意味する：
</p>

<ol>
	<li>`次入力~符号位置$を消費する</li>
	<li>
`現入力~符号位置$に応じて、［
後続の~blockに記された，対応する段
］を実行する
</li>
</ol>

<p>
繰り返しは，値が返された時点で終了する。
</p>
	</dd>

</dl>



		</section>
		<section id="tokenizer-algorithms">
<h3 title="Tokenizer Algorithms">4.3. ~tokenizer~algo</h3>

<p>
この節にて定義される一連の~algoは、［
`符号位置$の~stream
］を［
~tokenの~stream
］へ転換する。
◎
The algorithms defined in this section transform a stream of code points into a stream of tokens.
</p>

<div class="trans-note">
<p>
この節における表記
⇒
“~new `foo^tok ( `名前^V: `値^V , … )”
</p>

<p>
は、新たに作成される~token `foo^tok の~instanceであって，その各種~~属性が括弧内に記された様に初期化されたものを表す（ “値” という名前の~~属性もあることに注意）。
定数~token（ ~~属性を持たない~token ）の~instanceは，単に `foo^tok と記される。
</p>
</div>

			<section id="consume-token">
<h4 title="Consume a token">4.3.1. ~tokenを消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`~tokenを消費@
する方法を述べる。
それは、いずれかの型の単独の~tokenを返す：
◎
This section describes how to consume a token from a stream of code points. It will return a single token of any type.
</p>

<ol>
	<li>
`~comment列を消費$する
◎
Consume comments.
</li>

	<li>
<p>
~streamから`次入力~符号位置を繰り返し消費$する：
◎
Consume the next input code point.
</p>

<dl class="switch">
	<dt>`空白$</dt>
	<dd>
できるだけ多くの`空白$を消費する ~BR
~RET `whitespace$tok
◎
Consume as much whitespace as possible. Return a &lt;whitespace-token&gt;.
</dd>

	<dt>`22^UU</dt>
	<dd>
~RET `文字列~tokenを消費$した結果
◎
Consume a string token and return it.
</dd>

	<dt>`23^UU</dt>
	<dd>
<p>
~IF［
`次入力~符号位置$ ~IN `名前~符号位置$
］~OR［
`次の 2 個の入力~符号位置$は，`妥当な~escape$である
］：
◎
If the next input code point is a name code point or the next two input code points are a valid escape, then:
</p>

<ol>
	<li>
`type^V ~SET "無制約"
◎
↓</li>

	<li>
~IF［
`次の 3 個の入力~符号位置$は，`識別子を開始させる$
］
⇒
`type^V ~SET "id"
<!-- 
`hash$tok の~type~flag ~SET "id".
 -->
◎
Create a &lt;hash-token&gt;
◎
If the next 3 input code points would start an identifier, set the &lt;hash-token&gt;’s type flag to "id".
</li>

	<li>
~RET ~new `hash$tok ( 値: `名前を消費$した結果 , 型~flag: `type^V )
◎
Consume a name, and set the &lt;hash-token&gt;’s value to the returned string.
◎
Return the &lt;hash-token&gt;.
</li>

</ol>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`24^UU</dt>
	<dd>
<p>
~IF［
`次入力~符号位置$ ~EQ `3D^UU
］
⇒
それを消費する ~BR
~RET `suffix-match$tok
◎
If the next input code point is U+003D EQUALS SIGN (=), consume it and return a &lt;suffix-match-token&gt;.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, emit a &lt;delim-token&gt; with its value set to the current input code point.
</dd>

	<dt>`27^UU</dt>
	<dd>
~RET `文字列~tokenを消費$した結果
◎
Consume a string token and return it.
</dd>

	<dt>`28^UU</dt>
	<dd>
~RET `open-paren$T
◎
Return a &lt;(-token&gt;.
</dd>

	<dt>`29^UU</dt>
	<dd>
~RET `close-paren$T
◎
Return a &lt;)-token&gt;.
</dd>

	<dt>`2A^UU</dt>
	<dd>
<p>
~IF［
`次入力~符号位置$ ~EQ `3D^UU
］
⇒
それを消費する ~BR
~RET `substring-match$tok
◎
If the next input code point is U+003D EQUALS SIGN (=), consume it and return a &lt;substring-match-token&gt;.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`2B^UU</dt>
	<dd>
<p>
~IF［
入力~streamが `実数から開始されている$
］
⇒
`現入力~符号位置を再消費$する ~BR
~RET `数的~tokenを消費$した結果
◎
If the input stream starts with a number, reconsume the current input code point, consume a numeric token and return it.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`2C^UU</dt>
	<dd>
~RET `comma$tok
◎
Return a &lt;comma-token&gt;.
</dd>

	<dt>`2D^UU</dt>
	<dd>
<p>
~IF［
入力~streamが `実数から開始されている$
］
⇒
`現入力~符号位置を再消費$する ~BR
~RET `数的~tokenを消費$した結果
◎
If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
</p>

<p>
~IF
［
`次の 2 個の入力~符号位置$は［
`2D^U, `3E^U
］の並び (<code>-&gt;</code>) である 
］
⇒
それらを消費する ~BR
~RET `CDC$tok
◎
Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (-&gt;), consume them and return a &lt;CDC-token&gt;.
</p>

<p>
~IF ［
入力~streamが `識別子から開始されている$
］
⇒
`現入力~符号位置を再消費$する ~BR
~RET `識別子に類する~tokenを消費$した結果
◎
Otherwise, if the input stream starts with an identifier, reconsume the current input code point, consume an ident-like token, and return it.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</dd>

	<dt>`2E^UU</dt>
	<dd>
<p>
~IF［
入力~streamは `実数から開始されている$
］
⇒
`現入力~符号位置を再消費$する ~BR
~RET `数的~tokenを消費$した結果
◎
If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
<p>
	</dd>

	<dt>`3A^UU</dt>
	<dd>
~RET `colon$tok
◎
Return a &lt;colon-token&gt;.
</dd>

	<dt>`3B^UU</dt>
	<dd>
~RET `semicolon$tok
◎
Return a &lt;semicolon-token&gt;.
</dd>

	<dt>`3C^U (<code>&lt;</code>)</dt>
	<dd>
<p>
~IF［
`次の 3 個の入力~符号位置$は［
`21^U
`2D^U
`2D^U
］の並び（ <code>!--</code> ）である
］
⇒
それらを消費する ~BR
~RET `CDO$tok
◎
If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), consume them and return a &lt;CDO-token&gt;.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`40^UU</dt>
	<dd>
<p>
~IF［
`次の 3 個の入力~符号位置$は，`識別子を開始させる$
］
⇒
~RET ~new `at-keyword$tok ( 値: `名前を消費$した結果 )
◎
If the next 3 input code points would start an identifier, consume a name, create an &lt;at-keyword-token&gt; with its value set to the returned value, and return it.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`5B^UU</dt>
	<dd>
~RET `open-square$T
◎
Return a &lt;[-token&gt;.
</dd>

	<dt>`5C^UU</dt>
	<dd>
<p>
~IF［
入力~streamは `妥当な~escapeから開始されている$
］
⇒
`現入力~符号位置を再消費$する ~BR
~RET `識別子に類する~tokenを消費$した結果
◎
If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.
</p>

<p>
`構文解析error$ ~BR
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, this is a parse error. Return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`5D^UU</dt>
	<dd>
~RET `close-square$T
◎
Return a &lt;]-token&gt;.
</dd>

	<dt>`5E^UU</dt>
	<dd>
<p>
~IF［ `次入力~符号位置$ ~EQ `3D^UU ］
⇒
それを消費する ~BR
~RET `prefix-match$tok
◎
If the next input code point is U+003D EQUALS SIGN (=), consume it and return a &lt;prefix-match-token&gt;.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`7B^UU</dt>
	<dd>
~RET `open-curly$T
◎
Return a &lt;{-token&gt;.
</dd>

	<dt>`7D^UU</dt>
	<dd>
~RET `close-curly$T
◎
Return a &lt;}-token&gt;.
</dd>

	<dt>`数字$</dt>
	<dd>
`現入力~符号位置を再消費$する ~BR
~RET `数的~tokenを消費$した結果
◎
Reconsume the current input code point, consume a numeric token, and return it.
</dd>

	<dt>`名前開始~符号位置$</dt>
	<dd>
`現入力~符号位置を再消費$する ~BR
~RET `識別子に類する~tokenを消費$した結果
◎
Reconsume the current input code point, consume an ident-like token, and return it.
</dd>

	<dt>`7C^UU</dt>
	<dd>
<p>
~IF［
`次入力~符号位置$ ~EQ `3D^UU
］
⇒
それを消費する ~BR
~RET `dash-match$tok
◎
If the next input code point is U+003D EQUALS SIGN (=), consume it and return a &lt;dash-match-token&gt;.
</p>

<p>
~IF［ `次入力~符号位置$ ~EQ `7C^UU ］
⇒
それを消費する ~BR
~RET `column$tok
◎
Otherwise, if the next input code point is U+007C VERTICAL LINE (|), consume it and return a &lt;column-token&gt;.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>`7E^UU</dt>
	<dd>
<p>
~IF［
`次入力~符号位置$ ~EQ `3D^UU
］
⇒
それを消費する ~BR
~RET `include-match$tok
◎
If the next input code point is U+003D EQUALS SIGN (=), consume it and return an &lt;include-match-token&gt;.
</p>

<p>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</p>
	</dd>

	<dt>~EOF</dt>
	<dd>
~RET `EOF$tok
◎
Return an &lt;EOF-token&gt;.
</dd>

	<dt>他全部</dt>
	<dd>
~RET ~new `delim$tok ( 値: `現入力~符号位置$ )
◎
Return a &lt;delim-token&gt; with its value set to the current input code point.
</dd>

</dl>

	</li>
</ol>

			</section>
			<section id="consume-comments">
<h4 title="Consume comments">4.3.2. ~comment列を消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`~comment列を消費@
する方法を述べる。
それは~nothingを返す：
◎
This section describes how to consume comments from a stream of code points. It returns nothing.
</p>

<ol>
	<li>
~WHILE［
`次の 2 個の入力~符号位置$は［
`2F^UU,
`2A^UU
］の並びである
］
⇒
その 2 個を消費した上で、最初の［
［ `2A^UU, `2F^UU ］の並び, または［ ~EOF符号位置 ］
］までのすべての`符号位置$を消費する
◎
If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*), consume them and all following code points up to and including the first U+002A ASTERISK (*) followed by a U+002F SOLIDUS (/), or up to an EOF code point. Return to the start of this step.
</li>

	<li>
~IF
前段の繰り返しは ~EOF符号位置を消費して終えた
⇒
`構文解析error$
◎
If the preceding paragraph ended by consuming an EOF code point, this is a parse error.
</li>

	<li>
~RET ~nothing
◎
Return nothing.
</li>
</ol>

			</section>
			<section id="consume-numeric-token">
<h4 title="Consume a numeric token">4.3.3. 数的~tokenを消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`数的~tokenを消費@
する方法を述べる。
それは［
`number$tok,
`percentage$tok,
`dimension$tok
］のいずれかを返す。
◎
This section describes how to consume a numeric token from a stream of code points. It returns either a &lt;number-token&gt;, &lt;percentage-token&gt;, or &lt;dimension-token&gt;.
</p>


<ol >
	<li>
( 文字列表現: `string^V , 数値: `num^V , 型~flag: `type^V ) ~LET
`実数を消費$した結果
◎
Consume a number.
</li>

	<li>
<p>
~IF［
`次の 3 個の入力~符号位置$は，`識別子を開始させる$
］
⇒
~RET ~new `dimension$tok (
	文字列表現: `string^V ,
	数値: `num^V ,
	型~flag: `type^V ,
	単位: `名前を消費$した結果
)
</p>

◎
If the next 3 input code points would start an identifier, then:
◎
Create a &lt;dimension-token&gt; with the same representation, value, and type flag as the returned number, and a unit set initially to the empty string.
◎
Consume a name. Set the &lt;dimension-token&gt;’s unit to the returned value.
◎
Return the &lt;dimension-token&gt;.
</li>

	<li>
~IF［
`次入力~符号位置$ ~EQ `25^UU
］
⇒
それを消費する ~BR
~RET ~new `percentage$tok (
	文字列表現: `string^V ,
	数値: `num^V
)
◎
Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it. Create a &lt;percentage-token&gt; with the same representation and value as the returned number, and return it.
</li>

	<li>
~RET ~new `number$tok (
	文字列表現: `string^V ,
	型~flag: `type^V ,
	数値: `num^V
)
◎
Otherwise, create a &lt;number-token&gt; with the same representation, value, and type flag as the returned number, and return it.
</li>

</ol>



			</section>
			<section id="consume-ident-like-token">
<h4 title="Consume an ident-like token">4.3.4.  識別子に類する~tokenを消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`識別子に類する~tokenを消費@
する方法を述べる。
それは［
`ident$tok,
`function$tok,
`url$tok,
`bad-url$tok
］のいずれかを返す：
◎
This section describes how to consume an ident-like token from a stream of code points. It returns an &lt;ident-token&gt;, &lt;function-token&gt;, &lt;url-token&gt;, or &lt;bad-url-token&gt;.
</p>

<ol >
	<li>
`文字列^V ~LET `名前を消費$した結果
◎
Consume a name.
</li>

	<li>
<p>
~IF［［
`文字列^V  ~AEQ "`url^c"
］ ~AND ［
`次入力~符号位置$ ~EQ `28^UU
］：
</p>
		<ol >
			<li>
それを消費する
</li>

			<li>
~WHILE ［
`次の 2 個の入力~符号位置$は，いずれも`空白$である
］
⇒
`次入力~符号位置$を消費する
</li>

			<li>
<p>
~IF ［［
`次入力~符号位置$ ~IN { `22^UU, `27^UU }
］~OR［
`次の 2 個の入力~符号位置$は［
`空白$, ［
`22^UU または `27^UU
］の並びである
］
⇒
`現入力~符号位置を再消費$する ~BR
~RET ~new `function$tok ( 値: `文字列^V )
</p>

<p class="trans-note">【
引数が引用符で括られた `url("…")^c のような文字列は、
`function$tok と引数の並びと見なされる。
】</p>
			</li>

			<li>
~RET `~url~tokenを消費$した結果
</li>
		</ol>

◎
If the returned string’s value is an ASCII case-insensitive match for "url", and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it. While the next two input code points are whitespace, consume the next input code point. If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), or whitespace followed by U+0022 QUOTATION MARK (") orU+0027 APOSTROPHE ('), then create a &lt;function-token&gt; with its value set to the returned string and return it. Otherwise, consume a url token, and return it.
</li>

	<li>
~IF ［ `次入力~符号位置$ ~EQ `28^UU ］
⇒
それを消費する ~BR
~RET ~new `function$tok ( 値: `文字列^V )
◎
Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it. Create a &lt;function-token&gt; with its value set to the returned string and return it.
</li>

	<li>
~RET ~new `ident$tok ( 値: `文字列^V )
◎
Otherwise, create an &lt;ident-token&gt; with its value set to the returned string and return it.
</li>
</ol>









			</section>
			<section id="consume-string-token">
<h4 title="Consume a string token">4.3.5. 文字列~tokenを消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`文字列~tokenを消費@
する方法を述べる。
それは［
`string$tok
または
`bad-string$tok
］のいずれかを返す。

◎
This section describes how to consume a string token from a stream of code points. It returns either a &lt;string-token&gt; or &lt;bad-string-token&gt;.
</p>

<p>
この~algoは［
文字列を終端させる`符号位置$を表す <var>終端符号位置</var>
］も伴って呼ばれることもある。
<var>終端符号位置</var> が指定されずに呼ばれた場合、`現入力~符号位置$がそれに用いられる。
<span class="trans-note">【
終端符号位置までは消費されつつ，結果の文字列には終端符号位置は含まれない。
】</span>
◎
This algorithm may be called with an ending code point, which denotes the code point that ends the string. If an ending code point is not specified, the current input code point is used.
</p>

<ol >
	<li>
`文字列^V ~LET 空文字列
◎
Initially create a &lt;string-token&gt; with its value set to the empty string.
</li>

	<li>
<p>
~streamから`次入力~符号位置を繰り返し消費$する：
◎
Repeatedly consume the next input code point from the stream:
</p>

<dl class="switch">
	<dt><var >終端符号位置</var></dt>
	<dd>
~RET ~new `string$tok ( 値: `文字列^V )
◎
Return the &lt;string-token&gt;.
</dd>

	<dt>~EOF</dt>
	<dd>
`構文解析error$ ~BR
~RET ~new `string$tok ( 値: `文字列^V )
◎
This is a parse error. Return the &lt;string-token&gt;.
</dd>

	<dt>`改行$</dt>
	<dd>
`構文解析error$ ~BR
`現入力~符号位置を再消費$する ~BR
~RET `bad-string$tok
◎
This is a parse error. Reconsume the current input code point, create a &lt;bad-string-token&gt;, and return it.
</dd>

	<dt>`5C^UU</dt>
	<dd>
<p>
`次入力~符号位置$に応じて：
</p>

		<dl class="switch">
			<dt>~EOF</dt>
			<dd>
`構文解析error$
（何もしない）
</dd>

			<dt>`改行$</dt>
			<dd>
それを消費する
</dd>

			<dt>その他</dt>
			<dd class="note">（すなわち，~streamは `妥当な~escapeから開始されている$）</dd>
			<dd>
`文字列^V ~APPEND `~escapeされた符号位置を消費$した結果
</dd>
		</dl>

◎
If the next input code point is EOF, this is a parse error; do nothing.
◎
Otherwise, if the next input code point is a newline, consume it.
◎
Otherwise, (the stream starts with a valid escape) consume an escaped code point and append the returned code point to the &lt;string-token&gt;’s value.
</dd>

	<dt>他全部</dt>
	<dd>
`文字列^V ~APPEND `現入力~符号位置$
◎
Append the current input code point to the &lt;string-token&gt;’s value.
</dd>

</dl>
	</li>
</ol>


			</section>
			<section id="consume-url-token">
<h4 title="Consume a url token">4.3.6. ~url~tokenを消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`~url~tokenを消費@
する方法を述べる。
それは［
`url$tok, `bad-url$tok
］のいずれかを返す：
◎
This section describes how to consume a url token from a stream of code points. It returns either a &lt;url-token&gt; or a &lt;bad-url-token&gt;.
</p>

<p class="note">注記：
この~algoは，直前に文字列  "<code >url(</code>" が消費~済みであることを前提にする。
◎
Note: This algorithm assumes that the initial "url(" has already been consumed.
</p>




<ol>
	<li>
`url^V ~LET 空文字列
◎
Initially create a &lt;url-token&gt; with its value set to the empty string.
</li>

	<li>
できるだけ多くの`空白$を消費する
◎
Consume as much whitespace as possible.
</li>

	<li>
~IF［
`次入力~符号位置$ ~EQ ~EOF
］
⇒
`構文解析error$ ~BR
~RET ~new `url$tok ( 値: `url^V )
◎
If the next input code point is EOF, this is a parse error. Return the &lt;url-token&gt;.
</li>

	<li>
<p>
~streamから`次入力~符号位置を繰り返し消費$する：
◎
Repeatedly consume the next input code point from the stream:
</p>

		<dl class="switch">
			<dt>`29^UU</dt>
			<dd>
~RET ~new `url$tok ( 値: `url^V )
◎
Return the &lt;url-token&gt;.
</dd>

			<dt>EOF</dt>
			<dd>
`構文解析error$ ~BR
~RET ~new `url$tok ( 値: `url^V )
◎
This is a parse error. Return the &lt;url-token&gt;.
</dd>

			<dt>`空白$</dt>
			<dd>
<p>
できるだけ多くの`空白$を消費する
</p>

<p>
`次入力~符号位置$に応じて：
</p>

		<dl class="switch">
			<dt>~EOF</dt>
			<dd>
それを消費する ~BR
`構文解析error$ ~BR
~RET ~new `url$tok ( 値: `url^V )
</dd>

			<dt>`29^UU</dt>
			<dd>
それを消費する ~BR
~RET ~new `url$tok ( 値: `url^V )
</dd>

			<dt>その他</dt>
			<dd>
`不良~urlの残余を消費$する ~BR
~RET `bad-url$tok
</dd>
		</dl>

◎
Consume as much whitespace as possible. If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF, consume it and return the &lt;url-token&gt; (if EOF was encountered, this is a parse error); otherwise, consume the remnants of a bad url, create a &lt;bad-url-token&gt;, and return it.
</dd>

			<dt>`22^UU</dt>
			<dt>`27^UU</dt>
			<dt>`28^UU</dt>
			<dt>`印字不能~符号位置$</dt>
			<dd>
`構文解析error$ ~BR
`不良~urlの残余を消費$する ~BR
~RET `bad-url$tok
◎
This is a parse error. Consume the remnants of a bad url, create a &lt;bad-url-token&gt;, and return it.
</dd>

			<dt>`5C^U </dt>
			<dd>
<p>
~IF［
~streamは `妥当な~escapeから開始されている$
］
⇒
`url^V ~APPEND `~escapeされた符号位置を消費$した結果
◎
If the stream starts with a valid escape, consume an escaped code point and append the returned code point to the &lt;url-token&gt;’s value.
</p>

<p>
`構文解析error$ ~BR
`不良~urlの残余を消費$する ~BR
~RET `bad-url$tok
◎
Otherwise, this is a parse error. Consume the remnants of a bad url, create a &lt;bad-url-token&gt;, and return it.
</p>
			</dd>

			<dt>他全部</dt>
			<dd>
`url^V ~APPEND `現入力~符号位置$
◎
Append the current input code point to the &lt;url-token&gt;’s value.
</dd>
		</dl>
	</li>
</ol>




			</section>
			<section id="consume-escaped-code-point">
<h4 title="Consume an escaped code point">4.3.7. ~escapeされた符号位置を消費する</h4>

<p>
この節では，
`~escapeされた符号位置を消費@
する方法を述べる。
これは、［［
直前に `5C^UU が消費~済みである
］, かつ［
次入力~符号位置が `改行$ でも~EOFでもない
］］ことが検証-済みであることを前提にする。
これは、 1 個の`符号位置$を返す。
◎
This section describes how to consume an escaped code point. It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and that the next input code point has already been verified to not be a newline. It will return a code points.
</p><!-- ※a code points？ -->

<div >

<ol>
	<li>
<p>
~IF ［ `次入力~符号位置$ ~IN `~hex$ ］：
</p>
		<ol>
			<li>
`数値^V ~LET ［［
6 個まで，できるだけ多くの`~hex$を消費した結果
］を 16 進数として解釈した結果
］
</li>

			<li>
~IF［
`次入力~符号位置$ ~IN `空白$
］
⇒
それも消費する
</li>

			<li>
~IF［［
`数値^V ~EQ 0
］~OR［
`数値^V ~IN `~surrogate~符号位置$
］~OR［
`数値^V ~GT `許容される最大の符号位置$
］］
⇒
~RET ~FFFD
</li>

			<li>
~RET `数値^V を値とする `符号位置$
</li>
		</ol>
	</li>

	<li>
`次入力~符号位置$を消費する
</li>

	<li>
~IF ［ `現入力~符号位置$ ~EQ ~EOF ］
⇒
`構文解析error$ ~BR
~RET ~FFFD
</li>

	<li>
~RET `現入力~符号位置$
</li>
</ol>

		<div lang="en">
<p>
Consume the next input code point.
</p>

<dl>
	<dt>hex digit</dt>
	<dd>
Consume as many hex digits as possible, but no more than 5. Note that this means 1-6 hex digits have been consumed in total. If the next input code point is whitespace, consume it as well. Interpret the hex digits as a hexadecimal number. If this number is zero, or is for a surrogate code point, or is greater than the maximum allowed code point, return U+FFFD REPLACEMENT CHARACTER (&#xFFFD;). Otherwise, return the code point with that value.
</dd>

	<dt>EOF code point</dt>
	<dd>This is a parse error. Return U+FFFD REPLACEMENT CHARACTER (&#xFFFD;).</dd>

	<dt>anything else</dt>
	<dd>Return the current input code point.</dd>

</dl>

	</div>
</div>

			</section>
			<section id="starts-with-a-valid-escape">
<h4 title="Check if two code points are a valid escape">4.3.8. ［ 2 個の符号位置 ］並びが，妥当な~escapeをなすかどうかの検査</h4>

<p>
この節では， 2 個の符号位置の並び［
`c0^V, `c1^V
］が
`妥当な~escape@
であるかどうか検査する方法を述べる。
この~algoは、入力~streamそのものを入力に呼ばれることもある。
その場合、［
`c0^V ~SET `現入力~符号位置$,
`c1^V ~SET `次入力~符号位置$
］とする。
◎
This section describes how to check if two code points are a valid escape. The algorithm described here can be called explicitly with two code points, or can be called with the input stream itself. In the latter case, the two code points in question are the current input code point and the next input code point, in that order.
</p>

<p class="note">注記：
この~algoは`符号位置$を消費しない。
◎
Note: This algorithm will not consume any additional code point.
</p>

<ol>
	<li>
<p>
~IF［［
`c0^V ~EQ `5C^UU
］~AND［
`c1^V ~NIN `改行$
］］
⇒
~RET ~T
</p>

<p>
~RET ~F
</p>

◎
If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
◎
Otherwise, if the second code point is a newline, return false.
◎
Otherwise, return true.
</li>
</ol>


			</section>
			<section id="would-start-an-identifier">
<h4 title="Check if three code points would start an identifier">4.3.9. ［ 3 個の符号位置 ］並びが，識別子を開始させているかどうかの検査</h4>

<p>
この節では，
3 個の符号位置の並び［
`c0^V, `c1^V, `c2^V
］が
`識別子を開始させる@
かどうか検査する方法を述べる。
この~algoは、入力~streamそのものを入力に呼ばれることもある。
その場合、［
`c0^V, `c1^V, `c2^V
］ ~SET ［
`現入力~符号位置$,
`次の 2 個の入力~符号位置$
］とする。
◎
This section describes how to check if three code points would start an identifier. The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself. In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.
</p>

<p class="note">注記：
この~algoは`符号位置$を消費しない。
◎
Note: This algorithm will not consume any additional code points.
</p>

<ol>
	<li>
<p>
3 個の符号位置が次の表のいずれかの行に示される条件を満たすならば，~T を返し、他の場合は ~F を返す：
</p>

<table>
	<thead><tr><th>`c0^V</th><th>`c1^V</th><th>`c2^V</th></tr></thead>
	<tbody>
<tr><td>`2D^U
</td><td>`名前開始~符号位置$
</td><td>(任意)
</td></tr>

<tr><td>`2D^U
</td><td>`2D^U
</td><td>(任意)
</td></tr>

<tr><td>`2D^U
</td><td colspan="2">`妥当な~escape$である
</td></tr>

<tr><td>`名前開始~符号位置$
</td><td>(任意)
</td><td>(任意)
</td></tr>

<tr><td colspan="2">`妥当な~escape$である
</td><td>(任意)
</td></tr>
	</tbody>
</table>


		<div lang="en">

<p>
Look at the first code point:
</p>

<dl>
	<dt>U+002D HYPHEN-MINUS</dt>
	<dd>
If the second code point is a name-start code point or a U+002D HYPHEN-MINUS, or the second and third code points are a valid escape, return true. Otherwise, return false. 
</dd>
	<dt>name-start code point</dt>
	<dd>Return true.</dd>

	<dt>U+005C REVERSE SOLIDUS (\)</dt>
	<dd>If the first and second code points are a valid escape, return true. Otherwise, return false.</dd>

	<dt>anything else</dt>
	<dd>Return false.</dd>

</dl>

		</div>
	</li>
</ol>



			</section>
			<section id="starts-with-a-number">
<h4 title="Check if three code points would start a number">4.3.10. ［ 3 個の符号位置 ］並びが，実数を開始させているかどうかの検査</h4>

<p>
この節では，
3 個の符号位置の並び［
`c0^V, `c1^V, `c2^V
］が
`実数を開始させる@
かどうか検査する方法を述べる。
この~algoは、入力~streamそのものを入力に呼ばれることもある。
その場合、［
`c0^V, `c1^V, `c2^V
］ ~SET ［
`現入力~符号位置$,
`次の 2 個の入力~符号位置$
］とする。
◎
This section describes how to check if three code points would start a number. The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself. In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.
</p>

<p class="note">注記：
この~algoは`符号位置$を消費しない。
◎
Note: This algorithm will not consume any additional code points.
</p>

<ol >
	<li>
<p>
3 個の符号位置が次の表のいずれかの行に示される条件を満たすならば，~T を返し、他の場合は ~F を返す：
</p>
<table>
	<thead><tr><th>`c0^V</th><th>`c1^V</th><th>`c2^V</th></tr></thead>
	<tbody>
<tr><td>`正負符号$
</td><td>`数字$
</td><td>(任意)
</td></tr>

<tr><td>`正負符号$
</td><td>`2E^UU
</td><td>`数字$
</td></tr>

<tr><td>`2E^UU
</td><td>`数字$
</td><td>(任意)
</td></tr>

<tr><td>`数字$
</td><td>(任意)
</td><td>(任意)
</td></tr>

	</tbody>
</table>

		<div lang="en">

<p>
Look at the first code point:
</p>
<dl>
	<dt>U+002B PLUS SIGN (+)</dt>
	<dt>U+002D HYPHEN-MINUS (-)</dt>
	<dd>
<p>
If the second code point is a digit, return true.
</p>
<p>
Otherwise, if the second code point is a U+002E FULL STOP (.) and the third code point is a digit, return true.
</p>
<p>
Otherwise, return false.
</p>
	</dd>

	<dt>U+002E FULL STOP (.)</dt>
	<dd>If the second code point is a digit, return true. Otherwise, return false.</dd>

	<dt>digit</dt>
	<dd>Return true.</dd>

	<dt>anything else</dt>
	<dd>Return false.</dd>
</dl>


		</div>

	</li>
</ol>


			</section>
			<section id="consume-name">
<h4 title="Consume a name">4.3.11. 名前を消費する</h4>

<p>
この節では，`符号位置$の~streamから
`名前を消費@
する方法を述べる。
それは、~streamの中の，次の`符号位置$から始まる最長の名前を成す文字列を返す。
◎
This section describes how to consume a name from a stream of code points. It returns a string containing the largest name that can be formed from adjacent code points in the stream, starting from the first.
</p>

<p class="note">注記：
この~algoは，［
返される `符号位置$が `ident$tok の一部を成すこと
］の確保に必要な，［
最初の少数の`符号位置$の検証
］は行わない。
意図的にそのように利用するときは、［
~streamが`識別子から開始されている$こと
］を事前に確保すること。
◎
Note: This algorithm does not do the verification of the first few code points that are necessary to ensure the returned code points would constitute an &lt;ident-token&gt;. If that is the intended use, ensure that the stream starts with an identifier before calling this algorithm.
</p>

<ol>
	<li>
`結果^V ~LET 空~文字列
◎
Let result initially be an empty string.
</li>

	<li>
<p>
~streamから`次入力~符号位置を繰り返し消費$する：
◎
Repeatedly consume the next input code point from the stream:
</p>

<dl class="switch">
	<dt>`名前~符号位置$</dt>
	<dd>
`結果^V ~APPEND その`符号位置$
◎
Append the code point to result.
</dd>

	<dt>~streamが `妥当な~escapeから開始されている$◎the stream starts with a valid escape</dt>
	<dd>
`結果^V ~APPEND `~escapeされた符号位置を消費$した結果
◎
Consume an escaped code point. Append the returned code point to result.
</dd>

	<dt>他全部</dt>
	<dd>
`現入力~符号位置を再消費$する ~BR
~RET `結果^V
◎
Reconsume the current input code point. Return result.
</dd>

</dl>

	</li>
</ol>







			</section>
			<section id="consume-number">
<h4 title="Consume a number">4.3.12. 実数を消費する</h4>

<p>
この節では，
`符号位置$の~streamから
`実数を消費@
する方法を述べる。
それは，３つ組：［
文字列表現,
数値,
型~flag（ "整数" または "実数" ）
］を返す。
◎
This section describes how to consume a number from a stream of code points. It returns a 3-tuple of a string representation, a numeric value, and a type flag which is either "integer" or "number".
</p>

<p class="note">注記：
この~algoは，［
~streamから実数が得られること
］の確保に必要な，［
最初の少数の`符号位置$の検証
］を行わない。
呼ぶ際には，［
~streamが `実数から開始されている$こと
］を事前に確保すること。
◎
Note: This algorithm does not do the verification of the first few code points that are necessary to ensure a number can be obtained from the stream. Ensure that the stream starts with a number before calling this algorithm.
</p>

<ol>

	<li>
`文字列表現^V ~LET 空文字列 ~BR
`type^V ~LET "整数"
◎
Execute the following steps in order:
◎
Initially set repr to the empty string and type to "integer".
</li>

	<li>
~IF［ `次入力~符号位置$ ~IN `正負符号$ ］
⇒
`文字列表現^V ~APPEND それを消費した結果
◎
If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), consume it and append it to repr.
</li>

	<li>
~WHILE ［ `次入力~符号位置$ ~IN `数字$ ］
⇒
`文字列表現^V ~APPEND それを消費した結果
◎
While the next input code point is a digit, consume it and append it to repr.
</li>

	<li>
<p>
~IF［
`次の 2 個の入力~符号位置$は［ `2E^UU, `数字$ ］の並びである
］：
◎
If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
</p>

		<ol>
			<li>
`文字列表現^V ~APPEND それらを消費した結果
◎
Consume them.
◎
Append them to repr.
</li>

			<li>
`type^V ~SET "実数"
◎
Set type to "number".
</li>

			<li>
~WHILE ［ `次入力~符号位置$ ~IN `数字$ ］
⇒
`文字列表現^V ~APPEND それを消費した結果
◎
While the next input code point is a digit, consume it and append it to repr.
</li>

		</ol>
	</li>
	<li>
<p>
~IF［［
`次の 3 個の入力~符号位置$は［
`指数~指示子$, `正負符号$, `数字$
］の並びである
］~OR［
`次の 2 個の入力~符号位置$は［
`指数~指示子$, `数字$
］の並びである
］］：
◎
If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e), optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+), followed by a digit, then:
</p>

		<ol>
			<li>
`文字列表現^V ~APPEND それらを消費した結果
◎
Consume them.
◎
Append them to repr.
</li>

			<li>
`type^V ~SET  "実数"
◎
Set type to "number".
</li>

			<li>
~WHILE ［ `次入力~符号位置$ ~IN `数字$ ］
⇒
`文字列表現^V ~APPEND それを消費した結果
◎
While the next input code point is a digit, consume it and append it to repr.
</li>

		</ol>
	</li>

	<li>
~RET ３つ組［
文字列表現: `文字列表現^V,
数値: `文字列表現^V を`実数に変換-$した結果,
型~flag: `type^V
］
◎
Convert repr to a number, and set the value to the returned value.
◎
Return a 3-tuple of repr, value, and type.
</li>

</ol>




			</section>
			<section id="convert-string-to-number">
<h4 title="Convert a string to a number">4.3.13. 文字列を実数に変換する</h4>

<p>
この節では，文字列を
`実数に変換-@
する方法を述べる。
それは，実数を返す。
◎
This section describes how to convert a string to a number. It returns a number.
</p>

<p class="note">注記：
この~algoは、文字列が実数のみを包含しているかどうか 検証しない。
~algoを呼ぶ際には，［
文字列が妥当な~CSS 実数のみを包含していること
］を事前に確保すること。
◎
Note: This algorithm does not do any verification to ensure that the string contains only a number. Ensure that the string contains only a valid CSS number before calling this algorithm.
</p>

<ol >
	<li>
<p>
文字列を先頭から順に 7 個の成分に分割する：
◎
Divide the string into seven components, in order from left to right:
</p>

<ol>
	<li>
<b>符号</b> — 空文字列, または 1 個の`正負符号$
⇒
`s^V ~LET ［
符号 ~EQ `2D^UU ならば −1 ／
~ELSE_ 1
］
◎
A sign: a single U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), or the empty string. Let s be the number -1 if the sign is U+002D HYPHEN-MINUS (-); otherwise, let s be the number 1.
</li>

	<li>
<b>整数部</b> — ゼロ個以上の`数字$
⇒
`i^V ~LET 整数部を 10 進~整数として解釈した結果~DAGGER
◎
An integer part: zero or more digits. If there is at least one digit, let i be the number formed by interpreting the digits as a base-10 integer; otherwise, let i be the number 0.
</li>

	<li>
<b>小数点</b> — 空文字列, または 1 個の `2E^UU
◎
A decimal point: a single U+002E FULL STOP (.), or the empty string.
</li>

	<li>
<p><b>小数部</b> — ゼロ個以上の`数字$
⇒
`d^V ~LET 数字の個数 ~BR
`f^V ~LET 小数部を 10 進~整数として解釈した結果~DAGGER
◎
A fractional part: zero or more digits. If there is at least one digit, let f be the number formed by interpreting the digits as a base-10 integer and d be the number of digits; otherwise, let f and d be the number 0.
</li>

	<li>
<b>指数~指示子</b> — 空文字列, または 1 個の`指数~指示子$
◎
An exponent indicator: a single U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e), or the empty string.
</li>

	<li>
<b>指数~符号</b> — 空文字列, または 1 個の`正負符号$
⇒
`t^V ~LET ［
指数~符号 ~EQ `2D^UU ならば −1 ／
~ELSE_ 1
］
◎
An exponent sign: a single U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), or the empty string. Let t be the number -1 if the sign is U+002D HYPHEN-MINUS (-); otherwise, let t be the number 1.
</li>

	<li>
<b>指数</b>：ゼロ個以上の`数字$
⇒
`e^V ~LET 指数を 10 進~整数として解釈した結果~DAGGER
◎
An exponent: zero or more digits. If there is at least one digit, let e be the number formed by interpreting the digits as a base-10 integer; otherwise, let e be the number 0.
</li>

</ol>

<p>~DAGGER 整数部／小数部／指数が空文字列の場合、 0 に解釈する。</p>

	</li>
	<li>
~RET ［
`s^V × (`i^V + `f^V × 10<sup>−`d^V</sup>) × 10<sup>`t^V × `e^V</sup>
］
◎
Return the number s·(i + f·10-d)·10te.
</li>

</ol>

			</section>
			<section id="consume-remnants-of-bad-url">
<h4 title="Consume the remnants of a bad url">4.3.14. 不良~urlの残余を消費する</h4>

<p>
この節では、~tokenizerが，`符号位置$の~streamにおいて［
`url$tok ではなく，`bad-url$tok の中途にある
］ことを認識0した際の “後始末” のために、
`不良~urlの残余を消費@
する方法を述べる。
それは~nothingを返し、もっぱら，［
通常の~tokenizingを再開できるような回復~地点に到達するまで，入力~streamを十分に消費する
］ために利用される。
◎
This section describes how to consume the remnants of a bad url from a stream of code points, "cleaning up" after the tokenizer realizes that it’s in the middle of a &lt;bad-url-token&gt; rather than a &lt;url-token&gt;. It returns nothing; its sole use is to consume enough of the input stream to reach a recovery point where normal tokenizing can resume.
</p>

<ol >
	<li>
<p>
~streamから`次入力~符号位置を繰り返し消費$する：
◎
Repeatedly consume the next input code point from the stream:
</p>

<dl class="switch">
	<dt>`29^UU</dt>
	<dt>~EOF</dt>
	<dd>
~RET ~nothing
◎
Return.
</dd>

	<dt>入力~streamは `妥当な~escapeから開始されている$◎the input stream starts with a valid escape</dt>
	<dd>
<p>
`~escapeされた符号位置を消費$する
</p>

<p class="note">
これは、 `bad-url$tok を終端させずに，［
~escapeされた閉じ丸括弧（ "`\)^c" ）
］を取り込めるようにする。
それ以外の点では “他全部” の段と同じになる。
</p>

◎
Consume an escaped code point. This allows an escaped right parenthesis ("\)") to be encountered without ending the &lt;bad-url-token&gt;. This is otherwise identical to the "anything else" clause.
</dd>

	<dt>他全部</dt>
	<dd>
何もしない
◎
Do nothing.
</dd>

</dl>

	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="parsing">
<h2 title="Parsing">5. 構文解析法</h2>

<p>
構文解析処理 段階への入力は、［
~stream, または
~tokenization~段階から得られた~token~list
］である。
その出力は、構文解析器が［
この節にて後に定義される，一連の入口
］のいずれを介して呼出されたかに，依存する。
構文解析器の出力は、いくつかの［
`~at-rule$,
`有修飾~規則$,
`宣言$
］の混成からなる。
◎
The input to the parsing stage is a stream or list of tokens from the tokenization stage. The output depends on how the parser is invoked, as defined by the entry points listed later in this section. The parser output can consist of at-rules, qualified rules, and/or declarations.
</p>

<p>
構文解析器の出力は、特定のどの~itemについても，その妥当性については考慮せずに、~CSSの基礎的な構文に則って構築される。
実装は、種々の構文解析器~algoから~itemが返され次第，それらの~itemの妥当性を検査した上で、~itemが実装~自身に備わる文法の知識に則って無効なものであった際には，［
その~algoから~nothingが返されたものと扱う
］か, あるいは［
指定に従って全部的な木を構築した上で、無効な~itemは何であれ，除去する
］ことにより，それらを “一掃” してもよい。
◎
The parser’s output is constructed according to the fundamental syntax of CSS, without regards for the validity of any specific item. Implementations may check the validity of items as they are returned by the various parser algorithms and treat the algorithm as returning nothing if the item was invalid according to the implementation’s own grammar knowledge, or may construct a full tree as specified and "clean up" afterwards by removing any invalid items.
</p>

<p>
結果の木には、以下の~itemが現れ得る（一部の~itemには，いくつかの~~属性が伴われる）：
◎
The items that can appear in the tree are:
</p>

<dl>
	<dt>`~at-rule@</dt>
	<dd>
次の~~属性を持つ
⇒
<dfn>名前</dfn> ~BR
<dfn>導入部</dfn> : `成分値$~list ~BR
<dfn>~block</dfn>（~optional）: `波括弧~block$
◎
An at-rule has a name, a prelude consisting of a list of component values, and an optional block consisting of a simple {} block.
</dd>
	<dd class="note">注記：
この仕様は、［
~at-ruleの~blockが包含し得るもの
］について，制限を課さない。
個々の~at-ruleは、［［
それが~blockを受容するかどうか
］, および 受容するときは［
その~blockを構文解析する方法
］］を定義し~MUST（この仕様にて定義される，いずれかの［
構文解析器~algo, または入口
］の利用が好ましい）。
◎
Note: This specification places no limits on what an at-rule’s block may contain. Individual at-rules must define whether they accept a block, and if so, how to parse it (preferably using one of the parser algorithms or entry points defined in this specification).
</dd>

	<dt>`有修飾~規則@</dt>
	<dd>
次の~~属性を持つ
⇒
<dfn>導入部</dfn> : `成分値$~list ~BR
<dfn>~block</dfn> : `波括弧~block$
◎
A qualified rule has a prelude consisting of a list of component values, and a block consisting of a simple {} block.
</dd>
	<dd class="note">注記：
殆どの有修飾~規則は、［
導入部が選択子 `SELECT$r であり，
~blockが `宣言~list$である
］ような，~style規則になる。
◎
Note: Most qualified rules will be style rules, where the prelude is a selector [SELECT] and the block a list of declarations.
</dd>

	<dt>`宣言@</dt>
	<dd>
次の~~属性を持つ
⇒
<dfn>名前</dfn> ~BR
<dfn>値</dfn> : `成分値$~list ~BR
<dfn>important ~flag</dfn> : ~ON または ~OFF（初期時は~OFF）
◎
A declaration has a name, a value consisting of a list of component values, and an important flag which is initially unset.
</dd>
	<dd>
宣言は更に［
“~prop” と “記述子”
］に分類される
— 前者は概して，`有修飾~規則$の中に出現し、後者は，`~at-rule$の中に出現する。
（この分類は、 Syntax （この仕様）~levelにおいては生じない
— それは，宣言が現れる所における生産物であり、与えられた規則を定義している仕様により定義される。
）
◎
Declarations are further categorized as "properties" or "descriptors", with the former typically appearing in qualified rules and the latter appearing in at-rules. (This categorization does not occur at the Syntax level; instead, it is a product of where the declaration appears, and is defined by the respective specifications defining the given rule.)
</dd>

	<dt>`成分値@</dt>
	<dd>
次のいずれか
⇒
`保全~token$ ／ `関数式$ ／ `単純~block$
◎
A component value is one of the preserved tokens, a function, or a simple block.
</dd>

	<dt>`保全~token@</dt>
	<dd>
［
`function$tok,
`open-curly$T,
`open-paren$T,
`open-square$T
］以外の，~tokenizerにより生産される任意の~token。
◎
Any token produced by the tokenizer except for &lt;function-token&gt;s, &lt;{-token&gt;s, &lt;(-token&gt;s, and &lt;[-token&gt;s.
</dd>
	<dd class="note">注記：
［
上に挙げられた非~保全~token
］は常に，より高次の［
`関数式$／`単純~block$
］~objectの中で消費されるので、構文解析器の出力には，決して現れない。
◎
Note: The non-preserved tokens listed above are always consumed into higher-level objects, either functions or simple blocks, and so never appear in any parser output themselves.
</dd>
	<dd class="note">注記：
<span class="trans-note">【出力に現れる】</span>
~token：［
`close-curly$T,
`close-paren$T,
`close-square$T,
`bad-string$tok,
`bad-url$tok
］は，常に`構文解析error$を表すが、それらは， Media Queries などの他の仕様が［
単に，宣言や~blockをまるごと棄てるよりも細やかな、~errorの取扱い
］を定義できるようにするため、この仕様により，~token~streamの中に保全される。
◎
Note: The tokens &lt;}-token&gt;s, &lt;)-token&gt;s, &lt;]-token&gt;, &lt;bad-string-token&gt;, and &lt;bad-url-token&gt; are always parse errors, but they are preserved in the token stream by this specification to allow other specs, such as Media Queries, to define more fine-grainted error-handling than just dropping an entire declaration or block.
</dd>

	<dt>`関数式@</dt>
	<dd>
次の~~属性を持つ
⇒
<dfn>名前</dfn> ~BR
<dfn>値</dfn> : `成分値$~list
◎
A function has a name and a value consisting of a list of component values.
</dd>

	<dt>`単純~block@</dt>
	<dd>
次の~~属性を持つ
⇒
<dfn>開き括弧</dfn> ~DAGGER : `open-square$T, `open-paren$T, `open-curly$T のいずれか ~BR
<dfn>値</dfn> : `成分値$~list
◎
A simple block has an associated token (either a &lt;[-token&gt;, &lt;(-token&gt;, or &lt;{-token&gt;) and a value consisting of a list of component values.
</dd>
	<dd class="trans-note">【
~DAGGER 開き括弧がとる値に応じて，順に
`角括弧~block@,
`丸括弧~block@,
`波括弧~block@
とも記される。
】</dd>

</dl>

		<section id="parser-diagrams">
<h3 title="Parser Railroad Diagrams">5.1. 構文解析器の線路図式</h3>

~INFORMATIVE

<p>
この節は、構文解析器の参考~viewを，線路図式の形で呈示する。
◎
This section presents an informative view of the parser, in the form of railroad diagrams.
</p>

<p>
これらの図式は、<em>参考</em> であって, <em>不完全</em>なものである。
~stylesheetの “正しい” 文法は述べるが、~errorの取扱いについては全く述べない。
それらはもっぱら，構文を直感的に把握し易くするために提供されている。
◎
These diagrams are informative and incomplete; they describe the grammar of "correct" stylesheets, but do not describe error-handling at all. They are provided solely to make it easier to get an intuitive grasp of the syntax.
</p>

<dl>
	<dt id="stylesheet-diagram">`Stylesheet^sb（~stylesheet）</dt>
	<dd class="railroad">`stylesheet-diagram^dgm</dd>


	<dt id="rule-list-diagram">`Rule list^sb（`規則~list$）</dt>
	<dd class="railroad">`rule-list^dgm</dd>


	<dt id="at-rule-diagram">`At-rule^sb（`~at-rule$）</dt>
	<dd class="railroad">`at-rule-diagram^dgm</dd>


	<dt id="qualified-rule-diagram">`Qualified rule^sb（`有修飾~規則$）</dt>
	<dd class="railroad">`qualified-rule-diagram^dgm</dd>


	<dt id="declaration-list-diagram">`Declaration list^sb（`宣言~list$）</dt>
	<dd class="railroad">`declaration-list^dgm</dd>


	<dt id="declaration-diagram">`Declaration^sb（`宣言$）</dt>
	<dd class="railroad">`declaration^dgm</dd>


	<dt id="!important-diagram">~important</dt>
	<dd class="railroad">`important^dgm</dd>

	<dt id="component-value-diagram">`Component value^sb（`成分値$）</dt>
	<dd class="railroad">`component-value^dgm</dd>


	<dt id="curly-block-diagram">`{} block^sb（`波括弧~block$）</dt>
	<dd class="railroad">`curly-block^dgm</dd>


	<dt id="paren-block-diagram">`() block^sb（`丸括弧~block$）</dt>
	<dd class="railroad">`paren-block^dgm</dd>


	<dt id="square-block-diagram">`[] block^sb（`角括弧~block$）</dt>
	<dd class="railroad">`square-block^dgm</dd>


	<dt id="function-block-diagram">`Function block^sb（`関数式$）</dt>
	<dd class="railroad">`function-block^dgm</dd>

</dl>



		</section>
		<section id="parser-definitions">
<h3 title="Definitions">5.2. 定義</h3>

<dl>
	<dt>`現入力~token@</dt>
	<dd>
［
~tokenizerにより生産される~token~list
］からの，現在~操作されている［
~tokenまたは`成分値$
］
◎
The token or component value currently being operated on, from the list of tokens produced by the tokenizer.
</dd>

	<dt>`次入力~token@</dt>
	<dd>
~tokenizerにより生産される~token~listの中の，
`現入力~token$に直後に続く［
~tokenまたは`成分値$
］。
そのようなものが無い場合の`次入力~token$は `EOF$tok とする。
◎
The token or component value following the current input token in the list of tokens produced by the tokenizer. If there isn’t a token following the current input token, the next input token is an &lt;EOF-token&gt;.
</dd>

	<dt>`EOF@tok</dt>
	<dd>
~token~listの終端を表現する概念的な~token。
~token~listが空になったときの`次入力~token$は、常に， `EOF$tok である。
◎
A conceptual token representing the end of the list of tokens. Whenever the list of tokens is empty, the next input token is always an &lt;EOF-token&gt;.
</dd>

	<dt>`次入力~tokenを消費@する</dt>
	<dd>
［
現在の`次入力~token$
］を`現入力~token$にする。
それに伴い，`次入力~token$もその次のものを指すようになる。
◎
Let the current input token be the current next input token, adjusting the next input token accordingly.
</dd>

	<dt>`現入力~tokenを再消費@する</dt>
	<dd>
次回の［
`次入力~tokenを消費$する
］の挙動を，何もしない様に変える（`現入力~token$を不変に保たせる）。
◎
The next time an algorithm instructs you to consume the next input token, instead do nothing (retain the current input token unchanged).
</dd>

	<dt>“`次入力~tokenを繰り返し消費@する：”
<span class="trans-note">【この項目はこの訳による補完】</span>
</dt>
	<dd>
<p>
次を繰り返し実行することを意味する：
</p>

<ol>
	<li>`次入力~tokenを消費$する</li>
	<li>
消費された~token（すなわち，`現入力~token$）に応じて、［
後続の~blockに記された，対応する段
］を実行する
</li>
</ol>

<p>
繰り返しは，値が返された時点で終了する。
</p>

	</dd>
</dl>


		</section>
		<section id="parser-entry-points">
<h3 title="Parser Entry Points">5.3. 構文解析器の入口</h3>

<p>
この節にて定義される一連の~algoは、より低次の~objectから，より高次の~CSS~objectを生産する。
それらは，~token~streamに対し呼出されることを前提にしているが、文字列に対しても呼出され得る
—
この場合、事前に，`入力の前処理$を遂行して`符号位置$~streamを生産した上で、`~tokenization$を行って~token~streamを生産しておく。
◎
The algorithms defined in this section produce high-level CSS objects from lower-level objects. They assume that they are invoked on a token stream, but they may also be invoked on a string; if so, first perform input preprocessing to produce a code point stream, then perform tokenization to produce a token stream.
</p>

<p>
“`~stylesheetを構文解析-$”
は、~byte~streamに対しても呼出され得る。
この場合、`入力~byte~stream$が，それを Unicode に復号する方法を定義する。
◎
"Parse a stylesheet" can also be invoked on a byte stream, in which case The input byte stream defines how to decode it into Unicode.
</p>

<p class="note">注記：
この仕様は、他の入口については，~byte~streamを復号する方法は定義しない。
◎
Note: This specification does not define how a byte stream is decoded for other entry points.
</p>

<p class="note">注記：
他の仕様は、追加の入口を 自身の目的に定義できる。
◎
Note: Other specs can define additional entry points for their own purposes.
</p>

<div class="note">
<p>
以下の注記は、おそらく，この仕様の用語の利用を通して，関連~仕様の規定~textへ移行されるべきであろう：
◎
The following notes should probably be translated into normative text in the relevant specs, hooking this spec’s terms:
</p>

<ul>
	<li>
“`~stylesheetを構文解析-$”
は、~stylesheetを構文解析するための，［
通常の，構文解析器の入口
］になることが意図されている。
◎
"Parse a stylesheet" is intended to be the normal parser entry point, for parsing stylesheets.
</li>

	<li>
“`規則~listを構文解析-$”
は、［
`media$at などの，~at-ruleの内容
］のための用途が意図されている。
それは，［
`CDO$tok, および `CDC$tok
］の取扱いにおいて
“`~stylesheetを構文解析-$”
と異なる。
◎
"Parse a list of rules" is intended for the content of at-rules such as @media. It differs from "Parse a stylesheet" in the handling of &lt;CDO-token&gt; and &lt;CDC-token&gt;.
</li>

	<li>
“`規則を構文解析-$”
は，~textを構文解析して単独の規則を得る［
`CSSStyleSheet$c の `insertRule^c ~method
］, あるいは同類の関数からの利用が意図されている。
◎
"Parse a rule" is intended for use by the CSSStyleSheet#insertRule method, and similar functions which might exist, which parse text into a single rule.
</li>

	<li>
“`宣言を構文解析-$”
は，`条件付き~group規則$ `supports$at からの利用が意図されている。
`CSS3-CONDITIONAL$r
◎
"Parse a declaration" is used in @supports conditions. [CSS3-CONDITIONAL]
</li>

	<li>
“`宣言~listを構文解析-$”
は、 `style^c 属性の内容のために，~textを単独の~style規則の内容として構文解析するものである。
◎
"Parse a list of declarations" is for the contents of a style attribute, which parses text into the contents of a single style rule.
</li>

	<li>
“`成分値を構文解析-$”
は、 `attr()$css の構文解析規則の様な，単独の値の消費に必要とされるものである。
◎
"Parse a component value" is for things that need to consume a single value, like the parsing rules for attr().
</li>

	<li>
“`成分値~listを構文解析-$”
は、［
呈示用途の属性
<span class="trans-note">【 style 属性など】</span>
の内容~text
］を単独の宣言~値として構文解析したり，［
<a href="http://www.w3.org/TR/selectors-api/" >Selectors API</a>
の
<span class="trans-note">【~method引数~等に渡す】</span>
自立的な選択子 `SELECT$r
］や［
HTML の `media^c 属性の媒体~query~list `MEDIAQ$r
］を構文解析するためのものである
◎
"Parse a list of component values" is for the contents of presentational attributes, which parse text into a single declaration’s value, or for parsing a stand-alone selector [SELECT] or list of Media Queries [MEDIAQ], as in Selectors API or the media HTML attribute.
</li></ul>
	</div>

<p>
この仕様にて定義される すべての~algoは、［
~token~list ／`成分値$~list
］の，いずれかを伴って呼ばれ得る。
いずれにせよ，同じ結果を生産する。
◎
All of the algorithms defined in this spec may be called with either a list of tokens or of component values. Either way produces an identical result.
</p>


			<section id="parse-grammar">
<h4 title="Parse something according to a CSS grammar">5.3.1. 何かを CSS 文法に則って構文解析する</h4>

<p>
文字列や~token~listを，何らかの CSS 文法に合致するかどうか構文解析した上で、合致したときには，その文法に則って再構成したい場面はよくある。
この節では、この種の演算のための，汎用の~hookを提供する。
それは、
“ `foo^V を CSS `color$t として構文解析する”
等々の様に呼出されるべきである。
◎
It is often desirable to parse a string or token list to see if it matches some CSS grammar, and if it does, to destructure it according to the grammar. This section provides a generic hook for this kind of operation. It should be invoked like "parse foo as a CSS &lt;color&gt;", or similar.
</p>

<p class="note">注記：
この節や後続の各~節の~algoは、呼ぶ側の都合に合わせて［
文字列,
CSS ~tokenの~stream,
CSS 成分値の~stream
］のいずれも，入力にとり得ることに留意されたし。
◎
Note: As a reminder, this algorithm, along with all the others in this section, can be called with a string, a stream of CSS tokens, or a stream of CSS component values, whichever is most convenient.
</p>

<p>
この~algoを呼ぶときは、構文解析する対象として<strong>何らかの入力</strong>を伴い,
<strong>何らかの CSS 文法</strong>（または それに対応する用語）が指定され~MUST。
◎
This algorithm must be called with some input to be parsed, and some CSS grammar specification or term.
</p>

<p>
この~algoは、提供されている文法に対応する構造が指定されていないような 入力が，その文法に［
合致しないならば ~failure ／
合致したならば その文法に則って入力を構文解析した結果
］を返す。
後者の結果は、仕様の注釈文によってのみ interact され~MUST<!-- ＊ -->
— 結果を利用する仕様は、［
仕様~言語<!--＊-->の外部へ公開しようと~~意図する所で，表現の多義性が問題にならない所
］では，それを明示的に［
必要程度に仕様化された（ well-specified ）表現
］に翻訳し~MUST
— 例えば、何らかの CSS 直列化~algoを呼出して（
“CSS `string$t として直列化する”
等々）。
◎
This algorithm returns either failure, if the input does not match the provided grammar, or the result of parsing the input according to the grammar, which is an unspecified structure corresponding to the provided grammar specification. The return value must only be interacted with by specification prose, where the representation ambiguity is not problematic if it is meant to be exposed outside of spec language, the spec using the result must explicitly translate it into a well-specified representation, such as, for example, by invoking a CSS serialization algorithm (like "serialize as a CSS &lt;string&gt; value").
</p>

<p>
`何かを CSS 文法に則って構文解析する@
ときは：
◎
To parse something according to a CSS grammar:
</p>

<ol>
	<li>
`結果^V ~LET 入力から`成分値~listを構文解析-$した結果
◎
Parse a list of component values from the input, and let result be the return value.
</li>

	<li>
~RET
`結果^V が提供された文法に［
合致するならば，合致した結果 ／
合致しないならば ~failure
］
◎
Attempt to match result against the provided grammar. If this is successful, return the matched result; otherwise, return failure.
</li>
</ol>

			</section>
			<section id="parse-stylesheet">
<h4 title="Parse a stylesheet">5.3.2. ~stylesheetを構文解析する</h4>

<p>
~tokenの~streamから
`~stylesheetを構文解析-@
するためには：
◎
To parse a stylesheet from a stream of tokens:
</p>

<ol>
	<li>
`規則~list^V ~LET［
`~top-level~flag$ ~SET ~ON
］の下に，~tokenの~streamから`規則~listを消費$した結果
◎
Create a new stylesheet.
◎
Consume a list of rules from the stream of tokens, with the top-level flag set. Let the return value be rules.
</li>
	<li>
~IF［
`規則~list^V の最初の規則は`~at-rule$である
］~AND［
その名前 ~AEQ "`charset^c"
］
⇒
`規則~list^V から最初の規則を除去する
◎
If the first rule in rules is an at-rule with a name that is an ASCII case-insensitive match for "charset", remove it from rules.
</li>
	<li>
~stylesheetの値に `規則~list^V をあてがう
◎
Assign rules to the stylesheet’s value.
</li>
	<li>
~RET ~stylesheet
◎
Return the stylesheet.
</li>

</ol>



			</section>
			<section id="parse-list-of-rules">
<h4 title="Parse a list of rules">5.3.3. 規則~listを構文解析する</h4>

<p>
~tokenの~streamから
`規則~listを構文解析-@
するためには：
◎
To parse a list of rules from a stream of tokens:
</p>

<ol>
	<li>
~RET ［
`~top-level~flag$ ~SET ~OFF
］の下に，~tokenの~streamから`規則~listを消費$した結果
◎
Consume a list of rules from the stream of tokens, with the top-level flag unset.
◎
Return the returned list.
</li>
</ol>


			</section>
			<section id="parse-rule">
<h4 title="Parse a rule">5.3.4. 規則を構文解析する</h4>

<p>
~tokenの~streamから
`規則を構文解析-@
するためには：
◎
To parse a rule from a stream of tokens:
</p>

<ol>

	<li>
<p>
~WHILE ［ `次入力~token$は `whitespace$tok である ］
⇒
`次入力~tokenを消費$する
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</p>

<p>
~IF［ `次入力~token$は `EOF$tok である ］
⇒
~RET 構文~error
◎
If the next input token is an &lt;EOF-token&gt;, return a syntax error.
</p>

	</li>

	<li>
~IF ［ `次入力~token$は `at-keyword$tok である ］
⇒
`規則^V ~LET `~at-ruleを消費$した結果
◎
Otherwise, if the next input token is an &lt;at-keyword-token&gt;, consume an at-rule, and let rule be the return value.
</li>

	<li>
<p>
~ELSE：
</p>

		<ol>
			<li>
`規則^V ~LET `有修飾~規則を消費$した結果
</li>
			<li>
~IF［
`規則^V ~EQ ~nothing
］
⇒
~RET 構文~error
</li>
		</ol>

◎
Otherwise, consume a qualified rule and let rule be the return value. If nothing was returned, return a syntax error.
</li>

	<li>
~WHILE ［ `次入力~token$は `whitespace$tok である ］
⇒
`次入力~tokenを消費$する
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>

	<li>
<p>
~IF［ `次入力~token$は `EOF$tok である ］
⇒
~RET `規則^V
</p>

<p>
~RET 構文~error
</p>

◎
If the next input token is an &lt;EOF-token&gt;, return rule. Otherwise, return a syntax error.
</li>

</ol>



			</section>
			<section id="parse-declaration">
<h4 title="Parse a declaration">5.3.5. 宣言を構文解析する</h4>

<p class="note">注記：
“`宣言~listを構文解析-$”
するときと異なり，これは~at-ruleではなく 宣言のみを構文解析する。
◎
Note: Unlike "Parse a list of declarations", this parses only a declaration and not an at-rule.
</p>

<p>
`宣言を構文解析-@
するためには：
◎
To parse a declaration:
</p>

<ol>

	<li>
~WHILE ［ `次入力~token$は `whitespace$tok である ］
⇒
`次入力~tokenを消費$する
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>

	<li>
~IF［ `次入力~token$は `ident$tok でない ］
⇒
~RET 構文~error
◎
If the next input token is not an &lt;ident-token&gt;, return a syntax error.
</li>

	<li>
<p>
`宣言^V ~LET `宣言を消費$した結果
</p>

<p>
~IF［ `宣言^V ~NEQ ~nothing ］
⇒
~RET `宣言^V
</p>

<p>
~RET 構文~error
</p>

◎
Consume a declaration. If anything was returned, return it. Otherwise, return a syntax error.
</li>
</ol>

			</section>
			<section id="parse-list-of-declarations">
<h4 title="Parse a list of declarations">5.3.6. 宣言~listを構文解析する</h4>

<p class="note">注記：
その名前に反し、これは，実際には［
宣言と~at-rule
］が混在する~listを構文解析する。
~CSS 2.1 の `page$at に対し行われる様に。
予期されない~at-rule（与えられた文脈の中の，すべてを占め得る）は、無効であり，消費側からは無視される~SHOULDである。
◎
Note: Despite the name, this actually parses a mixed list of declarations and at-rules, as CSS 2.1 does for @page. Unexpected at-rules (which could be all of them, in a given context) are invalid and should be ignored by the consumer.
</p>

<p>
`宣言~listを構文解析-@
するためには：
◎
To parse a list of declarations:
</p>

<ol>
	<li>
~RET `宣言~listを消費$した結果
◎
Consume a list of declarations.
◎
Return the returned list.
</li>

</ol>

			</section>
			<section id="parse-component-value">
<h4 title="Parse a component value">5.3.7. 成分値を構文解析する</h4>

<p>
`成分値を構文解析-@
するためには：
◎
To parse a component value:
</p>

<ol>
	<li>
~WHILE ［ `次入力~token$は `whitespace$tok である ］
⇒
`次入力~tokenを消費$する
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>

	<li>
~IF［ `次入力~token$は `EOF$tok である ］
⇒
~RET 構文~error
◎
If the next input token is an &lt;EOF-token&gt;, return a syntax error.
</li>


	<li>
<p>
`成分値^V ~LET `成分値を消費$した結果
◎
Consume a component value and let value be the return value.
</li>

	<li>
~WHILE ［ `次入力~token$は `whitespace$tok である ］
⇒
`次入力~tokenを消費$する
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>

	<li>
<p>
~IF［ `次入力~token$は `EOF$tok である ］
⇒
~RET `成分値^V
◎
</p>

<p>
~RET 構文~error
</p>

◎
If the next input token is an &lt;EOF-token&gt;, return value. Otherwise, return a syntax error.
</li>
</ol>


			</section>
			<section id="parse-list-of-component-values">
<h4 title="Parse a list of component values">5.3.8. 成分値~listを構文解析する</h4>

<p>
`成分値~listを構文解析-@
するためには：
◎
To parse a list of component values:
</p>

<ol>
	<li>
`~list^V ~LET 空~list
</li>

	<li>
~WHILE ［ `成分値を消費$した結果は `EOF$tok でない ］
⇒
`~list^V にそれを付加する
◎
Repeatedly consume a component value until an &lt;EOF-token&gt; is returned, appending the returned values (except the final &lt;EOF-token&gt;) into a list. Return the list.
</li>

	<li>
~RET `~list^V
</li>

</ol>



			</section>
			<section id="parse-comma-separated-list-of-component-values">

<h4 title="Parse a comma-separated list of component values">5.3.9. カンマ区切りの成分値~listを構文解析する</h4>

<p>
`カンマ区切りの成分値~listを構文解析-@
するためには：
◎
To parse a comma-separated list of component values:
</p>

<ol>
	<li>
`~listの~list^V ~LET 空の［
成分値~listの~list
］
◎
Let list of cvls be an initially empty list of component value lists.
</li>

	<li>
<p>
~WHILE ［ `現入力~token$ ~NEQ `EOF$tok ］：
</p>
		<ol>
			<li>
`~list^V ~LET 空~list
</li>

			<li>
~WHILE ［ `成分値を消費$した結果は `EOF$tok, `comma$tok のいずれでもない ］
⇒
`~list^V にそれを付加する
</li>

			<li>
`~listの~list^V に `~list^V を付加する
</li>
		</ol>

◎
Repeatedly consume a component value until an &lt;EOF-token&gt; or &lt;comma-token&gt; is returned, appending the returned values (except the final &lt;EOF-token&gt; or &lt;comma-token&gt;) into a list. Append the list to list of cvls.
◎
If it was a &lt;comma-token&gt; that was returned, repeat this step.
</li>

	<li>
~RET `~listの~list^V
◎
Return list of cvls.
</li>

</ol>

			</section>


		</section>
		<section id="parser-algorithms">
<h3 title="Parser Algorithms">5.4. 構文解析器~algo</h3>

<p>
構文解析器は、この節に挙げる一連の~algoからなる。
これらは、上述の各種［
構文解析器の入口
］から呼ばれる。
◎
The following algorithms comprise the parser. They are called by the parser entry points above.
</p>

<p>
これらの~algoは，［
~token~list, 成分値~list
］のいずれかを伴って呼ばれ得る。
<!-- 混成／別種？／一部の~algoが？ -->
（`成分値$~listにおいては，一部の~tokenが［
`関数式$や`単純~block$
］に置換される点で異なる）。
~tokenization~段階において，入力~streamから［
それが空であることを表現する~EOF符号位置が返される
］のと同様に、この段階における~listでは、次の~tokenが要請されたにもかかわらず，それが空であるときは、 `EOF$tok を返さ~MUST。
◎
These algorithms may be called with a list of either tokens or of component values. (The difference being that some tokens are replaced by functions and simple blocks in a list of component values.) Similar to how the input stream returned EOF code points to represent when it was empty during the tokenization stage, the lists in this stage must return an &lt;EOF-token&gt; when the next token is requested but they are empty.
</p>

<p>
~algoは，特定の~listを伴って呼出され得る
— この場合、その~listのみを消費する（その~listが枯渇したときは，`EOF$tok を返すようになる）。
他の場合、暗黙的に，呼出している~algoのものと同じ~listを伴って呼出される。
◎
An algorithm may be invoked with a specific list, in which case it consumes only that list (and when that list is exhausted, it begins returning &lt;EOF-token&gt;s). Otherwise, it is implicitly invoked with the same list as the invoking algorithm.
</p>

<div class="trans-note">
<p>
この節における表記
⇒
“~new `~object^V ( `名前^V: `値^V , … )”
</p>

<p>
は、新たに作成される `~object^V の~instanceであって，その各種~~属性が括弧内に記された様に初期化されたものを表す。
</p>
</div>

			<section id="consume-list-of-rules">
<h4 title="Consume a list of rules">5.4.1. 規則~listを消費する</h4>

<p>
`規則~listを消費@
するためには：
◎
To consume a list of rules:
</p>

<ol>
	<li>
`規則~list^V ~LET 空~list
◎
Create an initially empty list of rules.
</li>

	<li>
<p>
`次入力~tokenを繰り返し消費$する：
◎
Repeatedly consume the next input token:
</p>

<dl class="switch">
	<dt>`whitespace$tok</dt>
	<dd>
何もしない
◎
Do nothing.
</dd>

	<dt>`EOF$tok</dt>
	<dd>
~RET `規則~list^V
◎
Return the list of rules.
</dd>

	<dt>`CDO$tok</dt>
	<dt>`CDC$tok</dt>
	<dd>
~IF［
`~top-level~flag@ ~EQ ~OFF
］
⇒
`現入力~tokenを再消費$する ~BR
~IF［ `有修飾~規則を消費$した結果 ~NEQ ~nothing ］
⇒
`規則~list^V にそれを付加する
◎
If the top-level flag is set, do nothing.
◎
Otherwise, reconsume the current input token. Consume a qualified rule. If anything is returned, append it to the list of rules.
</dd>

	<dt>`at-keyword$tok</dt>
	<dd>
`現入力~tokenを再消費$する ~BR
~IF［ `~at-ruleを消費$した結果 ~NEQ ~nothing ］
⇒
`規則~list^V にそれを付加する
◎
Reconsume the current input token. Consume an at-rule. If anything is returned, append it to the list of rules.
</dd>

	<dt>他全部</dt>
	<dd>
`現入力~tokenを再消費$する ~BR
~IF［ `有修飾~規則を消費$した結果 ~NEQ ~nothing ］
⇒
`規則~list^V にそれを付加する
◎
Reconsume the current input token. Consume a qualified rule. If anything is returned, append it to the list of rules.
</dd>

</dl>

	</li>
</ol>

			</section>
			<section id="consume-at-rule">
<h4 title="Consume an at-rule">5.4.2. ~at-ruleを消費する</h4>

<p>
`~at-ruleを消費@
するためには：
◎
To consume an at-rule:
</p>

<ol >
	<li>
`~at-rule^V ~LET ~new `~at-rule$ (
名前: ［ `次入力~tokenを消費$した結果 ］の.値 ,
導入部: 空~list ,
~block: ~nothing
)
◎
Consume the next input token. Create a new at-rule with its name set to the value of the current input token, its prelude initially set to an empty list, and its value initially set to nothing.
</li>

	<li>
<p>
`次入力~tokenを繰り返し消費$する：
◎
Repeatedly consume the next input token:
</p>

<dl class="switch">
	<dt>`semicolon$tok</dt>
	<dd>
~RET `~at-rule^V
◎
Return the at-rule.
</dd>

	<dt>`EOF$tok</dt>
	<dd>
`構文解析error$ ~BR
~RET `~at-rule^V
◎
This is a parse error. Return the at-rule.
</dd>

	<dt>`open-curly$T</dt>
	<dd>
<p>
`~at-rule^V の.~block ~SET `単純~blockを消費$した結果
</p>

<p>
~RET `~at-rule^V
</p>

◎
Consume a simple block and assign it to the at-rule’s block. Return the at-rule.
</dd>

	<dt>`波括弧~block$◎simple block with an associated token of &lt;{-token&gt;</dt>
	<dd>
<p>
`~at-rule^V の.~block ~SET その~block
</p>

<p>
~RET `~at-rule^V
</p>

◎
Assign the block to the at-rule’s block. Return the at-rule.
</dd>

	<dt>他全部</dt>
	<dd>
<p>
`現入力~tokenを再消費$する
</p>

<p>
`~at-rule^V の.導入部に，`成分値を消費$した結果を付加する
</p>

◎
Reconsume the current input token. Consume a component value. Append the returned value to the at-rule’s prelude.
</dd>

</dl>

	</li>
</ol>

			</section>
			<section id="consume-qualified-rule">
<h4 title="Consume a qualified rule">5.4.3. 有修飾~規則を消費する</h4>

<p>
`有修飾~規則を消費@
するためには：
◎
To consume a qualified rule:
</p>

<ol >
	<li>
`規則^V ~LET ~new`有修飾~規則$ (
導入部: 空~list ,
~block: ~nothing
)
◎
Create a new qualified rule with its prelude initially set to an empty list, and its value initially set to nothing.
</li>

	<li>
<p>
`次入力~tokenを繰り返し消費$する：
◎
Repeatedly consume the next input token:
</p>

<dl class="switch">
	<dt>`EOF$tok</dt>
	<dd>
`構文解析error$ ~BR
~RET ~nothing
◎
This is a parse error. Return nothing.
</dd>

	<dt>`open-curly$T</dt>
	<dd>
<p>
`規則^V の.~block ~SET `単純~blockを消費$した結果
</p>

<p>
~RET `規則^V
</p>

◎
Consume a simple block and assign it to the qualified rule’s block. Return the qualified rule.
</dd>



	<dt>`波括弧~block$◎simple block with an associated token of &lt;{-token&gt;</dt>
	<dd>
`規則^V の.~block ~SET その~block ~BR
~RET `規則^V
◎
Assign the block to the qualified rule’s block. Return the qualified rule.
</dd>

	<dt>他全部</dt>
	<dd>
`現入力~tokenを再消費$する ~BR
`規則^V の.導入部に`成分値を消費$した結果を付加する
◎
Reconsume the current input token. Consume a component value. Append the returned value to the qualified rule’s prelude.
</dd>

</dl>

	</li>
</ol>


			</section>
			<section id="consume-list-of-declarations">
<h4 title="Consume a list of declarations">5.4.4. 宣言~listを消費する</h4>

<p>
`宣言~listを消費@
するためには：
◎
To consume a list of declarations:
</p>

<ol>
	<li>
`宣言~list^V ~LET 空~list
◎
Create an initially empty list of declarations.
</li>

	<li>
<p>
`次入力~tokenを繰り返し消費$する：
◎
Repeatedly consume the next input token:
</p>

<dl class="switch">
	<dt>`whitespace$tok</dt>
	<dt>`semicolon$tok</dt>
	<dd>
何もしない
◎
Do nothing.
</dd>

	<dt>`EOF$tok</dt>
	<dd>
~RET `宣言~list^V
◎
Return the list of declarations.
</dd>

	<dt>`at-keyword$tok</dt>
	<dd>
<p>
`現入力~tokenを再消費$する
</p>

<p>
`宣言~list^V に，`~at-ruleを消費$した結果を付加する
</p>

◎
Reconsume the current input token. Consume an at-rule. Append the returned rule to the list of declarations.
</dd>

	<dt>`ident$tok</dt>
	<dd>
<p>
`temp^V ~LET `現入力~token$ のみからなる一時的な~list
</p>


<p>
~WHILE ［ `次入力~token$は `semicolon$tok, `EOF$tok のいずれでもない ］
⇒
`temp^V に`成分値を消費$した結果を付加する
</p>

<p>
~IF［ `temp^V から `宣言を消費$した結果 ~NEQ ~nothing ］
⇒
`宣言~list^V にその結果を付加する
</p>

◎
Initialize a temporary list initially filled with the current input token. As long as the next input token is anything other than a &lt;semicolon-token&gt; or &lt;EOF-token&gt;, consume a component value and append it to the temporary list. Consume a declaration from the temporary list. If anything was returned, append it to the list of declarations.
</dd>

	<dt>他全部</dt>
	<dd>
<p>
`構文解析error$
</p>

<p>
`現入力~tokenを再消費$する
</p>

<p>
~WHILE ［ `次入力~token$は `semicolon$tok, `EOF$tok のいずれでもない ］
⇒
`成分値を消費$（結果は投棄する）
</p>

◎
This is a parse error. Reconsume the current input token. As long as the next input token is anything other than a &lt;semicolon-token&gt; or &lt;EOF-token&gt;, consume a component value and throw away the returned value.
</dd>

</dl>

	</li>
</ol>



			</section>
			<section id="consume-declaration">
<h4 title="Consume a declaration">5.4.5. 宣言を消費する</h4>

<p class="note">注記：
この~algoは，`次入力~token$が `ident$tok であることを前提にする。
◎
Note: This algorithm assumes that the next input token has already been checked to be an &lt;ident-token&gt;. 
</p>

<p>
`宣言を消費@
するためには：
◎
To consume a declaration:
</p>

<ol>

	<li>
<p>
`宣言^V ~LET ~new`宣言$ (
名前: ［ `次入力~tokenを消費$した結果 ］の.値 ,
値: 空~list
)
◎
Consume the next input token. Create a new declaration with its name set to the value of the current input token and its value initially set to the empty list.
</li>

	<li>
~WHILE ［ `次入力~token$は `whitespace$tok である ］
⇒
`次入力~tokenを消費$する
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>

	<li>
<p>
~IF［ `次入力~token$は `colon$tok でない ］
⇒
`構文解析error$ ~BR
~RET ~nothing
◎
If the next input token is anything other than a &lt;colon-token&gt;, this is a parse error. Return nothing.
</p>

<p>
`次入力~tokenを消費$する
◎
Otherwise, consume the next input token.
</p>
	</li>

	<li>
~WHILE ［ `次入力~token$は `EOF$tok でない ］
⇒
`宣言^V の.値に`成分値を消費$した結果を付加する
◎
As long as the next input token is anything other than an &lt;EOF-token&gt;, consume a component value and append it to the declaration’s value.
</li>

	<li>
~IF［
`宣言^V の.値の中の ［
`whitespace$tok でない~token
］のうちの 最後の 2 個が，順に［［
.値 ~EQ `21^UU
］なる `delim$tok, ［
.値 ~AEQ "`important^c"
］なる `ident$tok
］である
］
⇒
その 2 個の~tokenを `宣言^V の.値から除去する ~BR
`宣言^V の.important ~flag ~SET ~ON
◎
If the last two non-&lt;whitespace-token&gt;s in the declaration’s value are a &lt;delim-token&gt; with the value "!" followed by an &lt;ident-token&gt; with a value that is an ASCII case-insensitive match for "important", remove them from the declaration’s value and set the declaration’s important flag to true.
</li>

	<li>
~RET `宣言^V
◎
Return the declaration.
</li>

</ol>




			</section>
			<section id="consume-component-value">
<h4 title="Consume a component value">5.4.6. 成分値を消費する</h4>

<p>
`成分値を消費@
するためには：
◎
To consume a component value:
</p>

<ol>

	<li>
`次入力~tokenを消費$する
◎
Consume the next input token.
</li>


	<li>
~IF［
`現入力~token$は［
`open-curly$T,
`open-square$T,
`open-paren$T
］のいずれかである
］
⇒
~RET `単純~blockを消費$した結果
◎
If the current input token is a &lt;{-token&gt;, &lt;[-token&gt;, or &lt;(-token&gt;, consume a simple block and return it.
</li>

	<li>
~IF ［
`現入力~token$は `function$tok である
］
⇒
~RET `関数式を消費$した結果
◎
Otherwise, if the current input token is a &lt;function-token&gt;, consume a function and return it.
</li>

	<li>
~RET `現入力~token$
◎
Otherwise, return the current input token.
</li>

</ol>

			</section>
			<section id="consume-simple-block">
<h4 title="Consume a simple block">5.4.7. 単純~blockを消費する</h4>

<p class="note">注記：
この~algoは，`現入力~token$は［
`open-curly$T,
`open-square$T,
`open-paren$T
］のいずれかであることを前提にする。
◎
Note: This algorithm assumes that the current input token has already been checked to be an &lt;{-token&gt;, &lt;[-token&gt;, or &lt;(-token&gt;.
</p>

<p>
`単純~blockを消費@
するためには：
◎
To consume a simple block:
</p>

<ol>
	<li><p id="ending-token"><!-- id: 終端 token から移動  -->
`終端ing~token^V ~LET `現入力~token$の “鏡像” ~token
（例えば `open-square$T なら `close-square$T ）
◎
The ending token is the mirror variant of the current input token. (E.g. if it was called with &lt;[-token&gt;, the ending token is &lt;]-token&gt;.)
</li>

	<li>
`block^V ~LET ~new `単純~block$ ( 開き括弧: `現入力~token$ , 値: 空~list )
◎
Create a simple block with its associated token set to the current input token and with a value with is initially an empty list.
</li>

	<li>
<p>
`次入力~tokenを繰り返し消費$する：
◎
Repeatedly consume the next input token and process it as follows:
</p>

<dl class="switch">
	<dt>`終端ing~token^V</dt>
	<dd>
~RET `block^V
◎
Return the block.
</dd>

	<dt>`EOF$tok</dt>
	<dd>
`構文解析error$ ~BR
~RET `block^V
◎
This is a parse error. Return the block.
</dd>

	<dt>他全部</dt>
	<dd>
`現入力~tokenを再消費$する ~BR
`block^V の.値に，`成分値を消費$した結果を付加する
◎
Reconsume the current input token. Consume a component value and append it to the value of the block.
</dd>
</dl>

	</li>
</ol>

			</section>
			<section id="consume-function">
<h4 title="Consume a function">5.4.8. 関数式を消費する</h4>

<p class="note">注記：
この~algoは，`現入力~token$が `function$tok であることを前提にする。
◎
Note: This algorithm assumes that the current input token has already been checked to be a &lt;function-token&gt;.
</p>

<p>
`関数式を消費@
するためには：
◎
To consume a function:
</p>

<ol>
	<li>
`function^V ~LET ~new `関数式$ (
名前: `現入力~token$の.値 ,
値: 空~list
)
◎
Create a function with a name equal to the value of the current input token, and with a value which is initially an empty list.
</li>

	<li>
<p>
`次入力~tokenを繰り返し消費$する：
◎
Repeatedly consume the next input token and process it as follows:
</p>

<dl class="switch">
	<dt>`close-paren$T</dt>
	<dd>
~RET `function^V
◎
Return the function.
</dd>

	<dt>`EOF$tok</dt>
	<dd>
`構文解析error$ ~BR
~RET `function^V
◎
This is a parse error. Return the function. 
</dd>

	<dt>他全部</dt>
	<dd>
`現入力~tokenを再消費$する ~BR
`function^V の.値に，`成分値を消費$した結果を付加する
◎
Reconsume the current input token. Consume a component value and append the returned value to the function’s value.
</dd>
</dl>

	</li>
</ol>


			</section>
		</section>
	</section>
	<section id="anb-microsyntax">
<h2 title="The An+B microsyntax">6. ~AnB 小構文</h2>

<p>
<a href="~SELECTORS#nth-child-pseudo"><code class="pseudo">:nth-child()</code></a>
疑似類など，~CSS の一部の構成子は、［
それが対象にする~list
］内の位置を指示する付番を必要とする。
~AnB 小構文は，作者が~listの中の［
単独の要素や, 一定周期に位置する すべての要素
］を指示し易くするのに有用になる。
◎
Several things in CSS, such as the :nth-child() pseudoclass, need to indicate indexes in a list. The An+B microsyntax is useful for this, allowing an author to easily indicate single elements or all elements at regularly-spaced intervals in a list.
</p>

<p>
`~AnB@ 記法は整数の［
`周期@: `A^V,
`~offset@: `B^V
］を定義し、ゼロ以上のあらゆる整数  `n^V に対する［
~listの中の［
<!-- ~AnB -->
`A^V × `n^V + `B^V
］番目の要素
］を表現する。
ここで，~listの中の最初の要素の付番は（ 0 でなく） 1 とする。
◎
The An+B notation defines an integer step (A) and offset (B), and represents the An+Bth elements in a list, for every positive integer or zero value of n, with the first element in the list having index 1 (not 0).
</p>

<p>
`A^V , `B^V いずれも正の場合、これは実質的に，~listを先頭から順に `A^V 個ずつの要素~groupに分割した上で（最後の~groupは余りの部分になる），各~groupから `B^V 番目の要素を選択する。
◎
For values of A and B greater than 0, this effectively divides the list into groups of A elements (the last group taking the remainder), and selecting the Bth element of each group.
</p>

<p>
~AnB 記法は、~keyword［
`even^css ／ `odd^css
］も受容する。
これらは，それぞれ［
`2n^css ／ <span class="css">2n+1</span>
］と同じ意味になる。
◎
The An+B notation also accepts the even and odd keywords, which have the same meaning as 2n and 2n+1, respectively.
</p>

<div class="example">
<p>◎Example:</p>

<pre>
2n+0   /* <span class="comment"
>~listの中の偶数番目の要素すべてを表現する
◎
represents all of the even elements in the list</span> */
even   /* <span class="comment"
>同じ
◎
same</span> */
4n+1   /* <span class="comment"
>~listの中の［ 1, 5, 9, 13, …］番目の要素すべてを表現する
◎
represents the 1st, 5th, 9th, 13th, etc. elements in the list</span> */</pre>

	</div>

<p>
`A^V, `B^V いずれも負数をとり得るが，いずれにせよ［
`n^V ≥ 0 に対する正の［
`A^V × `n^V + `B^V
］］のみが利用される。
◎
The values of A and B can be negative, but only the positive results of An+B, for n ≥ 0, are used.
</p>

<div class="example">
<p>◎Example:</p>

<pre>
-1n+6   /* <span class="comment"
>~listの中の最初の 6 個の要素を表現する
◎
represents the first 6 elements of the list</span> */
-4n+10  /* <span class="comment"
>~listの中の最初の 2, 6, 10 番目の要素を表現する
◎
represents the 2nd, 6th, and 10th elements of the list</span> */</pre>

	</div>


<p>
`A^V, `B^V いずれも 0 の場合、それを用いる疑似類は，~list内のどの要素も表現しない。
◎
If both A and B are 0, the pseudo-class represents no element in the list.
</p>

		<section id="anb-syntax">
<h3 title="Informal Syntax Description">6.1. 構文（参考）</h3>

~INFORMATIVE

<p>
`A^V が 0 のときは、 ~An 部分が省略されてもよい（ `B^V 部分がすでに省略されていない限り）。
~An が省略されている場合、負でない `B^V の前の `+^c 符号も省略されてよい<!-- (when allowed) ？-->
— この場合の構文は，単に `B^V に単純化される。
◎
When A is 0, the An part may be omitted (unless the B part is already omitted). When An is not included and B is non-negative, the + sign before B (when allowed) may also be omitted. In this case the syntax simplifies to just B.
</p>

<div class="example">
<p>◎Example:</p>

<pre>
0n+5   /* <span class="comment"
>~listの中の 5 番目の要素を表現する
◎
represents the 5th element in the list</span> */
5      /* <span class="comment"
>同じ
◎
same</span> */</pre>

	</div>

<p>
`A^V が ±1 の場合の `1^c は規則から省略されてよい。
◎
When A is 1 or -1, the 1 may be omitted from the rule.
</p>

<div class="example">
<p>◎Example:</p>

<p>
したがって次の記法は，どれも等価になる：
◎
The following notations are therefore equivalent:
</p>

<pre>
1n+0   /* <span class="comment"
>~listの中のすべての要素を表現する
◎
represents all elements in the list</span> */
n+0    /* <span class="comment"
>同じ
◎
same</span> */
n      /* <span class="comment"
>同じ
◎
same</span> */</pre>

	</div>

<p>
`B^V が 0 の場合、毎 `A^V 番目の要素が選ばれる。
このような場合、（ `A^V 部分がすでに省略されていない限り，）
正負符号と `B^V の部分は省略されてよい。
◎
If B is 0, then every Ath element is picked. In such a case, the +B (or -B) part may be omitted unless the A part is already omitted.
</p>

<div class="example">
<p>◎Example:</p>

<pre>
2n+0   /* <span class="comment"
>~listの中の毎~偶数番目の要素を表現する
◎
represents every even element in the list</span> */
2n     /* <span class="comment"
>同じ
◎
same</span> */</pre>

	</div>

<p>
B が負の場合、正符号は負符号に置換する。
◎
When B is negative, its minus sign replaces the + sign.
</p>


<div class="example">
<p>
妥当な例：
◎
Valid example:
</p>

<pre>3n-6</pre>

<p>
妥当でない例：
◎
Invalid example:
</p>

<p>
<pre>3n + -6</pre>

</div>

<p>
~An, `B^V 両者とも在るときは、それらを区切る正負符号の前後には，空白も許可される。
◎
Whitespace is permitted on either side of the + or - that separates the An and B parts when both are present.
</p>

<div class="example">
<p>
空白を伴う妥当な例：
◎
Valid Examples with white space:
</p>

<pre>
3n + 1
+3n - 2
-n+ 6
+6</pre>

		<p>
空白を伴う無効な例：
◎
Invalid Examples with white space:
</p>

<pre>
3 n
+ 2n
+ 2</pre>

</div>


		</section>
		<section id="the-anb-type">
<h3 title="The &lt;an+b&gt; type">6.2. ~anb 型</h3>

<p>
~AnB 記法は、元々は，~CSSの他のものと少しばかり異なる~tokenizerを用いて定義されており、その結果，~CSS~tokenの用語で記される際に，いくぶん不規則な定義になる。
この節では，~CSS~tokenの用語を通して ~AnB 記法を認識する方法（従って， ~CSS文法~目的の ~anb 型を定義することになる），および［ `A^V, `B^V ］に対する値を得るために，これらの~CSS~tokenを解釈する方法を述べる。
◎
The An+B notation was originally defined using a slightly different tokenizer than the rest of CSS, resulting in a somewhat odd definition when expressed in terms of CSS tokens. This section describes how to recognize the An+B notation in terms of CSS tokens (thus defining the &lt;an+b&gt; type for CSS grammar purposes), and how to interpret the CSS tokens to obtain values for A and B.
</p>

<p>
~anb 型は（
`CSS-VALUES$r 仕様の`値定義構文$
を用いて）次の様に定義される：
◎
The &lt;an+b&gt; type is defined (using the Value Definition Syntax in the Values &amp; Units spec) as:
</p>


<pre class="prod">
`~anb@ =
  odd |
  even |
  `integer$t |

  `n-dimension$t |
  '+'?~nB n |
  -n |

  `ndashdigit-dimension$t |
  '+'?~nB `ndashdigit-ident$t |
  `dashndashdigit-ident$t |

  `n-dimension$t `signed-integer$t |
  '+'?~nB n `signed-integer$t |
  -n `signed-integer$t |

  `ndash-dimension$t `signless-integer$t |
  '+'?~nB n- `signless-integer$t |
  -n- `signless-integer$t |

  `n-dimension$t ['+' | '-'] `signless-integer$t<!-- ＊| 欠落 -->
  '+'?~nB n ['+' | '-'] `signless-integer$t |
  -n ['+' | '-'] `signless-integer$t
</pre>


<p>
上に現れ, 下の表の 1 列目に記される各種~生成規則は、［
同じ行の 2 列目の~token
］であって, その各種~~属性が［
同じ行の 3 列目に記された条件
］を満たすものである：
◎
where:
</p>

<div >
<table>

<thead><tr><th>生成規則
</th><th>~token
</th><th>~tokenの~~属性が満たす条件
</th></tr></thead>

<tbody><tr><td>`n-dimension@t
</td><td>`dimension$tok
</td><td>
.型~flag ~EQ "整数" ~AND<br />
.単位 ~AEQ "`n^c"
</td></tr>

<tr><td>`ndash-dimension@t
</td><td>`dimension$tok
</td><td>
.型~flag ~EQ  "整数" ~AND<br />
.単位 ~AEQ "`n-^c"
</td></tr>

<tr><td>`ndashdigit-dimension@t
</td><td>`dimension$tok
</td><td>
.型~flag ~EQ  "整数" ~AND<br />
.単位 ~AEQ "`n-^c`数字~列$"
</td></tr>

<tr><td>`ndashdigit-ident@t
</td><td>`ident$tok
</td><td>
.値 ~AEQ "`n-^c`数字~列$"
</td></tr>

<tr><td>`dashndashdigit-ident@t
</td><td>`ident$tok
</td><td>
.値 ~AEQ "`-n-^c`数字~列$"
</td></tr>

<tr><td>`integer@t
</td><td>`number$tok
</td><td>
.型~flag ~EQ "整数"
</td></tr>

<tr><td>`signed-integer@t
</td><td>`number$tok
</td><td>
.型~flag ~EQ "整数" ~AND<br />
.文字列表現の先頭 ~IN `正負符号$
</td></tr>

<tr><td>`signless-integer@t
</td><td>`number$tok
</td><td>
.型~flag ~EQ  "整数" ~AND<br />
.文字列表現の先頭 ~IN `数字$

</td></tr></tbody></table>

◎
&lt;n-dimension&gt; is a &lt;dimension-token&gt; with its type flag set to "integer", and a unit that is an ASCII case-insensitive match for "n"
◎
&lt;ndash-dimension&gt; is a &lt;dimension-token&gt; with its type flag set to "integer", and a unit that is an ASCII case-insensitive match for "n-"
◎
&lt;ndashdigit-dimension&gt; is a &lt;dimension-token&gt; with its type flag set to "integer", and a unit that is an ASCII case-insensitive match for "n-*", where "*" is a series of one or more digits
◎
&lt;ndashdigit-ident&gt; is an &lt;ident-token&gt; whose value is an ASCII case-insensitive match for "n-*", where "*" is a series of one or more digits
◎
&lt;dashndashdigit-ident&gt; is an &lt;ident-token&gt; whose value is an ASCII case-insensitive match for "-n-*", where "*" is a series of one or more digits
◎
&lt;integer&gt; is a &lt;number-token&gt; with its type flag set to "integer"
◎
&lt;signed-integer&gt; is a &lt;number-token&gt; with its type flag set to "integer", and whose representation starts with "+" or "-"
◎
&lt;signless-integer&gt; is a &lt;number-token&gt; with its type flag set to "integer", and whose representation start with a digit
</div>

<p>
表の中の
`数字~列@
は、`数字$のみからなる，長さ 1 以上の任意の連なりを表す。
</p>

<p id="anb-plus">
上の ~DAGGER 印が付与されている所の様に，［
正符号 (`+^c)
］が［
"`n^c" から開始されている `ident^tok
］に先行するときは，その 2 個の~tokenの合間に空白が在っては~MUST_NOT。
さもなければ，それらの~tokenは上の文法に合致しない。
他の~tokenの合間の空白は妥当である（無視される）。
◎
†: When a plus sign (+) precedes an ident starting with "n", as in the cases marked above, there must be no whitespace between the two tokens, or else the tokens do not match the above grammar. Whitespace is valid (and ignored) between any other two tokens.
</p>

<p>
各~選択肢の~生成規則（~top-levelの "|" で分割された各~項）は、次の様に解釈される：
◎
The clauses of the production are interpreted as follows:
</p>

<div style="overflow:auto;"><table>

<thead><tr><th>生成規則
</th><th>`A^V の値
</th><th>`B^V の値
</th></tr></thead>

<tbody><tr><td>`odd^v
</td><td>2
</td><td>1
</td></tr>

<tr><td>`even^v
</td><td>2
</td><td>0
</td></tr>

<tr><td>`integer$t
</td><td>0
</td><td>`integer$t の.数値
</td></tr>

<tr><td>`n-dimension$t
</td><td>`n-dimension$t の.数値
</td><td>0
</td></tr>

<tr><td>'`+^c'? `n^c
</td><td>1
</td><td>0
</td></tr>


<tr><td>`-n^c
</td><td>−1
</td><td>0
</td></tr>

<tr><td>`ndashdigit-dimension$t
</td><td>`ndashdigit-dimension$t の.数値
</td><td>［
`ndashdigit-dimension$t の.単位から，最初の`符号位置$を除去した残りの部分
］を 10 進~数として解釈した結果
<span class="note">— 負数になる</span>
</td></tr>

<tr><td>'`+^c'? `ndashdigit-ident$t
</td><td>1
</td><td>［
`ndashdigit-ident$t の.値から，最初の`符号位置$を除去した残りの部分
］を 10 進~数として解釈した結果
<span class="note">— 負数になる</span>
</td></tr>

<tr><td>`dashndashdigit-ident$t
</td><td>−1
</td><td>［
`dashndashdigit-ident$t の.値から最初の 2 個の`符号位置$を除去した残りの部分
］を 10 進~数として解釈した結果
<span class="note">— 負数になる</span>
</td></tr>

<tr><td>`n-dimension$t `signed-integer$t
</td><td>`n-dimension$t の.数値
</td><td>`signed-integer$t の.数値
</td></tr>


<tr><td>'`+^c'? `n^c `signed-integer$t
</td><td>1
</td><td>(同上)
</td></tr>


<tr><td>`-n^c `signed-integer$t
</td><td>−1
</td><td>(同上)
</td></tr>

<tr><td>`ndash-dimension$t `signless-integer$t
</td><td>`n-dimension$t の.数値
</td><td>−1 ×［ `signless-integer$t の.数値 ］
</td></tr>


<tr><td>'`+^c'? `n-^c `signless-integer$t
</td><td>1
</td><td>(同上)
</td></tr>


<tr><td>`-n-^c `signless-integer$t
</td><td>−1
</td><td>(同上)
</td></tr>

<tr><td>`n-dimension$t ['`+^c' | '`-^c'] `signless-integer$t
</td><td>`n-dimension$t の.数値
</td><td>`sign^V × ［
`signless-integer$t の.数値
］
— ここで `sign^V は、
['`+^c' | '`-^c'] が［
'`+^c' ならば 1 ／ '`-^c' ならば −1
］
</td></tr>


<tr><td>'`+^c'? `n^c ['`+^c' | '`-^c'] `signless-integer$t
</td><td>1
</td><td>(同上)
</td></tr>


<tr><td>`-n^c ['`+^c' | '`-^c'] `signless-integer$t
</td><td>−1
</td><td>(同上)
</td></tr></tbody>

</table>


<dl lang="en">
	<dt>odd</dt>
	<dd>A is 2, B is 1.</dd>

	<dt>even</dt>
	<dd>A is 2, B is 0.</dd>

	<dt>&lt;integer&gt;</dt>
	<dd>A is 0, B is the integer’s value.</dd>

	<dt>&lt;n-dimension&gt;</dt>
	<dt>'+'? n</dt>
	<dt>-n</dt>
	<dd>A is the dimension’s value, 1, or -1, respectively. B is 0.</dd>

	<dt>&lt;ndashdigit-dimension&gt;</dt>
	<dt>'+'? &lt;ndashdigit-ident&gt;</dt>
	<dd>
A is the dimension’s value or 1, respectively. B is the dimension’s unit or ident’s value, respectively, with the first code point removed and the remainder interpreted as a base-10 number. B is negative.
</dd>

	<dt>&lt;dashndashdigit-ident&gt;</dt>
	<dd>
A is -1. B is the ident’s value, with the first two code points removed and the remainder interpreted as a base-10 number. B is negative.
</dd>

	<dt>&lt;n-dimension&gt; &lt;signed-integer&gt;</dt>
	<dt>'+'? n &lt;signed-integer&gt;</dt>
	<dt>-n &lt;signed-integer&gt;</dt>
	<dd>
A is the dimension’s value, 1, or -1, respectively. B is the integer’s value.
</dd>

	<dt>&lt;ndash-dimension&gt; &lt;signless-integer&gt;</dt>
	<dt>'+'? n- &lt;signless-integer&gt;</dt>
	<dt>-n- &lt;signless-integer&gt;</dt>
	<dd>
A is the dimension’s value, 1, or -1, respectively. B is the negation of the integer’s value.
</dd>

	<dt>&lt;n-dimension&gt; ['+' | '-'] &lt;signless-integer&gt;</dt>
	<dt>'+'? n ['+' | '-'] &lt;signless-integer&gt;</dt>
	<dt>-n ['+' | '-'] &lt;signless-integer&gt;</dt>
	<dd>
A is the dimension’s value, 1, or -1, respectively. B is the integer’s value. If a '-' was provided between the two, B is instead the negation of the integer’s value.
</dd>

</dl></div>




		</section>
	</section>
	<section id="urange">
<h2 title="The Unicode-Range microsyntax">7. Unicode-Range 小構文</h2>

<p>
`font-face$at 規則に対する `unicode-range$css 記述子など，一部の構成子は、 Unicode 符号位置の~~集合を記述する方法を必要とする。
`urange$t
生成規則が， 1 個以上の Unicode 符号位置からなる範囲を表現する。
◎
Some constructs, such as the unicode-range descriptor for the @font-face rule, need a way to describe one or more unicode code points. The &lt;urange&gt; production represents a range of one or more unicode code points.
</p>

<p>
`urange$t 生成規則は，次の様な 3 種の形をとり得る：
◎
Informally, the &lt;urange&gt; production has three forms:
</p>

<dl>
	<dt>`U+0001^v</dt>
	<dd>
単独の符号位置からなる範囲を定義する。
この事例では、符号位置 “1” 。
◎
Defines a range consisting of a single code point, in this case the code point "1".
</dd>

	<dt>`U+0001-00ff^v</dt>
	<dd>
最初の値から最後の値までの符号位置からなる範囲を定義する。
この事例では 1 〜 ff（ 10 進数 255 ）の範囲。
◎
Defines a range of codepoints between the first and the second value, in this case the range between "1" and "ff" (255 in decimal) inclusive.
</dd>

	<dt>`U+00??^v</dt>
	<dd>
文字 "`?^c" がすべての`~hex$に渡るような，符号位置の範囲を定義する。
この事例では、値 `U+0000-00ff^v のときと同じ範囲を定義する。
◎
Defines a range of codepoints where the "?" characters range over all hex digits, in this case defining the same as the value U+0000-00ff.
</dd>
</dl>

<p>
いずれの形でも，（ `?^v も~hexと見なした下で）最大 6 桁までの 16 進数が許容される。
◎
In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
</p>

		<section id="urange-syntax">
<h3 title="The &lt;urange&gt; type">7.1. `urange^t 型</h3>

<p>
`urange$t 記法は 元々， CSS では primitive ~tokenとして定義されていたが、ごく稀にしか利用されず，合法的な `ident$tok と衝突して混同され易い。
この節では、 `urange$t 記法を［
既存の CSS ~tokenを通して認識する, および
Unicode 符号位置の範囲として解釈する
］ための方法を述べる。
◎
The &lt;urange&gt; notation was originally defined as a primitive token in CSS, but it is used very rarely, and collides with legitimate &lt;ident-token&gt;s in confusing ways. This section describes how to recognize the &lt;urange&gt; notation in terms of existing CSS tokens, and how to interpret it as a range of unicode codepoints.
</p>

<p class="note">注記：
ここに述べる構文は、意図的にごく低次であり，実装者~向けのものである。
作者には、 `urange$t を利用するために必要な情報すべてが含まれた，前節の構文の記述で十分である。
◎
Note: The syntax described here is intentionally very low-level, and geared toward implementors. Authors should instead read the informal syntax description in the previous section, as it contains all information necessary to use &lt;urange&gt;, and is actually readable.
</p>

<p>
`urange$t 型は（  `CSS-VALUES$r 仕様の`値定義構文$を用いて），次の様に定義される。
◎
The &lt;urange&gt; type is defined (using the Value Definition Syntax in the Values &amp; Units spec) as:
</p>



<pre class="prod">
`urange@t =
  u '+' `ident$tok '?'* |
  u `dimension$tok '?'* |
  u `number$tok '?'* |
  u `number$tok `dimension$tok |
  u `number$tok `number$tok |
  u '+' '?'+
</pre>


<p>
この生成規則では、どの2つの~tokenの間にも空白は生じ得ない。
◎
In this production, no whitespace can occur between any of the tokens.
</p>

<p>
`urange$t 生成規則は、連続的な Unicode 符号位置の範囲 { `始値^V 〜 `終値^V } を表現する。
`urange$t 生成規則を範囲に解釈するときは、まず，次を実行した結果を得る：
◎
The &lt;urange&gt; production represents a range of one or more contiguous unicode code points as a start value and an end value, which are non-negative integers. To interpret the production above into a range, execute the following steps in order:
</p>

<ol>
	<li>
<p>
`text^V ~LET
生成規則~内の，最初の `u^c ~tokenを除くすべての~tokenの［
.文字列表現, あるいは `dimension$tok の場合は.文字列表現と.単位
］を連結した結果
◎
Skipping the first u token, concatenate the representations of all the tokens in the production together (or, in the case of &lt;dimension-token&gt;s, the representation followed by the unit). Let this be text.
</p>

</li>
	<li>
~IF
`text^V の最初の`符号位置$を消費した結果 ~NEQ `2B^UU
⇒
~RET 無効（すなわち， `urange$t は無効である — 以下~同様）
◎
If the first character of text is U+002B PLUS SIGN, consume it. Otherwise, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>

	<li>
<p>
`N^V ~LET
`text^V から，できるだけ多くの`~hex$を消費してから，できるだけ多くの`符号位置$ `3F^UU を消費した結果
◎
↓</p>

<p>
~IF ［
`N^V の長さ ~EQ 0 ~OR
`N^V の長さ ~GT 6
］
⇒
~RET 無効
◎
Consume as many hex digits from text as possible. then consume as many U+003F QUESTION MARK (?) code points as possible. If zero code points were consumed, or more than six code points were consumed, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</p>

<p>
~IF
`3F^UU `符号位置$が消費された：
◎
If any U+003F QUESTION MARK (?) code points were consumed, then:
</p>

		<ol>
			<li>
~IF
`text^V は消費され尽くされてない
⇒
~RET 無効
◎
If there are any code points left in text, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>
			<li>
`始値^V ~SET
`N^V の中の `3F^UU を `30^UU に置換した上で，
16 進数として解釈した結果
◎
Interpret the consumed code points as a hexadecimal number, with the U+003F QUESTION MARK (?) code points replaced by U+0030 DIGIT ZERO (0) code points. This is the start value.
</li>
			<li>
`終値^V ~SET
`N^V の中の `3F^UU を `46^UU に置換した上で，
16 進数として解釈した結果
◎
Interpret the consumed code points as a hexadecimal number again, with the U+003F QUESTION MARK (?) code points replaced by U+0046 LATIN CAPITAL LETTER F (F) code points. This is the end value.
</li>
			<li>
~RET 範囲 { `始値^V 〜 `終値^V }
◎
Exit this algorithm.
</li>
		</ol>
	</li>
	<li>
`始値^V ~SET `N^V を 16 進数として解釈した結果
◎
Otherwise, interpret the consumed code points as a hexadecimal number. This is the start value.
</li>

	<li>
~IF
`text^V は消費され尽くした
⇒
~RET 範囲 { `始値^V 〜 `始値^V }
◎
If there are no code points left in text, The end value is the same as the start value. Exit this algorithm.
</li>
	<li>
~IF
`text^V の次の`符号位置$を消費した結果 ~NEQ `2D^UU
⇒
~RET 無効
◎
If the next code point in text is U+002D HYPHEN-MINUS (-), consume it. Otherwise, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>

	<li>
<p>
`N^V ~LET
`text^V から，できるだけ多くの`~hex$を消費した結果
◎
Consume as many hex digits as possible from text.
</p>

<p>
~IF ［
`N^V の長さ ~EQ 0 ~OR
`N^V の長さ ~GT 6
］~OR［
`text^V は消費され尽くされてない
］
⇒
~RET 無効
◎
If zero hex digits were consumed, or more than 6 hex digits were consumed, this is an invalid &lt;urange&gt;, and this algorithm must exit. If there are any code points left in text, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</p>

	</li>

	<li>
`終値^V ~SET `N^V を 16 進数として解釈した結果 ~BR
~RET 範囲 { `始値^V 〜 `終値^V }
◎
Interpret the consumed code points as a hexadecimal number. This is the end value.
</li>

</ol>

<p>
上の結果の範囲 { `始値^V 〜 `終値^V } において，［
`終値^V ~GT `許容される最大の符号位置$
］~OR［
`始値^V ~GT `終値^V
］ならば、 `urange$t は<strong>無効であり，構文~error</strong>とする。
◎
To determine what codepoints the &lt;urange&gt; represents:
◎
If end value is greater than the maximum allowed code point, the &lt;urange&gt; is invalid and a syntax error.
◎
If start value is greater than end value, the &lt;urange&gt; is invalid and a syntax error.
◎
Otherwise, the &lt;urange&gt; represents a contiguous range of codepoints from start value to end value, inclusive.
</p>

<p class="note">注記：
`urange$t の構文は、その~patternが，前節の構文（参考）が生成し得るすべての~token並びを捉える以上に，意図的に幅広くしてある。
ただし，各~tokenの合間には空白を挟めないので、実用上は比較的安全に利用できる：
ある構成子の文法が［
`urange$t, ［
`number$t ／ `dimension$t
］］の並びを含むとしても（作者が `urange$t を［
`u^c, `number$t
］の並びで指定した場合に多義的になり得る）、実際にはごく安全である
— 多義的になるためには、作者が
`urange$t と［
`number$t ／ `dimension$t
］を，空白ではなく，~commentで意図的に区切る必要があるので。
作者は，構文解析を惑わすように書くことも<em>可能である</em>が、そのためには実際のコード自体も紛らわしく書く必要がある。
◎
Note: The syntax of &lt;urange&gt; is intentionally fairly wide; its patterns capture every possible token sequence that the informal syntax can generate. However, it requires no whitespace between its constituent tokens, which renders it fairly safe to use in practice. Even grammars which have a &lt;urange&gt; followed by a &lt;number&gt; or &lt;dimension&gt; (which might appear to be ambiguous if an author specifies the &lt;urange&gt; with the ''u &lt;number&gt;'' clause) are actually quite safe, as an author would have to intentionally separate the &lt;urange&gt; and the &lt;number&gt;/&lt;dimension&gt; with a comment rather than whitespace for it to be ambiguous. Thus, while it’s possible for authors to write things that are parsed in confusing ways, the actual code they’d have to write to cause the confusion is, itself, confusing and rare.
</p>

		</section>
	</section>
	<section id="rule-defs">
<h2 title="Defining Grammars for Rules and Other Values">8. 規則や他の値のための文法を定義するとき</h2>

<p>
`CSS-VALUES$r 仕様では、~propのための文法を指定する方法が定義されている。
この節は、同じ文法を， CSS 規則のために定義する。
◎
The Values spec defines how to specify a grammar for properties. This section does the same, but for rules.
</p>

<p>
~prop文法とちょうど同じく，記法 `foo^t は、文法記号 "`foo^V" を参照する
— それが，他で定義されていることを前提にして。
`foo^t をその定義に置換えた結果は、意味論的に同じ文法になる。
◎
Just like in property grammars, the notation &lt;foo&gt; refers to the "foo" grammar term, assumed to be defined elsewhere. Substituting the &lt;foo&gt; for its definition results in a semantically identical grammar.
</p>

<p>
~tokenの型のうちの いくつかは、引用符で括られずに，~literalとして記される：
◎
Several types of tokens are written literally, without quotes:
</p>

<ul>
	<li>
`ident$tok （
`auto^v,
`disc^v,
等々）
は，単純にそれらの.値で記される。
◎
&lt;ident-token&gt;s (such as auto, disc, etc), which are simply written as their value.
</li>

	<li>
`at-keyword$tok は，［
文字  "<code>@</code>",
~tokenの.値
］の並びとして記される。
例えば `media^at 。
◎
&lt;at-keyword-token&gt;s, which are written as an @ character followed by the token’s value, like @media.
</li>

	<li>
`function$tok は、［
関数~名<!-- ？ -->,
文字 "`(^c"
］の並びとして記される
— 例えば <code>translate(</code>
◎
&lt;function-token&gt;s, which are written as the function name followed by a ( character, like translate(.
</li>

	<li>
`colon$tok （ "<code>:</code>" と記される ）,
`comma$tok （ "<code>,</code>" と記される ）,
`semicolon$tok （ "<code>;</code>" と記される ）,
`open-paren$T,
`close-paren$T,
`open-curly$T,
`close-curly$T
◎
The &lt;colon-token&gt; (written as :), &lt;comma-token&gt; (written as ,), &lt;semicolon-token&gt; (written as ;), &lt;(-token&gt;, &lt;)-token&gt;, &lt;{-token&gt;, and &lt;}-token&gt;s.
</li></ul>

<p>
~tokenは、その値~DAGGERが［
`~ASCII文字大小無視$で，文法において定義される値に合致する
］とき，合致するとされる。
◎
Tokens match if their value is an ASCII case-insensitive match for the value defined in the grammar.
</p>

<p class="trans-note">【
~DAGGER “~tokenの値” — 明文化されていないが、~tokenが［
（~~属性として）.値を持つ場合は その.値 ／
持たない場合は その~tokenを表現する文字列
］を意味するものと思われる。
】</p>

<p class="note">
`~escaping$により，.値が［
"<code>(</code>" で終端する ／
"<code>@</code>" で開始する
］ような `ident$tok を構築することも可能であるが、その種の~tokenは，［
`function$tok ／ `at-keyword$tok
］ではなく, 対応する文法~定義には合致しない。
◎
Although it is possible, with escaping, to construct an &lt;ident-token&gt; whose value ends with ( or starts with @, such a tokens is not a &lt;function-token&gt; or an &lt;at-keyword-token&gt; and does not match corresponding grammar definitions.
</p>

<p>
`delim$tok は、その.値を一重引用符で括って記される。
例えば，［［
値: `符号位置$ "+"
］を伴う `delim$tok
］は、
<code>'+'</code>
のように記される。
同様に,［
`open-square$T や `close-square$T
］も，一重引用符で括って記され~MUST。
それらの.値は、項たちを~group化するために，文法それ自身の構文にて利用されるので。
`whitespace$tok は、文法の中では決して指示されず，［
~tokenの前後, および 2 個の~tokenの合間
］に許容される
— ただし，定義の注釈文から明示的に指定される場合を除く（例えば，規則の.導入部が選択子である場合，空白は有意になる）
◎
&lt;delim-token&gt;s are written with their value enclosed in single quotes. For example, a &lt;delim-token&gt; containing the "+" code point is written as '+'. Similarly, the &lt;[-token&gt; and &lt;]-token&gt;s must be written in single quotes, as they’re used by the syntax of the grammar itself to group clauses. &lt;whitespace-token&gt; is never indicated in the grammar; &lt;whitespace-token&gt;s are allowed before, after, and between any two tokens, unless explicitly specified otherwise in prose definitions. (For example, if the prelude of a rule is a selector, whitespace is significant.)
</p>

<p>
［
関数式／~block
］を定義する際には、その文法において 終端ing~tokenが指定され~MUSTが、最終的に~token~stream内に不在の場合でも，依然として合致する。
◎
When defining a function or a block, the ending token must be specified in the grammar, but if it’s not present in the eventual token stream, it still matches.
</p>

<div class="example">
<p>
例えば，関数式 `translateX()$css の構文は：
◎
For example, the syntax of the translateX() function is:
</p>

<pre>
translateX( `translation-value$t )</pre>


<p>
しかしながら，~stylesheetは、この関数式が閉じられないまま終端されてもよい
— 次の様に：
◎
However, the stylesheet may end with the function unclosed, like:
</p>

<pre>
.foo { transform: translate(50px</pre>


<p>
~CSS構文解析器は，これを［［［［
`関数式$であって，その.名前は "`translate^c" であるもの
］のみからなる`成分値$~list
］を.値に持つ， 1 個の`宣言$
］を包含している~style規則
］として構文解析する。
これは、終端ing~tokenが~token~streamの中に現れなくても，上の文法には合致するものとされる。
構文解析器を抜けた時点で，終端ing~tokenの有無は決定できなくなり、~blockと関数式があるという事実のみが残るので。
◎
The CSS parser parses this as a style rule containing one declaration, whose value is a function named "translate". This matches the above grammar, even though the ending token didn’t appear in the token stream, because by the time the parser is finished, the presence of the ending token is no longer possible to determine; all you have is the fact that there’s a block and a function.
</p></div>



		<section id="declaration-rule-list">
<h3 title="Defining Block Contents: the &lt;declaration-list&gt;, &lt;rule-list&gt;, and &lt;stylesheet&gt; productions">8.1. ~block内容を定義する生成規則： `declaration-list^t, `rule-list^t, `stylesheet^t</h3>

<p>
~CSS構文解析器は、~blockの内容に非依存である —
例えば何らかの~at-ruleの終端に来るものなど。
~blockの汎用~文法を~tokenの用語を通して定義することは，自明でないが、それを構文解析するために定義される，一義的な専用の~algoが用意されている：
◎
The CSS parser is agnostic as to the contents of blocks, such as those that come at the end of some at-rules. Defining the generic grammar of the blocks in terms of tokens is non-trivial, but there are dedicated and unambiguous algorithms defined for parsing this.
</p>

<p>
`declaration-list@t 生成規則は，宣言~listを表現する。
それは，文法においては［
~block全体を占める値
］としてのみ，利用され得る。
それは，~blockの内容が［
`宣言~listを消費$する~algoを用いて構文解析され~MUST
］ことを表現する。
◎
The &lt;declaration-list&gt; production represents a list of declarations. It may only be used in grammars as the sole value in a block, and represents that the contents of the block must be parsed using the consume a list of declarations algorithm.
</p>

<p>
同様に、 `rule-list@t 生成規則は，規則~listを表現し、文法においては［
~blockの全体を占める値
］としてのみ，利用され得る。
それは，~blockの内容が［
`規則~listを消費$する~algoを用いて構文解析され~MUST
］ことを表現する。
◎
Similarly, the &lt;rule-list&gt; production represents a list of rules, and may only be used in grammars as the sole value in a block. It represents that the contents of the block must be parsed using the consume a list of rules algorithm.
</p>

<p>
最後に、 `stylesheet@t 生成規則は，規則~listを表現する。
それは、それを用いている~blockが，［
特定0の文脈に制限されるようなものを除く，すべての規則
］を 既定で受容することを除いて、 `rule-list$t と同じである。
◎
Finally, the &lt;stylesheet&gt; production represents a list of rules. It is identical to &lt;rule-list&gt;, except that blocks using it default to accepting all rules that aren’t otherwise limited to a particular context.
</p>

<div class="example">
<p>
例えば， `font-face$at 規則は、［
その.導入部が空であって,
宣言~listを包含する
］ものと定義されている。
これは、次の文法により記される：
◎
For example, the @font-face rule is defined to have an empty prelude, and to contain a list of declarations. This is expressed with the following grammar:
</p>

<pre>
@font-face { `declaration-list$t }</pre>


<p>
これは、規則の文法として，完全かつ十分な定義である。
◎
This is a complete and sufficient definition of the rule’s grammar.
</p>

<p>
別の例として， `keyframes$at 規則は、その［
.導入部に
<span class="trans-note">【~animationの】</span>
名前が伴われていて,
その.~block内には 一連の~keyframe規則が包含されている
］ものと解釈される点で，より複雑である。
その文法は次の様になる：
◎
For another example, @keyframes rules are more complex, interpreting their prelude as a name and containing keyframes rules in their block Their grammar is:
</p>

<pre>
@keyframes `keyframes-name^t { `rule-list$t }</pre>

</div>

<p>
`declaration-list$t を利用する規則に対しては、その規則を定める仕様は，規則の内側において どの［
~prop ／記述子／~at-rule
］が妥当であるかを定義し~MUST
—
これは，単純に、
“`foo^at 規則 は，この仕様（または節）にて定義される ~propと記述子 を受容する”
，といった風に、あるいは，拡張~仕様は，
“`foo^at 規則は，追加で以下の~prop／記述子を受容する”
，といった風に述べ得る。
~blockの内側にて見出された，妥当なものとして定義されていない，どの宣言／~at-ruleも、その規則の値から除去され~MUST。
◎
For rules that use &lt;declaration-list&gt;, the spec for the rule must define which properties, descriptors, and/or at-rules are valid inside the rule; this may be as simple as saying "The @foo rule accepts the properties/descriptors defined in this specification/section.", and extension specs may simply say "The @foo rule additionally accepts the following properties/descriptors.". Any declarations or at-rules found inside the block that are not defined as valid must be removed from the rule’s value.
</p>

<p>
`declaration-list$t 内では、どの記述子であれ，その~importantは自動的に無効になる。
ある規則がある~propを受容する場合、その規則を定める仕様は，［
その~propが~cascadeに作用し得るかどうか, および
どの`詳細度$で作用するか
］を定義し~MUST。
~cascadeに作用しない~propが~importantを包含している場合、自動的に無効になる。
他の~propにおける~importantは，妥当であり、その~propの~cascadeの`出自$に対し，通例の効果を持つ。
◎
Within a &lt;declaration-list&gt;, !important is automatically invalid on any descriptors. If the rule accepts properties, the spec for the rule must define whether the properties interact with the cascade, and with what specificity. If they don’t interact with the cascade, properties containing !important are automatically invalid; otherwise using !important is valid and has its usual effect on the cascade origin of the property.
</p>

<div class="example">
<p>
例えば，前の例の `font-face$at のための文法は、そこに記されたものに加えて，［
許容される宣言は， Fonts 仕様にて定義される記述子である
］ものと定義し~MUST。
◎
For example, the grammar for @font-face in the previous example must, in addition to what is written there, define that the allowed declarations are the descriptors defined in the Fonts spec.
</p>
	</div>

<p>
`rule-list$t を利用する `規則^V においても、 `declaration-list$t のときと同様に，その `規則^V を定める仕様が，［
どの型の規則が，その `規則^V の中で妥当になるか
］を定義し~MUST。
同様に、認識されない規則は，その `規則^V の値から除去され~MUST。
◎
For rules that use &lt;rule-list&gt;, the spec for the rule must define what types of rules are valid inside the rule, same as &lt;declaration-list&gt;, and unrecognized rules must similarly be removed from the rule’s value.
</p>

<div class="example">
<p>
例えば，先の例の `keyframes$at の文法は、そこに記されたものに加えて，次の様に［
許容される規則は， `keyframe-rules$t のみである
］ことを定義し~MUST：
◎
For example, the grammar for @keyframes in the previous example must, in addition to what is written there, define that the only allowed rules are &lt;keyframe-rule&gt;s, which are defined as:
</p>

<pre>
`keyframe-rule^t = `keyframe-selector^t { `declaration-list$t }</pre>


<p>
~blockの中の~keyframe規則は更に，［
~animatableなすべての~CSS~propを宣言として受容すること
］に加えて, ［
`animation-timing-function$css ~propを受容すること
］，一方で［
それらが~cascadeに作用しないこと
］を定義し~MUST。
◎
Keyframe rules, then, must further define that they accept as declarations all animatable CSS properties, plus the animation-timing-function property, but that they do not interact with the cascade.
</p></div>

<p>
`stylesheet$t を利用する `規則^V においては，すべての規則が既定で許容されるが、その `規則^V を定める仕様は，その `規則^V の内側では <em>無効になる</em> 規則を定義して~MAY。
◎
For rules that use &lt;stylesheet&gt;, all rules are allowed by default, but the spec for the rule may define what types of rules are invalid inside the rule.
</p>

<div class="example">
<p>
例えば， `media$at 規則は、 `media^at 規則~自身を除く，~stylesheet内に置き得るものすべてを受容する。
従って、その文法は次の様になる：
◎
For example, the @media rule accepts anything that can be placed in a stylesheet, except more @media rules. As such, its grammar is:
</p>

<pre>
@media `media-query-list$t { `stylesheet$t }</pre>

<p>
加えて，［
`stylesheet$t は `media$at 規則を包含できない
］とする制約も定義する。
その結果、中に現れる `media^at 規則は，外側の `media^at 規則の値から棄てられることになる。
◎
It additionally defines a restriction that the &lt;stylesheet&gt; can not contain @media rules, which causes them to be dropped from the outer rule’s value if they appear.
</p></div>

		</section>
		<section id="any-value">
<h3 title="Defining Arbitrary Contents: the &lt;declaration-value&gt; and &lt;any-value&gt; productions">8.2. 任意の内容を定義するもの： `declaration-value^t, `any-value^t 生成規則</h3>

<p>
文法によっては、ある~~程度までの入力を受容して，その~errorを（単純に，文法への不一致により構成子を即 無効にする方式をとるのでなく，）~~特別に取扱う方が有用になる場合もある。
◎
In some grammars, it is useful to accept any reasonable input in the grammar, and do more specific error-handling on the contents manually (rather than simply invalidating the construct, as grammar mismatches tend to do).
</p>


<p>
例えば，`~custom~prop$は、［
他の CSS ~propがとる値の成分も包含し得る
］ような, あるいは［
既存の CSS に全く含まれないものに利用される
］ような，ある~~程度の値を許容する。
他の例として、 Media Queries の
<a href="~MQ4#typedef-general-enclosed">`general-enclosed^t</a>
生成規則は、将来の Media Queries 構文が許容し得るものを定義して，
“未知の” 値を特別な~~規則で~~扱う。
◎
For example, custom properties allow any reasonable value, as they can contain arbitrary pieces of other CSS properties, or be used for things that aren’t part of existing CSS at all. For another example, the &lt;general-enclosed&gt; production in Media Queries defines the bounds of what future syntax MQs will allow, and uses special logic to deal with "unknown" values.
</p>


<p>
これを~~補助するため、二つの生成規則が追加で定義される：
◎
To aid in this, two additional productions are defined:
</p>


<dl>
	<dt>`declaration-value@t</dt>
	<dd>
<p>
この生成規則は、<em>どの</em>［
一個以上の~token並び
］にも，その並びが次のものを包含していない限り，合致する：
</p>

<ul>
	<li>
対になっていない［
`bad-string$tok ／
`bad-url$tok ／
`close-paren$T ／
`close-square$T ／
`close-curly$T
］
</li>
	<li>
~top-levelの `semicolon$tok
</li>
	<li>
"<code>!</code>" を.値にとる `delim$tok
</li>
</ul>

<p>
それは、それ全体として［
妥当な宣言がとり得る値
］を表現する。
</p>

◎
The &lt;declaration-value&gt;
production matches any sequence of one or more tokens, so long as the sequence does not contain &lt;bad-string-token&gt;, &lt;bad-url-token&gt;, unmatched &lt;)-token&gt;, &lt;]-token&gt;, or &lt;}-token&gt;, or top-level &lt;semicolon-token&gt; tokens or &lt;delim-token&gt; tokens with a value of "!". It represents the entirety of what a valid declaration can have as its value.
</dd>

	<dt>`any-value@t</dt>
	<dd>
この生成規則は、前項の 2 番目, 3 番目に挙げた~tokenも許容されることを除いて， `declaration-value$t と同じである。
それは、それ全体として［
何らかの文脈の下で，妥当な CSS になり得るもの
］を表現する。
◎
The &lt;any-value&gt;
production is identical to &lt;declaration-value&gt;, but also allows top-level &lt;semicolon-token&gt; tokens and &lt;delim-token&gt; tokens with a value of "!". It represents the entirety of what valid CSS can be in any context.
</dd>
</dl>

<div >


</div>






		</section>
	</section>
	<section id="css-stylesheets">
<h2 title="CSS stylesheets">9. ~CSS~stylesheet</h2>

<p>
`~CSS~stylesheetを構文解析-@
するためには：
まず，`~stylesheetを構文解析-^iした上で、結果の中のすべての［
~top-levelの `有修飾~規則^i
］のそれぞれを，下に定義されるように `~style規則^iとして解釈する。
◎
To parse a CSS stylesheet, first parse a stylesheet. Interpret all of the resulting top-level qualified rules as style rules, defined below.
</p>

<p>
［
`無効$な~style規則 ／
認識されない~at-rule ／
その文法あるいは文脈に則って 無効な~at-rule
］は、`構文解析error^iであり，破棄される。
◎
If any style rule is invalid, or any at-rule is not recognized or is invalid according to its grammar or context, it’s a parse error. Discard that rule.
</p>

		<section id="style-rules">
<h3 title="Style rules">9.1. ~style規則</h3>

<p>
`~style規則@
は、［
`選択子~list$ `SELECT$r
］と［
~prop宣言~list
］を結付ける `有修飾~規則^iである。
それらは `CSS21$r の中では，`規則集合$とも呼ばれている。
~style規則の内側の宣言が~cascadeにどの様に関与するかは、
CSS Cascading and Inheritance `CSS3CASCADE$r
が定義する。
◎
A style rule is a qualified rule that associates a selector list [SELECT] with a list of property declarations. They are also called rule sets in [CSS21]. CSS Cascading and Inheritance [CSS3CASCADE] defines how the declarations inside of style rules participate in the cascade.
</p>

<p>
有修飾~規則の.導入部は，`選択子~list$として構文解析される。
この結果が`無効な選択子~list$になった場合、その~style規則~全体が`無効$になる。
◎
The prelude of the qualified rule is parsed as a selector list. If this results in an invalid selector list, the entire style rule is invalid.
</p>

<p>
有修飾~規則の~blockの内容は， `宣言~list$として構文解析される。
別の仕様やこの仕様の将来~levelにて定義されない限り、~listの中の~at-ruleは`無効$であり，無視され~MUST。
［
未知の, あるいは値が~propに定義される構文に合致しないような
］~CSS~propの宣言は、`無効$であり，無視され~MUST。
~style規則の内容の妥当性は、~style規則~自身の妥当性には~~影響しない。
他から定義されない限り，~prop名は`~ASCII文字大小無視$である。
◎
The content of the qualified rule’s block is parsed as a list of declarations. Unless defined otherwise by another specification or a future level of this specification, at-rules in that list are invalid and must be ignored. Declaration for an unknown CSS property or whose value does not match the syntax defined by the property are invalid and must be ignored. The validity of the style rule’s contents have no effect on the validity of the style rule itself. Unless otherwise specified, property names are ASCII case-insensitive.
</p>

<p class="note">注記：
`~custom~prop$ `CSS-VARIABLES$r の名前の文字大小は区別される。
◎
Note: The names of Custom Properties [CSS-VARIABLES] are case-sensitive.
</p>

<p>
~CSS~stylesheetの~top-levelの`有修飾~規則^iは，~style規則である。
他の文脈における有修飾~規則が~style規則になるかどうかは、その文脈の定義に従う。
◎
Qualified rules at the top-level of a CSS stylesheet are style rules. Qualified rules in other contexts may or may not be style rules, as defined by the context.
</p>

<p class="example">
例えば，
`media$at 規則  `CSS3-CONDITIONAL$r の内側の有修飾~規則は，~style規則であるが、
`keyframes$at 規則  `CSS3-ANIMATIONS$r の内側の有修飾~規則は，そうでない。
◎
For example, qualified rules inside @media rules [CSS3-CONDITIONAL] are style rules, but qualified rules inside @keyframes rules are not [CSS3-ANIMATIONS].
</p>

		</section>
		<section id="charset-rule">
<h3 title="The @charset Rule">9.2. `charset^at 規則</h3>

<p>
~stylesheetに対する`~fallback符号化方式を決定する$~algoは、特定の~byte並び
— 名前 "`charset^at" の`~at-rule$を構文形に持つような, ~file内の先頭に位置する少数の~byte列 —
を検索する。
◎
The algorithm used to determine the fallback encoding for a stylesheet looks for a specific byte sequence as the very first few bytes in the file, which has the syntactic form of an at-rule named "@charset".
</p>


<p>
しかしがら、名前 `charset@at の`~at-rule$は，実際には~~存在しない。
~stylesheetが実際に構文解析されるとき，
`charset$at 規則のどの出現も、認識されない規則として扱った上で,
~stylesheetの文法が検査されるときは無効なものとして棄てられ~MUST。
◎
However, there is no actual at-rule named @charset. When a stylesheet is actually parsed, any occurrences of an @charset rule must be treated as an unrecognized rule, and thus dropped as invalid when the stylesheet is grammar-checked.
</p>


<p class="note">注記：
`~stylesheetを構文解析-$する~algoは、~stylesheetの文法が検査される前に，文書から最初の `charset$at 規則を明示的に棄てる
— したがって， `import$at など，~stylesheet内に最初に出現し~MUST妥当な規則の後に、依然として，その存在自体は無効にされていない（が，無効な） `charset$at 規則が来ることもある。
◎
Note: The algorithm to parse a stylesheet explicitly drops the first @charset rule from the document, before the stylesheet is grammar-checked, so valid rules that must appear first in the stylesheet, such as @import, can still be preceded by an (invalid) @charset rule without making themselves invalid.
</p>


<p class="note">注記：
CSS 2.1 においては、 `charset$at は妥当な規則であった。
旧来の仕様には、依然として， `charset$at 規則を参照して, ~stylesheet内における その有無について明示的に~~述べているものもある。
◎
Note: In CSS 2.1, @charset was a valid rule. Some legacy specs may still refer to a @charset rule, and explicitly talk about its presence in the stylesheet.
</p>


		</section>
	</section>
	<section id="serialization">
<h2 title="Serialization">10. 直列化</h2>

<p>
この仕様にて述べられる~tokenizerは、~commentに対応する~token, あるいは 何らかの方法でそれらを保全するものは，生産しない。
実装は、~commentの内容と, ［
~token~streamの中における それらの所在
］を保全してよい
<span class="trans-note">【
以下において “<dfn>保全~comment</dfn>” と記される
】</span>
。
その場合、その保全されている情報が，構文解析処理の段に~~影響しては~MUST_NOT。
◎
The tokenizer described in this specification does not produce tokens for comments, or otherwise preserve them in any way. Implementations may preserve the contents of comments and their location in the token stream. If they do, this preserved information must have no effect on the parsing step.
</p>

<p>
この仕様は、~CSSを直列化するための一般の方法は 定義しない。
その仕事は、 CSSOM, および 個々の特色機能の仕様に委ねられる。
特に，~commentや空白の直列化は定義されない。
◎
This specification does not define how to serialize CSS in general, leaving that task to the CSSOM and individual feature specifications. In particular, the serialization of comments and whitespace is not defined.
</p>

<p>
直列化に課される唯一の要件は、構文解析処理と “往来” でき~MUSTことである。
すなわち，~stylesheetの構文解析処理においては、［
連続する `whitespace$tok が単独の~tokenに縮約されてよい~DAGGER
］ことを除き，［
その結果
］と［
それを更に直列化して, もう一度~構文解析した結果
］が，同じ~data構造を生産し~MUST。
◎
The only requirement for serialization is that it must "round-trip" with parsing, that is, parsing the stylesheet must produce the same data structures as parsing, serializing, and parsing again, except for consecutive &lt;whitespace-token&gt;s, which may be collapsed into a single token.
</p>

<p class="note">注記~DAGGER：
上の例外は、~CSS文法が，任意の量の空白を 常に単独のスペースと同一視することに因る。
◎
Note: This exception can exist because CSS grammars always interpret any amount of whitespace as identical to a single space.
</p>

<div class="note" id="serialization-tables">

<p>
この要件を満たすためには：
◎
To satisfy this requirement:
</p>

<ul>
			<li>
［
`5C^UU を.値にとる `delim$tok
］は、［
`5C^U,
`改行$
］の並びとして直列化され~MUST。
（~tokenizerが その種の~tokenを~emitするときは、必ず［
改行から開始される `whitespace$tok
］を後続させる。）
◎
A &lt;delim-token&gt; containing U+005C REVERSE SOLIDUS (\) must be serialized as U+005C REVERSE SOLIDUS followed by a newline. (The tokenizer only ever emits such a token followed by a &lt;whitespace-token&gt; that starts with a newline.)
</li>

	<li>
［
.型~flag に "無制約" を伴う `hash$tok
］に要する~escapeが，［
.型~flag に "id" を伴う，同じ~token
］より多くなることはない。
◎
A &lt;hash-token&gt; with the "unrestricted" type flag may not need as much escaping as the same token with the "id" type flag.
</li>

	<li>
`dimension$tok の.単位は、科学的記数法と区別するために，~escapeを要し得る。
◎
The unit of a &lt;dimension-token&gt; may need escaping to disambiguate with scientific notation.
</li>

	<li>
<p>
下の 2 つの表の中で，チェック（ ✗ ）が入っている欄の［［
上端の見出しに示されている~token,
左端の見出しに示されている~token
］が，この順に連続して直列化されるときは、それらの合間に~commentが伴われ~MUST。
◎
For any consecutive pair of tokens, if the first token shows up in the row headings of either of the following two tables, and the second token shows up in the column headings, and there’s a ✗ in the cell denoted by the intersection of the chosen row and column, the pair of tokens must be serialized with a comment between them.
</p>

<p>
~tokenizerが~commentを保全する場合，保全~commentが利用される~SHOULDである。
そうでなければ［
空の~comment（ `/**/^c ）
］が挿入され~MUST。
（保全~commentは、下の表による， 2 個の~tokenの合間の~commentが要求されない所でも，再挿入されてよい。）
◎
If the tokenizer preserves comments, the preserved comment should be used; otherwise, an empty comment (/**/) must be inserted. (Preserved comments may be reinserted even if the following tables don’t require a comment between two tokens.)
</p>

<p>
表の見出し項目のうち，単独の文字によるものは、それを.値に伴う `delim$tok を表現する。
◎
Single characters in the row and column headings represent a &lt;delim-token&gt; with that value, except for "(", which represents a (-token.
</p>
	</li>

</ul>

<div style="overflow:auto;" id="_ser-table_">

<table class="data _ser-table_">

<thead><tr><td></td><th>`ident^tok
</th><th>`function^tok
</th><th>`url^tok
</th><th>`bad-url^tok
</th><th>`-^c
</th><th>`number^tok
</th><th>`percentage^tok
</th><th>`dimension^tok
</th><th>`CDC^tok
</th><th>`(^tok
</th><th>`?^c
</th></tr></thead>

<tbody>
<tr><th>`ident^tok</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>
</td></tr>
<tr><th>`at-keyword^tok</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td>
</td></tr>
<tr><th>`hash^tok</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td>
</td></tr>
<tr><th>`dimension^tok</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td>
</td></tr>
<tr><th>`#^c</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td> </td><td>
</td></tr>
<tr><th>`-^c</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td>✗</td><td>✗</td><td>✗</td><td> </td><td> </td><td>
</td></tr>
<tr><th>`number^tok</th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td>✗</td><td>✗</td><td>✗</td><td> </td><td> </td><td>
</td></tr>
<tr><th><code>@</code></th>
<td>✗</td><td>✗</td><td>✗</td><td>✗</td><td>✗</td><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr>
<tr><th>`.^c</th>
<td> </td><td> </td><td> </td><td> </td><td> </td><td>✗</td><td>✗</td><td>✗</td><td> </td><td> </td><td>
</td></tr>
<tr><th>`+^c</th>
<td> </td><td> </td><td> </td><td> </td><td> </td><td>✗</td><td>✗</td><td>✗</td><td> </td><td> </td><td> </td></tr>

</tbody></table>

</div>

		<table class="data _ser-table_">
<tbody><tr><td></td><th>`=^c</th><th>`|^c</th><th>`*^c</th></tr>
<tr><th><code>$</code></th><td>✗</td><td> </td><td></td></tr>
<tr><th>`*^c</th><td>✗</td><td> </td><td></td></tr>
<tr><th><code>^</code></th><td>✗</td><td> </td><td></td></tr>
<tr><th>`~^c</th><td>✗</td><td> </td><td></td></tr>
<tr><th>`|^c</th><td>✗</td><td>✗</td><td></td></tr>
<tr><th>`/^c</th><td> </td><td> </td><td>✗</td></tr>
</tbody></table>

	</div>



		<section id="serializing-anb">
<h3 title="Serializing &lt;an+b&gt;">10.1. ~anb の直列化法</h3>

<div >
<p>
`~anb 値を直列化-@
した結果は、その`周期$ `A^V, `~offset$ `B^V の値に応じて，次の表で与えられる（ `sA^V, `sB^V は，それぞれ `A^V, `B^V を直列化した結果とする）：
</p>

<table>
	<thead><tr><th>`A^V</th><th>`B^V</th><th>結果</th></tr></thead>

	<tbody >
<tr><td>0</td><td>0</td><td>
"`0^c"
</td></tr>

<tr><td>0</td><td>0 以外</td><td>
`sB^V
</td></tr>

<tr><td>0 以外</td><td>0</td><td>
`sA^V ~APPEND "`n^c"
</td></tr>

<tr><td>0 以外</td><td>負</td><td>
`sA^V
~APPEND "`n^c"
~APPEND `sB^V
</td></tr>

<tr><td>0 以外</td><td>正</td><td>
`sA^V
~APPEND "<code>n+</code>" 
~APPEND `sB^V
</td></tr>

	</tbody>
</table>

	<div lang="en">
<p>
To serialize an &lt;an+b&gt; value, let s initially be the empty string:
</p>
<dl>
	<dt>A and B are both zero</dt>
	<dd>Append "0" to s.</dd>

	<dt>A is zero, B is non-zero</dt>
	<dd>Serialize B and append it to s.</dd>

	<dt>A is non-zero, B is zero</dt>
	<dd>Serialize A and append it to s. Append "n" to s.</dd>

	<dt>A and B are both non-zero</dt>
	<dd>
Serialize A and append it to s. Append "n" to s. If B is positive, append "+" to s Serialize B and append it to s.</dd>
</dl>

<p>
Return s.
</p>
	</div>
</div>



		</section>

	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">11. ~privacyと~security上の考慮点</h2>

<p>
この仕様により新たな~privacy上の懸念が導入されることはない。
◎
This specification introduces no new privacy concerns.
</p>

<p>
この仕様による CSS 構文解析処理は、今や すべての入力に対し一義的に定義されるので，~securityを改善する。
◎
This specification improves security, in that CSS parsing is now unambiguously defined for all inputs.
</p>

<p>
~whitelistや~filterなどの旧い構文解析器には、この仕様と異なるように構文解析する限り~secureでない部分があることになる。
以前の構文解析処理の仕様には，多義的で, ~browserにより解釈が異なるような多数のきわどい事例が残されているので、それらの~filterは~secureでない可能性がある。
この仕様は，その状況を悪化させることはない。
◎
Insofar as old parsers, such as whitelists/filters, parse differently from this specification, they are somewhat insecure, but the previous parsing specification left a lot of ambiguous corner cases which browsers interpreted differently, so those filters were potentially insecure already, and this specification does not worsen the situation.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">12. 変更点</h2>

~INFORMATIVE

		<section id="changes-CR-20140220">
<h3 title="Changes from the 20 February 2014 Candidate Recommendation">12.1. ［ 2014 年 2 月 20 日付  勧告候補 ］からの変更点</h3>


<p>
重要な変更点として次のものが加えられた：
◎
The following substantive changes were made:
</p>

<ul>
	<li>
文字列を消費する前に引用符を消費していなかった，
“~url~tokenを消費” ~algoの~bugを修正した。
◎
Fixed a bug in the "Consume a URL token" algorithm, where it didn’t consume the quote character starting a string before attempting to consume the string.
</li>

	<li>
現入力~token／次入力~tokenとその消費~時機に関する，いくつかの構文解析器~algoの~bugを修正した。
◎
Fixed a bug in several of the parser algorithms related to the current/next input token and things getting consumed early/late.
</li>

	<li>
~tokenizationと構文解析処理~algoにおける いくつかの~bugを修正した。
◎
Fix several bugs in the tokenization and parsing algorithms.
</li>

	<li>
識別子に類する~tokenの定義を，
`--^c から開始される識別子も許容するように変更。
<span class="trans-note">【
<a href="#would-start-an-identifier">参照</a>
】</span>
◎
Change the definition of ident-like tokens to allow "--" to start an ident.
</li>

</ul>

<p>
編集上の変更点として次のものが加えられた：
◎
The following editorial changes were made:
</p>


<ul>
	<li>
“文字列を消費” する~algoは、明示的な終端~符号位置を指定せずに呼べるようにされた。
その場合は 現入力~符号位置が代わりに用いられる。
これにより，３カ所の呼び出しに変更が加えられた。
◎
The "Consume a string token" algorithm was changed to allow calling it without specifying an explicit ending token, so that it uses the current input token instead. The three call-sites of the algorithm were changed to use that form.
</li>

	<li>
編集上の，~algoにおける小さな再構成
◎
Minor editorial restructuring of algorithms.
</li>

</ul>


		</section>
		<section id="changes-WD-20131105">
<h3 title="Changes from the 5 November 2013 Last Call Working Draft">12.2. ［ 2013 年 11 月 5 日付  最終~作業草案 ］からの変更点</h3>


	<ul>
	<li>
`直列化$の節は、“往来” の要件のみが規定になる様に書き直され、それを得るための方法の詳細は注記に移動された。
これらの詳細における，いくつかの きわどい事例は解消された。
◎
The Serialization section has been rewritten to make only the "round-trip" requirement normative, and move the details of how to achieve it into a note. Some corner cases in these details have been fixed.
</li>

	<li>
参照文献（規範）に `ENCODING$r が追加された。
それは規定~textからは参照されていたが、単に文献~listから漏れていた。
◎
[ENCODING] has been added to the list of normative references. It was already referenced in normative text before, just not listed as such.
</li>


	<li>
<p>
~stylesheetの`~fallback符号化方式を決定する$~algoにおける
`charset^at ~byte列の上限は、 1024 ~byteにされた。
これは， HTML における `meta charset^e の取り扱いに倣うものであり、列の長さを常に一定に抑えるようにする。
これは、符号化方式~labelの前後の空白についてのみ，以前と相違がある：
◎
In the algorithm to determine the fallback encoding of a stylesheet, limit the @charset byte sequence to 1024 bytes. This aligns with what HTML does for &lt;meta charset&gt; and makes sure the size of the sequence is bounded. This only makes a difference with leading or trailing whitespace in the encoding label:
</p>

<pre>@charset "   <em title="(lots of whitespace)">…多量の空白…</em>   utf-8";</pre>
	</li>

</ul>

		</section>
		<section id="changes-WD-20130919">
<h3 title="Changes from the 19 September 2013 Working Draft">12.3. ［ 2013 年 9 月 19 日付 作業草案］からの変更点</h3>


	<ul>
	<li>

`環境~符号化方式$の概念が追加された。
挙動は変更されていないが、定義の一部は，関連~仕様へ移動されるべきである。
◎
The concept of environment encoding was added. The behavior does not change, but some of the definitions should be moved to the relevant specs.
</li></ul>



		</section>
		<section id="changes-css21">
<h3 title="Changes from CSS 2.1 and Selectors Level 3">12.4. ［ CSS 2.1, Selectors Level 3 ］からの変更点</h3>

<p class="note">注記：
この仕様の要点は、実態に合致させることである
—
CSS 2.1 からの変更点は、おおよそ常に，~CSS 2.1 が［
実際の~browserの挙動に合致していない何かを指定しているか, または
何かを未指定~のままにしている
］ことに因る。
何らかの詳細が~browserの挙動に合致しない場合、それは，ほぼ意図されていないことなので，編集者まで知らせるよう願う。
◎
Note: The point of this spec is to match reality; changes from CSS2.1 are nearly always because CSS 2.1 specified something that doesn’t match actual browser behavior, or left something unspecified. If some detail doesn’t match browsers, please let me know as it’s almost certainly unintentional.
</p>

<p>
~byte~streamからの復号処理における変更点：
◎
Changes in decoding from a byte stream:
</p>

<ul>
	<li>
~ASCII 互換~byte~patternの中では、 `charset$at 規則のみが検知される。
◎
Only detect @charset rules in ASCII-compatible byte patterns.
</li>

	<li>
~ASCII 非互換の符号化方式を指定する `charset$at 規則は、規則それ自身を適正に復号できなくするので，無視される。
◎
Ignore @charset rules that specify an ASCII-incompatible encoding, as that would cause the rule itself to not decode properly.
</li>

	<li>
文字~符号化方式は、 IANA 登記簿ではなく， `ENCODING$r を参照するようにされた。
◎
Refer to [ENCODING] rather than the IANA registery for character encodings.
</li></ul>

<p>
~tokenizationにおける変更点:
◎
Tokenization changes:
</p>

<ul>
	<li>
~CSS~source内の `00^U `符号位置$はすべて， ~FFFD に置換される
◎
Any U+0000 NULL code point in the CSS source is replaced with U+FFFD REPLACEMENT CHARACTER.
</li>

	<li>
`\0^css などのゼロに評価されるどの 16 進~escape-seqも， `00^U でなく ~FFFD を生産する。
◎
Any hexadecimal escape sequence such as \0 that evaluates to zero produce U+FFFD REPLACEMENT CHARACTER rather than U+0000 NULL.
</li>

	<li>
`非~ASCII符号位置$の定義は， ~ASCII を利用するどの定義にも整合するように変更された。
これは，`符号位置$ { U+0080 〜 U+009F } に影響する —
それらは今や、他の`非~ASCII符号位置$同様に，`delim$tok ではなく `名前~符号位置$になる。
◎
The definition of non-ASCII code point was changed to be consistent with every definition of ASCII. This affects code points U+0080 to U+009F, which are now name code points rather than &lt;delim-token&gt;s, like the rest of non-ASCII code points.
</li>

	<li>
~tokenizationは、最早［
`COMMENT^c や `BAD_COMMENT^c
］~tokenを~emitしない。
`BAD_COMMENT^c は今や，（~errorではない）通常の~tokenと同じものと見なされる。
区切られる必要がある~token
— 例えば 連続する 2 個の `ident$tok など —
の合間に，必要に応じて~commentを挿入することは、`直列化$が責を負う。
◎
Tokenization does not emit COMMENT or BAD_COMMENT tokens anymore. BAD_COMMENT is now considered the same as a normal token (not an error). Serialization is responsible for inserting comments as necessary between tokens that need to be separated, e.g. two consecutive &lt;ident-token&gt;s.
</li>

	<li>

<p>
`unicode-range^tok は除去された。
価値が低い割に，時折 有害になるので（例えば
`u+a { font-weight: bold; }^css
は、無効な選択子にされていた…）。
◎
The &lt;unicode-range-token&gt; was removed, as it was low value and occasionally actively harmful. (u+a { font-weight: bold; } was an invalid selector, for example...)
</p>

<p>
代わりに，~token~patternに基づく `urange$t 生成規則が追加された。
それは CSS2.1 で許容されていたものより緩い（任意個数の数字や `?^c ）が、いずれにせよ，実施において，その利用に~~影響を及ぼすことは無い筈である。
◎
Instead, a &lt;urange&gt; production was added, based on token patterns. It is technically looser than what 2.1 allowed (any number of digits and ? characters), but not in any way that should impact its use in practice.
</p>
	</li>

	<li>
~tokenizerにおいては`~EOF~errorの取扱い規則$が適用され、~EOFに際しては、
`BAD_STRING^c や `BAD_URI^c ではなく，通常の `string$tok や `url$tok が~emitされる。
◎
Apply the EOF error handling rule in the tokenizer and emit normal &lt;string-token&gt; and &lt;url-token&gt; rather than BAD_STRING or BAD_URI on EOF.
</li>

	<li>
［
`prefix-match$tok,
`suffix-match$tok,
`substring-match$tok
］が Selectors Level 3 から移入された。
◎
&lt;prefix-match-token&gt;, &lt;suffix-match-token&gt;, and &lt;substring-match-token&gt; have been imported from Selectors 3.
</li>

	<li>
`BAD_URI^c ~token（今や `bad-url$tok ）は “自己完結的” である。
言い換えれば、~tokenizerにおいて，`url$tok ではなく `bad-url$tok の中であることが認識0された時点で、単に，閉じられる箇所を見つけるために 他のすべてを無視して前方検索する。
この挙動は［
それを `function$tok の様に扱って，開いた~blockに類するものに注意を払う
］より単純である。
この挙動は， WebKit のみに見られるが、それによる互換性bugは生じていないように見受けられる。
◎
The BAD_URI token (now &lt;bad-url-token&gt;) is "self-contained". In other words, once the tokenizer realizes it’s in a &lt;bad-url-token&gt; rather than a &lt;url-token&gt;, it just seeks forward to look for the closing ), ignoring everything else. This behavior is simpler than treating it like a &lt;function-token&gt; and paying attention to opened blocks and such. Only WebKit exhibits this behavior, but it doesn’t appear that we’ve gotten any compat bugs from it.
</li>

	<li>
`comma$tok が追加された。
◎
The &lt;comma-token&gt; has been added.
</li>

	<li>
［
`number$tok,
`percentage$tok,
`dimension$tok
］は、前置された`正負符号$を，値の一部に含むように変更された（他の仕様で言及される度に，手動的に取扱う必要がある，別個の `delim$tok としてではなく）。
これによる唯一の帰結は、符号とその実数の合間には，最早~commentを挿入し得なくなったことである。
◎
&lt;number-token&gt;, &lt;percentage-token&gt;, and &lt;dimension-token&gt; have been changed to include the preceding +/- sign as part of their value (rather than as a separate &lt;delim-token&gt; that needs to be manually handled every time the token is mentioned in other specs). The only consequence of this is that comments can no longer be inserted between the sign and the number.
</li>

	<li>
Working Group による解決に従って、 SVG に合わせるため，［
実数／百分率／次元
］における科学的記数法も~supportされる。
◎
Scientific notation is supported for numbers/percentages/dimensions to match SVG, per WG resolution.
</li>

	<li>
Selectors の構文解析処理における~tokenの先読みを 1 個までに保たせるため、 `column$tok が追加された。
◎
&lt;column-token&gt; has been added, to keep Selectors parsing in single-token lookahead.
</li>

	<li>
［
`~surrogate~符号位置$に対する 16 進~escape
］は今や、その~surrogateではなく，代替文字
<span class="trans-note">【 U+FFFD 】</span>
を~emitする。
これにより、実装は， UTF-16 を内部的に安全に利用できるようになる。
◎
Hexadecimal escape for surrogate code points now emit a replacement character rather than the surrogate. This allows implementations to safely use UTF-16 internally.
</li></ul>

<p>
構文解析処理における変更点:
◎
Parsing changes:
</p>

<ul>
	<li>
Working Group による解決に従って，今や、どの`宣言~list$も，
`page$at のような~at-ruleを受容する。
これにより，その種の~at-ruleが未だ定義されていなかったとしても，~errorの取扱いには相違が生じる：
`~at-rule$は、妥当であろうとなかろうと， `semicolon$tok が伴われなくとも<!-- ※ -->
波括弧~blockで終端し，次の宣言を始めさせる。
◎
Any list of declarations now also accepts at-rules, like @page, per WG resolution. This makes a difference in error handling even if no such at-rules are defined yet: an at-rule, valid or not, ends at a {} block without a &lt;semicolon-token&gt; and lets the next declaration begin.
</li>

	<li>
<p>
文法の中の種々の場所に現れる，一部の種々の “特別な” ~token（対になっていない `close-curly$T など）の取扱いは、少なくとも 1 つ以上の~browserに見られるような，ある種の理に適った挙動により指定された。
以前までは、その種の~tokenが伴われた~stylesheetは，単に ~stylesheet文法に全く合致しないものとされており、その取扱いは，まったく未定義であった。
より明確には：
◎
The handling of some miscellanous "special" tokens (like an unmatched &lt;}-token&gt;) showing up in various places in the grammar has been specified with some reasonable behavior shown by at least one browser. Previously, stylesheets with those tokens in those places just didn’t match the stylesheet grammar at all, so their handling was totally undefined. Specifically:
</p>

		<ul>
			<li>
［
`角括弧~block$,
`丸括弧~block$,
`関数式$
］はいずれも，今や［
`波括弧~block$,
`at-keyword$tok,
`semicolon$tok,
］のいずれをも包含し得る
◎
[] blocks, () blocks and functions can now contain {} blocks, &lt;at-keyword-token&gt;s or &lt;semicolon-token&gt;s
</li>

			<li>
有修飾~規則の.導入部は今や，セミコロンを包含し得る
◎
Qualified rule preludes can now contain semicolons
</li>

			<li>
［
有修飾~規則,
~at-ruleの.導入部
］はいずれも，今や `at-keyword$tok 包含し得る。
◎
Qualified rule and at-rule preludes can now contain &lt;at-keyword-token&gt;s
</li>

		</ul>
	</li>
</ul>

<p>
~AnB における， Selectors Level 3 `SELECT$r からの変更点：
◎
An+B changes from Selectors Level 3 [SELECT]:
</p>

<ul>
	<li>
<p>
~AnB 小構文は 今や，別個の~tokenizerではなく，~CSS~tokenの用語を通して，公式的に定義された。
その結果，小さな相違が生じている：
◎
The An+B microsyntax has now been formally defined in terms of CSS tokens, rather than with a separate tokenizer. This has resulted in minor differences:
</p>

		<ul>
			<li>
一部の場合には，負符号や数字を（それらが `dimension$tok の.単位や `ident$tok の一部として現れるときには）~escapeできる。
◎
In some cases, minus signs or digits can be escaped (when they appear as part of the unit of a &lt;dimension-token&gt; or &lt;ident-token&gt;).
</li>
		</ul>
	</li>
</ul>

		</section>
	</section>

</main></div><!-- MAIN -->


	<section>
<h2 id="acknowledgments">謝辞</h2>


<p>
次の方々からのフィードバックと貢献に：
</p>
<p>
Thanks for feedback and contributions from
Anne van Kesteren,
David Baron,
Henri Sivonen,
Johannes Koch,
呂康豪 (Kang-Hao Lu),
Marc O’Morain,
Raffaello Giulietti,
Simon Pieter,
Tyler Karaszewski, and
Zack Weinberg.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この節の内容は
<a href="css-common-ja.html#conformance">CSS 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="references">
<h2 title="References">参照文献</h2>

		<section id="normative">
<h3 title="Normative References">文献（規範）</h3>





<dl>

	<dt>[CSS-COLOR-3]</dt>
	<dd>CSS Color Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-color-3/</dd>

	<dt>[CSS-FONTS-3]</dt>
	<dd>John Daggett. CSS Fonts Module Level 3. 3 October 2013. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-fonts/</dd>

	<dt>[CSS-PAGE-3]</dt>
	<dd>CSS Paged Media Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-page-3/</dd>

	<dt>[CSS-VALUES]</dt>
	<dd>Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 11 June 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-values/</dd>

	<dt>[CSS-VARIABLES]</dt>
	<dd>Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-variables/</dd>

	<dt>[CSS21]</dt>
	<dd>Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC.</dd>
	<dd>http://www.w3.org/TR/CSS2</dd>

	<dt>[CSS3CASCADE]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 19 May 2016. CR.</dd>
	<dd>http://www.w3.org/TR/css-cascade-3/</dd>

	<dt>[ENCODING]</dt>
	<dd>Anne van Kesteren. Encoding Standard. Living Standard.</dd>
	<dd>https://encoding.spec.whatwg.org/</dd>

	<dt>[MEDIAQUERIES-4]</dt>
	<dd>Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 26 January 2016. WD.</dd>
	<dd>http://dev.w3.org/csswg/mediaqueries4/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

	<dt>[SELECT]</dt>
	<dd>Tantek Çelik; et al. Selectors Level 3. 29 September 2011. REC.</dd>
	<dd>http://www.w3.org/TR/css3-selectors/</dd>

	<dt>[SELECTORS-4]</dt>
	<dd>Selectors Level 4</dd>
	<dd>https://drafts.csswg.org/selectors-4/</dd>

	<dt>[UNICODE]</dt>
	<dd>The Unicode Standard.</dd>
	<dd>http://www.unicode.org/versions/latest/</dd>

	<dt>[WHATWG-DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>
</dl>


		</section>
		<section id="informative">
<h3 title="Informative References">文献（参考）</h3>


<dl>

	<dt>[CSS-2D-TRANSFORMS-1]</dt>
	<dd>CSS 2D Transforms Module Level 1</dd>
	<dd>https://www.w3.org/TR/css3-2d-transforms/</dd>

	<dt>[CSS-ANIMATIONS-1]</dt>
	<dd>CSS Animations Module Level 1</dd>
	<dd>https://drafts.csswg.org/css-animations-1/</dd>

	<dt>[CSS-CASCADE-4]</dt>
	<dd>Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-cascade/</dd>

	<dt>[CSS-COLOR-4]</dt>
	<dd>CSS Color Module Level 4</dd>
	<dd>https://drafts.csswg.org/css-color-4/</dd>

	<dt>[CSS-CONDITIONAL-3]</dt>
	<dd>CSS Conditional Rules Module Level 3</dd>
	<dd>https://drafts.csswg.org/css-conditional-3/</dd>

	<dt>[CSS-TEXT-DECOR-3]</dt>
	<dd>Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 3. 1 August 2013. CR.</dd>
	<dd>http://dev.w3.org/csswg/css-text-decor-3/</dd>

	<dt>[CSS-TRANSFORMS-1]</dt>
	<dd>Simon Fraser; et al. CSS Transforms Module Level 1. 26 November 2013. WD.</dd>
	<dd>http://dev.w3.org/csswg/css-transforms/</dd>

	<dt>[CSS3-ANIMATIONS]</dt>
	<dd>Dean Jackson; et al. CSS Animations. 19 February 2013. WD.</dd>
	<dd>http://www.w3.org/TR/css3-animations/</dd>

	<dt>[CSS3-CONDITIONAL]</dt>
	<dd>David Baron. CSS Conditional Rules Module Level 3. 4 April 2013. CR.</dd>
	<dd>http://www.w3.org/TR/css3-conditional/</dd>

	<dt>[CSSOM]</dt>
	<dd>Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD.</dd>
	<dd>https://drafts.csswg.org/cssom/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

	<dt>[MEDIAQ]</dt>
	<dd>Florian Rivoal; et al. Media Queries. 19 June 2012. REC.</dd>
	<dd>http://www.w3.org/TR/css3-mediaqueries/</dd>
</dl>


		</section>
	</section>
	<section id="index">
<h2 title="Index">索引</h2>
<p class="trans-note">【
この節の内容は省略（ウィンドウ下端の索引機能を利用されたし）。
】</p>

	</section>
	<section id="property-index">
<h2 title="Property index">プロパティ索引</h2>

<p>
この仕様にて定義されるプロパティは、無い。
<span lang="en">
No properties defined.
</span></p>

	</section>

</body></html>

