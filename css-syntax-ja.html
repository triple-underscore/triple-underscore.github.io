<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Syntax Module Level 3 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
@namespace svg url(http://www.w3.org/2000/svg);

svg|svg{
	background-color: hsl(30 20% 95%);
}
svg|path{
	stroke-width: 3;
	stroke: black;
	fill: none;
}
svg|text{
	font:bold 14px monospace;
	text-anchor:middle;
}
svg|text.label{
	text-anchor:start;
}
svg|text.comment{
	font:italic 12px monospace;
}
svg|rect{
	stroke-width: 3;
	stroke: black;
	fill: hsl(120 100% 90%);
}


dd.railroad {
	overflow: auto;
}
</style>
<!-- 
class="railroad-diagram" → 除去（ svg はすべて線路図式）
svg.railroad-diagram tagname → svg|tagname
埋め込み svg に名前空間宣言は不要
https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/HTML5_Parser
-->


<style>

.symbol {
	color: black;
}

.encoding {
	font-family: sans-serif0, sans-serif;
}


td[colspan] {
	text-align:center;
}

#_ser-table1 > tbody > tr > td {
	min-width: 1em;
	text-align: center;
}
#_ser-table1 > tbody > tr > th {
	white-space: nowrap;
	text-align: right;
}

#_ser-table1 > thead > tr > th > * {
	writing-mode: vertical-rl;
	white-space: nowrap;
}

#_anb-def,
#_anb-def > thead,
#_anb-def > tbody,
#_anb-def > thead > tr,
#_anb-def > tbody > tr,
#_anb-def > thead > tr > th,
#_anb-def > tbody > tr > td {
	display: block;
}

#_anb-def td:nth-child(2),
#_anb-def th:nth-child(2) {
	margin-left: 2em;
}

#_anb-def td:nth-child(3),
#_anb-def th:nth-child(3) {
	margin-left: 4em;
}
</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		collectParts: Util.collectParts,
		generate: expand
	};

	const unicode_map = PAGE_DATA.unicode_map
	.replace( /\n(\w+)([:!])(.+)/g, function(t0, t1, t2, t3){
		t0 = (t1.length < 3) ? '00' + t1 : t1;
		t2 = (t2 === '!') ? ` (<code>&#x${t1};</code>)` : '';
		return(
`\n${t1}:<span class="code-point">U+${t0}</span> <span class="cp-name">${t3}</span>${t2}`
		);
	});
	source_data.unicode_map = Util.get_mapping(unicode_map);
	delete PAGE_DATA.unicode_map

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '', text = key;

switch(klass){
case 'i': // ^i リンク解除（一時的？）
	break;
case 'r': // ref
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'tok': // token
	href = `#typedef-${key.toLowerCase()}-token`;
	text = `&lt;${key}-token&gt;`;
	break;
case 'Tok': // token
	href = `#tokendef-${key}`;
	text = `&lt;~${key}&gt;`;
	break;
case 't': // typedef
	href = `#typedef-${key}`;
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'U': // code point
	text = unicode_map[key] || `<span class="code-point">U+${key}</span>`;
	break;
case 'l': // literal
	text = `"<code>${key}</code>"`;
	break;
case 'at': // at-rule
	text = `@${key}`;
	break;
case 'ps': 
	text = `:${key}`;
	break;
case 'dgm': // place holder for railroad diagram
	return `<a id="_dgm-${key}"></a>`;
	break;
case 'cK':
	text = text.replace(/./g, '<td>$&').replace(/_/g, '-');//✗
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}//create_html
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Syntax Module Level 3
spec_date:2021-04-16
trans_update:2021-04-18
source_checked:190716
page_state_key:CSS
original_url:https://drafts.csswg.org/css-syntax-3/
	abbr_url:CSSSYN
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2021,permissive
trans_1st_pub:2013-12-14


●●class_map
at:at-rule
p:property
d:descriptor
ps:pseudo
f:func
tok:token
Tok:token
t:type
u:unit
sb:symbol
e:element
a:attr
enc:encoding
css:css
v:value
h:header

●●tag_map
i:i
tok:var
Tok:var
t:var
V:var
at:code
p:code
d:code
ps:code
f:code
sb:code
e:code
a:code
v:code
css:code
I:code
enc:span
c:code
h:code
em:em
sub:sub
dfn:dfn

●●words_table1


nB:<sup><a href="#anb-plus" >†</a></sup>
anb:<var>&lt;an+b&gt;</var>
AnB:<span class="css"><var>A</var>n+<var>B</var></span>
An:<span class="css"><var>A</var>n</span>

open-square:[-token
close-square:]-token
open-paren:(-token
close-paren:)-token
open-curly:{-token
close-curly:}-token

DAGGER:<sup>†</sup>
EOF: <i>EOF</i> 

●●words_table

	●処理一般
回復-:recover:~
回復:recovery:~
操作o-:operate:操作
	-:optionally
	:error handling
入口:entry point::~::エントリポイント
step
無制約:unrestricted:制約なし
呼ばれ:callされ:~
呼ぶ:callする:~
呼べる:callできる:~
	呼び出し:calling
繰返し:repeatedly:繰り返し
繰返n:repetition:繰り返し
渡す:passする:~
渡され:passされ:~
一掃:clean up:~
後始末:cleaning up:~
	-:initially
	戻る:returning
	%~URL:url

	●構文解析
長さ:
消費:consume::~
消費側:consumer::~
	消費し直す:reconsume
前方検索-:forward へ seek::~

発する:emitする::~
発され:emitされ::~
現入力:current input:現在の入力
次入力:next input:次の入力
小構文:microsyntax::~
形式変換-:transform:~
	引用符で括る:quote
	引用符で括られ:quoted
	引用符で括られてない:unquoted
一重引用符:single quote::~
線路図式:railroad diagram:~
		構文解析図

	~escape列:escape sequence
	~escapeを施す:escaping
	~escape法:escaping
前処理:preprocessing:~
構文解析error:parse error::構文解析エラー::パースエラー

tokenizer:::token 化器:トークン化器:トークナイザ
	~token化:tokenization
	~token化:tokenize
	~token化法:tokenizing
	~token化処理:tokenizing
	~token化前の:pre-tokenizing

枯渇-:exhaust:~
遭遇-:encounter:~
構築中:build 中:~
		building

分割-:divide:~
	~~分割-:split
出現する:appearする:現れる
出現し:appearし:現れ
縮約-:collapse:~
削る:trimする:~
連続する:consecutiveな:~
連続的:contiguous:~
往来-:round-trip::~
棄てら:dropさ:棄てら
棄てる:dropする:棄てる
	~~棄てる:throw away:破棄
	~~棄てられ:thrown out
代用-:substitute::~
	代用-:substitution
文法記号:grammar term:~


	一連の:series
	〜並び:sequence
	〜列:sequence
	部分列:subsequence
	~byte列:sequence of bytes
	挿入し直-:reinsert
	対になっていない:unmatched
	３つ組:3-tuple
	挟まれ:surrounded
	挟んで:surround
	一定周期に~~位置する:regularly-spaced intervals
	先頭に戻す:push〜back onto the front
	始まる:begins with
	閉じ:closing
	閉じら:close さ
	closed／unclosed
	開いた:opened
	まだ閉じられていない:still open
	~comment挿入:comment-insertion
	下位部分:sub-part
	成分~値:component-value
	成功した:successfully

	●符号位置／
BOM:
	BAD_STRING, BAD_URI
UTF-16:
数字:digit::~
英字:letter::~
hex:hex digit::16 進数字
	decimal:10 進数
	16 進数／16 進:hexadecimal number

	基数
	ident
符号:sign:~
負符号:minus sign:~
正符号:plus sign:~
正負符号:plus or minus sign:~

大文字:uppercase letter::~
小文字:lowercase letter::~
	convert 〜 lower-case
代替文字:replacement character:replacement 文字:~
surrogate::::サロゲート
backslash::::バックスラッシュ

	識別子を開始する:identifier-start
印字不能:non-printable::~

	●token 他
	括弧:brace
波括弧:curly:~
丸括弧:paren:~
角括弧:square:~
	閉じ丸括弧:right parenthesis
unicode-range:::unicode 範囲
有修飾:qualified::~
	有資格?
関数式:function::~
実数:number::~
文t:statement:文
	識別子に類する:ident-like
導入部:prelude::~
鏡像:mirror variant:~
終端ng:ending::終端
	ending token／ending code point
始値:start value:~
終値:end value:~
数値:numeric value:~
数量-:numeric:~
残余:remnants:~
	文字大小は区別:case-sensitive
	-ly
保全d:preserved::保全


	●An+B
整数部:integer part:~
小数点:decimal point:~
小数部:fractional part:~
指数:exponent:~
	グループ化
周期:step:~


	●CSS
CSSOM:
keyframe::::キーフレーム
	~animate可能:animatable
	custom property
import:
important:
green:
	疑似類:pseudoclass
字句走査器:lexical scanner::字句 scanner:字句スキャナ
出自:origin::~
詳細度:specificity::~
色:color::~

	~list値をとる:list-valued

	●仕様
参考:informative:~
	互換性:compat
上品:graceful:~
事実:fact:~
基礎的:fundamental:~
不規則:odd:~
	問題にならない:not problematic
節:section:~
自己完結的:self-contained:~
相:phase:~
段階:stage:~
アタられ:consultされ:あたられ
自立的:stand-alone:~
視点:standpoint:~
自明:trivial:~
一時的:temporary:~
	temporarily
whitelist::::ホワイトリスト
微妙な:subtle:~
際どい:corner:きわどい
実態:reality:~
最悪:at worst:~
誤用:mistake:~
適理:reasonable:~
総括的:blanket:~
切替えた:switchした:切り替えた
産物:product:~

不変:unchanged:~
真似た:mimicした:~
倣う:alignする:~
関知-:concern:~
解消-:fix:~
翻訳-:translate:~
衝突-:collide:~
	confusing
妨げら:disturbさ:~
参照r:refer:参照
	〜と呼ばれているもの:what is referred to as〜
参照元:referring:~
	認識できない:unrecognized
分類-:categorize:~
分類:categorization:~
呈-:exhibit:~
処-:deal:~
細やか:fine-grained:~
把握-:grasp:~

Selectors:
	`MEDIAQ$r:Media Queries
	Fonts
	Syntax
	CSSOM
	SVG
	IANA,
	WebKit,
	[CSS-VALUES] 仕様:Values &amp; Units spec

	低~level:low-level
	高~levelな:high-level
	~~主要な:substantive
	^en:destructure
	再構成:restructuring
	策定者:you
	~~考えて:think
	自明でない:non-trivial
	し得る:possible
	~~相応に／それなりに:fairly
	照らし合わせて:against
	最新の:most recent
	必要とする:necessary
	必要に応じて:as necessary
	必要に応じて:if so desired
	あるべき:decent
	責を負う:responsible
	注意を払う:paying attention
	その場で:on-demand
	に反し:despite
	易-:easier
	易く:easily
	十分:fine
	十分な:sufficient
	最小限の〜:minimum amount of 〜
	小さな:minor
	優先度:precedence
	優先-:gives precedence
	実の:real
	満たす:satisfy
	易くなる:easier
	衝突して:collision
	~~実在の:real-world
	本質的でない漏洩:accidental leak
	単に:just
	simple enough that
	それなり:fairly
	:please let me know
	:question
	多岐に渡る:wide variety of
	:although
	直前に〜済み:initial〜already
	~~区別:distinction
	足りる:suffice
	略して:aka
	もちろん:definitely
	きちんと:well-
	問わない:agnostic
	実装:impl
	~~影響しない:have no effect
	意図されない:unintentional
	課さない:places no
	きちんと定義され:well-defined
	といった風に:saying
	期待されない:unexpected
	要する:require／need
	~~判明-:realize
	書き直され:rewrite
	好ましい:preferably
	見受けられる:we’ve gotten any
	見受けられ:appear
	〜を通して:hooking
	心配せずに:without worrying about
	委ねられる:leaving
	大別され:broadly speaking
	諸々の:miscellaneous

	●未分類
	~filter済みでない:unfiltered
先行-:precede:~
選択-:select:~
minify:::圧縮
条件付き:conditional::~
正規表現:regular expression:~
	make
印:mark:~
	−1:negation
科学的記数法:scientific notation:~
実体:entity:~

	~literalとして:literally
	括られ:enclosed
	取り込む:to be encountered
	壊れ:broken
	選ばれ:chosen
	composed of 〜
	〜からなる:consisting of
	〜からなる:consists
	成す:comprise する
	constitute 〜
	表す／示され:denote
	（互いに）異なる:different
	異なる:differ
	区別する:disambiguate
	抜けた:finish
	よく似る:resemble
	〜:inclusive
	保つ:keep
	見かけ:look
	調べる:looks at
	混在する:mixed
	得る:achieve
	まだ open:still open
	保ち続ける:retain
	見える:seen
	selecting
	送る:sending
	現れる:showing up
	現れ:show up
	記され:written
	読み綴る:spell
	取り込まれる:taken
	take
	taking
	後続-:follow
	選ばれ:picked
	読み取／読まれる／読む:read
	種々の:varied
	変わり得る:vary
	〜で括られた:wrapped
	値~定義~構文:Value Definition Syntax
	~link法:linking
	後続する:continue
	完全に壊れる:being completely broken
	側:side
	-:total
	量:amount
	:adjusting
	:afterwards
	場合:case
	欄:cell
	二重に:doubled
	ever
	filled
	最終的に:eventual
	-:final
	-:finally
	見出し:heading
	formed
	hence
		 instruct
	-:intersection
	項目
	より大きい:greater
	高い:high
	より高い:higher
	より長い:longer
	最も長い:longest
	短い:short
	印~付き:marked
	呼応する／対応する
	表:table
	同時に，:together
	OFF:unset
	:very
	lower-, higher
	片 pieces
	ident
	一環:part of
	段たちを~~配列し直し:rearrange the ordering of the clauses
	~group化-:group
	構造~化-:structure
	何個かの:collection

	●指示語
新規:fresh:~
他全部:anything else:その他
部位:portion:~

	頭部:first several
	最~大:greatest
	最長:largest
	古い:old
	より古い:older
	最早:anymore
	のように:similar
	よく似た:very similar
	いくぶん:somewhat
	少しばかり:slightly
	ほぼ:certainly
	中途にある:in the middle of
	再:re
	前述の:previous
	now
	〜まで:until
	一番先頭:very first
	order
	当該の:respective
	respectively
	〜のいずれか:either
	あらゆるもの:everything
	おおよそ:nearly
	まったく:totally
	一緒に:altogether
	一部:part
	他の:rest
	他のもの:anything else
	他のもの:rest
	何らかの／一部の:some
	先頭:front, ...
	全体を占める:sole
	全然:entirely
	外側の:outer
	次の:adjacent
	次の:next
	残り:remainder
	残りの:remaining
	残りの部分:rest
	箇所:certain points
	組:pair
	結果:result／resulted／resulting
	自身による:own
	非:non
	ときには:occasionally
	上に挙げた:preceding
	ほとんど:mostly
	何箇所かで:sometimes


●●original_id_map

at-rule1:at-rule①
repeatedly-consume-next-code-point:
repeatedly-consume-next-token:
curly-block:
paren-block:
square-block:
plus-or-minus:
exponent-indicator:

whitespaces-diagram:ws*-diagram
curly-block-diagram:{}-block-diagram
paren-block-diagram:%28%29-block-diagram
square-block-diagram:[]-block-diagram

●●mdn_urls
at-ruledef-charset:CSS/@charset

●●link_map

	t.n-dimension:#typedef-n-dimension
	t.ndash-dimension:#typedef-ndash-dimension
	t.ndashdigit-dimension:#typedef-ndashdigit-dimension
	t.ndashdigit-ident:#typedef-ndashdigit-ident
	t.dashndashdigit-ident:#typedef-dashndashdigit-ident
	t.integer:#typedef-integer
	t.signed-integer:#typedef-signed-integer
	t.signless-integer:#typedef-signless-integer
	t.urange:#typedef-urange
	t.declaration-list:#typedef-declaration-list
	t.rule-list:#typedef-rule-list
	t.stylesheet:#typedef-stylesheet
	t.declaration-value:#typedef-declaration-value
	t.any-value:#typedef-any-value

t.number:~CSSVAL#number-value
t.dimension:~CSSVAL#typedef-dimension
t.string:~CSSVAL#string-value
t.color:~CSSCOLOR#typedef-color
	t.color:~CSSWG/css-color-3/#colorunits
t.keyframes-name:~CSSANIM#typedef-keyframes-name
t.keyframe-selector:~CSSANIM#typedef-keyframe-selector
t.selector-list:~SELECTORS4#typedef-selector-list
t.general-enclosed:~MQ4#typedef-general-enclosed
	t.length-percentage
	t.translation-value


	tok.ident:#typedef-ident-token
	tok.function:#typedef-function-token
	tok.at-keyword:#typedef-at-keyword-token
	tok.hash:#typedef-hash-token
	tok.string:#typedef-string-token
	tok.bad-string:#typedef-bad-string-token
	tok.url:#typedef-url-token
	tok.bad-url:#typedef-bad-url-token
	tok.delim:#typedef-delim-token
	tok.number:#typedef-number-token
	tok.percentage:#typedef-percentage-token
	tok.dimension:#typedef-dimension-token
	tok.whitespace:#typedef-whitespace-token
	tok.CDO:#typedef-CDO-token
	tok.CDC:#typedef-CDC-token
	tok.colon:#typedef-colon-token
	tok.semicolon:#typedef-semicolon-token
	tok.comma:#typedef-comma-token
	tok.EOF:#typedef-eof-token

	tok.[:#typedef-[-token
	tok.]:#typedef-]-token
	tok.(:#typedef-(-token
	tok.):#typedef-)-token
	tok.{:#typedef-{-token
	tok.}:#typedef-}-token
	T.~open-square:#typedef-[-token
	T.~close-square:#typedef-]-token
	T.~open-paren:#typedef-(-token
	T.~close-paren:#typedef-)-token
	T.~open-curly:#typedef-{-token
	T.~close-curly:#typedef-}-token


p.text-decoration:~CSSTEXTDECOR#propdef-text-decoration
p.color:~CSSCOLOR#propdef-color
	~CSSWG/css-color-3/#color0
p.animation-timing-function:~CSSANIM#propdef-animation-timing-function

d.unicode-range:~CSSFONT#descdef-unicode-range
	~CSSFONT4:#descdef-font-face-unicode-range

v.underline:~CSSTEXTDECOR#valdef-text-decoration-line-underline

	blue:csswg/css-color-4/#valdef-color-blue
	:left:~CSSPAGE#valdef-page-left

f.attr:~CSSVAL#funcdef-attr
f.translateX:~TRANSFORM#funcdef-transform-translatex
f.url:~CSSVAL#funcdef-url

at.charset:#at-ruledef-charset
at.keyframes:~CSSANIM#keyframes
at.import:~CASCADE#at-ruledef-import
at.media:~CSSCOND#at-ruledef-media
at.supports:~CSSCOND#at-ruledef-supports
at.page:~CSSPAGE#at-ruledef-page
at.font-face:~CSSFONT#at-font-face-rule
	~CSSFONT4#at-font-face-rule
	#at-font-face-rule
	#font-face-rule
at.namespace:~CSSNS#at-ruledef-namespace

ps.nth-child():~SELECTORS4#nth-child-pseudo

e.p:~HEgrouping#the-p-element
e.a:~HEtextlevel#the-a-element
e.img:~HEimages#the-img-element

a.sizes:~HEimages#attr-img-sizes
a.media:~HEmetadata#attr-style-media

I.CSSStyleSheet:~CSSOM1#cssstylesheet

h.Content-Type:~HTTPsem#field.content-type
c.querySelector():~DOM4#dom-parentnode-queryselector

	●用語
無効:#css-invalid
無視-:#css-ignored
構文解析error:#parse-error

~stylesheetの~byte列を復号する:#css-decode-bytes
~fallback符号化法を決定する:#determine-the-fallback-encoding
符号位置~列を~filterする:#css-filter-code-points
	~filter済み符号位置:#css-filter-code-points

~at-ruleを消費:#consume-an-at-rule
~comment列を消費:#consume-comments
~escapeされた符号位置を消費:#consume-an-escaped-code-point
関数式を消費:#consume-a-function
識別子に類する~tokenを消費:#consume-an-ident-like-token
実数を消費:#consume-a-number
有修飾~規則を消費:#consume-a-qualified-rule
~tokenを消費:#consume-a-token
~unicode-range~tokenを消費:#consume-a-unicode-range-token
~url~tokenを消費:#consume-a-url-token
数量-~tokenを消費:#consume-a-numeric-token
成分~値を消費:#consume-a-component-value
宣言~listを消費:#consume-a-list-of-declarations
宣言を消費:#consume-a-declaration
単純~blockを消費:#consume-a-simple-block
識別子を消費:#consume-an-identifier
不良~urlの残余を消費:#consume-the-remnants-of-a-bad-url
規則~listを消費:#consume-a-list-of-rules
文字列~tokenを消費:#consume-a-string-token

~token化する:#css-tokenize
~token~streamに正規化する:#normalize-into-a-token-stream

~stylesheetを構文解析する:#parse-a-stylesheet
規則を構文解析する:#parse-a-rule
成分~値を構文解析する:#parse-a-component-value
宣言~listを構文解析する:#parse-a-list-of-declarations
宣言~list:#parse-a-list-of-declarations
宣言を構文解析する:#parse-a-declaration
規則~listを構文解析する:#parse-a-list-of-rules
規則~list:#parse-a-list-of-rules
成分~値~listを構文解析する:#parse-a-list-of-component-values
~commaで分離された成分~値~listを構文解析する:#parse-a-comma-separated-list-of-component-values

~CSS文法に則って構文解析する:#css-parse-something-according-to-a-css-grammar
構文解析-:#css-parse-something-according-to-a-css-grammar
~commaで分離された~listを~CSS文法に則って構文解析する:#css-parse-a-comma-separated-list-according-to-a-css-grammar
	~listを構文解析する
~CSS~stylesheetを構文解析する:#parse-a-css-stylesheet

実数に変換-:#convert-a-string-to-a-number
~escape法:#escape-codepoint

次入力~tokenを消費:#consume-the-next-input-token
次入力~tokenを消費する:#consume-the-next-input-token
現入力~tokenを消費し直す:#reconsume-the-current-input-token
現入力~符号位置を消費し直す:#reconsume-the-current-input-code-point

~anb 値を直列化-:#serialize-an-anb-value

現入力~token:#current-input-token
現入力~符号位置:#current-input-code-point
次入力~token:#next-input-token
次入力~符号位置:#next-input-code-point
次入力~符号位置を繰返し消費する:#repeatedly-consume-next-code-point
次入力~tokenを繰返し消費する:#repeatedly-consume-next-token

~EOF符号位置:#eof-code-point
数字:#digit
~hex:#hex-digit
正負符号:#plus-or-minus
指数~指示子:#exponent-indicator
英字:#letter
小文字:#lowercase-letter
大文字:#uppercase-letter
非~ASCII符号位置:#non-ascii-code-point
識別子を開始する符号位置:#identifier-start-code-point
識別子~符号位置:#identifier-code-point
印字不能~符号位置:#non-printable-code-point
改行文字:#newline
空白:#whitespace

許容される最大な符号位置:#maximum-allowed-code-point
識別子:#identifier
表現:#representation
入力~stream:#input-stream

環境~符号化法:#environment-encoding

記述子:#css-descriptor
~at-rule:#at-rule
1.~at-rule:#at-rule1
文t~at-rule:#statement-at-rule
~block~at-rule:#block-at-rule

有修飾~規則:#qualified-rule
宣言:#declaration
~prop宣言:#css-property-declarations
記述子~宣言:#css-descriptor-declarations
成分~値:#component-value
保全d~token:#preserved-tokens
関数式:#function
単純~block:#simple-block
成分~値~list:#_component-value-list

波括弧~block:#curly-block
丸括弧~block:#paren-block
角括弧~block:#square-block

	復号-:#decode
	終端ng~token:#ending-token
~style規則:#style-rule
妥当な~escape:#check-if-two-code-points-are-a-valid-escape
妥当な~escapeから開始している:#check-if-two-code-points-are-a-valid-escape
識別子から開始している:#check-if-three-code-points-would-start-an-identifier
実数から開始している:#check-if-three-code-points-would-start-a-number

次の 2 個の入力~符号位置:#next-input-code-point
次の 3 個の入力~符号位置:#next-input-code-point
次の 2 ないし 3 個の入力~符号位置:#next-input-code-point
次の 3 個の入力~符号位置:#next-input-code-point
	後続の n 番目の符号位置
	後続の符号位置(n)

	符号化法:#at-charset-encoding

~anb:#anb-production
~AnB:#anb
周期:#_anb-step
~offset:#_anb-offset
数字~列:#_series-of-digits


	●§
直列化:#serialization
前処理:#input-preprocessing

	●外部（CSS
~list値をとる:~CSSTOM1#list-valued-properties

値~定義~構文:~CSSVAL#value-defs
関数-記法:~CSSVAL#functional-notation
~CSS識別子:~CSSVAL#css-identifier


選択子:~SELECTORS4#selector
無効な選択子:~SELECTORS4#invalid-selector
選択子~list:~SELECTORS4#selector-list
~ID選択子:~SELECTORS4#id-selectors
属性~選択子:~SELECTORS4#attribute-selectors
結合子:~SELECTORS4#selector-combinator

~prop:~CASCADE#css-property
~cascade:~CASCADE#cascade
~importantな宣言:~CASCADE#important
詳細度:~CASCADE#cascade-specificity
出自:~CASCADE#origin
非~CSS呈示~用~hint:~CASCADE#preshint

条件付き~group規則:~CSSCOND#conditional-group-rule
媒体~query~list:~MQ5#media-query-list
媒体~型:~MQ5#media-type

~custom~prop:~CSSVAR#custom-property

~counter~style:~CSSCOUNTER#counter-style

規則~集合:~TR/CSS21/syndata.html#rule-sets
~EOF~errorの取扱い規則:~TR/CSS21/syndata.html#unexpected-eof

	Selectors API:~TR/selectors-api/
	Selectors仕様:~TR/selectors/

	●外部（他
sub.大小無視:~INFRA#ascii-case-insensitive

#ascii-case_insensitive" >＝<sub>
~ASCII大小無視:~INFRA#ascii-case-insensitive
符号位置:~INFRA#code-point
~surrogate:~INFRA#surrogate
~scalar値:~INFRA#scalar-value
文字列:~INFRA#string
~list:~INFRA#list

符号化法~label:~ENCODING#label
~Unicodeに復号する:~ENCODING#decode
	復号-~algo:~ENCODING#decode
~labelから符号化法を取得する:~ENCODING#concept-encoding-get
enc.UTF-16LE:~ENCODING#utf-16le
enc.UTF-16BE:~ENCODING#utf-16be
enc.UTF-8:~ENCODING#utf-8


●●unicode_map


00:NULL
08:BACKSPACE
09:CHARACTER TABULATION
0A:LINE FEED
0B:LINE TABULATION
0C:FORM FEED
0D:CARRIAGE RETURN
0E:SHIFT OUT
1F:INFORMATION SEPARATOR ONE
20:SPACE
21!EXCLAMATION MARK
22!QUOTATION MARK
23!NUMBER SIGN
24!DOLLAR SIGN
25!PERCENTAGE SIGN
27!APOSTROPHE
28!LEFT PARENTHESIS
29!RIGHT PARENTHESIS
2A!ASTERISK
2B!PLUS SIGN
2C!COMMA
2D!HYPHEN-MINUS
2E!FULL STOP
2F!SOLIDUS
30!DIGIT ZERO
39!DIGIT NINE
3A!COLON
3B!SEMICOLON
3C!LESS-THAN SIGN
3D!EQUALS SIGN
3E!GREATER-THAN SIGN
3F!QUESTION MARK
40!COMMERCIAL AT
41!LATIN CAPITAL LETTER A
45!LATIN CAPITAL LETTER E
46!LATIN CAPITAL LETTER F
55!LATIN CAPITAL LETTER U
5A!LATIN CAPITAL LETTER Z
5B!LEFT SQUARE BRACKET
5C!REVERSE SOLIDUS
5D!RIGHT SQUARE BRACKET
5E!CIRCUMFLEX ACCENT
5F!LOW LINE
61!LATIN SMALL LETTER A
65!LATIN SMALL LETTER E
66!LATIN SMALL LETTER F
75!LATIN SMALL LETTER U
7A!LATIN SMALL LETTER Z
7B!LEFT CURLY BRACKET
7C!VERTICAL LINE
7D!RIGHT CURLY BRACKET
7E!TILDE
7F:DELETE
80:&lt;control&gt;
FFFD:REPLACEMENT CHARACTER
	0080 〜 009F
	D800 〜 DFFF


●●ref_normative

[CSS-CASCADE-3]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 11 February 2021. REC. URL: https://www.w3.org/TR/css-cascade-3/ 
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. CSS Cascading and Inheritance Level 5. 19 March 2021. WD. URL: https://www.w3.org/TR/css-cascade-5/ 
[CSS-COUNTER-STYLES-3]
    Tab Atkins Jr.. CSS Counter Styles Level 3. 14 December 2017. CR. URL: https://www.w3.org/TR/css-counter-styles-3/ 
[CSS-PAGE-3]
    Elika Etemad; Simon Sapin. CSS Paged Media Module Level 3. 18 October 2018. WD. URL: https://www.w3.org/TR/css-page-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 11 November 2020. WD. URL: https://www.w3.org/TR/css-values-4/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 

●●ref_informative

[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 12 November 2020. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-FONTS-4]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 4. 17 November 2020. WD. URL: https://www.w3.org/TR/css-fonts-4/ 
[CSS-FONTS-5]
    CSS Fonts Module Level 5 URL: https://www.w3.org/TR/css-fonts-5/ 
[CSS-TEXT-DECOR-3]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 3. 13 August 2019. CR. URL: https://www.w3.org/TR/css-text-decor-3/ 
[CSS-TEXT-DECOR-4]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 4. 6 May 2020. WD. URL: https://www.w3.org/TR/css-text-decor-4/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VARIABLES]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/ 
[CSS3-ANIMATIONS]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS3-CONDITIONAL]
    David Baron; Elika Etemad; Chris Lilley. CSS Conditional Rules Module Level 3. 8 December 2020. CR. URL: https://www.w3.org/TR/css-conditional-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[MEDIAQ]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 21 July 2020. CR. URL: https://www.w3.org/TR/mediaqueries-4/ 
[MEDIAQUERIES-5]
    Dean Jackson; Florian Rivoal; Tab Atkins Jr.. Media Queries Level 5. 31 July 2020. WD. URL: https://www.w3.org/TR/mediaqueries-5/ 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより勧告候補として公開された
<a href="~SPEC_URL">CSS Syntax Module Level 3</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

このバージョン
	https://www.w3.org/TR/2019/CR-css-syntax-3-20190716/
最新発行バージョン
	https://www.w3.org/TR/css-syntax-3/
編集者草案
	https://drafts.csswg.org/css-syntax/
以前のバージョン
	https://www.w3.org/TR/2019/CR-css-syntax-3-20190716/
	https://www.w3.org/TR/2014/CR-css-syntax-3-20140220/
	https://www.w3.org/TR/2013/WD-css-syntax-3-20131105/
	https://www.w3.org/TR/2013/WD-css-syntax-3-20130919/

テスト一式
	http://test.csswg.org/suites/css-syntax-3_dev/nightly-unstable/
実装報告（暫定的）
	https://wpt.fyi/results/css/css-syntax?label=master&label=experimental
課題追跡
	<a href="https://github.com/w3c/csswg-drafts/labels/css-syntax-3">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
	<a href="http://exyr.org/about/">Simon Sapin</a> (Mozilla)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-syntax-3/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-syntax-3

</script>

</head>
<body>

<!--%resource pool -->
<div id="_persisted_parts" hidden>

<!-- 
<a href="">\n(.+\n)\1</a>\n → $1
 -->

	<!-- tokenizer railroad -->

<svg id="_dgm-comment" class="railroad-diagram" height="80" viewBox="0 0 496 80" width="496">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="terminal">
<path d="M50 40h0"></path>
<path d="M86 40h0"></path>
<rect height="22" rx="10" ry="10" width="36" x="50" y="29"></rect>
<text x="68" y="44">/*</text>
</g>
<path d="M86 40h10"></path>
<g>
<path d="M96 40h0"></path>
<path d="M400 40h0"></path>
<path d="M96 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M116 20h264"></path>
</g>
<path d="M380 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M96 40h20"></path>
<g>
<path d="M116 40h0"></path>
<path d="M380 40h0"></path>
<path d="M116 40h10"></path>
<g class="non-terminal">
<path d="M126 40h0"></path>
<path d="M370 40h0"></path>
<rect height="22" width="244" x="126" y="29"></rect>
<text x="248" y="44">anything but * followed by /</text>
</g>
<path d="M370 40h10"></path>
<path d="M126 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M126 60h244"></path>
</g>
<path d="M370 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M380 40h20"></path>
</g>
<path d="M400 40h10"></path>
<g class="terminal">
<path d="M410 40h0"></path>
<path d="M446 40h0"></path>
<rect height="22" rx="10" ry="10" width="36" x="410" y="29"></rect>
<text x="428" y="44">*/</text>
</g>
<path d="M446 40h10"></path>
<path d="M 456 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-newline" class="railroad-diagram" height="152" viewBox="0 0 172 152" width="172">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 31h0"></path>
<path d="M132 31h0"></path>
<path d="M40 31h20"></path>
<g class="terminal">
<path d="M60 31h8"></path>
<path d="M104 31h8"></path>
<rect height="22" rx="10" ry="10" width="36" x="68" y="20"></rect>
<text x="86" y="35">\n</text>
</g>
<path d="M112 31h20"></path>
<path d="M40 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M60 61h0"></path>
<path d="M112 61h0"></path>
<rect height="22" rx="10" ry="10" width="52" x="60" y="50"></rect>
<text x="86" y="65">\r\n</text>
</g>
<path d="M112 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M60 91h8"></path>
<path d="M104 91h8"></path>
<rect height="22" rx="10" ry="10" width="36" x="68" y="80"></rect>
<text x="86" y="95">\r</text>
</g>
<path d="M112 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<path d="M40 31a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M60 121h8"></path>
<path d="M104 121h8"></path>
<rect height="22" rx="10" ry="10" width="36" x="68" y="110"></rect>
<text x="86" y="125">\f</text>
</g>
<path d="M112 121a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 132 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-whitespace" class="railroad-diagram" height="122" viewBox="0 0 196 122" width="196">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 31h0"></path>
<path d="M156 31h0"></path>
<path d="M40 31h20"></path>
<g class="terminal">
<path d="M60 31h8"></path>
<path d="M128 31h8"></path>
<rect height="22" rx="10" ry="10" width="60" x="68" y="20"></rect>
<text x="98" y="35">space</text>
</g>
<path d="M136 31h20"></path>
<path d="M40 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M60 61h20"></path>
<path d="M116 61h20"></path>
<rect height="22" rx="10" ry="10" width="36" x="80" y="50"></rect>
<text x="98" y="65">\t</text>
</g>
<path d="M136 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M60 91h0"></path>
<path d="M136 91h0"></path>
<rect height="22" width="76" x="60" y="80"></rect>
<text x="98" y="95">newline</text>
</g>
<path d="M136 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 156 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-hex-digit" class="railroad-diagram" height="62" viewBox="0 0 232 62" width="232">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="non-terminal">
<path d="M50 31h0"></path>
<path d="M182 31h0"></path>
<rect height="22" width="132" x="50" y="20"></rect>
<text x="116" y="35">0-9 a-f or A-F</text>
</g>
<path d="M182 31h10"></path>
<path d="M 192 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-escape" class="railroad-diagram" height="122" viewBox="0 0 430 122" width="430">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="terminal">
<path d="M50 31h0"></path>
<path d="M78 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="20"></rect>
<text x="64" y="35">\</text>
</g>
<path d="M78 31h10"></path>
<g>
<path d="M88 31h0"></path>
<path d="M390 31h0"></path>
<path d="M88 31h20"></path>
<g class="non-terminal">
<path d="M108 31h25"></path>
<path d="M345 31h25"></path>
<rect height="22" width="212" x="133" y="20"></rect>
<text x="239" y="35">not newline or hex digit</text>
</g>
<path d="M370 31h20"></path>
<path d="M88 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g>
<path d="M108 61h0"></path>
<path d="M370 61h0"></path>
<g>
<path d="M108 61h0"></path>
<path d="M220 61h0"></path>
<path d="M108 61h10"></path>
<g class="non-terminal">
<path d="M118 61h0"></path>
<path d="M210 61h0"></path>
<rect height="22" width="92" x="118" y="50"></rect>
<text x="164" y="65">hex digit</text>
</g>
<path d="M210 61h10"></path>
<path d="M118 61a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path>
<g>
<path d="M118 91h9.5"></path>
<path d="M200.5 91h9.5"></path>
<text class="comment" x="164" y="96">1-6 times</text>
</g>
<path d="M210 91a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M220 61h10"></path>
<g>
<path d="M230 61h0"></path>
<path d="M370 61h0"></path>
<path d="M230 61h20"></path>
<g>
<path d="M250 61h100"></path>
</g>
<path d="M350 61h20"></path>
<path d="M230 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M250 81h0"></path>
<path d="M350 81h0"></path>
<rect height="22" width="100" x="250" y="70"></rect>
<text x="300" y="85">whitespace</text>
</g>
<path d="M350 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
</g>
</g>
<path d="M370 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 390 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-whitespace-token" class="railroad-diagram" height="71" viewBox="0 0 220 71" width="220">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g>
<path d="M50 31h0"></path>
<path d="M170 31h0"></path>
<path d="M50 31h10"></path>
<g class="non-terminal">
<path d="M60 31h0"></path>
<path d="M160 31h0"></path>
<rect height="22" width="100" x="60" y="20"></rect>
<text x="110" y="35">whitespace</text>
</g>
<path d="M160 31h10"></path>
<path d="M60 31a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M60 51h100"></path>
</g>
<path d="M160 51a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M170 31h10"></path>
<path d="M 180 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-whitespaces" class="railroad-diagram" height="80" viewBox="0 0 304 80" width="304">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 40h0"></path>
<path d="M264 40h0"></path>
<path d="M40 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M60 20h184"></path>
</g>
<path d="M244 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M40 40h20"></path>
<g>
<path d="M60 40h0"></path>
<path d="M244 40h0"></path>
<path d="M60 40h10"></path>
<g class="non-terminal">
<path d="M70 40h0"></path>
<path d="M234 40h0"></path>
<rect height="22" width="164" x="70" y="29"></rect>
<text x="152" y="44">&lt;whitespace-token&gt;</text>
</g>
<path d="M234 40h10"></path>
<path d="M70 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M70 60h164"></path>
</g>
<path d="M234 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M244 40h20"></path>
</g>
<path d="M 264 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-ident-token" class="railroad-diagram" height="130" viewBox="0 0 768 130" width="768">
<g transform="translate(.5 .5)">
<path d="M 20 51 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 61h0"></path>
<path d="M384 61h0"></path>
<path d="M40 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g class="terminal">
<path d="M60 31h134"></path>
<path d="M230 31h134"></path>
<rect height="22" rx="10" ry="10" width="36" x="194" y="20"></rect>
<text x="212" y="35">--</text>
</g>
<path d="M364 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M40 61h20"></path>
<g>
<path d="M60 61h0"></path>
<path d="M364 61h0"></path>
<g>
<path d="M60 61h0"></path>
<path d="M128 61h0"></path>
<path d="M60 61h20"></path>
<g>
<path d="M80 61h28"></path>
</g>
<path d="M108 61h20"></path>
<path d="M60 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M80 81h0"></path>
<path d="M108 81h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="80" y="70"></rect>
<text x="94" y="85">-</text>
</g>
<path d="M108 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
</g>
<g>
<path d="M128 61h0"></path>
<path d="M364 61h0"></path>
<path d="M128 61h20"></path>
<g class="non-terminal">
<path d="M148 61h0"></path>
<path d="M344 61h0"></path>
<rect height="22" width="196" x="148" y="50"></rect>
<text x="246" y="65">a-z A-Z _ or non-ASCII</text>
</g>
<path d="M344 61h20"></path>
<path d="M128 61a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M148 91h64"></path>
<path d="M280 91h64"></path>
<rect height="22" width="68" x="212" y="80"></rect>
<text x="246" y="95">escape</text>
</g>
<path d="M344 91a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
</g>
<path d="M364 61h20"></path>
</g>
<g>
<path d="M384 61h0"></path>
<path d="M728 61h0"></path>
<path d="M384 61a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M404 41h304"></path>
</g>
<path d="M708 41a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M384 61h20"></path>
<g>
<path d="M404 61h0"></path>
<path d="M708 61h0"></path>
<path d="M404 61h10"></path>
<g>
<path d="M414 61h0"></path>
<path d="M698 61h0"></path>
<path d="M414 61h20"></path>
<g class="non-terminal">
<path d="M434 61h0"></path>
<path d="M678 61h0"></path>
<rect height="22" width="244" x="434" y="50"></rect>
<text x="556" y="65">a-z A-Z 0-9 _ - or non-ASCII</text>
</g>
<path d="M678 61h20"></path>
<path d="M414 61a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M434 91h88"></path>
<path d="M590 91h88"></path>
<rect height="22" width="68" x="522" y="80"></rect>
<text x="556" y="95">escape</text>
</g>
<path d="M678 91a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M698 61h10"></path>
<path d="M414 61a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<g>
<path d="M414 110h284"></path>
</g>
<path d="M698 110a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M708 61h20"></path>
</g>
<path d="M 728 61 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-function-token" class="railroad-diagram" height="62" viewBox="0 0 272 62" width="272">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="non-terminal">
<path d="M50 31h0"></path>
<path d="M174 31h0"></path>
<rect height="22" width="124" x="50" y="20"></rect>
<text x="112" y="35">&lt;ident-token&gt;</text>
</g>
<path d="M174 31h10"></path>
<path d="M184 31h10"></path>
<g class="terminal">
<path d="M194 31h0"></path>
<path d="M222 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="194" y="20"></rect>
<text x="208" y="35">(</text>
</g>
<path d="M222 31h10"></path>
<path d="M 232 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-at-keyword-token" class="railroad-diagram" height="62" viewBox="0 0 272 62" width="272">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="terminal">
<path d="M50 31h0"></path>
<path d="M78 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="20"></rect>
<text x="64" y="35">@</text>
</g>
<path d="M78 31h10"></path>
<path d="M88 31h10"></path>
<g class="non-terminal">
<path d="M98 31h0"></path>
<path d="M222 31h0"></path>
<rect height="22" width="124" x="98" y="20"></rect>
<text x="160" y="35">&lt;ident-token&gt;</text>
</g>
<path d="M222 31h10"></path>
<path d="M 232 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-hash-token" class="railroad-diagram" height="100" viewBox="0 0 452 100" width="452">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="terminal">
<path d="M50 31h0"></path>
<path d="M78 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="20"></rect>
<text x="64" y="35">#</text>
</g>
<path d="M78 31h10"></path>
<path d="M88 31h10"></path>
<g>
<path d="M98 31h0"></path>
<path d="M402 31h0"></path>
<path d="M98 31h10"></path>
<g>
<path d="M108 31h0"></path>
<path d="M392 31h0"></path>
<path d="M108 31h20"></path>
<g class="non-terminal">
<path d="M128 31h0"></path>
<path d="M372 31h0"></path>
<rect height="22" width="244" x="128" y="20"></rect>
<text x="250" y="35">a-z A-Z 0-9 _ - or non-ASCII</text>
</g>
<path d="M372 31h20"></path>
<path d="M108 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M128 61h88"></path>
<path d="M284 61h88"></path>
<rect height="22" width="68" x="216" y="50"></rect>
<text x="250" y="65">escape</text>
</g>
<path d="M372 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M392 31h10"></path>
<path d="M108 31a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<g>
<path d="M108 80h284"></path>
</g>
<path d="M392 80a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M402 31h10"></path>
<path d="M 412 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-string-token" class="railroad-diagram" height="246" viewBox="0 0 460 246" width="460">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 40h0"></path>
<path d="M420 40h0"></path>
<path d="M40 40h20"></path>
<g>
<path d="M60 40h0"></path>
<path d="M400 40h0"></path>
<g class="terminal">
<path d="M60 40h0"></path>
<path d="M88 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="60" y="29"></rect>
<text x="74" y="44">"</text>
</g>
<path d="M88 40h10"></path>
<g>
<path d="M98 40h0"></path>
<path d="M362 40h0"></path>
<path d="M98 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M118 20h224"></path>
</g>
<path d="M342 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M98 40h20"></path>
<g>
<path d="M118 40h0"></path>
<path d="M342 40h0"></path>
<path d="M118 40h10"></path>
<g>
<path d="M128 40h0"></path>
<path d="M332 40h0"></path>
<path d="M128 40h20"></path>
<g class="non-terminal">
<path d="M148 40h0"></path>
<path d="M312 40h0"></path>
<rect height="22" width="164" x="148" y="29"></rect>
<text x="230" y="44">not " \ or newline</text>
</g>
<path d="M312 40h20"></path>
<path d="M128 40a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M148 70h48"></path>
<path d="M264 70h48"></path>
<rect height="22" width="68" x="196" y="59"></rect>
<text x="230" y="74">escape</text>
</g>
<path d="M312 70a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M128 40a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<g>
<path d="M148 100h20"></path>
<path d="M292 100h20"></path>
<g class="terminal">
<path d="M168 100h0"></path>
<path d="M196 100h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="168" y="89"></rect>
<text x="182" y="104">\</text>
</g>
<path d="M196 100h10"></path>
<path d="M206 100h10"></path>
<g class="non-terminal">
<path d="M216 100h0"></path>
<path d="M292 100h0"></path>
<rect height="22" width="76" x="216" y="89"></rect>
<text x="254" y="104">newline</text>
</g>
</g>
<path d="M312 100a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
</g>
<path d="M332 40h10"></path>
<path d="M128 40a10 10 0 0 0 -10 10v59a10 10 0 0 0 10 10"></path>
<g>
<path d="M128 119h204"></path>
</g>
<path d="M332 119a10 10 0 0 0 10 -10v-59a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M342 40h20"></path>
</g>
<path d="M362 40h10"></path>
<g class="terminal">
<path d="M372 40h0"></path>
<path d="M400 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="372" y="29"></rect>
<text x="386" y="44">"</text>
</g>
</g>
<path d="M400 40h20"></path>
<path d="M40 40a10 10 0 0 1 10 10v87a10 10 0 0 0 10 10"></path>
<g>
<path d="M60 147h0"></path>
<path d="M400 147h0"></path>
<g class="terminal">
<path d="M60 147h0"></path>
<path d="M88 147h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="60" y="136"></rect>
<text x="74" y="151">'</text>
</g>
<path d="M88 147h10"></path>
<g>
<path d="M98 147h0"></path>
<path d="M362 147h0"></path>
<path d="M98 147a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M118 127h224"></path>
</g>
<path d="M342 127a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M98 147h20"></path>
<g>
<path d="M118 147h0"></path>
<path d="M342 147h0"></path>
<path d="M118 147h10"></path>
<g>
<path d="M128 147h0"></path>
<path d="M332 147h0"></path>
<path d="M128 147h20"></path>
<g class="non-terminal">
<path d="M148 147h0"></path>
<path d="M312 147h0"></path>
<rect height="22" width="164" x="148" y="136"></rect>
<text x="230" y="151">not ' \ or newline</text>
</g>
<path d="M312 147h20"></path>
<path d="M128 147a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M148 177h48"></path>
<path d="M264 177h48"></path>
<rect height="22" width="68" x="196" y="166"></rect>
<text x="230" y="181">escape</text>
</g>
<path d="M312 177a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M128 147a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<g>
<path d="M148 207h20"></path>
<path d="M292 207h20"></path>
<g class="terminal">
<path d="M168 207h0"></path>
<path d="M196 207h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="168" y="196"></rect>
<text x="182" y="211">\</text>
</g>
<path d="M196 207h10"></path>
<path d="M206 207h10"></path>
<g class="non-terminal">
<path d="M216 207h0"></path>
<path d="M292 207h0"></path>
<rect height="22" width="76" x="216" y="196"></rect>
<text x="254" y="211">newline</text>
</g>
</g>
<path d="M312 207a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
</g>
<path d="M332 147h10"></path>
<path d="M128 147a10 10 0 0 0 -10 10v59a10 10 0 0 0 10 10"></path>
<g>
<path d="M128 226h204"></path>
</g>
<path d="M332 226a10 10 0 0 0 10 -10v-59a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M342 147h20"></path>
</g>
<path d="M362 147h10"></path>
<g class="terminal">
<path d="M372 147h0"></path>
<path d="M400 147h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="372" y="136"></rect>
<text x="386" y="151">'</text>
</g>
</g>
<path d="M400 147a10 10 0 0 0 10 -10v-87a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 420 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-url-token" class="railroad-diagram" height="109" viewBox="0 0 880 109" width="880">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="non-terminal">
<path d="M50 40h0"></path>
<path d="M222 40h0"></path>
<rect height="22" width="172" x="50" y="29"></rect>
<text x="136" y="44">&lt;ident-token "url"&gt;</text>
</g>
<path d="M222 40h10"></path>
<path d="M232 40h10"></path>
<g class="terminal">
<path d="M242 40h0"></path>
<path d="M270 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="242" y="29"></rect>
<text x="256" y="44">(</text>
</g>
<path d="M270 40h10"></path>
<path d="M280 40h10"></path>
<g class="non-terminal">
<path d="M290 40h0"></path>
<path d="M334 40h0"></path>
<rect height="22" width="44" x="290" y="29"></rect>
<text x="312" y="44">ws*</text>
</g>
<path d="M334 40h10"></path>
<g>
<path d="M344 40h0"></path>
<path d="M728 40h0"></path>
<path d="M344 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M364 20h344"></path>
</g>
<path d="M708 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M344 40h20"></path>
<g>
<path d="M364 40h0"></path>
<path d="M708 40h0"></path>
<path d="M364 40h10"></path>
<g>
<path d="M374 40h0"></path>
<path d="M698 40h0"></path>
<path d="M374 40h20"></path>
<g class="non-terminal">
<path d="M394 40h0"></path>
<path d="M678 40h0"></path>
<rect height="22" width="284" x="394" y="29"></rect>
<text x="536" y="44">not " ' ( ) \ ws or non-printable</text>
</g>
<path d="M678 40h20"></path>
<path d="M374 40a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M394 70h108"></path>
<path d="M570 70h108"></path>
<rect height="22" width="68" x="502" y="59"></rect>
<text x="536" y="74">escape</text>
</g>
<path d="M678 70a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M698 40h10"></path>
<path d="M374 40a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<g>
<path d="M374 89h324"></path>
</g>
<path d="M698 89a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M708 40h20"></path>
</g>
<path d="M728 40h10"></path>
<g class="non-terminal">
<path d="M738 40h0"></path>
<path d="M782 40h0"></path>
<rect height="22" width="44" x="738" y="29"></rect>
<text x="760" y="44">ws*</text>
</g>
<path d="M782 40h10"></path>
<path d="M792 40h10"></path>
<g class="terminal">
<path d="M802 40h0"></path>
<path d="M830 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="802" y="29"></rect>
<text x="816" y="44">)</text>
</g>
<path d="M830 40h10"></path>
<path d="M 840 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-number-token" class="railroad-diagram" height="169" viewBox="0 0 682 169" width="682">
<g transform="translate(.5 .5)">
<path d="M 20 41 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 51h0"></path>
<path d="M108 51h0"></path>
<path d="M40 51a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g class="terminal">
<path d="M60 31h0"></path>
<path d="M88 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="60" y="20"></rect>
<text x="74" y="35">+</text>
</g>
<path d="M88 31a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M40 51h20"></path>
<g>
<path d="M60 51h28"></path>
</g>
<path d="M88 51h20"></path>
<path d="M40 51a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M60 71h0"></path>
<path d="M88 71h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="60" y="60"></rect>
<text x="74" y="75">-</text>
</g>
<path d="M88 71a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
</g>
<g>
<path d="M108 51h0"></path>
<path d="M376 51h0"></path>
<path d="M108 51h20"></path>
<g>
<path d="M128 51h0"></path>
<path d="M356 51h0"></path>
<g>
<path d="M128 51h0"></path>
<path d="M208 51h0"></path>
<path d="M128 51h10"></path>
<g class="non-terminal">
<path d="M138 51h0"></path>
<path d="M198 51h0"></path>
<rect height="22" width="60" x="138" y="40"></rect>
<text x="168" y="55">digit</text>
</g>
<path d="M198 51h10"></path>
<path d="M138 51a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M138 71h60"></path>
</g>
<path d="M198 71a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M208 51h10"></path>
<path d="M218 51h10"></path>
<g class="terminal">
<path d="M228 51h0"></path>
<path d="M256 51h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="228" y="40"></rect>
<text x="242" y="55">.</text>
</g>
<path d="M256 51h10"></path>
<path d="M266 51h10"></path>
<g>
<path d="M276 51h0"></path>
<path d="M356 51h0"></path>
<path d="M276 51h10"></path>
<g class="non-terminal">
<path d="M286 51h0"></path>
<path d="M346 51h0"></path>
<rect height="22" width="60" x="286" y="40"></rect>
<text x="316" y="55">digit</text>
</g>
<path d="M346 51h10"></path>
<path d="M286 51a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M286 71h60"></path>
</g>
<path d="M346 71a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
</g>
<path d="M356 51h20"></path>
<path d="M108 51a10 10 0 0 1 10 10v19a10 10 0 0 0 10 10"></path>
<g>
<path d="M128 90h74"></path>
<path d="M282 90h74"></path>
<path d="M202 90h10"></path>
<g class="non-terminal">
<path d="M212 90h0"></path>
<path d="M272 90h0"></path>
<rect height="22" width="60" x="212" y="79"></rect>
<text x="242" y="94">digit</text>
</g>
<path d="M272 90h10"></path>
<path d="M212 90a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M212 110h60"></path>
</g>
<path d="M272 110a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M356 90a10 10 0 0 0 10 -10v-19a10 10 0 0 1 10 -10"></path>
<path d="M108 51a10 10 0 0 1 10 10v58a10 10 0 0 0 10 10"></path>
<g>
<path d="M128 129h50"></path>
<path d="M306 129h50"></path>
<g class="terminal">
<path d="M178 129h0"></path>
<path d="M206 129h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="178" y="118"></rect>
<text x="192" y="133">.</text>
</g>
<path d="M206 129h10"></path>
<path d="M216 129h10"></path>
<g>
<path d="M226 129h0"></path>
<path d="M306 129h0"></path>
<path d="M226 129h10"></path>
<g class="non-terminal">
<path d="M236 129h0"></path>
<path d="M296 129h0"></path>
<rect height="22" width="60" x="236" y="118"></rect>
<text x="266" y="133">digit</text>
</g>
<path d="M296 129h10"></path>
<path d="M236 129a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M236 149h60"></path>
</g>
<path d="M296 149a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
</g>
<path d="M356 129a10 10 0 0 0 10 -10v-58a10 10 0 0 1 10 -10"></path>
</g>
<g>
<path d="M376 51h0"></path>
<path d="M642 51h0"></path>
<path d="M376 51h20"></path>
<g>
<path d="M396 51h226"></path>
</g>
<path d="M622 51h20"></path>
<path d="M376 51a10 10 0 0 1 10 10v19a10 10 0 0 0 10 10"></path>
<g>
<path d="M396 90h0"></path>
<path d="M622 90h0"></path>
<g>
<path d="M396 90h0"></path>
<path d="M464 90h0"></path>
<path d="M396 90h20"></path>
<g class="terminal">
<path d="M416 90h0"></path>
<path d="M444 90h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="416" y="79"></rect>
<text x="430" y="94">e</text>
</g>
<path d="M444 90h20"></path>
<path d="M396 90a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M416 120h0"></path>
<path d="M444 120h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="416" y="109"></rect>
<text x="430" y="124">E</text>
</g>
<path d="M444 120a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<g>
<path d="M464 90h0"></path>
<path d="M532 90h0"></path>
<path d="M464 90a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g class="terminal">
<path d="M484 70h0"></path>
<path d="M512 70h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="484" y="59"></rect>
<text x="498" y="74">+</text>
</g>
<path d="M512 70a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M464 90h20"></path>
<g>
<path d="M484 90h28"></path>
</g>
<path d="M512 90h20"></path>
<path d="M464 90a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M484 110h0"></path>
<path d="M512 110h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="484" y="99"></rect>
<text x="498" y="114">-</text>
</g>
<path d="M512 110a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
</g>
<path d="M532 90h10"></path>
<g>
<path d="M542 90h0"></path>
<path d="M622 90h0"></path>
<path d="M542 90h10"></path>
<g class="non-terminal">
<path d="M552 90h0"></path>
<path d="M612 90h0"></path>
<rect height="22" width="60" x="552" y="79"></rect>
<text x="582" y="94">digit</text>
</g>
<path d="M612 90h10"></path>
<path d="M552 90a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M552 110h60"></path>
</g>
<path d="M612 110a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
</g>
<path d="M622 90a10 10 0 0 0 10 -10v-19a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 642 51 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-dimension-token" class="railroad-diagram" height="62" viewBox="0 0 376 62" width="376">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="non-terminal">
<path d="M50 31h0"></path>
<path d="M182 31h0"></path>
<rect height="22" width="132" x="50" y="20"></rect>
<text x="116" y="35">&lt;number-token&gt;</text>
</g>
<path d="M182 31h10"></path>
<path d="M192 31h10"></path>
<g class="non-terminal">
<path d="M202 31h0"></path>
<path d="M326 31h0"></path>
<rect height="22" width="124" x="202" y="20"></rect>
<text x="264" y="35">&lt;ident-token&gt;</text>
</g>
<path d="M326 31h10"></path>
<path d="M 336 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-percentage-token" class="railroad-diagram" height="62" viewBox="0 0 280 62" width="280">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="non-terminal">
<path d="M50 31h0"></path>
<path d="M182 31h0"></path>
<rect height="22" width="132" x="50" y="20"></rect>
<text x="116" y="35">&lt;number-token&gt;</text>
</g>
<path d="M182 31h10"></path>
<path d="M192 31h10"></path>
<g class="terminal">
<path d="M202 31h0"></path>
<path d="M230 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="202" y="20"></rect>
<text x="216" y="35">%</text>
</g>
<path d="M230 31h10"></path>
<path d="M 240 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-CDO-token" class="railroad-diagram" height="62" viewBox="0 0 152 62" width="152">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="terminal">
<path d="M50 31h0"></path>
<path d="M102 31h0"></path>
<rect height="22" rx="10" ry="10" width="52" x="50" y="20"></rect>
<text x="76" y="35">&lt;!--</text>
</g>
<path d="M102 31h10"></path>
<path d="M 112 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-CDC-token" class="railroad-diagram" height="62" viewBox="0 0 144 62" width="144">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="terminal">
<path d="M50 31h0"></path>
<path d="M94 31h0"></path>
<rect height="22" rx="10" ry="10" width="44" x="50" y="20"></rect>
<text x="72" y="35">--&gt;</text>
</g>
<path d="M94 31h10"></path>
<path d="M 104 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

	<!-- parser railroad -->

<svg id="_dgm-stylesheet" class="railroad-diagram" height="198" viewBox="0 0 344 198" width="344">
<g transform="translate(.5 .5)">
<path d="M 20 119 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 129h0"></path>
<path d="M304 129h0"></path>
<path d="M40 129a10 10 0 0 0 10 -10v-89a10 10 0 0 1 10 -10"></path>
<g>
<path d="M60 20h224"></path>
</g>
<path d="M284 20a10 10 0 0 1 10 10v89a10 10 0 0 0 10 10"></path>
<path d="M40 129h20"></path>
<g>
<path d="M60 129h0"></path>
<path d="M284 129h0"></path>
<path d="M60 129h10"></path>
<g>
<path d="M70 129h0"></path>
<path d="M274 129h0"></path>
<path d="M70 129a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g class="non-terminal">
<path d="M90 99h0"></path>
<path d="M254 99h0"></path>
<rect height="22" width="164" x="90" y="88"></rect>
<text x="172" y="103">&lt;whitespace-token&gt;</text>
</g>
<path d="M254 99a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M70 129a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<g class="non-terminal">
<path d="M90 69h28"></path>
<path d="M226 69h28"></path>
<rect height="22" width="108" x="118" y="58"></rect>
<text x="172" y="73">&lt;CDC-token&gt;</text>
</g>
<path d="M254 69a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<path d="M70 129a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
<g class="non-terminal">
<path d="M90 39h28"></path>
<path d="M226 39h28"></path>
<rect height="22" width="108" x="118" y="28"></rect>
<text x="172" y="43">&lt;CDO-token&gt;</text>
</g>
<path d="M254 39a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
<path d="M70 129h20"></path>
<g class="non-terminal">
<path d="M90 129h16"></path>
<path d="M238 129h16"></path>
<rect height="22" width="132" x="106" y="118"></rect>
<text x="172" y="133">Qualified rule</text>
</g>
<path d="M254 129h20"></path>
<path d="M70 129a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M90 159h44"></path>
<path d="M210 159h44"></path>
<rect height="22" width="76" x="134" y="148"></rect>
<text x="172" y="163">At-rule</text>
</g>
<path d="M254 159a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M274 129h10"></path>
<path d="M70 129a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<g>
<path d="M70 178h204"></path>
</g>
<path d="M274 178a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M284 129h20"></path>
</g>
<path d="M 304 129 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-rule-list" class="railroad-diagram" height="138" viewBox="0 0 344 138" width="344">
<g transform="translate(.5 .5)">
<path d="M 20 59 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 69h0"></path>
<path d="M304 69h0"></path>
<path d="M40 69a10 10 0 0 0 10 -10v-29a10 10 0 0 1 10 -10"></path>
<g>
<path d="M60 20h224"></path>
</g>
<path d="M284 20a10 10 0 0 1 10 10v29a10 10 0 0 0 10 10"></path>
<path d="M40 69h20"></path>
<g>
<path d="M60 69h0"></path>
<path d="M284 69h0"></path>
<path d="M60 69h10"></path>
<g>
<path d="M70 69h0"></path>
<path d="M274 69h0"></path>
<path d="M70 69a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<g class="non-terminal">
<path d="M90 39h0"></path>
<path d="M254 39h0"></path>
<rect height="22" width="164" x="90" y="28"></rect>
<text x="172" y="43">&lt;whitespace-token&gt;</text>
</g>
<path d="M254 39a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<path d="M70 69h20"></path>
<g class="non-terminal">
<path d="M90 69h16"></path>
<path d="M238 69h16"></path>
<rect height="22" width="132" x="106" y="58"></rect>
<text x="172" y="73">Qualified rule</text>
</g>
<path d="M254 69h20"></path>
<path d="M70 69a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M90 99h44"></path>
<path d="M210 99h44"></path>
<rect height="22" width="76" x="134" y="88"></rect>
<text x="172" y="103">At-rule</text>
</g>
<path d="M254 99a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M274 69h10"></path>
<path d="M70 69a10 10 0 0 0 -10 10v29a10 10 0 0 0 10 10"></path>
<g>
<path d="M70 118h204"></path>
</g>
<path d="M274 118a10 10 0 0 0 10 -10v-29a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M284 69h20"></path>
</g>
<path d="M 304 69 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-at-rule" class="railroad-diagram" height="101" viewBox="0 0 588 101" width="588">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="non-terminal">
<path d="M50 40h0"></path>
<path d="M214 40h0"></path>
<rect height="22" width="164" x="50" y="29"></rect>
<text x="132" y="44">&lt;at-keyword-token&gt;</text>
</g>
<path d="M214 40h10"></path>
<g>
<path d="M224 40h0"></path>
<path d="M424 40h0"></path>
<path d="M224 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M244 20h160"></path>
</g>
<path d="M404 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M224 40h20"></path>
<g>
<path d="M244 40h0"></path>
<path d="M404 40h0"></path>
<path d="M244 40h10"></path>
<g class="non-terminal">
<path d="M254 40h0"></path>
<path d="M394 40h0"></path>
<rect height="22" width="140" x="254" y="29"></rect>
<text x="324" y="44">Component value</text>
</g>
<path d="M394 40h10"></path>
<path d="M254 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M254 60h140"></path>
</g>
<path d="M394 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M404 40h20"></path>
</g>
<g>
<path d="M424 40h0"></path>
<path d="M548 40h0"></path>
<path d="M424 40h20"></path>
<g class="non-terminal">
<path d="M444 40h0"></path>
<path d="M528 40h0"></path>
<rect height="22" width="84" x="444" y="29"></rect>
<text x="486" y="44">{} block</text>
</g>
<path d="M528 40h20"></path>
<path d="M424 40a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="terminal">
<path d="M444 70h28"></path>
<path d="M500 70h28"></path>
<rect height="22" rx="10" ry="10" width="28" x="472" y="59"></rect>
<text x="486" y="74">;</text>
</g>
<path d="M528 70a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 548 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-qualified-rule" class="railroad-diagram" height="80" viewBox="0 0 384 80" width="384">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 40h0"></path>
<path d="M240 40h0"></path>
<path d="M40 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M60 20h160"></path>
</g>
<path d="M220 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M40 40h20"></path>
<g>
<path d="M60 40h0"></path>
<path d="M220 40h0"></path>
<path d="M60 40h10"></path>
<g class="non-terminal">
<path d="M70 40h0"></path>
<path d="M210 40h0"></path>
<rect height="22" width="140" x="70" y="29"></rect>
<text x="140" y="44">Component value</text>
</g>
<path d="M210 40h10"></path>
<path d="M70 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M70 60h140"></path>
</g>
<path d="M210 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M220 40h20"></path>
</g>
<path d="M240 40h10"></path>
<g class="non-terminal">
<path d="M250 40h0"></path>
<path d="M334 40h0"></path>
<rect height="22" width="84" x="250" y="29"></rect>
<text x="292" y="44">{} block</text>
</g>
<path d="M334 40h10"></path>
<path d="M 344 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-declaration-list" class="railroad-diagram" height="101" viewBox="0 0 568 101" width="568">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="non-terminal">
<path d="M50 40h0"></path>
<path d="M94 40h0"></path>
<rect height="22" width="44" x="50" y="29"></rect>
<text x="72" y="44">ws*</text>
</g>
<path d="M94 40h10"></path>
<g>
<path d="M104 40h0"></path>
<path d="M528 40h0"></path>
<path d="M104 40h20"></path>
<g>
<path d="M124 40h0"></path>
<path d="M508 40h0"></path>
<g>
<path d="M124 40h0"></path>
<path d="M272 40h0"></path>
<path d="M124 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M144 20h108"></path>
</g>
<path d="M252 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M124 40h20"></path>
<g class="non-terminal">
<path d="M144 40h0"></path>
<path d="M252 40h0"></path>
<rect height="22" width="108" x="144" y="29"></rect>
<text x="198" y="44">Declaration</text>
</g>
<path d="M252 40h20"></path>
</g>
<g>
<path d="M272 40h0"></path>
<path d="M508 40h0"></path>
<path d="M272 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M292 20h196"></path>
</g>
<path d="M488 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M272 40h20"></path>
<g>
<path d="M292 40h0"></path>
<path d="M488 40h0"></path>
<g class="terminal">
<path d="M292 40h0"></path>
<path d="M320 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="292" y="29"></rect>
<text x="306" y="44">;</text>
</g>
<path d="M320 40h10"></path>
<path d="M330 40h10"></path>
<g class="non-terminal">
<path d="M340 40h0"></path>
<path d="M488 40h0"></path>
<rect height="22" width="148" x="340" y="29"></rect>
<text x="414" y="44">Declaration list</text>
</g>
</g>
<path d="M488 40h20"></path>
</g>
</g>
<path d="M508 40h20"></path>
<path d="M104 40a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g>
<path d="M124 70h70"></path>
<path d="M438 70h70"></path>
<g class="non-terminal">
<path d="M194 70h0"></path>
<path d="M270 70h0"></path>
<rect height="22" width="76" x="194" y="59"></rect>
<text x="232" y="74">At-rule</text>
</g>
<path d="M270 70h10"></path>
<path d="M280 70h10"></path>
<g class="non-terminal">
<path d="M290 70h0"></path>
<path d="M438 70h0"></path>
<rect height="22" width="148" x="290" y="59"></rect>
<text x="364" y="74">Declaration list</text>
</g>
</g>
<path d="M508 70a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 528 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-declaration" class="railroad-diagram" height="91" viewBox="0 0 676 91" width="676">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="non-terminal">
<path d="M50 40h0"></path>
<path d="M174 40h0"></path>
<rect height="22" width="124" x="50" y="29"></rect>
<text x="112" y="44">&lt;ident-token&gt;</text>
</g>
<path d="M174 40h10"></path>
<path d="M184 40h10"></path>
<g class="non-terminal">
<path d="M194 40h0"></path>
<path d="M238 40h0"></path>
<rect height="22" width="44" x="194" y="29"></rect>
<text x="216" y="44">ws*</text>
</g>
<path d="M238 40h10"></path>
<path d="M248 40h10"></path>
<g class="terminal">
<path d="M258 40h0"></path>
<path d="M286 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="258" y="29"></rect>
<text x="272" y="44">:</text>
</g>
<path d="M286 40h10"></path>
<g>
<path d="M296 40h0"></path>
<path d="M496 40h0"></path>
<path d="M296 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M316 20h160"></path>
</g>
<path d="M476 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M296 40h20"></path>
<g>
<path d="M316 40h0"></path>
<path d="M476 40h0"></path>
<path d="M316 40h10"></path>
<g class="non-terminal">
<path d="M326 40h0"></path>
<path d="M466 40h0"></path>
<rect height="22" width="140" x="326" y="29"></rect>
<text x="396" y="44">Component value</text>
</g>
<path d="M466 40h10"></path>
<path d="M326 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M326 60h140"></path>
</g>
<path d="M466 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M476 40h20"></path>
</g>
<g>
<path d="M496 40h0"></path>
<path d="M636 40h0"></path>
<path d="M496 40h20"></path>
<g>
<path d="M516 40h100"></path>
</g>
<path d="M616 40h20"></path>
<path d="M496 40a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M516 60h0"></path>
<path d="M616 60h0"></path>
<rect height="22" width="100" x="516" y="49"></rect>
<text x="566" y="64">!important</text>
</g>
<path d="M616 60a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 636 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-important" class="railroad-diagram" height="62" viewBox="0 0 496 62" width="496">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 31h10"></path>
<g class="terminal">
<path d="M50 31h0"></path>
<path d="M78 31h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="20"></rect>
<text x="64" y="35">!</text>
</g>
<path d="M78 31h10"></path>
<path d="M88 31h10"></path>
<g class="non-terminal">
<path d="M98 31h0"></path>
<path d="M142 31h0"></path>
<rect height="22" width="44" x="98" y="20"></rect>
<text x="120" y="35">ws*</text>
</g>
<path d="M142 31h10"></path>
<path d="M152 31h10"></path>
<g class="non-terminal">
<path d="M162 31h0"></path>
<path d="M382 31h0"></path>
<rect height="22" width="220" x="162" y="20"></rect>
<text x="272" y="35">&lt;ident-token "important"&gt;</text>
</g>
<path d="M382 31h10"></path>
<path d="M392 31h10"></path>
<g class="non-terminal">
<path d="M402 31h0"></path>
<path d="M446 31h0"></path>
<rect height="22" width="44" x="402" y="20"></rect>
<text x="424" y="35">ws*</text>
</g>
<path d="M446 31h10"></path>
<path d="M 456 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-component-value" class="railroad-diagram" height="182" viewBox="0 0 260 182" width="260">
<g transform="translate(.5 .5)">
<path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<g>
<path d="M40 31h0"></path>
<path d="M220 31h0"></path>
<path d="M40 31h20"></path>
<g class="non-terminal">
<path d="M60 31h0"></path>
<path d="M200 31h0"></path>
<rect height="22" width="140" x="60" y="20"></rect>
<text x="130" y="35">Preserved token</text>
</g>
<path d="M200 31h20"></path>
<path d="M40 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M60 61h28"></path>
<path d="M172 61h28"></path>
<rect height="22" width="84" x="88" y="50"></rect>
<text x="130" y="65">{} block</text>
</g>
<path d="M200 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path>
<path d="M40 31a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M60 91h28"></path>
<path d="M172 91h28"></path>
<rect height="22" width="84" x="88" y="80"></rect>
<text x="130" y="95">() block</text>
</g>
<path d="M200 91a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path>
<path d="M40 31a10 10 0 0 1 10 10v70a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M60 121h28"></path>
<path d="M172 121h28"></path>
<rect height="22" width="84" x="88" y="110"></rect>
<text x="130" y="125">[] block</text>
</g>
<path d="M200 121a10 10 0 0 0 10 -10v-70a10 10 0 0 1 10 -10"></path>
<path d="M40 31a10 10 0 0 1 10 10v100a10 10 0 0 0 10 10"></path>
<g class="non-terminal">
<path d="M60 151h4"></path>
<path d="M196 151h4"></path>
<rect height="22" width="132" x="64" y="140"></rect>
<text x="130" y="155">Function block</text>
</g>
<path d="M200 151a10 10 0 0 0 10 -10v-100a10 10 0 0 1 10 -10"></path>
</g>
<path d="M 220 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-curly-block" class="railroad-diagram" height="80" viewBox="0 0 376 80" width="376">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="terminal">
<path d="M50 40h0"></path>
<path d="M78 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="29"></rect>
<text x="64" y="44">{</text>
</g>
<path d="M78 40h10"></path>
<g>
<path d="M88 40h0"></path>
<path d="M288 40h0"></path>
<path d="M88 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M108 20h160"></path>
</g>
<path d="M268 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M88 40h20"></path>
<g>
<path d="M108 40h0"></path>
<path d="M268 40h0"></path>
<path d="M108 40h10"></path>
<g class="non-terminal">
<path d="M118 40h0"></path>
<path d="M258 40h0"></path>
<rect height="22" width="140" x="118" y="29"></rect>
<text x="188" y="44">Component value</text>
</g>
<path d="M258 40h10"></path>
<path d="M118 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M118 60h140"></path>
</g>
<path d="M258 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M268 40h20"></path>
</g>
<path d="M288 40h10"></path>
<g class="terminal">
<path d="M298 40h0"></path>
<path d="M326 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="298" y="29"></rect>
<text x="312" y="44">}</text>
</g>
<path d="M326 40h10"></path>
<path d="M 336 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-paren-block" class="railroad-diagram" height="80" viewBox="0 0 376 80" width="376">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="terminal">
<path d="M50 40h0"></path>
<path d="M78 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="29"></rect>
<text x="64" y="44">(</text>
</g>
<path d="M78 40h10"></path>
<g>
<path d="M88 40h0"></path>
<path d="M288 40h0"></path>
<path d="M88 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M108 20h160"></path>
</g>
<path d="M268 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M88 40h20"></path>
<g>
<path d="M108 40h0"></path>
<path d="M268 40h0"></path>
<path d="M108 40h10"></path>
<g class="non-terminal">
<path d="M118 40h0"></path>
<path d="M258 40h0"></path>
<rect height="22" width="140" x="118" y="29"></rect>
<text x="188" y="44">Component value</text>
</g>
<path d="M258 40h10"></path>
<path d="M118 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M118 60h140"></path>
</g>
<path d="M258 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M268 40h20"></path>
</g>
<path d="M288 40h10"></path>
<g class="terminal">
<path d="M298 40h0"></path>
<path d="M326 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="298" y="29"></rect>
<text x="312" y="44">)</text>
</g>
<path d="M326 40h10"></path>
<path d="M 336 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-square-block" class="railroad-diagram" height="80" viewBox="0 0 376 80" width="376">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="terminal">
<path d="M50 40h0"></path>
<path d="M78 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="50" y="29"></rect>
<text x="64" y="44">[</text>
</g>
<path d="M78 40h10"></path>
<g>
<path d="M88 40h0"></path>
<path d="M288 40h0"></path>
<path d="M88 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M108 20h160"></path>
</g>
<path d="M268 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M88 40h20"></path>
<g>
<path d="M108 40h0"></path>
<path d="M268 40h0"></path>
<path d="M108 40h10"></path>
<g class="non-terminal">
<path d="M118 40h0"></path>
<path d="M258 40h0"></path>
<rect height="22" width="140" x="118" y="29"></rect>
<text x="188" y="44">Component value</text>
</g>
<path d="M258 40h10"></path>
<path d="M118 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M118 60h140"></path>
</g>
<path d="M258 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M268 40h20"></path>
</g>
<path d="M288 40h10"></path>
<g class="terminal">
<path d="M298 40h0"></path>
<path d="M326 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="298" y="29"></rect>
<text x="312" y="44">]</text>
</g>
<path d="M326 40h10"></path>
<path d="M 336 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<svg id="_dgm-function-block" class="railroad-diagram" height="80" viewBox="0 0 496 80" width="496">
<g transform="translate(.5 .5)">
<path d="M 20 30 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path>
<path d="M40 40h10"></path>
<g class="non-terminal">
<path d="M50 40h0"></path>
<path d="M198 40h0"></path>
<rect height="22" width="148" x="50" y="29"></rect>
<text x="124" y="44">&lt;function-token&gt;</text>
</g>
<path d="M198 40h10"></path>
<g>
<path d="M208 40h0"></path>
<path d="M408 40h0"></path>
<path d="M208 40a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
<g>
<path d="M228 20h160"></path>
</g>
<path d="M388 20a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<path d="M208 40h20"></path>
<g>
<path d="M228 40h0"></path>
<path d="M388 40h0"></path>
<path d="M228 40h10"></path>
<g class="non-terminal">
<path d="M238 40h0"></path>
<path d="M378 40h0"></path>
<rect height="22" width="140" x="238" y="29"></rect>
<text x="308" y="44">Component value</text>
</g>
<path d="M378 40h10"></path>
<path d="M238 40a10 10 0 0 0 -10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M238 60h140"></path>
</g>
<path d="M378 60a10 10 0 0 0 10 -10v0a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M388 40h20"></path>
</g>
<path d="M408 40h10"></path>
<g class="terminal">
<path d="M418 40h0"></path>
<path d="M446 40h0"></path>
<rect height="22" rx="10" ry="10" width="28" x="418" y="29"></rect>
<text x="432" y="44">)</text>
</g>
<path d="M446 40h10"></path>
<path d="M 456 40 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

</div>

<header>
	<hgroup>
<h1 id="title">CSS の構文 — CSS Syntax Module Level 3</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p class="p-summary">
この~moduleは、~CSS~stylesheetの基本的な構造と構文を一般的な用語により述べるものである。
それは、~CSSの構文と構文解析-法
— ~byte~streamを有意義な~stylesheetに転化する方法 —
を詳細に定義する。
◎
This module describes, in general terms, the basic structure and syntax of CSS stylesheets. It defines, in detail, the syntax and parsing of CSS - how to turn a stream of bytes into a meaningful stylesheet.
</p>

~CSSisaLANG

	</section>
	<section id="status">

~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下，この節の内容は、<a href="css-common-ja.html#status">~CSS日本語訳~共通~page</a>／冒頭の仕様~metadataに移譲。】
</p>

	</section>

<main id="MAIN0">
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この~moduleは、~CSS~stylesheetの［
抽象-構文と構文解析-法
］を定義し，~CSS構文を利用する他のもの（~HTML `style^a 属性など）を定義する。
◎
This module defines the abstract syntax and parsing of CSS stylesheets and other things which use CSS syntax (such as the HTML style attribute).
</p>

<p>
これは、［
~Unicode `符号位置$の~stream（言い換えれば, ~text）
］から，［
~CSS~tokenの~stream
］へ変換するための一連の~algo，および［
その結果の~streamから更に［
~stylesheet, 規則, 宣言
］などからなる，いくつかの~CSS~objへ変換する
］ための一連の~algoを定義する。
◎
It defines algorithms for converting a stream of Unicode code points (in other words, text) into a stream of CSS tokens, and then further into CSS objects such as stylesheets, rules, and declarations.
</p>

		<section id="placement">
<h3 title="Module interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは、~CSS~stylesheetの［
構文と構文解析-法
］を定義する。
それは、~CSS 2.1 にて定義される［
字句走査器と文法
］に取って代わる。
◎
This module defines the syntax and parsing of CSS stylesheets. It supersedes the lexical scanner and grammar defined in CSS 2.1.
</p>
		</section>
	</section>
	<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

<p>
この訳に利用される記号
ε, ~LET, ~IF, ~RET,
等々の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
加えて、次の記法も用いる：
</p>
<dl class="def-list">
	<dt>.%名前</dt>
	<dd>
ドットが接頭された %名前 は，その %名前 がこの仕様の処理~modelにて生産される~objが持つ［
名前が %名前 である~~属性~DAGGER
］であることを明示するときに利用される（文脈から明らかな所では，このドット付き表記は利用されない）。
例えば “〜の.値” は、実際には，［
"`値^em" という名前の~~属性
］の値を意味する。
（~DAGGER
<small >この訳の中の各種~定義にしばしば現れる，この意味の “~~属性” という語は、訳の都合により導入したものであり，原文には無い非公式な用語である。</small>）
</dd>
</dl>

	</section>
	<section id="syntax-description">
<h2 title="Description of CSS’s Syntax">2. ~CSSの構文の記述</h2>

~INFORMATIVE

<p>
~CSS文書は、一連の`~style規則$からなる
— それら各~規則は、次のいずれかを与える
⇒＃
`有修飾~規則$（文書~内の要素に~styleを適用する）／
`~at-rule$1（~CSS文書~用に特別な処理~規則や値を定義する）
◎
A CSS document is a series of style rules—which are qualified rules that apply styles to elements in a document—and at-rules—which define special processing rules or values for the CSS document.
</p>

<p>
`有修飾~規則$は，
.`導入部^dfn
から開始され，宣言~並びを包含している
`波括弧~block$（ `{^c, `}^c で括られた~block）
が後続する。
.導入部の意味は、その規則が出現する文脈に基づいて変わり得る
— ~style規則に対しては、それは［
その宣言が適用されることになる要素たち
］を指定する`選択子$である。
各~宣言は［
名前, ~colon, 宣言~値
］並びで与えられる。
宣言と宣言は，~semicolonで分離される。
◎
A qualified rule starts with a prelude then has a {}-wrapped block containing a sequence of declarations. The meaning of the prelude varies based on the context that the rule appears in—for style rules, it’s a selector which specifies what elements the declarations will apply to. Each declaration has a name, followed by a colon and the declaration value. Declarations are separated by semicolons.
</p>

<div class="example">

<p>
典型的な規則は、次に様な見かけになろう：
◎
A typical rule might look something like this:
</p>

<pre class="lang-css">
p &gt; a {
  color: blue;
  text-decoration: underline;
}
</pre>

<p>
上の規則における
"`p &gt; a^css"
が選択子である。
~source文書が~HTMLであるならば、それは
`p$e 要素の子であるような，あらゆる `a$e 要素を選択する。
◎
In the above rule, "p &gt; a" is the selector, which, if the source document is HTML, selects any a elements that are children of a p element.
</p>

<p>
"`color: blue^css"
は、選択子に合致する要素に対し，それらの `color$p ~propが値 `blue^v になるべきであることを指定している宣言である。
同様に、それらの `text-decoration$p ~propも，値 `underline$v になるべきであることになる。
◎
"color: blue" is a declaration specifying that, for the elements that match the selector, their color property should have the value blue. Similarly, their text-decoration property should have the value underline.
</p>

</div>

<p>
~at-ruleは、種類ごとに異なるものだが，基本的な構造は共通する：
◎
At-rules are all different, but they have a basic structure in common.＼
</p>

<ul>
	<li>
それらは、`符号位置$ "<code>@</code>" で開始され, ~CSS~keywordとして名前が後続する。
◎
They start with an "@" code point followed by their name as a CSS keyword.＼
</li>
	<li>
一部の`~at-rule$は，単純な文tであり、その名前に［
その挙動を指定する 何個かの~CSS値
］が後続し, ~semicolonで終端する。
◎
Some at-rules are simple statements, with their name followed by more CSS values to specify their behavior, and finally ended by a semicolon.＼
</li>
	<li>
他の`~at-rule$は、~blockである：
それらにも，その名前に何個かの~CSS値が後続し得るが、`有修飾~規則$と類似に，`波括弧~block$で終端する。
この~blockの内容は，所与の`~at-rule$に特有なものであるが、それは
`有修飾~規則$の様に 宣言~並びを包含することもあれば，追加的に何個かの［
~block／~at-rule／その他の構造
］を一緒に包含することもある。
◎
Others are blocks; they can have CSS values following their name, but they end with a {}-wrapped block, similar to a qualified rule. Even the contents of these blocks are specific to the given at-rule: sometimes they contain a sequence of declarations, like a qualified rule; other times, they may contain additional blocks, or at-rules, or other structures altogether.
</li>
</ul>

<div class="example">

<p>
ここに、`~at-rule$1が包含し得る種々の構文を解説する いくつかの例を示す：
◎
Here are several examples of at-rules that illustrate the varied syntax they may contain.
</p>

<pre class="lang-css">
@import "my-styles.css";
</pre>

<p>
`import$at `~at-rule$1【！`~at-rule$】は，単純な文tであり、名前の後に［
~importすべき~stylesheetを指示する 1 個の［
文字列, または
関数式 `url$f
］］をとる。
◎
The @import at-rule is a simple statement. After its name, it takes a single string or url() function to indicate the stylesheet that it should import.
</p>

<pre class="lang-css">
@page :left {
  margin-left: 4cm;
  margin-right: 3cm;
}
</pre>

<p>
`page$at `~at-rule$1は、［
~page選択子（省略可能, この例では `:left^css 疑似類）, ［
~pageの印刷~時に適用される，一連の~propからなる~block
］］並びである。
この様に、それは［
それらの~propが，どの “要素” にも適用されず, ~pageそれ自身に適用される
］ことを除いて、通常の~style規則と とてもよく似る。
◎
The @page at-rule consists of an optional page selector (the :left pseudoclass), followed by a block of properties that apply to the page when printed. In this way, it’s very similar to a normal style rule, except that its properties don’t apply to any "element", but rather the page itself.
</p>

<pre class="lang-css">
@media print {
  body { font-size: 10pt }
}
</pre>

<p>
`media$at `~at-rule$1は、［
`媒体~型$,
`媒体~query~list$（省略可能）
］並びから始まる。
その~blockは，［
`media$at 条件が充足されるときに限り適用される
］ような規則~全体を包含する。
◎
The @media at-rule begins with a media type and a list of optional media queries. Its block contains entire rules, which are only applied when the @medias conditions are fulfilled.
</p>

</div>

<p>
［
`~prop$ ／ `~at-rule$
］の名前は、常に`識別子$であり：
◎
Property names and at-rule names are always identifiers,＼
</p>
<ul>
	<li>
次のいずれかから開始する必要がある
⇒＃
`識別子を開始する符号位置$／
2 個の~hyphen ／
［ 1 個の~hyphen, `識別子を開始する符号位置$ ］並び
◎
which have to start with an identifier-start code point, two hyphens, or a hyphen followed by an identifier-start code point,＼
</li>
	<li>
~~後続して 0 個以上の`識別子~符号位置$を包含できる
◎
and then can contain zero or more identifier code points.＼
</li>
	<li>
上述に加えて，どこにでも、`~escape法$により，どの`符号位置$も含めれる
— それが，~CSSの構文に利用されるものであっても。
◎
You can include any code point at all, even ones that CSS uses in its syntax, by escaping it.
</li>
</ul>

<p class="trans-note">【
言い換えれば、次を満たす必要がある：
［
`識別子から開始している$
］~AND［［
`識別子~符号位置$／`妥当な~escape$を成す符号位置~並び
］のみからなる
］
】</p>

<p>
`選択子$の構文は、 `SELECT$r にて定義される。
同様に，多岐に渡る~CSS値の構文は、 `CSS-VALUES$r 仕様にて定義される。
個々の`~at-rule$の特別な構文は、それらを定義する仕様の中に見出せる。
◎
The syntax of selectors is defined in the Selectors spec. Similarly, the syntax of the wide variety of CSS values is defined in the Values &amp; Units spec. The special syntaxes of individual at-rules can be found in the specs that define them.
</p>

		<section id="escaping">
<h3 title="Escaping">2.1. ~escape法</h3>

~INFORMATIVE

<p>
`識別子$や, 引用符で括られた文字列には、
`~escape法@
により，任意の~Unicode`符号位置$を含ませられる。
~CSS~escape列は、~backslash（ `\^l ）で開始され, 次のいずれかが後続する：
◎
Any Unicode code point can be included in an identifier or quoted string by escaping it. CSS escape sequences start with a backslash (\), and continue with:
</p>

<ul>
	<li>
`~hex$でも`改行文字$でもない，任意の［
~Unicode`符号位置$
］。
この~escape列は，その`符号位置$に置換される。
◎
Any Unicode code point that is not a hex digits or a newline. The escape sequence is replaced by that code point.
</li>
	<li>
<p>
［［
1 〜 6 個の`~hex$
］,
`空白$（省略可能）
］並び。
この~escape列は，［
その~hex並びが表す数を値とする~Unicode`符号位置$
］に置換される。
省略可能な空白は、 16 進~escape列の直後に “実の” ~hexを続けられるようにするためにある。
◎
Or one to six hex digits, followed by an optional whitespace. The escape sequence is replaced by the Unicode code point whose value is given by the hexadecimal digits. This optional whitespace allow hexadecimal escape sequences to be followed by "real" hex digits.
</p>

<p class="example">
例えば，.値に `&amp;B^l を伴う`識別子$は、［
`\26 B^css,
あるいは
`\000026B^css
］のように記すこともできる。
◎
An identifier with the value "&amp;B" could be written as \26 B or \000026B.
</p>

<p class="note">注記：
~escape列の直後に “実の” ~spaceを続ける場合、二重に記さなければならないことになる。
◎
A "real" space after the escape sequence must be doubled.
</p>

	</li>
</ul>

		</section>
		<section id="error-handling">
<h3 title="Error Handling">2.2. ~errorの取扱い</h3>

~INFORMATIVE

<p>
~CSSにおいて~errorが生じたときには、構文解析器は，通常通り構文解析に戻る前に［
最小限の内容のみ~~棄てて， “上品に” 回復しよう
］と試みる。
これは、~errorが必ずしも誤用によるものとは限らないからである
— 新たな構文は，古い構文解析器からは~errorに見えるので、［
それを含ませた~stylesheetが，古い~UAにおいて完全に壊れる
］ことを心配せずに［
言語に新たな構文を追加できる
］ことが有用になる。
◎
When errors occur in CSS, the parser attempts to recover gracefully, throwing away only the minimum amount of content before returning to parsing as normal. This is because errors aren’t always mistakes—new syntax looks like an error to an old parser, and it’s useful to be able to add new syntax to the language without worrying about stylesheets that include it being completely broken in older UAs.
</p>

<p>
~error回復の精確な挙動は，構文解析器~それ自身の中で詳細が与えられているが、短い記述でも，それなりに正確aに~~述べれる：
◎
The precise error-recovery behavior is detailed in the parser itself, but it’s simple enough that a short description is fairly accurate.
</p>

<ul>
	<li>
~stylesheetの “~top-level” においては、
`at-keyword$tok が，`~at-rule$を開始させる。
他のものは どれも，`有修飾~規則$を開始させ、その規則の.導入部の中に含められる。
これは，`無効な選択子$も生産し得るが、それは ~CSS構文解析器の関知する所ではなく、最悪でも，何にも合致しない`選択子$になることを意味する。
◎
At the "top level" of a stylesheet, an &lt;at-keyword-token&gt; starts an at-rule. Anything else starts a qualified rule, and is included in the rule’s prelude. This may produce an invalid selector, but that’s not the concern of the CSS parser—at worst, it means the selector will match nothing.
</li>
	<li>
<p>
`~at-rule$が開始されたなら、構文解析器の視点からは，何が来ようが無効ではなく、次のいずれかに遭遇するまでのすべてが，~at-ruleの.導入部の一部になる：
◎
Once an at-rule starts, nothing is invalid from the parser’s standpoint; it’s all part of the at-rule’s prelude.
</p>
		<ul>
			<li>
`semicolon$tok に遭遇したときは，その~at-ruleは即時に終端される。
◎
Encountering a &lt;semicolon-token&gt; ends the at-rule immediately, while＼
</li>
			<li>
一方で，開き波括弧 `open-curly$Tok に遭遇したときは、その~at-ruleの本体を開始させる
— 本体に合致する~block（ `()^c, `{}^c, `[]^c のいずれかに挟まれた内容）が、［［
他のものや別の~blockの内側
］には合致しない閉じ波括弧 `close-curly$Tok
］が見出されるまで，前方検索される。
◎
encountering an opening curly-brace &lt;{-token&gt; starts the at-rule’s body. The at-rule seeks forward, matching blocks (content surrounded by (), {}, or []) until it finds a closing curly-brace &lt;}-token&gt; that isn’t matched by anything else or inside of another block.
</li>
		</ul>
<p>
しかる後、その~at-ruleの内容が，~at-rule~自身の文法に則って解釈される。
◎
The contents of the at-rule are then interpreted according to the at-rule’s own grammar.
</p>
	</li>
	<li>
`有修飾~規則$の場合も，［
~semicolonは，それを終端させない
］ことを除いて，同様に働く
— その~semicolonは，単に規則の.導入部の一部に取り込まれる。
最初の`波括弧~block$が見出されたなら、その内容は常に，宣言~listとして解釈される。
◎
Qualified rules work similarly, except that semicolons don’t end them; instead, they are just taken in as part of the rule’s prelude. When the first {} block is found, the contents are always interpreted as a list of declarations.
</li>
	<li>
宣言~listを解釈する際に，未知な構文に出くわしたときは、現在~構築中の宣言は，それが何であれ，構文解析器により~~棄てられ、次の~semicolon（あるいは~blockの終端）が見出されるまで，前方検索される。
しかる後、宣言の構文解析-がまた，新規に試行される。
◎
When interpreting a list of declarations, unknown syntax at any point causes the parser to throw away whatever declaration it’s currently building, and seek forward until it finds a semicolon (or the end of the block). It then starts fresh, trying to parse a declaration again.
</li>
	<li>
どの［
規則, 宣言, 関数式, 文字列, 等々
］においても，それがまだ閉じられていないにもかかわらず，~stylesheetが終端した場合、あらゆるものが自動的に閉じられる。
これは、それらを無効にはしない。
不完全にもなり得るが、その場合は，それらの文法に照らし合わせて検証yされる際に~~棄てられる。
◎
If the stylesheet ends while any rule, declaration, function, string, etc. are still open, everything is automatically closed. This doesn’t make them invalid, though they may be incomplete and thus thrown away when they are verified against their grammar.
</li>
</ul>

<p>
各~構成子（宣言, ~style規則, ~at-rule）が構文解析されたなら、~UAは，期待される文法に照らし合わせて検査する。
文法に合致しない場合，それは
`無効@
になり、~UAは，元からそれが無かったかのように
`無視-@
することになる。
◎
After each construct (declaration, style rule, at-rule) is parsed, the user agent checks it against its expected grammar. If it does not match the grammar, it’s invalid, and gets ignored
by the UA, which treats it as if it wasn’t there at all.
</p>

		</section>
	</section>
	<section id="tokenizing-and-parsing">
<h2 title="Tokenizing and Parsing CSS">3. ~CSSの~token化法と構文解析-法</h2>

<p>
~UAが，【~MIME型】 `text/css^c の資源から~CSSOM~tree `CSSOM$r を生成するときは、この仕様に述べられる構文解析~規則を利用するモノトスル。
同時に，これらの規則は、~CSS構文解析器と~~呼ばれるものを定義する。
◎
User agents must use the parsing rules described in this specification to generate the [CSSOM] trees from text/css resources. Together, these rules define what is referred to as the CSS parser.
</p>

<p>
この仕様は、~CSS文書が構文上は正しいかどうかを調べるための，構文解析~規則を定義する。
構文解析~algoの内側にて、
`構文解析error@
と記される箇所がある。
その際の~errorの取扱いは、きちんと定義される：
~UA は，その種の問題に遭遇したときには、以下に述べる規則に従って動作するか, または［
それらの規則を適用したいと望まない~errorに最初に遭遇した時点で，処理を中止する
］モノトスル。
◎
This specification defines the parsing rules for CSS documents, whether they are syntactically correct or not. Certain points in the parsing algorithm are said to be parse errors. The error handling for parse errors is well-defined: user agents must either act as described below when encountering such problems, or must abort processing at the first error that they encounter for which they do not wish to apply the rules described below.
</p>

<p>
適合性~検査器は、文書において 1 個以上の構文解析error【！error conditions】が生じたときには，それら~errorのうち 1 個以上を利用者に報告するモノトスル。
また、それら~errorが複数個あるときは，それらのうち複数個を報告してもヨイ。
逆に、文書に~errorが存在しない場合は，~errorを報告しないモノトスル。
適合性~検査器には，構文解析errorから回復することは要求されないが、それを行う場合は，~UAと同じ仕方で回復するモノトスル。
◎
Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document. Conformance checkers are not required to recover from parse errors, but if they do, they must recover in the same way as user agents.
</p>

		<section id="parsing-overview">
<h3 title="Overview of the Parsing Model">3.1. 構文解析~modelの概観</h3>

<p>
~CSS構文解析への入力は、［
~Unicode`符号位置$の~stream
］である。
それは、［
~token化~段階
］を経て［
~treeの構築~段階
］に渡される。
その出力は［
`CSSStyleSheet$I ~obj
］である。
◎
The input to the CSS parsing process consists of a stream of Unicode code points, which is passed through a tokenization stage followed by a tree construction stage. The output is a CSSStyleSheet object.
</p>

<p class="note">注記：
~scriptingを~supportしない実装は、実際に~CSSOM `CSSStyleSheet^c ~objを作成しなくともよいが、そのような場合でも依然として、~CSSOM~treeは，この仕様の残りの部分のための~modelとして利用される。
◎
Note: Implementations that do not support scripting do not have to actually create a CSSOM CSSStyleSheet object, but the CSSOM tree in such cases is still used as the model for the rest of the specification.
</p>

		</section>
		<section id="input-byte-stream">
<h3 title="The input byte stream">3.2. 入力~byte~stream</h3>

<p>
［
~stylesheetの構文解析における~token化~段階
］への入力を成す［
~Unicode`符号位置$の~stream
］は、~UAにとっては，初期~時は（概して，~network越しに, または局所~file~systemからの）~byte~streamとして見えるであろう。
その場合，~UAは、特定0の文字~符号化法に則って，その~byte列を`符号位置$列に復号しなければならないことになる。
◎
When parsing a stylesheet, the stream of Unicode code points that comprises the input to the tokenization stage might be initially seen by the user agent as a stream of bytes (typically coming over the network or from the local file system). If so, the user agent must decode these bytes into code points according to a particular character encoding.
</p>

<div class="algo">
<p>
`~stylesheetの~byte列を復号する@
ときは、所与の %~stylesheet に対し，その~byte~streamを次に従って`符号位置$~streamの中へ復号する：
◎
To decode a stylesheet’s stream of bytes into a stream of code points:
</p>

<ol>
	<li>
%~fallback ~LET `~fallback符号化法を決定する$( %~stylesheet )
◎
Determine the fallback encoding of stylesheet, and let fallback be the result.
</li>
	<li>
~RET `~Unicodeに復号する$( %~stylesheet の~byte~stream, %~fallback )
◎
Decode stylesheet’s stream of bytes with fallback encoding fallback, and return the result.
</li>
</ol>

<p class="note">注記：
`~Unicodeに復号する$ ~algoは、~BOM（ `byte order mark^en ／ バイト順マーク ）を優先する
— ~fallbackを利用するのは、~BOMが見出されなかったときに限られる。
◎
Note: The decode algorithm gives precedence to a byte order mark (BOM), and only uses the fallback when none is found.
</p>

</div>

<div class="algo">
<p>
`~fallback符号化法を決定する@
ときは、所与の %~stylesheet に対し：
◎
To determine the fallback encoding of a stylesheet:
</p>

<ol>
	<li>
<p>
~IF［
~HTTPまたは それに等価な~protocol
］は、
%~stylesheet 用の`符号化法~label$として %~label を供している（例：
`Content-Type$h ~headerの `charset^c ~parameterを介して）
］：
</p>
		<ol>
			<li>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label )
</li>
			<li>
~IF［
%符号化法 ~NEQ `失敗^i
］
⇒
~RET %符号化法
</li>
		</ol>
◎
If HTTP or equivalent protocol provides an encoding label (e.g. via the charset parameter of the Content-Type header) for the stylesheet, get an encoding from encoding label. If that does not return failure, return it.
</li>
	<li>
<p>
~IF［
%~stylesheet を成す~byte~stream
］の［
先頭から【~stream終端を超えない】 1024 個までの~byteが成す~byte列
］の頭部は、次の~hex列に合致する
］：
◎
Otherwise, check stylesheet’s byte stream. If the first 1024 bytes of the stream begin with the hex sequence
</p>

<pre>40 63 68 61 72 73 65 74 20 22 %~label 22 3B</pre>

<p>
ここで %~label は、各~byteが 16 進 範囲 { 0x00 〜 0x21, 0x23 〜 0x7F } に入る任意の~byte列とする。
◎
where each XX byte is a value between 016 and 2116 inclusive or a value between 2316 and 7F16 inclusive, then＼
</p>

<p class="note">注記：
この~byte列は、~ASCIIとして復号したときには，次の連結になる
⇒＃
`@charset "^l,
%~label が表現する文字列,
`";^l
◎
↓</p>
		<ol>
			<li>
<p>
%符号化法 ~LET `~labelから符号化法を取得する$( %~label を~ASCIIとして解釈して得られる文字列 )
◎
get an encoding from a string formed out of the sequence of XX bytes, interpreted as ASCII.
◎
What does that byte sequence mean?
◎
The byte sequence above, when decoded as ASCII, is the string "@charset "…";", where the "…" is the sequence of bytes corresponding to the encoding’s label.
</p>
			</li>
			<li>
<div class="p">
<p>
~IF［
%符号化法 ~NEQ `失敗^i
］：
</p>
				<ol>
					<li>
~IF［
%符号化法 ~IN { `UTF-16BE$enc, `UTF-16LE$enc }
］
⇒
~RET `UTF-8$enc
</li>
					<li>
~RET %符号化法
</li>
				</ol>
◎
If the return value was utf-16be or utf-16le, return utf-8; if it was anything else except failure, return it.
</div>

<details class="note">
<summary>
宣言が~UTF-16のときに `UTF-8$enc を利用するのはなぜ？
◎
Why use utf-8 when the declaration says utf-16?
</summary>
<p>
符号化法~宣言の~byte列は~ASCIIとしては
“<code>@charset "…";</code>”
になるが、
~UTF-16は~ASCII互換でない。
好ましい行いでないが，文書~内で正しい~byte列になるように暗号的なもの（
`䁣桡牳整•utf-16be∻^c
など）を与えたとき、あるいは
文書が実際には~ASCII互換の符号化法でありつつ，符号化法~宣言が虚偽である場合でも、~UTF-8を既定にしておくことが，あるべき挙動になる。
◎
The bytes of the encoding declaration spell out “@charset "…";” in ASCII, but UTF-16 is not ASCII-compatible. Either you’ve typed in complete gibberish (like 䁣桡牳整•utf-16be∻) to get the right bytes in the document, which we don’t want to encourage, or your document is actually in an ASCII-compatible encoding and your encoding declaration is lying.
◎
Either way, defaulting to UTF-8 is a decent answer.
</p>

<p>
これは、~HTMLの `meta charset^e の挙動を真似たものでもある。
◎
As well, this mimics the behavior of HTML’s &lt;meta charset&gt; attribute.
</p>
</details>

<p class="note">注記：
符号化法~宣言の構文は、名前 `charset$at の`~at-rule$1の構文に`似ているように見えるが^em、そのような規則は実際には存在しない
— その書き方の規則は、そのような規則を認識する通常のあり方より，ずっと制約的である。
~CSS内で［［
~space並び, ~comment, 一重引用符
］などを利用して，妥当な `charset$at 規則を生産させつつ、その符号化法~宣言は認識できなくする
］ような、いくつものやり方がある。
この挙動は、符号化法~宣言をアリな限り単純にして，正しく実装し易くするためにある。
◎
Note: Note that the syntax of an encoding declaration looks like the syntax of an at-rule named @charset, but no such rule actually exists, and the rules for how you can write it are much more restrictive than they would normally be for recognizing such a rule. A number of things you can do in CSS that would produce a valid @charset rule (if one existed), such as using multiple spaces, comments, or single quotes, will cause the encoding declaration to not be recognized. This behavior keeps the encoding declaration as simple as possible, and thus maximizes the likelihood of it being implemented correctly.
</p>

			</li>
		</ol>
	</li>
	<li>
~IF［
参照元 文書にて`環境~符号化法$が供されている
］
⇒
~RET それ
◎
Otherwise, if an environment encoding is provided by the referring document, return it.
</li>
	<li>
~RET `UTF-8$enc
◎
Otherwise, return utf-8.
</li>
</ol>

<div class="note">

<p>注記：
~web用の符号化法は，~UTF-8が既定であり、~web用途の新たな~file形式の多くは，~UTF-8符号化法と見做す, あるいは要求しているが、~CSSは，どの符号化法が主流になるか はっきりする前の段階で策定されたので、~stylesheetを自動的に~UTF-8と見做すわけにはいかない。
◎
Though UTF-8 is the default encoding for the web, and many newer web-based file formats assume or require UTF-8 encoding, CSS was created before it was clear which encoding would win, and thus can’t automatically assume the stylesheet is UTF-8.
</p>

<p>
~stylesheet作者は、［
~stylesheetを~UTF-8にした上で、
~HTTP~header（または等価な手法）により，~stylesheetの符号化法を~UTF-8であるものと宣言する
］か, または［
参照元 文書の符号化法を~UTF-8として宣言する
］`ベキ^emである。
（~HTMLにおいて これを行うには、文書の頭部（ `head^e 内）に `meta charset=utf-8^e 要素を与える。）
◎
Stylesheet authors should author their stylesheets in UTF-8, and ensure that either an HTTP header (or equivalent method) declares the encoding of the stylesheet to be UTF-8, or that the referring document declares its encoding to be UTF-8. (In HTML, this is done by adding a &lt;meta charset=utf-8&gt; element to the head of the document.)
</p>

<p>
これらのいずれも可用でない場合、作者は，~stylesheetの先頭に~UTF-8~BOMを与えるか，あるいは正確に次に一致する文字列を与えるべきである：
◎
If neither of these options are available, authors should begin the stylesheet with a UTF-8 BOM or the exact characters
</p>

<pre>@charset "utf-8";</pre>

</div>
</div>

<p>
［
~byte列から復号される~CSS~stylesheet
］を参照rする文書~言語は、それらの各~stylesheetに対し，
`環境~符号化法@
を定義してもヨイ。
それは、他の符号化法~hintは［
入手できない／可用でない
］ときの，~fallbackとして利用される。
◎
Document languages that refer to CSS stylesheets that are decoded from bytes may define an environment encoding for each such stylesheet, which is used as a fallback when other encoding hints are not available or can not be used.
</p>

<p>
`環境~符号化法$の概念があるのは、旧来の内容との互換性を得るために限られる。
［
新たな形式の文書／新たな~link法の仕組み
］は、［
~stylesheetの符号化法が明示的に供されない下では，既定で~UTF-8になる
］よう，`環境~符号化法$を供する<strong>べきでない</strong>。
◎
The concept of environment encoding only exists for compatibility with legacy content. New formats and new linking mechanisms should not provide an environment encoding, so the stylesheet defaults to UTF-8 instead in the absence of more explicit information.
</p>

<div class="note">
<p>
注記：
◎
↓</p>

<ul>
	<li>
`HTML$r は、
`link rel=stylesheet^e から参照rされる~stylesheet用の`環境~符号化法$を
<a href="~HTMLlinks#link-type-stylesheet">定義している</a>。
◎
Note: [HTML] defines the environment encoding for &lt;link rel=stylesheet&gt;.
</li>
	<li>
`CSSOM$r は、
`&lt;xml-stylesheet?&gt;^c 用の`環境~符号化法$を
<a href="~CSSOM1#requirements-on-user-agents-implementing-the-xml-stylesheet-processing-instruction">定義している</a>。
◎
Note: [CSSOM] defines the environment encoding for &lt;xml-stylesheet?&gt;.
</li>
	<li>
`CSS-CASCADE-3$r は、
`import$at 用の`環境~符号化法$を
<a href="~CASCADE#import-processing">定義している</a>。
◎
Note: [CSS-CASCADE-3] defines the environment encoding for @import.
</li>
</ul>
</div>

		</section>
		<section id="input-preprocessing">
<h3 title="Preprocessing the input stream">3.3. 入力~streamの前処理</h3>

<p>
`入力~stream@
は、入力~byte~streamを復号するに伴い~pushされた，一連の
<a href="#css-filter-code-points">~filter済み符号位置</a>
からなる。
◎
The input stream consists of the filtered code points pushed into it as the input byte stream is decoded.
</p>

<div class="algo">
<p>
`符号位置~列を~filterする@
ときは、所与の（~filter済みでない）`符号位置$列が成す~stream %入力 に対し，
%入力 を成す各`符号位置$に応じて：
◎
To filter code points from a stream of (unfiltered) code points input:
</p>

<ul class="switch">
	<li>
次に該当するものは、除去する
⇒
`0D^U (CR) のうち，直後に `0A^U (LF) があるもの
◎
↓</li>
		<li>
次に挙げるものは、 `0A^U (LF) に置換する
⇒＃
前項に該当しない `0D^U (CR) ／
`0C^U (FF)
◎
Replace any U+000D CARRIAGE RETURN (CR) code points, U+000C FORM FEED (FF) code points, or pairs of U+000D CARRIAGE RETURN (CR) followed by U+000A LINE FEED (LF) in input by a single U+000A LINE FEED (LF) code point.
</li>
		<li>
次に挙げるものは、 `FFFD^U (LF) に置換する
⇒＃
`00^U／
`~surrogate$
◎
Replace any U+0000 NULL or surrogate code points in input with U+FFFD REPLACEMENT CHARACTER (�).
</li>
</ul>
</div>

		</section>
	</section>
	<section id="tokenization">
<h2 title="Tokenization">4. ~token化</h2>

<div>
<p>
`符号位置$~stream %入力 を~CSS~token~stream %出力 の中へ
`~token化する@
ときは：
</p>

<ol>
	<li>
~WHILE 無条件
		<ol>
			<li>
%~token ~LET %入力 から`~tokenを消費$した結果
</li>
			<li>
~IF［
%~token は `EOF$tok である
］
⇒
~BREAK
</li>
			<li>
%出力 の中へ %~token を~pushする
</li>
		</ol>
	</li>
</ol>

◎
To tokenize a stream of code points into a stream of CSS tokens input, repeatedly consume a token from input until an &lt;EOF-token&gt; is reached, pushing each of the returned tokens into a stream.
</div>

<p class="note">注記：
`~tokenを消費$する~algoは、`構文解析の間^emに［
必要に応じて “その場で”， `符号位置$が成す~streamの~token化に利用できる
］ようにするため，各~呼び出しに対し 1 個の~tokenを返す。
◎
Note: Each call to the consume a token algorithm returns a single token, so it can also be used "on-demand" to tokenize a stream of code points during parsing, if so desired.
</p>

<div class="p">
<p>
~token化の段における出力は、次に挙げる 0 個~以上の~tokenからなる並びが成す~streamである：
</p>

<p class="trans-note">【
各~tokenには，それが持ち得る~~属性の名前も挙げる。
また、その~tokenが表す~CSSの代表的な構成子も併記する（これは、訳者による補足であり，該当する構成子を網羅するものでもない）。
】</p>

<table>

<thead><tr><th>~token
<th>~~属性
<th>代表的な構成子（括弧内はその例）
</thead>

<tbody><tr><td>`ident@tok
<td>値
<td>~keywordなどを表す `~CSS識別子$（ `auto^l ）

<tr><td>`function@tok
<td>値
<td>`関数-記法$の名前~部分（ `calc(^l ）

<tr><td>`at-keyword@tok
<td>値
<td>~at-rule（ "<code>@import</code>" ）

<tr><td>`hash@tok
<td>値, 型~flag
<td>`~ID選択子$（ `#ID^l ）／ 16 進数による色（ `#ABCDEF^l ）

<tr><td>`string@tok
<td>値
<td>文字列（ `'もじのならび'^l, 引用符~付き）

<tr><td>`bad-string@tok
<td>
<td>合法でない文字列

<tr><td>`url@tok
<td>値
<td>~URL（ `url(example.png)^l ）

<tr><td>`bad-url@tok
<td>
<td>合法でない~URL

<tr><td>`delim@tok
<td>値
<td>1 個の文字からなる一般的な分離子（`結合子$, `~importantな宣言$の `!^l など）

<tr><td>`number@tok
<td>数値, 型~flag
<td>単位の無い数値（ `123.45^l ）

<tr><td>`percentage@tok
<td>数値,
<td>百分率（ `33.3%^l ）

<tr><td>`dimension@tok
<td>数値, 型~flag, 単位
<td>単位~付きの数値（ `1.5em^l ）

<tr><td>`whitespace@tok
<td>
<td>空白

<tr><td>`CDO@tok
<td>
<td>`&lt;!--^l — 埋め込み~stylesheetの中の~HTML~commentの~~開始

<tr><td>`CDC@tok
<td>
<td>`--&gt;^l — 同上, ~HTML~commentの~~終了

<tr><td>`colon@tok
<td>
<td>`:^l — `宣言$の中の~propの名前と値を分離する~colon

<tr><td>`semicolon@tok
<td>
<td>`;^l — `宣言$の並びを分離する~semicolon

<tr><td>`comma@tok
<td>
<td>`,^l — 成分~値の並びを分離する~comma

<tr><td>`open-square@Tok
<td>
<td>`[^l — `属性~選択子$を括る角括弧

<tr><td>`close-square@Tok
<td>
<td>`]^l — 同上

<tr><td>`open-paren@Tok
<td>
<td>`(^l — `条件付き~group規則$に与える条件を括る丸括弧

<tr><td>`close-paren@Tok
<td>
<td>`)^l — 同上

<tr><td>`open-curly@Tok
<td>
<td>`{^l — 宣言~listを括る波括弧

<tr><td>`close-curly@Tok
<td>
<td>`}^l — 同上

</tbody></table>

◎
The output of tokenization step is a stream of zero or more of the following tokens: &lt;ident-token&gt;, &lt;function-token&gt;, &lt;at-keyword-token&gt;, &lt;hash-token&gt;, &lt;string-token&gt;, &lt;bad-string-token&gt;, &lt;url-token&gt;, &lt;bad-url-token&gt;, &lt;delim-token&gt;, &lt;number-token&gt;, &lt;percentage-token&gt;, &lt;dimension-token&gt;, &lt;whitespace-token&gt;, &lt;CDO-token&gt;, &lt;CDC-token&gt;, &lt;colon-token&gt;, &lt;semicolon-token&gt;, &lt;comma-token&gt;, &lt;[-token&gt;, &lt;]-token&gt;, &lt;(-token&gt;, &lt;)-token&gt;, &lt;{-token&gt;, and &lt;}-token&gt;.
</div>

<p>
各種~~属性がとり得る値は：
◎
↓</p>

<ul>
	<li>
［
`ident$tok ／
`function$tok ／
`at-keyword$tok ／
`hash$tok ／
`string$tok ／
`url$tok
］の
.`値^dfn
は、 0 個以上の`符号位置$からなる。
◎
&lt;ident-token&gt;, &lt;function-token&gt;, &lt;at-keyword-token&gt;, &lt;hash-token&gt;, &lt;string-token&gt;, and &lt;url-token&gt; have a value composed of zero or more code points.＼
</li>
	<li>
`hash$tok の
.`型~flag^dfn
は、［
`無制約^i （既定）, `id^i
］のいずれかである。
◎
Additionally, hash tokens have a type flag set to either "id" or "unrestricted". The type flag defaults to "unrestricted" if not otherwise set.
</li>
	<li>
`delim$tok の
.`値^dfn
は、 1 個の`符号位置$からなる。
◎
&lt;delim-token&gt; has a value composed of a single code point.
</li>
	<li>
［
`number$tok ／
`percentage$tok ／
`dimension$tok
］の
.`数値^dfn
は、実数を与える。
◎
&lt;number-token&gt;, &lt;percentage-token&gt;, and &lt;dimension-token&gt; have a numeric value.＼
</li>
	<li>
［
`number$tok ／
`dimension$tok
］の
.`型~flag^dfn
は、［
`整数^i （既定）, `実数^i
］のいずれかである。
◎
&lt;number-token&gt; and &lt;dimension-token&gt; additionally have a type flag set to either "integer" or "number". The type flag defaults to "integer" if not otherwise set.＼
</li>
	<li>
`dimension$tok の
.`単位^dfn
は、 1 個以上の`符号位置$からなる。
◎
&lt;dimension-token&gt; additionally have a unit composed of one or more code points.
</li>
</ul>

<p class="note">注記：
`hash$tok の.型~flagは，~Selectors構文 `SELECT$r にて利用される。
［ 型~flag: `id^i ］を伴う `hash$tok のみが，妥当な `~ID選択子$になる。
◎
Note: The type flag of hash tokens is used in the Selectors syntax [SELECT]. Only hash tokens with the "id" type are valid ID selectors.
</p>

		<section id="token-diagrams">
<h3 title="Token Railroad Diagrams">4.1. ~tokenの線路図式</h3>

~INFORMATIVE

<p>
この節では、~tokenizerの参考~viewを線路図式の形で呈示する。
線路図式は，明示的な構文解析器より簡潔でありつつ,
大抵は正規表現よりも読み取り易い。
◎
This section presents an informative view of the tokenizer, in the form of railroad diagrams. Railroad diagrams are more compact than an explicit parser, but often easier to read than an regular expression.
</p>

<p>
これらの図式は、`参考であって, 不完全^emである。
~tokenの “正しい” 文法は述べるが、~errorの取扱いについては全く述べない。
それらはもっぱら，各種~tokenの構文を直感的に把握し易くするために供されている。
◎
These diagrams are informative and incomplete; they describe the grammar of "correct" tokens, but do not describe error-handling at all. They are provided solely to make it easier to get an intuitive grasp of the syntax of each token.
</p>

<p>
`foo^tok
の様な名前が付与されている図式は、~tokenを表現する。
他のものは，他の図式から参照rされる生成規則である。
◎
Diagrams with names such as &lt;foo-token&gt; represent tokens. The rest are productions referred to by other diagrams.
</p>

<dl>
	<dt id="comment-diagram">`comment^sb（~comment）</dt>
	<dd class="railroad">`comment^dgm</dd>

	<dt id="newline-diagram">`newline^sb（`前処理$前の改行文字）</dt>
	<dd class="railroad">`newline^dgm</dd>

	<dt id="whitespace-diagram">`whitespace^sb（`空白$）</dt>
	<dd class="railroad">`whitespace^dgm</dd>

	<dt id="hex-digit-diagram">`hex digit^sb（ `~hex$ ）</dt>
	<dd class="railroad">`hex-digit^dgm</dd>

	<dt id="escape-diagram">`escape^sb（~escape列）</dt>
	<dd class="railroad">`escape^dgm</dd>

	<dt id="whitespace-token-diagram">`whitespace$tok</dt>
	<dd class="railroad">`whitespace-token^dgm</dd>

	<dt id="whitespaces-diagram">`ws*^sb</dt>
	<dd class="railroad">`whitespaces^dgm</dd>

	<dt id="ident-token-diagram">`ident$tok</dt>
	<dd class="railroad">`ident-token^dgm</dd>

	<dt id="function-token-diagram">`function$tok</dt>
	<dd class="railroad">`function-token^dgm</dd>

	<dt id="at-keyword-token-diagram">`at-keyword$tok</dt>
	<dd class="railroad">`at-keyword-token^dgm</dd>

	<dt id="hash-token-diagram">`hash$tok</dt>
	<dd class="railroad">`hash-token^dgm</dd>

	<dt id="string-token-diagram">`string$tok</dt>
	<dd class="railroad">`string-token^dgm</dd>

	<dt id="url-token-diagram">`url$tok</dt>
	<dd class="railroad">`url-token^dgm</dd>

	<dt id="number-token-diagram">`number$tok</dt>
	<dd class="railroad">`number-token^dgm</dd>

	<dt id="dimension-token-diagram">`dimension$tok</dt>
	<dd class="railroad">`dimension-token^dgm</dd>

	<dt id="percentage-token-diagram">`percentage$tok</dt>
	<dd class="railroad">`percentage-token^dgm</dd>

	<dt id="CDO-token-diagram">`CDO$tok</dt>
	<dd class="railroad">`CDO-token^dgm</dd>

	<dt id="CDC-token-diagram">`CDC$tok</dt>
	<dd class="railroad">`CDC-token^dgm</dd>

</dl>

		</section>
		<section id="tokenizer-definitions">
<h3 title="Definitions">4.2. 定義</h3>

<p>
この節では、~token化~相にて利用される，いくつかの用語を定義する。
◎
This section defines several terms used during the tokenization phase.
</p>

<dl>
	<dt>
`次入力~符号位置@
◎
next input code point
</dt>
	<dd>
`入力~stream$内の，未だ消費されていない`符号位置$のうちの，最初のもの。
◎
The first code point in the input stream that has not yet been consumed.
</dd>
	<dd class="trans-note">【
“次の %n 個の入力~符号位置” と記されることもある（ %n ≤ 3 ）。
参照rされる範囲が~streamの末尾を越えている部分の符号位置は，`~EOF符号位置$と見なされる。
】</dd>

	<dt>
`現入力~符号位置@
◎
current input code point
</dt>
	<dd>
すでに消費された`符号位置$のうち，最後のもの。
◎
The last code point to have been consumed.
</dd>

	<dt>
`現入力~符号位置を消費し直す@
◎
reconsume the current input code point
</dt>
	<dd>
`現入力~符号位置$を`入力~stream$の先頭に戻す
【未~消費な~~状態に戻す】
。
すなわち，次回に`次入力~符号位置$を消費する際には、`現入力~符号位置$を再び消費することになる。
◎
Push the current input code point back onto the front of the input stream, so that the next time you are instructed to consume the next input code point, it will instead reconsume the current input code point.
</dd>

	<dt>
`~EOF符号位置@
【この訳では、単に “~EOF” と略記する。】
◎
EOF code point
</dt>
	<dd>
`入力~stream$の終端を表現する，
【他のどの符号位置とも異なる】
概念的な符号位置。
`入力~stream$が空になり次第，`次入力~符号位置$は常に，~EOFになる。
◎
A conceptual code point representing the end of the input stream. Whenever the input stream is empty, the next input code point is always an EOF code point.
</dd>

	<dt>（各種 符号位置の範囲）</dt>
	<dd>
<p>
次の表の 1 列目に挙げる各~用語は、同じ行の 2 列目に示される，一定~範囲に属する`符号位置$を表す：
</p>

<table>
<caption>
記号 ∪ は和集合をとることを意味する
</caption>

<thead><tr><th>用語
<th>符号位置の範囲
</thead>

<tbody>

<tr><td>
`数字@
◎
digit
<td>
{ `30^U 〜 `39^U }
◎
A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9) inclusive.

<tr><td>
`~hex@
◎
hex digit
<td>
`数字$ ∪ { `41^U 〜 `46^U } ∪ { `61^U 〜 `66^U }
◎
A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F) inclusive, or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f) inclusive.

<tr><td>
`正負符号@ ~DAGGER
<td>
{ `2B^U, `2D^U }

<tr><td>
`指数~指示子@ ~DAGGER
<td>
{ `45^U, `65^U }

<tr><td>
`大文字@
◎
uppercase letter
<td>
{ `41^U 〜 `5A^U }
◎
A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z) inclusive.

<tr><td>
`小文字@
◎
lowercase letter
<td>
{ `61^U 〜 `7A^U }
◎
A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z) inclusive.

<tr><td>
`英字@
◎
letter
<td>
`大文字$ ∪ `小文字$
◎
An uppercase letter or a lowercase letter.

<tr><td>
`非~ASCII符号位置@
◎
non-ASCII code point
<td>
{ `80^U 〜 `10FFFF^U }
◎
A code point with a value equal to or greater than U+0080 &lt;control&gt;.

<tr><td>
`識別子を開始する符号位置@
◎
identifier-start code point
<td>
`英字$ ∪ `非~ASCII符号位置$ ∪ { `5F^U }
◎
A letter, a non-ASCII code point, or U+005F LOW LINE (_).

<tr><td>
`識別子~符号位置@
◎
identifier code point
<td>
`識別子を開始する符号位置$ ∪ `数字$ ∪ { `2D^U }
◎
An identifier-start code point, a digit, or U+002D HYPHEN-MINUS (-).

<tr><td>
`印字不能~符号位置@
◎
non-printable code point
<td>
{ `00^U 〜 `08^U } ∪ { `0B^U } ∪ { `0E^U 〜 `1F^U } ∪ { `7F^U }
◎
A code point between U+0000 NULL and U+0008 BACKSPACE inclusive, or U+000B LINE TABULATION, or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE inclusive, or U+007F DELETE.

<tr><td>
`改行文字@
◎
newline
<td>
{ `0A^U }
<span class="note">
`0D^U および `0C^U は，この定義には含められない。
それらは`前処理$の段階で `0A^U に変換されるので。
</span>
◎
U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition, as they are converted to U+000A LINE FEED during preprocessing.

<tr><td>
`空白@
◎
whitespace
<td>
`改行文字$ ∪ { `09^U, `20^U }
◎
A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.

</tbody></table>

<p class="trans-note">【~DAGGER
`正負符号$, `指数~指示子$は、この訳による追加的な定義。
】</p>

	</dd>

	<dt>
`許容される最大な符号位置@
◎
maximum allowed code point
</dt>
	<dd>
~Unicodeにて定義されている最~大な`符号位置$： `10FFFF^U 。
◎
The greatest code point defined by Unicode: U+10FFFF.
</dd>

	<dt>
`識別子@
◎
identifier
</dt>
	<dd>
`ident$tok と構文が同じな`符号位置$並び。
◎
A sequence of code points that has the same syntax as an &lt;ident-token&gt;.
</dd>
	<dd class="note">注記：
次に挙げるものは、どれも`識別子$になる
⇒＃
`at-keyword$tok の "<code>@</code>" より後の部分,
`hash$tok のうち［ .型~flag ~EQ `id^i ］なるものの `#^l より後の部分,
`function$tok の `(^l より前の部分,
`dimension$tok の.単位
◎
Note: The part of an &lt;at-keyword-token&gt; after the "@", the part of a &lt;hash-token&gt; (with the "id" type flag) after the "#", the part of a &lt;function-token&gt; before the "(", and the unit of a &lt;dimension-token&gt; are all identifiers.
</dd>

	<dt>
`表現@
◎
representation
</dt>
	<dd>
~tokenの`表現$は、［
それを生産した，`~tokenを消費$する~algo
］により消費された，`入力~stream$の部分列である。
これは、［
~tokenの単純な “再~直列化” により妨げられ得るような，入力~textの微妙な詳細
］に依拠する，少数の~algo用に保全される。
◎
The representation of a token is the subsequence of the input stream consumed by the invocation of the consume a token algorithm that produced it. This is preserved for a few algorithms that rely on subtle details of the input text, which a simple "re-serialization" of the tokens might disturb.
</dd>
	<dd>
`表現$は、内部~algoのみに消費され，直に公開されることは決してないので、実際に正確な~textを保全することは要求されない
— 各~tokenを~source~textの中の~offsetに結付けるなどの，等価な手法でも足りる。
◎
The representation is only consumed by internal algorithms, and never directly exposed, so it’s not actually required to preserve the exact text; equivalent methods, such as associating each token with offsets into the source text, also suffice.
</dd>
	<dd class="note">
<p>注記：
特に，`表現$は、例えば次のような詳細を保全する：
</p>

<ul><li>`.009^v は［
`.009^c ／ `9e-3^c
］のどちらで記されたか
— これは，  `urange$t 生成規則を適正に構文解析するために必要とされる。
</li><li>ある文字は［
~literalに, あるいは ~CSS~escapeとして
］のどちらで記されたか
— これは基本的に，~token化法の抽象-化に~~本質的でない漏洩になるが、実装を定義し易くなるので許容される。
</li></ul>
◎
Note: In particular, the representation preserves details such as whether .009 was written as .009 or 9e-3, and whether a character was written literally or as a CSS escape. The former is necessary to properly parse &lt;urange&gt; productions; the latter is basically an accidental leak of the tokenizing abstraction, but allowed because it makes the impl easier to define.
</dd>
	<dd>
ある~tokenが，［
この仕様における~token化~algoを通さずに，ある~algoにより直に生産されたもの
］である場合、その表現は空~文字列になる。
◎
If a token is ever produced by an algorithm directly, rather than thru the tokenization algorithm in this specification, its representation is the empty string.
</dd>

	<dt>“〜の符号位置を消費する” 【この項は、この訳による補完】</dt>
	<dd>
~streamの先頭から，“〜” に記された部分の符号位置を取り去った上で、取り去られた最後の符号位置を，現入力~符号位置にあてがうことを意味する（言い換えれば、現入力~符号位置を指している~pointerを， “〜” に記された部分の最後の符号位置を指すよう移動する）。
“消費” が現れる所では、常にそのような副作用が伴われる。
“〜の符号位置を消費した結果” と記されたときは，消費された（取り去られた）符号位置~並びによる文字列を表す。
</dd>

	<dt>“~streamから`次入力~符号位置を繰返し消費する@：” 【この項は、この訳による補完】</dt>
	<dd>
<p>
次を繰返し走らすことを意味する：
</p>
		<ol>
			<li>
`次入力~符号位置$を消費する
</li>
			<li>
`現入力~符号位置$に応じて、［
後続の~blockに記された，対応する段
］を走らす
</li>
		</ol>
<p>
繰返nは、値を返した時点（ ~RET ）で終了する。
</p>
	</dd>

</dl>

		</section>
		<section id="tokenizer-algorithms">
<h3 title="Tokenizer Algorithms">4.3. ~tokenizer~algo</h3>

<p>
この節に定義する一連の~algoは、［
`符号位置$の~stream
］を［
~tokenの~stream
］へ形式変換する。
◎
The algorithms defined in this section transform a stream of code points into a stream of tokens.
</p>

<div class="trans-note">
<p>
この節における表記
⇒
“新たな `foo^tok ( %名前: %値 , … )”
</p>

<p>
は、新たに作成される~token `foo^tok の~instanceであって，その各種~~属性が括弧内に記された様に初期化されたものを表す（ “値” という名前の~~属性もあることに注意）。
定数~token（ ~~属性を持たない~token ）の~instanceは，単に `foo^tok の様に記される。
</p>
</div>

			<section id="consume-token">
<h4 title="Consume a token">4.3.1. ~tokenを消費する</h4>

<p>
この節では、`符号位置$の~streamから
`~tokenを消費@
する方法を述べる。
それは、いずれかの型の 1 個の~tokenを返す：
◎
This section describes how to consume a token from a stream of code points. It will return a single token of any type.
</p>

<ol>
	<li>
`~comment列を消費$する
◎
Consume comments.
</li>
	<li>
<p>
~streamから`次入力~符号位置を繰返し消費する$：
◎
Consume the next input code point.
</p>

<dl class="switch">
	<dt>`空白$</dt>
	<dd>
<ol ><li>アリな限り多くの`空白$を消費する
</li><li>~RET `whitespace$tok
</li></ol>
◎
Consume as much whitespace as possible. Return a &lt;whitespace-token&gt;.
</dd>

	<dt>`22^U</dt>
	<dd>
<ol ><li>~RET `文字列~tokenを消費$した結果
</li></ol>
◎
Consume a string token and return it.
</dd>

	<dt>`23^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`次入力~符号位置$ ~IN `識別子~符号位置$
］~OR［
`次の 2 個の入力~符号位置$は，`妥当な~escape$を成す
］：
◎
If the next input code point is an identifier code point or the next two input code points are a valid escape, then:
</p>

				<ol>
					<li>
%型 ~LET ［
次が満たされるならば `id^i ／
~ELSE_ `無制約^i
］
⇒
`次の 3 個の入力~符号位置$は`識別子から開始している$
◎
Create a &lt;hash-token&gt;
◎
If the next 3 input code points would start an identifier, set the &lt;hash-token&gt;’s type flag to "id".
</li>
					<li>
%値 ~LET `識別子を消費$した結果
◎
Consume an identifier, and set the &lt;hash-token&gt;’s value to the returned string.
</li>
					<li>
~RET 新たな `hash$tok ( 値: %値 , 型~flag: %型 )
◎
Return the &lt;hash-token&gt;.
</li>
				</ol>
			</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`27^U</dt>
	<dd>
<ol ><li>~RET `文字列~tokenを消費$した結果
</li></ol>
◎
Consume a string token and return it.
</dd>

	<dt>`28^U</dt>
	<dd>
<ol ><li>~RET `open-paren$Tok
</li></ol>
◎
Return a &lt;(-token&gt;.
</dd>

	<dt>`29^U</dt>
	<dd>
<ol ><li>~RET `close-paren$Tok
</li></ol>
◎
Return a &lt;)-token&gt;.
</dd>

	<dt>`2B^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
入力~streamは `実数から開始している$
］：
</p>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `数量-~tokenを消費$した結果
</li></ol>
◎
If the input stream starts with a number, reconsume the current input code point, consume a numeric token and return it.
</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`2C^U</dt>
	<dd>
<ol ><li>~RET `comma$tok
</li></ol>
◎
Return a &lt;comma-token&gt;.
</dd>

	<dt>`2D^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
入力~streamは `実数から開始している$
］：
</p>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `数量-~tokenを消費$した結果
</li></ol>
◎
If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
</li>
			<li>
<p>
~IF［
`次の 2 個の入力~符号位置$は［
`2D^U, `3E^U
］並びである
］：
</p>
<ol ><li>それらを消費する
</li><li>~RET `CDC$tok
</li></ol>
◎
Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (-&gt;), consume them and return a &lt;CDC-token&gt;.
</li>
			<li>
<p>
~IF［
入力~streamは `識別子から開始している$
］：
</p>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `識別子に類する~tokenを消費$した結果
</li></ol>
◎
Otherwise, if the input stream starts with an identifier, reconsume the current input code point, consume an ident-like token, and return it.
</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`2E^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
入力~streamは `実数から開始している$
］：
</p>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `数量-~tokenを消費$した結果
</li></ol>
◎
If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`3A^U</dt>
	<dd>
<ol ><li>~RET `colon$tok
</li></ol>
◎
Return a &lt;colon-token&gt;.
</dd>

	<dt>`3B^U</dt>
	<dd>
<ol ><li>~RET `semicolon$tok
</li></ol>
◎
Return a &lt;semicolon-token&gt;.
</dd>

	<dt>`3C^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`次の 3 個の入力~符号位置$は［
`21^U, `2D^U, `2D^U
］並びである
］：
</p>
<ol ><li>それらを消費する
</li><li>~RET `CDO$tok
</li></ol>
◎
If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), consume them and return a &lt;CDO-token&gt;.
</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`40^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`次の 3 個の入力~符号位置$は，`識別子から開始している$
］：
◎
If the next 3 input code points would start an identifier,＼
</p>
				<ol>
					<li>
%名前 ~LET `識別子を消費$した結果
◎
consume an identifier,＼
</li>
					<li>
~RET 新たな `at-keyword$tok ( 値: %名前 )
◎
create an &lt;at-keyword-token&gt; with its value set to the returned value, and return it.
</li>
				</ol>
			</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Otherwise, return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`5B^U</dt>
	<dd>
<ol ><li>~RET `open-square$Tok
</li></ol>
◎
Return a &lt;[-token&gt;.
</dd>

	<dt>`5C^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
入力~streamは `妥当な~escapeから開始している$
］：
</p>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `識別子に類する~tokenを消費$した結果
</li></ol>
◎
If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.
</li>
			<li>
`構文解析error$
◎
Otherwise, this is a parse error.＼
</li>
			<li>
~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
◎
Return a &lt;delim-token&gt; with its value set to the current input code point.
</li>
		</ol>
	</dd>

	<dt>`5D^U</dt>
	<dd>
<ol ><li>~RET `close-square$Tok
</li></ol>
◎
Return a &lt;]-token&gt;.
</dd>

	<dt>`7B^U</dt>
	<dd>
<ol ><li>~RET `open-curly$Tok
</li></ol>
◎
Return a &lt;{-token&gt;.
</dd>

	<dt>`7D^U</dt>
	<dd>
<ol ><li>~RET `close-curly$Tok
</li></ol>
◎
Return a &lt;}-token&gt;.
</dd>

	<dt>`数字$</dt>
	<dd>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `数量-~tokenを消費$した結果
</li></ol>
◎
Reconsume the current input code point, consume a numeric token, and return it.
</dd>

	<dt>`識別子を開始する符号位置$</dt>
	<dd>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET `識別子に類する~tokenを消費$した結果
</li></ol>
◎
Reconsume the current input code point, consume an ident-like token, and return it.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol ><li>~RET `EOF$tok
</li></ol>
◎
Return an &lt;EOF-token&gt;.
</dd>

	<dt>他全部</dt>
	<dd>
<ol ><li>~RET 新たな `delim$tok ( 値: `現入力~符号位置$ )
</li></ol>
◎
Return a &lt;delim-token&gt; with its value set to the current input code point.
</dd>
</dl>

	</li>
</ol>

			</section>
			<section id="consume-comments">
<h4 title="Consume comments">4.3.2. ~comment列を消費する</h4>

<p>
この節では、`符号位置$の~streamから
`~comment列を消費@
する方法を述べる。
それは ε を返す：
◎
This section describes how to consume comments from a stream of code points. It returns nothing.
</p>

<ol>
	<li>
<p>
~WHILE［
`次の 2 個の入力~符号位置$は［
`2F^U, `2A^U
］並びである
］：
</p>
<ol><li>その 2 個を消費する
</li><li>最初の［
［ `2A^U, `2F^U ］並び, または~EOF
］までのすべての`符号位置$を消費する
</li></ol>

◎
If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*), consume them and all following code points up to and including the first U+002A ASTERISK (*) followed by a U+002F SOLIDUS (/), or up to an EOF code point. Return to the start of this step.
</li>
	<li>
~IF［
前段の繰返nは~EOFを消費して終えた
］
⇒
`構文解析error$
◎
If the preceding paragraph ended by consuming an EOF code point, this is a parse error.
</li>
	<li>
~RET ε
◎
Return nothing.
</li>
</ol>

			</section>
			<section id="consume-numeric-token">
<h4 title="Consume a numeric token">4.3.3. 数量-~tokenを消費する</h4>

<p>
この節では、`符号位置$の~streamから
`数量-~tokenを消費@
する方法を述べる。
それは［
`number$tok ／
`percentage$tok ／
`dimension$tok
］を返す：
◎
This section describes how to consume a numeric token from a stream of code points. It returns either a &lt;number-token&gt;, &lt;percentage-token&gt;, or &lt;dimension-token&gt;.
</p>

<ol >
	<li>
( 数値: %num , 型~flag: %型 ) ~LET `実数を消費$した結果
◎
Consume a number and let number be the result.
</li>
	<li>
<p>
~IF［
`次の 3 個の入力~符号位置$は，`識別子から開始している$
］：
</p>
		<ol>
			<li>
%単位 ~LET `識別子を消費$した結果
</li>
			<li>
~RET 新たな `dimension$tok (
数値: %num ,
型~flag: %型 ,
単位: %単位
)
</li>
		</ol>
◎
If the next 3 input code points would start an identifier, then:
• Create a &lt;dimension-token&gt; with the same value and type flag as number, and a unit set initially to the empty string.
• Consume an identifier. Set the &lt;dimension-token&gt;’s unit to the returned value.
• Return the &lt;dimension-token&gt;.
</li>
	<li>
<p>
~IF［
`次入力~符号位置$ ~EQ `25^U
］：
</p>
<ol ><li>それを消費する
</li><li>~RET 新たな `percentage$tok ( 数値: %num【！, 型~flag: %型】 )
</li></ol>
◎
Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it. Create a &lt;percentage-token&gt; with the same value and type flag as number, and return it.
</li>
	<li>
~RET 新たな `number$tok (
	型~flag: %型 ,
	数値: %num
)
◎
Otherwise, create a &lt;number-token&gt; with the same value and type flag as number, and return it.
</li>
</ol>

			</section>
			<section id="consume-ident-like-token">
<h4 title="Consume an ident-like token">4.3.4.  識別子に類する~tokenを消費する</h4>

<p>
この節では、`符号位置$の~streamから
`識別子に類する~tokenを消費@
する方法を述べる。
それは［
`ident$tok ／
`function$tok ／
`url$tok ／
`bad-url$tok
］を返す：
◎
This section describes how to consume an ident-like token from a stream of code points. It returns an &lt;ident-token&gt;, &lt;function-token&gt;, &lt;url-token&gt;, or &lt;bad-url-token&gt;.
</p>

<ol >
	<li>
%文字列 ~LET `識別子を消費$した結果
◎
Consume an identifier, and let string be the result.
</li>
	<li>
<p>
~IF［
%文字列 ~EQ`大小無視$sub `url^l
］~AND［
`次入力~符号位置$ ~EQ `28^U
］：
◎
If string’s value is an ASCII case-insensitive match for "url", and the next input code point is U+0028 LEFT PARENTHESIS ((),＼
</p>
		<ol >
			<li>
それを消費する
◎
consume it.＼
</li>
			<li>
~WHILE ［
`次の 2 個の入力~符号位置$は，いずれも`空白$である
］
⇒
`次入力~符号位置$を消費する
◎
While the next two input code points are whitespace, consume the next input code point.＼
</li>
			<li>
<p>
~IF［
`次の 2 個の入力~符号位置$ %c1, %c2 は、次のいずれかを満たす
］…：
</p>

<ul ><li>%c1 ~IN { `22^U, `27^U } （ %c2 は任意）
</li><li>［
%c1 は`空白$である
］~AND［
%c2 ~IN { `22^U, `27^U }
］
</li></ul>

<p>
…ならば：
</p>

<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET 新たな `function$tok ( 値: %文字列 )
</li></ol>

<p class="trans-note">【
引数が引用符で括られた `url("…")^c のような文字列は、
`function$tok と引数の並びと見なされる。
】</p>

◎
If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('), or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('), then create a &lt;function-token&gt; with its value set to string and return it.＼
</li>
			<li>
~RET `~url~tokenを消費$した結果
◎
Otherwise, consume a url token, and return it.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
`次入力~符号位置$ ~EQ `28^U
］：
</p>
<ol ><li>それを消費する
</li><li>~RET 新たな `function$tok ( 値: %文字列 )
</li></ol>
◎
Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it. Create a &lt;function-token&gt; with its value set to string and return it.
</li>
	<li>
~RET 新たな `ident$tok ( 値: %文字列 )
◎
Otherwise, create an &lt;ident-token&gt; with its value set to string and return it.
</li>
</ol>

			</section>
			<section id="consume-string-token">
<h4 title="Consume a string token">4.3.5. 文字列~tokenを消費する</h4>

<p>
この節では、`符号位置$の~streamから
`文字列~tokenを消費@
する方法を述べる。
それは［
`string$tok ／
`bad-string$tok
］を返す：
◎
This section describes how to consume a string token from a stream of code points. It returns either a &lt;string-token&gt; or &lt;bad-string-token&gt;.
</p>

<p>
この~algoは［
文字列を終端させる`符号位置$を表す %終端ng符号位置
］も伴って呼ばれることもある。
%終端ng符号位置 が指定されずに呼ばれた場合、`現入力~符号位置$がそれに利用される。
【終端ng符号位置までは消費されつつ，結果の文字列には終端ng符号位置は含まれない。】
◎
This algorithm may be called with an ending code point, which denotes the code point that ends the string. If an ending code point is not specified, the current input code point is used.
</p>

<ol >
	<li>
%文字列 ~LET 空~文字列
◎
Initially create a &lt;string-token&gt; with its value set to the empty string.
</li>
	<li>
<p>
~streamから`次入力~符号位置を繰返し消費する$：
◎
Repeatedly consume the next input code point from the stream:
</p>

		<dl class="switch">
			<dt>%終端ng符号位置</dt>
			<dd>
<ol ><li>~RET 新たな `string$tok ( 値: %文字列 )
</li></ol>
◎
Return the &lt;string-token&gt;.
</dd>

			<dt>~EOF</dt>
			<dd>
<ol ><li>`構文解析error$
</li><li>~RET 新たな `string$tok ( 値: %文字列 )
</li></ol>
◎
This is a parse error. Return the &lt;string-token&gt;.
</dd>

			<dt>`改行文字$</dt>
			<dd>
<ol ><li>`構文解析error$
</li><li>`現入力~符号位置を消費し直す$
</li><li>~RET `bad-string$tok
</li></ol>
◎
This is a parse error. Reconsume the current input code point, create a &lt;bad-string-token&gt;, and return it.
</dd>

			<dt>`5C^U</dt>
			<dd>
<p>
`次入力~符号位置$に応じて：
</p>
				<dl class="switch">
					<dt>~EOF</dt>
					<dd>
何もしない
</dd>

					<dt>`改行文字$</dt>
					<dd>
それを消費する
</dd>

					<dt>その他</dt>
					<dd class="note">（すなわち，~streamは `妥当な~escapeから開始している$）</dd>
					<dd>
`~escapeされた符号位置を消費$して、その結果を %文字列 に付加する
</dd>
				</dl>
◎
If the next input code point is EOF, do nothing.
◎
Otherwise, if the next input code point is a newline, consume it.
◎
Otherwise, (the stream starts with a valid escape) consume an escaped code point and append the returned code point to the &lt;string-token&gt;’s value.
</dd>

			<dt>他全部</dt>
			<dd>
<ol><li>%文字列 に`現入力~符号位置$を付加する
</li></ol>
◎
Append the current input code point to the &lt;string-token&gt;’s value.
</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-url-token">
<h4 title="Consume a url token">4.3.6. ~url~tokenを消費する</h4>

<p>
この節では、`符号位置$の~streamから
`~url~tokenを消費@
する方法を述べる。
それは［
`url$tok ／
`bad-url$tok
］を返す：
◎
This section describes how to consume a url token from a stream of code points. It returns either a &lt;url-token&gt; or a &lt;bad-url-token&gt;.
</p>

<p class="note">注記：
この~algoは、直前に `url(^l が消費-済みであると見做す。
また、 `url(foo)^v の様な “引用符で括られてない” 値を消費するために呼ばれているものと見做す。
`url("foo")^v の様に引用符で括られた値は、 `function-token$t として構文解析される。
`識別子に類する~tokenを消費$する~algoは、この~~区別を自動的に取扱う
— この~algoは、他からは直に呼ばれるベキでない。
◎
Note: This algorithm assumes that the initial "url(" has already been consumed. This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo). A quoted value, like url("foo"), is parsed as a &lt;function-token&gt;. Consume an ident-like token automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
</p>

<ol>
	<li>
%~URL ~LET 空~文字列
◎
Initially create a &lt;url-token&gt; with its value set to the empty string.
</li>
	<li>
アリな限り多くの`空白$を消費する
◎
Consume as much whitespace as possible.
</li>
	<li>
<p>
~streamから`次入力~符号位置を繰返し消費する$：
◎
Repeatedly consume the next input code point from the stream:
</p>
		<dl class="switch">
			<dt>`29^U</dt>
			<dd>
<ol ><li>~RET 新たな `url$tok ( 値: %~URL )
</li></ol>
◎
Return the &lt;url-token&gt;.
</dd>
			<dt>~EOF</dt>
			<dd>
<ol ><li>`構文解析error$
</li><li>~RET 新たな `url$tok ( 値: %~URL )
</li></ol>
◎
This is a parse error. Return the &lt;url-token&gt;.
</dd>

			<dt>`空白$</dt>
			<dd>
				<ol>
					<li>
アリな限り多くの`空白$を消費する
◎
Consume as much whitespace as possible.＼
</li>
					<li>
<p>
`次入力~符号位置$に応じて：
</p>

						<dl class="switch">
							<dt>~EOF</dt>
							<dd>
<ol ><li>それを消費する
</li><li>`構文解析error$
</li><li>~RET 新たな `url$tok ( 値: %~URL )
</li></ol>
							</dd>

							<dt>`29^U</dt>
							<dd>
<ol ><li>それを消費する
</li><li>~RET 新たな `url$tok ( 値: %~URL )
</li></ol>
							</dd>

							<dt>その他</dt>
							<dd>
<ol ><li>`不良~urlの残余を消費$する
</li><li>~RET `bad-url$tok
</li></ol>
							</dd>
						</dl>
◎
If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF, consume it and return the &lt;url-token&gt; (if EOF was encountered, this is a parse error); otherwise, consume the remnants of a bad url, create a &lt;bad-url-token&gt;, and return it.
</li>
				</ol>
			</dd>

			<dt>`22^U</dt>
			<dt>`27^U</dt>
			<dt>`28^U</dt>
			<dt>`印字不能~符号位置$</dt>
			<dd>
<ol ><li>`構文解析error$
</li><li>`不良~urlの残余を消費$する
</li><li>~RET `bad-url$tok
</li></ol>
◎
This is a parse error. Consume the remnants of a bad url, create a &lt;bad-url-token&gt;, and return it.
</dd>

			<dt>`5C^U</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
~streamは `妥当な~escapeから開始している$
］：
◎
If the stream starts with a valid escape,＼
</p>
						<ol>
							<li>
%~escape ~LET `~escapeされた符号位置を消費$した結果
◎
consume an escaped code point and＼
</li>
							<li>
%~URL に %~escape を付加する
◎
append the returned code point to the &lt;url-token&gt;’s value.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
</p>
<ol ><li>`構文解析error$
</li><li>`不良~urlの残余を消費$する
</li><li>~RET `bad-url$tok
</li></ol>
◎
Otherwise, this is a parse error. Consume the remnants of a bad url, create a &lt;bad-url-token&gt;, and return it.
</li>
				</ol>
			</dd>
			<dt>他全部</dt>
			<dd>
<ol ><li>%~URL に`現入力~符号位置$を付加する
</li></ol>
◎
Append the current input code point to the &lt;url-token&gt;’s value.
</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-escaped-code-point">
<h4 title="Consume an escaped code point">4.3.7. ~escapeされた符号位置を消費する</h4>

<p>
この節では、
`~escapeされた符号位置を消費@
する方法を述べる。
これは、［
直前に `5C^U が消費~済みである
］かつ［
次入力~符号位置が`妥当な~escape$の一部を成している
］ことが検証y-済みであると見做す。
これは、 1 個の`符号位置$を返す：
◎
This section describes how to consume an escaped code point. It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and that the next input code point has already been verified to be part of a valid escape. It will return a code point.
</p>

<ol>
	<li>
`次入力~符号位置$を消費する
◎
Consume the next input code point.
</li>
	<li>
<p>
`現入力~符号位置$に応じて：
◎
↓</p>
		<dl class="switch">
			<dt>`~hex$</dt>
			<dd>
				<ol>
					<li>
%~hex列 ~LET `現入力~符号位置$
◎
↓</li>
					<li>
%~hex列 に［
5 個まで アリな限り多くの`~hex$を消費した結果
］を付加する
◎
Consume as many hex digits as possible, but no more than 5. Note that this means 1-6 hex digits have been consumed in total.＼
</li>
					<li>
~IF［
`次入力~符号位置$ ~IN `空白$
］
⇒
それも消費する
◎
If the next input code point is whitespace, consume it as well.＼
</li>
					<li>
%数値 ~SET %~hex列 を16 進数として解釈した結果
◎
Interpret the hex digits as a hexadecimal number.＼
</li>
					<li>
~IF［
%数値 ~EQ 0
］~OR［
%数値 ~IN `~surrogate$
］~OR［
%数値 ~GT `許容される最大な符号位置$
］
⇒
~RET `FFFD^U
◎
If this number is zero, or is for a surrogate, or is greater than the maximum allowed code point, return U+FFFD REPLACEMENT CHARACTER (&#xFFFD;).＼
</li>
					<li>
~RET %数値 を値とする `符号位置$
◎
Otherwise, return the code point with that value.
</li>
				</ol>
			</dd>

			<dt>~EOF</dt>
			<dd>
				<ol>
					<li>
`構文解析error$
</li>
					<li>
~RET `FFFD^U
</li>
				</ol>
◎
This is a parse error. Return U+FFFD REPLACEMENT CHARACTER (�).
</dd>

			<dt>他全部</dt>
			<dd>
~RET `現入力~符号位置$
◎
Return the current input code point.
</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="starts-with-a-valid-escape">
<h4 title="Check if two code points are a valid escape">4.3.8. ［ 2 個の符号位置 ］並びが，妥当な~escapeを成すかどうかの検査</h4>

<p>
この節では、 2 個の符号位置からなる並び［
%c0, %c1
］が
`妥当な~escape@
を成すかどうか検査する方法を述べる。
この~algoの入力には、入力~streamそのものが渡されることもある
— その場合、［
%c0 ~SET `現入力~符号位置$,
%c1 ~SET `次入力~符号位置$
］とする。
◎
This section describes how to check if two code points are a valid escape. The algorithm described here can be called explicitly with two code points, or can be called with the input stream itself. In the latter case, the two code points in question are the current input code point and the next input code point, in that order.
</p>

<p class="note">注記：
この~algoは`符号位置$を消費しない。
◎
Note: This algorithm will not consume any additional code point.
</p>

<ol>
	<li>
~RET［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%c0 ~EQ `5C^U
］~AND［
%c1 は`改行文字$でない
］
◎
If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
◎
Otherwise, if the second code point is a newline, return false.
◎
Otherwise, return true.
</li>
</ol>

			</section>
			<section id="would-start-an-identifier">
<h4 title="Check if three code points would start an identifier">4.3.9. ［ 3 個の符号位置 ］並びが，識別子を開始しているかどうかの検査</h4>

<p>
この節では、 3 個の符号位置~並び［
%c0, %c1, %c2
］が
`識別子から開始している@
かどうか検査する方法を述べる。
この~algoの入力には、入力~streamそのものが渡されることもある
— その場合、［
%c0, %c1, %c2
］ ~SET ［
`現入力~符号位置$,
`次の 2 個の入力~符号位置$
］とする。
◎
This section describes how to check if three code points would start an identifier. The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself. In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.
</p>

<p class="note">注記：
この~algoは`符号位置$を消費しない。
◎
Note: This algorithm will not consume any additional code points.
</p>

<ol>
	<li>
<p>
~RET［［
%c0, %c1, %c2
］が次の表のいずれかの行に示される条件を満たすならば ~T ／
~ELSE_ ~F
］：
</p>

<table>
	<thead><tr><th>%c0
<th>%c1
<th>%c2
</thead>
	<tbody>
<tr><td>`2D^U
<td>`識別子を開始する符号位置$
<td>(任意)

<tr><td>`2D^U
<td>`2D^U
<td>(任意)

<tr><td>`2D^U
<td colspan="2">`妥当な~escape$を成す

<tr><td>`識別子を開始する符号位置$
<td>(任意)
<td>(任意)

<tr><td colspan="2">`妥当な~escape$を成す
<td>(任意)

	</tbody>
</table>

		<div lang="en">

<p>
Look at the first code point:
</p>

<dl>
	<dt>U+002D HYPHEN-MINUS</dt>
	<dd>
If the second code point is an identifier-start code point or a U+002D HYPHEN-MINUS, or the second and third code points are a valid escape, return true. Otherwise, return false.
</dd>
	<dt>identifier-start code point</dt>
	<dd>Return true.</dd>

	<dt>U+005C REVERSE SOLIDUS (\)</dt>
	<dd>If the first and second code points are a valid escape, return true. Otherwise, return false.</dd>

	<dt>anything else</dt>
	<dd>Return false.</dd>

</dl>

		</div>
	</li>
</ol>

			</section>
			<section id="starts-with-a-number">
<h4 title="Check if three code points would start a number">4.3.10. ［ 3 個の符号位置 ］並びが，実数を開始しているかどうかの検査</h4>

<p>
この節では、 3 個の符号位置~並び［
%c0, %c1, %c2
］が
`実数から開始している@
かどうか検査する方法を述べる。
この~algoの入力には、入力~streamそのものが渡されることもある
— その場合、［
%c0, %c1, %c2
］ ~SET ［
`現入力~符号位置$,
`次の 2 個の入力~符号位置$
］とする。
◎
This section describes how to check if three code points would start a number. The algorithm described here can be called explicitly with three code points, or can be called with the input stream itself. In the latter case, the three code points in question are the current input code point and the next two input code points, in that order.
</p>

<p class="note">注記：
この~algoは`符号位置$を消費しない。
◎
Note: This algorithm will not consume any additional code points.
</p>

<ol >
	<li>
<p>
~RET［［
%c0, %c1, %c2
］が次の表のいずれかの行に示される条件を満たすならば ~T ／
~ELSE_ ~F
］：
</p>

<table>
<thead><tr><th>%c0
<th>%c1
<th>%c2
</thead>
	<tbody>
<tr><td>`正負符号$
<td>`数字$
<td>(任意)

<tr><td>`正負符号$
<td>`2E^U
<td>`数字$

<tr><td>`2E^U
<td>`数字$
<td>(任意)

<tr><td>`数字$
<td>(任意)
<td>(任意)

</tbody></table>

		<div lang="en">

<p>
Look at the first code point:
</p>
<dl>
	<dt>U+002B PLUS SIGN (+)</dt>
	<dt>U+002D HYPHEN-MINUS (-)</dt>
	<dd>
<p>
If the second code point is a digit, return true.
</p>
<p>
Otherwise, if the second code point is a U+002E FULL STOP (.) and the third code point is a digit, return true.
</p>
<p>
Otherwise, return false.
</p>
	</dd>

	<dt>U+002E FULL STOP (.)</dt>
	<dd>If the second code point is a digit, return true. Otherwise, return false.</dd>

	<dt>digit</dt>
	<dd>Return true.</dd>

	<dt>anything else</dt>
	<dd>Return false.</dd>
</dl>

		</div>

	</li>
</ol>

			</section>
			<section id="consume-name">
<h4 title="Consume an identifier">4.3.11. 識別子を消費する</h4>

<p>
この節では、`符号位置$の~streamから
`識別子を消費@
する方法を述べる。
それは、~stream内の，次の`符号位置$から始まる最長な名前を成す文字列を返す。
◎
This section describes how to consume an identifier from a stream of code points. It returns a string containing the largest name that can be formed from adjacent code points in the stream, starting from the first.
</p>

<p class="note">注記：
この~algoは、［
返される`符号位置$が `ident$tok の一部を成すこと
］を確保するために必要な，［
最初の少数の`符号位置$の検証y
］は行わない。
意図的にそのように利用するときは、［
~streamは`識別子から開始している$こと
］を事前に確保すること。
◎
Note: This algorithm does not do the verification of the first few code points that are necessary to ensure the returned code points would constitute an &lt;ident-token&gt;. If that is the intended use, ensure that the stream starts with an identifier before calling this algorithm.
</p>

<ol>
	<li>
%結果 ~LET 空~文字列
◎
Let result initially be an empty string.
</li>
	<li>
<p>
~streamから`次入力~符号位置を繰返し消費する$：
◎
Repeatedly consume the next input code point from the stream:
</p>

		<dl class="switch">
			<dt>`識別子~符号位置$</dt>
			<dd>
<ol ><li>%結果 にその`符号位置$を付加する
</li></ol>
◎
Append the code point to result.
</dd>

			<dt>
~streamは`妥当な~escapeから開始している$
◎
the stream starts with a valid escape
</dt>
			<dd>
<ol ><li>`~escapeされた符号位置を消費$して、その結果を %結果 に付加する
</li></ol>
◎
Consume an escaped code point. Append the returned code point to result.
</dd>

			<dt>他全部</dt>
			<dd>
<ol ><li>`現入力~符号位置を消費し直す$
</li><li>~RET %結果
</li></ol>
◎
Reconsume the current input code point. Return result.
</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-number">
<h4 title="Consume a number">4.3.12. 実数を消費する</h4>

<p>
この節では、`符号位置$の~streamから
`実数を消費@
する方法を述べる。
それは、
( %数値, %型~flag )
が成す組を返す
— %型~flag は［
`整数^i, `実数^i
］のいずれかをとり得る。
◎
This section describes how to consume a number from a stream of code points. It returns a numeric value, and a type which is either "integer" or "number".
</p>

<p class="note">注記：
この~algoは、［
~streamから実数が得せること
］を確保するために必要な，［
最初の少数の`符号位置$の検証y
］を行わない。
呼ぶ際には，［
~streamは`実数から開始している$こと
］を事前に確保すること。
◎
Note: This algorithm does not do the verification of the first few code points that are necessary to ensure a number can be obtained from the stream. Ensure that the stream starts with a number before calling this algorithm.
</p>

<ol>
	<li>
%型 ~LET `整数^i
◎
Execute the following steps in order:
</li>
	<li>
%表現 ~LET 空~文字列
◎
Initially set type to "integer". Let repr be the empty string.
</li>
	<li>
~IF［
`次入力~符号位置$ ~IN `正負符号$
］
⇒
それを消費して、その結果を %表現 に付加する
◎
If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), consume it and append it to repr.
</li>
	<li>
~WHILE［ `次入力~符号位置$ ~IN `数字$
］
⇒
それを消費して、その結果を %表現 に付加する
◎
While the next input code point is a digit, consume it and append it to repr.
</li>
	<li>
<p>
~IF［
`次の 2 個の入力~符号位置$は［
`2E^U, `数字$
］並びである
］：
◎
If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
</p>
		<ol>
			<li>
それらを消費して、その結果を %表現 に付加する
◎
Consume them.
◎
Append them to repr.
</li>
			<li>
%型 ~SET `実数^i
◎
Set type to "number".
</li>
			<li>
~WHILE［
`次入力~符号位置$ ~IN `数字$
］
⇒
それを消費して、その結果を %表現 に付加する
◎
While the next input code point is a digit, consume it and append it to repr.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［［
`次の 3 個の入力~符号位置$は［
`指数~指示子$, `正負符号$, `数字$
］並びである
］~OR［
`次の 2 個の入力~符号位置$は［
`指数~指示子$, `数字$
］並びである
］］：
◎
If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e), optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+), followed by a digit, then:
</p>
		<ol>
			<li>
それらを消費して、その結果を %表現 に付加する
◎
Consume them.
◎
Append them to repr.
</li>
			<li>
%型 ~SET `実数^i
◎
Set type to "number".
</li>
			<li>
~WHILE［
`次入力~符号位置$ ~IN `数字$
］
⇒
それを消費して、その結果を %表現 に付加する
◎
While the next input code point is a digit, consume it and append it to repr.
</li>
		</ol>
	</li>
	<li>
~RET ( 数値: %表現 を`実数に変換-$した結果, 型~flag: %型 ) が成す組
◎
Convert repr to a number, and set the value to the returned value.
◎
Return value and type.
</li>
</ol>

			</section>
			<section id="convert-string-to-number">
<h4 title="Convert a string to a number">4.3.13. 文字列を実数に変換する</h4>

<p>
この節では、文字列を
`実数に変換-@
する方法を述べる。
それは、実数を返す。
◎
This section describes how to convert a string to a number. It returns a number.
</p>

<p class="note">注記：
この~algoは、［
文字列が実数のみを包含しているかどうか
］は検証yしない。
~algoを呼ぶ際には，［
文字列が妥当な~CSS実数のみを包含している
］ことを事前に確保すること。
◎
Note: This algorithm does not do any verification to ensure that the string contains only a number. Ensure that the string contains only a valid CSS number before calling this algorithm.
</p>

<ol>
	<li>
<p>
文字列を先頭から順に 7 個の成分に分割する：
◎
Divide the string into seven components, in order from left to right:
</p>
		<ol>
			<li>
<b>符号</b>
— 0 〜 1 個の`正負符号$
⇒
%s ~LET ［
符号 ~EQ `2D^U ならば −1 ／
~ELSE_ 1
］
◎
A sign: a single U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), or the empty string. Let s be the number -1 if the sign is U+002D HYPHEN-MINUS (-); otherwise, let s be the number 1.
</li>
			<li>
<b>整数部</b>
— 0 個以上の`数字$
⇒
%i ~LET 整数部を 10 進~整数として解釈した結果~DAGGER
◎
An integer part: zero or more digits. If there is at least one digit, let i be the number formed by interpreting the digits as a base-10 integer; otherwise, let i be the number 0.
</li>
			<li>
<b>小数点</b>
— 0 〜 1 個の `2E^U
◎
A decimal point: a single U+002E FULL STOP (.), or the empty string.
</li>
			<li>
<b>小数部</b>
— 0 個以上の`数字$
⇒＃
%d ~LET 数字の個数,
%f ~LET 小数部を 10 進~整数として解釈した結果~DAGGER
◎
A fractional part: zero or more digits. If there is at least one digit, let f be the number formed by interpreting the digits as a base-10 integer and d be the number of digits; otherwise, let f and d be the number 0.
</li>
			<li>
<b>指数~指示子</b>
— 0 〜 1 個の`指数~指示子$
◎
An exponent indicator: a single U+0045 LATIN CAPITAL LETTER E (E) or U+0065 LATIN SMALL LETTER E (e), or the empty string.
</li>
			<li>
<b>指数~符号</b>
— 0 〜 1 個の`正負符号$
⇒
%t ~LET ［
指数~符号 ~EQ `2D^U ならば −1 ／
~ELSE_ 1
］
◎
An exponent sign: a single U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-), or the empty string. Let t be the number -1 if the sign is U+002D HYPHEN-MINUS (-); otherwise, let t be the number 1.
</li>
			<li>
<b>指数</b>
— 0 個以上の`数字$
⇒
%e ~LET 指数を 10 進~整数として解釈した結果~DAGGER
◎
An exponent: zero or more digits. If there is at least one digit, let e be the number formed by interpreting the digits as a base-10 integer; otherwise, let e be the number 0.
</li>
		</ol>

<p>~DAGGER
［
整数部／小数部／指数
］を成す文字が 0 個の場合（空~文字列）、 0 に解釈する。
</p>

	</li>
	<li>
~RET ［
%s
~MUL ( %i ~PLUS %f ~MUL 10<sup>−%d</sup> )
~MUL 10<sup>%t ~MUL %e</sup>
］
◎
Return the number s·(i + f·10-d)·10te.
</li>
</ol>

			</section>
			<section id="consume-remnants-of-bad-url">
<h4 title="Consume the remnants of a bad url">4.3.14. 不良~urlの残余を消費する</h4>

<p>
この節では、~tokenizerが，`符号位置$の~streamにおいて［
`url$tok ではなく，`bad-url$tok の中途にある
］ことが~~判明した際の “後始末” のために、
`不良~urlの残余を消費@
する方法を述べる。
それは ε を返し、もっぱら，［
通常の~token化処理を再開できるような回復~地点に達するまで，入力~streamを十分に消費する
］ために利用される。
◎
This section describes how to consume the remnants of a bad url from a stream of code points, "cleaning up" after the tokenizer realizes that it’s in the middle of a &lt;bad-url-token&gt; rather than a &lt;url-token&gt;. It returns nothing; its sole use is to consume enough of the input stream to reach a recovery point where normal tokenizing can resume.
</p>

<ol >
	<li>
<p>
~streamから`次入力~符号位置を繰返し消費する$：
◎
Repeatedly consume the next input code point from the stream:
</p>

		<dl class="switch">
			<dt>`29^U</dt>
			<dt>~EOF</dt>
			<dd>
<ol ><li>~RET ε
</li></ol>
◎
Return.
</dd>

			<dt>
入力~streamは `妥当な~escapeから開始している$
◎
the input stream starts with a valid escape
</dt>
			<dd>
<ol ><li>`~escapeされた符号位置を消費$する
</li></ol>
◎
Consume an escaped code point.＼
</dd>
			<dd class="note">注記：
これは、 `bad-url$tok を終端させずに，［
~escapeされた閉じ丸括弧（ `\)^l ）
］を取り込めるようにする。
それ以外については “他全部” の段と一致する。
◎
This allows an escaped right parenthesis ("\)") to be encountered without ending the &lt;bad-url-token&gt;. This is otherwise identical to the "anything else" clause.
</dd>

			<dt>他全部</dt>
			<dd>
<ol ><li>何もしない
</li></ol>
◎
Do nothing.
</dd>
		</dl>
	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="parsing">
<h2 title="Parsing">5. 構文解析-法</h2>

<p>
構文解析 段階への入力は、［
~stream, または
~token化~段階から得られた~token~list
］である。
その出力は、構文解析器が［
この節にて後に定義される，一連の入口
］のうち どれを介して呼出されたかに依存する。
構文解析器の出力は、何個かの［
`~at-rule$,
`有修飾~規則$,
`宣言$
］の混成からなる。
◎
The input to the parsing stage is a stream or list of tokens from the tokenization stage. The output depends on how the parser is invoked, as defined by the entry points listed later in this section. The parser output can consist of at-rules, qualified rules, and/or declarations.
</p>

<p>
構文解析器の出力は、特定のどの~itemについても，その妥当性は~~考慮せずに、~CSSの基礎的な構文に則って構築される。
実装は、種々の構文解析器~algoから~itemが返され次第，それらの~itemの妥当性を検査した上で、~itemが実装~自身に備わる文法の知識に則って無効なものであった際には，［
その~algoから ε が返されたものと扱う
］か, あるいは［
指定dどおりに全部的な~treeを構築した上で、無効な~itemは何であれ，除去する
］ことにより，それらを “一掃” してもヨイ。
◎
The parser’s output is constructed according to the fundamental syntax of CSS, without regards for the validity of any specific item. Implementations may check the validity of items as they are returned by the various parser algorithms and treat the algorithm as returning nothing if the item was invalid according to the implementation’s own grammar knowledge, or may construct a full tree as specified and "clean up" afterwards by removing any invalid items.
</p>

<p>
結果の~treeには、以下に挙げる~itemが出現し得る（一部の~itemには，いくつかの~~属性が伴われる）：
◎
The items that can appear in the tree are:
</p>

<dl>
	<dt>
`~at-rule@
◎
at-rule
</dt>
	<dd>
<p>
次の~~属性を持つ：
</p>
<ul ><li>.`名前^dfn
</li><li>.`導入部^dfn : `成分~値$~list
</li><li>.`~block^dfn（省略可能）: `波括弧~block$
</li></ul>
◎
An at-rule has a name, a prelude consisting of a list of component values, and an optional block consisting of a simple {} block.
</dd>
	<dd class="note">注記：
この仕様は、~at-ruleの.~blockが何を包含し得るかについては，制限sを課さない。
個々の`~at-rule$は、それが~blockを受容するかどうか, および受容する場合には［
その~blockを構文解析する方法
］を定義しなければナラナイ（この仕様が定義する，構文解析器の［
~algo／入口
］のうち いずれかを利用するのが好ましい）。
◎
Note: This specification places no limits on what an at-rule’s block may contain. Individual at-rules must define whether they accept a block, and if so, how to parse it (preferably using one of the parser algorithms or entry points defined in this specification).
</dd>

	<dt>
`有修飾~規則@
◎
qualified rule
</dt>
	<dd>
<p>
次の~~属性を持つ：
</p>
<ul ><li>.`導入部^dfn : `成分~値$~list
</li><li>.`~block^dfn : `波括弧~block$
</li></ul>
◎
A qualified rule has a prelude consisting of a list of component values, and a block consisting of a simple {} block.
</dd>
	<dd class="note">注記：
ほとんどの有修飾~規則は、その［
.導入部は`選択子$,
.~blockは`宣言~list$
］を与えるような，~style規則になる。
◎
Note: Most qualified rules will be style rules, where the prelude is a selector [SELECT] and the block a list of declarations.
</dd>

	<dt>
`宣言@
◎
declaration
</dt>
	<dd>
宣言は、概念的には，ある［
`~prop$／`記述子$
］の名前を ある値に結付ける，特定0の~instanceである。
◎
Conceptually, declarations are a particular instance of associating a property or descriptor name with a value.＼
</dd>
	<dd>
<p>
構文上は、次の~~属性を持つ：
</p>
<ul ><li>.`名前^dfn
</li><li>.`値^dfn : `成分~値$~list
</li><li>.`~importantか^dfn : 真偽値
— 初期~時は ~F
【`~importantな宣言$になるかどうかを指示する。】
</li></ul>
◎
Syntactically, a declaration has a name, a value consisting of a list of component values, and an important flag which is initially unset.
</dd>
	<dd>
宣言は更に，
`~prop宣言@
と
`記述子~宣言@
に分類される。
前者は、`有修飾~規則$内で出現することが最も多く，~CSS`~prop$を設定する。
後者は、`~at-rule$内に限り出現し，~CSS`記述子$を設定する。
（この分類は、この仕様の構文~levelにおいては生じない
— それは，宣言が出現する所における産物であり、当の規則を定義する仕様により定義される。）
◎
Declarations are further categorized as property declarations or descriptor declarations, with the former setting CSS properties and appearing most often in qualified rules and the latter setting CSS descriptors, which appear only in at-rules. (This categorization does not occur at the Syntax level; instead, it is a product of where the declaration appears, and is defined by the respective specifications defining the given rule.)
</dd>

	<dt>
`成分~値@
◎
component value
</dt>
	<dd>
次のいずれか
⇒
`保全d~token$ ／ `関数式$ ／ `単純~block$
◎
A component value is one of the preserved tokens, a function, or a simple block.
</dd>

	<dt>
`保全d~token@
◎
preserved tokens
</dt>
	<dd>
［
`function$tok,
`open-curly$Tok,
`open-paren$Tok,
`open-square$Tok
］以外の，~tokenizerにより生産される任意の~token。
◎
Any token produced by the tokenizer except for &lt;function-token&gt;s, &lt;{-token&gt;s, &lt;(-token&gt;s, and &lt;[-token&gt;s.
</dd>
	<dd class="note">注記：
［
上に挙げられた非`保全d~token$
］は常に，より高~levelな［
`関数式$／`単純~block$
］~objの中で消費されるので、構文解析器の出力には，決して出現しない。
◎
Note: The non-preserved tokens listed above are always consumed into higher-level objects, either functions or simple blocks, and so never appear in any parser output themselves.
</dd>
	<dd class="note">注記：
【出力に出現する】
~tokenのうち［
`close-curly$Tok,
`close-paren$Tok,
`close-square$Tok,
`bad-string$tok,
`bad-url$tok
］は，常に`構文解析error$を表すが、それらは， `MEDIAQ$r などの他の仕様が［
宣言や~blockを単にまるごと棄てるより細やかな、~errorの取扱い
］を定義できるようにするため、この仕様により，~token~streamの中に保全される。
◎
Note: The tokens &lt;}-token&gt;s, &lt;)-token&gt;s, &lt;]-token&gt;, &lt;bad-string-token&gt;, and &lt;bad-url-token&gt; are always parse errors, but they are preserved in the token stream by this specification to allow other specs, such as Media Queries, to define more fine-grained error-handling than just dropping an entire declaration or block.
</dd>

	<dt>
`関数式@
◎
function
</dt>
	<dd>
<p>
次の~~属性を持つ：
</p>
<ul ><li>.`名前^dfn
</li><li>.`値^dfn : `成分~値$~list
</li></ul>
◎
A function has a name and a value consisting of a list of component values.
</dd>

	<dt>
`単純~block@
◎
simple block
</dt>
	<dd>
<p>
次の~~属性を持つ：
</p>
<ul ><li>.`開き括弧^dfn ~DAGGER : `open-square$Tok, `open-paren$Tok, `open-curly$Tok のいずれか
</li><li>.`値^dfn : `成分~値$~list
</li></ul>
◎
A simple block has an associated token (either a &lt;[-token&gt;, &lt;(-token&gt;, or &lt;{-token&gt;) and a value consisting of a list of component values.
</dd>
	<dd class="trans-note">【
~DAGGER 開き括弧がとる値に応じて，順に
`角括弧~block@,
`丸括弧~block@,
`波括弧~block@
とも記される。
】</dd>

</dl>

		<section id="parser-diagrams">
<h3 title="Parser Railroad Diagrams">5.1. 構文解析器の線路図式</h3>

~INFORMATIVE

<p>
この節は、構文解析器の参考~viewを，線路図式の形で呈示する。
◎
This section presents an informative view of the parser, in the form of railroad diagrams.
</p>

<p>
これらの図式は、`参考であり, 不完全である^em。
~stylesheetの “正しい” 文法は述べるが、~errorの取扱いについては全く述べない。
それらはもっぱら，構文を直感的に把握し易くするために供されている。
◎
These diagrams are informative and incomplete; they describe the grammar of "correct" stylesheets, but do not describe error-handling at all. They are provided solely to make it easier to get an intuitive grasp of the syntax.
</p>

<dl>
	<dt id="stylesheet-diagram">`Stylesheet^sb（~stylesheet）</dt>
	<dd class="railroad">`stylesheet^dgm</dd>

	<dt id="rule-list-diagram">`Rule list^sb（`規則~list$）</dt>
	<dd class="railroad">`rule-list^dgm</dd>

	<dt id="at-rule-diagram">`At-rule^sb（`~at-rule$）</dt>
	<dd class="railroad">`at-rule^dgm</dd>

	<dt id="qualified-rule-diagram">`Qualified rule^sb（`有修飾~規則$）</dt>
	<dd class="railroad">`qualified-rule^dgm</dd>

	<dt id="declaration-list-diagram">`Declaration list^sb（`宣言~list$）</dt>
	<dd class="railroad">`declaration-list^dgm</dd>

	<dt id="declaration-diagram">`Declaration^sb（`宣言$）</dt>
	<dd class="railroad">`declaration^dgm</dd>

	<dt id="!important-diagram">`!important^sb</dt>
	<dd class="railroad">`important^dgm</dd>

	<dt id="component-value-diagram">`Component value^sb（`成分~値$）</dt>
	<dd class="railroad">`component-value^dgm</dd>

	<dt id="curly-block-diagram">`{} block^sb（`波括弧~block$）</dt>
	<dd class="railroad">`curly-block^dgm</dd>

	<dt id="paren-block-diagram">`() block^sb（`丸括弧~block$）</dt>
	<dd class="railroad">`paren-block^dgm</dd>

	<dt id="square-block-diagram">`[] block^sb（`角括弧~block$）</dt>
	<dd class="railroad">`square-block^dgm</dd>

	<dt id="function-block-diagram">`Function block^sb（`関数式$）</dt>
	<dd class="railroad">`function-block^dgm</dd>

</dl>

		</section>
		<section id="parser-definitions">
<h3 title="Definitions">5.2. 定義</h3>

<dl>
	<dt>
`現入力~token@
◎
current input token
</dt>
	<dd>
［
~tokenizerにより生産される~token~list
］からの，現在~操作oされている［
~tokenまたは`成分~値$
］。
◎
The token or component value currently being operated on, from the list of tokens produced by the tokenizer.
</dd>

	<dt>
`次入力~token@
◎
next input token
</dt>
	<dd>
`現入力~token$の直後に［
~tokenまたは`成分~値$
］が［
在るならばそれ ／
無いならば `EOF$tok
］。
◎
The token or component value following the current input token in the list of tokens produced by the tokenizer. If there isn’t a token following the current input token, the next input token is an &lt;EOF-token&gt;.
</dd>

	<dt>
`EOF@tok
</dt>
	<dd>
~token~listの終端を表現する概念的な~token。
~token~listが空になったときの`次入力~token$は、常に， `EOF$tok である。
◎
A conceptual token representing the end of the list of tokens. Whenever the list of tokens is empty, the next input token is always an &lt;EOF-token&gt;.
</dd>

	<dt>
`次入力~tokenを消費する@
◎
consume the next input token
</dt>
	<dd>
`現入力~token$を［
現在の`次入力~token$
］を指すようにする。
それに伴い，`次入力~token$もその次のものを指すようになる。
◎
Let the current input token be the current next input token, adjusting the next input token accordingly.
</dd>

	<dt>
`現入力~tokenを消費し直す@
◎
reconsume the current input token
</dt>
	<dd>
次回の［
`次入力~tokenを消費する$
］の挙動を，何もしないように変える（`現入力~token$を不変に保たせる）。
◎
The next time an algorithm instructs you to consume the next input token, instead do nothing (retain the current input token unchanged).
</dd>

	<dt>
“`次入力~tokenを繰返し消費する@：”
【この項は、この訳による補完】
</dt>
	<dd>
<p>
次を繰返し走らすことを意味する：
</p>
		<ol>
			<li>
`次入力~tokenを消費する$
</li>
			<li>
消費した~token（すなわち，`現入力~token$）に応じて、［
後続の~blockに記された，対応する段
］を走らす
</li>
		</ol>
<p>
繰返nは、値を返した時点（ ~RET ）で終了する。
</p>
	</dd>
</dl>

		</section>
		<section id="parser-entry-points">
<h3 title="Parser Entry Points">5.3. 構文解析器の入口</h3>

<p>
この節に定義する各種~algoは、低~levelな~CSS~tokenから高~levelな~CSS~objを生産する。
◎
The algorithms defined in this section produce high-level CSS objects from lists of CSS tokens.
</p>

<p>
これらの~algoは，~token~streamを入力として演算するが、便利~用に，何種かの他の値~型でも
— `~token~streamに正規化する$ことを介して，それが受容する値~型でも —
呼出せる。
◎
The algorithms here are operate on a token stream as input, but for convenience can also be invoked with a number of other value types.
</p>

<div class="algo">
<p>
`~token~streamに正規化する@
ときは、所与の %入力 に対し，その型に応じて：
◎
To normalize into a token stream a given input:
</p>

<ul class="switch">
	<li>
<p>
~CSS~tokenたちが成す~list／
~CSS成分~値たちが成す~list
⇒
~RET %入力
◎
If input is a list of CSS tokens, return input.
◎
If input is a list of CSS component values, return input.
</p>

<p class="note">注記：
［
~tokenたちが成す~list,
成分~値たちが成す~list
］の間の唯一の相違は、［
関数や~blockの様な，何かを “包含する” 一部の~obj
］は［
成分~値~list内では 1 個の実体を成すが，~token~list内では複数個の実体を成す
］ことにある。
この仕様~内の~algoに対しては、このことにより生じる相違はない。
◎
Note: The only difference between a list of tokens and a list of component values is that some objects that "contain" things, like functions or blocks, are a single entity in the component-value list, but are multiple entities in a token list. This makes no difference to any of the algorithms in this specification.
</p>

	</li>
	<li>
`文字列$
⇒
~RET `~token化する$( `符号位置~列を~filterする$( %入力 ) )
◎
If input is a string, then filter code points from input, tokenize the result, and return the final result.
</li>
	<li>
その他
⇒
~Assert：
この事例は生じ得ない
— %入力 として渡されるのは、上に挙げた型に限られるベキである。
◎
Assert: Only the preceding types should be passed as input.
</li>
</ul>
</div>

<p class="note">注記：
他の仕様は、追加的な入口を 自身の目的に定義できる。
◎
Note: Other specs can define additional entry points for their own purposes.
</p>

<div class="note">
<p>
以下の注記は、おそらく，関連な仕様の規範的な~textに
— この仕様の用語を通して —
翻訳されるべきである：
◎
The following notes should probably be translated into normative text in the relevant specs, hooking this spec’s terms:
</p>

<ul>
	<li>
“`~stylesheetを構文解析する$”
は、~stylesheetを構文解析するときの，構文解析器の通常の入口になることが意図されている。
◎
"Parse a stylesheet" is intended to be the normal parser entry point, for parsing stylesheets.
</li>
	<li>
“`規則~listを構文解析する$”
は、~at-rule（ `media$at など）の内容~用に意図されている。
それは、［
`CDO$tok, `CDC$tok
］の取扱いにおいて，
“`~stylesheetを構文解析する$”
と異なる。
◎
"Parse a list of rules" is intended for the content of at-rules such as @media. It differs from "Parse a stylesheet" in the handling of &lt;CDO-token&gt; and &lt;CDC-token&gt;.
</li>
	<li>
“`規則を構文解析する$”
は、~textを構文解析して 1 個の規則を得る［
`CSSStyleSheet$I の `insertRule()^c ~method
］その他の類似な関数からの利用が意図されている。
◎
"Parse a rule" is intended for use by the CSSStyleSheet#insertRule method, and similar functions which might exist, which parse text into a single rule.
</li>
	<li>
“`宣言を構文解析する$”
は、`条件付き~group規則$（ `supports$at ）からの利用が意図されている。
`CSS3-CONDITIONAL$r
◎
"Parse a declaration" is used in @supports conditions. [CSS3-CONDITIONAL]
</li>
	<li>
“`宣言~listを構文解析する$”
は、 `style^a 属性の内容~用に，~textを 1 個の~style規則の内容として構文解析する。
◎
"Parse a list of declarations" is for the contents of a style attribute, which parses text into the contents of a single style rule.
</li>
	<li>
“`成分~値を構文解析する$”
は、 `attr$f の構文解析~規則の様な， 1 個の値を消費するために必要になる。
◎
"Parse a component value" is for things that need to consume a single value, like the parsing rules for attr().
</li>
	<li>
“`成分~値~listを構文解析する$”
は、呈示~用の属性の内容~text【`非~CSS呈示~用~hint$など】を 1 個の宣言~値として構文解析したり，［
【！<a href="~TR/selectors-api/">~Selectors~API</a>】
`querySelector()$c などの選択子~APIに渡す自立的な`選択子$ ／
~HTMLの `media$a 属性に与える`媒体~query~list$
］を構文解析するためにある。
◎
"Parse a list of component values" is for the contents of presentational attributes, which parse text into a single declaration’s value, or for parsing a stand-alone selector [SELECT] or list of Media Queries [MEDIAQ], as in Selectors API or the media HTML attribute.
</li>
</ul>
</div>

			<section id="parse-grammar">
<h4 title="Parse something according to a CSS grammar">5.3.1. ある~CSS文法に則って何かを構文解析する</h4>

<p>
文字列や~token~listを構文解析して，何らかの~CSS文法に合致するかどうか見た上で、合致したならば，その文法に則って各成分に切り分けたい（ `destructure^en ）と欲されることは多い。
この節では、この種の演算~用に汎用な~hookを供する。
それは、
“ %foo を~CSS `color$t 文法に則って構文解析する”
等々のように呼出されるべきである。
◎
It is often desirable to parse a string or token list to see if it matches some CSS grammar, and if it does, to destructure it according to the grammar. This section provides a generic hook for this kind of operation. It should be invoked like "parse foo as a CSS &lt;color&gt;", or similar.
</p>

<p>
この~algoは、所与の［
供された文法に対応する構造が指定されていない入力
］が，その文法に［
合致しないならば `失敗^i ／
合致するならば その文法に則って入力を構文解析した結果
］を返す。
結果とヤリトリできるのは、表現の多義性が問題にならない所, かつ仕様の注釈文に限られなければナラナイ。
仕様~言語の外側へ公開することが意味される場合、その仕様は，結果を［
きちんと指定された表現
］に明示的に翻訳しなければナラナイ
— 例えば、（
“~CSS `string$t として直列化する”
の様に）何らかの~CSS直列化~algoを呼出して。
◎
This algorithm returns either failure, if the input does not match the provided grammar, or the result of parsing the input according to the grammar, which is an unspecified structure corresponding to the provided grammar specification. The return value must only be interacted with by specification prose, where the representation ambiguity is not problematic. If it is meant to be exposed outside of spec language, the spec using the result must explicitly translate it into a well-specified representation, such as, for example, by invoking a CSS serialization algorithm (like "serialize as a CSS &lt;string&gt; value").
</p>

<p class="note">注記：
他の仕様から~callしたいと求まれる構文解析~algoは、`通例的に^em，［
この~algo, および`~commaで分離された~listを~CSS文法に則って構文解析する$
］に限られる。
残りの構文解析~algoは、ほとんど［
`CSSOM$r, それに関係する “明示的に~CSS構造を構築する” 事例
］用に意味される
— それらの~algoを利用する必要があると~~考えている策定者は、まず~CSS~WGに指導をアタられたし。
◎
Note: This algorithm, and parse a comma-separated list according to a CSS grammar, are usually the only parsing algorithms other specs will want to call. The remaining parsing algorithms are meant mostly for [CSSOM] and related "explicitly constructing CSS structures" cases. Consult the CSSWG for guidance first if you think you need to use one of the other algorithms.
</p>

<div class="algo">
<p>
何かを
`~CSS文法に則って構文解析する@
（略して，単に “構文解析する” ）ときは、所与の
( %入力, ~CSS文法 %生成規則 )
に対し：
◎
To parse something according to a CSS grammar (aka simply parse) given an input and a CSS grammar production:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
%結果 ~LET %入力 から`成分~値~listを構文解析する$
◎
Parse a list of component values from input, and let result be the return value.
</li>
	<li>
~RET %結果 が %生成規則 の文法に［
合致するならば，合致した結果 ／
合致しないならば `失敗^i
］
◎
Attempt to match result against grammar. If this is successful, return the matched result; otherwise, return failure.
</li>
</ol>
</div>

			</section>
			<section id="parse-comma-list">
<h4 title="Parse A Comma-Separated List According To A CSS Grammar">5.3.2. ~commaで分離された~listを ある~CSS文法に則って構文解析する</h4>

<p>
~commaを伴う値でも，`~CSS文法に則って構文解析する$ことは もちろんできるが、値を成す`すべての部分^emが成功裡に構文解析されない限り， `失敗^i を返すことになる。
◎
While one can definitely parse a value according to a grammar with commas in it, if any part of the value fails to parse, the entire thing doesn’t parse, and returns failure.
</p>

<p>
それが欲されることもあるが（~CSS~propのうち`~list値をとる$ものなど）、値を成す各~commaで分離された下位部分を別々に構文解析して，［
各~結果に対し、成功したか失敗したかに応じて，別な仕方で処する
］方が良いこともある（失敗した場合、概して，無視されよう
— `img$e の `sizes$a 属性を<a href="~HEimages#parse-a-sizes-attribute">構文解析する</a>ときなど）。
◎
Sometimes that’s what’s desired (such as in list-valued CSS properties); other times, it’s better to let each comma-separated sub-part of the value parse separately, dealing with the parts that parse successfully one way, and the parts that fail to parse another way (typically ignoring them, such as in &lt;img sizes&gt;).
</p>

<p>
次の~algoは、これを成遂げるための容易な~hookを供する。
それは、 “~top-level” の~commaで~~分割された値たちが成す~listを返す
— ~listを成す各~値は、［
`失敗^i （構文解析-に失敗した）／構文解析した結果（`構文解析-$する~algoにて述べたように，構造が未指定な）
］になる。
◎
This algorithm provides an easy hook to accomplish exactly that. It returns a list of values split by "top-level" commas, where each values is either failure (if it failed to parse) or the result of parsing (an unspecified structure, as described in the parse algorithm).
</p>

<div class="algo">
<p>
`~commaで分離された~listを~CSS文法に則って構文解析する@
（略して，単に “~listを構文解析する” ）ときは、所与の
( %入力, ~CSS文法 %生成規則 )
に対し：
◎
To parse a comma-separated list according to a CSS grammar (aka parse a list) given an input and a CSS grammar production:
</p>
<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
~IF［
%入力 は `whitespace$tok 以外のものを包含しない
］
⇒
~RET 空~list
◎
If input contains only &lt;whitespace-token&gt;s, return an empty list.
</li>
	<li>
%~list ~LET %入力 から`~commaで分離された成分~値~listを構文解析する$
◎
Parse a comma-separated list of component values from input, and let list be the return value.
</li>
	<li>
%~list を成す
~EACH( %~item )
に対し
⇒
%~item を次の結果に置換する
⇒
`~CSS文法に則って構文解析する$( %~item, %生成規則 )
◎
For each item of list, replace item with the result of parsing item with grammar.
</li>
	<li>
~RET %~list
◎
Return list.
</li>
</ol>
</div>

			</section>
			<section id="parse-stylesheet">
<h4 title="Parse a stylesheet">5.3.3. ~stylesheetを構文解析する</h4>

<div class="algo">
<p>
%入力 から
`~stylesheetを構文解析する@
ときは：
◎
To parse a stylesheet from an input:
</p>

<ol>
	<li>
~IF［
%入力 は~stylesheet用の~byte~streamである
］
⇒
%入力 ~SET `~stylesheetの~byte列を復号する$( %入力 )
◎
If input is a byte stream for stylesheet, decode bytes from input, and set input to the result.
</li>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
%~stylesheet ~LET 新たな~stylesheet
◎
Create a new stylesheet.
</li>
	<li>
%~stylesheet の値 ~SET `~top-level^i を与える下で，
%入力 から`規則~listを消費$した結果
◎
Consume a list of rules from input, with the top-level flag set, and set the stylesheet’s value to the result.
</li>
	<li>
~RET %~stylesheet
◎
Return the stylesheet.
</li>
</ol>
</div>

			</section>
			<section id="parse-list-of-rules">
<h4 title="Parse a list of rules">5.3.4. 規則~listを構文解析する</h4>

<div class="algo">
<p>
%入力 から
`規則~listを構文解析する@
ときは：
◎
To parse a list of rules from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
~RET `~top-level^i を与える下で，
%入力 から`規則~listを消費$した結果
◎
Consume a list of rules from the input, with the top-level flag unset.
◎
Return the returned list.
</li>
</ol>
</div>

			</section>
			<section id="parse-rule">
<h4 title="Parse a rule">5.3.5. 規則を構文解析する</h4>

<div class="algo">
<p>
%入力 から
`規則を構文解析する@
ときは：
◎
To parse a rule from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
~WHILE［
%入力 の`次入力~token$は `whitespace$tok である
］
⇒
%入力 から`次入力~tokenを消費する$
◎
While the next input token from input is a &lt;whitespace-token&gt;, consume the next input token from input.
</li>
	<li>
~IF［
%入力 の`次入力~token$は `EOF$tok である
］
⇒
~RET 構文~error
◎
If the next input token from input is an &lt;EOF-token&gt;, return a syntax error.
</li>
	<li>
~IF［
%入力 の`次入力~token$は `at-keyword$tok である
］
⇒
%規則 ~LET %入力 から`~at-ruleを消費$した結果
◎
Otherwise, if the next input token from input is an &lt;at-keyword-token&gt;, consume an at-rule from input, and let rule be the return value.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%規則 ~LET %入力 から`有修飾~規則を消費$した結果
</li>
			<li>
~IF［
%規則 ~EQ ε
］
⇒
~RET 構文~error
</li>
		</ol>

◎
Otherwise, consume a qualified rule from input and let rule be the return value. If nothing was returned, return a syntax error.
</li>
	<li>
~WHILE［
%入力 の`次入力~token$は `whitespace$tok である
］
⇒
%入力 から`次入力~tokenを消費する$
◎
While the next input token from input is a &lt;whitespace-token&gt;, consume the next input token from input.
</li>
	<li>
~IF［
%入力 の`次入力~token$は `EOF$tok である
］
⇒
~RET %規則
◎
If the next input token from input is an &lt;EOF-token&gt;, return rule.＼
</li>
	<li>
~RET 構文~error
◎
Otherwise, return a syntax error.
</li>
</ol>
</div>

			</section>
			<section id="parse-declaration">
<h4 title="Parse a declaration">5.3.6. 宣言を構文解析する</h4>

<p class="note">注記：
“`宣言~listを構文解析する$”
ときと異なり、これは宣言のみを構文解析し，~at-ruleは構文解析しない。
◎
Note: Unlike "Parse a list of declarations", this parses only a declaration and not an at-rule.
</p>

<div class="algo">
<p>
%入力 から
`宣言を構文解析する@
ときは：
◎
To parse a declaration from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
~WHILE［
%入力 の`次入力~token$は `whitespace$tok である
］
⇒
%入力 から`次入力~tokenを消費する$
◎
While the next input token from input is a &lt;whitespace-token&gt;, consume the next input token.
</li>
	<li>
~IF［
%入力 の`次入力~token$は `ident$tok でない
］
⇒
~RET 構文~error
◎
If the next input token from input is not an &lt;ident-token&gt;, return a syntax error.
</li>
	<li>
%宣言 ~LET %入力 から`宣言を消費$した結果
◎
Consume a declaration from input.＼
</li>
	<li>
~IF［
%宣言 ~NEQ ε
］
⇒
~RET %宣言
◎
If anything was returned, return it.＼
</li>
	<li>
~RET 構文~error
◎
Otherwise, return a syntax error.
</li>
</ol>
</div>

			</section>
			<section id="parse-list-of-declarations">
<h4 title="Parse a list of declarations">5.3.7. 宣言~listを構文解析する</h4>

<p class="note">注記：
その名前に反し、これは，実際には［
宣言と~at-rule
］が混在する~listを構文解析する
— CSS 2.1 の `page$at に対し行われるように。
期待されない~at-rule（所与の文脈~内の，すべてを占め得る）は、無効であり，消費側からは無視されることになる。
◎
Note: Despite the name, this actually parses a mixed list of declarations and at-rules, as CSS 2.1 does for @page. Unexpected at-rules (which could be all of them, in a given context) are invalid and will be ignored by the consumer.
</p>

<div class="algo">
<p>
%入力 から
`宣言~listを構文解析する@
ときは：
◎
To parse a list of declarations from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
~RET %入力 から`宣言~listを消費$した結果
◎
Consume a list of declarations from input, and return the result.
</li>
</ol>
</div>

			</section>
			<section id="parse-component-value">
<h4 title="Parse a component value">5.3.8. 成分~値を構文解析する</h4>

<div class="algo">
<p>
%入力 から
`成分~値を構文解析する@
ときは：
◎
To parse a component value from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
~WHILE［
%入力 の`次入力~token$は `whitespace$tok である
］
⇒
%入力 から`次入力~tokenを消費する$
◎
While the next input token from input is a &lt;whitespace-token&gt;, consume the next input token from input.
</li>
	<li>
~IF［
%入力 の`次入力~token$は `EOF$tok である
］
⇒
~RET 構文~error
◎
If the next input token from input is an &lt;EOF-token&gt;, return a syntax error.
</li>
	<li>
%成分~値 ~LET %入力 から`成分~値を消費$した結果
◎
Consume a component value from input and let value be the return value.
</li>
	<li>
~WHILE［
%入力 の`次入力~token$は `whitespace$tok である
］
⇒
%入力 から`次入力~tokenを消費する$
◎
While the next input token from input is a &lt;whitespace-token&gt;, consume the next input token.
</li>
	<li>
~IF［
%入力 の`次入力~token$は `EOF$tok である
］
⇒
~RET %成分~値
◎
If the next input token from input is an &lt;EOF-token&gt;, return value.＼
</li>
	<li>
~RET 構文~error
◎
Otherwise, return a syntax error.
</li>
</ol>
</div>

			</section>
			<section id="parse-list-of-component-values">
<h4 title="Parse a list of component values">5.3.9. 成分~値~listを構文解析する</h4>

<div class="algo">
<p>
%入力 から
`成分~値~listを構文解析する@
ときは：
◎
To parse a list of component values from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
%~list ~LET 空~list
◎
↓</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%成分~値 ~LET %入力 から`成分~値を消費$した結果
</li>
			<li>
~IF［
%成分~値 は `EOF$tok である
］
⇒
~BREAK
</li>
			<li>
%~list に %成分~値 を付加する
</li>
		</ol>

◎
Repeatedly consume a component value from input until an &lt;EOF-token&gt; is returned, appending the returned values (except the final &lt;EOF-token&gt;) into a list.＼
</li>
	<li>
~RET %~list
◎
Return the list.
</li>
</ol>
</div>

			</section>
			<section id="parse-comma-separated-list-of-component-values">
<h4 title="Parse a comma-separated list of component values">5.3.10. ~commaで分離された成分~値~listを構文解析する</h4>

<div class="algo">
<p>
%入力 から
`~commaで分離された成分~値~listを構文解析する@
ときは：
◎
To parse a comma-separated list of component values from input:
</p>

<ol>
	<li>
%入力 ~SET `~token~streamに正規化する$( %入力 )
◎
Normalize input, and set input to the result.
</li>
	<li>
%成分~値~listの~list ~LET 空~list
◎
Let list of cvls be an initially empty list of component value lists.
</li>
	<li>
<p>
~WHILE［
`現入力~token$は `EOF$tok でない
］：
</p>
		<ol>
			<li>
%~list ~LET 空~list
</li>
			<li>
<p>
~WHILE 無条件：
</p>
				<ol>
					<li>
%成分~値 ~LET %入力 から`成分~値を消費$した結果
</li>
					<li>
~IF［
%成分~値 は［
`EOF$tok ／ `comma$tok
］である
⇒
~BREAK
</li>
					<li>
%~list に %成分~値 を付加する
</li>
				</ol>
			</li>
			<li>
%成分~値~listの~list に %~list を付加する
</li>
		</ol>
◎
Repeatedly consume a component value from input until an &lt;EOF-token&gt; or &lt;comma-token&gt; is returned, appending the returned values (except the final &lt;EOF-token&gt; or &lt;comma-token&gt;) into a list. Append the list to list of cvls.
◎
If it was a &lt;comma-token&gt; that was returned, repeat this step.
</li>
	<li>
~RET %成分~値~listの~list
◎
Return list of cvls.
</li>
</ol>
</div>

			</section>
		</section>
		<section id="parser-algorithms">
<h3 title="Parser Algorithms">5.4. 構文解析器~algo</h3>

<p>
構文解析器は、この節に挙げる一連の~algoからなる。
これらは、上述の各種［
構文解析器の入口
］から呼ばれる。
◎
The following algorithms comprise the parser. They are called by the parser entry points above.
</p>

<p>
これらの~algoは，［
~token~list, 成分~値~list
］のいずれかを伴って呼ばれ得る。
【！ 混成／別種？／一部の~algoが？】
（`成分~値$~listにおいては，一部の~tokenが［
`関数式$や`単純~block$
］に置換される点で異なる）。
~token化~段階において，入力~streamから［
それが空である【消費され尽くした】ことを表現する`~EOF符号位置$が返される
］のと同様に、この段階における~listでは、次の~tokenが要請されたにもかかわらず，それが空であるときは、 `EOF$tok を返すモノトスル。
◎
These algorithms may be called with a list of either tokens or of component values. (The difference being that some tokens are replaced by functions and simple blocks in a list of component values.) Similar to how the input stream returned EOF code points to represent when it was empty during the tokenization stage, the lists in this stage must return an &lt;EOF-token&gt; when the next token is requested but they are empty.
</p>

<p>
~algoは，特定の~listを伴って呼出され得る
— この場合、その~listのみを消費する（その~listが枯渇したときは，`EOF$tok を返すようになる）。
他の場合、暗黙的に，呼出している~algoのものと同じ~listを伴って呼出される。
◎
An algorithm may be invoked with a specific list, in which case it consumes only that list (and when that list is exhausted, it begins returning &lt;EOF-token&gt;s). Otherwise, it is implicitly invoked with the same list as the invoking algorithm.
</p>

<div class="trans-note">
<p>
この節における表記
⇒
“新たな %~obj ( %名前: %値 , … )”
</p>

<p>
は、新たに作成される %~obj の~instanceであって，その各種~~属性が括弧内に記されたように初期化されたものを表す。
</p>
</div>

			<section id="consume-list-of-rules">
<h4 title="Consume a list of rules">5.4.1. 規則~listを消費する</h4>

<p>
`規則~listを消費@
するときは、所与の %~top-level~flag ~IN { `~top-level^i , ε } （省略時は ε ）に対し：
◎
To consume a list of rules:
</p>

<ol>
	<li>
%規則~list ~LET 新たな`~list$
◎
Create an initially empty list of rules.
</li>
	<li>
<p>
`次入力~tokenを繰返し消費する$：
◎
Repeatedly consume the next input token:
</p>

		<dl class="switch">
			<dt>`whitespace$tok</dt>
			<dd>
				<ol>
					<li>
何もしない
◎
Do nothing.
</li>
				</ol>
			</dd>

			<dt>`EOF$tok</dt>
			<dd>
				<ol>
					<li>
~RET %規則~list
◎
Return the list of rules.
</li>
				</ol>
			</dd>

			<dt>`CDO$tok</dt>
			<dt>`CDC$tok</dt>
			<dd>
				<ol>
					<li>
~IF［
%~top-level~flag ~EQ `~top-level^i
］
⇒
何もしない
◎
If the top-level flag is set, do nothing.
</li>
					<li>
<p>
~ELSE：
◎
Otherwise,＼
</p>
						<ol>
							<li>
`現入力~tokenを消費し直す$
◎
reconsume the current input token.＼
</li>
							<li>
%規則 ~LET `有修飾~規則を消費$した結果
◎
Consume a qualified rule.＼
</li>
							<li>
~IF［
%規則 ~NEQ ε
］
⇒
%規則~list に %規則 を付加する
◎
If anything is returned, append it to the list of rules.
</li>
						</ol>
					</li>
				</ol>
			</dd>

			<dt>`at-keyword$tok</dt>
			<dd>
				<ol>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
`~at-ruleを消費$して，その結果を %規則~list に付加する
◎
Consume an at-rule, and append the returned value to the list of rules. 
</li>
				</ol>
			</dd>

			<dt>他全部</dt>
			<dd>
				<ol>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
%規則 ~LET `有修飾~規則を消費$した結果
◎
Consume a qualified rule.＼
</li>
					<li>
~IF［
%規則 ~NEQ ε
］
⇒
%規則~list に %規則 を付加する
◎
If anything is returned, append it to the list of rules.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-at-rule">
<h4 title="Consume an at-rule">5.4.2. ~at-ruleを消費する</h4>

<p>
`~at-ruleを消費@
するときは：
◎
To consume an at-rule:
</p>

<ol>
	<li>
%~token ~LET `次入力~tokenを消費$した結果
◎
Consume the next input token.＼
</li>
	<li>
%~at-rule ~LET 新たな`~at-rule$ (
名前: %~token の.値 ,
導入部: 空~list,
~block: ε
)
◎
Create a new at-rule with its name set to the value of the current input token, its prelude initially set to an empty list, and its value initially set to nothing.
</li>
	<li>
<p>
`次入力~tokenを繰返し消費する$：
◎
Repeatedly consume the next input token:
</p>
		<dl class="switch">
			<dt>`semicolon$tok</dt>
			<dd>
				<ol>
					<li>
~RET %~at-rule
◎
Return the at-rule.
</li>
				</ol>
			</dd>

			<dt>`EOF$tok</dt>
			<dd>
				<ol>
					<li>
`構文解析error$
◎
This is a parse error.＼
</li>
					<li>
~RET %~at-rule
◎
Return the at-rule.
</li>
				</ol>
			</dd>

			<dt>`open-curly$Tok</dt>
			<dd>
				<ol>
					<li>
%~at-rule の.~block ~SET `単純~blockを消費$した結果
◎
Consume a simple block and assign it to the at-rule’s block.＼
</li>
					<li>
~RET %~at-rule
◎
Return the at-rule.
</li>
				</ol>
			</dd>

			<dt>
`波括弧~block$
◎
simple block with an associated token of &lt;{-token&gt;
</dt>
			<dd>
				<ol>
					<li>
%~at-rule の.~block ~SET その~block
◎
Assign the block to the at-rule’s block.＼
</li>
					<li>
~RET %~at-rule
◎
Return the at-rule.
</li>
				</ol>
			</dd>

			<dt>他全部</dt>
			<dd>
<ol >
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
`成分~値を消費$して、その結果を %~at-rule の.導入部に付加する
◎
Consume a component value. Append the returned value to the at-rule’s prelude.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-qualified-rule">
<h4 title="Consume a qualified rule">5.4.3. 有修飾~規則を消費する</h4>

<p>
`有修飾~規則を消費@
するときは：
◎
To consume a qualified rule:
</p>

<ol >
	<li>
%規則 ~LET 新たな`有修飾~規則$ (
導入部: 新たな`~list$,
~block: ε
)
◎
Create a new qualified rule with its prelude initially set to an empty list, and its value initially set to nothing.
</li>
	<li>
<p>
`次入力~tokenを繰返し消費する$：
◎
Repeatedly consume the next input token:
</p>

		<dl class="switch">
			<dt>`EOF$tok</dt>
			<dd>
				<ol>
					<li>
`構文解析error$
◎
This is a parse error.＼
</li>
					<li>
~RET ε
◎
Return nothing.
</li>
				</ol>
			</dd>

			<dt>`open-curly$Tok</dt>
			<dd>
				<ol>
					<li>
%規則 の.~block ~SET `単純~blockを消費$した結果
◎
Consume a simple block and assign it to the qualified rule’s block.＼
</li>
					<li>
~RET %規則
◎
Return the qualified rule.
</li>
				</ol>
			</dd>

			<dt>
`波括弧~block$
◎
simple block with an associated token of &lt;{-token&gt;
</dt>
			<dd>
				<ol>
					<li>
%規則 の.~block ~SET その~block
◎
Assign the block to the qualified rule’s block.＼
</li>
					<li>
~RET %規則
◎
Return the qualified rule.
</li>
				</ol>
			</dd>

			<dt>他全部</dt>
			<dd>
				<ol>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
`成分~値を消費$して、その結果を %規則 の.導入部に付加する
◎
Consume a component value. Append the returned value to the qualified rule’s prelude.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-list-of-declarations">
<h4 title="Consume a list of declarations">5.4.4. 宣言~listを消費する</h4>

<p>
`宣言~listを消費@
するときは：
◎
To consume a list of declarations:
</p>

<ol>
	<li>
%宣言~list ~LET 空~list
◎
Create an initially empty list of declarations.
</li>
	<li>
<p>
`次入力~tokenを繰返し消費する$：
◎
Repeatedly consume the next input token:
</p>

		<dl class="switch">
			<dt>`whitespace$tok</dt>
			<dt>`semicolon$tok</dt>
			<dd>
				<ol>
					<li>
何もしない
</li>
				</ol>
◎
Do nothing.
</dd>

			<dt>`EOF$tok</dt>
			<dd>
				<ol>
					<li>
~RET %宣言~list
◎
Return the list of declarations.
</li>
				</ol>
			</dd>

			<dt>`at-keyword$tok</dt>
			<dd>
				<ol>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
`~at-ruleを消費$して、その結果を %宣言~list に付加する
◎
Consume an at-rule. Append the returned rule to the list of declarations.
</li>
				</ol>
			</dd>

			<dt>`ident$tok</dt>
			<dd>
				<ol>
					<li>
%temp ~LET `現入力~token$ のみからなる一時的な~list
◎
Initialize a temporary list initially filled with the current input token.＼
</li>
					<li>
~WHILE［
%入力 の`次入力~token$は［
`semicolon$tok ／ `EOF$tok
］ではない
］
⇒
`成分~値を消費$して、その結果を %temp に付加する
◎
As long as the next input token is anything other than a &lt;semicolon-token&gt; or &lt;EOF-token&gt;, consume a component value and append it to the temporary list.＼
</li>
					<li>
%宣言 ~LET `宣言を消費$した結果
◎
Consume a declaration from the temporary list.＼
</li>
					<li>
~IF［
%宣言 ~NEQ ε
］
⇒
%宣言~list に %宣言 を付加する
◎
If anything was returned, append it to the list of declarations.
</li>
				</ol>
			</dd>

			<dt>他全部</dt>
			<dd>
				<ol>
					<li>
`構文解析error$
◎
This is a parse error.＼
</li>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
~WHILE［
%入力 の`次入力~token$は［
`semicolon$tok ／ `EOF$tok
］ではない
］
⇒
`成分~値を消費$する（結果は~~棄てる）
◎
As long as the next input token is anything other than a &lt;semicolon-token&gt; or &lt;EOF-token&gt;, consume a component value and throw away the returned value.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

			</section>
			<section id="consume-declaration">
<h4 title="Consume a declaration">5.4.5. 宣言を消費する</h4>

<p class="note">注記：
この~algoは、［
`次入力~token$は `ident$tok である
］と見做す。
◎
Note: This algorithm assumes that the next input token has already been checked to be an &lt;ident-token&gt;.
</p>

<p>
`宣言を消費@
するときは：
◎
To consume a declaration:
</p>

<ol>
	<li>
%名前~token ~LET `次入力~tokenを消費$した結果
◎
Consume the next input token.＼
</li>
	<li>
%宣言 ~LET 新たな`宣言$ ( 名前: %名前~token の.値 , 値: 新たな`~list$ )
◎
Create a new declaration with its name set to the value of the current input token and its value initially set to an empty list.
</li>
	<li>
~WHILE［
`次入力~token$は `whitespace$tok である
］
⇒
`次入力~tokenを消費する$
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>
	<li>
<p>
~IF［
`次入力~token$は `colon$tok でない
］：
</p>
<ol ><li>`構文解析error$
</li><li>~RET ε
</li></ol>
◎
If the next input token is anything other than a &lt;colon-token&gt;, this is a parse error. Return nothing.
</li>
	<li>
`次入力~tokenを消費する$
◎
Otherwise, consume the next input token.
</li>
	<li>
~WHILE［
`次入力~token$は `whitespace$tok である
］
⇒
`次入力~tokenを消費する$
◎
While the next input token is a &lt;whitespace-token&gt;, consume the next input token.
</li>
	<li>
~WHILE［
`次入力~token$は `EOF$tok でない
］
⇒
`成分~値を消費$して、その結果を %宣言 の.値に付加する
◎
As long as the next input token is anything other than an &lt;EOF-token&gt;, consume a component value and append it to the declaration’s value.
</li>
	<li>
<p>
~IF［
%宣言 の.値の中に
`whitespace$tok でない~tokenが 2 個~以上あって，それらのうち最後の 2 個は順に次を満たす
］…：
◎
If the last two non-&lt;whitespace-token&gt;s in the declaration’s value are＼
</p>
		<ol>
			<li>
`delim$tok であって，その.値 ~EQ `21^U
◎
a &lt;delim-token&gt; with the value "!" followed by＼
</li>
			<li>
`ident$tok であって，その.値 ~EQ`大小無視$sub `important^l
◎
an &lt;ident-token&gt; with a value that is an ASCII case-insensitive match for "important",＼
</li>
		</ol>
<p>
…ならば：
◎
＼
</p>
		<ol>
			<li>
その 2 個の~tokenを %宣言 の.値から除去する
◎
remove them from the declaration’s value and＼
</li>
			<li>
%宣言 の.~importantか ~SET ~T
◎
set the declaration’s important flag to true.
</li>
		</ol>
	</li>
	<li>
~WHILE［
%宣言 の.値の最後の~tokenは `whitespace$tok である
］
⇒
その~tokenを %宣言 の.値から除去する
◎
While the last token in the declaration’s value is a &lt;whitespace-token&gt;, remove that token.
</li>
	<li>
~RET %宣言
◎
Return the declaration.
</li>
</ol>

			</section>
			<section id="consume-component-value">
<h4 title="Consume a component value">5.4.6. 成分~値を消費する</h4>

<p>
`成分~値を消費@
するときは：
◎
To consume a component value:
</p>

<ol>
	<li>
`次入力~tokenを消費する$
◎
Consume the next input token.
</li>
	<li>
~IF［
`現入力~token$は［
`open-curly$Tok,
`open-square$Tok,
`open-paren$Tok
］のいずれかである
］
⇒
~RET `単純~blockを消費$した結果
◎
If the current input token is a &lt;{-token&gt;, &lt;[-token&gt;, or &lt;(-token&gt;, consume a simple block and return it.
</li>
	<li>
~IF［
`現入力~token$は `function$tok である
］
⇒
~RET `関数式を消費$した結果
◎
Otherwise, if the current input token is a &lt;function-token&gt;, consume a function and return it.
</li>
	<li>
~RET `現入力~token$
◎
Otherwise, return the current input token.
</li>
</ol>

			</section>
			<section id="consume-simple-block">
<h4 title="Consume a simple block">5.4.7. 単純~blockを消費する</h4>

<p class="note">注記：
この~algoは、［
`現入力~token$は次のいずれかである
］と見做す
⇒
`open-curly$Tok,
`open-square$Tok,
`open-paren$Tok
◎
Note: This algorithm assumes that the current input token has already been checked to be an &lt;{-token&gt;, &lt;[-token&gt;, or &lt;(-token&gt;.
</p>

<p>
`単純~blockを消費@
するときは：
◎
To consume a simple block:
</p>

<ol>
	<li id="ending-token">
【！ id: 終端 token から移動】
%終端ng~token ~LET `現入力~token$の “鏡像” ~token
（例えば `open-square$Tok なら `close-square$Tok ）
◎
The ending token is the mirror variant of the current input token. (E.g. if it was called with &lt;[-token&gt;, the ending token is &lt;]-token&gt;.)
</li>
	<li>
%~block ~LET 新たな`単純~block$ ( 開き括弧: `現入力~token$ , 値: 新たな`~list$ )
◎
Create a simple block with its associated token set to the current input token and with its value initially set to an empty list.
</li>
	<li>
<p>
`次入力~tokenを繰返し消費する$：
◎
Repeatedly consume the next input token and process it as follows:
</p>

		<dl class="switch">
			<dt>%終端ng~token</dt>
			<dd>
				<ol>
					<li>
~RET %~block
◎
Return the block.
</li>
				</ol>
			</dd>

			<dt>`EOF$tok</dt>
			<dd>
				<ol>
					<li>
`構文解析error$
◎
This is a parse error.＼
</li>
					<li>
~RET %~block
◎
Return the block.
</li>
				</ol>
			</dd>

			<dt>他全部</dt>
			<dd>
				<ol>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
%成分~値 ~LET `成分~値を消費$した結果
◎
Consume a component value and＼
</li>
					<li>
%~block の.値に %成分~値 を付加する
◎
append it to the value of the block.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

<p class="note">注記：
あいにく，~CSSには、［
宣言を包含し得る~block,
有修飾~規則を包含し得る~block
］の間で，構文上の多義性がある。
そのため、規則を取扱うような どの “消費” ~algoも，初期~時には、より汎用な~algoでこれを利用することになる
— より特有な［
`宣言~listを消費$／`規則~listを消費$
］する~algoではなく。
これらの より特有な~algoは、代わりに，文法が適用される時点で呼出される
— ~blockが［
`declaration-list$t, ［
`rule-list$t ／ `stylesheet$t
］］のどちらを包含するかに依存して。
◎
Note: CSS has an unfortunate syntactic ambiguity between blocks that can contain declarations and blocks that can contain qualified rules, so any "consume" algorithms that handle rules will initially use this more generic algorithm rather than the more specific consume a list of declarations or consume a list of rules algorithms. These more specific algorithms are instead invoked when grammars are applied, depending on whether it contains a &lt;declaration-list&gt; or a &lt;rule-list&gt;/&lt;stylesheet&gt;.
</p>

			</section>
			<section id="consume-function">
<h4 title="Consume a function">5.4.8. 関数式を消費する</h4>

<p class="note">注記：
この~algoは、［
`現入力~token$は `function$tok である
］と見做す。
◎
Note: This algorithm assumes that the current input token has already been checked to be a &lt;function-token&gt;.
</p>

<p>
`関数式を消費@
するときは：
◎
To consume a function:
</p>

<ol>
	<li>
%関数 ~LET 新たな`関数式$ (
名前: `現入力~token$の.値 ,
値: 新たな`~list$
)
◎
Create a function with its name equal to the value of the current input token and with its value initially set to an empty list.
</li>
	<li>
<p>
`次入力~tokenを繰返し消費する$：
◎
Repeatedly consume the next input token and process it as follows:
</p>

		<dl class="switch">
			<dt>`close-paren$Tok</dt>
			<dd>
				<ol>
					<li>
~RET %関数
◎
Return the function.
</li>
				</ol>
			</dd>

			<dt>`EOF$tok</dt>
			<dd>
				<ol>
					<li>
`構文解析error$
◎
This is a parse error.＼
</li>
					<li>
~RET %関数
◎
Return the function.
</li>
				</ol>
			</dd>

			<dt>他全部</dt>
			<dd>
				<ol>
					<li>
`現入力~tokenを消費し直す$
◎
Reconsume the current input token.＼
</li>
					<li>
`成分~値を消費$して、その結果を %関数 の.値に付加する
◎
Consume a component value and append the returned value to the function’s value.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

			</section>
		</section>
	</section>
	<section id="anb-microsyntax">
<h2 title="The An+B microsyntax">6. ~AnB 小構文</h2>

<p>
~CSSにおける一部の~~構成子
— `nth-child()$ps 疑似類など —
は、その対象になる~list内の~~位置を指示する~indexを必要とする。
~AnB 小構文は，~list内の［
単独の要素や, 一定周期に~~位置する要素~すべて
］を作者が指示し易くするために有用になる。
◎
Several things in CSS, such as the :nth-child() pseudoclass, need to indicate indexes in a list. The An+B microsyntax is useful for this, allowing an author to easily indicate single elements or all elements at regularly-spaced intervals in a list.
</p>

<p>
`~AnB@
記法は、整数［
%A, %B
］で，順に［
`周期@,
`~offset@
］定義する。
それは、負でない あらゆる整数 %n に対する［
~list内の
【！ ~AnB】
( %A × %n + %B )
個目の要素
］を表現する。
ここで，~list内の最初の要素の~indexは（ 0 でなく） 1 とする。
◎
The An+B notation defines an integer step (A) and offset (B), and represents the An+Bth elements in a list, for every positive integer or zero value of n, with the first element in the list having index 1 (not 0).
</p>

<p>
%A , %B とも正な場合、これは実質的に，~listを先頭から順に %A 個ずつの要素~groupに分割した上で（最後の~groupは余りの部分になる），各~groupから %B 個目の要素を選択する。
◎
For values of A and B greater than 0, this effectively divides the list into groups of A elements (the last group taking the remainder), and selecting the Bth element of each group.
</p>

<p>
~AnB 記法は、~keyword［
`even^v ／ `odd^v
］も受容し，［
`2n^v ／ `2n+1^v
］と同じ意味になる。
◎
The An+B notation also accepts the even and odd keywords, which have the same meaning as 2n and 2n+1, respectively.
</p>

<div class="example">
<p>◎ Example:</p>

<pre class="lang-css">
2n+0   /* <span class="comment">
~list内の偶数個目の要素すべてを表現する
◎
represents all of the even elements in the list
</span> */
even   /* <span class="comment">
同じ
◎
same
</span> */
4n+1   /* <span class="comment">
~list内の［ 1, 5, 9, 13, …］個目の要素すべてを表現する
◎
represents the 1st, 5th, 9th, 13th, etc. elements in the list
</span> */
</pre>

</div>

<p>
%A, %B いずれも負になり得るが，いずれにせよ［
%n ~GT 0 に対する正な
( %A × %n + %B )
］のみが利用される。
◎
The values of A and B can be negative, but only the positive results of An+B, for n ≥ 0, are used.
</p>

<div class="example">
<p>◎ Example:</p>

<pre class="lang-css">
-1n+6   /* <span class="comment">
~list内の最初から 6 個までの要素を表現する
◎
represents the first 6 elements of the list
</span> */
-4n+10  /* <span class="comment">
~list内の 2, 6, 10 個目の要素を表現する
◎
represents the 2nd, 6th, and 10th elements of the list
</span> */
</pre>

</div>

<p>
%A, %B いずれも 0 の場合、それを用いる疑似類は，~list内のどの要素も表現しない。
◎
If both A and B are 0, the pseudo-class represents no element in the list.
</p>

		<section id="anb-syntax">
<h3 title="Informal Syntax Description">6.1. 非正式な構文（参考）</h3>

~INFORMATIVE

<p>
%A が 0 のときは、 ~An 部分が省略されてもヨイ（ %B 部分がすでに省略されていない限り）。
~An が省略されている場合、負でない %B の前の `+^c 符号も省略されてヨイ【！ (when allowed) ？】
— この場合の構文は，単に %B に単純~化される。
◎
When A is 0, the An part may be omitted (unless the B part is already omitted). When An is not included and B is non-negative, the + sign before B (when allowed) may also be omitted. In this case the syntax simplifies to just B.
</p>

<div class="example">
<p>◎ Example:</p>

<pre class="lang-css">
0n+5   /* <span class="comment">
~list内の 5 個目の要素を表現する
◎
represents the 5th element in the list
</span> */
5      /* <span class="comment">
同じ
◎
same
</span> */
</pre>

</div>

<p>
%A が ±1 の場合の `1^c は規則から省略されてもヨイ。
◎
When A is 1 or -1, the 1 may be omitted from the rule.
</p>

<div class="example">
<p>◎ Example:</p>

<p>
したがって次の記法は，どれも等価になる：
◎
The following notations are therefore equivalent:
</p>

<pre class="lang-css">
1n+0   /* <span class="comment">
~list内のすべての要素を表現する
◎
represents all elements in the list
</span> */
n+0    /* <span class="comment">
同じ
◎
same
</span> */
n      /* <span class="comment">
同じ
◎
same
</span> */
</pre>

</div>

<p>
%B が 0 の場合、毎 %A 個目の要素が選ばれる。
このような場合、（ %A 部分がすでに省略されていない限り，）
正負符号と %B の部分は省略されてもヨイ。
◎
If B is 0, then every Ath element is picked. In such a case, the +B (or -B) part may be omitted unless the A part is already omitted.
</p>

<div class="example">
<p>◎ Example:</p>

<pre class="lang-css">
2n+0   /* <span class="comment">
~list内の毎~偶数個目の要素を表現する
◎
represents every even element in the list
</span> */
2n     /* <span class="comment">
同じ
◎
same
</span> */
</pre>

</div>

<p>
B が負である場合、正符号は負符号に置換する。
◎
When B is negative, its minus sign replaces the + sign.
</p>

<div class="example">
<p>
妥当な例：
◎
Valid example:
</p>

<pre class="lang-css">3n-6</pre>

<p>
妥当でない例：
◎
Invalid example:
</p>

<p>
<pre class="lang-css">3n + -6</pre>

</div>

<p>
~An, %B 両者とも在るときは、それらを分離する正負符号の前後には，空白も許可される。
◎
Whitespace is permitted on either side of the + or - that separates the An and B parts when both are present.
</p>

<div class="example">
<p>
空白を伴う妥当な例：
◎
Valid Examples with white space:
</p>

<pre class="lang-css">
3n + 1
+3n - 2
-n+ 6
+6
</pre>

		<p>
空白を伴う無効な例：
◎
Invalid Examples with white space:
</p>

<pre class="lang-css">
3 n
+ 2n
+ 2
</pre>

</div>

		</section>
		<section id="the-anb-type">
<h3 title="The &lt;an+b&gt; type">6.2. ~anb 型</h3>

<p>
~AnB 記法は、元々は，~CSSの他のものと少しばかり異なる~tokenizerを利用して定義されており、その結果，~CSS~tokenの用語で表出する際に，いくぶん不規則な定義になる。
この節では、~CSS~tokenの用語を通して ~AnB 記法を認識する方法（従って， ~CSS文法~目的の ~anb 型を定義することになる），および［ %A, %B ］に対する値を得するために，これらの~CSS~tokenを解釈する方法を述べる。
◎
The An+B notation was originally defined using a slightly different tokenizer than the rest of CSS, resulting in a somewhat odd definition when expressed in terms of CSS tokens. This section describes how to recognize the An+B notation in terms of CSS tokens (thus defining the &lt;an+b&gt; type for CSS grammar purposes), and how to interpret the CSS tokens to obtain values for A and B.
</p>

<p>
~anb 型は（ `CSS-VALUES$r 仕様の`値~定義~構文$を利用して）次のように定義される：
◎
The &lt;an+b&gt; type is defined (using the Value Definition Syntax in the Values &amp; Units spec) as:
</p>

<pre class="prod">
`~anb@
  = odd
  | even
  | `integer$t

  | `n-dimension$t
  | '+'?~nB n
  | -n

  | `ndashdigit-dimension$t
  | '+'?~nB `ndashdigit-ident$t
  | `dashndashdigit-ident$t

  | `n-dimension$t `signed-integer$t
  | '+'?~nB n `signed-integer$t
  | -n `signed-integer$t

  | `ndash-dimension$t `signless-integer$t
  | '+'?~nB n- `signless-integer$t
  | -n- `signless-integer$t

  | `n-dimension$t ['+' | '-'] `signless-integer$t
  | '+'?~nB n ['+' | '-'] `signless-integer$t【！ ＊原文 | 欠落】
  | -n ['+' | '-'] `signless-integer$t
</pre>

<p>
上に現れ, 下の表の 1 列目に記される各種~生成規則は、［
同じ行の 2 列目の~token
］であって, その各種~~属性が［
同じ行の 3 列目に記された条件
］を満たすものである：
◎
where:
</p>

<div >
<table>

<thead><tr><th>生成規則
<th>~token
<th>~tokenの~~属性が満たす条件
</thead>

<tbody><tr><td>`n-dimension@t
<td>`dimension$tok
<td>
［
.型~flag ~EQ `整数^i
］~AND［
.単位 ~EQ`大小無視$sub `n^l
］

<tr><td>`ndash-dimension@t
<td>`dimension$tok
<td>
［
.型~flag ~EQ `整数^i
］~AND［
.単位 ~EQ`大小無視$sub `n-^l
］

<tr><td>`ndashdigit-dimension@t
<td>`dimension$tok
<td>
［
.型~flag ~EQ `整数^i
］~AND［
.単位 ~EQ`大小無視$sub "`n-^c`数字~列$"
］

<tr><td>`ndashdigit-ident@t
<td>`ident$tok
<td>
.値 ~EQ`大小無視$sub "`n-^c`数字~列$"

<tr><td>`dashndashdigit-ident@t
<td>`ident$tok
<td>
.値 ~EQ`大小無視$sub "`-n-^c`数字~列$"

<tr><td>`integer@t
<td>`number$tok
<td>
.型~flag ~EQ `整数^i

<tr><td>`signed-integer@t
<td>`number$tok
<td>
［
.型~flag ~EQ `整数^i
］~AND［
`表現$の先頭 ~IN `正負符号$
］

<tr><td>`signless-integer@t
<td>`number$tok
<td>
［
.型~flag ~EQ `整数^i
］~AND［
`表現$の先頭 ~IN `数字$
］

</tbody></table>

◎
&lt;n-dimension&gt; is a &lt;dimension-token&gt; with its type flag set to "integer", and a unit that is an ASCII case-insensitive match for "n"
◎
&lt;ndash-dimension&gt; is a &lt;dimension-token&gt; with its type flag set to "integer", and a unit that is an ASCII case-insensitive match for "n-"
◎
&lt;ndashdigit-dimension&gt; is a &lt;dimension-token&gt; with its type flag set to "integer", and a unit that is an ASCII case-insensitive match for "n-*", where "*" is a series of one or more digits
◎
&lt;ndashdigit-ident&gt; is an &lt;ident-token&gt; whose value is an ASCII case-insensitive match for "n-*", where "*" is a series of one or more digits
◎
&lt;dashndashdigit-ident&gt; is an &lt;ident-token&gt; whose value is an ASCII case-insensitive match for "-n-*", where "*" is a series of one or more digits
◎
&lt;integer&gt; is a &lt;number-token&gt; with its type flag set to "integer"
◎
&lt;signed-integer&gt; is a &lt;number-token&gt; with its type flag set to "integer", and whose representation starts with "+" or "-"
◎
&lt;signless-integer&gt; is a &lt;number-token&gt; with its type flag set to "integer", and whose representation starts with a digit
</div>

<p>
表の中の
`数字~列@
は、`数字$のみからなる，長さ 1 以上の任意の~~連なりを表す。
</p>

<p id="anb-plus">
上の ~DAGGER 印が付与されている所のように，［
正符号 (`+^c)
］が［
`n^l から開始している `ident^tok
］に先行するときは，その 2 個の~tokenの合間に空白が在ってはナラナイ。
さもなければ，それらの~tokenは上の文法に合致しないとする。
他の~tokenの合間の空白は妥当である（無視される）。
◎
†: When a plus sign (+) precedes an ident starting with "n", as in the cases marked above, there must be no whitespace between the two tokens, or else the tokens do not match the above grammar. Whitespace is valid (and ignored) between any other two tokens.
</p>

<p>
各~選択肢の~生成規則（~top-levelの "|" で~~分割された各~項）は、次に従って解釈される：
◎
The clauses of the production are interpreted as follows:
</p>

<div style="overflow:auto;"><table id="_anb-def">

<thead><tr><th>生成規則
<th>%A の値
<th>%B の値
</thead>

<tbody><tr><td><span class="prod">`odd^v</span>
<td>2
<td>1

<tr><td><span class="prod">`even^v</span>
<td>2
<td>0

<tr><td><span class="prod">`integer$t</span>
<td>0
<td>`integer$t の.数値

<tr><td><span class="prod">`n-dimension$t</span>
<td>`n-dimension$t の.数値
<td>0

<tr><td><span class="prod">'`+^c'? `n^c</span>
<td>1
<td>0

<tr><td><span class="prod">`-n^c</span>
<td>−1
<td>0

<tr><td><span class="prod">`ndashdigit-dimension$t</span>
<td>`ndashdigit-dimension$t の.数値
<td>［
`ndashdigit-dimension$t の.単位から，最初の`符号位置$を除去した残りの部分
］を 10 進~数として解釈した結果
<span class="note">— 負になる</span>

<tr><td><span class="prod">'`+^c'? `ndashdigit-ident$t</span>
<td>1
<td>［
`ndashdigit-ident$t の.値から，最初の`符号位置$を除去した残りの部分
］を 10 進~数として解釈した結果
<span class="note">— 負になる</span>

<tr><td><span class="prod">`dashndashdigit-ident$t</span>
<td>−1
<td>［
`dashndashdigit-ident$t の.値から最初の 2 個の`符号位置$を除去した残りの部分
］を 10 進~数として解釈した結果
<span class="note">— 負になる</span>

<tr><td><span class="prod">`n-dimension$t `signed-integer$t</span>
<td>`n-dimension$t の.数値
<td>`signed-integer$t の.数値

<tr><td><span class="prod">'`+^c'? `n^c `signed-integer$t</span>
<td>1
<td>(同上)

<tr><td><span class="prod">`-n^c `signed-integer$t</span>
<td>−1
<td>(同上)

<tr><td><span class="prod">`ndash-dimension$t `signless-integer$t</span>
<td>`n-dimension$t の.数値
<td>−1 ×［ `signless-integer$t の.数値 ］

<tr><td><span class="prod">'`+^c'? `n-^c `signless-integer$t</span>
<td>1
<td>(同上)

<tr><td><span class="prod">`-n-^c `signless-integer$t</span>
<td>−1
<td>(同上)

<tr><td><span class="prod">`n-dimension$t ['`+^c' | '`-^c'] `signless-integer$t</span>
<td>`n-dimension$t の.数値
<td>%sign × ［
`signless-integer$t の.数値
］
— ここで %sign は、
['`+^c' | '`-^c'] が［
'`+^c' ならば 1 ／ '`-^c' ならば −1
］

<tr><td><span class="prod">'`+^c'? `n^c ['`+^c' | '`-^c'] `signless-integer$t</span>
<td>1
<td>(同上)

<tr><td><span class="prod">`-n^c ['`+^c' | '`-^c'] `signless-integer$t</span>
<td>−1
<td>(同上)
</tbody>

</table>

<dl lang="en">
	<dt>odd</dt>
	<dd>A is 2, B is 1.</dd>

	<dt>even</dt>
	<dd>A is 2, B is 0.</dd>

	<dt>&lt;integer&gt;</dt>
	<dd>A is 0, B is the integer’s value.</dd>

	<dt>&lt;n-dimension&gt;</dt>
	<dt>'+'? n</dt>
	<dt>-n</dt>
	<dd>A is the dimension’s value, 1, or -1, respectively. B is 0.</dd>

	<dt>&lt;ndashdigit-dimension&gt;</dt>
	<dt>'+'? &lt;ndashdigit-ident&gt;</dt>
	<dd>
A is the dimension’s value or 1, respectively. B is the dimension’s unit or ident’s value, respectively, with the first code point removed and the remainder interpreted as a base-10 number. B is negative.
</dd>

	<dt>&lt;dashndashdigit-ident&gt;</dt>
	<dd>
A is -1. B is the ident’s value, with the first two code points removed and the remainder interpreted as a base-10 number. B is negative.
</dd>

	<dt>&lt;n-dimension&gt; &lt;signed-integer&gt;</dt>
	<dt>'+'? n &lt;signed-integer&gt;</dt>
	<dt>-n &lt;signed-integer&gt;</dt>
	<dd>
A is the dimension’s value, 1, or -1, respectively. B is the integer’s value.
</dd>

	<dt>&lt;ndash-dimension&gt; &lt;signless-integer&gt;</dt>
	<dt>'+'? n- &lt;signless-integer&gt;</dt>
	<dt>-n- &lt;signless-integer&gt;</dt>
	<dd>
A is the dimension’s value, 1, or -1, respectively. B is the negation of the integer’s value.
</dd>

	<dt>&lt;n-dimension&gt; ['+' | '-'] &lt;signless-integer&gt;</dt>
	<dt>'+'? n ['+' | '-'] &lt;signless-integer&gt;</dt>
	<dt>-n ['+' | '-'] &lt;signless-integer&gt;</dt>
	<dd>
A is the dimension’s value, 1, or -1, respectively. B is the integer’s value. If a '-' was provided between the two, B is instead the negation of the integer’s value.
</dd>
</dl>

</div>

		</section>
	</section>
	<section id="urange">
<h2 title="The Unicode-Range microsyntax">7. ~unicode-range小構文</h2>

<p>
`font-face$at 規則~用の `unicode-range$d 記述子など，一部の構成子は、 ~Unicode符号位置の~~集合を記述する仕方を必要とする。
`urange$t 生成規則が， 1 個以上の~Unicode符号位置からなる範囲を表現する。
◎
Some constructs, such as the unicode-range descriptor for the @font-face rule, need a way to describe one or more unicode code points. The &lt;urange&gt; production represents a range of one or more unicode code points.
</p>

<p>
`urange$t 生成規則は、非正式には，次の 3 種の形をとり得る：
◎
Informally, the &lt;urange&gt; production has three forms:
</p>

<dl>
	<dt>`U+0001^v</dt>
	<dd>
1 個の符号位置からなる範囲を定義する。
この事例では、符号位置 0x1 。
◎
Defines a range consisting of a single code point, in this case the code point "1".
</dd>

	<dt>`U+0001-00ff^v</dt>
	<dd>
最初の値から最後の値までの符号位置からなる範囲を定義する。
この事例では、 0x1 〜 0xFF の範囲（ 10 進数 1 〜 255 ）になる。
◎
Defines a range of codepoints between the first and the second value inclusive, in this case the range between "1" and "ff" (255 in decimal) inclusive.
</dd>

	<dt>`U+00??^v</dt>
	<dd>
文字 `?^l がすべての`~hex$に渡るような，符号位置の範囲を定義する。
この事例では、値 `U+0000-00ff^v のときと同じ範囲を定義する。
◎
Defines a range of codepoints where the "?" characters range over all hex digits, in this case defining the same as the value U+0000-00ff.
</dd>
</dl>

<p>
いずれの形でも，（ `?^v も~hexと扱う下で）最大 6 桁までの 16 進数が許容される。
◎
In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
</p>

		<section id="urange-syntax">
<h3 title="The &lt;urange&gt; type">7.1. `urange^t 型</h3>

<p>
`urange$t 記法は 元々，~CSSでは~primitive~tokenとして定義されていたが、ごく稀にしか利用されず，合法的な `ident$tok と衝突して混同され易い。
この節では、 `urange$t 記法を［
既存の~CSS~tokenを通して認識する, および
~Unicode符号位置の範囲として解釈する
］ための方法を述べる。
◎
The &lt;urange&gt; notation was originally defined as a primitive token in CSS, but it is used very rarely, and collides with legitimate &lt;ident-token&gt;s in confusing ways. This section describes how to recognize the &lt;urange&gt; notation in terms of existing CSS tokens, and how to interpret it as a range of unicode codepoints.
</p>

<details class="note">
<summary>
何が衝突して混同され易いのか？
◎
What are the confusing collisions?
</summary>

<p>
例えば、~CSSにおける規則
`u + a { color: green; }^css
に意図される意味は、［
`u^e 要素に後続する `a^e 要素の色は，~greenにされるべきである
］になる。
通常は，結合子を挟んでいる`選択子$の合間に空白は要求されないので、
`u+a{color:green;}^css
のように~minifyしても等価になるべきである：
◎
For example, in the CSS u + a { color: green; } , the intended meaning is that an a element following a u element should be colored green. Whitespace is not normally required between combinators and the surrounding selectors, so it should be equivalent to minify it to
◎
u+a{color:green;}
</p>

<p>
この 2 つの~CSS片は，結合子が他のものであれば等価になるが、前述の特化された~unicode-range~tokenの存在に因り，~minifyされた方の`選択子$の部位は、
2 個の `ident$tok と 1 個の結合子ではなく，~unicode-rangeを包含することになり、~Selectors文法に合致しない結果，規則は無効として~~棄てられることになる。
◎
With any other combinator, the two pieces of CSS would be equivalent, but due to the previous existence of a specialized unicode-range token, the selector portion of the minified code now contains a unicode-range, not two idents and a combinator. It thus fails to match the Selectors grammar, and the rule is thrown out as invalid.
</p>

<p>
（この例は、 Firefox に報告された~~実在の~bugからとられている。）
◎
(This example is taken from a real-world bug reported to Firefox.)
</p>
</details>

<p class="note">注記：
ここに述べる構文は、意図的にごく低~levelであり，実装者~向けである。
作者には、 `urange$t を利用するために必要な情報すべてが含まれた，前節の構文の記述で十分である。
◎
Note: The syntax described here is intentionally very low-level, and geared toward implementors. Authors should instead read the informal syntax description in the previous section, as it contains all information necessary to use &lt;urange&gt;, and is actually readable.
</p>

<p>
`urange$t 型は（ `CSS-VALUES$r 仕様の`値~定義~構文$を利用して），次で定義される。
◎
The &lt;urange&gt; type is defined (using the Value Definition Syntax in the Values &amp; Units spec) as:
</p>

<pre class="prod">
`urange@t
  = u '+' `ident$tok '?'*
  | u `dimension$tok '?'*
  | u `number$tok '?'*
  | u `number$tok `dimension$tok
  | u `number$tok `number$tok
  | u '+' '?'+
</pre>

<p>
この生成規則では、どの2つの~tokenの間にも空白は生じ得ない。
◎
In this production, no whitespace can occur between any of the tokens.
</p>

<p>
`urange$t 生成規則は、連続的な~Unicode符号位置の範囲 { %始値 〜 %終値 } を表現する。
◎
The &lt;urange&gt; production represents a range of one or more contiguous unicode code points as a start value and an end value, which are non-negative integers.＼
</p>

<div class="algo">
<p>
`urange$t 生成規則を範囲に解釈するときは、次を実行する：
◎
To interpret the production above into a range, execute the following steps in order:
</p>

<ol>
	<li>
%text ~LET 生成規則~内の［
最初の `u^c ~tokenを除くすべての~token
］の`表現$を連結した結果
◎
Skipping the first u token, concatenate the representations of all the tokens in the production together. Let this be text.
</li>
	<li>
~IF［
%text の最初の`符号位置$を消費した結果 ~NEQ `2B^U
］
⇒
~RET 無効（すなわち， `urange$t は無効である — 以下~同様）
◎
If the first character of text is U+002B PLUS SIGN, consume it. Otherwise, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>
	<li>
%N ~LET
%text から，アリな限り多くの`~hex$を消費してから，アリな限り多くの`符号位置$ `3F^U を消費した結果
◎
Consume as many hex digits from text as possible. then consume as many U+003F QUESTION MARK (?) code points as possible.＼
</li>
	<li>
~IF［
%N の長さ ~EQ 0
］~OR［
%N の長さ ~GT 6
］
⇒
~RET 無効
◎
If zero code points were consumed, or more than six code points were consumed, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>
	<li>
<p>
~IF［
%N 内に `3F^U `符号位置$がある
］：
◎
If any U+003F QUESTION MARK (?) code points were consumed, then:
</p>
		<ol>
			<li>
~IF［
%text は消費され尽くされてない
］
⇒
~RET 無効
◎
If there are any code points left in text, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>
			<li>
%始値 ~SET ［
%N 内の各 `3F^U を `30^U に置換した結果
］を 16 進数として解釈した結果
◎
Interpret the consumed code points as a hexadecimal number, with the U+003F QUESTION MARK (?) code points replaced by U+0030 DIGIT ZERO (0) code points. This is the start value.
</li>
			<li>
%終値 ~SET ［
%N 内の各 `3F^U を `46^U に置換した結果
］を 16 進数として解釈した結果
◎
Interpret the consumed code points as a hexadecimal number again, with the U+003F QUESTION MARK (?) code points replaced by U+0046 LATIN CAPITAL LETTER F (F) code points. This is the end value.
</li>
			<li>
~RET 範囲 { %始値 〜 %終値 }
◎
Exit this algorithm.
</li>
		</ol>
	</li>
	<li>
%始値 ~SET %N を 16 進数として解釈した結果
◎
Otherwise, interpret the consumed code points as a hexadecimal number. This is the start value.
</li>
	<li>
~IF［
%text は消費され尽くした
］
⇒
~RET 範囲 { %始値 〜 %始値 }
◎
If there are no code points left in text, The end value is the same as the start value. Exit this algorithm.
</li>
	<li>
~IF［
%text の次の`符号位置$を消費した結果 ~NEQ `2D^U
］
⇒
~RET 無効
◎
If the next code point in text is U+002D HYPHEN-MINUS (-), consume it. Otherwise, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>
	<li>
%N ~LET
%text から，アリな限り多くの`~hex$を消費した結果
◎
Consume as many hex digits as possible from text.
</li>
	<li>
~IF［
%N の長さ ~EQ 0
］~OR［
%N の長さ ~GT 6
］~OR［
%text は消費され尽くされてない
］
⇒
~RET 無効
◎
If zero hex digits were consumed, or more than 6 hex digits were consumed, this is an invalid &lt;urange&gt;, and this algorithm must exit. If there are any code points left in text, this is an invalid &lt;urange&gt;, and this algorithm must exit.
</li>
	<li>
%終値 ~SET %N を 16 進数として解釈した結果
◎
Interpret the consumed code points as a hexadecimal number. This is the end value.
</li>
	<li>
~IF［
%終値 ~GT `許容される最大な符号位置$
］~OR［
%始値 ~GT %終値
］
⇒
~RET `失敗^i
— `urange$t は、<strong>無効であり，構文~error</strong>になる。
◎
To determine what codepoints the &lt;urange&gt; represents:
◎
If end value is greater than the maximum allowed code point, the &lt;urange&gt; is invalid and a syntax error.
◎
If start value is greater than end value, the &lt;urange&gt; is invalid and a syntax error.
◎
Otherwise, the &lt;urange&gt; represents a contiguous range of codepoints from start value to end value, inclusive.
</li>
	<li>
~RET 範囲 { %始値 〜 %終値 }
◎
↑</li>
</ol>
</div>

<p class="note">注記：
`urange$t の構文は、その~patternが，前節の構文（参考）が生成し得るすべての~token並びを捉える以上に，意図的に幅広くしてある。
ただし，各~tokenの合間には空白を挟めないので、実施においては~~相応に安全に利用できる：
ある構成子の文法が［
`urange$t, ［
`number$t ／ `dimension$t
］］並びを含むとしても（作者が `urange$t を［
`u^c, `number$t
］並びで指定した場合に多義的になり得る）、実際にはごく安全である
— 多義的になるためには、作者は，
`urange$t と［
`number$t ／ `dimension$t
］とを，空白ではなく，意図的に~commentで分離する必要があるので。
作者は，構文解析を惑わす仕方でも`書ける^emが、そのためには実際の~code自体も紛らわしく書く必要がある。
◎
Note: The syntax of &lt;urange&gt; is intentionally fairly wide; its patterns capture every possible token sequence that the informal syntax can generate. However, it requires no whitespace between its constituent tokens, which renders it fairly safe to use in practice. Even grammars which have a &lt;urange&gt; followed by a &lt;number&gt; or &lt;dimension&gt; (which might appear to be ambiguous if an author specifies the &lt;urange&gt; with the ''u &lt;number&gt;'' clause) are actually quite safe, as an author would have to intentionally separate the &lt;urange&gt; and the &lt;number&gt;/&lt;dimension&gt; with a comment rather than whitespace for it to be ambiguous. Thus, while it’s possible for authors to write things that are parsed in confusing ways, the actual code they’d have to write to cause the confusion is, itself, confusing and rare.
</p>

		</section>
	</section>
	<section id="rule-defs">
<h2 title="Defining Grammars for Rules and Other Values">8. 規則や他の値~用の文法の定義-法</h2>

<p>
`CSS-VALUES$r 仕様では、~prop用の文法を指定する方法が定義されている。
この節は、同じ文法を，~CSS規則~用に定義する。
◎
The Values spec defines how to specify a grammar for properties. This section does the same, but for rules.
</p>

<p>
~prop文法とちょうど同じく，記法 `foo^t は、文法記号 "%foo" を参照rする
— それが，他で定義されていると見做して。
`foo^t をその定義で代用した結果は、意味論的に一致する文法になる。
◎
Just like in property grammars, the notation &lt;foo&gt; refers to the "foo" grammar term, assumed to be defined elsewhere. Substituting the &lt;foo&gt; for its definition results in a semantically identical grammar.
</p>

<p>
~tokenの型のうちの いくつかは、引用符で括られずに，~literalとして記される：
◎
Several types of tokens are written literally, without quotes:
</p>

<ul>
	<li>
`ident$tok （
`auto^v,
`disc^v,
等々）
は，単純にそれらの.値で記される。
◎
&lt;ident-token&gt;s (such as auto, disc, etc), which are simply written as their value.
</li>
	<li>
`at-keyword$tok は，［
文字  "<code>@</code>",
~tokenの.値
］並びとして記される。
例えば `media^at 。
◎
&lt;at-keyword-token&gt;s, which are written as an @ character followed by the token’s value, like @media.
</li>
	<li>
`function$tok は、［
関数~名【！？】,
文字 `(^l
］並びとして記される
— 例えば `translate(^c
◎
&lt;function-token&gt;s, which are written as the function name followed by a ( character, like translate(.
</li>
	<li>
`colon$tok （ `:^l と記される ）,
`comma$tok （ `,^l と記される ）,
`semicolon$tok （ `;^l と記される ）,
`open-paren$Tok,
`close-paren$Tok,
`open-curly$Tok,
`close-curly$Tok
◎
The &lt;colon-token&gt; (written as :), &lt;comma-token&gt; (written as ,), &lt;semicolon-token&gt; (written as ;), &lt;(-token&gt;, &lt;)-token&gt;, &lt;{-token&gt;, and &lt;}-token&gt;s.
</li>
</ul>

<p>
~tokenは、その値~DAGGERが文法に定義される値に
— 他が指定されない限り，`~ASCII大小無視$で —
合致するとき，合致するとされる。
◎
Tokens match if their value is a match for the value defined in the grammar. Unless otherwise specified, all matches are ASCII case-insensitive.
</p>

<p class="trans-note">【
~DAGGER “~tokenの値” — 明文化されていないが、~tokenが［
（~~属性として）.値を持つ場合は その.値 ／
持たない場合は その~tokenを表現する文字列
］を意味するものと思われる。
】</p>

<p class="note">注記：
`~escape法$により，.値が［
`(^l で終端する ／
"<code>@</code>" で開始する
］ような `ident$tok を構築することもアリだが、その種の~tokenは，［
`function$tok ／ `at-keyword$tok
］ではなく, 対応する文法~定義には合致しない。
◎
Note: Although it is possible, with escaping, to construct an &lt;ident-token&gt; whose value ends with ( or starts with @, such a tokens is not a &lt;function-token&gt; or an &lt;at-keyword-token&gt; and does not match corresponding grammar definitions.
</p>

<p>
`delim$tok は、その.値を一重引用符で括って記される。
例えば，［
.値に `符号位置$ "+" を伴う `delim$tok
］は、
`'+'^c
のように記される。
同様に、［
`open-square$Tok や `close-square$Tok
］も，一重引用符で括って記されなければナラナイ。
それらの.値は、項たちを~group化するために，文法それ自身の構文にて利用されるので。
`whitespace$tok は、文法の中では決して指示されず，［
~tokenの前後, および 2 個の~tokenの合間
］に許容される
— ただし，定義の注釈文から明示的に指定される場合を除く（例えば，規則の.導入部が`選択子$である場合，空白は有意になる）
◎
&lt;delim-token&gt;s are written with their value enclosed in single quotes. For example, a &lt;delim-token&gt; containing the "+" code point is written as '+'. Similarly, the &lt;[-token&gt; and &lt;]-token&gt;s must be written in single quotes, as they’re used by the syntax of the grammar itself to group clauses. &lt;whitespace-token&gt; is never indicated in the grammar; &lt;whitespace-token&gt;s are allowed before, after, and between any two tokens, unless explicitly specified otherwise in prose definitions. (For example, if the prelude of a rule is a selector, whitespace is significant.)
</p>

<p>
［
関数式／~block
］を定義する際には、その文法において 終端ng~tokenが指定されなければナラナイが、最終的に~token~stream内に無い場合でも，依然として合致する。
◎
When defining a function or a block, the ending token must be specified in the grammar, but if it’s not present in the eventual token stream, it still matches.
</p>

<div class="example">
<p>
例えば，関数式 `translateX$f の構文は：
◎
For example, the syntax of the translateX() function is:
</p>

<pre class="prod">
translateX( `length-percentage^t )【！ ＊修正 translation-value】
</pre>

<p>
しかしながら，~stylesheetは、この関数式が閉じられないまま終端されてもよい
— 次の様に：
◎
However, the stylesheet may end with the function unclosed, like:
</p>

<pre class="lang-css">
.foo { transform: translateX(50px
</pre>

<p>
~CSS構文解析器は，これを［［［［
`関数式$であって，その.名前は `translateX^l であるもの
］のみからなる`成分~値$~list
］を.値にとる， 1 個の`宣言$
］を包含している~style規則
］として構文解析する。
これは、終端ng~tokenが~token~streamの中に出現しなくても，上の文法には合致するものとされる。
構文解析器を抜けた時点で，終端ng~tokenの有無は決定し得なくなり、~blockと関数式があるという事実のみが残るので。
◎
The CSS parser parses this as a style rule containing one declaration, whose value is a function named "translate". This matches the above grammar, even though the ending token didn’t appear in the token stream, because by the time the parser is finished, the presence of the ending token is no longer possible to determine; all you have is the fact that there’s a block and a function.
</p>

</div>

		<section id="declaration-rule-list">
<h3 title="Defining Block Contents: the &lt;declaration-list&gt;, &lt;rule-list&gt;, and &lt;stylesheet&gt; productions">8.1. ~block内容を定義する生成規則： `declaration-list^t, `rule-list^t, `stylesheet^t</h3>

<p>
~CSS構文解析器は、~blockの内容を問わない —
例えば何らかの~at-ruleの終端に来るものなど。
~blockの汎用~文法を~tokenの用語を通して定義することは，自明でないが、それを構文解析するために定義される，一義的な専用の~algoが用意されている：
◎
The CSS parser is agnostic as to the contents of blocks, such as those that come at the end of some at-rules. Defining the generic grammar of the blocks in terms of tokens is non-trivial, but there are dedicated and unambiguous algorithms defined for parsing this.
</p>

<p>
`declaration-list@t
生成規則は、宣言~listを表現する。
文法において それを利用し得るのは、［
~blockの全体を占める値
］としてに限られる。
それは、［
~blockの内容は、`宣言~listを消費$する~algoを利用して構文解析されるモノトスル
］ことを表現する。
◎
The &lt;declaration-list&gt; production represents a list of declarations. It may only be used in grammars as the sole value in a block, and represents that the contents of the block must be parsed using the consume a list of declarations algorithm.
</p>

<p>
同様に，
`rule-list@t
生成規則は、規則~listを表現する。
文法において それを利用し得るのは、［
~blockの全体を占める値
］としてに限られる。
それは、［
~blockの内容は、`規則~listを消費$する~algoを利用して構文解析されるモノトスル
］ことを表現する。
◎
Similarly, the &lt;rule-list&gt; production represents a list of rules, and may only be used in grammars as the sole value in a block. It represents that the contents of the block must be parsed using the consume a list of rules algorithm.
</p>

<p>
最後に，
`stylesheet@t
生成規則は、規則~listを表現する。
それは、それを利用している~blockが［
特定0の文脈に制限されるようなものを除く，すべての規則
］を既定で受容することを除いて、 `rule-list$t と一致する。
◎
Finally, the &lt;stylesheet&gt; production represents a list of rules. It is identical to &lt;rule-list&gt;, except that blocks using it default to accepting all rules that aren’t otherwise limited to a particular context.
</p>

<div class="example">
<p>
例えば， `font-face$at 規則は、［
その.導入部が空であって,
宣言~listを包含する
］ものと定義されている。
これは、次の文法で表出される：
◎
For example, the @font-face rule is defined to have an empty prelude, and to contain a list of declarations. This is expressed with the following grammar:
</p>

<pre class="prod">
@font-face { `declaration-list$t }
</pre>

<p>
これは、規則の文法として，完全かつ十分な定義である。
◎
This is a complete and sufficient definition of the rule’s grammar.
</p>

<p>
別の例として， `keyframes$at 規則は、その［
.導入部に
【~animationの】
名前が伴われていて,
その.~block内には 一連の~keyframe規則が包含されている
］ものと解釈される点で，より複階的である。
その文法は、次で与えられる：
◎
For another example, @keyframes rules are more complex, interpreting their prelude as a name and containing keyframes rules in their block Their grammar is:
</p>

<pre class="prod">
@keyframes `keyframes-name$t { `rule-list$t }
</pre>

</div>

<p>
`declaration-list$t を利用する規則に対しては、その規則を定める仕様は，規則の内側において どの［
~prop ／記述子／~at-rule
］が妥当であるかを定義しなければナラナイ
— これは，単純に、
“`foo^at 規則 は，この仕様（または節）が定義する ~propと記述子 を受容する”
といった風に、あるいは，拡張~仕様は，
“`foo^at 規則は，以下の~prop／記述子を追加的に受容する”
といった風に述べ得る。
規則の.~blockの内側にて見出された，妥当なものとして定義されていない［
宣言／~at-rule
］は、その規則の値【当の~blockの.値】から除去するモノトスル。
◎
For rules that use &lt;declaration-list&gt;, the spec for the rule must define which properties, descriptors, and/or at-rules are valid inside the rule; this may be as simple as saying "The @foo rule accepts the properties/descriptors defined in this specification/section.", and extension specs may simply say "The @foo rule additionally accepts the following properties/descriptors.". Any declarations or at-rules found inside the block that are not defined as valid must be removed from the rule’s value.
</p>

<p>
`declaration-list$t 内では、どの記述子においても，その `!important^css は自動的に無効になる。
ある規則が ある~propを受容する場合、その規則を定める仕様は，［
その~propは`~cascade$とヤリトリし得るかどうか,
どの`詳細度$でヤリトリするか
］を定義しなければナラナイ。
`~cascade$とヤリトリしない~propが `!important^css を包含している場合、自動的に無効になる。
他の~propにおける `!important^css は、妥当であり，`~cascade$の目的において当の宣言を`~importantな宣言$にする
— `CSS-CASCADE-3$r を見よ。
◎
Within a &lt;declaration-list&gt;, !important is automatically invalid on any descriptors. If the rule accepts properties, the spec for the rule must define whether the properties interact with the cascade, and with what specificity. If they don’t interact with the cascade, properties containing !important are automatically invalid; otherwise using !important is valid and causes the declaration to be important for the purposes of the cascade. See [CSS-CASCADE-3].
</p>

<p class="example">
例えば，前の例の `font-face$at 用の文法は、そこに記されたものに加えて，［
許容される宣言は， Fonts 仕様にて定義される記述子である
］ものと定義しなければナラナイ。
◎
For example, the grammar for @font-face in the previous example must, in addition to what is written there, define that the allowed declarations are the descriptors defined in the Fonts spec.
</p>

<p>
`rule-list$t を利用する %規則 においても、 `declaration-list$t のときと同じく，その %規則 を定める仕様が，［
どの型の規則が，その %規則 の中で妥当になるか
］を定義しなければナラナイ。
同様に、認識できない規則は，その %規則 の値から除去するモノトスル。
◎
For rules that use &lt;rule-list&gt;, the spec for the rule must define what types of rules are valid inside the rule, same as &lt;declaration-list&gt;, and unrecognized rules must similarly be removed from the rule’s value.
</p>

<div class="example">
<p>
例えば，先の例の `keyframes$at の文法は、そこに記されたものに加えて，許容される規則は［
次で定義される `keyframe-rule^t に限られる
］ことを定義しなければナラナイ：
◎
For example, the grammar for @keyframes in the previous example must, in addition to what is written there, define that the only allowed rules are &lt;keyframe-rule&gt;s, which are defined as:
</p>

<pre class="prod">
`keyframe-rule^t = `keyframe-selector$t { `declaration-list$t }
</pre>

<p>
更に，~keyframe規則（ `keyframe-rule^t ）の~blockが［
~animate可能なすべての~CSS~propを宣言として受容する
］ことに加え, ［
`animation-timing-function$p ~propを受容する
］こと，一方で［
それらは`~cascade$とヤリトリしない
］ことを定義しなければナラナイ。
◎
Keyframe rules, then, must further define that they accept as declarations all animatable CSS properties, plus the animation-timing-function property, but that they do not interact with the cascade.
</p>

</div>

<p>
`stylesheet$t を利用する %規則 においては，すべての規則が既定で許容されるが、その %規則 を定める仕様は，その %規則 の内側では `無効になる^em 規則を定義してもヨイ。
◎
For rules that use &lt;stylesheet&gt;, all rules are allowed by default, but the spec for the rule may define what types of rules are invalid inside the rule.
</p>

<div class="example">
<p>
例えば， `media$at 規則は、 `media^at 規則を除く，~stylesheet内に置き得るものすべてを受容する。
なので，その文法は、次で与えられる：
◎
For example, the @media rule accepts anything that can be placed in a stylesheet, except more @media rules. As such, its grammar is:
</p>

<pre class="prod">
@media `media-query-list$t { `stylesheet$t }
</pre>

<p>
加えて，［
`stylesheet$t は `media$at 規則を包含できない
］とする制約も定義する。
その結果、中に出現する `media^at 規則は，外側の `media^at 規則の値から棄てられることになる。
◎
It additionally defines a restriction that the &lt;stylesheet&gt; can not contain @media rules, which causes them to be dropped from the outer rule’s value if they appear.
</p>

</div>

		</section>
		<section id="any-value">
<h3 title="Defining Arbitrary Contents: the &lt;declaration-value&gt; and &lt;any-value&gt; productions">8.2. 任意の内容を定義するもの： `declaration-value^t, `any-value^t 生成規則</h3>

<p>
文法によっては、任意の適理な入力を受容して，その~errorを手動で取扱う方が有用になる場合もある（単純に，文法への不一致により当の構成子を即 無効にすることなく）。
◎
In some grammars, it is useful to accept any reasonable input in the grammar, and do more specific error-handling on the contents manually (rather than simply invalidating the construct, as grammar mismatches tend to do).
</p>

<p class="example">
例えば，`~custom~prop$は、［
他の~CSS~propがとる値の成分も包含し得る
］ような, あるいは［
既存の~CSSに全く含まれないものに利用される
］ような，任意の適理な値を許容する。
他の例として、 `MEDIAQ$r の `general-enclosed$t 生成規則は、その仕様の将来の構文が許容し得るものを定義して，
“未知な” 値を特別な~logicで処する。
◎
For example, custom properties allow any reasonable value, as they can contain arbitrary pieces of other CSS properties, or be used for things that aren’t part of existing CSS at all. For another example, the &lt;general-enclosed&gt; production in Media Queries defines the bounds of what future syntax MQs will allow, and uses special logic to deal with "unknown" values.
</p>

<p>
これを援助するため、 2 つの追加的な生成規則が定義される：
◎
To aid in this, two additional productions are defined:
</p>

<dl>
	<dt>`declaration-value@t</dt>
	<dd>
<p>
この生成規則は、`どの^em［
1 個以上の~tokenからなる並び
］にも，その並びが次に挙げるものを包含していない限り，合致する：
◎
The &lt;declaration-value&gt;
production matches any sequence of one or more tokens, so long as the sequence does not contain＼
</p>

<div >
<ul><li>`bad-string$tok
</li><li>`bad-url$tok
</li><li>対になっていない［
`close-paren$Tok ／
`close-square$Tok ／
`close-curly$Tok
］
</li><li>~top-levelの `semicolon$tok
</li><li>`!^l を.値にとる `delim$tok
</li></ul>

◎
&lt;bad-string-token&gt;, &lt;bad-url-token&gt;, unmatched &lt;)-token&gt;, &lt;]-token&gt;, or &lt;}-token&gt;, or top-level &lt;semicolon-token&gt; tokens or &lt;delim-token&gt; tokens with a value of "!".＼
</div>
	</dd>
	<dd>
これは、その並び全体として［
妥当な宣言がとり得る値
］を表現する。
◎
It represents the entirety of what a valid declaration can have as its value.
</dd>

	<dt>`any-value@t</dt>
	<dd>
この生成規則は、［
~top-levelの `semicolon$tok ／
`!^l を.値にとる `delim$tok
］も許容されることを除いて， `declaration-value$t と一致する。
◎
The &lt;any-value&gt;
production is identical to &lt;declaration-value&gt;, but also allows top-level &lt;semicolon-token&gt; tokens and &lt;delim-token&gt; tokens with a value of "!".＼
</dd>
	<dd>
これは、それ全体として［
何らかの文脈の下で，妥当な~CSSになり得るもの
］を表現する。
◎
It represents the entirety of what valid CSS can be in any context.
</dd>
</dl>

		</section>
	</section>
	<section id="css-stylesheets">
<h2 title="CSS stylesheets">9. ~CSS~stylesheet</h2>

<div class="algo">
<p>
`~CSS~stylesheetを構文解析する@
ときは、所与の~stylesheet %入力 に対し：
</p>

<ol>
	<li>
%結果 ~LET %入力 から`~stylesheetを構文解析する$
</li>
	<li>
%結果 を成す
~EACH( ~top-levelの`有修飾~規則$ %規則 )
に対し
⇒
%規則 を，以下に定義するように`~style規則$として解釈する
</li>
</ol>
◎
To parse a CSS stylesheet, first parse a stylesheet. Interpret all of the resulting top-level qualified rules as style rules, defined below.
</div>

<p>
［
`無効$な~style規則 ／
認識できない~at-rule ／
その文法あるいは文脈に則って 無効な~at-rule
］は、`構文解析error$であり，破棄される。
◎
If any style rule is invalid, or any at-rule is not recognized or is invalid according to its grammar or context, it’s a parse error. Discard that rule.
</p>

		<section id="style-rules">
<h3 title="Style rules">9.1. ~style規則</h3>

<p>
`~style規則@
は、`選択子~list$と~prop宣言~listとを結付ける，`有修飾~規則$である。
それらは、 `CSS2$r においては，`規則~集合$とも呼ばれている。
~style規則の内側にある宣言が`~cascade$にどう関与するかは、
`CSS-CASCADE-3$r が定義する。
◎
A style rule is a qualified rule that associates a selector list with a list of property declarations. They are also called rule sets in [CSS2]. CSS Cascading and Inheritance [CSS-CASCADE-3] defines how the declarations inside of style rules participate in the cascade.
</p>

<p>
有修飾~規則の.導入部は、 `selector-list$t として`構文解析-$される。
それが `失敗^i を返したならば、その~style規則~全体が`無効$になる。
◎
The prelude of the qualified rule is parsed as a &lt;selector-list&gt;. If this returns failure, the entire style rule is invalid.
</p>

<p>
有修飾~規則の~blockの内容は、`宣言~list$として構文解析される。
別の仕様やこの仕様の将来~levelにて定義されない限り、この~list内の~at-ruleは`無効$であり，無視するモノトスル。
~CSS~propの宣言のうち，［
未知な, あるいは値が~propに定義される構文に合致しない
］ものは、`無効$であり，無視するモノトスル。
~style規則の内容の妥当性は、~style規則~自身の妥当性には~~影響しない。
他から定義されない限り，~prop名は`~ASCII大小無視$である。
◎
The content of the qualified rule’s block is parsed as a list of declarations. Unless defined otherwise by another specification or a future level of this specification, at-rules in that list are invalid and must be ignored. Declaration for an unknown CSS property or whose value does not match the syntax defined by the property are invalid and must be ignored. The validity of the style rule’s contents have no effect on the validity of the style rule itself. Unless otherwise specified, property names are ASCII case-insensitive.
</p>

<p class="note">注記：
`~custom~prop$ `CSS-VARIABLES$r の名前の文字大小は区別される。
◎
Note: The names of Custom Properties [CSS-VARIABLES] are case-sensitive.
</p>

<p>
~CSS~stylesheetの~top-levelの`有修飾~規則$は、~style規則である。
他の文脈における有修飾~規則が~style規則になるかどうかは、その文脈の定義に従う。
◎
Qualified rules at the top-level of a CSS stylesheet are style rules. Qualified rules in other contexts may or may not be style rules, as defined by the context.
</p>

<p class="example">
例えば、［
`media$at 規則 `CSS3-CONDITIONAL$r の内側にある有修飾~規則
］は~style規則であるが，［
`keyframes$at 規則 `CSS3-ANIMATIONS$r の内側にある有修飾~規則
］はそうでない。
◎
For example, qualified rules inside @media rules [CSS3-CONDITIONAL] are style rules, but qualified rules inside @keyframes rules are not [CSS3-ANIMATIONS].
</p>

		</section>
		<section id="at-rules">
<h3 title="At-rules">9.2. ~at-rule</h3>

<p>
`~at-rule@1
（ `~at-rule$ ）
は、 `at-keyword$tok 【！at-keyword】から始まる規則であり、したがって，同じ文脈~内の`~style規則$と判別できる。
◎
An at-rule is a rule that begins with an at-keyword, and can thus be distinguished from style rules in the same context.
</p>

<p>
`~at-rule$1は、次のために利用される：
◎
At-rules are used to:
</p>
<ul>
	<li>
~style規則や他の~at-rule
— `条件付き~group規則$内にあるものなど —
を~group化したり構造~化する。
◎
group and structure style rules and other at-rules such as in conditional rules
</li>
	<li>
特定0の要素には結付けられない~style情報を宣言する
— `~counter~style$を定義するなど。
◎
declare style information that is not associated with a particular element, such as defining counter styles
</li>
	<li>
構文-構成子を管理する
— 
`imports and namespace keyword mappings^en
【！~DOM4#concept-attribute-namespace】
【 `import$at 規則や, `namespace$at 規則による名前空間~接頭辞の対応付け？】
など
◎
manage syntactic constructs such as imports and namespace keyword mappings
</li>
	<li>
`~style規則$が~serveしない，他の諸々の目的を~serveする。
◎
and serve other miscellaneous purposes not served by a style rule
</li>
</ul>

<p>
~at-ruleは、自身に特有な規則と目的に依存して多くの形をとり得るが，
`文t~at-rule@
,
`~block~at-rule@
の 2 種類に大別される。
前者は、後者より単純な，~semicolonで終端する構成子である。
後者は、`波括弧~block$で終端し，入子な［
規則／`宣言$
］を包含できる。
◎
At-rules take many forms, depending on the specific rule and its purpose, but broadly speaking there are two kinds:＼
statement at-rules which are simpler constructs that end in a semicolon,＼
and block at-rules which end in a {}-block that can contain nested rules or declarations.
<p>

<p>
`~block~at-rule$は、概して，（当の`~at-rule$1に特有な, あるいは そうでない汎用な）何個かの［
`~at-rule$／`有修飾~規則$／`記述子~宣言$
］【混在し得る】を包含する
— それらは、当の~at-ruleにより定義される制限の~subjectになる。
◎
Block at-rules will typically contain a collection of (generic or at-rule–specific) at-rules, qualified rules, and/or descriptor declarations subject to limitations defined by the at-rule.＼
</p>

<p>
`記述子@
は，`~prop$に類似する（かつ同じ構文で宣言される）が、~tree内の［
要素／~box
］ではなく，特定0の型の`~at-rule$1に結付けられる。
◎
Descriptors are similar to properties (and are declared with the same syntax) but are associated with a particular type of at-rule rather than with elements and boxes in the tree.
</p>

		</section>
		<section id="charset-rule">
<h3 title="The @charset Rule">9.3. `charset^at 規則</h3>

<p>
~stylesheet用に`~fallback符号化法を決定する$~algoは、~fileの一番先頭から，特定の~byte並び
— 構文上は［
名前 "`charset^at" の`~at-rule$1
］の形をとる，少数の~byte列 —
を検索する。
◎
The algorithm used to determine the fallback encoding for a stylesheet looks for a specific byte sequence as the very first few bytes in the file, which has the syntactic form of an at-rule named "@charset".
</p>

<p>
しかしがら、名前
`charset@at
の`~at-rule$は，実際には無い。
`charset$at 規則のどの出現に対しても、~stylesheetを実際に構文解析するときは，認識できない規則として扱った上で、~stylesheetの文法を検査するときは，無効なものとして棄てるモノトスル。
◎
However, there is no actual at-rule named @charset. When a stylesheet is actually parsed, any occurrences of an @charset rule must be treated as an unrecognized rule, and thus dropped as invalid when the stylesheet is grammar-checked.
</p>

<p class="note">注記：
CSS 2.1 においては、 `charset$at は妥当な規則であった。
旧来の仕様には、依然として， `charset$at 規則を参照rして, ~stylesheet内における その有無について明示的に~~述べているものもある。
◎
Note: In CSS 2.1, @charset was a valid rule. Some legacy specs may still refer to a @charset rule, and explicitly talk about its presence in the stylesheet.
</p>

		</section>
	</section>
	<section id="serialization">
<h2 title="Serialization">10. 直列化</h2>

<p>
この仕様にて述べられる~tokenizerは、~commentに対応する~tokenは，生産しないし，何らかの仕方で保全することもない。
実装は、各~commentの内容，~token~stream内での その所在を保全してもヨイ
【以下では、 “`保全d~comment^dfn” と称される】
。
そうする場合、その保全された情報は，構文解析の段に~~影響させないモノトスル。
◎
The tokenizer described in this specification does not produce tokens for comments, or otherwise preserve them in any way. Implementations may preserve the contents of comments and their location in the token stream. If they do, this preserved information must have no effect on the parsing step.
</p>

<p>
この仕様は、~CSSを直列化する一般的な方法は 定義しない。
その仕事は、 `CSSOM$r, および 個々の特能の仕様に委ねられる。
特に，~commentや空白の直列化は定義されない。
◎
This specification does not define how to serialize CSS in general, leaving that task to the [CSSOM] and individual feature specifications. In particular, the serialization of comments and whitespace is not defined.
</p>

<p>
直列化に課される唯一の要件は、構文解析と “往来-” できなければナラナイことである。
すなわち，~stylesheetの構文解析においては、［
連続する `whitespace$tok が 1 個の~tokenに縮約されてもヨイ~DAGGER
］ことを除き，［
その結果
］と［
それを更に直列化して, もう一度~構文解析した結果
］は，同じ~data構造を生産しなければナラナイ。
◎
The only requirement for serialization is that it must "round-trip" with parsing, that is, parsing the stylesheet must produce the same data structures as parsing, serializing, and parsing again, except for consecutive &lt;whitespace-token&gt;s, which may be collapsed into a single token.
</p>

<p class="note">注記~DAGGER：
上の例外は、~CSS文法が，任意の量の空白を 常に 1 個の~spaceと同一視することに因る。
◎
Note: This exception can exist because CSS grammars always interpret any amount of whitespace as identical to a single space.
</p>

<div class="note" id="serialization-tables">

<p>
この要件を満たすためには：
◎
To satisfy this requirement:
</p>

<ul>
	<li>
［
`5C^U を.値にとる `delim$tok
］は、［
`5C^U, `改行文字$
］並びとして直列化されなければナラナイ。
（~tokenizerが その種の~tokenを発するときは、必ず［
改行文字から開始される `whitespace$tok
］を後続させる。）
◎
A &lt;delim-token&gt; containing U+005C REVERSE SOLIDUS (\) must be serialized as U+005C REVERSE SOLIDUS followed by a newline. (The tokenizer only ever emits such a token followed by a &lt;whitespace-token&gt; that starts with a newline.)
</li>
	<li>
`hash$tok であって［
.型~flag ~EQ `無制約^i
］なるものに要する~escapeが，同じ~tokenであって［
.型~flag ~EQ `id^i
］なるものより多くなることはない。
◎
A &lt;hash-token&gt; with the "unrestricted" type flag may not need as much escaping as the same token with the "id" type flag.
</li>
	<li>
`dimension$tok の.単位は、科学的記数法と区別するために，~escapeを要し得る。
◎
The unit of a &lt;dimension-token&gt; may need escaping to disambiguate with scientific notation.
</li>
	<li>
<p>
下の表の中で，チェック（ ✗ ）が入っている欄と同じ［
列, 行
］の見出しに示されている 2 個の~tokenを，この順に連続して直列化するときは、それらの合間に~commentが伴われなければナラナイ。
◎
For any consecutive pair of tokens, if the first token shows up in the row headings of the following table, and the second token shows up in the column headings, and there’s a ✗ in the cell denoted by the intersection of the chosen row and column, the pair of tokens must be serialized with a comment between them.
</p>

<p>
~tokenizerが~commentを保全する場合、保全d~commentを利用するベキである。
そうでなければ［
空な~comment（ `/**/^c ）
］を挿入するモノトスル。
（保全d~commentは、下の表による， 2 個の~tokenの合間の~commentが要求されない所でも，挿入し直されてもヨイ。）
◎
If the tokenizer preserves comments, the preserved comment should be used; otherwise, an empty comment (/**/) must be inserted. (Preserved comments may be reinserted even if the following tables don’t require a comment between two tokens.)
</p>

<p>
表の見出し項目のうち， 1 個の文字によるものは、それを.値に伴う `delim$tok を表現する。
◎
Single characters in the row and column headings represent a &lt;delim-token&gt; with that value, except for "(", which represents a (-token.
</p>

<div style="overflow:auto;">
<table id="_ser-table1">

<thead><tr><td><th>`ident$tok
<th>`function$tok
<th>`url$tok
<th>`bad-url$tok
<th>`-^c
<th>`number$tok
<th>`percentage$tok
<th>`dimension$tok
<th>`CDC$tok
<th>`(^c
<th>`*^c
<th>`%^c
</thead>

<tbody>
<tr><th>`ident$tok
`✗✗✗✗✗✗✗✗✗✗__^cK

<tr><th>`at-keyword$tok
`✗✗✗✗✗✗✗✗✗___^cK

<tr><th>`hash$tok
`✗✗✗✗✗✗✗✗✗___^cK

<tr><th>`dimension$tok
`✗✗✗✗✗✗✗✗✗___^cK

<tr><th>`#^c
`✗✗✗✗✗✗✗✗____^cK

<tr><th>`-^c
`✗✗✗✗✗✗✗✗____^cK

<tr><th>`number$tok
`✗✗✗✗_✗✗✗___✗^cK

<tr><th>`@^c
`✗✗✗✗✗_______^cK

<tr><th>`.^c
`_____✗✗✗____^cK

<tr><th>`+^c
`_____✗✗✗____^cK

<tr><th>`/^c
`__________✗_^cK

</tbody></table>

		</div>
	</li>
</ul>

</div>

		<section id="serializing-anb">
<h3 title="Serializing &lt;an+b&gt;">10.1. ~anb の直列化-法</h3>

<p>
`~anb 値を直列化-@
するときは、その
( `周期$ %A, `~offset$ %B )
に対し，次を走らす：
◎
To serialize an &lt;an+b&gt; value, with integer values A and B:
</p>

<div >
<ol>
	<li>
~IF［
%A ~EQ 0
］
⇒
~RET %B を直列化した結果
</li>
	<li>
%結果 ~LET %A に応じて
⇒＃
1 ならば 空~文字列 ／
−1 ならば `-^l ／
~ELSE_ %A を直列化した結果
</li>
	<li>
%結果 に `n^l を付加する
</li>
	<li>
~IF［
%B ~EQ 0
］
⇒
~RET %結果
</li>
	<li>
~IF［
%B ~GT 0
］
⇒
%結果 に `+^l を付加する
</li>
	<li>
%結果 に %B を直列化した結果を付加する
</li>
	<li>
~RET %結果
</li>

</ol>
◎
• If A is zero, return the serialization of B.
• Otherwise, let result initially be an empty string.
• A is 1
••  Append "n" to result.
• A is -1
•• Append "-n" to result.
• A is non-zero
•• Serialize A and append it to result, then append "n" to result.
• B is greater than zero
•• Append "+" to result, then append the serialization of B to result.
• B is less than zero
•• Append the serialization of B to result.
• Return result.
</div>

		</section>
	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">11. ~privacyと~securityの考慮点</h2>

<p>
この仕様により新たな~privacyの懸念が導入されることはない。
◎
This specification introduces no new privacy concerns.
</p>

<p>
この仕様による~CSS構文解析は、今や すべての入力に対し一義的に定義されるので，~securityを改善する。
◎
This specification improves security, in that CSS parsing is now unambiguously defined for all inputs.
</p>

<p>
~whitelistや~filterなどの旧い構文解析器には、この仕様と異なるように構文解析する限り~secureでない部分があることになる。
以前の構文解析の仕様には，多義的で, ~browserにより解釈が異なるような多数の際どい事例が残されているので、それらの~filterは~secureでない可能性がある。
この仕様は，その状況を悪化させることはない。
◎
Insofar as old parsers, such as whitelists/filters, parse differently from this specification, they are somewhat insecure, but the previous parsing specification left a lot of ambiguous corner cases which browsers interpreted differently, so those filters were potentially insecure already, and this specification does not worsen the situation.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">12. 変更点</h2>

~INFORMATIVE

		<section id="changes-CR-20190716">
<h3 title="Changes from the 16 August 2019 Candidate Recommendation">12.1. 2019年 8月 16日 勧告候補からの変更点</h3>

<p>
~~主要な変更点は：
◎
The following substantive changes were made:
</p>

<ul>
	<li>
新たに
<a href="#parse-comma-list">§ ~commaで分離された~listを ある~CSS文法に則って構文解析する</a>
~algoを追加した。
◎
Added a new § 5.3.2 Parse A Comma-Separated List According To A CSS Grammar algorithm.
</li>
</ul>

<p>
編集上の変更点は：
◎
The following editorial changes were made:
</p>

<ul>
	<li>
何箇所かで利用していた用語 "名前" に代えて、一貫して "識別子" を参照rするよう切替えた。
◎
Switched to consistently refer to "identifier", rather than sometimes using the term "name".
</li>
	<li>
~token化前の処理nのいくつかを明示的に命名して，それらを構文解析の入口から明示的に参照rするようにした（総括的な言明
“これらの~algoの開始-時には X を行うとする”
に依拠するのでなく）。
◎
Explicitly named several of the pre-tokenizing processes, and explicitly referred to them in the parsing entry points (rather than relying on a blanket "do X at the start of these algorithms" statement).
</li>
</ul>

<p>
<a href="https://github.com/w3c/csswg-drafts/milestone/7?closed=1">各~commentに対する処置集</a>
もある。
◎
A Disposition of Comments is available.
</p>

		</section>
		<section id="changes-CR-20140220">
<h3 title="Changes from the 20 February 2014 Candidate Recommendation">12.2. 2014年 2月 20日 勧告候補からの変更点</h3>

<p>
~~主要な変更点は：
◎
The following substantive changes were made:
</p>

<ul>
	<li>
`urange$t 生成規則を創出する支持を受けて，
`unicode-range^tok は除去した。
◎
Removed &lt;unicode-range-token&gt;, in favor of creating a &lt;urange&gt; production.
</li>
	<li>
文字列を包含する `url^f 関数は、今や，通常通り `function$tok として構文解析される。
“生の” ~URLを包含する `url^f 関数は、依然として `url$tok として特別に構文解析される。
◎
url() functions that contain a string are now parsed as normal &lt;function-token&gt;s. url() functions that contain "raw" URLs are still specially parsed as &lt;url-token&gt;s.
</li>
	<li>
文字列を消費しようと試みる前に引用符を消費していなかった，
“~url~tokenを消費” ~algoの~bugを修正した。
◎
Fixed a bug in the "Consume a URL token" algorithm, where it didn’t consume the quote character starting a string before attempting to consume the string.
</li>
	<li>
現入力~token／次入力~tokenとその消費~時機に関する，いくつかの構文解析器~algoの~bugを修正した。
◎
Fixed a bug in several of the parser algorithms related to the current/next input token and things getting consumed early/late.
</li>
	<li>
~token化と構文解析~algoにおける いくつかの~bugを修正した。
◎
Fix several bugs in the tokenization and parsing algorithms.
</li>
	<li>
識別子に類する~tokenの定義を，
`--^c から開始される識別子も許容するように変更した
【<a href="#would-start-an-identifier">参照</a>】
。
その~~一環として，`~tokenを消費$における `2D^U 段を成す段たちを~~配列し直して、
`CDC$tok が そう認識されるようにした
— `--^c `ident-token$t にはならずに。
◎
Change the definition of ident-like tokens to allow "--" to start an ident. As part of this, rearrange the ordering of the clauses in the "-" step of consume a token so that &lt;CDC-token&gt;s are recognized as such instead of becoming a -- &lt;ident-token&gt;.
</li>
	<li>
`~anb$ の`周期$ ~IN { 1, −1 } のときは、その数字は直列化しないようにした。
◎
Don’t serialize the digit in an &lt;an+b&gt; when A is 1 or -1.
</li>
	<li>
すべての~tokenは`表現$を持つように定義した。
◎
Define all tokens to have a representation.
</li>
	<li>
2 個の符号位置が`妥当な~escape$を成すかどうか検査するときの，小さな~bugを修正した
— 並び［
`5C^U, `EOF$tok
］は、今や，妥当な~escapeではないものと正しく報告される。
~stylesheet内の最後の `\^c は、今や，自身を `delim$tok として発するだけになる。
◎
Fixed minor bug in check if two code points are a valid escape—a \ followed by an EOF is now correctly reported as not a valid escape. A final \ in a stylesheet now just emits itself as a &lt;delim-token&gt;.
</li>
	<li>
`charset^at は、もはや妥当な~CSS規則ではない（単に， `charset^at という名前の規則の`様に見える^em 符号化法~宣言があるに過ぎない）。
◎
@charset is no longer a valid CSS rule (there’s just an encoding declaration that looks like a rule named @charset)
</li>
	<li>
構文解析の間に，宣言の.値の先頭／末尾にある空白~並びは削るようにした。
◎
Trimmed whitespace from the beginning/ending of a declaration’s value during parsing.
</li>
	<li>
~WGによる解決にしたがって、~Selectorsに特有な~tokenは除去した。
◎
Removed the Selectors-specific tokens, per WG resolution.
</li>
	<li>
~WGによる解決にしたがって、入力~stream内の`~surrogate$は~filterするようにした。
この仕様~全体は、今や，`~scalar値$のみに演算する。
◎
Filtered surrogates from the input stream, per WG resolution. Now the entire specification operates only on scalar values.
</li>
</ul>

<p>
編集上の変更点は：
◎
The following editorial changes were made:
</p>

<ul>
	<li>
“文字列を消費” する~algoは、明示的な終端~符号位置を指定せずに呼べるようにされた。
その場合は 現入力~符号位置が代わりに利用される。
これにより，３カ所の呼び出しに変更が加えられた。
◎
The "Consume a string token" algorithm was changed to allow calling it without specifying an explicit ending token, so that it uses the current input token instead. The three call-sites of the algorithm were changed to use that form.
</li>
	<li>
編集上の，~algoにおける小さな再構成
◎
Minor editorial restructuring of algorithms.
</li>
	<li>
構文解析-~API用の入口として、次を追加した
⇒＃
`~CSS文法に則って構文解析する$,
`~commaで分離された成分~値~listを構文解析する$
◎
Added the parse and parse a comma-separated list of component values API entry points.
</li>
	<li>
次の生成規則を追加した
⇒＃
`declaration-value$t,
`any-value$t
◎
Added the &lt;declaration-value&gt; and &lt;any-value&gt; productions.
</li>
	<li>
Infra Standard による定義に一致するので、次の定義は除去した
⇒＃
“符号位置”,
“~surrogate符号位置”
◎
Removed "code point" and "surrogate code point" in favor of the identical definitions in the Infra Standard.
</li>
	<li>
どの【符号位置】範囲も， `inclusive^ であることを明確化した。
◎
Clarified on every range that they are inclusive.
</li>
	<li>
`%^l `delim$tok ~tokenの次に出現する `number$tok を取扱うため、
<a href="#serialization-tables">~comment挿入~表</a>
に列を追加した。
◎
Added a column to the comment-insertion table to handle a number token appearing next to a "%" delim token.
</li>
</ul>

<p>
<a href="https://github.com/w3c/csswg-drafts/milestone/5?closed=1">各~commentに対する処置集</a>
もある。
◎
A Disposition of Comments is available.
</p>

		</section>
		<section id="changes-WD-20131105">
<h3 title="Changes from the 5 November 2013 Last Call Working Draft">12.3. 2013年 11月 5日 最終~作業草案からの変更点</h3>

<ul>
	<li>
§ `直列化$は、“往来-” の要件のみが規範的になるように書き直され、それを得るための方法の詳細は注記に移動された。
これらの詳細~における，いくつかの際どい事例は解消された。
◎
The Serialization section has been rewritten to make only the "round-trip" requirement normative, and move the details of how to achieve it into a note. Some corner cases in these details have been fixed.
</li>
	<li>
参照文献（規範）に `ENCODING$r が追加された。
それは規範的な~textからは参照されていたが、単に文献~listから漏れていた。
◎
[ENCODING] has been added to the list of normative references. It was already referenced in normative text before, just not listed as such.
</li>
	<li>
<p>
~stylesheetの`~fallback符号化法を決定する$~algoにおける
`charset^at ~byte列の上限は、 1024 ~byteにされた。
これは，~HTMLにおける `meta charset^e の処し方に倣うものであり、列の長さを常に一定に抑えるようにする。
これは、符号化法~labelの前後の空白についてのみ，以前と相違がある：
◎
In the algorithm to determine the fallback encoding of a stylesheet, limit the @charset byte sequence to 1024 bytes. This aligns with what HTML does for &lt;meta charset&gt; and makes sure the size of the sequence is bounded. This only makes a difference with leading or trailing whitespace in the encoding label:
</p>

<pre class="lang-css">
@charset "   <em title="(lots of whitespace)">…多量の空白…</em>   utf-8";
</pre>
	</li>
</ul>

		</section>
		<section id="changes-WD-20130919">
<h3 title="Changes from the 19 September 2013 Working Draft">12.4. 2013年 9月 19日 作業草案からの変更点</h3>

<ul>
	<li>

`環境~符号化法$の概念が追加された。
挙動は変更されていないが、定義の一部は，関連な仕様へ移動されるべきである。
◎
The concept of environment encoding was added. The behavior does not change, but some of the definitions should be moved to the relevant specs.
</li>
</ul>

		</section>
		<section id="changes-css21">
<h3 title="Changes from CSS 2.1 and Selectors Level 3">12.5. `CSS 2.1^cite, `Selectors Level 3^cite からの変更点</h3>

<p class="note">注記：
この仕様の要点は、実態に合致させることである
— CSS 2.1 からの変更点は、おおよそ常に， CSS 2.1 が［
実際の~browserの挙動に合致していない何かを指定しているか, または
何かを未指定なままにしている
］ことに因る。
何らかの詳細が~browserの挙動に合致しない場合、それは，ほぼ意図されていないことなので，編集者まで知らせるよう願う。
◎
Note: The point of this spec is to match reality; changes from CSS2.1 are nearly always because CSS 2.1 specified something that doesn’t match actual browser behavior, or left something unspecified. If some detail doesn’t match browsers, please let me know as it’s almost certainly unintentional.
</p>

<p>
~byte~streamからの復号-法における変更点：
◎
Changes in decoding from a byte stream:
</p>

<ul>
	<li>
~ASCII互換~byte~patternの中では、 `charset$at 規則のみが検出される。
◎
Only detect @charset rules in ASCII-compatible byte patterns.
</li>
	<li>
~ASCII互換でない符号化法を指定する `charset$at 規則は、規則それ自身を適正に復号できなくするので，無視される。
◎
Ignore @charset rules that specify an ASCII-incompatible encoding, as that would cause the rule itself to not decode properly.
</li>
	<li>
文字~符号化法は、 IANA ~registryではなく， `ENCODING$r を参照rするようにされた。
◎
Refer to [ENCODING] rather than the IANA registry for character encodings.
</li>
</ul>

<p>
~token化における変更点：
◎
Tokenization changes:
</p>

<ul>
	<li>
~CSS~source内の `00^U `符号位置$はすべて， `FFFD^U に置換される
◎
Any U+0000 NULL code point in the CSS source is replaced with U+FFFD REPLACEMENT CHARACTER.
</li>
	<li>
`\0^css などの 0 に評価されるどの 16 進~escape列も， `00^U でなく `FFFD^U を生産する。
◎
Any hexadecimal escape sequence such as \0 that evaluates to zero produce U+FFFD REPLACEMENT CHARACTER rather than U+0000 NULL.
</li>
	<li>
`非~ASCII符号位置$の定義は， ~ASCIIを用いるどの定義にも整合するように変更された。
これは，`符号位置$ { `0080^U 〜 `009F^U } に影響する
— それらは今や、他の`非~ASCII符号位置$同様に，`delim$tok ではなく `識別子~符号位置$になる。
◎
The definition of non-ASCII code point was changed to be consistent with every definition of ASCII. This affects code points U+0080 to U+009F, which are now identifier code points rather than &lt;delim-token&gt;s, like the rest of non-ASCII code points.
</li>
	<li>
~token化は、最早［
`COMMENT^c ／ `BAD_COMMENT^c
］~tokenを発することはない。
`BAD_COMMENT^c は今や，（~errorではない）通常の~tokenと同じものと見なされる。
分離される必要がある~token
— 例えば 連続する 2 個の `ident$tok など —
の合間に，必要に応じて~commentを挿入することは、`直列化$が責を負う。
◎
Tokenization does not emit COMMENT or BAD_COMMENT tokens anymore. BAD_COMMENT is now considered the same as a normal token (not an error). Serialization is responsible for inserting comments as necessary between tokens that need to be separated, e.g. two consecutive &lt;ident-token&gt;s.
</li>
	<li>
<p>
`unicode-range^tok を除去した。
価値が低い割に，ときには有害になるので（例えば
`u+a { font-weight: bold; }^css
は、`無効な選択子$にされていた…）。
◎
The &lt;unicode-range-token&gt; was removed, as it was low value and occasionally actively harmful. (u+a { font-weight: bold; } was an invalid selector, for example...)
</p>

<p>
代わりに，~token~patternに基づく `urange$t 生成規則が追加された。
それは、 CSS 2.1 で許容されていたものより，形上では緩い（任意個数の数字や `?^c ）が、実施におけるその利用には影響iない筈である。
◎
Instead, a &lt;urange&gt; production was added, based on token patterns. It is technically looser than what 2.1 allowed (any number of digits and ? characters), but not in any way that should impact its use in practice.
</p>
	</li>
	<li>
~tokenizerにおいては`~EOF~errorの取扱い規則$が適用され、~EOFに際しては、
`BAD_STRING^c や `BAD_URI^c ではなく，通常の `string$tok や `url$tok が発される。
◎
Apply the EOF error handling rule in the tokenizer and emit normal &lt;string-token&gt; and &lt;url-token&gt; rather than BAD_STRING or BAD_URI on EOF.
</li>
	<li>
`BAD_URI^c ~token（今や `bad-url$tok ）は “自己完結的” である。
言い換えれば、~tokenizerにおいて，`url$tok ではなく `bad-url$tok の中であることが~~判明した時点で、単に，閉じられる箇所を見つけるために 他のすべてを無視して前方検索する。
この挙動は［
それを `function$tok の様に扱って，開いた~blockに類するものに注意を払う
］より単純である。
この挙動は WebKit だけが呈するが、それによる互換性~bugは生じていないように見受けられる。
◎
The BAD_URI token (now &lt;bad-url-token&gt;) is "self-contained". In other words, once the tokenizer realizes it’s in a &lt;bad-url-token&gt; rather than a &lt;url-token&gt;, it just seeks forward to look for the closing ), ignoring everything else. This behavior is simpler than treating it like a &lt;function-token&gt; and paying attention to opened blocks and such. Only WebKit exhibits this behavior, but it doesn’t appear that we’ve gotten any compat bugs from it.
</li>
	<li>
`comma$tok が追加された。
◎
The &lt;comma-token&gt; has been added.
</li>
	<li>
［
`number$tok,
`percentage$tok,
`dimension$tok
］は、前置された`正負符号$を値の一部に含むように変更された（他の仕様で言及される度に，手動で取扱う必要がある，別々の `delim$tok としてではなく）。
これによる唯一の帰結は、符号とその実数の合間には，最早~commentを挿入し得なくなったことである。
◎
&lt;number-token&gt;, &lt;percentage-token&gt;, and &lt;dimension-token&gt; have been changed to include the preceding +/- sign as part of their value (rather than as a separate &lt;delim-token&gt; that needs to be manually handled every time the token is mentioned in other specs). The only consequence of this is that comments can no longer be inserted between the sign and the number.
</li>
	<li>
~WGによる解決に従って、~SVGに合わせるため，［
実数／百分率／次元
］における科学的記数法も~supportされる。
◎
Scientific notation is supported for numbers/percentages/dimensions to match SVG, per WG resolution.
</li>
	<li>
［
`~surrogate$用の 16 進~escape
］は今や、その~surrogateではなく，代替文字
【 `FFFD^U 】
を発する。
これにより、実装は，~UTF-16を内部的に安全に利用できるようになる。
◎
Hexadecimal escape for surrogate now emit a replacement character rather than the surrogate. This allows implementations to safely use UTF-16 internally.
</li>
</ul>

<p>
構文解析における変更点：
◎
Parsing changes:
</p>

<ul>
	<li>
~WGによる解決に従って，今や、どの`宣言~list$も
`page$at のような~at-ruleを受容する。
これにより，その種の~at-ruleが未だ定義されていなかったとしても，~errorの取扱いには相違が生じる：
`~at-rule$は、妥当であろうとなかろうと， `semicolon$tok が伴われなくとも波括弧~blockで終端し，次の宣言を始めさせる。
◎
Any list of declarations now also accepts at-rules, like @page, per WG resolution. This makes a difference in error handling even if no such at-rules are defined yet: an at-rule, valid or not, ends at a {} block without a &lt;semicolon-token&gt; and lets the next declaration begin.
</li>
	<li>
<p>
文法~内の様々な箇所に現れる，諸々の “特別な” ~token（対になっていない `close-curly$Tok など）の取扱いは、少なくとも 1 つ以上の~browserに見られる，ある種の適理な挙動により指定された。
その種の~tokenが伴われた~stylesheetは、以前までは，単に ~stylesheet文法に全く合致しないものとされており、その取扱いは，まったく定義されていなかった。
特定的には、今や：
◎
The handling of some miscellaneous "special" tokens (like an unmatched &lt;}-token&gt;) showing up in various places in the grammar has been specified with some reasonable behavior shown by at least one browser. Previously, stylesheets with those tokens in those places just didn’t match the stylesheet grammar at all, so their handling was totally undefined. Specifically:
</p>
		<ul>
			<li>
［
`角括弧~block$ ／ `丸括弧~block$ ／ `関数式$
］は、［
`波括弧~block$,
`at-keyword$tok,
`semicolon$tok,
］のいずれをも包含し得る
◎
[] blocks, () blocks and functions can now contain {} blocks, &lt;at-keyword-token&gt;s or &lt;semicolon-token&gt;s
</li>
			<li>
有修飾~規則の.導入部は、~semicolonを包含し得る
◎
Qualified rule preludes can now contain semicolons
</li>
			<li>
［
有修飾~規則 ／ ~at-ruleの.導入部
］は、 `at-keyword$tok 包含し得る。
◎
Qualified rule and at-rule preludes can now contain &lt;at-keyword-token&gt;s
</li>
		</ul>
	</li>
</ul>

<p>
~AnB における， `Selectors Level 3^cite `SELECT$r からの変更点：
◎
An+B changes from Selectors Level 3 [SELECT]:
</p>

<ul>
	<li>
<p>
~AnB 小構文は 今や，別々の~tokenizerではなく，~CSS~tokenの用語を通して，正式に定義された。
その結果，小さな相違が生じている：
◎
The An+B microsyntax has now been formally defined in terms of CSS tokens, rather than with a separate tokenizer. This has resulted in minor differences:
</p>
		<ul>
			<li>
一部の場合には，負符号や数字を（それらが `dimension$tok の.単位や `ident$tok の一部として出現するときには）~escapeできる。
◎
In some cases, minus signs or digits can be escaped (when they appear as part of the unit of a &lt;dimension-token&gt; or &lt;ident-token&gt;).
</li>
		</ul>
	</li>
</ul>

		</section>
	</section>
	<section>
<h2 id="acknowledgments">謝辞</h2>

<p>
次の方々からの~feedbackと貢献に：
</p>

<p lang="en-x-a0">
Thanks for feedback and contributions from
Anne van Kesteren,
David Baron,
Henri Sivonen,
Johannes Koch,
呂康豪 (Kang-Hao Lu),
Marc O’Morain,
Raffaello Giulietti,
Simon Pieter,
Tyler Karaszewski, and
Zack Weinberg.
</p>

	</section>
</main></div>
