<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Scroll Anchoring Module Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) { //%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Scroll Anchoring Module Level 1
spec_date:2020-11-11
trans_update:2020-11-13
source_checked:200918
page_state_key:CSS
original_url:https://drafts.csswg.org/css-scroll-anchoring-1/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-ux,css
copyright:2020,permissive
trans_1st_pub:2017-09-06


●●class_map
p:css
v:value
t:type
et:event-type
e:element
a:attr

●●tag_map
m:code
c:code
p:code
v:code
et:code
e:code
a:code

●●original_id_map

●●mdn_urls
propdef-overflow-anchor:CSS/overflow-anchor

●●link_map



m.getBoundingClientRect():~CSSOMVIEW#dom-element-getboundingclientrect
et.scroll:~CSSOMVIEW#eventdef-document-scroll
	~scroll~event:~CSSOMVIEW#eventdef-document-scroll

p.overflow-anchor:#propdef-overflow-anchor
p.display:~CSSDISP#propdef-display

p.width:~SIZING#propdef-width
p.height:~SIZING#propdef-height
p.max-width:~SIZING#propdef-max-width
p.max-height:~SIZING#propdef-max-height
p.min-width:~SIZING#propdef-min-width
p.min-height:~SIZING#propdef-min-height

p.position:~CSSPOS#propdef-position
p.scroll-padding:~CSSSCROLLSNAP#propdef-scroll-padding
p.transform:~TRANSFORM#propdef-transform
p.margin:~CSSBOX#propdef-margin
p.padding:~CSSBOX#propdef-padding

~inset~prop:~CSSPOS#inset-properties
	p.bottom:~CSSPOS#propdef-bottom
	p.left:~CSSPOS#propdef-left
	p.right:~CSSPOS#propdef-right
	p.top:~CSSPOS#propdef-top

v.auto:#valdef-overflow-anchor-auto
v.none:#valdef-overflow-anchor-none
	v.absolute:~CSSPOS#valdef-position-absolute
	v.fixed:~CSSPOS#valdef-position-fixed
	v.none:~CSSDISP#valdef-display-none

e.textarea:~HEforms#the-textarea-element
e.input:~HEinput#the-input-element

	●用語
~anchor~node:#scroll-anchoring-anchor-node
~anchor~node選定~algo:#anchoring-algorithm
優先~候補:#anchor-priority-candidates
実現可能な候補:#anchor-viable-candidate
候補~審査~algo:#candidate-examination
除外~下位tree:#excluded-subtree
全部的に切取られて:#fully-clipped
全部的に可視:#fully-visible
部分的に可視:#partially-visible
~scroll~anchor用の限界矩形:#scroll-anchoring-bounding-rect
抑止~誘因:#suppression-trigger
抑止~窓:#suppression-window

	●用語（CSS
	すべての要素:~CSSPSEUDO#generated-content
絶対的に位置され:~CSSPOS#absolute-position

包含塊:~CSSDISP#containing-block
可分な行内:~CSSDISP#inline-box
	不可分な行内:~CSSDISP#atomic-inline
~box:~CSSDISP#box

内容~区画:~CSSBOX#content-area

最適な~view用~領域:~CSSSCROLLSNAP#optimal-viewing-region
留められ:~CSSSCROLLSNAP#scroll-snap
~scroll留ng:~CSSSCROLLSNAP#scroll-snap
留直し:~CSSSCROLLSNAP#re-snap

~scrollされる~box:~CSSOMVIEW#scrolling-box
	~scrolling:~CSSOMVIEW#scrolling-events

~scroll可能な~overflow矩形:~CSSOVERFLOW3#scrollable-overflow-rectangle
~scroll容器:~CSSOVERFLOW3#scroll-container

塊~flow方向:~CSSWM#block-flow-direction
塊-始端:~CSSWM#block-start

	●用語（他

子孫:~DOM4#concept-tree-descendant
範囲~obj:~DOM4#concept-range
始端~node:~DOM4#concept-range-start-node

~event~loop処理~model:~WAPI#event-loop-processing-model

~DOM~anchor:~HTMLinteraction#dom-anchor
~focusされている区画:~HTMLinteraction#focused-area-of-the-document
編集中の~host:~HTMLinteraction#editing-host
作動中の合致-:~HTMLinteraction#fip-active-match

変異-可能:~HTMLforms#concept-fe-mutable

編集-可能:~EXEC-COMMAND#editable


	:https://tabatkins.github.io/specs/css-sticky-scrollbars/#intro
	:http://tabatkins.github.io/specs/css-sticky-scrollbars/
	~WICG~interventions~issue:https://github.com/wicg/interventions/issues/2
	:https://github.com/WICG/ScrollAnchoring/blob/master/explainer.md


●●words_table1


CSSSCROLLSNAP:css-scroll-snap-ja.html
	https://drafts.csswg.org/css-scroll-snap/


●●words_table



	●anchoring
anchor:
	係留／停泊
	anchor法:anchoring
補償-:compensate:~
ズラす:shiftする:ずらす
ズラされ:shiftされ:ずらされ
ズラして:shiftして:ずらして
動いた:moveした:~
動く:moveする:~
動き:movement:~
誘因:trigger::~
窓:window::~
候補:candidate:~
審査:examination::~
切取られ:clipされ::切り取られ
最適な:optimal:~
優先-:prioritize::~
優先:priority::~
実現可能:viable::~
留ng:snapping::留め::スナッピング
留めら:snapさ::~::スナップさ
留直し:re-snapping::留め直し::スナップし直し

	●layoput
領域:region::~
限界矩形:bounding rect::~
矩形:rectangle::~
可分:non-atomic::~

	~sizeが与えられていない:non-sized
	~scroll可能:scrollable
	~scrollされる:scrolling
	~flow外:out-of-flow
	~view用:viewing
	内側にある:within

	●DOM／event
経路:path::~
深い:deepな:~

	●UI
選択-:select::~
選択:selection::~
編集-:edit::~
編集中の:editing::~
安定的:stable:~
find-in-page::::ページ内検索

	合致している部分:match
	満たされ:meet
	合致したものとして現在~選択されている部分:current active selected match
	一部でも:span


	●仕様
opt-outする::任意で外す
可能性:possibility:~
必要:need:~
目指す:aimする:~
	~~説明:description
適格:eligible:~
安定化-:stabilize:~
目障りな:jarring:~

	広告入り:containing an ad

	関わらず:regardless
	に則ってaccordingly
	今日の:today,
	気を散らされる:distract
	~~不意に:surprising
	呼ばれ:called
	他に取って代わられた:supersed
	note
	説明:explainer
	opt
	moving
	保とう:keep

	●未分類（動詞
	loading
	追跡し続け:keep track
	生じ:occur
	転じる:turn
	オンに戻す:back on

	-:attempt

	●未分類
iframe:
低速:slow:~
近過去の:recentな:~

	-:mode
	time
	web~site:website
	~web~page:webpage
	website
	around:around
	近い:close to
	scroller
	切り替える:becomes or stops
	起動時から:when launched



	●指示語
部位:portion:~

	より近未来:comes sooner
	〜からの:relative
	一種:type
	保つ:keep
	直前:immediately before
	含-:include
	:differ
	後から:later
	ごく限られている:few
	途中で:in the middle of
	全体:entirely
	次に:next
	動く前:previous
	most
	whichever
	part
	now
	anything
	inclusive


●●ref_normative

[CSS-BOX-4]
    Elika Etemad. CSS Box Model Module Level 4. 21 April 2020. WD. URL: https://www.w3.org/TR/css-box-4/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 3 June 2020. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-POSITION-3]
    Elika Etemad; et al. CSS Positioned Layout Module Level 3. 19 May 2020. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-SCROLL-SNAP-1]
    Matt Rakow; et al. CSS Scroll Snap Module Level 1. 19 March 2019. CR. URL: https://www.w3.org/TR/css-scroll-snap-1/ 
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. CSS Box Sizing Module Level 3. 23 October 2020. WD. URL: https://www.w3.org/TR/css-sizing-3/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 6 June 2019. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 4. 31 January 2019. WD. URL: https://www.w3.org/TR/css-values-4/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/ 
[CSSOM-VIEW]
    Simon Pieters. CSSOM View Module. 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-view-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 

●●
ref_informative


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Scroll Anchoring Module Level 1</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-scroll-anchoring-1/
以前のバージョン
	https://www.w3.org/TR/2020/WD-css-scroll-anchoring-1-20200211/

課題追跡
	<a href="https://github.com/w3c/csswg-drafts/labels/css-scroll-anchoring-1">CSSWG Issues Repository</a>

編集
	Steve Kobes (Google)
	<a href="http://xanthir.com/contact/">Tab Atkins-Bittner</a> (Google)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-scroll-anchoring-1/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-scroll-anchoring-1
</script>

</head>
<body>

<header>
	<hgroup>
<h1>CSS Scroll Anchoring Module Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
`~scrollされる~box$の可視~領域より上にある~DOM要素が変化すると、利用者が内容を消費している途中で~pageが動く結果になり得る。
◎
Changes in DOM elements above the visible region of a scrolling box can result in the page moving while the user is in the middle of consuming the content.
</p>

<p>
この仕様は、~anchor~nodeの位置を追跡し続け，それに則って~scroll~offsetを調整することにより、この目障りな利用者~体験を軽減する仕組みを提案する。
◎
This spec proposes a mechanism to mitigate this jarring user experience by keeping track of the position of an anchor node and adjusting the scroll offset accordingly.
</p>

<p>
この仕様は、この挙動を~opt-outするための~web開発者~向け~APIも提案する。
◎
This spec also proposes an API for web developers to opt-out of this behavior.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~RET 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p>
今日の~web利用者たちは、表示域の外側で生じる変化に因り内容が周りへ動くことにより，気を散らされることが多い。
例えば、~scriptが広告入り~iframeを挿入するときや，低速な~networkの下で~sizeが与えられていない画像を読込むときなど。
◎
Today, users of the web are often distracted by content moving around due to changes that occur outside the viewport. Examples include script inserting an iframe containing an ad, or non-sized images loading on a slow network.
</p>

<p>
そのような変化が生じたときの~browserの既定の挙動は、歴史的に，絶対的な~scroll位置を保全することであった。
~web~pageは、内容がズラされるのを避けるため，後から読込まれるもの用に ~page上の空間を予約することもできるが、実施においてこれを一貫して行なっている~web~siteは，ごく限られている。
◎
Historically the browser’s default behavior has been to preserve the absolute scroll position when such changes occur. This means that to avoid shifting content, the webpage can attempt to reserve space on the page for anything that will load later. In practice, few websites do this consistently.
</p>

<p>
~scroll~anchor法は、表示域の外側における変化によるずれに対し，~scroll位置を調整して補償することにより、内容が~~不意にズラされるの最小限にすることを目指す。
◎
Scroll anchoring aims to minimize surprising content shifts. It does this by adjusting the scroll position to compensate for the changes outside the viewport.
</p>

<p>
~scroll~anchor法について概観する
<a href="https://github.com/WICG/ScrollAnchoring/blob/master/explainer.md">正式でない説明</a>
もある。
◎
The explainer document gives an informal overview of scroll anchoring.
</p>

		<section id="values">
<h3 title="Values Definitions">1.1. 値~定義</h3>

<p class="trans-note">【
この節の内容は
<a href="~CSScommon#values">~CSS日本語訳 共通~page</a>
に移譲。
】</p>

		</section>
	</section>
	<section id="description">
<h2 title="Description">2. ~~説明</h2>

<p>
~scroll~anchor法は、~layoutが変化しても，利用者からの文書~viewは安定的に保とうと試みる。
それは、
`~anchor~node@
— 【現在~利用者が見ている，】ある~DOM~node —
を選定した上で，［
その~nodeの動きを利用して，~scroll位置の調整を決定する
］ことにより働く。
◎
Scroll anchoring attempts to keep the user’s view of the document stable across layout changes. It works by selecting a DOM node (the anchor node) whose movement is used to determine adjustments to the scroll position.
</p>

<p>
しかしながら，当の`~scroll容器$が現在 ある要素に`留められ$ている
`CSS-SCROLL-SNAP-1$r
場合、~scroll~anchor法は，`留直し$により許容される調整に制限される。
◎
However, if the scroll container is currently snapped to an element, (see [CSS-SCROLL-SNAP-1]) scroll anchoring is limited to adjustments that would be allowed by re-snapping.
</p>

		<section id="anchor-node-selection">
<h3 title="Anchor Node Selection">2.1. ~anchor~nodeの選定</h3>

<p>
各`~scrollされる~box$は、~anchor~nodeとして［
次に該当するもののうち，~DOM内で なるべく深い それ
］を選定しようと目指す
⇒
`最適な~view用~領域$の`塊-始端$辺に近いか，重要な~DOM~nodeとして優先されるべきもの
◎
Each scrolling box aims to select an anchor node that is deep in the DOM and either should be prioritized as an important DOM node or is close to the block start edge of its optimal viewing region.
</p>

<p class="note">注記：
~UAが `scroll-padding$p ~propを~supportしない場合、`最適な~view用~領域$は，`~scrollされる~box$の`内容~区画$と等価になる。
◎
Note: If the user agent does not support the scroll-padding property, the optimal viewing region of the scrolling box is equivalent to its content area.
</p>

<p>
`可分な行内$を除く どの`~box$も~anchor~nodeになり得る。
~anchor~nodeは、常に`~scrollされる~box$の`子孫$になる。
事例によっては、~scrollされる~boxに対する~anchor~nodeは選定されないこともある
【この訳では、記号 ε で表現する】
。
◎
An anchor node can be any box except one for a non-atomic inline. The anchor node is always a descendant of the scrolling box. In some cases, a scrolling box may not select any anchor node.
</p>

<p>
所与の
( 要素 %C, `~scrollされる~box$ %S )
に対し，次に挙げる判定基準がすべて満たされるならば
— %C は %S 用の~scroll~anchorになり得る —
`実現可能な候補@
（ `viable candidate^en ）であるとされる：
◎
An element C is a viable candidate for becoming a scroll anchor for a scrolling box S if it meets all of the following criteria:
</p>

<ul>
	<li>
%C は`可分な行内$でない。
◎
C is an element that is not a non-atomic inline.
</li>
	<li>
%C は %S 内で［
`部分的に可視$／`全部的に可視$
］である
◎
C is partially visible or fully visible in S
</li>
	<li>
%C は %S の子孫である
◎
C is a descendant of S
</li>
	<li>
次を満たす要素は無い
⇒
［
%C または その先祖である
］~AND［
%S または その子孫である
］~AND［
ある`除外~下位tree$内には無い【`除外~下位tree$でも, その子孫でもない】
］
◎
C is not in an excluded subtree
◎
None of the ancestors of C up to S are in an excluded subtree
</li>
</ul>

<p>
次の (A) に挙げる各~要素に対し，その次の (B) で決定される要素は、~anchor選定~用の
`優先~候補@
（ `priority candidate^en ）と見なされる：
◎
Some elements are considered to be priority candidates for anchor selection:
</p>

<ul>
	<li>
(A)：
		<ul>
			<li>
文書にて`~focusされている区画$の`~DOM~anchor$のうち、~text編集-可能であるもの（
`編集-可能$／
`編集中の~host$／
`変異-可能$な `textarea$e ／
`変異-可能$な `input$e のうち，その `type^a は~text手入力を許容するもの
）。
◎
The DOM anchor of the focused area of the document, if such an anchor is text editable (editable, editing host, mutable textarea, or mutable input with a type that allows text entry).
</li>
			<li>
<p>
~UAによる~find-in-page~algoにより，現在`作動中の合致-$を包含している要素
— 複数~個ある場合、それらのうち最初の要素。
</p>

<p class="trans-note">【
“包含している” の意味が曖昧（一部でも包含する~nodeも該当しそうだが、それに沿うなら，文書の根~要素まで該当してしまいそうだ）。
ありそうな解釈として、合致している部分を表現する`範囲~obj$の`始端~node$が考えられる。
】</p>

◎
An element containing the current active match of the find-in-page user-agent algorithm. If the match spans multiple elements, then consider only the first such element.
</li>
		</ul>
	</li>
	<li>
(B)：
［
該当する要素, または その先祖
］であって［
`可分な行内$でない【~boxを生成する】もの
］のうち，要素に最も近いもの
◎
Note that if the priority candidate is a non-atomic inline element, then instead consider its nearest ancestor element that is not a non-atomic inline element as the priority candidate.
</li>
</ul>

<div class="algo">
<p>
`~anchor~node選定~algo@
は、所与の`~scrollされる~box$ %S に対し，次を走らせた結果を~anchor~nodeとして返す：
◎
The anchor node selection algorithm for a scrolling box S is as follows:
</p>

<ol>
	<li>
%~node ~LET  %S に結付けられている要素または文書
</li>
	<li>
~IF［
%~node は要素である
］~AND［
%~node の `overflow-anchor$p ~propの算出d値 ~EQ `none$v
］
⇒
~RET ε
◎
If S is associated with an element whose computed value of the overflow-anchor property is none, then do not select an anchor node for S.
</li>
	<li>
`優先~候補$たちを成す
~EACH( %候補 )
に対し，指定された順序【~tree順序？】で
⇒
~IF［
%候補 は %S 内の`実現可能な候補$である
］
⇒
~RET %候補
◎
Otherwise, for each priority candidate PC in order specified, check if PC is a viable candidate in S. If so, select it as an anchor node and terminate.
</li>
	<li>
<p>
%~node の~EACH( 子~node %N ) に対し：
</p>
		<ol>
			<li>
%結果 ~LET `候補~審査~algo$( %N, %S ) を遂行した結果
</li>
			<li>
~IF［
%結果 ~NEQ ε
］
⇒
~RET %結果
</li>
		</ol>
◎
Otherwise, for each DOM child N of the element or document associated with S, perform the candidate examination algorithm for N in S, and terminate if it selects an anchor node.
</li>
	<li>
~RET ε
</li>
</ol>
</div>

<div class="algo">
<p>
`候補~審査~algo@
は、所与の
( 候補~node %N, `~scrollされる~box$ %S )
に対し，次を走らす：
◎
The candidate examination algorithm for a candidate DOM node N in a scrolling box S is as follows:
</p>

<ol>
	<li>
~IF［
 %N は %S 内の`除外~下位tree$である
］~OR［
 %N は %S 内で`全部的に切取られて$いる
］
⇒
~RET ε
（ %N とその子孫は飛ばされる。）
◎
If N is an excluded subtree, or if N is fully clipped in S, then do nothing (N and its descendants are skipped).
</li>
	<li>
~IF［
 %N は %S 内で`全部的に可視$である
］
⇒
~RET %N
◎
If N is fully visible in S, select N as the anchor node.
</li>
	<li>
~Assert：
%N は %S 内で`部分的に可視$である
◎
If N is partially visible:
</li>
	<li>
<p>
%N の~EACH( 子~node %C ) に対し
</p>
		<ol>
			<li>
%結果 ~LET `候補~審査~algo$( %C, %S ) を遂行した結果
</li>
			<li>
~IF［
%結果 ~NEQ ε
］
⇒
~RET %結果
</li>
		</ol>
◎
For each DOM child C of N, perform the candidate examination algorithm for C in S, and terminate if it selects an anchor node.
</li>
	<li>
<p>
%N を`包含塊$とする ~EACH( 要素 %A ) に対し：
</p>
		<ol>
			<li>
~IF［
%A の親~node ~EQ  %N
］~OR［
%A は`絶対的に位置され$ていない
］
⇒
~CONTINUE
</li>
			<li>
%結果 ~LET `候補~審査~algo$( %A, %S ) を遂行した結果
</li>
			<li>
~IF［
%結果 ~NEQ ε
］
⇒
~RET %結果
</li>
		</ol>
◎
For each absolutely-positioned element A whose containing block is N, but whose DOM parent is not N, perform the candidate examination algorithm for A in S, and terminate if it selects an anchor node.
</li>
	<li>
~RET %N 
（この段に達したなら、 %N の子孫には，相応しい~anchor~nodeは見出せなかったことになる。）
◎
Select N as the anchor node. (If this step is reached, no suitable anchor node was found among N’s descendants.)
</li>
</ol>
</div>

<p class="note">注記：
変化する内容が［
~anchor~nodeの内側にありつつ，表示域の外側にある
］可能性を最小限にするため、なるべく深い~nodeが選好される。
そのような変化は、~scroll~anchor法の調整を誘発することなく，可視な内容をズラすので。
◎
Note: Deeper nodes are preferred to minimize the possibility of content changing inside the anchor node but outside the viewport, which would cause visible content to shift without triggering any scroll anchoring adjustment.
</p>

<p>
概念的には、ある`~scrollされる~box$の~scroll位置が変化する度に，各~scrollされる~boxごとに新たな~anchor~nodeが算出される。
（処理能の最適化として，実装は、当の~anchor~nodeが必要になるまで，その算出-を待機してヨイ）
◎
Conceptually, a new anchor node is computed for every scrolling box whenever the scroll position of any scrolling box changes. (As a performance optimization, the implementation may wait until the anchor node is needed before computing it.)
</p>

<p>
要素~node %要素 は、次のいずれかを満たすならば
`~scrollされる~box$ %S 内の
`除外~下位tree@
とされる：
◎
A DOM node N is an excluded subtree if it is an element and any of the following conditions holds:
</p>

<ul>
	<li>
%要素 の `display$p ~propの算出d値 ~EQ `none^v
◎
N’s computed value of the display property is none.
</li>
	<li>
%要素 の `position$p ~propの 算出d値 ~EQ `fixed^v
◎
N’s computed value of the position property is fixed.
</li>
	<li>
［
 %要素 の `position$p ~propの算出d値 ~EQ `absolute^v
］~AND［
%要素 の`包含塊$は %S の先祖である
］
◎
N’s computed value of the position property is absolute and N’s containing block is an ancestor of the scrolling box.
</li>
	<li>
%要素 の `overflow-anchor$p ~propの算出d値 ~EQ `none$v
◎
N’s computed value of the overflow-anchor property is none.
</li>
</ul>

<p>
所与の
~node %N, `~scrollされる~box$ %S
に対し：
◎
↓</p>

<ul>
	<li>
%N は %S 内で
`全部的に可視@
であるとは、次を意味する
⇒
%N の`~scroll~anchor用の限界矩形$全体が %S の`最適な~view用~領域$の内側にある
◎
A DOM node N is fully visible in a scrolling box S if N’s scroll anchoring bounding rect is entirely within the optimal viewing region of S.
</li>
	<li>
%N は %S 内で
`全部的に切取られて@
いるとは、次を意味する
⇒
%N の`~scroll~anchor用の限界矩形$全体が %S の`最適な~view用~領域$の外側にある
◎
A DOM node N is fully clipped in a scrolling box S if N’s scroll anchoring bounding rect is entirely outside the optimal viewing region of S.
</li>
	<li>
%N は %S 内で
`部分的に可視@
であるとは、次を意味する
⇒
［
%N は %S 内で`全部的に可視$でない
］~AND［
%N は %S 内で`全部的に切取られて$いない
］
◎
A DOM node N is partially visible in a scrolling box S if N is neither fully visible in S nor fully clipped in S.
</li>
</ul>

<p>
~node %N の
`~scroll~anchor用の限界矩形@
は、 %N の`~scroll可能な~overflow矩形$とする。
◎
The scroll anchoring bounding rect of a DOM node N is N’s scrollable overflow rectangle.
</p>

		</section>
		<section id="scroll-adjustment">
<h3 title="Scroll Adjustment">2.2. ~scroll調整</h3>

<div class="p">
<p>
~anchor~node %N （~NEQ ε ）を選定した~browserは、
%N が動いたときには，次を行う：
</p>

<ol>
	<li>
［
~scrollする内容の`塊-始端$辺
］から［
%N の`~scroll~anchor用の限界矩形$の`塊-始端$辺
］までの~offset
— 動く前の~offset %y0, 動いた後の~offset %y1 —
を算出する。
<!-- ＊
~scroller＊~scroll容器？の`塊~flow方向$の
 -->
</li>
	<li>
［
~scroll位置を塊~flow方向に %y1 − %y0 だけ調整する手続き
］を，`抑止~窓$の終端で遂行されるように~queueする。
</li>
</ol>

◎
If an anchor node was selected, then when the anchor node moves, the browser computes the previous offset y0, and the current offset y1, of the block start edge of the anchor node’s scroll anchoring bounding rect, relative to the block start edge of the scrolling content in the block flow direction of the scroller.
◎
It then queues an adjustment to the scroll position of y1 - y0, in the block flow direction, to be performed at the end of the suppression window.
</div>
 
<p>
この~scroll調整は、
<a href="~CSSOMVIEW#scrolling-events">~scroll法</a>
`CSSOM-VIEW$r
の一部を成し，そこに記述される方式で `scroll$et ~eventを生成する。
◎
The scroll adjustment is a type of [[cssom-view-1#scrolling-events#scrolling]] as defined by [CSSOM-VIEW], and generates scroll events in the manner described there.
</p>

			<section id="suppression-window-1">
<h3 title="Suppression Window">2.2.1. 抑止~窓</h3>

<p>
~anchor~nodeの各~動きは
`抑止~窓@
（ suppression window ）と呼ばれる，ある時区間の中で生じる。
抑止~窓の始端と終端は、次に従って定義される：
◎
Every movement of an anchor node occurs within a window of time called the suppression window, defined as follows:
</p>

<ul>
	<li>
<p>
始端は、次に挙げる時点のうち，最も近過去の時点：
</p>
<ul ><li>`~event~loop処理~model$の現在の反復の始端
</li><li>完了した前回の抑止~窓の終端
</li></ul>
◎
The suppression window begins at the start of the current iteration of the HTML Processing Model event loop, or at the end of the most recently completed suppression window, whichever is more recent.
</li>
	<li>
<p>
終端は、次に挙げる時点のうち，最も近未来の時点：
</p>

<ul ><li>`~event~loop処理~model$の現在の反復の終端
</li><li>次に~scroll位置を変化させるような演算の直前（副作用による変化も含む
— 例えば， `getBoundingClientRect()$m の呼び出しなど）
</li></ul>

◎
The suppression window ends at the end of the current iteration of the HTML Processing Model event loop, or immediately before the next operation whose result or side effects would differ as a result of a change in the scroll position (for example, an invocation of getBoundingClientRect()), whichever comes sooner.
</li>
</ul>

<p class="note">注記：
抑止~窓の境界は、~scroll~anchor法~APIが安定化されたなら，~HTML標準に組入れられるべきである。
◎
Note: The suppression window boundaries should be incorporated into the HTML standard once the scroll anchoring API is stabilized.
</p>

<p>
~anchor~nodeの動きは、同じ抑止~窓の中で複数~回~生じ得る。
◎
More than one anchor node movement may occur within the same suppression window.
</p>

<p>
~UAは、［
抑止~窓の間に~queueされ, `抑止~誘因$により抑止されなかった
］すべての~scroll調整を，この窓の終端にて遂行する。
◎
At the end of a suppression window, the user agent performs all scroll adjustments that were queued during the window and not suppressed by any suppression trigger during the window.
</p>

			</section>
			<section id="suppression-triggers">
<h3 title="Suppression Triggers">2.2.2. 抑止~誘因</h3>

<p>
`抑止~誘因@
（ suppression trigger ）と称される一部の演算に対しては、それにより［
当の演算と同じ抑止~窓の中で生じた~anchor~nodeの動き
］に対する~scroll~anchor法の調整は，抑止される。
次のものが、`抑止~誘因$とされる：
◎
A suppression trigger is an operation that suppresses the scroll anchoring adjustment for an anchor node movement, if it occurs within the suppression window for that movement. These triggers are:
</p>

<ul>
	<li>
<p>
~anchor~nodeから~scroll可能な要素までの経路にある いずれかの要素（または文書）上での，次に挙げるいずれかの~propにおける算出d値の変化：
◎
Any change to the computed value of any of the following properties, on any element in the path from the anchor node to the scrollable element (or document), inclusive of both:
</p>

		<ul>
			<li>
各種`~inset~prop$
◎
top, left, right, or bottom
</li>
			<li>
`margin$p ~propとその下位prop
◎
margin or its longhands
</li>
			<li>
`padding$p ~propとその下位prop
◎
padding or its longhands
</li>
			<li>
`width$p, `height$p, `min-width$p, `max-width$p, `min-height$p, `max-height$p
◎
width, height, min-width, max-width, min-height, or max-height
</li>
			<li>
`position$p
</li>
			<li>
`transform$p
</li>
		</ul>
	</li>
	<li>
~scroll可能な要素（または文書）の中の いずれかの要素~上での［
その要素が`絶対的に位置され$るかどうかどうかを切り替える
］ような， `position$p ~propの算出d値の変化。
この誘因は、改変された要素が~anchor~nodeから~scroll可能な要素までの経路にあるかどうかに関わらず，適用されることに注意。
◎
Any change to the computed value of the position property on any element within the scrollable element (or document), such that the element becomes or stops being absolutely positioned. Note that this trigger applies regardless of whether the modified element is on the path from the anchor node to the scrollable element.
</li>
	<li>
~scroll可能な要素の~scroll~offsetは 0 である。
◎
The scroll offset of the scrollable element being zero.
</li>
</ul>

<p class="note">注記：
抑止~誘因が存在するのは、互換性を得る
— 既存の~web内容が~scroll~event~handlerで内容をズラしていることに因り，~scroll~anchor法と負な相互作用が生じるのを防ぐ —
ためである。
◎
Note: Suppression triggers exist for compatibility with existing web content that has negative interactions with scroll anchoring due to shifting content in scroll event handlers.
</p>

			</section>
		</section>
	</section>
	<section id="exclusion-api">
<h2 title="Exclusion API">3. 除外~API</h2>

<p>
~scroll~anchor法は、旧来の内容においても利用者が便益を得られるよう，起動時から既定の挙動になることを目指す。
~web~pageは、 `overflow-anchor$p ~propにより、~scroll~anchor法の一部または全部を任意選択で不能化したり，~DOM内のある部位を`~anchor~node選定~algo$から除外できる。
◎
Scroll anchoring aims to be the default mode of behavior when launched, so that users benefit from it even on legacy content. overflow-anchor can disable scroll anchoring in part or all of a webpage (opt out), or exclude portions of the DOM from the anchor node selection algorithm.
</p>

◎名 `overflow-anchor@p
◎値 `auto$v | `none$v
◎初 `auto$v
◎適 すべての要素
◎継 されない
◎百 受容しない
◎算 指定された~keyword
◎順 文法に従う
◎ア 離散的
◎表終

<p>
各種 値は、次に従って定義される：
◎
Values are defined as follows:
</p>

<dl class="val-def">
	<dt>`auto@v</dt>
	<dd>
要素 またはその先祖により作成される どの`~scrollされる~box$に対しても、［
要素は，`~anchor~node選定~algo$に関与するに適格である
］ものと宣言する。
◎
Declares that the element is potentially eligible to participate in the anchor node selection algorithm for any scrolling box created by the element or an ancestor.
</dd>

	<dt>`none@v</dt>
	<dd>
要素 またはその先祖により作成される どの`~scrollされる~box$に対しても、［
要素とその子孫（のうち，~scrollしている別の要素の内側に入子にされていないもの）は，`~anchor~node選定~algo$に関与するに適格でない
］ものと宣言する。
◎
Declares that the element and its descendants (that aren’t nested inside of another scrolling element) are not eligible to participate in the anchor node selection algorithm for any scrolling box created by the element or an ancestor.
</dd>
</dl>

<p class="note">注記：
`overflow-anchor$p に `none^v を指定した要素においては、子孫の~scroll~anchor法を  “オンに戻す” よう転じることはアリでない。
しかしながら，子孫`~scroll容器$では、（自前の`~scrollされる~box$用に）自動的に “オンに戻す” よう転じる
— それら子孫の `overflow-anchor$p も明示的に `none^v に設定しない限り。
◎
Note: It is not possible to turn scroll anchoring "back on" for descendants of a overflow-anchor: none element. However, descendant scroll containers automatically "turn it back on" (for their own scrolling box) unless they explicitly have overflow-anchor: none set on them as well.
</p>

<p class="note">注記：
`overflow-anchor^p ~propは
<a href="http://tabatkins.github.io/specs/css-sticky-scrollbars/">CSS Sticky Scrollbars</a>
用にも提案されているが（異なる値をとるものとして）、今や
<a href="https://tabatkins.github.io/specs/css-sticky-scrollbars/#intro">他に取って代わられた</a>。
◎
Note: The overflow-anchor property was also proposed (with different values) for CSS Sticky Scrollbars, which has now been superseded.
</p>
	</section>
	<section id="priv-sec">
<h2 title="Privacy and Security Considerations">~privacyと~securityの考慮点</h2>

<p>
この仕様は、~scroll位置の算出-法を調整するだけであり，新たな［
~privacy／~security
］の考慮点はない。
◎
This specification, as it only adjusts how we compute scroll positions, introduces no new privacy or security considerations.
</p>
	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-20200211">
2020年 2月 11日 作業草案からの変更点
◎
Changes Since the Feb 11 2020 Working Draft
</dt>
	<dd>
［
`実現可能な候補$, `優先~候補$の
］の定義を追加した。
◎
Added definitions of viable candidate and priority candidate.
</dd>
	<dd>
~scroll~anchor法と`~scroll留ng$との相互作用を明確化した。
◎
Clarified interaction between scroll anchoring and scroll snapping.
</dd>
</dl>

	</section>
</main></div>
