<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web Animations （日本語訳）</title>


<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
.informative {
	background: #EFE
}


#_dgm-timing-and-animation-models {
	display: flex;
	align-items: center;
}

#_dgm-timing-and-animation-models > span {
	display: block;
	max-width: 6em;
	margin: 0 0.5em;
	text-align: center;
	white-space: pre-line;
}
#_dgm-timing-and-animation-models > span:nth-child(even) {
	vertical-align: middle;
	border: solid black 1px;
	padding: 0.5em;
	border-radius: 0.5em;
	background: #FFDAB9;
	height: 3em;
}

x-fillmode {
	display: inline-block;
	white-space: nowrap;
}
x-fillmode > * {
	vertical-align: top;
	display: inline-block;
	padding: 0.2em;
	height: 2em;
	min-width: 10em;
}
x-fillbox:first-child {
	background: linear-gradient(to left, #AFEEEE, white);
}

x-fillbox:last-child {
	background: linear-gradient(to right, #AFEEEE, white);
}

x-fillbox:nth-child(2){
	background: #AFEEEE;
	border: solid gray 0;
	border-width: 0 0.15em;
}

x-fillbox.x-fillnone {
	background: white;
}

#_origin-boxes > div {
	display: block;
	border: solid black 0.1em;
	white-space: nowrap;
	max-width: 15em;
	padding: 0.2em;
}

x-hier {
	display: block;
	border:solid black 0.2em;
	padding: 0.5em 0;
	width: 80%;
	margin: auto;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	var source_data = {
		collectParts: Util.collectParts,
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	var link_map = this.link_map;
	var class_map = {
		r: 'ref',
		p: 'property',
		pe: 'pseudo',
		t: 'type', // value type
		v: 'value',
		et: 'event-type',
		e: 'element',
		a: 'attr',
		E: 'error',
		sl: 'js-slot',
		op: 'op',
		css: 'css',
	};
	var tag_map = {
		p: 'code',
		pe: 'code',
		t: 'var',
		css: 'code',
		et: 'code',
		E: 'code',
		I: 'code',
		m: 'code',
		v: 'code',
		e: 'code',
		a: 'code',
		sl: 'span',
		i: 'i',
		op: 'span',
		c: 'code',
		em: 'em',
		V: 'var',
	}
	return this.html.replace(
		/%[\w\-~一-鿆あ-ん\/]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	match = match.slice(1);
	var n = match.indexOf('\/');
	if(n <= 0) {
		return '<var>' + match + '</var>';
	}
	return (
'<var>'
+ match.slice(0, n)
+ '</var><sub>'
+ match.slice(n+1)
+ '</sub>'
	); // 添え字付き
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	break;
case 'pe': // pseudo-element
	text = '::' + key;
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl': // internal slot
	text = '[[' + key + ']]';
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
case 'sec':
	text = '§ ' + text;
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '"></a>';
	break;
case 'issue':
	text = 'issue#' + key;
	href = '~CSSissue/' + key;
	break;
default:
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">

●●options
spec_title:Web Animations
spec_date:2018-07-25
trans_update:2018-07-26
source_checked:180416
original_url:https://drafts.csswg.org/web-animations-1/
spec_status:ED
page_state_key:WANIM
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:css-anim,svg,css
conformance:css
copyright:2018,use
trans_1st_pub:2018-05-02


●●original_id_map

●●link_map
	●IDL

文書:~HTMLdom#the-document-object
	I.Document:~HTMLdom#document

I.Animatable:~WANIMAPI#animatable
I.Animation:~WANIMAPI#animation
I.AnimationPlaybackEvent:~WANIMAPI#animationplaybackevent
I.KeyframeEffect:~WANIMAPI#keyframeeffect
I.KeyframeEffectReadOnly:~WANIMAPI#keyframeeffectreadonly

m.playState:~WANIMAPI#dom-animation-playstate
m.type:~DOM4#dom-event-type
m.registerProperty:~CSSPROPVALAPI#dom-css-registerproperty
m.syntax:~CSSPROPVALAPI#dom-propertydescriptor-syntax
m.document.open:~HTMLdynamic#dom-document-open
m.Performance.now:~HRTIME#dom-performance-now
m.pending:~WANIMAPI#dom-animation-pending
m.updatePlaybackRate:~WANIMAPI#dom-animation-updateplaybackrate
m.target:~WANIMAPI#dom-keyframeeffectreadonly-target
m.currentTime:~WANIMAPI#dom-animationplaybackevent-currenttime
m.timelineTime:~WANIMAPI#dom-animationplaybackevent-timelinetime
m.finish:~WANIMAPI#dom-animation-finish
m.requestAnimationFrame:~HTMLGAPI#dom-window-requestanimationframe
m.navigationStart:~NAV-TIMING#dom-performancetiming-navigationstart

m.document.timeline.currentTime
	:~WANIMAPI#dom-animation-currenttime
	:~WANIMAPI#dom-animationtimeline-currenttime

	●JS
	jsI.iterator:~ES6#sec-well-known-symbols
sl.DefineOwnProperty:~ES6#sec-ordinary-object-internal-methods-and-internal-slots-defineownproperty-p-desc
sl.Get:~ES6#sec-ordinary-object-internal-methods-and-internal-slots-get-p-receiver

jA.EnumerableOwnNames:~ES6#sec-enumerableownnames
jA.GetIterator:~ES6#sec-getiterator
jA.GetMethod:~ES6#sec-getmethod
jA.IteratorStep:~ES6#sec-iteratorstep
jA.IteratorValue:~ES6#sec-iteratorvalue

~promise:~ES6#sec-promise-objects
	~Promise:~ES6#sec-promise-objects
	Promise.resolve:~ES6#sec-promise.resolve
	~PromiseCapability~record:~ES6#sec-promisecapability-records
	~PromiseCapability~record:~TC39#sec-promisecapability-records



	m.Element.animate:~WANIMAPI#extensions-to-the-element-interface

	●prop
p.animation-name:~CSSANIM#propdef-animation-name

	p.border-*-width:~CSSBG#border-width
p.border-bottom-width:~CSSBG#propdef-border-bottom-width
p.border-left-width:~CSSBG#propdef-border-left-width
p.border-right-width:~CSSBG#propdef-border-right-width
p.border-top-width:~CSSBG#propdef-border-top-width
p.border-color:~CSSBG#propdef-border-color
p.border-top-color:~CSSBG#propdef-border-top-color
p.border-top:~CSSBG#propdef-border-top
p.border-width:~CSSBG#propdef-border-width

p.float:~CSS2VISUREN#propdef-float
p.offset:https://drafts.fxtf.org/motion-1/#propdef-offset
p.transform:~TRANSFORM#propdef-transform
p.will-change:~CSSWILLCHANGE#propdef-will-change
p.writing-mode:~CSSWM#propdef-writing-mode
p.direction:~CSSWM#propdef-direction

t.custom-property-name:~CSSVAR#typedef-custom-property-name
t.length:~CSSVAL#length-value
t.timing-function:~CSSTIMING#typedef-timing-function
t.filter-value-list:~FILTEREFFECTS1#typedef-filter-value-list

a.min:~SVG11/animate.html#MinAttribute

et.cancel:#cancel-event
et.finish:#finish-event

	●用語
反復~組成-演算~型:#iteration-composite-operation
組成-演算~型:#composite-operation

組成-順序:#composite-order
組成d値:#composited-value
組成:#composition
組成~用の中立~値:#neutral-value-for-composition

累積-型:#composite-operation-accumulate
置換-型:#composite-operation-replace
加算-型:#composite-operation-add
累積-反復~型:#iteration-composite-operation-accumulate
置換-反復~型:#iteration-composite-operation-replace

加算:#animation-addition
加算-:#animation-addition
累積:#animation-accumulation
累積-:#animation-accumulation
作動~所要時間:#active-duration
作動~区間:#active-interval

作動~時刻:#active-time



~animate可能:#concept-animatable

~animation:#concept-animation
~animation~class:#animation-class
~animation効果:#animation-effect
~animation~event:#animation-events
~animation~frame:#animation-frame
~animation再生~event:#animation-playback-events
~animation型:#animation-type

~animation~prop名から~IDL属性~名を得る:#animation-property-name-to-idl-attribute-name
~IDL属性~名から~animation~prop名を得る:#idl-attribute-name-to-animation-property-name


処理待ち再生~rateがあれば適用する:#apply-any-pending-playback-rate

~targetにしている~animation:#associated-with-an-animation
	associated／associated with an animation:
結付けられている~animation:#associated-animation-of-an-animation-effect
	associated animation of an animation effect／associated with

既定の文書~時列線:#default-document-timeline
文書~時列線:#document-timeline
	作動中でない:#inactive-timeline
作動中:#inactive-timeline
時列線:#timeline
An.時列線:#_animation-timeline
時列線~現-時刻:#_animation-timeline-time
時列線が結付けられている:#associated-with-a-timeline


文書に属する:#timeline-associated-with-a-document
	associated with a timeline／associated with document／associated with／associated

起点に相対的な時刻へ変換する:#timeline-time-to-origin-relative-time
~animation時刻から時列線~時刻へ変換する:#animation-time-to-timeline-time
~animation時刻を起点に相対的な時刻へ戻す:#animation-time-to-origin-relative-time



欠落~keyframe~offsetを算出する:#compute-missing-keyframe-offsets
算出d~keyframe~offset:#computed-keyframe-offset
算出d~keyframe~list:#computed-keyframes

適合している~script化~WAnim~UA:#conforming-scripted-web-animations-user-agent

aT.色:#color-animation-type
aT.離散的:#discrete-animation-type
aT.長さ／百分率／~calc式:#length-percentage-or-calc-animation-type
aT.実数-:#real-number-animation-type
aT.変形-~list:#transform-list-animation-type

	完了~recordを~checkする:#check-the-completion-record

却下する:~PROMISES#reject-promise
解決する:~PROMISES#resolve-promise
新たな~promise:~PROMISES#a-new-promise
解決される~promise:~PROMISES#a-promise-resolved-with
	~promiseを却下する:#reject-a-promise
	~promiseを解決する:#resolve-a-promise
	新たな解決-済み~promise:#create-a-new-resolved-promise
	新たな処理待ち~promise:#_new-pending-promise


現在の完遂d~promise:#current-finished-promise
現在の準備済み~promise:#current-ready-promise

現-反復:#current-iteration


計時~用の文書:#document-for-timing

時刻~値:#time-value
現-時刻:#current-time
tL.現-時刻:#timeline-current-time
開始-遅延:#start-delay
終止-遅延:#end-delay
開始-時刻:#start-time
終止-時刻:#end-time

効果~stack:#effect-stack
効果~値:#effect-value

延伸~mode:#fill-mode

再生-状態:#play-state

i.完遂d:#finished-play-state
i.遊休中:#idle-play-state
i.静止中:#paused-play-state
i.稼働中:#running-play-state

i.効果~中:#in-effect
i.再生-中:#in-play
i.現在の:#current

相:#_phase
i.作動~相:#active-phase
i.事後~相:#after-phase
i.事前~相:#before-phase
i.遊休~相:#idle-phase

V.~animation方向:#animation-direction
V.作動~後~境界~時刻:#active-after-boundary-time
V.作動~前~境界~時刻:#before-active-boundary-time


大域~animation~list:#global-animation-list
保持-時刻:#hold-time


補間:#animation-interpolation

反復~回数:#iteration-count
反復~所要時間:#iteration-duration
反復~区間:#iteration-interval
反復~始端:#iteration-start

有向~進捗:#directed-progress
反復~進捗:#iteration-progress
総体~進捗:#overall-progress
単純~反復~進捗:#simple-iteration-progress
変形d進捗:#transformed-progress

~keyframe効果:#keyframe-effect
~keyframe~offset:#keyframe-offset
	offset of a keyframe
~keyframeに特有の組成-演算~型:#keyframe-specific-composite-operation
~keyframe:#keyframe

局所~時刻:#local-time
~offsetにより~looseに~sortされ:#loosely-sorted-by-offset

加法的でない:#not-additive
~animate不可:#concept-not-animatable
	＊~offset:#offsetk
起点~時刻:#origin-time

時列線を設定する:#set-the-timeline-of-an-animation
開始-時刻を設定する:#set-the-start-time
現-時刻を~silentに設定する:#silently-set-the-current-time
現-時刻を設定する:#set-the-current-time
対応する~event~target:#_event-target
~schedule済み~event時刻:#scheduled-event-time
~animationを取消す:#cancel-an-animation
~animationを完遂する:#finish-an-animation
完遂-通知~手続き:#finish-notification-steps

~animationを再生する:#play-an-animation
~animationを静止する:#pause-an-animation
~animationを逆転する:#reverse-an-animation
処理待ち~taskを再設定する:#reset-an-animations-pending-tasks
~target効果を設定する:#set-the-target-effect-of-an-animation

処理待ち~animation~event~queue:#pending-animation-event-queue
処理待ち静止-~task:#pending-pause-task
処理待ち再生-~task:#pending-play-task
処理待ち再生~rate:#pending-playback-rate
再生~rateを継目無く更新する:#seamlessly-update-the-playback-rate
再生~rateを設定する:#set-the-playback-rate

再生~方向:#playback-direction
再生~rate:#playback-rate
前回の現-時刻:#previous-current-time
準備済み:#ready

未解決:#unresolved
解決-済み:#unresolved-


~target効果~終端:#target-effect-end
~target効果:#target-effect
~target要素:#target-element
~target~prop:#target-property
	~prop／targeted

下層~値:#underlying-value

完遂d状態を更新する:#update-an-animations-finished-state
~animationを更新して~eventを送信する:#update-animations-and-send-events

sec.効果~stack:#the-effect-stack
sec.中核~animation効果の計算:#core-animation-effect-calculations
sec.算出d~keyframeの計算-法:#calculating-computed-keyframes
sec.作動~所要時間の計算-法:#calculating-the-active-duration
sec.作動~時刻の計算-法:#calculating-the-active-time
sec.有向~進捗の計算-法:#calculating-the-directed-progress
sec.効果~stackの結果の計算-法:#calculating-the-result-of-an-effect-stack
sec.単純~反復~進捗の計算-法:#calculating-the-simple-iteration-progress
sec.変形d進捗の計算-法:#calculating-the-transformed-progress
sec.~animationの取消法:#canceling-an-animation-section
sec.効果の結合-法:#combining-effects
sec.~keyframe効果の効果~値:#the-effect-value-of-a-keyframe-animation-effect
sec.効果の組成:#effect-composition
sec.延伸の挙動:#fill-behavior
sec.局所~時刻:#local-time-section
sec.~animationの静止-法:#pausing-an-animation-section
sec.~API:#programming-interface
sec.各種~animation~class:#animation-classes
sec.各種~相:#animation-effect-phases-and-states
sec.速度~制御:#speed-control
sec.~target効果の待機-法:#waiting-for-the-target-effect


	~keyframeに類する~objを処理する:~WANIMAPI#process-a-keyframe-like-object
~keyframes引数を処理する:~WANIMAPI#process-a-keyframes-argument

●外部

作動中の文書:~BROWSERS#active-document
	~associated:~BROWSERS#concept-document-window
~session履歴~entry:~HISTORY#session-history-entry
	持続的な利用者~状態を伴う
	:~HISTORY#an-entry-with-persisted-user-state

~media要素:~HEmedia#media-element
~DOM操作~task源:~WAPI#dom-manipulation-task-source
現在の大域~obj:~WAPI#current-global-object

	~animation~frame~callbackを走らす:~HTMLGAPI#run-the-animation-frame-callbacks
~animation~frame~callback:~HTMLGAPI#animation-frames

~event~loop処理~model:~WAPI#event-loop-processing-model
小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
	小task~checkpoint
小taskを~queueする:~WAPI#queue-a-microtask
~taskを~queueする:~WAPI#queue-a-task
関連する~Realm:~WAPI#concept-relevant-realm
描画を更新する:~WAPI#update-the-rendering

直前~flag:~CSSTIMING#before-flag

算出d値:~CASCADE#computed-value
	computed property values:~CASCADE#computed-value
~level:~CASCADE#origin

~CSS~propから~IDL属性を得る:~CSSOM1#css-property-to-idl-attribute
~IDL属性から~CSS~propを得る:~CSSOM1#idl-attribute-to-css-property


~eventを作成する:~DOM4#concept-event-create
配送する:~DOM4#concept-event-dispatch
~node文書:~DOM4#concept-node-document
~eventを構築する:~DOM4#constructing-events
子孫:~DOM4#concept-tree-descendant

~realm:~ES6#sec-code-realms
現在の~realm:~ES6#sec-execution-contexts

~custom~prop:~CSSVAR#custom-property

~CSS値を直列化する:~CSSOM1#serialize-a-css-value
積層~文脈:~CSSPOS#stacking-context


時刻~起点:~HRTIME#dfn-time-origin
	https://w3c.github.io/hr-time/#time-origin
計時~関数:~CSSTIMING#timing-function
線形~計時~関数:~CSSTIMING#linear-timing-function
入力~進捗~値:~CSSTIMING#input-progress-value
出力~進捗~値:~CSSTIMING#output-progress-value

~THROW:~WEBIDL#dfn-throw
投出され:~WEBIDL#dfn-throw
interface mixin:~WEBIDL#interface-mixin

●●
	他のリンク
sec.＊:#reaching-the-end
http://lists.w3.org/Archives/Public/public-fx/2013AprJun/0184.html
Animation Elements:https://svgwg.org/specs/animation-elements/
~TRANSFORM#interpolation-of-transforms
~SVG2#mime-registration
~CSSANIM#events
~TRANSITION:#transition-events
~CSSIMAGE#interpolating-images
~CSSVAL#calc-computed-value
http://www.endemolshine.com.au
https://github.com/w3c/web-animations/issues/186
https://github.com/w3c/web-animations/issues/201


●●words_table1
WANIMAPI:web-animations-api-ja.html
CSSPROPVALAPI:css-properties-values-api-ja.html
CSSWILLCHANGE:css-will-change-ja.html
NAV-TIMING:navigation-timing-ja.html
ES6:http://www.ecma-international.org/ecma-262/6.0/
	TC39:https://tc39.github.io/ecma262/

important:<code class="css">!important</code>

●●words_table

	●時間
moment::::時点
seek:
	~seekした:did seek
時列線:timeline:::~:タイムライン

所要時間:duration:::~
未解決:unresolved:::~
局所:local:::~:ローカル
大域:global:::~:グローバル
時刻:time:::~
時間:time:::~
	時刻に基づく:timed
時刻印:timestamp:::~
	かかる時間は一定:constant-time
時系列順:chronological:::~
時系列順の:chronological な:::~
時計:clock:::~
	現実の時計:wall-clock／:wallclock
時制:temporal:::~
秒:seconds:::~
今:now::~
計時:timing:::~
起点:origin:::~
原点:origin::~

開始-:start:::~
	開始し直す:restart
始端:start:::~
終止-:end:::~
終端:end:::~
終端点:endpoint:::~
端点:endpoints:::~
終端除外:endpoint-exclusive:::~

期間:period:::~
	期間:period of time
区間:interval:::~
空間:space:::~
総体:overall::総
精度:precision::~
精確:precise::~

	なし:none
前方:forwards:::~
後方:backwards:::~
両方:both:::~
	後:after
	前:before
	直前:before

micro-::::マイクロ
milli-::::ミリ
	micro-秒:microsecond
	milli-秒:milliseconds

上界:upper bound:::~
下界:lower bound:::~
有界:bounded:::~
	有界でない
事後:after:::~
事前:before:::~

延伸:fill:::~
範囲:range:::~
重合して:overlap して::重なり合って
重合する:overlap する::重なり合う
重合しな:overlap しな::重なり合わな
	排他的でない:overlap
境界:boundary:::~
限界域:bounds:::~

	●変形
loose:
伸縮-:scale:::~
伸縮:scaling:::~
	伸縮-率:scaling factor:~
	伸縮-率:scale
速度:speed:::~
進捗:progress:::~
offset:
	:::オフセット
遅延:delay:::~

変形-:transform:::~
変形:transformation:::~
変形d:transformed:::変形済み
変換-:convert:::~
変換:conversion:::~
減少-:decrease:::~
増加-:increase:::~
	増える:increase
有向:directed:::~

	●補間／演算
補間-:interpolate:::~
補間:interpolation:::~
外挿-:extrapolate:::~
外挿:extrapolation:::~

切詰めら:clamp さ:切り詰めら
基底:base:::~
演算-:operate:::~
演算:operation:::~

無限大:infinity:: ∞ 
無限大頻度:infinitely high frequency:~
実数:number:::~
実数-:real number:::~
数量:numeric:::~
有符号:signed:::~
有限:finite:::~
総和:sum:::~
加重平均:weighted sum:::~
行列:matrix:::~
累積-:accumulate:::~
累積:accumulation:::~
組成-:composite:::~
組成d:composited:::組成
組成:composition:::~
結合-:combine:::~
可換:commutative:::~
解決-:resolve:::~
解決:resolution:::~
計算-:calculate:::~
計算:calculation:::~
等価:equivalent:::~
等式:equation:::~
離散的:discrete:::~
割合分:fraction::~
	範囲 [0, 1] に入る:fractional
線形:linear:::~
	線形でない:non-linear
加法的:additive:::~
加算-:add:::~
加算:addition:::~
乗算-:multiply:::~
乗算:multiplication:::~
乗算済み:premultiplied:::~
	~MUL:multiplying
除算-:divide:::~

中間:intermediate::~
比較-:compare::~
比較:comparison::~
評価-:evaluate::~
	評価し直され:re-evaluated
差分:delta::~
切落とさ:cut-off さ::~
中間点:half-way:~

	●animate／再生／効果
animate:
	:::アニメート
	~animate可能:animatable
	~animate不可:not animatable
animation:
	:::アニメーション
完了-:complete:::~
	完了-:run to completion
完了:completion:::~
完遂-:finish:::~
finish:
完遂d:finished:::完遂
	完遂するとき:finishing
遊休:idle:::~
遊休中:idle:::~

実効:effective:::~
静止-:pause:::~
静止中:paused:::~
下層の:underlying:::~
下層:underlying:::~
休止-:suspend:::~
	遅めて:slow down して:~
保持-:hold:::~
方向:direction:::~
待機-:wait:::~
巻戻し:rewinding:::~
自動巻戻し:auto-rewind:::~

稼働-:run:::~
稼働中:running:::~
稼働中の:running:::~
	稼働-:run:~
稼働時の:run-time:~

継目無く:seamless に:::~
継目無い:seamless な:::~
逆転-:reverse:::~
	逆方向:reverse direction
	逆に:reverse
逆方向:reverse:::~
順方向:forwards:::~
遷移:transition:::~
遷移効果:Transition:::~


繰返す:repeat する::繰り返す
繰返され:repeat され::繰り返され
繰返-:repeat::繰り返し
繰返:repetition::繰り返し
固定的な:fixed::~
不定:indefinite::~
停止-:stop:::~
再生-:play:::~
	再生するのを:playing
	再生し直す:replay
再生:playback:::~
再生機:player:::~
再開-:resume:::~
	始-:begin:~
始まる:begin する:::~
始める:begin する:::~
始めら:begin さ:::~
始まり:beginning:::~

相:phase:::~
効果:effect:::~
作動:active:::~:アクティブ
作動中の:active な:::~:アクティブな
作動中:active:::~:アクティブ
	作動中でない::inactive
反復:iteration:::~
取消され:cancel され:::取り消され
取消す:cancel する:::取り消す
	取消:cancel:取り消し
取消法:cancel 法:::取り消し法
	による効果がある:in effect
変化-:change::~
変更-:change::~
変更:change::~
変化-:change::~
変化:change::~
	進捗の向きに依存しない:directionless:~

cascade::::カスケード
rate::::レート
keyframe:
keyframes:
frame::::フレーム
schedule::::スケジュール
	~scheduleし直す:reschedule
連列-:sequence::~


	●CSS／呈示／UI
媒体:media::~::メディア
media::::メディア
成分:component::~
算出-:compute::~
算出d:computed::算出
calc:
gesture::::ジェスチャ
UI:
prop:property:::プロパティ
略式:shorthand:~
下位prop:sub-property::下位プロパティ
	下位prop:longhand
screen::::スクリーン
dialog::::ダイアログ
graphic::::グラフィック
	graphic的:graphical
graphics::::グラフィックス
modal::::モーダル
scroll::::スクロール
位置:position:~
	~scroll位置:scroll-position
宣言:declaration:~
宣言的:declarative:~
積層:stacking::~
呈示:presentation:~
描画:rendering:~
表示-:display:~
不透明度:opacity:~
単位:unit:~
横幅:width:~
長さ:length:~
	長さ 0 の:with zero-length
色:color:~
	緑色:green:~
	赤色:red:~
	黄色:yellow:~
疑似要素:pseudo-element:~
百分率:percentage:~
出自:origin::~
論理:logical::~
物理:physical::~

	●一般処理／データ型
callback::::
cancel:
checkpoint::::
class::::クラス
entry::::エントリ
event::::イベント
group::::グループ
handler::::ハンドラ
index:
interface::::インタフェース
item::::アイテム
list::::リスト
member::::メンバ
size::::サイズ
method::::メソッド
mixin::::
node::::ノード
obj:object:::オブジェクト
promise::::
	~promise:Promise object
call::::
	~cancel~event:cancelEvent
mode::::モード
pair::::ペア
空:empty::~
集合:set::~
parameter::::パラメタ
記録-:record::~::レコード
record::::レコード
sort::::ソート
	~sort法:sorting
stack::::スタック
target::::ターゲット
thread::::スレッド
	~thread等:process or thread
小task:microtask::小 task:小タスク
源:source::~
達-:reach::~
task::::タスク
照会-:query::~::クエリ
queue::::キュー
	~queueしてあった:queue up
flag::::フラグ
入力:input::~
出力:output::~
瞬時:instantaneous::~
即時:immediate::~
流れ:flow::~::フロー
process::::プロセス
処理-:process::~
処理:processing::~
処理待ち:pending::~
実行-:execute::~
実行:execution::~
走る:run する:~
走らす:run する:~
走らせ:run し:~
走って:run して:~
動作-:act::~
動作:action::~
報告-:report::~
失敗-:fail::~
同時的:simultaneous::~
同期-:synchronize::~
同期:synchronization::~
同期的:synchronous::~
非同期的:asynchronous::~
同期通知:synchronous に notify::~
先送り:defer::~
前倒し:bring forward::~
	:brought forward::~
中止-:abort::~
更新-:update::~
	更新-法:updating
準備済み:ready::~
滑らか:smooth::~
状態:state::~
無状態な:stateless な:::状態を保持しない
無状態:stateless:::状態を保持しない
	状態について:stative
安定:stable::~
再帰的:recursive::~
初期:initial::~
	初期~時には:initially
	初期~時には:originally
動的:dynamic::~
	-:parameter
status::::ステータス
順序:order::~
順序付け:ordering::~
順序付ける:order する::~
順序付けれ:order でき::~


	●IDL／event／DOM
例外:exception::~
構築子:constructor::~::コンストラクタ
属性:attribute::~
引数:argument::~
辞書:dictionary::~

値:value::~
名前:name::~
型:type::~

要素:element::~
親:parent::~
文書:document::~
	文書:doc
素片:fragment::~::フラグメント
片:fragment::~
文脈:context::~
木:tree::~::ツリー
子:child::~

却下-:reject::~
解決-:resolve::~
充足:fulfilment::~
	事由:reason
発火-:fire::~
発火:firing::~
配送-:dispatch::~
誘発-:trigger::~
投出-:throw::~
公開-:expose::~
送信-:send::~

●仕様
API:
	API:programming interface／application programming interface／の programming interface component
CSS:
DOM:
HTML:
IDL:
MIME:
SMIL:
SVG:
Web:
UA:user agent:UA
Unicode:
WAnim:Web Animations
JS:ECMAScript
model::::モデル
app:application:::アプリ
overhead::::オーバーヘッド
platform::::プラットフォーム
algo:algorithm:::アルゴリズム
approach::::アプローチ
debug::::デバッグ
bug::::バグ
computer::::コンピュータ
hardware::::ハードウェア
処理能:performance:~
役割:role:~
手段:means:~
手続き:procedure:~
下位手続き
	手続き的:procedural:~
方式:manner:~
技法:technique:~
技術:technologies:~
技術:technology:~
抽象:abstract:~
一般:general:~
一貫性:consistency:~
一貫する:consistent になる:~
事例:case:~
事実:fact:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
作者:author:~
単純:simple:~
	単純に:simply
問題:problem:~
	因り:due:~
	図式:diagram／Graphically
	可能／可能性もある:possible:~
実用:practical:~
	実用にならない:impractical:~
実質的:effective:~
将来:future:~
導入-:introduce:~
局面:scenario:~
後方互換:backwards-compatible:~
	必要:need:~
	必要とされ:necessary:~
	必要に応じて:as necessary
	必要はない:not necessary:~
情報:information:~
意味論:semantics:~
	でき得る限り:as best possible
有意:significant:~
	有意でない:insignificant
有意義:meaningful:~
望む:wish する:~
条件:condition:~
概念:concept:~
概して:typical に:~
用法:useage:~
用語:term:~
目的:purpose:~
直に:direct に:~
相似的:analogous:~
相応しい:suitable な:~
特別:special:~
特化-:specialize:~
特定0の:particular:ある特定の
特定の:specific な:~
特有:specific:~
特有の:specific な:~
特定の:specific な:~
	に特有の:-specific
	~~詳細を詰める:specific
特定的に:specifically:特に
	特定の:specifically
特色機能:feature:~
状況:situation:~
状況下:circumstances:~
	則って:according:~
通例の:usual な:~
通常の:normal な:~
適切:appropriate:~
適合性:conformance:~
適合-:conform:~
重要:important:~
関係性:relationship:~
無関係な:unrelated:~
非依存:agnostic:~
	難し:difficult:~
関連する:relevant な:~
編集者:editor:~
能力:capabilities:~
複雑:complex:~
要件:requirement:~
要求-:require:~
要約-:summarize:~
	-:summary
要請-:request:~
	見よ:see:~
見做す:assume する:~
記述:description:~
許可-:permit:~
許容-:allow:~
試験-:test:~
	試験-可能:testable
不変則:invariant:~
直感的:intuitive:~
相互作用-:interact:~
相互作用:interaction:~
副作用:side effect:~

発行版:publication:~
要因:factor:~
代替の:alternative な:~
関心:interest:~
	~~関心:concern
協力:contribution:~
履歴:history:~
規則:rule:~
規範的:normative:~
	規範的でない:non-normative
中核:core:~
規約:conventions:~
作業草案:Working Draft:~
	指す~refer
解-:understand:~
関係-:relate:~
文書化:documentation:~
明瞭:clear:~
	より良い:better
	感謝:gratitude
	概ね:roughly
	あるいは:alternatively
	の用語に基づいて:in terms of
	ていようが／関わらず:regardless
	何故:Why
	用途:of use
	大雑把には、:At a ~glance,
	~~理論上は:potentially
	主として:primarily
	便利／簡便に~convenience
	~~理想とは言えない:somewhat unfortunate
	真に:truly
	~~性質:qualities
	名目上:nominal
	見込まれ:likely
	必要とされ:necessarily
	理想的:ideally
	どう:how
	方法:how to
	かかわらず:despite
	するためには:in order to
	次のいずれかが満たされる:If any of the following are true:／If any of the following conditions are true:／Either of the following conditions are true:
	次のいずれも満たされる:both of the following conditions are true／all three of the following conditions are true／All of the following conditions are true／If the following three conditions are all satisfied:
	そのようなわけで:as such,
	同様に:likewise
	同様に:like
	〜可能／:able to
	一方で:whilst
	-:indeed
	おそらく:probably
	しかしながら，:however
	べき:should
	とにかく:if at all
	他の／~~後続の／さらに／それ以上の／他にも:further
	さらには:furthermore
	:in terms of
	-:we
	現実の:real-world
	任意選択で外す:opt out
	結果、／:~hence
	:such that
	-:matter
	誤り:mistake
	注記:note
	-:said
	に加えて:in addition to
	違って:unlike


●仕様（動詞
support::::サポート
	~supportされない:unsupported
予期-:expect:~
期待-:expect:~

	例:example:~
供-:provide:~
供せ:provide でき:~
依存-:depend:~
	依存しない:independent
	〜に依存する:dependent
依存関係:dependency:~
独立:independent:~
依拠-:rely:~
判別-:distinguish:~
	判別-可能:distinguishable
共通する:common な:~
共通の:common な:~
共通的に:common に:よく
共通的な:common な:よくある
判定基準:criteria:~

判断-:deem:~
利用-:use:~
	再~利用:re-use
利用者:user:~
	利用する側の責務:responsibility of the user
包摂-:encompass:~
奨励-:encourage:~
変更点:changes:~
孕む:involve する:~
孕まれ:involve され:~
定義-:define:~
	定義されない:undefined
	予め定義された:pre-defined
定義:definition:~
実装-:implement:~
実装:implementation:~
意向:intention:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
提案-:propose:~
支援-:assist:~
有用:useful:~
明確化-:clarify:~
明確化:clarification:~
検分-:inspect:~
検査-:check:~
概観:overview:~
求めら:want さ:~
組入れら:incorporate さ:組み入れら
組入れて:incorporate して:組み入れて
組入れる:incorporate する:組み入れる
特徴:characteristic:~
特徴付ける:characterize する:~

相違-:differ:~
確保-:ensure:~
競合:conflict:~
築いて:build して:~
築く:build する:~
築かれ:build され:~
簡便:convenient:~
環境設定-:configure:~
	環境設定-可能:configurable
汎用的:generic:~
	決して:never:~
決定-:determine:~
波及-:influence:~
影響-:affect:~
	扱う:treat:~
指定-:specify:~
指定d:specifid:指定
指示-:indicate:~
	挙動-:behave:ふるまう
挙動:behavior:ふるまい
遂行-:perform:~
達成-:achieve:~
適応-:accommodate:~
適用-:apply:~
適用:application:~
防止-:prevent:~
露に:exhibit:~
避ける:avoid する:~
統合-:integrate:~
統合:integration:~
統治-:govern:~
考える:consider する:~
考えた:consider した:~
見なし:consider し:~
見なさ:consider さ:~
見なせ:consider でき:~
落とし:drop し:~
被り:incur し:~
詳細な:detailed:~
資質:nature:~
述べた:describe した:~
述べる:describe する:~
述べら:describe さ:~
述べれ:describe でき:~
模倣-:emulate:~
説明-:explain:~
制御-:control:~
制御:control:~
制約:restriction:~
制限-:limit:~

推奨-:recommend:~
	推奨-:RECOMMENDED
図示-:illustrate:~
図示:illustration:~
例示-:demonstrate:~
移譲-:delegate:~
修正-:fix:~
分離-:separate:~
	分離:separation:
改訂-:revise:~
改称-:rename:~
廃用に:obsolete:~
後継:subsequent:~
序論:introduction:~
意外な:surprising:~
	〜に基づく:based／:-based
	謝辞:acknowledgement
	微調整:fine tune
	である限り:provided
	問い:question
	答える:answer
	~~機会:occasion
	弱められ:weaken
	進めれ:advance
	勧める:advised
	欲され:desirable
	〜とする:suppose
	理にかなう:sensible
	用立てる:make use of
	織り込まれている:falls out
	特に他が定義されない限り:Unless specifically defined otherwise
	気を散ら:distract the user’s attention
	と称される:referred to
	に注意:note that
	という:said to be
	記せる:can be written
	~~影響されない:no bearing
	気前よく懇切に:kind generosity and patience
	助力:help
	制作-:produce:~
	除いて:exceptして
	と呼ばれる:known
	かかり:commenced
	見受けられる:seem
	整合しなくなる:inconsistent
	手ほどき:introduce
	壊す:break
	従:follow
	-:proceed
	を除いて:with the exception


●未分類（動詞
address::::アドレス
	~address法:addressing
fade-out:fade out:::フェードアウト
print:
unload:
link::::リンク
text::::テキスト
存在-:exist::~
	無い:absence／:absent:~

保全-:preserve:~
保守-:maintain:~

入子に:nest:入れ子に


共有-:share:~
包含-:contain:~
参照-:reference:~
	参照-元:referencing
反映-:reflect:~
	~~反映:occur／:happen
合致-:match:~
照合-:match:~
	合致している:matching
	合致していない:non-matching
	合致していない:mismatched
	含-:include:~
	含めて:including:~


	対応-:correspond:~
導出-:derive:~
復旧-:restore:~
応答-:respond:~
応答:response:~
	応答して:in response to
抑制-:reduce:~
拡充-:populate:~
拡張-:extend:~
持続-:persist:~
挿入-:insert:~
接続-:connect:~
接続:connection:~
改変-:modify:~
改変:modification:~
最適化:optimization:~
	渡-:pass:~
	渡して:passing:~

格納-:store:~
無視-:ignore:~
	現れる:appear:~
	生じ:occur
登録-:register:~

	示す:show:~
移動-:move:~
組合せ:combination:~
結付け:associate:結び付け
結付けて:associate して:結び付けて
結付けら:associate さ:結び付けら
置換-:replace:~
	表す:express:~
表現-:represent:~
表現:representation:~
見出-:find:~
追跡-:track:~

生成-:generate:~
生産-:produce:~
確立-:establish:~
継承-:inherit:~

通知:notification:~
上書き:override:~
再設定する:reset する:設定し直す
設定-:set:~
初期設定:setup:~
付加-:append:~
前付加-:prepend:~
作成-:create:~
取扱い:handling:取り扱い
観測-:observe:~
	観測-可能:observable:~
読込んで:load して::読み込んで
	`load^et 読込-:load:~
調整-:adjust:~
走査-:traverse:~
通過-:passes through:~
連結-:concatenate:~
除去-:remove:~
除去:removal:~
隠され:hide され:~
追加-:add:~
追加:addition:~
追加の:additional:~

分解-:decompose:~
	分解-法:decomposing
合成-:synthesize:~
形成-:form:~
展開-:expand:~
操作:manipulation::~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
ズラされ:shift され:ずらされ
間隔法:spacing:~
束縛-:bind:~
	bound
	起こる:happen
	返す:return:~
	変わる:vary
	し続ける:continues to
	どこに~~挿入されるか:arrangement
	在る下で:presence
	欠く:lack
	行き着いた:arrive
	〜になった:became
	満たされ:met
	かかる:taken
	それを超えて~seekされた:overshot
	なる:become
	ままであり続ける:remain
	他へ遷移する:leave
	~RET:abort these steps
	~RET:abort this procedure
	ε にされる:disassociate
	入る／:fall
	占める:take place
	留められる:cap
	発生-:arise
	超えたかどうか:crossing
	過ぎ:past
	与-:give:~



●未分類
段:step:~:::ステップ
一意:unique:~
一時的:temporary:~
	一時的に:temporarily:~
silent:
	裏で

DVD:
cassette::::カセットテープ
channel::::チャネル
code::::コード
console::::コンソール
custom::::カスタム
filter::::フィルタ
jump::::ジャンプ
level::::レベル
	-:mark
markup::::マークアップ
page::::ページ
script::::スクリプト
scripting::::スクリプト処理
session::::セッション
navigate::::ナビゲート
資源:resource::~::リソース

source::::ソース
web::::
和集合:union:~
欠落:missing:~

外側:outside:~
内側:inside:~
外部:external:~
内部:internal:~
内部的:internal:~

層:layer::~
階層:hierarchy::~
階層的:hierarchical::~
深く:deep に:~
深い:deep な:~
	より深い:deeper
内容:content::~
座標:coordinate:~
機器:device::~::デバイス
相対的:relative::~
矩形:rectangle:~

既定の:default::~::デフォルト
既定:default::~::デフォルト
構文:syntax::~::シンタックス
符号位置:codepoint::~::コードポイント
	項:term
表記法:notation:~
妥当:valid::~
	妥当でない:invalid
自然:natural:~
複製:copy:~
距離:distance::~
	負の:negative:~
	正の:positive:~
関数:function::~
静的:static::~

放送:broadcast:~
	昇順に:in ascending order
高処理能:performant:~
入する:enter する:入る

	等し:equal:~
	節:section:~
	`id^a:id

●指示語
元の:original:~
現-:current::~
現在の:current::~
旧-:old::~
	%旧:unconstrained
新-:new::~
新たな:new::~
部分的:partial:~
	新たに:newly
既存の:existing:~
	現在:currently
	現時点では:currently
	超えて:beyond
	通:through
	上:above
	下:below
	両者:both
	単独の:single
	他の:other
	他の場合:otherwise
	代わりに:instead
	任意の:arbitrary
	依然として:still
	全体:entire
	その全体:entirely
	別々の:separate
	別の:another
	各:each
	同じ:same
	多い:often
	多くの:many
	同様に:similarly:~
	類似する:similar な
	似過ぎ:too similar
	似た様に:similar
	一致:identical
	常に:always
	常に〜とは限らない:not always the case
	所与の:given
	最初の:first
	最後の:last
	異なる:different
	様々な:various
	結果:result
	結果の:resulting
	複数の:multiple
	複数の:more than one
	種類／一種:kind
	〜の一種:a type of
	各／一連の:successive
	一連の:a series of
	だけ:merely
	の中でも特に:amongst
	一緒:together
	次に:followed by

	次回の:the next
	回数:number of times／:times
	回数:count
	回数-:
	各回ごと:each time
	2 回目の:second
	前回の／以前の:the previous
	前回までの:previous
	偶数回目:even
	奇数回目:odd
	最後の:final
	最終回:final
	毎回:every time
	2 回:twice
	2 倍にする:increase at twice


	個:two:three
	個目:first／:second／:third
	0:zero
	1 個まで:at most one
	1 つ以上:at least one
	少なくとも:at least
	ある種の:certain
	いくつかの:several
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	など:such as
	それら:they
	それらの:their
	それらの:those
	それらを:them
	それら自身:themselves

	次の:the following
	何らかの／いくつかの／もある:some
	ときどきある:sometimes
	~~今ある:present
	間:during
	少しばかり:few
	より少ない:fewer
	いくつかの:number of
	〜と同じく:as with〜
	についての:about
	いくつかの:a number of
	からなる:consists of

	すでに:already
	後続の:subsequent
	たびに／ごとに:every time／
	まだ:yet
	たびに:whenever
	まで:until
	〜間の:inter-
	それ以降は:longer
	長く／短くlonger or shorter
	より先に／〜まだ:prior to
	より早く／:earlier
	後で／より後に:later
	~earliest:#1
	それまで／:~previously:#2
	以前の:previous
	以降:there onwards
	になり次第:as soon as

	もっぱら:solely
	~most
	／:~final
	-:largest
	:next
	これら両〜:The different types of
	ここ:here
	先頭:beginning
	末尾:end
	一式として:as a whole
	ほぼ:largely
	部分:piece
	そこ:at which point
	地点:at the point
	箇所／地点:point
	基準点:point of reference
	直後にある:the next 〜after
	の所:mark
	前~段:previous step
	一部:part of
	一部を成す:part of
	上~層にある:layered on top／on top
	最後:at the top
	高い:high／higher／highest
	低い:lower
	先に現れるものほど:sort earlier
	指す:refer to
	部分／~part
	反対:opposite:
	による結果:final value
	最後に、:Finally

	~GTE:greater than or equal to
	~LTE:is less than or equal to
	~LT:less than
	~GT:greater than
	~EQ:equal to
	~NEQ:not equal to

●●

Transitions
Media Fragments
IEEE:
PromiseCapability:
Values and Units
Transition:
`px^css:pixel
勝つ:win
~~機会:chance
-:optional

始まり:beginning
始めて:begin して
始める:begin

外へ振り切らせる:overshoot
通り越して:beyond〜settling back
素早く:quick
交替する:alternative
交替的:alternative
遠い未来:far into the future
貼り付き続ける:sticky
存続する限り:for the lifetime of

相応する:proportional
空にする／~SET ε:clear
~~維持:retention-
:come
-:draw
:followed
:get
:goes
:going
:is set
~made
~non-matching
~place:
~queueing
-:substitute
-:substituting
:taken:taking:
-:in turn
ε:unset
~~間接的に:obscure
~NEQ `未解決$ is `解決-済み$
-:result of evaluating 
%旧-:unconstrained
一致する:coincident
0 の無限倍 result of infinity multiplied by zero
欄:line
~list／:~sequence
前回までの入力:sequence of inputs
-:finally
各種／~list／の集合:set of
-:firstly
浅いもの:shallow
~deep:#3
〜として~form
:long
文:~statement:#2
-:~in-flight:#1
~chapter:
加減速:easing
慣性感のある:sense of momentum
-:operand
RGBA
-:contiguous portion
-:thank
いったん／:once
~~生じた:cause
ない限り:only〜in the absence of
占める:span of
〜を伴わせて:along with
に対応する:indexed
食い違:at odds with
外から〜面:surface area
特質:property
%~finish~event:finishEvent
属する:belong


●●ref_normative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 30 November 2017. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-CASCADE-3]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 19 May 2016. CR. URL: https://www.w3.org/TR/css-cascade-3/ 
[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 14 January 2016. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-LOGICAL-1]
    Rossen Atanassov; Elika Etemad. CSS Logical Properties and Values Level 1. 18 May 2017. WD. URL: https://www.w3.org/TR/css-logical-1/ 
[CSS-POSITION-3]
    Rossen Atanassov; Arron Eicholz. CSS Positioned Layout Module Level 3. 17 May 2016. WD. URL: https://www.w3.org/TR/css-position-3/ 
[CSS-PROPERTIES-VALUES-API-1]
    Tab Atkins Jr.; et al. CSS Properties and Values API Level 1. 9 November 2017. WD. URL: https://www.w3.org/TR/css-properties-values-api-1/ 
[CSS-PSEUDO-4]
    Daniel Glazman; Elika Etemad; Alan Stearns. CSS Pseudo-Elements Module Level 4. 7 June 2016. WD. URL: https://www.w3.org/TR/css-pseudo-4/ 
[CSS-TIMING-1]
    Brian Birtles; et al. CSS Timing Functions Level 1. 21 February 2017. WD. URL: https://www.w3.org/TR/css-timing-1/ 
[CSS-TRANSITIONS-1]
    David Baron; Dean Jackson; Brian Birtles. CSS Transitions. 30 November 2017. WD. URL: https://www.w3.org/TR/css-transitions-1/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS-WILL-CHANGE-1]
    Tab Atkins Jr.. CSS Will Change Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-will-change-1/ 
[CSS-WRITING-MODES-3]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 3. 24 May 2018. CR. URL: https://www.w3.org/TR/css-writing-modes-3/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 24 May 2018. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS2]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-TRANSFORMS]
    Simon Fraser; et al. CSS Transforms Module Level 1. 30 November 2017. WD. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSS3VAL]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 29 September 2016. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMA-262]
    ECMAScript Language Specification. URL: https://tc39.github.io/ecma262/ 
[HR-TIME-2]
    Ilya Grigorik; James Simonsen; Jatinder Mann. High Resolution Time Level 2. 1 March 2018. CR. URL: https://www.w3.org/TR/hr-time-2/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[MEDIA-FRAGS]
    Raphaël Troncy; et al. Media Fragments URI 1.0 (basic). 25 September 2012. REC. URL: https://www.w3.org/TR/media-frags/ 
[MOTION-1]
    Dirk Schulze; Shane Stephens; Jihye Hong. Motion Path Module Level 1. 11 July 2017. WD. URL: https://www.w3.org/TR/motion-1/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 30 January 2018. CR. URL: https://www.w3.org/TR/selectors-3/ 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 
[SVG2]
    Nikos Andronikos; et al. Scalable Vector Graphics (SVG) 2. 15 September 2016. CR. URL: https://www.w3.org/TR/SVG2/ 
[WEBIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[HR-TIME]
    Jatinder Mann. High Resolution Time. 17 December 2012. REC. URL: https://www.w3.org/TR/hr-time/ 
[SMIL-ANIMATION]
    Patrick Schmitz; Aaron Cohen. SMIL Animation. 4 September 2001. REC. URL: https://www.w3.org/TR/smil-animation/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Web Animations</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新 発行バージョン
	https://www.w3.org/TR/web-animations-1/ 

以前のバージョン
	https://www.w3.org/TR/2016/WD-web-animations-1-20160913/ 
	https://www.w3.org/TR/2015/WD-web-animations-1-20150707/ 
	https://www.w3.org/TR/2014/WD-web-animations-20140605/ 
	https://www.w3.org/TR/2013/WD-web-animations-20130625/ 

バージョン履歴
	https://github.com/w3c/csswg-drafts/commits/master/web-animations-1 

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/web-animations-1">GitHub</a><!-- https://github.com/w3c/fxtf-drafts/labels/web-animations -->

編集
	<a href="mailto:bbirtles@mozilla.com">Brian Birtles</a> (Mozilla)
	<a href="mailto:shans@google.com">Shane Stephens</a> (Google Inc)
	<a href="mailto:dstockwell@google.com">Douglas Stockwell</a> (Google Inc)

前任編集者
	<a href="mailto:adanilo@google.com">Alex Danilo</a> (Google Inc)
	<a href="mailto:jackalmage@gmail.com">Tab Atkins</a> (Google Inc)

Participate
	<a href="https://github.com/w3c/csswg-drafts/tree/master/web-animations-1">Fix the text through GitHub</a>
	Join the ‘waapi’ channel on the <a href="https://damp-lake-50659.herokuapp.com/">Animation at Work</a> slack
	IRC: <a href="ircs://irc.w3.org:6667/webanimations">#webanimations</a> on W3C’s IRC

テスト
	<a href="https://github.com/web-platform-tests/wpt/tree/master/web-animations">web-platform-tests web-animations/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/web-animations">ongoing work</a>)

</script>


</head><body>

<!--%resource pool -->
<div id="_persisted_parts" style="display:none;">

<!-- 
<img
	id="_dgm-time-hierarchy"
	src="web-animations/time-hierarchy.svg"
	width="350"
	alt="A hierarchy of timing nodes"
>
 -->

<img
	id="_dgm-limiting"
	src="web-animations/limiting.svg"
	width="500"
	alt="The effect of limiting the current time of an animation."
>
<img
	id="_dgm-active-interval-examples"
	src="web-animations/active-interval-examples.svg"
	width="600"
	alt="Examples of the effect of the start delay on the endpoints of the active interval"
>
<img
	id="_dgm-animation-effect-phases-and-states"
	src="web-animations/animation-effect-phases-and-states.svg"
	width="700"
	alt="An example of the different phases and states used to describe an animation effect."
>
<!-- 
<img
	id="_dgm-animation-state-and-fill-behavior"
	src="web-animations/animation-state-and-fill-behavior.svg"
	width="600"
	alt="Examples of various fill modes and the states produced."
>
 -->
<img
	id="_dgm-iteration-intervals"
	src="web-animations/iteration-intervals.svg"
	width="600"
	alt="Comparison of the iteration duration and active time."
>
<img
	id="_dgm-iteration-count-and-start"
	src="web-animations/iteration-count-and-start.svg"
	width="600"
	alt="The effect of the iteration count and iteration start parameters"
>
<img
	id="_dgm-time-spaces"
	src="web-animations/time-spaces.svg"
	width="600"
	alt="A comparison of local time, active time, and iteration time."
>
<img
	id="_dgm-endpoint-exclusive-timing"
	src="web-animations/endpoint-exclusive-timing.svg"
	width="600"
	alt="Illustration of end-point exclusive timing."
>
<img
	id="_dgm-endpoint-exclusive-timing-and-fill"
	src="web-animations/endpoint-exclusive-timing-and-fill.svg"
	width="600"
	alt="Effect of iterations and fill on iteration time."
>
<img
	id="_dgm-active-duration-calculation"
	src="web-animations/active-duration-calculation.svg"
	width="600"
	alt="Calculation of the active duration."
>

<img
	id="_dgm-time-calculations"
	src="web-animations/time-calculations.svg"
	width="520"
	alt="Calculation of the active duration."
>

<!-- 
<img
	id="_dgm-animation-cascade"
	src="web-animations/animation-cascade.svg"
	width="500"
	alt="Overview of the application of effect values to their target properties"
>
 -->

</div>


<header>
	<hgroup>
<h1>Web Animations</h1>
	</hgroup>
</header>

<div id="MAIN" style="display: none;">

	<section id="abstract">
<h2 title="Abstract">~~要約</h2>

<p>
この仕様は、~web~pageの呈示に対する変化の同期と計時~用の~modelを定義する。
この仕様は、この~modelと相互作用するための~APIも定義する。
~~後続の仕様には、そのような特色機能を公開するための宣言的な手段を定義することが期待される。
◎
This specification defines a model for synchronization and timing of changes to the presentation of a Web page. This specification also defines an application programming interface for interacting with this model and it is expected that further specifications will define declarative means for exposing these features.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公開の複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status" >CSS 日本語訳 共通ページ</a>に委譲】
</p>

	</section>


<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この仕様は、~web~platform上の~animationと同期を~supportするための~modelを定義する。
他の仕様は、この~model上に自身による特色機能を築いて，宣言的~手段を通して公開することになるものと意図される。
加えて，この仕様は、この~modelに対し［
~scripting用の~supportを供する~UA
］が実装してよい~APIも定義する。
◎
Web Animations defines a model for supporting animation and synchronization on the Web platform. It is intended that other specifications will build on this model and expose its features through declarative means. In addition, this specification also defines a programming interface to the model that may be implemented by user agents that provide support for scripting.
</p>

		<section id="use-cases">
<h3 title="Use cases">1.1. 利用-事例</h3>

<p>
~WAnim~modelは
`CSS-TRANSITIONS-1$r,
`CSS-ANIMATIONS-1$r,
`SVG11$r
を表すために必要とされる特色機能を供するものと意図されている。
そのようなわけで，~WAnim~modelの利用-事例は、これらの仕様~用の利用-事例の和集合である。
◎
The Web Animations model is intended to provide the features necessary for expressing CSS Transitions [CSS-TRANSITIONS-1], CSS Animations [CSS-ANIMATIONS-1], and SVG [SVG11]. As such, the use cases of Web Animations model is the union of use cases for those three specifications.
</p>

<p>
利用-事例には、次に挙げる~API用のそれも含む：
◎
The use cases for the programming interface include the following:
</p>

<dl>
	<dt>

走っている~animationの検分-法
◎
Inspecting running animations
</dt>
	<dd>
<p>
~web~appは、何らかの状態を更新する前に，ある種の~animate化された効果が完了するのを待機し~MUSTことが多い。
この仕様における~APIは、そのような~appが
— CSS Transitions, CSS Animations, SVG ~animation
のどれで定義されていようが，~APIを利用して直に作成されていようが —
現在~稼働中の~animationすべてが完了するまで待機することを許容する。
◎
Often Web applications must wait for certain animated effects to complete before updating some state. The programming interface in this specification allows such applications to wait for all currently running animation to complete, regardless of whether they are defined by CSS Transitions, CSS Animations, SVG animations, or created directly using the programming interface.
</p>

<div class="example">

<pre class="lang-javascript">
/* <span class="comment">
要素を除去するより前に，すべての~animationが完遂するまで待機する
◎
Wait until all animations have finished before removing the element
</span> */
Promise.all(
  %elem.getAnimations().map(%animation =&gt; %animation.finished)
).then(() =&gt; %elem.remove());
</pre>

</div>


<p>
あるいは，~appは、~animationの再生~状態を待機することなく照会したいと望むこともある。
◎
Alternatively, applications may wish to query the playback state of animations without waiting.
</p>

<div class="example">

<pre class="lang-javascript">
const %isAnimating = %elem.getAnimations().some(
  %animation =&gt; %animation.playState === 'running'
);
</pre>

</div></dd>

	<dt>
稼働中の~animationの制御-法
◎
Controlling running animations
</dt>
	<dd>
<p>
~animationの再生~制御を，外部~入力に応答するように遂行できると有用になることはときどきある。
例えば、~modal~dialogを表示する前に，既存の~animationすべてを
— 利用者の気を散らさないよう —
静止することが必要とされることもあろう。
◎
It is sometimes useful to perform playback control on animations so that they can respond to external inputs. For example, it may be necessary to pause all existing animations before displaying a modal dialog so that they do not distract the user’s attention.
</p>

<div class="example">

<pre class="lang-javascript">
/* <span class="comment">
文書~内にある すべての既存の~animationを静止する
◎
Pause all existing animations in the document
</span> */
document.getAnimations().forEach(
  %animation =&gt; %animation.pause()
);
</pre>

</div>
	</dd>

	<dt>
~scriptからの~animationの作成-法
◎
Creating animations from script
</dt>

	<dd>
<p>
~animationを `requestAnimationFrame()$m `HTML$r を利用して~JSにより遂行することも可能であるが、そのような~animationの挙動は
— ［
それが~CSS~cascadeの用語に基づいて どう表現されるか
］, および［
~animationを別々の~thread等で遂行するなどの可能な処理能~最適化
］に関して —
宣言的な~animationとは異なる。
~WAnim~APIを利用すれば、~scriptからも，宣言的~animationと同じ挙動と処理能の特徴を備えた~animationを作成することが可能になる。
◎
While it is possible to use ECMAScript to perform animation using requestAnimationFrame [HTML], such animations behave differently to declarative animation in terms of how they are represented in the CSS cascade and the performance optimizations that are possible such as performing the animation on a separate thread. Using the Web Animations programming interface, it is possible to create animations from script that have the same behavior and performance characteristics as declarative animations.
</p>

<div class="example">

<pre class="lang-javascript">
/* <span class="comment">
素早く~fade-outする
◎
Fade out quickly
</span> */
%elem.animate({ transform: 'scale(0)', opacity: 0 }, 300);
</pre>

</div></dd>

	<dt>
~animationの~debug法
◎
Animation debugging
</dt>
	<dd>
<p>
複雑な~appにおいては、ある要素が~~今ある状態にどう行き着いたか決定するのが難しいこともある。
~WAnim~APIは、稼働中の~animationを検分して，
“この要素の不透明度は何故~変化しているか？”
などの問いに答えるために利用できる。
◎
In a complex application, it may be difficult to determine how an element arrived in its present state. The Web Animations programming interface may be used to inspect running animations to answer questions such as, “Why is the opacity of this element changing?”
</p>

<div class="example">

<pre class="lang-javascript">
/* <span class="comment">
%elem 上に不透明度~animationがあれば その `id^a を~printする
◎
Print the id of any opacity animations on elem
</span> */
%elem.getAnimations().filter(
  %animation =&gt;
    %animation.effect instanceof KeyframeEffect &amp;&amp;
    %animation.effect.getKeyframes().some(
      %frame =&gt; %frame.hasOwnProperty('opacity')
    )
).forEach(%animation =&gt; console.log(%animation.id));
</pre>

</div>

<p>
同様に，~animationを微調整するためには、その再生~rateを抑制して再生し直すことが必要とされることが多い。
◎
Likewise, in order to fine tune animations, it is often necessary to reduce their playback rate and replay them.
</p>

<div class="example">

<pre class="lang-javascript">
/* <span class="comment">
変形-~animationを遅めて再生し直す
◎
Slow down and replay any transform animations
</span> */
%elem.getAnimations().filter(
  %animation =&gt;
    %animation.effect instanceof KeyframeEffect &amp;&amp;
    %animation.effect.getKeyframes().some(
      %frame =&gt; %frame.hasOwnProperty('transform')
    )
).forEach(%animation =&gt; {
  %animation.currentTime = 0;
  %animation.updatePlaybackRate(0.5);
});
</pre>

</div>
	</dd>

	<dt>
~animationの試験-法
◎
Testing animations
</dt>
	<dd>
~animationを用立てる~appを試験するとき、そのような~animationが完了するまで待機していては実用にならないことが多い。
そのため、特定の時刻へ~animationを~seekすることが欲される。
◎
In order to test applications that make use of animations it is often impractical to wait for such animations to run to completion. Rather, it is desirable to seek the animations to specific times.
</dd>

</dl>

<div class="example">
<pre class="lang-javascript">
/* <span class="comment">
~animationの中間点へ
~seekして，不透明度は  50% になるかどうか検査する
◎
Seek to the half-way point of an animation and check that the opacity is 50%
</span> */
elem.getAnimations().forEach(
  %animation =&gt;
    %animation.currentTime =
      %animation.effect.getComputedTiming().delay +
      %animation.effect.getComputedTiming().activeDuration / 2;
);
assert.strictEqual(getComputedStyle(elem).opacity, '0.5');

/* <span class="comment">
~animationが完遂した後に，読込んでいる~screenが隠されるかどうか検査する
◎
Check that the loading screen is hidden after the animations finish
</span> */
%elem.getAnimations().forEach(
  %animation =&gt; %animation.finish()
);
/* <span class="comment">
~event~handlerが走る~~機会を得られるよう， 1 ~frameだけ待機する
◎
Wait one frame so that event handlers have a chance to run
</span> */
requestAnimationFrame(() =&gt; {
  assert.strictEqual(
    getComputedStyle(document.querySelector('#loading')).display, 'none');
});
</pre>

</div>


		</section>
		<section id="relationship-to-other-specifications">
<h3 title="Relationship to other specifications">1.2. 他の仕様との関係性</h3>

<p>
`CSS-TRANSITIONS-1$r,
`CSS-ANIMATIONS-1$r,
`SVG11$r
は、どれも~Web~page上に~animate化された内容を生成する仕組みを供する。
これらの仕様は、多くの類似する特色機能を供しているが，異なる用語で述べられている。
この仕様は、［
それらのどの仕様にも共通する特色機能を包摂する, かつ
それらの仕様の現在の挙動と後方互換になる
］ような，抽象~animation~modelを提案する。
すなわち，それらの挙動は
— その変化が観測-可能にならないように —
この~modelの用語に基づいて定義し直すことができる。
◎
CSS Transitions [CSS-TRANSITIONS-1], CSS Animations [CSS-ANIMATIONS-1], and SVG [SVG11] all provide mechanisms that generate animated content on a Web page. Although the three specifications provide many similar features, they are described in different terms. This specification proposes an abstract animation model that encompasses the common features of all three specifications. This model is backwards-compatible with the current behavior of these specifications such that they can be defined in terms of this model without any observable change.
</p>

<p>
~SVG 1.1 による~animation特色機能は、 `SMIL-ANIMATION$r の用語に基づいて定義される。
~WAnim~modelは、その用語に基づいて~SVGの~animation特色機能を定義することにより，~SVGと~SMILとの依存関係を除去できることが意図されている。
◎
The animation features in SVG 1.1 are defined in terms of SMIL Animation [SMIL-ANIMATION]. It is intended that by defining SVG’s animation features in terms of the Web Animations model, the dependency between SVG and SMIL Animation can be removed.
</p>

<p>
`HTML$r の`~animation~frame~callback$（ “`requestAnimationFrame$m” とも共通的に称される）と同じく，この仕様の~APIは、~animationを~scriptから作成できるようにする。
しかしながら，この仕様にて定義する~interfaceを利用して作成された~animationは、その全体が~UAにより実行される
— すなわち，~markupにより定義された~animationと同じ処理能の特徴を共有することになる。
この~interfaceを利用すれば、より単純かつ高処理能な方式で~scriptから~animationを作成することが可能になる。
◎
As with animation frame callbacks (commonly referred to as “requestAnimationFrame”) [HTML], the programming interface component of this specification allows animations to be created from script. The animations created using the interface defined in this specification, however, once created, are executed entirely by the user agent meaning they share the same performance characteristics as animations defined by markup. Using this interface it is possible to create animations from script in a simpler and more performant manner.
</p>

<p>
~APIの中で利用される時刻~値は、`~animation~frame~callback$
`HTML$r
にて利用されるそれらに対応し、それらの実行~順序は， 2 つの~interfaceが同時的に競合することなく利用できるように定義される。
◎
The time values used within the programming interface correspond with those used in animation frame callbacks [HTML] and their execution order is defined such that the two interfaces can be used simultaneously without conflict.
</p>


<p>
この仕様は、 `HTML$r にて定義される~interfaceに，いくつかの~APIを追加する。
◎
The programming interface component of this specification makes some additions to interfaces defined in HTML [HTML].
</p>
		</section>
		<section id="overview-of-this-specification">
<h3 title="Overview of this specification">1.3. この仕様の概観</h3>


<p>
この仕様は、まず，~animation用の抽象~modelを定義することから始め、次に，その用語に基づいて~APIを定義する。
この~APIに関連するのは，~scripting~supportを供する~UAに限られる。
◎
This specification begins by defining an abstract model for animation. This is followed by a programming interface defined in terms of the abstract model. The programming interface is defined in terms of the abstract model and is only relevant to user agents that provide scripting support.
</p>
		</section>
	</section>
	<section id="spec-conventions">
<h2 title="Specification conventions">2. 仕様~規約</h2>

<p class="trans-note">【
この節の和訳は省略する（和訳には不要な内容なので）。
】
◎
This specification begins by describing abstract concepts such as animations and animation effects and properties that belong to them such as their playback rate or iteration duration. In addition to these properties, there are often specific procedures for updating these properties such as the procedure to set the playback rate or the procedure to set the start time of an animation.
◎
Where this specification does not specifically link to a procedure, text that requires the user agent to update a property such as, “make animation’s start time unresolved”, should be understood to refer to updating the property directly without invoking any related procedure.
◎
Further documentation conventions that are not specific to this specification are described in Document conventions.
</p>

	</section>
	<section id="web-animations-model-overview">
<h2 title="Web Animations model overview">3. ~WAnim~modelの概観</h2>

~INFORMATIVE

<p>
大雑把には、~WAnim~modelは，ほぼ独立な役割を担う 2 つの部分からなる：
◎
At a glance, the Web Animations model consists of two largely independent pieces, a timing model and an animation model. The role of these pieces is as follows:
</p>

<dl>
	<dt>
計時~model
◎
Timing model
</dt>
	<dd>
時刻におけるある~momentを、`反復~進捗$と呼ばれる，~animationの 1 回の反復の中の相応する距離に変換する。
また `反復~index^i【`現-反復$ — 0 から数えて何回目の反復か】も記録される
— 繰返す各回ごとに変わる【累積される】~animationもあるので。
◎
Takes a moment in time and converts it to a proportional distance within a single iteration of an animation called the iteration progress. The iteration index is also recorded since some animations vary each time they repeat.
</dd>

	<dt>
~animation~model
◎
Animation model
</dt>
	<dd>
計時~modelにより生産される［
`反復~進捗$値, `反復~index^i
］を、~target~propに適用するための一連の値に変換する。
◎
Takes the iteration progress values and iteration indices produced by the timing model and converts them into a series of values to apply to the target properties.
</dd>
</dl>

<p>
この流れは、次のような図式に表現できる：
◎
Graphically, this flow can be represented as follows:
</p>

<figure>
<div
	id="_dgm-timing-and-animation-models"
	title="Overview of the operation of the Web Animations model."
>
<span>今</span>
→ <span>計時
~model</span>
→ <span>反復~進捗,
反復~index</span>
→ <span>~animation
~model</span>
→ <span>適用する値</span>
</div>
<figcaption>
~WAnim~modelの演算の概観：
現-時刻は計時~modelへの入力になり、それは反復~進捗~値と反復~indexを生産する。
これらは、~animation~modelへの入力として利用され，適用する値を生産する。
◎
Overview of the operation of the Web Animations model. The current time is input to the timing model which produces an iteration progress value and an iteration index. These parameters are used as input to the animation model which produces the values to apply.
</figcaption></figure>


<p>
例えば，次のような~animationを考える：
◎
For example, consider an animation that:
</p>

<ul>
	<li>
3 秒~後に開始する
◎
starts after 3 seconds
</li>
	<li>
2 回~稼働する
◎
runs twice,
</li>
	<li>
毎回 2 秒かかる
◎
takes 2 seconds every time, and
</li>
	<li>
矩形の横幅を `50px^v から `100px^v に変化させる。
◎
changes the width of a rectangle from 50 pixels to 100 pixels.
</li>
</ul>

<p>
最初の 3 項目は、計時~modelに適用される
— 時刻 6 秒 の時点では、~animationは 2 回目の反復の中間点になるべきと計算することになり、その結果として 0.5 を生産する。
次に，~animation~modelは、その情報を利用して横幅を計算する。
◎
The first three points apply to the timing model. At a time of 6 seconds, it will calculate that the animation should be half-way through its second iteration and produces the result 0.5. The animation model then uses that information to calculate a width.
</p>

<p>
この仕様は、まず計時~modelについて述べてから，~animation~modelについて述べる。
◎
This specification begins with the timing model and then proceeds to the animation model.
</p>

	</section>
	<section id="timing-model">
<h2 title="Timing model">4. 計時~model</h2>

<p>
この節では、~WAnim計時~modelの挙動について述べ，それを定義する。
◎
This section describes and defines the behavior of the Web Animations timing model.
</p>


		<section id="timing-model-overview">
<h3 title="Timing model overview">4.1. 計時~modelの概観</h3>

~INFORMATIVE

<p>
~WAnim計時~modelを特徴付ける特色機能には、
`無状態なこと^em（ `stateless^en ）,
`階層的^em
の 2 つがある。
◎
Two features characterize the Web Animations timing model: it is stateless and it is hierarchical.
</p>

			<section id="stateless">
<h4 title="Stateless">4.1.1. 無状態</h4>

~INFORMATIVE

<p>
~WAnim計時~modelは、入力~時刻から出力~反復~進捗を生産することにより演算する。
出力は もっぱら入力~時刻に基づき，前回までの入力には依存しないので、~modelは，無状態なものとして述べれる。
これにより、~modelには次の特質が備わる：
◎
The Web Animations timing model operates by taking an input time and producing an output iteration progress. Since the output is based solely on the input time and is independent of previous inputs, the model may be described as stateless. This gives the model the following properties:
</p>

<dl>
	<dt>
~frame~rateに依存しない：
◎
Frame-rate independent
</dt>
	<dd>
出力は前回までの入力に依存しないので、~modelが更新される~rateは，その進捗に影響しないことになる。
入力~時刻が現実の時計の時刻の進捗に相応する限り、~animationが進捗する~rateは，それを稼働させている機器の能力に関わらず 互いに一致することになる。
◎
Since the output is independent of previous inputs, the rate at which the model is updated will not affect its progress. Provided the input times are proportional to the progress of real-world time, animations will progress at an identical rate regardless of the capabilities of the device running them.
</dd>

	<dt>
方向に非依存
◎
Direction-agnostic
</dt>
	<dd>
前回までの入力は有意でないので、~modelは進捗の向きに依存しない（ `directionless^en ）。
すなわち，この~modelは、任意の~momentへ，何ら特化された取扱いを要求することなく更新できる。
◎
Since the sequence of inputs is insignificant, the model is directionless. This means that the model can be updated to an arbitrary moment without requiring any specialized handling.
</dd>

	<dt>
所与の時刻へ~seekするときにかかる時間は一定になる
◎
Constant-time seeking
</dt>
	<dd>
各~入力は，前回までの入力に依存しないので、~seek演算を遂行するために要求される処理は
— 遠い未来であろうが，少なくとも~~理論上は —
一定になる。
◎
Since each input is independent of the previous input, the processing required to perform a seek operation, even far into the future, is at least potentially constant.
</dd>
</dl>

<p>
この，無状態な計時~modelの挙動には、少しばかり例外がある：
◎
There are a few exceptions to the stateless behavior of the timing model.
</p>

<ul>
	<li>
この~modelに対する`~API$secにて定義する いくつかの~methodは、~animationを静止するなどの再生-制御を供する。
これらの~methodは、それが~callされた時刻に基づいて定義されるので，
【その時刻から導出される】
状態を保つ（ `stative^en ）。
これらの~methodは、主として便利~用に供されており，計時~modelの中核は成さないが その上~層にある。
◎
Firstly, a number of methods defined in the programming interface to the model provide play control such as pausing an animation. These methods are defined in terms of the time at which they are called and are therefore stative. These methods are provided primarily for convenience and are not part of the core timing model but are layered on top.
</li>
	<li>
同様に，~animationが
<a href="#reaching-the-end">完遂するときの挙動</a>
は、~animationの媒体（~target効果）の終止-時刻が動的に変更されたとき，それがいつ生じたかに依存して，生産される結果が異なり得ることを意味する。
この挙動は、~~理想とは言えないが直感的であり，~HTMLと一貫するものと判断されている。
結果として，この~modelは、`その計時~propが動的に変更されない限り^em，真に無状態なものとして述べれる。
◎
Similarly, the finishing behavior of animations means that dynamic changes to the end time of the media (target effect) of an animation may produce a different result depending on when the change occurs. This behavior is somewhat unfortunate but has been deemed intuitive and consistent with HTML. As a result, the model can only truly be described as stateless in the absence of dynamic changes to its timing properties.
</li>
	<li>
この~modelは、各回ごとに更新され，一時的な状態を確立するものと見なせる。
この一時的な状態は、`~API$secが返す値には影響するが 後続の更新には波及しないので，上で述べた無状態な~~性質と競合することはない。
◎
Finally, each time the model is updated, it can be considered to establish a temporary state. While this temporary state affects the values returned from the programming interface, it has no influence on the subsequent updates and hence does not conflict with the stateless qualities described above.
</li>
</ul>

			</section>
			<section id="hierarchical">
<h4 title="Hierarchical">4.1.2. 階層的</h4>

<p>
計時~modelを特徴付ける他の特色機能には、時刻が継承されることが挙げられる。
時刻は、ある`時列線$から始まり，何~段か~~経て各~animation効果へ~cascadeする。
各~段では、時刻は［
後方や前方へズラされる／伸縮される／逆転される／静止される／繰返される
］こともある。
◎
The other characteristic feature of the timing model is that time is inherited. Time begins at a timeline and cascades down a number of steps to each animation effect. At each step, time may be shifted backwards and forwards, scaled, reversed, paused, and repeated.
</p>

<figure>

	<div style="width:20em; text-align: center;">
<x-hier style="background:#90ee90; border-style:double;">時列線</x-hier>
		<div style="display:flex; width:100%; justify-content: space-around;">
			<div style="width:50%">
<div>　　↗</div>
<x-hier style="background:#dda0dd;">~animation</x-hier>
<div>↑</div>
<x-hier style="background:#afeeee; border-radius: 0.7em;">効果</x-hier>
			</div>
			<div style="width:50%">
<div>↖　　</div>
<x-hier style="background:#dda0dd;">~animation</x-hier>
<div>↑</div>
<x-hier style="background:#afeeee; border-radius: 0.7em;">効果</x-hier>
			</div>
		</div>
	</div>

<figcaption>
計時~nodeが成す階層。
木~内の各~nodeは、自身の時刻を自身の親~nodeから導出する。
◎
A hierarchy of timing nodes. Each node in the tree derives its time from its parent node.
</figcaption></figure>


<p>
仕様のこの~levelにおける階層は、浅いものである。
この仕様の後継~levelは、より深い計時~階層を許容する~group効果の概念を導入することになる。
◎
In this level of the specification the hierarchy is shallow. A subsequent level of this specification will introduce the concept of group effects which allows for deeper timing hierarchies.
</p>
			</section>
		</section>
		<section id="time-value-section">
<h3 title="Time values">4.2. 時刻~値</h3>

<p>
計時は、各~計時~node~間の時刻~関係性が成す階層に基づく。
親~nodeは、自身の子~nodeに計時~情報を`時刻~値$として供する。
◎
Timing is based on a hierarchy of time relationships between timing nodes. Parent nodes provide timing information to their child nodes in the form of time values.
</p>

<p>
`時刻~値@
は、ある~momentからの~milli-秒~数を表現する実数-である【（正の）無限大もとり得る】。
この~milli-秒は、名目上の~~単位であり，現実の時計（ `wall-clock^en ／ `wallclock^en ）における~milli-秒に一致するとは限らない
— それらの間の接続は、時刻~階層を通過する際に適用される値の変形【時間を伸縮するなど】により~~間接的にされ得る。
◎
A time value is a real number which nominally represents a number of milliseconds from some moment. The connection between time values and wall-clock milliseconds may be obscured by any number of transformations applied to the value as it passes through the time hierarchy.
</p>


<p class="note">注記：
将来においては、~scroll位置や~UI~gestureに基づく時列線なども~~導入され得る
— その事例では、時刻~値と現実の~milli-秒との間の接続は，さらに弱められることになる。
◎
In the future there may be timelines that are based on scroll position or UI gestures in which case the connection between time values and milliseconds will be weakened even further.
</p>

<p>
`時刻~値$は
`未解決@
にもなり得る
— 例えば、計時~nodeが`時刻~値$を生産する状態にない場合など。
【~APIの目的においては、`未解決$は ~NULL 値の別名とされる（すなわち、 `未解決$ ~EQ ~NULL ）。】
◎
A time value may also be unresolved if, for example, a timing node is not in a state to produce a time value.
</p>



		</section>
		<section id="timelines">
<h3 title="Timelines">4.3. 時列線</h3>

<p>
`時列線@
（ `timeline^en ）は、同期の目的で，~sourceの`時刻~値$を供する。
【概念的には、無数の［何かに対応する時刻~値］からなる，時系列順の（離散的な）並びが成す（連続的な）線。】
◎
A timeline provides a source of time values for the purpose of synchronization.
</p>



<p>
`時列線$は、所与の任意の~momentに，ある`時刻~値$をとる
— それは、時列線の
`現-時刻@tL
と呼ばれる。
【 対して，以下に現れる “時列線~時刻” は、時列線が含み得る任意の時刻~値を表す。】
◎
At any given moment, a timeline has a single current time value known simply as the timeline’s current time.
</p>

<p>
`時列線$は、常に有意義な`時刻~値$を返せるとは限らず，`未解決$を返す場合もある。
例えば、まだ生じていないかもしれないある~moment
— 文書の `load^et ~eventの発火など —
に相対的に定義されている`時列線$など。
`時列線$は、その`現-時刻$tLが`未解決$にならない間は
`作動中@
である（ `active^en ）とされ，`未解決$になる間は
`作動中$でない（ `inactive^en ）とされる。
◎
A timeline may not always be able to return a meaningful time value, but only an unresolved time value. For example, it may be defined relative to a moment that has yet to occur, such as the firing of a document’s load event. A timeline is considered to be inactive when its time value is unresolved.
</p>

<p>
特定の型の`時列線$には、時列線~時刻を
`起点に相対的な時刻へ変換する@
手続きを定義するものもある
— `時刻~値$と［
現実の時計に基づく時列線により生産される`時刻~値$
］は、それを通して比較できるようになる。
◎
Specific types of timelines may define a procedure to convert a timeline time to an origin-relative time for time value time, so that the time values produced by wallclock-based timelines can be compared.
</p>

<p>
`時列線$には
`文書に属する@
とされるものもある。
◎
A timeline may be associated with a document.
</p>

<p class="algo-head">
`~animationを更新して~eventを送信する@
ときは、所与の
( `文書$ %文書, 時刻印 %今 )
に対し，次を走らす：
◎
When asked to update animations and send events for a Document doc at timestamp now, run these steps:
</p>

<ol>
	<li>
<p>
~EACH( %文書 <a href="#timeline-associated-with-a-document">に属する時列線</a> %時列線 )
に対し
⇒
( 時刻印 %今 ) を渡して， %時列線 の`現-時刻$tLを更新する
◎
Update the current time of all timelines associated with doc passing now as the timestamp.
</p>

<p class="note">注記：
計時~modelが成す階層的な資質に因り，`時列線$の`現-時刻$tLを更新することは、その時列線を接続-先とする各`~animation$に対しても，次を行うことを孕む
⇒＃
~animationの`現-時刻$を更新する ／
~animation用に`完遂d状態を更新する$ ／
~animation用に`~animation~event$を~queueする
◎
Due to the hierarchical nature of the timing model, updating the current time of a timeline also involves:
• Updating the current time of any animations associated with the timeline.
• Running the update an animation’s finished state procedure for any animations whose current time has been updated.
• Queueing animation events for any such animations.
</p>

	</li>
	<li>
<p>
`小task~checkpointを遂行する$
◎
Perform a microtask checkpoint.
</p>

<p class="note">注記：
これは、前~段にて時列線を更新する一部として，~promiseを［
解決する／却下する
］
— その結果として、~queueしておかれた どの小taskも［
~animation~eventを配送するに先立って，~promiseの~callbackを走らす
］ことを確保する。
◎
Note: This is to ensure that any microtasks queued up as a result of resolving or rejecting Promise objects as part of updating timelines in the previous step, run their callbacks prior to dispatching animation events.
</p>
	</li>
	<li>
%配送する~event~list ~LET %文書 の`処理待ち~animation~event~queue$の複製
◎
Let events to dispatch be a copy of doc’s pending animation event queue.
</li>
	<li>
%文書 の`処理待ち~animation~event~queue$を空にする
◎
Clear doc’s pending animation event queue.
</li>
	<li>
<p>
%配送する~event~list 内の`~animation~event$を，それぞれの`~schedule済み~event時刻$
— 以下、単に `時刻^i —
に基づいて，次に従う順序に~sortする：
◎
Perform a stable sort of the animation events in events to dispatch as follows:
</p>
		<ol>
			<li>
`時刻^i は`未解決$でないものどうしは、 `時刻^i の~~昇順にする
— 早く生じる~eventほど、前に来るよう。
◎
Sort the events by their scheduled event time such that events that were scheduled to occur earlier, sort before events scheduled to occur later and＼
</li>
			<li>
`時刻^i は`未解決$であるものは、`未解決$でないものより前に来る。
◎
events whose scheduled event time is unresolved sort before events with a resolved scheduled event time.
</li>
			<li>
`時刻^i が等しいものどうしは、それぞれの`組成-順序$に従う。
◎
Within events with equal scheduled event times, sort by their composite order.
</li>
			<li>
以上により順序が決まらないものどうしは、元の順序を保つとする
— すなわち，安定~sortする。
◎
↑</li>
</ol>


<p class="note">注記：
~eventを~sortする目的は、［
能力が相違しているため ~frame~rateが異なる機器どうしの間でも，~eventが配送される順序は一貫する
］ことを，でき得る限り確保することである。
◎
Note: The purpose of sorting events is to ensure that, as best possible, even on devices with differing capabilities and hence different frame rates, events are dispatched in a consistent order.
</p>

<p class="note">注記：
安定~sortする要件は、［
同じ~schedule済み~event時刻で~queueされた，複数の~event
］の順序を保全するためにある。
例えば、所要時間 0 の~CSS~animationは、
`animationstart^et, `animationend^et
両~eventを~~同時に配送し得る。
◎
Note: The requirement for the sort to be a stable sort is because sometimes events may be queued with the same scheduled event time. For example, a CSS animation with a duration of zero, may dispatch both an animationstart and an animationend event and the order of these events should be preserved.
</p>
	</li>
	<li>
%配送する~event~list 内の~EACH( %~event ) に対し（前~段にて確立された順序で）
⇒
~eventに`対応する~event~target$に向けて， %~event を`配送する$
◎
Dispatch each of the events in events to dispatch at their corresponding target using the order established in the previous step.
</li>
</ol>

<p>
この手続きが呼出される各回は、簡便に，
“新たな
`~animation~frame@
を確立する”
と述べられることが多い。
［
`~animation$ ／ `~animation効果$
］の計時~propの変化や,
~objの［
追加／除去
］も，計時や~animation~modelの出力を変化させ得るが、これらの演算は 現在の`~animation~frame$を更新するだけで，新たな`~animation~frame$は作成しない。
◎
It is often convenient to describe each time this procedure is invoked as establishing a new animation frame. Changes to the timing properties of animations or animation effects, or the addition and removal of the objects may cause the output of the timing or animation model to change, but these operations in themselves do not create a new animation frame, rather they merely update the current animation frame.
</p>
			<section id="document-timelines">
<h4 title="Document timelines">4.3.1. 文書~時列線</h4>


<p>
`文書~時列線@
は、`文書に属する$`時列線$の一種であり，その`現-時刻$tLは［
`~animationを更新して~eventを送信する$手続きが走る各回ごとに供される，時刻印 %今
］から固定的な~offset後を指す時刻として計算される。
この固定的な~offset【すなわち， %今 ~EQ 0 であったとするときの現-時刻】は、文書~時列線の
`起点~時刻@
と称される。
◎
A document timeline is a type of timeline that is associated with a document and whose current time is calculated as a fixed offset from the now timestamp provided each time the update animations and send events procedure is run. This fixed offset is referred to as the document timeline’s origin time.
</p>


<p class="issue">
“起点~時刻” は “`時刻~起点$” に似過ぎるので、もっと良い用語が要る。
`2079$issue
◎
There must be a better term than “origin time”— it’s too similar to “time origin”. &lt;https://github.com/w3c/csswg-drafts/issues/2079&gt;
</p>

<p>
`文書~時列線$は、それが属する`文書$が次を満たしている間は，`作動中$でないとする
⇒
［
文書~用の`時刻~起点$は確立されていない
］~OR［
文書は`作動中の文書$でない
］
◎
Prior to establishing the time origin for its associated document, a document timeline is inactive.
◎
A document timeline that is associated with a Document which is not an active document is also considered to be inactive.
</p>

<p>
`文書~時列線$ %時列線
用の`起点に相対的な時刻へ変換する$手続きは、所与の
( 時列線~時刻 %時列線~時刻 )
に対し，次を返す
⇒＃
%時列線 は`作動中$でないならば `未解決$ ／
~ELSE_ ( %時列線~時刻 ~PLUS %時列線 の`起点~時刻$ )
◎
To convert a timeline time, timeline time, to an origin-relative time for a document timeline, timeline, return the sum of the timeline time and timeline’s origin time. If timeline is inactive, return an unresolved time value.
</p>
			</section>
			<section id="the-documents-default-timeline">
<h4 title="The default document timeline">4.3.2. 既定の文書~時列線</h4>

<p>
各`文書$は
`既定の文書~時列線@
と呼ばれる`文書~時列線$を有する。
`既定の文書~時列線$は、各~文書に一意であり，文書が存続する限り
— `document.open()$m への~callも含めて —
持続する。
`HTML$r
◎
Each Document has a document timeline called the default document timeline. The default document timeline is unique to each document and persists for the lifetime of the document including calls to document.open() [HTML].
</p>


<p>
`既定の文書~時列線$の`起点~時刻$は 0 とする。
◎
The default document timeline has an origin time of zero.
</p>

<div class="note">

<p>参考：
`文書~時列線$に供される時刻印~値 %今 には伸縮は適用されないので、それが生産する`時刻~値$は，現実の~milli-秒に相応する。
◎
This section is non-normative.
◎
Since no scaling is applied to the now timestamp values provided to document timelines, the time values it produces will be proportional to wall-clock milliseconds.
</p>

<p>
さらには、`既定の文書~時列線$の`時刻~値$は，`時刻~起点$からの~offsetは 0 なので、
`document.timeline.currentTime^m は，概ね
— `~animationを更新して~eventを送信する$手続きの各~callの合間では変化しないことを除いて —
`Performance.now()$m `HR-TIME$r に対応することになる。
◎
Furthermore, since the time values of the default document timeline have a zero offset from the time origin, document.timeline.currentTime will roughly correspond to Performance.now() [HR-TIME] with the exception that document.timeline.currentTime does not change in between calls to the update animations and send events procedure.
</p>

</div>

			</section>
		</section>
		<section id="animations">
<h3 title="Animations">4.4. ~animation</h3>

<p class="note">参考：
`時列線$の各~子~nodeは、~animationと呼ばれる。
~animationは、ある`~animation効果$
— 時刻に基づく何らかの挙動の静的な記述 —
を`時列線$に束縛して, 稼働するようにする。
~animationはまた、`~animation効果$と自身の`時列線$との合間の接続にて，稼働時の制御
— 静止する ／ ~seekする ／ 速度~制御 —
を供せるようにする。
~animationと`~animation効果$との関係性は、~DVD再生機と~DVDとの関係性に相似的である。
◎
This section is non-normative.
◎
The children of a timeline are called animations. An animation takes an animation effect which is a static description of some timed behavior and binds it to a timeline so that it runs. An animation also allows run-time control of the connection between the animation effect and its timeline by providing pausing, seeking, and speed control. The relationship between an animation and an animation effect is analogous to that of a DVD player and a DVD.
</p>

<p>
`~animation@
は、ある`~animation効果$をある`時列線$に接続して，再生~制御を供する。
<!-- ＊両者とも~optionalであり、環境設定-可能である -->
各`~animation$ %~animation には、次のものが結付けられる：
◎
An animation connects a single animation effect, called its target effect, to a timeline and provides playback control.＼
</p>

<dl>
	<dt>`時列線@An</dt>
	<dd>
%~animation の接続-先とされる`時列線$, または ~NULL （なし）。
</dd>
	<dd>
所与の~momentにおける %~animation の
`時列線~現-時刻@
は、［
%~animation の`時列線$Anは［
~NULL でない, かつ`作動中$である
］ならば その`現-時刻$tL（ ~NEQ `未解決$になる） ／
~ELSE_ `未解決$
］を返す。
</dd>
	<dd class="trans-note">【
この用語は、他所を簡潔に述べるためにこの訳に導入している。
】</dd>

	<dt>`~target効果@</dt>
	<dd>
%~animation により`時列線$Anに接続されることになる`~animation効果$,
または ~NULL （なし）。
◎
Both of these associations are optional and configurable such that an animation may have no associated target effect or timeline at a given moment.
</dd>

	<dt>`計時~用の文書@</dt>
	<dd>
%~animation の`時列線$Anは［
~NULL でない, かつ
ある`文書に属する$
］ならば その`文書$ ／
~ELSE_ ε（なし）。
◎
An animation’s document for timing is the Document with which its timeline is associated. If an animation is not associated with a timeline, or its timeline is not associated with a document, then it has no document for timing.
</dd>

	<dt>`開始-時刻@</dt>
	<dd>
`時刻~値$。
初期~時には`未解決$とする。
%~animation の`~target効果$が再生を始めるよう~scheduleされたなら、［
再生が始まった時点における %~animation の`時列線~現-時刻$
］になる値を表す。
◎
An animation’s start time is the time value of its timeline when its target effect is scheduled to begin playback. An animation’s start time is initially unresolved.
</dd>

	<dt>`保持-時刻@</dt>
	<dd>
`時刻~値$。
初期~時には`未解決$とする。
静止されているなどの状況下で，~animationの出力`時刻~値$
— すなわち， %~animation の`現-時刻$ —
を修正するために利用される。
◎
An animation also maintains a hold time time value which is used to fix the animation’s output time value, called its current time, in circumstances such as pausing. The hold time is initially unresolved.
</dd>
</dl>

<p>
`~animation$どうしの順序が互いに競合している場合に，それらの順序を確立するため、各~animationは，作成-順に
`大域~animation~list@
に付加される。
しかしながら，ある種の`~animation~class$は、それに属する~animationたちを代替の手段で順序付けることもある（`各種~animation~class$secを見よ）。
◎
In order to establish the relative ordering of conflicting animations, animations are appended to a global animation list in the order in which they are created. Certain classes of animations, however, may provide alternative means of ordering animations (see §5.5.1 Animation classes).
</p>
			<section id="setting-the-timeline">
<h4 title="Setting the timeline of an animation">4.4.1. ~animationの時列線の設定-法</h4>

<p class="algo-head">
`時列線を設定する@
手続きは、所与の
( %~animation, %新-時列線 （ ~NULL もとり得る） )
に対し，次を走らす：
◎
The procedure to set the timeline of an animation, animation, to new timeline which may be null, is as follows:
</p>

<ol>
	<li>
%旧-時列線 ~LET %~animation の`時列線$An
◎
Let old timeline be the current timeline of animation, if any.
</li>
	<li>
~IF［
%新-時列線 ~EQ %旧-時列線
］
⇒
~RET
◎
If new timeline is the same object as old timeline, abort this procedure.
</li>
	<li>
%~animation の`時列線$An ~LET %新-時列線
◎
Let the timeline of animation be new timeline.
</li>
	<li>
<p>
~IF［
%~animation の`開始-時刻$ ~NEQ `未解決$
］
⇒
%~animation の`保持-時刻$ ~SET `未解決$
◎
If the start time of animation is resolved, make animation’s hold time unresolved.
</p>


<p class="note">注記：
この段は、 %~animation の再生-状態が `完遂d$i に “貼り付き続ける” ことなく，`現-時刻$の更新-に基づいて評価し直されることを確保する。
◎
Note: This step ensures that the finished play state of animation is not “sticky” but is re-evaluated based on its updated current time.
</p>
	</li>
	<li>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</li>
</ol>



			</section>
			<section id="responding-to-a-newly-inactive-timeline">
<h4 title="Responding to a newly inactive timeline">4.4.2. 時列線が作動中でなくなったときの応答-法</h4>

<p class="issue">
この仕様のこの~levelにて定義される各種時列線に対しては、この状況が生じるものとは予期されていない。
そのため、この節は，この仕様の後継~levelへ移動されるものと見込まれている。
`2080$issue
◎
With the set of timelines defined in this level of this specification, this situation is not expected to occur. As a result, this section will likely be moved to a subsequent level of this specification. &lt;https://github.com/w3c/csswg-drafts/issues/2080&gt;
</p>


<p>
`~animation$ %~animation の`時列線$Anが新たに`作動中$でなくなったときは、次を走らす
⇒
~IF［
%~animation の`前回の現-時刻$ ~NEQ `未解決$
］
⇒
`現-時刻を~silentに設定する$( %~animation, `前回の現-時刻$ )
◎
When the timeline associated with an animation, animation, becomes newly inactive, if animation’s previous current time is resolved, the procedure to silently set the current time of animation to previous current time is run.
</p>

<p class="note">注記：
この段は、`~animation$の`時列線$Anが［
`作動中$でなくなるときと, ~NULL にされるとき
］の挙動が一貫するようにする。
さらには、それは`~animation$が`遊休中$iになる~~機会は、`~animationを取消す$手続きが遂行されるときに限られることを確保する。
◎
This step makes the behavior when an animation’s timeline becomes inactive consistent with when it is disassociated with a timeline. Furthermore, it ensures that the only occasion on which an animation becomes idle, is when the procedure to cancel an animation is performed.
</p>
			</section>
			<section id="setting-the-target-effect">
<h4 title="Setting the target effect of an animation">4.4.3. ~animationの~target効果の設定-法</h4>


<p class="algo-head">
`~target効果を設定する@
手続きは、所与の
( %~animation, %新-効果 （ ~NULL もとり得る） )
に対し，次を走らす：
◎
The procedure to set the target effect of an animation, animation, to new effect which may be null, is as follows:
</p>

<ol>
	<li>
%旧-効果 ~LET %~animation の`~target効果$
◎
Let old effect be the current target effect of animation, if any.
</li>
	<li>
~IF［
%新-効果 ~EQ %旧-効果
<!-- ＊same object as -->
］
⇒
~RET
◎
If new effect is the same object as old effect, abort this procedure.
</li>
	<li>
<p>
~IF［
%新-効果 ~NEQ ~NULL
］：
</p>
		<ol>
			<li>
~IF［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］
⇒
その~taskを，次が満たされた時点で走るように~scheduleし直す
⇒
%~animation は %新-効果 に関して`準備済み$である
◎
If animation has a pending pause task, reschedule that task to run as soon as animation is ready.
</li>
			<li>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］
⇒
その~taskを，次が満たされた時点で走るように~scheduleし直す
⇒
%~animation は %新-効果 に関して`準備済み$である
◎
If animation has a pending play task, reschedule that task to run as soon as animation is ready to play new effect.
</li>
			<li>
~IF［
%新-効果 を`~targetにしている~animation$ %A ~NEQ ε
］
⇒
`~target効果を設定する$( %A, ~NULL )
◎
If new effect is not null and if new effect is the target effect of another animation, previous animation, run the procedure to set the target effect of an animation (this procedure) on previous animation passing null as new effect.
</li>
		</ol>
	</li>
	<li>
%~animation の`~target効果$ ~LET %新-効果
◎
Let the target effect of animation be new effect.
</li>
	<li>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</li>
</ol>

<p class="algo-head">
`処理待ち~taskを再設定する@
手続きは、所与の
( %~animation )
に対し，次を走らす：
◎
The procedure to reset an animation’s pending tasks for animation is as follows:
</p>

<ol>
	<li>
~IF［
%~animation の`処理待ち再生-~task$ ~EQ ε
］~AND［
%~animation の`処理待ち静止-~task$ ~EQ ε
］
⇒
~RET
◎
If animation does not have a pending play task or a pending pause task, abort this procedure.
</li>
	<li>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］
⇒
その~taskを取消す
◎
If animation has a pending play task, cancel that task.
</li>
	<li>
~IF［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］
⇒
その~taskを取消す
◎
If animation has a pending pause task, cancel that task.
</li>
	<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate on animation.
</li>
	<li>
`AbortError^E 例外で %~animation の`現在の準備済み~promise$を`却下する$
◎
Reject animation’s current ready promise with a DOMException named "AbortError".
</li>
	<li>
%~animation の`現在の準備済み~promise$ ~LET `新たな~promise$
【原文は “（何かで）`解決される~promise$” を指しているが，何で解決されるか指定されていない。】
◎
Let animation’s current ready promise be the result of creating a new resolved Promise object.
</li>
</ol>

			</section>
			<section id="the-current-time-of-an-animation">
<h4 title="The current time of an animation">4.4.4. ~animationの現-時刻</h4>


<p>
各`~animation$は、その`現-時刻$と呼ばれる`時刻~値$を，自身の`~target効果$に供する。
◎
Animations provide a time value to their target effect called the animation’s current time.
</p>

<p class="algo-head">
所与の時点での`~animation$ %~animation の
`現-時刻@
は、次に従って計算される：
◎
The current time is calculated from the first matching condition from below:
</p>

<ol>
	<li>
~IF［
%~animation の`保持-時刻$ ~NEQ `未解決$
］
⇒
~RET %~animation の`保持-時刻$
◎
If the animation’s hold time is resolved,
• The current time is the animation’s hold time.
</li>
	<li>
~IF［
%~animation の`時列線~現-時刻$ ~EQ `未解決$
］~OR［
%~animation の`開始-時刻$ ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If any of the following are true:
• the animation has no associated timeline, or
• the associated timeline is inactive, or
• the animation’s start time is unresolved.
The current time is an unresolved time value.
</li>
	<li>
<p>
~RET ( 
( %~animation の`時列線~現-時刻$ ) ~MINUS %~animation の`開始-時刻$
)
~MUL `再生~rate$
◎
Otherwise,
• current time = (timeline time - start time) × playback rate
</p>

<p>
`再生~rate$ 値は、`速度~制御$secにて定義される。
◎
Where timeline time is the current time value of the associated timeline. The playback rate value is defined in §4.4.17 Speed control.
</p>
	</li>
</ol>


			</section>
			<section id="setting-the-current-time-of-an-animation">
<h4 title="Setting the current time of an animation">4.4.5. ~animationの現-時刻の設定-法</h4>

<p>
~animationを~seekするためには、その`現-時刻$が新たな値【を返すよう】に設定する。
現-時刻を設定する手続きは、以下に与える 2 つの部分に分けて定義される。
◎
The current time of an animation can be set to a new value to seek the animation. The procedure for setting the current time is defined in two parts.
</p>

<p class="algo-head">
`現-時刻を~silentに設定する@
手続きは、所与の
( %~animation, %~seek時刻 )
に対し，次を走らす：
◎
The procedure to silently set the current time of an animation, animation, to seek time is as follows:
</p>

<ol>
	<li>
<p>
~IF［
%~seek時刻 ~EQ `未解決$
］：
◎
If seek time is an unresolved time value, then perform the following steps.
</p>
		<ol>
			<li>
~IF［
%~animation の`現-時刻$ ~NEQ `未解決$
］
⇒
~THROW `TypeError^E
◎
If the current time is resolved, then throw a TypeError.
</li>
			<li>
~RET
◎
Abort these steps.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~animation は次のいずれかを満たす
］…：
◎
Update either animation’s hold time or start time as follows:
◎
If any of the following conditions are true:
</p>
		<ul>
			<li>
`保持-時刻$ ~NEQ `未解決$
◎
animation’s hold time is resolved, or
</li>
			<li>
`開始-時刻$ ~EQ `未解決$
◎
animation’s start time is unresolved, or
</li>
			<li>
`時列線~現-時刻$ ~EQ `未解決$
◎
animation has no associated timeline or the associated timeline is inactive, or
</li>
			<li>
`再生~rate$ ~EQ 0
◎
animation’s playback rate is 0,
</li>
		</ul>
<p>
…ならば
⇒
%~animation の`保持-時刻$ ~SET %~seek時刻
◎
Set animation’s hold time to seek time.
</p>
	</li>
	<li>
~ELSE
⇒
%~animation の`開始-時刻$ ~SET 
( %~animation の`時列線~現-時刻$ )
~MINUS ( %~seek時刻 ~DIV `再生~rate$ )
◎
Otherwise,
• Set animation’s start time to the result of evaluating timeline time - (seek time / playback rate) where timeline time is the current time value of timeline associated with animation.
</li>
	<li>
<p>
~IF［
%~animation の`時列線~現-時刻$ ~EQ `未解決$
］
⇒
%~animation の`開始-時刻$ ~SET `未解決$
◎
If animation has no associated timeline or the associated timeline is inactive, make animation’s start time unresolved.
</p>


<p class="note">注記：
これは、次の不変則を保全する
⇒
［
%~animation の`時列線~現-時刻$ ~EQ `未解決$
］になる間は、設定-が可能になるのは その［
`開始-時刻$／`現-時刻$
］に限られる。
◎
This preserves the invariant that when we don’t have an active timeline it is only possible to set either the start time or the animation’s current time.
</p>
	</li>
	<li>
%~animation の`前回の現-時刻$ ~SET `未解決$
◎
Make animation’s previous current time unresolved.
</li>
</ol>

<p class="algo-head">
`現-時刻を設定する@
手続きは、所与の
( %~animation, %~seek時刻 )
に対し，次を走らす：
◎
The procedure to set the current time of an animation, animation, to seek time is as follows:
</p>

<ol>
	<li>
`現-時刻を~silentに設定する$( %~animation, %~seek時刻 )
◎
Run the steps to silently set the current time of animation to seek time.
</li>
	<li>
<p>
~IF［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］（この段は、静止-演算を同期的に完了させる）：
◎
If animation has a pending pause task, synchronously complete the pause operation by performing the following steps:
</p>
		<ol>
			<li>
%~animation の`保持-時刻$ ~SET %~seek時刻
◎
Set animation’s hold time to seek time.
</li>
			<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate to animation.
</li>
			<li>
%~animation の`開始-時刻$ ~SET `未解決$
◎
Make animation’s start time unresolved.
</li>
			<li>
%~animation の`処理待ち静止-~task$を取消す
◎
Cancel the pending pause task.
</li>
			<li>
%~animation で %~animation の`現在の準備済み~promise$を`解決する$, %~animation )
◎
Resolve animation’s current ready promise with animation.
</li>
		</ol>
	</li>
	<li>
`完遂d状態を更新する$( %~animation, `~seekした^i )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to false.
</li>
</ol>



			</section>
			<section id="setting-the-start-time-of-an-animation">
<h4 title="Setting the start time of an animation">4.4.6. ~animationの開始-時刻の設定-法</h4>


<p class="algo-head">
`開始-時刻を設定する@
手続きは、所与の
( `~animation$ %~animation, %新-開始-時刻 )
に対し，次を走らす：
◎
The procedure to set the start time of animation, animation, to new start time, is as follows:
</p>

<ol>
	<li>
%時列線 ~LET %~animation の`時列線$An
◎
↓</li>
	<li>
%時列線~時刻 ~LET %~animation の`時列線~現-時刻$
◎
Let timeline time be the current time value of the timeline that animation is associated with. If there is no timeline associated with animation or the associated timeline is inactive, let the timeline time be unresolved.
</li>
	<li>
<p>
~IF［
%時列線~時刻 ~EQ `未解決$
］~AND［
%新-開始-時刻 ~NEQ `未解決$
］
⇒
%~animation の`保持-時刻$ ~SET `未解決$
◎
If timeline time is unresolved and new start time is resolved, make animation’s hold time unresolved.
</p>


<p class="note">注記：
これは、次の不変則を保全する
⇒
%~animation の`時列線~現-時刻$ ~EQ `未解決$になる間は、その`開始-時刻$／`現-時刻$に限り，設定-が可能になる。
◎
This preserves the invariant that when we don’t have an active timeline it is only possible to set either the start time or the animation’s current time.
</p>
	</li>
	<li>
<p>
%前回の現-時刻 ~LET  %~animation の`現-時刻$
◎
Let previous current time be animation’s current time.
</p>

<p class="note">注記：
これは、前~段による変更により`未解決$になり得る。
◎
Note: This is the current time after applying the changes from the previous step which may cause the current time to become unresolved.
</p>
	</li>
	<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate on animation.
</li>
	<li>
%~animation の`開始-時刻$ ~SET %新-開始-時刻
◎
Set animation’s start time to new start time.
</li>
	<li>
~IF［
%新-開始-時刻 ~NEQ `未解決$
］
⇒
~IF［
%~animation の`再生~rate$ ~NEQ 0
］
⇒
%~animation の`保持-時刻$ ~SET `未解決$
◎
Update animation’s hold time based on the first matching condition from the following,
◎
If new start time is resolved,
• If animation’s playback rate is not zero, make animation’s hold time unresolved.
</li>
	<li>
~ELSE
⇒
%~animation の`保持-時刻$ ~SET %前回の現-時刻
◎
Otherwise (new start time is unresolved),
• Set animation’s hold time to previous current time even if previous current time is unresolved.
</li>
	<li>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］~OR［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］
⇒＃
その~taskを取消す；
%~animation で %~animation の`現在の準備済み~promise$を`解決する$
◎
If animation has a pending play task or a pending pause task, cancel that task and resolve animation’s current ready promise with animation.
</li>
	<li>
`完遂d状態を更新する$( %~animation, `~seekした^i )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to false.
</li>
</ol>

			</section>
			<section id="waiting-for-the-target-effect">
<h4 title="Waiting for the target effect">4.4.7. ~target効果の待機-法</h4>

<div class="note">

<p>参考：
`~animation$により遂行される演算は、瞬時に~~反映されるとは限らない。
例えば，~UAによっては、~animationの再生を別々の~processへ, あるいは
特化された~graphics~hardwareへ移譲することもある
— そのそれぞれが初期設定~overheadを被り得る。
◎
This section is non-normative.
◎
Some operations performed by an animation may not occur instantaneously. For example, some user agents may delegate the playback of an animation to a separate process or to specialized graphics hardware each of which may incur some setup overhead.
</p>

<p>
そのような~animationが，誘発された~momentからの時刻に基づく場合、~animationの 1, 2 個目の~frameの合間に孕まれる初期設定にかかる時間だけ有意に~jumpし得る。
◎
If such an animation is timed from the moment when the animation was triggered there may be a significant jump between the first and second frames of the animation corresponding to the setup time involved.
</p>

<p>
この問題を避けるため，この仕様は、概して，~animationの計時を~animationの最初の~frameが完了した~momentから始める。
これは、［
`~animation$の`開始-時刻$を`未解決$にした上で，~animationが`準備済み$になった時点で解決される
］ようにすることで表現される。
内容は、任意選択で
— `開始-時刻$を`未解決$でない`時刻~値$に設定することにより —
この挙動を外すこともできる。
◎
To avoid this problem, Web Animations typically begins timing animations from the moment when the first frame of the animation is complete. This is represented by an unresolved start time on the animation which becomes resolved when the animation is ready. Content may opt out of this behavior by setting the start time to a resolved time value.
</p>

</div>

<p>
~animationは、次のいずれも満たすようになった最初の~momentにて
`準備済み@
になるとされる：
◎
An animation is ready at the first moment where both of the following conditions are true:
</p>

<ul>
	<li>
~UAは、~animationの`~target効果$の再生を始めるために要求される初期設定を
— `~keyframe効果$の最初の~frameの描画も含め —
完了した。
◎
the user agent has completed any setup required to begin the playback of the animation’s target effect including rendering the first frame of any keyframe effect.
</li>
	<li>
`時列線~現-時刻$ ~NEQ `未解決$
◎
the animation is associated with a timeline that is not inactive.
</li>
</ul>

			</section>
			<section id="promise-objects">
<h4 title="Promise objects">4.4.8. ~promise</h4>

<p>
`~promise$
【 `Promise object^en の略記】
は、 `ECMA-262$rにより定義される。
◎
Promise objects are defined by [ECMA-262].
</p>

<p class="trans-note">【
以下，この節では~promise関連の用語が定義されるが、この訳では
— 他の仕様と同様に —
<a href="https://www.w3.org/2001/tag/doc/promises-guide">Writing Promise-Using Specifications</a>
に定義される等価な用語への参照にすべて置換する。
】
◎
To resolve a Promise with value, call the [[Call]] internal [[Resolve]] method on the PromiseCapability record for the promise, passing undefined as thisArgument and (value) as argumentsList.
◎
To reject a Promise with reason, call the [[Call]] internal [[Reject]] method on the PromiseCapability record for the promise, passing undefined as thisArgument and (reason) as argumentsList.
◎
To create a new resolved Promise with value, call Promise.resolve, passing value as x.
</p>

			</section>
			<section id="the-current-ready-promise">
<h4 title="The current ready promise">4.4.9. 現在の準備済み~promise</h4>

<p>
各`~animation$は、
`現在の準備済み~promise@
を持つ
— 初期~時には`新たな~promise$にされる。
【原文は “（何かで）`解決される~promise$” を指しているが，何で解決されるか指定されていない。】
◎
Each animation has a current ready promise. The current ready promise is initially a resolved Promise created using the procedure to create a new resolved Promise.
</p>

<p>
この~objは、~animationが，ある［
`処理待ち再生-~task$／`処理待ち静止-~task$
］を~queueするたびに，`新たな~promise$に置換される
— それまで処理待ち~taskがなかったとき, あるいは
~animationは取消されたときに（`~animationの取消法$secを見よ）。
◎
The object is replaced with a new Promise object every time the animation queues a pending play task or a pending pause task when it previously did not have a pending task, or when the animation is canceled (see §4.4.16 Canceling an animation).
</p>



<div class="note">

<p>注記：
同じ~objが［
処理待ち再生-, 処理待ち静止-
］の両~要請-用に利用されることに注意
— なので，作者には、`~promise$が解決されたときには，~animationの状態を検査することを勧める。
◎
Note that since the same object is used for both pending play and pending pause requests, authors are advised to check the state of the animation when the Promise object is resolved.
</p>

<p>
例えば次の~code片における~animationの状態は、`現在の準備済み~promise$が解決されたときには `稼働中$i になる。
なぜなら， `play()^m 演算が生じるとき、`処理待ち再生-~task$は まだ~queueに残っているため，`現在の準備済み~promise$が再~利用されるからである。
◎
For example, in the following code fragment, the state of the animation will be running when the current ready promise is resolved. This is because the play operation occurs while a pending play task is still queued and hence the current ready promise is re-used.
</p>

<div class="example">
<pre class="lang-javascript">
%animation.pause();
%animation.ready.then(function() {
  /* <span class="comment">
`running^l （稼働中）を表示する 
◎
Displays 'running'
</span> */
  alert(%animation.playState);
});
%animation.play();
</pre>
</div>

</div>

			</section>
			<section id="playing-an-animation-section">
<h4 title="Playing an animation">4.4.10. ~animationの再生-法</h4>

<p class="algo-head">
`~animationを再生する@
手続きは、所与の
( %~animation, %自動巻戻し~flag ~IN { `自動巻戻しあり^i, ε } )
に対し，次を走らす：
◎
The procedure to play an animation, animation, given a flag auto-rewind, is as follows:
</p>


<p class="note">注記：
%自動巻戻し~flag は、 `CSS-ANIMATIONS-1$r など，［
この~model上に築かれるが，巻戻しの挙動は要求しない他の仕様
］用に供される。
◎
Note: The auto-rewind flag is provided for other specifications that build on this model but do not require the rewinding behavior, such as CSS Animations [CSS-ANIMATIONS-1].
</p>

<ol>
	<li>
%静止-は中止された ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%~animation の`処理待ち静止-~task$ ~NEQ ε
◎
Let aborted pause be a boolean flag that is true if animation has a pending pause task, and false otherwise.
</li>
	<li>
%処理待ち準備済み~promiseは在る ~LET ~F
◎
Let has pending ready promise be a boolean flag that is initially false.
</li>
	<li>
%実効~再生~rate ~LET ［
%~animation の`処理待ち再生~rate$ ~NEQ ε ならば それ ／
~ELSE_ %~animation の`再生~rate$
］
◎
Let effective playback rate be animation’s pending playback rate, if set, otherwise let it be animation’s playback rate.
</li>
	<li>
%現-時刻 ~LET %~animation の`現-時刻$
◎
↓
◎
Perform the steps corresponding to the first matching condition from the following, if any:
</li>
	<li>
<p>
~IF［
%実効~再生~rate ~GT 0
］~AND［
%自動巻戻し~flag ~EQ `自動巻戻しあり^i
］~AND［
%現-時刻 は次のいずれかを満たす
］…：
◎
If effective playback rate &gt; 0, the auto-rewind flag is true and either animation’s:
</p>
		<ul>
			<li>
%現-時刻 ~EQ `未解決$
◎
current time is unresolved, or
</li>
			<li>
%現-時刻 ~LT 0
◎
current time &lt; zero, or
</li>
			<li>
%現-時刻 ~GTE `~target効果~終端$
◎
current time ≥ target effect end,
</li>
		</ul>
<p>
…ならば
⇒
%~animation の`保持-時刻$ ~SET 0
◎
Set animation’s hold time to zero.
</p>
	</li>
	<li>
<p>
~ELIF［
%実効~再生~rate ~LT 0
］~AND［
%自動巻戻し~flag ~EQ `自動巻戻しあり^i
］~AND［
%現-時刻 は次のいずれかを満たす
］…：
◎
If effective playback rate &lt; 0, the auto-rewind flag is true and either animation’s:
</p>
		<ul>
			<li>
%現-時刻 ~EQ `未解決$
◎
current time is unresolved, or
</li>
			<li>
%現-時刻 ~LTE 0
◎
current time ≤ zero, or
</li>
			<li>
%現-時刻 ~GT `~target効果~終端$
◎
current time &gt; target effect end,
</li>
		</ul>
<p>
…ならば：
</p>
		<ol>
			<li>
~IF［
`~target効果~終端$ ~EQ 正の無限大
］
⇒
~THROW  `InvalidStateError^E
◎
If target effect end is positive infinity, throw an InvalidStateError and abort these steps.＼
</li>
			<li>
~ELSE
⇒
%~animation の`保持-時刻$ ~SET `~target効果~終端$
◎
Otherwise, set animation’s hold time to target effect end.
</li>
		</ol>
	</li>
	<li>
~ELIF［
%実効~再生~rate ~EQ 0
］~AND［
%~animation の`現-時刻$ ~EQ `未解決$
］
⇒
%~animation の`保持-時刻$ ~SET 0
◎
If effective playback rate = 0 and animation’s current time is unresolved,
• Set animation’s hold time to zero.
</li>
	<li>
<p>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］~OR［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］：
◎
If animation has a pending play task or a pending pause task,
</p>
		<ol>
			<li>
その~taskを取消す
◎
Cancel that task.
</li>
			<li>
%処理待ち準備済み~promiseは在る ~SET ~T
◎
Set has pending ready promise to true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
次がいずれも満たされる
］…：
◎
If the following three conditions are all satisfied:
</p>
		<ul>
			<li>
%~animation の`保持-時刻$ ~EQ `未解決$
◎
animation’s hold time is unresolved, and
</li>
			<li>
%静止-は中止された ~EQ ~F
◎
aborted pause is false, and
</li>
			<li>
%~animation の`処理待ち再生~rate$ ~EQ ε
◎
animation does not have a pending playback rate,
</li>
		</ul>
<p>
ならば…
⇒
~RET
◎
abort this procedure.
</p>
	</li>
	<li>
~IF［
%~animation の`保持-時刻$ ~NEQ `未解決$
］
⇒
%~animation の`開始-時刻$ ~LET `未解決$
◎
If animation’s hold time is resolved, let its start time be unresolved.
</li>
	<li>
~IF［
%処理待ち準備済み~promiseは在る ~EQ ~F
］
⇒
%~animation の`現在の準備済み~promise$ ~LET `新たな~promise$
◎
If has pending ready promise is false, let animation’s current ready promise be a new (pending) Promise object.
</li>
	<li>
<p>
次に与える~taskを［
%~animation が`準備済み$になり次第，走らす
］よう~scheduleする：
◎
Schedule a task to run as soon as animation is ready. The task shall perform the following steps:
</p>
		<ol>
			<li>
~Assert：
［
%~animation の`開始-時刻$ ~NEQ `未解決$
］~OR［
%~animation の`保持-時刻$ ~NEQ `未解決$
］
◎
Assert that at least one of animation’s start time or hold time is resolved.
</li>
			<li>
%準備済み時刻 ~LET %~animation の`時列線~現-時刻$
（すなわち、`準備済み$になった~momentのそれ）
◎
Let ready time be the time value of the timeline associated with animation at the moment when animation became ready.
</li>
			<li>
%新-開始-時刻 ~LET %準備済み時刻
◎
↓</li>
			<li>
<p>
~IF［
%~animation の`保持-時刻$ ~NEQ `未解決$
］：
◎
Perform the steps corresponding to the first matching condition below, if any:
◎
If animation’s hold time is resolved,
</p>
				<ol>
					<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate on animation.
</li>
					<li>
%再生~rate ~LET %~animation の`再生~rate$
◎
↓</li>
					<li>
~IF［
%再生~rate ~NEQ 0
］
⇒＃
%新-開始-時刻 ~DECBY ( %~animation の`保持-時刻$ ~DIV %再生~rate )；
%~animation の`保持-時刻$ ~SET `未解決$
◎
Let new start time be the result of evaluating ready time - hold time / playback rate for animation. If the playback rate is zero, let new start time be simply ready time.
◎
Set the start time of animation to new start time.
◎
If animation’s playback rate is not 0, make animation’s hold time unresolved.
</li>
					<li>
%~animation の`開始-時刻$ ~SET %新-開始-時刻
◎
↑</li>
				</ol>
			</li>
			<li>
<p>
~ELSE（ %~animation の`開始-時刻$ ~NEQ `未解決$ ）
⇒
~IF［
%~animation の`処理待ち再生~rate$ ~NEQ ε
］：
◎
If animation’s start time is resolved and animation has a pending playback rate,
</p>
				<ol>
					<li>
%合致させる現-時刻
~LET  ( %準備済み時刻 ~MINUS `開始-時刻$ ) ~MUL %~animation `再生~rate$
◎
Let current time to match be the result of evaluating (ready time - start time) × playback rate for animation.
</li>
					<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate on animation.
</li>
					<li>
%再生~rate ~LET %~animation の`再生~rate$
◎
↓</li>
					<li>
~IF［
%再生~rate ~EQ 0
］
⇒
%~animation の`保持-時刻$ ~SET %合致させる現-時刻；
◎
If animation’s playback rate is zero, let animation’s hold time be current time to match.
</li>
					<li>
~ELSE
⇒
%新-開始-時刻 ~DECBY %合致させる現-時刻 ~DIV %再生~rate
◎
Let new start time be the result of evaluating ready time - current time to match / playback rate for animation. If the playback rate is zero, let new start time be simply ready time.
</li>
					<li>
%~animation の`開始-時刻$ ~SET %新-開始-時刻
◎
Set the start time of animation to new start time.
</li>
				</ol>
			</li>
			<li>
%~animation で %~animation の`現在の準備済み~promise$を`解決する$
◎
Resolve animation’s current ready promise with animation.
</li>
			<li>
<p>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</p>

<p class="note">注記：
上の 2 つの段の順序は重要であることに注意
— それは、~animationの`~target効果$の長さが 0 であっても［
~animationの`現在の準備済み~promise$は`現在の完遂d~promise$より先に解決される
］ことを意味するので。
◎
Note that the order of the above two steps is important since it means that an animation with zero-length target effect will resolve its current ready promise before its current finished promise.
</p>
			</li>
		</ol>
<p>
所与の時点における %~animation の
`処理待ち再生-~task@
は、［
この段に与えた~taskが~scheduleされてから走る直前までの間は その~task ／
他のときは ε
］とする。
◎
So long as the above task is scheduled but has yet to run, animation is described as having a pending play task. While the task is running, however, animation does not have a pending play task.
</p>

<p>
~UAは %~animation は即時に`準備済み$になるものと決定する場合、上の~taskを［
次回に`小task~checkpointを遂行する$ときに走らすような小task
］として~scheduleしても~MAYが，~taskを同期的に遂行しては~MUST_NOT。
◎
If a user agent determines that animation is immediately ready, it may schedule the above task as a microtask such that it runs at the next microtask checkpoint, but it must not perform the task synchronously.
</p>

<div class="note">

<p>注記：
`処理待ち再生-~task$を非同期的に走らす上の要件は、次の~codeなどの挙動が各~実装~間で一貫することをを確保する：
◎
The above requirement to run the pending play task asynchronously ensures that code such as the following behaves consistently between implementations:
</p>

<div class="example">

<pre class="lang-javascript">
%animation.play();
%animation.ready.then(
  () =&gt; { console.log('再生にかかります'); },
  () =&gt; { console.log('再生は取消されました'); }
);
/* <span class="comment">
何らかの条件により，再生を取消すことが要求されるとする…
◎
Suppose some condition requires playback to be canceled...
</span> */
%animation.cancel();
/* <span class="comment">
~consoleには “再生は取消されました” と~printされることになる。
◎
"Playback was canceled" will be printed to the console.
</span> */
</pre>

</div>

<p>
`処理待ち再生-~task$を同期的に走らせた場合、上の~codeにおける`現在の準備済み~promise$は却下されなくなる。
◎
In the above code, were the pending play task run synchronously, the current ready promise would not be rejected.
</p>

</div>
	</li>
	<li>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</li>
</ol>



			</section>
			<section id="pausing-an-animation-section">
<h4 title="Pausing an animation">4.4.11. ~animationの静止-法</h4>

<p>
`~animation$の`開始-時刻$が`未解決$の間は、その`現-時刻$は休止されることになる。
◎
Whenever an animation has an unresolved start time, its current time will be suspended.
</p>

<p>
`~animationを再生する$ときと同じく、静止しても，瞬時に~~反映されるとは限らない（`~target効果の待機-法$secを見よ）。
例えば，~animation【の再生】が別々の~processにより遂行されている場合、その~processに状態が反映されることを確保するため，`現-時刻$を同期することも必要とされ得る。
◎
As with playing an animation, pausing may not happen instantaneously (see §4.4.7 Waiting for the target effect). For example, if animation is performed by a separate process, it may be necessary to synchronize the current time to ensure that it reflects the state drawn by the animation process.
</p>


<p class="algo-head">
`~animationを静止する@
手続きは、所与の
( %~animation )
に対し，次を走らす：
◎
The procedure to pause an animation, animation, is as follows:
</p>

<ol>
	<li>
~IF［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］
⇒
~RET
◎
If animation has a pending pause task, abort these steps.
</li>
	<li>
~IF［
%~animation の`再生-状態$ ~EQ `静止中$i
］
⇒
~RET
◎
If the play state of animation is paused, abort these steps.
</li>
	<li>
<p>
~IF［
%~animation の`現-時刻$ ~EQ `未解決$
］：
◎
If the animation’s current time is unresolved, perform the steps according to the first matching condition from below:
</p>
		<ol>
			<li>
~IF［
%~animation の`再生~rate$ ~GTE 0
］
⇒
%~animation の`保持-時刻$ ~SET 0
◎
If animation’s playback rate is ≥ 0,
• Let animation’s hold time be zero.
</li>
			<li>
~ELIF［
%~animation 用の`~target効果~終端$ ~EQ 正の無限大
］
⇒
~THROW `InvalidStateError^E
◎
Otherwise,
• If target effect end for animation is positive infinity, throw an InvalidStateError and abort these steps.
</li>
			<li>
~ELSE
⇒
%~animation の`保持-時刻$ ~SET `~target効果~終端$
◎
• Otherwise, let animation’s hold time be target effect end.
</li>
		</ol>
	</li>
	<li>
%処理待ち準備済み~promiseは在る ~LET ~F
◎
Let has pending ready promise be a boolean flag that is initially false.
</li>
	<li>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］
⇒＃
その~taskを取消す；
%処理待ち準備済み~promiseは在る ~LET ~T
◎
If animation has a pending play task, cancel that task and let has pending ready promise be true.
</li>
	<li>
~IF［
%処理待ち準備済み~promiseは在る ~EQ ~F
］
⇒
%~animation の`現在の準備済み~promise$ ~SET `新たな~promise$
◎
If has pending ready promise is false, set animation’s current ready promise to a new (pending) Promise object.
</li>
	<li>
<p>
次を遂行する~taskを［
~UAが［
%~animation の`~target効果$の再生を休止するために必要とされる処理
］を遂行した後の，最初に可能な~moment
］に実行するよう~scheduleする：
◎
Schedule a task to be executed at the first possible moment after the user agent has performed any processing necessary to suspend the playback of animation’s target effect, if any. The task shall perform the following steps:
</p>
		<ol>
			<li>
%準備済み時刻 ~LET %~animation の（この~momentにおける）`時列線~現-時刻$
◎
Let ready time be the time value of the timeline associated with animation at the moment when the user agent completed processing necessary to suspend playback of animation’s target effect.
</li>
			<li>
<p>
~IF［
%~animation の`開始-時刻$ ~NEQ `未解決$
］~AND［
%~animation の`保持-時刻$ ~EQ `未解決$
］
⇒
%~animation の`保持-時刻$ ~SET
( %準備済み時刻 ~MINUS %~animation の`開始-時刻$ ) ~MUL %~animation の`再生~rate$
◎
If animation’s start time is resolved and its hold time is not resolved, let animation’s hold time be the result of evaluating (ready time - start time) × playback rate.
</p>


<p class="note">注記：
`保持-時刻$は、すでに設定-済みかもしれない
— ［
%~animation は`完遂d$i ／
%~animation の`処理待ち再生-~task$ ~NEQ ε
］の場合には。
いずれの事例においても、`静止中$i 状態に入するに伴い，`保持-時刻$を保全することが求められる。
◎
Note: The hold time might be already set if the animation is finished, or if the animation has a pending play task. In either case we want to preserve the hold time as we enter the paused state.
</p>
			</li>
			<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate on animation.
</li>
			<li>
%~animation の`開始-時刻$ ~SET `未解決$
◎
Make animation’s start time unresolved.
</li>
			<li>
%~animation で %~animation の`現在の準備済み~promise$を`解決する$
◎
Resolve animation’s current ready promise with animation.
</li>
			<li>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</li>
		</ol>

<p>
所与の時点における %~animation の
`処理待ち静止-~task@
は、［
この段に与えた~taskが~scheduleされてから走る直前までの間は その~task ／
他のときは ε
］とする。
◎
So long as the above task is scheduled but has yet to run, animation is described as having a pending pause task. While the task is running, however, animation does not have a pending pause task.
</p>

<p>
`処理待ち再生-~task$のときと同じく、~UAは，`処理待ち静止-~task$を非同期的に走らせ~MUST
— それが、次回に`小task~checkpointを遂行する$ときに走ることになろうが。
◎
As with the pending play task, the user agent must run the pending pause task asynchronously, although that may be as soon as the next microtask checkpoint.
</p>
	</li>
	<li>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</li>
</ol>

			</section>
			<section id="reaching-the-end">
<h4 title="Reaching the end">4.4.12. 終端に達したとき</h4>

~INFORMATIVE
<div class="informative">

<p>
~DVDや~cassetteの再生機は、概して，その媒体の終端に達するまで再生し続け, そこで停止する。
そのような再生機が逆方向にも再生-可能な場合には、概して，その媒体の始まりに達するまで再生し続け, そこで停止する。
この挙動を模倣するため, および
`HTML$r の`~media要素$との一貫性を供するため、~WAnimにおける~animationの`現-時刻$は，その`~target効果$の［
`終止-時刻$を超えて前方へ ／
時刻 0 を過ぎて後方へ
］再生しないようにされている。
◎
DVD players or cassette players typically continue playing until they reach the end of their media at which point they stop. If such players are able to play in reverse, they typically stop playing when they reach the beginning of their media. In order to emulate this behavior and to provide consistency with HTML’s media elements [HTML], the current time of Web Animations' animations do not play forwards beyond the end time of their target effect or play backwards past time zero.
</p>

<p>
~animationは、その再生~範囲の自然な境界に達しているとき，`完遂した^emとされる。
◎
An animation that has reached the natural boundary of its playback range is said to have finished.
</p>


<p>
現-時刻を制限することによる効果は、次の図式に示される。
◎
Graphically, the effect of limiting the current time is shown below.
</p>

<figure>`limiting^dgm
<figcaption>
`~animation$の`現-時刻$を［
開始-時刻 `1s^v,
~target効果の長さ `3s^v,
正の`再生~rate$
］で制限するときの効果。
~target効果の終端に達した後，~animationの`現-時刻$は `3s^v に留められる。
◎
The effect of limiting the current time of an animation with a start time of 1s, a target effect of length 3s, and a positive playback rate. After the current time of the animation reaches the end of the target effect, it is capped at 3s.
</figcaption></figure>


<p>
しかしながら，［
`~animation$の`現-時刻$が`~target効果$の終端を過ぎる
］ような時刻へ`~seek^emすることも可能である。
そうしたときは、`現-時刻$はそれ以上~進捗せず，~animationは~seekされた時刻にて静止されていたかのように動作することになる。
◎
It is possible, however, to seek the current time of an animation to a time past the end of the target effect. When doing so, the current time will not progress but the animation will act as if it had been paused at the seeked time.
</p>

<p>
これにより，例えば、~animationの`~target効果$ ~EQ ~NULL のときにも`現-時刻$を例えば `5s^v へ~seekできるようになる。
後で~animationの`~target効果$に［
`終止-時刻$が `5s^v より後にされた`~animation効果$
］が設定された場合、再生は `5s^v の所から始まることになる。
◎
This allows, for example, seeking the current time of an animation with no target effect to 5s. If target effect with an end time later than 5s is later associated with the animation, playback will begin from the 5s mark.
</p>

<p>
上の局面に類似する挙動は、~animationの`~target効果$の長さが変化したときにも発生し得る。
◎
Similar behavior to the above scenario may arise when the length of an animation’s target effect changes.
</p>

<p>
同様に，`再生~rate$が負のときは、`現-時刻$は，時刻 0 を過ぎて進捗しない。
◎
Similarly, when the playback rate is negative, the current time does not progress past time zero.
</p>

</div>

			</section>
			<section id="the-current-finished-promise">
<h4 title="The current finished promise">4.4.13. 現在の完遂d~promise</h4>

<p>
各~animationは
`現在の完遂d~promise@
を持つ。
`現在の完遂d~promise$は、初期~時には`新たな~promise$とする。
◎
Each animation has a current finished promise. The current finished promise is initially a pending Promise object.
</p>

<p>
この~objは、~animationの再生-状態が`完遂d$iから他へ遷移するたびに`新たな~promise$に置換される。
◎
The object is replaced with a new (pending) Promise object every time the animation leaves the finished play state.
</p>
			</section>
			<section id="updating-the-finished-state">
<h4 title="Updating the finished state">4.4.14. 完遂d状態の更新-法</h4>

<p>
正の`再生~rate$を伴う~animationに対しては、`現-時刻$は`~target効果~終端$に達するまで増加し続ける。
◎
For an animation with a positive playback rate, the current time continues to increase until it reaches the target effect end.
</p>

<p>
~animation %~animation の
`~target効果~終端@
は、［
%~animation の`~target効果$ ~NEQ ~NULL ならば その`終止-時刻$ ／
~ELSE_ 0
］を返すとする。
◎
The target effect end of an animation is equal to the end time of the animation’s target effect. If the animation has no target effect, the target effect end is zero.
</p>

<p>
負の`再生~rate$を伴う~animationに対しては、`現-時刻$は 0 に達するまで減少し続ける。
◎
For an animation with a negative playback rate, the current time continues to decrease until it reaches zero.
</p>

<p>
稼働中の~animationは、この境界に達して（または, それを超えて~seekされて）いて，`開始-時刻$は`未解決$でないならば`完遂d$iと称される。
【これは定義ではない。】
◎
A running animation that has reached this boundary (or overshot it) and has a resolved start time is said to be finished.
</p>

<p>
この境界を超えたかどうかは、下に定義する`完遂d状態を更新する$手続きを利用して，当の~animation~objに対する各~改変に対し検査される。
この手続きは、`~animationを更新して~eventを送信する$手続きの一部としても走る。
両~事例とも，下に定義される %~seekした~flag は ε にされる。
◎
The crossing of this boundary is checked on each modification to the animation object using the procedure to update an animation’s finished state defined below. This procedure is also run as part of the update animations and send events procedure. In both cases the did seek flag, defined below, is set to false.
</p>


<p>
~UAは、各~animationに対し
`前回の現-時刻@
を保守する
— それは`時刻~値$であり，初期~時には`未解決$とする。
◎
For each animation, the user agent maintains a previous current time time value that is originally unresolved.
</p>

<p>
`~animation$の`現-時刻$は、通常の再生の間は 上で述べた境界に制限されるが，`現-時刻を設定する$手続きを利用して その境界の外側にある時刻へ~seekすることも可能である。
◎
Whilst during normal playback the current time of an animation is limited to the boundaries described above, it is possible to seek the current time of an animation to times outside those boundaries using the procedure to set the current time of an animation.
</p>

<p class="algo-head">
`完遂d状態を更新する@
手続きは、所与の
( %~animation, %~seekした~flag, %同期通知~flag )
に対し、以下を走らす：
◎
The procedure to update an animation’s finished state for animation, given＼
</p>

<ul>
	<li>
%~seekした~flag ~IN { `~seekした^i, ε }
は、省略時は ε とする。
非 ε ならば，`現-時刻を設定する$手続きの後に遂行されていることを指示する。
◎
a flag did seek (to indicate if the update is being performed after setting the current time), and＼
</li>
	<li>
%同期通知~flag ~IN { `同期通知する^i, ε }
は、省略時は ε とする。
非 ε ならば、この手続きは~callしている文脈は，とにかく即時に［
完遂d~eventを~queueする ／ 完遂d~promiseを解決する
］ことを期待していることを指示する。
◎
a flag synchronously notify (to indicate the update was called in a context where we expect finished event queueing and finished promise resolution to happen immediately, if at all) is as follows:
</li>
</ul>

<ol>
	<li>
%旧~現-時刻 ~LET %~animation の`現-時刻$
◎
↓</li>
	<li>
<p>
~IF［
%~seekした~flag ~EQ ε
］~AND［
%~animation の`保持-時刻$ ~EQ `未解決$
］
⇒
%~animation の`保持-時刻$ ~SET %旧~現-時刻
◎
Let the unconstrained current time be the result of calculating the current time substituting an unresolved time value for the hold time if did seek is false. If did seek is true, the unconstrained current time is equal to the current time.
</p>

<p class="note">注記：
この段は、［
方向が変化し得るような時列線
］に適応するために要求される。
この定義がないと，いったん完遂した~animationは、時列線が反対-方向へ進捗した後も完遂dのままであり続けることになる。
◎
Note: This is required to accommodate timelines that may change direction. Without this definition, a once-finished animation would remain finished even when its timeline progresses in the opposite direction.
</p>
	</li>
	<li>
<p>
%新-保持-時刻 ~LET 次の下位手続きを走らせた結果：
◎
↓</p>
		<ol>
			<li>
<p>
~IF［
次のいずれかが満たされる
］：
</p>

<ul ><li>%旧~現-時刻 ~EQ `未解決$
</li><li>%~animation の`開始-時刻$ ~EQ `未解決$
</li><li>%~animation の`処理待ち再生-~task$ ~NEQ ε
</li><li>%~animation の`処理待ち静止-~task$ ~NEQ ε
</li></ul>

<p>
…ならば
⇒
~RET ε
</p>

◎
If all three of the following conditions are true,
• the unconstrained current time is resolved, and
• animation’s start time is resolved, and
• animation does not have a pending play task or a pending pause task,
◎
then update animation’s hold time based on the first matching condition for animation from below, if any:
</li>
			<li>
%再生~rate ~LET %~animation の`再生~rate$
◎
↓</li>
			<li>
~IF［
%再生~rate ~EQ 0
］
⇒
~RET ε
◎
↓</li>
			<li>
<p>
~IF［
%再生~rate ~GT 0
］~AND［
%旧~現-時刻 ~GTE %~animation の`~target効果~終端$
］：
◎
If playback rate &gt; 0 and unconstrained current time is greater than or equal to target effect end,
</p>
				<ol>
					<li>
~IF［
%~seekした~flag ~EQ `~seekした^i
］
⇒
~RET %旧~現-時刻
◎
If did seek is true, let the hold time be the value of unconstrained current time.
</li>
					<li>
~IF［
%~animation の`前回の現-時刻$ ~NEQ `未解決$
］
⇒
~RET `max^op( %~animation の`前回の現-時刻$, %~animation の`~target効果~終端$ )
◎
If did seek is false, let the hold time be the maximum value of previous current time and target effect end.
</li>
					<li>
~RET %~animation の`~target効果~終端$
◎
If the previous current time is unresolved, let the hold time be target effect end.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%再生~rate ~LT 0
］~AND［
%旧~現-時刻 ~LTE 0
］：
◎
If playback rate &lt; 0 and unconstrained current time is less than or equal to 0,
</p>
				<ol>
					<li>
~IF［
%~seekした~flag ~EQ `~seekした^i
］
⇒
~RET %旧~現-時刻
◎
If did seek is true, let the hold time be the value of unconstrained current time.
</li>
					<li>
~IF［
%~animation の`前回の現-時刻$ ~NEQ `未解決$
］
⇒
~RET `min^op( %~animation の`前回の現-時刻$, 0 )
◎
If did seek is false, let the hold time be the minimum value of previous current time and zero.＼
</li>
					<li>
~RET 0
◎
If the previous current time is unresolved, let the hold time be zero.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~animation の`時列線~現-時刻$ ~NEQ `未解決$
］：
◎
If playback rate ≠ 0, and animation is associated with an active timeline,
◎
Perform the following steps:
</p>
				<ol>
					<li>
%保持-時刻 ~LET %~animation の`保持-時刻$
◎
↓</li>
					<li>
~IF［
%~seekした~flag ~EQ `~seekした^i
］~AND［
%保持-時刻 ~NEQ `未解決$
］
⇒
%~animation の`開始-時刻$ ~LET
%~animation の`時列線~現-時刻$
~MINUS ( %保持-時刻 ~DIV %再生~rate )
◎
If did seek is true and the hold time is resolved, let animation’s start time be equal to the result of evaluating timeline time - (hold time / playback rate) where timeline time is the current time value of timeline associated with animation.
</li>
					<li>
~RET `未解決$
◎
Let the hold time be unresolved.
</li>
				</ol>
			</li>
			<li>
~RET ε
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%新-保持-時刻 ~NEQ ε
］
⇒
%~animation の`保持-時刻$ ~SET %新-保持-時刻
◎
↑</li>
	<li>
%~animation の`前回の現-時刻$ ~SET %~animation の`現-時刻$
◎
Set the previous current time of animation be the result of calculating its current time.
</li>
	<li>
%現-完遂d状態 ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
%~animation の`再生-状態$ ~EQ `完遂d$i
◎
Let current finished state be true if the play state of animation is finished. Otherwise, let it be false.
</li>
	<li>
<p>
~IF［
%現-完遂d状態 ~EQ ~T
］~AND［
`現在の完遂d~promise$はまだ解決されてない
］：
◎
If current finished state is true and the current finished promise is not yet resolved, perform the following steps:
</p>
		<ol>
			<li>
<p>
この手続きにおける
`完遂-通知~手続き@
は、次を走らすとする：
◎
Let finish notification steps refer to the following procedure:
</p>
				<ol>
					<li>
~IF［
%~animation の`再生-状態$ ~NEQ `完遂d$i
］
⇒
~RET
◎
If animation’s play state is not equal to finished, abort these steps.
</li>
					<li>
%~animation で %~animation の`現在の完遂d~promise$を`解決する$
◎
Resolve animation’s current finished promise object with animation.
</li>
					<li>
%~finish~event ~LET `~eventを作成する$( `AnimationPlaybackEvent$I )
◎
Create an AnimationPlaybackEvent, finishEvent.
</li>
					<li>
%~finish~event の
⇒＃
`type$m 属性 ~SET `finish$et
`currentTime$m 属性 ~SET %~animation の`現-時刻$
`timelineTime$m 属性 ~SET %~animation の`時列線~現-時刻$
◎
Set finishEvent’s type attribute to finish.
◎
Set finishEvent’s currentTime attribute to the current time of animation.
◎
Set finishEvent’s timelineTime attribute to the current time of the timeline with which animation is associated. If animation is not associated with a timeline, or the timeline is inactive, let timelineTime be null.
</li>
					<li>
~IF［
%~animation の`計時~用の文書$ ~NEQ ε
］
⇒
%~animation の`計時~用の文書$の`処理待ち~animation~event~queue$に
次を伴わせた %~finish~event を付加する
⇒＃
`対応する~event~target$ ~SET %~animation,
`~schedule済み~event時刻$ ~SET `~animation時刻を起点に相対的な時刻へ戻す$( %~animation の`~target効果~終端$ )
◎
If animation has a document for timing, then append finishEvent to its document for timing's pending animation event queue along with its target, animation. For the scheduled event time, use the result of converting animation’s target effect end to an origin-relative time.
</li>
					<li>
~ELSE
⇒
`~DOM操作~task源$から 次を走らす`~taskを~queueする$
⇒
%~animation に向けて %~finish~event を`配送する$
◎
Otherwise, queue a task to dispatch finishEvent at animation. The task source for this task is the DOM manipulation task source.
</li>
				</ol>
			</li>
			<li>
%小task ~LET %~animation 用に`完遂-通知~手続き$を走らす小taskは［
すでに~queueされているならば それ ／
~ELSE_ ε
］
◎
↓</li>
			<li>
~IF［
%同期通知~flag ~EQ `同期通知する^i
］
⇒＃
%小task ~NEQ ε ならばそれを取消す；
即時に`完遂-通知~手続き$を走らす
◎
If synchronously notify is true, cancel any queued microtask to run the finish notification steps for this animation, and run the finish notification steps immediately.
</li>
			<li>
~ELIF［
%小task ~EQ ε
］
⇒
次を走らす`小taskを~queueする$
⇒
%~animation 用の`完遂-通知~手続き$
◎
Otherwise, if synchronously notify is false, queue a microtask to run finish notification steps for animation unless there is already a microtask queued to run those steps for animation.
</li>
		</ol>
	</li>
	<li>
~IF［
%現-完遂d状態 ~EQ ~F
］~AND［
%~animation の`現在の完遂d~promise$はすでに解決されている
］
⇒
%~animation の`現在の完遂d~promise$ ~SET `新たな~promise$
◎
If current finished state is false and animation’s current finished promise is already resolved, set animation’s current finished promise to a new (pending) Promise object.
</li>
</ol>

<div class="note">

<p>参考：
~animationの完遂d状態についての通知は、概して，非同期的に遂行される。
これは、~animationが
— ［
~eventを発火する／ ~promiseを解決する
］のを誘発させずに —
一時的に `完遂d$i 状態に入することを許容する。
◎
Typically, notification about the finished state of an animation is performed asynchronously. This allows for the animation to temporarily enter the finished state without triggering events to be fired or promises to be resolved.
</p>

<p>
例えば，次の~code片において、 %animation は一時的に完遂d状態に入する。
完遂d状態の通知が同期的に生じた場合、この~codeは `finish$et ~eventを~queueさせ，`現在の完遂d~promise$は解決されることになる。
しかしながら，最後の 2 文の順序を逆にして `iterationCount^c が最初に更新されるようにした場合、これは起こらないことになる。
この意外な挙動を避けるため、~animationの完遂d状態についての通知は，概して非同期的に遂行される。
◎
For example, in the following code fragment, animation temporarily enters the finished state. If notification of the finished state occurred synchronously this code would cause the finish event to be queued and the current finished promise to be resolved. However, if we reverse the order of the two statements such that the iterationCount is updated first, this would not happen. To avoid this surprising behavior, notification about the finished state of an animation is typically performed asynchronously.
</p>

<div class="example">

<pre class="lang-javascript">
var %animation = %elem.animate({ left: '100px' }, 2000);
%animation.playbackRate = 2;
%animation.currentTime = 1000; /* <span class="comment">
~animationは、今~完遂した
◎
animation is now finished
</span> */
%animation.effect.updateTiming({ iterationCount: 2 }); /* <span class="comment">
~animationは、以降は完遂しなくなる
◎
animation is no longer finished
</span> */
</pre>

</div>

<p>
この非同期的な挙動に対する例外の一つは、`~animationを完遂する$手続きが遂行されるときである（概して `finish()$m ~methodを~callすることにより）。
この事例では，作者の意向は~animationを完遂することは明瞭なので、~animationの完遂d状態についての通知は，下に例示するように同期的に生じる。
◎
The one exception to this asynchronous behavior is when the finish an animation procedure is performed (typically by calling the finish() method). In this case the author’s intention to finish the animation is clear so the notification about the finished state of the animation occurs synchronously as demonstrated below.
</p>

<div class="example">

<pre class="lang-javascript">
var %animation = %elem.animate({ left: '100px' }, 1000);
%animation.finish(); /* <span class="comment">
`finish^et ~eventは即時に~queueされ，完遂d~promiseは解決される
— 次の文は、~animationを完遂d状態から他へ遷移させるにもかかわらず。
◎
finish event is queued immediately and finished promise is resolved despite the fact that the following statement causes the animation to leave the finished state
</span> */
%animation.currentTime = 0;
</pre>

</div>

<p>
`~animationを完遂する$手続きと同様に，`~animationを取消す$手続きも、同期的な方式で，
`cancel$et ~eventを~queueした上で［
`現在の完遂d~promise$ ／ `現在の準備済み~promise$
］を却下することに注意。
◎
Note that like the procedure to finish an animation, the procedure to cancel an animation similarly queues the cancel event and rejects the current finished promise and current ready promise in a synchronous manner.
</p>

</div>

			</section>
			<section id="finishing-an-animation-section">
<h4 title="Finishing an animation">4.4.15. ~animationの完遂-法</h4>


<p class="algo-head">
次に与える 
`~animationを完遂する@
手続きを利用すれば、~animationを現在の再生~方向にある自然な終端へ進めれる。
それは、所与の
( %~animation )
に対し，次を走らす：
◎
An animation can be advanced to the natural end of its current playback direction by using the procedure to finish an animation for animation defined below:
</p>

<ol>
	<li>
%再生~rate ~LET ［
%~animation の`処理待ち再生~rate$ ~NEQ ε ならば それ ／
~ELSE_ %~animation の`再生~rate$
］
◎
Let effective playback rate be animation’s pending playback rate, if set, otherwise let it be animation’s playback rate.
</li>
	<li>
~IF［
%再生~rate ~EQ 0
］~OR［［
%再生~rate ~GT 0
］~AND［
`~target効果~終端$ ~EQ 無限大
］］
⇒
~THROW `InvalidStateError^E
◎
If the effective playback rate is zero, or if effective playback rate &gt; 0 and target effect end is infinity, throw an InvalidStateError and abort these steps.
</li>
	<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate to animation.
</li>
	<li>
~Assert：
%再生~rate ~EQ %~animation の`再生~rate$
</li>
	<li>
%制限- ~LET ［
%再生~rate ~GT 0 ならば`~target効果~終端$ ／
~ELSE_ 0
］
◎
Set limit as follows:
• If playback rate &gt; 0,
•• Let limit be target effect end.
• Otherwise,
•• Let limit be zero.
</li>
	<li>
`現-時刻を~silentに設定する$( %~animation, %制限- )
◎
Silently set the current time to limit.
</li>
	<li>
~IF［
%~animation の`開始-時刻$ ~EQ `未解決$
］~AND［
%~animation の`時列線~現-時刻$ ~NEQ `未解決$
］
⇒
%~animation の`開始-時刻$ ~LET
( %~animation の`時列線~現-時刻$ )
~MINUS ( %制限- ~DIV %再生~rate )
◎
If animation’s start time is unresolved and animation has an associated active timeline, let the start time be the result of evaluating timeline time - (limit / playback rate) where timeline time is the current time value of the associated timeline.
</li>
	<li>
<p>
~IF［
%~animation の`開始-時刻$ ~NEQ `未解決$
］：
◎
↓</p>
		<ol>
			<li>
<p>
~IF［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］：
◎
If there is a pending pause task and start time is resolved,
</p>
				<ol>
					<li>
<p>
`保持-時刻$ ~SET `未解決$
◎
Let the hold time be unresolved.
</p>

<p class="note">注記：
概して，`保持-時刻$は、この段~以前に`未解決$になる
— %~animation が `遊休中$i であった事例を除き。
◎
Typically the hold time will already be unresolved except in the case when the animation was previously idle.
</p>
					</li>
					<li>
%~animation の`処理待ち静止-~task$を取消す
◎
Cancel the pending pause task.
</li>
					<li>
%~animation で %~animation の`現在の準備済み~promise$を`解決する$
◎
Resolve the current ready promise of animation with animation.
</li>
				</ol>
			</li>
			<li>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］
⇒＃
その~taskを取消す；
%~animation で %~animation の`現在の準備済み~promise$を`解決する$
◎
If there is a pending play task and start time is resolved, cancel that task and resolve the current ready promise of animation with animation.
</li>
		</ol>
	</li>
	<li>
`完遂d状態を更新する$( %~animation, `~seekした^i, `同期通知する^i )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to true, and the synchronously notify flag set to true.
</li>
</ol>

			</section>
			<section id="canceling-an-animation-section">
<h4 title="Canceling an animation">4.4.16. ~animationの取消法</h4>

<p>
~animationは取消すことができる。
その結果、`現-時刻$は`未解決$になり，`~target効果$により~~生じた効果もすべて除去される。
◎
An animation can be canceled which causes the current time to become unresolved hence removing any effects caused by the target effect.
</p>

<p>
`~animationを取消す@
手続きは、所与の
( %~animation )
に対し，次を走らす：
◎
The procedure to cancel an animation for animation is as follows:
</p>

<ol>
	<li>
<p>
~IF［
%~animation の`再生-状態$ ~NEQ `遊休中$i
］：
◎
If animation’s play state is not idle, perform the following steps:
</p>
		<ol>
			<li>
`処理待ち~taskを再設定する$( %~animation )
◎
Run the procedure to reset an animation’s pending tasks on animation.
</li>
	<li>
`AbortError^E 例外で`現在の完遂d~promise$を`却下する$
◎
Reject the current finished promise with a DOMException named "AbortError".
</li>
	<li>
`現在の完遂d~promise$ ~LET `新たな~promise$
◎
Let current finished promise be a new (pending) Promise object.
</li>
	<li>
%~cancel~event ~LET `~eventを作成する$( `AnimationPlaybackEvent$I )
◎
Create an AnimationPlaybackEvent, cancelEvent.
</li>
	<li>
%時列線~時刻 ~LET %~animation の`時列線~現-時刻$
◎
↓</li>
	<li>
%~cancel~event の
⇒＃
`type$m 属性 ~SET `cancel$et,
`currentTime$m 属性 ~SET `未解決$,
`timelineTime$m 属性 ~SET %時列線~時刻
◎
Set cancelEvent’s type attribute to cancel.
◎
Set cancelEvent’s currentTime to null.
◎
Let timeline time be the current time of the timeline with which animation is associated. If animation is not associated with an active timeline, let timeline time be n unresolved time value.
◎
Set cancelEvent’s timelineTime to timeline time. If timeline time is unresolved, set it to null.
</li>
	<li>
<p>
~IF［
%~animation の`計時~用の文書$ ~NEQ ε
］：
</p>
		<ol>
			<li>
%~schedule済み~event時刻 ~LET `未解決$
</li>
			<li>
~IF［
%時列線~時刻 ~NEQ `未解決$
］~AND［
%~animation の`時列線$An用に`起点に相対的な時刻へ変換する$手続きは定義されている
］
⇒
%~schedule済み~event時刻 ~SET その手続きを %時列線~時刻 に適用した結果
</li>
			<li>
`計時~用の文書$の`処理待ち~animation~event~queue$に
次を伴わせた %~cancel~event を付加する
⇒＃
`対応する~event~target$ ~SET %~animation,
`~schedule済み~event時刻$ ~SET %~schedule済み~event時刻
</li>
		</ol>

◎
If animation has a document for timing, then append cancelEvent to its document for timing's pending animation event queue along with its target, animation. If animation is associated with an active timeline that defines a procedure to convert timeline times to origin-relative time, let the scheduled event time be the result of applying that procedure to timeline time. Otherwise, the scheduled event time is an unresolved time value.
</li>
			<li>
~ELSE
⇒
`~DOM操作~task源$から，次を走らす`~taskを~queueする$
⇒
%~animation に向けて %~cancel~event を`配送する$
◎
Otherwise, queue a task to dispatch cancelEvent at animation. The task source for this task is the DOM manipulation task source.
</li>
		</ol>
	</li>
	<li>
%~animation の`保持-時刻$ ~SET `未解決$
◎
Make animation’s hold time unresolved.
</li>
	<li>
%~animation の`開始-時刻$ ~SET `未解決$
◎
Make animation’s start time unresolved.
</li>
</ol>

			</section>
			<section id="speed-control">
<h4 title="Speed control">4.4.17. 速度~制御</h4>


<p class="note">参考：
`再生~rate$を設定することにより，~animationを再生する~rateを制御できる。
例えば，再生~rateを 2 にした場合、~animationの`現-時刻$は，~animationの`時列線~現-時刻$の 2 倍の~rateで増加することになる。
同様に， −1 にした場合、等倍の~rateで減少することになる。
◎
The rate of play of an animation can be controlled by setting its playback rate. For example, setting a playback rate of 2 will cause the animation’s current time to increase at twice the rate of its timeline. Similarly, a playback rate of -1 will cause the animation’s current time to decrease at the same rate as the time values from its timeline increase.
</p>

<p>
`~animation$の
`再生~rate@
は、［
その`時列線$Anの`時刻~値$が変化する~rateから，~animationの`現-時刻$への伸縮-率
］を供する
— 初期~時には 1 とする。
◎
Animations have a playback rate that provides a scaling factor from the rate of change of the associated timeline’s time values to the animation’s current time. The playback rate is initially 1.
</p>


<p>
~animationの`再生~rate$を 0 に設定した場合、実質的に，~animationは静止する（しかしながら、`再生-状態$は `静止中$i になる必要はない）。
◎
Setting an animation’s playback rate to zero effectively pauses the animation (however, the play state does not necessarily become paused).
</p>
				</section>
				<section id="setting-the-playback-rate-of-an-animation">
<h5 title="Setting the playback rate of an animation">4.4.17.1. ~animationの再生~rateの設定-法</h5>

<p class="algo-head">
`~animation$ %~animation の
`再生~rateを設定する@
ときは、所与の
( %新-再生~rate )
に対し，次を走らす：
◎
The procedure to set the playback rate of an animation, animation to new playback rate is as follows:
</p>

<ol>
	<li>
%~animation の`処理待ち再生~rate$ ~SET ε
◎
Clear any pending playback rate on animation.
</li>
	<li>
%前回の時刻 ~LET %~animation の`現-時刻$
◎
Let previous time be the value of the current time of animation before changing the playback rate.
</li>
	<li>
`再生~rate$ ~SET %新-再生~rate
◎
Set the playback rate to new playback rate.
</li>
	<li>
~IF［
%前回の時刻 ~NEQ `未解決$
］
⇒
%~animation の`現-時刻を設定する$( %前回の時刻 )
◎
If previous time is resolved, set the current time of animation to previous time
</li>
</ol>

				</section>
				<section id="seamlessly-updating-the-playback-rate-of-an-animation">
<h5 title="Seamlessly updating the playback rate of an animation">4.4.17.2. ~animationの再生~rateの継目無い更新-法</h5>

<p>

`~animation$の`再生~rateを設定する$手続きは、［
その更新-を遂行している~thread等と, それを走らせている~thread等とが別で，互いに同期していない
］下では，~animationを~jumpさせ得る。
`~animation$の
`処理待ち再生~rate@
は、そのような事例においても`再生~rate$に対する継目無い変化を生産するためにあり，初期~時には ε （なし）とする。
それは、必要とされる同期がとられた後に適用される再生~rateを定義する。
◎
For an in-flight animation that is running on another process or thread, the procedure to set the playback rate may cause the animation to jump if the process or thread running the animation is not currently synchronized with the process or thread performing the update.
◎
In order to produce seamless changes to the playback rate of an animation, animation’s may have a pending playback rate that defines a playback rate to be applied after any necessary synchronization has taken place (for the case of animations running in a different thread or process).
◎
Initially the pending playback rate of an animation is unset.
</p>

<p class="algo-head">
`処理待ち再生~rateがあれば適用する@
ときは、所与の
( `~animation$ %~animation )
に対し，次を走らす：
◎
When an animation, animation, is to apply any pending playback rate the following steps are performed:
</p>

<ol>
	<li>
~IF［
%~animation の`処理待ち再生~rate$ ~EQ ε
］
⇒
~RET
◎
If animation does not have a pending playback rate, abort these steps.
</li>
	<li>
%~animation の`再生~rate$ ~SET %~animation の`処理待ち再生~rate$
◎
Set animation’s playback rate to its pending playback rate.
</li>
	<li>
%~animation の`処理待ち再生~rate$ ~SET ε
◎
Clear animation’s pending playback rate.
</li>
</ol>

<p class="algo-head">
`再生~rateを継目無く更新する@
ときは、所与の
( `~animation$ %~animation, %新-再生~rate )
に対し，次を走らす
— この手続きは、 %~animation の`現-時刻$を保全するようにふるまう：
◎
The procedure to seamlessly update the playback rate an animation, animation, to new playback rate preserving its current time is as follows:
</p>

<ol>
	<li>
%~animation の`処理待ち再生~rate$ ~SET %新-再生~rate
◎
Let animation’s pending playback rate be new playback rate.
</li>
	<li>
<p>
~IF［
%~animation の`処理待ち再生-~task$ ~NEQ ε
］~OR［
%~animation の`処理待ち静止-~task$ ~NEQ ε
］
⇒
~RET
◎
Perform the steps corresponding to the first matching condition from below:
◎
If animation has a pending play task or a pending pause task,
• Abort these steps.
</p>

<p class="note">注記：
両~処理待ち~taskとも，自身が走るときに`処理待ち再生~rate$を適用することになるので、この事例においては，それ以上の動作は要求されない。
◎
Note: The different types of pending tasks will apply the pending playback rate when they run so there is no further action required in this case.
</p>

	</li>
	<li>
~IF［
%~animation の`再生-状態$ ~IN { `遊休中$i, `静止中$i }
］
⇒
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
If animation’s play state is idle or paused,
• Apply any pending playback rate on animation.
</li>
	<li>
<p>
~ELIF［
%~animation の`再生-状態$ ~EQ `完遂d$i
］：
◎
If animation’s play state is finished,
</p>
		<ol>
			<li>
%旧~現-時刻 ~LET %~animation の`現-時刻$
◎
↓</li>
			<li>
~IF［
`保持-時刻$ ~EQ `未解決$
］
⇒
%~animation の`保持-時刻$ ~SET %旧~現-時刻
◎
Let the unconstrained current time be the result of calculating the current time of animation substituting an unresolved time value for the hold time.
</li>
			<li>
%~animation の`開始-時刻$ ~SET %~animation の`時列線~現-時刻$
◎
↓</li>
			<li>
~IF［
%~animation の`処理待ち再生~rate$ ~NEQ 0
］
⇒
%~animation の`開始-時刻$
~DECBY ( %旧~現-時刻 ~DIV %~animation の`処理待ち再生~rate$ )
◎
Let animation’s start time be the result of evaluating the following expression:
• timeline time - (unconstrained current time / pending playback rate)
• Where timeline time is the current time value of the timeline associated with animation.
◎
If pending playback rate is zero, let animation’s start time be timeline time.
</li>
			<li>
`処理待ち再生~rateがあれば適用する$( %~animation )
◎
Apply any pending playback rate on animation.
</li>
			<li>
`完遂d状態を更新する$( %~animation )
◎
Run the procedure to update an animation’s finished state for animation with the did seek flag set to false, and the synchronously notify flag set to false.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
`~animationを再生する$( %~animation, ε )
◎
Otherwise,
• Run the procedure to play an animation for animation with the auto-rewind flag set to false.
</li>
</ol>

			</section>
			<section id="reversing-an-animation-section">
<h4 title="Reversing an animation">4.4.18. ~animationの逆転-法</h4>

<p class="algo-head">
`~animationを逆転する@
ときは、所与の
( `~animation$ %~animation )
に対し，次を走らす：
◎
The procedure to reverse an animation of animation animation is as follows:
</p>

<ol>
	<li>
~IF［
%~animation の`時列線~現-時刻$ ~EQ `未解決$
］
⇒
~THROW `InvalidStateError^E
◎
If there is no timeline associated with animation, or the associated timeline is inactive throw an InvalidStateError and abort these steps.
</li>
	<li>
%元の処理待ち再生~rate ~LET 
%~animation の`処理待ち再生~rate$
◎
Let original pending playback rate be animation’s pending playback rate.
</li>
	<li>
%実効~再生~rate ~LET ［
%~animation の`処理待ち再生~rate$ ~NEQ ε ならば それ ／
~ELSE_ %~animation の`再生~rate$
］
◎
Let effective playback rate be animation’s pending playback rate if it has one, or animation’s playback rate otherwise.
</li>
	<li>
%~animation の`処理待ち再生~rate$ ~LET %実効~再生~rate ~MUL −1
◎
Let animation’s pending playback rate be −effective playback rate.
</li>
	<li>
`~animationを再生する$( %~animation, `自動巻戻しあり^i )
⇒
例外が投出されたときは
⇒＃
%~animation の`処理待ち再生~rate$ ~SET %元の処理待ち再生~rate；
~THROW その例外
◎
Run the steps to play an animation for animation with the auto-rewind flag set to true.
◎
If the steps to play an animation throw an exception, set animation’s pending playback rate to original pending playback rate and propagate the exception.
</li>
</ol>


			</section>
			<section id="play-states">
<h4 title="Play states">4.4.19. 再生-状態</h4>

<p>
`~animation$は、次に挙げるいずれかの
`再生-状態@
をとり得る（括弧内は 対応する `playState$m 値）
— 対応する記述は規範的でない：
◎
An animation may be described as being in one of the following play states for each of which, a non-normative description is also provided:
</p>

<dl>
	<dt>`遊休中$i（ `idle^l ）</dt>
	<dd class="note">
~animationの`現-時刻$は`未解決$, かつ処理待ち~taskも無い。
この状態においては、~animationによる効果は無い。
◎
The current time of the animation is unresolved and there are no pending tasks. In this state the animation has no effect.
</dd>

	<dt>`稼働中$i（ `running^l ）</dt>
	<dd class="note">
~animationの`現-時刻$は`未解決$でなく、各`~animation~frame$ごとに（ `再生~rate$ ~NEQ 0 である限り）変化している。
◎
The animation has a resolved current time that changes on each animation frame (provided the playback rate is not zero).
</dd>

	<dt>`静止中$i（ `paused^l ）</dt>
	<dd class="note">
~animationは休止されているため、`現-時刻$は変化していない。
◎
The animation has been suspended and the current time is no longer changing.
</dd>

	<dt>`完遂d$i（ `finished^l ）</dt>
	<dd class="note">
~animationはその再生~範囲の自然な境界に達したため、`現-時刻$は更新されていない。
◎
The animation has reached the natural boundary of its playback range and the current time is no longer updating.
</dd>
</dl>

<p>
所与の~momentにおける`~animation$ %~animation の`再生-状態$は、次を走らせた結果を返す：
◎
The play state of animation, animation, at a given moment is the state corresponding to the first matching condition from the following:
</p>

<ol>
	<li>
以下に現れる次の用語は、 %~animation のそれを表すとする
⇒＃
`現-時刻$,
`処理待ち再生-~task$,
`処理待ち静止-~task$,
`開始-時刻$,
`再生~rate$,
`~target効果~終端$
</li>
	<li>
<p>
~IF［
次のいずれも満たされる
］：
◎
All of the following conditions are true:
</p>
		<ul>
			<li>
`現-時刻$ ~EQ `未解決$
◎
The current time of animation is unresolved, and
</li>
			<li>
［
`処理待ち再生-~task$ ~EQ ε
］~AND［
`処理待ち静止-~task$ ~EQ ε
］
◎
animation does not have either a pending play task or a pending pause task,
</li>
		</ul>
<p>
…ならば
⇒
~RET `遊休中@i
◎
→ idle
</p>

	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］：
◎
Either of the following conditions are true:
</p>
		<ul>
			<li>
`処理待ち静止-~task$ ~NEQ ε
◎
animation has a pending pause task, or
</li>
			<li>
［
`開始-時刻$ ~EQ `未解決$
］~AND［
`処理待ち再生-~task$ ~EQ ε
］
◎
both the start time of animation is unresolved and it does not have a pending play task,
</li>
		</ul>
<p>
…ならば
⇒
~RET
`静止中@i
◎
→ paused
</p>
	</li>
	<li>
<p>
~IF［
`現-時刻$ ~NEQ `未解決$
］~AND［
次のいずれかが満たされる
］：
◎
For animation, current time is resolved and either of the following conditions are true:
</p>
		<ul>
			<li>
［
`再生~rate$ ~GT 0
］~AND［
`現-時刻$ ~GTE `~target効果~終端$
］
◎
playback rate &gt; 0 and current time ≥ target effect end; or
</li>
			<li>
［
`再生~rate$ ~LT 0
］~AND［
`現-時刻$ ~LTE 0
］
◎
playback rate &lt; 0 and current time ≤ 0,
</li>
		</ul>
<p>
…ならば
⇒
~RET `完遂d@i
◎
→ finished
</p>
	</li>
	<li>
~RET `稼働中@i
◎
Otherwise,
• → running
</li>
</ol>


<div class="note">

<p>注記：
再生-状態 `静止中$i は、実質的に `完遂d$i に “勝つ” ことに注意。
◎
Note that the paused play state effectively “wins” over the finished play state.
</p>

<p>
しかしながら，~animationが その自然な再生~範囲の外側にて静止されている場合、開始し直すことなく
`静止中$i ~animationから`完遂d$i ~animationへ変換され得る
— 次のように`開始-時刻$を設定するなどにより：
◎
However, an animation that is paused outside of its natural playback range can be converted from a paused animation into a finished animation without restarting by setting the start time such as below:
</p>

<div class="example">

<pre class="lang-javascript">
%animation.effect.updateTiming({ duration: 5000 });
%animation.currentTime = 4000;
%animation.pause();
%animation.ready.then(function() {
  %animation.effect.updateTiming({ duration: 3000 });
  alert(%animation.playState); /* <span class="comment">
`paused^l を表示する
◎
Displays 'paused'
</span> */
  %animation.startTime =
    document.timeline.currentTime - %animation.currentTime * %animation.playbackRate;
  alert(%animation.playState); /* <span class="comment">
`finished^l を表示する
◎
Displays 'finished'
</span> */
});
</pre>

</div>
</div>


			</section>
			<section id="animation-events-section">
<h4 title="Animation events">4.4.20. ~animation~event</h4>

<p>
`~animation~event@
には、次に挙げるものがある：
◎
Animation events include＼
</p>

<ul>
	<li>
この仕様にて定義される各種`~animation再生~event$
◎
the animation playback events defined in this specification as well as＼
</li>
	<li>
`CSS-TRANSITIONS-1$r による，各種
<a href="~TRANSITION#transition-events">~CSS遷移~event</a>
◎
the events from CSS transitions [CSS-TRANSITIONS-1] and＼
</li>
	<li>
`CSS-ANIMATIONS-1$r による，各種
<a href="~CSSANIM#events">~CSS~animation~event</a>
◎
events from CSS animations [CSS-ANIMATIONS-1].＼
</li>
</ul>

<p>
将来の仕様は、この集合を他の型の`~animation~event$で拡張し得る。
◎
Future specifications may extend this set with further types of animation events.
</p>

<div class="p">
<p>
各`文書$は、
`処理待ち~animation~event~queue@
を保守する
— それは、それぞれに次が伴われた`~animation~event$たちを格納する：
</p>

<dl class="def-list">
	<dt>`対応する~event~target@</dt>
	<dd>
~eventの配送-先を与える。
</dd>

	<dt>`~schedule済み~event時刻@</dt>
	<dd>
`時刻~起点$に相対的な`時刻~値$。
これは、［
~animationが無限大頻度で更新される下で，~eventが配送されるとする
］ときの，理想的な時刻を表現する。
これは、`~animationを更新して~eventを送信する$手続きにより，~queueされた各`~animation~event$を時系列順に~sortするために利用される。
</dd>
	<dd>
この値は`未解決$にもなり得ることに注意
— 例えば、次の場合が挙げられる
⇒＃
`~animation$の`時列線$Anが`時刻~起点$に無関係な値を生産する場合（例：~scroll位置を追跡する時列線）／
`~animation$の`時列線~現-時刻$は`未解決$になる場合
</dd>
</dl>

◎
Each Document maintains a pending animation event queue that stores animation events along with their corresponding event targets and scheduled event time. The scheduled event time is a time value relative to the time origin representing when the event would ideally have been dispatched were animations updated at an infinitely high frequency. It is used by the procedure to update animations and send events to sort queued animation events chronologically. Note that this value may be unresolved if, for example, the animation's timeline produces values that are unrelated to the time origin (e.g. a timeline that tracks scroll-position) or if the timeline is inactive.
</div>

				</section>
				<section id="sorting-animation-events">
<h5 title="Sorting animation events">4.4.20.1. ~animation~eventの~sort法</h5>

<p>
次の定義は、~queueされた~eventの~sort法を支援するために供される。
◎
The following definitions are provided to assist with sorting queued events.
</p>

<p class="algo-head">
`~animation時刻を起点に相対的な時刻へ戻す@
ときは、所与の
( %~animation, %時刻 )
に対し，次を走らす（ %時刻 は %~animation の`開始-時刻$に相対的な`時刻~値$を表す）：
◎
↓↓</p>

<ol>
	<li>
<p>
%時列線~時刻 ~LET 次の下位手続き（
`~animation時刻から時列線~時刻へ変換する@
）を遂行した結果：
◎
To convert an animation time to timeline time a time value, time, that is relative to the start time of an animation, animation, perform the following steps:
</p>
		<ol>
			<li>
~IF［
%時刻 ~IN { `未解決$, 無限大 }
］
⇒
~RET `未解決$
◎
If time is unresolved, return time.
◎
If time is infinity, return an unresolved time value.
</li>
			<li>
%再生~rate ~LET %~animation の`再生~rate$
◎
↓</li>
			<li>
%開始-時刻 ~LET %~animation の`開始-時刻$
◎
↓</li>
			<li>
<p>
~IF［
%再生~rate ~EQ 0
］~OR［
%開始-時刻 ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If animation’s playback rate is zero, return an unresolved time value.
◎
If animation’s start time is unresolved, return an unresolved time value.
</li>
			<li>
~RET %時刻 ~DIV %再生~rate ~PLUS %開始-時刻
◎
Return the result of calculating: time × (1 / playback rate) + start time (where playback rate and start time are the playback rate and start time of animation, respectively).
</li>
		</ol>
	</li>
	<li>
~IF［
%時列線~時刻 ~EQ `未解決$
］
⇒
~RET %時刻 【`未解決$ではないのか？】
◎
↑To convert a timeline time to an origin-relative time a time value, time, that is expressed in the same scale as the time values of a timeline, timeline, perform the following steps:
◎
↑Let timeline time be the result of converting time from an animation time to a timeline time.
◎
If timeline time is unresolved, return time.
</li>
	<li>
~IF［
%~animation の`時列線~現-時刻$ ~NEQ `未解決$
］~AND［
%~animation の`時列線$An用に`起点に相対的な時刻へ変換する$手続きは定義されている
］
⇒
~RET その手続きを %時列線~時刻 に適用した結果
◎
If animation is not associated with a timeline, return an unresolved time value.
◎
If animation is associated with an inactive timeline, return an unresolved time value.
◎
If there is no procedure to convert a timeline time to an origin-relative time for the timeline associated with animation, return an unresolved time value.
◎
Return the result of converting timeline time to an origin-relative time using the procedure defined for the timeline associated with animation.
</li>
	<li>
~RET `未解決$
◎
↑</li>
</ol>

				</section>
				<section id="animation-playback-events-section">
<h5 title="Animation playback events">4.4.20.2. ~animation再生~event</h5>

<p>
`~animation$を再生するに伴い，その~statusに対する変化を
`~animation再生~event@
を通して報告する。
◎
As animations play, they report changes to their status through animation playback events.
</p>

<p>
`~animation再生~event$は、計時~modelの~propである。
その結果，それは、`~animation$の`~target効果$が［
無い, あるいは在っても観測-可能な結果は無い
］ときにも配送される。
◎
Animation playback events are a property of the timing model. As a result they are dispatched even when the target effect of the animation is absent or has no observable result.
</p>

				</section>
				<section id="animation-playback-event-types">
<h5 title="Types of animation playback events">4.4.20.3. ~animation再生~event型</h5>

<dl>
	<dt>`finish@et</dt>
	<dd>
~animationの再生-状態が別の状態から `完遂d$i に入するたびに~queueされる。
◎
Queued whenever an animation enters the finished play state.
</dd>

	<dt>`cancel@et</dt>
	<dd>
~animationの再生-状態が別の状態から `遊休中$i に入するたびに~queueされる。
初期~時には，この状態にあるので、新たな`~animation$を作成しても，新たな `cancel$et ~eventは`生成されない^em。
◎
Queued whenever an animation enters the idle play state from another state. Creating a new animation that is initially idle does not generate a new cancel event.
</dd>
</dl>

			</section>
		</section>
		<section id="animation-effects">
<h3 title="Animation effects">4.5. ~animation効果</h3>

<p>
`~animation効果@
は、計時~階層~内の ある~itemを指す，抽象~用語である。
◎
An animation effect is an abstract term referring to an item in the timing hierarchy.
</p>

			<section id="animation-effects-and-animations">
<h4 title="Relationship between animation effects and animations">4.5.1. ~animation効果と~animationとの関係性</h4>

<p>
所与の~momentにおいて，ある型の`~animation効果$ %効果 を`~target効果$とする`~animation$ %~animation は、在っても一つに限られる。
%効果 を
`~targetにしている~animation@
は、そのような %~animation が［
在るならば %~animation ／
無いならば ε
］とする。
◎
The target effect of an animation, if set, is a type of animation effect. The target effect of an animation is said to be associated with that animation. At a given moment, an animation effect can be associated with at most one animation.
</p>

<p>
`~animation効果$ %効果 は、次を満たすならば
`時列線が結付けられている@
とされる【この用語は、この仕様~内では利用されていない】
⇒
［
%効果 を`~targetにしている~animation$ %~animation ~NEQ ε
］~AND［
%~animation の`時列線$An ~NEQ ~NULL
］
◎
An animation effect, effect, is associated with a timeline, timeline, if effect is associated with an animation which, in turn, is associated with timeline.
</p>
			</section>
			<section id="types-of-animation-effects">
<h4 title="Types of animation effects">4.5.2. ~animation効果の型</h4>

<p>
この仕様は、`~animation効果$の型として，`~keyframe効果$ 一種のみを定義する。
この仕様の後継~levelは、他の型の`~animation効果$を定義することになる。
◎
This specification defines a single type of animation effect: keyframe effects. Subsequent levels of this specification will define further types of animation effects.
</p>

<p>
どの型の`~animation効果$にも、次~節に述べる，いくつかの~propが定義される。
◎
All types of animation effects define a number of common properties which are described in the following sections.
</p>

			</section>
			<section id="the-active-interval">
<h4 title="The active interval">4.5.3. 作動~区間</h4>

<div class="note">

<p>参考：
`~animation効果$が稼働するよう~scheduleされる期間は，その`作動~区間$と呼ばれる。
そのような区間は 各`~animation効果$ごとに 1 つに限られる。
◎
The period that an animation effect is scheduled to run is called its active interval. Each animation effect has only one such interval.
</p>

<p>
`作動~区間$の下界は、概して，この`~animation効果$を`~targetにしている~animation$の`開始-時刻$に対応するが、`~animation効果$の`開始-遅延$によりズラされ得る。
◎
The lower bound of the active interval typically corresponds to the start time of the animation associated with this animation effect but may be shifted by a start delay on the animation effect.
</p>

<p>
`作動~区間$の上界は、`作動~所要時間$により決定される。
◎
The upper bound of the interval is determined by the active duration.
</p>

<p>
［
`開始-時刻$,
`開始-遅延$,
`作動~所要時間$
］の関係性を下に図示する：
◎
The relationship between the start time, start delay, and active duration is illustrated below.
</p>

<figure>`active-interval-examples^dgm
<figcaption>
<p>
`作動~区間$の端点~上の`開始-遅延$による効果の例：
</p>
<ul>
	<li>(a)
遅延を伴わない~animation効果
— `開始-時刻$, `作動~区間$の始まりは一致する。
</li>
	<li>(b)
正の遅延を伴う~animation効果
— `作動~区間$の始まりは、遅延により先送りされる。
</li>
	<li>
(c)
負の遅延を伴う~animation効果
— `作動~区間$の始まりは、遅延により前倒しされる。
</li>
</ul>
◎
Examples of the effect of the start delay on the endpoints of the active interval.
(a) An animation effect with no delay; the start time and beginning of the active interval are coincident.
(b) An animation effect with a positive delay; the beginning of the active interval is deferred by the delay.
(c) An animation effect with a negative delay; the beginning of the active interval is brought forward by the delay.
</figcaption></figure>

<p>
`終止-遅延$も指定されても~MAYが、その用途は，主として~animationたちを連列するときに限られる。
◎
An end delay may also be specified but is primarily only of use when sequencing animations.
</p>

</div>

<p>
各`~animation効果$は、
`作動~区間@
を定義する
— それは、その間に自身の効果を生産するよう~scheduleされた期間である。
ただし，例外として、`延伸~mode$は，`作動~区間$の外側まで効果を適用する。
◎
Animation effects define an active interval which is the period of time during which the effect is scheduled to produce its effect with the exception of fill modes which apply outside the active interval.
</p>

<p>
`作動~区間$の下界は、`~animation効果$の
`開始-遅延@
により定義される。
それは、この効果を`~targetにしている~animation$の`開始-時刻$からの有符号~offsetを与える。
◎
The lower bound of the active interval is defined by the start delay.
◎
The start delay of an animation effect is a signed offset from the start time of the animation with which the animation effect is associated.
</p>

<p>
`作動~区間$の長さは、`作動~所要時間$と呼ばれる
— その計算は、`作動~所要時間の計算-法$secにて定義される。
◎
The length of the active interval is called the active duration, the calculation of which is defined in §4.8.2 Calculating the active duration.
</p>

<p>
`~animation効果$には
`終止-遅延@
もある
— その用途は、主として，~animationを別の`~animation効果$の`終止-時刻$に基づいて連列するためにある。
これが有用になるのは、概して［
この仕様の後継~levelにおいて導入される連列-効果
］との組合せに限られるが、~SVGにおける `min$a 属性（ `SVG11$r ）を表現する目的で，ここに含まれている。
◎
Similar to the start delay, an animation effect also has an end delay which is primarily of use when sequencing animations based on the end time of another animation effect. Although this is typically only useful in combination with sequence effects which are introduced in a subsequent level of this specification, it is included here for the purpose of representing the min attribute in SVG ([SVG11], Chapter 19).
</p>

<p class="algo-head">
`~animation効果$の
`終止-時刻@
は、次を評価した結果で与えられる
⇒
`max^op( `開始-遅延$ ~PLUS `作動~所要時間$ ~PLUS `終止-遅延$, 0 )
◎
The end time of an animation effect is the result of evaluating max(start delay + active duration + end delay, 0).
</p>

			</section>
			<section id="local-time-section">
<h4 title="Local time">4.5.4. 局所~時刻</h4>

<p>
所与の~momentにおける`~animation効果$の
`局所~時刻@
は、［
それを`~targetにしている~animation$ ~NEQ ε ならば その`現-時刻$ ／
~ELSE_ `未解決$
］とする。
◎
The local time of an animation effect at a given moment is based on the first matching condition from the following:
◎
If the animation effect is associated with an animation,
• the local time is the current time of the animation.
Otherwise,
• the local time is unresolved.
</p>
			</section>
			<section id="animation-effect-phases-and-states">
<h4 title="Animation effect phases and states">4.5.5. ~animation効果の各種~相と状態</h4>

<div class="note">

<p>参考：
`~animation効果$は、所与の~momentにおいて，以下に挙げる 4 種の`相$いずれかになる。
これらの相のうち `遊休~相$i を除く 3 種を次に図示する：
◎
This section is non-normative.
◎
At a given moment, an animation effect may be in one of three possible phases. If an animation effect has an unresolved local time it will not be in any phase.
◎
The different phases are illustrated below.
</p>

<figure>`animation-effect-phases-and-states^dgm
<figcaption>
`~animation効果$を述べるために利用される各種 相と状態の例。
◎
An example of the different phases and states used to describe an animation effect.
</figcaption></figure>

<p>
`~animation効果$の`相$は、その`局所~時刻$ %T, および
その［
`作動~区間$,
`終止-時刻$,
`開始-遅延$,
`終止-遅延$
］に応じて，次に従う：
◎
The phases are as follows:
</p>

<dl>
	<dt>
`遊休~相$i
◎
↓↓</dt>
	<dd>
%T は`未解決$になる間は、この相になる。
◎
↓↓</dd>

	<dt>
`事前~相$i
◎
before phase
</dt>
	<dd>
%T が［
`作動~区間$より前
］かつ［
`終止-時刻$より前
］に入る, または［
`開始-遅延$が負のときは その効果がある
］間は、この相になる。
◎
The animation effect’s local time falls before the effect’s active interval and end time, or occurs during the range when a negative start delay is in effect.
</dd>

	<dt>
`作動~相$i
◎
active phase
</dt>
	<dd>
%T が［
`作動~区間$の内側
］かつ［
`開始-遅延$が負のときは その効果が失せた後
］かつ［
`終止-遅延$が負のときは その効果が生じる前
］に入る間は、この相になる。
◎
The animation effect’s local time falls inside the effect’s active interval and outside the range of any negative start delay or negative end delay.
</dd>

	<dt>
`事後~相$i
◎
after phase
</dt>
	<dd>
%T が［
`作動~区間$より後
］または［
`終止-遅延$が負のときは `終止-時刻$より後
］に入る, かつ［
`開始-遅延$が負のときは その効果が失せた後
］に入る間は、この相になる。
◎
The animation effect’s local time falls after the effect’s active interval or after the end time if that comes first (due to a negative end delay), but not during the range when a negative start delay is in effect.
</dd>
</dl>

<p>
これらの相に加えて、`~animation効果$は，次に挙げる（排他的でない）状態として述べられることもある。
これらの状態は、単独の`~animation~frame$の所要時間~用に限り確立され，主として~modelの状態について簡便に述べるためにある。
◎
In addition to these phases, an animation effect may also be described as being in one of several overlapping states. These states are only established for the duration of a single animation frame and are primarily a convenience for describing stative parts of the model.
</p>

<p>
~modelの中での これらの状態と用法は、次に要約される：
◎
These states and their useage within the model are summarized as follows:
</p>

<dl>
	<dt>
`再生-中$i
◎
in play
</dt>
	<dd>
`~animation効果$は、各~frameごとに`作動~時刻$が変化する状態にある。
◎
Corresponds to an animation effect whose active time is changing on each frame.
</dd>

	<dt>
`現在の$i
◎
current
</dt>
	<dd>
`~animation効果$は、`再生-中$iにあるか, または
将来に`再生-中$iになり得る（`事前~相$iにある）。
◎
Corresponds to an animation effect that is either in play or may become in play in the future. This will be the case if the animation effect is in play or in its before phase.
</dd>

	<dt>
`効果~中$i
◎
in effect
</dt>
	<dd>
`~animation効果$は、`作動~時刻$が解決される状態にある。
これは，`~animation効果$は`作動~相$iにあるか，そうでないが
効果の`延伸~mode$がある（`延伸の挙動$secを見よ）ため、`作動~時刻$は`未解決$にならないことを表す。
◎
Corresponds to an animation effect that has a resolved active time. This occurs when either the animation effect is in its active phase or outside the active phase but at a time where the effect’s fill mode (see §4.6 Fill behavior) causes its active time to be resolved.＼
</dd>
	<dd>
`効果~中$iにある`~animation効果$のみが、その~targetに結果を適用する。
◎
Only in effect animation effects apply a result to their target.
</dd>
</dl>

<p>
これら各~状態の規範的な定義は、以下に~~述べる。
◎
The normative definition of each of these states follows.
</p>
</div>


<p class="algo-head">
所与の時点における`~animation効果$ %効果 の
`相@
は、次に従って計算される：
◎
Determining the phase of an animation effect requires the following definitions:
</p>

<ol>
	<li>
%局所~時刻 ~LET %効果 の`局所~時刻$
◎
↓↓</li>
	<li>
~IF［
%局所~時刻 ~EQ `未解決$
］
⇒
~RET
`遊休~相@i
◎
↓↓</li>
	<li>
`~animation方向@V ~LET ［
次が満たされるならば `後方^i ／
~ELSE_ `前方^i
］
⇒
%効果 を`~targetにしている~animation$（ ~NEQ ε ）の`再生~rate$ ~LT 0
◎
animation direction
• ‘backwards’ if the effect is associated with an animation and the associated animation’s playback rate is less than zero; in all other cases, the animation direction is ‘forwards’.
</li>
	<li>
`作動~前~境界~時刻@V ~LET
`max^op( `min^op( %効果 の`開始-遅延$, %効果 の`終止-時刻$ ), 0 )
◎
before-active boundary time
• max(min(start delay, end time), 0)
</li>
	<li>
`作動~後~境界~時刻@V ~LET
`max^op( `min^op( %効果 の`開始-遅延$ ~PLUS %効果 の`作動~所要時間$, %効果 の`終止-時刻$ ), 0 )
◎
active-after boundary time
• max(min(start delay + active duration, end time), 0)
</li>
	<li>
~IF［
%局所~時刻 ~LT %作動~前~境界~時刻
］~OR［［
%局所~時刻 ~EQ %作動~前~境界~時刻
］~AND［
%~animation方向 ~EQ `後方^i
］］
⇒
~RET
`事前~相@i
◎
An animation effect is in the before phase if the animation effect’s local time is not unresolved and either of the following conditions are met:
• the local time is less than the before-active boundary time, or
• the animation direction is ‘backwards’ and the local time is equal to the before-active boundary time.
</li>
	<li>
~IF［
%局所~時刻 ~GT %作動~後~境界~時刻
］~OR［［
%局所~時刻 ~EQ %作動~後~境界~時刻
］~AND［
%~animation方向 ~EQ `前方^i
］］
⇒
~RET
`事後~相@i
◎
An animation effect is in the after phase if the animation effect’s local time is not unresolved and either of the following conditions are met:
• the local time is greater than the active-after boundary time, or
• the animation direction is ‘forwards’ and the local time is equal to the active-after boundary time.
</li>
	<li>
~RET
`作動~相@i
◎
An animation effect is in the active phase if the animation effect’s local time is not unresolved and it is not in either the before phase nor the after phase.
◎
↑↑Furthermore, it is often convenient to refer to the case when an animation effect is in none of the above phases as being in the idle phase.
</li>
</ol>


<p>
所与の`~animation効果$ %効果 は：
◎
↓</p>

<ul>
	<li>
次を満たすならば
`再生-中@i
にあるとされる
⇒
［
`作動~相$iにある
］~AND［
%効果 を`~targetにしている~animation$（ ~NEQ ε ）の`再生-状態$ ~NEQ `完遂d$i
］
◎
An animation effect is in play if all of the following conditions are met:
• the animation effect is in the active phase, and
• the animation effect is associated with an animation that is not finished.
</li>
	<li>
次を満たすならば
`現在の@i
とされる
⇒
`事前~相$iまたは`再生-中$iにある
【この訳では、この用語は利用せず，そのままこのように記す。】
◎
An animation effect is current if either of the following conditions is true:
• the animation effect is in the before phase, or
• the animation effect is in play.
</li>
	<li>
次を満たすならば
`効果~中@i
にあるとされる
⇒
%効果 の`作動~時刻$ ~NEQ `未解決$
◎
An animation effect is in effect if its active time, as calculated according to the procedure in §4.8.3.1 Calculating the active time, is not unresolved.
</li>
</ul>

			</section>
		</section>
		<section id="fill-behavior">
<h3 title="Fill behavior">4.6. 延伸の挙動</h3>

<p>
`~animation効果$が`再生-中$iでないときの効果は、次のいずれかを値にとる
`延伸~mode@
（ `fill mode^en ）により決定される
⇒＃
`なし^i （ `none^en ）,
`前方^i （ `forwards^en ）,
`後方^i （ `backwards^en ）,
`両方^i （ `both^en ）
◎
The effect of an animation effect when it is not in play is determined by its fill mode.
◎
The possible fill modes are:
• none,
• forwards,
• backwards, and
• both.
</p>

<p>
これらの~modeの規範的~定義は、`作動~時刻の計算-法$secにおける`作動~時刻$の計算に組入れられている。
◎
The normative definition of these modes is incorporated in the calculation of the active time in §4.8.3.1 Calculating the active time.
</p>
			<section id="fill-modes">
<h4 title="Fill modes">4.6.1. 各種~延伸~mode</h4>

~INFORMATIVE

<div class="informative">

<p>
各種`延伸~mode$による，~animation効果が［
`事前~相$i ／ `事後~相$i
］にある間の効果は、次の表に従う：
◎
The effect of each fill mode is as follows:
</p>

<div >
<table><thead><tr>
<th>延伸~mode
<th>`事前~相$i
<th>`事後~相$i
</thead><tbody>

<tr><td>`なし^i
<td>なし
<td>なし

<tr><td>`前方^i
<td>なし
<td>`作動~相$iの最後の~momentと同じ`反復~進捗$値を生産する。

<tr><td>`後方^i
<td>`作動~相$iの最初の~momentと同じ`反復~進捗$値を生産する。
<td>なし

<tr><td>`両方^i
<td>`後方^i と同じ挙動になる。
<td>`前方^i と同じ挙動になる。

</tbody></table>

◎
none
• The animation effect has no effect when it is not in play.
◎
forwards
• When the animation effect is in the after phase, the animation effect will produce the same iteration progress value as the last moment it is scheduled to be in play.
• For all other times that the animation effect is not in play, it will have no effect.
◎
backwards
• When the animation effect is in the before phase, the animation effect will produce the same iteration progress value as the earliest moment that it is scheduled to be in play.
• For all other times that the animation effect is not in play, it will have no effect.
◎
both
• When the animation effect is in its before phase, backwards fill behavior is used.
• When the animation effect is in its after phase, forwards fill behavior is used.
</div>

<p>
これらの延伸~modeの例を下に図示する：
◎
Some examples of the these fill modes are illustrated below.
</p>

<figure >

<table
>
<caption>生産される様々な延伸~modeと状態の例。</caption>
<thead><tr><th>延伸~mode
<th>時間は右に向かって増大する。
中央の区間が作動~相。
</thead><tbody>

<tr><td>`なし^i
<td>
<x-fillmode
><x-fillbox class="x-fillnone"
></x-fillbox><x-fillbox></x-fillbox
><x-fillbox class="x-fillnone"
></x-fillbox></x-fillmode>
<p>
~animation効果による効果は，その作動~相の外側では無い。
</p>

<tr><td>`前方^i
<td>
<x-fillmode
><x-fillbox class="x-fillnone"
></x-fillbox><x-fillbox></x-fillbox
><x-fillbox
></x-fillbox></x-fillmode>
<p>
作動~相が完遂した後でも，`反復~進捗$値は延伸~値を保守し続ける。
</p>

<tr><td>`後方^i
<td>
<x-fillmode
><x-fillbox
></x-fillbox><x-fillbox></x-fillbox
><x-fillbox class="x-fillnone"
></x-fillbox></x-fillmode>
<p>
~animation効果は、作動~相の開始-まで延伸~値を生産する。
</p>

<tr><td>`両方^i
<td>
<x-fillmode
><x-fillbox
></x-fillbox><x-fillbox></x-fillbox
><x-fillbox
></x-fillbox></x-fillmode>
<p>
~animation効果は、作動~相より前, 後の両者にて，延伸~値を生産する。
</p>

</tbody></table>

<!-- animation-state-and-fill-behavior^dgm -->
◎
Examples of various fill modes and the states produced.
(a) fill mode ‘none’. The animation effect has no effect outside its active phase.
(b) fill mode ‘forwards’. After the active phase has finished, the iteration progress value continues to maintain a fill value.
(c) fill mode ‘backwards’. The animation effect produces a fill value until the start of the active phase.
(d) fill mode ‘both’. Both before and after the active phase the animation effect produces a fill value.
</figure>


<p class="note">注記：
延伸~modeを設定しても，［
`作動~区間$の両~端点 ／ `各種~相$sec間の境界
］は~~影響されない。
が、計時~modelの他の様々な~propに対しては効果がある
— ~animation効果の`作動~時刻$が`未解決$にならないのは、`作動~相$iの内側, または延伸が適用されるときに限られるので。
◎
Note: setting a fill mode has no bearing on the endpoints of the active interval or the boundaries between phases. However, the fill mode does have an effect on various other properties of the timing model since the active time of an animation effect is only defined (that is, not unresolved) inside the active phase or when a fill is applied.
</p>

</div>

			</section>
		</section>
		<section id="repeating">
<h3 title="Repeating">4.7. 繰返-法</h3>

			<section id="iteration-intervals">
<h4 title="Iteration intervals">4.7.1. 反復~区間</h4>

<p>
`~animation効果$は、ある固定的な回数, または不定に繰返すよう指定することもできる。
この繰返は、`作動~区間$の`中で生じる^em。
1 回の繰返が占める時刻~~範囲は、
`反復~区間@
と呼ばれる。
◎
It is possible to specify that an animation effect should repeat a fixed number of times or indefinitely. This repetition occurs within the active interval. The span of time during which a single repetition takes place is called an iteration interval.
</p>

<p>
`作動~区間$と違って，~animation効果の`反復~区間$は、複数回あり得る
— 関心があるのは、概して`現-反復$に対応している区間に限られるが。
◎
Unlike the active interval, an animation effect can have multiple iteration intervals although typically only the interval corresponding to the current iteration is of interest.
</p>

<p>
単独の反復の長さは、`~animation効果$の
`反復~所要時間@
と呼ばれる
— 初期~時は 0 とする。
◎
The length of a single iteration is called the iteration duration. The initial iteration duration of an animation effect is zero.
</p>

<div class="note">

<p>参考：
◎
This section is non-normative.
◎
Comparing the iteration duration and the active duration we have:
</p>
<ul>
	<li>
`反復~所要時間$は、~animation効果の単独の反復が完了するまでにかかる時間を表す。
◎
Iteration duration
• The time taken for a single iteration of the animation effect to complete.
</li>
	<li>
`作動~所要時間$は、繰返も含めて，~animation効果の全体が完了するまでににかかる時間を表す。
これは、`反復~所要時間$より長くも短くもなり得る。
◎
Active duration
• The time taken for the entire animation effect to complete, including repetitions. This may be longer or shorter than the iteration duration.
</li>
</ul>

<p>
これらの関係性を下に図示する：
◎
The relationship between the iteration duration and active duration is illustrated below.
</p>

<figure>`iteration-intervals^dgm
<figcaption>
`反復~所要時間$と`反復~回数$ 2.5 にされた~animation効果の`作動~所要時間$
との比較。
最終回の反復に対しても`反復~所要時間$は、変化しないことに注意
— それは、単純に`作動~所要時間$により切落とされる。
◎
A comparison of the iteration duration and active duration of an animation effect with an iteration count of 2.5. Note that the iteration duration for the final iteration does not change, it is simply cut-off by the active duration.
</figcaption></figure>

</div>

			</section>
			<section id="controlling-iteration">
<h4 title="Controlling iteration">4.7.2. 反復の制御-法</h4>


<p>
各`~animation効果$は，次の~propを持つ：
◎
↓<p>

<dl class="def-list">
	<dt>`反復~回数@</dt>
	<dd>
正の無限大も含む， 0  以上の実数-。
`~animation効果$を繰返す回数を指定する。
正の無限大は、不定に繰返すことを表現する。
◎
The number of times an animation effect repeats is called its iteration count. The iteration count is a real number greater than or equal to zero. The iteration count may also be positive infinity to represent that the animation effect repeats indefinitely.
</dd>

	<dt>`反復~始端@</dt>
	<dd>
0 以上の有限~実数-。
一連の反復の中での［
`~animation効果$が始まるべき~offset
］を指定する。
◎
In addition to the iteration count, animation effects also have an iteration start property which specifies an offset into the series of iterations at which the animation effect should begin. The iteration start is a finite real number greater than or equal to zero.
</dd>
</dl>

<p>
これらの挙動は、`中核~animation効果の計算$secにて定義される。
◎
The behavior of these parameters is defined in the calculations in §4.8 Core animation effect calculations.
</p>

<div class="note">
<p>参考：
`反復~回数$, `反復~始端$の効果を下に図示する：
◎
This section is non-normative.
◎
The effect of the iteration count and iteration start parameters is illustrated below.
</p>

<figure>`iteration-count-and-start^dgm
<figcaption>
<p>
`反復~回数$と`反復~始端$による効果。
両~事例とも`反復~回数$は 2.5 にされている：
</p>
<ul>
	<li>
1 個目の事例では、 3 回目の反復は その`反復~区間$の中間点で切落とされる。
</li>
	<li>
2 個目の事例では、`反復~始端$は 0.5 にされている。
その結果、`~animation効果$は 1 回目の反復の中間点から始まるようになる。
</li>
</ul>
◎
The effect of the iteration count and iteration start parameters. In the first case the iteration count is 2.5 resulting in the third iteration being cut-off half way through its iteration interval. The second case is the same but with an iteration start of 0.5. This causes the animation effect to begin half way through the first iteration.
</figcaption></figure>


<p>
`反復~回数$と違って，`反復~始端$は、`作動~所要時間$の長さには効果しない。
◎
Unlike the iteration count parameter, the iteration start parameter does not effect the length of the active duration.
</p>

<p>
`反復~始端$に対する 1 を超える値は、一般には
— `反復~組成-演算~型$に`累積-反復~型$を有する`~animation効果$と組合せて利用されない限り —
有用にはならないことに注意【例えば 1.5 は 0.5 と同じ結果になる】。
◎
Note that values of iteration start greater than or equal to one are generally not useful unless used in combination with an animation effect that has an iteration composite operation of accumulate.
</p>

</div>

			</section>
			<section id="iteration-time-space">
<h4 title="Iteration time space">4.7.3. 反復~時刻~空間</h4>

~INFORMATIVE

<div class="informative">

<p>
~WAnimにおける，すべての時刻は，何らかの基準点に相対的になる。
これらの基準点は、それぞれが異なる`時刻~空間^emを生産する。
◎
In Web Animations all times are relative to some point of reference. These different points of reference produce different time spaces.
</p>

<p>
これは、~computer~graphicsにおいて利用される座標~空間と比較できる。
時刻~空間の 0 時刻は、座標~空間の原点に相似的になる。
◎
This can be compared to coordinate spaces as used in computer graphics. The zero time of a time space is analogous to the origin of a coordinate space.
</p>

<p>
繰返される~animationは、繰返す各回ごとに新たな時刻~空間
— `反復~時刻~空間^em —
を確立しているものと述べれる。
◎
We can describe animations that repeat as establishing a new time space each time the animation repeats: the iteration time space.
</p>

<p>
`反復~時刻~空間^emは、
0 時刻は~animation効果の現在の反復の始まりにされた時刻~空間である。
◎
Iteration time space is a time space whose zero time is the beginning of an animation effect’s current iteration.
</p>

<p>
~WAnim~modelの中では、`作動~時刻$は作動~区間の始まりに相対的な時刻を指す。
しかしながら，この時刻~空間は、この~modelに内部的であり，
~API／~markup
には公開されない。
◎
Within the Web Animations model we also refer to active time which is a time relative to the beginning of the active interval. This time space, however, is internal to the model and not exposed in the programming interface or in markup.
</p>

<p>
これらの時刻~空間を下に図示する：
◎
These time spaces are illustrated below.
</p>

<figure>`time-spaces^dgm
<figcaption>
~animationが［
反復~所要時間 1s,
反復~回数 2.5
］にされているとするときの［
局所~時刻, 作動~時刻, 反復~時刻
］の比較。
◎
A comparison of local time, active time, and iteration time for an animation with a iteration duration of 1s and an iteration count of 2.5.
</figcaption></figure>


<p class="note">注記：
時刻~空間は有界でないが、この仕様は［
`作動~時刻$, `反復~進捗$
］を［
図式に示すような，ある設定された範囲
］に切詰められるものと定義する。
例えば、［
時刻 −1 秒は，作動~時刻~空間~内では妥当な時刻になる
］が、［
`作動~時刻$を計算する手続き（`作動~時刻の計算-法$sec）は，負の値を決して返さない
］ことになる。
◎
Note: While the time spaces themselves are not bounded, Web Animations defines active time and the iteration progress such that they are clamped to a set range as shown in the diagram. For example, whilst a time of -1 second is a valid time in active time space, the procedure for calculating the active time defined in §4.8.3.1 Calculating the active time will never return a negative value.
</p>

<p>
これらの時刻~空間に加えて，［［［［
`現在の大域~obj$の`文書$
］の`既定の文書~時列線$
］の`時刻~値$
］が属する時刻~空間
］を指して，
`文書~時刻~空間^em
という。
【この用語は、利用されていない。】
◎
In addition to these time spaces we can also refer to the document time space which is time space of the time values of the default document timeline of the Document of the current global object.
</p>

</div>

			</section>
			<section id="interval-timing">
<h4 title="Interval timing">4.7.4. 区間の計時</h4>

~INFORMATIVE

<div class="informative">

<p>
~animation効果を繰返すときには、反復~境界における挙動を定義する必要がある。
そのために，この仕様では、ほぼすべての区間~計時に対し，終端除外~計時~modelを利用する。
それは、区間の［
始端, 終端
］時刻のうち始端だけが区間~内に含まれることを意味する。
区間~表記法においては、これは
[ 始端, 終端 )
のように記せる。
この~modelでは、区間が繰返され, 連列されても重合しない点で，理にかなう挙動を供する。
◎
When an animation effect repeats we must define the behavior at the iteration boundaries. For this, and indeed for all interval timing, Web Animations uses an endpoint-exclusive timing model. This means that whilst the begin time of an interval is included in the interval, the end time time is not. In interval notation this can written [begin, end). This model provides sensible behavior when intervals are repeated and sequenced since there is no overlap between the intervals.
</p>

<p>
繰返される効果~用に［
局所~時刻 1s,
反復~時刻 0
］にされた例を次に示す。
この例の連列された例の~animation
— 図の A, B —
に対し，時列線~時刻 1s の所で`再生-中$iになる`~target効果$は、
B のそれに限られ， A のそれとは重合しない。
◎
In the examples below, for the repeated effect, at local time 1s, the iteration time is 0. For the sequenced animations, at timeline time 1s, only animation B’s target effect will be in play; there is no overlap.
</p>

<figure>`endpoint-exclusive-timing^dgm
<figcaption>
終端除外~計時の図示。
繰返され, 連列された 2 つの~animation効果の区間の境界は重合しない。
◎
Illustration of end-point exclusive timing. For both repeated and sequenced animation effects there is no overlap at the boundaries between intervals.
</figcaption></figure>


<p>
この挙動に対する例外は、`延伸の挙動$secを遂行するときである：
延伸が区間の終端点から始まる場合、その終端点が利用される。
この挙動は、`単純~反復~進捗の計算-法$secにて与される~algoに織り込まれており，下に図示されるようになる：
◎
An exception to this behavior is that when performing a fill, if the fill begins at an interval endpoint, the endpoint is used. This behavior falls out of the algorithm given in §4.8.3.3 Calculating the simple iteration progress and is illustrated below.
</p>

<figure>`endpoint-exclusive-timing-and-fill^dgm
<figcaption>
1 回目の反復の終端における`反復~進捗$は 0 になるが，
2 回目の反復の終端~以降における`反復~進捗$は 1 になる。
◎
After one iteration, the iteration progress is 0, but after two iterations (and there onwards), the iteration progress is 1 due to the special behavior defined when an animation effect fills.
</figcaption></figure>

</div>

			</section>
		</section>
		<section id="core-animation-effect-calculations">
<h3 title="Core animation effect calculations">4.8. 中核~animation効果の計算</h3>

			<section id="animation-effect-calculations-overview">
<h4 title="Overview">4.8.1. 概観</h4>

~INFORMATIVE

<div class="informative">

<p>
~WAnim計時~modelでは、`局所~時刻$ 値を`反復~進捗$に変換する処理-が中核を成す。
◎
At the core of the Web Animations timing model is the process that takes a local time value and converts it to an iteration progress.
</p>

<p>
この処理-における最初の段は、`作動~区間$の限界域を計算する。
それは、`作動~所要時間$により決定される。
◎
The first step in this process is to calculate the bounds of the active interval which is determined by the active duration.
</p>

<p>
この処理-を下に図示する：
◎
This process is illustrated below.
</p>

<figure>`active-duration-calculation^dgm
<figcaption>
`作動~所要時間$の計算は、
( `反復~所要時間$ ~MUL `反復~回数$ )
に基づく。
◎
Calculation of the active duration is based on multiplying the iteration duration by the iteration count.
</figcaption></figure>

<p>
`作動~所要時間$を計算する処理-は、`作動~所要時間の計算-法$secにて，規範的に定義される。
◎
The process for calculating the active duration is normatively defined in §4.8.2 Calculating the active duration.
</p>

<p>
`作動~所要時間$が確立されたなら，`~animation効果$の`局所~時刻$は `変形d進捗$（`反復~進捗$）に変形される
— その処理-を下に図示する：
◎
Having established the active duration, the process for transforming an animation effect’s local time into its transformed progress (iteration progress) is illustrated below.
</p>

<figure>
`time-calculations^dgm
<figcaption>
<p>
計時~model計算の概観：
◎
An overview of timing model calculations.
</p>
<ol>
	<li>
`~animation効果$を`~targetにしている~animation$から，`局所~時刻$が決定される。
◎
(1) The local time is determined from the associated animation.
</li>
	<li>
`局所~時刻$は、`開始-遅延$を組入れて`作動~時刻$に変換される。
◎
(2) The local time is converted into an active time by incorporating the start delay.
</li>
	<li>
`作動~時刻$は、`反復~所要時間$により除算された上で，`反復~始端$~propも組入れて`総体~進捗$を生産する。
◎
(3) The active time is divided by the iteration duration incorporating also the iteration start property to produce the overall progress.
</li>
	<li>
`総体~進捗$時刻は、単独の反復の中で，ある~offset
— `単純~反復~進捗$ —
に変換される。
◎
(4) The overall progress time is then converted to an offset within a single iteration: the simple iteration progress.
</li>
	<li>
`単純~反復~進捗$は、`再生~方向$を組入れて`有向~進捗$に変換される。
◎
(5) The simple iteration progress is converted into a directed progress by incorporating the playback direction.
</li>
	<li>
最後に、`有向~進捗$に計時~関数が適用され，`変形d進捗$を生産する。
◎
(6) Finally, a timing function is applied to the directed progress to produce the transformed progress.
</li>
</ol>

</figcaption></figure>

<p>
`局所~時刻$を計算する 1 番目の段は、
`局所~時刻$secにて述べられる。
この図式における 2 〜 4 番目の段は 次~節にて,
5 番目の段は`有向~進捗の計算-法$secにて,
6 番目の段は`変形d進捗の計算-法$secにて
述べられる。
◎
The first step, calculating the local time is described in §4.5.4 Local time. Steps 2 to 4 in the diagram are described in the following sections. Steps 5 and 6 are described in §4.9.1 Calculating the directed progress and §4.10.1 Calculating the transformed progress respectively.
</p>

</div>

			</section>
			<section id="calculating-the-active-duration">
<h4 title="Calculating the active duration">4.8.2. 作動~所要時間の計算-法</h4>

<p class="algo-head">
`~animation効果$ %効果 の
`作動~所要時間@
は、次に従って計算される：
◎
The active duration is calculated as follows:
</p>

<ol>
	<li>
~IF［
%効果 の`反復~所要時間$ ~EQ 0
］~OR［
%効果 の`反復~回数$ ~EQ 0
］
⇒
~RET 0
◎
↓</li>
	<li>
~RET %効果 の`反復~所要時間$ ~MUL %効果 の`反復~回数$
◎
active duration = iteration duration × iteration count
◎
If either the iteration duration or iteration count are zero, the active duration is zero.
</li>
</ol>

<p class="note">注記：
最初の段による明確化は、必要になる
— 無限大 と 0 を乗算した結果は IEEE 754-2008 に則って 定義されないので。
◎
This clarification is needed since the result of infinity multiplied by zero is undefined according to IEEE 754-2008.
</p>
			</section>
			<section id="transforming-the-local-time">
<h4 title="Transforming the local time">4.8.3. 局所~時刻の変形-法</h4>

				</section>
				<section id="calculating-the-active-time">
<h5 title="Calculating the active time">4.8.3.1. 作動~時刻の計算-法</h5>


<p class="algo-head">
`~animation効果$ %効果 の
`作動~時刻@
は，
%効果 の［
`局所~時刻$, `開始-遅延$
］に基づくが、
%効果 が出力を生産するべきときに限り定義されるので，
%効果 の［
`延伸~mode$, `相$
］にも依存する
— 次に従うように：
◎
The active time is based on the local time and start delay. However, it is only defined when the animation effect should produce an output and hence depends on its fill mode and phase as follows,
</p>

<ol>
	<li>
~IF［
%効果 の`相$ ~EQ `遊休~相$i
］
⇒
~RET `未解決$
◎
↓↓</li>
	<li>
~Assert：
`局所~時刻$ ~NEQ `未解決$
◎
↓↓</li>
	<li>
%時刻 ~LET `局所~時刻$ ~MINUS `開始-遅延$
◎
↓</li>
	<li>
<p>
%効果 の`相$に応じて：
</p>
		<ul class="switch">
			<li>
<p>
`事前~相$i：
◎
If the animation effect is in the before phase,
◎
The result depends on the first matching condition from the following,
</p>
				<ol>
					<li>
~IF［
`延伸~mode$ ~IN { `後方^i, `両方^i }
］
⇒
~RET  `max^op( %時刻, 0 )
◎
If the fill mode is backwards or both,
• Return the result of evaluating max(local time - start delay, 0).
</li>
					<li>
~RET `未解決$
◎
Otherwise,
• Return an unresolved time value.
</li>
				</ol>
			</li>
			<li>
`作動~相$i
⇒
~RET %時刻
◎
If the animation effect is in the active phase,
• Return the result of evaluating local time - start delay.
</li>
			<li>
<p>
`事後~相$i：
◎
If the animation effect is in the after phase,
◎
The result depends on the first matching condition from the following,
</p>
				<ol>
					<li>
~IF［
`延伸~mode$ ~IN { `前方^i, `両方^i }
］
⇒
~RET `max^op( `min^op( %時刻, `作動~所要時間$ ), 0)
◎
If the fill mode is forwards or both,
◎
Return the result of evaluating max(min(local time - start delay, active duration), 0).
</li>
					<li>
~RET `未解決$
◎
Otherwise,
• Return an unresolved time value.
◎
Otherwise (the local time is unresolved),
◎
Return an unresolved time value.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>

				</section>
				<section id="calculating-the-overall-progress">
<h5 title="Calculating the overall progress">4.8.3.2. 総体~進捗の計算-法</h5>

<p class="algo-head">
`~animation効果$ %効果 の
`総体~進捗@
は、完了した反復~回数（部分的な反復による端数も含む）を表し、次に従って定義される：
◎
The overall progress describes the number of iterations that have completed (including partial iterations) and is defined as follows:
</p>

<ol>
	<li>
%作動~時刻 ~LET %効果 の`作動~時刻$
◎
↓</li>
	<li>
~IF［
%作動~時刻 ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If the active time is unresolved, return unresolved.
</li>
	<li>
%反復~所要時間 ~LET %効果 の`反復~所要時間$
◎
↓</li>
	<li>
%総体~進捗 ~LET
⇒＃
%反復~所要時間 ~NEQ 0 ならば ( %作動~時刻 ~DIV %反復~所要時間 ) ／
~ELSE_ %効果 は`事前~相$iにあるならば  0 ／
~ELSE_ %効果 の`反復~回数$
◎
Calculate an initial value for overall progress based on the first matching condition from below,
◎
If the iteration duration is zero,
• If the animation effect is in the before phase, let overall progress be zero, otherwise, let it be equal to the iteration count.
◎
Otherwise,
• Let overall progress be the result of calculating active time / iteration duration.
</li>
	<li>
~RET %総体~進捗 ~PLUS %効果 の`反復~始端$
◎
Return the result of calculating overall progress + iteration start.
</li>
</ol>


				</section>
				<section id="calculating-the-simple-iteration-progress">
<h5 title="Calculating the simple iteration progress">4.8.3.3. 単純~反復~進捗の計算-法</h5>

<p class="algo-head">
`~animation効果$ %効果 の
`単純~反復~進捗@
は、次に従って計算される
— それは、［
効果に適用された［
`再生~方向$ ／ `計時~関数$
］により導入される，時刻に対する変形
］は無視する下での，現在の反復~進捗に対する割合分を表す：
◎
The simple iteration progress is a fraction of the progress through the current iteration that ignores transformations to the time introduced by the playback direction or timing functions applied to the effect, and is calculated as follows:
</p>

<ol>
	<li>
%進捗 ~LET %効果 の`総体~進捗$
◎
↓</li>
	<li>
~IF［
%進捗 ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If the overall progress is unresolved, return unresolved.
</li>
	<li>
~IF［
%進捗 ~EQ 無限大
］
⇒
%進捗 ~SET %効果 の`反復~始端$
◎
↓</li>
	<li>
%単純~反復~進捗 ~SET %進捗 ~MINUS `floor^op( %進捗 )
<!-- % 1.0 -->
◎
If overall progress is infinity, let the simple iteration progress be iteration start % 1.0, otherwise, let the simple iteration progress be overall progress % 1.0.
</li>
	<li>
<p>
~IF［
次のいずれも満たされる
］：
◎
If all of the following conditions are true,
</p>
		<ul>
			<li>
%単純~反復~進捗 ~EQ 0
◎
the simple iteration progress calculated above is zero, and
</li>
			<li>
%効果 は［
`作動~相$iまたは`事後~相$iにある
］にある
◎
the animation effect is in the active phase or the after phase, and
</li>
	<li>
%効果 の`作動~時刻$ ~EQ %効果 の`作動~所要時間$
◎
the active time is equal to the active duration, and
</li>
	<li>
%効果 の`反復~回数$ ~NEQ 0
◎
the iteration count is not equal to zero.
</li>
		</ul>
<p>
…ならば
⇒
%単純~反復~進捗 ~LET  1.0
◎
let the simple iteration progress be 1.0.
</p>

<div class="note">

<p>注記：
この段は、~animationの作動~区間の終端と反復の終端が精確に一致するときの延伸の挙動を実装する
— 次回の反復の始端ではなく，最終回の反復の終端点を保持することにより。
◎
The above step implements the behavior that when an animation’s active interval ends precisely at the end of an iteration, it fills by holding the endpoint of the final iteration rather than the start of the next iteration.
</p>

<p>
最後の条件は、［
`反復~回数$ ~EQ 0
］であったため ~animationの反復は決して再生されない場合に，これが適用されないようにする。
◎
The final condition prevents this from applying when we never played any iterations of the animation to begin with because the iteration count was zero.
</p>

</div>

	</li>
	<li>
~RET %単純~反復~進捗
◎
Return simple iteration progress.
</li>
</ol>

			</section>
			<section id="calculating-the-current-iteration">
<h4 title="Calculating the current iteration">4.8.4. 現在の反復の計算-法</h4>


<p class="algo-head">
`~animation効果$ %効果 の
`現-反復@
は、次の手続きで与えられ、整数または無限大になる：
◎
The current iteration can be calculated using the following steps:
</p>

<ol>
	<li>
~IF［
`作動~時刻$ ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If the active time is unresolved, return unresolved.
</li>
	<li>
~IF［
%効果 は`事後~相$iにある
］~AND［
`反復~回数$ ~EQ 無限大
］
⇒
~RET 無限大
◎
If the animation effect is in the after phase and the iteration count is infinity, return infinity.
</li>
	<li>
~IF［
`単純~反復~進捗$ ~EQ 1.0
］
⇒
~RET `floor^op( `総体~進捗$ ) ~MINUS 1
◎
If the simple iteration progress is 1.0, return floor(overall progress) - 1.
</li>
	<li>
~RET `floor^op( `総体~進捗$ )
◎
Otherwise, return floor(overall progress).
</li>
</ol>

			</section>
		</section>
		<section id="direction-control">
<h3 title="Direction control">4.9. 方向~制御</h3>


<p>
`~animation効果$は、方向~制御を利用して，反復ごとに方向が交替するようにも環境設定できる。
この目的~用に、`~animation効果$には，次のいずれかの値をとる
`再生~方向@
がある
⇒＃
`normal^v,
`reverse^v,
`alternate^v,
`alternate-reverse^v
◎
Animation effects may also be configured to run iterations in alternative directions using direction control. For this purpose, animation effects have a playback direction parameter which takes one of the following values:
• normal,
• reverse,
• alternate, or
• alternate-reverse.
</p>


<p>
これらの値の意味論は、以下に与える`有向~進捗$の計算に組入れられる。
◎
The semantics of these values are incorporated into the calculation of the directed progress which follows.
</p>

<div class="note">

<p>参考：
これらの値の規範的でない定義は：
◎
This section is non-normative.
◎
A non-normative definition of these values is as follows:
</p>

<dl>
	<dt>
`normal^v
◎
normal
</dt>
	<dd>
すべての反復は、指定されたとおりに再生される。
◎
All iterations are played as specified.
</dd>

	<dt>
`reverse^v
◎
reverse
</dt>
	<dd>
すべての反復は、指定された仕方と逆方向に再生される。
◎
All iterations are played in the reverse direction from the way they are specified.
</dd>

	<dt>
`alternate^v
◎
alternate
</dt>
	<dd>
`現-反復$が偶数のときは 指定されたとおりに再生され，奇数のときは その逆方向に再生される。
【 0 回目が初回を表す。】
◎
Even iterations are played as specified, odd iterations are played in the reverse direction from the way they are specified.
</dd>

	<dt>
`alternate-reverse^v
◎
alternate-reverse
</dt>
	<dd>
再生される方向は、各~反復ごとに `alternate^v と逆になる。
◎
Even iterations are played in the reverse direction from the way they are specified, odd iterations are played as specified.
</dd>
</dl>

</div>



			<section id="calculating-the-directed-progress">
<h4 title="Calculating the directed progress">4.9.1. 有向~進捗の計算-法</h4>

<p class="algo-head">
`~animation効果$ %効果 の
`有向~進捗@
は、次の手続きを利用して計算される：
◎
The directed progress is calculated from the simple iteration progress using the following steps:
</p>

<ol>
	<li>
%進捗 ~LET %効果 の`単純~反復~進捗$
◎
↑</li>
	<li>
~IF［
%進捗 ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If the simple iteration progress is unresolved, return unresolved.
</li>
	<li>
<p>
%現在の方向 ~LET 次の下位手続きを走らせた結果：
◎
Calculate the current direction using the first matching condition from the following list:
</p>
		<ol>
			<li>
%再生~方向 ~LET %効果 の`再生~方向$
◎
↓</li>
			<li>
~IF［
%再生~方向 ~EQ `normal^v
］
⇒
~RET `順方向^i
◎
If playback direction is normal,
• Let the current direction be forwards.
</li>
			<li>
~IF［
%再生~方向 ~EQ `reverse^v
］
⇒
~RET `逆方向^i
◎
If playback direction is reverse,
• Let the current direction be reverse.
◎
Otherwise,
</li>
			<li>
%d ~LET %効果 の`現-反復$
◎
Let d be the current iteration.
</li>
			<li>
~IF［
%d ~EQ 無限大
］
⇒
~RET `順方向^i
◎
↓</li>
			<li>
~IF［
%再生~方向 ~EQ `alternate-reverse^v
］
⇒
%d ~INCBY 1
◎
If playback direction is alternate-reverse increment d by 1.
</li>
			<li>
~RET［
%d は偶数ならば `順方向^i ／
~ELSE_ `逆方向^i
］
◎
If d % 2 == 0, let the current direction be forwards, otherwise let the current direction be reverse. If d is infinity, let the current direction be forwards.
</li>
		</ol>
	</li>
	<li>
~RET %現在の方向 に応じて
⇒＃
`順方向^i ならば %進捗 ／
`逆方向^i ならば ( 1.0 ~MINUS %進捗 )
◎
If the current direction is forwards then return the simple iteration progress.
◎
Otherwise, return 1.0 - simple iteration progress.
</li>
</ol>


			</section>
		</section>
		<section id="time-transformations">
<h3 title="Time transformations">4.10. 時間の変形</h3>

<p>
［
`~animation効果$が進捗する~rate
］を制御したいと欲されることは多い。
例えば，~animationの~rateの加減速（ `easing^en ）は、慣性感のある より自然な効果を生産する。
`CSS-TIMING-1$r は、この目的に`計時~関数$を定義する。
◎
It is often desirable to control the rate at which an animation effect progresses. For example, easing the rate of animation can create a sense of momentum and produce a more natural effect. The CSS Timing Functions Module [CSS-TIMING-1] defines timing functions for this purpose.
</p>

<p>
各`~animation効果$には、`計時~関数$が結付けられる。
既定の`計時~関数$は、`線形~計時~関数$とする。
◎
Animation effects have one timing function associated with them. The default timing function is the linear timing function.
</p>



			<section id="calculating-the-transformed-progress">
<h4 title="Calculating the transformed progress">4.10.1. 変形d進捗の計算-法</h4>

<p class="algo-head">
`~animation効果$ %効果 の
`変形d進捗@
は、 %効果 の`有向~進捗$から次の手続きを利用して計算される：
◎
The transformed progress is calculated from the directed progress using the following steps:
</p>

<ol>
	<li>
~IF［
%効果 の`有向~進捗$ ~EQ `未解決$
］
⇒
~RET `未解決$
◎
If the directed progress is unresolved, return unresolved.
</li>
	<li>
%現在の方向 ~LET `有向~進捗の計算-法$secに定義される手続きの中で決定されるそれ
◎
Calculate the value of the before flag as follows:
◎
Determine the current direction using the procedure defined in §4.9.1 Calculating the directed progress.
</li>
	<li>
<p>
%直前~flag ~LET ［
次のいずれかが満たされるならば ~ON ／
~ELSE_ ~OFF
］：
◎
If the current direction is forwards, let going forwards be true, otherwise it is false.＼
The before flag is set＼
</p>
		<ul>
			<li>
［
%効果 は`事前~相$iにある
］~AND［
%現在の方向 ~EQ `順方向^i
］
◎
if the animation effect is in the before phase and going forwards is true; or＼
</li>
			<li>
［
%効果 は`事後~相$iにある
］~AND［
%現在の方向 ~EQ `逆方向^i
］
◎
if the animation effect is in the after phase and going forwards is false.
</li>
		</ul>
	</li>
	<li>
~RET 次を与える下で，`~animation効果$の`計時~関数$から`出力~進捗~値$を得た結果
⇒＃
`入力~進捗~値$ ~SET `有向~進捗$,
`直前~flag$ ~SET %直前~flag
◎
Return the result of evaluating the animation effect’s timing function passing directed progress as the input progress value and before flag as the before flag.
</li>
</ol>

			</section>
		</section>
		<section id="the-iteration-progress">
<h3 title="The iteration progress">4.11. 反復~進捗</h3>

<p>
`~animation効果$の
`反復~進捗@
は、単純にその`変形d進捗$とする。
◎
The iteration progress of an animation effect is simply its transformed progress.
</p>


		</section>
	</section>
	<section id="animation-model">
<h2 title="Animation model">5. ~animation~model</h2>

~INFORMATIVE

<div class="informative">

<p>
~WAnimの`~animation~model^emにおいては、一部の種類の`~animation効果$に対し，`計時~model^emにより生産される［
`反復~進捗$, `現-反復$
］値を利用して，対応する出力を計算する。
◎
For some kinds of animation effects, the Web Animations animation model takes the iteration progress and current iteration values produced by the timing model and uses them to calculate a corresponding output.
</p>

<p>
そのような各~animation効果の出力は、~target~propに適用される前に，`効果~stack$を利用して他のそれらと結合される（`効果の結合-法$secを見よ）。
◎
The output of each such animation effect is then combined with that of others using an effect stack before being applied to the target properties (see §5.5 Combining effects).
</p>

</div>

		<section id="introduction-to-the-animation-model">
<h3 title="Introduction">5.1. 序論</h3>

<p>
`~animation効果$には、その計時~出力の変化に応答して影響される 0 個~以上の~propがある
— これらの~propは，その効果の
`~target~prop@
と総称される。
◎
An animation effect may have zero or more associated properties that it affects in response to changes to its timing output. These properties are referred to as the effect’s target properties.
</p>

<p>
`~animation効果$の各`~animate可能$な`~target~prop$用の
`効果~値@
は、［
その~propの`~animation型$に定義される適切な手続き
］を所与の［
`反復~進捗$,
`現-反復$,
`下層~値$
］に適用することにより，生産される。
◎
Given an iteration progress, a current iteration, and an underlying value, an animation effect produces an effect value for each animatable target property by applying the procedures from the animation type appropriate to the property.
</p>



		</section>
		<section id="procedures-for-animating-properties">
<h3 title="Procedures for animating properties">5.2. ~animateしている~prop用の各種~手続き</h3>

<p>
どの~CSS~propも、特に他が定義されない限り，
`~animate可能@
であると見なされる。
~propを~animateするためには、~propの`~animation型$に，次に挙げる手続きが定義され~MUST：
◎
Unless specifically defined otherwise, all CSS properties are considered animatable. In order to animate a property, the following procedures must be defined.
</p>

<dl class="def-list">
	<dt>`補間@</dt>
	<dd>
<p>
所与の 2 個の~prop値
( %V/start, %V/end ),
および実数 %p に対し，区間 [ %V/start 〜 %V/end ] 内の距離を表す中間~値 %V/result を生産する
— 次を満たすように
⇒＃
%p ~EQ 0 ならば %V/start ／
%p ~EQ 1 ならば %V/end
</p>

<p>
`計時~関数$の効果に因り， %p の範囲は区間 (−∞, ∞) にわたる。
よって，この手続きは、区間 [0, 1] の外側にある %p に対しても外挿の挙動を定義し~MUST。
</p>
◎
interpolation — given two property values Vstart and Vend, produces an intermediate value Vresult at a distance of p along the interval between Vstart and Vend such that p = 0 produces Vstart and p = 1 produces Vend. The range of p is (−∞, ∞) due to the effect of timing functions. As a result, this procedure must also define extrapolation behavior for p outside [0, 1].
</dd>

	<dt>`加算@</dt>
	<dd>
所与の 2 個の~prop値
( %V/a, %V/b )
の総和 %V/result を返す。
加算が可換でない場合（例えば, 行列の乗算）、これらの項の順序も有意になる。
◎
addition — given two property values Va and Vb, returns the sum of the two properties, Vresult. For addition that is not commutative (for example, matrix multiplication) Va represents the first term of the operation and Vb represents the second.
</dd>
	<dd class="note">参考：
`加算$は、`補間$の定義に利用される加重平均~関数と同じ用語に基づいて表せることが多いが、常に可能とは限らない。
例えば，変形-行列の補間は 行列~成分の分解-法と補間-法を孕む一方で、それらの加算は 行列の乗算に依拠する。
◎
This section is non-normative.
◎
While addition can often be expressed in terms of the same weighted sum function used to define interpolation, this is not always the case. For example, interpolation of transform matrices involves decomposing and interpolating the matrix components whilst addition relies on matrix multiplication.
</dd>

	<dt>`累積@</dt>
	<dd>
所与の 2 個の~prop値
( %V/a, %V/b )
に対し，［
%V/b は %V/a からの`差分^em として扱われる
］ように結合した結果 %V/result を返す。
累積が可換でない場合（例えば，合致していない変形-~listの累積）、これらの項の順序も有意になる。
◎
accumulation — given two property values Va and Vb, returns the result, Vresult, of combining the two operands such that Vb is treated as a delta from Va. For accumulation that is not commutative (for example, accumulation of mismatched transform lists) Va represents the first term of the operation and Vb represents the second.
</dd>
	<dd class="note">参考：
実数や長さなど，多くの型の~animation用の`累積$は、`加算$と一致するように定義される。
この 2 つの定義が相違する共通的な事例として，~listに基づく型がある
— そこでは、`加算$は ~listに付加するものとして, `累積$は 成分ごとの加算として定義されることもある。
例えば，~filter~list値【 `filter-value-list$t 】［
`blur(2)^v, `blur(3)^v
］は、`加算-$されるときは `blur(2) blur(3)^v を生産する一方で，`累積-$されるときは `blur(5)^v を生産するであろう。
◎
This section is non-normative.
◎
For many types of animation such as numbers or lengths, accumulation is defined to be identical to addition.
◎
A common case where the definitions differ is for list-based types where addition may be defined as appending to a list whilst accumulation may be defined as component-based addition. For example, the filter list values "blur(2)" and "blur(3)", when added together may produce "blur(2) blur(3)", but when accumulated, may produce "blur(5)".
</dd>
</dl>

<p>
上に挙げた各~手続きは、~CSS`算出d値$に適用される（`算出d~keyframeの計算-法$secを見よ）。
その結果、例えば `length$t 値［
`15pt^v, `5em^v
］を加算する方法を定義することは，必要とされない
— そのような値は、上の手続きに渡される前に `px^css 単位の値に解決されることになるので。
◎
The above procedures apply to CSS computed property values (see §5.4.2 Calculating computed keyframes). As a result, it is not necessary to define, for example, how to add a &lt;length&gt; value of "15pt" with "5em" since such values will be resolved to pixel values before being passed to any of the above procedures.
</p>
		</section>
		<section id="animation-types">
<h3 title="Animation types">5.3. 各種~animation型</h3>

<p>
所与の~propを~animateするために利用される特定の手続きは、その~propの
`~animation型@
と総称される。
◎
The specific procedures used for animating a given property are referred to as the property’s animation type.
</p>

<p>
各~CSS~propの`~animation型$は、~prop定義~表の "~animate可能：" 欄に定義されるか，そのような欄を欠く~prop用には `CSS-TRANSITIONS-1$r にて定義される。
`現在の大域~obj$用の `registerProperty()$m ~methodを利用して登録された`~custom~prop$の`~animation型$は、その~propの `syntax$m を定義するために利用された型から導出される。
［
~propに指定された `syntax$m に対応する`~animation型$
］が無い所では（例：構文は `*^l のとき）、`~animation型$は`離散的$aTとする。
他のすべての~custom~propに対しては、その`~animation型$は`離散的$aTとする。
◎
The animation type of each CSS property is defined by the "Animatable:" line in the summary of the property’s definition or in [CSS-TRANSITIONS-1] for properties that lack a such a line. For custom properties registered using the registerProperty() method for the current global object, the animation type is derived from the type used to define the property’s syntax. Where there is no animation type that corresponds to the property’s specified syntax (e.g. when the syntax is "*") the animation type is discrete. The animation type of all other custom properties is discrete.
</p>


<p class="issue">
上では
"<code class="prod">`length^t+</code>"
などの構文~用に利用する~animation型を説明していない。
これは、~animation型の定義が `CSS Values and Units^en へ移動されたなら，修正されることになる
— そこでは、~list型, 等々用に汎用的な取扱いが定義されるべきである。
◎
The above doesn’t explain the animation type to use for of syntax such as "&lt;length&gt;+". We will fix this once the definition of animation types has moved to CSS Values and Units where we should define generic handling for list types etc.
</p>

<p>
一連の予め定義された`~animation型$を以下に挙げる。
`CSS-TRANSITIONS-1$r は、他にも~CSSに特有の`~animation型$を供する。
◎
Following is a series of pre-defined animation types. [CSS-TRANSITIONS-1] provides further CSS-specific animation types.
</p>

<p>
`~animation型$のうち
`加法的でない@
— すなわち，`加算$用に特定の手続きを定義しない —
ものと定義されたものの`加算$手続きは、単純に次で与えられる
⇒
%V/result = %V/b
◎
For animation types that do not define a specific procedure for addition or which are defined as not additive, the addition procedure is simply Vres = Vb.
</p>

<p>
`~animation型$のうち，`累積$用に特定の手続きを定義しないもののの`累積$手続きは、その型~用の`加算$手続きと一致するものとする。
◎
For animation types that do not define a specific procedure for accumulation, the accumulation procedure is identical to the addition procedure for that type.
</p>


			<section id="not-animatable-section">
<h4 title="Not animatable">5.3.1. ~animate不可の~prop</h4>

<p>
一部の~propは、
`~animate不可@
であると特定的に定義される。
例えば，~animation~parameterを定義している~propは、`~animate不可$とされる
— 可能にすると再帰的で複雑な挙動をもたらすことになるので。
◎
Some properties are specifically defined as not animatable. For example, properties defining animation parameters are not animatable since doing so would create complex recursive behavior.
</p>

<p>
他と違って、`~animate不可$の~prop用に定義される`~animation型$には，［
`補間$, `加算$, `累積$
］用の手続きは無い
— これらの~propは改変されるべきでないので。
◎
Unlike other animation types, no procedures for interpolation, addition and accumulation are defined for properties whose animation type is not animatable since these properties should not be modified.
</p>

<p>
`~animate不可$の~propを~targetにする`~animation効果$は、依然として，通例の`~animation効果$用の挙動を露にすることになる
— `~animation$の`現在の完遂d~promise$の充足を遅延するなど。
◎
An animation effect that targets a property that is not animatable will still exhibit the usual behavior for an animation effect such as delaying the fulfilment of an animation’s current finished promise.
</p>


			</section>
			<section id="discrete-animation-type-section">
<h4 title="Discrete">5.3.2. 離散的</h4>

<p>
~propのうち，その`~animation型$は
`離散的@aT
とされたものの挙動は、次で与えられる：
◎
A property whose animation type is discrete has the following behavior:
</p>

<dl class="def-list">
	<dt>
`補間$：
◎
interpolation:
</dt>
	<dd>
%V/result ~EQ %p に応じて
⇒＃
%p ~LT 0.5 ならば %V/start ／
%p ~GTE 0.5 ならば %V/end
◎
Vresult = Vstart, if p &lt; 0.5 or Vend, if p ≥ 0.5 
</dd>
</dl>

			</section>
			<section id="real-number-animation-type-section">
<h4 title="Real number">5.3.3. 実数-</h4>

<p>
~propのうち，その`~animation型$は
`実数-@aT
とされたものの挙動は、次で与えられる：
◎
A property whose animation type is real number has the following behavior:
</p>


<dl class="def-list">
	<dt>
`補間$：
◎
interpolation:
</dt>
	<dd>
%V/result ~EQ
(1 ~MINUS %p ) ~MUL %V/start ~PLUS %p ~MUL %V/end
◎
Vresult = (1 - p) × Vstart + p × Vend
</dd>

	<dt>
`加算$：
◎
addition:
</dt>
	<dd>
%V/result ~EQ %V/a ~PLUS %V/b
◎
Vresult = Va + Vb
</dd>
</dl>

			</section>
			<section id="length-percentage-or-calc-animation-type-section">
<h4 title="Length, percentage, or calc">5.3.4. 長さ／百分率／~calc式</h4>

<p>
~propのうち，その`~animation型$は
`長さ／百分率／~calc式@aT
とされたものの挙動は、次で与えられる：
◎
A property whose animation type is length, percentage, or calc has the following behavior:
</p>

<dl class="def-list">
	<dt>
`補間$：
◎
interpolation:
</dt>
	<dd>
`CSS-TRANSITIONS-1$r にて定義される。
◎
as defined in [CSS-TRANSITIONS-1].
</dd>

	<dt>
`加算$：
◎
addition:
</dt>
	<dd>
%V/result ~EQ 次の式に等価な値
⇒
<code class="css">calc( %V/a + %V/b )</code>
<br>
◎
Vresult = calc(Va + Vb)＼
</dd>
	<dd>
（入子にされた `calc()^css 関数は、算出d値を決定するときには
`CSS3VAL$r による
<a href="~CSSVAL#calc-computed-value">算出d値</a>
節に定義されるように展開される。）
◎
(Nested calc() functions are expanded when determining the computed value as defined in CSS Values and Units [CSS3VAL].)
</dd>
</dl>


			</section>
			<section id="color-animation-type-section">
<h4 title="Color">5.3.5. 色</h4>

<p>
~propのうち，その`~animation型$は
`色@aT
とされたものの挙動は、次で与えられる：
◎
A property whose animation type is color has the following behavior:
</p>

<dl class="def-list">
	<dt>
`補間$：
◎
interpolation:
</dt>
	<dd>
`CSS-TRANSITIONS-1$r にて定義される。
◎
as defined in [CSS-TRANSITIONS-1].
</dd>

	<dt>
`加算$：
◎
addition:
</dt>
	<dd>
各 RGBA 色~成分ごとに，乗算済み空間~内で`実数-$aTと同じように遂行される。
◎
addition: as with real number but performed on each RGBA color component in premultiplied space.
</dd>
	<dd class="note">注記：
現在，負の色は~supportされないので、~channel値は，各~加算ごとに, および`組成$の完了-時に切詰められ得る。
◎
Note: Since negative color is not currently supported, clamping of the channel values may be performed upon each addition or once when composition is complete.
</dd>
</dl>

			</section>
			<section id="transform-list-animation-type-section">
<h4 title="Transform list">5.3.6. 変形-~list</h4>

<p>
~propのうち，その`~animation型$は
`変形-~list@aT
とされたものの挙動は、次で与えられる：
◎
A property whose animation type is transform list has the following behavior:
</p>

<dl class="def-list">
	<dt>
`補間$：
◎
interpolation:
</dt>
	<dd>
`CSS3-TRANSFORMS$r による
<a href="~TRANSFORM#interpolation-of-transforms">変形-の補間</a>
にて定義される。
◎
as defined in Interpolation of Transforms [CSS3-TRANSFORMS].
</dd>

	<dt>
`加算$：
◎
addition:
</dt>
	<dd>
変形-~list［
%V/a, %V/b
］を順に連結して得られる変形-~listになる。
◎
performed by concatenating transform lists as ‘Va Vb’.
</dd>

	<dt>
`累積$：
◎
accumulation:
</dt>
	<dd>
<p>
次を走らせた結果になる：
◎
↓</p>

		<ol>
			<li>
%V/c ~LET 新たな~list
◎
↓</li>
			<li>
<p>
~WHILE［
%V/a, %V/b とも空でない
］：
</p>
				<ol>
					<li>
( %F/a, %F/b ) ~LET ( %V/a 内の最後の変形-, %V/b 内の最後の変形- )
</li>

					<li>
<p>
~IF［
%F/a と %F/b の型は同じでない
］
⇒
~BREAK
</p>

<p class="issue">
おそらく，型を照合する前に 2d 関数をそれぞれの 3d 等価に展開するべきか。
</p>
					</li>
					<li>
<p>
%V/c の先頭に次の結果を付加する
⇒
%F/a と同じ型の変形-であって，
%F/a の各 数量~引数と %F/b 内の各 数量~引数をそれぞれ加算した各 結果を引数にとるもの
</p>

<p class="issue">
これは、もっと~~詳細を詰める必要がある
— 例えば
`translate(20px)^v と `translate(30px 10px)^v
を結合するときは，前者の関数をまず `translate(20px 0px)^v に展開する必要がある。
おそらく，単位の変換も定義する必要がある。
</p>

					</li>
					<li>
%V/a から %F/a を除去する
</li>
					<li>
%V/b から %F/b を除去する
</li>
				</ol>

◎
Beginning at the end of each list, Va and Vb, find the largest contiguous portion of each list where the corresponding list elements from each list have the same transform type. Call the matching portions from Va and Vb, Vmatching-a and Vmatching-b respectively and likewise Vremainder-a and Vremainder-b for the non-matching parts.
◎
We should probably expand 2d functions to their 3d equivalents before matching?
◎
Let Vcombined be a transform list combining Vmatching-a and Vmatching-b by adding the numeric components of each corresponding function.
◎
This needs to be more specific, e.g. when combining translate(20px) and translate(30px 10px) we have to expand the first function to translate(20px 0px) first. Probably need to define unit conversion too.
</li>
			<li>
~RET ［
%V/a, %V/b, %V/c
］を`加算-$して
— すなわち，順に連結して —
作成される変形-~list
◎
The result of accumulation is a transform list created by adding the combined result with the non-matching portions of the two lists as follows: ‘Vremainder-a Vremainder-b Vcombined’.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="other-animation-types">
<h4 title="Other animation types">5.3.7. 他の~animation型</h4>

<p>
ここに定義される各種`~animation型$は、他の仕様により拡張され得る。
例えば `image^t 型を利用している~propは、
`CSS3-IMAGES$r による
<a href="~CSSIMAGE#interpolating-images">`image^t の補間-法</a>
に定義される挙動を利用して~animate化される。
◎
The set of animation types defined here may be extended by other specifications. For example, properties with using the &lt;image&gt; type are animated using the interpolation behavior defined in CSS Image Values and Replaced Content [CSS3-IMAGES].
</p>

			</section>
		</section>
		<section id="keyframe-effects">
<h3 title="Keyframe effects">5.4. ~keyframe効果</h3>

<p>
`~keyframe効果@
は、`~animation効果$の一種であり，計時~modelの出力を利用して，
`~target要素@
と称される［
要素や
`before^pe, `after^pe
などの疑似要素 `SELECT$r
］用の~CSS~propを更新する。
◎
Keyframe effects are a kind of animation effect that use the output of the timing model to update CSS properties for an element or pseudo-element such as ::before or ::after [SELECT] referred to as the target element.
</p>


			<section id="keyframes-section">
<h4 title="Keyframes">5.4.1. ~keyframe</h4>

<p>
`~keyframe効果$用の`効果~値$は、それぞれが［
範囲 [0, 1] に入る ある~offset
］に位置された，一連の~prop値を補間することにより計算される。
同じ~offsetに対応する［
~prop値が成す集合
］は、
`~keyframe@
と呼ばれる。
◎
The effect values for a keyframe effect are calculated by interpolating between a series of property values positioned at fractional offsets. Each set of property values indexed by an offset is called a keyframe.
</p>

<p>
各`~keyframe$の
`~keyframe~offset@
は、範囲 [0, 1] 内に入る値, または
特別な値 ~NULL をとる。
`~keyframe効果$用の`~keyframe$たちが成す~listは、
`~offsetにより~looseに~sortされ@
~MUST
— すなわち、~list内の`~keyframe$のうち［
`~keyframe~offset$ ~NEQ ~NULL
］なるものどうしは，~offsetの昇順に~sortされることを意味する。
【この段落は、~keyframe~listを~APIの入力に渡す作者~向けの要件。】
◎
The offset of a keyframe is a value in the range [0, 1] or the special value null. The list of keyframes for a keyframe effect must be loosely sorted by offset which means that for each keyframe in the list that has a keyframe offset that is not null, the offset is greater than or equal to the offset of the previous keyframe in the list with a keyframe offset that is not null, if any.
</p>

<p>
複数の`~keyframe$が重合する†場合, および
~supportされない値††をとる場合の挙動は、`~keyframe効果の効果~値$secにて定義される。
【†~keyframeどうしが “重合する” とは、互いの`~keyframe~offset$が一致することを意味すると見受けられる。】
【††何の値が何から~supportされないのか はっきりしない。】
◎
The behavior when keyframes overlap or have unsupported values is defined in §5.4.3 The effect value of a keyframe effect.
</p>

<p>
各~keyframeには，`計時~関数$も結付けられ、その~keyframeから~list内の次の~keyframeまでの期間に適用される。
~list内で最後の~keyframeに指定された`計時~関数$は、決して適用されない。
◎
Each keyframe also has a timing function associated with it that is applied to the period of time between the keyframe on which it is specified and the next keyframe in the list. The timing function specified on the last keyframe in the list is never applied.
</p>

<div class="p">
<p>
各`~keyframe$には、
`~keyframeに特有の組成-演算~型@
が定義され得る：
</p>
<ul>
	<li>
定義される場合、~keyframe内に指定された すべての~prop値に適用される
— とり得る演算~型とその意味は、`~keyframe効果$の`組成-演算~型$用に定義されるものに一致する。
</li>
	<li>
定義されない場合、 ~NULL をとるとする
— その場合、~keyframeが属する`~keyframe効果$用に指定された一式の`組成-演算~型$が利用される。
</li>
</ul>

◎
Each keyframe may have a keyframe-specific composite operation that, if not null, is applied to all values specified in that keyframe. The possible operations and their meanings are identical to those defined for the composite operation associated with the keyframe effect as a whole in §5.5.4 Effect composition. If the keyframe-specific composite operation for a keyframe is null, the composite operation specified for the keyframe effect as a whole is used for values specified in that keyframe.
</div>

			</section>
			<section id="calculating-computed-keyframes">
<h4 title="Calculating computed keyframes">5.4.2. 算出d~keyframeの計算-法</h4>

<p>
`~keyframe効果$の`効果~値$を計算する前に、それを成す各`~keyframe$に対しては
⇒＃
~keyframe上に指定された~prop値は`算出d値$に解決される。
~keyframeの`~keyframe~offset$が値 ~NULL をとる場合には，利用する相応しい~offsetも算出される。
◎
Before calculating the effect value of a keyframe effect, the property values specified on its keyframes are resolved to computed values, and the offset to use for any keyframes with a null keyframe offset is computed. The result of resolving these values is a set of computed keyframes.
</p>

<p>
これらの値を解決した結果は、
`算出d~keyframe~list@
と称され、結果を成す`~keyframe~offset$は
`算出d~keyframe~offset@
と称される。
◎
The calculated keyframe offsets of a set of keyframe that includes suitable values for each null keyframe offset are referred to as the computed keyframe offsets.
</p>

<p class="algo-head">
`算出d~keyframe~offset$は、次に定義する
`欠落~keyframe~offsetを算出する@
手続きを利用して生産される
— それは、所与の
( 一連の`~keyframe$が成す~list %~keyframe~list )
に対し，次を走らす：
◎
To produce computed keyframe offsets, we define a procedure to compute missing keyframe offsets that takes a sequence of keyframes, keyframes, and has the following steps:
</p>

<ol>
	<li>
~IF［
%~keyframe~list は空である
］
⇒
~RET
◎
↓</li>
	<li>
%~offset~list ~LET %~keyframe~list 内の各~keyframeの`~keyframe~offset$からなる同順の~list
◎
For each keyframe, in keyframes, let the computed keyframe offset of the keyframe be equal to its keyframe offset value.
</li>
	<li>
%終端~index ~LET %~offset~list の~size ~MINUS 1
◎
↓</li>
	<li>
~IF［
%~offset~list[ 0 ] ~EQ ~NULL
］
⇒
%~offset~list[ 0 ] ~SET 0
◎
If keyframes contains more than one keyframe and the computed keyframe offset of the first keyframe in keyframes is null, set the computed keyframe offset of the first keyframe to 0.
</li>
	<li>
~IF［
%~offset~list[ %終端~index ] ~EQ ~NULL
］
⇒
%~offset~list[ %終端~index ] ~SET 1
◎
If the computed keyframe offset of the last keyframe in keyframes is null, set its computed keyframe offset to 1.
</li>
	<li>
( %始端~index, %始端~offset ) ~LET ( 0, %~offset~list[ 0 ] )
◎
↓</li>
	<li>
<p>
~EACH( 整数 %~index ~IN { 1 〜 %終端~index } ) に対し，昇順に：
</p>
		<ol>
			<li>
%~offset ~LET %~offset~list[ %~index ]
</li>
			<li>
~IF［
%~offset ~EQ ~NULL
］
⇒
~CONTINUE
</li>
			<li>
%n ~LET %~index ~MINUS %始端~index
</li>
			<li>
~EACH( 整数 %j ~IN { 1 〜 %n ~MINUS 1 } ) に対し，昇順に
⇒
%~offset~list[ %始端~index ~PLUS %j ] ~SET
%始端~offset ~PLUS ( %~offset ~MINUS %始端~offset ) ~MUL %j ~DIV %n
</li>
			<li>
( %始端~index, %始端~offset ) ~SET ( %~index, %~offset )
</li>
		</ol>

◎
For each pair of keyframes A and B where:
• A appears before B in keyframes, and
• A and B have a computed keyframe offset that is not null, and
• all keyframes between A and B have a null computed keyframe offset,
◎
calculate the computed keyframe offset of each keyframe between A and B as follows:
• Let offsetk be the computed keyframe offset of a keyframe k.
• Let n be the number of keyframes between and including A and B minus 1.
• Let index refer to the position of keyframe in the sequence of keyframes between A and B such that the first keyframe after A has an index of 1.
• Set the computed keyframe offset of keyframe to offsetA + (offsetB − offsetA) × index / n.
</li>
	<li>
~EACH( 整数 %~index ~IN { 0 〜 %終端~index } ) に対し
⇒
%~keyframe~list[ %~index ] の`算出d~keyframe~offset$ ~SET %~offset~list[ %~index ]
◎
↑</li>
</ol>

<p class="algo-head">
`算出d~keyframe~list$は、所与の
( `~keyframe効果$ %効果 )
に対し，次の手続きを利用して生産される：
◎
Computed keyframes are produced using the following procedure.＼
</p>

<ol>
	<li>
%要素 ~LET %効果 の`~target要素$
◎
↓</li>
	<li>
~Assert：
以下は、 %要素 上で算出d値を計算できる~propに限り，遂行される
◎
Note that this procedure is only performed on a keyframe effect having a target element for which computed property values can be calculated.
</li>
	<li>
%算出d~keyframe~list ~LET 空~list
◎
Let computed keyframes be an empty list of keyframes.
</li>
	<li>
<p>
%効果 上に指定された`~keyframe$たちが成す~list内の~EACH( %~keyframe ) に対し：
◎
For each keyframe in the list of keyframes specified on this keyframe effect, perform the following steps:
</p>
		<ol>
			<li>
%算出d~keyframe ~LET 新たな空`~keyframe$
◎
↓</li>
			<li>
%算出d~keyframe~list に %算出d~keyframe を追加する
◎
Add a new empty keyframe, computed keyframe, to computed keyframes.
</li>
			<li>
<p>
%~keyframe 内に指定された~EACH( %~prop ) に対し
⇒
%算出d~keyframe に［
%~prop と, 次に与える それ用の値
］を追加する
⇒
%要素 を値を算出するための文脈に利用する下で， %~prop の算出d値を計算した結果
◎
For each property specified in keyframe, calculate the computed value specified on keyframe using the target element as the context for computing values and add the corresponding property and computed value to computed keyframe.＼
</p>

<p>
%~prop が略式~propである場合、この段は，対応する等価な下位propたちに対し遂行するとする。
◎
For shorthand properties, add the equivalent longhand properties.＼
</p>

<p>
%~prop が論理~prop `CSS-LOGICAL-1$r である場合、%要素 上の［
`writing-mode$p ／ `direction$p
］の算出d値に基づいて， %~prop に
<a href="~CSSWM#logical-to-physical">等価な物理~prop</a>
`CSS-WRITING-MODES-4$r
を追加するとする。
◎
For logical properties [CSS-LOGICAL-1], add the equivalent physical properties [CSS-WRITING-MODES-4] based on the computed value of writing-mode and/or direction for target element.
</p>

<p class="example">
例えば %~keyframe が
`border-width$p ~prop用の算出d値 `12pt^v を有する場合、~UAは，各~下位prop 
— 
`border-bottom-width$p,
`border-left-width$p,
`border-right-width$p,
`border-top-width$p —
用の算出d値 `16px^v を生産する結果、
%算出d~keyframe に追加されるのは，
`border-width$p ~propとその値に代えて，これらの各
( 下位prop, その算出d値 `16px^v )
になる。
◎
For example, if keyframe has a value of ‘12pt’ for the border-width property, the user agent may produce a computed value of ‘16px’ for each of the longhand properties: border-bottom-width, border-left-width, border-right-width, and border-top-width. As a result, computed keyframe would not have a value for the border-width property, but would instead include each of the longhand properties, and each with the computed value, ‘16px’.
</p>

<p>
［
略式~propを展開した ／
論理~propを物理~propに置換した
］ことにより，競合が発生する場合、次の規則を，競合が解決されるまで順に適用する：
◎
If conflicts arise when expanding shorthand properties or replacing logical properties with physical propertiess, apply the following rules in order until the conflict is resolved:
</p>

				<ol>
					<li>
下位propは略式~propを上書きする
（例： `border-top-color$p は `border-top$p を上書きする）。
◎
Longhand properties override shorthand properties (e.g. border-top-color overrides border-top).
</li>
					<li>
下位propの個数がより少ない略式~propは、より多いものを上書きする
（例： `border-top$p は `border-color$p を上書きする）。
◎
Shorthand properties with fewer longhand components override those with more longhand components (e.g. border-top overrides border-color).
</li>
					<li>
下位propの個数が互いに等しい略式~propどうしは、［
`~CSS~propから~IDL属性を得る$ ~algo `CSSOM$r
により~propから得られる~IDL名
］を比較して，~Unicode符号位置に基づく辞書式順序で先に~sortされるものが後に~sortされるものを上書きする。
◎
For shorthand properties with an equal number of longhand components, properties whose IDL name (see the CSS property to IDL attribute algorithm [CSSOM]) appears earlier when sorted in ascending order by the Unicode codepoints that make up each IDL name, override those who appear later.
</li>
					<li>
物理~propは論理~propを上書きする。
◎
Physical properties override logical properties.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`欠落~keyframe~offsetを算出する$( %算出d~keyframe~list )
◎
Apply the procedure to compute missing keyframe offsets to computed keyframes.
</li>
	<li>
~RET %算出d~keyframe~list
◎
Return computed keyframes.
</li>
</ol>

			</section>
			<section id="the-effect-value-of-a-keyframe-animation-effect">
<h4 title="The effect value of a keyframe effect">5.4.3. ~keyframe効果の効果~値</h4>

<p>
`~keyframe効果$ %効果 の各`~target~prop$ %~prop 用の`効果~値$は、次に従って計算される：
◎
The effect value of a single property referenced by a keyframe effect as one of its target properties, for a given iteration progress, current iteration and underlying value is calculated as follows.
</p>

<ol>
	<li>
( %反復~進捗, %現-反復, %下層~値 ) ~LET 
%効果 の
( `反復~進捗$, `現-反復$, `下層~値$ )
◎
↑</li>
	<li>
~IF［
%反復~進捗 ~EQ `未解決$
］
⇒
~RET ε
◎
If iteration progress is unresolved abort this procedure.
◎
↑Let target property be the longhand property for which the effect value is to be calculated.
</li>
	<li>
~IF［
%~prop の`~animation型$は`~animate不可$
］
⇒
~RET ε
— 効果は適用できない。
◎
If animation type of the target property is not animatable abort this procedure since the effect cannot be applied.
</li>
	<li>
以下に現れる
`組成~用の中立~値@
とは、［
`加算-型$の組成-演算を利用して`下層~値$と結合した結果は，単にその`下層~値$になる
］ような，特別な値とする
◎
Define the neutral value for composition as a value which, when combined with an underlying value using the add composite operation, produces the underlying value.
</li>
	<li>
%~keyframe~list ~LET `算出d~keyframe~list$( %効果 )
◎
Let property-specific keyframes be the result of getting the set of computed keyframes for this keyframe effect.
</li>
	<li>
%~keyframe~list から［
%~prop 用の値が無い`~keyframe$
］をすべて除去する
◎
Remove any keyframes from property-specific keyframes that do not have a property value for target property.
</li>
	<li>
~IF［
%~keyframe~list は空である
］
⇒
~RET %下層~値
◎
If property-specific keyframes is empty, return underlying value.
</li>
	<li>
~IF［
%~keyframe~list 内のどの`~keyframe$の`算出d~keyframe~offset$も 0 でない
］
⇒
%~keyframe~list に次のようにされた新たな`~keyframe$を前付加する
⇒＃
`算出d~keyframe~offset$ ~SET 0,
~prop値 ~SET `組成~用の中立~値$,
`組成-演算~型$ ~SET `加算-型$
◎
If there is no keyframe in property-specific keyframes with a computed keyframe offset of 0, create a new keyframe with a computed keyframe offset of 0, a property value set to the neutral value for composition, and a composite operation of add, and prepend it to the beginning of property-specific keyframes.
</li>
	<li>
~IF［
%~keyframe~list 内のどの`~keyframe$の`算出d~keyframe~offset$も 1 でない
］
⇒
%~keyframe~list に次のようにされた新たな`~keyframe$を付加する
⇒＃
`算出d~keyframe~offset$ ~SET 1,
~prop値 ~SET `組成~用の中立~値$,
`組成-演算~型$ ~SET `加算-型$
◎
Similarly, if there is no keyframe in property-specific keyframes with a computed keyframe offset of 1, create a new keyframe with a computed keyframe offset of 1, a property value set to the neutral value for composition, and a composite operation of add, and append it to the end of property-specific keyframes.
</li>
	<li>
( %始端~keyframe, %終端~keyframe ) ~LET ( ε, ε )
◎
Let interval endpoints be an empty sequence of keyframes.
◎
Populate interval endpoints by following the steps from the first matching condition from below:
</li>
	<li>
~IF［
%反復~進捗 ~LT 0
］~AND［
%~keyframe~list 内に［
`算出d~keyframe~offset$ ~EQ 0
］を満たす`~keyframe$が複数ある
］
⇒
%始端~keyframe ~SET %~keyframe~list 内の最初の`~keyframe$
◎
If iteration progress &lt; 0 and there is more than one keyframe in property-specific keyframes with a computed keyframe offset of 0,
• Add the first keyframe in property-specific keyframes to interval endpoints.
</li>
	<li>
~ELIF［
%反復~進捗 ~GTE 1
］~AND［
%~keyframe~list 内に［
`算出d~keyframe~offset$ ~EQ 1
］を満たす`~keyframe$が複数ある
］
⇒
%始端~keyframe ~SET %~keyframe~list 内の最後の`~keyframe$
◎
If iteration progress ≥ 1 and there is more than one keyframe in property-specific keyframes with a computed keyframe offset of 1,
• Add the last keyframe in property-specific keyframes to interval endpoints.
</li>
	<li>
<p>
~ELSE
⇒
( %始端~keyframe, %終端~keyframe ) ~SET ［
%~keyframe~list 内の`~keyframe$のうち，次に該当するもの, および その直後に在るもの
］
⇒
その`算出d~keyframe~offset$ %~offset が［
次の条件 (1) を満たすものがあれば それらのうち最後のもの ／
~ELSE_ 次の条件 (2) を満たすもののうち最後のもの
］
⇒＃
(1)［ %~offset ~LTE %反復~進捗 ］~AND［ %~offset ~LT 1 ］ ／
(2) %~offset ~EQ 0
</p>

【 %~keyframe~list の先頭には %~offset ~EQ 0 のもの, 末尾には ~EQ 1 のものが必ず在るので、該当する 2 つの~keyframeは常に在る。】

◎
Otherwise,
• Append to interval endpoints the last keyframe in property-specific keyframes whose computed keyframe offset is less than or equal to iteration progress and less than 1. If there is no such keyframe (because, for example, the iteration progress is negative), add the last keyframe whose computed keyframe offset is 0.
• Append to interval endpoints the next keyframe in property-specific keyframes after the one added in the previous step.
</li>
	<li>
%~animation型 ~LET %~prop の`~animation型$
◎
↓</li>
	<li>
<p>
%始端~値 ~LET 次に与える下位手続きを %始端~keyframe に適用した結果
— 下位手続きは、所与の %~keyframe に対し，次を走らす：
◎
For each keyframe in interval endpoints:
</p>
		<ol>
			<li>
%利用する組成-演算~型 ~LET %~keyframe の`~keyframeに特有の組成-演算~型$は［
~NULL でないならば それ ／
~ELSE_ %効果 の`組成-演算~型$
］
◎
↓</li>
			<li>
%値 ~LET %~keyframe 上に指定された %~prop の値
◎
↓</li>
			<li>
~IF［
%利用する組成-演算~型 ~NEQ `置換-型$
］
⇒
%値 ~SET ［
%~animation型 にて %利用する組成-演算~型 用に定義される手続き
］を利用して，次を結合した結果
⇒
( %下層~値, %値 )
◎
If keyframe has a composite operation that is not replace, or keyframe has no composite operation and the composite operation of this keyframe effect is not replace, then perform the following steps:
• Let composite operation to use be the composite operation of keyframe, or if it has none, the composite operation of this keyframe effect.
• Let value to combine be the property value of target property specified on keyframe.
• Replace the property value of target property on keyframe with the result of combining underlying value (Va) and value to combine (Vb) using the composite operation to use procedure defined by the target property’s animation type.
</li>
			<li>
<p>
~IF［
%効果 の`反復~組成-演算~型$ ~EQ `累積-反復~型$
］
⇒
次を %現-反復 回数だけ適用する
⇒
%値 ~SET %~animation型 に定義された`累積$手続きを利用して，次を結合した結果
⇒
( %~keyframe~list 内の最後の~keyframe上の %~prop の値, %値 )
◎
If this keyframe effect has an iteration composite operation of accumulate, apply the following step current iteration times:
• replace the property value of target property on keyframe with the result of combining the property value on the final keyframe in property-specific keyframes (Va) with the property value on keyframe (Vb) using the accumulation procedure defined for target property.
</p>

<p class="note">注記：
ここでの引数の順序は、重要になる。
%~animation型 が累積や加算~用の手続きを定義しない場合の既定の手続きは，
2 個目の引数を返すものと定義される。
累積を~supportしない~prop上で反復~組成を遂行した結果は
%~keyframe 上の初期~時の %~prop の値になるべきである。
よって、上の段において これを 2 個目の引数に渡す。
◎
Note: The order of arguments here is important. In the case where the animation type of the target property does not define a procedure for accumulation or addition, the default definition for these procedures result in Vb being returned. When performing iteration composition on propreties that do not support accumulation, the result should be the initial property value of target property on keyframe, hence we we make this Vb in the above step.
</p>
			</li>
			<li>
~RET %値
◎
↑</li>
		</ol>
	</li>
	<li>
~IF［
%終端~keyframe ~NEQ ε
］
⇒
%終端~値 ~LET 前~段の下位手続きを %終端~keyframe に適用した結果
◎
↑</li>
	<li>
~ELSE
⇒
~RET %始端~値
◎
If there is only one keyframe in interval endpoints return the property value of target property on that keyframe.
</li>
	<li>
%始端~offset ~LET %始端~keyframe の`算出d~keyframe~offset$
◎
Let start offset be the computed keyframe offset of the first keyframe in interval endpoints.
</li>
	<li>
%終端~offset ~LET %終端~keyframe の`算出d~keyframe~offset$
◎
Let end offset be the computed keyframe offset of last keyframe in interval endpoints.
</li>
	<li>
%区間~距離 ~LET ( %反復~進捗 ~MINUS %始端~offset ) ~DIV ( %終端~offset ~MINUS %始端~offset )
◎
Let interval distance be the result of evaluating (iteration progress - start offset) / (end offset - start offset).
</li>
	<li>
%変形d距離 ~LET %始端~keyframe に結付けられている`計時~関数$を［
入力~進捗として %区間~距離
］を渡して評価した結果
◎
Let transformed distance be the result of evaluating the timing function associated with the first keyframe in interval endpoints passing interval distance as the input progress.
</li>
	<li>
~RET 次を与える下で，%~animation型 により定義される`補間$手続きを適用した結果
⇒＃
( %V/start, %V/end ) ~SET ( %始端~値, %終端~値 ),
補間~parameter %p ~SET %変形d距離
◎
Return the result of applying the interpolation procedure defined by the animation type of the target property, to the values of the target property specified on the two keyframes in interval endpoints taking the first such value as Vstart and the second as Vend and using transformed distance as the interpolation parameter p.
</li>
</ol>

<div class="note">

<p>注記：
この手続きは、当の効果~上に指定された`~keyframe$たちが成す~listが，次を満たしているものと見做すことに注意：
◎
Note that this procedure assumes the following about the list of keyframes specified on the effect:
</p>

<ul>
	<li>
各`~keyframe$に指定された`算出d~keyframe~offset$は範囲 [0, 1] 内に入る
◎
Each keyframe has a specified computed keyframe offset in the range [0, 1].
</li>
	<li>
~list内の`~keyframe$たちは`算出d~keyframe~offset$の昇順に~sortされている。
◎
The list of keyframes is sorted in ascending order by computed keyframe offset.
</li>
	<li>
各~keyframe上に指定されている~prop値は、~propごとに 1 個までである。
◎
For a given property, there is at most one specified property value on each keyframe.
</li>
</ul>

<p>
これらの条件が満たされることを確保することは、~modelを利用する側（例えば，宣言的~markup／ ~API）の責務である。
◎
It is the responsibility of the user of the model (for example, a declarative markup or programming interface) to ensure these conditions are met.
</p>

<p>
例えば，この仕様により定義される`~API$sec用には、これらの条件は，この手続きへの入力になる`算出d~keyframe~list$を生産する手続きにより満たされる。
◎
For example, for the programming interface defined by this specification, these conditions are met by the procedure to produce the computed keyframes that become the input to this procedure.
</p>

</div>

<p class="note">注記：
この手続きは、`~keyframe$どうしが重合することを許可する。
重合する地点における挙動は、出力~値は
その~offsetにて最後に定義された`~keyframe$の値へ~jumpする。
［
0 ／ 1
］にて重合している~keyframe用の［
0 未満 ／ 1 以上
］の`反復~進捗$値~用の出力~値は、 %~keyframe~list 内の［
最初の ／ 最後の
］`~keyframe$の値になる。
◎
Note: this procedure permits overlapping keyframes. The behavior is that at the point of overlap the output value jumps to the value of the last defined keyframe at that offset. For overlapping keyframes at 0 or 1, the output value for iteration progress values less than 0 or greater than or equal to 1 is the value of the first keyframe or the last keyframe in keyframes respectively.
</p>

<div class="issue">

<p>
ある種の計時~関数が在る下では、~animation効果への入力~反復~進捗は，範囲 [0, 1] 内に制限されない。
しかしながら，現時点では、~keyframe~offsetはこの範囲~内に制限され，この範囲の外側にある入力~反復~進捗~値~用の~prop値は 単純に外挿される。
◎
In the presence of certain timing functions, the input iteration progress to an animation effect is not limited to the range [0, 1]. Currently, however, keyframe offsets are limited to the range [0, 1] and property values are simply extrapolated for input iteration progress values outside this range.
</p>

<p>
［
~prop値における範囲 [0, 1] の外側の反復~進捗~値に線形でない変化を指定-可能になる
］のが有用になるような事例も存在するので、この制約を除去することも考えた。
例として、緑色から黄色へ補間するが，一時的に黄色を “通り越して” 赤色へ補間されるよう，計時~関数を外へ振り切らせる~animationが挙げられる。
◎
We have considered removing this restriction since some cases exist where it is useful to be able to specify non-linear changes in property values at iteration progress values outside the range [0, 1]. One example is an animation that interpolates from green to yellow but has an overshoot timing function that makes it temporarily interpolate ‘beyond’ yellow to red before settling back to yellow.
</p>

<p>
この効果は~keyframeと計時~関数を改変して達成することもできるが、そのような~approachは，~modelにおける計時への~~関心を~animation効果から分離する~~原則を壊すように見受けられる。
◎
While this effect could be achieved by modification of the keyframes and timing function, this approach seems to break the model’s separation of timing concerns from animation effects.
</p>

<p>
この効果が どう達成されるべきかは明瞭でないが、
[0, 1] の外側にも~keyframe~offsetを許容すると、現在~指定されている［
必要に応じて，~offset 0 ／ 1 にある~keyframeを合成する挙動
］と整合しなくなることに注意。
◎
It is not clear how this effect should be achieved but we note that allowing keyframe offsets outside [0, 1] may make the currently specified behavior where keyframes at offset 0 and 1 are synthesized as necessary, inconsistent.
</p>

<p>
<a href="http://lists.w3.org/Archives/Public/public-fx/2013AprJun/0184.html">section 4 (Keyframe offsets outside [0, 1]) of minuted discussion from Tokyo 2013 F2F</a>,
`2081$issue
を見よ。
◎
See section 4 (Keyframe offsets outside [0, 1]) of minuted discussion from Tokyo 2013 F2F.
◎
&lt;https://github.com/w3c/csswg-drafts/issues/2081&gt;
</p>

</div>

			</section>
		</section>
		<section id="combining-effects">
<h3 title="Combining effects">5.5. 効果の結合-法</h3>

~INFORMATIVE

<div class="informative">

<p>
`~keyframe効果$用の`効果~値$を計算した結果は、`~animation効果$の`~target~prop$に適用される。
◎
After calculating the effect values for a keyframe effect, they are applied to the animation effect’s target properties.
</p>

<p>
`効果~中$iにある複数の`~keyframe効果$は、同じ~propを~targetにする可能性もあるので，それらの結果を一緒に結合することが必要とされることは多い。
この処理-は
`組成@
（ `composition^en ）と呼ばれ、`効果~中$iにある`~animation効果$の~targetにされている各~propごとに，`効果~stack$を確立することに基づく。
◎
Since it is possible for multiple in effect keyframe effects to target the same property it is often necessary to combine the results of several keyframe effects together. This process is called compositing and is based on establishing an effect stack for each property targeted by an in effect animation effect.
</p>

<p>
いくつかの`~keyframe効果$の結果を一緒に組成した結果は、`~target~prop$用に指定された他の値と結合される。
◎
After compositing the results of keyframe effects together, the composited result is combined with other values specified for the target property.
</p>

<p>
`効果~stack$が，【既定の場合において】
~cascadeにおいて どの`~level$に属するかを下に図示する： 
◎
the arrangement is illustrated below:
</p>

<figure>
<div id="_origin-boxes">
<div>遷移~level（ Transition ）
</div><div>~UA~level ~important
</div><div>利用者~level ~important
<!-- 上書き -->
</div><div>作者~level ~important
</div><div style="position:relative; margin:0.5em 0;">
~animation~level

<div style="display:inline-block; position:absolute; right: -2em; width: 0;">
<div style="position: absolute; left:-1.5em; top:0;">←</div>
<div style="position: absolute; left:0; top:0;">効果~stack</div>
<div style="position: absolute; width:auto; left:0; top:1.5em; text-align: center; border:dashed gray 1px;">
<div>効果~値（`組成-順序$は最後）
</div><div>⁝
</div><div>効果~値（`組成-順序$は最初）
</div>
</div></div>

<!-- 上書き -->
</div><div>作者~level
</div><div>利用者~level
</div><div>~UA~level
</div>
</div>

<!-- animation-cascade^dgm -->

<figcaption>
`効果~値$の`~target~prop$への適用の概観：
同じ~propを~targetしている`~keyframe効果$の結果は、`効果~stack$を利用して一緒に組成され、その結果は，~CSS~cascadeの中の適切な箇所に挿入される。
【原文の図には “上書き~level” もあるが、<a href="~CSSissue/1385">廃用にされた</a>（実装されたこともない）ので，省略している。】
◎
Overview of the application of effect values to their target properties. The results of keyframe effects targeting the same property are composited together using an effect stack. The result of this composition is then inserted into the CSS cascade at an appropriate point.
</figcaption></figure>

<p>
この演算を成す最初の部分は，同じ`~target~prop$を~targetにしている`効果~値$を結合するが、そのためには，次の 2 つを決定することが必要とされる：
◎
For the first part of this operation—combining effect values that target the same property— it is necessary to determine both how keyframe effects are combined with one another, as well as the order in which they are applied, that is, their relative composite order.
</p>

<ul>
	<li>
2 つの`効果~値$をどう結合するか
— これは、当の`~keyframe効果$の`組成-演算~型$により統治される。
◎
The matter of how effect values are combined is governed by the composite operation of the corresponding keyframe effects.
</li>
	<li>
`組成-順序$と呼ばれる，一連の`効果~値$を適用する順序
— これは、~animateされる各~prop用に確立される`効果~stack$により決定される。
◎
The relative composite order of effect values is determined by an effect stack established for each animated property.
</li>
</ul>

</div>

			<section id="animation-classes">
<h4 title="Animation classes">5.5.1. 各種~animation~class</h4>

<p>
この仕様は、共通する~animation~modelを供する
— それは、この~modelの上~層に［
~markup／~API
］を定義する，他の仕様により利用されることが意図される。
~animationの
`~animation~class@
は、当の`~animation$を生成した特定0の［
~markup／~API
］が定義する。
【~animation~classとして何があり得るかは、この仕様には定義されていない。】
◎
This specification provides a common animation model intended to be used by other specifications that define markup or programming interfaces on top of this model. The particular markup or programming interface that generated an animation defines its animation class.
</p>

<p>
~~後続の仕様は、［
異なる~animation~class間の／特定0の~classの中での
］組成-順序~用に特化された挙動を定義して~MAY。
◎
Further specifications may define specialized behavior for composite ordering between different classes of animations or within a particular class.
</p>

<div class="note">
<p>参考：
例えば，`~animation~class$ `~CSS~animation^i に属する~animationは、`組成-順序$において［
~animation~class `~CSS遷移^i に属する~animationより後になり,
特定の~classに属さない~animationより前になる
］ものと定義される。
<!-- higher/lower -->
◎
This section is non-normative.
◎
For example, animations whose class is ‘CSS animation’ are defined as having a higher composite order than animations whose class is ‘CSS transition’ but lower than other animations without a specific class.
</p>

<p>
`~CSS~animation^i ~classに属する~objどうしに特化された組成-順序は、他の要因の中でも特に `animation-name$p ~propに基づいて定義される。
◎
Within the set of ‘CSS animation’ objects, specialized composite ordering is defined based on the animation-name property amongst other factors.
</p>

</div>

			</section>
			<section id="the-effect-stack">
<h4 title="The effect stack">5.5.2. 効果~stack</h4>

<p>
各~propには、それを`~target~prop$にしている`~keyframe効果$が 1 つ以上あるならば，それらからなる
`効果~stack@
が結付けられ、その中での互いの`~keyframe効果$の`組成-順序$を確立する。
◎
Associated with each property targeted by one or more keyframe effects is an effect stack that establishes the relative composite order of the keyframe effects.
</p>

<p>
~propの`効果~stack$ %~stack における
`組成-順序@
は、 %~stack 内の`~keyframe効果$ %A, %B を次に従って比較することにより確立される：
◎
The relative composite order of any two keyframe effects, A and B, within an effect stack is established by comparing their properties as follows:
</p>

<ol>
	<li>
<p>
%A, %B それぞれを`~targetにしている~animation$†が属する`~animation~class$は相違するならば、それらの~class間に定義される組成-順序に従う。
</p>

<p class="trans-note">【†
そのような~animationは，（`効果~stack$を成す各）`~animation効果$に
`結付けられている~animation@
と，原文には定義されているが、実質的に言い換えに過ぎないので，この訳では利用しない
— 単に，`~targetにしている~animation$を用いて記すことにする。
】</p>
◎
Let the associated animation of an animation effect be the animation associated with the animation effect that affecting the property with which this effect stack is associated.
◎
Sort A and B by applying the following conditions in turn until the order is resolved,
◎
If A and B’s associated animations differ by class, sort by any inter-class composite order defined for the corresponding classes.
</li>
	<li>
~ELSE_
%A, %B に共通の`~animation~class$に特有の組成-順序が定義されていて，
%A, %B を順序付けれるならば、それに従う。
◎
If A and B are still not sorted, sort by any class-specific composite order defined by the common class of A and B’s associated animations.
</li>
	<li>
~ELSE_
`大域~animation~list$における %A, %B の順序に従う。
◎
If A and B are still not sorted, sort by their corresponding position in the global animation list.
</li>
</ol>

<p>
`~animation効果$は、組成-順序において［
先に現れるものほど “低い” ／
後に現れるものほど “高い”
］とされる。
◎
Animation effects that sort earlier have lower composite order.
</p>

<p class="trans-note">【
すなわち，この “順序（ `order^en ）” は、英語としては “~~序列（~~優先順位）” も意味する。
しかしながら，この訳では，これらの句（ `lower^en, `higher^en ）は利用せず，単に順序を表す通常の句
— “〜より前”, “最後”, 等々 —
で表すことにする。
】</p>

			</section>
			<section id="calculating-the-result-of-an-effect-stack">
<h4 title="Calculating the result of an effect stack">5.5.3. 効果~stackの結果の計算-法</h4>

<p>
`効果~stack$ %~stack の結果を与える
`組成d値@
は、所与の
( 初期`下層~値$ %下層~値 )
から，次に従って計算される：
◎
In order to calculate the final value of an effect stack, the effect values of each keyframe effect in the stack are combined in composite order.
</p>

<ol>
	<li>
<p>
%~stack 内の~EACH( `~keyframe効果$ %効果 ) に対し，`組成-順序$で
⇒
%下層~値 ~SET `効果の組成$secに従って，
( %下層~値, %効果 の`効果~値$ ) を結合した結果
</p>

<p>
この段の各~反復における［
%効果 を結合する前の %下層~値
］は、 %効果 の
`下層~値@
と呼ばれる。
</p>

◎
Each step in the process of evaluating an effect stack takes an underlying value as input.
◎
For each keyframe effect in the stack, the appropriate effect value from the keyframe effect is combined with the underlying value to produce a new value. This resulting value becomes the underlying value for combining the next keyframe effect in the stack.
</li>
	<li>
~RET %下層~値
◎
The final value of an effect stack, called the composited value, is simply the result of combining the effect value of the final (highest composite order) keyframe effect in the stack with the underlying value at that point.
</li>
</ol>


			</section>
			<section id="effect-composition">
<h4 title="Effect composition">5.5.4. 効果の組成</h4>

<p>
`効果~値$を`下層~値$と結合するときに利用される特定の演算は、`効果~値$を生産した`~keyframe効果$の
`組成-演算~型@
により決定される。
◎
The specific operation used to combine an effect value with an underlying value is determined by the composite operation of the keyframe effect that produced the effect value.
</p>

<p class="trans-note">【
接尾辞 “型” は、この訳による追加。これは分類であり、演算そのものではないので。
演算~自体は、実際には
( `組成-演算~型$, 利用される`~animation型$ ) 
の組により決定される（`置換-型$は別として）。
】</p>

<p>
この仕様は、次に挙げる 3 種の`組成-演算~型$を定義する：
◎
This specification defines three composite operations as follows:
</p>

<dl>
	<dt>
`置換-型@
◎
replace
</dt>
	<dd>
( `下層~値$, `効果~値$ )
を組成した結果は、単純に`効果~値$になる。
◎
The result of compositing the effect value with the underlying value is simply the effect value.
</dd>

	<dt>
`加算-型@
◎
add
</dt>
	<dd>
( `下層~値$, `効果~値$ )
を組成した結果は、これらを`加算-$した結果になる。
当の`~animation型$に定義されている`加算$演算は可換でない場合もあるので，これらの順序も有意になる。
◎
The effect value is added to the underlying value. For animation types where the addition operation is defined such that it is not commutative, the order of the operands is underlying value + effect value.
</dd>

	<dt>
`累積-型@
◎
accumulate
</dt>
	<dd>
( `下層~値$, `効果~値$ )
を組成した結果は、これらを`累積-$した結果になる。
`加算-型$と同様に，これらの順序も有意になる。
◎
The effect value is accumulated onto the underlying value. For animation types where the accumulation operation is defined such that it is not commutative, the order of the operands is underlying value followed by effect value.
</dd>
</dl>

			</section>
			<section id="applying-the-composited-result">
<h4 title="Applying the composited result">5.5.5. 組成された結果の適用-法</h4>

<p>
`組成d値$を`~target~prop$に適用することは、~CSS~cascadeに指定d値を追加することにより達成される。
◎
Applying a composited value to a target property is achieved by adding a specified value to the CSS cascade.
</p>

<p>
この指定d値の追加-先になる~cascadeの`~level$は、所与の~prop用の`効果~stack$内の［
`組成-順序$において最後の効果<!-- highest -->
］を`~targetにしている~animation$が属する`~animation~class$†に依存する。
既定では、指定d値の追加-先は，~cascadeの“~animation宣言” ~level `css-cascade-3$r とする。
◎
The level of the cascade to which this specified value is added depends on the class of the animation associated with the effect with the highest composite order in the effect stack for a given property. By default, the specified value is added to the ‘Animation declarations’ level of the cascade ([css-cascade-3]).
</p>

<p class="note">参考†：
例えば，その`~animation~class$が`~CSS遷移^i である場合、`組成d値$は，~cascadeの遷移~宣言~levelに追加されることになる。
◎
This section is non-normative.
◎
For example, if the effect with the highest composite order is associated with a ‘CSS transition’-class animation, the composited value will be added to ‘Transition declarations’ level of the cascade.
</p>

<p>
~CSS`~target~prop$ %~prop 用に計算された`組成d値$は、次に従って適用される：
◎
The composited value calculated for a CSS target property is applied using the following process.
</p>

<ol>
	<li>
%基底~値 ~SET ~animationが無かったとするときの， %~prop 用の算出d値
◎
Calculate the base value of the property as the value generated for that property by computing the computed value for that property in the absence of animations.
</li>
	<li>
%効果~stack ~LET
%~prop 用の`効果~stack$を確立した結果（ `効果~stack$secを見よ）
◎
Establish the effect stack for the property (see §5.5.2 The effect stack).
</li>
	<li>
%組成d値 ~LET
`効果~stackの結果の計算-法$secに従って， %効果~stack の`組成d値$を計算した結果
— 初期`下層~値$として %~prop の %基底~値 を渡して
◎
Calculate the composited value of the effect stack passing in the base value of the property as the initial underlying value (see §5.5.3 Calculating the result of an effect stack).
</li>
	<li>
%組成d値 を~CSS~cascadeの中の［
%効果~stack の最後の効果を`~targetにしている~animation$が属する`~animation~class$
］用に定義された`~level$へ挿入する
◎
Insert the composited value into the CSS cascade at the level defined for the class of the animation associated with the effect at the top of the effect stack established for the target property.
</li>
</ol>

			</section>
		</section>
		<section id="effect-accumulation-section">
<h3 title="Effect accumulation">5.6. 効果の累積</h3>

<p>
一連の`効果~値$に対し遂行される組成-法（`効果の組成$secを見よ）と似た様に、
`反復~組成-演算~型@
は，同じ`~keyframe効果$を成す各~反復~間で値が結合される方法を決定する。
◎
Similar to the compositing performed between effect values (see §5.5.4 Effect composition), the iteration composite operation determines how values are combined between successive iterations of the same keyframe effect.
</p>

<p>
この仕様は、 2 種の`反復~組成-演算~型$を定義する：
◎
This specification defines two iteration composite operations as follows:
</p>

<dl>
	<dt>
`置換-反復~型@
◎
replace
</dt>
	<dd>
各~反復は、前回までの反復に依存することなく計算される。
◎
Each successive iteration is calculated independently of previous iterations.
</dd>

	<dt>
`累積-反復~型@
◎
accumulate
</dt>
	<dd>
~animationの各~反復は、前回の反復による結果に`累積-$される。
◎
Successive iterations of the animation are accumulated with the final value of the previous iteration.
</dd>
	<dd>
この`反復~組成-演算~型$の適用は、`~keyframe効果の効果~値$secによる`効果~値$の計算に組入れられる。
◎
The application of the iteration composite operation is incorporated in the calculation of the effect value in §5.4.3 The effect value of a keyframe effect.
</dd>
</dl>


		</section>
		<section id="side-effects-section">
<h3 title="Side effects of animation">5.7. ~animationの副作用</h3>

<p>
1 つ以上の`~animation効果$により~targetされている どの~propに対しても、効果が［
<!-- ＊現在の@ -->
`事前~相$iにある, または［
`再生-中$i／`効果~中$i
］にある
］間は、~UAは`~target要素$上の
`will-change$p ~prop `css-will-change-1$r
が その~propを含んでいたかのように動作し~MUST。
◎
For every property targeted by at least one animation effect that is current or in effect, the user agent must act as if the will-change property ([css-will-change-1]) on the target element includes the property.
</p>

<p class="note">参考：
上の要件の結果として、例えば，ある`~animation$が ある要素の `transform$p ~propを~targetしている場合、その`~animation効果$が［
`事前~相$i／`作動~相$i
］にあるか，または［
`延伸~mode$ ~IN { `前方^i, `両方^i }, かつ`事後~相$iにある
］間は，`~target要素$用に`積層~文脈$が作成されることになる。
◎
This section is non-normative.
◎
As a result of the above requirement, if an animation targets, for example, the transform property of an element, a stacking context will be created for the target element so long as the animation is in the before phase, the active phase or, if it has a fill mode of ‘forwards’ or ‘both’, the after phase.
</p>

		</section>
	</section>
	<section id="programming-interface">
<h2 title="Programming interface">6. ~API</h2>

【この節の内容は、<a href="~WANIMAPI">別ページにて</a>。概要のみ，ここに示す：】

<p class="note">参考：
上で述べた抽象~modelに加えて，この仕様は、~modelに対する~APIも定義する。
この~interfaceは、次のために利用できる
⇒＃
宣言的~手段により生産された~animationを拡張したり, 検分する ／
手続き的~approachの方が相応しいときに，~animationを直に生産する
◎
In addition to the abstract model described above, Web Animations also defines a programming interface to the model. This interface can be used to inspect and extend animations produced by declarative means or for directly producing animations when a procedural approach is more suitable.
</p>

	</section>
	<section id="integration-with-media-fragments">
<h2 title="Integration with Media Fragments">7. 媒体~素片との統合</h2>

<p>
`MEDIA-FRAGS$r 仕様は、媒体~資源の時制~範囲を~addressするための手段を定義する。
媒体~素片の適用は、それを指定した資源の~MIME型に依存する。
<a href="~SVG2#mime-registration">~SVG~MIME型</a>
`SVG11$r
の資源~用の時制~parameterの適用は、
<a href="https://svgwg.org/specs/animation-elements/">Animation Elements</a>
仕様にて定義される。
◎
The Media Fragments specification [MEDIA-FRAGS] defines a means for addressing a temporal range of a media resource. The application of media fragments depends on the MIME type of the resource on which they are specified. For resources with the SVG MIME type [SVG11], the application of temporal parameters is defined in the Animation Elements specification.
</p>

<p class="note">注記：
媒体~素片は、資源~上で，その~MIME型に基づいて演算するよう定義される。
そのため，時制~address法は、~WAnim内容が利用される どの状況でも~supportされるとは限らない。
◎
Note: media fragments are defined to operate on resources based on their MIME type. As a result, temporal addressing may not be supported in all situations where Web Animations content is used.
</p>

	</section>
	<section id="interaction-with-page-display">
<h2 title="Interaction with page display">8. ~page表示-との相互作用</h2>

<p>
~HTMLは、利用者が~page間を~navigateするに伴い，~pageの以前の状態
— ~scroll位置など —
も含めて復旧できるよう，［
~UAが，`~session履歴~entry$に
<a href="~HISTORY#an-entry-with-persisted-user-state">~UAにより定義される状態</a>
を伴わせて格納する
］ことを許可する。
`HTML$r
◎
HTML permits user agents to store user-agent defined state along with a session history entry so that as a user navigates between pages, the previous state of the page can be restored including state such as scroll position [HTML].
</p>

<p>
参照-元~の文書が~unloadされ, 走査されるとき，`~media要素$を静止して再開する~UAには、~WAnim内容を包含している文書に対し，一貫する取扱いを適用することが奨励される。
この挙動を供する場合、それは［
現実の時計の時刻を追跡する`時列線$
］の`時刻~値$を調整することにより達成される~SHOULDである。
◎
User agents that pause and resume media elements when the referencing document is unloaded and traversed, are encouraged to apply consistent handling to documents containing Web Animations content. If provided, this behavior SHOULD be achieved by adjusting the time values of any timelines that track wallclock time.
</p>


<p class="issue">
これは［
`navigationStart$m に相対的な`時刻~値$や,
`document.timeline.currentTime^m と同じ時刻を利用している `requestAnimationFrame()$m
］と食い違わないか？
`2083$issue
◎
Is this at odds with those time values being relative to navigationStart and with requestAnimationFrame using the same time as document.timeline.currentTime? &lt;https://github.com/w3c/csswg-drafts/issues/2083&gt;
</p>

	</section>
	<section id="implementation-requirements">
<h2 title="Implementation requirements">9. 実装の要件</h2>

		<section id="precision-of-time-values">
<h3 title="Precision of time values">9.1. 時刻~値の精度</h3>

<p>
時刻~値の内部~表現は、実装に依存する。
しかしながら，~UAには、（名目上は~milli-秒を表現する）`時刻~値$ 0.001 と 0.0 とが判別-可能になるよう，入力~時刻~値を~micro-秒の精度で表現-可能にすることが推奨される。
◎
The internal representation of time values is implementation dependent however, it is RECOMMENDED that user agents be able to represent input time values with microsecond precision so that a time value (which nominally represents milliseconds) of 0.001 is distinguishable from 0.0.
</p>
		</section>
		<section id="conformance-criteria">
<h3 title="Conformance criteria">9.2. 適合性の判定基準</h3>

<p>
この仕様は，~animation用の抽象~modelを定義するものなので、~scriptingを~supportしない~UAに対しては，適合性~判定基準は無い
— 外から試験-可能な面が無いので。
◎
This specification defines an abstract model for animation and, as such, for user agents that do not support scripting, there are no conformance criteria since there is no testable surface area.
</p>

<p>
しかしながら，~scriptingを~supportしない~UAは、この仕様の用語に基づいて定義される追加の技術を実装して~MAY。
その事例では、この仕様が供する定義が，そのような技術に対する適合性の判定基準の一部を形成することになる。
◎
User agents that do not support scripting, however, may implement additional technologies defined in terms of this specification in which case the definitions provided in this specification will form part of the conformance criteria of the additional technology.
</p>

<p>
`適合している~script化~WAnim~UA@
は、`~API$secにて定義される~APIを実装する~UAである。
◎
A conforming scripted Web Animations user agent is a user agent that implements the API defined in §6 Programming interface.
</p>



		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">10. 謝辞</h2>


<p>
この仕様に協力された次の方々に：
</p>

<p lang="en-x-a0">
Thank you to
Steve Block, Michael Giuffrida, Ryan Seys, and Eric Willigers
for their contributions to this specification.
</p>

<p>
滑らかな計時~関数~用の等式の提案-に助力された
`Michiel “Pomax” Kamermans^en
氏に
— その特色機能は、後継~仕様へ先送りされたが。
◎
Thank you also to Michiel “Pomax” Kamermans for help with the equations for a proposed smooth timing function although this feature has been deferred to a subsequent specification.
</p>

<p>
放送~animationの制作-時に利用される処理-と技法を，編集者たちに気前よく懇切に手ほどきされた
<a href="http://www.endemolshine.com.au">Southern Star Animation</a>
に~~深く感謝する。
◎
Our deep gratitude goes out to Southern Star Animation for their kind generosity and patience in introducing the editors to the processes and techniques used producing broadcast animations.
</p>



	</section>
	<section id="changes-since-last-publication">
<h2 title="Changes since last publication">11. 最後の発行版からの変更点</h2>

<p>
<a href="https://www.w3.org/TR/2016/WD-web-animations-1-20160913/">2016 年 9 月 13 日の作業草案</a>
からの変更点は：
◎
The following changes have been made since the 13 September 2016 Working Draft:
</p>

<ul>
	<li>
大域~時計の定義を落とした上で，`~animationを更新して~eventを送信する$手続きを追加して、~animationの更新-法を，~HTMLの`描画を更新する$手続きに統合できるようにした。
◎
Dropped global clock definition and added the update animations and send events procedure so that the updating of animations can be integrated with HTML’s update the rendering procedure.
</li>
	<li>
【`~target効果を設定する$ときの】
~animation上に新たな効果として ~NULL が設定されるとき，処理待ち~taskを再設定する段を除去した。
（<a href="~CSSissue/2077">#2077</a>）
◎
Removed step to reset pending tasks when a null effect it set on an animation (#2077).
</li>
	<li>
`処理待ち再生-~task$,
`処理待ち静止-~task$
は、非同期的に走らせ~MUSTことを明確化した。
◎
Clarified that the pending play task and pending pause task must be run asynchronously.
</li>
	<li>
静止-演算の完了-時の`保持-時刻$の計算における誤りを修正した（`~animationの静止-法$secを見よ）。
◎
Fixed a mistake in the calculation of the hold time when an pause operation completes (see §4.4.11 Pausing an animation).
</li>
	<li>
~animationの`完遂d状態を更新する$手続きを方向が変化する時列線を適応するよう調整した。
◎
Adjusted the procedure to update an animation’s finished state to accommodate timelines that change direction.
</li>
	<li>
`~animation$の`再生~rate$の更新-用に，非同期的な`再生~rateを継目無く更新する$手続きを導入した。
◎
Introduced an asynchronous procedure for updating an animation's playback rate: seamlessly update the playback rate.
</li>
	<li>
`~animationを逆転する$手続きにおける~animationの再生-時の例外~投出-時の挙動を明確化した。
◎
Clarified behavior of the procedure to reverse an animation when playing the animation causes an exception to be thrown.
</li>
	<li>
“`pending^en” 再生-状態を除去した。
`Animation$I ~interfaceに `pending$m ~memberを加算した。
◎
Removed the “pending” play state and added the pending member to the Animation interface.
</li>
	<li>
一般`処理待ち~animation~event~queue$を導入した。
互いの型が異なる~animation~eventがどう~sortされるかを定義した。
◎
Introduced a general pending animation event queue and defined how different types of animation events are sorted.
</li>
	<li>
`遊休~相$i用の定義を加算した。
◎
Added a definition for the idle phase.
</li>
	<li>
`単純~反復~進捗$を計算する手続きにおいて、［
負の終端~遅延により，次回の反復の始まりに代えて最後の反復の終端を利用する挙動
］は，誘発されないようにした。
また、この挙動の適用が，逆方向に再生している間に失敗する~bugを修正した。
（ <a href="https://github.com/w3c/web-animations/issues/201">#201</a> ）。
◎
In the procedure to calculate the simple iteration progress, made a negative end delay not trigger the behavior where the end of the last iteration is used instead of the beginning of the next iteration. Also fixed a bug where this behavior would fail to apply when playing in reverse. (#201).
</li>
	<li>
~keyframeの間隔法, 距離~計算, 妥当でない~keyframe~prop値の~~維持を落とした。
◎
Dropped keyframe spacing, distance calculation, and retention of invalid keyframe property values.
</li>
	<li>
別の~thread等~上で稼働中の~animationと同期する現-時刻を保守する代わりに，
`updatePlaybackRate()$m を導入した。
◎
Introduced updatePlaybackRate(playbackRate) instead which maintains the current time and synchronizes with animations running on another thread or process.
</li>
	<li>
<p>
`…ReadOnly^I, および計時に関係する各種~interfaceを次のように改訂した：
◎
Revised the …ReadOnly and timing-related interfaces as follows:
</p>
		<ul>
			<li>
`AnimationEffectReadOnly^I を `AnimationEffect^I に置換した。
◎
Replaced AnimationEffectReadOnly with AnimationEffect.
</li>
			<li>
`AnimationEffectReadOnly^I の `timing^m ~memberを
`AnimationEffect^I の `getTiming()^m, `updateTiming()^m ~methodに置換した。
◎
Replaced the timing member of AnimationEffectReadOnly with the getTiming() and updateTiming() methods on AnimationEffect.
</li>
			<li>
`AnimationEffectTimingReadOnly^I, `AnimationEffectTiming^I
~interfaceを除去した。
◎
Removed the AnimationEffectTimingReadOnly and AnimationEffectTiming interfaces.
</li>
			<li>
`AnimationEffectTimingProperties^I 辞書を
`EffectTiming^I に改称した。
◎
Renamed the AnimationEffectTimingProperties dictionary to EffectTiming.
</li>
			<li>
`ComputedTimingProperties^I 辞書を
`ComputedEffectTiming^I に改称した。
◎
Renamed the ComputedTimingProperties dictionary to ComputedEffectTiming.
</li>
			<li>
`updateTiming()^m ~methodに利用する `OptionalEffectTiming^I 辞書を導入した。
◎
Introduced the OptionalEffectTiming dictionary for use with the updateTiming method.
</li>
			<li>
`KeyframeEffectReadOnly^I を除去した
— `KeyframeEffect^I は残して。
◎
Removed KeyframeEffectReadOnly, leaving only KeyframeEffect.
</li>
		</ul>
	</li>
	<li>
~keyframe~offsetを指定するために利用される属性~名との競合を避けるため、［
~APIから `cssOffset^m を利用して `offset$p ~propを~animateできる
］ようにする特別な取扱いを追加した。
◎
Added special handling to allow animating the offset property from the programming interface using cssOffset to avoid conflict with the attribute name used to specify keyframe offsets.
</li>
	<li>
`~keyframes引数を処理する$手続きにて
`offset^c, `composite^c, 複数の `easing^c 値
を指定できるように更新した
— `composite^c 用に ~NULL 値を許容することも含めて。
◎
Updated the procedure to process a keyframes argument to allow specifying offset, composite and multiple easing values including allowing null values for composite.
</li>
	<li>
［
`KeyframeEffect$I ／ （今や廃用にされた） `KeyframeEffectReadOnly$I
］構築子の［
<!-- #dom-keyframeeffectreadonly-keyframeeffectreadonly-target-keyframes-options-target -->
%target 引数,
`target$m ~member
］の型を
`Animatable?^I  から `(Element or CSSPseudoElement)?^I に変更した
（ <a href="https://github.com/w3c/web-animations/issues/186">#186</a> ）。
◎
Changed the type of the target argument to the KeyframeEffect and (now obsolete) KeyframeEffectReadOnly constructors, and the target member of these same interfaces, from Animatable? to (Element or CSSPseudoElement)? (#186).
</li>
	<li>
`SharedKeyframeList^I ~interfaceを落とした。
◎
Dropped the SharedKeyframeList interface.
</li>
	<li>
`Animatable$I ~interfaceを
[NoInterfaceObject] から `interface mixin$ に変換した。
◎
Converted Animatable from a [NoInterfaceObject] interface to an interface mixin.
</li>
</ul>

<p>
より詳細な履歴は
<a href="https://github.com/w3c/csswg-drafts/commits/master/web-animations-1">changelog</a>
に供される。
◎
The changelog provides a more detailed history.
</p>
	</section>

</main></div><!-- MAIN -->
