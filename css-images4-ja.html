<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Images Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<style>

#_dgm-efunc2 {
	position: relative;
	overflow: hidden;
	width: 24em;
	padding: 1.5em;
}

._ex-efunc-src {
	position: absolute;
	top: 0;
	left: 0;
	width: 12em;
	height: 3em;
	color: white;
	background: lime;
}
#_ex-efunc-dst {
	position: relative;
	color: black;
}

x-stripe {
	display: flex;
	width: 400px;
	height: 1.4em;
	height: 1lh;
	border: solid thin var(--N-color);
	color: var(--N-color);
}

x-stripe > div {
	height: 100%;
	text-align: center;
}

</style>

<style>
/* style-railroad */
svg.railroad-diagram {
	background-color: var(--bg-color-1);
}
svg.railroad-diagram path {
	stroke-width: 3px;
	stroke: var(--K-color);
	fill: none;
}
svg.railroad-diagram text {
	font: bold 14px monospace;
	text-anchor: middle;
	fill: var(--K-color);
}
svg.railroad-diagram text.label {
	text-anchor: start;
}
svg.railroad-diagram text.comment {
	font:italic 12px monospace;
}
svg.railroad-diagram rect {
	stroke-width: 3px;
	stroke: var(--K-color);
	fill: var(--G-bg);
}
</style>


<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>


Util.ready = function(){
	const source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);
}


function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'vt': // css values
	text = `&lt;${key}&gt;`;
	break;
case 'f':
	text = `${key}()`;
	break;
case 'ft': // funcdef
	text = `&lt;<code class="func">${key}()</code>&gt;`;
	klass='f';
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
case 'pull':
	href = `https://github.com/w3c/csswg-drafts/pull/${key}`;
	text = `pull #${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Images Module Level 4
spec_date:2024-02-14
trans_update:2024-02-16
source_checked:221013
page_state_key:CSS
original_url:https://drafts.csswg.org/css-images-4/
spec_status:WD
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:paint,css
conformance:css
copyright:2024,permissive
trans_1st_pub:2017-04-24


●●class_map
p:property
f:func
t:type
u:unit
vt:type
ft:type
v:value
css:css
e:element
a:attr
et:event-type

●●tag_map
p:code
t:var
vt:var
ft:var
css:code
f:code
d:code
c:code
e:code
a:code
u:code
f:code
v:code
I:code
m:code
et:code
V:var
i:i
em:em

●●original_id_map


●●mdn_urls
	propdef-image-resolution:CSS/image-resolution
propdef-object-fit:CSS/object-fit

typedef-image:CSS/image
typedef-gradient:CSS/gradient
	typedef-image-set-option
	typedef-image-src
	typedef-image-tags
	typedef-linear-color-hint
	typedef-linear-color-stop
	typedef-angular-color-hint
	typedef-angular-color-stop-list
	typedef-angular-color-stop
	typedef-color-stop
	typedef-color-stop-angle
	typedef-color-stop-length
	typedef-color-stop-list

funcdef-conic-gradient:CSS/gradient/conic-gradient()
funcdef-cross-fade:CSS/cross-fade()
funcdef-element:CSS/element()
funcdef-image-set:CSS/image/image-set()
funcdef-image:CSS/image/image()
funcdef-repeating-conic-gradient:CSS/gradient/repeating-conic-gradient()
funcdef-repeating-linear-gradient:CSS/gradient/repeating-linear-gradient()
funcdef-repeating-radial-gradient:CSS/gradient/repeating-radial-gradient()

●●link_map

SameObject:~WEBIDLjs#SameObject
any:~WEBIDL#idl-any
I.CSS:~CSSOM1#namespacedef-css
I.CSSStyleSheet:~CSSOM1#cssstylesheet

m.elementSources:#dom-css-elementsources

a.dir:~HTMLdom#attr-dir
e.canvas:~HEcanvas#the-canvas-element
e.p:~HEgrouping#the-p-element
e.img:~HEimages#the-img-element
e.video:~HEmedia#the-video-element
e.iframe:~HEembed#the-iframe-element
e.picture:~HEimages#the-picture-element
	e.ul
	e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.defs:~SVGstruct#elementdef-defs
	e.linearGradient:~SVGpservers#elementdef-linearGradient
	e.radialGradient:~SVGpservers#elementdef-radialGradient
e.pattern:~SVGpservers#elementdef-pattern
e.use:~SVGstruct#elementdef-use

	et.click
p.object-fit:#propdef-object-fit
p.object-position:~CSSIMAGE#propdef-object-position
p.object-view-box:~CSSWG/css-images-5/#propdef-object-view-box

p.image-resolution:#propdef-image-resolution
p.background-image:~CSSBG#propdef-background-image
p.background-position:~CSSBG#propdef-background-position
p.background-color:~CSSBG#propdef-background-color
p.background-size:~CSSBG#propdef-background-size
p.cursor:~CSSUI#propdef-cursor
p.direction:~CSSWM#propdef-direction
p.list-style-image:~CSSLIST#propdef-list-style-image
p.list-style-type:~CSSLIST#propdef-list-style-type

v.snap:#valdef-image-resolution-snap
v.from-image:#valdef-image-resolution-from-image
v.transparent:~CSSCOLOR#valdef-color-transparent
	透明な黒:
v.center:~CSSBG#valdef-background-position-center

v.contain:#valdef-object-fit-contain
v.cover:#valdef-object-fit-cover
v.fill:#valdef-object-fit-fill
v.none:#valdef-object-fit-none
v.scale-down:#valdef-object-fit-scale-down

v.circle:~CSSIMAGE#valdef-radial-shape-circle
v.ellipse:~CSSIMAGE#valdef-radial-shape-ellipse

t.angular-color-hint:#typedef-angular-color-hint
t.angular-color-stop-list:#typedef-angular-color-stop-list
t.angular-color-stop:#typedef-angular-color-stop
t.color-stop-angle:#typedef-color-stop-angle
t.color-stop-length:#typedef-color-stop-length
t.color-stop-list:#typedef-color-stop-list
t.color-stop:#typedef-color-stop
t.gradient:#typedef-gradient
t.image-set-option:#typedef-image-set-option
t.image-src:#typedef-image-src
t.image-tags:#typedef-image-tags
t.image:#typedef-image
t.linear-color-hint:#typedef-linear-color-hint
t.linear-color-stop:#typedef-linear-color-stop
t.side-or-corner:~CSSIMAGE#typedef-side-or-corner
	t.side-or-corner:#typedef-side-or-corner
t.image-1D:#typedef-image-1d
t.color-stripe:#typedef-color-stripe
t.flex:~CSSGRID#typedef-flex

t.color:~CSSCOLOR#typedef-color
t.color-interpolation-method:~CSSCOLOR#color-interpolation-method
t.id-selector:~SELECTORS4#typedef-id-selector
t.linear-gradient-syntax:#typedef-linear-gradient-syntax
t.radial-gradient-syntax:#typedef-radial-gradient-syntax
t.conic-gradient-syntax:#typedef-conic-gradient-syntax

t.angle-percentage:~CSSVAL#typedef-angle-percentage
t.angle:~CSSVAL#angle-value
t.basic-shape:~CSSSHAPES#typedef-basic-shape
t.length-percentage:~CSSVAL#typedef-length-percentage
t.position:~CSSVAL#typedef-position
t.string:~CSSVAL#string-value
t.url:~CSSVAL#url-value
t.custom-ident:~CSSVAL#identifier-value
t.length:~CSSVAL#length-value
t.resolution:~CSSVAL#resolution-value
t.percentage:~CSSVAL#percentage-value

t.cf-image:#typedef-cf-image
t.radial-extent:~CSSIMAGE#typedef-radial-extent
t.radial-size:~CSSIMAGE#typedef-radial-size
t.radial-shape:~CSSIMAGE#typedef-radial-shape

f.repeating-conic-gradient:#funcdef-repeating-conic-gradient
f.repeating-linear-gradient:#funcdef-repeating-linear-gradient
f.repeating-radial-gradient:#funcdef-repeating-radial-gradient
t.repeating-linear-gradient():#funcdef-repeating-linear-gradient
t.repeating-radial-gradient():#funcdef-repeating-radial-gradient
t.repeating-conic-gradient():#funcdef-repeating-conic-gradient

f.stripes:#funcdef-stripes
f.cross-fade:#funcdef-cross-fade
f.image-set:#funcdef-image-set
f.-webkit-image-set:#funcdef--webkit-image-set
f.type:#funcdef-image-set-type
f.linear-gradient:~CSSIMAGE#funcdef-linear-gradient
f.radial-gradient:~CSSIMAGE#funcdef-radial-gradient
f.conic-gradient:#funcdef-conic-gradient
f.element:#funcdef-element
t.element():#funcdef-element
f.image:#funcdef-image
f.url:~CSSVAL#funcdef-url
f.circle:~CSSSHAPES#funcdef-basic-shape-circle
f.ellipse:~CSSSHAPES#funcdef-basic-shape-ellipse

	tv.angle:#valdef-conic-gradient-angle
	tv.position:#valdef-conic-gradient-position
	tv.resolution:#valdef-image-resolution-resolution

u.px:~CSSVAL#px


	●用語

~gradient関数:#gradient-function
~gradient~box:#gradient-box
~gradient中心:#conic-gradient-gradient-center
~gradient線:#gradient-line

読込n中の画像:#loading-image
画像~解像度:#image-resolution
生来な解像度:#natural-resolution
選好d解像度:#preferred-resolution
無効な画像:#invalid-image
描画され:#element-not-rendered
塗り~source:#paint-source

生来な寸法を決定する:#natural-dimensions-of-a-cross-fade
外観を決定する:#appearance-of-a-cross-fade

~fallback色を伴う~URL:#image-notation
装飾d限界~box:#decorated-bounding-box

円錐型~gradient:#conic-gradients

始点:#starting-point
終点:#ending-point

色停:#color-stop
遷移~hint:#color-transition-hint
色停~list:#color-stop-list

塗り線:#paint-line
1-次元な画像:#1d-image

~stylesheet用に外部の画像を~fetchする:#fetch-an-external-image-for-a-stylesheet

	§:#gradients
	§:#image-notation
	§:#color-images
	§:#element-notation
	§:#repeating-gradients
	§:#color-stop-syntax

	●用語（L3
	色停:~CSSIMAGE#color-stop
	遷移~hint:~CSSIMAGE#color-transition-hint
	色停~list:~CSSIMAGE#color-stop-list

終形:~CSSIMAGE#ending-shape
中心:~CSSIMAGE#radial-gradient-gradient-center
線型~gradient:~CSSIMAGE#linear-gradients
放射型~gradient:~CSSIMAGE#radial-gradients
繰返ng~gradient:~CSSIMAGE#repeating-gradients
	繰返ng~gradient:#repeating-gradients
~URL参照:~CSSIMAGE#url-notation
具象-~obj~size:~CSSIMAGE#concrete-object-size
既定の~obj~size:~CSSIMAGE#default-object-size
生来な寸法:~CSSIMAGE#natural-dimensions
生来な縦幅:~CSSIMAGE#natural-height
生来な横幅:~CSSIMAGE#natural-width
生来な~size:~CSSIMAGE#natural-size
生来な縦横比:~CSSIMAGE#natural-aspect-ratio
~obj~size折衝:~CSSIMAGE#object-size-negotiation

	●用語（CSS

算出d値:~CASCADE#computed-value

~border画像~区画:~CSSBG#border-image-area

積層~文脈:~CSS2J#stacking-context

透明な黒:~CSSCOLOR#transparent-black
算出d色:~CSSCOLOR#computed-color

角括弧付き範囲~記法:~CSSVAL#css-bracketed-range-notation
関数-記法:~CSSVAL#functional-notation
~style資源を~fetchする:~CSSVAL#fetch-a-style-resource

~flex~layout:~CSSFLEX#flex-layout

内在的~size:~SIZING#intrinsic-size

	●用語（外部

~tuple:~INFRA#tuple
~item:~INFRA#list-item
~list:~INFRA#list
付加する:~INFRA#list-append
空:~INFRA#list-is-empty

応答:~FETCH#concept-response

媒体~素片~識別子:~TR/media-frags/#naming-space
媒体~素片:~TR/media-frags/

利用元~単位:~SVGcoords#TermUserUnits
	利用元~単位:~SVG11/coords.html#Units
塗り~server:~SVGpainting#TermPaintServerElement
	塗り~server:~SVG11/pservers.html
~secure~animate化~mode:~SVGconform#secure-animated-mode
	~secure~animate化~mode:~TR/svg-integration/#secure-animated-mode
~secure静的~mode:~SVGconform#secure-static-mode
	~secure静的~mode:~TR/svg-integration/#secure-static-mode

	all elements:~CSSWG/css-pseudo/#generated-content

	:images/sprites.svg
	<color-hint> <color-hint>:
	<color-stop> <color-stop>:

首要~box:~CSSDISP#principal-box
置換d要素:~CSSDISP#replaced-element

生成d内容:~CSS22/generate.html#content

~ID選択子:~SELECTORS4#id-selector

線型~easing関数:~CSSEASING#linear-easing-function
~easing関数:~CSSEASING#easing-function

妥当な~MIME型:~MIMESNIFF#valid-mime-type

●●words_table1
SVGconform:svg-conform-ja.html

●●words_table


	●幾何
2D:
1D:
	1D:1d-
次元な:dimensional:~
	0-次元な:0-dimensional (0D)
	1-次元な:1-dimensional (1D)
	2-次元な:2-dimensional (1D)
回転-:rotate::~
回転:rotation::~
中心:center:~
半径:radius:~
四分円:quadrant:~
楕円な:ellipticalな:~
楕円:ellipse:~
真円:circle:~
円錐:cone::~
正方形:square:~
無限小:infinitesimal:~
線:line::~
直線:straight line:~
射線:ray line:~
	射線:ray
渦巻き:spiral:~
重合n:overlap:重なり合い
端点:endpoints:~
始点:starting point:~
終点:ending point:~
外方:outward:~
側:side:~
矩形:rectangle:~
矩形な:rectangularな:~
極座標:polar::~

裏返され:flipされ:~
裏返して:flipして:~
左上隅:top left corner:~
変形-:transform:~
横:horizontal::~
縦:vertical::~
ズラし:shiftし:ずらし
拡縮-:scale::~
	拡縮し直す:rescale
時計回り:clockwise::~
	反~時計回り
並進:translation::~
並進-:translate::~
形状:shape:~
中点:midpoint:~
面積:area:~
	面積が 0:zero-area
連続的:continuous:~
滑らか:smooth::~
比率:ratio:~
測度:measure:~
限界:bounding::~
限界域:bounds::~
無方向:directionless::~
太さ:thickness:~
極-:polar::~
直交-:orthogonal::~
平均化対角線長さ:scaled diagonal:~

	軸に~~平行な:axis-aligned
	なぞる:follow
	曲がった:curved
	外れ易くなる:easy for 〜 fall out of
	近づく:approach
	沿って:along
	端から端まで:end-to-end
	過ぎる:past
	幅:wide
	幅:width
	%総幅:total width
	逆~方向の:opposite direction
	向きのある:directional
	広さ無限:infinite

	●算術
丸めた:roundした:~
総和:sum:~
	総和:total
	総和:total sum
	総和:summed together
加重d:weighted:加重
重み:weight:~
平均:average:~
	色の平均をとる:color-averaging
同等性:equality:~
分配-:distribute:~
延伸-:extend:~
割合分:fraction:~
乗算済み:premultiplied::~
	乗算済みでない:non-premultiplied
確率的:stochastic:~
収束-:converge:~

	利用元~単位:user coordinate
	変換
	切り上げ:floor
	等分にあてがわれる:divided equally between〜
	占める:share
	N-way Porter-Duff
	Wikipedia

	●gradient
gradient:
線型:linear::~
放射型:radial::~
円錐型:conic::~
	^en:conical
終形:ending shape::~
繰返ng:repeating:繰り返し
	繰返ngなしの:non-repeating
繰返n:repetition:繰り返し
繰返して:repeatして:繰り返して
繰返しな:repeatしな:繰り返しな
均等:even:~

	●§gradient
graphics-library:graphics library::グラフィックス ライブラリ
埋める:fillする:~
確定的:definite::~
混合-:mix:~
混合:mixing:~
先行-:precede:~
後続-:follow:~
割合:percentage:~
市松模様:checkerboard:~
旭光状:starburst-type:~
縞:stripe:~
pie-chart:pie chart:円グラフ
指数関数曲線:exponential curve:~
中間点:halfway:~
	中間点:halfway point
動き:movement:~
湧出る:emergeする:湧き出る
修繕-:fix up:~
修繕:fixup:~
実数:number:~

	増加:increasing
	~~式
	deg^v:degree
	~~区間:segment
	それを挟む:surrounding
	上から眺めた:observed from above
	中心~点:center-point
	同じ所:right on
	周に沿って:around the circumference
	周り:around
	回る:spin
	地点:at／:point
	指して／地点:point

	等間隔:space themselves out equally
	等間隔に置く:evenly spaced
	高さ:tall
	-:weighting
	~~幾何的:technically
	変える:varying
	変わる:vary
	-:Just like linear gradients,
	見かけ:looks
	順
	置かれ:put／-
	近い:near
	通る:passes through
	連なり:run
	~~連続する:in a row／:-
	並ぶ:-
	成す
	挟まれ:in
	挟める:-
	数
	一定:constant
	欠いて:lack
	点
	現れた:-
	白丸
	種
	節
	結ぶ:-
	昇順:ascending order
	交わる


	●色
RGB:
sRGB:
RGBA:
sRGBA:
CIE:
Lab:
LCH:
Oklab:
Oklch:
	色~付け:coloring
色停:color-stop::~
	色停:color stop
	色停:stop
単色:solid-color::~
	単色:solid-color::ベタ塗り
原色:primary::~
色度:chroma::~
色相:hue::~
彩度:saturation::~
有彩度な:saturatedな::~
	彩度が低下-:desaturated
	彩度の低下:desaturation
中立:neutral:~
色域:gamut::~
色環:wheel:~
alpha:
gamma::::ガンマ
透明度:transparency::~
不透明度:opacity::~
半透明:partially-transparent::~
混色-:blend::~
暗に:darkに:暗く
知覚的:perceptual:~
一様:uniform:~
線形性:linearity::~
黒:black:~
黒な:blackな:黒い
白:white:~
白な:whiteな:白い
灰色:gray:~
red:
green:
purple:
blue:
yellow:
orange:

	^v:blue
	^v:yellow
	^v:red
	〜がかった／〜がかる:-ish
	〜っぽくなる:has a 〜-ish cast
	〜っぽさ:with 〜 cast
	〜っぽさ:has 〜 cast
	中間:intermediate
	色域~対応付けが施され:gamut mapped to bring
	色を伴う:colored

	●塗り／画像
bitmap::::ビットマップ
raster::::ラスター
	~raster化:rasterization
生来:natural::~
解像度:resolution::~
影:shadow::~
塗り:paint:~
塗ng:painting:塗り
塗られ:paintされ:~
dot::::ドット
	ドット数:dots
品質:quality:~
fade::::フェード
cross-fade::::クロスフェード
	~cross-fade法:cross-fading
美麗:attractive:~
見かけ:look:~
interlace::::インターレース
GIF:
PNG:
JPEG:
AVIF:
縦横比:aspect ratio::~
装飾-:decorate::~
装飾d:decorated::装飾
装飾的:decorative::~
描く:drawする:~
描いた:drawした:~
描かれ:drawされ:~
切抜く:clip outする:切り抜く
切抜かれ:clip outされ:切り抜かれ
切取る:clipする:切り取る
切取られ:clipされ:切り取られ
埋尽く:fill し尽く:埋め尽く
積層:stacking::~
	視覚-化:visualize
部位:portion:~
dither::::ディザ
	~dither法:dithering

	~view~box:viewbox
	~view~box:Viewbox
	~view~box:view box
	~~背後に回る:lies beneath
	淡く染める:tinting
	画素が目立つ:pixelated
	上層に重ね:overlay
	重ねて:overlay
	濃くなる:shade
	急激:sudden／:sharp
	色相と彩度を伴う色環:hue &amp; saturation wheel
	淡い陰影:subtle shading
	徐々に濃く:shading gradually
	くすむ:-
	明るく:lighter

	●network
mobile::::モバイル
filesize::::ファイルサイズ
帯域幅:bandwidth:~
混在して:mixされて:~
混在でき:mixでき:~
速度:speed:~
低速:slow:~
	読込n中の:loading
	~~部分的走査:pass
	~~更新:refresh

	●CSS layout
slice::::スライス
flex:
	overlay
	~page割り:pagination
接合-:flush:~
	接合-:joined flush
浮動-:float::~
収める:fitさせる:~
首要:principal::主要
柱:column::::カラム

	●遷移
	~animate化:animated
開始ng:starting:開始
終止-:end:~
終止ng:ending:終止
経過-:elapse:~
easing:
	増減:grow and then shrink
一足飛び:abrupt:~
	進行度合い:how far along in

	●CSS
	~LET:initialized
左横書き:LTR:~
右横書き:RTL:~
双向性:bidi::~


	●構文
構成-:compose:~
線路図式:railroad diagram:~
	構文~空間:syntax-space
角括弧付き:bracketed::~
拡張p-:expand:拡張

	●構造
循環:cycle:~
循環関係:circular relationship:~


	●媒体／UI
印刷機:printer::~::プリンタ
slideshow::::スライドショー
slide::::スライド
preview::::プレビュー
display::::ディスプレイ
紙:paper:~
monitor::::モニタ
中間的:intermediate:~
矢印:arrow:~

	●仕様
利点:advantage:~
自立的:standalone:~
疑似的な:pseudo-:~
無為:nonsensical:~
解決策:solution:~
賢い:smartな:~
強調:highlight:~
条項:clause:~
最大化して:maximizeして:最大限に得て
防げる:preventできる:~
競合-:conflict:~
代理-:proxy:~
見積もり:estimation:~
微妙:subtle:~
可能性:possibility:~
普通の:ordinaryな:~
内来的:inherent:~
精緻化:refinement:~
誤記:typo:~
維持-:retain:~
規定-:dictate:~
誤り:error:~
義務的:mandatory:~
計画-:plan:~
整備-:tighten:~

	より詳しく述べるなら、:In specific terms,
	も:still
	軽微:minor
	大幅:major
	補助:helpful
	易くする:help
	誤ったものに:be wrong
	~~問題なく:fine
	かなり:substantially
	度に:over time
	またはそれに準じるもの:some degree of
	表す:denote
	最低限:at minimum
	どうにかして:somehow
	に対する:compared to
	に応じる:-sensitive
	応じ:care
	編集者:I
	多くの用途に:put to many uses
	-:we
	-:my
	~~仕事:task
	気をつける:exercise caution
	目立って:noticeably
	裁定-:decision
	dependent
	見受けられ:appears to be
	行える:can be done
	要する:requiring
	選ぶ:choice
	選ぶ:choose
	選ばれ／選んだ:chosen
	次に従って:as follows
	影響しない:has no effect on
	助ける:help:
	~~十分表現可能な:that can do it justice
	~level 3:CSS Images 3
	従う
	従って:follow
	捉えれば:think of
	捉える:thought of
	方法
	施す
	示す:illustrate
	要する
	明らかにする:show off
	称されて:known
	様子
	良好:nice
	略記
	暗黙
	簡素な:terse
	傾向:tends
	助けになる:helpful
	いくぶん:somewhat
	-:making sure
	しか選べな:the only choice
	選べば:chosing
	序論:intro
	注記:note
	〜種の:〜 different
	ここに記したように、:notice that
	書き直:rewrite
	もっと明確になるよう:for better clarity
	~prop定義~表t:propdef table
	各種〜:assorted
	短縮-:shorten
	修正-:fixes
	正した:correction
	綴り:spelling
	明らかにする:showing off
	ようになる:now
	した後:then 〜 on top of
	実装:impl
	1 個目の拘束しか満たさない:fail the second one only
	他の場合:fail the first constraint
	処する:deals with
	汎用~的に:generically
	満たす:satisfy
	取り込んだ:pull
	揃えた:align

	●未分類
存続期間:lifetime:~
給-:supply:~
再生産-:reproduce:~
参照r:refer:参照
参照先の:referenced:~
参照元の:referencing:~
読める:readできる:~
	readable
検索-:look up:~
選択-:select:~
GCPM:
bullet::::ビュレット
tellub::::トッレュビ
数値的:explicit:~
背後:behind:~
fancy:
inch::::インチ
一部分:portion:~
最終-:final:~
	最後の:final
切落とさ:truncateさ:切り落とさ
graphics::::グラフィックス

	`image-set-option^t:option
	文書~外:Out-Of-Document
	上書き法:overriding
	追加された:additional
	生成し直-:regenerate／:regeneration
	生の:rawな:~
	~~計算
	~~指示
	対応~付ける:match
	探す:look for
	指-:point
	保ち続け keep track
	食い過ぎる:eats too much 
	塞ぐ:slapping
	片:snippet
	転換され:turned into
	存続する:lifetime
	高
	低
	挟まれた:interleaved with
	現れる:appear
	一斉に:in tandem
	X
	background-image
	against
	~~基準に:against
	HTML5
	-:entirely
	Mozilla:Moz
	consist
	B
	A
	来:come
	欠く:lack
	%stream:byteStream
	戻す:back
	単位なしの:unitless
	組合n:combo
	様々な:different
	-:obtain
	-:unvarying ...
	全:fully
	先ず:first
	先頭:beginning
	先頭の:leading
	も:as well
	だけ:just
	単に:just
	何〜かに:across
	まったく:at all／never 〜 at all
	他のどこか:anywhere else
	他方:other
	-:somewhat silly
	次の／前の:next/previous
	主な:main
	そのまま:as-is
	またがる:across
	数種の:handful
	あるもの／:anything
	傍:alongside
	他方:On the other hand
	種々の:various
	まるで:entirely
	~~連続する:in a row
	部分的に:partially-
	-:in place
	を挟む:surrounding
	残りの:remaining
	残された:leftover
	より旧い:older
	古い:old
	小さい:small
	最も小さい:smallest
	より小さい:smaller
	より大きい:larger
	広く:widely-
	より高:higher-
	高-:high-
	低-:low-
	極高-:extremely high
	極めて:extremely
	-:finally
	-:among
	2 回:twice
	ほぼ:mostly
	-:now
	各自に対応する:respective〜siblings
	指して:pointing
	一連の:sets of
	小さく縮める:shrink to 〜 small
	いくぶん失われ:entail some loss of
	~~配分し直:rebalance
	上げ
	両:either
	互いに
	以上
	以下
	以前に:previously
	先に
	前者:-
	後者:-
	時点
	部分:part of
	以前に:previously
	やや:little
	少し:slight
	2 個目（図中段）の:middle
	1 個目（図上段）の:upper
	3 個目（図下段）の:lower
	1 個以上の:1+
	~~欄:entry
	~~欄:line
	各部:parts
	隣接する 2 個の〜合間における:Between each pair of
	含める:include
	2 個ある:two-
	 2 個の 〜 が成す:dual

●●images

＠css-images/
sprites｜height:40px｜｜.svg
rectangular-f01-081｜height:330px｜｜.png
rectangular-fff-01e｜height:330px｜｜.png
rectangular-44c-795｜height:330px｜｜.png
polar-a37-595｜height:538px｜｜.png
radial-rectangular-f01-081｜height:330px｜｜.png
conic-diagram｜width:400px; height:300px;｜｜.png
conic1｜width:300px; height:200px;｜上の例の見本描画｜.png
conic2｜width:300px; height:200px;｜上の例の見本描画｜.png
conic3｜width:300px; height:200px;｜上の例の見本描画｜.png
conic4｜width:300px; height:200px;｜上の例の見本描画｜.png
conic5｜width:200px; height:200px;｜上の例の見本描画｜.png
conic6｜width:202px; height:202px;｜上の例の見本描画｜.png
repeating-conic1｜width:300px; height:200px;｜上の例の見本描画｜.png
repeating-conic2｜width:300px; height:200px;｜上の例の見本描画｜.png
repeating-conic3｜width:300px; height:200px;｜上の例の見本描画｜.png
gradient-colors-transition-hint-comparison｜height:200px｜＋｜.png
	stripes1｜height:1em;｜＋｜.svg
	stripes2｜height:1em;｜＋｜.svg
img_scale｜height:160px;border: thin solid black;｜＋｜.svg
	element-function｜｜｜.png


●●ref_normative

[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. 19 December 2023. CR. URL: https://www.w3.org/TR/css-backgrounds-3/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. 13 January 2022. CR. URL: https://www.w3.org/TR/css-cascade-5/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. 1 November 2022. CR. URL: https://www.w3.org/TR/css-color-4/
[CSS-GRID-2]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. ＜CSS Grid Layout Module Level 2＞. 18 December 2020. CR. URL: https://www.w3.org/TR/css-grid-2/
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 3＞. 18 December 2023. CR. URL: https://www.w3.org/TR/css-images-3/
[CSS-IMAGES-4]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 4＞. 17 February 2023. WD. URL: https://www.w3.org/TR/css-images-4/
[CSS-IMAGES-5]
    ＜CSS Images Module Level 5＞. Editor's Draft. URL: https://drafts.csswg.org/css-images-5/
[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Lists and Counters Module Level 3＞. 17 November 2020. WD. URL: https://www.w3.org/TR/css-lists-3/
[CSS-SHAPES-1]
    Rossen Atanassov; Alan Stearns. ＜CSS Shapes Module Level 1＞. 15 November 2022. CR. URL: https://www.w3.org/TR/css-shapes-1/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. 17 December 2021. WD. URL: https://www.w3.org/TR/css-sizing-3/
[CSS-UI-4]
    Florian Rivoal. ＜CSS Basic User Interface Module Level 4＞. 16 March 2021. WD. URL: https://www.w3.org/TR/css-ui-4/
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 3＞. 1 December 2022. CR. URL: https://www.w3.org/TR/css-values-3/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. 18 December 2023. WD. URL: https://www.w3.org/TR/css-values-4/
[CSS2]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS21/
[CSS3-TRANSFORMS]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/
[CSSOM]
    Daniel Glazman; Emilio Cobos Álvarez. ＜CSS Object Model (CSSOM)＞. 26 August 2021. WD. URL: https://www.w3.org/TR/cssom-1/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIA-FRAGS]
    Raphaël Troncy; et al. ＜Media Fragments URI 1.0 (basic)＞. 25 September 2012. REC. URL: https://www.w3.org/TR/media-frags/
[MIMESNIFF]
    Gordon P. Hemsley. ＜MIME Sniffing Standard＞. Living Standard. URL: https://mimesniff.spec.whatwg.org/
[PNG]
    Chris Lilley; et al. ＜Portable Network Graphics (PNG) Specification (Third Edition)＞. 21 September 2023. CR. URL: https://www.w3.org/TR/png-3/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECT]
    Tantek Çelik; et al. ＜Selectors Level 3＞. 6 November 2018. REC. URL: https://www.w3.org/TR/selectors-3/
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. 11 November 2022. WD. URL: https://www.w3.org/TR/selectors-4/
[SVG-INTEGRATION]
    Cameron McCormack; Doug Schepers; Dirk Schulze. ＜SVG Integration＞. 17 April 2014. WD. URL: https://www.w3.org/TR/svg-integration/
[SVG11]
    Erik Dahlström; et al. ＜Scalable Vector Graphics (SVG) 1.1 (Second Edition)＞. 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[CSS-FLEXBOX-1]
    Tab Atkins Jr.; et al. ＜CSS Flexible Box Layout Module Level 1＞. 19 November 2018. CR. URL: https://www.w3.org/TR/css-flexbox-1/
[SMIL10]
    Philipp Hoschka. ＜Synchronized Multimedia Integration Language (SMIL) 1.0 Specification＞. 15 June 1998. REC. URL: https://www.w3.org/TR/1998/REC-smil-19980615/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより作業草案として公開された
<a href="~SPEC_URL">CSS Images Module Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-images-4/
公表履歴
	https://www.w3.org/standards/history/css-images-4/

フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-images-4">CSSWG Issues Repository</a>
	<a href="https://www.w3.org/Style/CSS/Tracker/products/27">Tracker</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Apple)
	<a href="http://lea.verou.me/about">Lea Verou</a> (Invited Expert)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-images-4/Overview.bs">GitHub Editor</a>
テスト一式
	https://wpt.fyi/results/css/css-images/
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-images-4
</script>

</head>

<body>


<!--%resource pool -->
<template id="_persisted_parts">

<pre class="lang-html" id="_dgm-efunc1">
&lt;style&gt;
#src {
    color: white;
    background: lime;
    width: 12em;
    height: 3em;
    position: relative;
}
#dst {
    color: black;
    background: element(#src);
    width: 20em;
    padding: 1.5em;
}
&lt;/style&gt;
&lt;p id='src'&gt;普通の要素です。&lt;/p&gt;
&lt;p id='dst'&gt;前の要素を背景に利用しています。&lt;/p&gt;
</pre>

<!-- 
I’m an ordinary element!
I’m using the previous element as my background!
 -->

<!-- element-function.png -->
<div id="_dgm-efunc2">
<div class="_ex-efunc-src" style="">普通の要素です。</div>
<div class="_ex-efunc-src" style="left:12em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="left:24em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em; left:12em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em; left:24em;">普通の要素です。</div>
<div id="_ex-efunc-dst">前の要素を背景に利用しています。</div>
</div>

<svg
	id="_dgm-color-stop-railroad"
	class="railroad-diagram"
	width="653.0" height="112"
	viewBox="0 0 653.0 112"
>
<g transform="translate(.5 .5)">
<g>
<path d="M20 21v20m10 -20v20m-10 -10h20"></path>
</g>
<path d="M40 31h10"></path>
<g class="non-terminal ">
<path d="M50 31h0.0"></path>
<path d="M172.0 31h0.0"></path>
<rect height="22" width="122" x="50" y="20"></rect>
<text x="111" y="35">&lt;color-stop&gt;</text>
</g>
<path d="M172.0 31h10"></path>
<path d="M182.0 31h10"></path>
<g class="terminal ">
<path d="M192.0 31h0.0"></path>
<path d="M220.5 31h0.0"></path>
<rect height="22" rx="10" ry="10" width="28.5" x="192" y="20"></rect>
<text x="206.25" y="35">,</text>
</g>
<path d="M220.5 31h10"></path>
<path d="M230.5 31h10"></path>
<g>
<path d="M240.5 31h0.0"></path>
<path d="M603.0 31h0.0"></path>
<path d="M240.5 31h10"></path>
<g>
<path d="M250.5 31h0.0"></path>
<path d="M593.0 31h0.0"></path>
<g>
<path d="M250.5 31h0.0"></path>
<path d="M461.0 31h0.0"></path>
<path d="M250.5 31h20"></path>
<g>
<path d="M270.5 31h170.5"></path>
</g>
<path d="M441.0 31h20"></path>
<path d="M250.5 31a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path>
<g>
<path d="M270.5 51h0.0"></path>
<path d="M441.0 51h0.0"></path>
<g class="non-terminal ">
	<path d="M270.5 51h0.0"></path>
	<path d="M392.5 51h0.0"></path>
	<rect height="22" width="122" x="270.5" y="40"></rect>
	<text x="331.5" y="55">&lt;color-hint&gt;</text>
</g>
<path d="M392.5 51h10"></path>
<path d="M402.5 51h10"></path>
<g class="terminal ">
	<path d="M412.5 51h0.0"></path>
	<path d="M441.0 51h0.0"></path>
	<rect height="22" rx="10" ry="10" width="28.5" x="412.5" y="40"></rect>
	<text x="426.75" y="55">,</text>
</g>
</g>
<path d="M441.0 51a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path>
</g>
<path d="M461.0 31h10"></path>
<g class="non-terminal ">
<path d="M471.0 31h0.0"></path>
<path d="M593.0 31h0.0"></path>
<rect height="22" width="122" x="471" y="20"></rect>
<text x="532" y="35">&lt;color-stop&gt;</text>
</g>
</g>
<path d="M593.0 31h10"></path>
<path d="M250.5 31a10 10 0 0 0 -10 10v30a10 10 0 0 0 10 10"></path>
<g class="terminal ">
<path d="M250.5 81h157.0"></path>
<path d="M436.0 81h157.0"></path>
<rect height="22" rx="10" ry="10" width="28.5" x="407.5" y="70"></rect>
<text x="421.75" y="85">,</text>
</g>
<path d="M593.0 81a10 10 0 0 0 10 -10v-30a10 10 0 0 0 -10 -10"></path>
</g>
<path d="M603.0 31h10"></path>
<path d="M 613.0 31 h 20 m -10 -10 v 20 m 10 -20 v 20"></path>
</g>
</svg>

<x-stripe
	id="_dgm-stripes1"
	role="img"
>
	<div style="width:100px; background:red;">red</div>
	<div style="width:200px; background:green;">green</div>
	<div style="width:100px; background:blue;">blue</div>
</x-stripe>

<x-stripe
	id="_dgm-stripes2"
	role="img"
>
	<div style="width:30px; background:red;"></div>
	<div style="width:60px; background:green;"></div>
	<div style="width:100px; background:blue;"></div>
	<div style="width:210px; background:transparent;">transparent</div>
</x-stripe>

</template>

<header>
	<hgroup>
<h1>CSS Images Module Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
◎要約

<p>
この~moduleは、 `image$t 型と`置換d要素$に関係する~CSS~level 4 の特能を包含する。
それは、~CSS~level 2 `CSS2$r と この仕様の~level 3 `css-images-3$r の機能性を含み，それを拡張する。
~level 3 からの主な拡張は、
`image$t 型に対する `image$f 記法, `element$f 記法などの追加，および
円錐型~gradientである。
◎
This module contains the features of CSS level 4 relating to the &lt;image&gt; type and replaced elements. It includes and extends the functionality of CSS level 2 [CSS2] and in the previous level of this specification [css-images-3]. The main extensions compared to "CSS Images Module Level 3" [css-images-3] are several additions to the &lt;image&gt; type, such as the image() notation, the element() notation, and conic gradients.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、公表~時点における…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
この~moduleは~2D画像を表現するための追加的な仕方を導入する
例えば，
`~fallback色を伴う~URL$ ／
`円錐型~gradient$として ／
`文書~内の別の要素の描画＠#element-notation$として。
◎
This module introduces additional ways of representing 2D images, for example as a URL with color fallback, as conic gradients, or as the rendering of another element in the document.
</p>

		<section id="values">
<h3 title="Value Definitions">1.1. 値~定義</h3>

<p class="trans-note">【
この節の内容は `~CSS日本語訳 共通~page＠~CSScommon#values$に移譲。
】</p>

		</section>
	</section>
	<section id="image-values">
<h2 title="2D Image Values: the &lt;image&gt; type">2. ~2D画像~値： `image^t 型</h2>

<p>
`image$t 値~型は、
~2D画像を表し，［
`~URL参照$ ／
`~fallback色を伴う~URL$ ／
`~gradient記法＠#gradients$
］をとり得る。
その構文は、
次で与えられる：
◎
The &lt;image&gt; value type denotes a 2D image. It can be a url reference, image notation, or gradient notation. Its syntax is:
</p>

<pre class="prod">
`image@t
	= `url$t
	| `image$ft
	| `image-set$ft
	| `cross-fade$ft
	| `element$ft
	| `gradient$t
</pre>

<p class="trans-note">【
以下，［
`無効な画像@
／
`読込n中の画像@
／
`image$t の`算出d値$【！ id="computed-image" 】
］の定義も含め，
`~level 3 と同じ＠~CSSIMAGE#image-values$
（なので、和訳は省略する）。
】</p>

		<section id="image-file-formats">
<h3 title="Image File Formats">2.1. 画像~file形式</h3>

<p>
~propにおいて `image$t 値から参照される妥当な画像に対しては、
~UAは，最低限，次の~file形式を~supportするモノトスル：
◎
At minimum, the UA must support the following image file formats when referenced from an &lt;image&gt; value, for all the properties in which using &lt;image&gt; is valid:
</p>

<ul>
	<li>
`PNG$r により指定される，~PNG
◎
PNG, as specified in [PNG]
</li>
	<li>
`SVG11$r により指定される，`~secure静的~mode$を利用している~SVG
（ `SVG-INTEGRATION$r を見よ）
◎
SVG, as specified in [SVG11], using the secure static mode (See [SVG-INTEGRATION])
</li>
	<li>
~UAが~animate化 `image$t を~supportする場合、
`SVG11$r により指定される，`~secure~animate化~mode$を利用している~SVG
（ `SVG-INTEGRATION$r を見よ）
◎
If the UA supports animated &lt;image&gt;s, SVG, as specified in [SVG11], using the secure animated mode (See [SVG-INTEGRATION])
</li>
</ul>

<p>
~UAは、
他の~file形式を~supportしてもヨイ。
◎
The UA may support other file formats as well.
</p>

		</section>
		<section id="url-notation">
<h3 title="Image References: the url() notation">2.2. 画像~参照： `url^f 記法</h3>

<p class="note">注記：
`~level 3 と同じ＠~CSSIMAGE#url-notation$。
◎
Note: No change from [css-images-3].
</p>

		</section>
		<section id="fetching-images">
<h3 title="Fetching External Images">2.3. 外部~画像の~fetch法</h3>

<div class="algo">
<p>
`~stylesheet用に外部の画像を~fetchする@
ときは、
所与の
( `url$t %~URL, `CSSStyleSheet$I %sheet )
に対し：
</p>
<ol>
	<li class="algo">
%応答の処理n ~LET 所与の
( `応答$ %応答, ［
~NULL／`失敗^i／~byte~stream
］ %~stream )
に対し，次を走らす手続き
⇒
~IF［
%~stream は~byte~streamである
］
⇒
%~stream から画像を読込む
</li>
	<li>
`~style資源を~fetchする$( %~URL, %sheet, `image^l, `no-cors^l, %応答の処理n )
</li>
</ol>
◎
To fetch an external image for a stylesheet, given a &lt;url&gt; url and CSSStyleSheet sheet, fetch a style resource given url, with stylesheet CSSStyleSheet, destination "image", CORS mode "no-cors", and processResponse being the following steps given response res and null, failure or a byte stream byteStream: If byteStream is a byte stream, load the image from the byte stream.
</div>

		</section>
		<section id="image-set-notation">
<h3 title="Resolution/Type Negotiation: the image-set() notation">2.4. 解像度／型の折衝： `image-set^f 記法</h3>

<p>
利用者の機器に最も適切な解像度の画像を送達することは、
困難な~~仕事にもなり得る。
理想的には、
画像~解像度は，［
利用者~間で様々な，機器それぞれの解像度
］と同じになるべきである。
しかしながら、
どの画像を送信するか裁定する要因になるものは，他にもあり得る
— 例えば，低速な~mobile接続の下では、
利用者は，［
解像度は適正でも，巨大になる画像
］を読込むのを待つより，低-解像度な画像を受信する方を選好するかもしれない。
`image-set@f
関数は、
作者が［
これらの課題のほとんどを無視して、
単純に，ある画像に複数の解像度を供する
］ことにより［
所与の状況で最も適切なものを~UAに裁定してもらう
］ことを許容する。
◎
Delivering the most appropriate image resolution for a user’s device can be a difficult task. Ideally, images should be in the same resolution as the device they’re being viewed in, which can vary between users. However, other factors can factor into the decision of which image to send; for example, if the user is on a slow mobile connection, they may prefer to receive lower-res images rather than waiting for a large proper-res image to load. The image-set() function allows an author to ignore most of these issues, simply providing multiple resolutions of an image and letting the UA decide which is most appropriate in a given situation.
</p>

<p class="issue">
この解決策は、
解像度が~filesizeを代理するものと見做しているので，［
複数の解像度からなる一連の~vector画像／
一連の画像に~vectorと~rasterが混在しているとき（例：~icon）
］を適切に取扱わない。
例えば、［
高-解像度 用には~vector画像,
低-解像度 用には画素に最適化された~bitmap,
低-帯域幅 用には同じ~vector画像（高-解像度であってもずっと小さいので）
］を利用する場合など。
◎
This solution assumes that resolution is a proxy for filesize, and therefore doesn’t appropriately handle multi-resolution sets of vector images, or mixing vector images with raster ones (e.g. for icons). For example, use a vector for high-res, pixel-optimized bitmap for low-res, and same vector again for low-bandwidth (because it’s much smaller, even though it’s higher resolution).
</p>

<p>
`image-set$f の構文は：
◎
The syntax for image-set() is:
</p>

<pre class="prod">
`image-set$ft
	= image-set( `image-set-option$t# )
`image-set-option@t
	= [ `image$t | `string$t ] [ `resolution$t || type(`string$t) ]?
</pre>

<p class="issue">
~HTMLの `picture$e 要素の機能性に合致する可能性として、［
`w^u, `h^u
］次元を追加するべき。
◎
We should add "w" and "h" dimensions as a possibility to match the functionality of HTML’s picture.
</p>

<p>
`image-set$f の内側にある各 `string$t は、
`url$t を表現する。
◎
Each &lt;string&gt; inside image-set() represents a &lt;url&gt;.
</p>

<p>
`image-set$f 関数は、
直接的にも（他の `image$t 型の引数として）間接的にも，入子にできない。
◎
The image-set() function can not be nested inside of itself, either directly or indirectly (as an argument to another &lt;image&gt; type).
</p>

<p>
各 `image-set-option$t は、
`image-set$f 関数が表現する画像としてアリなものを定義し，次に挙げる各部で構成される：
◎
Each &lt;image-set-option&gt; defines a possible image for the image-set() function to represent, composed of three parts:
</p>
<dl class="def-list">
	<dt>
画像~参照
（要求される）
◎
An image reference (required).＼
</dt>
	<dd>
次のいずれかをとり得る
⇒＃
~URL／
~CSSから生成される画像
（ `linear-gradient$f など）
◎
This can be a URL, or a CSS generated image, such as a linear-gradient().
</dd>

	<dt>
`resolution$t
（省略可能）
◎
A &lt;resolution&gt; (optional).＼
</dt>
	<dd>
これは、［
~UAが，どの `image-set-option$t を選ぶか裁定する
］ことを助けるために利用される。
当の画像~参照が~raster画像~用ならば、
画像の`生来な解像度$も指定する
— それは、
`生来な解像度$を給する他の~data~sourceがあっても，それを上書きする。
◎
This is used to help the UA decide which &lt;image-set-option&gt; to choose. If the image reference is for a raster image, it also specifies the image’s natural resolution, overriding any other source of data that might supply a natural resolution.
</dd>
	<dd>
指定されなかった場合、［
どの `image-set-option$t を利用するか選定する目的
］においては， `1x^v として挙動する。
それはまた，画像の`生来な解像度$も`既定の^em `1x^v にするが、
他の何らかの~data~sourceが`生来な解像度$を給する場合，その解像度を尊守するモノトスル。
◎
If not specified, it behaves as 1x for the purpose of selecting which &lt;image-set-option&gt; to use. It also defaults the image’s natural resolution to 1x, but if some other source of data supplies a natural resolution, that resolution must be honored instead.
</dd>

	<dt id="funcdef-image-set-type">
<code class="func">type( `string$t )</code> 関数
（省略可能）
◎
A type( &lt;string&gt; ) function (optional),＼
</dt>
	<dd>
`string$t 内に画像の~MIME型を指定する。
◎
specifying the image’s MIME type in the &lt;string&gt;.
</dd>
	<dd>
`string$t を`妥当な~MIME型$として構文解析した結果が［
妥当でない／
~supportされる画像~形式を指定しない
］場合、
`image-set-option$t は妥当な~optionを定義しない。
（これは、
`image-set$f 関数の妥当性には影響しない。）
◎
If the &lt;string&gt;, when parsed as a valid MIME type string, is either not valid, or is valid but doesn’t specify a supported image format, the &lt;image-set-option&gt; does not define a valid option. (This has no effect on the validity of the image-set() function.)
</dd>
	<dd>
これには、
画像~自体に対する効果は無い。
`url("picture.png") 1x type("image/jpeg")^v
の様な `image-set-option$t は妥当であり、
選ばれた場合
— ~JPEG形式として宣言されていようが —
~link先の~PNG画像を表示することになる。
◎
It does not have any effect on the image itself; an &lt;image-set-option&gt; like url("picture.png") 1x type("image/jpeg") is valid, and if chosen will display the linked PNG image, even though it was declared to be a JPEG.
</dd>
	<dd>
指定されなかった場合、
`image-set-option$t に対する効果は無い。
◎
If not specified, it has no effect on the &lt;image-set-option&gt;.
</dd>
</dl>

<div class="algo">
<p>
`image-set$f 関数は、
1 個以上の `image-set-option$t からなる~listを包含する。
~UAは、
それらのうち 1 つだけを以下に従って選定して，
どの画像を表現するか決定するモノトスル：
◎
An image-set() function contains a list of one or more &lt;image-set-option&gt;s, and must select only one of them to determine what image it will represent:
</p>
<ol>
	<li>
次に該当する `image-set-option$t を~listから除去する
⇒
その `type$f 値にて［
未知な／~supportされない
］~MIME型を指定するもの
◎
First, remove any &lt;image-set-option&gt;s from the list that specify an unknown or unsupported MIME type in their type() value.
</li>
	<li>
次に該当する `image-set-option$t を~listから除去する
⇒
`resolution$t が~list内で それまでに~~現れた `image-set-option^t のそれと同じであるもの
◎
Second, remove any &lt;image-set-option&gt;s from the list that have the same &lt;resolution&gt; as a previous option in the list.
</li>
	<li>
~IF［
~listは空である
］
⇒
`image-set$f 関数は、
`無効な画像$を表現する。
◎
If there are no &lt;image-set-option&gt; left at this point, the function represents an invalid image.
</li>
	<li>
~ELSE
⇒
~list内の `image-set-option$t たちから、
何であれ［
関連するものと判断される，~UAに特有な判定基準
］に基づいて（例：~displayの解像度, 接続~速度, 等々），読込むものを一つ選ぶ
— `image-set$f 関数は、
ここで選んだ `image-set-option^t の `image$t を表現する。
◎
Finally, among the remaining &lt;image-set-option&gt;s, make a UA-specific choice of which to load, based on whatever criteria deemed relevant (such as the resolution of the display, connection speed, etc).
◎
The image-set() function then represents the &lt;image&gt; of the chosen &lt;image-set-option&gt;.
</li>
</ol>
</div>

<p>
~UAは、
~pageの存続期間において［
所与の `image-set$f 用に利用する `image-set-option$t
］を<strong>変更してもヨイ</strong>
— どの `image-set-option^t を選ぶか決定するために利用した判定基準が，
~UAの見積もりにおいて変更に価する程に十分~変化したならば。
◎
UAs may change which &lt;image-set-option&gt; they wish to use for a given image-set() over the lifetime of the page, if the criteria used to determine which option to choose change significantly enough to make it worthwhile in the UA’s estimation.
</p>

<div class="example">
<p>
次の例に、
`image-set$f を利用して 3 種の画像
— “通常”, “高-解像度”, “極高-解像度”
（高-品質な印刷~用 — 印刷機には解像度が `極めて^em高いものもあるので） —
を供する方法を示す：
◎
This example shows how to use image-set() to provide an image in three versions: a "normal" version, a "high-res" version, and an extra-high resolution version for use in high-quality printing (as printers can have extremely high resolution):
</p>

<pre class="lang-css">
background-image: image-set(
    "foo.png" 1x,
    "foo-2x.png" 2x,
    "foo-print.png" 600dpi
);
</pre>
</div>

<div class="example">
<p>
`type$f 関数を利用して，同じ画像を成す複数の~version
— 新しい, より高-品質な形式，および より旧い, より広く~supportされる形式 —
を~serveする例を次に示す：
◎
This example shows use of the type() function to serve multiple versions of the same image in both new, higher-quality formats, and older, more widely-supported formats:
</p>

<pre class="lang-css">
background-image: image-set(
    "foo.avif" type("image/avif"),
    "foo.jpg" type("image/jpeg")
);
</pre>

<p>
~AVIF画像を最初に与えていることに注意。
両~画像とも解像度は同じなので
（未指定なので，既定の `1x^v になる）、
後に与えた~JPEG画像は，~AVIF画像を~supportする~UAにおいては自動的に落とされる。
◎
Note that the AVIF image is given first; since both images have the same resolution (defaulting to 1x since it’s unspecified), the JPEG image, coming second, is automatically dropped in UAs that support AVIF images.
</p>

<p>
しかしながら，より旧い~UAにおいては、
~AVIF画像は無視され
（~UAは、
`image/avif^l から~fileを~supportしないと知るので），
代わりに~JPEGが選ばれる。
◎
In older UAs, however, the AVIF image is ignored (because the UA knows it doesn’t support "image/avif" files), and so the JPEG is chosen instead.
</p>
</div>

<div class="example">
<p>
~raster画像は、
~vector画像, あるいは~CSSから生成された画像とも混在できる。
◎
Raster images can be mixed with vector images, or even CSS generated images.
</p>

<p>
例えば，次の~code片では、［
~~十分表現可能な~screen上では，微妙な詳細を伴う高-解像度な画像が利用される
］一方で［
低-解像度な状況~用には，普通の~CSS `linear-gradient$f が利用される
］：
◎
For example, in this code snippet a high-resolution image with subtle details is used on screens that can do it justice, while an ordinary CSS linear-gradient() is used instead for low-resolution situations:
</p>

<pre class="lang-css">
background-image: image-set(
    linear-gradient(cornflowerblue, white) 1x,
    url("detailed-gradient.png") 3x
);
</pre>
</div>

		</section>
		<section id="image-notation">
<h3 title="Image Fallbacks and Annotations: the image() notation">2.5. 画像~fallbackと注釈： `image^f 記法</h3>

<p>
`image$f 関数により、
作者は次が可能になる：
◎
The image() function allows an author to:
</p>

<ul>
   <li>
`媒体~素片$を利用して、
画像の一部分を切抜く。
◎
use media fragments to clip out a portion of an image
</li>
	<li>
単色を画像として利用する。
◎
use a solid color as an image
</li>
	<li>
指定された URL にある画像が［
~downloadできない, または復号できない
］ときの，単色~画像への~fallbackを指定する。
◎
fallback to a solid-color image, when the image at the specified url can’t be downloaded or decoded
</li>
	<li>
画像の~metadataに指定されている画像の方位に，自動的に従うようにする。
◎
automatically respect the image orientation specified in the image’s metadata
</li>
</ul>

<p>
`image$f 記法は，次で定義される：
◎
The image() notation is defined as:
</p>

<pre class="prod">
`image@f
	= image( `image-tags$t? [ `image-src$t? , `color$t? ]! )
`image-tags@t
	= ltr
	| rtl
`image-src@t
	= `url$t
	| `string$t
</pre>

<p>
`image$f 内で利用される `string$t は、
`url$t を表現する。
CSS における通例の~URLと同じく、
`image$f 値に指定された相対~URLは，算出d値を得るときに
（ “値と単位” 仕様 `CSS-VALUES-3$r に従って）
絶対~URLに解決される。
◎
A &lt;string&gt; used in image() represents a &lt;url&gt;. As usual for URLs in CSS, relative URLs are resolved to an absolute URL (as described in Values &amp; Units [CSS-VALUES-3]) when a specified image() value is computed.
</p>

<p>
EXIF などの画像の~metadata内に，方位が指定されている場合、
~UAは，その~metadataの指定に従って［
画像を回転させたり裏返して，正しく方位させる
］モノトスル。
◎
If the image has an orientation specified in its metadata, such as EXIF, the UA must rotate or flip the image to correctly orient it as the metadata specifies.
</p>

			<section id="image-fallbacks">
<h4 title="Image Fallbacks">2.5.1. 画像の~fallback</h4>

<p>
`image$f 関数に~URLが指定されていて，~URLが［
`無効な画像$／`読込n中の画像$
］を表現するときは、
その関数は：
◎
↓</p>
<ul>
	<li>
`color$t も指定されていた場合、
~URLが元々指定されていなかったかのように
`単色~画像＠#color-images$を描画する。
◎
If both a URL and a &lt;color&gt; are specified in image(), then whenever the URL represents an invalid image or loading image, the image() function renders as if the URL were not specified at all; it generates a solid-color image as specified in § 2.5.3 Solid-color Images.
</li>
	<li>
他の場合、
同じ［
`無効な画像$／`読込n中の画像$
］を表現する。
◎
If just a URL is specified (no &lt;color&gt;) and it represents an invalid image or loading image, the image() function represents the same.
</li>
</ul>

<div class="example">
<p>
~fallback色を利用すれば、
画像の読込nに失敗したときでも，少なくとも~textは読めるようになる。
例えば次の旧来~codeは、
画像が透明度を持たない矩形であれば，~~問題なく働く。
◎
The fallback color can be used to ensure that text is still readable even when the image fails to load. For example, the following legacy code works fine if the image is rectangular and has no transparency:
</p>

<pre class="lang-css">
body      { color: black; background: white; }
p.special { color: white; background: url("dark.png") black; }
</pre>

<p>
画像が読込めなくても、
背景~色により，依然として白な~textは読める。
しかしながら，画像に透明度がある場合、
背後の黒が可視になり，おそらく欲されない結果になる。
`image$f 関数は、
これに取組む：
◎
When the image doesn’t load, the background color is still there to ensure that the white text is readable. However, if the image has some transparency, the black will be visible behind it, which is probably not desired. The image() function addresses this:
</p>

<pre class="lang-css">
body      { color: black; background: white; }
p.special { color: white; background: image("dark.png", black); }
</pre>

<p>
今度は、
画像を読込めたときには黒はまったく現れなくなる一方、
何らかの理由で画像の読込nに失敗した場合には黒がそれに代わり，
白な背景に白な~textが設定されるのを防げる。
◎
Now, the black won’t show at all if the image loads, but if for whatever reason the image fails, it’ll pop in and prevent the white text from being set against a white background.
</p>

</div>

			</section>
			<section id="image-fragments">
<h4 title="Image Fragments">2.5.2. 画像~断片</h4>

<p>
`image$f に指定された~URLが，
（例：`媒体~素片~識別子$の利用により）
資源の一部分を表現するとき、
その一部分は，その文脈から切抜かれた上で，自立的な画像として利用されるようになる。
◎
When a URL specified in image() represents a portion of a resource (e.g. by the use of media fragment identifiers) that portion is clipped out of its context and used as a standalone image.
</p>

<div class="example">
<p>
例えば，次の画像と~CSSが与えられたとする：
◎
For example, given the following image and CSS:
</p>

<figure>
<p class="alt" hidden id="_dgm-sprites">
黒な部分が次第に増える 9 個の円
◎
[9 circles, with 0 to 8 eighths filled in]
</p>
</figure>

<pre class="lang-css">
background-image: image('sprites.svg#xywh=80,0,40,40')
</pre>

<p>
要素の背景は、
この画像の， ( 80px, 0px ) の所から，右下へ高さ幅ともに 40px の部分
（画像の中では黒な四分円）
で埋尽くされることになる。
◎
...the background of the element will be the portion of the image that starts at (40px,0px) and is 20px wide and tall, which is just the circle with a quarter filled in.
</p>

</div>

<p>
作者が［
~CSSの前方-互換な構文解析~規則の利点を活かして，画像~slice用の~fallbackを供せる
］ようにするため、
`image$f 記法を~supportする実装は，［
`image$f を介して指定された画像
］用には［
`xywh=<var>#,#,#,#</var>^c 形による`媒体~素片~識別子$ `MEDIA-FRAGS$r
］を~supportする`モノトスル^em。
◎
So that authors can take advantage of CSS’s forwards-compatible parsing rules to provide a fallback for image slices, implementations that support the image() notation must support the xywh=#,#,#,# form of media fragment identifiers for images specified via image(). [MEDIA-FRAGS]
</p>

<div class="example">
<p>
画像~断片は `url$f 記法でも利用し得ることに注意。
しかしながら、
`媒体~素片$ 記法を解せない旧来の~UA は，［
素片を無視して，単純に画像~全体を表示する
］ことになる。
◎
Note that image fragments can also be used with the url() notation. However, a legacy UA that doesn’t understand the media fragments notation will ignore the fragment and simply display the entirety of the image.
</p>

<p>
`image$f 記法は，~UAによる`媒体~素片$の~supportを要するので、
作者は，画像~素片~URLを利用するときに［
~fallbackを供する~CSSの前方-互換な構文解析~規則
］の利点を活かせる：
◎
Since the image() notation requires UAs to support media fragments, authors can take advantage of CSS’s forward-compatible parsing rules to provide a fallback when using an image fragment URL:
</p>

<pre class="lang-css">
background-image: url('swirl.png'); /* 旧~UA */
background-image: image('sprites.png#xywh=10,30,60,20'); /* 新~UA */
</pre>

</div>

<p>
~URLに利用されている素片~識別子の構文が［
実装が解せない／当の画像~型において妥当でない
］場合、
その~URLは，`無効な画像$を表現しているものと扱うモノトスル。
◎
If a URL uses a fragment identifier syntax that the implementation does not understand, or does not consider valid for that type of image, the URL must be treated as representing an invalid image.
</p>

<p class="note">注記：
旧来との互換性の理由から、
この~errorの取扱いは，
~URL【そのもの】の定義ではなく， `image$f 【の中の~URL】に限られる。
◎
Note: This error-handling is limited to image(), and not in the definition of URL, for legacy compat reasons.
</p>

			</section>
			<section id="color-images">
<h4 title="Solid-color Images">2.5.3. 単色~画像</h4>

<p>
`image$f 関数の引数に（~URLなしで） `color$t のみが指定された場合、
`生来な寸法$を伴わない，指定された色による単色~画像を表現する。
◎
If the image() function is specified with only a &lt;color&gt; argument (no URL), it represents a solid-color image of the specified color with no natural dimensions.
</p>

<div class="example">
<p>
例えば，これを、
他の画像の上層に半透明な色を重ねて背景~画像を “淡く染める” 単純な仕方として利用できる：
◎
For example, one can use this as a simple way to "tint" a background image, by overlaying a partially-transparent color over the top of the other image:
</p>

<pre class="lang-css">
background-image: image(rgba(0,0,255,.5)), url("bg-image.png");
</pre>

<p>
`background-color$p は、
これに対しては働かない。
それが生成する単色は、
常に，すべての背景~画像の`~~背後に回る^emので。
◎
background-color does not work for this, as the solid color it generates always lies beneath all the background images.
</p>

</div>

			</section>
			<section id="bidi-images">
<h4 title="Bidi-sensitive Images">2.5.4. 双向性に応じる画像</h4>

<p>
作者は、
`image$f 内の `image-src$t の前に、画像~用の方向性（ `image-tags$t ）を指定してもヨイ
— これは、
~HTML要素に `dir$a 属性を追加するのに類似する。
［
要素に対し／要素~内で
］逆~方向の `direction$p を伴う画像が利用された場合、
その画像は，行内~方向に裏返されるモノトスル
（行内~方向が X 軸なら、
例えば `scaleX(-1)^v で変形されたかのように）。
◎
Before listing any &lt;image-src&gt;s, the author may specify a directionality for the image, similar to adding a dir attribute to an element in HTML. If a directional image is used on or in an element with opposite direction, the image must be flipped in the inline direction (as if it was transformed by, e.g., scaleX(-1), if the inline direction is the X axis).
</p>

<p class="note">注記：
この宣言が無い場合の既定では、
画像の方向性はまったくないので，周囲の要素の方向性にも応じない。
◎
Note: Absent this declaration, images default to no directionality at all, and thus don’t care about the directionality of the surrounding element.
</p>

<div class="example">
<p>
~listが~bulletとして［
内容の中を指す矢印
］を利用していて，［
左横書きの~textを包含する~list~item,
右横書きのそれ
］が混在している場合、
~bulletは，左端にも右端にも生じる。
その結果、
一方の側では~textの中を指すよう設計された画像は，他方の側では~textの外を指すことになる。
これは、
次の様な~codeで修正できる：
◎
A list may use an arrow for a bullet that points into the content. If the list can contain both LTR and RTL text, though, the bullet may be on the left or the right, and an image designed to point into the text on one side will point out of the text on the other side. This can be fixed with code like:
</p>

<pre class="lang-html">
&lt;ul style="list-style-image: image(ltr 'arrow.png');"&gt;
  &lt;li dir='ltr'&gt;左に~bulletがあります。&lt;/li&gt;
  &lt;li dir='rtl'&gt;~bulletは右にあります。&lt;/li&gt;
&lt;/ul&gt;
</pre>
<!-- 
My bullet is on the left!
MY BULLET IS ON THE RIGHT!
 -->

<p>
これは次の様に描画されるべきである：
◎
This should render something like:
</p>

<pre class="lang-html">
☞ 左に~bulletがあります。
  。すまりあに右は~tellub ☜
</pre>
<!-- 
☞ My bullet is on the left!
  !THGIR EHT NO SI TELLUB YM ⇐
-->

<p class="trans-note">【
便宜上，日本語で記しているが、
実際には，右横書きの言語でなければ、
このように左方へ流れる表示にはならない。
】</p>

<p>
左横書き~list~itemにおいては，画像はそのまま利用され、
右横書き~list~itemにおいても内容を指すように，画像は行内~方向に裏返されることになる。
◎
In LTR list items, the image will be used as-is. In the RTL list items, however, it will be flipped in the inline direction, so it still points into the content.
</p></div>

			</section>
		</section>
		<section id="cross-fade-function">
<h3 title="Combining images: the cross-fade() notation">2.6. 画像を組合せる： `cross-fade^f 記法</h3>

<p>
~CSSにより 2 個の画像~間の遷移を与えるためには、［
開始-, 終止-
］画像を組合せた中間的な画像を明示的に指す仕方を要する。
`cross-fade$f 関数が、
これを達成する。
それは、
組合される 2 個の画像, および
組合nの遷移の進行度合いを指示する。
◎
When transitioning between images, CSS requires a way to explicitly refer to the intermediate image that is a combination of the start and end images. This is accomplished with the cross-fade() function, which indicates the two images to be combined and how far along in the transition the combination is.
</p>

<p class="note">注記：
作者は、
`cross-fade$f 関数を，多くの単純な画像~操作にも利用できる
— 画像を単色で淡く染めたり、
`放射型~gradient$と組合せて，~page内の特定0の区画を強調するなど。
◎
Note: Authors can also use the cross-fade() function for many simple image manipulations, such as tinting an image with a solid color or highlighting a particular area of the page by combining an image with a radial gradient.
</p>

<p>
`cross-fade^f の構文は、
次で定義される：
◎
The syntax for cross-fade() is defined as:
</p>

<pre class="prod">
`cross-fade@f
	= cross-fade( `cf-image$t# )
`cf-image@t
	= [ `image$t | `color$t ] &amp;&amp; `percentage [0,100]$t?
</pre>

<p>
この関数は、
1 個~以上の画像を組合せて生成される画像を表現する。
◎
The function represents an image generated by combining one or more images.
</p>

<p>
各~画像の `percentage$t は、
その画像が他の画像と混色されたときの含有率を表現する。
`percentage$t 値は、
`0%^v 以上 `100%^v 以下でなければナラナイ
— 他の値は無効とする。
◎
The &lt;percentage&gt; represents how much of each image is retained when it is blended with the other images. The &lt;percentage&gt; must be between 0% and 100% inclusive; any other value is invalid.
</p>

<p>
百分率が省略された画像がある場合、
`100%^v から［
他の画像に指定されたすべての百分率の総和
］を減算してから `0%^v 以上に切り上げた結果が，算出d値の時点で［
省略された百分率を伴うすべての画像
］に等分にあてがわれる。
【`実際の~algo＠#cross-fade-painting$／下の注記と食い違う？】
◎
If any percentages are omitted, all the specified percentages are summed together and subtracted from 100%, the result is floored at 0%, then divided equally between all images with omitted percentages at computed-value time.
</p>

<div class="note">

<p>注記：
これは，算出d値には反映されないが、
すべての引数の百分率の総和が `100%^v を超えるときは
— ［
~sizing／塗ng
］の詳細~にて —
実質的に，総和が正確に `100%^v になるよう各 引数は拡縮し直される。
◎
While this is not reflected in the computed value, when all the arguments’ percentages sum to greater than 100%, the sizing/painting details effectively rescale them so that they sum to exactly 100%.
</p>

<p>
他方，総和が `100%^v 以下のときは
— ［
~sizing／塗ng
］の詳細~にて —
実質的に，［
百分率が［
総和が `100%^v に等しくなるために必要yな残りの値
］に設定され，`透明な黒$にされた `cf-image$t【！ `transparent$v 引数】
］が追加されたかの様に動作する。
◎
On the other hand, when the sum is less than 100%, the sizing/painting details effectively act like there’s an additional transparent argument, with its percentage set to the remaining value necessary to make the sum equal 100%.
</p>

</div>

<p>
`color$t が供された場合、
それは “自動的”な寸法を伴う単色~画像を表現する
（それは、
結果の画像の~sizingにはまったく関与しない
— 詳細は下の~sizingを見よ）。
◎
If a &lt;color&gt; is provided, it represents a solid-color image with “automatic” dimensions (it doesn’t participate in the sizing of the result image at all; see details in the sizing details below).
</p>

			<section id="cross-fade-sizing">
<h4 title="cross-fade() Sizing">2.6.1. `cross-fade^f の~sizing</h4>

<p>
`cross-fade$f が表現する画像の寸法は、
関数の各 `image$t 引数の寸法の加重d平均になる
— `color$t 引数には効果は無い。
それは、
以下に従って計算される。
◎
The dimensions of the image represented by a cross-fade() are a weighted average of dimensions of the &lt;image&gt; arguments to the function; the &lt;color&gt; arguments have no effect. They are calculated as follows:
</p>

<p class="trans-note">【
以下に現れる百分率は，
`cf-image$t を成す `percentage^t としか解釈しようがないが、
それは，混色-用の重みであり、
寸法の計算に利用されるのは不可解。
】</p>

<div class="algo">
<p>
`cross-fade$f の
<dfn id="natural-dimensions-of-a-cross-fade">`生来な寸法$を決定する</dfn>
ときは：
◎
To determine the natural dimensions of a cross-fade():
</p>

<ol>
	<li>
%画像~list ~LET 新たな`~list$
◎
Let images be an empty list.
</li>
	<li>
<p>
`cross-fade$f 関数の
~EACH( `image$t 値を伴う引数 %引数 )
に対し：
◎
For each argument of the cross-fade() function with an &lt;image&gt; value:
</p>
		<ol>
			<li>
%~item ~LET
( `横幅^i, `縦幅^i, `百分率^i )
からなる`~tuple$
◎
Let item be a tuple consisting of a width, a height, and a percentage.
</li>
			<li>
%~item の ( `横幅^i, `縦幅^i ) ~SET ［
%引数 の `image$t に対し， `cross-fade$f が現れる文脈に適切に`~obj~size折衝$ ~algoを走らせた結果
］の`具象-~obj~size$の ( 横幅, 縦幅 )
◎
Run the object size negotiation algorithm for the &lt;image&gt;, as appropriate for the context in which the cross-fade() appears, and set item’s width and height to the width and height of the resulting concrete object size.
</li>
			<li>
%~item の`百分率^i ~SET %引数 の百分率
◎
Set item’s percentage to the argument’s percentage.
</li>
			<li>
【 %画像~list に %~item を`付加する$ 】
</li>
		</ol>
	</li>
	<li>
~IF［
%画像~list は`空$である
］
⇒
~RET ε
（`生来な寸法$は無い）
◎
If images is empty, return no natural dimensions.
</li>
	<li>
%百分率の総和 ~LET %画像~list 内のすべての`~item$の`百分率^iの総和
◎
Let percentage sum be the sum of all the percentages of the items in images.
</li>
	<li>
%画像~list を成す
~EACH( %~item )
に対し
⇒
%~item の百分率 ~SET %~item の`百分率^i ~DIV %百分率の総和
◎
For each item in images, divide item’s percentage by percentage sum, and set item’s percentage to the result.
</li>
	<li>
~Assert：
%画像~list 内の`百分率^iの総和 ~EQ `100%^v 
◎
Assert: The percentages in images now sum to 100%.
</li>
	<li>
( %最終-横幅, %最終-縦幅 ) ~LET ( `0px^v, `0px^v )
◎
Let final width and final height be 0px.
</li>
	<li>
%画像~list を成す
~EACH( %~item )
に対し
⇒＃
%最終-横幅 ~INCBY %~item の`横幅^i ~MUL %~item の`百分率^i；
%最終-縦幅 ~INCBY %~item の`縦幅^i ~MUL %~item の`百分率^i
◎
For each item in images, multiply item’s width by item’s percentage and add the result to final width, and multiply item’s height by item’s percentage and add the result to final height.
</li>
	<li>
~RET `生来な寸法$( `生来な横幅$ %最終-横幅, `生来な縦幅$ %最終-縦幅 )
◎
Return a natural width of final width and a natural height of final height.
</li>
</ol>
</div>

			</section>
			<section id="cross-fade-painting">
<h4 title="cross-fade() Painting">2.6.2. `cross-fade^f の塗ng</h4>

<p>
`cross-fade$f が表現する画像は、
関数に与えられた引数たちの加重d平均であり，以下に従って計算される：
◎
The image represented by a cross-fade() is a weighted average of the input arguments to the function, calculated as follows:
</p>

<div class="algo">
<p>
`cross-fade^f の
`外観を決定する@
ときは：
◎
To determine the appearance of a cross-fade():
</p>
<ol>
	<li>
%画像~list ~LET 新たな`~list$
◎
Let images be an empty list.
</li>
	<li>
<p>
%~size ~LET
`生来な寸法を決定する$手続きを利用して `cross-fade$f 関数の`具象-~obj~size$を見出した結果
</p>
<p class="trans-note">【
`cross-fade^f 関数のどの引数も `image$t を伴わない場合、
手続きは ε を返すことになる。
その場合にどうなるかは、
ここには述べられていない
（`既定の~obj~size$と見做される？）。
】</p>
◎
Let size be a tuple of width and height, initialized to the result of finding the concrete object size of the cross-fade() function (using the natural dimensions of a cross-fade()).
</li>
	<li>
<p>
`cross-fade$f 関数の
~EACH( %引数 )
に対し：
◎
For each argument of the cross-fade() function:
</p>
		<ol>
			<li>
%~item ~LET
( `画像^i, `百分率^i )
からなる`~tuple$
◎
Let item be a tuple consisting of an image and a percentage.
</li>
			<li>
~IF［
%引数 は `image$t 値を伴う
］
⇒
%~item の`画像^i ~SET その `image^t 画像を %~size に拡縮し直した結果 
◎
If argument has an &lt;image&gt;, rescale it to size’s width and height and set item’s image to the result.＼
</li>
			<li>
~ELSE
（ %引数 は `color$t 値を伴う）
⇒
%~item の`画像^i ~SET
寸法 %~size の，その `color^t の単色~画像
◎
Otherwise, argument has a &lt;color&gt;; set item’s image to a solid-color image of the &lt;color&gt;, with size’s dimensions.
</li>
			<li>
%~item の`百分率^i ~SET %引数 の百分率
【無い場合は？】
◎
Set item’s percentage to the argument’s percentage.
</li>
			<li>
【 %画像~list に %~item を`付加する$ 】
</li>
		</ol>
	</li>
	<li>
%百分率の総和 ~LET %画像~list を成すすべての`~item$の`百分率^iの総和
◎
Let percentage sum be the sum of all the percentages of the items in images.
</li>
	<li>
~IF［
%百分率の総和 ~LT 100%
］
⇒
%画像~list に次のようにされた`~tuple$を付加する
⇒＃
`画像^i ~SET 寸法 %~size の`透明な黒$にされた単色~画像,
`百分率^i ~SET 100% ~MINUS %百分率の総和
◎
If percentage sum is less than 100%, append a tuple to images consisting of a solid-color transparent-black image with size’s dimensions, and a percentage equal to 100% minus percentage sum.
</li>
	<li>
~ELIF［
%百分率の総和 ~GT 100%
］
⇒
%画像~list を成す
~EACH( %~item )
に対し
⇒
%~item の`百分率^i ~SET %~item の百分率 ~DIV %百分率の総和
◎
Otherwise, if percentage sum is greater than 100%, then for each item in images, divide item’s percentage by percentage sum, and set item’s percentage to the result.
</li>
	<li>
<div>
<p>
~RET 次のようにされた画像：
</p>
		<ul>
			<li>
寸法 %~size
</li>
			<li>
各 画素は［
%画像~list 内の各 %~item の`画像^iの，対応する画素
］たちに対し，
%~item の百分率を重みに用いて線型~加重d平均をとった結果
（色~channel, ~alpha~channelとも平均をとる）
</li>
		</ul>
◎
Let final image be an image with size’s dimensions, and every pixel being the weighted linear average of the corresponding pixels of each item’s image in images, weighted according to the item’s percentage. (Average both the color channels and the alpha channel of the pixels.)＼
</div>
<p>
この段の目的においては、
各~画素の色は乗算済み~sRGB空間で計算するモノトスル。
◎
For the purpose of this calculation, each pixel’s color must be in pre-multiplied sRGB.
</p>

<details class="note">
<summary class="L">
上の演算の詳細
◎
Details on the above operation
</summary>
<p>
これは、
~source画像たちに `N-way Porter-Duff dissolve^en 演算を適用することに等しい。
Wikipedia によれば、
これは，確率的な演算【`参考＠https://en.wikipedia.org/wiki/Stochastic_computing$】として定義される
— すなわち，結果の画素は、
~source画像たちの対応する画素から，
画素ごとに独立に, ~source画像の重みに則って, ~randomに選ばれる。
これは、
画素を無限に小さく縮める伴い，
乗算済み色~空間~内で色の平均をとることに収束する。
◎
This is applying an N-way Porter-Duff dissolve operation to the source images. Wikipedia defines dissolve as a stochastic operation, with the result pixels independently randomly chosen from the source images’ corresponding pixels according to their source images’ weights, but as pixels shrink to infinitely small, this converges to doing color-averaging in pre-multiplied color space.
</p>

<p>
特に，このことは、
`cross-fade(white 50%, transparent 50%)^v
は，半透明な白による単色~画像を生産することを意味する。
（半透明な灰色ではなく
— それは、
不透明な白と透明な黒な画素を乗算済みでない空間で平均した場合に取得されるものである。）
◎
In particular, this means that `cross-fade(white 50%, transparent 50%)` will produce a partially-transparent solid white image. (Rather than a partially-transparent gray, which is what you’d get if you averaged the opaque white and transparent black pixels in non-premultiplied space.)
</p>

<p>
乗算済みに変換すると精度がいくぶん失われることに加え、
~graphics~libraryは，この演算を~nativeに~supportするとは限らない。
通例どおり、
指定された効果が達成される限り，どの~methodでも利用できる。
◎
As converting to pre-multiplied does entail some loss of precision, and graphics libraries may or may not support this operation natively, as per usual any method can be used so long as it achieves the specified effect.
</p>

<p>
例えば，代わりに、
百分率を各~画素の~alphaに則って~~配分し直してから，
色~channelを乗算済みでない空間~内で平均できる。
例：
`cross-fade(rgb(255 0 0 / 1) 40%, rgb(0 255 0 / .5) 20%, rgb(0 0 255 / 0) 40%)^v
を描画するためには、
百分率を~alpha［
`1^v ／ `.5^v ／ `0^v
］に則って~~配分し直す
— これは［
`40%^v ／ `10%^v ／ `0%^v
］を生産することになる【なぜそうなる？】
（これは［
`80%^v ／ `20%^v ／ `0%^v
］に正規化し直される）。
この時点で，生の色~channel値を平均でき、
その結果は `rgb(204 51 0 / .5)^v を伴う画像になる。
（それでも、
~alpha~channelは，［
~~配分し直された百分率ではなく，元の百分率
］を利用して平均されることに注意。）
◎
For example, one can instead rebalance the percentages according to the alphas of each pixel, then do the color-channel averages in non-premultiplied space. E.g., to render cross-fade(rgb(255 0 0 / 1) 40%, rgb(0 255 0 / .5) 20%, rgb(0 0 255 / 0) 40%), rebalancing the percentages according to the 1 / .5 / 0 alphas would produce 40% / 10% / 0% (which renormalizes to 80% / 20% / 0%), at which point you can average the raw color channel values and end up with an rgb(204 51 0 / .5) image. (Note that the alpha channel is still averaged using the original percentages, not the rebalanced ones.)
◎
↑↑Return final image.
</p>
</details>

	</li>
</ol>
</div>

			</section>
			<section id="cross-fade-complex">
<h4 title="Simplifying Complex cross-fade()">2.6.3. 複階的な `cross-fade^f の単純~化</h4>

<p class="issue">
~WGによる解決にしたがって、
画像~用に “同等性” の観念を定義し，
“同じ” 画像たちは算出d値の時点で百分率の総和をとって結合する。
◎
Per WG resolution, define a notion of "equality" for images, and combine "same" images at computed-value time, summing their percentages.
</p>

<p class="issue">
~WGによる解決にしたがって、
直に入子にされた `cross-fade$f は［
算出d値の時点で，単に百分率を分配して平坦~化する
］よう単純~化する
— `cross-fade(A 10%, cross-fade(B 30%, C 70%) 90%)^v は
`cross-fade(A 10%, B 27%, C 63%)^v になるように。
◎
Per WG resolution, simplify directly-nested cross-fade() at computed-value time by just distributing the percentage and flattening; cross-fade(A 10%, cross-fade(B 30%, C 70%) 90%) becomes cross-fade(A 10%, B 27%, C 63%).
</p>

			</section>
		</section>
		<section id="element-notation">
<h3 title="Using Elements as Images: the element() notation">2.7. 要素を画像として利用する： `element^f 記法</h3>

<p>
`element$f 関数により、
作者は，文書~内の要素を画像として利用することが可能になる。
参照先の要素の外観が変化するに伴い，画像も変化するようになる。
これを利用すれば，例えば、
~slideshowにおける［
次／前
］の~slideの~live~previewを作成したり，
~fancyな~gradientを生成するために `canvas$e 要素を参照したり，
背景を~animate化することさえ可能になる。
◎
The element() function allows an author to use an element in the document as an image. As the referenced element changes appearance, the image changes as well. This can be used, for example, to create live previews of the next/previous slide in a slideshow, or to reference a canvas element for a fancy generated gradient or even an animated background.
</p>

<p class="note">注記：
`element$f 関数が再生産するのは、
参照先の要素の`外観^emに限られ，実際の内容やその構造を再生産することはない。
作者は、
装飾的な目的に限り，これを利用するべきである。
`element$f を，~pageにまたがる有意な内容を伴う要素を再生産するために利用してはナラナイ
— 代わりに、
単に文書の中に要素の複数の複製を挿入すること。
◎
Note: The element() function only reproduces the appearance of the referenced element, not the actual content and its structure. Authors should only use this for decorative purposes, and must not use element() to reproduce an element with significant content across the page. Instead, just insert multiple copies of the element into the document.
</p>

<p>
`element$f の構文は、
次で与えられる：
◎
The syntax for element() is:
</p>

<pre class="prod">
`element@f
	= element( `id-selector$t )
</pre>

<p>
ここで `id-selector$t は`~ID選択子$である。
`SELECT$r
◎
where &lt;id-selector&gt; is an ID selector [SELECT].
</p>

<p class="issue">
外部~文書~内の要素（~SVGの`塗り~server$など）を参照rできるようにする必要はあるか？
あるいは、
この用途には `url^f を利用するだけで十分か？
◎
Do we need to be able to refer to elements in external documents (such as SVG paint servers)? Or is it enough to just use url() for this?
</p>

<p class="issue">
この名前は、
GCPM† のいくぶん類似な関数と競合する。
これはどうにかして解決される必要がある。
【† `CSS Generated Content for Paged Media Module^en（~page媒体~用の生成d内容）】
◎
This name conflicts with a somewhat similar function in GCPM. This needs to be resolved somehow.
</p>

<p class="issue">
要素の “反映” を行う能が求まれる
— 要素~上の背景~画像として, または疑似要素~内で。
循環の検出を誘発するのを避けるため、
これは特別に取扱われる必要がある。
◎
Want the ability to do "reflections" of an element, either as a background-image on the element or in a pseudo-element. This needs to be specially-handled to avoid triggering the cycle-detection.
</p>

<p class="issue">
`overflow^p が `paged^v にされている~view内の単独の~pageにはどう取組むか？
◎
When we have overflow:paged, how can we address a single page in the view?
</p>

<p>
`element$f 関数は、
その引数に与えた~IDに合致する要素を参照する。
~IDは、
先ず `elementSources$m ~map内で検索される。
見出されなかった場合、
文書【内の要素】に対し照合される
— 合致した要素が複数ある場合、
関数は，それらのうち最初の要素を参照する。
◎
The element() function references the element matched by its argument. The ID is first looked up in the elementSources map, as described in that section. If it’s not found, it’s then matched against the document. If multiple elements are matched, the function references the first such element.
</p>

<p>
`element$f 関数により表現される画像は、
要素が文書~内で可視かどうかに基づいて変わり得る：
◎
The image represented by the element() function can vary based on whether the element is visible in the document:
</p>

<dl>
	<dt>
要素は`描画され$ていて，`置換d要素$の子孫ではない, かつ`積層~文脈$を生成する場合：
◎
an element that is rendered, is not a descendant of a replaced element, and generates a stacking context
</dt>
	<dd>
<p>
関数は、
`生来な~size$が参照先の要素の
`装飾d限界~box@
に等しい画像を表現する：
◎
The function represents an image with its natural size equal to the decorated bounding box of the referenced element:
</p>
		<ul>
			<li>
~CSS描画~modelを利用して描画される要素に対しては、
`装飾d限界~box$は，［
`首要~box$のすべての断片の`~border画像~区画$を包含する, かつ軸に~~平行
］な最も小さい矩形になる。
◎
for an element rendered using a CSS rendering model, the decorated bounding box is the smallest axis-aligned rectangle that contains the border image areas of all the fragments of the principal box
</li>
			<li>
~SVG描画~modelを利用して描画される要素に対しては、
`装飾d限界~box$は，
`~SVGにより定義されるそれ＠~SVGcoords#TermDecoratedBoundingBox$になる。
【！~TR/SVGTiny12/intro.html#TermDecoratedBoundingBox】
【大雑把に言えば，外形線の太さも含め，図形~全体を囲う最~小な矩形】
◎
for an element rendered using the SVG rendering model, the decorated bounding box is defined by SVG
</li>
		</ul>

<p class="note">注記：
画像の限界域の外側にあるものは既定で切取られるので、
~box影の様な`装飾d限界~box$の外側へ拡張する装飾は，
切取られることになる。
◎
Note: Because images clip anything outside their bounds by default, this means that decorations that extend outside the decorated bounding box, like box shadows, may be clipped.
</p>

	</dd>
	<dd>
画像は、［
広さ無限で`透明な黒$にされた~canvas
］上に［
参照先の要素とその子孫
］を描画して構築され
（文書~内にあるときの~sizeと同じになる），［
`装飾d限界~box$の各~辺が画像の各~辺に接合される
］ように位置される。
◎
The image is constructed by rendering the referenced element and its descendants (at the same size that they would be in the document) over an infinite transparent canvas, positioned so that the edges of the decorated bounding box are flush with the edges of the image.
</dd>
	<dd class="issue">
実装を効率的にするためには、
要素には積層~文脈またはそれに準じるものが要求されるよう見受けられる。
全部的な積層~文脈は必要か？
あるいは疑似的な積層~文脈で済むか？
それは通常の積層~文脈になる必要はあるか？
あるいは `element^f に描画するときに積層~文脈として描画するだけで済むか？
◎
Requiring some degree of stacking context on the element appears to be required for an efficient implementation. Do we need a full stacking context, or just a pseudo-stacking context? Should it need to be a stacking context normally, or can we just render it as a stacking context when rendering it to element()?
</dd>
	<dd>
参照先の要素またはその先祖に変形-が適用されている場合、
要素を画像として描画するときには，変形-は無視するモノトスル。
`CSS3-TRANSFORMS$r
◎
If the referenced element has a transform applied to it or an ancestor, the transform must be ignored when rendering the element as an image. [CSS3-TRANSFORMS]
</dd>
	<dd>
参照先の要素が何~pageかに分断されている場合、
要素は，~pageの内容~区画が~page割り方向に接合されていたかのように表示される
— ~pageの各~辺は初期~包含塊の対応する始端~辺に整列された上で。
<span class="note">
何~行lか／何~柱か
に分断されている要素は、
単に`装飾d限界~box$と伴に描画される
</span>
◎
If the referenced element is broken across pages, the element is displayed as if the page content areas were joined flush in the pagination direction, with pages' edges corresponding to the initial containing block’s start edge aligned. Elements broken across lines or columns are just rendered with their decorated bounding box.
</dd>
	<dd>
実装は、
参照先の要素~用に生成した既存の~bitmap~dataを再利用してもヨイ。
あるいは，要素の表示-を生成し直して、
当の~sizeにおける画像の品質を最大化してもヨイ
（例えば、参照先の要素は~SVG素片であると検出された場合）。
生成し直す場合でも、
結果の画像における~layoutは参照先の要素から変化させないモノトスル。
すなわち，画像の見かけは、
~raster化の品質の違いを除き，参照先の要素と一致させるモノトスル。
◎
Implementations may either re-use existing bitmap data generated for the referenced element or regenerate the display of the element to maximize quality at the image’s size (for example, if the implementation detects that the referenced element is an SVG fragment); in the latter case, the layout of the referenced element in the image must not be changed by the regeneration process. That is, the image must look identical to the referenced element, modulo rasterization quality.
</dd>
	<dd class="example">
<p>
`p$e 要素を文書~内の他所で背景として再利用する例：
◎
As a somewhat silly example, a p element can be reused as a background elsewhere in the document:
</p>

`efunc1^dgm

<figure>
`efunc2^dgm
</figure>

	</dd>

	<dt>
要素は`描画され$ないが、
`塗り~source$を供する場合：
◎
an element that is not rendered, but which provides a paint source
</dt>
	<dd>
関数は、
`塗り~source$の［
`生来な寸法$, 【内在的な】外観
］を伴う画像を表現する
— ~sizeと外観は、
~host言語により定義される。
◎
The function represents an image with the natural dimensions and appearance of the paint source. The host language defines the size and appearance of paint sources.
</dd>
	<dd class="example">
<p>
例えば， `element$f 関数は、
~HTML文書~内の ~SVG `pattern$e 要素を参照できる：
◎
For example, the element() function can reference an SVG &lt;pattern&gt; element in an HTML document:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;svg&gt;
  &lt;defs&gt;
    &lt;pattern id='pattern1'&gt;
      &lt;path d='...'&gt;
    &lt;/pattern&gt;
  &lt;/defs&gt;
&lt;/svg&gt;
&lt;p style="background: element(#pattern1)"&gt;
<span class="comment">
ここでは~patternを背景に利用しています。
~patternが変化したり~animateされた場合、
背景も更新されることになります。
◎
I’m using the pattern as a background! If the pattern is changed or animated, my background will be updated too!
</span>
&lt;/p&gt;
</pre>

<p>
~HTMLは、
塗り~sourceを供する数種の要素
— ［
`canvas$e, `img$e, `video$e
］など —
を定義する。
~page内には表示されてないが、
中に何か描かれている `canvas$e を，~CSSから参照できることを意味する：
◎
HTML also defines that a handful of elements, such as canvas, img, and video, provide a paint source. This means that CSS can, for example, reference a canvas that’s being drawn into, but not displayed in the page:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  var %canvas = document.querySelector('#animated-bullet');
  %canvas.width = 20; canvas.height = 20;
  drawAnimation(%canvas);
&lt;/script&gt;
&lt;canvas id='animated-bullet' style='display:none'&gt;&lt;/canvas&gt;
&lt;ul style="list-style-image: element(#animated-bullet);"&gt;
  &lt;li&gt;<span class="comment">
ここでは `canvas$e を~bulletに利用しています。
◎
I’m using the canvas as a bullet!
</span>&lt;/li&gt;
  &lt;li&gt;<span class="comment">
ここでも。
◎
So am I!
</span>&lt;/li&gt;
  &lt;li&gt;<span class="comment">
`canvas$e が~JSで変更される度に，すべての~bullet画像も更新されます。
◎
As the canvas is changed over time with Javascript, we’ll all update our bullet image with it!
</span>&lt;/li&gt;
&lt;/ul&gt;
</pre>

	</dd>

	<dt>
その他の場合：
◎
anything else
</dt>
	<dd>
関数は`無効な画像$を表現する。
◎
The function represents an invalid image.
</dd>
	<dd class="example">
<p>
例えば，次に挙げる `element$f の利用は、
どれも透明な背景になる：
◎
For example, all of the following element() uses will result in a transparent background:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;p id='one' style="display:none; position: relative;"&gt;one&lt;/p&gt;
&lt;iframe src="http://example.com"&gt;
  &lt;p id='two' style="position: relative;"&gt;<span class="comment">
~fallback内容
◎
I’m fallback content!
</span>&lt;/p&gt;
&lt;/iframe&gt;
&lt;ul&gt;
  &lt;li style="background: element(#one);"&gt;
<span class="comment">
要素 `p id='one'^e は、
`display^p が `none^v にされていて`描画され$ないので，塗り~sourceを供さない。
◎
A display:none element isn’t rendered, and a P element doesn’t provide a paint source.
</span>
  &lt;/li&gt;
  &lt;li style="background: element(#two);"&gt;
<span class="comment">
`element^f には `iframe$e の様な`置換d要素$の子孫は利用できない。
◎
The descendants of a replaced element like an IFRAME can’t be used in element() either.
</span>
  &lt;/li&gt;
  &lt;li style="background: element(#three);"&gt;
<span class="comment">
`id^a "`three^v" の要素はないので、
この背景も透明になる。
◎
There’s no element with an id of "three", so this also gets rendered as a transparent image.
</span>
  &lt;/li&gt;
&lt;/ul&gt;
</pre>
	</dd>
</dl>

<p>
結付けられた~boxがない要素は、
`描画され@
ないとされる。
これは、例えば［
要素またはその ある先祖にて，
`display^p が `none^v にされている場合
］などに起こり得る。
~host言語は、
要素が描画されないと見なされ得る追加的な仕方を定義してもヨイ
— 例えば，~SVGにおいては、
`defs$e 要素のどの子孫も，描画されないものと見なされる。
◎
An element is not rendered if it does not have an associated box. This can happen, for example, if the element or an ancestor is display:none. Host languages may define additional ways in which an element can be considered not rendered; for example, in SVG, any descendant of a &lt;defs&gt; element is considered to be not rendered.
</p>

<div class="example">
<p>
`element$f 関数には、
多くの用途がある。
例えば、
~slideshowにおける［
次／前
］の~slideの~previewを示すために利用できる：
◎
The element() function can be put to many uses. For example, it can be used to show a preview of the previous or next slide in a slideshow:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
function navigateSlides() {
  var %currentSlide = ...;
  document.querySelector('#prev-slide').id = '';
  document.querySelector('#next-slide').id = '';
  %currentSlide.previousElementSibling.id = 'prev-slide';
  %currentSlide.nextElementSibling.id = 'next-slide';
}
&lt;/script&gt;
&lt;style&gt;
.slide {
  /* <span class="comment">
`element^f 可能になるためには、
積層~文脈にする必要がある。
◎
Need to be a stacking context to be element()-able.
</span> */
  position: relative;
}
#prev-preview, #next-preview {
  position: fixed;
  ...
}
#prev-preview { background: element(#prev-slide); }
#next-preview { background: element(#next-slide); }
&lt;/style&gt;
&lt;a id='prev-preview'&gt;前の~slide&lt;/a&gt;
&lt;a id='next-preview'&gt;次の~slide&lt;/a&gt;
&lt;section class='slide'&gt;...&lt;/section&gt;
&lt;section class='slide current-slide'&gt;...&lt;/section&gt;
...
</pre>
<!-- 
Previous Slide
Next Slide
 -->

<p>
この例の `navigateSlides()^c 関数は、［
次／前
］の~slideの `id^a を更新する
— それは、
~slideの傍に浮動している小さい~box内に表示される。
【利用者は，】
`element$f 関数による~slideとはヤリトリできないので
（それは単なる画像である）、
~preview~boxに対し `click^et ~handlerを利用して，
~pageを~navigateし易くすることもできる。
◎
In this example, the navigateSlides function updates the ids of the next and previous slides, which are then displayed in small floating boxes alongside the slides. Since you can’t interact with the slides through the element() function (it’s just an image), you could even use click handlers on the preview boxes to help navigate through the page.
</p>

</div>

			<section id="paint-sources">
<h4 title="Paint Sources">2.7.1. 塗り~source</h4>

<p>
~host言語は、
何らかの要素を
`塗り~source@
を供するものとを定義してもヨイ。
塗り~sourceは、［
内在的な外観があり，［
~layoutする／描画-
］する必要なく`具象-~obj~size$を得せる
］ので，`描画され$ていなくとも画像として利用できる。
◎
Host languages may define that some elements provide a paint source. Paint sources have an intrinsic appearance and can obtain a concrete object size without having to do layout or rendering, and so may be used as images even when they’re not rendered.
</p>

<p>
~HTMLにおいては、［
`img$e ／ `video$e ／ `canvas$e
］要素が塗り~sourceを供する。
◎
In HTML, the img, video, and canvas elements provide paint sources.
</p>

<p>
~SVGにおいては、
`塗り~server$を供する要素が，塗り~sourceを供する。
<span class="note">注記：
SVG1.1 においては，［
`linearGradient＠~SVG11/pservers.html#LinearGradientElement$e,
`radialGradient＠~SVG11/pservers.html#RadialGradientElement$e,
`pattern＠~SVG11/pservers.html#PatternElement$e
］要素が塗り~sourceを供する。
</span>
それらは，その仕様にて述べるように描かれる
— 次に定義される座標系の下で：
◎
In SVG, any element that provides a paint server provides a paint source. Note: In SVG1.1, the &lt;linearGradient&gt;, &lt;radialGradient&gt;, and &lt;pattern&gt; elements provide paint sources. They are drawn as described in the spec, with the coordinate systems defined as follows:
</p>

<dl>
	<dt>`objectBoundingBox^v</dt>
	<dd>
原点は，描かれている`具象-~obj~size$により定義される矩形の左上隅。
寸法は，`具象-~obj~size$と同じ。
`利用元~単位$は，`具象-~obj~size$の横幅, 縦幅。
◎
The coordinate system has its origin at the top left corner of the rectangle defined by the concrete object size that it’s being drawn into, and the same width and height as the concrete object size. A single user coordinate is the width and height of the concrete object size.
</dd>

	<dt>`userSpaceOnUse^v</dt>
	<dd>
原点は，描かれている`具象-~obj~size$により定義される矩形の左上隅。
寸法は，`具象-~obj~size$と同じ。
`利用元~単位$は， `px$u 単位に等価。
◎
The coordinate system has its origin at the top left corner of the rectangle defined by the concrete object size that it’s being drawn into, and the same width and height as the concrete object size. User coordinates are sized equivalently to the CSS px unit.
</dd>
</dl>

<p class="note">注記：
この~moduleの将来の~versionでは、
次を参照rする仕方も定義するものと期待されている
⇒＃
外部~文書~内の塗り~source／
もっぱら~scriptにより作成され，文書~内にまったく挿入されない塗り~source
◎
Note: It is expected that a future version of this module will define ways to refer to paint sources in external documents, or ones that are created solely by script and never inserted into a document at all.
</p>

			</section>
			<section id="elementsources">
<h4 title="Using Out-Of-Document Sources: the ElementSources interface">2.7.2. 文書~外~sourceの利用-法： `ElementSources^I ~interface</h4>

<p>
`element$f 関数は，通常は文書の中の要素を選択するが、
`塗り~source$を供する要素は，必ずしも文書~内にある必要はない。
例えば、
~scriptにより［
作成され, 保守され, 描かれ
］，文書に直に挿入されてはいない~HTML `canvas$e 要素など。
◎
The element() function normally selects elements within a document, but elements that provide a paint source don’t necessarily need to be in-document. For example, an HTML canvas element can be created, maintained, and drawn into entirely in script, with no need for it to be inserted into the document directly.
</p>

<p>
`~ID選択子$は，文書の外側にある要素を選択できないので、
要素を参照rする仕方が必要になる。
`elementSources$m ~map~objがこれを供する。
◎
All that’s needed is a way to refer to the element, as an ID selector cannot select elements outside of the document. The elementSources Map object provides this.
</p>

<pre class="idl">
partial namespace `CSS$I {
  [`SameObject$] readonly attribute `any$ `elementSources@m;
};
</pre>

<p>
`elementSources$m ~mapを成す各~entryのうち，次を満たすものが、
`element$f 関数にて可用になる
⇒
［
~keyは文字列である
］~AND［
値は`塗り~source$を供している~objである
］
◎
Any entries in the elementSources map with a string key and a value that is an object providing a paint source are made available to the element() function.
</p>

<p>
`element$f に与えた `id-selector$t に対しては、
先ず `elementSources$m ~map内で，~ID（先頭の文字 `#^c は含めない）が検索される：
◎
Whenever element() uses an &lt;id-selector&gt;, the ID’s value (without the leading # character) is first looked up in the elementSources map:
</p>

<ul>
	<li>
~IDを~keyとする~entryが見出された場合、
`element$f 関数は，~entryの値で与えられる~objが`塗り~source$を供して［
いるならば その塗り~source ／
いないならば`無効な画像$
］を表現する。
◎
If it’s found, and the object associated with it provides a paint source, the element() function represents that paint source.
◎
If it’s found, but the object associated with it doesn’t provide a paint source, the element() function represent an invalid image.
</li>
	<li>
見出されなかった場合、
通常通り，文書~内を探す。
◎
If the ID isn’t found in the map at all, it’s then looked for in the document as normal.
</li>
</ul>

<p class="issue">
この`~ID選択子$の再利用は、
Mozilla の挙動に合致する。
編集者は、
文法の先頭を `custom-ident$t で塞ぐのは避けたいと~~考えている
— それは構文~空間を食い過ぎるので。
別の可能性として、
値を言語により定義される~keywordから開始させ，
`custom-ident$t を後続させる~~案もあるが
— `element(external fancy)^v  か何かの様に。
何か命名の示唆があれば歓迎する。
◎
This reuse of the ID selector matches Moz behavior. I’m trying to avoid slapping a &lt;custom-ident&gt; right in the beginning of the grammar, as that eats too much syntax-space. Another possibility, though, is to start the value with a language-defined keyword followed by a &lt;custom-ident&gt;, like element(external fancy) or something. Naming suggestions welcome.
</p>

<div class="example">
<p>
外部~canvasで~fancyな背景を~animateする例：
◎
For example, fancy animating backgrounds can be done with an external canvas:
</p>

<pre class="lang-html">
&lt;script&gt;
var %bg = document.createElement('canvas');
%bg.height = 200;
%bg.width = 1000;
drawFancyBackground(%bg);
CSS.elementSources.set('fancy', %bg);
&lt;/script&gt;
&lt;style&gt;
h1 {
  background-image: element(#fancy);
}
&lt;/style&gt;
</pre>

<p>
“~fancyな” ~canvasの中に何かが描かれ，~animateされるに伴い，すべての `h1^e 要素の背景も自動的かつ一斉に更新されることになる。
◎
As the "fancy" canvas is drawn into and animated, the backgrounds of all the H1 elements will automatically update in tandem.
</p>

<p>
`elementSources$m ~mapは，文書に対し`~ID選択子$を照合する前に諮られるので、
文書~内に `#fancy^v に合致する要素があっても，背景は依然として `elementSources$m 値から来ることに注意。
◎
Note that the elementSources map is consulted before the document to match the ID selector, so even if there’s an element in the document that would match #fancy, the backgrounds will still predictably come from the elementSources value instead.
</p>

</div>

			</section>
			<section id="element-cycles">
<h4 title="Cycle Detection">2.7.3. 循環の検出</h4>

<p>
`element$f 関数は、
無為な循環関係を生産し得る
— 自身を自前の背景に利用する要素など。
これらの関係性は，依存関係~graphを保ち続けるので、
共通的な循環~検出~algoを利用すれば，容易かつ依拠-可能に検出して解決できる。
◎
The element() function can produce nonsensical circular relationships, such as an element using itself as its own background. These relationships can be easily and reliably detected and resolved, however, by keeping track of a dependency graph and using common cycle-detection algorithms.
</p>

<p>
依存関係~graphは、
次に挙げる辺からなる：
◎
The dependency graph consists of edges such that:
</p>

<ul>
	<li>
どの要素も、
その子たちに依存する。
◎
every element depends on its children
</li>
	<li>
要素 A 上のある~propが `element$f 関数を利用していて，要素 B を指しているならば、
A は B に依存する
◎
for any element A with a property using the element() function pointing to an element B, A depends on B
</li>
	<li>
~host言語が，要素が他の要素の描画を参照rする仕方を定義しているならば、
参照元の要素は参照先の要素に依存する。
例えば，~SVGにおいては、
`use$e 要素は参照先の要素に依存する。
◎
if a host language defines a way for elements to refer to the rendering of other elements, the referencing element depends on the referenced element. For example, in SVG, a &lt;use&gt; element depends on the element it referenced.
</li>
</ul>

<p>
この~graphが循環を包含する場合、
その循環に関与しているどの `element$f 関数も，`無効な画像$になる。
◎
If the graph contains a cycle, any element() functions participating in the cycle are invalid images.
</p>

			</section>
		</section>
	</section>
	<section id="gradients">
<h2 title="Gradients">3. ~gradient</h2>

<p>
~gradientとは、
ある色から別の色へ滑らかに~fadeする画像である。
これらは、［
背景~画像, ~button, その他多くのもの
］に淡い陰影を施すために，共通的に利用される。
この節に述べる
`~gradient関数@
は、
そのような画像を簡素な構文で指定することを作者に許容する
— ~UAが~pageを描画するときに自動的に生成できるような。
`~gradient関数$の構文は：
◎
A gradient is an image that smoothly fades from one color to another. These are commonly used for subtle shading in background images, buttons, and many other things. The gradient functions described in this section allow an author to specify such an image in a terse syntax, so that the UA can generate the image automatically when rendering the page. The syntax of a &lt;gradient&gt; is:
</p>

<pre class="prod">
`gradient@t
	= `linear-gradient$ft
	| `repeating-linear-gradient$ft
	| `radial-gradient$ft
	| `repeating-radial-gradient$ft
	| `conic-gradient$ft
	| `repeating-conic-gradient$ft
</pre>

<div class="example">
<p>
他の `image$t 型と同じく、
この仕様にて定義される~gradientは，画像を受容するどの~propにも利用できる。
例えば：
◎
As with the other &lt;image&gt; types defined in this specification, gradients can be used in any property that accepts images. For example:
</p>

<pre class="lang-css">
`background^p: `linear-gradient(white, gray)^v;
`list-style-image^p: `radial-gradient(circle, #006, #00a 90%, #0000af 100%, white 100%)^v;
</pre>

</div>

<p>
~gradientは、
`~gradient~box@
と呼ばれる，`具象-~obj~size$の寸法による~boxの中に描かれる。
しかしながら、
~gradient自身は`生来な寸法$を持たない。
◎
A gradient is drawn into a box with the dimensions of the concrete object size, referred to as the gradient box. However, the gradient itself has no natural dimensions.
</p>

<div class="example">
<p>
例えば，~gradientを背景として利用する場合、
既定では，~gradientは［
要素の~padding~boxに~sizeされた`~gradient~box$
］の中に描かれることになる。
`background-size$p が， `100px 200px^v のような数値的な値にされている場合、
`~gradient~box$は，幅 100px, 高さ 200px になる。
同様に， `list-style-image$p として利用される~gradientに対しては、
~boxは，その~propの`既定の~obj~size$である 1em の正方形になる。
◎
For example, if you use a gradient as a background, by default the gradient will draw into a gradient box the size of the element’s padding box. If background-size is explicitly set to a value such as 100px 200px, then the gradient box will be 100px wide and 200px tall. Similarly, for a gradient used as a list-style-image, the box would be a 1em square, which is the default object size for that property.
</p>

</div>

<p>
~gradientは、
`~gradient線@
（その形状は、
~gradientの型に依存し，~~幾何的には［
直線／射線／渦巻き線
］になり得る）
の
`始点@
と
`終点@
を定義した上で，この線~上のいくつかの点に色を指定することにより指定される。
これらの色は、
まず，線~上の他の部分を埋めるように滑らかに混色される。
`~gradient線$の色を利用して~gradient 全体の色を実際に生産する方法は、
~gradientの各~型ごとに定義される。
◎
Gradients are specified by defining the starting point and ending point of a gradient line (which, depending on the type of gradient, may be technically a line, or a ray, or a spiral), and then specifying colors at points along this line. The colors are smoothly blended to fill in the rest of the line, and then each type of gradient defines how to use the color of the gradient line to produce the actual gradient.
</p>

		<section id="linear-gradients">
<h3 title="Linear Gradients: the linear-gradient() notation">3.1. 線型~gradient： `linear-gradient^f 記法</h3>

<p>
この~level 4 は、［
`linear-gradient$f, `repeating-linear-gradient$f
］に `color-interpolation-method$t 引数を追加する。
それは、
`~gradient線$上の色を補間するときに利用する色~空間と~path†を指示する
— `CSS-COLOR-4$r `§ 色~補間＠~CSSCOLOR#interpolation$ を見よ。
◎
This level adds a &lt;color-interpolation-method&gt; argument to linear-gradient() and repeating-linear-gradient(), indicating the color space and path to use when interpolating colors on the gradient line. See CSS Color 4 §  12. Color Interpolation.
</p>

<p class="trans-note">【†
言い換えれば、
空間を［
`極-座標＠~CSSCOLOR#cylindrical-polar-color$,
`直交-座標＠~CSSCOLOR#rectangular-orthogonal-color$
］どちらにするか。
極-座標の場合（色相を補間する場合）、
~pathは曲線になる（曲線に沿って補間することになる）。
】</p>

<pre class="prod">
`linear-gradient-syntax@t
	= [ [ `angle$t | `to^v `side-or-corner$t || `color-interpolation-method$t ]?, `color-stop-list$t
</pre>
【！`side-or-corner@t = [left | right] || [top | bottom]】

			<section id="color-interpolation">
<h4 title="Effects of color space on interpolation: examples">3.1.1. 補間に対する色~空間の効果の例</h4>

◎非規範的

<p>
色~空間は、
補間に対し有意な効果を伴い得る。
◎
The effect of colorspace on interpolation can be significant.
</p>

<div class="example">
<p>
この例では、
3 種の色~空間~内で，同じ色~pair［
`#f01^v, `#081^v
］の合間に線型~gradientが描かれる。
2 個目（図中段）の~gradientは、
~gamma符号化された~sRGBを利用する
（~level 3 では、これしか選べなかった）
— 結果は、
中点で明瞭に暗になり過ぎる。
1 個目（図上段）の~gradientは、
~CIE~Labを利用する
— それは、
より知覚的に一様な結果を与える。
3 個目（図下段）の~gradientは、
~Oklabを利用する
— それは、
ここでは~CIE~Labとほぼ同じ結果を与える。
◎
In this example, a linear gradient between the same pair of colors #f01 and #081 is drawn in three different colorspaces. The middle gradient uses gamma-encoded sRGB, which was the only choice in CSS Images 3; the result is clearly too dark at the midpoint. The upper gradient uses CIE Lab, giving a more perceptually uniform result; while the lower gradient uses Oklab, which here gives almost the same result as CIE Lab.
</p>
<ul>
<li>`linear-gradient(in lab to right, #F01, #081)^v
</li>
<li>`linear-gradient(in srgb to right, #F01, #081)^v
</li>
<li>`linear-gradient(in oklab to right, #F01, #081)^v
</li>
</ul>

<p class="alt" hidden id="_dgm-rectangular-f01-081">
3 種の色~空間における~redから~greenへの~gradient
◎
red to green gradient in three colorspaces
</p>
</div>

<div class="example">
<p>
この例では、
3 種の色~空間~内で，同じ色~pair［
`white^v, `#01E^v
］の合間に線型~gradientが描かれる。
2 個目（図中段）の~gradientは、
~gamma符号化された~sRGBを利用する
— この結果もまた、
中点で暗になり過ぎる上に，彩度がやや低下し，少し~purpleっぽくなる。
1 個目（図上段）の~gradientは、
~CIE~Labを利用する
— それは、
中点で暗になり過ぎるのを避けるが，有意な~purpleっぽさがある。
3 個目（図下段）の~gradientは、
~Oklabを利用する
— それは、
より知覚的に一様な結果を与えることに加え，~purpleっぽさはまったく無い。
◎
In this example, a linear gradient between the same pair of colors white and #01E is drawn in three different colorspaces. The middle gradient uses gamma-encoded sRGB, the result is again too dark at the midpoint, is a little desaturated, and has a slight purplish cast. The upper gradient uses CIE Lab, which avoids the too-dark midpoint but has a significant purple cast; while the lower gradient uses Oklab, giving a more perceptually uniform result with no purple cast at all.
</p>
<ul>
<li>`linear-gradient(in lab to right, white, #01E)^v
<li>`linear-gradient(in srgb to right, white, #01E)^v
<li>`linear-gradient(in oklab to right, white, #01E)^v
</ul>

<p class="alt" hidden id="_dgm-rectangular-fff-01e">
3 種の色~空間における白から~blueへの~gradient
◎
white to blue gradient in three colorspaces
</p>
</div>

<div class="example">
<p>
この例では、
3 種の色~空間~内で，同じ色~pair［
`#44C^v, `#795^v
］の合間に線型~gradientが描かれる。
これは、［
~CIE~Labにおける色相の非-線形性が，~blueがかった色~すべてに影響する
］ことをデモる
— 有彩度な原色~blueから白への~gradientのみならず。
2 個目（図中段）の~gradientは、
~gamma符号化された~sRGBを利用する
— その結果もまた、
中点で暗になり過ぎ，少し~purpleっぽくなる。
1 個目（図上段）の~gradientは、
~CIE~Labを利用する
— それは、
中点で暗になり過ぎるのを避けるが，有意な~purpleっぽさがある。
3 個目（図下段）の~gradientは、
~Oklabを利用する
— これもまた、
より知覚的に一様な結果を与える上に，~purpleっぽさはまったく無い。
◎
In this example, a linear gradient between the same pair of colors #44C and #795 is drawn in three different colorspaces. This demonstrates that the hue non-linearity of CIE Lab affects all bulueish colors, not just the gradient from saturated primary blue to white. The middle gradient uses gamma-encoded sRGB, the result is again too dark at the midpoint, and has a slight purplish cast. The upper gradient uses CIE Lab, which avoids the too-dark midpoint but has a significant purple cast; while the lower gradient uses Oklab, again giving a more perceptually uniform result with no purple cast at all.
</p>
<ul>
<li>`linear-gradient(in lab to right, #44C, #795)^v
<li>`linear-gradient(in srgb to right, #44C, #795)^v
<li>`linear-gradient(in oklab to right, #44C, #795)^v
</ul>

<p class="alt" hidden id="_dgm-rectangular-44c-795">
3 種の色~空間における~blueから~greenへの~gradient
◎
blue to green gradient in three colorspaces
</p>
</div>

<p>
~gradient補間~用に，
矩形な色~空間に代えて極座標な色~空間を選べば、
色停どうしの色相が遠く離れていても，彩度の低下を避けれる。
極座標な色~空間~内での補間は、
内来的に色度を保全する
— 中間~色は，色域から外れ易くなるが、
そうなった場合，色域~内に戻すよう色域~対応付けが施される。
◎
Choosing a polar, rather than rectangular, colorspace for gradient interpolation avoids desaturation if the hues of the color stops are far apart. Interpolating in a polar colorspaces is inherently chroma-preserving, although it is easy for the intermediate colors to fall out of gamut; they will then be gamut mapped to bring them back into gamut.
</p>

<div class="example">
<p>
この例では、
5 種の色~空間~内で，同じ色~pair［
`#A37^v, `#595^v
］の合間に線型~gradientが描かれる。
1 個目から（図の上から）順に，［
~CIE~LCH,
~CIE~Lab,
~sRGB,
~Oklab,
~Oklch
］
— うち 2 つ【最初と最後】は極座標である。
◎
In this example, a linear gradient between the same pair of colors #A37 and #595 is drawn in five different colorspaces, two of them polar. From top to bottom: CIE LCH, CIE Lab, sRGB, Oklab, Oklch.
</p>

<p>
矩形な空間においては，中点は灰色がかる一方で、
極座標な空間~内の中間~色は，色度を保全するように曲がった~pathをなぞる。
◎
The rectangular spaces have a greyish midpoint, while the intermediate colors in the polar spaces follow a curved, chroma-preserving path.
</p>

<ul>
<li>`linear-gradient(in lch to right, #A37, #595)^v
<li>`linear-gradient(in lab to right, #A37, #595)^v
<li>`linear-gradient(in srgb to right, #A37, #595)^v
<li>`linear-gradient(in oklab to right, #A37, #595)^v
<li>`linear-gradient(in oklch to right, #A37, #595)^v
</ul>

<p class="alt" hidden id="_dgm-polar-a37-595">
5 種の色~空間における~blueから~greenへの~gradient
◎
blue to green gradient in three colorspaces
</p>
</div>

			</section>
		</section>
		<section id="radial-gradients">
<h3 title="Radial Gradients: the radial-gradient() notation">3.2. 放射型~gradient： `radial-gradient^f 記法</h3>

			<section id="radial-color-interpolation">
<h4 title="Adding &lt;color-interpolation-method&gt;">3.2.1. `color-interpolation-method^t の追加-法</h4>

<p>
この~level 4 は、［
`radial-gradient$f, `repeating-radial-gradient$f
］に `color-interpolation-method$t 引数を追加する。
それは、
`~gradient線$上の色を補間するときに利用する色~空間と~pathを指示する
— `CSS-COLOR-4$r `§ 色~補間＠~CSSCOLOR#interpolation$ を見よ。
◎
This level adds a &lt;color-interpolation-method&gt; argument to radial-gradient() and repeating-radial-gradient(), indicating the color space and path to use when interpolating colors on the gradient line. See CSS Color 4 § 12 Color Interpolation.
</p>

<pre class="prod">
`radial-gradient-syntax@t
	= [ [ [ `radial-shape$t || `radial-size$t ]? [ at `position$t ]? ] || `color-interpolation-method$t]? , `color-stop-list$t
</pre>

<div class="example">
<p>
この例では、
3 種の色~空間~内で，同じ色~pair［
`color(display-p3 0.918 0.2 0.161)^v,
`#081^v
］の合間に放射型~gradientが描かれる。
ここに記したように、
すべての色停を同じ色~空間に入れる必要はない。
2 個目（図中段）の~gradientは、
~gamma符号化された~sRGBを利用する
— その結果は、
明瞭に中点にて暗になり過ぎる。
1 個目（図上段）の~gradientは、
~CIE~Labを利用する
— それは、
より知覚的に一様な結果を与える。
3 個目（図下段）の~gradientは、
~Oklabを利用する
— それは、
ここでは~CIE~Labとほぼ同じ結果を与える。
◎
In this example, a radial gradient between the same pair of colors color(display-p3 0.918 0.2 0.161) and #081 is drawn in three different colorspaces. Notice that the color stops do not all need to be in the same colorspace. The middle gradient uses gamma-encoded sRGB, the result is clearly too dark at the midpoint. The upper gradient uses CIE Lab, giving a more perceptually uniform result; while the lower gradient uses Oklab, which here gives almost the same result as CIE Lab.
</p>

<ul>
<li>`radial-gradient(in lab farthest-side at left bottom, color(display-p3 0.918 0.2 0.161), #081)^v
<li>`radial-gradient(in srgb farthest-side at left bottom, color(display-p3 0.918 0.2 0.161), #081)^v
<li>`radial-gradient(in oklab farthest-side at left bottom, color(display-p3 0.918 0.2 0.161), #081)^v
</ul>

<p class="alt" hidden id="_dgm-radial-rectangular-f01-081">
3 種の色~空間における~redから~greenへの~gradient
◎
red to green gradient in three colorspaces
</p>
</div>

			</section>
			<section id="radial-size">
<h4 title="Expanding &lt;radial-size&gt;">3.2.2. `radial-size^t の拡張p-法</h4>

<p>
この~level 4 は、
`basic-shape$t に対する値［
`circle$f, `ellipse$f
］の追加を含めるよう，
`radial-size$t を拡張する：
◎
This level extends the &lt;radial-size&gt; options to include the additions from the circle() and ellipse() &lt;basic-shape&gt; values:
</p>

<pre class="prod">
`radial-size$t
	= `radial-extent$t{1,2}
	| `length-percentage[0,∞]$t{1,2}
</pre>

<div>
<p>
`radial-size$t は：
</p>
<ul>
	<li>
<p>
【 `radial-gradient-syntax$t を成す】 `radial-shape$t として，
`circle$v が指定された下では：
</p>
		<ul>
			<li>
成分~値が 2 個ある場合、
【それを利用している~gradient関数は】
無効になる。
</li>
			<li>
<p>
`percentage$t 値は、
当の`~gradient~box$の［
横幅, 縦幅
］の “平均化対角線長さ”
— 次の式で与えられる長さ —
を~~基準に解決される
⇒
√( ( 横幅 ~MUL 横幅 ) ~PLUS ( 縦幅 ~MUL 縦幅 ) ) ~DIV √2
</p>

<p class="trans-note">【
これは、
~SVGに定義される`正規化-済み対角線長さ＠~SVGcoords#_normalized-diagonal$と同じになる。
】</p>
</li>
		</ul>
	</li>
	<li>
<p>
他の場合
⇒
楕円【`終形$】を成す［
横~半径, 縦~半径
］を順に指示する。
</p>
<p class="trans-note">【
成分~値が 1 個しかない場合、それが 2 個目の値も与えるであろう。
】</p>
	</li>
</ul>
◎
Two-component values remain invalid when specifying circle as the &lt;radial-shape&gt;, and otherwise indicate the horizontal (first) and vertical (second) radii of the ellipse.
◎
For circle, a &lt;percentage&gt; value is resolved against the “scaled diagonal” of the gradient box's width and height: sqrt(width² + height²)/sqrt(2).
</div>
			</section>
		</section>
		<section id="conic-gradients">
<h3 title="Conic Gradients: the conic-gradient() notation">3.3. 円錐型~gradient： `conic-gradient^f 記法</h3>

<p>
円錐型~gradientは、
放射型~gradientと類似に 真円の中心を指定するが、
その色停は，［
中心から湧出る線ではなく，`真円の周^em
］に沿って配置される
— 色は、
中心から外方へは進捗せず，中心の周りを回るに伴い滑らかに遷移する。
◎
A conic gradient starts by specifying the center of a circle, similar to radial gradients, except that conic gradient color-stops are placed around the circumference of the circle, rather than on a line emerging from the center, causing the color to smoothly transition as you spin around the center, rather than as you progress outward from the center.
</p>

<p>
円錐型~gradientを指定するためには、［
回転~角度, ~gradientの中心
］を指示した上で，色停たちが成す~listを指定する。
円錐型~gradientの各~色停は `angle$t で指定される
— `length$t 指定して配置する［
線型／放射型
］~gradientと違って。
射線は，中心からすべての方向へ湧出るように描かれ、
各~射線の色は，それが~gradient線に交差する所の色に等しくなる。
◎
A conic gradient is specified by indicating a rotation angle, the center of the gradient, and then specifying a list of color-stops. Unlike linear and radial gradients, whose color-stops are placed by specifying a &lt;length&gt;, the color-stops of a conic gradient are specified with an &lt;angle&gt;. Rays are then drawn emerging from the center and pointing in all directions, with the color of each ray equal to the color of the gradient-line where they intersect it.
</p>

<p class="note">注記：
これらの~gradientが “円錐型” （ “`conic^en” あるいは “`conical^en” ）と呼ばれるわけは、
それが生産する~patternが
— 一方の色停を他方のそれより有意に明るくしたときには —
円錐を上から眺めた様な見かけになるからである。
それは，射線の回転~角度を変えることで生産されるので、
一部の文脈においては “角度” ~gradientとも称されている。
◎
Note: These gradients are called "conic" or "conical" because, if the color stops are chosen to be significantly lighter on one side than the other, it produces a pattern that looks like a cone observed from above. They are also known as "angle" gradients in some contexts, since they are produced by varying the rotation angle of a ray.
</p>

<div class="example">
<figure>
<figcaption id="_dgm-conic-diagram">
~boxの背景が、
上端から開始して, 時計回りに, 白から黒へ徐々に濃くなる様子を示している画像。
この画像には、
~gradient線を成す真円（赤線）と［
角度 `0deg^v, `216deg^v （白丸）に~~位置する色
］が示されている。
◎
[An image showing a box with a background shading gradually clockwise from white to black, starting from the top. A gradient circle is shown, and the colors at 0 and 216 degrees respectively.]
</figcaption></figure>

<p>
この例は、
`conic-gradient(at 25% 30%, white, black 60%)^v
がどう描かれるかを視覚的に示す。
各~色停の位置は，常に角度に解決されるので、
`25% 30%^v の効果は、
~gradientの~2D並進~しかないことに注意
— すなわちそれは、
~gradientがどう描かれるかには影響しない。
◎
This example visually illustrates how conic-gradient(at 25% 30%, white, black 60%) would be drawn. Note that since color stop positions always resolve to angles, the only effect of the at 25% 30% is a 2D translation of the gradient, i.e. it does not affect how the gradient is drawn.
</p>

</div>

			<section id="conic-gradient-syntax">
<h4 title="conic-gradient() Syntax">3.3.1.  `conic-gradient^f の構文</h4>

<p>
円錐型~gradientの構文は：
◎
The syntax for a conic gradient is:
</p>

<pre class="prod">
`conic-gradient@f
	= conic-gradient( [ `conic-gradient-syntax$t ] )
`conic-gradient-syntax@t
	= [ [ [ from `angle$t ]? [ at `position$t ]? ] || `color-interpolation-method$t ]?, `angular-color-stop-list$t
</pre>

<p>
各 引数は、
次に従って定義される：
◎
The arguments are defined as follows:
</p>
<dl>
	<dt id="valdef-conic-gradient-angle">`angle$t</dt>
	<dd>
~gradient全体がこの角度で回転される。
省略-時の既定は、
`0deg^v になる。
角度 0 の場合、
`angle$t の単位~識別子は省略してもヨイ。
◎
The entire gradient is rotated by this angle. If omitted, defaults to 0deg. The unit identifier may be omitted if the &lt;angle&gt; is zero.
</dd>

	<dt id="valdef-conic-gradient-position">`position$t</dt>
	<dd>
~gradientの
`~gradient中心@
を決定する。
値は `radial-gradient$f に対するときと同じに解決される。
<!-- ＊
`position$t 値~型（ `background-position$p にも利用される）は， `CSS-VALUES-3$r にて定義され、［
~obj区画として中心~点,
背景~位置決め区画として`~gradient~box$
］を利用して解決される。
 -->
この引数が省略された場合の既定は `center$v とする。
◎
Determines the gradient center of the gradient. The &lt;position&gt; value type (which is also used for background-position) is defined in [CSS-VALUES-3], and is resolved using the center-point as the object area and the gradient box as the positioning area. If this argument is omitted, it defaults to center.
</dd>
</dl>

<p class="issue">
円錐型~gradientにおいては、
`0deg^v 地点での急激な遷移は 通例的に望ましくないので，最初と最後の色停は概して同じ色にされる。
たぶん、
これを自動的に達成する~keywordがあれば，有用になる。
◎
Usually in conic gradients the sharp transition at 0deg is undesirable, which is typically avoided by making sure the first and last color stops are the same color. Perhaps it would be useful to have a keyword for automatically achieving this.
</p>

<p class="issue">
~gradientを切取る（内縁や外縁の）半径は有用になるか？
もしそうなら、
特定の半径があるので，長さ値による色停~位置も~supportできる。
◎
Would a radius (inner &amp; outer) for clipping the gradient be useful? If so, we could also support lengths in color stop positions, since we now have a specific radius.
</p>

<p class="issue">
楕円な円錐型~gradientは有用になるか？
~graphics-libraryはそれを~supportするか？
◎
Are elliptical conic gradients useful? Do graphics libraries support them?
</p>

			</section>
			<section id="conic-color-stops">
<h4 title="Placing Color Stops">3.3.2. 色停の配置-法</h4>

<p>
`色停$は、
ある真円~内で，［
`~gradient中心$の周りに沿って曲がる`~gradient線$
］上に配置される。
`0%^v, `100%^v は，両者とも `0deg^v の所在に一致し、
~pageの上端を指す。
角度の増加は、
時計回りの動きに対応する。
◎
Color stops are placed on a gradient line that curves around the gradient center in a circle, with both the 0% and 100% locations at 0deg. Just like linear gradients, 0deg points to the top of the page, and increasing angles correspond to clockwise movement around the circle.
</p>

<p class="note">注記：
~gradient線は、［
`0deg^v から `360deg^v までの~~区間のみが描画されるような，渦巻き
］を形成していると捉えれば，助けになるかもしれない。
これは、
角度が描画される領域の外側にあるときの “重合n” についての混同を避ける。
◎
Note: It may be more helpful to think of the gradient line as forming a spiral, where only the segment from 0deg to 360deg is rendered. This avoids any confusion about "overlap" when you have angles outside of the rendered region.
</p>

<p>
色停は［
`0%^v より前 ／ `100%^v より後
］の所在にも配置できる。
これらの領域は，描画-時に直に諮られることは決してないが、
そこに配置される色停は
— 補間や繰返nを通して —
描画される領域の中にある色停の色に影響し得る
（ `§ ~gradientの繰返ng＠#repeating-gradients$ を見よ）。
例えば， `conic-gradient(red -50%, yellow 150%)^v が生産する円錐型~gradientは、
`0deg^v の所では~redがかった~orange
<span style="background:#f50;">　</span>（ `#f50^v ）に,
`360deg^v の所では~orangeがかった~yellow
<span style="background:#fa0;">　</span>（ `#fa0^v ）になり，
前者から後者へ遷移する。
◎
A color-stop can be placed at a location before 0% or after 100%; though these regions are never directly consulted for rendering, color stops placed there can affect the color of color-stops within the rendered region through interpolation or repetition (see repeating gradients). For example, conic-gradient(red -50%, yellow 150%) produces a conic gradient that starts with a reddish-orange color at 0deg (specifically, #f50), and transitions to an orangish-yellow color at 360deg (specifically, #fa0).
</p>

<p>
~canvas上の所与の点 %P における~gradientの色を決定するためには、
まず，~gradientの中心から %P を通る一意な射線を見出す。
%P の色は、
この射線が`~gradient線$に交わる点の色で与えられる。
◎
The color of the gradient at any point is determined by first finding the unique ray anchored at the center of the gradient that passes through the given point. The point’s color is then the color of the gradient line at the location where this ray intersects it.
</p>

			</section>
			<section id="conic-gradient-examples">
<h4 title="Conic Gradient Examples">3.3.3. 円錐型~gradientの例</h4>

<p>
以下に挙げるどの `conic-gradient$f 例も，幅 `300px^v, 高さ `200px^v の~boxに適用される。
◎
All of the following conic-gradient() examples are presumed to be applied to a box that is 300px wide and 200px tall, unless otherwise specified.
</p>

<div class="example">
<p>
同じ基本的な円錐型~gradientを指定する種々の仕方を下に示す：
◎
Below are various ways of specifying the same basic conic gradient:
</p>

<pre class="lang-css">
background: conic-gradient(#f06, gold);
background: conic-gradient(at 50% 50%, #f06, gold);
background: conic-gradient(from 0deg, #f06, gold);
background: conic-gradient(from 0deg at center, #f06, gold);
background: conic-gradient(#f06 0%, gold 100%);
background: conic-gradient(#f06 0deg, gold 1turn);
</pre>

<figure>`conic1^dgm
</figure>
</div>

<div class="example">
<p>
同じ基本的な円錐型~gradientを指定する種々の仕方を下に示す。
これは、
色停の角度が [`0deg^v, `360deg^v) の外側にあって直に塗られない場合でも，
色停は依然として~gradientの塗られる部分を成す色には影響し得る様子をデモる。
◎
Below are various ways of specifying the same basic conic gradient. This demonstrates how even though color stops with angles outside [0deg, 360deg) are not directly painted, they can still affect the color of the painted part of the gradient.
</p>

<pre class="lang-css">
background: conic-gradient(white -50%, black 150%);
background: conic-gradient(white -180deg, black 540deg);
background: conic-gradient(hsl(0,0%,75%), hsl(0,0%,25%));
</pre>

<figure>`conic2^dgm
</figure>
</div>

<div class="example">
<p>
同じ回転された円錐型~gradientを指定する， 2 つ仕方を下に示す
— 一方は回転~角度を伴い，他方は伴わない：
◎
Below are two different ways of specifying the same rotated conic gradient, one with a rotation angle and one without:
</p>
<pre class="lang-css">
background: conic-gradient(from 45deg, white, black, white);
background: conic-gradient(hsl(0,0%,75%), white 45deg, black 225deg, hsl(0,0%,75%));
</pre>

<figure>`conic3^dgm
</figure>

<p>
すべての色停を回転~角度だけ~offsetしても，同じにはならず、
まるで異なる~gradientを生産することに注意：
◎
Note that offsetting every color stop by the rotation angle instead would not work and produces an entirely different gradient:
</p>

<pre class="lang-css">
background: conic-gradient(white 45deg, black 225deg, white 405deg);
</pre>

<figure>`conic4^dgm
</figure>
</div>

<div class="example">
<p>
円錐型~gradientの上層に放射型~gradientを重ねて，色相と彩度を伴う色環を描く例：
◎
A conic gradient with a radial gradient overlaid on it, to draw a hue &amp; saturation wheel:
</p>

<pre class="lang-css">
background: radial-gradient(gray, transparent),
            conic-gradient(red, magenta, blue, aqua, lime, yellow, red);
border-radius: 50%;
width: 200px; height: 200px;
</pre>

<figure>`conic5^dgm
</figure>
</div>

<div class="example">
<p>
単純な~pie-chartを描くために利用される円錐型~gradient。
色停の位置 `0deg^v は、
それより前にある色停の位置に等しくなるよう，修繕されることになる。
これは、
異なる色の 2 個の色停の合間に，無限小な（不可視な）遷移を生産することになる
— 実質的に単色の~~区間を生産するような。
◎
A conic gradient used to draw a simple pie chart. The 0deg color stop positions will be fixed up to be equal to the position of the color stop before them. This will produce infinitesimal (invisible) transitions between the color stops with different colors, effectively producing solid color segments.
</p>

<pre class="lang-css">
background: conic-gradient(yellowgreen 40%, gold 0deg 75%, #f06 0deg);
border-radius: 50%;
width: 200px; height: 200px;
</pre>

<figure>`conic6^dgm
</figure>

</div>

			</section>
		</section>
		<section id="repeating-gradients">
<h3 title="Repeating Gradients: the repeating-linear-gradient(), repeating-radial-gradient(), and repeating-conic-gradient() notations">3.4. ~gradientの繰返ng： `repeating-linear-gradient^f, `repeating-radial-gradient^f, `repeating-conic-gradient^f 記法</h3>

<p>
［
`linear-gradient$f ／
`radial-gradient$f ／
`conic-gradient$f
］に加えて，この仕様は［
`repeating-linear-gradient@f
／
`repeating-radial-gradient@f
／
`repeating-conic-gradient@f
］値を定義する。
これらの記法が引数にとり得る値は、
これまでに定義した各自に対応する繰返ngなしの記法と同じであり，同じに解釈される。
【が、その効果は繰返される — ~level 3 の`繰返ng~gradient$を見よ。】
◎
In addition to linear-gradient(), radial-gradient(), and conic-gradient(), this specification defines repeating-linear-gradient(), repeating-radial-gradient(), and repeating-conic-gradient() values. These notations take the same values and are interpreted the same as their respective non-repeating siblings defined previously.
</p>

<pre class="prod">
`repeating-conic-gradient()$t
	= repeating-conic-gradient( [ `conic-gradient-syntax$t ] )
`repeating-linear-gradient()$t
	= repeating-linear-gradient( [ `linear-gradient-syntax$t ] )
`repeating-radial-gradient()$t
	= repeating-radial-gradient( [ `radial-gradient-syntax$t ] )
</pre>

<div class="example">
<p>
基本的な繰返ng円錐型~gradient:
◎
Basic repeating conic gradient:
</p>

<pre class="lang-css">
background: repeating-conic-gradient(gold, #f06 20deg);
</pre>

<figure>`repeating-conic1^dgm
</figure>
</div>

<div class="example">
<p>
一足飛びに遷移する色停たちが繰返されるときは、
旭光状の背景を作成する：
◎
Repeating color stops with abrupt transitions creates a starburst-type background:
</p>

<pre class="lang-css">
background: repeating-conic-gradient(
    hsla(0,0%,100%,.2) 0deg 15deg,
    hsla(0,0%,100%,0) 0deg 30deg
) #0ac;
</pre>

<figure>`repeating-conic2^dgm
</figure>
</div>

<div class="example">
<p>
ここでは、
市松模様を作成するために，一足飛びに遷移する繰返ng色停が利用されている：
◎
Here repeating color stops with abrupt transitions are used to create a checkerboard:
</p>
<pre class="lang-css">
background: repeating-conic-gradient(black 0deg 25%, white 0deg 50%);
background-size: 60px 60px;
</pre>

<figure>`repeating-conic3^dgm
<figcaption>
</figcaption></figure>

<p>
同じ市松模様は、
繰返ngなしの円錐型~gradientを介しても作成できる：
◎
The same checkerboard can be created via non-repeating conic gradients:
</p>

<pre class="lang-css">
background: conic-gradient(black 25%, white 0deg 50%, black 0deg 75%, white 0deg);
background-size: 60px 60px;
</pre>
</div>

		</section>
		<section id="gradient-colors">
<h3 title="Defining Gradient Color">3.5. ~gradient色の定義-法</h3>

<p class="trans-note">【
この節の内容の和訳は、
`~level 3 の内容＠~CSSIMAGE#gradient-colors$からの差分のみを与える
（この節に定義される［
`色停@
／
`遷移~hint@
／
`色停~list@
］は、
~level 3 による定義に一致する）。
】</p>

			<section id="color-stop-syntax">
<h4 title="Color Stop Lists">3.5.1. 色停~list</h4>

<p>
`色停~list$の構文は、
~level 3 から，次のように拡張される：
◎
Color stops and transition hints are specified in a color stop list, which is a list of two or more color stops interleaved with optional transition hints:
</p>

<pre class="prod">
`color-stop-list@t
	= `linear-color-stop$t , [ `linear-color-hint$t? , `linear-color-stop$t ]#
`linear-color-stop@t
	= `color$t `color-stop-length$t?
`linear-color-hint@t
	= `length-percentage$t
`color-stop-length@t
	= `length-percentage$t{1,2}

`angular-color-stop-list@t
	= `angular-color-stop$t , [ `angular-color-hint$t? , ]? `angular-color-stop$t ]#
`angular-color-stop@t
	= `color$t `color-stop-angle$t?
`angular-color-hint@t
	= `angle-percentage$t
`color-stop-angle@t
	= `angle-percentage$t{1,2}

`color-stop@t
	= `color-stop-length$t
	| `color-stop-angle$t
</pre>

<p class="note">注記：
`color-stop-list$t と `angular-color-stop-list$t の構造は正確に一致することに注意
— ［
色停／遷移~hint
］の位置を指定するときに［
`length$t, `angle$t
］どちらを受容するかが相違するだけである。
◎
Note that &lt;color-stop-list&gt; and &lt;angular-color-stop-list&gt; are exactly identical in structure, they just differ on whether they accept &lt;length&gt;s or &lt;angle&gt;s for specifying the position of the stops and hints.
</p>

<p>
線路図式で視覚-化すれば、
これら両者とも次の~patternに従う：
◎
Visualized with a railroad diagram, both of them follow this pattern:
◎
alt="&lt;color-stop&gt; , &lt;color-hint&gt; , &lt;color-stop&gt; ,"
</p>

<div class="railroad">
`color-stop-railroad^dgm
</div>

<p>
2 個の位置を伴う`色停$は、［
各~位置ごとに同じ色を伴う， 2 個の`色停$
］を指定することに，等価になる。
<span class="note">
2 個の位置を指定すれば、
色を 2 回~繰返すことなく，~gradient内で単色の “縞” を容易に作成できる。
</span>
◎
A color stop with two positions is equivalent to specifying two color stops with the same color, one for each position. Specifying two locations makes it easier to create solid-color "stripes" in a gradient, without having to repeat the color twice.
</p>

<p class="trans-note">【
以下、
`~level 3 と同じ＠~CSSIMAGE#color-stop-syntax$。
】</p>

			</section>
			<section id="coloring-gradient-line">
<h4 title="Coloring the Gradient Line">3.5.2. 色~付けと~gradient線</h4>

<p>
各 `色停$の位置における~gradient線の色は、
その`色停$の色になる。
~gradient線の［
最初の`色停$より前 ／ 最後の`色停$より後
］を成す部分は［
最初／最後
］の`色停$の色になる。
隣接する 2 個の`色停$の合間における線の色は、
それらの`色停$の色を補間した結果になる
— この補間は、
次に従うとする：
◎
At each color stop position, the gradient line is the color of the color stop. Before the first color stop, the gradient line is the color of the first color stop, and after the last color stop, the gradient line is the color of the last color stop. Between each pair of color stops, the gradient line’s color is interpolated between the colors of the two color stops, with the interpolation＼
</p>
<ul>
	<li>
当の~gradient関数に `color-interpolation-method$t が指定されているならば、
その色~空間~内で行う。
指定されていない場合、
`CSS-COLOR-4$r にて定義される既定の補間~色~空間 ~Oklabを利用する。
◎
taking place in the specified color space,＼
◎
↓</li>
	<li>
欠落~成分は、
`CSS-COLOR-4$r `§ 欠落~成分との補間-法＠~CSSCOLOR#interpolation-missing$
にて定義されるとおりに取扱う。
◎
with missing components handled as defined in CSS Color 4 § 12.2 Interpolating with Missing Components,＼
</li>
	<li>
色相の補間は、
`CSS-COLOR-4$r `§ 色相の補間＠~CSSCOLOR#hue-interpolation$
にて定義されるとおりに行う。
◎
hue interpolation as defined in CSS Color 4 § 12.4 Hue Interpolation,＼
</li>
	<li>
乗算済み色~値【！乗算済み~alpha】を
`CSS-COLOR-4$r `§ ~alphaを伴う色の補間-法＠~CSSCOLOR#interpolation-alpha$
にて定義されるとおりに利用する。
◎
and using premultiplied alpha, as defined in CSS Color 4 § 12.3 Interpolating with Alpha.＼
↑↑ If no &lt;color-interpolation-method&gt; is specified in the gradient function, the color space used for gradient interpolation is the default interpolation color space, Oklab, as defined in [css-color-4].
</li>
</ul>

<div class="example">
<p>
例えば，所与の~gradient定義
`linear-gradient(in oklch, red, #888, green)^v
に対しては、
中立な `#888^v から~Oklchへ変換した結果は
`oklch(0.6268 0 none)^v になり，欠落な色相~成分を与える。
◎
For example, given the following gradient definition:
• linear-gradient(in oklch, red, #888, green)
◎
the conversion of the neutral #888 to oklch gives a missing hue component: oklch(0.6268 0 none)
</p>

<p>
したがって、［
1 個目／ 2 個目
］の~gradient~~区間における色相は、［
`red^v ／ `green^v
］からとられ，［
`oklch(0.628 0.2577 29.234)^v ／
`oklch(0.5198 0.1769 142.5)^v
］になる。
◎
and thus, in the first gradient segment, the hue is taken from red, which is oklch(0.628 0.2577 29.234); while in the second segment it is taken from green, which is oklch(0.5198 0.1769 142.5)
</p>
</div>

<p class="trans-note">【
以下，
この節を成す（下の例以外の）内容は、
`~level 3 と同じ＠~CSSIMAGE#coloring-gradient-line$なので，和訳は省略する。
】</p>

<div class="example">
<p>
線型~gradientが`遷移~hint$を伴わないとき（図~上段）と，［
~red, ~blue
］`色停$の合間に遷移~hintを伴うとき（図~下段）とを比較する例。
◎
Here an example of a linear gradient without transition hint (top) compared to one with a transition hint between the red and blue color stops (bottom).
</p>

<figure>`gradient-colors-transition-hint-comparison^dgm</figure>

<p>
図~上段は、
`遷移~hint$を伴わないとき
（既定の中間点~遷移~hintに~fall-backする）：
◎
Top - Without transition hint (falling back to the default halfway transition hint):
</p>

<pre class="lang-css">
background: linear-gradient(to right, red 0%, blue 100%);
</pre>

<p>
図~下段は、
遷移~hintを伴うとき：
◎
Bottom - With transition hint:
</p>

<pre class="lang-css">
background: linear-gradient(to right, red 0%, 25%, blue 100%);
</pre>
</div>

			</section>
			<section id="color-stop-fixup">
<h4 title="Color Stop “Fixup”">3.5.3. 色停の “修繕”</h4>

<p class="trans-note">【
`~level 3 と同じ＠~CSSIMAGE#color-stop-fixup$。
】</p>

			</section>
		</section>
	</section>
	<section id="stripes">
<h2 title="1D Image Values: the &lt;image-1D&gt; type and stripes() notation">4. ~1D画像~値： `image-1D^t 型と `stripes^f 記法</h2>

<p>
`image$t 値は 2-次元な画像を表現し，
`color$t は 0-次元な画像【！(unvarying in either axis)】として捉えることもできるが、
一部の文脈は，
`1-次元な画像@
を要求する
— それは、
ある抽象的な, 無方向な, 単-軸な
`塗り線@
に沿って色を指定する。
`image-1D$t 型は、
そのような `1-次元な画像$を表現し，
`stripes$f `関数-記法$を含む：
◎
While &lt;image&gt; values represent a 2-dimensional (2D) image, and &lt;color&gt; can be thought of as a 0-dimensional (0D) image (unvarying in either axis), some contexts require a 1-dimensional (1D) image, which specifies colors along an abstract, directionless, single-axis paint line. The &lt;image-1D&gt; type represents such 1D images, including the stripes() functional notation:
</p>

<p class="trans-note">【
~SVGの
`stroke-dasharray＠~SVGpainting#StrokeDasharrayProperty$p
に似た（色に関しては，より強力な）効果が想定されている
— 例： `outline-color＠~CSSUI#propdef-outline-color$p 。
】【
“無方向” と記されているが、
`塗り線$上に色（縞）を配置する順序は方向を含意する。
】</p>

<pre class="prod">
`image-1D@t
	= `stripes$ft
`stripes$ft
	= stripes( `color-stripe$t# )
`color-stripe@t
	= `color$t &amp;&amp; [ `length-percentage$t | `flex$t ]?
</pre>

<p>
`stripes@f
関数は、
~commaで分離された［
色を伴う縞（ `stripe^en ）
］（ `color-stripe$t ）たちが成す~listとして，
`1-次元な画像$を定義する
— それらの縞は、
所与の順序で`塗り線$上の端から端まで†に配置される。
◎
The stripes() function defines a 1D image as a comma-separated list of colored stripes, each placed end-to-end on the paint line in the order given.
</p>

<p class="trans-note">【†
したがって、
`塗り線$には，始点と終点が定義される必要がある
（`~gradient線$と同様に）。
】</p>

<p>
各 `color-stripe$t は、
指定された色と太さ（ `thickness^en ）†を伴う単色な縞を定義する。
太さが省略された場合、
`1fr^v が既定になる。
太さ値は、
次に従って解釈される：
◎
Each &lt;color-stripe&gt; entry defines a solid-color stripe with the specified &lt;color&gt; and thickness. If the thickness is omitted, it defaults to 1fr. Thickness values are interpreted as follows:
</p>

<p class="trans-note">【†
`塗り線$上を占める長さ。
“幅” とも称される。
】</p>

<dl class="valdef">
	<dt id="valdef-stripes-percentage-0-100">`percentage$t</dt>
	<dd>
百分率による太さは、
%総幅 【下を見よ】に相対的になる。
妥当な値は、
`0%^v 以上 `100%^v 以下に限られる。
◎
Percentage thicknesses are relative to the total width. Only values between 0% and 100% (inclusive) are valid.
</dd>

	<dt id="valdef-stripes-length-0">`length$t</dt>
	<dd>
負な長さ値は、
無効になる。
◎
Negative length values are invalid.
</dd>

	<dt id="valdef-stripes-flex">`flex$t</dt>
	<dd>
各 `flex$t は、［
%総幅 から `flex^t を伴わない各~縞の太さを減算した結果
（ 0 以上に切り上げる）
］に対する［［
関数~内の `flex^t を伴う縞の太さの総和
］に相対的な割合分
］として評価される。
`flex^t 値の総和が `1fr^v 未満になる場合、
減算した結果は，分配される前に総和の値で乗算される。
◎
A &lt;flex&gt; is evaluated as a fraction of the total width relative to the total sum of &lt;flex&gt; entries in the function, after subtracting the thickness of any non-&lt;flex&gt; entries (flooring the subtraction result at zero). If the sum of &lt;flex&gt; values is less than 1fr, the result of the subtraction is multiplied by the sum’s value before being distributed.
</dd>
</dl>

<p>
%総幅 は、
`stripes$f 関数が利用される文脈により定義される。
縞たちの太さの総和が %総幅 より小さい場合、
`塗り線$における残りの長さを占める部位は，`透明な黒$になる
— 最後の引数として `transparent$v を伴うものが追加され【！与えられ】たかのように。
総和が %総幅 より大きい場合、
`塗り線$の %総幅 を超える［
縞／部位
］は切落とされる。
◎
The total width is defined by the context in which the stripes() function is used. If the sum of the stripes is smaller than the total width, the paint line is transparent black for its remaining length, as if a final transparent argument were given. If the sum is larger, any stripes or portions beyond the total width are truncated.
</p>

<div class="example">
<p>
例えば， %総幅 `400px^v が与えられた下では：
◎
↓</p>

<ul>
	<li>
<p>
`stripes(red 1fr, green 2fr, blue 100px)^v
は、
順に
⇒＃
幅 `100px^v の~redな縞,
幅 `200px^v の~greenな縞,
幅 `100px^v の~blueな縞
◎終
を与えることになる。
総和 `400px^v から `blue^v が占める `100px^v を減算した残り `300px^v のうち［
~red は 1/(1+2), ~greenは 2/(1+2)
］を占めるようになる。
◎
For example, stripes(red 1fr, green 2fr, blue 100px) with a total width of 400px will result in a 100px red stripe and 200px green stripe, giving red 1 share and green 2 shares of the 300px remaining after subtracting blue’s 100px from the 400px total.
</p>

<figure>`stripes1^dgm</figure>
	</li>
	<li>
<p>
他方，
`stripes(red .1fr, green .2fr, blue 100px)^v は、
順に
⇒＃
幅 `30px^v の~redな縞,
幅 `60px^v の~greenな縞,
幅 `100px^v の~blueな縞,
幅 `210px^v の透明な縞
◎終
を与えることになる。
`flex$t 用に残された幅 `300px^v の空間は、
`flex^t 値の総和 0.3 で乗算した結果 `90px^v に限り，
各 `flex^t 値により規定される 1:2 の比率で分配される。
◎
On the other hand, stripes(red .1fr, green .2fr, blue 100px) with a total width of 400px will instead give a 30px red stripe and 60px green stripe, followed by 100px of blue and then 210px of transparent. The 300px of leftover space is multiplied by .3, the value of the sum of the &lt;flex&gt; values, to obtain only 90px, which is then distributed in the 1:2 ratio dictated by the &lt;flex&gt; values.
</p>

<figure>`stripes2^dgm</figure>
	</li>
</ul>

<p>
（これは、
`~flex~layout$において，
~flex行l上の `flex$t の総和が小さいときに対し処する方法に類似する
— `flex^t 値が 0 に近づくに伴い，滑らかで連続的になる挙動を確保する。）
◎
(This is similar to how flex layout deals with small &lt;flex&gt; sums on a line, and ensures smoothly continuous behavior as the &lt;flex&gt; values approach zero.)
</p>
</div>

<p>
この関数の`算出d値$は、
縞たちが成す有順序~listであり，
各縞は
( `算出d色$, 次のいずれかとして表現される太さ )
が成す組になる
⇒
`flex$t 値／
算出された `length-percentage$t 値
◎
The computed value of this function is an ordered list of stripes, each given as a computed color and a thickness represented either a &lt;flex&gt; value or a computed &lt;length-percentage&gt; value.
</p>

	</section>
	<section id="sizing">
<h2 title="Sizing Images and Objects in CSS">5. ~CSSにおける画像／~objの~sizing</h2>

		<section id="the-object-fit">
<h3 title="Sizing Objects: the object-fit property">5.1. ~objの~sizing： `object-fit^p ~prop</h3>

◎名 `object-fit@p
◎値 `fill$v | `none$v | [`contain$v | `cover$v] || `scale-down$v
◎初 `fill$v
◎適 `置換d要素$
◎継 されない
◎百 受容しない
◎算 指定された~keyword（たち）
◎順 文法に従う
◎ア 離散的
◎表終

<p>
`object-fit$p ~propは、
置換d要素の内容が，その使用［
横幅, 縦幅
］により確立される~boxに，どう収めるべきかを指定する。
◎
The object-fit property specifies how the contents of a replaced element should be fitted to the box established by its used height and width.
</p>

<p class="trans-note">【
以下、
`~level 3 の内容＠~CSSIMAGE#the-object-fit$
と同じ部分
—  “L3” と記されている箇所 —
の和訳は省略する。
】</p>

<dl class="valdef">
	<dt>`fill@v</dt>
	<dd>
L3
◎
The replaced content is sized to fill the element’s content box: the object’s concrete object size is the element’s used width and height.
</dd>

	<dt>`none@v</dt>
	<dd>
L3
◎
The replaced content is not resized to fit inside the element’s content box: determine the object’s concrete object size using the default sizing algorithm with no specified size, and a default object size equal to the replaced element’s used width and height.
</dd>

	<dt>`contain@v</dt>
	<dd>
L3
◎
The replaced content is sized to maintain its aspect ratio while fitting within the element’s content box: its concrete object size is resolved as a contain constraint against the element’s used width and height.
</dd>
	<dd>
`scale-down$v も併用された場合、
内容は［
`none$v, `contain$v
］のうち，`具象-~obj~size$が小さくなる方が指定されたかのように~sizeされる。
◎
If the scale-down flag is used, size the content as if none or contain were specified, whichever would result in a smaller concrete object size.
</dd>
	<dd class="note">注記：
`none$v も `contain$v も内容の`生来な縦横比$を保つので、
大きさは比較可能になる。
◎
Note: Both none and contain respect the content’s natural aspect ratio, so the concept of "smaller" is well-defined.
</dd>

	<dt>`cover@v</dt>
	<dd>
L3
◎
The replaced content is sized to maintain its aspect ratio while filling the element’s entire content box: its concrete object size is resolved as a cover constraint against the element’s used width and height.
</dd>
	<dd>
`scale-down$v も併用された場合、
内容は［
`none$v, `cover$v
］のうち，`具象-~obj~size$が小さくなる方が指定されたかのように~sizeされる。
◎
If the scale-down flag is used, size the content as if none or cover were specified, whichever would result in a smaller concrete object size.
</dd>
	<dd class="note">注記：
`none$v も `cover$v も内容の`生来な縦横比$を保つので、
大きさは比較可能になる。
◎
Note: Both none and cover respect the content’s natural aspect ratio, so the concept of "smaller" is well-defined.
</dd>

	<dt>`scale-down@v</dt>
	<dd>
`contain scale-down^v と等価。
◎
Equivalent to contain scale-down. 
</dd>
</dl>

<p>
L3
◎
If the content does not completely fill the replaced element’s content box, the unfilled space shows the replaced element’s background. Since replaced elements always clip their contents to the content box, the content will never overflow. See the object-position property for positioning the object with respect to the content box.
</p>

<figure>`img_scale^dgm<figcaption>
<p>
L3
◎
An example showing how four of the values of object-fit cause the replaced element (blue figure) to be scaled to fit its height/width box (shown with a green background), using the initial value for object-position.＼
</p>

<p>
この事例では、［
図に示されていない値 `scale-down$v, および `scale-down contain^v
］による見かけは， `contain$v と一致する／
`scale-down cover^v による見かけは， `none$v と一致する。
◎
In this case, scale-down and scale-down contain would look identical to contain, and scale-down cover would look identical to none. 
</p>
</figcaption></figure>

<p class="note">注記：
L3
◎
Note: The object-fit property has similar semantics to the fit attribute in [SMIL10] and the &lt;meetOrSlice&gt; parameter on the preserveAspectRatio attribute in [SVG11].
</p>

<p class="note">注記：
L3
◎
Note: Per the object size negotiation algorithm, the concrete object size (or, in this case, the size of the content) does not directly scale the object itself - it is merely passed to the object as information about the size of the visible canvas. How to then draw into that size is up to the image format. In particular, raster images always scale to the given size, while SVG uses the given size as the size of the "SVG Viewport" (a term defined by SVG) and then uses the values of several attributes on the root &lt;svg&gt; element to determine how to draw itself.
</p>

		</section>
	</section>
	<section id="image-processing">
<h2 title="Image Processing">6. 画像~処理</h2>

		<section id="the-image-resolution">
<h3 title="Overriding Image Resolutions: the image-resolution property">6.1. 画像~解像度の上書き法： `image-resolution^p ~prop</h3>

<p>
`画像~解像度@
は、
単位~長さあたりの画像~画素~数として定義される
（例：~inchあたりの画素~数）。
画像~形式には、
画像の解像度についての情報を記録するものもある。
この情報は、
整形~処理nにあたって画像の実際の~sizeを決定する補助になり得る
— しかしながら、
誤ったものにもなり得るので，その場合には無視されるべきである。
~CSSの既定では，［
解像度は、
~CSS `px$u 単位が 1 画像~画素に等しい
］ものと見做されるが、
`image-resolution$p ~propは，他の何らかの解像度を利用することを許容する。
◎
The image resolution is defined as the number of image pixels per unit length, e.g., pixels per inch. Some image formats can record information about the resolution of images. This information can be helpful when determining the actual size of the image in the formatting process. However, the information can also be wrong, in which case it should be ignored. By default, CSS assumes a resolution of one image pixel per CSS px unit; however, the image-resolution property allows using some other resolution.
</p>

◎名 `image-resolution@p
◎値 [ `from-image$v || `resolution$t ] &amp;&amp; `snap$v?
◎初 `1dppx^v
◎適 すべての要素
◎継 される
◎百 受容しない
◎算 
指定された~keyword（たち） ／ 指定された `resolution$t ／ これらが成す組
— ただし， `resolution$t は `snap$v 用に調整され得る（下記を見よ）。
◎
specified keyword(s) and/or &lt;resolution&gt; (possibly adjusted for snap, see below)
◎順 文法に従う
◎ア 離散的
◎表終

<p class="issue">
`image-set$f 記法は、
画像の`生来な解像度$を改め得る
—
それは、
この~propを設定しなくても，自動的に尊守されるのが理想的だが【？】。
これをどう~~解決すべきか？
初期~値を、
“~CSSが他を~~指示しない限り `1dppx^v とする”
を意味する `auto^v に変えるか？
`image-resolution^p は、
解像度が~CSSにおける他の何かで設定された画像には効果がないようにするか？
あるいは、
`image-set$f を，それが常に何らかの方法で `1dppx^v 画像を生産するように，どうにか `wordsmith^en するか？
◎
The image-set() notation can alter the natural resolution of an image, which ideally would be automatically honored without having to set this property. How should we best address this? Change the initial value to auto, meaning "1dppx, unless CSS says otherwise"? Say that image-resolution has no effect on images whose resolution was set by something else in CSS? Or somehow wordsmithing image-set() in some way such that it always produces 1dppx images somehow?
</p>

<p>
`image-resolution$p ~propは、［［
要素~内／要素~上
］で利用されるすべての~raster画像
］の`選好d解像度$を指定する。
それは、
内容~画像（例： `置換d要素$や`生成d内容$）にも,
装飾的な画像（ `background-image$p など）にも影響する。
画像の
`選好d解像度@
は、
画像の`生来な寸法$を決定するために利用される。
natural resolution
各種 値の意味は：
◎
The image-resolution property specifies the preferred resolution of all raster images used in or on the element. It affects both content images (e.g. replaced elements and generated content) and decorative images (such as background-image). The preferred resolution of an image is used to determine the image’s natural dimensions. Values have the following meanings:
</p>

<dl class="valdef">
	<dt id="valdef-image-resolution-resolution">`resolution$t</dt>
	<dd>
`選好d解像度$を数値的に指定する。
この場合の 1 “~dot” は， 1 画像~画素に対応する。
◎
Specifies the preferred resolution explicitly. A "dot" in this case corresponds to a single image pixel.
</dd>
	<dd class="trans-note">【
すなわち、［
`CSS-VALUES-3$r による
`resolution＠~CSSVAL#resolution$t
の定義
］に記されている “~dot” は 1 画像~画素と解釈される。
】</dd>

	<dt>`from-image@v</dt>
	<dd>
画像の`選好d解像度$は、
画像~形式から指定される（
`生来な解像度@
）。
画像が自前の解像度を指定していない場合、
`resolution$t が明示的に指定されていれば，それが利用され、
他の場合は既定の `1dppx^v になる。
◎
The image’s preferred resolution is taken as that specified by the image format (the natural resolution). If the image does not specify its own resolution, the explicitly specified resolution is used (if given), else it defaults to 1dppx.
</dd>
	<dd class="note">注記：
どの~metadataを利用できるかに対しては、
ある制約が課される
— ~level 3 の `§ 画像~metadata＠~CSSIMAGE#url-metadata$を見よ。
◎
Note: CSS Images 3 § 2.1.2 Image Metadata imposes some restrictions on what metadata can be used.
</dd>

	<dt>`snap@v</dt>
	<dd>
この~keywordが伴われている `resolution$t は、
1 画像~画素が機器~画素の整数~倍に対応するような，最も近い値に丸めた結果に算出される。
解像度が画像からとられる【 `from-image$v が供されている】場合、
`生来な解像度$の使用~値は，画像の~nativeな解像度を同様に調整した結果になる。
◎
If the "snap" keyword is provided, the computed &lt;resolution&gt; (if any) is the specified resolution rounded to the nearest value that would map one image pixel to an integer number of device pixels. If the resolution is taken from the image, then the used natural resolution is the image’s native resolution similarly adjusted.
</dd>
</dl>

<p>
SVG などの~vector形式には、
`生来な解像度$は無い。
この~propは、
~vector画像には効果がない。
◎
As vector formats such as SVG do not have a natural resolution, this property has no effect on vector images.
</p>

<div class="example">
<p>
印刷機の解像度は、
~computer~monitorより，かなり高いのが常なので、
~screen上ではきれいな画像でも，印刷~時には画素が目立つ。
`image-resolution$p ~propを利用すれば、
文書~内に高-解像度な画像を埋込んで 適切な~sizeを保守しつつ，~screen上でも紙~上でも美麗に表示できるようになる：
◎
Printers tend to have substantially higher resolution than computer monitors; due to this, an image that looks fine on the screen may look pixelated when printed out. The image-resolution property can be used to embed a high-resolution image into the document and maintain an appropriate size, ensuring attractive display both on screen and on paper:
</p>

<pre class="lang-css">
img.high-res {
  image-resolution: 300dpi;
}
</pre>

<p>
この規則の下では、
300dpi で 5 ~inch幅になるようにされた画像は，実際に 5 ~inch幅で表示されることになる。
この規則が無い下では、
~CSSの既定による 1 ~inchあたり 96 画像~画素の表示になるので，画像は［
300 ~MUL 5 ~DIV 96 ~EQ 約 15.6
］~inch幅で表示されることになる。
◎
With this set, an image meant to be 5 inches wide at 300dpi will actually display as 5in wide; without this set, the image would display as approximately 15.6in wide since the image is 15000 image pixels across, and by default CSS displays 96 image pixels per inch.
</p>

</div>

<div class="example">
<p>
画像~形式には、
自身の~data内に解像度を符号化するものもある。
次の規則は、
~UAが，解像度を画像~自身から見出すように指定する
— 見出されない場合、
~CSS `px$u 単位あたり 1 画像~画素に~fallbackする。
◎
Some image formats can encode the image resolution into the image data. This rule specifies that the UA should use the image resolution found in the image itself, falling back to 1 image pixel per CSS px unit.
</p>

<pre class="lang-css">
img { image-resolution: from-image }
</pre>

<p>
次の規則は、
~UAが，解像度を画像~自身から見出すように指定しつつ、
見出せないときは，解像度を既定の `1dppx^v でなく `300dpi^v に設定する。
◎
These rules both specify that the UA should use the image resolution found in the image itself, but if the image has no resolution, the resolution is set to 300dpi instead of the default 1dppx.
</p>

<pre class="lang-css">
img { image-resolution: from-image 300dpi }
img { image-resolution: 300dpi from-image }
</pre>

</div>

<div class="example">
<p>
次の規則は、
画像~解像度を 300dpi に設定する
（画像~自身の解像度は，無視される）。
◎
Using this rule, the image resolution is set to 300dpi. (The resolution in the image, if any, is ignored.)
</p>

<pre class="lang-css">
img { image-resolution: 300dpi }
</pre>

<p>
一方で，次の規則では、
~screen解像度が 96dpi の下であれば，画像を解像度 288dpi で描画することになる
（ 3 画像~画素が 1 機器~画素に対応する）：
◎
This rule, on the other hand, if used when the screen’s resolution is 96dpi, would instead render the image at 288dpi (so that 3 image pixels map to 1 device pixel):
</p>

<pre class="lang-css">
img { image-resolution: 300dpi snap; }
</pre>

<p>
`snap$v ~keywordは、
解像度が画像からとれるときにも利用できる：
◎
The snap keyword can also be used when the resolution is taken from the image:
</p>

<pre class="lang-css">
img { image-resolution: snap from-image; }
</pre>

<p>
画像~自身に備わる解像度が
300dpi のときには 288dpi で描画する
（ 3 画像~画素が 1 機器~画素に対応する）一方で、
72dpi のときには 96dpi で描画することになる
（ 1 画像~画素が 1 機器~画素に対応する）。
◎
An image declaring itself as 300dpi will, in the situation above, display at 288dpi (3 image pixels per device pixel) whereas an image declaring 72dpi will render at 96dpi (1 image pixel per device pixel).
</p>
</div>

		</section>
	</section>
	<section id="interpolation">
<h2 title="Interpolation">7. 補間</h2>

<p>
この節では、
~CSSによる遷移や~animation（ CSS Transitions ／ CSS Animations ）における利用のために，［
この仕様にて定義される，新たな値~型
］の補間-法を述べる。
◎
This section describes how to interpolate between new value types defined in this specification, for use with modules such as CSS Transitions and CSS Animations.
</p>

<p>
以下の~algoにおいて，単に［
2 個の値が “補間される”, あるいは “遷移する”
］と記される所では、
それ以上の詳細を言明することなく，
`CSS Transitions 仕様に従って補間される＠~TRANSITION#animatable-types$
べきであることを意味する
【~link先は廃された — 補間-法は、現在は `CSS-VALUES-4$r にて`定義される＠~CSSVAL#combining-values$】
。
他の場合、
 ~algoは，その補間の詳細な記述において，変数 %t を参照rする。
これは、
0% から 100% へ進捗する数値であり，遷移の［
所要時間, 経過した時間, 利用されている`~easing関数$
］に基づく遷移の進捗を表現する値に設定される。
例えば、
`線型~easing関数$と所要時間 1 秒の下では， 0.3 秒後の %t は 30% になる。
◎
If an algorithm below simply states that two values should be "interpolated" or "transitioned" without further details, then the value should be interpolated as described by the Transitions spec. Otherwise, the algorithm may reference a variable t in its detailed description of the interpolation. This is a number which starts at 0% and goes to 100%, and is set to a value that represents the progress through the transition, based on the duration of the transition, the elapsed time, and the timing function in use. For example, with a linear timing function and a 1s duration, after .3s t is equal to 30%.
</p>

		<section id="interpolating-images">
<h3 title="Interpolating &lt;image&gt;">7.1. `image$t の補間-法</h3>

<p>
すべての画像は補間できる
— 一部の特殊な型の画像（~gradientなど）は、
特別な補間~規則を備えるが。
一般~語で述べるなら、
画像は、［
%開始-画像 の~sizeに拡縮した所から始まり，
%終止-画像 の~sizeへ遷移する間に 2 つを~cross-fadeする
］ことにより，補間される。
◎
All images can be interpolated, though some special types of images (like some gradients) have their own special interpolation rules. In general terms, images are interpolated by scaling them to the size of the start image and cross-fading the two while they transition to the size of the end image.
</p>

<p>
より詳しく述べるなら、
補間における各~時点にて，画像は
<code class="value">cross-fade( ( 100% ~MINUS %t ) %開始-画像, %終止-画像 )</code>
に等しくされる。
◎
In specific terms, at each point in the interpolation the image is equal to cross-fade( (100% - t) start image, end image).
</p>

<p class="issue">
画像~無しから, あるいは画像~無しへ遷移するような，特殊な事例の補間-法
—
<code class="css">`background-image^p: `url(foo)^v;</code>
から
<code class="css">`background-image^p: `none^v;</code>
へ のような。
◎
Special-case interpolating to/from no image, like "background-image: url(foo);" to "background-image: none;".
</p>

		</section>
		<section id="interpolating-image-combinations">
<h3 title="Interpolating cross-fade()">7.2. `cross-fade$f の補間-法</h3>

<p>
`cross-fade$f を成す 3 成分は独立に補間される。
これは、
入子な `cross-fade$f 記法にもなり得ることに注意。
◎
The three components of cross-fade() are interpolated independently. Note this may result in nested cross-fade() notations.
</p>

		</section>
		<section id="interpolating-gradients">
<h3 title="Interpolating &lt;gradient&gt;">7.3. `gradient$t の補間-法</h3>

<p class="issue">
この節は考査と改善を要する。
特に、
`linear-gradient^f の取扱いは不完全であろう
— ~gradient線が［
開始する位置から終止する位置までの “長さ”
（ 0% から 100% までの距離）
］が同じ~animationを通じて増減しないように，
数値的に特に補間すべきと見られる。
◎
This section needs review and improvement. In particular, I believe the handling of linear-gradient() is incomplete - I think we want to specifically interpolate the "length" of the gradient line (the distance between 0% and 100%) between the starting and ending positions explicitly, so it doesn’t grow and then shrink over a single animation.
</p>

<p>
~gradient画像は、
~gradientから別の~gradientへ滑らかに~animateするよう［
~CSS遷移／~CSS~animation
］において直に補間し得る。
ただし、
~gradientの補間が許容されるためには，次に挙げる制約がある：
◎
Gradient images can be interpolated directly in CSS transitions and animations, smoothly animating from one gradient to another. There are only a few restrictions on what gradients are allowed to be interpolated:
</p>
<ul>
	<li>
［
開始ng, 終止ng
］~gradientを与える関数の型は，同じでなければナラナイ。
（例えば、
`linear-gradient$f からは、
`linear-gradient$f へは遷移できるが，［
`radial-gradient$f ／ `repeating-linear-gradient$f
］へは遷移できない）
◎
Both the starting and ending gradient must be expressed with the same function. (For example, you can transition from a linear-gradient() to a linear-gradient(), but not from a linear-gradient() to a radial-gradient() or a repeating-linear-gradient().)
</li>
	<li>
［
開始ng, 終止ng
］~gradientの `color-stop$t は同数でなければナラナイ。
この目的においては、
すべての繰返ng~gradientには 無限~個の`色停$があり，互いに同数あると見なされる。
◎
Both the starting and ending gradient must have the same number of &lt;color-stop&gt;s. For this purpose, all repeating gradients are considered to have infinite color stops, and thus all repeating gradients match in this respect.
</li>
	<li>
両~gradientとも， `length$t, `percentage$t による`色停$を組合せて利用していない。
◎
Neither gradient uses a combination of &lt;length&gt; and &lt;percentage&gt; color stops.
</li>
</ul>

<p>
2 個の~gradientが，上述の 3 つの拘束すべてを満たすならば、
以下に述べるように補間するモノトスル。
3 つ目の拘束だけ満たさない場合、
50% の所で一足飛びに遷移するモノトスル
（将来の仕様により他が指定されない限り）。
他の場合、
汎用 `image$t に対するときと同じく， `cross-fade$f を利用して補間するモノトスル。
◎
If the two gradients satisfy all of those constraints, they must be interpolated as described below. If they fail the third one only, they must be abruptly transitioned at 50% (unless otherwise specified by a future specification). If they fail either of the first two constraints, they must be interpolated using cross-fade() as for generic images.
</p>

<p class="note">注記：
50% の所で一足飛びに遷移させるのは、
内容が~cross-fadeに依拠しないようにして，将来に［
この事例~用に，もっと賢い補間~規則を追加できるようにする
］ためである。
◎
Note: The abrupt transition at 50% is so that content will not rely on cross-fading, and smarter interpolation rules can be added for this case in the future.
</p>

<ol>
	<li>
<p>
［
開始ng, 終止ng
］~gradientを成す各~成分を数値的な形に変換する：
◎
Convert both the start and end gradients to their explicit forms:
</p>
		<dl class="switch">
			<dt>
`線型~gradient$に対しては
【成分は方向のみ】：
◎
For linear gradients:
</dt>
			<dd>
`angle$t として指定されている場合
⇒
すでに数値的な形である。
◎
If the direction is specified as an &lt;angle&gt;, it is already in its explicit form.
</dd>
			<dd>
<p>
他の場合【すなわち，~keyword】：
◎
Otherwise,＼
</p>
				<ol>
					<li>
等価な描画を生産する［
0 度 以上, 360 度 未満
］の `angle$t に変換する。
◎
change its direction to an &lt;angle&gt; in [0deg,360deg) that would produce an equivalent rendering.
</li>
					<li>
<p>
［［
開始ng, 終止ng
］~gradientの いずれの方向も~keywordで指定されていて
］かつ［
前~段で数値化した 2 個の角度の差の絶対値 ~GT 180 度
］の場合、
小さい方の角度に 360 度を加算する。
◎
If both the start and end gradients had their direction specified with keywords, and the absolute difference between the angles their directions mapped to is greater than 180deg, add 360deg to the direction of the gradient with the smaller angle.＼
</p>

<p class="note">注記：
これにより、
例えば，［
`to left^v （ 270 度）から `to top^v （ 0 度）への遷移
］は、
期待されるとおり，
~gradientを（反~時計回りに 3/4 回転ではなく，）時計回りに 1/4 回転させる。
◎
This ensures that a transition from, for example, "to left" (270deg) to "to top" (0deg) rotates the gradient a quarter-turn clockwise, as expected, rather than rotating three-quarters of a turn counter-clockwise.
</p>
					</li>
				</ol>
			</dd>

			<dt>
`放射型~gradient$に対しては：
◎
For radial gradients:
</dt>
			<dd>
【`終形$の】~sizeが［
2 個の `length$t または 2 個の `percentage$t
］として指定されている場合
⇒
すでに数値的であり，変換は必要ない。
<!-- ＊
“2 個の”, ”~size” — 補間の趣旨からは［
開始ng~gradientの終形の縦（横）~sizeと, 
終止ng~gradientの終形の縦（横）~size
］と解釈すべきように思えるが、そうすると次項の記述にそぐわなくなる。
 -->
◎
If the size is specified as two &lt;length&gt;s or &lt;percentage&gt;s, it is already in its explicit form.
</dd>
			<dd>
<p>
他の場合、
次に従うモノトスル：
◎
Otherwise,＼
</p>
				<ul>
					<li>
2 個の~sizeを［
等価な`終形$を生産するような 2 個の `length$t が成す~pair
］に~~変換する。
◎
the size must be changed to a pair of &lt;length&gt;s that would produce an equivalent ending-shape.＼
</li>
					<li>
`radial-shape$t【！rg-ending-shape】 に `circle$v が指定されている場合、
それを `ellipse$v に変更する。
◎
If the &lt;rg-ending-shape&gt; was specified as circle, change it to ellipse.
</li>
				</ul>

<p class="trans-note">【
~gradientの`中心$（ `position$t ）も~keywordにより指定され得るが、
言及されていない
— それらも同様に数値化すると思われる。
】</p>

			</dd>
		</dl>
	</li>
	<li>
<p>
~gradientを成す各［
成分, 色停
］を独立に補間する：
◎
Interpolate each component and color-stop of the gradients independently.＼
</p>
		<ul>
			<li>
`線型~gradient$に対しては、
成分は角度のみになる。
◎
For linear gradients, the only component is the angle.＼
</li>
			<li>
`放射型~gradient$に対しては、
成分は［
中心の［
横, 縦
］位置
］, および［
【終形の】 ［
横, 縦
］方向の長さ
］からなる。
◎
For radial gradients, the components are the horizontal and vertical position of the center and the horizontal and vertical axis lengths.
</li>
		</ul>
	</li>
	<li>
<p>
`色停$を補間する：
◎
To interpolate a color-stop,＼
</p>
		<ol>
			<li>
<p>
［
開始ng, 終止ng
］~gradientの，各 色停を互いに対応~付ける：
</p>
				<ul>
					<li>
各~色停に，指定された順により ~indexを付与する。
</li>
					<li>
繰返ng~gradientに対しては、［
後続する／先行する
］他のすべての色停には，色停~listを繰返しながら，適切にズラした~indexを付与する。
</li>
					<li>
各~gradientの同じ~indexの色停が互いに対応する。
</li>
				</ul>
◎
first match each color-stop in the start gradient to the corresponding color-stop at the same index in the end gradient. For repeating gradients, the first specified color-stop in the start and end gradients are considered to be at the same index, and all other color-stops following and preceding are indexed appropriately, repeating and shifting each gradient’s list of color-stops as needed.＼
</li>
			<li>
各 対応する色停~pairに対し，その［
位置, 色
］を独立に補間する。
◎
Then, for each pair of color-stops, interpolate the position and color independently.
</li>
		</ol>
	</li>
</ol>

		</section>
		<section id="interpolating-stripes">
<h3 title="Interpolating stripes()">7.4. `stripes$f の補間-法</h3>

<p>
2 個の `stripes$f は、
~gradientと類似に補間でき，
一方の画像から他方へ滑らかな~animationを許容する。
ただし、
`stripes$f どうしの補間が許容されるためには，次に挙げる少数の制約がある：
◎
Similar to gradients, two stripes() can be interpolated, allowing for smooth animations from one image to another. There are only a few restrictions on what stripes() are allowed to be interpolated:
</p>
<ul>
	<li>
引数【！Both the starting and ending image】を成す `color-stripe$t の個数は互いに同じでなければナラナイ。
◎
Both the starting and ending image must have the same number of &lt;color-stripe&gt;s.
</li>
	<li>
対応する `color-stripe$t を成す太さの型は互いに同じ
— すなわち，［
どちらも `length-percentage$t ／ どちらも `flex$t
］ —
でなければナラナイ。
◎
Each pair of interpolated thicknesses must be of the same type, i.e. both must either be of type &lt;length-percentage&gt;, or &lt;flex&gt;.
</li>
</ul>

<p>
両~画像が：
◎
↓</p>
<ul>
	<li>
上の拘束をいずれも満たす場合、
以下に述べるとおりに補間するモノトスル。
◎
If the two images satisfy both constraints, they must be interpolated as described below.＼
</li>
	<li>
1 個目の拘束しか満たさない場合、
50% の所で一足飛びに遷移するモノトスル
（将来の仕様により他が指定されない限り）。
◎
If they fail the second one only, they must be abruptly transitioned at 50% (unless otherwise specified by a future specification).＼
</li>
	<li>
他の場合、
汎用な画像~用の `cross-fade$f を利用して補間するモノトスル
◎
If they fail the first constraint, they must be interpolated using cross-fade() as for generic images.
</li>
</ul>

<p class="note">注記：
50% の所で一足飛びに遷移させるのは、
内容が~cross-fadeに依拠しないようにして，将来に［
この事例~用に，もっと賢い補間~規則を追加できるようにする
］ためである。
◎
Note: The abrupt transition at 50% is so that content will not rely on cross-fading, and smarter interpolation rules can be added for this case in the future.
</p>

<ol>
	<li>
画像を成す各~縞（ `color-stripe$t ）【！component and stripe】は、
独立に補間する。
◎
Interpolate each component and stripe of the images independently.
</li>
	<li>
<p>
縞を補間するときは、［
開始~画像, 終了~画像
］内の同じ~indexにある各~縞~pairに対し，その［
太さ, 色
］を独立に補間する。
</p>

<p class="trans-note">【
太さは `length^t 値の`補間-法＠~CSSVAL#combine-dimensions$,
色は`色の補間-法＠~CSSCOLOR#interpolation$
に従うことになろう。
】</p>
◎
To interpolate a stripe, first match each stripe in the start image to the corresponding stripe at the same index in the end image. Then, for each pair of stripes, interpolate the thickness and color independently.
</li>
</ol>

		</section>
	</section>
	<section id="serialization">
<h2 title="Serialization">8. 直列化</h2>

<p class="trans-note">【
この節の他の内容は、
次も適用されることを除き，
`~level 3 と同じ＠~CSSIMAGE#serialization$
（なので、和訳は省略する）。
（しかしながら、
下の例における結果は，~level 3 と一致していない【！`7728$issue】。）
】</p>

<p>
`cross-fade$f に対しては、
常に `percentage$t も直列化する。
◎
For cross-fade(), always serialize the &lt;percentage&gt;.
</p>

<div class="example">
<p>
例えば，次のように指定された~gradientは：
◎
For example, a gradient specified as:
</p>

<pre class="lang-css">
Linear-Gradient( to bottom, red 0%,yellow,black 100px)
</pre>

<p>
次のように直列化するモノトスル：
◎
must serialize as:
</p>

<pre class="lang-css">
linear-gradient(rgb(255, 0, 0), rgb(255, 255, 0), rgb(0, 0, 0) 100px)
</pre>
</div>

	</section>
	<section id="deprecated">
<h2 title=" Appendix A: Deprecated Features and Aliases"> 付録 A. 非推奨にされた特能と別名</h2>

<p>
実装は、
構文解析-時における `image-set$f の別名として，
`-webkit-image-set@f
を受容するモノトスル
（それは、
引数も `image-set^f と一致する妥当な値であり，
構文解析の間に `image-set^f に転換される。）
◎
Implementations must accept -webkit-image-set() as a parse-time alias of image-set(). (It’s a valid value, with identical arguments to image-set(), and is turned into image-set() during parsing.)
</p>

	</section>
	<section id="privacy">
<h2 title="Privacy Considerations">~privacyの考慮点</h2>

<p class="note">注記：
`~level 3 と同じ＠~CSSIMAGE#priv-sec$。
◎
Note: No change from [css-images-3].
</p>

	</section>
	<section id="security">
<h2 title="Security Considerations">~securityの考慮点</h2>

<p class="note">注記：
`~level 3 と同じ＠~CSSIMAGE#priv-sec$。
◎
Note: No change from [css-images-3].
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-20230217">
`2023年 2月 17日 作業草案＠~TR/2023/WD-css-images-4-20230217/$
からの変更点
◎
Changes Since the 17 February 2023 Working Draft
</dt>
	<dd>
［
`radial-gradient(circle …)^v ／ `radial-gradient(ellipse …)^v
］用に［
`percentage$t 値／ 2 個の `radial-extent$t が成す値
］を追加した
— `radial-gradient$f が `basic-shape$t 用の値［
`circle$f ／ `ellipse$f
］と整合するよう。
（ `824$issue ）
◎
Added &lt;percentage&gt; values to radial-gradient(circle), and dual &lt;radial-extent&gt; values to radial-gradient(ellipse) to make radial-gradient() consistent with the circle() and ellipse() &lt;basic-shape&gt;s. (Issue 824)
</dd>

	<dt id="changes-20170413">
`2017年 4月 13日 作業草案＠~TR/2017/WD-css-images-4-20170413/$
からの変更点
◎
Changes Since the 13 April 2017 Working Draft
</dt>
	<dd>
`§ ~gradient色の定義-法＠#gradient-colors$に対する編集上の大幅な書き直し。
◎
Major editorial rewrite of § 3.5 Defining Gradient Color.
</dd>
	<dd>
`image-1D$t ~data型, `stripes$f 関数を追加した。
（ `2532$issue ）
◎
Added new &lt;image-1D&gt; data type and stripes() function. (Issue 2532)
</dd>
	<dd>
すべての~gradient関数に
`color-interpolation-method$t を追加した。
（ `6094$issue, `6667$issue ）
◎
Added &lt;color-interpolation-method&gt; to all gradient functions. (Issues 6094, 6667)
</dd>
	<dd>
新たに `object-view-box$p ~propを追加した【が、~level 5 へ先送りされた】。
（ `7058$issue ）
◎
Added new object-view-box property. (Issue 7058)
</dd>
	<dd>
<p>
`image-set$f の定義を `css-images-3$r から取り込んだ。
◎
Pulled definition of image-set() from [css-images-3] and:
</p>
		<ul>
			<li>
`image-set$f に `type$f を追加した。
（ `656$issue ）
◎
Added type() to image-set(). (Issue 656)
</li>
			<li>
互換性を得るための別名として，
`-webkit-image-set$f 追加した。
（ `6285$issue ）
◎
Added the -webkit-image-set() compatibility alias. (Issue 6285)
</li>
		</ul>
	</dd>
	<dd>
<p>
`cross-fade$f の定義を `css-images-3$r から取り込んだ。
◎
Pulled definition of cross-fade() from [css-images-3] and:
</p>
		<ul>
			<li>
`cross-fade$f は 1 個以上の引数をとることを明確化した。
◎
Clarified that cross-fade() takes 1+ arguments.
</li>
			<li>
画像に加えて，色の混合も許容するよう更新した。
◎
Updated to allow mixing colors as well as images.
</li>
			<li>
新たな関数~引数の~sizingと塗ngを詳細に定義した。
◎
Defined sizing and painting of the new function arguments in detail.
</li>
			<li>
`cross-fade$f 画像の混色-法の不正な定義を修正した。
◎
Fixed incorrect definition of cross-fade() image blending.
</li>
			<li>
算出において計画-中にある［
単純~化と比較
］についての課題を追加した。
（ `2852$issue ）
◎
Add issue about computation planned simplification and comparison. (Issue 2852)
</li>
		</ul>
<p>
（ `Minutes＠https://lists.w3.org/Archives/Public/www-style/2018Jul/0024.html$,
`Changeset＠https://github.com/w3c/csswg-drafts/commit/ab20b4cbccf41db8e61850f58b2f1c1afc6ec66a$ ）
◎
(Minutes, Changeset)
</p>
	</dd>
	<dd>
画像の［
`§ 補間＠#interpolation$, `§ 直列化＠#serialization$
］を `css-images-3$r から取り込んだ。
◎
Pulled interpolation and serialization of images from [css-images-3].
</dd>
	<dd>
画像~dataより後に配置された画像~metadataは、
無視されるベキであるものと定義した
— ~level 3 の `§ 画像~metadata＠~CSSIMAGE#url-metadata$を見よ。
（ `4929$issue ）
◎
Defined that image metadata placed after the image data should be ignored, see CSS Images 3 § 2.1.2 Image Metadata. (Issue 4929)
</dd>
	<dd>
<p>
画像の読込n法を定義した
（ `1984$issue ）：
◎
Defined image loading. (Issue 1984)
</p>
		<ul>
			<li>
`読込n中の画像$の定義を `css-images-3$r から複製した。
◎
Copied definition of loading image from [css-images-3].
</li>
			<li>
読込n法と~errorの取扱いを `image$f 挙動の中へ統合した。
◎
Integrated loading and error handling into image() behavior.
</li>
			<li>
別の画像を置換する新たな画像を読込む間は，古い画像を描画することを明示的に~UAに許容した。
◎
Explicitly allow UA to render the old image while a new image loads in to replace another.
</li>
			<li>
`§ 外部~画像の~fetch法＠#fetching-images$を適正に定義した。
（ `562$issue, `6715$pull ）
◎
Properly defined § 2.3 Fetching External Images. (Issue 562, Pull Request 6715)
</li>
		</ul>
	</dd>
	<dd>
`CSS$I ~interfaceを名前空間に更新した。
（ `437$pull ）
◎
Updated CSS interface to a namespace. (Issue 437)
</dd>
	<dd>
単位なしの 0 を［
`conic-gradient$f における `angle$t 値を表現する値
］として許容した。
（ `1162$issue,
`変更点＠https://github.com/w3c/csswg-drafts/commit/edb0b3090bdd73abb765023475e58afe52c701b9$ ）
◎
Allowed unitless zero to represent &lt;angle&gt; values in conic-gradient(). (Issue 1162, Changes)
</dd>
	<dd>
`object-fit$p において，
`scale-down$v を他の値と組合せることを許容した。
（ `1578$issue ）
◎
Allowed scale-down to be combined with other values in object-fit. (Issue 1578)
</dd>
	<dd>
`image$t ~data型に欠落った `element()$t を追加した。
（ `5170$issue ）
◎
Added missing &lt;element()&gt; to &lt;image&gt; data type. (issue 5170)
</dd>
	<dd>
`elementSources$m の~IDL定義を修正した。
◎
Fixed elementSources IDL definition.
</dd>
	<dd>
文法における誤り
— `色停$の位置を義務的にしていた誤り —
を修正した。
（ `1334$issue ）
◎
Fixed grammar error requiring color stop positions to be mandatory. (Issue 1334)
</dd>
	<dd>
<p>
~prop定義~表tを更新した：
◎
Updated property definition tables to:
</p>
		<ul>
			<li>
［
“算出d値”, “~animation型”
］~~欄を他の~moduleと揃えた。
言い回しを整備した。
誤りを正した。
◎
Align “Computed Value” and “Animation Type” lines across modules, tighten wording, and correct errors.
</li>
			<li>
適切な所では、
新たな`角括弧付き範囲~記法$を利用した。
◎
Use the new CSS bracketed range notation where appropriate.
</li>
			<li>
“媒体” ~~欄を落とした。
◎
Drop “Media” lines.
</li>
		</ul>
	</dd>
	<dd>
“内在的~寸法” を`生来な寸法$に改称した
— `内在的~size$との混同を避けるため。
（ `4961$issue ）
◎
Renamed “intrinsic dimensions” to natural dimensions to avoid confusion with intrinsic sizes. (Issue 4961)
</dd>
	<dd>
`image$t の算出d値の定義を `css-images-3$r から複製した。
（ `4042$issue ）
◎
Copied over definition of computed &lt;image&gt; from [css-images-3]. (Issue 4042)
</dd>
	<dd>
~gradientにおける~dither法を明示的に許容した。
（ `4793$issue ）
◎
Explicitly allowed dithering in gradients. (Issue 4793)
</dd>
	<dd>
各種~markupを修正した。
~prop構文を正した。
課題を~inline化した。
綴りを正した。
例を修正して改善した。
軽微な編集上の精緻化。
◎
Assorted markup fixes, corrections to property syntaxes, inline issues, spelling corrections, example fixes and improvements, and minor editorial refinements.
</dd>
	<dd>
~moduleの~titleを短縮した。
◎
Shortened module title.
</dd>

	<dt id="changes-20120911">
`2012年 9月 11日 作業草案＠~TR/2012/WD-css4-images-20120911/$
からの変更点
◎
Changes Since the 11 September 2012 Working Draft
</dt>
	<dd>
`遷移~hint$を追加した。
◎
Added color interpolation hints
</dd>
	<dd>
~gradientの色停に
`2 個の所在による構文＠#color-stop-syntax$を追加した。
◎
Added the two location syntax for gradient color stops
</dd>
	<dd>
`円錐型~gradient$に開始-角度を追加した。
◎
Added start angles to conic gradients
</dd>
	<dd>
色停の位置（たち）を，色より前にも来れるようにした。
◎
The position(s) of a color stop can now come before the color
</dd>
	<dd>
~level 3 に一致する~textは、
~level 3 への参照に置換した。
◎
Text that is identical to [css-images-3] has been replaced with a reference to [css-images-3].
</dd>
	<dd>
`image-set$f の別名として，
`-webkit-image-set$f を追加した。
◎
Added the -webkit-image-set() alias.
</dd>

	<dt id="changes-3">
~level 3 からの変更点
◎
Changes Since Level 3
</dt>
	<dd>
（~level 3 から先送りされた）
`image$f 記法を追加した。
◎
Added the image() notation (deferred from Level 3)
</dd>
	<dd>
（~level 3 から先送りされた）
`image-resolution$p ~propを追加した。
◎
Added the image-resolution property (deferred from Level 3)
</dd>
	<dd>
（~level 3 から先送りされた）
`element$f 記法を追加した。
◎
Added the element() notation (deferred from Level 3)
</dd>
	<dd>
`円錐型~gradient$を追加した。
◎
Added conic gradients
</dd>
	<dd>
すべての~gradient関数に
`color-interpolation-method$t を追加した
◎
Added &lt;color-interpolation-method&gt; to all gradient functions
</dd>
</dl>

	</section>
</main></div>
