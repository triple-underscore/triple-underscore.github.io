<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS Images Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>

#_dgm-efunc2 {
	position: relative;
	overflow: hidden;
	width: 24em;
	padding: 1.5em;
}

._ex-efunc-src {
	position: absolute;
	top: 0;
	left: 0;
	width: 12em;
	height: 3em;
	color: white;
	background: lime;
}
#_ex-efunc-dst {
	position: relative;
	color: black;
}

</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>


Util.ready = function(){
	var source_data = {
		collectParts: Util.collectParts,
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: XXXXX spec
}


function expand(){
	var link_map = this.link_map;
	var class_map = {
		p: 'property',
		f: 'func',
		t: 'type', // value type
		u: 'unit',
		vt: 'type',
		ft: 'type',
		v: 'value',
		P: 'production',
		css: 'css',
		e: 'element',
		a: 'attr',
		et: 'event-type',
	};
	var tag_map = {
		p: 'code',
		t: 'var',
		vt: 'var',
		ft: 'var',
		css: 'code',
		f: 'code',
		d: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		u: 'code',
		f: 'code',
		v: 'code',
		I: 'code',
		m: 'code',
		et: 'code',
		P: 'var',
		V: 'var',
	}

	return this.html.replace(
		/%\w+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];


switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 't': // typedef
	text = '&lt;' + key + '&gt;';
	break;
case 'vt': // css values
	text = '&lt;' + key + '&gt;';
	break;
case 'f': // funcdef
	text = key + '()';
	break;
case 'ft': // funcdef
	text = '&lt;<code class="func">' + key + '()</code>&gt;';
	klass='f';
	break;
case 'P': // token
	text = '&lt;' + key + '&gt;';
	break;
case 'L3':
	return (
'<p class="note">注記： <a href="#biblio-css3-images">[css3-images]</a> と<a href="~CSSIMAGE#' + key + '" >同じ</a>。<span lang="en">Note: No change from [css3-images].</span></p>'
	);
	break;
case 'dgm':
	return '<a id="_dgm-' + key + '">＊</a>';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Images Module Level 4
spec_date:2018-01-30
trans_update:2017-08-13
page_state_key:CSS
original_url:https://drafts.csswg.org/css-images-4/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
site_nav:paint,css
conformance:css
copyright:2018,permissive
trans_1st_pub:2017-04-24


●●original_id_map


●●link_map



I.CSS:~CSSOM1#namespacedef-css
SameObject:~WEBIDL#SameObject
m.elementSources:#dom-css-elementsources

a.dir:~HTMLdom#the-dir-attribute
e.canvas:~HEcanvas#the-canvas-element
e.p:~HEgrouping#the-p-element
e.img:~HEimages#the-img-element
e.video:~HEmedia#the-video-element
e.iframe:~HEembed#the-iframe-element
e.picture:~HEimages#the-picture-element
	e.ul
	e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.defs:~SVG11/struct.html#DefsElement
e.linearGradient:~SVG11/pservers.html#LinearGradientElement
e.radialGradient:~SVG11/pservers.html#RadialGradientElement
e.pattern:~SVG11/pservers.html#PatternElement
e.use:~SVG11/struct.html#UseElement

	et.click
p.object-fit:#propdef-object-fit

p.image-resolution:#propdef-image-resolution
p.background-image:~CSSBG#propdef-background-image
p.background-position:~CSSBG#propdef-background-position
p.background-color:~CSSBG#propdef-background-color
p.background-size:~CSSBG#propdef-background-size
p.cursor:~CSSUI#propdef-cursor
p.direction:~CSSWM#propdef-direction
	~CSS2VISUREN#propdef-direction
p.list-style-image:~CSSWG/css-lists-3/#propdef-list-style-image

v.snap:#valdef-image-resolution-snap
v.from-image:#valdef-image-resolution-from-image
v.transparent:~CSSCOLOR#valdef-color-transparent

v.contain:#valdef-object-fit-contain
v.cover:#valdef-object-fit-cover
v.fill:#valdef-object-fit-fill
v.none:#valdef-object-fit-none
v.scale-down:#valdef-object-fit-scale-down

t.angular-color-hint:#typedef-angular-color-hint
t.angular-color-stop-list:#typedef-angular-color-stop-list
t.angular-color-stop:#typedef-angular-color-stop
t.angular-color-stop:#typedef-angular-color-stop

t.color-stop-angle:#typedef-color-stop-angle
t.color-stop-length:#typedef-color-stop-length
t.color-stop-list:#typedef-color-stop-list
t.color-stop:#typedef-color-stop
t.gradient:#typedef-gradient
t.image-set-option:#typedef-image-set-option
t.image-src:#typedef-image-src
t.image-tags:#typedef-image-tags
t.image:#typedef-image
t.linear-color-hint:#typedef-linear-color-hint
t.linear-color-stop:#typedef-linear-color-stop

t.color:~CSSCOLOR#typedef-color
	~CSSWG/css-color-3/#valuea-def-color
t.id-selector:~SELECTORS4#typedef-id-selector

t.angle-percentage:~CSSVAL#typedef-angle-percentage
t.angle:~CSSVAL#angle-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.position:~CSSVAL#typedef-position
t.string:~CSSVAL#string-value
t.url:~CSSVAL#url-value
t.angle:~CSSVAL#angle-value
t.custom-ident:~CSSVAL#identifier-value
t.length:~CSSVAL#length-value
t.position:~CSSVAL#typedef-position
t.resolution:~CSSVAL#resolution-value
t.string:~CSSVAL#string-value
t.url:~CSSVAL#url-value

f.cross-fade:~CSSIMAGE#funcdef-cross-fade
f.image-set:#funcdef-image-set
f.url:~CSSVAL#funcdef-url
f.conic-gradient:#funcdef-conic-gradient
f.element:#funcdef-element
f.image:#funcdef-image

	f.repeating-conic-gradient:#funcdef-repeating-conic-gradient
	f.repeating-linear-gradient:#funcdef-repeating-linear-gradient
	f.repeating-radial-gradient:#funcdef-repeating-radial-gradient
	tv.angle:#valdef-conic-gradient-angle
	tv.position:#valdef-conic-gradient-position
	tv.resolution:#valdef-image-resolution-resolution


u.px:~CSSVAL#px

勾配~box:#gradient-box
勾配~中心:#conic-gradient-gradient-center
勾配~線:#gradient-line
画像~解像度:#image-resolution
内在~解像度:#intrinsic-resolution
無効な画像:#invalid-image
描画され:#element-not-rendered
塗り~source:#paint-source

~fallback色を伴う~URL:#image-notation
装飾限界~box:#decorated-bounding-box

始点:#starting-point
終点:#ending-point

	§勾配~notation:#gradients
	§~image~notation:#image-notation
	§2.3.3 Solid-color Images:#color-images
	＊rendering of another element in the document:#element-notation
	＊repeating gradients:#repeating-gradients

塗り~source:#paint-source

円錐型~勾配:#conic-gradients
色~補間~hint:#color-interpolation-hint
色停:#color-stop
色停~list:#color-stop-list

	＊two location syntax:#color-stop-syntax
	＊color interpolation hints:#color-stop-syntax

~border画像~区画:~CSSBG#border-image-area

積層~文脈:~CSS2VISUREN#x43

媒体~素片~識別子:~TR/media-frags/#naming-space
媒体~素片:~TR/media-frags/

利用単位:~SVG11/coords.html#Units
塗り~server:~SVG11/pservers.html
~secure~animate化~mode:~TR/svg-integration/#secure-animated-mode
~secure静的~mode:~TR/svg-integration/#secure-static-mode

	:~TR/SVGTiny12/intro.html#TermDecoratedBoundingBox
	CSS:http://www.w3.org/TR/CSS/
	HTML5:http://www.whatwg.org/specs/web-apps/current-work/multipage/
	all elements:~CSSWG/css-pseudo/#generated-content

	:~TR/2012/WD-css4-images-20120911/
	:images/sprites.svg
	<color-hint> <color-hint>:
	<color-stop> <color-stop>:

主要~box:~CSSDISP#principal-box

~url参照:~CSSIMAGE#url-notation
実obj~size:~CSSIMAGE#concrete-object-size
既定の~obj~size:~CSSIMAGE#default-object-size

置換~要素:~CSSDISP#replaced-element
生成内容:~CSS22/generate.html#content
内在~寸法:~CSSIMAGE#intrinsic-dimensions
~ID選択子:~SELECTORS4#id-selector


●●words_table1


●●words_table


	●幾何
2D:
寸法:dimension:~
軸:axis:~
	軸に~~平行な:axis-aligned
縦幅:height:~
横幅:width:~
原点:origin:~
四分円:quadrant:~
左端:left:~
右端:right:~
始端:start:~
回転-:rotate::回転
回転:rotation::~

区画:area::~
辺:edge::~

開始-:start:~
外側:outside:~
側:side:~
矩形:rectangle:~

裏返され:flip され:~
裏返して:flip して:~

座標系:coordinate system:~
左上隅:top left corner:~
変形-:transform:~
方位:orientation:~
方位-:orient:~
角度:angle:~

	●値／スカラー／比較
無限:infinite:~
	広さ無限:infinite
補間-:interpolate:~
補間:interpolation:~

単位:unit:~
利用単位:user coordinate:~
値:value:~
丸めた:round した:~
長さ:length:~

	●画像／色／勾配
画像:image::~:イメージ
raster:::ラスター
	~raster化:rasterization
vector:::ベクター
解像度:resolution::~
画素:pixel::~
機器:device::~:デバイス
素片:fragment::~:フラグメント
断片:fragment::~:フラグメント
dot:::ドット
	ドット数:dots
勾配:gradient:::グラデーション
円錐型:conic::~
品質:quality:~

	●色
色:color::~:カラー
	色~付け:colored
色停:color-stop::~:カラーストップ
単色:solid-color::~:ソリッドカラー
所在:location::~

透明度:transparency::~
透明:transparent::~
半透明:partially-transparent::~
黒色:black:~
白色:white:~

	●CSS layout
	置換内容:replaced content::~
	置換要素:replaced element::~
置換-:replace:~
置換:replaced:~
行内:inline::~:インライン
obj:object::オブジェクト
layout:::レイアウト
box:::ボックス
size:::サイズ
sizing:::サイズ法
slice:::スライス

	overlay
border:::ボーダー
方向:direction::~
方向性:directionality::~
	逆~方向の:opposite direction
	向きのある:directional
背景:background::~
位置:position::~
内在:intrinsic::~
内在的:intrinsic::~
縦横比:aspect ratio::~:アスペクト比
文脈:context::~
可視:visible::~
視覚的:visual::~

包含-:contain:~
包含塊:containing block:~

実obj:concrete object::実オブジェクト
canvas:::キャンバス

生成内容:generated content::~

頁:page::ページ
頁割:pagination::ページ割り付け

装飾-:decorate::~
装飾限界:decorated bounding::~
装飾的:decorative::~
限界:bound:~

折衝:negotiation::~:ネゴシエーション

描く:draw する:~
描いた:draw した:~
描かれ:draw され:~
切抜く:clip out する:切り抜く
切抜かれ:clip out され:切り抜かれ
切取る:clip する:~
切取られ:clip され:~
埋尽く:fill し尽く:埋め尽く
接合-:flush:~
	接合-:joined flush
整形:formatting:~
積層:stacking:~
分断:break:~
	分断され:broken
表示:display:~
整列-:align:~
浮動-:float:~

主要:principal:主

	●CSS
CSS:
animation:::アニメーション
animate:::アニメート
	~animate化:animated
prop:property::プロパティ
keyword:::キーワード
記法:notation:~
名前:name:~
適用対象:applies to:~
継承:inherited:~
継承-:inherit:~
非継承:non-inherited:~
百分率:percentage:~
算出値:computed value:~
使用値:used value:~
指定値:specified value:~
初期値:initial value:~
正準的:canonical:~
正準的順序:canonical order:~
離散的:discrete:~

要素:element:~
宣言:declaration:~
	宣言-:declare:~
型:type:~
成分:component:~
属性:attribute:~
自動的:automatic:~
媒体:media::~:メディア
fallback:::フォールバック
直列化:serialization:~
	直列化-:serialize:~

子孫:descendant:~
先祖:ancestor:~
子:child:~
	子たち:children:~
選択子:selector:~::セレクタ
擬似要素:pseudo-element:~

描画-:render:~::レンダー
描画:rendering:~::レンダリング
screen:::スクリーン
紙:paper:~
言語:language:~
記述-:describe:~
静的:static:~
塗り:paint:~
server:::サーバ
左横書き:LTR:~
右横書き:RTL:~
双向性:bidi-:~
影:shadow::~
行0:line:行
柱:column::カラム
規則:rule:~

	●仕様
仕様:spec:~
model:::モデル
algo:algorithm::アルゴリズム
UA:user agent:UA
module:::モジュール
version:::バージョン
Level:
level:::レベル
host:::ホスト
特色機能:feature:~
将来の:future:~
作者:author:~
	節:section:~

適合性:conformance:~
	段:step:~
正しく:correct に:~
目的:purpose:~
通例的:usual:~
error:::エラー
明示的:explicit:~
機能性:functionality:~
能:ability:~
事例:case:~
既定:default:~
既定の:default:~
適切:appropriate:~
共通的な:common な:よくある
有意:significant:~

仕方:way:~
互換性:compatibility:~
	compat 
前方互換:forwards-compatible:~
利点:advantage:~
理由:reason:~
自立的:standalone:~
旧来:legacy:~
旧来の:legacy:~
通常通り:as normal に:~
通常の:normal な:~
通常は:normal には:~
容易:easy:~
algo:algorithm:~
疑似的な:pseudo-:~
可用:available:~
効率的:efficient:~
特別:special:~
無為:nonsensical:~
直に:direct に:~
直接的:direct:~
間接的:indirect:~
実際:actual:~
関連する:relevant な:~
課題:issue:~
選択肢:option:~
	困難な仕事:difficult task.
要因:factor:~
適正:proper:~
状況:situation:~
解決策:solution:~
判定基準:criteria:~

	十分:enough
	依然として／も:still
	補助:helpful
	易くする:help
	誤ったものに:be wrong
	簡単:simple
	例:example
	~~問題なく:fine
	〜に基づいて:based
	〜に注意。:note
	おそらく:probably
	欲され:desire
	かなり:substantially
	していく:over time
	必ずしも:necessarily:~
	要約:abstract
	可能性:possibility:~
	しかしながら，:however
	節:section
	またはそれに準じるもの:some degree of
	表す:denote
	最低限:at minimum
	最大化:maximize
	どうにかして:somehow
	に対する:compared to
	応じる:sensitive
	応じ:care
	編集者:I
	歓迎:welcome
	多くの用途に:put to many uses
	-:we
	-:my

	●仕様（動詞
support:::サポート
実装:implementation:~
	実装-:implement:~
変更点:changes:~
拡張-:extend:~
拡張:extension:~
設計-:design:~
期待-:expect:~
解釈-:interpret:~
導入-:introduce:~
	~~考えて:try:~
要求-:require:~
	要-:require:~
挙動:behavior:ふるまい
注釈:annotation:~
保守-:maintain:~
指定-:specify:~
決定-:determine:~
依存-:depend:~
	dependent
依存関係:dependency:~
定義-:define:~
定義:definition:~
適用-:apply:~
供-:provide:~
供せる:provide できる:~
供さな:provide しな:~
影響-:affect:~
考慮点:considerations:~
働く:work する:~
働かな:work しな:~
先送り:defer:~
取組む:address する:取り組む
更新-:update:~
見なさ:consider さ:~
記述-:describe:~
述べる:describe する:~
関係-:relate:~
尊守-:honor:~
見做す:assume する:~
防げる:prevent できる:~
競合-:conflict:~
意味-:mean:~
示唆:suggestion:~
依拠-:rely:~
	依拠-可能:reliable
修正-:fix:~
避ける:avoid する:~
避けた:avoid した:~
選好-:prefer:~
制約:restriction:~
利用者:user:~
取扱わな:handle しな:取り扱わな
最適化-:optimize:~
代理-:proxy:~
見做して:assume して:~
見積もり:estimation:~
働く:work する:~
受容-:accept:~

	-:predictable:~
	利用:use
	再~利用-:re-use:~
	再利用:reuse:~
	利用-法
	必要:need
	見受けられる:appears to be
	行える:can be done
	要する:requiring
	選ばれ:chosen
	見よ:see
	求まれ:want


	●未分類（動詞
誘発-:trigger:~
解決-:resolve:~
生産-:produce:~
再生産-:reproduce:~
表現-:represent:~
	表現:representation:~
算出-:compute:~
調整-:adjust:~
	~~計算
構築-:construct:~
	あたられ:consult
作成-:create:~
無視-:ignore:~
	~~指示
挿入-:insert:~
合致-:match:~::マッチ
照合-:match:~::マッチ
印刷:print:~::プリント
印刷機:printer:~::プリンタ
処理-:process:~
処理:processing:~
参照:reference:~
参照-:refer:~
参照先の:referenced:~
参照元の:referencing:~
設定-:set:~
変化-:change:~
埋込んで:embed して:埋め込んで
読込む:load する:読み込む
読込み:load :読み込み
読込め:load でき:読み込め
改め:alter し:~
改めら:alter さ:~
復号-:decode:~::デコード
失敗-:fail:~
読める:read できる:~
	readable
符号化-:encode:~::エンコード
解せな:understand できな:~
記録-:record:~
組合せる:combine する:組み合せる
見出せな:find できな:~
見出して:find して:~
見出す:find する:~
見出され:find され:~
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
	扱われ:treat され:~
追加-:add:~
追加:addition:~
追加の:additional:~

生成-:generate:~
	再~生成-:regenerate
	再~生成する場合でも、結果の:In the latter case 〜 regeneration process
複製:copy:~
反映:reflection:~
検出:detection:~
検出-:detect:~
検索-:look-up:~
結付けら:associate さ:結び付けら
対話-:interact:やりとり:~
選択-:select:~
関与-:participate:~
	変わ:vary
	等し:equal
	対応-:correspond
	探す:look for
	起こる:happen:~
	示す:show:~
	得:obtain:~
	含:include
	含めて:including:~
	指-:point
	不在:absent
	保ち続け keep track
	食い過ぎる:eats too much 
	周囲の:surrounding
	塞ぐ:slapping

	●未分類
XML:
SVG:
GCPM:
ID:
HTML:
JS:Javascript
URL:
url:
interface:::インタフェース
secure:::セキュア
mode:::モード
privacy:::プライバシー
security:::セキュリティ
download:::ダウンロード
bullet:::ビュレット
tellub:::トッレュビ
pattern:::パタン
slideshow:::スライドショー
slide:::スライド
script:::スクリプト
live:
preview:::プレビュー
view:::ビュー
handler:::ハンドラ
navigate:::ナビゲート
entry:::エントリ
key:::
fancy:
map:
graph:::グラフ
妥当:valid:~
無効:invalid:~
構文:syntax:~
構文空間:syntax-space:~
文法:grammar:~
文字列:string:~
文字:character:~
命名:naming:~
文書:document:~
	文書~外:Out-Of-Document
引数:argument:~
内容:content:~
全部的:full:~
数値的:explicit:~
上書き:override:~
	上書き法:overriding
形式:format:~::フォーマット
関数:function:~
効果:effect:~
等価:equivalent:~
	一致する:identical
情報:information:~
初期:initial:~
単純:simple:~
構造:structure:~
text:::テキスト
data:::データ
list:::リスト
item:::アイテム
metadata:::メタデータ
資源:resource::~:リソース
source:::ソース
hint:::ヒント
bitmap:::ビットマップ
code:::コード
file:::ファイル
computer-monitor:computer monitor::コンピュータモニタ
inch:::インチ
美麗:attractive:~
見かけ:look:~
外観:appearance:~
一部分:portion:~
絶対:absolute:~
相対:relative:~
整数:integer:~
構文解析:parsing:~::パース処理
背後:behind:~
識別子:identifier:~
循環:cycle:~
循環関係:circular relationship:~
矢印:arrow:~
	~~背後に回るlies beneath
	淡く染めるtinting
	画素が目立つ:pixellated
	重ねて:overlay
	一致:identical
	結果:result
	小さい:small
	通:through
	一斉に:in tandem
	X
	background-image
	against
	HTML5
	-:entirely
	Mozilla:Moz
	後続-:follow
	consist
	B
	A
	来:come

	●指示語
単独の:single:~
外部:external:~
既存の:existing:~
自前の:own:~
	最初の:first:~
	最初:first:~
	も:as well
	だけ:just
	様な:like
	何〜かに:across
	すなわち、:that is
	もっぱら:solely
	全く:at all／never 〜 at all
	先頭:beginning
	先頭の:leading
	先ず:first
	何か:something
	この:this
	いくつかの:several
	そのような:such
	等々:etc
	別の:another
	多くの／数多くの:many
	すべての:all
	他の／他方:other
	前:before
	似る:similar
	-:somewhat silly
	似た:somewhat similar
	両者:both
	1 個の:one
	その:that
	最も小さい:smallest
	同じ:same
	再~生成する場合:latter case
	他所:elsewhere
	各:each
	自身:itself
	これらの:these
	 2 個の:two
	何か:something
	次の／前の:next/previous
	複数:multiple
	代わりに:instead
	主な:main
	今や:now
	そのまま:as-is
	またがる:across
	単に:just
	数種の:handful
	あるもの／:anything
	傍:alongside

	●

送達-:deliver:~
受信-:receive:~
送信-:send:~
mobile:::モバイル
接続:connection:~
読込む:load する:読み込む
vector:::ベクター
display:::ディスプレイ
bitmap:::ビットマップ
filesize:::ファイルサイズ
入子に:nest:入れ子に

帯域幅:bandwidth:~
次元:dimension::~
icon:::アイコン
混在して:mix されて:~
速度:speed:~
	~~選択:choice
低速:slow:~
変更:change:~
変更-:change:~
高品質の:high-quality な:~
	理想的:ideal:~
	存続する:lifetime
	高
	低


●●ref_normative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS-COLOR-3]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 5 December 2017. CR. URL: https://www.w3.org/TR/css-color-3/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 July 2016. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-LISTS-3]
    Tab Atkins Jr.. CSS Lists and Counters Module Level 3. 20 March 2014. WD. URL: https://www.w3.org/TR/css-lists-3/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 22 December 2017. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-VALUES-3]
    Tab Atkins Jr.; Elika Etemad. CSS Values and Units Module Level 3. 29 September 2016. CR. URL: https://www.w3.org/TR/css-values-3/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-IMAGES]
    Elika Etemad; Tab Atkins Jr.. CSS Image Values and Replaced Content Module Level 3. 17 April 2012. CR. URL: https://www.w3.org/TR/css3-images/ 
[CSS3-TRANSFORMS]
    Simon Fraser; et al. CSS Transforms Module Level 1. 30 November 2017. WD. URL: https://www.w3.org/TR/css-transforms-1/ 
[CSSOM-1]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[MEDIA-FRAGS]
    Raphaël Troncy; et al. Media Fragments URI 1.0 (basic). 25 September 2012. REC. URL: https://www.w3.org/TR/media-frags/ 
[PNG]
    Tom Lane. Portable Network Graphics (PNG) Specification (Second Edition). 10 November 2003. REC. URL: https://www.w3.org/TR/PNG/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECT]
    Tantek Çelik; et al. Selectors Level 3. 30 January 2018. CR. URL: https://www.w3.org/TR/selectors-3/ 
[SELECTORS4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 2 May 2013. WD. URL: https://www.w3.org/TR/selectors4/ 
[SVG-INTEGRATION]
    Cameron McCormack; Doug Schepers; Dirk Schulze. SVG Integration. 17 April 2014. WD. URL: https://www.w3.org/TR/svg-integration/ 
[SVG11]
    Erik Dahlström; et al. Scalable Vector Graphics (SVG) 1.1 (Second Edition). 16 August 2011. REC. URL: https://www.w3.org/TR/SVG11/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 


●●ref_informative

[SMIL10]
    Philipp Hoschka. Synchronized Multimedia Integration Language (SMIL) 1.0 Specification. 15 June 1998. REC. URL: https://www.w3.org/TR/1998/REC-smil-19980615/ 

●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Images Module Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css4-images/

編集者草案
	https://drafts.csswg.org/css-images-4/

以前のバージョン
	https://www.w3.org/TR/2012/WD-css4-images-20120911/

最新の課題
	<a href="https://www.w3.org/Style/CSS/Tracker/products/27">Tracker</a>
	<span><a href="https://github.com/w3c/csswg-drafts/labels/css-images-4">GitHub Issues</a></span>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins Jr.</a> (Google)

	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)

	<a class="p-name fn u-url url" href="http://lea.verou.me/about">Lea Verou</a> (Invited Expert)

</script>

</head>

<body>

<div style="display:none;">

<!--%resource pool -->
	<div id="_persisted_parts">

<img
	id="_dgm-img_scale"
	height="160"
	alt="（ SVG 画像）"
	src="css-images/img_scale.svg"
	style="border: thin solid black;"
>

<pre class="lang-html" id="_dgm-efunc1">
&lt;style&gt;
#src {
    color: white;
    background: lime;
    width: 12em;
    height: 3em;
    position: relative;
}
#dst {
    color: black;
    background: element(#src);
    width: 20em;
    padding: 1.5em;
}
&lt;/style&gt;
&lt;p id='src'&gt;普通の要素です。&lt;/p&gt;
&lt;p id='dst'&gt;前の要素を背景に利用しています。&lt;/p&gt;
</pre>

<!-- 
I’m an ordinary element!
I’m using the previous element as my background!
 -->

<!-- element-function.png -->
<div id="_dgm-efunc2">
<div class="_ex-efunc-src" style="">普通の要素です。</div>
<div class="_ex-efunc-src" style="left:12em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="left:24em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em; left:12em;">普通の要素です。</div>
<div class="_ex-efunc-src" style="top: 3em; left:24em;">普通の要素です。</div>
<div id="_ex-efunc-dst">前の要素を背景に利用しています。</div>
</div>

<img
	id="_dgm-sprites"
	alt="黒い部分が次第に増える 9 個の円（ SVG 画像）"
	title="[9 circles, with 0 to 8 eighths filled in]"
	src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiCgl4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCgl4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKCXdpZHRoPSIzNjAiCgloZWlnaHQ9IjQwIgo+Cgo8ZGVmcz4KCTxwYXRoIGlkPSJIIiBkPSJNIDAgLTUgQSA1LDUgMCAwIDEgMCw1IHoiLz4KCTxnIGlkPSJISCI+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgZmlsbD0iYmxhY2siIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgZmlsbD0iI0NDQyIgdHJhbnNmb3JtPSJyb3RhdGUoMTgwKSIgLz4KCTwvZz4KPC9kZWZzPgoKPGcgdHJhbnNmb3JtPSJzY2FsZSg0KXRyYW5zbGF0ZSg1LDUpIiBzdHJva2U9Im5vbmUiPgoKCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsMCkiPgoJCTx1c2UgeGxpbms6aHJlZj0iI0hIIiAvPgoJCTx1c2UgeGxpbms6aHJlZj0iI0giIHRyYW5zZm9ybT0icm90YXRlKDApIiBmaWxsPSIjQ0NDIiAvPgoJPC9nPgoJPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTAsMCkiPgoJCTx1c2UgeGxpbms6aHJlZj0iI0hIIiAvPgoJCTx1c2UgeGxpbms6aHJlZj0iI0giIHRyYW5zZm9ybT0icm90YXRlKDQ1KSIgZmlsbD0iI0NDQyIgLz4KCTwvZz4KCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwLDApIj4KCQk8dXNlIHhsaW5rOmhyZWY9IiNISCIgLz4KCQk8dXNlIHhsaW5rOmhyZWY9IiNIIiB0cmFuc2Zvcm09InJvdGF0ZSg5MCkiIGZpbGw9IiNDQ0MiIC8+Cgk8L2c+Cgk8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzMCwwKSI+CgkJPHVzZSB4bGluazpocmVmPSIjSEgiIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgdHJhbnNmb3JtPSJyb3RhdGUoMTM1KSIgZmlsbD0iI0NDQyIgLz4KCTwvZz4KCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDQwLDApIj4KCQk8dXNlIHhsaW5rOmhyZWY9IiNISCIgLz4KCTwvZz4KCTxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDUwLDApIj4KCQk8dXNlIHhsaW5rOmhyZWY9IiNISCIgLz4KCQk8dXNlIHhsaW5rOmhyZWY9IiNIIiB0cmFuc2Zvcm09InJvdGF0ZSg0NSkiIGZpbGw9ImJsYWNrIiAvPgoJPC9nPgoJPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjAsMCkiPgoJCTx1c2UgeGxpbms6aHJlZj0iI0hIIiAvPgoJCTx1c2UgeGxpbms6aHJlZj0iI0giIHRyYW5zZm9ybT0icm90YXRlKDkwKSIgZmlsbD0iYmxhY2siIC8+Cgk8L2c+Cgk8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg3MCwwKSI+CgkJPHVzZSB4bGluazpocmVmPSIjSEgiIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgdHJhbnNmb3JtPSJyb3RhdGUoMTM1KSIgZmlsbD0iYmxhY2siIC8+Cgk8L2c+Cgk8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MCwwKSI+CgkJPHVzZSB4bGluazpocmVmPSIjSEgiIC8+CgkJPHVzZSB4bGluazpocmVmPSIjSCIgdHJhbnNmb3JtPSJyb3RhdGUoMTgwKSIgZmlsbD0iYmxhY2siIC8+Cgk8L2c+CjwvZz4KCjwvc3ZnPg=="
>

	</div>
</div>

<header>
	<hgroup>
<h1>CSS Images Module Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この~moduleは、 `image$t 型と`置換~要素$に関係する~CSS~level 4 の特色機能を包含する。
それは、~CSS~level 2 `CSS21$r と この仕様の~level 3 `css3-images$r の機能性を含み，それを拡張する。
~level 3 からの主な拡張は、
`image$t 型に対する `image$f 記法, `element$f 記法などの追加，および
円錐型~勾配である。
◎
This module contains the features of CSS level 4 relating to the &lt;image&gt; type and replaced elements. It includes and extends the functionality of CSS level 2 [CSS21] and in the previous level of this specification [css3-images]. The main extensions compared to "CSS Images Module Level 3" [css3-images] are several additions to the &lt;image&gt; type, such as the image() notation, the element() notation, and conic gradients.
</p>

~CSSisaLANG

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
これは編集者草案の公開の複製です…
<!-- 
この節では、発行時点における…
 -->
【以下，この節の他の内容は <a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>に委譲。】
</p>

	</section>


<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
この~moduleは~2D画像を表現するための追加の仕方を導入する
例えば，
`~fallback色を伴う~URL$ ／
`円錐型~勾配$として ／
<a href="#element-notation">文書~内の別の要素の描画</a>として。
◎
This module introduces additional ways of representing 2D images, for example as a URL with color fallback, as conic gradients, or as the rendering of another element in the document.
</p>

	</section>
	<section id="image-values">
<h2 title="Image Values: the &lt;image&gt; type">2. 画像~値： `image^t 型</h2>

<p>
`image$t 値~型は、~2D画像を表し，［
`~url参照$ ／
`~fallback色を伴う~URL$ ／
<a href="#gradients">勾配~記法</a>
］をとり得る。
その構文は、次で与えられる：
◎
The &lt;image&gt; value type denotes a 2D image. It can be a url reference, image notation, or gradient notation. Its syntax is:
</p>


<pre class="prod">
`image@t = `url$t | `image$ft | `image-set$ft | `cross-fade$ft | `gradient$t
</pre>


<p>
`image$t は、［
`background-image$p, `list-style-image$p, `cursor$p
］~prop
`CSS21$r
なども含め，数多くの~CSS~propにて利用できる（それらの値~内の `url$t 成分を置換する）。
◎
An &lt;image&gt; can be used in many CSS properties, including the background-image, list-style-image, cursor properties [CSS21] (where it replaces the &lt;url&gt; component in the property’s value).
</p>


<p>
一部の事例では、妥当な画像~形式でない資源を指している `url$t など，画像は無効になる。
`無効な画像@
は、内在~寸法を伴わない，単色の `transparent$v 画像として描画される。
しかしながら， `image$f 記法などの一部の文脈~下では、`無効な画像$には特別な挙動がある。
◎
In some cases, an image is invalid, such as a &lt;url&gt; pointing to a resource that is not a valid image format. An invalid image is rendered as a solid-color transparent image with no intrinsic dimensions. However, invalid images have special behavior in some contexts, such as the image() notation.
</p>


		<section id="image-file-formats">
<h3 title="Image File Formats">2.1. 画像~file形式</h3>

<p>
~propにおいて `image$t 値から参照~される妥当な画像に対しては、~UAは，最低限，次の~file形式を~supportし~MUST：
◎
At minimum, the UA must support the following image file formats when referenced from an &lt;image&gt; value, for all the properties in which using &lt;image&gt; is valid:
</p>

<ul>
	<li>
`PNG$r により指定される， PNG
◎
PNG, as specified in [PNG]
</li>
	<li>
`SVG11$r により指定される，`~secure静的~mode$を利用している~SVG（ `SVG-INTEGRATION$r を見よ）
◎
SVG, as specified in [SVG11], using the secure static mode (See [SVG-INTEGRATION])
</li>
	<li>
~UAが~animate化 `image$t を~supportする場合、
`SVG11$r により指定される，`~secure~animate化~mode$を利用している~SVG（
`SVG-INTEGRATION$r を見よ）
◎
If the UA supports animated &lt;image&gt;s, SVG, as specified in [SVG11], using the secure animated mode (See [SVG-INTEGRATION])
</li>
</ul>

<p>
~UAは、他の~file形式を~supportしても~MAY。
◎
The UA may support other file formats as well.
</p>



		</section>
		<section id="url-notation">
<h3 title="Image References: the url() notation">2.2. 画像~参照： `url^f 記法</h3>

`url-notation^L3

		</section>
		<section id="image-set-notation">
<h3 title="Resolution Negotiation: the image-set() notation">2.3. 解像度の折衝： `image-set^f 記法</h3>

<p>
利用者の機器に最も適切な解像度の画像を送達することは、困難な仕事にもなり得る。
理想的には、画像~解像度は、利用者~間で様々な，機器それぞれの解像度と同じになるべきである。
しかしながら、送信する画像をどれにするか決める要因になるものは、他にもあり得る
— 例えば，低速な~mobile接続の下では、利用者は，解像度は適正でも，巨大になる画像を読込むのを待つより，低~解像度の画像を受信する方を選好するかもしれない。
`image-set$f 関数により、作者は，これらの課題のほとんどを無視して、単に，画像に複数の解像度を供することで，与えられた状況で最も適切なものを UA に決めさせることが可能になる。
◎
Delivering the most appropriate image resolution for a user’s device can be a difficult task. Ideally, images should be in the same resolution as the device they’re being viewed in, which can vary between users. However, other factors can factor into the decision of which image to send; for example, if the user is on a slow mobile connection, they may prefer to receive lower-res images rather than waiting for a large proper-res image to load. The image-set() function allows an author to ignore most of these issues, simply providing multiple resolutions of an image and letting the UA decide which is most appropriate in a given situation.
</p>

<p class="issue">
この解決策は、解像度が~filesizeを代理するものと見做しているので、［
複数の解像度からなる一連の~vector画像や,
一連の画像に~vectorと~rasterが混在しているとき（例えば~icon）
］を，適切に取扱わない。
例えば、高~解像度 向けには~vector画像,
低~解像度 向けには画素に最適化された~bitmap,
低~帯域幅 向けには同じ~vector画像（高~解像度であってもずっと小さいので）など。
◎
This solution assumes that resolution is a proxy for filesize, and therefore doesn’t appropriately handle multi-resolution sets of vector images, or mixing vector images with raster ones (e.g. for icons). For example, use a vector for high-res, pixel-optimized bitmap for low-res, and same vector again for low-bandwidth (because it’s much smaller, even though it’s higher resolution).
</p>

<p>
`image-set^f の構文は：
◎
The syntax for image-set() is:
</p>



<pre class="prod">
`image-set@f
    = image-set( `image-set-option$t# )
`image-set-option@t
    = [ `image$t | `string$t ] `resolution$t
</pre>

<p class="issue">
~HTMLの `picture$e 要素の機能性に合致させるため、
`w^u ／ `h^u 次元, および `format^f 関数
を追加すべき。
◎
We should add "w" and "h" dimensions as a possibility, and a "format()" function, to match the functionality of HTML’s picture.
</p>

<p>
`image-set$f 関数は、直接的にも（他の `image$t 型の引数として）間接的にも，入子にできない。
◎
The image-set() function can not be nested inside of itself, either directly or indirectly (as an argument to another &lt;image&gt; type).
</p>

<p class="issue">
この制約は必要か？
◎
Is this restriction needed?
</p>

<p>
`image-set$f の中の各 `string$t は、 `url$t を表現する。
◎
Each &lt;string&gt; inside image-set() represents a &lt;url&gt;.
</p>

<p>
`image-set$f 関数~内の各 `image-set-option$t の `resolution$t は，互いに異なら~MUST
— さもなければ，関数は無効になる。
◎
Every &lt;image-set-option&gt; in a given image-set() must have a different &lt;resolution&gt;, or else the function is invalid.
</p>

<p>
~UAは、どの `image-set-option$t を読込むかについて、自身に関連する判定基準（~displayの解像度, 接続~速度, 等々）を何であれ見出して，それに基づいて選ば~MUST。
しかる後、 `image-set$f は，その~~選択に結び付けられている画像を表現し、その`内在~解像度$は，その~~選択に結び付けられている解像度になる。
~UAは、頁が存続する間，与えられた `image-set$f に対し利用する `image-set-option$t を，変更して<strong>よい</strong>
— 選択肢を選ぶために利用された判定基準が，~UAの見積もりにおいて変更に価する程に十分~変化したならば。
◎
UAs must make a UA-specific choice of which &lt;image-set-option&gt; to load, based on whatever criteria they find relevant (such as the resolution of the display, connection speed, etc). The image-set() then represents the image associated with the URL of that choice. The image’s intrinsic resolution is the resolution associated with that choice. UAs may change which &lt;image-set-option&gt; they wish to use for a given image-set() over the lifetime of the page, if the criteria used to determine which option to choose change significantly enough to make it worthwhile in the UA’s estimation.
</p>

<div class="example">
<p>
次の例に、 `image-set$f を用いて 3 種の画像を供する方法を示す。
“通常”, “高~解像度”, （高品質の印刷~用の） “極高~解像度” （印刷機は <em>極めて</em> 高い解像度を持ち得るので）：
◎
This example shows how to use image-set() to provide an image in three versions: a "normal" version, a "high-res" version, and an extra-high resolution version for use in high-quality printing (as printers can have extremely high resolution):
</p>

<pre class="lang-css">
background-image: image-set(
    "foo.png" 1x, "foo-2x.png" 2x, "foo-print.png" 600dpi
);
</pre>
</div>

		</section>
		<section id="image-notation">
<h3 title="Image Fallbacks and Annotations: the image() notation">2.4. 画像~fallbackと注釈： `image^f 記法</h3>

<p>
`image$f 関数により、作者は次が可能になる：
◎
The image() function allows an author to:
</p>


<ul>
   <li>
`媒体~素片$を利用して、画像の一部分を切抜く。
◎
use media fragments to clip out a portion of an image
</li>
	<li>
単色を画像として利用する。
◎
use a solid color as an image
</li>
	<li>
指定された URL にある画像が［
~downloadできない, または復号できない
］ときの，単色~画像への~fallbackを指定する。
◎
fallback to a solid-color image, when the image at the specified url can’t be downloaded or decoded
</li>
	<li>
画像の~metadataに指定されている画像の方位に，自動的に従うようにする。
◎
automatically respect the image orientation specified in the image’s metadata
</li>
</ul>

<p>
`image$f 記法は，次で定義される：
◎
The image() notation is defined as:
</p>

<pre class="prod">
`image@f = image( `image-tags$t? [ `image-src$t? , `color$t? ]! )
`image-tags@t = [ ltr | rtl ]
`image-src@t = [ `url$t | `string$t ]
</pre>


<p>
`image$f 内で利用される `string$t は、 `url$t を表現する。
CSS における通例的な~URLと同様、
`image$f 値に指定された相対~URLは，算出値を得るときに（ “値と単位” 仕様 `css-values-3$r に従って）絶対~URLに解決される。
◎
A &lt;string&gt; used in image() represents a &lt;url&gt;. As usual for URLs in CSS, relative URLs are resolved to an absolute URL (as described in Values &amp; Units [css-values-3]) when a specified image() value is computed.
</p>

<p>
EXIF などの画像の~metadataにて，方位が指定されている場合、~UAは，その~metadataの指定に従って，画像を回転させたり裏返して 正しく方位させ~MUST。
◎
If the image has an orientation specified in its metadata, such as EXIF, the UA must rotate or flip the image to correctly orient it as the metadata specifies.
</p>

			</section>
			<section id="image-fallbacks">
<h4 title="Image Fallbacks">2.4.1. 画像の~fallback</h4>

<p>
`image$f に~URLと `color$t の両者が指定された下で，~URLが`無効な画像$を表現するときには、 `image$f 関数は，URL が元々指定されていなかったかのように
<a href="#color-images">単色の画像</a>
を描画する。
◎
If both a URL and a &lt;color&gt; are specified in image(), then whenever the URL represents an invalid image, the image() function renders as if the URL were not specified at all; it generates a solid-color image as specified in §2.3.3 Solid-color Images.
</p>

<div class="example">

<p>
~fallback色を利用すれば、画像の読込みに失敗したときでも，少なくとも~textは読めるようになる。
例えば次の旧来~codeは、画像が透明度を持たない矩形であれば，~~問題なく働く。
◎
The fallback color can be used to ensure that text is still readable even when the image fails to load. For example, the following legacy code works fine if the image is rectangular and has no transparency:
</p>

<pre class="lang-css">
body      { color: black; background: white; }
p.special { color: white; background: url("dark.png") black; }
</pre>

<p>
画像が読込めなくても、背景~色により，依然として白色~textは読める。
しかしながら，画像に透明度がある場合、背後の黒色が可視になり，おそらく欲されない結果になる。
`image$f 関数は、これに取組む：
◎
When the image doesn’t load, the background color is still there to ensure that the white text is readable. However, if the image has some transparency, the black will be visible behind it, which is probably not desired. The image() function addresses this:
</p>


<pre class="lang-css">
body      { color: black; background: white; }
p.special { color: white; background: image("dark.png", black); }
</pre>


<p>
今度は、画像を読込めたときには黒色は全く現れなくなる一方、何らかの理由で画像の読込みに失敗した場合には，黒色がそれに代わり，白色~背景に白色~textが設定されるのを防げる。
◎
Now, the black won’t show at all if the image loads, but if for whatever reason the image fails, it’ll pop in and prevent the white text from being set against a white background.
</p>

</div>

			<section id="image-fragments">
<h4 title="Image Fragments">2.4.2. 画像~断片</h4>

<p>
`image$f に指定された~URLが，（例えば，`媒体~素片~識別子$の利用により）資源の一部分を表現するとき、その一部分は，その文脈から切抜かれた上で，自立的な画像として利用されるようになる。
◎
When a URL specified in image() represents a portion of a resource (e.g. by the use of media fragment identifiers) that portion is clipped out of its context and used as a standalone image.
</p>

<div class="example">
<p>
例えば，次の画像と~CSSが与えられたとする：
◎
For example, given the following image and CSS:
</p>

<figure>
`sprites^dgm
</figure>

<pre class="lang-css">
background-image: image('sprites.svg#xywh=80,0,40,40')
</pre>

<p>
要素の背景は、この画像の， ( 80px, 0px ) の所から，右下へ高さ幅ともに 40px の部分（画像の中では黒の四分円）で埋尽くされることになる。
◎
...the background of the element will be the portion of the image that starts at (40px,0px) and is 20px wide and tall, which is just the circle with a quarter filled in.
</p>

</div>

<p>
作者が，~CSSの前方互換な構文解析~規則の利点を活かして，画像~slice用の~fallbackを供せるようにするため、 `image$f 記法を~supportする実装は，［
`image$f を通して指定された画像
］に対する
`xywh=<var>#,#,#,#</var>^c
形による`媒体~素片~識別子$ `MEDIA-FRAGS$r を~supportし<em>~MUST</em>。
◎
So that authors can take advantage of CSS’s forwards-compatible parsing rules to provide a fallback for image slices, implementations that support the image() notation must support the xywh=#,#,#,# form of media fragment identifiers for images specified via image(). [MEDIA-FRAGS]
</p>

<div class="example">

<p>
画像~断片は `url$f 記法でも利用し得ることに注意。
しかしながら、`媒体~素片$ 記法を解せない旧来の~UA は，素片を無視して，単純に画像~全体を表示することになる。
◎
Note that image fragments can also be used with the url() notation. However, a legacy UA that doesn’t understand the media fragments notation will ignore the fragment and simply display the entirety of the image.
</p>

<p>
`image$f 記法は~UA による`媒体~素片$の~supportを要するので、作者は，画像~素片~URLを利用する際に，~fallbackを供する CSS の前方互換な構文解析~規則の利点を活かせる：
◎
Since the image() notation requires UAs to support media fragments, authors can take advantage of CSS’s forward-compatible parsing rules to provide a fallback when using an image fragment URL:
</p>

<pre class="lang-css">
background-image: url('swirl.png'); /* 旧~UA */
background-image: image('sprites.png#xywh=10,30,60,20'); /* 新~UA */
</pre>

</div>


<p>
~URLに利用されている素片~識別子の構文が，実装が解せない, あるいはその画像~型において妥当でない場合、その~URLは，`無効な画像$を表現しているものと扱われ~MUST。
◎
If a URL uses a fragment identifier syntax that the implementation does not understand, or does not consider valid for that type of image, the URL must be treated as representing an invalid image.
</p>

<p class="note">注記：
旧来との互換性の理由から、この~errorの取扱いは，
~URL【そのもの】の定義ではなく， `image$f 【の中の~URL】に限られる。
◎
Note: This error-handling is limited to image(), and not in the definition of URL, for legacy compat reasons.
</p>



			</section>
			<section id="color-images">
<h4 title="Solid-color Images">2.4.3. 単色の画像</h4>

<p>
`image$f 関数の引数に（~URLなしで） `color$t のみが指定された場合、内在~寸法を伴わない，指定された色による単色~画像を表現する。
◎
If the image() function is specified with only a &lt;color&gt; argument (no URL), it represents a solid-color image of the specified color with no intrinsic dimensions.
</p>

<div class="example">

<p>
例えば，これを、他の画像の上層に半透明な色を重ねて
背景~画像を “淡く染める” 簡単な方法として利用できる：
◎
For example, one can use this as a simple way to "tint" a background image, by overlaying a partially-transparent color over the top of the other image:
</p>

<pre class="lang-css">
background-image: image(rgba(0,0,255,.5)), url("bg-image.png");
</pre>


<p>
`background-color$p は、これに対しては働かない。
それが生成する単色は、常に，すべての背景~画像の<em>~~背後に回る</em>ので。
◎
background-color does not work for this, as the solid color it generates always lies beneath all the background images.
</p>

</div>


			</section>
			<section id="bidi-images">
<h4 title="Bidi-sensitive Images">2.4.4. 双向性に応じる画像</h4>

<p>
作者は、 `image$f 内の `image-src$t の前に、画像~用の方向性（ `image-tags$t ）を指定しても~MAY
— これは、~HTML要素に `dir$a 属性を追加するのに似る。
要素~上で／内で逆~方向の `direction$p を伴う画像が利用された場合、その画像は，行内~方向に裏返され~MUST（行内~方向が X 軸であれば，例えば `scaleX(-1)^v で変形されたかのように）。
◎
Before listing any &lt;image-src&gt;s, the author may specify a directionality for the image, similar to adding a dir attribute to an element in HTML. If a directional image is used on or in an element with opposite direction, the image must be flipped in the inline direction (as if it was transformed by, e.g., scaleX(-1), if the inline direction is the X axis).
</p>

<p class="note">注記：
この宣言が不在の場合の既定では、画像の方向性は全くないので，周囲の要素の方向性にも応じない。
◎
Note: Absent this declaration, images default to no directionality at all, and thus don’t care about the directionality of the surrounding element.
</p>

<div class="example">

<p>
~listが，~bulletとして内容の中を指す矢印を利用していて、左横書きの~textを包含する~list~itemと, 右横書きのそれとが混在している場合、~bulletは，左端にも右端にも生じる。
その結果、一方の側では~textの中を指すよう設計された画像は、他方の側では~textの外を指すことになる。
これは、次の様な~codeで修正できる：
◎
A list may use an arrow for a bullet that points into the content. If the list can contain both LTR and RTL text, though, the bullet may be on the left or the right, and an image designed to point into the text on one side will point out of the text on the other side. This can be fixed with code like:
</p>

<pre class="lang-html">
&lt;ul style="list-style-image: image(ltr 'arrow.png');"&gt;
  &lt;li dir='ltr'&gt;左に~bulletがあります。&lt;/li&gt;
  &lt;li dir='rtl'&gt;~bulletは右にあります。&lt;/li&gt;
&lt;/ul&gt;
</pre>
<!-- 
My bullet is on the left!
MY BULLET IS ON THE RIGHT!
 -->

<p>
これは次の様に描画されるべきである：
◎
This should render something like:
</p>

<pre class="lang-html">
☞ 左に~bulletがあります。
  。すまりあに右は~tellub ☜
</pre>
<!-- 
☞ My bullet is on the left!
  !THGIR EHT NO SI TELLUB YM ⇐
-->

<p class="trans-note">【
便宜上，日本語で記しているが、実際には，右横書きの言語でなければ、このように左方へ流れる表示にはならない。
】</p>

<p>
左横書き~list~itemにおいては，画像はそのまま利用され、右横書き~list~itemにおいても内容を指すように，画像は行内~方向に裏返されることになる。
◎
In LTR list items, the image will be used as-is. In the RTL list items, however, it will be flipped in the inline direction, so it still points into the content.
</p></div>



			</section>
		</section>
		<section id="cross-fade-function">
<h3 title="Combining images: the cross-fade() notation">2.5. 画像を組合せる： `cross-fade^f 記法</h3>

`cross-fade-function^L3

		</section>
		<section id="element-notation">
<h3 title="Using Elements as Images: the element() notation">2.6. 要素を画像として利用する： `element^f 記法</h3>

<p>
`element$f 関数により、作者は，文書~内の要素を画像として利用することが可能になる。
参照先の要素の外観が変化するに伴い、画像も変化するようになる。
これを利用すれば，例えば、~slideshow内の次の／前の~slideの~live~previewを作成したり，~fancyな勾配を生成するために `canvas$e 要素を参照~したり，背景を~animate化することさえ可能になる。
◎
The element() function allows an author to use an element in the document as an image. As the referenced element changes appearance, the image changes as well. This can be used, for example, to create live previews of the next/previous slide in a slideshow, or to reference a canvas element for a fancy generated gradient or even an animated background.
</p>


<p class="note">注記：
`element$f 関数が再生産するのは、参照先の要素の<em>外観</em>に限られ，実際の内容やその構造を再生産することはない。
作者は、装飾的な目的に限り，これを利用するべきである。
`element$f を，頁にまたがる有意な内容を伴う要素を再生産するために利用しては~MUST_NOT
— 代わりに、単に文書の中に要素の複数の複製を挿入すること。
◎
Note: The element() function only reproduces the appearance of the referenced element, not the actual content and its structure. Authors should only use this for decorative purposes, and must not use element() to reproduce an element with significant content across the page. Instead, just insert multiple copies of the element into the document.
</p>


<p>
`element$f の構文は、次で与えられる：
◎
The syntax for element() is:
</p>

<pre class="prod">
`element@f = element( `id-selector$t )
</pre>


<p>
ここで `id-selector$t は`~ID選択子$である。
`SELECT$r
◎
where &lt;id-selector&gt; is an ID selector [SELECT].
</p>


<p class="issue">
外部~文書~内の要素（~SVGの`塗り~server$など）を参照できるようにする必要はあるか？
あるいは、この用途には `url^f を利用するだけで十分か？
◎
Do we need to be able to refer to elements in external documents (such as SVG paint servers)? Or is it enough to just use url() for this?
</p>


<p class="issue">
この名前は、 GCPM の似た関数と競合する。
これはどうにかして解決される必要がある。
◎
This name conflicts with a somewhat similar function in GCPM. This needs to be resolved somehow.
</p>


<p class="issue">
要素の “反映” を行う能が求まれる
— 要素~上の背景~画像として, または擬似要素~内で。
循環の検出を誘発するのを避けるため、これは特別に取扱われる必要がある。
◎
Want the ability to do "reflections" of an element, either as a background-image on the element or in a pseudo-element. This needs to be specially-handled to avoid triggering the cycle-detection.
</p>


<p class="issue">
`overflow^p が `paged^v にされている~view内の単独の頁にはどう取組むか？
◎
When we have overflow:paged, how can we address a single page in the view?
</p>


<p>
`element$f 関数は、その引数に与えた~IDに合致する要素を参照~する。
~IDは、先ず `elementSources$m ~map内で検索される。
見出されなかった場合，文書に対し照合され、合致した要素が複数あれば，関数は それらのうち最初の要素を参照~する。
◎
The element() function references the element matched by its argument. The ID is first looked up in the elementSources map, as described in that section. If it’s not found, it’s then matched against the document. If multiple elements are matched, the function references the first such element.
</p>


<p>
`element$f 関数により表現される画像は、要素が文書~内で可視かどうかに基づいて変わり得る：
◎
The image represented by the element() function can vary based on whether the element is visible in the document:
</p>

<dl>
	<dt>
要素は`描画され$ていて，`置換~要素$の子孫ではない, かつ`積層~文脈$を生成する場合：
◎
an element that is rendered, is not a descendant of a replaced element, and generates a stacking context 
</dt>
	<dd>
<p>
関数は、内在~sizeが参照先の要素の
`装飾限界~box@
に等しい画像を表現する：
◎
The function represents an image with its intrinsic size equal to the decorated bounding box of the referenced element:
</p>
		<ul>
			<li>
~CSS描画~modelを利用して描画される要素に対しては、`装飾限界~box$は，`主要~box$のすべての断片の`~border画像~区画$を包含する, かつ軸に~~平行な，最も小さい矩形になる。
◎
for an element rendered using a CSS rendering model, the decorated bounding box is the smallest axis-aligned rectangle that contains the border image areas of all the fragments of the principal box
</li>
			<li>
~SVG描画~modelを利用して描画される要素に対する`装飾限界~box$は，
<a href="https://www.w3.org/TR/SVGTiny12/intro.html#TermDecoratedBoundingBox">SVGにより定義されるそれ</a>になる。
【大雑把に言えば，外形線の太さも含め，図形~全体を囲う最小の矩形】
◎
for an element rendered using the SVG rendering model, the decorated bounding box is defined by SVG
</li>
		</ul>

<p class="note">注記：
画像は，その限界の外側にあるものは既定で切取るので、~box影の様な`装飾限界~box$の外側へ拡張する装飾は，切取られることになる。
◎
Note: Because images clip anything outside their bounds by default, this means that decorations that extend outside the decorated bounding box, like box shadows, may be clipped.
</p>

	</dd>
	<dd>
画像は、広さ無限の `transparent$v ~canvas上に参照先の要素とその子孫を描画して構築され
（文書~内にあるときの~sizeと同じになる）、`装飾限界~box$の各~辺は画像の各~辺に接合されるように，位置される。
◎
The image is constructed by rendering the referenced element and its descendants (at the same size that they would be in the document) over an infinite transparent canvas, positioned so that the edges of the decorated bounding box are flush with the edges of the image.
</dd>
	<dd class="issue">
実装を効率的にするためには、要素には積層~文脈またはそれに準じるものが要求されるよう見受けられる。
全部的な積層~文脈は必要か？あるいは疑似的な積層~文脈で済むか？
それは通常の積層~文脈になる必要はあるか？あるいは `element^f に描画するときに積層~文脈として描画するだけで済むか？
◎
Requiring some degree of stacking context on the element appears to be required for an efficient implementation. Do we need a full stacking context, or just a pseudo-stacking context? Should it need to be a stacking context normally, or can we just render it as a stacking context when rendering it to element()?
</dd>
	<dd>
参照先の要素またはその先祖に変形-が適用されている場合、要素を画像として描画するときには，変形-は無視され~MUST。
`CSS3-TRANSFORMS$r
◎
If the referenced element has a transform applied to it or an ancestor, the transform must be ignored when rendering the element as an image. [CSS3-TRANSFORMS]
</dd>
	<dd>
参照先の要素が何~頁かに分断されている場合、要素は，頁の内容~区画が頁割~方向に接合されていたかのように表示される
— 頁の各~辺は初期~包含塊の対応する始端~辺に整列された上で。
<span class="note">
何~行0か／何~柱か
に分断されている要素は、単に`装飾限界~box$と伴に描画される
</span>
◎
If the referenced element is broken across pages, the element is displayed as if the page content areas were joined flush in the pagination direction, with pages' edges corresponding to the initial containing block’s start edge aligned. Elements broken across lines or columns are just rendered with their decorated bounding box.
</dd>
	<dd>
実装は、参照先の要素~用に生成した既存の~bitmap~dataを再~利用しても~MAY。
あるいは，要素の表示-を再~生成して、当の~sizeにおける画像の品質を最大化しても~MAY（例えば、参照先の要素は~SVG素片であると検出された場合）。
再~生成する場合でも、結果の画像における~layoutが参照先の要素から変化しては~MUST_NOT。
すなわち，画像の見かけは、~raster化の品質の違いを除き，参照先の要素と一致し~MUST。
◎
Implementations may either re-use existing bitmap data generated for the referenced element or regenerate the display of the element to maximize quality at the image’s size (for example, if the implementation detects that the referenced element is an SVG fragment); in the latter case, the layout of the referenced element in the image must not be changed by the regeneration process. That is, the image must look identical to the referenced element, modulo rasterization quality.
</dd>
	<dd class="example">
<p>
`p$e 要素を文書~内の他所で背景として再利用する例：
◎
As a somewhat silly example, a p element can be reused as a background elsewhere in the document:
</p>

`efunc1^dgm

<figure>
`efunc2^dgm
</figure>

	</dd>

	<dt>
要素は`描画され$ないが、`塗り~source$を供する場合：
◎
an element that is not rendered, but which provides a paint source
</dt>
	<dd>
関数は、`塗り~source$の［
内在~size, 外観
］を伴う画像を表現する
— ~sizeと外観は、~host言語により定義される。
◎
The function represents an image with the intrinsic size and appearance of the paint source. The host language defines the size and appearance of paint sources.
</dd>
	<dd class="example">
<p>
例えば， `element$f 関数は、~HTML文書~内の ~SVG `pattern$e 要素を参照~できる：
◎
For example, the element() function can reference an SVG &lt;pattern&gt; element in an HTML document:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;svg&gt;
  &lt;defs&gt;
    &lt;pattern id='pattern1'&gt;
      &lt;path d='...'&gt;
    &lt;/pattern&gt;
  &lt;/defs&gt;
&lt;/svg&gt;
&lt;p style="background: element(#pattern1)"&gt;
<span class="comment">
ここでは~patternを背景に用いてます。
~patternが変化したり~animateされた場合、背景も更新されることになります。
◎
I’m using the pattern as a background! If the pattern is changed or animated, my background will be updated too!
</span>
&lt;/p&gt;
</pre>

<p>
~HTMLは［
`canvas$e, `img$e, `video$e
］など、塗り~sourceを供する，数種の要素を定義する。
頁~内には表示されてないが，中に何か描かれている `canvas$e を，~CSSから参照~できることを意味する：
◎
HTML also defines that a handful of elements, such as canvas, img, and video, provide a paint source. This means that CSS can, for example, reference a canvas that’s being drawn into, but not displayed in the page:
</p>


<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
  var %canvas = document.querySelector('#animated-bullet');
  %canvas.width = 20; canvas.height = 20;
  drawAnimation(%canvas);
&lt;/script&gt;
&lt;canvas id='animated-bullet' style='display:none'&gt;&lt;/canvas&gt;
&lt;ul style="list-style-image: element(#animated-bullet);"&gt;
  &lt;li&gt;<span class="comment">
ここでは `canvas$e を~bulletに用いてます。
◎
I’m using the canvas as a bullet!
</span>&lt;/li&gt;
  &lt;li&gt;<span class="comment">
ここでも。
◎
So am I!
</span>&lt;/li&gt;
  &lt;li&gt;<span class="comment">
`canvas$e が~JSで変更される度に，すべての~bullet画像も更新されます。
◎
As the canvas is changed over time with Javascript, we’ll all update our bullet image with it!
</span>&lt;/li&gt;
&lt;/ul&gt;
</pre>

	</dd>

	<dt>
その他の場合：
◎
anything else
</dt>
	<dd>
関数は`無効な画像$を表現する。
◎
The function represents an invalid image.
</dd>
	<dd class="example">
<p>
例えば，次に挙げる `element$f の利用は、どれも透明な背景になる：
◎
For example, all of the following element() uses will result in a transparent background:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;p id='one' style="display:none; position: relative;"&gt;one&lt;/p&gt;
&lt;iframe src="http://example.com"&gt;
  &lt;p id='two' style="position: relative;"&gt;<span class="comment">
~fallback内容
◎
I’m fallback content!
</span>&lt;/p&gt;
&lt;/iframe&gt;
&lt;ul&gt;
  &lt;li style="background: element(#one);"&gt;
<span class="comment">
要素 `p id='one'^e は、 `display^p が `none^v にされていて`描画され$ないので，塗り~sourceを供さない。
◎
A display:none element isn’t rendered, and a P element doesn’t provide a paint source.
</span>
  &lt;/li&gt;
  &lt;li style="background: element(#two);"&gt;
<span class="comment">
`element^f には `iframe$e の様な`置換~要素$の子孫は利用できない。
◎
The descendants of a replaced element like an IFRAME can’t be used in element() either.
</span>
  &lt;/li&gt;
  &lt;li style="background: element(#three);"&gt;
<span class="comment">
`id^a "`three^v" の要素はないので、この背景も透明になる。
◎
There’s no element with an id of "three", so this also gets rendered as a transparent image.
</span>
  &lt;/li&gt;
&lt;/ul&gt;
</pre>
	</dd>
</dl>

<p>
結付けられている~boxがない要素は、
`描画され@
ないとされる。
これは例えば、要素またはその ある先祖にて `display^p が `none^v にされている場合などに起こり得る。
~host言語は、要素が描画されないと見なされ得る追加の仕方を定義して~MAY
— 例えば，~SVGにおいては、 `defs$e 要素のどの子孫も描画されないものと見なされる。
◎
An element is not rendered if it does not have an associated box. This can happen, for example, if the element or an ancestor is display:none. Host languages may define additional ways in which an element can be considered not rendered; for example, in SVG, any descendant of a &lt;defs&gt; element is considered to be not rendered.
</p>

<div class="example">

<p>
`element$f 関数には、多くの用途に利用できる。
例えば、~slideshow内の次の／前の~slideの~previewを示すために利用できる：
◎
The element() function can be put to many uses. For example, it can be used to show a preview of the previous or next slide in a slideshow:
</p>


<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;script&gt;
function navigateSlides() {
  var %currentSlide = ...;
  document.querySelector('#prev-slide').id = '';
  document.querySelector('#next-slide').id = '';
  %currentSlide.previousElementSibling.id = 'prev-slide';
  %currentSlide.nextElementSibling.id = 'next-slide';
}
&lt;/script&gt;
&lt;style&gt;
.slide {
  /* <span class="comment">
`element^f 可能になるためには、積層~文脈にする必要がある。
◎
Need to be a stacking context to be element()-able.
</span> */
  position: relative;
}
#prev-preview, #next-preview {
  position: fixed;
  ...
}
#prev-preview { background: element(#prev-slide); }
#next-preview { background: element(#next-slide); }
&lt;/style&gt;
&lt;a id='prev-preview'&gt;前の~slide&lt;/a&gt;
&lt;a id='next-preview'&gt;次の~slide&lt;/a&gt;
&lt;section class='slide'&gt;...&lt;/section&gt;
&lt;section class='slide current-slide'&gt;...&lt;/section&gt;
...
</pre>
<!-- 
Previous Slide
Next Slide
 -->

<p>
この例の `navigateSlides()^c 関数は、次の／前の~slideの `id^a を更新する
— それは、~slideの傍に浮動している小さい~box内に表示される。
`element$f 関数による~slideとは対話できないので（それは単なる画像である）、~preview~box上で `click^et ~handlerを利用して頁を~navigateし易くすることもできる。
◎
In this example, the navigateSlides function updates the ids of the next and previous slides, which are then displayed in small floating boxes alongside the slides. Since you can’t interact with the slides through the element() function (it’s just an image), you could even use click handlers on the preview boxes to help navigate through the page.
</p>

</div>

			<section id="paint-sources">
<h4 title="Paint Sources">2.6.1. 塗り~source</h4>

<p>
~host言語は、何らかの要素を
`塗り~source@
を供するものとを定義して~MAY。
塗り~sourceは、内在的~外観を持ち，［
~layoutする／描画-
］する必要なく`実obj~size$を得れるので、`描画され$ていなくとも画像として利用できる。
◎
Host languages may define that some elements provide a paint source. Paint sources have an intrinsic appearance and can obtain a concrete object size without having to do layout or rendering, and so may be used as images even when they’re not rendered.
</p>


<p>
~HTMLにおいては、［
`img$e ／ `video$e ／ `canvas$e
］要素が塗り~sourceを供する。
◎
In HTML, the img, video, and canvas elements provide paint sources.
</p>

<p>
~SVGにおいては、`塗り~server$を供する要素が，塗り~sourceを供する。
<span class="note">注記：
SVG1.1 においては，［
`linearGradient$e, `radialGradient$e, `pattern$e 
］要素が塗り~sourceを供する。
</span>
それらは，その仕様にて述べるように描かれる
— 次に定義される座標系の下で：
◎
In SVG, any element that provides a paint server provides a paint source. Note: In SVG1.1, the &lt;linearGradient&gt;, &lt;radialGradient&gt;, and &lt;pattern&gt; elements provide paint sources. They are drawn as described in the spec, with the coordinate systems defined as follows:
</p>

<dl>
	<dt>`objectBoundingBox^v</dt>
	<dd>
原点は，描かれている`実obj~size$により定義される矩形の左上隅。
寸法は，`実obj~size$と同じ。
1 `利用単位$は，`実obj~size$の横幅, 縦幅。
◎
The coordinate system has its origin at the top left corner of the rectangle defined by the concrete object size that it’s being drawn into, and the same width and height as the concrete object size. A single user coordinate is the width and height of the concrete object size.
</dd>

	<dt>`userSpaceOnUse^v</dt>
	<dd>
原点は，描かれている`実obj~size$により定義される矩形の左上隅。
寸法は，`実obj~size$と同じ。
1 `利用単位$は， 1 `px$u 単位に等価。
◎
The coordinate system has its origin at the top left corner of the rectangle defined by the concrete object size that it’s being drawn into, and the same width and height as the concrete object size. User coordinates are sized equivalently to the CSS px unit.
</dd>
</dl>


<p class="note">注記：
この~moduleの将来の~versionでは、［
外部~文書~内の／
もっぱら~scriptにより作成され文書~内に全く挿入されない
］塗り~sourceを参照する仕方を定義することが期待されている。
◎
Note: It is expected that a future version of this module will define ways to refer to paint sources in external documents, or ones that are created solely by script and never inserted into a document at all.
</p>



			</section>
			<section id="elementsources">
<h4 title="Using Out-Of-Document Sources: the ElementSources interface">2.6.2. 文書~外~sourceの利用-法： `ElementSources^I ~interface</h4>

<p>
`element$f 関数は、通常は文書の中の要素を選択するが、`塗り~source$を供する要素は，必ずしも文書~内にある必要はない。
例えば、~scriptにより 作成され, 保守され, 描かれ，文書に直に挿入されてはいない~HTML `canvas$e 要素など。
◎
The element() function normally selects elements within a document, but elements that provide a paint source don’t necessarily need to be in-document. For example, an HTML canvas element can be created, maintained, and drawn into entirely in script, with no need for it to be inserted into the document directly.
</p>


<p>
`~ID選択子$は，文書の外側にある要素は選択できないので、要素を参照する仕方が必要になる。
`elementSources$m ~map~objがこれを供する。
◎
All that’s needed is a way to refer to the element, as an ID selector cannot select elements outside of the document. The elementSources Map object provides this.
</p>


<pre class="idl">partial interface `CSS$I {
  [`SameObject$] readonly attribute <a>Map</a> `elementSources@m;
};
</pre>

<p>
`elementSources$m ~map内の~entryのうち，次を満たすものが、 `element$f 関数にて可用になる
⇒
［
文字列を~keyとする
］~AND［
`塗り~source$を供している~objを値にとる
］
◎
Any entries in the elementSources map with a string key and a value that is an object providing a paint source are made available to the element() function.
</p>

<p>
`element$f に与えた `id-selector$t に対しては、先ず `elementSources$m ~map内で，~ID（先頭の文字 `#^c は含めない）が検索される：
◎
Whenever element() uses an &lt;id-selector&gt;, the ID’s value (without the leading # character) is first looked up in the elementSources map:
</p>

<ul>
	<li>
~IDを~keyとする~entryが見出された場合、 `element$f 関数は，~entryの値で与えられる~objが`塗り~source$を供して［
いるならば その塗り~source ／
いないならば`無効な画像$
］を表現する。
◎
If it’s found, and the object associated with it provides a paint source, the element() function represents that paint source.
◎
If it’s found, but the object associated with it doesn’t provide a paint source, the element() function represent an invalid image.
</li>
	<li>
見出されなかった場合、通常通り，文書~内を探す。
◎
If the ID isn’t found in the map at all, it’s then looked for in the document as normal.
</li>
</ul>


<p class="issue">
この`~ID選択子$の再利用は、 Mozilla の挙動に合致する。
編集者は、文法の先頭を `custom-ident$t で塞ぐのは避けたいと~~考えている
— それは構文空間を食い過ぎるので。
別の可能性として、値を言語により定義される~keywordから開始させ，
`custom-ident$t を後続させる案も考えられる
— `element(external fancy)^v  か何かの様に。
何か命名の示唆があれば歓迎する。
◎
This reuse of the ID selector matches Moz behavior. I’m trying to avoid slapping a &lt;custom-ident&gt; right in the beginning of the grammar, as that eats too much syntax-space. Another possibility, though, is to start the value with a language-defined keyword followed by a &lt;custom-ident&gt;, like element(external fancy) or something. Naming suggestions welcome.
</p>

<div class="example">

<p>
外部~canvasを用いて~fancyな背景を~animateする例：
◎
For example, fancy animating backgrounds can be done with an external canvas:
</p>

<pre class="lang-html">
&lt;script&gt;
var %bg = document.createElement('canvas');
%bg.height = 200;
%bg.width = 1000;
drawFancyBackground(%bg);
CSS.elementSources.set('fancy', %bg);
&lt;/script&gt;
&lt;style&gt;
h1 {
  background-image: element(#fancy);
}
&lt;/style&gt;
</pre>


<p>
“~fancy” ~canvasの中に何かが描かれ，~animateされるに伴い，すべての `h1^e 要素の背景も自動的かつ一斉に更新されることになる。
◎
As the "fancy" canvas is drawn into and animated, the backgrounds of all the H1 elements will automatically update in tandem.
</p>

<p>
`elementSources$m ~mapは，文書に対し`~ID選択子$を照合する前にあたられるので、文書~内に `#fancy^v に合致する要素があっても，背景は依然として `elementSources$m 値から来ることに注意。
◎
Note that the elementSources map is consulted before the document to match the ID selector, so even if there’s an element in the document that would match #fancy, the backgrounds will still predictably come from the elementSources value instead.
</p>

</div>

			</section>
			<section id="element-cycles">
<h4 title="Cycle Detection">2.6.3. 循環の検出</h4>


<p>
`element$f 関数は、無為な循環関係を生産し得る
— 自身を自前の背景に利用する要素など。
が，これらの関係性は、依存関係~graphを保ち続け, 共通的な循環~検出~algoを用いれば，容易かつ依拠-可能に検出して解決できる。
◎
The element() function can produce nonsensical circular relationships, such as an element using itself as its own background. These relationships can be easily and reliably detected and resolved, however, by keeping track of a dependency graph and using common cycle-detection algorithms.
</p>

<p>
依存関係~graphは、次に挙げる辺からなる：
◎
The dependency graph consists of edges such that:
</p>

<ul>
	<li>
どの要素も、その子たちに依存する。
◎
every element depends on its children
</li>
	<li>
要素 A 上のある~propが `element$f 関数を利用していて，要素 B を指しているならば、 A は B に依存する
◎
for any element A with a property using the element() function pointing to an element B, A depends on B
</li>
	<li>
~host言語が，要素が他の要素の描画を参照する仕方を定義しているならば、参照元の要素は参照先の要素に依存する。
例えば，~SVGにおいては、 `use$e 要素は参照先の要素に依存する。
◎
if a host language defines a way for elements to refer to the rendering of other elements, the referencing element depends on the referenced element. For example, in SVG, a &lt;use&gt; element depends on the element it referenced.
</li>
</ul>

<p>
この~graphが循環を包含する場合、その循環に関与しているどの `element$f 関数も，`無効な画像$になる。
◎
If the graph contains a cycle, any element() functions participating in the cycle are invalid images.
</p>


			</section>
		</section>
	</section>
	<section id="gradients">
<h2 title="Gradients">3. 勾配</h2>

<a id="conic-gradients"></a>
<a id="color-stop-syntax"></a>

<p class="trans-note">【
この節の内容は未訳。
】</p>

	</section>
	<section id="sizing">
<h2 title="Sizing Images and Objects in CSS">4. ~CSSにおける画像／~objの~sizing</h2>

<p class="note">注記：
この節の他の内容は、
 <a href="#biblio-css3-images">[css3-images]</a> と
<a href="~CSSIMAGE#sizing" >同じ</a>。
</p>

		<section id="the-object-fit">
<h3 title="Sizing Objects: the object-fit property">4.1. ~objの~sizing： `object-fit^p ~prop</h3>

◎名 `object-fit@p
◎値 `fill$v | `none$v | [`contain$v | `cover$v] || `scale-down$v
◎初 `fill$v
◎適 `置換~要素$
◎継 されない
◎百 受容しない
◎媒 視覚的
◎算 指定値
◎順 文法に従う
◎ア 不可
◎表終

<p>
`object-fit$p ~propは、置換~要素の内容が，その使用~横縦幅により確立される~boxに，どのように収められるべきかを指定する。
◎
The object-fit property specifies how the contents of a replaced element should be fitted to the box established by its used height and width.
</p>

<p class="trans-note">【
以下、
<a href="~CSSIMAGE#the-object-fit">~level 3 の内容</a>
と同じ部分
—  “L3” と記されている箇所 —
の和訳は省略する。
】</p>

<dl class="valdef">
	<dt>`fill@v</dt>
	<dd>
L3
◎
The replaced content is sized to fill the element’s content box: the object’s concrete object size is the element’s used width and height.
</dd>

	<dt>`none@v</dt>
	<dd>
L3
◎
The replaced content is not resized to fit inside the element’s content box: determine the object’s concrete object size using the default sizing algorithm with no specified size, and a default object size equal to the replaced element’s used width and height.
</dd>


	<dt>`contain@v</dt>
	<dd>
L3
◎
The replaced content is sized to maintain its aspect ratio while fitting within the element’s content box: its concrete object size is resolved as a contain constraint against the element’s used width and height.
</dd>
	<dd>
`scale-down$v も併用された場合、内容は［
`none$v, `contain$v
］のうち，`実obj~size$が小さくなる方が指定されたかのように~sizeされる。
◎
If the scale-down flag is used, size the content as if none or contain were specified, whichever would result in a smaller concrete object size.
</dd>
	<dd class="note">注記：
`none$v, `contain$v
の両者とも内容の内在的~縦横比を保たせるので、大きさの比較は可能になる。
◎
Note: Both none and contain respect the content’s intrinsic aspect ratio, so the concept of "smaller" is well-defined.
</dd>

	<dt>`cover@v</dt>
	<dd>
L3
◎
The replaced content is sized to maintain its aspect ratio while filling the element’s entire content box: its concrete object size is resolved as a cover constraint against the element’s used width and height.
</dd>
	<dd>
`scale-down$v も併用された場合、内容は［
`none$v, `cover$v
］のうち，`実obj~size$が小さくなる方が指定されたかのように~sizeされる。
</dd>
	<dd class="note">注記：
`none$v, `cover$v 
の両者とも内容の内在的~縦横比を保たせるので、大きさの比較は可能になる。
◎
Note: Both none and cover respect the content’s intrinsic aspect ratio, so the concept of "smaller" is well-defined.
</dd>

	<dt>`scale-down@v</dt>
	<dd>
`contain scale-down^v と等価。
◎
Equivalent to contain scale-down. 
</dd>
</dl>

<p>
L3
◎
If the content does not completely fill the replaced element’s content box, the unfilled space shows the replaced element’s background. Since replaced elements always clip their contents to the content box, the content will never overflow. See the object-position property for positioning the object with respect to the content box.
</p>

<figure>`img_scale^dgm<figcaption>
<p>
L3
◎
An example showing how four of the values of object-fit cause the replaced element (blue figure) to be scaled to fit its height/width box (shown with a green background), using the initial value for object-position.＼
</p>

<p>
この事例では、図に示されていない値 `scale-down$v, および `scale-down contain^v による見かけは， `contain$v と一致し、
`scale-down cover^v による見かけは， `none$v と一致する。
◎
In this case, scale-down and scale-down contain would look identical to contain, and scale-down cover would look identical to none. 
</p>
</figcaption></figure>

<p class="note">注記：
L3
◎
Note: The object-fit property has similar semantics to the fit attribute in [SMIL10] and the &lt;meetOrSlice&gt; parameter on the preserveAspectRatio attribute in [SVG11].
</p>

<p class="note">注記：
L3
◎
Note: Per the object size negotiation algorithm, the concrete object size (or, in this case, the size of the content) does not directly scale the object itself - it is merely passed to the object as information about the size of the visible canvas. How to then draw into that size is up to the image format. In particular, raster images always scale to the given size, while SVG uses the given size as the size of the "SVG Viewport" (a term defined by SVG) and then uses the values of several attributes on the root &lt;svg&gt; element to determine how to draw itself.
</p>

		</section>
	</section>
	<section id="image-processing">
<h2 title="Image Processing">5. 画像~処理</h2>

		<section id="the-image-resolution">
<h3 title="Overriding Image Resolutions: the image-resolution property">5.1. 画像~解像度の上書き法： `image-resolution^p ~prop</h3>

<p>
`画像~解像度@
は、単位~長さあたりの画像~画素~数として定義される。
例えば、~inchあたりの画素~数。
画像~形式には、画像の解像度についての情報を記録するものもある。
この情報は、整形~処理-にあたって画像の実際の~sizeを決定する補助になり得るが、誤ったものにもなり得るので，その場合には，無視されるべきである。
~CSSの既定では、
~CSS `px$u 単位が 1 画像~画素に等しい解像度と見做すが、
`image-resolution$p ~propにより，他の解像度も利用できるようになる。
◎
The image resolution is defined as the number of image pixels per unit length, e.g., pixels per inch. Some image formats can record information about the resolution of images. This information can be helpful when determining the actual size of the image in the formatting process. However, the information can also be wrong, in which case it should be ignored. By default, CSS assumes a resolution of one image pixel per CSS px unit; however, the image-resolution property allows using some other resolution.
</p>

◎名 `image-resolution@p
◎値 [ `from-image$v || `resolution$t ] &amp;&amp; `snap$v?
◎初 `1dppx^v
◎適 すべての要素
◎継 される
◎百 受容しない
◎媒 視覚的
◎算 
指定値
— ただし， `snap$v の~~計算により `resolution$t が改められる場合（下記を見よ）は除く。
◎
as specified, except with &lt;resolution&gt; possibly altered by computed for snap (see below)
◎順 文法に従う
◎ア 不可
◎表終


<p class="issue">
`image-set$f 記法は、画像の内在~解像度を改め得る
—
それは、この~propを設定しなくても，自動的に尊守されるのが理想的だが【？】。
これをどう~~解決すべきか？
初期値を、
“~CSSが他を~~指示しない限り `1dppx^v とする”
を意味する `auto^v に変えるか？
`image-resolution^p は、解像度が~CSSにおける他の何かで設定された画像には効果がないようにするか？
あるいは、 `image-set$f を，それが常に何らかの方法で `1dppx^v 画像を生産するように，どうにか wordsmithing するか？
◎
The image-set() notation can alter the intrinsic resolution of an image, which ideally would be automatically honored without having to set this property. How should we best address this? Change the initial value to auto, meaning "1dppx, unless CSS says otherwise"? Say that image-resolution has no effect on images whose resolution was set by something else in CSS? Or somehow wordsmithing image-set() in some way such that it always produces 1dppx images somehow?
</p>

<p>
`image-resolution$p ~propは、［［
要素~内／要素~上
］で利用されるすべての~raster画像
］の`内在~解像度$を，指定する。
それは、内容~画像（例えば，`置換~要素$や`生成内容$）にも, 装飾的な画像（ `background-image$p など）にも影響する。
画像の
`内在~解像度@
は、画像の`内在~寸法$を決定するために利用される。
各種 値の意味は：
◎
The image-resolution property specifies the intrinsic resolution of all raster images used in or on the element. It affects both content images (e.g. replaced elements and generated content) and decorative images (such as background-image). The intrinsic resolution of an image is used to determine the image’s intrinsic dimensions. Values have the following meanings:
</p>


<dl class="valdef">
	<dt id="valdef-image-resolution-resolution">`resolution$t</dt>
	<dd>
内在~解像度を数値的に指定する。
この場合の 1 “~dot” は， 1 画像~画素に対応する。
◎
Specifies the intrinsic resolution explicitly. A "dot" in this case corresponds to a single image pixel.
</dd>
	<dd class="trans-note">【
すなわち、［
`css-values-3$r による
<a href="~CSSVAL#resolution">`resolution^t</a>
の定義
］に記されている “~dot” は 1 画像~画素と解釈される。
】</dd>

	<dt>`from-image@v</dt>
	<dd>
画像の内在~解像度は、画像~形式から指定される。
画像が自前の解像度を指定していない場合、
`resolution$t が明示的に指定されていれば，それが利用され、他の場合は既定の `1dppx^v になる。
◎
The image’s intrinsic resolution is taken as that specified by the image format. If the image does not specify its own resolution, the explicitly specified resolution is used (if given), else it defaults to 1dppx.
</dd>

	<dt>`snap@v</dt>
	<dd>
この~keywordが伴われている `resolution$t は、 1 画像~画素が機器~画素の整数~倍に対応するような，最も近い値に丸めた結果に算出される。
解像度が画像からとられる【 `from-image$v が供されている】場合、内在~解像度の使用値は，画像~自身による解像度を同様に調整した結果になる。
◎
If the "snap" keyword is provided, the computed &lt;resolution&gt; (if any) is the specified resolution rounded to the nearest value that would map one image pixel to an integer number of device pixels. If the resolution is taken from the image, then the used intrinsic resolution is the image’s native resolution similarly adjusted.
</dd>
</dl>

<p>
SVG などの~vector形式には、内在~解像度はない。
この~propは、~vector画像には効果がない。
◎
As vector formats such as SVG do not have an intrinsic resolution, this property has no effect on vector images.
</p>

<div class="example">

<p>
印刷機の解像度は、~computer-monitorより，かなり高いのが常なので、~screen上ではきれいな画像でも，印刷~時には画素が目立つ。
`image-resolution$p ~propを利用すれば、文書~内に高~解像度の画像を埋込んで 適切な~sizeを保守しつつ，~screen上でも紙~上でも美麗に表示できるようになる：
◎
Printers tend to have substantially higher resolution than computer monitors; due to this, an image that looks fine on the screen may look pixellated when printed out. The image-resolution property can be used to embed a high-resolution image into the document and maintain an appropriate size, ensuring attractive display both on screen and on paper:
</p>

<pre class="lang-css">
img.high-res {
  image-resolution: 300dpi;
}
</pre>


<p>
この規則の下では、 300dpi で 5 ~inch幅になるようにされた画像は，実際に 5 ~inch幅で表示されることになる。
この規則が無い下では、~CSSの既定による 1 ~inchあたり 96 画像~画素の表示になるので、画像は［
300 × 5 ÷ 96 ＝ 約 15.6
］~inch幅で表示されることになる。
◎
With this set, an image meant to be 5 inches wide at 300dpi will actually display as 5in wide; without this set, the image would display as approximately 15.6in wide since the image is 15000 image pixels across, and by default CSS displays 96 image pixels per inch.
</p>

</div>

<div class="example">

<p>
画像~形式には、自身の~data内に解像度を符号化するものもある。
次の規則は、~UAが，解像度を画像~自身から見出すように指定する
— 見出されない場合、~CSS `px$u 単位あたり 1 画像~画素に~fallbackする。
◎
Some image formats can encode the image resolution into the image data. This rule specifies that the UA should use the image resolution found in the image itself, falling back to 1 image pixel per CSS px unit.
</p>

<pre class="lang-css">
img { image-resolution: from-image }
</pre>


<p>
次の規則は、~UAが，解像度を画像~自身から見出すように指定しつつ、見出せないときは，解像度を既定の `1dppx^v でなく `300dpi^v に設定する。
◎
These rules both specify that the UA should use the image resolution found in the image itself, but if the image has no resolution, the resolution is set to 300dpi instead of the default 1dppx.
</p>


<pre class="lang-css">
img { image-resolution: from-image 300dpi }
img { image-resolution: 300dpi from-image }
</pre>

</div>

<div class="example">

<p>
次の規則は、画像~解像度を 300dpi に設定する（画像~自身の解像度は，無視される）。
◎
Using this rule, the image resolution is set to 300dpi. (The resolution in the image, if any, is ignored.)
</p>

<pre class="lang-css">
img { image-resolution: 300dpi }
</pre>


<p>
一方で，次の規則では、~screen解像度が 96dpi の下であれば，画像を解像度 288dpi で描画することになる（ 3 画像~画素が 1 機器~画素に対応する）：
◎
This rule, on the other hand, if used when the screen’s resolution is 96dpi, would instead render the image at 288dpi (so that 3 image pixels map to 1 device pixel):
</p>


<pre class="lang-css">
img { image-resolution: 300dpi snap; }
</pre>


<p>
`snap$v ~keywordは、解像度が画像から取得されるときにも利用できる：
◎
The snap keyword can also be used when the resolution is taken from the image:
</p>


<pre class="lang-css">
img { image-resolution: snap from-image; }
</pre>


<p>
画像~自身に備わる解像度が
300dpi のときには 288dpi で描画する（ 3 画像~画素が 1 機器~画素に対応する）一方で、
72dpi のときには 96dpi で描画することになる（ 1 画像~画素が 1 機器~画素に対応する）。
◎
An image declaring itself as 300dpi will, in the situation above, display at 288dpi (3 image pixels per device pixel) whereas an image declaring 72dpi will render at 96dpi (1 image pixel per device pixel).
</p>
</div>



		</section>
	</section>
	<section id="interpolation">
<h2 title="Interpolation">6. 補間</h2>


`interpolation^L3

	</section>
	<section id="serialization">
<h2 title="Serialization">7. 直列化</h2>

`serialization^L3

	</section>
	<section id="privsec">
<h2 title="Privacy and Security Considerations">~privacy／~security上の考慮点</h2>

`privsec^L3

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p id="changes-20120911">
<a href="~TR/2012/WD-css4-images-20120911/">2012 年 9 月 11 日付 作業草案</a>
からの変更点は：
◎
Changes Since the 11 September 2012 Working Draft
</p>

<ul>
	<li>
<a href="#color-stop-syntax">色~補間~hint</a>
を追加した。
◎
Added color interpolation hints
</li>
	<li>
勾配の色停に
<a href="#color-stop-syntax">2 個の所在による構文</a>
を追加した。
◎
Added the two location syntax for gradient color stops
</li>
	<li>
`円錐型~勾配$に開始-角度を追加した。
◎
Added start angles to conic gradients
</li>
	<li>
色停の位置（たち）は、今や色より前にも来れる
◎
The position(s) of a color stop can now come before the color
</li>
	<li>
`css3-images$r に一致する~textは、 `css3-images$r への参照に置換した。
◎
Text that is identical to [css3-images] has been replaced with a reference to [css3-images].
</li>
</ul>

<p id="changes-3">
~Level 3 からの変更点は：
</p>

<ul>
	<li>
（~level 3 から先送りされた）
`image$f 記法を追加した。
◎
Added the image() notation (deferred from Level 3)
</li>
	<li>
（~level 3 から先送りされた）
`image-resolution$p ~propを追加した。
◎
Added the image-resolution property (deferred from Level 3)
</li>
	<li>
（~level 3 から先送りされた）
`element$f 記法を追加した。
◎
Added the element() notation (deferred from Level 3)
</li>
	<li>
`円錐型~勾配$を追加した。
◎
Added conic gradients
</li>
</ul>

	</section>

</main></div><!-- MAIN -->

