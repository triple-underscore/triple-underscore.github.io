<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — WebSocket（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		toc_main: 'network',
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 171023 spec
}

function expand(){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		sc: 'scheme',
		E: 'error',
		h: 'header',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		hd: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		sc: 'code',
		et: 'code',
		h: 'code',
		E: 'code',
		v: 'var',
		i: 'i',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[\w~一-鿆]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
case 'hd': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text += ':';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2017-12-19
trans_update:2017-10-28
page_state_key:HTML
original_url:https://html.spec.whatwg.org/multipage/web-sockets.html
spec_status:LS
site_nav:comms,network,html
nav_prev:HTMLsse
nav_next:WORKERS


●●original_urls
_websocket-terms:https://html.spec.whatwg.org/multipage/infrastructure.html

●●original_id_map


●●link_map


	●IDL
E.SyntaxError:~WEBIDL#syntaxerror

I.WebSocket:#websocket
I.CloseEvent:#closeevent
I.CloseEventInit:#closeeventinit
I.BinaryType:#binarytype

I.EventHandler:~WAPI#eventhandler
I.Window:~WINDOW#window
I.MessageEvent:~HTMLcomms#messageevent
I.Document:~HTMLdom#document
I.Event:~DOM4#interface-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#interface-eventtarget
I.Blob:~FILEAPI#blob
I.URL:~URL1#dom-url
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.ArrayBufferView:~WEBIDL#ArrayBufferView
I.USVString:~WEBIDL#idl-USVString


m.wasClean:#dom-closeevent-wasclean
m.code:#dom-closeevent-code
m.reason:#dom-closeevent-reason

m.onclose:#handler-websocket-onclose
m.onerror:#handler-websocket-onerror
m.onmessage:#handler-websocket-onmessage
m.onopen:#handler-websocket-onopen

m.WebSocket:#dom-websocket
m.binaryType:#dom-websocket-binarytype
m.bufferedAmount:#dom-websocket-bufferedamount
m.close:#dom-websocket-close
m.extensions:#dom-websocket-extensions
m.protocol:#dom-websocket-protocol
m.readyState:#dom-websocket-readystate
m.send:#dom-websocket-send
m.url:#dom-websocket-url
m.CLOSED:#dom-websocket-closed
m.CLOSING:#dom-websocket-closing
m.CONNECTING:#dom-websocket-connecting
m.OPEN:#dom-websocket-open

m.data:~HTMLcomms#dom-messageevent-data
m.origin:~HTMLcomms#dom-messageevent-origin

l.blob:#dom-binarytype-blob
l.arraybuffer:#dom-binarytype-arraybuffer

et.open:#event-open
et.message:#event-message
et.error:#event-error
et.close:#event-close


	●RFC6455
~url:#concept-websocket-url
後述のように:#closeWebSocket
~WebSocket~task源:#websocket-task-source
消滅させる:#make-disappear
満杯~flag:#concept-websocket-close-fail


~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~event~handler IDL 属性:~WAPI#event-handler-idl-attributes
~event-loop:~WAPI#event-loop
最初の段:~WAPI#step1
~event-loopの処理~model:~WAPI#event-loop-processing-model
~task源:~WAPI#task-source
~queueされ:~WAPI#queue-a-task
~queueし:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
~task:~WAPI#concept-task
入口~設定群~obj:~WAPI#entry-settings-object
関連する~Realm:~WAPI#concept-relevant-realm

並列的:~HTMLINFRA#in-parallel

生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom
~UTF-8符号化する:~ENCODING#utf-8-encode

~URL~record:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin

~eventを発火-:~DOM4#concept-event-fire

	●WebSocket
~WebSocket接続を確立する:~FETCH#concept-websocket-establish

ws.~status~code:#_ws-status-code
ws.~WebSocket~closing~handshakeは開始され:#concept-websocket-closing-handshake
ws.~WebSocket~closing~handshakeが開始され:#concept-websocket-closing-handshake
ws.~WebSocket~closing~handshakeを開始する:#concept-websocket-start-closing-handshake

ws.確立-済み:#concept-websocket-established
ws.確立され:#concept-websocket-established
ws.~WebSocket接続を~closeする:#concept-websocket-close
ws.~WebSocket~messageを送信する:#concept-websocket-send
ws.~WebSocket~messageを受信した:#concept-websocket-message-received
ws.~closeされ:#_ws-closed
ws.~WebSocket接続は~closed:#concept-websocket-closed
ws.~closed:#concept-websocket-closed
ws.~WebSocket接続を失敗させる:#concept-websocket-fail
ws.~WebSocket接続~close~code:#concept-websocket-close-code
ws.~WebSocket接続~close事由:#concept-websocket-close-reason
ws.~cleanに~closeされた:#_ws-closed-cleanly
ws.下位protocol:#_ws-subprotocol
ws.下位protocol名:#_ws-subprotocol-name
ws.利用中の下位protocol:#concept-websocket-subprotocol
ws.利用中の拡張:#concept-websockets-active-extensions
ws.Close ~frame:#_ws-frame-type-Close
ws.Close ~message:#_ws-frame-type-Close
ws.Ping ~frame:#_ws-frame-type-Ping
ws.Pong ~frame:#_ws-frame-type-Pong
ws.~opcode:#_ws-data-opcode
ws.~payload~data:#_ws-data-Payload
ws.~app~data:#_ws-data-Application
ws.~text~data:#_ws-data-Text
ws.~binary~data:#_ws-data-Binary
ws.~frame種別:#_ws-frame-type

h.Sec-WebSocket-Protocol:#http-sec-websocket-protocol


●●words_table1


RFC6455:RFC6455-ja.html


●●words_table

	●ws／network
WebSocket:
URL:
url:
record::::レコード

client::::クライアント
server::::サーバ
status::::ステータス
素片:fragment::~::フラグメント
port::::ポート
host::::ホスト
scheme::::スキーム

close:
closed::::close 済み
open:
closing:
	~closeするための
opening:
	~openするための
ping:
pong:
opcode:

clean:
body::::ボディ
接続:connection::~
接続-:connect::~
	接続-先
開始-:start::~
事由:reason::~
拡張:extensions:~
確立-:establish:~
	確立-済み:established
data::::データ
text::::テキスト
折衝:negotiation::~
network::::ネットワーク
検証-:verify:~
解決-:resolve:~
byte::::バイト
binary::::バイナリ
handshake::::ハンドシェイク
framing::::フレーミング
frame::::フレーム
下位protocol:subprotocol:::下位プロトコル
protocol::::プロトコル
payload::::ペイロード
header::::ヘッダ
message::::メッセージ
local::::ローカル
buffer::::バッファ
buffering::::バッファリング
packet::::パケット
route:

	要請:request::~::リクエスト
応答:response::~::レスポンス
失敗-:fail:~
失敗:failure:~
種別:type:~
受信:receive:~
証明書:certificate:~
状態探針:status probing:~
生成元:origin::~::オリジン
送信:send:~
代理送信:proxying:~
接続維持:keep-alive:~
伝送-:transmit:~
転送-:transmit:~
状態:state:~
成功裡:successful:~
双方向:bidirectional:~
通信:communication:~
通信-:communicate:~
遅延計測:latency instrumentation:~
遅延測定:latency metric:~

	●未分類
interface::::インタフェース
Web::::ウェブ
obj:object:::オブジェクト
option::::オプション
garbage::::ガーベジ
overhead::::オーバーヘッド
BOM:
UTF-8:
Realm:
源:source::~::ソース
task::::タスク
背後:background:~
即時:immediate:~
disk::::ディスク
hardware::::ハードウェア
flag::::フラグ
main-thread:main thread:::メインスレッド
method::::メソッド
memory::::メモリ
属性:attribute:~
値:value:~
新たな:new:~
配列:array:~
引数:argument:~
例外:exception:~
情報:information:~
整数:integer:~
等価:equivalent:~
満杯:full:~
名前:name:~
名:name:~
繊細:subtle:~
並列的:parallel:~
鼓動:heart-beats:単方向の鼓動
手続き:steps:~
段:step:~
現在の:current:~
生の:raw:~
	特に:in particular
	this particular
突如:abrupt に:~
成功裡:successful:~
競合:race condition:~

	●未分類（動詞
call:
入口:entry::~
走らす:run する:~
走らせ:run し:~
呼出-:invoke:呼び出
呼出す:invoke する:呼び出す

access::::アクセス
event::::イベント
handler::::ハンドラ
listener::::リスナ
event-loop:event loop:::イベントループ
queue::::キュー
発火-:fire:~
設定群:settings::~

収集-:collect:~
収集:collection:~
code::::コード
構築子:constructor::~::コンストラクタ
script::::スクリプト
停滞-:stall:~
被呼出時:被 invoke 時:~
取得子:getter:~
設定子:setter:~
設定-:set:~
再設定-:reset:~

遂行-:perform:~
実行-:execute:~
実行:execution:~
結付けら:associate さ:結び付けら

spool::::スプール
	0:zero
検査-:check:~

feedback::::フィードバック
process::::プロセス
NATmapping:NAT mapping:::NAT マッピング
list::::リスト
hint::::ヒント

公開-:expose:~

構文解析-:parse::~::パース
直列化-:serialize::~::シリアル化
符号化-:encode::~::エンコード
復号-:decode::~::デコード

初期:initial:~
初期化-:initialize:~
未請求の:unsolicited:請求されていない

投出:throw:~

作成-:create:~
表現-:represent:~
攻撃:attack:~

登録-:register:~

到着時:arrive 時:~
保持-:keep:~
格納-:store:~
要素:element:~
完了-:complete:~

拒否:refuse:~
空:empty:~
型:type:~
形:form:~
消滅-:disappear:~
安全:safe:~
保守-:maintain:~
調査:probe:~
検出-:detect:~
変更-:change:~
可能化-:enable:~
更新:updates:~
構成-:comprise:~
合致-:match:~
選択-:select:~
省略-:omit:~
頻度:rate:~
下層の:underlying:~
判別-:distinguish:~
監視-:monitor:~
継続-:continue:~
表示-:display:~

	●仕様
UA:user agent:UA
app:application:::アプリ
algo:algorithm:::アルゴリズム
support::::サポート
model::::モデル
仕様:spec:~
指示-:indicate:~
指定-:specify:~
推奨-:recommend:~
制御:control:~
要件:requirements:~
利用者:user:~
作者:author:~
内容:content:~
文字列:string:~
効率的:efficient:~
実装-:implement:~
理由:reason:~
許容-:allow:~
適切:appropriate:~
適用-:apply:~
経験則:heuristics:~
定義-:define:~
定義:definition:~
導入-:introduce:~
独自:custom:~
意味-:mean:~
	要求-:require:~
	援助目的:aid
	消失-:go away
側面:aspect:~
重要:important:~
切替えた:switch した:切り替えた
既定:default:~
提供-:provide:~
単純:simple:~
正しい:correct に:~
正しく:correct に:~

	用い／利用-:use
	後述する:described below
	-:optionally

	2 個目:second:~
	最初の:first:~
	
	在る:
	処理:
	起因:incurred by
	結果:
	現時点:currently
	後者:
	後述:
	最終的:eventually
	最後:
	最初:
	参照:
	時点:
	自体:
	数値:number
	注意:
	注記:
	直前:
	~~通常:
	任意:
	必要:
	利用:
	利用中:in use
	時機


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
Communication 章の
<a href="~SPEC_URL">Web sockets</a>
節を日本語に翻訳したものです。
（公開：<time>2012-06-14</time> （ <a href="https://www.w3.org/TR/websockets/">W3C 版</a> として））
</p>

</script>


</head>
<body>

<header>
	<hgroup>
<h1 title="The WebSocket API">WebSocket</h1>

	</hgroup>


</header>

<main id="MAIN" style="display:none;">

	<section id="network">
<h2 title="Web sockets">9.3. Web sockets</h2>

		<section id="network-intro">
<h3 title="Introduction">9.3.1. 序論</h3>

~INFORMATIVE

<p>
この仕様は、~Web~appが~server側~processとの双方向~通信を可能化するための,
`WebSocket$I ~interfaceを導入する。 
◎
To enable Web applications to maintain bidirectional communications with server-side processes, this specification introduces the WebSocket interface.
</p>

<p class="note">注記：
この~interfaceは、下層の~networkへの生の~accessを許容するものではない。
例えば，独自~serverを介した~messageの代理送信を用いない限り、この~interfaceを IRC ~clientの実装に利用することはできない。
◎
This interface does not allow for raw access to the underlying network. For example, this interface could not be used to implement an IRC client without proxying messages through a custom server.
</p>

		</section>
		<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<section id="_websocket-terms">

<p>
以下の用語は、 ~WebSocket~protocol仕様 `WSP$r にて定義される（この訳では、日本語訳への直接リンクを “参照” として与える）：
</p>

<ul><li>`~status~code@ws（<a href="~RFC6455#section-7.4">参照</a>）（ HTTP 応答~status~codeではないことに注意）
</li><li>~WebSocket接続は`確立され@wsた（<a href="~RFC6455#dfn-established">参照</a>）
</li><li>`~WebSocket~messageを送信する@ws（<a href="~RFC6455#dfn-to-send">参照</a>）
</li><li>`~WebSocket~messageを受信した@ws（<a href="~RFC6455#dfn-received">参照</a>）
</li><li>`~WebSocket接続を失敗させる@ws（<a href="~RFC6455#dfn-to-fail">参照</a>）
</li><li>`~WebSocket接続を~closeする@ws（<a href="~RFC6455#dfn-to-close">参照</a>）
</li><li>`~WebSocket~closing~handshakeを開始する@ws（<a href="~RFC6455#dfn-to-start-closing-handshake">参照</a>）
</li><li>`~WebSocket~closing~handshakeは開始され@wsた（<a href="~RFC6455#dfn-closing-handshake-started">参照</a>）
</li><li>~WebSocket接続は`~closeされ@wsた（<a href="~RFC6455#dfn-closed">参照</a>）
</li><li>`~cleanに~closeされた@ws（<a href="~RFC6455#dfn-closed-cleanly">参照</a>）
</li><li>`~WebSocket接続~close~code@ws（<a href="~RFC6455#dfn-close-code">参照</a>）
</li><li>`~WebSocket接続~close事由@ws（<a href="~RFC6455#dfn-close-reason">参照</a>）
</li><li>`下位protocol@ws（<a href="~RFC6455#section-1.9">参照</a>）
</li><li>`下位protocol名@ws（<a href="~RFC6455#section-11.5">参照</a>）
</li><li>`利用中の下位protocol@ws（<a href="~RFC6455#dfn-subprotocol-in-use">参照</a>）
</li><li>`利用中の拡張@ws（<a href="~RFC6455#dfn-extensions-in-use">参照</a>）
</li><li>`Sec-WebSocket-Protocol@h ~header（<a href="~RFC6455#section-11.3.4">参照</a>）
</li><li>`Close ~frame@ws（<a href="~RFC6455#section-5.5.1">参照</a>）
</li><li>`Ping ~frame@ws（<a href="~RFC6455#section-5.5.2">参照</a>）
</li><li>`Pong ~frame@ws（<a href="~RFC6455#section-5.5.3">参照</a>）
</li><li>`~opcode@ws（<a href="~RFC6455#data-opcode">参照</a>）
</li><li>`~payload~data@ws（<a href="~RFC6455#data-Payload">参照</a>）
</li><li>`~app~data@ws（<a href="~RFC6455#data-Application">参照</a>）
</li><li>`~text~data@ws（<a href="~RFC6455#data-Text">参照</a>）
</li><li>`~binary~data@ws（<a href="~RFC6455#data-Binary">参照</a>）
</li><li>`~frame種別@ws（<a href="~RFC6455#frame-type">参照</a>）
</li></ul>

</section>

		</section>
		<section id="the-websocket-interface">

<h3 title="The WebSocket interface">9.3.2. `WebSocket^I ~interface</h3>

<pre class="idl">
enum `BinaryType@I { `blob$l, `arraybuffer$l };
[<a href="#dom-websocket">Constructor</a>(
    USVString %url,
    optional (DOMString or sequence&lt;DOMString&gt;) %protocols = []
), Exposed=(Window,Worker)]

interface `WebSocket@I : `EventTarget$I {
  readonly attribute USVString `url$m;

  // ready state
  const unsigned short `CONNECTING$m = 0;
  const unsigned short `OPEN$m = 1;
  const unsigned short `CLOSING$m = 2;
  const unsigned short `CLOSED$m = 3;
  readonly attribute unsigned short `readyState$m;
  readonly attribute unsigned long long `bufferedAmount$m;

  // networking
           attribute `EventHandler$I `onopen$m;
           attribute `EventHandler$I `onerror$m;
           attribute `EventHandler$I `onclose$m;
  readonly attribute DOMString `extensions$m;
  readonly attribute DOMString `protocol$m;
  void `close$m(optional [Clamp] unsigned short %code, optional `USVString$I %reason);

  // messaging
           attribute `EventHandler$I `onmessage$m;
           attribute `BinaryType$I `binaryType$m;
  void `send$m(`USVString$I %data);
  void `send$m(`Blob$I %data);
  void `send$m(`ArrayBuffer$I %data);
  void `send$m(`ArrayBufferView$I %data);
};</pre>


<p>
各 `WebSocket$I ~objには、
`~url@
（`~URL~record$）が結付けられる
◎
Each WebSocket object has an associated url (a URL record).
</p>

<dl class="domintro">
	<dt>%socket = new `WebSocket(url [, protocols ] )$m</dt>
	<dd>
新たな `WebSocket$I ~objを作成した上で、結付けらた~WebSocket接続を即時に確立する。
◎
Creates a new WebSocket object, immediately establishing the associated WebSocket connection.
</dd>
	<dd>
%url は文字列をとり、それが与える`~URL~record$に向けて，接続が確立される。
許容される~schemeは
`ws^l, `wss^l いずれかに限られ、他に対しては
`SyntaxError$E が投出される。
~URLに`素片$urlが伴われる場合もそれが投出される。
◎
url is a string giving the URL over which the connection is established. Only "ws" or "wss" schemes are allowed; others will cause a "SyntaxError" DOMException. URLs with fragments will also cause such an exception.
</dd>
	<dd>
%protocols （省略可）は、文字列, または 文字列の配列をとり、［
省略-時は空の配列 ／
文字列ならば，その文字列のみからなる配列
］に等価になる。
配列~内の各 文字列は`下位protocol名$wsを表す。
接続が`確立され$wsるのは、~serverが，これらの`下位protocol$wsの一つを応答に選択して返したときに限られることになる。
どの下位protocol名も、~WebSocket~protocol仕様による定義に従って，
`Sec-WebSocket-Protocol$h ~header値を構成する一連の~protocol要素に課される要件に合致する必要がある。
◎
protocols is either a string or an array of strings. If it is a string, it is equivalent to an array consisting of just that string; if it is omitted, it is equivalent to the empty array. Each string in the array is a subprotocol name. The connection will only be established if the server reports that it has selected one of these subprotocols. The subprotocol names have to match the requirements for elements that comprise the value of Sec-WebSocket-Protocol fields as defined by the WebSocket protocol specification. [WSP]
</dd>

	<dt>%socket . `send( data )$m</dt>
	<dd>
~WebSocket接続を用いて %data を伝送する。
%data は［
文字列, `Blob$I, `ArrayBuffer$I, `ArrayBufferView$I
］のいずれかをとり得る。
◎
Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.
</dd>

	<dt>%socket . `close( [ code ] [, reason ] )$m</dt>
	<dd>
~WebSocket接続を~closeする。
供された
%code は`~WebSocket接続~close~code$wsとして，
%reason は`~WebSocket接続~close事由$wsとして利用される（いずれも省略可）。
◎
Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.
</dd>

	<dt>%socket . `url$m</dt>
	<dd>
~WebSocket接続を確立するときに利用された`~url$を返す。
◎
Returns the URL that was used to establish the WebSocket connection.
</dd>

	<dt>%socket . `readyState$m</dt>
	<dd>
`WebSocket$I ~objの接続の状態を返す。
とり得る値は後述する。
◎
Returns the state of the WebSocket object's connection. It can have the values described below.
</dd>

	<dt>%socket . `bufferedAmount$m</dt>
	<dd>
`send()$m を用いて~queueされたが, まだ
~networkに伝送されていない，`~app~data$ws（~UTF-8~text／~binary~data）を成す~byte数を返す。
◎
Returns the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but not yet been transmitted to the network.
</dd>
	<dd>
~WebSocket接続が`~closeされ$wsている場合、この属性の値は，
`send()$m ~methodが~callされる度に増えることになる（この数値は、接続が`~closeされ$wsても 0 に再設定されない）。 
◎
If the WebSocket connection is closed, this attribute's value will only increase with each call to the send() method. (The number does not reset to zero once the connection closes.)
</dd>

	<dt>%socket . `extensions$m</dt>
	<dd>
~serverにより選択された拡張があれば，それを返す。
◎
Returns the extensions selected by the server, if any.
</dd>

	<dt>%socket . `protocol$m</dt>
	<dd>
~serverにより選択された`下位protocol$wsを（もしあれば）返す。
これは、下位protocolの折衝を遂行するために，構築子の（配列~形にされた） 2 個目の引数と併用され得る。
◎
Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.
</dd>

	<dt>%socket . `binaryType$m [ = %value ]</dt>
	<dd>
<p>
この `WebSocket$I ~objからの~binary~dataが~scriptにどう公開されるかを指示する文字列を返す：
◎
Returns a string that indicates how binary data from the WebSocket object is exposed to scripts:
</p>
		<dl class="switch">
			<dt>`blob$l</dt>
			<dd>
~binary~dataは `Blob$I 形で返された。
◎
Binary data is returned in Blob form.
</dd>

			<dt>`arraybuffer$l</dt>
			<dd>
~binary~dataは `ArrayBuffer$I 形で返された。
◎
Binary data is returned in ArrayBuffer form.
</dd>
		</dl>
	</dd>
	<dd>
設定して，返される~binary~dataがどう公開されるかを変更できる。
既定では `blob$l になる。
◎
Can be set, to change how binary data is returned. The default is "blob".
</dd>
</dl>



<dl class="idl-def">
	<dt>`WebSocket(url, protocols)@m</dt>
	<dd>
<p>
この構築子の被呼出時には、次の手続きを走らせ~MUST： 
◎
The WebSocket(url, protocols) constructor, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~url~record ~LET `~URL構文解析する$( %url )
◎
Let urlRecord be the result of applying the URL parser to url.
</li>
			<li>
~IF［
%~url~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%~url~record の`~scheme$url ~NIN { `ws^l, `wss^l}
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord's scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%~url~record の`素片$url ~NEQ ~NULL
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord's fragment is non-null, then throw a "SyntaxError" DOMException.
</li>
			<li>
~IF［
%protocols は文字列である
］
⇒
%protocols ~SET その文字列 1 個からなる配列
◎
If protocols is a string, set protocols to a sequence consisting of just that string.
</li>
			<li>
~IF［
%protocols 内に重複する値がある
］~OR［
%protocols 内の値に，［
~WebSocket~protocol仕様の定義による
`Sec-WebSocket-Protocol$h ~header値を構成する~protocol要素に課される要件
］を満たさないものがある
］
⇒
~THROW `SyntaxError$E
◎
If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of Sec-WebSocket-Protocol fields as defined by the WebSocket protocol specification, then throw a "SyntaxError" DOMException. [WSP]
</li>
			<li>
~RET ［
`~url$ ~SET %~url~record
］にされた，新たな `WebSocket$I ~obj
— ただし、この手続きは`並列的$に継続する
◎
Return a new WebSocket object whose url is urlRecord, but continue these steps in parallel.
</li>
			<li>
<p>
( %~url~record, %protocols, `入口~設定群~obj$ )
を与える下で、`~WebSocket接続を確立する$
`FETCH$r
◎
Establish a WebSocket connection given urlRecord, protocols, and the entry settings object. [FETCH]
</p>

<p class="note">注記：
`~WebSocket接続を確立する$のに失敗した場合
⇒
それにより，`~WebSocket接続を失敗させる$ws~algoが誘発され
⇒
それにより，`~WebSocket接続を~closeする$ws~algoが呼出され
⇒
それにより，~WebSocket接続は`~closed$wsにされ
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
If the establish a WebSocket connection algorithm fails, it triggers the fail the WebSocket connection algorithm, which then invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</p>
			</li>
		</ol>
	</dd>

	<dt>`url@m</dt>
	<dd>
取得子は、次の結果を返さ~MUST
⇒
`~URLを直列化する$( この `WebSocket$I ~objの`~url$ )
◎
The url attribute's getter must return this WebSocket object's url, serialized.
</dd>

	<dt>`readyState@m</dt>
	<dd>
<p>
この属性は、接続の状態を表し、次の値をとり得る： 
◎
The readyState attribute represents the state of the connection. It can have the following values:
</p>


		<dl>
			<dt>`CONNECTING@m （数値 0 ）</dt>
			<dd>
接続はまだ`確立-済み$wsでない。
◎
The connection has not yet been established.
</dd>

			<dt>`OPEN@m （数値 1 ）</dt>
			<dd>
~WebSocket接続は`確立-済み$wsで，通信は可能である。
◎
The WebSocket connection is established and communication is possible.
</dd>

			<dt>`CLOSING@m （数値 2 ）</dt>
			<dd>
接続は~handshakeの~close中にあるか、または
`close()$m ~methodが呼出されている。
◎
The connection is going through the closing handshake, or the close() method has been invoked.
</dd>

			<dt>`CLOSED@m （数値 3 ）</dt>
			<dd>
接続はすでに`~closeされ$wsたか, または~openできなかった。
◎
The connection has been closed or could not be opened.
</dd>
		</dl>
	</dd>
	<dd>
此れの作成-時には、この属性は `CONNECTING$m に設定され~MUST。
◎
When the object is created its readyState must be set to CONNECTING (0).
</dd>

	<dt>`extensions@m</dt>
	<dd>
この属性は、初期~時には空~文字列を返さ~MUST。
その値は、~WebSocket接続が`確立され$wsた後に，
<a href="#feedback-from-the-protocol">~protocolからの~feedback節</a>
にて定義されるように，変更され得る。
◎
The extensions attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.
</dd>

	<dt>`protocol@m</dt>
	<dd>
この属性は、初期~時には空~文字列を返さ~MUST。
その値は、~WebSocket接続が`確立され$wsた後に，
<a href="#feedback-from-the-protocol">~protocolからの~feedback節</a>
にて定義されるように，変更され得る。
◎
The protocol attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.
</dd>

	<dt>`close(code, reason)@m</dt>
	<dd>
<p>
被呼出時には、次の手続きを走らせ~MUST：
◎
The close(code, reason) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%code は与えられている
］~AND［
%code ~NIN { 1000, 3000 ～ 4999 }
］
⇒
~THROW `InvalidAccessError^E
◎
If code is present, but is neither an integer equal to 1000 nor an integer in the range 3000 to 4999, inclusive, throw an "InvalidAccessError" DOMException.
</li>
			<li>
<p>
~IF［
%reason は与えられている
］：
◎
If reason is present, then run these substeps:
</p>

				<ol>
					<li>
%reason ~SET `~UTF-8符号化する$( %reason )
◎
Let reasonBytes be the result of encoding reason.
</li>
					<li>
~IF［
%reason を成す~byte数 ~GT 123
］
⇒
~THROW `SyntaxError$E
◎
If reasonBytes is longer than 123 bytes, then throw a "SyntaxError" DOMException.
</li>
				</ol>
			</li>
			<li>
<p>
以下の項目のうち，最初に該当する段を走らす：
◎
Run the first matching steps from the following list:
</p>

<dl class="switch">
	<dt>
`readyState$m ~IN { `CLOSING$m, `CLOSED$m }
の場合：
◎
If the readyState attribute is in the CLOSING (2) or CLOSED (3) state
</dt>

	<dd>
何もしない。
◎
Do nothing.
</dd>
	<dd class="note">注記：
接続は、~closeしつつあるか, すでに~closedである。
~closedでない場合、最終的には，`後述のように$ `close$et ~eventが発火されることになる。
◎
The connection is already closing or is already closed. If it has not already, a close event will eventually fire as described below.
</dd>

	<dt>
~WebSocket接続は まだ`確立-済み$wsでない場合：
◎
If the WebSocket connection is not yet established [WSP]
</dt>
	<dd>
`~WebSocket接続を失敗させる$ws；<br />
`readyState$m 属性~値 ~SET `CLOSING$m
◎
Fail the WebSocket connection and set the readyState attribute's value to CLOSING (2). [WSP]
</dd>
	<dd class="note">注記：
`~WebSocket接続を失敗させる$ws~algoは
⇒
`~WebSocket接続を~closeする$ws~algoを呼出す
⇒
それにより，~WebSocket接続は~closedになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The fail the WebSocket connection algorithm invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</dd>
	<dt>
まだ `~WebSocket~closing~handshakeは開始され$wsていない場合
◎
If the WebSocket closing handshake has not yet been started [WSP]
</dt>
	<dd>
<p>
`~WebSocket~closing~handshakeを開始する$ws：
◎
Start the WebSocket closing handshake and set the readyState attribute's value to CLOSING (2). [WSP]
</p>

		<ul>
			<li>
<p>
%code, %reason いずれの引数も与えられていない場合
⇒
`Close ~message$wsは，~bodyを持っては~MUST_NOT。
◎
If neither code nor reason is present, the WebSocket Close message must not have a body.
</p>

<p class="note">注記：
~WebSocket~protocol仕様は、`~WebSocket~closing~handshakeを開始する$ws~algoに~status~codeが要求されるものと，誤って定めている。
◎
The WebSocket Protocol specification erroneously states that the status code is required for the start the WebSocket closing handshake algorithm.
</p>
			</li>
			<li>
%code 引数が与えられている場合
⇒
`Close ~message$wsに利用する`~status~code$wsは、その引数に与えられた整数にし~MUST。
◎
If code is present, then the status code to use in the WebSocket Close message must be the integer given by close. [WSP]
</li>
			<li>
%reason 引数も与えられている場合
⇒
`Close ~message$wsには，`~status~code$wsに加えて %reason も供され~MUST。
◎
If reason is also present, then reasonBytes must be provided in the Close message after the status code. [WSP]
</li>
		</ul>
	</dd>
	<dd>
`readyState$m 属性~値 ~SET `CLOSING$m
◎
↑</dd>
	<dd class="note">注記：
`~WebSocket~closing~handshakeを開始する$ws~algoは
⇒
最終的には`~WebSocket接続を~closeする$ws~algoを呼出すことになる
⇒
それにより、~WebSocket接続は`~closed$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The start the WebSocket closing handshake algorithm eventually invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</dd>

	<dt>他の場合
◎
Otherwise
</dt>

	<dd>
`readyState$m 属性~値 ~SET `CLOSING$m
◎
Set the readyState attribute's value to CLOSING (2).
</dd>
	<dd class="note">注記：
`~WebSocket~closing~handshakeは開始され$wsており
⇒
最終的には`~WebSocket接続を~closeする$ws~algoを呼出すことになる
⇒
それにより~WebSocket接続は`~closed$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The WebSocket closing handshake is started, and will eventually invoke the close the WebSocket connection algorithm, which will establish that the WebSocket connection is closed, and thus the close event will fire, as described below.
</dd>
</dl>
			</li>
		</ol>

	</dd>
	<dd class="note">注記：
`close()$m ~methodは、`~WebSocket~closing~handshakeを開始する$ws以前に送信した~messageを破棄するものではない
— 仮に，~UAがそのような~messageをまだ送信-中であったとしても、~handshakeは，その~messageが送信された後にのみ開始されることになる。
◎
The close() method does not discard previously sent messages before starting the WebSocket closing handshake — even if, in practice, the user agent is still busy sending those messages, the handshake will only start after the messages are sent.
</dd>

	<dt>`bufferedAmount@m</dt>
	<dd>
この属性は、 `send()$m により~queueされているが，`~event-loop$がその`最初の段$に最後に到達した時点では，~networkにまだ伝送されていない、`~app~data$ws（~UTF-8`~text~data$wsか, または`~binary~data$ws）の~byte数を返さ~MUST。
（したがって これは、現在の~taskの実行-中に伝送された~textを含む
— ~UAが~script実行と`並列的$に，背後で~textを転送できるかどうかにかかわらず。）
これには、~protocolに起因する~framingの~overheadや, OS や~network~hardwareによる~bufferingは含まれない。
◎
The bufferedAmount attribute must return the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but that, as of the last time the event loop reached step 1, had not yet been transmitted to the network. (This thus includes any text sent during the execution of the current task, regardless of whether the user agent is able to transmit text in the background in parallel with script execution.) This does not include framing overhead incurred by the protocol, or buffering done by the operating system or network hardware.
</dd>
	<dd class="example">
<p>
次の簡単な例では、 `bufferedAmount$m 属性を用いて、毎 50ms ごとに一回の頻度で（あるいは~network~~処理が追いつかない場合は追いつける頻度で）更新を送信させる。
◎
In this simple example, the bufferedAmount attribute is used to ensure that updates are sent either at the rate of one update every 50ms, if the network can handle that rate, or at whatever rate the network can handle, if that is too fast.
</p>

<pre>
var %socket = new WebSocket('ws://game.example.com:12010/updates');
%socket.onopen = function () {
  setInterval(function() {
    if (%socket.bufferedAmount == 0) {
      %socket.send(getUpdateData());
    }
  }, 50);
};</pre>
<p>
`bufferedAmount$m 属性の利用により、~networkが追いつかない頻度で~dataを送信しなくとも，~networkを使い切れるようになる（その属性の値を常時より注意して監視する必要はあるが）。
◎
The bufferedAmount attribute can also be used to saturate the network without sending the data at a higher rate than the network can handle, though this requires more careful monitoring of the value of the attribute over time.
</p>
	</dd>

	<dt>`binaryType@m</dt>
	<dd>
此れの作成-時には、この属性は，文字列 `blob^l に設定され~MUST。
◎
When a WebSocket object is created, its binaryType IDL attribute must be set to the string "blob".＼
</dd>
	<dd>
取得子は、最後に設定された値を返さ~MUST。
◎
On getting, it must return the last value it was set to.＼
</dd>
	<dd>
設定子は、新たな値をこの属性に設定し~MUST。
◎
On setting, the user agent must set the IDL attribute to the new value.
</dd>
	<dd class="note">注記：
~UAは、受信される~binary~dataの扱い方の~hintに，この属性を用いることができる：
この属性が `blob^l にされている場合、~dataは~diskへ安全に~spoolするに適するものになる。
`arraybuffer^l にされている場合、より効率的に~memory内に保持するに適するものになる。
もちろん，~UAには、受信された~dataを~memory内に保持するかどうかの決定に，より繊細な経験則を用いることが推奨される：
例えば、~data量，あるいは
直前における, ~scriptによるこの属性に対する変更の頻度を基準にするなど。
この後者の側面は特に重要になる。
何故なら、~UAが~dataを受信した後, かつ それに対する~eventを発火する前に、この属性が変更される可能性も少なからずあるので。 
◎
User agents can use the binaryType attribute as a hint for how to handle incoming binary data: if the attribute is set to "blob", it is safe to spool it to disk, and if it is set to "arraybuffer", it is likely more efficient to keep the data in memory. Naturally, user agents are encouraged to use more subtle heuristics to decide whether to keep incoming data in memory or not, e.g. based on how big the data is or how common it is for a script to change the attribute at the last minute. This latter aspect is important in particular because it is quite possible for the attribute to be changed after the user agent has received the data but before the user agent has fired the event for it.
</dd>

	<dt>`send(data)@m</dt>
	<dd>
<p>
この~methodは、接続を用いて~dataを伝送する。
被呼出時には、次の手続きを走らせ~MUST：
◎
The send(data) method transmits data using the connection.＼
</p>

		<ol>
			<li>
~IF［
`readyState$m 属性 ~EQ `CONNECTING$m
］
⇒
~THROW `InvalidStateError^E
◎
If the readyState attribute is CONNECTING, it must throw an "InvalidStateError" DOMException. Otherwise, the user agent must run the appropriate set of steps from the following list:
</li>
			<li>
<p>
~IF［
~WebSocket接続は`確立-済み$wsである
］~AND［
まだ `~WebSocket~closing~handshakeは開始され$wsていない
【すなわち `readyState$m 属性は `OPEN$m 】
］
⇒
%data 引数の型に応じて，下の表に与えられる［
`~opcode$ws, および`~payload~data$ws
］から構成される`~WebSocket~messageを送信する$ws
⇒
~bufferを要する所で~bufferが満杯になっているなどの理由で，~dataを送信できない場合
⇒
この接続の`満杯~flag$を ON にした上で， `~WebSocket接続を~closeする$ws。
◎
↓</p>

<table><thead><tr><th>引数の型
<th>`~opcode$ws
<th>`~payload~data$ws
</thead>

<tbody><tr><th><code>DOMString</code>
◎
If the argument is a string
<td>~text~frame（数値 1 ）
<td>
`~UTF-8符号化する$( %data ) の結果。
`UNICODE$r
`ENCODING$r
◎
If the WebSocket connection is established and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of the data argument using a text frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. Any invocation of this method with a string argument that does not throw an exception must increase the bufferedAmount attribute by the number of bytes needed to express the argument as UTF-8. [UNICODE] [ENCODING] [WSP]


<tr><th>`Blob$I
◎
If the argument is a Blob object
<td rowspan="3">~binary~frame（数値 2 ）
<td>
%data が表現する生~data。
`FILEAPI$r
◎
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the raw data represented by the Blob object. Any invocation of this method with a Blob argument that does not throw an exception must increase the bufferedAmount attribute by the size of the Blob object's raw data, in bytes. [WSP] [FILEAPI]


<tr><th>`ArrayBuffer$I
◎
If the argument is an ArrayBuffer object
<td>
%data が表現する~bufferに格納されている~data。
◎
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the buffer described by the ArrayBuffer object. Any invocation of this method with an ArrayBuffer argument that does not throw an exception must increase the bufferedAmount attribute by the length of the ArrayBuffer in bytes. [WSP]


<tr><th>`ArrayBufferView$I
◎
If the argument is an object that matches the ArrayBufferView type definition
<td>
%data が参照している，下層の `ArrayBuffer$I ~objが格納する~bufferの中の一区分。
◎
If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the section of the buffer described by the ArrayBuffer object that data references. Any invocation of this method with this kind of argument that does not throw an exception must increase the bufferedAmount attribute by the length of data's buffer in bytes. [WSP]
</tbody></table>

<p class="trans-note">【
ここの訳は、原文の同じ文言の繰り返しを集約して再構成している。
】</p>

			</li>
			<li>
<!-- 
この~methodの被呼出時に，例外を投出しない場合は、
 -->
`bufferedAmount$m 属性の値 ~INCBY 前~段による`~payload~data$wsに要する~byte数
◎
↑
</li>
		</ol>
	</dd>
</dl>


<p>
`WebSocket$I ~interfaceを実装する~objは、次の表に与える［
`~event~handler$, および
対応する `~event~handler~event型$
］を，`~event~handler IDL 属性$として~supportし~MUST ：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the WebSocket interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onopen@m
<td>`open@et（<a href="~HTMLindex#event-open">参照</a>）

<tr><td>`onmessage@m
<td>`message@et（<a href="~HTMLindex#event-message">参照</a>）

<tr><td>`onerror@m
<td>`error@et（<a href="~HTMLindex#event-error">参照</a>）

<tr><td>`onclose@m
<td>`close@et（<a href="~HTMLindex#event-close">参照</a>）

</tbody></table>

		</section>
		<section id="feedback-from-the-protocol">
<h3 title="Feedback from the protocol">9.3.3. ~protocolからの~feedback</h3>

<p>
~UAは、~WebSocket接続が`確立され$wsたときは，次の手続きを走らす~taskを`~queueし$~MUST：
◎
When the WebSocket connection is established, the user agent must queue a task to run these steps:
</p>


<ol>
	<li>
%O ~LET 当の `WebSocket$I ~obj
◎
↓</li>
	<li>
%O の `readyState$m 属性~値 ~SET `OPEN$m
◎
Change the readyState attribute's value to OPEN (1).
</li>
	<li>
~IF［
`利用中の拡張$ws ~NEQ ~NULL 値
］
⇒
%O の `extensions$m 属性~値 ~SET その値
◎
Change the extensions attribute's value to the extensions in use, if it is not the null value. [WSP]
</li>
	<li>
~IF［
`利用中の下位protocol$ws ~NEQ ~NULL 値
］
⇒
%O の `protocol$m 属性~値 ~SET その値
◎
Change the protocol attribute's value to the subprotocol in use, if it is not the null value. [WSP]
</li>
	<li>
%O に向けて，名前 `open$et の`~eventを発火-$する
◎
Fire an event named open at the WebSocket object.
</li>
</ol>

<p class="note">注記：
上の~algoは、~taskとして`~queueされ$るので、`確立され$wsている~WebSocket接続と,
`open$et ~event用に~event~listenerを設定しておく~scriptとの間で競合が生じることはない。
【 すなわち、 `WebSocket()$m を呼出した<em>後に</em> 同期的に登録された~event~listenerが，~serverからの初期~messageを受け取り損ねることはない。】
◎
Since the algorithm above is queued as a task, there is no race condition between the WebSocket connection being established and the script setting up an event listener for the open event.
</p>


<hr>

<p>
~UAは、［
`~frame種別$ws %type の~data %data
］を伴う，`~WebSocket~messageを受信した$wsときは、次の手続きを走らす~taskを`~queueし$~MUST：
◎
When a WebSocket message has been received with type type and data data, the user agent must queue a task to follow these steps: [WSP]
</p>

<ol>
	<li>
%O ~LET 当の `WebSocket$I ~obj
◎
↓</li>
	<li>
~IF［
%O の `readyState$m 属性~値 ~NEQ `OPEN$m
］
⇒
~RET
◎
If the readyState attribute's value is not OPEN (1), then return.
</li>
	<li>
<p>
%dataForEvent ~LET
%type が指示する~dataの種別に応じて，次で与えられる値：
◎
Let dataForEvent be determined by switching on type and binaryType:
</p>

		<dl class="switch">
			<dt>`Text^i</dt>
			<dd>
%data を内容とする，新たな `DOMString^I
◎
type indicates that the data is Text
◎
• a new DOMString containing data
</dd>

			<dt>`Binary^i</dt>
			<dd>
<p>
%O の `binaryType$m の値に応じて，次で与えられる値：
</p>

				<dl class="switch">
					<dt>`blob@l</dt>
					<dd>
生~dataが %data を表現する様な，新たな `Blob$I ~obj
`FILEAPI$r
</dd>

					<dt>`arraybuffer@l</dt>
					<dd>
%data を内容とする，新たな `ArrayBuffer$I ~obj
</dd>
				</dl>
<p>
いずれの~objも， %O に`関連する~Realm$内に作成されるとする。
</p>
◎
type indicates that the data is Binary and binaryType is "blob"
◎
• a new Blob object, created in the relevant Realm of the WebSocket object, that represents data as its raw data [FILEAPI]
◎
type indicates that the data is Binary and binaryType is "arraybuffer"
◎
• a new ArrayBuffer object, created in the relevant Realm of the WebSocket object, whose contents are data
</dd>
		</dl>
	</li>
	<li>
%O に向けて，次のように初期化された`~eventを発火-$する
⇒＃
名前 `message$et,
`MessageEvent$I を利用する,
`origin$m 属性 ~SET `生成元を直列化する$( %O の`~url$の`生成元$url ),
`data$m 属性 ~SET %dataForEvent
◎
Fire an event named message at the WebSocket object, using MessageEvent, with the origin attribute initialized to the serialization of the WebSocket object's url's origin, and the data attribute initialized to dataForEvent.
</li>
</ol>

<p class="note">注記：
~UAには、前述の手続きによる~taskを走らす前に，それが効率的に遂行できるかどうか検査しておくことが推奨される。
効率的に遂行できないなら、~bufferを準備している間に，他の`~task~queue$から~taskを取り出す等。<!--  -->
例えば、~dataの到着時には
`binaryType$m
属性が `blob^l に設定されていて,
~UAがすべての~dataを~diskへ~spoolしている状況で、その~messageに対し前述の`~task$を走らす直前に，~scriptが
`binaryType$m
を `arraybuffer^l に切替えた場合、~UAは，~main-threadが停滞しないよう，この`~task$を走らす前に~dataを RAM に戻して,
`ArrayBuffer$I ~objを作成する，などが考えられる。 
◎
User agents are encouraged to check if they can perform the above steps efficiently before they run the task, picking tasks from other task queues while they prepare the buffers if not. For example, if the binaryType attribute was set to "blob" when the data arrived, and the user agent spooled all the data to disk, but just before running the above task for this particular message the script switched binaryType to "arraybuffer", the user agent would want to page the data back to RAM before running this task so as to avoid stalling the main thread while it created the ArrayBuffer object.
</p>

<div class="example">
<p>
~text~frameの場合に
`message$et ~event用に~handlerを定義する例：
◎
Here is an example of how to define a handler for the message event in the case of text frames:
</p>

<pre>
mysocket.onmessage = function (event) {
  if (event.data == 'on') {
    turnLampOn();
  } else if (event.data == 'off') {
    turnLampOff();
  }
};</pre>

<p>
ここでの~protocolは、~serverが "on" または "off" ~messageを送信するだけの単純なものとする。
◎
The protocol here is a trivial one, with the server just sending "on" or "off" messages.
</p>
</div>

<hr>

<div class="p">
<p>
~UAは、`~WebSocket~closing~handshakeが開始され$wsたときは，次を走らす~taskを`~queueし$~MUST：
◎
When the WebSocket closing handshake is started, the user agent must＼
</p>

<ol>
	<li>
当の `WebSocket$I ~objの `readyState$m 属性~値 ~SET `CLOSING$m
◎
queue a task to change the readyState attribute's value to CLOSING (2).＼
</li>
</ol>

<p>
（ `close()$m ~methodが~callされていた場合、 `readyState$m 属性~値は，この~taskを走らす時点で，すでに `CLOSING$m に設定されていることになる。）
◎
(If the close() method was called, the readyState attribute's value will already be set to CLOSING (2) when this task runs.) [WSP]
</p>
</div>


<hr>
<p id="closeWebSocket">
~UAは、`~WebSocket接続を~closeする$wsときは（`~cleanに~closeされた$ws場合も含め），次の手続きを走らす~taskを`~queueし$~MUST：
◎
When the WebSocket connection is closed, possibly cleanly, the user agent must queue a task to run the following substeps:
</p>


<ol>
	<li>
%O ~LET 当の `WebSocket$I ~obj
◎
↓</li>
	<li>
%O の `readyState$m 属性~値 ~SET `CLOSED$m
◎
Change the readyState attribute's value to CLOSED (3).
</li>
	<li>
~IF［
~UAは`~WebSocket接続を失敗させる$ws必要がある
］~OR［
~WebSocket接続は その
`満杯~flag@
が ON にされた上で`~closeされ$wsた
］
⇒
%O に向けて，名前 `error$et の`~eventを発火-$する
◎
If the user agent was required to fail the WebSocket connection, or if the the WebSocket connection was closed after being flagged as full, fire an event named error at the WebSocket object. [WSP]
</li>
	<li>
<p>
%O に向けて，次のように初期化された`~eventを発火-$する
⇒＃
`CloseEvent$I ~interfaceを利用する,
名前 `close$et,
`wasClean$m 属性 ~SET ［ 接続は`~cleanに~closeされた$wsならば ~T ／ ~ELSE_ ~F ］,
`code$m 属性 ~SET `~WebSocket接続~close~code$ws,
`reason$m 属性 ~SET `~BOMはそのままに~UTF-8復号する$( `~WebSocket接続~close事由$ws )
◎
Fire an event named close at the WebSocket object, using CloseEvent, with the wasClean attribute initialized to true if the connection closed cleanly and false otherwise, the code attribute initialized to the WebSocket connection close code, and the reason attribute initialized to the result of applying UTF-8 decode without BOM to the WebSocket connection close reason. [WSP]
</li>
</ol>

<div class="warning">

<p>警告：
~UAは、失敗に際し，次の状況を判別し得るような情報を~script側に伝えてはならない。
◎
User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:
</p>

<ul>
	<li>
~serverの~host名を解決できなかった。
◎
A server whose host name could not be resolved.
</li>
	<li>
~serverへ~packetを成功裡に~routeできなかった。
◎
A server to which packets could not successfully be routed.
</li>
	<li>
指定された~portへの接続を~serverが拒否した。
◎
A server that refused the connection on the specified port.
</li>
	<li>
~serverとの TLS ~handshakeを正しく遂行できなかった（例えば，~serverの証明書を検証できなかったなど）。
◎
A server that failed to correctly perform a TLS handshake (e.g., the server certificate can't be verified).
</li>
	<li>
~serverが~opening~handshakeを完了しなかった（例えば，~serverが~WebSocket~serverではなかったなど）。
◎
A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).
</li>
	<li>
~WebSocket~serverは正しい~opening~handshakeを送信したが、それが指定する~optionにより，~clientは接続を解除した（例えば~serverは~clientが求めなかった`下位protocol$wsを指定してきたなど）。
◎
A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified a subprotocol that the client did not offer).
</li>
	<li>
~WebSocket~serverは~opening~handshakeを成功裡に完了した後に突如，接続を~closeした。
◎
A WebSocket server that abruptly closed the connection after successfully completing the opening handshake.
</li>
</ul>

<p>
これらすべての場合において，
`~WebSocket接続~close~code$wsは、~WebSocket~protocol仕様の要求に従って， 1006 になる。
◎
In all of these cases, the the WebSocket connection close code would be 1006, as required by the WebSocket Protocol specification. [WSP]
</p>

<p>
~scriptがこれらの場合を判別できるようになると、攻撃の前準備として，~scriptに利用者の~local~networkの調査を可能にさせ得ることになる。
◎
Allowing a script to distinguish these cases would allow a script to probe the user's local network in preparation for an attack.
</p>

<p class="note">注記：
特に，このことは、~code 1015 が~UAからは利用されないことを意味する（もちろん、~serverが `Close ~frame$wsに誤って利用した場合は除く）。
◎
In particular, this means the code 1015 is not used by the user agent (unless the server erroneously uses it in its close frame, of course).

</p>

</div>


<p>
この節にて`~queueされ$る どの`~task$も，その`~task源$は
`~WebSocket~task源@
とする。
◎
The task source for all tasks queued in this section is the WebSocket task source.
</p>

		</section>
		<section id="ping-and-pong-frames">

<h3 title="Ping and Pong frames">9.3.4. Ping および Pong ~frame</h3>

<p>
~WebSocket~protocol仕様は、接続維持, 鼓動, ~network状態探針, 遅延計測, 等々に利用し得る、`Ping ~frame$wsおよび `Pong ~frame$wsを定義する。
これらは現時点では API に公開されていない。
◎
The WebSocket protocol specification defines Ping and Pong frames that can be used for keep-alive, heart-beats, network status probing, latency instrumentation, and so forth. These are not currently exposed in the API.
</p>

<p>
~UAは、必要に応じて［
`Ping ~frame$ws ／ 未請求の`Pong ~frame$ws
］を送信してよい（例えば：
~local~network~NATmappingを保守する,
接続を検出する,
利用者に遅延測定を表示する，などのために）。
~UAは、これらの~frameを~serverへの援助目的に用いてはならない。
~serverは必要に応じて適切な時機に~pongするものとされているので。
◎
User agents may send ping and unsolicited pong frames as desired, for example in an attempt to maintain local network NAT mappings, to detect failed connections, or to display latency metrics to the user. User agents must not use pings or unsolicited pongs to aid the server; it is assumed that servers will solicit pongs whenever appropriate for the server's needs.
</p>

		</section>
		<section id="the-closeevent-interfaces">

<h3 title="The CloseEvent interface">9.3.5. `CloseEvent^I ~interface</h3>

<p>
`WebSocket$I ~objは、その `close$et ~event用に
`CloseEvent$I ~interfaceを利用する：
◎
WebSocket objects use the CloseEvent interface for their close events:
</p>

<pre class="idl">
[Constructor(DOMString %type, optional `CloseEventInit$I %eventInitDict),
 Exposed=(Window,Worker)]
interface `CloseEvent@I : `Event$I {
  readonly attribute boolean `wasClean$m;
  readonly attribute unsigned short `code$m;
  readonly attribute USVString `reason$m;
};

dictionary `CloseEventInit@I : `EventInit$I {
  boolean wasClean = false;
  unsigned short code = 0;
  USVString reason = "";
};
</pre>

<dl class="domintro">
	<dt>%event . `wasClean$m</dt>
	<dd>
［
接続は`~cleanに~closeされた$wsなら ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the connection closed cleanly; false otherwise.
</dd>

	<dt>%event . `code$m</dt>
	<dd>
~serverから提供された`~WebSocket接続~close~code$wsを返す。
◎
Returns the WebSocket connection close code provided by the server.
</dd>

	<dt>%event . `reason$m</dt>
	<dd>
~serverから提供された`~WebSocket接続~close事由$wsを返す。
◎
Returns the WebSocket connection close reason provided by the server.
</dd>
</dl>


<dl class="idl-def">
	<dt>`wasClean@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
<!-- term-closed-cleanly -->
◎
The wasClean attribute must return the value it was initialized to.＼
</dd>
	<dd>
この属性は、接続が`~cleanに~closeされた$wsかどうかを表現する。
◎
It represents whether the connection closed cleanly or not.
</dd>

	<dt>`code@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The code attribute must return the value it was initialized to.＼
</dd>
	<dd>
この属性は、~serverから供された `~WebSocket接続~close~code$wsを表現する。
◎
It represents the WebSocket connection close code provided by the server.
</dd>

	<dt>`reason@m</dt>
	<dd>
取得子は、初期化-時の値を返さ~MUST。
◎
The reason attribute must return the value it was initialized to.＼
</dd>
	<dd>
この属性は、~serverから供された`~WebSocket接続~close事由$wsを表現する。
◎
It represents the WebSocket connection close reason provided by the server.
</dd>

</dl>

		</section>
		<section id="garbage-collection">

<h3 title="Garbage collection">9.3.6. ~garbage収集</h3>


<p>
次のいずれかに該当する `WebSocket$I ~objは、~garbage収集されてはならない：
◎
↓</p>

<ul>
	<li>
<p>
`~event-loop$がその`最初の段$に最後に到達した時点で、
`readyState$m 属性が［
次の表の 1 列目の値
］にされていて，［
同じ行の 2 列目に示される~event型に対し登録されている~event~listenerが在る
］もの。
</p>

<table>
<thead><tr><th>`readyState$m
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`CONNECTING$m (0)
<td>`open$et, `message$et, `error$et, `close$et

<tr><td>`OPEN$m (1)
<td>`message$et, `error$et, `close$et

<tr><td>`CLOSING$m (2)
<td>`error$et, `close$et

</tbody></table>

◎
A WebSocket object whose readyState attribute's value was set to CONNECTING (0) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for open events, message events, error events, or close events.
◎
A WebSocket object whose readyState attribute's value was set to OPEN (1) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for message events, error, or close events.
◎
A WebSocket object whose readyState attribute's value was set to CLOSING (2) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for error or close events.
</li>
	<li>
その接続は`確立-済み$wsであり，~network伝送-用に~dataが~queueされているもの。
◎
A WebSocket object with an established connection that has data queued to be transmitted to the network must not be garbage collected. [WSP]
</li>
</ul>


<p>
接続が~openしているにもかかわらず， `WebSocket$I ~objが~garbage収集された場合、~UAには，`~WebSocket~closing~handshakeを開始する$wsことが要求される。
このときの `Close ~message$wsは、`~status~code$wsを伴わないものとする。
◎
If a WebSocket object is garbage collected while its connection is still open, the user agent must start the WebSocket closing handshake, with no status code for the Close message. [WSP]
</p>

<hr>
<p>
~UAは， `WebSocket$I ~objを
`消滅させる@
必要が生じたとき（これは `Document$I ~objが消失した時に起こる）は、次を走らせ~MUST：
◎
If a user agent is to make disappear a WebSocket object (this happens when a Document object goes away), the user agent must follow the first appropriate set of steps from the following list:
</p>

<ol>
	<li>
~IF［
~WebSocket接続はまだ`確立-済み$wsでない
］
⇒
`~WebSocket接続を失敗させる$ws
◎
If the WebSocket connection is not yet established [WSP]
• Fail the WebSocket connection. [WSP]
</li>
	<li>
~ELIF［
`~WebSocket~closing~handshakeは開始され$wsていない
］
⇒
`~WebSocket~closing~handshakeを開始する$ws
— `Close ~message$wsに用いる`~status~code$wsは 1001 とする
◎
If the WebSocket closing handshake has not yet been started [WSP]
• Start the WebSocket closing handshake, with the status code to use in the WebSocket Close message being 1001. [WSP]
◎
Otherwise
• Do nothing.
</li>
</ol>

		</section>
	</section>

</main><!-- id="MAIN" -->
