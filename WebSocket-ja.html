<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>WebSockets （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	Util.switchWordsInit({
		persisted_parts: { _acks1: E('_acks1'), _ipr1: E('_ipr1') },
		toc_main: 'MAIN0',
		generate: expand
	});
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'h':
	text = `\`<code class="header">${text}</code>\``;
	break;
case 'bl':
	text = `\`<code class="literal">${text}</code>\``;
	break;
case 'U':
	text = `U+${key}`
	break;
case 'X':
	text = `0x${key}`;
	break;
case 'ws':
	if(indicator === '@'){
		text += `（<a href="${link_map['ws0.' + key] || '#'}">参照</a>）`;
	}
	break;
case 'mc':
	text = 'constructor';
	href = `#dom-${key.toLowerCase()}`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}

</script>

<script type="text/plain" id="_source_data">

●●options

spec_date:2022-06-02
trans_update:2022-02-20
	source_checked:210301
spec_status:LS
original_url:https://websockets.spec.whatwg.org/
ref_id_prefix:refs
copyright:,whatwg
site_nav:network
trans_1st_pub:2021-12-20

●●class_map
et:event-type
sc:scheme
E:error
h:header
X:hex-value
U:code-point
cn:cp-name

●●tag_map
I:code
m:code
c:code
sc:code
et:code
h:code
E:code
X:span
U:span
cn:span
i:i
cite:cite

●●mdn_urls
websocket:API/WebSocket
closeevent:API/CloseEvent
	closeeventinit:API/CloseEventInit
	binarytype:API/BinaryType

event-open:API/WebSocket/open_event
event-message:API/WebSocket/message_event
event-error:API/WebSocket/error_event
event-close:API/WebSocket/close_event

●●link_map

	●IDL

Clamp:~WEBIDLjs#Clamp
Exposed:~WEBIDLjs#Exposed

I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.ArrayBufferView:~WEBIDL#ArrayBufferView
I.BufferSource:~WEBIDL#BufferSource
	DOMException:~WEBIDL#idl-DOMException
DOMString:~WEBIDL#idl-DOMString
sequence:~WEBIDL#idl-sequence
undefined:~WEBIDL#idl-undefined
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned short:~WEBIDL#idl-unsigned-short
USVString:~WEBIDL#idl-USVString
boolean:~WEBIDL#idl-boolean

E.InvalidAccessError:~WEBIDL#invalidaccesserror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror

I.WebSocket:#websocket
I.CloseEvent:#closeevent
I.CloseEventInit:#dictdef-closeeventinit
I.BinaryType:#enumdef-binarytype
I.Blob:~FILEAPI#blob
	I.Blob:~FILEAPI#dfn-Blob

I.Document:~DOM4#document
I.Event:~DOM4#event
I.EventHandler:~WAPI#eventhandler
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.MessageEvent:~HTMLcomms#messageevent

m.new WebSocket:#dom-websocket-websocket
	constructor:#dom-websocket-websocket
m.binaryType:#dom-websocket-binarytype
m.bufferedAmount:#dom-websocket-bufferedamount
m.close:#dom-websocket-close
m.extensions:#dom-websocket-extensions
m.protocol:#dom-websocket-protocol
m.readyState:#dom-websocket-readystate
m.send:#dom-websocket-send
m.url:#dom-websocket-url
m.CLOSED:#dom-websocket-closed
m.CLOSING:#dom-websocket-closing
m.CONNECTING:#dom-websocket-connecting
m.OPEN:#dom-websocket-open

m.onopen:#dom-websocket-onopen
m.onmessage:#dom-websocket-onmessage
m.onerror:#dom-websocket-onerror
m.onclose:#dom-websocket-onclose


constructor:~DOM4#concept-event-constructor
	constructor:#dom-closeevent-closeevent

m.wasClean:#dom-closeevent-wasclean
m.code:#dom-closeevent-code
m.reason:#dom-closeevent-reason

mb.wasClean:#dom-closeeventinit-wasclean
mb.code:#dom-closeeventinit-code
mb.reason:#dom-closeeventinit-reason

l.blob:#dom-binarytype-blob
l.arraybuffer:#dom-binarytype-arraybuffer

m.data:~HTMLcomms#dom-messageevent-data
m.origin:~HTMLcomms#dom-messageevent-origin

	%url:#dom-websocket-websocket-url-protocols-url
	%protocols:#dom-websocket-websocket-url-protocols-protocols
	%code:#dom-websocket-close-code-reason-code
	%reason:#dom-websocket-close-code-reason-reason
	%data:#dom-websocket-send-data-data
	%type:#dom-closeevent-closeevent-type-eventinitdict-type
	%eventInitDict:#dom-closeevent-closeevent-type-eventinitdict-eventinitdict


et.close:#eventdef-websocket-close
et.error:#eventdef-websocket-error
et.message:#eventdef-websocket-message
et.open:#eventdef-websocket-open


h.Upgrade:~HTTPsem#field.upgrade
h.Connection:~HTTPsem#field.connection
h.Sec-WebSocket-Key:~RFC6455#section-11.3.1
h.Sec-WebSocket-Extensions:~RFC6455#section-11.3.2
	h.Sec-WebSocket-Accept:~RFC6455#section-11.3.3
h.Sec-WebSocket-Protocol:~RFC6455#section-11.3.4
h.Sec-WebSocket-Version:~RFC6455#section-11.3.5


sc.ws:~RFC6455#section-11.1.1
sc.wss:~RFC6455#section-11.1.2
st.101:~HTTPsem#status.101

	●用語
~WebSocket~task源:#websocket-task-source
消滅させる:#make-disappear
~WebSocket接続を得する:#concept-websocket-connection-obtain
~WebSocket接続を確立する:#concept-websocket-establish
wS.~URL:#websocket-internal-url
wS.準備y状態:#websocket-ready-state
wS.~binary種別:#websocket-binary-type
後述のように:#closeWebSocket
満杯か:#flagged-as-full

	●外部
	コレ:~WEBIDL#this

連結する:~INFRA#string-concatenate
~forgiving-base64符号化する:~INFRA#forgiving-base64-encode
同型に符号化する:~INFRA#isomorphic-encode

並列的:~HTMLINFRA#in-parallel
~eventを発火する:~DOM4#concept-event-fire

~event~handler~event型:~WAPI#event-handler-event-type
~event~handler:~WAPI#event-handlers
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~event~loop:~WAPI#event-loop
最初の段:~WAPI#step1
~task源:~WAPI#task-source
~queueされ:~WAPI#queue-a-task
~taskを~queueする:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
~task:~WAPI#concept-task
関連な設定群~obj:~WAPI#relevant-settings-object
関連な~Realm:~WAPI#concept-relevant-realm

~header値:~FETCH#header-value
~headerを結合する:~FETCH#concept-header-list-combine
~header~listから値を抽出する:~FETCH#extract-header-list-values
~headerを付加する:~FETCH#concept-header-list-append
要請:~FETCH#concept-request
rq.~URL:~FETCH#concept-request-url
rq.~cache~mode:~FETCH#concept-request-cache-mode
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~header~list:~FETCH#concept-request-header-list
rq.~mode:~FETCH#concept-request-mode
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
rq.~referrer:~FETCH#concept-request-referrer
rq.~sw~mode:~FETCH#request-service-workers-mode

rs.状態s:~FETCH#concept-response-status
rs.~header~list:~FETCH#concept-response-header-list

~byte列~data:~FILEAPI#_ref-bytes

接続:~FETCH#concept-connection
~fetchする:~FETCH#concept-fetch
~fetching:~FETCH#concept-fetch
~network~error:~FETCH#concept-network-error
i.応答の処理n:~FETCH#process-response
i.並列~queueを利用するか:~FETCH#fetch-useparallelqueue

~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
url.素片:~URL1#concept-url-fragment
url.~scheme:~URL1#concept-url-scheme
url.生成元:~URL1#concept-url-origin
url.~path:~URL1#concept-url-path
url.~port:~URL1#concept-url-port
url.~query:~URL1#concept-url-query
url.~host:~URL1#concept-url-host

~BOMはそのままに~UTF-8復号する:~ENCODING#utf-8-decode-without-bom
~UTF-8符号化する:~ENCODING#utf-8-encode
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

	●WebSocket
ws.状態s~code:#_ws-status-code
ws.~WebSocket接続は確立-済み:#_concept-websocket-established
ws.確立-:#_concept-websocket-established
ws.失敗-:#_concept-websocket-fail
ws.~WebSocket接続を失敗させる:#_concept-websocket-fail
ws.~WebSocket~closing~handshakeは開始-済み:#_concept-websocket-closing-handshake
ws.~WebSocket~closing~handshakeを開始した:#_concept-websocket-closing-handshake
ws.~WebSocket~closing~handshakeを開始する:#_concept-websocket-start-closing-handshake
ws.~WebSocket~messageを送信する:#_concept-websocket-send
ws.~WebSocket~messageを受信した:#_concept-websocket-message-received
ws.~WebSocket接続を~closeする:#_concept-websocket-close
ws.~closeされ:#_concept-websocket-closed
ws.~WebSocket接続は~close済み:#_concept-websocket-closed
ws.~WebSocket接続~close~code:#_concept-websocket-close-code
ws.~WebSocket接続~close事由:#_concept-websocket-close-reason
ws.~cleanに~closeされた:#_ws-closed-cleanly
ws.下位protocol:#_ws-subprotocol
ws.下位protocol名:#_ws-subprotocol-name
ws.利用-中の下位protocol:#_concept-websocket-subprotocol
ws.利用-中の拡張:#_concept-websockets-active-extensions
ws.Close ~frame:#_ws-frame-type-Close
ws.Close ~message:#_ws-frame-type-Close
ws.Ping ~frame:#_ws-frame-type-Ping
ws.Pong ~frame:#_ws-frame-type-Pong
ws.~opcode:#_ws-data-opcode
ws.~payload~data:#_ws-data-Payload

	i.Text:#data-Text
	i.Binary:#data-Binary
	ws.~app~data:#_ws-data-Application
	ws.~frame種別:#_ws-frame-type
	ws.~text~data:#_ws-data-Text
	ws.~binary~data:#_ws-data-Binary

ws0.状態s~code:~RFC6455#section-7.4
ws0.~WebSocket接続は確立-済み:~RFC6455#dfn-established
	:~RFC6455#page-19:~:text=_The%20WebSocket%20Connection%20is%20Established_,-and
ws0.~WebSocket接続を失敗させる:~RFC6455#dfn-to-fail
	:~RFC6455#section-7.1.7
ws0.~WebSocket~closing~handshakeを開始する:~RFC6455#dfn-to-start-closing-handshake
	:~RFC6455#section-7.1.2
ws0.~WebSocket~closing~handshakeは開始-済み:~RFC6455#dfn-closing-handshake-started
	:~RFC6455#section-7.1.3
ws0.~WebSocket~messageを送信する:~RFC6455#dfn-to-send
	:~RFC6455#page-66:~:text=needs%20to-,_Send%20a%20WebSocket%20Message_
ws0.~WebSocket~messageを受信した:~RFC6455#dfn-received
	:~RFC6455#page-66:~:text=_A%20WebSocket%20Message%20Has%20Been%20Received_
ws0.~WebSocket接続を~closeする:~RFC6455#dfn-to-close
	:~RFC6455#section-7.1.1
ws0.~WebSocket接続は~close済み:~RFC6455#dfn-closed
	:~RFC6455#section-7.1.4
ws0.~cleanに~closeされた:~RFC6455#dfn-closed-cleanly
	:~RFC6455#page-41:~:text=closed-,_cleanly_.
ws0.~WebSocket接続~close~code:~RFC6455#dfn-close-code
	:~RFC6455#section-7.1.5
ws0.~WebSocket接続~close事由:~RFC6455#dfn-close-reason
	:~RFC6455#section-7.1.6
ws0.下位protocol:~RFC6455#section-1.9
ws0.下位protocol名:~RFC6455#section-11.5
ws0.利用-中の下位protocol:~RFC6455#dfn-subprotocol-in-use
	:~RFC6455#page-19:~:text=_Subprotocol%20In,Use_
ws0.利用-中の拡張:~RFC6455#dfn-extensions-in-use
ws0.Close ~frame:~RFC6455#section-5.5.1
ws0.Ping ~frame:~RFC6455#section-5.5.2
ws0.Pong ~frame:~RFC6455#section-5.5.3
ws0.~opcode:~RFC6455#data-opcode
ws0.~payload~data:~RFC6455#data-Payload
	ws0.~app~data:~RFC6455#data-Application
	ws0.~text~data:~RFC6455#data-Text
	ws0.~binary~data:~RFC6455#data-Binary
	ws0.~frame種別:~RFC6455#section-5.6
	ws0.~frame種別:~RFC6455#frame-type
	:~RFC6455#http-sec-websocket-protocol

	extensions in use:~RFC6455#
	section 4.1:http://tools.ietf.org/html/rfc6455#section-4.1

_acks1:#_acks1
_ipr1:#_ipr1

●●words_table1
RFC6455:RFC6455-ja.html

●●words_table

	●ws／network
WebSocket:
Fetch:
HSTS:
status::::ステータス
close:
	~close済み:closed
open:
closing:
	~closeするための
opening:
	~openするための
ping:
pong:
opcode:
clean:
body::::ボディ
	確立-済み:established
handshake::::ハンドシェイク
	~frame法:framing
下位protocol:subprotocol:::下位プロトコル
payload::::ペイロード
local::::ローカル
buffering::::バッファ処理
packet::::パケット
route:
	~proxy法:proxying
受信:receive::~
証明書:certificate::~
状態探針:status probing::~
接続維持:keep-alive::~
双方向-:bidirectional::~
計測:instrumentation:~
NATmapping:NAT mapping:::NAT マッピング
	待時間:latency metric
hostname::::ホスト名
internet::::インターネット
	運ぶ:carry する

	●処理
main::::メイン
spool::::スプール
process::::プロセス

突如:abruptに:~
競争:race condition::~
満杯:full:~
背後:background:~
停滞-:stall::~
入口:entry::~
切替えた:switchした:切り替えた
頻度:rate:~
準備y:ready::準備
準備-:prepare:~
準備:preparation:~
並列:parallel::~

	設定し直-:reset
	速すぎ:too fast
	追いつける:can handle
	常時:over time
	消え去る:go away
	%~URL~record:urlRecord

	●保安
秘匿情報:secret:~
騙す:trickする:~
探査-:probe::~

	●仕様
繊細:subtle:~
拒否-:refuse:~
改め:alteration:~
文言:language:~
普通の:ordinaryな:~
遺物:artefact:~
本当の:realな:~
承認-:acknowledge:~
深刻:serious:~
選取る:pickする:選び取る
助力-:help:~
repository::::リポジトリ

	利用-中:in use
	利用:
	後述する:described below
	-:optionally
	~~通常:
	参照:
	注意:
	注記:
	可能性も少なからず:quite possible
	一箇所に集約:in a single location
	理想だが:ideally
	念頭に置く:Keep that in mind
	重ね方:layering
	~~正しい:right
	課される:incurred by
	-:applying

	●未分類
請求-:solicite:~
	請求されていない:unsolicited
到着-:arrive:~
保つ:keepする:~
消滅-:disappear:~
同型:isomorphic::~
forgiving-base64:
socket:::ソケット
overhead::::オーバーヘッド
BOM:
RAM:
disk::::ディスク
鼓動:heart-beats:単方向の鼓動
生の:raw:~

	在る
	成す:comprise
	~~構成:structured
	構成:comprised of
	~~受信した:incoming


	●指示語
	this particular
	2 個目:second
	結果:
	後者:
	後述:
	最終的:eventually
	最後:
	最初:
	時点:
	自体:
	数値:number
	直前:
	時機
	the following list

●●ref_normative

[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[FILEAPI]
    Marijn Kruisselbrink; Arun Ranganathan. ＜File API＞. URL: https://w3c.github.io/FileAPI/
[HSTS]
    J. Hodges; C. Jackson; A. Barth. ＜HTTP Strict Transport Security (HSTS)＞. November 2012. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6797
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[UNICODE]
    ＜The Unicode Standard＞. URL: https://www.unicode.org/versions/latest/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[WSP]
    I. Fette; A. Melnikov. ＜The WebSocket Protocol＞. December 2011. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6455

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
<a href="~SPEC_URL">WebSockets</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

Participate:
	<a href="https://github.com/whatwg/websockets">GitHub whatwg/websockets</a> (<a href="https://github.com/whatwg/websockets/issues/new">new issue</a>, <a href="https://github.com/whatwg/websockets/issues">open issues</a>)
	<a href="https://whatwg.org/chat">Chat on Matrix</a>

Commits:
	<a href="https://github.com/whatwg/websockets/commits">GitHub whatwg/websockets/commits</a>
	<a href="/commit-snapshots/3945f96a661764048fb6252fa075e22f3942ab92/" id="commit-snapshot-link">Snapshot as of this commit</a>
	<a href="https://twitter.com/whatsockets">@whatsockets</a>
Tests:
	<a href="https://github.com/web-platform-tests/wpt/tree/master/websockets">web-platform-tests websockets/</a> (<a href="https://github.com/web-platform-tests/wpt/labels/websockets">ongoing work</a>)

各国語翻訳（非規範的）
	日本語（このページ）

</script>

</head>

<body>
<header>

<a href="https://whatwg.org/"><img
	style="float: right;"
	alt="WHATWG"
	height="100"
	src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj4KICA8Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0NSIgZmlsbD0iI2ZmZiIgc3Ryb2tlPSIjM2M3OTBhIiBzdHJva2Utd2lkdGg9IjEwIi8+CiAgPHBhdGggZmlsbD0iIzNjNzkwYSIgZD0iTSA2Ni4yMyA2Mi4yMzcgTCA3NC4yMzUgNjIuMjM3IEwgNzQuMjM1IDQzLjAxOSBMIDY1LjIxOCAzNC4wMDIgTCA1OS41NTcgMzkuNjYxIEwgNjYuMjMgNDYuMzM0IEwgNjYuMjMgNjIuMjM3IFogTSA3NC4yNTQgNjYuMjQ5IEwgNjIuNTk3IDY2LjI0OSBMIDQ2LjMzNiA2Ni4yNDkgTCAzOS42NjIgNTkuNTc3IEwgNDIuNDkyIDU2Ljc0NiBMIDQ4LjAwNSA2Mi4yNTkgTCA1OS4zNDUgNjIuMjU5IEwgNDguMTczIDUxLjA2NiBMIDUxLjAyNCA0OC4yMTUgTCA2Mi4xOTYgNTkuMzg3IEwgNjIuMTk2IDQ4LjA0NiBMIDU2LjcwNiA0Mi41NTYgTCA1OS41MTQgMzkuNzQ3IEwgNDUuNjM5IDI1LjgwOCBMIDMxLjk1NCAyNS44MDggTCAzMS45NTQgMjUuODA4IEwgMTcuNzYzIDI1LjgwOCBMIDI1Ljc0NiAzMy43OTEgTCAyNS43NDYgMzMuODEyIEwgMjUuNzg4IDMzLjgxMiBMIDQyLjMwNCAzMy44MTIgTCA0OC4xNTMgMzkuNjYxIEwgMzkuNTk5IDQ4LjIxNSBMIDMzLjc1MSA0Mi4zNjUgTCAzMy43NTEgMzcuODI1IEwgMjUuNzQ2IDM3LjgyNSBMIDI1Ljc0NiA0NS42OCBMIDM5LjU5OSA1OS41MzUgTCAzMy45NjEgNjUuMTc0IEwgNDIuOTc4IDc0LjE5MiBMIDU2LjY2MiA3NC4xOTIgTCA4Mi4yMzggNzQuMTkyIEwgODIuMjM4IDc0LjE5MiBMIDc0LjI1NCA2Ni4yNDkgWiIvPgo8L3N2Zz4K"
></a>

	<hgroup>
<h1 id="title">WebSockets</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
~ABSTRACT

<p>
この仕様は、［
~web~appが~server側~processとの双方向-通信を保守する
］ことを可能化するための~APIを供する。
◎
This specification provides APIs to enable web applications to maintain bidirectional communications with server-side processes.
</p>

<p class="trans-note">【
この~pageは，以前は［
~HTML仕様の一部を成す § Web sockets の和訳
］を与えていたが、［
その節（および， `Fetch^cite 内の~WebSocketに関連な節）が独立な仕様として，
この標準に分離された
］ことに伴い，その内容の和訳に置換したものである。
】</p>

	</section>

<main id="MAIN0">
	<section id="network-intro">
<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
［
~web~appが~server側~processとの双方向-通信を保守する
］ことを可能化するため、
この仕様は， `WebSocket$I ~interfaceを導入する。
◎
To enable web applications to maintain bidirectional communications with server-side processes, this specification introduces the WebSocket interface.
</p>

<p class="note">注記：
この~interfaceは、
下層の~networkへの生の~accessを許容するものではない。
例えば，~custom~serverを介した~messageの~proxy法を利用しない限り、
この~interfaceを IRC ~clientの実装に利用することはできない。
◎
This interface does not allow for raw access to the underlying network. For example, this interface could not be used to implement an IRC client without proxying messages through a custom server.
</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ~THROW 等々）の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照されたし。
</p>

<section id="_websocket-terms">

<p>
以下の用語は、
~WebSocket~protocol仕様 `WSP$r にて定義される
（この訳では、日本語訳への~linkを “参照” として与える）：
</p>

<ul><li>`状態s~code@ws（ HTTP 応答~状態s~codeではないことに注意）
</li><li>`~WebSocket接続は確立-済み@ws
</li><li>`~WebSocket接続を失敗させる@ws
</li><li>`~WebSocket~closing~handshakeを開始する@ws
</li><li>`~WebSocket~closing~handshakeは開始-済み@ws
</li><li>`~WebSocket~messageを送信する@ws
</li><li>`~WebSocket~messageを受信した@ws
</li><li>`~WebSocket接続を~closeする@ws
</li><li>`~WebSocket接続は~close済み@ws
</li><li>`~cleanに~closeされた@ws
</li><li>`~WebSocket接続~close~code@ws
</li><li>`~WebSocket接続~close事由@ws
</li><li>`下位protocol@ws
</li><li>`下位protocol名@ws
</li><li>`利用-中の下位protocol@ws
</li><li>`利用-中の拡張@ws
</li><li>`Close ~frame@ws
</li><li>`Ping ~frame@ws
</li><li>`Pong ~frame@ws
</li><li>`~opcode@ws
</li><li>`~payload~data@ws
<!-- 
~frame種別@ws
~app~data@ws
~text~data@ws
~binary~data@ws
-->
</li></ul>

</section>

	</section>
	<section id="websocket-protocol">
<h2 title="WebSocket protocol alterations">2. ~WebSocket~protocolの改め</h2>

<div class="note">
<p>注記：
この節は、［
~WebSocket~protocolの~opening~handshakeに課される~client要件
］の一部を［
`Fetch^cite にて定義される~algoに統合する
］ために置換する。
~CSP, ~cookie, ~HSTS, その他， `Fetch^cite に関係する~protocolは、
この仕方で，一箇所に集約して取扱われるようになる。
~RFCがこの文言で更新されるのが理想だが、
それは決して容易にはならない。
以下に定義される `WebSocket$I ~APIは、
この文言を利用する。
`WSP$r `FETCH$r
◎
This section replaces part of the WebSocket protocol opening handshake client requirement to integrate it with algorithms defined in Fetch. This way CSP, cookies, HSTS, and other Fetch-related protocols are handled in a single location. Ideally the RFC would be updated with this language, but it is never that easy. The WebSocket API, defined below, uses this language. [WSP] [FETCH]
</p>

<p>
これは、［
`WebSocket Protocol^cite の “~WebSocket接続を確立する” ~algo
］を［
新たなものに置換して， `Fetch^cite に統合する
］ような仕方で働く
— “~WebSocket接続を確立する” は、
3 つの~algo［
接続を設定しておく,
~handshake要請を作成して伝送する,
~handshake応答を検証する
］からなる。
その重ね方は、
`Fetch^cite による［
先ず~handshakeを作成し, 次に接続を設定しておいてから、
~handshakeを伝送し, ~~最後に応答を検証する
］のとは，異なる。
この改めを読むときは、
そのことを念頭に置くこと。
◎
The way this works is by replacing The WebSocket Protocol’s "establish a WebSocket connection" algorithm with a new one that integrates with Fetch. "Establish a WebSocket connection" consists of three algorithms: setting up a connection, creating and transmiting a handshake request, and validating the handshake response. That layering is different from Fetch, which first creates a handshake, then sets up a connection and transmits the handshake, and finally validates the response. Keep that in mind while reading these alterations.
</p>
</div>

		<section id="websocket-connections">
<h3 title="Connections">2.1. 接続</h3>

<div class="algo">
<p>
`~WebSocket接続を得する@
ときは、
所与の
( %~URL )
に対し，次の手続きを走らす：
◎
To obtain a WebSocket connection, given a url, run these steps:
</p>
<ol>
	<li>
%~host ~LET %~URL の`~host$url
◎
Let host be url’s host.
</li>
	<li>
%~port ~LET %~URL の`~port$url
◎
Let port be url’s port.
</li>
	<li>
%資源~名 ~LET `002F^U (/)
◎
Let resource name be U+002F (/),＼
</li>
	<li>
%資源~名 に次の結果を付加する
⇒
%~URL の`~path$urlを `002F^U (/) で`連結する$
◎
followed by the strings in url’s path (including empty strings), if any, separated from each other by U+002F (/).
</li>
	<li>
~IF［
%~URL の`~query$url ~NEQ 空~文字列
］
⇒
%資源~名 に次を順に付加する
⇒＃
`003F^U (?),
%~URL の`~query$url
◎
If url’s query is non-empty, append U+003F (?), followed by url’s query, to resource name.
</li>
	<li>
%~secureか ~LET %~URL の`~scheme$urlに応じて
⇒＃
`http^l ならば ~F ／
~ELSE_ ~T
◎
Let secure be false, if url’s scheme is "http", and true otherwise.
</li>
	<li>
［
`WebSocket Protocol^cite
<a href="~RFC6455#section-4.1">§ ~clientに課される要件</a>
の
<a href="~RFC6455#dfn-to-establish">前半の手続き</a>
の段 2 〜 5
］に言明されている要件に従って，~WebSocket接続を確立する `WSP$r
— 次を与える下で
⇒
( %~host, %~port, %資源~名, %~secureか )
◎
Follow the requirements stated in step 2 to 5, inclusive, of the first set of steps in section 4.1 of The WebSocket Protocol to establish a WebSocket connection, passing host, port, resource name and secure. [WSP]
</li>
	<li>
~RET［
接続は確立されたなら それ ／
~ELSE_ `失敗^i
］
◎
If that established a connection, return it, and return failure otherwise.
</li>
</ol>

<p class="note">注記：
~WebSocket接続は、
異なる~propを運ぶ少し異なる~~構成なので，共有できないが、
“普通の” `接続$にごく近いものである。
◎
Although structured a little differently, carrying different properties, and therefore not shareable, a WebSocket connection is very close to identical to an "ordinary" connection.
</p>
</div>

		</section>
		<section id="websocket-opening-handshake">
<h3 title="Opening handshake">2.2. ~opening~handshake</h3>

<div class="algo">
<p>
`~WebSocket接続を確立する@
ときは、
所与の
( %~URL, %~protocol~list, %~client )
に対し，次の手続きを走らす：
◎
To establish a WebSocket connection, given a url, protocols, and client, run these steps:
</p>
<ol>
	<li>
%要請~URL ~LET %~URL の複製
◎
Let requestURL be a copy of url,＼
</li>
	<li>
<p>
%要請~URL の`~scheme$url ~SET %~URL の`~scheme$urlに応じて
⇒＃
`ws^l ならば `http^l ／
~ELSE_ `https^l
◎
with its scheme set to "http", if url’s scheme is "ws", and to "https" otherwise.
</p>

<p class="note">注記：
この~schemeの変更は、
`~fetching$に上手く統合するために本質的になる。
例えば~HSTSは、
こうしないと働かなくなる。
これは、
旧来の遺物である
— ~WebSocketを別個な~schemeにする本当の理由はない。
`HSTS$r
◎
This change of scheme is essential to integrate well with fetching. E.g., HSTS would not work without it. There is no real reason for WebSocket to have distinct schemes, it’s a legacy artefact. [HSTS]
</li>
	<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %要請~URL,
`~client$rq ~SET %~client,
`~sw~mode$rq ~SET `none^l,
`~referrer$rq ~SET `no-referrer^l,
`~mode$rq ~SET `websocket^l,
`資格証~mode$rq ~SET `include^l,
`~cache~mode$rq ~SET `no-store^l,
`~redirect~mode$rq ~SET `error^l
◎
Let request be a new request, whose URL is requestURL, client is client, service-workers mode is "none", referrer is "no-referrer", mode is "websocket", credentials mode is "include", cache mode is "no-store" , and redirect mode is "error".
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Upgrade$h, `websocket^bl )
)
◎
Append (`Upgrade`, `websocket`) to request’s header list.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Connection$h, `Upgrade^bl )
)
◎
Append (`Connection`, `Upgrade`) to request’s header list.
</li>
	<li>
<p>
%~key値 ~LET `同型に符号化する$( `~forgiving-base64符号化する$( ~randomに選定された 16 ~byteの値 ) )
◎
Let keyValue be a nonce consisting of a randomly selected 16-byte value that has been forgiving-base64-encoded and isomorphic encoded.
</p>

<p class="example">
例えば，~randomに選定された値が~byte列［
`01^X `02^X `03^X `04^X `05^X `06^X `07^X `08^X `09^X `0a^X `0b^X `0c^X `0d^X `0e^X `0f^X `10^X
］ならば、
%~key値 は，それを~forgiving-base64符号化した結果
`AQIDBAUGBwgJCgsMDQ4PEC==^l
を同型に符号化した結果
`AQIDBAUGBwgJCgsMDQ4PEC==^bl
になる。
◎
If the randomly selected value was the byte sequence 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10, keyValue would be forgiving-base64-encoded to "AQIDBAUGBwgJCgsMDQ4PEC==" and isomorphic encoded to `AQIDBAUGBwgJCgsMDQ4PEC==`.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Sec-WebSocket-Key$h, %~key値 )
)
◎
Append (`Sec-WebSocket-Key`, keyValue) to request’s header list.
</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Sec-WebSocket-Version$h, `13^bl )
)
◎
Append (`Sec-WebSocket-Version`, `13`) to request’s header list.
</li>
	<li>]
%~protocol~list を成す
~EACH( %~protocol )
に対し
⇒
%要請 の`~header~list$rq内で`~headerを結合する$(
( `Sec-WebSocket-Protocol$h, %~protocol )
)
◎
For each protocol in protocols, combine (`Sec-WebSocket-Protocol`, protocol) in request’s header list.
</li>
	<li>
<p>
%permessageDeflate ~LET ~UA定義な `permessage-deflate^l 拡張`~header値$
`WSP$r
◎
Let permessageDeflate be a user-agent defined "permessage-deflate" extension header value. [WSP]
</p>

<div class="example" id="example-permessage-deflate">
`permessage-deflate; client_max_window_bits^bl
</div>

	</li>
	<li>
%要請 の`~header~list$rqに`~headerを付加する$(
( `Sec-WebSocket-Extensions$h, %permessageDeflate )
)
◎
Append (`Sec-WebSocket-Extensions`, permessageDeflate) to request’s header list.
</li>
	<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request＼
</p>
		<ul>
			<li>
`並列~queueを利用するか$i ~SET ~T
◎
with useParallelQueue set to true,＼
</li>
			<li>
<p>
`応答の処理n$i ~SET 所与の
( %応答 )
に対し，次を走らす手続き：
◎
and processResponse given response being these steps:
</p>
				<ol>
					<li>
~IF［
%応答 は`~network~error$である
］~OR［
%応答 の`状態s$rs ~NEQ `101$st
］
⇒
`~WebSocket接続を失敗させる$ws
◎
If response is a network error or its status is not 101, fail the WebSocket connection.
</li>
					<li>
<p>
~IF［
%~protocol~list は空でない
］~AND［
`~header~listから値を抽出する$( %応答 の`~header~list$rs, `Sec-WebSocket-Protocol$h ) ~IN { ~NULL, `失敗^i, 空~byte列 }
］
⇒
`~WebSocket接続を失敗させる$ws
◎
If protocols is not the empty list and extracting header list values given `Sec-WebSocket-Protocol` and response’s header list results in null, failure, or the empty byte sequence, then fail the WebSocket connection.
</p>

<p class="note">注記：
これは、［
`WebSocket Protocol^cite にて定義される，この~headerに対する検査
］と異なる。
そこでは、［
~clientから要請されていない下位protocolがある場合
］しか受持ってなかった。
ここでは、［
~clientから要請された下位protocolが~serverから承認されていない場合
］も受持つ。
◎
This is different from the check on this header defined by The WebSocket Protocol. That only covers a subprotocol not requested by the client. This covers a subprotocol requested by the client, but not acknowledged by the server.
</p>
					</li>
					<li>
［
`WebSocket Protocol^cite
<a href="~RFC6455#section-4.1">§ ~clientに課される要件</a>の後半の手続きの段 2 〜 6
］に言明されている要件に従って，
%応答 を検証する
— これは、~WebSocket接続を［
`失敗-$wsさせるか`確立-$wsさせる
］ことになる。
◎
Follow the requirements stated step 2 to step 6, inclusive, of the last set of steps in section 4.1 of The WebSocket Protocol to validate response. This either results in fail the WebSocket connection or the WebSocket connection is established.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<p>
◎
↑↑Fail the WebSocket connection and the WebSocket connection is established are defined by The WebSocket Protocol. [WSP]
</p>

<p class="warning">警告：
~redirectを追わない理由は、
~web~browser文脈に深刻な~security問題をもたらすからである。
そのため、
この~handshakeは，一般に制約される。
例えば、
ある~hostが ある~pathに~WebSocket~serverを立てていたとする。
その~hostが，別の~pathにも
~openな~HTTP~redirect器
【`<a href="https://wiki.suikawiki.org/n/open%20redirector">参考</a>^】
を立てた時点で、
~WebSocket~URLを与え得るような どの~scriptも
— その~URLの~hostnameが~~正しいことを検査したとしても —
~internet上の~~任意の~hostと通信する（したがって秘匿情報を共有し得る）よう騙すことが可能になる。
【！ https://www.ietf.org/mail-archive/web/hybi/current/msg06951.html】
◎
The reason redirects are not followed and this handshake is generally restricted is because it could introduce serious security problems in a web browser context. For example, consider a host with a WebSocket server at one path and an open HTTP redirector at another. Suddenly, any script that can be given a particular WebSocket URL can be tricked into communicating to (and potentially sharing secrets with) any host on the internet, even if the script checks that the URL has the right hostname.
</p>

		</section>
	</section>
	<section id="the-websocket-interface">
<h2 title="The WebSocket interface">3. `WebSocket^I ~interface</h2>

		<section id="interface-definition">
<h3 title="Interface definition">3.1. ~interface定義</h3>

<p>
`WebSocket$I ~class用の~Web~IDL定義は、
次で与えられる：
◎
The Web IDL definition for the WebSocket class is given as follows:
</p>

<pre class="idl">
enum `BinaryType@I { `blob$l, `arraybuffer$l };

[`Exposed$=(Window,Worker)]
interface `WebSocket@I : `EventTarget$I {
  `WebSocket$mc(`USVString$ %url, optional (`DOMString$ or `sequence$&lt;`DOMString$&gt;) %protocols = []);
  readonly attribute `USVString$ `url$m;

  // ready state
  const `unsigned short$ `CONNECTING$m = 0;
  const `unsigned short$ `OPEN$m = 1;
  const `unsigned short$ `CLOSING$m = 2;
  const `unsigned short$ `CLOSED$m = 3;
  readonly attribute `unsigned short$ `readyState$m;
  readonly attribute `unsigned long long$ `bufferedAmount$m;

  // networking
  attribute `EventHandler$I `onopen$m;
  attribute `EventHandler$I `onerror$m;
  attribute `EventHandler$I `onclose$m;
  readonly attribute `DOMString$ `extensions$m;
  readonly attribute `DOMString$ `protocol$m;
  `undefined$ `close$m(optional [`Clamp$] `unsigned short$ %code, optional `USVString$ %reason);

  // messaging
  attribute `EventHandler$I `onmessage$m;
  attribute `BinaryType$I `binaryType$m;
  `undefined$ `send$m((`BufferSource$I or `Blob$I or `USVString$) %data);
};
</pre>

<p>
各 `WebSocket$I ~objには、
次に挙げるものが結付けられる：
◎
↓</p>
<dl class="def-list">
	<dt>
`~URL@wS
◎
Each WebSocket object has an associated url,＼
</dt>
	<dd>
`~URL~record$。
【構築-時に設定される。】
◎
which is a URL record.
</dd>

	<dt>
`~binary種別@wS
（ `binary type^en ）
◎
Each WebSocket object has an associated binary type,＼
</dt>
	<dd>
`BinaryType$I 値
— 初期~時は `blob$l になるモノトスル。
◎
which is a BinaryType. Initially it must be "blob".
</dd>

	<dt>
`準備y状態@wS
（ `ready state^en ）
◎
Each WebSocket object has an associated ready state,＼
</dt>
	<dd>
当の接続の状態を表現している数値
— 初期~時は `CONNECTING$m になるモノトスル。
◎
which is a number representing the state of the connection. Initially it must be CONNECTING (0).＼
</dd>
	<dd>
<p>
次に挙げる値をとり得る：
◎
It can have the following values:
</p>
		<ul>
			<li>
`CONNECTING@m
（数値 0 ）
⇒
`~WebSocket接続は確立-済み$wsでない。
◎
CONNECTING (numeric value 0)
• The connection has not yet been established.
</li>
			<li>
`OPEN@m
（数値 1 ）
⇒
`~WebSocket接続は確立-済み$wsであり，通信は可能である。
◎
OPEN (numeric value 1)
• The WebSocket connection is established and communication is possible.
</li>
			<li>
`CLOSING@m
（数値 2 ）
⇒
接続は~handshakeの~close中にあるか，
または `close()$m ~methodが呼出されている。
◎
CLOSING (numeric value 2)
• The connection is going through the closing handshake, or the close() method has been invoked.
</li>
			<li>
`CLOSED@m
（数値 3 ）
⇒
接続はすでに`~closeされ$wsたか，
または~openできなかった。
◎
CLOSED (numeric value 3)
• The connection has been closed or could not be opened.
</li>
		</ul>
	</dd>
</dl>

<dl class="domintro">
	<dt>%socket = `new WebSocket(url [, protocols ])$m</dt>
	<dd>
新たな `WebSocket$I ~objを作成した上で、
それに結付けられる~WebSocket接続を即時に確立する。
◎
Creates a new WebSocket object, immediately establishing the associated WebSocket connection.
</dd>
	<dd>
%url は文字列をとり、
それが与える`~URL~record$に向けて，接続が確立される。
許容される~schemeは
`ws^l, `wss^l いずれかに限られ、
他に対しては
`SyntaxError$E が投出される。
~URLに`素片$urlが伴われる場合もそれが投出される。
◎
url is a string giving the URL over which the connection is established. Only "ws" or "wss" schemes are allowed; others will cause a "SyntaxError" DOMException. URLs with fragments will also cause such an exception.
</dd>
	<dd>
省略可能な %protocols は、［
文字列, または文字列の配列
］をとり，［
省略-時は空な配列 ／
文字列ならば，その文字列のみからなる配列
］と等価になる。
配列~内の各 文字列は`下位protocol名$wsを表す。
接続が`確立-$wsされるのは、
~serverが，これらの`下位protocol$wsの一つを応答に選定して返したときに限られることになる。
どの下位protocol名も、［
`WSP$r に定義される `Sec-WebSocket-Protocol$h ~field
］の値を成す各~protocol要素に課される要件に合致する必要がある。
◎
protocols is either a string or an array of strings. If it is a string, it is equivalent to an array consisting of just that string; if it is omitted, it is equivalent to the empty array. Each string in the array is a subprotocol name. The connection will only be established if the server reports that it has selected one of these subprotocols. The subprotocol names have to match the requirements for elements that comprise the value of `Sec-WebSocket-Protocol` fields as defined by The WebSocket protocol. [WSP]
</dd>

	<dt>%socket.`send(data)$m</dt>
	<dd>
~WebSocket接続を利用して %data を伝送する。
%data は［
文字列, `Blob$I, `ArrayBuffer$I, `ArrayBufferView$I
］のいずれかをとり得る。
◎
Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.
</dd>

	<dt>%socket.`close([ code ] [, reason ])$m</dt>
	<dd>
~WebSocket接続を~closeする。
%code は`~WebSocket接続~close~code$wsとして，
%reason は`~WebSocket接続~close事由$wsとして利用される（いずれも省略可）。
◎
Closes the WebSocket connection, optionally using code as the WebSocket connection close code and reason as the WebSocket connection close reason.
</dd>

	<dt>%socket.`url$m</dt>
	<dd>
~WebSocket接続を確立するときに利用された`~URL$を返す。
◎
Returns the URL that was used to establish the WebSocket connection.
</dd>

	<dt>%socket.`readyState$m</dt>
	<dd>
<p>
当の~WebSocket接続の状態を返す。
上に述べた値をとり得る。
◎
Returns the state of the WebSocket connection. It can have the values described above.
</dd>

	<dt>%socket.`bufferedAmount$m</dt>
	<dd>
`send()$m を利用して~queueされたが, まだ
~networkに伝送されていない，~app~data（~UTF-8~text／~binary~data）を成す~byte数を返す。
◎
Returns the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but not yet been transmitted to the network.
</dd>
	<dd>
~WebSocket接続が`~closeされ$wsた場合、
この属性の値は，
`send()$m ~methodが~callされる度に増えることになる
（この数値は、接続が`~closeされ$wsても， 0 に設定し直されることはない）。
◎
If the WebSocket connection is closed, this attribute’s value will only increase with each call to the send() method. (The number does not reset to zero once the connection closes.)
</dd>

	<dt>%socket.`extensions$m</dt>
	<dd>
~serverにより選定された拡張があれば，それを返す。
◎
Returns the extensions selected by the server, if any.
</dd>

	<dt>%socket.`protocol$m</dt>
	<dd>
~serverにより選定された`下位protocol$wsがあれば，それを返す。
これは、
下位protocolの折衝を遂行するために，
構築子の（配列~形にされた） 2 個目の引数と併用され得る。
◎
Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor’s second argument to perform subprotocol negotiation.
</dd>

	<dt>%socket.`binaryType$m</dt>
	<dd>
<p>
~socketからの~binary~dataが~scriptにどう公開されるかを指示する文字列を返す：
◎
Returns a string that indicates how binary data from socket is exposed to scripts:
</p>
		<dl class="switch">
			<dt>`blob$l</dt>
			<dd>
~binary~dataは `Blob$I 形で返された。
◎
Binary data is returned in Blob form.
</dd>

			<dt>`arraybuffer$l</dt>
			<dd>
~binary~dataは `ArrayBuffer$I 形で返された。
◎
Binary data is returned in ArrayBuffer form.
</dd>
		</dl>
<p>
既定では `blob$l になる。
◎
The default is "blob".
</p>
	</dd>

	<dt>%socket.`binaryType$m = %value</dt>
	<dd>
~binary~dataがどう返されるかを変更する。
◎
Changes how binary data is returned.
</dd>
</dl>

<div class="algo">
<p>
`new WebSocket(url, protocols)@m
構築子~手続きは：
◎
The new WebSocket(url, protocols) constructor steps are:
</p>
<ol>
	<li>
%~URL~record ~LET `~URL構文解析する$( %url )
◎
Let urlRecord be the result of applying the URL parser to url.
</li>
	<li>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%~URL~record の`~scheme$url ~NIN { "`ws$sc", "`wss$sc" }
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord’s scheme is not "ws" or "wss", then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
%~URL~record の`素片$url ~NEQ ~NULL
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord’s fragment is non-null, then throw a "SyntaxError" DOMException.
</li>
	<li>
%~protocol~list ~LET %protocols に応じて
⇒＃
文字列であるならば « %protocols »
~ELSE_ %protocols
◎
If protocols is a string, set protocols to a sequence consisting of just that string.
</li>
	<li>
~IF［
%~protocol~list 内に重複する値がある
］~OR［
%~protocol~list 内の値に［［
`WSP$r に定義される `Sec-WebSocket-Protocol$h ~field
］の値を成す各~protocol要素に課される要件
］を満たさないものがある
］
⇒
~THROW `SyntaxError$E
◎
If any of the values in protocols occur more than once or otherwise fail to match the requirements for elements that comprise the value of `Sec-WebSocket-Protocol` fields as defined by The WebSocket protocol, then throw a "SyntaxError" DOMException. [WSP]
</li>
	<li>
コレの`~URL$wS ~SET %~URL~record
◎
Set this's url to urlRecord.
</li>
	<li>
%~client ~LET コレに`関連な設定群~obj$
◎
Let client be this's relevant settings object.
</li>
	<li>
<p>
この段は`並列的$に走らす
⇒
`~WebSocket接続を確立する$( %~URL~record, %~protocol~list, %~client )
`FETCH$r
◎
Run this step in parallel:
• Establish a WebSocket connection given urlRecord, protocols, and client. [FETCH]
</p>

<p class="note">注記：
`~WebSocket接続を確立する$のに失敗した場合
⇒
それにより，`~WebSocket接続を失敗させる$ws~algoが誘発され
⇒
それにより，`~WebSocket接続を~closeする$ws~algoが呼出され
⇒
それにより，`~WebSocket接続は~close済み$wsになり
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
If the establish a WebSocket connection algorithm fails, it triggers the fail the WebSocket connection algorithm, which then invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</p>
	</li>
</ol>
</div>

<hr>

<div class="algo">
`url@m
取得子~手続きは
⇒
~RET `~URLを直列化する$( コレの`~URL$wS )
◎
The url getter steps are to return this's url, serialized.
</div>

<div class="algo">
`readyState@m
取得子~手続きは
⇒
~RET コレの`準備y状態$wS
◎
The readyState getter steps are to return this's ready state.
</div>

<p>
`extensions@m
属性は、
初期~時には空~文字列を返すモノトスル。
その値は、
~WebSocket接続が`確立-$wsされた後に，
<a href="#feedback-from-the-protocol">§ ~protocolからの~feedback</a>
にて定義されるとおり変更され得る。
◎
The extensions attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.
</p>

<p>
`protocol@m
属性は、
初期~時には空~文字列を返すモノトスル。
その値は、
~WebSocket接続が`確立-$wsされた後に，
<a href="#feedback-from-the-protocol">§ ~protocolからの~feedback</a>
にて定義されるとおり変更され得る。
◎
The protocol attribute must initially return the empty string. After the WebSocket connection is established, its value might change, as defined below.
</p>

<div class="algo">
<p>
`close(code, reason)@m
~method手続きは：
◎
The close(code, reason) method steps are:
</p>
<ol>
	<li>
~IF［
%code ~NEQ ε
］~AND［
%code ~NIN { 1000, 3000 ～ 4999 }
］
⇒
~THROW `InvalidAccessError^E
◎
If code is present, but is neither an integer equal to 1000 nor an integer in the range 3000 to 4999, inclusive, throw an "InvalidAccessError" DOMException.
</li>
	<li>
<p>
~IF［
%reason ~NEQ ε
］：
◎
If reason is present, then run these substeps:
</p>
		<ol>
			<li>
%事由~byte列 ~SET `~UTF-8符号化する$( %reason )
◎
Let reasonBytes be the result of encoding reason.
</li>
			<li>
~IF［
%事由~byte列 を成す~byte数 ~GT 123
］
⇒
~THROW `SyntaxError$E
◎
If reasonBytes is longer than 123 bytes, then throw a "SyntaxError" DOMException.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
コレの`準備y状態$wS ~IN { `CLOSING$m, `CLOSED$m }
］
⇒
~RET
◎
Run the first matching steps from the following list:
◎
If this's ready state is CLOSING (2) or CLOSED (3)
• Do nothing.
</p>

<p class="note">注記：
接続は、
~closeしつつあるか, すでに~close済みである。
~close済みでない場合、
最終的には，`後述のように$ `close$et ~eventが発火されることになる。
◎
The connection is already closing or is already closed. If it has not already, a close event will eventually fire as described below.
</p>
	</li>
	<li>
<p>
~ELIF［
`~WebSocket接続は確立-済み$wsでない `WSP$r
］
⇒＃
`~WebSocket接続を失敗させる$ws；
コレの`準備y状態$wS ~SET `CLOSING$m
◎
If the WebSocket connection is not yet established [WSP]
• Fail the WebSocket connection and set this's ready state to CLOSING (2). [WSP]
</p>

<p class="note">注記：
`~WebSocket接続を失敗させる$ws~algoは
⇒
`~WebSocket接続を~closeする$ws~algoを呼出す
⇒
それにより，`~WebSocket接続は~close済み$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The fail the WebSocket connection algorithm invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</p>
	</li>
	<li>
<p>
~ELIF［
`~WebSocket~closing~handshakeは開始-済み$wsでない
］：
◎
If the WebSocket closing handshake has not yet been started [WSP]
</p>
		<ol>
			<li>
<p>
`~WebSocket~closing~handshakeを開始する$ws：
◎
Start the WebSocket closing handshake＼
↓and set this's ready state to CLOSING (2). [WSP]
</p>
				<ul>
					<li>
<p>
［
%code ~EQ ε
］~AND［
%reason ~EQ ε
］ならば
⇒
`Close ~message$wsは，~bodyを持たないモノトスル。
◎
If neither code nor reason is present, the WebSocket Close message must not have a body.
</p>

<p class="note">注記：
`WSP$r は、［
`~WebSocket~closing~handshakeを開始する$ws~algoに状態s~codeが要求される
］ものと，誤って言明している。
◎
The WebSocket Protocol erroneously states that the status code is required for the start the WebSocket closing handshake algorithm.
</p>
					</li>
					<li>
［
%code ~NEQ ε
］ならば
⇒
`Close ~message$wsに利用する`状態s~code$wsは、
%code に与えられた整数にするモノトスル。
◎
If code is present, then the status code to use in the WebSocket Close message must be the integer given by code. [WSP]
</li>
					<li>
［
%code ~NEQ ε
］~AND［
%reason ~NEQ ε
］ならば
⇒
`Close ~message$wsには，`状態s~code$wsに加えて %reason も供するモノトスル。
◎
If reason is also present, then reasonBytes must be provided in the Close message after the status code. [WSP]
</li>
				</ul>
			</li>
			<li>
<p>
コレの`準備y状態$wS ~SET `CLOSING$m
◎
↑</p>
			</li>
		</ol>

<p class="note">注記：
`~WebSocket~closing~handshakeを開始する$ws~algoは
⇒
最終的には`~WebSocket接続を~closeする$ws~algoを呼出すことになる
⇒
それにより，`~WebSocket接続は~close済み$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The start the WebSocket closing handshake algorithm eventually invokes the close the WebSocket connection algorithm, which then establishes that the WebSocket connection is closed, which fires the close event as described below.
</p>
	</li>
	<li>
<p>
~ELSE
⇒
コレの`準備y状態$wS ~SET `CLOSING$m
◎
Otherwise
• Set this's ready state to CLOSING (2).
</p>

<p class="note">注記：
`~WebSocket~closing~handshakeは開始-済み$wsであり
⇒
最終的には`~WebSocket接続を~closeする$ws~algoを呼出すことになる
⇒
それにより，`~WebSocket接続は~close済み$wsになる
⇒
それに伴い，`後述のように$ `close$et ~eventが発火されることになる。
◎
The WebSocket closing handshake is started, and will eventually invoke the close the WebSocket connection algorithm, which will establish that the WebSocket connection is closed, and thus the close event will fire, as described below.
</p>
	</li>
</ol>

<p class="note">注記：
`close()$m ~methodは、［
`~WebSocket~closing~handshakeを開始する$ws以前に送信した~message
］を破棄するものではない
— 仮に，~UAがそのような~messageをまだ送信-中であったとしても、
~handshakeが開始されるのは，その~messageを送信した後に限られることになる。
◎
The close() method does not discard previously sent messages before starting the WebSocket closing handshake — even if, in practice, the user agent is still busy sending those messages, the handshake will only start after the messages are sent.
</p>
</div>

<hr>

<div class="algo">
<p>
`bufferedAmount@m
取得子~手続きは、
~app~data（~UTF-8~text~data, または~binary~data）
— `send()$m により~queueされたが、
`~event~loop$がその`最初の段$に最後に達した時点では，~networkにまだ伝送されていないそれ —
の~byte数を返す。
（したがって、
これは，現在の~taskの実行-中に伝送された~textを含む
— ~UAが［
~script実行と`並列的$に，背後で~textを伝送できるかどうか
］にかかわらず）。
これには、［
~protocolから課される~frame法の~overhead／
~OSや~network~hardwareによる~buffering
］は含まれない。
◎
The bufferedAmount getter steps are to return the number of bytes of application data (UTF-8 text and binary data) that have been queued using send() but that, as of the last time the event loop reached step 1, had not yet been transmitted to the network. (This thus includes any text sent during the execution of the current task, regardless of whether the user agent is able to transmit text in the background in parallel with script execution.) This does not include framing overhead incurred by the protocol, or buffering done by the operating system or network hardware.
</p>
</div>

<div class="example" id="buffered-amount-example">
<p>
次の単純な例では、
`bufferedAmount$m 属性を利用して，毎 50ms ごとに一回の頻度で
（あるいは，速すぎて~networkが追いつかない場合は追いつける頻度で）
更新を送信する。
◎
In this simple example, the bufferedAmount attribute is used to ensure that updates are sent either at the rate of one update every 50ms, if the network can handle that rate, or at whatever rate the network can handle, if that is too fast.
</p>

<pre class="lang-js">
var %socket = new WebSocket('ws://game.example.com:12010/updates');
%socket.onopen = function () {
  setInterval(function() {
    if (%socket.bufferedAmount == 0) {
      %socket.send(getUpdateData());
    }
  }, 50);
};
</pre>

<p>
`bufferedAmount$m 属性を利用すれば、
~networkが追いつかない頻度で~dataを送信しなくとも，
~networkを使い切れるようになる
（その属性の値を常時~注意深く監視する必要はあるが）。
◎
The bufferedAmount attribute can also be used to saturate the network without sending the data at a higher rate than the network can handle, though this requires more careful monitoring of the value of the attribute over time.
</p>
</div>

<hr>

<div class="algo">
`binaryType@m
取得子~手続きは
⇒
~RET コレの`~binary種別$wS
◎
The binaryType getter steps are to return this's binary type.
</div>

<div class="algo">
`binaryType@m
設定子~手続きは
⇒
コレの`~binary種別$wS ~SET 所与の値
◎
The binaryType setter steps are to set this's binary type to the given value.
</div>

<p class="note">注記：
~UAは、
受信した~binary~dataを取扱う方法~用の~hintとして，`~binary種別$wSを利用できる：
これが `blob$l にされている場合、
~dataは~diskへ安全に~spoolするに適するものになる。
`arraybuffer$l にされている場合、
より効率的に~memory内に保つに適するものになる。
もちろん，~UAには、
~~受信した~dataを~memory内に保つかどうか裁定するときに，より繊細な経験則を利用することが推奨される
— 例：~data量や［
直前における，~scriptによるこの属性に対する変更の頻度
］を基準にするなど。
この後者の側面は、
特に重要になる
— ~UAが［
~dataを受信した後, かつ それ用の~eventを発火する前
］に，この属性が変更される可能性も少なからずあるので。
◎
User agents can use the binary type as a hint for how to handle incoming binary data: if it is "blob", it is safe to spool it to disk, and if it is "arraybuffer", it is likely more efficient to keep the data in memory. Naturally, user agents are encouraged to use more subtle heuristics to decide whether to keep incoming data in memory or not, e.g. based on how big the data is or how common it is for a script to change the attribute at the last minute. This latter aspect is important in particular because it is quite possible for the attribute to be changed after the user agent has received the data but before the user agent has fired the event for it.
</p>

<div class="algo">
<p>
`send(data)@m
その~method手続きは：
◎
The send(data) method steps are:
</p>
<ol>
	<li>
~IF［
コレの`準備y状態$wS ~EQ `CONNECTING$m
］
⇒
~THROW `InvalidStateError^E
◎
If this's ready state is CONNECTING, then throw an "InvalidStateError" DOMException.
</li>
	<li>
<p>
~IF［
`~WebSocket接続は確立-済み$wsである
］~AND［
`~WebSocket~closing~handshakeは開始-済み$wsでない
【すなわち，`準備y状態$wS ~EQ `OPEN$m 】
］
⇒
%data 引数の型に応じて，下の表に与えられる［
`~opcode$ws, および`~payload~data$ws
］から構成される`~WebSocket~messageを送信する$ws
⇒
~bufferを要する所で~bufferが満杯になっているなどの~~理由で，~dataを送信できない場合
⇒
この接続の`満杯か$を ~T にした上で，`~WebSocket接続を~closeする$ws
</p>

<table><thead><tr><th>引数の型
<th>`~opcode$ws
<th>`~payload~data$ws
</thead>

<tbody><tr><th><code>DOMString</code>
<td>~text~frame（数値 1 ）
<td>
`~UTF-8符号化する$( %data ) の結果。
`UNICODE$r
`ENCODING$r

<tr><th>`Blob$I
<td rowspan="3">~binary~frame（数値 2 ）
<td>
%data が表現する生~data。
`FILEAPI$r

<tr><th>`ArrayBuffer$I
<td>
%data が表現する~bufferに格納されている~data。

<tr><th>`ArrayBufferView$I
<td>
%data が参照している，下層の `ArrayBuffer$I ~objが格納する~bufferの中の一区分。
</tbody></table>

<p class="trans-note">【
ここの訳は、
原文の同じ文言の繰り~~返しを集約して再構成している。
】</p>

◎
Otherwise, the user agent must run the appropriate set of steps from the following list:
◎
If data is a string
• If the WebSocket connection is established and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of the data argument using a text frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. Any invocation of this method with a string argument that does not throw an exception must increase the bufferedAmount attribute by the number of bytes needed to express the argument as UTF-8. [UNICODE] [ENCODING] [WSP]
◎
If data is a Blob object
• If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the raw data represented by the Blob object. Any invocation of this method with a Blob argument that does not throw an exception must increase the bufferedAmount attribute by the size of the Blob object’s raw data, in bytes. [WSP] [FILEAPI]
◎
If data is an ArrayBuffer
• If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the buffer described by the ArrayBuffer object. Any invocation of this method with an ArrayBuffer argument that does not throw an exception must increase the bufferedAmount attribute by the length of the ArrayBuffer in bytes. [WSP]
◎
If data is an ArrayBufferView
• If the WebSocket connection is established, and the WebSocket closing handshake has not yet started, then the user agent must send a WebSocket Message comprised of data using a binary frame opcode; if the data cannot be sent, e.g. because it would need to be buffered but the buffer is full, the user agent must flag the WebSocket as full and then close the WebSocket connection. The data to be sent is the data stored in the section of the buffer described by the ArrayBuffer object that data references. Any invocation of this method with this kind of argument that does not throw an exception must increase the bufferedAmount attribute by the length of data’s buffer in bytes. [WSP]
</li>
	<li>
【！この~methodの被呼出時に，例外を投出しない場合は、】
`bufferedAmount$m 属性の値 ~INCBY 前~段による`~payload~data$wsに要する~byte数
◎
↑</li>
</ol>
</div>

<hr>

<p>
`WebSocket$I ~interfaceを実装する~objは、
次の表に挙げる［
`~event~handler$, それに対応する `~event~handler~event型$
］を`~event~handler~IDL属性$として~supportするモノトスル：
◎
The following are the event handlers (and their corresponding event handler event types) that must be supported, as event handler IDL attributes, by all objects implementing the WebSocket interface:
</p>

<table><thead><tr><th>`~event~handler$
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`onopen@m
<td>`open$et

<tr><td>`onmessage@m
<td>`message$et

<tr><td>`onerror@m
<td>`error$et

<tr><td>`onclose@m
<td>`close$et

</tbody></table>

		</section>
	</section>
	<section id="feedback-from-the-protocol">
<h2 title="Feedback from the protocol">4. ~protocolからの~feedback</h2>

<div class="algo">
<p>
~UAは、
~WebSocket接続を`確立-$wsしたときは，
次の手続きを走らす`~taskを~queueする$モノトスル：
◎
When the WebSocket connection is established, the user agent must queue a task to run these steps:
</p>
<ol>
	<li>
%O ~LET 当の `WebSocket$I ~obj
◎
↓</li>
	<li>
%O の`準備y状態$wS ~SET `OPEN$m
◎
Change the ready state to OPEN (1).
</li>
	<li>
~IF［
`利用-中の拡張$ws ~NEQ ~NULL 値
］
⇒
%O の `extensions$m 属性~値 ~SET `利用-中の拡張$ws
◎
Change the extensions attribute’s value to the extensions in use, if it is not the null value. [WSP]
</li>
	<li>
~IF［
`利用-中の下位protocol$ws ~NEQ ~NULL 値
］
⇒
%O の `protocol$m 属性~値 ~SET その値
`WSP$r
◎
Change the protocol attribute’s value to the subprotocol in use, if it is not the null value. [WSP]
</li>
	<li>
`~eventを発火する$( %O,
`open@et
)
◎
Fire an event named open at the WebSocket object.
</li>
</ol>

<p class="note">注記：
上の~algoは、
~taskとして`~queueされ$るので，［
`確立-$wsされる~WebSocket接続,
`open$et ~event用に~event~listenerを設定しておく~script
］との間で競争が生じることはない。
【 すなわち、 `new WebSocket()$m を呼出した<em>後に</em>同期的に登録された~event~listenerが，~serverからの初期~messageを受け取り損ねることはない。】
◎
Since the algorithm above is queued as a task, there is no race condition between the WebSocket connection being established and the script setting up an event listener for the open event.
</p>
</div>

<hr>

<div class="algo">
<p>
~UAは，
`~WebSocket~messageを受信した$wsときは、
所与の
( %種別,  %~data )
に対し，
次の手続きを走らす`~taskを~queueする$モノトスル：
◎
When a WebSocket message has been received with type type and data data, the user agent must queue a task to follow these steps: [WSP]
</p>

<p class="trans-note">【
%~data は、
当の~message内に受信した`~payload~data$wsを表す。
%種別 ~IN { `Text^i, `Binary^i } は、
~messageの<a href="~RFC6455#section-5.6">~frame種別</a>から指示される %~data の種別を表す。
】</p>
<ol>
	<li>
%O ~LET 当の `WebSocket$I ~obj
◎
↓</li>
	<li>
~IF［
%O の`準備y状態$wS ~NEQ `OPEN$m
］
⇒
~RET
◎
If ready state ]is not OPEN (1), then return.
</li>
	<li>
<p>
%~event用の~data ~LET %種別 に応じて
⇒＃
`Text^i ならば %~data を内容とする，新たな `DOMString^I ／
`Binary^i ならば %O の`~binary種別$wSに応じて：
</p>
		<ul class="switch">
			<li>
`blob@l
⇒
%O に`関連な~Realm$内の新たな `Blob$I ~obj `FILEAPI$r
— その`~byte列~data$として %~data を伴う
</li>
			<li>
`arraybuffer@l
⇒
%O に`関連な~Realm$内の新たな `ArrayBuffer$I ~obj
— その~buffer内容として %~data を伴う
</li>
		</ul>
◎
Let dataForEvent be determined by switching on type and binary type:
◎
type indicates that the data is Text
• a new DOMString containing data
◎
type indicates that the data is Binary and binary type is "blob"
• a new Blob object, created in the relevant Realm of the WebSocket object, that represents data as its raw data [FILEAPI]
◎
type indicates that the data is Binary and binary type is "arraybuffer"
• a new ArrayBuffer object, created in the relevant Realm of the WebSocket object, whose contents are data
</li>
	<li>
`~eventを発火する$( %O,
`message@et,
`MessageEvent$I )
— 次のように初期化して
⇒＃
`origin$m 属性 ~SET `生成元を直列化する$【！`~URLを直列化する$】( %O の`~URL$wSの`生成元$url ),
`data$m 属性 ~SET %~event用の~data
◎
Fire an event named message at the WebSocket object, using MessageEvent, with the origin attribute initialized to the serialization of the WebSocket object’s url's origin, and the data attribute initialized to dataForEvent.
</li>
</ol>

<p class="note">注記：
~UAには、［
上で~queueした`~task$ %~task を効率的に遂行できるかどうか
］を［
%~task を走らす前に検査しておく
］ことが推奨される
— 効率的に遂行できないときは、
~bufferを準備する間は，他の`~task~queue$から`~task$を選取る等。
例えば，［
~dataの到着-時には、
`~binary種別$wSは `blob$l にされていて，
~UAは すべての~dataを~diskへ~spool済みであった
］が［
当の~message用に %~task を走らす直前に，
~scriptが`~binary種別$wSを `arraybuffer$l に切替えた
］場合、
~UAは
— `ArrayBuffer$I ~objを作成している間に~main~threadが停滞しないよう —
%~task を走らす前に~dataを~RAMに戻したいと求めるであろう。
◎
User agents are encouraged to check if they can perform the above steps efficiently before they run the task, picking tasks from other task queues while they prepare the buffers if not. For example, if the binary type is "blob" when the data arrived, and the user agent spooled all the data to disk, but just before running the above task for this particular message the script switched binary type to "arraybuffer", the user agent would want to page the data back to RAM before running this task so as to avoid stalling the main thread while it created the ArrayBuffer object.
</p>
</div>

<div class="example" id="message-example">
<p>
~text~frameの場合に `message$et ~event用に~handlerを定義する例：
◎
Here is an example of how to define a handler for the message event in the case of text frames:
</p>

<pre class="lang-js">
%mysocket.onmessage = function (%event) {
  if (%event.data == 'on') {
    turnLampOn();
  } else if (%event.data == 'off') {
    turnLampOff();
  }
};
</pre>

<p>
ここでの~protocolは、［
~serverが "on" または "off" ~messageを送信するだけの，単純なもの
］とする。
◎
The protocol here is a trivial one, with the server just sending "on" or "off" messages.
</p>
</div>

<hr>

<div class="algo">
<p>
~UAは、
`~WebSocket~closing~handshakeを開始した$wsときは，
次を走らす`~taskを~queueする$モノトスル：
◎
When the WebSocket closing handshake is started, the user agent must＼
</p>
<ol>
	<li>
当の `WebSocket$I ~objの`準備y状態$wS ~SET `CLOSING$m
◎
queue a task to change the ready state to CLOSING (2).＼
</li>
</ol>

<p>
（ `close()$m ~methodが~callされていた場合、
`準備y状態$wSは，この~taskを走らす時点で，
すでに `CLOSING$m に設定されていることになる。）
◎
(If the close() method was called, the ready state will already be set to CLOSING (2) when this task runs.) [WSP]
</p>
</div>

<hr>

<div class="algo">
<p id="closeWebSocket">
~UAは、
~WebSocket接続が`~closeされ$wsたときは
（`~cleanに~closeされた$ws場合も含む），
次の手続きを走らす`~taskを~queueする$モノトスル：
◎
When the WebSocket connection is closed, possibly cleanly, the user agent must queue a task to run the following substeps:
</p>
<ol>
	<li>
%O ~LET 当の `WebSocket$I ~obj
◎
↓</li>
	<li>
%O の`準備y状態$wS ~SET `CLOSED$m
◎
Change the ready state to CLOSED (3).
</li>
	<li>
~IF［
~UAは`~WebSocket接続を失敗させる$ws必要がある
］~OR［
~WebSocket接続は その
`満杯か@
（初期~時は ~F ）が ~T にされた上で`~closeされ$wsた
］
⇒
`~eventを発火する$( %O,
`error@et
)
◎
If the user agent was required to fail the WebSocket connection, or if the WebSocket connection was closed after being flagged as full, fire an event named error at the WebSocket object. [WSP]
</li>
	<li>
`~eventを発火する$( %O,
`close@et,
`CloseEvent$I )
— 次のように初期化して
⇒＃
`wasClean$m 属性 ~SET ［ 接続は`~cleanに~closeされた$wsならば ~T ／ ~ELSE_ ~F ］,
`code$m 属性 ~SET `~WebSocket接続~close~code$ws,
`reason$m 属性 ~SET `~BOMはそのままに~UTF-8復号する$( `~WebSocket接続~close事由$ws )
◎
Fire an event named close at the WebSocket object, using CloseEvent, with the wasClean attribute initialized to true if the connection closed cleanly and false otherwise, the code attribute initialized to the WebSocket connection close code, and the reason attribute initialized to the result of applying UTF-8 decode without BOM to the WebSocket connection close reason. [WSP]
</li>
</ol>
</div>

<div class="warning">
<p>警告：
~UAは、
次に挙げる状況を判別し得るような失敗~情報は，~scriptに伝達しないモノトスル：
◎
User agents must not convey any failure information to scripts in a way that would allow a script to distinguish the following situations:
</p>
<ul>
	<li>
~serverの~host名を解決できなかった。
◎
A server whose host name could not be resolved.
</li>
	<li>
~serverへ~packetを成功裡に~routeできなかった。
◎
A server to which packets could not successfully be routed.
</li>
	<li>
指定された~portへの接続を~serverが拒否した。
◎
A server that refused the connection on the specified port.
</li>
	<li>
~serverとの TLS ~handshakeを正しく遂行できなかった
（例：~serverの証明書を検証yできなかった）。
◎
A server that failed to correctly perform a TLS handshake (e.g., the server certificate can’t be verified).
</li>
	<li>
~serverが~opening~handshakeを完了しなかった
（例：~serverが~WebSocket~serverではなかった）。
◎
A server that did not complete the opening handshake (e.g. because it was not a WebSocket server).
</li>
	<li>
~WebSocket~serverは正しい~opening~handshakeを送信したが、
それが指定する~optionにより，~clientは接続を落とした
（例：~serverは~clientが提供しなかった`下位protocol$wsを指定してきた）。
◎
A WebSocket server that sent a correct opening handshake, but that specified options that caused the client to drop the connection (e.g. the server specified a subprotocol that the client did not offer).
</li>
	<li>
~WebSocket~serverは~opening~handshakeを成功裡に完了した後に突如，接続を~closeした。
◎
A WebSocket server that abruptly closed the connection after successfully completing the opening handshake.
</li>
</ul>

<p>
これらのどの事例でも、
`~WebSocket接続~close~code$wsは 1006 になる
— `WSP$r により要求されるとおり。
◎
In all of these cases, the WebSocket connection close code would be 1006, as required by WebSocket Protocol. [WSP]
</p>

<p>
~scriptがこれら各~事例を判別できるようになると、［
攻撃の準備として，利用者の~local~networkを探査する
］ことを~scriptに許容することになる。
◎
Allowing a script to distinguish these cases would allow a script to probe the user’s local network in preparation for an attack.
</p>

<p class="note">注記：
特に，このことは、
~code 1015 は，~UAからは利用されないことを意味する
（もちろん、
~serverが `Close ~frame$wsに誤って利用した場合は除く）。
◎
In particular, this means the code 1015 is not used by the user agent (unless the server erroneously uses it in its close frame, of course).
</p>
</div>

<hr>

<p>
この節にて`~queueされ$る どの`~task$も，その`~task源$は
`~WebSocket~task源@
とする。
◎
The task source for all tasks queued in this section is the WebSocket task source.
</p>

	</section>
	<section id="ping-and-pong-frames">
<h2 title="Ping and Pong frames">5. Ping ~frameと Pong ~frame</h2>

<p>
`WSP$r は、［
接続維持, 鼓動, ~network状態探針, 待時間の計測, 等々
］に利用できる［
`Ping ~frame$ws,
`Pong ~frame$ws
］を定義する。
これらは、
現時点では~APIに公開されていない。
◎
The WebSocket protocol defines Ping and Pong frames that can be used for keep-alive, heart-beats, network status probing, latency instrumentation, and so forth. These are not currently exposed in the API.
</p>

<p>
~UAは、
欲されるなら［
`Ping ~frame$ws ／ 請求されていない `Pong ~frame$ws
］を送信してもヨイ
— 例えば［
~local~network~NATmappingを保守する／
接続を検出する／
利用者に待時間を表示する
］などの試みの一環として。
~UAは、
これらの~frameを~serverの援助-用として利用しないモノトスル
— ~serverは、
必要に応じて適切な時機に~pongを請求するものと見做されているので。
◎
User agents may send ping and unsolicited pong frames as desired, for example in an attempt to maintain local network NAT mappings, to detect failed connections, or to display latency metrics to the user. User agents must not use pings or unsolicited pongs to aid the server; it is assumed that servers will solicit pongs whenever appropriate for the server’s needs.
</p>

	</section>
	<section id="the-closeevent-interface">
<h2 title="The CloseEvent interface">6. `CloseEvent^I ~interface</h2>

<p>
`WebSocket$I ~objは、
その `close$et ~event用に `CloseEvent$I ~interfaceを利用する：
◎
WebSocket objects use the CloseEvent interface for their close events:
</p>

<pre class="idl">
[`Exposed$=(Window,Worker)]
interface `CloseEvent@I : `Event$I {
  <span id="dom-closeevent-closeevent">`constructor$</span>(`DOMString$ %type, optional `CloseEventInit$I %eventInitDict = {});

  readonly attribute `boolean$ `wasClean$m;
  readonly attribute `unsigned short$ `code$m;
  readonly attribute `USVString$ `reason$m;
};

dictionary `CloseEventInit@I : `EventInit$I {
  `boolean$ `wasClean@mb = false;
  `unsigned short$ `code@mb = 0;
  `USVString$ `reason@mb = "";
};
</pre>

<dl class="domintro">
	<dt>%event.`wasClean$m</dt>
	<dd>
［
接続は`~cleanに~closeされた$wsなら ~T ／
~ELSE_ ~F
］を返す。
◎
Returns true if the connection closed cleanly; false otherwise.
</dd>

	<dt>%event.`code$m</dt>
	<dd>
~serverから供された`~WebSocket接続~close~code$wsを返す。
◎
Returns the WebSocket connection close code provided by the server.
</dd>

	<dt>%event.`reason$m</dt>
	<dd>
~serverから供された`~WebSocket接続~close事由$wsを返す。
◎
Returns the WebSocket connection close reason provided by the server.
</dd>
</dl>

<div class="algo">
`wasClean@m
取得子~手続きは、
初期化-時の値を返す。
それは、［
接続が`~cleanに~closeされた$wsかどうか
］を表現する。
◎
The wasClean attribute must return the value it was initialized to.＼
It represents whether the connection closed cleanly or not.
</div>

<div class="algo">
`code@m
取得子~手続きは、
初期化-時の値を返す。
それは、［
~serverから供された`~WebSocket接続~close~code$ws
］を表現する。
◎
The code attribute must return the value it was initialized to.＼
It represents the WebSocket connection close code provided by the server.
</div>

<div class="algo">
`reason@m
取得子~手続きは、
初期化-時の値を返す。
それは、［
~serverから供された`~WebSocket接続~close事由$ws
］を表現する。
◎
The reason attribute must return the value it was initialized to.＼
It represents the WebSocket connection close reason provided by the server.
</div>

	</section>
	<section id="garbage-collection">
<h2 title="Garbage collection">7. ~garbage収集</h2>

<p>
次のいずれかに該当する `WebSocket$I ~objは、
~garbage収集しないモノトスル：
◎
↓</p>
<ul>
	<li>
<p>
`~event~loop$がその`最初の段$に最後に達した時点で、
`準備y状態$wSが［
次の表の 1 列目に挙げる値
］にされていて，［
同じ行の 2 列目に示される~event型に対し登録されている~event~listenerが在る
］もの。
</p>

<table>
<thead><tr><th>`準備y状態$wS
<th>`~event~handler~event型$
</thead>

<tbody><tr><td>`CONNECTING$m (0)
<td>`open$et, `message$et, `error$et, `close$et

<tr><td>`OPEN$m (1)
<td>`message$et, `error$et, `close$et

<tr><td>`CLOSING$m (2)
<td>`error$et, `close$et

</tbody></table>

◎
A WebSocket object whose ready state was set to CONNECTING (0) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for open events, message events, error events, or close events.
◎
A WebSocket object whose ready state was set to OPEN (1) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for message events, error, or close events.
◎
A WebSocket object whose ready state was set to CLOSING (2) as of the last time the event loop reached step 1 must not be garbage collected if there are any event listeners registered for error or close events.
</li>
	<li>
`~WebSocket接続は確立-済み$wsであり，~network伝送-用に~dataが~queueされているもの。
◎
A WebSocket object with an established connection that has data queued to be transmitted to the network must not be garbage collected. [WSP]
</li>
</ul>

<p>
接続が~openしているにもかかわらず， `WebSocket$I ~objが~garbage収集された場合、
~UAは，`~WebSocket~closing~handshakeを開始する$wsモノトスル。
このときの `Close ~message$wsは、
`状態s~code$wsを伴わないものとする。
◎
If a WebSocket object is garbage collected while its connection is still open, the user agent must start the WebSocket closing handshake, with no status code for the Close message. [WSP]
</p>

<hr>

<div class="algo">
<p>
~UAは， `WebSocket$I ~objを
`消滅させる@
必要が生じたときは
（これは、 `Document$I ~objが消え去るとき起こる）、
次を走らすモノトスル：
◎
If a user agent is to make disappear a WebSocket object (this happens when a Document object goes away), the user agent must follow the first appropriate set of steps from the following list:
</p>

<ol>
	<li>
~IF［
`~WebSocket接続は確立-済み$wsでない
］
⇒
`~WebSocket接続を失敗させる$ws
◎
If the WebSocket connection is not yet established [WSP]
• Fail the WebSocket connection. [WSP]
</li>
	<li>
~ELIF［
`~WebSocket~closing~handshakeは開始-済み$wsでない
］
⇒
`~WebSocket~closing~handshakeを開始する$ws
— `Close ~message$wsに利用する`状態s~code$wsは 1001 とする
◎
If the WebSocket closing handshake has not yet been started [WSP]
• Start the WebSocket closing handshake, with the status code to use in the WebSocket Close message being 1001. [WSP]
◎
Otherwise
• Do nothing.
</li>
</ol>
</div>

	</section>
	<section id="acks">
<h2 title="Acknowledgments">謝辞</h2>

<p>
2021年におけるこの標準の作成まで、
ここにある~textは，［
<a href="https://html.spec.whatwg.org/multipage/">~HTML標準</a>,
<a href="https://fetch.spec.whatwg.org/">~Fetch標準</a>
］にて保守されていた。
これら各~仕様の~repositoryに貢献して この仕様の開発に助力された，すべての方々に
— とりわけ、これら各~仕様の元の作者である
`Ian Hickson^en, `Anne van Kesteren^en
各氏（同順）に。
◎
Until the creation of this standard in 2021, the text here was maintained in the HTML Standard and Fetch Standard. Thanks to all of the contributors to those repositories who helped develop the specification, especially Ian Hickson and Anne van Kesteren as the respective original authors.
</p>

<p>
この標準が作成された後の
平野裕（ `Yutaka Hirano^en ）氏による貢献に。
◎
Thanks to 平野裕 (Yutaka Hirano) for their contributions after the creation of the WebSockets Standard.
</p>

<p>
この標準は、
`Adam Rice^en 
（ <a href="https://google.com">Google</a>,
<a href="mailto:ricea@chromium.org">ricea@chromium.org</a> ）
により書かれた。
◎
This standard is written by Adam Rice (Google, ricea@chromium.org).
</p>

`_acks1@

	</section>
	<section id="ipr">
<h2 title="Intellectual property rights">知的財産権</h2>

`_ipr1@

	</section>
</main></div>

<div hidden>
<div lang="en" id="_acks1">
</div>

<div lang="en" id="_ipr1">
<p>Copyright © WHATWG (Apple, Google, Mozilla, Microsoft). This work is licensed under a <a href="https://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0
International License</a>. To the extent portions of it are incorporated into source code, such
portions in the source code are licensed under the <a href="https://opensource.org/licenses/BSD-3-Clause" rel="license">BSD 3-Clause License</a> instead.</p>

<p>This is the Living Standard. Those interested in the patent-review version should view the <a href="/review-drafts/2022-03/">Living Standard Review Draft</a>.</p>

</div>

</div>
