<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Worklets （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'worklets',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん？]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sl':
	text = `[[${text}]]`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2021-07-27
trans_update:2021-06-25
source_checked:201016
page_state_key:HTML
original_url:https://html.spec.whatwg.org/multipage/worklets.html
	abbr_url:WORKLETS
spec_status:LS
nav_prev:WORKERS
nav_next:WEBSTORAGE
trans_1st_pub:2018-02-27


●●class_map
E:error
jA:abstract
sl:js-slot

●●tag_map
I:code
m:code
c:code
E:code
jA:span
sl:span
i:i
cite:cite

●●original_id_map


●●mdn_urls
worklet:API/Worklet
	workletglobalscope:API/WorkletGlobalScope

●●link_map


	●IDL
Exposed:~WEBIDLjs#Exposed

E.AbortError:~WEBIDL#aborterror
E.SyntaxError:~WEBIDL#syntaxerror

	I.DOMException:~WEBIDL#dfn-DOMException
I.Function:~WEBIDL#common-Function
I.Worklet:#worklet
I.WorkletGlobalScope:#workletglobalscope
I.WorkletOptions:#workletoptions
I.RequestCredentials:~FETCH#requestcredentials
I.Window:~WINDOW#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope

	●IDL members

m.addModule:#dom-worklet-addmodule
m.credentials:#dom-workletoptions-credentials
m.self:~WORKERS#dom-workerglobalscope-self


I.FakeWorkletGlobalScope:#fakeworkletglobalscope
m.registerFake:#dom-fakeworkletglobalscope-registerfake
m.fakeWorklet1:#fakeworklet1
m.fakeWorklet2:#fakeworklet2
fake-worklet-1:#fake-worklet-1
fake-worklet-2:#fake-worklet-2

	●用語

doc.~worklet大域~scope~list:#concept-document-worklet-global-scopes

wL.大域~scope~list:#concept-worklet-global-scopes
wL.追加した~module~list:#concept-worklet-added-modules-list
wL.~module応答~map:#concept-worklet-module-responses-map
wL.~module~map:#concept-workletglobalscope-module-map
wL.~worklet行先~種別:#worklet-destination-type
wL.~worklet大域~scope型:#worklet-global-scope-type

登録-済み~class構築子~map:#registered-class-constructors-map
~workletの環境~設定群~objを設定しておく:#set-up-a-worklet-environment-settings-object
~worklet大域~scopeを作成する:#create-a-worklet-global-scope
wL.作成-:#create-a-worklet-global-scope
~worklet大域~scopeを終了させる:#terminate-a-worklet-global-scope
wL.終了-:#terminate-a-worklet-global-scope
doc.破棄-:~WINDOW#discard-a-document

	§:#worklets-example-registering
	§:#worklets-idempotent
	§:#worklets-speculative
	#fakeworkletglobalscope-process
	https://github.com/whatwg/html/issues/6059




	●用語（HTML

~task:~WAPI#concept-task
小task:~WAPI#microtask
現在~走っている~task:~WAPI#currently-running-task
~task~queue:~WAPI#task-queue
大域~taskを~queueする:~WAPI#queue-a-global-task
~network用~task源:~WAPI#networking-task-source
~event~loop:~WAPI#event-loop
aG.~event~loop:~WAPI#concept-agent-event-loop
~event~loop処理~model:~WAPI#event-loop-processing-model
小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
~worklet~agent:~WAPI#worklet-agent
生成元が類似な~window~agent:~WAPI#similar-origin-window-agent
専用~worker~agent:~WAPI#dedicated-worker-agent
~worklet~agentを得する:~WAPI#obtain-a-worklet-agent
関連な~agent:~WAPI#relevant-agent
~module~script:~WAPI#module-script
~module~map:~WAPI#module-map
~module~scriptを走らす:~WAPI#run-a-module-script
~worklet~script~graphを~fetchする:~WAPI#fetch-a-worklet-script-graph
走っている~scriptを中止する:~WAPI#abort-a-running-script
新たな~JS~realmを作成する:~WAPI#creating-a-new-javascript-realm
sC.再投出-用~error:~WAPI#concept-script-error-to-rethrow
大域~obj:~WAPI#global-object
rM.大域~obj:~WAPI#concept-realm-global
関連な設定群~obj:~WAPI#relevant-settings-object
環境~設定群~obj:~WAPI#environment-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
enV.大域~obj:~WAPI#concept-settings-object-global
enV.担当の~event~loop:~WAPI#responsible-event-loop
enV.~API用~基底~URL:~WAPI#api-base-url
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.担当の文書:~WAPI#responsible-document
~window~event~loop:~WAPI#window-event-loop
enV.~API用~URL文字~符号化法:~WAPI#api-url-character-encoding
enV.生成元:~WAPI#concept-settings-object-origin
enV.非同一-生成元~能力は隔離-済みか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
enV.~ID:~WAPI#concept-environment-id
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context
enV.作動中の~sw:~WAPI#concept-environment-active-service-worker

非同期に完了する:~HTMLINFRA#_asynchronously-complete
並列的:~HTMLINFRA#in-parallel
相対的に~URL構文解析する:~HTMLurl#parse-a-url
文書:~HTMLdom#the-document-object
	I.Document:~HTMLdom#document
結付けられている文書:~WINDOW#concept-document-window
不透明な生成元:~ORIGIN#concept-origin-opaque
施策~容器を~cloneする:~ORIGIN#clone-a-policy-container

	●用語（他
実装定義:~INFRA#implementation-defined
有順序~map:~INFRA#ordered-map
有順序~集合:~INFRA#ordered-set
	~EACH:~INFRA#list-iterate
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
~list:~INFRA#list
空:~INFRA#list-is-empty
~size:~INFRA#list-size

~IDL値に変換する:~WEBIDLjs#dfn-convert-ecmascript-to-idl-value
	~IDL型に変換する:~WEBIDLjs#es-type-mapping → ~IDL値に変換する
~callback関数で構築する:~WEBIDLjs#construct-a-callback-function
	~callback this 値:~WEBIDLjs#dfn-callback-this-value
~callback関数を呼出す:~WEBIDLjs#invoke-a-callback-function
継承-:~WEBIDL#dfn-inherit
呼出す:~WEBIDLjs#invoke-a-callback-function
新たな~promise:~WEBIDLjs#a-new-promise
却下する:~WEBIDLjs#reject
解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with

rq.行先:~FETCH#concept-request-destination
rq.資格証~mode:~FETCH#concept-request-credentials-mode
応答:~FETCH#concept-response

~UTF-8:~ENCODING#utf-8
~URL~record:~URL1#concept-url

jA.Get:~TC39#sec-get-o-p
~JS実行~文脈:~TC39#sec-execution-contexts

●●words_table1


●●words_table

	●環境
worklet:
agent:
	生成元が類似な:similar-origin
surface:

	●IDL／型／構造
拡張属性:exetended attribute:~
依存物:dependencies:~
重複-:duplicate:~
一対一:one-to-one:~
	属する:belong

	●処理
pipeline::::パイプライン
stage:
phase:
stateless::::ステートレス
stateful::::ステートフル
checkpoint:
kill:
main:
random::::ランダム
小task:microtask::小 task:小タスク
join:
deadlock::::デッドロック
処理待ち:pending:~
冪等:idempotent::~
冪等性:idempotence::~
並列化-:parallelize::~
並列性:parallelism::~
存続期間:lifetime::~
同時並行性:concurrency::~
投機的:speculative::~
投機-:speculate::~
overhead::::オーバーヘッド
作成時の:creation::~
再投出-:rethrow::~
アタる:consultする::あたる
入口:entry:~

	入口~地点
	ある時点に:at some point
	途中:in the middle of
	~thread安全:thread-safe
	~overheadが高い:high-overhead
	の以降は、:the rest of
	いつでも:at any time
	開始し直す:restart
	期間:period of time
	« »:with no arguments
	かかる時間:timing
	~scriptの読込ng:script-loading
	~~反転する:negation
	~~反転:opposite
	（例外が投出され得る）:Rethrow any exceptions.
	~garbage収集され:garbage-collected
	短く走る:short-running
	長く走る:long-running

	●仕様
opt-out:
導入:introduction:~
意向:intention:~
策:strategy:~
異常:abnormal:~
計画-:plan:~
促す:encourageする:~
書く:writeする:~
書かれ:writeされ:~
放棄-:abandon:~
控えめ:sparing:~
本物の:realな:~
束ねら:tieさ:~
透過的:transparent:~
仕様化-:specify:~
地点:points:~
fake:
理論:theory:~
	理論~上は:in~theory
自由:freedom:~
問題m:matter:問題
保つ:keepする:~
一助:help:~

	なるようにする:makeする
	対照的に，:Contrast this with
	作者が供した:author-provided
	それまで保持していた:previously-held
	当の:in question
	きちんと:well-
	他に比して:relatively
	相当するもの:counterpart
	とする:Let's say that
	~~高度に:highly-
	対照的に，:Contrast this with
	課され:imposed
	場を占める:taking place
	最低限:at a minimum
	~~部品:piece
	主:main
	観測される結果が等価になること:observably-equivalent results
	~web開発者が供した:web-developer-provided
	必要に応じて:as required
	依存する:dependent
	~~説明:illustrate
	〜を問わない:〜-agnostic
	選ばれ:chosen
	選ばれ:chooseされ:~
	選ぶ:chooseする:~
	指定-:says
	最後に，:Finally,

	●未分類
超過-:exceed:~

	出力-:print
	高い:high
	高める:increase
	~worklet型に特有な:worklet-type-specific
	~scriptを~fetchする:script-fetching

	●指示語

	以下の少数の:next couple of
	〜以上の:at least
	成す組み:together
	各部:parts
	~~部位:in 〜 parts
	点:point
	その中で:wherein
	〜のそれら:the ones

	●変数
	%外側~設定群:outsideSettings
	%~agent:agent
	%~realm実行~文脈:realmExecutionContext
	%内側~設定群~insideSettings
	%~module~URL:moduleURL
	%~event~loop:eventLoop
	%継承される~API用~基底~URL:inheritedAPIBaseURL
	%継承される施策~容器:inheritedPolicyContainer
	%設定群~obj:settingsObject
	%~module~URL~record:moduleURLRecord
	%~worklet大域~scope:workletGlobalScope
	%~class構築子:classConstructor
	%~class~instance:classInstance
	%実行~文脈:executionContext
	%処理待ち~task数:pendingTasks
	%成功裡に追加された:addedSuccessfully


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Worklets</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>Worklets</h1>

	</hgroup>

</header>

<main id="MAIN" hidden>

	<section id="worklets">
<h2 title="Worklets">11. ~worklet</h2>

		<section id="worklets-intro">
<h3 title="Introduction">11.1. 序論</h3>

~INFORMATIVE

<p>
~workletは、特定0の実装~modelを要求することなく，~main~JS実行~環境とは独立に~scriptを走らすために利用できるような，仕様の基盤を成す~~部品である。
◎
Worklets are a piece of specification infrastructure which can be used for running scripts independent of the main JavaScript execution environment, while not requiring any particular implementation model.
</p>

<p>
ここに指定される~worklet基盤は、~web開発者が直に利用できるものではない。
代わりに，この基盤の上に築かれる他の仕様が、直に利用-可能な
— ~browserの実装~pipelineを成す特定0の~~部位で走らすよう特化された —
~worklet型を作成する。
◎
The worklet infrastructure specified here cannot be used directly by web developers. Instead, other specifications build upon it to create directly-usable worklet types, specialized for running in particular parts of the browser implementation pipeline.
</p>

			<section id="worklets-motivations">
<h4 title="Motivations">11.1.1. 動機</h4>

~INFORMATIVE

<p>
描画, あるいは［
音声~出力など，実装~pipelineを成す他の敏感な各部
］に対し，拡張~地点を許容することは、困難である。
拡張~地点で行われる何かに， `Window$I に可用な~APIへの全部的な~accessを与えた場合、~engineは，［
それらの~phaseの途中で何が起こり得るかについて，それまで保持していた前提
］を放棄する必要があろう。
例えば，描画~engineは、~layout~phaseの間は，~DOMは改変されないものと見做す。
◎
Allowing extension points to rendering, or other sensitive parts of the implementation pipeline such as audio output, is difficult. If extension points were done with full access to the APIs available on Window, engines would need to abandon previously-held assumptions for what could happen in the middle of those phases. For example, during the layout phase, rendering engines assume that no DOM will be modified.
</p>

<p>
加えて，
`Window$I 環境~内に拡張~地点を定義するのは、
`Window$I ~objと同じ~thread内で作業を遂行するよう，~UAを制約することになる（実装が，［
~thread~join時の保証（ `thread joining guarantee^en ）†
に加えて，~thread安全（ `thread-safe^en ）な~API††
を許容するような，複階的かつ~overheadが高い基盤
］を追加しない限り）。
◎
Additionally, defining extension points in the Window environment would restrict user agents to performing work in the same thread as the Window object. (Unless implementations added complex, high-overhead infrastructure to allow thread-safe APIs, as well as thread-joining guarantees.)
</p>

<p class="trans-note">【†
ある~threadを別の~threadが終了するまで待機するよう “~joinして” も，~deadlockは生じない保証と思われる。
】【††
当の~APIに複数の~threadから~accessされても，その結果は予測-可能になることと思われる。
】</p>

<p>
~workletは、~UAが現在~依拠している保証を保つ一方で，拡張~地点も許容するように設計されている。
これは、 `WorkletGlobalScope$I の各~下位classに基づく，新たな大域~環境を通して行われる。
◎
Worklets are designed to allow extension points, while keeping guarantees that user agents currently rely on. This is done through new global environments, based on subclasses of WorkletGlobalScope.
</p>

<p>
~workletは~web~workerに類似する。
しかしながら，それらは：
◎
Worklets are similar to web workers. However, they:
</p>
<ul>
	<li>
~threadを問わない。
すなわち、［
個々の~workerの様に，専用な別々の~thread内で走らす
］ように設計されてはいない。
実装は、~workletを自身が選ぶどこで走らすこともできる（~main~threadも含め）。
◎
Are thread-agnostic. That is, they are not designed to run on a dedicated separate thread, like each worker is. Implementations can run worklets wherever they choose (including on the main thread).
</li>
	<li>
並列性の目的で、大域~scopeの複数個の~instanceを重複-可能である。
◎
Are able to have multiple duplicate instances of the global scope created, for the purpose of parallelism.
</li>
	<li>
~eventに基づく~APIは利用しない。
その代わりとして、各~classは，大域~scopeに登録され、その各~methodは，~UAにより呼出される。
◎
Do not use an event-based API. Instead, classes are registered on the global scope, whose methods are invoked by the user agent.
</li>
	<li>
<p>
大域~scope上の~API~surfaceは、抑制される。
</p>
<p class="trans-note">【
`WebIDL$r の用語で述べるなら、
`Exposed$ 拡張属性を通して `WorkletGlobalScope$I に公開される~interfaceは，他の大域~obj（ `WorkerGlobalScope$I や `Window$I ）に比して限られている。
】</p>
◎
Have a reduced API surface on the global scope.
</li>
	<li>
それらの`大域~obj$には存続期間がある。
それは、他の仕様により定義され，`実装定義$な方式になることが多い。
◎
Have a lifetime for their global object which is defined by other specifications, often in an implementation-defined manner.
</li>
</ul>

<p>
~workletは、~overheadが他に比して高いので，控えめに利用されるのが最善である。
これに因り、所与の `WorkletGlobalScope$I は，複数の別々な~scriptから共有されるものと期待される（これは、単独の `Window$I が，複数の別々な~scriptから どう共有されるかに類似する）。
◎
As worklets have relatively high overhead, they are best used sparingly. Due to this, a given WorkletGlobalScope is expected to be shared between multiple separate scripts. (This is similar to how a single Window is shared between multiple separate scripts.)
</p>

<p>
~workletは、様々な利用-事例を~serveするような，一般的な技術である。
一部の~worklet
— `CSS Painting API^cite `CSSPAINT$r に定義されるものなど —
が供する拡張~地点は、［
~statelessかつ冪等かつ短く走る
］算出~用に意図される
— それらには、以下の少数の節に述べるような特別な考慮点がある。
他の~worklet
— `Web Audio API^cite `WEBAUDIO$r に定義されるものなど —
は、［
~statefulかつ長く走る
］演算~用に利用される。
◎
Worklets are a general technology that serve different use cases. Some worklets, such as those defined in CSS Painting API, provide extension points intended for stateless, idempotent, and short-running computations, which have special considerations as described in the next couple of sections. Others, such as those defined in Web Audio API, are used for stateful, long-running operations. [CSSPAINT] [WEBAUDIO]
</p>

			</section>
			<section id="worklets-idempotent">
<h4 title="Code idempotence">11.1.2. ~codeの冪等性</h4>

<p>
~workletを利用する一部の仕様は、各 作業を［
複数の~threadに並列化する／必要に応じて他の~threadへ移動する
］ことを~UAに許容するものと意図される。
そのような仕様においては、~UAは，~web開発者が供した~class上の~methodを`実装定義$な順序で呼出すかもしれない。
◎
Some specifications which use worklets are intended to allow user agents to parallelize work over multiple threads, or to move work between threads as required. In these specifications, user agents might invoke methods on a web-developer-provided class in an implementation-defined order.
</p>

<p>
その結果による相互運用能の課題を防止するため、そのような `WorkletGlobalScope$I に~classを登録する作者は，自身の~codeが冪等になるようにするベキである。
すなわち，当の~classの［
1 個以上の~methodが成す組
］は、所与の特定0の入力に対し同じ出力を生産するベキである。
◎
As a result of this, to prevent interoperability issues, authors who register classes on such WorkletGlobalScopes should make their code idempotent. That is, a method or set of methods on the class should produce the same output given a particular input.
</p>

<p>
この仕様は、~codeを冪等な仕方で書くよう作者に促すため，次に挙げる技法を利用する：
◎
This specification uses the following techniques in order to encourage authors to write code in an idempotent way:
</p>

<ul>
	<li>
<p>
当の大域~objへの参照は、可用でない（すなわち，
`WorkletGlobalScope$I には `self$m に相当するものは無い）。
◎
No reference to the global object is available (i.e., there is no counterpart to self on WorkletGlobalScope.
</p>

<p class="XXX">
これは，~workletが最初に仕様化されたときの意向であったが、
`globalThis^c の導入により，もはや成立しなくなった。
さらなる論点は、
<a href="~HTMLissue/6059">課題 #6059</a>
を見よ。
◎
Although this was the intention when worklets were first specified, the introduction of globalThis has made it no longer true. See issue #6059 for more discussion.
</p>
	</li>
	<li>
~codeは`~module~script$として読込まれる。
その結果，~codeは、厳密~mode【 `use strict^c 】の下で
— ［
共有される，大域的な~proxyを参照している `this^c
］を伴うことなく —
実行される。
◎
Code is loaded as a module script, which results in the code being executed in strict mode and with no shared this referencing the global proxy.
</li>
</ul>

<p>
これらの制約が成す組みは、複数の異なる【大域~環境で走っている】~scriptが`大域~obj$の~propを利用して状態を共有するのを防止する一助になる。
◎
Together, these restrictions help prevent two different scripts from sharing state using properties of the global object.
</p>

<p>
加えて，~workletを利用する仕様は、`実装定義$な挙動を許容するものと意図するならば，次を順守しなければナラナイ：
◎
Additionally, specifications which use worklets and intend to allow implementation-defined behavior must obey the following:
</p>
<ul>
	<li>
<p>
~UAに次を要求しなければナラナイ：
</p>
		<ul>
			<li>
常に、各 `Worklet$I 用に 2 個以上の `WorkletGlobalScope$I ~instanceがあること。
</li>
			<li>
~class上の［
1 個以上の~methodが成す組
］を特定0の `WorkletGlobalScope$I ~instanceに~randomにアテガうこと。
</li>
		</ul>
<p>
これらの仕様は、~memoryが拘束された下では，~UAが~opt-outを供しても
【これらの要件を~~任意で外せるようにしても】
ヨイ。
</p>
◎
They must require user agents to always have at least two WorkletGlobalScope instances per Worklet, and randomly assign a method or set of methods on a class to a particular WorkletGlobalScope instance. These specifications may provide an opt-out under memory constraints.
</li>
	<li>
これらの仕様は、~UAに次を許容しなければナラナイ
⇒
`WorkletGlobalScope$I 下位classの~instanceを，いつでも［
作成する／破壊する
］
◎
These specifications must allow user agents to create and destroy instances of their WorkletGlobalScope subclasses at any time.
</li>
</ul>

			</section>
			<section id="worklets-speculative">
<h4 title="Speculative evaluation">11.1.3. 投機的な評価</h4>

<p>
~workletを利用する一部の仕様は、~UAの状態に基づいて，~web開発者が供した~class上の~methodを呼出せる。
~UAは，複数の~thread間の同時並行性を高めるためとして、未来にあり得る状態に基づいて，~methodを投機的に呼出してもヨイ。
◎
Some specifications which use worklets can invoke methods on a web-developer-provided class based on the state of the user agent. To increase concurrency between threads, a user agent may invoke a method speculatively, based on potential future states.
</p>

<p>
これらの仕様においては、~UAは，~methodを［
いつでも，および
~UAの現在の状態に対応するものに限らず，他の引数で
］呼出すかもしれない。
そのような投機的な評価の結果は，即時には表示されないが、~UAの状態が投機した状態に合致する場合に利用できるよう，~cacheできる。
これは、~UAと~worklet~thread間の同時並行性を高め得る。
◎
In these specifications, user agents might invoke such methods at any time, and with any arguments, not just ones corresponding to the current state of the user agent. The results of such speculative evaluations are not displayed immediately, but can be cached for use if the user agent state matches the speculated state. This can increase the concurrency between the user agent and worklet threads.
</p>

<p>
この結果による，~UA間の相互運用能~riskを防止するため、そのような `WorkletGlobalScope$I に~classを登録する作者は，自身の~codeが~statelessになる
— すなわち，ある~methodを呼出すことによる効果は、それが返す結果に限られ，変異-可能な状態を更新するなどの副作用は無い —
ようにするベキである。
◎
As a result of this, to prevent interoperability risks between user agents, authors who register classes on such WorkletGlobalScopes should make their code stateless. That is, the only effect of invoking a method should be its result, and not any side effects such as updating mutable state.
</p>

<p>
<a href="#worklets-idempotent">~codeの冪等性</a>
を促す技法も、~statelessな~codeを書くことを，作者に促す。
◎
The same techniques which encourage code idempotence also encourage authors to write stateless code.
</p>

			</section>
		</section>
		<section class="example" id="worklets-examples">
<h3 title="Examples">11.2. 例</h3>

~INFORMATIVE

<p>
ここでは、以下に与える各~例~用に，ある~fake~workletを利用する。
`Window$I ~objは、
2 個の `Worklet$I ~instanceを供する
— それぞれ、自前の［
いくつかの `FakeWorkletGlobalScope$I からなる~collection
］内で~codeを走らすことになる：
◎
For these examples, we'll use a fake worklet. The Window object provides two Worklet instances, which each run code in their own collection of FakeWorkletGlobalScopes:
</p>

<pre class="idl">
partial interface `Window$I {
  [SameObject, SecureContext] readonly attribute `Worklet$I `fakeWorklet1$m;
  [SameObject, SecureContext] readonly attribute `Worklet$I `fakeWorklet2$m;
};
</pre>

<p>
各 `Window$I は，
2 個の `Worklet$I ~instance［
`fake-worklet-1@
`fake-worklet-2@
］を有していて、どちらも，
その`~worklet大域~scope型$wL は `FakeWorkletGlobalScope$I に設定され，
その`~worklet行先~種別$wL は `fakeworklet^l に設定されるとする。
~UAは、各~worklet用に `FakeWorkletGlobalScope$I ~instanceを 2 個以上~作成するベキである。
◎
Each Window has two Worklet instances, fake worklet 1 and fake worklet 2. Both of these have their worklet global scope type set to FakeWorkletGlobalScope, and their worklet destination type set to "fakeworklet". User agents should create at least two FakeWorkletGlobalScope instances per worklet.
</p>

<p class="note">注記：
`fakeworklet^l は，実際には `FETCH$r に従う妥当な`行先$rqではないが、これは，本物の~workletが［
一般に、~worklet型に特有な自前の行先を どう有することになるか
］を~~説明する。
◎
"fakeworklet" is not actually a valid destination per Fetch. But this illustrates how real worklets would generally have their own worklet-type-specific destination. [FETCH]
</p>

<div class="algo">
`fakeWorklet1@m
取得子~手続きは
⇒
~RET コレの`fake-worklet-1$
◎
The fakeWorklet1 getter steps are to return this's fake worklet 1.
</div>

<div class="algo">
`fakeWorklet2@m
取得子~手続きは
⇒
~RET コレの`fake-worklet-2$
◎
The fakeWorklet2 getter steps are to return this's fake worklet 2.
</div>

<hr>

<pre class="idl">
[Global=(Worklet,FakeWorklet),
 Exposed=FakeWorklet,
 SecureContext]
interface `FakeWorkletGlobalScope@I : `WorkletGlobalScope$I {
  undefined `registerFake$m(DOMString %type, `Function$I %classConstructor);
};
</pre>

<p>
各 `FakeWorkletGlobalScope$I は
`登録-済み~class構築子~map@
を有する
— それは，`有順序~map$であり、初期~時は空とする。
◎
Each FakeWorkletGlobalScope has a registered class constructors map, which is an ordered map, initially empty.
</p>

<div class="algo">
`registerFake(type, classConstructor)@m
~method手続きは
⇒
コレの`登録-済み~class構築子~map$[ %type ] ~SET %classConstructor
◎
The registerFake(type, classConstructor) method steps are to set this's registered class constructors map[type] to classConstructor.
</div>

			<section id="worklets-examples-loading">
<h4 title="Loading scripts">11.2.1. ~scriptの読込ng</h4>

~INFORMATIVE

<p>
~web開発者は、`fake-worklet-1$の中へ~scriptを読込むために，次を書くことになろう：
◎
To load scripts into fake worklet 1, a web developer would write:
</p>

<pre class="lang-js">
window.fakeWorklet1.addModule('script1.mjs');
window.fakeWorklet1.addModule('script2.mjs');
</pre>

<p>
どちらの~scriptが，最初に~fetchingを完遂して走ることになるかは、~networkにかかる時間に依存することに注意。
それは、
`script1.mjs^c, `script2.mjs^c
どちらにもなり得る。
これは，一般に、~worklet内に読込まれるものと意図された~scriptが［
<a href="#worklets-speculative">投機的な評価</a>用に準備することについての示唆に従う
］よう きちんと書かれていれば，問題mにはならない。
◎
Note that which script finishes fetching and runs first is dependent on network timing: it could be either script1.mjs or script2.mjs. This generally won't matter for well-written scripts intended to be loaded in worklets, if they follow the suggestions about preparing for speculative evaluation.
</p>

<p>
~web開発者は、ある~taskを［
当の~scriptどれもが、成功裡に走って，何らかの~workletの中に読込まれた
］後に限り遂行したいと求めるならば，次のように書くこともできる：
◎
If a web developer wants to perform a task only after the scripts have successfully run and loaded into some worklets, they could write:
</p>

<pre class="lang-js">
Promise.all([
    window.fakeWorklet1.addModule('script1.mjs'),
    window.fakeWorklet2.addModule('script2.mjs')
]).then(() =&gt; {
    /* <span class="comment">
~scriptが読込まれたことに依拠するような何かを行う。
◎
Do something which relies on those scripts being loaded.
</span> */
});
</pre>

<hr>

<p>
~scriptの読込ngについての別の重要な点は
— <a href="#worklets-idempotent">§ ~codeの冪等性</a>にて論じたように —
読込まれた~scriptを走らす `WorkletGlobalScope$I は，
`Worklet$I ごとに複数個あり得ることである。
特に，上の［
`fake-worklet-1$, `fake-worklet-2$
］用の仕様は、これを要求する。
次のような局面を考える：
◎
Another important point about script-loading is that loaded scripts can be run in multiple WorkletGlobalScopes per Worklet, as discussed in the section on code idempotence. In particular, the specification above for fake worklet 1 and fake worklet 2 require this. So, consider a scenario such as the following:
</p>

<pre class="lang-js">
// script.mjs
console.log("Hello from a FakeWorkletGlobalScope!");
</pre>

<pre class="lang-js">
// app.mjs
window.fakeWorklet1.addModule("script.mjs");
</pre>

<p>
その結果、~UAの~consoleには次も出力され得る：
◎
This could result in output such as the following from a user agent's console:
</p>

<pre class="presentation">
[fakeWorklet1#1] Hello from a FakeWorkletGlobalScope!
[fakeWorklet1#4] Hello from a FakeWorkletGlobalScope!
[fakeWorklet1#2] Hello from a FakeWorkletGlobalScope!
[fakeWorklet1#3] Hello from a FakeWorkletGlobalScope!
</pre>

<p>
~UAが，ある時点で `FakeWorkletGlobalScope$I の 3 個目の~instanceを~killして開始し直すものと裁定した場合、~consoleは，その開始-時に【！これが生じたとき】再び次を出力することになる
⇒
`[fakeWorklet1#3] Hello from a FakeWorkletGlobalScope!^c
◎
If the user agent at some point decided to kill and restart the third instance of FakeWorkletGlobalScope, the console would again print [fakeWorklet1#3] Hello from a FakeWorkletGlobalScope! when this occurs.
</p>

			</section>
			<section id="worklets-example-registering">
<h4 title="Registering a class and invoking its methods">11.2.2. ~classの登録-法と その~methodの呼出ng</h4>

~INFORMATIVE

<p>
~fake~workletに意図される［
~web開発者~向けの ある用法
］が、~~高度に複階的な処理nの一部
— この例では、真偽値を~~反転するだけであるが —
を~custom化することを~web開発者に許容するとする。
~web開発者は、そのような~custom化を，次のように登録するであろう：
◎
Let's say that one of the intended usages of our fake worklet by web developers is to allow them to customize the highly-complex process of boolean negation. They might register their customization as follows:
</p>

<pre class="lang-js">
// script.mjs
registerFake('negation-processor', class {
  process(%arg) {
    return !%arg;
  }
});
</pre>

<pre class="lang-js">
// app.mjs
window.fakeWorklet1.addModule("script.mjs");
</pre>

<div class="algo">
<p>
そのように登録された~classを用立てるため、~fake~worklet用の仕様は，
<dfn id="fakeworkletglobalscope-process">~T の~~反転を見出す~algo</dfn>
を定義することもできる
— それは、所与の
( `Worklet$I %~worklet )
に対し：
◎
To make use of such registered classes, the specification for fake worklets could define a find the opposite of true algorithm, given a Worklet worklet:
</p>
<ol>
	<li>
任意選択で
⇒
`~worklet大域~scopeを作成する$( %~worklet )
◎
Optionally, create a worklet global scope for worklet.
</li>
	<li>
%~worklet大域~scope ~LET `実装定義$な方式で選ばれる，
%~worklet の`大域~scope~list$wL内の いずれかの~item
◎
Let workletGlobalScope be one of worklet's global scopes, chosen in an implementation-defined manner.
</li>
	<li>
%~class構築子 ~LET %~worklet大域~scope の`登録-済み~class構築子~map$[ `negation-processor^l ]
◎
Let classConstructor be workletGlobalScope's registered class constructors map["negation-processor"].
</li>
	<li>
%~class~instance ~LET `~callback関数で構築する$( %~class構築子, « » )
◎
Let classInstance be the result of constructing classConstructor, with no arguments.
</li>
	<li>
%関数 ~LET `Get$jA( %~class~instance, `process^l )
（例外が投出され得る）
◎
Let function be Get(classInstance, "process"). Rethrow any exceptions.
</li>
	<li>
%~callback ~LET %関数 を `Function$I 型の`~IDL値に変換する$
◎
Let callback be the result of converting function to a Web IDL Function instance.
</li>
	<li>
~RET `~callback関数を呼出す$( %~callback, « ~T », %~class~instance )
◎
Return the result of invoking callback with the arguments « true » and with classInstance as the callback this value.
</li>
</ol>
</div>

<p class="note">注記：
たぶん，次のようにした方が、別の，もっと良い仕様~architectureになろう
⇒
`registerFake()$m ~method手続きの一部として、登録~時に
`process^l ~propを抽出して `Function$I に変換する
◎
Another, perhaps better, specification architecture would be to extract the "process" property and convert it into a Function at registration time, as part of the registerFake() method steps.
</p>

			</section>
		</section>
		<section id="worklets-infrastructure">
<h3 title="Infrastructure">11.3. 基盤</h3>

			<section id="worklets-global">
<h4 title="The global scope">11.3.1. 大域~scope</h4>

<p>
`WorkletGlobalScope$I の下位classは、`大域~obj$
— 特定0の `Worklet$I の中に読込まれた~codeを その中で実行できるような，それ —
を作成するために利用される。
【そのような各 下位classは、 “~worklet型” とも総称される。】
◎
Subclasses of WorkletGlobalScope are used to create global objects wherein code loaded into a particular Worklet can execute.
</p>

<pre class="idl">
[Exposed=Worklet, SecureContext]
interface `WorkletGlobalScope@I {};
</pre>

<p class="note">注記：
他の仕様は、 `WorkletGlobalScope$I を下位class化して，~classを登録するための~APIを
— 当の~worklet型に特有な他の~APIに加えて —
追加するものと意図される。
◎
Other specifications are intended to subclass WorkletGlobalScope, adding APIs to register a class, as well as other APIs specific for their worklet type.
</p>

<p>
各 `WorkletGlobalScope$I には
`~module~map@wL
が結付けられる。
それは，`~module~map$であり、初期~時は空とする。
◎
Each WorkletGlobalScope has an associated module map. It is a module map, initially empty.
</p>

				<section id="worklet-agents-and-event-loops">
<h5 title="Agents and event loops">11.3.1.1. ~agentと~event~loop</h5>

~INFORMATIVE

<p>
各 `WorkletGlobalScope$I は、自前の`~worklet~agent$内に包含され，それには対応する`~event~loop$aGがある。
しかしながら，実施においては、これらの~agentと~event~loopの実装は，他のほとんどのそれらとは異なるようになると予期される。
◎
Each WorkletGlobalScope is contained in its own worklet agent, which has its corresponding event loop. However, in practice, implementation of these agents and event loops is expected to be different from most others.
</p>

<p>
各 `WorkletGlobalScope$I 用に，`~worklet~agent$が存在する
— 理論~上は，実装は［
`WorkletGlobalScope$I の各~instanceごとに別々の~threadを利用する
］こともでき、この~levelの並列性は，~agentを利用して許容するのが最善になるので。
しかしながら，それらの `CanBlock^sl の値は ~F になるので、各~agentと各~threadが一対一になるとする要件は無い。
これは、~workletの中に読込まれる~scriptを どの~thread上でも実行する自由を実装に許容する
— `CanBlock^sl の値が ~F になるような，他の~agentからの~codeを走らせているものも含め（`生成元が類似な~window~agent$用の~thread（ “~main~thread” ）など）。
対照的に，`専用~worker~agent$は、
`CanBlock^sl の値が ~T になるので，実質的に専用な~OS~threadを取得することが要求される。
◎
A worklet agent exists for each WorkletGlobalScope since, in theory, an implementation could use a separate thread for each WorkletGlobalScope instance, and allowing this level of parallelism is best done using agents. However, because their [[CanBlock]] value is false, there is no requirement that agents and threads are one-to-one. This allows implementations the freedom to execute scripts loaded into a worklet on any thread, including one running code from other agents with [[CanBlock]] of false, such as the thread of a similar-origin window agent ("the main thread"). Contrast this with dedicated worker agents, whose true value for [[CanBlock]] effectively requires them to get a dedicated operating system thread.
</p>

<p>
~worklet`~event~loop$は、いくぶん特別でもあり，次に該当する`~task$用に限り利用される
⇒＃
`addModule()$m で結付けられるもの／
その中で~UAが作者が定義した~methodを呼出すもの／
`小task$
◎終
したがって，［
`~event~loop処理~model$は、すべての~event~loopは継続的に走らすものと指定している
］が、実装は，もっと単純な策を利用して 観測される結果が等価になることを達成できる
— 単に、作者が供した~methodを<a href="~WEBIDLjs#invoke-a-callback-function">呼出して</a>から，その処理nが`小task~checkpointを遂行する$ことに依拠するような。
◎
Worklet event loops are also somewhat special. They are only used for tasks associated with addModule(), tasks wherein the user agent invokes author-defined methods, and microtasks. Thus, even though the event loop processing model specifies that all event loops run continuously, implementations can achieve observably-equivalent results using a simpler strategy, which just invokes author-provided methods and then relies on that process to perform a microtask checkpoint.
</p>

				</section>
				<section id="worklets-creation-termination">
<h5 title="Creation and termination">11.3.1.2. 作成と終了n</h5>

<div class="algo">
<p>
`~worklet大域~scopeを作成する@
ときは、所与の
( `Worklet$I %~worklet )
に対し：
◎
To create a worklet global scope for a Worklet worklet:
</p>
<ol>
	<li>
%外側~設定群 ~LET %~worklet に`関連な設定群~obj$
◎
Let outsideSettings be worklet's relevant settings object.
</li>
	<li>
%~agent ~LET `~worklet~agentを得する$( %外側~設定群 )
◎
Let agent be the result of obtaining a worklet agent given outsideSettings.＼
</li>
	<li>
この手続きの以降は、 %~agent 内で走らすようにする
◎
Run the rest of these steps in that agent.
</li>
	<li>
<p>
%~realm実行~文脈 ~LET `新たな~JS~realmを作成する$( %~agent )
— 次に従って~custom化する下で
⇒
大域~obj用には、［
%~worklet の`~worklet大域~scope型$wL
］の新たな~objを作成する
◎
Let realmExecutionContext be the result of creating a new JavaScript realm given agent and the following customizations:
• For the global object, create a new object of the type given by worklet's worklet global scope type.
</li>
	<li>
%~worklet大域~scope ~LET %~realm実行~文脈 の~Realm成分の`大域~obj$rM
◎
Let workletGlobalScope be the global object of realmExecutionContext's Realm component.
</li>
	<li>
%内側~設定群 ~LET `~workletの環境~設定群~objを設定しておく$( %~realm実行~文脈, %外側~設定群 )
◎
Let insideSettings be the result of setting up a worklet environment settings object given realmExecutionContext and outsideSettings.
</li>
	<li>
<p>
%~worklet の`追加した~module~list$wLを成す
~EACH( %~module~URL )
に対し：
◎
For each moduleURL of worklet's added modules list:
</p>
		<ol>
			<li>
<p>
`~worklet~script~graphを~fetchする$( 次に挙げる引数 )
⇒＃
%~module~URL,
%内側~設定群,
%~worklet の`~worklet行先~種別$wL,
<span class="XXX">資格証~modeは何か？</span>,
%内側~設定群,
%~worklet の`~module応答~map$wL
◎
Fetch a worklet script graph given moduleURL, insideSettings, worklet's worklet destination type, what credentials mode?, insideSettings, and worklet's module responses map.＼
↓ Wait until the algorithm asynchronously completes with script.
</p>

<p class="note">注記：
これは、~network要請を実際に遂行することはない
— %~worklet の`~module応答~map$wL内の`応答$を再利用するだけなので。
この段の主~目的は、この`応答$から［
%~worklet大域~scope に特有な，新たな`~module~script$
］を作成することにある。
◎
This will not actually perform a network request, as it will just reuse responses from worklet's module responses map. The main purpose of this step is to create a new workletGlobalScope-specific module script from the response.
</p>
	</li>
	<li>
前~段が %~script を結果として`非同期に完了する$まで待機する
◎
↑</li>
	<li>
~Assert：
%~script ~NEQ ~NULL
— %~worklet の`~module応答~map$wLが初期~時に %~module~URL で拡充された時点で、~fetchは成功して，~source~textは成功裡に構文解析されたはずなので。
◎
Assert: script is not null, since the fetch succeeded and the source text was successfully parsed when worklet's module responses map was initially populated with moduleURL.
</li>
	<li>
`~module~scriptを走らす$( %~script )
◎
Run a module script given script.
</li>
		</ol>
	</li>
	<li>
%外側~設定群 の`大域~obj$enVに`結付けられている文書$の`~worklet大域~scope~list$doc
に %~worklet大域~scope を`付加する$
◎
Append workletGlobalScope to outsideSettings's global object's associated Document's worklet global scopes.
</li>
	<li>
%~worklet の`大域~scope~list$wLに %~worklet大域~scope を`付加する$
◎
Append workletGlobalScope to worklet's global scopes.
</li>
	<li>
%内側~設定群 により指定される`担当の~event~loop$enVを走らす
◎
Run the responsible event loop specified by insideSettings.
</li>
</ol>
</div>

<div class="algo">
<p>
`~worklet大域~scopeを終了させる@
ときは、所与の
( `WorkletGlobalScope$I %~worklet大域~scope )
に対し：
◎
To terminate a worklet global scope given a WorkletGlobalScope workletGlobalScope:
</p>
<ol>
	<li>
%~event~loop ~LET %~worklet大域~scope に`関連な~agent$の`~event~loop$aG
◎
Let eventLoop be workletGlobalScope's relevant agent's event loop.
</li>
	<li>
%~event~loop の`~task~queue$内に~queueされた`~task$は、すべて，処理することなく破棄する
◎
If there are any tasks queued in eventLoop's task queues, discard them without processing them.
</li>
	<li>
%~event~loop の`現在~走っている~task$が完了するまで待機する
◎
Wait for eventLoop to complete the currently running task.
</li>
	<li>
~IF［
前~段は、`実装定義$な期間~内に完了しなかった
］
⇒
当の~worklet内で現在`走っている~scriptを中止する$
◎
If the previous step doesn't complete within an implementation-defined period of time, then abort the script currently running in the worklet.
</li>
	<li>
%~event~loop を破壊する
◎
Destroy eventLoop.
</li>
	<li>
%~worklet大域~scope を それを包含している［
`Worklet$I の`大域~scope~list$wL
］から`除去する$
◎
Remove workletGlobalScope from the global scopes of the Worklet whose global scopes contains workletGlobalScope.
</li>
	<li>
%~worklet大域~scope を それを包含している［
`文書$の`~worklet大域~scope~list$doc
］から`除去する$
◎
Remove workletGlobalScope from the worklet global scopes of the Document whose worklet global scopes contains workletGlobalScope.
</li>
</ol>
</div>

				</section>
				<section id="script-settings-for-worklets">
<h5 title="Script settings for worklets">11.3.1.3. ~worklet用の~script設定群</h5>

<div class="algo">
<p>
`~workletの環境~設定群~objを設定しておく@
ときは、所与の
( `~JS実行~文脈$ %実行~文脈, `環境~設定群~obj$ %外側~設定群 )
に対し：
◎
To set up a worklet environment settings object, given a JavaScript execution context executionContext and an environment settings object outsideSettings:
</p>
<ol>
	<li>
%生成元 ~LET 一意な`不透明な生成元$
◎
Let origin be a unique opaque origin.
</li>
	<li>
%継承される~API用~基底~URL ~LET %外側~設定群 の`~API用~基底~URL$enV
◎
Let inheritedAPIBaseURL be outsideSettings's API base URL.
</li>
	<li>
%継承される施策~容器 ~LET `施策~容器を~cloneする$( %外側~設定群 の`施策~容器$enV )
◎
Let inheritedPolicyContainer be a clone of outsideSettings's policy container.
</li>
	<li>
%~realm ~LET %実行~文脈 の~Realm成分の値
◎
Let realm be the value of executionContext's Realm component.
</li>
	<li>
%~worklet大域~scope ~LET %~realm の`大域~obj$rM
◎
Let workletGlobalScope be realm's global object.
</li>
	<li>
<p>
%設定群~obj ~LET 新たな`環境~設定群~obj$
— その各種~algoは、次に従って定義される：
◎
Let settingsObject be a new environment settings object whose algorithms are defined as follows:
</p>
		<ul>
			<li>
`~realm実行~文脈$enV
⇒
~RET %実行~文脈
◎
The realm execution context
• Return executionContext.
</li>
			<li>
`~module~map$enV
⇒
~RET %~worklet大域~scope の`~module~map$wL
◎
The module map
• Return workletGlobalScope's module map.
</li>
			<li>
`担当の文書$enV
⇒
適用-可能でない（`担当の~event~loop$enVは`~window~event~loop$でない）
◎
The responsible document
• Not applicable (the responsible event loop is not a window event loop).
</li>
			<li>
`~API用~URL文字~符号化法$enV
⇒
~RET `~UTF-8$
◎
The API URL character encoding
• Return UTF-8.
</li>
			<li>
<p>
`~API用~基底~URL$enV
⇒
~RET %継承される~API用~基底~URL
◎
The API base URL
• Return inheritedAPIBaseURL.
</p>

<p class="note">注記：
［
~worker／単独の資源から導出される他の大域~obj
］と違って、~workletには首な資源は無い
— 代わりに，それぞれ自前の~URLを伴う複数の~scriptが、
`addModule()$m を介して大域~scopeの中に読込まれる。
なので、この`~API用~基底~URL$enVは，他の大域~obj用のそれとは違ったものになる。
しかしながら，［
`~API用~基底~URL$enVを用立てる~APIとして~worklet~codeに可用になるもの
］は無いので、これが問題mになることはない。
◎
Unlike workers or other globals derived from a single resource, worklets have no primary resource; instead, multiple scripts, each with their own URL, are loaded into the global scope via worklet.addModule(). So this API base URL is rather unlike that of other globals. However, so far this doesn't matter, as no APIs available to worklet code make use of the API base URL.
</p>
			</li>
			<li>
`生成元$enV
⇒
~RET %生成元
◎
The origin
• Return origin.
</li>
			<li>
`施策~容器$enV
⇒
~RET %継承される施策~容器
◎
The policy container
• Return inheritedPolicyContainer.
</li>
			<li>
`非同一-生成元~能力は隔離-済みか？$enV
⇒
~RET <span class="XXX">未策定</span>
◎
The cross-origin isolated capability
• Return TODO.
</li>
		</ul>
	</li>
	<li>
%設定群~obj の
⇒＃
`~ID$enV ~SET 新たな一意な不透明な文字列,
`作成時の~URL$enV ~SET %継承される~API用~基底~URL,
`~top-level作成時の~URL$enV ~SET ~NULL,
`~top-level生成元$enV ~SET %外側~設定群 の`~top-level生成元$enV,
`~target閲覧文脈$enV ~SET ~NULL,
`作動中の~sw$enV ~SET ~NULL
◎
Set settingsObject's id to a new unique opaque string, creation URL to inheritedAPIBaseURL, top-level creation URL to null, top-level origin to outsideSettings's top-level origin, target browsing context to null, and active service worker to null.
</li>
	<li>
%~realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm's [[HostDefined]] field to settingsObject.
</li>
	<li>
~RET %設定群~obj
◎
Return settingsObject.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="worklets-worklet">
<h4 title="The Worklet class">11.3.2. `Worklet^I ~class</h4>

<p>
`Worklet$I ~classは、それに結付けられる各 `WorkletGlobalScope$I の中へ`~module~script$を追加する能力を供する。
~UAは、
`WorkletGlobalScope$I に登録された各~classを作成して，それらの~methodを呼出せる。
◎
The Worklet class provides the capability to add module scripts into its associated WorkletGlobalScopes. The user agent can then create classes registered on the WorkletGlobalScopes and invoke their methods.
</p>

<pre class="idl">
[Exposed=Window, SecureContext]
interface `Worklet@I {
  [NewObject] Promise&lt;undefined&gt; `addModule$m(USVString %moduleURL, optional `WorkletOptions$I %options = {});
};

dictionary `WorkletOptions@I {
  `RequestCredentials$I `credentials@m = "same-origin";
};
</pre>

<p>
`Worklet$I ~instanceを作成する仕様は、所与の各~instanceが有するものとして，次を指定しなければナラナイ：
◎
Specifications that create Worklet instances must specify the following for a given instance:
</p>
<dl class="def-list">
	<dt>
`~worklet大域~scope型@wL
◎
its worklet global scope type,＼
</dt>
	<dd>
`WorkletGlobalScope$I を`継承-$する~Web~IDL型でなければナラナイ。
◎
which must be a Web IDL type that inherits from WorkletGlobalScope; and
</dd>

	<dt>
`~worklet行先~種別@wL
◎
its worklet destination type,＼
</dt>
	<dd>
~scriptを~fetchするときに利用される`行先$rqでなければナラナイ。
◎
which must be a destination, and is used when fetching scripts.
</dd>
</dl>

<dl class="domintro">
	<dt>await %worklet.`addModule$m(%moduleURL[, { `credentials$m }])</dt>
	<dd>
%moduleURL に与えられた`~module~script$を
%worklet の`大域~scope~list$wLを成すすべての中に
読込んで実行する。
それはまた、~worklet型に依存して，
この処理nの一部として，追加的な大域~scopeも作成し得る。
返される~promiseは、~scriptが成功裡に［
読込まれ，すべての大域~scope内で走った
］とき充足されることになる。
◎
Loads and executes the module script given by moduleURL into all of worklet's global scopes. It can also create additional global scopes as part of this process, depending on the worklet type. The returned promise will fulfill once the script has been successfully loaded and run in all global scopes.
</dd>
	<dd>
`credentials$m ~optionは、既定では `same-origin^l になる
— 他の`資格証~mode$rqに設定することで、~scriptを~fetchする処理nを改変できる。
◎
The credentials option can be set to a credentials mode to modify the script-fetching process. It defaults to "same-origin".
</dd>
	<dd>
返される~promiseは、［
~script, または その依存物
］にて次のいずれかが生じた場合には，却下されることになる
⇒＃
<a href="~WAPI#fetch-a-worklet-script-graph">~fetch時</a>における失敗に対しては、 `AbortError$E 例外で／
構文解析-時の~errorに対しては、それにより生成される例外で
◎
Any failures in fetching the script or its dependencies will cause the returned promise to be rejected with an "AbortError" DOMException. Any errors in parsing the script or its dependencies will cause the returned promise to be rejected with the exception generated during parsing.
</dd>
</dl>

<p>
各 `Worklet$I は、次に挙げるものを有する：
◎
↓</p>

<dl class="def-list">
	<dt>
`大域~scope~list@wL
◎
A Worklet has a list of global scopes,＼
</dt>
	<dd>
［
当の `Worklet$I の`~worklet大域~scope型$wL
］の~instanceたちを包含する`~list$であり、初期~時は空とする。
◎
which contains instances of the Worklet's worklet global scope type. It is initially empty.
</dd>

	<dt>
`追加した~module~list@wL
◎
A Worklet has an added modules list,＼
</dt>
	<dd>
`~URL~record$からなる`~list$であり、初期~時は空とする。
この~listへの~accessは、~thread安全になるベキである。
◎
which is a list of URLs, initially empty. Access to this list should be thread-safe.
</dd>

	<dt>
`~module応答~map@wL
◎
A Worklet has a module responses map,＼
</dt>
	<dd>
`~URL~record$から`応答$への`有順序~map$であり、初期~時は空とする。
この~mapへの~accessは、~thread安全になるベキである。
◎
which is an ordered map from URLs to responses, initially empty. Access to this map should be thread-safe.
</dd>
</dl>

<div class="note">
<p>
［
`追加した~module~list$wL, 
`~module応答~map$wL
］は、［
異なる時点に作成される各 `WorkletGlobalScope$I が，同じ~source~textに基づく等価な`~module~script$を走らす
］ようになることを確保するために存在する。
これは、作者からは透過的な，追加的な `WorkletGlobalScope$I の作成を許容する。
◎
The added modules list and module responses map exist to ensure that WorkletGlobalScopes created at different times get equivalent module scripts run in them, based on the same source text. This allows the creation of additional WorkletGlobalScopes to be transparent to the author.
</p>

<p>
実施においては、［
これらの~data構造を実装すること／
それらをアタる~algoが，~thread安全な~programming技法を利用すること
］は，~UAに期待されてはいない。
代わりに~UAは、
`addModule()$m が~callされたとき，次を行える：
◎
In practice, user agents are not expected to implement these data structures, and the algorithms that consult them, using thread-safe programming techniques. Instead, when addModule() is called, user agents can＼
</p>
<ol>
	<li>
~main~thread上で~module~graphを~fetchして、~fetchした~source~text（すなわち`~module応答~map$wL内に包含される重要な~data）を `WorkletGlobalScope$I を有する各~threadに送信する。
◎
fetch the module graph on the main thread, and send the fetched source text (i.e., the important data contained in the module responses map) to each thread which has a WorkletGlobalScope.
</li>
	<li>
次に，~UAが所与の `Worklet$I 用に新たな `WorkletGlobalScope$I を`作成-$wLしたとき、単純に［
~fetchした~source~textが成す~map, 各~入口~地点からなる~list
］を~main~threadから，新たな `WorkletGlobalScope$I を包含している~threadへ送信する。
◎
Then, when a user agent creates a new WorkletGlobalScope for a given Worklet, it can simply send the map of fetched source text and the list of entry points from the main thread to the thread containing the new WorkletGlobalScope.
</li>
</ol>
</div>

<div class="algo">
<p>
`addModule(moduleURL, options)@m
~method手続きは：
◎
The addModule(moduleURL, options) method steps are:
</p>
<ol>
	<li>
%外側~設定群 ~LET コレに`関連な設定群~obj$
◎
Let outsideSettings be the relevant settings object of this.
</li>
	<li>
%~module~URL~record ~LET `相対的に~URL構文解析する$( %moduleURL, %外側~設定群 )
◎
Parse moduleURL relative to outsideSettings.
</li>
	<li>
~IF［
%~module~URL~record ~EQ `失敗^i
］
⇒
~RET `SyntaxError$E 例外で`却下される~promise$
◎
If this fails, then return a promise rejected with a "SyntaxError" DOMException.
◎
↑Let moduleURLRecord be the resulting URL record.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
<p>
この段は、`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<p>
~IF［
コレの`大域~scope~list$wLは`空$である
］：
◎
If this's global scopes is empty, then:
</p>
				<ol>
					<li>
`~worklet大域~scopeを作成する$( コレ )
◎
Create a worklet global scope given this.
</li>
					<li>
任意選択で
⇒
［
当の特定の~worklet, その仕様
］に依存して，何個かの大域~scopeの~instanceを追加的に`作成-$wLする
◎
Optionally, create additional global scope instances given this, depending on the specific worklet in question and its specification.
</li>
					<li>
`作成-$wLする処理n（たち）を成す手続きすべてを完了するまで待機する
— `~worklet~agent$の中で場を占める段も含め
◎
Wait for all steps of the creation process(es) — including those taking place within the worklet agents — to complete, before moving on.
</li>
				</ol>
			</li>
			<li>
%処理待ち~task数 ~LET コレの`大域~scope~list$wLの`~size$
◎
Let pendingTasks be this's global scopes's size.
</li>
			<li>
%成功裡に追加されたか ~LET ~F
◎
Let addedSuccessfully be false.
</li>
			<li>
<p>
コレの`大域~scope~list$wLを成す
~EACH( %~worklet大域~scope )
に対し
⇒
`大域~taskを~queueする$( `~network用~task源$, %~worklet大域~scope, 次に与える下位手続き )
◎
For each workletGlobalScope of this's global scopes, queue a global task on the networking task source given workletGlobalScope to perform the following steps:
</p>

<div class="algo">
<p>
下位手続きは、次を遂行する：
◎
↑</p>
				<ol>
					<li>
<p>
`~worklet~script~graphを~fetchする$( 次に挙げる引数 )
⇒＃
%~module~URL~record,
%外側~設定群,
コレの`~worklet行先~種別$wL,
%options[ "`credentials$m" ],
%~worklet大域~scope に`関連な設定群~obj$,
コレの`~module応答~map$wL
◎
Fetch a worklet script graph given moduleURLRecord, outsideSettings, this's worklet destination type, options["credentials"], workletGlobalScope's relevant settings object, and this's module responses map.＼
↓Wait until the algorithm asynchronously completes with script.
</p>

<p class="note">注記：
これらの~fetchのうち，~network要請を実際に遂行することになるのは、最初のものに限られる
— 他の `WorkletGlobalScope$I 用のそれらは，コレの`~module応答~map$wLからの`応答$を再利用することになる。
◎
Only the first of these fetches will actually perform a network request; the ones for other WorkletGlobalScopes will reuse reuse responses from this's module responses map.
</p>
					</li>
					<li>
前~段が %~script を結果として`非同期に完了する$まで待機する
◎
↑</li>

					<li>
<p>
~IF［
%~script ~EQ ~NULL
］：
◎
If script is null, then:
</p>
						<ol>
							<li class="algo">
<p>
次を遂行する`大域~taskを~queueする$( `~network用~task源$, コレに`関連な大域~obj$ )：
◎
Queue a global task on the networking task source given this's relevant global object to perform the following steps:
</p>
								<ol>
									<li>
<p>
~IF［
%処理待ち~task数 ~NEQ −1
］：
◎
If pendingTasks is not −1, then:
</p>
										<ol>
											<li>
%処理待ち~task数 ~SET  −1
◎
Set pendingTasks to −1.
</li>
											<li>
`AbortError$E 例外で %~promise を`却下する$
◎
Reject promise with an "AbortError" DOMException.
</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
~RET
◎
Abort these steps.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~script の`再投出-用~error$sC ~NEQ ~NULL
］：
◎
If script's error to rethrow is not null, then:
</p>
						<ol>
							<li class="algo">
<p>
次を遂行する`大域~taskを~queueする$( `~network用~task源$, コレに`関連な大域~obj$ )：
◎
Queue a global task on the networking task source given this's relevant global object to perform the following steps:
</p>
								<ol>
									<li>
<p>
~IF［
%処理待ち~task数 ~NEQ −1
］：
◎
If pendingTasks is not −1, then:
</p>
										<ol>
											<li>
%処理待ち~task数 ~SET −1
◎
Set pendingTasks to −1.
</li>
											<li>
%~script の`再投出-用~error$sCで %~promise を`却下する$
◎
Reject promise with script's error to rethrow.
</li>
										</ol>
									</li>
								</ol>
							</li>
							<li>
~RET
◎
Abort these steps.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%成功裡に追加されたか ~EQ ~F
］：
◎
If addedSuccessfully is false, then:
</p>
						<ol>
							<li>
コレの`追加した~module~list$wLに %~module~URL~record を`付加する$
◎
Append moduleURLRecord to this's added modules list.
</li>
							<li>
%成功裡に追加されたか ~SET ~T
◎
Set addedSuccessfully to true.
</li>
						</ol>
					</li>
					<li>
`~module~scriptを走らす$( %~script )
◎
Run a module script given script.
</li>
					<li class="algo">
<p>
次を遂行する`大域~taskを~queueする$( `~network用~task源$, コレに`関連な大域~obj$ )
◎
Queue a global task on the networking task source given this's relevant global object to perform the following steps:
</p>
						<ol>
							<li>
<p>
~IF［
%処理待ち~task数 ~NEQ −1
］：
◎
If pendingTasks is not −1, then:
</p>
								<ol>
									<li>
%処理待ち~task数 ~DECBY 1
◎
Set pendingTasks to pendingTasks − 1.
</li>
									<li>
~IF［
%処理待ち~task数 ~EQ 0
］
⇒
%~promise を`解決する$
◎
If pendingTasks is 0, then resolve promise.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

			</section>
			<section id="worklets-lifetime">
<h4 title="The worklet's lifetime">11.3.3. ~workletの存続期間</h4>

<p>
`Worklet$I の存続期間には、特別な考慮点は無い
— 存続期間は、当の `Worklet$I が属する~obj（ `Window$I など）に束ねられる。
◎
The lifetime of a Worklet has no special considerations; it is tied to the object it belongs to, such as the Window.
</p>

<p>
各`文書$は、
`~worklet大域~scope~list@doc
を有する
— それは，何個かの `WorkletGlobalScope$I が成す`有順序~集合$であり、初期~時は空とする。
◎
Each Document has a worklet global scopes, which is a set of WorkletGlobalScopes, initially empty.
</p>

<p>
`WorkletGlobalScope$I %G の存続期間は、最低限，［
%G を包含する`~worklet大域~scope~list$docを有する`文書$
］に束ねられる。
特に，当の`文書$が`破棄-$docされたときは、
%G は`終了-$wLされ，~garbage収集できるようになる。
◎
The lifetime of a WorkletGlobalScope is, at a minimum, tied to the Document whose worklet global scopes contain it. In particular, discarding the Document will terminate the corresponding WorkletGlobalScope and allow it to be garbage-collected.
</p>

<p>
加えて，~UAは、所与の `WorkletGlobalScope$I を いつでも`終了-$wLさせてヨイ
— 対応する~worklet型を定義している仕様が，他を指定していない限り。
例えば，次のいずれかに該当する場合、それを終了させることもあろう
⇒＃
`~worklet~agent$の`~event~loop$aGに~queueされた`~task$は無いとき／
当の~workletを用立てるよう計画している処理待ち演算は無いとき／
無限~loopや課される時間~制限sを超過する~callbackなど，異常な演算が検出されたとき
◎
Additionally, user agents may, at any time, terminate a given WorkletGlobalScope, unless the specification defining the corresponding worklet type says otherwise.＼
For example, they might terminate them if the worklet agent's event loop has no tasks queued, or if the user agent has no pending operations planning to make use of the worklet, or if the user agent detects abnormal operations such as infinite loops or callbacks exceeding imposed time limits.
</p>

<p>
最後に，特定の~worklet型~用の仕様は、その型の `WorkletGlobalScope$I を`作成-$wLするときに，より特定的な詳細を与えれる。
例えば、~worklet~codeを~callする特定の処理nの間に，それを作成することもあろう
— <a href="#worklets-example-registering">§ ~classの登録-法と その~methodの呼出ng</a>の例のように。
◎
Finally, specifications for specific worklet types can give more specific details on when to create WorkletGlobalScopes for a given worklet type. For example, they might create them during specific processes that call upon worklet code, as in the example.
</p>

			</section>
		</section>
	</section>
</main>
