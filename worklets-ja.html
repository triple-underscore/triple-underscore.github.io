<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Worklets Level 1 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>
/* アルゴリズム */

*.algorithm {
	padding: .5em;
	border: thin solid #ddd;
	border-radius: .5em;
	margin: .5em 0;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	var source_data = {
		generate: expand,
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); // checked: 170308 spec

}

function expand(){

	var class_map = {
		t: 'type',
		e: 'element',
		a: 'attr',
		E: 'error',
		sl: 'js-slot',
		jA: 'abstract',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		e: 'code',
		E: 'code',
		a: 'code',
		at: 'code',
		h: 'code',
		c: 'code',
		v: 'code',
		t: 'var',
		sl: 'span',
		jA: 'span',
		i: 'i',
//		V: 'var',
	};

	var link_map = this.link_map;

	return this.html.replace(
		/%[~\w\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
//case 'mb': // IDL dictionary member
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l': // literal
	return '"<code class="literal">' + text + '</code>"'
case 'sl': // internal slot
	text = '[[' + key + ']]';
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}
return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:Worklets Level 1
spec_date:2018-04-10
trans_update:2018-04-10
	page_state_key:CSS
original_url:https://drafts.css-houdini.org/worklets/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2018,use
trans_1st_pub:2018-02-27

●●original_id_map

●●words_table1


●●words_table


WorkletGlobalScope:
CSP:
HTTPS:
realm:
Realm:
id:
service-worker:service worker
DOM:
HTML:
JS:JavaScript
interface::::インタフェース
URL:
access::::アクセス
cache::::キャッシュ
class::::
	class~s:classes#4
clear::::
code::::コード
console::::コンソール
data::::データ
entry::::エントリ
error::::エラー
map::::マップ
scope::::スコープ
event-loop:event loop:::イベントループ
event::::イベント
fetch::::
field::::フィールド
graph::::グラフ
instance::::インスタンス
key::::
list::::リスト
main::::
member::::メンバ
method::::メソッド
module::::モジュール
network::::ネットワーク
obj:object:::オブジェクト
random::::ランダム
record::::レコード
referrer::::リファラ

secure::::セキュア
	~secureでない:unsecure
security::::セキュリティ

script::::スクリプト
source::::ソース
target::::
text::::テキスト

url::
web:
window:
worker:
worklet:
小task:microtask::小 task:小タスク
layout::::レイアウト

	●処理一般
algo:algorithm:::アルゴリズム
call::::
callback::::
計数:counter:~
memory::::メモリ
処理-:process::~
処理:processing::~
処理待ち:pending::~
継続-:continue::~
呼出す:invoke する:呼び出す
呼出され:invoke され:呼び出され
呼出して:invoke して:呼び出して
呼出した:invoke した:呼び出した
被呼出時:被 invoke 時:~
走らす:run する:~
走る:run する:~
走らせ:run し:~
失敗-:fail::~
失敗:failure::~
成功裡:successful::~
初期:initial::~
	初期~時には:initially::~
初期化-:initialize::~
	何もしない:do nothing
無限:infinite::~
loop::::ループ
kill:
再開始-:restart:再開
	-:continuing

	●非同期／並列処理
task::::タスク
promise::::
queue::::キュー
process::::プロセス
thread::::スレッド
	thread安全:thread-safe
	~threadに非依存:thread-agnostic:
joining:
live:
存続期間:lifetime::~
pipeline::::パイプライン
stage:
phase:
stateless:
即時:immediate::~
断続的:continual::~
束ねら:tie さ:~
並列化-:parallelize::~
並列性:parallelism::~
並列的:parallel::~
破壊-:destroy::~
破棄-:discard::~
評価-:evaluate::~
評価:evaluation::~
冪等:idempotent::~
冪等性:idempotence::~
冪等性:idempotency::~
非同期:asynchronous::~
移動-:move::~
演算:operation::~
解決-:resolve::~
完了-:complete::~
却下-:reject::~
実行-:execute::~
実行:execution::~
作業:work::~
待機-:wait::~
中止-:abort::~
投機-:speculate:~
投機的:speculative::~
同時並行性:concurrency::~
	いつでも:at any time
	途中:in the middle of
	間:during
	どこでも:wherever
	舞台裏では:behind the scenes

	●仕様
UA:user agent:UA
API:
opt-out:
custom::::カスタム
	custom化:customization
model::::モデル
engine::::エンジン
overhead::::オーバーヘッド
	~overheadの高い:high-overhead
risk::::リスク
tool::::ツール
事例:case:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
特定的:specifical:具体的
作者:author:~
	例:example:~
依存-:depend:~
依拠-:rely:~
保証-:guarantee:~
保証:guarantee:~
制約-:restrict:~
制限-:limit:~
副作用:side-effect:~
効果:effect:~
動機:motivation:~
困難:difficult:~
基盤:infrastructure:~
報告-:report:~
	促す:encourage する:~
定義-:define:~
実装-:implement:~
実装:implementation:~
実際:actual:~
序論:introduction:~
	必要:need:~
	必要に応じて:as required
技法:technique:~
抑制-:reduce:~
拘束-:constrain:~
	constraints
指定-:specify:~
挙動:behaviour:ふるまい
供-:provide:~
供せ:provide でき:~
放棄-:abandon:~
書く:write する:~
望む:wish する:~
期待-:expect:~
予期-:expect:~
正し:correct:~
求める:want する:~
	決して:never:~
決める:decide する:~
	ことにした:decide
独立:independent:~
	用いて:using:~
異常:abnormal:~
目的:purpose:~
確保-:ensure:~
結付ける:associate する:~
結付けら:associate さ:結び付けら
考慮点:considerations:~
能:ability:~
能力:capability:~
要求-:require:~
見做して:assume して:~
設計-:design:~
許容-:allow:~
透過的:transparent:~
遂行-:perform:~
適用-:apply:~
	適用-可能:applicable
開発者:developer:~
防止-:prevent:~
非依存:agnostic:~
働ける:work できる:~
	利用-:use:~
拡張-:extend:~
拡張:extension:~
	控えめ:sparing
	あり得る:potential
実施上は:practical には:実施において
手続き:steps:~
段:step:~
複雑:complex:~
依拠-:rely:~
単純:simple:~
	simply

	従う:follow:~
	特に，:particularly
	課され:impose
	すなわち:that is
	そのため、:Due to this
	~~従来の前提:previously held assumptions
	任意選択で:optionally
	べき:should
	〜に基づく:based
	他に比して:relatively
	-:we
	-:asked to

	●未分類（動詞
作動中の:active な::~::アクティブな
応答:response::~
改変-:modify::~
拡充-:populate::~
共有-:share::~
共用:shared::~
具現化:rendering::~
継承-:inherit::~
検出-:detect::~
更新-:update::~
構成子:construct::~
構文解析-:parse::~
構文解析:parsing::~
合致-:match::~
参照-:reference::~
作成-:create::~
作成:creation::~
	作成-法:creating
作成時の:creation::~
設定群:settings::~
生産-:produce::~
宣言的:declarative::~
挿入-:insert::~
	insertion
終了-:terminate::~
送信-:send::~
	高める:increase する:~
存在-:exist::~
超過-:exceed::~
追加-:add::~
追加の:additional::~
登録-:register::~
投出:throw::~
入力:input::~
	比して:compare して::~
表現-:represent::~
表示-:display::~
変化-:change::~
返す:return::~
包含-:contain::~
有順序:ordered::~
要請:request::~
所有-:own::~
所有者:owner::~
変異-:mutate::~
	変異-可能:mutable
設定-:set::~
構築子:constructor::~
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
読込んで:load して::読み込んで::ロードして
送信-:send::~
	sent
debug::::デバッグ
	debug用:debugging
print:
更新-:update::~
併合-:merge::~
住まう:live する::~
	~NULL にされる:clear
	生じ:occur
	選ぶ:choose
	あてがう:assign
	し続け:keep
	対する応答は〜~cache済み:hit
	-:assocated
	属する:belong

	●未分類
fake:
surface:
options:::option 集
strict-mode:strict mode
基底:base::~
閲覧文脈:browsing context::~
一意:unique::~
引数:argument::~
環境:environment::~
資格証:credentials::資格証明情報::クレデンシャル
大域:global::~::グローバル
関数:function::~
空:empty::~
型:type::~
時刻:time::~
	重複:duplicate::~
出力:output::~
順序:order::~
状態:state::~
	数:number
成分:component::~
生成元:origin::~
相対的:relative::~
値:value::~
抽象:abstract::~
長さ:length::~
等価:equivalent::~
内側:inside::~
外側:outside::~
不透明:opaque::~
文字列:string::~
文書:document::~
文脈:context::~
例外:exception::~
集合:set::~
妥当:valid::~
地点:point::~
施策:policy::~:ポリシー
文字:character:~
符号化方式:encoding::~::エンコーディング
構造体:struct::~
安全:safe::~

	●指示語
新たな:new::~
特定0の:particular:ある特定の
未来:future:~
	個の:one ／two
	ここ:here
	この:this
	これらの:these
	すべて:all
	その:that
	そのような:such
	それらの:their
	それらを:them
	異なる:different
	下:below
	加えて:additionally
	加えて:in addition
	各:each
	間:between
	結果:result
	結果の:resulting
	現在:currently
	現在の:current
	高い:high
	再度:again
	最初の:first
	所与の:given
	上:above
	常に:always
	新たな:new
	新たに:newly
	前:before
	対応ing:corresponding
	等々:etc
	同じ:same
	複数の:multiple
	類似する:similar
	他の:other
	別々の:separate
	別の:another
	個別に:distinct
	後続の:subsequent
	だけ:just
	〜の代わりに:instead
	以上の:at least
	#3:number 3
	でない:non-
	以降:rest of
	:against

	●変数
	~worklet~event-loop:workletEventLoop
	~realm実行~文脈:realmExecutionContext
	外側~設定群:outsideSettings
	内側~設定群:insideSettings
	実行~文脈~executionContext
	継承された~API用~基底~URL:inheritedAPIBaseURL
	継承された~HTTPS状態:inheritedHTTPSState
	継承された担当の閲覧文脈:inheritedResponsibleBrowsingContext
	継承された~referrer施策:inheritedReferrerPolicy
	設定群~obj:settingsObject
	資格証~options:credentialOptions
	~module応答~map:moduleResponsesMap
	処理待ち~task構造体:pendingTaskStruct
	~module~URL~record:moduleURLRecord
	~worklet大域~scope型:workletGlobalScopeType
	~worklet大域~scope:workletGlobalScope
	~class構築子:classConstructor
	~class構築子:classCtor
	~class~instance:classInstance


●●link_map

	●IDL
Global:~WEBIDL#Global
Exposed:~WEBIDL#Exposed
NewObject:~WEBIDL#NewObject
SyntaxError:~WEBIDL#syntaxerror
USVString:~WEBIDL#idl-USVString

I.Worklet:#worklet
I.WorkletGlobalScope:#workletglobalscope
I.WorkletOptions:#dictdef-workletoptions
I.PaintWorkletGlobalScope:https://drafts.css-houdini.org/css-paint-api-1/#paintworkletglobalscope
I.RequestCredentials:~FETCH#requestcredentials
I.DedicatedWorkerGlobalScope:~WORKERS#dedicatedworkerglobalscope
I.EventTarget:~DOM4#interface-eventtarget
I.Window:~WINDOW#window
I.Document:#dom-document
	~HTMLINFRA#dom-document
	I.FakeWorkletGlobalScope:#fakeworkletglobalscope

E.SyntaxError:~WEBIDL#syntaxerror
E.AbortError:~WEBIDL#aborterror
	DOMException:~WEBIDL#idl-DOMException

m.addModule:#dom-worklet-addmodule
m.credentials:#dom-workletoptions-credentials
	m.registerAnArbitaryClass:#dom-fakeworkletglobalscope-registeranarbitaryclass
m.self:~WORKERS#dom-workerglobalscope-self


	●用語
計数:#pending-tasks-struct-counter
~WorkletGlobalScopeを作成する:#create-a-workletglobalscope

~worklet~scriptを~fetchして呼出す:#fetch-and-invoke-a-worklet-script
~worklet~scriptを~fetchする:#fetch-a-worklet-script
処理待ち~task構造体:#pending-tasks-struct
登録-済み~class構築子~map:#registered-class-constructors-map
~workletの環境~設定群~objを設定しておく:#set-up-a-worklet-environment-settings-object

	sl.HostDefined

~worklet大域~scope:#worklet-global-scope
wL.環境~設定群~obj:#_workletglobalscope-environment-settings-object
wL.~module~map:#workletglobalscope-module-map
wL.所有者~文書:#workletglobalscope-owner-document
wL.~worklet大域~scope実行~環境:#worklet-global-scope-execution-environment
wL.~module応答~map:#module-responses-map
wL.~worklet大域~scope型:#worklet-global-scope-type
wL.~WorkletGlobalScope~list:#worklets-workletglobalscopes

UTF-8:~ENCODING#utf-8

~fetch:~FETCH#concept-fetch
rq.~url:~FETCH#concept-request-url

並列的:~HTMLINFRA#in-parallel
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
破棄され:~WINDOW#a-browsing-context-is-discarded
不透明な生成元:~ORIGIN#concept-origin-opaque
~web~worker:~WORKERS#workers
~workerの環境~設定群~objを設定しておく:~WORKERS#set-up-a-worker-environment-settings-object

非同期に完了する:~WAPI#_asynchronously-complete
	＊
文書~環境:#_document-environment
	~WAPI#document-environment
環境~設定群~obj:~WAPI#environment-settings-object
~event-loop:~WAPI#event-loop
閲覧文脈~event-loop:~WAPI#_browsing-context-event-loop
~worker用~module~script~graphを~fetchする:~WAPI#fetch-a-module-worker-script-tree
~module~scriptを走らす:~WAPI#run-a-module-script

小task:~WAPI#microtask
小task~queue:~WAPI#microtask-queue
~module~script:~WAPI#module-script
~fetchを遂行する:~WAPI#fetching-scripts-perform-fetch
~taskを~queueする:~WAPI#queue-a-task
関連する設定群~obj:~WAPI#relevant-settings-object
例外を報告する:~WAPI#report-the-exception
~module~map:~WAPI#module-map

enV.作動中の~service-worker:~WAPI#concept-environment-active-service-worker
enV.~API用~基底~URL:~WAPI#api-base-url
enV.~API用~URL文字~符号化方式:~WAPI#api-url-character-encoding
enV.作成時の~URL:~WAPI#concept-environment-creation-url
enV.大域~obj:~WAPI#concept-settings-object-global
enV.~module~map:~WAPI#concept-settings-object-module-map
enV.~HTTPS状態:~WAPI#https-state
enV.~id:~WAPI#concept-environment-id
enV.生成元:~WAPI#concept-settings-object-origin
enV.~realm実行~文脈:~WAPI#realm-execution-context
enV.~referrer施策:~WAPI#concept-settings-object-referrer-policy
enV.担当の閲覧文脈:~WAPI#responsible-browsing-context
enV.担当の文書:~WAPI#responsible-document
enV.担当の~event-loop:~WAPI#responsible-event-loop
enV.~target閲覧文脈:~WAPI#concept-environment-target-browsing-context



構造体:~INFRA#struct
有順序~map:~INFRA#ordered-map
	~keyたちを取得する:~INFRA#map-getting-the-keys
新たな~promise:~PROMISES#a-new-promise
継承-:~WEBIDL#dfn-inherit
~callback関数を呼出す:~WEBIDL#es-invoking-callback-functions

相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL~record:~HTMLurl#resulting-url-record


jA.InitializeHostDefinedRealm:~TC39#sec-initializehostdefinedrealm
jA.Construct:~TC39#sec-construct
	http://www.ecma-international.org/ecma-262/6.0/#sec-construct
jA.Invoke:~TC39#sec-invoke
	http://www.ecma-international.org/ecma-262/6.0/#sec-invoke
大域~objの~CSP~listを初期化する:~CSP3#initialize-global-object-csp
~strict-mode:~TC39#sec-strict-mode-code
	http://www.ecma-international.org/ecma-262/6.0/#sec-strict-mode-code


●●ref_normative

[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 20 February 2014. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[ENCODING]
    Anne van Kesteren. Encoding Standard. Living Standard. URL: https://encoding.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[PROMISES-GUIDE]
    Domenic Denicola. Writing Promise-Using Specifications. 16 February 2016. Finding of the W3C TAG. URL: https://www.w3.org/2001/tag/doc/promises-guide 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSS-PAINT-API-1]
    Shane Stephens; Ian Kilpatrick; Dean Jackson. CSS Painting API Level 1. 7 June 2016. WD. URL: https://www.w3.org/TR/css-paint-api-1/ 
[WEBAUDIO]
    Paul Adenot; Chris Wilson; Chris Rogers. Web Audio API. 8 December 2015. WD. URL: https://www.w3.org/TR/webaudio/ 

●●trans_metadata

<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Object Model (CSSOM)</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新発行バージョン
	http://www.w3.org/TR/worklets-1/

フィードバック
	<a href="mailto:public-houdini@w3.org?subject=%5Bworklets%5D%20YOUR%20TOPIC%20HERE">public-houdini@w3.org</a> with subject line “<kbd>[worklets] <i>… message topic …</i></kbd>” (<a href="http://lists.w3.org/Archives/Public/public-houdini/" rel="discussion">archives</a>)

最新の課題
	<a href="https://github.com/w3c/css-houdini-drafts/issues/">GitHub</a>

編集
	<a href="mailto:ikilpatrick@chromium.org">Ian Kilpatrick</a>

発行者
	<a href="http://www.w3.org/Style/CSS/members">CSS Working Group</a> (part of the <a href="http://www.w3.org/Style/">Style Activity</a>)

commit 履歴
	https://github.com/w3c/css-houdini-drafts/commits/master

</script>

<!-- 
<a href="https://github.com/w3c/css-houdini-drafts/issues">GitHub Issues</a> are <a href="https://lists.w3.org/Archives/Public/public-houdini-archive/">archived</a>
 -->

</head>

<body>

<header>


	<hgroup>
<h1>Worklets Level 1</h1>
	</hgroup>
</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>


<p>
この仕様は、~main~JS実行~環境からは独立に，具現化~pipelineを成す~stageたち内で~scriptを走らすための~APIを定義する。
◎
This specification defines an API for running scripts in stages of the rendering pipeline independent of the main javascript execution environment.
</p>



	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<!-- 
この節では、発行時点における…
 -->
これは編集者草案の公開の複製です…
<span class="trans-note">【
以下，この節の他の内容は
<a href="css-common-ja.html#status">CSS 日本語訳 共通ページ</a>
に委譲
】</span></p>


	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

		<section id="motivations">
<h3 title="Motivations">1.1. 動機</h3>

~INFORMATIVE

<p>
`文書~環境@
†内に拡張~地点を定義できるようにするのは、困難である
— 具現化~engineは、~phaseの途中で何が起こり得るかについて，~~従来の前提を放棄する必要があるので。
【†原文による<a href="~HTMLLS/webappapis.html#document-environment">リンク先の定義</a>（~HTML仕様）は、現在は廃されている。】
◎
Allowing extension points defined in the document environment is difficult, as rendering engines would need to abandon previously held assumptions for what could happen in the middle of a phase.
</p>

<p>
例えば具現化~engineは、~layout~phaseの間は，~DOMは改変されないものと見做している。
◎
For example, during the layout phase the rendering engine assumes that no DOM will be modified.
</p>


<p>
加えて、`文書~環境$内に拡張~地点を定義することは、具現化~engineが，`文書~環境$と同じ~thread内で作業を遂行することを制約する。
（具現化~engineが，~thread~joining保証【？】に加えて ~thread安全な~APIも許容するような，複雑, かつ~overheadの高い基盤を追加しない限り）。
◎
Additionally defining extension points in the document environment would restrict rendering engines to performing work in the same thread as the document environment. (Unless rendering engines added complex, high-overhead infrastructure to allow thread-safe APIs in addition to thread joining guarantees).
</p>

<p>
~workletは、具現化~engineが現在~依拠しているものは保証し続けつつ，そのような拡張~地点を具現化~engine内に許容するよう設計されている。
◎
The worklet is designed to allow such extension points in rendering engines, while keeping guarantees which rendering engines rely currently on.
</p>


<p>
~workletは`~web~worker$に類似するが：
◎
Worklets are similar to web workers however they:
</p>

<ul>
	<li>
~threadに非依存である。
すなわち、特定0の~thread上で走らすように定義されない。
具現化~engineは、それらを自身が選ぶどこで走らせても~MAY。
◎
Are thread-agnostic. That is, they are not defined to run on a particular thread. Rendering engines may run them wherever they choose.
</li>
	<li>
並列性の目的で、複数の［
大域~scopeの~instance
］を重複して作成できる。
◎
Are able to have multiple duplicate instances of the global scope created for the purpose of parallelism.
</li>
	<li>
~event~APIに基づかない。
代わりに，いくつかの~classが大域~scopeに登録され、それらの~methodは，~UAにより呼出されることになる。
◎
Are not event API based. Instead classes are registered on the global scope, whose methods are to be invoked by the user agent.
</li>
	<li>
<p>
大域~scope上の~API~surfaceは、抑制される。
</p>
<p class="trans-note">【
`WebIDL$r の用語で述べるならば、 `Exposed$ 拡張属性を通して`~worklet大域~scope$に公開される~interfaceは，他（ ~workerや~window ）に比して限られている。
】</p>
◎
Have a reduced API surface on the global scope.
</li>
	<li>
［
後続の仕様や~UAにより定義される大域~scope
］用として，存続期間がある。
それらは、文書の存続期間に束ねられない。
◎
Have a lifetime for the global scope which is defined by subsequent specifications or user agents. They aren’t tied to the lifetime of the document.
</li>
	<li>
~overheadが他に比して高いので，控えめに利用されるべきである。
そのため、~workletは，別々の~script間で共有されるものと期待される。
このことは、`文書~環境$に類似する。
◎
As worklets have a relatively high overhead, they should be used sparingly. Due to this worklets are expected to be shared between separate scripts. This is similar to the document environment.
</li>
</ul>

		</section>
		<section id="code-idempotency">
<h3 title="Code Idempotency">1.2. ~codeの冪等性</h3>

<p>
~workletを利用する仕様
— 以下、この節を通して，単に %当該~仕様 と記す —
のうち一部のもの（例： `css-paint-api-1$r ）は、各 作業を［
複数の~threadに並列化する ／
必要に応じて別~threadへ移動する
］ことを，~UAに許容する。
◎
Some specifications which use worklets ([css-paint-api-1]), allow user agents to parallelize work over multiple threads, or to move work between threads as required.
</p>

<p>
%当該~仕様 の下で~class上の~methodを呼出す順序は、複数の~UA間で異なるかもしれない。
◎
In these specifications user agents might invoke methods on a class in a different order to other user agents.
</p>

<p>
その結果による~UA間の互換性~riskを防止するため、 %当該~仕様 の~APIを用いて大域~scopeに~classを登録する作者は，~codeを冪等にするべきである。
すなわち，ある~class上の［
1 個以上の~methodが成す組
］は、所与の特定0の入力に対し同じ出力を生産するべきある。
◎
As a result of this, to prevent this compatibility risk between user agents, authors who register classes on the global scope using these APIs, should make their code idempotent. That is, a method or set of methods on a class should produce the same output given a particular input.
</p>

<p>
次に挙げる技法は、 %当該~仕様 が，~codeを冪等な仕方で書くのを作者に促すために利用される：
◎
The following techniques are used in order to encourage authors to write code in an idempotent way:
</p>

<ul>
	<li>
大域~objへの参照-（例： `DedicatedWorkerGlobalScope$I 上の `self$m ）は、持たないようにする。
◎
No reference to the global object, e.g. self on a DedicatedWorkerGlobalScope.
</li>
	<li>
~codeは、`~module~script$として読込むようにする
— それにより，~codeは、 `this^jv を共有することなく，`~strict-mode$で実行される結果、大域~scope上の共用~objが 状態を共有している複数の~module~scriptから参照されるのは，防止される。
◎
Code is loaded as a module script which resulting in the code being executed in strict mode code without a shared this. This prevents two different module scripts sharing state be referencing shared objects on the global scope.
</li>
	<li>
<p>
%当該~仕様 は、次を~UAに要求し~MUST：
</p>
		<ul>
			<li>
`Worklet$I ごとに 2 個~以上の `WorkletGlobalScope$I が常にあること。
</li>
			<li>
ある~class上の［
1 個以上の~methodが成す組
］を 特定0の大域~scopeに~randomにあてがうこと。
</li>
		</ul>
<p>
 %当該~仕様 は、~memoryが拘束された下では，~opt-outを供せる。
</p>
◎
These specifications must require user agents to always have at least two WorkletGlobalScopes per Worklet and randomly assign a method or set of methods on a class to a particular global scope. These specifications can provide an opt-out under memory constraints.
</li>
	<li>
~UAは、 %当該~仕様 が定義する `WorkletGlobalScope$I 【の拡張】を，いつでも作成でき, 破壊できる。
◎
User agents can create and destroy WorkletGlobalScopes at any time for these specifications.
</li>
</ul>


		</section>
		<section id="speculative-evaluation">
<h3 title="Speculative Evaluation">1.3. 投機的な評価</h3>


<p>
~workletを利用する一部の仕様（例： `css-paint-api-1$r ）は、~UAの状態に基づいて~class上の~methodを呼出して~MAY。
複~thread間の同時並行性を高めるため、~UAは，未来にあり得る状態に基づいて，~methodを投機的に呼出して~MAY。
◎
Some specifications which use worklets ([css-paint-api-1]) may invoke methods on a class based on the state of the user agent. To increase the concurrency between threads, a user agent may invoke a method speculatively, based on potential future states.
</p>


<p>
これらの仕様においては、~UAは，~class上の~methodを［
いつでも，および
~UAの現在の状態に対応するものに限らず 他の引数でも
］呼出して, ~cacheして~MAY
— そのような投機的な評価の結果は，即時には表示されないが、~UAの状態が投機された状態に合致するとき，利用できる。
これは、~UAと~worklet~thread間の同時並行性を高めるであろう。
◎
In these specifications user agents might invoke methods on a class at any time, and with any arguments, not just ones corresponding to the current state of the user agent. The results of such speculative evaluations are not displayed immediately, but may be cached for use if the user agent state matches the speculated state. This may increase the concurrency between the user agent and worklet threads.
</p>


<p>
この結果による，~UA間の互換性~riskを防止するため、これらの~APIを用いて大域~scopeに
~classを登録する作者は、自身の~codeを~statelessにするべきである。
すなわち，~methodを呼出すことによる効果は、その結果に限られるべきである
— 変異-可能な状態を更新するような副作用は，一切伴わずに。
◎
As a result of this, to prevent this compatibility risk between user agents, authors who register classes on the global scope using these APIs, should make their code stateless. That is, the only effect of invoking a method should be its result, not any side-effects such as updating mutable state.
</p>

<p>
~code冪等性を促す同じ技法は、~stateless~codeを書くことも，作者に促す。
◎
The same techniques which encourage code idempotence also encourage authors to write stateless code.
</p>



		</section>
	</section>
	<section id="infrastructure">
<h2 title="Infrastructure">2. 基盤</h2>

		<section id="the-global-scope">
<h3 title="The Global Scope">2.1. 大域~scope</h3>

<p>
`WorkletGlobalScope$I ~objは、
`~worklet大域~scope@
を供する。
それは、 `Worklet$I の大域~実行~文脈を表現する。
◎
The WorkletGlobalScope object provides a worklet global scope which represents the global execution context of a Worklet.
</p>

<p class="trans-note">【
<a href="~WORKERS#the-global-scope">~workerのときと同様に</a>，概念的には、［
`WorkletGlobalScope$I ／ `Worklet$I
］が，同じ~workletが［
内側／外側
］に “見せる顔” になる。
】</p>

<pre class="idl">
[`Exposed$=Worklet]
interface `WorkletGlobalScope@I {
};
</pre>

<p>
各 `WorkletGlobalScope$I には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`所有者~文書@wL</dt>
	<dd>
初期~時には ~NULL とする。
それは、 `~WorkletGlobalScopeを作成する$~algoの内側で設定される。
◎
Each WorkletGlobalScope has an assocated owner document. It is initially null and set inside the create a WorkletGlobalScope algorithm.
</dd>
	<dd>
`Document$I ~obj %文書 が【`属する閲覧文脈$が】`破棄され$るときは、
%文書 を`所有者~文書$wLとしているどの `WorkletGlobalScope$I に対しても，その`所有者~文書$wLは ~NULL にされるべきである。
◎
Whenever a Document object is discarded, each WorkletGlobalScope whose owner document is that Document object, should clear its owner document.
</dd>

	<dt>`環境~設定群~obj@wL</dt>
	<dd>
`環境~設定群~obj$。
【`~workletの環境~設定群~objを設定しておく$ときに， `HostDefined^sl に格納される。】
◎
Each WorkletGlobalScope has an associated environment settings object.
</dd>

	<dt>`~module~map@wL</dt>
	<dd>
`~module~map$。
初期~時には空とする。
◎
Each WorkletGlobalScope has an associated module map. It is a module map, initially empty.
</dd>

	<dt>`~worklet大域~scope実行~環境@wL</dt>
	<dd>
この実行~環境は、並列的にしても（すなわち，別々の~thread等
— ~thread, ~process, その他の等価な構成子 —
に分ける）,
それが属する `Worklet$I ~objが他と同じ~thread等に住まうようにしても~MAY。
どの~thread等に住まうかは、~UAが決める。
◎
Each WorkletGlobalScope has a worklet global scope execution environment. This execution environment may be parallel (i.e. it may be on a separate thread, process, or other equivalent construct), or it may live on the same thread or process as the Worklet object it belongs to. Which thread or process it lives on is decided by the user agent.
</dd>
</dl>


<p class="note">注記：
`WorkletGlobalScope$I は、 `DedicatedWorkerGlobalScope$I に比して制限された大域~scopeである。
他の仕様は、 `WorkletGlobalScope$I を拡張するものと期待される
— ［
~UAが 作成して~methodを呼出すための~classを，作者が登録する
］のを許容する~methodを加えることにより（例えば `registerAClass()^m の様な名前の）。
◎
Note: The WorkletGlobalScope has a limited global scope when compared to a DedicatedWorkerGlobalScope. It is expected that other specifications will extend WorkletGlobalScope with registerAClass methods which will allow authors to register classes for the user agent create and invoke methods on.
</p>


<p>
【この仕様において】`例外を報告する$所では、任意選択で，何もしないか, 開発者~consoleに例外を報告する。
◎
When asked to report an exception, do nothing instead, or optionally report the exception to a developer console.
</p>


<p class="issue">
~HTMLによる`例外を報告する$は、
`EventTarget$I でない大域~objでも働けるよう，更新する必要がある。
<a href="https://github.com/whatwg/html/issues/2611">&lt;https://github.com/whatwg/html/issues/2611&gt;</a>
◎
HTML’s report an exception needs updating to work with non-EventTarget global objects. &lt;https://github.com/whatwg/html/issues/2611&gt;
</p>



			<section id="the-event-loop">
<h4 title="The event loop">2.1.1. ~event-loop</h4>


<p>
各 `WorkletGlobalScope$I ~objは、個別に`~event-loop$を持つ
— この~event-loopは：
◎
Each WorkletGlobalScope object has a distinct event loop.＼
</p>


<ul>
	<li>
`閲覧文脈$には結付けられない。
◎
This event loop has no associated browsing context.＼
</li>
	<li>
`~WorkletGlobalScopeを作成する$~algoにより作成される。
◎
The event loop is created by the create a WorkletGlobalScope algorithm.
</li>
	<li>
上で定義した`~worklet大域~scope実行~環境$wL下で走る。
◎
The event loop is run on the worklet global scope execution environment defined above.
</li>
	<li>
それを利用するのは、次に挙げるものに限られるものと予期されている
⇒＃
`addModule()$m に結付けられている~task ／
作者により定義され，~UAが呼出す~callback ／
`小task$
◎
It is expected that only tasks associated addModule(), the user agent invoking author defined callbacks, and microtasks will use this event loop.
</li>
</ul>


<p class="note">注記：
<a href="#event-loop-processing-model">~event-loop処理~model</a>
は，断続的に~loopするものと指定していても、実施上は，実装がそれを行うものとは期待されてはいない。
`小task~queue$は、作者により供された`~callback関数を呼出す$間に，空にされる。
◎
Note: Even through the event loop processing model specifies that it loops continually, practically implementations aren’t expected to do this. The microtask queue is emptied while invoking callback functions provided by the author.
</p>

			</section>
			<section id="creating-a-workletglobalscope">
<h4 title="Creating a WorkletGlobalScope">2.1.2.  `WorkletGlobalScope^I の作成-法</h4>

<div class="algorithm">

<p>
~UAは
`~WorkletGlobalScopeを作成する@
ときは、所与の
⇒＃
%~worklet大域~scope型,
%~module応答~map,
%外側~設定群,
%資格証~options
◎終
に対し，次の手続きを走らせ~MUST：
◎
When a user agent is to create a WorkletGlobalScope, given workletGlobalScopeType, moduleResponsesMap, and outsideSettings, it must run the following steps:
</p>

<ol>
	<li>
新たな`~worklet大域~scope実行~環境$wLを作成する
— この手続きの以降は、その文脈の下で走らす
◎
Create the worklet global scope execution environment and run the rest of these steps in that context.
</li>
	<li>
%~worklet大域~scope ~LET 型 %~worklet大域~scope型 の新たな~obj
◎
↓</li>
	<li>
%~realm実行~文脈 ~LET ［
大域~objに %~worklet大域~scope を用いるように~custom化する
］下で，［
~JS `InitializeHostDefinedRealm$jA 抽象~演算
］を~callして作成される~JS実行~文脈
◎
Call the JavaScript InitializeHostDefinedRealm abstract operation with the following customizations:
• For the global object, create a new workletGlobalScopeType object. Let workletGlobalScope be the created object.
• Let realmExecutionContext be the created JavaScript execution context.
</li>
	<li>
%内側~設定群 ~LET
`~workletの環境~設定群~objを設定しておく$( %~realm実行~文脈, %外側~設定群 )
◎
Let insideSettings be the result of set up a worklet environment settings object given realmExecutionContext, and outsideSettings.
</li>
	<li>
%内側~設定群 と %~worklet大域~scope を結付ける
◎
Associate the insideSettings with workletGlobalScope.
</li>
	<li>
%~worklet大域~scope の`所有者~文書$wL ~SET %外側~設定群 の`担当の文書$enV
◎
Set workletGlobalScope’s owner document to outsideSettings’s responsible document.
</li>
	<li>
`大域~objの~CSP~listを初期化する$( %~worklet大域~scope, † )
【† 何らかの応答も引数に必要だが、言及されていない】
◎
Invoke the initialize a global object’s CSP list algorithm given workletGlobalScope.
</li>
	<li>
<p>
%~module応答~map 内の~EACH( %~entry ) に対し：
◎
For each entry in the given moduleResponsesMap (in insertion order), run the following substeps:
</p>
		<ol>
			<li>
%~module~URL~record ~LET %~entry の~key
◎
Let moduleURLRecord be entry’s key.
</li>
			<li>
%~script ~LET 次を走らせて`非同期に完了する$まで待機した結果の`~module~script$
⇒
`~worklet~scriptを~fetchする$(
%~module~URL~record,
%~module応答~map,
%資格証~options,
%外側~設定群,
%内側~設定群
)
◎
Let script be the result of fetch a worklet script given moduleURLRecord, moduleResponsesMap, outsideSettings, and insideSettings when it asynchronously completes.
</li>
			<li>
`~module~scriptを走らす$( %~script )
◎
Run a module script given script.
</li>
	</ol>
<p class="note">注記：
この段において`~worklet~scriptを~fetchする$ときには、実際に~network要請が遂行されることはない
— 対する応答は、~workletの`~module応答~map$wL内に~cache済みなので。
また、構文解析~errorにもならない
— この時点では、別の~worklet大域~scopeにより成功裡に構文解析されているはずなので。
すなわち、ここで %~script が ~NULL になることは，決してないはずである。
◎
Note: Fetch a worklet script won’t actually perform a network request as it will hit the worklet’s module responses map. It also won’t have a parsing error as at this point it should have successfully been parsed by another worklet global scope. I.e. script should never be null here.
</p>
	</li>
	<li>
%内側~設定群 により指定される`担当の~event-loop$enVを走らす
◎
Run the responsible event loop specified by insideSettings.
</li>
</ol>
</div>


			</section>
			<section id="script-settings-for-worklets">
<h4 title="Script settings for worklets">2.1.3. ~worklet用の~script設定群</h4>

<div class="algorithm">

<p>
`~workletの環境~設定群~objを設定しておく@
ときは、所与の
( %実行~文脈, %外側~設定群 )
に対し，次の手続きを走らせ~MUST：
◎
When a user agent is to set up a worklet environment settings object, given a executionContext, and outsideSettings, it must run the following steps:
</p>

<ol>
	<li>
%継承される担当の閲覧文脈 ~LET %外側~設定群 の`担当の閲覧文脈$enV
◎
Let inheritedResponsibleBrowsingContext be outsideSettings’s responsible browsing context.
</li>
	<li>
%継承される~API用~基底~URL ~LET %外側~設定群 の`~API用~基底~URL$enV
◎
Let inheritedAPIBaseURL be outsideSettings’s API base URL.
</li>
	<li>
%生成元 ~LET 一意かつ`不透明な生成元$
◎
Let origin be a unique opaque origin.
</li>
	<li>
%継承される~HTTPS状態 ~LET  %外側~設定群 の`~HTTPS状態$enV
◎
Let inheritedHTTPSState be outsideSettings’s HTTPS state.
</li>
	<li>
%継承される~referrer施策 ~LET %外側~設定群 の`~referrer施策$enV
◎
Let inheritedReferrerPolicy be outsideSettings’s referrer policy.
</li>
	<li>
%~worklet~event-loop ~LET 新たな`~event-loop$
◎
Let workletEventLoop be a newly created event loop.
</li>
	<li>
%~realm ~LET %実行~文脈 の~Realm成分の値
◎
Let realm be the value of executionContext’s Realm component.
</li>
	<li>
%~worklet大域~scope ~LET %~realm の`大域~obj$enV
◎
Let workletGlobalScope be realm’s global object.
</li>
	<li>
<p>
%設定群~obj ~LET 各種~algoが次のように定義される，新たな`環境~設定群~obj$：
◎
Let settingsObject be a new environment settings object whose algorithms are defined as follows:
</p>

		<ul>
			<li>
`~realm実行~文脈$enV
⇒
~RET %実行~文脈
◎
The realm execution context
• Return executionContext.
</li>
			<li>
`~module~map$enV<!-- 原文誤 ~module~map -->
⇒
~RET %~worklet大域~scope の`~module~map$wL
◎
The module map.
• Return workletGlobalScope’s module map.
</li>
			<li>
`担当の閲覧文脈$enV
⇒
~RET %継承される担当の閲覧文脈
◎
The responsible browsing context
• Return inheritedResponsibleBrowsingContext.
</li>
			<li>
`担当の~event-loop$enV
⇒
~RET %~worklet~event-loop
◎
The responsible event loop
• Return workletEventLoop.
</li>
			<li>
`担当の文書$enV
⇒
適用-可能でない（`担当の~event-loop$enVは、`閲覧文脈~event-loop$でない）
◎
The responsible document
• Not applicable (the responsible event loop is not a browsing context event loop).
loop).
</li>
			<li>
`~API用~URL文字~符号化方式$enV
⇒
~RET `UTF-8$
◎
The API URL character encoding
• Return UTF-8.
</li>
			<li>
`~API用~基底~URL$enV
⇒
~RET %継承される~API用~基底~URL
◎
The API base URL
• Return inheritedAPIBaseURL.
</li>
			<li>
`生成元$enV
⇒
~RET %生成元
◎
The origin
• Return origin.
</li>
			<li>
`~HTTPS状態$enV
⇒
~RET %継承される~HTTPS状態
◎
The HTTPS state
• Return inheritedHTTPSState.
</li>
			<li>
`~referrer施策$enV
⇒
~RET %継承される~referrer施策
◎
The referrer policy
• Return inheritedReferrerPolicy.
</li>
		</ul>
	</li>
	<li>
%設定群~obj の
⇒＃
`~id$enV ~SET 新たな一意かつ不透明な文字列,
`作成時の~URL$enV ~SET %継承される~API用~基底~URL,
`~target閲覧文脈$enV ~SET ~NULL ,
`作動中の~service-worker$enV ~SET ~NULL
◎
Set settingsObject’s id to a new unique opaque string, settingsObject’s creation URL to inheritedAPIBaseURL, settingsObject’s target browsing context to null, and settingsObject’s active service worker to null.
</li>
	<li>
%~realm の `HostDefined^sl ~field ~SET %設定群~obj
◎
Set realm’s [[HostDefined]] field to settingsObject.
</li>
	<li>
~RET %設定群~obj
◎
Return settingsObject.
</li>
</ol>

</div>


<p class="issue">
これを，`~workerの環境~設定群~objを設定しておく$~algoと併合する。
◎
Merge this with workers.html#set-up-a-worker-environment-settings-object
</p>



			</section>
		</section>
		<section id="worklet-section">
<h3 title="Worklet">2.2. ~worklet</h3>


<p>
`Worklet$I ~objは、
結付けられている `WorkletGlobalScope$I の中に， 1 個~以上の~module~scriptを追加する能力を供する。
~UAは、
`WorkletGlobalScope$I に登録された各~classを作成して，それらの~methodを呼出せるようになる。
◎
The Worklet object provides the capability to add module scripts into its associated WorkletGlobalScopes. The user agent can then create classes registered on the WorkletGlobalScopes and invoke their methods.
</p>


<pre class="idl">
interface `Worklet@I {
    [`NewObject$] Promise&lt;void&gt; `addModule$m(
      USVString %moduleURL,
      optional `WorkletOptions$I %options
    );
};

dictionary `WorkletOptions@I {
    `RequestCredentials$I `credentials@m = "omit";
};
</pre>


<p>
各 `Worklet$I は、次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~worklet大域~scope型@wL</dt>
	<dd>
`WorkletGlobalScope$I を`継承-$する~interface型（例： `PaintWorkletGlobalScope$I ）。
新たな `WorkletGlobalScope$I ~objを作成するときに利用される。
◎
A Worklet has a worklet global scope type. This is used for creating new WorkletGlobalScope and the type must inherit from WorkletGlobalScope.
◎
Note: As an example the worklet global scope type might be a PaintWorkletGlobalScope.
</dd>

	<dt>`~WorkletGlobalScope~list@wL</dt>
	<dd>
初期~時には空とする。
この~listは、~UAが新たな<!-- its＊ --> `WorkletGlobalScope$I ~objを作成することを選んだときに拡充される。
◎
A Worklet has a list of the worklet’s WorkletGlobalScopes. Initially this list is empty; it is populated when the user agent chooses to create its WorkletGlobalScope.
</dd>

	<dt>`~module応答~map@wL</dt>
	<dd>
`有順序~map$。
その各~entryは、~module~URLを`~fetch$応答に対応付ける。
~entryたちの順序は挿入-順になる。
この~mapへの~accessは、~thread安全になるべきある。
◎
A Worklet has a module responses map. This is a ordered map of module URLs to values that are a fetch responses. The map’s entries are ordered based on their insertion order. Access to this map should be thread-safe.
</dd>
	<dd>
この~mapは、異なる時点に作成される `WorkletGlobalScope$I が［
同じ~script~source~textの集合を包含し，挙動が同じになる
］ことを確保するために存在する。
追加の `WorkletGlobalScope$I ~objの作成は、作者からは透過的になるべきである。
◎
The module responses map exists to ensure that WorkletGlobalScopes created at different times contain the same set of script source text and have the same behaviour. The creation of additional WorkletGlobalScopes should be transparent to the author.
</dd>
	<dd class="note">
<p>注記：
実施上は、 `addModule()$m の~algoを実装する際に~thread安全な~mapを利用することは，~UAに期待されていない。
~UAは代わりに，その~methodが~callされたとき、~main~thread上で~module~graphを~fetchして，~fetchされた~source（`~module応答~map$wL内に包含される~data）を
`WorkletGlobalScope$I を有する各~threadに送信できる。
◎
Practically user agents aren’t expected to implement the following algorithm using a thread-safe map. Instead when addModule() is called user agents can fetch the module graph on the main thread, and send the fetched sources (the data contained in the module responses map) to each thread which has a WorkletGlobalScope.
</p>

<p>
~UAは，新たな `WorkletGlobalScope$I を作成したいと望む場合には、単純に［
~main~threadから~fetchされたすべての~sourceからなる~list
］を［
`WorkletGlobalScope$I を所有している~thread
］へ送信できる。
◎
If the user agent wishes to create a new WorkletGlobalScope it can simply sent the list of all fetched sources from the main thread to the thread which owns the WorkletGlobalScope.
</p>
	</dd>
</dl>

<p>
`処理待ち~task構造体@
は、次のものからなる`構造体$である：
◎
A pending tasks struct is a struct consisting of:
</p>

<ul>
	<li>
`計数@
— これは、下の~algoにより利用される。
【これ一つしかないのに構造体で包装している理由は、整数~値をとる計数を参照として渡せるようにするため。】
◎
A counter.
◎
This is used by the algorithms below.
</li>
</ul>

<div class="algorithm">

<p class="idl">
`Worklet$I ~objの
`addModule(moduleURL, options)@m
~methodの被呼出時には、次を走らせ~MUST：
◎
When the addModule(moduleURL, options) method is called on a Worklet object, the user agent must run the following steps:
</p>

<ol>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
◎
Let worklet be this Worklet.
</li>
	<li>
%外側~設定群 ~LET 此れに`関連する設定群~obj$
◎
Let outsideSettings be the relevant settings object of this.
</li>
	<li>
%~module~URL~record ~LET %moduleURL を %外側~設定群 に`相対的に構文解析-$した`結果の~URL~record$
<!-- ＊原文誤（ ~CSSSYN#css-parse-something-according-to-a-css-grammar ） -->
◎
Let moduleURLRecord be the result of parsing the moduleURL argument relative to outsideSettings.
</li>
	<li>
~IF［
%~module~URL~record ~EQ `失敗^i
］
⇒＃
`SyntaxError$E 例外で~promiseを却下する；
~RET %~promise
◎
If moduleURLRecord is failure, then reject promise with a "SyntaxError" DOMException and return promise.
</li>
	<li>
~RET %~promise
— ただし、この~algoは`並列的$に継続する
◎
Return promise, and then continue running this algorithm in parallel.
</li>
	<li>
%資格証~options ~LET %options の `credentials$m ~member
◎
Let credentialOptions be the credentials member of options.
</li>
	<li>
%~module応答~map ~LET 此れの`~module応答~map$wL
◎
Let moduleResponsesMap be worklet’s module responses map.
</li>
	<li>
%~worklet大域~scope型 ~LET 此れの`~worklet大域~scope型$wL
◎
Let workletGlobalScopeType be worklet’s worklet global scope type.
</li>
	<li>
%大域~scope~list ~LET 此れの`~WorkletGlobalScope~list$wL
◎
↓</li>
	<li>
<p>
~IF［
%大域~scope~list は空である
］：
◎
If the worklet’s WorkletGlobalScopes is empty, run the following steps:
</p>

		<ol>
			<li>
%O ~LET 次を走らせて`非同期に完了する$まで待機した結果
⇒
`~WorkletGlobalScopeを作成する$(
%~worklet大域~scope型,
%~module応答~map,
%外側~設定群,
%資格証~options
)
◎
Create a WorkletGlobalScope given workletGlobalScopeType, moduleResponsesMap, and outsideSettings.
</li>
			<li>
%大域~scope~list に %O を追加する
◎
Add the WorkletGlobalScope to worklet’s WorkletGlobalScopes.
</li>
		</ol>

<p>
~UAは、~workletの型に依存して，この時点で追加の `WorkletGlobalScope$I を作成しても~MAY。
◎
Depending on the type of worklet the user agent may create additional WorkletGlobalScopes at this time.
</p>

<p class="note">注記：
特定的には、
`css-paint-api-1$r は 複数の大域~scopeを許容する一方で，
`webaudio$r ~APIは許容しない。
◎
Note: Specifically the [css-paint-api-1] allows for multiple global scopes, while the [webaudio] API does not.
◎
↑↑Wait for this step to complete before continuing.
</p>

</li>
	<li>
%処理待ち~task構造体 ~LET 次のように初期化された，新たな`処理待ち~task構造体$
⇒
`計数$ ~SET `~WorkletGlobalScope~list$wLの長さ
◎
Let pendingTaskStruct be a new pending tasks struct with counter initialized to the length of worklet’s WorkletGlobalScopes.
</li>
	<li>
`~WorkletGlobalScope~list$wL内の~EACH( %~worklet大域~scope ) に対し
⇒
%~worklet大域~scope
【<a href="#the-event-loop">の~event-loop</a>】
上に，次を走らす`~taskを~queueする$
⇒
`~worklet~scriptを~fetchして呼出す$(
%~worklet大域~scope,
%~module~URL~record,
%~module応答~map,
%資格証~options,
%外側~設定群,
%処理待ち~task構造体,
%~promise
)
◎
For each workletGlobalScope in the worklet’s WorkletGlobalScopes, queue a task on the workletGlobalScope to fetch and invoke a worklet script given workletGlobalScope, moduleURLRecord, moduleResponsesMap, credentialOptions, outsideSettings, pendingTaskStruct, and promise.
</li>
</ol>

<p class="note">注記：
%~promise は、`~worklet~scriptを~fetchして呼出す$~algoの中で［
却下- ／ 解決-
］される。
◎
Note: The rejecting and resolving of the promise occurs within the fetch and invoke a worklet script algorithm.
</p>
</div>

<div class="algorithm">

<p>
`~worklet~scriptを~fetchして呼出す@
ときは、所与の
⇒＃
%~worklet大域~scope,
%~module~URL~record,
%~module応答~map,
%資格証~options,
%外側~設定群,
%処理待ち~task構造体,
%~promise
◎終
に対し，次の手続きを走らせ~MUST：
◎
When the user agent is to fetch and invoke a worklet script given workletGlobalScope, moduleURLRecord, moduleResponsesMap, credentialOptions, outsideSettings, pendingTaskStruct, and promise, the user agent must run the following steps:
</p>

<p class="note">注記：
この~algoは、`~worklet大域~scope実行~環境$wLの中で走ることになる。
◎
Note: This algorithm is to be run within the worklet global scope execution environment.
</p>

<ol>
	<li>
%内側~設定群 ~LET %~worklet大域~scope の`環境~設定群~obj$wL
◎
Let insideSettings be the workletGlobalScope’s associated environment settings object.
</li>
	<li>
%~script ~LET 次を走らせて`非同期に完了する$まで待機した結果
⇒
`~worklet~scriptを~fetchする$(
%~module~URL~record,
%~module応答~map,
%資格証~options,
%外側~設定群,
%内側~設定群
)
◎
Let script by the result of fetch a worklet script given moduleURLRecord, moduleResponsesMap, credentialOptions, outsideSettings, and insideSettings when it asynchronously completes.
</li>
	<li>
<p>
~IF［
%~script ~EQ ~NULL
］
⇒
%外側~設定群 の`担当の~event-loop$enV上に，次を走らす`~taskを~queueする$：
◎
If script is null, then queue a task on outsideSettings’s responsible event loop to run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
%処理待ち~task構造体 の`計数$ ~NEQ −1
］：
◎
If pendingTaskStruct’s counter is not -1, then run these steps:
</p>

				<ol>
					<li>
%処理待ち~task構造体 の`計数$ ~SET −1
◎
Set pendingTaskStruct’s counter to -1.
</li>
					<li>
`AbortError$E 例外で %~promise を却下する
◎
Reject promise with an "AbortError" DOMException.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`~module~scriptを走らす$( %~script )
◎
Run a module script given script.
</li>
	<li>
<p>
%外側~設定群 の`担当の~event-loop$enV上に，次を走らす`~taskを~queueする$：
◎
Queue a task on outsideSettings’s responsible event loop to run these steps:
</p>

		<ol>
			<li>
<p>
~IF［
%処理待ち~task構造体 の`計数$ ~NEQ −1
］：
◎
If pendingTaskStruct’s counter is not -1, then run these steps:
</p>

				<ol>
					<li>
%処理待ち~task構造体 の`計数$ ~DECBY 1
◎
Decrement pendingTaskStruct’s counter by 1.
</li>
					<li>
~IF［
%処理待ち~task構造体 の`計数$ ~EQ 0
］
⇒
%~promise を解決する
【何で解決するか述べられていない】
◎
If pendingTaskStruct’s counter is 0, then resolve promise.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>

</div>

<div class="algorithm">

<p>
`~worklet~scriptを~fetchする@
ときは、所与の
⇒＃
%~module~URL~record,
%~module応答~map,
%資格証~options,
%外側~設定群,
%内側~設定群
◎終
に対し，次を走らせ~MUST： 
◎
When the user agent is to fetch a worklet script given moduleURLRecord, moduleResponsesMap, credentialOptions, outsideSettings, and insideSettings, the user agent must run the following steps:
</p>

<p class="note">注記：
この~algoは、`~worklet大域~scope実行~環境$wLの中で走ることになる。
◎
Note: This algorithm is to be run within the worklet global scope execution environment.
</p>

<ol>
	<li>
<p>
%~fetch ~LET 次を走らす手続き
⇒
`~worker用~module~script~graphを~fetchする$(
%~module~URL~record,
%外側~設定群,
`script^l,
%資格証~options,
%内側~設定群
)
— 加えて、次に与える`~fetchを遂行する$手続きも渡す
◎
Fetch a module worker script graph given moduleURLRecord, outsideSettings, "script", credentialOptions, and insideSettings.
</p>

<p>
手続きは、所与の
( %要請 )
に対し，次を遂行する：
◎
To perform the fetch given request, perform the following steps:
</p>

		<ol>
			<li>
%~cache ~LET %~module応答~map
◎
Let cache be the moduleResponsesMap.
</li>
			<li>
%~url ~LET %要請 の`~url$rq
◎
Let url be request’s url.
</li>
			<li>
~IF［
%~cache[ %~url ] ~EQ `fetching^l
］
⇒
%~cache[ %~url ] が変化するまで待機する
◎
If cache contains an entry with key url whose value is "fetching", wait until that entry’s value changes, then proceed to the next step.
</li>
			<li>
~IF［
%~cache[ %~url ] ~NEQ ε
］
⇒
%~cache[ %~url ] を結果として，`非同期に完了する$
◎
If cache contains an entry with key url, asynchronously complete this algorithm with that entry’s value, and abort these steps.
</li>
			<li>
%~cache[ %~url ] ~SET `fetching^l
◎
Create an entry in cache with key url and value "fetching".
</li>
			<li>
%応答 ~LET 次を走らせて`非同期に完了する$まで待機した結果
⇒
%要請 を`~fetch$する
◎
Fetch request.
◎
Let response be the result of fetch when it asynchronously completes.
</li>
			<li>
%~cache[ %~url ] ~SET %応答
◎
Set the value of the entry in cache whose key is url to response, and＼
asynchronously complete this algorithm with response.
</li>
			<li>
%応答 を結果として`非同期に完了する$
◎
asynchronously complete this algorithm with response.
</li>
		</ol>
	</li>
	<li>
~RET %~fetch を遂行して，`非同期に完了する$まで待機した結果
◎
Return the result of fetch a module worker script graph when it asynchronously completes.
</li>
</ol>

</div>


<p class="note">注記：
特定的には、［
~scriptを構文解析する ／
~network越しに読込む
］のに失敗した場合，~promiseは却下されることになる。
~promiseを最初に評価する間に，~scriptが~errorを投出した場合、解決されることになる
— それが解決される値を与える~classが、正しく登録されていたなら。
<!-- as a classes＊？ -->
◎
Note: Specifically, if a script fails to parse or fails to load over the network, it will reject the promise. If the script throws an error while first evaluating the promise it will resolve as a classes may have been registered correctly.
</p>

<div class="example">

<p>
作者が `Worklet$I の中に~codeを追加するとき、その~codeは，複数の `WorkletGlobalScope$I 上で走ることにもなり得る。
例えば：
◎
When an author adds code into a Worklet the code may run against multiple WorkletGlobalScopes, for example:
</p>

<pre class="lang-javascript">
// script.js
console.log('Hello from a WorkletGlobalScope!');
</pre>


<pre class="lang-javascript">
// main.js
await CSS.paintWorklet.addModule('script.js');
</pre>

<p>
~UAは、舞台裏では， `script.js^c を 4 個の大域~scopeの中に読込んで~MAY
— その事例では、~UAの~debug用~toolは，次を~printすることになる：
◎
Behind the scenes the user agent may load the script.js into 4 global scopes, in which case the debugging tools for the user agent would print:
</p>


<pre class="lang-javascript">
[paintWorklet#1] Hello from a WorkletGlobalScope!
[paintWorklet#4] Hello from a WorkletGlobalScope!
[paintWorklet#2] Hello from a WorkletGlobalScope!
[paintWorklet#3] Hello from a WorkletGlobalScope!
</pre>

<p>
~UAが，この例の `WorkletGlobalScope$I #3 を~killして再開始することにした場合、再開始-時に，~debug用~tool内に再度
`[paintWorklet#3] Hello from a WorkletGlobalScope!^c
を~printすることになる。
◎
If the user agent decided to kill and restart a WorkletGlobalScope number 3 in this example, it would print [paintWorklet#3] Hello from a WorkletGlobalScope! again in the debugging tools when this occurs.
</p>
</div>


<p class="issue">
`WorkletGlobalScope$I の中に ~codeを宣言的に読込む能が必要。
<a href="https://github.com/w3c/css-houdini-drafts/issues/47">&lt;https://github.com/w3c/css-houdini-drafts/issues/47&gt;</a>
◎
Need ability to load code into a WorkletGlobalScope declaratively. &lt;https://github.com/w3c/css-houdini-drafts/issues/47&gt;
</p>



		</section>
		<section id="lifetime-of-the-worklet">
<h3 title="Lifetime of the Worklet">2.3. ~workletの存続期間</h3>


<p>
`Worklet$I の存続期間は、それが属する~obj
— 例えば `Window$I —
に束ねられる。
◎
The lifetime of a Worklet is tied to the object it belongs to, for example the Window.
</p>

<p>
`WorkletGlobalScope$I を継承する~interface %A を定義する仕様は：
◎
↓</p>

<ul>
	<li>
%A の存続期間を定義するべきである。
◎
The lifetime of a WorkletGlobalScope should be defined by subsequent specifications which inherit from WorkletGlobalScope.
</li>
	<li>
%A を いつでも終了できるものと定義して~MAY
— 特に、処理待ち演算が無い場合や, ［
課される制限-時間を超過するような，無限~loopや~callback
］などの異常な演算が検出された場合には。
◎
Subsequent specifications may define that a WorkletGlobalScope can be terminated at any time particularly if there are no pending operations, or detects abnormal operation such as infinite loops and callbacks exceeding imposed time limits.
</li>
</ul>


		</section>
	</section>
	<section id="security-considerations">
<h2 title="Security Considerations">3. ~security上の考慮点</h2>


<p class="issue">
~workletを~secureでない文脈にも許容するかどうか, 等々を決める必要がある
<a href="https://github.com/w3c/css-houdini-drafts/issues/92">&lt;https://github.com/w3c/css-houdini-drafts/issues/92&gt;</a>
◎
Need to decide if to allow worklets for unsecure context, etc. &lt;https://github.com/w3c/css-houdini-drafts/issues/92&gt;
</p>



	</section>
	<section class="example" id="examples">
<h2 title="Examples">4. 例</h2>

~INFORMATIVE

<p>
以下の例では、~window上で `FakeWorklet^I （“~fakeの” ~worklet ）を利用する。
◎
For these examples we’ll use a fake worklet on window.
</p>

<div><!--  class="example" -->

<pre class="idl">
partial interface Window {
  [SameObject] readonly attribute Worklet fakeWorklet1;
  [SameObject] readonly attribute Worklet fakeWorklet2;
};
</pre>


<pre class="idl">
callback Function = any (any... arguments);

[`Global$=(Worklet,FakeWorklet),Exposed=FakeWorklet]
interface FakeWorkletGlobalScope : `WorkletGlobalScope$I {
    void `registerAnArbitaryClass^m(DOMString %type, Function %classConstructor);
};
</pre>


<p>
各 `FakeWorkletGlobalScope^I は、
`登録-済み~class構築子~map@
を持つ。
◎
Each FakeWorkletGlobalScope has a map of the registered class constructors map.
</p>

<p>
`registerAnArbitaryClass(type, classConstructor)^m
~methodが~callされたとき、~UAは，`登録-済み~class構築子~map$に型 %type の %classConstructor を追加することになる。
◎
When the registerAnArbitaryClass(type, classConstructor) method is called, the user agent will add the classConstructor of type to the map of registered class constructors map.
</p>

</div>

		<section id="example-single">
<h3 title="Loading scripts into a worklet.">4.1. ~workletの中へ~scriptを読込むとき</h3>

<pre class="lang-javascript">
window.fakeWorklet1.addModule('script1.js');
window.fakeWorklet1.addModule('script2.js');

/* <span class="comment">
他からは `fakeWorklet1^c は~callされていないとするなら、次のいずれも，~scriptを読込む妥当な順序になる：
◎
Assuming no other calls to fakeWorklet1 valid script loading orderings are:
</span> */
// 1. 'script1.js', 'script2.js'
// 2. 'script2.js', 'script1.js'
</pre>



		</section>
		<section id="example-multiple">
<h3 title="Loading scripts into multiple worklets.">4.2. 複数の~workletの中へ~scriptを読込むとき</h3>


<pre class="lang-javascript">
Promise.all([
    window.fakeWorklet1.addModule('script1.js'),
    window.fakeWorklet2.addModule('script2.js')
]).then(function() {
    /* <span class="comment">
両~scriptの~codeとも読込まれたので，ここで それらに依拠する~taskを行える。
◎
Both scripts now have loaded code, can do a task which relies on this.
</span> */
});
</pre>


		</section>
		<section id="example-class">
<h3 title="Create a registered class and invoke a method.">4.3. 登録-済み~classを作成して~methodを呼出す</h3>

<pre class="lang-javascript">
/* <span class="comment">
`FakeWorkletGlobalScope^I の内側
◎
Inside FakeWorkletGlobalScope
</span> */
registerAnArbitaryClass('key', class FooClass {
    process(%arg) {
        return !%arg;
    }
});
</pre>


<p>
例として，~UAが 新たな~class~instance上で `process^m を呼出したいと求めるなら、次の手続きに従うこともできる
◎
As an example, if the user agent wants to invoke "process" on a new class instance, the user agent could follow the following steps:
</p>

<ol>
	<li>
<p>
%~worklet大域~scope ~LET 当の~fake `Worklet$I の`~WorkletGlobalScope~list$wL からの `FakeWorkletGlobalScope^I
【複数あり得るので、~UAが適切などれかを選ぶことになる。】
◎
Let workletGlobalScope be a FakeWorkletGlobalScope from the list of worklet’s WorkletGlobalScopes from the fake Worklet.
</p>

<p>
~UAは、次を行った上で，その結果を利用しても<em>よい</em>
⇒
~fake `Worklet$I を与える下で `~WorkletGlobalScopeを作成する$
◎
The user agent may also create a WorkletGlobalScope given the fake Worklet and use that.
</p>

	</li>
	<li>
%~class構築子 ~LET `登録-済み~class構築子~map$[ `key^l ]
◎
Let classCtor be the result of performing a lookup in registered class constructors map with "key" as the key.
</li>
	<li>
%~class~instance ~LET `Construct$jA( %~class構築子 )
◎
Let classInstance be the result of Construct(classCtor).
</li>
	<li>
%結果 ~LET `Invoke$jA( %~class~instance, `process^l, « `true^l » )
◎
Let result be the result of Invoke(O=classInstance, P="process", Arguments=["true"]).
</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>

		</section>
	</section>

</main></div>
