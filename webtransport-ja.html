<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>WebTransport（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
.settings-parameter,
.frame-type,
.error-code {
	font-family: sans-serif0, sans-serif;
	color: var(--K-color);
}

@supports (grid-template-columns: subgrid) and (display: contents) {

._stream-capa {
	grid-template-columns: 4em 1fr 1fr 1fr;
	min-width: 32em;
	max-width: 52em;
	tr {
		grid-template-areas:
			"能力 能力 能力 能力"
			". 定義 定義 定義"
			". 流入 流出 双方向"
		;
		> *:nth-child(1) {
			grid-area: 能力;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 定義;
		}
		> *:nth-child(3) {
			grid-area: 流入;
		}
		> *:nth-child(4) {
			grid-area: 流出;
		}
		> *:nth-child(5) {
			grid-area: 双方向;
		}
	}
}

#_session-capa {
	grid-template-columns: 4em 1fr;
	tr {
		grid-template-areas:
			"能力 能力"
			". 定義"
		;
	}
}

._wt-effect {
	grid-template-columns: 4em 1fr;
	tr {
		grid-template-areas:
			"原因 原因"
			". 効果"
		;
		> *:nth-child(1) {
			grid-area: 原因;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 効果;
		}
	}
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
case 'dw':
case 'dr':
case 'ws':
case 'mH':
case 'rs':
case 'gr':
case 'mT':
case 'mD':
case 'mR':
case 'mS':
case 'mB':
case 'mE':
case 'mG':
case 'mW':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'sl':
case 'slW':
case 'slS':
case 'slR':
case 'slB':
case 'slG':
case 'wS':
	text = `[[${key}]]`;
	break;
case 'commit':
	href1 = `https://github.com/w3c/web-share/commit/${key}`
	text = `commit`;
	break;
case 'pull':
	href1 = `https://github.com/w3c/web-share/pull/${key}`
	text = `pull`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:WebTransport
spec_date:2025-04-08
trans_update:2025-04-09
source_checked:250311
	page_state_key:
original_url:https://w3c.github.io/webtransport/
	abbr_url:WEBTRANSPORT
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
site_nav:network,security
copyright:2025,permissive
trans_1st_pub:2023-08-16


●●class_map
E:error
h:header
M:method
jv:js-value
sl:js-slot
slW:js-slot
slS:js-slot
slR:js-slot
slB:js-slot
slG:js-slot
wS:js-slot
ft:frame-type
er:error-code
sp:settings-parameter
st:status

●●tag_map
h:code
M:code
c:code
I:code
E:code
m:code
dw:code
gr:code
mB:code
mD:code
mE:code
mH:code
mR:code
mS:code
mT:code
mG:code
mW:code
mb:code
rs:code
ws:code
mbR:code
mbS:code
mbE:code
mbD:code
st:code
jv:code
sl:span
slS:span
slR:span
slB:span
slG:span
slW:span
wS:span
ft:code
er:code
sp:code
b:b
i:i
em:em
cite:cite

●●words_table1
ECMA262:http://www.ecma-international.org/ecma-262/6.0/index.html
ECMA262:https://tc39.es/ecma262/
WT-HTTP3:webtrans-http3-ja.html
	WT-HTTP3:https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3/
WT-HTTP2:https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http2/
WT-OVERVIEW:webtrans-overview-ja.html
	https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-overview
HTTPdatagram:http-datagram-ja.html
	rfc9297
●●words_table

	●名称／略称
QUIC:
UDP:
TCP:
TLS:
HTTP3:HTTP/3
HTTP2:HTTP/2
ALPN:
ACK:
WebTransport:
WebRTC:
WebSocket:
	WebSockets
PKI:
SHA-256:
RTT:
DER:
UNIX:
WEBTRANS:
WebIDL:
ECMAScript:
RSA:
	X.509v3
	^en:Certificate
	^en:Subject Public Key
	^en:Subject Public Key Info
	^en:TLS CertificateVerify
	^en:ECDSA with the secp256r1 (NIST P-256) named group
	^en:IFFEs

	●transport／metwork
CONNECT:
FIN:
datagram::::データグラム
packet::::パケット
pool:
	~pool法:pooling
close:
	~close時の:closed
	~closeする際の:closing
open:
	~open法:opening
route::::ルート
	~route可能:routable
	^en:ack
	承認, ^en:acknowledgment
handshake::::ハンドシェイク
transactional:
運ぶ:carryする:~
輻輳:congestion::~
外方:outbound::~::アウトバウンド
ticket::::チケット
二重化:duplex::~
交換:exchange:~
端点:endpoint::~::エンドポイント
	相手の端点:peer
経路:path::~
clean:
draining:
認知-:acknowledge:~
contact:
受領:receipt::~
	受信される:reception
窓:window::~::ウインドウ
credit:
不依拠-:unrely:~
	不依拠-可能:unreliable
	依拠-可能:reliable
	依拠-可能でない:unreliable
payload::::ペイロード

	送信者~側:sender-side
	接続:the first hop
	~frame法:framing
	~cache法:caching
	^M:CONNECT
	^sp:SETTINGS_ENABLE_WEBTRANPORT
	^sp:H3_DATAGRAM
	$ft:SETTINGS
	^ft:CONNECTION_CLOSE
	`STOP_SENDING^ft:stop_sending
	$ft:STOP_SENDING
	$ft:RESET_STREAM
	`RESET_STREAM^ft:reset

	●stream
一方向:unidirectional::~
	一方向:uni-directional
	一方通行:one-way
双方向:bidirectional::~
	双方向:bi-directional
流入:incoming::~
流出:outgoing::~
BYOB:
限界水位:high water mark::~
chunk::::チャンク
sink::::シンク
EOF:
背圧:backpressure::~
消費器:consumer::~
pipe::::パイプ
書込n:write::書き込み
書込んだ:writeした::書き込んだ
書込んで:writeして::書き込んで
書込む:writeする::書き込む
書込まれ:writeされ::書き込まれ
書込器:writer::書き込み器
可書:writable::~
可読:readable::~
	再-伝送:retransmission
	~stream用の:streaming

	●処理
同型:isomorphic::~
片付け:cleanup::~
片付ける:clean upする::~
	片付ける:cleanup
unload:
逆直列化:deserialization::~::逆シリアル化
退行-:degrade:~
決着-:settle:~
露呈-:reveal::露わに
待受ける:awaitする:待ち受ける
待受けて:awaitして:待ち受けて
消費器:consumer::~
割振る:allocateする::割り振る
milli::::ミリ
rate::::レート
overhead::::オーバーヘッド
優先度化:prioritization:優先度付け
優先-:prioritize:~
優先度:priority:~
統計:stats::~
	統計:statistics
上品:graceful:~
中途で:abruptに:~
正常:normal:~
直列形:serialized::~::シリアル形
公平:fair:~
	公平さ:fairness
分合う:divideする:分け合う
処理待ち:pending:~
集めて:gatherして:~
集める:gatherする:~
集めら:gatherさ:~
単調増加-:monotonic に increase:~
平均:mean:~
見積もら:estimateさ:~
見積もり:estimate:~
調律-:tune::~
標本:sample:~
期間:period:~
変動:variation:~
後回-:starve::後回しに
喪失-:lose:~
出生-:originate:~
overflow::::オーバーフロー
real-time:real time:::リアルタイム
deadlock::::デッドロック
割振り:allocation:割り振り
支続-:sustain:維持
commit:

	渡-:pass
	~milli秒数:milliseconds
	~milli秒:ms
	時点で:at the time of
	時点:point at which
	この時点ですでに:previously
	それまでに:previously
	回ごとに:at a time
	秒あたりの:per second
	の直前まで限り:up to, but not including
	高いものほど先に:ahead of 〜 lower
	高いものほど:higher
	より高い:higher
	処理-可能:processable
	前後して／前後する:interleave
	他と前後され:interleave
	順序どおりでない:out-of-order
	順序どおり:in-order
	~errorしない:un-errored

	●変数
in-flight:

	%~FINを受信したか:hasReceivedFIN
	%~buffer:buffer
	%~byte列:bytes
	%符号化した証明書:cert
	%~chunk:chunk
	%~client:client
	%~close時の~promise:closed
	-:closeAlgorithm
	%~close報:closeInfo
	%~code:code
	%~data:data
	%~datagram群:datagrams
	-:pullDatagramsAlgorithm
	-:writeDatagramsAlgorithm
	%所要時間:duration
	%~error:error
	%~hash:hash
	%~hash値:hashValue
	%~hash群:hashes
	%~hash~source:-
	%~HTTP~error~code:httpErrorCode
	%~network区分~key:networkPartitionKey
	%~offset:offset
	-:allowPooling
	%~protocol群:protocols
	%~promise:promise
	%~promise:p
	-:pullAlgorithm
	%~queue:queue
	%~server証明書~hash群:serverCertificateHashes
	%~session:session
	%~stream:stream
	%~stream~ID:streamId
	%~transport:transport
	%不依拠-可能が要求されるか:requireUnreliable
	%~view:view
	-:pullUnidirectionalStreamAlgorithm
	-:abortAlgorithm
	%事由:reason
	%事由~byte列:reasonBytes
	%事由~文字列:reasonString
	%値:value
	%内部~stream:internalStream
	%処理待ち演算:pendingOperation
	%参照~hash:referenceHash
	-:pullBidirectionalStreamAlgorithm
	-:cancelAlgorithm
	%受信-~stream群:receiveStreams
	%可書~stream:writable
	%可読~stream:readable
	%専用か:dedicated
	%手続き:steps
	%接続:connection
	%新たな接続:newConnection
	%時刻印:timestamp
	-:writeAlgorithm
	%最大-~byte数:maxBytes
	%maxDatagramSize
	%最大-~size:maxSize
	%基底~URL:baseURL
	%構文解析した~URL:parsedURL
	%流入~datagram群:incomingDatagrams
	%流入~一方向~stream群:incomingUnidirectionalStreams
	%流入~双方向~stream群:incomingBidirectionalStreams
	%流出~datagram可書~stream群:outgoingDatagramWritables
	%準備済み時の~promise:ready
	%生成元:origin
	%統計:stats
	%要素~size:elementSize
	%要請:request
	%設定群:settings
	%証明書:certificate
	%長さ:read
	%輻輳~制御:congestionControl
	%送信-~stream:sendStream
	%送信-~stream群:sendStreams
	%送信-順序:sendOrder
	%送信-順序:-
	%送信-~group:sendGroup
	%送信-~group:-
	%除去する個数:toBeRemoved
	%~session
	%直列形:serialized
	%~stream群:streams
	%中止-通達:abortSignal
	%可用になるまで待機するか:waitUntilAvailable
	%書込n要請~群:writeRequests
	%中止する要請~群:requestsToAbort
	%書込器:writer
	%~in-flight書込n要請:inFlightWriteRequest
	%不可分か:atomic
	%見越される同時並行な流入~一方向~stream数:anticipatedConcurrentIncomingUnidirectionalStreams
	%見越される同時並行な流入~双方向~stream数:anticipatedConcurrentIncomingBidirectionalStreams

	●保安
証明書:certificate::~
廃止:revocation::~
失効n:expiration::失効
失効:expiry::失効
秘密鍵:private key::~
公開鍵:public key::~
	公開鍵:public-key
鍵:key::~
交替-:rotate::~
交替:rotation::~
hash::::ハッシュ
区分:partition::~
暗号用:cryptographic::~
弱体化:compromise::~
弱体化-:compromise::~
弱い:weakな:~
耐性:resistance::~
能動的:active::~
受動的:passive::~
野放図:unsanctioned:~
散発的:sporadic:~
容量:capacity::~
致命的:fatal:~
確認-:confirm:~
敵対者:adversary:~
防護策:safeguards:~
支給-:provision:~
機密性:confidentiality::~
認証-:authenticate::~
認証:authentication::~
観測者:observer::~
相関-:correlate::~
迂回-:bypass:~
走査-:scan:~
開示:disclosure:~
持続性:persistence:~
持続的:persistent:~
期限:limit:~
活動:activity:~
利用度:usage:~
推定-:infer:~
立地:vantage point:~
人々:people:~
識別情報:identity:~
悪影響:adverse effect:~
抜道:interstitial:抜け道
濫用-:abuse:~

	^en:second-preimage resistance
	他と競わない:uncontested
	^en:contested
	^en:contact
	`阻止される^i:<b>"Blocked"</b>
	`阻止される^i:blocked
	繋がり:connection
	無効~化-:invalidation
	無効~化:invalidate
	隠せない:cannot be hidden
	抗する:against

	●仕様
運用者:operator::~
収容-:accomodate:~
安定的:stable:~
計量:metrics:~
順応-:adapt:~
balance::::バランス
難題:challenging:~
確証:confidence:~
準備的:preliminary:~
課して:imposeして:~
課す:imposeする:~
責務:responsibility:~
	責務がある:responsible
組織化用の:organizational:~
見越す:anticipateする:~
見越した:anticipateした:~
見越され:anticipateされ:~
拙い:poorな:~
polyfill:
総意:consensus:~

	きちんと:wellに
	重要なこととして:It is important to
	できるようにする:lets
	とは限らない:necessarily
	必ず:make sure
	みなされ:regard
	用意がある／ない:willing to
	以下では〜と称される:we will refer
	場合もある:may
	アリでない:impossible
	〜が選んだ:choice
	自身が選んだ:chosen
	選ぶ:chooseする
	知る:know
	足る:sufficient
	関わらず:regardless
	当の:in-question
	共に:in conjunction with
	見込みが高い:likely
	今後:going forward
	よって:hence
	に応じて:negation of
	触れない:touch
	足るまで:sufficiently
	行き渡るまで:being rolled out
	書いて:writing
	モノトスル:SHALL
	注記-:note
	実質:net
	原因:cause
	事実:fact
	気を配る:pay attention
	〜得る:potentially
	その帰結として:consequently
	~~説明:illustrate
	主な:main
	~~限定的:niche
	知れる:learn
	ただし:except
	限りにおいて:provided
	が、:in spite of
	^en:the chairs
	以前は 〜 していた:used to

	●言い換え
	^en:first-strong
	^en:quic-transport
	伴われていた:was accompanied
	最小~化:minimize
	から今を表現している時刻印まで 〜 ~milli秒数:milliseconds have passed since
	〜を指示する:An indicator of progress on
	無いに等しい:minimal
	整数:number
	-:opts
	-:enum
	-:a series of steps
	`smoothed_rtt^c ^en:smoothed
	~buffer化:buffering
	この数は、決して減少しない:This number can only increase.
	~GT:higher
	作動中でない:inactive
	~GTE 1:rounded down
	応用:app
	〜の直前まで:sequential
	~promise:Promise
	~dequeueする:Remove the first element
	等しく:as equals
	わたる:spread across
	設定子を通して:through assignment
	~data:numbers
	-:numberspace
	に限り:exclusively
	包含されない:absent
	その妥当~性:to be valid
	〜しない所まで:but not to the point of
	満たさない:fail to match
	連列／~list:〜 array
	解決されたなら:pending
	成す:comprise
	~IN { 1 〜 512 }:0 or exceeding 512
	省略可能な:optionally

	●未分類
throughput::::スループット
virtual:
適時性:timeliness:~
contact:
為す:makeする:~
為せる:makeできる:~
epoch:
固定的:fixed:~
運ぶ:carryする:~
到着-:arrive:~
満足-:satisfy:~
上界:upper bound:~
上限:upper limit:~
天井:ceiling:上限
枯渇:exhaustion:~
番号:number:~
素早く:quickに:~
machine::::マシン
欠如:lack:~
確立:establishment:~
代用-:substitute:~
疑似-:pseudo-:~
超過-:exceed:~
側:side:~
帯域内:in-band::~
帯域幅:bandwidth::~
bottleneck::::ボトルネック
時計:clock:~
	ずれ:skew
短命:ephemeral:~
	短命:ephemeral or short-lived
	その場限りの:short-lived
所蔵-:possess:~
負荷:load:~
	負荷が軽い:lightly loaded
付され:attachされ:~
後続に:subsequentに:後続して
重複-:duplicate:~
集成-:aggregate:~
近過去:recent:~
獲得-:acquire:~
不可分:atomic::~
	不可分でない:non-atomic
	不可分~性:atomicity
不可分的:transactional::~

	NaN:
	∞:
	現在に:currently
	短い／短く／低い／より低く:low
	なるべく下げる:lower
	大きい:larger
	総-~total
	以前の:previous
	それまでの:previous
	2 週間:two weeks
	場を占めて:taking place
	等しく:equally
	存在しない:non-existing
	今や／今:now
	残りの:remaining
	長期的:long-term
	各部:parts
	〜以下:inclusive
	旧くなった:being older
	何~byte:how many
	長く:high
	細かく:closely
	間／ ↔ :between
	不在:absent
	十分:enough
	近い:close to
	これまでに:so far
	高める:increase
	まとめて:at once
	埋まる:filling up
	数えら:countさ
	相互に:and vice versa
	まずまずの:decent
	危うく:jeopardizing
	入る:enter
	来ている:coming
	含まな:include
	含む:include
	-:maximal
	いつでも:at any time
	し続ける:keeping
	小さ過ぎる:too small
	一度で:entirely
	全体を:entirety
	に~~後続して:behind
	すべて:everything
	時点:moment
	一片:piece
	少ない:less

●●original_id_map
	webtransportdatagramduplexstream-create:webtransportdatagramduplexstream-create-readable
	webtransportdatagramduplexstream-create:webtransportdatagramduplexstream-create-writable

●●mdn_urls
webtransport:API/WebTransport
webtransportdatagramduplexstream:API/WebTransportDatagramDuplexStream
webtransportbidirectionalstream:API/WebTransportBidirectionalStream
webtransportreceivestream:API/WebTransportReceiveStream
webtransporterror:API/WebTransportError
	webtransportsendstream:API/WebTransportSendStream

●●link_map

	●IDL
Exposed:~WEBIDLjs#Exposed
SecureContext:~WEBIDLjs#SecureContext
EnforceRange:~WEBIDLjs#EnforceRange
Serializable:~HTMLcloning#serializable
Transferable:~HTMLcloning#transferable
Clamp:~WEBIDL#Clamp

undefined:~WEBIDL#idl-undefined
long long:~WEBIDL#idl-long-long
unrestricted double:~WEBIDL#idl-unrestricted-double
c.unrestricted double:~WEBIDL#idl-unrestricted-double
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
unsigned short:~WEBIDL#idl-unsigned-short
boolean:~WEBIDL#idl-boolean
USVString:~WEBIDL#idl-USVString
sequence:~WEBIDL#idl-sequence
any:~WEBIDL#idl-any
DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
DOMString:~WEBIDL#idl-DOMString
Promise:~WEBIDL#idl-promise

I.Uint8Array:~WEBIDL#idl-Uint8Array
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.DataView:~WEBIDL#idl-DataView
I.BufferSource:~WEBIDL#BufferSource

E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror
E.QuotaExceededError:~WEBIDL#quotaexceedederror
E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.DOMException:~WEBIDL#idl-DOMException
I.WebTransport:#webtransport
I.WebTransportBidirectionalStream:#webtransportbidirectionalstream
I.WebTransportCloseInfo:#dictdef-webtransportcloseinfo
I.WebTransportCongestionControl:#enumdef-webtransportcongestioncontrol
I.WebTransportConnectionStats:#dictdef-webtransportconnectionstats
I.WebTransportDatagramDuplexStream:#webtransportdatagramduplexstream
I.WebTransportDatagramStats:#dictdef-webtransportdatagramstats
I.WebTransportDatagramsWritable:#webtransportdatagramswritable
I.WebTransportError:#webtransporterror
I.WebTransportErrorOptions:#dictdef-webtransporterroroptions
I.WebTransportErrorSource:#enumdef-webtransporterrorsource
I.WebTransportHash:#dictdef-webtransporthash
I.WebTransportOptions:#dictdef-webtransportoptions
I.WebTransportReceiveStream:#webtransportreceivestream
I.WebTransportReceiveStreamStats:#dictdef-webtransportreceivestreamstats
I.WebTransportReliabilityMode:#enumdef-webtransportreliabilitymode
I.WebTransportSendGroup:#webtransportsendgroup
I.WebTransportSendOptions:#dictdef-webtransportsendoptions
I.WebTransportSendStream:#webtransportsendstream
I.WebTransportSendStreamOptions:#dictdef-webtransportsendstreamoptions
I.WebTransportSendStreamStats:#dictdef-webtransportsendstreamstats
I.WebTransportWriter:#webtransportwriter
I.ReadableStream:~STREAMS#readablestream
I.WritableStream:~STREAMS#writablestream
I.WritableStreamDefaultWriter:~STREAMS#writablestreamdefaultwriter
I.TextDecoderStream:~ENCODING#textdecoderstream
I.TextEncoderStream:~ENCODING#textencoderstream

	●#dom-

mD.createWritable:#dom-webtransportdatagramduplexstream-createwritable
mD.readable:#dom-webtransportdatagramduplexstream-readable
mD.incomingMaxAge:#dom-webtransportdatagramduplexstream-incomingmaxage
mD.maxDatagramSize:#dom-webtransportdatagramduplexstream-maxdatagramsize
mD.outgoingMaxAge:#dom-webtransportdatagramduplexstream-outgoingmaxage
mD.incomingHighWaterMark:#dom-webtransportdatagramduplexstream-incominghighwatermark
mD.outgoingHighWaterMark:#dom-webtransportdatagramduplexstream-outgoinghighwatermark

	%url:#dom-webtransport-webtransport-url-options-url
	%options:#dom-webtransport-webtransport-url-options-options
	%closeInfo:#dom-webtransport-close-closeinfo-closeinfo
	%options:#dom-webtransport-createbidirectionalstream-options-options
	%options:#dom-webtransport-createunidirectionalstream-options-options
	%options:#dom-webtransportdatagramduplexstream-createwritable-options-options

l.pending:#dom-webtransportreliabilitymode-pending
l.reliable-only:#dom-webtransportreliabilitymode-reliable-only
l.supports-unreliable:#dom-webtransportreliabilitymode-supports-unreliable

m.new WebTransport:#dom-webtransport-webtransport
	constructor:#dom-webtransport-webtransport
mT.ready:#dom-webtransport-ready
mT.closed:#dom-webtransport-closed
mT.draining:#dom-webtransport-draining
mT.datagrams:#dom-webtransport-datagrams
mT.incomingBidirectionalStreams:#dom-webtransport-incomingbidirectionalstreams
mT.incomingUnidirectionalStreams:#dom-webtransport-incomingunidirectionalstreams
mT.reliability:#dom-webtransport-reliability
mT.congestionControl:#dom-webtransport-congestioncontrol
mT.anticipatedConcurrentIncomingUnidirectionalStreams:#dom-webtransport-anticipatedconcurrentincomingunidirectionalstreams
mT.anticipatedConcurrentIncomingBidirectionalStreams:#dom-webtransport-anticipatedconcurrentincomingbidirectionalstreams
mT.protocol:#dom-webtransport-protocol
mT.close:#dom-webtransport-close
mT.getStats:#dom-webtransport-getstats
mT.createBidirectionalStream:#dom-webtransport-createbidirectionalstream
mT.createUnidirectionalStream:#dom-webtransport-createunidirectionalstream
mT.createSendGroup:#dom-webtransport-createsendgroup
mT.supportsReliableOnly:#dom-webtransport-dom-webtransport-supportsreliableonly

mH.algorithm:#dom-webtransporthash-algorithm
mH.value:#dom-webtransporthash-value

mG.getStats:#dom-webtransportsendgroup-getstats

l.default:#dom-webtransportcongestioncontrol-default
l.throughput:#dom-webtransportcongestioncontrol-throughput
l.low-latency:#dom-webtransportcongestioncontrol-low-latency

mb.allowPooling:#dom-webtransportoptions-allowpooling
mb.requireUnreliable:#dom-webtransportoptions-requireunreliable
mb.serverCertificateHashes:#dom-webtransportoptions-servercertificatehashes
mb.congestionControl:#dom-webtransportoptions-congestioncontrol
mb.anticipatedConcurrentIncomingUnidirectionalStreams:#dom-webtransportoptions-anticipatedconcurrentincomingunidirectionalstreams
mb.anticipatedConcurrentIncomingBidirectionalStreams:#dom-webtransportoptions-anticipatedconcurrentincomingbidirectionalstreams
mb.protocols:#dom-webtransportoptions-protocols
mb.sendGroup:#dom-webtransportsendoptions-sendgroup
mb.waitUntilAvailable:#dom-webtransportsendstreamoptions-waituntilavailable

mb.closeCode:#dom-webtransportcloseinfo-closecode
mb.reason:#dom-webtransportcloseinfo-reason

mb.sendOrder:#dom-webtransportsendoptions-sendorder

mb.datagrams:#dom-webtransportconnectionstats-datagrams
mb.timestamp:#dom-webtransportconnectionstats-timestamp
mb.bytesSent:#dom-webtransportconnectionstats-bytessent
mb.packetsSent:#dom-webtransportconnectionstats-packetssent
mb.bytesLost:#dom-webtransportconnectionstats-byteslost
mb.packetsLost:#dom-webtransportconnectionstats-packetslost
mb.numOutgoingStreamsCreated:#dom-webtransportconnectionstats-numoutgoingstreamscreated
mb.numIncomingStreamsCreated:#dom-webtransportconnectionstats-numincomingstreamscreated
mb.bytesReceived:#dom-webtransportconnectionstats-bytesreceived
mb.packetsReceived:#dom-webtransportconnectionstats-packetsreceived
mb.smoothedRtt:#dom-webtransportconnectionstats-smoothedrtt
mb.rttVariation:#dom-webtransportconnectionstats-rttvariation
mb.minRtt:#dom-webtransportconnectionstats-minrtt
mb.estimatedSendRate:#dom-webtransportconnectionstats-estimatedsendrate
mb.atSendCapacity:#dom-webtransportconnectionstats-atsendcapacity

mbD.timestamp:#dom-webtransportdatagramstats-timestamp
mbD.expiredIncoming:#dom-webtransportdatagramstats-expiredincoming
mbD.expiredOutgoing:#dom-webtransportdatagramstats-expiredoutgoing
mbD.droppedIncoming:#dom-webtransportdatagramstats-droppedincoming
mbD.lostOutgoing:#dom-webtransportdatagramstats-lostoutgoing

mS.sendGroup:#dom-webtransportsendstream-sendgroup
mS.sendOrder:#dom-webtransportsendstream-sendorder
mS.getStats:#dom-webtransportsendstream-getstats
mS.getWriter:#dom-webtransportsendstream-getwriter

mbS.timestamp:#dom-webtransportsendstreamstats-timestamp
mbS.bytesWritten:#dom-webtransportsendstreamstats-byteswritten
mbS.bytesSent:#dom-webtransportsendstreamstats-bytessent
mbS.bytesAcknowledged:#dom-webtransportsendstreamstats-bytesacknowledged

mR.getStats:#dom-webtransportreceivestream-getstats

mW.sendGroup:#dom-webtransportdatagramswritable-sendgroup
mW.sendOrder:#dom-webtransportdatagramswritable-sendorder

mbR.timestamp:#dom-webtransportreceivestreamstats-timestamp
mbR.bytesReceived:#dom-webtransportreceivestreamstats-bytesreceived
mbR.bytesRead:#dom-webtransportreceivestreamstats-bytesread

mB.readable:#dom-webtransportbidirectionalstream-readable
mB.writable:#dom-webtransportbidirectionalstream-writable

	%message:#dom-webtransporterror-webtransporterror-message-options-message
	%options:#dom-webtransporterror-webtransporterror-message-options-options

l.stream:#dom-webtransporterrorsource-stream
l.session:#dom-webtransporterrorsource-session

m.new WebTransportError:#dom-webtransporterror-webtransporterror
	constructor:#dom-webtransporterror-webtransporterror
mE.source:#dom-webtransporterror-source
mE.streamErrorCode:#dom-webtransporterror-streamerrorcode
mbE.source:#dom-webtransporterroroptions-source
mbE.streamErrorCode:#dom-webtransporterroroptions-streamerrorcode

gr.cancel:~STREAMS#generic-reader-cancel
dr.read:~STREAMS#default-reader-read
dw.atomicWrite:#dom-webtransportwriter-atomicwrite
dw.abort:~STREAMS#default-writer-abort
dw.close:~STREAMS#default-writer-close
dw.write:~STREAMS#default-writer-write
rs.cancel:~STREAMS#rs-cancel
ws.close:~STREAMS#ws-close
ws.abort:~STREAMS#ws-abort
ws.getWriter:~STREAMS#ws-get-writer
m.new WritableStreamDefaultWriter:~STREAMS#default-writer-constructor

	＠~WEBIDL#dom-domexception-code
	＠~STREAMS#default-writer-ready

M.CONNECT:~HTTPsem#CONNECT

	●sl
sl.Readable:#dom-webtransportdatagramduplexstream-readable-slot
sl.Writables:#dom-webtransportdatagramduplexstream-writables-slot
sl.IncomingDatagramsQueue:#dom-webtransportdatagramduplexstream-incomingdatagramsqueue-slot
sl.IncomingDatagramsPullPromise:#dom-webtransportdatagramduplexstream-incomingdatagramspullpromise-slot
sl.IncomingDatagramsHighWaterMark:#dom-webtransportdatagramduplexstream-incomingdatagramshighwatermark-slot
sl.IncomingDatagramsExpirationDuration:#dom-webtransportdatagramduplexstream-incomingdatagramsexpirationduration-slot
sl.OutgoingDatagramsHighWaterMark:#dom-webtransportdatagramduplexstream-outgoingdatagramshighwatermark-slot
sl.OutgoingDatagramsExpirationDuration:#dom-webtransportdatagramduplexstream-outgoingdatagramsexpirationduration-slot
sl.OutgoingMaxDatagramSize:#dom-webtransportdatagramduplexstream-outgoingmaxdatagramsize-slot

sl.SendStreams:#dom-webtransport-sendstreams-slot
sl.ReceiveStreams:#dom-webtransport-receivestreams-slot
sl.IncomingBidirectionalStreams:#dom-webtransport-incomingbidirectionalstreams-slot
sl.IncomingUnidirectionalStreams:#dom-webtransport-incomingunidirectionalstreams-slot
sl.State:#dom-webtransport-state-slot
sl.Ready:#dom-webtransport-ready-slot
sl.Reliability:#dom-webtransport-reliability-slot
sl.CongestionControl:#dom-webtransport-congestioncontrol-slot
sl.Closed:#dom-webtransport-closed-slot
sl.Protocol:#dom-webtransport-protocol-slot
sl.Draining:#dom-webtransport-draining-slot
sl.Datagrams:#dom-webtransport-datagrams-slot
sl.Session:#dom-webtransport-session-slot
sl.AnticipatedConcurrentIncomingUnidirectionalStreams:#dom-webtransport-anticipatedconcurrentincomingunidirectionalstreams-slot
sl.AnticipatedConcurrentIncomingBidirectionalStreams:#dom-webtransport-anticipatedconcurrentincomingbidirectionalstreams-slot

slW.OutgoingDatagramsQueue:#dom-webtransportdatagramswritable-outgoingdatagramsqueue-slot
slW.Transport:#dom-webtransportdatagramswritable-transport-slot
slW.SendGroup:#dom-webtransportdatagramswritable-sendgroup-slot
slW.SendOrder:#dom-webtransportdatagramswritable-sendorder-slot

slS.InternalStream:#dom-webtransportsendstream-internalstream-slot
slS.PendingOperation:#dom-webtransportsendstream-pendingoperation-slot
slS.Transport:#dom-webtransportsendstream-transport-slot
slS.SendGroup:#dom-webtransportsendstream-sendgroup-slot
slS.SendOrder:#dom-webtransportsendstream-sendorder-slot
slS.AtomicWriteRequests:#dom-webtransportsendstream-atomicwriterequests-slot

slR.InternalStream:#dom-webtransportreceivestream-internalstream-slot
slR.Transport:#dom-webtransportreceivestream-transport-slot

slB.Readable:#dom-webtransportbidirectionalstream-readable-slot
slB.Writable:#dom-webtransportbidirectionalstream-writable-slot
slB.Transport:#dom-webtransportbidirectionalstream-transport-slot

slG.Transport:#dom-webtransportsendgroup-transport-slot

sl.Source:#dom-webtransporterror-source-slot
sl.StreamErrorCode:#dom-webtransporterror-streamerrorcode-slot

wS.inFlightWriteRequest:~STREAMS#writablestream-inflightwriterequest
wS.writeRequests:~STREAMS#writablestream-writerequests

	●code 他
ft.DRAIN_WEBTRANSPORT_SESSION:#session-signal-drain_webtransport_session
ft.GOAWAY:#session-signal-goaway
ft.STOP_SENDING:#stream-signal-stop_sending
ft.RESET_STREAM:#stream-signal-reset_stream
ft.SETTINGS:~HTTPv3#frame-settings

h.Origin:~FETCH#http-origin
h.WT-Available-Protocols:~WT-HTTP3#field-wt-available-protocol
h.WT-Protocol:~WT-HTTP3#field-wt-protocol

st.2xx:~HTTPsem#status.2xx


	●用語
下層~接続:#underlying-connection
~WebTransport~stream:#protocol-webtransport-stream
~WebTransport~session:#protocol-webtransport-session
~datagramを送信する:#session-send-a-datagram
~datagramを受信する:#session-receive-a-datagram
	available incoming datagrams:#session-receive-a-datagram
流出~一方向~streamを作成する:#session-create-an-outgoing-unidirectional-stream
双方向~streamを作成する:#session-create-a-bidirectional-stream
流入~一方向~streamを受信する:#session-receive-an-incoming-unidirectional-stream
	available incoming unidirectional stream:#session-receive-an-incoming-unidirectional-stream
~HTTP越しの~WebTransportを初期化する:#initialize-webtransport-over-http
双方向~streamを受信する:#session-receive-a-bidirectional-stream
	available incoming bidirectional stream:#session-receive-a-bidirectional-stream
~WebTransport~sessionを確立する:#session-establish
	＠#session-establish
~CONNECT~stream:#connect-stream
~WebTransport~sessionを終了する:#session-terminate
~draining:#session-draining
終了され:#session-terminated
流入~一方向:#stream-incoming-unidirectional
流出~一方向:#stream-outgoing-unidirectional
双方向:#stream-bidirectional
WT.送信-:#stream-send
WT.送信する:#stream-send
WT.受信-:#stream-receive
WT.受信する:#stream-receive
	read:#stream-receive
	received:#stream-receive
WT.送信を停止させる:#stream-send-stop_sending
	STOP_SENDING を送信する:#stream-send-stop_sending
WT.設定し直す:#stream-reset
	RESET_STREAM を送信する:#stream-reset
	RESET.送信する:#stream-reset
~flow制御:#stream-signal-flow-control

DW.作成する:#webtransportdatagramswritable-create
DPS.作成する:#webtransportdatagramduplexstream-create
	%readable:#webtransportdatagramduplexstream-create-readable
	%writable:#webtransportdatagramduplexstream-create-writable
TSG.作成する:#webtransportsendgroup-create
TW.作成する:#webtransportwriter-create

~datagram群を~pullする:#pulldatagrams
~datagram群を受信する:#receivedatagrams
~datagram群を書込む:#writedatagrams
~datagram群を送信する:#senddatagrams
双方向~streamを~pullする:#pullbidirectionalstream
一方向~streamを~pullする:#pullunidirectionalstream
~WebTransportを片付ける:#webtransport-cleanup
~network~taskを~queueする:#webtransport-queue-a-network-task
文脈を片付ける手続き:#context-cleanup-steps
証明書~hashを算出する:#compute-a-certificate-hash
証明書~hashを検証yする:#verify-a-certificate-hash
~custom証明書~要件:#custom-certificate-requirements
許容される公開鍵~algo:#allowed-public-key-algorithms
厳密な順序付け:#strict-ordering
		strictly ordered:#strict-ordering
wtS.作成する:#webtransportsendstream-create
wtS.書込む:#webtransportsendstream-write
wtS.~closeする:#webtransportsendstream-close
wtS.中止する:#webtransportsendstream-abort
		aborting:#webtransportsendstream-abort
wtS.すべての不可分な書込n要請を中止する:#webtransportsendstream-abort-all-atomic-write-requests

wtR.作成する:#webtransportreceivestream-create
wtR.~byte列を~pullする:#webtransportreceivestream-pull-bytes
wtR.取消す:#webtransportreceivestream-cancel
wtB.作成する:#bidirectionalstream-create

送信-~group:#grouped
	＠#ungrouped
~protocol名:#protocol-names
送信-順序の規則:#send-order-rules

~WebTransport用の例外を作成する:#_create-exception-for-webtransport

	●用語（外部
依拠-可能:~WT-OVERVIEW#reliable
不依拠-可能:~WT-OVERVIEW#unreliable
	＠~WT-HTTP3#subprotocol-negotiation
	~WT-HTTP3#section-3.4
	＠~WT-OVERVIEW#application-protocol-negotiation
	~WT-OVERVIEW#section-3.1

実装定義:~INFRA#implementation-defined
ときは中止する:~INFRA#abort-when
中止されたときは:~INFRA#if-aborted
~byte列:~INFRA#byte-sequence
符号単位:~INFRA#code-unit
	符号単位~接頭辞:~INFRA#code-unit-prefix
~queue:~INFRA#queue
~dequeueする:~INFRA#queue-dequeue
~enqueueする:~INFRA#queue-enqueue
~scalar値~文字列に変換する:~INFRA#javascript-string-convert
同型に符号化する:~INFRA#isomorphic-encode
byte.長さ:~INFRA#byte-sequence-length
有順序~集合:~INFRA#ordered-set
~ASCII大小無視:~INFRA#ascii-case-insensitive
set.付加する:~INFRA#set-append
~list:~INFRA#list
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
~size:~INFRA#list-size
空にする:~INFRA#list-empty

所与の値:~WEBIDL#the-given-value
充足-時:~WEBIDLjs#upon-fulfillment
却下-時:~WEBIDLjs#upon-rejection
新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決される~promise:~WEBIDLjs#a-promise-resolved-with
~promiseに反応する:~WEBIDLjs#dfn-perform-steps-once-promise-is-settled
	:~ECMA262#sec-promise-objects

BS.下層~buffer:~WEBIDLjs#buffersource-underlying-buffer
BS.~byte長さ:~WEBIDLjs#buffersource-byte-length
配列~bufferの中へ~byte列を書込む:~WEBIDLjs#arraybuffer-write
例外を作成する:~WEBIDL#dfn-create-exception
eX.~message:~WEBIDL#domexception-message
eX.名前:~WEBIDL#domexception-name
	コレ:~WEBIDL#this
新たな~obj:~WEBIDLjs#new
	~THROW:~WEBIDL#dfn-throw
保持された~byte列の複製を取得する:~WEBIDLjs#dfn-get-buffer-source-copy
~buffer~sourceを~byte列から作成する:~WEBIDLjs#_buffersource-create

要請:~FETCH#concept-request
rq.生成元:~FETCH#concept-request-origin
rq.施策~容器:~FETCH#concept-request-policy-container
rq.~URL:~FETCH#concept-request-url
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
rq.~redirect~mode:~FETCH#concept-request-redirect-mode
	bd.~stream:~FETCH#concept-body-stream
接続:~FETCH#concept-connection
資格証:~FETCH#credentials
~network区分~keyを決定する:~FETCH#determine-the-network-partition-key
~fetchする:~FETCH#concept-fetch
~network区分~key:~FETCH#network-partition-keys
接続を得する:~FETCH#concept-connection-obtain
~fetchingは，不良~portに因り阻止されるべきか？:~FETCH#block-bad-port

通達に~algoを追加する:~DOM4#abortsignal-add
aB.中止-事由:~DOM4#abortsignal-abort-reason

下層~sink:~STREAMS#underlying-sink
~BYOB読取器:~STREAMS#byob-reader
既定の読取器:~STREAMS#default-reader
限界水位:~STREAMS#high-water-mark
可読~byte~stream:~STREAMS#readable-byte-stream
RS.~closeする:~STREAMS#readablestream-close
RS.~errorにする:~STREAMS#readablestream-error
RS.~lockされて:~STREAMS#readablestream-locked
RS.~chunkを~enqueueする:~STREAMS#readablestream-enqueue
RS.~byte列から~pullする:~STREAMS#readablestream-pull-from-bytes
RS.~byte読取り~support付きで設定しておく:~STREAMS#readablestream-set-up-with-byte-reading-support
RS.現在の~BYOB要請~view:~STREAMS#readablestream-current-byob-request-view
RS.設定しておく:~STREAMS#readablestream-set-up
	.取消~algo:~STREAMS#readablestream-set-up-with-byte-reading-support-cancelalgorithm
	.~pull~algo:~STREAMS#readablestream-set-up-with-byte-reading-support-pullalgorithm
	.限界水位:~STREAMS#readablestream-set-up-highwatermark
	.~pull~algo:~STREAMS#readablestream-set-up-pullalgorithm
WS.~errorにする:~STREAMS#writablestream-error
	errored:~STREAMS#writablestream-error
WS.~closeする:~STREAMS#writablestream-close
WS.設定しておく:~STREAMS#writablestream-set-up
	.中止-~algo:~STREAMS#writablestream-set-up-abortalgorithm
	.~close~algo:~STREAMS#writablestream-set-up-closealgorithm
	.書込n~algo:~STREAMS#writablestream-set-up-writealgorithm

並列的:~HTMLINFRA#in-parallel
大域~taskを~queueする:~WAPI#queue-a-global-task
逆直列化~手続き:~HTMLcloning#deserialization-steps
aG.~event~loop:~WAPI#concept-agent-event-loop
~network用~task~source:~WAPI#networking-task-source
生成元:~ORIGIN#concept-origin
	origin:~HTMLLS/browsers.html#concept-origin
enV.生成元:~WAPI#concept-settings-object-origin
enV.施策~容器:~WAPI#concept-settings-object-policy-container
enV.~API用~基底~URL:~WAPI#api-base-url
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
直列化-可能:~HTMLcloning#serializable-objects
直列化~手続き:~HTMLcloning#serialization-steps
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
	serialized:~HTMLLS/browsers.html#ascii-serialisation-of-an-origin
転送-手続き:~HTMLcloning#transfer-steps
転送-受信-時の手続き:~HTMLcloning#transfer-receiving-steps

~URL構文解析する:~URL1#concept-url-parser
~URL~record:~URL1#concept-url
url.~scheme:~URL1#concept-url-scheme
url.素片:~URL1#concept-url-fragment

~UTF-8復号する:~ENCODING#utf-8-decode
~UTF-8符号化する:~ENCODING#utf-8-encode

要請に対する~CSP違反を報告する:~CSP3#report-for-request
要請は~CSPにより阻止されるべきか？:~CSP3#should-block-request

~capsule:~HTTPdatagram#dfn-capsule

●●ref_key_map
QUIC:RFC9000
QUICDATAGRAM:RFC9221

●●ref_data
WEBTRANSPORTOVERVIEW=副   ~/webtrans-overview-ja.html
WEBTRANSPORTHTTP3=副      ~/webtrans-http3-ja.html

●●ref_normative

[CSP3]
    Mike West; Antonio Sartori. ＜Content Security Policy Level 3＞. URL: https://w3c.github.io/webappsec-csp/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT-6.0]
    Allen Wirfs-Brock. ＜ECMA-262 6th Edition, The ECMAScript 2015 Language Specification＞. URL: http://www.ecma-international.org/ecma-262/6.0/index.html
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PRIVACY-PRINCIPLES]
    Robin Berjon; Jeffrey Yasskin. ＜Privacy Principles＞. URL: https://w3ctag.github.io/privacy-principles/
[QUIC]
    Jana Iyengar; Martin Thomson. ＜QUIC: A UDP-Based Multiplexed and Secure Transport＞. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9000
[QUIC-DATAGRAM]
    Tommy Pauly; Eric Kinnear; David Schinazi. ＜An Unreliable Datagram Extension to QUIC＞. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9221
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[RFC3279]
    L. Bassham; W. Polk; R. Housley. ＜Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile＞. April 2002. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc3279
[RFC5280]
    D. Cooper; et al. ＜Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile＞. May 2008. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc5280
[RFC8174]
    B. Leiba. ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[RFC8422]
    Y. Nir; S. Josefsson; M. Pegourie-Gonnard. ＜Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier＞. August 2018. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8422
[RFC9002]
    J. Iyengar, Ed.; I. Swett, Ed.. ＜QUIC Loss Detection and Congestion Control＞. May 2021. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9002
[RFC9525]
    P. Saint-Andre; R. Salz. ＜Service Identity in TLS＞. November 2023. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9525
[STREAMS]
    Adam Rice; et al. ＜Streams Standard＞. Living Standard. URL: https://streams.spec.whatwg.org/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEB-TRANSPORT-HTTP2]
    Alan Frindell; et al. ＜WebTransport over HTTP/2＞. Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http2/
[WEB-TRANSPORT-HTTP3]
    Alan Frindell; Eric Kinnear; Victor Vasiliev. ＜WebTransport over HTTP/3＞. Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3/
[WEB-TRANSPORT-OVERVIEW]
    Victor Vasiliev. ＜WebTransport Protocol Framework＞. Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-overview
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/
[WEBTRANSPORT]
    Nidhi Jaju; Victor Vasiliev. ＜WebTransport＞. URL: https://w3c.github.io/webtransport/

●●ref_informative

[RFC7301]
    S. Friedl; et al. ＜Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension＞. July 2014. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7301
[RFC8446]
    E. Rescorla. ＜The Transport Layer Security (TLS) Protocol Version 1.3＞. August 2018. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8446
[RFC9308]
    M. Kühlewind; B. Trammell. ＜Applicability of the QUIC Transport Protocol＞. September 2022. Informational. URL: https://www.rfc-editor.org/rfc/rfc9308
[UNSANCTIONED-TRACKING]
    Mark Nottingham. ＜Unsanctioned Web Tracking＞. 17 July 2015. TAG Finding. URL: http://www.w3.org/2001/tag/doc/unsanctioned-tracking/
[WEBRTC]
    Cullen Jennings; et al. ＜WebRTC: Real-Time Communication in Browsers＞. URL: https://w3c.github.io/webrtc-pc/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">WebTransport</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/webtransport/
公表履歴
	https://www.w3.org/standards/history/webtransport/
フィードバック
	<a href="mailto:public-webtransport@w3.org?subject=%5Bwebtransport%5D%20YOUR%20TOPIC%20HERE">public-webtransport@w3.org</a> with subject line “<kbd>[webtransport] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webtransport/" rel="discussion">archives</a>)
	<a href="https://github.com/w3c/webtransport/issues/">GitHub</a>

編集
	Nidhi Jaju (Google)
	Victor Vasiliev (Google)
	Jan-Ivar Bruaroey (Mozilla)
前任編集者
	Bernard Aboba (Microsoft Corporation)
	Peter Thatcher (Google)
	Robin Raymond (Optical Tone Ltd.)
	Yutaka Hirano (Google)


commit 履歴
	https://github.com/w3c/webtransport/commits/main
公表者
	<a href="https://www.w3.org/groups/wg/webtransport">WebTransport WG</a>


</script>
</head>
<body>

<header>
	<hgroup>
<h1>WebTransport</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、［
~browser ↔ ~server
］間で~dataが［
送信される／受信される
］ことを許容するための~API【！a set of ECMAScript APIs in WebIDL】を
`WEB-TRANSPORT-HTTP3$r, `WEB-TRANSPORT-HTTP2$r
を用立てる下で定義する。
この仕様は、［
~IETF~WEBTRANS~WGにより開発された~protocol仕様
］と共に開発されている。
◎
This document defines a set of ECMAScript APIs in WebIDL to allow data to be sent and received between a browser and server, utilizing [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2]. This specification is being developed in conjunction with protocol specifications developed by the IETF WEBTRANS Working Group.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、公表~時点における…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>
	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
この仕様は、
`WEB-TRANSPORT-HTTP3$r,
`WEB-TRANSPORT-HTTP2$r
を利用して~dataを［
~UAから送信する／
~serverから受信する
］ための~APIを定義する。
それは，~WebSocketの様に利用できるが、
次に挙げるもの用の~supportを伴う
⇒＃
複数の~stream,
一方向~stream,
順序どおりでない送達,
`依拠-可能$な（ `reliable^en ）~transport【~TCP（ ~HTTP2 ）】,
`不依拠-可能$な（ `unreliable^en ）~transport【~UDP（ ~HTTP3 ）】
◎
This specification uses [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2] to send data to and receive data from servers. It can be used like WebSockets but with support for multiple streams, unidirectional streams, out-of-order delivery, and reliable as well as unreliable transport.
</p>

<p class="note">注記：
この仕様に呈示される~APIは、
~IETF~WEBTRANS~WGの中で進捗-中な作業に基づく，準備的な提案を表現する。
その［
`WEB-TRANSPORT-HTTP3$r, `WEB-TRANSPORT-HTTP2$r
］仕様は，進捗-中な作業なので、
今後［
~protocol, ~API
］どちらも有意に変更される見込みが高い。
◎
Note: The API presented in this specification represents a preliminary proposal based on work-in-progress within the IETF WEBTRANS WG. Since the [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2] specifications are a work-in-progress, both the protocol and API are likely to change significantly going forward.
</p>

	</section>
【！§ #conformance】
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="protocol-concepts">
<h2 title="Protocol concepts">3. ~protocol概念</h2>

<p>
~WebTransportには、
主な~protocol概念として，~sessionと~streamが在る。
各`~WebTransport~session$は、
複数個の`~WebTransport~stream$を包含し得る。
◎
There are two main protocol concepts for WebTransport: sessions and streams. Each WebTransport session can contain multiple WebTransport streams.
</p>

<p>
これらは、
`~protocol名$と混同するべきでない
— それは、
応用~levelの~API構成子である。
◎
These should not be confused with protocol names which is an application-level API construct.
</p>

		<section id="webtransport-session">
<h3 title="WebTransport session">3.1. ~WebTransport~session</h3>

<p>
`~WebTransport~session@
は、
その
`下層~接続@
と称される［
~HTTP3／~HTTP2
］`接続$越しの~WebTransportが成す~sessionである。
~pool法が可能化されたときは、
1 個の`接続$に複数個の`~WebTransport~session$が在り得る。
◎
A WebTransport session is a session of WebTransport over an HTTP/3 or HTTP/2 underlying connection. There may be multiple WebTransport sessions on one connection, when pooling is enabled.
</p>

<p>
各`~WebTransport~session$は、
次に挙げる能力を有する
— それらは `WEB-TRANSPORT-OVERVIEW$r にて定義される：
◎
A WebTransport session has the following capabilities defined in [WEB-TRANSPORT-OVERVIEW]:
</p>

<div>
<table class="_stream-capa grid-table">
<thead><tr>
<th>能力
<th>`WEB-TRANSPORT-OVERVIEW$r における定義
【括弧内はこの訳による補完】
<tbody>

<tr><td>
`~datagramを送信する@
<td>
`~datagramを送信する＠~WT-OVERVIEW#send-a-datagram$

<tr><td>
`~datagramを受信する@
<td>
`~datagramを受信する＠~WT-OVERVIEW#receive-a-datagram$

<tr><td>
`流出~一方向~streamを作成する@
<td>
`一方向~streamを作成する＠~WT-OVERVIEW#create-a-unidirectional-stream$
（~clientが起動した`流出~一方向$な~streamを返す。）

<tr><td>
`双方向~streamを作成する@
<td>
`双方向~streamを作成する＠~WT-OVERVIEW#create-a-bidirectional-stream$
（~clientが起動した`双方向$な~streamを返す。）

<tr><td>
`流入~一方向~streamを受信する@
<td>
`一方向~streamを受信する＠~WT-OVERVIEW#receive-a-unidirectional-stream$
（~serverから起動された`流入~一方向$な~streamを返す。）

<tr><td>
`双方向~streamを受信する@
<td>
`双方向~streamを受信する＠~WT-OVERVIEW#receive-a-bidirectional-stream$
（~serverから起動された`双方向$な~streamを返す。）
</table>
◎
capability｜definition
send a datagram｜[WEB-TRANSPORT-OVERVIEW] Section 4.2
receive a datagram｜[WEB-TRANSPORT-OVERVIEW] Section 4.2
create an outgoing unidirectional stream｜[WEB-TRANSPORT-OVERVIEW] Section 4.3
create a bidirectional stream｜[WEB-TRANSPORT-OVERVIEW] Section 4.3
receive an incoming unidirectional stream｜[WEB-TRANSPORT-OVERVIEW] Section 4.3
receive a bidirectional stream｜[WEB-TRANSPORT-OVERVIEW] Section 4.3
</div>

<div class="algo">
<p>
【~clientが】
`~WebTransport~sessionを確立する@
ときは、
所与の
( `生成元$ %生成元, `~list$ %~protocol群 【！~array】 )
に対し，
`WEB-TRANSPORT-OVERVIEW$r `新たな~sessionの作成-法＠~WT-OVERVIEW#establish-a-session$【！4.1】
および次に従う
— これは、［
ある`~WebTransport~session$ ／ `失敗^i
］を返す：
◎
To establish a WebTransport session with an origin origin and a protocols array, follow [WEB-TRANSPORT-OVERVIEW] Section 4.1,＼
</p>
<ul>
	<li>
当の要請の `Origin$h ~headerには次の結果を利用する
⇒
`同型に符号化する$( `生成元を直列化する$( %生成元 ) )
◎
using origin, serialized and isomorphically encoded, as the `Origin` header of the request,＼
</li>
	<li>
<p>
`WEB-TRANSPORT-OVERVIEW$r `§ 応用~protocolの折衝＠~WT-OVERVIEW#application-protocol-negotiation$ に従って、
【 %~protocol群 は空でないならば，】
当の要請【の `WT-Available-Protocols$h ~header】には次の結果を利用する：
</p>
		<ol>
			<li>
%結果 ~LET 新たな`~list$
</li>
			<li>
%~protocol群 を成す
~EACH( %~protocol名 )
に対し，~clientの選好~順序で†
⇒
%結果 に次の結果を`付加する$
⇒
`同型に符号化する$( %~protocol名 )
</li>
			<li>
~RET %結果
</li>
		</ol>

<p class="trans-note">【†
%~protocol群 は `protocols$mb から供される
— それにより供された順序が，そのまま~clientの選好~順序を指示する
（ここでの “~client” は、
~UAではなく応用を指す）
ように思われる
（そうならば、
ここでの “選好~順序で” は冗長であり，
代わりに `protocols$mb の定義にて述べられるべきであろうが）。
】</p>
◎
and the isomorphically encoded protocols as the list of protocols the client would like the server to use in this session, in preference order, following Section 3.1.＼
</li>
	<li>
<p>
~sessionを確立するときは、
~clientは，`資格証$を供さないモノトスル。
◎
When establishing a session, the client MUST NOT provide any credentials.＼
</p>

<p>
結果の下層~transport~streamは、
当の~sessionの
`~CONNECT~stream@
と称される。
◎
The resulting underlying transport stream is referred to as the session’s CONNECT stream.
</p>

<p class="trans-note">【
~CONNECT と称されるわけは、
当の要請が `CONNECT$M ~methodを利用することによる。
】</p>
	</li>
</ul>
</div>

<div>
<p>
`~WebTransport~session$は、
次(1)または次(2) のとき，次(3) に述べられるとおり
`~draining@
【 `Draining$sl を見よ】：
</p>
<ul>
	<li>(1)
当の~sessionの`~CONNECT~stream$において，
`DRAIN_WEBTRANSPORT_SESSION$ft `~capsule$を受信したとき
</li>
	<li>(2)
`GOAWAY$ft ~frameを受信したとき
</li>
	<li>(3)
`WEB-TRANSPORT-HTTP3$r `§ ~HTTP3 GOAWAY ~frameとの相互作用＠~WT-HTTP3#interaction-with-http3-goaway-frame$【！4.6】
</li>
</ul>

◎
A WebTransport session session is draining when the CONNECT stream receives an DRAIN_WEBTRANSPORT_SESSION capsule, or when a GOAWAY frame is received, as described in [WEB-TRANSPORT-HTTP3] Section 4.6.
</div>

<div class="algo">
<p>
`~WebTransport~sessionを終了する@
ときは、
所与の
( `~WebTransport~session$, 省略可能な整数 %~code, 省略可能な`~byte列$ %事由 )
に対し，
`WEB-TRANSPORT-OVERVIEW$r `§ ~session全般な特能＠~WT-OVERVIEW#features-session$
に従う。
◎
To terminate a WebTransport session session with an optional integer code and an optional byte sequence reason, follow [WEB-TRANSPORT-OVERVIEW] Section 4.1.

[WEB-TRANSPORT-HTTP3] Section 5.
</p>
</div>

<div>
<p>
`~WebTransport~session$は、
次(1) のとき，次(2) を伴って，次(3) に述べられるとおり
`終了され@
る
【 `§ 5.6＠#web-transport-termination$ を見よ】：
</p>
<ul>
	<li>(1)
`~CONNECT~stream$が~serverにより~closeされた
</li>
	<li>(2)
整数 %~code,
`~byte列$ %事由
— いずれも省略可能
</li>
	<li>(3)
`WEB-TRANSPORT-OVERVIEW$r `§ ~session全般な特能＠~WT-OVERVIEW#features-session$
</li>
</ul>
◎
A WebTransport session session is terminated, with optionally an integer code and a byte sequence reason, when the CONNECT stream is closed by the server, as described at [WEB-TRANSPORT-OVERVIEW] Section 4.1.
</div>

<p>
各`~WebTransport~session$には、
次に挙げる通達が生じ得る：
◎
A WebTransport session has the following signals:
</p>

<div>
<table class="_stream-capa grid-table" id="_session-capa"><thead>
<tr><th>~event
<th>定義
<tbody>

<tr><td>`DRAIN_WEBTRANSPORT_SESSION@ft
<td>`WEB-TRANSPORT-HTTP3$r `§ ~HTTP3 GOAWAY ~frameとの相互作用＠~WT-HTTP3#interaction-with-http3-goaway-frame$【！4.6】

<tr><td>`GOAWAY@ft
<td>`WEB-TRANSPORT-HTTP3$r `§ ~HTTP3 GOAWAY ~frameとの相互作用＠~WT-HTTP3#interaction-with-http3-goaway-frame$【！4.6】
</table>
◎
event｜definition
DRAIN_WEBTRANSPORT_SESSION｜[WEB-TRANSPORT-HTTP3] Section 4.6
GOAWAY｜[WEB-TRANSPORT-HTTP3] Section 4.6
</div>

		</section>
		<section id="webtransport-stream">
<h3 title="WebTransport stream">3.2. ~WebTransport~stream</h3>

<p>
`~WebTransport~stream@
は、
`WEB-TRANSPORT-OVERVIEW$r `§ ~stream＠~WT-OVERVIEW#features-streams$
にて述べられるとおり，［
`~WebTransport~session$上の
`依拠-可能$な順序どおりな~byteたちが成す~stream
］用の概念である。
◎
A WebTransport stream is a concept for a reliable in-order stream of bytes on a WebTransport session, as described in [WEB-TRANSPORT-OVERVIEW] Section 4.3.
</p>

<div>
<p>
所与の`~WebTransport~stream$は、
次に挙げるいずれかになる：
</p>
<ul>
	<li>
`流入~一方向@
（ `incoming unidirectional^en ）
</li>
	<li>
`流出~一方向@
（ `outgoing unidirectional^en ）
</li>
	<li>
`双方向@
（ `bidirectional^en ）
</li>
</ul>
◎
A WebTransport stream is one of incoming unidirectional, outgoing unidirectional or bidirectional.
</div>

<p>
各`~WebTransport~stream$ %~stream は、
次に挙げる能力を有する：
◎
A WebTransport stream has the following capabilities:
</p>

<div>
<table class="_stream-capa grid-table"><thead>
<tr><th>能力
<th>`WEB-TRANSPORT-OVERVIEW$r における定義
<th>`流入~一方向$
<th>`流出~一方向$
<th>`双方向$
<tbody>

<tr><td>
%~stream に~byte列を
`送信する@WT
（~FINを伴い得る）
<td>`~byte列を送信する＠~WT-OVERVIEW#send-bytes$
<td>不可
<td>可
<td>可

<tr><td>
%~stream から~byte列を
`受信する@WT
（~FINを伴い得る）
<td>`~byte列を受信する＠~WT-OVERVIEW#receive-bytes$
<td>可
<td>不可
<td>可

<tr><td>
%~stream 上の
`送信を停止させる@WT
（ `STOP_SENDING$ft ）
<td>`受信-側を中止する＠~WT-OVERVIEW#abort-receive-side$
<td>可
<td>不可
<td>可

<tr><td>
%~stream を
`設定し直す@WT
（ `RESET_STREAM$ft ）
<td>`送信-側を中止する＠~WT-OVERVIEW#abort-send-side$
<td>不可
<td>可
<td>可
</table>

◎
capability｜definition｜incoming unidirectional｜outgoing unidirectional｜bidirectional
send bytes (potentially with FIN)｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜No｜Yes｜Yes
receive bytes (potentially with FIN)｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜Yes｜No｜Yes
send STOP_SENDING｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜Yes｜No｜Yes
reset a WebTransport stream｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜No｜Yes｜Yes
</div>

<p>
各`~WebTransport~session$には、
次に挙げる通達が生じ得る：
◎
A WebTransport stream has the following signals:
</p>

<div>
<table class="_stream-capa grid-table"><thead>
<tr><th>~event
<th>`WEB-TRANSPORT-OVERVIEW$r における定義
<th>`流入~一方向$
<th>`流出~一方向$
<th>`双方向$
<tbody>

<tr><td>`STOP_SENDING@ft
<td>`受信-側は中止された＠~WT-OVERVIEW#receive-side-aborted$【！受信-側を中止する】
<td>生じない
<td>生じ得る
<td>生じ得る

<tr><td>`RESET_STREAM@ft
<td>`送信-側は中止された＠~WT-OVERVIEW#send-side-aborted$【！送信-側を中止する】
<td>生じ得る
<td>生じない
<td>生じ得る

<tr><td>`~flow制御@
<td>`~flow制御される＠~WT-OVERVIEW#is-flow-controlled$
<td>生じない
<td>生じ得る
<td>生じ得る
</table>
◎
event｜definition｜incoming unidirectional｜outgoing unidirectional｜bidirectional
STOP_SENDING｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜No｜Yes｜Yes
RESET_STREAM｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜Yes｜No｜Yes
flow control｜[WEB-TRANSPORT-OVERVIEW] Section 4.3｜No｜Yes｜Yes 
</div>

		</section>
	</section>
	<section id="datagram-writable">
<h2 title="WebTransportDatagramsWritable Interface">4. `WebTransportDatagramsWritable^I ~interface</h2>

<p>
`WebTransportDatagramsWritable$I は、
`WritableStream$I であり，
`~datagramを送信する$ための流出~stream用の特能を供する。
◎
A WebTransportDatagramsWritable is a WritableStream providing outgoing streaming features to send datagrams.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$, `Transferable$]
interface `WebTransportDatagramsWritable@I : `WritableStream$I {
  attribute `WebTransportSendGroup$I? `sendGroup$mW;
  attribute `long long$ `sendOrder$mW;
};
</pre>

		<section id="datagram-writable-internal-slots">
<h3 title="Internal slots">4.1. 内部~slot</h3>

<p>
各 `WebTransportDatagramsWritable$I ~objは、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportDatagramsWritable object has the following internal slot.
◎
Internal Slot｜Description (non-normative)
</p>

<dl>
	<dt>`OutgoingDatagramsQueue@slW</dt>
	<dd>
ある`~queue$
◎
A queue＼
</dd>
	<dd>
( 流出~datagram, 時刻印, ~promise )
が成す~tupleたちからなる。
◎
of tuples of an outgoing datagram, a timestamp and a promise＼
</dd>
	<dd>
この~tupleを成す~promiseは、
~datagramが［
送信される／破棄される
］とき解決される。
◎
which is resolved when the datagram is sent or discarded.
</dd>

	<dt>`Transport@slW</dt>
	<dd>
この `WebTransportDatagramsWritable$I を所有する `WebTransport$I ~obj
◎
A WebTransport which owns this WebTransportDatagramsWritable.
</dd>

	<dt>`SendGroup@slW</dt>
	<dd>
~NULL ／
ある `WebTransportSendGroup$I ~obj
— 既定は ~NULL
◎
An optional WebTransportSendGroup, or null.
</dd>

	<dt>`SendOrder@slW</dt>
	<dd>
送信-順序~番号
— 既定は 0
◎
An optional send order number, defaulting to 0.
</dd>
</dl>

<div class="algo">
<p>
`WebTransportDatagramsWritable$I を
`作成する@DW
~algoは、
所与の
( `WebTransport$I %~transport, %送信-~group, %送信-順序 )
に対し：
◎
To create a WebTransportDatagramsWritable, given a WebTransport transport, a sendGroup, and a sendOrder, perform the following steps.
</p>
<ol>
	<li>
%~stream ~LET `新たな~obj$( `WebTransportDatagramsWritable$I )
— その
⇒＃
`OutgoingDatagramsQueue$slW ~SET 空~queue,
`Transport$slW ~SET %~transport,
`SendGroup$slW ~SET %送信-~group,
`SendOrder$slW ~SET %送信-順序
◎
Let stream be a new WebTransportDatagramsWritable, with:
• [[OutgoingDatagramsQueue]]
•• an empty queue
• [[Transport]]
•• transport
• [[SendGroup]]
•• sendGroup
• [[SendOrder]]
•• sendOrder
</li>
	<li>
<p>
%~stream を`設定しておく$WS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`書込n~algo^i ~SET 【所与の ( %~chunk ) に対し，】次を走らす動作
⇒
`~datagram群を書込む$( %~transport, %~stream【, %~chunk】 )
</li>
		</ul>
◎
Let writeDatagramsAlgorithm be an action that runs writeDatagrams with transport and stream.
◎
Set up stream with writeAlgorithm set to writeDatagramsAlgorithm.
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

		</section>
		<section id="datagram-writable-attributes">
<h3 title="Attributes">4.2. 属性</h3>

<dl>
	<dt>
`sendGroup@mW
◎
sendGroup, of type WebTransportSendGroup, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `SendGroup$slW
◎
The getter steps are:
• Return this’s [[SendGroup]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~NEQ ~NULL
］~AND［
%値 . `Transport$slG ~NEQ コレ . `Transport$slW
］
⇒
~THROW `InvalidStateError$E
◎
If value is non-null, and value.[[Transport]] is not this.[[Transport]], throw an InvalidStateError.
</li>
			<li>
コレ . `SendGroup$slW ~SET %値
◎
Set this.[[SendGroup]] to value.
</li>
		</ol>
	</dd>

	<dt>
`sendOrder@mW
◎
sendOrder, of type long long
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `SendOrder$slW
◎
The getter steps are:
• Return this’s [[SendOrder]].
</dd>
	<dd class="algo">
設定子~手続きは
⇒
コレ . `SendOrder$slW ~SET `所与の値$
◎
The setter steps, given value, are:
• Set this.[[SendOrder]] to value.
</dd>
</dl>

		</section>
		<section id="datagram-writable-procedures">
<h3 title="Procedures">4.3. 手続-</h3>

<div class="algo">
<p>
`~datagram群を書込む@
~algoは、
所与の
( `WebTransport$I ~obj %~transport, `WebTransportDatagramsWritable$I ~obj %可書~stream, %~data )
に対し：
◎
The writeDatagrams algorithm is given a transport and writable as parameters and data as input. It is defined by running the following steps:
</p>
<ol>
	<li>
%時刻印 ~LET 今を表現している時刻印
◎
Let timestamp be a timestamp representing now.
</li>
	<li>
~IF［
%~data は `BufferSource$I ~objでない
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If data is not a BufferSource object, then return a promise rejected with a TypeError.
</li>
	<li>
%~datagram群 ~LET %~transport . `Datagrams$sl
◎
Let datagrams be transport.[[Datagrams]].
</li>
	<li>
~IF［
%~datagram群 . `OutgoingMaxDatagramSize$sl ~LT %~data . `ByteLength^sl
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If datagrams.[[OutgoingMaxDatagramSize]] is less than data’s [[ByteLength]], return a promise resolved with undefined.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~byte列 ~LET %~data に`保持された~byte列の複製を取得する$
◎
Let bytes be a copy of bytes which data represents.
</li>
	<li>
%~chunk ~LET
( %~byte列, %時刻印, %~promise )
が成す~tuple
◎
Let chunk be a tuple of bytes, timestamp and promise.
</li>
	<li>
%可書~stream . `OutgoingDatagramsQueue$slW に %~chunk を`~enqueueする$
◎
Enqueue chunk to writable.[[OutgoingDatagramsQueue]].
</li>
	<li>
~IF［
%可書~stream . `OutgoingDatagramsQueue$slW の`~size$【！長さ】 ~LT %~datagram群 . `OutgoingDatagramsHighWaterMark$sl
］
⇒
`~promiseを解決する$( %~promise )
◎
If the length of writable.[[OutgoingDatagramsQueue]] is less than datagrams.[[OutgoingDatagramsHighWaterMark]], then resolve promise with undefined.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

<p class="note">注記：
結付けられた `WritableStream$I
【 %~datagram群 . `Writable$sl ？】は、
`that^en ~stream【？】用に［
`~datagram群を書込む$から返されたすべての~promise
］が解決されたときに限り，`~datagram群を書込む$を~callする。
よって，［
時刻印, 失効n所要時間【 %~datagram群 . `OutgoingDatagramsExpirationDuration$sl ？】
］がきちんと働くのは、
~web開発者が `WritableStreamDefaultWriter.ready＠~STREAMS#default-writer-ready$c に気を配るときに限られる。
◎
Note: The associated WritableStream calls writeDatagrams only when all the promises that have been returned by writeDatagrams for that stream have been resolved. Hence the timestamp and the expiration duration work well only when the web developer pays attention to WritableStreamDefaultWriter.ready.
</p>
</div>

<div class="algo">
<p>
`~datagram群を送信する@
~algoは、
所与の
( `WebTransport$I ~obj %~transport, `WebTransportDatagramsWritable$I ~obj %可書~stream )
に対し：
◎
To sendDatagrams, given a WebTransport object transport and a WebTransportDatagramsWritable object writable, run these steps:
</p>
<ol>
	<li>
%~queue ~LET %可書~stream . `OutgoingDatagramsQueue$slW
◎
Let queue be writable.[[OutgoingDatagramsQueue]].
</li>
	<li>
%~datagram群 ~LET %~transport . `Datagrams$sl
◎
Let datagrams be transport.[[Datagrams]].
</li>
	<li>
%所要時間 ~LET %~datagram群 . `OutgoingDatagramsExpirationDuration$sl
◎
Let duration be datagrams.[[OutgoingDatagramsExpirationDuration]].
</li>
	<li>
~IF［
%所要時間 ~EQ ~NULL
］
⇒
%所要時間 ~SET `実装定義$な値
◎
If duration is null, then set duration to an implementation-defined value.
</li>
	<li>
<p>
~WHILE［
%~queue は空でない
］：
</p>
		<ol>
			<li>
~IF［
%~queue[ 0 ][ 1 ] から［
今を表現している時刻印
］までを成す~milli秒数 ~LTE %所要時間
］
⇒
~BREAK
</li>
			<li>
%~queue から`~dequeueする$【！Remove the first element】
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
</p>
<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
</div>
			</li>
		</ol>
◎
While queue is not empty:
• Let bytes, timestamp and promise be queue’s first element.
• If more than duration milliseconds have passed since timestamp, then:
•• Remove the first element from queue.
•• Queue a network task with transport to resolve promise with undefined.
• Otherwise, break this loop.
</li>
	<li>
~IF［
%~transport . `State$sl ~NEQ `connected^l
］
⇒
~RET
◎
If transport.[[State]] is not "connected", then return.
</li>
	<li>
%最大-~size ~LET %~datagram群 . `OutgoingMaxDatagramSize$sl
◎
Let maxSize be datagrams.[[OutgoingMaxDatagramSize]].
</li>
	<li>
<p>
~WHILE［
%~queue は空でない
］：
◎
While queue is not empty:
</p>
		<ol>
			<li>
( %~byte列, %時刻印, %~promise ) ~LET %~queue[ 0 ]【！’s first element】
◎
Let bytes, timestamp and promise be queue’s first element.
</li>
			<li>
<p>
~IF［
%~byte列 の長さ ~LTE %最大-~size
］：
◎
If bytes’s length ≤ maxSize:
</p>
				<ol>
					<li>
~IF［
%~byte列 を~networkへ即時に送信することはアリでない
］
⇒
~BREAK
◎
If it is not possible to send bytes to the network immediately, then break this loop.
</li>
					<li>
`~datagramを送信する$( %~transport . `Session$sl, %~byte列 )
◎
Send a datagram, with transport.[[Session]] and bytes.
</li>
				</ol>
			</li>
			<li>
%~queue から`~dequeueする$【！Remove the first element】
◎
Remove the first element from queue.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
◎
resolve promise with undefined.
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは，
`WebTransport$I ~obj %~transport が［
%~transport . `State$sl ~IN { `connecting^l, `connected^l }
］を満たす間は、［
`~datagram群を送信する$
~algoが
( %~transport, 次を満たす各 `WebTransportDatagramsWritable$I ~obj )
に対し進捗を為せるようになった
］ときには，［
アリな限り適度に早く，それを走らす
］ベキである
⇒
［
%~transport に結付けられたもの
【 %~transport . `Datagrams$sl の `createWritable()$mD により作成されたもの】
である
］~AND［
`送信-順序の規則$に基づいて後回されないものである
］
◎
The user agent SHOULD run sendDatagrams for any WebTransport object whose [[State]] is "connecting" or "connected" as soon as reasonably possible on a subset, based on send-order rules, of its associated WebTransportDatagramsWritable objects whenever the algorithm can make progress.
</p>

<div>
<p>
`送信-順序の規則@
：
そのような送信は、
一般には，
%~transport 越しに送信されるよう［
それまでに~queueされた／これから~queueされる
］［
~stream, ~datagram
］の送信と前後してもヨイ
— ただし、
~AND↓ を満たす［
~stream, ~datagram
］が在るときは，［
その送信~用に~queueされた すべての~byteが送信される
］まで，後回するモノトスル：
</p>
<ul>
	<li>
同じ `SendGroup$slW を伴う
</li>
	<li>
`SendOrder$slW がより高い
</li>
	<li>
~NOT `~error＠~STREAMS#writablestream-error$WSした
</li>
	<li>
~NOT `~flow制御$により阻まれた
</ul>
◎
The send-order rules are that sending in general MAY be interleaved with sending of previously queued streams and datagrams, as well as streams and datagrams yet to be queued to be sent over this transport, except that sending MUST starve until all bytes queued for sending on streams and datagrams with the same [[SendGroup]] and a higher [[SendOrder]], that are neither errored nor blocked by flow control, have been sent.
</div>

<div class="note">
<p>注記：
`WebTransport$I ~obj %~transport が［
その `State$sl ~EQ `connecting^l
］を満たす間でも，~datagram群を書込むことは許容される。
書込まれた~datagram群は：
</p>
<ul>
	<li>
【 %~transport . `Datagrams$sl . `Writables$sl を成す各~可書~streamの】
`OutgoingDatagramsQueue$slW 内に格納される。
</li>
	<li>
`connected^l 状態にあるときと同じ方式で破棄され得る／できる。
</li>
	<li>
［
%~transport . `State$sl ~EQ `connected^l
］になったとき、
送信を開始することになる。
</li>
</ul>
◎
Note: Writing datagrams while the transport’s [[State]] is "connecting" is allowed. The datagrams are stored in [[OutgoingDatagramsQueue]], and they can be discarded in the same manner as when in the "connected" state. Once the transport’s [[State]] becomes "connected", it will start sending the queued datagrams.
</div>

		</section>
	</section>
	<section id="duplex-stream">
<h2 title="WebTransportDatagramDuplexStream Interface">5. `WebTransportDatagramDuplexStream^I ~interface</h2>

<p>
`WebTransportDatagramDuplexStream$I は、
汎用な二重化~streamを成す。
◎
A WebTransportDatagramDuplexStream is a generic duplex stream.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransportDatagramDuplexStream@I {
  `WebTransportDatagramsWritable$I `createWritable$mD( optional `WebTransportSendOptions$I %options = {});
  readonly attribute ReadableStream readable;

  readonly attribute `ReadableStream$I `readable$mD;

  readonly attribute `unsigned long$ `maxDatagramSize$mD;
  attribute `unrestricted double$? `incomingMaxAge$mD;
  attribute `unrestricted double$? `outgoingMaxAge$mD;
  attribute `unrestricted double$ `incomingHighWaterMark$mD;
  attribute `unrestricted double$ `outgoingHighWaterMark$mD;
};
</pre>

		<section id="datagram-duplex-stream-internal-slots">
<h3 title="Internal slots">5.1. 内部~slot</h3>

<p>
各 `WebTransportDatagramDuplexStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportDatagramDuplexStream object has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`Readable@sl</dt>
	<dd>
流入~datagram用の `ReadableStream$I ~obj
◎
A ReadableStream for incoming datagrams.
</dd>

	<dt>`Writables@sl</dt>
	<dd>
`WebTransportDatagramsWritable$I ~streamたちが成す`有順序~集合$
— 初期~時は空とする。
◎
An ordered set of WebTransportDatagramsWritable streams, initially empty.
</dd>

	<dt>`IncomingDatagramsQueue@sl</dt>
	<dd>
ある`~queue$
◎
A queue＼
</dd>
	<dd>
( 流入~datagram, 時刻印 )
が成す~pairたちからなる。
◎
of pairs of an incoming datagram and a timestamp.
</dd>

	<dt>`IncomingDatagramsPullPromise@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
`~datagram群を~pullする$により設定され，
流入~datagramを待機する。
◎
set by pullDatagrams, to wait for an incoming datagram.
</dd>

	<dt>`IncomingDatagramsHighWaterMark@sl</dt>
	<dd>
ある `unrestricted double$c
◎
An unrestricted double＼
</dd>
	<dd>
流入~datagramたちの`限界水位$を表現する。
◎
representing the high water mark of the incoming datagrams.
</dd>

	<dt>`IncomingDatagramsExpirationDuration@sl</dt>
	<dd>
~NULL ／ ある `unrestricted double$c
◎
↓</dd>
	<dd>
~NULL でない場合、
流入~datagramたち用の失効n所要時間を（~milli秒数で）表現する。
◎
An unrestricted double representing the expiration duration for incoming datagrams (in milliseconds), or null.
</dd>

	<dt>`OutgoingDatagramsHighWaterMark@sl</dt>
	<dd>
ある `unrestricted double$c
◎
An unrestricted double＼
</dd>
	<dd>
流出~datagramの`限界水位$を表現する。
◎
representing the high water mark of the outgoing datagrams.
</dd>

	<dt>`OutgoingDatagramsExpirationDuration@sl</dt>
	<dd>
~NULL ／ ある `unrestricted double$c
◎
↓</dd>
	<dd>
~NULL でない場合、
流出~datagramたち用の失効n所要時間を（~milli秒数で）表現する。
◎
An unrestricted double value representing the expiration duration for outgoing datagrams (in milliseconds), or null.
</dd>

	<dt>`OutgoingMaxDatagramSize@sl</dt>
	<dd>
ある整数
◎
An integer＼
</dd>
	<dd>
流出~datagram用の最大~sizeを表現する。
◎
representing the maximum size for an outgoing datagram.
</dd>
</dl>

<p>
~UAは、
所与の `WebTransport$I ~obj %~transport に対し［
%~transport . `State$sl ~IN { `connecting^l, `connected^l }
］が満たされる間は，
%~transport . `OutgoingMaxDatagramSize$sl を更新してもヨイ。
◎
The user agent MAY update [[OutgoingMaxDatagramSize]] for any WebTransport object whose [[State]] is either "connecting" or "connected".
</p>

<p>
`WebTransportDatagramDuplexStream$I を
`作成する@DPS
~algoは、
所与の
( %可読~stream )
に対し：
◎
To create a WebTransportDatagramDuplexStream given a readable, perform the following steps
</p>
<ol>
	<li>
<p>
%~stream ~LET `新たな~obj$( `WebTransportDatagramDuplexStream$I )
— その
⇒＃
`Readable$sl ~SET %可読~stream,
`Writables$sl ~SET 新たな`有順序~集合$,
`IncomingDatagramsQueue$sl ~SET 新たな`~queue$,
`IncomingDatagramsPullPromise$sl ~SET ~NULL,
`IncomingDatagramsHighWaterMark$sl ~SET `実装定義$な値,
`IncomingDatagramsExpirationDuration$sl ~SET ~NULL,
`OutgoingDatagramsHighWaterMark$sl ~SET `実装定義$な値†,
`OutgoingDatagramsExpirationDuration$sl ~SET ~NULL,
`OutgoingMaxDatagramSize$sl ~SET `実装定義$な整数
</p>

<p class="note">注記†：
この実装定義な値は、［
まずまずの~throughputを確保する
］かつ［
伝送される~dataの適時性を危うくしない
］よう調律されるべきである。
</p>
◎
Let stream be a new WebTransportDatagramDuplexStream, with:
• [[Readable]]
•• readable
• [[Writables]]
•• an empty ordered set.
• [[IncomingDatagramsQueue]]
•• an empty queue
• [[IncomingDatagramsPullPromise]]
•• null
• [[IncomingDatagramsHighWaterMark]]
•• an implementation-defined value
• [[IncomingDatagramsExpirationDuration]]
•• null
• [[OutgoingDatagramsHighWaterMark]]
•• an implementation-defined value
•• This implementation-defined value should be tuned to ensure decent throughput, without jeopardizing the timeliness of transmitted data.
• [[OutgoingDatagramsExpirationDuration]]
•• null
• [[OutgoingMaxDatagramSize]]
•• an implementation-defined integer.
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>

		</section>
		<section id="datagram-duplex-stream-methods">
<h3 title="Methods">5.2. ~method</h3>

<dl>
	<dt>
`createWritable(options)@mD
◎
createWritable()
</dt>
	<dd>
`WebTransportDatagramsWritable$I ~objを作成する。
◎
Creates a WebTransportDatagramsWritable.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When createWritable() method is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
<p>
%~transport ~LET コレに結付けられた `WebTransport$I ~obj
</p>

<p class="trans-note">【
すなわち，`new WebTransport()$m によりコレを作成したもの
— 言い換えれば、
%~transport . `Datagrams$sl ~EQ コレ
】</p>
◎
Let transport be WebTransport object associated with this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~THROW `InvalidStateError$E
◎
If transport.[[State]] is "closed" or "failed", throw an InvalidStateError.
</li>
			<li>
~RET `WebTransportDatagramsWritable$I を`作成する$DW( %~transport, %options[ "`sendGroup$mb" ], %options[ "`sendOrder$mb" ] )
◎
Let sendGroup be options’s sendGroup.
◎
Let sendOrder be options’s sendOrder.
◎
Return the result of creating a WebTransportDatagramsWritable with transport, sendGroup and sendOrder.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="datagram-duplex-stream-attributes">
<h3 title="Attributes">5.3. 属性</h3>

<dl>
	<dt>
`readable@mD
◎
readable, of type ReadableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Readable$sl
◎
The getter steps are:
• Return this.[[Readable]].
</dd>

	<dt>
`incomingMaxAge@mD
◎
incomingMaxAge, of type unrestricted double, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingDatagramsExpirationDuration$sl
◎
The getter steps are:
• Return this.[[IncomingDatagramsExpirationDuration]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~EQ 0
］
⇒
%値 ~SET ~NULL
◎
If value is 0, set value to null.
</li>
			<li>
コレ . `IncomingDatagramsExpirationDuration$sl ~SET %値
◎
Set this.[[IncomingDatagramsExpirationDuration]] to value.
</li>
		</ol>
	</dd>

	<dt>
`maxDatagramSize@mD
◎
maxDatagramSize, of type unsigned long, readonly
</dt>
	<dd>
【コレ . `Writables$sl を成す各】 `WebTransportDatagramsWritable$I に渡してもよい~dataの最大~size
◎
The maximum size data that may be passed to a WebTransportDatagramsWritable.＼
</dd>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `OutgoingMaxDatagramSize$sl
◎
The getter steps are to return this.[[OutgoingMaxDatagramSize]].
</dd>

	<dt>
`outgoingMaxAge@mD
◎
outgoingMaxAge, of type unrestricted double, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレの `OutgoingDatagramsExpirationDuration$sl
◎
The getter steps are:
• Return this’s [[OutgoingDatagramsExpirationDuration]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~EQ 0
］
⇒
%値 ~SET ~NULL
◎
If value is 0, set value to null.
</li>
			<li>
コレ . `OutgoingDatagramsExpirationDuration$sl ~SET %値
◎
Set this.[[OutgoingDatagramsExpirationDuration]] to value.
</li>
		</ol>
	</dd>

	<dt>
`incomingHighWaterMark@mD
◎
incomingHighWaterMark, of type unrestricted double
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingDatagramsHighWaterMark$sl
◎
The getter steps are:
• Return this.[[IncomingDatagramsHighWaterMark]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~LT 1
］
⇒
%値 ~SET 1
◎
If value is &lt; 1, set value to 1.
</li>
			<li>
コレ . `IncomingDatagramsHighWaterMark$sl ~SET %値
◎
Set this.[[IncomingDatagramsHighWaterMark]] to value.
</li>
		</ol>
	</dd>

	<dt>
`outgoingHighWaterMark@mD
◎
outgoingHighWaterMark, of type unrestricted double
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `OutgoingDatagramsHighWaterMark$sl
◎
The getter steps are:
• Return this.[[OutgoingDatagramsHighWaterMark]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~LT 1
］
⇒
%値 ~SET 1
◎
If value is &lt; 1, set value to 1.
</li>
			<li>
コレ . `OutgoingDatagramsHighWaterMark$sl ~SET %値
◎
Set this.[[OutgoingDatagramsHighWaterMark]] to value.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="datagram-duplex-stream-procedures">
<h3 title="Procedures">5.4. 手続-</h3>

<div class="algo">
<p>
`~datagram群を~pullする@
~algoは、
所与の
( `WebTransport$I ~obj %~transport )
に対し：
◎
To pullDatagrams, given a WebTransport object transport, run these steps:
</p>
<ol>
	<li>
%~datagram群 ~LET %~transport . `Datagrams$sl
◎
Let datagrams be transport.[[Datagrams]].
</li>
	<li>
~Assert：
%~datagram群 . `IncomingDatagramsPullPromise$sl ~EQ ~NULL
◎
Assert: datagrams.[[IncomingDatagramsPullPromise]] is null.
</li>
	<li>
%~queue ~LET %~datagram群 . `IncomingDatagramsQueue$sl
◎
Let queue be datagrams.[[IncomingDatagramsQueue]].
</li>
	<li>
<p>
~IF［
%~queue は空である
］：
◎
If queue is empty, then:
</p>
		<ol>
			<li>
%~datagram群 . `IncomingDatagramsPullPromise$sl ~SET `新たな~promise$
◎
Set datagrams.[[IncomingDatagramsPullPromise]] to a new promise.
</li>
			<li>
~RET %~datagram群 . `IncomingDatagramsPullPromise$sl
◎
Return datagrams.[[IncomingDatagramsPullPromise]].
</li>
		</ol>
	</li>
	<li>
( %~datagram, %時刻印 ) ~LET %~queue から`~dequeueする$
◎
Let datagram and timestamp be the result of dequeuing queue.
</li>
	<li>
%~view ~LET %~datagram群 . `Readable$sl 用の`現在の~BYOB要請~view$RS
◎
↓</li>
	<li>
<p>
~IF［
%~view ~NEQ ~NULL
］：
◎
If datagrams.[[Readable]]’s current BYOB request view is not null, then:
</p>
		<ol>
			<li>
~IF［
%~view の`~byte長さ$BS ~LT %~datagram の~size
］
⇒
~RET `却下される~promise$( `RangeError$E )
◎
Let view be datagrams.[[Readable]]’s current BYOB request view.
◎
If view’s byte length is less than the size of datagram, return a promise rejected with a RangeError.
</li>
			<li>
%要素~size ~LET 0
◎
↓</li>
			<li>
~IF［
%~view は `TypedArrayName^sl 内部~slotを有する
（すなわち， %~view は `DataView$I でない）
］
⇒
`有型~配列~構築子~表t＠~ECMA262#table-49$にて指定される［
%~view . `TypedArrayName^sl
］用の要素~size
◎
Let elementSize be the element size specified in the typed array constructors table for view.[[TypedArrayName]]. If view does not have a [[TypedArrayName]] internal slot (i.e. it is a DataView), let elementSize be 0.
</li>
	<li>
~IF［
%要素~size ~NEQ 1
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If elementSize is not 1, return a promise rejected with a TypeError.
</li>
		</ol>
	</li>
	<li>
%~datagram群 . `Readable$sl の中へ`~byte列から~pullする$RS( %~datagram )
◎
Pull from bytes datagram into datagrams.[[Readable]].
</li>
	<li>
~RET `解決される~promise$( `undefined^jv )
◎
Return a promise resolved with undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`~datagram群を受信する@
~algoは、
所与の
( `WebTransport$I ~obj %~transport )
に対し：
◎
To receiveDatagrams, given a WebTransport object transport, run these steps:
</p>
<ol>
	<li>
%時刻印 ~LET 今を表現している時刻印
◎
Let timestamp be a timestamp representing now.
</li>
	<li>
%~queue ~LET %~datagram群 . `IncomingDatagramsQueue$sl
◎
Let queue be datagrams.[[IncomingDatagramsQueue]].
</li>
	<li>
%所要時間 ~LET %~datagram群 . `IncomingDatagramsExpirationDuration$sl
◎
Let duration be datagrams.[[IncomingDatagramsExpirationDuration]].
</li>
	<li>
~IF［
%所要時間 ~EQ ~NULL
］
⇒
%所要時間 ~SET `実装定義$な値
◎
If duration is null, then set duration to an implementation-defined value.
</li>
	<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
	<li>
<p>
~WHILE［
%~session 上に可用な流入~datagramは在る
【！`~datagramを受信する$】
］：
◎
While there are available incoming datagrams on session:
</p>
		<ol>
			<li>
%~datagram ~LET `~datagramを受信する$( %~session )
◎
Let datagram be the result of receiving a datagram with session.
</li>
			<li>
%~chunk ~LET ( %~datagram, 今を表現している時刻印 ) が成す~pair
◎
Let timestamp be a timestamp representing now.
◎
Let chunk be a pair of datagram and timestamp.
</li>
			<li>
%~queue に %~chunk を`~enqueueする$
◎
Enqueue chunk to queue.
</li>
		</ol>
	</li>
	<li>
%除去する個数 ~LET %~queue の`~size$【！長さ】 ~MINUS %~datagram群 . `IncomingDatagramsHighWaterMark$sl
◎
Let toBeRemoved be the length of queue minus datagrams.[[IncomingDatagramsHighWaterMark]].
</li>
	<li>
~WHILE［
%除去する個数 ~GTE 1
【！rounded down＠https://tc39.github.io/ecma262/#eqn-floor$ 】
］
⇒＃
%~queue から`~dequeueする$；
%除去する個数 ~DECBY 1
◎
If toBeRemoved is positive, repeat dequeuing queue toBeRemoved (rounded down) times.
</li>
	<li>
<p>
~WHILE［
%~queue は空でない
］：
◎
While queue is not empty:
</p>
		<ol>
			<li>
~IF［
%~queue[ 0 ][ 1 ] から［
今を表現している時刻印
］までを成す~milli秒数 ~LTE %所要時間
］
⇒
~BREAK
◎
Let bytes and timestamp be queue’s first element.
◎
If more than duration milliseconds have passed since timestamp, then dequeue queue.
◎
Otherwise, break this loop.
</li>
			<li>
%~queue から`~dequeueする$
◎
↑</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~queue は空でない
］~AND［
%~datagram群 . `IncomingDatagramsPullPromise$sl ~NEQ ~NULL
］：
◎
If queue is not empty and datagrams.[[IncomingDatagramsPullPromise]] is non-null, then:
</p>
		<ol>
			<li>
( %~byte列, %時刻印 ) ~LET %~queue から`~dequeueする$
◎
Let bytes and timestamp be the result of dequeuing queue.
</li>
			<li>
%~promise ~LET %~datagram群 . `IncomingDatagramsPullPromise$sl
◎
Let promise be datagrams.[[IncomingDatagramsPullPromise]].
</li>
			<li>
%~datagram群 . `IncomingDatagramsPullPromise$sl ~SET ~NULL
◎
Set datagrams.[[IncomingDatagramsPullPromise]] to null.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
				<ol>
					<li>
%~chunk ~LET %~byte列 を表現している新たな `Uint8Array$I ~obj
◎
Let chunk be a new Uint8Array object representing bytes.
</li>
					<li>
%~datagram群 . `Readable$sl に`~chunkを~enqueueする$RS( %~chunk )
◎
Enqueue chunk to datagrams.[[Readable]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは、
次に従うベキである
⇒
`WebTransport$I ~objが［
その `State$sl ~EQ `connected^l
］を満たす間は
⇒
`~datagram群を受信する$
~algoが進捗を為せるようになったときには、
アリな限り適度に早く，それを走らす
◎
The user agent SHOULD run receiveDatagrams for any WebTransport object whose [[State]] is "connected" as soon as reasonably possible whenever the algorithm can make progress.
</p>

		</section>
	</section>
	<section id="web-transport">
<h2 title="WebTransport Interface">6. `WebTransport^I ~interface</h2>

<p>
`WebTransport$I は、［
`WEB-TRANSPORT-OVERVIEW$r にて定義される下層~transportの機能性
］への~APIを供する。
◎
WebTransport provides an API to the underlying transport functionality defined in [WEB-TRANSPORT-OVERVIEW].
</p>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransport@I {
  `constructor＠#dom-webtransport-webtransport$(`USVString$ %url, optional `WebTransportOptions$I %options = {});

  `Promise$&lt;`WebTransportConnectionStats$I&gt; `getStats$mT();
  readonly attribute `Promise$&lt;`undefined$&gt; `ready$mT;
  readonly attribute `WebTransportReliabilityMode$I `reliability$mT;
  readonly attribute `WebTransportCongestionControl$I `congestionControl$mT;
  [`EnforceRange$] attribute `unsigned short$? `anticipatedConcurrentIncomingUnidirectionalStreams$mT;
  [`EnforceRange$] attribute `unsigned short$? `anticipatedConcurrentIncomingBidirectionalStreams$mT;
  readonly attribute DOMString `protocol$mT;

  readonly attribute `Promise$&lt;`WebTransportCloseInfo$I&gt; `closed$mT;
  readonly attribute `Promise$&lt;`undefined$&gt; `draining$mT;
  `undefined$ `close$mT(optional `WebTransportCloseInfo$I %closeInfo = {});

  readonly attribute `WebTransportDatagramDuplexStream$I `datagrams$mT;

  `Promise$&lt;`WebTransportBidirectionalStream$I&gt; `createBidirectionalStream$mT(
      optional `WebTransportSendStreamOptions$I %options = {});
  /* <span class="comment">
`WebTransportBidirectionalStream$I ~objの `ReadableStream$I
◎
a ReadableStream of WebTransportBidirectionalStream objects
</span> */
  readonly attribute `ReadableStream$I `incomingBidirectionalStreams$mT;

  `Promise$&lt;`WebTransportSendStream$I&gt; `createUnidirectionalStream$mT(
      optional `WebTransportSendStreamOptions$I %options = {});
  /* <span class="comment">
`WebTransportReceiveStream$I ~objの `ReadableStream$I
◎
a ReadableStream of WebTransportReceiveStream objects
</span> */
  readonly attribute `ReadableStream$I `incomingUnidirectionalStreams$mT;
  `WebTransportSendGroup$I `createSendGroup$mT();

  static readonly attribute `boolean$ `supportsReliableOnly$mT;
};

enum `WebTransportReliabilityMode@I {
  `pending@l,
  `reliable-only@l,
  `supports-unreliable@l,
};
</pre>

		<section id="webtransport-internal-slots">
<h3 title="Internal slots">6.1. 内部~slot</h3>

<p>
各 `WebTransport$I %~transport は、
次に挙げる内部~slotを有する
— 各項に与える【~data型~以外の】記述は規範的ではない：
◎
A WebTransport object has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`SendStreams@sl</dt>
	<dd>
`有順序~集合$
◎
An ordered set＼
</dd>
	<dd>
%~transport に所有されている `WebTransportSendStream$I たちからなる
◎
An ordered set of WebTransportSendStreams owned by this WebTransport.
</dd>

	<dt>`ReceiveStreams@sl</dt>
	<dd>
`有順序~集合$
◎
An ordered set＼
</dd>
	<dd>
%~transport に所有されている `WebTransportReceiveStream$I たちからなる
◎
of WebTransportReceiveStreams owned by this WebTransport.
</dd>

	<dt>`IncomingBidirectionalStreams@sl</dt>
	<dt>`IncomingUnidirectionalStreams@sl</dt>
	<dd>
いずれも，ある `ReadableStream$I
◎
A ReadableStream＼
</dd>
	<dd>
順に，~serverから受信した［
双方向~streamを表現する `WebTransportBidirectionalStream$I たち／
一方向~streamを表現する `WebTransportReceiveStream$I たち
］からなる†
◎
consisting of WebTransportBidirectionalStream objects.
◎
IncomingUnidirectionalStreams
◎
A ReadableStream consisting of WebTransportReceiveStreams.
</dd>
	<dd class="trans-note">【†
“からなる（ `consisting of^en ）”
とは、
これら各~objが `ReadableStream$I に~chunkとして~enqueueされることを意味する
— ［
`双方向~streamを~pullする$, `一方向~streamを~pullする$
］を見よ。
】</dd>
	<dd class="note">注記：
流入~stream上にすでに~dataがあるかどうかは、
~serverの挙動に依存することになる。
【！Note: Whether the incoming streams already have data on them will depend on server behavior.】
</dd>

	<dt>`State@sl</dt>
	<dd>
次に挙げるいずれか
⇒＃
`connecting^l,
`connected^l,
`draining^l,
`closed^l,
`failed^l
◎
An enum indicating the state of the transport. One of "connecting", "connected", "draining", "closed", and "failed".
</dd>
	<dd>
%~transport の状態を指示する
◎
↑</dd>

	<dt>`Ready@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
`~WebTransport~sessionを確立する$ことに
⇒＃
成功したとき充足される／
失敗したとき却下される
◎
fulfilled when the associated WebTransport session gets established, or rejected if the establishment process failed.
</dd>

	<dt>`Reliability@sl</dt>
	<dd>
ある `WebTransportReliabilityMode$I
◎
A WebTransportReliabilityMode＼
</dd>
	<dd>
接続が確立されるまでは `pending$l を返す。
それ以降は、
接続が［
`不依拠-可能$な（~UDP越し）~transportを~supportするならば `supports-unreliable$l ／
`依拠-可能$な（~fallbackによる~TCP越し）~transportしか~supportしないならば `reliable-only$l
］を返す。
◎
indicating whether the first hop supports unreliable (UDP) transport or whether only reliable (TCP fallback) transport is available.＼
◎
Returns "pending" until a connection has been established.
</dd>

	<dt>`CongestionControl@sl</dt>
	<dd>
ある `WebTransportCongestionControl$I
◎
A WebTransportCongestionControl＼
</dd>
	<dd>
応用により［
~throughput／短い待時間
］用に最適化された輻輳~制御~algoが要請され，~UAにより満足されたならば、
その選好を
【 `throughput$l ／ `low-latency$l として】
指示する。
他の場合は `default$l になる。
◎
indicating whether a preference for a congestion control algorithm optimized for throughput or low latency was requested by the application and satisfied by the user agent, or "default".
</dd>

	<dt>`AnticipatedConcurrentIncomingUnidirectionalStreams@sl</dt>
	<dd>
~NULL ／ ある整数
◎
↓</dd>
	<dd>
~NULL でない場合、［
同時並行に~openな，`流入~一方向$な~streamたち
］として［
~serverが作成するものと応用が見越す個数
］を与える。
◎
The number of concurrently open incoming unidirectional streams the application anticipates the server creating, or null.
</dd>

	<dt>`AnticipatedConcurrentIncomingBidirectionalStreams@sl</dt>
	<dd>
~NULL ／ ある整数
◎
↓</dd>
	<dd>
~NULL でない場合、［
同時並行に~openな，`双方向$な~streamたち
］として［
~serverが作成するものと応用が見越す個数
］を与える。
◎
The number of concurrently open bidirectional streams the application anticipates the server creating, or null.
</dd>

	<dt>`Protocol@sl</dt>
	<dd>
ある文字列
◎
A string＼
</dd>
	<dd>
~serverにより選定された応用~levelの~protocolを指示する。
◎
indicating the application-level protocol selected by the server, if any.＼
</dd>
	<dd>
初期~時は空~文字列とする。
◎
Initially an empty string.
</dd>

	<dt>`Closed@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
%~transport が
⇒＃
上品に~closeされたとき充足される／
中途で~closeされたとき却下される／
初期化に失敗したとき却下される
◎
fulfilled when the associated WebTransport object is closed gracefully, or rejected when it is closed abruptly or failed on initialization.
</dd>

	<dt>`Draining@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
%~transport が［
`DRAIN_WEBTRANSPORT_SESSION$ft `~capsule$ ／
`GOAWAY$ft ~frame
］を受信したとき充足される。
◎
fulfilled when the associated WebTransport session receives a DRAIN_WEBTRANSPORT_SESSION capsule or a GOAWAY frame.
</dd>

	<dt>`Datagrams@sl</dt>
	<dd>
ある `WebTransportDatagramDuplexStream$I
◎
A WebTransportDatagramDuplexStream.
</dd>
	<dd>
この~session越しに~datagram群を［
送信する／受信する
］ための単独の二重化~stream。
◎
↓↓</dd>

	<dt>`Session@sl</dt>
	<dd>
~NULL ／
%~transport 用の`~WebTransport~session$
◎
A WebTransport session for this WebTransport object, or null.
</dd>
</dl>

		</section>
		<section id="webtransport-constructor">
<h3 title="Constructor">6.2. 構築子</h3>

<div class="algo">
<p>
`new WebTransport(url, options)@m
構築子手続きは：
◎
When the WebTransport() constructor is invoked, the user agent MUST run the following steps:
</p>
<ol>
	<li>
%基底~URL ~LET コレに`関連な設定群~obj$の`~API用~基底~URL$enV
◎
Let baseURL be this’s relevant settings object’s API base URL.
</li>
	<li>
%構文解析した~URL ~LET `~URL構文解析する$( %url, %基底~URL )
◎
Let parsedURL be the URL record resulting from parsing url with baseURL.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is a failure, throw a SyntaxError exception.
</li>
	<li>
~IF［
%構文解析した~URL の`~scheme$url ~NEQ `https^l
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL scheme is not https, throw a SyntaxError exception.
</li>
	<li>
~IF［
%構文解析した~URL の`素片$url  ~NEQ ~NULL
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL fragment is not null, throw a SyntaxError exception.
</li>
	<li>
%専用か ~LET ~IS［
%options[ "`allowPooling$mb" ] ~EQ ~F
］
◎
Let allowPooling be options’s allowPooling.
◎
Let dedicated be the negation of allowPooling.
</li>
	<li>
%~server証明書~hash群 ~LET %options[ "`serverCertificateHashes$mb" ]
◎
Let serverCertificateHashes be options’s serverCertificateHashes if it exists, and null otherwise.
</li>
	<li>
~IF［
%~server証明書~hash群 ~EQ ε
］
⇒
%~server証明書~hash群 ~SET ~NULL
◎
↑</li>
	<li>
~IF［
%専用か ~EQ ~F
］~AND［
%~server証明書~hash群 ~NEQ ~NULL
］
⇒
~THROW `NotSupportedError$E
◎
If dedicated is false and serverCertificateHashes is non-null, then throw a NotSupportedError exception.
</li>
	<li>
%不依拠-可能が要求されるか ~LET %options[ "`requireUnreliable$mb" ]
◎
Let requireUnreliable be options’s requireUnreliable.
</li>
	<li>
%輻輳~制御 ~LET %options[ "`congestionControl$mb" ]
◎
Let congestionControl be options’s congestionControl.
</li>
	<li>
~IF［
%輻輳~制御 ~NEQ `default^l
］~AND［［
%輻輳~制御 用に最適化するための輻輳~制御~algo
］として［
`RFC9002$r `§ 7＠~RFCx/rfc9002#section-7$ により許容されるもの
］のうち［
~UAが~supportするもの
］は無い
］
⇒
%輻輳~制御 ~SET `default^l
◎
If congestionControl is not "default", and the user agent does not support any congestion control algorithms that optimize for congestionControl, as allowed by [RFC9002] Section 7, then set congestionControl to "default".
</li>
	<li>
%~protocol群 ~LET %options[ "`protocols$mb" ]
◎
Let protocols be options’s protocols
</li>
	<li>
<p>
~IF［
%~protocol群 を成す ある~itemの値は ~AND↓ を満たさない
］…
</p>
		<ul>
			<li>
%~protocol群 を成す他の~itemの値に一致しない
</li>
			<li>
~WebTransport~protocolにより定義されるとおり，
`WT-Protocol$h の~field値を成すための要件を満たす
</li>
			<li>
次の結果の長さ ~IN { 1 〜 512 }
⇒
`同型に符号化する$( 当の~itemの値 )
</li>
		</ul>
<p>
…ならば
⇒
~THROW `SyntaxError$E
</p>

<p>
`WEB-TRANSPORT-HTTP3$r `§ 応用~protocolの折衝＠~WT-HTTP3#subprotocol-negotiation$ を見よ。
</p>
◎
If any of the values in protocols occur more than once, fail to match the requirements for elements that comprise the value of WT-Protocol fields as defined by the WebTransport protocol, or have an isomorphic encoded length of 0 or exceeding 512, throw a SyntaxError exception. [WEB-TRANSPORT-HTTP3] Section 3.4.
</li>
	<li>
%見越される同時並行な流入~一方向~stream数 ~LET %options[ "`anticipatedConcurrentIncomingUnidirectionalStreams$mb" ]
◎
Let anticipatedConcurrentIncomingUnidirectionalStreams be options’s anticipatedConcurrentIncomingUnidirectionalStreams.
</li>
	<li>
%見越される同時並行な流入~双方向~stream数 ~LET %options[ "`anticipatedConcurrentIncomingBidirectionalStreams$mb" ]
◎
Let anticipatedConcurrentIncomingBidirectionalStreams be options’s anticipatedConcurrentIncomingBidirectionalStreams.
</li>
	<li>
%流入~datagram群 ~LET `新たな~obj$( `ReadableStream$I )
◎
Let incomingDatagrams be a new ReadableStream.
</li>
	<li>
%~datagram群 ~LET `WebTransportDatagramDuplexStream$I を`作成する$DPS( %流入~datagram群 )
◎
Let datagrams be the result of creating a WebTransportDatagramDuplexStream, its readable set to incomingDatagrams.
</li>
	<li>
%~transport ~LET `新たな~obj$( `WebTransport$I )
— その
⇒＃
`SendStreams$sl ~SET 新たな`有順序~集合$,
`ReceiveStreams$sl ~SET 新たな`有順序~集合$,
`IncomingBidirectionalStreams$sl ~SET `新たな~obj$( `ReadableStream$I ),
`IncomingUnidirectionalStreams$sl ~SET `新たな~obj$( `ReadableStream$I ),
`State$sl ~SET `connecting^l,
`Ready$sl ~SET `新たな~promise$,
`Reliability$sl ~SET `pending^l,
`CongestionControl$sl ~SET %輻輳~制御,
`AnticipatedConcurrentIncomingUnidirectionalStreams$sl ~SET %見越される同時並行な流入~一方向~stream数,
`AnticipatedConcurrentIncomingBidirectionalStreams$sl ~SET %見越される同時並行な流入~双方向~stream数,
`Protocol$sl ~SET 空~文字列,
`Closed$sl ~SET `新たな~promise$,
`Draining$sl ~SET `新たな~promise$,
`Datagrams$sl ~SET %~datagram群,
`Session$sl ~SET ~NULL
◎
Let transport be a newly constructed WebTransport object, with:
• [[SendStreams]]
•• an empty ordered set
• [[ReceiveStreams]]
•• an empty ordered set
• [[IncomingBidirectionalStreams]]
•• a new ReadableStream
• [[IncomingUnidirectionalStreams]]
•• a new ReadableStream
• [[State]]
•• "connecting"
• [[Ready]]
•• a new promise
• [[Reliability]]
•• "pending"
• [[CongestionControl]]
•• congestionControl
• [[AnticipatedConcurrentIncomingUnidirectionalStreams]]
•• anticipatedConcurrentIncomingUnidirectionalStreams
• [[AnticipatedConcurrentIncomingBidirectionalStreams]]
•• anticipatedConcurrentIncomingBidirectionalStreams
• [[Protocol]]
•• an empty string
• [[Closed]]
•• a new promise
• [[Draining]]
•• a new promise
• [[Datagrams]]
•• datagrams
• [[Session]]
•• null
</li>
	<li>
<p>
%流入~datagram群 を`~byte読取り~support付きで設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET 次を走らす動作
⇒
`~datagram群を~pullする$( %~transport )
</li>
			<li>
`限界水位^i ~SET 0
</li>
		</ul>

<p class="note">注記：
各~datagramには 64kB ~bufferを利用することが推奨される
— ［
~WebTransportにおける~datagramの実質的な最大~frame~size
］には，上界として［
~QUICにおける~datagramの最大~frame~size
］があり、
それには 64kB が推奨されるので
（ `QUIC-DATAGRAM$r `§ 3＠~RFCx/rfc9221#section-3$
を見よ）。
これは、［
ある~datagramが~bufferより大きいことに因り，当の~streamが~errorする
］ことは生じないことを確保する。
</p>
◎
Let pullDatagramsAlgorithm be an action that runs pullDatagrams with transport.
◎
Note: Using 64kB buffers with datagrams is recommended because the effective maximum WebTransport datagram frame size has an upper bound of the QUIC maximum datagram frame size which is recommended to be 64kB (See [QUIC-DATAGRAM] Section 3). This will ensure the stream is not errored due to a datagram being larger than the buffer.
◎
Set up with byte reading support incomingDatagrams with pullAlgorithm set to pullDatagramsAlgorithm, and highWaterMark set to 0.
</li>
	<li>
<p>
%~transport . `IncomingBidirectionalStreams$sl を`設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET 次を走らす動作
⇒
`双方向~streamを~pullする$( %~transport )
</li>
			<li>
`限界水位^i ~SET 0
</li>
		</ul>
◎
Let pullBidirectionalStreamAlgorithm be an action that runs pullBidirectionalStream with transport.
◎
Set up transport.[[IncomingBidirectionalStreams]] with pullAlgorithm set to pullBidirectionalStreamAlgorithm, and highWaterMark set to 0.
</li>
	<li>
<p>
%~transport . `IncomingUnidirectionalStreams$sl を`設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET 次を走らす動作
⇒
`一方向~streamを~pullする$( %~transport )
</li>
			<li>
`限界水位^i ~SET 0
</li>
		</ul>
◎
Let pullUnidirectionalStreamAlgorithm be an action that runs pullUnidirectionalStream with transport.
◎
Set up transport.[[IncomingUnidirectionalStreams]] with pullAlgorithm set to pullUnidirectionalStreamAlgorithm, and highWaterMark set to 0.
</li>
	<li>
`~HTTP越しの~WebTransportを初期化する$( ↓ )
⇒＃
%~transport,
%構文解析した~URL,
%専用か,
%不依拠-可能が要求されるか,
%輻輳~制御,
%~protocol群,
%~server証明書~hash群
◎
Initialize WebTransport over HTTP with transport, parsedURL, dedicated, requireUnreliable, congestionControl, protocols, and serverCertificateHashes.
</li>
	<li>
~RET %~transport
◎
Return transport.
</li>
</ol>
</div>

<div class="algo">
<p>
`~HTTP越しの~WebTransportを初期化する@
~algoは、
所与の
⇒＃
`WebTransport$I ~obj %~transport,
`~URL~record$ %~URL,
真偽値 %専用か,
真偽値 %不依拠-可能が要求されるか,
`WebTransportCongestionControl$I %輻輳~制御,
文字列たちが成す連列 %~protocol群 【！array】,
`WebTransportHash$I たちが成す連列 %~server証明書~hash群
◎終
に対し：
◎
To initialize WebTransport over HTTP, given a WebTransport object transport, a URL record url, a boolean dedicated, a boolean requireUnreliable, a WebTransportCongestionControl congestionControl, a protocols array, and a sequence&lt;WebTransportHash&gt; serverCertificateHashes, run these steps.
</p>
<ol>
	<li>
%~client ~LET %~transport に`関連な設定群~obj$
◎
Let client be transport’s relevant settings object.
</li>
	<li>
%生成元 ~LET %~client の`生成元$enV
◎
Let origin be client’s origin.
</li>
	<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET %~client,
`施策~容器$rq ~SET %~client の`施策~容器$enV,
`行先$rq ~SET 空~文字列,
`生成元$rq ~SET %生成元,
`~redirect~mode$rq ~SET `error^l
◎
Let request be a new request whose URL is url, client is client, policy container is client’s policy container, destination is an empty string, origin is origin and redirect mode is "error".
</li>
	<li>
`要請に対する~CSP違反を報告する$( %要請 )
◎
Run report Content Security Policy violations for request.
</li>
	<li>
<p>
~IF［
`要請は~CSPにより阻止されるべきか？$( %要請 ) ~EQ `阻止される^i
］~OR［
`~fetchingは，不良~portに因り阻止されるべきか？$( %要請 ) ~EQ `阻止される^i
］：
◎
If should request be blocked by Content Security Policy? with request returns "Blocked", or if request should be blocked due to a bad port returns blocked, then abort the remaining steps and＼
</p>
		<ol>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
					<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
					<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
				</ol>
</div>
			</li>
			<li>
~RET
◎
↑↑</li>
		</ol>
	</li>
	<li>
%~network区分~key ~LET `~network区分~keyを決定する$( %~transport に`関連な設定群~obj$ )
◎
Let networkPartitionKey be the result of determining the network partition key with transport’s relevant settings object.
</li>
	<li class="algo">
<p>
この段は、
`並列的$に走らすことに加え：
◎
Run the following steps in parallel,＼
</p>
		<ul>
			<li>
次が満たされた`ときは中止する$
⇒
%~transport . `State$sl ~IN { `closed^l, `failed^l }
◎
but abort when transport.[[State]] becomes "closed" or "failed":
</li>
		</ul>
		<ol>
			<li>
%新たな接続 ~LET %専用か に応じて
⇒＃
~F ならば `no^l／
~T ならば `yes-and-dedicated^l
◎
Let newConnection be "no" if dedicated is false; otherwise "yes-and-dedicated".
</li>
			<li>
<p>
%接続 ~LET `接続を得する$( ↓ )
⇒＃
%~network区分~key,
%~URL,
~F,
%新たな接続,
%不依拠-可能が要求されるか
◎
Let connection be the result of obtaining a connection with networkPartitionKey, url, false, newConnection, and requireUnreliable.＼
</p>
<div>
<p>
— 次に従う下で：
</p>
				<ul>
					<li>
~UAは，複数の輻輳~制御~algoを~supportする場合、［
この %接続 上に~dataを送信するためとして，
%輻輳~制御 用に適切なもの
］を選ぶ。
</li>
					<li>
<p>
%~server証明書~hash群 が指定された【空でない】場合：
</p>
						<ul>
							<li>
接続を得するときは，証明書は
— 既定の証明書~検証y~algoを利用する代わりに —
次を満たす場合に妥当であるものと見なす
⇒
［
`~custom証明書~要件$を満たす
］~AND［
`証明書~hashを検証yする$( %~server証明書~hash群 ) の結果 ~EQ ~T
］
</li>
							<li>
前項の条件が満たされない場合
⇒
%接続 ~SET `失敗^i
</li>
						</ul>
					</li>
				</ul>
◎
If the user agent supports more than one congestion control algorithm, choose one appropriate for congestionControl for sending of data on this connection. When obtaining a connection, if serverCertificateHashes is specified, instead of using the default certificate verification algorithm, consider the certificate valid if it meets the custom certificate requirements and if verifying the certificate hash against serverCertificateHashes returns true. If either condition is not met, let connection be failure.
</div>

			</li>
			<li>
<p>
~IF［
%接続 ~EQ `失敗^i
］：
◎
If connection is failure, then abort the remaining steps and＼
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
							<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
							<li>
<p>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</p>

<p class="note">注記：
~redirectは追従されない
【 %要請 の`~redirect~mode$rqは `error^l に設定されたので】。
~redirectionにより生じる~network~errorは、
意図的に，他の~network~errorと判別-不能になる。
非同一-生成元な文脈においては、
これ【追従すること？】は，［
通常は~CORSにより阻止されることになる情報
］を露呈することになる。
同一-生成元な文脈においては、
これは，［
情報を渡すための行路として~handshakeを濫用する
］よう応用に奨励するかもしれない。
◎
Note: Redirects are not followed. Network errors caused by redirection are intentionally indistinguishable from other network errors. In cross-origin contexts, this would reveal information that would normally be blocked by CORS. In same-origin contexts, it might encourage applications to abuse the handshake as a vector for passing information.
</p>
							</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
↑↑</li>
				</ol>
			</li>
			<li>
%接続 から最初の `SETTINGS$ft ~frameを受信するまで待機する
◎
Wait for connection to receive the first SETTINGS frame,＼
</li>
			<li>
%設定群 ~LET 前~段の `SETTINGS$ft ~frameを表現する辞書
◎
and let settings be a dictionary that represents the SETTINGS frame.
</li>
			<li>
<p>
~IF［
%設定群 [ "`SETTINGS_ENABLE_WEBTRANPORT^sp" ] ~NEQ 1
］~OR［
%設定群 [ "`H3_DATAGRAM^sp" ] ~NEQ 1
］：
◎
If settings doesn’t contain SETTINGS_ENABLE_WEBTRANPORT with a value of 1, or it doesn’t contain H3_DATAGRAM with a value of 1, then abort the remaining steps and＼
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
							<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
							<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
↑↑</li>
				</ol>
			</li>
			<li>
<p>
%~session ~LET `~WebTransport~sessionを確立する$( %生成元, %~protocol群 ) `on^en %接続
◎
Establish a WebTransport session with origin and protocols on connection.
</p>

<p class="note">注記：
この段は、［
`QUIC-DATAGRAM$r にて指定される，~transport~parameterの交換
］も包含する。
◎
Note: This step also contains the transport parameter exchange specified in [QUIC-DATAGRAM].
</p>
			</li>
			<li>
<p>
~IF［
%~session ~EQ `失敗^i
］：
◎
If the previous step fails, abort the remaining steps and＼
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
							<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
							<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
↑↑</li>
				</ol>
			</li>
			<li>
~Assert：
%maxDatagramSize は整数である。
【未定義な変数。前後との関係が不明で意図不明な段。】
◎
↑↑ Let session be the established WebTransport session.
◎
Assert: maxDatagramSize is an integer.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
%~transport . `State$sl ~NEQ `connecting^l
］：
◎
If transport.[[State]] is not "connecting":
</p>
						<ol>
							<li class="algo">
この段は`並列的$に走らす
⇒
`~WebTransport~sessionを終了する$( %~session )
◎
In parallel, terminate session.
</li>
							<li>
~RET
◎
Abort these steps.
</li>
						</ol>
					</li>
				</ol>
</div>
			</li>
			<li>
%~transport . `State$sl ~SET `connected^l
◎
Set transport.[[State]] to "connected".
</li>
			<li>
%~transport . `Session$sl ~SET %~session
◎
Set transport.[[Session]] to session.
</li>
			<li>
%~transport . `Protocol$sl ~SET 空~文字列
◎
↓</li>
			<li>
<p>
`WEB-TRANSPORT-HTTP3$r `§ 応用~protocolの折衝＠~WT-HTTP3#subprotocol-negotiation$ に従って
⇒
~IF［
当の `CONNECT$M 要請に対する `2xx$st 応答~内に `WT-Protocol$h ~headerは在る
］
⇒
%~transport . `Protocol$sl ~SET 当の~headerの値を成す文字列
◎
Set transport.[[Protocol]] to either the string value of the WT-Protocol header field in the 2xx response to the CONNECT request if present, following [WEB-TRANSPORT-HTTP3] Section 3.4, or "" if not present.
</p>

<p class="note">注記：
これは、
代わりに `WEB-TRANSPORT-OVERVIEW$r を参照するべきである
— その`課題 #15＠https://github.com/ietf-wg-webtrans/draft-ietf-webtrans-overview/issues/15$
が解決されたなら。
◎
This should reference [WEB-TRANSPORT-OVERVIEW] instead pending issue 15.
</p>
			</li>
			<li>
%~transport . `Reliability$sl ~SET %接続 【！the connection】に応じて
⇒＃
~HTTP3接続であるならば `supports-unreliable$l ／
~HTTP2接続である `WEB-TRANSPORT-HTTP2$r ならば `reliable-only$l
◎
If the connection is an HTTP/3 connection, set transport’s [[Reliability]] to "supports-unreliable".
◎
If the connection is an HTTP/2 connection [WEB-TRANSPORT-HTTP2], set transport’s [[Reliability]] to "reliable-only".
</li>
			<li>
`~promiseを解決する$( %~transport . `Ready$sl )
◎
Resolve transport.[[Ready]] with undefined.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`双方向~streamを~pullする@
~algoは、
所与の
( `WebTransport$I ~obj %~transport )
に対し：
◎
To pullBidirectionalStream, given a WebTransport object transport, run these steps.
</p>
<ol>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
~RET %~transport . `Ready$sl の`充足-時$に次の手続きを遂行するようにする：
◎
If transport.[[State]] is "connecting", then return the result of performing the following steps upon fulfillment of transport.[[Ready]]:
</p>

<div class="algo">
手続きは
⇒
~RET `双方向~streamを~pullする$( %~transport )
◎
Return the result of pullBidirectionalStream with transport.
</div>
	</li>
	<li>
~IF［
%~transport . `State$sl ~NEQ `connected^l
］
⇒
~RET `却下される~promise$( `InvalidStateError$E )
◎
If transport.[[State]] is not "connected", then return a new rejected promise with an InvalidStateError.
</li>
	<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~session に可用な流入~双方向~streamが在るようになるまで待機する
【！`双方向~streamを受信する$】
◎
Wait until there is an available incoming bidirectional stream.
</li>
			<li>
%内部~stream ~LET `双方向~streamを受信する$( %~session )
◎
Let internalStream be the result of receiving a bidirectional stream.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream ~LET `WebTransportBidirectionalStream$I を`作成する$wtB( %内部~stream, %~transport )
◎
Let stream be the result of creating a WebTransportBidirectionalStream with internalStream and transport.
</li>
					<li>
%~transport . `IncomingBidirectionalStreams$sl に`~chunkを~enqueueする$RS( %~stream )
◎
Enqueue stream to transport.[[IncomingBidirectionalStreams]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve p with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>
</div>

<div class="algo">
<p>
`一方向~streamを~pullする@
~algoは、
所与の
( `WebTransport$I ~obj %~transport )
に対し：
◎
To pullUnidirectionalStream, given a WebTransport object transport, run these steps.
</p>
<ol>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
~RET %~transport . `Ready$sl の`充足-時$に次の手続きを遂行するようにする：
◎
If transport.[[State]] is "connecting", then return the result of performing the following steps upon fulfillment of transport.[[Ready]]:
</p>

<div class="algo">
手続きは
⇒
~RET `一方向~streamを~pullする$( %~transport )
◎
Return the result of pullUnidirectionalStream with transport.
</div>
	</li>
	<li>
~IF［
%~transport . `State$sl ~NEQ `connected^l
］
⇒
~RET `却下される~promise$( `InvalidStateError$E )
◎
If transport.[[State]] is not "connected", then return a new rejected promise with an InvalidStateError.
</li>
	<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~session に可用な流入~一方向~streamが在るようになるまで待機する
【！`流入~一方向~streamを受信する$】
◎
Wait until there is an available incoming unidirectional stream.
</li>
			<li>
%内部~stream ~LET `流入~一方向~streamを受信する$( %~session )
◎
Let internalStream be the result of receiving an incoming unidirectional stream.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream ~LET `WebTransportReceiveStream$I を`作成する$wtR( %内部~stream, %~transport )
◎
Let stream be the result of creating a WebTransportReceiveStream with internalStream and transport.
</li>
					<li>
%~transport . `IncomingUnidirectionalStreams$sl に`~chunkを~enqueueする$RS( %~stream )
◎
Enqueue stream to transport.[[IncomingUnidirectionalStreams]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve p with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>
</div>

		</section>
		<section id="webtransport-attributes">
<h3 title="Attributes">6.3. 属性</h3>

<p class="trans-note">【
原文には、
各~属性のうち一部に（規範的でない）記述もあるが、
属性が返す内部~slotの定義にて同様な内容が述べられているので，この訳では省略する
（あるいは、そこへ移動している）。
】</p>

<dl>
	<dt>
`ready@mT
◎
ready, of type Promise&lt;undefined&gt;, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Ready$sl
◎
On getting, it MUST return this’s [[Ready]].
</dd>

	<dt>
`closed@mT
◎
closed, of type Promise&lt;WebTransportCloseInfo&gt;, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Closed$sl
◎
On getting, it MUST return this’s [[Closed]].
</dd>

	<dt>
`draining@mT
◎
draining, of type Promise&lt;undefined&gt;, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Draining$sl
◎
On getting, it MUST return this’s [[Draining]].
</dd>

	<dt>
`datagrams@mT
◎
datagrams, of type WebTransportDatagramDuplexStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Datagrams$sl
◎
↑↑ A single duplex stream for sending and receiving datagrams over this session.＼
◎
The getter steps for the datagrams attribute SHALL be:
• Return this’s [[Datagrams]].
</dd>

	<dt>
`incomingBidirectionalStreams@mT
◎
incomingBidirectionalStreams, of type ReadableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingBidirectionalStreams$sl
◎
↑↑ Returns a ReadableStream of WebTransportBidirectionalStreams that have been received from the server.＼
◎
↑↑ Note: Whether the incoming streams already have data on them will depend on server behavior.
◎
The getter steps for the incomingBidirectionalStreams attribute SHALL be:
• Return this’s [[IncomingBidirectionalStreams]].
</dd>

	<dt>
`incomingUnidirectionalStreams@mT
◎
incomingUnidirectionalStreams, of type ReadableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingUnidirectionalStreams$sl
◎
↑↑ A ReadableStream of unidirectional streams, each represented by a WebTransportReceiveStream, that have been received from the server.＼
◎
↑↑ Note: Whether the incoming streams already have data on them will depend on server behavior.
◎
The getter steps for incomingUnidirectionalStreams are:
• Return this.[[IncomingUnidirectionalStreams]].
</dd>

	<dt>
`reliability@mT
◎
reliability, of type WebTransportReliabilityMode, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Reliability$sl
◎
Whether connection supports unreliable (over UDP) transport or only reliable (over TCP fallback) transport. Returns "pending" until a connection has been established.＼
The getter steps are to return this’s [[Reliability]].
</dd>

	<dt>
`congestionControl@mT
◎
congestionControl, of type WebTransportCongestionControl, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `CongestionControl$sl
◎
The application’s preference, if requested in the constructor, and satisfied by the user agent, for a congestion control algorithm optimized for either throughput or low latency for sending on this connection. If a preference was requested but not satisfied, then the value is "default"＼
The getter steps are to return this’s [[CongestionControl]].
</dd>

	<dt>
`supportsReliableOnly@mT
◎
supportsReliableOnly, of type boolean, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET ~IS［
~UAは、
`~WebTransport~session$を`依拠-可能$な`接続$越しに限り~supportする
］
◎
Returns true if the user agent supports WebTransport sessions over exclusively reliable connections, otherwise false.
</dd>

	<dt>
`anticipatedConcurrentIncomingUnidirectionalStreams@mT
◎
anticipatedConcurrentIncomingUnidirectionalStreams, of type unsigned short, nullable
</dt>
	<dd>
値の意味は、
`WebTransportOptions$I の `anticipatedConcurrentIncomingUnidirectionalStreams$mb を見よ。
◎
Optionally lets an application specify the number of concurrently open incoming unidirectional streams it anticipates the server creating.＼
If not null, the user agent SHOULD attempt to reduce future round-trips by taking [[AnticipatedConcurrentIncomingUnidirectionalStreams]] into consideration in its negotiations with the server.
</dd>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `AnticipatedConcurrentIncomingUnidirectionalStreams$sl
◎
The getter steps are to return this’s [[AnticipatedConcurrentIncomingUnidirectionalStreams]].
</dd>
	<dd class="algo">
設定子~手続きは
⇒
コレ . `AnticipatedConcurrentIncomingUnidirectionalStreams$sl ~SET 所与の値
◎
The setter steps, given value, are to set this’s [[AnticipatedConcurrentIncomingUnidirectionalStreams]] to value.
</dd>

	<dt>
`anticipatedConcurrentIncomingBidirectionalStreams@mT
◎
anticipatedConcurrentIncomingBidirectionalStreams, of type unsigned short, nullable
</dt>
	<dd>
値の意味は、
`WebTransportOptions$I の `anticipatedConcurrentIncomingBidirectionalStreams$mb を見よ。
◎
Optionally lets an application specify the number of concurrently open bidirectional streams it anticipates the server creating.＼
If not null, the user agent SHOULD attempt to reduce future round-trips by taking [[AnticipatedConcurrentIncomingBidirectionalStreams]] into consideration in its negotiations with the server.
</dd>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `AnticipatedConcurrentIncomingBidirectionalStreams$sl
◎
The getter steps are to return this’s [[AnticipatedConcurrentIncomingBidirectionalStreams]].
</dd>
	<dd class="algo">
設定子~手続きは
⇒
コレ . `AnticipatedConcurrentIncomingBidirectionalStreams$sl ~SET 所与の値
◎
The setter steps, given value, are to set this’s [[AnticipatedConcurrentIncomingBidirectionalStreams]] to value.
</dd>
	<dd class="note">注記：
［
`anticipatedConcurrentIncomingUnidirectionalStreams$mT ／
`anticipatedConcurrentIncomingBidirectionalStreams$mT
］は、
設定したとしても，［
応用が，自身が見越した~streamの個数を受信するようになる
］ことを保証するものではない。
◎
Note: Setting anticipatedConcurrentIncomingUnidirectionalStreams or anticipatedConcurrentIncomingBidirectionalStreams does not guarantee the application will receive the number of streams it anticipates.
</dd>

	<dt>
`protocol@mT
◎
protocol, of type DOMString, readonly
</dt>
	<dd>
［
構築子~optionとして空でない `protocols$mb が利用された
］下で［
`~WebTransport~session$が確立された
］なら、［
~serverにより選定された応用~levelの~protocol
］が在る場合は，それを指示する文字列を返す。
他の場合、
空~文字列を返す。
◎
Once a WebTransport session has been established and the protocols constructor option was used to provide a non-empty array, returns the application-level protocol selected by the server, if any. Otherwise, an empty string.＼
</dd>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Protocol$sl
◎
The getter steps are to return this’s [[Protocol]].
</dd>
</dl>

		</section>
		<section id="webtransport-methods">
<h3 title="Methods">6.4. ~method</h3>

<dl>
	<dt>
`close(closeInfo)@mT
◎
close(closeInfo)
</dt>
	<dd>
この `WebTransport$I に結付けられた`~WebTransport~session$を終了する。
◎
Terminates the WebTransport session associated with the WebTransport object.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When close is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
			<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］：
◎
If transport.[[State]] is "connecting":
</p>
				<ol>
					<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
					<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>
			</li>
			<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
			<li>
%~code ~LET %closeInfo[ "`closeCode$mb" ]
◎
Let code be closeInfo.closeCode.
</li>
			<li>
%事由 ~LET 空な`~byte列$
◎
↓</li>
			<li>
<p>
%事由~文字列 ~LET `~scalar値~文字列に変換する$( %closeInfo[ "`reason$mb" ] )
</p>
<p class="trans-note">【
原文は，`符号単位$に基づいて演算しているが、
以下で~UTF-8符号化法を適用するためには，
~scalar値に変換する必要があろう。
】</p>
◎
↓</li>
			<li>
%長さ ~LET 0
◎
↓</li>
			<li>
<p>
%事由~文字列 を成す
~EACH( %符号位置 )
に対し：
【！`符号単位~接頭辞$】
</p>
				<ol>
					<li>
%~byte列 ~LET `~UTF-8符号化する$( %符号位置 )
</li>
					<li>
%長さ ~INCBY %~byte列 の`長さ$byte
</li>
					<li>
~IF［
%長さ ~GT 1024
］
⇒
~BREAK
</li>
					<li>
%事由 に %~byte列 を付加する
</li>
				</ol>
◎
Let reasonString be the maximal code unit prefix of closeInfo.reason where the length of the UTF-8 encoded prefix doesn’t exceed 1024.
◎
Let reason be reasonString, UTF-8 encoded.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす
⇒
`~WebTransport~sessionを終了する$( %~session, %~code, %事由 )
◎
In parallel, terminate session with code and reason.
</p>

<p class="note">注記：
これはまた［
%~transport . `SendStreams$sl,
%~transport . `ReceiveStreams$sl
］内に包含された各`~WebTransport~stream$に対しても［
`設定し直す$WT／
`送信を停止させる$WT
］
◎
Note: This also resets or sends STOP_SENDING WebTransport streams contained in transport.[[SendStreams]] and [[ReceiveStreams]].
</p>
			</li>
			<li>
`~WebTransportを片付ける$( %~transport, `AbortError$E, %closeInfo )
◎
Cleanup transport with AbortError and closeInfo.
</li>
		</ol>
	</dd>

	<dt>
`getStats()@mT
◎
getStats()
</dt>
	<dd>
この `WebTransport$I の`下層~接続$用の統計を集めて，
その結果を非同期的に報告する。
◎
Gathers stats for this WebTransport’s underlying connection and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li>
<p>
~IF［
%~transport . `State$sl ~EQ `failed^l
］
⇒
~RET `却下される~promise$( `InvalidStateError$E 例外 )
◎
↑</p>

<p class="trans-note">【
この段は、
原文では［
`~promiseを却下する$( %~promise, `InvalidStateError^E 例外 )
］を行ってから値を返さずに手続きを終えているが，誤りであろう。
】</p>
◎
If transport.[[State]] is "failed", reject p with an InvalidStateError and abort these steps.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
%~transport . `State$sl が変化するまで待機する
◎
If transport.[[State]] is "connecting", wait until it changes.
</li>
					<li>
<p>
%~transport . `State$sl に応じて：
◎
↓</p>
						<ul class="switch">
							<li>
<p>
`failed^l
⇒
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
If transport.[[State]] is "failed", abort these steps after queueing a network task with transport to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `InvalidStateError$E 例外 )
◎
reject p with an InvalidStateError.
</div>
							</li>
							<li>
<p>
`closed^l
⇒
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
If transport.[[State]] is "closed", abort these steps after queueing a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
</p>
								<ol>
									<li>
%統計 ~LET 新たな `WebTransportConnectionStats$I
</li>
									<li>
%統計 を成す各~memberを当の接続~用に可用な最も近過去な統計を表現するよう設定する
— 統計が収集される正確な時点は、
`実装定義$とする。
</li>
									<li>
`~promiseを解決する$( %~promise, %統計 )
</li>
								</ol>
◎
resolve p with the most recent stats available for the connection. The exact point at which those stats are collected is implementation-defined.
</div>
							</li>
							<li>
<p>
その他：
◎
↑↓</p>
								<ol>
									<li>
`下層~接続$から統計を集める
— 各~datagram上の統計も含む
◎
Gather the stats from the underlying connection, including stats on datagrams.
</li>
									<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
										<ol>
											<li>
%統計 ~LET 新たな `WebTransportConnectionStats$I
◎
Let stats be a new WebTransportConnectionStats object＼
</li>
											<li>
%統計 を成す各~memberを集められた統計を表現するよう設定する
◎
representing the gathered stats.
</li>
											<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
										</ol>
</div>
									</li>
								</ol>
							</li>
						</ul>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>

	<dt>
`createBidirectionalStream(options)@mT
◎
createBidirectionalStream()
</dt>
	<dd>
流出~双方向~stream用の `WebTransportBidirectionalStream$I ~objを作成する。
~streamの作成だけでは、
~dataの送信に利用されるまでは，
即時に相手の端点から可視になることはないことに注意。
◎
Creates a WebTransportBidirectionalStream object for an outgoing bidirectional stream. Note that the mere creation of a stream is not immediately visible to the peer until it is used to send data.
</dd>
	<dd class="note">注記：
当の~stream上に~dataが送信されるまでは、
~serverが当の~streamを自覚するようになることは期待されない。
◎
Note: There is no expectation that the server will be aware of the stream until data is sent on it.
</dd>

	<dd class="algo">
<p>
~method手続きは：
◎
When createBidirectionalStream is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET `却下される~promise$( `InvalidStateError$E )
◎
If transport.[[State]] is "closed" or "failed", return a new rejected promise with an InvalidStateError.
</li>
			<li>
%送信-~group ~LET %options[ "`sendGroup$mb" ]
◎
Let sendGroup be options’s sendGroup.
</li>
			<li>
%送信-順序 ~LET %options[ "`sendOrder$mb" ]
◎
Let sendOrder be options’s sendOrder.
</li>
			<li>
%可用になるまで待機するか ~LET %options[ "`waitUntilAvailable$mb" ]
◎
Let waitUntilAvailable be options’s waitUntilAvailable.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は、
`並列的$に走らすことに加え：
◎
Run the following steps in parallel,＼
</p>
				<ul>
					<li>
次が満たされた`ときは中止する$
⇒
%~transport . `State$sl ~IN { `closed^l, `failed^l }
◎
but abort when transport’s [[State]] becomes "closed" or "failed",＼
</li>
					<li class="algo">
<p>
`中止されたときは$
⇒
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
and instead queue a network task with transport to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `InvalidStateError$E )
◎
reject p with an InvalidStateError:
</div>
					</li>
				</ul>
				<ol>
					<li>
<p>
%~stream~ID ~LET %~transport . `Session$sl 用に妥当かつ一意な新たな~stream~ID
— `QUIC$r `§ 19.11＠~RFCx/rfc9000#section-19.11$ にて定義されるとおり
</p>

<p>
~IF［
枯渇に因り，即時に可用な~stream~IDは無い
］：
</p>
						<ol>
							<li>
<p>
~IF［
%可用になるまで待機するか ~EQ ~F
］：
</p>
								<ol>
									<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `QuotaExceededError$E 例外 )
</div>
									</li>
									<li>
~RET
</li>
								</ol>
							</li>
							<li>
~stream~IDが可用になるまで待機する
</li>
							<li>
%~stream~ID ~SET 可用になった~stream~ID
</li>
						</ol>
◎
Let streamId be a new stream ID that is valid and unique for transport.[[Session]], as defined in [QUIC] Section 19.11. If one is not immediately available due to exhaustion, either wait for it to become available if waitUntilAvailable is true, or if waitUntilAvailable is false, abort these steps after queueing a network task with transport to reject p with a QuotaExceededError.
</li>
					<li>
%内部~stream ~LET `双方向~streamを作成する$( %~transport . `Session$sl, %~stream~ID )
◎
Let internalStream be the result of creating a bidirectional stream with transport.[[Session]] and streamId.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E )；
~RET
◎
If transport.[[State]] is "closed" or "failed", reject p with an InvalidStateError and abort these steps.
</li>
							<li>
%~stream ~LET `WebTransportBidirectionalStream$I を`作成する$wtB( %内部~stream, %~transport, %送信-~group, %送信-順序 )
◎
Let stream be the result of creating a WebTransportBidirectionalStream with internalStream, transport, sendGroup, and sendOrder.
</li>
							<li>
`~promiseを解決する$( %~promise, %~stream )
◎
Resolve p with stream.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>

	<dt>
`createUnidirectionalStream(options)@mT
◎
createUnidirectionalStream()
</dt>
	<dd>
流出~一方向~stream用の `WebTransportSendStream$I を作成する。
~streamの作成だけでは、
~dataの送信に利用されるまでは，
~serverからは即時に可視にならないことに注意。
◎
Creates a WebTransportSendStream for an outgoing unidirectional stream. Note that the mere creation of a stream is not immediately visible to the server until it is used to send data.
</dd>
	<dd class="note">注記：
当の~stream上に~dataが送信されるまでは、
~serverが当の~streamを自覚するようになることは期待されない。
◎
Note: There is no expectation that the server will be aware of the stream until data is sent on it.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When createUnidirectionalStream() method is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET `却下される~promise$( `InvalidStateError$E )
◎
If transport.[[State]] is "closed" or "failed", return a new rejected promise with an InvalidStateError.
</li>
			<li>
%送信-~group ~LET %options[ "`sendGroup$mb" ]
◎
Let sendGroup be options’s sendGroup.
</li>
			<li>
%送信-順序 ~LET %options[ "`sendOrder$mb" ]
◎
Let sendOrder be options’s sendOrder.
</li>
			<li>
%可用になるまで待機するか ~LET %options[ "`waitUntilAvailable$mb" ]
◎
Let waitUntilAvailable be options’s waitUntilAvailable.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は、
`並列的$に走らすことに加え：
◎
Run the following steps in parallel,＼
</p>
				<ul>
					<li>
次が満たされた`ときは中止する$
⇒
%~transport . `State$sl ~IN { `closed^l, `failed^l }
◎
but abort when transport’s [[State]] becomes "closed" or "failed",＼
</li>
					<li class="algo">
<p>
`中止されたときは$
⇒
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
and instead queue a network task with transport to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `InvalidStateError$E )
◎
reject p with an InvalidStateError:
</div>
					</li>
				</ul>
				<ol>
					<li>
<p>
%~stream~ID ~LET %~transport . `Session$sl 用に妥当かつ一意な新たな~stream~ID
— `QUIC$r `§ 19.11＠~RFCx/rfc9000#section-19.11$ にて定義されるとおり
</p>

<p>
~IF［
枯渇に因り，即時に可用な~stream~IDは無い
］：
</p>
						<ol>
							<li>
<p>
~IF［
%可用になるまで待機するか ~EQ ~F
］：
</p>
								<ol>
									<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `QuotaExceededError$E 例外 )
</div>
									</li>
									<li>
~RET
</li>
								</ol>
							</li>
							<li>
~stream~IDが可用になるまで待機する
</li>
							<li>
%~stream~ID ~SET 可用になった~stream~ID
</li>
						</ol>
◎
Let streamId be a new stream ID that is valid and unique for transport.[[Session]], as defined in [QUIC] Section 19.11. If one is not immediately available due to exhaustion, either wait for it to become available if waitUntilAvailable is true, or if waitUntilAvailable is false, abort these steps after queueing a network task with transport to reject p with a QuotaExceededError.
</li>
					<li>
<p>
%内部~stream ~LET `流出~一方向~streamを作成する$( %~transport . `Session$sl, %~stream~ID )
◎
Let internalStream be the result of creating an outgoing unidirectional stream with transport.[[Session]] and streamId.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E )；
~RET
◎
If transport.[[State]] is "closed" or "failed", reject p with an InvalidStateError and abort these steps.
</li>
							<li>
%~stream ~LET `WebTransportSendStream$I を`作成する$wtS( %内部~stream, %~transport, %送信-~group, %送信-順序 )
◎
Let stream be the result of creating a WebTransportSendStream with internalStream, transport, sendGroup, and sendOrder.
</li>
							<li>
`~promiseを解決する$( %~promise, %~stream )
◎
Resolve p with stream.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
return p.
</li>
		</ol>
	</dd>

	<dt>
`createSendGroup()@mT
◎
createSendGroup()
</dt>
	<dd>
`WebTransportSendGroup$I を作成する。
◎
Creates a WebTransportSendGroup.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When createSendGroup() method is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~THROW `InvalidStateError$E
◎
If transport.[[State]] is "closed" or "failed", throw an InvalidStateError.
</li>
			<li>
~RET `WebTransportSendGroup$I を`作成する$TSG( %~transport )
◎
Return the result of creating a WebTransportSendGroup with transport.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="webtransport-procedures">
<h3 title="Procedures">6.5. 手続-</h3>

<div class="algo">
<p>
`~WebTransportを片付ける@
~algoは、
所与の
( `WebTransport$I %~transport, %~error, %~close報（省略時は ε ） )
に対し：
◎
To cleanup a WebTransport transport with error and optionally closeInfo, run these steps:
</p>
<ol>
	<li>
%送信-~stream群 ~LET %~transport . `SendStreams$sl の複製
◎
Let sendStreams be a copy of transport.[[SendStreams]].
</li>
	<li>
%受信-~stream群 ~LET %~transport . `ReceiveStreams$sl の複製
◎
Let receiveStreams be a copy of transport.[[ReceiveStreams]].
</li>
	<li>
%流出~datagram可書~stream群 ~LET %~transport . `Datagrams$sl . `Writables$sl
◎
Let outgoingDatagramWritables be transport.[[Datagrams]].[[Writables]].
</li>
	<li>
%流入~datagram群 ~LET %~transport . `Datagrams$sl . `Readable$sl
◎
Let incomingDatagrams be transport.[[Datagrams]].[[Readable]].
</li>
	<li>
%準備済み時の~promise ~LET %~transport . `Ready$sl
◎
Let ready be transport.[[Ready]].
</li>
	<li>
%~close時の~promise ~LET %~transport . `Closed$sl
◎
Let closed be transport.[[Closed]].
</li>
	<li>
%流入~双方向~stream群 ~LET %~transport . `IncomingBidirectionalStreams$sl
◎
Let incomingBidirectionalStreams be transport.[[IncomingBidirectionalStreams]].
</li>
	<li>
%流入~一方向~stream群 ~LET %~transport . `IncomingUnidirectionalStreams$sl
◎
Let incomingUnidirectionalStreams be transport.[[IncomingUnidirectionalStreams]].
</li>
	<li>
%~transport . `SendStreams$sl ~SET 新たな`有順序~集合$
◎
Set transport.[[SendStreams]] to an empty set.
</li>
	<li>
%~transport . `ReceiveStreams$sl ~SET 新たな`有順序~集合$
◎
Set transport.[[ReceiveStreams]] to an empty set.
</li>
	<li>
%~transport . `Datagrams$sl . `OutgoingDatagramsQueue$slW ~SET 新たな`~queue$
◎
Set transport.[[Datagrams]].[[OutgoingDatagramsQueue]] to an empty queue.
</li>
	<li>
%~transport . `Datagrams$sl . `IncomingDatagramsQueue$sl ~SET 新たな`~queue$
◎
Set transport.[[Datagrams]].[[IncomingDatagramsQueue]] to an empty queue.
</li>
	<li>
%~transport . `State$sl ~SET %~close報 に応じて
⇒＃
ε ならば `failed^l ／
~ELSE_ `closed^l
◎
If closeInfo is given, then set transport.[[State]] to "closed". Otherwise, set transport.[[State]] to "failed".
</li>
	<li>
<p>
%送信-~stream群 を成す
~EACH( %~stream )
に対し：
◎
For each stream in sendStreams, run the following steps:
</p>
		<ol>
			<li>
~IF［
%~stream . `PendingOperation$slS ~NEQ ~NULL
］
⇒
`~promiseを却下する$( %~stream . `PendingOperation$slS, %~error )
◎
If stream.[[PendingOperation]] is not null, reject stream.[[PendingOperation]] with error.
</li>
			<li>
%~stream を`~errorにする$WS( %~error )
◎
Error stream with error.
</li>
		</ol>
	</li>
	<li>
<p>
%受信-~stream群 を成す
~EACH( %~stream )
に対し
⇒
%受信-~stream を`~errorにする$RS( %~error )
◎
For each stream in receiveStreams, error stream with error.
</p>

<p class="note">注記：
~script作者は［
~promise解決~内で同期的に走る~code
］を注入できる。
よって，ここ以降は、
【仕様~策定者は】
%~transport には触れないこと
— それは、
~scriptにより予測-不能な仕方で変異されることもあるので。
このことは、
この手続-を~callしている~logicにも適用される。
◎
Note: Script authors can inject code which runs in Promise resolution synchronously. Hence from here, do not touch transport as it may be mutated by scripts in an unpredictable way. This applies to logic calling this procedure, too.
</p>
	</li>
	<li>
<p>
~IF［
%~close報 ~NEQ ε
］：
◎
If closeInfo is given, then:
</p>
		<ol>
			<li>
`~promiseを解決する$( %~close時の~promise, %~close報 )
◎
Resolve closed with closeInfo.
</li>
			<li>
~Assert：
%準備済み は`決着した＠~ECMA262#sec-promise-objects$
◎
Assert: ready is settled.
</li>
			<li>
%流入~双方向~stream群 を`~closeする$RS()
◎
Close incomingBidirectionalStreams.
</li>
			<li>
%流入~一方向~stream群 を`~closeする$RS()
◎
Close incomingUnidirectionalStreams.
</li>
			<li>
%流出~datagram可書~stream群 を成す
~EACH( %可書~stream )
に対し
⇒
%可書~stream を`~closeする$WS()
◎
For each writable in outgoingDatagramWritables, close writable.
</li>
			<li>
%流入~datagram群 を`~closeする$RS()
◎
Close incomingDatagrams.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
`~promiseを却下する$( %~close時の~promise, %~error )
◎
Reject closed with error.
</li>
			<li>
%~close時の~promise . `PromiseIsHandled^sl ~SET ~T
◎
Set closed.[[PromiseIsHandled]] to true.
</li>
			<li>
`~promiseを却下する$( %準備済み時の~promise, %~error )
◎
Reject ready with error.
</li>
			<li>
%準備済み時の~promise . `PromiseIsHandled^sl ~SET ~T
◎
Set ready.[[PromiseIsHandled]] to true.
</li>
			<li>
%流入~双方向~stream群 を`~errorにする$RS( %~error )
◎
Error incomingBidirectionalStreams with error.
</li>
			<li>
%流入~一方向~stream群 を`~errorにする$RS( %~error )
◎
Error incomingUnidirectionalStreams with error.
</li>
			<li>
%流出~datagram可書~stream群 を成す
~EACH( %可書~stream )
に対し
⇒
%可書~stream を`~errorにする$WS( %~error )
◎
For each writable in outgoingDatagramWritables, error writable with error.
</li>
			<li>
%流入~datagram群 を`~errorにする$RS( %~error )
◎
Error incomingDatagrams with error.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
`~network~taskを~queueする@
~algoは、
所与の
( `WebTransport$I %~transport, %手続き )
に対し
⇒
`大域~taskを~queueする$( `~network用~task~source$, %~transport に`関連な大域~obj$, 
%手続き )
◎
To queue a network task with a WebTransport transport and a series of steps steps, run these steps:
• Queue a global task on the network task source with transport’s relevant global object to run steps.
</div>

		</section>
		<section id="web-transport-termination">
<h3 title="Session termination not initiated by the client">6.6. ~clientにより起動されたものでない~sessionの終了n</h3>

<div class="algo">
<p>
ある `WebTransport$I %~transport に結付けられた`~WebTransport~session$ %~session
【すなわち %~transport . `Session$sl】
が`終了され$たときは、
所与の
( %~code （省略時は ε ）, %事由~byte列 （省略時は ε ） )
に対し，次の手続きを走らす：
◎
Whenever a WebTransport session which is associated with a WebTransport transport is terminated with optionally code and reasonBytes, run these steps:
</p>
<ol>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
			<li>
%~close報 ~LET 新たな `WebTransportCloseInfo$I
◎
Let closeInfo be a new WebTransportCloseInfo.
</li>
			<li>
~IF［
%~code ~NEQ ε
］
⇒
%~close報[ "`closeCode$mb" ] ~SET %~code
◎
If code is given, set closeInfo’s closeCode to code.
</li>
			<li>
<p>
~IF［
%事由~byte列 ~NEQ ε
］
⇒
%~close報[ "`reason$mb" ] ~SET `~UTF-8復号する$( %事由~byte列 )
◎
If reasonBytes is given, set closeInfo’s reason to reasonBytes, UTF-8 decoded.
</p>

<p class="note">注記：
%事由~byte列 に可用な［
言語／方向
］
【ヒトが話す言語／書字方向】
~metadataは無い。
方向~用には、
値を表示するときに `first-strong＠~TR/string-meta/#firststrong$en 経験則†を利用できる。
【† 最初に現れる `Strong^en 文字の方向に基づく（`参考＠~HTMLdom#the-directionality$）】
◎
Note: No language or direction metadata is available with reasonBytes. First-strong heuristics can be used for direction when displaying the value.
</p>
			</li>
			<li>
`~WebTransportを片付ける$( %~transport, %~error, %~close報 )
◎
Cleanup transport with error and closeInfo.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
ある `WebTransport$I %~transport の`下層~接続$に接続~errorが生じたときは、
次の手続きを走らす：
◎
Whenever a WebTransport transport’s underlying connection gets a connection error, run these steps:
</p>
<ol>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
			<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="web-transport-context-cleanup-steps">
<h3 title="Context cleanup steps">6.7. 文脈を片付ける手続き</h3>

<div class="algo">
<p>
`文脈を片付ける手続き@
は、
所与の
( `WebTransport$I %~transport )
に対し：
◎
This specification defines context cleanup steps as the following steps, given WebTransport transport:
</p>
<ol>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connected^l
］：
◎
If transport.[[State]] is "connected", then:
</p>
		<ol>
			<li>
%~transport . `State$sl ~SET `failed^l
◎
Set transport.[[State]] to "failed".
</li>
			<li class="algo">
この段は`並列的$に走らす
⇒
`~WebTransport~sessionを終了する$( %~transport . `Session$sl )
◎
In parallel, terminate transport.[[Session]].
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
				<ol>
					<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
					<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
%~transport . `State$sl ~SET `failed^l
◎
If transport.[[State]] is "connecting", set transport.[[State]] to "failed".
</p>

<p class="issue">
これは、
~worker内でも行う必要がある。
`課題 #127＠https://www.github.com/w3c/webtransport/issues/127$,
`whatwg/html 課題 #6731＠https://www.github.com/whatwg/html/issues/6831$
を見よ。
◎
This needs to be done in workers too. See #127 and whatwg/html#6731.
</p>
	</li>
</ol>

<p class="trans-note">【
この手続き（この仕様~内では利用されていない）は、
~HTMLの`文書~unload時の片付け手続き＠~HTMLlifecycle#unloading-document-cleanup-steps$から呼び出される。
】</p>
</div>

		</section>
		<section id="web-transport-gc">
<h3 title="Garbage Collection">6.8. ~garbage収集</h3>

<p>
~UAは、
所与の
( `WebTransport$I ~obj %~transport )
に対し，
%~transport が ~OR↓ を満たす間は
%~transport を~garbage収集しないモノトスル：
◎
↓</p>
<ul>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
%~transport . `State$sl ~IN { `connecting^l, `connected^l, `draining^l }
</li>
			<li>
［
関連な~streamのうち`~lockされて$RSいるものがある
］~OR［
関連な~promiseのうち観測されているものがある
］
</li>
		</ul>

<p>
上の条件において：
		<ul>
			<li>
関連な~streamとは、
次に挙げる~streamの総称である
⇒＃
%~transport . `IncomingBidirectionalStreams$sl,
%~transport . `IncomingUnidirectionalStreams$sl,
【%~transport . `ReceiveStreams$sl を成す】各 `WebTransportReceiveStream$I,
%~transport . `Datagrams$sl . `Readable$sl
</li>
			<li>
関連な~promiseとは、［
%~transport . `State$sl に応じて，次に挙げる %~transport の属性（たち）
］が返した~promiseの総称である
⇒＃
`connecting^l ならば［ `ready$mT, `draining$mT, `closed$mT ］ ／
`connected^l ならば［ `draining$mT, `closed$mT ］ ／
`draining^l ならば `closed$mT
</li>
		</ul>

◎
A WebTransport object whose [[State]] is "connecting" must not be garbage collected if [[IncomingBidirectionalStreams]], [[IncomingUnidirectionalStreams]], any WebTransportReceiveStream, or [[Datagrams]].[[Readable]] are locked, or if the ready, draining, or closed promise is being observed.
◎
A WebTransport object whose [[State]] is "connected" must not be garbage collected if [[IncomingBidirectionalStreams]], [[IncomingUnidirectionalStreams]], any WebTransportReceiveStream, or [[Datagrams]].[[Readable]] are locked, or if the draining or closed promise is being observed.
◎
A WebTransport object whose [[State]] is "draining" must not be garbage collected if [[IncomingBidirectionalStreams]], [[IncomingUnidirectionalStreams]], any WebTransportReceiveStream, or [[Datagrams]].[[Readable]] are locked, or if the closed promise is being observed.
</li>
	<li>
<p>
~AND↓：
</p>
		<ul>
			<li>
`~WebTransport~session$を`確立した＠#session-establish$
</li>
			<li>
~networkへ伝送するよう~queueされた~dataがある
— この~dataには、
%~transport . `Datagrams$sl . `OutgoingDatagramsQueue$slW 内の~datagramも含まれる。
</li>
		</ul>
◎
A WebTransport object with an established WebTransport session that has data queued to be transmitted to the network, including datagrams in [[Datagrams]].[[OutgoingDatagramsQueue]], must not be garbage collected.
</li>
</ul>

<p>
`WebTransport$I ~objが，その`下層~接続$がまだ~openな間に~garbage収集された場合、
~UAは，`~WebTransport~sessionを終了する＠~WT-OVERVIEW#terminate-a-session$モノトスル
— ( ~error~code 0, ~error~message 空~文字列 )
を与える下で
◎
If a WebTransport object is garbage collected while the underlying connection is still open, the user agent must terminate the WebTransport session with an Application Error Code of 0 and Application Error Message of "".
</p>

		</section>
		<section id="web-transport-configuration">
<h3 title="Configuration">6.9. 環境設定</h3>

<pre class="idl">
dictionary `WebTransportHash@I {
  `DOMString$ `algorithm@mH;
  `BufferSource$I `value@mH;
};

dictionary `WebTransportOptions@I {
  `boolean$ `allowPooling$mb = false;
  `boolean$ `requireUnreliable$mb = false;
  `sequence$&lt;`WebTransportHash$I&gt; `serverCertificateHashes$mb;
  `WebTransportCongestionControl$I `congestionControl$mb = "default";
  [`EnforceRange$] `unsigned short$? `anticipatedConcurrentIncomingUnidirectionalStreams$mb = null;
  [`EnforceRange$] `unsigned short$? `anticipatedConcurrentIncomingBidirectionalStreams$mb = null;
  `sequence$&lt;`DOMString$&gt; `protocols$mb = [];
};

enum `WebTransportCongestionControl@I {
  `default@l,
  `throughput@l,
  `low-latency@l,
};
</pre>

<p>
`WebTransportOptions$I は、［
`~WebTransport~session$がどう確立され，どう利用されるか
］を決定する~parameterたちが成す辞書である。
◎
WebTransportOptions is a dictionary of parameters that determine how the WebTransport session is established and used.
</p>
<dl>
	<dt>
`allowPooling@mb
◎
allowPooling, of type boolean, defaulting to false
</dt>
	<dd>
~T に設定されたときは、
当の`~WebTransport~session$を~poolできる
— すなわち、
その`下層~接続$は，他の`~WebTransport~session$と共有できるようになる。
◎
When set to true, the WebTransport session can be pooled, that is, its underlying connection can be shared with other WebTransport sessions.
</dd>

	<dt>
`requireUnreliable@mb
◎
requireUnreliable, of type boolean, defaulting to false
</dt>
	<dd>
~T に設定されたときは、
次を行えなくなる
⇒
~HTTP3`接続$がアリでない場合に，
`~WebTransport~session$を~HTTP2`接続$越しに確立する
◎
When set to true, the WebTransport session cannot be established over an HTTP/2 connection if an HTTP/3 connection is not possible.
</dd>

	<dt>
`serverCertificateHashes@mb
◎
serverCertificateHashes, of type sequence&lt;WebTransportHash&gt;
</dt>
	<dd>
この~optionは、
専用な接続を利用している~transport用に限り~supportされる。
◎
This option is only supported for transports using dedicated connections.＼
</dd>
	<dd>
<p>
~UAは、
次に従うモノトスル
— 以下における %~hash群 は、
この~fieldに与えた値を表すとする：
</p>
		<ul>
			<li>
［
~transport~protocolが この特能を~supportしない
］~AND［
%~hash群 は空でない
］場合、
`NotSupportedError$E 例外を投出する。
</li>
			<li>
<p>
［
~transport~protocolが この特能を~supportする
］~AND［
%~hash群 は空でない
］場合、
~server証明書は，［
~AND↓ が満たされる場合，その場合に限り
］信用されるものと判断する：
</p>
				<ul>
					<li>
次の結果 ~EQ ~T
⇒
`証明書~hashを検証yする$( 当の証明書, %~hash群 )
</li>
					<li>
当の証明書は`~custom証明書~要件$を満足する
</li>
				</ul>
			</li>
			<li>
%~hash群 を成す各~hashのうち未知な `algorithm$mH を利用するものは無視する。
</li>
			<li>
%~hash群 は空な場合、
通常の`~fetchする$ 演算~用に利用することになる証明書~検証y手続-を利用する。
</li>
		</ul>
◎
For transport protocols that do not support this feature, having this field non-empty SHALL result in a NotSupportedError exception being thrown.
◎
If supported and non-empty, the user agent SHALL deem a server certificate trusted if and only if it can successfully verify a certificate hash against serverCertificateHashes and satisfies custom certificate requirements. The user agent SHALL ignore any hash that uses an unknown algorithm. If empty, the user agent SHALL use certificate verification procedures it would use for normal fetch operations.
</dd>
	<dd>
これは、
`allowPooling$mb と伴には利用できない。
◎
This cannot be used with allowPooling.
</dd>
	<dd class="issue">
`serverCertificateHashes$mb には， 2 つの実装があるが、
`the chairs^en により，~risk下にある特能として識別された。
これは、
次に挙げる~openな課題に関する総意の欠如に因る
⇒
`課題 #623＠https://github.com/w3c/webtransport/issues/623$,
`課題 #59＠https://github.com/w3c/webtransport/issues/59$
◎
serverCertificateHashes has been identified by the chairs as a feature at risk, in spite of having two implementations. This is due to lack of consensus over the following two open issues:
• https://github.com/w3c/webtransport/issues/623
• https://github.com/w3c/webtransport/issues/59 
</dd>

	<dt>
`congestionControl@mb
◎
congestionControl, of type WebTransportCongestionControl, defaulting to "default"
</dt>
	<dd>
任意選択で，
次に関する応用の選好を指定する
⇒
［
~throughputまたは短い待時間
］用に調律された輻輳~制御~algoであって，
この接続~越しに~dataを送信するとき利用されるもの。
◎
Optionally specifies an application’s preference for a congestion control algorithm tuned for either throughput or low-latency to be used when sending data over this connection.＼
</dd>
	<dd>
これは、
~UA向けの~hintである。
◎
This is a hint to the user agent.
</dd>
	<dd class="issue atrisk">
この環境設定~optionは、
~browserにおける［
短い待時間~用に最適化する輻輳~制御~algo
］用の実装の欠如に因り，~risk下にある特能と見なされる
— これを書いた時点では。
◎
This configuration option is considered a feature at risk due to the lack of implementation in browsers of a congestion control algorithm, at the time of writing, that optimizes for low latency.
</dd>

	<dt>
`anticipatedConcurrentIncomingUnidirectionalStreams@mb
◎
anticipatedConcurrentIncomingUnidirectionalStreams, of type unsigned short, nullable, defaulting to null
</dt>
	<dd>
［
同時並行に~openな，`流入~一方向$な~streamたち
］として［
~serverが作成するものと応用が見越す個数
］を応用が任意選択で指定できるようにする。
◎
Optionally lets an application specify the number of concurrently open incoming unidirectional streams it anticipates the server creating.＼
</dd>
	<dd>
~UAは、
初期~時は，
~serverからの`流入~一方向$な~streamを 100 個以上は許容するモノトスル。
◎
The user agent MUST initially allow at least 100 incoming unidirectional streams from the server.＼
</dd>
	<dd>
~NULL でない場合、
~UAは，［
自身と~serverとの折衝において `AnticipatedConcurrentIncomingUnidirectionalStreams$sl を考慮に入れる
］ことにより［
未来の往復-数を抑制するよう試みる
］ベキである。
◎
If not null, the user agent SHOULD attempt to reduce round-trips by taking [[AnticipatedConcurrentIncomingUnidirectionalStreams]] into consideration in its negotiations with the server.
</dd>

	<dt>
`anticipatedConcurrentIncomingBidirectionalStreams@mb
◎
anticipatedConcurrentIncomingBidirectionalStreams, of type unsigned short, nullable, defaulting to null
</dt>
	<dd>
［
同時並行に~openな，`双方向$な~streamたち
］として［
~serverが作成するものと応用が見越す個数
］を応用が任意選択で指定できるようにする。
◎
Optionally lets an application specify the number of concurrently open bidirectional streams it anticipates a server creating.＼
</dd>
	<dd>
~UAは、
初期~時は，
~serverが作成する`双方向$な~streamとして 100 個以上は許容するモノトスル。
◎
The user agent MUST initially allow the server to create at least 100 bidirectional streams.＼
</dd>
	<dd>
~NULL でない場合、
~UAは，［
自身と~serverとの折衝において `AnticipatedConcurrentIncomingBidirectionalStreams$sl を考慮に入れる
］ことにより［
未来の往復-数を抑制するよう試みる
］ベキである。
◎
If not null, the user agent SHOULD attempt to reduce round-trips by taking [[AnticipatedConcurrentIncomingBidirectionalStreams]] into consideration in its negotiations with the server.
</dd>

	<dt>
`protocols@mb
◎
protocols, of type sequence&lt;DOMString&gt;, defaulting to []
</dt>
	<dd>
応用~levelの
`~protocol名@
たちが成す連列
— 省略可能。
◎
An optionally provided array of application-level protocol names.＼
</dd>
	<dd>
【空でない場合】
当の接続は、
次が生じた場合に限り，確立されることになる
⇒
~serverは、［
これらが指示する応用~levelの~protocolのうちいずれか
］を選定して，それを【~clientへ】報告した。
◎
The connection will only be established if the server reports that it has selected one of these application-level protocols.
</dd>
</dl>

<div class="algo">
<p>
`証明書~hashを算出する@
~algoは、
所与の
( %証明書 )
に対し：
◎
To compute a certificate hash, given a certificate, perform the following steps:
</p>
<ol>
	<li>
%符号化した証明書 ~LET %証明書 に次を施した結果を表現するもの
⇒
`RFC5280$r にて定義される `Certificate^en【証明書】~messageを~DER符号化した結果
◎
Let cert be certificate, represented as a DER encoding of Certificate message defined in [RFC5280].
</li>
	<li>
~RET %符号化した証明書 の~SHA-256~hashを算出した結果
【！and return the computed value.】
◎
Compute the SHA-256 hash of cert and return the computed value.
</li>
</ol>
</div>

<div class="algo">
<p>
`証明書~hashを検証yする@
~algoは、
所与の
( %証明書, `WebTransportHash$I ~hashたちが成す配列 %~hash群 )
に対し：
◎
To verify a certificate hash, given a certificate and an array of hashes hashes, perform the following steps:
</p>
<ol>
	<li>
%参照~hash ~LET `証明書~hashを算出する$( %証明書 )
◎
Let referenceHash be the result of computing a certificate hash with certificate.
</li>
	<li>
<p>
%~hash群 を成す
~EACH( %~hash )
に対し：
</p>
		<ol>
			<li>
%~hash~source ~LET %~hash[ "`value$mH" ]
</li>
			<li>
%~algo ~LET %~hash[ "`algorithm$mH" ]
</li>
			<li>
~IF［
%~hash~source ~EQ ε【！~NULL】
］~OR［
%~algo ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
<p>
~IF［
%~algo は`~ASCII大小無視$で `sha-256^l に合致する
］：
</p>
				<ol>
					<li>
%~hash値 ~LET %~hash~source が表現する~byte列
</li>
					<li>
~IF［
%~hash値 ~EQ %参照~hash
］
⇒
~RET ~T
</li>
				</ol>
			</li>
		</ol>
◎
For every hash hash in hashes:
• If hash.value is not null and hash.algorithm is an ASCII case-insensitive match with "sha-256":
•• Let hashValue be the byte sequence which hash.value represents.
•• If hashValue is equal to referenceHash, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
`~custom証明書~要件@
は、
次に従うモノトスル：
◎
The custom certificate requirements are as follows:＼
</p>
<ul>
	<li>
当の証明書は、
`RFC5280$r にて定義されるとおり X.509v3 証明書である。
◎
the certificate MUST be an X.509v3 certificate as defined in [RFC5280],＼
</li>
	<li>
`Subject Public Key^en ~field内に利用される~keyは、
いずれかの`許容される公開鍵~algo$である。
◎
the key used in the Subject Public Key field MUST be one of the allowed public key algorithms,＼
</li>
	<li>
現在の時刻は、
`RFC5280$r § 4.1.2.5 にて定義されるとおり，
証明書の妥当性~期間（ `validity period^en ）の中にある。
◎
the current time MUST be within the validity period of the certificate as defined in Section 4.1.2.5 of [RFC5280]＼
</li>
	<li>
妥当性~期間を成す総-長さは、
2 週間を超過しない。
◎
and the total length of the validity period MUST NOT exceed two weeks.＼
</li>
</ul>

<p>
~UAは、
当の証明書に対し，追加的な［
`実装定義$な要件
］を課してもヨイ。
◎
The user agent MAY impose additional implementation-defined requirements on the certificate.
</p>

<p>
`Subject Public Key Info^en ~field内
（したがって、
その帰結として， `TLS CertificateVerify^en ~message内）
に利用される
`許容される公開鍵~algo@
たちが成す正確な~listは、
`実装定義$とする
— しかしながら、
それは：
◎
The exact list of allowed public key algorithms used in the Subject Public Key Info field (and, as a consequence, in the TLS CertificateVerify message) is implementation-defined; however,＼
</p>
<ul>
	<li>
相互運用可能な既定を供するためとして、
`ECDSA with the secp256r1 (NIST P-256) named group^en
（ `RFC3279$r § 2.3.5, `RFC8422$r ）
を含むモノトスル。
◎
it MUST include ECDSA with the secp256r1 (NIST P-256) named group ([RFC3279], Section 2.3.5; [RFC8422]) to provide an interoperable default.＼
</li>
	<li>
~RSA鍵（ `RFC3279$r, § 2.3.1 ）を包含しないモノトスル。
◎
It MUST NOT contain RSA keys ([RFC3279], Section 2.3.1).
</li>
</ul>

		</section>
		<section id="web-transport-close-info">
<h3 title="WebTransportCloseInfo Dictionary">6.10. `WebTransportCloseInfo^I 辞書</h3>

<p>
`WebTransportCloseInfo$I 辞書は、
`WebTransport$I を~closeする際の~error~codeに関係している情報を含む。
この情報は、
`CONNECTION_CLOSE^ft ~frame用に［
~error~code, 事由
］を設定するために利用される。
◎
The WebTransportCloseInfo dictionary includes information relating to the error code for closing a WebTransport. This information is used to set the error code and reason for a CONNECTION_CLOSE frame.
</p>

<pre class="idl">
dictionary `WebTransportCloseInfo@I {
  `unsigned long$ `closeCode$mb = 0;
  `USVString$ `reason$mb = "";
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`closeCode@mb
◎
closeCode, of type unsigned long, defaulting to 0
</dt>
	<dd>
相手の端点へ通信される~error~code。
◎
The error code communicated to the peer.
</dd>

	<dt>
`reason@mb
◎
reason, of type USVString, defaulting to ""
</dt>
	<dd>
`WebTransport$I を~closeする際の事由。
◎
The reason for closing the WebTransport.
</dd>
</dl>

		</section>
		<section id="send-options">
<h3 title="WebTransportSendOptions Dictionary">6.11. `WebTransportSendOptions^I 辞書</h3>

<p>
`WebTransportSendOptions@I
は、［
`createUnidirectionalStream()$mT,
`createBidirectionalStream()$mT,
`createWritable()$mD
］~methodがどう挙動するかに影響する~parameterたちが成す基底~辞書である。
◎
The WebTransportSendOptions is a base dictionary of parameters that affect how createUnidirectionalStream, createBidirectionalStream, and the createWritable methods behave.
</p>


<pre class="idl">
dictionary `WebTransportSendOptions$I {
  `WebTransportSendGroup$I? `sendGroup$mb = null;
  `long long$ `sendOrder$mb = 0;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`sendGroup@mb
◎
sendGroup, of type WebTransportSendGroup, nullable, defaulting to null
</dt>
	<dd>
~NULL ／
ある `WebTransportSendGroup$I
◎
↓</dd>
	<dd>
~NULL でない場合、
【この辞書を利用する~method（上に挙げたもの）により】
作成される~streamは，それが表現する`送信-~group$に属する。
◎
An optional WebTransportSendGroup to group the created stream under, or null.
</dd>

	<dt>
`sendOrder@mb
◎
sendOrder, of type long long, defaulting to 0
</dt>
	<dd>
作成される~streamに与える送信-順序~番号
◎
A send order number that,＼
</dd>
	<dd>
<p>
作成される各~streamのうち：
</p>
		<ul>
			<li>
送信-順序~番号が供されたものは、
`厳密な順序付け@
に関与するようになり【！opts】、
それらに~queueされた~byte列は，
送信-順序~番号が高いものほど先に送信されることになる。
</li>
			<li>
送信-順序~番号が供されないものは、［
それと他の~stream
］から~UAが送信する~byte列どうしの相対的な送信-順序は`実装定義$になる。
</li>
		</ul>

<p class="trans-note">【
`sendOrder$mb の既定~値は，更新により ~NULL から 0 に改められたため、
上の条件（供されたか否か）が明示的に 0 を供した場合と省略した場合を区別するのかどうか不明瞭になっている
（ ~IDL~levelでは、
これらは同じに挙動する）。
】</p>
◎
if provided, opts the created stream in to participating in strict ordering. Bytes currently queued on strictly ordered streams will be sent ahead of bytes currently queued on other strictly ordered streams created with lower send order numbers.
◎
If no send order number is provided, then the order in which the user agent sends bytes from it relative to other streams is implementation-defined.＼
</dd>
	<dd>
しかしながら，~UAには、
すべての~streamのうち［
より低い送信-順序~番号により後回されないもの
］の間で帯域幅を公平に分合うことが強く奨励される。
◎
User agents are strongly encouraged however to divide bandwidth fairly between all streams that aren’t starved by lower send order numbers.
</dd>
	<dd class="note">注記：
これは、
送信者~側における~dataの優先度化であり，
受信される順序を保証するものではない。
◎
Note: This is sender-side data prioritization which does not guarantee reception order.
</dd>
</dl>

		</section>
		<section id="uni-stream-options">
<h3 title="WebTransportSendStreamOptions Dictionary">6.12. `WebTransportSendStreamOptions^I 辞書</h3>

<p>
`WebTransportSendStreamOptions$I は、［
`createUnidirectionalStream()$mT ／ `createBidirectionalStream()$mT
］により作成された `WebTransportSendStream$I
— 以下 %~stream と記す —
がどう挙動するかに影響する~parameterたちが成す辞書である。
◎
The WebTransportSendStreamOptions is a dictionary of parameters that affect how WebTransportSendStreams created by createUnidirectionalStream and createBidirectionalStream behave.
</p>

<pre class="idl">
dictionary `WebTransportSendStreamOptions@I {
  `boolean$ `waitUntilAvailable$mb = false;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`waitUntilAvailable@mb
◎
waitUntilAvailable, of type boolean, defaulting to false
</dt>
	<dd>
<p>
［
`createUnidirectionalStream()$mT ／
`createBidirectionalStream()$mT
］~callにより返される~promiseは、
この~memberの値に応じて：
</p>
		<ul>
			<li>
~T の場合
⇒
`下層~接続$が次に挙げる いずれかの状態に達しない限り，`決着しない＠~ECMA262#sec-promise-objects$ことになる
⇒＃
~streamを作成するために足る~flow制御~creditを有する／
更なる流出~streamを作成することはアリでない
</li>
			<li>
~F の場合
⇒
~callした時点で可用な~flow制御~窓が無い場合には、
`却下される＠~ECMA262#sec-promise-objects$ことになる。
◎
If true, the promise returned by the createUnidirectionalStream or createBidirectionalStream call will not be settled until either the underlying connection has sufficient flow control credit to create the stream, or the connection reaches a state in which no further outgoing streams are possible. If false, the promise will be rejected if no flow control window is available at the time of the call.
</li>
		</ul>
	</dd>
</dl>

		</section>
		<section id="web-transport-connection-stats">
<h3 title="WebTransportConnectionStats Dictionary">6.13. `WebTransportConnectionStats^I 辞書</h3>

<p>
`WebTransportConnectionStats$I 辞書は、
`~WebTransport~session$の`下層~接続$についての~WebTransportに特有な統計を含む。
◎
The WebTransportConnectionStats dictionary includes information on WebTransport-specific stats about the WebTransport session’s underlying connection.
</p>

<p class="note">注記：
~pool法が利用されるとき，同じ`接続$に~poolされた複数の`~WebTransport~session$は、
すべて同じ情報を受信する
— すなわち、
当の情報は、［
~poolされた`~WebTransport~session$たちのうち，同じ`~network区分~key$を保持しているもの
］にまたがって開示される。
◎
Note: When pooling is used, multiple WebTransport sessions pooled on the same connection all receive the same information, i.e. the information is disclosed across pooled sessions holding the same network partition key.
</p>

<p class="note">注記：
各種~統計のうち可用でないものは、
`WebTransportConnectionStats$I 辞書~内には`包含され＠~INFRA#map-exists$ない。
◎
Note: Any unavailable stats will be absent from the WebTransportConnectionStats dictionary.
</p>

<pre class="idl">
dictionary `WebTransportConnectionStats@I {
  `unsigned long long$ `bytesSent$mb = 0;
  `unsigned long long$ `packetsSent$mb = 0;
  `unsigned long long$ `bytesLost$mb = 0;
  `unsigned long long$ `packetsLost$mb = 0;
  `unsigned long long$ `bytesReceived$mb = 0;
  `unsigned long long$ `packetsReceived$mb = 0;
  required `DOMHighResTimeStamp$ `smoothedRtt$mb;
  required `DOMHighResTimeStamp$ `rttVariation$mb;
  required `DOMHighResTimeStamp$ `minRtt$mb;
  required `WebTransportDatagramStats$I `datagrams$mb;
  `unsigned long long$? `estimatedSendRate$mb = null;
  `boolean$ `atSendCapacity$mb = false;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`bytesSent@mb
◎
bytesSent, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の`下層~接続$上に送信された~byteたちの個数
— 再-伝送も含むが，［
~UDPその他の外縁~frame法
］は含まない。
◎
The number of bytes sent on the underlying connection, including retransmissions. Does not include UDP or any other outer framing.
</dd>

	<dt>
`packetsSent@mb
◎
packetsSent, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の`下層~接続$上に送信された~packetの個数
— 喪失したものと決定されたものも含む。
◎
The number of packets sent on the underlying connection, including those that are determined to have been lost.
</dd>

	<dt>
`bytesLost@mb
◎
bytesLost, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の`下層~接続$上で喪失した~byteたちの個数
（単調増加しない
— 喪失したものと宣言された~packetは，後続に受信され得るので）
— 再-伝送も含むが，［
~UDPその他の外縁~frame法
］は含まない。
◎
The number of bytes lost on the underlying connection (does not monotonically increase, because packets that are declared lost can subsequently be received). Does not include UDP or any other outer framing.
</dd>

	<dt>
`packetsLost@mb
◎
packetsLost, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の`下層~接続$上で喪失した~packetの個数
（単調増加しない
— 喪失したものと宣言された~packetは，後続に受信され得るので）。
◎
The number of packets lost on the underlying connection (does not monotonically increase, because packets that are declared lost can subsequently be received).
</dd>

	<dt>
`bytesReceived@mb
◎
bytesReceived, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の`下層~接続$上で受信された総-~byte数
— ［
各~stream用に重複した~data
］も含むが，［
~UDPその他の外縁~frame法
］は含まない。
◎
The number of total bytes received on the underlying connection, including duplicate data for streams. Does not include UDP or any other outer framing.
</dd>

	<dt>
`packetsReceived@mb
◎
packetsReceived, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の`下層~接続$上で受信された総-~packet数
— 処理-可能でなかった~packetも含む。
◎
The number of total packets received on the underlying connection, including packets that were not processable.
</dd>

	<dt>
`smoothedRtt@mb
◎
smoothedRtt, of type DOMHighResTimeStamp
</dt>
	<dd>
当の接続~上で現在に観測された
`smoothed^en 往復-時間【 `smoothed_rtt^c 】
— `RFC9002$r `§ 5.3＠~RFCx/rfc9002#section-5.3$ にて定義されるとおり。
◎
The smoothed round-trip time (RTT) currently observed on the connection, as defined in [RFC9002] Section 5.3.
</dd>

	<dt>
`rttVariation@mb
◎
rttVariation, of type DOMHighResTimeStamp
</dt>
	<dd>
接続~上で現在に観測された［
往復-時間 標本
］たちの平均~変動【 `rttvar^c 】
— `RFC9002$r `§ 5.3＠~RFCx/rfc9002#section-5.3$
にて定義されるとおり。
◎
The mean variation in round-trip time samples currently observed on the connection, as defined in [RFC9002] Section 5.3.
</dd>

	<dt>
`minRtt@mb
◎
minRtt, of type DOMHighResTimeStamp
</dt>
	<dd>
接続~全体~上で観測された最小な往復-時間。
【 `min_rtt^c — `RFC9002$r `§ 5.2＠~RFCx/rfc9002#section-5.2$】
◎
The minimum round-trip time observed on the entire connection.
</dd>

	<dt>
`estimatedSendRate@mb
◎
estimatedSendRate, of type unsigned long long, nullable, defaulting to null
</dt>
	<dd>
［
~UAが~queueされた~dataを送信することになる~rate
］として見積もられた毎秒あたりの~bit数。
この~rateは、
`~WebTransport~session$を共有するすべての［
~stream, ~datagram
］に適用され，
輻輳~制御~algo
（ `congestionControl$mT により選ばれるそれにもなり得る）
により計算される。
この見積もりには、
~frame法による~overheadは含まれない。
この見積もりは、
応用~payloadが送信されるであろう~rateを表現する。
~UAは、
現在の見積もりを有さない場合には，この~memberの値を ~NULL にするモノトスル。
この~memberは、
以前の結果では ~NULL でなかった場合でも， ~NULL になり得る。
◎
The estimated rate at which queued data will be sent by the user agent, in bits per second. This rate applies to all streams and datagrams that share a WebTransport session and is calculated by the congestion control algorithm (potentially chosen by congestionControl). This estimate excludes any framing overhead and represents the rate at which an application payload might be sent. If the user agent does not currently have an estimate, the member MUST be the null value. The member can be null even if it was not null in previous results.
</dd>

	<dt>
`atSendCapacity@mb
◎
atSendCapacity, of type boolean, defaulting to false
</dt>
	<dd>
値 ~F は、
次を指示する
⇒
`estimatedSendRate$mb は、
応用により制限された
— すなわち、
当の応用が送信している~dataは，
輻輳~制御器が許容するよりも有意に少ない —
かもしれない。
その間は、
輻輳~制御器は，
可用な~network容量として拙い見積もりを生産するかもしれない。
◎
A value of false indicates the estimatedSendRate might be application limited, meaning the application is sending significantly less data than the congestion controller allows. A congestion controller might produce a poor estimate of the available network capacity while it is application limited.
</dd>
	<dd>
値 ~T は、
次を指示する
⇒
当の応用は，
~dataを~network容量ぎりぎりまで送信しているので、
`estimatedSendRate$mb は，
応用に可用な~network容量を反映する。
◎
A value of true indicates the application is sending data at network capacity, and the estimatedSendRate reflects the network capacity available to the application.
</dd>
	<dd class="note">注記：
`estimatedSendRate$mb は、
`atSendCapacity$mb が ~T をとる間は［
応用の送信-~rateが支続される限り，~network条件に順応するよう天井を反映する
］ことになる
— しかしながら、
その間でも ~NULL になることは許容される。
◎
When atSendCapacity is true, the estimatedSendRate reflects a ceiling. As long as the application send rate is sustained, the estimatedSendRate will adapt to network conditions. However, estimatedSendRate is allowed to be null while atSendCapacity is true.
</dd>

	<dt>
`datagrams@mb
◎
</dt>
	<dd class="trans-note">【
この~memberについては、
原文には（他所も含めて）何も述べられていない。
】</dd>
</dl>

		</section>
		<section id="web-transport-datagram-stats">
<h3 title="WebTransportDatagramStats Dictionary">6.14. `WebTransportDatagramStats^I 辞書</h3>

<p>
`WebTransportDatagramStats$I 辞書は、
`下層~接続$越しの~datagram伝送~上の統計を含む。
◎
The WebTransportDatagramStats dictionary includes statistics on datagram transmission over the underlying connection.
</p>

<pre class="idl">
dictionary `WebTransportDatagramStats@I {
  `unsigned long long$ `droppedIncoming$mbD = 0;
  `unsigned long long$ `expiredIncoming$mbD = 0;
  `unsigned long long$ `expiredOutgoing$mbD = 0;
  `unsigned long long$ `lostOutgoing$mbD = 0;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`droppedIncoming@mbD
◎
droppedIncoming, of type unsigned long long, defaulting to 0
</dt>
	<dd>
流入~datagramのうち，次に該当するものの個数
⇒
応用が `datagrams$mT の `readable$mD から読取る前に受信-~queueを~overflowしたことに因り，落とされた
◎
The number of incoming datagrams that were dropped due to the application not reading from datagrams' readable before new datagrams overflow the receive queue.
</dd>

	<dt>
`expiredIncoming@mbD
◎
expiredIncoming, of type unsigned long long, defaulting to 0
</dt>
	<dd>
流入~datagramのうち，次に該当するものの個数
⇒
`incomingMaxAge$mD より旧くなったことに因り，
応用が `datagrams$mT の `readable$mD から読取る前に落とされた
◎
The number of incoming datagrams that were dropped due to being older than incomingMaxAge before they were read from datagrams' readable.
</dd>

	<dt>
`expiredOutgoing@mbD
◎
expiredOutgoing, of type unsigned long long, defaulting to 0
</dt>
	<dd>
送信~用に~queueされた~datagramのうち，次に該当するものの個数
⇒
`outgoingMaxAge$mD より旧くなったことに因り，送信-可能になる前に落とされた
◎
The number of datagrams queued for sending that were dropped due to being older than outgoingMaxAge before they were able to be sent.
</dd>

	<dt>
`lostOutgoing@mbD
◎
lostOutgoing, of type unsigned long long, defaulting to 0
</dt>
	<dd>
送信した~datagramのうち，次に該当するものの個数
⇒
`RFC9002$r `§ 6.1＠~RFCx/rfc9002#section-6.1$ にて定義されるおり，
喪失したものと宣言された
◎
The number of sent datagrams that were declared lost, as defined in [RFC9002] Section 6.1.
</dd>
</dl>

		</section>
	</section>
	<section id="send-stream">
<h2 title="Interface WebTransportSendStream">7. `WebTransportSendStream^I ~interface</h2>

<p>
`WebTransportSendStream$I は、
次のような `WritableStream$I である：
◎
↓</p>
<ul>
	<li>
［
`流出~一方向$／`双方向$
］な`~WebTransport~stream$を伴う，流出~stream用の特能を供する。
◎
A WebTransportSendStream is a WritableStream providing outgoing streaming features with an outgoing unidirectional or bidirectional WebTransport stream.
</li>
	<li>
`Uint8Array$I を書込んで，~serverへ~dataを送信できる。
◎
It is a WritableStream of Uint8Array that can be written to, to send data to the server.
</li>
</ul>


<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$, `Transferable$]
interface `WebTransportSendStream@I : `WritableStream$I {
  attribute `WebTransportSendGroup$I? `sendGroup$mS;
  attribute `long long$ `sendOrder$mS;
  `Promise$&lt;`WebTransportSendStreamStats$I&gt; `getStats$mS();
  `WebTransportWriter$I `getWriter$mS();
};
</pre>

<p>
`WebTransportSendStream$I は、
常に，`作成する$wtS手続-により作成される。
◎
A WebTransportSendStream is always created by the create procedure.
</p>

<p>
`WebTransportSendStream$I の［
`転送-手続き$, `転送-受信-時の手続き$
］は、
`WritableStream$I の`それら＠~STREAMS#ws-transfer$に従う。
◎
The WebTransportSendStream’s transfer steps and transfer-receiving steps are those of WritableStream.
</p>

		<section id="send-stream-attributes">
<h3 title="Attributes">7.1. 属性</h3>

<dl>
	<dt>
`sendGroup@mS
◎
sendGroup, of type WebTransportSendGroup, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレの `SendGroup$slS
◎
The getter steps are:
• Return this’s [[SendGroup]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~NEQ ~NULL
］~AND［
%値 . `Transport$slG ~NEQ コレ . `Transport$slS
］
⇒
~THROW `InvalidStateError$E
◎
If value is non-null, and value.[[Transport]] is not this.[[Transport]], throw an InvalidStateError.
</li>
			<li>
コレ . `SendGroup$slS ~SET %値
◎
Set this.[[SendGroup]] to value.
</li>
		</ol>
	</dd>

	<dt>
`sendOrder@mS
◎
sendOrder, of type long long
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `SendOrder$slS
◎
The getter steps are:
• Return this’s [[SendOrder]].
</dd>
	<dd class="algo">
設定子~手続きは、
`所与の値$ %値 に対し
⇒
コレ . `SendOrder$slS ~SET %値
◎
The setter steps, given value, are:
• Set this.[[SendOrder]] to value.
</dd>
</dl>

		</section>
		<section id="send-stream-methods">
<h3 title="Methods">7.2. ~method</h3>

<dl>
	<dt>
`getStats()@mS
◎
getStats()
</dt>
	<dd>
この `WebTransportSendStream$I の処理能に特有な統計を集めて，
その結果を非同期的に報告する。
◎
Gathers stats specific to this WebTransportSendStream’s performance, and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
コレ【！この `WebTransportSendStream$I】に特有な統計を集める
◎
Gather the stats specific to this WebTransportSendStream.
</li>
					<li>
前~段の統計が準備済みになるまで待機する
◎
Wait for the stats to be ready.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
%統計 ~LET 新たな `WebTransportSendStreamStats$I
◎
Let stats be a new WebTransportSendStreamStats object＼
</li>
							<li>
%統計 の各~memberを集められた統計を表現するよう設定する
◎
representing the gathered stats.
</li>
							<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>

	<dt>`getWriter()@mS</dt>
	<dd>
この~methodは、
`WritableStream$I から継承した `getWriter()$ws と同じ方式で実装するモノトスル
— ただし、
`WritableStreamDefaultWriter$I を作成する所では，
代わりに `WebTransportWriter$I を`作成する$TWモノトスル。
◎
This method must be implemented in the same manner as getWriter inherited from WritableStream, except in place of creating a WritableStreamDefaultWriter, it must instead create a WebTransportWriter with this.
</dd>
</dl>

		</section>
		<section id="send-stream-internal-slots">
<h3 title="Internal Slots">7.3. 内部~slot</h3>

<p>
各 `WebTransportSendStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportSendStream has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`InternalStream@slS</dt>
	<dd>
［
`流出~一方向$／`双方向$
］な`~WebTransport~stream$
◎
An outgoing unidirectional or bidirectional WebTransport stream.
</dd>

	<dt>`PendingOperation@slS</dt>
	<dd>
~NULL ／
処理待ちな［
書込n／~close
］演算を表現している~promise
◎
A promise representing a pending write or close operation, or null.
</dd>

	<dt>`Transport@slS</dt>
	<dd>
この `WebTransportSendStream$I を所有する `WebTransport$I
◎
A WebTransport which owns this WebTransportSendStream.
</dd>

	<dt>`SendGroup@slS</dt>
	<dd>
~NULL ／
ある `WebTransportSendGroup$I
— 既定は ~NULL
◎
An optional WebTransportSendGroup, or null.
</dd>

	<dt>`SendOrder@slS</dt>
	<dd>
送信-順序~番号
— 既定は 0
◎
An optional send order number, defaulting to 0.
</dd>

	<dt>`AtomicWriteRequests@slS</dt>
	<dd>
~promiseたちが成す`有順序~集合$
— これは、［
`下層~sink$が処理するものとして~queueされた書込n要請のうち，不可分（ `atomic^en ）なもの
］たちが成す下位集合を追跡し続ける。
◎
An ordered set of promises, keeping track of the subset of write requests that are atomic among those queued to be processed by the underlying sink.
</dd>
</dl>

		</section>
		<section id="send-stream-procedures">
<h3 title="Procedures">7.4. 手続-</h3>

<div class="algo">
<p>
`WebTransportSendStream$I を
`作成する@wtS
~algoは、
所与の
( ［
`流出~一方向$／`双方向$
］な`~WebTransport~stream$ %内部~stream, `WebTransport$I %~transport, %送信-~group, %送信-順序 )
に対し：
◎
To create a WebTransportSendStream, with an outgoing unidirectional or bidirectional WebTransport stream internalStream, a WebTransport transport, sendGroup, and a sendOrder, run these steps:
</p>

<ol>
	<li>
%~stream ~LET `新たな~obj$( `WebTransportSendStream$I )
— その
⇒＃
`InternalStream$slS ~SET %内部~stream,
`PendingOperation$slS ~SET ~NULL,
`Transport$slS ~SET %~transport,
`SendGroup$slS ~SET %送信-~group,
`SendOrder$slS ~SET %送信-順序,
`AtomicWriteRequests$slS ~SET ~promiseたちが成す新たな`有順序~集合$
◎
Let stream be a new WebTransportSendStream, with:
• [[InternalStream]]
•• internalStream
• [[PendingOperation]]
•• null
• [[Transport]]
•• transport
• [[SendGroup]]
•• sendGroup
• [[SendOrder]]
•• sendOrder
• [[AtomicWriteRequests]]
•• An empty ordered set of promises.
</li>
	<li>
<p>
%~stream を`設定しておく$WS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`書込n~algo^i ~SET 所与の
( %~chunk )
に対し，次を走らす動作
⇒
%~stream に`書込む$wtS( %~chunk )
</li>
			<li class="algo">
`~close~algo^i ~SET 次を走らす動作
⇒
%~stream を`~closeする$wtS()
</li>
			<li class="algo">
`中止-~algo^i ~SET 所与の
( %事由 )
に対し，次を走らす動作
⇒
%~stream を`中止する$wtS( %事由 )
</li>
		</ul>
◎
Let writeAlgorithm be an action that writes chunk to stream, given chunk.
◎
Let closeAlgorithm be an action that closes stream.
◎
Let abortAlgorithm be an action that aborts stream with reason, given reason.
◎
Set up stream with writeAlgorithm set to writeAlgorithm, closeAlgorithm set to closeAlgorithm, abortAlgorithm set to abortAlgorithm.
</li>
	<li>
%中止-通達 ~LET %~stream . `controller^sl . `abortController^sl . `signal^sl
◎
Let abortSignal be stream’s [[controller]].[[abortController]].[[signal]].
</li>
	<li>
<p>
`通達に~algoを追加する$( %中止-通達, 次の手続き )
◎
Add the following steps to abortSignal.
</p>
<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
%処理待ち演算 ~LET %~stream . `PendingOperation$slS
◎
Let pendingOperation be stream.[[PendingOperation]].
</li>
			<li>
~IF［
%処理待ち演算 ~EQ ~NULL
］
⇒
~RET
◎
If pendingOperation is null, then abort these steps.
</li>
			<li>
%~stream . `PendingOperation$slS ~SET ~NULL
◎
Set stream.[[PendingOperation]] to null.
</li>
			<li>
%事由 ~LET %中止-通達 の`中止-事由$aB
◎
Let reason be abortSignal’s abort reason.
</li>
			<li>
%~promise ~LET %~stream を`中止する$wtS( %事由 )
◎
Let promise be the result of aborting stream with reason.
</li>
			<li>
%~promise の`充足-時$には
⇒
`~promiseを却下する$( %処理待ち演算, %事由 )
◎
Upon fulfillment of promise, reject pendingOperation with reason.
</li>
		</ol>
</div>
	</li>
	<li>
%~transport . `SendStreams$sl に %~stream を`付加する$set
◎
Append stream to transport.[[SendStreams]].
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream に
`書込む@wtS
~algoは、
所与の
( %~chunk )
に対し：
◎
To write chunk to a WebTransportSendStream stream, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
~IF［
%~chunk は `BufferSource$I でない
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If chunk is not a BufferSource, return a promise rejected with a TypeError.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~byte列 ~LET %~chunk に`保持された~byte列の複製を取得する$
◎
Let bytes be a copy of the byte sequence which chunk represents.
</li>
	<li>
%~stream . `PendingOperation$slS ~SET %~promise
◎
Set stream.[[PendingOperation]] to promise.
</li>
	<li>
%~in-flight書込n要請 ~LET %~stream . `inFlightWriteRequest$wS
◎
Let inFlightWriteRequest be stream.inFlightWriteRequest.
</li>
	<li>
%不可分か ~LET ~IS［
%~in-flight書込n要請 ~IN %~stream 【！`~stream$bd】 . `AtomicWriteRequests$slS
］
◎
Let atomic be true if stream.[[AtomicWriteRequests]] contains inFlightWriteRequest, otherwise false.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<p>
~IF［
%不可分か ~EQ ~T
］~AND［
現在の~flow制御~窓は %~byte列 全体を送信するには小さ過ぎる
］：
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
</p>

<div class="algo">
<p>
手続きは：
</p>
						<ol>
							<li>
%~stream . `PendingOperation$slS ~SET ~NULL
</li>
							<li>
%~stream 上の`すべての不可分な書込n要請を中止する$wtS()
</li>
						</ol>
</div>
					<li>
~RET
</li>
				</ol>
◎
If atomic is true and the current flow control window is too small for bytes to be sent in its entirety, then＼
abort the remaining steps and＼
queue a network task with transport to run these sub-steps:
• Set stream.[[PendingOperation]] to null.
• Abort all atomic write requests on stream.
</li>
			<li>
%~stream . `InternalStream$slS に %~byte列 を`送信する$WT
◎
Otherwise, send bytes on stream.[[InternalStream]] and＼
</li>
			<li>
<p>
前~段の演算が完了するまで待機する
— この送信は：
◎
wait for the operation to complete.＼
</p>
				<ul>
					<li>
この時点ですでに~queueされたかどうかを問わず，
この~transport越しに送信されることになる［
~stream, ~datagram
］の送信と前後してもヨイ。
◎
This sending MAY be interleaved with sending of previously queued streams and datagrams, as well as streams and datagrams yet to be queued to be sent over this transport.
</li>
					<li>
~UAは、
転送~処理能を改善するために~bufferしてもヨイ。
背圧~情報を `WebTransportSendStream$I の利用元へ運ぶため、
そのような~buffer【の~size】には固定的な上限があるベキである。
◎
The user-agent MAY have a buffer to improve the transfer performance. Such a buffer SHOULD have a fixed upper limit, to carry the backpressure information to the user of the WebTransportSendStream.
</li>
					<li>
<p>
［
~AND↓ を満たす各~stream %送信-~stream
］上に送信するために~queueされたすべての~byteが送信されるまでは，後回するモノトスル：
◎
This sending MUST starve until all bytes queued for sending on streams with＼
</p>
						<ul>
							<li>
%送信-~stream . `SendGroup$slS ~EQ %~stream . `SendGroup$slS
◎
the same [[SendGroup]] and＼
</li>
							<li>
%送信-~stream . `SendOrder$slS ~GT %~stream . `SendOrder$slS
◎
a higher [[SendOrder]],＼
</li>
							<li>
~NOT `~error＠~STREAMS#writablestream-error$WSした
◎
that are neither errored＼
</li>
							<li>
~NOT `~flow制御$により阻まれた
◎
nor blocked by flow control, have been sent.
</li>
						</ul>
<p>
ここでは、
%~stream . `SendOrder$slS に対し`並列的$に~accessする。
~UAは、
送信している間，この値の~liveな更新に応答するベキである
— その詳細は、
`実装定義$であるが。
◎
We access stream.[[SendOrder]] in parallel here. User agents SHOULD respond to live updates of these values during sending, though the details are implementation-defined.
</p>

<p class="note">注記：
再-伝送の順序付けは，`実装定義$であるが、
~UAには，~dataの再-伝送を［
`SendOrder$slS 値が高いものほど優先する
］ことが強く奨励される。
◎
Note: Ordering of retransmissions is implementation-defined, but user agents are strongly encouraged to prioritize retransmissions of data with higher [[SendOrder]] values.
</p>
					</li>
					<li>
前項により後回されるもの，および`~flow制御$の［
事由／`~error＠~STREAMS#writablestream-error$WS
］を除き、
後回しないモノトスル。
◎
This sending MUST NOT starve otherwise, except for flow control reasons or error.
</li>
					<li>
<p>
~UAは、［
後回されていない~stream
］たちすべての間で，帯域幅を公平に分合うベキである。
◎
The user agent SHOULD divide bandwidth fairly between all streams that aren’t starved.
</p>

<p class="note">注記：
ここでの公平さを成す定義は、
`実装定義$である。
◎
Note: The definition of fairness here is implementation-defined.
</p>
					</li>
				</ul>
			</li>
			<li>
<p>
~IF［
前~段は~network~errorに因り失敗した
］
⇒
~RET
◎
If the previous step failed due to a network error, abort the remaining steps.
</p>

<p class="note">注記：
ここでは %~promise を却下しない
— ~network~errorは他所で取扱われ、
そこでの手続きが %~stream . `PendingOperation$slS を却下するので。
◎
Note: We don’t reject promise here because we handle network errors elsewhere, and those steps reject stream.[[PendingOperation]].
</p>
			</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Otherwise, queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream . `PendingOperation$slS ~SET ~NULL
◎
Set stream.[[PendingOperation]] to null.
</li>
					<li>
~IF［
%~in-flight書込n要請 ~IN %~stream . `AtomicWriteRequests$slS
］
⇒
%~in-flight書込n要請 を`除去する$
◎
If stream.[[AtomicWriteRequests]] contains inFlightWriteRequest, remove inFlightWriteRequest.
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

<p class="note">注記：
この~algo（あるいは `write()$dw ）から返された~promiseが`充足されても＠~ECMA262#sec-promise-objects$，
~chunkが~serverにより `ack^en される<strong>とは限らない</strong> `QUIC$r
— ~chunkが~bufferに付加されたことしか意味しないこともある。
当の~chunkが~serverに必ず到着するようにするためには、
~serverは，応用~levelの承認（ `acknowledgment^en ）~messageを送信する必要がある。
◎
Note: The fulfillment of the promise returned from this algorithm (or, write(chunk)) does NOT necessarily mean that the chunk is acked by the server [QUIC]. It may just mean that the chunk is appended to the buffer. To make sure that the chunk arrives at the server, the server needs to send an application-level acknowledgment message.
</p>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream を
`~closeする@wtS
~algoは：
◎
To close a WebTransportSendStream stream, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
	<li>
%~stream . `PendingOperation$slS ~SET %~promise
◎
Set stream.[[PendingOperation]] to promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~stream . `InternalStream$slS に~FINを`送信する$WT
◎
Send FIN on stream.[[InternalStream]] and＼
</li>
			<li>
前~段の演算が完了するまで待機する
◎
wait for the operation to complete.
</li>
			<li>
<p>
%~stream . `InternalStream$slS が “すべての~dataは~commitされた（ `all data committed^en ）”† 状態になるまで待機する
`QUIC$r
</p>

<p class="trans-note">【†
`QUIC$r には、
そのような句は見当たらない
— 以前は “`Data Recvd^en” と称されていたが。
なぜ，このように`改称された＠https://github.com/w3c/webtransport/commit/ec3ee7261d0262f603a5a99071c6ef4ed596bc31$のかは不明。
】</p>
◎
Wait for stream.[[InternalStream]] to enter the "all data committed" state. [QUIC]
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream . `PendingOperation$slS ~SET ~NULL
◎
Set stream.[[PendingOperation]] to null.
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream を
`中止する@wtS
~algoは、
所与の
( %事由 )
に対し：
◎
To abort a WebTransportSendStream stream with reason, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~code ~LET 0
◎
Let code be 0.
</li>
	<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
	<li>
~IF［
%事由 は `WebTransportError$I である
］~AND［
%事由 . `StreamErrorCode$sl ~NEQ ~NULL
］
⇒
%~code ~SET %事由 . `StreamErrorCode$sl
◎
If reason is a WebTransportError and reason.[[StreamErrorCode]] is not null, then set code to reason.[[StreamErrorCode]].
</li>
	<li>
~IF［
%~code ~LT 0
］
⇒
%~code ~SET 0
◎
If code &lt; 0, then set code to 0.
</li>
	<li>
<p>
~IF［
%~code ~GT 4294967295
］
⇒
%~code ~SET 4294967295
◎
If code &gt; 4294967295, then set code to 4294967295.
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
`下層~接続$が~HTTP3を利用している場合、
`WEB-TRANSPORT-HTTP3$r にて述べられる【！decribe】とおり，
~codeは整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } に符号化されることになる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. If the underlying connection is using HTTP/3, the code will be encoded to a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~stream . `InternalStream$slS を`設定し直す$WT( %~code )
◎
Reset stream.[[InternalStream]] with code.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
◎
resolve promise with undefined.
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream 上の
`すべての不可分な書込n要請を中止する@wtS
~algoは：
◎
To abort all atomic write requests on a WebTransportSendStream stream, run these steps:
</p>
<ol>
	<li>
%書込n要請~群 ~LET %~stream . `writeRequests$wS
◎
Let writeRequests be stream.writeRequests.
</li>
	<li>
%中止する要請~群 ~LET %~stream【！`~stream$bd】 . `AtomicWriteRequests$slS
◎
Let requestsToAbort be stream.[[AtomicWriteRequests]].
</li>
	<li>
%書込n要請~群 を成す
~EACH( %~promise )
に対し
⇒
~IF［
%~promise ~NIN %中止する要請~群
］
⇒
%~stream を`~errorにする$WS( `AbortError$E 例外 )；
~RET
◎
If writeRequests contains a promise not in requestsToAbort, then error stream with AbortError, and abort these steps.
</li>
	<li>
%~stream【！`~stream$bd】 . `AtomicWriteRequests$slS を`空にする$
◎
Empty stream.[[AtomicWriteRequests]].
</li>
	<li>
%中止する要請~群 を成す
~EACH( %~promise )
に対し
⇒
`~promiseを却下する$( %~promise, `AbortError$E 例外 )
◎
For each promise in requestsToAbort, reject promise with AbortError.
</li>
	<li class="algo">
この段は`並列的$に走らす
⇒
%中止する要請~群 を成す
~EACH( %~promise )
に対し
⇒
次を中止する
⇒
%~stream に［
%~promise に結付けられた~byte列
］を`送信する$WT
◎
In parallel, for each promise in requestsToAbort, abort the sending of bytes associated with promise.
</li>
</ol>
</div>

		</section>
		<section id="send-stream-STOP_SENDING">
<h3 title="STOP_SENDING signal coming from the server">7.5. ~serverから来ている `STOP_SENDING^ft 通達</h3>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream に結付けられた `~WebTransport~stream$が，~serverから `STOP_SENDING$ft ~frame %通達 を取得したときは、
次の手続きを走らす：
◎
Whenever a WebTransport stream associated with a WebTransportSendStream stream gets a STOP_SENDING signal from the server, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
<p>
%~code ~LET %通達 に付された応用~protocol~error~code
`QUIC$r
◎
Let code be the application protocol error code attached to the STOP_SENDING frame. [QUIC]
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
`下層~接続$が~HTTP3を利用している場合、
`WEB-TRANSPORT-HTTP3$r にて述べられる【！decribe】とおり，
~codeは整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } に符号化されることになる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. If the underlying connection is using HTTP/3, the code will be encoded to a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `stream^l, %~code )
◎
Let error be a newly created WebTransportError whose source is "stream" and streamErrorCode is code.
</li>
			<li>
~IF［
%~stream . `PendingOperation$slS ~NEQ ~NULL
］
⇒
`~promiseを却下する$( %~stream . `PendingOperation$slS, %~error )
◎
If stream.[[PendingOperation]] is not null, reject stream.[[PendingOperation]] with error.
</li>
			<li>
%~stream を`~errorにする$WS( %~error )
◎
Error stream with error.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="send-stream-stats">
<h3 title="WebTransportSendStreamStats Dictionary">7.6. `WebTransportSendStreamStats^I 辞書</h3>

<p>
`WebTransportSendStreamStats$I 辞書は、
ある `WebTransportSendStream$I に特有な統計の情報を含む。
◎
The WebTransportSendStreamStats dictionary includes information on stats specific to one WebTransportSendStream.
</p>

<pre class="idl">
dictionary `WebTransportSendStreamStats@I {
  `unsigned long long$ `bytesWritten$mbS = 0;
  `unsigned long long$ `bytesSent$mbS = 0;
  `unsigned long long$ `bytesAcknowledged$mbS = 0;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`bytesWritten@mbS
◎
bytesWritten, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の応用が この `WebTransportSendStream$I に成功裡に書込んだ総~byte数。
この数は、
決して減少しない。
◎
The total number of bytes the application has successfully written to this WebTransportSendStream. This number can only increase.
</dd>

	<dt>
`bytesSent@mbS
◎
bytesSent, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の応用が この `WebTransportSendStream$I に書込んだ~byte列のうち，
何~byteが一回以上~送信されたかを指示する。
この数は、
決して減少しないことに加え，
常に `bytesWritten$mbS 以下になる。
◎
An indicator of progress on how many of the application bytes written to this WebTransportSendStream has been sent at least once. This number can only increase, and is always less than or equal to bytesWritten.
</dd>
	<dd class="note">注記：
この進捗は、
単独の~streamに送信された応用~dataに限られ，
~network~overheadを含まない。
◎
Note: this is progress of app data sent on a single stream only, and does not include any network overhead.
</dd>

	<dt>
`bytesAcknowledged@mbS
◎
bytesAcknowledged, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の応用が この `WebTransportSendStream$I に書込んだ~byte列のうち，
何~byteが［
送信され、
~serverにより受信されるに伴い，~QUICの~ACK用の仕組みを利用して認知されたか
］を指示する。
数えられるのは、［
認知されなかった最初の~byte
］の直前までに限られる。
この数は、
決して減少しないことに加え，
常に `bytesSent$mbS 以下になる。
◎
An indicator of progress on how many of the application bytes written to this WebTransportSendStream have been sent and acknowledged as received by the server using QUIC’s ACK mechanism. Only sequential bytes up to, but not including, the first non-acknowledged byte, are counted. This number can only increase and is always less than or equal to bytesSent.
</dd>
	<dd class="note">注記：
この値は、
~HTTP2越しの接続においては，
`bytesSent$mbS に合致することになる。
◎
Note: This value will match bytesSent when the connection is over HTTP/2.
</dd>
</dl>

		</section>
	</section>
	<section id="sendGroup">
<h2 title="Interface WebTransportSendGroup">8. ~interface `WebTransportSendGroup^I</h2>

<p>
`WebTransportSendGroup$I は、
任意選択な組織化用の~objであり，
多数の個々の（概して，`厳密に順序付けられた＠#strict-ordering$） `WebTransportSendStream$I たちにわたる~dataの伝送を追跡する。
◎
A WebTransportSendGroup is an optional organizational object that tracks transmission of data spread across many individual (typically strictly ordered) WebTransportSendStreams.
</p>

<p>
各 `WebTransportSendStream$I は、
その作成~時に，あるいは［
その `sendGroup$mS 設定子を通して，いつでも
］，ある `WebTransportSendGroup$I が表現する
`送信-~group@
に属するようにし得る。
既定では、
どの`送信-~group$にも
`属さない＠#ungrouped@
とする†。
◎
WebTransportSendStreams can, at their creation or through assignment of their sendGroup attribute, be grouped under at most one WebTransportSendGroup at any time. By default, they are ungrouped.
</p>

<p class="trans-note">【†
そのような `WebTransportSendStream$I たちは、
次の段落に述べる目的においては，
“匿名な送信-~group” に属するものとして扱うものと推定される。
】</p>

<p>
~UAは、
各`送信-~group$を等しく考慮する下で，
それらに属する `WebTransportSendStream$I の送信~用に帯域幅を割振る。
異なる`送信-~group$に属する `WebTransportSendStream$I どうしの
`sendOrder$mb 番号は別々に評価される
【すなわち、互いの送信-順序には影響しない】。
◎
The user agent considers WebTransportSendGroups as equals when allocating bandwidth for sending WebTransportSendStreams. Each WebTransportSendGroup also establishes a separate numberspace for evaluating sendOrder numbers.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransportSendGroup@I {
  `Promise$&lt;`WebTransportSendStreamStats$I&gt; `getStats$mG();
};
</pre>

<p>
`WebTransportSendGroup$I は、
常に，`作成する$TSG 手続-により作成される。
◎
A WebTransportSendGroup is always created by the create procedure.
</p>

		<section id="sendGroup-methods">
<h3 title="Methods">8.1. ~method</h3>

<dl>
	<dt>`getStats()@mG</dt>
	<dd>
この`送信-~group$に属するすべての `WebTransportSendStream$I からの統計を集成して，
その結果を非同期的に報告する。
◎
Aggregates stats from all WebTransportSendStreams grouped under this sendGroup, and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li>
%~stream群 ~LET 次を満たす すべての `WebTransportSendStream$I たちが成す集合
⇒
その `SendGroup$slS ~EQ コレ
◎
Let streams be all WebTransportSendStreams whose [[SendGroup]] is this.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
%統計~data ~LET %~stream群 を成す すべての~streamから~stream統計を集めて集成された~data
◎
Gather stream statistics from all streams in streams.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
%統計 ~LET 新たな `WebTransportSendStreamStats$I
◎
Let stats be a new WebTransportSendStreamStats object＼
</li>
							<li>
%統計 を成す各~memberを %統計~data を表現するよう初期化する
◎
representing the aggregate numbers of the gathered stats.
</li>
							<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="sendGroup-internal-slots">
<h3 title="Internal Slots">8.2. 内部~slot</h3>

<p>
各 `WebTransportSendGroup$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportSendGroup has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>
`Transport@slG
</dt>
	<dd>
この `WebTransportSendGroup$I を所有している `WebTransport$I ~obj
◎
The WebTransport object owning this WebTransportSendGroup.
</dd>
</dl>

		</section>
		<section id="sendGroup-procedures">
<h3 title="Procedures">8.3. 手続-</h3>

<div class="algo">
<p>
`WebTransportSendGroup$I を
`作成する@TSG
~algoは、
所与の
( `WebTransport$I %~transport )
に対し：
◎
To create a WebTransportSendGroup, with a WebTransport transport, run these steps:
</p>
<ol>
	<li>
%送信-~group ~LET `新たな~obj$( `WebTransportSendGroup$I )
— その
⇒＃
`Transport$slG ~SET %~transport
◎
Let sendGroup be a new WebTransportSendGroup, with:
◎
[[Transport]]
• transport
</li>
	<li>
~RET %送信-~group
◎
Return sendGroup.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="receive-stream">
<h2 title="Interface WebTransportReceiveStream">9. `WebTransportReceiveStream^I ~interface</h2>

<p>
`WebTransportReceiveStream$I は、
次のような `ReadableStream$I である：
◎
↓</p>
<ul>
	<li>
［
`流入~一方向$／`双方向$
］な`~WebTransport~stream$を伴う流入~stream用の特能を供する。
◎
A WebTransportReceiveStream is a ReadableStream providing incoming streaming features with an incoming unidirectional or bidirectional WebTransport stream.
</li>
	<li>
そこから `Uint8Array$I を読取って，
~serverから受信した~dataを消費できる。
◎
It is a ReadableStream of Uint8Array that can be read from, to consume data received from the server.＼
</li>
	<li>
`可読~byte~stream$でもある。
よって，それは、
`既定の読取器$のみならず，
`~BYOB読取器$を利用することを消費器に許容する。
◎
WebTransportReceiveStream is a readable byte stream, and hence it allows its consumers to use a BYOB reader as well as a default reader.
</li>
</ul>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$, `Transferable$]
interface `WebTransportReceiveStream@I : `ReadableStream$I {
  `Promise$&lt;`WebTransportReceiveStreamStats$I&gt; `getStats$mR();
};
</pre>

<p>
`WebTransportReceiveStream$I は、
常に，それを`作成する$wtR手続-により作成される。
◎
A WebTransportReceiveStream is always created by the create procedure.
</p>

<p>
`WebTransportReceiveStream$I の［
`転送-手続き$／`転送-受信-時の手続き$
］は
`ReadableStream$I の`それら＠~STREAMS#rs-transfer$に従う。
◎
The WebTransportReceiveStream’s transfer steps and transfer-receiving steps are those of ReadableStream.
</p>

		<section id="receive-stream-methods">
<h3 title="Methods">9.1. ~method</h3>

<dl>
	<dt>
`getStats()@mR
◎
getStats()
</dt>
	<dd>
この `WebTransportReceiveStream$I の処理能に特有な統計を集めて，
その結果を非同期的に報告する。
◎
Gathers stats specific to this WebTransportReceiveStream’s performance, and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
コレ【！この `WebTransportReceiveStream$I】に特有な統計を集める
◎
Gather the stats specific to this WebTransportReceiveStream.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
%統計 ~LET 新たな `WebTransportReceiveStreamStats$I
~obj
◎
Let stats be a new WebTransportReceiveStreamStats object＼
</li>
							<li>
%統計 の各~memberを集められた統計を表現するよう設定する
◎
representing the gathered stats.
</li>
							<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="receive-stream-internal-slots">
<h3 title="Internal Slots">9.2. 内部~slot</h3>

<p>
各 `WebTransportReceiveStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportReceiveStream has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`InternalStream@slR</dt>
	<dd>
［
`流入~一方向$／`双方向$
］な`~WebTransport~stream$
◎
An incoming unidirectional or bidirectional WebTransport stream.
</dd>

	<dt>`Transport@slR</dt>
	<dd>
この `WebTransportReceiveStream$I を所有している `WebTransport$I ~obj
◎
The WebTransport object owning this WebTransportReceiveStream.
</dd>
</dl>

		</section>
		<section id="receive-stream-procedures">
<h3 title="Procedures">9.3. 手続-</h3>

<div class="algo">
<p>
`WebTransportReceiveStream$I を
`作成する@wtR
~algoは、
所与の
( ［
`流入~一方向$／`双方向$
］な`~WebTransport~stream$ %内部~stream, `WebTransport$I %~transport )
に対し：
◎
To create a WebTransportReceiveStream, with an incoming unidirectional or bidirectional WebTransport stream internalStream and a WebTransport transport, run these steps:
</p>
<ol>
	<li>
%~stream ~LET `新たな~obj$( `WebTransportReceiveStream$I )
— その
⇒＃
`InternalStream$slR ~SET %内部~stream,
`Transport$slR ~SET %~transport
◎
Let stream be a new WebTransportReceiveStream, with:
• [[InternalStream]]
•• internalStream
• [[Transport]]
•• transport
</li>
	<li>
<p>
%~stream を`~byte読取り~support付きで設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET  次を走らす動作
⇒
%~stream から`~byte列を~pullする$wtR
</li>
			<li class="algo">
`取消~algo^i ~SET  所与の
( %事由 )
に対し，次を走らす動作
⇒
%~stream を`取消す$wtR( %事由 )
</li>
		</ul>

◎
Let pullAlgorithm be an action that pulls bytes from stream.
◎
Let cancelAlgorithm be an action that cancels stream with reason, given reason.
◎
Set up with byte reading support stream with pullAlgorithm set to pullAlgorithm and cancelAlgorithm set to cancelAlgorithm.
</li>
	<li>
%~transport . `ReceiveStreams$sl に %~stream を`付加する$set
◎
Append stream to transport.[[ReceiveStreams]].
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportReceiveStream$I %~stream から
`~byte列を~pullする@wtR
~algoは：
◎
To pull bytes from a WebTransportReceiveStream stream, run these steps.
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slR
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%内部~stream ~LET %~stream . `InternalStream$slR
◎
Let internalStream be stream.[[InternalStream]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~buffer ~LET ~NULL
◎
↓</li>
	<li>
%~offset ~LET ~NULL
◎
↓</li>
	<li>
%最大-~byte数 ~LET ~NULL
◎
Let buffer, offset, and maxBytes be null.
</li>
	<li>
%~view ~LET %~stream 用の`現在の~BYOB要請~view$RS
◎
↓</li>
	<li>
<p>
~IF［
%~view ~NEQ ~NULL
］：
◎
If stream’s current BYOB request view for stream is not null:
</p>
		<ol>
			<li>
%~offset ~SET %~view . `ByteOffset^sl
◎
Set offset to stream’s current BYOB request view.[[ByteOffset]].
</li>
			<li>
%最大-~byte数 ~SET %~view の`~byte長さ$BS
◎
Set maxBytes to stream’s current BYOB request view’s byte length.
</li>
			<li>
%~buffer ~SET %~view の`下層~buffer$BS
◎
Set buffer to stream’s current BYOB request view’s underlying buffer.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~offset ~SET 0
◎
Set offset to 0.
</li>
			<li>
%最大-~byte数 ~SET `実装定義$な~size
◎
Set maxBytes to an implementation-defined size.
</li>
			<li>
<p>
%~buffer ~SET `~buffer~sourceを~byte列から作成する$( `ArrayBuffer$I, ~size %最大-~byte数 の~byte列† )
【† ~byte列の内容は指定されていない（すべて 0 ？）。】
</p>

<p>
~IF［
`ArrayBuffer$I を割振ることに失敗した
］
⇒
~RET `却下される~promise$( `RangeError$E )
</p>
◎
Set buffer be a new ArrayBuffer with maxBytes size. If allocating the ArrayBuffer fails, return a promise rejected with a RangeError.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<div>
<p>
次を遂行する：
◎
↓</p>
				<ol>
					<li>
%内部~stream にて［
1 個以上の~byteが読取られるか ~FIN が受信される
］まで待機する
</li>
					<li>
%~FINを受信したか ~LET ~IS［
前~段にて ~FIN が受信された
］
</li>
					<li>
%~byte列 ~LET ［
%内部~stream から %最大-~byte数 個までの~byteたち
］を読取った結果が成す~byte列
</li>
					<li>
`配列~bufferの中へ~byte列を書込む$( %~buffer, %~byte列, %~offset )
</li>
				</ol>
◎
Write the bytes that area read from internalStream into buffer with offset offset, up to maxBytes bytes. Wait until either at least one byte is read or FIN is received. Let read be the number of read bytes, and let hasReceivedFIN be whether FIN was accompanied.
</div>

<p>
~UAは、
転送~処理能を改善するために~bufferしてもヨイ。
背圧~情報を~serverへ運ぶため、
そのような~buffer【の~size】には固定的な上限があるベキである。
◎
The user-agent MAY have a buffer to improve the transfer performance. Such a buffer SHOULD have a fixed upper limit, to carry the backpressure information to the server.
</p>

<p class="note">注記：
この演算は、
%~buffer がすべて埋まる前に返ることもある。
◎
Note: This operation may return before filling up all of buffer.
</p>
			</li>
			<li>
<p>
~IF［
前~段は失敗した
］
⇒
~RET
◎
If the previous step failed, abort the remaining steps.
</p>

<p class="note">注記：
ここでは %~promise を却下しない
— ~network~errorは他所で取扱われ、
そこでの手続きが %~stream を~errorにして，
この~pullを待受けている読取n要請を却下するので。
◎
Note: We don’t reject promise here because we handle network errors elsewhere, and those steps error stream, which rejects any read requests awaiting this pull.
</p>
			</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>

<p class="note">注記：
%~buffer 【！the buffer described above】が，
この手続-が走っている`~event~loop$aG内で可用である場合、
次の手続きは，即時に走れる／走らせてもヨイ。
◎
Note: If the buffer described above is available in the event loop where this procedure is running, the following steps may run immediately.
</p>
				<ol>
					<li>
%長さ ~LET %~byte列 の`長さ$byte
◎
↑</li>
					<li>
<p>
~IF［
%長さ ~GT 0
］：
◎
If read &gt; 0:
</p>
						<ol>
							<li>
<p>
%~view ~SET 新たな `Uint8Array$I `with^en† %~buffer, %~offset, %長さ
</p>

<p class="trans-note">【†
%~buffer 内の［
%~offset から %長さ 個の~byteが成す~byte列
］への~viewを表現している新たな `Uint8Array$I 
】</p>
◎
Set view to a new Uint8Array with buffer, offset and read.
</li>
							<li>
%~stream の中へ`~chunkを~enqueueする$RS( %~view )
◎
Enqueue view into stream.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~FINを受信したか ~EQ ~T
］：
◎
If hasReceivedFIN is true:
</p>
						<ol>
							<li>
%~transport . `ReceiveStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[ReceiveStreams]].
</li>
							<li>
%~stream を`~closeする$RS
◎
Close stream.
</li>
						</ol>
					</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportReceiveStream$I %~stream を
`取消す@wtR
~algoは、
所与の
( %事由 )
に対し：
◎
To cancel a WebTransportReceiveStream stream with reason, run these steps.
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slR
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%内部~stream ~LET %~stream . `InternalStream$slR
◎
Let internalStream be stream.[[InternalStream]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~code ~LET 0
◎
Let code be 0.
</li>
	<li>
~IF［
%事由 は `WebTransportError$I である
］~AND［
%事由 . `StreamErrorCode$sl ~NEQ ~NULL
］
⇒
%~code ~SET %事由 . `StreamErrorCode$sl
◎
If reason is a WebTransportError and reason.[[StreamErrorCode]] is not null, then set code to reason.[[StreamErrorCode]].
</li>
	<li>
~IF［
%~code ~LT 0
］
⇒
%~code ~SET 0
◎
If code &lt; 0, then set code to 0.
</li>
	<li>
<p>
~IF［
%~code ~GT 4294967295
］
⇒
%~code ~SET 4294967295
◎
If code &gt; 4294967295, then set code to 4294967295.
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
`下層~接続$が~HTTP3を利用している場合、
`WEB-TRANSPORT-HTTP3$r にて述べられる【！decribe】とおり，
~codeは整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } に符号化されることになる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. If the underlying connection is using HTTP/3, the code will be encoded to a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%内部~stream 上の`送信を停止させる$WT( %~code )
◎
Send STOP_SENDING with internalStream and code.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
<p class="note">注記：
%~buffer 【！the buffer described above】が，
この手続-が走っている`~event~loop$aG内で可用である場合、
次の手続きは，即時に走れる／走らせてもヨイ。
◎
Note: If the buffer described above is available in the event loop where this procedure is running, the following steps may run immediately.
</p>
				<ol>
					<li>
%~transport . `ReceiveStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[ReceiveStreams]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

		</section>
		<section id="receive-stream-RESET_STREAM">
<h3 title="Reset signal coming from the server">9.4. ~serverから来ている `RESET_STREAM^ft 通達</h3>

<div class="algo">
<p>
`WebTransportReceiveStream$I %~stream に結付けられた `~WebTransport~stream$が ~serverから `RESET_STREAM$ft ~frame %通達 を取得したときは，次の手続きを走らす：
◎
Whenever a WebTransport stream associated with a WebTransportReceiveStream stream gets a RESET_STREAM signal from the server, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slR
◎
Let transport be stream.[[Transport]].
</li>
	<li>
<p>
%~code ~LET %通達 に付された応用~protocol~error~code
`QUIC$r
◎
Let code be the application protocol error code attached to the RESET_STREAM frame. [QUIC]
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
`下層~接続$が~HTTP3を利用している場合、
`WEB-TRANSPORT-HTTP3$r にて述べられる【！decribe】とおり，
~codeは整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } に符号化されることになる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. If the underlying connection is using HTTP/3, the code will be encoded to a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~transport . `ReceiveStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[ReceiveStreams]].
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `stream^l, %~code )
◎
Let error be a newly created WebTransportError whose source is "stream" and streamErrorCode is code.
</li>
			<li>
%~stream を`~errorにする$RS( %~error )
◎
Error stream with error.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="receive-stream-stats">
<h3 title="WebTransportReceiveStreamStats Dictionary">9.5. `WebTransportReceiveStreamStats^I 辞書</h3>

<p>
`WebTransportReceiveStreamStats$I 辞書は、
ある `WebTransportReceiveStream$I に特有な統計の情報を含む。
◎
The WebTransportReceiveStreamStats dictionary includes information on stats specific to one WebTransportReceiveStream.
</p>

<pre class="idl">
dictionary `WebTransportReceiveStreamStats@I {
  `unsigned long long$ `bytesReceived$mbR = 0;
  `unsigned long long$ `bytesRead$mbR = 0;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`bytesReceived@mbR
◎
bytesReceived, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の `WebTransportReceiveStream$I 用に意図された~server応用からの~byte列のうち，
これまでに何~byteが受信されたかを指示する。
数えられるのは、
最初の欠落な~byteの直前までに限られる。
この数は、
決して減少しない。
◎
An indicator of progress on how many of the server application’s bytes intended for this WebTransportReceiveStream have been received so far. Only sequential bytes up to, but not including, the first missing byte, are counted. This number can only increase.
</dd>
	<dd class="note">注記：
この進捗は、
単独の~streamに受信された応用~dataに限られ，
~network~overheadを含まない。
◎
Note: this is progress of app data received on a single stream only, and does not include any network overhead.
</dd>
	<dt>
`bytesRead@mbR
◎
bytesRead, of type unsigned long long, defaulting to 0
</dt>
	<dd>
当の応用が，この `WebTransportReceiveStream$I から成功裡に読取った総-~byte数。
この数は、
決して減少しないことに加え，
常に `bytesReceived$mbR 以下になる。
◎
The total number of bytes the application has successfully read from this WebTransportReceiveStream. This number can only increase, and is always less than or equal to bytesReceived.
</dd>
</dl>

		</section>
	</section>
	<section id="bidirectional-stream">
<h2 title="Interface WebTransportBidirectionalStream">10. `WebTransportBidirectionalStream^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransportBidirectionalStream@I {
  readonly attribute `WebTransportReceiveStream$I `readable$mB;
  readonly attribute `WebTransportSendStream$I `writable$mB;
};
</pre>

		<section id="bidirectional-stream-internal-slots">
<h3 title="Internal slots">10.1. 内部~slot</h3>

<p>
各 `WebTransportBidirectionalStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportBidirectionalStream has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`Readable@slB</dt>
	<dd>
ある `WebTransportReceiveStream$I
◎
A WebTransportReceiveStream.
</dd>

	<dt>`Writable@slB</dt>
	<dd>
ある `WebTransportSendStream$I
◎
A WebTransportSendStream.
</dd>

	<dt>`Transport@slB</dt>
	<dd>
この `WebTransportBidirectionalStream$I を所有している `WebTransport$I ~obj
◎
The WebTransport object owning this WebTransportBidirectionalStream.
</dd>
</dl>

		</section>
		<section id="bidirectional-stream-attributes">
<h3 title="Attributes">10.2. 属性</h3>

<dl>
	<dt>
`readable@mB
◎
readable, of type WebTransportReceiveStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Readable$slB
◎
The getter steps are to return this’s [[Readable]].
</dd>

	<dt>
`writable@mB
◎
writable, of type WebTransportSendStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Writable$slB
◎
The getter steps are to return this’s [[Writable]].
</dd>
</dl>

		</section>
		<section id="bidirectional-stream-procedures">
<h3 title="Procedures">10.3. 手続-</h3>

<div class="algo">
<p>
`WebTransportBidirectionalStream$I を
`作成する@wtB
~algoは、
所与の
( `双方向$な`~WebTransport~stream$ %内部~stream, `WebTransport$I ~obj %~transport, %送信-順序 )
に対し：
◎
To create a WebTransportBidirectionalStream with a bidirectional WebTransport stream internalStream, a WebTransport object transport, and a sendOrder, run these steps.
</p>
<ol>
	<li>
%可読~stream ~LET `WebTransportReceiveStream$I を`作成する$wtR( %内部~stream, %~transport )
◎
Let readable be the result of creating a WebTransportReceiveStream with internalStream and transport.
</li>
	<li>
%可書~stream ~LET `WebTransportSendStream$I を`作成する$wtS( %内部~stream, %~transport, %送信-順序 )
◎
Let writable be the result of creating a WebTransportSendStream with internalStream, transport, and sendOrder.
</li>
	<li>
%~stream ~LET `新たな~obj$( `WebTransportBidirectionalStream$I )
— その
⇒＃
`Readable$slB ~SET %可読~stream,
`Writable$slB ~SET %可書~stream,
`Transport$slB ~SET %~transport
◎
Let stream be a new WebTransportBidirectionalStream, with:
• [[Readable]]
•• readable
• [[Writable]]
•• writable
• [[Transport]]
•• transport
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="web-transport-writer-interface">
<h2 title="WebTransportWriter Interface">11. `WebTransportWriter^I ~interface</h2>

<p>
`WebTransportWriter$I は、
`WritableStreamDefaultWriter$I の下位classであり，
1 個の~methodを追加する。
◎
WebTransportWriter is a subclass of WritableStreamDefaultWriter that adds one method.
</p>

<p>
`WebTransportWriter$I は、
常に，`作成する$TW手続-により作成される。
◎
A WebTransportWriter is always created by the create procedure.
</p>


<pre class="idl">
[Exposed=*, `SecureContext$]
interface `WebTransportWriter@I : `WritableStreamDefaultWriter$I {
  `Promise$&lt;`undefined$&gt; `atomicWrite$dw(optional `any$ %chunk);
};
</pre>

		<section id="web-transport-writer-methods">
<h3 title="Methods">11.1. ~method</h3>

<dl>
	<dt>`atomicWrite(chunk)@dw</dt>
	<dd>
この~method【が返す~promise】は、［
送信~時点における現在の~flow制御~窓
］の中で %chunk 全体を送信できなかった場合には，却下されることになる。
この挙動は、［
`~flow制御$の~deadlockに敏感な，~dataを不可分的（ `transactional^en ）に送信する~~限定的な応用
］を満足するために設計された
（ `RFC9308$r `§ 4.4＠~RFCx/rfc9308#section-4.4$ ）。
◎
The atomicWrite method will reject if the chunk given to it could not be sent in its entirety within the flow control window that is current at the time of sending. This behavior is designed to satisfy niche transactional applications sensitive to flow control deadlocks ([RFC9308] Section 4.4).
</dd>
	<dd class="note">注記：
この~methodは、
送信~後であっても，一部の~dataを却下し得る。
それは、
~flow制御に関する不可分~性を供するが，他の~errorも生じ得る。
この~methodは、
~dataが［
複数の~packetに分割される／他の~dataと前後する
］ことを防止しない。
この~methodが可用な~flow制御~creditの欠如に因り失敗するか否かを知れるのは、
送信者に限られる。
◎
Note: atomicWrite can still reject after sending some data. Though it provides atomicity with respect to flow control, other errors may occur. atomicWrite does not prevent data from being split between packets or being interleaved with other data. Only the sender learns if atomicWrite fails due to lack of available flow control credit.
</dd>
	<dd class="note">注記：
不可分な書込nは、
不可分でない書込nに~~後続して~queueされた場合には，依然として阻まれる。
不可分な書込nが却下された場合、
その時点で それに~~後続して~queueされた書込nもすべて却下されることになる。
この仕方で却下された不可分でない書込nは、
当の~streamを`~errorにする$WSことになる。
したがって、
応用には，不可分な書込nを常に待受けることが奨励される。
◎
Note: Atomic writes can still block if queued behind non-atomic writes. If the atomic write is rejected, everything queued behind it at that moment will be rejected as well. Any non-atomic writes rejected in this way will error the stream. Applications are therefore encouraged to always await atomic writes.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When atomicWrite is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~promise ~LET コレ上の `write$dw 手続き( %chunk )
◎
Let p be the result of write(chunk) on WritableStreamDefaultWriter with chunk.
</li>
			<li>
%~stream . `AtomicWriteRequests$slS に %~promise を`付加する$set
◎
Append p to stream.[[AtomicWriteRequests]].
</li>
			<li>
<p>
~RET `~promiseに反応する$( %~promise )
— 次を与える下で：
</p>
				<ul>
					<li class="algo">
<p>
`充足~手続き^i は：
</p>
						<ol>
							<li>
%~stream . `AtomicWriteRequests$slS から %~promise を`除去する$
</li>
							<li>
~RET `undefined^jv
</li>
						</ol>
					</li>
					<li class="algo">
<p>
`却下~手続き^i は、
所与の
( 事由 %r )
に対し：
</p>
						<ol>
							<li>
%~stream . `AtomicWriteRequests$slS から %~promise を`除去する$
</li>
							<li>
~RET `却下される~promise$( %r )
</li>
						</ol>
					</li>
				</ul>
◎
Return the result of reacting to p with the following steps:
• If stream.[[AtomicWriteRequests]] contains p, remove p.
• If p was rejected with reason r, then return a promise rejected with r.
• Return undefined.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="web-transport-writer-procedures">
<h3 title="Procedures">11.2. 手続-</h3>

<div class="algo">
<p>
`WebTransportWriter$I を
`作成する@TW
~algoは、
所与の
( `WebTransportSendStream$I %~stream )
に対し：
◎
To create a WebTransportWriter, with a WebTransportSendStream stream, run these steps:
</p>
<ol>
	<li>
%書込器 ~LET `新たな~obj$( `WebTransportWriter$I )
◎
Let writer be a new WebTransportWriter.
</li>
	<li>
%書込器 上の `new WritableStreamDefaultWriter$m 構築子~手続き( %~stream )
◎
Run the new WritableStreamDefaultWriter(stream) constructor steps passing writer as this, and stream as the constructor argument.
</li>
	<li>
~RET %書込器
◎
Return writer.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="web-transport-error-interface">
<h2 title="WebTransportError Interface">12. `WebTransportError^I ~interface</h2>

<p>
`WebTransportError@I
は
`DOMException$I の下位classであり，
次に挙げるいずれかを表現する：
◎
WebTransportError is a subclass of DOMException that represents
</p>
<ul>
	<li>
［
~server／~network
］から来ている~error
◎
An error coming from the server or the network, or
</li>
	<li>
~clientが起動した中止-演算~用の事由
◎
A reason for a client-initiated abort operation.
</li>
</ul>

<pre class="idl">
[`Exposed$=(Window,Worker), `Serializable$, `SecureContext$]
interface `WebTransportError$I : `DOMException$I {
  `constructor＠#dom-webtransporterror-webtransporterror$(optional `DOMString$ %message = "", optional `WebTransportErrorOptions$I %options = {});

  readonly attribute `WebTransportErrorSource$I `source$mE;
  readonly attribute `unsigned long$? `streamErrorCode$mE;
};

dictionary `WebTransportErrorOptions@I {
  `WebTransportErrorSource$I `source@mbE = "stream";
  [`Clamp$] `unsigned long$? `streamErrorCode@mbE = null;
};

enum `WebTransportErrorSource@I {
  `stream@l,
  `session@l,
};
</pre>

<div class="algo">
<p>
`~WebTransport用の例外を作成する@
~algoは、
所与の
( %~source, %~code （省略時は ~NULL ） )
に対し：
</p>
<ol>
	<li>
%~error ~LET `新たな~obj$( `WebTransportError$I )
</li>
	<li>
%~error 上の `new WebTransportError$m 構築子~手続き( 空~文字列, «[ "`source$mbE" → %~source, "`streamErrorCode$mbE" → %~code ]» )
</li>
	<li>
~RET %~error
</li>
</ol>

<p class="trans-note">【
この手続きは、
他所を集約するための，この訳による追加。
原文は，構築子~手続きを利用していないが、
次節に述べられる各~内部~slotを初期化する必要があるはずなので，追加している
— 原文は`~message$eXをどう初期化するか何も述べていないので、
%message 引数には，`とりあえず^em空~文字列を渡している
（本当は、何らかの`実装定義$な値に初期化されるかもしれない）。
】</p>
</div>

		<section id="web-transport-error-internal-slots">
<h3 title="Internal slots">12.1. 内部~slot</h3>

<p>
各 `WebTransportError$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportError has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`Source@sl</dt>
	<dd>
ある `WebTransportErrorSource$I
— この~errorの~sourceを指示する。
◎
A WebTransportErrorSource indicating the source of this error.
</dd>

	<dt>`StreamErrorCode@sl</dt>
	<dd>
~NULL ／
この~error用の応用~protocol~error~code
◎
The application protocol error code for this error, or null.
</dd>
</dl>

		</section>
		<section id="web-transport-error-constructor1">
<h3 title="Constructor">12.2. 構築子</h3>

<div class="algo">
<p>
`new WebTransportError(message, options)@m
構築子~手続きは：
◎
The new WebTransportError(message, options) constructor steps are:
</p>
<ol>
	<li>
<p>
コレの
⇒＃
`名前$eX ~SET `WebTransportError^l,
`~message$eX ~SET %message,
`Source$sl ~SET %options[ "`source$mbE" ],
`StreamErrorCode$sl ~SET %options[ "`streamErrorCode$mbE" ]
◎
Set this’s name to "WebTransportError".
◎
Set this’s message to message.
◎
Set this’s internal slots as follows:
• [[Source]]
•• options.source
• [[StreamErrorCode]]
•• options.streamErrorCode
</p>

<p class="note">注記：
この名前に対応付けられる旧来の~codeは無いので、
コレの `code＠~WEBIDL#dom-domexception-code$m は 0 になる。
◎
Note: This name does not have a mapping to a legacy code, so this’s code is 0.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="web-transport-error-attributes">
<h3 title="Attributes">12.3. 属性</h3>

<dl>
	<dt>
`source@mE
◎
source, of type WebTransportErrorSource, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Source$sl
◎
The getter steps are to return this’s [[Source]].
</dd>

	<dt>
`streamErrorCode@mE
◎
streamErrorCode, of type unsigned long, readonly, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `StreamErrorCode$sl
◎
The getter steps are to return this’s [[StreamErrorCode]].
</dd>
</dl>

		</section>
		<section id="web-transport-error-serialization">
<h3 title="Serialization">12.4. 直列化</h3>

<p>
`WebTransportError$I ~objは`直列化-可能$である
— その：
◎
WebTransportError objects are serializable objects.＼
</p>
<ul>
	<li class="algo">
<p>
`直列化~手続き$は、
所与の
( %値, %直列形 )
に対し：
◎
Their serialization steps, given value and serialized, are:
</p>
		<ol>
			<li>
`DOMException$I 用の`直列化~手続き$( %値, %直列形 )
◎
Run the DOMException serialization steps given value and serialized.
</li>
			<li>
%直列形 . `Source^sl ~SET %値 . `Source$sl
◎
Set serialized.[[Source]] to value.[[Source]].
</li>
			<li>
%直列形 . `StreamErrorCode^sl ~SET %値 . `StreamErrorCode$sl
◎
Set serialized.[[StreamErrorCode]] to value.[[StreamErrorCode]].
</li>
		</ol>
	</li>
	<li class="algo">
<p>
`逆直列化~手続き$は、
所与の
( %直列形, %値 )
に対し：
◎
Their deserialization steps, given serialized and value, are:
</p>
		<ol>
			<li>
`DOMException$I 用の`逆直列化~手続き$( %直列形, %値 )
◎
Run the DOMException deserialization steps given serialized and value.
</li>
			<li>
%値 . `Source$sl ~SET %直列形 . `Source^sl
◎
Set value.[[Source]] to serialized.[[Source]].
</li>
			<li>
%値 . `StreamErrorCode$sl ~SET %直列形 . `StreamErrorCode^sl
◎
Set value.[[StreamErrorCode]] serialized.[[StreamErrorCode]].
</li>
		</ol>
	</li>
</ul>

		</section>
	</section>
	<section id="protocol-mapping">
<h2 title="Protocol Mappings">13. ~protocol対応付け</h2>

◎非規範的

<p>
この節では、
この仕様に定義した各~methodを成す下層~protocolの挙動を，
`WEB-TRANSPORT-OVERVIEW$r を用立てる下で述べる。
~buffer化に因り、
原因から即時に効果が生じるとは限らない。
【以下の各~表tの 1 列目に原因, 2 列目に効果が挙げられる。】
◎
This section describes the underlying protocol behavior of methods defined in this specification, utilizing [WEB-TRANSPORT-OVERVIEW]. Cause and effect may not be immediate due to buffering.
</p>

<div>
<table class="_wt-effect grid-table">
<thead>
<tr><th>~WebTransport~protocolにおける動作
<th>~APIによる効果
<tbody>

<tr><td>
`DRAIN_WEBTRANSPORT_SESSION$ft を受信した
<td>
<code>await wt.`draining$mT</code>
【に反映される】
</table>
◎
WebTransport Protocol Action｜API Effect
received DRAIN_WEBTRANSPORT_SESSION｜await wt.draining
</div>

<p>
当の`下層~接続$は~HTTP3を利用している場合、
以下に挙げる `WEB-TRANSPORT-HTTP3$r による~protocolの挙動が適用される。
◎
If the underlying connection is using HTTP/3, the following protocol behaviors from [WEB-TRANSPORT-HTTP3] apply.
</p>

<p>
［
`WebTransportError$I ~error %error 内の応用 `streamErrorCode$mE %~code
］と［
【~HTTP3における】 %~HTTP~error~code
］は、
`WEB-TRANSPORT-HTTP3$r `§ 4.3＠~WT-HTTP3#resetting-data-streams$【！4.3】
にて指定されるとおりに，相互に変換される。
◎
The application streamErrorCode in the WebTransportError error is converted to an httpErrorCode, and vice versa, as specified in [WEB-TRANSPORT-HTTP3] Section 4.3.
</p>

<div>
<table class="_wt-effect grid-table">
<thead>

<tr><th>~API~method
<th>~QUIC~protocolにおける動作
<tbody>

<tr><td>
<code>`writable$mB.`abort(error)$ws</code>
<td>
`設定し直す$WT( %~code )
— これは、
%~HTTP~error~code を伴う `RESET_STREAM$ft を送信する

<tr><td>
<code>`writable$mB.`close$ws()</code>
<td>
~FIN~bitを伴う `STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`write(chunk)$dw</code>
<td>
`STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`close()$dw</code>
<td>
~FIN~bitを伴う `STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`abort(error)$dw</code>
<td>
`設定し直す$WT( %~code )
— これは、
%~HTTP~error~code を伴う `RESET_STREAM$ft を送信する

<tr><td>
<code>`readable$mB.`cancel(error)$rs</code>
<td>
`送信を停止させる$WT( %~code )
— これは，
%~HTTP~error~code を伴う `STOP_SENDING$ft を送信する

<tr><td>
<code>`readable$mB.getReader().`cancel(error)$gr</code>
<td>
`送信を停止させる$WT( %~code )
— これは，
%~HTTP~error~code を伴う `STOP_SENDING$ft を送信する

<tr><td>
<code>wt.`close(closeInfo)$mT</code>
<td>
`~WebTransport~sessionを終了する$( %~session, %closeInfo[ "`closeCode$mb" ], %closeInfo[ "`reason$mb" ] )

</table>
◎
API Method｜QUIC Protocol Action
writable.abort(error)｜sends RESET_STREAM with httpErrorCode
writable.close()｜sends STREAM with FIN bit set
writable.getWriter().(chunk)()｜sends STREAM
writable.getWriter().close()｜sends STREAM with FIN bit set
writable.getWriter().abort(error)｜sends RESET_STREAM with httpErrorCode
readable.cancel(error)｜sends STOP_SENDING with httpErrorCode
readable.getReader().cancel(error)｜sends STOP_SENDING with httpErrorCode
wt.close(closeInfo)｜terminates session with closeInfo
</div>

<div>
<table class="_wt-effect grid-table">
<thead>

<tr><th>~QUIC~protocolにおける動作
<th>~APIによる効果
<tbody>

<tr><td>
%~HTTP~error~code を伴う `STOP_SENDING$ft を受信した
<td>
`writable$mB を`~errorにする$WS( %~code )

<tr><td>
`STREAM^ft を`受信-$WTした
<td>
<code>(await `readable$mB.getReader().`read()$dr).value</code>
【に反映される】


<tr><td>
~FIN~bitを伴う `STREAM^ft を`受信-$WTした
<td>
<code>(await `readable$mB.getReader().`read()$dr).done</code>
【に反映される】


<tr><td>
%~HTTP~error~code を伴う `RESET_STREAM$ft を受信した
<td>
`readable$mB を`~errorにする$RS( %~code )


<tr><td>
~sessionは~cleanに`終了され$た( %~code, %事由 )
【！with closeInfo】

<td>
<code>(await wt.`closed$mT).closeInfo</code>
【に反映されること】に加え，
~openな各~streamを`~errorにする$RS( )


<tr><td>
~network~error
<td>
<code>(await wt.`closed$mT)</code>
を却下することに加え，
~openな各~streamを`~errorにする$RS( )
</table>
◎
QUIC Protocol Action｜API Effect
received STOP_SENDING with httpErrorCode｜errors writable with streamErrorCode
received STREAM｜(await readable.getReader().read()).value
received STREAM with FIN bit set｜(await readable.getReader().read()).done
received RESET_STREAM with httpErrorCode｜errors readable with streamErrorCode
Session cleanly terminated with closeInfo｜(await wt.closed).closeInfo, and errors open streams
Network error｜(await wt.closed) rejects, and errors open streams
</div>

<p class="note">注記：
`QUIC$r § 3.2 にて論じられたとおり、
`RESET_STREAM$ft ~frameの受領は，応用に常に指示されるとは限らない。
`RESET_STREAM$ft の受領は、
即時に通達され得る
— それに伴い、
~stream~dataの送達は中断され，消費されてない~dataは破棄される。
しかしながら，即時に通達するよう要求されてはいない。
また、
~stream~dataは完全に受信されたが，当の応用により まだ読取られてない場合、
`RESET_STREAM$ft 通達は，抑止され得る。
◎
Note: As discussed in [QUIC] Section 3.2, receipt of a RESET_STREAM frame is not always indicated to the application. Receipt of the RESET_STREAM can be signaled immediately, interrupting delivery of stream data with any data not consumed being discarded. However, immediate signaling is not required. Also, if stream data is completely received but has not yet been read by the application, the RESET_STREAM signal can be suppressed.
</p>

<div>
<table class="_wt-effect grid-table">
<thead>

<tr><th>~HTTP3~protocolにおける動作
<th>~APIによる効果
<tbody>

<tr><td>
`GOAWAY$ft を受信した
<td>
<code>await wt.`draining$mT</code>
【に反映される】
</table>
◎
HTTP/3 Protocol Action｜API Effect
received GOAWAY｜await wt.draining
</div>

<p>
当の`下層~接続$は~HTTP2を利用している場合、
以下に挙げる `WEB-TRANSPORT-HTTP2$r による~protocolの挙動が適用される。
~HTTP3と違って，
［
`WebTransportError$I ~error %error 内の応用 `streamErrorCode$mE %~code
］と~HTTP~error~codeを相互に変換する必要は無いことに注意。
◎
If the underlying connection is using HTTP/2, the following protocol behaviors from [WEB-TRANSPORT-HTTP2] apply. Note that, unlike for HTTP/3, the stream error code does not need to be converted to an HTTP error code, and vice versa.
</p>

<div>
<table class="_wt-effect grid-table">
<thead>

<tr><th>~API~method
<th>~HTTP2~protocolにおける動作
<tbody>

<tr><td>
<code>`writable$mB.`abort(error)$ws</code>
<td>
`設定し直す$WT( %~code )

<tr><td>
<code>`writable$mB.`close$ws()</code>
<td>
~FIN~bitを伴う `WT_STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`write()$dw</code>
<td>
`WT_STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`close()$dw</code>
<td>
~FIN~bitを伴う `WT_STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`abort(error)$dw</code>
<td>
`設定し直す$WT( %~code )

<tr><td>
<code>`readable$mB.`cancel(error)$rs</code>
<td>
`送信を停止させる$WT( %~code )

<tr><td>
<code>`readable$mB.getReader().`cancel(error)$gr</code>
<td>
`送信を停止させる$WT( %~code )

<tr><td>
<code>wt.`close(closeInfo)$mT</code>
<td>
`~WebTransport~sessionを終了する$( %~session, %closeInfo[ "`closeCode$mb" ], %closeInfo[ "`reason$mb" ] )

</table>
◎
API Method｜HTTP/2 Protocol Action
writable.abort(error)｜sends WT_RESET_STREAM with error
writable.close()｜sends WT_STREAM with FIN bit set
writable.getWriter().write()｜sends WT_STREAM
writable.getWriter().close()｜sends WT_STREAM with FIN bit set
writable.getWriter().abort(error)｜sends WT_RESET_STREAM with error
readable.cancel(error)｜sends WT_STOP_SENDING with error
readable.getReader().cancel(error)｜sends WT_STOP_SENDING with error
wt.close(closeInfo)｜terminates session with closeInfo
</div>

<div>
<table class="_wt-effect grid-table">
<thead>
<tr><th>~HTTP2~protocolにおける動作
<th>~APIによる効果
<tbody>

<tr><td>
~errorを伴う `STOP_SENDING$ft を受信した
<td>
`writable$mB を`~errorにする$WS( %~code )

<tr><td>
`WT_STREAM^ft を`受信-$WTした
<td>
<code>(await `readable$mB.getReader().`read()$dr).value</code>
【に反映される】

<tr><td>
~FIN~bitを伴う `WT_STREAM^ft を`受信-$WTした
<td>
<code>(await `readable$mB.getReader().`read()$dr).done</code>
【に反映される】

<tr><td>
~errorを伴う `RESET_STREAM$ft を受信した
<td>
`readable$mB を`~errorにする$RS( %~code )

<tr><td>
~sessionは~cleanに`終了され$た( %~code, %事由 )
【！with closeInfo】
<td>
<code>(await wt.`closed$mT).closeInfo</code>
【に反映されること】に加え，
~openな各~streamを`~errorにする$RS( )

<tr><td>
~network~error
<td>
<code>(await wt.`closed$mT)</code>
を却下することに加え，
~openな各~streamを`~errorにする$RS( )

<tr><td>
`GOAWAY$ft を受信した
<td>
<code>await wt.`draining$mT</code>
【に反映される】
</table>
◎
HTTP/2 Protocol Action｜API Effect
received WT_STOP_SENDING with error｜errors writable with streamErrorCode
received WT_STREAM｜(await readable.getReader().read()).value
received WT_STREAM with FIN bit set｜(await readable.getReader().read()).done
received WT_RESET_STREAM with error｜errors readable with streamErrorCode
Session cleanly terminated with closeInfo｜(await wt.closed).closeInfo, and errors open streams
Network error｜(await wt.closed) rejects, and errors open streams
received GOAWAY｜await wt.draining
</div>

	</section>
	<section id="privacy-security">
<h2 title="Privacy and Security Considerations">14. ~privacy／~securityの考慮点</h2>

◎非規範的

<p>
この節は、
新たな挙動を指定するものではなく，
この仕様を成す他の各部にて すで呈示した情報を要約する。
◎
it specifies no new behaviour, but instead summarizes information already present in other parts of the specification.
</p>

		<section id="confidentiality">
<h3 title="Confidentiality of Communications">14.1. 通信の機密性</h3>

<p>
通信が場を占めている事実は、
~networkを観測できる敵対者たちからは隠せないので，
公な情報とみなされる。
◎
The fact that communication is taking place cannot be hidden from adversaries that can observe the network, so this has to be regarded as public information.
</p>

<p>
この文書~内で述べた~transport~protocolを成すすべては，［
~TLS `RFC8446$r またはそれと意味論的に等価な~protocol
］を利用するので、
~TLSを成すすべての~security~propを供する
— 流通の［
機密性と完全性
］も含めて。
~HTTP越しの~WebTransportは，`外方＠~HTTPinfra#outbound$への~HTTP要請と同じ［
証明書~検証y用の仕組み
］を利用するので、
~remote~serverへの認証は，同じ公開鍵~基盤に依拠している。
~WebTransportにおいては、
証明書~検証yにおける~errorは致命的であり，［
証明書~検証を迂回することを許容する抜道
］として可用なものは無い。
◎
All of the transport protocols described in this document use either TLS [RFC8446] or a semantically equivalent protocol, thus providing all of the security properties of TLS, including confidentiality and integrity of the traffic. WebTransport over HTTP uses the same certificate verification mechanism as outbound HTTP requests, thus relying on the same public key infrastructure for authentication of the remote server. In WebTransport, certificate verification errors are fatal; no interstitial allowing bypassing certificate validation is available.
</p>

		</section>
		<section id="state-persistence">
<h3 title="State Persistence">14.2. 状態の持続性</h3>

<p>
~WebTransport自体は、
新たな［
【利用者に】一意な識別子／
状態を持続的に格納する仕方
］を作成するものでも，
既存の持続的な状態を~serverに自動的に公開するものでもない。
一例として、
`WEB-TRANSPORT-HTTP3$r,
`WEB-TRANSPORT-HTTP2$r
は，どちらも［
~cookieを送信しない／
~HTTP認証を~supportしない／
~cache法を無効~化する仕組みは無い
］。
それらは，~TLSを利用するので、
~TLSにおける持続的な状態
— ~TLS~session~ticketなど —
を継承する。
そのような状態は、
受動的な~network観測者からは可視にならないが，
~serverにより［
同じ~clientからの異なる接続どうしを相関する
］ためにも利用され得る。
◎
WebTransport does not by itself create any new unique identifiers or new ways to persistently store state, nor does it automatically expose any of the existing persistent state to the server. For instance, neither [WEB-TRANSPORT-HTTP3] nor [WEB-TRANSPORT-HTTP2] send cookies or support HTTP authentication or caching invalidation mechanisms. Since they do use TLS, they inherit TLS persistent state such as TLS session tickets, which while not visible to passive network observers, could be used by the server to correlate different connections from the same client.
</p>

		</section>
		<section id="protocol-security">
<h3 title="Protocol Security">14.3. ~protocol~security</h3>

<p>
~WebTransportは、
`WEB-TRANSPORT-OVERVIEW$r にて述べられる要件の集合を課す
— それは、
次に挙げるものを含む：
◎
WebTransport imposes a set of requirements as described in [WEB-TRANSPORT-OVERVIEW], including:
</p>
<ol>
	<li>
~remote~serverが［
~WebTransport~protocolが利用-中にあることを自覚する
］ことを確保することに加え、
~remote~serverには［
~WebTransport~protocolを利用する用意がある
］ことを確認すること。
`WEB-TRANSPORT-HTTP3$r は、
~WebTransport~protocolを識別するために［
~ALPN `RFC7301$r,
`~HTTP3設定＠~HTTPv3#setting$,
`:protocol^h `疑似-~header＠~HTTPv3#pseudo-header$
］が成す組合n利用する。
`WEB-TRANSPORT-HTTP2$r は、
~WebTransport~protocolを識別するために［
~ALPN `RFC7301$r,
~HTTP2設定,
`:protocol^h 疑似-~header
］が成す組合n利用する。
【疑似-~header `:protocol^h は、 ~RFC 8441 に定義される。】
◎
Ensuring that the remote server is aware that the WebTransport protocol is in use and confirming that the remote server is willing to use the WebTransport protocol. [WEB-TRANSPORT-HTTP3] uses a combination of ALPN [RFC7301], an HTTP/3 setting, and a :protocol pseudo-header to identify the WebTransport protocol. [WEB-TRANSPORT-HTTP2] uses a combination of ALPN, an HTTP/2 setting, and a :protocol pseudo-header to identify the WebTransport protocol.
</li>
	<li>
［
~transport~sessionを出生した資源
］の生成元に基づいて，接続を~filterすることを~serverに許容する。
この情報【生成元】は、
~session確立~要請の `Origin$h ~header~fieldが運ぶ。
◎
Allowing the server to filter connections based on the origin of the resource originating the transport session. The Origin header field on the session establishment request carries this information.
</li>
</ol>

<p>
関係する~protocol~securityの考慮点は、［
`WEB-TRANSPORT-HTTP3$r `§ ~securityの考慮点＠~WT-HTTP3#security-considerations$,
`WEB-TRANSPORT-HTTP2$r `§ ~securityの考慮点＠~WT-HTTP2#security-considerations$
］にて述べられる。
◎
Protocol security related considerations are described in the Security Considerations sections of [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2].
</p>

<p>
~networking~APIは、
局所~networkで可用な~hostを走査するために共通的に利用され得るので，［
指紋収集や他の形を成す攻撃
］に利用される。
~WebTransportは、
この問題に対し`~WebSocketによる~approach＠~WEBSOCKET#feedback-from-the-protocol$に従う
⇒
【~WebTransportに】特有な接続~errorは、
端点が~WebTransport端点であることが検証yされるまでは，返されない。
したがって、
~Web応用は，所与の端点が［
存在しないのか,
~Webからの接続を受容する用意がないのか
］を判別し得ない。
◎
Networking APIs can be commonly used to scan the local network for available hosts, and thus be used for fingerprinting and other forms of attacks. WebTransport follows the WebSocket approach to this problem: the specific connection error is not returned until an endpoint is verified to be a WebTransport endpoint; thus, the Web application cannot distinguish between a non-existing endpoint and the endpoint that is not willing to accept connections from the Web.
</p>

		</section>
		<section id="certificate-hashes">
<h3 title="Authentication using Certificate Hashes">14.4. 証明書~hash群を利用している認証</h3>

<p>
~UAは、
通常は，［
自身 ↔ ~remote端点
］間の~TLS接続を［
~URL内の~server名に対し供された~TLS~server証明書
］の妥当性を検証yすることにより認証する `RFC9525$r 。
これは、
~server証明書を［
~UAにより保守される信用-~anchorのうちいずれか
］へ連鎖することにより成遂げられる
— 各~信用-~anchorは、
証明書~内の~server名を認証する責務がある。
この~systemは、
以下では，~Web~PKIと称される。
◎
Normally, a user agent authenticates a TLS connection between itself and a remote endpoint by verifying the validity of the TLS server certificate provided against the server name in the URL [RFC9525]. This is accomplished by chaining server certificates to one of the trust anchors maintained by the user agent; the trust anchors in question are responsible for authenticating the server names in the certificates. We will refer to this system as Web PKI.
</p>

<p>
この~APIは，
~remote~network端点へ接続する能力を~web応用に供するが、
端点は［
その~server名ではなく，特定の~server証明書
］により認証される。
この仕組みは、
長期的な証明書を取得するのは難題になり得るような端点
— その資質において短命な~host
（例：その場限りの~virtual~machine）や，
公に~route可能でない~hostを含む —
への接続を可能化する。
この仕組みは、
個々の接続~用に［
~Web~PKIに基づく認証
］を代用するので，
両者の~security~propを比較する必要がある。
◎
This API provides web applications with a capability to connect to a remote network endpoint authenticated by a specific server certificate, rather than its server name. This mechanism enables connections to endpoints for which getting long-term certificates can be challenging, including hosts that are ephemeral in nature (e.g. short-lived virtual machines), or that are not publicly routable. Since this mechanism substitutes Web PKI-based authentication for an individual connection, we need to compare the security properties of both.
</p>

<p>
ある~remote~serverが，
~TLS~handshakeを成功裡に遂行-可能になるのは、［
それが，指定された証明書の公開鍵に対応している秘密鍵を所蔵している【！posess】
］場合に限られる。
この~APIは、
それらの~hashを利用して証明書を識別する。
それが~secureになるのは、［
利用された暗号用~hash関数が，
第二原像攻撃に対する耐性（ `second-preimage resistance^en ）を有する場合
］に限られる。
この文書にて定義される関数は，~SHA-256に限られるが、
この~APIは，［
新たな~hash関数を導入するための仕方
］を［
複数個の［
( ~algo, ~hash )
が成す~pair
］を指定すること
］を許容することを通して供する。
◎
A remote server will be able to successfully perform a TLS handshake only if it posesses the private key corresponding to the public key of the certificate specified. The API identifies the certificates using their hashes. That is only secure as long as the cryptographic hash function used has second-preimage resistance. The only function defined in this document is SHA-256; the API provides a way to introduce new hash functions through allowing multiple algorithm-hash pairs to be specified.
</p>

<p>
重要なこととして、
~Web~PKIは，~security用に追加的な仕組みを供することに注意
— 単純に［
ある~server名に対し信用が成す連鎖を確立する
］ことに加えて。
それらのうち一つに，証明書~廃止の取扱いがある。
利用される証明書が短命である事例では、
そのような仕組みは必要yでない。
他の事例では、
~Web応用は，証明書~hashを支給するための仕組みを考慮する必要がある
— 一例として、
当の~hashが~cacheされた~HTTP資源として供された場合，
当の~cacheは［
対応している証明書が，弱体化に因り交替された場合
］には無効~化される必要がある。
~Web~PKIにより供される別の~security特能は、
鍵~生成に伴われるある種の課題に抗する防護策である
— 弱いことが既知な鍵を伴う証明書を却下するなど。
この仕様は，特有な指導を何も供さないが、
各~browserは，実装定義な挙動の一部として それらを却下してもヨイ。
◎
It is important to note that Web PKI provides additional security mechanisms in addition to simply establishing a chain of trust for a server name. One of them is handling certificate revocation. In cases where the certificate used is ephemeral, such a mechanism is not necessary. In other cases, the Web application has to consider the mechanism by which the certificate hashes are provisioned; for instance, if the hash is provided as a cached HTTP resource, the cache needs to be invalidated if the corresponding certificate has been rotated due to compromise. Another security feature provided by the Web PKI are safeguards against certain issues with key generation, such as rejecting certificates with known weak keys; while this specification does not provide any specific guidance, browsers MAY reject those as a part of implementation-defined behavior.
</p>

<p>
~Web~PKIは、
各~証明書に対し，失効~期間~要件を施行する。
この要件は、
鍵が弱体化され得る視野を制限することに加え、［
鍵~交替を~supportして，それを能動的に遂行する
］よう~systemを設計することを~server運用者に強制する。
この理由から、
~WebTransportも，類似な失効~要件を課す
— 証明書は，短命なことが予期されるので、
失効~期間は 2 週間に制限される。
2 週間の期限は、
次に挙げるものの間で~balanceをとった結果である：
◎
Web PKI enforces an expiry period requirement on the certificates. This requirement limits the scope of potential key compromise; it also forces server operators to design systems that support and actively perform key rotation. For this reason, WebTransport imposes a similar expiry requirement; as the certificates are expected to be ephemeral or short-lived, the expiry period is limited to two weeks. The two weeks limit is a balance between＼
</p>
<ul>
	<li>
鍵~弱体化による帰結を最小~化するため，
失効~期限をアリな限り短く設定する。
◎
setting the expiry limit as low as possible to minimize consequences of a key compromise,＼
</li>
	<li>
各~機器にまたがる時計のずれを収容するに足るまで，長く保守する。
◎
and maintaining it sufficiently high to accomodate for clock skew across devices,＼
</li>
	<li>
［
~client側 ↔ ~server側
］間で証明書を同期するための~costを なるべく下げる。
◎
and to lower the costs of synchronizing certificates between the client and the server side.
</li>
</ul>

<p>
~WebTransport~APIは、
応用が複数の証明書~hashをまとめて指定できるようにする。
それは、
次を~clientに許容する
⇒
新たな証明書が行き渡るまでの期間において，
【それまでの証明書も可用になるよう】
複数の証明書を受容する。
◎
The WebTransport API lets the application specify multiple certificate hashes at once, allowing the client to accept multiple certificates for a period in which a new certificate is being rolled out.
</p>

<p>
~WebRTCにおける`類似な仕組み＠~CSP3#webrtc$と違って、
~WebTransportにおける~server証明書~hash~APIは，
~clientを認証するための手段を何ら供さない
— 事実、
~clientが［
~server証明書が何であるか／どう `contact^en するか
］を知るだけでは足らない。
応用は、
必要yなら，
~clientの識別情報を帯域内に確立する必要がある。
◎
Unlike a similar mechanism in WebRTC, the server certificate hash API in WebTransport does not provide any means of authenticating the client; the fact that the client knows what the server certificate is or how to contact it is not sufficient. The application has to establish the identity of the client in-band if necessary.
</p>

		</section>
		<section id="fingerprinting">
<h3 title="Fingerprinting and Tracking">14.5. 指紋収集と追跡</h3>

<p>
この~APIは、［
~network活動を生成する能,
この活動の効果を細かく観測する能
］を~siteに供する。
この仕方で得される情報は，
【利用者を】`識別している＠~INFRA#tracking-vector$かもしれない。
◎
This API provides sites with the ability to generate network activity and closely observe the effect of this activity. The information obtained in this way might be identifying.
</p>

<p>
重要なこととして、
他の~web~platform~API
— `FETCH$r, `WEBRTC$r など —
も，ごく類似な~networking能力を供することを認識すること。
したがって、
~WebTransport~APIを追加することに因る~privacyへの悪影響は，
実質無いに等しい。
この節における考慮点は、
他の~networking能力にも等しく適用される。
◎
It is important to recognize that very similar networking capabilities are provided by other web platform APIs (such as fetch and [webrtc]). The net adverse effect on privacy due to adding WebTransport is therefore minimal. The considerations in this section applies equally to other networking capabilities.
</p>

<p>
~network特性を測定するためには、［
~networkが利用されていて，
その利用度が成す効果が測定される
］ことが要求される
— この~APIはどちらも可能化する。
~WebTransportは、［
~siteが選んだ~serverへ向けて~network活動を生成する能,
その効果を観測する能
］を~siteに供する。
［
~network経路の安定的な~prop,
~network利用度が成す動的な効果
］どちらも観測nがアリになる。
◎
Measuring network characteristics requires that the network be used and that the effect of that usage be measured, both of which are enabled by this API. WebTransport provides sites with an ability to generate network activity toward a server of their choice and observe the effects. Observations of both the stable properties of a network path and dynamic effect of network usage are possible.
</p>

<p>
~networkについての情報は、
次に挙げるものを通して，~serverに可用になる：
◎
Information about the network is available to the server either＼
</p>
<ul>
	<li>
~server自前の~networking~stackを通して直に
◎
directly through its own networking stack,＼
</li>
	<li>
~clientにより~dataが［
消費される／伝送される
］~rateを通して間接的に
◎
indirectly through the rate at which data is consumed or transmitted by the client,＼
</li>
	<li>
この~APIにより供される統計の一部として
（ <a href="#web-transport-connection-stats">§ `WebTransportConnectionStats^I 辞書</a> を見よ）
◎
or as part of the statistics provided by the API (see § 6.13 WebTransportConnectionStats Dictionary).＼
</li>
</ul>
<p>
その帰結として、［
~UAにおける情報に対する制約
］は，［
これらの~privacy~riskを管理するために必要かもしれない仕組み
］として唯一のものではない。
◎
Consequently, restrictions on information in user agents is not the only mechanism that might be needed to manage these privacy risks.
</p>

			<section id="fp-static">
<h4 title="Static Observations">14.5.1. 静的な観測n</h4>

<p>
~siteは、［
~UA ↔ 自身が選んだ~server
］間における［
可用な~network容量／往復~時間（~RTT）
］を観測できる。
この情報は、［
他の追跡~行路と組合されたとき
］に【利用者を】識別し得る。
~RTTはまた、
~UAの物理的な所在についての何かを露呈し得る
— とりわけ、
複数の立地から複数の測定を為せる場合に。
◎
A site can observe available network capacity or round trip time (RTT) between a user agent and a chosen server. This information can be identifying when combined with other tracking vectors. RTT can also reveal something about the physical location of a user agent, especially if multiple measurements can be made from multiple vantage points.
</p>

<p>
~networkingは共有されるが、
~networkは散発的に利用されることが多い
— そのことは、
~siteは［
他と競わない／負荷が軽い
］~network経路の［
容量, 往復~時間
］を観測-可能になることが多いことを意味する。
これらの~propは、
多くの人々において安定的である
— ~network上での彼らの所在は変化しないことに加え、
~network~bottleneck（それは可用な容量を決定する）の位置は，~UAに近いこともあるので。
◎
Though networking is shared, network use is often sporadic, which means that sites are often able to observe the capacity and round trip times of an uncontested or lightly loaded network path. These properties are stable for many people as their network location does not change and the position of network bottlenecks--which determine available capacity--can be close to a user agent.
</p>

			</section>
			<section id="fp-shared">
<h4 title="Shared Networking">14.5.2. 共用~networking</h4>

<p>
`contested^en ~link【？】は、
`非同一-~site認識＠https://w3ctag.github.io/privacy-principles/#dfn-cross-site-recognition$を可能化する機会を~siteに呈示する
— それは、
野放図な追跡 `UNSANCTIONED-TRACKING$r を遂行するために利用されるかもしれない。
~network容量は，有限な共用~資源なので、
異なる~siteに同時並行に~accessする~UAは，
各~siteに呈示された識別情報どうしの繋がりを露呈するかもしれない。
◎
Contested links present sites with opportunities to enable cross-site recognition, which might be used to perform unsanctioned tracking [UNSANCTIONED-TRACKING]. Network capacity is a finite shared resource, so a user agent that concurrently accesses different sites might reveal a connection between the identity presented to each site.
</p>

<p>
ある~siteにおける~networking能力の利用は、
他の~siteに可用な容量を抑制する
— それは、
~networking~APIを利用して観測され得る。
~network［
利用度, 計量
］は動的に変化し得るので、
どの変化も~real-timeで観測され得る。
これは、
その［
同じ利用者から出生している異なる~site上での活動
］について確証を高めることを~siteに許容するかもしれない。
◎
The use of networking capabilities on one site reduces the capacity available to other sites, which can be observed using networking APIs. Network usage and metrics can change dynamically, so any change can be observed in real time. This might allow sites to increase confidence that activity on different sites originates from the same user.
</p>

<p>
~UAは、［
作動中でない／
~focusを得ていない
（ `HTML^cite `§ ~focus＠~HTMLinteraction#focus$）
］~site用には，~feedbackする仕組み
— 統計（ <a href="#web-transport-connection-stats">§ `WebTransportConnectionStats^I 辞書</a> ）など —
への~accessを［
制限する／退行する
］こともできる。
注記したとおり、
これは，~serverが［
~network内の変化について観測nを為すこと
］を防止しない。
◎
A user agent could limit or degrade access to feedback mechanisms such as statistics (§ 6.13 WebTransportConnectionStats Dictionary) for sites that are inactive or do not have focus (HTML § 6.6 Focus). As noted, this does not prevent a server from making observations about changes in the network.
</p>

			</section>
			<section id="fp-pooled">
<h4 title="Pooled Sessions">14.5.3. ~poolされた~session</h4>

<p>
~networkingが共有される局面と類似に、
同じ接続に複数の~sessionが~poolされたとき，
ある~sessionからの情報は別の~sessionの活動により影響される。
ある~sessionは、
別の~sessionの活動についての情報
— 別の応用が~dataを送信している~rateなど —
を推定することもできる。
◎
Similar to shared networking scenarios, when sessions are pooled on a single connection, information from one session is affected by the activity of another session. One session could infer information about the activity of another session, such as the rate at which another application is sending data.
</p>

<p>
共有された接続の利用は、
すでに，~sessionどうしを相関することを~serverに許容している。
共有された~sessionの利用が，
求まれない非同一-~site認識を可能化するかもしれない所では、
`~network区分~key$の利用が，
~pool法を不能化する。
◎
The use of a shared connection already allows the server to correlate sessions. Use of a network partition key disables pooling where use of a shared session might enable unwanted cross-site recognition.
</p>

			</section>
		</section>
	</section>
	<section id="examples">
<h2 title="Examples">15. 例</h2>

		<section id="example-datagrams">
<h3 title="Sending a buffer of datagrams">15.1. ~datagramたちが成す~bufferの送信-法</h3>

◎非規範的

<p>
~datagramたちが成す~bufferの送信は、［
`datagrams$mT の `createWritable()$mD ~methodと その結果の~streamの書込器
］を利用して達成できる。
次の例では、
~datagramたちは，
~transportがそれを送信するに準備済みな場合に限り送信される。
◎
Sending a buffer of datagrams can be achieved by using the datagrams' createWritable method and the resulting stream’s writer. In the following example datagrams are only sent if the transport is ready to send.
</p>

<pre class="lang-js">
async function sendDatagrams(%url, %datagrams) {
  const %wt = new WebTransport(%url);
  const %writable = %wt.datagrams.createWritable();
  const %writer = %writable.getWriter();
  for (const %bytes of %datagrams) {
    await %writer.ready;
    %writer.write(%bytes).catch(() =&gt; {});
  }
  await %writer.close();
}
</pre>

		</section>
		<section id="example-fixed-rate">
<h3 title="Sending datagrams at a fixed rate">15.2. 固定的な~rateによる~datagram群の送信-法</h3>

◎非規範的

<p>
~datagram群を［
~transportがそれを送信するに準備済みか否か
］に関わらず固定的な~rateで送信することは、
単純に［
`datagrams$mT の `createWritable()$mD ~methodと その結果の~streamの書込器
］を利用して達成できる
— `ready$mT 属性を待受けることなく。
◎
Sending datagrams at a fixed rate regardless if the transport is ready to send can be achieved by simply using datagrams' createWritable method and the resulting stream’s writer without awaiting the ready attribute.
</p>

<pre class="lang-js">
/* <span class="comment">
100 ~milli秒ごとに~datagramを送信する。
◎
Sends datagrams every 100 ms.
</span> */
async function sendFixedRate(%url, %createDatagram, %ms = 100) {
  const %wt = new WebTransport(%url);
  const %writable = %wt.datagrams.createWritable();
  const %writer = %writable.getWriter();
  const %bytes = createDatagram();
  setInterval(() =&gt; writer.write(%bytes).catch(() =&gt; {}), %ms);
}
</pre>

		</section>
		<section id="example-receiving-datagrams">
<h3 title="Receiving datagrams">15.3. ~datagramの受信-法</h3>

◎非規範的

<p>
~datagramは、
`datagrams$mT の `readable$mD 属性から読取ることにより受信できる。
~NULL値は、
~packetが十分に素早く処理されていないことを指示し得る。
◎
Datagrams can be received by reading from the transport.datagrams.readable attribute. Null values may indicate that packets are not being processed quickly enough.
</p>

<pre class="lang-js">
async function receiveDatagrams(%url) {
  const %wt = new WebTransport(%url);
  for await (const %datagram of %wt.datagrams.readable) {
    /* <span class="comment">
%datagram を処理する
◎
Process the datagram
</span> */
  }
}
</pre>

		</section>
		<section id="example-datagrams-byob">
<h3 title="Receiving datagrams with a BYOB reader">15.4. ~BYOB読取器による~datagramの受信-法</h3>

◎非規範的

<p>
`datagrams$mT は、
`可読~byte~stream$なので，
それ用に`~BYOB読取器$を獲得できる
— それは、
複製を避けるために，より精確な［
~bufferの割振りに対する制御
］を許容する。
この例は、
~datagramを 64kB の~memory~bufferの中へ読取る。
◎
As datagrams are readable byte streams, you can acquire a BYOB reader for them, which allows more precise control over buffer allocation in order to avoid copies. This example reads the datagram into a 64kB memory buffer.
</p>

<pre class="lang-js">
const wt = new WebTransport(%url);

for await (const %datagram of %wt.datagrams.readable) {
  const %reader = %datagram.getReader({ mode: "byob" });

  let %array_buffer = new ArrayBuffer(65536);
  const %buffer = await readInto(%array_buffer);
}

async function readInto(%buffer) {
  let %offset = 0;

  while (%offset &lt; %buffer.byteLength) {
    const {value: %view, %done} = await %reader.read(
        new Uint8Array(%buffer, %offset, %buffer.byteLength - %offset));
    %buffer = %view.buffer;
    if (%done) {
      break;
    }
    %offset += %view.byteLength;
  }

  return %buffer;
}
</pre>

		</section>
		<section id="example-sending-stream">
<h3 title="Sending a stream">15.5. ~streamの送信-法</h3>

◎非規範的

<p>
~dataを一方通行な~streamとして送信することは、
`createUnidirectionalStream()$mT 関数から返される~streamの書込器を利用して達成できる。
◎
Sending data as a one-way stream can be achieved by using the createUnidirectionalStream function and the resulting stream’s writer.
</p>

<pre class="lang-js">
async function sendData(%url, ...%data) {
  const %wt = new WebTransport(%url);
  const %writable = await %wt.createUnidirectionalStream();
  const %writer = %writable.getWriter();
  for (const %bytes of %data) {
    await %writer.ready;
    %writer.write(%bytes).catch(() =&gt; {});
  }
  await %writer.close();
}
</pre>

<p class="note">注記：
`write()^c からの~promiseを待受けること（ `await^c ）は、
~stream仕様により`忌避される＠~STREAMS#example-manual-write-dont-await$。
◎
The streams spec discourages awaiting the promise from write().
</p>

<p>
`ReadableStream$I から~pipeを通すことで，符号化も行える
— 例えば，
`TextEncoderStream$I を利用して。
◎
Encoding can also be done through pipes from a ReadableStream, for example using TextEncoderStream.
</p>

<pre class="lang-js">
async function sendText(%url, %readableStreamOfTextData) {
  const %wt = new WebTransport(%url);
  const %writable = await %wt.createUnidirectionalStream();
  await %readableStreamOfTextData
    .pipeThrough(new TextEncoderStream("utf-8"))
    .pipeTo(%writable);
}
</pre>

		</section>
		<section id="example-receiving-incoming-streams">
<h3 title="Receiving incoming streams">15.6. 流入~streamの受信-法</h3>

◎非規範的

<p>
流入~streamを読取ることは、
次により達成できる
⇒
`incomingUnidirectionalStreams$mT 属性~上で
各 `WebTransportReceiveStream$I を反復して，
そこからの各~chunkを反復して消費する。
◎
Reading incoming streams can be achieved by iterating over the incomingUnidirectionalStreams attribute, and then consuming each WebTransportReceiveStream by iterating over its chunks.
</p>

<pre class="lang-js">
async function receiveData(%url, %processTheData) {
  const %wt = new WebTransport(%url);
  for await (const %readable of %wt.incomingUnidirectionalStreams) {
    /* <span class="comment">
`IFFEs^en【？】 を個別に利用して各~streamを消費する,
~streamごとに~errorを報告する
◎
consume streams individually using IFFEs, reporting per-stream errors
</span> */
    ((async () =&gt; {
      try {
        for await (const %bytes of readable) {
          processTheData(%bytes);
        }
      } catch (%e) {
        console.error(%e);
      }
    })());
  }
}
</pre>

<p>
新たな `WritableStream$I へ~pipeすることを通して，復号も行える
— 例えば， `TextDecoderStream$I を利用して。
この例では、
~text出力は，他と前後されるべきでない
— したがって，回ごとに 1 個の~streamに限り読取る —
ものと見做す。
◎
Decoding can also be done through pipes to new WritableStreams, for example using TextDecoderStream. This example assumes text output should not be interleaved, and therefore only reads one stream at a time.
</p>

<pre class="lang-js">
async function receiveText(%url, %createWritableStreamForTextData) {
  const %wt = new WebTransport(%url);
  for await (const %readable of %wt.incomingUnidirectionalStreams) {
    /* <span class="comment">
出力を他と前後することなく，連列的に消費する。
~errorは~streamごとに報告する。
◎
consume sequentially to not interleave output, reporting per-stream errors
</span> */
    try {
      await %readable
       .pipeThrough(new TextDecoderStream("utf-8"))
       .pipeTo(%createWritableStreamForTextData());
    } catch (%e) {
      console.error(%e);
    }
  }
}
</pre>

		</section>
		<section id="example-stream-byob">
<h3 title="Receiving a stream with a BYOB reader">15.7. ~BYOB読取器による~streamの受信-法</h3>

◎非規範的

<p>
`WebTransportReceiveStream$I は`可読~byte~stream$なので、
それ用に`~BYOB読取器$を獲得できる
— それは、
複製を避けるために，より精確な［
~bufferの割振りに対する制御
］を許容する。
この例は、
`WebTransportReceiveStream$I から最初の 1024 ~byteを単独の~memory~bufferの中へ読取る。
◎
As WebTransportReceiveStreams are readable byte streams, you can acquire a BYOB reader for them, which allows more precise control over buffer allocation in order to avoid copies. This example reads the first 1024 bytes from a WebTransportReceiveStream into a single memory buffer.
</p>

<pre class="lang-js">
const %wt = new WebTransport(%url);

const %reader = %wt.incomingUnidirectionalStreams.getReader();
const { value: %recv_stream, %done } = await %reader.read();
const %byob_reader = %recv_stream.getReader({ mode: "byob" });

let %array_buffer = new ArrayBuffer(1024);
const %buffer = await readInto(%array_buffer);

async function readInto(%buffer) {
  let %offset = 0;

  while (%offset &lt; %buffer.byteLength) {
    const {value: %view, %done} = await %reader.read(
        new Uint8Array(%buffer, %offset, %buffer.byteLength - %offset));
    %buffer = %view.buffer;
    if (%done) {
      break;
    }
    %offset += %view.byteLength;
  }

  return %buffer;
}
</pre>

		</section>
		<section id="example-transactional-stream">
<h3 title="Sending a transactional chunk on a stream">15.8. ~streamに対する不可分的な~chunkの送信-法</h3>

◎非規範的

<p>
不可分的な一片を成す~dataを［
`~flow制御$により阻まれることなく，一度で行える場合
］に限り，一方向な~stream上に送信することは、
`getWriter()$mS ~method【！関数】, その結果の書込器（ %writer ）を利用して達成できる。
◎
Sending a transactional piece of data on a unidirectional stream, only if it can be done entirely without blocking on flow control, can be achieved by using the getWriter function and the resulting writer.
</p>

<pre class="lang-js">
async function sendTransactionalData(%wt, %bytes) {
  const %writable = await %wt.createUnidirectionalStream();
  const %writer = %writable.getWriter();
  await %writer.ready;
  try {
    await writer.atomicWrite(%bytes);
  } catch (%e) {
    if (%e.name != "AbortError") throw %e;
    /* <span class="comment">
~flow制御により阻まれるのを避けるため、
却下される。
%writable は、［
処理待ちな不可分でない書込n
］は無い限りにおいて，~errorしないままにあり続ける。
◎
rejected to avoid blocking on flow control
The writable remains un-errored provided no non-atomic writes are pending
</span> */
  } finally {
    %writer.releaseLock();
  }
}
</pre>

		</section>
		<section id="example-server-certificate-hash">
<h3 title="Using a server certificate hash">15.9. ~server証明書~hashの利用-法</h3>

◎非規範的

<p>
~WebTransport~sessionは、［
~clientにより遂行される既定の信用-評価
］を［
~serverへ供される証明書の~hashに対する検査
］で上書きし得る。
次の例の %hashValue は、
~server証明書の~SHA-256 ~hashを包含している `BufferSource$I であり，
その妥当~性は`下層~接続$が考慮するべきものである。
◎
A WebTransport session can override the default trust evaluation performed by the client with a check against the hash of the certificate provided to the server. In the example below, hashValue is a BufferSource containing the SHA-256 hash of a server certificate that the underlying connection should consider to be valid.
</p>

<pre class="lang-js">
const %wt = new WebTransport(%url, {
  serverCertificateHashes: [
    {
      algorithm: "sha-256",
      value: %hashValue,
    }
  ]
});
await %wt.ready;
</pre>

		</section>
		<section id="example-complete">
<h3 title="Complete example">15.10. 完全な例</h3>

◎非規範的

<p>
この例は、
次について~~説明する：
◎
This example illustrates＼
</p>
<ul>
	<li>
［
~close時の~promise, 準備済み時の~promise
］の利用
◎
use of the closed and ready promises,＼
</li>
	<li>
［
~client／~server
］による［
一方向~stream, 双方向~stream
］の~open法
◎
opening of uni-directional and bi-directional streams by either the client or the server,＼
</li>
	<li>
~datagramの［
送信-法, 受信-法
］
◎
and sending and receiving datagrams.
</li>
</ul>

<div class="note">
<p>注記：
以前は~transportの `datagrams$mT に存在していた `writable^m 属性は、
次のように容易に~polyfillできる：
◎
The writable attribute that used to exist on a transport’s datagrams is easy to polyfill as follows:
</p>

<pre class="lang-js">
%wt.datagrams.writable ||= %wt.datagrams.createWritable();
</pre>
</div>

<pre class="lang-js">
/* <span class="comment">
~page上の~event~logに~entryを追加する。
【！余計？任意選択で，指定された~CSS~classを適用して】
◎
Adds an entry to the event log on the page, optionally applying a specified CSS class.
</span> */

let %wt, %streamNumber, %datagramWriter;

connect.onclick = async () =&gt; {
  try {
    const %url = document.getElementById('url').value;

    %wt = new WebTransport(%url);
    %wt.datagrams.writable ||= %wt.datagrams.createWritable();
    addToEventLog('接続を起動しています...');
    await %wt.ready;
    addToEventLog(``^${(%wt.reliability == "reliable-only")? "TCP" : "UDP"} 接続は準備済み。``^);
    %wt.closed
      .then(() =&gt; addToEventLog('接続は正常に~closeされました。'))
      .catch(() =&gt; addToEventLog('接続は中途で~closeされました。', 'error'));

    %streamNumber = 1;
    %datagramWriter = %wt.datagrams.writable.getWriter();

    %readDatagrams();
    %acceptUnidirectionalStreams();
    document.forms.sending.elements.send.disabled = false;
    document.getElementById('connect').disabled = true;
  } catch (%e) {
    addToEventLog(``^接続に失敗しました。 ${%e}``^, 'error');
  }
}

sendData.onclick = async () =&gt; {
  const %form = %document.forms.sending.elements;
  const %data = %sending.data.value;
  const %bytes = new TextEncoder('utf-8').encode(%data);
  try {
    switch (%form.sendtype.value) {
      case 'datagram': {
        await %datagramWriter.ready;
        %datagramWriter.write(%bytes).catch(() =&gt; {});
        addToEventLog(``^~datagramを送信しました: ${%data} ``^);
        break;
      }
      case 'unidi': {
        const %writable = await %wt.createUnidirectionalStream();
        const %writer = %writable.getWriter();
        %writer.write(%bytes).catch(() =&gt; {});
        await %writer.close();
        addToEventLog(``^一方向~streamを~dataと伴に送信しました: ${%data}``^);
        break;
      }
      case 'bidi': {
        const %duplexStream = await %wt.createBidirectionalStream();
        const %n = %streamNumber++;
        readFromIncomingStream(%duplexStream.readable, %n);

        const %writer = %duplexStream.writable.getWriter();
        %writer.write(%bytes).catch(() =&gt; {});
        await %writer.close();
        addToEventLog(``^双方向~stream #${%n} を~dataと伴に送信しました: ${%data}``^);
        break;
      }
    }
  } catch (%e) {
    addToEventLog(``^~dataの送信-中に~error: ${%e}``^, 'error');
  }
}

/* <span class="comment">
~EOFに到達するまで、
~datagram群を~event~logの中へ読取る。
◎
Reads datagrams into the event log until EOF is reached.
</span> */
async function readDatagrams() {
  try {
    const %decoder = new TextDecoderStream('utf-8');

    for await (const %data of %wt.datagrams.readable.pipeThrough(%decoder)) {
      addToEventLog(``^~datagramを受信しました: ${%data}``^);
    }
    addToEventLog('~datagramを読取りました。');
  } catch (%e) {
    addToEventLog(``^~datagramの読取n中に~error: ${%e}``^, 'error');
  }
}

async function acceptUnidirectionalStreams() {
  try {
    for await (const %readable of %wt.incomingUnidirectionalStreams) {
      const %number = %streamNumber++;
      addToEventLog(``^新たな流入~一方向~stream #${%number}``^);
      readFromIncomingStream(%readable, %number);
    }
    addToEventLog('一方向~streamを受容しました。');
  } catch (%e) {
    addToEventLog(``^~stream ${%e} の受容-中に~error。``^, 'error');
  }
}

async function readFromIncomingStream(%readable, %number) {
  try {
    const %decoder = new TextDecoderStream('utf-8');
    for await (const %data of %readable.pipeThrough(%decoder)) {
      addToEventLog(``^~stream #${%number} 上で~dataを受信しました: ${%data}``^);
    }
    addToEventLog(``^~stream #${%number} は~closeされました。``^);
  } catch (%e) {
    addToEventLog(``^~stream #${%number} から読取n中に~error: ${%e}``^, 'error');
    addToEventLog(``^    ${%e.message}``^);
  }
}

function addToEventLog(%text, %severity = 'info') {
  const %log = document.getElementById('event-log');
  const %previous = %log.lastElementChild;
  const %entry = document.createElement('li');
  %entry.innerText = %text;
  %entry.className = ``^`log^-${%severity}``^;
  %log.appendChild(%entry);

  /* <span class="comment">
%log 内のそれまでの~entryが可視であった場合、
新たな要素へ~scrollする。
◎
If the previous entry in the log was visible, scroll to the new element.
</span> */
  if (%previous &amp;&amp;
      %previous.getBoundingClientRect().top &lt; %log.getBoundingClientRect().bottom) {
    %entry.scrollIntoView();
  }
}
</pre>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p lang="en">
The editors wish to thank the Working Group chairs and Team Contact, Jan-Ivar Bruaroey, Will Law and Yves Lafon, for their support.
</p>

<p>
`WebTransport$I ~interfaceは、
`W3C ORTC CG＠https://www.w3.org/community/ortc/$
にて初期に述べられた `QuicTransport^I ~interfaceに基づく
— それから，この仕様における利用-用に順応された。
◎
The WebTransport interface is based on the QuicTransport interface initially described in the W3C ORTC CG, and has been adapted for use in this specification.
</p>

	</section>
</main></div>
