<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>WebTransport（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
.settings-parameter,
.frame-type,
.error-code {
	font-family: sans-serif0, sans-serif;
	color: var(--K-color);
}

@supports (display: grid) and (display: contents) {

._stream-capa {
	min-width: 32em;
	max-width: 52em;
}

._stream-capa tr {
	grid-template-areas:
		"能力 能力 能力 能力 能力"
		". 定義 流入 流出 双方向"
	;
	grid-template-columns: 4em 1fr 1fr 1fr 1fr;
}

._stream-capa tr > *:nth-child(1) {
	grid-area: 能力;
	border-left-width: 0;
}

._stream-capa tr > *:nth-child(2) {
	grid-area: 定義;
}

._stream-capa tr > *:nth-child(3) {
	grid-area: 流入;
}

._stream-capa tr > *:nth-child(4) {
	grid-area: 流出;
}

._stream-capa tr > *:nth-child(5) {
	grid-area: 双方向;
}

#_session-capa tr {
	grid-template-areas:
		"能力 能力"
		". 定義"
	;
	grid-template-columns: 4em 1fr;
}


._wt-effect tr {
	grid-template-areas:
		"原因 原因"
		". 効果"
	;
	grid-template-columns: 4em 1fr;
}

._wt-effect tr > *:nth-child(1) {
	grid-area: 原因;
	border-left-width: 0;
}

._wt-effect tr > *:nth-child(2) {
	grid-area: 効果;
}

}
</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'm':
case 'dw':
case 'dr':
case 'ws':
case 'mH':
case 'rs':
case 'gr':
case 'mT':
case 'mD':
case 'mR':
case 'mS':
case 'mB':
case 'mE':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	text = `"<code class="literal">${key}</code>"`;
	break;
case 'sl':
case 'slS':
case 'slR':
case 'slB':
	text = `[[${key}]]`;
	break;
case 'commit':
	href1 = `https://github.com/w3c/web-share/commit/${key}`
	text = `commit`;
	break;
case 'pull':
	href1 = `https://github.com/w3c/web-share/pull/${key}`
	text = `pull`;
	break;
case 'en':
	text = `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>


<script type="text/plain" id="_source_data">


●●options

spec_title:WebTransport
spec_date:2023-07-18
trans_update:2023-08-17
source_checked:230718
	page_state_key:
original_url:https://w3c.github.io/webtransport/
	abbr_url:WEBTRANSPORT
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:w3c
site_nav:network,security
copyright:2023,permissive
trans_1st_pub:2023-08-16


●●class_map
E:error
h:header
M:method
jv:js-value
sl:js-slot
slS:js-slot
slR:js-slot
slB:js-slot
ft:frame-type
er:error-code
sp:settings-parameter


●●tag_map
h:code
M:code
c:code
I:code
E:code
m:code
dw:code
gr:code
mB:code
mD:code
mE:code
mH:code
mR:code
mS:code
mT:code
mb:code
rs:code
ws:code
mbR:code
mbS:code
mbE:code
mbD:code
jv:code
sl:span
slS:span
slR:span
slB:span
ft:code
er:code
sp:code
b:b
i:i
em:em
cite:cite

●●words_table1
ECMA262:http://www.ecma-international.org/ecma-262/6.0/index.html
ECMA262:https://tc39.es/ecma262/
WT-HTTP3:https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3/

●●words_table

	●名称／略称
QUIC:
UDP:
TCP:
TLS:
HTTP3:HTTP/3
HTTP2:HTTP/2
ALPN:
ACK:
WebTransport:
WebRTC:
WebSocket:
	WebSockets
PKI:
SHA-256:
RTT:
DER:
UNIX:
WEBTRANS:
WebIDL:
ECMAScript:
RSA:
	X.509v3
	^en:Certificate
	^en:Subject Public Key
	^en:Subject Public Key Info
	^en:TLS CertificateVerify
	^en:ECDSA with the secp256r1 (NIST P-256) named group
	^en:IFFEs

	●transport／metwork
FIN:
datagram::::データグラム
packet::::パケット
pool:
	~pool法:pooling
close:
	~close時の:closed
	~closeする際の:closing
open:
	~open法:opening
route::::ルート
	~route可能:routable
ack:
handshake::::ハンドシェイク
運ぶ:carryする:~
輻輳:congestion::~
外方:outbound::~::アウトバウンド
ticket::::チケット
capsule:
二重化:duplex::~
交換:exchange:~
送信者:sender::~
	送信者~側:sender-side
端点:endpoint::~::エンドポイント
	相手の端点:peer
経路:path::~
clean:
	接続:the first hop
reliable:
unreliable:
draining:
認知-:acknowledge:~
contact:
受領:receipt::~
	受信される:reception

	~frame法:framing
	~cache法:caching
	`Data Recvd^i:"Data Recvd"
	^M:CONNECT
	^sp:SETTINGS_ENABLE_WEBTRANPORT
	^sp:H3_DATAGRAM
	$ft:SETTINGS
	^ft:CONNECTION_CLOSE
	`STOP_SENDING^ft:stop_sending
	$ft:STOP_SENDING
	$ft:RESET_STREAM
	`RESET_STREAM^ft:reset

	●stream
一方向:unidirectional::~
	一方向:uni-directional
	~~一方向:one-way
双方向:bidirectional::~
	双方向:bi-directional
流入:incoming::~
流出:outgoing::~
BYOB:
限界水位:high water mark::~
chunk::::チャンク
EOF:
背圧:backpressure::~
消費器:consumer::~
pipe::::パイプ
書込n:write::書き込み
書込んだ:writeした::書き込んだ
書込んで:writeして::書き込んで
書込む:writeする::書き込む
書込まれ:writeされ::書き込まれ
書込器:writer::書き込み器
可書:writable::~
可読:readable::~

	再-伝送:retransmission
	~stream用の:streaming

	●処理
同型:isomorphic::~
片付ける:clean upする:~
	片付ける:cleanup
逆直列化:deserialization::~::逆シリアル化
退行-:degrade:~
決着-:settle:~
同時並行的:concurrent:~
露呈-:reveal::露わに
待受ける:awaitする:~
消費器:consumer::~
割振る:allocateする::割り振る
milli::::ミリ
rate::::レート
overhead::::オーバーヘッド
優先順位付け:prioritization:~
統計:stats::~
	統計:statistics
上品:graceful:~
中途で:abruptに:~
正常:normal:~
直列形:serialized::~::シリアル形
公平:fair:~
	公平さ:fairness
分合う:divideする:分け合う
処理待ち:pending:~
集めて:gatherして:~
集める:gatherする:~
集めら:gatherされ:~
単調増加-:monotonic に increase:~
平均:mean:~
見積もら:estimateさ:~
見積もり:estimate:~
調律-:tune::~
標本:sample:~
期間:period:~
変動:variation:~
後回-:starve::後回しに
喪失-:lose:~
出生-:originate:~
overflow::::オーバーフロー
real-time:real time:::リアルタイム
符号化:encoding::~::エンコーディング
復号:decoding::~::デコーディング

	渡して:pass
	~milli秒数:milliseconds
	~milli秒:ms
	時点で:at the time of
	回ごとに:at a time
	秒あたりの:per second
	かかることもある:may take
	の直前まで限り:up to, but not including
	高いものほど先に:ahead of 〜 lower
	処理-可能:processable
	この時点ですでに:previously
	~UNIX~epoch$:UNIX epoch (Jan 1, 1970, UTC)
	前後して:interleave
	他と前後され:interleave
	順序どおりでない:out-of-order
	渡して:pass

	●変数
	%~FINを受信したか:hasReceivedFIN
	%~HTTP3に限るか:http3Only
	%~buffer:buffer
	%~byte列:bytes
	%符号化した証明書:cert
	%~chunk:chunk
	%~cleanにか:cleanly
	%~client:client
	%~close時の~promise:closed
	-:closeAlgorithm
	%~close報:closeInfo
	%~code:code
	%~data:data
	%~datagram群:datagrams
	-:pullDatagramsAlgorithm
	-:writeDatagramsAlgorithm
	%所要時間:duration
	%~error:error
	%~hash:hash
	%~hash値:hashValue
	%~hash群:hashes
	%~hash~source:-
	%~HTTP~error~code:httpErrorCode
	%~network区分~key:networkPartitionKey
	%~offset:offset
	-:allowPooling
	%~promise:promise
	%~promise:p
	-:pullAlgorithm
	%~queue:queue
	%~server証明書~hash群:serverCertificateHashes
	%~session:session
	%~stream:stream
	%~transport:transport
	%~unreliableは要求されるか:requireUnreliable
	%~view:view
	-:pullUnidirectionalStreamAlgorithm
	-:abortAlgorithm
	%中止-時の~promise:abortPromise
	%事由:reason
	%事由~byte列:reasonBytes
	%事由~文字列:reasonString
	%値:value
	%内部~stream:internalStream
	%処理待ち演算:pendingOperation
	%参照~hash:referenceHash
	-:pullBidirectionalStreamAlgorithm
	-:cancelAlgorithm
	%受信-~stream:receiveStream
	%受信-~stream群:receiveStreams
	%可書~stream:writable
	%可読~stream:readable
	%専用か:dedicated
	%手続き:steps
	%接続:connection
	%新たな接続:newConnection
	%時刻印:timestamp
	-:writeAlgorithm
	%最大-~byte数:maxBytes
	%maxDatagramSize
	%最大-~size:maxSize
	%構文解析した~URL:parsedURL
	%流入~datagram群:incomingDatagrams
	%流入~一方向~stream群:incomingUnidirectionalStreams
	%流入~双方向~stream群:incomingBidirectionalStreams
	%流出~datagram群:outgoingDatagrams
	%準備済み時の~promise:ready
	%生成元:origin
	%統計:stats
	%要素~size:elementSize
	%要請:request
	%設定群:settings
	%証明書:certificate
	%長さ:read
	%輻輳~制御:congestionControl
	%送信-~stream:sendStream
	%送信-~stream群:sendStreams
	%送信-順序:sendOrder
	%除去する個数:toBeRemoved
	%~session
	%直列形:serialized

	●保安
証明書:certificate::~
廃止:revocation::~
失効n:expiration::失効
失効:expiry::失効
秘密鍵:private key::~
公開鍵:public key::~
	公開鍵:public-key
鍵:key::~
交替-:rotate::~
交替:rotation::~
hash::::ハッシュ
区分:partition::~
暗号用:cryptographic::~
弱体化:compromise::~
弱体化-:compromise::~
弱い:weakな:~
耐性:resistance::~
能動的:active::~
受動的:passive::~
野放図:unsanctioned:~
散発的:sporadic:~
容量:capacity::~
致命的:fatal:~
確認-:confirm:~
敵対者:adversary:~
防護策:safeguards:~
支給-:provision:~
機密性:confidentiality::~
認証-:authenticate::~
認証:authentication::~
観測者:observer::~
相関-:correlate::~
迂回-:bypass:~
走査-:scan:~
開示:disclosure:~
持続性:persistence:~
持続的:persistent:~
期限:limit:~
活動:activity:~
利用度:usage:~
推定-:infer:~
立地:vantage point:~
人々:people:~
識別情報:identity:~
悪影響:adverse effect:~

	^en:interstitial
	^en:second-preimage resistance
	他と競わない:uncontested
	^en:contested
	^en:contact
	`阻止される^i:<b>"Blocked"</b>
	`阻止される^i:blocked
	繋がり:connection
	無効~化-:invalidation
	無効~化:invalidate
	隠せない:cannot be hidden
	抗する:against

	●仕様
運用者:operator::~
収容-:accomodate:~
安定的:stable:~
計量:metrics:~
逐次的:sequential:~
順応-:adapt:~
balance::::バランス
難題:challenging:~
適度:reasonable:~
確証:confidence:~
準備的:preliminary:~
課して:imposeして:~
課す:imposeする:~
責務:responsibility:~
	責務がある:responsible

	きちんと:wellに
	重要なこととして:It is important to
	できるようにする:lets
	とは限らない:necessarily
	必ず:make sure
	みなされ:regard
	用意がある／ない:willing to
	以下では〜と称される:we will refer
	場合もある:may
	アリでない:impossible
	〜が選んだ:choice
	自身が選んだ:chosen
	選ぶ:chooseする
	知る:know
	足る:sufficient
	関わらず:regardless
	当の:in-question
	共に:in conjunction with
	見込みが高い:likely
	今後:going forward
	よって:hence
	に応じて:negation of
	触れない:touch
	足るまで:sufficiently
	行き渡るまで:being rolled out
	書いて:writing
	モノトスル:SHALL
	注記-:note
	実質:net
	原因:cause
	事実:fact
	気を配る:pay attention
	〜得る:potentially
	その帰結として:consequently
	~~説明:illustrate

	●言い換え
	^en:first-strong
	^en:quic-transport
	伴われていた:was accompanied
	最小~化:minimize
	を片付ける:cleanup
	今を表現している時刻印 ~MINUS:passed
	〜を指示する:An indicator of progress on
	無いに等しい:minimal
	整数:number
	-:opts
	-:enum
	-:a series of steps
	`minRtt$mb:min-RTT
	`smoothed_rtt^c ^en:smoothed
	~buffer化:buffering
	この数は、決して減少しない:This number can only increase.
	~GT:higher
	作動中でない:inactive
	~GTE 1:rounded down
	応用:app
	連列を成す:sequential
	~promise:Promise

	●未分類
throughput::::スループット
virtual:
適時性:timeliness:~
contact:
為す:makeする:~
為せる:makeできる:~
epoch:
固定的:fixed:~
運ぶ:carryする:~
到着-:arrive:~
満足-:satisfy:~
上界:upper bound:~
上限:upper limit:~
枯渇-:exhaust:~
番号:number:~
素早く:quickに:~
machine::::マシン
欠如:lack:~
確立:establishment:~
代用-:substitute:~
疑似-:pseudo-:~
超過-:exceed:~
側:side:~
帯域内:in-band::~
帯域幅:bandwidth::~
bottleneck::::ボトルネック
時計:clock:~
	ずれ:skew
短命:ephemeral:~
	短命:ephemeral or short-lived
	その場限りの:short-lived
所蔵-:possess:~
負荷:load:~
	負荷が軽い:lightly loaded
付され:attachされ:~
後続に:subsequentに:後続して
重複-:duplicate:~

	NaN:
	∞:
	現在に:currently
	短い／短く／低い／より低く:low
	なるべく下げる:lower
	大きい:larger
	総-~total
	以前の／それまでの:previous
	2 週間:two weeks
	場を占めて:taking place
	等しく:equally
	存在しない:non-existing
	今や／今:now
	残りの:remaining
	長期的:long-term
	各部:parts
	〜以下:inclusive
	旧くなった:being older
	何~byte:how many
	長く:high
	細かく:closely
	間／ ↔ :between
	不在:absent
	十分:enough
	近い:close to
	これまでに:so far
	高める:increase
	まとめて:at once
	埋まる:filling up
	数えら:countさ
	相互に:and vice versa
	まずまずの:decent
	危うく:jeopardizing
	入る:enter
	来ている:coming
	含まな:include
	含む:include
	-:maximal

●●original_id_map
	webtransportdatagramduplexstream-create:webtransportdatagramduplexstream-create-readable
	webtransportdatagramduplexstream-create:webtransportdatagramduplexstream-create-writable

●●mdn_urls

●●link_map

	●href/dfn 整理
	~ECMA262:http://www.ecma-international.org/ecma-262/6.0/index.html
	~HTMLLS:https://html.spec.whatwg.org/multipage
	~CSP3:https://w3c.github.io/webappsec-csp/


ECMA262:http://www.ecma-international.org/ecma-262/6.0/index.html
ECMA262:https://tc39.es/ecma262/


	●IDL
Exposed:~WEBIDL#Exposed
SecureContext:~WEBIDL#SecureContext
Serializable:~HTMLcloning#serializable
Transferable:~HTMLcloning#transferable
Clamp:~WEBIDL#Clamp

undefined:~WEBIDL#idl-undefined
long long:~WEBIDL#idl-long-long
unrestricted double:~WEBIDL#idl-unrestricted-double
c.unrestricted double:~WEBIDL#idl-unrestricted-double
unsigned long long:~WEBIDL#idl-unsigned-long-long
unsigned long:~WEBIDL#idl-unsigned-long
boolean:~WEBIDL#idl-boolean
USVString:~WEBIDL#idl-USVString
sequence:~WEBIDL#idl-sequence
DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
DOMString:~WEBIDL#idl-DOMString
Promise:~WEBIDL#idl-promise

I.Uint8Array:~WEBIDL#idl-Uint8Array
I.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
I.DataView:~WEBIDL#idl-DataView
I.BufferSource:~WEBIDL#BufferSource

E.AbortError:~WEBIDL#aborterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.NotSupportedError:~WEBIDL#notsupportederror
E.RangeError:~WEBIDL#exceptiondef-rangeerror
E.SyntaxError:~WEBIDL#syntaxerror
E.TypeError:~WEBIDL#exceptiondef-typeerror

I.DOMException:~WEBIDL#idl-DOMException
I.WebTransportOptions:#dictdef-webtransportoptions
I.WebTransportCongestionControl:#enumdef-webtransportcongestioncontrol
I.WritableStream:~STREAMS#writablestream
I.WebTransportDatagramDuplexStream:#webtransportdatagramduplexstream
I.WebTransport:#webtransport
I.WebTransportReliabilityMode:#enumdef-webtransportreliabilitymode
I.WebTransportHash:#dictdef-webtransporthash
I.WebTransportCloseInfo:#dictdef-webtransportcloseinfo
I.WebTransportSendStreamOptions:#dictdef-webtransportsendstreamoptions
I.WebTransportStats:#dictdef-webtransportstats
I.WebTransportDatagramStats:#dictdef-webtransportdatagramstats
I.WebTransportSendStream:#webtransportsendstream
I.WebTransportSendStreamStats:#dictdef-webtransportsendstreamstats
I.WebTransportReceiveStream:#webtransportreceivestream
I.WebTransportReceiveStreamStats:#dictdef-webtransportreceivestreamstats
I.WebTransportBidirectionalStream:#webtransportbidirectionalstream
I.WebTransportError:#webtransporterror
I.WebTransportErrorOptions:#dictdef-webtransporterroroptions
I.WebTransportErrorSource:#enumdef-webtransporterrorsource
I.ReadableStream:~STREAMS#readablestream
I.TextDecoderStream:~ENCODING#textdecoderstream
I.TextEncoderStream:~ENCODING#textencoderstream

	●#dom-

m.new WebTransport:#dom-webtransport-webtransport
	constructor:#dom-webtransport-webtransport
mD.readable:#dom-webtransportdatagramduplexstream-readable
mD.writable:#dom-webtransportdatagramduplexstream-writable
mD.incomingMaxAge:#dom-webtransportdatagramduplexstream-incomingmaxage
mD.maxDatagramSize:#dom-webtransportdatagramduplexstream-maxdatagramsize
mD.outgoingMaxAge:#dom-webtransportdatagramduplexstream-outgoingmaxage
mD.incomingHighWaterMark:#dom-webtransportdatagramduplexstream-incominghighwatermark
mD.outgoingHighWaterMark:#dom-webtransportdatagramduplexstream-outgoinghighwatermark

	%url:#dom-webtransport-webtransport-url-options-url
	%options:#dom-webtransport-webtransport-url-options-options
	%closeInfo:#dom-webtransport-close-closeinfo-closeinfo
	%options:#dom-webtransport-createbidirectionalstream-options-options
	%options:#dom-webtransport-createunidirectionalstream-options-options

l.pending:#dom-webtransportreliabilitymode-pending
l.reliable-only:#dom-webtransportreliabilitymode-reliable-only
l.supports-unreliable:#dom-webtransportreliabilitymode-supports-unreliable

mT.ready:#dom-webtransport-ready
mT.closed:#dom-webtransport-closed
mT.draining:#dom-webtransport-draining
mT.datagrams:#dom-webtransport-datagrams
mT.incomingBidirectionalStreams:#dom-webtransport-incomingbidirectionalstreams
mT.incomingUnidirectionalStreams:#dom-webtransport-incomingunidirectionalstreams
mT.reliability:#dom-webtransport-reliability
mT.congestionControl:#dom-webtransport-congestioncontrol
mT.close:#dom-webtransport-close
mT.getStats:#dom-webtransport-getstats
mT.createBidirectionalStream:#dom-webtransport-createbidirectionalstream
mT.createUnidirectionalStream:#dom-webtransport-createunidirectionalstream

mH.algorithm:#dom-webtransporthash-algorithm
mH.value:#dom-webtransporthash-value

l.default:#dom-webtransportcongestioncontrol-default
l.throughput:#dom-webtransportcongestioncontrol-throughput
l.low-latency:#dom-webtransportcongestioncontrol-low-latency

mb.allowPooling:#dom-webtransportoptions-allowpooling
mb.requireUnreliable:#dom-webtransportoptions-requireunreliable
mb.serverCertificateHashes:#dom-webtransportoptions-servercertificatehashes
mb.congestionControl:#dom-webtransportoptions-congestioncontrol

mb.closeCode:#dom-webtransportcloseinfo-closecode
mb.reason:#dom-webtransportcloseinfo-reason

mb.sendOrder:#dom-webtransportsendstreamoptions-sendorder

mb.datagrams:#dom-webtransportstats-datagrams
mb.timestamp:#dom-webtransportstats-timestamp
mb.bytesSent:#dom-webtransportstats-bytessent
mb.packetsSent:#dom-webtransportstats-packetssent
mb.packetsLost:#dom-webtransportstats-packetslost
mb.numOutgoingStreamsCreated:#dom-webtransportstats-numoutgoingstreamscreated
mb.numIncomingStreamsCreated:#dom-webtransportstats-numincomingstreamscreated
mb.bytesReceived:#dom-webtransportstats-bytesreceived
mb.packetsReceived:#dom-webtransportstats-packetsreceived
mb.smoothedRtt:#dom-webtransportstats-smoothedrtt
mb.rttVariation:#dom-webtransportstats-rttvariation
mb.minRtt:#dom-webtransportstats-minrtt
mb.estimatedSendRate:#dom-webtransportstats-estimatedsendrate

mbD.timestamp:#dom-webtransportdatagramstats-timestamp
mbD.expiredOutgoing:#dom-webtransportdatagramstats-expiredoutgoing
mbD.droppedIncoming:#dom-webtransportdatagramstats-droppedincoming
mbD.lostOutgoing:#dom-webtransportdatagramstats-lostoutgoing

mS.sendOrder:#dom-webtransportsendstream-sendorder
mS.getStats:#dom-webtransportsendstream-getstats

mbS.timestamp:#dom-webtransportsendstreamstats-timestamp
mbS.bytesWritten:#dom-webtransportsendstreamstats-byteswritten
mbS.bytesSent:#dom-webtransportsendstreamstats-bytessent
mbS.bytesAcknowledged:#dom-webtransportsendstreamstats-bytesacknowledged

mR.getStats:#dom-webtransportreceivestream-getstats

mbR.timestamp:#dom-webtransportreceivestreamstats-timestamp
mbR.bytesReceived:#dom-webtransportreceivestreamstats-bytesreceived
mbR.bytesRead:#dom-webtransportreceivestreamstats-bytesread

mB.readable:#dom-webtransportbidirectionalstream-readable
mB.writable:#dom-webtransportbidirectionalstream-writable

	%message:#dom-webtransporterror-webtransporterror-message-options-message
	%options:#dom-webtransporterror-webtransporterror-message-options-options

l.stream:#dom-webtransporterrorsource-stream
l.session:#dom-webtransporterrorsource-session

m.new WebTransportError:#dom-webtransporterror-webtransporterror
	constructor:#dom-webtransporterror-webtransporterror
mE.source:#dom-webtransporterror-source
mE.streamErrorCode:#dom-webtransporterror-streamerrorcode
mbE.source:#dom-webtransporterroroptions-source
mbE.streamErrorCode:#dom-webtransporterroroptions-streamerrorcode

m.code:~WEBIDL#dom-domexception-code

c.WritableStreamDefaultWriter.ready:~STREAMS#default-writer-ready
	c.WritableStreamDefaultWriter.write:~STREAMS#default-writer-write

gr.cancel:~STREAMS#generic-reader-cancel
dr.read:~STREAMS#default-reader-read
dw.abort:~STREAMS#default-writer-abort
dw.close:~STREAMS#default-writer-close
dw.write:~STREAMS#default-writer-write
rs.cancel:~STREAMS#rs-cancel
ws.close:~STREAMS#ws-close
ws.abort:~STREAMS#ws-abort

	●sl
sl.Readable:#dom-webtransportdatagramduplexstream-readable-slot
sl.Writable:#dom-webtransportdatagramduplexstream-writable-slot
sl.IncomingDatagramsQueue:#dom-webtransportdatagramduplexstream-incomingdatagramsqueue-slot
sl.IncomingDatagramsPullPromise:#dom-webtransportdatagramduplexstream-incomingdatagramspullpromise-slot
sl.IncomingDatagramsHighWaterMark:#dom-webtransportdatagramduplexstream-incomingdatagramshighwatermark-slot
sl.IncomingDatagramsExpirationDuration:#dom-webtransportdatagramduplexstream-incomingdatagramsexpirationduration-slot
sl.OutgoingDatagramsQueue:#dom-webtransportdatagramduplexstream-outgoingdatagramsqueue-slot
sl.OutgoingDatagramsHighWaterMark:#dom-webtransportdatagramduplexstream-outgoingdatagramshighwatermark-slot
sl.OutgoingDatagramsExpirationDuration:#dom-webtransportdatagramduplexstream-outgoingdatagramsexpirationduration-slot
sl.OutgoingMaxDatagramSize:#dom-webtransportdatagramduplexstream-outgoingmaxdatagramsize-slot

sl.SendStreams:#dom-webtransport-sendstreams-slot
sl.ReceiveStreams:#dom-webtransport-receivestreams-slot
sl.IncomingBidirectionalStreams:#dom-webtransport-incomingbidirectionalstreams-slot
sl.IncomingUnidirectionalStreams:#dom-webtransport-incomingunidirectionalstreams-slot
sl.State:#dom-webtransport-state-slot
sl.Ready:#dom-webtransport-ready-slot
sl.Reliability:#dom-webtransport-reliability-slot
sl.CongestionControl:#dom-webtransport-congestioncontrol-slot
sl.Closed:#dom-webtransport-closed-slot
sl.Draining:#dom-webtransport-draining-slot
sl.Datagrams:#dom-webtransport-datagrams-slot
sl.Session:#dom-webtransport-session-slot

slS.InternalStream:#dom-webtransportsendstream-internalstream-slot
slS.PendingOperation:#dom-webtransportsendstream-pendingoperation-slot
slS.Transport:#dom-webtransportsendstream-transport-slot
slS.SendOrder:#dom-webtransportsendstream-sendorder-slot

slR.InternalStream:#dom-webtransportreceivestream-internalstream-slot
slR.Transport:#dom-webtransportreceivestream-transport-slot

slB.Readable:#dom-webtransportbidirectionalstream-readable-slot
slB.Writable:#dom-webtransportbidirectionalstream-writable-slot
slB.Transport:#dom-webtransportbidirectionalstream-transport-slot

sl.Source:#dom-webtransporterror-source-slot
sl.StreamErrorCode:#dom-webtransporterror-streamerrorcode-slot

ft.DRAIN_WEBTRANSPORT_SESSION:#session-signal-drain_webtransport_session
ft.GOAWAY:#session-signal-goaway
ft.STOP_SENDING:#stream-signal-stop_sending
ft.RESET_STREAM:#stream-signal-reset_stream
ft.SETTINGS:~HTTPv3#frame-settings

h.Origin:~FETCH#http-origin

	●用語
~WebTransport~stream:#webtransport-stream
~WebTransport~session:#protocol-webtransport-session
~datagramを送信する:#session-send-a-datagram
~datagramを受信する:#session-receive-a-datagram
		available incoming datagrams:#session-receive-a-datagram
流出~一方向~streamを作成する:#session-create-an-outgoing-unidirectional-stream
双方向~streamを作成する:#session-create-a-bidirectional-stream
流入~一方向~streamを受信する:#session-receive-an-incoming-unidirectional-stream
		available流入~一方向~stream:#session-receive-an-incoming-unidirectional-stream
~HTTP越しの~WebTransportを初期化する:#initialize-webtransport-over-http
双方向~streamを受信する:#session-receive-a-bidirectional-stream
		available incoming 双方向~stream:#session-receive-a-bidirectional-stream
		receiving a 双方向~stream:#session-receive-a-bidirectional-stream
~WebTransport~sessionを確立する:#session-establish
~WebTransport~sessionを終了する:#session-terminate
		確立する:#session-establish
		established:#session-establish
		establishment process:#session-establish
~draining:#session-draining
終了され:#session-terminated
流入~一方向:#stream-incoming-unidirectional
流出~一方向:#stream-outgoing-unidirectional
双方向:#stream-bidirectional
WT.送信-:#stream-send
WT.送信する:#stream-send
WT.受信-:#stream-receive
WT.受信する:#stream-receive
	read:#stream-receive
	received:#stream-receive
WT.送信を停止させる:#stream-send-stop_sending
	STOP_SENDING を送信する:#stream-send-stop_sending
WT.設定し直す:#stream-reset
	RESET_STREAM を送信する:#stream-reset
	RESET.送信する:#stream-reset
~flow制御:#stream-signal-flow-control
	
DPS.作成する:#webtransportdatagramduplexstream-create
	%readable:#webtransportdatagramduplexstream-create-readable
	%writable:#webtransportdatagramduplexstream-create-writable

~datagram群を~pullする:#pulldatagrams
~datagram群を受信する:#receivedatagrams
~datagram群を書込む:#writedatagrams
~datagram群を送信する:#senddatagrams
双方向~streamを~pullする:#pullbidirectionalstream
一方向~streamを~pullする:#pullunidirectionalstream
~WebTransportを片付ける:#webtransport-cleanup
~network~taskを~queueする:#webtransport-queue-a-network-task
文脈を片付ける手続き:#context-cleanup-steps
証明書~hashを算出する:#compute-a-certificate-hash
証明書~hashを検証yする:#verify-a-certificate-hash
~custom証明書~要件:#custom-certificate-requirements
許容される公開鍵~algo:#allowed-public-key-algorithms
厳密な順序付け:#strict-ordering
		strictly ordered:#strict-ordering
wtS.作成する:#webtransportsendstream-create
wtS.書込む:#webtransportsendstream-write
wtS.~closeする:#webtransportsendstream-close
wtS.中止する:#webtransportsendstream-abort
		aborting:#webtransportsendstream-abort
wtR.作成する:#webtransportreceivestream-create
wtR.~byte列を~pullする:#webtransportreceivestream-pull-bytes
wtR.取消す:#webtransportreceivestream-cancel
wtB.作成する:#bidirectionalstream-create

~WebTransport用の例外を作成する:#_create-exception-for-webtransport

	●用語（外部
実装定義:~INFRA#implementation-defined
ときは中止する:~INFRA#abort-when
中止されたときは:~INFRA#if-aborted
~byte列:~INFRA#byte-sequence
符号単位:~INFRA#code-unit
	符号単位~接頭辞:~INFRA#code-unit-prefix
~queue:~INFRA#queue
~dequeueする:~INFRA#queue-dequeue
~enqueueする:~INFRA#queue-enqueue
~scalar値~文字列に変換する:~INFRA#javascript-string-convert
同型に符号化する:~INFRA#isomorphic-encode
byte.長さ:~INFRA#byte-sequence-length
有順序~集合:~INFRA#ordered-set
~ASCII大小無視:~INFRA#ascii-case-insensitive
set.付加する:~INFRA#set-append
除去する:~INFRA#list-remove
~size:~INFRA#list-size

所与の値:~WEBIDL#the-given-value
充足-時:~WEBIDLjs#upon-fulfillment
却下-時:~WEBIDLjs#upon-rejection
新たな~promise:~WEBIDLjs#a-new-promise
~promiseを却下する:~WEBIDLjs#reject
~promiseを解決する:~WEBIDLjs#resolve
却下される~promise:~WEBIDLjs#a-promise-rejected-with
解決される~promise:~WEBIDLjs#a-promise-resolved-with
	:~ECMA262#sec-promise-objects

BS.下層~buffer:~WEBIDLjs#buffersource-underlying-buffer
BS.~byte長さ:~WEBIDLjs#buffersource-byte-length
配列~bufferの中へ~byte列を書込む:~WEBIDLjs#arraybuffer-write
例外を作成する:~WEBIDL#dfn-create-exception
eX.~message:~WEBIDL#domexception-message
eX.名前:~WEBIDL#domexception-name
	コレ:~WEBIDL#this
新たな:~WEBIDLjs#new
	~THROW:~WEBIDL#dfn-throw
保持された~byte列の複製を取得する:~WEBIDLjs#dfn-get-buffer-source-copy
~buffer~sourceを~byte列から作成する:~WEBIDLjs#_buffersource-create

要請:~FETCH#concept-request
rq.生成元:~FETCH#concept-request-origin
rq.施策~容器:~FETCH#concept-request-policy-container
rq.~URL:~FETCH#concept-request-url
rq.~client:~FETCH#concept-request-client
rq.行先:~FETCH#concept-request-destination
接続:~FETCH#concept-connection
資格証:~FETCH#credentials
~network区分~keyを決定する:~FETCH#determine-the-network-partition-key
~fetchする:~FETCH#concept-fetch
~network区分~key:~FETCH#network-partition-keys
接続を得する:~FETCH#concept-connection-obtain
~fetchingは，不良~portに因り阻止されるべきか？:~FETCH#block-bad-port

通達に~algoを追加する:~DOM4#abortsignal-add
aB.中止-事由:~DOM4#abortsignal-abort-reason

~BYOB読取器:~STREAMS#byob-reader
既定の読取器:~STREAMS#default-reader
限界水位:~STREAMS#high-water-mark
可読~byte~stream:~STREAMS#readable-byte-stream
RS.~closeする:~STREAMS#readablestream-close
RS.~errorにする:~STREAMS#readablestream-error
RS.~chunkを~enqueueする:~STREAMS#readablestream-enqueue
RS.~byte列から~pullする:~STREAMS#readablestream-pull-from-bytes
RS.~byte読取り~support付きで設定しておく:~STREAMS#readablestream-set-up-with-byte-reading-support
RS.現在の~BYOB要請~view:~STREAMS#readablestream-current-byob-request-view
RS.設定しておく:~STREAMS#readablestream-set-up
	.取消~algo:~STREAMS#readablestream-set-up-with-byte-reading-support-cancelalgorithm
	.~pull~algo:~STREAMS#readablestream-set-up-with-byte-reading-support-pullalgorithm
	.限界水位:~STREAMS#readablestream-set-up-highwatermark
	.~pull~algo:~STREAMS#readablestream-set-up-pullalgorithm
WS.~errorにする:~STREAMS#writablestream-error
		errored:~STREAMS#writablestream-error
WS.~closeする:~STREAMS#writablestream-close
WS.設定しておく:~STREAMS#writablestream-set-up
	.中止-~algo:~STREAMS#writablestream-set-up-abortalgorithm
	.~close~algo:~STREAMS#writablestream-set-up-closealgorithm
	.書込n~algo:~STREAMS#writablestream-set-up-writealgorithm


並列的:~HTMLINFRA#in-parallel
大域~taskを~queueする:~WAPI#queue-a-global-task
逆直列化~手続き:~HTMLcloning#deserialization-steps
aG.~event~loop:~WAPI#concept-agent-event-loop
~network用~task~source:~WAPI#networking-task-source
生成元:~ORIGIN#concept-origin
		origin:~HTMLLS/browsers.html#concept-origin
enV.生成元:~WAPI#concept-settings-object-origin
enV.施策~容器:~WAPI#concept-settings-object-policy-container
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
直列化-可能:~HTMLcloning#serializable-objects
直列化~手続き:~HTMLcloning#serialization-steps
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin
		serialized:~HTMLLS/browsers.html#ascii-serialisation-of-an-origin
転送-手続き:~HTMLcloning#transfer-steps
転送-受信-時の手続き:~HTMLcloning#transfer-receiving-steps

	
~URL構文解析する:~URL1#concept-url-parser
~URL~record:~URL1#concept-url
url.~scheme:~URL1#concept-url-scheme
url.素片:~URL1#concept-url-fragment

~UTF-8復号する:~ENCODING#utf-8-decode
~UTF-8符号化する:~ENCODING#utf-8-encode
	
要請に対する~CSP違反を報告する:~CSP3#report-for-request
要請は~CSPにより阻止されるべきか？:~CSP3#should-block-request

~UNIX~epoch:~HRTIME#dfn-unix-epoch

~capsule:~RFCx/rfc9297#name-capsules

●●ref_normative

[CSP3]
    Mike West; Antonio Sartori. ＜Content Security Policy Level 3＞. URL: https://w3c.github.io/webappsec-csp/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT-6.0]
    Allen Wirfs-Brock. ＜ECMA-262 6th Edition, The ECMAScript 2015 Language Specification＞. URL: http://www.ecma-international.org/ecma-262/6.0/index.html
[ENCODING]
    Anne van Kesteren. ＜Encoding Standard＞. Living Standard. URL: https://encoding.spec.whatwg.org/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[HR-TIME-3]
    Yoav Weiss. ＜High Resolution Time＞. URL: https://w3c.github.io/hr-time/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[PRIVACY-PRINCIPLES]
    Robin Berjon; Tonya Lee Tonya Dickard. ＜Privacy Principles＞. URL: https://w3ctag.github.io/privacy-principles/
[QUIC]
    Jana Iyengar; Martin Thomson. ＜QUIC: A UDP-Based Multiplexed and Secure Transport＞. Internet-Draft. URL: https://www.rfc-editor.org/rfc/rfc9000
[QUIC-DATAGRAM]
    Tommy Pauly; Eric Kinnear; David Schinazi. ＜An Unreliable Datagram Extension to QUIC＞. Internet-Draft. URL: https://www.rfc-editor.org/rfc/rfc9221
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[RFC3279]
    L. Bassham; W. Polk; R. Housley. ＜Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile＞. April 2002. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc3279
[RFC5280]
    D. Cooper; et al. ＜Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile＞. May 2008. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc5280
[RFC6125]
    P. Saint-Andre; J. Hodges. ＜Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)＞. March 2011. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc6125
[RFC8174]
    B. Leiba. ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174
[RFC8422]
    Y. Nir; S. Josefsson; M. Pegourie-Gonnard. ＜Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS) Versions 1.2 and Earlier＞. August 2018. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8422
[RFC9002]
    J. Iyengar, Ed.; I. Swett, Ed.. ＜QUIC Loss Detection and Congestion Control＞. May 2021. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc9002
[STREAMS]
    Adam Rice; et al. ＜Streams Standard＞. Living Standard. URL: https://streams.spec.whatwg.org/
[URL]
    Anne van Kesteren. ＜URL Standard＞. Living Standard. URL: https://url.spec.whatwg.org/
[WEB-TRANSPORT-HTTP2]
    Alan Frindell; et al. ＜WebTransport over HTTP/2＞. Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http2/
[WEB-TRANSPORT-HTTP3]
    Alan Frindell; Eric Kinnear; Victor Vasiliev. ＜WebTransport over HTTP/3＞. Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-http3/
[WEB-TRANSPORT-OVERVIEW]
    Victor Vasiliev. ＜WebTransport Protocol Framework＞. Internet-Draft. URL: https://datatracker.ietf.org/doc/html/draft-ietf-webtrans-overview
[WEBIDL]
    Edgar Chen; Timothy Gu. ＜Web IDL Standard＞. Living Standard. URL: https://webidl.spec.whatwg.org/

●●ref_informative

[RFC7301]
    S. Friedl; et al. ＜Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension＞. July 2014. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc7301
[RFC8446]
    E. Rescorla. ＜The Transport Layer Security (TLS) Protocol Version 1.3＞. August 2018. Proposed Standard. URL: https://www.rfc-editor.org/rfc/rfc8446
[UNSANCTIONED-TRACKING]
    Mark Nottingham. ＜Unsanctioned Web Tracking＞. 17 July 2015. TAG Finding. URL: http://www.w3.org/2001/tag/doc/unsanctioned-tracking/
[WEBRTC]
    Cullen Jennings; et al. ＜WebRTC: Real-Time Communication in Browsers＞. URL: https://w3c.github.io/webrtc-pc/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">WebTransport</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/webtransport/
公表履歴
	https://www.w3.org/standards/history/webtransport/
フィードバック
	<a href="mailto:public-webtransport@w3.org?subject=%5Bwebtransport%5D%20YOUR%20TOPIC%20HERE">public-webtransport@w3.org</a> with subject line “<kbd>[webtransport] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webtransport/" rel="discussion">archives</a>)
	<a href="https://github.com/w3c/webtransport/issues/">GitHub</a>

編集
	Bernard Aboba (Microsoft Corporation)
	Nidhi Jaju (Google)
	Victor Vasiliev (Google)
前任編集者
	Peter Thatcher (Google)
	Robin Raymond (Optical Tone Ltd.)
	Yutaka Hirano (Google)


commit 履歴
	https://github.com/w3c/webtransport/commits/main
公表者
	<a href="https://www.w3.org/groups/wg/webtransport">WebTransport WG</a>


</script>
</head>
<body>

<header>
	<hgroup>
<h1>WebTransport</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この文書は、［
~browser ↔ ~server
］間で~dataが［
送信される／受信される
］ことを許容するための~API【！a set of ECMAScript APIs in WebIDL】を
`WEB-TRANSPORT-HTTP3$r, `WEB-TRANSPORT-HTTP2$r
を用立てる下で定義する。
この仕様は、［
~IETF~WEBTRANS~WGにより開発された~protocol仕様
］と共に開発されている。
◎
This document defines a set of ECMAScript APIs in WebIDL to allow data to be sent and received between a browser and server, utilizing [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2]. This specification is being developed in conjunction with protocol specifications developed by the IETF WEBTRANS Working Group.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
この節では、公表~時点における…
【以下、この節の内容は，~SOTD-W3Cに移譲。】
</p>
	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
この仕様は、
`WEB-TRANSPORT-HTTP3$r,
`WEB-TRANSPORT-HTTP2$r
を利用して~dataを［
~UAから送信する／
~serverから受信する
］ための~APIを定義する。
それは，~WebSocketの様に利用できるが、
次に挙げるもの用の~supportを伴う
⇒＃
複数の~stream,
一方向~stream,
順序どおりでない送達,
~reliableな~transport【~TCP（ ~HTTP2 ）】,
~unreliableな~transport【~UDP（ ~HTTP3 ）】
◎
This specification uses [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2] to send data to and receive data from servers. It can be used like WebSockets but with support for multiple streams, unidirectional streams, out-of-order delivery, and reliable as well as unreliable transport.
</p>

<p class="note">注記：
この仕様に呈示される~APIは、
~IETF~WEBTRANS~WGの中で進捗-中の作業に基づく，準備的な提案を表現する。
その［
`WEB-TRANSPORT-HTTP3$r, `WEB-TRANSPORT-HTTP2$r
］仕様は，進捗-中の作業なので、
今後［
~protocol, ~API
］どちらも有意に変更される見込みが高い。
◎
Note: The API presented in this specification represents a preliminary proposal based on work-in-progress within the IETF WEBTRANS WG. Since the [WEB-TRANSPORT-HTTP3] and [WEB-TRANSPORT-HTTP2] specifications are a work-in-progress, both the protocol and API are likely to change significantly going forward.
</p>

	</section>
【！§ #conformance】
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="protocol-concepts">
<h2 title="Protocol concepts">3. ~protocol概念</h2>

<p>
`~WebTransport~session@
は、
~HTTP3越しの~WebTransportが成す~sessionである。
~pool法が可能化されたときは、
1 個の`接続$に複数個の`~WebTransport~session$が在り得る。
◎
A WebTransport session is a session of WebTransport over HTTP/3. There may be multiple WebTransport sessions on one connection, when pooling is enabled.
</p>

<p>
`~WebTransport~session$は、
次に挙げる能力を有する
— それらは `WEB-TRANSPORT-HTTP3$r にて定義される
【各項に挙げられる参照に後続する記述は、この訳による補完】：
◎
WebTransport session has the following capabilities defined in [WEB-TRANSPORT-HTTP3].
</p>

<div>
<dl class="def-list">
	<dt>
`~datagramを送信する@
</dt>
	<dd>
`WEB-TRANSPORT-HTTP3$r `§ ~datagram＠~WT-HTTP3#datagrams$【！4.4】
</dd>

	<dt>
`~datagramを受信する@
</dt>
	<dd>
`WEB-TRANSPORT-HTTP3$r `§ ~datagram＠~WT-HTTP3#datagrams$【！4.4】
</dd>

	<dt>
`流出~一方向~streamを作成する@
</dt>
	<dd>
`WEB-TRANSPORT-HTTP3$r `§ 一方向~stream＠~WT-HTTP3#unidirectional-streams$【！4.1】
</dd>
	<dd>
~clientが起動した`流出~一方向$な~streamを返す。
</dd>

	<dt>
`双方向~streamを作成する@
</dt>
	<dd>
`WEB-TRANSPORT-HTTP3$r `§ 双方向~stream＠~WT-HTTP3#bidirectional-streams$【！4.2】
</dd>
	<dd>
~clientが起動した`双方向$な~streamを返す。
</dd>

	<dt>
`流入~一方向~streamを受信する@
</dt>
	<dd>
`WEB-TRANSPORT-HTTP3$r `§ 一方向~stream＠~WT-HTTP3#unidirectional-streams$【！4.1】
</dd>
	<dd>
~serverから起動された`流入~一方向$な~streamを返す。
</dd>

	<dt>
`双方向~streamを受信する@
</dt>
	<dd>
`WEB-TRANSPORT-HTTP3$r `§ 双方向~stream＠~WT-HTTP3#bidirectional-streams$【！4.2】
</dd>
	<dd>
~serverから起動された`双方向$な~streamを返す。
</dd>
</dl>
◎
capability｜definition
send a datagram｜[WEB-TRANSPORT-HTTP3] Section 4.4
receive a datagram｜[WEB-TRANSPORT-HTTP3] Section 4.4
create an outgoing unidirectional stream｜[WEB-TRANSPORT-HTTP3] Section 4.1
create a bidirectional stream｜[WEB-TRANSPORT-HTTP3] Section 4.2
receive an incoming unidirectional stream｜[WEB-TRANSPORT-HTTP3] Section 4.1
receive a bidirectional stream｜[WEB-TRANSPORT-HTTP3] Section 4.2
</div>

<div class="algo">
<p>
`~WebTransport~sessionを確立する@
ときは、
所与の
( `生成元$ %生成元 )
に対し，［
`~WebTransport~session$ ／ `失敗^i
］を返す
— `WEB-TRANSPORT-HTTP3$r `§ 新たな~sessionの作成-法＠~WT-HTTP3#creating-a-new-session$【！3.3】
および次に従う下で：
</p>
<ul>
	<li>
当の要請の `Origin$h ~headerには、
次の結果を利用する
⇒
`同型に符号化する$( `生成元を直列化する$( %生成元 ) )
</li>
	<li>
~sessionを確立するときは、
~clientは，`資格証$を供さないモノトスル。
</li>
</ul>
◎
To establish a WebTransport session with an origin origin, follow [WEB-TRANSPORT-HTTP3] Section 3.3, with using origin, serialized and isomorphic encoded, as the `Origin` header of the request. When establishing a session, the client MUST NOT provide any credentials.
</div>

<div>
<p>
`~WebTransport~session$は、
次(1)または次(2) のとき，次(3) に述べられるとおり
`~draining@
【 `Draining$sl を見よ】：
</p>
<ul>
	<li>(1)
当の~sessionを起動した `CONNECT^M 要請に結付けられた~HTTP3~streamにおいて，
`DRAIN_WEBTRANSPORT_SESSION$ft `~capsule$を受信したとき
</li>
	<li>(2)
~HTTP3 `GOAWAY$ft ~frameを受信したとき
</li>
	<li>(3)
`WEB-TRANSPORT-HTTP3$r `§ ~HTTP3 GOAWAY ~frameとの相互作用＠~WT-HTTP3#interaction-with-http3-goaway-frame$【！4.6】
</li>
</ul>

◎
A WebTransport session session is draining when the HTTP/3 stream associated with the CONNECT request that initiated session receives an DRAIN_WEBTRANSPORT_SESSION capsule, or when an HTTP/3 GOAWAY frame is received, as described in [WEB-TRANSPORT-HTTP3] Section 4.6.
</div>

<div class="algo">
<p>
`~WebTransport~sessionを終了する@
ときは、
所与の
( `~WebTransport~session$, 省略可能な整数 %~code, 省略可能な`~byte列$ %事由 )
に対し，
`WEB-TRANSPORT-HTTP3$r `§ ~sessionの終了n＠~WT-HTTP3#session-termination$【！5】
に従う。
◎
To terminate a WebTransport session session with an optional integer code and an optional byte sequence reason, follow [WEB-TRANSPORT-HTTP3] Section 5.
</p>
</div>

<div>
<p>
`~WebTransport~session$は、
次(1) のとき，次(2) を伴って，次(3) に述べられるとおり
`終了され@
る
【 `§ 5.6＠#web-transport-termination$ を見よ】：
</p>
<ul>
	<li>(1)
当の~sessionを起動した `CONNECT^M 要請に結付けられた~HTTP3~streamが~serverにより~closeされた
</li>
	<li>(2)
整数 %~code,
`~byte列$ %事由
— いずれも省略可能
</li>
	<li>(3)
`WEB-TRANSPORT-HTTP3$r `§ ~sessionの終了n＠~WT-HTTP3#session-termination$【！5】
</li>
</ul>
◎
A WebTransport session session is terminated, with optionally an integer code and a byte sequence reason, when the HTTP/3 stream associated with the CONNECT request that initiated session is closed by the server, as described at [WEB-TRANSPORT-HTTP3] Section 5.
</div>

<p>
`~WebTransport~stream@
は、［
`~WebTransport~session$上の~HTTP3~stream
］用の概念である。
◎
WebTransport stream is a concept for HTTP/3 stream on a WebTransport session.
</p>

<div>
<p>
所与の`~WebTransport~stream$は、
次に挙げるいずれかになる：
</p>
<ul>
	<li>
`流入~一方向@
（ `incoming unidirectional^en ）
</li>
	<li>
`流出~一方向@
（ `outgoing unidirectional^en ）
</li>
	<li>
`双方向@
（ `bidirectional^en ）
</li>
</ul>
◎
A WebTransport stream is one of incoming unidirectional, outgoing unidirectional or bidirectional.
</div>

<p>
各`~WebTransport~stream$ %~stream は、
次に挙げる能力を有する：
◎
A WebTransport stream has the following capabilities:
</p>

<div>
<table class="_stream-capa grid-table"><thead>
<tr><th>能力
<th>定義
<th>`流入~一方向$
<th>`流出~一方向$
<th>`双方向$
<tbody>

<tr><td>
%~stream に~byte列を
`送信する@WT
（~FINを伴い得る）
<td>`QUIC$r `§ 2.2＠~RFCx/rfc9000#section-2.2$
<td>不可
<td>可
<td>可

<tr><td>
%~stream から~byte列を
`受信する@WT
（~FINを伴い得る）
<td>`QUIC$r `§ 2.2＠~RFCx/rfc9000#section-2.2$
<td>可
<td>不可
<td>可

<tr><td>
%~stream 上の
`送信を停止させる@WT
（ `STOP_SENDING$ft ）
<td>`QUIC$r `§ 3.5＠~RFCx/rfc9000#section-3.5$
<td>可
<td>不可
<td>可

<tr><td>
%~stream を
`設定し直す@WT
（ `RESET_STREAM$ft ）
<td>`QUIC$r `§ 19.4＠~RFCx/rfc9000#section-19.4$
<td>不可
<td>可
<td>可
</table>
◎
capability｜definition｜incoming unidirectional｜outgoing unidirectional｜bidirectional
send bytes (potentially with FIN)｜[QUIC] Section 2.2｜No｜Yes｜Yes
receive bytes (potentially with FIN)｜[QUIC] Section 2.2｜Yes｜No｜Yes
send STOP_SENDING｜[QUIC] Section 3.5｜Yes｜No｜Yes
reset a WebTransport stream｜[QUIC] Section 19.4｜No｜Yes｜Yes
</div>

<p>
`~WebTransport~session$には、
次に挙げる通達が生じ得る：
◎
A WebTransport session has the following signals:
</p>

<div>
<table class="_stream-capa grid-table" id="_session-capa"><thead>
<tr><th>~event
<th>定義
<tbody>

<tr><td>`DRAIN_WEBTRANSPORT_SESSION@ft
<td>`WEB-TRANSPORT-HTTP3$r `§ ~HTTP3 GOAWAY ~frameとの相互作用＠~WT-HTTP3#interaction-with-http3-goaway-frame$【！4.6】

<tr><td>`GOAWAY@ft
<td>`WEB-TRANSPORT-HTTP3$r `§ ~HTTP3 GOAWAY ~frameとの相互作用＠~WT-HTTP3#interaction-with-http3-goaway-frame$【！4.6】
</table>
◎
event｜definition
DRAIN_WEBTRANSPORT_SESSION｜[WEB-TRANSPORT-HTTP3] Section 4.6
GOAWAY｜[WEB-TRANSPORT-HTTP3] Section 4.6
</div>

<p>
`~WebTransport~session$には、
次に挙げる通達が生じ得る：
◎
A WebTransport stream has the following signals:
</p>

<div>
<table class="_stream-capa grid-table"><thead>
<tr><th>~event
<th>定義
<th>`流入~一方向$
<th>`流出~一方向$
<th>`双方向$
<tbody>

<tr><td>`STOP_SENDING@ft
<td>`QUIC$r `§ 3.5＠~RFCx/rfc9000#section-3.5$
<td>生じない
<td>生じ得る
<td>生じ得る

<tr><td>`RESET_STREAM@ft
<td>`QUIC$r `§ 19.4＠~RFCx/rfc9000#section-19.4$
<td>生じ得る
<td>生じない
<td>生じ得る

<tr><td>`~flow制御@
<td>`QUIC$r `§ 4.1＠~RFCx/rfc9000#section-4.1$
<td>生じない
<td>生じ得る
<td>生じ得る
</table>
◎
event｜definition｜incoming unidirectional｜outgoing unidirectional｜bidirectional
STOP_SENDING｜[QUIC] Section 3.5｜No｜Yes｜Yes
RESET_STREAM｜[QUIC] Section 19.4｜Yes｜No｜Yes
flow control｜[QUIC] Section 4.1｜No｜Yes｜Yes
</div>

	</section>
	<section id="duplex-stream">
<h2 title="WebTransportDatagramDuplexStream Interface">4. `WebTransportDatagramDuplexStream^I ~interface</h2>

<p>
`WebTransportDatagramDuplexStream$I は、
汎用な二重化~streamを成す。
◎
A WebTransportDatagramDuplexStream is a generic duplex stream.
</p>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransportDatagramDuplexStream@I {
  readonly attribute `ReadableStream$I `readable$mD;
  readonly attribute `WritableStream$I `writable$mD;

  readonly attribute `unsigned long$ `maxDatagramSize$mD;
  attribute `unrestricted double$ `incomingMaxAge$mD;
  attribute `unrestricted double$ `outgoingMaxAge$mD;
  attribute `unrestricted double$ `incomingHighWaterMark$mD;
  attribute `unrestricted double$ `outgoingHighWaterMark$mD;
};
</pre>

		<section id="datagramduplexstream-internal-slots">
<h3 title="Internal slots">4.1. 内部~slot</h3>

<p>
各 `WebTransportDatagramDuplexStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportDatagramDuplexStream object has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`Readable@sl</dt>
	<dd>
ある `ReadableStream$I
◎
A ReadableStream＼
</dd>
	<dd>
流入~datagram用。
◎
for incoming datagrams.
</dd>

	<dt>`Writable@sl</dt>
	<dd>
ある `WritableStream$I
◎
A WritableStream＼
</dd>
	<dd>
流出~datagram用。
◎
for outgoing datagrams.
</dd>

	<dt>`IncomingDatagramsQueue@sl</dt>
	<dd>
ある`~queue$
◎
A queue＼
</dd>
	<dd>
( 流入~datagram, 時刻印 )
が成す~pairたちからなる。
◎
of pairs of an incoming datagram and a timestamp.
</dd>

	<dt>`IncomingDatagramsPullPromise@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
`~datagram群を~pullする$により設定され，
流入~datagramを待機する。
◎
set by pullDatagrams, to wait for an incoming datagram.
</dd>

	<dt>`IncomingDatagramsHighWaterMark@sl</dt>
	<dd>
ある `unrestricted double$c
◎
An unrestricted double＼
</dd>
	<dd>
流入~datagramたちの`限界水位$を表現する。
◎
representing the high water mark of the incoming datagrams.
</dd>

	<dt>`IncomingDatagramsExpirationDuration@sl</dt>
	<dd>
ある `unrestricted double$c
◎
An unrestricted double＼
</dd>
	<dd>
流入~datagramたち用の失効n所要時間を（~milli秒数で）表現する。
◎
representing the expiration duration for incoming datagrams (in milliseconds).
</dd>

	<dt>`OutgoingDatagramsQueue@sl</dt>
	<dd>
ある`~queue$
◎
A queue＼
</dd>
	<dd>
( 流出~datagram, 時刻印, ~promise )
が成す~tupleたちからなる。
◎
of tuples of an outgoing datagram, a timestamp and a promise＼
</dd>
	<dd>
この~tupleを成す~promiseは、
~datagramが［
送信される／破棄される
］とき解決される。
◎
which is resolved when the datagram is sent or discarded.
</dd>

	<dt>`OutgoingDatagramsHighWaterMark@sl</dt>
	<dd>
ある `unrestricted double$c
◎
An unrestricted double＼
</dd>
	<dd>
流出~datagramの`限界水位$を表現する。
◎
representing the high water mark of the outgoing datagrams.
</dd>

	<dt>`OutgoingDatagramsExpirationDuration@sl</dt>
	<dd>
ある `unrestricted double$c
◎
An unrestricted double＼
</dd>
	<dd>
流出~datagram用の失効n所要時間を（~milli秒数で）表現する。
◎
value representing the expiration duration for outgoing datagrams (in milliseconds).
</dd>

	<dt>`OutgoingMaxDatagramSize@sl</dt>
	<dd>
ある整数
◎
An integer＼
</dd>
	<dd>
流出~datagram用の最大~sizeを表現する。
◎
representing the maximum size for an outgoing datagram.
</dd>
</dl>

<p>
~UAは、
所与の `WebTransport$I ~obj %~transport に対し［
%~transport . `State$sl ~IN { `connecting^l, `connected^l }
］が満たされる間は，
%~transport . `OutgoingMaxDatagramSize$sl を更新してもヨイ。
◎
The user agent MAY update [[OutgoingMaxDatagramSize]] for any WebTransport object whose [[State]] is either "connecting" or "connected".
</p>

<p>
`WebTransportDatagramDuplexStream$I を
`作成する@DPS
ときは、
所与の
( %可読~stream, %可書~stream )
に対し，次の手続きを遂行する：
◎
To create a WebTransportDatagramDuplexStream given a readable, and a writable, perform the following steps.
</p>
<ol>
	<li>
<p>
%~stream ~LET `新たな$ `WebTransportDatagramDuplexStream$I
— その
⇒＃
`Readable$sl ~SET %可読~stream,
`Writable$sl ~SET %可書~stream,
`IncomingDatagramsQueue$sl ~SET 新たな`~queue$,
`IncomingDatagramsPullPromise$sl ~SET ~NULL,
`IncomingDatagramsHighWaterMark$sl ~SET `実装定義$な値,
`IncomingDatagramsExpirationDuration$sl ~SET +∞,
`OutgoingDatagramsQueue$sl ~SET 新たな`~queue$,
`OutgoingDatagramsHighWaterMark$sl ~SET `実装定義$な値†,
`OutgoingDatagramsExpirationDuration$sl ~SET +∞,
`OutgoingMaxDatagramSize$sl ~SET `実装定義$な整数
</p>

<p class="note">注記†：
この実装定義な値は、［
まずまずの~throughputを確保する
］かつ［
伝送される~dataの適時性を危うくしない
］よう調律されるべきである。
</p>
◎
Let stream be a new WebTransportDatagramDuplexStream, with:
• [[Readable]]
•• readable
• [[Writable]]
•• writable
• [[IncomingDatagramsQueue]]
•• an empty queue
• [[IncomingDatagramsPullPromise]]
•• null
• [[IncomingDatagramsHighWaterMark]]
•• an implementation-defined value
• [[IncomingDatagramsExpirationDuration]]
•• +∞
• [[OutgoingDatagramsQueue]]
•• an empty queue
• [[OutgoingDatagramsHighWaterMark]]
•• an implementation-defined value
•• This implementation-defined value should be tuned to ensure decent throughput, without jeopardizing the timeliness of transmitted data.
• [[OutgoingDatagramsExpirationDuration]]
•• +∞
• [[OutgoingMaxDatagramSize]]
•• an implementation-defined integer.
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>

		</section>
		<section id="datagram-duplex-stream-attributes">
<h3 title="Attributes">4.2. 属性</h3>

<dl>
	<dt>
`readable@mD
◎
readable, of type ReadableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Readable$sl
◎
The getter steps are:
• Return this.[[Readable]].
</dd>

	<dt>
`writable@mD
◎
writable, of type WritableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Writable$sl
◎
The getter steps are:
• Return this.[[Writable]].
</dd>

	<dt>
`incomingMaxAge@mD
◎
incomingMaxAge, of type unrestricted double
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingDatagramsExpirationDuration$sl
◎
The getter steps are:
• Return this.[[IncomingDatagramsExpirationDuration]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~EQ 0
］
⇒
%値 ~SET +∞
◎
If value is 0, set value to +∞.
</li>
			<li>
コレ . `IncomingDatagramsExpirationDuration$sl ~SET %値
◎
Set this.[[IncomingDatagramsExpirationDuration]] to value.
</li>
		</ol>
	</dd>

	<dt>
`maxDatagramSize@mD
◎
maxDatagramSize, of type unsigned long, readonly
</dt>
	<dd>
`writable$mD に渡してもよい~dataの最大~size
◎
The maximum size data that may be passed to writable.＼
</dd>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `OutgoingMaxDatagramSize$sl
◎
The getter steps are to return this.[[OutgoingMaxDatagramSize]].
</dd>

	<dt>
`outgoingMaxAge@mD
◎
outgoingMaxAge, of type unrestricted double
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレの `OutgoingDatagramsExpirationDuration$sl
◎
The getter steps are:
• Return this's [[OutgoingDatagramsExpirationDuration]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~EQ 0
］
⇒
%値 ~SET +∞
◎
If value is 0, set value to +∞.
</li>
			<li>
コレ . `OutgoingDatagramsExpirationDuration$sl ~SET %値
◎
Set this.[[OutgoingDatagramsExpirationDuration]] to value.
</li>
		</ol>
	</dd>

	<dt>
`incomingHighWaterMark@mD
◎
incomingHighWaterMark, of type unrestricted double
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingDatagramsHighWaterMark$sl
◎
The getter steps are:
• Return this.[[IncomingDatagramsHighWaterMark]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~LT 1
］
⇒
%値 ~SET 1
◎
If value is &lt; 1, set value to 1.
</li>
			<li>
コレ . `IncomingDatagramsHighWaterMark$sl ~SET %値
◎
Set this.[[IncomingDatagramsHighWaterMark]] to value.
</li>
		</ol>
	</dd>

	<dt>
`outgoingHighWaterMark@mD
◎
outgoingHighWaterMark, of type unrestricted double
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `OutgoingDatagramsHighWaterMark$sl
◎
The getter steps are:
• Return this.[[OutgoingDatagramsHighWaterMark]].
</dd>
	<dd class="algo">
<p>
設定子~手続きは、
`所与の値$ %値 に対し：
◎
The setter steps, given value, are:
</p>
		<ol>
			<li>
~IF［
%値 ~LT 0
］~OR［
%値 ~EQ NaN
］
⇒
~THROW `RangeError$E
◎
If value is negative or NaN, throw a RangeError.
</li>
			<li>
~IF［
%値 ~LT 1
］
⇒
%値 ~SET 1
◎
If value is &lt; 1, set value to 1.
</li>
			<li>
コレ . `OutgoingDatagramsHighWaterMark$sl ~SET %値
◎
Set this.[[OutgoingDatagramsHighWaterMark]] to value.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="datagram-duplex-stream-procedures">
<h3 title="Procedures">4.3. 手続-</h3>

<div class="algo">
<p>
`~datagram群を~pullする@
ときは、
所与の
( `WebTransport$I ~obj %~transport )
に対し，次の手続きを走らす：
◎
To pullDatagrams, given a WebTransport object transport, run these steps:
</p>
<ol>
	<li>
%~datagram群 ~LET %~transport . `Datagrams$sl
◎
Let datagrams be transport.[[Datagrams]].
</li>
	<li>
~Assert：
%~datagram群 . `IncomingDatagramsPullPromise$sl ~EQ ~NULL
◎
Assert: datagrams.[[IncomingDatagramsPullPromise]] is null.
</li>
	<li>
%~queue ~LET %~datagram群 . `IncomingDatagramsQueue$sl
◎
Let queue be datagrams.[[IncomingDatagramsQueue]].
</li>
	<li>
<p>
~IF［
%~queue は空である
］：
◎
If queue is empty, then:
</p>
		<ol>
			<li>
%~datagram群 . `IncomingDatagramsPullPromise$sl ~SET `新たな~promise$
◎
Set datagrams.[[IncomingDatagramsPullPromise]] to a new promise.
</li>
			<li>
~RET %~datagram群 . `IncomingDatagramsPullPromise$sl
◎
Return datagrams.[[IncomingDatagramsPullPromise]].
</li>
		</ol>
	</li>
	<li>
( %~datagram, %時刻印 ) ~LET %~queue から`~dequeueする$
◎
Let datagram and timestamp be the result of dequeuing queue.
</li>
	<li>
%~view ~LET %~datagram群 . `Readable$sl 用の`現在の~BYOB要請~view$RS
◎
↓</li>
	<li>
<p>
~IF［
%~view ~NEQ ~NULL
］：
◎
If datagrams.[[Readable]]'s current BYOB request view is not null, then:
</p>
		<ol>
			<li>
~IF［
%~view の`~byte長さ$BS ~LT %~datagram の~size
］
⇒
~RET `却下される~promise$( `RangeError$E )
◎
Let view be datagrams.[[Readable]]'s current BYOB request view.
◎
If view’s byte length is less than the size of datagram, return a promise rejected with a RangeError.
</li>
			<li>
%要素~size ~LET 0
◎
↓</li>
			<li>
~IF［
%~view は `TypedArrayName^sl 内部~slotを有する
（すなわち， %~view は `DataView$I でない）
］
⇒
`有型~配列~構築子~表t＠~ECMA262#table-49$にて指定される［
%~view . `TypedArrayName^sl
］用の要素~size
◎
Let elementSize be the element size specified in the typed array constructors table for view.[[TypedArrayName]]. If view does not have a [[TypedArrayName]] internal slot (i.e. it is a DataView), let elementSize be 0.
</li>
	<li>
~IF［
%要素~size ~NEQ 1
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If elementSize is not 1, return a promise rejected with a TypeError.
</li>
		</ol>
	</li>
	<li>
%~datagram群 . `Readable$sl の中へ`~byte列から~pullする$RS( %~datagram )
◎
Pull from bytes datagram into datagrams.[[Readable]].
</li>
	<li>
~RET `解決される~promise$( `undefined^jv )
◎
Return a promise resolved with undefined.
</li>
</ol>
</div>

<div class="algo">
<p>
`~datagram群を受信する@
ときは、
所与の
( `WebTransport$I ~obj %~transport )
に対し，次の手続きを走らす：
◎
To receiveDatagrams, given a WebTransport object transport, run these steps:
</p>
<ol>
	<li>
%時刻印 ~LET 今を表現している時刻印
◎
Let timestamp be a timestamp representing now.
</li>
	<li>
%~queue ~LET %~datagram群 . `IncomingDatagramsQueue$sl
◎
Let queue be datagrams.[[IncomingDatagramsQueue]].
</li>
	<li>
%所要時間 ~LET %~datagram群 . `IncomingDatagramsExpirationDuration$sl
◎
Let duration be datagrams.[[IncomingDatagramsExpirationDuration]].
</li>
	<li>
~IF［
%所要時間 ~EQ ~NULL
］
⇒
%所要時間 ~SET `実装定義$な値
◎
If duration is null, then set duration to an implementation-defined value.
</li>
	<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
	<li>
<p>
~WHILE［
%~session 上に可用な流入~datagramは在る
【！`~datagramを受信する$】
］：
◎
While there are available incoming datagrams on session:
</p>
		<ol>
			<li>
%~datagram ~LET `~datagramを受信する$( %~session )
◎
Let datagram be the result of receiving a datagram with session.
</li>
			<li>
%~chunk ~LET ( %~datagram, 今を表現している時刻印 ) が成す~pair
◎
Let timestamp be a timestamp representing now.
◎
Let chunk be a pair of datagram and timestamp.
</li>
			<li>
%~queue に %~chunk を`~enqueueする$
◎
Enqueue chunk to queue.
</li>
		</ol>
	</li>
	<li>
%除去する個数 ~LET %~queue の`~size$【！長さ】 ~MINUS %~datagram群 . `IncomingDatagramsHighWaterMark$sl
◎
Let toBeRemoved be the length of queue minus datagrams.[[IncomingDatagramsHighWaterMark]].
</li>
	<li>
~WHILE［
%除去する個数 ~GTE 1
【！rounded down＠https://tc39.github.io/ecma262/#eqn-floor$ 】
］
⇒＃
%~queue から`~dequeueする$；
%除去する個数 ~DECBY 1
◎
If toBeRemoved is positive, repeat dequeuing queue toBeRemoved (rounded down) times.
</li>
	<li>
<p>
~WHILE［
%~queue は空でない
］：
◎
While queue is not empty:
</p>
		<ol>
			<li>
~IF［
~milli秒数による［
今を表現している時刻印 ~MINUS %~queue[ 0 ][ 1 ]
］ ~LTE %所要時間
］
⇒
~BREAK
◎
Let bytes and timestamp be queue’s first element.
◎
If more than duration milliseconds have passed since timestamp, then dequeue queue.
◎
Otherwise, break this loop.
</li>
			<li>
%~queue から`~dequeueする$
◎
↑</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~queue は空でない
］~AND［
%~datagram群 . `IncomingDatagramsPullPromise$sl ~NEQ ~NULL
］：
◎
If queue is not empty and datagrams.[[IncomingDatagramsPullPromise]] is non-null, then:
</p>
		<ol>
			<li>
( %~byte列, %時刻印 ) ~LET %~queue から`~dequeueする$
◎
Let bytes and timestamp be the result of dequeuing queue.
</li>
			<li>
%~promise ~LET %~datagram群 . `IncomingDatagramsPullPromise$sl
◎
Let promise be datagrams.[[IncomingDatagramsPullPromise]].
</li>
			<li>
%~datagram群 . `IncomingDatagramsPullPromise$sl ~SET ~NULL
◎
Set datagrams.[[IncomingDatagramsPullPromise]] to null.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
				<ol>
					<li>
%~chunk ~LET %~byte列 を表現している新たな `Uint8Array$I ~obj
◎
Let chunk be a new Uint8Array object representing bytes.
</li>
					<li>
%~datagram群 . `Readable$sl に`~chunkを~enqueueする$RS( %~chunk )
◎
Enqueue chunk to datagrams.[[Readable]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは、
次に従うベキである
⇒
`WebTransport$I ~objが［
その `State$sl ~EQ `connected^l
］を満たす間は
⇒
`~datagram群を受信する$
~algoが進捗を為せるようになったときには、
アリな限り適度に早く，それを走らす
◎
The user agent SHOULD run receiveDatagrams for any WebTransport object whose [[State]] is "connected" as soon as reasonably possible whenever the algorithm can make progress.
</p>

<div class="algo">
<p>
`~datagram群を書込む@
~algoは、
所与の
( `WebTransport$I ~obj %~transport, %~data )
に対し：
◎
The writeDatagrams algorithm is given a transport as parameter and data as input. It is defined by running the following steps:
</p>
<ol>
	<li>
%時刻印 ~LET 今を表現している時刻印
◎
Let timestamp be a timestamp representing now.
</li>
	<li>
~IF［
%~data は `BufferSource$I ~objでない
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If data is not a BufferSource object, then return a promise rejected with a TypeError.
</li>
	<li>
%~datagram群 ~LET %~transport . `Datagrams$sl
◎
Let datagrams be transport.[[Datagrams]].
</li>
	<li>
~IF［
%~datagram群 . `OutgoingMaxDatagramSize$sl ~LT %~data . `ByteLength^sl
］
⇒
~RET `解決される~promise$( `undefined^jv )
◎
If datagrams.[[OutgoingMaxDatagramSize]] is less than data’s [[ByteLength]], return a promise resolved with undefined.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~byte列 ~LET %~data に`保持された~byte列の複製を取得する$
◎
Let bytes be a copy of bytes which data represents.
</li>
	<li>
%~chunk ~LET 
( %~byte列, %時刻印, %~promise )
が成す~tuple
◎
Let chunk be a tuple of bytes, timestamp and promise.
</li>
	<li>
%~datagram群 . `OutgoingDatagramsQueue$sl に %~chunk を`~enqueueする$
◎
Enqueue chunk to datagrams.[[OutgoingDatagramsQueue]].
</li>
	<li>
~IF［
%~datagram群 . `OutgoingDatagramsQueue$sl の`~size$【！長さ】 ~LT %~datagram群 . `OutgoingDatagramsHighWaterMark$sl
］
⇒
`~promiseを解決する$( %~promise )
◎
If the length of datagrams.[[OutgoingDatagramsQueue]] is less than datagrams.[[OutgoingDatagramsHighWaterMark]], then resolve promise with undefined.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

<p class="note">注記：
結付けられた `WritableStream$I
【すなわち %~datagram群 . `Writable$sl 】は、［
`~datagram群を書込む$から返されたすべての~promise
］が解決されたときに限り，`~datagram群を書込む$を~callする。
よって，［
時刻印, 失効n所要時間
］がきちんと働くのは、
~web開発者が `WritableStreamDefaultWriter.ready$c に気を配るときに限られる。
◎
Note: The associated WritableStream calls writeDatagrams only when all the promises that have been returned by writeDatagrams have been resolved. Hence the timestamp and the expiration duration work well only when the web developer pays attention to WritableStreamDefaultWriter.ready.
</p>
</div>

<div class="algo">
<p>
`~datagram群を送信する@
ときは、
所与の
( `WebTransport$I ~obj %~transport )
に対し，次の手続きを走らす：
◎
To sendDatagrams, given a WebTransport object transport, run these steps:
</p>
<ol>
	<li>
%~queue ~LET %~datagram群 . `OutgoingDatagramsQueue$sl
◎
Let queue be datagrams.[[OutgoingDatagramsQueue]].
</li>
	<li>
%所要時間 ~LET %~datagram群 . `OutgoingDatagramsExpirationDuration$sl
◎
Let duration be datagrams.[[OutgoingDatagramsExpirationDuration]].
</li>
	<li>
~IF［
%所要時間 ~EQ ~NULL
］
⇒
%所要時間 ~SET `実装定義$な値
◎
If duration is null, then set duration to an implementation-defined value.
</li>
	<li>
<p>
~WHILE［
%~queue は空でない
］：
</p>
		<ol>
			<li>
<p>
~IF［
~milli秒数による［
今を表現している時刻印 ~MINUS %~queue[ 0 ][ 1 ]
］ ~LTE %所要時間
］
⇒
~BREAK
</li>
			<li>
%~queue から`~dequeueする$【！Remove the first element】
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
</p>
<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
</div>
			</li>
		</ol>
◎
While queue is not empty:
• Let bytes, timestamp and promise be queue’s first element.
• If more than duration milliseconds have passed since timestamp, then:
•• Remove the first element from queue.
•• Queue a network task with transport to resolve promise with undefined.
• Otherwise, break this loop.
</li>
	<li>
~IF［
%~transport . `State$sl ~NEQ `connected^l
］
⇒
~RET
◎
If transport.[[State]] is not "connected", then return.
</li>
	<li>
%最大-~size ~LET %~datagram群 . `OutgoingMaxDatagramSize$sl
◎
Let maxSize be datagrams.[[OutgoingMaxDatagramSize]].
</li>
	<li>
<p>
~WHILE［
%~queue は空でない
］：
◎
While queue is not empty:
</p>
		<ol>
			<li>
( %~byte列, %時刻印, %~promise ) ~LET %~queue[ 0 ]【！’s first element】
◎
Let bytes, timestamp and promise be queue’s first element.
</li>
			<li>
<p>
~IF［
%~byte列 の長さ ~LTE %最大-~size
］：
◎
If bytes’s length ≤ maxSize:
</p>
				<ol>
					<li>
~IF［
%~byte列 を~networkへ即時に送信することはアリでない
］
⇒
~BREAK
◎
If it is not possible to send bytes to the network immediately, then break this loop.
</li>
					<li>
`~datagramを送信する$( %~transport . `Session$sl, %~byte列 )
◎
Send a datagram, with transport.[[Session]] and bytes.
</li>
				</ol>
			</li>
			<li>
%~queue から`~dequeueする$【！Remove the first element】
◎
Remove the first element from queue.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
◎
resolve promise with undefined.
</div>
			</li>
		</ol>
	</li>
</ol>
</div>

<p>
~UAは、
次に従うベキである
⇒
`WebTransport$I ~objが［
その `State$sl ~IN { `connecting^l, `connected^l }
］を満たす間は
⇒
`~datagram群を送信する$
~algoが進捗を為せるようになったときには、
アリな限り適度に早く，それを走らす
◎
The user agent SHOULD run sendDatagrams for any WebTransport object whose [[State]] is "connecting" or "connected" as soon as reasonably possible whenever the algorithm can make progress.
</p>

<div class="note">
<p>注記：
［
%~transport . `State$sl ~EQ `connecting^l
］が満たされる間でも，~datagram群を書込むことは許容される。
書込まれた~datagram群は：
</p>
<ul>
	<li>
【%~transport . `Datagrams$sl . 】
`OutgoingDatagramsExpirationDuration$sl 内に格納される
</li>
	<li>
`connected^l の事例と同じ方式で破棄され得る／できる。
</li>
	<li>
［
%~transport . `State$sl ~EQ `connected^l
］になったとき、
送信を開始することになる。
</li>
</ul>
◎
Note: Writing datagrams while the transport’s [[State]] is "connecting" is allowed. The datagrams are stored in [[OutgoingDatagramsExpirationDuration]], and they can be discarded in the same manner as the "connected" case. Once the transport’s [[State]] becomes "connected", it will start sending stored datagrams.
</div>

		</section>
	</section>
	<section id="web-transport">
<h2 title="WebTransport Interface">5. `WebTransport^I ~interface</h2>

<p>
`WebTransport^I は、［
`WEB-TRANSPORT-HTTP3$r にて定義される~HTTP3~transport機能性
］への~APIを供する。
◎
WebTransport provides an API to the HTTP/3 transport functionality defined in [WEB-TRANSPORT-HTTP3].
</p>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransport@I {
  `constructor＠#dom-webtransport-webtransport$(`USVString$ %url, optional `WebTransportOptions$I %options = {});

  `Promise$&lt;`WebTransportStats$I&gt; `getStats$mT();
  readonly attribute `Promise$&lt;`undefined$&gt; `ready$mT;
  readonly attribute `WebTransportReliabilityMode$I `reliability$mT;
  readonly attribute `WebTransportCongestionControl$I `congestionControl$mT;
  readonly attribute `Promise$&lt;`WebTransportCloseInfo$I&gt; `closed$mT;
  readonly attribute `Promise$&lt;`undefined$&gt; `draining$mT;
  `undefined$ `close$mT(optional `WebTransportCloseInfo$I %closeInfo = {});

  readonly attribute `WebTransportDatagramDuplexStream$I `datagrams$mT;

  `Promise$&lt;`WebTransportBidirectionalStream$I&gt; `createBidirectionalStream$mT(
      optional `WebTransportSendStreamOptions$I %options = {});
  /* <span class="comment">
`WebTransportBidirectionalStream$I ~objの `ReadableStream$I
◎
a ReadableStream of WebTransportBidirectionalStream objects
</span> */
  readonly attribute `ReadableStream$I `incomingBidirectionalStreams$mT;

  `Promise$&lt;`WebTransportSendStream$I&gt; `createUnidirectionalStream$mT(
      optional `WebTransportSendStreamOptions$I %options = {});
  /* <span class="comment">
`WebTransportReceiveStream$I ~objの `ReadableStream$I
◎
a ReadableStream of WebTransportReceiveStream objects
</span> */
  readonly attribute `ReadableStream$I `incomingUnidirectionalStreams$mT;
};

enum `WebTransportReliabilityMode@I {
  `pending@l,
  `reliable-only@l,
  `supports-unreliable@l,
};
</pre>

		<section id="webtransport-internal-slots">
<h3 title="Internal slots">5.1. 内部~slot</h3>

<p>
各 `WebTransport$I %~transport は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransport object has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`SendStreams@sl</dt>
	<dd>
`有順序~集合$
◎
An ordered set＼
</dd>
	<dd>
%~transport に所有されている `WebTransportSendStream$I たちからなる
◎
An ordered set of WebTransportSendStreams owned by this WebTransport.
</dd>

	<dt>`ReceiveStreams@sl</dt>
	<dd>
`有順序~集合$
◎
An ordered set＼
</dd>
	<dd>
%~transport に所有されている `WebTransportReceiveStream$I たちからなる
◎
of WebTransportReceiveStreams owned by this WebTransport.
</dd>

	<dt>`IncomingBidirectionalStreams@sl</dt>
	<dd>
ある `ReadableStream$I
◎
A ReadableStream＼
</dd>
	<dd>
~serverから受信した `WebTransportBidirectionalStream$I たちからなる†
◎
consisting of WebTransportBidirectionalStream objects.
</dd>

	<dt>`IncomingUnidirectionalStreams@sl</dt>
	<dd>
ある `ReadableStream$I
◎
A ReadableStream＼
</dd>
	<dd>
~serverから受信した一方向~streamを表現する `WebTransportReceiveStream$I たちからなる†
◎
consisting of WebTransportReceiveStreams.
</dd>
	<dd class="trans-note">【†
“からなる（ `consisting of^en ）”
とは、
これら各~objが `ReadableStream$I に~chunkとして~enqueueされることを意味する（次節）。
】</dd>

	<dt>`State@sl</dt>
	<dd>
%~transport の状態を指示する
— 次に挙げるいずれかとして
⇒＃
`connecting^l,
`connected^l,
`draining^l,
`closed^l,
`failed^l
◎
An enum indicating the state of the transport. One of "connecting", "connected", "draining", "closed", and "failed".
</dd>

	<dt>`Ready@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
`~WebTransport~sessionを確立する$ことに
⇒＃
成功したとき充足される／
失敗したとき却下される
◎
fulfilled when the associated WebTransport session gets established, or rejected if the establishment process failed.
</dd>

	<dt>`Reliability@sl</dt>
	<dd>
ある `WebTransportReliabilityMode$I
◎
A WebTransportReliabilityMode＼
</dd>
	<dd>
接続が確立されるまでは `pending$l を返す。
それ以降は、
接続が［
~unreliable（~UDP越し）~transportを~supportするならば `supports-unreliable$l ／
~reliable（~fallbackによる~TCP越し）~transportしか~supportしないならば `reliable-only$l
］を返す。
◎
indicating whether the first hop supports unreliable (UDP) transport or whether only reliable (TCP fallback) transport is available.＼
◎
Returns "pending" until a connection has been established.
</dd>

	<dt>`CongestionControl@sl</dt>
	<dd>
ある `WebTransportCongestionControl$I
◎
A WebTransportCongestionControl＼
</dd>
	<dd>
応用により［
~throughput／短い待時間
］用に最適化された輻輳~制御~algoが要請され，~UAにより満足されたならば、
その選好を
【 `throughput$l ／ `low-latency$l として】
指示する。
他の場合は `default$l になる。
◎
indicating whether a preference for a congestion control algorithm optimized for throughput or low latency was requested by the application and satisfied by the user agent, or "default".
</dd>

	<dt>`Closed@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
%~transport が
⇒＃
上品に~closeされたとき充足される／
中途で~closeされたとき却下される／
初期化に失敗したとき却下される
◎
fulfilled when the associated WebTransport object is closed gracefully, or rejected when it is closed abruptly or failed on initialization.
</dd>

	<dt>`Draining@sl</dt>
	<dd>
ある~promise
◎
A promise＼
</dd>
	<dd>
%~transport が［
`DRAIN_WEBTRANSPORT_SESSION$ft `~capsule$ ／
`GOAWAY$ft ~frame
］を受信したとき充足される。
◎
fulfilled when the associated WebTransport session receives a DRAIN_WEBTRANSPORT_SESSION capsule or a GOAWAY frame.
</dd>

	<dt>`Datagrams@sl</dt>
	<dd>
ある `WebTransportDatagramDuplexStream$I
◎
A WebTransportDatagramDuplexStream.
</dd>
	<dd>
この~session越しに~datagram群を［
送信する／受信する
］ための単独の二重化~stream。
◎
↓↓</dd>

	<dt>`Session@sl</dt>
	<dd>
~NULL ／
%~transport 用の`~WebTransport~session$
◎
A WebTransport session for this WebTransport object, or null.
</dd>
</dl>

		</section>
		<section id="webtransport-constructor">
<h3 title="Constructor">5.2. 構築子</h3>

<div class="algo">
<p>
`new WebTransport(url, options)@m
構築子手続きは：
◎
When the WebTransport() constructor is invoked, the user agent MUST run the following steps:
</p>
<ol>
	<li>
%構文解析した~URL ~LET `~URL構文解析する$( %url )
◎
Let parsedURL be the URL record resulting from parsing url.
</li>
	<li>
~IF［
%構文解析した~URL ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL is a failure, throw a SyntaxError exception.
</li>
	<li>
~IF［
%構文解析した~URL の`~scheme$url ~NEQ `https^l
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL scheme is not https, throw a SyntaxError exception.
</li>
	<li>
~IF［
%構文解析した~URL の`素片$url  ~NEQ ~NULL,
］
⇒
~THROW `SyntaxError$E
◎
If parsedURL fragment is not null, throw a SyntaxError exception.
</li>
	<li>
%専用か ~LET %options[ "`allowPooling$mb" ] に応じて
⇒＃
~F ならば ~T ／
~T ならば ~F
◎
Let allowPooling be options's allowPooling.
◎
Let dedicated be the negation of allowPooling.
</li>
	<li>
%~server証明書~hash群 ~LET %options[ "`serverCertificateHashes$mb" ]
◎
Let serverCertificateHashes be options's serverCertificateHashes if it exists, and null otherwise.
</li>
	<li>
~IF［
%~server証明書~hash群 ~EQ ε
］
⇒
%~server証明書~hash群 ~SET ~NULL
◎
↑</li>
	<li>
~IF［
%専用か ~EQ ~F
］~AND［
%~server証明書~hash群 ~NEQ ~NULL
］
⇒
~THROW `NotSupportedError$E
◎
If dedicated is false and serverCertificateHashes is non-null, then throw a NotSupportedError exception.
</li>
	<li>
%~unreliableは要求されるか ~LET %options[ "`requireUnreliable$mb" ]
◎
Let requireUnreliable be options's requireUnreliable.
</li>
	<li>
%輻輳~制御 ~LET %options[ "`congestionControl$mb" ]
◎
Let congestionControl be options's congestionControl.
</li>
	<li>
~IF［
%輻輳~制御 ~NEQ `default^l
］~AND［［
%輻輳~制御 用に最適化するための輻輳~制御~algo
］として［
`RFC9002$r `§ 7＠~RFCx/rfc9002#section-7$ により許容されるもの
］のうち［
~UAが~supportするもの
］は無い
］
⇒
%輻輳~制御 ~SET `default^l
◎
If congestionControl is not "default", and the user agent does not support any congestion control algorithms that optimize for congestionControl, as allowed by [RFC9002] Section 7, then set congestionControl to "default".
</li>
	<li>
%流入~datagram群 ~LET `新たな$ `ReadableStream$I
◎
Let incomingDatagrams be a new ReadableStream.
</li>
	<li>
%流出~datagram群 ~LET `新たな$ `WritableStream$I
◎
Let outgoingDatagrams be a new WritableStream.
</li>
	<li>
%~datagram群 ~LET `WebTransportDatagramDuplexStream$I を`作成する$DPS( %流入~datagram群, %流出~datagram群 )
◎
Let datagrams be the result of creating a WebTransportDatagramDuplexStream, its readable set to incomingDatagrams and its writable set to outgoingDatagrams.
</li>
	<li>
%~transport ~LET `新たな$ `WebTransport$I ~obj
— その
⇒＃
`SendStreams$sl ~SET 新たな`有順序~集合$,
`ReceiveStreams$sl ~SET 新たな`有順序~集合$,
`IncomingBidirectionalStreams$sl ~SET `新たな$ `ReadableStream$I,
`IncomingUnidirectionalStreams$sl ~SET `新たな$ `ReadableStream$I,
`State$sl ~SET `connecting^l,
`Ready$sl ~SET `新たな~promise$,
`Reliability$sl ~SET `pending^l,
`CongestionControl$sl ~SET %輻輳~制御,
`Closed$sl ~SET `新たな~promise$,
`Draining$sl ~SET `新たな~promise$,
`Datagrams$sl ~SET %~datagram群,
`Session$sl ~SET ~NULL
◎
Let transport be a newly constructed WebTransport object, with:
• [[SendStreams]]
•• an empty ordered set
• [[ReceiveStreams]]
•• an empty ordered set
• [[IncomingBidirectionalStreams]]
•• a new ReadableStream
• [[IncomingUnidirectionalStreams]]
•• a new ReadableStream
• [[State]]
•• "connecting"
• [[Ready]]
•• a new promise
• [[Reliability]]
•• "pending"
• [[CongestionControl]]
•• congestionControl
• [[Closed]]
•• a new promise
• [[Draining]]
•• a new promise
• [[Datagrams]]
•• datagrams
• [[Session]]
•• null
</li>
	<li>
<p>
%流入~datagram群 を`~byte読取り~support付きで設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET 次を走らす動作
⇒
`~datagram群を~pullする$( %~transport )
</li>
			<li>
`限界水位^i ~SET 0
</li>
		</ul>
◎
↓</li>
	<li>
<p>
%流出~datagram群 を`設定しておく$WS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`書込n~algo^i ~SET 
【所与の ( %~data ) に対し，】
次を走らす動作
⇒
`~datagram群を書込む$( %~transport【, %~data】 )
</li>
		</ul>

<p class="note">注記：
各~datagramには 64kB ~bufferを利用することが推奨される
— ［
~WebTransportにおける~datagramの実質的な最大~frame~size
］には，上界として［
~QUICにおける~datagramの最大~frame~size
］があり、
それには 64kB が推奨されるので
（ `QUIC-DATAGRAM$r `§ 3＠~RFCx/rfc9221#section-3$
を見よ）。
これは、［
ある~datagramが~bufferより大きいことに因り，当の~streamが~errorする
］ことは生じないことを確保する。
</p>

◎
Let pullDatagramsAlgorithm be an action that runs pullDatagrams with transport.
◎
Let writeDatagramsAlgorithm be an action that runs writeDatagrams with transport.
◎
Note: Using 64kB buffers with datagrams is recommended because the effective maximum WebTransport datagram frame size has an upper bound of the QUIC maximum datagram frame size which is recommended to be 64kB (See [QUIC-DATAGRAM] Section 3). This will ensure the stream is not errored due to a datagram being larger than the buffer.
◎
Set up with byte reading support incomingDatagrams with pullAlgorithm set to pullDatagramsAlgorithm, and highWaterMark set to 0.
◎
Set up outgoingDatagrams with writeAlgorithm set to writeDatagramsAlgorithm.
</li>
	<li>
<p>
%~transport . `IncomingBidirectionalStreams$sl を`設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET 次を走らす動作
⇒
`双方向~streamを~pullする$( %~transport )
</li>
			<li>
`限界水位^i ~SET 0
</li>
		</ul>
◎
Let pullBidirectionalStreamAlgorithm be an action that runs pullBidirectionalStream with transport.
◎
Set up transport.[[IncomingBidirectionalStreams]] with pullAlgorithm set to pullBidirectionalStreamAlgorithm, and highWaterMark set to 0.
</li>
	<li>
<p>
%~transport . `IncomingUnidirectionalStreams$sl を`設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET 次を走らす動作
⇒
`一方向~streamを~pullする$( %~transport )
</li>
			<li>
`限界水位^i ~SET 0
</li>
		</ul>
◎
Let pullUnidirectionalStreamAlgorithm be an action that runs pullUnidirectionalStream with transport.
◎
Set up transport.[[IncomingUnidirectionalStreams]] with pullAlgorithm set to pullUnidirectionalStreamAlgorithm, and highWaterMark set to 0.
</li>
	<li>
`~HTTP越しの~WebTransportを初期化する$( ↓ )
⇒＃
%~transport,
%構文解析した~URL,
%専用か,
%~unreliableは要求されるか,
%輻輳~制御,
%~server証明書~hash群
◎
Initialize WebTransport over HTTP with transport, parsedURL, dedicated, requireUnreliable, congestionControl, and serverCertificateHashes.
</li>
	<li>
~RET %~transport
◎
Return transport.
</li>
</ol>
</div>

<div class="algo">
<p>
`~HTTP越しの~WebTransportを初期化する@
ときは、
所与の
⇒＃
`WebTransport$I ~obj %~transport,
`~URL~record$ %~URL,
真偽値 %専用か,
真偽値 %~HTTP3に限るか,
`WebTransportCongestionControl$I %輻輳~制御,
`WebTransportHash$I たちが成す連列 %~server証明書~hash群
◎終
に対し，
次の手続きを走らす：
◎
To initialize WebTransport over HTTP, given a WebTransport object transport, a URL record url, a boolean dedicated, a boolean http3Only, a WebTransportCongestionControl congestionControl, and a sequence&lt;WebTransportHash&gt; serverCertificateHashes, run these steps.
</p>
<ol>
	<li>
%~client ~LET %~transport に`関連な設定群~obj$
◎
Let client be transport’s relevant settings object.
</li>
	<li>
%生成元 ~LET %~client の`生成元$enV
◎
Let origin be client’s origin.
</li>
	<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET %~client,
`施策~容器$rq ~SET %~client の`施策~容器$enV,
`行先$rq ~SET 空~文字列,
`生成元$rq ~SET %生成元
◎
Let request be a new request whose URL is url, client is client, policy container is client’s policy container, destination is an empty string, and origin is origin.
</li>
	<li>
`要請に対する~CSP違反を報告する$( %要請 )
◎
Run report Content Security Policy violations for request.
</li>
	<li>
<p>
~IF［
`要請は~CSPにより阻止されるべきか？$( %要請 ) ~EQ `阻止される^i
］~OR［
`~fetchingは，不良~portに因り阻止されるべきか？$( %要請 ) ~EQ `阻止される^i
］：
◎
If should request be blocked by Content Security Policy? with request returns "Blocked", or if request should be blocked due to a bad port returns blocked, then abort the remaining steps and＼
</p>
		<ol>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
					<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
					<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
				</ol>
</div>
			</li>
			<li>
~RET
◎
↑↑</li>
		</ol>
	</li>
	<li>
%~network区分~key ~LET `~network区分~keyを決定する$( %~transport に`関連な設定群~obj$ )
◎
Let networkPartitionKey be the result of determining the network partition key with transport’s relevant settings object.
</li>
	<li class="algo">
<p>
この段は、
`並列的$に走らすことに加え：
◎
Run the following steps in parallel,＼
</p>
		<ul>
			<li>
次が満たされた`ときは中止する$
⇒
%~transport . `State$sl ~IN { `closed^l, `failed^l }
◎
but abort when transport.[[State]] becomes "closed" or "failed":
</li>
		</ul>
		<ol>
			<li>
%新たな接続 ~LET %専用か に応じて
⇒＃
~F ならば `no^l／
~T ならば `yes-and-dedicated^l
◎
Let newConnection be "no" if dedicated is false; otherwise "yes-and-dedicated".
</li>
			<li>
<p>
%接続 ~LET `接続を得する$( ↓ )
⇒＃
%~network区分~key,
%~URL,
~F,
%新たな接続,
%~HTTP3に限るか
◎
Let connection be the result of obtaining a connection with networkPartitionKey, url, false, newConnection, and http3Only.＼
</p>
<div>
<p>
— 次に従う下で：
</p>
				<ul>
					<li>
~UAは，複数の輻輳~制御~algoを~supportする場合、［
この %接続 上に~dataを送信するためとして，
%輻輳~制御 用に適切なもの
］を選ぶ。
</li>
					<li>
<p>
%~server証明書~hash群 が指定された【空でない】場合：
</p>
						<ul>
							<li>
接続を得するときは，証明書は
— 既定の証明書~検証y~algoを利用する代わりに —
次を満たす場合に妥当であるものと見なす
⇒
［
`~custom証明書~要件$を満たす
］~AND［
`証明書~hashを検証yする$( %~server証明書~hash群 ) の結果 ~EQ ~T
］
</li>
							<li>
前項の条件が満たされない場合
⇒
%接続 ~SET `失敗^i
</li>
						</ul>
					</li>
				</ul>
◎
If the user agent supports more than one congestion control algorithm, choose one appropriate for congestionControl for sending of data on this connection. When obtaining a connection, if serverCertificateHashes is specified, instead of using the default certificate verification algorithm, consider the certificate valid if it meets the custom certificate requirements and if verifying the certificate hash against serverCertificateHashes returns true. If either condition is not met, let connection be failure.
</div>

			</li>
			<li>
<p>
~IF［
%接続 ~EQ `失敗^i
］：
◎
If connection is failure, then abort the remaining steps and＼
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
							<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
							<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
↑↑</li>
				</ol>
			</li>
			<li>
%接続 から最初の `SETTINGS$ft ~frameを受信するまで待機する
◎
Wait for connection to receive the first SETTINGS frame,＼
</li>
			<li>
%設定群 ~LET 前~段の `SETTINGS$ft ~frameを表現する辞書
◎
and let settings be a dictionary that represents the SETTINGS frame.
</li>
			<li>
<p>
~IF［
%設定群 [ "`SETTINGS_ENABLE_WEBTRANPORT^sp" ] ~NEQ 1
］~OR［
%設定群 [ "`H3_DATAGRAM^sp" ] ~NEQ 1
］：
◎
If settings doesn’t contain SETTINGS_ENABLE_WEBTRANPORT with a value of 1, or it doesn’t contain H3_DATAGRAM with a value of 1, then abort the remaining steps and＼
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
							<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
							<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
↑↑</li>
				</ol>
			</li>
			<li>
<p>
%~session ~LET `~WebTransport~sessionを確立する$( %生成元, %接続 )
◎
Establish a WebTransport session with origin on connection.
</p>

<p class="note">注記：
この段は、［
`QUIC-DATAGRAM$r にて指定される，~transport~parameterの交換
］も包含する。
◎
Note: This step also contains the transport parameter exchange specified in [QUIC-DATAGRAM].
</p>
			</li>
			<li>
<p>
~IF［
%~session ~EQ `失敗^i
］：
◎
If the previous step fails, abort the remaining steps and＼
</p>
				<ol>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
							<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
							<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
						</ol>
</div>
					</li>
					<li>
~RET
◎
↑↑</li>
				</ol>
			</li>
			<li>
~Assert：
%maxDatagramSize は整数である。
【未定義な変数。前後との関係が不明で意図不明な段。】
◎
↑↑ Let session be the established WebTransport session.
◎
Assert: maxDatagramSize is an integer.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>

<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
<p>
~IF［
%~transport . `State$sl ~NEQ `connecting^l
］：
◎
If transport.[[State]] is not "connecting":
</p>
						<ol>
							<li class="algo">
この段は`並列的$に走らす
⇒
`~WebTransport~sessionを終了する$( %~session )
◎
In parallel, terminate session.
</li>
							<li>
~RET
◎
Abort these steps.
</li>
						</ol>
</li></ol></div>
					</li>
					<li>
%~transport . `State$sl ~SET `connected^l
◎
Set transport.[[State]] to "connected".
</li>
					<li>
%~transport . `Session$sl ~SET %~session
◎
Set transport.[[Session]] to session.
</li>
					<li>
%~transport . `Reliability$sl ~SET %接続 【！the connection】に応じて
⇒＃
~HTTP3接続であるならば `supports-unreliable$l ／
~HTTP2接続である `WEB-TRANSPORT-HTTP2$r ならば `reliable-only$l
◎
If the connection is an HTTP/3 connection, set transport’s [[Reliability]] to "supports-unreliable".
◎
If the connection is an HTTP/2 connection [WEB-TRANSPORT-HTTP2], set transport’s [[Reliability]] to "reliable-only".
</li>
					<li>
`~promiseを解決する$( %~transport . `Ready$sl )
◎
Resolve transport.[[Ready]] with undefined.
</li>
				</ol>
			</li>
		</ol>
</div>

<div class="algo">
<p>
`双方向~streamを~pullする@
ときは、
所与の
( `WebTransport$I ~obj %~transport )
に対し，
次の手続きを走らす：
◎
To pullBidirectionalStream, given a WebTransport object transport, run these steps.
</p>
<ol>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
~RET %~transport . `Ready$sl の`充足-時$に次の手続きを遂行するようにする：
◎
If transport.[[State]] is "connecting", then return the result of performing the following steps upon fulfillment of transport.[[Ready]]:
</p>

<div class="algo">
手続きは
⇒
~RET `双方向~streamを~pullする$( %~transport )
◎
Return the result of pullBidirectionalStream with transport.
</div>

	</li>
	<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
可用な流入~双方向~streamが在るようになるまで待機する
【！`双方向~streamを受信する$】
◎
Wait until there is an available incoming bidirectional stream.
</li>
			<li>
%内部~stream ~LET `双方向~streamを受信する$()
◎
Let internalStream be the result of receiving a bidirectional stream.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream ~LET `WebTransportBidirectionalStream$I を`作成する$wtB( %内部~stream, %~transport )
◎
Let stream be the result of creating a WebTransportBidirectionalStream with internalStream and transport.
</li>
					<li>
%~transport . `IncomingBidirectionalStreams$sl に`~chunkを~enqueueする$RS( %~stream )
◎
Enqueue stream to transport.[[IncomingBidirectionalStreams]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve p with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>
</div>

<div class="algo">
<p>
`一方向~streamを~pullする@
ときは、
所与の
( `WebTransport$I ~obj %~transport )
に対し，
次の手続きを走らす：
◎
To pullUnidirectionalStream, given a WebTransport object transport, run these steps.
</p>
<ol>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
~RET %~transport . `Ready$sl の`充足-時$に次の手続きを遂行するようにする：
◎
If transport.[[State]] is "connecting", then return the result of performing the following steps upon fulfillment of transport.[[Ready]]:
</p>

<div class="algo">
手続きは
⇒
~RET `一方向~streamを~pullする$( %~transport )
◎
Return the result of pullUnidirectionalStream with transport.
</div>
	</li>
	<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
可用な流入~一方向~streamが在るようになるまで待機する
【！`流入~一方向~streamを受信する$】
◎
Wait until there is an available incoming unidirectional stream.
</li>
			<li>
%内部~stream ~LET `流入~一方向~streamを受信する$()
◎
Let internalStream be the result of receiving an incoming unidirectional stream.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream ~LET `WebTransportReceiveStream$I を`作成する$wtR( %内部~stream, %~transport )
◎
Let stream be the result of creating a WebTransportReceiveStream with internalStream and transport.
</li>
					<li>
%~transport . `IncomingUnidirectionalStreams$sl に`~chunkを~enqueueする$RS( %~stream )
◎
Enqueue stream to transport.[[IncomingUnidirectionalStreams]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve p with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return p.
</li>
</ol>
</div>

		</section>
		<section id="webtransport-attributes">
<h3 title="Attributes">5.3. 属性</h3>

<p class="trans-note">【
原文には、
各~属性のうち一部に（規範的でない）記述もあるが、
属性が返す内部~slotの定義にて似たような内容が述べられているので，この訳では省略する
（あるいは、そこへ移動している）。
】</p>

<dl>
	<dt>
`ready@mT
◎
ready, of type Promise&lt;undefined&gt;, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Ready$sl
◎
On getting, it MUST return this's [[Ready]].
</dd>

	<dt>
`closed@mT
◎
closed, of type Promise&lt;WebTransportCloseInfo&gt;, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Closed$sl
◎
On getting, it MUST return this's [[Closed]].
</dd>

	<dt>
`draining@mT
◎
draining, of type Promise&lt;undefined&gt;, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Draining$sl
◎
On getting, it MUST return this's [[Draining]].
</dd>

	<dt>
`datagrams@mT
◎
datagrams, of type WebTransportDatagramDuplexStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Datagrams$sl
◎
↑↑ A single duplex stream for sending and receiving datagrams over this session.＼
◎
The getter steps for the datagrams attribute SHALL be:
• Return this's [[Datagrams]].
</dd>

	<dt>
`incomingBidirectionalStreams@mT
◎
incomingBidirectionalStreams, of type ReadableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingBidirectionalStreams$sl
◎
↑↑ Returns a ReadableStream of WebTransportBidirectionalStreams that have been received from the server.＼
The getter steps for the incomingBidirectionalStreams attribute SHALL be:
• Return this's [[IncomingBidirectionalStreams]].
</dd>

	<dt>
`incomingUnidirectionalStreams@mT
◎
incomingUnidirectionalStreams, of type ReadableStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `IncomingUnidirectionalStreams$sl
◎
↑↑ A ReadableStream of unidirectional streams, each represented by a WebTransportReceiveStream, that have been received from the server.＼
The getter steps for incomingUnidirectionalStreams are:
• Return this.[[IncomingUnidirectionalStreams]].
</dd>

	<dt>
`reliability@mT
◎
reliability, of type WebTransportReliabilityMode, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Reliability$sl
◎
Whether connection supports unreliable (over UDP) transport or only reliable (over TCP fallback) transport. Returns "pending" until a connection has been established.＼
The getter steps are to return this's [[Reliability]].
</dd>

	<dt>
`congestionControl@mT
◎
congestionControl, of type WebTransportCongestionControl, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `CongestionControl$sl
◎
The application’s preference, if requested in the constructor, and satisfied by the user agent, for a congestion control algorithm optimized for either throughput or low latency for sending on this connection. If a preference was requested but not satisfied, then the value is "default"＼
The getter steps are to return this's [[CongestionControl]].
</dd>
</dl>

		</section>
		<section id="webtransport-methods">
<h3 title="Methods">5.4. ~method</h3>

<div class="algo">
<dl>
	<dt>
`close(closeInfo)@mT
◎
close(closeInfo)
</dt>
	<dd>
この `WebTransport$I に結付けられた`~WebTransport~session$を終了する。
◎
Terminates the WebTransport session associated with the WebTransport object.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When close is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", then abort these steps.
</li>
			<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］：
◎
If transport.[[State]] is "connecting":
</p>
				<ol>
					<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
					<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
					<li>
~RET
◎
Abort these steps.
</li>
				</ol>
			</li>
			<li>
%~session ~LET %~transport . `Session$sl
◎
Let session be transport.[[Session]].
</li>
			<li>
%~code ~LET %closeInfo[ "`closeCode$mb" ]
◎
Let code be closeInfo.closeCode.
</li>
			<li>
%事由 ~LET 空な`~byte列$
◎
↓</li>
			<li>
<p>
%事由~文字列 ~LET `~scalar値~文字列に変換する$( %closeInfo[ "`reason$mb" ] )
</p>
<p class="trans-note">【
原文は，`符号単位$に基づいて演算しているが、
以下で~UTF-8符号化法を適用するためには，
~scalar値に変換する必要があろう。
】</p>
◎
↓</li>
			<li>
%長さ ~LET 0
◎
↓</li>
			<li>
<p>
%事由~文字列 を成す
~EACH( %符号位置 )
に対し：
【！`符号単位~接頭辞$】
</p>
				<ol>
					<li>
%~byte列 ~LET `~UTF-8符号化する$( %符号位置 )
</li>
					<li>
%長さ ~INCBY %~byte列 の`長さ$byte
</li>
					<li>
~IF［
%長さ ~GT 1024
］
⇒
~BREAK
</li>
					<li>
%事由 に %~byte列 を付加する
</li>
				</ol>
◎
Let reasonString be the maximal code unit prefix of closeInfo.reason where the length of the UTF-8 encoded prefix doesn’t exceed 1024.
◎
Let reason be reasonString, UTF-8 encoded.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす
⇒
`~WebTransport~sessionを終了する$( %~session, %~code, %事由 )
◎
In parallel, terminate session with code and reason.
</p>

<p class="note">注記：
これはまた［
%~transport . `SendStreams$sl,
%~transport . `ReceiveStreams$sl
］内に包含された各`~WebTransport~stream$に対しても［
`設定し直す$WT／
`送信を停止させる$WT
］
◎
Note: This also resets or sends STOP_SENDING WebTransport streams contained in transport.[[SendStreams]] and [[ReceiveStreams]].
</p>
			</li>
			<li>
`~WebTransportを片付ける$( %~transport, `AbortError$E, %closeInfo )
◎
Cleanup transport with AbortError and closeInfo.
</li>
		</ol>
	</dd>
</dl>
</div>

<dl>
	<dt>
`getStats()@mT
◎
getStats()
</dt>
	<dd>
この `WebTransport$I の~HTTP3接続~用の統計を集めて，
その結果を非同期的に報告する。
◎
Gathers stats for this WebTransport's HTTP/3 connection and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
下層の~QUIC接続から統計を集める
— 各~datagram上の統計も含む
◎
Gather the stats from the underlying QUIC connection, including stats on datagrams.
</li>
					<li>
前~段の統計が準備済みになるまで待機する
◎
Wait for the stats to be ready.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
%統計 ~LET `新たな$ `WebTransportStats$I ~obj
◎
Let stats be a new WebTransportStats object＼
</li>
							<li>
%統計 の各~memberを集められた統計を表現するよう設定する
◎
representing the gathered stats.
</li>
							<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>

	<dt>
`createBidirectionalStream(options)@mT
◎
createBidirectionalStream()
</dt>
	<dd>
流出~双方向~stream用の `WebTransportBidirectionalStream$I ~objを作成する。
~streamの作成だけでは、
~dataの送信に利用されるまでは，
即時に相手の端点から可視になることはないことに注意。
◎
Creates a WebTransportBidirectionalStream object for an outgoing bidirectional stream. Note that the mere creation of a stream is not immediately visible to the peer until it is used to send data.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When createBidirectionalStream is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET `却下される~promise$( `InvalidStateError$E )
◎
If transport.[[State]] is "closed" or "failed", return a new rejected promise with an InvalidStateError.
</li>
			<li>
%送信-順序 ~LET %options[ "`sendOrder$mb" ]
◎
Let sendOrder be options's sendOrder.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は、
`並列的$に走らすことに加え：
◎
Run the following steps in parallel,＼
</p>
				<ul>
					<li>
次が満たされた`ときは中止する$
⇒
%~transport . `State$sl ~IN { `closed^l, `failed^l }
◎
but abort when transport’s [[State]] becomes "closed" or "failed",＼
</li>
					<li class="algo">
<p>
`中止されたときは$
⇒
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
and instead queue a network task with transport to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `InvalidStateError$E )
◎
reject p with an InvalidStateError:
</div>
					</li>
				</ul>
				<ol>
					<li>
<p>
%内部~stream ~LET `双方向~streamを作成する$( %~transport . `Session$sl )
◎
Let internalStream be the result of creating a bidirectional stream with transport.[[Session]].
</p>

<p class="note">注記：
この演算には時間がかかることもある
— 例えば、
~stream~IDが枯渇したとき。
`QUIC$r
◎
Note: This operation may take time, for example when the stream ID is exhausted. [QUIC]
</p>
					</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E )；
~RET
◎
If transport.[[State]] is "closed" or "failed", reject p with an InvalidStateError and abort these steps.
</li>
							<li>
%~stream ~LET `WebTransportBidirectionalStream$I を`作成する$wtB( %内部~stream, %~transport, %送信-順序 )
◎
Let stream be the result of creating a WebTransportBidirectionalStream with internalStream, transport, and sendOrder.
</li>
							<li>
`~promiseを解決する$( %~promise, %~stream )
◎
Resolve p with stream.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>

	<dt>
`createUnidirectionalStream(options)@mT
◎
createUnidirectionalStream()
</dt>
	<dd>
流出~一方向~stream用の `WebTransportSendStream$I を作成する。
~streamの作成だけでは、
~dataの送信に利用されるまでは，
~serverからは即時に可視にならないことに注意。
◎
Creates a WebTransportSendStream for an outgoing unidirectional stream. Note that the mere creation of a stream is not immediately visible to the server until it is used to send data.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When createUnidirectionalStream() method is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~transport ~LET コレ
◎
Let transport be this.
</li>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET `却下される~promise$( `InvalidStateError$E )
◎
If transport.[[State]] is "closed" or "failed", return a new rejected promise with an InvalidStateError.
</li>
			<li>
%送信-順序 ~LET %options[ "`sendOrder$mb" ]
◎
Let sendOrder be options's sendOrder.
</li>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は、
`並列的$に走らすことに加え：
◎
Run the following steps in parallel,＼
</p>
				<ul>
					<li>
次が満たされた`ときは中止する$
⇒
%~transport . `State$sl ~IN { `closed^l, `failed^l }
◎
but abort when transport’s [[State]] becomes "closed" or "failed",＼
</li>
					<li class="algo">
<p>
`中止されたときは$
⇒
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
and instead queue a network task with transport to＼
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `InvalidStateError$E )
◎
reject p with an InvalidStateError:
</div>
					</li>
				</ul>
				<ol>
					<li>
<p>
%内部~stream ~LET `流出~一方向~streamを作成する$( %~transport . `Session$sl )
◎
Let internalStream be the result of creating an outgoing unidirectional stream with transport.[[Session]].
</p>

<p class="note">注記：
この演算には時間がかかることもある
— 例えば、
~stream~IDが枯渇したとき。
`QUIC$r
◎
Note: This operation may take time, for example when the stream ID is exhausted. [QUIC]
</p>
					</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒＃
`~promiseを却下する$( %~promise, `InvalidStateError$E )；
~RET
◎
If transport.[[State]] is "closed" or "failed", reject p with an InvalidStateError and abort these steps.
</li>
							<li>
%~stream ~LET `WebTransportSendStream$I を`作成する$wtS( %内部~stream, %~transport, %送信-順序 )
◎
Let stream be the result of creating a WebTransportSendStream with internalStream, transport, and sendOrder.
</li>
							<li>
`~promiseを解決する$( %~promise, %~stream )
◎
Resolve p with stream.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
return p.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="webtransport-procedures">
<h3 title="Procedures">5.5. 手続-</h3>

<div class="algo">
<p>
`~WebTransportを片付ける@
ときは、
所与の
( `WebTransport$I %~transport, %~error, %~close報（省略時は ε ） )
に対し，次の手続きを走らす：
◎
To cleanup a WebTransport transport with error and optionally closeInfo, run these steps:
</p>
<ol>
	<li>
%送信-~stream群 ~LET %~transport . `SendStreams$sl の複製
◎
Let sendStreams be a copy of transport.[[SendStreams]].
</li>
	<li>
%受信-~stream群 ~LET %~transport . `ReceiveStreams$sl の複製
◎
Let receiveStreams be a copy of transport.[[ReceiveStreams]].
</li>
	<li>
%流出~datagram群 ~LET %~transport . `Datagrams$sl . `Writable$sl
◎
Let outgoingDatagrams be transport.[[Datagrams]].[[Writable]].
</li>
	<li>
%流入~datagram群 ~LET %~transport . `Datagrams$sl . `Readable$sl
◎
Let incomingDatagrams be transport.[[Datagrams]].[[Readable]].
</li>
	<li>
%準備済み時の~promise ~LET %~transport . `Ready$sl
◎
Let ready be transport.[[Ready]].
</li>
	<li>
%~close時の~promise ~LET %~transport . `Closed$sl
◎
Let closed be transport.[[Closed]].
</li>
	<li>
%流入~双方向~stream群 ~LET %~transport . `IncomingBidirectionalStreams$sl
◎
Let incomingBidirectionalStreams be transport.[[IncomingBidirectionalStreams]].
</li>
	<li>
%流入~一方向~stream群 ~LET %~transport . `IncomingUnidirectionalStreams$sl
◎
Let incomingUnidirectionalStreams be transport.[[IncomingUnidirectionalStreams]].
</li>
	<li>
%~transport . `SendStreams$sl ~SET 新たな`有順序~集合$
◎
Set transport.[[SendStreams]] to an empty set.
</li>
	<li>
%~transport . `ReceiveStreams$sl ~SET 新たな`有順序~集合$
◎
Set transport.[[ReceiveStreams]] to an empty set.
</li>
	<li>
%~transport . `Datagrams$sl . `OutgoingDatagramsQueue$sl ~SET 新たな`~queue$
◎
Set transport.[[Datagrams]].[[OutgoingDatagramsQueue]] to an empty queue.
</li>
	<li>
%~transport . `Datagrams$sl . `IncomingDatagramsQueue$sl ~SET 新たな`~queue$
◎
Set transport.[[Datagrams]].[[IncomingDatagramsQueue]] to an empty queue.
</li>
	<li>
%~transport . `State$sl ~SET %~close報 に応じて
⇒＃
ε ならば `failed^l ／
~ELSE_ `closed^l
◎
If closeInfo is given, then set transport.[[State]] to "closed". Otherwise, set transport.[[State]] to "failed".
</li>
	<li>
%送信-~stream群 を成す
~EACH( %送信-~stream )
に対し
⇒
%送信-~stream を`~errorにする$WS( %~error )
◎
For each sendStream in sendStreams, error sendStream with error.
</li>
	<li>
<p>
%受信-~stream群 を成す
~EACH( %受信-~stream )
に対し
⇒
%受信-~stream を`~errorにする$RS( %~error )
◎
For each receiveStream in receiveStreams, error receiveStream with error.
</p>

<p class="note">注記：
~script作者は［
~promise解決~内で同期的に走る~code
］を注入できる。
よって，ここ以降は、
【仕様~策定者は】
%~transport には触れないこと
— それは、
~scriptにより予測-不能な仕方で変異されることもあるので。
このことは、
この手続-を~callしている~logicにも適用される。
◎
Note: Script authors can inject code which runs in Promise resolution synchronously. Hence from here, do not touch transport as it may be mutated by scripts in an unpredictable way. This applies to logic calling this procedure, too.
</p>
	</li>
	<li>
<p>
~IF［
%~close報 ~NEQ ε
］：
◎
If closeInfo is given, then:
</p>
		<ol>
			<li>
`~promiseを解決する$( %~close時の~promise, %~close報 )
◎
Resolve closed with closeInfo.
</li>
			<li>
~Assert：
%準備済み は`決着した＠~ECMA262#sec-promise-objects$
◎
Assert: ready is settled.
</li>
			<li>
%流入~双方向~stream群 を`~closeする$RS()
◎
Close incomingBidirectionalStreams.
</li>
			<li>
%流入~一方向~stream群 を`~closeする$RS()
◎
Close incomingUnidirectionalStreams.
</li>
			<li>
%流出~datagram群 を`~closeする$WS()
◎
Close outgoingDatagrams.
</li>
			<li>
%流入~datagram群 を`~closeする$RS()
◎
Close incomingDatagrams.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
`~promiseを却下する$( %~close時の~promise, %~error )
◎
Reject closed with error.
</li>
			<li>
`~promiseを却下する$( %準備済み時の~promise, %~error )
◎
Reject ready with error.
</li>
			<li>
%流入~双方向~stream群 を`~errorにする$RS( %~error )
◎
Error incomingBidirectionalStreams with error.
</li>
			<li>
%流入~一方向~stream群 を`~errorにする$RS( %~error )
◎
Error incomingUnidirectionalStreams with error.
</li>
			<li>
%流出~datagram群 を`~errorにする$WS( %~error )
◎
Error outgoingDatagrams with error.
</li>
			<li>
%流入~datagram群 を`~errorにする$RS( %~error )
◎
Error incomingDatagrams with error.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
`~network~taskを~queueする@
ときは、
所与の
( `WebTransport$I %~transport, %手続き )
に対し，次の手続きを走らす
⇒
`大域~taskを~queueする$( `~network用~task~source$, %~transport に`関連な大域~obj$, 
%手続き )
◎
To queue a network task with a WebTransport transport and a series of steps steps, run these steps:
• Queue a global task on the network task source with transport’s relevant global object to run steps.
</div>

		</section>
		<section id="web-transport-termination">
<h3 title="Session termination not initiated by the client">5.6. ~clientにより起動されたものでない~sessionの終了n</h3>

<div class="algo">
<p>
ある `WebTransport$I %~transport に結付けられた`~WebTransport~session$ %~session
【すなわち %~transport . `Session$sl】
が`終了され$たときは、
所与の
( %~code （省略時は ε ）, %事由~byte列 （省略時は ε ） )
に対し，次の手続きを走らす：
◎
Whenever a WebTransport session which is associated with a WebTransport transport is terminated with optionally code and reasonBytes, run these steps:
</p>
<ol>
	<li>
%~cleanにか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%~session を起動した `CONNECT^M 要請
］に結付けられた~HTTP3~streamは，
`Data Recvd^i 状態にある
`QUIC$r
◎
Let cleanly be a boolean representing whether the HTTP/3 stream associated with the CONNECT request that initiated transport.[[Session]] is in the "Data Recvd" state. [QUIC]
</li>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
			<li>
~IF［
%~cleanにか ~EQ ~F
］
⇒＃
`~WebTransportを片付ける$( %~transport, %~error )；
~RET
◎
If cleanly is false, then cleanup transport with error, and abort these steps.
</li>
			<li>
%~close報 ~LET `新たな$ `WebTransportCloseInfo$I
◎
Let closeInfo be a new WebTransportCloseInfo.
</li>
			<li>
~IF［
%~code ~NEQ ε
］
⇒
%~close報[ "`closeCode$mb" ] ~SET %~code
◎
If code is given, set closeInfo’s closeCode to code.
</li>
			<li>
<p>
~IF［
%事由~byte列 ~NEQ ε
］
⇒
%~close報[ "`reason$mb" ] ~SET `~UTF-8復号する$( %事由~byte列 )
◎
If reasonBytes is given, set closeInfo’s reason to reasonBytes, UTF-8 decoded.
</p>

<p class="note">注記：
%事由~byte列 に可用な［
言語／方向
］
【ヒトが話す言語／書字方向】
~metadataは無い。
方向~用には、
値を表示するときに `first-strong^en 経験則†を利用できる。
【† 最初に現れる `Strong^en 文字の方向に基づく（`参考＠~HTMLdom#the-directionality$）】
◎
Note: No language or direction metadata is available with reasonBytes. First-strong heuristics can be used for direction when displaying the value.
</p>
			</li>
			<li>
`~WebTransportを片付ける$( %~transport, %~error, %~close報 )
◎
Cleanup transport with error and closeInfo.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
ある `WebTransport$I %~transport に結付けられた`接続$に接続~errorが生じたときは、
次の手続きを走らす：
◎
Whenever a connection associated with a WebTransport transport gets a connection error, run these steps:
</p>
<ol>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
			<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="web-transport-context-cleanup-steps">
<h3 title="Context cleanup steps">5.7. 文脈を片付ける手続き</h3>

<div class="algo">
<p>
`文脈を片付ける手続き@
は、
所与の
( `WebTransport$I %~transport )
に対し：
◎
This specification defines context cleanup steps as the following steps, given WebTransport transport:
</p>
<ol>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connected^l
］：
◎
If transport.[[State]] is "connected", then:
</p>
		<ol>
			<li>
%~transport . `State$sl ~SET `failed^l
◎
Set transport.[[State]] to "failed".
</li>
			<li class="algo">
この段は`並列的$に走らす
⇒
`~WebTransport~sessionを終了する$( %~transport . `Session$sl )
◎
In parallel, terminate transport.[[Session]].
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
				<ol>
					<li>
%~error ~LET `~WebTransport用の例外を作成する$( `session^l )
◎
Let error be a newly created WebTransportError whose source is "session".
</li>
					<li>
`~WebTransportを片付ける$( %~transport, %~error )
◎
Cleanup transport with error.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~transport . `State$sl ~EQ `connecting^l
］
⇒
%~transport . `State$sl ~SET `failed^l
◎
If transport.[[State]] is "connecting", set transport.[[State]] to "failed".
</p>

<p class="issue">
これは、
~worker内でも行う必要がある。
`課題 #127＠https://www.github.com/w3c/webtransport/issues/127$,
`whatwg/html 課題 #6731＠https://www.github.com/whatwg/html/issues/6831$
を見よ。
◎
This needs to be done in workers too. See #127 and whatwg/html#6731.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="web-transport-gc">
<h3 title="Garbage Collection">5.8. ~garbage収集</h3>

<p>
~UAは、
所与の
( `WebTransport$I ~obj %~transport )
に対し
⇒
%~transport が次を満たす間は，
%~transport を~garbage収集しないモノトスル
⇒
%~transport . `State$sl ~IN { `connecting^l, `connected^l }
◎
The user agent MUST NOT garbage collect a WebTransport object whose [[State]] is either "connecting" or "connected".
</p>

		</section>
		<section id="web-transport-configuration">
<h3 title="Configuration">5.9. 環境設定</h3>

<pre class="idl">
dictionary `WebTransportHash@I {
  `DOMString$ `algorithm@mH;
  `BufferSource$I `value@mH;
};

dictionary `WebTransportOptions@I {
  `boolean$ `allowPooling$mb = false;
  `boolean$ `requireUnreliable$mb = false;
  `sequence$&lt;`WebTransportHash$I&gt; `serverCertificateHashes$mb;
  `WebTransportCongestionControl$I `congestionControl$mb = "default";
};

enum `WebTransportCongestionControl@I {
  `default@l,
  `throughput@l,
  `low-latency@l,
};
</pre>

<p>
`WebTransportOptions$I は、［
~WebTransport接続がどう確立され，どう利用されるか
］を決定する~parameterたちが成す辞書である。
◎
WebTransportOptions is a dictionary of parameters that determine how WebTransport connection is established and used.
</p>
<dl>
	<dt>
`allowPooling@mb
◎
allowPooling, of type boolean, defaulting to false
</dt>
	<dd>
~T に設定されたときは、
当の~WebTransport接続を~poolできる
— すなわち、
当の~WebTransport~session用の~network接続は，
他の~HTTP3~sessionと共有できるようになる。
◎
When set to true, the WebTransport connection can be pooled, that is, the network connection for the WebTransport session can be shared with other HTTP/3 sessions.
</dd>

	<dt>
`requireUnreliable@mb
◎
requireUnreliable, of type boolean, defaulting to false
</dt>
	<dd>
~T に設定した場合、
次を行えなくなる
⇒
~HTTP3接続がアリでない場合に，
~WebTransport接続を~HTTP2越しに確立する
◎
When set to true, the WebTransport connection cannot be established over HTTP/2 if an HTTP/3 connection is not possible.
</dd>

	<dt>
`serverCertificateHashes@mb
◎
serverCertificateHashes, of type sequence&lt;WebTransportHash&gt;
</dt>
	<dd>
この~optionは、
専用な接続を利用している~transport用に限り~supportされる。
◎
This option is only supported for transports using dedicated connections.＼
</dd>
	<dd>
<p>
~UAは、
次に従うモノトスル
— 以下における %~hash群 は、
この~fieldに与えた値を表すとする：
</p>
		<ul>
			<li>
~transport~protocolが この特能を~supportしない場合、
%~hash群 は空でないときには，
`NotSupportedError$E 例外を投出する
</li>
			<li>
<p>
［
~transport~protocolが この特能を~supportする
］~AND［
%~hash群 は空でない
］場合、
~server証明書は，［
~AND↓ が満たされる場合，その場合に限り
］信用されるものと判断する：
</p>
				<ul>
					<li>
次の結果 ~EQ ~T
⇒
`証明書~hashを検証yする$( 当の証明書, %~hash群 )
</li>
					<li>
当の証明書は`~custom証明書~要件$を満足する
</li>
				</ul>
			</li>
			<li>
%~hash群 を成す各~hashのうち未知な `algorithm$mH を利用するものは無視する
</li>
			<li>
%~hash群 は空な場合、
通常の`~fetchする$ 演算~用に利用することになる証明書~検証y手続-を利用する。
</li>
		</ul>
◎
For transport protocols that do not support this feature, having this field non-empty SHALL result in a NotSupportedError exception being thrown.
◎
If supported and non-empty, the user agent SHALL deem a server certificate trusted if and only if it can successfully verify a certificate hash against serverCertificateHashes and satisfies custom certificate requirements. The user agent SHALL ignore any hash that uses an unknown algorithm. If empty, the user agent SHALL use certificate verification procedures it would use for normal fetch operations.
</dd>
	<dd>
これは、
`allowPooling$mb と伴には利用できない。
◎
This cannot be used with allowPooling.
</dd>

	<dt>
`congestionControl@mb
◎
congestionControl, of type WebTransportCongestionControl, defaulting to "default"
</dt>
	<dd>
任意選択で，
次に関する応用の選好を指定する
⇒
［
~throughputまたは短い待時間
］用に調律された輻輳~制御~algoであって，
この接続~越しに~dataを送信するとき利用されるもの。
◎
Optionally specifies an application’s preference for a congestion control algorithm tuned for either throughput or low-latency to be used when sending data over this connection.＼
</dd>
	<dd>
これは、
~UA向けの~hintである。
◎
This is a hint to the user agent.
</dd>
	<dd class="issue atrisk">
この環境設定~optionは、
~browserにおける［
短い待時間~用に最適化する輻輳~制御~algo
］用の実装の欠如に因り，~risk下にある特能と見なされる
— これを書いた時点では。
◎
This configuration option is considered a feature at risk due to the lack of implementation in browsers of a congestion control algorithm, at the time of writing, that optimizes for low latency.
</dd>
</dl>

<div class="algo">
<p>
`証明書~hashを算出する@
ときは、
所与の
( %証明書 )
に対し，次の手続きを遂行する：
◎
To compute a certificate hash, given a certificate, perform the following steps:
</p>
<ol>
	<li>
%符号化した証明書 ~LET %証明書 に次を施した結果を表現するもの
⇒
`RFC5280$r にて定義される `Certificate^en【証明書】~messageを~DER符号化した結果
◎
Let cert be certificate, represented as a DER encoding of Certificate message defined in [RFC5280].
</li>
	<li>
~RET %符号化した証明書 の~SHA-256~hashを算出した結果
【！and return the computed value.】
◎
Compute the SHA-256 hash of cert and return the computed value.
</li>
</ol>
</div>

<div class="algo">
<p>
`証明書~hashを検証yする@
ときは、
所与の
( %証明書, `WebTransportHash$I ~hashたちが成す配列 %~hash群 )
に対し，次の手続きを遂行する：
◎
To verify a certificate hash, given a certificate and an array of hashes hashes, perform the following steps:
</p>
<ol>
	<li>
%参照~hash ~LET `証明書~hashを算出する$( %証明書 )
◎
Let referenceHash be the result of computing a certificate hash with certificate.
</li>
	<li>
<p>
%~hash群 を成す
~EACH( %~hash )
に対し：
</p>
		<ol>
			<li>
%~hash~source ~LET %~hash[ "`value$mH" ]
</li>
			<li>
%~algo ~LET %~hash[ "`algorithm$mH" ]
</li>
			<li>
~IF［
%~hash~source ~EQ ε【！~NULL】
］~OR［
%~algo ~EQ ε
］
⇒
~CONTINUE
</li>
			<li>
<p>
~IF［
%~algo は`~ASCII大小無視$で `sha-256^l に合致する
］：
</p>
				<ol>
					<li>
%~hash値 ~LET %~hash~source が表現する~byte列
</li>
					<li>
~IF［
%~hash値 ~EQ %参照~hash
］
⇒
~RET ~T
</li>
				</ol>
			</li>
		</ol>
◎
For every hash hash in hashes:
• If hash.value is not null and hash.algorithm is an ASCII case-insensitive match with "sha-256":
•• Let hashValue be the byte sequence which hash.value represents.
•• If hashValue is equal to referenceHash, return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p>
`~custom証明書~要件@
は、
次に従うモノトスル：
◎
The custom certificate requirements are as follows:＼
</p>
<ul>
	<li>
当の証明書は、
`RFC5280$r にて定義されるとおり X.509v3 証明書である。
◎
the certificate MUST be an X.509v3 certificate as defined in [RFC5280],＼
</li>
	<li>
`Subject Public Key^en ~field内に利用される~keyは、
いずれかの`許容される公開鍵~algo$である。
◎
the key used in the Subject Public Key field MUST be one of the allowed public key algorithms,＼
</li>
	<li>
現在の時刻は、
`RFC5280$r § 4.1.2.5 にて定義されるとおり，
証明書の妥当性~期間（ `validity period^en ）の中にある。
◎
the current time MUST be within the validity period of the certificate as defined in Section 4.1.2.5 of [RFC5280]＼
</li>
	<li>
妥当性~期間を成す総-長さは、
2 週間を超過しない。
◎
and the total length of the validity period MUST NOT exceed two weeks.＼
</li>
</ul>

<p>
~UAは、
当の証明書に対し，追加的な［
`実装定義$な要件
］を課してもヨイ。
◎
The user agent MAY impose additional implementation-defined requirements on the certificate.
</p>

<p>
`Subject Public Key Info^en ~field内
（したがって、
その帰結として， `TLS CertificateVerify^en ~message内）
に利用される
`許容される公開鍵~algo@
たちが成す正確な~listは、
`実装定義$とする
— しかしながら、
それは：
◎
The exact list of allowed public key algorithms used in the Subject Public Key Info field (and, as a consequence, in the TLS CertificateVerify message) is implementation-defined; however,＼
</p>
<ul>
	<li>
相互運用可能な既定を供するためとして、
`ECDSA with the secp256r1 (NIST P-256) named group^en
（ `RFC3279$r § 2.3.5, `RFC8422$r ）
を含むモノトスル。
◎
it MUST include ECDSA with the secp256r1 (NIST P-256) named group ([RFC3279], Section 2.3.5; [RFC8422]) to provide an interoperable default.＼
</li>
	<li>
~RSA~key（ `RFC3279$r, § 2.3.1 ）を包含しないモノトスル。
◎
It MUST NOT contain RSA keys ([RFC3279], Section 2.3.1).
</li>
</ul>

		</section>
		<section id="web-transport-close-info">
<h3 title="WebTransportCloseInfo Dictionary">5.10. `WebTransportCloseInfo^I 辞書</h3>

<p>
`WebTransportCloseInfo$I 辞書は、
`WebTransport$I を~closeする際の~error~codeに関係している情報を含む。
この情報は、
`CONNECTION_CLOSE^ft ~frame用に［
~error~code, 事由
］を設定するために利用される。
◎
The WebTransportCloseInfo dictionary includes information relating to the error code for closing a WebTransport. This information is used to set the error code and reason for a CONNECTION_CLOSE frame.
</p>

<pre class="idl">
dictionary `WebTransportCloseInfo@I {
  `unsigned long$ `closeCode$mb = 0;
  `USVString$ `reason$mb = "";
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`closeCode@mb
◎
closeCode, of type unsigned long, defaulting to 0
</dt>
	<dd>
相手の端点へ通信される~error~code。
◎
The error code communicated to the peer.
</dd>

	<dt>
`reason@mb
◎
reason, of type USVString, defaulting to ""
</dt>
	<dd>
`WebTransport$I を~closeする際の事由。
◎
The reason for closing the WebTransport.
</dd>
</dl>

		</section>
		<section id="uni-stream-options">
<h3 title="WebTransportSendStreamOptions Dictionary">5.11. `WebTransportSendStreamOptions^I 辞書</h3>

<p>
`WebTransportSendStreamOptions$I は、［
`createUnidirectionalStream()$mT ／ `createBidirectionalStream()$mT
］により作成された `WebTransportSendStream$I がどう挙動するかに影響する~parameterたちが成す辞書である。
◎
The WebTransportSendStreamOptions is a dictionary of parameters that affect how WebTransportSendStreams created by createUnidirectionalStream and createBidirectionalStream behave.
</p>

<pre class="idl">
dictionary `WebTransportSendStreamOptions@I {
  `long long$? `sendOrder$mb = null;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`sendOrder@mb
◎
sendOrder, of type long long, nullable, defaulting to null
</dt>
	<dd>
供された場合、
作成される `WebTransportSendStream$I に送信-順序~番号を与える。
◎
↓</dd>
	<dd>
<p>
各 `WebTransportSendStream$I のうち：
</p>
		<ul>
			<li>
送信-順序~番号を伴うものは、
`厳密な順序付け@
に関与するようになり【！opts】、
それらに~queueされた~byte列は，
送信-順序~番号が高いものほど先に送信されることになる。
</li>
			<li>
送信-順序~番号を伴わないものに対しては、［
それと他の `WebTransportSendStream$I
］から~UAが送信する~byte列どうしの相対的な送信-順序は`実装定義$になる。
</li>
		</ul>
◎
An send order number that, if provided, opts the created WebTransportSendStream in to participating in strict ordering. Bytes currently queued on strictly ordered WebTransportSendStreams will be sent ahead of bytes currently queued on other strictly ordered WebTransportSendStreams created with lower send order numbers.
◎
If no send order number is provided, then the order in which the user agent sends bytes from it relative to other WebTransportSendStreams is implementation-defined.＼
</dd>
	<dd>
しかしながら，~UAには、
すべての~streamのうち［
より低い送信-順序~番号により後回されないもの
］の間で帯域幅を公平に分合うことが強く奨励される。
◎
User agents are strongly encouraged however to divide bandwidth fairly between all streams that aren’t starved by lower send order numbers.
</dd>
	<dd class="note">注記：
これは、
送信者~側における~dataの優先順位付けであり，
受信される順序を保証するものではない。
◎
Note: This is sender-side data prioritization which does not guarantee reception order.
</dd>
</dl>

		</section>
		<section id="web-transport-stats">
<h3 title="WebTransportStats Dictionary">5.12. `WebTransportStats^I 辞書</h3>

<p>
`WebTransportStats$I 辞書は、
~HTTP3接続~上の統計~情報を含む。
◎
The WebTransportStats dictionary includes information on HTTP/3 connection stats.
</p>

<p class="issue">
`quic-transport^en 【？】は、
今や除去された
— この節は、
改訂される必要がある。
それらのうち（ `minRtt$mb【！min-RTT】 の様な）一部は［
~HTTP2／
~HTTP3
］接続~用に公開しても安全である一方、
ほとんどは［
結果として情報~開示になるか，
~poolされた接続~用に定義することはアリでない
］。
◎
Now that quic-transport has been removed, this section needs to be revised. Some of those are safe to expose for HTTP/2 and HTTP/3 connections (like min-RTT), while most would either result in information disclosure or are impossible to define for pooled connections.
</p>

<pre class="idl">
dictionary `WebTransportStats@I {
  `DOMHighResTimeStamp$ `timestamp$mb;
  `unsigned long long$ `bytesSent$mb;
  `unsigned long long$ `packetsSent$mb;
  `unsigned long long$ `packetsLost$mb;
  `unsigned long$ `numOutgoingStreamsCreated$mb;
  `unsigned long$ `numIncomingStreamsCreated$mb;
  `unsigned long long$ `bytesReceived$mb;
  `unsigned long long$ `packetsReceived$mb;
  `DOMHighResTimeStamp$ `smoothedRtt$mb;
  `DOMHighResTimeStamp$ `rttVariation$mb;
  `DOMHighResTimeStamp$ `minRtt$mb;
  `WebTransportDatagramStats$I `datagrams$mb;
  `unsigned long long$? `estimatedSendRate$mb;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`timestamp@mb
◎
timestamp, of type DOMHighResTimeStamp
</dt>
	<dd>
統計が集められたときの時刻印【！`timestamp^c】
— `~UNIX~epoch$から相対的な。
◎
The timestamp for when the stats are gathered, relative to the UNIX epoch (Jan 1, 1970, UTC).
</dd>

	<dt>
`bytesSent@mb
◎
bytesSent, of type unsigned long long
</dt>
	<dd>
当の~QUIC接続~上に送信された~byteたちの個数
— これは、
再-伝送も含むが，［
~UDPその他の外縁~frame法
］は含まない。
◎
The number of bytes sent on the QUIC connection, including retransmissions. Does not include UDP or any other outer framing.
</dd>

	<dt>
`packetsSent@mb
◎
packetsSent, of type unsigned long long
</dt>
	<dd>
当の~QUIC接続~上に送信された~packetの個数
— 喪失したものと決定されたものも含む。
◎
The number of packets sent on the QUIC connection, including those that are determined to have been lost.
</dd>

	<dt>
`packetsLost@mb
◎
packetsLost, of type unsigned long long
</dt>
	<dd>
当の~QUIC接続~上で喪失した~packetの個数
（単調増加しない
— 喪失したものと宣言された~packetは，後続に受信され得るので）。
◎
The number of packets lost on the QUIC connection (does not monotonically increase, because packets that are declared lost can subsequently be received).
</dd>

	<dt>
`numOutgoingStreamsCreated@mb
◎
numOutgoingStreamsCreated, of type unsigned long
</dt>
	<dd>
当の~QUIC接続~上に作成された流出~QUIC~streamの個数。
◎
The number of outgoing QUIC streams created on the QUIC connection.
</dd>

	<dt>
`numIncomingStreamsCreated@mb
◎
numIncomingStreamsCreated, of type unsigned long
</dt>
	<dd>
当の~QUIC接続~上に作成された流入~QUIC~streamの個数。
◎
The number of incoming QUIC streams created on the QUIC connection.
</dd>

	<dt>
`bytesReceived@mb
◎
bytesReceived, of type unsigned long long
</dt>
	<dd>
当の~QUIC接続~上で受信された総-~byte数
— ［
各~stream用に重複した~data
］も含むが，［
~UDPその他の外縁~frame法
］は含まない。
◎
The number of total bytes received on the QUIC connection, including duplicate data for streams. Does not include UDP or any other outer framing.
</dd>

	<dt>
`packetsReceived@mb
◎
packetsReceived, of type unsigned long long
</dt>
	<dd>
当の~QUIC接続~上で受信された総-~packet数
— 処理-可能でなかった~packetも含む。
◎
The number of total packets received on the QUIC connection, including packets that were not processable.
</dd>

	<dt>
`smoothedRtt@mb
◎
smoothedRtt, of type DOMHighResTimeStamp
</dt>
	<dd>
当の接続~上で現在に観測された
`smoothed^en 往復-時間【 `smoothed_rtt^c 】
— `RFC9002$r `§ 5.3＠~RFCx/rfc9002#section-5.3$ にて定義されるとおり。
◎
The smoothed round-trip time (RTT) currently observed on the connection, as defined in [RFC9002] Section 5.3.
</dd>

	<dt>
`rttVariation@mb
◎
rttVariation, of type DOMHighResTimeStamp
</dt>
	<dd>
接続~上で現在に観測された［
往復-時間 標本
］たちの平均~変動【 `rttvar^c 】
— `RFC9002$r `§ 5.3＠~RFCx/rfc9002#section-5.3$
にて定義されるとおり。
◎
The mean variation in round-trip time samples currently observed on the connection, as defined in [RFC9002] Section 5.3.
</dd>

	<dt>
`minRtt@mb
◎
minRtt, of type DOMHighResTimeStamp
</dt>
	<dd>
接続~全体~上で観測された最小な往復-時間。
【 `min_rtt^c — `RFC9002$r `§ 5.2＠~RFCx/rfc9002#section-5.2$】
◎
The minimum round-trip time observed on the entire connection.
</dd>

	<dt>
`datagrams@mb
◎
</dt>
	<dd class="trans-note">【
この~memberについては、
原文には何も述べられていない。
】</dd>

	<dt>
`estimatedSendRate@mb
◎
estimatedSendRate, of type unsigned long long, nullable
</dt>
	<dd>
［
~UAが~queueされた~dataを送信することになる~rate
］として見積もられた毎秒あたりの~bit数。
この~rateは、
`~WebTransport~session$を共有するすべての［
~stream, ~datagram
］に適用され，
輻輳~制御~algo
（ `congestionControl$mT により選ばれるそれにもなり得る）
により計算される。
~UAが現在の見積もりを有さない場合、
この~memberは，`不在＠~INFRA#map-exists$になるモノトスル。
この~memberは、
以前の結果には在った場合でも，不在になり得る。
◎
The estimated rate at which queued data will be sent by the user agent, in bits per second. This rate applies to all streams and datagrams that share a WebTransport session and is calculated by the congestion control algorithm (potentially chosen by congestionControl). If the user agent does not currently have an estimate, the member MUST be absent. The member can be absent even if present in previous results.
</dd>
</dl>

		</section>
		<section id="web-transport-datagram-stats">
<h3 title="WebTransportDatagramStats Dictionary">5.13. `WebTransportDatagramStats^I 辞書</h3>

<p>
`WebTransportDatagramStats$I 辞書は、
~HTTP3接続~越しの~datagram伝送~上の統計を含む。
◎
The WebTransportDatagramStats dictionary includes statistics on datagram transmission over the HTTP/3 connection.
</p>

<pre class="idl">
dictionary `WebTransportDatagramStats@I {
  `DOMHighResTimeStamp$ `timestamp$mbD;
  `unsigned long long$ `expiredOutgoing$mbD;
  `unsigned long long$ `droppedIncoming$mbD;
  `unsigned long long$ `lostOutgoing$mbD;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`timestamp@mbD
◎
timestamp, of type DOMHighResTimeStamp
</dt>
	<dd>
統計が集められたときの時刻印【！`timestamp^c】
— `~UNIX~epoch$から相対的な。
◎
The timestamp for when the stats are gathered, relative to the UNIX epoch (Jan 1, 1970, UTC).
</dd>

	<dt>
`expiredOutgoing@mbD
◎
expiredOutgoing, of type unsigned long long
</dt>
	<dd>
送信~用に~queueされた~datagramのうち，次に該当するものの個数
⇒
`outgoingMaxAge$mD より旧くなったことに因り，送信-可能になる前に落とされた
◎
The number of datagrams queued for sending that were dropped, due to being older than outgoingMaxAge before they were able to be sent.
</dd>

	<dt>
`droppedIncoming@mbD
◎
droppedIncoming, of type unsigned long long
</dt>
	<dd>
次に因り落とされた流入~datagramの個数
⇒
応用が `datagrams$mT の `readable$mD から読取る前に，受信-~queueを~overflowした
◎
The number of incoming datagrams that were dropped, due to the application not reading from datagrams' readable before new datagrams overflow the receive queue.
</dd>

	<dt>
`lostOutgoing@mbD
◎
lostOutgoing, of type unsigned long long
</dt>
	<dd>
送信した~datagramのうち，次に該当するものの個数
⇒
`RFC9002$r `§ 6.1＠~RFCx/rfc9002#section-6.1$ にて定義されるおり，
喪失したものと宣言された
◎
The number of sent datagrams that were declared lost, as defined in [RFC9002] Section 6.1.
</dd>
</dl>

		</section>
	</section>
	<section id="send-stream">
<h2 title="Interface WebTransportSendStream">6. `WebTransportSendStream^I ~interface</h2>

<p>
`WebTransportSendStream$I は、
次のような `WritableStream$I である：
◎
↓</p>
<ul>
	<li>
［
`流出~一方向$／`双方向$
］な`~WebTransport~stream$を伴う，流出~stream用の特能を供する。
◎
A WebTransportSendStream is a WritableStream providing outgoing streaming features with an outgoing unidirectional or bidirectional WebTransport stream.
</li>
	<li>
`Uint8Array$I を書込んで，~serverへ~dataを送信できる。
◎
It is a WritableStream of Uint8Array that can be written to, to send data to the server.
</li>
</ul>


<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$, `Transferable$]
interface `WebTransportSendStream@I : `WritableStream$I {
  attribute `long long$? `sendOrder$mS;
  `Promise$&lt;`WebTransportSendStreamStats$I&gt; `getStats$mS();
};
</pre>

<p>
`WebTransportSendStream$I は、
常に，`作成する$wtS手続-により作成される。
◎
A WebTransportSendStream is always created by the create procedure.
</p>

<p>
`WebTransportSendStream$I の［
`転送-手続き$, `転送-受信-時の手続き$
］は、
`WritableStream$I の`それら＠~STREAMS#ws-transfer$に従う。
◎
The WebTransportSendStream's transfer steps and transfer-receiving steps are those of WritableStream.
</p>

		<section id="send-stream-attributes">
<h3 title="Attributes">6.1. 属性</h3>

<dl>
	<dt>
`sendOrder@mS
◎
sendOrder, of type long long, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `SendOrder$slS
◎
The getter steps are:
• Return this's [[SendOrder]].
</dd>
	<dd class="algo">
設定子~手続きは、
`所与の値$ %値 に対し
⇒
コレ . `SendOrder$slS ~SET %値
◎
The setter steps, given value, are:
• Set this.[[SendOrder]] to value.
</dd>
</dl>

		</section>
		<section id="send-stream-methods">
<h3 title="Methods">6.2. ~method</h3>

<dl>
	<dt>
`getStats()@mS
◎
getStats()
</dt>
	<dd>
この `WebTransportSendStream$I の処理能に特有な統計を集めて，
その結果を非同期的に報告する。
◎
Gathers stats specific to this WebTransportSendStream's performance, and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
コレ【！この `WebTransportSendStream$I】に特有な統計を集める
◎
Gather the stats specific to this WebTransportSendStream.
</li>
					<li>
前~段の統計が準備済みになるまで待機する
◎
Wait for the stats to be ready.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
%統計 ~LET `新たな$ `WebTransportSendStreamStats$I ~obj
◎
Let stats be a new WebTransportSendStreamStats object＼
</li>
							<li>
%統計 の各~memberを集められた統計を表現するよう設定する
◎
representing the gathered stats.
</li>
							<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="send-stream-internal-slots">
<h3 title="Internal Slots">6.3. 内部~slot</h3>

<p>
各 `WebTransportSendStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportSendStream has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`InternalStream@slS</dt>
	<dd>
［
`流出~一方向$／`双方向$
］な`~WebTransport~stream$
◎
An outgoing unidirectional or bidirectional WebTransport stream.
</dd>

	<dt>`PendingOperation@slS</dt>
	<dd>
~NULL ／
処理待ちな［
書込n／~close
］演算を表現している~promise
◎
A promise representing a pending write or close operation, or null.
</dd>

	<dt>`Transport@slS</dt>
	<dd>
この `WebTransportSendStream$I を所有する `WebTransport$I
◎
A WebTransport which owns this WebTransportSendStream.
</dd>

	<dt>`SendOrder@slS</dt>
	<dd>
~NULL ／
送信-順序~番号
◎
An optional send order number, or null.
</dd>
</dl>

		</section>
		<section id="send-stream-procedures">
<h3 title="Procedures">6.4. 手続-</h3>

<div class="algo">
<p>
`WebTransportSendStream$I を
`作成する@wtS
ときは、
所与の
( ［
`流出~一方向$／`双方向$
］な`~WebTransport~stream$ %内部~stream, `WebTransport$I %~transport, %送信-順序 )
に対し，次の手続きを走らす：
◎
To create a WebTransportSendStream, with an outgoing unidirectional or bidirectional WebTransport stream internalStream, a WebTransport transport, and a sendOrder, run these steps:
</p>

<ol>
	<li>
%~stream ~LET `新たな$ `WebTransportSendStream$I
— その
⇒＃
`InternalStream$slS ~SET %内部~stream,
`PendingOperation$slS ~SET ~NULL,
`Transport$slS ~SET %~transport,
`SendOrder$slS ~SET %送信-順序,
◎
Let stream be a new WebTransportSendStream, with:
• [[InternalStream]]
•• internalStream
• [[PendingOperation]]
•• null
• [[Transport]]
•• transport
• [[SendOrder]]
•• sendOrder
</li>
	<li>
<p>
%~stream を`設定しておく$WS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`書込n~algo^i ~SET 所与の
( %~chunk )
に対し，次を走らす動作
⇒
%~stream に`書込む$wtS( %~chunk )
</li>
			<li class="algo">
`~close~algo^i ~SET 次を走らす動作
⇒
%~stream を`~closeする$wtS()
</li>
			<li class="algo">
`中止-~algo^i ~SET 所与の
( %事由 )
に対し，次を走らす動作
⇒
%~stream を`中止する$wtS( %事由 )
</li>
		</ul>
◎
Let writeAlgorithm be an action that writes chunk to stream, given chunk.
◎
Let closeAlgorithm be an action that closes stream.
◎
Let abortAlgorithm be an action that aborts stream with reason, given reason.
◎
Set up stream with writeAlgorithm set to writeAlgorithm, closeAlgorithm set to closeAlgorithm, abortAlgorithm set to abortAlgorithm.
</li>
	<li>
<p>
`通達に~algoを追加する$( %~stream . `controller^sl . `signal^sl, 次の手続き )
◎
Add the following steps to stream’s [[controller]]'s [[signal]].
</p>
<div class="algo">
<p>
手続きは：
◎
↑</p>
		<ol>
			<li>
~IF［
%~stream . `PendingOperation$slS ~EQ ~NULL
］
⇒
~RET
◎
If stream.[[PendingOperation]] is null, then abort these steps.
</li>
			<li>
%事由 ~LET %~stream . `controller^sl . `signal^sl の`中止-事由$aB
◎
Let reason be stream’s [[controller]]'s [[signal]]'s abort reason.
</li>
			<li>
%中止-時の~promise ~LET %~stream を`中止する$wtS( %事由 )
◎
Let abortPromise be the result of aborting stream with reason.
</li>
			<li>
%中止-時の~promise の`充足-時$には
⇒
`~promiseを却下する$( %~promise, %事由 )
◎
Upon fulfillment of abortPromise, reject promise with reason.
</li>
			<li>
%処理待ち演算 ~LET %~stream . `PendingOperation$slS
◎
Let pendingOperation be stream.[[PendingOperation]].
</li>
			<li>
%~stream . `PendingOperation$slS ~SET ~NULL
◎
Set stream.[[PendingOperation]] to null.
</li>
			<li>
`~promiseを解決する$( %処理待ち演算, %~promise )
◎
Resolve pendingOperation with promise.
</li>
		</ol>
</div>
	</li>
	<li>
%~transport . `SendStreams$sl に %~stream を`付加する$set
◎
Append stream to transport.[[SendStreams]].
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream に
`書込む@wtS
ときは、
所与の
( %~chunk )
に対し，次の手続きを走らす：
◎
To write chunk to a WebTransportSendStream stream, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
~IF［
%~chunk は `BufferSource$I でない
］
⇒
~RET `却下される~promise$( `TypeError$E )
◎
If chunk is not a BufferSource, return a promise rejected with a TypeError.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~byte列 ~LET %~chunk に`保持された~byte列の複製を取得する$
◎
Let bytes be a copy of the byte sequence which chunk represents.
</li>
	<li>
%~stream . `PendingOperation$slS ~SET %~promise
◎
Set stream.[[PendingOperation]] to promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~stream . `InternalStream$slS に %~byte列 を`送信する$WT
◎
Send bytes on stream.[[InternalStream]] and＼
</li>
			<li>
<p>
前~段の演算が完了するまで待機する
— この送信は：
◎
wait for the operation to complete.＼
</p>
				<ul>
					<li>
この時点ですでに~queueされたかどうかを問わず，
この~transport越しに送信されることになる［
~stream, ~datagram
］の送信と前後してもヨイ。
◎
This sending MAY be interleaved with sending of previously queued streams and datagrams, as well as streams and datagrams yet to be queued to be sent over this transport.
</li>
					<li>
%~stream . `SendOrder$slS ~EQ ~NULL の場合
⇒
この送信は、
`~flow制御$［
事由／`~error＠~STREAMS#writablestream-error$WS
］を除いて，後回しないモノトスル
◎
If stream.[[SendOrder]] is null then this sending MUST NOT starve except for flow control reasons or error.
</li>
					<li>
%~stream . `SendOrder$slS ~NEQ ~NULL の場合
⇒
この送信は、［
次を満たす各 `WebTransportSendStream$I %送信-~stream 上に送信するために~queueされたすべての~byteが送信される
］までは，後回するモノトスル
⇒
［
%送信-~stream . `SendOrder$slS ~NEQ ~NULL
］~AND［
%送信-~stream . `SendOrder$slS ~GT %~stream . `SendOrder$slS
］~AND［
~NOT↓
］
⇒
［
`~error＠~STREAMS#writablestream-error$WSした
］~OR［
`~flow制御$により阻まれた
］
◎
If stream.[[SendOrder]] is not null then this sending MUST starve until all bytes queued for sending on WebTransportSendStreams with a non-null and higher [[SendOrder]], that are neither errored nor blocked by flow control, have been sent.
</li>
					<li>
<p>
~UAは、［
後回されていない~stream
］たちすべての間で，帯域幅を公平に分合うベキである。
◎
The user agent SHOULD divide bandwidth fairly between all streams that aren’t starved.
</p>

<p class="note">注記：
ここでの公平さを成す定義は、
`実装定義$である。
◎
Note: The definition of fairness here is implementation-defined.
</p>
					</li>
				</ul>

<p class="note">注記：
ここでは、
%~stream . `SendOrder$slS に対し`並列的$に~accessする。
~UAは、
送信している間，この値の~liveな更新に応答するベキである
— その詳細は、
`実装定義$であるが。
◎
Note: We access stream.[[SendOrder]] in parallel here. User agents SHOULD respond to live updates of these values during sending, though the details are implementation-defined.
</p>
			</li>
			<li>
<p>
~IF［
前~段は失敗した
］
⇒
~RET
◎
If the previous step failed, abort the remaining steps.
</p>

<p class="note">注記：
ここでは %~promise を却下しない
— ~network~errorは他所で取扱われ、
そこでの手続きが %~stream を~errorにして，
この書込n演算の結果を却下するので。
◎
Note: We don’t reject promise here because we handle network errors elsewhere, and those steps error stream and reject the result of this write operation.
</p>
			</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream . `PendingOperation$slS ~SET ~NULL
◎
Set stream.[[PendingOperation]] to null.
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

<p class="note">注記：
~UAは、
転送~処理能を改善するために~bufferしてもヨイ。
背圧~情報を `WebTransportSendStream$I の利用元へ運ぶため、
そのような~buffer【の~size】には固定的な上限があるベキである。
このことはまた、［
この~algo（あるいは `write()$dw ）から返された~promiseが`充足されても＠~ECMA262#sec-promise-objects$，
~chunkが~serverにより~ackされる
］<strong>とは限らず</strong> `QUIC$r，
~chunkは~bufferに付加されたことだけを意味する
］場合もあることを意味する。
当の~chunkが~serverに必ず到着するようにするためには、
応用~levelの~protocolを利用すること。
◎
Note: The user-agent MAY have a buffer to improve the transfer performance. Such a buffer SHOULD have a fixed upper limit, to carry the backpressure information to the user of WebTransportSendStream. This also means the fulfillment of the promise returned from this algorithm (or, WritableStreamDefaultWriter.write) does NOT necessarily mean that the chunk is acked by the server [QUIC]. It may just mean that the chunk is appended to the buffer. To make sure that the chunk arrives at the server, use an application-level protocol.
</p>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream を
`~closeする@wtS
ときは、
次の手続きを走らす：
◎
To close a WebTransportSendStream stream, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
	<li>
%~stream . `PendingOperation$slS ~SET %~promise
◎
Set stream.[[PendingOperation]] to promise.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~stream . `InternalStream$slS に~FINを`送信する$WT
◎
Send FIN on stream.[[InternalStream]] and＼
</li>
			<li>
前~段の演算が完了するまで待機する
◎
wait for the operation to complete.
</li>
			<li>
%~stream . `InternalStream$slS が `Data Recvd^i 状態に入るまで待機する
`QUIC$r
◎
Wait for stream.[[InternalStream]] to enter the "Data Recvd" state. [QUIC]
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
				<ol>
					<li>
%~stream . `PendingOperation$slS ~SET ~NULL
◎
Set stream.[[PendingOperation]] to null.
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream を
`中止する@wtS
ときは、
所与の
( %事由 )
に対し，次の手続きを走らす：
◎
To abort a WebTransportSendStream stream with reason, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~code ~LET 0
◎
Let code be 0.
</li>
	<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
	<li>
~IF［
%事由 は `WebTransportError$I である
］~AND［
%事由 . `StreamErrorCode$sl ~NEQ ~NULL
］
⇒
%~code ~SET %事由 . `StreamErrorCode$sl
◎
If reason is a WebTransportError and reason.[[StreamErrorCode]] is not null, then set code to reason.[[StreamErrorCode]].
</li>
	<li>
~IF［
%~code ~LT 0
］
⇒
%~code ~SET 0
◎
If code &lt; 0, then set code to 0.
</li>
	<li>
<p>
~IF［
%~code ~GT 4294967295
］
⇒
%~code ~SET 4294967295
◎
If code &gt; 4294967295, then set code to 4294967295.
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
~codeは、
`WEB-TRANSPORT-HTTP3$r にて述べられる【！decribe】とおり，
整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } に符号化されることになる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. The code will be encoded to a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%~stream . `InternalStream$slS を`設定し直す$WT( %~code )
◎
Reset stream.[[InternalStream]] with code.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
◎
resolve promise with undefined.
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

		</section>
		<section id="send-stream-STOP_SENDING">
<h3 title="STOP_SENDING signal coming from the server">6.5. ~serverから来ている `STOP_SENDING^ft 通達</h3>

<div class="algo">
<p>
`WebTransportSendStream$I %~stream に結付けられた `~WebTransport~stream$が，~serverから `STOP_SENDING$ft ~frame %通達 を取得したときは、
次の手続きを走らす：
◎
Whenever a WebTransport stream associated with a WebTransportSendStream stream gets a STOP_SENDING signal from the server, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slS
◎
Let transport be stream.[[Transport]].
</li>
	<li>
<p>
%~code ~LET %通達 に付された応用~protocol~error~code
`QUIC$r
◎
Let code be the application protocol error code attached to the STOP_SENDING frame. [QUIC]
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
~codeは、
`WEB-TRANSPORT-HTTP3$r にて述べられるとおり，
整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } から復号された結果になる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. The code has been decoded from a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in[WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `stream^l, %~code )
◎
Let error be a newly created WebTransportError whose source is "stream" and streamErrorCode is code.
</li>
			<li>
%~stream を`~errorにする$WS( %~error )
◎
Error stream with error.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="send-stream-stats">
<h3 title="WebTransportSendStreamStats Dictionary">6.6. `WebTransportSendStreamStats^I 辞書</h3>

<p>
`WebTransportSendStreamStats$I 辞書は、
ある `WebTransportSendStream$I に特有な統計の情報を含む。
◎
The WebTransportSendStreamStats dictionary includes information on stats specific to one WebTransportSendStream.
</p>

<pre class="idl">
dictionary `WebTransportSendStreamStats@I {
  `DOMHighResTimeStamp$ `timestamp$mbS;
  `unsigned long long$ `bytesWritten$mbS;
  `unsigned long long$ `bytesSent$mbS;
  `unsigned long long$ `bytesAcknowledged$mbS;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`timestamp@mbS
◎
timestamp, of type DOMHighResTimeStamp
</dt>
	<dd>
統計が集められたときの時刻印【！`timestamp^c】
— `~UNIX~epoch$から相対的な。
◎
The timestamp for when the stats are gathered, relative to the UNIX epoch (Jan 1, 1970, UTC).
</dd>

	<dt>
`bytesWritten@mbS
◎
bytesWritten, of type unsigned long long
</dt>
	<dd>
当の応用が この `WebTransportSendStream$I に成功裡に書込んだ総~byte数。
この数は、
決して減少しない。
◎
The total number of bytes the application has successfully written to this WebTransportSendStream. This number can only increase.
</dd>

	<dt>
`bytesSent@mbS
◎
bytesSent, of type unsigned long long
</dt>
	<dd>
当の応用が この `WebTransportSendStream$I に書込んだ~byte列のうち，
何~byteが一回以上~送信されたかを指示する。
この数は、
決して減少しないことに加え，
常に `bytesWritten$mbS 以下になる。
◎
An indicator of progress on how many of the application bytes written to this WebTransportSendStream has been sent at least once. This number can only increase, and is always less than or equal to bytesWritten.
</dd>
	<dd class="note">注記：
この進捗は、
単独の~streamに送信された応用~dataに限られ，
~network~overheadを含まない。
◎
Note: this is progress of app data sent on a single stream only, and does not include any network overhead.
</dd>

	<dt>
`bytesAcknowledged@mbS
◎
bytesAcknowledged, of type unsigned long long
</dt>
	<dd>
当の応用が この `WebTransportSendStream$I に書込んだ~byte列のうち，
何~byteが［
送信され、
~serverにより受信されるに伴い，~QUICの~ACK用の仕組みを利用して認知されたか
］を指示する。
数えられるのは、［
認知されてない最初の~byte
］の直前までに限られる。
この数は、
決して減少しないことに加え，
常に `bytesSent$mbS 以下になる。
◎
An indicator of progress on how many of the application bytes written to this WebTransportSendStream have been sent and acknowledged as received by the server using QUIC’s ACK mechanism. Only sequential bytes up to, but not including, the first non-acknowledged byte, are counted. This number can only increase and is always less than or equal to bytesSent.
</dd>
	<dd class="note">注記：
この値は、
~HTTP2越しの接続においては，
`bytesSent$mbS に合致することになる。
◎
Note: This value will match bytesSent when the connection is over HTTP/2.
</dd>
</dl>

		</section>
	</section>
	<section id="receive-stream">
<h2 title="Interface WebTransportReceiveStream">7. `WebTransportReceiveStream^I ~interface</h2>

<p>
`WebTransportReceiveStream$I は、
次のような `ReadableStream$I である：
◎
↓</p>
<ul>
	<li>
［
`流入~一方向$／`双方向$
］な`~WebTransport~stream$を伴う流入~stream用の特能を供する。
◎
A WebTransportReceiveStream is a ReadableStream providing incoming streaming features with an incoming unidirectional or bidirectional WebTransport stream.
</li>
	<li>
そこから `Uint8Array$I を読取って，
~serverから受信した~dataを消費できる。
◎
It is a ReadableStream of Uint8Array that can be read from, to consume data received from the server.＼
</li>
	<li>
`可読~byte~stream$でもある。
よって，それは、
`既定の読取器$のみならず，
`~BYOB読取器$を利用することを消費器に許容する。
◎
WebTransportReceiveStream is a readable byte stream, and hence it allows its consumers to use a BYOB reader as well as a default reader.
</li>
</ul>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$, `Transferable$]
interface `WebTransportReceiveStream@I : `ReadableStream$I {
  `Promise$&lt;`WebTransportReceiveStreamStats$I&gt; `getStats$mR();
};
</pre>

<p>
`WebTransportReceiveStream$I は、
常に，それを`作成する$wtR手続-により作成される。
◎
A WebTransportReceiveStream is always created by the create procedure.
</p>

<p>
`WebTransportReceiveStream$I の［
`転送-手続き$／`転送-受信-時の手続き$
］は
`ReadableStream$I の`それら＠~STREAMS#rs-transfer$に従う。
◎
The WebTransportReceiveStream's transfer steps and transfer-receiving steps are those of ReadableStream.
</p>

		<section id="receive-stream-methods">
<h3 title="Methods">7.1. ~method</h3>

<dl>
	<dt>
`getStats()@mR
◎
getStats()
</dt>
	<dd>
この `WebTransportReceiveStream$I の処理能に特有な統計を集めて，
その結果を非同期的に報告する。
◎
Gathers stats specific to this WebTransportReceiveStream's performance, and reports the result asynchronously.
</dd>
	<dd class="algo">
<p>
~method手続きは：
◎
When getStats is called, the user agent MUST run the following steps:
</p>
		<ol>
			<li>
%~promise ~LET `新たな~promise$
◎
Let p be a new promise.
</li>
			<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
				<ol>
					<li>
コレ【！この `WebTransportReceiveStream$I】に特有な統計を集める
◎
Gather the stats specific to this WebTransportReceiveStream.
</li>
					<li>
前~段の統計が準備済みになるまで待機する
◎
Wait for the stats to be ready.
</li>
					<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run the following steps:
</p>
						<ol>
							<li>
%統計 ~LET `新たな$ `WebTransportReceiveStreamStats$I
~obj
◎
Let stats be a new WebTransportReceiveStreamStats object＼
</li>
							<li>
%統計 の各~memberを集められた統計を表現するよう設定する
◎
representing the gathered stats.
</li>
							<li>
`~promiseを解決する$( %~promise, %統計 )
◎
Resolve p with stats.
</li>
						</ol>
</div>
					</li>
				</ol>
			</li>
			<li>
~RET %~promise
◎
Return p.
</li>
		</ol>
	</dd>
</dl>

		</section>
		<section id="receive-stream-internal-slots">
<h3 title="Internal Slots">7.2. 内部~slot</h3>

<p>
各 `WebTransportReceiveStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportReceiveStream has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`InternalStream@slR</dt>
	<dd>
［
`流入~一方向$／`双方向$
］な`~WebTransport~stream$
◎
An incoming unidirectional or bidirectional WebTransport stream.
</dd>

	<dt>`Transport@slR</dt>
	<dd>
この `WebTransportReceiveStream$I を所有している `WebTransport$I ~obj
◎
The WebTransport object owning this WebTransportReceiveStream.
</dd>
</dl>

		</section>
		<section id="receive-stream-procedures">
<h3 title="Procedures">7.3. 手続-</h3>

<div class="algo">
<p>
`WebTransportReceiveStream$I を
`作成する@wtR
ときは、
所与の
( ［
`流入~一方向$／`双方向$
］な`~WebTransport~stream$ %内部~stream, `WebTransport$I %~transport )
に対し，次の手続きを走らす：
◎
To create a WebTransportReceiveStream, with an incoming unidirectional or bidirectional WebTransport stream internalStream and a WebTransport transport, run these steps:
</p>
<ol>
	<li>
%~stream ~LET `新たな$ `WebTransportReceiveStream$I
— その
⇒＃
`InternalStream$slR ~SET %内部~stream,
`Transport$slR ~SET %~transport
◎
Let stream be a new WebTransportReceiveStream, with:
• [[InternalStream]]
•• internalStream
• [[Transport]]
•• transport
</li>
	<li>
<p>
%~stream を`~byte読取り~support付きで設定しておく$RS
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`~pull~algo^i ~SET  次を走らす動作
⇒
%~stream から`~byte列を~pullする$wtR
</li>
			<li class="algo">
`取消~algo^i ~SET  所与の
( %事由 )
に対し，次を走らす動作
⇒
%~stream を`取消す$wtR( %事由 )
</li>
		</ul>

◎
Let pullAlgorithm be an action that pulls bytes from stream.
◎
Let cancelAlgorithm be an action that cancels stream with reason, given reason.
◎
Set up with byte reading support stream with pullAlgorithm set to pullAlgorithm and cancelAlgorithm set to cancelAlgorithm.
</li>
	<li>
%~transport . `ReceiveStreams$sl に %~stream を`付加する$set
◎
Append stream to transport.[[ReceiveStreams]].
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportReceiveStream$I %~stream から
`~byte列を~pullする@wtR
ときは、
次の手続きを走らす：
◎
To pull bytes from a WebTransportReceiveStream stream, run these steps.
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slR
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%内部~stream ~LET %~stream . `InternalStream$slR
◎
Let internalStream be stream.[[InternalStream]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~buffer ~LET ~NULL
◎
↓</li>
	<li>
%~offset ~LET ~NULL
◎
↓</li>
	<li>
%最大-~byte数 ~LET ~NULL
◎
Let buffer, offset, and maxBytes be null.
</li>
	<li>
%~view ~LET %~stream 用の`現在の~BYOB要請~view$RS
◎
↓</li>
	<li>
<p>
~IF［
%~view ~NEQ ~NULL
］：
◎
If stream’s current BYOB request view for stream is not null:
</p>
		<ol>
			<li>
%~offset ~SET %~view . `ByteOffset^sl
◎
Set offset to stream’s current BYOB request view.[[ByteOffset]].
</li>
			<li>
%最大-~byte数 ~SET %~view の`~byte長さ$BS
◎
Set maxBytes to stream’s current BYOB request view's byte length.
</li>
			<li>
%~buffer ~SET %~view の`下層~buffer$BS
◎
Set buffer to stream’s current BYOB request view's underlying buffer.
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~offset ~SET 0
◎
Set offset to 0.
</li>
			<li>
%最大-~byte数 ~SET `実装定義$な~size
◎
Set maxBytes to an implementation-defined size.
</li>
			<li>
<p>
%~buffer ~SET `新たな$ `ArrayBuffer$I
— ~size %最大-~byte数 の
【！`~buffer~sourceを~byte列から作成する$】
</p>

<p>
~IF［
`ArrayBuffer$I を割振ることに失敗した
］
⇒
~RET `却下される~promise$( `RangeError$E )
</p>
◎
Set buffer be a new ArrayBuffer with maxBytes size. If allocating the ArrayBuffer fails, return a promise rejected with a RangeError.
</li>
		</ol>
	</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<div>
<p>
次を遂行する：
◎
↓</p>
				<ol>
					<li>
%内部~stream にて［
1 個以上の~byteが読取られるか ~FIN が受信される
］まで待機する
</li>
					<li>
%~FINを受信したか ~LET ［
~FIN が伴われていたならば ~T ／
~ELSE_ ~F
］
</li>
					<li>
%~byte列 ~LET ［
%内部~stream から %最大-~byte数 個までの~byteたち
］を読取った結果が成す~byte列
</li>
					<li>
`配列~bufferの中へ~byte列を書込む$( %~buffer, %~byte列, %~offset )
</li>
				</ol>
◎
Write the bytes that area read from internalStream into buffer with offset offset, up to maxBytes bytes. Wait until either at least one byte is read or FIN is received. Let read be the number of read bytes, and let hasReceivedFIN be whether FIN was accompanied.＼
</div>

<p class="note">注記：
~UAは、
転送~処理能を改善するために~bufferしてもヨイ。
背圧~情報を~serverへ運ぶため、
そのような~buffer【の~size】には固定的な上限があるベキである。
◎
Note: The user-agent MAY have a buffer to improve the transfer performance. Such a buffer SHOULD have a fixed upper limit, to carry the backpressure information to the server.
</p>

<p class="note">注記：
この演算は、
【 %~buffer を成す】すべての~byteたちが埋まる前に返ることもある。
◎
Note: This operation may return before filling up all of bytes.
</p>
			</li>
			<li>
<p>
~IF［
前~段は失敗した
］
⇒
~RET
◎
If the previous step failed, abort the remaining steps.
</p>

<p class="note">注記：
ここでは %~promise を却下しない
— ~network~errorは他所で取扱われ、
そこでの手続きが %~stream を~errorにして，
この読取n演算の結果を却下するので。
◎
Note: We don’t reject promise here because we handle network errors elsewhere, and those steps error stream and reject the result of this read operation.
</p>
			</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>

<p class="note">注記：
%~buffer 【！the buffer described above】が，
この手続-が走っている`~event~loop$aG内で可用である場合、
次の手続きは，即時に走れる／走らせてもヨイ。
◎
Note: If the buffer described above is available in the event loop where this procedure is running, the following steps may run immediately.
</p>
				<ol>
					<li>
%長さ ~LET %~byte列 の`長さ$byte
◎
↑</li>
					<li>
<p>
~IF［
%長さ ~GT 0
］：
◎
If read &gt; 0:
</p>
						<ol>
							<li>
<p>
%~view ~SET 新たな `Uint8Array$I `with^en† %~buffer, %~offset, %長さ
</p>

<p class="trans-note">【†
%~buffer 内の［
%~offset から %長さ 個の~byteが成す~byte列
］への~viewを表現している新たな `Uint8Array$I 
】</p>
◎
Set view to a new Uint8Array with buffer, offset and read.
</li>
							<li>
%~stream の中へ`~chunkを~enqueueする$RS( %~view )
◎
Enqueue view into stream.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~FINを受信したか ~EQ ~T
］：
◎
If hasReceivedFIN is true:
</p>
						<ol>
							<li>
%~transport . `ReceiveStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[ReceiveStreams]].
</li>
							<li>
%~stream を`~closeする$RS
◎
Close stream.
</li>
						</ol>
					</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`WebTransportReceiveStream$I %~stream を
`取消す@wtR
ときは、
所与の
( %事由 )
に対し，
次の手続きを走らす：
◎
To cancel a WebTransportReceiveStream stream with reason, run these steps.
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slR
◎
Let transport be stream.[[Transport]].
</li>
	<li>
%内部~stream ~LET %~stream . `InternalStream$slR
◎
Let internalStream be stream.[[InternalStream]].
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~code ~LET 0
◎
Let code be 0.
</li>
	<li>
~IF［
%事由 は `WebTransportError$I である
］~AND［
%事由 . `StreamErrorCode$sl ~NEQ ~NULL
］
⇒
%~code ~SET %事由 . `StreamErrorCode$sl
◎
If reason is a WebTransportError and reason.[[StreamErrorCode]] is not null, then set code to reason.[[StreamErrorCode]].
</li>
	<li>
~IF［
%~code ~LT 0
］
⇒
%~code ~SET 0
◎
If code &lt; 0, then set code to 0.
</li>
	<li>
<p>
~IF［
%~code ~GT 4294967295
］
⇒
%~code ~SET 4294967295
◎
If code &gt; 4294967295, then set code to 4294967295.
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
~codeは、
`WEB-TRANSPORT-HTTP3$r にて述べられる【！decribe】とおり，
整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } に符号化されることになる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. The code will be encoded to a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li>
%~transport . `SendStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[SendStreams]].
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%内部~stream 上の`送信を停止させる$WT( %~code )
◎
Send STOP_SENDING with internalStream and code.
</li>
			<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
<p class="note">注記：
%~buffer 【！the buffer described above】が，
この手続-が走っている`~event~loop$aG内で可用である場合、
次の手続きは，即時に走れる／走らせてもヨイ。
◎
Note: If the buffer described above is available in the event loop where this procedure is running, the following steps may run immediately.
</p>
				<ol>
					<li>
%~transport . `ReceiveStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[ReceiveStreams]].
</li>
					<li>
`~promiseを解決する$( %~promise )
◎
Resolve promise with undefined.
</li>
				</ol>
</div>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>

		</section>
		<section id="receive-stream-RESET_STREAM">
<h3 title="Reset signal coming from the server">7.4. ~serverから来ている `RESET_STREAM^ft 通達</h3>

<div class="algo">
<p>
`WebTransportReceiveStream$I %~stream に結付けられた `~WebTransport~stream$が ~serverから `RESET_STREAM$ft ~frame %通達 を取得したときは，次の手続きを走らす：
◎
Whenever a WebTransport stream associated with a WebTransportReceiveStream stream gets a RESET_STREAM signal from the server, run these steps:
</p>
<ol>
	<li>
%~transport ~LET %~stream . `Transport$slR
◎
Let transport be stream.[[Transport]].
</li>
	<li>
<p>
%~code ~LET %通達 に付された応用~protocol~error~code
`QUIC$r
◎
Let code be the application protocol error code attached to the RESET_STREAM frame. [QUIC]
</p>

<p class="note">注記：
%~code 用の妥当な値は、
0 以上 4294967295 以下である。
~codeは、
`WEB-TRANSPORT-HTTP3$r にて述べられるとおり，
整数 ~IN { 0x52e4a40fa8db 〜 0x52e5ac983162 } から復号された結果になる。
◎
Note: Valid values of code are from 0 to 4294967295 inclusive. The code has been decoded from a number in [0x52e4a40fa8db, 0x52e5ac983162] as decribed in [WEB-TRANSPORT-HTTP3].
</p>
	</li>
	<li>
<p>
`~network~taskを~queueする$( %~transport, 次の手続き )
◎
Queue a network task with transport to＼
</p>
<div class="algo">
<p>
手続きは：
◎
run these steps:
</p>
		<ol>
			<li>
~IF［
%~transport . `State$sl ~IN { `closed^l, `failed^l }
］
⇒
~RET
◎
If transport.[[State]] is "closed" or "failed", abort these steps.
</li>
			<li>
%~transport . `ReceiveStreams$sl から %~stream を`除去する$
◎
Remove stream from transport.[[ReceiveStreams]].
</li>
			<li>
%~error ~LET `~WebTransport用の例外を作成する$( `stream^l, %~code )
◎
Let error be a newly created WebTransportError whose source is "stream" and streamErrorCode is code.
</li>
			<li>
%~stream を`~errorにする$RS( %~error )
◎
Error stream with error.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

		</section>
		<section id="receive-stream-stats">
<h3 title="WebTransportReceiveStreamStats Dictionary">7.5. `WebTransportReceiveStreamStats^I 辞書</h3>

<p>
`WebTransportReceiveStreamStats$I 辞書は、
ある `WebTransportReceiveStream$I に特有な統計の情報を含む。
◎
The WebTransportReceiveStreamStats dictionary includes information on stats specific to one WebTransportReceiveStream.
</p>

<pre class="idl">
dictionary `WebTransportReceiveStreamStats@I {
  `DOMHighResTimeStamp$ `timestamp$mbR;
  `unsigned long long$ `bytesReceived$mbR;
  `unsigned long long$ `bytesRead$mbR;
};
</pre>

<p>
この辞書が有する~memberは：
◎
The dictionary SHALL have the following attributes:
</p>
<dl>
	<dt>
`timestamp@mbR
◎
timestamp, of type DOMHighResTimeStamp
</dt>
	<dd>
統計が集められたときの時刻印【！`timestamp^c】
— `~UNIX~epoch$から相対的な。
◎
The timestamp for when the stats are gathered, relative to the UNIX epoch (Jan 1, 1970, UTC).
</dd>

	<dt>
`bytesReceived@mbR
◎
bytesReceived, of type unsigned long long
</dt>
	<dd>
当の `WebTransportReceiveStream$I 用に意図された~server応用からの~byte列のうち，
これまでに何~byteが受信されたかを指示する。
最初の欠落な~byteの直前までの，連列を成す~byteたちに限り数えられる。
この数は、
決して減少しない。
◎
An indicator of progress on how many of the server application’s bytes intended for this WebTransportReceiveStream have been received so far. Only sequential bytes up to, but not including, the first missing byte, are counted. This number can only increase.
</dd>
	<dd class="note">注記：
この進捗は、
単独の~streamに受信された応用~dataに限られ，
~network~overheadを含まない。
◎
Note: this is progress of app data received on a single stream only, and does not include any network overhead.
</dd>
	<dt>
`bytesRead@mbR
◎
bytesRead, of type unsigned long long
</dt>
	<dd>
当の応用が，この `WebTransportReceiveStream$I から成功裡に読取った総-~byte数。
この数は、
決して減少しないことに加え，
常に `bytesReceived$mbR 以下になる。
◎
The total number of bytes the application has successfully read from this WebTransportReceiveStream. This number can only increase, and is always less than or equal to bytesReceived.
</dd>
</dl>

		</section>
	</section>
	<section id="bidirectional-stream">
<h2 title="Interface WebTransportBidirectionalStream">8. `WebTransportBidirectionalStream^I ~interface</h2>

<pre class="idl">
[`Exposed$=(Window,Worker), `SecureContext$]
interface `WebTransportBidirectionalStream@I {
  readonly attribute `WebTransportReceiveStream$I `readable$mB;
  readonly attribute `WebTransportSendStream$I `writable$mB;
};
</pre>

		<section id="bidirectional-stream-internal-slots">
<h3 title="Internal slots">8.1. 内部~slot</h3>

<p>
各 `WebTransportBidirectionalStream$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportBidirectionalStream has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`Readable@slB</dt>
	<dd>
ある `WebTransportReceiveStream$I
◎
A WebTransportReceiveStream.
</dd>

	<dt>`Writable@slB</dt>
	<dd>
ある `WebTransportSendStream$I
◎
A WebTransportSendStream.
</dd>

	<dt>`Transport@slB</dt>
	<dd>
この `WebTransportBidirectionalStream$I を所有している `WebTransport$I ~obj
◎
The WebTransport object owning this WebTransportBidirectionalStream.
</dd>
</dl>

		</section>
		<section id="bidirectional-stream-attributes">
<h3 title="Attributes">8.2. 属性</h3>

<dl>
	<dt>
`readable@mB
◎
readable, of type WebTransportReceiveStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Readable$slB
◎
The getter steps are to return this's [[Readable]].
</dd>

	<dt>
`writable@mB
◎
writable, of type WebTransportSendStream, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Writable$slB
◎
The getter steps are to return this's [[Writable]].
</dd>
</dl>

		</section>
		<section id="bidirectional-stream-procedures">
<h3 title="Procedures">8.3. 手続-</h3>

<div class="algo">
<p>
`WebTransportBidirectionalStream$I を
`作成する@wtB
ときは、
所与の
( `双方向$な`~WebTransport~stream$ %内部~stream, `WebTransport$I ~obj %~transport, %送信-順序 )
に対し，
次の手続きを走らす：
◎
To create a WebTransportBidirectionalStream with a bidirectional WebTransport stream internalStream, a WebTransport object transport, and a sendOrder, run these steps.
</p>
<ol>
	<li>
%可読~stream ~LET `WebTransportReceiveStream$I を`作成する$wtR( %内部~stream, %~transport )
◎
Let readable be the result of creating a WebTransportReceiveStream with internalStream and transport.
</li>
	<li>
%可書~stream ~LET `WebTransportSendStream$I を`作成する$wtS( %内部~stream, %~transport, %送信-順序 )
◎
Let writable be the result of creating a WebTransportSendStream with internalStream, transport, and sendOrder.
</li>
	<li>
%~stream ~LET `新たな$ `WebTransportBidirectionalStream$I
— その
⇒＃
`Readable$slB ~SET %可読~stream,
`Writable$slB ~SET %可書~stream,
`Transport$slB ~SET %~transport
◎
Let stream be a new WebTransportBidirectionalStream, with:
• [[Readable]]
•• readable
• [[Writable]]
•• writable
• [[Transport]]
•• transport
</li>
	<li>
~RET %~stream
◎
Return stream.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="web-transport-error-interface">
<h2 title="WebTransportError Interface">9. `WebTransportError^I ~interface</h2>

<p>
`WebTransportError@I
は
`DOMException$I の下位classであり，
次に挙げるいずれかを表現する：
◎
WebTransportError is a subclass of DOMException that represents
</p>
<ul>
	<li>
［
~server／~network
］から来ている~error
◎
An error coming from the server or the network, or
</li>
	<li>
~clientが起動した中止-演算~用の事由
◎
A reason for a client-initiated abort operation.
</li>
</ul>

<pre class="idl">
[`Exposed$=(Window,Worker), `Serializable$, `SecureContext$]
interface `WebTransportError$I : `DOMException$I {
  `constructor＠#dom-webtransporterror-webtransporterror$(optional `DOMString$ %message = "", optional `WebTransportErrorOptions$I %options = {});

  readonly attribute `WebTransportErrorSource$I `source$mE;
  readonly attribute `unsigned long$? `streamErrorCode$mE;
};

dictionary `WebTransportErrorOptions@I {
  `WebTransportErrorSource$I `source@mbE = "stream";
  [`Clamp$] `unsigned long$? `streamErrorCode@mbE = null;
};

enum `WebTransportErrorSource@I {
  `stream@l,
  `session@l,
};
</pre>

<div class="algo">
<p>
`~WebTransport用の例外を作成する@
ときは、
所与の
( %~source, %~code （省略時は ~NULL ） )
に対し：
</p>
<ol>
	<li>
%~option群 ~LET 新たな `WebTransportErrorOptions$I
— その
⇒＃
`source$mbE ~SET %~source,
`streamErrorCode$mbE ~SET %~code
</li>
	<li>
%~error ~LET `新たな$ `WebTransportError$I
</li>
	<li>
%~error 上の `new WebTransportError$m 構築子~手続き( "", %~option群 )
</li>
	<li>
~RET %~error
</li>
</ol>

<p class="trans-note">【
この手続きは、
他所を集約するための，この訳による追加。
原文は，構築子~手続きを利用していないが、
次節に述べられる各~内部~slotを初期化する必要があるはずなので，追加している
— 原文は`~message$eXをどう初期化するか何も述べていないので、
%message 引数には，`とりあえず^em空~文字列を渡している
（本当は、何らかの`実装定義$な値に初期化されるかもしれない）。
】</p>
</div>

		<section id="web-transport-error-internal-slots">
<h3 title="Internal slots">9.1. 内部~slot</h3>

<p>
各 `WebTransportError$I は、
次に挙げる内部~slotを有する
— 各項に与える記述は規範的ではない：
◎
A WebTransportError has the following internal slots.
◎
Internal Slot｜Description (non-normative)
</p>
<dl>
	<dt>`Source@sl</dt>
	<dd>
ある `WebTransportErrorSource$I
— この~errorの~sourceを指示する。
◎
A WebTransportErrorSource indicating the source of this error.
</dd>

	<dt>`StreamErrorCode@sl</dt>
	<dd>
~NULL ／
この~error用の応用~protocol~error~code
◎
The application protocol error code for this error, or null.
</dd>
</dl>

		</section>
		<section id="web-transport-error-constructor1">
<h3 title="Constructor">9.2. 構築子</h3>

<div class="algo">
<p>
`new WebTransportError(message, options)@m
構築子~手続きは：
◎
The new WebTransportError(message, options) constructor steps are:
</p>
<ol>
	<li>
<p>
コレの
⇒＃
`名前$eX ~SET `WebTransportError^l,
`~message$eX ~SET %~message,
`Source$sl ~SET %~option群 . `source$mbE,
`StreamErrorCode$sl ~SET %~option群 . `streamErrorCode$mbE,
◎
Set this’s name to "WebTransportError".
◎
Set this’s message to message.
◎
Set this’s internal slots as follows:
• [[Source]]
•• options.source
• [[StreamErrorCode]]
•• options.streamErrorCode
</p>

<p class="note">注記：
この名前に対応付けられる旧来の~codeは無いので、
コレの `code$m は 0 になる。
◎
Note: This name does not have a mapping to a legacy code, so this's code is 0.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="web-transport-error-attributes">
<h3 title="Attributes">9.3. 属性</h3>

<dl>
	<dt>
`source@mE
◎
source, of type WebTransportErrorSource, readonly
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `Source$sl
◎
The getter steps are to return this's [[Source]].
</dd>

	<dt>
`streamErrorCode@mE
◎
streamErrorCode, of type unsigned long, readonly, nullable
</dt>
	<dd class="algo">
取得子~手続きは
⇒
~RET コレ . `StreamErrorCode$sl
◎
The getter steps are to return this's [[StreamErrorCode]].
</dd>
</dl>

		</section>
		<section id="web-transport-error-serialization">
<h3 title="Serialization">9.4. 直列化</h3>

<p>
`WebTransportError$I ~objは`直列化-可能$である
— その：
◎
WebTransportError objects are serializable objects.＼
</p>
<ul>
	<li class="algo">
<p>
その`直列化~手続き$は、
所与の
( %値, %直列形 )
に対し：
◎
Their serialization steps, given value and serialized, are:
</p>
		<ol>
			<li>
`DOMException$I 用の`直列化~手続き$( %値, %直列形 )
◎
Run the DOMException serialization steps given value and serialized.
</li>
			<li>
%直列形 . `Source^sl ~SET %値 . `Source$sl
◎
Set serialized.[[Source]] to value.[[Source]].
</li>
			<li>
%直列形 . `StreamErrorCode^sl ~SET %値 . `StreamErrorCode$sl
◎
Set serialized.[[StreamErrorCode]] to value.[[StreamErrorCode]].
</li>
		</ol>
	</li>
	<li class="algo">
<p>
その`逆直列化~手続き$は、
所与の
( %直列形, %値 )
に対し：
◎
Their deserialization steps, given serialized and value, are:
</p>
		<ol>
			<li>
`DOMException$I 用の`逆直列化~手続き$( %直列形, %値 )
◎
Run the DOMException deserialization steps given serialized and value.
</li>
			<li>
%値 . `Source$sl ~SET %直列形 . `Source^sl
◎
Set value.[[Source]] to serialized.[[Source]].
</li>
			<li>
%値 . `StreamErrorCode$sl ~SET %直列形 . `StreamErrorCode^sl
◎
Set value.[[StreamErrorCode]] serialized.[[StreamErrorCode]].
</li>
		</ol>
	</li>
</ul>

		</section>
	</section>
	<section id="protocol-mapping">
<h2 title="Protocol Mappings">10. ~protocol対応付け</h2>

◎非規範的

<p>
この節では、［
この仕様に定義した~methodたち
］を成す［
~QUIC~protocol `QUIC$r の挙動
］を［
`WEB-TRANSPORT-HTTP3$r を用立てる
］下で述べる。
~buffer化に因り、
原因から即時に効果が生じるとは限らない。
【以下の各~表tの 1 列目に原因, 2 列目に効果が挙げられる。】
◎
This section describes the [QUIC] protocol behavior of methods defined in this specification, utilizing [WEB-TRANSPORT-HTTP3]. Cause and effect may not be immediate due to buffering.＼
</p>

<p>
［
`WebTransportError$I ~error内の応用 `streamErrorCode$mE %~code
］と［
【~HTTP3における】 %~HTTP~error~code
］は、
`WEB-TRANSPORT-HTTP3$r `§ 4.3＠~WT-HTTP3#resetting-data-streams$【！4.3】
にて指定されるとおりに，相互に変換される。
◎
The application streamErrorCode in the WebTransportError error is converted to an httpErrorCode, and vice versa, as specified in [WEB-TRANSPORT-HTTP3] Section 4.3.
</p>

<div>
<table class="_wt-effect grid-table"><thead>
<tr><th>~API~method
<th>~QUIC~protocolにおける動作
<tbody>

<tr><td>
<code>`writable$mB.`abort(error)$ws</code>
<td>`設定し直す$WT( %~code )
— これは、
%~HTTP~error~code を伴う `RESET_STREAM$ft を送信する

<tr><td>
<code>`writable$mB.`close$ws()</code>
<td>~FIN~bitを伴う `STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`write()$dw</code>
<td>`STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`close()$dw</code>
<td>~FIN~bitを伴う `STREAM^ft を`送信する$WT

<tr><td>
<code>`writable$mB.getWriter().`abort(error)$dw</code>
<td>`設定し直す$WT( %~code )
— これは、
%~HTTP~error~code を伴う `RESET_STREAM$ft を送信する

<tr><td>
<code>`readable$mB.`cancel(error)$rs</code>
<td>`送信を停止させる$WT( %~code )
— これは，
%~HTTP~error~code を伴う `STOP_SENDING$ft を送信する

<tr><td>
<code>`readable$mB.getReader().`cancel(error)$gr</code>
<td>`送信を停止させる$WT( %~code )
— これは，
%~HTTP~error~code を伴う `STOP_SENDING$ft を送信する

<tr><td>
<code>wt.`close(closeInfo)$mT</code>
<td>`~WebTransport~sessionを終了する$( %~session, %closeInfo[ "`closeCode$mb" ], %closeInfo[ "`reason$mb" ] )
</table>
◎
API Method｜QUIC Protocol Action
writable.abort(error)｜sends RESET_STREAM with httpErrorCode
writable.close()｜sends STREAM with FIN bit set
writable.getWriter().write()｜sends STREAM
writable.getWriter().close()｜sends STREAM with FIN bit set
writable.getWriter().abort(error)｜sends RESET_STREAM with httpErrorCode
readable.cancel(error)｜sends STOP_SENDING with httpErrorCode
readable.getReader().cancel(error)｜sends STOP_SENDING with httpErrorCode
wt.close(closeInfo)｜terminates session with closeInfo
</div>

<div>
<table class="_wt-effect grid-table"><thead>
<tr><th>
~QUIC~protocolにおける動作
<th>~API効果
<tbody>

<tr><td>
%~HTTP~error~code を伴う `STOP_SENDING$ft を受信した
<td> `writable$mB を`~errorにする$WS( `streamErrorCode$mE ) 

<tr><td>`STREAM^ft を`受信-$WTした
<td>
<code>(await `readable$mB.getReader().`read()$dr).value</code>
【に反映される】

<tr><td>~FIN~bitを伴う `STREAM^ft を`受信-$WTした
<td>
<code>(await `readable$mB.getReader().`read()$dr).done</code>
【に反映される】

<tr><td>
%~HTTP~error~code を伴う `RESET_STREAM$ft を受信した
<td>`readable$mB を`~errorにする$RS( `streamErrorCode$mE )

<tr><td>
~sessionは~cleanに`終了され$た( %~code, %事由 )
【！with closeInfo】
<td>
<code>(await wt.`closed$mT).closeInfo</code>
【に反映されること】に加え，
~openな各~streamを`~errorにする$RS( )

<tr><td>~network~error
<td>
<code>(await wt.`closed$mT)</code>
を却下することに加え，
~openな各~streamを`~errorにする$RS( )
</table>
◎
QUIC Protocol Action｜API Effect
received STOP_SENDING with httpErrorCode｜errors writable with streamErrorCode
received STREAM｜(await readable.getReader().read()).value
received STREAM with FIN bit set｜(await readable.getReader().read()).done
received RESET_STREAM with httpErrorCode｜errors readable with streamErrorCode
Session cleanly terminated with closeInfo｜(await wt.closed).closeInfo, and errors open streams
Network error｜(await wt.closed) rejects, and errors open streams
</div>


<p class="note">注記：
`QUIC$r § 3.2 にて論じられたとおり、
`RESET_STREAM$ft ~frameの受領は，応用に常に指示されるとは限らない。
`RESET_STREAM$ft の受領は、
即時に通達され得る
— それに伴い、
~stream~dataの送達は中断され，消費されてない~dataは破棄される。
しかしながら，即時に通達するよう要求されてはいない。
また、
~stream~dataは完全に受信されたが，当の応用により まだ読取られてない場合、
`RESET_STREAM$ft 通達は，抑止され得る。
◎
Note: As discussed in [QUIC] Section 3.2, receipt of a RESET_STREAM frame is not always indicated to the application. Receipt of the RESET_STREAM can be signaled immediately, interrupting delivery of stream data with any data not consumed being discarded. However, immediate signaling is not required. Also, if stream data is completely received but has not yet been read by the application, the RESET_STREAM signal can be suppressed.
</p>

<div>
<table class="_wt-effect grid-table"><thead>
<tr><th>~WebTransport~protocolにおける動作
<th>~API効果
<tbody>

<tr><td>`DRAIN_WEBTRANSPORT_SESSION$ft を受信した
<td>
<code>await wt.`draining$mT</code>
【に反映される】
</table>
◎
WebTransport Protocol Action｜API Effect
received DRAIN_WEBTRANSPORT_SESSION｜await wt.draining
</div>

<div>
<table class="_wt-effect grid-table"><thead>
<tr><th>~HTTP3~protocolにおける動作
<th>~API効果
<tbody>

<tr><td>`GOAWAY$ft を受信した
<td>
<code>await wt.`draining$mT</code>
【に反映される】
</table>
◎
HTTP/3 Protocol Action｜API Effect
received GOAWAY｜await wt.draining
</div>

	</section>
	<section id="privacy-security">
<h2 title="Privacy and Security Considerations">11. ~privacy／~securityの考慮点</h2>

◎非規範的

<p>
この節は、
新たな挙動を指定するものではなく，
この仕様を成す他の各部にて すで呈示した情報を要約する。
◎
it specifies no new behaviour, but instead summarizes information already present in other parts of the specification.
</p>

		<section id="confidentiality">
<h3 title="Confidentiality of Communications">11.1. 通信の機密性</h3>

<p>
通信が場を占めている事実は、
~networkを観測できる敵対者たちからは隠せないので，
公な情報とみなされる。
◎
The fact that communication is taking place cannot be hidden from adversaries that can observe the network, so this has to be regarded as public information.
</p>

<p>
この文書~内で述べた~transport~protocolを成すすべては，［
~TLS `RFC8446$r またはそれと意味論的に等価な~protocol
］を利用するので、
~TLSを成すすべての~security~propを供する
— 流通の［
機密性と完全性
］も含めて。
~HTTP越しの~WebTransportは，`外方＠~HTTPinfra#outbound$への~HTTP要請と同じ［
証明書~検証y用の仕組み
］を利用するので、
~remote~serverへの認証は，同じ公開鍵~基盤に依拠している。
~WebTransportにおいては、
証明書~検証yにおける~errorは致命的であり，［
証明書~検証を迂回することを許容する `interstitial^en
］として可用なものは無い。
◎
All of the transport protocols described in this document use either TLS [RFC8446] or a semantically equivalent protocol, thus providing all of the security properties of TLS, including confidentiality and integrity of the traffic. WebTransport over HTTP uses the same certificate verification mechanism as outbound HTTP requests, thus relying on the same public key infrastructure for authentication of the remote server. In WebTransport, certificate verification errors are fatal; no interstitial allowing bypassing certificate validation is available.
</p>

		</section>
		<section id="state-persistence">
<h3 title="State Persistence">11.2. 状態の持続性</h3>

<p>
~WebTransport自体は、
新たな［
【利用者に】一意な識別子／
状態を持続的に格納する仕方
］を作成するものでも，
既存の持続的な状態を~serverに自動的に公開するものでもない。
一例として、
`WEB-TRANSPORT-HTTP3$r,
`WEB-TRANSPORT-HTTP2$r
は，どちらも［
~cookieを送信しない／
~HTTP認証を~supportしない／
~cache法を無効~化する仕組みは無い
］。
それらは，~TLSを利用するので、
~TLSにおける持続的な状態
— ~TLS~session~ticketなど —
を継承する。
そのような状態は、
受動的な~network観測者からは可視にならないが，
~serverにより［
同じ~clientからの異なる接続どうしを相関する
］ためにも利用され得る。
◎
WebTransport does not by itself create any new unique identifiers or new ways to persistently store state, nor does it automatically expose any of the existing persistent state to the server. For instance, neither [WEB-TRANSPORT-HTTP3] nor [WEB-TRANSPORT-HTTP2] send cookies or support HTTP authentication or caching invalidation mechanisms. Since they do use TLS, they inherit TLS persistent state such as TLS session tickets, which while not visible to passive network observers, could be used by the server to correlate different connections from the same client.
</p>

		</section>
		<section id="protocol-security">
<h3 title="Protocol Security">11.3. ~protocol~security</h3>

<p>
~WebTransportは、
`WEB-TRANSPORT-OVERVIEW$r にて述べられる要件の集合を課す
— それは、
次に挙げるものを含む：
◎
WebTransport imposes a set of requirements as described in [WEB-TRANSPORT-OVERVIEW], including:
</p>
<ol>
	<li>
~remote~serverが［
~WebTransport~protocolが利用-中にあることを自覚する
］ことを確保することに加え、
~remote~serverには［
~WebTransport~protocolを利用する用意がある
］ことを確認すること。
`WEB-TRANSPORT-HTTP3$r は、
~WebTransport~protocolを識別するために［
~ALPN `RFC7301$r,
`~HTTP3設定＠~HTTPv3#setting$,
`:protocol^h `疑似-~header＠~HTTPv3#pseudo-header$†
］が成す組合n利用する。
【† `:protocol^h は、~HTTP3には直に関係しない ~RFC 8441 に定義される。】
◎
Ensuring that the remote server is aware that the WebTransport protocol is in use and confirming that the remote server is willing to use the WebTransport protocol. [WEB-TRANSPORT-HTTP3] uses a combination of ALPN [RFC7301], an HTTP/3 setting, and a :protocol pseudo-header to identify the WebTransport protocol.
</li>
	<li>
［
~transport~sessionを出生した資源
］の生成元に基づいて，接続を~filterすることを~serverに許容する。
この情報【生成元】は、
~session確立~要請の `Origin$h ~header~fieldが運ぶ。
◎
Allowing the server to filter connections based on the origin of the resource originating the transport session. The Origin header field on the session establishment request carries this information.
</li>
</ol>

<p>
関係する~protocol~securityの考慮点は、
`WEB-TRANSPORT-HTTP3$r `§ ~securityの考慮点＠~WT-HTTP3#security-considerations$
にて述べられる。
◎
Protocol security considerations related are described in the Security Considerations sections of [WEB-TRANSPORT-HTTP3].
</p>

<p>
~networking~APIは、
局所~networkで可用な~hostを走査するために共通的に利用され得るので，［
指紋収集や他の形を成す攻撃
］に利用される。
~WebTransportは、
この問題に対し`~WebSocketによる~approach＠~WEBSOCKET#feedback-from-the-protocol$に従う
⇒
【~WebTransportに】特有な接続~errorは、
端点が~WebTransport端点であることが検証yされるまでは，返されない。
したがって、
~Web応用は，所与の端点が［
存在しないのか,
~Webからの接続を受容する用意がないのか
］を判別し得ない。
◎
Networking APIs can be commonly used to scan the local network for available hosts, and thus be used for fingerprinting and other forms of attacks. WebTransport follows the WebSocket approach to this problem: the specific connection error is not returned until an endpoint is verified to be a WebTransport endpoint; thus, the Web application cannot distinguish between a non-existing endpoint and the endpoint that is not willing to accept connections from the Web.
</p>

		</section>
		<section id="certificate-hashes">
<h3 title="Authentication using Certificate Hashes {#certificate-hashes}">11.4. 証明書~hash群を利用している認証</h3>

<p>
~UAは、
通常は，［
自身 ↔ ~remote端点
］間の~TLS接続を［
~URL内の~server名に対し供された~TLS~server証明書
］の妥当性を検証yすることにより認証する `RFC6125$r 。
これは、
~server証明書を［
~UAにより保守される信用-~anchorのうちいずれか
］へ連鎖することにより成遂げられる
— 各~信用-~anchorは、
証明書~内の~server名を認証する責務がある。
この~systemは、
以下では，~Web~PKIと称される。
◎
Normally, a user agent authenticates a TLS connection between itself and a remote endpoint by verifying the validity of the TLS server certificate provided against the server name in the URL [RFC6125]. This is accomplished by chaining server certificates to one of the trust anchors maintained by the user agent; the trust anchors in question are responsible for authenticating the server names in the certificates. We will refer to this system as Web PKI.
</p>

<p>
この~APIは，
~remote~network端点へ接続する能力を~web応用に供するが、
端点は［
その~server名ではなく，特定の~server証明書
］により認証される。
この仕組みは、
長期的な証明書を取得するのは難題になり得るような端点
— その資質において短命な~host
（例：その場限りの~virtual~machine）や，
公に~route可能でない~hostを含む —
への接続を可能化する。
この仕組みは、
個々の接続~用に［
~Web~PKIに基づく認証
］を代用するので，
両者の~security~propを比較する必要がある。
◎
This API provides web applications with a capability to connect to a remote network endpoint authenticated by a specific server certificate, rather than its server name. This mechanism enables connections to endpoints for which getting long-term certificates can be challenging, including hosts that are ephemeral in nature (e.g. short-lived virtual machines), or that are not publicly routable. Since this mechanism substitutes Web PKI-based authentication for an individual connection, we need to compare the security properties of both.
</p>

<p>
ある~remote~serverが，
~TLS~handshakeを成功裡に遂行-可能になるのは、［
それが，指定された証明書の公開鍵に対応している秘密鍵を所蔵している【！posess】
］場合に限られる。
この~APIは、
それらの~hashを利用して証明書を識別する。
それが~secureになるのは、［
利用された暗号用~hash関数が，
第二原像攻撃に対する耐性（ `second-preimage resistance^en ）を有する場合
］に限られる。
この文書にて定義される関数は，~SHA-256に限られるが、
この~APIは，［
新たな~hash関数を導入するための仕方
］を［
複数個の［
( ~algo, ~hash )
が成す~pair
］を指定すること
］を許容することを通して供する。
◎
A remote server will be able to successfully perform a TLS handshake only if it posesses the private key corresponding to the public key of the certificate specified. The API identifies the certificates using their hashes. That is only secure as long as the cryptographic hash function used has second-preimage resistance. The only function defined in this document is SHA-256; the API provides a way to introduce new hash functions through allowing multiple algorithm-hash pairs to be specified.
</p>

<p>
重要なこととして、
~Web~PKIは，~security用に追加的な仕組みを供することに注意
— 単純に［
ある~server名に対し信用が成す連鎖を確立する
］ことに加えて。
それらのうち一つに，証明書~廃止の取扱いがある。
利用される証明書が短命である事例では、
そのような仕組みは必要yでない。
他の事例では、
~Web応用は，証明書~hashを支給するための仕組みを考慮する必要がある
— 一例として、
当の~hashが~cacheされた~HTTP資源として供された場合，
当の~cacheは［
対応している証明書が，弱体化に因り交替された場合
］には無効~化される必要がある。
~Web~PKIにより供される別の~security特能は、
鍵~生成に伴われるある種の課題に抗する防護策である
— 弱いことが既知な鍵を伴う証明書を却下するなど。
この仕様は，特有な指導を何も供さないが、
各~browserは，実装定義な挙動の一部として それらを却下してもヨイ。
◎
It is important to note that Web PKI provides additional security mechanisms in addition to simply establishing a chain of trust for a server name. One of them is handling certificate revocation. In cases where the certificate used is ephemeral, such a mechanism is not necessary. In other cases, the Web application has to consider the mechanism by which the certificate hashes are provisioned; for instance, if the hash is provided as a cached HTTP resource, the cache needs to be invalidated if the corresponding certificate has been rotated due to compromise. Another security feature provided by the Web PKI are safeguards against certain issues with key generation, such as rejecting certificates with known weak keys; while this specification does not provide any specific guidance, browsers MAY reject those as a part of implementation-defined behavior.
</p>

<p>
~Web~PKIは、
各~証明書に対し，失効~期間~要件を施行する。
この要件は、
鍵が弱体化され得る視野を制限することに加え、［
鍵~交替を~supportして，それを能動的に遂行する
］よう~systemを設計することを~server運用者に強制する。
この理由から、
~WebTransportも，類似な失効~要件を課す
— 証明書は，短命なことが予期されるので、
失効~期間は 2 週間に制限される。
2 週間の期限は、
次に挙げるものの間で~balanceをとった結果である：
◎
Web PKI enforces an expiry period requirement on the certificates. This requirement limits the scope of potential key compromise; it also forces server operators to design systems that support and actively perform key rotation. For this reason, WebTransport imposes a similar expiry requirement; as the certificates are expected to be ephemeral or short-lived, the expiry period is limited to two weeks. The two weeks limit is a balance between＼
</p>
<ul>
	<li>
鍵~弱体化による帰結を最小~化するため，
失効~期限をアリな限り短く設定する。
◎
setting the expiry limit as low as possible to minimize consequences of a key compromise,＼
</li>
	<li>
各~機器にまたがる時計のずれを収容するに足るまで，長く保守する。
◎
and maintaining it sufficiently high to accomodate for clock skew across devices,＼
</li>
	<li>
［
~client側 ↔ ~server側
］間で証明書を同期するための~costを なるべく下げる。
◎
and to lower the costs of synchronizing certificates between the client and the server side.
</li>
</ul>

<p>
~WebTransport~APIは、
応用が複数の証明書~hashをまとめて指定できるようにする。
それは、
次を~clientに許容する
⇒
新たな証明書が行き渡るまでの期間において，
【それまでの証明書も可用になるよう】
複数の証明書を受容する。
◎
The WebTransport API lets the application specify multiple certificate hashes at once, allowing the client to accept multiple certificates for a period in which a new certificate is being rolled out.
</p>

<p>
~WebRTCにおける`類似な仕組み＠~CSP3#webrtc$と違って、
~WebTransportにおける~server証明書~hash~APIは，
~clientを認証するための手段を何ら供さない
— 事実、
~clientが［
~server証明書が何であるか／どう `contact^en するか
］を知るだけでは足らない。
応用は、
必要yなら，
~clientの識別情報を帯域内に確立する必要がある。
◎
Unlike a similar mechanism in WebRTC, the server certificate hash API in WebTransport does not provide any means of authenticating the client; the fact that the client knows what the server certificate is or how to contact it is not sufficient. The application has to establish the identity of the client in-band if necessary.
</p>

		</section>
		<section id="fingerprinting">
<h3 title="Fingerprinting and Tracking">11.5. 指紋収集と追跡</h3>

<p>
この~APIは、［
~network活動を生成する能,
この活動の効果を細かく観測する能
］を~siteに供する。
この仕方で得される情報は，
【利用者を】`識別している＠~INFRA#tracking-vector$かもしれない。
◎
This API provides sites with the ability to generate network activity and closely observe the effect of this activity. The information obtained in this way might be identifying.
</p>

<p>
重要なこととして、
他の~web~platform~API
— `FETCH$r, `WEBRTC$r など —
も，ごく類似な~networking能力を供することを認識すること。
したがって、
~WebTransport~APIを追加することに因る~privacyへの悪影響は，
実質無いに等しい。
この節における考慮点は、
他の~networking能力にも等しく適用される。
◎
It is important to recognize that very similar networking capabilities are provided by other web platform APIs (such as fetch and [webrtc]). The net adverse effect on privacy due to adding WebTransport is therefore minimal. The considerations in this section applies equally to other networking capabilities.
</p>

<p>
~network特性を測定するためには、［
~networkが利用されていて，
その利用度が成す効果が測定される
］ことが要求される
— この~APIはどちらも可能化する。
~WebTransportは、［
~siteが選んだ~serverへ向けて~network活動を生成する能,
その効果を観測する能
］を~siteに供する。
［
~network経路の安定的な~prop,
~network利用度が成す動的な効果
］どちらも観測nがアリになる。
◎
Measuring network characteristics requires that the network be used and that the effect of that usage be measured, both of which are enabled by this API. WebTransport provides sites with an ability to generate network activity toward a server of their choice and observe the effects. Observations of both the stable properties of a network path and dynamic effect of network usage are possible.
</p>

<p>
~networkについての情報は、
次に挙げるものを通して，~serverに可用になる：
◎
Information about the network is available to the server either＼
</p>
<ul>
	<li>
~server自前の~networking~stackを通して直に
◎
directly through its own networking stack,＼
</li>
	<li>
~clientにより~dataが［
消費される／伝送される
］~rateを通して間接的に
◎
indirectly through the rate at which data is consumed or transmitted by the client,＼
</li>
	<li>
この~APIにより供される統計の一部として
（ <a href="#web-transport-stats">§ `WebTransportStats^I 辞書</a> を見よ）
◎
or as part of the statistics provided by the API (see § 5.12 WebTransportStats Dictionary).＼
</li>
</ul>
<p>
その帰結として、［
~UAにおける情報に対する制約
］は，［
これらの~privacy~riskを管理するために必要かもしれない仕組み
］として唯一のものではない。
◎
Consequently, restrictions on information in user agents is not the only mechanism that might be needed to manage these privacy risks.
</p>

			<section id="fp-static">
<h4 title="Static Observations">11.5.1. 静的な観測n</h4>

<p>
~siteは、［
~UA ↔ 自身が選んだ~server
］間における［
可用な~network容量／往復~時間（~RTT）
］を観測できる。
この情報は、［
他の追跡~行路と組合されたとき
］に【利用者を】識別し得る。
~RTTはまた、
~UAの物理的な所在についての何かを露呈し得る
— とりわけ、
複数の立地から複数の測定を為せる場合に。
◎
A site can observe available network capacity or round trip time (RTT) between a user agent and a chosen server. This information can be identifying when combined with other tracking vectors. RTT can also reveal something about the physical location of a user agent, especially if multiple measurements can be made from multiple vantage points.
</p>

<p>
~networkingは共有されるが、
~networkは散発的に利用されることが多い
— そのことは、
~siteは［
他と競わない／負荷が軽い
］~network経路の［
容量, 往復~時間
］を観測-可能になることが多いことを意味する。
これらの~propは、
多くの人々において安定的である
— ~network上での彼らの所在は変化しないことに加え、
~network~bottleneck（それは可用な容量を決定する）の位置は，~UAに近いこともあるので。
◎
Though networking is shared, network use is often sporadic, which means that sites are often able to observe the capacity and round trip times of an uncontested or lightly loaded network path. These properties are stable for many people as their network location does not change and the position of network bottlenecks--which determine available capacity--can be close to a user agent.
</p>

			</section>
			<section id="fp-shared">
<h4 title="Shared Networking">11.5.2. 共用~networking</h4>

<p>
`contested^en ~link【？】は、
`非同一-~site認識＠https://w3ctag.github.io/privacy-principles/#dfn-cross-site-recognition$を可能化する機会を~siteに呈示する
— それは、
野放図な追跡 `UNSANCTIONED-TRACKING$r を遂行するために利用されるかもしれない。
~network容量は，有限な共用~資源なので、
異なる~siteに同時並行的に~accessする~UAは，
各~siteに呈示された識別情報どうしの繋がりを露呈するかもしれない。
◎
Contested links present sites with opportunities to enable cross-site recognition, which might be used to perform unsanctioned tracking [UNSANCTIONED-TRACKING]. Network capacity is a finite shared resource, so a user agent that concurrently accesses different sites might reveal a connection between the identity presented to each site.
</p>

<p>
ある~siteにおける~networking能力の利用は、
他の~siteに可用な容量を抑制する
— それは、
~networking~APIを利用して観測され得る。
~network［
利用度, 計量
］は動的に変化し得るので、
どの変化も~real-timeで観測され得る。
これは、
その［
同じ利用者から出生している異なる~site上での活動
］について確証を高めることを~siteに許容するかもしれない。
◎
The use of networking capabilities on one site reduces the capacity available to other sites, which can be observed using networking APIs. Network usage and metrics can change dynamically, so any change can be observed in real time. This might allow sites to increase confidence that activity on different sites originates from the same user.
</p>

<p>
~UAは、［
作動中でない／
~focusを得ていない
（ `HTML^cite `§ ~focus＠~HTMLinteraction#focus$）
］~site用には，~feedbackする仕組み
— 統計（ <a href="#web-transport-stats">§ `WebTransportStats^I 辞書</a> ）など —
への~accessを［
制限する／退行する
］こともできる。
注記したとおり、
これは，~serverが［
~network内の変化について観測nを為すこと
］を防止しない。
◎
A user agent could limit or degrade access to feedback mechanisms such as statistics (§ 5.12 WebTransportStats Dictionary) for sites that are inactive or do not have focus (HTML § 6.6 Focus). As noted, this does not prevent a server from making observations about changes in the network.
</p>

			</section>
			<section id="fp-pooled">
<h4 title="Pooled Sessions">11.5.3. ~poolされた~session</h4>

<p>
~networkingが共有される局面と類似に、
同じ接続に複数の~sessionが~poolされたとき，
ある~sessionからの情報は別の~sessionの活動により影響される。
ある~sessionは、
別の~sessionの活動についての情報
— 別の応用が~dataを送信している~rateなど —
を推定することもできる。
◎
Similar to shared networking scenarios, when sessions are pooled on a single connection, information from one session is affected by the activity of another session. One session could infer information about the activity of another session, such as the rate at which another application is sending data.
</p>

<p>
共有された接続の利用は、
すでに，~sessionどうしを相関することを~serverに許容している。
共有された~sessionの利用が，
求まれない非同一-~site認識を可能化するかもしれない所では、
`~network区分~key$の利用が，
~pool法を不能化する。
◎
The use of a shared connection already allows the server to correlate sessions. Use of a network partition key disables pooling where use of a shared session might enable unwanted cross-site recognition.
</p>

			</section>
		</section>
	</section>
	<section id="examples">
<h2 title="Examples">12. 例</h2>

		<section>
<h3 title="Sending a buffer of datagrams">12.1. ~datagramたちが成す~bufferの送信-法</h3>

◎非規範的

<p>
~datagramたちが成す~bufferの送信は、
`datagrams$mT の `writable$mD 属性を利用して達成できる。
次の例では、
~datagramたちは，
~transportがそれを送信するに準備済みな場合に限り送信される。
◎
Sending a buffer of datagrams can be achieved by using the datagrams' writable attribute. In the following example datagrams are only sent if the transport is ready to send.
</p>

<pre class="lang-js">
async function sendDatagrams(%url, %datagrams) {
  const %wt = new WebTransport(%url);
  const %writer = %wt.datagrams.writable.getWriter();
  for (const %bytes of %datagrams) {
    await %writer.ready;
    %writer.write(%bytes).catch(() =&gt; {});
  }
}
</pre>

		</section>
		<section>
<h3 title="Sending datagrams at a fixed rate">12.2. 固定的な~rateによる~datagram群の送信-法</h3>

◎非規範的

<p>
~datagram群を［
~transportがそれを送信するに準備済みか否か
］に関わらず固定的な~rateで送信することは、
単純に［
`datagrams$mT の `writable$mD を利用して，
`ready$mT 属性を利用しないこと
］により達成できる。
もっと複階的な局面では、
`ready$mT 属性を用立てれる。
◎
Sending datagrams at a fixed rate regardless if the transport is ready to send can be achieved by simply using datagrams' writable and not using the ready attribute. More complex scenarios can utilize the ready attribute.
</p>

<pre class="lang-js">
/* <span class="comment">
100 ~milli秒ごとに~datagramを送信する。
◎
Sends datagrams every 100 ms.
</span> */
async function sendFixedRate(%url, %createDatagram, %ms = 100) {
  const %wt = new WebTransport(%url);
  await %wt.ready;
  const %writer = wt.datagrams.writable.getWriter();
  const %bytes = createDatagram();
  setInterval(() =&gt; %writer.write(%bytes).catch(() =&gt; {}), %ms);
}
</pre>

		</section>
		<section>
<h3 title="Receiving datagrams">12.3. ~datagramの受信-法</h3>

◎非規範的

<p>
~datagramは、
`datagrams$mT の `readable$mD 属性から読取ることにより受信できる。
~NULL値は、
~packetが十分に素早く処理されていないことを指示し得る。
◎
Datagrams can be received by reading from the transport.datagrams.readable attribute. Null values may indicate that packets are not being processed quickly enough.
</p>

<pre class="lang-js">
async function receiveDatagrams(%url) {
  const %wt = new WebTransport(%url);
  for await (const %datagram of %wt.datagrams.readable) {
    /* <span class="comment">
%datagram を処理する
◎
Process the datagram
</span> */
  }
}
</pre>

		</section>
		<section>
<h3 title="Sending a stream">12.4. ~streamの送信-法</h3>

◎非規範的

<p>
~dataを~~一方向な~streamとして送信することは、
`createUnidirectionalStream()$mT 関数から返される~streamの書込器を利用して達成できる。
◎
Sending data as a one-way stream can be achieved by using the createUnidirectionalStream function and the resulting stream’s writer.
</p>

<pre class="lang-js">
async function sendData(%url, ...%data) {
  const %wt = new WebTransport(%url);
  const %writable = await %wt.createUnidirectionalStream();
  const %writer = %writable.getWriter();
  for (const %bytes of %data) {
    await %writer.ready;
    %writer.write(%bytes).catch(() =&gt; {});
  }
  await %writer.close();
}
</pre>

<p class="note">注記：
`write()^c からの~promiseを待受けること（ `await^c ）は、
~stream仕様により`忌避される＠~STREAMS#example-manual-write-dont-await$。
◎
The streams spec discourages awaiting the promise from write().
</p>

<p>
`ReadableStream$I から~pipeを通すことで，符号化も行える
— 例えば，
`TextEncoderStream$I を利用して。
◎
Encoding can also be done through pipes from a ReadableStream, for example using TextEncoderStream.
</p>

<pre class="lang-js">
async function sendText(%url, %readableStreamOfTextData) {
  const %wt = new WebTransport(%url);
  const %writable = await %wt.createUnidirectionalStream();
  await %readableStreamOfTextData
    .pipeThrough(new TextEncoderStream("utf-8"))
    .pipeTo(%writable);
}
</pre>

		</section>
		<section>
<h3 title="Receiving incoming streams">12.5. 流入~streamの受信-法</h3>

◎非規範的

<p>
流入~streamを読取ることは、
次により達成できる
⇒
`incomingUnidirectionalStreams$mT 属性~上で
各 `WebTransportReceiveStream$I を反復して，
そこからの各~chunkを反復して消費する。
◎
Reading incoming streams can be achieved by iterating over the incomingUnidirectionalStreams attribute, and then consuming each WebTransportReceiveStream by iterating over its chunks.
</p>

<pre class="lang-js">
async function receiveData(%url, %processTheData) {
  const %wt = new WebTransport(%url);
  for await (const %readable of %wt.incomingUnidirectionalStreams) {
    /* <span class="comment">
`IFFEs^en【？】 を個別に利用して各~streamを消費する,
~streamごとに~errorを報告する
◎
consume streams individually using IFFEs, reporting per-stream errors
</span> */
    ((async () =&gt; {
      try {
        for await (const %bytes of readable) {
          processTheData(%bytes);
        }
      } catch (%e) {
        console.error(%e);
      }
    })());
  }
}
</pre>

<p>
新たな `WritableStream$I へ~pipeすることを通して，復号も行える
— 例えば， `TextDecoderStream$I を利用して。
この例では、
~text出力は，他と前後されるべきでない
— したがって，回ごとに 1 個の~streamに限り読取る —
ものと見做す。
◎
Decoding can also be done through pipes to new WritableStreams, for example using TextDecoderStream. This example assumes text output should not be interleaved, and therefore only reads one stream at a time.
</p>

<pre class="lang-js">
async function receiveText(%url, %createWritableStreamForTextData) {
  const %wt = new WebTransport(%url);
  for await (const %readable of %wt.incomingUnidirectionalStreams) {
    /* <span class="comment">
出力を他と前後することなく，逐次的に消費する。
~errorは~streamごとに報告する。
◎
consume sequentially to not interleave output, reporting per-stream errors
</span> */
    try {
      await %readable
       .pipeThrough(new TextDecoderStream("utf-8"))
       .pipeTo(%createWritableStreamForTextData());
    } catch (%e) {
      console.error(%e);
    }
  }
}
</pre>

		</section>
		<section>
<h3 title="Complete example">12.6. 完全な例</h3>

◎非規範的

<p>
この例は、
次について~~説明する：
◎
This example illustrates＼
</p>
<ul>
	<li>
［
~close時の~promise, 準備済み時の~promise
］の利用
◎
use of the closed and ready promises,＼
</li>
	<li>
［
~client／~server
］による［
一方向~stream, 双方向~stream
］の~open法
◎
opening of uni-directional and bi-directional streams by either the client or the server,＼
</li>
	<li>
~datagramの［
送信-法, 受信-法
］
◎
and sending and receiving datagrams.
</li>
</ul>

<pre class="lang-js">
/* <span class="comment">
~page上の~event~logに~entryを追加する。
【！余計？任意選択で，指定された~CSS~classを適用して】
◎
Adds an entry to the event log on the page, optionally applying a specified CSS class.
</span> */

let %wt, %streamNumber, %datagramWriter;

connect.onclick = async () =&gt; {
  try {
    const %url = document.getElementById('url').value;

    %wt = new WebTransport(%url);
    addToEventLog('接続を起動しています...');
    await %wt.ready;
    addToEventLog(``^${(%wt.reliability == "reliable-only")? "TCP" : "UDP"} 接続は準備済み。``^);
    %wt.closed
      .then(() =&gt; addToEventLog('接続は正常に~closeされました。'))
      .catch(() =&gt; addToEventLog('接続は中途で~closeされました。', 'error'));

    %streamNumber = 1;
    %datagramWriter = %wt.datagrams.writable.getWriter();

    %readDatagrams();
    %acceptUnidirectionalStreams();
    document.forms.sending.elements.send.disabled = false;
    document.getElementById('connect').disabled = true;
  } catch (%e) {
    addToEventLog(``^接続に失敗しました。 ${%e}``^, 'error');
  }
}

sendData.onclick = async () =&gt; {
  const %form = %document.forms.sending.elements;
  const %data = %sending.data.value;
  const %bytes = new TextEncoder('utf-8').encode(%data);
  try {
    switch (%form.sendtype.value) {
      case 'datagram': {
        await %datagramWriter.ready;
        %datagramWriter.write(%bytes).catch(() =&gt; {});
        addToEventLog(``^~datagramを送信しました: ${%data} ``^);
        break;
      }
      case 'unidi': {
        const %writable = await %wt.createUnidirectionalStream();
        const %writer = %writable.getWriter();
        %writer.write(%bytes).catch(() =&gt; {});
        await %writer.close();
        addToEventLog(``^一方向~streamを~dataと伴に送信しました: ${%data}``^);
        break;
      }
      case 'bidi': {
        const %duplexStream = await %wt.createBidirectionalStream();
        const %n = %streamNumber++;
        readFromIncomingStream(%duplexStream.readable, %n);

        const %writer = %duplexStream.writable.getWriter();
        %writer.write(%bytes).catch(() =&gt; {});
        await %writer.close();
        addToEventLog(``^双方向~stream #${%n} を~dataと伴に送信しました: ${%data}``^);
        break;
      }
    }
  } catch (%e) {
    addToEventLog(``^~dataの送信-中に~error: ${%e}``^, 'error');
  }
}

/* <span class="comment">
~EOFに到達するまで、
~datagram群を~event~logの中へ読取る。
◎
Reads datagrams into the event log until EOF is reached.
</span> */
async function readDatagrams() {
  try {
    const %decoder = new TextDecoderStream('utf-8');

    for await (const %data of %wt.datagrams.readable.pipeThrough(%decoder)) {
      addToEventLog(``^~datagramを受信しました: ${%data}``^);
    }
    addToEventLog('~datagramを読取りました。');
  } catch (%e) {
    addToEventLog(``^~datagramの読取n中に~error: ${%e}``^, 'error');
  }
}

async function acceptUnidirectionalStreams() {
  try {
    for await (const %readable of %wt.incomingUnidirectionalStreams) {
      const %number = %streamNumber++;
      addToEventLog(``^新たな流入~一方向~stream #${%number}``^);
      readFromIncomingStream(%readable, %number);
    }
    addToEventLog('一方向~streamを受容しました。');
  } catch (%e) {
    addToEventLog(``^~stream ${%e} の受容-中に~error。``^, 'error');
  }
}

async function readFromIncomingStream(%readable, %number) {
  try {
    const %decoder = new TextDecoderStream('utf-8');
    for await (const %data of %readable.pipeThrough(%decoder)) {
      addToEventLog(``^~stream #${%number} 上で~dataを受信しました: ${%data}``^);
    }
    addToEventLog(``^~stream #${%number} は~closeされました。``^);
  } catch (%e) {
    addToEventLog(``^~stream #${%number} から読取n中に~error: ${%e}``^, 'error');
    addToEventLog(``^    ${%e.message}``^);
  }
}

function addToEventLog(%text, %severity = 'info') {
  const %log = document.getElementById('event-log');
  const %previous = %log.lastElementChild;
  const %entry = document.createElement('li');
  %entry.innerText = %text;
  %entry.className = ``^`log^-${%severity}``^;
  %log.appendChild(%entry);

  /* <span class="comment">
%log 内のそれまでの~entryが可視であった場合、
新たな要素へ~scrollする。
◎
If the previous entry in the log was visible, scroll to the new element.
</span> */
  if (%previous &amp;&amp;
      %previous.getBoundingClientRect().top &lt; %log.getBoundingClientRect().bottom) {
    %entry.scrollIntoView();
  }
}
</pre>

		</section>
	</section>
	<section id="acknowledgements">
<h2 title="Acknowledgements">謝辞</h2>

<p lang="en">
The editors wish to thank the Working Group chairs and Team Contact, Jan-Ivar Bruaroey, Will Law and Yves Lafon, for their support.
</p>

<p>
`WebTransport$I ~interfaceは、
`W3C ORTC CG＠https://www.w3.org/community/ortc/$
にて初期に述べられた `QuicTransport^I ~interfaceに基づく
— それから，この仕様における利用-用に順応された。
◎
The WebTransport interface is based on the QuicTransport interface initially described in the W3C ORTC CG, and has been adapted for use in this specification.
</p>

	</section>
</main></div>
