<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Web IDL Standard — JavaScript binding（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>

:root {
	--code-color: light-dark( hsl(12 100% 33%), hsl(12 100% 73%) );
	--idl-color: light-dark( hsl(231 100% 23%), hsl(231 100% 83%) );
	--idl-bg-color: light-dark( hsl(204 80% 95%), hsl(204 80% 13%) );
}

code {
	color: var(--code-color);
}

/* 拡張d属性 */
.xattr {
	font-family: monospace0, monospace;
	color: var(--text-color-1);
}

/* IDL, JavaScript 型／値 */

.idltype,
.idlmember,
.idlvalue {
	font-family: monospace0, monospace;
	color: var(--idl-color);
}

/* JavaScript */
.js-property,
.js-error {
	color: var(--js-color);
}

/* 仮想の定数 */
i.const {
	text-decoration: underline;
}

	/* コードブロック */
pre {
	margin: 0.5em 0 0.5em 0.5em;
	padding: 0.5em 1em;
}

pre.webidl {
	background: var(--idl-bg-color);
}

/* 引用例 */
blockquote {
	border: dashed thin var(--N-color);
	padding: 0.5em;
	margin-left: 2em;
}

/* 文法 */
.g {
	font-style: italic;
}

.sym {
	color: var(--K-color);
}

/* アルゴリズム */

dd > :first-child {
	margin-top: 0;
}

/* table */

table {
	border-style: hidden hidden none hidden;
}
table thead {
	border-bottom: solid medium var(--dim-color);
}

table td, table th {
	border: solid thin var(--dim-color);
	border-top: none;
	padding:0.2em;
}

	/* 表 整形 */

#matrix-integers td,
#matrix-integers th {
	text-align: right;
	white-space: nowrap;
}
#matrix-integers th {
	min-width: 4em;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

const source_data = {
	toc_main: 'MAIN0',
};

Util.ready = function(){

	Util.switchWordsInit(source_data);
	return;
}

/*内容変換生成*/
source_data.generate = function(){

	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const tf_map = { T: 'true', F: 'false', 0: '0', 1: '1' };

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^§])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `~WEBIDL#biblio-${key.toLowerCase()}`;
	break;
case 'g': // 非終端記号／生成規則／regex
	href = `~WEBIDL#prod-${key}`;
	break;
case 'jE': // JS error 型
	href = `~WEBIDL#exceptiondef-${key.toLowerCase()}`;
	break;
case 'E': // error 名
	href = `~WEBIDL#${key.toLowerCase()}`;
	break;
case 'A': // JS 抽象演算
	href = `~TC39#sec-${key.toLowerCase()}`;
	break;
case 'x': // 拡張d属性
	href = `#${key}`;
	text = `[${key}]`;
	break;
case 'l': // literal
	text = `"<code class="literal">${key}</code>"`
	break;
case 'X': // byte value
	text = `0x${key}`;
	break;
case 'U': // Unicode code point
	return ( `<span class="code-point">U+${key}</span>` );
	break;
case 'sl': // 内部 slot
	text = `[[${key}]]`
	break;
case 'jI': // JS intrinsic object/prototype object/well-known symbol
	text = `%${key}%`;
	break;
//	jt: // JS 型, JS class
case 'jIsl':
	href = link_map[`jI.${key}`];
	if(!href) return match;//＊
	return (
`<span class="js-slot">[[Intrinsics]]</span>.<span class="js-slot">[[<a href="${href}"><code class="js-intrinsic">%${key}%</code></a>]]</span>`
	);
	break;
case 'desc': // JS property descriptor
	return desc(key);
	break;
case 'fI':
	href = `~WEBIDLissue/new?title=${key.replace(/ /g, '%20')}`;
	text = '課題を申請-';
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;

//	sym: 終端記号
//	char: Unicode 符号位置
//	i: i syntax変数
//	C: 仮想定数
//	mk: syntax強調
//	V: IDL 値
//	T: IDL 型
//	jp: JS property
//	jv: JS 値
//	jt: JS 型, JS class
//	sl: 内部 slot
//	op: 算術演算
//	A: JS 抽象演算
//	M: IDL メンバ
//	x: 拡張d属性

default:
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '§':
		text = ` <a href="${href}">§ ${text}</a> `;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}

	function desc(id){// JS プロパティ記述子
		const Val = (id.length > 3) ?
			`,
[[Value]]: ${TFmap(id.slice(4))}` : '';
		return (
`{ [[Writable]]: ${TFmap(id[0])}, \
[[Enumerable]]: ${TFmap(id[1])}, \
[[Configurable]]: ${TFmap(id[2])}${Val} \
}`
		);
		function TFmap(c){
			const s = tf_map[c];
			return s ?
				`<span class="js-value">${s}</span>` : 
				`<var>${c}</var>`;
		}
	}
}

source_data.populate = function(){

// 内容複製
	duplicate();
	
	function duplicate(){
		const visited = Object.create(null);
		const iter = document.createNodeIterator(
			E('MAIN0'), NodeFilter.SHOW_COMMENT, null, null
		);
		let node;
		while(node = iter.nextNode()){
			const id = node.data;
			if(id.slice(0, 3) !== 'cp-'){
				continue;
			}
			const e = visited[id] || E(id);
			if(!e){
				console.log('source not found: ' + id);
				continue;
			}
			if(!visited[id]){
				e.removeAttribute('id');
				visited[id] = e;
			}
			node.replaceWith(e.cloneNode(true));
		}
	}


/*
	Util.del_j();
	repeat('pre span[title]', function(e){
		e.textContent = e.title;//.replace(/^/gm, '// ');
	});
	repeat('h2, h3, h4, h5', function(e){
		const t = e.title;
		if(!t) return;
		e.textContent = e.textContent.replace(/\. .+/, '. ' + t);
	});
	repeat('.algorithm li', function(e){
		e.insertBefore(C('br'), e.firstChild);
	});

*/

}


</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Web IDL Standard
trans_update:2025-07-25
original_url:https://webidl.spec.whatwg.org/
	abbr_url:WEBIDLjs
page_state_key:WEBIDL
spec_status:LS
ref_id_prefix:biblio-
ref_id_lowercase:true
trans_1st_pub:2013-08-22


●●class_map
g:g
sym:sym
char:char
C:const
E:error
jE:js-error
T:idltype
V:idlvalue
jv:js-value
jp:js-property
jt:js-type
jI:js-intrinsic
A:abstract
M:idlmember
x:xattr
sl:js-slot
X:hex-value
et:event-type
op:op

●●tag_map
g:span
sym:code
char:span
sup:sup
c:code
et:code
i:i
C:i
mk:mark
E:code
jE:code
V:code
T:code
jt:code
jI:code
jp:code
jv:code
sl:span
op:span
A:span
M:code
x:span
X:span
var:var
em:em
cite:cite

●●original_id_map

ol-callable:
ol-optionality-list:
ol-type-list:
dfn-variadic-argument:
idl-integers:
idl-floats:
dfn-function-like:

dfn-convert-javascript-to-idl-value:dfn-convert-ecmascript-to-idl-value

	● 旧 id
	javascript-binding:ecmascript-binding
	javascript-throw:ecmascript-throw
	js-environment:es-environment
	js-type-mapping:es-type-mapping
	dfn-convert-idl-to-javascript-value:dfn-convert-idl-to-ecmascript-value
	js-any:es-any
	js-undefined:void-to-es
	js-undefined:es-to-void
	js-undefined:es-void
	js-undefined:es-undefined
	js-boolean:es-boolean
	js-integer-types:es-integer-types
	js-byte:es-byte
	js-octet:es-octet
	js-short:es-short
	js-unsigned-short:es-unsigned-short
	js-long:es-long
	js-unsigned-long:es-unsigned-long
	js-long-long:es-long-long
	js-unsigned-long-long:es-unsigned-long-long
	js-integer-types-abstract-ops:es-integer-types-abstract-ops
	js-float:es-float
	js-unrestricted-float:es-unrestricted-float
	js-double:es-double
	js-unrestricted-double:es-unrestricted-double
	js-bigint:es-bigint
	js-DOMString:es-DOMString
	js-ByteString:es-ByteString
	js-USVString:es-USVString
	js-object:es-object
	js-symbol:es-symbol
	js-interface:es-interface
	js-callback-interface:es-callback-interface
	js-dictionary:es-dictionary
	js-enumeration:es-enumeration
	js-callback-function:es-callback-function
	js-nullable-type:es-nullable-type
	js-sequence:es-sequence
	js-record:es-record
	js-promise:es-promise
	js-promise-manipulation:es-promise-manipulation
	js-promise-examples:es-promise-examples
	js-union:es-union
	js-buffer-source-types:es-buffer-source-types
	js-frozen-array:es-frozen-array
	js-observable-array:es-observable-array
	js-extended-attributes:es-extended-attributes
	Global:PrimaryGlobal
	js-legacy-extended-attributes:es-legacy-extended-attributes
	LegacyFactoryFunction:NamedConstructor
	LegacyLenientSetter:LenientSetter
	LegacyLenientThis:LenientThis
	LegacyNoInterfaceObject:NoInterfaceObject
	LegacyNullToEmptyString:TreatNullAs
	LegacyOverrideBuiltIns:OverrideBuiltins
	LegacyTreatNonObjectAsNull:TreatNonObjectAsNull
	LegacyUnforgeable:Unforgeable
	js-security:es-security
	js-overloads:es-overloads
	js-interfaces:es-interfaces
	dfn-legacy-factory-function:dfn-named-constructor
	interface-object:es-constructible-interfaces
	interface-object:es-interface-call
	legacy-factory-functions:named-constructors
	js-constants:es-constants
	js-attributes:es-attributes
	js-operations:es-operations
	js-default-operations:es-default-operations
	js-default-tojson:es-default-tojson
	js-stringifier:es-stringifier
	js-iterable:es-iterable
	define-the-iteration-methods:es-iterable-values
	define-the-iteration-methods:es-iterable-keys
	define-the-iteration-methods:es-iterable-entries
	js-default-iterator-object:es-default-iterator-object
	js-iterator-prototype-object:es-iterator-prototype-object
	js-asynchronous-iterable:es-asynchronous-iterable
	js-default-asynchronous-iterator-object:es-default-asynchronous-iterator-object
	js-asynchronous-iterator-prototype-object:es-asynchronous-iterator-prototype-object
	js-maplike:es-maplike
	js-map-size:es-map-size
	js-map-iterator:es-iterators
	js-map-iterator:es-iterator
	js-map-iterator:es-map-iterator
	js-map-entries:es-map-entries
	js-map-keys:es-map-keys-values
	js-map-keys:es-map-keys
	js-map-values:es-map-values
	js-map-forEach:es-forEach
	js-map-forEach:es-map-forEach
	js-map-get:es-map-get-has
	js-map-get:es-map-get
	js-map-has:es-map-has
	js-map-set:es-map-set
	js-map-delete:es-map-delete
	js-map-clear:es-map-clear
	js-setlike:es-setlike
	js-set-size:es-set-size
	js-set-iterator:es-set-iterator
	js-set-entries:es-set-entries-keys
	js-set-entries:es-set-entries
	js-set-keys:es-set-keys
	js-set-values:es-set-values
	js-set-forEach:es-set-forEach
	js-set-has:es-set-has
	js-set-add:es-add-delete
	js-set-add:es-set-add
	js-set-delete:es-set-delete
	js-set-clear:es-set-clear
	js-platform-objects:es-platform-objects
	platform-object-setprototypeof:platformobjectsetprototypeof
	js-legacy-platform-objects:indexed-and-named-properties
	js-legacy-platform-objects:es-legacy-platform-objects
	legacy-platform-object-getownproperty:getownproperty
	legacy-platform-object-set:platformobjectset
	legacy-platform-object-defineownproperty:defineownproperty
	legacy-platform-object-delete:delete
	legacy-platform-object-preventextensions:preventextensions
	legacy-platform-object-ownpropertykeys:legacy-platform-object-property-enumeration
	legacy-platform-object-ownpropertykeys:property-enumeration
	is-an-array-index:dfn-array-index-property-name
	invoke-indexed-setter:invoking-indexed-setter
	invoke-named-setter:invoking-named-setter
	LegacyPlatformObjectGetOwnProperty:getownproperty-guts
	js-observable-arrays:es-observable-arrays
	js-observable-array-defineProperty:es-observable-array-defineProperty
	js-observable-array-deleteProperty:es-observable-array-deleteProperty
	js-observable-array-get:es-observable-array-get
	js-observable-array-getOwnPropertyDescriptor:es-observable-array-getOwnPropertyDescriptor
	js-observable-array-has:es-observable-array-has
	js-observable-array-ownKeys:es-observable-array-ownKeys
	js-observable-array-preventExtensions:es-observable-array-preventExtensions
	js-observable-array-set:es-observable-array-set
	js-observable-array-abstract-operations:es-observable-array-abstract-operations
	js-user-objects:es-user-objects
	js-invoking-callback-functions:es-invoking-callback-functions
	js-namespaces:es-namespaces
	js-exceptions:es-exceptions
	js-DOMException-specialness:es-DOMException-prototype-object
	js-DOMException-specialness:es-DOMException-constructor-object
	js-DOMException-specialness:es-DOMException-specialness
	js-exception-objects:es-exception-objects
	js-creating-throwing-exceptions:es-creating-throwing-exceptions
	js-handling-exceptions:es-handling-exceptions

	any-to-js:any-to-es
	undefined-to-js:void-to-es
	undefined-to-js:undefined-to-es
	boolean-to-js:boolean-to-es
	byte-to-js:byte-to-es
	octet-to-js:octet-to-es
	short-to-js:short-to-es
	unsigned-short-to-js:unsigned-short-to-es
	long-to-js:long-to-es
	unsigned-long-to-js:unsigned-long-to-es
	long-long-to-js:long-long-to-es
	unsigned-long-long-to-js:unsigned-long-long-to-es
	float-to-js:float-to-es
	unrestricted-float-to-js:unrestricted-float-to-es
	double-to-js:double-to-es
	unrestricted-double-to-js:unrestricted-double-to-es
	bigint-to-js:bigint-to-es
	DOMString-to-js:DOMString-to-es
	ByteString-to-js:ByteString-to-es
	USVString-to-js:USVString-to-es
	object-to-js:object-to-es
	symbol-to-js:symbol-to-es
	interface-to-js:interface-to-es
	callback-interface-to-js:callback-interface-to-es
	dictionary-to-js:dictionary-to-es
	enumeration-to-js:enumeration-to-es
	callback-function-to-js:callback-function-to-es
	nullable-to-js:nullable-to-es
	sequence-to-js:sequence-to-es
	record-to-js:record-to-es
	promise-to-js:promise-to-es
	union-to-js:union-to-es
	buffer-source-to-js:buffer-source-to-es
	js-to-any:es-to-any
	js-to-undefined:es-to-undefined
	js-to-undefined:es-to-void
	js-to-boolean:es-to-boolean
	js-to-byte:es-to-byte
	js-to-octet:es-to-octet
	js-to-short:es-to-short
	js-to-unsigned-short:es-to-unsigned-short
	js-to-long:es-to-long
	js-to-unsigned-long:es-to-unsigned-long
	js-to-long-long:es-to-long-long
	js-to-unsigned-long-long:es-to-unsigned-long-long
	js-to-float:es-to-float
	js-to-unrestricted-float:es-to-unrestricted-float
	js-to-double:es-to-double
	js-to-unrestricted-double:es-to-unrestricted-double
	js-to-bigint:es-to-bigint
	js-to-bigint-or-numeric:es-to-bigint-or-numeric
	js-to-DOMString:es-to-DOMString
	js-to-ByteString:es-to-ByteString
	js-to-USVString:es-to-USVString
	js-to-object:es-to-object
	js-to-symbol:es-to-symbol
	js-to-interface:es-to-interface
	js-to-callback-interface:es-to-callback-interface
	js-to-dictionary:es-to-dictionary
	js-to-enumeration:es-to-enumeration
	js-to-callback-function:es-to-callback-function
	js-to-nullable:es-to-nullable
	js-to-sequence:es-to-sequence
	js-to-record:es-to-record
	js-to-promise:es-to-promise
	js-to-union:es-to-union
	js-to-buffer-source:es-to-buffer-source


●●link_map

T.ArrayBuffer:~WEBIDL#idl-ArrayBuffer
T.ArrayBufferView:~WEBIDL#ArrayBufferView
T.BufferSource:~WEBIDL#BufferSource
T.SharedArrayBuffer:~WEBIDL#idl-SharedArrayBuffer
T.ByteString:~WEBIDL#idl-ByteString
T.DOMException:~WEBIDL#idl-DOMException
T.DOMString:~WEBIDL#idl-DOMString
T.DataView:~WEBIDL#idl-DataView
T.Function:~WEBIDL#Function
T.USVString:~WEBIDL#idl-USVString
T.any:~WEBIDL#idl-any
T.bigint:~WEBIDL#idl-bigint
T.boolean:~WEBIDL#idl-boolean
T.byte:~WEBIDL#idl-byte
T.double:~WEBIDL#idl-double
T.float:~WEBIDL#idl-float
T.long long:~WEBIDL#idl-long-long
T.long:~WEBIDL#idl-long
T.object:~WEBIDL#idl-object
T.octet:~WEBIDL#idl-octet
T.record:~WEBIDL#idl-record
T.short:~WEBIDL#idl-short
T.symbol:~WEBIDL#idl-symbol
T.unrestricted double:~WEBIDL#idl-unrestricted-double
T.unrestricted float:~WEBIDL#idl-unrestricted-float
T.unsigned long long:~WEBIDL#idl-unsigned-long-long
T.unsigned long:~WEBIDL#idl-unsigned-long
T.unsigned short:~WEBIDL#idl-unsigned-short
T.undefined:~WEBIDL#idl-undefined
T.Promise:~WEBIDL#idl-promise

T.WindowProxy:~HTMLWPROXY#windowproxy
T.Window:~WINDOW#window
T.Worklet:~WORKLETS#worklet
T.Document:~DOM4#document
T.HTMLAllCollection:~HTMLLS/common-dom-interfaces.html#htmlallcollection
T.Location:~WINDOW#location
T.Response:~FETCH#response

	●用語
~IDL片:~WEBIDL#dfn-idl-fragment
定義:~WEBIDL#dfn-definition
	有名~定義:~WEBIDL#dfn-named-definition
識別子:~WEBIDL#dfn-identifier
予約-済み識別子:~WEBIDL#dfn-reserved-identifier
有修飾~名:~WEBIDL#qualified-name

~ifc:~WEBIDL#dfn-interface
~ifc~mb:~WEBIDL#dfn-interface-member
継承-:~WEBIDL#dfn-inherit
継承した~ifc群:~WEBIDL#dfn-inherited-interfaces
自身も含む継承した~ifc群:~WEBIDL#interface-inclusive-inherited-interfaces
部分的な~ifc定義:~WEBIDL#dfn-partial-interface
部分的な~ifc:~WEBIDL#dfn-partial-interface
~ifc~mixin:~WEBIDL#interface-mixin
~ifc~mixin~mb:~WEBIDL#interface-mixin-member
部分的な~ifc~mixin:~WEBIDL#partial-interface-mixin
	部分的な~ifc~mixin定義:~WEBIDL#partial-interface-mixin
~includes文:~WEBIDL#includes-statement
内包-:~WEBIDL#include
~host~ifc:~WEBIDL#host-interfaces
~callback~ifc:~WEBIDL#dfn-callback-interface
	~callback~ifc~mb:~WEBIDL#callback-interface-member
~mb:~WEBIDL#dfn-member

V.this:~WEBIDL#this
所与の値:~WEBIDL#the-given-value

定数:~WEBIDL#dfn-constant
属性:~WEBIDL#dfn-attribute
正則~属性:~WEBIDL#dfn-regular-attribute
読専:~WEBIDL#dfn-read-only
取得子を継承する:~WEBIDL#dfn-inherit-getter
演算:~WEBIDL#dfn-operation
正則~演算:~WEBIDL#dfn-regular-operation
返り値~型:~WEBIDL#dfn-return-type
	可変個的な:~WEBIDL#dfn-variadic
可変個~引数:~WEBIDL#dfn-variadic-argument
	随意~引数:~WEBIDL#dfn-optional-argument
既定~値:~WEBIDL#dfn-optional-argument-default-value
	stR.値:~WEBIDL#value-of-string-literal-tokens
~JSON型:~WEBIDL#dfn-json-types
構築子~演算:~WEBIDL#idl-constructors
	特殊~演算:~WEBIDL#dfn-special-operation
	特殊~keyword:~WEBIDL#dfn-special-keyword
取得子:~WEBIDL#dfn-getter
設定子:~WEBIDL#dfn-setter
	削除子:~WEBIDL#dfn-deleter
文字列化子:~WEBIDL#dfn-stringifier
文字列~化の挙動:~WEBIDL#dfn-stringification-behavior
構築子~手続き:~WEBIDL#constructor-steps
~method手続き:~WEBIDL#method-steps
取得子~手続き:~WEBIDL#getter-steps
設定子~手続き:~WEBIDL#setter-steps

有index~prop:~WEBIDL#idl-indexed-properties
有index~prop取得子:~WEBIDL#dfn-indexed-property-getter
有index~prop設定子:~WEBIDL#dfn-indexed-property-setter
有index~propを~support:~WEBIDL#dfn-support-indexed-properties
~supportする~prop~index:~WEBIDL#dfn-supported-property-indices
有index~propの値を決定する手続き:~WEBIDL#dfn-determine-the-value-of-an-indexed-property
既存の有index~propを設定する手続き:~WEBIDL#dfn-set-the-value-of-an-existing-indexed-property
新たな有index~propを設定する手続き:~WEBIDL#dfn-set-the-value-of-a-new-indexed-property

有名~prop:~WEBIDL#idl-named-properties
有名~prop取得子:~WEBIDL#dfn-named-property-getter
有名~prop設定子:~WEBIDL#dfn-named-property-setter
有名~prop削除子:~WEBIDL#dfn-named-property-deleter
有名~propを~support:~WEBIDL#dfn-support-named-properties
~supportする~prop名:~WEBIDL#dfn-supported-property-names
有名~propの値を決定する手続き:~WEBIDL#dfn-determine-the-value-of-a-named-property
既存の有名~propを設定する手続き:~WEBIDL#dfn-set-the-value-of-an-existing-named-property
新たな有名~propを設定する手続き:~WEBIDL#dfn-set-the-value-of-a-new-named-property
既存の有名~propを削除する手続き:~WEBIDL#dfn-delete-an-existing-named-property

静的~属性:~WEBIDL#dfn-static-attribute
静的~演算:~WEBIDL#dfn-static-operation
oP.静的:~WEBIDL#dfn-static-operation

多重定義:~WEBIDL#dfn-overloaded
有効-多重定義~集合:~WEBIDL#dfn-effective-overload-set
関数~類:~WEBIDL#dfn-function-like
oL.~callable:~WEBIDL#effective-overload-set-tuple-callable
oL.型~list:~WEBIDL#type-list
oL.省略可否~list:~WEBIDL#optionality-list
	省略可否 値:~WEBIDL#dfn-optionality-value
有効-多重定義~集合を算出する:~WEBIDL#compute-the-effective-overload-set
判別-可能:~WEBIDL#dfn-distinguishable
最も内縁な型:~WEBIDL#_innermost-type
判別~引数~index:~WEBIDL#dfn-distinguishing-argument-index
	可反復:~WEBIDL#dfn-iterable
可反復~宣言:~WEBIDL#dfn-iterable-declaration
~pairを非同期に可反復な宣言:~WEBIDL#pair-asynchronously-iterable-declaration
値を非同期に可反復な宣言:~WEBIDL#value-asynchronously-iterable-declaration

値~反復子:~WEBIDL#dfn-value-iterator
~pair反復子:~WEBIDL#dfn-pair-iterator
反復される値~pair群:~WEBIDL#dfn-value-pairs-to-iterate-over
値~pair:~WEBIDL#value-pair
vP.~key:~WEBIDL#value-pair-key
vP.値:~WEBIDL#value-pair-value
非同期に可反復な宣言:~WEBIDL#dfn-async-iterable-declaration
次回の反復~結果を取得する手続き:~WEBIDL#dfn-get-the-next-iteration-result
非同期~反復子の初期化~手続き:~WEBIDL#asynchronous-iterator-initialization-steps
非同期~反復子から返る手続き:~WEBIDL#asynchronous-iterator-return
	sM.現在の状態:~WEBIDL#sessionmanager-async-iterator-current-state
C.反復~終了:~WEBIDL#end-of-iteration

	~maplike:~WEBIDL#dfn-maplike
~maplike宣言:~WEBIDL#dfn-maplike-declaration
~map~entry群:~WEBIDL#dfn-map-entries
	~setlike:~WEBIDL#dfn-setlike
~setlike宣言:~WEBIDL#dfn-setlike-declaration
集合~entry群:~WEBIDL#dfn-set-entries

~ns:~WEBIDL#dfn-namespace
~ns~mb:~WEBIDL#dfn-namespace-member
	部分的な~ns定義:~WEBIDL#dfn-partial-namespace
部分的な~ns:~WEBIDL#dfn-partial-namespace
	辞書:~WEBIDL#dfn-dictionary
辞書~mb:~WEBIDL#dfn-dictionary-member
	diC.継承-:~WEBIDL#dfn-inherit-dictionary
継承した辞書~群:~WEBIDL#dfn-inherited-dictionaries
diC.既定~値:~WEBIDL#dfn-dictionary-member-default-value
diC.要求され:~WEBIDL#required-dictionary-member
	部分的な辞書~定義:~WEBIDL#dfn-partial-dictionary

例外:~WEBIDL#dfn-exception
eX.名前:~WEBIDL#domexception-name
eX.~message:~WEBIDL#domexception-message
単純~例外:~WEBIDL#dfn-simple-exception
例外を作成する:~WEBIDL#dfn-create-exception
例外を投出する:~WEBIDL#dfn-throw
~DOMException用の名前~表t:~WEBIDL#dfn-error-names-table
例外~用の適切な~message:#_appropriate-message-for-an-exception

列挙:~WEBIDL#dfn-enumeration
列挙~値:~WEBIDL#dfn-enumeration-value
~callback関数:~WEBIDL#dfn-callback-function
	~typedef:~WEBIDL#dfn-typedef
	新たな名前が与えられる型:~WEBIDL#type-being-given-a-new-name
~platform~obj:~WEBIDL#dfn-platform-object
旧来の~platform~obj:~WEBIDL#dfn-legacy-platform-object

	型:~WEBIDL#idl-types
整数~型:~WEBIDL#dfn-integer-type
数量-型:~WEBIDL#dfn-numeric-type
	~primitive型:~WEBIDL#dfn-primitive-type
文字列~型:~WEBIDL#dfn-string-type
有型~配列~型:~WEBIDL#dfn-typed-array-type
~buffer~source型:~WEBIDL#dfn-buffer-source-type
~buffer型:~WEBIDL#buffer-types
~buffer~view型:~WEBIDL#buffer-view-types
~obj型:~WEBIDL#dfn-object-type

特有~型:~WEBIDL#dfn-specific-type
	~symbol型:~WEBIDL#idl-symbol
~ifc型:~WEBIDL#idl-interface
~callback文脈:~WEBIDL#dfn-callback-context
~callback~ifc型:~WEBIDL#idl-callback-interface
辞書~型:~WEBIDL#idl-dictionary
列挙~型:~WEBIDL#idl-enumeration
~callback関数~型:~WEBIDL#idl-callback-function
~nullable型:~WEBIDL#dfn-nullable-type
~nullable:~WEBIDL#dfn-nullable-type
	~nullable~mb型の個数:~WEBIDL#dfn-number-of-nullable-member-types
~nullable型を内包する:~WEBIDL#dfn-includes-a-nullable-type
~undefinedを内包する:~WEBIDL#dfn-includes-undefined
内縁~型:~WEBIDL#dfn-inner-type
	内縁~型:~WebIDL#annotated-types-inner-type → 最も内縁な型
連列~型:~WEBIDL#sequence-type
~sequence_T:~WEBIDL#idl-sequence
~async_sequence_T:~WEBIDL#idl-async-iterable-type
	~async-iterable_T:~WEBIDL#idl-async-iterable-type
非同期c連列~型:~WEBIDL#async-sequence-type
非同期c連列:~WEBIDL#async-sequence-type
~record型:~WEBIDL#record-type
~record_KV:~WEBIDL#idl-record
~promise型:~WEBIDL#dfn-promise-type
~promise_T:~WEBIDL#idl-promise
共用体~型:~WEBIDL#dfn-union-type
~mb型:~WEBIDL#dfn-union-member-type
平坦~化~mb型~群:~WEBIDL#dfn-flattened-union-member-types
凍結d配列~型:~WEBIDL#dfn-frozen-array-type
~FrozenArray_T:~WEBIDL#idl-frozen-array
	~ObservableArray_T:~WEBIDL#idl-observable-array
観測-可能な配列~型:~WEBIDL#dfn-observable-array-type
~backしている~list:~WEBIDL#observable-array-attribute-backing-list
観測-可能な配列~属性の有index値を削除する:~WEBIDL#observable-array-attribute-delete-an-indexed-value
観測-可能な配列~属性の有index値を設定する:~WEBIDL#observable-array-attribute-set-an-indexed-value

注釈された型:~WEBIDL#annotated-types
	型に適用-可能:~WEBIDL#extended-attributes-applicable-to-types

拡張d属性:~WEBIDL#dfn-extended-attribute
	結付けられた拡張d属性:~WEBIDL#idl-type-extended-attribute-associated-with
拡張d属性が結付けられ:~WEBIDL#idl-type-extended-attribute-associated-with

引数をとらない:~WEBIDL#dfn-xattr-no-arguments
	引数~listを引数にとる:~WEBIDL#dfn-xattr-argument-list
有名~引数~listを引数にとる:~WEBIDL#dfn-xattr-named-argument-list
	有名~引数~list:~WEBIDL#dfn-xattr-named-argument-list
識別子を引数にとる:~WEBIDL#dfn-xattr-identifier
識別子~listを引数にとる:~WEBIDL#dfn-xattr-identifier-list
~wildcardを引数にとる:~WEBIDL#dfn-xattr-wildcard

	●用語（ JS 束縛

~class文字列:#dfn-class-string
~THROW:#javascript-throw
初期~obj:#dfn-initial-object

公開~集合:#dfn-exposure-set
交差~公開~集合:#exposure-set-intersection
自前の公開~集合:#own-exposure-set
公開され:#dfn-exposed
公開されて:#dfn-exposed
条件付きで公開されて:#dfn-conditionally-exposed
属する~realm:#dfn-associated-realm

~IDL値に変換する:#dfn-convert-javascript-to-idl-value
~JS値に変換する:#dfn-convert-idl-to-javascript-value
いずれかの型の~IDL値に変換する:#converted-to-a-numeric-type-or-bigint

~promiseに反応する:#dfn-perform-steps-once-promise-is-settled
新たな~promise:#a-new-promise
~promiseを却下する:#reject
~promiseを解決する:#resolve
却下される~promise:#a-promise-rejected-with
解決される~promise:#a-promise-resolved-with
充足-時:#upon-fulfillment
却下-時:#upon-rejection
すべての~promiseを待機する:#wait-for-all
すべてを待機する~promiseを取得する:#waiting-for-all-promise
準備済み~promise:#environment-ready-promise
~promiseを取扱済みとして~markする:#mark-a-promise-as-handled

可反復から連列を作成する:#create-sequence-from-iterable
可反復から凍結d配列を作成する:#create-frozen-array-from-iterable
凍結d配列を作成する:#dfn-create-frozen-array

~buffer~sourceを作成する:#_buffersource-create
	配列~bufferを~byte列から作成する:#arraybuffer-create
	配列~buffer~viewを~byte列から作成する:#arraybufferview-create
	共用~配列~bufferを~byte列から作成する:#sharedarraybuffer-create
配列~bufferを切離す:#dfn-detach
	BS.切離す:#dfn-detach
切離されて:#buffersource-detached
BS.~byte長さ:#buffersource-byte-length
BS.下層~buffer:#buffersource-underlying-buffer
	BS.~byte列を書込む:#_buffersource-write
BS.転送-可能:buffersource-transferable
保持された~byte列の複製を取得する:#dfn-get-buffer-source-copy
配列~bufferの中へ~byte列を書込む:#arraybuffer-write
配列~buffer~viewの中へ~byte列を書込む:#arraybufferview-write
配列~bufferを転送する:#arraybuffer-transfer
	V.開始-時の~offset:#arraybuffer-write-startingoffset
	V.開始-時の~offset:#arraybufferview-write-startingoffset

大域~名:#dfn-global-name
wA.識別子:#legacywindowalias-identifier
fF.識別子:#legacyfactoryfunction-identifier
	nC.識別子:#namedconstructor-identifier
大域~原型鎖は変異-可能か:#realm-is-global-prototype-chain-mutable
~security検査を遂行する:#dfn-perform-a-security-check
偽造-不能:#dfn-unforgeable-on-an-interface
偽造-不能な~prop名:#dfn-unforgeable-property-name

多重定義~解決~algo:#dfn-overload-resolution-algorithm

~ifc~obj:#dfn-interface-object
構築子を上書きする手続き:#overridden-constructor-steps
~ifc~objを作成する:#create-an-interface-object
旧来の~factory関数:#dfn-legacy-factory-function
旧来の~factory関数を作成する:#create-a-legacy-factory-function
~ifc原型~obj:#dfn-interface-prototype-object
~ifc原型~objを作成する:#create-an-interface-prototype-object
実装を検査する:#implementation-check-an-object

有名~prop群~obj:#dfn-named-properties-object
有名~prop群~objを作成する:#create-a-named-properties-object
定数を定義する:#define-the-constants
正則~属性を定義する:#define-the-regular-attributes
静的~属性を定義する:#define-the-static-attributes
偽造-不能な正則~属性を定義する:#define-the-unforgeable-regular-attributes
属性を定義する:#define-the-attributes
属性~取得子:#dfn-attribute-getter
属性~取得子を作成する:#dfn-attribute-getter
属性~設定子:#dfn-attribute-setter
属性~設定子を作成する:#dfn-attribute-setter
正則~演算を定義する:#define-the-regular-operations
静的~演算を定義する:#define-the-static-operations
偽造-不能な正則~演算を定義する:#define-the-unforgeable-regular-operations
演算を定義する:#define-the-operations
演算~関数を作成する:#dfn-create-operation-function
既定の~method手続き:#default-method-steps
既定の~method手続きを有する:#has-default-method-steps
既定の~toJSON手続き:#default-tojson-steps
継承~stackの属性~値を収集する:#collect-attribute-values-of-an-inheritance-stack
属性~値を収集する:#collect-attribute-values
継承~stackを作成する:#create-an-inheritance-stack
反復子~methodを定義する:#define-the-iteration-methods
非同期~反復子~methodを定義する:#define-the-asynchronous-iteration-methods
非同期~反復子~method用の引数を変換する:#converting-arguments-for-an-asynchronous-iterator-method

既定の反復子~obj:#dfn-default-iterator-object
反復子~原型~obj:#dfn-iterator-prototype-object
非同期~反復子~原型~obj:#dfn-asynchronous-iterator-prototype-object
既定の非同期~反復子~obj:#dfn-default-asynchronous-iterator-object

dI.~target:#default-iterator-object-target
dI.種類:#default-iterator-object-kind
dI.~index:#default-iterator-object-index

aI.種類:#default-asynchronous-iterator-object-kind
aI.進行中な~promise:#default-asynchronous-iterator-object-ongoing-promise
	＊aI.状態:#default-asynchronous-iterator-object-state
aI.~target:#default-asynchronous-iterator-object-target
aI.完遂したか:#default-asynchronous-iterator-object-is-finished

反復子~結果:#iterator-result

~map反復子を作成する:#create-a-map-iterator
~map~size取得子:#dfn-map-size-getter
集合~反復子を作成する:#create-a-set-iterator
集合~size取得子:#dfn-set-size-getter

aS.~obj:#js-async-sequence-object
aS.~method:#js-async-sequence-method
aS.種別:#js-async-sequence-type
非同期c連列を~openする:#async-sequence-open
非同期c反復子:#async-iterator
aI1.下層の~record:#js-async-iterator-underlying-record
aI1.型~parameter:#js-async-iterator-type-parameter
次回の値を取得する:#async-iterator-get-next-value
非同期c反復子を~closeする:#async-iterator-close

~platform~objである:#is-a-platform-object
実装-:#implements
~ifcを実装する新たな~objを作成する:#new
~ifcを実装する新たな~objを内部的に作成する:#internally-create-a-new-object-implementing-the-interface

大域~prop参照を定義する:#define-the-global-property-references
首~ifc:#dfn-primary-interface
変化-:#dfn-change-global-environment

配列~indexで:#is-an-array-index
有名~propの可視性判定~algo:#dfn-named-property-visibility
有名~propは可視か？:#dfn-named-property-visibility
有index~prop設定子を呼出す:#invoke-indexed-setter
有名~prop設定子を呼出す:#invoke-named-setter

C.missing:#_missing
~Web~IDL引数~list:#web-idl-arguments-list
~JS引数~listに変換する:#web-idl-arguments-list-converting
利用元~objの演算を~callする:#call-a-user-objects-operation
~callback this 値:#dfn-callback-this-value
旧来の~callback~ifc~obj:#dfn-legacy-callback-interface-object
旧来の~callback~ifc~objを作成する:#create-a-legacy-callback-interface-object
~callback関数を呼出す:#invoke-a-callback-function
~callback関数で構築する:#construct-a-callback-function
~ns~obj:#dfn-namespace-object
~ns~objを作成する:#create-a-namespace-object
例外が投出された:#an-exception-was-thrown

観測-可能な配列~exotic~obj:#observable-array-exotic-object
観測-可能な配列~exotic~objを作成する:#creating-an-observable-array-exotic-object
~backしている観測-可能な配列~exotic~obj:#backing-observable-array-exotic-object
観測-可能な配列~exotic~objの有index値を設定する:#observable-array-exotic-object-set-the-indexed-value
観測-可能な配列~exotic~objの長さを設定する:#observable-array-exotic-object-set-the-length

~scriptと~callbackを準備する:#_prepare-for-script-and-callback

	●外部
実装定義:~INFRA#implementation-defined
32 ~bitな無符号~整数:~INFRA#32-bit-unsigned-integer
64 ~bitな無符号~整数:~INFRA#64-bit-unsigned-integer
符号単位:~INFRA#code-unit
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item
~list:~INFRA#list
~size:~INFRA#list-size
空:~INFRA#list-is-empty
空にする:~INFRA#list-empty
付加する:~INFRA#list-append
除去する:~INFRA#list-remove
拡張する:~INFRA#list-extend
有順序~map:~INFRA#ordered-map
map.~clearする:~INFRA#map-clear
map.~size:~INFRA#map-size
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
交差集合:~INFRA#set-intersection
下位集合:~INFRA#set-subset
~stack:~INFRA#stack
~cloneする:~INFRA#list-clone
~popする:~INFRA#stack-pop
	~pushする:~INFRA#stack-push
	文字列:~INFRA#string
連結する:~INFRA#string-concatenate
~scalar値~文字列に変換-:~INFRA#javascript-string-convert
~byte列:~INFRA#byte-sequence
byte.長さ:~INFRA#byte-sequence-length
	範囲:~INFRA#the-range

大域~obj:~WAPI#concept-realm-global
関連な~realm:~WAPI#concept-relevant-realm
関連な設定群~obj:~WAPI#relevant-settings-object
設定群~obj:~WAPI#concept-realm-settings-object
現任な設定群~obj:~WAPI#incumbent-settings-object
走らせた~scriptを片付ける:~WAPI#clean-up-after-running-script
走らせた~callbackを片付ける:~WAPI#clean-up-after-running-a-callback
~scriptを走らすために準備する:~WAPI#prepare-to-run-script
~callbackを走らすために準備する:~WAPI#prepare-to-run-a-callback
~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~task~source:~WAPI#task-source
小taskを~queueする:~WAPI#queue-a-microtask
~taskを~queueする:~WAPI#queue-a-task
例外を報告する:~WAPI#report-an-exception

並列的:~HTMLINFRA#in-parallel

enV.~secureな文脈:~WAPI#secure-context
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability

	●外部（JS

	A.XxxYyy:~TC39#sec-xxxyyy
A.LegacyPlatformObjectGetOwnProperty:#LegacyPlatformObjectGetOwnProperty
A.IntegerPart:#abstract-opdef-integerpart
A.ConvertToInt:#abstract-opdef-converttoint

A.Completion:~TC39#sec-completion-ao
	Completion:~TC39#sec-completion-record-specification-type
A.Get:~TC39#sec-get-o-p
A.Set:~TC39#sec-set-o-p-v-throw
A.SetImmutablePrototype:~TC39#sec-set-immutable-prototype
A.IsResizableArrayBuffer:https://tc39.es/proposal-resizablearraybuffer/#sec-isresizablearraybuffer
A.CreateIteratorResultObject:~TC39#sec-createiterresultobject

	op.

jI.Function.prototype:~TC39#sec-properties-of-the-function-prototype-object
jI.Object.prototype:~TC39#sec-properties-of-the-object-prototype-object
jI.Error.prototype:~TC39#sec-properties-of-the-error-prototype-object
jI.Array.prototype:~TC39#sec-properties-of-the-array-prototype-object
jI.Array.prototype.values:~TC39#sec-array.prototype.values
jI.Array.prototype.forEach:~TC39#sec-array.prototype.foreach
jI.Array.prototype.entries:~TC39#sec-array.prototype.entries
jI.Array.prototype.keys:~TC39#sec-array.prototype.keys
jI.ArrayBuffer:~TC39#sec-arraybuffer-constructor
jI.Iterator.prototype:~TC39#sec-%25iterator.prototype%25-object
jI.AsyncIteratorPrototype:~TC39#sec-asynciteratorprototype
jI.Promise:~TC39#sec-promise-constructor
jI.Promise.resolve:~TC39#sec-promise.resolve
jI.Promise.reject:~TC39#sec-promise.reject
jI.MapIteratorPrototype:~TC39#sec-%25mapiteratorprototype%25-object
jI.SetIteratorPrototype:~TC39#sec-%25setiteratorprototype%25-object
jI.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-constructor
jI.Symbol.toStringTag:~TC39#sec-well-known-symbols
jI.Symbol.unscopables:~TC39#sec-well-known-symbols
jI.Symbol.iterator:~TC39#sec-well-known-symbols
jI.Symbol.asyncIterator:~TC39#sec-well-known-symbols

jE.SyntaxError:~TC39#sec-native-error-types-used-in-this-standard-syntaxerror

	// js class
jt.Boolean:~TC39#sec-ecmascript-language-types-boolean-type
jt.Number:~TC39#sec-ecmascript-language-types-number-type
jt.BigInt:~TC39#sec-ecmascript-language-types-bigint-type
	jt.BigInt:~TC39#sec-bigint-objects
jt.String:~TC39#sec-ecmascript-language-types-string-type
jt.Symbol:~TC39#sec-ecmascript-language-types-symbol-type
jt.Object:~TC39#sec-object-type
jt.Map:~TC39#sec-map-objects
jt.Set:~TC39#sec-set-objects
jt.Error:~TC39#sec-error-objects
jt.ArrayBuffer:~TC39#sec-arraybuffer-objects
	jt.DataView:~TC39#sec-dataview-objects
jt.SharedArrayBuffer:~TC39#sec-sharedarraybuffer-objects
jt.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror

	jt.Array:~TC39#sec-array-objects
	jt.Function:~TC39#
	jt.Undefined:~TC39#
	jt.Null:~TC39#
	jt.Uint8:~TC39#


i.NumericLiteral:~TC39#sec-literals-numeric-literals
	~TC39#sec-well-known-symbols

c.JSON.stringify():~TC39#sec-json.stringify
c.Promise.all():~TC39#sec-promise.all
c.promise.then():~TC39#sec-promise.prototype.then
NewTarget:~TC39#sec-built-in-function-objects

op.floor:~TC39#eqn-floor
op.abs:~TC39#eqn-abs
op.modulo:~TC39#eqn-modulo
op.max:~TC39#eqn-max
op.min:~TC39#eqn-min
	op.typeof:~TC39#sec-typeof-operator

中途完了:~TC39#sec-completion-record-specification-type
構築子:~TC39#constructor
関数~obj:~TC39#function-object
組込みの関数~obj:~TC39#sec-built-in-function-objects
~realm:~TC39#realm
現在の~realm:~TC39#current-realm
~callable:~TC39#sec-iscallable
配列~反復子~obj:~TC39#sec-array-iterator-objects
配列~index:~TC39#array-index
~pdesc:~TC39#sec-property-descriptor-specification-type
抽象-~closure:~TC39#sec-abstract-closure
~Proxy~exotic~obj:~TC39#proxy-exotic-object
変異-不能な原型~exotic~obj:~TC39#immutable-prototype-exotic-object
内部~slot:~TC39#sec-object-internal-methods-and-internal-slots
内部~method:~TC39#sec-object-internal-methods-and-internal-slots
eS.要素:~TC39#sec-ecmascript-language-types-string-type
	eS.型:~TC39#sec-ecmascript-data-types-and-values
~PromiseCapability:~TC39#sec-promisecapability-records
eS.要素~size:~TC39#table-the-typedarray-constructors

普通の~obj:~TC39#ordinary-object
~algo規約:~TC39#sec-algorithm-conventions
~agent~cluster:~TC39#sec-agent-clusters

	Assert:~TC39#sec-algorithm-conventions
	＠~TC39#sec-completion-record-specification-type
	＠~TC39#sec-iterator-records


●●words_table1

SPACE:<span class="cp-name">SPACE</span>

record_KV:<code class="idltype">record&lt;<var>K</var>, <var>V</var>&gt;</code>

promise_T:<code class="idltype">Promise&lt;<var>T</var>&gt;</code>
sequence_T:<code class="idltype">sequence&lt;<var>T</var>&gt;</code>
FrozenArray_T:<code class="idltype">FrozenArray&lt;<var>T</var>&gt;</code>
ObservableArray_T:<code class="idltype">ObservableArray&lt;<var>T</var>&gt;</code>
async_sequence_T:<code class="idltype">async_sequence&lt;<var>T</var>&gt;</code>
toJSON: <code>toJSON</code> 
varT:<var>T</var>
Proxy:<code class="js-type">Proxy</code> 
WEBIDLissue:https://github.com/whatwg/webidl/issues

●●words_table

	●データ／型／構造
浮動小数点:floating point::~
数量-:numeric::~
ns:namespace::名前空間
	列挙-不能:unenumerable
	列挙-可能:enumerable
	並び:sequence
共用体:union:::~:ユニオン
set:::::セット
和集合:union::~
	instance化:instantiate
maplike:
setlike:
定数:constant::~::コンスタント
	定数:const
演算子:operator::~
	昇順
	昇順／:in ascending numerical order
	作成した順に:in ascending chronological order
循環:cycle::~
循環-:cycle::~
	-:inclusive
	長さ固定な:fixed-length
	~resize可能:resizable
	~resize可能:growable
	`同期c^C:"sync"
	`非同期c^C:"async"

	●型注釈
随意:optional::::オプショナル
	随意~引数
省略可否:optionality:~
	随意でない:non-optional
内縁:inner::~::インナー
	最も内縁:innermost
nullable:::null 可能
undefined:
正則:regular::~::レギュラー
特殊:special::~::スペシャル
exotic:
単精度:single-precision::~
倍精度:double-precision::~
無符号:unsigned::~
有符号:signed::~
首:primary::~
	//EN dash
非読専な:read-write::読専でない
	非読専な:read–write
writable:::書き込み可能
	旧来のものでない:non-legacy
	LegacyWindowAlias:legacy window alias
普通の:ordinary::~

	●データ演算
削除子:deleter::~
文字列化子:stringifier::~
	文字列~化-:stringify
	文字列~化:stringification
可反復:iterable:::~:イテラブル
	反復される値:iterated value
	非同期に可反復な:asynchronously iterable

連結-:concatenate:~
	連結-:concatenation
	連結-:prepended

決着-:settle::~
代入-:assign::~
代入:assignment::~
書込む:writeする::書き込む
書込n:write::書き込み

	~LET ε:Let 〜 be an uninitialized variable
	設定しておく:set up

	●一般処理
return:
this:
渡す:passする:~
渡され:passされ:~
渡し:passし:~
片付ける:clean upする:~
切詰める:clampする::切り詰める
切詰めら:clampさ::切り詰めら
切落す:truncateする:切り落とす
合格-:pass:~
検索-:look up::~
検索:lookup::~
切離す:detachする::切り離す
切離して:detachして::切り離して
切離され:detachされ::切り離され
切離せ:detachでき::切り離せ
main::::メイン
遂げる:carry outする:~
宛先:target::~
取扱済み:handled:取り扱い済み
静止-:pause::~
割振る:allocateする:割り振る
	割振るため〜ない:cannot be allocated
割振られ:allocateされ:割り振られ
割振n:allocation:割り振り
open:
close:

	存続する限り:lifetime
	投出し直す:rethrow
	走り得る:run
	~call元:caller
	この~algoを~callする:call site
	へ進む:continue
	生じさせ:cause

	●JS
symbol:
List:
strict-mode:strict mode
trace::::トレース
bind:
callable:
configure:
	~configure不能:non-configurable
	~importするもの:imports
	proxy:
trap::::トラップ
essential:
closure:
capture:
原型:prototype::::プロトタイプ
原型鎖:prototype chain::::プロトタイプチェイン
pdesc:Property Descriptor::property 記述子:プロパティ記述子
中途完了:abrupt completion::~
Record:
	完了~Record:Completion Record
	反復子~Record:Iterator Record
PromiseCapability:

	環境設定-可能:configurable
	列挙-可能:enumerable
	環境設定-不能:non-configurable
	列挙-不能:non-enumerable
	`ECMA-262$r:ECMAScript

	●IDL
DOMException:
ifc:interface::::インタフェース
	~ifc化:interface with
mb:member:::メンバ
iframe:
accessor::::アクセサ
	引数~list:argument values／:the only argument value／:passing no arguments
	引数たち:arguments
内包-:include::~
includes:
引数個数:argument count:~
可変個:variadic::~
判別:distinguishing:~
index-:index::index アクセス
多重定義:overload::~::オーバーロード
	多重定義:overloading
有効-:effective:~
有修飾:qualified::~
片:fragment::~::フラグメント
言語束縛:language binding:言語 binding:~::言語バインディング
	言語束縛:binding
文:statement:~
現任:incumbent::~
隠蔽-:shadow:~
	invalid
ms:milliseconds:::ミリ秒

	予約-済み:reserved
	:-defined

	●保安
偽造-:forge::~
	偽造-不能:unforgeable
	~secureでない:insecure

	●構文／文字
式:expression:~
辞書式:lexicographic:~
surrogate::::サロゲート
wildcard::::ワイルドカード

	範囲~外:out-of-range

	●仕様
不用意:accidental:~
略記:shorthand:~
命令的:imperative:~
力:power:~
複雑:complicated:~
冗長:redundant:~
給-:supply:~
	~~給-:-
申請-:file:~
競合-:conflict:~
論交する:discussする:論を交わす
出荷-:ship:~
勧める:adviseする:~
移行-:migrate:~
本物の:realな:~
例外的:exceptional:~
指示書き:instruction:~
的確:right:~
責務:responsibility:~
続行-:proceed:~

	~~問題ない:Fine;
	標準でない:non-standard
	実質的:In effect,
	~~通常:Fine
	誤った:erroneous
	よく似た:very similar
	必要:have to
	不要:need not
	必要性:need
	何故
	-:be true
	場合分け:case
	そのわけは:This is because
	今は無き:defunct
	~~緩く:looseに
	欠損なく:intactに
	〜しなくとも:Instead of
	超越的に特化された:hyper-specialization
	他が指定されない限り:unless otherwise specified
	~~供:be a
	注意:notice
	易くする:help
	助けになる:help
	付与:-
	見える:made to look like
	まかなう:cater
	集約:-
	裁定-:decision
	-:Recall that
	予測-不能:unpredictable
	細心な注意を払う必要がある:Extreme care must be taken
	用心深く:cautious
	共有されない:non-shared
	見込まれ:likely
	〜から諮られ得る:might or might not consult
	相応するもの:counterpart

	●事例
叩いた:hitした:~
押した:pressした:~
polyfill:
合計:total:~
句:phrase:~
集成-:aggregate::~
bookmark::::ブックマーク
illustrate::説明
末端利用者:end user:~:::エンドユーザ
自立的:standalone:~
非同期性:asynchronicity::~
非同時性:asynchrony::~
即時な:immediateな:即時の
	環境による:environmental
	~~定式化:encode
	-:maximum
	姓名:names
	ほぼ同様:much like
	取り出され:drawn
	何度も行われる:iterative
	現実にありそうな:more real-world
	訴えかける:appealing
	選ぶ:make a choice
	何箇所か:place
	余分な:extra


	●未分類
agent:
back:
	~backしている:backing
factory:
現れる:appearする:~
現れて:appearして:~
現れ:appearし:~
正準-:canonical:~
	正準-化-:canonicalize
型強制-:coerce:~
回送-:forward:~
派生:derived::~
	継承~階層において最も末端:most-derived／:derived-most
埋めら:fillさ:~
穴:hole:~
代理:proxy::~
	それを代理する:by proxy
runtime:
仮数:significand:~
偶数:even:~
実数:real number:~
計数:counter:~
可視性判定:visibility:~
種類:kind:~
数学的:mathematical:~
最大:最大
最小:最小
重合しな:overlapしな:重なり合わな
	重合しなくなる:cannot overlap
横取り:intercept:~

	`username^M:username
	完遂したか:is finished
	置く:place
	選ぶ:choose／choice
	重複-:duplicate
	から開始-:starting with
	指す:refer
	指す:address
	ある:contain
	-:without the intervening dot
	最小:shortest／
	下位~節:sub-section
	series
	~~基準
	等距離:equally close／lies halfway between two
	何もしない:no-op
	-:just
	保たれ:kept／keep
	何か:interface-or-null
	追っ:follow

	●訳注／meta
	導入-:
	~link:
	原文:-
	総称:-
	~~参照

	●指示語
現在:currently:~
main:
次回の:next:~
位置:位置
位置-:位置
	に位置する／の位置:at
	位置:position
新-:new:~
旧-:old:~
裸の:bareな:~
	直後:
	種:
	項:
	前~段:
	前述:

	／-:known
	最低:lowest
	最終的に:eventual
	最長:longest
	唯一の:only
	後続:
	同様:
	自身:
	複数:
	以上
	以下
	以外
	任意な:arbitrary
	任意の:any
	どの:any
	場合:
	部分:parts／
	片方
	一方
	一連
	一部:part of
	時点
	この時点:at this point
	前者:
	一環:as part of
	同時:
	類:category
	数~段~先:subsequently
	のみ／~~唯一の:sole
	もっぱら:solely
	回数:count
	該当:
	他所で:other parts
	ときには／こともある:sometimes
	1 個だけ:only
	個数:length
	他方:one other
	ここでも:again
	さらに／より:further
	:across
	以前は:previously
	様々な／各種:various
	種々の:variety of
	まるごと:altogether
	-:rest
	より後:greater than
	開始-時の:starting
	全箇所で:everywhere
	冒頭:opening

	●変数名
js:JS
idl:IDL

	%number長さ:numberLen
	%object:object
	%uint32長さ:uint32Len
	%~buffer~source:bufferSource
	%~byte列:bytes
	%~callable:callable
	%~callback:callback
	%~callback関数:callbackFn
	%~class文字列:classString
	%~configure可能
	%~entry:entry
	%~error:error
	%~js~key:jsKey
	%~js~mb値
	%~js値:jsValue
	%~js引数~群:jsArgs
	%~js引数~群:args
	%~js辞書
	%~js配列~buffer:jsArrayBuffer
	-:jsSharedArrayBuffer
	%~js~view:jsView
	%~js~buffer:jsBuffer
	%~js~buffer~source:jsBufferSource
	%~js~buffer~view:jsBufferView
	%~js転送-済み:jsTransferred
	%~handler
	%~ID:id
	%~idl~key:idlKey
	%~idl~obj:idlObject
	%~idl値:idlValue
	%~idl引数~群:args
	%~idl引数~群:idlArgs
	%~idl辞書:idlDict
	%~idl~callback:idlCallback
	%~ifc:interface
	%~ifc~obj:interfaceObject
	%~ifc原型~obj:interfaceProtoObj
	%~index:index
	%~instance:-
	%~instance:instance
	%~key:key
	%~key群:keys
	%~key型:keyType
	%~key引数:keyArg
	%~map:map
	%~mb:member
	%~metadata:info
	%~method:method
	%~mixin:mixin
	%~ns:namespace
	%~ns~obj:namespaceObject
	%~obj:obj
	%~offset:offset
	%~pair:pair
	%~pair群:pairs
	%~promise:promise
	%~promise~index:promiseIndex
	%~promise群:promises
	%~promise能力:promiseCapability
	%~realm:realm
	%~realm；
	%~return~promise:returnPromise
	%~return~promise能力:returnPromiseCapability
	%~return手続き:returnSteps
	%~return~method:returnMethod
	%~return結果:returnResult
	%~return~promise:~returnPromise
	%~return~promise結果:~returnPromiseResult
	%~scope不能~obj:unscopableObject
	%~slot群:slots
	%~stack:stack
	%~target:target
	%~target~realm:targetRealm
	%~task~source:taskSource
	%~this引数:thisArg
	%~thisを検証する~promise能力:thisValidationPromiseCapability
	%~thisは妥当か:validThis
	`this^jv 値:thisValue
	%この検証~promise能力:thisValidationPromiseCapability
	%集合:set
	%引数:arg
	%引数~群:args
	%引数~個数:argcount
	%最大~引数~個数:maxarg
	-:argCount
	%個数:count
	%引数~宣言~list:-
	%事由:reason
	%作成したか:created
	%作成するか:creating
	%名前:name
	%値:value
	%値~IDL:valueIDL
	%値~群:values
	%値~型:valueType
	%値~引数:valueArg
	%偽造-不能~obj:unforgeables
	%充足-回数:fullfilledCount
	%充足-手続き:fulfillSteps
	%充足-時の手続き:onFulfilledSteps
	%充足-時の関数:onFulfilled
	%充足~handler:fulfillmentHandler
	%充足~手続き:-
	%却下-時の手続き:onRejectedSteps
	%却下-時の関数:%onRejected
	%却下~handler:rejectionHandler
	%却下~handler手続き:rejectionHandlerSteps
	%却下~手続き:-
	%却下された:rejected
	%却下される~promise:rejectedPromise
	%決着-時の関数:onSettled
	%先祖~ifc:-
	%入力:-
	%内縁~配列:innerArray
	%削除する~algo:deleteAlgorithm
	%削除する~index:indexToDelete
	%原型:proto
	%反復子:iterator
	%反復子~record:iteratorRecord
	%反復子~obj:iteratorObj
	%反復-結果:iterResult
	%取得子:getter
	%可反復:iterable
	%合計:total
	%型:-
	%型:type
	%型~群:types
	%型~集合:-
	%変換-結果:convertResult
	%失敗~手続き:failureSteps
	%定数:const
	%定義:definition
	%属性:attr
	%属性:attribute
	%属性~群:attributes
	%後の進行中な~promise能力:afterOngoingPromiseCapability
	%進行中な~promise:ongoingPromise
	%応答~promise群:responsePromises
	%成功~手続き:successSteps
	%手続き:steps
	%文字列化子:stringifier
	%新-~target:newTarget
	%新-長さ:newLen
	%新たな値~群:newValues
	%新たな能力:newCapability
	%旧-長さ:oldLen
	%有名~propは無視するか:ignoreNamedProps
	%旧来の~factory関数:legacyFactoryFunction
	%有型~key:typedKey
	%有型~値:typedValue
	%格納-済み設定群:stored settings
	%構成子:construct
	%構築子:constructor
	%構築子~原型:constructorProto
	%次回の:next
	%次回の~promise:nextPromise
	%次回の~promise能力:nextPromiseCapability
	%次回の手続き:nextSteps
	%次回の結果:nextResult
	%演算:op
	%演算~名:opName
	%演算~群:operations
	%環境:env
	%環境:environment
	%省略可否:optionality
	%種類:kind
	%結果:result
	%結果~群:results
	%結果:callResult
	%結果:completion
	%結果:getResult
	%返り値:retVal
	%自前の~key群:ownKeys
	%自前の記述子:ownDesc
	%行:-
	%観測-可能な配列:oa
	%記述子:desc
	%記述子:Desc
	%記述子:descriptor
	%記述子~obj:descriptorObj
	%設定する~algo:setAlgorithm
	%設定子:setter
	%識別子:id
	%辞書:dictionary
	%長さ:length
	-:len
	%関連な設定群:relevant settings
	-:idlMemberValue
	%宛先~realm:targetRealm
	%配列:array
	%配列~buffer~data:arrayBufferData
	%配列~buffer~byte長さ:arrayBufferByteLength
	%配列~buffer:arrayBuffer
	-:sharedArrayBuffer
	%開始-時の~offset:startingOffset
	%拡張を防止するか:preventExtensions
	%有符号か:signedness
	%最大:-
	%最小:-
	%回送-~ID:forwardId
	%完了~record:completion
	%例外:ex
	%例外:O
	%例外の挙動:exceptionBehavior
	%済んだか:done
	%手続き:step
	%完遂-:finish
	%同期c~method:syncMethod
	%非同期c~method:asyncMethod

	%A
	%B
	%C
	%D
	%E
	%F
	%G
	%H
	%I
	%J
	%K
	%N
	%O
	%P
	%Q
	%R
	%S
	%T
	%U
	%V
	%X
	%Receiver
	%M:modifiable
	%d
	%defineProperty
	%deleteProperty
	%get
	%getOwnPropertyDescriptor
	%has
	%i
	%k
	%m
	%n
	%next
	%op
	%p
	%proto
	%prototype
	%r
	%target
	%v
	%x
	%y


	●変数名（例
	%a
	%b
	%c
	%d
	%e
	%a1
	%a2
	%abc
	%alice
	%arg
	%blue
	%breedName
	%canvas
	%context
	%coordinates
	%counter
	%def
	%details
	%entries
	%et
	%example
	%fn
	%forgedLoginTime
	%green
	%height
	%iframe
	%indexedDB
	%instance
	%key
	%length
	%localName
	%manager
	%map1
	%map2
	%ms
	%myMU
	%node
	%obj
	%otherMU
	%pixels
	%proto
	%promise
	%red
	%requestAnimationFrame
	%result
	%src
	%supportedImageCodecs
	%system
	%thing
	%url
	%urls
	%value
	%w
	%width
	%x
	%y


●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる Web IDL の
<a href="~SPEC_URL#javascript-binding">§ JavaScript binding</a>
を日本語に翻訳したものです。
</p>

</script>

</head>

<body>

<header>
	<hgroup>
<h1 title="Web IDL">Web IDL — JavaScript 言語束縛</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

<p class="trans-note">【
この~pageは、編集の都合により，
<a href="~WEBIDL">~Web~IDL仕様</a>
を成す一部を別に分けたものです。
仕様~metadata（および著作権情報）は、その~pageを参照されたし。
】</p>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

<p>
この仕様~自身にも，
`表記規約＠~WEBIDL#conventions$がある。
</p>

	</section>
	<section id="javascript-binding">
<h2 title="JavaScript binding">3. ~JS言語束縛</h2>

<p>
この節では、
`~ifc定義~言語＠~WEBIDL#idl§にて定義された~IDLで記される`定義$が，
`ECMAScript 言語~仕様^cite `ECMA-262$r
により定義される~JSの中の特定0の構成子にどう対応するかを述べる。
◎
This section describes how definitions written with the IDL defined in § 2 Interface definition language correspond to particular constructs in JavaScript, as defined by the ECMAScript Language Specification [ECMA-262].
</p>

<p>
他が指定されない限り、
この節に定義される~objは，
`ECMA-262$r `普通の~objの内部~methodと内部~slot＠~TC39#sec-ordinary-object-internal-methods-and-internal-slots§
にて述べられるとおり`普通の~obj$であり、
当の~objは`関数~obj$である場合は，`組込みの関数~obj$ `ECMA-262$r であるとする。
◎
Unless otherwise specified, objects defined in this section are ordinary objects as described in ECMAScript § 10.1 Ordinary Object Internal Methods and Internal Slots, and if the object is a function object, ECMAScript § 10.3 Built-in Function Objects.
</p>

<p>
この節では、
一部の~objに対し，ある種の［
内部~method ／ 内部~slot
］を定義し直す。
他の仕様も、［
`~ifc$の~instanceである`~platform~obj$
］の［
内部~method ／ 内部~slot
］の定義を上書きしてヨイ。
これらの［
意味論が変更された~obj
］は、
~exotic~obj用の規則に則って扱うものとする。
◎
This section may redefine certain internal methods and internal slots of objects. Other specifications may also override the definitions of any internal method or internal slots of a platform object that is an instance of an interface. These objects with changed semantics shall be treated in accordance with the rules for exotic objects.
</p>

<p class="warning">
内部~JS~obj~methodを上書きすることは、
低~levelな演算であり，~objの挙動を`普通の~obj$から違えさせ得るので、
この便宜性は，［
~security／互換性
］のために必要yでない限り，利用するべきでない。
現時点で，これを利用して定義された~ifcは、
`HTML$r の［
`HTMLAllCollection$T, `Location$T
］である。
◎
As overriding internal JavaScript object methods is a low level operation and can result in objects that behave differently from ordinary objects, this facility should not be used unless necessary for security or compatibility. This is currently used to define the HTMLAllCollection and Location interfaces. [HTML] 
</p>

<p>
他が指定されない限り，［
この節 ／ 他の仕様
］に定義される~exotic~objは：
◎
Unless otherwise specified, exotic objects defined in this section and other specifications＼
</p>
<ul>
	<li>
`普通の~obj$と同じ`内部~slot$たちを有するとする。
◎
have the same internal slots as ordinary objects,＼
</li>
	<li>
その内部~methodのうち代替な定義が与えられなかったものは、
すべて，`普通の~objの内部~method＠~TC39#sec-ordinary-object-internal-methods-and-internal-slots$と同じになるとする。
◎
and all of the internal methods for which alternative definitions are not given are the same as those of ordinary objects.
</li>
</ul>

<p>
他が指定されない限り，この節に定義される~objの：
◎
↓</p>
<ul>
	<li>
`Extensible^sl 内部~slotの値は `true^jv とする。
◎
Unless otherwise specified, the [[Extensible]] internal slot of objects defined in this section has the value true.
</li>
	<li>
`Prototype^sl 内部~slotは `Object.prototype$jI になるとする。
◎
Unless otherwise specified, the [[Prototype]] internal slot of objects defined in this section is %Object.prototype%.
</li>
</ul>

<p>
この節にて述べる一部の~objは、
`~class文字列@
を有するものと定義される。
この文字列は、
`Object.prototype.toString^c が返す文字列に内包されることになる。
◎
Some objects described in this section are defined to have a class string, which is the string to include in the string returned from Object.prototype.toString.
</p>

<div class="p">
<p>
`~class文字列$ %~class文字列 を有する~objは、
その作成-時に，次の特性を伴う~propを有するモノトスル：
</p>
<ul>
	<li>
名前：
`Symbol.toStringTag$jI ~symbol
</li>
	<li>
次の属性を伴う
⇒
`FFT-~class文字列^desc
</li>
</ul>
◎
If an object has a class string classString, then the object must, at the time it is created, have a property whose name is the %Symbol.toStringTag% symbol with PropertyDescriptor{[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true, [[Value]]: classString}.
</div>

<p id="ecmascript-abstractop">
この節の中の~algoは、
手続き, 数学的~演算, 等々の利用に関し，
`ECMA-262$r `~algo規約§に述べられる表記規約を利用する。
この節は、
ECMA-262 の他所で定義される［
抽象-演算 ／ 記法
］も参照する。
◎
Algorithms in this section use the conventions described in ECMAScript § 5.2 Algorithm Conventions, such as the use of steps and substeps, the use of mathematical operations, and so on. This section may also reference abstract operations and notations defined in other parts of ECMA-262.
</p>

<p>
~algoにおいて
“`~THROW@ `SomethingError^E”
と記される所では、
`現在の~realm$に属する新たな~JS `SomethingError^E ~objを構築して，
ECMA-262 の~algoとちょうど同じ様に投出することを意味する。
◎
When an algorithm says to throw a SomethingError then this means to construct a new JavaScript SomethingError object in the current realm and to throw it, just as the algorithms in ECMA-262 do.
</p>

<p>
~algoを成す各~段は，他の~algoや抽象-演算の中へ~callし得るが、
それらから投出される例外は，明示的には取扱われていないことに注意。
~algoまたは抽象-演算により例外が投出され，それが~call元により明示的に取扱われない所では、
~algoは終了~され，その~call元~の更に外へ伝播する，等々となる。
◎
Note that algorithm steps can call in to other algorithms and abstract operations and not explicitly handle exceptions that are thrown from them. When an exception is thrown by an algorithm or abstract operation and it is not explicitly handled by the caller, then it is taken to end the algorithm and propagate out to its caller, and so on.
</p>

<div class="example">
<p>
次の~algoを考える：
◎
Consider the following algorithm:
</p>

<div class="algo">
<ol>
	<li>
%x ~LET この~algoに渡された~JS値
◎
Let x be the JavaScript value passed in to this algorithm.
</li>
	<li>
%y ~LET
~ABRUPT `ToString$A( %x )
◎
Let y be the result of calling ? ToString(x).
</li>
	<li>
~RET %y
◎
Return y.
</li>
</ol>
</div>

<p>
`ToString$A は例外を投出し得るが
（例えば、
~obj `({ toString: function() { throw 1 } })^c が渡されたとき）、
この~algoは例外を取扱わない
— なので，投出された場合、
この~algoは終了~され，その例外は ~call元が在るならば そこへ伝播する。
◎
Since ToString can throw an exception (for example if passed the object ({ toString: function() { throw 1 } })), and the exception is not handled in the above algorithm, if one is thrown then it causes this algorithm to end and for the exception to propagate out to its caller, if there is one.
</p>
</div>

		<section id="js-environment">
<h3 title="JavaScript environment">3.1. ~JS環境</h3>

<p>
所与の［
`~IDL片$たちが成す集合
］に対する~JS実装においては、
それらの`~IDL片$の中の各 定義に対応する，~JS~objが存在することになる。
これらの~objは
`初期~obj@
と呼ばれ、
次に挙げるものからなる：
◎
In a JavaScript implementation of a given set of IDL fragments, there will exist a number of JavaScript objects that correspond to definitions in those IDL fragments. These objects are termed the initial objects, and comprise the following:
</p>
<ul>
	<li>
`~ifc~obj$
◎
interface objects
</li>
	<li>
`旧来の~callback~ifc~obj$
◎
legacy callback interface objects
</li>
	<li>
`旧来の~factory関数$
◎
legacy factory functions
</li>
	<li>
`~ifc原型~obj$
◎
interface prototype objects
</li>
	<li>
`有名~prop群~obj$
◎
named properties objects
</li>
	<li>
`反復子~原型~obj$
◎
iterator prototype objects
</li>
	<li>
`属性~取得子$
◎
attribute getters
</li>
	<li>
`属性~設定子$
◎
attribute setters
</li>
	<li>
`演算に対応する関数~obj＠#js-operations$
◎
the function objects that correspond to operations
</li>
	<li>
`文字列化子に対応する関数~obj＠#js-stringifier$
◎
the function objects that correspond to stringifiers
</li>
</ul>

<p>
どの`~realm$ %R も、［
各自に一意な自前の各種`初期~obj$からなる集合 %S
］を有するモノトスル。
%S が作成されるのは、［
%R 用の`大域~obj$が作成された後, かつ
%R に結付けられた~JS実行~文脈に制御が移る前
］になるモノトスル。
%R に属する どの初期~objも，その `Prototype^sl は %R に属するモノトスル。
◎
Each realm must have its own unique set of each of the initial objects, created before control enters any JavaScript execution context associated with the realm, but after the global object for that realm is created. The [[Prototype]]s of all initial objects in a given realm must come from that same realm.
</p>

<p class="trans-note">【
“~realmに属する” という句は、
所与の~objが同時に複数の`~realm$に属することは決してないことを含意する
— %S （を成す各種~初期~obj）は~realmごとに一意なので。
】</p>

<div class="example">
<p>
~HTML~UAにおいては、
複数の~frameや~windowが作成されるときに，複数の`~realm$が存在し得る。
各［
~frame／~window
］は、
自前の`初期~obj$たちが成す集合を有することになる。
次の~HTML文書にデモるように：
◎
In an HTML user agent, multiple realms can exist when multiple frames or windows are created. Each frame or window will have its own set of initial objects, which the following HTML document demonstrates:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
相異なる~realm
◎
Different Realms
</span>&lt;/title&gt;
&lt;iframe id=a&gt;&lt;/iframe&gt;
&lt;script&gt;
var %iframe = document.getElementById("a");
var %w = %iframe.contentWindow;     /* <span class="comment">
~frame内の大域~obj
◎
The global object in the frame
</span> */

Object == %w.Object;       /* <span class="comment">
ECMA-262 に則り， `false^jv に評価される。
◎
Evaluates to false, per ECMA-262
</span> */
Node == %w.Node;                            /* <span class="comment" id="cp-eval-false">
`false^jv に評価される。
◎
Evaluates to false.
</span> */
%iframe instanceof %w.Node;                  /* <!--cp-eval-false--> */
%iframe instanceof %w.Object;                /* <!--cp-eval-false--> */
%iframe.appendChild instanceof Function;    /* <span class="comment" id="cp-eval-true">
`true^jv に評価される。
◎
Evaluates to true.
</span> */
%iframe.appendChild instanceof %w.Function;  /* <!--cp-eval-false--> */
&lt;/script&gt;
</pre>
</div>

<p class="note">注記：
すべての`~ifc$は、
どの`~realm$内に`公開され$るかを定義する。
これにより，例えば、［
Web Workers 用の`~realm$が~supportするものとして`公開され$る，~ifcたちが成す集合
］を［
~Web~page用に公開されるそれら
］と違えることも許容される。
◎
Note: All interfaces define which realms they are exposed in. This allows, for example, realms for Web Workers to expose different sets of supported interfaces from those exposed in realms for Web pages.
</p>

<p>
これを書いた時点では，~JS仕様には まだ反映されてないが、
どの~JS~objにも，ある`~realm$が結付けられるモノトスル
— この~realmを指して，~objが
`属する~realm@
という。
◎
Although at the time of this writing the JavaScript specification does not reflect this, every JavaScript object must have an associated realm.＼
</p>

<p>
各~objに~realmを結付けるための仕組みは、
今の所，策定中にあるが：
◎
The mechanisms for associating objects with realms are, for now, underspecified. However, we note that＼
</p>
<ul>
	<li>
`~platform~obj$用には、
それが`属する~realm$は，当の~objに`関連な~realm$に等しい。
◎
in the case of platform objects, the associated realm is equal to the object’s relevant realm, and＼
</li>
	<li>
~exoticでない`関数~obj$
（すなわち，`~callable$な~proxyでも, ~bindされた関数でもない それ）
用には、
それが`属する~realm$は，当の~objの `Realm^sl 内部~slotの値に等しい。
◎
for non-exotic function objects (i.e. not callable proxies, and not bound functions) the associated realm is equal to the value of the function object’s [[Realm]] internal slot.
</li>
</ul>

		</section>
		<section id="js-type-mapping">
<h3 title="JavaScript type mapping">3.2. ~JS型との対応付け</h3>

<p>
この節では、
~IDLにおける各~型が，~JSにおける型に どう対応付けられるかについて述べる。
◎
This section describes how types in the IDL map to types in JavaScript.
</p>

<div class="p">
<p>
以下の各~下位~節では、
所与の［
~IDL型の値
］が，~JSの中では どう表現されるかを述べる。
各種~IDL型に対し、
その型を期待する`~platform~obj$に~JS値が渡された際に
`~IDL値に変換する@
方法, および
その型の~IDL値が~platform~objから返される際に
`~JS値に変換する@
方法が述べられる。
</p>

<p>
【和訳における表記規約として、】
これらは、
次の形を成す句により呼出されることもある
⇒＃
`~IDL値に変換する$( 所与の~JS値, 所与の~IDL型 ) ／
`~JS値に変換する$( 所与の~IDL値 ) ／
</p>

◎
Each sub-section below describes how values of a given IDL type are represented in JavaScript. For each IDL type, it is described how JavaScript values are converted to an IDL value when passed to a platform object expecting that type, and how IDL values of that type are converted to JavaScript values when returned from a platform object.
</div>

<p>
以下の各［
下位~節／~algo
］は、
`注釈された型$
— 当の節の見出しに挙げられる型に`拡張d属性$を適用して作成される型 —
にも適用されることに注意。
◎
Note that the sub-sections and algorithms below also apply to annotated types created by applying extended attributes to the types named in their headers.
</p>

			<section id="js-any">
<h4>3.2.1. `any^T</h4>

<p>
~IDL `any$T 型は、
他のすべての~IDL型の和集合なので，どの~JS値~型にも対応し得る。
◎
Since the IDL any type is the union of all other IDL types, it can correspond to any JavaScript value type.
</p>

<div class="algo">
<p id="js-to-any">
~JS値 %V を `any$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL any value by running the following algorithm:
</p>
<ol>
	<li>
<p>
~RET %V に応じて：
◎
↓</p>
		<ul class="switch">
			<li>
`undefined^jv
⇒
~RET 一意な `undefined$T ~IDL値
◎
If V is undefined, then return the unique undefined IDL value.
</li>
			<li>
`null^jv
⇒
~RET `null^V `object$T`​?^T 参照
◎
If V is null, then return the null object? reference.
</li>
			<li>
`Boolean$jt である
⇒
同じ真偽-値を表現する `boolean$T 値
◎
If V is a Boolean, then return the boolean value that represents the same truth value.
</li>
			<li>
`Number$jt である
⇒
`unrestricted double＠#js-unrestricted-double§T に従って，
%V を `unrestricted double$T 値に変換した結果
◎
If V is a Number, then return the result of converting V to an unrestricted double.
</li>
			<li>
`BigInt$jt である
⇒
`bigint＠#js-bigint§T に従って，
%V を `bigint$T 値に変換した結果
◎
If V is a BigInt, then return the result of converting V to a bigint.
</li>
			<li>
`String$jt である
⇒
`DOMString＠#js-DOMString§T に従って，
%V を `DOMString$T 値に変換した結果
◎
If V is a String, then return the result of converting V to a DOMString.
</li>
			<li>
`Symbol$jt である
⇒
`symbol＠#js-symbol§T に従って，
%V を `symbol$T 値に変換した結果
◎
If V is a Symbol, then return the result of converting V to a symbol.
</li>
			<li>
`Object$jt である
⇒
%V を参照する~IDL `object$T 値
◎
If V is an Object, then return an IDL object value that references V.
</li>
		</ul>
	</li>
</ol>
</div>

<p id="any-to-js">
~IDL `any$T 値 %V を`~JS値に変換する$ときは、［
この`~JS型との対応付け＠#js-type-mapping§の中の他所にて述べる，
%V の`特有~型$を`~JS値に変換する$ための規則
］に従うとする。
◎
An IDL any value is converted to a JavaScript value according to the rules for converting the specific type of the IDL any value as described in the remainder of this section.
</p>

			</section>
			<section id="js-undefined">
<h4>3.2.2. `undefined^T</h4>

<div class="algo">
<p id="js-to-undefined">
~JS値 %V を `undefined$T 型の`~IDL値に変換する$ときは
⇒
~RET 一意な `undefined$T 値（ %V は無視する）
◎
A JavaScript value V is converted to an IDL undefined value by returning the unique undefined value, ignoring V.
</p>
</div>

<div class="algo">
<p id="undefined-to-js">
~IDL `undefined$T 値を`~JS値に変換する$ときは
⇒
~RET ~JS `undefined^jv 値
◎
The unique IDL undefined value is converted to the JavaScript undefined value.
</p>
</div>

			</section>
			<section id="js-boolean">
<h4>3.2.3. `boolean^T</h4>

<div class="algo">
<p id="js-to-boolean">
~JS値 %V を `boolean$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL boolean value by running the following algorithm:
</p>
<ol>
	<li>
%x ~LET `ToBoolean$A( %V ) の算出-結果
◎
Let x be the result of computing ToBoolean(V).
</li>
	<li>
~RET ［
~JS `Boolean^jt 値 %x
］と同じ真偽-値を表現する~IDL `boolean$T 値
◎
Return the IDL boolean value that is the one that represents the same truth value as the JavaScript Boolean value x.
</li>
</ol>
</div>

<p class="algo" id="boolean-to-js">
~IDL `boolean$T 値［
`true^V ／ `false^V
］を`~JS値に変換する$ときは
⇒
~RET 値に応じて
⇒＃
`true^V ならば ~JS `true^jv 値／
`false^V ならば ~JS `false^jv 値
◎
The IDL boolean value true is converted to the JavaScript true value and the IDL boolean value false is converted to the JavaScript false value.
</p>

			</section>
			<section id="js-integer-types">
<h4 title="Integer types">3.2.4. 整数~型</h4>

<p>
この節に利用される数学的~演算は、
`ECMA-262$r `~algo規約§に定義されるものも含め，数学的~実数による数学的に正確な結果を算出していると解されるとする。
◎
Mathematical operations used in this section, including those defined in ECMAScript § 5.2 Algorithm Conventions, are to be understood as computing exact mathematical results on mathematical real numbers.
</p>

<p>
`Number^jt 値 %x に対し，
“%x に演算する”
ことは、
実質的に
“%x と同じ数量-値を表現する数学的~実数に演算する”
ことの略記である。
◎
In effect, where x is a Number value, “operating on x” is shorthand for “operating on the mathematical real number that represents the same numeric value as x”.
</p>

<dl>
	<dt id="js-byte">3.2.4.1. `byte^T</dt>
	<dt id="js-octet">3.2.4.2. `octet^T</dt>
	<dt id="js-short">3.2.4.3. `short^T</dt>
	<dt id="js-unsigned-short">3.2.4.4. `unsigned short^T</dt>
	<dt id="js-long">3.2.4.5. `long^T</dt>
	<dt id="js-unsigned-long">3.2.4.6. `unsigned long^T</dt>
	<dt id="js-long-long">3.2.4.7. `long long^T</dt>
	<dt id="js-unsigned-long-long">3.2.4.8. `unsigned long long^T</dt>
	<dd class="trans-note">【
この訳では、
原文のこれら各~下位~節の内容
— ~JS値 から各種~IDL整数~型 値への変換, およびその逆の変換の定義 —
を集約して，一括して与える。
】</dd>
</dl>

<div class="algo">
<p>
<a id="js-to-byte"></a
><a id="js-to-octet"></a
><a id="js-to-short"></a
><a id="js-to-unsigned-short"></a
><a id="js-to-long"></a
><a id="js-to-unsigned-long"></a
><a id="js-to-long-long"></a
><a id="js-to-unsigned-long-long"></a>
~JS値 %V を `整数~型$ %T の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL _T_ value by running the following algorithm:
</p>
<ol>
	<li>
%x ~LET
~ABRUPT `ConvertToInt$A( %V, %T )
◎
Let x be ? ConvertToInt(V, _N_, "signed|unsigned").
</li>
	<li>
~RET %x と同じ数量-値を表現する，型 %T の~IDL値
◎
Return the IDL _T_ value that represents the same numeric value as x.
</li>
</ol>
</div>

<div class="algo">
<p>
<a id="byte-to-js"></a
><a id="octet-to-js"></a
><a id="short-to-js"></a
><a id="unsigned-short-to-js"></a
><a id="long-to-js"></a
><a id="unsigned-long-to-js"></a
><a id="long-long-to-js"></a
><a id="unsigned-long-long-to-js"></a>
~IDL`整数~型$ %T の値 %V を`~JS値に変換する$ときは、
%T に応じて：
</p>

<dl class="switch">
	<dt>`long long$T</dt>
	<dt>`unsigned long long$T</dt>
	<dd id="_int-toES_">
%V に最も近い数量-値を表現する `Number^jt 値
⇒
2 数が等距離にある場合は，`仮数が偶数になる方^emを選ぶとする
</dd>
	<dd>
%V が範囲 { %最小 〜 %最大 }† に入るならば、
その値 は %V と正確に同じ値を表現できることになる。
</dd>

	<dt>他の整数~型</dt>
	<dd>
%V と同じ数量-値を表現する `Number^jt 値。
</dd>
	<dd>
その値は 範囲 { %最小 〜 %最大 }† に入る整数になる。
</dd>
</dl>

<p>†
上の %最小, %最大 は、
次節の `ConvertToInt$A にて与えられる。
</p>

◎
The result of converting an IDL _T_ value to a JavaScript value is a Number value that represents the closest numeric value to the _T_, choosing the numeric value with an even significand if there are two equally close values. If the _T_ is in the range [_MIN_, _MAX_], then the Number will be able to represent exactly the same value as the _T_.
◎
Number that represents the same numeric value as the IDL _T_ value. The Number value will be an integer in the range [_MIN_, _MAX_].
</div>

				<section id="js-integer-types-abstract-ops">
<h5 title="Abstract operations">3.2.4.9. 抽象-演算</h5>

<div class="algo">
<p>
`IntegerPart@A( %n )：
◎
IntegerPart(n):
</p>
<ol>
	<li>
%r ~LET `floor$op( `abs$op( %n ) )
◎
Let r be floor(abs(n)).
</li>
	<li>
~IF［
%n ~LT 0
］
⇒
~RET −1 ~MUL %r
◎
If n &lt; 0, then return -1 × r.
</li>
	<li>
~RET %r
◎
Otherwise, return r.
</li>
</ol>
</div>

<div class="algo">
<p>
`ConvertToInt@A( %V, %T )：
◎
ConvertToInt(V, bitLength, signedness):
</p>
<ol>
	<li>
<p>
( %N, %最小, %最大, %有符号か ) ~LET
%T に応じて，次の表tで与えられる値：
</p>

<table id="matrix-integers"><thead>
<tr><th>%T
<th>%N
<th>%最小
<th>%最大
<th>%有符号か
<tbody>

<tr><th>`byte$T
<td>8
<td>−2`7^sup
<td>2`7^sup ~MINUS 1
<td>~T

<tr><th>`octet$T
<td>8
<td>0
<td>2`8^sup ~MINUS 1
<td>~F

<tr><th>`short$T
<td>16
<td>−2`15^sup
<td>2`15^sup ~MINUS 1
<td>~T

<tr><th>`unsigned short$T
<td>16
<td>0
<td>2`16^sup ~MINUS 1
<td>~F

<tr><th>`long$T
<td>32
<td>−2`31^sup
<td>2`31^sup ~MINUS 1
<td>~T

<tr><th>`unsigned long$T
<td>32
<td>0
<td>2`32^sup ~MINUS 1
<td>~F

<tr><th>`long long$T
<td>64
<td>−2`53^sup ~PLUS 1
<td>2`53^sup ~MINUS 1
<td>~T

<tr><th>`unsigned long long$T
<td>64
<td>0
<td>2`53^sup ~MINUS 1
<td>~F
</table>

<p class="note">注記：
`long long^T, `unsigned long long^T の
%最小, %最大
を 2 の 53 乗で~~制限しているのは、［
`EnforceRange$x ／ `Clamp$x
］`拡張d属性が結付けられ$た `long long$T 型を，~JS `Number$jt 型の整数として一義的に表現できることを確保するためである。
</p>
◎
If bitLength is 64, then:
• Let upperBound be 253 − 1.
• If signedness is "unsigned", then let lowerBound be 0.
• Otherwise let lowerBound be −253 + 1.
◎
Note: this ensures long long types associated with [EnforceRange] or [Clamp] extended attributes are representable in JavaScript’s Number type as unambiguous integers.
◎
Otherwise, if signedness is "unsigned", then:
• Let lowerBound be 0.
• Let upperBound be 2bitLength − 1.
◎
Otherwise:
• Let lowerBound be -2bitLength − 1.
• Let upperBound be 2bitLength − 1 − 1.
</li>
	<li>
%x ~LET
~ABRUPT `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<li>
~IF［
%x ~EQ −0
］
⇒
%x ~SET +0
◎
If x is −0, then set x to +0.
</li>
	<li>
<p>
~IF［
`EnforceRange$x `拡張d属性が結付けられ$た~IDL型への変換である
］：
◎
If the conversion is to an IDL type associated with the [EnforceRange] extended attribute, then:
</p>
		<ol>
			<li id="cp-x-isNonFinite">
~IF［
%x ~IN { `NaN^jv, +∞, −∞ }
］
⇒
`~THROW$ `TypeError$jt
◎
If x is NaN, +∞, or −∞, then throw a TypeError.
</li>
			<li id="cp-floor_x">
%x ~SET
`IntegerPart$A( %x )
◎
Set x to IntegerPart(x).
</li>
			<li>
~IF［
%x ~LT %最小
］~OR［
%x ~GT %最大
］
⇒
`~THROW$ `TypeError$jt
◎
If x &lt; lowerBound or x &gt; upperBound, then throw a TypeError.
</li>
			<li>
~RET %x
◎
Return x.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%x ~NEQ `NaN^jv
］~AND［
`Clamp$x `拡張d属性が結付けられ$た~IDL型への変換である
］：
◎
If x is not NaN and the conversion is to an IDL type associated with the [Clamp] extended attribute, then:
</p>
		<ol>
			<li>
%x ~SET `min$op( `max$op( %x, %最小 ), %最大 )
◎
Set x to min(max(x, lowerBound), upperBound).
</li>
			<li>
~RET %x を最も近い整数に丸めた結果
⇒
2 つの整数と等距離にある場合は偶数を選び，−0 より +0 の方を選ぶとする
◎
Round x to the nearest integer, choosing the even integer if it lies halfway between two, and choosing +0 rather than −0.
◎
Return x.
</li>
		</ol>
	</li>
	<li>
~IF［
%x ~IN { `NaN^jv, +0, +∞, −∞ }
］
⇒
~RET 0
◎
If x is NaN, +0, +∞, or −∞, then return +0.
</li>
	<!--cp-floor_x-->
	<li>
%x ~SET %x `modulo$op 2<sup>%N</sup>
◎
Set x to x modulo 2bitLength.
</li>
	<li>
~IF［
%有符号か ~EQ ~T
］~AND［
%x  ~GTE 2<sup>%N ~MINUS 1</sup>
］
⇒
~RET %x ~MINUS 2<sup>%N</sup>
◎
If signedness is "signed" and x ≥ 2bitLength − 1, then return x − 2bitLength.
</li>
	<li>
~RET %x
◎
Otherwise, return x.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="js-float">
<h4>3.2.5. `float^T</h4>

<div class="algo">
<p id="js-to-float">
~JS値 %V を `float$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL float value by running the following algorithm:
</p>
<ol>
	<li id="cp-ToNumber">
%x ~LET
~ABRUPT `ToNumber$A( %V )
◎
Let x be ? ToNumber(V).
</li>
	<!--cp-x-isNonFinite-->
	<li id="cp-let-S-to754">
%S ~LET ［
−0 を除く有限 IEEE 754 単精度 浮動小数点~値が成す集合に， 2 つの特別な値
{ 2`128^sup, −2`128^sup }
を追加した集合
］
◎
Let S be the set of finite IEEE 754 single-precision floating point values except −0, but with two special values added: 2^128 and −2^128.
</li>
	<li id="cp-round-x-to-y">
%y ~LET 
%S の中で %x に最も近い数量-値
⇒
2 数が等距離にある場合は，`仮数が偶数になる方^emを選ぶとする
⇒
この目的においては， 2 つの特別な値 2`128^sup, −2`128^sup の仮数は偶数と見なされる。
◎
Let y be the number in S that is closest to x, selecting the number with an even significand if there are two equally close values. (The two special values 2^128 and −2^128 are considered to have even significands for this purpose.)
</li>
	<li>
~IF［
%y ~IN { 2`128^sup, −2`128^sup }
］
⇒
`~THROW$ `TypeError$jt
◎
If y is 2^128 or −2^128, then throw a TypeError.
</li>
	<li id="cp-if-y-0-x-lt0">
~IF［
%y ~EQ +0
］~AND［
%x ~LT 0
］
⇒
~RET −0
◎
If y is +0 and x is negative, return −0.
</li>
	<li id="cp-ret-y">
~RET %y
◎
Return y.
</li>
</ol>
</div>

<p class="algo" id="float-to-js">
~IDL `float$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V と同じ数量-値を表現する `Number^jt 値
◎
The result of converting an IDL float value to a JavaScript value is the Number value that represents the same numeric value as the IDL float value.
</p>

			</section>
			<section id="js-unrestricted-float">
<h4>3.2.6. `unrestricted float^T</h4>

<div class="algo">
<p id="js-to-unrestricted-float">
~JS値 %V を `unrestricted float$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL unrestricted float value by running the following algorithm:
</p>
<ol>
	<!--cp-ToNumber-->
	<li>
~IF［
%x ~EQ `NaN^jv
］
⇒
~RET ［
~bit~pattern `7fc00000^X の IEEE 754 NaN 値 `IEEE-754$r
］を表現する~IDL `unrestricted float$T 値
◎
If x is NaN, then return the IDL unrestricted float value that represents the IEEE 754 NaN value with the bit pattern 0x7fc00000 [IEEE-754].
</li>
	<!--cp-let-S-to754-->
	<!--cp-round-x-to-y-->
	<li>
~IF［
%y ~EQ 2`128^sup
］
⇒
~RET +∞
◎
If y is 2^128, return +∞.
</li>
	<li>
~IF［
%y ~EQ −2`128^sup 
］
⇒
~RET −∞
◎
If y is −2^128, return −∞.
</li>
	<!--cp-if-y-0-x-lt0-->
	<!--cp-ret-y-->
</ol>
</div>

<p class="note">注記：
~JS `NaN^jv 値は、
唯 1 個しかないので，特定0の単精度 IEEE 754 NaN 値に正準-化されなければならない。
上で言及した NaN 値は、
単純に，［
その~bit~patternが `32 ~bitな無符号~整数$として解釈されたとき，
最低~値の `quiet^en NaN になる
］ことから選ばれている。
◎
Note: Since there is only a single JavaScript NaN value, it must be canonicalized to a particular single precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an 32-bit unsigned integer.
</p>

<div class="algo">
<p id="unrestricted-float-to-js">
~IDL `unrestricted float$T 値 %V を`~JS値に変換する$ための~algoは：
◎
The result of converting an IDL unrestricted float value to a JavaScript value is a Number:
</p>
<ol>
	<li>
~IF［
%V ~EQ NaN
］
⇒
~RET `NaN^jv
◎
If the IDL unrestricted float value is a NaN, then the Number value is NaN.
</li>
	<li>
~RET %V と同じ数量-値を表現する（~~唯一の） `Number^jt 値
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted float value.
</li>
</ol>
</div>

			</section>
			<section id="js-double">
<h4>3.2.7. `double^T</h4>

<div class="algo">
<p id="js-to-double">
~JS値 %V を `double$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL double value by running the following algorithm:
</p>
<ol>
	<!--cp-ToNumber-->
	<!--cp-x-isNonFinite-->
	<li>
~RET ［
%x と同じ数量-値
］を表現する~IDL `double$T 値
◎
Return the IDL double value that represents the same numeric value as x.
</li>
</ol>
</div>

<p class="algo" id="double-to-js">
~IDL `double$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V と同じ数量-値を表現する `Number^jt 値
◎
The result of converting an IDL double value to a JavaScript value is the Number value that represents the same numeric value as the IDL double value.
</p>

			</section>
			<section id="js-unrestricted-double">
<h4>3.2.8. `unrestricted double^T</h4>

<div class="algo">
<p id="js-to-unrestricted-double">
~JS値 %V を `unrestricted double$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL unrestricted double value by running the following algorithm:
</p>
<ol>
	<!--cp-ToNumber-->
	<li>
~IF［
%x ~EQ `NaN^jv
］
⇒
~RET ［
~bit~pattern `7ff8000000000000^X の IEEE 754 NaN 値 `IEEE-754$r
］を表現する~IDL `unrestricted double$T 値
◎
If x is NaN, then return the IDL unrestricted double value that represents the IEEE 754 NaN value with the bit pattern 0x7ff8000000000000 [IEEE-754].
</li>
	<li>
~RET ［
%x と同じ数量-値
］を表現する~IDL `unrestricted double$T 値
◎
Return the IDL unrestricted double value that represents the same numeric value as x.
</li>
</ol>
</div>

<p class="note">注記：
~JS `NaN^jv 値は唯 1 個しかないので，特定0の倍精度 IEEE 754 NaN 値に正準-化されなければならない。
上で言及した NaN 値は、
単純に，［
その~bit~patternが `64 ~bitな無符号~整数$として解釈されたとき，
最低~値の `quiet^en NaN になる
］ことから選ばれている。
◎
Note: Since there is only a single JavaScript NaN value, it must be canonicalized to a particular double precision IEEE 754 NaN value. The NaN value mentioned above is chosen simply because it is the quiet NaN with the lowest value when its bit pattern is interpreted as an 64-bit unsigned integer.
</p>

<div class="algo">
<p id="unrestricted-double-to-js">
~IDL `unrestricted double$T 値 %V を`~JS値に変換する$ための~algoは：
◎
The result of converting an IDL unrestricted double value to a JavaScript value is a Number:
</p>
<ol>
	<li>
~IF［
%V ~EQ NaN
］
⇒
~RET `NaN^jv
◎
If the IDL unrestricted double value is a NaN, then the Number value is NaN.
</li>
	<li>
~RET %V と同じ数量-値を表現する（~~唯一の） `Number^jt 値
◎
Otherwise, the Number value is the one that represents the same numeric value as the IDL unrestricted double value.
</li>
</ol>
</div>

			</section>
			<section id="js-bigint">
<h4 title="bigint">3.2.9. `bigint^T</h4>

<div class="algo">
<p id="js-to-bigint">
~JS値 %V を `bigint$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL bigint value by running the following algorithm:
</p>
<ol>
	<li>
%x ~LET
~ABRUPT `ToBigInt$A( %V )
◎
Let x be ? ToBigInt(V).
</li>
	<li>
~RET %x と同じ数量-値を表現する，型 `bigint$T の~IDL値
◎
Return the IDL bigint value that represents the same numeric value as x.
</li>
</ol>
</div>

<div class="algo">
<p id="bigint-to-js">
~IDL `bigint$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V と同じ数量-値を表現する `BigInt$jt 値
◎
The result of converting an IDL bigint value to a JavaScript value is a BigInt:
• Return the BigInt value that represents the same numeric value as the IDL bigint value.
</p>
</div>

<div class="algo">
<p id="js-to-bigint-or-numeric">
~JS値 %V を~IDL［
`数量-型$ %T, `bigint$T 型
］
`いずれかの型の~IDL値に変換する@
~algoは：
◎
A JavaScript value V is converted to an IDL numeric type T or bigint value by running the following algorithm:
</p>
<ol>
	<li>
%x ~LET
~ABRUPT `ToNumeric$A( %V )
◎
Let x be ? ToNumeric(V).
</li>
	<li>
~IF［
%x は `BigInt$jt である
］
⇒
~RET %x と同じ数量-値を表現する，型 `bigint$T の~IDL値
◎
If x is a BigInt, then
• Return the IDL bigint value that represents the same numeric value as x.
</li>
	<li>
~Assert：
%x は `Number$jt である
◎
Assert: x is a Number.
</li>
	<li>
~RET `~IDL値に変換する$【！`~JS値に変換する$】( %x, %T )
◎
Return the result of converting x to T.
</li>
</ol>
</div>

			</section>
			<section id="js-DOMString">
<h4>3.2.10. `DOMString^T</h4>

<div class="algo">
<p id="js-to-DOMString">
~JS値 %V を `DOMString$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL DOMString value by running the following algorithm:
</p>
<ol>
	<li>
~IF［
%V ~EQ `null^jv
］~AND［
`LegacyNullToEmptyString$x `拡張d属性が結付けられ$た~IDL型への変換である
］
⇒
~RET 空~文字列を表現する `DOMString$T 値
◎
If V is null and the conversion is to an IDL type associated with the [LegacyNullToEmptyString] extended attribute, then return the DOMString value that represents the empty string.
</li>
	<li>
%x ~LET
~ABRUPT `ToString$A( %V )
◎
Let x be ? ToString(V).
</li>
	<li>
~RET ［
その~JS `String^jt 値 %x が表現するものと同じ，`符号単位$並び
］を表現する~IDL `DOMString$T 値
◎
Return the IDL DOMString value that represents the same sequence of code units as the one the JavaScript String value x represents.
</li>
</ol>
</div>

<p class="algo" id="DOMString-to-js">
~IDL `DOMString$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ`符号単位$並びを表現する `String^jt 値
◎
The result of converting an IDL DOMString value to a JavaScript value is the String value that represents the same sequence of code units that the IDL DOMString represents.
</p>

			</section>
			<section id="js-ByteString">
<h4>3.2.11. `ByteString^T</h4>

<div class="algo">
<p id="js-to-ByteString">
~JS値 %V を `ByteString$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL ByteString value by running the following algorithm:
</p>
<ol>
	<li>
%x ~LET
~ABRUPT `ToString$A( %V )
◎
Let x be ? ToString(V).
</li>
	<li>
~IF［
%x の中に 値 ~GT 255 なる`要素$eSがある
］
⇒
`~THROW$ `TypeError$jt
◎
If the value of any element of x is greater than 255, then throw a TypeError.
</li>
	<li>
~RET ［［
各~要素の値 ~SET %x の対応する要素の値
］にされた，
長さ ~EQ %x の長さ
］の~IDL `ByteString$T 値
◎
Return an IDL ByteString value whose length is the length of x, and where the value of each element is the value of the corresponding element of x.
</li>
</ol>
</div>

<p class="algo" id="ByteString-to-js">
~IDL `ByteString$T 値 %V を`~JS値に変換する$ときは
⇒
~RET 次を満たす `String^jt 値
⇒
［
長さ ~EQ %V の長さ
］~AND［
各 `要素$eSに対し，その値 ~EQ %V の対応する要素の値
］
◎
The result of converting an IDL ByteString value to a JavaScript value is a String value whose length is the length of the ByteString, and the value of each element of which is the value of the corresponding element of the ByteString.
</p>

			</section>
			<section id="js-USVString">
<h4>3.2.12. `USVString^T</h4>

<div class="algo">
<p id="js-to-USVString">
~JS値 %V を `USVString$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL USVString value by running the following algorithm:
</p>
<ol>
	<li>
%文字列 ~LET `~IDL値に変換する$( %V, `DOMString$T )
◎
Let string be the result of converting V to a DOMString.
</li>
	<li>
~RET
%文字列 を`~scalar値~文字列に変換-$した結果の~IDL `USVString$T 値
◎
Return an IDL USVString value that is the result of converting string to a sequence of scalar values.
</li>
</ol>
</div>

<div class="algo">
<p id="USVString-to-js">
~IDL `USVString$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V
◎
The result of converting an IDL USVString value S to a JavaScript value is S.
</p>
</div>

			</section>
			<section id="js-object">
<h4>3.2.13. `object^T</h4>

<p>
~IDL `object$T 値は、
~JS `Object^jt 値により表現される。
◎
IDL object values are represented by JavaScript Object values.
</p>

<div class="algo">
<p id="js-to-object">
~JS値 %V を `object$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL object value by running the following algorithm:
</p>
<ol>
	<li id="cp-type-not-object">
~IF［
%V は `Object$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If V is not an Object, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objを参照する~IDL `object$T 値
◎
Return the IDL object value that is a reference to the same object as V.
</li>
</ol>
</div>

<p class="algo" id="object-to-js">
~IDL `object$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~objへの参照を表現する `Object^jt 値
◎
The result of converting an IDL object value to a JavaScript value is the Object value that represents a reference to the same object that the IDL object represents.
</p>

			</section>
			<section id="js-symbol">
<h4>3.2.14. `symbol^T</h4>

<p>
~IDL `symbol$T 値は、
~JS `Symbol^jt 値により表現される。
◎
IDL symbol values are represented by JavaScript Symbol values.
</p>

<div class="algo">
<p id="js-to-symbol">
~JS値 %V を `symbol$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL symbol value by running the following algorithm:
</p>
<ol>
	<li>
~IF［
%V は `Symbol$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If V is not a Symbol, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~symbolを参照する~IDL `symbol$T 値
◎
Return the IDL symbol value that is a reference to the same symbol as V.
</li>
</ol>
</div>

<p class="algo" id="symbol-to-js">
~IDL `symbol$T 値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~symbolへの参照を表現する `Symbol^jt 値
◎
The result of converting an IDL symbol value to a JavaScript value is the Symbol value that represents a reference to the same symbol that the IDL symbol represents.
</p>

			</section>
			<section id="js-interface">
<h4 title="Interface types">3.2.15. ~ifc型</h4>

<p>
~IDL`~ifc型$の値は、
~JS `Object^jt 値（`関数~obj$も含む）により表現される。
◎
IDL interface type values are represented by JavaScript Object values (including function objects).
</p>

<div class="algo">
<p id="js-to-interface">
~JS値 %V を `~ifc型$ %I の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL interface type value by running the following algorithm (where I is the interface):
</p>
<ol>
	<li>
~IF［
%V は %I を`実装-$する
］
⇒
~RET その~platform~objへの参照を表現する，~IDL`~ifc型$の値
◎
If V implements I, then return the IDL interface type value that represents a reference to that platform object.
</li>
	<li id="cp-throw-typeerror">
`~THROW$ `TypeError$jt
◎
Throw a TypeError.
</li>
</ol>
</div>

<p class="algo" id="interface-to-js">
~IDL`~ifc型$の値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~objへの参照を表現する `Object^jt 値
◎
The result of converting an IDL interface type value to a JavaScript value is the Object value that represents a reference to the same object that the IDL interface type value represents.
</p>

			</section>
			<section id="js-callback-interface">
<h4 title="Callback interface types">3.2.16. ~callback~ifc型</h4>

<p>
~IDL`~callback~ifc型$の値は、
~JS `Object^jt 値（`関数~obj$も含む）により表現される。
◎
IDL callback interface type values are represented by JavaScript Object values (including function objects).
</p>

<div class="algo">
<p id="js-to-callback-interface">
~JS値 %V を `~callback~ifc型$の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL callback interface type value by running the following algorithm:
</p>
<ol>
	<!--cp-type-not-object-->
	<li>
~RET %V への参照を表現し, `~callback文脈$として`現任な設定群~obj$を伴う，~IDL`~callback~ifc型$の値
◎
Return the IDL callback interface type value that represents a reference to V, with the incumbent settings object as the callback context.
</li>
</ol>
</div>

<p class="algo" id="callback-interface-to-js">
~IDL`~callback~ifc型$の値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~objへの参照を表現する `Object^jt 値
◎
The result of converting an IDL callback interface type value to a JavaScript value is the Object value that represents a reference to the same object that the IDL callback interface type value represents.
</p>

			</section>
			<section id="js-dictionary">
<h4 title="Dictionary types">3.2.17. 辞書~型</h4>

<p>
~IDL`辞書~型$の値は、
~JS `Object^jt 値により表現される。
その~obj（またはその原型鎖）の~propが`辞書~mb$に対応する。
◎
IDL dictionary type values are represented by JavaScript Object values. Properties on the object (or its prototype chain) correspond to dictionary members.
</p>

<div class="algo">
<p id="js-to-dictionary">
~JS値 %~js辞書 を`辞書~型$ %D の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value jsDict is converted to an IDL dictionary type value by running the following algorithm (where D is the dictionary type):
</p>
<ol>
	<li>
~IF［
%~js辞書 は `Object$jt でない
］~AND［
%~js辞書 ~NIN { `undefined^jv, `null^jv }
］
⇒
`~THROW$ `TypeError$jt
◎
If jsDict is not an Object and jsDict is neither undefined nor null, then throw a TypeError.
</li>
	<li>
%~idl辞書 ~LET 型 %D の辞書を表現している新たな`有順序~map$
◎
Let idlDict be an empty ordered map, representing a dictionary of type D.
</li>
	<li>
<p id="cp-for-each-inherited-dictionaries">
［
%D, %D が`継承した辞書~群$
］を成す
~EACH( %辞書 )
に対し，先祖から継承-順に：
◎
Let dictionaries be a list consisting of D and all of D’s inherited dictionaries, in order from least to most derived.
◎
For each dictionary dictionary in dictionaries, in order:
</p>
		<ol>
			<li>
<p id="cp-foreach-mb">
%辞書 上に宣言された
~EACH( 辞書~mb %~mb )
に対し，~mbの`識別子$の辞書式~順序で：
◎
For each dictionary member member declared on dictionary, in lexicographical order:
</p>
				<ol>
					<li>
%~key ~LET %~mb の`識別子$
◎
Let key be the identifier of member.
</li>
					<li>
%~js~mb値 ~LET `undefined^jv
◎
↓</li>
					<li>
~IF［
%~js辞書 は `Object$jt である
］
⇒
%~js~mb値 ~SET
~ABRUPT `Get$A( %~js辞書, %~key )
◎
If jsDict is either undefined or null, then:
• Let jsMemberValue be undefined.
◎
Otherwise,
• Let jsMemberValue be ? Get(jsDict, key).
</li>
					<li>
~IF［
%~js~mb値 ~NEQ `undefined^jv
］
⇒
%~idl辞書[ %~key ] ~SET `~IDL値に変換する$( %~js~mb値, %~mb に宣言された型 )
◎
If jsMemberValue is not undefined, then:
• Let idlMemberValue be the result of converting jsMemberValue to an IDL value whose type is the type member is declared to be of.
• Set idlDict[key] to idlMemberValue.
</li>
					<li>
~ELIF［
%~mb には`既定~値$diC %d が指定されている
］
⇒
%~idl辞書[ %~key ] ~SET %d
◎
Otherwise, if jsMemberValue is undefined but member has a default value, then:
• Let idlMemberValue be member’s default value.
• Set idlDict[key] to idlMemberValue.
</li>
					<li>
~ELIF［
%~mb は`要求され$diCる
］
⇒
`~THROW$ `TypeError$jt
◎
Otherwise, if jsMemberValue is undefined and member is required, then throw a TypeError.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~idl辞書
◎
Return idlDict.
</li>
</ol>
</div>

<p class="note">注記：
~JS~obj上で`辞書~mb$を検索する順序は、
~objの~prop列挙~順序と同じになるとは限らない。
◎
Note: The order that dictionary members are looked up on the JavaScript object are not necessarily the same as the object’s property enumeration order.
</p>

<div class="algo">
<p id="dictionary-to-js">
~IDL辞書 %D 型の値 %V を `Object^jt 型の`~JS値に変換する$ための~algoは：
◎
An IDL dictionary value V is converted to a JavaScript Object value by running the following algorithm (where D is the dictionary):
</p>
<ol>
	<li>
%O ~LET
`OrdinaryObjectCreate$A( `Object.prototype$jI )
◎
Let O be OrdinaryObjectCreate(%Object.prototype%).
</li>
	<li>
<!--cp-for-each-inherited-dictionaries-->
		<ol>
			<li>
<!--cp-foreach-mb-->
				<ol>
					<li>
%~key ~LET %~mb の`識別子$
◎
Let key be the identifier of member.
</li>
					<li>
%~idl値 ~LET %V[ %~key ]
◎
↓</li>
					<li>
~IF［
%~idl値 ~EQ ε
］
⇒
~CONTINUE
◎
If V[key] exists, then:
◎
Let idlValue be V[key].
</li>
					<li id="cp-idlValue-toES">
%~js値 ~LET `~JS値に変換する$( %~idl値 )
◎
Let value be the result of converting idlValue to a JavaScript value.
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %O, %~key, %~js値 )
◎
Perform ! CreateDataPropertyOrThrow(O, key, value).
</li>
				</ol>

<p class="note">注記：
%~mb に`既定~値$diCが指定されている場合、
常に %V[ %~key ] ~NEQ ε になる。
◎
Recall that if member has a default value, then key will always exist in V.
</p>
			</li>
		</ol>
	</li>
	<li>
~RET %O
◎
Return O.
</li>
</ol>
</div>

			</section>
			<section id="js-enumeration">
<h4 title="Enumeration types">3.2.18. 列挙~型</h4>

<p>
~IDL`列挙~型$の値は、
~JS `String^jt 値により表現される。
◎
IDL enumeration types are represented by JavaScript String values.
</p>

<div class="algo">
<p id="js-to-enumeration">
~JS値 %V を`列挙$型 %E の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL enumeration type value as follows (where E is the enumeration):
</p>
<ol>
	<li>
%S ~LET
~ABRUPT `ToString$A( %V )
◎
Let S be the result of calling ? ToString(V).
</li>
	<li>
~IF［
%S は %E の`列挙~値$のいずれでもない
］
⇒
`~THROW$ `TypeError$jt
◎
If S is not one of E’s enumeration values, then throw a TypeError.
</li>
	<li>
~RET 型 %E の， %S に等しい列挙~値
◎
Return the enumeration value of type E that is equal to S.
</li>
</ol>
</div>

<p class="algo" id="enumeration-to-js">
~IDL`列挙$型の値 %V を`~JS値に変換する$ときは
⇒
~RET %V と同じ`符号単位$並びを表現する `String^jt 値
◎
The result of converting an IDL enumeration type value to a JavaScript value is the String value that represents the same sequence of code units as the enumeration value.
</p>

			</section>
			<section id="js-callback-function">
<h4 title="Callback function types">3.2.19. ~callback関数~型</h4>

<p>
~IDL`~callback関数~型$の値は、
~JS`関数~obj$により表現される。
ただし， `LegacyTreatNonObjectAsNull$x の場合は、
どの~objもとり得る。
◎
IDL callback function types are represented by JavaScript function objects, except in the [LegacyTreatNonObjectAsNull] case, when they can be any object.
</p>

<div class="algo">
<p id="js-to-callback-function">
~JS値 %V を`~callback関数~型$の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL callback function type value by running the following algorithm:
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
`IsCallable$A( %V ) ~EQ ~T
</li>
			<li>
この~algoは、
次を満たす`属性$へ代入することに因り遂行されている
⇒
［
`~nullable$な`~callback関数$型である
］~AND［
`LegacyTreatNonObjectAsNull$x が注釈されている
］
</li>
		</ul>
<p>
…ならば
⇒
~RET
%V が表現するものと同じ~objを表現し,
`~callback文脈$として`現任な設定群~obj$を伴う，~IDL`~callback関数~型$の値
</p>
◎
If the result of calling IsCallable(V) is false and the conversion to an IDL value is not being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [LegacyTreatNonObjectAsNull], then throw a TypeError.
◎
Return the IDL callback function type value that represents a reference to the same object that V represents, with the incumbent settings object as the callback context.
</li>
	<li>
`~THROW$ `TypeError$jt
◎
↑</li>
</ol>
</div>

<p class="algo" id="callback-function-to-js">
~IDL`~callback関数~型$の値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~objへの参照
◎
The result of converting an IDL callback function type value to a JavaScript value is a reference to the same object that the IDL callback function type value represents.
</p>

			</section>
			<section id="js-nullable-type">
<h4 title="Nullable types — T?">3.2.20. ~nullable型 — `~varT?^T</h4>

<p>
~IDL`~nullable型$の値は、
その`内縁~型$に対応する~JS型の値か, または
~JS `null^jv 値により表現される。
◎
IDL nullable type values are represented by values of either the JavaScript type corresponding to the inner IDL type, or the JavaScript null value.
</p>

<p>
この節を通して、
`~varT?^T は，`内縁~型$が %T である~IDL`~nullable型$を表す。
</p>

<div class="algo">
<p id="js-to-nullable">
~JS値 %V を型 `~varT?^T の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL nullable type T? value (where T is the inner type) as follows:
</p>
<ol>
	<li>
<p>
~IF［
~AND↓
］…
</p>
		<ul>
			<li>
%V は `Object$jt でない
</li>
			<li>
この~algoは、
次を満たす`属性$へ代入することに因り遂行されている
⇒
［
`~nullable$な`~callback関数$型である【！missing id="dfn-nullable"】
］~AND［
`LegacyTreatNonObjectAsNull$x が注釈されている
］
</li>
		</ul>
<p>
…ならば
⇒
~RET 型 `~varT?^T の値 `null^V
</p>
◎
If V is not an Object, and the conversion to an IDL value is being performed due to V being assigned to an attribute whose type is a nullable callback function that is annotated with [LegacyTreatNonObjectAsNull], then return the IDL nullable type T? value null.
</li>
	<li>
~IF［
%V ~EQ `undefined^jv
］~AND［
%T は`~undefinedを内包する$
］
⇒
~RET 一意な `undefined$T 値
◎
Otherwise, if V is undefined, and T includes undefined, return the unique undefined value.
</li>
	<li>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］
⇒
~RET 型 `~varT?^T の値 `null^V
◎
Otherwise, if V is null or undefined, then return the IDL nullable type T? value null.
</li>
	<li>
~RET `~IDL値に変換する$( %V, %T )
◎
Otherwise, return the result of converting V using the rules for the inner IDL type T.
</li>
</ol>
</div>

<p class="algo" id="nullable-to-js">
型 `~varT?^T の~IDL値 %V を`~JS値に変換する$ときは
⇒
~RET %V に応じて
⇒＃
`null^V ならば `null^jv ／
~ELSE_（ %V の型は %T である） `~JS値に変換する$( %V )
◎
The result of converting an IDL nullable type value to a JavaScript value is:
• If the IDL nullable type T? value is null, then the JavaScript value is null.
• Otherwise, the JavaScript value is the result of converting the IDL nullable type value to the inner IDL type T.
</p>

			</section>
			<section id="js-sequence">
<h4 title="Sequences — sequence&lt;T&gt;">3.2.21. 連列 — ~sequence_T</h4>

<p>
~IDL `~sequence_T$ 値は、
~JS `Array^jt 値により表現される。
◎
IDL sequence&lt;T&gt; values are represented by JavaScript Array values.
</p>

<div class="algo">
<p id="js-to-sequence">
~JS値 %V を`~sequence_T$ 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL sequence&lt;T&gt; value as follows:
</p>
<ol>
	<li>
~IF［
%V は `Object$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If V is not an Object, throw a TypeError.
</li>
	<li id="cp-checkiter-V">
%~method ~LET
~ABRUPT `GetMethod$A( %V, `Symbol.iterator$jI )
◎
Let method be ? GetMethod(V, %Symbol.iterator%).
</li>
	<li>
~IF［
%~method ~EQ `undefined^jv
］
⇒
`~THROW$ `TypeError$jt
◎
If method is undefined, throw a TypeError.
</li>
	<li>
~RET `可反復から連列を作成する$( %T, %V, %~method )
◎
Return the result of creating a sequence from V and method.
</li>
</ol>
</div>

<div class="algo">
<p id="sequence-to-js">
`~sequence_T$ 型の~IDL連列~値 %S を
`Array^jt 型の`~JS値に変換する$ための~algoは：
◎
An IDL sequence value S of type sequence&lt;T&gt; is converted to a JavaScript Array object as follows:
</p>
<ol>
	<li>
%n ~LET %S の長さ
◎
Let n be the length of S.
</li>
	<li>
%A ~LET 式 `[]^c で作成されるものと同じ，新たな `Array^jt ~obj
◎
Let A be a new Array object created as if by the expression [].
</li>
	<li>
<p>
~EACH( %i ~IN { 0 〜 %n ~MINUS 1 } )
に対し：
◎
Initialize i to be 0.
◎
While i &lt; n:
</p>
		<ol>
			<li>
%E ~LET `~JS値に変換する$( %S [ %i ] )
◎
Let V be the value in S at index i.
◎
Let E be the result of converting V to a JavaScript value.
</li>
			<li>
%P ~LET
~NOABRUPT `ToString$A( %i )
◎
Let P be the result of calling ! ToString(i).
</li>
			<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %A, %P, %E )
◎
Perform ! CreateDataPropertyOrThrow(A, P, E).
◎
↑↑Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
~RET %A
◎
Return A.
</li>
</ol>
</div>

				<section id="create-sequence-from-iterable">
<h5 title="Creating a sequence from an iterable">3.2.21.1. 可反復から連列を作成する</h5>

<div class="algo">
<p>
可反復から型 `~sequence_T$ の~IDL値を作成する
~algoは、
所与の
( 型 %T, 可反復 %可反復, 反復子~取得子 %~method )
に対し：
◎
To create an IDL value of type sequence&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>
<ol>
	<li>
%反復子~record ~LET
~ABRUPT `GetIteratorFromMethod$A( %可反復, `sync^i, %~method )
◎
Let iteratorRecord be ? GetIteratorFromMethod(iterable, method).
</li>
	<li>
%結果 ~LET 新たな`~list$
◎
Initialize i to be 0.
</li>
	<li>
<p>
~WHILE 無条件：
◎
Repeat
</p>
		<ol>
			<li>
%next ~LET
~ABRUPT `IteratorStepValue$A( %反復子~record )
◎
Let next be ? IteratorStepValue(iteratorRecord).
</li>
			<li>
~IF［
%next ~EQ `done^i
］
⇒
~RET ~IDL `~sequence_T$ 型~値としての %結果
◎
If next is done, then return an IDL sequence value of type sequence&lt;T&gt; of length i, where the value of the element at index j is Sj.
</li>
			<li>
%結果 に次の結果を`付加する$
⇒
`~IDL値に変換する$( %next, %T )
◎
Initialize Si to the result of converting next to an IDL value of type T.
◎
Set i to i + 1.
</li>
		</ol>
	</li>
</ol>
</div>

				</section>

<div class="example">
<p>
次の`~ifc$は
連列~型の引数を伴う`演算$と伴に
連列~型の`属性$を定義する。
◎
The following interface defines an attribute of a sequence type as well as an operation with an argument of a sequence type.
</p>

<pre class="webidl">
[Exposed=Window]
interface Canvas {

  sequence&lt;DOMString&gt; getSupportedImageCodecs();

  undefined drawPolygon(sequence&lt;double&gt; %coordinates);
  sequence&lt;double&gt; getLastDrawnPolygon();

  /* ... */
};
</pre>

<p>
この~ifcの~JS実装においては、
各~型［
`String^jt ／ `Number^jt
］に対し，その型の要素からなる `Array^jt ~objが［
`sequence&lt;DOMString&gt;^T ／
`sequence&lt;double&gt;^T
］を表現するために利用される。
この `Array^jt ~objは、
実質的には値により渡される
— `getSupportedImageCodecs()^M 関数は，
~callされる度に新たな `Array^jt を返すことになり、
`drawPolygon()^M に渡された `Array^jt への参照は，
~callを完了した後は保たれないことになる。
◎
In a JavaScript implementation of this interface, an Array object with elements of type String is used to represent a sequence&lt;DOMString&gt;, while an Array with elements of type Number represents a sequence&lt;double&gt;. The Array objects are effectively passed by value; every time the getSupportedImageCodecs() function is called a new Array is returned, and whenever an Array is passed to drawPolygon no reference will be kept after the call completes.
</p>

<pre class="lang-js">
/* <span class="comment">
`Canvas^T の~instanceを得する。
その `getSupportedImageCodecs()^M は、
2 個の `DOMString^T 値
`image/png^l, `image/svg+xml^l
からなる連列を返すとする。
◎
Obtain an instance of Canvas. Assume that getSupportedImageCodecs() returns a sequence with two DOMString values: "image/png" and "image/svg+xml".
</span> */
var %canvas = getCanvas();

/* <span class="comment">
長さ 2 の `Array^jt ~obj：
◎
An Array object of length 2.
</span> */
var %supportedImageCodecs = %canvas.getSupportedImageCodecs();

/* <span class="comment" id="cp-eval-img-png">
`image/png^l に評価される：
◎
Evaluates to "image/png".
</span> */
%supportedImageCodecs[0];

/* <span class="comment">
%canvas`.getSupportedImageCodecs()^c が~callされる度に，新たな `Array^jt object が返される。
したがって，返された `Array^jt を改変しても，後続な関数~callで返される値には影響しないことになる：
◎
Each time canvas.getSupportedImageCodecs() is called, it returns a new Array object.  Thus modifying the returned Array will not affect the value returned from a subsequent call to the function.
</span> */
%supportedImageCodecs[0] = `image/jpeg^l;

/* <!--cp-eval-img-png--> */
%canvas.getSupportedImageCodecs()[0];

/* <span class="comment">
各~callに対し，新たな `Array^jt ~objが返されるので、
これは `false^jv に評価される：
◎
This evaluates to false, since a new Array object is returned each call.
</span> */
%canvas.getSupportedImageCodecs() == %canvas.getSupportedImageCodecs();

/* <span class="comment">
数量-値の `Array^jt は...
◎
An Array of Numbers...
</span> */
var %a = [0, 0, 100, 0, 50, 62.5];

/* <span class="comment">
...は、
`sequence&lt;double&gt;^T を期待する~platform~objに渡せる：
◎
...can be passed to a platform object expecting a sequence&lt;double&gt;.
</span> */
%canvas.drawPolygon(%a);

/* <span class="comment">
各~要素は、
最初に `ToNumber$A() を~callすることにより，
`double^T に変換される。
したがって，次の~callは、
`drawPolygon()^M が返る前に `hi^l が alert されることを除き，
前のものと等価になる：
◎
Each element will be converted to a double by first calling ToNumber(). So the following call is equivalent to the previous one, except that "hi" will be alerted before drawPolygon() returns.
</span> */
%a = [
    false,
    "",
    { valueOf: function() { alert("hi"); return 100; } },
    0,
    "50",
    new Number(62.5)
];
%canvas.drawPolygon(%a);

/* <span class="comment">
`Array^jt は実質的には値により渡されるので、
`drawPolygon()^M に渡された `Array^jt を改変しても，
`Canvas^T に効果が及ぶことはないことが保証される：
◎
Modifying an Array that was passed to drawPolygon() is guaranteed not to have an effect on the Canvas, since the Array is effectively passed by value.
</span> */
%a[4] = 20;
var %b = %canvas.getLastDrawnPolygon();

alert(%b[4]);    /* <span class="comment">
これは `50^l を alert することになる。
◎
This would alert "50".
</span> */
</pre>
</div>

			</section>
			<section id="js-async-iterable">
<h4 title="Async sequences — async_sequence&lt;T&gt;">3.2.22. 非同期c連列 — ~async_sequence_T</h4>

<p>
~JS束縛においては、
非同期c連列
（~IDL`非同期c連列~型$の値）は，
次に挙げる`~item$sctを伴う`構造体$により表現される：
◎
In the JavaScript binding, IDL async sequence values are represented by a struct with the following items:
</p>
<ul>
	<li>
`~obj@aS
⇒
ある~JS値
◎
object, a JavaScript value
</li>
	<li>
`~method@aS
⇒
ある~JS値
◎
method, a JavaScript value
</li>
	<li>
`種別@aS
⇒
`同期c^C ／ `非同期c^C
◎
type, either "sync" or "async"
</li>
</ul>

<div class="algo">
<p>
~JS値 %V を `~async_sequence_T$ 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL async_sequence&lt;T&gt; value as follows:
</p>
<ol>
	<!--cp-type-not-object-->
	<li>
%~method ~LET
~ABRUPT `GetMethod$A( %V【！obj】, `Symbol.asyncIterator$jI )
◎
Let method be ? GetMethod(obj, %Symbol.asyncIterator%).
</li>
	<li>
<p>
~IF［
%~method ~EQ `undefined^jv
］：
◎
If method is undefined:
</p>
		<ol>
			<li>
%同期c~method ~SET 
~ABRUPT `GetMethod$A( %V【！obj】, `Symbol.iterator$jI )
◎
Set syncMethod to ? GetMethod(obj, %Symbol.iterator%).
</li>
			<li>
~IF［
%同期c~method ~EQ `undefined^jv
］
⇒
`~THROW$ `TypeError$jt
◎
If syncMethod is undefined, throw a TypeError.
</li>
			<li>
~RET 新たな`非同期c連列$
— その
⇒＃
`~obj$aS ~SET %V,
`~method$aS ~SET %同期c~method,
`種別$aS ~SET `同期c^C
◎
Return an IDL async sequence value with object set to V, method set to syncMethod, and type set to "sync".
</li>
		</ol>
	</li>
	<li>
~RET 新たな`非同期c連列$
— その
⇒＃
`~obj$aS ~SET %V,
`~method$aS ~SET %~method,
`種別$aS ~SET `非同期c^C
◎
Return an IDL async sequence value with object set to V, method set to method, and type set to "async".
</li>
</ol>
</div>

<div class="algo">
<p id="async-sequence-to-js">
~IDL `~async_sequence_T$ 型の値 %V を `Object^jt 型の`~JS値に変換する$ための~algoは：
◎
An IDL async_sequence&lt;T&gt; value V is converted to a JavaScript object as follows:
</p>
<ol>
	<li>
~RET %V の`~obj$aS
◎
Return V’s object.
</li>
</ol>
</div>

				<section id="js-async-sequence-iteration">
<h5 title="Iterating async sequences">3.2.22.1. 非同期c連列の反復-法</h5>

<p>
`非同期c連列$は、
直には反復されない。
代わりに、
まず`非同期c反復子$を作成するよう~openされる。
`非同期c反復子$は、
値たちを生産するために非同期に反復され得る。
◎
An async sequence is not directly iterated over. Instead, it is first opened to create an async iterator. The async iterator can be asynchronously iterated over to produce values.
</p>

<p>
`非同期c反復子@
は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
Async iterators are structs with the following items:
</p>
<ul>
	<li>
`下層の~record@aI1
⇒
ある~JS`反復子~Record＠~TC39#sec-iterator-records$
◎
underlying record, an Iterator Record
</li>
	<li>
`型~parameter@aI1
⇒
ある~IDL型
— 当の非同期c反復子により生産される値たちの型を表現する。
◎
type parameter, an IDL type representing the type of values produced by the async iterator
</li>
</ul>

<div class="algo">
<p>
`非同期c連列を~openする@
~algoは、
所与の
( `~async_sequence_T$ %連列 )
に対し：
◎
To open an async_sequence&lt;T&gt; sequence:
</p>
<ol>
	<li>
%反復子 ~LET
~ABRUPT `GetIteratorFromMethod$A( %連列 の`~obj$aS, %連列 の`~method$aS )
◎
Let iterator be ? GetIteratorFromMethod(sequence’s object, sequence’s method).
</li>
	<li>
~IF［
%連列 の`種別$aS ~EQ `同期c^C
］
⇒
%反復子 ~SET `CreateAsyncFromSyncIterator$A( %反復子 )
◎
If sequence’s type is "sync", set iterator to CreateAsyncFromSyncIterator(iterator).
</li>
	<li>
~RET 新たな`非同期c反復子$
— その
⇒＃
`下層の~record$aI1 ~SET %反復子,
`型~parameter$aI1 ~SET %T
◎
Return an async iterator value with underlying record set to iterator and type parameter set to T.
</li>
</ol>
</div>

<div class="algo">
<p>
`次回の値を取得する@
~algoは、
所与の
( `非同期c反復子$ %反復子 )
に対し：
◎
To get the next value of an async iterator iterator:
</p>
<ol>
	<li>
%次回の結果 ~LET
`IteratorNext$A( %反復子 の`下層の~record$aI1 )
◎
Let nextResult be IteratorNext(iterator’s underlying record).
</li>
	<li>
~IF［
%次回の結果 は`中途完了$である
］
⇒
~RET `却下される~promise$( %次回の結果.`Value^sl )
◎
If nextResult is an abrupt completion, return a promise rejected with nextResult.[[Value]].
</li>
	<li>
%次回の~promise ~LET `解決される~promise$( %次回の結果.`Value^sl )
◎
Let nextPromise be a promise resolved with nextResult.[[Value]].
</li>
	<li>
<p>
~RET `~promiseに反応する$( %次回の~promise )
— 次を与える下で：
◎
Return the result of reacting to nextPromise with＼
</p>
		<ul>
			<li class="algo">
<p>
`充足~手続き^i は、
所与の ( 値 %反復-結果 ) に対し：
◎
the following fulfillment steps, given iterResult:
</p>
				<ol>
					<li>
~IF［
%反復-結果 は `Object$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If iterResult is not an Object, throw a TypeError.
</li>
					<li>
%済んだか ~LET
~ABRUPT `IteratorComplete$A( %反復-結果 )
◎
Let done be ? IteratorComplete(iterResult).
</li>
					<li>
~IF［
%済んだか ~EQ `true^jv
］
⇒
~RET `反復~終了$C
◎
If done is true:
• Return end of iteration.
</li>
					<li>
%V ~LET
~ABRUPT `IteratorValue$A( %反復-結果 )
◎
Otherwise:
• Let V be ? IteratorValue(iterResult).
</li>
					<li>
~RET `~IDL値に変換する$( %V, %反復子 の`型~parameter$aI1 )
◎
• Let value be the result of converting V to an IDL value of type iterator’s type parameter.
• Return value.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="algo">
<p>
`非同期c反復子を~closeする@
~algoは、
所与の
( `非同期c反復子$【！async iterator&lt;T&gt;】 %反復子, ~JS【！ECMAScript】値 %事由 )
に対し：
◎
To close an async iterator&lt;T&gt; iterator, with an ECMAScript value reason:
</p>
<ol>
	<li>
%反復子~record ~LET %反復子 の`下層の~record$aI1
◎
Let iteratorRecord be iterator’s underlying record.
</li>
	<li>
%反復子~obj ~LET %反復子~record.`Iterator^sl
◎
Let iteratorObj be iteratorRecord.[[Iterator]].
</li>
	<li>
%~return~method ~LET
`GetMethod$A( %反復子~obj, `return^l )
◎
Let returnMethod be GetMethod(iteratorObj, "return").
</li>
	<li>
~IF［
%~return~method は`中途完了$である
］
⇒
~RET `却下される~promise$

%~return~method.`Value^sl
◎
If returnMethod is an abrupt completion, return a promise rejected with returnMethod.[[Value]].
</li>
	<li>
~IF［
%~return~method ~EQ `undefined^jv
］
⇒
~RET `解決される~promise$( `undefined$T )
◎
If returnMethod is undefined, return a promise resolved with undefined.
</li>
	<li>
%~return結果 ~LET
`Call$A( %~return~method.`Value^sl, %反復子~obj, « %事由 » )
◎
Let returnResult be Call(returnMethod.[[Value]], iteratorObj, « reason »).
</li>
	<li>
~IF［
%~return結果 は`中途完了$である
］
⇒
~RET `却下される~promise$

%~return結果.`Value^sl
◎
If returnResult is an abrupt completion, return a promise rejected with returnResult.[[Value]].
</li>
	<li>
%~return~promise ~LET `解決される~promise$( %~return結果.`Value^sl )
◎
Let returnPromise be a promise resolved with returnResult.[[Value]].
</li>
	<li>
<p>
~RET `~promiseに反応する$( %~return~promise )
— 次を与える下で：
◎
Return the result of reacting to returnPromise with＼
</p>
		<ul>
			<li class="algo">
<p>
`充足~手続き^i は、
所与の ( 値 %~return~promise結果 ) に対し：
◎
the following fulfillment steps, given returnPromiseResult:
</p>
				<ol>
					<li>
~IF［
%~return~promise結果 は `Object$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If returnPromiseResult is not an Object, throw a TypeError.
</li>
					<li>
~RET `undefined$T
◎
Return undefined.
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>
</div>

<div class="example">
<p>
`concatN^c は、
~promiseを返す`演算$であり，［
渡された非同期c連列により得られたすべての文字列を連結した結果
］で充足されることになる。
%maxN 個の文字列が得られたなら、
連結するのを停止して，~openした反復子を~closeする。
◎
concatN is an operation that returns a promise that will be fulfilled with the concatenation of all the strings yielded by the async sequence passed to it. It stops concatenating and closes the iterator once the async sequence has yielded maxN strings.
</p>

<pre class="idl">
interface I {
  Promise&lt;DOMString&gt; concatN(async_sequence&lt;DOMString&gt; %strings, unsigned long %maxN);
};
</pre>

<div class="algo">
<p>
<code>concatN(%sequence, %maxN)</code>
~method手続きは：
◎
The concatN(sequence, maxN) method steps are:
</p>
<ol>
	<li>
%~promise ~LET `新たな~promise$()
◎
Let promise be a new promise.
</li>
	<li>
%結果 ~LET 空~文字列
◎
Let result be the empty string.
</li>
	<li>
%n ~LET 0
◎
Let n be 0.
</li>
	<li>
%反復子 ~LET `非同期c連列を~openする$( %sequence )
◎
Let iterator be the result of opening sequence.
</li>
	<li class="algo">
<p>
%手続き ~LET 次を遂行する手続き
（非同期c連列を処理するために利用される）：
◎
Let step be a sequence of steps that will be used to process the async sequence:
</p>
		<ol>
			<li>
%次回の ~LET `次回の値を取得する$( %反復子 )
◎
Let next be the result of getting the next value of iterator.
</li>
			<li>
<p>
`~promiseに反応する$( %次回の )
— 次を与える下で：
◎
React to next:
</p>
				<ul>
					<li class="algo">
<p>
`充足~手続き^i は、
所与の ( 値 %v ) に対し：
◎
If next was fulfilled with value v:
</p>
						<ol>
							<li>
~IF［
%v ~EQ `反復~終了$C
］
⇒
`~promiseを解決する$( %~promise, %結果 )
◎
If v is end of iteration, resolve promise with result.
</li>
							<li>
%結果 ~SET 次を順に連結した結果
⇒
%結果, %v
◎
Set result to the result of concatenating result and v.
</li>
							<li>
%n ~INCBY 1
◎
Set n to n + 1.
</li>
							<li>
<p>
~IF［
%n ~EQ %maxN
］：
◎
If n is maxN, then:
</p>
								<ol>
									<li>
%完遂- ~LET `非同期c反復子を~closeする$( %反復子, `undefined$T )
◎
Let finish be the result of closing iterator with reason undefined.
</li>
									<li>
<p>
`~promiseに反応する$( %完遂- )
— 次を与える下で：
◎
React to finish:
</p>
										<ul>
											<li class="algo">
`充足~手続き^i は、
所与の ( 値 %結果 ) に対し
⇒
`~promiseを解決する$( %~promise, %結果 )
◎
If finish was fulfilled, resolve promise with result.
</li>
											<li class="algo">
`却下~手続き^i は、
所与の ( 事由 %r ) に対し
⇒
`~promiseを却下する$( %~promise, %r )
◎
If finish was rejected with reason r, reject promise with r.
</li>
										</ul>
									</li>
								</ol>
							</li>
							<li>
~ELSE
⇒
%手続き()
◎
Otherwise:
• Call step.
</li>
						</ol>
					</li>
					<li class="algo">
`却下~手続き^i は、
所与の ( 事由 %r ) に対し
⇒
`~promiseを却下する$( %~promise, %r )
◎
If next was rejected with reason r, reject promise with r.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
%手続き()
◎
Call step.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>
</div>

				</section>
			</section>
			<section id="js-record">
<h4 title="Records — record&lt;K, V&gt;">3.2.23. ~record — ~record_KV</h4>

<p>
~IDL `record$T 値は、
~JS `Object^jt 値により表現される。
◎
IDL record&lt;K, V&gt; values are represented by JavaScript Object values.
</p>

<div class="algo">
<p id="js-to-record">
~JS値 %O を `~record_KV$ 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value O is converted to an IDL record&lt;K, V&gt; value as follows:
</p>
<ol>
	<li>
~IF［
%O は `Object$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If O is not an Object, throw a TypeError.
</li>
	<li>
%結果 ~LET 新たな空な`~record_KV$ 値
◎
Let result be a new empty instance of record&lt;K, V&gt;.
</li>
	<li>
%~key群 ~LET
~ABRUPT %O.`OwnPropertyKeys^sl()
◎
Let keys be ? O.[[OwnPropertyKeys]]().
</li>
	<li>
<p>
%~key群 を成す
~EACH( %~key )
に対し：
◎
For each key of keys:
</p>
		<ol>
			<li>
%記述子 ~LET
~ABRUPT %O.`GetOwnProperty^sl( %~key )
◎
Let desc be ? O.[[GetOwnProperty]](key).
</li>
			<li>
<p>
~IF［
%記述子 ~NEQ `undefined^jv
］~AND［
%記述子.`Enumerable^sl ~EQ `true^jv
］：
◎
If desc is not undefined and desc.[[Enumerable]] is true:
</p>
				<ol>
					<li>
%有型~key ~LET `~IDL値に変換する$( %~key, %K )
◎
Let typedKey be key converted to an IDL value of type K.
</li>
					<li>
%値 ~LET
~ABRUPT `Get$A( %O, %~key )
◎
Let value be ? Get(O, key).
</li>
					<li>
%有型~値 ~LET `~IDL値に変換する$( %値, %V )
◎
Let typedValue be value converted to an IDL value of type V.
</li>
					<li>
<p>
%結果[ %有型~key ] ~SET %有型~値
◎
Set result[typedKey] to typedValue.
</p>

<p class="note">注記：
%K が `USVString$T で %~key が対を成さない~surrogateを包含している場合、
%有型~key は，すでに %結果 内にあり得る。
◎
Note: It’s possible that typedKey is already in result, if K is USVString and key contains unpaired surrogates.
</p>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p id="record-to-js">
~IDL `record$T 値 %D を`~JS値に変換する$ための~algoは：
◎
An IDL record&lt;…&gt; value D is converted to a JavaScript value as follows:
</p>
<ol>
	<li>
%結果 ~LET
`OrdinaryObjectCreate$A( `Object.prototype$jI )
◎
Let result be OrdinaryObjectCreate(%Object.prototype%).
</li>
	<li>
<p>
%D を成す
~EACH( %~key → %値 )
に対し：
◎
For each key → value of D:
</p>
		<ol>
			<li>
%~js~key ~LET `~JS値に変換する$( %~key )
◎
Let jsKey be key converted to a JavaScript value.
</li>
			<li>
%~js値 ~LET `~JS値に変換する$( %値 )
◎
Let jsValue be value converted to a JavaScript value.
</li>
			<li>
%作成したか ~LET
~NOABRUPT `CreateDataProperty$A( %結果, %~js~key, %~js値 )
◎
Let created be ! CreateDataProperty(result, jsKey, jsValue).
</li>
			<li>
~Assert：
%作成したか ~EQ `true^jv
◎
Assert: created is true.
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="example">
<p>
`record&lt;DOMString, double&gt;^T 型の引数として~JS値 `{b: 3, a: 4}^jv を渡した結果は、
~IDL値 «[ `b^l → 3, `a^l → 4 ]» になる。
◎
Passing the JavaScript value {b: 3, a: 4} as a record&lt;DOMString, double&gt; argument would result in the IDL value «[ "b" → 3, "a" → 4 ]».
</p>

<p>
~recordが考慮するのは，自前の列挙-可能な~prop
—
`own＠~TC39#sec-own-property$
`enumerable＠~TC39#sec-property-attributes$
~prop —
に限られるので、
引数を返すだけの~IDL演算
⇒
<samp>`record&lt;DOMString, double&gt;^T identity(`record&lt;DOMString, double&gt;^T %arg)</samp>
◎終
が与えられたとき、
次の~codeは 各~表明（ `assert()^c ）に合格する：
◎
Records only consider own enumerable properties, so given an IDL operation record&lt;DOMString, double&gt; identity(record&lt;DOMString, double&gt; arg) which returns its argument, the following code passes its assertions:
</p>

<pre class="lang-js">
let %proto = {a: 3, b: 4};
let %obj = {__proto__: proto, d: 5, c: 6}
Object.defineProperty(%obj, "e", {value: 7, enumerable: false});
let %result = identity(%obj);
console.assert(%result.a === undefined);
console.assert(%result.b === undefined);
console.assert(%result.e === undefined);
let %entries = Object.entries(%result);
console.assert(%entries[0][0] === "d");
console.assert(%entries[0][1] === 5);
console.assert(%entries[1][0] === "c");
console.assert(%entries[1][1] === 6);
</pre>

<p>
~recordの［
~key, 値
］は、
他から拘束され得る
— ~keyは、
3 種の文字列~型に拘束されるに過ぎないが。
例えば：
◎
Record keys and values can be constrained, although keys can only be constrained among the three string types. The following conversions have the described results:
</p>

<table><thead>
<tr><th>
渡された値
◎
Value
<th>
値が渡された型
◎
Passed to type
<th>
結果
◎
Result
<tbody>

<tr><td>`{"😞": 1}^jv
<td>`record&lt;ByteString, double&gt;^T
<td>`TypeError$jE

<tr><td>`{"\uD83D": 1}^jv
<td>`record&lt;USVString, double&gt;^T
<td>«[ `\uFFFD^l → 1 ]»

<tr><td>`{"\uD83D": {hello: "world"}}^jv
<td>`record&lt;DOMString, double&gt;^T
<td>«[ `\uD83D^l → 0 ]»
</table>
</div>

			</section>
			<section id="js-promise">
<h4 title="Promise types — Promise&lt;T&gt;">3.2.24. ~promise型 — ~promise_T</h4>

<p>
~IDL`~promise型$の値は、
~JS `~PromiseCapability$~recordにより表現される。
◎
IDL promise type values are represented by JavaScript PromiseCapability records.
</p>

<div class="algo">
<p id="js-to-promise">
~JS値 %V を `~promise_T$ 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL Promise&lt;T&gt; value as follows:
</p>
<ol>
	<li>
%~promise能力 ~LET
~ABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let promiseCapability be ? NewPromiseCapability(%Promise%).
</li>
	<li>
~ABRUPT `Call$A( %~promise能力.`Resolve^sl, `undefined^jv , « %V » )
◎
Perform ? Call(promiseCapability.[[Resolve]], undefined, « V »).
</li>
	<li>
~RET %~promise能力
◎
Return promiseCapability.
</li>
</ol>
</div>

<p class="algo" id="promise-to-js">
~IDL`~promise型$の値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現する~recordの `Promise^sl ~fieldの値
◎
The result of converting an IDL promise type value to a JavaScript value is the value of the [[Promise]] field of the record that IDL promise type represents.
</p>

				<section id="js-promise-manipulation">
<h5 title="Creating and manipulating Promises">3.2.24.1. ~promiseの作成-法と操作-法</h5>

<div class="algo">
<p>
`新たな~promise@
（ `a new promise^en ）
を作成する~algoは、
所与の
( `~realm$ %~realm )
に対し，
`~promise_T$ 型の %~realm に属する値を返す：
◎
To create a new Promise&lt;T&gt; in a realm realm, perform the following steps:
</p>
<ol>
	<li>
%構築子 ~LET %~realm.`Promise$jIsl
◎
Let constructor be realm.[[Intrinsics]].[[%Promise%]].
</li>
	<li>
~RET
~ABRUPT `NewPromiseCapability$A( %構築子 )
◎
Return ? NewPromiseCapability(constructor).
</li>
</ol>
</div>

<p class="trans-note">【
ほとんどの事例では、
%~realm は省略して~callされる
（単に， “新たな~promise” と記される）。
それは、
%~realm が文脈から一義的に決定できることを意味する
（さもなければ指定-漏れである）。
例えば，演算や属性~用の手続きから~callされる所では、
通例的に `this$V に`関連な~realm$
（演算や属性が静的な場合は`現在の~realm$）
と解釈する他にない。
以下の~algoでも同様。
】【†
すなわち，
`~promise_T$ 型の値を期待する文脈（~promiseを返す~APIなど）から~callされた場合、
結果は， ~promise_T 型の値を表現するものと見なされる。
以下の~algoでも同様。
】</p>

<div class="algo">
<p>
`解決される~promise@
（ `resolved promise^en ）
を作成する~algoは、
所与の
( ~IDL値 %x, `~realm$ %~realm )
に対し：
◎
To create a resolved promise of type Promise&lt;T&gt;, with x (a value of type T) in a realm realm, perform the following steps:
</p>
<ol>
	<li>
%値 ~LET `~JS値に変換する$( %x )
◎
Let value be the result of converting x to a JavaScript value.
</li>
	<li>
%~promise能力 ~LET `新たな~promise$( %~realm )
◎
Let constructor be realm.[[Intrinsics]].[[%Promise%]].
◎
Let promiseCapability be ? NewPromiseCapability(constructor).
</li>
	<li>
~NOABRUPT `Call$A( %~promise能力.`Resolve^sl, `undefined^jv, « %値 » )
◎
Perform ! Call(promiseCapability.[[Resolve]], undefined, « value »).
</li>
	<li>
~RET %~promise能力
◎
Return promiseCapability.
</li>
</ol>

<p class="trans-note">【
これは、
“%x で解決される~promise”
の様な形の句でも参照される。
】【
%値 が~IDL値を期待する文脈で利用される所では、
暗黙的に~IDL値に変換されることになる
（例： ~promise_T を返す~APIにおいては、
%T 型の~IDL値に変換される）。
】</p>
</div>

<div class="algo">
<p>
`却下される~promise@
（ `rejected promise^en ）
を作成する~algoは、
所与の
( ~JS値 %事由, `~realm$ %~realm )
に対し：
◎
To create a rejected promise of type Promise&lt;T&gt;, with reason r (a JavaScript value) in a realm realm, perform the following steps:
</p>
<ol>
	<li>
%~promise能力 ~LET `新たな~promise$( %~realm )
◎
Let constructor be realm.[[Intrinsics]].[[%Promise%]].
◎
Let promiseCapability be ? NewPromiseCapability(constructor).
</li>
	<li>
~NOABRUPT `Call$A( %~promise能力.`Reject^sl, `undefined^jv, « %事由 » )
◎
Perform ! Call(promiseCapability.[[Reject]], undefined, « r »).
</li>
	<li>
~RET %~promise能力
◎
Return promiseCapability.
</li>
</ol>

<p class="trans-note">【
これは、
“%事由 で却下される~promise”
の様な形の句でも参照される。
】【
ほとんどの事例では、
%事由 として`例外$が渡される。
%事由 として `DOMException$T 値が渡された場合、
それは~IDL値なので，まず~JS値に変換してから上の手続きを適用することになる。
】</p>
</div>

<div class="algo">
<p>
`~promiseを解決する@
（ `resolve^en する）
~algoは、
所与の
( `~promise_T$ %p, 型 %T の値 %x ~DF `undefined$T 値 )
に対し：
◎
To resolve a Promise&lt;T&gt; p with x (a value of type T), perform the following steps:
• If x is not given, then let it be the undefined value.
</p>
<ol>
	<li>
%値 ~LET `~JS値に変換する$( %x )
◎
Let value be the result of converting x to a JavaScript value.
</li>
	<li>
~NOABRUPT `Call$A( %p.`Resolve^sl, `undefined^jv, « %値 » )
◎
Perform ! Call(p.[[Resolve]], undefined, « value »).
</li>
</ol>

<div>
<p class="trans-note">【
これは、
“ %x で %p を解決する”
の様な形の句で参照されることもある。
】【
引数 %x が省略された場合、
%T は`~undefinedを内包する$ことになる。
】</p>
◎
↑ If T is undefined, then the x argument is optional, allowing a simpler "resolve p" usage.
</div>
</div>

<div class="algo">
<p>
`~promiseを却下する@
（ `reject^en する）
~algoは、
所与の
( `~promise_T$ %p, ~JS値 %r )
に対し（ %r が事由を与える）：
◎
To reject a Promise&lt;T&gt; p with reason r (a JavaScript value), perform the following steps:
</p>
<ol>
	<li>
~NOABRUPT `Call$A( %p.`Reject^sl, `undefined^jv, « %r » )
◎
Perform ! Call(p.[[Reject]], undefined, « r »).
</li>
</ol>

<p class="trans-note">【
これは、
“ %x で %p を却下する”
の様な形の句で参照されることもある。
】</p>
</div>

<div class="algo">
<div>
<p>
`~promiseに反応する@
（ `react^en する）
~algoは、
所与の
( `~promise_T$ %~promise )
および所与の：
</p>
<ul>
	<li>
%充足~手続き ~DF ε
⇒
%~promise が充足されたときを受持つ手続き
</li>
	<li>
%却下~手続き ~DF ε
⇒
%~promise が却下されたときを受持つ手続き
</li>
</ul>
<p>
に対し：
</p>
◎
To react to a Promise&lt;T&gt; promise, given one or two sets of steps to perform, covering when the promise is fulfilled, rejected, or both, perform the following steps:
</div>
<ol>
	<li class="algo">
<p>
%充足-時の手続き ~LET 所与の ( %V ) に対し，次を走らす手続き：
◎
Let onFulfilledSteps be the following steps given argument V:
</p>
		<ol>
			<li>
%値 ~LET `~IDL値に変換する$( %V, %T )
◎
Let value be the result of converting V to an IDL value of type T.
</li>
			<li>
%結果 ~LET %値
◎
↓</li>
			<li>
~IF［
%充足~手続き ~NEQ ε
］
⇒
%結果 ~SET %T に応じて
⇒＃
`undefined$T ならば %充足~手続き() ／
~ELSE_ %充足~手続き( %値 )
◎
If there is a set of steps to be run if the promise was fulfilled, then let result be the result of performing them, given value if T is not undefined. Otherwise, let result be value.
</li>
			<li>
~RET `~JS値に変換する$( %結果 )
◎
Return result, converted to a JavaScript value.
</li>
		</ol>
	</li>
	<li>
%充足-時の関数 ~LET
`CreateBuiltinFunction$A( %充足-時の手続き, « » )
◎
Let onFulfilled be CreateBuiltinFunction(onFulfilledSteps, « »):
</li>
	<li class="algo">
<p>
%却下-時の手続き ~LET 所与の ( %R ) に対し，次を走らす手続き：
◎
Let onRejectedSteps be the following steps given argument R:
</p>
		<ol>
			<li>
%事由 ~LET `~IDL値に変換する$( %R, `any$T )
◎
Let reason be the result of converting R to an IDL value of type any.
</li>
			<li>
%結果 ~LET %却下~手続き に応じて
⇒＃
ε ならば `却下される~promise$( %事由 ) ／
~ELSE_ %却下~手続き( %事由 )
◎
If there is a set of steps to be run if the promise was rejected, then let result be the result of performing them, given reason. Otherwise, let result be a promise rejected with reason.
</li>
			<li>
~RET `~JS値に変換する$( %結果 )
◎
Return result, converted to a JavaScript value.
</li>
		</ol>
	</li>
	<li>
%却下-時の関数 ~LET
`CreateBuiltinFunction$A( %却下-時の手続き, « » )
◎
Let onRejected be CreateBuiltinFunction(onRejectedSteps, « »).
</li>
	<li>
%構築子 ~LET %~promise.`Promise^sl.`Realm^sl.`Promise$jIsl
◎
Let constructor be promise.[[Promise]].[[Realm]].[[Intrinsics]].[[%Promise%]].
</li>
	<li>
<p>
%新たな能力 ~LET
~ABRUPT `NewPromiseCapability$A( %構築子 )
◎
Let newCapability be ? NewPromiseCapability(constructor).
</p>

<p class="note">注記：
返される `~promise_T$ を利用しない~call元もある。
そのような事例では、
実装は %新たな能力 を作成するのを避けるよう望むこともあろう。
◎
Note: Not all callers will use the returned Promise. Implementations might wish to avoid creating newCapability in those cases.
</p>
	</li>
	<li>
`PerformPromiseThen$A( %~promise.`Promise^sl, %充足-時の関数, %却下-時の関数, %新たな能力 )
◎
Perform PerformPromiseThen(promise.[[Promise]], onFulfilled, onRejected, newCapability).
</li>
	<li>
~RET %新たな能力
◎
Return newCapability.
</li>
</ol>

<p class="note">注記：
この~algoは、
`promise.then()$c ~methodによく似た仕方で挙動することになる。
特に,
［
手続きが返す値の型が［
%T ／ `~promise_T$
］である場合、
この~algoも `~promise_T$ を返す。
◎
Note: This algorithm will behave in a very similar way to the promise.then() method. In particular, if the steps return a value of type U or Promise&lt;U&gt;, this algorithm returns a Promise&lt;U&gt; as well.
</p>
</div>

<div class="algo">
<p>
`~promise_T$ %~promise の
`充足-時@
（ `upon fulfillment^en ）に［
型 %T の値を引数にとる何らかの手続き %手続き
］を遂行するようにするときは：
◎
To perform some steps upon fulfillment of a Promise&lt;T&gt; promise given some steps steps taking a value of type T, perform the following steps:
</p>
<ol>
	<li>
<p>
~RET `~promiseに反応する$( %~promise )
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`充足~手続き^i は、
所与の ( 値 %v ) に対し
⇒
%手続き( %v )
</li>
		</ul>
◎
Return the result of reacting to promise:
• If promise was fulfilled with value v, then:
•• Perform steps with v.
</li>
</ol>

<p>
`~promise_T$ %~promise の
`却下-時@
（ `upon rejection^en ）に［
~JS値を引数にとる何らかの手続き %手続き
］を遂行するようにするときは：
◎
To perform some steps upon rejection of a Promise&lt;T&gt; promise given some steps steps taking a JavaScript value, perform the following steps:
</p>
<ol>
	<li>
<p>
~RET `~promiseに反応する$( %~promise )
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`却下~手続き^i は、
所与の ( 事由 %r ) に対し
⇒
%手続き( %r )
</li>
		</ul>
◎
Return the result of reacting to promise:
• If promise was rejected with reason r, then:
•• Perform steps with r.
</li>
</ol>

<p class="trans-note">【
同じ箇所に［
`充足-時$の手続き, `却下-時$の手続き
］両者が与えられている所では、
`~promiseに反応する$ときに両~手続きとも渡すことになろう。
】</p>
</div>

<div class="algo">
<p>
`すべての~promiseを待機する@
（ `wait for all^en ）
~algoは、
所与の
( `~promise_T$ 値たちが成す`~list$ %~promise群 )
および所与の：
◎
To wait for all with a list of Promise&lt;T&gt; values promises, with＼
</p>
<ul>
	<li>
%成功~手続き
⇒
%T 値たちが成す`~list$を引数にとる手続き
◎
success steps successSteps that take a list of T values and＼
</li>
	<li>
%失敗~手続き
⇒
却下~事由を与える `any$T 値を引数にとる手続き
◎
failure steps failureSteps that take a rejection reason any value,＼
</li>
</ul>
<p>
に対し：
◎
perform the following steps:
</p>
<ol>
	<li>
%充足-回数 ~LET 0
◎
Let fullfilledCount be 0.
</li>
	<li>
%却下されたか ~LET ~F
◎
Let rejected be false.
</li>
	<li class="algo">
<p>
%却下~handler手続き ~LET 所与の ( %引数 ) に対し，次を走らす手続き：
◎
Let rejectionHandlerSteps be the following steps given arg:
</p>
		<ol>
			<li>
~IF［
%却下されたか ~EQ ~T
］
⇒
~RET
◎
If rejected is true, abort these steps.
</li>
			<li>
%却下されたか ~SET ~T
◎
Set rejected to true.
</li>
			<li>
%失敗~手続き( %引数 )
◎
Perform failureSteps given arg.
</li>
		</ol>
	</li>
	<li>
%却下~handler ~LET
`CreateBuiltinFunction$A( %却下~handler手続き, « » )
◎
Let rejectionHandler be CreateBuiltinFunction(rejectionHandlerSteps, « »):
</li>
	<li>
%合計 ~LET %~promise群 の`~size$
◎
Let total be promises’s size.
</li>
	<li>
<p>
~IF［
%合計 ~EQ 0
］：
◎
If total is 0, then:
</p>
		<ol>
			<li>
<p>
`小taskを~queueする$( 次の手続き )
</p>

<div class="algo">
手続きは
⇒
%成功~手続き( « » )
</div>
◎
Queue a microtask to perform successSteps given « ».
</li>
			<li>
~RET
◎
Return.
</li>
		</ol>
	</li>
	<li>
%~index ~LET 0
◎
Let index be 0.
</li>
	<li>
%結果 ~LET %合計 個の `null^V 値たちからなる`~list$
◎
Let result be a list containing total null values.
</li>
	<li>
<p>
%~promise群 を成す
~EACH( %~promise )
に対し：
◎
For each promise of promises:
</p>
		<ol>
			<li>
%~promise~index ~LET %~index
◎
Let promiseIndex be index.
</li>
			<li class="algo">
<p>
%充足~handler ~LET 所与の ( %引数 ) に対し，次を走らす手続き：
◎
Let fulfillmentHandler be the following steps given arg:
</p>
				<ol>
					<li>
%結果[ %~promise~index ] ~SET %引数
◎
Set result[promiseIndex] to arg.
</li>
					<li>
%充足-回数 ~INCBY 1
◎
Set fullfilledCount to fullfilledCount + 1.
</li>
					<li>
~IF［
%充足-回数 ~EQ %合計
］
⇒
%成功~手続き( %結果 )
◎
If fullfilledCount equals total, then perform successSteps given result.
</li>
				</ol>
			</li>
			<li>
%充足~handler ~LET
`CreateBuiltinFunction$A( %充足~handler, « » )
◎
Let fulfillmentHandler be CreateBuiltinFunction(fulfillmentHandler, « »):
</li>
			<li>
`PerformPromiseThen$A( %~promise, %充足~handler, %却下~handler )
◎
Perform PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler).
</li>
			<li>
%~index ~INCBY 1
◎
Set index to index + 1.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`すべてを待機する~promiseを取得する@
（ `get a promise for waiting for all^en ）
~algoは、
所与の
( `~promise_T$ 値たちが成す`~list$ %~promise群, `~realm$ %~realm )
に対し：
◎
To get a promise for waiting for all with a list of Promise&lt;T&gt; values promises and a realm realm, perform the following steps:
</p>
<ol>
	<li>
%~promise ~LET 
型 <code>`Promise$T&lt;`~sequence_T$&gt;</code>
の`新たな~promise$( %~realm )
◎
Let promise be a new promise of type Promise&lt;sequence&lt;T&gt;&gt; in realm.
</li>
	<li>
<p>
`すべての~promiseを待機する$( %~promise群 )
— 次を与える下で：
</p>
		<ul>
			<li class="algo">
`成功~手続き^i は、
所与の
( %結果~群 )
に対し
⇒
`~promiseを解決する$( %~promise, %結果~群 )
</li>
			<li class="algo">
`失敗~手続き^i は、
所与の
( %事由 )
に対し
⇒
`~promiseを却下する$( %~promise, %事由 )
</li>
		</ul>
◎
Let successSteps be the following steps, given results:
• Resolve promise with results.
◎
Let failureSteps be the following steps, given reason:
• Reject promise with reason.
◎
Wait for all with promises, given successSteps and failureSteps.
</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>

<p class="note">注記：
この定義は、
複数個の~promiseの結果を集成して，
それらから別の~promiseを生産するよう望むときに有用になる
— ~JS~code用の `Promise.all()$c 関数と同じ仕方で。
別の~promiseを生産する必要が無い場合、
`すべての~promiseを待機する$方が良いと見込まれる。
◎
This definition is useful when you wish to aggregate the results of multiple promises, and then produce another promise from them, in the same way that Promise.all() functions for JavaScript code. If you do not need to produce another promise, then waiting for all is likely better.
</p>
</div>

<div class="algo">
<p>
`~promiseを取扱済みとして~markする@
（ `mark as handled^en ）ときは、
所与の
( `~promise_T$ %~promise )
に対し
⇒
%~promise.`Promise^sl.`PromiseIsHandled^sl ~SET ~T
◎
To mark as handled a Promise&lt;T&gt; promise, set promise.[[Promise]].[[PromiseIsHandled]] to true.
</p>

<p class="note">注記：
この定義は、［
却下が無視されることが多いと予期される~promise
］用に有用になり，
そのような~promiseが `unhandledrejection＠~HTMLindex#event-unhandledrejection$et ~eventを生じさせないことを確保する。
最も共通的な利用事例は、
~web開発者から諮られ得る~promise~prop用である
— 例えば `writableStreamWriter.closed＠~STREAMS#default-writer-closed$M が返す~promise。
◎
This definition is useful for promises for which you expect rejections to often be ignored; it ensures such promises do not cause unhandledrejection events. The most common use case is for promise properties, which the web developer might or might not consult. An example is the writableStreamWriter.closed promise.
</p>
</div>

				</section>
				<section id="js-promise-examples">
<h5 title="Examples">3.2.24.2. 例</h5>

<div class="example" id="promise-example-delay">
<p>
`delay^c は、
ある~ms数後に充足される~promiseを返す`演算$である。
それは、
~promiseの解決は，単純に 1 行lの注釈文で記せることを~illustrateする：
◎
delay is an operation that returns a promise that will be fulfilled in a number of milliseconds. It illustrates how simply you can resolve a promise, with one line of prose.
</p>

<pre class="webidl">
interface I {
  Promise&lt;undefined&gt; delay(unrestricted double ms);
};
</pre>

<div class="algo">
<p>
<code>delay(%ms)</code>
~method手続きは：
◎
The delay(ms) method steps are:
</p>
<ol>
	<li>
%~realm ~LET `this$V に`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li>
%~task~source ~LET 何らかの適切な`~task~source$
◎
Let taskSource be some appropriate task source.
</li>
	<li>
%ms ~SET ［
%ms ~EQ `NaN^jv ならば `+0^jv ／
~ELSE_ %ms ~LT `+0^jv ならば `+0^jv ／
~ELSE_ %ms
］
◎
If ms is NaN, let ms be +0; otherwise let ms be the maximum of ms and +0.
</li>
	<li>
%p ~LET `新たな~promise$( %~realm )
◎
Let p be a new promise in realm.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
			<li>
<p>
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %p )
</div>
◎
Queue a task on taskSource to resolve p.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol></div>
</div>

<div class="example" id="promise-example-validatedDelay">
<p>
`validatedDelay()^c `演算$は、
引数を検証することを除いて，
`delay()＠#promise-example-delay$c 関数とほぼ同様になる。
これは、［
非同期な演算を開始する前であっても，即時な失敗を通達する
］ために，却下される~promiseを利用する方法を示す。
◎
The validatedDelay operation is much like the delay function, except it will validate its arguments. This shows how to use rejected promises to signal immediate failure before even starting any asynchronous operations.
</p>

<pre class="webidl">
interface I {
  Promise&lt;undefined&gt; validatedDelay(unrestricted double ms);
};
</pre>

<div class="algo">
<p>
<code>validatedDelay(%ms)</code>
~method手続きは：
◎
The validatedDelay(ms) method steps are:
</p>
<ol>
	<li>
%~realm ~LET `this$V に`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li>
%~task~source ~LET 何らかの適切な`~task~source$
◎
Let taskSource be some appropriate task source.
</li>
	<li>
~IF［
%ms ~EQ `NaN^jv
］
⇒
~RET `却下される~promise$( `TypeError$jE 例外, %~realm )
◎
If ms is NaN, return a promise rejected with a TypeError in realm.
</li>
	<li>
~IF［
%ms ~LT 0
］
⇒
~RET `却下される~promise$( `RangeError$jE 例外, %~realm )
◎
If ms &lt; 0, return a promise rejected with a RangeError in realm.
</li>
	<li>
%p ~LET `新たな~promise$( %~realm )
◎
Let p be a new promise in realm.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
			<li>
<p>
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %p )
</div>
◎
Queue a task on taskSource to resolve p.
</li>
		</ol>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>
</div>

<div class="example" id="promise-example-addDelay">
<p>
`addDelay^c は、［
引数 %~promise が決着してから，返される~promiseが決着するまでの間
］に余分な %ms ~msの遅延を追加する`演算$である。
◎
addDelay is an operation that adds an extra number of milliseconds of delay between promise settling and the returned promise settling.
</p>

<pre class="webidl">
interface I {
  Promise&lt;any&gt; addDelay(Promise&lt;any&gt; promise, unrestricted double ms);
};
</pre>

<div class="algo">
<p>
<code>addDelay(%ms, %promise)</code>
~method手続きは：
◎
The addDelay(ms, promise) method steps are:
</p>
<ol>
	<li>
%~realm ~LET `this$V に`関連な~realm$
◎
Let realm be this’s relevant realm.
</li>
	<li>
%~task~source ~LET 何らかの適切な`~task~source$
◎
Let taskSource be some appropriate task source.
</li>
	<li>
%ms ~SET ［
%ms ~EQ `NaN^jv ならば `+0^jv ／
~ELSE_ %ms ~LT `+0^jv ならば `+0^jv ／
~ELSE_ %ms
］
◎
If ms is NaN, let ms be +0; otherwise let ms be the maximum of ms and +0.
</li>
	<li>
%p ~LET `新たな~promise$( %~realm )
◎
Let p be a new promise in realm.
</li>
	<li>
<p>
`~promiseに反応する$( %promise )
— 次を与える下で：
◎
React to promise:
</p>
		<ul>
			<li class="algo">
<p>
`充足~手続き^i は、
所与の ( 値 %v ) に対し：
◎
If promise was fulfilled with value v, then:
</p>
				<ol>
					<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
						<ol>
							<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
							<li>
<p>
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %p, %v )
</div>
◎
Queue a task on taskSource to resolve p with v.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li class="algo">
<p>
`却下~手続き^i は、
所与の ( 事由 %r ) に対し：
◎
If promise was rejected with reason r, then:
</p>
				<ol>
					<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
						<ol>
							<li>
%ms ~msだけ待機する
◎
Wait ms milliseconds.
</li>
							<li>
<p>
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %p, %r )
</div>
◎
Queue a task on taskSource to reject p with r.
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ul>
	</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>
</div>

<div class="example" id="promise-example-environment-ready">
<p>
%環境.`ready^c は、［
ある環境（例：~DOM文書）を成す何らかの部分が “準備済み” になるとき
］を通達する`属性$である。
それは、
その環境による非同期性を~~定式化する方法を~illustrateする：
◎
environment.ready is an attribute that signals when some part of some environment, e.g. a DOM document, becomes "ready". It illustrates how to encode environmental asynchronicity.
</p>

<pre class="webidl">
interface Environment {
  readonly attribute Promise&lt;undefined&gt; ready;
};
</pre>

<p>
どの `Environment^T ~objも
<code>`Promise$T&lt;`undefined$T&gt;</code>
型の
`準備済み~promise@
を有するモノトスル。
◎
Every Environment object must have a ready promise, which is a Promise&lt;undefined&gt;.
</p>

<div class="algo">
<p>
`ready^c 属性~取得子~手続きは：
◎
The ready attribute getter steps are:
</p>
<ol>
	<li>
~RET `this$V の`準備済み~promise$
◎
Return this’s ready promise.
</li>
</ol>
</div>

<div class="algo">
<p>
`~realm$ %~realm 内で `Environment^T ~objを作成するときは、
次~手続きを遂行する：
◎
To create an Environment object in a realm realm, perform the following steps:
</p>
<ol>
	<li>
%~task~source ~LET 何らかの適切な`~task~source$
◎
Let taskSource be some appropriate task source.
</li>
	<li>
%環境 ~LET `~ifcを実装する新たな~objを作成する$( `Environment^T, %~realm )
◎
Let environment be new Environment object in realm.
</li>
	<li>
%環境 の`準備済み~promise$ ~SET `新たな~promise$( %~realm )
◎
Set environment’s ready promise to a new promise in realm.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
何らかの非同期な作業を行う【加えて，それが完了するまで待機する】
◎
Do some asynchronous work.
</li>
			<li>
<p>
~IF［
%環境 は成功裡に準備済みになった
］
⇒
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %環境 の`準備済み~promise$ )
</div>
◎
If environment becomes ready successfully, then queue a task on taskSource to resolve environment’s ready promise.
</li>
			<li>
<p>
~ELSE（準備済みにならずに失敗した）
⇒
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %環境 の`準備済み~promise$, `NetworkError$E 例外 )
</div>
◎
If environment fails to become ready, then queue a task on taskSource to reject environment’s ready promise with a "NetworkError" DOMException.
</li>
		</ol>
	</li>
	<li>
~RET %環境
◎
Return environment.
</li>
</ol>
</div>
</div>

<div class="example" id="promise-example-addBookmark">
<p>
`addBookmark^c は、［
現在の~web~pageを~bookmarkとして追加する
］よう利用者に要請する，`演算$である。
これは，
`何度も行われる設計~作業＠https://github.com/domenic/promises-unwrapping/issues/85$から取り出されたものであり、
環境による非同時性を，現実にありそうな局面として訴えかけると伴に、
即時な却下についても~illustrateするものである。
◎
addBookmark is an operation that requests that the user add the current web page as a bookmark. It’s drawn from some iterative design work and illustrates a more real-world scenario of appealing to environmental asynchrony, as well as immediate rejections.
</p>

<pre class="webidl">
interface I {
  Promise&lt;undefined&gt; addBookmark();
};
</pre>

<div class="algo">
<p>
`addBookmark()^c
~method手続きは：
◎
The addBookmark() method steps are:
</p>
<ol>
	<li>
%~task~source ~LET 何らかの適切な`~task~source$
◎
Let taskSource be some appropriate task source.
</li>
	<li>
~IF［
この~methodは明示的な利用者~動作の結果として呼出されていない
］
⇒
~RET `却下される~promise$( `SecurityError$E 例外 )
◎
If this method was not invoked as a result of explicit user action, return a promise rejected with a "SecurityError" DOMException.
</li>
	<li>
~IF［
文書の “演算~mode” は “自立的” である
］
⇒
~RET `却下される~promise$( `NotSupportedError$E 例外 )
◎
If the document’s mode of operation is standalone, return a promise rejected with a "NotSupportedError" DOMException.
</li>
	<li>
%~promise ~LET `新たな~promise$
◎
Let promise be a new promise.
</li>
	<li>
%~metadata ~LET ~web~appの~metadataを取得した結果
◎
Let info be the result of getting a web application’s metadata.
</li>
	<li class="algo">
<p>
この段は`並列的$に走らす：
◎
Run the following steps in parallel:
</p>
		<ol>
			<li>
<p>
%~metadata を利用して，~UAに特有な［
~bookmarkを追加するよう求めるかどうか選ぶことを，末端利用者に許容する方式
］で：
◎
Using info, and in a manner that is user-agent specific, allow the end user to make a choice as to whether they want to add the bookmark.
</p>
				<ol>
					<li>
<p>
~IF［
末端利用者は~bookmarkを追加する要請する中止した（例：~escapeを叩いたか “取消-” ~buttonを押した）
］
⇒
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを却下する$( %~promise, `AbortError$E 例外 )
</div>
◎
If the end-user aborts the request to add the bookmark (e.g., they hit escape, or press a "cancel" button), then queue a task on taskSource to reject promise with an "AbortError" DOMException.
</li>
					<li>
<p>
~ELSE
⇒
`~taskを~queueする$( %~task~source, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~promiseを解決する$( %~promise )
</div>
◎
Otherwise, queue a task on taskSource to resolve promise.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET %~promise
◎
Return promise.
</li>
</ol>
</div>
</div>

<div class="example" id="promise-example-batchRequest">
<p>
`SERVICE-WORKERS$r は、
何箇所かで，`すべてを待機する~promiseを取得する$を利用している。
`batchRequest^c は、
その種のある利用を単純~化した~versionを~illustrateする。
それは、
一連の~URLが成す `~sequence_T$ を入力にとり，［
各~URLを~fetchして作成された `Response$T ~objたちが成す `~sequence_T$
］用の~promiseを返す。
いずれかの~fetchが失敗した場合、
その失敗で`却下される~promise$を返すことになる。
◎
Several places in [SERVICE-WORKERS] use get a promise to wait for all. batchRequest illustrates a simplified version of one of their uses. It takes as input a sequence of URLs, and returns a promise for a sequence of Response objects created by fetching the corresponding URL. If any of the fetches fail, it will return a promise rejected with that failure.
</p>

<pre class="webidl">
interface I {
  Promise&lt;sequence&lt;Response&gt;&gt; batchRequest(sequence&lt;USVString&gt; urls);
};
</pre>

<div class="algo">
<p>
<code>batchRequest(%urls)</code>
~method手続きは：
◎
The batchRequest(urls) method steps are:
</p>
<ol>
	<li>
%応答~promise群 ~LET  « »
◎
Let responsePromises be « ».
</li>
	<li>
<p>
%urls を成す
~EACH( %url )
に対し：
◎
For each url of urls:
</p>
		<ol>
			<li>
%p ~LET `fetch(<var>url</var>)＠~FETCH#dom-global-fetch$M を~callした結果
◎
Let p be the result of calling fetch() with url.
</li>
			<li>
%応答~promise群 に %p を`付加する$
◎
Append p to responsePromises.
</li>
		</ol>
	</li>
	<li>
%p ~LET `すべてを待機する~promiseを取得する$( %応答~promise群 )
◎
Let p be the result of getting a promise to wait for all with responsePromises.
</li>
	<li>
~RET %p
◎
Return p.
</li>
</ol>
</div>
</div>

				</section>
			</section>
			<section id="js-union">
<h4 title="Union types">3.2.25. 共用体~型</h4>

<p>
~IDL`共用体~型$の値は、
共用体の`~mb型$に対応する~JS値により表現される。
◎
IDL union type values are represented by JavaScript values that correspond to the union’s member types.
</p>

<div class="algo">
<p id="js-to-union">
~JS値 %V を`共用体~型$ %U の`~IDL値に変換する$ための~algoは：
◎
To convert a JavaScript value V to an IDL union type value is done as follows:
</p>
<ol>
	<li>
~IF［
%U は`~undefinedを内包する$
］~AND［
%V ~EQ `undefined^jv
］
⇒
~RET 一意な `undefined$T 値
◎
If the union type includes undefined and V is undefined, then return the unique undefined value.
</li>
	<li>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］~AND［
%U は`~nullable型を内包する$
］
⇒
~RET ~IDL値 `null^V
◎
If the union type includes a nullable type and V is null or undefined, then return the IDL value null.
</li>
	<li>
%型~群 ~LET %U の`平坦~化~mb型~群$
◎
Let types be the flattened member types of the union type.
</li>
	<li>
<p>
~IF［
%V ~IN { `null^jv, `undefined^jv }
］：
◎
If V is null or undefined, then:
</p>
		<ol>
			<li>
~IF［
%型~群 に`辞書~型$が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その辞書~型 )
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `~platform~objである$
］：
◎
If V is a platform object, then:
</p>
		<ol>
			<li>
~IF［
%型~群 に %V が`実装-$する`~ifc型$が含まれている
］
⇒
~RET ~obj %V への参照である~IDL値
◎
If types includes an interface type that V implements, then return the IDL value that is a reference to the object V.
</li>
			<li id="cp-object-in-types">
~IF［
%型~群 に `object$T が含まれている
］
⇒
~RET ~obj %V への参照である~IDL値
◎
If types includes object, then return the IDL value that is a reference to the object V.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `Object$jt である
］~AND［
%V は `ArrayBufferData^sl `内部~slot$を有する
］：
</p>
		<ol>
			<li>
%配列~buffer型 ~LET `IsSharedArrayBuffer$A( %V ) の結果に応じて
⇒＃
`true^jv ならば `SharedArrayBuffer$T ／
`false^jv ならば `ArrayBuffer$T
</li>
			<li>
~IF［
%型~群 に %配列~buffer型 が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, %配列~buffer型 )
</li>
			<!--cp-object-in-types-->
		</ol>
◎
If V is an Object, V has an [[ArrayBufferData]] internal slot, and IsSharedArrayBuffer(V) is false, then:
• If types includes ArrayBuffer, then return the result of converting V to ArrayBuffer.
• If types includes object, then return the IDL value that is a reference to the object V.
◎
If V is an Object, V, has an [[ArrayBufferData]] internal slot, and IsSharedArrayBuffer(V) is true, then:
• If types includes SharedArrayBuffer, then return the result of converting V to SharedArrayBuffer.
• If types includes object, then return the IDL value that is a reference to the object V.
</li>
	<li>
<p>
~IF［
%V は `Object$jt である
］~AND［
%V は `DataView^sl `内部~slot$を有する
］：
◎
If V is an Object and V has a [[TypedArrayName]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型~群 に `DataView$T が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, `DataView$T )
◎
If types includes DataView, then return the result of converting V to DataView.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `Object$jt である
］~AND［
%V は `TypedArrayName^sl `内部~slot$を有する
］：
◎
If V is an Object and V has a [[TypedArrayName]] internal slot, then:
</p>
		<ol>
			<li>
~IF［
%型~群 に［
`有型~配列~型$であって，［
その名前 ~EQ %V の `TypedArrayName^sl `内部~slot$の値
］を満たすもの
］が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その型 )
◎
If types includes a typed array type whose name is the value of V’s [[TypedArrayName]] internal slot, then return the result of converting V to that type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
`IsCallable$A( %V ) ~EQ ~T
］：
◎
If IsCallable(V) is true, then:
</p>
		<ol>
			<li>
~IF［
%型~群 に`~callback関数$型が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その~callback関数~型 )
◎
If types includes a callback function type, then return the result of converting V to that callback function type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `Object$jt である
］：
◎
If V is an Object, then:
</p>
		<ol>
			<li>
<p>
~IF［
%型~群 に`非同期c連列~型$が含まれている
］：
◎
If types includes an async sequence type, then
</p>
				<ol>
					<li>
<p>
~IF［
%型~群 に`文字列~型$は含まれていない
］~OR［
%V は `StringData^sl `内部~slot$を有さない
］：
◎
If types does not include a string type or V does not have a [[StringData]] internal slot, then
</p>
						<ol>
							<li>
%非同期c~method ~LET
~ABRUPT `GetMethod$A( %V, `Symbol.asyncIterator$jI )
◎
Let asyncMethod be ? GetMethod(V, %Symbol.asyncIterator%).
</li>
							<li>
~IF［
%非同期c~method ~NEQ `undefined^jv
］
⇒
~RET 新たな`非同期c連列$
— その
⇒＃
`~obj$aS ~SET %V,
`~method$aS ~SET %同期c~method,
`種別$aS ~SET `非同期c^C
◎
If asyncMethod is not undefined, return an IDL async sequence value with object set to V, method set to syncMethod, and type set to "async".
</li>
							<li>
%同期c~method ~LET
~ABRUPT `GetMethod$A( %V, `Symbol.iterator$jI )
◎
Let syncMethod be ? GetMethod(V, %Symbol.iterator%).
</li>
							<li>
~IF［
%同期c~method ~NEQ `undefined^jv
］
⇒
~RET 新たな`非同期c連列$
— その
⇒＃
`~obj$aS ~SET %V,
`~method$aS ~SET %同期c~method,
`種別$aS ~SET `同期c^C
◎
If syncMethod is not undefined, return an IDL async sequence value with object set to V, method set to syncMethod, and type set to "sync".
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%型~群 に`連列~型$ %T が含まれている
］：
◎
If types includes a sequence type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<li>
~IF［
%~method ~NEQ `undefined^jv
］
⇒
~RET `可反復から連列を作成する$( %T, %V, %~method )
◎
If method is not undefined, return the result of creating a sequence of that type from V and method.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%型~群 に`凍結d配列~型$ %T が含まれている
］：
◎
If types includes a frozen array type, then
</p>
				<ol>
					<!--cp-checkiter-V-->
					<li>
~IF［
%~method ~NEQ `undefined^jv
］
⇒
~RET `可反復から凍結d配列を作成する$( %T, %V, %~method )
◎
If method is not undefined, return the result of creating a frozen array of that type from V and method.
</li>
				</ol>
			</li>
			<li>
~IF［
%型~群 に`辞書~型$が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その型 )
◎
If types includes a dictionary type, then return the result of converting V to that dictionary type.
</li>
			<li>
~IF［
%型~群 に`~record型$が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その型 )
◎
If types includes a record type, then return the result of converting V to that record type.
</li>
			<li>
~IF［
%型~群 に`~callback~ifc型$が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その型 )
◎
If types includes a callback interface type, then return the result of converting V to that callback interface type.
</li>
			<!--cp-object-in-types-->
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `Boolean$jt である
］：
◎
If V is a Boolean, then:
</p>
		<ol>
			<li id="cp-boolean-in-types">
~IF［
%型~群 に `boolean$T が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, `boolean$T )
◎
If types includes boolean, then return the result of converting V to boolean.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `Number$jt である
］：
◎
If V is a Number, then:
</p>
		<ol>
			<li id="cp-numeric-in-types">
~IF［
%型~群 に`数量-型$が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その`数量-型$ )
◎
If types includes a numeric type, then return the result of converting V to that numeric type.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%V は `BigInt$jt である
］：
◎
If V is a BigInt, then:
</p>
		<ol>
			<li id="cp-bigint-in-types">
~IF［
%型~群 に `bigint$T が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, `bigint$T )
◎
If types includes bigint, then return the result of converting V to bigint.
</li>
		</ol>
	</li>
	<li>
~IF［
%型~群 に`文字列~型$が含まれている
］
⇒
~RET `~IDL値に変換する$( %V, その型 )
◎
If types includes a string type, then return the result of converting V to that type.
</li>
			<li>
~IF［
%型~群 に［
`bigint$T, `数量-型$
］が含まれている
］
⇒
~RET %V を その`いずれかの型の~IDL値に変換する$
◎
If types includes a numeric type and bigint, then return the result of converting V to either that numeric type or bigint.
</li>
	<!--cp-numeric-in-types-->
	<!--cp-boolean-in-types-->
	<!--cp-bigint-in-types-->
	<!--cp-throw-typeerror-->
</ol>
</div>

<p id="union-to-js">
~IDL共用体~型の値 %U を`~JS値に変換する$ときは、［
この`~JS型との対応付け＠#js-type-mapping§の中の他所にて述べる，
%U の`特有~型$を`~JS値に変換する$ための規則
］に従うとする。
◎
An IDL union type value is converted to a JavaScript value according to the rules for converting the specific type of the IDL union type value as described in this section (§ 3.2 JavaScript type mapping).
</p>

			</section>
			<section id="js-buffer-source-types">
<h4 title="Buffer source types">3.2.26. ~buffer~source型</h4>

<p>
~IDL［
`ArrayBuffer$T ／ `SharedArrayBuffer$T
］型の値は、
対応する~JS~classの~objにより表現される
— そのような値は，ある~JS［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt
］~obj %V により~backされるが、
当の型に `AllowResizable$x `拡張d属性が結付けられ$ていない場合，［
`IsResizableArrayBuffer$A( %V ) ~EQ `false^jv
］を満たすもの†に限られる。
◎
A value of an IDL ArrayBuffer is represented by an object of the corresponding JavaScript class. If it is not associated with the [AllowResizable] extended attribute, it can only be backed by JavaScript ArrayBuffer objects V for which IsResizableArrayBuffer(V) is false.
◎
A value of an IDL SharedArrayBuffer is represented by an object of the corresponding JavaScript class. If it is not associated with the [AllowResizable] extended attribute, it can only be backed by JavaScript SharedArrayBuffer objects V for which IsResizableArrayBuffer(V) is false.
</p>

<p>
~IDL`~buffer~view型$の値は、
対応する~JS~classの~objにより表現される
— そのような値は，ある~JS［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt
］~obj %V により~backされるが：
◎
Values of the IDL buffer view types are represented by objects of the corresponding JavaScript class, with the following additional restrictions on those objects.
</p>
<ul>
	<li>
当の型に `AllowShared$x `拡張d属性が結付けられ$ていない場合、
%V は `ArrayBuffer$jt ~objに限られる【！if applicable？】。
◎
If the type is not associated with either the [AllowResizable] or [AllowShared] extended attribute, if applicable, they can only be backed by JavaScript ArrayBuffer objects V for which IsResizableArrayBuffer(V) is false.
◎
If the type is associated with the [AllowResizable] extended attribute but not with the [AllowShared] extended attribute, if applicable, they can only be backed by JavaScript ArrayBuffer objects.
</li>
	<li>
当の型に `AllowResizable$x `拡張d属性が結付けられ$ていない場合、［
`IsResizableArrayBuffer$A( %V ) ~EQ `false^jv
］を満たすもの†に限られる。
◎
If the type is associated with the [AllowShared] extended attribute but not with the [AllowResizable] extended attribute, they can only be backed by JavaScript ArrayBuffer and SharedArrayBuffer objects V for which IsResizableArrayBuffer(V) is false.
◎
If the type is associated with both the [AllowResizable] and the [AllowShared] extended attributes, they can be backed by any JavaScript ArrayBuffer or SharedArrayBuffer object.
</li>
</ul>

<p class="trans-note">【
“~backする” とは、
下層の~dataを “裏で保持する” ことを意味する。
】【†
すなわち， “~resize可能” でないもの
】</p>

<div class="algo">
<p id="js-to-buffer-source">
~JS値 %V を`ArrayBuffer$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL ArrayBuffer value by running the following algorithm:
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%V は `Object$jt でない
</li>
			<li>
%V は `ArrayBufferData^sl `内部~slot$を有さない
</li>
			<li>
`IsSharedArrayBuffer$A( %V ) ~EQ `true^jv
</li>
			<li id="cp-is-conv-not-AllowResizable-0">
［
`AllowResizable$x `拡張d属性が結付けられ$た~IDL型への変換でない
］~AND［
`IsResizableArrayBuffer$A( %V ) ~EQ `true^jv
］
</li>
		</ul>
<p>
…ならば
⇒
`~THROW$ `TypeError$jt
</p>

◎
If V is not an Object, or V does not have an [[ArrayBufferData]] internal slot, then throw a TypeError.
◎
If IsSharedArrayBuffer(V) is true, then throw a TypeError.
◎
If the conversion is not to an IDL type associated with the [AllowResizable] extended attribute, and IsResizableArrayBuffer(V) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `ArrayBuffer$T 値
◎
Return the IDL ArrayBuffer value that is a reference to the same object as V.
</li>
</ol>
</div>

<div class="algo">
<p>
~JS値 %V を`SharedArrayBuffer$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL SharedArrayBuffer value by running the following algorithm:
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%V は `Object$jt でない
</li>
			<li>
%V は `ArrayBufferData^sl `内部~slot$を有さない
</li>
			<li>
`IsSharedArrayBuffer$A( %V ) ~EQ `false^jv
</li>
			<!--cp-is-conv-not-AllowResizable-0-->
		</ul>
<p>
…ならば
⇒
`~THROW$ `TypeError$jt
</p>
◎
If V is not an Object, or V does not have an [[ArrayBufferData]] internal slot, then throw a TypeError.
◎
If IsSharedArrayBuffer(V) is false, then throw a TypeError.
◎
If the conversion is not to an IDL type associated with the [AllowResizable] extended attribute, and IsResizableArrayBuffer(V) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `SharedArrayBuffer$T 値
◎
Return the IDL SharedArrayBuffer value that is a reference to the same object as V.
</li>
</ol>
</div>

<div class="algo">
<p>
~JS値 %V を `DataView$T 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL DataView value by running the following algorithm:
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%V は `Object$jt でない
</li>
			<li>
%V は `DataView^sl `内部~slot$を有さない
</li>
			<li id="cp-is-conv-not-AllowShared">
［
`AllowShared$x `拡張d属性が結付けられ$た~IDL型への変換でない
］~AND［
`IsSharedArrayBuffer$A( %V.`ViewedArrayBuffer^sl ) ~EQ `true^jv
］
</li>
			<li id="cp-is-conv-not-AllowResizable-1">
［
`AllowResizable$x `拡張d属性が結付けられ$た~IDL型への変換でない
］~AND［
`IsResizableArrayBuffer$A( %V.`ViewedArrayBuffer^sl ) ~EQ `true^jv
］
</li>
		</ul>
<p>
…ならば
⇒
`~THROW$ `TypeError$jt
</p>
◎
If V is not an Object, or V does not have a [[DataView]] internal slot, then throw a TypeError.
◎
If the conversion is not to an IDL type associated with the [AllowShared] extended attribute, and IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true, then throw a TypeError.
◎
If the conversion is not to an IDL type associated with the [AllowResizable] extended attribute, and IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL `DataView$T 値
◎
Return the IDL DataView value that is a reference to the same object as V.
</li>
</ol>
</div>

<div class="algo">
<p>
~JS値 %V を いずれかの`有型~配列~型$【！Int8Array, …】 %T の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, BigInt64Array, BigUint64Array, Float16Array, Float32Array, or Float64Array value by running the following algorithm:
• Let T be the IDL type V is being converted to.
</p>
<ol>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%V は `Object$jt でない
</li>
			<li>
%V は `TypedArrayName^sl `内部~slot$を有さない
</li>
			<li>
%V の `TypedArrayName^sl `内部~slot$の値 ~NEQ %T の名前
</li>
			<!--cp-is-conv-not-AllowShared-->
			<!--cp-is-conv-not-AllowResizable-1-->
		</ul>
<p>
…ならば
⇒
`~THROW$ `TypeError$jt
</p>
◎
If V is not an Object, or V does not have a [[TypedArrayName]] internal slot with a value equal to T’s name, then throw a TypeError.
◎
If the conversion is not to an IDL type associated with the [AllowShared] extended attribute, and IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true, then throw a TypeError.
◎
If the conversion is not to an IDL type associated with the [AllowResizable] extended attribute, and IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is true, then throw a TypeError.
</li>
	<li>
~RET %V と同じ~objへの参照である~IDL %T 型~値
◎
Return the IDL value of type T that is a reference to the same object as V.
</li>
</ol>
</div>

<p class="algo" id="buffer-source-to-js">
`~buffer~source型$の~IDL値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~objへの参照を表現する `Object^jt
◎
The result of converting an IDL value of any buffer source type to a JavaScript value is the Object value that represents a reference to the same object that the IDL value represents.
</p>

<hr>

<div class="algo">
<p>
`~buffer~sourceを作成する@
~algoは、
所与の
( `~buffer~source型$ %T, ［ `~byte列$／負でない整数 ］ %~byte列または長さ, `~realm$ %~realm )
に対し：
</p>
<ol>
	<li>
%~buffer型 ~LET %T に応じて
⇒＃
`SharedArrayBuffer$T ならば %T ／
~ELSE_ `ArrayBuffer$T
</li>
	<li>
%長さ ~LET %~byte列または長さ に応じて
⇒＃
`~byte列$であるならば`~byte列$の`長さ$byte ／
整数であるならば %~byte列または長さ
</li>
	<li>
<p>
%~js配列~buffer ~LET %~buffer型 に応じて：
</p>
		<ul class="switch">
			<li>
`SharedArrayBuffer$T
⇒
~ABRUPT `AllocateSharedArrayBuffer$A( %~realm.`SharedArrayBuffer$jIsl, %長さ )
</li>
			<li>
`ArrayBuffer$T
⇒
~ABRUPT `AllocateArrayBuffer$A( %~realm.`ArrayBuffer$jIsl, %長さ )
</li>
		</ul>

<p class="trans-note">【
~JS仕様に則って、
ここで割振られた~bufferを成す各~byteは，
すべて 0 に初期化される。
~bufferを割振ることに失敗した場合、
`RangeError$jE が投出される。
】</p>
	</li>
	<li>
%配列~buffer ~LET `~IDL値に変換する$( %~js配列~buffer, %~buffer型 )
</li>
	<li>
~IF［
%~byte列または長さ は`~byte列$である
］
⇒
`配列~bufferの中へ~byte列を書込む$( %配列~buffer, %~byte列または長さ )
</li>
	<li>
~IF［
%T は`~buffer型$である
］
⇒
~RET %配列~buffer
</li>
	<li>
~Assert：
%T は`~buffer~view型$である
</li>
	<li>
~Assert：
［
%T ~EQ `DataView$T
］~OR［
%長さ `modulo$op ( %T の`要素~size$eS )
~EQ 0
］
</li>
	<li>
%構築子 ~LET %~realm.`Intrinsics^sl からの［
%T 用の適切な構築子
］
</li>
	<li>
%~js~view ~LET
~NOABRUPT `Construct$A( %構築子, « %~js配列~buffer » )
</li>
	<li>
~RET `~IDL値に変換する$( %~js~view, %T )
</li>
</ol>

<p class="trans-note">【
この~algoは、
原文では %T ~EQ ［
<dfn id="arraybuffer-create">`ArrayBuffer$T の場合</dfn>
／
<dfn id="sharedarraybuffer-create">`SharedArrayBuffer$T の場合</dfn>
／
<dfn id="arraybufferview-create">`ArrayBufferView$T の場合</dfn>
］の 3 つに分けて定義されているが，
この訳では 1 つに統合することにする。
】【
%~byte列または長さ は、
原文では，~byte列しかとらない %~byte列 として定義されるが、
この訳では，［
~byte列を書込むことなく~buffer~sourceを作成する事例
］にも利用できるよう拡張する。
】</p>
◎
To create an ArrayBuffer from a byte sequence bytes in a realm realm:
• Let jsArrayBuffer be ? AllocateArrayBuffer(realm.[[Intrinsics]].[[%ArrayBuffer%]], bytes’s length).
• Let arrayBuffer be the result of converting jsArrayBuffer to an IDL value of type ArrayBuffer.
• Write bytes into arrayBuffer.
• Return arrayBuffer.
◎
To create a SharedArrayBuffer from a byte sequence bytes in a realm realm:
• Let jsSharedArrayBuffer be ? AllocateSharedArrayBuffer(realm.[[Intrinsics]].[[%SharedArrayBuffer%]], bytes’s length).
• Let sharedArrayBuffer be the result of converting jsSharedArrayBuffer to an IDL value of type SharedArrayBuffer.
• Write bytes into sharedArrayBuffer.
• Return sharedArrayBuffer.
◎
To create one of the ArrayBufferView types from a byte sequence bytes in a realm realm:
• Assert: if the type is not DataView, then bytes’s length modulo the element size of that type is 0.
• Let arrayBuffer be the result of creating an ArrayBuffer from bytes in realm.
• Let jsArrayBuffer be the result of converting arrayBuffer to a JavaScript value.
• Let constructor be the appropriate constructor from realm.[[Intrinsics]] for the type of ArrayBufferView being created.
• Let jsView be ! Construct(constructor, « jsArrayBuffer »).
• Return the result of converting jsView into the given type.
</div>

<div class="algo">
<p>
`~buffer~source型$の~instance %~buffer~source に
`保持された~byte列の複製を取得する@
~algoは：
◎
To get a copy of the bytes held by the buffer source given a buffer source type instance bufferSource:
</p>
<ol>
	<li>
%~js~buffer~source ~LET `~JS値に変換する$( %~buffer~source )
◎
Let jsBufferSource be the result of converting bufferSource to a JavaScript value.
</li>
	<li>
%~js配列~buffer ~LET %~js~buffer~source
◎
Let jsArrayBuffer be jsBufferSource.
</li>
	<li>
%~offset ~LET 0
◎
Let offset be 0.
</li>
	<li>
%長さ ~LET 0
◎
Let length be 0.
</li>
	<li>
<p>
~IF［
%~js~buffer~source は `ViewedArrayBuffer^sl `内部~slot$を有する
］：
◎
If jsBufferSource has a [[ViewedArrayBuffer]] internal slot, then:
</p>
		<ol>
			<li>
%~js配列~buffer ~SET %~js~buffer~source.`ViewedArrayBuffer^sl
◎
Set jsArrayBuffer to jsBufferSource.[[ViewedArrayBuffer]].
</li>
			<li>
%~offset ~SET %~js~buffer~source.`ByteOffset^sl
◎
Set offset to jsBufferSource.[[ByteOffset]].
</li>
			<li>
%長さ ~SET %~js~buffer~source.`ByteLength^sl
◎
Set length to jsBufferSource.[[ByteLength]].
</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
%~js~buffer~source は［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt【！T】
］~objである
◎
Assert: jsBufferSource is an ArrayBuffer or SharedArrayBuffer object.
</li>
			<li>
%長さ ~SET %~js~buffer~source.`ArrayBufferByteLength^sl
◎
Set length to jsBufferSource.[[ArrayBufferByteLength]].
</li>
		</ol>
	</li>
	<li>
%~byte列 ~LET 空な`~byte列$
◎
↓</li>
	<li>
~IF［
`IsDetachedBuffer$A( %~js配列~buffer ) ~EQ `true^jv
］
⇒
~RET %~byte列
◎
If IsDetachedBuffer(jsArrayBuffer) is true, then return the empty byte sequence.
◎
Let bytes be a new byte sequence of length equal to length.
</li>
	<li>
~EACH( %i ~IN { 0 〜 %長さ ~MINUS 1 } )
に対し，昇順に
⇒
%~byte列 に次の結果を付加する
⇒
`GetValueFromBuffer$A( %~js配列~buffer, %i, `Uint8^jt, `true^jv, `Unordered^i )
◎
For i in the range offset to offset + length − 1, inclusive, set bytes[i − offset] to GetValueFromBuffer(jsArrayBuffer, i, Uint8, true, Unordered).
</li>
	<li>
~Assert：
%~byte列 の`長さ$byte ~EQ %長さ
◎
↑</li>
	<li>
~RET %~byte列
◎
Return bytes.
</li>
</ol>
</div>

<div class="algo">
<p>
`~buffer~source型$の~instance %~buffer~source の
`~byte長さ@BS
は、
次の手続きの結果を返す：
◎
The byte length of a buffer source type instance bufferSource is the value returned by the following steps:
</p>
<ol>
	<li>
%~js~buffer~source ~LET `~JS値に変換する$( %~buffer~source )
◎
Let jsBufferSource be the result of converting bufferSource to a JavaScript value.
</li>
	<li>
~IF［
%~js~buffer~source は `ViewedArrayBuffer^sl 内部~slotを有する
］
⇒
~RET %~js~buffer~source.`ByteLength^sl
◎
If jsBufferSource has a [[ViewedArrayBuffer]] internal slot, then return jsBufferSource.[[ByteLength]].
</li>
	<li>
~RET %~js~buffer~source.`ArrayBufferByteLength^sl
◎
Return jsBufferSource.[[ArrayBufferByteLength]].
</li>
</ol>
</div>

<div class="algo">
<p>
`~buffer~source型$の~instance %~buffer~source の
`下層~buffer@BS
は、
次の手続きの結果を返す：
◎
The underlying buffer of a buffer source type instance bufferSource is the value returned by the following steps:
</p>
<ol>
	<li>
~IF［
%~buffer~source は`~buffer型$の~instanceである
］
⇒
~RET %~buffer~source
◎
If bufferSource is a buffer type instance, then return bufferSource.
</li>
	<li>
%~js~buffer~view ~LET `~JS値に変換する$( %~buffer~source )
◎
Let jsBufferView be the result of converting bufferSource to a JavaScript value.
</li>
	<li>
%~js~buffer ~LET %~js~buffer~view.`ViewedArrayBuffer^sl
◎
Let jsBuffer be jsBufferView.[[ViewedArrayBuffer]].
</li>
	<li>
~IF［
`IsSharedArrayBuffer$A( %~js~buffer ) ~EQ `false^jv
］
⇒
~RET `~IDL値に変換する$( %~js~buffer, `ArrayBuffer$T )
◎
If IsSharedArrayBuffer(jsBuffer) is false, then return the result of converting jsBuffer to an IDL value of type ArrayBuffer.
</li>
	<li>
~RET `~IDL値に変換する$( %~js~buffer, `SharedArrayBuffer$T )
◎
Return the result of converting jsBuffer to an IDL value of type SharedArrayBuffer.
</li>
</ol>
</div>

<div class="algo">
<p>
`配列~bufferの中へ~byte列を書込む@
~algoは、
所与の
(
`~buffer型$の~instance %配列~buffer,
`~byte列$ %~byte列,
負でない整数 <dfn id="arraybuffer-write-startingoffset">%開始-時の~offset</dfn> ~DF 0
)
に対し：
◎
To write a byte sequence bytes into a buffer type instance arrayBuffer, optionally given a startingOffset (default 0):
</p>
<ol>
	<li>
%~js配列~buffer ~LET `~JS値に変換する$( %配列~buffer )
◎
Let jsArrayBuffer be the result of converting arrayBuffer to a JavaScript value.
</li>
	<li>
~Assert：
%開始-時の~offset ~PLUS %~byte列 の`長さ$byte ~LTE
%~js配列~buffer.`ArrayBufferByteLength^sl
◎
Assert: bytes’s length ≤ jsArrayBuffer.[[ArrayBufferByteLength]] − startingOffset.
</li>
	<li>
~EACH( %i ~IN { 0 〜 %~byte列 の`長さ$byte ~MINUS 1 } )
に対し，昇順に
⇒
`SetValueInBuffer$A( %~js配列~buffer, %i, `Uint8^jt, %~byte列[ %i ], `true^jv, `Unordered^i)
◎
For i in the range startingOffset to startingOffset + bytes’s length − 1, inclusive, perform SetValueInBuffer(jsArrayBuffer, i, Uint8, bytes[i - startingOffset], true, Unordered).
</li>
</ol>
</div>

<div class="algo">
<p>
`配列~buffer~viewの中へ~byte列を書込む@
~algoは、
所与の
(
`ArrayBufferView$T %~view,
`~byte列$ %~byte列,
負でない整数 <dfn id="arraybufferview-write-startingoffset">%開始-時の~offset</dfn> ~DF 0 
)
に対し：
◎
To write a byte sequence bytes into an ArrayBufferView view, optionally given a startingOffset (default 0):
</p>
<ol>
	<li>
%~js~view ~LET `~JS値に変換する$( %~view )
◎
Let jsView be the result of converting view to a JavaScript value.
</li>
	<li>
%長さ ~LET %~byte列 の`長さ$byte
◎
↓</li>
	<li>
~Assert：
%開始-時の~offset ~PLUS %長さ ~LTE %~js~view.`ByteLength^sl
◎
Assert: bytes’s length ≤ jsView.[[ByteLength]] − startingOffset.
</li>
	<li>
~Assert：
［
%型 は `DataView$T である
］~OR［
%長さ `modulo$op ( %~view の型の`要素~size$eS ) ~EQ 0
］
◎
Assert: if view is not a DataView, then bytes’s length modulo the element size of view’s type is 0.
</li>
	<li>
%配列~buffer ~LET `~IDL値に変換する$( %~js~view.`ViewedArrayBuffer^sl, `ArrayBuffer$T )
◎
Let arrayBuffer be the result of converting jsView.[[ViewedArrayBuffer]] to an IDL value of type ArrayBuffer.
</li>
	<li>
`配列~bufferの中へ~byte列を書込む$( %配列~buffer, %~byte列, %~js~view.`ByteOffset^sl ~PLUS %開始-時の~offset )
◎
Write bytes into arrayBuffer with startingOffset set to jsView.[[ByteOffset]] + startingOffset.
</li>
</ol>
</div>

<div class="warning">
<p>
仕様において，
`~buffer~source型$の~instanceの中へ`~byte列を書込む＠#arraybuffer-write$ような~textを書くときには、
細心な注意を払う必要がある
— 下層の~dataは、
作者や他の~APIにより，予測-不能なときに容易に変更され得るので。
このことは、
とりわけ `SharedArrayBuffer$T ~objが孕まれる場合に該当する。
◎
Extreme care must be taken when writing specification text that writes into a buffer source type instance, as the underlying data can easily be changed by the script author or other APIs at unpredictable times. This is especially true if a SharedArrayBuffer object is involved. 
</p>

<p>
`ArrayBuffer$T が共有されない事例では、
アリなら，次の~patternがより推奨される
⇒
最初に`配列~bufferを転送する$ことにより，
書込nが他による改変と重合しなくなることを確保した上で、
結果の新たな `ArrayBuffer$T ~instanceを必要に応じて作者~codeに与える。
◎
For the non-shared cases, a more recommended pattern is to transfer the ArrayBuffer first if possible, to ensure the writes cannot overlap with other modifications, and then give the new ArrayBuffer instance to author code as necessary.＼
</p>

<p>
代替として，次を行うこともできる
⇒＃
まず，~buffer~sourceに`保持された~byte列の複製を取得する$；
その~byte列を改変してから，`~buffer~sourceを作成する$；
結果の新たな`~buffer型$の~obj【！ ArrayBuffer or ArrayBufferView】を作者~codeに与える。
◎
Alternately, you can get a copy of the bytes held by the buffer source, modify those bytes, and then use them to create a new ArrayBuffer or ArrayBufferView to give back to author code.
</p>
</div>

<div class="algo">
<p>
`配列~bufferを切離す@
~algoは、
所与の
( `ArrayBuffer$T %配列~buffer )
に対し：
◎
To detach an ArrayBuffer arrayBuffer:
</p>
<ol>
	<li>
%~js配列~buffer ~LET `~JS値に変換する$( %配列~buffer )
◎
Let jsArrayBuffer be the result of converting arrayBuffer to a JavaScript value.
</li>
	<li>
~ABRUPT
`DetachArrayBuffer$A( %~js配列~buffer )
◎
Perform ? DetachArrayBuffer(jsArrayBuffer).
</li>
</ol>

<p class="note" id="note-ArrayBuffer-detach-exceptions">注記：
これは、［
%~js配列~buffer は `ArrayBufferDetachKey^sl を有していて，
それは `undefined^jv 以外の値をとる場合
］に例外を投出することになる
— `WebAssembly.Memory＠https://webassembly.github.io/spec/js-api/#memory$M の `buffer＠https://webassembly.github.io/spec/js-api/#dom-memory-buffer$M 属性の値を伴う事例など
`WASM-JS-API-1$r 。
◎
This will throw an exception if jsArrayBuffer has an [[ArrayBufferDetachKey]] that is not undefined, such as is the case with the value of WebAssembly.Memory’s buffer attribute. [WASM-JS-API-1]
</p>

<p class="note">注記：
すでに`切離されて$いる~bufferを切離しても，何もしない。
◎
Detaching a buffer that is already detached is a no-op.
</p>
</div>

<div class="algo">
<p>
所与の
`~buffer~source型$の~instance %~buffer~source が
`切離されて@
［
いる／いない
］とは、
次の手続きが［
~T ／ ~F
］を返すことをいう：
◎
A buffer source type instance bufferSource is detached if the following steps return true:
</p>
<ol>
	<li>
%~js配列~buffer ~LET `~JS値に変換する$( %~buffer~source )
◎
Let jsArrayBuffer be the result of converting bufferSource to a JavaScript value.
</li>
	<li>
~IF［
%~js配列~buffer は `ViewedArrayBuffer^sl 内部~slotを有する
］
⇒
%~js配列~buffer ~SET %~js配列~buffer.`ViewedArrayBuffer^sl
◎
If jsArrayBuffer has a [[ViewedArrayBuffer]] internal slot, then set jsArrayBuffer to jsArrayBuffer.[[ViewedArrayBuffer]].
</li>
	<li>
~RET ~IS［
`IsDetachedBuffer$A( %~js配列~buffer ) ~EQ `true^jv
］
◎
Return IsDetachedBuffer(jsArrayBuffer).
</li>
</ol>
</div>

<div class="algo">
<p>
所与の
`~buffer~source型$の~instance %~buffer~source が
`転送-可能@BS
［
である／でない
］とは、
次の手続きが［
~T ／ ~F
］を返すことをいう：
◎
A buffer source type instance bufferSource is transferable if the following steps return true:
</p>
<ol>
	<li>
%~js配列~buffer ~LET `~JS値に変換する$( %~buffer~source )
◎
Let jsArrayBuffer be the result of converting bufferSource to a JavaScript value.
</li>
	<li>
~IF［
%~js配列~buffer は `ViewedArrayBuffer^sl 内部~slotを有する
］
⇒
%~js配列~buffer ~SET %~js配列~buffer.`ViewedArrayBuffer^sl
◎
If jsArrayBuffer has a [[ViewedArrayBuffer]] internal slot, then set jsArrayBuffer to jsArrayBuffer.[[ViewedArrayBuffer]].
</li>
	<li>
<p>
~RET ~IS［
~AND↓
］：
</p>
		<ul>
			<li>
`IsSharedArrayBuffer$A( %~js配列~buffer ) ~NEQ `true^jv
</li>
			<li>
`IsDetachedBuffer$A( %~js配列~buffer ) ~NEQ `true^jv
</li>
			<li>
%~js配列~buffer.`ArrayBufferDetachKey^sl ~EQ `undefined^jv
</li>
		</ul>
◎
If IsSharedArrayBuffer(jsArrayBuffer) is true, then return false.
◎
If IsDetachedBuffer(jsArrayBuffer) is true, then return false.
◎
If jsArrayBuffer.[[ArrayBufferDetachKey]] is not undefined, then return false.
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
`配列~bufferを転送する@
~algoは、
所与の
( `ArrayBuffer$T %配列~buffer, `~realm$ %宛先~realm ~DF ε )
に対し：
◎
To transfer an ArrayBuffer arrayBuffer, optionally given a realm targetRealm:
</p>
<ol>
	<li>
%~js配列~buffer ~LET `~JS値に変換する$( %配列~buffer )
◎
Let jsArrayBuffer be the result of converting arrayBuffer to a JavaScript value.
</li>
	<li>
~IF［
`IsDetachedBuffer$A( %~js配列~buffer ）~EQ ~F
］
⇒
`~THROW$ `TypeError$jt
◎
If IsDetachedBuffer(jsArrayBuffer) is false, then throw a TypeError.
</li>
	<li>
%配列~buffer~data ~LET 
%~js配列~buffer.`ArrayBufferData^sl
◎
Let arrayBufferData be jsArrayBuffer.[[ArrayBufferData]].
</li>
	<li>
%配列~buffer~byte長さ ~LET 
%~js配列~buffer.`ArrayBufferByteLength^sl
◎
Let arrayBufferByteLength be jsArrayBuffer.[[ArrayBufferByteLength]].
</li>
	<li>
~ABRUPT `DetachArrayBuffer$A( %~js配列~buffer )
◎
Perform ? DetachArrayBuffer(jsArrayBuffer).
</li>
	<li>
~IF［
%宛先~realm ~EQ ε
］
⇒
%宛先~realm ~LET `現在の~realm$
◎
If targetRealm is not given, let targetRealm be the current realm.
</li>
	<li>
%~js転送-済み ~LET
~ABRUPT `AllocateArrayBuffer$A( %宛先~realm.`ArrayBuffer$jIsl, 0 )
◎
Let jsTransferred be ? AllocateArrayBuffer(targetRealm.[[Intrinsics]].[[%ArrayBuffer%]], 0).
</li>
	<li>
%~js転送-済み.`ArrayBufferData^sl ~SET %配列~buffer~data
◎
Set jsTransferred.[[ArrayBufferData]] to arrayBufferData.
</li>
	<li>
%~js転送-済み.`ArrayBufferByteLength^sl ~SET %配列~buffer~byte長さ
◎
Set jsTransferred.[[ArrayBufferByteLength]] to arrayBufferByteLength.
</li>
	<li>
~RET `~IDL値に変換する$( %~js転送-済み, `ArrayBuffer$T )
◎
Return the result of converting jsTransferred to an IDL value of type ArrayBuffer.
</li>
</ol>

<div class="note" id="note-ArrayBuffer-transfer-exceptions">
<p>注記：
これは、
次に挙げる状況下で，例外を投出することになる：
◎
This will throw an exception under any of the following circumstances:
</p>
<ul>
	<li>
`配列~bufferを切離す$ための`~algoの定義にて説明した理由＠#note-ArrayBuffer-detach-exceptions$から，
%配列~buffer を`切離せな＠#buffersource-detached$かった。
◎
arrayBuffer cannot be detached, for the reasons explained in that algorithm’s definition;
</li>
	<li>
%配列~buffer は、
すでに`切離されて$いた。
◎
arrayBuffer is already detached;
</li>
	<li>
%~realm 内に割振るための~memoryが足りなかった。
この事例は、
一般に，［
%~realm と %配列~buffer が割振られた~realmが異なる`~agent~cluster$内にある場合
］に限られる。
それらの~realmが同じ`~agent~cluster$内にある場合、
実装は，［
同じ観測-可能な結果を取得するために~backしている~pointer
］を［
処理能を高める, かつ割振nを伴わない
］よう変更することになるだけなので。
◎
Sufficient memory cannot be allocated in realm. Generally this will only be the case if realm is in a different agent cluster than the one in which arrayBuffer was allocated. If they are in the same agent cluster, then implementations will just change the backing pointers to get the same observable results with better performance and no allocations.
</li>
</ul>
</div>
</div>

			</section>
			<section id="js-frozen-array">
<h4 title="Frozen arrays — FrozenArray&lt;T&gt;">3.2.27. 凍結d配列 — ~FrozenArray_T</h4>

<p>
`凍結d配列~型$の値は、
~~凍結された（ `frozen^en ）~JS `Array^jt ~obj参照により表現される。
◎
Values of frozen array types are represented by frozen JavaScript Array object references.
</p>

<div class="algo">
<p>
~JS値 %V を `~FrozenArray_T$ 型の`~IDL値に変換する$ための~algoは：
◎
A JavaScript value V is converted to an IDL FrozenArray&lt;T&gt; value by running the following algorithm:
</p>
<ol>
	<li>
%値~群 ~LET `~IDL値に変換する$( %V, ~sequence_T )
◎
Let values be the result of converting V to IDL type sequence&lt;T&gt;.
</li>
	<li>
~RET `凍結d配列を作成する$( %値~群 )
◎
Return the result of creating a frozen array from values.
</li>
</ol>
</div>

<div class="algo">
<p>
`凍結d配列を作成する@
~algoは、
所与の
( 型 %T の値たちが成す連列 %S )
に対し：
◎
To create a frozen array from a sequence of values of type T, follow these steps:
</p>
<ol>
	<li>
%配列 ~LET `~JS値に変換する$( %S )
◎
Let array be the result of converting the sequence of values of type T to a JavaScript value.
</li>
	<li>
~NOABRUPT `SetIntegrityLevel$A( %配列, `frozen^l )
◎
Perform ! SetIntegrityLevel(array, "frozen").
</li>
	<li>
~RET %配列
◎
Return array.
</li>
</ol>
</div>

<p class="algo">
~IDL `~FrozenArray_T$ 値 %V を`~JS値に変換する$ときは
⇒
~RET %V が表現するものと同じ~objへの参照を表現する `Object^jt 値
◎
The result of converting an IDL FrozenArray&lt;T&gt; value to a JavaScript value is the Object value that represents a reference to the same object that the IDL FrozenArray&lt;T&gt; represents.
</p>

				<section id="create-frozen-array-from-iterable">
<h5 title="Creating a frozen array from an iterable">3.2.27.1. 可反復から凍結d配列を作成する</h5>

<div class="algo">
<p>
可反復から型 `~FrozenArray_T$ の~IDL値を作成する
~algoは、
所与の
( 型 %T, 可反復 %可反復, 反復子~取得子 %~method )
に対し：
◎
To create an IDL value of type FrozenArray&lt;T&gt; given an iterable iterable and an iterator getter method, perform the following steps:
</p>
<ol>
	<li>
%値~群 ~LET `可反復から連列を作成する$( %T, %可反復, %~method )
◎
Let values be the result of creating a sequence of type sequence&lt;T&gt; from iterable and method.
</li>
	<li>
~RET `凍結d配列を作成する$( %値~群 )
◎
Return the result of creating a frozen array from values.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="js-observable-array">
<h4 title="Observable arrays — ObservableArray&lt;T&gt;">3.2.28. 観測-可能な配列 — ~ObservableArray_T</h4>

<p>
`観測-可能な配列~型$の値は、
`観測-可能な配列~exotic~obj$により表現される。
◎
Values of observable array types are represented by observable array exotic objects.
</p>

<p>
通例的な変換~algoに代えて、
`観測-可能な配列~型$には，［
`属性~取得子を作成する$／`属性~設定子を作成する$
］~algoを成す一部として特別な取扱いがある。
◎
Instead of the usual conversion algorithms, observable array types have special handling as part of the attribute getter and attribute setter algorithms.
</p>

<p>
~JS言語束縛における各［
`~platform~obj$を表現する~JS~obj
］は、
その各［
`観測-可能な配列~型$である`正則~属性$
］用に，それを
`~backしている観測-可能な配列~exotic~obj@
を有する。
これらは、
`属性を定義する$~algoの一部として，作成され, 管理される。
◎
In the JavaScript binding, JavaScript objects that represent platform objects have a backing observable array exotic object for each regular attribute of an observable array type. These are created and managed as part of the define the attributes algorithm.
</p>

<div class="algo">
<p>
~JS言語束縛における，観測-可能な配列~属性を`~backしている~list$は、
所与の
( `~platform~obj$ %~obj, 属性 %属性 )
に対し，次の~algoが返す`~list$になる：
◎
The backing list for an observable array attribute in the JavaScript binding, given a platform object obj and an attribute attribute, is the list returned by the following algorithm:
</p>
<ol>
	<li>
~Assert：
%~obj は`正則~属性$ %属性 を伴う`~ifc$を`実装-$する
◎
Assert: obj implements an interface with the regular attribute attribute.
</li>
	<li>
%観測-可能な配列 ~LET %~obj の
%属性 を`~backしている観測-可能な配列~exotic~obj$
◎
Let oa be obj’s backing observable array exotic object for attribute.
</li>
	<li>
~RET %観測-可能な配列.`ProxyHandler^sl.`BackingList^sl
◎
Return oa.[[ProxyHandler]].[[BackingList]].
</li>
</ol>
</div>

			</section>
		</section>
		<section id="js-extended-attributes">
<h3 title="Extended attributes">3.3. 拡張d属性</h3>

<p>
この節では、
`拡張d属性$のうち，その有無が~JS言語束縛に影響するものを定義する。
◎
This section defines a number of extended attributes whose presence affects the JavaScript binding.
</p>

			<section id="AllowResizable">
<h4 data-dfn-type="extended-attribute" data-export="" title="[AllowResizable]">3.3.1. `AllowResizable^x</h4>

<p>
`~buffer型$に`AllowResizable$x `拡張d属性$が現れた場合、
次を許容する新たな~IDL型を作成する
⇒
対応する~JS［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt
］~objは、
~resize可能になる。
◎
If the [AllowResizable] extended attribute appears on a buffer type, it creates a new IDL type that allows for the respective corresponding JavaScript ArrayBuffer or SharedArrayBuffer object to be resizable.
</p>

<p>
`~buffer~view型$に `AllowResizable$x `拡張d属性$が現れた場合：
◎
↓</p>
<ul>
	<li>
次を許容する新たな~IDL型を作成する
⇒
当の型の値を~backしている~JS `ArrayBuffer$jt ~objは、
~resize可能になる（長さ固定のみならず）。
◎
If the [AllowResizable] extended attribute appears on one of the buffer view types and the [AllowShared] extended attribute does not, it creates a new IDL type that allows the buffer view type to be backed by a JavaScript ArrayBuffer that is resizable, instead of only by a fixed-length ArrayBuffer.
</li>
	<li>
`AllowShared$x `拡張d属性$も現れた場合、
作成される~IDL型には，次が許容される
⇒
当の型の値を ある~resize可能†な~JS `SharedArrayBuffer$jt により~backする
（ `ArrayBuffer$jt ~objに加えて）。
◎
If the [AllowResizable] extended attribute and the [AllowShared] extended attribute both appear on one of the buffer view types, it creates a new IDL type that allows the buffer view type to be additionally backed by a JavaScript SharedArrayBuffer that is growable.
</li>
</ul>

<p class="trans-note">【†
原文では，
`SharedArrayBuffer^jt 用には
“~resize可能（ `resizable^en ）” に代えて “`growable^en” という語が利用されているが、
この仕様からは，どちらも［
`IsResizableArrayBuffer$A( 当の~backしている~obj ) ~EQ ~T
］を満たすことを意味するとしか解釈しようがないので、
同義と見受けられる。
しかしながら、
意味論上の違いはあるのかもしれない（ “~sizeを減らせない” など）。
】</p>

<p>
`AllowResizable$x 拡張d属性は、
`引数をとらない$ことが要求される。
◎
The [AllowResizable] extended attribute must take no arguments.
</p>

<p>
`~buffer~source型$でない型に `AllowResizable$x `拡張d属性が結付けられ$てはナラナイ。
◎
A type that is not a buffer source type must not be associated with the [AllowResizable] extended attribute.
</p>

<p>
`AllowResizable$x の利用に課される特有な要件については、
`~buffer~source型＠#js-buffer-source-types§の［
~JS値から~IDL`~buffer~source型$へ変換する規則
］を見よ。
◎
See the rules for converting JavaScript values to IDL buffer source types in § 3.2.26 Buffer source types for the specific requirements that the use of [AllowResizable] entails.
</p>

<p>
`AllowResizable$x, `AllowShared$x の用法~例は、
いずれも
`AllowShared§x における`例＠#example-allowresizable-allowshared$を見よ。
◎
See the example in § 3.3.2 [AllowShared] for example usage of both [AllowResizable] and [AllowShared].
</p>

			</section>
			<section id="AllowShared">
<h4>3.3.2. `AllowShared^x</h4>

<p>
`AllowShared$x `拡張d属性$が`~buffer~view型$に現れた場合、
次を許容する新たな~IDL型を作成する
⇒
当の~objを
— `ArrayBuffer$T のみならず —
`SharedArrayBuffer$T により~backする
◎
If the [AllowShared] extended attribute appears on one of the buffer view types, it creates a new IDL type that allows the object to be backed by an SharedArrayBuffer instead of only by an ArrayBuffer.
</p>

<p>
`AllowShared$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [AllowShared] extended attribute must take no arguments.
</li>
	<li>
`~buffer~view型$でない型には，この`拡張d属性が結付けられ$てはナラナイ。
◎
A type that is not a buffer view type must not be associated with the [AllowShared] extended attribute.
</li>
</ul>

<p>
`AllowShared$x の利用に課される特有な要件については、
`~buffer~source型＠#js-buffer-source-types§内の［
~JS値から~IDL`~buffer~view型$へ変換する規則
］を見よ。
◎
See the rules for converting JavaScript values to IDL buffer view types in § 3.2.26 Buffer source types for the specific requirements that the use of [AllowShared] entails.
</p>

<div class="example" id="example-allowresizable-allowshared">
<p>
次の`~IDL片$は、［
`AllowResizable$x, `AllowShared$x
］`拡張d属性$にアリな組合nをデモる：
◎
The following IDL fragment demonstrates the possible combinations of the [AllowResizable] and [AllowShared] extended attribute:
</p>

<pre class="webidl">
[Exposed=Window]
interface ExampleBufferFeature {
  undefined writeInto(ArrayBufferView %dest);
  undefined writeIntoResizable([AllowResizable] ArrayBufferView %dest);
  undefined writeIntoShared([AllowShared] ArrayBufferView %dest);
  undefined writeIntoSharedResizable([AllowResizable, AllowShared] ArrayBufferView %dest);
};
</pre>

<p>
この定義の下では：
◎
With this definition,
</p>
<ul>
	<li>
`writeInto^M の~callは、
`~buffer~view型$のうち［
~resize可能な `ArrayBuffer$jt【！$T 以下同様】 ~instance／
`SharedArrayBuffer$jt ~instance
］により~backされるものを受容しない
— すなわち， `TypeError$jE 例外を投出することになる（以下同様）。
◎
A call to writeInto with any buffer view type backed by either a resizable ArrayBuffer instance or a SharedArrayBuffer instance, will throw a TypeError exception.
</li>
	<li>
`writeIntoResizable^M の~callは、
`~buffer~view型$のうち［
`SharedArrayBuffer$jt ~instanceにより~backされるもの
］を受容しない。
◎
A call to writeIntoResizable with any buffer view type backed by a SharedArrayBuffer instance, will throw a TypeError exception.
</li>
	<li>
`writeIntoShared^M の~callは、
`~buffer~view型$のうち［
~resize可能な［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt 
］の~instanceにより~backされるもの
］を受容しない。
◎
A call to writeIntoShared with any buffer view type backed by a resizable ArrayBuffer instance or a growable SharedArrayBuffer instance, will throw a TypeError exception.
</li>
	<li>
`writeIntoSharedResizable^M の~callは、
`~buffer~view型$のうち［［
`ArrayBuffer$jt ／ `SharedArrayBuffer$jt
］の~instanceにより~backされるもの
］を受容する。
◎
A call to writeIntoSharedResizable will accept any buffer view type backed by a ArrayBuffer instance or a SharedArrayBuffer instance.
</li>
</ul>
</div>

			</section>
			<section id="Clamp">
<h4>3.3.3. `Clamp^x</h4>

<p>
`Clamp$x `拡張d属性$が`整数~型$に現れた場合、
次に従ってふるまう，新たな型を作成する
⇒
~JS `Number^jt 値がこの~IDL型へ変換される際には、
範囲~外の値に対しては，範囲~内の最も近い妥当な値に切詰める
— modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）は利用せずに。
◎
If the [Clamp] extended attribute appears on one of the integer types, it creates a new IDL type such that that when a JavaScript Number is converted to the IDL type, out-of-range values will be clamped to the range of valid values, rather than using the operators that use a modulo operation (ToInt32, ToUint32, etc.).
</p>

<p>
`Clamp$x 拡張d属性は、
`引数をとらない$ことが要求される。
◎
The [Clamp] extended attribute must take no arguments.
</p>

<div class="p">
<p>
型 %T に `Clamp$x `拡張d属性が結付けられ$るときは、
~AND↓ が満たされなければナラナイ：
</p>
<ul>
	<li>
%T は、
`読専$な属性に現れていない。
</li>
	<li>
%T には `EnforceRange$x `拡張d属性が結付けられ$てはいない。
</li>
	<li>
%T は`整数~型$である。
</li>
</ul>
◎
A type annotated with the [Clamp] extended attribute must not appear in a read only attribute. A type must not be associated with both the [Clamp] and [EnforceRange] extended attributes. A type that is not an integer type must not be associated with the [Clamp] extended attribute.
</div>

<p>
`Clamp$x の利用に課される特有な要件については、
`整数~型＠#js-integer-types§の［
~JS値から各種~IDL整数~型へ変換する規則
］を見よ。
◎
See the rules for converting JavaScript values to the various IDL integer types in § 3.2.4 Integer types for the specific requirements that the use of [Clamp] entails.
</p>

<div class="example">
<p>
次の`~IDL片$では、
2 個の`演算$が宣言され，どちらも 3 個の `octet$T 引数をとる。
一方には 3 個すべての引数に `Clamp$x `拡張d属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [Clamp] extended attribute on all three arguments, while the other does not:
</p>

<pre class="webidl">
[Exposed=Window]
interface GraphicsContext {
  undefined setColor(octet %red, octet %green, octet %blue);
  undefined setColorClamped([Clamp] octet %red, [Clamp] octet %green, [Clamp] octet %blue);
};
</pre>

<p>
`setColorClamped^M の~callに渡された，
`octet$T の範囲~外の `Number^jt 値は、
範囲 [0, 255] に切詰められる。
◎
A call to setColorClamped with Number values that are out of range for an octet are clamped to the range [0, 255].
</p>

<pre class="lang-js">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する：
◎
Get an instance of GraphicsContext.
</span> */
var %context = getGraphicsContext();

/* <span class="comment">
非 `Clamp^x 版の~callは、
数量-値を~octetに型強制する ToUint8 を利用する：
◎
Calling the non-[Clamp] version uses ToUint8 to coerce the Numbers to octets.
</span> */
/* <span class="comment">
次は `setColor(255, 255, 1)^c の~callと等価：
◎
This is equivalent to calling setColor(255, 255, 1).
</span> */
%context.setColor(-1, 255, 257);

/* <span class="comment">
範囲~外の値を渡して `setColorClamped^M を~callする：
◎
Call setColorClamped with some out of range values.
</span> */
/* <span class="comment">
次は `setColorClamped(0, 255, 255)^c の~callと等価：
◎
This is equivalent to calling setColorClamped(0, 255, 255).
</span> */
%context.setColorClamped(-1, 255, 257);
</pre>
</div>

			</section>
			<section id="CrossOriginIsolated">
<h4>3.3.4. `CrossOriginIsolated^x</h4>

<p>
`CrossOriginIsolated$x `拡張d属性$が次に挙げる構成子に現れたときは
⇒＃
`~ifc$,
`部分的な~ifc$,
`~ifc~mixin$,
`部分的な~ifc~mixin$,
`~callback~ifc$,
`~ns$,
`部分的な~ns$,
`~ifc~mb$,
`~ifc~mixin~mb$,
`~ns~mb$
◎終
次を指示する
⇒
当の構成子が`公開され$るのは，次を満たす環境の中に限られる
⇒
その`非同一-生成元~能力は隔離されるか？$enV ~EQ ~T
◎
If the [CrossOriginIsolated] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, callback interface, namespace, partial namespace, interface member, interface mixin member, or namespace member, it indicates that the construct is exposed only within an environment whose cross-origin isolated capability is true.＼
</p>

<p>
`CrossOriginIsolated$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
上に挙げたもの以外の構成子に利用してはナラナイ。
◎
The [CrossOriginIsolated] extended attribute must not be used on any other construct.
</li>
	<li>
`引数をとらない$ことが要求される。
◎
The [CrossOriginIsolated] extended attribute must take no arguments.
</li>
	<li>
`多重定義$された ある`演算$に現れるならば、
その多重定義を成す他のすべての演算にも現れなければナラナイ。
◎
If [CrossOriginIsolated] appears on an overloaded operation, then it must appear on all overloads.
</li>
	<li>
<p>
次の各項に対し，そこに挙げる両者に指定してはナラナイ：
◎
The [CrossOriginIsolated] extended attribute must not be specified both on
</p>
		<ul>
			<li>
`~ifc~mb$, それを宣言している［
`~ifc$／`部分的な~ifc$
］
◎
an interface member and its interface or partial interface;
</li>
			<li>
`~ifc~mixin~mb$, それを宣言している［
`~ifc~mixin$／`部分的な~ifc~mixin$
］
◎
an interface mixin member and its interface mixin or partial interface mixin;
</li>
			<li>
`~ns~mb$, それを宣言している［
`~ns$／`部分的な~ns$
］
◎
a namespace member and its namespace or partial namespace.
</li>
		</ul>

<p class="note">注記：
そのわけは、
ある定義に `CrossOriginIsolated$x `拡張d属性$が注釈されている下で，
それが包含している`~mb$に `CrossOriginIsolated$x `拡張d属性$を追加しても、
~mbの公開をさらに制約することはないからである。
◎
Note: This is because adding the [CrossOriginIsolated] extended attribute on a member when its containing definition is also annotated with the [CrossOriginIsolated] extended attribute does not further restrict the exposure of the member.
</p>
	</li>
</ul>

<p>
`CrossOriginIsolated$x `拡張d属性$を伴わない`~ifc$は、
`CrossOriginIsolated$x を指定する別の~ifcを`継承-$してはナラナイ。
◎
An interface without the [CrossOriginIsolated] extended attribute must not inherit from another interface that does specify [CrossOriginIsolated].
</p>

<div class="example">
<p>
次の`~IDL片$が定義する~ifcには、
3 個の~mbがある
— うち 1 個は どの文脈からも実行-可能な`演算$であり，
他は非同一-生成元~隔離-済みな文脈に限り実行-可能になる：
◎
The following IDL fragment defines an interface with one operation that is executable from all contexts, and two which are executable only from cross-origin isolated contexts.
</p>

<pre class="lang-js">
[Exposed=Window]
interface ExampleFeature {
  /* <span class="comment">
次の演算の~callはどの文脈~下でも成功する：
◎
This call will succeed in all contexts.
</span> */
  Promise &lt;Result&gt; calculateNotSoSecretResult();

  /* <span class="comment">
次の演算は、
隔離-済みでない文脈には公開されない
— `ExampleFeature.prototype^c 上に `calculateSecretResult^jp ~propは無い：
◎
This operation will not be exposed to a non-isolated context. In such a context, there will be no "calculateSecretResult" property on ExampleFeature.prototype.
</span> */
  // 
  [CrossOriginIsolated] Promise&lt;Result&gt; calculateSecretResult();

  /* <span class="comment">
次の属性にも同じことが言え、
隔離-済みでない文脈には公開されない
— `ExampleFeature.prototype^c 上に `secretBoolean^jp ~propは無い：
◎
The same applies here: the attribute will not be exposed to a non-isolated context, and in such a context there will be no "secretBoolean" property on ExampleFeature.prototype.
</span> */

  [CrossOriginIsolated] readonly attribute boolean secretBoolean;
};

/* <span class="comment">
`HighResolutionTimer^T は、
隔離-済みでない文脈にも その~mbにも公開されない
— `Window^T 上に `HighResolutionTimer^jp ~propは無い：
◎
HighResolutionTimer will not be exposed in a non-isolated context, nor will its members. In such a context, there will be no "HighResolutionTimer" property on Window.
</span> */
[Exposed=Window, CrossOriginIsolated]
interface HighResolutionTimer {
  DOMHighResTimeStamp getHighResolutionTime();
};

/* <span class="comment">
次に定義される~ifc~mixin~mbは、
それを内包する~ifcが隔離-済みかどうかに関わらず，隔離-済みでない文脈には決して公開されない
— すなわち、
`ExampleFeature.prototype^c 上に `snap^jp ~propは無い：
◎
The interface mixin members defined below will never be exposed in a non-isolated context, regardless of whether the interface that includes them is. That is, in non-isolated context, there will be no "snap" property on ExampleFeature.prototype.
</span> */

[CrossOriginIsolated]
interface mixin Snapshotable {
  Promise&lt;boolean&gt; snap();
};
ExampleFeature includes Snapshotable;

/* <span class="comment">
他方，次の各 ~ifc~mixin~mbは、
`CrossOriginIsolated$x 拡張d属性を伴わない~host~ifcに内包された場合には，
隔離-済みでない文脈にも公開されることになる
— すなわち、
そのような文脈においても，
`ExampleFeature.prototype^c 上に `log^jp ~propは在る：
◎
On the other hand, the following interface mixin members will be exposed to a non-isolated context when included by a host interface that doesn’t have the [CrossOriginIsolated] extended attribute. That is, in a non-isolated context, there will be a "log" property on ExampleFeature.prototype.
</span> */
interface mixin Loggable {
  Promise&lt;boolean&gt; log();
};
ExampleFeature includes Loggable;
</pre>
</div>

			</section>
			<section id="Default">
<h4>3.3.5. `Default^x</h4>

<p>
`Default$x `拡張d属性$が`正則~演算$に現れた場合、
次を指示する
⇒
当の演算が呼出されたときは、
適切な`既定の~method手続き$を遂げるモノトスル
◎
If the [Default] extended attribute appears on a regular operation, then it indicates that the appropriate default method steps must be carried out when the operation is invoked.
</p>

<p>
`Default$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Default] extended attribute must take no arguments.
</li>
	<li>
次を満たすもの以外に利用してはナラナイ
⇒
`正則~演算$であって，`既定の~method手続きを有する$
◎
The [Default] extended attribute must not be used on anything other than a regular operation that has default method steps defined.
</li>
</ul>

<div class="example">
<p>
例として、
`Default$x 拡張d属性は，~toJSON`正則~演算$の利用に相応しくなる：
◎
As an example, the [Default] extended attribute is suitable for use on toJSON regular operations:
</p>

<pre class="webidl">
[Exposed=Window]
interface Animal {
  attribute DOMString name;
  attribute unsigned short age;
  [Default] object toJSON();
};

[Exposed=Window]
interface Human : Animal {
  attribute Dog? pet;
  [Default] object toJSON();
};

[Exposed=Window]
interface Dog : Animal {
  attribute DOMString? breed;
};
</pre>

<p>
~JS言語束縛においては、
`toJSON()^M ~methodは，
`Animal^T, `Human^T
~obj上にも, 継承を介して `Dog^T ~obj上にも存在することになる：
◎
In the JavaScript language binding, there would exist a toJSON() method on Animal, Human, and (via inheritance) Dog objects:
</p>

<pre class="lang-js">
/* <span class="comment">
`Human^T の~instanceを取得する：
◎
Get an instance of Human.
</span> */
var %alice = getHuman();

/* <span class="comment">
次の様な~objに評価される（この時点で， `Dog^T の~instanceは依然として `pet^l を保持することに注意）：
◎
Evaluates to an object like this (notice how "pet" still holds an instance of Dog at this point):
</span>
   {
     name: "Alice",
     age: 59,
     pet: Dog
   }
*/
%alice.toJSON();

/* <span class="comment">
次の様な~objに評価される
（ `Dog^T ~ifcは，既定の~toJSON手続きを利用しないので、
`breed^l は無いことに注意）：
◎
Evaluates to an object like this (notice how "breed" is absent, as the Dog interface doesn’t use the default toJSON steps):
</span>
   {
     name: "Tramp",
     age: 6
   }
*/
%alice.pet.toJSON();

/* <span class="comment">
次の様な文字列に評価される：
◎
Evaluates to a string like this:
</span>
   '{"name":"Alice","age":59,"pet":{"name":"Tramp","age":6}}'
*/
JSON.stringify(%alice);
</pre>
</div>

			</section>
			<section id="EnforceRange">
<h4>3.3.6. `EnforceRange^x</h4>

<p>
`EnforceRange$x `拡張d属性$が`整数~型$に現れた場合、
次に従ってふるまう，新たな型を作成する
⇒
~JS `Number^jt 値をこの~IDL型へ変換する際には、
0 側に丸めた結果が範囲~外になる値に対しては，例外を投出する
— modulo 演算を利用する演算子（ `ToInt32$A, `ToUint32$A, 等々）は利用せずに。
◎
If the [EnforceRange] extended attribute appears on one of the integer types, it creates a new IDL type such that that when a JavaScript Number is converted to the IDL type, out-of-range values will cause an exception to be thrown, rather than being converted to a valid value using using the operators that use a modulo operation (ToInt32, ToUint32, etc.). The Number will be rounded toward zero before being checked against its range.
</p>

<p>
`EnforceRange$x 拡張d属性は、
`引数をとらない$ことが要求される。
◎
The [EnforceRange] extended attribute must take no arguments.
</p>

<div class="p">
<p>
型 %T に `EnforceRange$x `拡張d属性が結付けられ$るときは、
~AND↓ が満たされなければナラナイ：
</p>
<ul>
	<li>
%T は、
`読専$な属性に現れていない。
</li>
	<li>
%T には `Clamp$x `拡張d属性が結付けられ$ていない。
</li>
	<li>
%T は`整数~型$である。
</li>
</ul>
◎
A type annotated with the [EnforceRange] extended attribute must not appear in a read only attribute. A type must not be associated with both the [Clamp] and [EnforceRange] extended attributes. A type that is not an integer type must not be associated with the [EnforceRange] extended attribute.
</div>

<p>
`EnforceRange$x の利用に課される特有な要件については、
`~JS型との対応付け＠#js-type-mapping§の［
~JS値から各種~IDL整数~型へ変換する規則
］を見よ。
◎
See the rules for converting JavaScript values to the various IDL integer types in § 3.2 JavaScript type mapping for the specific requirements that the use of [EnforceRange] entails.
</p>

<div class="example">
<p>
次の`~IDL片$では、
2 個の`演算$が宣言され，どちらも 3 個の `octet$T 引数をとる。
一方には 3 個すべての引数に `EnforceRange$x `拡張d属性$が利用され，他方はそうでない：
◎
In the following IDL fragment, two operations are declared that take three octet arguments; one uses the [EnforceRange] extended attribute on all three arguments, while the other does not:
</p>

<pre class="webidl">
[Exposed=Window]
interface GraphicsContext {
  undefined setColor(octet %red, octet %green, octet %blue);
  undefined setColorEnforcedRange([EnforceRange] octet %red, [EnforceRange] octet %green, [EnforceRange] octet %blue);
};
</pre>

<p>
この~IDLの~JS実装においては、
`octet$T の範囲~外の `Number^jt 値を渡して
`setColorEnforcedRange^M を~callした場合，例外が投出される結果になる。
◎
In a JavaScript implementation of the IDL, a call to setColorEnforcedRange with Number values that are out of range for an octet will result in an exception being thrown.
</p>

<pre class="lang-js">
/* <span class="comment">
`GraphicsContext^T の~instanceを取得する：
◎
Get an instance of GraphicsContext.
</span> */
var %context = getGraphicsContext();

/* <span class="comment">
非 `EnforceRange^x 版の~callは、
数量-値を~octetに型強制する ToUint8 を利用する。
次は、
`setColor(255, 255, 1)^c
の~callと等価になる：
◎
Calling the non-[EnforceRange] version uses ToUint8 to coerce the Numbers to octets. This is equivalent to calling setColor(255, 255, 1).
</span> */
%context.setColor(-1, 255, 257);

/* <span class="comment">
数量-値は `setColorEnforcedRange^M が~callされる際に 0 側に丸められる。
次は、
`setColor(0, 255, 255)^c
の~callと等価になる：
◎
When setColorEnforcedRange is called, Numbers are rounded towards zero. This is equivalent to calling setColor(0, 255, 255).
</span> */
%context.setColorEnforcedRange(-0.9, 255, 255.2);

/* <span class="comment">
次は、
 `TypeError^jE を投出させる
— 丸められた後でも， 1 個目, 3 個目の引数は範囲~外になるので：
◎
The following will cause a TypeError to be thrown, since even after rounding the first and third argument values are out of range.
</span> */
%context.setColorEnforcedRange(-1, 255, 256);
</pre>
</div>

			</section>
			<section id="Exposed">
<h4>3.3.7. `Exposed^x</h4>

<p>
`Exposed$x `拡張d属性$が次に挙げる構成子に現れたときは
⇒＃
`~ifc$ ／
`部分的な~ifc$ ／
`~ifc~mixin$ ／
`~callback~ifc$ ／
`部分的な~ifc~mixin$ ／
`~ns$ ／
`部分的な~ns$ ／
個々の`~ifc~mb$ ／
個々の`~ifc~mixin~mb$ ／
個々の`~ns~mb$
◎終
次を指示する
⇒
当の構成子は、
拡張d属性の引数により指定される，すべての大域~ifc【 `Global$x 拡張d属性が注釈された~ifc】上に公開される
◎
When the [Exposed] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, callback interface, namespace, partial namespace, or an individual interface member, interface mixin member, or namespace member, it indicates that the construct is exposed on that particular set of global interfaces.
</p>

<p>
`Exposed$x `拡張d属性$には、［
`識別子を引数にとる$／
`識別子~listを引数にとる$／
`~wildcardを引数にとる$
］ことが要求される。
挙げられた各~識別子は、
引数~内で一意, かつ`大域~名$でなければナラナイ。
◎
The [Exposed] extended attribute must either take an identifier, take an identifier list or take a wildcard. Each of the identifiers mentioned must be a global name of some interface and be unique.
</p>

<p>
所与の構成子 %C の
`自前の公開~集合@
は、［
識別子の`集合$／特別な値 `*^c
］である
— それは、
%C 上の `Exposed$x `拡張d属性$の形に応じて，次に従って定義される：
◎
The own exposure set is either a set of identifiers or the special value *, defined as follows:
</p>
<ul class="switch">
	<li>
`識別子を引数にとる$
⇒
« 引数に与えられた識別子 »
◎
If the [Exposed] extended attribute takes an identifier I
• The own exposure set is the set « I ».
</li>
	<li>
`識別子~listを引数にとる$
⇒
引数に与えられた識別子~群
◎
If the [Exposed] extended attribute takes an identifier list I
• The own exposure set is the set I.
</li>
	<li>
`~wildcardを引数にとる$
⇒
`*^c
【 “すべての大域~ifc” を表現する】
◎
If the [Exposed] extended attribute takes a wildcard
• The own exposure set is *.
</li>
</ul>

<p class="trans-note">【
`集合$は，定義により有順序であるが、
`自前の公開~集合$における順序が有意になることは，ないであろう
（少なくとも，この仕様に限れば）。
】</p>

<p class="warning">【！class=advisement】
【！[Exposed=*]】
`~wildcardを引数にとる$のが適切になるのは、
当の~APIが有意な新たな能力
— 何らかの環境において［
制約される／不能化される
］かもしれない能力 —
を公開しないときに限られる。
そうでない場合、
明示的に大域~名を~listすることが選好される。
◎
[Exposed=*] is to be used with care. It is only appropriate when an API does not expose significant new capabilities. If the API might be restricted or disabled in some environments, it is preferred to list the globals explicitly.
</p>

<div class="algo">
<p>
所与の
( 構成子 %C, 何か %H ) の
`交差~公開~集合@
は、
次に従って定義される：
◎
The exposure set intersection of a construct C and interface-or-null H is defined as follows:
</p>
<ol>
	<li>
~Assert：
%C は次に挙げるいずれかである
⇒＃
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$ ／
`部分的な~ifc$ ／
`部分的な~ifc~mixin$ ／
`部分的な~ns$ ／
`~ifc~mixin$
◎
Assert: C is an interface member, interface mixin member, namespace member, partial interface, partial interface mixin, partial namespace, or interface mixin.
</li>
	<li>
~Assert：
%H は［
`~ifc$ ／ ~NULL
］である。
◎
Assert: H is an interface or null.
</li>
	<li>
~IF［
%H ~EQ ~NULL
］
⇒
~RET %C の`自前の公開~集合$
◎
If H is null, return C’s own exposure set.
</li>
	<li>
~IF［
%C の`自前の公開~集合$ ~EQ `*^c
］
⇒
~RET %H の`公開~集合$
◎
If C’s own exposure set is *, return H’s exposure set.
</li>
	<li>
~IF［
%H の`公開~集合$ ~EQ `*^c
］
⇒
~RET %C の`自前の公開~集合$
◎
If H’s exposure set is *, return C’s own exposure set.
</li>
	<li>
~RET `交差集合$( %C の`自前の公開~集合$, %H の`公開~集合$ )
◎
Return the intersection of C’s own exposure set and H’s exposure set.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の構成子 %C の
`公開~集合@
を取得するときは、
次の手続きを走らす：
◎
To get the exposure set of a construct C, run the following steps:
</p>
<ol>
	<li>
~Assert：
%C は次に挙げるいずれかである
⇒＃
`~ifc$ ／
`~callback~ifc$ ／
`~ns$ ／
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
◎
Assert: C is an interface, callback interface, namespace, interface member, interface mixin member, or namespace member.
</li>
	<li>
%H ~LET ［
%C は`~ifc~mixin~mb$であるならば %C の`~host~ifc$ ／
~ELSE_ ~NULL
］
◎
Let H be C’s host interface if C is an interface mixin member, or null otherwise.
</li>
	<li>
<p>
~IF［
%C は［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
］：
◎
If C is an interface member, interface mixin member, or namespace member, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張d属性$は指定されている
］
⇒
~RET ( %C, %H ) の`交差~公開~集合$
◎
If the [Exposed] extended attribute is specified on C, return the exposure set intersection of C and H.
</li>
			<li>
%C ~SET
%C を宣言している［
`~ifc$ ／
`部分的な~ifc$ ／
`~ifc~mixin$ ／
`部分的な~ifc~mixin$ ／
`~ns$ ／
`部分的な~ns$
］
◎
Set C to the interface, partial interface, interface mixin, partial interface mixin, namespace, or partial namespace C is declared on.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は［
`部分的な~ifc$ ／ `部分的な~ifc~mixin$ ／ `部分的な~ns$
］である
］：
◎
If C is a partial interface, partial interface mixin, or partial namespace, then:
</p>
		<ol>
			<li>
~IF［
%C 上に `Exposed$x `拡張d属性$は指定されている
］
⇒
~RET ( %C, %H ) の`交差~公開~集合$
◎
If the [Exposed] extended attribute is specified on C, return the exposure set intersection of C and H.
</li>
			<li>
%C ~SET %C の元の［
`~ifc$ ／ `~ifc~mixin$ ／ `~ns$
］定義
◎
Set C to the original interface, interface mixin, or namespace definition of C.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%C は`~ifc~mixin$である
］：
◎
If C is an interface mixin, then:
</p>
		<ol>
			<li>
~Assert：
%H ~NEQ ~NULL
◎
Assert: H is not null.
</li>
			<li>
~IF［
%C 上に `Exposed$x `拡張d属性$は指定されている
］
⇒
~RET ( %C, %H ) の`交差~公開~集合$
◎
If the [Exposed] extended attribute is specified on C, return the exposure set intersection of C and H.
</li>
			<li>
%C ~SET %H
◎
Set C to H.
</li>
		</ol>
	</li>
	<li>
~Assert：
%C は次に挙げるいずれかである
⇒＃
`~ifc$ ／
`~callback~ifc$ ／
`~ns$
◎
Assert: C is an interface, callback interface or namespace.
</li>
	<li>
~Assert：
%C 上に `Exposed$x `拡張d属性$は指定されている
◎
Assert: The [Exposed] extended attribute is specified on C.
</li>
	<li>
~RET %C の`自前の公開~集合$
◎
Return C’s own exposure set.
</li>
</ol>
</div>

<p>
`Exposed$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`多重定義$された ある`演算$に現れた場合、
その多重定義を成す他のすべての演算にも現れなければナラナイ。
◎
If [Exposed] appears on an overloaded operation, then it must appear identically on all overloads.
</li>
	<li>
<p>
次の両者に指定してはナラナイ
⇒
［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］, それを宣言している［
`部分的な~ifc$ ／ `部分的な~ifc~mixin$ ／ `部分的な~ns$
］定義
◎
The [Exposed] extended attribute must not be specified both on an interface member, interface mixin member, or namespace member, and on the partial interface, partial interface mixin, or partial namespace definition the member is declared on.
</p>

<p class="note">注記：
そのわけは、［
`部分的な~ifc$ ／ `部分的な~ifc~mixin$ ／ `部分的な~ns$
］上に `Exposed$x `拡張d属性$を追加することは，その各`~mb$を注釈することの略記だからである。
◎
Note: This is because adding an [Exposed] extended attribute on a partial interface, partial interface mixin, or partial namespace is shorthand for annotating each of its members.
</p>
	</li>
	<li>
［
`部分的な~ifc$ ／ `部分的な~ns$
］ %A に現れた場合、
%A の`自前の公開~集合$は， %A の元の［
`~ifc$ ／ `~ns$
］の`公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears on a partial interface or partial namespace, then the partial’s own exposure set must be a subset of the exposure set of the partial’s original interface or namespace.
</li>
	<li>
［
`~ifc$ ／ `~ns$
］ %A の［
`~ifc~mb$ ／ `~ns~mb$
］ %m に現れた場合、
%m の`公開~集合$は %A の`公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears on an interface or namespace member, then the member’s exposure set must be a subset of the exposure set of the interface or namespace it is a member of.
</li>
	<li>
［
`部分的な~ifc~mixin$ %A,
%A の元の`~ifc~mixin$ %B
］の両者に現れた場合、
%A の`自前の公開~集合$は %B の`自前の公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears both on a partial interface mixin and its original interface mixin, then the partial interface mixin’s own exposure set must be a subset of the interface mixin’s own exposure set.
</li>
	<li>
［
`~ifc~mixin$ %A,
%A の`~ifc~mixin~mb$ %m
］の両者に現れた場合、
%m の`自前の公開~集合$は
%A の`自前の公開~集合$の`下位集合$でなければナラナイ。
◎
If [Exposed] appears both on an interface mixin member and the interface mixin it is a member of, then the interface mixin members’s own exposure set must be a subset of the interface mixin’s own exposure set.
</li>
</ul>

<p>
%A が別の~ifc %B を`継承-$しているならば、
%A の`公開~集合$は %B の`公開~集合$の`下位集合$でなければナラナイ。
◎
If an interface X inherits from another interface Y then the exposure set of X must be a subset of the exposure set of Y.
</p>

<p class="note">注記：
`~ifc~mixin$ %M は，互いに異なる`~ifc$に`内包-$され得るので、
%M の`~ifc~mixin~mb$ %m の`公開~集合$は，
%M を`内包-$している`~ifc$
— すなわち， %m の`~host~ifc$ %I —
の関数になり、
%F を %I の`公開~集合$とするならば，次で与えられる
⇒＃
%m は `Exposed$x `拡張d属性$で注釈されているならば  `交差集合$( %m の`自前の公開~集合$, %F ) ／
~ELSE_ %M は `Exposed$x `拡張d属性$で注釈されているならば `交差集合$( %M の`自前の公開~集合$, %F ) ／
~ELSE_ %F
◎
Note: As an interface mixin can be included by different interfaces, the exposure set of its members is a function of the interface that includes them. If the interface mixin member, partial interface mixin, or interface mixin is annotated with an [Exposed] extended attribute, then the interface mixin member’s exposure set is the intersection of the relevant construct’s own exposure set with the host interface’s exposure set. Otherwise, it is the host interface’s exposure set.
</p>

<div class="algo">
<p>
所与の［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$ ／ `~mb$
］ %構成子 は、
次の手続きが ~T を返すならば，`~realm$ %~realm 内に
`公開されて@
いるとされる：
◎
An interface, callback interface, namespace, or member construct is exposed in a given realm realm if the following steps return true:
</p>
<ol>
	<li>
~IF［
%構成子 の`公開~集合$ ~NEQ `*^c
］~AND［
%~realm.`GlobalObject^sl は、
%構成子 の`公開~集合$を成す どの~ifcも実装していない
］
⇒
~RET ~F
◎
If construct’s exposure set is not *, and realm.[[GlobalObject]] does not implement an interface that is in construct’s exposure set, then return false.
</li>
	<li>
~IF［
%~realm の`設定群~obj$は`~secureな文脈$enVでない
］~AND［
%構成子 は `SecureContext$x 上で`条件付きで公開されて$いる
］
⇒
~RET ~F
◎
If realm’s settings object is not a secure context, and construct is conditionally exposed on [SecureContext], then return false.
</li>
	<li>
~IF［
%~realm の`設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV ~EQ ~F
］~AND［
%構成子 は `CrossOriginIsolated$x 上で`条件付きで公開されて$いる
］
⇒
~RET ~F
◎
If realm’s settings object’s cross-origin isolated capability is false, and construct is conditionally exposed on [CrossOriginIsolated], then return false.
</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の［
`~ifc$ ／ `~callback~ifc$ ／ `~ns$ ／ `~mb$
］ %構成子 は、
次の手続きが ~T を返すならば，所与の`拡張d属性$ %公開~条件 上で
`条件付きで公開されて@
いるとされる：
◎
An interface, callback interface, namespace, or member construct is conditionally exposed on a given extended attribute exposure condition if the following steps return true:
</p>
<ol>
	<li>
~Assert：
%構成子 は次に挙げるいずれかである
⇒＃
`~ifc$ ／
`~callback~ifc$ ／
`~ns$ ／
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
◎
Assert: construct is an interface, callback interface, namespace, interface member, interface mixin member, or namespace member.
</li>
	<li>
%H ~LET ［
%構成子 は`~ifc~mixin~mb$であるならば %構成子 の`~host~ifc$ ／
~ELSE_ ~NULL
］
◎
Let H be construct’s host interface if construct is an interface mixin member, or null otherwise.
</li>
	<li>
<p>
~IF［
%構成子 は［
`~ifc~mb$ ／ `~ifc~mixin~mb$ ／ `~ns~mb$
］である
］：
◎
If construct is an interface member, interface mixin member, or namespace member, then:
</p>
		<ol>
			<li>
~IF［
%構成子 上に %公開~条件 `拡張d属性$は指定されている
］
⇒
~RET ~T
◎
If the exposure condition extended attribute is specified on construct, then return true.
</li>
			<li>
%構成子 ~SET %構成子 を宣言している［
`~ifc$ ／
`部分的な~ifc$ ／
`~ifc~mixin$ ／
`部分的な~ifc~mixin$ ／
`~ns$ ／
`部分的な~ns$
］
◎
Otherwise, set construct to be the interface, partial interface, interface mixin, partial interface mixin, namespace, or partial namespace construct is declared on.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%構成子 は［
`部分的な~ifc$ ／ `部分的な~ifc~mixin$ ／ `部分的な~ns$
］である
］：
◎
If construct is a partial interface, partial interface mixin, or partial namespace, then:
</p>
		<ol>
			<li>
~IF［
%構成子 上に %公開~条件 `拡張d属性$は指定されている
］
⇒
~RET ~T
◎
If the exposure condition extended attribute is specified on construct, then return true.
</li>
			<li>
%構成子 ~SET %構成子 の元の［
`~ifc$ ／
`~ifc~mixin$ ／
`~ns$
］定義
◎
Otherwise, set construct to be the original interface, interface mixin, or namespace definition of construct.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%構成子 は`~ifc~mixin$である
］：
◎
If construct is an interface mixin, then:
</p>
		<ol>
			<li>
~IF［
%構成子 上に %公開~条件 `拡張d属性$は指定されている
］
⇒
~RET ~T
◎
If the exposure condition extended attribute is specified on construct, then return true.
</li>
			<li>
%構成子 ~SET %H
◎
Otherwise, set construct to H.
</li>
		</ol>
	</li>
	<li>
~Assert：
%構成子 は次に挙げるいずれかである
⇒＃
`~ifc$ ／
`~callback~ifc$ ／
`~ns$
◎
Assert: construct is an interface, callback interface or namespace.
</li>
	<li>
~IF［
%構成子 上に %公開~条件 `拡張d属性$は指定されている
］
⇒
~RET ~T
◎
If the exposure condition extended attribute is specified on construct, then return true.
</li>
	<li>
~RET ~F
◎
Otherwise, return false.
</li>
</ol>
</div>

<p class="note">注記：
~JS大域~objに`関連な設定群~obj$が［
`~secureな文脈$enVであるかどうか／
その`非同一-生成元~能力は隔離されるか？$enV の結果
］は変化し得ないので、
実装が %構成子 用の~propを作成するかどうか裁定するのは，`初期~obj$を作成する時点の一度限りになる。
◎
Note: Since it is not possible for the relevant settings object for a JavaScript global object to change whether it is a secure context or cross-origin isolated capability over time, an implementation’s decision to create properties for an interface or interface member can be made once, at the time the initial objects are created.
</p>

<p>
`Exposed$x の利用に課される特有な要件については、
次を見よ
⇒＃
`~ifc＠#js-interfaces§,
`定数＠#js-constants§,
`属性＠#js-attributes§,
`演算＠#js-operations§
◎
See § 3.7 Interfaces, § 3.7.5 Constants, § 3.7.6 Attributes, § 3.7.7 Operations, and for the specific requirements that the use of [Exposed] entails.
</p>

<div class="example">
<p>
`Exposed$x に意図されている用途は、［
`~ifc$ ／
`~callback~ifc$ ／
`~ns$ ／
個々の`~ifc~mb$ ／
個々の`~ifc~mixin~mb$ ／
個々の`~ns~mb$
］が可用になるのは［
`~worker＠~WORKERS$, `Worklet$T, `Window$T
］のうち［
どれ, あるいは どの組合n
］の中に限るかを制御することである。
◎
[Exposed] is intended to be used to control whether interfaces, callback interfaces, namespaces, or individual interface, mixin or namespace members are available for use in workers, Worklet, Window, or any combination of the above.
</p>

<p>
それが どうやって達成されるかを，次の~IDL片に示す：
◎
The following IDL fragment shows how that might be achieved:
</p>

<pre class="webidl">
[Exposed=Window, Global=Window]
interface Window {
  /* ... */
};

/* <span class="comment">
`SharedWorkerGlobalScope^T と `DedicatedWorkerGlobalScope^T
の両者に同じ識別子 `Worker^l を利用する
— 両者は `Exposed^x 拡張d属性からまとめて指せるようになる：
◎
By using the same identifier Worker for both SharedWorkerGlobalScope and DedicatedWorkerGlobalScope, both can be addressed in an [Exposed] extended attribute at once.
</span> */
[Exposed=Worker, Global=Worker]
interface SharedWorkerGlobalScope : WorkerGlobalScope {
  /* ... */
};

[Exposed=Worker, Global=Worker]
interface DedicatedWorkerGlobalScope : WorkerGlobalScope {
  /* ... */
};

/* <span class="comment">
`Dimensions^T は、
~main~thread上でも, ~workerの中でも可用になる：
◎
Dimensions is available for use in workers and on the main thread.
</span> */
[Exposed=(Window,Worker)]
interface Dimensions {
  constructor(double %width, double %height);
  readonly attribute double %width;
  readonly attribute double %height;
};

/* <span class="comment">
`WorkerNavigator^T は、
~workerの中に限り可用になる
— ~workerの大域~scopeの中で `WorkerNavigator^T を評価したときは~ifc~objを得られる一方で、
~main~thread上でそうしたときは `ReferenceError^jE になる：
◎
WorkerNavigator is only available in workers.  Evaluating WorkerNavigator in the global scope of a worker would give you its interface object, while doing so on the main thread will give you a ReferenceError.
</span> */
[Exposed=Worker]
interface WorkerNavigator {
  /* ... */
};

/* <span class="comment">
`Node^T は、
~main~thread上に限り可用になる
— ~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^jE になる：
◎
Node is only available on the main thread.  Evaluating Node in the global scope of a worker would give you a ReferenceError.
</span> */
[Exposed=Window]
interface Node {
  /* ... */
};

/* <span class="comment">
`MathUtils^T は、
~main~thread上でも, ~workerの中でも可用になる：
◎
MathUtils is available for use in workers and on the main thread.
</span> */
[Exposed=(Window,Worker)]
namespace MathUtils {
  double someComplicatedFunction(double %x, double %y);
};

/* <span class="comment">
`WorkerUtils^T は、
~workerの中に限り可用になる
— ~workerの大域~scopeの中で `WorkerUtils^T を評価したときは その~ns~objを得られる一方で、
~main~thread上でそうしたときは `ReferenceError^jE になる：
◎
WorkerUtils is only available in workers.  Evaluating WorkerUtils in the global scope of a worker would give you its namespace object, while doing so on the main thread will give you a ReferenceError.
</span> */
[Exposed=Worker]
namespace WorkerUtils {
  undefined setPriority(double %x);
};

/* <span class="comment">
`NodeUtils^T は、
~main~thread上に限り可用になる
— ~workerの大域~scopeの中で `Node^T を評価したときは `ReferenceError^jE になる：
◎
NodeUtils is only available in the main thread.  Evaluating NodeUtils in the global scope of a worker would give you a ReferenceError.
</span> */
[Exposed=Window]
namespace NodeUtils {
  DOMString getAllText(Node %node);
};

</pre>
</div>

			</section>
			<section id="Global">
<h4>3.3.8. `Global^x</h4>

<p>
`Global$x `拡張d属性$が`~ifc$に現れた場合、
次を指示する
⇒
当の~ifcを実装している~objは、
ある`~realm$に属する大域~objとして利用されることになる
◎
If the [Global] extended attribute appears on an interface, it indicates that objects implementing this interface will be used as the global object in a realm.
</p>

<p>
`Global$x `拡張d属性$は、
当の`~ifc$用の
`大域~名@
（たち）も定義する
— それは、［
`識別子を引数にとる$ならば その`識別子$のみからなる~list／
`識別子~listを引数にとる$ならば その識別子~list
］になる。
◎
The [Global] extended attribute also defines the global names for the interface:
• If the [Global] extended attribute takes an identifier
•• « the given identifier »
• If the [Global] extended attribute takes an identifier list
•• the identifier list
</p>

<p>
`Global$x 拡張d属性は、
前段落に挙げた いずれかの形をとらなければナラナイ。
◎
The [Global] extended attribute must be one of the forms given above.
</p>


<p class="note">注記：
`~ifc$用の`大域~名$は、
`Exposed$x `拡張d属性$において，それを参照するために利用できる`識別子$を与える。
単独の識別子が，複数の異なる大域~ifcから共有され得る
— これにより，~ifcは、
自身を それらすべてに一括して公開するときに，
`Exposed$x をより容易に利用できるようになる。
例えば `Worker^l は、［
~thread法に関係する，複数の別個な型の大域~ifc
］を指すときに利用される。
【`Exposed§x の末尾にある例を見よ。】
◎
Note: The global names for the interface are the identifiers that can be used to reference it in the [Exposed] extended attribute. A single name can be shared across multiple different global interfaces, allowing an interface to more easily use [Exposed] to expose itself to all of them at once. For example, "Worker" is used to refer to several distinct types of threading-related global interfaces.
</p>

<p>
これらの大域`~ifc$に対しては、
原型鎖の構造, および［
`~ifc~mb$に対応する~propが原型~obj上に どう反映されるか
］も，他の~ifcと異なることになる。
特定的には：
◎
For these global interfaces, the structure of the prototype chain and how properties corresponding to interface members will be reflected on the prototype objects will be different from other interfaces. Specifically:
</p>
<ol>
	<li>
どの`有名~prop$も，~obj自身ではなく,
原型鎖の中の~obj
— `有名~prop群~obj$ —
上に公開されることになる。
◎
Any named properties will be exposed on an object in the prototype chain – the named properties object – rather than on the object itself.
</li>
	<li>
`~ifc$からの`~ifc~mb$は、
`~ifc原型~obj$上ではなく，~obj自身の~propに対応することになる。
◎
Interface members from the interface will correspond to properties on the object itself rather than on interface prototype objects.
</li>
</ol>

<p>
各`~realm$は、
`大域~原型鎖は変異-可能か@
を有する
— その値は
⇒＃
真偽値をとる。
既定では， ~F に設定される。
当の`~realm$の作成-時に，設定され得る。
当の`~realm$が存続する限り，変化しない。
◎
All realms have an is global prototype chain mutable boolean, which can be set when the realm is created. Its value can not change during the lifetime of the realm. By default it is set to false.
</p>

<p class="note">注記：
これは、［
`ShadowRealm^jt 大域~objの原型が変異-可能になる
］ことを許容するためにある。
◎
This allows the ShadowRealm global to have a mutable prototype.
</p>

<div class="note">
<p>注記：
原型鎖の中の~obj上に置かれる有名~propは、
変数~宣言とそのままの名前の代入を通して，大域~obj自身の~propにより隠蔽される。
◎
Placing named properties on an object in the prototype chain is done so that variable declarations and bareword assignments will shadow the named property with a property on the global object itself.
</p>

<p>
~ifc~mbに対応する~propを~obj自身の上に置くことは、
次の様な，特能を検出するためによく利用される手法が働くことになることを意味する：
【！機能しない？】
◎
Placing properties corresponding to interface members on the object itself will mean that common feature detection methods like the following will work:
</p>

<pre class="lang-js">
var %indexedDB = window.indexedDB || window.webkitIndexedDB ||
                window.mozIndexedDB || window.msIndexedDB;

var %requestAnimationFrame = window.requestAnimationFrame ||
                            window.mozRequestAnimationFrame || ...;
</pre>

<p>
~JSにおける変数~宣言が取扱われる仕方から，代入が評価される前に隠蔽する変数~propが作成されることになるので、
上の~codeでは，
`window.indexedDB^c
と
`window.requestAnimationFrame^c
が `undefined^jv に評価されることになる。
◎
Because of the way variable declarations are handled in JavaScript, the code above would result in the window.indexedDB and window.requestAnimationFrame evaluating to undefined, as the shadowing variable property would already have been created before the assignment is evaluated.
</p>
</div>

<p>
`Global$x `拡張d属性$を利用する`~ifc$ %I に対しては：
◎
If the [Global] extended attributes is used on an interface, then:
</p>
<ul>
	<li>
次に挙げるものを定義してはナラナイ
⇒＃
`有名~prop設定子$／
`有index~prop取得子$／
`有index~prop設定子$／
`構築子~演算$
◎
The interface must not define a named property setter.
◎
The interface must not define indexed property getters or setters.
◎
The interface must not define a constructor operation.
</li>
	<li>
%I の`自身も含む継承した~ifc群$を成す どの~ifcも，
【！%I, および %I が`継承した~ifc群$】
`LegacyOverrideBuiltIns$x 拡張d属性を伴って宣言されてはナラナイ。
◎
The interface must not also be declared with the [LegacyOverrideBuiltIns] extended attribute.
◎
The interface must not inherit from another interface with the [LegacyOverrideBuiltIns] extended attribute.
</li>
	<li>
他の~ifcは、
%I を`継承-$してはナラナイ。
◎
Any other interface must not inherit from it.
</li>
	<li>
この拡張d属性が %I の`部分的な~ifc定義$ %J 上に指定される場合、
%J は， %I を成す~ifc定義の中で`有名~prop取得子$を定義する部分を成していなければナラナイ。
◎
If [Global] is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</li>
	<li>
<p>
%I は、
同じ`~realm$内で，複数個の~objから実装され得るものであってはナラナイ。
◎
The [Global] extended attribute must not be used on an interface that can have more than one object implementing it in the same realm.
</p>

<p class="note">注記：
そのわけは、［
有名~propたちを公開する`有名~prop群~obj$は，原型鎖の中にあるもの
］であり，複数個の［
~objの有名~prop
］を［
それらの~objを継承する 1 個の~obj
］上で公開するようにしてもイミを成さないからである。
◎
Note: This is because the named properties object, which exposes the named properties, is in the prototype chain, and it would not make sense for more than one object’s named properties to be exposed on an object that all of those objects inherit from.
</p>
	</li>
	<li>
<p>
%I には［
`識別子$が互いに同じ`~mb$
］が複数~在ってはナラナイ。
%I には`文字列化子$が複数~在ってはナラナイ。
%I には［
`可反復~宣言$／`非同期に可反復な宣言$／`~maplike宣言$／`~setlike宣言$
］【混在も含む】が複数~在ってはナラナイ。
◎
If an interface is declared with the [Global] extended attribute, then there must not be more than one member across the interface with the same identifier. There also must not be more than one stringifier or more than one iterable declaration, asynchronously iterable declaration, maplike declaration or setlike declaration across those interfaces.
</p>

<p class="note">注記：
そのわけは、
~ifcを成す`~mb$すべてが，~ifcを`実装-$する~objに平坦~化されるからである。
◎
Note: This is because all of the members of the interface get flattened down on to the object that implements the interface.
</p>
	</li>
</ul>

<p>
`有名~prop$における `Global$x の利用に課される特有な要件については、
`有名~prop群~obj＠#named-properties-object§
を見よ。
`~ifc~mb$に対応する~propの所在に関する要件については、
`定数＠#js-constants§,
`属性＠#js-attributes§,
`演算＠#js-operations§
を見よ。
◎
See § 3.7.4 Named properties object for the specific requirements that the use of [Global] entails for named properties, and § 3.7.5 Constants, § 3.7.6 Attributes and § 3.7.7 Operations for the requirements relating to the location of properties corresponding to interface members.
</p>

<div class="example">
<p>
`Window^T ~ifcは、
~frameたち【 `iframe^c 要素】を `Window^T ~objの~propとして公開する
【`参照＠~WINDOW#named-access-on-the-window-object$】
。
`Window^T ~objは，~JS大域~objとしても~serveするので、
有名~propに対する代入や変数~宣言は，新たな値への置換-になる。
属性に対する変数~宣言は、
既存の~propを置換する~propを作成しない。
◎
The Window interface exposes frames as properties on the Window object. Since the Window object also serves as the JavaScript global object, variable declarations or assignments to the named properties will result in them being replaced by the new value. Variable declarations for attributes will not create a property that replaces the existing one.
</p>

<pre class="webidl">
[Exposed=Window, Global=Window]
interface Window {
  getter object【！any】 (DOMString %name);
  attribute DOMString name; 
   /* ... */
};
</pre>

<p>
次の~HTML文書では、
`Window^T ~objの有名~propが隠蔽され，
属性に対する~propは同じ名前の変数が宣言されても置換されない：
◎
The following HTML document illustrates how the named properties on the Window object can be shadowed, and how the property for an attribute will not be replaced when declaring a variable of the same name:
</p>

<pre class="lang-html">
&lt;!DOCTYPE html&gt;
&lt;title&gt;<span class="comment">
`Window^T の変数~宣言と代入
◎
Variable declarations and assignments on Window
</span>&lt;/title&gt;
&lt;iframe name=abc&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
有名~propを隠蔽する
◎
Shadowing named properties
</span> --&gt;
&lt;script&gt;
  window.abc;    /* <span class="comment">
`iframe^c の `Window^T ~objに評価される。
◎
Evaluates to the iframe’s Window object.
</span> */
  %abc = 1;       /* <span class="comment">
有名~propを隠蔽する。
◎
Shadows the named property.
</span> */
  window.abc;    /* <span class="comment" id="cp-eval-1">
`1^jv に評価される。
◎
Evaluates to 1.
</span> */
&lt;/script&gt;

&lt;!-- <span class="comment">
~IDL属性~用の~propは保全される
◎
Preserving properties for IDL attributes
</span> --&gt;
&lt;script&gt;
  Window.prototype.def = 2;         /* <span class="comment">
原型~上に~propを置く。
◎
Places a property on the prototype.
</span> */
  window.hasOwnProperty("length");  /* <!--cp-eval-true--> */

  %length;        /* <!--cp-eval-1--> */
  %def;           /* <span class="comment">
`2^jv に評価される。
◎
Evaluates to 2.
</span> */
&lt;/script&gt;

&lt;script&gt;
  var %length;    /* <span class="comment">
この変数~宣言は既存の~propに触らない。
◎
Variable declaration leaves existing property.
</span> */
  %length;        /* <!--cp-eval-1--> */
  var %def;       /* <span class="comment">
この変数~宣言は隠蔽する~propを作成する。
◎
Variable declaration creates shadowing property.
</span> */
  %def;           /* <span class="comment">
`undefined^jv に評価される。
◎
Evaluates to undefined
</span> */
&lt;/script&gt;
</pre>
</div>

			</section>
			<section id="NewObject">
<h4>3.3.9. `NewObject^x</h4>

<p>
`NewObject$x `拡張d属性$が［
`正則~演算$／`静的~演算$
］に現れた場合、
次を指示する
⇒
当の演算が~callされたときは、
常に，新たに作成された~objへの参照を返すモノトスル
◎
If the [NewObject] extended attribute appears on a regular or static operation, then it indicates that when calling the operation, a reference to a newly created object must always be returned.
</p>

<p>
`NewObject$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [NewObject] extended attribute must take no arguments.
</li>
	<li>
`返り値~型$が［
`~ifc型$, または `~promise型$
］である［
`正則~演算$／`静的~演算$
］以外の所に利用してはナラナイ。
◎
The [NewObject] extended attribute must not be used on anything other than a regular or static operation whose return type is an interface type or a promise type.
</li>
</ul>

<div class="example">
<p>
この拡張d属性の利用が適する例として、
`Document$T ~ifcの `createElement()＠~DOM4#dom-document-createelement$M 演算 `DOM$r がある
— これは、
~callされる度に新たな~objが返すので。
`DOM$r
◎
As an example, this extended attribute is suitable for use on the createElement() operation on the Document interface, since a new object is always returned when it is called. [DOM]
</p>

<pre class="webidl">
[Exposed=Window]
interface Document : Node {
  [NewObject] Element createElement(DOMString %localName);
  /* ... */
};
</pre>
</div>

			</section>
			<section id="PutForwards">
<h4>3.3.10. `PutForwards^x</h4>

<p>
`PutForwards$x `拡張d属性$が［
`~ifc型$の`読専$な`正則~属性$宣言
］に現れた場合、
次を指示する
⇒
当の属性への代入-時には特有に挙動することになる
— すなわち，その代入は、
代入するよう試みられた属性から［
現在~参照されている~obj
］の属性
（当の拡張d属性の引数で指定される）
へ “回送-” される。
◎
If the [PutForwards] extended attribute appears on a read only regular attribute declaration whose type is an interface type, it indicates that assigning to the attribute will have specific behavior. Namely, the assignment is “forwarded” to the attribute (specified by the extended attribute argument) on the object that is currently referenced by the attribute being assigned to.
</p>

<p>
`PutForwards$x 拡張d属性は、
`識別子を引数にとる$ことが要求される。
次が与えられたとするとき：
◎
The [PutForwards] extended attribute must take an identifier. Assuming that:
</p>
<ul>
	<li>
%A は
`PutForwards$x 拡張d属性が現れる`属性$,
◎
A is the attribute on which the [PutForwards] extended attribute appears,
</li>
	<li>
%I は
%A を宣言した`~ifc$,
◎
I is the interface on which A is declared,
</li>
	<li>
%J は
%A の型として宣言された`~ifc型$, 【！＊】
◎
J is the interface type that A is declared to be of, and
</li>
	<li>
%N は
その拡張d属性の`識別子$引数,
◎
N is the identifier argument of the extended attribute,
</li>
</ul>

<p>
このとき，`識別子$ %N を有する別の`属性$ %B が
%J 上に宣言されていなければナラナイ。
%I を実装している~objの属性 %A への値の代入では、
代わりに， %A が参照する~objの属性 %B にその値が代入されることになる。
◎
then there must be another attribute B declared on J whose identifier is N. Assignment of a value to the attribute A on an object implementing I will result in that value being assigned to attribute B of the object that A references, instead.
</p>

<p>
`PutForwards$x で注釈された`属性$は連鎖し得ることに注意。
すなわち、
`PutForwards$x `拡張d属性$を伴う属性は，
この拡張d属性を有する他の属性を指すことができる。
ただし、
この代入の連鎖が循環してはナラナイ。
代入の連鎖を追ったとき，同じ`~ifc$の特定0の属性に複数~回 遭遇するならば、
循環が存在する。
◎
Note that [PutForwards]-annotated attributes can be chained. That is, an attribute with the [PutForwards] extended attribute can refer to an attribute that itself has that extended attribute. There must not exist a cycle in a chain of forwarded assignments. A cycle exists if, when following the chain of forwarded assignments, a particular attribute on an interface is encountered more than once.
</p>

<p>
`PutForwards$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
同じ属性~上で，次に挙げる拡張d属性と伴に宣言してはナラナイ
⇒＃
`LegacyLenientSetter$x ／
`Replaceable$x
◎
An attribute with the [PutForwards] extended attribute must not also be declared with the [LegacyLenientSetter] or [Replaceable] extended attributes.
</li>
	<li>
`読専$でない`属性$に利用してはナラナイ。
◎
The [PutForwards] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$に利用してはナラナイ。
◎
The [PutForwards] extended attribute must not be used on a static attribute.
</li>
	<li>
`~ns$上で宣言される属性に利用してはナラナイ。
◎
The [PutForwards] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`PutForwards$x が どう実装されるかについては、
`属性＠#js-attributes§
を見よ。
◎
See the Attributes section for how [PutForwards] is to be implemented.
</p>

<div class="example">
<p>
次の`~IDL片$は、
姓名と人を表す~ifcを定義する。
`Person^T ~ifcの `name^M 属性~上に利用される `PutForwards$x 拡張d属性は、［
その属性への代入による結果は、
`Person^T ~objの【 `name^M 属性が指す `Name^T ~objの】 `full^M 属性への代入になる
］ことを指示する：
◎
The following IDL fragment defines interfaces for names and people. The [PutForwards] extended attribute is used on the name attribute of the Person interface to indicate that assignments to that attribute result in assignments to the full attribute of the Person object:
</p>

<pre class="webidl">
[Exposed=Window]
interface Name {
  attribute DOMString full;
  attribute DOMString family;
  attribute DOMString given;
};

[Exposed=Window]
interface Person {
  [PutForwards=full] readonly attribute Name name;
  attribute unsigned short age;
};
</pre>

<p>
~JS言語束縛においては、
`name^jp ~propへの代入が許容されることになる：
◎
In the JavaScript binding, this would allow assignments to the name property:
</p>

<pre class="lang-js">
var %p = getPerson();           /* <span class="comment">
`Person^T の~instanceを得する。
◎
Obtain an instance of Person.
</span> */

%p.name = 'John Citizen';       /* <span class="comment">
この文は...
◎
This statement...
</span> */
%p.name.full = 'John Citizen';  /* <span class="comment">
...これと同じ挙動になる。
◎
...has the same behavior as this one.
</span> */
</pre>
</div>

			</section>
			<section id="Replaceable">
<h4>3.3.11. `Replaceable^x</h4>

<p>
`Replaceable$x `拡張d属性$が `読専$な`正則~属性$に現れた場合、
次を指示する
⇒
当の`~platform~obj$の対応する~propが設定される際には，［
当の~obj上に，代入される値をとる同じ名前の自前の~prop
］が作成され、
それは，`~ifc原型~obj$上に存在する［
当の属性に対応する~accessor~prop
］を隠蔽することになる。
◎
If the [Replaceable] extended attribute appears on a read only regular attribute, it indicates that setting the corresponding property on the platform object will result in an own property with the same name being created on the object which has the value being assigned. This property will shadow the accessor property corresponding to the attribute, which exists on the interface prototype object.
</p>

<p>
`Replaceable$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Replaceable] extended attribute must take no arguments.
</li>
	<li>
同じ属性~上で，次に挙げる拡張d属性と伴に宣言してはナラナイ
⇒＃
`LegacyLenientSetter$x ／
`Replaceable$x
◎
An attribute with the [Replaceable] extended attribute must not also be declared with the [LegacyLenientSetter] or [PutForwards] extended attributes.
</li>
	<li>
`読専$でない`属性$に利用してはナラナイ。
◎
The [Replaceable] extended attribute must not be used on an attribute that is not read only.
</li>
	<li>
`静的~属性$に利用してはナラナイ。
◎
The [Replaceable] extended attribute must not be used on a static attribute.
</li>
	<li>
`~ns$上で宣言される属性に利用してはナラナイ。
◎
The [Replaceable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`Replaceable$x の利用に課される特有な要件については、
`属性＠#js-attributes§
を見よ。
◎
See § 3.7.6 Attributes for the specific requirements that the use of [Replaceable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、［
計数を増やす`演算$,
計数~値を公開する初期~値 0 の`属性$を有する`~ifc$
］を定義する：
◎
The following IDL fragment defines an interface with an operation that increments a counter, and an attribute that exposes the counter’s value, which is initially 0:
</p>

<pre class="webidl">
[Exposed=Window]
interface Counter {
  [Replaceable] readonly attribute unsigned long value;
  undefined increment();
};
</pre>

<p>
`Counter^T を実装する `~platform~obj$の `value^jp ~propに代入することにより，その`属性$に対応する~propは隠蔽されることになる：
◎
Assigning to the value property on a platform object implementing Counter will shadow the property that corresponds to the attribute:
</p>

<pre class="lang-js">
var %counter = getCounter();         /* <span class="comment">
`Counter^T の~instanceを得する。
◎
Obtain an instance of Counter.
</span> */
%counter.value;                      /* <span class="comment">
`0^jv に評価される。
◎
Evaluates to 0.
</span> */

%counter.hasOwnProperty("value");    /* <!--cp-eval-false--> */
Object.getPrototypeOf(%counter).hasOwnProperty("value");
                                    /* <!--cp-eval-true--> */

%counter.increment();
%counter.increment();
%counter.value;                      /* <span class="comment">
`2^jv に評価される。
◎
Evaluates to 2.
</span> */

%counter.value = 'a';                
       /* <span class="comment">
`Counter::value^V に無関係なもので~propを隠蔽する。
◎
Shadows the property with one that is unrelated to Counter::value.
</span> */

%counter.hasOwnProperty("value");    /* <!--cp-eval-true--> */

%counter.increment();
%counter.value;                      /* <span class="comment">
`a^l に評価される。
◎
Evaluates to 'a'.
</span> */

delete %counter.value;               /* <span class="comment">
元の~propを露にする。
◎
Reveals the original property.
</span> */
%counter.value;                      /* <span class="comment">
`3^jv に評価される。
◎
Evaluates to 3.
</span> */
</pre>
</div>

			</section>
			<section id="SameObject">
<h4>3.3.12. `SameObject^x</h4>

<p>
`SameObject$x `拡張d属性$が `読専$な`属性$に現れた場合、
次を指示する
⇒
所与の~obj上でその属性の値が取得される度に，常に同じ値を返すモノトスル
◎
If the [SameObject] extended attribute appears on a read only attribute, then it indicates that when getting the value of the attribute on a given object, the same value must always be returned.
</p>

<p>
`SameObject$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [SameObject] extended attribute must take no arguments.
</li>
	<li>
次を満たす`属性$以外の所に利用してはナラナイ
⇒
［
`読専$である
］~AND［
その型は［
`~ifc型$／`~obj型$
］である
］
◎
The [SameObject] extended attribute must not be used on anything other than a read only attribute whose type is an interface type or object.
</li>
</ul>

<div class="example">
<p>
この拡張d属性の利用が適する例として，
`Document$T ~ifcの `implementation＠~DOM4#dom-document-implementation$M 属性がある。
— 所与の `Document^T ~objに対しては、
常に同じ~objを返すので。
`DOM$r
◎
As an example, this extended attribute is suitable for use on the implementation attribute on the Document interface since the same object is always returned for a given Document object. [DOM]
</p>

<pre class="webidl">
[Exposed=Window]
interface Document : Node {
  [SameObject] readonly attribute DOMImplementation implementation;
  /* ... */
};
</pre>
</div>

			</section>
			<section id="SecureContext">
<h4>3.3.13. `SecureContext^x</h4>

<p>
`SecureContext$x `拡張d属性$が，次に挙げる構成子に現れた場合
⇒＃
`~ifc$ ／
`部分的な~ifc$ ／
`~ifc~mixin$ ／
`~callback~ifc$ ／
`部分的な~ifc~mixin$ ／
`~ns$ ／
`部分的な~ns$ ／
`~ifc~mb$ ／
`~ifc~mixin~mb$ ／
`~ns~mb$
◎終
次を指示する
⇒
当の構成子が`公開され$るのは，`~secureな文脈$enVの中に限られる
◎
If the [SecureContext] extended attribute appears on an interface, partial interface, interface mixin, partial interface mixin, callback interface, namespace, partial namespace, interface member, interface mixin member, or namespace member, it indicates that the construct is exposed only within a secure context.＼
</p>

<p>
`SecureContext$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
上に挙げたもの以外の構成子に利用してはナラナイ。
◎
The [SecureContext] extended attribute must not be used on any other construct.
</li>
	<li>
`引数をとらない$ことが要求される。
◎
The [SecureContext] extended attribute must take no arguments.
</li>
	<li>
`多重定義$された ある`演算$に現れるならば、
その多重定義を成す他のすべての演算にも現れなければナラナイ。
◎
If [SecureContext] appears on an overloaded operation, then it must appear on all overloads.
</li>
	<li>
<p>
次の各項に対し，そこに挙げる両者に指定してはナラナイ：
◎
The [SecureContext] extended attribute must not be specified both on
</p>
		<ul>
			<li>
`~ifc~mb$, それを宣言している［
`~ifc$／`部分的な~ifc$
］
◎
an interface member and its interface or partial interface;
</li>
			<li>
`~ifc~mixin~mb$, それを宣言している［
`~ifc~mixin$／`部分的な~ifc~mixin$
］
◎
an interface mixin member and its interface mixin or partial interface mixin;
</li>
			<li>
`~ns~mb$, それを宣言している［
`~ns$／`部分的な~ns$
］
◎
a namespace member and its namespace or partial namespace.
</li>
		</ul>

<p class="note">注記：
そのわけは、
ある定義に `SecureContext$x `拡張d属性$が注釈されている下で，
それが包含している`~mb$に `SecureContext$x `拡張d属性$を追加しても、
~mbの公開をさらに制約することはないからである。
◎
Note: This is because adding the [SecureContext] extended attribute on a member when its containing definition is also annotated with the [SecureContext] extended attribute does not further restrict the exposure of the member.
</p>
	</li>
</ul>

<p>
`SecureContext$x `拡張d属性$を伴わない`~ifc$は、
`SecureContext$x を指定する別の~ifcを`継承-$してはナラナイ。
◎
An interface without the [SecureContext] extended attribute must not inherit from another interface that does specify [SecureContext].
</p>

<p>
`SecureContext$x は［
`CrossOriginIsolated$x 上で`条件付きで公開されて$いる構成子
］に指定してはナラナイ（そうすることは冗長になる
— どの環境も［
`非同一-生成元~能力は隔離されるか？$enV ~EQ ~T
］ならば`~secureな文脈$enVになるので）。
◎
[SecureContext] must not be specified on a construct is that is conditionally exposed on [CrossOriginIsolated]. (Doing so would be redundant, since every environment which is cross-origin isolated is also a secure context.)
</p>

<div class="example">
<p>
次の`~IDL片$が定義する~ifcには、
3 個の~mbがある
— うち 1 個は，どの文脈からも実行-可能な`演算$であり、
他は，~secureな文脈に限り実行-可能になる：
◎
The following IDL fragment defines an interface with one operation that is executable from all contexts, and two which are executable only from secure contexts.
</p>

<pre class="webidl">
[Exposed=Window]
interface ExampleFeature {
  /* <span class="comment">
次の演算の~callはどの文脈~下でも成功する：
◎
This call will succeed in all contexts.
</span> */
  Promise &lt;Result&gt; calculateNotSoSecretResult();

  /* <span class="comment">
次の演算は、
~secureでない文脈には公開されない
— `ExampleFeature.prototype^c 上に `calculateSecretResult^jp ~propは無い：
◎
This operation will not be exposed to a non-secure context. In such a context, there will be no "calculateSecretResult" property on ExampleFeature.prototype.
</span> */
  [SecureContext] Promise&lt;Result&gt; calculateSecretResult();

  /* <span class="comment">
次の属性にも同じことが言え、
~secureでない文脈には公開されない
— `ExampleFeature.prototype^c 上に `secretBoolean^jp ~propは無い：
◎
The same applies here: the attribute will not be exposed to a non-secure context, and in a non-secure context there will be no "secretBoolean" property on ExampleFeature.prototype.
</span> */
  [SecureContext] readonly attribute boolean secretBoolean;
};

/* <span class="comment">
`HeartbeatSensor^T は、
~secureでない文脈にも その~mbにも公開されない
— `Window^T 上に `HeartbeatSensor^jp ~propは無い：
◎
HeartbeatSensor will not be exposed in a non-secure context, nor will its members. In such a context, there will be no "HeartbeatSensor" property on Window.
</span> */
[Exposed=Window, SecureContext]
interface HeartbeatSensor {
  Promise&lt;float&gt; getHeartbeatsPerMinute();
};

/* <span class="comment">
次に定義される~ifc~mixin~mbは、
それを内包する~ifcが~secureかどうかに関わらず，
~secureでない文脈には決して公開されない
— すなわち、
`ExampleFeature.prototype^c 上に `snap^jp ~propは無い：
◎
The interface mixin members defined below will never be exposed in a non-secure context, regardless of whether the interface that includes them is. That is, in a non-secure context, there will be no "snap" property on ExampleFeature.prototype.
</span> */
[SecureContext]
interface mixin Snapshotable {
  Promise&lt;boolean&gt; snap();
};
ExampleFeature includes Snapshotable;

/* <span class="comment">
他方，次の各 ~ifc~mixin~mbは、
`SecureContext$x 拡張d属性を伴わない~host~ifcに内包された場合には，
~secureでない文脈にも公開されることになる
— すなわち、
そのような文脈においても，
`ExampleFeature.prototype^c 上に `log^jp ~propは在る：
◎
On the other hand, the following interface mixin members will be exposed to a non-secure context when included by a host interface that doesn’t have the [SecureContext] extended attribute. That is, in a non-secure context, there will be a "log" property on ExampleFeature.prototype.
</span> */
interface mixin Loggable {
  Promise&lt;boolean&gt; log();
};
ExampleFeature includes Loggable;
</pre>
</div>

			</section>
			<section id="Unscopable">
<h4>3.3.14. `Unscopable^x</h4>

<p>
`Unscopable$x `拡張d属性$が［
`正則~属性$／`正則~演算$
］ %m に現れた場合、
次を指示する
⇒
［
%m を伴う~ifcを`実装-$する~obj %O
］は、
%O に伴われるどの~obj環境~record内にも，
その基底~objとして %m の~prop名を内包しない
◎
If the [Unscopable] extended attribute appears on a regular attribute or regular operation, it indicates that an object that implements an interface with the given interface member will not include its property name in any object environment record with it as its base object.＼
</p>

<p>
その結果， `with^c 文の中では、［
%m の~prop名に合致する “裸の” 識別子
］は，当の~propには解決されないことになる。
このふるまいは、
%m の~prop名を［
`~ifc原型~obj$の `Symbol.unscopables$jI ~propの値
］に含めることにより達成される。
◎
The result of this is that bare identifiers matching the property name will not resolve to the property in a with statement. This is achieved by including the property name on the interface prototype object’s %Symbol.unscopables% property’s value.
</p>

<p>
`Unscopable$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [Unscopable] extended attribute must take no arguments.
</li>
	<li>
次に挙げるもの以外の所に現れてはナラナイ
⇒＃
`正則~属性$／
`正則~演算$
◎
The [Unscopable] extended attribute must not appear on anything other than a regular attribute or regular operation.
</li>
	<li>
`~ns$上で宣言される属性に利用してはナラナイ。
◎
The [Unscopable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`Unscopable$x の利用に課される特有な要件については、
`~ifc原型~obj＠#interface-prototype-object§
を見よ。
◎
See § 3.7.3 Interface prototype object for the specific requirements that the use of [Unscopable] entails.
</p>

<div class="note">
<p>注記：
例えば、
次の~IDLが与えられたとき：
◎
For example, with the following IDL:
</p>

<pre class="webidl">
[Exposed=Window]
interface Thing {
  undefined f();
  [Unscopable] g();
};
</pre>

<p>
`f^jp ~propは、
`with^c 文の中で “裸の” 識別子により参照できるが，
`g^jp ~propはできない：
◎
the f property can be referenced with a bare identifier in a with statement but the g property cannot:
</p>

<pre class="lang-js">
var %thing = getThing();  /* <span class="comment">
`Thing^T の~instance
◎
An instance of Thing
</span> */
with (%thing) {
  f;                     /* <span class="comment">
`Function^jt ~objに評価される。
◎
Evaluates to a Function object.
</span> */
  g;                     /* <span class="comment">
`ReferenceError^jE が投出される。
◎
Throws a ReferenceError.
</span> */
}
</pre>
</div>

			</section>
		</section>
		<section id="js-legacy-extended-attributes">
<h3 title="Legacy extended attributes">3.4. 旧来の拡張d属性</h3>

<p>
この節では、
その有無が~JS言語束縛に影響する，いくつかの`拡張d属性$を定義する。
`拡張d属性＠#js-extended-attributes§に述べたものと違って、
これらは，もっぱら旧来の~Web~platform特能を指定できるようにするために存在する。
これらは、
旧来の~APIの挙動を指定するために要求されない限り，仕様~内に利用されるベキでない。
◎
This section defines a number of extended attributes whose presence affects the JavaScript binding. Unlike those in § 3.3 Extended attributes, these exist only so that legacy Web platform features can be specified. They should not be used in specifications, unless required to specify the behavior of legacy APIs.
</p>

<p>
これらの拡張d属性を利用する良い理由があると予見する編集者には、
続行する前に，
`Intent to use a legacy extended attribute$fIして論交することを強く勧める。
◎
Editors who believe they have a good reason for using these extended attributes are strongly advised to discuss this by filing an issue before proceeding.
</p>

			<section id="LegacyFactoryFunction">
<h4>3.4.1. `LegacyFactoryFunction^x</h4>

<p class="warning">
この特能を利用する代わりに、
~ifcに`構築子~演算$を与えること。
◎
Instead of using this feature, give your interface a constructor operation.
</p>

<p>
`LegacyFactoryFunction$x `拡張d属性$が`~ifc$に現れた場合、
次を指示する
⇒
当の~JS大域~objは、
次を伴う~propを有することになる
⇒＃
その名前は、当の拡張d属性の引数に指定された名前／
その値は、当の~ifcを実装する~objを作成できる関数【`旧来の~factory関数$】
◎
If the [LegacyFactoryFunction] extended attribute appears on an interface, it indicates that the JavaScript global object will have a property with the specified name whose value is a function that can create objects that implement the interface.＼
</p>

<div>
<p>
`LegacyFactoryFunction$x 拡張d属性は：
</p>
<ul>
	<li>
`有名~引数~listを引数にとる$ことが要求される。
</li>
	<li>
所与の~ifc上に，複数個 現れてもヨイ。
その それぞれが、
当の~ifcを`実装-$する~objを構築する仕方を
— 指定された引数を前述の~propの値である構築子【`旧来の~factory関数$】に渡すことにより —
成すことになる。
</li>
	<li>
同じ`~ifc$上で， `Global$x 拡張d属性とともに指定してはナラナイ。
</li>
</ul>

<p>
`=^sym の直後に現れる `identifier$g が，
`LegacyFactoryFunction$x の
`識別子@fF
を与える。
【！旧来の~factory関数~用に利用する】この識別子は、
次に挙げる識別子と同じになってはナラナイ：
</p>
<ul>
	<li>
別の~ifcの `LegacyFactoryFunction$x 拡張d属性に利用されている`識別子$fF
</li>
	<li>
当のまたは別の~ifcの `LegacyWindowAlias$x 拡張d属性に利用されている`識別子$wA
</li>
	<li>
`~ifc~obj$を有する~ifcの`識別子$
</li>
	<li>
`予約-済み識別子$
</li>
</ul>

◎
Multiple [LegacyFactoryFunction] extended attributes may appear on a given interface.
◎
The [LegacyFactoryFunction] extended attribute must take a named argument list.＼
The identifier that occurs directly after the “=” is the [LegacyFactoryFunction]'s identifier.＼
For each [LegacyFactoryFunction] extended attribute on the interface, there will be a way to construct an object that implements the interface by passing the specified arguments to the constructor that is the value of the aforementioned property.
◎
The identifier used for the legacy factory function＼
must not be the same as that used by a [LegacyFactoryFunction] extended attribute on another interface,＼
must not be the same as an identifier used by a [LegacyWindowAlias] extended attribute on this interface or another interface,＼
must not be the same as an identifier of an interface that has an interface object, and＼
must not be one of the reserved identifiers.
◎
The [LegacyFactoryFunction] and [Global] extended attributes must not be specified on the same interface.
</div>

<p>
`旧来の~factory関数$が どう実装されるかの詳細は、
`旧来の~factory関数＠#legacy-factory-functions§を見よ。
◎
See § 3.7.2 Legacy factory functions for details on how legacy factory functions are to be implemented.
</p>

<div class="example">
<p>
次の~IDLは
`LegacyFactoryFunction$x 拡張d属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [LegacyFactoryFunction] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window,
 LegacyFactoryFunction=Audio(DOMString %src)]
interface HTMLAudioElement : HTMLMediaElement {
  /* ... */
};
</pre>

<p>
この~ifcを~supportする~JS実装は、
`Audio()^M 関数を利用する `HTMLAudioElement^T ~objの構築を許容することになる。
◎
A JavaScript implementation that supports this interface will allow the construction of HTMLAudioElement objects using the Audio function.
</p>

<pre class="lang-js">
typeof Audio;           /* <span class="comment">
`function^l に評価される。
◎
Evaluates to "function"
</span> */

var %a2 = new Audio('a.flac');   /* <span class="comment">
1 個の引数をとる構築子【`旧来の~factory関数$】を利用して， `HTMLAudioElement^T を作成する。
◎
Creates an HTMLAudioElement using the one-argument constructor.
</span> */
</pre>

<p>
追加的な旧来の過去互換として、
これらの~factory関数は，元の~ifcの `prototype^jp に等しい
`prototype^jp ~propを有することになる：
◎
As an additional legacy quirk, these factory functions will have a prototype property equal to the prototype of the original interface:
</p>

<pre class="lang-js">
console.assert(Audio.prototype === HTMLAudioElement.prototype);
</pre>
</div>

			</section>
			<section id="LegacyLenientSetter">
<h4>3.4.2. `LegacyLenientSetter^x</h4>

<p>
`LegacyLenientSetter$x `拡張d属性$が`読専$な`正則~属性$に現れた場合、
次を指示する
⇒
当の属性の~accessor~propとして，何もしない設定子を生成する
◎
If the [LegacyLenientSetter] extended attribute appears on a read only regular attribute, it indicates that a no-op setter will be generated for the attribute’s accessor property.＼
</p>

<p>
その結果，~strict-mode下では、
当の~propに対する誤った代入に対しては，例外は投出されずに無視されるようになる。
◎
This results in erroneous assignments to the property in strict mode to be ignored rather than causing an exception to be thrown.
</p>

<p class="note">注記：
作者が［
ある~IDL属性を，当の~propに代入することにより ~polyfillするよう試みている~page
］があって、
当の~propが存在するときでも不用意にそうしていたとする。
~strict-mode下では、
これは例外を投出させ，~pageを非互換化しかねない。
そのため、
`LegacyLenientSetter$x が無いと，~browserは当の特能を出荷できなくなる。
◎
Pages have been observed where authors have attempted to polyfill an IDL attribute by assigning to the property, but have accidentally done so even if the property exists. In strict mode, this would cause an exception to be thrown, potentially breaking page. Without [LegacyLenientSetter], this could prevent a browser from shipping the feature.
</p>

<p>
`LegacyLenientSetter$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [LegacyLenientSetter] extended attribute must take no arguments.＼
</li>
	<li>
`読専$な`正則~属性$以外に利用してはナラナイ。
◎
It must not be used on anything other than a read only regular attribute.
</li>
	<li>
同じ属性~上で，次に挙げる拡張d属性と伴に宣言してはナラナイ
⇒＃
`PutForwards$x ／
`Replaceable$x
◎
An attribute with the [LegacyLenientSetter] extended attribute must not also be declared with the [PutForwards] or [Replaceable] extended attributes.
</li>
	<li>
`~ns$上で宣言される属性~上に利用してはナラナイ。
◎
The [LegacyLenientSetter] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
`LegacyLenientSetter$x が どう実装されるかについては、
`属性＠#js-attributes§を見よ。
◎
See the Attributes section for how [LegacyLenientSetter] is to be implemented.
</p>

<div class="example">
<p>
次の~IDL片は `LegacyLenientSetter$x 拡張d属性を利用する~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LegacyLenientSetter] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window]
interface Example {
  [LegacyLenientSetter] readonly attribute DOMString x;
  readonly attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~JS実装は，
`x^M に対応する~accessor~prop上に設定子を有することになり、
~strict-mode下では，どのような代入も無視されるようになる。
◎
A JavaScript implementation that supports this interface will have a setter on the accessor property that correspond to x, which allows any assignment to be ignored in strict mode.
</p>

<pre class="lang-js">
"use strict";

var %example = getExample();  /* <span class="comment">
`Example^T の~instanceを取得する。
◎
Get an instance of Example.
</span> */

/* <span class="comment">
~~問題ない。~strict-mode下では，何もしない設定子がある：
◎
Fine; while we are in strict mode, there is a setter that is a no-op.
</span> */
%example.x = 1;

/* <span class="comment">
`TypeError^jE が投出される。~strict-mode下にあり，設定子がないので：
◎
Throws a TypeError, since we are in strict mode and there is no setter.
</span> */
%example.y = 1;
</pre>
</div>

			</section>
			<section id="LegacyLenientThis">
<h4>3.4.3. `LegacyLenientThis^x</h4>

<p>
`LegacyLenientThis$x `拡張d属性$が `正則~属性$に現れた場合、
次を指示する
⇒
当の属性の取得子や設定子に対する［
当の属性が現れる`~ifc$を`実装-$する~objとは異なる `this^jv 値
］を伴う呼出nは，無視されることになる
◎
If the [LegacyLenientThis] extended attribute appears on a regular attribute, it indicates that invocations of the attribute’s getter or setter with a this value that is not an object that implements the interface on which the attribute appears will be ignored.
</p>

<div class="p">
<p>
`LegacyLenientThis$x 拡張d属性は：
</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
</li>
	<li>
`静的~属性$に利用してはナラナイ。
</li>
	<li>
`~ns$上で宣言される属性に利用してはナラナイ。
</li>
</ul>
◎
The [LegacyLenientThis] extended attribute must take no arguments. It must not be used on a static attribute.
◎
The [LegacyLenientThis] extended attribute must not be used on an attribute declared on a namespace.
</div>

<p>
`LegacyLenientThis$x が どう実装されるかについては、
`属性＠#js-attributes§を見よ。
◎
See the Attributes section for how [LegacyLenientThis] is to be implemented.
</p>

<div class="example">
<p>
次の~IDL片は
`LegacyLenientThis$x 拡張d属性を利用する
~ifcを定義する。
◎
The following IDL fragment defines an interface that uses the [LegacyLenientThis] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window]
interface Example {
  [LegacyLenientThis] attribute DOMString x;
  attribute DOMString y;
};
</pre>

<p>
この~ifcを~supportする~JS実装では、
`x^M に対応する~accessor~propの取得子／設定子では，
`Example^T ~obj以外の何かを伴う呼出ngも許容されることになる。
◎
A JavaScript implementation that supports this interface will allow the getter and setter of the accessor property that corresponds to x to be invoked with something other than an Example object.
</p>

<pre class="lang-js">
var %example = getExample();  /* <span class="comment">
`Example^T の~instanceを取得する。
◎
Get an instance of Example.
</span> */
var %obj = { };

/* <span class="comment">
~~通常：
◎
Fine.
</span> */
%example.x;

/* <span class="comment">
`this^jv 値は `Example^T ~objでなく, かつ
`LegacyLenientThis^x が利用されているので、
無視される：
◎
Ignored, since the this value is not an Example object and [LegacyLenientThis] is used.
</span> */
Object.getOwnPropertyDescriptor(Example.prototype, "x").get.call(%obj);

/* <span class="comment">
`Example.prototype^jv は `Example^T ~objでなく, かつ
`LegacyLenientThis^x が利用されているので、
これも無視される：
◎
Also ignored, since Example.prototype is not an Example object and [LegacyLenientThis] is used.
</span> */
Example.prototype.x;

/* <span class="comment">
`Example.prototype^jv は `Example^T ~objでないので `TypeError^jE が投出される：
◎
Throws a TypeError, since Example.prototype is not an Example object.
</span> */
Example.prototype.y;
</pre>
</div>

			</section>
			<section id="LegacyNamespace">
<h4>3.4.4. `LegacyNamespace^x</h4>

<p class="warning">
この特能を利用しなくとも、
一連の~ifc用の~ifc名は，［
~ifcの識別子の一部を成すよう，特定0の接頭辞から開始させる命名~規約
］により形成できる【！without the intervening dot】。
◎
Instead of using this feature, interface names can be formed with a naming convention of starting with a particular prefix for a set of interfaces, as part of the identifier, without the intervening dot.
</p>

<p>
`LegacyNamespace$x `拡張d属性$が`~ifc$に現れた場合、
次を指示する
⇒
当の~ifc用の`~ifc~obj$は、［
大域~objの~propとしてではなく，この拡張d属性の引数により識別される`~ns$の~prop
］として作成される
◎
If the [LegacyNamespace] extended attribute appears on an interface, it indicates that the interface object for this interface will not be created as a property of the global object, but rather as a property of the namespace identified by the argument to the extended attribute.
</p>

<p>
`LegacyNamespace$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
ある`~ns$の`識別子を引数にとる$ことが要求される。
◎
The [LegacyNamespace] extended attribute must take an identifier. This identifier must be the identifier of a namespace definition.
</li>
	<li>
同じ~ifc上で， `LegacyNoInterfaceObject$x 拡張d属性とともに指定してはナラナイ。
◎
The [LegacyNamespace] and [LegacyNoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
</ul>

<p>
~ifcが~nsにどう公開されるかの詳細は、
`~ns~obj＠#namespace-object§を見よ。
◎
See § 3.13.1 Namespace object for details on how an interface is exposed on a namespace.
</p>

<div class="example">
<p>
次の`~IDL片$は、
`~ns$, および
その内側に定義されることになる［
`LegacyNamespace$x を利用する`~ifc$
］を定義する：
◎
The following IDL fragment defines a namespace and an interface which uses [LegacyNamespace] to be defined inside of it.
</p>

<pre class="webidl">
[Exposed=Window]【！＊原文抜け】
namespace Foo { };

[LegacyNamespace=Foo]
interface Bar {
  constructor();
};
</pre>

<p>
上の~nsと~ifcの~JS実装においては、
構築子 `Bar^M は，次のように~accessできる：
◎
In a JavaScript implementation of the above namespace and interface, the constructor Bar can be accessed as follows:
</p>

<pre class="lang-js">
var %instance = new Foo.Bar();
</pre>
</div>

			</section>
			<section id="LegacyNoInterfaceObject">
<h4>3.4.5. `LegacyNoInterfaceObject^x</h4>

<p>
`LegacyNoInterfaceObject$x `拡張d属性$が`~ifc$に現れた場合、
次を指示する
⇒
当の~ifc用の`~ifc~obj$は、
~JS言語束縛には存在しないことになる
◎
If the [LegacyNoInterfaceObject] extended attribute appears on an interface, it indicates that an interface object will not exist for the interface in the JavaScript binding.
</p>

<p>
`LegacyNoInterfaceObject$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [LegacyNoInterfaceObject] extended attribute must take no arguments.
</li>
	<li>
［
`構築子$／`静的~演算$
］が定義されている~ifcに指定してはナラナイ。
◎
The [LegacyNoInterfaceObject] extended attribute must not be specified on an interface that has any constructors or static operations defined on it.
</li>
	<li>
この拡張d属性が指定されていない~ifcは、
この拡張d属性が指定されている~ifcを継承してはナラナイ
◎
An interface that does not have the [LegacyNoInterfaceObject] extended attribute specified must not inherit from an interface that has the [LegacyNoInterfaceObject] extended attribute specified.
</li>
</ul>

<p>
`LegacyNoInterfaceObject$x の利用に課される特有な要件については、
`~ifc＠#js-interfaces§を見よ。
◎
See § 3.7 Interfaces for the specific requirements that the use of [LegacyNoInterfaceObject] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの~ifcを定義する。
一方はその~ifc~objが~JS大域~obj上に公開され，他方はそうでない：
◎
The following IDL fragment defines two interfaces, one whose interface object is exposed on the JavaScript global object, and one whose isn’t:
</p>

<pre class="webidl">
[Exposed=Window]
interface Storage {
  undefined addEntry(unsigned long %key, any %value);
};

[Exposed=Window,
 LegacyNoInterfaceObject]
interface Query {
  any lookupEntry(unsigned long %key);
};
</pre>

<p>
上の~IDLの~JS実装においては、
`Storage^T の原型に対する操作は許容される一方，
`Query^T に対してはそうならない。
◎
A JavaScript implementation of the above IDL would allow manipulation of Storage’s prototype, but not Query’s.
</p>

<pre class="lang-js">
typeof Storage;                        /* <span class="comment">
`object^l に評価される。
◎
evaluates to "object"
</span> */

/* <span class="comment">
`Storage.addEntry^c に~trace用の `alert()^c ~callを追加する：
◎
Add some tracing alert() call to Storage.addEntry.
</span> */
var %fn = Storage.prototype.addEntry;
Storage.prototype.addEntry = function(%key, %value) {
  alert('Calling addEntry()');
  return %fn.call(this, %key, %value);
};

typeof Query;                          /* <span class="comment">
`undefined^l に評価される。
◎
evaluates to "undefined"
</span> */
var %fn = Query.prototype.lookupEntry;  /* <span class="comment">
例外が投出される。 `Query^T は定義されていないので。
◎
exception, Query isn’t defined
</span> */
</pre>
</div>

			</section>
			<section id="LegacyNullToEmptyString">
<h4>3.4.6. `LegacyNullToEmptyString^x</h4>

<p>
`LegacyNullToEmptyString$x `拡張d属性$が［
`DOMString$T ／ `USVString$T
］型に現れた場合、
次に従ってふるまう，新たな型を作成する
⇒
~JS `null^jv 値がこの~IDL型に変換される際には、
既定による `null^l に文字列~化される代わりに，空~文字列に変換される
◎
If the [LegacyNullToEmptyString] extended attribute appears on the DOMString or USVString type, it creates a new IDL type such that that when a JavaScript null is converted to the IDL type, it will be handled differently from its default handling. Instead of being stringified to "null", which is the default, it will be converted to the empty string.
</p>

<p>
`LegacyNullToEmptyString$x `拡張d属性が結付けられ$た型は、［
`DOMString$T ／ `USVString$T
］でなければナラナイ。
◎
The [LegacyNullToEmptyString] extended attribute must not be associated with a type that is not DOMString or USVString.
</p>

<p class="note">注記：
すなわち、
`DOMString?^T 型であっても，
`LegacyNullToEmptyString$x を利用してはならない
— `null^V はその型の妥当な値なので。
◎
Note: This means that even DOMString? must not use [LegacyNullToEmptyString], since null is a valid value of that type.
</p>

<p>
`LegacyNullToEmptyString$x の利用に課される特有な要件については、
`DOMString＠#js-DOMString§T を見よ。
◎
See § 3.2.10 DOMString for the specific requirements that the use of [LegacyNullToEmptyString] entails.
</p>

<div class="example">
<p>
次の`~IDL片$が定義する［
属性 ／ 演算がとる引数
］の型は、
`LegacyNullToEmptyString$x 拡張d属性を有している：
◎
The following IDL fragment defines an interface that has one attribute whose type has the extended attribute, and one operation whose argument’s type has the extended attribute:
</p>

<pre class="webidl">
[Exposed=Window]
interface Dog {
  attribute DOMString name;
  attribute [LegacyNullToEmptyString] DOMString owner;

  boolean isMemberOfBreed([LegacyNullToEmptyString] DOMString %breedName);
};
</pre>

<p>
`Dog^T ~ifcを実装する~JS実装においては、［
`owner^jp ~propに代入される `null^jv 値／
`isMemberOfBreed^M 関数の引数に渡される `null^jv 値
］は，
`null^l ではなく空~文字列に変換されることになる：
◎
A JavaScript implementation implementing the Dog interface would convert a null value assigned to the owner property or passed as the argument to the isMemberOfBreed function to the empty string rather than "null":
</p>

<pre class="lang-js">
var %d = getDog();
       /* <span class="comment">
%d は `Dog^T ~ifcを実装する~platform~objとする。
◎
Assume d is a platform object implementing the Dog interface.
</span> */

%d.name = null;
       /* <span class="comment">
文字列 `null^l を `.name^jp ~propに代入する。
◎
This assigns the string "null" to the .name property.
</span> */

%d.owner = null;
       /* <span class="comment">
文字列 "" を `.owner^jp ~propに代入する。
◎
This assigns the string "" to the .owner property.
</span> */

%d.isMemberOfBreed(null);
       /* <span class="comment">
文字列 "" を `isMemberOfBreed^M 関数に渡す。
◎
This passes the string "" to the isMemberOfBreed function.
</span> */
</pre>
</div>

			</section>
			<section id="LegacyOverrideBuiltIns">
<h4>3.4.7. `LegacyOverrideBuiltIns^x</h4>

<p>
`LegacyOverrideBuiltIns$x `拡張d属性$が`~ifc$に現れた場合、
次を指示する
⇒
当の~ifcを実装する`旧来の~platform~obj$ %O においては
— ［
%O や %O の原型鎖
］上に存在する他の~propに関わらず —
各［
%O が`~supportする~prop名$
］に対し，対応する~propが %O に現れることになる
◎
If the [LegacyOverrideBuiltIns] extended attribute appears on an interface, it indicates that for a legacy platform object implementing the interface, properties corresponding to all of the object’s supported property names will appear to be on the object, regardless of what other properties exist on the object or its prototype chain.＼
</p>

<p>
このことは、
次を意味する
⇒
有名~propは、［
さもなければ %O に現れることになる，同じ名前の~prop
］が在れば，常にそれを隠蔽することになる
（対照的に，通例の挙動では、
有名~propは，［［
%O 自身や %O の原型鎖
］のどこにも同じ名前の~propが存在しない
］ときに限り公開される）
◎
This means that named properties will always shadow any properties that would otherwise appear on the object. This is in contrast to the usual behavior, which is for named properties to be exposed only if there is no property with the same name on the object itself or somewhere on its prototype chain.
</p>

<div class="p">
<p>
`LegacyOverrideBuiltIns$x `拡張d属性$は：
</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
</li>
	<li>
`有名~prop取得子$を定義しない~ifcに現れてはナラナイ。
</li>
	<li>
`Global$x `拡張d属性$とともに宣言されてはナラナイ。
</li>
	<li>
`部分的な~ifc定義$ %J に指定される場合、
%J は，当の~ifc定義の中で`有名~prop取得子$を定義する部分を成していなければナラナイ。
</li>
</ul>

◎
The [LegacyOverrideBuiltIns] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter or that also is declared with the [Global] extended attribute. If the extended attribute is specified on a partial interface definition, then that partial interface definition must be the part of the interface definition that defines the named property getter.
</div>

<p>
`LegacyOverrideBuiltIns$x 拡張d属性が`部分的な~ifc定義$上に指定された場合、
~ifc自身に現れるものと見なされる。
◎
If the [LegacyOverrideBuiltIns] extended attribute is specified on a partial interface definition, it is considered to appear on the interface itself.
</p>

<p>
`LegacyOverrideBuiltIns$x の利用に課される特有な要件については、
`旧来の~platform~obj＠#js-legacy-platform-objects§,
`DefineOwnProperty＠#legacy-platform-object-defineownproperty§sl
を見よ。
◎
See § 3.9 Legacy platform objects and § 3.9.3 [[DefineOwnProperty]] for the specific requirements that the use of [LegacyOverrideBuiltIns] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は 2 つの`~ifc$を定義する。
一方には`有名~prop取得子$があり, 他方には無い：
◎
The following IDL fragment defines two interfaces, one that has a named property getter and one that does not.
</p>

<pre class="webidl">
[Exposed=Window]
interface StringMap {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString %key);
};

[Exposed=Window,
 LegacyOverrideBuiltIns]
interface StringMap2 {
  readonly attribute unsigned long length;
  getter DOMString lookup(DOMString %key);
};
</pre>

<p>
これら 2 つの~ifcの~JS実装においては、
各~ifcを実装する~objの一部の~propについて，それを取得した結果が異なってくることになる：
◎
In a JavaScript implementation of these two interfaces, getting certain properties on objects implementing the interfaces will result in different values:
</p>

<pre class="lang-js">
/* <span class="comment">
`StringMap^T の~instanceを得する。
~supportする~prop名として， `abc^l, `length^l, `toString^l を有するとする：
◎
Obtain an instance of StringMap.  Assume that it has "abc", "length" and "toString" as supported property names.
</span> */
var %map1 = getStringMap();

/* <span class="comment">
有名~prop取得子を呼出す：
◎
This invokes the named property getter.
</span> */
%map1.abc;

/* <span class="comment">
`length^M 属性に対応する~objの `length^jp ~propを取りに行く：
◎
This fetches the "length" property on the object that corresponds to the length attribute.
</span> */
%map1.length;

/* <span class="comment">
~objの原型鎖~上の `toString^jp ~propを取りに行く：
◎
This fetches the "toString" property from the object’s prototype chain.
</span> */
%map1.toString;

/* <span class="comment">
`StringMap2^T の~instanceを得する
— これも、
~supportする~prop名として， `abc^l, `length^l, `toString^l を有するとする：
◎
Obtain an instance of StringMap2.  Assume that it also has "abc", "length" and "toString" as supported property names.
</span> */
var %map2 = getStringMap2();

/* <span class="comment">
これは、
有名~prop取得子を呼出す：
◎
This invokes the named property getter.
</span> */
%map2.abc;

/* <span class="comment">
これも、
有名~prop取得子を呼出す
— ~objの `length^jp ~propが length 属性に対応しているにも関わらず：
◎
This also invokes the named property getter, despite the fact that the "length" property on the object corresponds to the length attribute.
</span> */
%map2.length;

/* <span class="comment">
これもまた、
有名~prop取得子を呼出す
— `toString^l が %map2 の prototype chain 内にある~propであるにも関わらず：
◎
This too invokes the named property getter, despite the fact that "toString" is a property in map2’s prototype chain.
</span> */
%map2.toString;
</pre>
</div>

			</section>
			<section id="LegacyTreatNonObjectAsNull">
<h4>3.4.8. `LegacyTreatNonObjectAsNull^x</h4>

<p>
`LegacyTreatNonObjectAsNull$x `拡張d属性$が`~callback関数$に現れた場合、
次を指示する
⇒
`属性$のうち［
`~nullable$かつ当の`~callback関数$型であるもの
］に代入される どの値も次に従って
— もっと~~緩く —
変換する
⇒＃
当の値は~objでない場合， `null^V に変換する／
当の値は`~callable$でもない場合，~callされても何もしない`~callback関数$値に変換する
◎
If the [LegacyTreatNonObjectAsNull] extended attribute appears on a callback function, then it indicates that any value assigned to an attribute whose type is a nullable callback function will be converted more loosely: if the value is not an object, it will be converted to null, and if the value is not callable, it will be converted to a callback function value that does nothing when called.
</p>

<p>
`LegacyTreatNonObjectAsNull$x の利用に課される特有な要件については、
`~nullable型＠#js-nullable-type§,
`~callback関数~型＠#js-callback-function§,
`~callback関数の呼出ng＠#js-invoking-callback-functions§
を見よ。
◎
See § 3.2.20 Nullable types — T?, § 3.2.19 Callback function types and § 3.12 Invoking callback functions for the specific requirements that the use of [LegacyTreatNonObjectAsNull] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は、
`LegacyTreatNonObjectAsNull$x で注釈された`~callback関数$型の属性と,
この`拡張d属性$を伴わない`~callback関数$を有する~ifcを定義する。
◎
The following IDL fragment defines an interface that has one attribute whose type is a [LegacyTreatNonObjectAsNull]-annotated callback function and another whose type is a callback function without the extended attribute:
</p>

<pre class="webidl">
callback OccurrenceHandler = undefined (DOMString %details);

[LegacyTreatNonObjectAsNull]
callback ErrorHandler = undefined (DOMString %details);

[Exposed=Window]
interface Manager {
  attribute OccurrenceHandler? handler1;
  attribute ErrorHandler? handler2;
};
</pre>

<p>
~JS実装においては、［
~objでない値（ `Number^jt 値など）／`~callable$でない値
］を
`handler1^M に代入したときと,
`handler2^M に代入したときとでは，挙動が異なる：
◎
In a JavaScript implementation, assigning a value that is not an object (such as a Number value), or that is not callable to handler1 will have different behavior from that when assigning to handler2:
</p>

<pre class="lang-js">
var %manager = getManager();  /* <span class="comment">
`Manager^T の~instanceを取得する。
◎
Get an instance of Manager.
</span> */

%manager.handler1 = function() { };
%manager.handler1;            /* <span class="comment" id="cp-eval-the-function">
当の function に評価される。
◎
Evaluates to the function.
</span> */

try {
  %manager.handler1 = 123;    /* <span class="comment" id="cp-throws-a-typeerror">
`TypeError^jE が投出される。
◎
Throws a TypeError.
</span> */
} catch (%e) {
}

try {
  %manager.handler1 = {};     /* <!--cp-throws-a-typeerror--> */
} catch (%e) {
}

%manager.handler2 = function() { };
%manager.handler2;            /* <!--cp-eval-the-function--> */

%manager.handler2 = 123;
%manager.handler2;            /* <span class="comment">
`null^jv に評価される。
◎
Evaluates to null.
</span> */

%manager.handler2 = {};
%manager.handler2;            /* <span class="comment">
`object^jt に評価される。
◎
Evaluates to the object.
</span> */
</pre>
</div>

			</section>
			<section id="LegacyUnenumerableNamedProperties">
<h4>3.4.9. `LegacyUnenumerableNamedProperties^x</h4>

<p id="dfn-unenumerable">
`LegacyUnenumerableNamedProperties$x `拡張d属性$が［
`有名~propを~support$する`~ifc$
］に現れた場合、
次を指示する
⇒
当の~ifcの有名~propは、
すべて列挙-不能である
◎
If the [LegacyUnenumerableNamedProperties] extended attribute appears on a interface that supports named properties, it indicates that all the interface’s named properties are unenumerable.
</p>

<div class="p">
<p>
`LegacyUnenumerableNamedProperties$x 拡張d属性は：
</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
</li>
	<li>
`有名~prop取得子$を定義しない~ifcに現れてはナラナイ。
</li>
	<li>
当の~ifcのすべての派生~ifcにも適用され、
それらには，この拡張d属性を指定してはナラナイ。
</li>
</ul>

◎
The [LegacyUnenumerableNamedProperties] extended attribute must take no arguments and must not appear on an interface that does not define a named property getter.
◎
If the [LegacyUnenumerableNamedProperties] extended attribute is specified on an interface, then it applies to all its derived interfaces and must not be specified on any of them.
</div>

<p>
`LegacyUnenumerableNamedProperties$x の利用に課される特有な要件については、
`GetOwnProperty＠#legacy-platform-object-getownproperty§sl を見よ。
◎
See § 3.9.1 [[GetOwnProperty]] for the specific requirements that the use of [LegacyUnenumerableNamedProperties] entails.
</p>

			</section>
			<section id="LegacyUnforgeable">
<h4>3.4.10. `LegacyUnforgeable^x</h4>

<p>
`LegacyUnforgeable$x `拡張d属性$が［
`正則~属性$／`静的$oPでない`演算$
］に現れた場合、
次を指示する
⇒
当の［
属性／演算
］は，次の仕方で~JS~propとして反映されることになる
⇒＃
その挙動を改変できない／
~obj上で~prop検索が遂行された際には，常に当の属性の~prop値が返される
◎
If the [LegacyUnforgeable] extended attribute appears on regular attributes or non-static operations, it indicates that the attribute or operation will be reflected as a JavaScript property in a way that means its behavior cannot be modified and that performing a property lookup on the object will always result in the attribute’s property value being returned.＼
</p>

<p>
特に，そのような~propは、
~configure不能になり，かつ［
~objの原型~上ではなく, ~objの自前の~prop
］として存在することになる。
◎
In particular, the property will be non-configurable and will exist as an own property on the object itself rather than on its prototype.
</p>

<p>
所与の~ifc %A 上の［
属性／演算
］のうち，
`LegacyUnforgeable$x `拡張d属性$で注釈されて宣言されたものは、
%A 上で
`偽造-不能@
であるとされる。
◎
An attribute or operation is said to be unforgeable on a given interface A if the attribute or operation is declared on A, and is annotated with the [LegacyUnforgeable] extended attribute.
</p>

<p>
`LegacyUnforgeable$x `拡張d属性$は：
◎
↓</p>
<ul>
	<li>
`引数をとらない$ことが要求される。
◎
The [LegacyUnforgeable] extended attribute must take no arguments.
</li>
	<li>
次に挙げるもの以外の所に現れてはナラナイ
⇒＃
`正則~属性$／
`静的$oPでない`演算$
◎
The [LegacyUnforgeable] extended attribute must not appear on anything other than a regular attribute or a non-static operation.＼
</li>
	<li>
ある演算に現れるならば、
その~ifc上で同じ識別子を有する他のすべての演算にも現れなければナラナイ。
◎
If it does appear on an operation, then it must appear on all operations with the same identifier on that interface.
</li>
	<li>
`~ns$上で宣言される属性に利用してはナラナイ。
◎
The [LegacyUnforgeable] extended attribute must not be used on an attribute declared on a namespace.
</li>
</ul>

<p>
~ifc %A の［
属性／演算
］ %m が`偽造-不能$である場合、［
別の~ifc %B のうち，それが`継承した~ifc群$が %A を含むもの
］は，
%m と同じ`識別子$を有する［
`正則~属性$／`静的$oPでない`演算$
］を有してはナラナイ。
◎
If an attribute or operation X is unforgeable on an interface A, and A is one of the inherited interfaces of another interface B, then B must not have a regular attribute or non-static operation with the same identifier as X.
</p>

<div class="note">
<p>注記：
例えば，次は許容されない：
◎
For example, the following is disallowed:
</p>

<pre class="webidl">
[Exposed=Window]
interface A1 {
[LegacyUnforgeable] readonly attribute DOMString x;
};
[Exposed=Window]
interface B1 : A1 {
  undefined x();  /* <span class="comment">
妥当でない
— `A1^T の `x^M で隠蔽されるので。
◎
Invalid; would be shadowed by A1’s x.
</span> */
};

[Exposed=Window]
interface B2 : A1 { };
B2 includes M1;
interface mixin M1 {
  undefined x();  /* <span class="comment">
妥当でない
— `B2^T における `x^M の複製は `A1^T の `x^M で隠蔽されるので。
◎
Invalid; B2’s copy of x would be shadowed by A1’s x.
</span> */
};
</pre>
</div>

<p>
`LegacyUnforgeable$x の利用に課される特有な要件については、
`属性＠#js-attributes§,
`演算＠#js-operations§,
`~ifcを実装している~platform~obj＠#js-platform-objects§,
`旧来の~platform~obj＠#js-legacy-platform-objects§,
`DefineOwnProperty＠#legacy-platform-object-defineownproperty§sl
を見よ。
◎
See § 3.7.6 Attributes, § 3.7.7 Operations, § 3.8 Platform objects implementing interfaces, § 3.9 Legacy platform objects and § 3.9.3 [[DefineOwnProperty]] for the specific requirements that the use of [LegacyUnforgeable] entails.
</p>

<div class="example">
<p>
次の`~IDL片$は
片方に `LegacyUnforgeable$x が指定された 2 個の`属性$を有する~ifcを定義する：
◎
The following IDL fragment defines an interface that has two attributes, one of which is designated as [LegacyUnforgeable]:
</p>

<pre class="webidl">
[Exposed=Window]
interface System {
  [LegacyUnforgeable] readonly attribute DOMString username;
  readonly attribute long long loginTime;
};
</pre>

<p>
この~ifcの~JS実装においては、
`username^M 属性は，~obj自身において~configure不能な~propとして公開されることになる：
◎
In a JavaScript implementation of the interface, the username attribute will be exposed as a non-configurable property on the object itself:
</p>

<pre class="lang-js">
var %system = getSystem();         /* <span class="comment">
`System^T の~instanceを取得する。
◎
Get an instance of System.
</span> */

%system.hasOwnProperty("username");             /* <!--cp-eval-true--> */
%system.hasOwnProperty("loginTime");            /* <!--cp-eval-false--> */
System.prototype.hasOwnProperty("username");   /* <!--cp-eval-false--> */
System.prototype.hasOwnProperty("loginTime");  /* <!--cp-eval-true--> */

try {
  /* <span class="comment">
次の~callは失敗することになる — ~propは~configure不能なので：
◎
This call would fail, since the property is non-configurable.
</span> */
  Object.defineProperty(system, "username", { value: "administrator" });
} catch (%e) { }

/* <span class="comment">
次の `defineProperty^jp ~callは成功する
— `System.prototype.loginTime^c が~configure可能なので：
◎
This defineProperty call would succeed, because System.prototype.loginTime is configurable.
</span> */
var %forgedLoginTime = 5;
Object.defineProperty(System.prototype, "loginTime", { value: %forgedLoginTime });

%system.loginTime;  /* <span class="comment">
よって，これは今や %forgedLoginTime に評価される。
◎
So this now evaluates to forgedLoginTime.
</span> */
</pre>
</div>

			</section>
			<section id="LegacyWindowAlias">
<h4>3.4.11. `LegacyWindowAlias^x</h4>

<p>
`LegacyWindowAlias$x `拡張d属性$が`~ifc$ %I に現れた場合、
次を指示する
⇒
`Window$T `~ifc$は、
当の拡張d属性の引数として挙げられた各`識別子$に対し，
%I 用の`~ifc~obj$を値にとる~propを有することになる
◎
If the [LegacyWindowAlias] extended attribute appears on an interface, it indicates that the Window interface will have a property for each identifier mentioned in the extended attribute, whose value is the interface object for the interface.
</p>

<p>
`LegacyWindowAlias$x 拡張d属性は：
◎
↓</p>
<ul>
	<li>
［
`識別子を引数にとる$か`識別子~listを引数にとる$
］ことが要求される。
`=^sym の直後に~~現れる `identifier$g が，各 `LegacyWindowAlias$x の
`識別子@wA
を与える。
◎
The [LegacyWindowAlias] extended attribute must either take an identifier or take an identifier list. The identifiers that occur after the “=” are the [LegacyWindowAlias]'s identifiers.
</li>
	<li>
<p>
次に挙げる識別子は、
`LegacyWindowAlias$x 用の`識別子$wAとして利用してはナラナイ：
</p>
		<ul>
			<li>
当のまたは別の~ifcの `LegacyWindowAlias$x 拡張d属性に利用されている`識別子$wA
</li>
			<li>
当のまたは別の~ifcの `LegacyFactoryFunction$x 拡張d属性に利用されている`識別子$fF
</li>
			<li>
`~ifc~obj$を有する~ifcの`識別子$
</li>
			<li>
`予約-済み識別子$
</li>
		</ul>
◎
Each of the identifiers of [LegacyWindowAlias] must not be the same as one used by a [LegacyWindowAlias] extended attribute on this interface or another interface, must not be the same as the identifier used by a [LegacyFactoryFunction] extended attribute on this interface or another interface, must not be the same as an identifier of an interface that has an interface object, and must not be one of the reserved identifiers.
</li>
	<li>
同じ~ifc上で， `LegacyNoInterfaceObject$x 拡張d属性とともに指定してはナラナイ。
◎
The [LegacyWindowAlias] and [LegacyNoInterfaceObject] extended attributes must not be specified on the same interface.
</li>
	<li>
同じ~ifc上で， `LegacyNamespace$x 拡張d属性とともに指定してはナラナイ。
◎
The [LegacyWindowAlias] and [LegacyNamespace] extended attributes must not be specified on the same interface.
</li>
	<li>
自身の`公開~集合$内に `Window$T `~ifc$を含んでいない~ifcには、
指定してはナラナイ。
◎
The [LegacyWindowAlias] extended attribute must not be specified on an interface that does not include the Window interface in its exposure set.
</li>
	<li>
同じ~ifc上に複数~個 指定してはナラナイ。
◎
An interface must not have more than one [LegacyWindowAlias] extended attributes specified.
</li>
</ul>

<p>
`LegacyWindowAlias^x が どう実装されるかの詳細は、
`~ifc＠#js-interfaces§を見よ。
◎
See § 3.7 Interfaces for details on how legacy window aliases are to be implemented.
</p>

<div class="example">
<p>
次の~IDLは
`LegacyWindowAlias$x 拡張d属性を利用する~ifcを定義する。
◎
The following IDL defines an interface that uses the [LegacyWindowAlias] extended attribute.
</p>

<pre class="webidl">
[Exposed=Window,
 LegacyWindowAlias=WebKitCSSMatrix]
interface DOMMatrix : DOMMatrixReadOnly {
  /* ... */
};
</pre>

<p>
この~ifcを~supportする~JS実装は、
`Window$T ~obj上に，同じ値, 同じ特性を備える 2 個の~propを公開することになる
— 1 つは`~ifc~obj$を通常に公開するためのもの，もう 1 つは それを旧来の名前で公開するためのもの。
◎
A JavaScript implementation that supports this interface will expose two properties on the Window object with the same value and the same characteristics; one for exposing the interface object normally, and one for exposing it with a legacy name.
</p>

<pre class="lang-js">
WebKitCSSMatrix === DOMMatrix;     /* <!--cp-eval-true--> */

var %m = new WebKitCSSMatrix();     /* <span class="comment">
`DOMMatrix^T を実装する新たな~objを作成する。
◎
Creates a new object that implements DOMMatrix.
</span> */

%m.constructor === DOMMatrix;       /* <!--cp-eval-true--> */
%m.constructor === WebKitCSSMatrix; /* <!--cp-eval-true--> */
{}.toString.call(%m);               /* <span class="comment">
`[object DOMMatrix]^l に評価される。
◎
Evaluates to '[object DOMMatrix]'.
</span> */
</pre>
</div>

			</section>
		</section>
		<section id="js-security">
<h3 title="Security">3.5. ~security検査</h3>

<p>
以下の節の一部の~algoでは、
所与の~objに対し
`~security検査を遂行する@
ものがある。
この検査は、
所与の［
`演算$／`属性$
］ %m に対する［
呼出n／~access
］が許容されるべきかどうかを決定するために利用される。
~security検査は、
次の 3 つを入力にとる：
◎
Certain algorithms in the sections below are defined to perform a security check on a given object. This check is used to determine whether a given operation invocation or attribute access should be allowed. The security check takes the following three inputs:
</p>
<ol>
	<li>
［
%m の呼出n ／ %m への~access
］が行われている当の`~platform~obj$
◎
the platform object on which the operation invocation or attribute access is being done,
</li>
	<li>
%m の`識別子$
◎
the identifier of the operation or attribute, and
</li>
	<li>
<p>
%m を実装する`関数~obj$の種別
— 次のいずれかとして与えられる：
</p>
		<ul>
			<li>
`~method^C
（ %m が演算に対応するとき）
</li>
			<li>
`取得子^C
（ %m が “取得子” 関数に対応するとき）
</li>
			<li>
`設定子^C
（ %m が “設定子” 関数に対応するとき）
</li>
		</ul>
◎
the type of the function object – "method" (when it corresponds to an IDL operation), or "getter" or "setter" (when it corresponds to the getter or setter function of an IDL attribute).
</li>
</ol>

<p class="note">注記：
~security検査がどう遂行されるかは、
~HTML仕様が定義する。
`HTML$r
【`参照＠~HTMLWPROXY#integration-with-idl$】
◎
Note: The HTML Standard defines how a security check is performed. [HTML]
</p>

		</section>
		<section id="js-overloads">
<h3 title="Overload resolution algorithm">3.6. 多重定義~解決~algo</h3>

<div class="algo">
<p>
`関数~類$の呼出nを解決するために，
`多重定義~解決~algo@
が定義される
【その名に反し、この~algoは，多重定義されていなくとも呼出される】
：
◎
In order to define how function invocations are resolved, the overload resolution algorithm is defined.＼
</p>
<ul>
	<li>
その入力は
⇒＃
`有効-多重定義~集合$ %S,
~JS値たちが成す`~list$ %引数~群
◎
Its input is an effective overload set, S, and a list of JavaScript values, args.＼
</li>
	<li>
その出力は，次が成す~pairである
⇒＃
%S を成すいずれかの~entryの［`演算$／`拡張d属性$（構築子）］,
`~Web~IDL引数~list$
◎
Its output is a pair consisting of the operation or extended attribute of one of S’s entries and a list of IDL values or the special value “missing”.＼
</li>
</ul>

<p>
~algoは次に従って挙動する：
◎
The algorithm behaves as follows:
</p>
<ol>
	<li>
%最大~引数~個数 ~LET
%S 内の各~entryの`型~list$oLの`~size$のうち，最大
◎
Let maxarg be the length of the longest type list of the entries in S.
</li>
	<li id="cp-let-n-args-size">
%n ~LET %引数~群 の`~size$
◎
Let n be the size of args.
</li>
	<li>
%引数~個数 ~LET `min^op( %最大~引数~個数, %n )
◎
Initialize argcount to be min(maxarg, n).
</li>
	<li>
%S から，次を満たす~entryはすべて除去する
⇒
`型~list$oL の長さ ~NEQ %引数~個数
◎
Remove from S all entries whose type list is not of length argcount.
</li>
	<li>
~IF［
%S は空である
］
⇒
`~THROW$ `TypeError$jt
◎
If S is empty, then throw a TypeError.
</li>
	<li>
%d ~LET 0
◎
Initialize d to −1.
</li>
	<li>
%~method ~LET `undefined^jv
◎
Initialize method to undefined.
</li>
	<li>
~IF［
%S を成す~entryは複数個ある
］
⇒
%d ~SET それらの~entryの`判別~引数~index$
◎
If there is more than one entry in S, then set d to be the distinguishing argument index for the entries of S.
</li>
	<li>
%値~群 ~LET 空~list（`~Web~IDL引数~list$）
◎
Initialize values to be an empty list, where each entry will be either an IDL value or the special value “missing”.
</li>
	<li>
<p>
~EACH( %i ~IN { 0 〜 %d ~MINUS 1 } )
に対し，昇順に：
◎
Initialize i to 0.
◎
While i &lt; d:
</p>
		<ol>
			<li>
%V ~LET %引数~群[ %i ]
◎
Let V be args[i].
</li>
			<li>
<p>
%型 ~LET ［
%S から~~任意に選んだ~entry
］の`型~list$oL[ %i ]
◎
Let type be the type at index i in the type list of any entry in S.
</p>

<p class="note">注記：
この時点では、
%S を成すすべての~entryにわたり，
`型~list$oL[ %i ] は互いに同じ, かつ
`省略可否~list$oL[ %i ] は互いに同じである。
◎
Note: All entries in S at this point have the same type and optionality value at index i.
</p>
			</li>
			<li>
%省略可否 ~LET ［
%S から~~任意に選んだ~entry
］の`省略可否~list$oL[ %i ]
◎
Let optionality be the value at index i in the list of optionality values of any entry in S.
</li>
			<li id="cp-if-optional">
~IF［
%省略可否 ~EQ `省略可能^C
］~AND［
%V ~EQ `undefined^jv
］
⇒
%値~群 に `既定~値？^C を付加する
◎
If optionality is “optional” and V is undefined, then:
• If the argument at index i is declared with a default value, then append to values that default value.
• Otherwise, append to values the special value “missing”.
</li>
			<li id="cp-append-convert1">
~ELSE
⇒
%値~群 に次の結果を付加する
⇒
`~IDL値に変換する$( %V, %型 )
◎
Otherwise, append to values the result of converting V to IDL type type.
◎
Set i to i + 1.
</li>
		</ol>

<p class="trans-note">【
`既定~値？^C
— 原文のこの段では，~index %i に位置する引数の`既定~値$について取扱っているが、
その引数が %S 内のどの~entryの`~callable$oLに属するのかは，この時点では決定できない。
既定~値の有無，その値は、
~entryごとに異なるかもしれない。
そのため、
ここでは暫定的な値 `既定~値？^C を導入して，その取扱いを後の段へ先送りしている。
】</p>

	</li>
	<li>
<div class="algo">
<p>
%~entry ~LET 次の手続きを遂行した結果：
</p>
		<ol>
			<li>
~IF［
%S は 1 個の~entryのみからなる
］
⇒
~RET その~entry
◎
If i = d, then:
</li>
			<li>
<p>
%V ~LET %引数~群[ %d ]
◎
Let V be args[i].
</p>

<p class="note">注記：
この引数が、
多重定義を解決するために利用される。
◎
Note: This is the argument that will be used to resolve which overload is selected.
</p>
			</li>
			<li>
<p>
~IF［
%V ~EQ `undefined^jv
］~AND［
%S 内の~entryとして［
その`省略可否~list$oL[ %d ] ~EQ `省略可能^C
］を満たすものが在る
］
⇒
~RET 該当する~entry
</p>

<p class="trans-note">【
%S （`有効-多重定義~集合$）に課される拘束,
%d （`判別~引数~index$）の定義により，該当する~entryは 1 個に限られる。
次の段も同様。
】</p>
◎
If V is undefined, and there is an entry in S whose list of optionality values has “optional” at index i, then remove from S all other entries.
</li>
			<li>
~ELIF［［
%V ~IN { `null^jv, `undefined^jv }
］~AND［
%S 内の~entryとして［
その `型~list$oL[ %d ] は `~nullable型を内包する$
］ものは在る
］
⇒
~RET 該当する~entry
◎
↓</li>
			<li>
<p>
この段においては、
次の “多重定義~選別~表t” を利用する：
</p>

<p class="trans-note">【
簡潔するため，この段の内容は、
その~logicを［
この表t, その下に与える手続き
］に分割することにより，
原文を再構成している。
】</p>

<table>
<thead>
<tr><th>%V が満たす条件
<th>%型~集合
<tbody>

<tr><td>
［
`null^jv ／ `undefined^jv
］である
◎
Otherwise: if V is null or undefined, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`辞書~型$
◎
• a nullable type
• a dictionary type
• an annotated type whose inner type is one of the above types
• a union type or annotated union type that includes a nullable type or that has a dictionary type in its flattened members
◎
then remove from S all other entries.

<tr><td>
`~platform~objである$
◎
Otherwise: if V is a platform object, and there is an entry in S that has one of the following types at position i of its type list,
<td>
%V が`実装-$する`~ifc型$, `object$T
◎
• an interface type that V implements
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
［
`Object$jt である
］~AND［
`ArrayBufferData^sl `内部~slot$を有する
］
◎
Otherwise: if V is an Object, V has an [[ArrayBufferData]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`ArrayBuffer$T,
`SharedArrayBuffer$T,
`object$T
◎
• ArrayBuffer
• SharedArrayBuffer
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
［
`Object$jt である
］~AND［
`DataView^sl `内部~slot$を有する
］
◎
Otherwise: if V is an Object, V has a [[DataView]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`DataView$T, `object$T
◎
• DataView
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
［
`Object$jt である
］~AND［
`TypedArrayName^sl `内部~slot$を有する
］
◎
Otherwise: if V is an Object, V has a [[TypedArrayName]] internal slot, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`有型~配列~型$のうち［
その名前 ~EQ %V の `TypedArrayName^sl `内部~slot$
］を満たすもの, `object$T
◎
• a typed array type whose name is equal to the value of V’s [[TypedArrayName]] internal slot
• object
• a nullable version of either of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`IsCallable$A( %V ) ~EQ ~T
◎
Otherwise: if IsCallable(V) is true, and there is an entry in S that has one of the following types at position i of its type list,
<td>
`~callback関数~型$, `object$T
◎
• a callback function type
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Object$jt である
— `(A)^i
◎
Otherwise: if V is an Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`非同期c連列~型$
◎
• an async sequence type
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
and the following are not all true,
• V has a [[StringData]] internal slot
• S has one of the following types at position i of its type list,
•• a string type
•• a nullable version of a string type
•• an annotated type whose inner type is a string type
•• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
and after performing the following steps,
• Let method be ? GetMethod(V, %Symbol.asyncIterator%).
• If method is undefined, then set method to ? GetMethod(V, %Symbol.iterator%).
◎
method is not undefined, then remove from S all other entries.

<tr><td>
`Object$jt である
— `(B)^i
◎
Otherwise: if V is an Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`連列~型$
◎
• a sequence type
• a nullable version of any of the above types
• an annotated type whose inner type is a sequence type
• a union type, nullable union type, or annotated union type that has a sequence type in its flattened member types
◎
and after performing the following steps,
• Let method be ? GetMethod(V, %Symbol.iterator%).
◎
method is not undefined, then remove from S all other entries.

<tr><td>
`Object$jt である
◎
Otherwise: if V is an Object and there is an entry in S that has one of the following types at position i of its type list,
<td>
`~callback~ifc$型, `辞書~型$, `~record型$, `object$T
◎
• a callback interface type
• a dictionary type
• a record type
• object
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Boolean$jt である
◎
Otherwise: if V is a Boolean and there is an entry in S that has one of the following types at position i of its type list,
<td>
`boolean$T
◎
• boolean
• a nullable boolean
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`Number$jt である
◎
Otherwise: if V is a Number and there is an entry in S that has one of the following types at position i of its type list,
<td>
`数量-型$
◎
• a numeric type
• a nullable numeric type
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
`BigInt$jt である
◎
Otherwise: if V is a BigInt and there is an entry in S that has one of the following types at position i of its type list,
<td>
`bigint$T
◎
• bigint
• a nullable bigint
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`文字列~型$
◎
• a string type
• a nullable version of any of the above types
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`数量-型$
◎
• a numeric type
• a nullable numeric type
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`boolean$T
◎
• boolean
• a nullable boolean
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
◎
Otherwise: if there is an entry in S that has one of the following types at position i of its type list,
<td>
`bigint$T
◎
• bigint
• a nullable bigint
• an annotated type whose inner type is one of the above types
• a union type, nullable union type, or annotated union type that has one of the above types in its flattened member types
◎
then remove from S all other entries.

<tr><td>
無条件
<td>
`any$T
◎
Otherwise: if there is an entry in S that has any at position i of its type list, then remove from S all other entries.
</table>

<div>
<p>
上の選別~表tを成す
~EACH( %行 )
に対し，挙げられた順に：
</p>
				<ol>
					<li>
~IF［
%V は %行 の 1 列目の条件を満たさない
］
⇒
~CONTINUE
</li>
					<li>
%型~集合 ~LET %行 の 2 列目に挙げられる型たちが成す集合
</li>
					<li>
<p>
~IF［
%S 内の~entryとして［
その `型~list$oL[ %d ] の`最も内縁な型$が ~OR↓ を満たすもの
］は在る
］…
</p>
						<ul>
							<li>
%型~集合 に属する
</li>
							<li>
［
`共用体~型$である
］~AND［
その`平坦~化~mb型~群$の中に %型~集合 に属するものが在る
］
</li>
						</ul>
<p>
…ならば：
</p>
						<ol>
							<li>
<p>
~IF［
%行 は選別~表tにて `(A)^i が付与された行である
］：
</p>
								<ol>
									<li>
<p>
~IF［
~AND↓
］…：
</p>
										<ul>
											<li>
%V は `StringData^sl `内部~slot$を有する
</li>
											<li>
<p>
%S 内の~entryとして［
`型~list$oL[ %i ] の`最も内縁な型$が ~OR↓ を満たすもの
］は在る
</p>
												<ul>
													<li>
`文字列~型$である
</li>
													<li>
［
`共用体~型$である
］~AND［
その`平坦~化~mb型~群$の中に`文字列~型$が在る
］
</li>
												</ul>
<p>
…ならば
⇒
~CONTINUE
</p>
											</li>
										</ul>
									<li>
%~method ~SET
~ABRUPT `GetMethod$A( %V, `Symbol.asyncIterator$jI )
</li>
									<li>
~IF［
%~method ~EQ `undefined^jv
］
⇒
%~method ~SET
~ABRUPT `GetMethod$A( %V, `Symbol.iterator$jI )
</li>
									<li>
~IF［
%~method ~EQ `undefined^jv
］
⇒
~CONTINUE
</li>
								</ol>
							</li>

							<li>
<p>
~IF［
%行 は選別~表tにて `(B)^i が付与された行である
］：
</p>
								<ol>
									<li>
%~method ~SET
~ABRUPT `GetMethod$A( %V, `Symbol.iterator$jI )
</li>
									<li>
~IF［
%~method ~EQ `undefined^jv
］
⇒
~CONTINUE
</li>
								</ol>
							</li>
							<li>
<p>
~RET 該当する~entry
</p>

<p class="trans-note">【
上の選別~表tを成す どの行においても、
2 列目に挙げられた型たちは，どの 2 つも互いに`判別-可能$でないので，
%S 内で条件を満たす~entryは高々 1 個になる。
】</p>
							</li>
						</ol>
					</li>
				</ol>
◎
↑</div>
			</li>
			<li>
`~THROW$ `TypeError$jt
◎
Otherwise: throw a TypeError.
</li>
		</ol>
</div>
	</li>
	<li>
%~callable ~LET %~entry の`~callable$oL （ `演算$／`拡張d属性$ ）
◎
Let callable be the operation or extended attribute of the single entry in S.
</li>
	<li>
<p>
~IF［
%~method ~NEQ `undefined^jv
］：
【！ GOTO により “If i = d” は不要】
◎
If i = d and method is not undefined, then
</p>
		<ol>
			<li>
%V ~LET %引数~群[ %d ]
◎
Let V be args[i].
</li>
			<li>
%T ~LET %~entry の `型~list$oL[ %d ]
◎
Let T be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
<p>
~Assert：
%T は`連列~型$である。
</p>

<p class="trans-note">【
この表明は、
今や満たされない。
%T は，この仕様の更新により追加された`非同期c連列~型$であるかもしれず、
その場合，次の段は遂行し得ない
（他に何を行うかは指定されていない）。
】</p>
◎
Assert: T is a sequence type.
</li>
			<li>
%値~群 に次の結果を付加する
⇒
`可反復から連列を作成する$( %T, %V, %~method )
◎
Append to values the result of creating a sequence of type T from V and method.
</li>
			<li>
%d ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
<p>
~EACH( %i ~IN { %d 〜 %引数~個数 ~MINUS 1 } )
に対し，昇順に：
◎
While i &lt; argcount:
</p>
		<ol>
			<li>
%V ~LET %引数~群[ %i ]
◎
Let V be args[i].
</li>
			<li>
%型 ~LET %~entry の `型~list$oL[ %i ]
◎
Let type be the type at index i in the type list of the remaining entry in S.
</li>
			<li>
%省略可否 ~LET %~entry の `省略可否~list$oL[ %i ]
◎
Let optionality be the value at index i in the list of optionality values of the remaining entry in S.
</li>
			<!--cp-if-optional-->
			<!--cp-append-convert1-->
		</ol>
	</li>
	<li>
%引数~宣言~list ~LET %~callable の各~引数~宣言からなる同順の`~list$
◎
↓</li>
	<li>
<p>
~EACH( %i ~IN { 0 〜 %引数~宣言~list の`~size$ ~MINUS 1 } )
に対し，昇順に：
</p>

<p class="trans-note">【
上で言及した `既定~値？^C を取扱うため、
この段は［
%i を %引数~個数 からではなく 0 から反復する
］などの手を加えている。
】</p>

		<ol>
			<li>
%値 ~LET ［
%引数~宣言~list[ %i ] は`既定~値$を伴うならば その既定~値 ／
~ELSE_ `missing$C
］
</li>
			<li>
~IF［
%i ~LT %引数~個数
］
⇒
~IF［
%値~群[ %i ] ~EQ `既定~値？^C
］
⇒
%値~群[ %i ] ~SET %値
</li>
			<li>
~ELIF［
%引数~宣言~list[ %i ] は`可変個~引数$でない
］
⇒
%値~群 に %値 を付加する
</li>
		</ol>

◎
While i is less than the number of arguments callable is declared to take:
• If callable’s argument at index i is declared with a default value, then append to values that default value.
• Otherwise, if callable’s argument at index i is not variadic, then append to values the special value “missing”.
• Set i to i + 1.
</li>
	<li>
~RET ~pair &lt;%~callable, %値~群&gt;
◎
Return the pair &lt;callable, values&gt;.
</li>
</ol>
</div>

<div class="note">
<p>注記：
多重定義~解決~algoは、
~callされている［
多重定義された`関数~類$
］の識別に加えて、
~JS引数~値から，それぞれに対応する~IDL値への変換を遂行する。
非正式には次のように演算する。
◎
The overload resolution algorithm performs both the identification of which overloaded operation, constructor, etc. is being called, and the conversion of the JavaScript argument values to their corresponding IDL values. Informally, it operates as follows.
</p>

<p>
まず、
関数に渡された~JS引数の個数を考慮しつつ，妥当な多重定義の選定が行われる：
◎
First, the selection of valid overloads is done by considering the number of JavaScript arguments that were passed in to the function:
</p>
	<ul>
		<li>
最長な多重定義~引数~listより多い引数が渡された場合、
余分な引数は無視する。
◎
If there are more arguments passed in than the longest overload argument list, then they are ignored.
</li>
		<li>
考慮する必要があるのは、
余分な引数を無視した後の引数の個数, および同じ個数の引数をとれる多重定義に限られる。
もし無ければ， `TypeError$jE が投出される。
◎
After ignoring these trailing arguments, only overloads that can take this exact number of arguments are considered. If there are none, then a TypeError is thrown.
</li>
	</ul>

<p>
的確な個数の引数をとる，アリな多重定義たちが成す集合が得られたなら、
~JS値は左から右の順に変換される。
多重定義に対する制約の定義により、
この時点でアリな多重定義が複数ある場合、
引数~listの中で，最終的に選定される多重定義を判別する際の~~基準となる位置がある。
これが`判別~引数~index$である。
◎
Once we have a set of possible overloads with the right number of arguments, the JavaScript values are converted from left to right. The nature of the restrictions on overloading means that if we have multiple possible overloads at this point, then there will be one position in the argument list that will be used to distinguish which overload we will finally select; this is the distinguishing argument index.
</p>

<p>
最初に，判別~引数
— `判別~引数~index$に位置する引数 —
より左に位置する引数を変換する
（これらの引数については、
同じ~indexに位置する他の多重定義の引数と同じ型であることが要件にされている）。
【！判別~引数~indexまで到達したなら、】
次に，対応し得る~IDL型を決定するため、
判別~引数として渡された~JS値の型を検分する。
これにより、
呼出されることになる多重定義の最終的な選定が可能になる。
渡された値が `undefined^jv で，この位置に随意~引数を伴う多重定義がある場合、
その多重定義が選定される。
ここで，渡された値の型に対する妥当な多重定義が無ければ、
`TypeError$jE が投出される。
一般に，判別~引数の検分による副作用は無い
— ~JS値から~IDL値へ変換した結果のみが，多重定義~解決~algoにおける副作用を成す。
（例外は、
いずれかの多重定義の判別~引数~indexに［
`非同期c連列~型$／`連列~型$／`凍結d配列~型$
］が存在するときである【すなわち，上の選別~表tにおける `(A)^i または `(B)^i 】。
この事例では、
適切な多重定義を決定するために［
`Symbol.asyncIterator$jI ／ `Symbol.iterator$jI
］~prop（順不同）を取得するよう試みた上で、
次の段へ進む前に，それとは別に判別~引数の変換を遂行する。）
◎
We first convert the arguments to the left of the distinguishing argument. (There is a requirement that an argument to the left of the distinguishing argument index has the same type as in the other overloads, at the same index.) Then we inspect the type of the JavaScript value that is passed in at the distinguishing argument index to determine which IDL type it can correspond to. This allows us to select the final overload that will be invoked. If the value passed in is undefined and there is an overload with an optional argument at this position, then we will choose that overload. If there is no valid overload for the type of value passed in here, then we throw a TypeError. Generally, the inspection of the value at the distinguishing argument index does not have any side effects, and the only side effects in the overload resolution algorithm are the result of converting the JavaScript values to IDL values. (An exception exists when one of the overloads has an async sequence type, sequence type or frozen array type at the distinguishing argument index. In this case, we attempt to get the %Symbol.asyncIterator% / %Symbol.iterator% property to determine the appropriate overload, and perform the conversion of the distinguishing argument separately before continuing with the next step.)
</p>

<p>
この時点で，利用する多重定義が決定されたことになる。
しかる後、
判別~引数に後続する残りの引数~値も左から右の順に変換する。
ここでも、
前述の余分な引数は，無視される。
◎
At this point, we have determined which overload to use. We now convert the remaining arguments, from the distinguishing argument onwards, again ignoring any additional arguments that were ignored due to being passed after the last possible argument.
</p>

<p>
随意~引数の~JS値から それに等価な~IDL値へ変換する際には、
`undefined^jv は，随意~引数に`既定~値$が指定されて［
いれば それ／
いなければ `missing$C
］に変換されることになる。
◎
When converting an optional argument’s JavaScript value to its equivalent IDL value, undefined will be converted into the optional argument’s default value, if it has one, or a special value “missing” otherwise.
</p>

<p>
しかしながら、
`可変個~引数$に対応する【暗黙的な】随意~引数に対する `undefined^jv は，
`missing$C とは見なされない。
この場合の `undefined^jv 値は、
随意でない引数と同様に，`可変個~引数$の型に変換されることになる。
◎
Optional arguments corresponding to a final, variadic argument do not treat undefined as a special “missing” value, however. The undefined value is converted to the type of variadic argument as would be done for a non-optional argument.
</p>
</div>

		</section>
		<section id="js-interfaces">
<h3 title="Interfaces">3.7. ~ifc</h3>

<p>
所与の`~realm$ %R 内に`公開されて$いる，どの`~ifc$ %I に対しても：
◎
↓</p>

<ul>
	<li>
<p>
%I が［
`LegacyNoInterfaceObject$x, `LegacyNamespace$x
］いずれの`拡張d属性$も伴わずに宣言されたならば、
%I に対応して，次の特性を伴う~propが %R の`大域~obj$上に存在する：
◎
For every interface that is exposed in a given realm and that is not declared with the [LegacyNoInterfaceObject] or [LegacyNamespace] extended attributes, a corresponding property exists on the realm’s global object.＼
</p>
		<ul>
			<li>
名前：
%I の`識別子$
◎
The name of the property is the identifier of the interface, and＼
</li>
			<li>
値：
`~ifc~obj@
と呼ばれる~obj
— この~objの特性については、
`~ifc~obj＠#interface-object§にて述べる。
◎
its value is an object called the interface object. The characteristics of an interface object are described in § 3.7.1 Interface object.
</li>
		</ul>
	</li>
	<li>
<p id="_legacy-window-alias">
%I に `LegacyWindowAlias$x 拡張d属性が指定されている場合、
その拡張d属性~内の各`識別子$wAに対し，対応する［
次の特性を伴う~prop
］が `Window$T 大域~obj上に存在する：
◎
If the [LegacyWindowAlias] extended attribute was specified on an exposed interface, then for each identifier in [LegacyWindowAlias]'s identifiers there exists a corresponding property on the Window global object.＼
</p>
		<ul>
			<li>
名前：
その`識別子$wA
◎
The name of the property is the given identifier, and＼
</li>
			<li>
値：
%I 用の`~ifc~obj$への参照
◎
its value is a reference to the interface object for the interface.
</li>
		</ul>
	</li>
	<li>
<p>
加えて，
%I に `LegacyFactoryFunction$x 拡張d属性たちが伴われるならば、
そのそれぞれに対し，次の特性を伴う~propが %R の大域~obj上に存在する：
◎
In addition, for every [LegacyFactoryFunction] extended attribute on an exposed interface, a corresponding property exists on the JavaScript global object.＼
</p>
		<ul>
			<li>
名前：
`LegacyFactoryFunction$x 拡張d属性の`識別子$fF
◎
The name of the property is the [LegacyFactoryFunction]'s identifier, and＼
</li>
			<li>
値：
`旧来の~factory関数@
と呼ばれる，
%I を実装する~objの作成を許容する~obj。
この関数の特性については、
`旧来の~factory関数＠#legacy-factory-functions§にて述べる。
◎
its value is an object called a legacy factory function, which allows creation of objects that implement the interface. The characteristics of a legacy factory function are described in § 3.7.2 Legacy factory functions.
</li>
		</ul>
	</li>
</ul>

<p>
この節にて定義される~JS~methodのうち一部は、
その手続きの冒頭にて所与の`実装を検査する$ことになる
— それらが正しい種類の~objに対し~callされていて，
現在の文脈から当の~methodを~callすることは妥当であることを確保するため。
◎
Some JavaScript methods defined in this section will perform an implementation check in their opening steps, to ensure they’re being called on the correct kind of object and that the method is valid to call from the current context.
</p>

<div class="algo">
<p>
`実装を検査する@
~algoは、
所与の
( %~js値, ~ifc %~ifc, 識別子 %名前, 種別 %種別 )
に対し：
◎
To implementation-check an object jsValue against the interface interface, with the identifier name and the type type:
</p>
<ol>
	<li>
%object ~LET
~ABRUPT `ToObject$A( %~js値 )
◎
Let object to ? ToObject(jsValue).
</li>
	<li>
~IF［
%object は`~platform~obj$である
］
⇒
`~security検査を遂行する$( %object, %名前, %種別 )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object
• the identifier name
• the type type
</li>
	<li>
~IF［
%object は %~ifc を`実装-$しない
］
⇒
`~THROW$ `TypeError$jt
◎
If object does not implement interface, then throw a TypeError.
</li>
	<li>
~RET %object
◎
Return object.
</li>
</ol>

<p class="XXX">
この~algoは、
まだ，全箇所で一貫して利用されてはいない。
◎
This algo is not yet consistently used everywhere.
</p>
</div>

			<section id="interface-object">
<h4 title="Interface object">3.7.1. ~ifc~obj</h4>

<p>
所与の`~ifc$ %I 用の`~ifc~obj$ %O は、
`組込みの関数~obj$である：
◎
The interface object for a given interface is a built-in function object.＼
</p>

<ul>
	<li>
%O は、
%I 上に定義される各［
`定数$／`静的~演算$
］ごとに対応する~propを有する
— 詳細は
`定数＠#js-constants§,
`演算＠#js-operations§
にて述べる。
◎
It has properties that correspond to the constants and static operations defined on that interface, as described in sections § 3.7.5 Constants and § 3.7.7 Operations.
</li>
	<li>
%I は`構築子~演算$を伴って宣言された場合、
%O を`構築子$として~callして， %I を`実装-$する~objを作成できる。
%I を関数として~callした場合、
例外が投出される。
◎
If the interface is declared with a constructor operation, then the interface object can be called as a constructor to create an object that implements that interface. Calling that interface as a function will throw an exception.
</li>
	<li>
%I は`構築子~演算$を伴わずに宣言された場合、
`構築子$として~callしようが関数として~callしようが，例外が投出される。
◎
Interface objects whose interfaces are not declared with a constructor operation will throw when called, both as a function and as a constructor.
</li>
	<li>
%O には`~ifc原型~obj$と呼ばれる~objが結付けられる
— それは、
%I 上に定義される各［
`正則~属性$ ／ `正則~演算$
］ごとに対応する~propを有する
— 詳細は
`~ifc原型~obj＠#interface-prototype-object§
にて述べる。
◎
An interface object for an interface has an associated object called the interface prototype object. This object has properties that correspond to the regular attributes and regular operations defined on the interface, and is described in more detail in § 3.7.3 Interface prototype object.
</li>
</ul>

<p class="note">注記：
`~ifc~obj$は `関数~obj$なので、
`typeof^op 演算子が適用されたときは， "`function^jv" を返すことになる。
◎
Note: Since an interface object is a function object the typeof operator will return "function" when applied to an interface object.
</p>

<p>
~ifcは、
対応する`~ifc~obj$が［
~callされる／構築される
］ときの挙動を変更できる
`構築子を上書きする手続き@
を備えてもヨイ。
既定では、
~ifcは，そのような手続きを備えない。
◎
An interface may have overridden constructor steps, which can change the behavior of the interface object when called or constructed. By default interfaces do not have such steps.
</p>

<p class="warning">
一般に，構築子は、
`構築子~演算$, その挙動を定義することにより述べられる。
`構築子を上書きする手続き$は、
もっと複雑な状況に限り利用される。
この特能を利用するよう望む編集者には、
続行する前に，
`Intent to use constructor steps$fIして論交することを強く勧める。
◎
In general, constructors are described by defining a constructor operation and its behavior. The overridden constructor steps are used only for more complicated situations. Editors who wish to use this feature are strongly advised to discuss this by filing an issue before proceeding.
</p>

<div class="algo">
<p>
`~ifc$用の`~ifc~obj$は、
以下に従って作成される
—
`~ifc~objを作成する@
~algoは、
所与の
( `~ifc$ %I, `識別子$ %識別子, `~realm$ %~realm )
に対し：
◎
The interface object for a given interface I with identifier id and in realm realm is created as follows:
</p>
<ol>
	<li>
<p>
%手続き ~LET ［
%I は`構築子を上書きする手続き$を備えるならば それ／
~ELSE_ 次に与える手続き
］
◎
Let steps be I’s overridden constructor steps if they exist, or the following steps otherwise:
</p>
		<ol>
			<li>
~IF［
%I は`構築子~演算$を伴って宣言されてない
］
⇒
`~THROW$ `TypeError$jt
◎
If I was not declared with a constructor operation, then throw a TypeError.
</li>
			<li id="cp-throw-undef-NewTarget">
~IF［
`NewTarget$ ~EQ `undefined^jv
］
⇒
`~THROW$ `TypeError$jt
◎
If NewTarget is undefined, then throw a TypeError.
</li>
			<li id="cp-let-args-0-n-1">
%引数~群 ~LET 渡された引数たちからなる~list
◎
Let args be the passed arguments.
</li>
			<!--cp-let-n-args-size-->
			<li>
%S ~LET %I の構築子~用の`有効-多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 %n )
◎
Let id be the identifier of interface I. 原文削除漏れ
◎
Compute the effective overload set for constructors with identifier id on interface I and with argument count n, and let S be the result.
</li>
			<li id="cp-resolve-overload">
&lt;%構築子, %値~群&gt; ~LET
( %S, %引数~群 )
を`多重定義~解決~algo$に渡した結果
◎
Let &lt;constructor, values&gt; be the result of passing S and args to the overload resolution algorithm.
</li>
			<li id="cp-internally-creating-new">
%object ~LET `~ifcを実装する新たな~objを作成する$( %I, %~realm, `NewTarget$ )
◎
Let object be the result of internally creating a new object implementing I, with realm and NewTarget.
</li>
			<li id="cp-perform-constructor-steps">
%構築子 の`構築子~手続き$を［
`this$V として %object,
引数~list %値~群
］を与える下で遂行する
◎
Perform the constructor steps of constructor with object as this and values as the argument values.
</li>
			<li id="cp-O-toES-I">
%O ~LET `~JS値に変換する$( %object )
◎
Let O be object, converted to a JavaScript value.
</li>
			<li id="cp-assert-O-implements-I">
~Assert：
%O は %I を`実装-$する~objである
◎
Assert: O is an object that implements I.
</li>
			<li id="cp-assert-O-realm-is-I">
~Assert：
%O.`Realm^sl ~EQ %~realm
◎
Assert: O.[[Realm]] is realm.
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
	<li>
%構築子~原型 ~LET %~realm.`Function.prototype$jIsl
◎
Let constructorProto be realm.[[Intrinsics]].[[%Function.prototype%]].
</li>
	<li>
~IF［
%I は他の~ifc %P を継承する
］
⇒
%構築子~原型 ~SET %~realm に属する %P 用の`~ifc~obj$
◎
If I inherits from some other interface P, then set constructorProto to the interface object of P in realm.
</li>
	<li>
%F ~LET
`CreateBuiltinFunction$A( %手続き, « `Unforgeables^sl », %~realm, %構築子~原型 )
◎
Let F be CreateBuiltinFunction(steps, « [[Unforgeables]] », realm, constructorProto).
</li>
	<li>
%偽造-不能~obj ~LET
`OrdinaryObjectCreate$A( `null^jv )
◎
Let unforgeables be OrdinaryObjectCreate(null).
</li>
	<li>
`偽造-不能な正則~演算を定義する$( %I, %偽造-不能~obj, %~realm )
◎
Define the unforgeable regular operations of I on unforgeables, given realm.
</li>
	<li>
`偽造-不能な正則~属性を定義する$( %I, %偽造-不能~obj, %~realm )
◎
Define the unforgeable regular attributes of I on unforgeables, given realm.
</li>
	<li>
<p>
%F.`Unforgeables^sl ~SET %偽造-不能~obj
◎
Set F.[[Unforgeables]] to unforgeables.
</p>

<p class="note">注記：
この~objは、
利用元~codeには決して公開されず，次を確保するために限り存在する
⇒
偽造-不能な~mbを伴う~ifcのすべて~instanceは、［
`属性~取得子を作成する$／`属性~設定子を作成する$／`演算~関数を作成する$
］のそれぞれに対し，同じ~JS関数~objを利用する
◎
Note: this object is never exposed to user code. It exists only to ensure all instances of an interface with an unforgeable member use the same JavaScript function objects for attribute getters, attribute setters and operation functions.
</p>
	</li>
	<li id="cp-SetFunctionName-F-id">
`SetFunctionName$A( %F, %識別子 )
◎
Perform SetFunctionName(F, id).
</li>
	<li>
%長さ ~LET 0
◎
Let length be 0.
</li>
	<li>
<p>
~IF［
%I は`構築子~演算$を伴って宣言された
］：
◎
If I was declared with a constructor operation, then
</p>
		<ol>
			<li>
%S ~LET %I の構築子~用の`有効-多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 0 )
◎
Compute the effective overload set for constructors with identifier id on interface I and with argument count 0, and let S be the result.
</li>
			<li>
%長さ ~SET %S 内の各~entryの引数~listの長さのうち，最小
◎
Set length to the length of the shortest argument list of the entries in S.
</li>
		</ol>
	</li>
	<li id="cp-SetFunctionLength-F-length">
`SetFunctionLength$A( %F, %長さ )
◎
Perform SetFunctionLength(F, length).
</li>
	<li>
%proto ~LET `~ifc原型~objを作成する$( %I, %~realm )
◎
Let proto be the result of creating an interface prototype object of interface I in realm.
</li>
	<li id="cp-DefinePropertyOrThrow-F-proto">
~NOABRUPT `DefinePropertyOrThrow$A( %F, `prototype^l, `FFF-proto^desc )
◎
Perform ! DefinePropertyOrThrow(F, "prototype", PropertyDescriptor{[[Value]]: proto, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}).
</li>
	<li>
`定数を定義する$( %I, %F, %~realm )
◎
Define the constants of interface I on F given realm.
</li>
	<li>
`静的~属性を定義する$( %I, %F, %~realm )
◎
Define the static attributes of interface I on F given realm.
</li>
	<li>
`静的~演算を定義する$( %I, %F, %~realm )
◎
Define the static operations of interface I on F given realm.
</li>
	<li id="cp-ret-F">
~RET %F
◎
Return F.
</li>
</ol>
</div>

			</section>
			<section id="legacy-factory-functions">
<h4 title="Legacy factory functions">3.7.2. 旧来の~factory関数</h4>

<p>
`旧来の~factory関数$は、［
`識別子$fFを伴う 1 個~以上の `LegacyFactoryFunction$x `拡張d属性$
］に因り存在することになる，`組込みの関数~obj$である。
それは、
その拡張d属性が現れる`~ifc$（以下 %I とする）を実装する~objの構築を可能にする。
◎
A legacy factory function that exists due to one or more [LegacyFactoryFunction] extended attributes with a given identifier is a built-in function object. It allows constructing objects that implement the interface on which the [LegacyFactoryFunction] extended attributes appear.
</p>

<div class="algo">
<p>
`~ifc$用の`旧来の~factory関数$は、
以下に従って作成される
—
`旧来の~factory関数を作成する@
~algoは、
所与の
( `~ifc$ %I, `識別子$ %識別子, `~realm$ %~realm )
に対し：
◎
The legacy factory function with identifier id for a given interface I in realm realm is created as follows:
</p>
<ol>
	<li>
%識別子 ~LET `旧来の~factory関数$の`識別子$fF
◎
↑</li>
	<li class="algo">
<p>
%手続き ~LET 次に与える手続き：
◎
Let steps be the following steps:
</p>
		<ol>
			<!--cp-throw-undef-NewTarget-->
			<!--cp-let-args-0-n-1-->
			<!--cp-let-n-args-size-->
			<li>
%S ~LET %I の旧来の~factory関数~用の`有効-多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 %n )
◎
Compute the effective overload set for legacy factory functions with identifier id on interface I and with argument count n, and let S be the result.
</li>
			<!--cp-resolve-overload-->
			<!--cp-internally-creating-new-->
			<!--cp-perform-constructor-steps-->
			<!--cp-O-toES-I-->
			<!--cp-assert-O-implements-I-->
			<!--cp-assert-O-realm-is-I-->
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
	<li id="cp-CreateBuiltinFunction">
%F ~LET
`CreateBuiltinFunction$A( %手続き, « », %~realm )
◎
Let F be CreateBuiltinFunction(steps, « », realm).
</li>
	<!--cp-SetFunctionName-F-id-->
	<li>
%S ~LET %I の旧来の~factory関数~用の`有効-多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 0 )
◎
Compute the effective overload set for legacy factory functions with identifier id on interface I and with argument count 0, and let S be the result.
</li>
	<li>
%長さ ~LET %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list of the entries in S.
</li>
	<!--cp-SetFunctionLength-F-length-->
	<li>
%proto ~LET %~realm 内で %I を成す`~ifc原型~obj$
◎
Let proto be the interface prototype object of interface I in realm.
</li>
	<!--cp-DefinePropertyOrThrow-F-proto-->
	<!--cp-ret-F-->
</ol>
</div>

			</section>
			<section id="interface-prototype-object">
<h4 title="Interface prototype object">3.7.3. ~ifc原型~obj</h4>

<p>
定義されたどの`~ifc$に対しても、
その~ifcが `LegacyNoInterfaceObject$x `拡張d属性$を伴って宣言されたかどうかに関わらず，
対応する
`~ifc原型~obj@
が存在することになる。
◎
There will exist an interface prototype object for every interface defined, regardless of whether the interface was declared with the [LegacyNoInterfaceObject] extended attribute.
</p>

<div class="algo">
<p>
`~ifc原型~objを作成する@
~algoは、
所与の
( `~ifc$ %~ifc, `~realm$ %~realm )
に対し，`~ifc原型~obj$を作成して返す：
◎
The interface prototype object for a given interface interface and realm realm is created as follows:
</p>
<ol>
	<li>
%原型 ~LET ~NULL
◎
Let proto be null.
</li>
	<li>
~IF［
%~ifc は `Global$x `拡張d属性$を伴って宣言された
］~AND［
%~ifc は`有名~propを~support$する
］
⇒
%原型 ~SET `有名~prop群~objを作成する$( %~ifc, %~realm )
◎
If interface is declared with the [Global] extended attribute, and interface supports named properties, then set proto to the result of creating a named properties object for interface and realm.
</li>
	<li>
~ELIF［
%~ifc は別の~ifc %B を`継承-$するように宣言された
］
⇒
%原型 ~SET %~realm 内の %B 用の`~ifc原型~obj$
◎
Otherwise, if interface is declared to inherit from another interface, then set proto to the interface prototype object in realm of that inherited interface.
</li>
	<li>
~ELIF［
%~ifc は `DOMException$T `~ifc$である
］
⇒
%原型 ~SET %~realm.`Error.prototype$jIsl
◎
Otherwise, if interface is the DOMException interface, then set proto to realm.[[Intrinsics]].[[%Error.prototype%]].
</li>
	<li id="cp-else-set-proto-realm">
~ELSE
⇒
%原型 ~SET %~realm.`Object.prototype$jIsl
◎
Otherwise, set proto to realm.[[Intrinsics]].[[%Object.prototype%]].
</li>
	<li>
~Assert：
%原型 は `Object$jt である
◎
Assert: proto is an Object.
</li>
	<li>
%~ifc原型~obj ~LET ~NULL
◎
Let interfaceProtoObj be null.
</li>
	<li>
~IF［
%~realm の`大域~原型鎖は変異-可能か$ ~EQ ~T
］
⇒
%~ifc原型~obj ~SET `OrdinaryObjectCreate$A( %原型 )
◎
If realm’s is global prototype chain mutable is true, then:
• Set interfaceProtoObj to OrdinaryObjectCreate(proto).
</li>
	<li>
<p>
~ELIF［
%~ifc の`自身も含む継承した~ifc群$を成すある~ifcは、
`Global$x `拡張d属性$を伴って宣言された
【！declared with..., or %I が`継承した~ifc群$】
］：
◎
Otherwise, if interface is declared with the [Global] extended attribute, or interface is in the set of inherited interfaces of an interface that is declared with the [Global] extended attribute, then:
</p>
		<ol>
			<li>
%~ifc原型~obj ~SET
`MakeBasicObject$A( « `Prototype^sl, `Extensible^sl » )
◎
Set interfaceProtoObj to MakeBasicObject(« [[Prototype]], [[Extensible]] »).
</li>
			<li>
%~ifc原型~obj.`Prototype^sl ~SET %原型
◎
Set interfaceProtoObj.[[Prototype]] to proto.
</li>
			<li>
%~ifc原型~obj を成す［
`変異-不能な原型~exotic~obj$に特有な各 内部~method
］を［
`ECMA-262$r `変異-不能な原型~exotic~obj＠~TC39#sec-immutable-prototype-exotic-object§に指定される各 定義
］に設定する
◎
Set the internal methods of interfaceProtoObj which are specific to immutable prototype exotic objects to the definitions specified in ECMA-262 Immutable prototype exotic objects.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%~ifc原型~obj ~SET
`OrdinaryObjectCreate$A( %原型 )
◎
Otherwise, set interfaceProtoObj to OrdinaryObjectCreate(proto).
</li>
	<li>
<p>
~IF［
%~ifc のある`~mb$は `Unscopable$x `拡張d属性$を伴って宣言された
］：
◎
If interface has any member declared with the [Unscopable] extended attribute, then:
</p>
		<ol>
			<li>
%~scope不能~obj ~LET
`OrdinaryObjectCreate$A( `null^jv )
◎
Let unscopableObject be OrdinaryObjectCreate(null).
</li>
			<li>
<p>
%~ifc に`公開されて$いる, かつ
`Unscopable$x `拡張d属性$を伴って宣言された
~EACH( `~mb$ %~mb )
に対し：
◎
For each exposed member member of interface that is declared with the [Unscopable] extended attribute:
</p>
				<ol>
					<li>
%識別子 ~LET %~mb の`識別子$
◎
Let id be member’s identifier.
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~scope不能~obj, %識別子, `true^jv )
◎
Perform ! CreateDataPropertyOrThrow(unscopableObject, id, true).
</li>
				</ol>
			</li>
			<li>
%記述子 ~LET `FFT-~scope不能~obj^desc
◎
Let desc be the PropertyDescriptor{[[Value]]: unscopableObject, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~ifc原型~obj, `Symbol.toStringTag$jI, %記述子 )
◎
Perform ! DefinePropertyOrThrow(interfaceProtoObj, %Symbol.unscopables%, desc).
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~ifc は `Global$x `拡張d属性$を伴って宣言されてない
］：
◎
If interface is not declared with the [Global] extended attribute, then:
</p>
		<ol>
			<li>
`正則~属性を定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the regular attributes of interface on interfaceProtoObj given realm.
</li>
			<li>
`正則~演算を定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the regular operations of interface on interfaceProtoObj given realm.
</li>
			<li>
`反復子~methodを定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the iteration methods of interface on interfaceProtoObj given realm.
</li>
			<li>
`非同期~反復子~methodを定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the asynchronous iteration methods of interface on interfaceProtoObj given realm.
</li>
		</ol>
	</li>
	<li>
`定数を定義する$( %~ifc, %~ifc原型~obj, %~realm )
◎
Define the constants of interface on interfaceProtoObj given realm.
</li>
	<li>
<p>
~IF［
%~ifc には `LegacyNoInterfaceObject$x `拡張d属性$は指定されていない
］：
◎
If the [LegacyNoInterfaceObject] extended attribute was not specified on interface, then:
</p>
		<ol>
			<li>
%構築子 ~LET %~realm 内で %~ifc を成す`~ifc~obj$
◎
Let constructor be the interface object of interface in realm.
</li>
			<li>
%記述子 ~LET `TFT-構築子^desc
◎
Let desc be the PropertyDescriptor{[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true, [[Value]]: constructor}.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~ifc原型~obj, `constructor^l, %記述子 )
◎
Perform ! DefinePropertyOrThrow(interfaceProtoObj, "constructor", desc).
</li>
		</ol>
	</li>
	<li>
~RET %~ifc原型~obj
◎
Return interfaceProtoObj.
</li>
</ol>
</div>

<p>
加えて，`~ifc原型~obj$は、
次に挙げるものから宣言的に~propを取得する
⇒＃
`文字列化子＠#js-stringifier§,
`~maplike宣言＠#js-maplike§,
`~setlike宣言＠#js-setlike§
◎
Additionally, interface prototype objects get properties declaratively from:
• § 3.7.8 Stringifiers,
• § 3.7.11 Maplike declarations, and
• § 3.7.12 Setlike declarations.
</p>

<p class="issue" id="cp-issue-imperatively">
これらの~propを，代わりに命令的に定義する。
◎
Define those properties imperatively instead.
</p>

<div class="note">
<p>注記：
`LegacyNoInterfaceObject$x `拡張d属性$を伴って定義された`~ifc$用の`~ifc原型~obj$は、
~access可能になる。
例えば、
次の~IDLでは：
◎
The interface prototype object of an interface that is defined with the [LegacyNoInterfaceObject] extended attribute will be accessible. For example, with the following IDL:
</p>

<pre class="webidl">
[Exposed=Window,
 LegacyNoInterfaceObject]
interface Foo {
};

partial interface Window {
  attribute Foo foo;
};
</pre>

<p>
`~ifc~obj$を通して ~ifc原型~objに~accessすることはアリでない（ `window.Foo^c として存在しないので）。
しかしながら， `Foo^T の~instanceは、
その `GetPrototypeOf^sl `内部~method$を~callすること
— この例では， `Object.getPrototypeOf(window.foo)^c —
により，~ifc原型~objを公開できる。
◎
it is not possible to access the interface prototype object through the interface object (since it does not exist as window.Foo). However, an instance of Foo can expose the interface prototype object by calling its [[GetPrototypeOf]] internal method – Object.getPrototypeOf(window.foo) in this example.
</p>
</div>

<p>
`~ifc原型~obj$の`~class文字列$は、
`~ifc$の`有修飾~名$とする
◎
The class string of an interface prototype object is the interface’s qualified name.
</p>

			</section>
			<section id="named-properties-object">
<h4 title="Named properties object">3.7.4. 有名~prop群~obj</h4>

<p>
`Global$x `拡張d属性$を伴って宣言された`~ifc$のうち［
`有名~propを~support$するもの
］用には，
`有名~prop群~obj@
と称される~objが存在し、
当の有名~propたちは，そこで公開されることになる。
◎
For every interface declared with the [Global] extended attribute that supports named properties, there will exist an object known as the named properties object for that interface on which named properties are exposed.
</p>

<div class="algo">
<p>
`有名~prop群~objを作成する@
~algoは、
所与の
( `~ifc$ %~ifc, `~realm$ %~realm )
に対し，`有名~prop群~obj$を作成して返す：
◎
The named properties object for a given interface interface and realm realm, is created as follows:
</p>
<ol>
	<li>
%原型 ~LET ~NULL
◎
Let proto be null.
</li>
	<li>
~IF［
%~ifc は別の~ifc %B を`継承-$するように宣言された
］
⇒
%原型 ~SET %~realm 内の %B 用の`~ifc原型~obj$
◎
If interface is declared to inherit from another interface, then set proto to the interface prototype object in realm for the inherited interface.
</li>
	<!--cp-else-set-proto-realm-->
	<li>
%~obj ~LET
`MakeBasicObject$A( « `Prototype^sl, `Extensible^sl » )
◎
Let obj be MakeBasicObject(« [[Prototype]], [[Extensible]] »).
</li>
	<li>
%~obj の
⇒＃
.`GetOwnProperty^sl ~SET `GetOwnProperty＠#named-properties-object-getownproperty§sl に指定される手続き；
.`DefineOwnProperty^sl ~SET `DefineOwnProperty＠#named-properties-object-defineownproperty§sl に指定される手続き；
.`Delete^sl ~SET `Delete＠#named-properties-object-delete§sl に指定される手続き；
.`SetPrototypeOf^sl ~SET `SetPrototypeOf＠#named-properties-object-setprototypeof§sl に指定される手続き；
.`PreventExtensions^sl ~SET `PreventExtensions＠#named-properties-object-preventextensions§sl に指定される手続き
◎
Set obj.[[GetOwnProperty]] as specified in § 3.7.4.1 [[GetOwnProperty]].
◎
Set obj.[[DefineOwnProperty]] as specified in § 3.7.4.2 [[DefineOwnProperty]].
◎
Set obj.[[Delete]] as specified in § 3.7.4.3 [[Delete]].
◎
Set obj.[[SetPrototypeOf]] as specified in § 3.7.4.4 [[SetPrototypeOf]].
◎
Set obj.[[PreventExtensions]] as specified in § 3.7.4.5 [[PreventExtensions]].
</li>
	<li>
%~obj.`Prototype^sl ~SET %原型
◎
Set obj.[[Prototype]] to proto.
</li>
	<li>
~RET %~obj
◎
Return obj.
</li>
</ol>
</div>

<p class="note">注記：
有名~prop群~objの `OwnPropertyKeys^sl 内部~methodは、
`旧来の~platform~obj$用の相応するものと違って，
`OrdinaryOwnPropertyKeys$A† を利用し続ける。
有名~propは、
“本物の” 自前の~propではなく，
この内部~methodにより返されることになるので。
◎
Note: The [[OwnPropertyKeys]] internal method of a named properties object continues to use OrdinaryOwnPropertyKeys, unlike the counterpart for legacy platform objects. Since named properties are not “real” own properties, they will not be returned by this internal method.
</p>

<p class="trans-note">【†
`GetOwnProperty＠#named-properties-object-getownproperty§sl にて実際に利用されているのは `OrdinaryGetOwnProperty^A なのに，
`OrdinaryOwnPropertyKeys^A と記されているのはなぜなのかは、
よくわからない。
】</p>

<p>
所与の`~ifc$用の`有名~prop群~obj$の`~class文字列$は、
次の結果になるとする
⇒
次を順に`連結する$
⇒＃
当の~ifcの`識別子$,
文字列 `Properties^l
◎
The class string of a named properties object is the concatenation of the interface’s identifier and the string "Properties".
</p>

				<section id="named-properties-object-getownproperty">
<h5>3.7.4.1. `GetOwnProperty^sl</h5>

<div class="algo">
<p>
`~ifc$ %A 用の`有名~prop群~obj$ %O の `GetOwnProperty^sl 内部~methodが，
~prop名 %P を伴って~callされたときは、
次を走らす：
◎
When the [[GetOwnProperty]] internal method of a named properties object O is called with property key P, the following steps are taken:
• Let A be the interface for the named properties object O.
</p>
<ol>
	<li>
%object ~LET %O.`Realm^sl の`大域~obj$
◎
Let object be O.[[Realm]]'s global object.
</li>
	<li>
~Assert：
%object は %A を`実装-$する
◎
Assert: object implements A.
</li>
	<li>
<p>
~IF［
`有名~propは可視か？$( %P, %object ) ~EQ ~T
］：
◎
If the result of running the named property visibility algorithm with property name P and object object is true, then:
</p>
		<ol>
			<li>
%演算 ~LET `有名~prop取得子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
			<li id="cp-let-uninitialized">
%値 ~LET ε
◎
Let value be an uninitialized variable.
</li>
			<li id="cp-determine-ifndef">
~IF［
%演算 は`識別子$を伴わずに定義された
］
⇒
%値 ~SET %演算 を宣言した`~ifc$用の`有名~propの値を決定する手続き$( %P )
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of a named property with P as the name.
</li>
			<li>
~ELSE
⇒
%値 ~SET ［
%演算 の記述に挙げられた手続き
］を引数~list « %P » を与える下で遂行した結果
【%演算 用の`~method手続き$を［ `this$V として %A, 引数~list « %P » ］を与える下で遂行した結果？】
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the steps listed in the description of operation with P as the only argument value.
</li>
			<li>
<p>
~RET 次を伴う新たな`~pdesc$
⇒
`TET-V^desc
— ここで：
</p>
				<ul>
					<li id="cp-let-convert2">
%V ~LET `~JS値に変換する$( %値 )
</li>
					<li>
%E ~LET ［
%A が`実装-$する ある~ifcは `LegacyUnenumerableNamedProperties$x `拡張d属性$を伴うならば `false^jv ／
~ELSE_ `true^jv
］
</li>
				</ul>
◎
Let desc be a newly created Property Descriptor with no fields.
◎
Set desc.[[Value]] to the result of converting value to a JavaScript value.
◎
If A implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Writable]] to true and desc.[[Configurable]] to true.
◎
Return desc.
</li>
		</ol>
	</li>
	<li id="cp-return-OrdinaryGetOwnProperty">
~RET
`OrdinaryGetOwnProperty$A( %O, %P )
◎
Return OrdinaryGetOwnProperty(O, P).
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-defineownproperty">
<h5>3.7.4.2. `DefineOwnProperty^sl</h5>

<div class="algo">
<p>
`有名~prop群~obj$の `DefineOwnProperty^sl 内部~methodが~callされたときは、
次を走らす：
◎
When the [[DefineOwnProperty]] internal method of a named properties object is called, the following steps are taken:
</p>
<ol>
	<li id="cp-return-false">
~RET `false^jv
◎
Return false.
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-delete">
<h5>3.7.4.3. `Delete^sl</h5>

<div class="algo">
<p>
`有名~prop群~obj$の `Delete^sl 内部~methodが~callされたときには，次を走らす：
◎
When the [[Delete]] internal method of a named properties object is called, the following steps are taken:
</p>
<ol>
	<!--cp-return-false-->
</ol>
</div>

				</section>
				<section id="named-properties-object-setprototypeof">
<h5>3.7.4.4. `SetPrototypeOf^sl</h5>

<div class="algo">
<p>
`有名~prop群~obj$ %O の `SetPrototypeOf^sl 内部~methodが，~JS言語~値 %V で~callされたときは、
次を走らす：
◎
When the [[SetPrototypeOf]] internal method of a named properties object O is called with JavaScript language value V, the following step is taken:
</p>

<ol id="cp-SetImmutablePrototype">
	<li>
~IF［
%O が`属する~realm$の`大域~原型鎖は変異-可能か$ ~EQ ~T
］
⇒
~RET 
~ABRUPT `OrdinarySetPrototypeOf$A( %O, %V )
◎
If O’s associated realm’s is global prototype chain mutable is true, return ? OrdinarySetPrototypeOf(O, V).
</li>
	<li>
~RET
~ABRUPT `SetImmutablePrototype$A( %O, %V )
◎
Return ? SetImmutablePrototype(O, V).
</li>
</ol>
</div>

				</section>
				<section id="named-properties-object-preventextensions">
<h5>3.7.4.5. `PreventExtensions^sl</h5>

<div class="algo">
<p>
`有名~prop群~obj$の `PreventExtensions^sl 内部~methodが~callされたときは、
次を走らす：
◎
When the [[PreventExtensions]] internal method of a named properties object is called, the following steps are taken:
</p>
<ol>
	<!--cp-return-false-->
</ol>
</div>

<p class="note">注記:
これにより、
`有名~prop群~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^sl を失敗させることにより。
◎
Note: this keeps named properties object extensible by making [[PreventExtensions]] fail.
</p>

				</section>
			</section>
			<section id="js-constants">
<h4 title="Constants">3.7.5. 定数</h4>

<p>
`定数$は［
`~ifc~obj$ ／ `旧来の~callback~ifc~obj$ ／ `~ifc原型~obj$
］上に
— 当の~ifcは `Global$x `拡張d属性$を伴って宣言されたときには，~ifcを`実装-$する単独の~obj上に —
公開される。
◎
Constants are exposed on interface objects, legacy callback interface objects, interface prototype objects, and on the single object that implements the interface, when an interface is declared with the [Global] extended attribute.
</p>

<div class="algo">
<p>
`定数を定義する@
~algoは、
所与の
( ［
`~ifc$／`~callback~ifc$／`~ns$
］ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the constants of interface, callback interface, or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
<p>
%定義 を成す`~mb$のうち，`定数$である
~EACH( %定数 )
に対し：
◎
For each constant const that is a member of definition:
</p>
		<ol>
			<li>
~IF［
%定数 は%~realm 内に`公開されて$いない
］
⇒
~CONTINUE
◎
If const is not exposed in realm, then continue.
</li>
			<li>
%値 ~LET `~JS値に変換する$( %定数 の~IDL値 )
◎
Let value be the result of converting const’s IDL value to a JavaScript value.
</li>
			<li>
%記述子 ~LET `FTF-値^desc
◎
Let desc be the PropertyDescriptor{[[Writable]]: false, [[Enumerable]]: true, [[Configurable]]: false, [[Value]]: value}.
</li>
			<li>
%識別子 ~LET %定数 の`識別子$
◎
Let id be const’s identifier.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~target, %識別子, %記述子 )
◎
Perform ! DefinePropertyOrThrow(target, id, desc).
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="js-attributes">
<h4 title="Attributes">3.7.6. 属性</h4>

<p>
`静的~属性$は、
`~ifc~obj$上に公開される。
`正則~属性$は、
`~ifc原型~obj$上に公開される
— ただし，［
属性は`偽造-不能$である／
当の~ifcは `Global$x `拡張d属性$を伴って宣言された
］事例では、
その~ifcを`実装-$する どの~objにも公開される。
◎
Static attributes are exposed on the interface object. Regular attributes are exposed on the interface prototype object, unless the attribute is unforgeable or if the interface was declared with the [Global] extended attribute, in which case they are exposed on every object that implements the interface.
</p>

<div class="algo">
<p>
`正則~属性を定義する@
~algoは、
所与の
( `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the regular attributes of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
%属性~群 ~LET ［
%定義 を成す`~mb$のうち，`正則~属性$である, かつ
`偽造-不能$でないもの
］からなる`~list$
◎
Let attributes be the list of regular attributes that are members of definition.
◎
Remove from attributes all the attributes that are unforgeable.
</li>
	<li id="cp-define-attr">
`属性を定義する$( %属性~群, %定義, %~target, %~realm )
◎
Define the attributes attributes of definition on target given realm.
</li>
</ol>
</div>

<div class="algo">
<p>
`静的~属性を定義する@
~algoは、
所与の
( `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the static attributes of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
%属性~群 ~LET ［
%定義 を成す`~mb$のうち，`静的~属性$であるもの
］からなる`~list$
◎
Let attributes be the list of static attributes that are members of definition.
</li>
	<!--cp-define-attr-->
</ol>
</div>

<div class="algo">
<p>
`偽造-不能な正則~属性を定義する@
~algoは、
所与の
( `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the unforgeable regular attributes of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
%属性~群 ~LET ［
%定義 を成す`~mb$のうち，`正則~属性$である, かつ
`偽造-不能$であるもの
］からなる`~list$
◎
Let attributes be the list of unforgeable regular attributes that are members of definition.
</li>
	<!--cp-define-attr-->
</ol>
</div>

<div class="algo">
<p>
`属性を定義する@
~algoは、
所与の
( %属性~群, `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the attributes attributes of interface or namespace definition on target given realm realm, run the following steps:
</p>
<ol>
	<li>
<p>
%属性~群 を成す
~EACH( `属性$ %属性 )
に対し：
◎
For each attribute attr of attributes:
</p>
		<ol>
			<li>
~IF［
%属性 は %~realm 内に`公開されて$いない
］
⇒
~CONTINUE
◎
If attr is not exposed in realm, then continue.
</li>
			<li>
%取得子 ~LET `属性~取得子を作成する$( %属性, %定義, %~realm )
◎
Let getter be the result of creating an attribute getter given attr, definition, and realm.
</li>
			<li>
<p>
%設定子 ~LET `属性~設定子を作成する$( %属性, %定義, %~realm )
◎
Let setter be the result of creating an attribute setter given attr, definition, and realm.
</p>

<p class="note">注記：
`属性~設定子を作成する$~algoは、
%属性 は`読専$である場合には `undefined^jv を返す。
◎
Note: the algorithm to create an attribute setter returns undefined if attr is read only.
</p>
			</li>
			<li>
%~configure可能 ~LET ［
%属性 は`偽造-不能$であるならば `false^jv ／
~ELSE_ `true^jv
］
◎
Let configurable be false if attr is unforgeable and true otherwise.
</li>
			<li>
%記述子 ~LET {
[[Get]]: %取得子,
[[Set]]: %設定子,
[[Enumerable]]: `true^jv,
[[Configurable]]: %~configure可能
}
◎
Let desc be the PropertyDescriptor{[[Get]]: getter, [[Set]]: setter, [[Enumerable]]: true, [[Configurable]]: configurable}.
</li>
			<li>
%識別子 ~LET %属性 の`識別子$
◎
Let id be attr’s identifier.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~target, %識別子, %記述子 )
◎
Perform ! DefinePropertyOrThrow(target, id, desc).
</li>
			<li>
~IF［
%属性 の型は型~引数 %T を伴う`観測-可能な配列~型$である
］
⇒
%~target の
%属性 を`~backしている観測-可能な配列~exotic~obj$ ~SET
%~realm 内に`観測-可能な配列~exotic~objを作成する$( ↓ )
⇒＃
%T,
%属性 用の`観測-可能な配列~属性の有index値を設定する$~algo,
%属性 用の`観測-可能な配列~属性の有index値を削除する$~algo
◎
If attr’s type is an observable array type with type argument T, then set target’s backing observable array exotic object for attr to the result of creating an observable array exotic object in realm, given T, attr’s set an indexed value algorithm, and attr’s delete an indexed value algorithm.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`属性~取得子を作成する@
~algoは、
所与の
( `属性$ %属性, ［`~ifc$／`~ns$］ %target, `~realm$ %~realm )
に対し：
◎
The attribute getter is created as follows, given an attribute attribute, a namespace or interface target, and a realm realm:
</p>
<ol>
	<li class="algo">
<p>
%手続き ~LET 以下を走らす手続き
— ただし，手続きの中で`例外が投出された$ときは、
その下に与える手続きを走らすとする：
◎
Let steps be the following series of steps:
◎
Try running the following steps:
</p>
		<ol>
			<li id="cp-let-idlObject-null">
%~idl~obj ~LET `null^V
◎
Let idlObject be null.
</li>
			<li>
<p>
~IF［
%target は`~ifc$である
］~AND［
%属性 は`正則~属性$である
］：
◎
If target is an interface, and attribute is a regular attribute:
</p>
				<ol>
					<li id="cp-let-jsValue-this-or-global">
<p>
%~js値 ~LET ［
`this^jv 値 ~NIN { `null^jv, `undefined^jv } ならば `this^jv 値 ／
~ELSE_ %~realm の`大域~obj$
］
</p>

<p>
（この大域~objが %target を実装しない, かつ
`LegacyLenientThis$x は指定されていない場合、
数~段~先で `TypeError$jE が生じることになる。）
</p>
◎
Let jsValue be the this value, if it is not null or undefined, or realm’s global object otherwise. (This will subsequently cause a TypeError in a few steps, if the global object does not implement target and [LegacyLenientThis] is not specified.)
</li>
					<li>
~IF［
%~js値 は `~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, %属性 の`識別子$, `取得子^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, attribute’s identifier, and "getter".
</li>
					<li>
<p>
~IF［
%~js値 は %target を`実装-$しない
］：
◎
If jsValue does not implement target, then:
</p>
						<ol>
							<li>
~IF［
%属性 には `LegacyLenientThis$x `拡張d属性$が指定されている
］
⇒
~RET `undefined^jv
◎
If attribute was specified with the [LegacyLenientThis] extended attribute, then return undefined.
</li>
							<li>
~ELSE
⇒
`~THROW$ `TypeError$jt
◎
Otherwise, throw a TypeError.
</li>
						</ol>
					</li>
					<li>
~IF［
%属性 の型は`観測-可能な配列~型$である
］
⇒
~RET %~js値 の
%属性 を`~backしている観測-可能な配列~exotic~obj$
◎
If attribute’s type is an observable array type, then return jsValue’s backing observable array exotic object for attribute.
</li>
					<li id="cp-set-idlObject-ifc">
%~idl~obj ~SET %~js値 への参照を表現する，~IDL`~ifc型$の値
◎
Set idlObject to the IDL interface type value that represents a reference to jsValue.
</li>
				</ol>
			</li>
			<li>
%R ~LET %属性 の`取得子~手続き$を［
`this$V として %~idl~obj
］を与える下で走らせた結果
◎
Let R be the result of running the getter steps of attribute with idlObject as this.
</li>
			<li>
~RET （ %属性 に宣言された型から）`~JS値に変換する$( %R )
◎
Return the result of converting R to a JavaScript value of the type attribute is declared as.
</li>
		</ol>

<p id="cp-if-E-thrown">
上で`例外が投出された$ときは、
その例外 %E に対し：
◎
And then, if an exception E was thrown:
</p>
		<ol>
			<li>
~IF［
%属性 の型は`~promise型$である
］
⇒
~RET
~NOABRUPT `Call$A( `Promise.reject$jI, `Promise$jI, « %E » )
◎
If attribute’s type is a promise type, then return ! Call(%Promise.reject%, %Promise%, «E»).
</li>
			<li id="cp-throw-E">
~ELSE
⇒
`~THROW$ %E
◎
Otherwise, end these steps and allow the exception to propagate.
</li>
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<li>
%名前 ~LET 次を順に`連結する$
⇒＃
文字列 `get^l,
`0020^U ~SPACE,
%属性 の`識別子$
◎
Let name be the string "get " prepended to attribute’s identifier.
</li>
	<li id="cp-SetFunctionName-name-F">
`SetFunctionName$A( %F, %名前 )
◎
Perform SetFunctionName(F, name).
</li>
	<li id="cp-SetFunctionLength-F-0">
`SetFunctionLength$A( %F, 0 )
◎
Perform SetFunctionLength(F, 0).
</li>
	<!--cp-ret-F-->
</ol>
</div>

<div class="algo">
<p>
`属性~設定子を作成する@
~algoは、
所与の
( `属性$ %属性, `~ns$または`~ifc$ %target, `~realm$ %~realm )
に対し：
◎
The attribute setter is created as follows, given an attribute attribute, a namespace or interface target, and a realm realm:
</p>
<ol>
	<li>
<p>
~IF［
%target は`~ns$である
］：
◎
If target is a namespace:
</p>
		<ol>
			<li>
~Assert：
%属性 は`読専$である
◎
Assert: attribute is read only.
</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
	<li>
~IF［
%属性 は`読専$である
］~AND［
%属性 は［
`LegacyLenientSetter$x, `PutForwards$x, `Replaceable$x
］いずれの`拡張d属性$も伴わない
］
⇒
~RET `undefined^jv
— `属性~設定子$ 関数は無い。
◎
If attribute is read only and does not have a [LegacyLenientSetter], [PutForwards] or [Replaceable] extended attribute, return undefined; there is no attribute setter function.
</li>
	<li>
~Assert：
%属性 の型は`~promise型$でない
◎
Assert: attribute’s type is not a promise type.
</li>
	<li class="algo">
<p id="cp-let-steps">
%手続き ~LET 以下を遂行する手続き：
◎
Let steps be the following series of steps:
</p>
		<ol>
			<li>
%V ~LET `undefined^jv
◎
Let V be undefined.
</li>
			<li>
~IF［
1 個以上の引数が渡された
］
⇒
%V ~SET 渡された最初の引数の値
◎
If any arguments were passed, then set V to the value of the first argument passed.
</li>
			<li>
%識別子 ~LET %属性 の`識別子$
◎
Let id be attribute’s identifier.
</li>
			<!--cp-let-idlObject-null-->
			<li>
<p>
~IF［
%属性 は`正則~属性$である
］：
◎
If attribute is a regular attribute:
</p>
				<ol>
					<!--cp-let-jsValue-this-or-global-->
					<li>
~IF［
%~js値 は `~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, %識別子, `設定子^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, id, and "setter".
</li>
					<li>
%~thisは妥当か ~LET ~IS［
%~js値 は %target を`実装-$する
］
◎
Let validThis be true if jsValue implements target, or false otherwise.
</li>
					<li>
~IF［
%~thisは妥当か ~EQ ~F
］~AND［
%属性 には `LegacyLenientThis$x `拡張d属性$は指定されていない
］
⇒
`~THROW$ `TypeError$jt
◎
If validThis is false and attribute was not specified with the [LegacyLenientThis] extended attribute, then throw a TypeError.
</li>
					<li>
<p>
~IF［
%属性 は `Replaceable$x 拡張d属性を伴って宣言された
］：
◎
If attribute is declared with the [Replaceable] extended attribute, then:
</p>
						<ol>
							<li>
~ABRUPT `CreateDataPropertyOrThrow$A( %~js値, %識別子, %V )
◎
Perform ? CreateDataPropertyOrThrow(jsValue, id, V).
</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
					<li>
~IF［
%~thisは妥当か ~EQ ~F
］
⇒
~RET `undefined^jv
◎
If validThis is false, then return undefined.
</li>
					<li>
~IF［
%属性 は `LegacyLenientSetter$x 拡張d属性を伴って宣言された
］
⇒
~RET `undefined^jv
◎
If attribute is declared with a [LegacyLenientSetter] extended attribute, then return undefined.
</li>
					<li>
<p>
~IF［
%属性 は `PutForwards$x 拡張d属性を伴って宣言された
］：
◎
If attribute is declared with a [PutForwards] extended attribute, then:
</p>
						<ol>
							<li>
%Q ~LET
~ABRUPT `Get$A( %~js値, %識別子 )
◎
Let Q be ? Get(jsValue, id).
</li>
							<li>
~IF［
%Q は `Object$jt でない
］
⇒
`~THROW$ `TypeError$jt
◎
If Q is not an Object, then throw a TypeError.
</li>
							<li>
%回送-~ID ~LET `PutForwards$x 拡張d属性の識別子~引数
◎
Let forwardId be the identifier argument of the [PutForwards] extended attribute.
</li>
							<li>
~ABRUPT `Set$A( %Q, %回送-~ID, %V, `false^jv )
◎
Perform ? Set(Q, forwardId, V, false).
</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
					<!--cp-set-idlObject-ifc-->
					<li>
<p>
~IF［
%属性 の型は 型~引数 %T を伴う`観測-可能な配列~型$である
］：
◎
If attribute’s type is an observable array type with type argument T:
</p>
						<ol>
							<li>
%新たな値~群 ~LET `~IDL値に変換する$( %V, `連列~型$ )
◎
Let newValues be the result of converting V to an IDL value of type sequence&lt;T&gt;.
</li>
							<li>
%観測-可能な配列 ~LET %~idl~obj の
%属性 を`~backしている観測-可能な配列~exotic~obj$
◎
Let oa be idlObject’s attribute’s backing observable array exotic object.
</li>
							<li>
`観測-可能な配列~exotic~objの長さを設定する$( %観測-可能な配列.`ProxyHandler^sl, 0 )
◎
Set the length of oa.[[ProxyHandler]] to 0.
</li>
							<li>
<p>
~EACH( %i ~IN { 0 〜 %新たな値~群 の`~size$ ~MINUS 1 } )
に対し，昇順に：
◎
Let i be 0.
◎
While i &lt; newValues’s size:
</p>
【！原文抜け %i += 1 】
								<ol>
									<li>
%観測-可能な配列.`ProxyHandler^sl.`SetAlgorithm^sl( %新たな値~群[ %i ], %i )
◎
Perform the algorithm steps given by oa.[[ProxyHandler]].[[SetAlgorithm]], given newValues[i] and i.
</li>
									<li>
%観測-可能な配列.`ProxyHandler^sl.`BackingList^sl に %新たな値~群[ %i ] を`付加する$
◎
Append newValues[i] to oa.[[ProxyHandler]].[[BackingList]].
</li>
								</ol>
							</li>
							<li>
~RET `undefined^jv
◎
Return undefined.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%~idl値 ~LET ε
◎
Let idlValue be determined as follows:
</li>
			<li>
<p>
~IF［
%属性 の型 は`列挙$である
］：
◎
attribute’s type is an enumeration
</p>
				<ol>
					<li>
%S ~LET
~ABRUPT `ToString$A( %V )
◎
Let S be ? ToString(V).
</li>
					<li>
~IF［
%S は `列挙~値$のいずれでもない
］
⇒
~RET `undefined^jv
◎
If S is not one of the enumeration’s values, then return undefined.
</li>
					<li>
%~idl値 ~SET %S に等しい列挙~値
◎
Otherwise, idlValue is the enumeration value equal to S.
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
%~idl値 ~SET `~IDL値に変換する$( %V, %属性 の型 )
◎
Otherwise
• idlValue is the result of converting V to an IDL value of attribute’s type.
</li>
			<li>
%属性 の`設定子~手続き$を［
`this$V として %~idl~obj,
`所与の値$として %~idl値
］を与える下で遂行する
◎
Perform the setter steps of attribute, with idlObject as this and idlValue as the given value.
</li>
			<li>
~RET `undefined^jv
◎
Return undefined
</li>
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<li>
%名前 ~LET 次を順に`連結する$
⇒＃
文字列 `set^l,
`0020^U ~SPACE,
%識別子
◎
Let name be the string "set " prepended to id.
</li>
	<!--cp-SetFunctionName-name-F-->
	<li id="cp-SetFunctionLength-F-1">
`SetFunctionLength$A( %F, 1 )
◎
Perform SetFunctionLength(F, 1).
</li>
	<!--cp-ret-F-->
</ol>
</div>

<p class="note">注記：
ある~IDL属性に対応する~propは 1 個に限られるが、
~accessor~propの［
取得子／設定子
］には［
当の~propが~accessされた~obj
］を指す `this$V 値が渡されるので、
それらの［
取得子／設定子
］は，~instanceに特有な~dataを公開できる。
◎
Note: Although there is only a single property for an IDL attribute, since accessor property getters and setters are passed a this value for the object on which property corresponding to the IDL attribute is accessed, they are able to expose instance-specific data.
</p>

<p class="note">注記：
`読専$な`属性$に対応する~propへ代入するよう試みた結果の挙動は、
それを行う~scriptが~strict-modeであるかどうかに依存して異なる。
~strict-modeならば， `TypeError$jE が投出され、
そうでないならば，代入の試みは無視されることになる。
◎
Note: Attempting to assign to a property corresponding to a read only attribute results in different behavior depending on whether the script doing so is in strict mode. When in strict mode, such an assignment will result in a TypeError being thrown. When not in strict mode, the assignment attempt will be ignored.
</p>

			</section>
			<section id="js-operations">
<h4 title="Operations">3.7.7. 演算</h4>

<p>
［
`~ifc$上に定義され, `公開されて$いる`演算$
］の各 一意な`識別子$ごとに，対応する~propが存在する。
`静的~演算$は、
`~ifc~obj$上に公開される。
`正則~演算$は、
`~ifc原型~obj$上に公開される
— ただし，［
演算は`偽造-不能$である ／
当の~ifcは `Global$x `拡張d属性$を伴って宣言された
］事例では、
~ifcを`実装-$する どの~obj上にも公開される。
◎
For each unique identifier of an exposed operation defined on the interface, there exist a corresponding property. Static operations are exposed of the interface object. Regular operations are exposed on the interface prototype object, unless the operation is unforgeable or the interface was declared with the [Global] extended attribute, in which case they are exposed on every object that implements the interface.
</p>

<div class="algo">
<p>
`正則~演算を定義する@
~algoは、
所与の
( `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the regular operations of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
%演算~群 ~LET ［
%定義 を成す`~mb$のうち，`正則~演算$である, かつ
`偽造-不能$でないもの
］からなる`~list$
◎
Let operations be the list of regular operations that are members of definition.
◎
Remove from operations all the operations that are unforgeable.
</li>
	<li id="cp-define-op">
`演算を定義する$( %演算~群, %定義, %~target, %~realm )
◎
Define the operations operations of definition on target given realm.
</li>
</ol>
</div>

<div class="algo">
<p>
`静的~演算を定義する@
~algoは、
所与の
( `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the static operations of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
%演算~群 ~LET ［
%定義 を成す`~mb$のうち，`静的~演算$であるもの
］からなる`~list$
◎
Let operations be the list of static operations that are members of definition.
</li>
	<!--cp-define-op-->
</ol>
</div>

<div class="algo">
<p>
`偽造-不能な正則~演算を定義する@
~algoは、
所与の
( `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the unforgeable regular operations of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
%演算~群 ~LET ［
%定義 を成す`~mb$のうち，`正則~演算$である, かつ
`偽造-不能$であるもの
］からなる`~list$
◎
Let operations be the list of unforgeable regular operations that are members of definition.
</li>
	<!--cp-define-op-->
</ol>
</div>

<div class="algo">
<p>
`演算を定義する@
~algoは、
所与の
( %演算~群, `~ifc$／`~ns$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the operations operations of interface or namespace definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
<p>
%演算~群 を成す
~EACH( `演算$ %演算 )
に対し：
◎
For each operation op of operations:
</p>

		<ol>
			<li>
~IF［
%演算 は %~realm 内に`公開されて$いない
］
⇒
~CONTINUE
◎
If op is not exposed in realm, then continue.
</li>
			<li>
%~method ~LET `演算~関数を作成する$( %演算, %定義, %~realm )
◎
Let method be the result of creating an operation function given op, definition, and realm.
</li>
			<li>
%M ~LET ［
%演算 は`偽造-不能$であるならば `false^jv ／
~ELSE_ `true^jv
］
◎
Let modifiable be false if op is unforgeable and true otherwise.
</li>
			<li>
%記述子 ~LET `MTM-method^desc
◎
Let desc be the PropertyDescriptor{[[Value]]: method, [[Writable]]: modifiable, [[Enumerable]]: true, [[Configurable]]: modifiable}.
</li>
			<li>
%識別子 ~LET %演算 の`識別子$
◎
Let id be op’s identifier.
</li>
			<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~target, %識別子, %記述子 )
◎
Perform ! DefinePropertyOrThrow(target, id, desc).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`演算~関数を作成する@
~algoは、
所与の
( `演算$ %op, `~ns$または`~ifc$ %target, `~realm$ %~realm )
に対し：
◎
To create an operation function, given an operation op, a namespace or interface target, and a realm realm:
</p>
<ol>
	<li>
%識別子 ~LET %op の`識別子$
◎
Let id be op’s identifier.
</li>
	<li class="algo">
<p>
%手続き ~LET 所与の
( 関数~引数~list %引数~群 )
に対し，次を走らす手続き
— ただし，手続きの中で`例外が投出された$ときは、
その下に与える手続きを走らすとする：
◎
Let steps be the following series of steps, given function argument values args:
◎
Try running the following steps:
</p>
		<ol>
			<!--cp-let-idlObject-null-->
			<li>
<p>
~IF［
%target は`~ifc$である
］~AND［
%op は`静的~演算$でない
］：
◎
If target is an interface, and op is not a static operation:
</p>
				<ol>
					<!--cp-let-jsValue-this-or-global-->
					<li>
~IF［
%~js値 は `~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, %識別子, `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, id, and "method".
</li>
					<li>
~IF［
%~js値 は ~ifc %target を`実装-$しない
］
⇒
`~THROW$ `TypeError$jt
◎
If jsValue does not implement the interface target, throw a TypeError.
</li>
					<!--cp-set-idlObject-ifc-->
				</ol>
			</li>
			<!--cp-let-n-args-size-->
			<li>
<p>
%S ~LET %target の［
%op が［
正則~演算ならば`正則~演算$ ／ 静的~演算ならば`静的~演算$
］］用の`有効-多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 %n )
◎
Compute the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count n, and let S be the result.
</li>
			<li>
&lt;%演算, %値~群&gt; ~LET
( %S, %引数~群 )
を`多重定義~解決~algo$に渡した結果
◎
Let &lt;operation, values&gt; be the result of passing S and args to the overload resolution algorithm.
</li>
			<li>
%R ~LET ~NULL
◎
Let R be null.
</li>
			<li>
<p>
~IF［
%演算 は `Default$x 拡張d属性を伴って宣言された
］：
◎
If operation is declared with a [Default] extended attribute, then:
</p>
				<ol>
					<li>
~Assert：
%演算 は`既定の~method手続きを有する$
◎
Assert: operation has default method steps.
</li>
					<li>
%R ~SET %演算 用の`既定の~method手続き$を［
`this$V として %~idl~obj,
引数~list %値~群
］を与える下で走らせた結果
◎
Set R to the result of running the default method steps for operation, with idlObject as this and values as the argument values.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE
⇒
%R ~SET %演算 用の`~method手続き$を［
`this$V として %~idl~obj,
引数~list %値~群
］を与える下で走らせた結果
◎
Otherwise, set R to the result of running the method steps of operation, with idlObject as this and values as the argument values.
</li>
			<li>
<p>
~RET `~JS値に変換する$( %R )
◎
Return R, converted to a JavaScript value.
</p>

<p class="issue">
%R は %op の返り値に宣言された型の~IDL値と見做される。
[`課題 #674＠~WEBIDLissue/674$]
◎
R is assumed to be an IDL value of the type op is declared to return. [whatwg/webidl Issue #674]
</p>
			</li>
		</ol>

<!--cp-if-E-thrown-->
		<ol>
			<li>
~IF［
%op の`返り値~型$は `~promise型$である
］
⇒
~RET 
~NOABRUPT `Call$A( `Promise.reject$jI, `Promise$jI, « %E » )
◎
If op has a return type that is a promise type, then return ! Call(%Promise.reject%, %Promise%, «E»).
</li>
			<!--cp-throw-E-->
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<!--cp-SetFunctionName-F-id-->
	<li>
%S ~LET %target の［
%op が［
正則~演算ならば`正則~演算$ ／ 静的~演算ならば`静的~演算$
］］用の`有効-多重定義~集合を算出する$( `識別子$ %識別子, 引数個数 0 )
◎
Compute the effective overload set for regular operations (if op is a regular operation) or for static operations (if op is a static operation) with identifier id on target and with argument count 0, and let S be the result.
</li>
	<li>
%長さ ~LET %S 内の各~entryの引数~listの長さのうち，最小
◎
Let length be the length of the shortest argument list in the entries in S.
</li>
	<!--cp-SetFunctionLength-F-length-->
	<!--cp-ret-F-->
</ol>
</div>

				<section id="js-default-operations">
<h5 title="Default operations">3.7.7.1. 既定の演算</h5>

<p>
`正則~演算$のうち［
その`識別子$は，次の表tの 1 列目に現れるもの
］は、
`既定の~method手続きを有する@
とされ，その
`既定の~method手続き@
は［
同じ行の 2 列目から~linkされる~algo
］で与えられる。
その返り値は、
同じ行の 3 列目に与える型でなければナラナイ。
◎
A regular operation has default method steps if its identifier appears in the first column of the following table. In that case, its default method steps are those given by the algorithm linked from the second column of the table, and the operation must have the return type given in the third column of the table.
</p>

<div>
<table id="table-default-method-steps">
<thead>
<tr><th>`識別子$
<th>`既定の~method手続き$
<th>`返り値~型$
<tbody>

<tr><td>`toJSON^l
<td>`既定の~toJSON手続き$
<td>`object$T
</table>

◎
Identifier｜Default method steps｜Return type
"toJSON"｜The default toJSON steps｜object
</div>

<p>
`既定の~method手続きを有する$もの以外の`正則~演算$は、
`Default$x `拡張d属性$を伴って宣言してはナラナイ。
◎
A regular operation that does not have default method steps must not be declared with a [Default] extended attribute.
</p>

					<section id="js-default-tojson">
<h6 title="Default toJSON operation">3.7.7.1.1. 既定の~toJSON演算</h6>

<div class="algo">
<p>
`~ifc$ %I 用の
`既定の~toJSON手続き@
は：
◎
The default toJSON steps for an interface I are:
</p>
<ol>
	<li>
%~map ~LET 新たな`有順序~map$
◎
Let map be a new ordered map.
</li>
	<li>
%~stack ~LET `継承~stackを作成する$( %I )
◎
Let stack be the result of creating an inheritance stack for interface I.
</li>
	<li>
`継承~stackの属性~値を収集する$( `this$V, %~stack, %~map )
◎
Invoke collect attribute values of an inheritance stack given this, stack, and map.
</li>
	<li>
%結果 ~LET
`OrdinaryObjectCreate$A( `Object.prototype$jI )
◎
Let result be OrdinaryObjectCreate(%Object.prototype%).
</li>
	<li>
<p>
%~map を成す
~EACH( %~key → %値 )
に対し：
◎
For each key → value of map,
</p>
		<ol>
			<li>
%k ~LET `~JS値に変換する$( %~key )
◎
Let k be key converted to a JavaScript value.
</li>
			<li>
%v ~LET `~JS値に変換する$( %値 )
◎
Let v be value converted to a JavaScript value.
</li>
			<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %結果, %k, %v )
◎
Perform ! CreateDataPropertyOrThrow(result, k, v).
</li>
		</ol>
	</li>
	<li>
~RET %結果
◎
Return result.
</li>
</ol>
</div>

<div class="algo">
<p>
`継承~stackの属性~値を収集する@
~algoは、
所与の
( `~platform~obj$ %object, `~stack$ %~stack, `有順序~map$ %~map )
に対し：
◎
To collect attribute values of an inheritance stack given a platform object object, a stack stack, and an ordered map map:
</p>
<ol>
	<li>
%I ~LET %~stack から`~popする$
◎
Let I be the result of popping from stack.
</li>
	<li>
`属性~値を収集する$( %object, %I, %~map )
◎
Invoke collect attribute values given object, I, and map.
</li>
	<li>
~IF［
%~stack は`空$でない
］
⇒
`継承~stackの属性~値を収集する$( %object, %~stack, %~map )
◎
If stack is not empty, then invoke collect attribute values of an inheritance stack given object, stack, and map.
</li>
</ol>
</div>

<div class="algo">
<p>
`属性~値を収集する@
~algoは、
所与の
( `~platform~obj$ %object, `~ifc$ %I, `有順序~map$ %~map )
に対し：
◎
To collect attribute values given a platform object object, an interface I, and an ordered map map:
</p>
<ol>
	<li>
~IF［
%I 上に［
`Default$x `拡張d属性$を伴う~toJSON演算
］は宣言されてない
］
⇒
~RET
◎
If a toJSON operation with a [Default] extended attribute is declared on I, then＼
</li>
	<li>
<p>
%I を成す`~ifc~mb$のうち，`公開されて$いる, かつ`正則~属性$である
~EACH( %属性 )
に対し：
◎
for each exposed regular attribute attr that is an interface member of I, in order:
</p>
		<ol>
			<li>
%識別子 ~LET %属性 の`識別子$
◎
Let id be the identifier of attr.
</li>
			<li>
%値 ~LET %属性 の`取得子~手続き$を［
`this$V として %object
］を与える下で走らせた結果
◎
Let value be the result of running the getter steps of attr with object as this.
</li>
			<li>
~IF［
%値 は`~JSON型$である
］
⇒
%~map[ %識別子 ] ~SET %値
◎
If value is a JSON type, then set map[id] to value.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`継承~stackを作成する@
~algoは、
所与の
( `~ifc$ %I )
に対し
⇒
~RET `~stack$としての次の結果
⇒
`~cloneする$( %I の`自身も含む継承した~ifc群$ )
◎
To create an inheritance stack for interface I, run the following steps:
• Let stack be a new stack.
• Push I onto stack.
• While I inherits from an interface,
•• Let I be that interface.
•• Push I onto stack.
• Return stack.
</p>
</div>

<div class="example">
<p>
`~ifc$のうち［
`Default$x `拡張d属性$を伴って `toJSON^M 演算を宣言するもの
］の`正則~属性$に限り，含まれる【 “値が収集される” 】
— それを`継承した~ifc群$を成すいずれかの~ifcが，そのような `toJSON^M 演算を宣言する場合でも。
例えば、
次の`~IDL片$を考える：
◎
Only regular attributes of interfaces that declare a toJSON operation with a [Default] extended attribute are included, even if an inherited interface declares such a toJSON operation. For example, consider the following IDL fragment:
</p>

<pre class="webidl">
[Exposed=Window]
interface A {
  [Default] object toJSON();
  attribute DOMString a;
};

[Exposed=Window]
interface B : A {
  attribute DOMString b;
};

[Exposed=Window]
interface C : B {
  [Default] object toJSON();
  attribute DOMString c;
};
</pre>

<p>
上で定義した~ifc `C^T を実装している~objの
`toJSON()^M ~methodを~callしたなら、
次を返すことになろう：
◎
Calling the toJSON() method of an object implementing interface C defined above would return the following JSON object:
</p>


<pre class="lang-js">
{
    "a": "...",
    "c": "..."
}
</pre>

<p>
上で定義した~ifc `A^T （または `B^T ）を実装している~objの
`toJSON()^M ~methodを~callしたなら、
次を返すことになろう
◎
Calling the toJSON() method of an object implementing interface A (or B) defined above would return:
</p>

<pre class="lang-js">
{
    "a": "..."
}
</pre>

<p>
`toJSON^M 演算は、
`~ifc~mixin$（または`部分的な~ifc$）上でも宣言でき，
元の`~ifc$上で宣言することに等価になる。
例えば、
次の`~IDL片$を考える：
◎
A toJSON operation can also be declared on an interface mixin (or partial interface) and is equivalent to declaring it on the original interface. For example, consider the following IDL fragment:
</p>

<pre class="webidl">
[Exposed=Window]
interface D {
  attribute DOMString d;
};

interface mixin M {
  [Default] object toJSON();
  attribute DOMString m;
};

D includes M;
</pre>

<p>
上で定義した~ifc `D^T を実装している~objの
`toJSON()^M ~methodを~callしたなら、
次を返すことになろう：
◎
Calling the toJSON() method of an object implementing interface D defined above would return:
</p>

<pre class="lang-js">
{
    "d": "...",
    "m": "..."
}
</pre>
</div>

					</section>
				</section>
			</section>
			<section id="js-stringifier">
<h4 title="Stringifiers">3.7.8. 文字列化子</h4>

<div class="p">
<p>
`~ifc$に`公開されて$いる`文字列化子$ %文字列化子 が在る場合、
次の特性を伴う~propが存在するモノトスル：
</p>
<ul>
	<li>
名前：
`toString^l
</li>
	<li>
値：
下に与える`組込みの関数~obj$ %F
</li>
	<li>
次の属性を伴う
⇒
`BTB^desc
— ここで %B は、［
%文字列化子 が~ifc上で`偽造-不能$である場合は `false^jv ／
~ELSE_ `true^jv
］とする。
</li>
</ul>

<p>
~propの所在は：
</p>

<ul>
	<li>
%文字列化子 が~ifc上で`偽造-不能$であるか, または
~ifcが `Global$x 拡張d属性を伴って宣言されたならば、
~ifcを`実装-$するどの~obj上にも存在する。
</li>
	<li>
他の場合、
~ifc用の`~ifc原型~obj$上に存在する。
</li>
</ul>

◎
If the interface has an exposed stringifier, then there must exist a property with the following characteristics:
• The name of the property is "toString".
• If the stringifier is unforgeable on the interface or if the interface was declared with the [Global] extended attribute, then the property exists on every object that implements the interface. Otherwise, the property exists on the interface prototype object.
• The property has attributes { [[Writable]]: B, [[Enumerable]]: true, [[Configurable]]: B }, where B is false if the stringifier is unforgeable on the interface, and true otherwise.
• The value of the property is a built-in function object,＼
</div>

<div class="algo">
<p>
~prop値 %F が呼出されたときは，次に従って挙動するモノトスル：
◎
which behaves as follows:
</p>
<ol>
	<li>
%O ~LET
~ABRUPT `ToObject$A( `this^jv 値 )
◎
Let thisValue be the this value.
◎
Let O be ? ToObject(thisValue).
</li>
	<li>
~IF［
%O は `~platform~objである$
］
⇒
`~security検査を遂行する$( %O, %文字列化子 の`識別子$, `~method^C )
◎
If O is a platform object, then perform a security check, passing:
• the platform object O,
• the identifier of the stringifier, and
• the type "method".
</li>
	<li>
~IF［
%O は %文字列化子 を宣言する~ifcを`実装-$しない
］
⇒
`~THROW$ `TypeError$jt
◎
If O does not implement the interface on which the stringifier was declared, then throw a TypeError.
</li>
	<li>
%V ~LET ε
◎
Let V be an uninitialized variable.
</li>
	<li>
~IF［
`stringifier^sym は宣言として指定された
］
⇒
%V ~SET 当の~ifcの`文字列~化の挙動$を遂行した結果
◎
Depending on how stringifier was specified:
◎
as a declaration
• Set V to the result of performing the stringification behavior of the interface.
</li>
	<li>
<p>
~ELSE（ `stringifier^sym はある`属性$ %属性 に指定された）：
</p>
		<ol>
			<li>
~IF［
%属性 は`取得子を継承する$ものと宣言された
］
⇒
%属性 ~SET %属性 が継承した属性
</li>
			<li>
%V ~SET %O の %属性 の`取得子~手続き$を［
`this$V として %O
］を与える下で走らせた結果
</li>
		</ol>
◎
on an attribute
• Set V to the result of running the getter steps of the attribute (or those listed in the getter steps of the inherited attribute, if this attribute is declared to inherit its getter), with O as this.
</li>
	<li>
~RET （ `String^jt 型の）`~JS値に変換する$( %V )
◎
Return the result of converting V to a String value.
</li>
</ol>
</div>

<p id="cp-length-is-0">
この`関数~obj$の `length^jp ~propの値は、
`Number^jt 値 `0^jv とする。
◎
The value of the function object’s length property is the Number value 0.
</p>

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `toString^l とする。
◎
The value of the function object’s name property is the String value "toString".
</p>

			</section>
			<section id="js-iterable">
<h4 title="Iterable declarations">3.7.9. 可反復~宣言</h4>

<div class="algo">
<p>
`反復子~methodを定義する@
~algoは、
所与の
( `~ifc$ %定義, %~target, `~realm$ %~realm )
に対し：
◎
To define the iteration methods of interface definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
<p>
~IF［
%定義 は`有index~prop取得子$を有する
］：
◎
If definition has an indexed property getter, then:
</p>
		<ol>
			<li>
`DefineMethodProperty$A( %~target, `Symbol.iterator$jI, `Array.prototype.values$jI, `false^jv )
◎
Perform DefineMethodProperty(target, %Symbol.iterator%, %Array.prototype.values%, false).
</li>
			<li>
<p>
~IF［
%定義 は`値~反復子$を有する
］：
◎
If definition has a value iterator, then:
</p>
				<ol>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `entries^l, `Array.prototype.entries$jI )
◎
Perform ! CreateDataPropertyOrThrow(target, "entries", %Array.prototype.entries%).
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `keys^l, `Array.prototype.keys$jI )
◎
Perform ! CreateDataPropertyOrThrow(target, "keys", %Array.prototype.keys%).
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `values^l, `Array.prototype.values$jI )
◎
Perform ! CreateDataPropertyOrThrow(target, "values", %Array.prototype.values%).
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `forEach^l, `Array.prototype.forEach$jI )
◎
Perform ! CreateDataPropertyOrThrow(target, "forEach", %Array.prototype.forEach%).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
%定義 は`~pair反復子$を有する
］：
◎
Otherwise, if definition has a pair iterator, then:
</p>
		<ol>
			<li>
<p>
［
`Symbol.iterator$jI ~method, `entries^jp ~method
］を定義する：
◎
Define the %Symbol.iterator% and entries methods:
</p>
				<ol>
					<li class="algo">
<!--cp-let-steps-->
						<ol>
							<li id="cp-ToObject-this">
%~js値 ~LET
~ABRUPT `ToObject$A( `this^jv 値 )
◎
Let jsValue be ? ToObject(this value).
</li>
							<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, "`Symbol.iterator^jI", `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "%Symbol.iterator%", and "method".
</li>
							<li id="cp-jsValue-not-implement-definition">
~IF［
%~js値 は %定義 を`実装-$しない
］
⇒
`~THROW$ `TypeError$jt
◎
If jsValue does not implement definition, then throw a TypeError.
</li>
							<li>
~RET %定義 用の新たな`既定の反復子~obj$
— その
⇒＃
`~target$dI ~SET %~js値,
`種類$dI ~SET `key+value^l,
`~index$dI ~SET 0
◎
Return a newly created default iterator object for definition, with jsValue as its target, "key+value" as its kind, and index set to 0.
</li>
						</ol>
					</li>
					<!--cp-CreateBuiltinFunction-->
					<li id="cp-SetFunctionLength-F-entries">
`SetFunctionName$A( %F, `entries^l)
◎
Perform SetFunctionName(F, "entries").
</li>
					<!--cp-SetFunctionLength-F-0-->
					<li>
`DefineMethodProperty$A( %~target, `Symbol.iterator$jI, %F, `false^jv )
◎
Perform DefineMethodProperty(target, %Symbol.iterator%, F, false).
</li>
					<li id="cp-CreateDataPropertyOrThrow-target-entries-F">
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `entries^l, %F )
◎
Perform ! CreateDataPropertyOrThrow(target, "entries", F).
</li>
				</ol>
			</li>
			<li>
<p>
`keys^jp ~methodを定義する：
◎
Define the keys method:
</p>
				<ol>
					<li class="algo">
<!--cp-let-steps-->
						<ol>
							<!--cp-ToObject-this-->
							<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, `keys^l, `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "keys", and "method".
</li>
							<!--cp-jsValue-not-implement-definition-->
							<li>
~RET %定義 用の新たな`既定の反復子~obj$
— その
⇒＃
`~target$dI ~SET %~js値,
`種類$dI ~SET `key^l,
`~index$dI ~SET 0
◎
Return a newly created default iterator object for definition, with jsValue as its target, "key" as its kind, and index set to 0.
</li>
						</ol>
					</li>
					<!--cp-CreateBuiltinFunction-->
					<li>
`SetFunctionName$A( %F, `keys^l)
◎
Perform SetFunctionName(F, "keys").
</li>
					<!--cp-SetFunctionLength-F-0-->
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `keys^l, %F )
◎
Perform ! CreateDataPropertyOrThrow(target, "keys", F).
</li>
				</ol>
			</li>
			<li>
<p>
`values^jp ~methodを定義する：
◎
Define the values method:
</p>
				<ol>
					<li class="algo">
<!--cp-let-steps-->
						<ol>
							<!--cp-ToObject-this-->
							<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, `values^l, `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "values", and "method".
</li>
							<!--cp-jsValue-not-implement-definition-->
							<li>
~RET %定義 用の新たな`既定の反復子~obj$
— その
⇒＃
`~target$dI ~SET %~js値,
`種類$dI ~SET `value^l,
`~index$dI ~SET 0
◎
Return a newly created default iterator object for definition, with jsValue as its target, "value" as its kind, and index set to 0.
</li>
						</ol>
					</li>
					<!--cp-CreateBuiltinFunction-->
					<li id="cp-SetFunctionName-F-values">
`SetFunctionName$A( %F, `values^l)
◎
Perform SetFunctionName(F, "values").
</li>
					<!--cp-SetFunctionLength-F-0-->
					<li id="cp-CreateDataPropertyOrThrow-target-values-F">
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `values^l, %F )
◎
Perform ! CreateDataPropertyOrThrow(target, "values", F).
</li>
				</ol>
			</li>
			<li>
<p>
`forEach^jp ~methodを定義する：
◎
Define the forEach method:
</p>
				<ol>
					<li class="algo">
<p>
%手続き ~LET 所与の関数~引数~値
( %~callback, %~this引数 )
に対し，次を走らす手続き：
◎
Let steps be the following series of steps, given function argument values callback and thisArg:
</p>
						<ol>
							<!--cp-ToObject-this-->
							<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, `forEach^l, `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "forEach", and "method".
</li>
							<!--cp-jsValue-not-implement-definition-->
							<li>
%~idl~callback ~LET `~IDL値に変換する$( %~callback, `Function$T )
◎
Let idlCallback be callback, converted to a Function.
</li>
							<li id="cp-let-idlObject-represent-jsValue">
%~idl~obj ~LET %~js値 への参照を表現する~IDL`~ifc型$の値
◎
Let idlObject be the IDL interface type value that represents a reference to jsValue.
</li>
							<li>
%~pair群 ~LET %~idl~obj の`反復される値~pair群$
◎
Let pairs be idlObject’s list of value pairs to iterate over.
</li>
							<li>
%i ~LET  0
◎
Let i be 0.
</li>
							<li>
<p>
~WHILE［
%i ~LT %~pair群 の`~size$
］：
◎
While i &lt; pairs’s size:
</p>
								<ol>
									<li>
%~pair ~LET %~pair群[ %i ]
◎
Let pair be pairs[i].
</li>
									<li>
`~callback関数を呼出す$( %~idl~callback, 次に与える~list, %~this引数 )
⇒
« %~pair の`値$vP, %~pair の`~key$vP, %~idl~obj »
◎
Invoke idlCallback with « pair’s value, pair’s key, idlObject » and with thisArg as the callback this value.
</li>
									<li>
%~pair群 ~SET %~idl~obj の現在の`反復される値~pair群$
（【前~段により】変化したかもしれない。）
◎
Set pairs to idlObject’s current list of value pairs to iterate over. (It might have changed.)
</li>
									<li>
%i ~INCBY 1
◎
Set i to i + 1.
</li>
								</ol>
							</li>
						</ol>
					</li>
					<!--cp-CreateBuiltinFunction-->
					<li>
`SetFunctionName$A( %F, `forEach^l)
◎
Perform SetFunctionName(F, "forEach").
</li>
					<!--cp-SetFunctionLength-F-1-->
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `forEach^l, %F )
◎
Perform ! CreateDataPropertyOrThrow(target, "forEach", F).
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
</div>

				<section id="js-default-iterator-object">
<h5 title="Default iterator objects">3.7.9.1. 既定の反復子~obj</h5>

<p>
所与の［
`~ifc$, ~target, 反復の種類
］用の
`既定の反復子~obj@
は、
次を満たす~objである
⇒
その `Prototype^sl `内部~slot$は、
~ifc用の`反復子~原型~obj$である
◎
A default iterator object for a given interface, target and iteration kind is an object whose [[Prototype]] internal slot is the iterator prototype object for the interface.
</p>

<p>
`既定の反復子~obj$は、
次に挙げる値を内部に有する：
◎
A default iterator object has three internal values:
</p>
<ul>
	<li>
`~target@dI
⇒
反復される値たちを~~給する~obj
◎
its target, which is an object whose values are to be iterated,
</li>
	<li>
`種類@dI
⇒
反復の種類 
【 ~IN { `key^l, `value^l, `key+value^l } 】
◎
its kind, which is the iteration kind,
</li>
	<li>
`~index@dI
⇒
反復されることになる値を指す，現在の~index
◎
its index, which is the current index into the values to be iterated.
</li>
</ul>

<p class="note">注記：
既定の反復子~objは、
`~pair反復子$のみに利用される
—
`値~反復子$は，現時点では、
~objが`~supportする~prop~index$を反復するように制約されており，
標準な~JS `Array^jt 反復子~objを利用する。
◎
Note: Default iterator objects are only used for pair iterators; value iterators, as they are currently restricted to iterating over an object’s supported indexed properties, use standard JavaScript Array iterator objects.
</p>

<p class="note">注記：
`既定の反復子~obj$には`~class文字列$は無い。
所与の`~ifc$の`既定の反復子~obj$上で
`Object.prototype.toString()^c が~callされたときは、
その~ifcの`~class文字列$が利用されるとする。
◎
Note: Default iterator objects do not have class strings; when Object.prototype.toString() is called on a default iterator object of a given interface, the class string of the iterator prototype object of that interface is used.
</p>

				</section>
				<section id="js-iterator-prototype-object">
<h5 title="Iterator prototype object">3.7.9.2. 反復子~原型~obj</h5>

<p>
`~pair反復子$を有する どの`~ifc$に対しても、
`反復子~原型~obj@
と呼ばれる~objが存在する。
それは、
その~ifc用の`既定の反復子~obj$の原型として~serveする。
◎
The iterator prototype object for a given interface is an object that exists for every interface that has a pair iterator. It serves as the prototype for default iterator objects for the interface.
</p>

<p>
`反復子~原型~obj$の `Prototype^sl `内部~slot$は、
`Iterator.prototype$jI でなければナラナイ。
◎
The [[Prototype]] internal slot of an iterator prototype object must be %Iterator.prototype%.
</p>

<div class="algo">
<p>
`反復子~結果@
は、
所与の
( `値~pair$ %~pair, 種類 %種類 )
に対し，次の手続きで与えられる：
◎
The iterator result for a value pair pair and a kind kind is given by the following steps:
</p>
<ol>
	<li>
<p>
%結果 ~LET %種類 に応じて，次で決定される値：
◎
Let result be a value determined by the value of kind:
</p>
		<dl class="switch">
			<dt>`key^l</dt>
			<dd>
				<ol>
					<li id="cp-let-idlkey-of-pair">
%~idl~key ~LET %~pair の~key
◎
Let idlKey be pair’s key.
</li>
					<li id="cp-idlKey-toES">
%~key ~LET `~JS値に変換する$( %~idl~key )
◎
Let key be the result of converting idlKey to a JavaScript value.
</li>
					<li>
%結果 ~SET %~key
◎
result is key.
</li>
				</ol>
			</dd>

			<dt>`value^l</dt>
			<dd>
				<ol>
					<li id="cp-let-idlValue-of-pair">
%~idl値 ~LET %~pair の~key
◎
Let idlValue be pair’s value.
</li>
					<!--cp-idlValue-toES-->
					<li>
%結果 ~SET %値
◎
result is value.
</li>
				</ol>
			</dd>

			<dt>`key+value^l</dt>
			<dd>
				<ol>
					<!--cp-let-idlkey-of-pair-->
					<!--cp-let-idlValue-of-pair-->
					<!--cp-idlKey-toES-->
					<!--cp-idlValue-toES-->
					<li>
%配列 ~LET
~NOABRUPT `ArrayCreate$A( 2 )
◎
Let array be ! ArrayCreate(2).
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %配列, `0^l, %~key )
◎
Perform ! CreateDataPropertyOrThrow(array, "0", key).
</li>
					<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %配列, `1^l, %値 )
◎
Perform ! CreateDataPropertyOrThrow(array, "1", value).
</li>
					<li>
%結果 ~SET %配列
◎
result is array.
</li>
				</ol>
			</dd>
		</dl>
	</li>
	<li>
~RET
`CreateIteratorResultObject$A( %結果, `false^jv )
◎
Return CreateIteratorResultObject(result, false).
</li>
</ol>
</div>

<div class="p">
<p>
`反復子~原型~obj$は、
次の特性を伴う `next^jp ~data~propを有するモノトスル：
</p>
<ul>
	<li id="cp-has-attr-TTT">
次の属性を伴う
⇒
`TTT^desc
</li>
	<li>
値：
下に与える`組込みの関数~obj$
</li>
</ul>
◎
An iterator prototype object must have a next data property with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a built-in function object that behaves as follows:
</div>

<div class="algo">
<p>
この組込みの関数~objは、
次に従って挙動する：
◎
↑</p>
<ol>
	<li>
%~ifc ~LET その`反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the iterator prototype object exists.
</li>
	<li>
%object ~LET
~ABRUPT `ToObject$A( `this^jv 値 )
◎
Let thisValue be the this value.
◎
Let object be ? ToObject(thisValue).
</li>
	<li>
~IF［
%object は `~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `next^l, `~method^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "next", and
• the type "method".
</li>
	<li>
~IF［
%object は %~ifc 用の`既定の反復子~obj$でない
］
⇒
`~THROW$ `TypeError$jt
◎
If object is not a default iterator object for interface, then throw a TypeError.
</li>
	<li>
%~index ~LET %object の~index
◎
Let index be object’s index.
</li>
	<li>
%種類 ~LET %object の種類
◎
Let kind be object’s kind.
</li>
	<li>
%値~群 ~LET %object の`~target$dIの`反復される値~pair群$
◎
Let values be object’s target’s value pairs to iterate over.
</li>
	<li>
~IF［
%~index ~GTE %値~群 の長さ
］
⇒
~RET
`CreateIteratorResultObject$A( `undefined^jv, `true^jv )
◎
Let len be the length of values.
◎
If index is greater than or equal to len, then return CreateIteratorResultObject(undefined, true).
</li>
	<li>
%~pair ~LET %値~群 内の %~index に位置する~entry
◎
Let pair be the entry in values at index index.
</li>
	<li>
%object の~index ~SET %~index ~PLUS 1
◎
Set object’s index to index + 1.
</li>
	<li>
~RET `反復子~結果$( %~pair, %種類 )
◎
Return the iterator result for pair and kind.
</li>
</ol>
</div>

<p>
所与の`~ifc$用の`反復子~原型~obj$の`~class文字列$は、
次の結果になるとする
⇒
次を順に`連結する$
⇒＃
当の~ifcの`識別子$,
`0020^U ~SPACE,
文字列 `Iterator^l
◎
The class string of an iterator prototype object for a given interface is the result of concatenating the identifier of the interface and the string " Iterator".
</p>

				</section>
			</section>
			<section id="js-asynchronous-iterable">
<h4 title="Asynchronous iterable declarations">3.7.10. 非同期な可反復~宣言</h4>

<div class="algo">
<p>
`非同期~反復子~methodを定義する@
~algoは、
所与の
( `~ifc$ %定義, %~target, 所与の`~realm$ %~realm )
に対し：
◎
To define the asynchronous iteration methods of interface definition on target, given realm realm, run the following steps:
</p>
<ol>
	<li>
~IF［
%定義 は`非同期に可反復な宣言$【！(of either sort)】を有さない
］
⇒
~RET
◎
If definition does not have an an asynchronously iterable declaration (of either sort), then return.
</li>
	<li>
~Assert：
%定義 は`有index~prop取得子$も`可反復~宣言$も有さない
◎
Assert: definition does not have an indexed property getter or an iterable declaration.
</li>
	<li>
<p>
~IF［
%定義 は`~pairを非同期に可反復な宣言$を有する
］：
◎
If definition has a pair asynchronously iterable declaration, then＼
</p>

<p>
（この段は、
`Symbol.asyncIterator$jI, `entries^jp 両~methodを定義する）
◎
define the %Symbol.asyncIterator% and entries methods:
</p>

		<ol>
			<li class="algo">
<p id="cp-let-steps-args">
%手続き ~LET 所与の
( 関数~引数~list %引数~群 )
に対し，次を走らす手続き：
◎
Let steps be the following series of steps, given function argument values args:
</p>
				<ol>
					<!--cp-ToObject-this-->
					<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, "`Symbol.asyncIterator^jI", `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "%Symbol.asyncIterator%", and "method".
</li>
					<!--cp-jsValue-not-implement-definition-->
					<!--cp-let-idlObject-represent-jsValue-->
					<li id="cp-let-convert-args-for-async">
%~idl引数~群 ~LET `非同期~反復子~method用の引数を変換する$( %引数~群 )
◎
Let idlArgs be the result of converting arguments for an asynchronous iterator method given args.
</li>

					<li>
%反復子 ~LET %定義 用の新たな`既定の非同期~反復子~obj$
— その
⇒＃
`~target$aI ~SET %~idl~obj,
`種類$aI ~SET `key+value^l,
`完遂したか$aI ~SET ~F
◎
Let iterator be a newly created default asynchronous iterator object for definition with idlObject as its target, "key+value" as its kind, and is finished set to false.
</li>
					<li id="cp-run-async-iterator-init">
~IF［
%定義 用の`非同期~反復子の初期化~手続き$は存在する
］
⇒
その手続き( %~idl~obj, %反復子, %~idl引数~群 )
◎
Run the asynchronous iterator initialization steps for definition with idlObject, iterator, and idlArgs, if any such steps exist.
</li>
					<li>
~RET %反復子
◎
Return iterator.
</li>
				</ol>
			</li>
			<!--cp-CreateBuiltinFunction-->
			<!--cp-SetFunctionLength-F-entries-->
			<!--cp-SetFunctionLength-F-0-->
			<li>
`DefineMethodProperty$A( %~target, `Symbol.asyncIterator$jI, %F, `false^jv )
◎
Perform DefineMethodProperty(target, %Symbol.asyncIterator%, F, false).
</li>
			<!--cp-CreateDataPropertyOrThrow-target-entries-F-->
		</ol>
	</li>
	<li>
<p>
~IF［
%定義 は`~pairを非同期に可反復な宣言$を有する
］：
◎
If definition has a pair asynchronously iterable declaration, then＼
</p>
<p>
（この段は、
`keys^jp ~methodを定義する）
◎
define the keys method:
</p>
		<ol>
			<li class="algo">
<!--cp-let-steps-args-->
				<ol>
					<!--cp-ToObject-this-->
					<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, `keys^l, `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "keys", and "method".
</li>
					<!--cp-jsValue-not-implement-definition-->
					<!--cp-let-idlObject-represent-jsValue-->
					<!--cp-let-convert-args-for-async-->
					<li>
%反復子 ~LET %定義 用の新たな`既定の非同期~反復子~obj$
— その
⇒＃
`~target$aI ~SET %~idl~obj,
`種類$aI ~SET `key^l,
`完遂したか$aI ~SET ~F
◎
Let iterator be a newly created default asynchronous iterator object for definition with idlObject as its target, "key" as its kind, and is finished set to false.
</li>
					<!--cp-run-async-iterator-init-->
					<li>
~RET %反復子
◎
Return iterator.
</li>
				</ol>
			</li>
			<!--cp-CreateBuiltinFunction-->
			<li>
`SetFunctionName$A( %F, `keys^l)
◎
Perform SetFunctionName(F, "keys").
</li>
			<!--cp-SetFunctionLength-F-0-->
			<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~target, `keys^l, %F )
◎
Perform ! CreateDataPropertyOrThrow(target, "keys", F).
</li>
		</ol>
	</li>
	<li>
<p>
（この段は、
`values^jp ~methodを
— および，場合によっては `Symbol.asyncIterator$jI も —
定義する）：
◎
Define the values, and possibly %Symbol.asyncIterator%, methods:
</p>
		<ol>
			<li class="algo">
<!--cp-let-steps-args-->
				<ol>
					<!--cp-ToObject-this-->
					<li>
~IF［
%~js値 は`~platform~objである$
］
⇒
`~security検査を遂行する$( %~js値, `values^l, `~method^C )
◎
If jsValue is a platform object, then perform a security check, passing jsValue, "values", and "method".
</li>

					<!--cp-jsValue-not-implement-definition-->
					<!--cp-let-idlObject-represent-jsValue-->
					<!--cp-let-convert-args-for-async-->
					<li>
%反復子 ~LET %定義 用の新たな`既定の非同期~反復子~obj$
— その
⇒＃
`~target$aI ~SET %~idl~obj,
`種類$aI ~SET `value^l,
`完遂したか$aI ~SET ~F
◎
Let iterator be a newly created default asynchronous iterator object for definition with idlObject as its target, "value" as its kind, and is finished set to false.
</li>
					<!--cp-run-async-iterator-init-->
					<li>
~RET %反復子
◎
Return iterator.
</li>
				</ol>
			</li>
			<!--cp-CreateBuiltinFunction-->
			<!--cp-SetFunctionName-F-values-->
			<!--cp-SetFunctionLength-F-0-->
			<!--cp-CreateDataPropertyOrThrow-target-values-F-->
			<li>
~IF［
%定義 は`値を非同期に可反復な宣言$を有する
］
⇒
~NOABRUPT `DefineMethodProperty$A( %~target, `Symbol.asyncIterator$jI, %F, `false^jv )
◎
If definition has a value asynchronously iterable declaration, then perform ! DefineMethodProperty(target, %Symbol.asyncIterator%, F, false).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`非同期~反復子~method用の引数を変換する@
~algoは、
所与の
( %定義, %~js引数~群 )
に対し：
◎
To convert arguments for an asynchronous iterator method,＼
</p>
<ol>
	<li>
~Assert
⇒＃
%定義 は`非同期に可反復な宣言$を有する`~ifc$である／
%~js引数~群 は~JS値たちが成す`~list$である
◎
given an interface definition that has an asynchronously iterable declaration and a list of JavaScript values args:
</li>
	<li>
%~idl引数~群 ~LET 新たな`~list$
◎
Let idlArgs be an empty list.
</li>
	<li>
%引数~宣言~list ~LET %定義 の`非同期に可反復な宣言$の引数~宣言たちが成す同順の~list
（引数が宣言されてないならば空）
◎
↓</li>
	<li>
<p>
~EACH( %i ~IN { 0 〜 %引数~宣言~list の`~size$ ~MINUS 1 } )
に対し，昇順に：
</p>
		<ol>
			<li>
%~idl値 ~LET `missing$C
</li>
			<li>
~IF［
%i ~LT %~js引数~群 の`~size$
］~AND［
%~js引数~群[ %i ] ~NEQ `undefined^jv
］
⇒
%~idl値 ~SET `~IDL値に変換する$( %~js引数~群[ %i ], %引数~宣言~list[ %i ] )
</li>
			<li>
~ELIF［
%引数~宣言~list[ %i ] は`既定~値$を伴う
］
⇒
%~idl値 ~SET その既定~値
</li>
			<li>
%~idl引数~群 に %~idl値 を`付加する$
</li>
		</ol>
◎
Let argCount be the number of arguments of definition’s asynchronously iterable declaration, or 0 if the asynchronously iterable declaration does not have an argument list.
◎
Let i be 0.
◎
While i &lt; argCount:
• If i ≥ args’s size, or if args[i] is undefined, then:
•• If the argument to the asynchronously iterable declaration at index i is declared with a default value, then append that default value to idlArgs.
•• Otherwise, append to idlArgs the special value "missing".
• Otherwise, append to idlArgs the result of converting args[i] to the IDL type given in the asynchronously iterable declaration’s argument list at index i.
• Set i to i + 1.
</li>
	<li>
~RET %~idl引数~群
◎
Return idlArgs.
</li>
</ol>

<p class="note">注記：
これは、
本質的には［
許容される多重定義は無く, すべての引数は随意である事例
］用の，超越的に特化された`多重定義~解決~algo$を成す。
◎
This is essentially a hyper-specialization of the overload resolution algorithm for the case where no overloads are allowed and all arguments are optional.
</p>
</div>

				<section id="js-default-asynchronous-iterator-object">
<h5 title="Default asynchronous iterator objects">3.7.10.1. 既定の非同期~反復子~obj</h5>

<p>
所与の
( `~ifc$, ~target, 反復~種類 )
用の
`既定の非同期~反復子~obj@
は、
次を満たす~objである
⇒
その `Prototype^sl `内部~slot$は、
`~ifc$用の`非同期~反復子~原型~obj$である
◎
A default asynchronous iterator object for a given interface, target and iteration kind is an object whose [[Prototype]] internal slot is the asynchronous iterator prototype object for the interface.
</p>

<p>
`既定の非同期~反復子~obj$は、
次に挙げる値を内部に有する：
◎
A default asynchronous iterator object has internal values:
</p>
<ul>
	<li>
`~target@aI
⇒
反復される値を~~給する~obj
◎
its target, which is an object whose values are to be iterated,
</li>
	<li>
`種類@aI
⇒
反復の種類
【 ~IN { `key^l, `value^l, `key+value^l } 】
◎
its kind, which is the iteration kind,
</li>
	<li>
`進行中な~promise@aI
⇒
`~promise_T$ ／ `null^jv【！`null^V？】
◎
its ongoing promise, which is a Promise or null,
</li>
	<li>
`完遂したか@aI
⇒
真偽値
◎
its is finished, which is a boolean.
</li>
</ul>

<p class="note">注記：
`既定の非同期~反復子~obj$には、
`~class文字列$は無い。
所与の`~ifc$の`既定の非同期~反復子~obj$上で `Object.prototype.toString()^c が~callされたときは、
その`~ifc$の`非同期~反復子~原型~obj$の`~class文字列$が利用される。
◎
Note: Default asynchronous iterator objects do not have class strings; when Object.prototype.toString() is called on a default asynchronous iterator object of a given interface, the class string of the asynchronous iterator prototype object of that interface is used.
</p>

				</section>
				<section id="js-asynchronous-iterator-prototype-object">
<h5 title="Asynchronous iterator prototype object">3.7.10.2. 非同期~反復子~原型 ~obj</h5>

<p>
`非同期に可反復な宣言$を伴うどの`~ifc$に対しても，
`非同期~反復子~原型~obj@
が存在し、
その~ifc用の`既定の非同期~反復子~obj$用の原型として~serveする。
`非同期~反復子~原型~obj$は：
◎
The asynchronous iterator prototype object for a given interface is an object that exists for every interface that has an asynchronously iterable declaration. It serves as the prototype for default asynchronous iterator objects for the interface.
</p>

<ul>
	<li>
その `Prototype^sl `内部~slot$は、
`AsyncIteratorPrototype$jI になるモノトスル。
◎
The [[Prototype]] internal slot of an asynchronous iterator prototype object must be %AsyncIteratorPrototype%.
</li>
	<li>
<p>
次の特性を伴う `next^jp ~data~propを有するモノトスル：
</p>
		<ul>
			<li>
値は 下に与える`組込みの関数~obj$
</li>
			<!--cp-has-attr-TTT-->
		</ul>
◎
An asynchronous iterator prototype object must have a next data property with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a built-in function object that behaves as follows:
</li>
</ul>

<div class="algo">
<p>
この組込みの関数~objは、
次に従って挙動する：
◎
↑</p>
<ol>
	<li id="cp-let-ifc-async-proto">
%~ifc ~LET 当の`非同期~反復子~原型~obj$が存在する`~ifc$
◎
Let interface be the interface for which the asynchronous iterator prototype object exists.
</li>
	<li>
%~thisを検証する~promise能力 ~LET
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let thisValidationPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
	<li id="cp-let-object-ToObject-this-value">
%object ~LET `Completion$A( `ToObject$A( `this^jv 値 ) )
◎
Let thisValue be the this value.
◎
Let object be Completion(ToObject(thisValue)).
</li>
	<li>
`IfAbruptRejectPromise$A( %object, %~thisを検証する~promise能力 )
◎
IfAbruptRejectPromise(object, thisValidationPromiseCapability).
</li>
	<li>
<p>
~IF［
%object は`~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `next^l, `~method^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "next", and
• the type "method".
</p>

<p>
この段にて例外 %e が投出されたときは：
◎
If this threw an exception e, then:
</p>
		<ol>
			<li>
~NOABRUPT `Call$A( %~thisを検証する~promise能力.`Reject^sl, `undefined^jv, « %e » )
◎
Perform ! Call(thisValidationPromiseCapability.[[Reject]], undefined, « e »).
</li>
			<li>
~RET %~thisを検証する~promise能力 .`Promise^sl
◎
Return thisValidationPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>

	<li>
<p id="cp-not-default-async-iterator">
~IF［
%object は %~ifc 用の`既定の非同期~反復子~obj$でない
］：
◎
If object is not a default asynchronous iterator object for interface, then:
</p>
		<ol>
			<li id="cp-let-new-TypeError">
%~error ~LET 新たな `TypeError$jt
◎
Let error be a new TypeError.
</li>
			<li>
~NOABRUPT `Call$A( %~thisを検証する~promise能力.`Reject^sl, `undefined^jv, « %~error » )
◎
Perform ! Call(thisValidationPromiseCapability.[[Reject]], undefined, « error »).
</li>
			<li>
~RET %~thisを検証する~promise能力.`Promise^sl
◎
Return thisValidationPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li class="algo">
<p>
%次回の手続き ~LET 次を走らす手続き：
◎
Let nextSteps be the following steps:
</p>
		<ol>
			<li>
%次回の~promise能力 ~LET
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let nextPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
			<li>
<p id="cp-obj-finished-true">
~IF［
%object の`完遂したか$aI ~EQ ~T
］：
◎
If object’s is finished is true, then:
</p>
				<ol>
					<li>
%結果 ~LET
`CreateIteratorResultObject$A( `undefined^jv, `true^jv )
◎
Let result be CreateIteratorResultObject(undefined, true).
</li>
					<li>
~NOABRUPT `Call$A( %次回の~promise能力.`Resolve^sl, `undefined^jv, « %結果 » )
◎
Perform ! Call(nextPromiseCapability.[[Resolve]], undefined, « result »).
</li>
					<li>
~RET %次回の~promise能力.`Promise^sl
◎
Return nextPromiseCapability.[[Promise]].
</li>
				</ol>
			</li>
			<li>
%種類 ~LET %object の`種類$aI
◎
Let kind be object’s kind.
</li>
			<li>
%次回の~promise ~LET %~ifc 用の`次回の反復~結果を取得する手続き$( %object の`~target$aI, %object )
◎
Let nextPromise be the result of getting the next iteration result with object’s target and object.
</li>
			<li class="algo">
<p>
%充足-手続き ~LET 所与の
( %next )
に対し，次を走らす手続き：
◎
Let fulfillSteps be the following steps, given next:
</p>
				<ol>
					<li id="cp-set-ongoing-null">
%object の`進行中な~promise$aI ~SET `null^jv
◎
Set object’s ongoing promise to null.
</li>
					<li>
<p>
~IF［
%next ~EQ `反復~終了$C
］：
◎
If next is end of iteration, then:
</p>
						<ol>
							<li id="cp-set-finished-true">
%object の`完遂したか$aI ~SET ~T
◎
Set object’s is finished to true.
</li>
							<li>
~RET
`CreateIteratorResultObject$A( `undefined^jv, `true^jv )
◎
Return CreateIteratorResultObject(undefined, true).
</li>
						</ol>
					</li>
					<li>
<p>
~ELIF［
%~ifc は`~pairを非同期に可反復な宣言$を有する
］：
◎
Otherwise, if interface has a pair asynchronously iterable declaration:
</p>
						<ol>
							<li>
~Assert：
%next は`値~pair$である
◎
Assert: next is a value pair.
</li>
							<li>
~RET `反復子~結果$( %next, %種類 )
◎
Return the iterator result for next and kind.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
◎
Otherwise:
</p>
						<ol>
							<li>
~Assert：
%~ifc は`値を非同期に可反復な宣言$を有する。
◎
Assert: interface has a value asynchronously iterable declaration.
</li>
							<li>
~Assert：
%next は宣言~内に現れる型の値である。
◎
Assert: next is a value of the type that appears in the declaration.
</li>
							<li>
%値 ~LET `~JS値に変換する$( %next )
◎
Let value be next, converted to a JavaScript value.
</li>
							<li>
~RET
`CreateIteratorResultObject$A( %値, `false^jv )
◎
Return CreateIteratorResultObject(value, false).
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li id="cp-let-onFulfilled-CreateBuiltinFunction">
%充足-時の関数 ~LET
`CreateBuiltinFunction$A( %充足-手続き, « » )
◎
Let onFulfilled be CreateBuiltinFunction(fulfillSteps, « »).
</li>
			<li class="algo">
<p>
%却下-手続き ~LET 所与の ( %事由 ) に対し，次を走らす手続き：
◎
Let rejectSteps be the following steps, given reason:
</p>
				<ol>
					<!--cp-set-ongoing-null-->
					<!--cp-set-finished-true-->
					<li>
`~THROW$ %事由
◎
Throw reason.
</li>
				</ol>
			</li>
			<li>
%却下-時の関数 ~LET
`CreateBuiltinFunction$A( %却下-手続き, « » )
◎
Let onRejected be CreateBuiltinFunction(rejectSteps, « »).
</li>
			<li>
`PerformPromiseThen$A( %次回の~promise, %充足-時の関数, %却下-時の関数, %次回の~promise能力 )
◎
Perform PerformPromiseThen(nextPromise, onFulfilled, onRejected, nextPromiseCapability).
</li>
			<li>
~RET %次回の~promise能力.`Promise^sl
◎
Return nextPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li id="cp-let-ongoingPromise">
%進行中な~promise ~LET %object の`進行中な~promise$aI
◎
Let ongoingPromise be object’s ongoing promise.
</li>
	<li>
<p id="cp-if-ongoingPromise-not-null">
~IF［
%進行中な~promise ~NEQ `null^jv
］：
◎
If ongoingPromise is not null, then:
</p>
		<ol>
			<li id="cp-let-afterOngoingPromiseCapability">
%後の進行中な~promise能力 ~LET
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let afterOngoingPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
			<li>
%決着-時の関数 ~LET
`CreateBuiltinFunction$A( %次回の手続き, « » )
◎
Let onSettled be CreateBuiltinFunction(nextSteps, « »).
</li>
			<li id="cp-PerformPromiseThen-ongoingPromise">
`PerformPromiseThen$A( %進行中な~promise, %決着-時の関数, %決着-時の関数, %後の進行中な~promise能力 )
◎
Perform PerformPromiseThen(ongoingPromise, onSettled, onSettled, afterOngoingPromiseCapability).
</li>
			<li>
%object の`進行中な~promise$aI ~SET %後の進行中な~promise能力.`Promise^sl
◎
Set object’s ongoing promise to afterOngoingPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%object の`進行中な~promise$aI ~SET %次回の手続き()
◎
Otherwise:
• Set object’s ongoing promise to the result of running nextSteps.
</li>
	<li>
~RET %object の`進行中な~promise$aI
◎
Return object’s ongoing promise.
</li>
</ol>
</div>

<div class="p">
<p>
`非同期に可反復な宣言$を伴う`~ifc$用に`非同期~反復子から返る手続き$が定義されている場合、
その`非同期~反復子~原型~obj$は，次の特性を伴う `return^jp ~data~propを有するモノトスル：
</p>

<ul>
	<li>
値は 下に与える`組込みの関数~obj$
</li>
	<!--cp-has-attr-TTT-->
</ul>

◎
If an asynchronous iterator return algorithm is defined for the interface, then the asynchronous iterator prototype object must have a return data property with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is a built-in function object, taking one argument value, that behaves as follows:
</div>

<div class="algo">
<p>
この組込みの関数~objは、
1 個の引数
( %値 )
をとり，次に従って挙動する：
◎
↑</p>
<ol>
	<!--cp-let-ifc-async-proto-->
	<li id="cp-let-returnPromiseCapability-new">
%~return~promise能力 ~LET
~NOABRUPT `NewPromiseCapability$A( `Promise$jI )
◎
Let returnPromiseCapability be ! NewPromiseCapability(%Promise%).
</li>
	<!--cp-let-object-ToObject-this-value-->
	<li>
`IfAbruptRejectPromise$A( %object, %~return~promise能力 )
◎
IfAbruptRejectPromise(object, returnPromiseCapability).
</li>
	<li>
<p>
~IF［
%object は`~platform~objである$
］
⇒
`~security検査を遂行する$( %object, `return^l, `~method^C )
◎
If object is a platform object, then perform a security check, passing:
• the platform object object,
• the identifier "return", and
• the type "method".
</p>

<p>
この段にて例外 %e が投出されたときは：
◎
If this threw an exception e, then:
</p>
		<ol>
			<li>
~NOABRUPT `Call$A( %~return~promise能力.`Reject^sl, `undefined^jv, « %e » )
◎
Perform ! Call(returnPromiseCapability.[[Reject]], undefined, « e »).
</li>
			<li id="cp-ret-returnPromiseCapability">
~RET %~return~promise能力.`Promise^sl
◎
Return returnPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
<!--cp-not-default-async-iterator-->
		<ol>
			<!--cp-let-new-TypeError-->
			<li>
~NOABRUPT `Call$A( %~return~promise能力.`Reject^sl, `undefined^jv, « %~error » )
◎
Perform ! Call(returnPromiseCapability.[[Reject]], undefined, « error »).
</li>
			<!--cp-ret-returnPromiseCapability-->
		</ol>
	</li>
	<li class="algo">
<p>
%~return手続き ~LET 次を走らす手続き：
◎
Let returnSteps be the following steps:
</p>
		<ol>
			<!--cp-let-returnPromiseCapability-new-->
			<li>
<!--cp-obj-finished-true-->
				<ol>
					<li>
%結果 ~LET
`CreateIteratorResultObject$A( %値, `true^jv )
◎
Let result be CreateIteratorResultObject(value, true).
</li>
					<li>
~NOABRUPT `Call$A( %~return~promise能力.`Resolve^sl, `undefined^jv, « %結果 » )
◎
Perform ! Call(returnPromiseCapability.[[Resolve]], undefined, « result »).
</li>
					<!--cp-ret-returnPromiseCapability-->
				</ol>
			</li>
			<!--cp-set-finished-true-->
			<li>
~RET 
%~ifc 用の`非同期~反復子から返る手続き$( %object の`~target$aI, %object, %値 )
◎
Return the result of running the asynchronous iterator return algorithm for interface, given object’s target, object, and value.
</li>
		</ol>
	</li>
	<!--cp-let-ongoingPromise-->
	<li>
<!--cp-if-ongoingPromise-not-null-->
		<ol>
			<!--cp-let-afterOngoingPromiseCapability-->
			<li>
%決着-時の関数 ~LET
`CreateBuiltinFunction$A( %~return手続き, « » )
◎
Let onSettled be CreateBuiltinFunction(returnSteps, « »).
</li>
			<!--cp-PerformPromiseThen-ongoingPromise-->
			<li>
%object の`進行中な~promise$aI ~SET %後の進行中な~promise能力.`Promise^sl
◎
Set object’s ongoing promise to afterOngoingPromiseCapability.[[Promise]].

Set returnStepsPromise to afterOngoingPromiseCapability.[[Promise]].
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%object の`進行中な~promise$aI ~SET %~return手続き()
◎
Otherwise:
• Set object’s ongoing promise to the result of running returnSteps.
</li>
	<li>
%充足-手続き ~LET 次を走らす手続き
⇒
~RET
`CreateIteratorResultObject$A( %値, `true^jv )
◎
Let fulfillSteps be the following steps:
• Return CreateIteratorResultObject(value, true).
</li>
	<!--cp-let-onFulfilled-CreateBuiltinFunction-->
	<li>
`PerformPromiseThen$A( %object の`進行中な~promise$aI, %充足-時の関数, `undefined^jv, %~return~promise能力 )
◎
Perform PerformPromiseThen(object’s ongoing promise, onFulfilled, undefined, returnPromiseCapability).
</li>
	<!--cp-ret-returnPromiseCapability-->
</ol>
</div>

<p>
所与の`~ifc$用の`非同期~反復子~原型~obj$の`~class文字列$は、
次の結果になるとする
⇒
次を順に`連結する$
⇒＃
当の~ifcの`識別子$
文字列 ` AsyncIterator^l
◎
The class string of an asynchronous iterator prototype object for a given interface is the result of concatenating the identifier of the interface and the string " AsyncIterator".
</p>

				</section>
			</section>
			<section id="js-maplike">
<h4 title="Maplike declarations">3.7.11. ~maplike宣言</h4>

<p>
`~maplike宣言$を伴って宣言された`~ifc$
— 以下、
この節を通して %A と記される —
の`~ifc原型~obj$上には、
いくつかの追加的な~propが存在する。
これらの~propは、
以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a maplike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

				<section id="js-map-size">
<h5>3.7.11.1. `size^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a size property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`size^jp
◎
↑</li>
	<li>
次の属性を伴う
⇒
{ [[Get]]: %G, [[Enumerable]]: `true^jv, [[Configurable]]: `true^jv }
— ここで %G は、
下に定義する`~map~size取得子$である。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: true, [[Configurable]]: true }, where G is the interface’s map size getter, defined below.
</li>
</ul>

<div class="algo">
<p>
`~map~size取得子@
は、
`組込みの関数~obj$であり，
呼出されたときは次に従って挙動する：
◎
The map size getter is a built-in function object whose behavior when invoked is as follows:
</p>
<ol>
	<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `size^l, `取得子^C )
◎
Let O be the this value, implementation-checked against A with identifier "size" and type "getter".
</li>
	<li id="cp-let-map-entries">
%~map ~LET %O への参照を表現する~IDL値を成す`~map~entry群$
◎
Let map be the map entries of the IDL value that represents a reference to O.
</li>
	<li>
~RET `~JS値に変換する$( %~map の`~size$map )
◎
Return map’s size, converted to a JavaScript value.
</li>
</ol>
</div>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `get size^l とする。
◎
The value of the function object’s name property is the String value "get size".
</p>

				</section>
				<section id="js-map-iterator">
<h5>3.7.11.2. `Symbol.iterator^jI</h5>

<div class="p">
<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
</p>
<ul>
	<li>
名前：
`Symbol.iterator$jI ~symbol
</li>
	<li>
次の属性を伴う
⇒
`TFT^desc
</li>
	<li>
値：
`entries^jp ~propの値で与えられる`関数~obj$
</li>
</ul>
◎
There must exist a data property whose name is the %Symbol.iterator% symbol on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the entries property.
</div>

<div class="algo">
<p>
`~map反復子を作成する@
~algoは、
所与の
( `有順序~map$ %~map, %種類 ~IN { `key+value^l, `key^l, `value^l } )
に対し：
◎
To create a map iterator from a map map and a kind which is either "key+value", "key", or "value":
</p>
<ol>
	<li>
<p>
%~closure ~LET 新たな`抽象-~closure$
— それは
⇒＃
~parameterを伴わない,
( %~map, %種類 ) を~captureする,
~callされたときは，次の手続きを遂行する：
◎
Let closure be a new Abstract Closure with no parameters that captures map and kind and performs the following steps when called:
</p>
		<ol>
			<li>
<p>
%~map を成す
~EACH( %~key → %値 )
に対し：
◎
For each key → value of map:
</p>
				<ol>
					<li>
%~key ~SET `~JS値に変換する$( %~key )
◎
↓</li>
					<li>
%値 ~SET `~JS値に変換する$( %値 )
◎
Set key and value to each converted to a JavaScript value.
</li>
					<li>
%結果 ~LET %種類 に応じて
⇒＃
`key^l ならば %~key ／
`value^l ならば %値 ／
`key+value^l ならば `CreateArrayFromList$A( « %~key, %値 » )
◎
If kind is "key", let result be key.
◎
Else if kind is "value", let result be value.
◎
Else, let result be CreateArrayFromList(« key, value »).
</li>
					<li>
~ABRUPT `GeneratorYield$A( `CreateIteratorResultObject$A( %結果, `false^jv ) )
◎
Perform ? GeneratorYield(CreateIteratorResultObject(result, false)).
</li>
				</ol>

<p class="note">注記：
%~map の`~size$map, および %~map 内の~entryたちの順序は、
この抽象-演算の実行が `Yield$A により静止された場合，その間に変更されるかもしれない。
◎
Note: The size of map, and the order of its entries, might have changed while execution of this abstract operation was paused by Yield.
</p>
			</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
	<li>
~RET `CreateIteratorFromClosure$A( %~closure, `%MapIteratorPrototype%^l, `MapIteratorPrototype$jI )
◎
Return CreateIteratorFromClosure(closure, "%MapIteratorPrototype%", %MapIteratorPrototype%).
</li>
</ol>
</div>

				</section>
				<section id="js-map-entries">
<h5>3.7.11.3. `entries^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist an entries data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`entries^jp
◎
↑</li>
	<li id="cp-has-TTT">
次の属性を伴う
⇒
`TTT^desc
◎
The property has attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true }.
</li>
	<li class="algo">
<p id="cp-value-is-built-in-func">
値：
呼出されたとき，次に従って挙動する`組込みの関数~obj$：
◎
The value of the property is a built-in function object that behaves as follows when invoked:
</p>
<!--
The value of the property is a built-in function object whose behavior when invoked is as follows:
-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `entries^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "entries" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li>
~RET `~map反復子を作成する$( %~map, `key+value^l )
◎
Return the result of creating a map iterator from map with kind "key+value".
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `entries^l とする。
◎
The value of the function object’s name property is the String value "entries".
</p>

				</section>
				<section id="js-map-keys">
<h5>3.7.11.4. `keys^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a keys data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`keys^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `keys^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "keys" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li>
~RET `~map反復子を作成する$( %~map, 種類 `key^l )
◎
Return the result of creating a map iterator from map with kind "key".
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `keys^l とする。
◎
The value of the function object’s name property is the String value "keys".
</p>

				</section>
				<section id="js-map-values">
<h5>3.7.11.5. `values^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a values data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`values^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `values^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "values" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li>
~RET `~map反復子を作成する$( %~map, `value^l )
◎
Return the result of creating a map iterator from map with kind "value".
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `values^l とする。
◎
The value of the function object’s name property is the String value "values".
</p>

				</section>
				<section id="js-map-forEach">
<h5>3.7.11.6. `forEach^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a forEach data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`forEach^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `forEach^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "forEach" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li id="cp-let-callbackFn-1st-arg">
%~callback関数 ~LET ［
この関数に 1 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let callbackFn be the first argument passed to the function, or undefined if not supplied.
</li>
			<li id="cp-throw-if-not-callable">
~IF［
`IsCallable$A( %~callback関数 ) ~EQ `false^jv
］
⇒
`~THROW$ `TypeError$jt
◎
If IsCallable(callbackFn) is false, throw a TypeError.
</li>
			<li id="cp-let-thisArg-2nd-arg">
%~this引数 ~LET ［
この関数に 2 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let thisArg be the second argument passed to the function, or undefined if not supplied.
</li>
			<li>
<p>
%~map を成す
~EACH( %~key → %値 )
に対し：
◎
For each key → value of map:
</p>
				<ol>
					<li>
%~js~key ~LET `~JS値に変換する$( %~key )
◎
↓</li>
					<li>
%~js値 ~LET `~JS値に変換する$( %値 )
◎
Let jsKey and jsValue be key and value converted to a JavaScript value.
</li>
					<li>
~ABRUPT `Call$A( %~callback関数, %~this引数, « %~js値, %~js~key, %O » )
◎
Perform ? Call(callbackFn, thisArg, « jsValue, jsKey, O »).
</li>
				</ol>
			</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
</ul>

<p id="cp-length-is-1">
この`関数~obj$の `length^jp ~propの値は、
`Number^jt 値 `1^jv とする。
◎
The value of the function object’s length property is the Number value 1.
</p>

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `forEach^l とする。
◎
The value of the function object’s name property is the String value "forEach".
</p>

				</section>
				<section id="js-map-get">
<h5>3.7.11.7. `get^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a get data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`get^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `get^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "get" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li id="cp-let-keyType">
%~key型 ~LET 当の`~maplike宣言$にて指定された~key型
◎
Let keyType be the key type specified in the maplike declaration.
</li>
			<li id="cp-let-keyArg-1st-arg">
%~key引数 ~LET ［
この関数に 1 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let keyArg be the first argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-let-key-converted">
%~key ~LET `~IDL値に変換する$( %~key引数, %~key型 )
◎
Let key be keyArg converted to an IDL value of type keyType.
</li>
			<li id="cp-map-zero-key">
~IF［
%~key ~EQ `-0^jv
］
⇒
%~key ~SET `+0^jv
◎
If key is -0, set key to +0.
</li>
			<li>
~IF［
%~map[ %~key ] ~NEQ ε ならば
］
⇒
~RET `~JS値に変換する$( %~map[ %~key ] )
◎
If map[key] exists, then return map[key], converted to a JavaScript value.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `get^l とする。
◎
The value of the function object’s name property is the String value "get".
</p>

				</section>
				<section id="js-map-has">
<h5>3.7.11.8. `has^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a has data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`has^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `has^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "has" and type "method".
</li>
			<!--cp-let-map-entries-->
			<!--cp-let-keyType-->
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-let-key-converted-->
			<!--cp-map-zero-key-->
			<li>
~RET ［
%~map[ %~key ] ~NEQ ε ならば `true^jv ／
~ELSE_ `false^jv
］
◎
If map[key] exists, then return true; otherwise return false.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `has^l とする。
◎
The value of the function object’s name property is the String value "has".
</p>

				</section>
				<section id="js-map-set">
<h5>3.7.11.9. `set^jp</h5>

<p>
［
%A には識別子 `set^l を伴う`~ifc~mb$は宣言されてない
］かつ［
%A は非読専な`~maplike宣言$を伴って宣言された
］場合、
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "set", and A was declared with a read–write maplike declaration, then there must exist a set data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`set^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `set^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "set" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li>
( %~key型, %値~型 ) ~LET 当の`~maplike宣言$にて指定された ( ~key型, 値~型 )
◎
Let keyType be the key type specified in the maplike declaration, and valueType be the value type.
</li>
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-let-key-converted-->
			<!--cp-map-zero-key-->
			<li>
%値~引数 ~LET ［
この関数に 2 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let valueArg be the second argument passed to this function, or undefined if not supplied.
</li>
			<li id="cp-let-value-converted">
%値 ~LET `~IDL値に変換する$( %値~引数, %値~型 )
◎
Let value be valueArg converted to an IDL value of type valueType.
</li>
			<li>
%~map[ %~key ] ~SET %値
◎
Set map[key] to value.
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
</ul>

<p>
この`関数~obj$の `length^jp ~propの値は、
`Number^jt 値 `2^jv とする。
◎
The value of the function object’s length property is the Number value 2.
</p>

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `set^l とする。
◎
The value of the function object’s name property is the String value "set".
</p>

<p>
%A が `set^M ~methodを宣言する場合
⇒＃
類似に，~keyに対する `-0^jv を `+0^jv へ対応付けるベキである。
`this$V を返すモノトスル。
◎
If the interface does declare a set method, it should similarly map a -0 key to +0, and must return this.
</p>

				</section>
				<section id="js-map-delete">
<h5>3.7.11.10. `delete^jp</h5>

<p>
［
%A には識別子 `delete^l を伴う`~mb$は宣言されてない
］かつ［
%A は非読専な`~maplike宣言$を伴って宣言された
］場合、
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "delete", and A was declared with a read–write maplike declaration, then there must exist a delete data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`delete^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `delete^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "delete" and type "method".
</li>
			<!--cp-let-map-entries-->
			<!--cp-let-keyType-->
			<!--cp-let-keyArg-1st-arg-->
			<!--cp-let-key-converted-->
			<!--cp-map-zero-key-->
			<li>
%返り値 ~LET ［
次が満たされるならば `true^jv ／
~ELSE_ `false^jv
］
⇒
%~map[ %~key ] ~NEQ ε
◎
Let retVal be true if map[key] exists, or else false.
</li>
			<li>
%~map[ %~key ] ~SET ε
◎
Remove map[key].
</li>
			<li>
~RET %返り値
◎
Return retVal.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `delete^l とする。
◎
The value of the function object’s name property is the String value "delete".
</p>

<p>
%A が `delete^M ~methodを宣言する場合
⇒＃
類似に，~keyに対する `-0^jv を `+0^jv へ対応付けるベキである。
~keyが在るか否かを指示する `boolean$T を返すモノトスル。
◎
If the interface does declare a delete method, it should similarly map a -0 key to +0, and must return a boolean indicating whether the key was present or not.
</p>

				</section>
				<section id="js-map-clear">
<h5>3.7.11.11. `clear^jp</h5>

<p>
［
%A には識別子 `clear^l を伴う`~mb$は宣言されてない
］かつ［
%A は非読専な`~maplike宣言$を伴って宣言された
］場合、
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "clear", and A was declared with a read–write maplike declaration, then there must exist a clear data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`clear^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `clear^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "clear" and type "method".
</li>
			<!--cp-let-map-entries-->
			<li>
<p>
%~map を`~clearする$map
◎
Clear map.
</p>

<p class="note">注記：
当の`有順序~map$【の~instance】は保全される
— それを反復しているが現在~休止されている既存の反復子が在り得るので。
◎
Note: The map is preserved because there may be existing iterators, currently suspended, iterating over it.
</p>
			</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `clear^l とする。
◎
The value of the function object’s name property is the String value "clear".
</p>

<p>
%A が `clear^M ~methodを宣言する場合
⇒＃
`~map~entry群$~objを（新たなものを生成することなく）保全するモノトスル。
`undefined$T を返すモノトスル。
◎
If the interface does declare a clear method, it must preserve the map entries object (rather than generating a new one) and must return undefined.
</p>

				</section>
			</section>
			<section id="js-setlike">
<h4 title="Setlike declarations">3.7.12. ~setlike宣言</h4>

<p>
`~setlike宣言$を伴って宣言された`~ifc$
— 以下、
この節を通して %A と記される —
の`~ifc原型~obj$上には、
いくつかの追加的な~propが存在する。
これらの~propは、
以下の各 下位~節にて述べられる。
◎
If an interface A is declared with a setlike declaration, then there exists a number of additional properties on A’s interface prototype object. These additional properties are described in the sub-sections below.
</p>

				<section id="js-set-size">
<h5>3.7.12.1. `size^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
A size property must exist on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`size^jp
◎
↑</li>
	<li>
属性
{ [[Get]]: %G, [[Enumerable]]: `true^jv, [[Configurable]]: `true^jv }
を有する
— ここで %G は、
下に定義する`集合~size取得子$とする。
◎
The property has attributes { [[Get]]: G, [[Enumerable]]: true, [[Configurable]]: true }, where G is the interface’s set size getter, defined below.
</li>
</ul>

<div class="algo">
<p>
`集合~size取得子@
は、
`組込みの関数~obj$であり，
呼出されたときは次に従って挙動する：
◎
The set size getter is a built-in function object whose behavior when invoked is as follows:
</p>
<ol>
	<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `size^l, `取得子^C )
◎
Let O be the this value, implementation-checked against A with identifier "size" and type "getter".
</li>
	<li id="cp-let-set-entries">
%集合 ~LET %O への参照を表現する~IDL値を成す`集合~entry群$
◎
Let set be the set entries of the IDL value that represents a reference to O.
</li>
	<li>
~RET `~JS値に変換する$( %集合 の`~size$ )
◎
Return set’s size, converted to a JavaScript value.
</li>
</ol>
</div>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `get size^l とする。
◎
The value of the function object’s name property is the String value "get size".
</p>

				</section>
				<section id="js-set-iterator">
<h5>3.7.12.2. `Symbol.iterator^jI</h5>

<div class="p">
<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
</p>
<ul>
	<li>
名前：
`Symbol.iterator$jI ~symbol
</li>
	<li>
次の属性を伴う
⇒
`TFT^desc
</li>
	<li>
値：
`values^jp ~propの値で与えられる`関数~obj$
</li>
</ul>
◎
There must exist a data property whose name is the %Symbol.iterator% symbol on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true } and whose value is the function object that is the value of the values property.
</div>

<div class="algo">
<p>
`集合~反復子を作成する@
~algoは、
所与の
( `集合$ %集合, %種類 ~IN { `key+value^l, `value^l } )
に対し：
◎
To create a set iterator from a set set and a kind which is either "key+value" or "value":
</p>
<ol>
	<li>
<p>
%~closure ~LET 新たな`抽象-~closure$
— それは
⇒＃
~parameterを伴わない,
( %集合, %種類 ) を~captureする,
~callされたときは，次の手続きを遂行する：
◎
Let closure be a new Abstract Closure with no parameters that captures set and kind and performs the following steps when called:
</p>
		<ol>
			<li>
<p>
%集合 を成す
~EACH( %~entry )
に対し：
◎
For each entry of set:
</p>

				<ol>
					<li>
%~entry ~SET `~JS値に変換する$( %~entry )
◎
Set entry to be entry converted to a JavaScript value.
</li>
					<li>
%結果 ~LET %種類 に応じて
⇒＃
`value^l ならば %~entry ／
`key+value^l ならば `CreateArrayFromList$A( « %~entry, %~entry » )
◎
If kind is "value", let result be entry.
◎
Else, let result be CreateArrayFromList(« entry, entry »).
</li>
					<li>
~ABRUPT `GeneratorYield$A( `CreateIteratorResultObject$A( %結果, `false^jv ) )
◎
Perform ? GeneratorYield(CreateIteratorResultObject(result, false)).
</li>
				</ol>

<p class="note">注記：
%集合 の`~size$, および
%集合 内の~entryたちの順序は、
この抽象-演算の実行が `Yield$A により静止された場合，その間に変更されるかもしれない。
◎
Note: The size of set, and the order of its entries, might have changed while execution of this abstract operation was paused by Yield.
</p>
			</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
	<li>
~RET `CreateIteratorFromClosure$A( %~closure, `%SetIteratorPrototype%^l, `SetIteratorPrototype$jI )
◎
Return CreateIteratorFromClosure(closure, "%SetIteratorPrototype%", %SetIteratorPrototype%).
</li>
</ol>
</div>

				</section>
				<section id="js-set-entries">
<h5>3.7.12.3. `entries^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist an entries data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`entries^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `entries^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "entries" and type "method".
</li>
			<!--cp-let-set-entries-->
			<li>
~RET `集合~反復子を作成する$( %集合, `key+value^l )
◎
Return the result of creating a set iterator from set with kind "key+value".
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `entries^l とする。
◎
The value of the function object’s name property is the String value "entries".
</p>

				</section>
				<section id="js-set-keys">
<h5>3.7.12.4. `keys^jp</h5>

<div>
<p>
%A 用の`~ifc原型~obj$上には、
次の特性を伴う~data~propが存在するモノトスル：
</p>
<ul>
	<li>
名前：
`keys^jp
◎
↑</li>
	<li>
次の属性を伴う
⇒
`TTT^desc
</li>
	<li>
値：
`values^jp ~propの値で与えられる`関数~obj$
</li>
</ul>
◎
A keys data property must exist on A’s interface prototype object with attributes { [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true } and whose value is the function object that is the value of the values property.
</div>

				</section>
				<section id="js-set-values">
<h5>3.7.12.5. `values^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a values data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`values^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `values^l, `~method^C )。
◎
Let O be the this value, implementation-checked against A with identifier "values" and type "method".
</li>
			<!--cp-let-set-entries-->
			<li>
~RET `集合~反復子を作成する$( %集合, `value^l )
◎
Return the result of creating a set iterator from set with kind "value".
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `values^l とする。
◎
The value of the function object’s name property is the String value "values".
</p>

				</section>
				<section id="js-set-forEach">
<h5>3.7.12.6. `forEach^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a forEach data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`forEach^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `forEach^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "forEach" and type "method".
</li>
			<!--cp-let-set-entries-->
			<!--cp-let-callbackFn-1st-arg-->
			<!--cp-throw-if-not-callable-->
			<!--cp-let-thisArg-2nd-arg-->
			<li>
<p>
%集合 を成す
~EACH( %値 )
に対し：
◎
For each value of set:
</p>
				<ol>
					<li>
%~js値 ~LET `~JS値に変換する$( %値 )
◎
Let jsValue be value converted to a JavaScript value.
</li>
					<li>
~ABRUPT `Call$A( %~callback関数, %~this引数, « %~js値, %~js値, %O » )
◎
Perform ? Call(callbackFn, thisArg, « jsValue, jsValue, O»).
</li>
				</ol>
			</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `forEach^l とする。
◎
The value of the function object’s name property is the String value "forEach".
</p>

				</section>
				<section id="js-set-has">
<h5>3.7.12.7. `has^jp</h5>

<p>
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
There must exist a has data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`has^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `has^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "has" and type "method".
</li>
			<!--cp-let-set-entries-->
			<li id="cp-let-valueType">
%値~型 ~LET 当の`~setlike宣言$にて指定された値~型
◎
Let valueType be the value type specified in the setlike declaration.
</li>
			<li id="cp-let-valueArg-1st-arg">
%値~引数 ~LET［
この関数に 1 個目の引数が給されているならば その値 ／
~ELSE_ `undefined^jv
］
◎
Let valueArg be the first argument passed to this function, or undefined if not supplied.
</li>
			<!--cp-let-value-converted-->
			<li id="cp-map-zero-value">
~IF［
%値 ~EQ `-0^jv
］
⇒
%値 ~SET `+0^jv
◎
If value is -0, set value to +0.
</li>
			<li>
~RET ［
%値 ~IN %集合 ならば `true^jv ／
~ELSE_ `false^jv
］
◎
If set contains value, then return true, otherwise return false.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `has^l とする。
◎
The value of the function object’s name property is the String value "has".
</p>

				</section>
				<section id="js-set-add">
<h5>3.7.12.8. `add^jp</h5>

<p>
［
%A には識別子 `add^l を伴う`~mb$は宣言されてない
］かつ［
%A は非読専な`~setlike宣言$を伴って宣言された
］場合、
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "add", and A was declared with a read–write setlike declaration, then there must exist an add data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`add^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `add^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "add" and type "method".
</li>
			<!--cp-let-set-entries-->
			<!--cp-let-valueType-->
			<!--cp-let-valueArg-1st-arg-->
			<!--cp-let-value-converted-->
			<!--cp-map-zero-value-->
			<li>
%集合 に %値 を`付加する$set
◎
Append value to set.
</li>
			<li>
~RET %O
◎
Return O.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `add^l とする。
◎
The value of the function object’s name property is the String value "add".
</p>

<p>
%A が `add^M ~methodを宣言する場合
⇒＃
類似に，~keyに対する `-0^jv を `+0^jv へ対応付けるベキである。
設定された値を返すモノトスル。
◎
If the interface does declare an add method, it should similarly map a -0 value to +0, and must return the value that was set.
</p>

				</section>
				<section id="js-set-delete">
<h5>3.7.12.9. `delete^jp</h5>

<p>
［
%A には識別子 `delete^l を伴う`~mb$は宣言されてない
］かつ［
%A は非読専な`~setlike宣言$を伴って宣言された
］場合、
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "delete", and A was declared with a read–write setlike declaration, then there must exist a delete data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`delete^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `delete^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "delete" and type "method".
</li>
			<li>
%集合 ~LET %O の`集合~entry群$
◎
Let set be O’s set entries.
</li>
			<!--cp-let-valueType-->
			<!--cp-let-valueArg-1st-arg-->
			<!--cp-let-value-converted-->
			<!--cp-map-zero-value-->
			<li>
%返り値 ~LET ［
%値 ~IN %集合 ならば `true^jv ／
~ELSE_ `false^jv
］
◎
Let retVal be true if set contains value, or else false.
</li>
			<li>
%集合 から %値 を`除去する$
◎
Remove value from set.
</li>
			<li>
~RET %返り値
◎
Return retVal.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-1-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `delete^l とする。
◎
The value of the function object’s name property is the String value "delete".
</p>

<p>
%A が `delete^M ~methodを宣言する場合
⇒＃
類似に，~keyに対する `-0^jv を `+0^jv へ対応付けるベキである。
値が在るか否かを指示する `boolean$T を返すモノトスル。
◎
If the interface does declare a delete method, it should similarly map a -0 value to +0, and must return a boolean indicating whether the value was present or not.
</p>

				</section>
				<section id="js-set-clear">
<h5>3.7.12.10. `clear^jp</h5>

<p>
［
%A には識別子 `clear^l を伴う`~mb$は宣言されてない
］かつ［
%A は非読専な`~setlike宣言$を伴って宣言された
］場合、
%A 用の`~ifc原型~obj$上には，
次の特性を伴う~data~propが存在するモノトスル：
◎
If A does not declare a member with identifier "clear", and A was declared with a read–write setlike declaration, then there must exist a clear data property on A’s interface prototype object with the following characteristics:
</p>
<ul>
	<li>
名前：
`clear^jp
◎
↑</li>
	<!--cp-has-TTT-->
	<li class="algo">
<!--cp-value-is-built-in-func-->
		<ol>
			<li>
%O ~LET `実装を検査する$( `this^jv 値, %A, `clear^l, `~method^C )
◎
Let O be the this value, implementation-checked against A with identifier "clear" and type "method".
</li>
			<!--cp-let-set-entries-->
			<li>
<p>
%集合 を`空にする$
◎
Empty set.
</p>

<p class="note">注記：
当の`集合$【の~instance】は保全される
— それを反復しているが現在~休止されている既存の反復子が在り得るので。
◎
Note: The set is preserved because there may be existing iterators, currently suspended, iterating over it.
</p>
			</li>
			<li>
~RET `undefined^jv
◎
Return undefined.
</li>
		</ol>
	</li>
</ul>

<!--cp-length-is-0-->

<p>
この`関数~obj$の `name^jp ~propの値は、
`String^jt 値 `clear^l とする。
◎
The value of the function object’s name property is the String value "clear".
</p>

<p>
%A が `clear^M ~methodを宣言する場合
⇒＃
`集合~entry群$~objを（新たなものを生成することなく）保全するモノトスル。
`undefined$T を返すモノトスル。
◎
If the interface does declare a clear method, it must preserve the set entries object (rather than generating a new one) and must return undefined.
</p>

				</section>
			</section>
		</section>
		<section id="js-platform-objects">
<h3 title="Platform objects implementing interfaces">3.8. ~ifcを実装している~platform~obj</h3>


<div class="algo">
<p>
次を満たす~JS値 %値 は
`~platform~objである@
とされる
⇒
［
%値 は `Object$jt である
］~AND［
%値 は `PrimaryInterface^sl 内部~slotを有する
］
◎
A JavaScript value value is a platform object if value is an Object and if value has a [[PrimaryInterface]] internal slot.
</p>
</div>

<div class="algo">
<p>
~JS値 %値 は、
次を満たすならば`~ifc$ %~ifc を
`実装-@
するとされる
⇒
［
%値 は `~platform~objである$
］~AND［
%~ifc ~IN ［
%値.`PrimaryInterface^sl の`自身も含む継承した~ifc群$
］］
◎
A JavaScript value value implements an interface interface if value is a platform object and the inclusive inherited interfaces of value.[[PrimaryInterface]] contains interface.
</p>

<p>
各種 仕様は、
“%object は %~ifc を実装する”
概念を様々な仕方で参照することもある
— 例： “%object は %~ifc ~objである” などの~~句で。
◎
Specifications may reference the concept "object implements interface" in various ways, including "object is an interface object".
</p>
</div>

<p>
各`~platform~obj$には、
`~realm$が結付けられる
— `初期~obj$とちょうど同じく。
【和訳では、このことを “~objは~realmに属する” とも記す。】
この~realmは、
当の`~platform~obj$の `Realm^sl ~slot内に格納される。
各~platform~objに，どの~realm（または、それを代理する，どの大域~obj）が結付けられるかを言明する責務は、
~Web~IDLを利用している仕様にある。
特に，下に与える各種~algoは、
新たな`~platform~obj$に，引数に与えた~realmを結付ける。
◎
Every platform object is associated with a realm, just as the initial objects are. This realm is stored in the platform object’s [[Realm]] slot. It is the responsibility of specifications using Web IDL to state which realm (or, by proxy, which global object) each platform object is associated with. In particular, the algorithms below associate the new platform object with the realm given as an argument.
</p>

<div class="algo">
<p>
`~ifcを実装する新たな~objを作成する@
~algoは、
所与の
( %~ifc, `~realm$ %~realm, ~JS値 %新-~target ~DF `undefined^jv )
に対し：
◎
To create a new object implementing the interface interface, with a realm realm, perform the following steps:
• Return the result of internally creating a new object implementing interface, with realm and undefined.
◎
To internally create a new object implementing the interface interface, with a realm realm and a JavaScript value newTarget, perform the following steps:
</p>

<p class="trans-note">【
他の仕様は、
この手続きを単に “新たな〜” のような句で参照することが多い
（それらの和訳においては、
通例的に “新たな~obj( … )” ）。
】【
この手続きは、
原文では，
`~ifcを実装する新たな~objを内部的に作成する@
手続きと分けて定義されているが、
この訳では，
%新-~target に省略時の値を与えることにより一つに統合する
（他の仕様から利用されるときは、
%新-~target は，ほぼすべての事例で省略される）。
】【
他の仕様は、
この手続きを %~realm を省略して~callすることが多い
— それは、
%~realm が文脈から一義的に決定できることを意味する
（さもなければ指定-漏れである）。
例えば，演算や属性~用の手続きから~callされる所では、
通例的に `this$V に`関連な~realm$
（演算や属性が静的な場合は`現在の~realm$）
と解釈する他にない。
】</p>
<ol>
	<li>
~Assert：
%~ifc は %~realm 内に`公開されて$いる
◎
Assert: interface is exposed in realm.
</li>
	<li>
<p>
~IF［
%新-~target ~EQ `undefined^jv
］
⇒
%原型 ~LET %~realm に属する %~ifc 用の`~ifc原型~obj$
◎
If newTarget is undefined, then:
• Let prototype be the interface prototype object for interface in realm.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
~Assert：
`IsCallable$A( %新-~target ) ~EQ ~T
◎
Assert: IsCallable(newTarget) is true.
</li>
			<li>
%原型 ~LET
~ABRUPT `Get$A( %新-~target, `prototype^l )
◎
Let prototype be ? Get(newTarget, "prototype").
</li>
			<li>
<p>
~IF［
%原型 は `Object$jt でない
］：
◎
If prototype is not an Object, then:
</p>
				<ol>
					<li>
%~target~realm ~LET
~ABRUPT `GetFunctionRealm$A( %新-~target )
◎
Let targetRealm be ? GetFunctionRealm(newTarget).
</li>
					<li>
%原型 ~SET %~target~realm に属する %~ifc 用の`~ifc原型~obj$
◎
Set prototype to the interface prototype object for interface in targetRealm.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%~slot群 ~LET « `Prototype^sl, `Extensible^sl, `Realm^sl, `PrimaryInterface^sl »
◎
Let slots be « [[Prototype]], [[Extensible]], [[Realm]], [[PrimaryInterface]] ».
</li>
	<li>
~IF［
%~ifc は `DOMException$T である
］
⇒
%~slot群 に `ErrorData^sl を付加する
◎
If interface is DOMException, append [[ErrorData]] to slots.
</li>
	<li>
%~instance ~LET `MakeBasicObject$A( %~slot群 )
◎
Let instance be MakeBasicObject(slots).
</li>
	<li>
%~instance の
⇒＃
.`Realm^sl ~SET %~realm；
.`PrimaryInterface^sl ~SET %~ifc；
.`Prototype^sl ~SET %原型；
◎
Set instance.[[Realm]] to realm.
◎
Set instance.[[PrimaryInterface]] to interface.
◎
Set instance.[[Prototype]] to prototype.
</li>
	<li>
%~ifc群 ~LET %~ifc の`自身も含む継承した~ifc群$
◎
Let interfaces be the inclusive inherited interfaces of interface.
</li>
	<li>
<p>
%~ifc群 を成す
~EACH( `~ifc$ %先祖~ifc )
に対し：
◎
For every interface ancestor interface in interfaces:
</p>
		<ol>
			<li>
%偽造-不能~obj ~LET %~realm に属する［
%先祖~ifc の`~ifc~obj$
］の `Unforgeables^sl ~slotの値
◎
Let unforgeables be the value of the [[Unforgeables]] slot of the interface object of ancestor interface in realm.
</li>
			<li>
%~key群 ~LET
~NOABRUPT %偽造-不能~obj.`OwnPropertyKeys^sl()
◎
Let keys be ! unforgeables.[[OwnPropertyKeys]]().
</li>
			<li>
<p>
%~key群 を成す
~EACH( %~key )
に対し：
◎
For each element key of keys:
</p>
				<ol>
					<li>
%記述子 ~LET
~NOABRUPT %偽造-不能~obj.`GetOwnProperty^sl( %~key )
◎
Let descriptor be ! unforgeables.[[GetOwnProperty]](key).
</li>
					<li>
~NOABRUPT `DefinePropertyOrThrow$A( %~instance, %~key, %記述子 )
◎
Perform ! DefinePropertyOrThrow(instance, key, descriptor).
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~ifc は `Global$x `拡張d属性$を伴って宣言された
］：
◎
If interface is declared with the [Global] extended attribute, then:
</p>
		<ol>
			<li>
`正則~演算を定義する$( %~ifc, %~instance, %~realm )
◎
Define the regular operations of interface on instance, given realm.
</li>
			<li>
`正則~属性を定義する$( %~ifc, %~instance, %~realm )
◎
Define the regular attributes of interface on instance, given realm.
</li>
			<li>
`反復子~methodを定義する$( %~ifc, %~instance, %~realm )
◎
Define the iteration methods of interface on instance given realm.
</li>
			<li>
`非同期~反復子~methodを定義する$( %~ifc, %~instance, %~realm )
◎
Define the asynchronous iteration methods of interface on instance given realm.
</li>
			<li>
`大域~prop参照を定義する$( %~instance, %~realm )
◎
Define the global property references on instance, given realm.
</li>
			<li>
%~instance.`SetPrototypeOf^sl ~SET
`SetPrototypeOf＠#platform-object-setprototypeof§sl に定義される手続き
◎
Set instance.[[SetPrototypeOf]] as defined in § 3.8.1 [[SetPrototypeOf]].
</li>
		</ol>
	</li>
	<li>
~ELIF［
%~ifc群 を成すある`~ifc$は［
`有index~propを~support$する／`有名~propを~support$する
］］
⇒
%~instance の
⇒＃
.`GetOwnProperty^sl ~SET `GetOwnProperty＠#legacy-platform-object-getownproperty§sl に定義される手続き；
.`Set^sl ~SET `Set＠#legacy-platform-object-set§sl に定義される手続き；
.`DefineOwnProperty^sl ~SET `DefineOwnProperty＠#legacy-platform-object-defineownproperty§sl に定義される手続き；
.`Delete^sl ~SET `Delete＠#legacy-platform-object-delete§sl に定義される手続き；
.`PreventExtensions^sl ~SET `PreventExtensions＠#legacy-platform-object-preventextensions§sl に定義される手続き；
.`OwnPropertyKeys^sl ~SET `OwnPropertyKeys＠#legacy-platform-object-ownpropertykeys§sl に定義される手続き
◎
Otherwise, if interfaces contains an interface which supports indexed properties, named properties, or both:
• Set instance.[[GetOwnProperty]] as defined in § 3.9.1 [[GetOwnProperty]].
• Set instance.[[Set]] as defined in § 3.9.2 [[Set]].
• Set instance.[[DefineOwnProperty]] as defined in § 3.9.3 [[DefineOwnProperty]].
• Set instance.[[Delete]] as defined in § 3.9.4 [[Delete]].
• Set instance.[[PreventExtensions]] as defined in § 3.9.5 [[PreventExtensions]].
• Set instance.[[OwnPropertyKeys]] as defined in § 3.9.6 [[OwnPropertyKeys]].
</li>
	<li>
~RET %~instance
◎
Return instance.
</li>
</ol>
</div>


<div class="algo">
<p>
`大域~prop参照を定義する@
~algoは、
所与の
( %~target, `~realm$ %~realm )
に対し：
◎
To define the global property references on target, given realm realm, perform the following steps:
</p>
<ol>
	<li>
%~ifc群 ~LET ［
%~realm 内に`公開されて$いる すべての`~ifc$
］を，次に従うように~sortした結果
⇒
どの~ifc %A, %B に対しても、
%A は %B を`継承-$するならば， %A は %B より後に~listされる
◎
Let interfaces be a list that contains every interface that is exposed in realm.
◎
Sort interfaces in such a way that if A and B are items of interfaces, and A inherits from B, A has a higher index in interfaces than B.
</li>
	<li>
<p>
%~ifc群 を成す
~EACH( %~ifc )
に対し：
◎
For every interface of interfaces:
</p>
		<ol>
			<li>
<p>
~IF［
%~ifc は［
`LegacyNoInterfaceObject$x ／ `LegacyNamespace$x 
］`拡張d属性$を伴って宣言されてない
］：
◎
If interface is not declared with the [LegacyNoInterfaceObject] or [LegacyNamespace] extended attributes, then:
</p>
				<ol>
					<li id="cp-id-be-identifier">
%~ID ~LET %~ifc の`識別子$
◎
Let id be interface’s identifier.
</li>
					<li id="cp-create-interface-obj">
%~ifc~obj ~LET `~ifc~objを作成する$( %~ifc, %~ID, %~realm )
◎
Let interfaceObject be the result of creating an interface object for interface with id in realm.
</li>
					<li id="cp-DefineMethodProperty-target">
`DefineMethodProperty$A( %~target, %~ID, %~ifc~obj, `false^jv )
◎
Perform DefineMethodProperty(target, id, interfaceObject, false).
</li>
					<li>
<p>
~IF［
%~ifc は `LegacyWindowAlias$x `拡張d属性$を伴って宣言された
］~AND［
%~target は `Window$T `~ifc$を実装する
］：
◎
If the interface is declared with a [LegacyWindowAlias] extended attribute, and target implements the Window interface, then:
</p>
						<ol>
							<li>
<p>
`LegacyWindowAlias$x の`識別子$wAたちを成す
~EACH( `識別子$wA %~ID )
に対し：
◎
For every identifier id in [LegacyWindowAlias]'s identifiers:
</p>
								<ol>
									<!--cp-DefineMethodProperty-target-->
								</ol>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%~ifc は `LegacyFactoryFunction$x `拡張d属性$を伴って宣言された
］：
◎
If the interface is declared with a [LegacyFactoryFunction] extended attribute, then:
</p>
				<ol>
					<li>
<p>
`LegacyFactoryFunction$x の`識別子$fFたちを成す
~EACH( `識別子$fF %~ID )
に対し：
◎
For every identifier id in [LegacyFactoryFunction]'s identifiers:
</p>
						<ol>
							<li>
%旧来の~factory関数 ~LET `旧来の~factory関数を作成する$( %~ID, %~ifc, %~realm )
◎
Let legacyFactoryFunction be the result of creating a legacy factory function with id for interface in realm.
</li>
							<li>
`DefineMethodProperty$A( %~target, %~ID, %旧来の~factory関数, `false^jv )
◎
Perform DefineMethodProperty(target, id, legacyFactoryFunction, false).
</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
%~realm 内に`公開されて$いる
~EACH( `~callback~ifc$ %~ifc )
に対し：
◎
For every callback interface interface that is exposed in realm＼
</p>
		<ol>
			<li>
~IF［
%~ifc には`定数$は定義されていない
］
⇒
~CONTINUE
◎
and on which constants are defined:
</li>
			<!--cp-id-be-identifier-->
			<li>
%~ifc~obj ~LET `旧来の~callback~ifc~objを作成する$( %~ifc, %~ID, %~realm )
◎
Let interfaceObject be the result of creating a legacy callback interface object for interface with id in realm.
</li>
			<!--cp-DefineMethodProperty-target-->
		</ol>
	</li>
	<li>
<p>
%~realm 内に`公開されて$いる
~EACH( `~ns$ %~ns )
に対し：
◎
For every namespace namespace that is exposed in realm:
</p>
		<ol>
			<li>
%~ID ~LET %~ns の`識別子$
◎
Let id be namespace’s identifier.
</li>
			<li>
%~ns~obj ~LET `~ns~objを作成する$( %~ns, %~realm )
◎
Let namespaceObject be the result of creating a namespace object for namespace in realm.
</li>
			<li>
`DefineMethodProperty$A( %~target, %~ID, %~ns~obj, `false^jv )
◎
Perform DefineMethodProperty(target, id, namespaceObject, false).
</li>
		</ol>
	</li>
</ol>
</div>

<div class="note">
<p>注記：
`~platform~obj$が`実装-$する~ifcたちが成す集合は、
~objが存続する限り変化しない。
◎
The set of interfaces that a platform object implements does not change over the lifetime of the object.
</p>

<p>
互いに異なる`大域~obj$を伴う複数の`~platform~obj$は、
それらの `PrimaryInterface^sl 内部~slotにて同じ`~ifc$への参照を共有することになる。
例えば~pageは、
同一-生成元に属する~iframeを包含し得る
— ［
~main~pageの同じ種類の要素
］上で［
その~iframeの~method
］が~callされても例外は投出されないような【？】。
◎
Multiple platform objects with different global objects will share a reference to the same interface in their [[PrimaryInterface]] internal slots. For example, a page could contain a same-origin iframe, with the iframe’s method being called on the main page’s element of the same kind, with no exception thrown.
</p>

<p>
`~ifc~mixin$ %~mixin は、
`実装-$する~algoの評価に直に関与することはない。
代わりに，
%~mixin を`内包-$する各`~ifc$には自前の［
%~mixin を成す各`~mb$の “複製”
］があり、
対応する`演算~関数を作成する$ときに，
`the receiver^en 【？】が［
%~mixin を`内包-$する特定0の`~ifc$を`実装-$する
］かどうかを検査する。
◎
Interface mixins do not participate directly in the evaluation of the implements algorithm. Instead, each interface that the interface mixin is included in has its own "copy" of each member of the interface mixin, and the corresponding operation function checks that the receiver implements the particular interface which includes the interface mixin.
</p>
</div>

<div class="algo">
<p>
`~platform~obj$ %O の
`首~ifc@
は、
%O の `PrimaryInterface^sl 内部~slotの値を返す
— それは、
%O が`実装-$する`~ifc$のうち，継承~階層において最も末端の~ifcである。
◎
The primary interface of a platform object is the value of the object’s [[PrimaryInterface]] internal slot, which is the most-derived interface that it implements.
</p>
</div>

<p>
所与の`~platform~obj$ %O に対し，
%O が`属する~realm$は、
%O の作成-後に
`変化-@
し得る。
%O が`属する~realm$が変化したときは、
即時に， %O の `Prototype^sl `内部~slot$を［
その新たな`~realm$に属する `首~ifc$用の`~ifc原型~obj$
］に更新するモノトスル。
◎
The realm that a given platform object is associated with can change after it has been created. When the realm associated with a platform object is changed, its [[Prototype]] internal slot must be immediately updated to be the interface prototype object of the primary interface from the platform object’s newly associated realm.
</p>

<p>
加えて，`~platform~obj$は［
`Global$x `拡張d属性$を伴って宣言された~ifc
］を実装するならば、
次に挙げるものから宣言的に~propを取得する
⇒＃
`文字列化子＠#js-stringifier§,
`~maplike宣言＠#js-maplike§,
`~setlike宣言＠#js-setlike§
◎
Additionally, platform objects which implement an interface which has a [Global] extended attribute get properties declaratively from:
• § 3.7.8 Stringifiers,
• § 3.7.11 Maplike declarations, and
• § 3.7.12 Setlike declarations.
</p>

<!--cp-issue-imperatively-->

			<section id="platform-object-setprototypeof">
<h4>3.8.1. `SetPrototypeOf^sl</h4>

<div class="algo">
<p>
`Global$x `拡張d属性$を伴う`~ifc$を実装する`~platform~obj$ %O の `SetPrototypeOf^sl 内部~methodが，~JS言語~値 %V で~callされたときは、
次を走らす：
◎
When the [[SetPrototypeOf]] internal method of a platform object O that implements an interface with the [Global] extended attribute is called with JavaScript language value V, the following step is taken:
</p>

<!--cp-SetImmutablePrototype-->
</div>

<p class="note">注記：
`Window$T ~objに対しては、
これが実装されているかどうかは観測し得ない
— `WindowProxy$T ~objが在るので、
`Window^T ~obj上では `SetPrototypeOf^sl が直に~callされることは決してないことが確保されるので。
しかしながら，他の~大域~objに対しては、
このことは必要yでない。
◎
Note: For Window objects, it is unobservable whether this is implemented, since the presence of the WindowProxy object ensures that [[SetPrototypeOf]] is never called on a Window object directly. For other global objects, however, this is necessary.
</p>

			</section>
		</section>
		<section id="js-legacy-platform-objects">
<h3 title="Legacy platform objects">3.9. 旧来の~platform~obj</h3>

<p>
`旧来の~platform~obj$は、［
自身の［
`有index~prop$, `有名~prop$
］に対応するような 追加的な~prop
］を有するように現れることになる。
これらの~propは，~objの “真の” 自前の~propではないが、
`GetOwnProperty^sl 内部~methodにより公開されて見えるようにされる。
◎
Legacy platform objects will appear to have additional properties that correspond to their indexed and named properties. These properties are not “real” own properties on the object, but are made to look like they are by being exposed by the [[GetOwnProperty]] internal method .
</p>

<p>
~objが複数の［
`有index~propを~support$する~ifc
］を実装することも許可-可能である。
しかしながら，そうであって各~ifcによる［
~objが`~supportする~prop~index$の定義
］が競合している場合に、［
~objが有するように現れることになる追加的な~prop
］がどれになるか, あるいは［
その有index~propに関する正確な挙動
］がどうなるか，については、
未定義である。
同じことは、
有名~propについても該当する。
◎
It is permissible for an object to implement multiple interfaces that support indexed properties. However, if so, and there are conflicting definitions as to the object’s supported property indices, then it is undefined what additional properties the object will appear to have, or what its exact behavior will be with regard to its indexed properties. The same applies for named properties.
</p>

<p>
［
旧来の~platform~objが実装する，継承~階層において最も末端の~ifc
］上で定義される`有index~prop取得子$が、［
~objに対し，`配列~index$で~index-したときの挙動
］を定義する。
`有index~prop設定子$に対しても同様になる。
先祖~ifcによる，これらの特殊~演算の定義は、
この仕方で上書きできる。
◎
The indexed property getter that is defined on the derived-most interface that the legacy platform object implements is the one that defines the behavior when indexing the object with an array index. Similarly for indexed property setters. This way, the definitions of these special operations from ancestor interfaces can be overridden.
</p>

<div class="p">
<p>
所与の~platform~obj %O の~prop名は、
%O が ~AND↓ を満たす`~ifc$ %I を実装するならば，
`偽造-不能な~prop名@
とされる：
</p>
<ul>
	<li>
%I はその~prop名を識別子とする`~ifc~mb$を有する
</li>
	<li>
その~mbは［
%O が実装するいずれかの~ifc
］上で`偽造-不能$である。
</li>
</ul>

◎
A property name is an unforgeable property name on a given platform object O if the object implements an interface that has an interface member with that identifier and that interface member is unforgeable on any of the interfaces that O implements.
</div>

<p>
`取得子$の~supportは
`GetOwnProperty＠#legacy-platform-object-getownproperty§sl
にて取扱われ、
`設定子$については
`DefineOwnProperty＠#legacy-platform-object-defineownproperty§sl,
`Set＠#legacy-platform-object-set§sl
にて取扱われる。
◎
Support for getters is handled in § 3.9.1 [[GetOwnProperty]], and for setters in § 3.9.3 [[DefineOwnProperty]] and § 3.9.2 [[Set]].
</p>

<p>
加えて，`旧来の~platform~obj$には、
次に挙げる内部~methodが定義される
⇒
`Delete＠#legacy-platform-object-delete§sl,
`PreventExtensions＠#legacy-platform-object-preventextensions§sl,
`OwnPropertyKeys＠#legacy-platform-object-ownpropertykeys§sl
◎
Additionally, legacy platform objects have internal methods as defined in:
• § 3.9.4 [[Delete]],
• § 3.9.5 [[PreventExtensions]], and
• § 3.9.6 [[OwnPropertyKeys]].
</p>

			<section id="legacy-platform-object-getownproperty">
<h4>3.9.1. `GetOwnProperty^sl</h4>

<div class="algo">
<p>
`旧来の~platform~obj$ %O の `GetOwnProperty^sl 内部~methodは、
( ~prop名 %P )
を引数に~callされたときには，次に従って挙動するモノトスル：
◎
The [[GetOwnProperty]] internal method of every legacy platform object O must behave as follows when called with property name P:
</p>
<ol>
	<li>
~RET
~ABRUPT `LegacyPlatformObjectGetOwnProperty$A( %O, %P, `false^jv )
◎
Return ? LegacyPlatformObjectGetOwnProperty(O, P, false).
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-set">
<h4>3.9.2. `Set^sl</h4>

<div class="algo">
<p>
`旧来の~platform~obj$ %O の `Set^sl 内部~methodは、
( ~prop名 %P, 値 %V, ~JS言語~値 %Receiver )
を引数に~callされたときには，次に従って挙動するモノトスル：
◎
The [[Set]] internal method of every legacy platform object O must behave as follows when called with property name P, value V, and JavaScript language value Receiver:
</p>
<ol>
	<li>
<p>
~IF［
%O ~EQ %Receiver
］：
◎
If O and Receiver are the same object, then:
</p>
		<ol>
			<li>
<p>
~IF［
%O が`実装-$する ある~ifcは`有index~prop設定子$を伴う
］~AND［
%P は`配列~indexで$ある
］：
◎
If O implements an interface with an indexed property setter and P is an array index, then:
</p>
				<ol>
					<li>
%O 上で`有index~prop設定子を呼出す$( %P, %V )
◎
Invoke the indexed property setter on O with P and V.
</li>
					<li id="cp-return-true">
~RET `true^jv
◎
Return true.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
%O が`実装-$する ある~ifcは`有名~prop設定子$を伴う
］~AND［
%P は `String$jt である
］：
◎
If O implements an interface with a named property setter and P is a String, then:
</p>
				<ol>
					<li>
%O 上で`有名~prop設定子を呼出す$( %P, %V )
◎
Invoke the named property setter on O with P and V.
</li>
					<li>
~RET `true^jv
◎
Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
%自前の記述子 ~LET
~ABRUPT `LegacyPlatformObjectGetOwnProperty$A( %O, %P, `true^jv )
◎
Let ownDesc be ? LegacyPlatformObjectGetOwnProperty(O, P, true).
</li>
	<li>
~ABRUPT `OrdinarySetWithOwnDescriptor$A( %O, %P, %V, %Receiver, %自前の記述子 )
◎
Perform ? OrdinarySetWithOwnDescriptor(O, P, V, Receiver, ownDesc).
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-defineownproperty">
<h4>3.9.3. `DefineOwnProperty^sl</h4>

<div class="algo">
<p>
`旧来の~platform~obj$ %O の `DefineOwnProperty^sl 内部~methodは、
( ~prop~key %P, `~pdesc$ %記述子 )
を伴って~callされたときは，次の手続きに従うモノトスル：
◎
When the [[DefineOwnProperty]] internal method of a legacy platform object O is called with property key P and Property Descriptor Desc, the following steps must be taken:
</p>
<ol>
	<li>
<p id="cp-if-support-and-index">
~IF［
%O は`有index~propを~support$する
］~AND［
%P は `配列~indexで$ある
］：
◎
If O supports indexed properties and P is an array index, then:
</p>
		<ol>
			<li id="cp-ret-false-ifnot-IsDataDescriptor">
~IF［
`IsDataDescriptor$A( %記述子 ) を~callした結果 ~EQ `false^jv
］
⇒
~RET `false^jv
◎
If the result of calling IsDataDescriptor(Desc) is false, then return false.
</li>
			<li>
~IF［
%O が`実装-$する どの~ifcも，`有index~prop設定子$を伴わない
］
⇒
~RET `false^jv
◎
If O does not implement an interface with an indexed property setter, then return false.
</li>
			<li>
%O 上で`有index~prop設定子を呼出す$( %P, %記述子.`Value^sl )
◎
Invoke the indexed property setter on O with P and Desc.[[Value]].
</li>
			<li>
~RET `true^jv
◎
Return true.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If＼
</p>
		<ul>
			<li>
%O は`有名~propを~support$する
◎
O supports named properties,＼
</li>
			<li>
%O は `Global$x `拡張d属性$を伴う`~ifc$を`実装-$しない
◎
O does not implement an interface with the [Global] extended attribute,＼
</li>
			<li>
%P は `String$jt である
◎
P is a String,＼
</li>
			<li>
%P は %O の`偽造-不能な~prop名$でない
◎
and P is not an unforgeable property name of O, then:
</li>
			<li>
［
%O が`実装-$する ある~ifcは `LegacyOverrideBuiltIns$x `拡張d属性$を伴う
］~OR［
%O は 名前 %P の自前の~propを有さない
］
◎
• ↓ Let creating be true if P is not a supported property name, and false otherwise.
◎
• If O implements an interface with the [LegacyOverrideBuiltIns] extended attribute or O does not have an own property named P,＼
</li>
		</ul>
<p>
…ならば：
◎
then:
</p>
		<ol>
			<li>
~IF［
%P は %O が`~supportする~prop名$でない
］~AND［
%O が`実装-$する どの~ifcも，`有名~prop設定子$を伴わない
］
⇒
~RET `false^jv
◎
• If creating is false and O does not implement an interface with a named property setter, then return false.
</li>
			<li>
<p>
~IF［
%O が`実装-$する ある~ifcは`有名~prop設定子$を伴う
］：
◎
• If O implements an interface with a named property setter, then:
</p>
				<ol>
					<!--cp-ret-false-ifnot-IsDataDescriptor-->
					<li>
%O 上で`有名~prop設定子を呼出す$( %P, %記述子.`Value^sl )
◎
• Invoke the named property setter on O with P and Desc.[[Value]].
</li>
					<li>
~RET `true^jv
◎
• Return true.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~RET
~NOABRUPT `OrdinaryDefineOwnProperty$A( %O, %P, %記述子 )
◎
Return ! OrdinaryDefineOwnProperty(O, P, Desc).
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-delete">
<h4>3.9.4. `Delete^sl</h4>

<div class="algo">
<p>
`旧来の~platform~obj$ %O の `Delete^sl 内部~methodは、
~prop名 %P を伴って~callされたときには，次に従って挙動するモノトスル。
◎
The [[Delete]] internal method of every legacy platform object O must behave as follows when called with property name P.
</p>
<ol>
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<li id="cp-ToUint32-2">
%~index ~LET
~NOABRUPT `ToUint32$A( %P )
◎
Let index be the result of calling ! ToUint32(P).
</li>
			<li>
~IF［
%~index は %O が`~supportする~prop~index$でない
］
⇒
~RET `true^jv
◎
If index is not a supported property index, then return true.
</li>
			<!--cp-return-false-->
		</ol>
	</li>
	<li>
<p>
~IF［
%O は`有名~propを~support$する
］~AND［
%O は `Global$x `拡張d属性$を伴う`~ifc$を`実装-$しない
］~AND［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］：
◎
If O supports named properties, O does not implement an interface with the [Global] extended attribute and the result of calling the named property visibility algorithm with property name P and object O is true, then:
</p>
		<ol>
			<li>
~IF［
%O が`実装-$する どの~ifcも，`有名~prop削除子$を伴わない
］
⇒
~RET `false^jv
◎
If O does not implement an interface with a named property deleter, then return false.
</li>
			<li>
%演算 ~LET `有名~prop削除子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property deleter.
</li>
			<li>
<p id="cp-ifdef-no-id">
~IF［
%演算 は`識別子$を伴わずに定義された
］：
◎
If operation was defined without an identifier, then:
</p>
				<ol>
					<li>
%演算 を宣言した`~ifc$用の`既存の有名~propを削除する手続き$( %P )
◎
Perform the steps listed in the interface description to delete an existing named property with P as the name.
</li>
					<li>
~IF［
手続きから削除の失敗-が指示された
］
⇒
~RET `false^jv
◎
If the steps indicated that the deletion failed, then return false.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, operation was defined with an identifier:
</p>
				<ol>
					<li>
%演算 用の`~method手続き$を［
`this$V として %O,
引数~list « %P »
］を与える下で遂行する
◎
Perform method steps of operation with O as this and « P » as the argument values.
</li>
					<li>
~IF［
%演算 は `返り値~型$ `boolean$T を伴って宣言された
］~AND［
前~段の結果 ~EQ `false^V
］
⇒
~RET `false^jv
◎
If operation was declared with a return type of boolean and the steps returned false, then return false.
</li>
				</ol>
			</li>
			<!--cp-return-true-->
		</ol>
	</li>
	<li>
<p>
~IF［
%O は 名前 %P の自前の~propを有する
］：
◎
If O has an own property with name P, then:
</p>
		<ol>
			<li>
~IF［
その~propは~configure可能でない
］
⇒
~RET `false^jv
◎
If the property is not configurable, then return false.
</li>
			<li>
~ELSE
⇒
その~propを %O から除去する
◎
Otherwise, remove the property from O.
</li>
		</ol>
	</li>
	<!--cp-return-true-->
</ol>
</div>

			</section>
			<section id="legacy-platform-object-preventextensions">
<h4>3.9.5. `PreventExtensions^sl</h4>

<div class="algo">
<p>
`旧来の~platform~obj$の `PreventExtensions^sl 内部~methodが~callされたときは、
次を走らす：
◎
When the [[PreventExtensions]] internal method of a legacy platform object is called, the following steps are taken:
</p>
<ol>
	<!--cp-return-false-->
</ol>
</div>

<p class="note">注記:
これにより、
`旧来の~platform~obj$は 拡張-可能に保たれる
— それらに対する `PreventExtensions^sl を失敗させることにより。
◎
Note: this keeps legacy platform objects extensible by making [[PreventExtensions]] fail for them.
</p>

			</section>
			<section id="legacy-platform-object-ownpropertykeys">
<h4>3.9.6. `OwnPropertyKeys^sl</h4>

<p>
この文書は、
`~ifc$を実装している`~platform~obj$
（あるいは`例外を表現する~platform~obj＠#js-exception-objects$）
に対しては，完全な~prop列挙~順序は定義しない。
が、
`旧来の~platform~obj$に対しては，定義する
— 次に与える `OwnPropertyKeys^sl 内部~methodを定義することにより。
◎
This document does not define a complete property enumeration order for platform objects implementing interfaces (or for platform objects representing exceptions). However, it does for legacy platform objects by defining the [[OwnPropertyKeys]] internal method as follows.
</p>

<div class="algo">
<p>
`旧来の~platform~obj$ %O の `OwnPropertyKeys^sl 内部~methodの~call時には、
次を走らす：
◎
When the [[OwnPropertyKeys]] internal method of a legacy platform object O is called, the following steps are taken:
</p>
<ol>
	<li>
%~key群 ~LET 新たな空`~list$
— これは、
いくつかの~JS［
`String^jt ／ `Symbol^jt
］値からなる。
◎
Let keys be a new empty list of JavaScript String and Symbol values.
</li>
	<li>
~IF［
%O は`有index~propを~support$する
］
⇒
~EACH( %O が`~supportする~prop~index$ %~index )
に対し，昇順に
⇒
%~key群 に次の結果を`付加する$
⇒
~NOABRUPT `ToString$A( %~index )
◎
If O supports indexed properties, then for each index of O’s supported property indices, in ascending numerical order, append ! ToString(index) to keys.
</li>
	<li>
~IF［
%O は`有名~propを~support$する
］
⇒
~EACH( %O が`~supportする~prop名$ %P )
に対し
【~prop名たちが成す集合を定義する仕様により定義される順序で】
⇒
~IF［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］
⇒
%~key群 に %P を`付加する$
◎
If O supports named properties, then for each P of O’s supported property names that is visible according to the named property visibility algorithm, append P to keys.
</li>
	<li>
%O の
~EACH( 自前の~prop~key %P )
に対し，~propを作成した順に
⇒
~IF［
%P は `String^jt である
］
⇒
%~key群 に %P を`付加する$
◎
For each P of O’s own property keys that is a String, in ascending chronological order of property creation, append P to keys.
</li>
	<li>
%O の
~EACH( 自前の~prop~key %P )
に対し，~propを作成した順に
⇒
~IF［
%P は `Symbol^jt である
］
⇒
%~key群 に %P を`付加する$
◎
For each P of O’s own property keys that is a Symbol, in ascending chronological order of property creation, append P to keys.
</li>
	<li>
~Assert:
%~key群 内には重複する~itemは無い
◎
Assert: keys has no duplicate items.
</li>
	<li>
~RET %~key群
◎
Return keys.
</li>
</ol>
</div>

			</section>
			<section id="legacy-platform-object-abstract-ops">
<h4 title="Abstract operations">3.9.7. 各種 抽象-演算</h4>

<div class="algo">
<p>
所与の~prop名 %P が
`配列~indexで@
あるかどうか決定するときは、
次の~algoを適用する：
◎
To determine if a property name P is an array index, the following algorithm is applied:
</p>
<ol>
	<li>
~IF［
%P は `String$jt でない
］
⇒
~RET ~F
◎
If P is not a String, then return false.
</li>
	<li>
%~index ~LET
`CanonicalNumericIndexString$A( %P )
◎
Let index be CanonicalNumericIndexString(P).
</li>
	<li>
~IF［
%~index ~EQ `undefined^jv
］
⇒
~RET ~F
◎
If index is undefined, then return false.
</li>
	<li>
~IF［
`IsInteger$A( %~index ) ~EQ `false^jv
］
⇒
~RET ~F
◎
If IsInteger(index) is false, then return false.
</li>
	<li>
<p>
~IF［
%~index ~EQ −0
］~OR［
%~index ~LT 0
］~OR［
%~index ~GTE 2`32^sup ~MINUS 1
］
⇒
~RET ~F
◎
If index is −0, then return false.
◎
If index &lt; 0, then return false.
◎
If index ≥ 232 − 1, then return false.
</p>

<p class="note">注記：
2`32^sup ~MINUS 1 は、
~JSに許容される最大な配列~長さである。
◎
Note: 232 − 1 is the maximum array length allowed by JavaScript.
</p>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="algo">
<p>
所与の有名~propを~obj上に公開するかどうかは、
`有名~propの可視性判定~algo@
を利用して決定される。
一部の有名~propは、［
`LegacyOverrideBuiltIns$x `拡張d属性$が利用されたかどうか
］に依存して，~obj上に公開されなくなる。
この~algoは、
所与の
( ~prop名 %P, ~obj %O )
に対し，次に従って演算する：
◎
The named property visibility algorithm is used to determine if a given named property is exposed on an object. Some named properties are not exposed on an object depending on whether the [LegacyOverrideBuiltIns] extended attribute was used. The algorithm operates as follows, with property name P and object O:
</p>
<ol>
	<li>
~IF［
%P は %O が`~supportする~prop名$でない
］
⇒
~RET ~F
◎
If P is not a supported property name of O, then return false.
</li>
	<li>
<p>
~IF［
%O は名前 %P の自前の~propを有する
］
⇒
~RET ~F
◎
If O has an own property named P, then return false.
</p>

<p class="note">注記：
これには %O が偽造-不能な~propを有する事例も含まれる
— 実施においては、
それらは常に %O が~supportする~prop名を有する前に設定しておかれ，
対応する有名~propを不可視にするので。
◎
Note: This will include cases in which O has unforgeable properties, because in practice those are always set up before objects have any supported property names, and once set up will make the corresponding named properties invisible.
</p>

	</li>
	<li>
~IF［
%O が`実装-$する ある~ifcは， `LegacyOverrideBuiltIns$x `拡張d属性$を有する
］
⇒
~RET ~T
◎
If O implements an interface that has the [LegacyOverrideBuiltIns] extended attribute, then return true.
</li>
	<li>
%prototype ~LET %O . `GetPrototypeOf^sl()
◎
Let prototype be O.[[GetPrototypeOf]]().
</li>
	<li>
<p>
~WHILE［
%prototype ~NEQ `null^jv
］：
◎
While prototype is not null:
</p>
		<ol>
			<li>
~IF［
%prototype は `有名~prop群~obj$でない
］~AND［
%prototype は 名前 %P の自前の~propを有する
］
⇒
~RET ~F
◎
If prototype is not a named properties object, and prototype has an own property named P, then return false.
</li>
			<li>
%prototype ~SET %prototype . `GetPrototypeOf^sl()
◎
Set prototype to prototype.[[GetPrototypeOf]]().
</li>
		</ol>
	</li>
	<li>
~RET ~T
◎
Return true.
</li>
</ol>
</div>

<div class="note">
<p>注記：
これにより、
有名~propを伴う~objに対する~prop解決は，次の順序で行えるようになる：
◎
This ensures that for objects with named properties, property resolution is done in the following order:
</p>
<ol>
	<li>
有index~prop
◎
Indexed properties.
</li>
	<li>
自前の~prop
— 偽造-不能な属性／演算も含め。
◎
Own properties, including unforgeable attributes and operations.
</li>
	<li>
<p>
`LegacyOverrideBuiltIns$x である場合：
◎
Then, if [LegacyOverrideBuiltIns]:
</p>
		<ol>
			<li>
有名~prop
◎
Named properties.
</li>
			<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
		</ol>
	</li>
	<li>
<p>
他の場合：
◎
Otherwise, if not [LegacyOverrideBuiltIns]:
</p>
		<ol>
			<li>
原型鎖からの~prop
◎
Properties from the prototype chain.
</li>
			<li>
有名~prop
◎
Named properties.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`有index~prop設定子$を伴う`~ifc$ %A を`実装-$する`~platform~obj$ %O 上で
`有index~prop設定子を呼出す@
~algoは、
所与の
( ~prop名 %P, ~JS値 %V )
に対し：
◎
To invoke an indexed property setter on a platform object O with property name P and JavaScript value V, the following steps must be performed:
</p>
<ol>
	<li>
%~index ~LET
~ABRUPT `ToUint32$A( %P )
◎
Let index be the result of calling ? ToUint32(P).
◎
↓ Let creating be true if index is not a supported property index, and false otherwise.
</li>
	<li>
%演算 ~LET `有index~prop設定子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the indexed property setter.
</li>
	<li id="cp-2nd-arg">
%T ~LET %演算 の 2 個目の引数の型
◎
Let T be the type of the second argument of operation.
</li>
	<li id="cp-V-toIDL-T">
%値 ~LET `~IDL値に変換する$( %V, %T )
◎
Let value be the result of converting V to an IDL value of type T.
</li>
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF［
%~index は %O が`~supportする~prop~index$でない
］
⇒
%A 用の`新たな有index~propを設定する手続き$( %~index, %値 )
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new indexed property with index as the index and value as the value.
</li>
			<li>
~ELSE
⇒
%A 用の`既存の有index~propを設定する手続き$( %~index, %値 )
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing indexed property with index as the index and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%演算 用の`~method手続き$を［
`this$V として %O,
引数~list « %~index, %値 »
］を与える下で遂行する
◎
Otherwise, operation was defined with an identifier. Perform the method steps of operation with O as this and « index, value » as the argument values.
</li>
</ol>
</div>

<div class="algo">
<p>
`有名~prop設定子$を伴う`~ifc$ %A を`実装-$する`~platform~obj$ %O 上で
`有名~prop設定子を呼出す@
~algoは、
所与の
( ~prop名 %P, ~JS値 %V )
に対し：
◎
To invoke a named property setter on a platform object O with property name P and JavaScript value V, the following steps must be performed:
</p>
<ol>
	<li>
%演算 ~LET `有名~prop設定子$を宣言するために利用された演算
◎
↓ Let creating be true if P is not a supported property name, and false otherwise.
◎
Let operation be the operation used to declare the named property setter.
</li>
	<!--cp-2nd-arg-->
	<!--cp-V-toIDL-T-->
	<li>
<!--cp-ifdef-no-id-->
		<ol>
			<li>
~IF［
%P は %O が`~supportする~prop名$である
］
⇒
%A 用の`新たな有名~propを設定する手続き$( %P, %値 )
◎
If creating is true, then perform the steps listed in the interface description to set the value of a new named property with P as the name and value as the value.
</li>
			<li>
~ELSE
⇒
%A 用の`既存の有名~propを設定する手続き$( %P, %値 )
◎
Otherwise, creating is false. Perform the steps listed in the interface description to set the value of an existing named property with P as the name and value as the value.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%演算 用の`~method手続き$を［
`this$V として %O,
引数~list « %P, %値 »
］を与える下で遂行する
◎
Otherwise, operation was defined with an identifier. Perform the method steps of operation with O as this and « P, value » as the argument values.
</li>
</ol>
</div>

<div class="algo">
<p>
`LegacyPlatformObjectGetOwnProperty@A
抽象-演算は、
所与の
( ~obj %O, ~prop名 %P, 真偽-値 %有名~propは無視するか )
で~callされたとき，次の手続きを遂行する：
◎
The LegacyPlatformObjectGetOwnProperty abstract operation performs the following steps when called with an object O, a property name P, and a boolean ignoreNamedProps value:
</p>
<ol>
	<li>
<!--cp-if-support-and-index-->
		<ol>
			<!--cp-ToUint32-2-->
			<li>
<p>
~IF［
%~index は %O が`~supportする~prop~index$である
］：
◎
If index is a supported property index, then:
</p>
				<ol>
					<li>
%演算 ~LET `有index~prop取得子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the indexed property getter.
</li>
					<!--cp-let-uninitialized-->
					<li>
~IF［
%演算 は`識別子$を伴わずに定義された
］
⇒
%値 ~SET %演算 を宣言した`~ifc$用の`有index~propの値を決定する手続き$( %~index )
◎
If operation was defined without an identifier, then set value to the result of performing the steps listed in the interface description to determine the value of an indexed property with index as the index.
</li>
					<li>
~ELSE
⇒
%値 ~SET %演算 用の`~method手続き$を［
`this$V として %O,
引数~list « %~index »
］を与える下で遂行した結果
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the method steps of operation with O as this and « index » as the argument values.
</li>
					<li>
<p>
~RET 次を伴う新たな`~pdesc$
⇒
`BTT-V^desc
— ここで：
</p>
						<ul>
							<!--cp-let-convert2-->
							<li>
%B ~LET ［
%O が`実装-$する ある~ifcは`有index~prop設定子$を伴うならば `true^jv ／
~ELSE_ `false^jv
］
</li>
						</ul>
◎
Let desc be a newly created Property Descriptor with no fields.
◎
Set desc.[[Value]] to the result of converting value to a JavaScript value.
◎
If O implements an interface with an indexed property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
Set desc.[[Enumerable]] and desc.[[Configurable]] to true.
◎
Return desc.
</li>
				</ol>
			</li>
			<li>
%有名~propは無視するか ~SET ~T
◎
Set ignoreNamedProps to true.
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%O は`有名~propを~support$する
］~AND［
%有名~propは無視するか ~EQ ~F
］：
◎
If O supports named properties and ignoreNamedProps is false, then:
</p>
		<ol>
			<li>
<p>
~IF［
`有名~propは可視か？$( %P, %O ) ~EQ ~T
］：
◎
If the result of running the named property visibility algorithm with property name P and object O is true, then:
</p>
				<ol>
					<li>
%演算 ~LET `有名~prop取得子$を宣言するために利用された演算
◎
Let operation be the operation used to declare the named property getter.
</li>
					<!--cp-let-uninitialized-->
					<!--cp-determine-ifndef-->
					<li>
~ELSE
⇒
%値 ~SET %演算 用の`~method手続き$を［
`this$V として %O,
引数~list « %P »
］を与える下で遂行した結果
◎
Otherwise, operation was defined with an identifier. Set value to the result of performing the method steps of operation with O as this and « P » as the argument values.
</li>
					<li>
<p>
~RET 次を伴う新たな`~pdesc$
⇒
`BET-V^desc
— ここで：
</p>
						<ul>
							<!--cp-let-convert2-->
							<li>
%B ~LET ［
%O が`実装-$する ある~ifcは`有名~prop設定子$を伴うならば `true^jv ／
~ELSE_ `false^jv
］
</li>
							<li>
%E ~LET ［
%O が`実装-$する ある~ifcは `LegacyUnenumerableNamedProperties$x `拡張d属性$を伴うならば `false^jv ／
~ELSE_ `true^jv
］
</li>
						</ul>
◎
Let desc be a newly created Property Descriptor with no fields.
◎
Set desc.[[Value]] to the result of converting value to a JavaScript value.
◎
If O implements an interface with a named property setter, then set desc.[[Writable]] to true, otherwise set it to false.
◎
If O implements an interface with the [LegacyUnenumerableNamedProperties] extended attribute, then set desc.[[Enumerable]] to false, otherwise set it to true.
◎
Set desc.[[Configurable]] to true.
◎
Return desc.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<!--cp-return-OrdinaryGetOwnProperty-->
</ol>
</div>

			</section>
		</section>
		<section id="js-observable-arrays">
<h3 title="Observable array exotic objects">3.10. 観測-可能な配列~exotic~obj</h3>

<p>
`観測-可能な配列~exotic~obj@
は、
~JS`~Proxy~exotic~obj$を成す特定の型であり，［
この節にて定義する各種~proxy~trap
］を利用して作成される。
それらがこの方式で定義されるわけは、
~JS仕様は［
`~Proxy~exotic~obj$のうち，~proxy~targetとして `Array^jt ~instanceを有するもの
］用に特別な扱いを含んでいて，［
`観測-可能な配列~型$は、
この特別な扱いが欠損なく~JS~codeに公開される
］ことを確保することが求まれるからである。
◎
An observable array exotic object is a specific type of JavaScript Proxy exotic object which is created using the proxy traps defined in this section. They are defined in this manner because the JavaScript specification includes special treatment for Proxy exotic objects that have Array instances as their proxy target, and we want to ensure that observable array types are exposed to JavaScript code with this special treatment intact.
</p>

<p>
観測-可能な配列~exotic~objが利用する各種~proxy~trapは、［
通常の `Array^jt ~instanceのそれらを超える，次に挙げる不変則
］を確保するように働く：
◎
The proxy traps used by observable array exotic objects work to ensure a number of invariants beyond those of normal Array instances:
</p>

<ul>
	<li>
これらの配列には、
穴は無い
— すなわち、
`配列~index$~propは範囲
{ 0 〜 `observableArray.length^c ~MINUS 1 }
の外側に存在せず，この範囲~内にあるどの~propも［
指定された~Web~IDL型
］に互換な値で埋められることになる。
◎
The arrays have no holes, i.e. every property in the inclusive range 0 through observableArray.length − 1 will be filled with a value compatible with the specified Web IDL type, and no array index properties will exist outside that range.
</li>
	<li>
重要な~prop用の~prop記述子は、
それらの既定の環境設定からは変更できない
— 有index~propは，常に［
環境設定-可能, 列挙-可能, ~writable
］な~data~propであり続ける一方で、
`length^jp ~propは，常に［
環境設定-不能, 列挙-不能, ~writable
］な~data~propであり続ける。
◎
The property descriptors for important properties cannot be changed from their default configuration; indexed properties always remain as configurable, enumerable, and writable data properties, while the length property remains as a non-configurable, non-enumerable, and writable data property.
</li>
	<li>
配列に追加的な~propを追加することは防止できない
— 例えば， `Object.preventExtensions()^c を利用しても。
◎
Adding additional properties to the array cannot be prevented using, for example, Object.preventExtensions().
</li>
</ul>

<div class="algo">
<p>
`~realm$ %~realm 内に
`観測-可能な配列~exotic~objを作成する@
~algoは、
所与の
( ~Web~IDL型 %T, ~algo %設定する~algo, ~algo %削除する~algo )
に対し：
◎
To create an observable array exotic object in a realm realm, given Web IDL type T and algorithms setAlgorithm and deleteAlgorithm:
</p>
<ol>
	<li>
%内縁~配列 ~LET
~NOABRUPT `ArrayCreate$A( 0 )
◎
Let innerArray be ! ArrayCreate(0).
</li>
	<li>
%~handler ~LET
`OrdinaryObjectCreate$A( `null^jv, « `Type^sl, `SetAlgorithm^sl, `DeleteAlgorithm^sl, `BackingList^sl » )
◎
Let handler be OrdinaryObjectCreate(null, « [[Type]], [[SetAlgorithm]], [[DeleteAlgorithm]], [[BackingList]] »).
</li>
	<li>
%~handler.`Type^sl ~SET %T
◎
Set handler.[[Type]] to T.
</li>
	<li>
%~handler.`SetAlgorithm^sl ~SET %設定する~algo
◎
Set handler.[[SetAlgorithm]] to setAlgorithm.
</li>
	<li>
%~handler.`DeleteAlgorithm^sl ~SET %削除する~algo
◎
Set handler.[[DeleteAlgorithm]] to deleteAlgorithm.
</li>
	<li>
%defineProperty ~LET
`CreateBuiltinFunction$A( `defineProperty＠#js-observable-array-defineProperty§jp の手続き, « », %~realm )
◎
Let defineProperty be CreateBuiltinFunction(the steps from § 3.10.1 defineProperty, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `defineProperty^l, %defineProperty )
◎
Perform ! CreateDataPropertyOrThrow(handler, "defineProperty", defineProperty).
</li>
	<li>
%deleteProperty ~LET
`CreateBuiltinFunction$A( `deleteProperty＠#js-observable-array-deleteProperty§jp の手続き, « », %~realm )
◎
Let deleteProperty be CreateBuiltinFunction(the steps from § 3.10.2 deleteProperty, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `deleteProperty^l, %deleteProperty )
◎
Perform ! CreateDataPropertyOrThrow(handler, "deleteProperty", deleteProperty).
</li>
	<li>
%get ~LET
`CreateBuiltinFunction$A( `get＠#js-observable-array-get§jp の手続き, « », %~realm )
◎
Let get be CreateBuiltinFunction(the steps from § 3.10.3 get, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `get^l, %get )
◎
Perform ! CreateDataPropertyOrThrow(handler, "get", get).
</li>
	<li>
%getOwnPropertyDescriptor ~LET
`CreateBuiltinFunction$A( `getOwnPropertyDescriptor＠#js-observable-array-getOwnPropertyDescriptor§jp の手続き, « », %~realm )
◎
Let getOwnPropertyDescriptor be CreateBuiltinFunction(the steps from § 3.10.4 getOwnPropertyDescriptor, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `getOwnPropertyDescriptor^l, %getOwnPropertyDescriptor )
◎
Perform ! CreateDataPropertyOrThrow(handler, "getOwnPropertyDescriptor", getOwnPropertyDescriptor).
</li>
	<li>
%has ~LET
`CreateBuiltinFunction$A( `has＠#js-observable-array-has§jp の手続き, « », %~realm )
◎
Let has be CreateBuiltinFunction(the steps from § 3.10.5 has, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `has^l, %has )
◎
Perform ! CreateDataPropertyOrThrow(handler, "has", has).
</li>
	<li>
%自前の~key群 ~LET
`CreateBuiltinFunction$A( `ownKeys＠#js-observable-array-ownKeys§jp の手続き, « », %~realm )
◎
Let ownKeys be CreateBuiltinFunction(the steps from § 3.10.6 ownKeys, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `ownKeys^l, %自前の~key群 )
◎
Perform ! CreateDataPropertyOrThrow(handler, "ownKeys", ownKeys).
</li>
	<li>
%拡張を防止するか ~LET
`CreateBuiltinFunction$A( `preventExtensions＠#js-observable-array-preventExtensions§jp の手続き, « », %~realm )
◎
Let preventExtensions be CreateBuiltinFunction(the steps from § 3.10.7 preventExtensions, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `preventExtensions^l, %拡張を防止するか )
◎
Perform ! CreateDataPropertyOrThrow(handler, "preventExtensions", preventExtensions).
</li>
	<li>
%set ~LET
`CreateBuiltinFunction$A( `set＠#js-observable-array-set§jp の手続き, « », %~realm )
◎
Let set be CreateBuiltinFunction(the steps from § 3.10.8 set, « », realm).
</li>
	<li>
~NOABRUPT `CreateDataPropertyOrThrow$A( %~handler, `set^l, %set )
◎
Perform ! CreateDataPropertyOrThrow(handler, "set", set).
</li>
	<li>
~RET
~NOABRUPT `ProxyCreate$A( %内縁~配列, %~handler )
◎
Return ! ProxyCreate(innerArray, handler).
</li>
</ol>
</div>

			<section id="js-observable-array-defineProperty">
<h4 title="defineProperty">3.10.1. `defineProperty^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `defineProperty^jp ~proxy~trap用の手続きは、
所与の
( %O, %P, %記述子~obj )
に対し，次に従う：
◎
The steps for the defineProperty proxy trap for observable array exotic objects, given O, P, and descriptorObj are as follows:
</p>
<ol>
	<li id="cp-let-handler-this-value">
%~handler ~LET `this^jv 値
◎
Let handler be the this value.
</li>
	<li>
%記述子 ~LET
~NOABRUPT `ToPropertyDescriptor$A( %記述子~obj )
◎
Let descriptor be ! ToPropertyDescriptor(descriptorObj).
</li>
	<li>
<p>
~IF［
%P ~EQ `length^l
］：
◎
If P is "length", then:
</p>
		<ol>
			<li>
~IF［
`IsAccessorDescriptor$A( %記述子 ) ~EQ `true^jv
］
⇒
~RET `false^jv
◎
If IsAccessorDescriptor(descriptor) is true, then return false.
</li>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
%記述子.`Configurable^sl は在って, その値 ~EQ `true^jv
</li>
					<li>
%記述子.`Enumerable^sl は在って, その値 ~EQ `true^jv
</li>
					<li>
%記述子.`Writable^sl は在って, その値 ~EQ `false^jv
</li>
				</ul>

<p>
…ならば
⇒
~RET `false^jv
</p>
◎
If descriptor.[[Configurable]] is present and has the value true, then return false.
◎
If descriptor.[[Enumerable]] is present and has the value true, then return false.
◎
If descriptor.[[Writable]] is present and has the value false, then return false.
</li>
			<li>
~IF［
%記述子.`Value^sl は在る
］
⇒
~RET `観測-可能な配列~exotic~objの長さを設定する$( %~handler, %記述子.`Value^sl )
◎
If descriptor.[[Value]] is present, then return the result of setting the length given handler and descriptor.[[Value]].
</li>
			<!--cp-return-true-->
		</ol>
	</li>
	<li>
<p id="cp-if-P-is-array-index">
~IF［
%P は`配列~indexで$ある
］：
◎
If P is an array index, then:
</p>
		<ol>
			<li>
~IF［
`IsAccessorDescriptor$A( %記述子 ) ~EQ `true^jv
］
⇒
~RET `false^jv
◎
If IsAccessorDescriptor(descriptor) is true, then return false.
</li>
			<li>
<p>
~IF［
~OR↓
］…
</p>
				<ul>
					<li>
%記述子.`Configurable^sl は在って, その値 ~EQ `false^jv
</li>
					<li>
%記述子.`Enumerable^sl は在って, その値 ~EQ `false^jv
</li>
					<li>
%記述子.`Writable^sl は在って, その値 ~EQ `false^jv
</li>
				</ul>

<p>
…ならば
⇒
~RET `false^jv
</p>
◎
If descriptor.[[Configurable]] is present and has the value false, then return false.
◎
If descriptor.[[Enumerable]] is present and has the value false, then return false.
◎
If descriptor.[[Writable]] is present and has the value false, then return false.
</li>
			<li>
~IF［
%記述子.`Value^sl は在る
］
⇒
~RET `観測-可能な配列~exotic~objの有index値を設定する$( %~handler, %P, %記述子.`Value^sl )
◎
If descriptor.[[Value]] is present, then return the result of setting the indexed value given handler, P, and descriptor.[[Value]].
</li>
			<!--cp-return-true-->
		</ol>
	</li>
	<li>
~RET
~ABRUPT %O.`DefineOwnProperty^sl( %P, %記述子 )
◎
Return ? O.[[DefineOwnProperty]](P, descriptor).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-deleteProperty">
<h4 title="deleteProperty">3.10.2. `deleteProperty^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `deleteProperty^jp ~proxy~trap用の手続きは、
所与の
( %O, %P )
に対し，次に従う：
◎
The steps for the deleteProperty proxy trap for observable array exotic objects, given O and P, are as follows:
</p>
<ol>
	<!--cp-let-handler-this-value-->
	<li>
~IF［
%P ~EQ `length^l
］
⇒
~RET `false^jv
◎
If P is "length", then return false.
</li>
	<li>
<!--cp-if-P-is-array-index-->
		<ol>
			<li id="cp-let-oldLen-BackingList-size">
%旧-長さ ~LET %~handler.`BackingList^sl の`~size$
◎
Let oldLen be handler.[[BackingList]]'s size.
</li>
			<li id="cp-let-index-ToUint32-P">
%~index ~LET
~NOABRUPT `ToUint32$A( %P )
◎
Let index be ! ToUint32(P).
</li>
			<li>
~IF［
%~index ~NEQ %旧-長さ ~MINUS 1
］
⇒
~RET `false^jv
◎
If index ≠ oldLen − 1, then return false.
</li>
			<li>
%~handler.`DeleteAlgorithm^sl( %~handler.`BackingList^sl[ %~index ], %~index )
◎
Perform the algorithm steps given by handler.[[DeleteAlgorithm]], given handler.[[BackingList]][index] and index.
</li>
			<li>
%~handler.`BackingList^sl から最後の~itemを`除去する$
◎
Remove the last item from handler.[[BackingList]].
</li>
			<!--cp-return-true-->
		</ol>
	</li>
	<li>
~RET
~ABRUPT %O.`Delete^sl( %P )
◎
Return ? O.[[Delete]](P).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-get">
<h4 title="get">3.10.3. `get^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `get^jp ~proxy~trap用の手続きは、
所与の
( %O, %P, %Receiver )
に対し，次に従う：
◎
The steps for the get proxy trap for observable array exotic objects, given O, P, and Receiver, are as follows:
</p>
<ol>
	<!--cp-let-handler-this-value-->
	<li id="cp-let-length-BackingList-size">
%長さ ~LET %~handler.`BackingList^sl の`~size$
◎
Let length be handler.[[BackingList]]'s size.
</li>
	<li>
~IF［
%P ~EQ `length^l
］
⇒
~RET %長さ
◎
If P is "length", then return length.
</li>
	<li>
<!--cp-if-P-is-array-index-->
		<ol>
			<!--cp-let-index-ToUint32-P-->
			<li>
~IF［
%~index ~GTE %長さ
］
⇒
~RET `undefined^jv
◎
If index ≥ length, then return undefined.
</li>
			<li>
%~js値 ~LET `~JS値に変換する$( %~handler.`BackingList^sl[ %~index ] )
◎
Let jsValue be the result of converting handler.[[BackingList]][index] to a JavaScript value.
</li>
			<li>
~Assert：
前~段が例外を投出することは決してない
◎
Assert: the above step never throws an exception.
</li>
			<li>
~RET %~js値
◎
Return jsValue.
</li>
		</ol>
	</li>
	<li>
~RET
~ABRUPT %O.`Get^sl( %P, %Receiver )
◎
Return ? O.[[Get]](P, Receiver).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-getOwnPropertyDescriptor">
<h4 title="getOwnPropertyDescriptor">3.10.4. `getOwnPropertyDescriptor^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `getOwnPropertyDescriptor^jp ~proxy~trap用の手続きは、
所与の
( %O, %P )
に対し，次に従う：
◎
The steps for the getOwnPropertyDescriptor proxy trap for observable array exotic objects, given O and P, are as follows:
</p>
<ol>
	<!--cp-let-handler-this-value-->
	<!--cp-let-length-BackingList-size-->
	<li>
~IF［
%P ~EQ `length^l
］
⇒
~RET
~NOABRUPT【！余計？】 `FromPropertyDescriptor$A( `TFF-長さ^desc )
◎
If P is "length", then return ! FromPropertyDescriptor(PropertyDescriptor{[[Configurable]]: false, [[Enumerable]]: false, [[Writable]]: true, [[Value]]: length }).
</li>
	<li>
<!--cp-if-P-is-array-index-->
		<ol>
			<!--cp-let-index-ToUint32-P-->
			<li>
~IF［
%~index ~GTE %長さ
］
⇒
~RET `undefined^jv
◎
If index ≥ length, then return undefined.
</li>
			<li>
%~js値 ~LET `~JS値に変換する$( %~handler.`BackingList^sl[ %~index ] )
◎
Let jsValue be the result of converting handler.[[BackingList]][index] to a JavaScript value.
</li>
			<li>
~Assert：
前~段が例外を投出することは決してない
◎
Assert: the above step never throws an exception.
</li>
			<li>
~RET
`FromPropertyDescriptor$A( `TTT-~js値^desc )
◎
Return FromPropertyDescriptor(PropertyDescriptor{[[Configurable]]: true, [[Enumerable]]: true, [[Writable]]: true, [[Value]]: jsValue }).
</li>
		</ol>
	</li>
	<li>
~RET
`FromPropertyDescriptor$A( ~ABRUPT %O.`GetOwnProperty^sl( %P ) )
◎
Return FromPropertyDescriptor(? O.[[GetOwnProperty]](P)).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-has">
<h4 title="has">3.10.5. `has^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `has^jp ~proxy~trap用の手続きは、
所与の
( %O, %P )
に対し，次に従う：
◎
The steps for the has proxy trap for observable array exotic objects, given O and P, are as follows:
</p>
<ol>
	<!--cp-let-handler-this-value-->
	<li>
~IF［
%P ~EQ `length^l
］
⇒
~RET `true^jv
◎
If P is "length", then return true.
</li>
	<li>
<!--cp-if-P-is-array-index-->
		<ol>
			<!--cp-let-index-ToUint32-P-->
			<li>
~IF［
%~index ~LT %~handler.`BackingList^sl の`~size$
］
⇒
~RET `true^jv
◎
If index &lt; handler.[[BackingList]]'s size, then return true.
</li>
			<!--cp-return-false-->
		</ol>
	</li>
	<li>
~RET
~ABRUPT %O.`HasProperty^sl( %P )
◎
Return ? O.[[HasProperty]](P).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-ownKeys">
<h4 title="ownKeys">3.10.6. `ownKeys^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `ownKeys^jp ~proxy~trap用の手続きは、
所与の
( %O )
に対し，次に従う：
◎
The steps for the ownKeys proxy trap for observable array exotic objects, given O, are as follows:
</p>
<ol>
	<!--cp-let-handler-this-value-->
	<!--cp-let-length-BackingList-size-->
	<li>
%~key群 ~LET 空`~list$
◎
Let keys be an empty list.
</li>
	<li>
~EACH( %i ~IN { 0 〜 %長さ ~MINUS 1 } )
に対し，昇順に
⇒
%~key群 に次の結果を`付加する$
⇒
~NOABRUPT `ToString$A( %i )
◎
Let i be 0.
◎
While i &lt; length:
• Append ! ToString(i) to keys.
• Set i to i + 1.
</li>
	<li>
%~key群 を次の結果で`拡張する$
⇒
~NOABRUPT %O.`OwnPropertyKeys^sl() 
◎
Extend keys with ! O.[[OwnPropertyKeys]]().
</li>
	<li>
~RET
`CreateArrayFromList$A( %~key群 )
◎
Return CreateArrayFromList(keys).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-preventExtensions">
<h4 title="preventExtensions">3.10.7. `preventExtensions^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `preventExtensions^jp ~proxy~trap用の手続きは、
次に従う：
◎
The steps for the preventExtensions proxy trap for observable array exotic objects are as follows:
</p>
<ol>
	<!--cp-return-false-->
</ol>
</div>

			</section>
			<section id="js-observable-array-set">
<h4 title="set">3.10.8. `set^jp</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~obj$用の `set^jp ~proxy~trap用の手続きは、
所与の
( %O, %P, %V, %Receiver )
に対し，次に従う：
◎
The steps for the set proxy trap for observable array exotic objects, given O, P, V, and Receiver, are as follows:
</p>
<ol>
	<!--cp-let-handler-this-value-->
	<li>
~IF［
%P ~EQ `length^l
］
⇒
~RET `観測-可能な配列~exotic~objの長さを設定する$( %~handler, %V )
◎
If P is "length", then return the result of setting the length given handler and V.
</li>
	<li>
~IF［
%P は`配列~indexで$ある
］
⇒
~RET `観測-可能な配列~exotic~objの有index値を設定する$( %~handler, %P, %V )
◎
If P is an array index, then return the result of setting the indexed value given handler, P, and V.
</li>
	<li>
~RET
~ABRUPT %O.`Set^sl( %P, %V, %Receiver )
◎
Return ? O.[[Set]](P, V, Receiver).
</li>
</ol>
</div>

			</section>
			<section id="js-observable-array-abstract-operations">
<h4 title="Abstract operations">3.10.9. 抽象-演算</h4>

<div class="algo">
<p>
`観測-可能な配列~exotic~objの長さを設定する@
~algoは、
所与の
( %~handler, %新-長さ )
に対し：
◎
To set the length of an observable array exotic object given handler and newLen:
</p>
<ol>
	<li>
%uint32長さ ~LET
~ABRUPT `ToUint32$A( %新-長さ )
◎
Let uint32Len be ? ToUint32(newLen).
</li>
	<li>
%number長さ ~LET
~ABRUPT `ToNumber$A( %新-長さ )
◎
Let numberLen be ? ToNumber(newLen).
</li>
	<li>
~IF［
%uint32長さ ~NEQ %number長さ
］
⇒
~THROW `RangeError$jE
◎
If uint32Len ≠ numberLen, then throw a RangeError exception.
</li>
	<!--cp-let-oldLen-BackingList-size-->
	<li>
~IF［
%uint32長さ ~GT %旧-長さ
］
⇒
~RET `false^jv
◎
If uint32Len &gt; oldLen, then return false.
</li>
	<li>
%削除する~index ~LET %旧-長さ ~MINUS 1
◎
Let indexToDelete be oldLen − 1.
</li>
	<li>
<p>
~WHILE［
%削除する~index ~GTE %uint32長さ
］：
◎
While indexToDelete ≥ uint32Len:
</p>
		<ol>
			<li>
%~handler.`DeleteAlgorithm^sl( %~handler.`BackingList^sl[ %削除する~index ], %削除する~index )
◎
Perform the algorithm steps given by handler.[[DeleteAlgorithm]], given handler.[[BackingList]][indexToDelete] and indexToDelete.
</li>
			<li>
%~handler.`BackingList^sl から最後の~itemを`除去する$
◎
Remove the last item from handler.[[BackingList]].
</li>
			<li>
%削除する~index ~DECBY 1
◎
Set indexToDelete to indexToDelete − 1.
</li>
		</ol>
	</li>
	<li>
~RET `true^jv
◎
Return true.
</li>

</ol>
</div>

<div class="algo">
<p>
`観測-可能な配列~exotic~objの有index値を設定する@
~algoは、
所与の
( %~handler, %P, %V )
に対し：
◎
To set the indexed value of an observable array exotic object given handler, P, and V:
</p>
<ol>
	<!--cp-let-oldLen-BackingList-size-->
	<!--cp-let-index-ToUint32-P-->
	<li>
~IF［
%~index ~GT %旧-長さ
］
⇒
~RET `false^jv
◎
If index &gt; oldLen, return false.
</li>
	<li>
%~idl値 ~LET `~IDL値に変換する$( %V, %~handler.`Type^sl )
◎
Let idlValue be the result of converting V to the type given by handler.[[Type]].
</li>
	<li>
<p>
~IF［
%~index ~LT %旧-長さ
］：
◎
If index &lt; oldLen, then:
</p>
		<ol>
			<li>
%~handler.`DeleteAlgorithm^sl( %~handler.`BackingList^sl[ %~index ], %~index )
◎
Perform the algorithm steps given by handler.[[DeleteAlgorithm]], given handler.[[BackingList]][index] and index.
</li>
		</ol>
	</li>
	<li>
%~handler.`SetAlgorithm^sl( %~idl値, %~index )
◎
Perform the algorithm steps given by handler.[[SetAlgorithm]], given idlValue and index.
</li>
	<li>
~IF［
%~index ~EQ %旧-長さ
］
⇒
%~handler.`BackingList^sl に %~idl値 を`付加する$
◎
If index = oldLen, then append idlValue to handler.[[BackingList]].
</li>
	<li>
~ELSE
⇒
%~handler.`BackingList^sl[ %~index ] ~SET %~idl値
◎
Otherwise, set handler.[[BackingList]][index] to idlValue.
</li>
	<!--cp-return-true-->
</ol>
</div>

			</section>
		</section>
		<section id="js-user-objects">
<h3 title="Callback interfaces">3.11. ~callback~ifc</h3>

<p>
`~ifcを実装している~obj＠~WEBIDL#idl-objects§にて述べたとおり、
`~callback~ifc$は，~script内の どの~JS~objも実装できる。
所与の~obj上で`~callback~ifc$の`演算$がどう呼出されるかを，以下の場合分けで説明する：
◎
As described in § 2.12 Objects implementing interfaces, callback interfaces can be implemented in script by any JavaScript object. The following cases explain how a callback interface’s operation is invoked on a given object:
</p>

<ul>
	<li>
%O は`~callable$な場合、
その演算の実装は， %O 自身になる。
◎
If the object is callable, then the implementation of the operation is the callable object itself.
</li>
	<li>
他の場合、
その演算の実装は，次を~callすることである
⇒
その演算の`識別子$を~prop名として，
%O の `Get^sl 内部~methodを呼出した結果
◎
Otherwise, the implementation of the operation is calling the result of invoking the internal [[Get]] method on the object with a property name that is the identifier of the operation.
</li>
</ul>

<p>
`~callback~ifc$に`定数$が宣言されていようが、［
~JS~objが それを実装していると見なされるためには、
そのような定数に対応する~propを有する必要がある
］わけではないことに注意。
◎
Note that JavaScript objects need not have properties corresponding to constants on them to be considered as implementing callback interfaces that happen to have constants declared on them.
</p>

<div class="algo">
<p>
`~scriptと~callbackを準備する@
~algoは、
所与の
( `~realm$ %~realm, `~callback~ifc型$の値 %値 )
に対し：
</p>
<ol>
	<li>
%関連な設定群 ~LET %~realm の`設定群~obj$
</li>
	<li>
%格納-済み設定群 ~LET %値 の`~callback文脈$
</li>
	<li>
`~scriptを走らすために準備する$( %関連な設定群 )
</li>
	<li>
`~callbackを走らすために準備する$( %格納-済み設定群 )
</li>
	<li>
~RET ( %関連な設定群, %格納-済み設定群 )
</li>
</ol>

<p class="trans-note">【
この手続きは、
以下に定義される各~手続きに共通な記述を集約するために，
この訳にて導入したものである。
】</p>

◎
• Let relevant settings be realm’s settings object.
• Let stored settings be XXX’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</div>

<p>
`~Web~IDL引数~list@
は、
`~list$であり，それを成す各~itemは［
ある~IDL値
］または［
与えられなかった随意~引数~用の特別な値
`missing@C
］を与える。
◎
A Web IDL arguments list is a list of values each of which is either an IDL value or the special value “missing”, which represents a missing optional argument.
</p>

<div class="algo">
<p>
`~JS引数~listに変換する@
~algoは、
所与の
( `~Web~IDL引数~list$ %~idl引数~群 )
に対し：
◎
To convert a Web IDL arguments list to a JavaScript arguments list, given a Web IDL arguments list args, perform the following steps:
</p>
<ol>
	<li>
%~js引数~群 ~LET 空`~list$
◎
Let jsArgs be an empty list.
</li>
	<li>
%i ~LET 0
◎
Let i be 0.
</li>
	<li>
%個数 ~LET 0
◎
Let count be 0.
</li>
	<li>
<p>
%~idl引数~群 を成す
~EACH( %~idl引数 )
に対し：
◎
While i &lt; args’s size:
</p>
		<ol>
			<li>
~IF［
%~idl引数 ~EQ `missing$C
］
⇒
%~js引数~群 に `undefined^jv を`付加する$
◎
If args[i] is the special value “missing”, then append undefined to jsArgs.
</li>
			<li>
<p>
~ELSE（ %~idl引数 は~IDL値である）：
◎
Otherwise, args[i] is an IDL value:
</p>
				<ol>
					<li>
%変換-結果 ~LET `~JS値に変換する$( %~idl引数 )
— 例外は投出し直す
◎
Let convertResult be the result of converting args[i] to a JavaScript value. Rethrow any exceptions.
</li>
					<li>
%~js引数~群 に %変換-結果 を`付加する$
◎
Append convertResult to jsArgs.
</li>
					<li>
%個数 ~SET %i ~PLUS 1
◎
Set count to i + 1.
</li>
				</ol>
			</li>
			<li>
%i ~INCBY 1
◎
Set i to i + 1.
</li>
		</ol>
	</li>
	<li>
%~js引数~群 を %個数 個の~itemまでに切落す
◎
Truncate jsArgs to contain count items.
</li>
	<li>
~RET %~js引数~群
◎
Return jsArgs.
</li>
</ol>
</div>

<div class="algo">
<p>
`利用元~objの演算を~callする@
~algoは、
所与の
⇒＃
`~callback~ifc型$の値 %値,
演算~名 %演算~名,
`~Web~IDL引数~list$ %~idl引数~群,
`~callback this 値@ %~this引数 ~DF `undefined^jv
◎終
に対し，
~IDL値を返すか例外を投出する。
◎
To call a user object’s operation, given a callback interface type value value, operation name opName, Web IDL arguments list args, and optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</p>
<ol>
	<li>
%結果 ~LET ε
◎
Let completion be an uninitialized variable.
◎
↑ If thisArg was not given, let thisArg be undefined.
</li>
	<li>
%O ~LET %値 に対応している~JS~obj
◎
Let O be the JavaScript object corresponding to value.
</li>
	<li>
%~realm ~LET %O が`属する~realm$
◎
Let realm be O’s associated realm.
</li>
	<li>
( %関連な設定群, %格納-済み設定群 ) ~LET `~scriptと~callbackを準備する$( %~realm, %値 )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be value’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<li>
%T ~LET 当の演算の`返り値~型$
◎
↓</li>
	<li>
%X ~LET %O
◎
Let X be O.
</li>
	<li>
<p>
~IF［
`IsCallable$A( %O ) ~EQ ~F
］：
◎
If IsCallable(O) is false, then:
</p>
		<ol>
			<li>
%結果 ~SET
`Completion$A( `Get$A( %O, %演算~名 ) )
◎
Let getResult be Completion(Get(O, opName)).
</li>
			<li>
~IF［
%結果 は`中途完了$である
］
⇒
~GOTO `最後の段^i
◎
If getResult is an abrupt completion, set completion to getResult and jump to the step labeled return.
</li>
			<li>
<p>
~IF［
`IsCallable$A( %結果.`Value^sl ) ~EQ ~F
］：
◎
Set X to getResult.[[Value]].
◎
If IsCallable(X) is false, then＼
</p>
				<ol>
					<li>
%結果 ~SET 新たな`完了~Record＠~TC39#sec-completion-record-specification-type$ {
`Type^sl: `throw^i,
`Value^sl: 新たな `TypeError^jE ~obj,
`Target^sl: 空
}
◎
set completion to Completion Record { [[Type]]: throw, [[Value]]: a newly created TypeError object, [[Target]]: empty }, and＼
</li>
					<li>
~GOTO `最後の段^i
◎
jump to the step labeled return.
</li>
				</ol>
			</li>
			<li>
%~this引数 ~SET %O
（供された値を上書きする）
◎
Set thisArg to O (overriding the provided value).
</li>
		</ol>
	</li>
	<li id="cp-convert-to-js-args">
<p>
%~js引数~群 ~LET `~JS引数~listに変換する$( %~idl引数~群 )
◎
Let jsArgs be the result of converting args to a JavaScript arguments list.＼
</p>

<p>
~IF［
変換-時に例外が投出された
］
⇒＃
%結果 ~SET その例外を表現している`中途完了$【！completion value】
~GOTO `最後の段^i
◎
If this throws an exception, set completion to the completion value representing the thrown exception and jump to the step labeled return.
</p>
	</li>
	<li>
%結果 ~SET `Completion$A( `Call$A( %X, %~this引数, %~js引数~群 ) )
◎
Let callResult be Completion(Call(X, thisArg, jsArgs)).
</li>
	<li id="cp-callResult-is-abrupt">
~IF［
%結果 は`中途完了$である
］
⇒
~GOTO `最後の段^i
◎
If callResult is an abrupt completion, set completion to callResult and jump to the step labeled return.
</li>
	<li>
<div id="cp-set-completion-callResult">
<p>
%結果 ~SET `~IDL値に変換する$( %結果.`Value^sl, %T )
</p>

<p>
~IF［
変換-時に例外が投出された
］
⇒
%結果 ~SET その例外を表現している`中途完了$【！completion value】；
</p>
</div>
◎
Set completion to the result of converting callResult.[[Value]] to an IDL value of the same type as the operation’s return type. If this throws an exception, set completion to the completion value representing the thrown exception.
</li>
	<li>
<p id="call-user-object-operation-return">
`最後の段^i：
◎
Return:＼
</p>
		<ol>
			<li id="cp-is-IDL-value-or-abrupt">
~Assert：
%結果 は［
~IDL値／`中途完了$
］である
◎
at this point completion will be set to an IDL value or an abrupt completion.
</li>

			<li id="cp-cleanup-callback">
`走らせた~callbackを片付ける$( %格納-済み設定群 )
◎
Clean up after running a callback with stored settings.
</li>
			<li id="cp-cleanup-script">
`走らせた~scriptを片付ける$( %関連な設定群 )
◎
Clean up after running script with relevant settings.
</li>
			<li>
~IF［
%結果 は~IDL値である
］
⇒
~RET %結果
◎
If completion is an IDL value, return completion.
</li>
			<li>
%値 ~LET %結果.`Value^sl
◎
↓</li>
			<li>
~IF［
%T は`~promise型$でない
］
⇒
`~THROW$ %値
◎
If completion is an abrupt completion and the operation has a return type that is not a promise type, throw completion.[[Value]].
</li>
			<li>
%却下される~promise ~LET
~NOABRUPT `Call$A( `Promise.reject$jI, `Promise$jI, « %値 » )
◎
Let rejectedPromise be ! Call(%Promise.reject%, %Promise%, «completion.[[Value]]»).
</li>
			<li>
~RET `~IDL値に変換する$( %却下される~promise, %T )
◎
Return the result of converting rejectedPromise to the operation’s return type.
</li>
		</ol>
	</li>
</ol>
</div>

			<section id="legacy-callback-interface-object">
<h4 title="Legacy callback interface object">3.11.1. 旧来の~callback~ifc~obj</h4>

<p>
所与の`~realm$ %R 内に`公開されて$いる どの`~callback~ifc$ %I に対しても、
%I 上に`定数$が定義されているならば，
%R の`大域~obj$上に，対応する 次の特性を伴う~propが存在する：
◎
For every callback interface that is exposed in a given realm and on which constants are defined, a corresponding property exists on the realm’s global object.＼
</p>
<ul>
	<li>
名前：
%I の`識別子$
◎
The name of the property is the identifier of the callback interface, and＼
</li>
	<li>
値：
`旧来の~callback~ifc~obj@
と呼ばれる~obj。
これは、
`組込みの関数~obj$であり，
%I 上に定義される各`定数$に対し
— 下の`定数＠#js-constants§にて述べるとおり —
対応する~propを有する。
◎
its value is an object called the legacy callback interface object.
◎
The legacy callback interface object for a given callback interface is a built-in function object. It has properties that correspond to the constants defined on that interface, as described in sections § 3.7.5 Constants.
</li>
</ul>

<p class="note">注記：
`旧来の~callback~ifc~obj$は `関数~obj$なので、
`typeof^op 演算子が適用されたときは， "`function^jv" を返すことになる。
◎
Note: Since a legacy callback interface object is a function object the typeof operator will return "function" when applied to a legacy callback interface object.
</p>

<div class="algo">
<p>
`~callback~ifc$用の`旧来の~callback~ifc~obj$は、
以下に従って作成される
—
`旧来の~callback~ifc~objを作成する@
~algoは、
所与の
( `~callback~ifc$ %I, `識別子$ %識別子, `~realm$ %~realm )
に対し：
◎
The legacy callback interface object for a given callback interface interface with identifier id and in realm realm is created as follows:
</p>
<ol>
	<li class="algo">
<p>
%手続き ~LET 次に与える手続き：
◎
Let steps be the following steps:
</p>
		<ol>
			<!--cp-throw-typeerror-->
		</ol>
	</li>
	<!--cp-CreateBuiltinFunction-->
	<!--cp-SetFunctionName-F-id-->
	<!--cp-SetFunctionLength-F-0-->
	<li>
`定数を定義する$( %I, %F, %~realm )
◎
Define the constants of interface on F given realm.
</li>
	<!--cp-ret-F-->
</ol>
</div>

			</section>
		</section>
		<section id="js-invoking-callback-functions">
<h3 title="Invoking callback functions">3.12. ~callback関数の呼出ng</h3>

<p>
`~callback関数$値として利用されている`~callable$な~JS~objは、
（前~節【の`利用元~objの演算を~callする$】にて述べたとおり）
`~callback~ifc$の`演算$と類似な方式で~callされる。
◎
A JavaScript callable object that is being used as a callback function value is called in a manner similar to how operations on callback interface values are called (as described in the previous section).
</p>

<div class="algo">
<p>
`~callback関数を呼出す@
~algoは、
所与の
⇒＃
`~callback関数~型$の値 %~callable,
`~Web~IDL引数~list$ %~idl引数~群,
%例外の挙動 ~IN { `報告する^i, `投出し直す^i, ε },
`~callback this 値$ %~this引数 ~DF `undefined^jv
◎終
に対し，~IDL値を返すか例外を投出する：
◎
To invoke a callback function type value callable with a Web IDL arguments list args, exception behavior exceptionBehavior (either "report" or "rethrow"), and an optional callback this value thisArg, perform the following steps. These steps will either return an IDL value or throw an exception.
</p>

<ol>
	<li>
%T ~LET %~callable の`返り値~型$
◎
↓</li>
	<li>
<p>
~Assert：
%例外の挙動 は %T に応じて
⇒＃
`~promise型$であるならば ε ／
`undefined$T ならば ε 以外 ／
`any$T ならば ε 以外 ／
~ELSE_ `投出し直す^i
◎
The exceptionBehavior argument must be supplied if, and only if, callable’s return type is not a promise type. If callable’s return type is neither undefined nor any, it must be "rethrow".
</p>

<p class="XXX">
この~algoを~callする他の仕様のうち，
新たに追加された引数 %例外の挙動 をまだ織り込んでないものは、
%T は`~promise型$でない場合には，
`投出し直す^i を給しているものと解するべきである。
◎
Until call sites are updated to respect this, specifications which fail to provide a value here when it would be mandatory should be understood as supplying "rethrow".
</p>

<p class="trans-note">【
%例外の挙動 用の値 ε は，
原文では “給されない” という句で表現されるが
（すなわち、
`~promise型$の事例では，この引数は省略して~callされる）、
~call元において，そのこと
— および、
この引数を織り込むよう更新されたか否か —
を明瞭にするため、
この訳では，明示的に ε で表現することにする
（すなわち、
この引数は，その事例でも省略可能でないものと見做す）。
】</p>
	</li>
	<li>
%結果 ~LET ε
◎
Let completion be an uninitialized variable.
◎
↑ If thisArg was not given, let thisArg be undefined.
</li>
	<li id="cp-let-F-callable">
%F ~LET %~callable に対応している~JS~obj
◎
Let F be the JavaScript object corresponding to callable.
</li>
	<li>
<p>
~IF［
`IsCallable$A( %F ) ~EQ ~F
］
⇒
~RET `~IDL値に変換する$( `undefined^jv, %T )
</p>

<p class="note">注記：
これがアリになるのは、
%T に `LegacyTreatNonObjectAsNull$x 拡張d属性が伴われていた【！the callback function came from an attribute marked with】場合に限られる。
</p>
◎
If IsCallable(F) is false:
• Note: This is only possible when the callback function came from an attribute marked with [LegacyTreatNonObjectAsNull].
• Return the result of converting undefined to the callback function’s return type.
</li>
	<li id="cp-let-realm-F-realm">
%~realm ~LET %F が`属する~realm$
◎
Let realm be F’s associated realm.
</li>
	<li id="cp-prepare-script-callback">
( %関連な設定群, %格納-済み設定群 ) ~LET `~scriptと~callbackを準備する$( %~realm, %~callable )
◎
• Let relevant settings be realm’s settings object.
• Let stored settings be callable’s callback context.
• Prepare to run script with relevant settings.
• Prepare to run a callback with stored settings.
</li>
	<!--cp-convert-to-js-args-->
	<li>
%結果 ~SET `Completion$A( `Call$A( %F, %~this引数, %~js引数~群 ) )
◎
Let callResult be Completion(Call(F, thisArg, jsArgs)).
</li>
	<!--cp-callResult-is-abrupt-->
	<li>
<!--cp-set-completion-callResult-->
◎
Set completion to the result of converting callResult.[[Value]] to an IDL value of the same type as callable’s return type. If this throws an exception, set completion to the completion value representing the thrown exception.
</li>
	<li>
<p id="invoke-return">
`最後の段^i：
◎
Return:＼
</p>
		<ol>
			<!--cp-is-IDL-value-or-abrupt-->
			<!--cp-cleanup-callback-->
			<!--cp-cleanup-script-->
			<li>
~IF［
%結果 は~IDL値である
］
⇒
~RET %結果
◎
If completion is an IDL value, return completion.
</li>
			<li>
%値 ~LET %結果.`Value^sl
◎
↑ Assert: completion is an abrupt completion.
◎
↓</li>
			<li>
~IF［
%例外の挙動 ~EQ `投出し直す^i
］
⇒
~THROW %値
◎
If exceptionBehavior is "rethrow", throw completion.[[Value]].
</li>
			<li>
<p>
~ELIF［
%例外の挙動 ~EQ `報告する^i
］：
◎
Otherwise, if exceptionBehavior is "report":
</p>
				<ol>
					<li>
~Assert：
%~callable の`返り値~型$ ~IN { `undefined$T, `any$T }
◎
Assert: callable’s return type is undefined or any.
</li>
					<li>
`例外を報告する$( %値, %~realm の`大域~obj$ )
◎
Report an exception completion.[[Value]] for realm’s global object.
</li>
					<li>
~RET 一意な `undefined$T ~IDL値
◎
Return the unique undefined IDL value.
</li>
				</ol>
			</li>
			<li>
~Assert：
%T は`~promise型$である
◎
Assert: callable’s return type is a promise type.
</li>
			<li>
%却下される~promise ~LET
~NOABRUPT `Call$A( `Promise.reject$jI, `Promise$jI, « %値 » )
◎
Let rejectedPromise be ! Call(%Promise.reject%, %Promise%, «completion.[[Value]]»).
</li>
			<li>
~RET `~IDL値に変換する$( %却下される~promise, %T )
◎
Return the result of converting rejectedPromise to the callback function’s return type.
</li>
		</ol>
	</li>
</ol>
</div>

<p>
~callback関数には、
`構築子$として利用できるものもある。
そのような~callback関数の返り値~型は`~promise型$になってはナラナイ。
◎
Some callback functions are instead used as constructors. Such callback functions must not have a return type that is a promise type.
</p>

<div class="algo">
<p>
`~callback関数で構築する@
~algoは、
所与の
⇒＃
`~callback関数~型$の値 %~callable,
`~Web~IDL引数~list$ %~idl引数~群
◎終
に対し，~IDL値を返すか例外を投出する：
◎
To construct a callback function type value callable with a Web IDL arguments list args, perform the following steps. These steps will either return an IDL value or throw an exception.
</p>
<ol>
	<li>
%結果 ~LET ε
◎
Let completion be an uninitialized variable.
</li>
	<!--cp-let-F-callable-->
	<li>
~IF［
`IsConstructor$A( %F ) ~EQ `false^jv
］
⇒
`~THROW$ `TypeError$jt
◎
If IsConstructor(F) is false, throw a TypeError exception.
</li>
	<!--cp-let-realm-F-realm-->
	<li>
%T ~LET 当の~callback関数の返り値~型
◎
↓</li>
	<!--cp-prepare-script-callback-->
	<!--cp-convert-to-js-args-->
	<li>
%結果 ~LET `Completion$A( `Construct$A( %F, %~js引数~群 ) )
◎
Let callResult be Completion(Construct(F, jsArgs)).
</li>
	<!--cp-callResult-is-abrupt-->
	<li>
<!--cp-set-completion-callResult-->
◎
Set completion to the result of converting callResult.[[Value]] to an IDL value of the same type as callable’s return type. If this throws an exception, set completion to the completion value representing the thrown exception.
</li>
	<li>
<p id="construct-return">
`最後の段^i：
◎
Return:＼
</p>
		<ol>
			<!--cp-is-IDL-value-or-abrupt-->
			<!--cp-cleanup-callback-->
			<!--cp-cleanup-script-->
			<li>
~IF［
%結果 は`中途完了$である
］
⇒
`~THROW$ %結果.`Value^sl
◎
If completion is an abrupt completion, throw completion.[[Value]].
</li>
			<li>
~RET %結果
◎
Return completion.
</li>
		</ol>
	</li>
</ol>
</div>

		</section>
		<section id="js-namespaces">
<h3 title="Namespaces">3.13. ~ns</h3>

<p>
所与の`~realm$ %R 内に`公開されて$いる どの`~ns$ %~ns に対しても、
%R の`大域~obj$上に，対応する 次の特性を伴う~propが存在する：
◎
For every namespace that is exposed in a given realm, a corresponding property exists on the realm’s global object.＼
</p>
<ul>
	<li>
名前：
%~ns の`識別子$
◎
The name of the property is the identifier of the namespace, and＼
</li>
	<li>
値：
`~ns~obj@
と呼ばれる~obj
— 詳細は、
`~ns~obj＠#namespace-object§に述べる。
◎
its value is an object called the namespace object.
◎
The characteristics of a namespace object are described in § 3.13.1 Namespace object.
</li>
</ul>

			<section id="namespace-object">
<h4 title="Namespace object">3.13.1. ~ns~obj</h4>

<div class="algo">
<p>
`~ns~objを作成する@
~algoは、
所与の
( `~ns$ %~ns, `~realm$ %~realm )
に対し：
◎
The namespace object for a given namespace namespace and realm realm is created as follows:
</p>
<ol>
 	<li>
%~ns~obj ~LET
`OrdinaryObjectCreate$A( %~realm.`Object.prototype$jIsl )
◎
Let namespaceObject be OrdinaryObjectCreate(realm.[[Intrinsics]].[[%Object.prototype%]]).
</li>
	<li>
`正則~属性を定義する$( %~ns, %~ns~obj, %~realm )
◎
Define the regular attributes of namespace on namespaceObject given realm.
</li>
	<li>
`正則~演算を定義する$( %~ns, %~ns~obj, %~realm )
◎
Define the regular operations of namespace on namespaceObject given realm.
</li>
	<li>
`定数を定義する$( %~ns, %~ns~obj, %~realm )
◎
Define the constants of namespace on namespaceObject given realm.
</li>
	<li>
%~ifc群 ~LET 次を満たす`~ifc$たちが成す集合
⇒
［
`公開されて$いる
］~AND［
%~ns の識別子を引数にとる `LegacyNamespace$x 拡張d属性を伴う
］
◎
For each exposed interface interface which has the [LegacyNamespace] extended attribute with the identifier of namespace as its argument,
</li>
	<li>
<p>
%~ifc群 を成す
~EACH( %~ifc )
に対し：
◎
↑</p>
		<ol>
			<!--cp-id-be-identifier-->
			<!--cp-create-interface-obj-->
			<li>
`DefineMethodProperty$A( %~ns~obj, %~ID, %~ifc~obj, `false^jv )
◎
Perform DefineMethodProperty(namespaceObject, id, interfaceObject, false).
</li>
		</ol>
	</li>
	<li>
~RET %~ns~obj
◎
Return namespaceObject.
</li>
</ol>
</div>

<p>
`~ns~obj$の`~class文字列$は、
当の`~ns$の`識別子$とする。
◎
The class string of a namespace object is the namespace’s identifier.
</p>

			</section>
		</section>
		<section id="js-exceptions">
<h3 title="Exceptions">3.14. 例外</h3>

			<section id="js-DOMException-specialness">
<h4 title="DOMException custom bindings">3.14.1. `DOMException^T ~custom言語束縛</h4>

<p>
~JS言語束縛における［
`DOMException$T 用の`~ifc原型~obj$
］の `Prototype^sl `内部~slot$は、
`~ifc原型~objを作成する$抽象-演算に定義されるとおりに，
内在的~obj `Error.prototype$jI に設定するモノトスル。
それは、
すべての組込みの例外と同様に，
`ErrorData^sl ~slotも有する。
◎
In the JavaScript binding, the interface prototype object for DOMException has its [[Prototype]] internal slot set to the intrinsic object %Error.prototype%, as defined in the create an interface prototype object abstract operation. It also has an [[ErrorData]] slot, like all built-in exceptions.
</p>

<p>
加えて，実装は、
~nativeな `Error$jt ~objに［
特別な力／標準でない~prop
］を与える場合（ `stack^jp ~propなど），
それらも `DOMException$T ~objに公開するべきである。
◎
Additionally, if an implementation gives native Error objects special powers or nonstandard properties (such as a stack property), it should also expose those on DOMException objects.
</p>

			</section>
			<section id="js-exception-objects">
<h4 title="Exception objects">3.14.2. 例外~obj</h4>

<p>
`単純~例外$は、
対応する型の~nativeな~JS~objにより表現される。
◎
Simple exceptions are represented by native JavaScript objects of the corresponding type.
</p>

<p>
`DOMException$T は、
`DOMException$T ~ifcを実装する`~platform~obj$により表現される。
◎
A DOMException is represented by a platform object that implements the DOMException interface.
</p>

			</section>
			<section id="js-creating-throwing-exceptions">
<h4 title="Creating and throwing exceptions">3.14.3. 例外の作成-法と投出-法</h4>

<div class="algo">
<p>
型 %T の`単純~例外$用に`例外を作成する$ときは：
◎
To create a simple exception of type T:
</p>
<ol>
	<li>
<p>
%~message ~LET 当の`例外~用の適切な~message$
◎
Let message be an implementation-defined message appropriate for the exceptional situation. The calling specification may contain information to to help implementations construct this message.
◎
Implementations need to be cautious not to leak sensitive or secured information when constructing this message, e.g., by including the URL of a cross-origin frame, or information which could identify the user.
</p>
	</li>
	<li>
%引数~群 ~LET « %~message »
◎
Let args be « message ».
</li>
	<li>
%構築子 ~LET `現在の~realm$ .`Intrinsics^sl.`<var>T</var>^jI
◎
Let constructor be current realm.[[Intrinsics]].[[%T%]].
</li>
	<li>
~RET ~NOABRUPT `Construct$A( %構築子, %引数~群 )
◎
Return ! Construct(constructor, args).
</li>
</ol>
</div>

<div class="algo">
<p>
`DOMException$T 用に`例外を作成する$ときは、
所与の
( 文字列 %名前 )
に対し：
◎
To create a DOMException given a string name:
</p>
<ol>
	<li>
~Assert：
%名前 は`~DOMException用の名前~表t$に現れる。
◎
Assert: name appears in the DOMException names table.
</li>
	<li>
%例外 ~LET `~ifcを実装する新たな~objを作成する$( `DOMException$T, `現在の~realm$ )
◎
Let ex be a new DOMException created in the current realm.
</li>
	<li>
%例外 の`名前$eX ~SET %名前
◎
Set ex’s name to name.
</li>
	<li>
%例外 の`~message$eX ~SET 当の`例外~用の適切な~message$
◎
Set ex’s message to an implementation-defined message appropriate for the exceptional situation. The calling specification may contain information to to help implementations construct this message.
◎
Implementations need to be cautious not to leak sensitive or secured information when constructing this message, e.g., by including the URL of a cross-origin frame, or information which could identify the user.
</li>
	<li>
~RET %例外
◎
Return ex.
</li>
</ol>
</div>

<div class="algo">
<p>
`DOMException$T 派生~ifc用に`例外を作成する$ときは、
所与の
( ある`~ifc$の`識別子$ %型, 追加的な初期化~用の指示書き )
に対し：
◎
To create a DOMException derived interface given the interface identifier type and additional initialization instructions:
</p>
<ol>
	<li>
%例外 ~LET `~ifcを実装する新たな~objを作成する$( %型 により識別される`~ifc$, `現在の~realm$ )
◎
Let ex be a new instance of the interface identified by type, created in the current realm.
</li>
	<li>
%例外 の`名前$eX ~SET %型
◎
Set ex’s name to type.
</li>
	<li>
%例外 の`~message$eX ~SET 当の`例外~用の適切な~message$
◎
Set ex’s message to an implementation-defined message appropriate for the exceptional situation. The calling specification may contain information to to help implementations construct this message.
◎
Implementations need to be cautious not to leak sensitive or secured information when constructing this message, e.g., by including the URL of a cross-origin frame, or information which could identify the user.
</li>
	<li>
%例外 に対する追加的な初期化を~call元にて述べられたとおりに遂行する
◎
Perform any additional initialization on ex as described by the caller.
</li>
	<li>
~RET %例外
◎
Return ex.
</li>
</ol>
</div>

<div class="algo">
<p>
`例外~用の適切な~message@
は、
当の例外的な状況~用に適切な`実装定義$な文字列を返す
— 各~仕様は、
`例外を作成する$ときに，実装がこの~messageを構築する助けになる情報を包含してもヨイ。
</p>

<p>
実装は、
この~messageを構築するときには，［
敏感な情報／~secure化された情報
］を漏洩しないよう用心深くなる必要がある
— 例えば，次を含まないよう
⇒＃
非同一-生成元に属する~frameの~URL／
利用者を識別し得るような情報
</p>
◎
↑↑</div>

<div class="algo">
<p>
`例外を投出する$ときは、
所与の
( `例外を作成する$ときに与えるものと同じ引数~群 )
に対し，次を走らす：
◎
To throw an exception:
</p>
<ol>
	<li>
%例外 ~LET `例外を作成する$( 引数~群 )
◎
Let O be the result of creating an exception with the same arguments.
</li>
	<li>
`~THROW$ %例外
◎
Throw O.
</li>
</ol>
</div>

<div class="note">
<p>注記：
上の~algoは、
`関数~obj$ %F から外へ伝播する
`例外を表現する~obj＠#js-exception-objects$を，
%F の`~realm$（すなわち， %F の実行-時における`現在の~realm$）に属するものに制約する。
例えば、
次の~IDLを考える：
◎
The above algorithms restrict objects representing exceptions propagating out of a function object to be ones that are associated with the realm of that function object (i.e., the current realm at the time the function executes). For example, consider the IDL:
</p>

<pre class="webidl">
[Exposed=Window]
interface MathUtils {
  /* <span class="comment">
%x は負ならば `NotSupportedError$E `DOMException$T を投出する。
◎
If x is negative, throws a "NotSupportedError" DOMException.
</span> */
  double computeSquareRoot(double %x);
};
</pre>

<p>
`computeSquareRoot()^M ~methodを異なる`~realm$に属する `MathUtils^T ~objに適用した場合、
投出される例外は，~objではなく~methodの`~realm$に属する：
◎
If we apply computeSquareRoot to a MathUtils object from a different realm, then the exception thrown will be from the realm of the method, not the object it is applied to:
</p>

<pre class="lang-js">
const %myMU = window.getMathUtils();          /* <span class="comment">
この~realmに属する `MathUtils^T
◎
A MathUtils object from this realm
</span> */
const %otherMU = %otherWindow.getMathUtils();  /* <span class="comment">
異なる~realmに属する `MathUtils^T
◎
A MathUtils object from a different realm
</span> */

%myMU instanceof Object;                      /* <!--cp-eval-true--> */
%otherMU instanceof Object;                   /* <!--cp-eval-false--> */
%otherMU instanceof %otherWindow.Object;       /* <!--cp-eval-true--> */

try {
  %otherMU.computeSquareRoot【！doComputation】.call(%myMU, -1);
} catch (%e) {
  console.assert(!(%e instanceof DOMException));
  console.assert(%e instanceof %otherWindow.DOMException);
}
</pre>
</div>

			</section>
			<section id="js-handling-exceptions">
<h4 title="Handling exceptions">3.14.4. 例外の取扱い</h4>

<p>
他が指定されない限り、
この文書の要件に因り~JS~runtime意味論が呼出され，例外が投出されて終了~したときは、
その例外は~call元まで（そこで~catchされない場合は更にその~call元まで，等々）伝播するモノトスル。
◎
Unless specified otherwise, whenever JavaScript runtime semantics are invoked due to requirements in this document and end due to an exception being thrown, that exception must propagate to the caller, and if not caught there, to its caller, and so on.
</p>

<p>
`表記規約＠~WEBIDL#conventions§により、
この文書に指定される~algoは，［
`例外が投出された@
ときにとる正確な手続きを指定する
］か［
`中途完了$を明示的に取扱う
］ことにより［
投出された例外を横取りする
］こともある。
◎
Per Document conventions, an algorithm specified in this document may intercept thrown exceptions, either by specifying the exact steps to take if an exception was thrown, or by explicitly handling abrupt completions.
</p>

<div class="example">
<p>
次の`~IDL片$は、
2 個の`~ifc$と 1 個の`例外$を定義する。
`ExceptionThrower^T の `valueOf^M 属性は、［
その値を取得するよう試みられたときは，常に例外を投出する
］よう定義されている。
◎
The following IDL fragment defines two interfaces and an exception. The valueOf attribute on ExceptionThrower is defined to throw an exception whenever an attempt is made to get its value.
</p>

<pre class="webidl">
[Exposed=Window]
interface Dahut {
  attribute DOMString type;
};

[Exposed=Window]
interface ExceptionThrower {
  /* <span class="comment">
この属性は、
常に `NotSupportedError$E を投出する
— 決して値を返さない。
◎
This attribute always throws a NotSupportedError and never returns a value.
</span> */
  attribute long valueOf;
};
</pre>

<p>
~JS実装がこの~ifcを~supportしていると見做すとき、
例外をどう取扱うかを次の~codeにデモる：
◎
Assuming a JavaScript implementation supporting this interface, the following code demonstrates how exceptions are handled:
</p>

<pre class="lang-js">
var %d = getDahut();              /* <span class="comment">
`Dahut^T の~instanceを得する。
◎
Obtain an instance of Dahut.
</span> */
var %et = getExceptionThrower();  /* <span class="comment">
`ExceptionThrower^T の~instanceを得する。
◎
Obtain an instance of ExceptionThrower.
</span> */

try {
  %d.type = { toString: function() { throw "abc"; } };
} catch (%e) {
  /* <span class="comment">
文字列 `abc^l はここで~catchされる。
何故なら、
~nativeな~objから文字列への変換の一環として，
匿名~関数が呼出され、［
`DefaultValue^sl, `ToPrimitive^A, `ToString^A
］~algoは，どれも例外を~catchするように定義されていないので。
◎
The string "abc" is caught here, since as part of the conversion from the native object to a string, the anonymous function was invoked, and none of the [[DefaultValue]], ToPrimitive or ToString algorithms are defined to catch the exception.
</span> */
}

try {
  %d.type = { toString: { } };
} catch (%e) {
  /* <span class="comment">
例外は、
ここで~catchされる。
`toString^jp ~propの値である~nativeな~obj上で `Call^sl を呼出そうと試みられたので。
◎
An exception is caught here, since an attempt is made to invoke [[Call]] on the native object that is the value of toString property.
</span> */
}

try {
  %d.type = Symbol();
} catch (%e) {
  /* <span class="comment">
例外は、
ここで~catchされる。
`Symbol^jt 値~上で~JS `ToString$A 抽象-演算を呼出そうと試みられたので。
◎
An exception is caught here, since an attempt is made to invoke the JavaScript ToString abstract operation on a Symbol value.
</span> */
}

%d.type = %et;
  /* <span class="comment">
~catchされなかった `NotSupportedError$E は、
ここで投出される。
`DefaultValue^sl ~algoは、
`ExceptionThrower^T ~objの `valueOf^jp ~propの値を取得するよう試みるので。
例外はこの~code~blockの外へ伝播する。
◎
An uncaught "NotSupportedError" DOMException is thrown here, since the [[DefaultValue]] algorithm attempts to get the value of the "valueOf" property on the ExceptionThrower object. The exception propagates out of this block of code.
</span> */
</pre>
</div>

			</section>
		</section>
	</section>
</main></div>

