<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>HTML Standard — The XML syntax （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2019-05-27
trans_update:2017-07-29
source_checked:170227
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/xhtml.html
site_nav:xml,html-syntax,html
nav_prev:HTMLparsing
nav_next:HTMLrendering
trans_1st_pub:2017-03-01


●●class_map
E:error
e:element
a:attr
P:production
U:code-point

●●tag_map
I:code
m:code
E:code
c:code
mt:code
P:code
e:code
a:code
U:span
V:var
i:i
cite:cite
em:em

●●original_id_map


●●words_table1


XML10:https://www.w3.org/TR/xml/
HTMLcharrefs:HTML-charrefs-ja.html


●●link_map


	●
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror

I.Attr:~DOM4#interface-attr
I.Comment:~DOM4#interface-comment
I.DOMException:~WEBIDL#idl-DOMException
I.Document:~HTMLdom#document
I.DocumentFragment:~DOM4#interface-documentfragment
I.DocumentType:~DOM4#interface-documenttype
I.Element:~DOM4#interface-element
I.Node:~DOM4#interface-node
I.ProcessingInstruction:~DOM4#interface-processinginstruction
I.Text:~DOM4#interface-text
I.MutationEvent:~DOM4#mutationevent

m.lookupNamespaceURI():~DOM4#dom-node-lookupnamespaceuri
m.isDefaultNamespace():~DOM4#dom-node-isdefaultnamespace

P.Name:~XML10#NT-Name

m.document.write():~HTMLdynamic#dom-document-write
e.object:~HEembed#the-object-element
e.param:~HEembed#the-param-element
e.script:~HEscripting#the-script-element
e.template:~HEscripting#the-template-element
mt.text/html:~HTMLLS/iana.html#text/html

~XML素片に直列化する:#xml-fragment-serialisation-algorithm
構文解析器に給する:#feed-the-parser
~XML素片を構文解析する:#xml-fragment-parsing-algorithm
~XML構文解析器:#xml-parser
~XML~scriptingの~supportは不能化-:#xml-scripting-support-disabled
~XML~scriptingの~supportは可能化-:#xml-scripting-support-enabled
関連な子~nodeたち:#relevant-child-nodes
	＊the~URL~given~by~this~link:#XXXXX
~XML構文:#the-xhtml-syntax

開始済み~flag:~HEscripting#already-started
解析器挿入~flag:~HEscripting#parser-inserted
阻まず~flag:~HEscripting#non-blocking
解析器実行準備済み~flag:~HEscripting#ready-to-be-parser-executed

	"already~started":~HEscripting#already-started
	"non-blocking":~HEscripting#non-blocking
	"parser-inserted":~HEscripting#parser-inserted
	"ready~to~be構文解析器-executed":~HEscripting#ready-to-be-parser-executed
実行する:~HEscripting#execute-the-script-block
構文解析器を阻んでいる~script:~HEscripting#pending-parsing-blocking-script
阻んでいる~script:~HEscripting#pending-parsing-blocking-script
準備する:~HEscripting#prepare-a-script
~template内容:~HEscripting#template-contents

~event-loopを回す:~WAPI#spin-the-event-loop
~event-loop:~WAPI#event-loop
小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
~task:~WAPI#concept-task

~HTML構文:~HTMLwriting#syntax
~HTML素片を構文解析-:~HTMLparsing#html-fragment-parsing-algorithm
~HTML構文解析器:~HTMLparsing#html-parser
中止-:~HTMLparsing#abort-a-parser
V.文脈~要素:~HTMLparsing#concept-frag-parse-context
~tokenから要素を作成する:~HTMLparsing#create-an-element-for-the-token
~open要素~stack:~HTMLparsing#stack-of-open-elements
構文解析を停止-:~HTMLparsing#stop-parsing
	~HTMLparsing#named-character-references

~custom要素:~HEcustom#custom-element

~scriptを阻んでいる~stylesheetは無い:~HEmetadata#has-no-style-sheet-that-is-blocking-scripts

故意的な違反:~HTMLINFRA#willful-violation

~ASCII大小無視:~INFRA#ascii-case-insensitive

~XML文書:~DOM4#xml-document
文書~要素:~DOM4#document-element
要素~interface:~DOM4#concept-element-interface
変異~observer:~DOM4#mutation-observers
~node文書:~DOM4#concept-node-document
~tree順序:~DOM4#concept-tree-order

文書~実体:~XML10#sec-well-formed
実体~宣言:~XML10#sec-entity-decl
実体~参照:~XML10#dt-entref
内部~一般解析対象~実体:~XML10#wf-entities


●●words_table



	●仕様
精神:spirit:~
反する:contradictする:~
流儀:fashion:~
本式:proper:~
強いら:forceさ:~

	書いている／書くとき:writing
	安全でない:unsafe
	extensible
	~~実際:indeed
	とりわけ:particular-emphasis
	更には:furthermore
	以前は:formerly
	称され:refer
	によれば:according
	面した:face
	普通の:regular
	-:regarding

	●構文／直列化
just:
	直列化-不能にする:unserialisable

開始tag:start tag:開始 tag::開始タグ
終了tag:end tag:終了 tag::終了タグ
終端-:end:~
終端:end:~
連結:concatenation:~
	~~連続する:adjacent

	●XML
MathML:
DOCTYPE:
DTD:
	Namespaces in XML

subset::::サブセット
systemID:system identifier:system 識別子
publicID:public identifier:public 識別子
一般解析対象:general parsed::~
実体:entity::~
名前空間整形式:namespace-well-formed::~
整形式性:well-formedness::整形式


同型:isomorphic:~
	~data構造:datastructure
形:form:~

	●処理
準備-:prepare::~
渡され:passされ:~

回す:spinする::~
解析器挿入:parser-inserted::~::パーサ挿入
解析器実行準備済み:ready to be parser-executed::解析器実行 準備済み::パーサ実行 準備済み
開始済み:already started::~
阻まず:non-blocking::~::非ブロッキング
	阻んでいる:-blocking
	-:pending
給する:feedする:~
	spoon-feed
checkpoint:
open::::
小task:microtask::小 task:小タスク
observer::::オブザーバ

	●未分類
個別:individual:~
	混ぜて:combination
template::::
	WHATWG:
	QUOTATION MARK
	APOSTROPHE
	COLON
	HYPHEN-MINUS
	~instance化:instantiate
	time::::
	-:unblock


	●指示語
	それも:again
	後続して，:subsequently
	among
	この時点で、:no longer
	何か:some
	かなりの部分:much of


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">The XML syntax</a>
章を日本語に翻訳したものです。
~PUB
</p>

</script>

<body>

<header id="head">
	<hgroup id="living-standard">
<h1 id="the-xhtml-syntax" title="The XML syntax">13. XML 構文 — The XML syntax</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

<a id="xhtml"></a>
<p class="note">注記：
この節は、~XML資源~用の規則のみを述べる。
`text/html$mt 資源~用の規則は、`~HTML構文$ 節にて論じられる。
◎
This section only describes the rules for XML resources. Rules for text/html resources are discussed in the section above entitled "The HTML syntax".
</p>

		<section id="writing-xhtml-documents">
<h2 title="Writing documents in the XML syntax">13.1. ~XML構文で文書を書くとき</h2>

<p class="note">注記：
~HTML用の~XML構文は、以前は "XHTML" と称されていたが、この仕様はその用語を利用しない
（他の理由もあるが、~MathMLや~SVGの~HTML構文には，そのような用語は利用されていないので）。
◎
The XML syntax for HTML was formerly referred to as "XHTML", but this specification does not use that term (among other reasons, because no such term is used for the HTML syntaxes of MathML and SVG).
</p>

<p>
~XML用の構文は、［
`XML^cite `XML$r,
`Namespaces in XML^cite `XMLNS$r
］にて定義される。
◎
The syntax for XML is defined in XML and Namespaces in XML. [XML] [XMLNS]
</p>

<p>
この仕様は、~XMLにて本式に定義されるものを超えるような，構文~levelの要件は何も定義しない。
◎
This specification does not define any syntax-level requirements beyond those defined for XML proper.
</p>

<p>
~XML文書は、欲されるなら `DOCTYPE^c を包含してもヨイが、この仕様に適合するためには要求されない。
この仕様は、~publicIDも~systemIDも定義しないし，正式な~DTDも供さない。
◎
XML documents may contain a DOCTYPE if desired, but this is not required to conform to this specification. This specification does not define a public or system identifier, nor provide a formal DTD.
</p>

<p class="note">注記：
`XML^cite によれば、~XML処理器が［
~DOCTYPE内から参照されている外部~DTD~subset
］を処理することは，保証されない。
これは例えば、［
外部~file内に定義される`実体~参照$を，~XML文書~内の文字に利用すること
］は，安全でないことを意味する（
`&amp;lt;^c,
`&amp;gt;^c,
`&amp;amp;^c,
`&amp;quot;^c,
`&amp;apos;^c
は除いて）。
◎
According to XML, XML processors are not guaranteed to process the external DTD subset referenced in the DOCTYPE. This means, for example, that using entity references for characters in XML documents is unsafe if they are defined in an external file (except for &amp;lt;, &amp;gt;, &amp;amp;, &amp;quot; and &amp;apos;).
</p>

		</section>
		<section id="parsing-xhtml-documents">
<h2 title="Parsing XML documents">13.2. ~XML文書の構文解析-法</h2>

<p>
この節では、~XMLと~DOMとの間の関係性を，とりわけ、これが~HTMLとどう相互作用するかについて述べる。
◎
This section describes the relationship between XML and the DOM, with a particular emphasis on how this interacts with HTML.
</p>

<p>
この仕様の目的における
`~XML構文解析器@
は、［
`XML^cite にて与えられる，［
~byte／文字
］たちが成す連なりを `Document$I ~objの中へ対応付ける規則
］に従う構成子である。
◎
An XML parser, for the purposes of this specification, is a construct that follows the rules given in XML to map a string of bytes or characters into a Document object.
</p>

<p class="note">注記：
これを書いている時点では、そのような規則は実際には存在しない。
◎
At the time of writing, no such rules actually exist.
</p>

<p>
`~XML構文解析器$は、
`Document$I ~objの作成-時に結付けられるか，または
暗黙的に作成される。
◎
An XML parser is either associated with a Document object when it is created, or creates one implicitly.
</p>

<p>
次に，この `Document$I は、［
`XML^cite,
`Namespaces in XML^cite,
`DOM^cite
］による定義に従って，［
構文解析器に渡された入力が成す~tree構造を表現する~DOM~nodeたち
］で拡充されるモノトスル。
要素を表現する~DOM~nodeを作成するときは、［
適正な`要素~interface$が作成され，`~custom要素$が正しく設定しておかれる
］ことを確保するため，［
`~tokenから要素を作成する$ ~algo, または
適切な~XML~data構造に演算する等価な何か
］を利用するモノトスル。
◎
This Document must then be populated with DOM nodes that represent the tree structure of the input passed to the parser, as defined by XML, Namespaces in XML, and DOM. When creating DOM nodes representing elements, the create an element for a token algorithm or some equivalent that operates on appropriate XML datastructures must be used, to ensure the proper element interfaces are created and that custom elements are set up correctly.
</p>

<p>
~DOM変異~event
【 `MutationEvent$I 】
は、`~XML構文解析器$が `Document$I ~tree上に遂行する演算~用には，発火されないモノトスルが，~UAは、［
要素が個別に付加された ／ 属性が個別に設定された
］かのように動作して，［［
要素が文書の中へ挿入されたとき／要素の属性が設定されたとき
］に何が起こるかに関する，この仕様~内の各種~規則
］を誘発させるモノトスル。
その際には、`変異~observer$に関する `DOM^cite  の要件により，変異~observerは`発火される^em
【<a href="~DOM4#queue-a-mutation-record">参照</a>】
ことになる（変異~eventとは違って）。
`XML$r
`XMLNS$r
`DOM$r
`UIEVENTS$r
◎
DOM mutation events must not fire for the operations that the XML parser performs on the Document's tree, but the user agent must act as if elements and attributes were individually appended and set respectively so as to trigger rules in this specification regarding what happens when an element is inserted into a document or has its attributes set, and DOM's requirements regarding mutation observers mean that mutation observers are fired (unlike mutation events). [XML] [XMLNS] [DOM] [UIEVENTS]
</p>

<p>
要素の開始tagが構文解析されてから，［
要素の終了tagが構文解析されるか, 
構文解析器が整形式性~errorを検出する
］までの間、~UAは，その要素が`~open要素~stack$内にあるかのように動作するモノトスル。
◎
Between the time an element's start tag is parsed and the time either the element's end tag is parsed or the parser detects a well-formedness error, the user agent must act as if the element was in a stack of open elements.
</p>

<p class="note">注記：
これは例えば、 `object$e 要素において，［
その子である `param$e 要素が構文解析される前に，~pluginが~instance化される
］のを避けるために利用される。
◎
This is used, e.g. by the object element to avoid instantiating plugins before the param element children have been parsed.
</p>

<p>
この仕様は、~UAが外部~実体を検索取得するときに利用するべきである，追加的な情報を以下に供する：
次に挙げる~publicIDは、どれも，この~linkに与える~URL†
【<a href="HTML-resources/external-entity.txt">この~link先にある~data</a>と等価な内容を表現する~URL】
に対応する（この~URLは、
<a href="~HTMLcharrefs">有名~文字~参照 節</a>
に挙げる一連の名前~用に`実体~宣言$を包含している~DTDを内容とする）。
`XML$r
◎
This specification provides the following additional information that user agents should use when retrieving an external entity: the public identifiers given in the following list all correspond to the URL given by this link. (This URL is a DTD containing the entity declarations for the names listed in the named character references section.) [XML]
</p>

<p class="trans-note">【†
原文では、~linkの `href^a 属性に（ `data:^c ~URLとして base64 符号化された上で）直に~DTDが記されているが、編集上の都合により，この訳では `その内容^emを外部~資源（~ASCII~text）として与えることにする。
】</p>

<ul ><li>`-//W3C//DTD XHTML 1.0 Transitional//EN^c
</li><li>`-//W3C//DTD XHTML 1.1//EN^c
</li><li>`-//W3C//DTD XHTML 1.0 Strict//EN^c
</li><li>`-//W3C//DTD XHTML 1.0 Frameset//EN^c
</li><li>`-//W3C//DTD XHTML Basic 1.0//EN^c
</li><li>`-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN^c
</li><li>`-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN^c
</li><li>`-//W3C//DTD MathML 2.0//EN^c
</li><li>`-//WAPFORUM//DTD XHTML Mobile 1.0//EN^c
</li></ul>

<div class="p">
<p>
~UAは、上に挙げた~publicIDのいずれかが利用されているときは：
</p>

<ul><li>上述した外部~実体の内容を，検索取得するよう試みるべきである。
</li><li>他の外部~実体の内容は，検索取得しようと試みるべきでない。
</li></ul>

◎
Furthermore, user agents should attempt to retrieve the above external entity's content when one of the above public identifiers is used, and should not attempt to retrieve any other external entity's content.
</div>

<p class="note">注記：
これは厳密には，
`XML^cite `XML$r
に対する`故意的な違反$ではないが、~XML仕様が課す要件の精神には反する。
その動機は、［
外部~subsetを取扱うための~network~accessを，~UAに要求する
］ことなく，［
すべての~UAが，実体を相互運用可能な流儀で取扱う
］ことが欲されていることにある。
◎
This is not strictly a violation of XML, but it does contradict the spirit of XML's requirements. This is motivated by a desire for user agents to all handle entities in an interoperable fashion without requiring any network access for handling external subsets. [XML]
</p>

<p>
~XML構文解析器は
`~XML~scriptingの~supportは可能化-@
されるか, または
`~XML~scriptingの~supportは不能化-@
される下で、呼出される。
特に指定されない限り、`~XML~scriptingの~supportは可能化-$されて呼出されるとする。
◎
XML parsers can be invoked with XML scripting support enabled or XML scripting support disabled. Except where otherwise specified, XML parsers are invoked with XML scripting support enabled.
</p>

<p id="scriptTagXML">
`~XML~scriptingの~supportは可能化-$された`~XML構文解析器$ %構文解析器 が，
`script$e 要素 %script を作成したときは：
◎
When an XML parser with XML scripting support enabled creates a script element,＼
</p>

<ul>
	<li>
<p>
%script の各種~flagを次のように設定しておくモノトスル：
</p>

<ul><li>`解析器挿入~flag$ ~SET ~T
</li><li>`阻まず~flag$ ~SET ~F
</li><li>%構文解析器 が，`~XML素片を構文解析する$一部として作成されたものである場合
⇒
`開始済み~flag$ ~SET ~T
</li></ul>
◎
it must be marked as being "parser-inserted" and its "non-blocking" flag must be unset. If the parser was created as part of the XML fragment parsing algorithm, then the element must be marked as "already started" also.＼
</li>
	<li>
<p>
後続して， %script の終了tagを構文解析するときは、次を遂行するモノトスル：
◎
When the element's end tag is subsequently parsed, the user agent must perform＼
</p>
		<ol>
			<li>
`小task~checkpointを遂行する$
◎
a microtask checkpoint, and then＼
</li>
			<li>
%script を`準備する$
◎
prepare the script element.＼
</li>
			<li>
<p>
~IF［
前~段により %script は`構文解析器を阻んでいる~script$になった
］：
◎
If this causes there to be a pending parsing-blocking script, then the user agent must run the following steps:
</p>

				<ol>
					<li>
<p>
この段を終えるまでは、［
%構文解析器 を呼出した`~task$を，`~event-loop$が走らす
］ことはないよう， %構文解析器 を阻む。
</p>

<p>
次の両者が満たされるまで`~event-loopを回す$：
</p>

<ul ><li>%構文解析器 の `Document$I には`~scriptを阻んでいる~stylesheetは無い$
</li><li>%script の`解析器実行準備済み~flag$ ~EQ ~T
</li></ul>

◎
Block this instance of the XML parser, such that the event loop will not run tasks that invoke it.
◎
Spin the event loop until the parser's Document has no style sheet that is blocking scripts and the pending parsing-blocking script's "ready to be parser-executed" flag is set.
◎
Unblock this instance of the XML parser, such that tasks that invoke it can again be run.
</li>
					<li>
%script を`実行する$
◎
Execute the pending parsing-blocking script.
</li>
					<li>
`構文解析器を阻んでいる~script$ ~SET ε
◎
There is no longer a pending parsing-blocking script.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ul>

<p class="note">注記：
`~XML文書$用には
`document.write()$m ~APIは可用でないので、
`~HTML構文解析器$における複階性を成すかなりの部分は，`~XML構文解析器$においては必要なくなる。
◎
Since the document.write() API is not available for XML documents, much of the complexity in the HTML parser is not needed in the XML parser.
</p>

<p class="note">注記：
`~XML~scriptingの~supportは不能化-$されている`~XML構文解析器$においては、これは起こらない。
◎
When the XML parser has XML scripting support disabled, none of this happens.
</p>

<p id="templateTagXML">
`~XML構文解析器$が `template$e 要素に~nodeを付加するときは、それに代えて 要素の`~template内容$（ `DocumentFragment$I ~node）に，~nodeを付加するモノトスル。
◎
When an XML parser would append a node to a template element, it must instead append it to the template element's template contents (a DocumentFragment node).
</p>

<p class="note">注記：
これは、
`XML^cite `XML$r
に対する`故意的な違反$である
— あいにく，~XMLを正式に拡張することは、 `template$e 処理に必要な方式ではできないので。
`XML$r
◎
This is a willful violation of XML; unfortunately, XML is not formally extensible in the manner that is needed for template processing. [XML]
</p>

<p>
`~XML構文解析器$が作成する `Node$I ~objの`~node文書$は、その挿入-先の~nodeの`~node文書$に設定されるモノトスル。
◎
When an XML parser creates a Node object, its node document must be set to the node document of the node into which the newly created node is to be inserted.
</p>

<p>
この仕様における ある種の~algoは、いっときに何個かの文字を
`構文解析器に給する@
。
そのような事例では、`~XML構文解析器$は，それらの文字すべての連結からなる 1 個の文字列に面したかのように動作するモノトスル。
◎
Certain algorithms in this specification spoon-feed the parser characters one string at a time. In such cases, the XML parser must act as it would have if faced with a single string consisting of the concatenation of all those characters.
</p>

<p>
`~XML構文解析器$は、入力の終端に達したときは，`~HTML構文解析器$と同じ規則に従って `構文解析を停止-$するモノトスル。
また，`~XML構文解析器$は`中止-$されることもあるが、それも`~HTML構文解析器$に対するときと同じ仕方で行うモノトスル。
◎
When an XML parser reaches the end of its input, it must stop parsing, following the same rules as the HTML parser. An XML parser can also be aborted, which must again be done in the same way as for an HTML parser.
</p>

<p>
適合性~検査器の目的においては、`~XML構文$であると決定された資源は，`~XML文書$になる。
◎
For the purposes of conformance checkers, if a resource is determined to be in the XML syntax, then it is an XML document.
</p>

		</section>
		<section id="serialising-xhtml-fragments">
<h2 title="Serializing XML fragments">13.3. ~XML素片への直列化-法</h2>

<p>
［
`Document$I ／ `Element$I
］~nodeを
`~XML素片に直列化する@
~algoは、その~nodeを表現する ~XML素片を返すか, または例外を投出する。
◎
The XML fragment serialization algorithm for a Document or Element node either returns a fragment of XML that represents that node or throws an exception.
</p>

<p>
この~algoは、下に与えるどの~error事例も適用されないならば、次の形による文字列を返すモノトスル：
◎
↓</p>

<ul>
	<li>
`Document$I 用には、`文書~実体$
◎
For Documents, the algorithm must return a string in the form of a document entity, if none of the error cases below apply.
</li>
	<li>
`Element$I 用には、`内部~一般解析対象~実体$
◎
For Elements, the algorithm must return a string in the form of an internal general parsed entity, if none of the error cases below apply.
</li>
</ul>

<p>
両~事例とも，返される文字列は、~XML名前空間整形式, かつ［
`~tree順序$による，当の~nodeに`関連な子~nodeたち$すべてと同型†な直列化
］にするモノトスル。
~UAは、直列化における［
名前空間~接頭辞／名前空間~宣言
］を調整してもヨイ（また，一部の事例では、名前空間整形式~XMLを得るために，~~実際にそうするよう強いられることもある）。
~UAは、~DOM内の `Text$I ~nodeを表現するときは、普通の~textに文字~参照を混ぜてもヨイ。
◎
In both cases, the string returned must be XML namespace-well-formed and must be an isomorphic serialization of all of that node's relevant child nodes, in tree order. User agents may adjust prefixes and namespace declarations in the serialization (and indeed might be forced to do so in some cases to obtain namespace-well-formed XML). User agents may use a combination of regular text and character references to represent Text nodes in the DOM.
</p>
<p class="trans-note">【†
同型（ isomorphic ）
— この語に技術的に特別な定義があるのかは不明だが、おそらく，直列化した結果を構文解析した結果が元どおりになる（ 2 つの文字列を構文解析した結果が同じ~DOMを生産するならば，それらは同型である、という関係に基づく）ことを意味すると思われる。
】</p>

<p>
~nodeに
`関連な子~nodeたち@
は、次の規則を適用して与えられる：
◎
A node's relevant child nodes are those that apply given the following rules:
</p>

<ul class="switch">
	<li>
`template$e 要素~用には
⇒
`template$e 要素の`~template内容$の子~nodeたち
◎
For template elements
• The relevant child nodes are the child nodes of the template element's template contents, if any.
</li>
	<li>
他の~node用には
⇒
~node自身の子~nodeたち
◎
For all other nodes
• The relevant child nodes are the child nodes of node itself, if any.
</li>
</ul>

<p>
`Element$I に対しては、直列化~内のある要素が名前空間を伴わない場合、その要素の視野に入るどこかで，既定の名前空間が明示的に空~文字列として宣言されなければナラナイ（これは、 `Document$I に対しては適用されない）。
`XML$r
`XMLNS$r
◎
For Elements, if any of the elements in the serialization are in no namespace, the default namespace in scope for those elements must be explicitly declared as the empty string. (This doesn't apply in the Document case.) [XML] [XMLNS]
</p>

<p>
この節の目的においては、内部~一般解析対象~実体は，次を満たすならば~XML名前空間整形式と見なされる
⇒
［［
その実体を内容とする, かつ
名前空間~宣言を伴わない
］ような  1 個の要素
］からなる文書は、~XML名前空間整形式になる
◎
For the purposes of this section, an internal general parsed entity is considered XML namespace-well-formed if a document consisting of an element with no namespace declarations whose contents are the internal general parsed entity would itself be XML namespace-well-formed.
</p>

  
<p>
直列化されている~DOM下位tree内に次のいずれかに該当する~error事例が見出されたときは、~algoは，文字列を返さずに `InvalidStateError$E 例外を投出するモノトスル：
◎
If any of the following error cases are found in the DOM subtree being serialized, then the algorithm must throw an "InvalidStateError" DOMException instead of returning a string:
</p>

<ul>
	<li>
`Document$I ~nodeの子に要素~nodeが無い。
◎
A Document node with no child element nodes.
</li>
	<li>
`DocumentType$I ~nodeは外部~subset~publicIDを有していて，それは
~XML `PubidChar^P 生成規則に合致しない文字を包含している。
`XML$r
◎
A DocumentType node that has an external subset public identifier that contains characters that are not matched by the XML PubidChar production. [XML]
</li>
	<li>
`DocumentType$I ~nodeは外部~subset~systemIDを有していて，それは次を満たしている
⇒
［
`0022^U `"^smb, `0027^U `'^smb
の両者を包含している
］~OR［
~XML `Char^P 生成規則に合致しない文字を包含している
］
`XML$r
◎
A DocumentType node that has an external subset system identifier that contains both a U+0022 QUOTATION MARK (") and a U+0027 APOSTROPHE (') or that contains characters that are not matched by the XML Char production. [XML]
</li>
	<li>
ある~nodeの局所~名が， `003A^U `:^smb を包含している。
◎
A node with a local name containing a U+003A COLON (:).
</li>
	<li>
ある~nodeの局所~名が，~XML `Name$P 生成規則に合致していない
`XML$r
◎
A node with a local name that does not match the XML Name production. [XML]
</li>
	<li>
ある `Attr$I ~nodeが，次を満たしている
⇒
［
どの名前空間にも属さない
］~AND［
その局所~名 ~EQ 文字列 `xmlns^l
］
`XMLNS$r
◎
An Attr node with no namespace whose local name is the lowercase string "xmlns". [XMLNS]
</li>
	<li>
ある `Element$I ~nodeが複数の属性を有していて，それらの［
局所~名, 属する名前空間
］の両者とも互いに同じである。
【属する名前空間が無いものどうしも，属する名前空間は同じと見なされるであろう】
◎
An Element node with two or more attributes with the same local name and namespace.
</li>
	<li>
ある［
`Attr$I ／
`Text$I ／
`Comment$I ／
`ProcessingInstruction$I
］~nodeの~dataが，~XML `Char^P 生成規則に合致しない文字を包含している
`XML$r
◎
An Attr node, Text node, Comment node, or ProcessingInstruction node whose data contains characters that are not matched by the XML Char production. [XML]
</li>
	<li>
ある `Comment$I ~nodeの~dataが，次を満たしている
⇒
［
~~連続する 2 個の `002D^U `-^smb を包含している
］~OR［
`002D^U `-^smb で終端している
］
◎
A Comment node whose data contains two adjacent U+002D HYPHEN-MINUS characters (-) or ends with such a character.
</li>
	<li>
<p>
ある `ProcessingInstruction$I ~nodeが，次のいずれかを満たしている：
◎
↓</p>
		<ul>
			<li>
その~target名は `~ASCII大小無視$で `xml^l に合致する
◎
A ProcessingInstruction node whose target name is an ASCII case-insensitive match for the string "xml".
</li>
			<li>
その~target名は `003A^U `:^smb を包含している
◎
A ProcessingInstruction node whose target name contains a U+003A COLON (:).
</li>
			<li>
その~dataは 文字列 `?&gt;^l を包含している
◎
A ProcessingInstruction node whose data contains the string "?&gt;".
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
~DOMを直列化-不能にする仕方は、これらに限られる。
~XMLが課す他のすべての拘束は、~DOMにより施行される
— 例えば `Document$I ~nodeに 2 個の要素を付加しようと試行しても
`HierarchyRequestError$E 例外が投出されることになる。
◎
These are the only ways to make a DOM unserialisable. The DOM enforces all the other XML constraints; for example, trying to append two elements to a Document node will throw a "HierarchyRequestError" DOMException.
</p>

		</section>
		<section id="parsing-xhtml-fragments">
<h2 title="Parsing XML fragments">13.4. ~XML素片の構文解析-法</h2>

<p>
`~XML素片を構文解析する@
ときは、所与の
( `文脈~要素$V, 文字列 %入力 )
に対し，次を走らす
— それは、［
一連の~nodeからなる~list†
］を返すか, または
`SyntaxError$E 例外を投出する：
◎
The XML fragment parsing algorithm either returns a Document or throws a "SyntaxError" DOMException. Given a string input and a context element context, the algorithm is as follows:
</p>

<p class="trans-note">【
原文には 
“`Document$I を返す”
と記されているが、［
実際の記述（この手続きの最後の段）／
`~HTML素片を構文解析-$ ／
他所における利用 `DOMPARSING$r
］と整合していないので修正している。
】</p>

<ol>
	<li>
新たな`~XML構文解析器$を作成する
◎
Create a new XML parser.
</li>
	<li>
<p>
`文脈~要素$V の開始tagに対応している文字列を，`構文解析器に給する$
— `文脈~要素$V の視野に入る~DOM内の［
すべての名前空間~接頭辞, および
既定の名前空間（もしあれば）
］を宣言した上で：
◎
Feed the parser just created the string corresponding to the start tag of the context element, declaring all the namespace prefixes that are in scope on that element in the DOM, as well as declaring the default namespace (if any) that is in scope on that element in the DOM.
</p>
		<ul>
			<li>
名前空間~接頭辞は、［
それを~~引数に，要素~上の `lookupNamespaceURI()$m ~methodを呼出したとき ~NULL 以外を返すことになる
］ならば，要素の視野に入るとされる。
◎
A namespace prefix is in scope if the DOM lookupNamespaceURI() method on the element would return a non-null value for that prefix.
</li>
			<li>
既定の名前空間は、［
それを~~引数に，要素~上の `isDefaultNamespace()$m ~methodを呼出したとき ~T を返すことになる
］ような名前空間である。
◎
The default namespace is the namespace for which the DOM isDefaultNamespace() method on the element would return true.
</li>
		</ul>

<p class="note">注記：
構文解析器には `DOCTYPE^c は渡されない。
したがって，参照される外部~subsetは無いので、どの実体も認識されないことになる。
◎
No DOCTYPE is passed to the parser, and therefore no external subset is referenced, and therefore no entities will be recognized.
</p>
	</li>
	<li>
%入力 を`構文解析器に給する$
◎
Feed the parser just created the string input.
</li>
	<li>
`文脈~要素$V の終了tagに対応している文字列を，`構文解析器に給する$
◎
Feed the parser just created the string corresponding to the end tag of the context element.
</li>
	<li>
~IF［
~XML整形式性~errorがある
］~OR［
~XML名前空間~整形式性~errorがある
］
⇒
~THROW `SyntaxError$E
◎
If there is an XML well-formedness or XML namespace well-formedness error, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
結果の `Document$I の`文書~要素$に他の同胞~nodeがある
］
⇒
~THROW `SyntaxError$E
◎
If the document element of the resulting Document has any sibling nodes, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET
結果の `Document$I の`文書~要素$の子~nodeたちが成す，`~tree順序$による~list
◎
Return the child nodes of the document element of the resulting Document, in tree order.
</li>
</ol>

		</section>
</main>
