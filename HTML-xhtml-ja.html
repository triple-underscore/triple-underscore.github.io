<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>HTML Standard — The XML syntax （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'U': // Unicode code point
	text = 'U+' + key;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2017-11-14
trans_update:2017-07-29
source_checked:170227
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/xhtml.html
site_nav:xml,html
nav_prev:HTMLparsing
nav_next:HTMLrendering
trans_1st_pub:2017-03-01


●●class_map
E:error
e:element
a:attr
P:production
U:code-point

●●tag_map
I:code
m:code
E:code
c:code
mt:code
P:code
e:code
a:code
U:span
V:var
i:i

●●original_id_map


●●words_table1


XML10:https://www.w3.org/TR/xml/
HTMLcharrefs:HTML-charrefs-ja.html


●●link_map


	●
E.HierarchyRequestError:~WEBIDL#hierarchyrequesterror
E.InvalidStateError:~WEBIDL#invalidstateerror
E.SyntaxError:~WEBIDL#syntaxerror

I.Attr:~DOM4#interface-attr
I.Comment:~DOM4#interface-comment
I.DOMException:~WEBIDL#idl-DOMException
I.Document:~HTMLdom#document
I.DocumentFragment:~DOM4#interface-documentfragment
I.DocumentType:~DOM4#interface-documenttype
I.Element:~DOM4#interface-element
I.Node:~DOM4#interface-node
I.ProcessingInstruction:~DOM4#interface-processinginstruction
I.Text:~DOM4#interface-text
I.MutationEvent:~DOM4#mutationevent

m.lookupNamespaceURI():~DOM4#dom-node-lookupnamespaceuri
m.isDefaultNamespace():~DOM4#dom-node-isdefaultnamespace

P.Name:~XML10#NT-Name

m.document.write():~HTMLdynamic#dom-document-write
e.object:~HEembed#the-object-element
e.param:~HEembed#the-param-element
e.script:~HEscripting#the-script-element
e.template:~HEscripting#the-template-element
mt.text/html:~HTMLLS/iana.html#text/html

~XML素片に直列化-:#xml-fragment-serialisation-algorithm
構文解析器に給する:#feed-the-parser
~XML素片を構文解析-:#xml-fragment-parsing-algorithm
~XML構文解析器:#xml-parser
~XML~scriptingの~supportは不能化-:#xml-scripting-support-disabled
~XML~scriptingの~supportは可能化-:#xml-scripting-support-enabled
関連する子~nodeたち:#relevant-child-nodes
	＊the~URL~given~by~this~link:#XXXXX
~XML構文:#the-xhtml-syntax

開始済み~flag:~HEscripting#already-started
解析器挿入~flag:~HEscripting#parser-inserted
阻まず~flag:~HEscripting#non-blocking
解析器実行準備済み~flag:~HEscripting#ready-to-be-parser-executed

	"already~started":~HEscripting#already-started
	"non-blocking":~HEscripting#non-blocking
	"parser-inserted":~HEscripting#parser-inserted
	"ready~to~be構文解析器-executed":~HEscripting#ready-to-be-parser-executed
実行-:~HEscripting#execute-the-script-block
構文解析器を阻んでいる~script:~HEscripting#pending-parsing-blocking-script
阻んでいる~script:~HEscripting#pending-parsing-blocking-script
準備-:~HEscripting#prepare-a-script
~template内容:~HEscripting#template-contents

~event-loopを回す:~WAPI#spin-the-event-loop
~event-loop:~WAPI#event-loop
小task~checkpointを遂行-:~WAPI#perform-a-microtask-checkpoint
~task:~WAPI#concept-task

~HTML構文:~HTMLwriting#syntax
~HTML素片を構文解析-:~HTMLparsing#html-fragment-parsing-algorithm
~HTML構文解析器:~HTMLparsing#html-parser
中止-:~HTMLparsing#abort-a-parser
V.文脈~要素:~HTMLparsing#concept-frag-parse-context
~tokenから要素を作成-:~HTMLparsing#create-an-element-for-the-token
~open要素~stack:~HTMLparsing#stack-of-open-elements
構文解析を停止-:~HTMLparsing#stop-parsing
	~HTMLparsing#named-character-references

~custom要素:~HEcustom#custom-element

~scriptを阻んでいる~stylesheetは無い:~HEmetadata#has-no-style-sheet-that-is-blocking-scripts

故意的な違反:~HTMLINFRA#willful-violation

~ASCII大小無視:~INFRA#ascii-case-insensitive

~XML文書:~DOM4#xml-document
文書~要素:~DOM4#document-element
要素~interface:~DOM4#concept-element-interface
変異~observer:~DOM4#mutation-observers
~node文書:~DOM4#concept-node-document
木~順序:~DOM4#concept-tree-order

文書~実体:~XML10#sec-well-formed
実体~宣言:~XML10#sec-entity-decl
実体~参照:~XML10#dt-entref
内部~一般解析対象~実体:~XML10#wf-entities


●●words_table



	●仕様
UA:user agent:UA
support::::サポート
level::::レベル
algo:algorithm:::アルゴリズム
標準:standard:~
述べる:describe する:~
規則:rule:~
論じら:discuss さ:~
	書いている／書くとき:writing
仕様:spec:~
用語:term:~
利用-:use:~
理由:reason:~
定義-:define:~
要件:requirements:~
欲され:desire され:~
適合-:conform:~
要求-:require:~
公式的:formal:~
保証:guarantee:~
	例:example:~
安全:safe:~
	安全でない:unsafe
結付けら:associate さ:結び付けら
意味-:mean:~
関係性:relationship:~
相互作用-:interact:~
目的:purpose:~
	従う:follow:~
実際:actual:~
暗黙的:implicit:~
避ける:avoid する:~
	べき:should:~
追加の:additional:~
情報:information:~
試み:attempt:~
厳密:strict:~
精神:spirit:~
反する:contradict:~
取扱う:handle する:取り扱う
供-:provide:~
供さな:provide しな:~
適切:appropriate:~
正しく:correct に:~
確保-:ensure:~
相互運用可能:interoperable:~
動機:motivation:~
	動機-:motivate:~
指定-:specify:~
可用:available:~
複雑さ:complexity:~
	必要:need
方式:manner:~
拡張-:extend:~
	extensible

流儀:fashion:~
適正:proper:~
	正式に:proper:~
事例:case:~
仕方:way:~
施行:enforce:~
拘束:constraints:~
調整-:adjust:~
既定の:default:~
明示的:explicit:~
見なさ:consider:~
試行-:try:~
認識-:recognize:~
手続き:steps:~
適合性:conformance:~
適用-:apply:~
決定-:determine:~
等価:equivalent:~
故意的な:willful:故意による
違反:violation:~

	~~実際:indeed
	あいにく:unfortunately
	とりわけ:particular-emphasis
	違って:unlike
	したがって:therefore
	更には:furthermore
	以前は:formerly
	称され:refer

	●構文／直列化
just:
error::::エラー
token::::トークン
stack::::スタック
ASCII:
大小無視:case-insensitive:~
構成子:construct:~
構文:syntax::~
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
構文解析器:parser::~::パーサ
直列化-:serialize::~::シリアル化
	直列化-不能にする:unserialisable
直列化:serialization::~::シリアル化

開始tag:start tag:開始 tag::開始タグ
終了tag:end tag:終了 tag::終了タグ
終端-:end:~
終端:end:~

空:empty:~
生成規則:production:~
合致-:match:~
参照:reference:~
	-:lowercase:~
文字:character:~
文字列:string:~
検出-:detect:~
検査器:checker:~
連結:concatenation:~
	~~連続する:adjacent
包含-:contain:~

	●XML
MathML:
SVG:
XML:
DOCTYPE:
DTD:
	Namespaces in XML

subset::::サブセット
target::::ターゲット
systemID:system identifier:system 識別子
publicID:public identifier:public 識別子
一般解析対象:general parsed::~
実体:entity::~
接頭辞:prefix::~
名前空間:namespace::~
名前空間整形式:namespace-well-formed::~
整形式性:well-formedness::整形式
処理器:processor::~::プロセッサ

文脈:context:~
視野:scope::~::スコープ
宣言-:declare:~
宣言:declaration:~
局所:local::~::ローカル
属性:attribute:~

文書:document:~
部分木:subtree::~::サブツリー
木:tree::~::ツリー
素片:fragment::~
同型:isomorphic:~
内容:content:~
名:name:~
名前:name:~
内部:internal:~
外部:external:~
同胞:sibling:~
子:child:~
構造:structure:~
	~data構造:datastructure
要素:element:~
形:form:~

	●処理
不能化-:disable::~
可能化-:enable::~
準備-:prepare::~
呼出され:invoke され:呼び出され
呼出した:invoke した:呼び出した
変異:mutation:~
拡充-:populate:~
挿入-:insert:~
検索取得-:retrieve:~
演算-:operate:~
演算:operation:~
渡され:pass され:~
発火-:fire:~
設定-:set:~
誘発-:trigger:~
走らす:run する:~
走らせ:run し:~
	返す:return:~
遂行-:perform:~
達-:reach:~
回す:spin する::~
実行-:execute:~
解析器挿入:parser-inserted::~::パーサ挿入
解析器実行準備済み:ready to be parser-executed::解析器実行 準備済み::パーサ実行 準備済み
開始済み:already started::~
阻まず:non-blocking::~::非ブロッキング
阻んで:block して::~::ブロックして
阻む:block する::~::ブロックする
	阻んでいる:-blocking
	-:pending
停止-:stop:~
給する:feed する:~
	spoon-feed
checkpoint:
event-loop:event loop:::イベントループ
event::::イベント
flag::::フラグ
open::::
script::::スクリプト
scripting::::スクリプト処理
task::::タスク
小task:microtask::小 task:小タスク
中止-:abort:~
付加-:append:~
作成-:create:~
処理-:process:~
処理:processing:~
動作-:act:~
observer::::オブザーバ
例外:exception:~
入力:input:~

	●未分類
存在-:exist:~
強いら:force さ:~
資源:resource::~:リソース
	混ぜて:combination
表現-:represent:~
見出され:find され:~
対応付ける:map する:~
template::::
stylesheet:style sheet:::スタイルシート
API:
DOM:
HTML:
URL:
	WHATWG:
	QUOTATION MARK
	APOSTROPHE
	COLON
	HYPHEN-MINUS
access::::アクセス
byte::::バイト
custom::::カスタム
data::::データ
file::::ファイル
instance::::インスタンス
	~instance化:instantiate
interface::::インタフェース
link::::リンク
list::::リスト
method::::メソッド
network::::ネットワーク
node::::ノード
obj:object:::オブジェクト
plugin::::プラグイン
text::::テキスト
	time::::

順序:order:~
個別:individual:~
投出:throw:~
新たな:new:~
	によれば:according

	-:unblock
	面した:face
	普通の:regular
	regarding




	●指示語
関連する:relevant な:~
	-:given

	1 個の:single:~
	個の:one／two
	〜の代わりに:instead
	ある種の:certain
	この:this
	これらの:these
	すべての:all
	その:that
	そのような:such
	それらの:those
	に関して:regarding
	上:above
	下:below
	与-:give
	両者:both
	他の:other
	元々:originally
	再び／それも:again
	前:before
	同じ:same
	対応-:correspond
	対応ing:corresponding
	得-:obtain
	節:section
	結果の:resulting
	自身:itself
	起こる:happen
	間:between
	除-:except
	後続して，:subsequently
	among
	超える:beyond
	まで:until
	この時点で、:no longer
	何か:some
	挙げられ:list
	かなりの部分:much of


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">The XML syntax</a>
章を日本語に翻訳したものです。
~PUB
</p>

</script>

<body>

<header id="head">
	<hgroup id="living-standard">
<h1 id="the-xhtml-syntax" title="The XML syntax">13. XML 構文 — The XML syntax</h1>
	</hgroup>
</header>

<main id="MAIN" style="display:none;">

<a id="xhtml"></a>
<p class="note">注記：
この節は、~XML資源~用の規則のみを述べる。
`text/html$mt 資源~用の規則は、`~HTML構文$ 節にて論じられる。
◎
This section only describes the rules for XML resources. Rules for text/html resources are discussed in the section above entitled "The HTML syntax".
</p>

		<section id="writing-xhtml-documents">
<h2 title="Writing documents in the XML syntax">13.1. ~XML構文で文書を書くとき</h2>

<p class="note">注記：
~HTML用の~XML構文は、以前は "XHTML" と称されていたが、この仕様はその用語を利用しない
（他の理由もあるが、~MathMLや~SVGの~HTML構文には，そのような用語は利用されていないので）。
◎
The XML syntax for HTML was formerly referred to as "XHTML", but this specification does not use that term (among other reasons, because no such term is used for the HTML syntaxes of MathML and SVG).
</p>

<p>
~XML用の構文は、
`XML$r 仕様, `XMLNS$r 仕様
にて定義される。
◎
The syntax for XML is defined in the XML and Namespaces in XML specifications. [XML] [XMLNS]
</p>

<p>
この仕様は、~XMLにて正式に定義されるものを超えるような，構文~levelの要件は何も定義しない。
◎
This specification does not define any syntax-level requirements beyond those defined for XML proper.
</p>

<p>
~XML文書は、欲されるなら `DOCTYPE^c を包含してもよいが、この仕様に適合するためには要求されない。
この仕様は、~publicIDも~systemIDも定義しないし，公式的な~DTDも供さない。
◎
XML documents may contain a DOCTYPE if desired, but this is not required to conform to this specification. This specification does not define a public or system identifier, nor provide a formal DTD.
</p>

<p class="note">注記：
~XML仕様によれば、~XML処理器が［
~DOCTYPE内から参照されている外部~DTD~subset
］を処理することは，保証されない。
これは例えば、外部~file内に定義される`実体~参照$を ~XML文書~内の文字に利用することは，安全でないことを意味する（
`&amp;lt;^c,
`&amp;gt;^c,
`&amp;amp;^c,
`&amp;quot;^c,
`&amp;apos;^c
は除いて）。
◎
According to the XML specification, XML processors are not guaranteed to process the external DTD subset referenced in the DOCTYPE. This means, for example, that using entity references for characters in XML documents is unsafe if they are defined in an external file (except for &amp;lt;, &amp;gt;, &amp;amp;, &amp;quot; and &amp;apos;).
</p>


		</section>
		<section id="parsing-xhtml-documents">
<h2 title="Parsing XML documents">13.2. ~XML文書の構文解析-法</h2>

<p>
この節では、~XMLと~DOMとの間の関係性を，とりわけ、これが~HTMLとどう相互作用するかについて述べる。
◎
This section describes the relationship between XML and the DOM, with a particular emphasis on how this interacts with HTML.
</p>

<p>
この仕様の目的における
`~XML構文解析器@
は、［
~XML仕様にて与えられる，［
~byte／文字
］たちが成す連なりを `Document$I ~objの中へ対応付ける規則
］に従う構成子である。
◎
An XML parser, for the purposes of this specification, is a construct that follows the rules given in the XML specification to map a string of bytes or characters into a Document object.
</p>

<p class="note">注記：
これを書いている時点では、そのような規則は実際には存在しない。
◎
At the time of writing, no such rules actually exist.
</p>

<p>
`~XML構文解析器$は、
`Document$I ~objの作成-時に結付けられるか，または
暗黙的に作成される。
◎
An XML parser is either associated with a Document object when it is created, or creates one implicitly.
</p>

<p>
次に，この `Document$I は、［
`XML$r 仕様, `XMLNS$r 仕様, `DOM$r 標準
］による定義に従って，構文解析器に渡された入力の木~構造を表現する~DOM~nodeで拡充され~MUST。
要素を表現する~DOM~nodeを作成するときは、［
適正な`要素~interface$が作成され，`~custom要素$が正しく設定しておかれる
］ことを確保するため，［
`~tokenから要素を作成-$する~algo, または
適切な~XML~data構造に演算する等価な何か
］が利用され~MUST。
◎
This Document must then be populated with DOM nodes that represent the tree structure of the input passed to the parser, as defined by the XML specification, the Namespaces in XML specification, and the WHATWG DOM standard. When creating DOM nodes representing elements, the create an element for a token algorithm or some equivalent that operates on appropriate XML datastructures must be used, to ensure the proper element interfaces are created and that custom elements are set up correctly.
</p>

<p>
~DOM変異~event
【 `MutationEvent$I 】
は、`~XML構文解析器$が `Document$I 木~上に遂行する演算~用には，発火されては~MUST_NOTが，~UAは、［
要素が個別に付加- ／ 属性が個別に設定-
］されたかのように動作して，［［
要素が文書の中へ挿入されたとき／要素の属性が設定されたとき
］に何が起こるかに関する，この仕様~内の各種~規則
］を誘発させ~MUST。
その際には、`変異~observer$に関する `DOM$r 標準の要件により，変異~observerは<em>発火される</em>
【<a href="~DOM4#queue-a-mutation-record" >参照</a>】
ことになる（変異~eventとは違って）。
`XML$r
`XMLNS$r
`DOM$r
`UIEVENTS$r
◎
DOM mutation events must not fire for the operations that the XML parser performs on the Document's tree, but the user agent must act as if elements and attributes were individually appended and set respectively so as to trigger rules in this specification regarding what happens when an element is inserted into a document or has its attributes set, and the WHATWG DOM standard's requirements regarding mutation observers mean that mutation observers are fired (unlike mutation events). [XML] [XMLNS] [DOM] [UIEVENTS]
</p>


<p>
要素の開始tagが構文解析されてから，［
要素の終了tagが構文解析されるか, 
構文解析器が整形式性~errorを検出する
］までの間、~UAは，その要素が`~open要素~stack$内にあるかのように動作し~MUST。
◎
Between the time an element's start tag is parsed and the time either the element's end tag is parsed or the parser detects a well-formedness error, the user agent must act as if the element was in a stack of open elements.
</p>

<p class="note">注記：
これは例えば、 `object$e 要素において，［
その子である `param$e 要素が構文解析される前に，~pluginが~instance化される
］のを避けるために利用される。
◎
This is used, e.g. by the object element to avoid instantiating plugins before the param element children have been parsed.
</p>

<p>
この仕様は、~UAが外部~実体を検索取得するときに利用するべきである，追加の情報を以下に供する：
次の~listに与える~publicIDは、どれも［
<a href="HTML-resources/external-entity.txt">この~link先にある~data</a>
と等価な内容を表現する~URL†
］に対応する。
（この~URLは、
<a href="~HTMLcharrefs">有名~文字~参照 節</a>
に挙げる一連の名前~用に`実体~宣言$を包含している~DTDを内容とする。）
`XML$r
◎
This specification provides the following additional information that user agents should use when retrieving an external entity: the public identifiers given in the following list all correspond to the URL given by this link. (This URL is a DTD containing the entity declarations for the names listed in the named character references section.) [XML]
</p>

<p class="trans-note">【†
原文では、~linkの `href^a 属性に（ `data:^c ~URLとして base64 符号化された上で）直接的に記されているが、編集の都合により，この訳では <em>その内容</em>を外部~資源（~ASCII~text）として与えることにする。
】</p>

<ul ><li>`-//W3C//DTD XHTML 1.0 Transitional//EN^c
</li><li>`-//W3C//DTD XHTML 1.1//EN^c
</li><li>`-//W3C//DTD XHTML 1.0 Strict//EN^c
</li><li>`-//W3C//DTD XHTML 1.0 Frameset//EN^c
</li><li>`-//W3C//DTD XHTML Basic 1.0//EN^c
</li><li>`-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN^c
</li><li>`-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN^c
</li><li>`-//W3C//DTD MathML 2.0//EN^c
</li><li>`-//WAPFORUM//DTD XHTML Mobile 1.0//EN^c
</li></ul>

<div class="p">
<p>
~UAは、上に挙げた~publicIDのいずれかが利用されているときは：
</p>

<ul><li>上述した外部~実体の内容を，検索取得するよう試みるべきである。
</li><li>他の外部~実体の内容は，検索取得しようと試みるべきでない。
</li></ul>

◎
Furthermore, user agents should attempt to retrieve the above external entity's content when one of the above public identifiers is used, and should not attempt to retrieve any other external entity's content.
</div>

<p class="note">注記：
これは、厳密には，~XML仕様に対する`故意的な違反$ではないが、~XML仕様が課す要件の精神には反する。
その動機は、［
外部~subsetを取扱うための~network~accessを，~UAに要求する
］ことなく，［
すべての~UAが，実体を相互運用可能な流儀で取扱う
］ことが欲されていることにある。
`XML$r
◎
This is not strictly a violation of the XML specification, but it does contradict the spirit of the XML specification's requirements. This is motivated by a desire for user agents to all handle entities in an interoperable fashion without requiring any network access for handling external subsets. [XML]
</p>

<p>
~XML構文解析器は
`~XML~scriptingの~supportは可能化-@
されるか, または
`~XML~scriptingの~supportは不能化-@
される下で、呼出される。
特に指定されない限り、`~XML~scriptingの~supportは可能化-$されて呼出されるとする。
◎
XML parsers can be invoked with XML scripting support enabled or XML scripting support disabled. Except where otherwise specified, XML parsers are invoked with XML scripting support enabled.
</p>

<p id="scriptTagXML">
`~XML~scriptingの~supportは可能化-$された`~XML構文解析器$ %構文解析器 が，
`script$e 要素 %script を作成したときは：
◎
When an XML parser with XML scripting support enabled creates a script element,＼
</p>

<ul>
	<li>
<p>
%script の各種~flagを次のように設定しておか~MUST：
</p>

<ul><li>`解析器挿入~flag$ ~SET ~ON
</li><li>`阻まず~flag$ ~SET ~OFF
</li><li>%構文解析器 が，元々は`~XML素片を構文解析-$するために作成されたものである場合
⇒
`開始済み~flag$ ~SET ~ON
</li></ul>
◎
it must be marked as being "parser-inserted" and its "non-blocking" flag must be unset. If the parser was originally created for the XML fragment parsing algorithm, then the element must be marked as "already started" also.＼
</li>
	<li>
<p>
後続して， %script の終了tagを構文解析するときは、次を遂行し~MUST：
◎
When the element's end tag is subsequently parsed, the user agent must perform＼
</p>
		<ol>
			<li>
`小task~checkpointを遂行-$する
◎
a microtask checkpoint, and then＼
</li>
			<li>
%script を`準備-$する
◎
prepare the script element.＼
</li>
			<li>
<p>
~IF［
前~段により %script は`構文解析器を阻んでいる~script$になった
］：
◎
If this causes there to be a pending parsing-blocking script, then the user agent must run the following steps:
</p>

				<ol>
					<li>
<p>
この段を終えるまでは、［
`~event-loop$が［
%構文解析器 を呼出した`~task$
］を走らせない
］よう， %構文解析器 は阻むものとする。
</p>

<p>
次の両者が満たされるまで`~event-loopを回す$：
</p>

<ul ><li>%構文解析器 の `Document$I には`~scriptを阻んでいる~stylesheetは無い$
</li><li>%script の`解析器実行準備済み~flag$ ~EQ ~ON
</li></ul>

◎
Block this instance of the XML parser, such that the event loop will not run tasks that invoke it.
◎
Spin the event loop until the parser's Document has no style sheet that is blocking scripts and the pending parsing-blocking script's "ready to be parser-executed" flag is set.
◎
Unblock this instance of the XML parser, such that tasks that invoke it can again be run.
</li>
					<li>
%script を`実行-$する
◎
Execute the pending parsing-blocking script.
</li>
					<li>
`構文解析器を阻んでいる~script$ ~SET ε
◎
There is no longer a pending parsing-blocking script.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ul>


<p class="note">注記：
`~XML文書$用には
`document.write()$m ~APIは可用でないので、
`~HTML構文解析器$における複雑さの かなりの部分は，`~XML構文解析器$においては必要なくなる。
◎
Since the document.write() API is not available for XML documents, much of the complexity in the HTML parser is not needed in the XML parser.
</p>

<p class="note">注記：
`~XML~scriptingの~supportは不能化-$されている`~XML構文解析器$においては、これは起こらない。
◎
When the XML parser has XML scripting support disabled, none of this happens.
</p>

<p id="templateTagXML">
`~XML構文解析器$が `template$e 要素に~nodeを付加するときは、それに代えて 要素の`~template内容$（ `DocumentFragment$I ~node）に，~nodeを付加し~MUST。
◎
When an XML parser would append a node to a template element, it must instead append it to the template element's template contents (a DocumentFragment node).
</p>

<p class="note">注記：
これは、~XML仕様に対する`故意的な違反$である
— あいにく，~XMLを公式的に拡張することは、 `template$e 処理に必要な方式ではできないので。
`XML$r
◎
This is a willful violation of the XML specification; unfortunately, XML is not formally extensible in the manner that is needed for template processing. [XML]
</p>

<p>
`~XML構文解析器$が作成する `Node$I ~objの`~node文書$は、その挿入-先の~nodeの`~node文書$に設定され~MUST。
◎
When an XML parser creates a Node object, its node document must be set to the node document of the node into which the newly created node is to be inserted.
</p>

<p>
この仕様における ある種の~algoは、いっときに何個かの文字を
`構文解析器に給する@
。
そのような事例では、`~XML構文解析器$は，それらの文字すべての連結からなる 1 個の文字列に面したかのように動作し~MUST。
◎
Certain algorithms in this specification spoon-feed the parser characters one string at a time. In such cases, the XML parser must act as it would have if faced with a single string consisting of the concatenation of all those characters.
</p>

<p>
`~XML構文解析器$は、入力の終端に達したときは，`~HTML構文解析器$と同じ規則に従って `構文解析を停止-$し~MUST。
また，`~XML構文解析器$は、`中止-$されることもあるが，それも`~HTML構文解析器$に対するときと同じ仕方で行われ~MUST。
◎
When an XML parser reaches the end of its input, it must stop parsing, following the same rules as the HTML parser. An XML parser can also be aborted, which must again be done in the same way as for an HTML parser.
</p>

<p>
適合性~検査器の目的においては、`~XML構文$であると決定された資源は，`~XML文書$になる。
◎
For the purposes of conformance checkers, if a resource is determined to be in the XML syntax, then it is an XML document.
</p>

		</section>
		<section id="serialising-xhtml-fragments">
<h2 title="Serializing XML fragments">13.3. ~XML素片への直列化-法</h2>

<p>
`Document$I ／ `Element$I
~nodeを
`~XML素片に直列化-@
する~algoは、その~nodeを表現する ~XML素片を返すか, または例外を投出する。
◎
The XML fragment serialization algorithm for a Document or Element node either returns a fragment of XML that represents that node or throws an exception.
</p>

<p>
この~algoは、下に与えるどの~error事例も適用されないならば、次の形による文字列を返さ~MUST：
◎
↓</p>

<ul>
	<li>
`Document$I 用には、`文書~実体$
◎
For Documents, the algorithm must return a string in the form of a document entity, if none of the error cases below apply.
</li>
	<li>
`Element$I 用には、`内部~一般解析対象~実体$
◎
For Elements, the algorithm must return a string in the form of an internal general parsed entity, if none of the error cases below apply.
</li>
</ul>

<p>
両~事例とも，返される文字列は、~XML名前空間整形式である, かつ［
`木~順序$による，当の~nodeに`関連する子~nodeたち$すべてと同型†な直列化
］で~MUST。
~UAは、直列化における［
名前空間~接頭辞／名前空間~宣言
］を調整してもよい（また，一部の事例では、名前空間整形式~XMLを得るために，~~実際にそうするよう強いられることもある）。
~UAは、~DOM内の `Text$I ~nodeを表現するときは、普通の~textに文字~参照を混ぜてもよい。
◎
In both cases, the string returned must be XML namespace-well-formed and must be an isomorphic serialization of all of that node's relevant child nodes, in tree order. User agents may adjust prefixes and namespace declarations in the serialization (and indeed might be forced to do so in some cases to obtain namespace-well-formed XML). User agents may use a combination of regular text and character references to represent Text nodes in the DOM.
</p>
<p class="trans-note">【†
同型（ isomorphic ）
— この語に技術的に特別な定義があるのかは不明だが、おそらく，直列化した結果を構文解析した結果が元どおりになる（ 2 つの文字列を構文解析した結果が同じ~DOMを生産するならば，それらは同型である、という関係に基づく）ことを意味すると思われる。
】</p>


<p>
~nodeに
`関連する子~nodeたち@
は、次の規則を適用して与えられる：
◎
A node's relevant child nodes are those that apply given the following rules:
</p>

<ul class="switch">
	<li>
`template$e 要素~用には
⇒
`template$e 要素の`~template内容$の子~nodeたち
◎
For template elements
• The relevant child nodes are the child nodes of the template element's template contents, if any.
</li>
	<li>
他の~node用には
⇒
~node自身の子~nodeたち
◎
For all other nodes
• The relevant child nodes are the child nodes of node itself, if any.
</li>
</ul>

<p>
`Element$I に対しては、直列化~内のある要素が名前空間を伴わない場合、その要素の視野に入る所で，既定の名前空間が明示的に空~文字列として宣言され~MUST。
（これは `Document$I に対しては適用されない。）
`XML$r
`XMLNS$r
◎
For Elements, if any of the elements in the serialization are in no namespace, the default namespace in scope for those elements must be explicitly declared as the empty string. (This doesn't apply in the Document case.) [XML] [XMLNS]
</p>

<p>
この節の目的においては、内部~一般解析対象~実体は，次を満たすならば~XML名前空間整形式と見なされる
⇒
［［
その実体を内容とする, かつ
名前空間~宣言を伴わない
］ような  1 個の要素
］からなる文書は、~XML名前空間整形式になる
◎
For the purposes of this section, an internal general parsed entity is considered XML namespace-well-formed if a document consisting of an element with no namespace declarations whose contents are the internal general parsed entity would itself be XML namespace-well-formed.
</p>

  
<p>
直列化されている~DOM部分木~内に次のいずれかに該当する~error事例が見出されたときは、~algoは，文字列を返さずに `InvalidStateError$E 例外を投出し~MUST：
◎
If any of the following error cases are found in the DOM subtree being serialized, then the algorithm must throw an "InvalidStateError" DOMException instead of returning a string:
</p>

<ul>
	<li>
`Document$I ~nodeの子に要素~nodeがない。
◎
A Document node with no child element nodes.
</li>
	<li>
`DocumentType$I ~nodeは外部~subset~publicIDを有していて，それは
~XML `PubidChar^P 生成規則に合致しない文字を包含している。
`XML$r
◎
A DocumentType node that has an external subset public identifier that contains characters that are not matched by the XML PubidChar production. [XML]
</li>
	<li>
`DocumentType$I ~nodeは外部~subset~systemIDを有していて，それは
`0022^U `"^smb, `0027^U `'^smb
の両者を包含している, または
~XML `Char^P 生成規則に合致しない文字を包含している。
`XML$r
◎
A DocumentType node that has an external subset system identifier that contains both a U+0022 QUOTATION MARK (") and a U+0027 APOSTROPHE (') or that contains characters that are not matched by the XML Char production. [XML]
</li>
	<li>
ある~nodeの局所~名が
`003A^U `:^smb を包含している。
◎
A node with a local name containing a U+003A COLON (:).
</li>
	<li>
ある~nodeの局所~名が~XML `Name$P 生成規則に合致していない
`XML$r
◎
A node with a local name that does not match the XML Name production. [XML]
</li>
	<li>
ある `Attr$I ~nodeが［
どの名前空間にも属さない
］~AND［
その局所~名 ~EQ 文字列 `xmlns^l
］
`XMLNS$r
◎
An Attr node with no namespace whose local name is the lowercase string "xmlns". [XMLNS]
</li>
	<li>
ある `Element$I ~nodeが複数の属性を有していて，それらの［
局所~名, および 属する名前空間
］の両者とも互いに同じである。
【属する名前空間がないものどうしも名前空間は同じとされるであろう】
◎
An Element node with two or more attributes with the same local name and namespace.
</li>
	<li>
ある［
`Attr$I ／
`Text$I ／
`Comment$I ／
`ProcessingInstruction$I
］~nodeの~dataが~XML `Char^P 生成規則に合致しない文字を包含している
`XML$r
◎
An Attr node, Text node, Comment node, or ProcessingInstruction node whose data contains characters that are not matched by the XML Char production. [XML]
</li>
	<li>
ある `Comment$I の~dataが，次を満たしている
⇒
［
~~連続する 2 個の `002D^U `-^smb を包含している
］~OR［
`002D^U `-^smb で終端している
］
◎
A Comment node whose data contains two adjacent U+002D HYPHEN-MINUS characters (-) or ends with such a character.
</li>
	<li>
<p>
ある `ProcessingInstruction$I ~nodeは、次のいずれかを満たす：
◎
↓</p>
		<ul>
			<li>
~target名が`~ASCII大小無視$で `xml^l に合致する。
◎
A ProcessingInstruction node whose target name is an ASCII case-insensitive match for the string "xml".
</li>
			<li>
~target名が `003A^U `:^smb を包含している。
◎
A ProcessingInstruction node whose target name contains a U+003A COLON (:).
</li>
			<li>
~dataが文字列 `?&gt;^l を包含している。
◎
A ProcessingInstruction node whose data contains the string "?&gt;".
</li>
		</ul>
	</li>
</ul>

<p class="note">注記：
~DOMを直列化-不能にする仕方は、これらに限られる。
~XMLが課す他のすべての拘束は、~DOMにより施行される
— 例えば `Document$I ~nodeに 2 個の要素を付加しようと試行しても
`HierarchyRequestError$E 例外が投出されることになる。
◎
These are the only ways to make a DOM unserialisable. The DOM enforces all the other XML constraints; for example, trying to append two elements to a Document node will throw a "HierarchyRequestError" DOMException.
</p>


		</section>
		<section id="parsing-xhtml-fragments">
<h2 title="Parsing XML fragments">13.4. ~XML素片の構文解析-法</h2>


<p>
`~XML素片を構文解析-@
するときは、所与の
( `文脈~要素$V, 文字列 %入力 )
に対し，次を走らす
— それは、［
一連の~nodeからなる~list†
］を返すか, または
`SyntaxError$E 例外を投出する：
◎
The XML fragment parsing algorithm either returns a Document or throws a "SyntaxError" DOMException. Given a string input and a context element context, the algorithm is as follows:
</p>

<p class="trans-note">【
原文には 
“`Document$I を返す”
と記されているが、［
実際の記述（この手続きの最後の段）／
`~HTML素片を構文解析-$ ／
他所における利用 `DOMPARSING$r
］と整合していないので修正している。
】</p>

<ol>
	<li>
新たな`~XML構文解析器$を作成する
◎
Create a new XML parser.
</li>
	<li>
<p>
`文脈~要素$V の開始tagに対応している文字列を，`構文解析器に給する$
— `文脈~要素$V の視野に入る~DOM内の［
すべての名前空間~接頭辞, および
既定の名前空間（もしあれば）
］を宣言した上で：
◎
Feed the parser just created the string corresponding to the start tag of the context element, declaring all the namespace prefixes that are in scope on that element in the DOM, as well as declaring the default namespace (if any) that is in scope on that element in the DOM.
</p>
		<ul>
			<li>
名前空間~接頭辞は、［
それを引数に，要素~上の `lookupNamespaceURI()$m ~methodを呼出したとき ~NULL 以外を返すことになる
］ならば，要素の視野に入るとされる。
◎
A namespace prefix is in scope if the DOM lookupNamespaceURI() method on the element would return a non-null value for that prefix.
</li>
			<li>
既定の名前空間は、［
それを引数に，要素~上の `isDefaultNamespace()$m ~methodを呼出したとき ~T を返すことになる
］ような名前空間である。
◎
The default namespace is the namespace for which the DOM isDefaultNamespace() method on the element would return true.
</li>
		</ul>

<p class="note">注記：
構文解析器には `DOCTYPE^c は渡されない。
したがって，参照される外部~subsetはないので、どの実体も認識されないことになる。
◎
No DOCTYPE is passed to the parser, and therefore no external subset is referenced, and therefore no entities will be recognized.
</p>
	</li>
	<li>
%入力 を`構文解析器に給する$
◎
Feed the parser just created the string input.
</li>
	<li>
`文脈~要素$V の終了tagに対応している文字列を，`構文解析器に給する$
◎
Feed the parser just created the string corresponding to the end tag of the context element.
</li>
	<li>
~IF［
~XML整形式性~errorがある
］~OR［
~XML名前空間~整形式性~errorがある
］
⇒
~THROW `SyntaxError$E
◎
If there is an XML well-formedness or XML namespace well-formedness error, then throw a "SyntaxError" DOMException.
</li>
	<li>
~IF［
結果の `Document$I の`文書~要素$に他の同胞~nodeがある
］
⇒
~THROW `SyntaxError$E
◎
If the document element of the resulting Document has any sibling nodes, then throw a "SyntaxError" DOMException.
</li>
	<li>
~RET
結果の `Document$I の`文書~要素$の子~nodeたちが成す，`木~順序$による~list
◎
Return the child nodes of the document element of the resulting Document, in tree order.
</li>
</ol>

		</section>
</main>
