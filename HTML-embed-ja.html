<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — iframe, embed, object 要素 他（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mS':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U': 
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">作者~向け</a>／<a href="~HTMLAAM#el-${key}">実装者~向け</a>`;
	break;
case 'obsMb':
	text = '廃用にされた~memberもある';
	href= `~HTMLLS/obsolete.html#${key}-partial`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2026-01-16
trans_update:2025-08-04
source_checked:240712
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/iframe-embed-object.html
	abbr_url:HEembed
nav_prev:HEimageAlt
nav_next:HEmedia
trans_1st_pub:2017-03-07

●●class_map
e:element
E:error
a:attr
aF:attr
aE:attr
aO:attr
et:event-type
sc:scheme
st:attr-state
sl:js-slot
v:value
h:header
U:code-point
obsMb:comment

●●tag_map
I:code
m:code
mF:code
mE:code
mO:code
E:code
c:code
e:code
a:code
aF:code
aE:code
aO:code
et:code
mt:code
st:i
sc:code
h:code
sub:sub
U:span
v:code
V:var
sl:span
i:i
cite:cite
obsMb:span

●●original_urls
mathml:https://html.spec.whatwg.org/multipage/embedded-content-other.html
svg-0:https://html.spec.whatwg.org/multipage/embedded-content-other.html
dimension-attributes:https://html.spec.whatwg.org/multipage/embedded-content-other.html

●●mdn_urls
the-embed-element:HTML/Element/embed
the-iframe-element:HTML/Element/iframe
the-object-element:HTML/Element/object

htmlembedelement:API/HTMLEmbedElement
htmlobjectelement:API/HTMLObjectElement
htmliframeelement:API/HTMLIFrameElement

●●original_id_map
	shared-attribute-processing-steps-for-iframe-and-frame-elements:otherwise-steps-for-iframe-or-frame-elements

●●link_map


	●IDL
CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor
Reflect:~HTMLcdom#xattr-reflect
ReflectURL:~HTMLcdom#xattr-reflecturl

I.TrustedHTML:~TRUSTED-TYPES#trustedhtml
HTMLString:~TRUSTED-TYPES#typedefdef-htmlstring

I.DOMTokenList:~DOM4#interface-domtokenlist
I.Document:~HTMLdom#document
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLEmbedElement:#htmlembedelement
I.HTMLFormElement:~HEforms#htmlformelement
I.HTMLObjectElement:#htmlobjectelement
I.ValidityState:~HTMLforms#validitystate
~window:~WINDOW#the-window-object
	I.Window:~WINDOW#window
I.WindowProxy:~HTMLWPROXY#windowproxy
I.HTMLIFrameElement:#htmliframeelement
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp


m.alert:~HTMLGAPI#dom-window-alert
m.checkValidity:~HTMLforms#dom-cva-checkvalidity
m.confirm:~HTMLGAPI#dom-window-confirm
m.form:~HTMLforms#dom-fae-form
m.getSVGDocument:#dom-media-getsvgdocument
m.prompt:~HTMLGAPI#dom-window-prompt
m.reportValidity:~HTMLforms#dom-cva-reportvalidity
m.requestFullscreen:~FULLSCREEN#dom-element-requestfullscreen
m.setCustomValidity:~HTMLforms#dom-cva-setcustomvalidity
m.validationMessage:~HTMLforms#dom-cva-validationmessage
m.validity:~HTMLforms#dom-cva-validity
m.value:~DOM4#dom-domtokenlist-value
m.willValidate:~HTMLforms#dom-cva-willvalidate

mF.allowFullscreen:#dom-iframe-allowfullscreen
mF.allow:#dom-iframe-allow
mF.contentDocument:#dom-iframe-contentdocument
mF.contentWindow:#dom-iframe-contentwindow
mF.name:#dom-iframe-name
mF.referrerPolicy:#dom-iframe-referrerpolicy
mF.loading:#dom-iframe-loading
mF.sandbox:#dom-iframe-sandbox
mF.src:#dom-iframe-src
mF.srcdoc:#dom-iframe-srcdoc
mF.width:#dom-dim-width
mF.height:#dom-dim-height

mE.src:#dom-embed-src
mE.type:#dom-embed-type
mE.width:#dom-embed-width
mE.height:#dom-embed-height


mO.contentDocument:#dom-object-contentdocument
mO.contentWindow:#dom-object-contentwindow
mO.data:#dom-object-data
mO.name:#dom-object-name
mO.type:#dom-object-type
mO.width:#dom-object-width
mO.height:#dom-object-height


e.embed:#the-embed-element
e.iframe:#the-iframe-element
e.object:#the-object-element
e.video:~HEmedia#the-video-element
e.img:~HEimages#the-img-element
e.picture:~HEimages#the-picture-element
e.source:~HEimages#the-source-element
e.input:~HEinput#the-input-element

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.form:~HEforms#the-form-element

e.frame:~HTMLobs#frame

e.annotation-xml:~MATHMLcore#dfn-annotation-xml
e.math:~MATHMLcore#the-top-level-math-element
e.merror:~MATHMLcore#error-message-merror
e.mi:~MATHMLcore#the-mi-element
e.mn:~MATHMLcore#number-mn
e.mo:~MATHMLcore#operator-fence-separator-or-accent-mo
e.ms:~MATHMLcore#string-literal-ms
e.mtext:~MATHMLcore#text-mtext

e.foreignObject:~SVGembedded#elementdef-foreignObject
e.svg:~SVGstruct#elementdef-svg
	e.title:~SVGstruct#elementdef-title

a.classid:~HTMLobs#attr-object-classid

a.form:~HTMLforms#attr-fae-form
a.width:#attr-dim-width
a.height:#attr-dim-height
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute
a.type:~HEinput#attr-input-type

aF.allow:#attr-iframe-allow
aF.allowfullscreen:#attr-iframe-allowfullscreen
aF.name:#attr-iframe-name
aF.referrerpolicy:#attr-iframe-referrerpolicy
aF.loading:#attr-iframe-loading
aF.sandbox:#attr-iframe-sandbox
aF.src:#attr-iframe-src
aF.srcdoc:#attr-iframe-srcdoc

aE.src:#attr-embed-src
aE.type:#attr-embed-type

aO.data:#attr-object-data
aO.name:#attr-object-name
aO.type:#attr-object-type


et.error:~HTMLindex#event-error
et.load:~HTMLindex#event-load
et.unload:~HTMLindex#event-unload


mt.application/octet-stream:~RFCx/rfc2046#section-4.5.1
mt.text/html:~HTMLiana#text/html
mt.text/plain:~RFCx/rfc2046#section-4.1.3
mt.image/svg+xml:~HTMLindex#image/svg+xml

sc.~about_blank:~HTMLdep#about:blank
sc.~about_srcdoc:~HTMLurl#about:srcdoc


v.allow-forms:~ORIGIN#attr-iframe-sandbox-allow-forms
v.allow-modals:~ORIGIN#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:~ORIGIN#attr-iframe-sandbox-allow-orientation-lock
v.allow-pointer-lock:~ORIGIN#attr-iframe-sandbox-allow-pointer-lock
v.allow-popups-to-escape-sandbox:~ORIGIN#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-downloads:~ORIGIN#attr-iframe-sandbox-allow-downloads
v.allow-popups:~ORIGIN#attr-iframe-sandbox-allow-popups
v.allow-presentation:~ORIGIN#attr-iframe-sandbox-allow-presentation
v.allow-same-origin:~ORIGIN#attr-iframe-sandbox-allow-same-origin
v.allow-scripts:~ORIGIN#attr-iframe-sandbox-allow-scripts
v.allow-top-navigation-by-user-activation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-top-navigation-to-custom-protocols:~ORIGIN#attr-iframe-sandbox-allow-top-navigation-to-custom-protocols
v.allow-top-navigation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation

st.Image:~HEinput#image-button-state-(type=image)
st.Eager:~HTMLurl#attr-loading-eager-state

i.~fallback:#_object-fallback

	●用語
~load~eventを遅延し得る:#potentially-delays-the-load-event
利用は許容されて:#allowed-to-use
~iframe-srcdoc文書:#an-iframe-srcdoc-document
~iframe~load~event手続き:#iframe-load-event-steps
~iframe~loadは進捗-中か:#iframe-load-in-progress
~iframe~loadを黙らすか:#mute-iframe-load
~iframe属性~群を処理する:#process-the-iframe-attributes
~iframe~src属性を処理する:#shared-attribute-processing-steps-for-iframe-and-frame-elements

現在の~naviは~lazyに読込まれるか:#current-navigation-was-lazy-loaded
~iframeを~navigateする:#navigate-an-iframe-or-frame

作動中になれ:#concept-embed-active

~embed要素を設定しておく:#the-embed-element-setup-steps
~embed~task~source:#embed-task-source
内容の型を決定する:#concept-embed-type
~pluginなしを表示する:#display-no-plugin

	#process-iframe-initial-insertion

処理待ちな資源~計時の開始~時刻:#iframe-pending-resource-timing-start-time


	●用語HTML

寸法~属性:#dimension-attributes
~media要素:~HEmedia#media-element

~HTML要素~接続~後の手続き:~HTMLINFRA#html-element-post-connection-steps
~HTML要素~除去-時の手続き:~HTMLINFRA#html-element-removing-steps
文書の中へ挿入され:~HTMLINFRA#insert-an-element-into-a-document
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document
~plugin:~HTMLINFRA#plugin
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications

反映する:~HTMLcdom#reflect
既知な値のみに制限される:~HTMLcdom#limited-to-only-known-values

~Content-Type:~HTMLurl#content-type
~Content-Type~metadata:~HTMLurl#content-type
	資源の／~associated／明示的な ~Content-Type~metadata
~referrer施策~属性:~HTMLurl#referrer-policy-attribute
~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
妥当かつ空でない~URL（前後~空白~可）:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces
~lazyに読込むことになる:~HTMLurl#will-lazy-load-element-steps
~lazy読込ng属性:~HTMLurl#lazy-loading-attribute
~lazy読込n再開~手続き:~HTMLurl#lazy-load-resumption-steps
~lazyに読込んでいる要素の交差~観測を開始する:~HTMLurl#start-intersection-observing-a-lazy-loading-element
~about_blank に合致して:~HTMLurl#matches-about:blank
~about_srcdoc に合致して:~HTMLurl#matches-about:srcdoc

真偽-属性:~HTMLcms#boolean-attribute
~space等で分離された~token集合:~HTMLcms#set-of-space-separated-tokens
妥当な負でない整数:~HTMLcms#valid-non-negative-integer


分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~accessibilityの考慮点:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
埋込d内容:~HTMLdom#embedded-content-category
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
ヤリトリありな内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句ng内容:~HTMLdom#phrasing-content-2
~fallback内容:~HTMLdom#fallback-content
透過的な内容:~HTMLdom#transparent
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
表現-:~HTMLdom#represents
要素間~空白:~HTMLdom#inter-element-whitespace

文書:~HTMLdom#the-document-object
まだ初期~about_blank 文書で:~HTMLdom#still-on-its-initial-about:blank-document

~DOM操作~task~source:~WAPI#dom-manipulation-task-source
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
~event~loop:~WAPI#event-loop
~network用~task~source:~WAPI#networking-task-source
~queueされ:~WAPI#queue-a-task
~task~queue:~WAPI#task-queue
要素~taskを~queueする:~WAPI#queue-an-element-task
最初の段:~WAPI#step1
~task~source:~WAPI#task-source
~task:~WAPI#concept-task
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin

syn.~comment:~HTMLwriting#syntax-comments
syn.要素:~HTMLwriting#syntax-elements
~DOCTYPE:~HTMLwriting#syntax-doctype
終了~tag:~HTMLwriting#syntax-end-tag
	~HTMLwriting#syntax-tag-omission
~HTML構文:~HTMLwriting#syntax

~HTML構文解析器:~HTMLparsing#html-parser
完全に読込まれ:~HTMLlifecycle#completely-loaded
~load~eventを遅延する:~HTMLparsing#delay-the-load-event
~load~eventを遅延して:~HTMLparsing#delay-the-load-event
~load後~task用に準備済み:~HTMLparsing#ready-for-post-load-tasks
~open要素~stack:~HTMLparsing#stack-of-open-elements

拘束~検証~API:~HTMLforms#the-constraint-validation-api
~form所有者:~HTMLforms#form-owner

~formに所有され得る要素:~HEforms#form-associated-element

一過な作動化を有して:~HTMLinteraction#transient-activation

~XML構文解析器:~HTMLxml#xml-parser
具現化されて:~HTMLrendering#being-rendered

~navigable:~HTMLds#navigable
子~navigable:~HTMLds#child-navigable
内容~navigable:~HTMLds#content-navigable
新たな子~navigableを作成する:~HTMLds#create-a-new-child-navigable
子~navigableを破壊する:~HTMLds#destroy-a-child-navigable
~node~navigable:~HTMLds#node-navigable
広義-先祖~navigable群:~HTMLds#inclusive-ancestor-navigables
nav.作動中な文書:~HTMLds#nav-document
nav.作動中な~WindowProxy:~HTMLds#nav-wp
nav.辿可能な~navigable:~HTMLds#nav-traversable
nav.~load~event遅延-中か:~HTMLds#delaying-load-events-mode
全部的に作動中:~HTMLds#fully-active
補助~閲覧~文脈:~HTMLds#auxiliary-browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
内容~文書:~HTMLds#concept-bcc-content-document
内容~window:~HTMLds#content-window
妥当な~navigable~target名:~HTMLds#valid-navigable-target-name
nav.作動中な~window:~HTMLds#nav-window
破棄され:~HTMLds#a-browsing-context-is-discarded

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
非同一-生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
~iframe~sandbox法~flag集合:~ORIGIN#iframe-sandboxing-flag-set
~sandbox法~指令を構文解析する:~ORIGIN#parse-a-sandboxing-directive

~URLと履歴を更新する:~HTMLnav#url-and-history-update-steps

doc.許可~施策:~HTMLdom#concept-document-permissions-policy
~navigate:~HTMLnav#navigate
~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navi:~HTMLnav#navigate
hH.auto:~HTMLnav#navigationhistorybehavior-auto
hH.replace:~HTMLnav#navigationhistorybehavior-replace

	i.~referrer施策:~HTMLnav#navigation-referrer-policy
	i.文書~資源:~HTMLnav#navigation-resource
	i.応答:~HTMLnav#navigation-response
	i.履歴~取扱い:~HTMLnav#navigation-hh
	i.初期~挿入か:~HTMLnav#navigation-initial-insertion

外部~softwareに手渡す:~HTMLnav#hand-off-to-external-software

単純~dialogを示せない:~HTMLGAPI#cannot-show-simple-dialogs

	●用語他
~ASCII空白:~INFRA#ascii-whitespace
~ASCII~tabや~ASCII改行文字:~INFRA#ascii-tab-or-newline
~HTML名前空間:~INFRA#html-namespace

~URL~record:~URL1#concept-url
~URL:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser
url.~path:~URL1#concept-url-path
同等な~URL:~URL1#concept-url-equals

~fetch~scheme:~FETCH#fetch-scheme
~fetchする:~FETCH#concept-fetch
~fetch:~FETCH#concept-fetch
i.応答の処理n:~FETCH#process-response
~ok状態s:~FETCH#ok-status
要請:~FETCH#concept-request
応答:~FETCH#concept-response
~network~error:~FETCH#concept-network-error
~fetch計時~報:~FETCH#fetch-timing-info
fT.開始~時刻:~FETCH#fetch-timing-info-start-time
fT.終了~時刻:~FETCH#fetch-timing-info-end-time
応答~本体~報:~FETCH#response-body-info

rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~mode:~FETCH#concept-request-mode
rq.起動元~種別:~FETCH#request-initiator-type
rq.行先:~FETCH#concept-request-destination
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag

rs.~URL:~FETCH#concept-response-url

~MIME型:~MIMESNIFF#mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
算出された~MIME型:~MIMESNIFF#computed-mime-type
画像を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-images-specifically
~textか~binaryかを判別する規則:~MIMESNIFF#rules-for-text-or-binary
妥当な~MIME型~文字列:~MIMESNIFF#valid-mime-type

~eventを発火する:~DOM4#concept-event-fire
~HTML文書:~DOM4#html-document
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
~XML文書:~DOM4#xml-document
文書~要素:~DOM4#document-element
文書~内:~DOM4#in-a-document
~node文書:~DOM4#concept-node-document
~supportする~token集合:~DOM4#concept-supported-tokens
~shadow~tree:~DOM4#concept-shadow-tree
属性を名前空間と局所~名により取得する:~DOM4#concept-element-attributes-get-by-namespace
attr.局所~名:~DOM4#concept-attribute-local-name
attr.値:~DOM4#concept-attribute-value
属性~値を設定する:~DOM4#concept-element-attributes-set-value

信用-済みな型に準拠な文字列を取得する:~TRUSTED-TYPES#get-trusted-type-compliant-string

~referrer施策:~REFERRER-POLICY#referrer-policy

現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time

資源~計時を~markする:~RESOURCE-TIMING#mark-resource-timing

許可~施策:~PERMISSIONS-POLICY#permissions-policy
容器~施策:~PERMISSIONS-POLICY#container-policy
直列形の許可~施策:~PERMISSIONS-POLICY#serialized-permissions-policy
文書~内の特能は生成元~用に可能化されるか？:~PERMISSIONS-POLICY#is-feature-enabled
許可~施策~属性を処理する:~PERMISSIONS-POLICY#process-policy-attributes
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

生来な横幅:~CSSIMAGE#natural-width
生来な縦幅:~CSSIMAGE#natural-height
~CSS~pixel:~CSSVAL#px

●●words_table1
about_blank:about:blank
about_srcdoc:about:srcdoc

●●words_table



	●仕様
簡素:succinct:~
冗長:redundant:~
必要最小限:minimal:~
助け:help:~
誤解釈-:misinterpret:~
防ぐ:preventする:~
装う:pretendする:~
本当の:realな:~
準拠な:compliantな:準拠する

	-:possible
	任意選択で:may
	能力を備え:capable
	いまいましいもの:annoyance
	-:manner
	〜により制御される特能:-controlled-feature
	きちんと:well-
	注意／:notice／note
	暗黙に:by implication
	困難:quite hard
	よい:may
	更には、:furthermore
	でなくとも:despite
	になり得る:potentially
	無にする:altogether
	ようがされまいが:regardless of
	単に:just
	そこで:prematurely
	としていることもある:might say
	併用:in conjunction with

	できるようにする:enable
	適合しない:not 〜 conforming ／ non-conformant
	選り分ける:reason about
	優先される:takes priority
	課す:imposeする
	選べる:pick
	できない:unable
	ままにされる:remain
	まま:remaining
	とする:suppose
	しないことを勧める:ill-advised
	覚えておく:remember
	~~発揮:take


	●network／navi
DNS:
ok:
sniff:
lazy:
為す:makeする:~
load:
	~load後:post-load
unload:
補助:auxiliary::~

	●保安
	~secure化-:secured
探査-:probe::~
脆弱:vulnerable::~
被害:damage:~
	~URL資格証~利用:use-URL-credential
騙され:trickされ:~
突破-:break out:~
	~~軽くする:lift
malware::::マルウェア
仕向けれ:convinceでき:~
仕向けて:convinceして:~
黙らす:muteする::~

	●構文
DOCTYPE:
	QUOTATION MARK 
	AMPERSAND
	LESS-THAN SIGN
	CHARACTER TABULATION
	LINE FEED
	LF
	CARRIAGE RETURN
	CR
	大文字:uppercase letter
省略不可:omissibleでない:~
省略:omission:~
	-:tab
ampersand::::アンパサンド
open::::
生の:raw:~
直列形の:serialized::~::シリアル形の
	終端-:end:~

	●embed／UI／内容
Content-Type:
MathML:
iframe:
iframe-srcdoc:iframe srcdoc
embed:

popup::::ポップアップ
gadget::::ガジェット
再生器:player::~::プレイヤー

blog::::ブログ

分類:categories:~
分類-:categorize:~
	分類される:falls into 〜 categories
透過的:transparent::~
句ng:phrasing::句::フレージング
可触:palpable::~

広告:advertising:~
広告unit:ad unit:広告 unit::広告ブロック
投稿:post::~
横:horizontal::~
縦:vertical::~
解像度:resolution::~
online::::オンライン
伸張-:stretch::~
一過:transient::~
生来:natural::~

	なし:none

	●処理
増分的:incremental:~
再開:resumption::~
手渡す:hand offする:取り扱わせる
高分解能:high resolution::~
処理待ち:pending:~

	newly
	~access可能:accessible
	開始し直す:restart
	終:finish
	なった:become
	-:stopping
	でなくなった:stop
	回数を数える:count
	読み取り:reading
	時点で:marked as
	先送り可否:deferral
	この~algoの 〜 段~以降を走らす手続き:the rest of this algorithm starting with the step labeled 〜
	進捗-中:in progress

src:
srcdoc:
	%src:maybeURL
	%初期~挿入か:initialInsertion
	%再開~手続き:resumptionSteps
	%応答:res
	-:processResponseEndOfBody
	%~referrer施策:referrerPolicy
	%履歴~取扱い:historyHandling
	%子~文書:childDocument
	~srcdoc文字列:srcdocString
	%iframe:element
	%embed:element
	%object:element
	%大域~obj:global
	%~URL:url
	%~fallback計時~報:fallbackTimingInfo
	%挿入された~node:insertedNode
	%除去される~node:removedNode
	%準拠な文字列:compliantString

	●未分類
要素間:inter-element::~
	~popされ除かれ:popped off
WindowProxy:
代理-:proxy::~::プロキシ
名目上の:nominal:~
代行業者:broker:~

	instance化:instantiate
	jump
	time
	~~不正な:malformed
	し直す:again
	同時に:simultaneous
	~iframe:fragment
	~~地点:point
	再度:re
	-:opt
	-:wherein
	-:straight
	-:leading
	-:followed by
	O3D
	GOTO:jump to the step below labeled
	-:name-value
	地図:map
	Geolocation
	`可能化される^i:"Enabled"
	-:exist
	送る:send
	現れ:appear
	~~供給-:furnish
	見られ:view


	●指示語
出自の:originating:~

	~~追加の:extra
	この時点で／今:now
	自身のみでは:on its own
	また:once more
	-:aforementioned
	とも:together
	どちらかは:At least
	一部:part of
	二重に:doubly
	次:next
	異なる／相異なる:different
	何か:anything
	対象に:target
	何も〜しない:nothing
	以前に:previously
	最後に:finally
	初めに:originally
	前の:previous
	様々な:various
	similar
	similarly
	他所へ:away
	1 列目
	以外
	以上
	一方
	次第
	時点
	場合


●●html_code_list



■iframe-1
<article>
 <h1>自分の雑誌ができた</h1>
 <p>頑張った甲斐あって、版元を見つけられた。ついに自分の雑誌を持てるようになった。最高だ！最初の号は９月になるよ。フードをゲットしたりボックスの中を見て回ることについての記事だ。楽しみだよ。</p>
 <footer>
  <p><a href="/users/cap">cap</a> さん（投稿： 1 時間前）
 </footer>
 <article>
  <footer> 13 分前, <a href="/users/ch">ch</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>表紙絵はできた？"></iframe>＞
 </article>
 <article>
  <footer> 9 分前, <a href="/users/cap">cap</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>もちろん、<a href=&quot;/gallery?mode=cover&amp;amp;page=1&quot;>僕のギャラリー</a>で見れるよ。"></iframe>＞
 </article>
 <article>
  <footer> 5 分前, <a href="/users/ch">ch</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>それ、 earl の食卓だな。
<p>次の表紙絵には earl&amp;amp;me を入れないとな。"></iframe>＞
 </article>

<article>
 <h1>I got my own magazine!</h1>
 <p>After much effort, I've finally found a publisher, and so now I
 have my own magazine! Isn't that awesome?! The first issue will come
 out in September, and we have articles about getting food, and about
 getting in boxes, it's going to be great!</p>
 <footer>
  <p>Written by <a href="/users/cap">cap</a>, 1 hour ago.
 </footer>
 <article>
  <footer> Thirteen minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>did you get a cover picture yet?"></iframe>
 </article>
 <article>
  <footer> Nine minutes ago, <a href="/users/cap">cap</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>Yeah, you can see it <a href="/gallery?mode=cover&amp;amp;page=1">in my gallery</a>."></iframe>
 </article>
 <article>
  <footer> Five minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>hey that's earl's table.
<p>you should get earl&amp;amp;me on the next cover."></iframe>
 </article>


■iframe-2
<p>どんな内容だろうが恐るるに足らない。何も編集を加えていない投稿内容はここにある：</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>

<p>We're not scared of you! Here is your content, unedited:</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>


■iframe-3
<iframe sandbox="allow-same-origin allow-forms allow-scripts"
        src="https://maps.example.com/embedded.html"></iframe>

■iframe-4
<iframe sandbox="allow-same-origin allow-forms" src=%B ></iframe>

■iframe-5
<iframe sandbox="allow-scripts" src=%C ></iframe>

■iframe-6
<a href=%D >Link</a>

■iframe-7
<iframe src="https://maps.example.com/" allow="geolocation"></iframe>

■iframe-8
<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">私的投稿</a></p>
 </header>
 <p>Check out my new ride!</p>
 ＜<iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>＞
</article>

<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">Private Post</a></p>
 </header>
 <main>
  <p>Check out my new ride!</p>
  <iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>
 </main>
</article>

■iframe-9
<iframe src="https://ads.example.com/?customerid=923513721&amp;format=banner"
        width="468" height="60"></iframe>

■object-2
<figure>
 <object data="clock.html"></object>
 <figcaption>自作 HTML 時計</figcaption>
</figure>

 <figcaption>My HTML Clock</figcaption>

■mathml-1
<!DOCTYPE html>
<html lang="en">
 <head>
  <title>二次方程式の解の公式</title>
 </head>
 <body>
  <h1>二次方程式の解の公式</h1>
  <p>
   <math>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo form="prefix">−</mo> <mi>b</mi>
      <mo>±</mo>
      <msqrt>
       <msup> <mi>b</mi> <mn>2</mn> </msup>
       <mo>−</mo>
       <mn>4</mn> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mi>c</mi>
      </msqrt>
     </mrow>
     <mrow>
      <mn>2</mn> <mo>⁢</mo> <mi>a</mi>
     </mrow>
    </mfrac>
   </math>
  </p>
 </body>
</html>

The quadratic formula


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~HTMLLS/#toc-semantics">§ The elements of HTML</a>
内の
<a href="~SPEC_URL">iframe, embed, object 要素</a>
各節,
<a href="~HTMLLS/embedded-content-other.html">その他の埋め込み内容に関係する節</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>
</head>
<body>

<header>
	<hgroup>
<h1>HTML — iframe, embed, object 要素, 他</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

			</section>
			<section id="the-iframe-element">
<h4 title="The iframe element">4.8.5. `iframe^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$
◎
Flow content.
</dd>
	<dd>
`句ng内容$
◎
Phrasing content.
</dd>
	<dd>
`埋込d内容$
◎
Embedded content.
</dd>
	<dd>
`ヤリトリありな内容$
◎
Interactive content.
</dd>
	<dd>
`可触~内容$
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aF
— 埋込む資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`srcdoc$aF
— `iframe$e 内に具現化する文書
◎
srcdoc — A document to render in the iframe
</dd>
	<dd>
`name$aF
— `内容~navigable$の名前
◎
name — Name of content navigable
</dd>
	<dd>
`sandbox$aF
— 入子な内容に対する~security規則
◎
sandbox — Security rules for nested content
</dd>
	<dd>
`allow$aF
— `iframe$e の内容に適用されることになる`許可~施策$
◎
allow — Permissions policy to be applied to the iframe's contents
</dd>
	<dd>
`allowfullscreen$aF
— `iframe$e の内容が `requestFullscreen()$m を利用するのを許容するかどうか
◎
allowfullscreen — Whether to allow the iframe's contents to use requestFullscreen()
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
`referrerpolicy$aF
— この要素により起動された`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>
	<dd>
`loading$aF
— 読み込みの先送り可否を決定するときに利用される。
◎
loading — Used when determining loading deferral
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`iframe$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLIFrameElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$, `ReflectURL$] attribute USVString `src@mF;
  [`CEReactions$] attribute `TrustedHTML$I `srcdoc$mF;
  [`CEReactions$, `Reflect$] attribute DOMString `name@mF;
  [SameObject, PutForwards=`value$m, `Reflect$] readonly attribute `DOMTokenList$I `sandbox@mF;
  [`CEReactions$, `Reflect$] attribute DOMString `allow@mF;
  [`CEReactions$, `Reflect$] attribute boolean `allowFullscreen@mF;
  [`CEReactions$, `Reflect$] attribute DOMString `width@mF;
  [`CEReactions$, `Reflect$] attribute DOMString `height@mF;
  [`CEReactions$] attribute DOMString `referrerPolicy$mF;
  [`CEReactions$] attribute DOMString `loading$mF;
  readonly attribute `Document$I? `contentDocument$mF;
  readonly attribute `WindowProxy$I? `contentWindow$mF;
  `Document$I? `getSVGDocument$m();

  // `HTMLIFrameElement$obsMb
};
</pre>

	</dd>
</dl>

<p>
`iframe$e 要素は、
自身の`内容~navigable$を`表現-$する。
◎
The iframe element represents its content navigable.
</p>

<p>
`src@aF
属性は、
要素の`内容~navigable$が包含することになる~pageの`~URL$を与える。
この属性が在る場合の値は、
`妥当かつ空でない~URL（前後~空白~可）$でなければナラナイ。
`iframe$e 要素が `itemprop$a 属性を有する場合、
この属性も有していなければナラナイ。
◎
The src attribute gives the URL of a page that the element's content navigable is to contain. The attribute, if present, must be a valid non-empty URL potentially surrounded by spaces. If the itemprop attribute is specified on an iframe element, then the src attribute must also be specified.
</p>

<p>
`srcdoc@aF
属性は、
要素の`内容~navigable$が包含することになる内容を与える。
この属性の値は、
`~iframe-srcdoc文書$を`構築する＠~HTMLnav#create-navigation-params-from-a-srcdoc-resource$ときに利用される。
◎
The srcdoc attribute gives the content of the page that the element's content navigable is to contain. The value of the attribute is used to construct＼
</p>

<p>
`~iframe-srcdoc文書@
とは、
次を満たす`文書$である
⇒
その`~URL$docは，`~about_srcdoc に合致して$いる
◎
an iframe srcdoc document, which is a Document whose URL matches about:srcdoc.
</p>

<p class="trans-note">【
そのような文書は、
`srcdoc$aF 以外からも`作成され得る＠~HTMLissue/9514$。
】</p>

<p>
`srcdoc$aF 属性に指定する値は、
次に与える順による構文-成分からなる`~HTML構文$を利用しなければナラナイ：
◎
The srcdoc attribute, if present, must have a value using the HTML syntax that consists of the following syntactic components, in the given order:
</p>

<ol>
	<li>
0 個~以上の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
	<li>
0 〜 1 個の `~DOCTYPE$
◎
Optionally, a DOCTYPE.
</li>
	<li>
0 個~以上の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
	<li>
`html$e `要素$synの形で与えられる`文書~要素$
◎
The document element, in the form of an html element.
</li>
	<li>
0 個~以上の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
</ol>

<p class="note">注記：
上の要件は、
`~XML文書$にも適用される。
◎
The above requirements apply in XML documents as well.
</p>

<div class="example">
<p>
次の~blogでは、
`srcdoc$aF, 下に述べる `sandbox$aF
両~属性を併用して，この特能を~supportする~UAの利用者に［
~blog投稿~commentによる~script注入から保護する~~追加の層
］を伴わせて供している：
◎
Here a blog uses the srcdoc attribute in conjunction with the sandbox attribute described below to provide users of user agents that support this feature with an extra layer of protection from script injection in the blog post comments:
</p>

`iframe-1^xCode

<p>
引用符は~escapeされる必要があることに加え
（さもなければ， `srcdoc$aF 属性は そこで終端してしまう）、
~sandbox化された内容（例：~URLや注釈文~内）における生の~ampersand（ `&amp;^l ）は，<em>二重に</em>~escapeされる必要があることにも注意
— `srcdoc$aF 属性が初めに構文解析されるときに ~ampersandが保全され，その後 ~sandbox化された内容がまた構文解析されるときにも ~ampersandが誤解釈されるのを防ぐため。
◎
Notice the way that quotes have to be escaped (otherwise the srcdoc attribute would end prematurely), and the way raw ampersands (e.g. in URLs or in prose) mentioned in the sandboxed content have to be doubly escaped — once so that the ampersand is preserved when originally parsing the srcdoc attribute, and once more to prevent the ampersand from being misinterpreted when parsing the sandboxed content.
</p>

<p>
更には，
`srcdoc$aF 属性~内の~markupは、
文書~全体を表現しているにもかかわらず，~~比較的 簡素にできることにも注意
— ［
`html$e, `head$e, `body$e
］要素の`開始~tag／終了~tagは省略可能＠~HTMLwriting#syntax-tag-omission$であり
（省略されても，依然として暗黙に在る），
`~iframe-srcdoc文書$においては［
`~DOCTYPE$ ／ `title$e 要素
］も省略可能なので、
構文~内に~literalに現れる必要があるのは， `body$e 要素の内容のみになるので。
◎
Furthermore, notice that since the DOCTYPE is optional in iframe srcdoc documents, and the html, head, and body elements have optional start and end tags, and the title element is also optional in iframe srcdoc documents, the markup in a srcdoc attribute can be relatively succinct despite representing an entire document, since only the contents of the body element need appear literally in the syntax. The other elements are still present, but only by implication.
</p>
</div>

<div class="note">
<p>注記：
`~HTML構文$においては、
作者が覚えておく必要があるのは，次を行うことに限られる：
</p>
<ul>
	<li>
文字 `0022^U `"^smb を利用して，属性の内容を包装する。
</li>
	<li>
次に、
文字 `0026^U `&amp;^smb をすべて~escapeしてから，文字 `0022^U `"^smb をすべて~escapeする
（逆順に行うと、
引用符は二重に~escapeされ， `&amp;quot;^l から `&amp;amp;quot;^l になってしまう）。
</li>
	<li>
`sandbox$aF 属性を指定して，
内容の安全な埋込みを確保する。
</li>
</ul>

◎
In the HTML syntax, authors need only remember to use U+0022 QUOTATION MARK characters (") to wrap the attribute contents and then to escape all U+0026 AMPERSAND (&amp;) and U+0022 QUOTATION MARK (") characters, and to specify the sandbox attribute, to ensure safe embedding of content. (And remember to escape ampersands before quotation marks, to ensure quotation marks become &amp;quot; and not &amp;amp;quot;.)
</div>

 <p class="note">注記：
~XMLにおいては、
`属性~値の正規化＠~TR/xml/#AVNormalize$を防止するため，
`003C^U `&lt;^smb
も~escapeされる必要がある。
~XMLの一部の空白~文字
— 特定的には，`~ASCII~tabや~ASCII改行文字$ —
も~escapeされる必要がある。
`XML$r
◎
In XML the U+003C LESS-THAN SIGN character (&lt;) needs to be escaped as well. In order to prevent attribute-value normalization, some of XML's whitespace characters — specifically U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), and U+000D CARRIAGE RETURN (CR) — also need to be escaped. [XML]
</p>

<p class="note">注記：
`src$aF, `srcdoc$aF
両~属性とも指定された場合、
`srcdoc$aF 属性が優先される。
これにより，作者は、
`srcdoc$aF 属性を~supportしない旧来の~UA用に~fallback `~URL$を供せるようになる。
◎
If the src attribute and the srcdoc attribute are both specified together, the srcdoc attribute takes priority. This allows authors to provide a fallback URL for legacy user agents that do not support the srcdoc attribute.
</p>

<hr>

<div class="algo">
<p>
`iframe$e 用の`~HTML要素~接続~後の手続き$は、
所与の
( %挿入された~node )
に対し：
◎
The iframe HTML element post-connection steps, given insertedNode, are:
</p>
<ol>
	<li>
`新たな子~navigableを作成する$( %挿入された~node )
◎
Create a new child navigable for insertedNode.
</li>
	<li>
~IF［
%挿入された~node は `sandbox$aF 属性を有する
］
⇒
`~sandbox法~指令を構文解析する$( %挿入された~node の `sandbox$aF 属性の値, %挿入された~node の`~iframe~sandbox法~flag集合$ )
◎
If insertedNode has a sandbox attribute, then parse the sandboxing directive given the attribute's value and insertedNode's iframe sandboxing flag set.
</li>
	<li>
`~iframe属性~群を処理する$( %挿入された~node, ~T )
◎
Process the iframe attributes for insertedNode, with initialInsertion set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
`iframe$e 用の`~HTML要素~除去-時の手続き$は、
所与の
( %除去される~node )
に対し
⇒
`子~navigableを破壊する$( %除去される~node )
◎
The iframe HTML element removing steps, given removedNode, are to destroy a child navigable given removedNode.
</p>

<p class="note">注記：
これが起きたときは、
`unload$et ~eventは発火されない
（当の要素の`内容~文書$は、
<em>
`~unloadされる＠~HTMLlifecycle#unload-a-document$ことなく，
`破壊される＠~HTMLds#destroy-a-document$【！~HTMLds#destroy-a-child-navigable】
</em>）。
◎
This happens without any unload events firing (the element's content document is destroyed, not unloaded).
</p>
</div>

<p class="XXX">
上により，
`iframe$e は`~shadow~tree$内にある間も処理されるが、
その挙動を成す他のいくつかの側面は，
~shadow~treeに関してきちんと定義されていない。
より詳細は、
`課題 #763＠~HTMLissue/763$
を見よ。
◎
Although iframes are processed while in a shadow tree, per the above, several other aspects of their behavior are not well-defined with regards to shadow trees. See issue #763 for more detail.
</p>

<div class="algo">
<p>
［
`iframe$e 要素 %iframe の`内容~navigable$ ~NEQ ~NULL
］の下では、
~UAは，次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
%iframe の `srcdoc$aF 属性が［
設定- ／ 変更- ／ 除去-
］されたときは
⇒
`~iframe属性~群を処理する$( %iframe )
◎
Whenever an iframe element with a non-null content navigable has its srcdoc attribute set, changed, or removed, the user agent must process the iframe attributes.
</li>
	<li>
%iframe の `src$aF 属性が［
設定- ／ 変更- ／ 除去-
］されたときは
⇒
~IF［
%iframe は `srcdoc$aF 属性を有していない
］
⇒
`~iframe属性~群を処理する$( %iframe )
◎
Similarly, whenever an iframe element with a non-null content navigable but with no srcdoc attribute specified has its src attribute set, changed, or removed, the user agent must process the iframe attributes.
</li>
</ul>
</div>

<div class="algo">
<p>
`~iframe属性~群を処理する@
~algoは、
所与の
( `iframe$e 要素 %iframe, 真偽値 <span id="process-iframe-initial-insertion">%初期~挿入か</span> ~DF ~F )
に対し：
◎
To process the iframe attributes for an element element, with an optional boolean initialInsertion (default false):
</p>
<ol>
	<li>
<p>
~IF［
%iframe は `srcdoc$aF 属性を有する
］：
◎
If element's srcdoc attribute is specified, then:
</p>
		<ol>
			<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~F
◎
Set element's current navigation was lazy loaded boolean to false.
</li>
			<li>
<p>
~IF［
`~lazyに読込むことになる$( %iframe ) ~EQ ~T
］：
◎
If the will lazy load element steps given element return true, then:
</p>
				<ol>
					<li>
%iframe の`~lazy読込n再開~手続き$ ~SET この~algoの `srcdoc 資源へ~navigateする^i 段~以降を走らす手続き
◎
Set element's lazy load resumption steps to the rest of this algorithm starting with the step labeled navigate to the srcdoc resource.
</li>
					<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~T
◎
Set element's current navigation was lazy loaded boolean to true.
</li>
					<li>
`~lazyに読込んでいる要素の交差~観測を開始する$( %iframe )
◎
Start intersection-observing a lazy loading element for element.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
<div class="p">
<p>
`srcdoc 資源へ~navigateする^i：
</p>
				<ol>
					<li>
`~iframeを~navigateする$( %iframe, `~about_srcdoc$sc, 空~文字列, %iframe の `srcdoc$aF 属性の値 )
</li>
					<li>
~RET
</li>
				</ol>
◎
Navigate to the srcdoc resource: Navigate an iframe or frame given element, about:srcdoc, the empty string, and the value of element's srcdoc attribute.
</div>

<p>
この段による結果の`文書$は、
`~iframe-srcdoc文書$と見なすモノトスル。
◎
The resulting Document must be considered an iframe srcdoc document.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%~URL ~LET `~iframe~src属性を処理する$( %iframe, %初期~挿入か )
◎
Let url be the result of running the shared attribute processing steps for iframe and frame elements given element and initialInsertion.
</li>
			<li>
~IF［
%~URL ~EQ ~NULL
］
⇒
~RET
◎
If url is null, then return.
</li>
			<li>
<p>
~IF［
%~URL は`~about_blank に合致して$いる
］~AND［
%初期~挿入か ~EQ ~T
］：
◎
If url matches about:blank and initialInsertion is true, then:
</p>
				<ol>
					<li>
`~iframe~load~event手続き$( %iframe )
◎
Run the iframe load event steps given element.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%~referrer施策 ~LET %iframe の `referrerpolicy$aF 内容~属性の現在の状態
◎
Let referrerPolicy be the current state of element's referrerpolicy content attribute.
</li>
			<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~F
◎
Set element's current navigation was lazy loaded boolean to false.
</li>
			<li>
<p>
~IF［
`~lazyに読込むことになる$( %iframe ) ~EQ ~T
］：
◎
If the will lazy load element steps given element return true, then:
</p>
				<ol>
					<li>
%iframe の`~lazy読込n再開~手続き$ ~SET この~algoの `~navigateする^i 段~以降を走らす手続き
◎
Set element's lazy load resumption steps to the rest of this algorithm starting with the step labeled navigate.
</li>
					<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~T
◎
Set element's current navigation was lazy loaded boolean to true.
</li>
					<li>
`~lazyに読込んでいる要素の交差~観測を開始する$( %iframe )
◎
Start intersection-observing a lazy loading element for element.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
`~navigateする^i
⇒
`~iframeを~navigateする$( %iframe, %~URL, %~referrer施策 )
◎
Navigate: Navigate an iframe or frame given element, url, and referrerPolicy.
</li>
		</ol>
	</li>
</ol>
</div>

<p class="trans-note">【
以下に与える［
`~iframe~src属性を処理する$,
`~iframeを~navigateする$
］~algoは、
実際には `frame$e 要素からも利用される
— 原文では，そのことも表すよう もっと長い名前が与えられているが、
この訳では，命名を簡素化する
（廃用にされた `frame^e 要素を和訳するつもりはないので）。
】</p>

<div class="algo">
<p>
`~iframe~src属性を処理する@
~algoは、
所与の
( %iframe, 真偽値 %初期~挿入か )
に対し：
◎
The shared attribute processing steps for iframe and frame elements, given an element element and a boolean initialInsertion, are:
</p>
<ol>
	<li>
%~URL ~LET `~URL~record$ `~about_blank$sc
◎
Let url be the URL record about:blank.
</li>
	<li>
<p>
~IF［
%iframe は `src$aF 属性を有していて，その値 %src ~NEQ 空~文字列
］：
◎
If element has a src attribute specified, and its value is not the empty string, then:
</p>
		<ol>
			<li>
%src ~SET `~URLを符号化法の下で相対的に構文解析する$( %src, %iframe の`~node文書$ )
◎
Let maybeURL be the result of encoding-parsing a URL given that attribute's value, relative to element's node document.
</li>
			<li>
~IF［
%src ~NEQ `失敗^i
］
⇒
%~URL ~SET %src
◎
If maybeURL is not failure, then set url to maybeURL.
</li>
		</ol>
	</li>
	<li>
%iframe の`~node~navigable$の`広義-先祖~navigable群$を成す
~EACH( %~navigable )
に対し
⇒
~IF［
( %~navigable にて`作動中な文書$navの`~URL$doc, %~URL )
は，`素片は除外する^i 下で`同等な~URL$である
］
⇒
~RET ~NULL
◎
If the inclusive ancestor navigables of element's node navigable contains a navigable whose active document's URL equals url with exclude fragments set to true, then return null.
</li>
	<li>
<p>
~IF［
%~URL は`~about_blank に合致して$いる
］~AND［
%初期~挿入か ~EQ ~T
］
⇒
`~URLと履歴を更新する$( %iframe の`内容~navigable$にて`作動中な文書$nav, %~URL )
◎
If url matches about:blank and initialInsertion is true, then perform the URL and history update steps given element's content navigable's active document and url.
</p>

<p class="note">注記：
この段は、
%~URL が `about:blank?foo^l の様な何かである事例で必要yある。
%~URL は単に素な `~about_blank^sc の場合、
この段は何もしない。
◎
This is necessary in case url is something like about:blank?foo. If url is just plain about:blank, this will do nothing.
</p>
	<li>
~RET %~URL
◎
Return url.
</li>
</ol>
</div>

<div class="algo">
<p>
`~iframeを~navigateする@
~algoは、
所与の
⇒＃
%iframe,
`~URL$ %~URL,
`~referrer施策$ %~referrer施策,
文字列 %~srcdoc文字列 ~DF ~NULL
真偽値 %初期~挿入か ~DF ~F
◎終
に対し：
◎
To navigate an iframe or frame given an element element, a URL url, a referrer policy referrerPolicy, an optional string-or-null srcdocString (default null), and an optional boolean initialInsertion (default false):
</p>
<ol>
	<li>
%履歴~取扱い ~LET `auto$hH
◎
Let historyHandling be "auto".
</li>
	<li>
%~navigable ~LET %iframe の`内容~navigable$
◎
↓</li>
	<li>
~IF［
%~navigable にて`作動中な文書$navは`完全に読込まれ$ていない
］
⇒
%履歴~取扱い ~SET `replace$hH
◎
If element's content navigable's active document is not completely loaded, then set historyHandling to "replace".
</li>
	<li>
~IF［
%iframe は `iframe$e である
］
⇒
%iframe の`処理待ちな資源~計時の開始~時刻$ ~SET `現在の高分解能~時刻$( %iframe の`~node文書$に`関連な大域~obj$ )
◎
If element is an iframe, then set element's pending resource-timing start time to the current high resolution time given element's node document's relevant global object.
</li>
	<li>
`~navigableを~URLへ~navigateする$( %~navigable, %~URL, %iframe の`~node文書$ )
— 次も与える下で
⇒＃
`履歴~取扱い^i ~SET %履歴~取扱い,
`~referrer施策^i ~SET %~referrer施策,
`文書~資源^i ~SET %~srcdoc文字列,
`初期~挿入か^i ~SET %初期~挿入か
◎
Navigate element's content navigable to url using element's node document, with historyHandling set to historyHandling, referrerPolicy set to referrerPolicy, documentResource set to srcdocString, and initialInsertion set to initialInsertion.
</li>
</ol>
</div>

<p>
各`文書$は、
`~iframe~loadは進捗-中か@
,
`~iframe~loadを黙らすか@
を有する
— いずれも、
真偽値をとり，当の文書の作成-時には ~F になるモノトスル。
◎
Each Document has an iframe load in progress flag and a mute iframe load flag. When a Document is created, these flags must be unset for that Document.
</p>

<div class="algo">
<p>
`~iframe~load~event手続き@
は、
所与の
( `iframe$e 要素 %iframe )
に対し：
◎
To run the iframe load event steps, given an iframe element element:
</p>
<ol>
	<li>
%~navigable ~LET %iframe の`内容~navigable$
◎
↓</li>
	<li>
~Assert：
%~navigable ~NEQ ~NULL
◎
Assert: element's content navigable is not null.
</li>
	<li>
%子~文書 ~LET %~navigable にて`作動中な文書$nav
◎
Let childDocument be element's content navigable's active document.
</li>
	<li>
~IF［
%子~文書 の`~iframe~loadを黙らすか$ ~EQ ~T
］
⇒
~RET
◎
If childDocument has its mute iframe load flag set, then return.
</li>
	<li>
<p>
~IF［
%iframe の`処理待ちな資源~計時の開始~時刻$ ~NEQ ~NULL
］：
◎
If element's pending resource-timing start time is not null, then:
</p>
		<ol>
			<li>
%大域~obj ~LET %iframe の`~node文書$に`関連な大域~obj$
◎
Let global be element's node document's relevant global object.
</li>
			<li>
%~fallback計時~報 ~LET 新たな`~fetch計時~報$
— その
⇒＃
`開始~時刻$fT ~SET %iframe の`処理待ちな資源~計時の開始~時刻$,
`終了~時刻$fT ~SET `現在の高分解能~時刻$( %大域~obj )
◎
Let fallbackTimingInfo be a new fetch timing info whose start time is element's pending resource-timing start time and whose response end time is the current high resolution time given global.
</li>
			<li>
`資源~計時を~markする$( ↓ )
⇒＃
%~fallback計時~報,
%~URL,
"`iframe$e",
%大域~obj,
空~文字列,
新たな`応答~本体~報$,
0
◎
Mark resource timing given fallbackTimingInfo, url, "iframe", global, the empty string, a new response body info, and 0.
</li>
			<li>
%iframe の`処理待ちな資源~計時の開始~時刻$ ~SET ~NULL
◎
Set element's pending resource-timing start time to null.
</li>
		</ol>
	</li>
	<li>
%子~文書 の`~iframe~loadは進捗-中か$ ~SET ~T
◎
Set childDocument's iframe load in progress flag.
</li>
	<li>
`~eventを発火する$( %iframe, `load$et )
◎
Fire an event named load at element.
</li>
	<li>
%子~文書 の`~iframe~loadは進捗-中か$ ~SET ~F
◎
Unset childDocument's iframe load in progress flag.
</li>
</ol>
</div>

<p class="warning">
これを~scriptingと併用すれば、
局所~networkの~HTTP~serverの~URL空間を探査する攻撃にも利用できる。
~UAは、
これを軽減するため，上に述べたものより厳密な［
`非同一-生成元$に対する~access制御~用の施策
］を実装してもヨイ
— が，あいにく そのような施策は、
概して，既存の~web内容と互換にならない。
◎
This, in conjunction with scripting, can be used to probe the URL space of the local network's HTTP servers. User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing web content.
</p>

<p>
所与の要素~型が
`~load~eventを遅延し得る@
ならば、
~UAは，そのような要素~型の各 %要素 に対し、［
%要素 の`内容~navigable$ %~navigable が ~OR↓ を満たしている
］間は，
%要素 の`~node文書$の`~load~eventを遅延する$モノトスル：
◎
If an element type potentially delays the load event, then for each element element of that type, the user agent must delay the load event of element's node document if element's content navigable is non-null and any of the following are true:
</p>
<ul>
	<li>
%~navigable にて`作動中な文書$navは`~load後~task用に準備済み$でない
◎
element's content navigable's active document is not ready for post-load tasks;
</li>
	<li>
%~navigable の`~load~event遅延-中か$nav ~EQ ~T
◎
element's content navigable's is delaying load events is true; or
</li>
	<li>
%~navigable にて`作動中な文書$navの`~load~eventを遅延して$いる何かがある
◎
anything is delaying the load event of element's content navigable's active document.
</li>
</ul>

<p class="note">注記：
`load$et ~eventの取扱い中に %~navigable が再度`~navigate$された場合、
それにより更に`~load~eventを遅延する$ことになる。
◎
If, during the handling of the load event, element's content navigable is again navigated, that will further delay the load event.
</p>

<p>
各 `iframe$e 要素には
`現在の~naviは~lazyに読込まれるか@
が結付けられる
— それは、
真偽値をとり，
初期~時は ~F とする。
それは、
`~iframe属性~群を処理する$中で［
~T／~F
］に設定される。
◎
Each iframe element has an associated current navigation was lazy loaded boolean, initially false. It is set and unset in the process the iframe attributes algorithm.
</p>

<p>
`iframe$e 要素は、［
`現在の~naviは~lazyに読込まれるか$ ~EQ ~F
］ならば，`~load~eventを遅延し得る$とする。
◎
An iframe element whose current navigation was lazy loaded boolean is false potentially delays the load event.
</p>

<p>
各 `iframe$e 要素には
`処理待ちな資源~計時の開始~時刻@
が結付けられる
— それは、［
~NULL ／ `DOMHighResTimeStamp$I
］をとり，
初期~時は ~NULL とする。
◎
Each iframe element has an associated null or DOMHighResTimeStamp pending resource-timing start time, initially set to null.
</p>

<p class="note">注記：
当の要素†の作成-時に，［
`srcdoc$aF 属性を有してなかった
］~AND［
`src$aF 属性を有してなかったか, 有していたが その値を成す`~URLを符号化法の下で相対的に構文解析する$のに失敗した
］場合、
要素の`内容~navigable$は，`まだ初期~about_blank 文書で$あり続けることになる。
【† `iframe^e 要素に限られない？ — この注記は、
過去には，他の要素にも適用される “`~load~eventを遅延し得る$” のすぐ後に置かれていたので。】
◎
If, when the element is created, the srcdoc attribute is not set, and the src attribute is either also not set or set but its value cannot be parsed, the element's content navigable will remain at the initial about:blank Document.
</p>

<p class="note">注記：
利用者がこの~page【 `~about_blank^sc に限られない？】から他所へ`~navigate$した場合、
`iframe$e 要素の`内容~navigable$にて`作動中な~WindowProxy$navは，
新たな`文書$用の新たな`~window$を代理することになるが、
要素の `src$aF 属性は変化しない。
◎
If the user navigates away from this page, the iframe's content navigable's active WindowProxy object will proxy new Window objects for new Document objects, but the src attribute will not change.
</p>

<hr>

<p>
`name@aF
属性に指定する値は、
`妥当な~navigable~target名$でなければナラナイ。
その値は、
当の `iframe$e 要素の`内容~navigable$に名前を与えるために利用される
— それが`作成され＠~HTMLds#create-a-new-child-navigable$る時点で，この属性が在るならば。
◎
The name attribute, if present, must be a valid navigable target name. The given value is used to name the element's content navigable if present when that is created.
</p>

<hr>

<p>
`iframe$e 要素に
`sandbox@aF
属性が指定された場合、
要素が~hostする内容に対し，~~追加の制約の集合を可能化する。
指定する値は、［
`~space等で分離された~token集合$（大小無視で一意）
］でなければナラナイ。
下の表tの 1 列目に挙げる~keyword値が~tokenとして許容される。
◎
The sandbox attribute, when specified, enables a set of extra restrictions on any content hosted by the iframe. Its value must be an unordered set of unique space-separated tokens that are ASCII case-insensitive. The allowed values are:
• allow-downloads
• allow-forms
• allow-modals
• allow-orientation-lock
• allow-pointer-lock
• allow-popups
• allow-popups-to-escape-sandbox
• allow-presentation
• allow-same-origin
• allow-scripts
• allow-top-navigation
• allow-top-navigation-by-user-activation
• allow-top-navigation-to-custom-protocols
</p>

<p>
この属性が設定された下では、
要素により埋込まれる内容は，一意な`不透明な生成元$に属するものと扱われ、
それにより，［
~form, ~script, 様々な悩ましいものになり得る~API
］は不能化され,
~linkに対しては 他の`~navigable$を~targetにすることは防止される。
加えて，各種~keywordには、
これらの制約の一部を緩めるような効果がある：
◎
When the attribute is set, the content is treated as being from a unique opaque origin, forms, scripts, and various potentially annoying APIs are disabled, and links are prevented from targeting other navigables.＼
</p>

<div>
<table>
<caption>`sandbox$aF 属性に指定できる~keywordとその効果</caption>
<thead>
<tr><th>~keyword
<td>効果
【詳細は、`§ ~sandbox法＠~ORIGIN#sandboxing$を見よ】
<tbody>

<tr><td>`allow-same-origin$v
<td>内容を`不透明な生成元$に属するよう強制する代わりに，その本当の生成元に属するものと扱われるようにする

<tr><td>`allow-top-navigation$v
<td>内容が その`辿可能な~navigable$navを`~navigate$できるようにする

<tr><td>`allow-top-navigation-by-user-activation$v
<td>`allow-top-navigation$v と類似に挙動するが、
そのような`~navi$を許容するのを［
当の`~navigable$【！閲覧~文脈】にて`作動中な~window$navが`一過な作動化を有して$いるとき
］に限るようにする

<tr><td>`allow-top-navigation-to-custom-protocols$v
<td>非`~fetch~scheme$へ向かう~naviを`外部~softwareに手渡す$ことを可能化し直す

<tr><td>`allow-forms$v
<td>~formを可能化し直す

<tr><td>`allow-modals$v
<td>~modal~dialogを可能化し直す

<tr><td>`allow-orientation-lock$v
<td>~screen方位~lockを可能化し直す
`SCREENORIENTATION$r

<tr><td>`allow-pointer-lock$v
<td>~pointer~lock~APIを可能化し直す
`POINTERLOCK$r

<tr><td>`allow-popups$v
<td>~popupを可能化し直す

<tr><td>`allow-presentation$v
<td>呈示~APIを可能化し直す
`PRESENTATION$r

<tr><td>`allow-scripts$v
<td>~scriptを可能化し直す

<tr><td>`allow-popups-to-escape-sandbox$v
<td>~sandbox化されない`補助~閲覧~文脈$の作成を可能化し直す

<tr><td>`allow-downloads$v
<td>~downloadを遂行することを内容に許容する
</table>

◎
The allow-same-origin keyword causes the content to be treated as being from its real origin instead of forcing it into an opaque origin;＼
the allow-top-navigation keyword allows the content to navigate its traversable navigable;＼
the allow-top-navigation-by-user-activation keyword behaves similarly but allows such navigation only when the browsing context's active window has transient activation;＼
the allow-top-navigation-to-custom-protocols reenables navigations toward non fetch scheme to be handed off to external software;＼
and the allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-presentation, allow-scripts, and allow-popups-to-escape-sandbox keywords re-enable forms, modal dialogs, screen orientation lock, the pointer lock API, popups, the presentation API, scripts, and the creation of unsandboxed auxiliary browsing contexts respectively.＼
The allow-downloads keyword allows content to perform downloads.＼
[POINTERLOCK] [SCREENORIENTATION] [PRESENTATION]
</div>

<p>
`allow-top-navigation$v,
`allow-top-navigation-by-user-activation$v
両~keywordとも指定してはナラナイ
— そうすることは冗長なので。
そのような適合しない~markupにおいては、
`allow-top-navigation$v のみ効果がある。
◎
The allow-top-navigation and allow-top-navigation-by-user-activation keywords must not both be specified, as doing so is redundant; only allow-top-navigation will have an effect in such non-conformant markup.
</p>

<p>
類似に，
`allow-top-navigation-to-custom-protocols$v ~keywordは、［
`allow-top-navigation$v ／ `allow-popups$v
］を指定した場合には，指定してはナラナイ
— そうすることは冗長なので。
◎
Similarly, the allow-top-navigation-to-custom-protocols keyword must not be specified if either allow-top-navigation or allow-popups are specified, as doing so is redundant.
</p>

<p class="note">注記：
~sandbox化された内容の内側で［
`alert()$m ／
`confirm()$m ／
`prompt()$m
］を許容するためには、
`allow-modals$v,
`allow-same-origin$v
両~keywordを指定する必要があり，読込まれる~URLは`~top-level生成元$enVと`同一-生成元$である必要もある。
`allow-same-origin$v ~keywordを伴わない場合、
内容は常に非同一-生成元に属するものと扱われ，`単純~dialogを示せない$。
◎
To allow alert(), confirm(), and prompt() inside sandboxed content, both the allow-modals and allow-same-origin keywords need to be specified, and the loaded URL needs to be same origin with the top-level origin. Without the allow-same-origin keyword, the content is always treated as cross-origin, and cross-origin content cannot show simple dialogs.
</p>

<p class="warning">
`allow-scripts$v, `allow-same-origin$v
両~keywordとも設定することは、［
埋込まれた~pageと それを包含している `iframe$e とが`同一-生成元$に属する
］ときには，［
埋込まれた~pageが単純に `sandbox$aF 属性を除去して，自身を再度~読込む
］ことにより［
実質的に，~sandboxを突破して無にする
］ことを許容することになる。
◎
Setting both the allow-scripts and allow-same-origin keywords together when the embedded page has the same origin as the page containing the iframe allows the embedded page to simply remove the sandbox attribute and then reload itself, effectively breaking out of the sandbox altogether.
</p>

<p class="warning">
これらの~flagが効果を~~発揮するのは、
当の `iframe$e 要素の`内容~navigable$が`~navigate$されるときに限られる。
すでに読込まれた~pageに対しては、
これらの~flagのうち一部を除去しようが `sandbox$aF 属性をまるごと除去しようが，
効果はない。
◎
These flags only take effect when the content navigable of the iframe element is navigated. Removing them, or removing the entire sandbox attribute, has no effect on an already-loaded page.
</p>

<p class="warning">
敵対的になり得る~fileは、［
当の `iframe$e 要素を包含している~fileと同じ~server
］から~serveされるべきでない。
敵対的な内容を~sandbox化することは、
攻撃者が［
`iframe$e 内ではなく，敵対的な内容へ直に訪問する
］よう利用者を仕向けれる場合のためにあり，必要最小限な助けでしかない。
敵対的な~HTML内容がもたらし得る被害を制限するには、
別々な専用~domainから~serveするべきである。
異なる~domainを利用すれば、
利用者が［
`sandbox$aF 属性による保護なしに，そのような~pageへ直に訪問する
］よう騙された場合でも，［
~file内の~scriptは，~siteを攻撃-不能になる
］ことが確保される。
◎
Potentially hostile files should not be served from the same server as the file containing the iframe element. Sandboxing hostile content is of minimal help if an attacker can convince the user to just visit the hostile content directly, rather than in the iframe. To limit the damage that can be caused by hostile HTML content, it should be served from a separate dedicated domain. Using a different domain ensures that scripts in the files are unable to attack the site, even if the user is tricked into visiting those pages directly, without the protection of the sandbox attribute.
</p>

<div class="algo">
<p>
［
`iframe$e 要素 %iframe の`内容~navigable$ ~NEQ ~NULL
］の下では、
~UAは，次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
%iframe の`sandbox$aF 属性が［
設定-／変更-
］されたときは
⇒
`~sandbox法~指令を構文解析する$( %iframe の `sandbox$aF 属性の値, %iframe の`~iframe~sandbox法~flag集合$ )
◎
When an iframe element's sandbox attribute is set or changed while it has a non-null content navigable, the user agent must parse the sandboxing directive given the attribute's value and the iframe element's iframe sandboxing flag set.
</li>
	<li>
%iframe の `sandbox$aF 属性が除去されたときは
⇒
%iframe の`~iframe~sandbox法~flag集合$を空にする
◎
When an iframe element's sandbox attribute is removed while it has a non-null content navigable, the user agent must empty the iframe element's iframe sandboxing flag set.
</li>
</ul>
</div>

<div class="example">
<p>
この例では、
~page内には，利用者が供した ある［
完全に未知な，敵対的にもなり得る~HTML内容
］が埋込まれている。
それは，ある別々な~domainから~serveされるので、
非同一-~siteに対する通常の制約~すべてから影響される。
加えて，埋込まれた~pageにおいては、［
~scripting, ~plugin, ~form
］は不能化され，自身以外のどの［
~frame／~window
］も（自身が埋込んだものも含め）~navigateできない。
◎
In this example, some completely-unknown, potentially hostile, user-provided HTML content is embedded in a page. Because it is served from a separate domain, it is affected by all the normal cross-site restrictions. In addition, the embedded page has scripting disabled, plugins disabled, forms disabled, and it cannot navigate any frames or windows other than itself (or any frames or windows it itself embeds).
</p>

`iframe-2^xCode

<p class="warning">
別々な~domainを利用することは、
攻撃者が利用者を［
その~pageを直に訪問させ、
~page内に見出されるどの攻撃からも脆弱にする
］よう仕向けても，［
そのような~pageが，当の~siteの生成元の文脈の下で走ることはない
］ようにするために重要になる。
◎
It is important to use a separate domain so that if the attacker convinces the user to visit that page directly, the page doesn't run in the context of the site's origin, which would make the user vulnerable to any attack found in the page.
</p>
</div>

<div class="example">
<p>
次の例では、
別の~siteからの ある~gadgetが埋込まれている。
この~gadgetでは、
~scriptingと~formが可能化されていて、
~gadgetが，出自の~serverと通信できるよう，生成元~sandbox制約は~~軽くされている。
しかしながら，~sandboxは、［
~pluginと~popup
］を不能化して，利用者が［
~malwareその他の いまいましいもの
］に晒されるのを抑制するので，
依然として有用になる。
◎
In this example, a gadget from another site is embedded. The gadget has scripting and forms enabled, and the origin sandbox restrictions are lifted, allowing the gadget to communicate with its originating server. The sandbox is still useful, however, as it disables plugins and popups, thus reducing the risk of the user being exposed to malware and other annoyances.
</p>

`iframe-3^xCode
</div>

<div class="example">
<p>
~file %A は、
次の~iframeを包含しているとする：
◎
Suppose a file A contained the following fragment:
</p>

`iframe-4^xCode

<p>
~file %B も~iframeも包含していたとする：
◎
Suppose that file B contained an iframe also:
</p>

`iframe-5^xCode

<p>
更に、
~file %C は~page %D への~linkを包含していたとする：
◎
Further, suppose that file C contained a link:
</p>

`iframe-6^xCode

<p>
この例に対しては、
どの~fileも `text/html$mt として~serveされているとする。
◎
For this example, suppose all the files were served as text/html.
</p>

<p>
この局面における~page %C に対しては、
すべての~sandbox法~flagが設定される。
%A 内の `iframe$e では~scriptは不能化されるので、
 %C においては［
%B 内の `iframe$e 内に設定された `allow-scripts$v ~keyword
］は上書きされ， ~scriptは不能化される。
また、
~formも不能化される
— （ %B 内の）内縁 `iframe$e 内には `allow-forms$v ~keywordは設定されてないので。
◎
Page C in this scenario has all the sandboxing flags set. Scripts are disabled, because the iframe in A has scripts disabled, and this overrides the allow-scripts keyword set on the iframe in B. Forms are also disabled, because the inner iframe (in B) does not have the allow-forms keyword set.
</p>

<p>
今ここで、
 %A 内の~scriptが %A, %B 内のすべての `sandbox$aF 属性を除去したとする。
これは、
即時には何も変更しない。
利用者が %C 内の~linkを~clickして，
%B 内の `iframe$e の中に~page %D を読込んだ場合、
~page %D は今や，［
%B 内の `iframe$e に［
`allow-same-origin$v, `allow-forms$v
］~keywordが設定されていた
］かのように動作する
— それが、［
~page%B が読込まれた時点で， %A 内の `iframe$e の`内容~navigable$の状態
］であったので。
◎
Suppose now that a script in A removes all the sandbox attributes in A and B. This would change nothing immediately. If the user clicked the link in C, loading page D into the iframe in B, page D would now act as if the iframe in B had the allow-same-origin and allow-forms keywords set, because that was the state of the content navigable in the iframe in A when page B was loaded.
</p>

<p>
一般に， `sandbox$aF 属性は、
動的に除去したり変更しないことを勧める
— そうすると、［
許容されるもの, されないもの
］を選り分けるのが難しくなり得るので。
◎
Generally speaking, dynamically removing or changing the sandbox attribute is ill-advised, because it can make it quite hard to reason about what will be allowed and what will not.
</p>
</div>

<hr>

<p>
`allow@aF
属性は、
指定されたときは，`容器~施策$を決定する
— それは、［
`iframe$e の`内容~navigable$に属する`文書$用の`許可~施策$doc
］が初期化されるとき，利用されることになる。
値は、
`直列形の許可~施策$でなければナラナイ。
`PERMISSIONSPOLICY$r
◎
The allow attribute, when specified, determines the container policy that will be used when the permissions policy for a Document in the iframe's content navigable is initialized. Its value must be a serialized permissions policy. [PERMISSIONSPOLICY]
</p>

<div class="example">
<p>
次の例では、
~online~navi~serviceからの地図を埋込むために， `iframe$e が利用される。
`allow$aF 属性は、
入子な文脈の中で Geolocation ~APIを可能化するために利用される。
◎
In this example, an iframe is used to embed a map from an online navigation service. The allow attribute is used to enable the Geolocation API within the nested context.
</p>

`iframe-7^xCode
</div>

<p>
`allowfullscreen@aF
属性は，`真偽-属性$であり、
指定されたときは，［
`iframe$e 要素の`内容~navigable$に属する`文書$は、［
どの`生成元$からでも， `fullscreen^l 特能の利用を許容する
］よう，`許可~施策$docで初期化されることになる
］ことを指示する。
これは、
`許可~施策~属性を処理する$ ~algoにより施行される。
`PERMISSIONSPOLICY$r
◎
The allowfullscreen attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's content navigable will be initialized with a permissions policy which allows the "fullscreen" feature to be used from any origin. This is enforced by the process permissions policy attributes algorithm. [PERMISSIONSPOLICY]
</p>

<div class="example">
<p>
ここでの `iframe$e は、
動画~siteからの再生器を埋込むために利用されている。
この再生器が動画を全~screen化するのを可能化するためには、
`allowfullscreen$aF 属性が必要になる。
◎
Here, an iframe is used to embed a player from a video site. The allowfullscreen attribute is needed to enable the player to show its video fullscreen.
</p>

`iframe-8^xCode
</div>

<p class="note">注記：
［
`allow$aF ／
`allowfullscreen$aF
］属性は、
すでに［
それを有する `iframe$e 要素 %要素 の`~node文書$には，
ある特能 %特能 の`利用は許容されて$いない
］場合には，［
%要素 の`内容~navigable$における %特能 への~access
］を是認し得ない。
◎
Neither allow nor allowfullscreen can grant access to a feature in an iframe element's content navigable if the element's node document is not already allowed to use that feature.
</p>

<div class="algo">
<p id="fullscreen-logic">
`文書$ %文書 には`施策により制御される特能$ %特能 の
`利用は許容されて@
いるとは、
~AND↓ が満たされることをいう：
◎
To determine whether a Document object document is allowed to use the policy-controlled-feature feature, run these steps:
</p>
<ul>
	<li>
%文書 が`属する閲覧~文脈$ ~NEQ ~NULL
◎
If document's browsing context is null, then return false.
</li>
	<li>
%文書 は`全部的に作動中$である
◎
If document is not fully active, then return false.
</li>
	<li>
次の結果 ~EQ `可能化される^i
⇒
`文書~内の特能は生成元~用に可能化されるか？$( %特能, %文書, %文書 の`生成元$doc )
◎
If the result of running is feature enabled in document for origin on feature, document, and document's origin is "Enabled", then return true.
◎
Return false.
</li>
</ul>
</div>

<p class="warning">
［
`allow$aF ／
`allowfullscreen$aF
］属性が波及するのは，
それを有する `iframe$e 要素の`内容~navigable$ %~navigable にて`作動中な文書$navの`許可~施策$docに限られるので、
これらの属性が効果を~~発揮するのは，
%~navigable が`~navigate$されるときに限られる。
これらの属性を追加しようが除去しようが，すでに読込んだ文書に対する効果は無い。
◎
Because they only influence the permissions policy of the content navigable's active document, the allow and allowfullscreen attributes only take effect when the content navigable of the iframe is navigated. Adding or removing them has no effect on an already-loaded document.
</p>

<hr>

<p>
`iframe$e 要素は、
埋込d内容に特有な寸法がある場合は，`寸法~属性$を~supportする（例： きちんと定義された寸法を有する広告unitなど）。
◎
The iframe element supports dimension attributes for cases where the embedded content has specific dimensions (e.g. ad units have well-defined dimensions).
</p>

<p>
`iframe$e 要素は、
`~fallback内容$を決して有さない
— 指定された初期~内容が成功裡に利用されたか否かを問わず、
常に，`新たな子~navigableを作成する$ことになるので。
◎
An iframe element never has fallback content, as it will always create a new child navigable, regardless of whether the specified initial contents are successfully used.
</p>

<hr>

<p>
`referrerpolicy@aF
属性は、
`~referrer施策~属性$である。
その目的は、
`~iframe属性~群を処理する$ときに利用される`~referrer施策$を設定することである。
`REFERRERPOLICY$r
◎
The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when processing the iframe attributes. [REFERRERPOLICY]
</p>

<p>
`loading@aF
属性は、
`~lazy読込ng属性$である。
その目的は、
表示域の外側にある `iframe$e 要素を読込むときの施策を指示することである。
◎
The loading attribute is a lazy loading attribute. Its purpose is to indicate the policy for loading iframe elements that are outside the viewport.
</p>

<div class="algo">
<p>
`iframe$e 要素の %iframe の `loading$aF 属性の状態が `Eager$st に変化したときは、
~UAは，次の手続きを走らすモノトスル：
◎
When the loading attribute's state is changed to the Eager state, the user agent must run these steps:
</p>
<ol>
	<li>
%再開~手続き ~LET %iframe の`~lazy読込n再開~手続き$
◎
Let resumptionSteps be the iframe element's lazy load resumption steps.
</li>
	<li>
~IF［
%再開~手続き ~EQ ~NULL
］
⇒
~RET
◎
If resumptionSteps is null, then return.
</li>
	<li>
%iframe の`~lazy読込n再開~手続き$ ~SET ~NULL
◎
Set the iframe's lazy load resumption steps to null.
</li>
	<li>
%再開~手続き を呼出す
◎
Invoke resumptionSteps.
</li>
</ol>
</div>

<hr>

<p>
`iframe$e 要素の子孫は、
何も表現しない（ `iframe$e 要素を~supportしない旧来の~UAにおいては、
その内容は ~markupとして構文解析され，~fallback内容として動作し得る。）
◎
Descendants of iframe elements represent nothing. (In legacy user agents that do not support iframe elements, the contents would be parsed as markup that could act as fallback content.)
</p>

<p class="note">注記：
`~HTML構文解析器$は、
 `iframe$e 要素の内側にある~markupを~textとして扱う。
◎
The HTML parser treats markup inside iframe elements as text.
</p>

<hr>

<div class="algo">
<p>
`srcdoc@mF
取得子~手続きは：
◎
The srcdoc getter steps are:
</p>
<ol>
	<li>
%属性 ~LET コレの`属性を名前空間と局所~名により取得する$( ~NULL, `srcdoc$aF の`局所~名$attr )
◎
Let attribute be the result of getting an attribute by namespace and local name given null, srcdoc's local name, and this.
</li>
	<li>
~IF［
%属性 ~EQ ~NULL
］
⇒
~RET 空~文字列
◎
If attribute is null, then return the empty string.
</li>
	<li>
~RET %属性 の`値$attr
◎
Return attribute's value.
</li>
</ol>
</div>

<div class="algo">
<p>
`srcdoc$mF 設定子~手続きは：
◎
The srcdoc setter steps are:
</p>
<ol>
	<li>
%準拠な文字列 ~LET `信用-済みな型に準拠な文字列を取得する$( ↓ )
⇒＃
`TrustedHTML$I,
コレに`関連な大域~obj$,
所与の値, 
`HTMLIFrameElement srcdoc^l,
`script^l
◎
Let compliantString be the result of invoking the get trusted type compliant string algorithm with TrustedHTML, this's relevant global object, the given value, "HTMLIFrameElement srcdoc", and "script".
</li>
	<li>
コレの`属性~値を設定する$( `srcdoc$aF の`局所~名$attr, %準拠な文字列 )
◎
Set an attribute value given this, srcdoc's local name, and compliantString.
</li>
</ol>
</div>

<p>
`sandbox$mF 属性が `DOMTokenList$I 用に`~supportする~token集合$は、［
`sandbox$aF 内容~属性に定義された許容される値のうち，~UAが~supportするもの
］からなるとする。
◎
The supported tokens for sandbox's DOMTokenList are the allowed values defined in the sandbox attribute and supported by the user agent.
</p>

<p>
`referrerPolicy@mF
~IDL属性は、
`既知な値のみに制限される$下で，
`referrerpolicy$aF 内容~属性を`反映する$モノトスル。
◎
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</p>

<p>
`loading@mF
~IDL属性は、
`既知な値のみに制限される$下で，
`loading$aF 内容~属性を`反映する$モノトスル。
◎
The loading IDL attribute must reflect the loading content attribute, limited to only known values.
</p>

<div class="algo">
`contentDocument@mF
取得子~手続きは
⇒
~RET コレの`内容~文書$
◎
The contentDocument getter steps are to return this's content document.
</div>

<div class="algo">
`contentWindow@mF
取得子~手続きは
⇒
~RET コレの`内容~window$
◎
The contentWindow getter steps are to return this's content window.
</div>

<div class="example">
<p>
`iframe$e を用いて
広告~代行業者からの広告を含ませる例：
◎
Here is an example of a page using an iframe to include advertising from an advertising broker:
</p>

`iframe-9^xCode
</div>

			</section>
			<section id="the-embed-element">
<h4 title="The embed element">4.8.6. `embed^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$
◎
Flow content.
</dd>
	<dd>
`句ng内容$
◎
Phrasing content.
</dd>
	<dd>
`埋込d内容$
◎
Embedded content.
</dd>
	<dd>
`ヤリトリありな内容$
◎
Interactive content.
</dd>
	<dd>
`可触~内容$
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aE
— 埋込む資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`type$aE
— 埋込む資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
どの名前空間にも属さない任意の属性（注釈文を見よ）。
◎
Any other attribute that has no namespace (see prose).
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`embed$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLEmbedElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$, `ReflectURL$] attribute USVString `src@mE;
  [`CEReactions$, `Reflect$] attribute DOMString `type@mE;
  [`CEReactions$, `Reflect$] attribute DOMString `width@mE;
  [`CEReactions$, `Reflect$] attribute DOMString `height@mE;
  `Document$I? `getSVGDocument$m();

  // `HTMLEmbedElement$obsMb
};
</pre>
	</dd>
</dl>

<p>
`embed$e 要素は、［
外部~app／ヤリトリありな内容
］用に統合~~地点を供する。
◎
The embed element provides an integration point for an external application or interactive content.
</p>

<p>
`src@aE
属性は、
埋込まれる資源の`~URL$を与える。
この属性に指定する値は、
`妥当かつ空でない~URL（前後~空白~可）$でなければナラナイ。
◎
The src attribute gives the URL of the resource being embedded. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p>
`embed$e 要素が `itemprop$a を有する場合、
`src$aE 属性も有していなければナラナイ。
◎
If the itemprop attribute is specified on an embed element, then the src attribute must also be specified.
</p>

<p>
`type@aE
属性は、
在るならば，`~MIME型$を与える
— ~instance化される~pluginは、
それにより選定される。
指定する値は、
`妥当な~MIME型~文字列$でなければナラナイ。
要素が［
`type$aE 属性, `src$aE 属性
］どちらも有する場合、
`type$aE 属性には，［
`src$aE 属性により与えられる資源の明示的な`~Content-Type~metadata$
］と同じ型を指定しなければナラナイ。
◎
The type attribute, if present, gives the MIME type by which the plugin to instantiate is selected. The value must be a valid MIME type string. If both the type attribute and the src attribute are present, then the type attribute must specify the same type as the explicit Content-Type metadata of the resource given by the src attribute.
</p>

<p>
`embed$e 要素が ~OR↓ を満たしている間は、
当の要素~用に~instance化された`~plugin$が在るならば，それを除去するモノトスル
— 当の要素は何も`表現-$しなくなる：
◎
While any of the following conditions are occurring, any plugin instantiated for the element must be removed, and the embed element represents nothing:
</p>
<ul>
	<li>
［
`src$aE 属性を有さない
］~AND［
`type$aE 属性を有さない
］
◎
The element has neither a src attribute nor a type attribute.
</li>
	<li>
次を満たす先祖が在る
⇒
［
`~media要素$である
］~OR［
`~fallback内容$を<em>示していない</em> `object$e 要素である
］
◎
The element has a media element ancestor.
◎
The element has an ancestor object element that is not showing its fallback content.
</li>
</ul>

<p>
`embed$e 要素が所与の時点で
`作動中になれ@
るとは、
~AND↓ を満たすことをいう
（その否定は、
単に “作動中になれない” ）：
◎
An embed element is said to be potentially active when the following conditions are all met simultaneously:
</p>
<ul>
	<li>
［
`文書~内$に在る
］~OR［
`~event~loop$が最後に その`最初の段$に達した時点で，`文書~内$に在った
］
◎
The element is in a document or was in a document the last time the event loop reached step 1.
</li>
	<li>
その`~node文書$は`全部的に作動中$である
◎
The element's node document is fully active.
</li>
	<li>
［
`src$aE 属性を有する
］~OR［
`type$aE 属性を有する
］
◎
The element has either a src attribute set or a type attribute set (or both).
</li>
	<li>
［
`src$aE 属性は有さない
］~OR［
`src$aE 属性を有していて，その値 ~NEQ 空~文字列
］
◎
The element's src attribute is either absent or its value is not the empty string.
</li>
	<li>
`~media要素$の子孫ではない
◎
The element is not a descendant of a media element.
</li>
	<li>
［
`~fallback内容$を示していない `object$e 要素
］の子孫ではない
◎
The element is not a descendant of an object element that is not showing its fallback content.
</li>
	<li>
［
`具現化されて$いる
］~OR［
`~event~loop$が最後に その`最初の段$に達した時点で，`具現化されて$いた
］
◎
The element is being rendered, or was being rendered the last time the event loop reached step 1.
</li>
</ul>

<div class="algo">
<p>
`embed$e 要素 %embed において，次のいずれかが生じたときは…：
</p>
<ul>
	<li>
`作動中になれ$ない~~状態から`作動中になれ$るようになったとき
</li>
	<li>
`作動中になれ$る間に，その［
`src$aE, `type$aE
］属性いずれかが［
設定-／変更-／除去-
］されたとき
</li>
</ul>

<p>
…~UAは、
次を遂行するモノトスル
⇒
`要素~taskを~queueする$(
`~embed~task~source@,
%embed, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~embed要素を設定しておく$( %embed )
</div>
◎
Whenever an embed element that was not potentially active becomes potentially active, and whenever a potentially active embed element that is remaining potentially active has its src attribute set, changed, or removed or its type attribute set, changed, or removed, the user agent must queue an element task on the embed task source given the element to run the embed element setup steps for that element.
</div>

<div class="algo">
<p>
`~embed要素を設定しておく@
手続きは、
所与の
( `embed$e 要素 %embed )
に対し：
◎
The embed element setup steps for a given embed element element are as follows:
</p>

<ol>
	<li>
%現~task ~LET %embed 用にこの手続きを走らせている`~task$
◎
↓</li>
	<li>
~IF［
%現~task より後に~queueされた，［
%embed 用にこの手続きを走らす，別の`~task$
］が在る
］
⇒
~RET
◎
If another task has since been queued to run the embed element setup steps for element, then return.
</li>
	<li>
<p>
~IF［
%embed は `src$aE 属性を有する
］：
◎
If element has a src attribute set, then:
</p>
		<ol>
			<li>
%~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( %embed の `src$aE 属性の値, %embed の`~node文書$ )
◎
Let url be the result of encoding-parsing a URL given element's src attribute's value, relative to element's node document.
</li>
			<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~RET
◎
If url is failure, then return.
</li>
			<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET %embed の`~node文書$に`関連な設定群~obj$,
`行先$rq ~SET `embed^l,
`資格証~mode$rq ~SET `include^l,
`~mode$rq ~SET `navigate^l,
`起動元~種別$rq ~SET `embed^l,
`~URL資格証を利用するか$rq ~SET ~T
◎
Let request be a new request whose URL is url, client is element's node document's relevant settings object, destination is "embed", credentials mode is "include", mode is "navigate", initiator type is "embed", and whose use-URL-credentials flag is set.
</li>
			<li>
<p>
%要請 を`~fetchする$
— 次を与える下で：
◎
Fetch request, with＼
</p>
				<ul>
					<li class="algo">
<p>
`応答の処理n$i ~SET 所与の
( `応答$ %応答 )
に対し，次を走らす手続き：
◎
processResponse set to the following steps given response response:
</p>
						<ol>
							<li>
~IF［
%現~task より後に~queueされた，［
%embed 用にこの手続きを走らす別の`~task$
］が在る
］
⇒
~RET
◎
If another task has since been queued to run the embed element setup steps for element, then return.
</li>
							<li>
~IF［
%応答 は`~network~error$である
］
⇒＃
`~eventを発火する$( %embed, `load$et )；
~RET
◎
If response is a network error, then fire an event named load at element, and return.
</li>
							<li>
%型 ~LET `内容の型を決定する$( %embed, %応答 )
◎
Let type be the result of determining the type of content given element and response.
</li>
							<li>
~IF［
%型 ~EQ ~NULL
］
⇒
%embed 用の`~pluginなしを表示する$
◎
Switch on type:
◎
null
• Display no plugin for element.
</li>
							<li>
<p>
~ELSE：
◎
Otherwise
</p>
								<ol>
									<li>
%~navigable ~LET %embed の`内容~navigable$
◎
↓</li>
									<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
%~navigable ~SET `新たな子~navigableを作成する$( %embed )
◎
If element's content navigable is null, then create a new child navigable for element.
</li>
									<li>
<p>
`~navigableを~URLへ~navigateする$( %~navigable, %応答 の`~URL$rs, %embed の`~node文書$ )
— 次も与える下で
⇒＃
`応答^i ~SET %応答,
`履歴~取扱い^i ~SET `replace$hH
◎
Navigate element's content navigable to response's URL using element's node document, with response set to response, and historyHandling set to "replace".
</p>

<p class="note">注記：
%embed の `src$aE 属性は、
%~navigable が更に他の所在に~navigateされても更新されない。
◎
element's src attribute does not get updated if the content navigable gets further navigated to other locations.
</p>
									</li>
									<li>
この時点で、
%embed は，自身の`内容~navigable$を`表現-$する
◎
element now represents its content navigable.
</li>
								</ol>
							</li>
						</ol>
					</li>
				</ul>
<p>
資源を~fetchするときは、
%embed の`~node文書$の`~load~eventを遅延する$モノトスル。
◎
Fetching the resource must delay the load event of element's node document.
</p>
			</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
%embed 用の`~pluginなしを表示する$
◎
Otherwise, display no plugin for element.
</li>
</ol>
</div>

<div class="algo">
<p>
`内容の型を決定する@
~algoは、
所与の
( `embed$e 要素 %embed, `応答$ %応答 )
に対し：
◎
To determine the type of the content given an embed element element and a response response, run the following steps:
</p>

<ol>
	<li>
~IF［
%embed は `type$aE 属性を有していて，その値は ある`~plugin$が~supportする型である
］
⇒
~RET その値
◎
If element has a type attribute, and that attribute's value is a type that a plugin supports, then return the value of the type attribute.
</li>
	<li>
<p>
~IF［
%応答 の`~URL$rsの`~path$url成分は ある`~plugin$が~supportする~patternに合致する
］
⇒
~RET その~pluginが取扱える型
◎
If the path component of response's url matches a pattern that a plugin supports, then return the type that that plugin can handle.
</p>

<p class="example">
例えば，ある~pluginは、［
`~path$url成分が文字列 `.swf^l で終端する
］ような~URLを取扱えるとしていることもある。
◎
For example, a plugin might say that it can handle URLs with path components that end with the four character string ".swf".
</p>

<p class="trans-note">【
~patternに合致する複数の~pluginがある場合に［
どの~pluginが選定されるか ／
当の~pluginが複数の型を取扱える場合に，どの型が選定されるか
］については、
ここには述べられていない
— 実装定義な（何らかの環境設定に基づく）仕組みで選定されるものと見做されているようだ。
他所にも~pluginを選定する記述があるが、
同様と見受けられる。
】</p>

</li>
	<li>
~IF［
%応答 には明示的な`~Content-Type~metadata$があって，その値は ある`~plugin$が~supportする型である
］
⇒
~RET その値
◎
If response has explicit Content-Type metadata, and that value is a type that a plugin supports, then return that value.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="note">注記：
上の~algoが`~ok状態s$でない応答を許容するのは、
意図的である。
これにより，~serverは、
~error応答においても~plugin用の~dataを返せるようになる（例：
~HTTP状態s~code 500 ( Internal Server Error ) であっても、
~plugin~dataを包含できる）。
◎
It is intentional that the above algorithm allows response to have a non-ok status. This allows servers to return data for plugins even with error responses (e.g., HTTP 500 Internal Server Error codes can still contain plugin data).
</p>
</div>

<div class="algo">
<p>
`embed$e 要素 %embed 用の
`~pluginなしを表示する@
~algoは：
◎
To display no plugin for an embed element element:
</p>
<ol>
	<li>
`子~navigableを破壊する$( %embed )
◎
Destroy a child navigable given element.
</li>
	<li>
%embed 用の`~plugin$は見出せなかった指示を表示する
◎
Display an indication that no plugin could be found for element, as the contents of element.
</li>
	<li>
この時点で、
 %embed は何も`表現-$しない
◎
element now represents nothing.
</li>
</ol>
</div>

<p class="note">注記：
`embed$e 要素には、
`~fallback内容$は無い
— その子孫は無視される。
◎
The embed element has no fallback content; its descendants are ignored.
</p>

<p>
`作動中になれ$る `embed$e 要素が，`作動中になれ$なくなったときは、
要素~用に~instance化されていた`~plugin$を~unloadするモノトスル。
◎
Whenever an embed element that was potentially active stops being potentially active, any plugin that had been instantiated for that element must be unloaded.
</p>

<p>
`embed$e 要素は、
`~load~eventを遅延し得る$とする。
◎
The embed element potentially delays the load event.
</p>

<p>
`embed$e 要素は、
`寸法~属性$を~supportする。
◎
The embed element supports dimension attributes.
</p>

			</section>
			<section id="the-object-element">
<h4 title="The object element">4.8.7. `object^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$
◎
Flow content.
</dd>
	<dd>
`句ng内容$
◎
Phrasing content.
</dd>
	<dd>
`埋込d内容$
◎
Embedded content.
</dd>
	<dd>
`~formに所有され得る要素$のうち`~listされる＠~HEforms#category-listed$もの
◎
Listed form-associated element.
</dd>
	<dd>
`可触~内容$
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`透過的な内容$
◎
Transparent.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`data$aO
— 埋込む資源の~address
◎
data — Address of the resource
</dd>
	<dd>
`type$aO
— 埋込む資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`name$aO
— `内容~navigable$の名前
◎
name — Name of content navigable
</dd>
	<dd>
`form$a
— この要素の所有者にする `form$e 要素
◎
form — Associates the element with a form element
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`object$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLObjectElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$, `ReflectURL$] attribute USVString `data@mO;
  [`CEReactions$, `Reflect$] attribute DOMString `type@mO;
  [`CEReactions$, `Reflect$] attribute DOMString `name@mO;
  readonly attribute `HTMLFormElement$I? `form$m;
  [`CEReactions$, `Reflect$] attribute DOMString `width@mO;
  [`CEReactions$, `Reflect$] attribute DOMString `height@mO;
  readonly attribute `Document$I? `contentDocument$mO;
  readonly attribute `WindowProxy$I? `contentWindow$mO;
  `Document$I? `getSVGDocument$m();

  readonly attribute boolean `willValidate$m;
  readonly attribute `ValidityState$I `validity$m;
  readonly attribute DOMString `validationMessage$m;
  boolean `checkValidity$m();
  boolean `reportValidity$m();
  undefined `setCustomValidity$m(DOMString %error);

  // `HTMLObjectElement$obsMb
};
</pre>

<p>
`object$e 要素により~instance化される内容の型に依存して、
~nodeは，他の~interfaceも~supportする。
◎
Depending on the type of content instantiated by the object element, the node also supports other interfaces.
</p>
	</dd>
</dl>

<p>
`object$e 要素は、
外部~資源を表現できる
— それは、
資源の型に依存して，［
画像, `子~navigable$
］いずれかとして扱われることになる。
◎
The object element can represent an external resource, which, depending on the type of the resource, will either be treated as an image or as a child navigable.
</p>

<p>
`data@aO
属性は、
資源の`~URL$を指定する。
`object$e 要素は、
この属性を有していなければナラナイ
— 指定する値は、
`妥当かつ空でない~URL（前後~空白~可）$でなければナラナイ。
◎
The data attribute specifies the URL of the resource. It must be present, and must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p>
`type@aO
属性は、
在るならば，資源の型を指定する。
この属性に指定する値は、
`妥当な~MIME型~文字列$でなければナラナイ。
◎
The type attribute, if present, specifies the type of the resource. If present, the attribute must be a valid MIME type string.
</p>

<p>
`name@aO
属性に指定する値は、
`妥当な~navigable~target名$でなければナラナイ。
その値は、
適用-可能な場合には，
当の `object$e 要素の`内容~navigable$に名前を与えるために利用される
— それが`作成され＠~HTMLds#create-a-new-child-navigable$る時点で，この属性が在るならば。
◎
The name attribute, if present, must be a valid navigable target name. The given value is used to name the element's content navigable, if applicable, and if present when the element's content navigable is created.
</p>

<div class="algo">
<p>
`object$e 要素 %object において，次のいずれかが生じたときは…：
◎
Whenever one of the following conditions occur:
</p>
<ul>
	<li>
作成されたとき
◎
the element is created,
</li>
	<li>
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$から~popされ除かれたとき
◎
the element is popped off the stack of open elements of an HTML parser or XML parser,
</li>
	<li>
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$内に無い下で
⇒
［
`文書の中へ挿入され$た／`文書から除去され$た
］とき
◎
the element is not on the stack of open elements of an HTML parser or XML parser, and it is either inserted into a document or removed from a document,
</li>
	<li>
その`~node文書$が`全部的に作動中$かどうかが変化したとき
◎
the element's node document changes whether it is fully active,
</li>
	<li>
そのある先祖の `object$e 要素において［
`~fallback内容$を示しているかどうか
］が変化したとき
◎
one of the element's ancestor object elements changes to or from showing its fallback content,
</li>
	<li>
その `classid$a 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
the element's classid attribute is set, changed, or removed,
</li>
	<li>
`classid$a 属性を有していない下で
⇒
その `data$aO 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
the element's classid attribute is not present, and its data attribute is set, changed, or removed,
</li>
	<li>
［
`classid$a, `data$aO
］両~属性とも有していない下で
⇒
その `type$aO 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
neither the element's classid attribute nor its data attribute are present, and its type attribute is set, changed, or removed,
</li>
	<li>
`具現化されて$いるかどうかが変化したとき
◎
the element changes from being rendered to not being rendered, or vice versa,
</li>
</ul>

<p class="trans-note">【
上の `classid$a に関する条件は、
もはや不要にも思われる
— `classid$a に関係する処理は、
この仕様（以下の手続き）から除去されたので。
】</p>

<p>
…~UAは、
次を遂行するモノトスル：
◎
...the user agent＼
</p>
<ul>
	<li>
%~task ~LET `要素~taskを~queueする$( `~DOM操作~task~source$, %object, 以下に与える手続き )
◎
must queue an element task on the DOM manipulation task source given the object element to run the following steps to (re)determine what the object element represents.＼
</li>
	<li>
%~task が［
【！`~queueされ$ている】`~task~queue$内に在るか, 【！actively】走っている
］間は、
%object の`~node文書$の`~load~eventを遅延する$。
◎
This task being queued or actively running must delay the load event of the element's node document.
</li>
</ul>

<div class="algo">
<p>
手続きは、
%object が表現するものを決定する（し直す）：
◎
↑</p>
<ol>
	<li>
<p>
~IF［
利用者は、
%object の通例の挙動に代えて
%object の`~fallback内容$を示す選好を指示した
］
⇒
~GOTO `~fallback$i
◎
If the user has indicated a preference that this object element's fallback content be shown instead of the element's usual behavior, then jump to the step below labeled fallback.
</p>

<p class="note">注記：
利用者は、
例えば %object の`~fallback内容$の方がより~access可能な形式であると見出したときに，それを示すよう依頼することもできる。
◎
For example, a user could ask for the element's fallback content to be shown because that content uses a format that the user finds more accessible.
</p>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
↓</p>
		<ul>
			<li>
%object の先祖には`~media要素$が在る
◎
If the element has an ancestor media element,＼
</li>
			<li>
%object の先祖には［
`~fallback内容$を<em>示していない</em> `object$e 要素
］が在る
◎
or has an ancestor object element that is not showing its fallback content,＼
</li>
			<li>
%object は`文書~内$に無い
◎
↓</li>
			<li>
%object の`~node文書$が`属する閲覧~文脈$ ~EQ ~NULL
◎
or if the element is not in a document whose browsing context is non-null,＼
</li>
			<li>
%object の`~node文書$は`全部的に作動中$でない
◎
or if the element's node document is not fully active,＼
</li>
			<li>
%object は，まだ［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$内に在る
◎
or if the element is still in the stack of open elements of an HTML parser or XML parser,＼
</li>
			<li>
%object は`具現化されて$いない
◎
or if the element is not being rendered,＼
</li>
		</ul>
<p>
…ならば
⇒
~GOTO `~fallback$i
◎
then jump to the step below labeled fallback.
</p>
	</li>
	<li>
%data ~LET ［
%object は `data$aO 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
%type ~LET ［
%object は `type$aO 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
~IF［
%data ~IN { ε, 空~文字列 }
］
⇒
~GOTO `~fallback$i
◎
If the data attribute is present and its value is not the empty string, then:
</li>
	<li>
任意選択で
⇒
~IF［
%type ~NEQ ε
］~AND［
%type は~UAが~supportする型でない
］
⇒
~GOTO `~fallback$i
（その本当の型を精査するために内容を~fetchすることなく。）
◎
If the type attribute is present and its value is not a type that the user agent supports, then the user agent may jump to the step below labeled fallback without fetching the content to examine its real type.
</li>
	<li>
%~URL ~LET `~URLを符号化法の下で相対的に構文解析する$( %data, %object の`~node文書$ )
◎
Let url be the result of encoding-parsing a URL given the data attribute's value, relative to the element's node document.
</li>
	<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒＃
`~eventを発火する$( %object, `error$et )；
~GOTO `~fallback$i
◎
If url is failure, then fire an event named error at the element and jump to the step below labeled fallback.
</li>
	<li>
%要請 ~LET 新たな`要請$
— その
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET %object の`~node文書$に`関連な設定群~obj$,
`行先$rq ~SET `object^l,
`資格証~mode$rq ~SET `include^l,
`~mode$rq ~SET `navigate^l,
`起動元~種別$rq ~SET `object^l,
`~URL資格証を利用するか$rq ~SET ~T
◎
Let request be a new request whose URL is url, client is the element's node document's relevant settings object, destination is "object", credentials mode is "include", mode is "navigate", initiator type is "object", and whose use-URL-credentials flag is set.
</li>
	<li>
<p>
%要請 を`~fetchする$
◎
Fetch request.
</p>

<p>
資源の~fetchingは、［
資源が~fetchされ，`~network用~task~source$から`~queueされ$る`~task$（次の段を見よ）が走る
］まで，
%object の`~node文書$の`~load~eventを遅延する$モノトスル。
◎
Fetching the resource must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined next) has been run.
</p>

<p class="trans-note">【
以下に現れる “資源” は、
~fetchして得られることになる資源を指す。
】</p>
	</li>
	<li>
~IF［
資源は まだ可用でない（例：資源は~cache内に可用でなかったので、
資源を読込むためには~network越しに要請を為すことが要求される）
］
⇒
~GOTO `~fallback$i
— ただし
⇒
`~network用~task~source$から`~queueされ$た`~task$は、
資源が可用になり次第，この~algoをこの段から開始し直すモノトスル。
資源は増分的に読込める
— ~UAは資源の処理を始めるに十分な~dataが得られ次第、
資源を “可用” と見なしてヨイ。
【！ opt to 】
◎
If the resource is not yet available (e.g. because the resource was not available in the cache, so that loading the resource required making a request over the network), then jump to the step below labeled fallback. The task that is queued by the networking task source once the resource is available must restart this algorithm from this step. Resources can load incrementally; user agents may opt to consider a resource "available" whenever enough data has been obtained to begin processing the resource.
</li>
	<li>
~IF［
資源を読込むのに失敗した（例： ~HTTP 404 ~error ／ ~DNS~errorが生じた）
］
⇒＃
`~eventを発火する$( %object, `error$et )
~GOTO `~fallback$i
◎
If the load failed (e.g. there was an HTTP 404 error, there was a DNS error), fire an event named error at the element, then jump to the step below labeled fallback.
</li>
	<li class="algo" id="object-type-detection">
<p>
%資源~型 ~LET 次の手続きを走らせた結果：
◎
Determine the resource type, as follows:
</p>
		<ol>
			<li>
%Content-Type ~LET ［
資源には `~Content-Type~metadata$が結付けられているならば それが指定する型 ／
~ELSE_ ε
］
◎
↓</li>
			<li>
<p>
~IF［
~UAは この資源に対しては、
`Content-Type^h ~headerを厳密に順守するよう環境設定されている
］~AND［
%Content-Type ~NEQ ε
］
⇒
~RET %Content-Type
◎
Let the resource type be unknown.
◎
If the user agent is configured to strictly obey Content-Type headers for this resource, and the resource has associated Content-Type metadata, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.
</p>

<p class="warning">
これは、
次のようなときに脆弱性をもたらし得る：
ある~siteが特定0の内容~型が利用される
【ものと期待して，~pageに】
資源を埋込もうとしたが、
~remote~siteはそれを上書きして，代わりに［
~security特性が異なる，別の型の内容
］を誘発させる資源を~UAに~~供給したときに。
◎
This can introduce a vulnerability, wherein a site is trying to embed a resource that uses a particular type, but the remote site overrides that and instead furnishes the user agent with a resource that triggers a different type of content with different security characteristics.
</p>
			</li>
			<li>
<p>
~IF［
%Content-Type ~NEQ ε
］：
◎
Run the appropriate set of steps from the following list:
◎
If the resource has associated Content-Type metadata
</p>
				<ol>
					<li>
<p>
%~binaryか ~LET ~IS ~OR↓：
</p>
						<ul>
							<li>
［
%Content-Type ~EQ `text/plain$mt
］~AND［
資源に`~textか~binaryかを判別する規則$を適用した結果 ~NEQ `text/plain$mt
］
</li>
							<li>
%Content-Type ~EQ `application/octet-stream$mt
</li>
						</ul>
◎
Let binary be false.
◎
If the type specified in the resource's Content-Type metadata is "text/plain", and the result of applying the rules for distinguishing if a resource is text or binary to the resource is that the resource is not text/plain, then set binary to true.
◎
If the type specified in the resource's Content-Type metadata is "application/octet-stream", then set binary to true.
</li>
					<li>
~IF［
%~binaryか ~EQ ~F
］
⇒
~RET %Content-Type
◎
If binary is false, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.
</li>
					<li>
<p>
~IF［
%type ~NIN { ε, `application/octet-stream$mt }
］：
◎
If there is a type attribute present on the object element, and its value is not application/octet-stream, then run the following steps:
</p>

						<ol>
							<li>
~IF［
%type は `image/^l から開始している
］~AND［
%type は`~XML~MIME型$ではない
］
⇒
~RET %type
◎
If the attribute's value is a type that starts with "image/" that is not also an XML MIME type, then let the resource type be the type specified in that type attribute.
</li>
							<li>
~RET `未知^i
◎
Jump to the step below labeled handler.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, if the resource does not have associated Content-Type metadata
</p>
				<ol>
					<li>
~IF［
%type ~EQ ε
］
⇒
%type ~SET 資源に`算出された~MIME型$
◎
If there is a type attribute present on the object element, then let the tentative type be the type specified in that type attribute.
◎
Otherwise, let tentative type be the computed type of the resource.
</li>
					<li>
~IF［
%type ~NEQ `application/octet-stream$mt
］
⇒
~RET %type
◎
If tentative type is not application/octet-stream, then let resource type be tentative type and jump to the step below labeled handler.
</li>
				</ol>
			</li>
			<li>
%資源~URL ~LET `~URL構文解析する$( 資源の（~redirect後の）~URL ) 
◎
If applying the URL parser algorithm to the URL of the specified resource (after any redirects)＼
</li>
			<li>
<p>
~IF［
%資源~URL ~NEQ `失敗^i
］~AND［
%資源~URL の`~path$urlは ある`~plugin$ %~plugin が~supportする~patternに合致する
］
⇒
~RET %~plugin が取扱える型
◎
results in a URL record whose path component matches a pattern that a plugin supports, then let resource type be the type that that plugin can handle.
</p>

<p class="example">
例えば，ある~pluginは、［
`~path$url 成分が文字列 `.swf^l で終端する
］ような資源を取扱えるものとしていることもある。
◎
For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".
</p>
			</li>
			<li>
~RET `未知^i
◎
It is possible for this step to finish, or for one of the substeps above to jump straight to the next step, with resource type still being unknown. In both cases, the next step will trigger fallback.
</li>
		</ol>
	</li>
	<li>
~IF［
%資源~型 ~EQ `未知^i
］
⇒
~GOTO `~fallback$i
◎
↑↓</li>
	<li>
<p>
次のうち， %資源~型 が最初に満たす条件に応じて、
対応する段に従って資源の内容を取扱う：
◎
Handler: Handle the content as given by the first of the following cases that matches:
</p>
		<dl class="switch">
			<dt>
%資源~型 は`~XML~MIME型$である：
◎
↓</dt>
			<dt>
%資源~型 は `image/^l から開始していない：
◎
If the resource type is an XML MIME type, or if the resource type does not start with "image/"
</dt>
			<dd>
				<ol>
					<li>
%~navigable ~LET %object の`内容~navigable$
◎
↓</li>
					<li>
~IF［
%~navigable ~EQ ~NULL
］
⇒
%~navigable ~SET `新たな子~navigableを作成する$( %object )
◎
If the object element's content navigable is null, then create a new child navigable for the element.
</li>

					<li>
%応答 ~LET 上の`~fetch$から得られた`応答$
◎
Let response be the response from fetch.
</li>
					<li>
<p>
~IF［
%応答 の`~URL$rsは`~about_blank に合致して$いない
］
⇒
`~navigableを~URLへ~navigateする$( %~navigable, %応答 の`~URL$rs, %object の`~node文書$ )
— 次も与える下で
⇒＃
`履歴~取扱い^i ~SET `replace$hH
◎
If response's URL does not match about:blank, then navigate the element's content navigable to response's URL using the element's node document, with historyHandling set to "replace".
</p>

<p class="note">注記：
%object の `data$aO 属性は、
%~navigable が更に他の所在に`~navigate$されても更新されない。
◎
The data attribute of the object element doesn't get updated if the content navigable gets further navigated to other locations.
</p>
					</li>
					<li>
この時点で、
%object は，自身の`内容~navigable$を`表現-$する。
◎
The object element represents its content navigable.
</li>
				</ol>
			</dd>

			<dt>
（ %資源~型 は `image/^l から開始していて，）
画像の~supportは不能化されていない：
◎
If the resource type starts with "image/", and support for images has not been disabled
</dt>
			<dd>
				<ol>
					<li>
`子~navigableを破壊する$( %object )
◎
Destroy a child navigable given the object element.
</li>
					<li>
`画像を特定的に~sniffするための規則$を適用して，画像の型を決定する
◎
Apply the image sniffing rules to determine the type of the image.
</li>
					<li>
この時点で、
%object は指定された画像を`表現-$する
◎
The object element represents the specified image.
</li>
					<li>
~IF［
画像を具現化できない（例：~dataは~~不正な形式である／その形式は未~supportである，など）
］
⇒
~GOTO `~fallback$i
【前~段の “画像を表現する” を上書きすることになる。】
◎
If the image cannot be rendered, e.g. because it is malformed or in an unsupported format, jump to the step below labeled fallback.
</li>
				</ol>
			</dd>

			<dt>
その他（ %資源~型 は~supportされていない）：
◎
Otherwise
</dt>
			<dd>
~GOTO `~fallback$i
◎
The given resource type is not supported. Jump to the step below labeled fallback.
◎
If the previous step ended with the resource type being unknown, this is the case that is triggered.
</dd>
		</dl>
	</li>
	<li>
この時点で，
%object の内容は %object が表現するものの一部を成さないとされる
◎
The element's contents are not part of what the object element represents.
</li>
	<li>
<div class="p">
<p>
~IF［
%object は自身の`内容~navigable$を表現していない
］：
</p>
		<ol>
			<li class="algo">
<p>
資源が完全に読込まれた時点で，次を行うようにしておく
⇒
`要素~taskを~queueする$( `~DOM操作~task~source$, %object, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~eventを発火する$( %object, `load$et )
</div>
			</li>
		</ol>
◎
If the object element does not represent its content navigable, then once the resource is completely loaded, queue an element task on the DOM manipulation task source given the object element to fire an event named load at the element.
</div>

<p class="note">注記：
%object は自身の`内容~navigable$を`表現して^emいる場合、
作成された`文書$が
`読込ngを完全に終えた＠~HTMLlifecycle#completely-finish-loading$とき，相似的な~taskが~queueされることになる。
◎
If the element does represent its content navigable, then an analogous task will be queued when the created Document is completely finished loading.
</p>
	</li>
	<li>
~RET
◎
Return.
</li>
	<li>
<p>
`~fallback@i：
◎
Fallback:＼
</p>
		<ol>
			<li>
この時点で、
%object は，その子~群を`表現-$する
— それが %object の`~fallback内容$になる
◎
The object element represents the element's children. This is the element's fallback content.＼
</li>
			<li>
`子~navigableを破壊する$( %object )
◎
Destroy a child navigable given the element.
</li>
		</ol>
	</li>
</ol>
</div>
</div>

<p>
`object$e 要素の内容は、［
上の~algoに因り，参照した資源を示せない場合（例：404~errorが返されたなど）
］に限り，利用される`~fallback内容$として動作する。
これにより、
複数の `object$e 要素を入子にすれば，能力が相異なる複数の~UAを対象にできるようになる
— ~UAは，自身が~supportする最初のものを選ぶことになる。
◎
Due to the algorithm above, the contents of object elements act as fallback content, used only when referenced resources can't be shown (e.g. because it returned a 404 error). This allows multiple object elements to be nested inside each other, targeting multiple user agents with different capabilities, with the user agent picking the first one it supports.
</p>

<p>
`object$e 要素は、
`~load~eventを遅延し得る$とする。
◎
The object element potentially delays the load event.
</p>

<p>
`form$a 属性は、
`object$e 要素の`~form所有者$を明示的に指定するために利用される。
◎
The form attribute is used to explicitly associate the object element with its form owner.
</p>

<p>
`object$e 要素は、
`寸法~属性$を~supportする。
◎
The object element supports dimension attributes.
</p>

<div>
<p>
`data@mO
~IDL属性は、
`data$aO 内容~属性を`反映する$モノトスル。
</p>

<p>
`type@mO
~IDL属性は、
`type$aO 内容~属性を`反映する$モノトスル。
</p>

<p>
`name@mO
~IDL属性は、
`name$aO 内容~属性を`反映する$モノトスル。
</p>
◎
The IDL attributes data, type, and name each must reflect the respective content attributes of the same name.
</div>

<div class="algo">
`contentDocument@mO
取得子~手続きは
⇒
~RET コレの`内容~文書$
◎
The contentDocument getter steps are to return this's content document.
</div>

<div class="algo">
`contentWindow@mO
取得子~手続きは
⇒
~RET コレの`内容~window$
◎
The contentWindow getter steps are to return this's content window.
</div>

<ul>
	<li>
`willValidate$m,
`validity$m,
`validationMessage$m
属性, および
`checkValidity()$m,
`reportValidity()$m,
`setCustomValidity()$m
~methodは、
`拘束~検証~API$の一部である。
◎
The willValidate, validity, and validationMessage attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API.＼
</li>
	<li>
`form$m ~IDL属性は、
要素の~form~APIの一部である。
◎
The form IDL attribute is part of the element's forms API.
</li>
</ul>

<div class="example">
<p>
次の例の~HTML~pageは、
`object$e 要素を用いて，別の~pageを埋込んでいる。
◎
In this example, an HTML page is embedded in another using the object element.
</p>

`object-2^xCode
</div>

			</section>
			<section id="_other-sections-2">
<h4>4.8.8. 〜 4.8.14.</h4>

<p class="trans-note">【
これらの節の和訳は
`別~page（画像~関連）＠~HEimages#_toc$ ／
`別~page（~media要素）＠~HEmedia#_toc$
にて。
】</p>

			</section>
			<section id="mathml">
<h4>4.8.15. ~MathML</h4>

<p>
~MathML `math$e 要素は、
この仕様における内容~modelの目的においては，［
`埋込d内容$ ／ `句ng内容$ ／ `~flow内容$ ／ `可触~内容$
］に分類される。
◎
The MathML math element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.
</p>

<p>
~MathML `annotation-xml$e 要素が包含する，`~HTML名前空間$に属する要素は、
`~flow内容$でなければナラナイ。
◎
When the MathML annotation-xml element contains elements from the HTML namespace, such elements must all be flow content.
</p>

<p>
~HTML要素の子孫である~MathML~token要素（
`mi$e ／ `mo$e ／ `mn$e ／ `ms$e ／ `mtext$e
）は、
`~HTML名前空間$に属する要素のうち，`句ng内容$を包含してもヨイ。
◎
When the MathML token elements (mi, mo, mn, ms, and mtext) are descendants of HTML elements, they may contain phrasing content elements from the HTML namespace.
</p>

<p>
~UAは、
~MathMLの［
内容~model, ~layout, 具現化
］の目的においては，［［
~MathML要素のうち，自身の内容~modelが直の~textを許容しないもの
］内に見出された，`要素間~空白$でない~text
］を［
実際には ~MathML `mtext$e 要素が当の~textを包装しているように装う
］ことにより，取扱うモノトスル。
（しかしながら、
そのような~textは適合しない。）
◎
User agents must handle text other than inter-element whitespace found in MathML elements whose content models do not allow straight text by pretending for the purposes of MathML content models, layout, and rendering that the text is actually wrapped in a MathML mtext element. (Such text is not, however, conforming.)
</p>

<p>
~UAは、
~MathMLの［
~layout, 具現化
］の目的においては，［
~MathML要素のうち，その内容が自身の内容~modelに合致しないもの
］に対しては［
何らかの適切な~error~messageを包含している，~MathML `merror$e 要素に置換されていた
］かのように動作するモノトスル。
◎
User agents must act as if any MathML element whose contents does not match the element's content model was replaced, for the purposes of MathML layout and rendering, by a MathML merror element containing some appropriate error message.
</p>

<p>
~MathML要素の意味論は、
`MathML^cite `MATHMLCORE$r,
および他の`適用-可能な仕様$にて定義される。
◎
The semantics of MathML elements are defined by MathML and other applicable specifications. [MATHML]
</p>

<div class="example">
<p>
~HTML文書における~MathMLの利用~例：
◎
Here is an example of the use of MathML in an HTML document:
</p>

`mathml-1^xCode
</div>

			</section>
			<section id="svg-0">
<h4 title="SVG">4.8.16. ~SVG</h4>

<p>
~SVG `svg$e 要素は、
この仕様における内容~modelの目的においては，［
`埋込d内容$ ／ `句ng内容$ ／ `~flow内容$ ／ `可触~内容$
］に分類される。
◎
The SVG svg element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.
</p>

<p>
~SVG `foreignObject$e 要素が包含する要素のうち，`~HTML名前空間$に属するものは、
`~flow内容$でなければナラナイ。
◎
When the SVG foreignObject element contains elements from the HTML namespace, such elements must all be flow content.
</p>

<p>
`~HTML文書$の内側における~SVG `title＠~SVGstruct#elementdef-title$e 要素の内容~modelは、
`句ng内容$とする（これは、
 `SVG 2^cite が課す要件を更に拘束する）。
◎
The content model for the SVG title element inside HTML documents is phrasing content. (This further constrains the requirements given in SVG 2.)
</p>

<p>
~SVG要素の意味論は、
`SVG 2^cite `SVG$r
と他の`適用-可能な仕様$にて定義される。
◎
The semantics of SVG elements are defined by SVG 2 and other applicable specifications. [SVG]
</p>

<hr>

<dl class="domintro">
	<dt>%doc = %iframe.`getSVGDocument()$m</dt>
	<dt>%doc = %embed.`getSVGDocument()$m</dt>
	<dt>%doc = %object.`getSVGDocument()$m</dt>
	<dd>
［
`iframe$e ／ `embed$e ／ `object$e 
］要素が~SVGを埋込むために利用されている事例では、
`Document$I ~objを返す。
◎
Returns the Document object, in the case of iframe, embed, or object elements being used to embed SVG.
</dd>
</dl>

<div class="algo">
<p>
`getSVGDocument()@m
~method手続きは：
◎
The getSVGDocument() method steps are:
</p>
<ol>
	<li>
%文書 ~LET コレの`内容~文書$
◎
Let document be this's content document.
</li>
	<li>
~IF［
%文書 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
↓</li>
	<li>
~RET ［
%文書 は次に該当するならば %文書 ／
~ELSE_ ~NULL
］
⇒
%文書 は，`§ ~XML文書の読込n法＠~HTMLlifecycle#read-xml$に従って作成されたものである
（`~navigate$した際に，資源に`算出された~MIME型$は `image/svg+xml$mt であったので）
◎
If document is non-null and was created by the page load processing model for XML files section because the computed type of the resource in the navigate algorithm was image/svg+xml, then return document.
◎
Return null.
</li>
</ol>
</div>

			</section>
			<section id="dimension-attributes">
<h4 title="Dimension attributes">4.8.17. 寸法~属性</h4>

				<section>
<h5>
作者~要件
◎
Author requirements:＼
</h5>

<p>
次に挙げる要素に対しては、［
`width@a
／
`height@a
］属性を指定してもヨイ
⇒＃
`img$e,
`iframe$e,
`embed$e,
`object$e,
`video$e,
`source$e のうち その親は `picture$e 要素であるもの,
`input$e のうち その `type$a 属性は `Image$st 状態にあるもの
◎
The width and height attributes on img, iframe, embed, object, video, source when the parent is a picture element and, when their type attribute is in the Image Button state, input elements may be specified＼
</p>

<p>
これらの属性は、
要素の視覚的な内容の寸法を`~CSS~pixel$単位で与える（順に，出力~mediaの名目上の方向に相対的な［
横幅, 縦幅
］を与える）。
両~属性とも、
指定する値は`妥当な負でない整数$でなければナラナイ。
◎
to give the dimensions of the visual content of the element (the width and height respectively, relative to the nominal direction of the output medium), in CSS pixels. The attributes, if specified, must have values that are valid non-negative integers.
</p>

<p>
指定する寸法は、
資源~自身に指定されている寸法から相違してもヨイ
— 資源の解像度は`~CSS~pixel$の解像度から相違することもあるので。
（`~CSS~pixel$の解像度は、
~screen上では 96ppi になるが，一般には 読み取り距離に依存する。）
両~属性とも指定する場合、
~OR↓ を満たさなければナラナイ：
◎
The specified dimensions given may differ from the dimensions specified in the resource itself, since the resource may have a resolution that differs from the CSS pixel resolution. (On screens, CSS pixels have a resolution of 96ppi, but in general the CSS pixel resolution depends on the reading distance.) If both attributes are specified, then one of the following statements must be true:
</p>
<ul>
	<li>
%W ~MINUS 0.5 ~LTE %H ~DIV %iH ~MUL %iW ~LTE %W ~PLUS 0.5
◎
specified width - 0.5 ≤ specified height * target ratio ≤ specified width + 0.5
</li>
	<li>
%H ~MINUS 0.5 ~LTE %W ~DIV %iW ~MUL %iH ~LTE %H ~PLUS 0.5
◎
specified height - 0.5 ≤ specified width / target ratio ≤ specified height + 0.5
</li>
	<li>
%H ~EQ %W ~EQ 0
◎
specified height = specified width = 0
</li>
</ul>

<p>
— ここで、
%W, %H は，順に
`width$a, `height$a
属性の値とする。
%iW, %iH は，順に資源の［
`生来な横幅$, `生来な縦幅$
］とする。
◎
The target ratio is the ratio of the natural width to the natural height in the resource. The specified width and specified height are the values of the width and height attributes respectively.
</p>

<p>
当の資源が`生来な横幅$も`生来な縦幅$も持たない場合、
両~属性とも省略しなければナラナイ。
◎
The two attributes must be omitted if the resource in question does not have both a natural width and a natural height.
</p>

<p>
両~属性とも値が 0 の場合、
要素は 利用者~向けに意図されていないことを指示する
（例：~pageが見られた回数を数える~service用途など）。
◎
If the two attributes are both 0, it indicates that the element is not intended for the user (e.g. it might be a part of a service to count page views).
</p>

<p class="note">注記：
これらの寸法~属性には、
画像を伸張する用途は意図されていない。
◎
The dimension attributes are not intended to be used to stretch the image.
</p>

				</section>
				<section>
<h5>
~UA要件
◎
User agent requirements:＼
</h5>

<p>
~UAには、［
`width$a, `height$a
］属性を`具現化~用の~hintに利用する＠~HTMLrendering#dimRendering$ことが期待される。
◎
User agents are expected to use these attributes as hints for the rendering.
</p>

<p class="note">注記：
これらの【内容~属性を`反映する$】~IDL属性の型は、［
`iframe$e ／ `embed$e ／ `object$e
］用には `DOMString^c であるが，［
`video$e ／ `source$e
］用には `unsigned long^c である。
◎
For iframe, embed and object the IDL attributes are DOMString; for video and source the IDL attributes are unsigned long.
</p>

<p class="note">注記：
［
`img$e ／ `input$e
］要素~上の対応する~IDL属性は、
各~要素の節にて定義される
— それらには、
それらの要素の他の挙動に特有な~~面が少しばかりあるので。
◎
The corresponding IDL attributes for img and input elements are defined in those respective elements' sections, as they are slightly more specific to those elements' other behaviors.
</p>

				</section>
			</section>
</main>

