<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — iframe, embed, object 要素 他（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		persisted_parts: Util.collectHtmlCodeList(),
		collectParts: Util.collectParts,
		toc_main: 'MAIN',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'mS':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U': 
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
case 'sl':
	text = `[[${key}]]`;
	break;
case 'xCode':
	return `<a id="_ex-${key}">＊</a>`;
	break;
case 'AA':
	return `<a href="~HTMLARIA#el-${key}">作者~向け</a>／<a href="~HTMLAAM#el-${key}">実装者~向け</a>`;
	break;
case 'obsMb':
	text = '廃用にされた~memberもある';
	href= `~HTMLLS/obsolete.html#${key}-partial`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2021-10-25
trans_update:2021-10-26
source_checked:201104
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/iframe-embed-object.html
	abbr_url:HEembed
nav_prev:HEimageAlt
nav_next:HEmedia
trans_1st_pub:2017-03-07

●●class_map
e:element
E:error
a:attr
aF:attr
aE:attr
aO:attr
aP:attr
et:event-type
sc:scheme
st:attr-state
sl:js-slot
v:value
h:header
U:code-point
obsMb:comment

●●tag_map
I:code
m:code
mP:code
mF:code
mE:code
mO:code
E:code
c:code
e:code
a:code
aF:code
aE:code
aO:code
aP:code
et:code
mt:code
st:span
sc:code
h:code
sub:sub
U:span
v:code
V:var
sl:span
i:i
cite:cite
obsMb:span

●●original_urls
mathml:https://html.spec.whatwg.org/multipage/embedded-content-other.html
svg-0:https://html.spec.whatwg.org/multipage/embedded-content-other.html
dimension-attributes:https://html.spec.whatwg.org/multipage/embedded-content-other.html

●●mdn_urls
the-embed-element:HTML/Element/embed
the-iframe-element:HTML/Element/iframe
the-object-element:HTML/Element/object
the-param-element:HTML/Element/param

htmlembedelement:API/HTMLEmbedElement
htmlobjectelement:API/HTMLObjectElement
htmliframeelement:API/HTMLIFrameElement
htmlparamelement:API/HTMLParamElement

●●original_id_map


●●link_map


CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor

I.DOMTokenList:~DOM4#interface-domtokenlist
I.Document:~HTMLdom#document
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLEmbedElement:#htmlembedelement
I.HTMLFormElement:~HEforms#htmlformelement
I.HTMLObjectElement:#htmlobjectelement
I.ValidityState:~HTMLforms#validitystate
~window:~WINDOW#the-window-object
	I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy
I.HTMLIFrameElement:#htmliframeelement
I.HTMLParamElement:#htmlparamelement

m.alert:~HTMLGAPI#dom-window-alert
m.checkValidity:~HTMLforms#dom-cva-checkvalidity
m.confirm:~HTMLGAPI#dom-window-confirm
m.form:~HTMLforms#dom-fae-form
m.getSVGDocument:#dom-media-getsvgdocument
m.prompt:~HTMLGAPI#dom-window-prompt
m.reportValidity:~HTMLforms#dom-cva-reportvalidity
m.requestFullscreen:~FULLSCREEN#dom-element-requestfullscreen
m.setCustomValidity:~HTMLforms#dom-cva-setcustomvalidity
m.validationMessage:~HTMLforms#dom-cva-validationmessage
m.validity:~HTMLforms#dom-cva-validity
m.value:~DOM4#dom-domtokenlist-value
m.willValidate:~HTMLforms#dom-cva-willvalidate
m.width:#dom-dim-width
m.height:#dom-dim-height

mF.allowFullscreen:#dom-iframe-allowfullscreen
mF.allow:#dom-iframe-allow
mF.contentDocument:#dom-iframe-contentdocument
mF.contentWindow:#dom-iframe-contentwindow
mF.name:#dom-iframe-name
mF.referrerPolicy:#dom-iframe-referrerpolicy
mF.loading:#dom-iframe-loading
mF.sandbox:#dom-iframe-sandbox
mF.src:#dom-iframe-src
mF.srcdoc:#dom-iframe-srcdoc

mE.src:#dom-embed-src
mE.type:#dom-embed-type

mO.contentDocument:#dom-object-contentdocument
mO.contentWindow:#dom-object-contentwindow
mO.data:#dom-object-data
mO.name:#dom-object-name
mO.type:#dom-object-type

mP.name:#dom-param-name
mP.value:#dom-param-value

e.embed:#the-embed-element
e.iframe:#the-iframe-element
e.object:#the-object-element
e.param:#the-param-element
e.video:~HEmedia#the-video-element
e.img:~HEimages#the-img-element
e.picture:~HEimages#the-picture-element
e.source:~HEimages#the-source-element
e.input:~HEinput#the-input-element

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.form:~HEforms#the-form-element

e.frame:~HTMLobs#frame

e.mi:~MATHML/chapter3.html#presm.mi
e.mn:~MATHML/chapter3.html#presm.mn
e.mo:~MATHML/chapter3.html#presm.mo
e.ms:~MATHML/chapter3.html#presm.ms
e.mtext:~MATHML/chapter3.html#presm.mtext
e.merror:~MATHML/chapter3.html#presm.merror
e.math:~MATHML/chapter2.html#interf.toplevel
e.annotation-xml:~MATHML/chapter5.html#mixing.elements.annotation.xml

e.foreignObject:~SVGembedded#ForeignObjectElement
e.svg:~SVGstruct#SVGElement
e.~svg-title:~SVGstruct#TitleElement

a.align:~HTMLobs#attr-embed-align
a.classid:~HTMLobs#attr-object-classid
a.hspace:~HTMLobs#attr-embed-hspace
a.name:~HTMLobs#attr-embed-name
a.vspace:~HTMLobs#attr-embed-vspace

a.form:~HTMLforms#attr-fae-form
a.width:#attr-dim-width
a.height:#attr-dim-height
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute
a.type:~HEinput#attr-input-type

aF.allow:#attr-iframe-allow
aF.allowfullscreen:#attr-iframe-allowfullscreen
aF.name:#attr-iframe-name
aF.referrerpolicy:#attr-iframe-referrerpolicy
aF.loading:#attr-iframe-loading
aF.sandbox:#attr-iframe-sandbox
aF.src:#attr-iframe-src
aF.srcdoc:#attr-iframe-srcdoc

aE.src:#attr-embed-src
aE.type:#attr-embed-type

aO.data:#attr-object-data
aO.name:#attr-object-name
aO.type:#attr-object-type

aP.name:#attr-param-name
aP.value:#attr-param-value

et.error:~HTMLindex#event-error
et.load:~HTMLindex#event-load
et.unload:~HTMLindex#event-unload


mt.application/octet-stream:~RFCx/rfc2046#section-4.5.1
mt.text/html:~HTMLiana#text/html
mt.text/plain:~RFCx/rfc2046#section-4.1.3
mt.image/svg+xml:~HTMLindex#image/svg+xml

sc.~about_blank:~HTMLdep#about:blank
sc.~about_srcdoc:~HTMLurl#about:srcdoc


v.allow-forms:~ORIGIN#attr-iframe-sandbox-allow-forms
v.allow-modals:~ORIGIN#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:~ORIGIN#attr-iframe-sandbox-allow-orientation-lock
v.allow-pointer-lock:~ORIGIN#attr-iframe-sandbox-allow-pointer-lock
v.allow-popups-to-escape-sandbox:~ORIGIN#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-downloads:~ORIGIN#attr-iframe-sandbox-allow-downloads
v.allow-popups:~ORIGIN#attr-iframe-sandbox-allow-popups
v.allow-presentation:~ORIGIN#attr-iframe-sandbox-allow-presentation
v.allow-same-origin:~ORIGIN#attr-iframe-sandbox-allow-same-origin
v.allow-scripts:~ORIGIN#attr-iframe-sandbox-allow-scripts
v.allow-top-navigation-by-user-activation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-top-navigation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation

st.Image:~HEinput#image-button-state-(type=image)
st.Eager:~HTMLurl#attr-loading-eager-state

i.~fallback:#_object-fallback
i.~dataなし:#_no-data

	●用語
~load~eventを遅延し得る:#potentially-delays-the-load-event
利用は許容されて:#allowed-to-use
~iframe-srcdoc文書:#an-iframe-srcdoc-document
~iframe~load~event手続き:#iframe-load-event-steps
~iframe~loadは進捗-中か:#iframe-load-in-progress
~iframe~loadを黙らすか:#mute-iframe-load
	:#shared-attribute-processing-steps-for-iframe-and-frame-elements
~iframeの属性を処理する:#process-the-iframe-attributes
現在の~naviは~lazyに読込まれるか:#current-navigation-was-lazy-loaded
~iframeを~navigateする:#navigate-an-iframe-or-frame

作動中になれ:#concept-embed-active

~embed要素を設定しておく:#the-embed-element-setup-steps
~embed~task源:#embed-task-source
内容の型を決定する:#concept-embed-type
~pluginを表示する:#display-a-plugin
~pluginなしを表示する:#display-no-plugin

	~instance化して利用する
利用するべき:#object-plugin
~pluginは~sandbox化されて:#sandboxPluginObject
~parameter:#concept-param-parameter

i.初回:#process-iframe-initial-insertion


	●用語HTML

寸法~属性:#dimension-attributes
~media要素:~HEmedia#media-element

~XML互換:~HTMLINFRA#xml-compatible
文書の中へ挿入され:~HTMLINFRA#insert-an-element-into-a-document
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document
~plugin:~HTMLINFRA#plugin
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications

反映する:~HTMLcdom#reflect
既知な値のみに制限され:~HTMLcdom#limited-to-only-known-values

~Content-Type:~HTMLurl#content-type
~Content-Type~metadata:~HTMLurl#content-type
	資源の／~associated／明示的な ~Content-Type~metadata
~referrer施策~属性:~HTMLurl#referrer-policy-attribute
相対的に~URL構文解析する:~HTMLurl#parse-a-url
前後~空白~可の妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces
~lazyに読込むことになる:~HTMLurl#will-lazy-load-element-steps
~lazy読込ng属性:~HTMLurl#lazy-loading-attribute
~lazy読込n再開~手続き:~HTMLurl#lazy-load-resumption-steps
~lazyに読込んでいる要素の交差~観測を開始する:~HTMLurl#start-intersection-observing-a-lazy-loading-element
~about_blank に合致して:~HTMLurl#matches-about:blank

真偽-属性:~HTMLcms#boolean-attribute
~space等で分離された一意な~token集合:~HTMLcms#_set-of-unique-space-separated-tokens
妥当な負でない整数:~HTMLcms#valid-non-negative-integer


分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~accessibilityの考慮点:~HTMLdom#concept-element-accessibility-considerations
~DOM~interface:~HTMLdom#concept-element-dom
埋込d内容:~HTMLdom#embedded-content-category
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句ng内容:~HTMLdom#phrasing-content-2
~fallback内容:~HTMLdom#fallback-content
透過的な内容:~HTMLdom#transparent
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
表現-:~HTMLdom#represents
要素間~空白:~HTMLdom#inter-element-whitespace

文書:~HTMLdom#the-document-object
まだ初期~about_blank 文書である:~HTMLdom#still-on-its-initial-about:blank-document
まだ初期~about_blank 文書で:~HTMLdom#still-on-its-initial-about:blank-document

~DOM操作~task源:~WAPI#dom-manipulation-task-source
関連な設定群~obj:~WAPI#relevant-settings-object
~event~loop:~WAPI#event-loop
~network用~task源:~WAPI#networking-task-source
~queueされ:~WAPI#queue-a-task
要素~taskを~queueする:~WAPI#queue-an-element-task
最初の段:~WAPI#step1
~task源:~WAPI#task-source
~task:~WAPI#concept-task
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin

syn.~comment:~HTMLwriting#syntax-comments
syn.要素:~HTMLwriting#syntax-elements
~DOCTYPE:~HTMLwriting#syntax-doctype
終了~tag:~HTMLwriting#syntax-end-tag
	~HTMLwriting#syntax-tag-omission
~HTML構文:~HTMLwriting#syntax

~HTML構文解析器:~HTMLparsing#html-parser
完全に読込まれ:~HTMLparsing#completely-loaded
~load~eventを遅延する:~HTMLparsing#delay-the-load-event
~load~eventを遅延して:~HTMLparsing#delay-the-load-event
~load後~task用に準備済み:~HTMLparsing#ready-for-post-load-tasks
~open要素~stack:~HTMLparsing#stack-of-open-elements

~listされる要素:~HEforms#category-listed
拘束~検証~API:~HTMLforms#the-constraint-validation-api
~form所有者:~HTMLforms#form-owner

~formに所有され得る要素:~HEforms#form-associated-element

一過な作動化？:~HTMLinteraction#transient-activation

~XML構文解析器:~HTMLxml#xml-parser
具現化されて:~HTMLrendering#being-rendered

作動中の文書:~BROWSERS#active-document
全部的に作動中:~BROWSERS#fully-active
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
妥当な閲覧文脈~名:~BROWSERS#valid-browsing-context-name
閲覧文脈~容器:~BROWSERS#browsing-context-container
	閲覧文脈~名:~BROWSERS#browsing-context-name
	＊~name:~BROWSERS#browsing-context-name
属する閲覧文脈:~BROWSERS#concept-document-bc
子~閲覧文脈:~BROWSERS#child-browsing-context
内容~文書:~BROWSERS#concept-bcc-content-document
新たな入子な閲覧文脈を作成する:~BROWSERS#creating-a-new-nested-browsing-context
~load~event遅延-中か:~BROWSERS#delaying-load-events-mode
入子な閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
作動中の~window:~BROWSERS#active-window

閲覧文脈を破棄する:~WINDOW#a-browsing-context-is-discarded
入子な閲覧文脈を破棄する:#_discard-nested-browsing-context
破棄され:~WINDOW#a-browsing-context-is-discarded

生成元:~ORIGIN#concept-origin
非同一-生成元:~ORIGIN#concept-origin
同一-生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
~iframe~sandbox法~flag集合:~ORIGIN#iframe-sandboxing-flag-set
~sandbox法~指令を構文解析する:~ORIGIN#parse-a-sandboxing-directive
閲覧文脈~sandbox化( ~plugin )~flag:~ORIGIN#sandboxed-plugins-browsing-context-flag

~URLと履歴を更新する:~HISTORY#url-and-history-update-steps

doc.許可~施策:~HTMLdom#concept-document-permissions-policy
~navigate:~NAVI#navigate
~navi:~NAVI#navigate
~source閲覧文脈:~NAVI#source-browsing-context
未読込みにされ:~NAVI#unload-a-document
V.履歴~取扱い:~NAVI#navigation-hh
i.既定:~NAVI#hh-default
i.置換-:~NAVI#hh-replace

単純~dialogを示せない:~HTMLGAPI#cannot-show-simple-dialogs

	●用語他
~ASCII英大文字:~INFRA#ascii-upper-alpha
~ASCII空白:~INFRA#ascii-whitespace
~HTML名前空間:~INFRA#html-namespace

~URL~record:~URL1#concept-url
~URL:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser
url.~path:~URL1#concept-url-path
url.素片:~URL1#concept-url-fragment
同等な~URL:~URL1#concept-url-equals

~fetch:~FETCH#concept-fetch
~ok状態s:~FETCH#ok-status
要請:~FETCH#concept-request
応答:~FETCH#concept-response
応答を処理する:~FETCH#process-response
~network~error:~FETCH#concept-network-error
本体と内容~型を抽出する:~FETCH#concept-bodyinit-extract

rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.~mode:~FETCH#concept-request-mode
rq.行先:~FETCH#concept-request-destination
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.~URL:~FETCH#concept-request-url
rq.~URL資格証を利用するか:~FETCH#concept-request-use-url-credentials-flag
rs.~URL~list:~FETCH#concept-response-url-list
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list
rs.~URL:~FETCH#concept-response-url

~MIME型:~MIMESNIFF#mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
資源に算出される~MIME型:~MIMESNIFF#computed-mime-type
画像を特定的に~sniffするための規則:~MIMESNIFF#rules-for-sniffing-images-specifically
~textか~binaryかを判別する規則:~MIMESNIFF#rules-for-text-or-binary
妥当な~MIME型~文字列:~MIMESNIFF#valid-mime-type

~eventを発火する:~DOM4#concept-event-fire
~HTML文書:~DOM4#html-document
doc.~URL:~DOM4#concept-document-url
doc.生成元:~DOM4#concept-document-origin
~XML文書:~DOM4#xml-document
文書~要素:~DOM4#document-element
文書~内に:~DOM4#in-a-document
~node文書:~DOM4#concept-node-document
~supportする~token集合:~DOM4#concept-supported-tokens
~tree順序:~DOM4#concept-tree-order

属性~値の正規化:https://www.w3.org/TR/xml/#AVNormalize
~referrer施策:~REFERRER-POLICY#referrer-policy

許可~施策:~PERMISSIONS-POLICY#permissions-policy
容器~施策:~PERMISSIONS-POLICY#container-policy
直列形の許可~施策:~PERMISSIONS-POLICY#serialized-permissions-policy
文書~内の特能は生成元~用に可能化されるか:~PERMISSIONS-POLICY#is-feature-enabled
許可~施策~属性を処理する:~PERMISSIONS-POLICY#process-permissions-policy-attributes
施策により制御される特能:~PERMISSIONS-POLICY#policy-controlled-feature

内在的~横幅:~CSSIMAGE#natural-width
内在的~縦幅:~CSSIMAGE#natural-height
~CSS~pixel:~CSSVAL#px


●●words_table1


MATHML:https://www.w3.org/Math/draft-spec
svg-title:title
about_blank:about:blank
about_srcdoc:about:srcdoc

●●words_table



	●仕様
proprietary::::プロプライエタリ
簡素:succinct:~
冗長:redundant:~
必要最小限:minimal:~
助け:help:~
誤解釈-:misinterpret:~
防ぐ:preventする:~
行使-:exercise:~
装う:pretendする:~
本当の:realな:~

	-:possible
	任意選択で:may
	能力を備え:capable
	いまいましいもの:annoyance
	-:manner
	〜により制御される特能:-controlled-feature
	~~定義済み:well-defined
	注意／:notice／note
	暗黙に:by implication
	困難:quite hard
	よい:may
	更には、:furthermore
	でなくとも:despite
	になり得る:potentially
	無にする:altogether
	ようがされまいが:regardless of
	単に:just
	そこで:prematurely
	としていることもある:might say
	併用:in conjunction with

	できるようにする:enable
	適合しない:not 〜 conforming ／ non-conformant
	選り分ける:reason about
	優先される:takes priority
	課す:imposeする
	選べる:pick
	できない:unable
	ままにされる:remain
	まま:remaining
	とする:suppose
	しないことを勧める:ill-advised
	覚えておく:remember
	~~発揮:take


	●network／navi
DNS:
ok:
遠隔:remote::~::リモート
sniff:
lazy:
為す:makeする:~
load:
	~load後:post-load
未読込みに:unload::未読み込みに::未ロードに
補助:auxiliary::~

	●保安
	~secure化-:secured
探査-:probe::~
脆弱:vulnerable::~
被害:damage:~
	~URL資格証~利用:use-URL-credential
騙され:trickされ:~
突破-:break out:~
	~~軽くする:lift
malware::::マルウェア
仕向けれ:convinceでき:~
仕向けて:convinceして:~
黙らす:muteする::~

	●構文
DOCTYPE:
	QUOTATION MARK 
	AMPERSAND
	LESS-THAN SIGN
	CHARACTER TABULATION
	LINE FEED
	LF
	CARRIAGE RETURN
	CR
	大文字:uppercase letter
英大文字:upper alpha::~
構文単位:syntactic component::~
省略不可:omissibleでない:~
省略:omission:~
	-:tab
ampersand::::アンパサンド
open::::
生の:raw:~
直列形の:serialized::~::シリアル形の
	終端-:end:~

	●embed／UI／内容
Content-Type:
MathML:
Flash:
iframe:
iframe-srcdoc:iframe srcdoc
embed:

popup::::ポップアップ
gadget::::ガジェット
再生器:player::~::プレイヤー

blog::::ブログ
modal::::モーダル

分類:categories:~
分類-:categorize:~
	分類される:falls into 〜 categories
透過的:transparent::~
句ng:phrasing::句::フレージング
可触:palpable::~

広告:advertising:~
広告unit:ad unit:広告 unit::広告ユニット
投稿:post::~
横:horizontal::~
縦:vertical::~
解像度:resolution::~
online::::オンライン
伸張-:stretch::~
一過:transient::~

	なし:none

	●data 型／操作／構造
回送-:forward::~
要素間:inter-element::~
	~popされ除かれ:popped off
	子たち:children

	●処理
増分的:incremental:~
再開:resumption::~
	%再開~手続き:resumptionSteps
	newly
	~access可能:accessible
	開始し直す:restart
	終:finish
	なった:become
	-:stopping
	でなくなった:stop
	回数を数える:count
	読み取り:reading
	時点で:marked as
	先送り可否:deferral
	この~algoの 〜 段~以降を走らす手続き:the rest of this algorithm starting with the step labeled 〜
	進捗-中:in progress

	初回:initialInsertion
	%初回か:initialInsertion

	●未分類
代理-:proxy::~::プロキシ
名目上の:nominal:~
代行業者:broker:~

	instance化:instantiate
	jump
	time
	~~不正な:malformed
	し直す:again
	同時に:simultaneous
	~iframe:fragment
	~~地点:point
	再度:re
	-:opt
	-:wherein
	-:straight
	-:leading
	-:followed by
	O3D
	GOTO:jump to the step below labeled
	-:name-value
	地図:map
	Geolocation
	`可能化される^i:"Enabled"
	-:exist
	送る:send
	現れ:appear
	~~供給-:furnish
	見られ:view


	●指示語
出自の:originating:~

	~~追加の:extra
	この時点で／今:now
	自身のみでは:on its own
	また:once more
	-:aforementioned
	とも:together
	どちらかは:At least
	一部:part of
	二重に:doubly
	次:next
	異なる／相異なる:different
	何か:anything
	対象に:target
	何も〜しない:nothing
	以前に:previously
	最後に:finally
	初めに:originally
	前の:previous
	様々な:various
	similar
	similarly
	他所へ:away
	1 列目
	以外
	以上
	一方
	次第
	時点
	場合


●●html_code_list



■iframe-1
<article>
 <h1>自分の雑誌ができた</h1>
 <p>頑張った甲斐あって、版元を見つけられた。ついに自分の雑誌を持てるようになった。最高だ！最初の号は９月になるよ。フードをゲットしたりボックスの中を見て回ることについての記事だ。楽しみだよ。</p>
 <footer>
  <p><a href="/users/cap">cap</a> さん（投稿： 1 時間前）
 </footer>
 <article>
  <footer> 13 分前, <a href="/users/ch">ch</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>表紙絵はできた？"></iframe>＞
 </article>
 <article>
  <footer> 9 分前, <a href="/users/cap">cap</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>もちろん、<a href=&quot;/gallery?mode=cover&amp;amp;page=1&quot;>僕のギャラリー</a>で見れるよ。"></iframe>＞
 </article>
 <article>
  <footer> 5 分前, <a href="/users/ch">ch</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>それ、 earl の食卓だな。
<p>次の表紙絵には earl&amp;amp;me を入れないとな。"></iframe>＞
 </article>

<article>
 <h1>I got my own magazine!</h1>
 <p>After much effort, I've finally found a publisher, and so now I
 have my own magazine! Isn't that awesome?! The first issue will come
 out in September, and we have articles about getting food, and about
 getting in boxes, it's going to be great!</p>
 <footer>
  <p>Written by <a href="/users/cap">cap</a>, 1 hour ago.
 </footer>
 <article>
  <footer> Thirteen minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>did you get a cover picture yet?"></iframe>
 </article>
 <article>
  <footer> Nine minutes ago, <a href="/users/cap">cap</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>Yeah, you can see it <a href="/gallery?mode=cover&amp;amp;page=1">in my gallery</a>."></iframe>
 </article>
 <article>
  <footer> Five minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>hey that's earl's table.
<p>you should get earl&amp;amp;me on the next cover."></iframe>
 </article>

	'

■iframe-2
<p>どんな内容だろうが恐るるに足らない。何も編集を加えていない投稿内容はここにある：</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>

<p>We're not scared of you! Here is your content, unedited:</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>

'

■iframe-3
<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">私的投稿</a></p>
 </header>
 <p>Check out my new ride!</p>
 ＜<iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>＞
</article>

<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">Private Post</a></p>
 </header>
 <main>
  <p>Check out my new ride!</p>
  <iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>
 </main>
</article>

■iframe-4
<iframe src="https://ads.example.com/?customerid=923513721&amp;format=banner"
        width="468" height="60"></iframe>

■embed-1
<embed src="catgame.swf">

■embed-2
<embed src="catgame.swf" quality="high">

■embed-3
<object data="catgame.swf">
 <param name="quality" value="high">
</object>

■param-1
<!DOCTYPE HTML>
<html lang="ja">
  <head>
   <title>O3D ユタティーポット</title>
  </head>
  <body>
   <p>
    <object type="application/vnd.o3d.auto">
     ＜<param name="o3d_features" value="FloatingPointTextures">＞
     <img src="o3d-teapot.png"
          title="O3D を利用して描画された 3D ユタティーポット"
          alt="O3D で描画されるユタティーポットは、周囲の光を反射する金属光沢と光源によるおぼろげな影を伴うように現れる。">
     <p>実際に O3D で描画されるユタティーポットを見るためには、<a href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install">O3D プラグイン</a>をダウンロードしてインストールする必要があります。</p>
    </object>
    <％script src="o3d-teapot.js"></％script>
   </p>
  </body>
</html>

<!DOCTYPE HTML>
<html lang="en">
  <head>
   <title>O3D Utah Teapot</title>
  </head>
  <body>
   <p>
    <object type="application/vnd.o3d.auto">
     <param name="o3d_features" value="FloatingPointTextures">
     <img src="o3d-teapot.png"
          title="3D Utah Teapot illustration rendered using O3D."
          alt="When O3D renders the Utah Teapot, it appears as a squat
          teapot with a shiny metallic finish on which the
          surroundings are reflected, with a faint shadow caused by
          the lighting.">
     <p>To see the teapot actually rendered by O3D on your
     computer, please download and install the <a
     href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install">O3D plugin</a>.</p>
    </object>
    <％script src="o3d-teapot.js"></％script>
   </p>
  </body>
</html>

■object-2
<figure>
 <object data="clock.html"></object>
 <figcaption>自作 HTML 時計</figcaption>
</figure>

 <figcaption>My HTML Clock</figcaption>

■object-3
<p>動画に注目：
 <object type="application/x-shockwave-flash">
  <param name=movie value="https://video.example.com/library/watch.swf">
  <param name=allowfullscreen value=true>
  <param name=flashvars value="https://video.example.com/vids/315981">
  <video controls src="https://video.example.com/vids/315981">
   <a href="https://video.example.com/vids/315981">動画を見る</a>
  </video>
 </object>
</p>

<p>Look at my video:
   <a href="https://video.example.com/vids/315981">View video</a>.

■mathml-1
<!DOCTYPE html>
<html lang="en">
 <head>
  <title>二次方程式の解の公式</title>
 </head>
 <body>
  <h1>二次方程式の解の公式</h1>
  <p>
   <math>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo form="prefix">−</mo> <mi>b</mi>
      <mo>±</mo>
      <msqrt>
       <msup> <mi>b</mi> <mn>2</mn> </msup>
       <mo>−</mo>
       <mn>4</mn> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mi>c</mi>
      </msqrt>
     </mrow>
     <mrow>
      <mn>2</mn> <mo>⁢</mo> <mi>a</mi>
     </mrow>
    </mfrac>
   </math>
  </p>
 </body>
</html>

The quadratic formula


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~HTMLLS/#toc-semantics">§ The elements of HTML</a>
内の
<a href="~SPEC_URL">iframe, embed, object 要素</a>
各節,
<a href="~HTMLLS/embedded-content-other.html">その他の埋め込み内容に関係する節</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


</head>
<body>


<header id="head">
	<hgroup>
<h1>iframe, embed, object 要素 他（埋め込み内容 — Embedded content ）</h1>
	</hgroup>

</header>

<main id="MAIN" hidden>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

<p>
この訳の，~algoの記述に利用されている各種記号（ε, コレ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
共通な記述を集約するため、次も定義する：
</p>

<div class="algo">
<p>
`入子な閲覧文脈を破棄する@
ときは、所与の
( 要素 %要素 )
に対し，次を走らす：
</p>

<ol>
	<li>
%B ~LET %要素 が`入子にしている閲覧文脈$
</li>
	<li>
~IF［
%B ~EQ ~NULL
］
⇒
~RET
</li>
	<li>
`閲覧文脈を破棄する$( %B )
</li>
	<li>
%要素 が`入子にしている閲覧文脈$ ~SET ~NULL
</li>
</ol>
</div>

			</section>
			<section id="the-iframe-element">
<h4 title="The iframe element">4.8.5. `iframe^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句ng内容$／`埋込d内容$／`対話的~内容$／`可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aF
— 埋込む資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`srcdoc$aF
— `iframe$e 内に具現化する文書
◎
srcdoc — A document to render in the iframe
</dd>
	<dd>
`name$aF
— `入子にしている閲覧文脈$の名前
◎
name — Name of nested browsing context
</dd>
	<dd>
`sandbox$aF
— 入子な内容に対する~security規則
◎
sandbox — Security rules for nested content
</dd>
	<dd>
`allow$aF
— `iframe$e の内容に適用されることになる`許可~施策$
◎
allow — Permissions policy to be applied to the iframe's contents
</dd>
	<dd>
`allowfullscreen$aF
— `iframe$e の内容が `requestFullscreen()$m を利用するのを許容するかどうか
◎
allowfullscreen — Whether to allow the iframe's contents to use requestFullscreen()
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
`referrerpolicy$aF
— この要素により起動された`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>
	<dd>
`loading$aF
— 読み込みの先送り可否を決定するときに利用される。
◎
loading — Used when determining loading deferral
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`iframe$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLIFrameElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute USVString `src$mF;
  [`CEReactions$] attribute DOMString `srcdoc$mF;
  [`CEReactions$] attribute DOMString `name$mF;
  [SameObject, PutForwards=`value$m] readonly attribute `DOMTokenList$I `sandbox$mF;
  [`CEReactions$] attribute DOMString `allow$mF;
  [`CEReactions$] attribute boolean `allowFullscreen$mF;
  [`CEReactions$] attribute DOMString `width$m;
  [`CEReactions$] attribute DOMString `height$m;
  [`CEReactions$] attribute DOMString `referrerPolicy$mF;
  [`CEReactions$] attribute DOMString `loading$mF;
  readonly attribute `Document$I? `contentDocument$mF;
  readonly attribute `WindowProxy$I? `contentWindow$mF;
  `Document$I? `getSVGDocument$m();

  // `HTMLIFrameElement$obsMb
};
</pre>

	</dd>
</dl>

<p>
`iframe$e 要素は、自身が`入子にしている閲覧文脈$を`表現-$する。
◎
The iframe element represents its nested browsing context.
</p>

<p>
`src@aF
属性は、要素が`入子にしている閲覧文脈$が包含することになる~pageの`~URL$を与える。
この属性が在る場合の値は、`前後~空白~可の妥当かつ空でない~URL$でなければナラナイ。
`iframe$e 要素が `itemprop$a 属性を有する場合、この属性も有していなければナラナイ。
◎
The src attribute gives the URL of a page that the element's nested browsing context is to contain. The attribute, if present, must be a valid non-empty URL potentially surrounded by spaces. If the itemprop attribute is specified on an iframe element, then the src attribute must also be specified.
</p>

<p>
`srcdoc@aF
属性は、要素が`入子にしている閲覧文脈$が包含することになる内容を与える。
この属性の値が
`~iframe-srcdoc文書@
の~sourceを与える。
◎
The srcdoc attribute gives the content of the page that the element's nested browsing context is to contain. The value of the attribute is the source of an iframe srcdoc document.
</p>

<p>
`srcdoc$aF 属性に指定する値は、次に与える順による構文単位からなる`~HTML構文$を利用する値でなければナラナイ：
◎
The srcdoc attribute, if present, must have a value using the HTML syntax that consists of the following syntactic components, in the given order:
</p>

<ol>
	<li>
任意~個数の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
	<li>
0 〜 1 個の `~DOCTYPE$
◎
Optionally, a DOCTYPE.
</li>
	<li>
任意~個数の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
	<li>
`html$e `要素$synの形による`文書~要素$
◎
The document element, in the form of an html element.
</li>
	<li>
任意~個数の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
</ol>

<p class="note">注記：
上の要件は、`~XML文書$にも適用される。
◎
The above requirements apply in XML documents as well.
</p>

<div class="example">

<p>
次の~blogでは、
`srcdoc$aF, 下に述べる `sandbox$aF
両~属性を併用して，この特能を~supportする~UAの利用者に［
~blog投稿~commentによる~script注入から保護する~~追加の層
］を伴わせて供している：
◎
Here a blog uses the srcdoc attribute in conjunction with the sandbox attribute described below to provide users of user agents that support this feature with an extra layer of protection from script injection in the blog post comments:
</p>

`iframe-1^xCode

<p>
引用符は~escapeされる必要があることに加え（さもなければ、 `srcdoc$aF 属性は そこで終端してしまう）、~sandbox化された内容（例：~URLや注釈文~内）における生の~ampersand（ `&amp;^l ）は，<em>二重に</em>~escapeされる必要があることにも注意
— `srcdoc$aF 属性が初めに構文解析されるときに ~ampersandが保全され，その後 ~sandbox化された内容がまた構文解析されるときにも ~ampersandが誤解釈されるのを防ぐため。
◎
Notice the way that quotes have to be escaped (otherwise the srcdoc attribute would end prematurely), and the way raw ampersands (e.g. in URLs or in prose) mentioned in the sandboxed content have to be doubly escaped — once so that the ampersand is preserved when originally parsing the srcdoc attribute, and once more to prevent the ampersand from being misinterpreted when parsing the sandboxed content.
</p>

<p>
更には，
`srcdoc$aF 属性~内の~markupは、文書~全体を表現しているにもかかわらず，~~比較的 簡素にできることにも注意
— ［
`html$e, `head$e, `body$e
］要素の
<a href="~HTMLwriting#syntax-tag-omission">開始~tag／終了~tagは省略可能</a>
であり（省略されても，依然として暗黙に在る），
`~iframe-srcdoc文書$においては［
`~DOCTYPE$ ／ `title$e 要素
］も省略可能なので、構文~内に~literalに現れる必要があるのは， `body$e 要素の内容のみになるので。
◎
Furthermore, notice that since the DOCTYPE is optional in iframe srcdoc documents, and the html, head, and body elements have optional start and end tags, and the title element is also optional in iframe srcdoc documents, the markup in a srcdoc attribute can be relatively succinct despite representing an entire document, since only the contents of the body element need appear literally in the syntax. The other elements are still present, but only by implication.
</p>

</div>

<div class="note">
<p>注記：
`~HTML構文$においては、作者が覚えておく必要があるのは，次の点に限られる：
</p>

<ul ><li>文字 `0022^U `"^smb を利用して，属性の内容を包装する。
</li><li>次に、文字 `0026^U `&amp;^smb をすべて~escapeしてから，文字 `0022^U `"^smb をすべて~escapeする（逆順に行うと、引用符は二重に~escapeされ， `&amp;quot;^l から `&amp;amp;quot;^l になってしまう）。
</li><li>`sandbox$aF 属性を指定して、内容の安全な埋込みを確保する。
</li></ul>

◎
In the HTML syntax, authors need only remember to use U+0022 QUOTATION MARK characters (") to wrap the attribute contents and then to escape all U+0026 AMPERSAND (&amp;) and U+0022 QUOTATION MARK (") characters, and to specify the sandbox attribute, to ensure safe embedding of content. (And remember to escape ampersands before quotation marks, to ensure quotation marks become &amp;quot; and not &amp;amp;quot;.)
</div>

 <p class="note">注記：
~XMLにおいては、`属性~値の正規化$を防止するため，
`003C^U `&lt;^smb
も~escapeされる必要がある。
~XMLの一部の空白~文字，
 — 特定的には
`0009^U CHARACTER TABULATION（ tab ）,
`000A^U LINE FEED（ LF ）,
`000D^U  CARRIAGE RETURN（ CR ）
—
も~escapeされる必要がある。
`XML$r
◎
In XML the U+003C LESS-THAN SIGN character (&lt;) needs to be escaped as well. In order to prevent attribute-value normalization, some of XML's whitespace characters — specifically U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), and U+000D CARRIAGE RETURN (CR) — also need to be escaped. [XML]
</p>

<p class="note">注記：
`src$aF, `srcdoc$aF
両~属性とも指定された場合、 `srcdoc$aF 属性が優先される。
これにより，作者は、 `srcdoc$aF 属性を~supportしない旧来の~UA用に~fallback `~URL$を供せるようになる。
◎
If the src attribute and the srcdoc attribute are both specified together, the srcdoc attribute takes priority. This allows authors to provide a fallback URL for legacy user agents that do not support the srcdoc attribute.
</p>

<hr>

<div class="algo">
<p>
`iframe$e 要素 %iframe が`文書の中へ挿入され$たときは、~UAは次を走らすモノトスル：
◎
When an iframe element element is inserted into a document＼
</p>
<ol>
	<li>
~IF［
文書が`属する閲覧文脈$ ~EQ ~NULL
］
⇒
~RET
◎
whose browsing context is non-null, the user agent must run these steps:
</li>
	<li>
`新たな入子な閲覧文脈を作成する$( %iframe )
◎
Create a new nested browsing context for element.
</li>
	<li>
~IF［
%iframe は `sandbox$aF 属性を有する
］
⇒
`~sandbox法~指令を構文解析する$( %iframe の `sandbox$aF 属性の値, %iframe の`~iframe~sandbox法~flag集合$ )
◎
If element has a sandbox attribute, then parse the sandboxing directive given the attribute's value and element's iframe sandboxing flag set.
</li>
	<li>
`~iframeの属性を処理する$( %iframe, `初回$i )
◎
Process the iframe attributes for element, with initialInsertion set to true.
</li>
</ol>
</div>

<div class="algo">
<p>
［
`iframe$e 要素 %iframe が`入子にしている閲覧文脈$ ~NEQ ~NULL
］の下では、~UAは，次に従うモノトスル：
◎
↓</p>

<ul>
	<li>
<p>
%iframe が`文書から除去され$たときは
⇒＃
`入子な閲覧文脈を破棄する$( %iframe )
◎
When an iframe element is removed from a document, the user agent must discard the element's nested browsing context, if it is not null, and then set the element's nested browsing context to null.
</p>

<p class="note">注記：
これは、 `unload$et ~eventは発火されずに起こる（ %iframe が`入子にしている閲覧文脈$は それに属する`文書$とともに<em>`破棄され$</em>, <em>`未読込みにされ$ない</em>）。
◎
This happens without any unload events firing (the element's nested browsing context and its Document are discarded, not unloaded).
</p>
	</li>
	<li>
%iframe の `srcdoc$aF 属性が［
設定- ／ 変更- ／ 除去-
］されたときは
⇒
`~iframeの属性を処理する$( %iframe )
◎
Whenever an iframe element with a non-null nested browsing context has its srcdoc attribute set, changed, or removed, the user agent must process the iframe attributes.
</li>
	<li>
%iframe の `src$aF 属性が［
設定- ／ 変更- ／ 除去-
］されたときは
⇒
~IF［
%iframe は `srcdoc$aF 属性を有していない
］
⇒
`~iframeの属性を処理する$( %iframe )
◎
Similarly, whenever an iframe element with a non-null nested browsing context but with no srcdoc attribute specified has its src attribute set, changed, or removed, the user agent must process the iframe attributes.
</li>
</ul>
</div>

<div class="algo">
<p>
`~iframeの属性を処理する@
ときは、所与の
( `iframe$e 要素 %iframe, %初回か ~IN { `初回@i, ε }（省略時は ε ） )
に対し，次を走らすモノトスル：
◎
To process the iframe attributes for an element element, with an optional boolean initialInsertion (default false):
</p>
<ol>
	<li>
%B ~LET %iframe が`入子にしている閲覧文脈$
◎
↓</li>
	<li>
~Assert：
%B ~NEQ ~NULL
【この段は、この訳による補完。】
</li>
	<li>
<p>
~IF［
%iframe は `srcdoc$aF 属性を有する
］：
◎
If element's srcdoc attribute is specified, then:
</p>
		<ol>
			<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~F
◎
Set element's current navigation was lazy loaded boolean to false.
</li>
			<li>
<p>
~IF［
`~lazyに読込むことになる$( %iframe ) ~EQ ~T
］：
◎
If the will lazy load element steps given element return true, then:
</p>
				<ol>
					<li>
%iframe の`~lazy読込n再開~手続き$ ~SET この~algoの `srcdoc 資源へ~navigateする^i 段~以降を走らす手続き
◎
Set element's lazy load resumption steps to the rest of this algorithm starting with the step labeled navigate to the srcdoc resource.
</li>
					<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~T
◎
Set element's current navigation was lazy loaded boolean to true.
</li>
					<li>
`~lazyに読込んでいる要素の交差~観測を開始する$( %iframe )
◎
Start intersection-observing a lazy loading element for element.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
<div class="p">
<p>
`srcdoc 資源へ~navigateする^i：
</p>
				<ol>
					<li>
<p>
%応答 ~LET 次のようにされた新たな`応答$
⇒＃
`~URL~list$rs ~SET « `~about_srcdoc$sc »,
`~header~list$rs ~SET « ( ``^`Content-Type^h``^, ``^`text/html$mt``^ ) »,
`本体$rs ~SET %iframe の `srcdoc$aF 属性の値†
</p>

<p class="trans-note">【†
`本体$rsは，実際には~byte~streamその他からなる構造体なので、
厳密には，値を変換する必要がある（`本体と内容~型を抽出する$などに似た手続きを通して）。
】</p>
					</li>
					<li>
`~iframeを~navigateする$( %iframe, %応答 )
</li>
					<li>
~RET
</li>
				</ol>
◎
Navigate to the srcdoc resource: navigate an iframe or frame given element and a new response whose URL list is « about:srcdoc », header list is « (`Content-Type`, `text/html`) », and body is the value of element's srcdoc attribute.
</div>

<p>
この段による結果の`文書$は、`~iframe-srcdoc文書$と見なすモノトスル。
◎
The resulting Document must be considered an iframe srcdoc document.
</p>

			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise, run the shared attribute processing steps for iframe and frame elements given element and initialInsertion.
◎
The shared attribute processing steps for iframe and frame elements, given an element element and a boolean initialInsertion, are:
</p>

<p class="trans-note">【
この段の内容は，原文では
<dfn id="shared-attribute-processing-steps-for-iframe-and-frame-elements">`iframe^e, `frame^e 要素~用の共用~属性~処理~手続き</dfn>
【！旧 id otherwise-steps-for-iframe-or-frame-elements】
として別に定義されているが（すなわち， `frame$e 要素からも利用される）、
この訳では，この手続きの中に統合する
（廃用にされた `frame^e 要素を和訳するつもりはないので）。
加えて、 `frame^e 要素に対しては，以下における “~lazy読込n” に関する段は遂行されない。
下に与える`~iframeを~navigateする$も，実際には `frame^e 要素からも利用されるが、
同様に（命名を）簡素化している。
】</p>
		<ol>
			<li>
%~URL ~LET `~URL~record$ `~about_blank$sc
◎
Let url be the URL record about:blank.
</li>
			<li>
<p>
~IF［
%iframe は `src$aF 属性を有していて，その値 %src ~NEQ 空~文字列
］：
◎
If element has a src attribute specified, and its value is not the empty string,＼
</p>
				<ol>
					<li>
%src ~SET `相対的に~URL構文解析する$( %src, %iframe の`~node文書$ )
◎
then parse the value of that attribute relative to element's node document.＼
</li>
					<li>
~IF［
%src ~NEQ `失敗^i
］
⇒
%~URL ~SET %src
◎
If this is successful, then set url to the resulting URL record.
</li>
				</ol>
			</li>
			<li>
~IF［
%B のある`先祖~閲覧文脈$にて`作動中の文書$の`~URL$docは，
`素片$urlは無視して %~URL に等しい
【おそらく， “`素片は除外する^i 下で`同等な~URL$” を意味する】
］
⇒
~RET
◎
If there exists an ancestor browsing context of element's nested browsing context whose active document's URL, ignoring fragments, is equal to url, then return.
</li>
			<li>
<p>
~IF［
%~URL は`~about_blank に合致して$いる
］~AND［
%初回か ~EQ `初回$i
］：
◎
If url matches about:blank and initialInsertion is true, then:
</p>
				<ol>
					<li>
<p>
`~URLと履歴を更新する$( %B にて`作動中の文書$, %~URL )
◎
Perform the URL and history update steps given element's nested browsing context's active document and url.
</p>

<p class="note">注記：
この段は、
%~URL が `about:blank?foo^l の様な何かである事例で必要とされる。
%~URL は単に素な `~about_blank^sc の場合、
この段は何もしない。
◎
This is necessary in case url is something like about:blank?foo. If url is just plain about:blank, this will do nothing.
</p>
					</li>
					<li>
`~iframe~load~event手続き$( %iframe )
◎
Run the iframe load event steps given element.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
%資源 ~LET 次のようにされた新たな`要請$
⇒＃
`~URL$rq ~SET %~URL,
`~referrer施策$rq ~SET %iframe の `referrerpolicy$aF 内容~属性の現在の状態
◎
Let resource be a new request whose URL is url and whose referrer policy is the current state of element's referrerpolicy content attribute.
</li>

			<li>
【！If element is an iframe element, then】
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~F
◎
If element is an iframe element, then set element's current navigation was lazy loaded boolean to false.
</li>
			<li>
<p>
【！If element is an iframe element, and】
~IF［
`~lazyに読込むことになる$( %iframe ) ~EQ ~T
］：
◎
If element is an iframe element, and the will lazy load element steps given element return true, then:
</p>
				<ol>
					<li>
%iframe の`~lazy読込n再開~手続き$ ~SET この~algoの `資源へ~navigateする^i 段~以降を走らす手続き
◎
Set element's lazy load resumption steps to the rest of this algorithm starting with the step labeled navigate to the resource.
</li>
					<li>
%iframe の`現在の~naviは~lazyに読込まれるか$ ~SET ~T
◎
Set element's current navigation was lazy loaded boolean to true.
</li>
					<li>
`~lazyに読込んでいる要素の交差~観測を開始する$( `iframe$e 要素 )
◎
Start intersection-observing a lazy loading element for element.
</li>
					<li>
~RET
◎
Return.
</li>
				</ol>
			</li>
			<li>
`資源へ~navigateする^i
⇒
`~iframeを~navigateする$( %iframe, %資源 )
◎
Navigate to the resource: navigate an iframe or frame given element and resource.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`~iframeを~navigateする@
ときは、所与の
( `iframe$e 要素 %iframe, 資源 %資源 )
に対し：
◎
To navigate an iframe or frame given an element element and a resource resource:
</p>
<ol>
	<li>
%B ~LET %iframe が`入子にしている閲覧文脈$
◎
↓</li>
	<li>
<p>
%履歴~取扱い ~LET ［
次が満たされるならば `置換-$i ／
~ELSE_ `既定$i
］
⇒
［
%B は`まだ初期~about_blank 文書である$
］~OR［
%B にて`作動中の文書$は`完全に読込まれ$ていない
］
◎
Let historyHandling be "default".
◎
If element's nested browsing context is still on its initial about:blank Document, then set historyHandling to "replace".
◎
If element's nested browsing context's active document is not completely loaded, then set historyHandling to "replace".
</li>
	<li>
%B を %資源 へ`~navigate$する
— 次を与える下で
⇒＃
`履歴~取扱い$V ~SET %履歴~取扱い,
`~source閲覧文脈$ ~SET  %iframe の`~node文書$が`属する閲覧文脈$
◎
Navigate element's nested browsing context to resource, with historyHandling set to historyHandling and the source browsing context set to element's node document's browsing context.
</li>
</ol>
</div>

<p class="note">注記：
`iframe$e 要素の作成-時には、その中へ読込まれる他の~dataはない場合には，
要素に向けて `load$et ~eventも発火される。
◎
A load event is also fired at the iframe element when it is created if no other data is loaded in it.
</p>

<p>
各 `文書$は、真偽値をとる
`~iframe~loadは進捗-中か@,
`~iframe~loadを黙らすか@
を持つ
— いずれも，`文書$の作成-時には ~F になるモノトスル。
◎
Each Document has an iframe load in progress flag and a mute iframe load flag. When a Document is created, these flags must be unset for that Document.
</p>

<div class="algo">
<p>
`~iframe~load~event手続き@
は、所与の
( `iframe$e 要素 %iframe )
に対し，次を走らす：
◎
To run the iframe load event steps, given an iframe element element:
</p>
<ol>
	<li>
%B ~LET %iframe が`入子にしている閲覧文脈$
◎
↓</li>
	<li>
~Assert：
%B ~NEQ ~NULL
◎
Assert: element's nested browsing context is not null.
</li>
	<li>
%子~文書 ~LET %B にて`作動中の文書$
◎
Let childDocument be the active document of element's nested browsing context.
</li>
	<li>
~IF［
%子~文書 の`~iframe~loadを黙らすか$ ~EQ ~T
］
⇒
~RET
◎
If childDocument has its mute iframe load flag set, then return.
</li>
	<li>
%子~文書 の`~iframe~loadは進捗-中か$ ~SET ~T
◎
Set childDocument's iframe load in progress flag.
</li>
	<li>
`~eventを発火する$( %iframe, `load$et )
◎
Fire an event named load at element.
</li>
	<li>
%子~文書 の`~iframe~loadは進捗-中か$ ~SET ~F
◎
Unset childDocument's iframe load in progress flag.
</li>
</ol>
</div>

<p class="warning">
これを~scriptingと併用すれば、局所~networkの~HTTP~serverの~URL空間を探査する攻撃にも利用できる。
~UAは、これを軽減するため，上に述べたものより厳密な［
`非同一-生成元$に対する~access制御~用の施策
］を実装してもヨイ
— が，あいにく そのような施策は、概して，既存の~web内容と互換にならない。
◎
This, in conjunction with scripting, can be used to probe the URL space of the local network's HTTP servers. User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing web content.
</p>

<p>
所与の要素~型が
`~load~eventを遅延し得る@
ならば、~UAは，そのような要素~型の各 %要素 に対し、［
%要素 が`入子にしている閲覧文脈$ %B が， ~NULL でない, かつ次のいずれかを満たしている
］間は，
%要素 の`~node文書$の`~load~eventを遅延する$モノトスル：
◎
If an element type potentially delays the load event, then for each element element of that type, the user agent must delay the load event of element's node document if element's nested browsing context is non-null and any of the following are true:
</p>

<ul>
	<li>
%B にて`作動中の文書$の`~load後~task用に準備済み$でない
◎
element's nested browsing context's active document is not ready for post-load tasks.
</li>
	<li>
%B にて`作動中の文書$の`~load~eventを遅延して$いる何かがある
◎
Anything is delaying the load event of element's nested browsing context's active document.
</li>
	<li>
%B の`~load~event遅延-中か$ ~EQ ~T
◎
element's nested browsing context is in the delaying load events mode.
</li>
</ul>

<p class="note">注記：
`load$et ~eventの取扱い中に %B が再度`~navigate$された場合、それにより更に`~load~eventを遅延する$ことになる。
◎
If, during the handling of the load event, element's nested browsing context is again navigated, that will further delay the load event.
</p>

<p>
各 `iframe$e 要素には、真偽値をとる
`現在の~naviは~lazyに読込まれるか@
が結付けられ，初期~時は ~F とする。
それは、`~iframeの属性を処理する$中で［
~T／~F
］に設定される。
◎
Each iframe element has an associated current navigation was lazy loaded boolean, initially false. It is set and unset in the process the iframe attributes algorithm.
</p>

<p>
`iframe$e 要素は、［
`現在の~naviは~lazyに読込まれるか$ ~EQ ~F
］ならば，`~load~eventを遅延し得る$とする。
◎
An iframe element whose current navigation was lazy loaded boolean is false potentially delays the load event.
</p>

<p class="note">注記：
当の要素†の作成-時に，［
`srcdoc$aF 属性を有してなかった
］~AND［
`src$aF 属性を有してなかったか, 有していたが その値を`相対的に~URL構文解析する$のに失敗した
］場合、要素が`入子にしている閲覧文脈$は，`まだ初期~about_blank 文書で$あり続けることになる。
【† `iframe^e 要素に限られない？ — この注記は、過去には，他の要素にも適用される “`~load~eventを遅延し得る$” のすぐ後に置かれていたので。】
◎
If, when the element is created, the srcdoc attribute is not set, and the src attribute is either also not set or set but its value cannot be parsed, the browsing context will remain at the initial about:blank Document.
</p>

<p class="note">注記：
利用者がこの~page【 `~about_blank^sc に限られない？】から他所へ`~navigate$した場合、
`iframe$e 要素が`入子にしている閲覧文脈$の `WindowProxy$I ~objは，新たな`文書$用の新たな`~window$を代理することになるが、要素の `src$aF 属性は変化しない。
◎
If the user navigates away from this page, the iframe's nested browsing context's WindowProxy object will proxy new Window objects for new Document objects, but the src attribute will not change.
</p>

<hr>

<p>
`name@aF
属性に指定する値は、`妥当な閲覧文脈~名$でなければナラナイ。
その値は、当の `iframe$e 要素が`入子にしている閲覧文脈$に名前を与えるために利用される
— その閲覧文脈が作成される時点で この属性が在るならば。
◎
The name attribute, if present, must be a valid browsing context name. The given value is used to name the element's nested browsing context if present when that is created.
</p>

<hr>

<p>
`iframe$e 要素に
`sandbox@aF
属性が指定された場合、要素が~hostする内容に対し，~~追加の制約の集合を可能化する。
指定する値は、［
`~space等で分離された一意な~token集合$（大小無視）
］でなければナラナイ。
下の表の 1 列目に挙げる~keyword値が~tokenとして許容される。
◎
The sandbox attribute, when specified, enables a set of extra restrictions on any content hosted by the iframe. Its value must be an unordered set of unique space-separated tokens that are ASCII case-insensitive. The allowed values are allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-popups-to-escape-sandbox, allow-presentation, allow-same-origin, allow-scripts, allow-top-navigation, allow-top-navigation-by-user-activation, and allow-downloads.
</p>

<p>
この属性が設定された下では、要素により埋込まれる内容は，一意な`生成元$に属するものと扱われ、それにより，［
~form, ~script, 様々な悩ましいものになり得る~API
］は不能化され,
~linkに対しては 他の`閲覧文脈$を~targetにすることは防止され,
~pluginは~secure化される。
加えて，各種~keywordには、これらの制約の一部を緩めるような次の効果がある：
◎
When the attribute is set, the content is treated as being from a unique origin, forms, scripts, and various potentially annoying APIs are disabled, links are prevented from targeting other browsing contexts, and plugins are secured.＼
</p>

<div>
<table>
<caption>`sandbox$aF 属性に指定できる~keywordとその効果</caption>
<thead><tr><th>~keyword
<td>効果
【詳細は、<a href="~ORIGIN#sandboxing">§ ~sandbox法</a>を見よ】
</thead>

<tbody>
<tr><td>`allow-same-origin$v
<td>内容を一意な生成元の中に強制する代わりに，その本当の生成元に属するものと扱われるようにする

<tr><td>`allow-top-navigation$v
<td>内容が その`~top-level閲覧文脈$を`~navigate$できるようにする

<tr><td>`allow-top-navigation-by-user-activation$v
<td>`allow-top-navigation$v と同様に挙動するが、そのような`~navi$を許容するのを［
`~source閲覧文脈$にて`作動中の~window$の`一過な作動化？$ ~EQ ~T
］のときに限るようにする

<tr><td>`allow-forms$v
<td>~formを可能化し直す

<tr><td>`allow-modals$v
<td>~modal~dialogを可能化し直す

<tr><td>`allow-orientation-lock$v
<td>~screen方位~lockを可能化し直す
`SCREENORIENTATION$r

<tr><td>`allow-pointer-lock$v
<td>~pointer~lock~APIを可能化し直す
`POINTERLOCK$r

<tr><td>`allow-popups$v
<td>~popupを可能化し直す

<tr><td>`allow-presentation$v
<td>呈示~APIを可能化し直す
`PRESENTATION$r

<tr><td>`allow-scripts$v
<td>~scriptを可能化し直す

<tr><td>`allow-popups-to-escape-sandbox$v
<td>~sandbox化されない`補助~閲覧文脈$の作成を可能化し直す

<tr><td>`allow-downloads$v
<td>~downloadを遂行することを内容に許容する

</tbody></table>

◎
The allow-same-origin keyword causes the content to be treated as being from its real origin instead of forcing it into a unique origin;＼
the allow-top-navigation keyword allows the content to navigate its top-level browsing context;＼
the allow-top-navigation-by-user-activation keyword behaves similarly but allows such navigation only when the browsing context's active window has transient activation;＼
and the allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-presentation, allow-scripts, and allow-popups-to-escape-sandbox keywords re-enable forms, modal dialogs, screen orientation lock, the pointer lock API, popups, the presentation API, scripts, and the creation of unsandboxed auxiliary browsing contexts respectively.＼
The allow-downloads keyword allows content to perform downloads.＼
[POINTERLOCK] [SCREENORIENTATION] [PRESENTATION]
</div>

<p>
`allow-top-navigation$v,
`allow-top-navigation-by-user-activation$v
両~keywordとも指定してはナラナイ
— そうすることは冗長なので。
そのような適合しない~markupにおいては、 `allow-top-navigation$v のみ効果がある。
◎
The allow-top-navigation and allow-top-navigation-by-user-activation keywords must not both be specified, as doing so is redundant; only allow-top-navigation will have an effect in such non-conformant markup.
</p>

<p class="note">注記：
~sandbox化された内容の内側で［
`alert()$m ／
`confirm()$m ／
`prompt()$m
］を許容するためには、
`allow-modals$v,
`allow-same-origin$v
両~keywordを指定する必要があり，読込まれる~URLは`~top-level生成元$enVと`同一-生成元$である必要もある。
`allow-same-origin$v ~keywordを伴わない場合、内容は常に非同一-生成元に属するものと扱われ，`単純~dialogを示せない$。
◎
To allow alert(), confirm(), and prompt() inside sandboxed content, both the allow-modals and allow-same-origin keywords need to be specified, and the loaded URL needs to be same origin with the top-level origin. Without the allow-same-origin keyword, the content is always treated as cross-origin, and cross-origin content cannot show simple dialogs.
</p>

<p class="warning">
`allow-scripts$v, `allow-same-origin$v
両~keywordとも設定することは、［
埋込まれた~pageと それを包含している `iframe$e とが`同一-生成元$に属する
］ときには，［［
埋込まれた~pageが単純に `sandbox$aF 属性を除去して，自身を再度~読込む
］ことにより，実質的に~sandboxを突破して無にする
］ことを許容することになる。
◎
Setting both the allow-scripts and allow-same-origin keywords together when the embedded page has the same origin as the page containing the iframe allows the embedded page to simply remove the sandbox attribute and then reload itself, effectively breaking out of the sandbox altogether.
</p>

<p class="warning">
これらの~flagが効果を~~発揮するのは、当の `iframe$e 要素が`入子にしている閲覧文脈$が`~navigate$されるときに限られる。
すでに読込まれた~pageに対しては、それらの一部を除去しようが `sandbox$aF 属性をまるごと除去しようが，効果はない。
◎
These flags only take effect when the nested browsing context of the iframe element is navigated. Removing them, or removing the entire sandbox attribute, has no effect on an already-loaded page.
</p>

<p class="warning">
敵対的になり得る~fileは、当の `iframe$e 要素を包含している~fileと同じ~serverから~serveされるべきでない。
敵対的な内容を~sandbox化することは、攻撃者が［
`iframe$e 内ではなく，敵対的な内容へ直に訪問する
］よう利用者を仕向けれる場合のためにある，必要最小限な助けでしかない。
敵対的な~HTML内容がもたらし得る被害を制限するには、別々の専用~domainから~serveするべきである。
異なる~domainを利用すれば、利用者が `sandbox$aF 属性の保護なしに，そのような~pageへ直に訪問するよう騙された場合でも，~file内の~scriptは~siteを攻撃-不能になることが確保される。
◎
Potentially hostile files should not be served from the same server as the file containing the iframe element. Sandboxing hostile content is of minimal help if an attacker can convince the user to just visit the hostile content directly, rather than in the iframe. To limit the damage that can be caused by hostile HTML content, it should be served from a separate dedicated domain. Using a different domain ensures that scripts in the files are unable to attack the site, even if the user is tricked into visiting those pages directly, without the protection of the sandbox attribute.
</p>

<div class="algo">
<p>
［
`iframe$e 要素 %iframe が`入子にしている閲覧文脈$ ~NEQ ~NULL
］の下では、~UAは，次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
%iframe の`sandbox$aF 属性が［
設定-／変更-
］されたときは
⇒
`~sandbox法~指令を構文解析する$( %iframe の `sandbox$aF 属性の値, %iframe の`~iframe~sandbox法~flag集合$ )
◎
When an iframe element's sandbox attribute is set or changed while it has a non-null nested browsing context, the user agent must parse the sandboxing directive given the attribute's value and the iframe element's iframe sandboxing flag set.
</li>
	<li>
%iframe の `sandbox$aF 属性が除去されたときは
⇒
%iframe の`~iframe~sandbox法~flag集合$を空にする
◎
When an iframe element's sandbox attribute is removed while it has a non-null nested browsing context, the user agent must empty the iframe element's iframe sandboxing flag set.
</li>
</ul>
</div>

<div class="example">
<p>
この例では、~page内には，利用者が供した ある［
完全に未知で，敵対的にもなり得る~HTML内容
］が埋込まれている。
それは，ある別々の~domainから~serveされているので、非同一-~siteに対する通常の制約~すべてから影響される。
加えて，埋込まれた~pageでは、［
~scripting, ~plugin, ~form
］は不能化され，自身以外のどの［
~frame／~window
］も（自身が埋込んだものも含め）~navigateできない。
◎
In this example, some completely-unknown, potentially hostile, user-provided HTML content is embedded in a page. Because it is served from a separate domain, it is affected by all the normal cross-site restrictions. In addition, the embedded page has scripting disabled, plugins disabled, forms disabled, and it cannot navigate any frames or windows other than itself (or any frames or windows it itself embeds).
</p>

`iframe-2^xCode

<p class="warning">
別々の~domainを利用することは、攻撃者が利用者を［
その~pageに直に訪問させ、~page内に見出されるどの攻撃からも脆弱にする
］よう仕向けても，［
~pageは~siteの生成元の文脈の下で走ることはない
］ようにするために重要になる。
◎
It is important to use a separate domain so that if the attacker convinces the user to visit that page directly, the page doesn't run in the context of the site's origin, which would make the user vulnerable to any attack found in the page.
</p>

</div>

<div class="example">

<p>
次の例では、別の~siteからの ある~gadgetが埋込まれている。
この~gadgetでは、~scriptingと~formが可能化されていて、~gadgetが，出自の~serverと通信できるよう，生成元~sandbox制約は~~軽くされている。
しかしながら，~sandboxは、［
~pluginと~popup
］を不能化して，利用者が［
~malwareその他の いまいましいもの
］に晒されるのを抑制するので、依然として有用になる。
◎
In this example, a gadget from another site is embedded. The gadget has scripting and forms enabled, and the origin sandbox restrictions are lifted, allowing the gadget to communicate with its originating server. The sandbox is still useful, however, as it disables plugins and popups, thus reducing the risk of the user being exposed to malware and other annoyances.
</p>

<pre class="lang-html">
&lt;iframe sandbox="allow-same-origin allow-forms allow-scripts"
        src="https://maps.example.com/embedded.html"&gt;&lt;/iframe&gt;
</pre>

</div>

<div class="example">

<p>
~file %A は、次の~iframeを包含しているとする：
◎
Suppose a file A contained the following fragment:
</p>

<pre class="lang-html">
&lt;iframe sandbox="allow-same-origin allow-forms" src=%B &gt;&lt;/iframe&gt;
</pre>

<p>
~file %B も~iframeも包含していたとする：
◎
Suppose that file B contained an iframe also:
</p>

<pre class="lang-html">
&lt;iframe sandbox="allow-scripts" src=%C &gt;&lt;/iframe&gt;
</pre>

<p>
更に、~file %C は~page %D への~linkを包含していたとする：
◎
Further, suppose that file C contained a link:
</p>

<pre class="lang-html">
&lt;a href=%D &gt;Link&lt;/a&gt;
</pre>

<p>
この例に対しては、どの~fileも `text/html$mt として~serveされているとする。
◎
For this example, suppose all the files were served as text/html.
</p>

<p>
この局面における~page %C に対しては、すべての~sandbox法~flagが設定される。
%A 内の `iframe$e では~scriptは不能化されるので、 %C においては［
%B 内の `iframe$e 内に設定された `allow-scripts$v ~keyword
］は上書きされ， ~scriptは不能化される。
また、~formも不能化される
— （ %B 内の）内縁 `iframe$e 内には `allow-forms$v ~keywordは設定されてないので。
◎
Page C in this scenario has all the sandboxing flags set. Scripts are disabled, because the iframe in A has scripts disabled, and this overrides the allow-scripts keyword set on the iframe in B. Forms are also disabled, because the inner iframe (in B) does not have the allow-forms keyword set.
</p>

<p>
今ここで、 %A 内の~scriptが %A, %B 内のすべての `sandbox$aF 属性を除去したとする。
これは、即時には何も変更しない。
利用者が %C 内の~linkを~clickして，
%B 内の `iframe$e の中に~page %D を読込んだ場合、~page %D は今や，［
%B 内の `iframe$e に［
`allow-same-origin$v, `allow-forms$v
］~keywordが設定されていた
］かのように動作する
— それが、［
~page%B が読込まれた時点で， %A 内の `iframe$e が`入子にしている閲覧文脈$の状態
］であったので。
◎
Suppose now that a script in A removes all the sandbox attributes in A and B. This would change nothing immediately. If the user clicked the link in C, loading page D into the iframe in B, page D would now act as if the iframe in B had the allow-same-origin and allow-forms keywords set, because that was the state of the nested browsing context in the iframe in A when page B was loaded.
</p>

<p>
一般に， `sandbox$aF 属性は、動的に除去したり変更しないことを勧める
— そうすると、許容されるもの, されないものを選り分けるのが，難しくなり得るので。
◎
Generally speaking, dynamically removing or changing the sandbox attribute is ill-advised, because it can make it quite hard to reason about what will be allowed and what will not.
</p>

</div>

<hr>

<p>
`allow@aF
属性は、指定されたときは，`容器~施策$を決定する
— それは、［
`iframe$e が`入子にしている閲覧文脈$に属する`文書$用の`許可~施策$doc
］が初期化されるときに，利用されることになる。
値は`直列形の許可~施策$でなければナラナイ。
`PERMISSIONSPOLICY$r
◎
The allow attribute, when specified, determines the container policy that will be used when the permissions policy for a Document in the iframe's nested browsing context is initialized. Its value must be a serialized permissions policy. [PERMISSIONSPOLICY]
</p>

<div class="example">
<p>
次の例では、~online~navi~serviceからの地図を埋込むために， `iframe$e が利用される。
`allow$aF 属性は、入子な文脈の中で Geolocation ~APIを可能化するために利用される。
◎
In this example, an iframe is used to embed a map from an online navigation service. The allow attribute is used to enable the Geolocation API within the nested context.
</p>

<pre class="lang-html">
&lt;iframe src="https://maps.example.com/" allow="geolocation"&gt;&lt;/iframe&gt;
</pre>

</div>

<p>
`allowfullscreen@aF
属性は，`真偽-属性$であり、指定されたときは，［
`iframe$e 要素が`入子にしている閲覧文脈$に属する`文書$は、［
どの`生成元$からでも， `fullscreen^l 特能の利用を許容する
］よう，`許可~施策$docで初期化されることになる
］ことを指示する。
これは、`許可~施策~属性を処理する$ ~algoにより施行される。
`PERMISSIONSPOLICY$r
◎
The allowfullscreen attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's nested browsing context will be initialized with a permissions policy which allows the "fullscreen" feature to be used from any origin. This is enforced by the process permissions policy attributes algorithm. [PERMISSIONSPOLICY]
</p>

<div class="example">

<p>
ここでの `iframe$e は、動画~siteからの再生器を埋込むために利用されている。
この再生器が動画を全~screen化するのを可能化するためには、
`allowfullscreen$aF 属性が必要になる。
◎
Here, an iframe is used to embed a player from a video site. The allowfullscreen attribute is needed to enable the player to show its video fullscreen.
</p>

`iframe-3^xCode

</div>

<p class="note">注記：
［
`allow$aF ／
`allowfullscreen$aF
］属性は、［
当の `iframe$e 要素の`~node文書$には、当の特能の利用は，すでに許容されていない
］場合には，［
要素が`入子にしている閲覧文脈$における特能への~access
］を是認することはない。
◎
Neither allow nor allowfullscreen can grant access to a feature in an iframe element's nested browsing context if the element's node document is not already allowed to use that feature.
</p>

<div class="algo">
<p id="fullscreen-logic">
`文書$ %文書 には，`施策により制御される特能$ %特能 の
`利用は許容されて@
いるかどうか決定するときは、次を走らす：
◎
To determine whether a Document object document is allowed to use the policy-controlled-feature feature, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 が`属する閲覧文脈$ ~EQ ~NULL
］
⇒
~RET ~F
◎
If document's browsing context is null, then return false.
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$にて`作動中の文書$ ~NEQ %文書
］
⇒
~RET ~F
◎
If document's browsing context's active document is not document, then return false.
</li>
	<li>
~IF［
`文書~内の特能は生成元~用に可能化されるか$( %特能, %文書, %文書 の`生成元$doc ) ~EQ `可能化される^i
］
⇒
~RET ~T
◎
If the result of running is feature enabled in document for origin on feature, document, and document's origin is "Enabled", then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>
</div>

<p class="warning">
［
`allow$aF ／
`allowfullscreen$aF
］属性が波及するのは，当の `iframe$e 要素が`入子にしている閲覧文脈$にて`作動中の文書$の`許可~施策$docに限られるので、これらの属性が効果を~~発揮するのは，その閲覧文脈が`~navigate$されるときに限られる。
属性を追加しようが除去しようが，すでに読込まれた文書に対する効果は無い。
◎
Because they only influence the permissions policy of the nested browsing context's active document, the allow and allowfullscreen attributes only take effect when the nested browsing context of the iframe is navigated. Adding or removing them has no effect on an already-loaded document.
</p>

<hr>

<p>
`iframe$e 要素は、埋込d内容に特有な寸法がある場合は，`寸法~属性$を~supportする（例： ~~定義済み寸法がある広告unitなど）。
◎
The iframe element supports dimension attributes for cases where the embedded content has specific dimensions (e.g. ad units have well-defined dimensions).
</p>

<p>
`iframe$e 要素には、`~fallback内容$は決してない
— 指定された初期~内容が成功裡に利用されようがされまいが、それは常に，`新たな入子な閲覧文脈を作成する$ことになるので。
◎
An iframe element never has fallback content, as it will always create a new nested browsing context, regardless of whether the specified initial contents are successfully used.
</p>

<hr>

<p>
`referrerpolicy@aF
属性は、`~referrer施策~属性$である。
その目的は、`~iframeの属性を処理する$ときに利用される`~referrer施策$を設定することである。
`REFERRERPOLICY$r
◎
The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when processing the iframe attributes. [REFERRERPOLICY]
</p>

<p>
`loading@aF
属性は、`~lazy読込ng属性$である。
その目的は、表示域の外側にある `iframe$e 要素を読込むときの施策を指示することにある。
◎
The loading attribute is a lazy loading attribute. Its purpose is to indicate the policy for loading iframe elements that are outside the viewport.
</p>

<div class="algo">
<p>
`iframe$e 要素の %iframe の `loading$aF 属性の状態が `Eager$st に変化したときは、~UAは，次の手続きを走らすモノトスル：
◎
When the loading attribute's state is changed to the Eager state, the user agent must run these steps:
</p>
<ol>
	<li>
%再開~手続き ~LET %iframe の`~lazy読込n再開~手続き$
◎
Let resumptionSteps be the iframe element's lazy load resumption steps.
</li>
	<li>
~IF［
%再開~手続き ~EQ ~NULL
］
⇒
~RET
◎
If resumptionSteps is null, then return.
</li>
	<li>
%iframe の`~lazy読込n再開~手続き$ ~SET ~NULL
◎
Set the iframe's lazy load resumption steps to null.
</li>
	<li>
%再開~手続き を呼出す
◎
Invoke resumptionSteps.
</li>
</ol>
</div>

<hr>

<p>
`iframe$e 要素の子孫は、何も表現しない（ `iframe$e 要素を~supportしない旧来の~UAにおいては、その内容は ~markupとして構文解析され，~fallback内容として動作し得る。）
◎
Descendants of iframe elements represent nothing. (In legacy user agents that do not support iframe elements, the contents would be parsed as markup that could act as fallback content.)
</p>

<p class="note">注記：
`~HTML構文解析器$は、 `iframe$e 要素の内側にある~markupを~textとして扱う。
◎
The HTML parser treats markup inside iframe elements as text.
</p>

<hr>

<div>
<p>
`src@mF
~IDL属性は、
`src$aF 内容~属性を`反映する$モノトスル。
</p>

<p>
`srcdoc@mF
~IDL属性は、
`srcdoc$aF 内容~属性を`反映する$モノトスル。
</p>

<p>
`name@mF
~IDL属性は、
`name$aF 内容~属性を`反映する$モノトスル。
</p>

<p>
`sandbox@mF
~IDL属性は、
`sandbox$aF 内容~属性を`反映する$モノトスル。
</p>

<p>
`sandbox$mF 属性が `DOMTokenList$I 用に`~supportする~token集合$は、［
`sandbox$aF 内容~属性に定義された許容される値のうち，~UAが~supportするもの
］からなるとする。
</p>

<p>
`allow@mF
~IDL属性は、
`allow$aF 内容~属性を`反映する$モノトスル。
</p>

◎
The IDL attributes src, srcdoc, name, sandbox, and allow must reflect the respective content attributes of the same name.
◎
The supported tokens for sandbox's DOMTokenList are the allowed values defined in the sandbox attribute and supported by the user agent.
</div>

<p>
`allowFullscreen@mF
~IDL属性は、
`allowfullscreen$aF 内容~属性を`反映する$モノトスル。
◎
The allowFullscreen IDL attribute must reflect the allowfullscreen content attribute.
</p>

<p>
`referrerPolicy@mF
~IDL属性は、
`既知な値のみに制限され$る下で，
`referrerpolicy$aF 内容~属性を`反映する$モノトスル。
◎
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</p>

<p>
`loading@mF
~IDL属性は、
`既知な値のみに制限され$る下で，
`loading$aF 内容~属性を`反映する$モノトスル。
◎
The loading IDL attribute must reflect the loading content attribute, limited to only known values.
</p>

<div class="algo">
`contentDocument@mF
取得子~手続きは
⇒
~RET コレの`内容~文書$
◎
The contentDocument IDL attribute, on getting, must return the iframe element's content document.
</div>

<div class="algo">
`contentWindow@mF
取得子~手続きは
⇒
~RET コレが`入子にしている閲覧文脈$ %B に応じて
⇒＃
~NULL ならば ~NULL ／
~ELSE_ %B の `WindowProxy$I ~obj
◎
The contentWindow IDL attribute must return the WindowProxy object of the iframe element's nested browsing context, if its nested browsing context is non-null, or null otherwise.
</div>

<div class="example">
<p>
`iframe$e を用いて
広告~代行業者からの広告を含ませる例：
◎
Here is an example of a page using an iframe to include advertising from an advertising broker:
</p>

`iframe-4^xCode

</div>

			</section>
			<section id="the-embed-element">
<h4 title="The embed element">4.8.6. `embed^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$ ／ `埋込d内容$ ／`対話的~内容$ ／ `可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aE
— 埋込む資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`type$aE
— 埋込む資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
どの名前空間にも属さない任意の属性（注釈文を見よ）。
◎
Any other attribute that has no namespace (see prose).
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`embed$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLEmbedElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute USVString `src$mE;
  [`CEReactions$] attribute DOMString `type$mE;
  [`CEReactions$] attribute DOMString `width$m;
  [`CEReactions$] attribute DOMString `height$m;
  `Document$I? `getSVGDocument$m();

  // `HTMLEmbedElement$obsMb
};
</pre>

<p>
`embed$e 要素により~instance化される内容の型に依存して、~nodeは，他の~interfaceを~supportしてもヨイ。
◎
Depending on the type of content instantiated by the embed element, the node may also support other interfaces.
</p>
	</dd>
</dl>

<p>
`embed$e 要素は、外部（概して~HTMLでない）
~appや対話的~内容~用に統合~~地点を供する。
◎
The embed element provides an integration point for an external (typically non-HTML) application or interactive content.
</p>

<p>
`src@aE
属性は、埋込まれる資源の`~URL$を与える。
この属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$でなければナラナイ。
◎
The src attribute gives the URL of the resource being embedded. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p class="warning">
作者は、信用しない資源を参照するのを避けるベキである。
そのような資源は、~pluginを~instance化したり，~scriptを走らすために利用され得るので
— 作者が［
~Flashの "allowScriptAccess" ~parameter
］に類する特能を利用していたとしても。
◎
Authors should avoid referencing untrusted resources, as such a resource can be used to instantiate plugins or run scripts, even if the author has used features such as the Flash "allowScriptAccess" parameter.
</p>

<p>
`embed$e 要素が `itemprop$a を有する場合、
`src$aE 属性も有していなければナラナイ。
◎
If the itemprop attribute is specified on an embed element, then the src attribute must also be specified.
</p>

<p>
`type@aE
属性は、在るならば`~MIME型$を与え、~instance化される~pluginは，それにより選定される。
指定する値は、`妥当な~MIME型~文字列$でなければナラナイ。
要素が `type$aE, `src$aE 両 属性とも有する場合、
`type$aE 属性には，［
`src$aE 属性に与えられた資源
］の［
明示的な`~Content-Type~metadata$
］と同じ型を指定しなければナラナイ。
◎
The type attribute, if present, gives the MIME type by which the plugin to instantiate is selected. The value must be a valid MIME type string. If both the type attribute and the src attribute are present, then the type attribute must specify the same type as the explicit Content-Type metadata of the resource given by the src attribute.
</p>

<p>
`embed$e 要素が次のいずれかの条件を満たしている間は、要素~用に~instance化された`~plugin$は，除去するモノトスル
— 要素は何も`表現-$しなくなる：
◎
While any of the following conditions are occurring, any plugin instantiated for the element must be removed, and the embed element represents nothing:
</p>

<ul>
	<li>
要素は `src$aE, `type$aE 両~属性とも有さない
◎
The element has neither a src attribute nor a type attribute.
</li>
	<li>
要素の先祖に`~media要素$が在る
◎
The element has a media element ancestor.
</li>
	<li>
要素の先祖に［
`~fallback内容$を<em>示していない</em> `object$e 要素
］が在る
◎
The element has an ancestor object element that is not showing its fallback content.
</li>
</ul>

<p>
`embed$e 要素は、次の条件すべてを同時に満たすとき
`作動中になれ@
るとされる（その否定は、単に “作動中になれない” ）：
◎
An embed element is said to be potentially active when the following conditions are all met simultaneously:
</p>

<ul>
	<li>
［
`文書~内に$ある
］~OR［
`~event~loop$が最後に その`最初の段$に達した時点で，`文書~内に$あった
］
◎
The element is in a document or was in a document the last time the event loop reached step 1.
</li>
	<li>
その`~node文書$は`全部的に作動中$である
◎
The element's node document is fully active.
</li>
	<li>
［
`src$aE 属性を有する
］~OR［
`type$aE 属性を有する
］
◎
The element has either a src attribute set or a type attribute set (or both).
</li>
	<li>
［
`src$aE 属性は有さない
］~OR［
`src$aE 属性を有していて，その値 ~NEQ 空~文字列
］
◎
The element's src attribute is either absent or its value is not the empty string.
</li>
	<li>
`~media要素$の子孫ではない
◎
The element is not a descendant of a media element.
</li>
	<li>
［
`~fallback内容$を示していない `object$e 要素
］の子孫ではない
◎
The element is not a descendant of an object element that is not showing its fallback content.
</li>
	<li>
［
`具現化されて$いる
］~OR［
`~event~loop$が最後に その`最初の段$に達した時点で，`具現化されて$いた
］
◎
The element is being rendered, or was being rendered the last time the event loop reached step 1.
</li>
</ul>

<div class="algo">
<p>
`embed$e 要素 %embed において，次のいずれかが生じたときは…：
</p>

<ul ><li>`作動中になれ$ない~~状態から`作動中になれ$るようになったとき
</li><li>`作動中になれ$るまま，その［
`src$aE 属性, または `type$aE 属性
］が［
設定- ／ 変更- ／ 除去-
］されたとき
</li></ul>

<p>
…~UAは、次を行うモノトスル
⇒
次を走らす`要素~taskを~queueする$(
`~embed~task源@,
%embed )
⇒
`~embed要素を設定しておく$( %embed )
</p>

◎
Whenever an embed element that was not potentially active becomes potentially active, and whenever a potentially active embed element that is remaining potentially active and has its src attribute set, changed, or removed or its type attribute set, changed, or removed, the user agent must queue an element task on the embed task source given the element to run the embed element setup steps for that element.
</div>

<div class="algo">
<p>
`~embed要素を設定しておく@
手続きは、所与の
( `embed$e 要素 %embed )
に対し，次を走らす：
◎
The embed element setup steps for a given embed element element are as follows:
</p>

<ol>
	<li>
%現~task ~LET %embed に対し この手続きを走らせている`~task$
◎
↓</li>
	<li>
~IF［
%現~task より後に~queueされた，［
%embed に対し この手続きを走らす，別の`~task$
］が在る
］
⇒
~RET
◎
If another task has since been queued to run the embed element setup steps for element, then return.
</li>
	<li>
<p>
~IF［
%embed は `src$aE 属性を有する
］：
◎
If element has a src attribute set, then:
</p>
		<ol>
			<li>
%~URL ~LET `相対的に~URL構文解析する$( %embed の `src$aE 属性の値, %embed の`~node文書$ )
◎
Let url be the result of parsing the value of element's src attribute, relative to element's node document.
</li>
			<li>
~IF［
%~URL ~EQ `失敗^i
］
⇒
~RET
◎
If url is failure, then return.
</li>
			<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET %embed の`~node文書$に`関連な設定群~obj$,
`行先$rq ~SET `embed^l,
`資格証~mode$rq ~SET `include^l,
`~mode$rq ~SET `navigate^l,
`~URL資格証を利用するか$rq ~SET ~T
◎
Let request be a new request whose URL is url, client is element's node document's relevant settings object, destination is "embed", credentials mode is "include", mode is "navigate", and whose use-URL-credentials flag is set.
</li>
			<li>
<p>
%要請 を`~fetch$する
— 加えて：
◎
Fetch request.
</p>

<p>
資源の~fetchingは、 %embed の`~node文書$の`~load~eventを遅延する$モノトスル。
◎
Fetching the resource must delay the load event of element's node document.
</p>

<p>
`応答を処理する$ときは、所与の
( `応答$ %応答 )
に対し：
◎
To process response for the response response:
</p>
				<ol>
					<li>
~IF［
%現~task より後に~queueされた，［
%embed に対し この手続きを走らす，別の`~task$
］が在る
］
⇒
~RET
◎
If another task has since been queued to run the embed element setup steps for element, then return.
</li>
					<li>
~IF［
%応答 は`~network~error$である
］
⇒＃
`~eventを発火する$( %embed, `load$et )；
~RET
◎
If response is a network error, then fire an event named load at element, and return.
</li>
					<li>
%型 ~LET `内容の型を決定する$( %embed, %応答 )
◎
Let type be the result of determining the type of content given element and response.
</li>
					<li>
<p>
%型 に応じて：
◎
Switch on type:
</p>
						<dl class="switch">
							<dt>~NULL</dt>
							<dd>
%embed 用の`~pluginなしを表示する$
◎
Display no plugin for element.
</dd>
							<dt>`image/svg+xml$mt</dt>
							<dd>
								<ol>
									<li>
%B ~LET %embed が`入子にしている閲覧文脈$
◎
↓</li>
									<li>
~IF［
%B ~EQ ~NULL
］
⇒
%B ~SET `新たな入子な閲覧文脈を作成する$( %embed )
◎
If element's nested browsing context is null, then create a new nested browsing context for element.
</li>
									<li>
<p>
%B を %応答 へ`~navigate$する
— 次を与える下で
⇒＃
`履歴~取扱い$V ~SET `置換-$i,
`~source閲覧文脈$ ~SET %embed の`~node文書$が`属する閲覧文脈$
◎
Navigate element's nested browsing context to response, with historyHandling set to "replace" and the source browsing context set to element's node document's browsing context.
</p>

<p class="note">注記：
%embed の `src$aE 属性は、 %B が更に他の所在に~navigateされても更新されない。
◎
element's src attribute does not get updated if the browsing context gets further navigated to other locations.
</p>
									</li>
									<li>
この時点で、 %embed は %B を`表現-$する
◎
element now represents its nested browsing context.
</li>
								</ol>
							</dd>
							<dt>その他</dt>
							<dd>
%embed 用の`~pluginを表示する$( %型, %応答 )
◎
Display a plugin for element, given type and response.
</dd>
						</dl>
					</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%型 ~LET %embed の `type$aE 属性の値
◎
Let type be the value of element's type attribute.
</li>
			<li>
~IF［
%型 は ある`~plugin$が~supportする型である
］
⇒
%embed 用の`~pluginを表示する$( %型 )
◎
If type is a type that a plugin supports, then display a plugin for element given type.
</li>
			<li>
~ELSE
⇒
%embed 用の`~pluginなしを表示する$
◎
Otherwise, display no plugin for element.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`内容の型を決定する@
ときは、所与の
( `embed$e 要素 %embed, `応答$ %応答 )
に対し，次の手続きを走らす：
◎
To determine the type of the content given an embed element element and a response response, run the following steps:
</p>

<ol>
	<li>
~IF［
%embed は `type$aE 属性を有していて，その値は ある`~plugin$が~supportする型である
］
⇒
~RET その値
◎
If element has a type attribute, and that attribute's value is a type that a plugin supports, then return the value of the type attribute.
</li>
	<li>
<p>
~IF［
%応答 の`~URL$rsの`~path$url成分は ある`~plugin$が~supportする~patternに合致する
］
⇒
~RET その~pluginが取扱える型
◎
If the path component of response's url matches a pattern that a plugin supports, then return the type that that plugin can handle.
</p>

<p class="example">
例えば，ある~pluginは、［
`~path$url成分が文字列 `.swf^l で終端する
］ような~URLを取扱えるとしていることもある。
◎
For example, a plugin might say that it can handle URLs with path components that end with the four character string ".swf".
</p>

<p class="trans-note">【
~patternに合致する複数の~pluginがある場合に［
どの~pluginが選定されるか ／
当の~pluginが複数の型を取扱える場合に，どの型が選定されるか
］については、ここには述べられていない
— 実装定義な（何らかの環境設定に基づく）仕組みで選定されるものと見做されているようだ。
他所にも~pluginを選定する記述があるが、同様と見受けられる。
】</p>

</li>
	<li>
~IF［
%応答 には明示的な`~Content-Type~metadata$があって，その値は ある`~plugin$が~supportする型である
］
⇒
~RET その値
◎
If response has explicit Content-Type metadata, and that value is a type that a plugin supports, then return that value.
</li>
	<li>
~RET ~NULL
◎
Return null.
</li>
</ol>

<p class="note">注記：
上の~algoが`~ok状態s$でない応答を許容するのは、意図的である。
これにより，~serverは、~error応答においても~plugin用の~dataを返せるようになる（例：
~HTTP状態s~code 500 ( Internal Server Error ) であっても、~plugin~dataを包含できる）。
◎
It is intentional that the above algorithm allows response to have a non-ok status. This allows servers to return data for plugins even with error responses (e.g., HTTP 500 Internal Server Error codes can still contain plugin data).
</p>
</div>

<div class="algo">
<p>
`embed$e 要素 %embed 用の
`~pluginを表示する@
ときは、所与の
( 文字列 %型, `応答$ %応答 （省略時は ε） )
に対し：
◎
To display a plugin for an embed element element, given a string type and optionally a response response:
</p>

<ol>
	<li>
`入子な閲覧文脈を破棄する$( %embed )
◎
If element's nested browsing context is not null, then:
• Discard element's nested browsing context.
• Set element's nested browsing context to null.
</li>
	<li>
%~plugin ~LET %型 に基づいて適切な`~plugin$を見出して，それを~instance化した結果
— 加えて
⇒
%embed 用に以前に~instance化されていた~pluginがあれば それを置換する ／
%応答 を（ ~NEQ ε ならば） %~plugin に回送する。
◎
Find and instantiate an appropriate plugin based on type, replacing any previously-instantiated plugin for element. If response was given, forward it to the plugin.
</li>
	<li>
この時点で、 %embed は %~plugin を`表現-$する
◎
element now represents this plugin instance.
</li>
	<li>
［
%~plugin, %応答 （ ~NEQ ε ）
］が完全に読込まれた時点で，次を行うようにしておく
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %embed )
⇒
`~eventを発火する$( %embed, `load$et )
◎
Once the plugin, and response if given, are completely loaded, queue an element task on the DOM manipulation task source give element to fire an event named load at element.
</li>
</ol>
</div>

<div class="algo">
<p>
`embed$e 要素 %embed 用の
`~pluginなしを表示する@
ときは：
◎
To display no plugin for an embed element element:
</p>

<ol>
	<li>
`入子な閲覧文脈を破棄する$( %embed )
◎
If element's nested browsing context is not null, then:
• Discard element's nested browsing context.
• Set element's nested browsing context to null.
</li>
	<li>
`~plugin$は見出せなかった指示を表示する
— %embed 用に以前に~instance化されていた~pluginがあれば それを置換する
◎
Display an indication that no plugin could be found for element, replacing any previously-instantiated plugin for element.
</li>
	<li>
この時点で、 %embed は何も`表現-$しない
◎
element now represents nothing.
</li>
</ol>
</div>

<p class="note">注記：
`embed$e 要素には、`~fallback内容$は無い
— その子孫は無視される。
◎
The embed element has no fallback content; its descendants are ignored.
</p>

<p>
`作動中になれ$る `embed$e 要素が，`作動中になれ$なくなったときは、要素~用に~instance化されていた`~plugin$は，未読込みにするモノトスル。
◎
Whenever an embed element that was potentially active stops being potentially active, any plugin that had been instantiated for that element must be unloaded.
</p>

<p id="sandboxPluginEmbed">
~UAは，
`embed$e 要素 %embed が［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN %embed の`~node文書$にて`作動中の~sandbox法~flag集合$
］を満たす下では、
%embed にて ある`~plugin$が~instance化されようとしても，
~instance化しないモノトスル
— 代わりに［
~pluginが不能化されたことを伝えるように %embed を具現化する
］モノトスル。
◎
When a plugin is to be instantiated but the sandboxed plugins browsing context flag is set on the embed element's node document's active sandboxing flag set, then the user agent must not instantiate the plugin, and must instead render the embed element in a manner that conveys that the plugin was disabled.
</p>

<p>
`embed$e 要素は、`~load~eventを遅延し得る$とする。
◎
The embed element potentially delays the load event.
</p>

<div>
<p>
`embed$e 要素には、名前が次をすべて満たすような任意の属性を指定してもヨイ：
</p>
<ul>
	<li>
どの名前空間にも属さない
</li>
	<li>
`name$a, `align$a, `hspace$a, `vspace$a のいずれでもでない
</li>
	<li>
`~XML互換$である
</li>
	<li>
`~ASCII英大文字$を包含しない
</li>
</ul>
◎
Any namespace-less attribute other than name, align, hspace, and vspace may be specified on the embed element, so long as its name is XML-compatible and contains no ASCII upper alphas.＼
</div>

<p>
そのような属性は、`~plugin$への~parameterとして渡されることになる。
◎
These attributes are then passed as parameters to the plugin.
</p>

<p class="note">注記：
`~HTML文書$におけるすべての属性は，自動的に小文字~化されるので、大文字に対する制約は，そのような文書には影響しない。
◎
All attributes in HTML documents get lowercased automatically, so the restriction on uppercase letters doesn't affect such documents.
</p>

<p class="note">注記：
上に挙げた 4 個の名前は，旧来の属性であり、単に~parameterを`~plugin$に送ることを超えるような副作用を伴うので，除外されている。
◎
The four exceptions are to exclude legacy attributes that have side-effects beyond just sending parameters to the plugin.
</p>

<p>
~UAは、［
`embed$e 要素の属性のうち，どの名前空間にも属さないもの
］すべての名前と値を，利用される`~plugin$が~instance化されるときに渡すべきである。
◎
The user agent should pass the names and values of all the attributes of the embed element that have no namespace to the plugin used, when one is instantiated.
</p>

<p>
`embed$e 要素を表現している `HTMLEmbedElement$I ~objは、要素~用に~instance化された`~plugin$に~script可能な~interfaceがあれば それを公開するモノトスル。
◎
The HTMLEmbedElement object representing the element must expose the scriptable interface of the plugin instantiated for the embed element, if any.
</p>

<p>
`embed$e 要素は、`寸法~属性$を~supportする。
◎
The embed element supports dimension attributes.
</p>

<div>
<p>
`src@mE
~IDL属性は、
`src$aE 内容~属性を`反映する$モノトスル。
</p>

<p>
`type@mE
~IDL属性は、
`type$aE 内容~属性を`反映する$モノトスル。
</p>
◎
The IDL attributes src and type each must reflect the respective content attributes of the same name.
</div>

<div class="example">
<p>
~Flashの様な，~proprietaryな~pluginを要する資源を埋込む例：
◎
Here's a way to embed a resource that requires a proprietary plugin, like Flash:
</p>

`embed-1^xCode

<p>
~pluginを備えていない利用者は、この資源を利用できないことになる（例えば，その~plugin~vendorは、利用者の~platformを~supportしていないなど）。
◎
If the user does not have the plugin (for example if the plugin vendor doesn't support the user's platform), then the user will be unable to use the resource.
</p>

<p>
属性を指定すれば、この~pluginに~parameter［
名前 `quality^l, 値 `high^l
］を渡せる：
◎
To pass the plugin a parameter "quality" with the value "high", an attribute can be specified:
</p>

`embed-2^xCode

<p>
これは、代わりに `object$e 要素を用いたときには，次と等価になる：
◎
This would be equivalent to the following, when using an object element instead:
</p>

`embed-3^xCode

</div>

			</section>
			<section id="the-object-element">
<h4 title="The object element">4.8.7. `object^e 要素</h4>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句ng内容$ ／ `埋込d内容$ ／ `可触~内容$ ／
`~listされる要素$ ／ `~formに所有され得る要素$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Listed form-associated element.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込d内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の順による並び：
</p>

<ol ><li>0 個~以上の `param$e 要素
</li><li>`透過的な内容$
</li></ol>
◎
Zero or more param elements, then, transparent.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`data$aO
— 埋込む資源の~address
◎
data — Address of the resource
</dd>
	<dd>
`type$aO
— 埋込む資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`name$aO
— `入子な閲覧文脈$の名前
◎
name — Name of nested browsing context
</dd>
	<dd>
`form$a
— この要素の所有者にする `form$e 要素
◎
form — Associates the element with a form element
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`object$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window]
interface `HTMLObjectElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute USVString `data$mO;
  [`CEReactions$] attribute DOMString `type$mO;
  [`CEReactions$] attribute DOMString `name$mO;
  readonly attribute `HTMLFormElement$I? `form$m;
  [`CEReactions$] attribute DOMString `width$m;
  [`CEReactions$] attribute DOMString `height$m;
  readonly attribute `Document$I? `contentDocument$mO;
  readonly attribute `WindowProxy$I? `contentWindow$mO;
  `Document$I? `getSVGDocument$m();

  readonly attribute boolean `willValidate$m;
  readonly attribute `ValidityState$I `validity$m;
  readonly attribute DOMString `validationMessage$m;
  boolean `checkValidity$m();
  boolean `reportValidity$m();
  undefined `setCustomValidity$m(DOMString %error);

  // `HTMLObjectElement$obsMb
};
</pre>

<p>
`object$e 要素により~instance化される内容の型に依存して、~nodeは，他の~interfaceも~supportする。
◎
Depending on the type of content instantiated by the object element, the node also supports other interfaces.
</p>
	</dd>
</dl>

<p>
`object$e 要素は、外部~資源を表現できる
— それは、資源の型に依存して，［
画像, `子~閲覧文脈$, `~plugin$により処理される外部~資源
］のいずれかとして扱われることになる。
◎
The object element can represent an external resource, which, depending on the type of the resource, will either be treated as an image, as a child browsing context, or as an external resource to be processed by a plugin.
</p>

<p>
`data@aO
属性は、在るならば，資源の`~URL$を指定する。
この属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$でなければナラナイ。
◎
The data attribute, if present, specifies the URL of the resource. If present, the attribute must be a valid non-empty URL potentially surrounded by spaces.
</p>

<p class="warning">
作者は、信用しない資源を参照するのを避けるベキである。
そのような資源は、~pluginを~instance化したり，~scriptを走らすために利用され得るので
— 作者が［
~Flashの "allowScriptAccess" ~parameter
］に類する特能を利用していたとしても。
◎
Authors should avoid referencing untrusted resources, as such a resource can be used to instantiate plugins or run scripts, even if the author has used features such as the Flash "allowScriptAccess" parameter.
</p>

<p>
`type@aO
属性は、在るならば，資源の型を指定する。
この属性に指定する値は、`妥当な~MIME型~文字列$でなければナラナイ。
◎
The type attribute, if present, specifies the type of the resource. If present, the attribute must be a valid MIME type string.
</p>

<p>
`object$e 要素は、
`data$aO, `type$aO
属性のうち，どちらかは有していなければナラナイ。
◎
At least one of either the data attribute or the type attribute must be present.
</p>

<p>
`object$e 要素が `itemprop$a 属性を有する場合、
`data$aO 属性も有していなければナラナイ。
◎
If the itemprop attribute is specified on an object element, then the data attribute must also be specified.
</p>

<p>
`name@aO
属性に指定する値は、`妥当な閲覧文脈~名$でなければナラナイ。
その値は、当の `object$e 要素が`入子にしている閲覧文脈$に名前を与えるために利用される
— 適用-可能かつ，その閲覧文脈が作成される時点で この属性が在るならば。
◎
The name attribute, if present, must be a valid browsing context name. The given value is used to name the element's nested browsing context, if applicable, and if present when the element's nested browsing context is created.
</p>

<div class="algo">
<p>
`object$e 要素 %object において，次のいずれかが生じたときは…：
◎
Whenever one of the following conditions occur:
</p>
<ul>
	<li>
作成されたとき
◎
the element is created,
</li>
	<li>
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$から~popされ除かれたとき
◎
the element is popped off the stack of open elements of an HTML parser or XML parser,
</li>
	<li>
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$内に無い下で
⇒
［
`文書の中へ挿入され$た／`文書から除去され$た
］とき
◎
the element is not on the stack of open elements of an HTML parser or XML parser, and it is either inserted into a document or removed from a document,
</li>
	<li>
その`~node文書$が`全部的に作動中$かどうかが変化したとき
◎
the element's node document changes whether it is fully active,
</li>
	<li>
そのある先祖の `object$e 要素において［
`~fallback内容$を示しているかどうか
］が変化したとき
◎
one of the element's ancestor object elements changes to or from showing its fallback content,
</li>
	<li>
その `classid$a 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
the element's classid attribute is set, changed, or removed,
</li>
	<li>
`classid$a 属性を有していない下で
⇒
その `data$aO 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
the element's classid attribute is not present, and its data attribute is set, changed, or removed,
</li>
	<li>
［
`classid$a, `data$aO
］両~属性とも有していない下で
⇒
その `type$aO 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
neither the element's classid attribute nor its data attribute are present, and its type attribute is set, changed, or removed,
</li>
	<li>
`具現化されて$いるかどうかが変化したとき
◎
the element changes from being rendered to not being rendered, or vice versa,
</li>
</ul>

<p>
…~UAは、次に従うモノトスル：
◎
...the user agent＼
</p>
<ul>
	<li>
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %object )
⇒
以下に与える［
`object$e 要素 %object が表現するものを決定する（し直す）
］手続き
◎
must queue an element task on the DOM manipulation task source given the object element to run the following steps to (re)determine what the object element represents.＼
</li>
	<li>
この`~task$が［
`~queueされ$ている, または【！actively】走っている
］間は、
%object の`~node文書$の`~load~eventを遅延する$。
◎
This task being queued or actively running must delay the load event of the element's node document.
</li>
</ul>
<ol>
	<li>
<p>
~IF［
利用者は、
%object の通例の挙動に代えて
%object の`~fallback内容$を示す選好を指示した
］
⇒
~GOTO `~fallback$i
◎
If the user has indicated a preference that this object element's fallback content be shown instead of the element's usual behavior, then jump to the step below labeled fallback.
</p>

<p class="note">注記：
利用者は、例えば %object の`~fallback内容$の方がより~access可能な形式であると見出したときに，それを示すよう依頼することもできる。
◎
For example, a user could ask for the element's fallback content to be shown because that content uses a format that the user finds more accessible.
</p>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…：
◎
↓</p>
		<ul>
			<li>
%object の先祖には`~media要素$が在る
◎
If the element has an ancestor media element,＼
</li>
			<li>
%object の先祖には［
`~fallback内容$を<em>示していない</em> `object$e 要素
］が在る
◎
or has an ancestor object element that is not showing its fallback content,＼
</li>
			<li>
%object は`文書~内に$ない
◎
↓</li>
			<li>
%object の`~node文書$が`属する閲覧文脈$ ~EQ ~NULL
◎
or if the element is not in a document whose browsing context is non-null,＼
</li>
			<li>
%object の`~node文書$は`全部的に作動中$でない
◎
or if the element's node document is not fully active,＼
</li>
			<li>
%object は，まだ［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$内に在る
◎
or if the element is still in the stack of open elements of an HTML parser or XML parser,＼
</li>
			<li>
%object は`具現化されて$いない
◎
or if the element is not being rendered,＼
</li>
		</ul>
<p>
…ならば
⇒
~GOTO `~fallback$i
</p>
◎
then jump to the step below labeled fallback.
</li>
	<li>
%classid ~LET ［
%object は `classid$a 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
<p>
~IF［
%classid ~NIN { ε, 空~文字列 }
］：
◎
If the classid attribute is present, and has a value that isn't the empty string, then:＼
</p>
		<ol>
			<li>
<p>
~IF［
~UAは %classid に則って相応しい`~plugin$ %~plugin を見出せる
］：
◎
if the user agent can find a plugin suitable according to the value of the classid attribute, and＼
</p>
				<ol>
					<li>
~IF［
%object における`~pluginは~sandbox化されて$いる
］
⇒
~GOTO `~fallback$i
◎
plugins aren't being sandboxed, then＼
</li>
					<li>
~UAは、 %~plugin を`利用するべき$である
— %object が `data$aO 属性を有するならば それも %~plugin に渡すべきである
◎
that plugin should be used, and the value of the data attribute, if any, should be passed to the plugin.＼
</li>
					<li>
~IF［
%~plugin から~errorが報告された
］
⇒
~GOTO `~fallback$i
◎
If no suitable plugin can be found, or if the plugin reports an error, jump to the step below labeled fallback.
</li>
					<li>
~RET
【この段は、この訳による補完】
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
~GOTO `~fallback$i
◎
↑</li>
		</ol>
	</li>
	<li>
%data ~LET ［
%object は `data$aO 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
%type ~LET ［
%object は `type$aO 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
~IF［
%data ~IN { ε, 空~文字列 }
］
⇒
~GOTO `~dataなし$i
◎
If the data attribute is present and its value is not the empty string, then:
</li>
	<li>
任意選択で
⇒
~IF［
%type ~NEQ ε
］~AND［
%type は~UA~supportする型でない
］~AND［
%type は~UAが`~plugin$を見出せる型でない
］
⇒
~GOTO `~fallback$i
（その本当の型を精査するために内容を~fetchすることなく。）
◎
If the type attribute is present and its value is not a type that the user agent supports, and is not a type that the user agent can find a plugin for, then the user agent may jump to the step below labeled fallback without fetching the content to examine its real type.
</li>
	<li>
%~URL ~LET `相対的に~URL構文解析する$( %data, %object の`~node文書$ )
◎
Parse a URL given the data attribute, relative to the element's node document.
</li>
	<li>
<p>
~IF［
%~URL ~EQ `失敗^i
］：
</p>

<ol ><li>`~eventを発火する$( %object, `error$et )
</li><li>~GOTO `~fallback$i
</li></ol>
◎
If that failed, fire an event named error at the element, then jump to the step below labeled fallback.
</li>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~URL$rq ~SET %~URL,
`~client$rq ~SET %object の`~node文書$に`関連な設定群~obj$,
`行先$rq ~SET `object^l,
`資格証~mode$rq ~SET `include^l,
`~mode$rq ~SET `navigate^l,
`~URL資格証を利用するか$rq ~SET ~T
◎
Let request be a new request whose URL is the resulting URL record, client is the element's node document's relevant settings object, destination is "object", credentials mode is "include", mode is "navigate", and whose use-URL-credentials flag is set.
</li>
	<li>
<p>
%要請 を`~fetch$する
⇒
資源の~fetchingは、［
資源が~fetchされ，`~network用~task源$から`~queueされ$る`~task$（次の段を見よ）が走る
］まで，
%object の`~node文書$を`~load~eventを遅延する$モノトスル。
</p>

<p class="trans-note">【
以下に現れる “資源” は、~fetchして得られることになる資源を指す。
】</p>

◎
Fetch request.
◎
Fetching the resource must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined next) has been run.
</li>
	<li>
~IF［
資源は まだ可用でない（例：資源は~cache内に可用でなかったので、資源を読込むためには~network越しに要請を為すことが要求される）
］
⇒
~GOTO `~fallback$i
— ただし
⇒
`~network用~task源$から`~queueされ$た`~task$は、資源が可用になり次第，この~algoをこの段から開始し直すモノトスル。
資源は増分的に読込める
— ~UAは資源の処理を始めるに十分な~dataが得られ次第、資源を “可用” と見なしてヨイ。
【！ opt to 】
◎
If the resource is not yet available (e.g. because the resource was not available in the cache, so that loading the resource required making a request over the network), then jump to the step below labeled fallback. The task that is queued by the networking task source once the resource is available must restart this algorithm from this step. Resources can load incrementally; user agents may opt to consider a resource "available" whenever enough data has been obtained to begin processing the resource.
</li>
	<li>
<p>
~IF［
資源を読込むのに失敗した（例： ~HTTP 404 ~error ／ ~DNS~errorが生じた）
］：
</p>

<ol ><li>`~eventを発火する$( %object, `error$et )
</li><li>~GOTO `~fallback$i
</li></ol>
◎
If the load failed (e.g. there was an HTTP 404 error, there was a DNS error), fire an event named error at the element, then jump to the step below labeled fallback.
</li>
	<li class="algo" id="object-type-detection">
<p>
%資源~型 ~LET 次の下位手続きを走らせた結果：
◎
Determine the resource type, as follows:
</p>
		<ol>
			<li>
%Content-Type ~LET ［
資源には `~Content-Type~metadata$が結付けられているならば それが指定する型 ／
~ELSE_ ε
］
◎
↓</li>
			<li>
<p>
~IF［
~UAは この資源に対しては、 `Content-Type^h ~headerを厳密に順守するよう環境設定されている
］~AND［
%Content-Type ~NEQ ε
］
⇒
~RET %Content-Type
◎
Let the resource type be unknown.
◎
If the user agent is configured to strictly obey Content-Type headers for this resource, and the resource has associated Content-Type metadata, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.
</p>

<p class="warning">
これは、次のようなときに脆弱性をもたらし得る：
ある~siteが特定0の~pluginが利用される
【ものと期待して，~pageに】
資源を埋込もうとしたが、遠隔~siteはそれを上書きして，代わりに［
~security上の特徴が異なる，別の~plugin
］を誘発させるような
【Content-Type~headerを伴わせて】
資源を~UAに~~供給したときに。
◎
This can introduce a vulnerability, wherein a site is trying to embed a resource that uses a particular plugin, but the remote site overrides that and instead furnishes the user agent with a resource that triggers a different plugin with different security characteristics.
</p>
			</li>
			<li>
~IF［
%type ~NEQ ε
］~AND［
%type は~UAが~supportする型でない
］~AND［
%type は ある`~plugin$が<em>~supportする</em>型である
］
⇒
~RET %type
◎
If there is a type attribute present on the object element, and that attribute's value is not a type that the user agent supports, but it is a type that a plugin supports, then let the resource type be the type specified in that type attribute, and jump to the step below labeled handler.
</li>
			<li>
<p>
~IF［
%Content-Type ~NEQ ε
］：
◎
Run the appropriate set of steps from the following list:
◎
If the resource has associated Content-Type metadata
</p>
				<ol>
					<li>
<p>
%~binaryか ~LET［
次のいずれかが満たされるならば ~T ／
~ELSE_ ~F
］：
</p>

<ul><li>［
%Content-Type ~EQ `text/plain$mt
］~AND［
資源に`~textか~binaryかを判別する規則$を適用した結果 ~NEQ `text/plain$mt
］
</li><li>%Content-Type ~EQ `application/octet-stream$mt
</li></ul>

◎
Let binary be false.
◎
If the type specified in the resource's Content-Type metadata is "text/plain", and the result of applying the rules for distinguishing if a resource is text or binary to the resource is that the resource is not text/plain, then set binary to true.
◎
If the type specified in the resource's Content-Type metadata is "application/octet-stream", then set binary to true.
</li>
					<li>
~IF［
%~binaryか ~EQ ~F
］
⇒
~RET %Content-Type
◎
If binary is false, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.
</li>
					<li>
<p>
~IF［
%type ~NIN { ε, `application/octet-stream$mt }
］：
◎
If there is a type attribute present on the object element, and its value is not application/octet-stream, then run the following steps:
</p>

						<ol>
							<li>
~IF［
%type は`~plugin$が~supportする型である
］
⇒
~RET %type
◎
↓</li>
							<li>
~IF［
%type は `image/^l から開始している
］~AND［
%type は`~XML~MIME型$ではない
］
⇒
~RET %type
◎
If the attribute's value is a type that a plugin supports, or the attribute's value is a type that starts with "image/" that is not also an XML MIME type, then let the resource type be the type specified in that type attribute.
</li>
							<li>
~RET `未知^i
◎
Jump to the step below labeled handler.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, if the resource does not have associated Content-Type metadata
</p>
				<ol>
					<li>
~IF［
%type ~EQ ε
］
⇒
%type ~SET `資源に算出される~MIME型$
◎
If there is a type attribute present on the object element, then let the tentative type be the type specified in that type attribute.
◎
Otherwise, let tentative type be the computed type of the resource.
</li>
					<li>
~IF［
%type ~NEQ `application/octet-stream$mt
］
⇒
~RET %type
◎
If tentative type is not application/octet-stream, then let resource type be tentative type and jump to the step below labeled handler.
</li>
				</ol>
			</li>
			<li>
%資源~URL ~LET `~URL構文解析する$( 資源の（~redirect後の）~URL ) 
◎
If applying the URL parser algorithm to the URL of the specified resource (after any redirects)＼
</li>
			<li>
<p>
~IF［
%資源~URL ~NEQ `失敗^i
］~AND［
%資源~URL の`~path$urlは ある`~plugin$ %~plugin が~supportする~patternに合致する
］
⇒
~RET %~plugin が取扱える型
◎
results in a URL record whose path component matches a pattern that a plugin supports, then let resource type be the type that that plugin can handle.
</p>

<p class="example">
例えば，ある~pluginは、［
`~path$url 成分が文字列 `.swf^l で終端する
］ような資源を取扱えるものとしていることもある。
◎
For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".
</p>
			</li>
			<li>
~RET `未知^i
◎
It is possible for this step to finish, or for one of the substeps above to jump straight to the next step, with resource type still being unknown. In both cases, the next step will trigger fallback.
</li>
		</ol>
	</li>
	<li>
~IF［
%資源~型 ~EQ `未知^i
］
⇒
~GOTO `~fallback$i
◎
↑↓</li>
	<li>
<p>
次のうち， %資源~型 が最初に満たす条件に応じて、対応する段に従って資源の内容を取扱う：
◎
Handler: Handle the content as given by the first of the following cases that matches:
</p>
		<dl class="switch">
			<dt>
［
%資源~型 は ~UAが~supportする型でない
］~AND［
%資源~型 は ある`~plugin$ %~plugin が~supportする型である
］：
◎
If the resource type is not a type that the user agent supports, but it is a type that a plugin supports
</dt>
			<dd>
				<ol>
					<li>
`入子な閲覧文脈を破棄する$( %object )
◎
If the object element's nested browsing context is non-null, then it must be discarded and then set to null.
</li>
					<li>
~IF［
%object における`~pluginは~sandbox化されて$いる
］
⇒
~GOTO `~fallback$i
◎
If plugins are being sandboxed, then jump to the step below labeled fallback.
</li>
					<li>
~UAは %~plugin を`利用するべき$である
— %~plugin には資源の内容も渡すべきである
◎
↓</li>
					<li>
~IF［
%~plugin から~errorが報告された
］
⇒
~GOTO `~fallback$i
◎
Otherwise, the user agent should use the plugin that supports resource type and pass the content of the resource to that plugin. If the plugin reports an error, then jump to the step below labeled fallback.
</li>
				</ol>
			</dd>

			<dt>
%資源~型 は`~XML~MIME型$である：
◎
↓</dt>
			<dt>
%資源~型 は `image/^l から開始していない：
◎
If the resource type is an XML MIME type, or if the resource type does not start with "image/"
</dt>
			<dd>
				<ol>
					<li>
%B ~LET %object が`入子にしている閲覧文脈$
◎
↓</li>
					<li>
~IF［
%B ~EQ ~NULL
］
⇒
%B ~SET `新たな入子な閲覧文脈を作成する$( %object )
◎
If the object element's nested browsing context is null, then create a new nested browsing context for the element.
</li>
					<li>
<p>
~IF［
所与の資源の`~URL$は`~about_blank に合致して$いない
］
⇒
%B をその資源へ`~navigate$する
— 次を与える下で
⇒＃
`履歴~取扱い$V ~SET `置換-$i,
`~source閲覧文脈$ ~SET %object の`~node文書$が`属する閲覧文脈$
◎
If the URL of the given resource does not match about:blank, then navigate the element's nested browsing context to that resource, with historyHandling set to "replace" and the source browsing context set to the object element's node document's browsing context.＼
</p>

<p>
（ %object の `data$aO 属性は、 %B が更に他の所在に~navigateされても更新されない。）
◎
(The data attribute of the object element doesn't get updated if the browsing context gets further navigated to other locations.)
</p>
					</li>
					<li>
この時点で、
%object は，それが`入子にしている閲覧文脈$を`表現-$する。
◎
The object element represents its nested browsing context.
</li>
				</ol>
			</dd>

			<dt>
（ %資源~型 は `image/^l から開始していて，）
画像の~supportは不能化されていない：
◎
If the resource type starts with "image/", and support for images has not been disabled
</dt>
			<dd>
				<ol>
					<li>
`入子な閲覧文脈を破棄する$( %object )
◎
If the object element's nested browsing context is non-null, then it must be discarded and then set to null.
</li>
					<li>
`画像を特定的に~sniffするための規則$を適用して，画像の型を決定する
◎
Apply the image sniffing rules to determine the type of the image.
</li>
					<li>
この時点で、
%object は指定された画像を`表現-$する
◎
The object element represents the specified image.
</li>
					<li>
~IF［
画像を具現化できない（例：~dataは~~不正な形式である／その形式は未~supportである，など）
］
⇒
~GOTO `~fallback$i
【前~段の “画像を表現する” を上書きすることになる。】
◎
If the image cannot be rendered, e.g. because it is malformed or in an unsupported format, jump to the step below labeled fallback.
</li>
				</ol>
			</dd>

			<dt>
その他（ %資源~型 は~supportされていない）：
◎
Otherwise
</dt>
			<dd>
~GOTO `~fallback$i
◎
The given resource type is not supported. Jump to the step below labeled fallback.
◎
If the previous step ended with the resource type being unknown, this is the case that is triggered.
</dd>
		</dl>
	</li>
	<li>
この時点で，
%object の内容は %object が表現するものの一部を成さないとされる
◎
The element's contents are not part of what the object element represents.
</li>
	<li>
<p>
~IF［
%object は自身が`入子にしている閲覧文脈$を表現していない
］
⇒
資源が完全に読込まれた時点で，次を行うようにしておく
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %object )
⇒
`~eventを発火する$( %object, `load$et )
◎
If the object element does not represent its nested browsing context, then once the resource is completely loaded, queue an element task on the DOM manipulation task source given the object element to fire an event named load at the element.
</p>

<p class="note">注記：
%object は自身が`入子にしている閲覧文脈$を`表現して^emいる場合、作成された`文書$が
<a href="~NAVI#completely-finish-loading">読込ngを完全に終えた</a>とき，相似的な~taskが~queueされることになる。
◎
If the element does represent its nested browsing context, then an analogous task will be queued when the created Document is completely finished loading.
</p>
	</li>
	<li>
~RET
◎
Return.
</li>
	<li>
<p>
`~dataなし@i：
</p>
		<ol>
			<li>
~IF［
%data ~EQ 空~文字列
］~OR［
%type ~EQ ε
］
⇒
~GOTO `~fallback$i
</li>
			<li>
<p>
~IF［
~UAは %type に則って相応しい`~plugin$ %~plugin を見出せる
］：
</p>
				<ol>
					<li>
~IF［
%object における`~pluginは~sandbox化されて$いる
］
⇒
~GOTO `~fallback$i
</li>
					<li>
~UAは、 %~plugin を`利用するべき$である
</li>
					<li>
~IF［
%~plugin から~errorが報告された
］
⇒
~GOTO `~fallback$i
</li>
					<li>
%~plugin が完全に読込まれた時点で，次を行うようにしておく
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %object )
⇒
`~eventを発火する$( %object, `load$et )
</li>
					<li>
~RET
</li>
				</ol>
			</li>
		</ol>
◎
If the data attribute is absent but the type attribute is present, and the user agent can find a plugin suitable according to the value of the type attribute, and plugins aren't being sandboxed, then that plugin should be used. If these conditions cannot be met, or if the plugin reports an error, jump to the step below labeled fallback. Otherwise return; once the plugin is completely loaded, queue an element task on the DOM manipulation task source given the object element to fire an event named load at the element.
</li>
	<li>
<p>
`~fallback@i：
◎
Fallback:＼
</p>
		<ol>
			<li>
この時点で、 %object は［
%object の子のうち， `param$e 要素~以外のもの
］を`表現-$する
— それらが %object の`~fallback内容$になる
◎
The object element represents the element's children, ignoring any leading param element children. This is the element's fallback content.＼
</li>
			<li>
~IF［
%object が~instance化した`~plugin$ %~plugin はある
］
⇒
%~plugin を未読込みにする
◎
If the element has an instantiated plugin, then unload it.＼
</li>
			<li>
`入子な閲覧文脈を破棄する$( %object )
◎
If the element's nested browsing context is non-null, then it must be discarded and then set to null.
</li>
		</ol>
	</li>
</ol>
</div>

<p id="object-plugin">
上の~algoにて 
`object$e 要素 %object に対し
ある`~plugin$ %~plugin を~instance化して利用するときは：
◎
When the algorithm above instantiates a plugin,＼
</p>

<ul>
	<li>
<p>
次に挙げる順による各~parameterを，
%~plugin に渡すべきである：
</p>

<ol ><li>%object 上のすべての属性の名前と値
— 構文解析器により追加された各 属性は~source順序で
</li><li>名前 `PARAM^l, 値 ~NULL にされた~parameter
</li><li>%object の子である `param$e 要素すべての`~parameter$の名前と値
— 要素の`~tree順序$で
</li></ol>
◎
the user agent should pass to the plugin used the names and values of all the attributes on the element, in the order they were added to the element, with the attributes added by the parser being ordered in source order, followed by a parameter named "PARAM" whose value is null, followed by all the names and values of parameters given by param elements that are children of the object element, in tree order.＼
</li>
	<li>
%~plugin が~script可能な~interfaceを~supportする場合、
%object を表現している `HTMLObjectElement$I ~objは，その~interfaceを公開するべきである。
◎
If the plugin supports a scriptable interface, the HTMLObjectElement object representing the element should expose that interface.＼
</li>
	<li>
%object は %~plugin を`表現-$する。
%~plugin は`入子な閲覧文脈$ではない。
◎
The object element represents the plugin. The plugin is not a nested browsing context.
</li>
</ul>

<p>【！ id="sandboxPluginObject" 】
`object$e 要素の目的においては、次が満たされるならば，
`~pluginは~sandbox化されて@
いるものと見なされる
⇒
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN 要素の`~node文書$にて`作動中の~sandbox法~flag集合$
◎
Plugins are considered sandboxed for the purpose of an object element if the sandboxed plugins browsing context flag is set on the object element's node document's active sandboxing flag set.
</p>

<p>
`object$e 要素の内容は、［
上の~algoに因り，参照した資源を示せない場合（例：404~errorが返されたなど）
］に限り，利用される`~fallback内容$として動作する。
これにより、複数の `object$e 要素を入子にすれば，能力が相異なる複数の~UAを対象にできるようになる
— ~UAは，自身が~supportする最初のものを選ぶことになる。
◎
Due to the algorithm above, the contents of object elements act as fallback content, used only when referenced resources can't be shown (e.g. because it returned a 404 error). This allows multiple object elements to be nested inside each other, targeting multiple user agents with different capabilities, with the user agent picking the first one it supports.
</p>

<p>
`object$e 要素は、`~load~eventを遅延し得る$とする。
◎
The object element potentially delays the load event.
</p>

<p>
`form$a 属性は、
`object$e 要素の`~form所有者$を明示的に指定するために利用される。
◎
The form attribute is used to explicitly associate the object element with its form owner.
</p>

<p>
`object$e 要素は、`寸法~属性$を~supportする。
◎
The object element supports dimension attributes.
</p>

<div>
<p>
`data@mO
~IDL属性は、
`data$aO 内容~属性を`反映する$モノトスル。
</p>

<p>
`type@mO
~IDL属性は、
`type$aO 内容~属性を`反映する$モノトスル。
</p>

<p>
`name@mO
~IDL属性は、
`name$aO 内容~属性を`反映する$モノトスル。
</p>
◎
The IDL attributes data, type, and name each must reflect the respective content attributes of the same name.
</div>

<div class="algo">
`contentDocument@mO
取得子~手続きは
⇒
~RET コレの`内容~文書$
◎
The contentDocument IDL attribute, on getting, must return the object element's content document.
</div>

<div class="algo">
`contentWindow@mO
取得子~手続きは
⇒
~RET コレが`入子にしている閲覧文脈$ %B  に応じて
⇒＃
非 ~NULL ならば %B の `WindowProxy$I ~obj ／
~ELSE_ ~NULL
◎
The contentWindow IDL attribute must return the WindowProxy object of the object element's nested browsing context, if its nested browsing context is non-null; otherwise, it must return null.
</div>

<ul>
	<li>
`willValidate$m,
`validity$m,
`validationMessage$m
属性, および
`checkValidity()$m,
`reportValidity()$m,
`setCustomValidity()$m
~methodは、`拘束~検証~API$の一部である。
◎
The willValidate, validity, and validationMessage attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API.＼
</li>
	<li>
`form$m ~IDL属性は、要素の~form~APIの一部である。
◎
The form IDL attribute is part of the element's forms API.
</li>
</ul>

<div class="example">

<p>
次の例の~HTML~pageは、 `object$e 要素を用いて，別の~pageを埋込んでいる。
◎
In this example, an HTML page is embedded in another using the object element.
</p>

`object-2^xCode

</div>

<div class="example">

<p>
次の例に ~pluginを~HTML内で利用する方法を示す（この事例では、動画~fileを示す~Flash~plugin）。
~Flashは可能化されていないが `video$e は~supportする~UA利用者~向けには、~fallbackとして，動画を示す `video$e 要素を供している。
最後に，~Flashも `video$e 能力も備えない~browser利用者~向けには、動画への~linkを供している。
◎
The following example shows how a plugin can be used in HTML (in this case the Flash plugin, to show a video file). Fallback is provided for users who do not have Flash enabled, in this case using the video element to show the video for those using user agents that support video, and finally providing a link to the video for those who have neither Flash nor a video-capable browser.
</p>

`object-3^xCode

</div>

			</section>
			<section id="the-param-element">
<h4 title="The param element">4.8.8. `param^e 要素</h4>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
なし。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`object$e 要素の子として
— ただし，同胞のどの`~flow内容$よりも前。
◎
As a child of an object element, before any flow content.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了~tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`name$aP
— ~parameterの名前
◎
name — Name of parameter
</dd>
	<dd>
`value$aP
— ~parameterの値
◎
value — Value of parameter
</dd>

	<dt>`~accessibilityの考慮点$</dt>
	<dd>
`param$AA
◎
For authors.
For implementers.
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window]
interface `HTMLParamElement@I : `HTMLElement$I {
  [`HTMLConstructor$] constructor();

  [`CEReactions$] attribute DOMString `name$mP;
  [`CEReactions$] attribute DOMString `value$mP;

  // `HTMLParamElement$obsMb
};
</pre>
	</dd>
</dl>

<p>
`param$e 要素は、 `object$e 要素により呼出される~plugin用の~parameterを定義する
— それは、自身のみでは何も`表現-$しない。
◎
The param element defines parameters for plugins invoked by object elements. It does not represent anything on its own.
</p>

<p>
`param$e 要素の
`name@aP,
`value@aP
属性は：
◎
↓
</p>
<ul>
	<li>
順に、~parameterの［
名前, 値
］を与える。
◎
The name attribute gives the name of the parameter.
◎
The value attribute gives the value of the parameter.
</li>
	<li>
要素は、これら両~属性とも有していなければナラナイ。
◎
Both attributes must be present.＼
</li>
	<li>
両~属性とも，値は何でもヨイ。
◎
They may have any value.
</li>
	<li>
［
要素が両~属性とも有する
］~AND［
要素の親~要素は `object$e 要素である
］ならば、要素は，所与の［
名前, 値
］~pairを伴う
`~parameter@
を定義する。
◎
If both attributes are present, and if the parent element of the param is an object element, then the element defines a parameter with the given name-value pair.
</li>
</ul>

<p>
`param$e 要素が［
~instance化された`~plugin$ %~plugin を`表現-$する `object$e 要素の子である
］~AND［
~UAは、 %~plugin を更新する能を備える~API特能を利用して，
%~plugin と通信している
］下で，要素が定義する`~parameter$の［
名前または値
］が変化したときは、~UAは 更新する能を適切に行使して，
%~plugin に変化を通知するモノトスル。
◎
If either the name or value of a parameter defined by a param element that is the child of an object element that represents an instantiated plugin changes, and if that plugin is communicating with the user agent using an API that features the ability to update the plugin when the name or value of a parameter so changes, then the user agent must appropriately exercise that ability to notify the plugin of the change.
</p>

<div>
<p>
`name@mP
~IDL属性は、
`name$aP 内容~属性を`反映する$モノトスル。
</p>

<p>
`value@mP
~IDL属性は、
`value$aP 内容~属性を`反映する$モノトスル。
</p>
◎
The IDL attributes name and value must both reflect the respective content attributes of the same name.
</div>

<div class="example">

<p>
`param$e 要素を用いて、~parameterを~plugin（この事例では、 O3D ~plugin）に渡す例：
◎
The following example shows how the param element can be used to pass a parameter to a plugin, in this case the O3D plugin.
</p>

`param-1^xCode

</div>
			</section>
			<section id="_other-sections-2">
<h4>4.8.9. 〜 4.8.15.</h4>

<p class="trans-note">【
これらの節の和訳は
<a href="~HEimages#_toc">別~page（画像~関連）</a> ／
<a href="~HEmedia#_toc">別~page（~media要素）</a>
にて。
】</p>

			</section>
			<section id="mathml">
<h4>4.8.16. ~MathML</h4>

<p>
~MathML `math$e 要素は、この仕様における内容~modelの目的においては，［
`埋込d内容$ ／ `句ng内容$ ／ `~flow内容$ ／ `可触~内容$
］に分類される。
◎
The MathML math element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.
</p>

<p>
~MathML `annotation-xml$e 要素が包含する，`~HTML名前空間$に属する要素は、`~flow内容$でなければナラナイ。
◎
When the MathML annotation-xml element contains elements from the HTML namespace, such elements must all be flow content.
</p>

<p>
~HTML要素の子孫である~MathML~token要素（
`mi$e ／ `mo$e ／ `mn$e ／ `ms$e ／ `mtext$e
）は、`~HTML名前空間$に属する要素のうち，`句ng内容$を包含してもヨイ。
◎
When the MathML token elements (mi, mo, mn, ms, and mtext) are descendants of HTML elements, they may contain phrasing content elements from the HTML namespace.
</p>

<p>
~UAは、~MathMLの［
内容~model, ~layout, 具現化
］の目的においては，［［
~MathML要素のうち，自身の内容~modelが直の~textを許容しないもの
］内に見出された，`要素間~空白$でない~text
］を［
実際には ~MathML `mtext$e 要素が当の~textを包装しているように装う
］ことにより，取扱うモノトスル。
（しかしながら、そのような~textは適合しない。）
◎
User agents must handle text other than inter-element whitespace found in MathML elements whose content models do not allow straight text by pretending for the purposes of MathML content models, layout, and rendering that the text is actually wrapped in a MathML mtext element. (Such text is not, however, conforming.)
</p>

<p>
~UAは、~MathMLの［
~layout, 具現化
］の目的においては，［
~MathML要素のうち，その内容が自身の内容~modelに合致しないもの
］に対しては［
何らかの適切な~error~messageを包含している，~MathML `merror$e 要素に置換されていた
］かのように動作するモノトスル。
◎
User agents must act as if any MathML element whose contents does not match the element's content model was replaced, for the purposes of MathML layout and rendering, by a MathML merror element containing some appropriate error message.
</p>

<p>
~MathML要素の意味論は、
`MathML^cite `MATHML$r,
および他の`適用-可能な仕様$にて定義される。
◎
The semantics of MathML elements are defined by MathML and other applicable specifications. [MATHML]
</p>

<div class="example">

<p>
~HTML文書~内での~MathMLの利用~例：
◎
Here is an example of the use of MathML in an HTML document:
</p>

`mathml-1^xCode

</div>

			</section>
			<section id="svg-0">
<h4 title="SVG">4.8.17. ~SVG</h4>

<p>
~SVG `svg$e 要素は、この仕様における内容~modelの目的においては，［
`埋込d内容$ ／ `句ng内容$ ／ `~flow内容$ ／ `可触~内容$
］に分類される。
◎
The SVG svg element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.
</p>

<p>
~SVG `foreignObject$e 要素が包含する要素のうち，`~HTML名前空間$に属するものは、`~flow内容$でなければナラナイ。
◎
When the SVG foreignObject element contains elements from the HTML namespace, such elements must all be flow content.
</p>

<p>
`~HTML文書$の内側における~SVG `~svg-title$e 要素の内容~modelは、`句ng内容$とする（これは、 `SVG 2^cite が課す要件を更に拘束する）。
◎
The content model for the SVG title element inside HTML documents is phrasing content. (This further constrains the requirements given in SVG 2.)
</p>

<p>
~SVG要素の意味論は、
`SVG 2^cite `SVG$r
と他の`適用-可能な仕様$にて定義される。
◎
The semantics of SVG elements are defined by SVG 2 and other applicable specifications. [SVG]
</p>

<hr>

<dl class="domintro">
	<dt>%doc = %iframe.`getSVGDocument()$m</dt>
	<dt>%doc = %embed.`getSVGDocument()$m</dt>
	<dt>%doc = %object.`getSVGDocument()$m</dt>
	<dd>
［
`iframe$e ／ `embed$e ／ `object$e 
］要素が~SVGを埋込むために利用されている事例では、 `Document$I ~objを返す。
◎
Returns the Document object, in the case of iframe, embed, or object elements being used to embed SVG.
</dd>
</dl>

<div class="algo">
<p>
`getSVGDocument()@m
~method~手続きは：
◎
The getSVGDocument() method must run the following steps:
</p>
<ol>
	<li>
%文書 ~LET コレの`内容~文書$
◎
Let document be this element's content document.
</li>
	<li>
~IF［
%文書 ~EQ ~NULL
］
⇒
~RET ~NULL
◎
↓</li>
	<li>
~RET ［
%文書 は次に該当するならば %文書 ／
~ELSE_ ~NULL
］
⇒
`~navigate$~algoにおいて`資源に算出される~MIME型$は `image/svg+xml$mt であったため，
<a href="~NAVI#read-xml">§ ~XML~file用の~page読込n処理~model</a>
により作成されたものである
◎
If document is non-null and was created by the page load processing model for XML files section because the computed type of the resource in the navigate algorithm was image/svg+xml, then return document.
◎
Return null.
</li>
</ol>
</div>

			</section>
			<section id="dimension-attributes">
<h4 title="Dimension attributes">4.8.18. 寸法~属性</h4>

				<section>
<h5>
作者~要件
◎
Author requirements:＼
</h5>

<p>
次に挙げる要素に対しては、［
`width@a
／
`height@a
］属性を指定してもヨイ
⇒＃
`img$e,
`iframe$e,
`embed$e,
`object$e,
`video$e,
`source$e のうち その親は `picture$e 要素であるもの,
`input$e のうち その `type$a 属性は `Image$st 状態にあるもの
◎
The width and height attributes on img, iframe, embed, object, video, source when the parent is a picture element and, when their type attribute is in the Image Button state, input elements may be specified＼
</p>

<p>
これらの属性は、要素の視覚的な内容の寸法を`~CSS~pixel$単位で与える（順に，出力~mediaの名目上の方向に相対的な［
横幅, 縦幅
］を与える）。
両~属性とも、指定する値は`妥当な負でない整数$でなければナラナイ。
◎
to give the dimensions of the visual content of the element (the width and height respectively, relative to the nominal direction of the output medium), in CSS pixels. The attributes, if specified, must have values that are valid non-negative integers.
</p>

<p>
指定する寸法は、資源~自身に指定されている寸法から相違してもヨイ
— 資源の解像度は`~CSS~pixel$の解像度から相違することもあるので。
（`~CSS~pixel$の解像度は、~screen上では 96ppi になるが，一般には 読み取り距離に依存する。）
両~属性とも指定する場合、次のいずれかを満たさなければナラナイ：
◎
The specified dimensions given may differ from the dimensions specified in the resource itself, since the resource may have a resolution that differs from the CSS pixel resolution. (On screens, CSS pixels have a resolution of 96ppi, but in general the CSS pixel resolution depends on the reading distance.) If both attributes are specified, then one of the following statements must be true:
</p>

<ul>
	<li>
%W − 0.5 ~LTE %H ÷ %iH × %iW ~LTE %W + 0.5
◎
specified width - 0.5 ≤ specified height * target ratio ≤ specified width + 0.5
</li>
	<li>
%H − 0.5 ~LTE %W ÷ %iW × %iH ~LTE %H + 0.5
◎
specified height - 0.5 ≤ specified width / target ratio ≤ specified height + 0.5
</li>
	<li>
%H = %W = 0
◎
specified height = specified width = 0
</li>
</ul>

<p>
— ここで、
%W, %H は，順に
`width$a, `height$a
属性の値とする。
%iW, %iH は，順に資源の［
`内在的~横幅$, `内在的~縦幅$
］とする。
◎
The target ratio is the ratio of the intrinsic width to the intrinsic height in the resource. The specified width and specified height are the values of the width and height attributes respectively.
</p>

<p>
当の資源が`内在的~横幅$も`内在的~縦幅$も持たない場合、両~属性とも省略しなければナラナイ。
◎
The two attributes must be omitted if the resource in question does not have both an intrinsic width and an intrinsic height.
</p>

<p>
両~属性とも値が 0 の場合、要素は 利用者~向けに意図されていないことを指示する（例：~pageが見られた回数を数える~service用途など）。
◎
If the two attributes are both zero, it indicates that the element is not intended for the user (e.g. it might be a part of a service to count page views).
</p>

<p class="note">注記：
これらの寸法~属性には、画像を伸張する用途は意図されていない。
◎
The dimension attributes are not intended to be used to stretch the image.
</p>

				</section>
				<section>
<h5>
~UA要件
◎
User agent requirements:＼
</h5>

<p>
~UAには、［
`width$a, `height$a
］属性を
<a href="~HTMLrendering#dimRendering">具現化~用~hintに利用する</a>
ことが期待される。
◎
User agents are expected to use these attributes as hints for the rendering.
</p>

<div>
<p>
［
`iframe$e ／ `embed$e ／ `object$e ／ `source$e ／ `video$e
］要素の：
</p>
<ul>
	<li>
`width@m
~IDL属性は、
`width$a 内容~属性を`反映する$モノトスル。
</li>
	<li>
`height@m
~IDL属性は、
`height$a 内容~属性を`反映する$モノトスル。
</li>
</ul>
◎
The width and height IDL attributes on the iframe, embed, object, source, and video elements must reflect the respective content attributes of the same name.
</div>

<p class="note">注記：
これらの~IDL属性の型は、［
`iframe$e ／ `embed$e ／ `object$e
］に対しては `DOMString^I であるが，［
`video$e ／ `source$e
］に対しては `unsigned long^I である。
◎
For iframe, embed and object the IDL attributes are DOMString; for video and source the IDL attributes are unsigned long.
</p>

<p class="note">注記：
［
`img$e ／ `input$e
］要素~上の対応する~IDL属性は、各~要素の節にて定義される
— それらには、それらの要素の他の挙動に特有な~~面が少しばかりあるので。
◎
The corresponding IDL attributes for img and input elements are defined in those respective elements' sections, as they are slightly more specific to those elements' other behaviors.
</p>

				</section>
			</section>
</main>
