<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML — iframe, embed, object 要素 他（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />

<style type="text/css">
.type {
	color: #600;
	font-family: monospace0, monospace;
	font-style:italic;
}
</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		persisted_parts: Util.collectHtmlCodeList(),
		collectParts: Util.collectParts,
		toc_main: 'MAIN',
		generate: expand
	};

	Util.switchWordsInit(source_data);
}

function expand(){

	const class_map = {
		e: 'element',
		E: 'error',
		a: 'attr',
		aF: 'attr',
		aE: 'attr',
		aO: 'attr',
		aP: 'attr',
		et: 'event-type',
		sc: 'scheme',
		st: 'attr-state',
		v: 'value',
		h: 'header',
		U: 'code-point',
	};

	const tag_map = {
		I: 'code',
		m: 'code',
		mP: 'code',
		mF: 'code',
		mE: 'code',
		mO: 'code',
		E: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		aF: 'code',
		aE: 'code',
		aO: 'code',
		aP: 'code',
		et: 'code',
		mt: 'code',
		st: 'span',
		sc: 'code',
		h: 'code',
		sub: 'sub',
		U: 'span',
		v: 'code',
		i: 'i',
	};

	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'm': // IDL member
case 'mS':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'sc': // url scheme
	text = text.replace(/_/, ':');
	break;
case 'U': // 
	text = 'U+' + key;
	break;
case 'smb': //
	text = '(<span class="char-symbol">' + text + '</span>)'
	break;
case 'xCode':
	return '<a id="_ex-' + key + '">＊</a>'
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2018-06-28
trans_update:2018-06-30
source_checked:180622
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/iframe-embed-object.html
nav_prev:HEimages
nav_next:HEmedia
trans_1st_pub:2017-03-07

●●original_urls
mathml:https://html.spec.whatwg.org/multipage/embedded-content-other.html
svg-0:https://html.spec.whatwg.org/multipage/embedded-content-other.html
dimension-attributes:https://html.spec.whatwg.org/multipage/embedded-content-other.html

●●original_id_map


●●link_map


CEReactions:~HEcustom#cereactions
HTMLConstructor:~HTMLdom#htmlconstructor

I.DOMTokenList:~DOM4#interface-domtokenlist
I.Document:~HTMLdom#document
I.HTMLElement:~HTMLdom#htmlelement
I.HTMLEmbedElement:#htmlembedelement
I.HTMLFormElement:~HEforms#htmlformelement
I.HTMLObjectElement:#htmlobjectelement
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest
I.ValidityState:~HTMLforms#validitystate
I.Window:~WINDOW#window
I.WindowProxy:~WINDOW#windowproxy
I.HTMLIFrameElement:#htmliframeelement
I.HTMLParamElement:#htmlparamelement

m.checkValidity:~HTMLforms#dom-cva-checkvalidity
m.form:~HTMLforms#dom-fae-form
m.getSVGDocument:#dom-media-getsvgdocument
m.getUserMedia:https://w3c.github.io/mediacapture-main/#dom-mediadevices-getusermedia
m.reportValidity:~HTMLforms#dom-cva-reportvalidity
m.requestFullscreen:~FULLSCREEN#dom-element-requestfullscreen
m.setCustomValidity:~HTMLforms#dom-cva-setcustomvalidity
m.validationMessage:~HTMLforms#dom-cva-validationmessage
m.validity:~HTMLforms#dom-cva-validity
m.value:~DOM4#dom-domtokenlist-value
m.willValidate:~HTMLforms#dom-cva-willvalidate
m.width:#dom-dim-width
m.height:#dom-dim-height

mF.allowFullscreen:#dom-iframe-allowfullscreen
mF.allowPaymentRequest:#dom-iframe-allowpaymentrequest
mF.allowUserMedia:#dom-iframe-allowusermedia
mF.allow:#dom-iframe-allow
mF.contentDocument:#dom-iframe-contentdocument
mF.contentWindow:#dom-iframe-contentwindow
mF.name:#dom-iframe-name
mF.referrerPolicy:#dom-iframe-referrerpolicy
mF.sandbox:#dom-iframe-sandbox
mF.src:#dom-iframe-src
mF.srcdoc:#dom-iframe-srcdoc

mE.src:#dom-embed-src
mE.type:#dom-embed-type

mO.contentDocument:#dom-object-contentdocument
mO.contentWindow:#dom-object-contentwindow
mO.data:#dom-object-data
mO.name:#dom-object-name
mO.type:#dom-object-type
mO.typeMustMatch:#dom-object-typemustmatch
mO.useMap:#dom-object-usemap

mP.name:#dom-param-name
mP.value:#dom-param-value

e.embed:#the-embed-element
e.iframe:#the-iframe-element
e.object:#the-object-element
e.param:#the-param-element
e.video:~HEmedia#the-video-element
e.img:~HEimages#the-img-element
e.input:~HEinput#the-input-element

e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.title:~HEmetadata#the-title-element
e.body:~HEsections#the-body-element
e.form:~HEforms#the-form-element

e.mi:~MATHML/chapter3.html#presm.mi
e.mn:~MATHML/chapter3.html#presm.mn
e.mo:~MATHML/chapter3.html#presm.mo
e.ms:~MATHML/chapter3.html#presm.ms
e.mtext:~MATHML/chapter3.html#presm.mtext
e.merror:~MATHML/chapter3.html#presm.merror
e.math:~MATHML/chapter2.html#interf.toplevel
e.annotation-xml:~MATHML/chapter5.html#mixing.elements.annotation.xml


e.foreignObject:~SVG2/embedded.html#ForeignObjectElement
e.svg:~SVG2/struct.html#SVGElement
e.~svg-title:~SVG2/struct.html#TitleElement

a.align:~HTMLobs#attr-embed-align
a.classid:~HTMLobs#attr-object-classid
a.hspace:~HTMLobs#attr-embed-hspace
a.name:~HTMLobs#attr-embed-name
a.vspace:~HTMLobs#attr-embed-vspace

a.form:~HTMLforms#attr-fae-form
a.width:#attr-dim-width
a.height:#attr-dim-height
a.itemprop:~HTMLLS/microdata.html#names:-the-itemprop-attribute
a.manifest:~HEmetadata#attr-html-manifest
a.usemap:~HEimages#attr-hyperlink-usemap
a.type:~HEinput#attr-input-type

aF.allow:#attr-iframe-allow
aF.allowfullscreen:#attr-iframe-allowfullscreen
aF.allowpaymentrequest:#attr-iframe-allowpaymentrequest
aF.allowusermedia:#attr-iframe-allowusermedia
aF.name:#attr-iframe-name
aF.referrerpolicy:#attr-iframe-referrerpolicy
aF.sandbox:#attr-iframe-sandbox
aF.src:#attr-iframe-src
aF.srcdoc:#attr-iframe-srcdoc

aE.src:#attr-embed-src
aE.type:#attr-embed-type

aO.data:#attr-object-data
aO.name:#attr-object-name
aO.type:#attr-object-type
aO.typemustmatch:#attr-object-typemustmatch

aP.name:#attr-param-name
aP.value:#attr-param-value

et.error:~HTMLindex#event-error
et.load:~HTMLindex#event-load
et.unload:~HTMLindex#event-unload


mt.application/octet-stream:~IETF/rfc2046#section-4.5.1
mt.text/html:~HTMLLS/iana.html#text/html
mt.text/plain:~IETF/rfc2046#section-4.1.3
mt.image/svg+xml:~HTMLindex#image/svg+xml

sc.about_blank:~HTMLdep#about:blank
sc.about_srcdoc:~HTMLurl#about:srcdoc


v.allow-forms:~ORIGIN#attr-iframe-sandbox-allow-forms
v.allow-modals:~ORIGIN#attr-iframe-sandbox-allow-modals
v.allow-orientation-lock:~ORIGIN#attr-iframe-sandbox-allow-orientation-lock
v.allow-pointer-lock:~ORIGIN#attr-iframe-sandbox-allow-pointer-lock
v.allow-popups-to-escape-sandbox:~ORIGIN#attr-iframe-sandbox-allow-popups-to-escape-sandbox
v.allow-popups:~ORIGIN#attr-iframe-sandbox-allow-popups
v.allow-presentation:~ORIGIN#attr-iframe-sandbox-allow-presentation
v.allow-same-origin:~ORIGIN#attr-iframe-sandbox-allow-same-origin
v.allow-scripts:~ORIGIN#attr-iframe-sandbox-allow-scripts
v.allow-top-navigation-by-user-activation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation-by-user-activation
v.allow-top-navigation:~ORIGIN#attr-iframe-sandbox-allow-top-navigation

st.Image:~HEinput#image-button-state-(type=image)

i.fallback:#_object-fallback
i.~dataなし:#_no-data

	●用語
文書:~HTMLdom#the-document-object
既定の~plugin:#_default-plugin
利用は許容されて:#allowed-to-use
~iframe-srcdoc文書:#an-iframe-srcdoc-document
~iframe~load~event手続き:#iframe-load-event-steps
~iframe読込中~flag:#iframe-load-in-progress
~iframe読込黙秘中~flag:#mute-iframe-load
	~iframeまたは~frame要素に対する他の場合の手続き:#otherwise-steps-for-iframe-or-frame-elements
~iframeの属性を処理する:#process-the-iframe-attributes

内容の型:#concept-embed-type
作動中になれ:#concept-embed-active
~embed要素を設定しておく手続き:#the-embed-element-setup-steps
~embed~task源:#embed-task-source

	~instance化して利用する
~pluginを利用するべき:#object-plugin
	should be used:#object-plugin
~sandbox化されて:#sandboxPluginObject
~parameter:#concept-param-parameter


	●用語HTML
寸法~属性:#dimension-attributes
画像~map:~HEimages#image-map
~media要素:~HEmedia#media-element

~XML互換:~HTMLINFRA#xml-compatible
文書の中へ挿入され:~HTMLINFRA#insert-an-element-into-a-document
文書から除去され:~HTMLINFRA#remove-an-element-from-a-document
~plugin:~HTMLINFRA#plugin
保安化-:~HTMLINFRA#concept-plugin-secure
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications

反映-:~HTMLcdom#reflect
既知の値のみに制限され:~HTMLcdom#limited-to-only-known-values

~Content-Type:~HTMLurl#content-type
~Content-Type~metadata:~HTMLurl#content-type
	資源の／~associated／明示的な ~Content-Type~metadata
~referrer施策~属性:~HTMLurl#referrer-policy-attribute
相対的に構文解析-:~HTMLurl#parse-a-url
結果の~URL~record:~HTMLurl#resulting-url-record
前後~空白~可の妥当かつ空でない~URL:~HTMLurl#valid-non-empty-url-potentially-surrounded-by-spaces

真偽~属性:~HTMLcms#boolean-attribute
空白区切りの一意な~tokenからなる無順序~集合:~HTMLcms#unordered-set-of-unique-space-separated-tokens
妥当な非負~整数:~HTMLcms#valid-non-negative-integer


分類:~HTMLdom#concept-element-categories
内容~属性:~HTMLdom#concept-element-attributes
内容~model:~HTMLdom#concept-element-content-model
この要素を利用できる文脈:~HTMLdom#concept-element-contexts
~DOM~interface:~HTMLdom#concept-element-dom
埋込みの内容:~HTMLdom#embedded-content-category
~flow内容:~HTMLdom#flow-content-2
大域~属性:~HTMLdom#global-attributes
対話的~内容:~HTMLdom#interactive-content-2
なし:~HTMLdom#concept-content-nothing
可触~内容:~HTMLdom#palpable-content-2
句内容:~HTMLdom#phrasing-content-2
~fallback内容:~HTMLdom#fallback-content
透過的な内容:~HTMLdom#transparent
text/html における~tag省略:~HTMLdom#concept-element-tag-omission
doc.~CSP~list:~HTMLdom#concept-document-csp-list
doc.~HTTPS状態:~HTMLdom#concept-document-https-state
表現-:~HTMLdom#represents
要素間~空白:~HTMLdom#inter-element-whitespace

~DOM操作~task源:~WAPI#dom-manipulation-task-source
環境~設定群~obj:~WAPI#environment-settings-object
~event-loop:~WAPI#event-loop
~network用~task源:~WAPI#networking-task-source
~taskを~queueする:~WAPI#queue-a-task
~taskを~queueし:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
最初の段:~WAPI#step1
~task源:~WAPI#task-source
~task:~WAPI#concept-task


syn.~comment:~HTMLwriting#syntax-comments
syn.要素:~HTMLwriting#syntax-elements
~DOCTYPE:~HTMLwriting#syntax-doctype
終了tag:~HTMLwriting#syntax-end-tag
	~HTMLwriting#syntax-tag-omission
~HTML構文:~HTMLwriting#syntax

~HTML構文解析器:~HTMLparsing#html-parser
完全に読込済み:~HTMLparsing#completely-loaded
~load~eventを遅延-:~HTMLparsing#delay-the-load-event
~load~eventを遅延している:~HTMLparsing#delay-the-load-event-
読込後~taskは準備済み:~HTMLparsing#ready-for-post-load-tasks
~open要素~stack:~HTMLparsing#stack-of-open-elements

~listされる要素:~HEforms#category-listed
拘束~検証の対象外:~HTMLforms#barred-from-constraint-validation
拘束~検証~API:~HTMLforms#the-constraint-validation-api
~form所有者:~HTMLforms#form-owner

~formに所有され得る要素:~HEforms#form-associated-element
提出-可能な要素:~HEforms#category-submit

利用者による作動化により誘発され:~HTMLinteraction#triggered-by-user-activation

~XML構文解析器:~HTMLxhtml#xml-parser
具現化されて:~HTMLrendering#being-rendered

作動中の文書:~BROWSERS#active-document
全部的に作動中:~BROWSERS#fully-active
先祖~閲覧文脈:~BROWSERS#ancestor-browsing-context
補助~閲覧文脈:~BROWSERS#auxiliary-browsing-context
閲覧文脈:~BROWSERS#browsing-context
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
妥当な閲覧文脈~名:~BROWSERS#valid-browsing-context-name
閲覧文脈~容器:~BROWSERS#browsing-context-container
閲覧文脈~名:~BROWSERS#browsing-context-name
	＊~name:~BROWSERS#browsing-context-name
属する閲覧文脈:~BROWSERS#concept-document-bc
子~閲覧文脈:~BROWSERS#child-browsing-context
内容~文書:~BROWSERS#concept-bcc-content-document
新たな閲覧文脈を作成する:~BROWSERS#creating-a-new-browsing-context
~load~event遅延-中~mode:~BROWSERS#delaying-load-events-mode
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context

閲覧文脈を破棄する:~WINDOW#a-browsing-context-is-discarded
破棄され:~WINDOW#a-browsing-context-is-discarded

~session履歴:~HISTORY#session-history

生成元:~ORIGIN#concept-origin
非同一生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
~iframe~sandbox法~flag集合:~ORIGIN#iframe-sandboxing-flag-set
~sandbox法~指令を構文解析-:~ORIGIN#parse-a-sandboxing-directive
閲覧文脈~sandbox化( ~plugin )~flag:~ORIGIN#sandboxed-plugins-browsing-context-flag

doc.特色機能~施策:~HTMLdom#concept-document-feature-policy
~navigate:~NAVI#navigate
~navi:~NAVI#navigate
置換~可能化~flag:~NAVI#replacement-enabled
~source閲覧文脈:~NAVI#source-browsing-context
未読込みにされ:~NAVI#unload-a-document

具現化~用~hint:~HTMLrendering#dimRendering

	●用語他
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII英大文字:~INFRA#ascii-upper-alpha
~ASCII空白:~INFRA#ascii-whitespace
~HTML名前空間:~INFRA#html-namespace

~URL~record:~URL1#concept-url
~URL:~URL1#concept-url
~URL構文解析する:~URL1#concept-url-parser
url.~path:~URL1#concept-url-path
url.素片:~URL1#concept-url-fragment
url.同等:~URL1#concept-url-equals

~fetch:~FETCH#concept-fetch
~ok~status:~FETCH#ok-status
要請:~FETCH#concept-request
応答:~FETCH#concept-response
rq.~client:~FETCH#concept-request-client
rq.資格証~mode:~FETCH#concept-request-credentials-mode
rq.行先:~FETCH#concept-request-destination
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.~url:~FETCH#concept-request-url
rq.~URL資格証~利用~flag:~FETCH#concept-request-use-url-credentials-flag
rs.~url~list:~FETCH#concept-response-url-list
rs.~CSP~list:~FETCH#concept-response-csp-list
rs.~HTTPS状態:~FETCH#concept-response-https-state
rs.本体:~FETCH#concept-response-body
rs.~header~list:~FETCH#concept-response-header-list

~MIME型:~MIMESNIFF#mime-type
~XML~MIME型:~MIMESNIFF#xml-mime-type
資源に算出される~MIME型:~MIMESNIFF#computed-mime-type
画像の~sniffing:~MIMESNIFF#rules-for-sniffing-images-specifically
~textか~binaryかを判別する規則:~MIMESNIFF#rules-for-text-or-binary
妥当な~MIME型~文字列:~MIMESNIFF#valid-mime-type

要素は~CSPにより先天的に阻止されるべきか？:~CSP3#should-plugin-element-be-blocked-a-priori-by-content-security-policy

~eventを発火する:~DOM4#concept-event-fire
~HTML文書:~DOM4#html-document
doc.~URL:~DOM4#concept-document-url
~XML文書:~DOM4#xml-document
文書~要素:~DOM4#document-element
文書~内に:~DOM4#in-a-document
~node文書:~DOM4#concept-node-document
~supportする~token集合:~DOM4#concept-supported-tokens
木~順序:~DOM4#concept-tree-order

属性~値の正規化:https://www.w3.org/TR/xml/#AVNormalize
~referrer施策:~REFERRER-POLICY#referrer-policy

特色機能~施策:~FEATUREPOLICY#feature-policy
容器~施策:~FEATUREPOLICY#container-policy
直列形の特色機能~施策:~FEATUREPOLICY#serialized-feature-policy
特色機能は施策により生成元~用に可能化されるか？:~FEATUREPOLICY#is-feature-enabled
特色機能~施策~属性を処理する:~FEATUREPOLICY#process-feature-policy-attributes

内在的~横幅:~CSS2CONFORM#intrinsic
内在的~縦幅:~CSS2CONFORM#intrinsic
~CSS~pixel:~CSSVAL#px


●●words_table1


MATHML:https://www.w3.org/Math/draft-spec
svg-title:title


●●words_table



	●仕様（動詞
support::::サポート
	未~supportの:unsupported:~
上書き:override:~
不能化-:disable:~
可能化-:enable:~
可能化:enabled:~
	できるようにする:enable
抑制-:reduce:~
拘束:constraint:~
拘束-:constrain:~
検証:validation:~
指定-:specify:~
指示-:indicate:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
供-:provide:~
供せ:provide でき:~
提供-:offer:~
定義-:define:~
実装-:implement:~
適合-:conform:~
	適合しない:not 〜 conforming ／ non-conformant
専用:dedicated:~
尊守-:honor:~
	もたらす:introduce:~
強制-:force:~
影響-:affect:~
	従う:follow:~
制御:control:~
既存の:existing:~
期待-:expect:~
	利用-:use:~
	利用して:using
制約:restriction:~
制限-:limit:~
	則って:according:~
取扱える:handle できる:取り扱える
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
取扱われ:handle され:取り扱われ
取扱わ:handle し:取り扱わ
手渡す:hand する:~
決定-:determine:~
督促-:urge:~
確保-:ensure:~
統合:integration:~
統合-:integrate:~
要求-:require:~
	要-:require:~
見なさ:consider さ:~
見なし:consider し:~
	見よ:see:~
言及-:mention:~
試みた:attempt した:~
試行-:try:~
誤解釈-:misinterpret:~
述べる:describe する:~
述べた:describe した:~
適用-:apply:~
	適用-可能:applicable
	選り分ける:reason about
順守-:obey:~
	伝える:convey:~
依存-:depend:~
	優先される takes priority
	課す:impose する:~
	加えて:In addition:~
無視-:ignore:~
環境設定-:configure:~
防止-:prevent:~
防ぐ:prevent する:~
行使-:exercise:~
依頼-:ask:~
意図-:intend:~
受容-:accept:~
装う:pretend する:~
	必要:need:~
	扱う:treat:~
	~~述べる:say
	選べる:pick
	〜に基づいて:based
	できない:unable
	ままにされる:remain
	まま:remaining
	とする:suppose
	しないことを勧める:ill-advised
	覚えておく:remember
	~~発揮:take

	●仕様
UA:
API:
Web:
algo:algorithm:::アルゴリズム
app:application:::アプリ
browser::::ブラウザ
fall-back:fall back:::フォールバック
fallback::::フォールバック
proprietary::::プロプライエタリ
vendor::::ベンダ
model::::モデル
platform::::プラットフォーム

仕様:spec:~
一意:unique:~
一般:general:~
事例:case:~
互換:compatible:~
仕方:way:~
仕組み:mechanism:~
実質的:effective:~
	悩ましい:annoying:~
	いまいましいもの:annoyance
	-:manner
既定の:default:~
既定:default:~
旧来の:legacy:~
明示的:explicit:~
有用:useful:~
利用者:user:~
副作用:side-effect:~
効果:effect:~
単純:simple:~
厳格:strict:~
可用:available:~
下位手続き:substeps:~
手続き:steps:~
段:step:~
概して:typical に:~
注釈文:prose:~
特定0の:particular:ある特定の
特徴:characteristic:~
特有の:specific:~
特色機能:feature:~
	〜により制御される特色機能:-controlled-feature
目的:purpose:~
直に:direct に:~
	~~直に:immediate:~
相応しい:suitable な:~
省略可能:optional:~
簡素:succinct:~
能:ability:~
能力:capability:~
	能力を備え:capable
要件:requirements:~
通例の:usual:~
通常の:normal:~
適切:appropriate:~
選択肢:option:~
重要:important:~
作者:author:~
冗長:redundant:~
最低限:minimal:~
規則:rule:~
助け:help:~
局面:scenario:~
条件:condition:~
実際:actual:~
奨励-:encourage:~
意味論:semantics:~
特定的:specifical:具体的
波及-:influence:~

	●仕様（他
	~~定義済みの:well-defined
	決して:never:~
	例:example:~
	依然として／まだ:still:~
	十分:enough:~
	注意／:notice／note
	暗黙に:by implication
	困難:quite hard
	実の:real
	代わりに:instead
	あいにく:unfortunately
	しかしながら，:however
	べき:should
	よい:may
	更には、:furthermore
	でなくとも:despite
	になり得る:potentially
	無にする:altogether
	ようがされまいが:regardless of
	とにかく:anyway
	単に:just
	そこで:prematurely
	としていることもある:might say
	併用:in conjunction with
	よりも:compare:~
	~~比較的:relative:~
	因り:due:~
	可能:possible


	●network／navi
URL:
HTTP:
HTTPS:
DNS:
ok:
status::::ステータス
要請:request::~::リクエスト
応答:response::~::レスポンス

domain::::ドメイン
fetch::::
fetching::::fetch 処理
header::::ヘッダ
host::::ホスト
link::::リンク
metadata::::メタデータ
network::::ネットワーク
redirect::::リダイレクト
referrer::::リファラ
遠隔:remote::~::リモート
serve::::サービス供与
server::::サーバ
session::::セッション
site::::サイト
sniffing::::
url::::
address::::アドレス
cache::::キャッシュ
client::::クライアント
record::::レコード
path::::パス
本体:body:~
相対的:relative:~
素片:fragment::~::フラグメント
行先:destination:~
発行-:make:~

資源:resource::~:リソース
load:
読込み:load::読み込み::ロード
読込む:load する::読み込む::ロードする
読込まれ:load され::読み込まれ::ロードされ
読込め:load でき::読み込め::ロードでき
読込んだ:load した::読み込んだ::ロードした
読込済み:load 済み::読み込み済み::ロード済み
読込後:post load::読み込み後::ロード後
読込中:load in progress::読み込み中::ロード中
	進捗
読込黙秘中:load を mute::読み込み黙秘中::ロード黙秘中
	再度~読込む:reload::~::ロード
未読込みに:unload::未読み込みに::未ロードに
所在:location:~
navi::::ナビ
navigate::::ナビゲート
環境:environment:~
設定群:settings:~
source::::ソース
target::::ターゲット
頁:page:::ページ
top-level::::トップレベル
履歴:history::~
閲覧文脈:browsing context::~
補助:auxiliary::~
容器:container:::コンテナ
準備済み:ready::~
遅延-:delay:~

	●保安
CSP:
sandbox::::
	sandboxing::::
	sandbox化され:sandboxed
	sandbox化されない:unsandboxed
cross-site:
生成元:origin::~::オリジン
非同一生成元:cross-origin::~::クロスオリジン
同一生成元:same-origin::~::同一オリジン
保安:security::~::セキュリティ
保安化-:secure に::~:セキュア化
保護-:protect:~
保護:protection:~
信用-:trust:~
探査-:probe:~
脆弱:vulnerable:~
脆弱性:vulnerability:~
被害:damage:~
攻撃:attack:~
攻撃者:attacker:~
敵対的:hostile:~
検分-:examine:~
検査:check:~
訪問-:visit:~
許容-:allow:~
資格証:credential::資格証明情報::クレデンシャル
	~URL資格証~利用:use-URL-credential
騙され:trick され:~
起動-:initiate:~
軽減-:mitigate:~
危険性:danger:~
安全:safe:~
	晒される:expose
注入:injection:~
阻止-:block::阻止::ブロック
阻止ed:Blocked::阻止される::ブロックされる
突破-:break out:~
	~~軽くする:lift
指令:directive::~::ディレクティブ
malware::::マルウェア
先天的:a priori:~
施策:policy::~:ポリシー
仕向けれ:convince でき:~
仕向けて:convince して:~
是認-:grant:~

	●構文
ASCII:
DOCTYPE:
	QUOTATION MARK 
	AMPERSAND
	LESS-THAN SIGN
	CHARACTER TABULATION
	LINE FEED
	LF
	CARRIAGE RETURN
	CR
pop-off:pop off
大文字:uppercase:~
	uppercase letter
小文字:lowercase:~
文字:character:~
文字列:string:~
構文:syntax:~
構文単位:syntactic component:~
構文解析-:parse::~::パース
構文解析器:parser::~::パーサ
終了tag:end tag::終了 tag:終了タグ
開始tag:end tag::開始 tag:開始タグ
大小無視:case-insensitive:~
正規化:normalization:~
空白区切りの:space-separated:~
英大文字:upper alpha:~
省略不可:omissible でない:~
省略-:omit:~
省略:omission:~

合致-:match:~
終端-:end:~
HTML:
XML:
comment::::コメント
escape::::エスケープ
stack::::スタック
markup::::マークアップ
	-:tab
tag::::タグ
token::::トークン
引用符:quotes:~
ampersand::::アンパサンド
error::::エラー
keyword::::キーワード
literal::::リテラル
open::::
pattern::::パタン
空:empty:~
空白:whitespace:~
成分:component:~
妥当:valid:~
既知の:known:~
未知:unknown:~
失敗:failure:~
失敗-:fail:~
生の:raw:~
形:form:~
直列形の:serialized::~::シリアル形の

	●embed／UI／内容
Content-Type:
MIME:
型:type:~
Flash:
iframe:
iframe-srcdoc:iframe srcdoc
embed:
srcdoc:
flow::::フロー
text::::テキスト

click::::クリック
form::::フォーム
frame::::フレーム
popup::::ポップアップ
window::::ウィンドウ
control::::コントロール
dialog::::ダイアログ
map::::マップ
gadget::::ガジェット
再生器:player::~::プレイヤー

binary::::バイナリ
blog::::ブログ
media::::メディア
modal::::モーダル
screen::::スクリーン
plugin::::プラグイン
CSS:
pixel::::ピクセル
layout::::レイアウト

埋込み:embedding::~
埋込む:embed する::埋め込む
埋込まれ:embed され::埋め込まれ
埋込みの:embedded::埋め込みの
埋込んだ:embed した::埋め込んだ
埋込んで:embed して::埋め込んで
埋込もう:embed しよう::埋め込もう

作動中の:active な::~::アクティブな
作動中:active::~::アクティブ
作動化:activation::~::アクティブ化


分類:categories:~
分類-:categorize:~
	分類される falls into 〜 categories
対話的:interactive::~
提出-:submit::~
	提出-可能:submittable
透過的:transparent::~
句内容:phrasing content:phrasing 内容:~::フレージング内容
可触:palpable::~

広告:advertising:~
広告unit:ad unit:広告 unit::広告ユニット
形式:format:~
内容:content:~
動画:video:~
投稿:post:~
画像:image:~
	なし:none


視覚的:visual:~
横幅:width::~
縦幅:height::~
整数:integer:~
相違-:differ:~
解像度:resolution:~
距離:distance:~
内在的:intrinsic::~
online::::オンライン
service::::サービス
hint::::ヒント
伸張-:stretch:~
具現化:rendering:~


	●未分類
DOM:
MathML:
SVG:
先祖:ancestor:~
子:child:~
	子たち:children
子孫:descendant:~
文書:document:~
要素:element:~
要素間:inter-element:~
親:parent:~
同胞:sibling:~
木:tree::~::ツリー
node::::ノード

大域:global::~::グローバル
操作:manipulation:~
源:source::~::ソース
IDL:

発火-:fire:~
取得子:getter:~
event-loop:event loop:::イベントループ
event::::イベント
task::::タスク
instance::::インスタンス
	instance化:instantiate
interface::::インタフェース
method::::メソッド
obj:object:::オブジェクト

code::::コード
data::::データ
file::::ファイル
flag::::フラグ
	jump::::
list::::リスト
lock::::ロック
mode::::モード
pair::::ペア
parameter::::パラメタ
payment:::支払い
pointer::::ポインタ
代理-:proxy::~::プロキシ
script::::スクリプト
scripting::::スクリプト処理
	script可能な:scriptable
	全~screen化する:show fullscreen:~
	time::::
message::::メッセージ
tool::::ツール
	-:exception:~
真偽:boolean::~
属性:attribute:~
名前:name:~
名:name:~
値:value:~
名前空間:namespace:~
名前空間整形式の:namespace-well-formed:~

入力:input:~
出力:output:~
動的:dynamic:~
増分的:incremental:~
完全:complete:~
局所:local:~
層:layer:~
呈示:presentation:~
	再度／し直す:again
	同時:simultaneous
	対応:corresponding
成功裡:successful:~
文脈:context:~
方位:orientation:~
新たな:new:~
	newly
	-:tentative:~
寸法:dimension:~
横:horizontal:~
縦:vertical:~
状態:state:~
空間:space:~
等価:equivalent:~
	等し:equal:~
自動的:automatic:~
無順序:unordered:~
順序:order:~
集合:set:~
所有者:owner:~
名目上の:nominal:~
	~~不正な:malformed
代行業者:broker:~
	~iframe:fragment
	~~地点:point
	再度:re
	-:opt
	-:wherein
	-:straight
	-:leading
	-:followed by
	O3D
	GOTO:jump to the step below labeled
	-:name-value
	地図:map
	Geolocation
	`可能化される^i:"Enabled"

	●未分類（動詞
access::::アクセス
	~access可能:accessible
call:
export:
	再開-:restart:~
更新-:update:~
判別-:distinguish:~
算出-:compute:~
作成-:create:~
作成:creation:~
保全-:preserve:~
入子に:nest::入れ子に
入子の:nested::入れ子の
公開-:expose:~
処理-:process:~
処理:processing:~
初期:initial:~
初期化-:initialize:~
達-:reach:~
動作-:act:~
参照-:reference:~
可能化-:enable:~
	含-:include:~
呼出した:invoke した:呼び出した
呼出され:invoke され:呼び出され
被呼出時:被 invoke 時:~
在する:present する:在る
	presence
	有さない:absent:~

報告-:report:~
変化:change:~
変更-:change:~
包含-:contain:~
包装-:wrap:~
	始-:begin:~
	-:exist
完了-:complete:~
queue::::キュー
所有-:own:~
具現化-:render:~
	得-:obtain:~
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
表現-:represent:~
	見出す:find する:~
見出され:find され:~
見出した:find した:~
見出して:find して:~
見出せ:find でき:~
設定-:set:~
誘発-:trigger:~
走らす:run する:~
走らせ:run し:~
走る:run する:~
走って:run して:~
追加-:add:~
通信-:communicate:~
通知-:notify:~
選好:preference:~
選定-:select:~
開始-:start:~
除去-:remove:~
除外-:exclude:~
置換-:replace:~
置換:replacement:~
破棄-:discard:~
反映-:reflect:~
挿入-:insert:~
	送る:send:~
	起こる:happen:~
	返す:return:~
	現れ:appear:~
	渡-:pass:~
	生じ:occur:~
	示す:show:~
	終える:finish
	なった:become
	-:stopping
	~~供給-:furnish
	でなくなった:stop
	回数を数える:count
	読み取り:reading
	読み取り:reading
	見られ:view


	●指示語
外部:external:~
内側:inside:~
内縁:inner:~
出自の:originating:~
現在の:current:~
全部的:full:~
	所与の:given
	与-:give:~
	ある種の:certain
	~~追加の:extra
	この:this
	この時点で／今:now
	すべての:all
	その:that
	そのような:such
	それら:they
	それらの:those
	それらを:them
	これらの:these
	された:~mark
	すでに:already
	自身のみでは:on its own 
	また:once more
	-:aforementioned
	とも:together
	どちらかは:At least
	個の:one／four
	一部:part of
	上:above:~
	下:below:~
	両者:both:~
	二重に:doubly:~
	次:next:~
	異なる／相異なる:different:~
	他の:other:~
	他の場合:otherwise:~
	任意の:arbitrary:~
	何か:anything
	対象に:target
	何も〜しない:nothing
	全体:entire:~
	以前に:previously
	最後に:finally
	初めに:originally
	初回:first time
	別々の:separate
	別の:another
	前:before
	前の:previous
	常に:always
	後:after
	更なる:further
	最初の:first
	最後の:last
	様々な:various
	各:each
	同じ:same
	節:section
	結果:result
	結果の:resulting
	自身:itself
	複数の:multiple
	超えて:beyond
	similar
	similarly
	他所へ:away
	1 列目
	以外
	以上
	一方
	次第
	時点
	場合


●●html_code_list



■iframe-1
<article>
 <h1>自分の雑誌ができた</h1>
 <p>頑張った甲斐あって、版元を見つけられた。ついに自分の雑誌を持てるようになった。最高だ！最初の号は９月になるよ。フードをゲットしたりボックスの中を見て回ることについての記事だ。楽しみだよ。</p>
 <footer>
  <p><a href="/users/cap">cap</a> さん（投稿： 1 時間前）
 </footer>
 <article>
  <footer> 13 分前, <a href="/users/ch">ch</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>表紙絵はできた？"></iframe>＞
 </article>
 <article>
  <footer> 9 分前, <a href="/users/cap">cap</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>もちろん、<a href=&quot;/gallery?mode=cover&amp;amp;page=1&quot;>僕のギャラリー</a>で見れるよ。"></iframe>＞
 </article>
 <article>
  <footer> 5 分前, <a href="/users/ch">ch</a> さん</footer>
  ＜<iframe sandbox srcdoc="<p>それ、 earl の食卓だな。
<p>次の表紙絵には earl&amp;amp;me を入れないとな。"></iframe>＞
 </article>

<article>
 <h1>I got my own magazine!</h1>
 <p>After much effort, I've finally found a publisher, and so now I
 have my own magazine! Isn't that awesome?! The first issue will come
 out in September, and we have articles about getting food, and about
 getting in boxes, it's going to be great!</p>
 <footer>
  <p>Written by <a href="/users/cap">cap</a>, 1 hour ago.
 </footer>
 <article>
  <footer> Thirteen minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>did you get a cover picture yet?"></iframe>
 </article>
 <article>
  <footer> Nine minutes ago, <a href="/users/cap">cap</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>Yeah, you can see it <a href=&quot;/gallery?mode=cover&amp;amp;page=1&quot;>in my gallery</a>."></iframe>
 </article>
 <article>
  <footer> Five minutes ago, <a href="/users/ch">ch</a> wrote: </footer>
  <iframe sandbox srcdoc="<p>hey that's earl's table.
<p>you should get earl&amp;amp;me on the next cover."></iframe>
 </article>

	'

■iframe-2
<p>どんな内容だろうが恐るるに足らない。何も編集を加えていない投稿内容はここにある：</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>

<p>We're not scared of you! Here is your content, unedited:</p>
<iframe sandbox src="https://usercontent.example.net/getusercontent.cgi?id=12193"></iframe>

'

■iframe-3
<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">私的投稿</a></p>
 </header>
 <p>Check out my new ride!</p>
 ＜<iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>＞
</article>

<article>
 <header>
  <p><img src="/usericons/1627591962735"> <b>Fred Flintstone</b></p>
  <p><a href="/posts/3095182851" rel=bookmark>12:44</a> — <a href="#acl-3095182851">Private Post</a></p>
 </header>
 <main>
  <p>Check out my new ride!</p>
  <iframe src="https://video.example.com/embed?id=92469812" allowfullscreen></iframe>
 </main>
</article>

■iframe-4
<iframe src="https://ads.example.com/?customerid=923513721&amp;format=banner"
        width="468" height="60"></iframe>

■embed-1
<embed src="catgame.swf">

■embed-2
<embed src="catgame.swf" quality="high">

■embed-3
<object data="catgame.swf">
 <param name="quality" value="high">
</object>

■param-1
<!DOCTYPE HTML>
<html lang="ja">
  <head>
   <title>O3D ユタティーポット</title>
  </head>
  <body>
   <p>
    <object type="application/vnd.o3d.auto">
     ＜<param name="o3d_features" value="FloatingPointTextures">＞
     <img src="o3d-teapot.png"
          title="O3D を利用して描画された 3D ユタティーポット"
          alt="O3D で描画されるユタティーポットは、周囲の光を反射する金属光沢と光源によるおぼろげな影を伴うように現れる。">
     <p>実際に O3D で描画されるユタティーポットを見るためには、<a href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install">O3D プラグイン</a>をダウンロードしてインストールする必要があります。</p>
    </object>
    <％script src="o3d-teapot.js"></％script>
   </p>
  </body>
</html>

<!DOCTYPE HTML>
<html lang="en">
  <head>
   <title>O3D Utah Teapot</title>
  </head>
  <body>
   <p>
    <object type="application/vnd.o3d.auto">
     <param name="o3d_features" value="FloatingPointTextures">
     <img src="o3d-teapot.png"
          title="3D Utah Teapot illustration rendered using O3D."
          alt="When O3D renders the Utah Teapot, it appears as a squat
          teapot with a shiny metallic finish on which the
          surroundings are reflected, with a faint shadow caused by
          the lighting.">
     <p>To see the teapot actually rendered by O3D on your
     computer, please download and install the <a
     href="http://code.google.com/apis/o3d/docs/gettingstarted.html#install">O3D plugin</a>.</p>
    </object>
    <％script src="o3d-teapot.js"></％script>
   </p>
  </body>
</html>

■object-2
<figure>
 <object data="clock.html"></object>
 <figcaption>自作 HTML 時計</figcaption>
</figure>

 <figcaption>My HTML Clock</figcaption>

■object-3
<p>動画に注目：
 <object type="application/x-shockwave-flash">
  <param name=movie value="https://video.example.com/library/watch.swf">
  <param name=allowfullscreen value=true>
  <param name=flashvars value="https://video.example.com/vids/315981">
  <video controls src="https://video.example.com/vids/315981">
   <a href="https://video.example.com/vids/315981">動画を見る</a>
  </video>
 </object>
</p>

<p>Look at my video:
   <a href="https://video.example.com/vids/315981">View video</a>.

■mathml-1
<!DOCTYPE html>
<html lang="en">
 <head>
  <title>二次方程式の解の公式</title>
 </head>
 <body>
  <h1>二次方程式の解の公式</h1>
  <p>
   <math>
    <mi>x</mi>
    <mo>=</mo>
    <mfrac>
     <mrow>
      <mo form="prefix">−</mo> <mi>b</mi>
      <mo>±</mo>
      <msqrt>
       <msup> <mi>b</mi> <mn>2</mn> </msup>
       <mo>−</mo>
       <mn>4</mn> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mi>c</mi>
      </msqrt>
     </mrow>
     <mrow>
      <mn>2</mn> <mo>⁢</mo> <mi>a</mi>
     </mrow>
    </mfrac>
   </math>
  </p>
 </body>
</html>

The quadratic formula


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる HTML 仕様の
<a href="~HTMLLS/#toc-semantics">The elements of HTML</a>
章の
<a href="~SPEC_URL">iframe, embed, object 要素</a>
節,
<a href="~HTMLLS/embedded-content-other.html">その他の埋め込み内容に関係する節</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


</head>
<body>


<header id="head">
	<hgroup>
<h1>iframe, embed, object 要素 他（埋め込みの内容 — Embedded content ）</h1>
	</hgroup>

</header>

<main id="MAIN" style="display:none;">

			<section id="_conventions">
<h3>【この訳に固有の表記規約】</h3>

<p>
この訳の，~algoの記述に利用されている各種記号（ε, 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="the-iframe-element">
<h3 title="The iframe element">4.8.5. `iframe^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$／`句内容$／`埋込みの内容$／`対話的~内容$／`可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込みの内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aF
— 埋込む資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`srcdoc$aF
— `iframe$e 内に具現化する文書
◎
srcdoc — A document to render in the iframe
</dd>
	<dd>
`name$aF
— `入子にしている閲覧文脈$の名前
◎
name — Name of nested browsing context
</dd>
	<dd>
`sandbox$aF
— 入子にされる内容に対する保安~規則
◎
sandbox — Security rules for nested content
</dd>
	<dd>
`allow$aF
— `iframe$e の内容に適用されることになる`特色機能~施策$
◎
allow — Feature policy to be applied to the iframe's contents
</dd>
	<dd>
`allowfullscreen$aF
— `iframe$e の内容が `requestFullscreen()$m を利用するのを許容するかどうか
◎
allowfullscreen — Whether to allow the iframe's contents to use requestFullscreen()
</dd>
	<dd>
`allowpaymentrequest$aF
—
`iframe$e の内容が `PaymentRequest$I ~interfaceを利用して，~payment要請を発行するのを許容するかどうか
◎
allowpaymentrequest — Whether the iframe's contents are allowed to use the PaymentRequest interface to make payment requests
</dd>
	<dd>
`allowusermedia$aF
— `iframe$e の内容が `getUserMedia()$m を利用するのを許容するかどうか
◎
allowusermedia — Whether to allow the iframe's contents to use getUserMedia()
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
`referrerpolicy$aF
— この要素により起動された`~fetch$用の`~referrer施策$
◎
referrerpolicy — Referrer policy for fetches initiated by the element
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>

<pre class="idl">
[Exposed=Window,
 `HTMLConstructor$]
interface `HTMLIFrameElement@I : `HTMLElement$I {
  [`CEReactions$] attribute USVString `src$mF;
  [`CEReactions$] attribute DOMString `srcdoc$mF;
  [`CEReactions$] attribute DOMString `name$mF;
  [SameObject, PutForwards=`value$m] readonly attribute `DOMTokenList$I `sandbox$mF;
  [`CEReactions$] attribute DOMString `allow$mF;
  [`CEReactions$] attribute boolean `allowFullscreen$mF;
  [`CEReactions$] attribute boolean `allowPaymentRequest$mF;
  [`CEReactions$] attribute boolean `allowUserMedia$mF;
  [`CEReactions$] attribute DOMString `width$m;
  [`CEReactions$] attribute DOMString `height$m;
  [`CEReactions$] attribute DOMString `referrerPolicy$mF;
  readonly attribute `Document$I? `contentDocument$mF;
  readonly attribute `WindowProxy$I? `contentWindow$mF;
  `Document$I? `getSVGDocument$m();
};
</pre>

	</dd>
</dl>

<p>
`iframe$e 要素は、自身が`入子にしている閲覧文脈$を`表現-$する。
◎
The iframe element represents a nested browsing context.
</p>

<p>
`src@aF
属性は、`入子の閲覧文脈$が包含することになる頁の`~URL$を与える。
この属性が在する場合の値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
`iframe$e 要素が `itemprop$a 属性を有する場合、この属性も有してい~MUST。
◎
The src attribute gives the URL of a page that the nested browsing context is to contain. The attribute, if present, must be a valid non-empty URL potentially surrounded by spaces. If the itemprop attribute is specified on an iframe element, then the src attribute must also be specified.
</p>

<p>
`srcdoc@aF
属性は、`入子の閲覧文脈$が包含することになる内容を与える。
この属性の値が
`~iframe-srcdoc文書@
の~sourceを与える。
◎
The srcdoc attribute gives the content of the page that the nested browsing context is to contain. The value of the attribute is the source of an iframe srcdoc document.
</p>

<p>
`srcdoc$aF 属性に指定する値は、次に与える順による構文単位からなる`~HTML構文$を利用する値にされ~MUST：
◎
The srcdoc attribute, if present, must have a value using the HTML syntax that consists of the following syntactic components, in the given order:
</p>

<ol>
	<li>
任意~個数の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
	<li>
0 〜 1 個の `~DOCTYPE$
◎
Optionally, a DOCTYPE.
</li>
	<li>
任意~個数の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
	<li>
`html$e `要素$synの形による`文書~要素$
◎
The document element, in the form of an html element.
</li>
	<li>
任意~個数の［
`~comment$syn, `~ASCII空白$
］
◎
Any number of comments and ASCII whitespace.
</li>
</ol>

<p class="note">注記：
上の要件は、`~XML文書$にも適用される。
◎
The above requirements apply in XML documents as well.
</p>


<div class="example">

<p>
次の~blogでは、
`srcdoc$aF, 下に述べる `sandbox$aF
両~属性を併用して，この特色機能を~supportする~UAの利用者に［
~blog投稿~commentによる~script注入から保護する~~追加の層
］を伴わせて供している：
◎
Here a blog uses the srcdoc attribute in conjunction with the sandbox attribute described below to provide users of user agents that support this feature with an extra layer of protection from script injection in the blog post comments:
</p>

`iframe-1^xCode

<p>
引用符は~escapeされる必要があることに加え（さもなければ、 `srcdoc$aF 属性は そこで終端してしまう）、~sandbox化された内容（例：~URLや注釈文~内）における生の~ampersand（ `&amp;^l ）は，<em>二重に</em>~escapeされる必要があることにも注意
— `srcdoc$aF 属性が初めに構文解析されるときに ~ampersandが保全され，その後 ~sandbox化された内容がまた構文解析されるときにも ~ampersandが誤解釈されるのを防ぐため。
◎
Notice the way that quotes have to be escaped (otherwise the srcdoc attribute would end prematurely), and the way raw ampersands (e.g. in URLs or in prose) mentioned in the sandboxed content have to be doubly escaped — once so that the ampersand is preserved when originally parsing the srcdoc attribute, and once more to prevent the ampersand from being misinterpreted when parsing the sandboxed content.
</p>

<p>
更には，
`srcdoc$aF 属性~内の~markupは、文書~全体を表現しているにもかかわらず，~~比較的 簡素にできることにも注意
— ［
`html$e, `head$e, `body$e
］要素の
<a href="~HTMLwriting#syntax-tag-omission">開始tag／終了tagは省略可能</a>
であり（省略されても，依然として暗黙に在する），
`~iframe-srcdoc文書$においては［
`~DOCTYPE$ ／ `title$e 要素
］も省略可能なので、構文~内に~literalに現れる必要があるのは， `body$e 要素の内容のみになるので。
◎
Furthermore, notice that since the DOCTYPE is optional in iframe srcdoc documents, and the html, head, and body elements have optional start and end tags, and the title element is also optional in iframe srcdoc documents, the markup in a srcdoc attribute can be relatively succinct despite representing an entire document, since only the contents of the body element need appear literally in the syntax. The other elements are still present, but only by implication.
</p>

</div>

<div class="note">
<p>注記：
`~HTML構文$においては、作者が覚えておく必要があるのは，次の点に限られる：
</p>

<ul ><li>文字 `0022^U `"^smb を利用して，属性の内容を包装する。
</li><li>次に、文字 `0026^U `&amp;^smb をすべて~escapeしてから，文字 `0022^U `"^smb をすべて~escapeする（逆順に行うと、引用符は二重に~escapeされ， `&amp;quot;^l から `&amp;amp;quot;^l になってしまう）。
</li><li>`sandbox$aF 属性を指定して、内容の安全な埋込みを確保する。
</li></ul>

◎
In the HTML syntax, authors need only remember to use U+0022 QUOTATION MARK characters (") to wrap the attribute contents and then to escape all U+0026 AMPERSAND (&amp;) and U+0022 QUOTATION MARK (") characters, and to specify the sandbox attribute, to ensure safe embedding of content. (And remember to escape ampersands before quotation marks, to ensure quotation marks become &amp;quot; and not &amp;amp;quot;.)
</div>


 <p class="note">注記：
~XMLにおいては、`属性~値の正規化$を防止するため，
`003C^U `&lt;^smb
も~escapeされる必要がある。
~XMLの一部の空白~文字，
 — 特定的には
`0009^U CHARACTER TABULATION（ tab ）,
`000A^U LINE FEED（ LF ）,
`000D^U  CARRIAGE RETURN（ CR ）
—
も~escapeされる必要がある。
`XML$r
◎
In XML the U+003C LESS-THAN SIGN character (&lt;) needs to be escaped as well. In order to prevent attribute-value normalization, some of XML's whitespace characters — specifically U+0009 CHARACTER TABULATION (tab), U+000A LINE FEED (LF), and U+000D CARRIAGE RETURN (CR) — also need to be escaped. [XML]
</p>

<p class="note">注記：
`src$aF, `srcdoc$aF
両~属性とも指定された場合、 `srcdoc$aF 属性が優先される。
これにより，作者は、 `srcdoc$aF 属性を~supportしない旧来の~UA用に~fallback `~URL$を供せるようになる。
◎
If the src attribute and the srcdoc attribute are both specified together, the srcdoc attribute takes priority. This allows authors to provide a fallback URL for legacy user agents that do not support the srcdoc attribute.
</p>

<hr>

<p>
`iframe$e 要素 %iframe が`文書の中へ挿入され$たときは、［
文書が`属する閲覧文脈$ ~NEQ ε
］ならば，~UAは次を走らせ~MUST：
◎
When an iframe element is inserted into a document that has a browsing context, the user agent must＼
</p>

<ol>
	<li>
%B ~LET `新たな閲覧文脈を作成する$()
◎
create a new browsing context,＼
</li>
	<li>
%iframe が`入子にしている閲覧文脈$ ~SET %B
◎
set the element's nested browsing context to the newly-created browsing context, and then＼
</li>
	<li>
`~iframeの属性を処理する$( %iframe, `初回^i )
◎
process the iframe attributes for the "first time".
</li>
</ol>

<p>
`iframe$e 要素 %iframe が`入子にしている閲覧文脈$ %B ~NEQ ~NULL
の下では、~UAは，次に従わ~MUST：
◎
↓</p>

<ul>
	<li>
<p>
%iframe が`文書から除去され$たときは
⇒＃
`閲覧文脈を破棄する$( %B )；
%iframe が`入子にしている閲覧文脈$ ~SET ~NULL
◎
When an iframe element is removed from a document, the user agent must discard the element's nested browsing context, if it is not null, and then set the element's nested browsing context to null.
</p>

<p class="note">注記：
これは、 `unload$et ~eventは発火されずに起こる（`入子の閲覧文脈$は それに属する`文書$とともに<em>`破棄され$</em>, <em>`未読込みにされ$ない</em>）。
◎
This happens without any unload events firing (the nested browsing context and its Document are discarded, not unloaded).
</p>
	</li>
	<li>
%iframe の `srcdoc$aF 属性が［
設定- ／ 変更- ／ 除去-
］されたときは
⇒
`~iframeの属性を処理する$( %iframe )
◎
Whenever an iframe element with a non-null nested browsing context has its srcdoc attribute set, changed, or removed, the user agent must process the iframe attributes.
</li>
	<li>
%iframe の `src$aF 属性が［
設定- ／ 変更- ／ 除去-
］されたときは
⇒
~IF［
%iframe は `srcdoc$aF 属性を有していない
］
⇒
`~iframeの属性を処理する$( %iframe )
◎
Similarly, whenever an iframe element with a non-null nested browsing context but with no srcdoc attribute specified has its src attribute set, changed, or removed, the user agent must process the iframe attributes.
</li>
</ul>


<p class="algo-head">
~UAは，
`~iframeの属性を処理する@
ときは、所与の
( `iframe$e 要素 %iframe, %初回~flag ~IN { `初回^i, ε }（省略時は ε ） )
に対し，次を走らせ~MUST：
◎
When the user agent is to process the iframe attributes, it must run the first appropriate steps from the following list:
</p>

<ol>
	<li>
%B ~LET %iframe が`入子にしている閲覧文脈$
◎
↓</li>
	<li>
<div class="p">
<p>
~IF［
%iframe は `srcdoc$aF 属性を有する
］：
</p>
		<ol>
			<li>
%応答 ~LET 次のようにされた新たな`応答$
⇒＃
`~url~list$rs ~SET `about_srcdoc$sc のみからなる~list,
`~header~list$rs ~SET ( `Content-Type^h / `text/html$mt ) のみからなる~list,
`本体$rs ~SET その属性~値,
`~CSP~list$rs ~SET %iframe の`~node文書$の`~CSP~list$doc,
`~HTTPS状態$rs ~SET %iframe の`~node文書$の`~HTTPS状態$doc
</li>
			<li>
%B を %応答 へ`~navigate$する
</li>
			<li>
~RET
</li>
		</ol>

◎
If the srcdoc attribute is specified
◎
Navigate the element's nested browsing context to a new response whose url list consists of about:srcdoc, header list consists of `Content-Type`/`text/html, body is the value of the attribute, CSP list is the CSP list of the iframe element's node document, HTTPS state is the HTTPS state of the iframe element's node document.
</div>

<p>
上による結果の`文書$は、`~iframe-srcdoc文書$と見なされ~MUST。
◎
The resulting Document must be considered an iframe srcdoc document.
</p>
	</li>
	<li>
~IF［
%iframe は `src$aF 属性を有さない
］~AND［
%初回~flag ~NEQ ε
］
⇒
`~DOM操作~task源$から，次を走らす`~taskを~queueする$
⇒
`~iframe~load~event手続き$
◎
Otherwise, if the element has no src attribute specified, and the user agent is processing the iframe's attributes for the "first time"
◎
Queue a task to run the iframe load event steps.
◎
The task source for this task is the DOM manipulation task source.
</li>
	<li>
<p>
~ELSE：
◎
Otherwise
◎
Run the otherwise steps for iframe or frame elements.
◎
The otherwise steps for iframe or frame elements are as follows:
</p>
		<ol>
			<li>
%~url ~LET `~URL$ `about_blank$sc
◎
↓</li>
			<li>
<p>
~IF［
%iframe は `src$aF 属性を有する
］~AND［
その値 %src ~NEQ 空~文字列
］：
</p>
				<ol>
					<li>
%src ~SET %src を %iframe の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
</li>
					<li>
~IF［
%src ~NEQ ~error
］
⇒
%~url ~SET %src
</li>
		</ol>
◎
If the element has no src attribute specified, or its value is the empty string, let url be the URL "about:blank".
◎
Otherwise, parse the value of the src attribute, relative to the element's node document.
◎
If that is not successful, then let url be the URL "about:blank". Otherwise, let url be the resulting URL record.
</li>
			<li>
~IF［
%B のある`先祖~閲覧文脈$にて`作動中の文書$の`~URL$docは，`素片$urlは無視して %~url に等しい【`同等$url？】
］
⇒
~RET
◎
If there exists an ancestor browsing context whose active document's URL, ignoring fragments, is equal to url, then return.
</li>
			<li>
%資源 ~LET 次のようにされた新たな`要請$
⇒＃
`~url$rq ~SET %~url,
`~referrer施策$rq ~SET %iframe の `referrerpolicy$aF 内容~属性の現在の状態
◎
Let resource be a new request whose url is url and whose referrer policy is the current state of the element's referrerpolicy content attribute.
</li>
			<li>
%B を %資源 へ`~navigate$する
◎
Navigate the element's nested browsing context to resource.
</li>
		</ol>

<p class="trans-note">【
この一連の段は，原文では
<dfn id="otherwise-steps-for-iframe-or-frame-elements">iframe または frame 要素に対する他の場合の手続き</dfn>
として別に定義されているが（すなわち， `frame^e 要素からも利用されると見受けられる）、この訳では，この手続きに統合することにする（廃用にされた `frame^e 要素を和訳するつもりはないので）。
】</p>
	</li>
</ol>


<p>
［
`iframe$e 要素 %iframe を与える下で，`~iframeの属性を処理する$
］ときに，~UAに要求される`~navi$においては：
◎
Any navigation required of the user agent in the process the iframe attributes algorithm＼
</p>

<ul>
	<li>
`~source閲覧文脈$として，
%iframe の`~node文書$が`属する閲覧文脈$を利用し~MUST。
◎
must use the iframe element's node document's browsing context as the source browsing context.
</li>
	<li>
<p>
加えて，  %iframe が`入子にしている閲覧文脈$ %B について 次のいずれかが満たされる場合、`~navi$は［
`置換~可能化~flag$ ~SET ~ON
］の下で完了され~MUST：
◎
↓</p>
		<ul>
			<li>
`~navi$の時点では、
%B にて`作動中の文書$は`完全に読込済み$でなかった
◎
Furthermore, if the active document of the element's nested browsing context before such a navigation was not completely loaded at the time of the new navigation, then the navigation must be completed with replacement enabled.
</li>
			<li>
`~iframeの属性を処理する$~algoが呼出された時点では、
%B の`~session履歴$は［
%B の作成-時に作成された `about_blank$sc `文書$
］のみを包含していた
◎
Similarly, if the nested browsing context's session history contained only one Document when the process the iframe attributes algorithm was invoked, and that was the about:blank Document created when the nested browsing context was created, then any navigation required of the user agent in that algorithm must be completed with replacement enabled.
</li>
		</ul>
	</li>
</ul>

<p>
`iframe$e 内の`文書$が`完全に読込済み$とされた時点で、~UAは，`~iframe~load~event手続き$を走らせ~MUST。
◎
When a Document in an iframe is marked as completely loaded, the user agent must run the iframe load event steps.
</p>

<p class="note">注記：
`iframe$e 要素の作成-時には、その中へ読込まれる他の~dataはない場合には，
要素に向けて `load$et ~eventも発火される。
◎
A load event is also fired at the iframe element when it is created if no other data is loaded in it.
</p>

<p>
各 `文書$は
`~iframe読込中~flag@,
`~iframe読込黙秘中~flag@
を持つ
— いずれも，`文書$の作成-時には ~OFF にされ~MUST。
◎
Each Document has an iframe load in progress flag and a mute iframe load flag. When a Document is created, these flags must be unset for that Document.
</p>

<p class="algo-head">
`~iframe~load~event手続き@
は、所与の `iframe$e 要素 %iframe に対し，次を走らす：
◎
The iframe load event steps are as follows:
</p>

<ol>
	<li>
%子~文書 ~LET %iframe が`入子にしている閲覧文脈$にて`作動中の文書$
（この時点では~NULLになり得ない。）
◎
Let child document be the active document of the iframe element's nested browsing context (which cannot be null at this point).
</li>
	<li>
~IF［
%子~文書 の
`~iframe読込黙秘中~flag$ ~EQ ~ON
］
⇒
~RET
◎
If child document has its mute iframe load flag set, return.
</li>
	<li>
%子~文書 の`~iframe読込中~flag$ ~SET ~ON
◎
Set child document's iframe load in progress flag.
</li>
	<li>
%iframe に向けて，名前 `load$et の`~eventを発火する$
◎
Fire an event named load at the iframe element.
</li>
	<li>
%子~文書 の`~iframe読込中~flag$ ~SET ~OFF
◎
Unset child document's iframe load in progress flag.
</li>
</ol>

<p class="warning">
これを~scriptingと併用すれば、局所~networkの~HTTP~serverの~URL空間を探査する攻撃にも利用できる。
~UAは、これを軽減するため，上に述べたものより厳格な［
`非同一生成元$に対する~access制御~用の施策
］を実装してよい
— が，あいにく そのような施策は、概して，既存の~Web内容と互換にならない。
◎
This, in conjunction with scripting, can be used to probe the URL space of the local network's HTTP servers. User agents may implement cross-origin access control policies that are stricter than those described above to mitigate this attack, but unfortunately such policies are typically not compatible with existing Web content.
</p>

<div >
<p>
`iframe$e 要素が`入子にしている閲覧文脈$ %B （~NEQ ~NULL ）にて`作動中の文書$ %文書 に対し，次のいずれかが満たされている間は、要素は %文書 の`~load~eventを遅延-$し~MUST：
</p>

<ul><li>%文書 の`読込後~taskは準備済み$でない
</li><li>要素 内の何かが， %文書 の`~load~eventを遅延-$している
</li><li>%B は`~load~event遅延-中~mode$下にある
</li></ul>

◎
When the iframe's browsing context's active document is not ready for post-load tasks, and when anything in the iframe is delaying the load event of the iframe's browsing context's active document, and when the iframe's browsing context is in the delaying load events mode, the iframe must delay the load event of its document.
</div>

<p class="note">注記：
`load$et ~eventの取扱い中に %B が再度`~navigate$された場合、それにより更に`~load~eventを遅延-$することになる。
◎
If, during the handling of the load event, the browsing context in the iframe is again navigated, that will further delay the load event.
</p>


<p class="note">注記：
%iframe の作成-時に，［
`srcdoc$aF 属性を有してなかった
］~AND［
`src$aF 属性を有してなかったか, 有していたが その値を`相対的に構文解析-$できなかった
］場合、 %B は，初期 `about_blank$sc 頁のままにされることになる。
◎
If, when the element is created, the srcdoc attribute is not set, and the src attribute is either also not set or set but its value cannot be parsed, the browsing context will remain at the initial about:blank page.
</p>

<p class="note">注記：
利用者がこの頁から他所へ`~navigate$した場合、
%B の `WindowProxy$I ~objは，新たな`文書$~用の新たな `Window$I ~objを代理することになるが、
%iframe の `src$aF 属性は変更されない。
◎
If the user navigates away from this page, the iframe's corresponding WindowProxy object will proxy new Window objects for new Document objects, but the src attribute will not change.
</p>

<hr>

<p>
`name@aF
属性は、在するならば，
`iframe$e 要素 %iframe が`入子にしている閲覧文脈$ %B に名前を与えるために利用される。
この属性に指定する値は、`妥当な閲覧文脈~名$で~MUST。
%B の`閲覧文脈~名$は：
◎
The name attribute, if present, must be a valid browsing context name. The given value is used to name the nested browsing context.＼
</p>

<ul>
	<li>
%B の作成-時には、
%iframe がこの属性を［
有するならば その値 ／
有さないならば 空~文字列
］に設定され~MUST。
◎
When the browsing context is created, if the attribute is present, the browsing context name must be set to the value of this attribute; otherwise, the browsing context name must be set to the empty string.
</li>
	<li>
%iframe にこの属性が設定されたときは、その新たな値に変更され~MUST。
◎
Whenever the name attribute is set, the nested browsing context's name must be changed to the new value.＼
</li>
	<li>
%iframe からこの属性が除去されたときは、空~文字列に設定され~MUST。
◎
If the attribute is removed, the browsing context name must be set to the empty string.
</li>
</ul>


<hr>

<p>
`iframe$e 要素に
`sandbox@aF
属性が指定された場合、要素が~hostする内容に対し，~~追加の制約の集合を可能化する。
指定する値は、［
`~ASCII大小無視$の下で，`空白区切りの一意な~tokenからなる無順序~集合$
］で~MUST。
下の表の 1 列目に挙げる~keyword値が~tokenとして許容される。
◎
The sandbox attribute, when specified, enables a set of extra restrictions on any content hosted by the iframe. Its value must be an unordered set of unique space-separated tokens that are ASCII case-insensitive. The allowed values are allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-popups-to-escape-sandbox, allow-presentation, allow-same-origin, allow-scripts, allow-top-navigation, and allow-top-navigation-by-user-activation.
</p>

<p>
この属性が設定された下では、要素により埋込まれる内容は，一意な`生成元$に属するものと扱われ、それにより，［
~form, ~script, 様々な悩ましいものになり得る~API
］は不能化され,
~linkに対しては 他の`閲覧文脈$を~targetにすることは防止され,
~pluginは保安化される。
加えて，各種~keywordには、これらの制約の一部を緩めるような次の効果がある：
◎
When the attribute is set, the content is treated as being from a unique origin, forms, scripts, and various potentially annoying APIs are disabled, links are prevented from targeting other browsing contexts, and plugins are secured.＼
</p>

<div>

<table>
<caption>`sandbox$aF 属性に指定できる~keywordとその効果</caption>
<thead><tr><th>~keyword
<td>効果
</thead>

<tbody>
<tr><td>`allow-same-origin$v
<td>内容を一意な生成元の中に強制する代わりに，その実の生成元に属するものと扱われるようにする

<tr><td>`allow-top-navigation$v
<td>内容が その`~top-level閲覧文脈$を`~navigate$できるようにする

<tr><td>`allow-top-navigation-by-user-activation$v
<td>`allow-top-navigation$v と同様に挙動するが、そのような`~navi$を
`利用者による作動化により誘発され$るときに限り，許容する

<tr><td>`allow-forms$v
<td>~formを可能化する

<tr><td>`allow-modals$v
<td>~modal~dialogを可能化する

<tr><td>`allow-orientation-lock$v
<td>~screen方位~lockを可能化する
`SCREENORIENTATION$r

<tr><td>`allow-pointer-lock$v
<td>~pointer~lock~APIを可能化する
`POINTERLOCK$r

<tr><td>`allow-popups$v
<td>~popupを可能化する

<tr><td>`allow-presentation$v
<td>呈示~APIを可能化する
`PRESENTATION$r

<tr><td>`allow-scripts$v
<td>~scriptを可能化する

<tr><td>`allow-popups-to-escape-sandbox$v
<td>~sandbox化されない`補助~閲覧文脈$の作成を可能化する

</tbody></table>


◎
The allow-same-origin keyword causes the content to be treated as being from its real origin instead of forcing it into a unique origin; the allow-top-navigation keyword allows the content to navigate its top-level browsing context; the allow-top-navigation-by-user-activation keyword behaves similarly but only allows such navigation when triggered by user activation; and the allow-forms, allow-modals, allow-orientation-lock, allow-pointer-lock, allow-popups, allow-presentation, allow-scripts, and allow-popups-to-escape-sandbox keywords re-enable forms, modal dialogs, screen orientation lock, the pointer lock API, popups, the presentation API, scripts, and the creation of unsandboxed auxiliary browsing contexts respectively. [POINTERLOCK] [SCREENORIENTATION] [PRESENTATION]
</div>

<p>
`allow-top-navigation$v,
`allow-top-navigation-by-user-activation$v
両~keywordとも指定されては~MUST_NOT
— そうすることは冗長なので。
そのような適合しない~markupにおいては、 `allow-top-navigation$v のみ効果がある。
◎
The allow-top-navigation and allow-top-navigation-by-user-activation keywords must not both be specified, as doing so is redundant; only allow-top-navigation will have an effect in such non-conformant markup.
</p>

<p class="warning">
`allow-scripts$v, `allow-same-origin$v
両~keywordとも設定することは、［
埋込まれた頁と それを包含している `iframe$e とが`同一生成元$に属する
］ときには，［［
埋込まれた頁が単純に `sandbox$aF 属性を除去して，自身を再度~読込む
］ことにより，実質的に~sandboxを突破して無にする
］ことを許容することになる。
◎
Setting both the allow-scripts and allow-same-origin keywords together when the embedded page has the same origin as the page containing the iframe allows the embedded page to simply remove the sandbox attribute and then reload itself, effectively breaking out of the sandbox altogether.
</p>

<p class="warning">
これらの~flagが効果を~~発揮するのは、 `iframe$e が`入子にしている閲覧文脈$が`~navigate$されるときに限られる。
すでに読込まれた頁に対しては、それらの一部を除去しようが `sandbox$aF 属性まるごと除去しようが，効果はない。
◎
These flags only take effect when the nested browsing context of the iframe is navigated. Removing them, or removing the entire sandbox attribute, has no effect on an already-loaded page.
</p>

<p class="warning">
`iframe$e 要素を包含している~fileと同じ~serverは、敵対的になり得る~fileを~serveするべきでない。
敵対的な内容を~sandbox化することは、攻撃者が，［
`iframe$e 内ではなく，敵対的な内容へ直に訪問する
］よう利用者を仕向けれる場合のためにある、最低限の助けでしかない。
敵対的な~HTML内容がもたらし得る被害を制限するには、別々の専用~domainから~serveするべきである。
異なる~domainを利用すれば、利用者が `sandbox$aF 属性の保護なしに，そのような頁へ直に訪問するよう騙された場合でも，~file内の~scriptは~siteを攻撃できないことが確保される。
◎
Potentially hostile files should not be served from the same server as the file containing the iframe element. Sandboxing hostile content is of minimal help if an attacker can convince the user to just visit the hostile content directly, rather than in the iframe. To limit the damage that can be caused by hostile HTML content, it should be served from a separate dedicated domain. Using a different domain ensures that scripts in the files are unable to attack the site, even if the user is tricked into visiting those pages directly, without the protection of the sandbox attribute.
</p>

<div >
<p>
`iframe$e 要素 %iframe において，次のいずれかが生じたときは、~UAは，
( `sandbox$aF 属性の値, 当の閲覧文脈の`~iframe~sandbox法~flag集合$ )
を ( %入力, %出力 ) に用いて，`~sandbox法~指令を構文解析-$し~MUST：
</p>

<ul>
	<li>
%iframe が `sandbox$aF 属性を有している下で
⇒
%iframe 用に`入子の閲覧文脈$が作成されたとき（かつ，初期 `about_blank$sc `文書$が作成される前）
</li>
	<li>
［
%iframe が`入子にしている閲覧文脈$ ~NEQ ~NULL
］の下で
⇒
%iframe の`sandbox$aF 属性が［
設定-／変更-
］されたとき
</li>
</ul>
◎
When an iframe element with a sandbox attribute has its nested browsing context created (before the initial about:blank Document is created), and when an iframe element's sandbox attribute is set or changed while it has a nested browsing context, the user agent must parse the sandboxing directive using the attribute's value as the input and the iframe element's nested browsing context's iframe sandboxing flag set as the output.
</div>

<p>
［
`iframe$e 要素が`入子にしている閲覧文脈$ %B ~NEQ ~NULL
］の下で、要素の `sandbox$aF 属性が除去されたときは、~UAは，
%B の`~iframe~sandbox法~flag集合$を空にし~MUST。
<!-- ＊ as the output -->
◎
When an iframe element's sandbox attribute is removed while it has a non-null nested browsing context, the user agent must empty the iframe element's nested browsing context's iframe sandboxing flag set as the output.
</p>

<div class="example">
<p>
この例では、頁~内には，利用者が供した ある［
完全に未知で，敵対的にもなり得る~HTML内容
］が埋込まれている。
それは，ある別々の~domainから~serveされているので、通常の~cross-site制約すべてから影響される。
加えて，埋込まれた頁では、［
~scripting, ~plugin, ~form
］は不能化され，自身以外のどの［
~frame／~window
］も（自身が埋込んだものも含め）~navigateできない。
◎
In this example, some completely-unknown, potentially hostile, user-provided HTML content is embedded in a page. Because it is served from a separate domain, it is affected by all the normal cross-site restrictions. In addition, the embedded page has scripting disabled, plugins disabled, forms disabled, and it cannot navigate any frames or windows other than itself (or any frames or windows it itself embeds).
</p>

`iframe-2^xCode

<p class="warning">
別々の~domainを利用することは、攻撃者が利用者を［
その頁に直に訪問させ、頁~内に見出されるどの攻撃からも脆弱にする
］よう仕向けても，［
頁は~siteの生成元の文脈の下で走ることはない
］ようにするために重要になる。
◎
It is important to use a separate domain so that if the attacker convinces the user to visit that page directly, the page doesn't run in the context of the site's origin, which would make the user vulnerable to any attack found in the page.
</p>

</div>

<div class="example">

<p>
次の例では、別の~siteからの ある~gadgetが埋込まれている。
この~gadgetでは、~scriptingと~formが可能化されていて、~gadgetが，出自の~serverと通信できるよう，生成元~sandbox制約は~~軽くされている。
しかしながら，~sandboxは、［
~pluginと~popup
］を不能化して，利用者が ~malwareその他のいまいましいものに晒されることを抑制するので、依然として有用になる。
◎
In this example, a gadget from another site is embedded. The gadget has scripting and forms enabled, and the origin sandbox restrictions are lifted, allowing the gadget to communicate with its originating server. The sandbox is still useful, however, as it disables plugins and popups, thus reducing the risk of the user being exposed to malware and other annoyances.
</p>

<pre class="html-code">
&lt;iframe sandbox="allow-same-origin allow-forms allow-scripts"
        src="https://maps.example.com/embedded.html"&gt;&lt;/iframe&gt;
</pre>

</div>

<div class="example">

<p>
~file %A は、次の~iframeを包含しているとする：
◎
Suppose a file A contained the following fragment:
</p>

<pre class="html-code">
&lt;iframe sandbox="allow-same-origin allow-forms" src=%B&gt;&lt;/iframe&gt;
</pre>

<p>
~file %B も~iframeも包含していたとする：
◎
Suppose that file B contained an iframe also:
</p>

<pre class="html-code">
&lt;iframe sandbox="allow-scripts" src=%C&gt;&lt;/iframe&gt;
</pre>

<p>
更に、~file %C は頁 %D への~linkを包含していたとする：
◎
Further, suppose that file C contained a link:
</p>

<pre class="html-code">
&lt;a href=%D&gt;Link&lt;/a&gt;
</pre>

<p>
この例に対しては、どの~fileも `text/html$mt として~serveされているとする。
◎
For this example, suppose all the files were served as text/html.
</p>

<p>
この局面における頁 %C  に対しては、~sandbox法~flagすべてが ~ON にされる。
%A 内の `iframe$e では~scriptは不能化されるので、 %C においては［
%B 内の `iframe$e 内に設定された `allow-scripts$v ~keyword
］は上書きされ， ~scriptは不能化される。
また、~formも不能化される
— （ %B 内の）内縁 `iframe$e 内には `allow-forms$v ~keywordは設定されてないので。
◎
Page C in this scenario has all the sandboxing flags set. Scripts are disabled, because the iframe in A has scripts disabled, and this overrides the allow-scripts keyword set on the iframe in B. Forms are also disabled, because the inner iframe (in B) does not have the allow-forms keyword set.
</p>

<p>
今ここで、 %A 内の~scriptが %A, %B 内のすべての `sandbox$aF 属性を除去したとする。
これは、~~直には何も変更しない。
利用者が %C 内の~linkを~clickして，
%B 内の `iframe$e の中に頁 %D を読込んだ場合、頁 %D は今や，［
%B 内の `iframe$e に［
`allow-same-origin$v, `allow-forms$v
］~keywordが設定されていた
］かのように動作する
— それが、［
頁%B が読込まれた時点で， %A 内の `iframe$e が`入子にしている閲覧文脈$の状態
］であったので。
◎
Suppose now that a script in A removes all the sandbox attributes in A and B. This would change nothing immediately. If the user clicked the link in C, loading page D into the iframe in B, page D would now act as if the iframe in B had the allow-same-origin and allow-forms keywords set, because that was the state of the nested browsing context in the iframe in A when page B was loaded.
</p>

<p>
一般に， `sandbox$aF 属性は、動的に除去したり変更しないことを勧める
— そうすると、何が許容され，何がされないようになるか選り分けることが困難になることもあるので。
◎
Generally speaking, dynamically removing or changing the sandbox attribute is ill-advised, because it can make it quite hard to reason about what will be allowed and what will not.
</p>

</div>

<hr>

<p>
`allow@aF
属性が指定されたときは、`容器~施策$を決定する
— それは、［
`iframe$e が`入子にしている閲覧文脈$に属する`文書$用の`特色機能~施策$doc
］が初期化されるときに，利用されることになる。
値は`直列形の特色機能~施策$で~MUST。
`FEATUREPOLICY$r
◎
The allow attribute, when specified, determines the container policy that will be used when the feature policy for a Document in the iframe's nested browsing context is initialized. Its value must be a serialized feature policy. [FEATUREPOLICY]
</p>

<div class="example">
<p>
次の例では、~online~navi~serviceからの地図を埋込むために， `iframe$e が利用される。
`allow$aF 属性は、入子にされた文脈の中で Geolocation ~APIを可能化するために利用される。
◎
In this example, an iframe is used to embed a map from an online navigation service. The allow attribute is used to enable the Geolocation API within the nested context.
</p>

<pre class="html-code">
&lt;iframe src="https://maps.example.com/" allow="geolocation"&gt;&lt;/iframe&gt;
</pre>

</div>

<p>
`allowfullscreen@aF
属性は，`真偽~属性$であり、指定されたときは，［
`iframe$e 要素の`閲覧文脈$に属する`文書$は、［
どの`生成元$からでも， `fullscreen^l 特色機能の利用を許容する
］ように，`特色機能~施策$docで初期化されることになる
］ことを指示する。
これは、`特色機能~施策~属性を処理する$ ~algoにより施行される。
`FEATUREPOLICY$r
◎
The allowfullscreen attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's browsing context will be initialized with a feature policy which allows the "fullscreen" feature to be used from any origin. This is enforced by the Process feature policy attributes algorithm. [FEATUREPOLICY]
</p>

<div class="example">

<p>
ここでの `iframe$e は、動画~siteからの再生器を埋込むために利用されている。
この再生器が動画を全~screen化するのを可能化するためには、
`allowfullscreen$aF 属性が必要になる。
◎
Here, an iframe is used to embed a player from a video site. The allowfullscreen attribute is needed to enable the player to show its video fullscreen.
</p>

`iframe-3^xCode

</div>

<p>
`allowpaymentrequest@aF
属性は`真偽~属性$であり、指定されたときは，［
`iframe$e 要素の`閲覧文脈$に属する`文書$は、［
どの`生成元$からでも，~payment要請を発行して `payment^l 特色機能を利用することを許容する
］ように，`特色機能~施策$docで初期化されることになる
］ことを指示する。
これは、`特色機能~施策~属性を処理する$~algoにより施行される。
`FEATUREPOLICY$r
◎
The allowpaymentrequest attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's browsing context will be initialized with a feature policy which allows the "payment" feature to be used to make payment requests from any origin. This is enforced by the Process feature policy attributes algorithm. [FEATUREPOLICY]
</p>

<p>
`allowusermedia@aF
属性は`真偽~属性$であり、指定されたときは，［
`iframe$e 要素の`閲覧文脈$に属する`文書$は、［
どの`生成元$からでも， `getUserMedia()$m を~callして［
`camera^l ／ `microphone^l
］特色機能を利用することを許容する
］ように，`特色機能~施策$docで初期化されることになる
］ことを指示する。
これは、`特色機能~施策~属性を処理する$~algoにより施行される。
`FEATUREPOLICY$r
◎
The allowusermedia attribute is a boolean attribute. When specified, it indicates that Document objects in the iframe element's browsing context will be initialized with a feature policy which allows the "camera" and "microphone" features to be used to call getUserMedia() from any origin. This is enforced by the Process feature policy attributes algorithm. [FEATUREPOLICY]
</p>

<p class="note">
これらの［
`allow$aF ／
`allowfullscreen$aF ／
`allowpaymentrequest$aF ／
`allowusermedia$aF
］属性は、［
`iframe$e 要素の`~node文書$には、当の特色機能の利用は，すでに許容されていない
］場合には，`入子の閲覧文脈$における特色機能への~accessを是認することはない。
◎
None of these attributes, allow, allowfullscreen, allowpaymentrequest or allowusermedia, can grant access to a feature in a nested browsing context if the iframe element's node document is not already allowed to use that feature.
</p>

<p id="fullscreen-logic">
`文書$ %文書 には，施策により制御される特色機能 %特色機能 の
`利用は許容されて@
いるかどうか決定するときは、次を走らす：
◎
To determine whether a Document object document is allowed to use the policy-controlled-feature feature, run these steps:
</p>

<ol>
	<li>
~IF［
%文書 が`属する閲覧文脈$ ~EQ ε
］
⇒
~RET ~F
◎
If document has no browsing context, then return false.
</li>
	<li>
~IF［
%文書 が`属する閲覧文脈$にて`作動中の文書$ ~NEQ %文書
］
⇒
~RET ~F
◎
If document's browsing context's active document is not document, then return false.
</li>
	<li>
~IF［
`特色機能は施策により生成元~用に可能化されるか？$( %特色機能, %文書, %文書 の`生成元$ ) ~EQ `可能化される^i
］
⇒
~RET ~T
◎
If the result of running Is feature enabled in document for origin on feature, document, and document's origin is "Enabled", then return true.
</li>
	<li>
~RET ~F
◎
Return false.
</li>
</ol>

<p class="warning">
［
`allow$aF ／
`allowfullscreen$aF ／
`allowpaymentrequest$aF ／
`allowusermedia$aF
］属性が波及するのは，`入子の閲覧文脈$にて`作動中の文書$の`特色機能~施策$docに限られる
— これらが効果を~~発揮するのは
`iframe$e が`入子にしている閲覧文脈$が`~navigate$されるときに限られる。
属性を追加しようが除去しようが，すでに読込まれた文書に対する効果は無い。
◎
Because they only influence the feature policy of the nested browsing context's active document, the allow, allowfullscreen, allowpaymentrequest and allowusermedia attributes only take effect when the nested browsing context of the iframe is navigated. Adding or removing them has no effect on an already-loaded document.
</p>

<hr>

<p>
`iframe$e 要素は、埋込みの内容に特有の寸法がある場合は，`寸法~属性$を~supportする（例： ~~定義済みの寸法がある広告unitなど）。
◎
The iframe element supports dimension attributes for cases where the embedded content has specific dimensions (e.g. ad units have well-defined dimensions).
</p>

<p>
`iframe$e 要素には、`~fallback内容$は決してない
— 指定された初期~内容が成功裡に利用されようがされまいが、それは常に，`入子の閲覧文脈$として`新たな閲覧文脈を作成する$ことになるので。
◎
An iframe element never has fallback content, as it will always create a nested browsing context, regardless of whether the specified initial contents are successfully used.
</p>

<hr>

<p>
`referrerpolicy@aF
属性は、`~referrer施策~属性$である。
その目的は、`~iframeの属性を処理する$ときに利用される`~referrer施策$を設定することである。
`REFERRERPOLICY$r
◎
The referrerpolicy attribute is a referrer policy attribute. Its purpose is to set the referrer policy used when processing the iframe attributes. [REFERRERPOLICY]
</p>

<hr>

<p>
`iframe$e 要素の子孫は、何も表現しない（ `iframe$e 要素を~supportしない旧来の~UAにおいては、その内容は ~markupとして構文解析され，~fallback内容として動作し得る。）
◎
Descendants of iframe elements represent nothing. (In legacy user agents that do not support iframe elements, the contents would be parsed as markup that could act as fallback content.)
</p>

<p class="note">注記：
`~HTML構文解析器$は、 `iframe$e 要素の内側にある~markupを~textとして扱う。
◎
The HTML parser treats markup inside iframe elements as text.
</p>

<hr>


<dl class="idl-def">
	<dt>`src@mF</dt>
	<dt>`srcdoc@mF</dt>
	<dt>`name@mF</dt>
	<dt>`sandbox@mF</dt>
	<dt>`allow@mF</dt>
	<dt>`allowFullscreen@mF</dt>
	<dt>`allowPaymentRequest@mF</dt>
	<dt>`allowUserMedia@mF</dt>
	<dd>
順に，（小文字~化した名前の）［
`src$aF,
`srcdoc$aF,
`name$aF,
`sandbox$aF,
`allow$aF,
`allowfullscreen$aF,
`allowpaymentrequest$aF,
`allowusermedia$aF
］内容~属性を`反映-$し~MUST。
◎
The IDL attributes src, srcdoc, name, sandbox, and allow must reflect the respective content attributes of the same name.
◎
The supported tokens for sandbox's DOMTokenList are the allowed values defined in the sandbox attribute and supported by the user agent.
◎
The allowFullscreen IDL attribute must reflect the allowfullscreen content attribute.
◎
The allowPaymentRequest IDL attribute must reflect the allowpaymentrequest content attribute.
◎
The allowUserMedia IDL attribute must reflect the allowusermedia content attribute.
</dd>
	<dd>
`sandbox$mF 属性が `DOMTokenList$I 用に`~supportする~token集合$は、［
`sandbox$aF 内容~属性に定義された許容される値のうち，~UAが~supportするもの
］からなるとする。
◎
↑</dd>

	<dt>`referrerPolicy@mF</dt>
	<dd>
`既知の値のみに制限され$る下で，
`referrerpolicy$aF 内容~属性を`反映-$し~MUST。
◎
The referrerPolicy IDL attribute must reflect the referrerpolicy content attribute, limited to only known values.
</dd>

	<dt>`contentDocument@mF</dt>
	<dd>
取得子は、此れの`内容~文書$を返さ~MUST。
◎
The contentDocument IDL attribute, on getting, must return the iframe element's content document.
</dd>

	<dt>`contentWindow@mF</dt>
	<dd>
取得子は、此れが`入子にしている閲覧文脈$ %B に応じて，［
~NULL ならば ~NULL ／
~ELSE_ %B の `WindowProxy$I ~obj
］を返さ~MUST。
◎
The contentWindow IDL attribute must return the WindowProxy object of the iframe element's nested browsing context, if its nested browsing context is non-null, or null otherwise.
</dd>
</dl>



<div class="example">
<p>
`iframe$e を用いて
広告~代行業者からの広告を含ませる例：
◎
Here is an example of a page using an iframe to include advertising from an advertising broker:
</p>

`iframe-4^xCode

</div>

			</section>
			<section id="the-embed-element">
<h3 title="The embed element">4.8.6. `embed^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句内容$ ／ `埋込みの内容$ ／`対話的~内容$ ／ `可触~内容$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
Interactive content.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込みの内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`src$aE
— 埋込む資源の~address
◎
src — Address of the resource
</dd>
	<dd>
`type$aE
— 埋込む資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>
	<dd>
どの名前空間にも属さない任意の属性（注釈文を見よ）。
◎
Any other attribute that has no namespace (see prose).
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>


<pre class="idl">
[Exposed=Window,
 `HTMLConstructor$]
interface `HTMLEmbedElement@I : `HTMLElement$I {
  [`CEReactions$] attribute USVString `src$mE;
  [`CEReactions$] attribute DOMString `type$mE;
  [`CEReactions$] attribute DOMString `width$m;
  [`CEReactions$] attribute DOMString `height$m;
  `Document$I? `getSVGDocument$m();
};
</pre>


<p>
`embed$e 要素により~instance化される内容の型に依存して、~nodeは，他の~interfaceを~supportしてもよい。
◎
Depending on the type of content instantiated by the embed element, the node may also support other interfaces.
</p>
	</dd>
</dl>

<p>
`embed$e 要素は、外部（概して~HTMLでない）
~appや対話的~内容~用に統合~~地点を供する。
◎
The embed element provides an integration point for an external (typically non-HTML) application or interactive content.
</p>

<p>
`src@aE
属性は、埋込まれる資源の`~URL$を与える。
この属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
◎
The src attribute gives the URL of the resource being embedded. The attribute, if present, must contain a valid non-empty URL potentially surrounded by spaces.
</p>

<p>
`embed$e 要素が `itemprop$a を有する場合、
`src$aE 属性も有してい~MUST。
◎
If the itemprop attribute is specified on an embed element, then the src attribute must also be specified.
</p>

<p>
`type@aE
属性は、在するならば`~MIME型$を与え、~instance化される~pluginは，それにより選定される。
指定する値は、`妥当な~MIME型~文字列$で~MUST。
要素が `type$aE, `src$aE 両 属性とも有する場合、
`type$aE 属性には，［
`src$aE 属性に与えられた資源
］の［
明示的な`~Content-Type~metadata$
］と同じ型が指定され~MUST。
◎
The type attribute, if present, gives the MIME type by which the plugin to instantiate is selected. The value must be a valid MIME type string. If both the type attribute and the src attribute are present, then the type attribute must specify the same type as the explicit Content-Type metadata of the resource given by the src attribute.
</p>

<p>
`embed$e 要素が次のいずれかの条件を満たしている間は、要素に対し~instance化された`~plugin$は，除去され~MUST
— 要素は何も`表現-$しなくなる：
◎
While any of the following conditions are occurring, any plugin instantiated for the element must be removed, and the embed element represents nothing:
</p>

<ul>
	<li>
要素は `src$aE, `type$aE 両~属性とも有さない。
◎
The element has neither a src attribute nor a type attribute.
</li>
	<li>
要素の先祖に`~media要素$がある。
◎
The element has a media element ancestor.
</li>
	<li>
要素の先祖に［
`~fallback内容$を<em>示していない</em> `object$e 要素
］がある。
◎
The element has an ancestor object element that is not showing its fallback content.
</li>
</ul>

<p>
`embed$e 要素は、次の条件すべてを同時に満たすとき
`作動中になれ@
るとされる（その否定は、 “作動中になれない” と記される）：
◎
An embed element is said to be potentially active when the following conditions are all met simultaneously:
</p>

<ul>
	<li>
［
`文書~内に$ある
］~OR［
`~event-loop$が最後に その`最初の段$に達した時点で，`文書~内に$あった
］。
◎
The element is in a document or was in a document the last time the event loop reached step 1.
</li>
	<li>
その`~node文書$は`全部的に作動中$である。
◎
The element's node document is fully active.
</li>
	<li>
［
`src$aE 属性を有する
］~OR［
`type$aE 属性を有する
］
◎
The element has either a src attribute set or a type attribute set (or both).
</li>
	<li>
［
`src$aE 属性は有さない
］~OR［
`src$aE 属性を有していて，その値 ~NEQ 空~文字列
］
◎
The element's src attribute is either absent or its value is not the empty string.
</li>
	<li>
`~media要素$の子孫ではない
◎
The element is not a descendant of a media element.
</li>
	<li>
［
`~fallback内容$を示していない `object$e 要素
］の子孫ではない
◎
The element is not a descendant of an object element that is not showing its fallback content.
</li>
	<li>
［
`具現化されて$いる
］~OR［
`~event-loop$が最後に その`最初の段$に達した時点で，`具現化されて$いた
］。
◎
The element is being rendered, or was being rendered the last time the event loop reached step 1.
</li>
</ul>

<div >
<p class="algo-head">
`embed$e 要素に対し，次のいずれかが生じたときは、~UAは，
`~embed~task源@
から，`~embed要素を設定しておく手続き$を走らす`~taskを~queueし$~MUST：
</p>

<ul><li>`作動中になれ$ない~~状態から`作動中になれ$るようになったとき
</li><li>`作動中になれ$るまま，その［
`src$aE 属性, または `type$aE 属性
<!-- ＊原文誤#attr-embed-type -->
］が［
設定- ／ 変更- ／ 除去-
］されたとき
</li></ul>

◎
Whenever an embed element that was not potentially active becomes potentially active, and whenever a potentially active embed element that is remaining potentially active and has its src attribute set, changed, or removed or its type attribute set, changed, or removed, the user agent must queue a task using the embed task source to run the embed element setup steps.
</div>

<p>
`~embed要素を設定しておく手続き@
は、所与の `embed$e 要素 %embed に対し，次を走らす：
◎
The embed element setup steps are as follows:
</p>

<ol>
	<li>
%現~task ~LET %embed に対し，この手続きを走らせている`~task$
◎
↓</li>
	<li>
~IF［
%現~task より後に~queueされた，［
同じ %embed に対し この手続きを走らす，別の`~task$
］がある
］
⇒
~RET
◎
If another task has since been queued to run the embed element setup steps for this element, then return.
</li>
	<li>
~IF［
`要素は~CSPにより先天的に阻止されるべきか？$( %embed ) `CSP$rの結果 ~EQ `阻止ed^i
］
⇒
~RET
◎
If the Should element be blocked a priori by Content Security Policy? algorithm returns "Blocked" when executed on the element, then return. [CSP]
</li>
	<li>
<p>
~UAは、この段を走らすべきである。
◎
↓</p>

<p>
~IF［
%embed は `src$aE 属性を有する
］：
◎
If the element has a src attribute set
</p>
		<ol>
			<li>
%src ~LET
%embed の `src$aE 属性の値を［
%embed の`~node文書$
］に`相対的に構文解析-$した`結果の~URL~record$
◎
The user agent must parse the value of the element's src attribute, relative to the element's node document.＼
</li>
			<li>
~IF［
%src ~EQ ~error
］
⇒
~RET
◎
If that is successful, the user agent should run these steps:
</li>
			<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~url$rq ~SET %src,
`~client$rq ~SET %embed の`~node文書$の `Window$I ~objの`環境~設定群~obj$,
`行先$rq ~SET `embed^l,
`資格証~mode$rq ~SET `include^l,
`~URL資格証~利用~flag$rq ~SET ~ON
◎
Let request be a new request whose url is the resulting URL record, client is the element's node document's Window object's environment settings object, destination is "embed", credentials mode is "include", and whose use-URL-credentials flag is set.
</li>
			<li>
<p>
%要請 を`~fetch$する
— 加えて：
◎
Fetch request.
</p>

<p>
資源が~fetchされ，`~network用~task源$から`~queueされ$た`~task$は、次の手続きを走らせ~MUST：
◎
The task that is queued by the networking task source once the resource has been fetched must run the following steps:
</p>

				<ol>
					<li>
~IF［
%現~task より後に~queueされた，［
同じ %embed に対し この手続きを走らす，別の`~task$
］がある
］
⇒
~RET
◎
If another task has since been queued to run the embed element setup steps for this element, then return.
</li>
					<li>
<p>
`内容の型@
~LET 次の下位手続きを走らせた結果：
◎
Determine the type of the content being embedded, as follows (stopping at the first substep that determines the type):
</p>
						<ol>
							<li>
~IF［
%embed は `type$aE 属性を有していて，その値は
ある`~plugin$が~supportする型である
］
⇒
~RET その属性~値
◎
If the element has a type attribute, and that attribute's value is a type that a plugin supports, then the value of the type attribute is the content's type.
</li>
							<li>
%~url ~LET `~URL構文解析する$( 指定された資源の（~redirect後の）`~URL$ )
◎
Otherwise, if applying the URL parser algorithm to the URL of the specified resource (after any redirects) results in a URL record＼
</li>
							<li>
<p>
~IF［
%~url ~NEQ `失敗^i
］~AND［
%~url の`~path$url 成分は ある`~plugin$が~supportする~patternに合致する
］
⇒
~RET その~pluginが取扱える型
◎
whose path component matches a pattern that a plugin supports, then the content's type is the type that that plugin can handle.
</p>

<p class="example">
例えば，ある~pluginは、［
`~path$url 成分が文字列 `.swf^l で終端する
］ような資源を取扱えるとしていることもある。
◎
For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".
</p>

<p class="trans-note">【
~patternに合致する複数の~pluginがある場合に，［
どの~pluginが選定されるか ／
当の~pluginが複数の型を取扱える場合に，どの型が選定されるか
］については、ここには述べられていない（関連すると思しき記述は
<a href="~HTMLnavigator#plugins-2">~plugin節</a>
にあるが、いずれにせよ，~UAや環境設定に基づく何らかの仕組みで選定されることが前提にある）。
他所にも~pluginを選定する記述があるが同様と思われる。
】</p>

							</li>
							<li>
~IF［
指定された資源には、明示的な`~Content-Type~metadata$がある
］
⇒
~RET その~Content-Type
◎
Otherwise, if the specified resource has explicit Content-Type metadata, then that is the content's type.
</li>
							<li>
~RET ε
（内容には`内容の型$はなく，対する適切な`~plugin$はない）
◎
Otherwise, the content has no type and there can be no appropriate plugin for it.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
`内容の型$ ~EQ `image/svg+xml$mt
］：
◎
If the previous step determined that the content's type is image/svg+xml, then run the following substeps:
</p>
						<ol>
							<li>
%B ~LET %embed が`入子にしている閲覧文脈$
◎
↓</li>
							<li>
<p>
~IF［
%B ~EQ ~NULL
］：
</p>
								<ol>
									<li>
%B ~SET `新たな閲覧文脈を作成する$()
</li>
									<li>
%embed が`入子にしている閲覧文脈$ ~SET %B
</li>
									<li>
~IF［
%embed は `name$a 属性を有する
］
⇒
%B の`閲覧文脈~名$ ~SET その属性の値
</li>
								</ol>
◎
If the embed element's nested browsing context is null, set the element's nested browsing context to a newly-created browsing context, and, if the element has a name attribute, set the browsing context name of the element's new nested browsing context to the value of this attribute.
</li>
							<li>
<p>
次を与える下で， %B を~fetchされた資源へ`~navigate$する
⇒＃
`置換~可能化~flag$ ~SET ~ON,
`~source閲覧文脈$ ~SET %embed の`~node文書$が`属する閲覧文脈$
</p>
<p>
（ %embed の `src$aE 属性は、 %B が更に他の所在に~navigateされても更新されない。）
</p>

◎
Navigate the nested browsing context to the fetched resource, with replacement enabled, and with the embed element's node document's browsing context as the source browsing context. (The src attribute of the embed element doesn't get updated if the browsing context gets further navigated to other locations.)
</li>
							<li>
この時点で、
%embed は %B を`表現-$する
◎
The embed element now represents its nested browsing context.
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
</p>
						<ol>
							<li>
%~plugin ~LET `内容の型$に基づいて適切な`~plugin$を見出して
— なければ`既定の~plugin$とする —
それを~instance化した結果
— %embed に対し以前に~instance化されていた~pluginがあれば それを置換する
</li>
							<li>
%~plugin に資源の内容を手渡す
</li>
							<li>
この時点で、
%embed は %~plugin を表現する
</li>
						</ol>
◎
Otherwise, find and instantiate an appropriate plugin based on the content's type, and hand that plugin the content of the resource, replacing any previously instantiated plugin for the element. The embed element now represents this plugin instance.
</li>
				</ol>

<p>
加えて：
</p>
				<ul>
					<li>
資源または その~pluginが完全に読込まれた時点で、次を走らす`~taskを~queueする$
⇒
%embed に向けて，名前 `load$et の`~eventを発火する$
◎
Once the resource or plugin has completely loaded, queue a task to fire an event named load at the element.
</li>
					<li>
<p>
資源が成功裡に~fetchされたかどうか（例：その応答~statusは`~ok~status$であったかどうか）は、［
`内容の型$を決定する／
資源を~pluginに手渡す
］ときには，無視され~MUST。
◎
Whether the resource is fetched successfully or not (e.g. whether the response status was an ok status) must be ignored when determining the content's type and when handing the resource to the plugin.
</p>

<p class="note">注記：
これにより、~serverは， ~error応答においても~plugin用の~dataを返せるようになる（例：
~HTTP 500  Internal Server Error ~codeは、依然として ~plugin~dataを包含できる）。
◎
This allows servers to return data for plugins even with error responses (e.g. HTTP 500 Internal Server Error codes can still contain plugin data).
</p>
					</li>
					<li>
資源の~fetchingは、 %embed の`~node文書$の`~load~eventを遅延-$し~MUST。
◎
Fetching the resource must delay the load event of the element's node document.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
<p>
~UAは、この段を走らすべきである。
【上の “走らすべき” 段とこの段のうち，片方だけ走らすことにする~UAもあり得ることになる。】
◎
↓</p>

<p>
~IF［
%embed は `src$aE 属性を有さない
］：
◎
If the element has no src attribute set
</p>
		<ol>
			<li>
%~plugin ~LET `type$aE 属性の値に基づいて 適切な`~plugin$を見出して
— なければ`既定の~plugin$とする —
それを~instance化した結果
◎
The user agent should find and instantiate an appropriate plugin based on the value of the type attribute.＼
</li>
			<li>
この時点で、 %embed は %~plugin を表現する
◎
The embed element now represents this plugin instance.
</li>
			<li>
%~plugin が完全に読込まれた時点で，次を走らす`~taskを~queueする$ようにしておく
⇒
%embed に向けて，名前 `load$et の`~eventを発火する$
◎
Once the plugin is completely loaded, queue a task to fire an event named load at the element.
</li>
		</ol>
	</li>
</ol>

<p>
`embed$e 要素は、`~fallback内容$を持たない。
~UAは、上の~algoにて相応しい~pluginを見出して~instance化しようと試みたときに見出せなかった場合，
`既定の~plugin@
を利用し~MUST。
この既定は、単純に
“未~supportの形式です”
と~~述べるだけにすることもできる。
◎
The embed element has no fallback content. If the user agent can't find a suitable plugin when attempting to find and instantiate one for the algorithm above, then the user agent must use a default plugin. This default could be as simple as saying "Unsupported Format".
</p>

<p>
`作動中になれ$る `embed$e 要素が，`作動中になれ$なくなったときは、要素に対し~instance化されていた`~plugin$は，未読込みにされ~MUST。
◎
Whenever an embed element that was potentially active stops being potentially active, any plugin that had been instantiated for that element must be unloaded.
</p>

<p id="sandboxPluginEmbed">
［
~instance化されようとしている`~plugin$ %~plugin を`保安化-$できない
］~AND［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN
`embed$e 要素の`~node文書$の`作動中の~sandbox法~flag集合$
］のときは、~UAは：
◎
When a plugin is to be instantiated but it cannot be secured and the sandboxed plugins browsing context flag is set on the embed element's node document's active sandboxing flag set, then＼
</p>

<ul>
	<li>
 %~plugin を~instance化しては~MUST_NOT
— 代わりに， %~plugin が不能化されたことを伝えるように `embed$e 要素を具現化し~MUST。
◎
the user agent must not instantiate the plugin, and must instead render the embed element in a manner that conveys that the plugin was disabled.＼
</li>
	<li>
［
~sandboxを上書きして， %~plugin を とにかく~instance化する選択肢
］を，利用者に提供してもよい
— 利用者がそのような選択肢を呼出した場合、［
この要素の目的においては，上の条件は適用されなかった
］かのように動作し~MUST。
◎
The user agent may offer the user the option to override the sandbox and instantiate the plugin anyway; if the user invokes such an option, the user agent must act as if the conditions above did not apply for the purposes of this element.
</li>
</ul>

<p class="warning">
`保安化-$できない~pluginは、~sandboxが課す制約を尊守しないかもしれないので，~sandbox化された閲覧文脈においては不能化される（例：さもなければ、~sandboxに対し~scriptingが不能化されていても，~scriptingが許容されるかもしれない）。
~UAは、~sandboxを上書きすることの危険性を，そうする選択肢を供する場合には 利用者に伝えるべきである。
◎
Plugins that cannot be secured are disabled in sandboxed browsing contexts because they might not honor the restrictions imposed by the sandbox (e.g. they might allow scripting even when scripting in the sandbox is disabled). User agents should convey the danger of overriding the sandbox to the user if an option to do so is provided.
</p>

<div >
<p>
`embed$e 要素が`入子にしている閲覧文脈$ %B （~NEQ ~NULL ）にて`作動中の文書$ %文書 に対し，次のいずれかが満たされている間は、要素は %文書 の`~load~eventを遅延-$し~MUST：
</p>

<ul><li>%文書 の`読込後~taskは準備済み$でない
</li><li>%文書 の`~load~eventを遅延-$している何かがある
</li><li>%B は`~load~event遅延-中~mode$下にある
</li></ul>

◎
When an embed element has a non-null nested browsing context: if the embed element's nested browsing context's active document is not ready for post-load tasks, and when anything is delaying the load event of the embed element's browsing context's active document, and when the embed element's browsing context is in the delaying load events mode, the embed must delay the load event of its document.
</div>

<p>
この節にて言及された`~task$の`~task源$は、
【他が指定されない限り】
`~DOM操作~task源$とする。
◎
The task source for the tasks mentioned in this section is the DOM manipulation task source.
</p>

<div >
<p>
`embed$e 要素には、名前が次をすべて満たすような任意の属性が指定されてもよい：
</p>

<ul ><li>`name$a, `align$a, `hspace$a, `vspace$a のいずれでもでない
</li><li>どの名前空間にも属さない
</li><li>`~XML互換$である
</li><li>`~ASCII英大文字$を包含しない
</li></ul>

◎
Any namespace-less attribute other than name, align, hspace, and vspace may be specified on the embed element, so long as its name is XML-compatible and contains no ASCII upper alphas.＼
</div>

<p>
そのような属性は、`~plugin$への~parameterとして渡されることになる。
◎
These attributes are then passed as parameters to the plugin.
</p>

<p class="note">注記：
`~HTML文書$におけるすべての属性は、自動的に小文字~化されるので、大文字に対する制約は，そのような文書には影響しない。
◎
All attributes in HTML documents get lowercased automatically, so the restriction on uppercase letters doesn't affect such documents.
</p>

<p class="note">注記：
上に挙げた 4 個の名前は，旧来の属性であり、単に~parameterを`~plugin$に送ることを超えるような副作用を伴うので，除外されている。
◎
The four exceptions are to exclude legacy attributes that have side-effects beyond just sending parameters to the plugin.
</p>

<p>
~UAは、 `embed$e 要素の属性のうち，どの名前空間にも属さないものすべての名前と値を，利用される`~plugin$が~instance化されるときに渡すべきである。
◎
The user agent should pass the names and values of all the attributes of the embed element that have no namespace to the plugin used, when one is instantiated.
</p>

<p>
`embed$e 要素を表現している `HTMLEmbedElement$I ~objは、要素に対し~instance化された`~plugin$に~script可能な~interfaceがあれば それを公開し~MUST。
◎
The HTMLEmbedElement object representing the element must expose the scriptable interface of the plugin instantiated for the embed element, if any.
</p>

<p>
`embed$e 要素は、`寸法~属性$を~supportする。
◎
The embed element supports dimension attributes.
</p>


<dl class="idl-def">
	<dt>`src@mE</dt>
	<dt>`type@mE</dt>
	<dd>
順に，（同じ名前の）［
`src$aE,
`type$aE
］内容~属性を`反映-$し~MUST。
◎
The IDL attributes src and type each must reflect the respective content attributes of the same name.
</dd>
</dl>

<div class="example">
<p>
~Flashの様な，~proprietaryな~pluginを要する資源を埋込む例：
◎
Here's a way to embed a resource that requires a proprietary plugin, like Flash:
</p>

`embed-1^xCode

<p>
~pluginが備えていない利用者は、この資源を利用できないことになる（例えば，その~plugin~vendorは、利用者の~platformを~supportしていないなど）。
◎
If the user does not have the plugin (for example if the plugin vendor doesn't support the user's platform), then the user will be unable to use the resource.
</p>

<p>
属性を指定すれば、この~pluginに~parameter［
名前 `quality^l, 値 `high^l
］を渡せる：
◎
To pass the plugin a parameter "quality" with the value "high", an attribute can be specified:
</p>

`embed-2^xCode

<p>
これは、代わりに `object$e 要素を用いたときには，次と等価になる：
◎
This would be equivalent to the following, when using an object element instead:
</p>

`embed-3^xCode

</div>

			</section>
			<section id="the-object-element">
<h3 title="The object element">4.8.7. `object^e 要素</h3>

<dl class="element-def">

	<dt>`分類$</dt>
	<dd>
`~flow内容$ ／ `句内容$ ／ `埋込みの内容$ ／ `可触~内容$ ／［
この要素が `usemap$a 属性を有する場合に限り，`対話的~内容$
］ ／
`~listされる要素$ ／ `提出-可能な要素$ ／ `~formに所有され得る要素$
◎
Flow content.
◎
Phrasing content.
◎
Embedded content.
◎
If the element has a usemap attribute: Interactive content.
◎
Listed and submittable form-associated element.
◎
Palpable content.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`埋込みの内容$が期待される所。
◎
Where embedded content is expected.
</dd>

	<dt>`内容~model$</dt>
	<dd>
<p>
次の順による並び：
</p>

<ol ><li>0 個~以上の `param$e 要素
</li><li>`透過的な内容$
</li></ol>
◎
Zero or more param elements, then, transparent.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
両~tagとも省略不可。
◎
Neither tag is omissible.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`data$aO
— 埋込む資源の~address
◎
data — Address of the resource
</dd>
	<dd>
`type$aO
— 埋込む資源の型
◎
type — Type of embedded resource
</dd>
	<dd>
`typemustmatch$aO
— 資源が利用されるためには
`type$aO 属性と`~Content-Type$ 値とが合致する必要があるかどうか
◎
typemustmatch — Whether the type attribute and the Content-Type value need to match for the resource to be used
</dd>
	<dd>
`name$aO
— `入子の閲覧文脈$の名前
◎
name — Name of nested browsing context
</dd>
	<dd>
`usemap$a
— 利用する`画像~map$の名前
◎
usemap — Name of image map to use
</dd>
	<dd>
`form$a
— この~controlの所有者にする `form$e 要素
◎
form — Associates the control with a form element
</dd>
	<dd>
`width$a
— 横~寸法
◎
width — Horizontal dimension
</dd>
	<dd>
`height$a
— 縦~寸法
◎
height — Vertical dimension
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>


<pre class="idl">
[Exposed=Window,
 `HTMLConstructor$]
interface `HTMLObjectElement@I : `HTMLElement$I {
  [`CEReactions$] attribute USVString `data$mO;
  [`CEReactions$] attribute DOMString `type$mO;
  [`CEReactions$] attribute boolean `typeMustMatch$mO;
  [`CEReactions$] attribute DOMString `name$mO;
  [`CEReactions$] attribute DOMString `useMap$mO;
  readonly attribute `HTMLFormElement$I? `form$m;
  [`CEReactions$] attribute DOMString `width$m;
  [`CEReactions$] attribute DOMString `height$m;
  readonly attribute `Document$I? `contentDocument$mO;
  readonly attribute `WindowProxy$I? `contentWindow$mO;
  `Document$I? `getSVGDocument$m();

  readonly attribute boolean `willValidate$m;
  readonly attribute `ValidityState$I `validity$m;
  readonly attribute DOMString `validationMessage$m;
  boolean `checkValidity$m();
  boolean `reportValidity$m();
  void `setCustomValidity$m(DOMString %error);
};
</pre>


<p>
`object$e 要素により~instance化される内容の型に依存して、~nodeは，他の~interfaceを~supportしてもよい。
◎
Depending on the type of content instantiated by the object element, the node also supports other interfaces.
</p>
	</dd>
</dl>

<p>
`object$e 要素は、外部~資源を表現できる
— それは、資源の型に依存して，［
画像, `入子の閲覧文脈$, `~plugin$により処理される外部~資源
］のいずれかとして扱われることになる。
◎
The object element can represent an external resource, which, depending on the type of the resource, will either be treated as an image, as a nested browsing context, or as an external resource to be processed by a plugin.
</p>

<p>
`data@aO
属性は、在するならば，資源の`~URL$を指定する。
この属性に指定する値は、`前後~空白~可の妥当かつ空でない~URL$で~MUST。
◎
The data attribute, if present, specifies the URL of the resource. If present, the attribute must be a valid non-empty URL potentially surrounded by spaces.
</p>

<p class="warning">
作者には、信用しない他の`生成元$からの資源を参照する場合には，下に定義する `typemustmatch$aO 属性を利用することが督促される。
その属性がないと、ある種の事例において，［
遠隔~host上の攻撃者が、~pluginの仕組みを利用して，任意の~scriptを走らす
］ことが可能になる
— 作者が［
~Flashの "allowScriptAccess" ~parameter
］に類する特色機能を利用していたとしても。
◎
Authors who reference resources from other origins that they do not trust are urged to use the typemustmatch attribute defined below. Without that attribute, it is possible in certain cases for an attacker on the remote host to use the plugin mechanism to run arbitrary scripts, even if the author has used features such as the Flash "allowScriptAccess" parameter.
</p>

<p>
`type@aO
属性は、在するならば，資源の型を指定する。
この属性に指定する値は、`妥当な~MIME型~文字列$で~MUST。
◎
The type attribute, if present, specifies the type of the resource. If present, the attribute must be a valid MIME type string.
</p>

<p>
`object$e 要素は、
`data$aO, `type$aO
属性のうち，どちらかは有してい~MUST。
◎
At least one of either the data attribute or the type attribute must be present.
</p>

<p>
`object$e 要素が `itemprop$a 属性を有する場合、
`data$aO 属性も有してい~MUST。
◎
If the itemprop attribute is specified on an object element, then the data attribute must also be specified.
</p>

<p>
`typemustmatch@aO
属性は`真偽~属性$であり、在するならば，［
`data$aO 属性に指定された資源は、その`~Content-Type$が
`type$aO 属性の値に合致する場合に限り利用される
］ことを指示する。
◎
The typemustmatch attribute is a boolean attribute whose presence indicates that the resource specified by the data attribute is only to be used if the value of the type attribute and the Content-Type of the aforementioned resource match.
</p>

<p>
`typemustmatch$aO
属性は、
`data$aO, `type$aO
両~属性とも在する場合を除き，指定されては~MUST_NOT。
◎
The typemustmatch attribute must not be specified unless both the data attribute and the type attribute are present.
</p>

<p>
`name@aO
属性に指定する値は、`妥当な閲覧文脈~名$で~MUST。
その値は、適用-可能であれば，`入子の閲覧文脈$に名前を与えるときに利用される。
◎
The name attribute, if present, must be a valid browsing context name. The given value is used to name the nested browsing context, if applicable.
</p>


<p class="algo-head">
`object$e 要素において，次のいずれかが生じたときは：
◎
Whenever one of the following conditions occur:
</p>

<ul>
	<li>
作成されたとき
◎
the element is created,
</li>
	<li>
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$から~pop-offされたとき
◎
the element is popped off the stack of open elements of an HTML parser or XML parser,
</li>
	<li>
［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$内にない下で
⇒
［
`文書の中へ挿入され$た／`文書から除去され$た
］とき
◎
the element is not on the stack of open elements of an HTML parser or XML parser, and it is either inserted into a document or removed from a document,
</li>
	<li>
その`~node文書$が`全部的に作動中$かどうかが変化したとき
◎
the element's node document changes whether it is fully active,
</li>
	<li>
ある先祖の `object$e 要素において［
`~fallback内容$を示しているかどうか
］が変化したとき
◎
one of the element's ancestor object elements changes to or from showing its fallback content,
</li>
	<li>
その `classid$a 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
the element's classid attribute is set, changed, or removed,
</li>
	<li>
`classid$a 属性を有していない下で
⇒
その `data$aO 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
the element's classid attribute is not present, and its data attribute is set, changed, or removed,
</li>
	<li>
［
`classid$a, `data$aO
］両~属性とも有していない下で
⇒
その `type$aO 属性が［
設定- ／ 変更- ／ 除去-
］されたとき
◎
neither the element's classid attribute nor its data attribute are present, and its type attribute is set, changed, or removed,
</li>
	<li>
`具現化されて$いるかどうかが変化したとき
◎
the element changes from being rendered to not being rendered, or vice versa,
</li>

</ul>

<p>
…~UAは、次に与える［
`object$e 要素 %O が表現するものを決定する（し直す）
］手続きを走らす`~taskを~queueし$~MUST
— この`~task$が `~queueされ$ている, または<!-- ＊actively -->
走っている間は、
%O の`~node文書$の`~load~eventを遅延-$し~MUST。
◎
...the user agent must queue a task to run the following steps to (re)determine what the object element represents. This task being queued or actively running must delay the load event of the element's node document.
</p>

<ol>
	<li>
<p>
~IF［
利用者は、
%O の通例の挙動に代えて
%O の`~fallback内容$を示す選好を指示した
］
⇒
~GOTO `fallback$i
◎
If the user has indicated a preference that this object element's fallback content be shown instead of the element's usual behavior, then jump to the step below labeled fallback.
</p>

<p class="note">注記：
利用者は、例えば %O の`~fallback内容$の方がより~access可能な形式であると見出したときに，それを示すよう依頼することもできる。
◎
For example, a user could ask for the element's fallback content to be shown because that content uses a format that the user finds more accessible.
</p>
	</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］
⇒
~GOTO `fallback$i
</p>

<ul><li>%O の先祖には`~media要素$ がある
</li><li>%O の先祖には［
`~fallback内容$を<em>示していない</em> `object$e 要素
］がある
</li><li>%O は`文書~内に$ない
</li><li>%O は`文書~内に$あって，その文書が`属する閲覧文脈$ ~EQ ε
</li><li>%O の`~node文書$は`全部的に作動中$でない
</li><li>%O は，まだ［
`~HTML構文解析器$ ／ `~XML構文解析器$
］の`~open要素~stack$内にある
</li><li>%O は`具現化されて$いない
</li><li>`要素は~CSPにより先天的に阻止されるべきか？$( %O ) の結果 ~EQ `阻止ed^i 
`CSP$r
</li></ul>
◎
If the element has an ancestor media element, or has an ancestor object element that is not showing its fallback content, or if the element is not in a document that has a browsing context, or if the element's node document is not fully active, or if the element is still in the stack of open elements of an HTML parser or XML parser, or if the element is not being rendered, or if the Should element be blocked a priori by Content Security Policy? algorithm returns "Blocked" when executed on the element, then jump to the step below labeled fallback. [CSP]
</li>
	<li>
%classid ~LET ［
%O は `classid$a 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
<p>
~IF［
%classid ~NIN { ε, 空~文字列 }
］：
◎
If the classid attribute is present, and has a value that isn't the empty string, then:＼
</p>
		<ol>
			<li>
<p>
~IF［
~UAは %classid に則って相応しい`~plugin$を見出せる
］：
◎
if the user agent can find a plugin suitable according to the value of the classid attribute, and＼
</p>
				<ol>
					<li>
~IF［
その~pluginは`~sandbox化されて$いる
］~AND［
その~pluginは`保安化-$できない
］
⇒
~GOTO `fallback$i
◎
either plugins aren't being sandboxed or that plugin can be secured, then＼
</li>
					<li>
~UAは、その`~pluginを利用するべき$である
— %O が `data$aO 属性を有するならば それも`~plugin$に渡されるべきである
◎
that plugin should be used, and the value of the data attribute, if any, should be passed to the plugin.＼
</li>
					<li>
~IF［
`~plugin$から~errorが報告された
］
⇒
~GOTO `fallback$i
◎
If no suitable plugin can be found, or if the plugin reports an error, jump to the step below labeled fallback.
</li>
					<li>
~RET
【この段は、この訳による補完】
</li>
				</ol>
			</li>
			<li>
~ELSE
⇒
~GOTO `fallback$i
◎
↑</li>
		</ol>
	</li>
	<li>
%data ~LET ［
%O は `data$aO 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
%type ~LET ［
%O は `type$aO 属性を有するならば その値 ／
~ELSE_ ε
］
◎
↓</li>
	<li>
~IF［
%data ~IN { ε, 空~文字列 }
］
⇒
~GOTO `~dataなし$i
◎
If the data attribute is present and its value is not the empty string, then:
</li>
	<li>
~IF［
%type ~NEQ ε
］~AND［
%type は~UA~supportする型でない
］~AND［
%type は~UAが`~plugin$を見出せる型でない
］
⇒
~UAの任意選択で
⇒
~GOTO `fallback$i
（その実の型を検分するために内容を~fetchすることなく。）
◎
If the type attribute is present and its value is not a type that the user agent supports, and is not a type that the user agent can find a plugin for, then the user agent may jump to the step below labeled fallback without fetching the content to examine its real type.
</li>
	<li>
%~url ~LET %data を
%O の`~node文書$に`相対的に構文解析-$した`結果の~URL~record$
◎
Parse the URL specified by the data attribute, relative to the element's node document.
</li>
	<li>
<p>
~IF［
%~url ~EQ ~error
］：
</p>

<ol ><li>%O に向けて，名前 `error$et の`~eventを発火する$
</li><li>~GOTO `fallback$i
</li></ol>
◎
If that failed, fire an event named error at the element, then jump to the step below labeled fallback.
</li>
	<li>
%要請 ~LET 次のようにされた新たな`要請$
⇒＃
`~url$rq ~SET %~url,
`~client$rq ~SET %O の`~node文書$の `Window$I ~objの`環境~設定群~obj$,
`行先$rq ~SET `object^l,
`資格証~mode$rq ~SET `include^l,
`~URL資格証~利用~flag$rq ~SET ~ON
◎
Let request be a new request whose url is the resulting URL record, client is the element's node document's Window object's environment settings object, destination is "object", credentials mode is "include", and whose use-URL-credentials flag is set.
</li>
	<li>
<p>
%要請 を`~fetch$する：
◎
Fetch request.
</p>
		<ul>
			<li>
資源の~fetchingは、［
資源が~fetchされ，`~network用~task源$から`~queueされ$る`~task$（次の段を見よ）が走る
］まで，
%O の`~node文書$を`~load~eventを遅延-$し~MUST。
◎
Fetching the resource must delay the load event of the element's node document until the task that is queued by the networking task source once the resource has been fetched (defined next) has been run.
</li>
			<li>
【<a href="~NAVI#offline">~app~cache関連の記述</a>】
◎
For the purposes of the application cache networking model, this fetch operation is not for a child browsing context (though it might end up being used for one after all, as defined below).
</li>
		</ul>

【以下に現れる “資源” は、~fetchingにより得られた資源を指す。】

	</li>
	<li>
~IF［
資源は まだ可用でない（例：資源は~cache内に可用でなかったので、資源を読込むためには~network越しに要請を発行することが要求される）
］
⇒
~GOTO `fallback$i
— ただし
⇒
`~network用~task源$から`~queueされ$た`~task$は、資源が可用になり次第，この~algoをこの段から再開し~MUST。
資源は増分的に読込める
— ~UAは資源の処理を始めるに十分な~dataが得られ次第、資源を “可用” と見なしてよい。
<!-- opt to -->
◎
If the resource is not yet available (e.g. because the resource was not available in the cache, so that loading the resource required making a request over the network), then jump to the step below labeled fallback. The task that is queued by the networking task source once the resource is available must restart this algorithm from this step. Resources can load incrementally; user agents may opt to consider a resource "available" whenever enough data has been obtained to begin processing the resource.
</li>
	<li>
<p>
~IF［
資源を読込むのに失敗した（例： ~HTTP 404 ~error ／ ~DNS~errorが生じた）
］：
</p>

<ol ><li>%O に向けて，名前 `error$et の`~eventを発火する$
</li><li>~GOTO `fallback$i
</li></ol>
◎
If the load failed (e.g. there was an HTTP 404 error, there was a DNS error), fire an event named error at the element, then jump to the step below labeled fallback.
</li>
	<li id="object-type-detection">
<p>
%資源~型 ~LET 次の下位手続きを走らせた結果：
◎
Determine the resource type, as follows:
</p>

		<ol>
			<li>
%Content-Type ~LET ［
資源には `~Content-Type~metadata$が結付けられているならば それが指定する型 ／
~ELSE_ ε
］
◎
↓</li>
			<li>
<p>
~IF［
%O は `typemustmatch$aO 属性を有する
］：
</p>
				<ol>
					<li>
~IF［
%type ~NEQ ε
］~AND［
%Content-Type ~NEQ ε
］~AND［
%Content-Type は`~ASCII大小無視$で %type に合致する
］
⇒
~RET %type
</li>
					<li>
~RET `未知^i
</li>
				</ol>
◎
Let the resource type be unknown.
◎
If the object element has a type attribute and a typemustmatch attribute, and the resource has associated Content-Type metadata, and the type specified in the resource's Content-Type metadata is an ASCII case-insensitive match for the value of the element's type attribute, then let resource type be that type and jump to the step below labeled handler.
◎
If the object element has a typemustmatch attribute, jump to the step below labeled handler.
</li>
			<li>
<p>
~IF［
~UAは この資源に対しては、 `Content-Type^h ~headerに厳格に順守するよう環境設定されている
］~AND［
%Content-Type ~NEQ ε
］
⇒
~RET %Content-Type
◎
If the user agent is configured to strictly obey Content-Type headers for this resource, and the resource has associated Content-Type metadata, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.
</p>

<p class="warning">
これは、次のようなときに脆弱性をもたらし得る：
ある~siteが特定0の~pluginが利用される
【ものと期待して，頁に】
資源を埋込もうとしたが、遠隔~siteはそれを上書きして，代わりに［
保安~上の特徴が異なる，別の~plugin
］を誘発させるような
【Content-Type~headerを伴わせて】
資源を~UAに~~供給したときに。
◎
This can introduce a vulnerability, wherein a site is trying to embed a resource that uses a particular plugin, but the remote site overrides that and instead furnishes the user agent with a resource that triggers a different plugin with different security characteristics.
</p>

			</li>
			<li>
~IF［
%type ~NEQ ε
］~AND［
%type は~UAが~supportする型でない
］~AND［
%type は ある`~plugin$が<em>~supportする</em>型である
］
⇒
~RET %type
◎
If there is a type attribute present on the object element, and that attribute's value is not a type that the user agent supports, but it is a type that a plugin supports, then let the resource type be the type specified in that type attribute, and jump to the step below labeled handler.
</li>
			<li>
<p>
~IF［
%Content-Type ~NEQ ε
］：
◎
Run the appropriate set of steps from the following list:
◎
If the resource has associated Content-Type metadata
</p>
				<ol>
					<li>
<p>
%~binary ~LET［
次のいずれかが満たされるならば ~T ／
~ELSE_ ~F
］：
</p>

<ul><li>［
%Content-Type ~EQ `text/plain$mt
］~AND［
資源に`~textか~binaryかを判別する規則$を適用した結果 ~NEQ `text/plain$mt
］
</li><li>%Content-Type ~EQ `application/octet-stream$mt
</li></ul>

◎
Let binary be false.
◎
If the type specified in the resource's Content-Type metadata is "text/plain", and the result of applying the rules for distinguishing if a resource is text or binary to the resource is that the resource is not text/plain, then set binary to true.
◎
If the type specified in the resource's Content-Type metadata is "application/octet-stream", then set binary to true.
</li>
					<li>
~IF［
%~binary ~EQ ~F
］
⇒
~RET %Content-Type
◎
If binary is false, then let the resource type be the type specified in the resource's Content-Type metadata, and jump to the step below labeled handler.
</li>
					<li>
<p>
~IF［
%type ~NIN { ε, `application/octet-stream$mt }
］：
◎
If there is a type attribute present on the object element, and its value is not application/octet-stream, then run the following steps:
</p>

						<ol>
							<li>
~IF［
%type は`~plugin$が~supportする型である
］
⇒
~RET %type
◎
↓</li>
							<li>
~IF［
%type は `image/^l から開始している
］~AND［
%type は`~XML~MIME型$ではない
］
⇒
~RET %type
◎
If the attribute's value is a type that a plugin supports, or the attribute's value is a type that starts with "image/" that is not also an XML MIME type, then let the resource type be the type specified in that type attribute.
</li>
							<li>
~RET `未知^i
◎
Jump to the step below labeled handler.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, if the resource does not have associated Content-Type metadata
</p>
				<ol>
					<li>
~IF［
%type ~EQ ε
］
⇒
%type ~SET `資源に算出される~MIME型$
◎
If there is a type attribute present on the object element, then let the tentative type be the type specified in that type attribute.
◎
Otherwise, let tentative type be the computed type of the resource.
</li>
					<li>
~IF［
%type ~NEQ `application/octet-stream$mt
］
⇒
~RET %type
◎
If tentative type is not application/octet-stream, then let resource type be tentative type and jump to the step below labeled handler.
</li>
				</ol>
			</li>
			<li>
%~URL ~LET `~URL構文解析する$( 資源の（~redirect後の）~URL ) 
◎
If applying the URL parser algorithm to the URL of the specified resource (after any redirects)＼
</li>
			<li>
<p>
~IF［
%~URL ~NEQ `失敗^i
］~AND［
%~URL の`~path$urlは ある`~plugin$が~supportする~patternに合致する
］
⇒
~RET その~pluginが取扱える型
◎
results in a URL record whose path component matches a pattern that a plugin supports, then let resource type be the type that that plugin can handle.
</p>

<p class="example">
例えば，ある~pluginは、［
`~path$url 成分が文字列 `.swf^l で終端する
］ような資源を取扱えるものとしていることもある。
◎
For example, a plugin might say that it can handle resources with path components that end with the four character string ".swf".
</p>
			</li>
			<li>
~RET `未知^i
◎
It is possible for this step to finish, or for one of the substeps above to jump straight to the next step, with resource type still being unknown. In both cases, the next step will trigger fallback.
</li>
		</ol>
	</li>
	<li>
%B ~LET %O が`入子にしている閲覧文脈$
◎
↓</li>
	<li>
~IF［
%資源~型 ~EQ `未知^i
］
⇒
~GOTO `fallback$i
◎
↑↓</li>
	<li>
<p>
次のうち， %資源~型 が最初に満たす条件に応じて、対応する段に従って資源の内容を取扱う：
◎
Handler: Handle the content as given by the first of the following cases that matches:
</p>
		<dl class="switch">
			<dt>
［
%資源~型 は ~UAが~supportする型でない
］~AND［
%資源~型 は ある`~plugin$が~supportする型である
］：
◎
If the resource type is not a type that the user agent supports, but it is a type that a plugin supports
</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
%B ~NEQ ~NULL
］：
</p>

<ol ><li>`閲覧文脈を破棄する$( %B )
</li><li>%O が`入子にしている閲覧文脈$ ~SET ~NULL
</li></ol>
◎
If the object element's nested browsing context is non-null, then it must be discarded and then set to null.
</li>
					<li>
~IF［
その~pluginは`~sandbox化されて$いる
］~AND［
その~pluginは`保安化-$できない
］
⇒
~GOTO `fallback$i
◎
If plugins are being sandboxed and the plugin that supports resource type cannot be secured, jump to the step below labeled fallback.
</li>
					<li>
~UAは その`~pluginを利用するべき$である
— その`~plugin$には資源の内容も渡すべきである
◎
↓</li>
					<li>
~IF［
`~plugin$から~errorが報告された
］
⇒
~GOTO `fallback$i
◎
Otherwise, the user agent should use the plugin that supports resource type and pass the content of the resource to that plugin. If the plugin reports an error, then jump to the step below labeled fallback.
</li>
				</ol>
			</dd>

			<dt>
%資源~型 は`~XML~MIME型$である：
◎
↓</dt>
			<dt>
%資源~型 は `image/^l から開始していない：
◎
If the resource type is an XML MIME type, or if the resource type does not start with "image/"
</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
%B ~EQ ~NULL
］：
</p>

<ol ><li>%B ~SET `新たな閲覧文脈を作成する$()
</li><li>%O が`入子にしている閲覧文脈$  ~SET %B
</li></ol>
◎
If the object element's nested browsing context is null, set the element's nested browsing context to a newly-created browsing context.
◎
The object element must be associated with a newly created nested browsing context, if it does not already have one.
</li>
					<li>
<p>
~IF［
所与の資源の`~URL$は `about_blank$sc でない
］
⇒
次を与える下で， %B をその資源へ`~navigate$する
⇒＃
`置換~可能化~flag$ ~SET ~ON,
`~source閲覧文脈$ ~SET %O の`~node文書$が`属する閲覧文脈$
</p>

<p>
（ %O の `data$aO 属性は、 %B が更に他の所在に~navigateされても更新されない。）
</p>

◎
If the URL of the given resource is not about:blank, the element's nested browsing context must then be navigated to that resource, with replacement enabled, and with the object element's node document's browsing context as the source browsing context. (The data attribute of the object element doesn't get updated if the browsing context gets further navigated to other locations.)
</li>
					<li>
<p>
~ELSE
⇒
次を走らす`~taskを~queueする$
⇒
%O に向けて名前 `load$et の`~eventを発火する$
</p>

<p class="note">注記：
`load$et ~eventは、 `about_blank$sc 文書に向けては発火されない。
</p>
◎
If the URL of the given resource is about:blank, then, instead, the user agent must queue a task to fire an event named load at the object element. No load event is fired at the about:blank document itself.
</li>
					<li>
この時点で、
%O は`入子の閲覧文脈$を`表現-$する
◎
The object element represents the nested browsing context.
</li>
					<li>
%B の`閲覧文脈~名$ ~SET
%O が `name$aO 属性を［
有するならば その値 ／
有さないならば 空~文字列
］
◎
If the name attribute is present, the object element's nested browsing context's browsing context name must be set to the value of this attribute; otherwise, the browsing context name must be set to the empty string.
</li>
				</ol>

<p class="note">注記：
【<a href="~NAVI#offline">~app~cache関連の記述</a>】
◎
In certain situations, e.g., if the resource was fetched from an application cache but it is an HTML file with a manifest attribute that points to a different application cache manifest, the navigation of the browsing context will be restarted so as to load the resource afresh from the network or a different application cache. Even if the resource is then found to have a different type, it is still used as part of a nested browsing context: only the navigate algorithm is restarted, not this object algorithm.
</p>
			</dd>

			<dt>
（ %資源~型 は `image/^l から開始していて，）
画像の~supportは不能化されていない：
◎
If the resource type starts with "image/", and support for images has not been disabled
</dt>
			<dd>
				<ol>
					<li>
<p>
~IF［
%B ~NEQ ~NULL
］：
</p>

<ol ><li>`閲覧文脈を破棄する$( %B )
</li><li>%O が`入子にしている閲覧文脈$ ~SET ~NULL
</li></ol>
◎
If the object element's nested browsing context is non-null, then it must be discarded and then set to null.
</li>
					<li>
`画像の~sniffing$規則を適用して，画像の型を決定する
◎
Apply the image sniffing rules to determine the type of the image.
</li>
					<li>
この時点で、
%O は指定された画像を`表現-$する
◎
The object element represents the specified image.
</li>
					<li>
~IF［
画像を具現化できない（例：~dataは~~不正な形式である／その形式は未~supportである，など）†
］
⇒
~GOTO `fallback$i
◎
If the image cannot be rendered, e.g. because it is malformed or in an unsupported format, jump to the step below labeled fallback.
</li>
				</ol>
			</dd>
			<dd class="trans-note">【†
具現化できなくても，画像を表現すると見なされる？
】</dd>

			<dt>
その他：
◎
Otherwise
</dt>
			<dd>
~GOTO `fallback$i
（ %資源~型 は~supportされていない。）
◎
The given resource type is not supported. Jump to the step below labeled fallback.
◎
If the previous step ended with the resource type being unknown, this is the case that is triggered.
</dd>
		</dl>
	</li>
	<li>
資源が完全に読込まれた時点で，次を走らす`~taskを~queueする$ようにしておく
⇒
%O に向けて名前 `load$et の`~eventを発火する$
◎
↓</li>
	<li>
~RET
— この時点で，
%O の内容は %O が表現するものの一部を成さないとされる
◎
The element's contents are not part of what the object element represents.
◎
Return. Once the resource is completely loaded, queue a task to fire an event named load at the element.
</li>
	<li>
<p>
`~dataなし@i：
</p>

		<ol>
			<li>
~IF［
%data ~EQ 空~文字列
］~OR［
%type ~EQ ε
］
⇒
~GOTO `fallback$i
</li>
			<li>
<p>
~IF［
~UAは %type に則って相応しい`~plugin$を見出せる
］：
</p>
				<ol>
					<li>
~IF［
その~pluginは`~sandbox化されて$いる
］~AND［
その~pluginは`保安化-$できない
］
⇒
~GOTO `fallback$i
</li>
					<li>
~UAは、その`~pluginを利用するべき$である
</li>
					<li>
~IF［
その`~plugin$から~errorが報告された
］
⇒
~GOTO `fallback$i
</li>
					<li>
その~pluginが完全に読込まれた時点で，次を走らす`~taskを~queueする$ようにしておく
⇒
%O に向けて，名前 `load$et の`~eventを発火する$
</li>
					<li>
~RET
</li>
				</ol>
			</li>
		</ol>
◎
If the data attribute is absent but the type attribute is present, and the user agent can find a plugin suitable according to the value of the type attribute, and either plugins aren't being sandboxed or the plugin can be secured, then that plugin should be used. If these conditions cannot be met, or if the plugin reports an error, jump to the step below labeled fallback. Otherwise return; once the plugin is completely loaded, queue a task to fire an event named load at the element.
</li>
	<li>
<p>
`fallback@i：
この時点で、
%O は［
%O の子のうち， `param$e 要素~以外のもの
］を`表現-$する
— それらが %O の`~fallback内容$になる
◎
Fallback: The object element represents the element's children, ignoring any leading param element children. This is the element's fallback content.＼
</p>
		<ol>
			<li>
~IF［
%O が~instance化した`~plugin$はある
］
⇒
その~pluginを未読込みにする
◎
If the element has an instantiated plugin, then unload it.＼
</li>
			<li>
<p>
~IF［
%B ~NEQ ~NULL
］：
</p>

<ol ><li>`閲覧文脈を破棄する$( %B )
</li><li>%O が`入子にしている閲覧文脈$ ~SET ~NULL
</li></ol>

◎
If the element's nested browsing context is non-null, then it must be discarded and then set to null.
</li>
		</ol>
	</li>
</ol>

<p id="object-plugin">
~UAは，上の~algoにて 
`object$e 要素 %O に対し
ある`~plugin$を~instance化して利用するときは：
◎
When the algorithm above instantiates a plugin,＼
</p>

<ul>
	<li>
<p>
次に挙げる順による各~parameterを，その~pluginに渡すべきである：
</p>

<ol ><li>%O 上のすべての属性の名前と値
— 構文解析器により追加された各 属性は~source順序で
</li><li>名前 `PARAM^l, 値 ~NULL にされた~parameter
</li><li>%O の子である `param$e 要素すべての`~parameter$の名前と値
— 要素の`木~順序$で
</li></ol>
◎
the user agent should pass to the plugin used the names and values of all the attributes on the element, in the order they were added to the element, with the attributes added by the parser being ordered in source order, followed by a parameter named "PARAM" whose value is null, followed by all the names and values of parameters given by param elements that are children of the object element, in tree order.＼
</li>
	<li>
`~plugin$が~script可能な~interfaceを~supportする場合、
%O を表現している `HTMLObjectElement$I ~objは，その~interfaceを公開するべきである。
◎
If the plugin supports a scriptable interface, the HTMLObjectElement object representing the element should expose that interface.＼
</li>
	<li>
%O は`~plugin$を`表現-$する。
`~plugin$は入子の`閲覧文脈$ではない。
◎
The object element represents the plugin. The plugin is not a nested browsing context.
</li>
</ul>

<p><!--  id="sandboxPluginObject" -->
~pluginは、 `object$e 要素の目的においては，［
`閲覧文脈~sandbox化( ~plugin )~flag$ ~IN 要素の`~node文書$の`作動中の~sandbox法~flag集合$
］ならば
`~sandbox化されて@
いるものと見なされる。
◎
Plugins are considered sandboxed for the purpose of an object element if the sandboxed plugins browsing context flag is set on the object element's node document's active sandboxing flag set.
</p>

<p>
`object$e 要素の内容は、［
上の~algoに因り，参照した資源を示せない場合（例：404~errorが返されたなど）
］に限り，利用される`~fallback内容$として動作する。
これにより、複数の `object$e 要素を入子にすれば，能力が相異なる複数の~UAを対象にできるようになる
— ~UAは，自身が~supportする最初のものを選ぶことになる。
◎
Due to the algorithm above, the contents of object elements act as fallback content, used only when referenced resources can't be shown (e.g. because it returned a 404 error). This allows multiple object elements to be nested inside each other, targeting multiple user agents with different capabilities, with the user agent picking the first one it supports.
</p>

<div >
<p>
`object$e 要素が`入子にしている閲覧文脈$ %B （~NEQ ~NULL ）にて`作動中の文書$ %文書 に対し，次のいずれかが満たされている間は、要素は %文書 の`~load~eventを遅延-$し~MUST：
</p>

<ul><li>%文書 の`読込後~taskは準備済み$でない
</li><li>%文書 の`~load~eventを遅延-$している何かがある
</li><li>%B は`~load~event遅延-中~mode$下にある
</li></ul>

◎
When an object element's nested browsing context is non-null: if the object element's nested browsing context's active document is not ready for post-load tasks, and when anything is delaying the load event of the object element's browsing context's active document, and when the object element's browsing context is in the delaying load events mode, the object must delay the load event of its document.
</div>

<p>
この節に言及された`~task$の`~task源$は、`~DOM操作~task源$とする。
◎
The task source for the tasks mentioned in this section is the DOM manipulation task source.
</p>

<p>
`object$e 要素が画像を表現している場合、
`usemap$a 属性を用いて`画像~map$を結付けるよう指示できる。
この属性は、画像を表現していない `object$e 要素に対しては，無視され~MUST。
◎
The usemap attribute, if present while the object element represents an image, can indicate that the object has an associated image map. The attribute must be ignored if the object element doesn't represent an image.
</p>

<p>
`form$a 属性は、
`object$e 要素の`~form所有者$を明示的に指定するために利用される。
◎
The form attribute is used to explicitly associate the object element with its form owner.
</p>

<p><strong>拘束~検証</strong>
⇒
`object$e 要素は、常に`拘束~検証の対象外$とする。
◎
Constraint validation: object elements are always barred from constraint validation.
</p>


<p>
`object$e 要素は、`寸法~属性$を~supportする。
◎
The object element supports dimension attributes.
</p>

<dl class="idl-def">
	<dt>`data@mO</dt>
	<dt>`type@mO</dt>
	<dt>`name@mO</dt>
	<dt>`typeMustMatch@mO</dt>
	<dt>`useMap@mO</dt>
	<dd>
順に，（小文字~化した名前の）［
`data$aO,
`type$aO,
`name$aO,
`typemustmatch$aO,
`usemap$a
］内容~属性を`反映-$し~MUST。
◎
The IDL attributes data, type and name each must reflect the respective content attributes of the same name.＼
The typeMustMatch IDL attribute must reflect the typemustmatch content attribute.＼
The useMap IDL attribute must reflect the usemap content attribute.
</dd>

	<dt>`contentDocument@mO</dt>
	<dd>
取得子は、此れの`内容~文書$を返さ~MUST。
◎
The contentDocument IDL attribute, on getting, must return the object element's content document.
</dd>

	<dt>`contentWindow@mO</dt>
	<dd>
取得子は、此れが`入子にしている閲覧文脈$ %B  に応じて，［
非 ~NULL ならば %B の `WindowProxy$I ~obj ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The contentWindow IDL attribute must return the WindowProxy object of the object element's nested browsing context, if its nested browsing context is non-null; otherwise, it must return null.
</dd>
</dl>

<ul>
	<li>
`willValidate$m,
`validity$m,
`validationMessage$m
属性, および
`checkValidity()$m,
`reportValidity()$m,
`setCustomValidity()$m
~methodは、`拘束~検証~API$の一部である。
◎
The willValidate, validity, and validationMessage attributes, and the checkValidity(), reportValidity(), and setCustomValidity() methods, are part of the constraint validation API.＼
</li>
	<li>
`form$m ~IDL属性は、要素の~form~APIの一部である。
◎
The form IDL attribute is part of the element's forms API.
</li>
</ul>


<div class="example">

<p>
次の例の~HTML頁は、 `object$e 要素を用いて，別の頁を埋込んでいる。
◎
In this example, an HTML page is embedded in another using the object element.
</p>

`object-2^xCode

</div>

<div class="example">

<p>
次の例に ~pluginを~HTML内で利用する方法を示す（この事例では、動画~fileを示す~Flash~plugin）。
~Flashは可能化されていないが `video$e は~supportする~UA利用者~向けには、~fallbackとして，動画を示す `video$e 要素を供している。
最後に，~Flashも `video$e 能力も備えない~browser利用者~向けには、動画への~linkを供している。
◎
The following example shows how a plugin can be used in HTML (in this case the Flash plugin, to show a video file). Fallback is provided for users who do not have Flash enabled, in this case using the video element to show the video for those using user agents that support video, and finally providing a link to the video for those who have neither Flash nor a video-capable browser.
</p>

`object-3^xCode

</div>


			</section>
			<section id="the-param-element">
<h3 title="The param element">4.8.8. `param^e 要素</h3>

<dl class="element-def">
	<dt>`分類$</dt>
	<dd>
なし。
◎
None.
</dd>

	<dt>`この要素を利用できる文脈$</dt>
	<dd>
`object$e 要素の子として
— ただし，同胞のどの`~flow内容$よりも前。
◎
As a child of an object element, before any flow content.
</dd>

	<dt>`内容~model$</dt>
	<dd>
`なし$。
◎
Nothing.
</dd>

	<dt>`text/html における~tag省略$</dt>
	<dd>
`終了tag$はない。
◎
No end tag.
</dd>

	<dt>`内容~属性$</dt>
	<dd>
`大域~属性$
◎
Global attributes
</dd>
	<dd>
`name$aP
— ~parameterの名前
◎
name — Name of parameter
</dd>
	<dd>
`value$aP
— ~parameterの値
◎
value — Value of parameter
</dd>

	<dt>`~DOM~interface$</dt>
	<dd>
<pre class="idl">
[Exposed=Window,
 `HTMLConstructor$]
interface `HTMLParamElement@I : `HTMLElement$I {
  [`CEReactions$] attribute DOMString `name$mP;
  [`CEReactions$] attribute DOMString `value$mP;
};
</pre>
	</dd>
</dl>

<p>
`param$e 要素は、 `object$e 要素により呼出される~plugin用の~parameterを定義する
— それは、自身のみでは何も`表現-$しない。
◎
The param element defines parameters for plugins invoked by object elements. It does not represent anything on its own.
</p>

<p>
`param$e 要素の
`name@aP,
`value@aP
属性は：
◎
↓
</p>
<ul>
	<li>
順に、~parameterの［
名前, 値
］を与える。
◎
The name attribute gives the name of the parameter.
◎
The value attribute gives the value of the parameter.
</li>
	<li>
要素は、これら両~属性とも有してい~MUST。
◎
Both attributes must be present.＼
</li>
	<li>
両~属性とも，値は何でもよい。
◎
They may have any value.
</li>
	<li>
［
要素が両~属性とも有する
］~AND［
要素の親~要素は `object$e 要素である
］ならば、要素は，所与の［
名前, 値
］~pairを伴う
`~parameter@
を定義する。
◎
If both attributes are present, and if the parent element of the param is an object element, then the element defines a parameter with the given name-value pair.
</li>
</ul>

<p>
`param$e 要素が［
~instance化された`~plugin$を`表現-$する `object$e 要素の子である
］~AND［
~UAは、`~plugin$を更新する能を備える~API特色機能を利用して，`~plugin$と通信している
］下で，要素が定義する`~parameter$の［
名前または値
］が変化したときは、~UAは 更新する能を適切に行使して，`~plugin$に変化を通知し~MUST。
◎
If either the name or value of a parameter defined by a param element that is the child of an object element that represents an instantiated plugin changes, and if that plugin is communicating with the user agent using an API that features the ability to update the plugin when the name or value of a parameter so changes, then the user agent must appropriately exercise that ability to notify the plugin of the change.
</p>


<dl class="idl-def">
	<dt>`name@mP</dt>
	<dt>`value@mP</dt>
	<dd>
順に，（同じ名前の）［
`name$aP,
`value$aP
］内容~属性を`反映-$し~MUST。
◎
The IDL attributes name and value must both reflect the respective content attributes of the same name.
</dd>
</dl>


<div class="example">

<p>
`param$e 要素を用いて、~parameterを~plugin（この事例では、 O3D ~plugin）に渡す例：
◎
The following example shows how the param element can be used to pass a parameter to a plugin, in this case the O3D plugin.
</p>

`param-1^xCode

</div>
			</section>
			<section id="_other-sections-2">
<h3>4.8.9. 〜 4.8.15.</h3>

<p>
これらの節の和訳は
<a href="~HEimages#_toc">別ページ（画像~関連）</a> ／
<a href="~HEmedia#_toc">別ページ（~media要素）</a>
にて。
</p>

			</section>
			<section id="mathml">
<h3>4.8.16. ~MathML</h3>

<p>
~MathML `math$e 要素は、この仕様における内容~modelの目的においては，［
`埋込みの内容$ ／ `句内容$ ／ `~flow内容$ ／ `可触~内容$
］に分類される。
◎
The MathML math element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.
</p>

<p>
~MathML `annotation-xml$e 要素が包含する，`~HTML名前空間$に属する要素は、`~flow内容$で~MUST。
◎
When the MathML annotation-xml element contains elements from the HTML namespace, such elements must all be flow content.
</p>

<p>
~HTML要素の子孫である~MathML~token要素（
`mi$e ／ `mo$e ／ `mn$e ／ `ms$e ／ `mtext$e
）は、`~HTML名前空間$に属する要素のうち，`句内容$を包含して~MAY。
◎
When the MathML token elements (mi, mo, mn, ms, and mtext) are descendants of HTML elements, they may contain phrasing content elements from the HTML namespace.
</p>

<p>
~UAは、~MathMLの［
内容~model, ~layout, 具現化
］の目的においては，［［
~MathML要素のうち，自身の内容~modelが直の~textを許容しないもの
］内に見出された，`要素間~空白$でない~text
］を［
実際には ~MathML `mtext$e 要素が当の~textを包装しているように装う
］ことにより，取扱わ~MUST。
（しかしながら、そのような~textは適合しない。）
◎
User agents must handle text other than inter-element whitespace found in MathML elements whose content models do not allow straight text by pretending for the purposes of MathML content models, layout, and rendering that the text is actually wrapped in a MathML mtext element. (Such text is not, however, conforming.)
</p>

<p>
~UAは、~MathMLの［
~layout, 具現化
］の目的においては，［
~MathML要素のうち，その内容が自身の内容~modelに合致しないもの
］に対しては［
何らかの適切な~error~messageを包含している，~MathML `merror$e 要素に置換されていた
］かのように動作し~MUST。
◎
User agents must act as if any MathML element whose contents does not match the element's content model was replaced, for the purposes of MathML layout and rendering, by a MathML merror element containing some appropriate error message.
</p>


<p>
［
作者が，~XML形による~MathMLのみを受容する~MathML~toolを利用できるようにする
］ため、対話的~HTML~UAには，［
~MathML素片を，~XML名前空間整形式の~XML素片として~exportする仕方
］を供することが奨励される。
◎
To enable authors to use MathML tools that only accept MathML in its XML form, interactive HTML user agents are encouraged to provide a way to export any MathML fragment as an XML namespace-well-formed XML fragment.
</p>

<p>
~MathML要素の意味論は、~MathML仕様, および他の`適用-可能な仕様$にて定義される。
`MATHML$r
◎
The semantics of MathML elements are defined by the MathML specification and other applicable specifications. [MATHML]
</p>

<div class="example">

<p>
~HTML文書~内での~MathMLの利用~例：
◎
Here is an example of the use of MathML in an HTML document:
</p>

`mathml-1^xCode

</div>

			</section>
			<section id="svg-0">
<h3 title="SVG">4.8.17. ~SVG</h3>

<p>
~SVG `svg$e 要素は、この仕様における内容~modelの目的においては，［
`埋込みの内容$ ／ `句内容$ ／ `~flow内容$ ／ `可触~内容$
］に分類される。
◎
The SVG svg element falls into the embedded content, phrasing content, flow content, and palpable content categories for the purposes of the content models in this specification.
</p>

<p>
［
作者が，~XML形による~SVGのみを受容する~SVG~toolを利用できるようにする
］ため、対話的~HTML~UAには，［
~SVG素片を，~XML名前空間整形式の~XML素片として~exportする仕方
］を供することが奨励される。
◎
To enable authors to use SVG tools that only accept SVG in its XML form, interactive HTML user agents are encouraged to provide a way to export any SVG fragment as an XML namespace-well-formed XML fragment.
</p>

<p>
~SVG `foreignObject$e 要素が包含する，`~HTML名前空間$に属する要素は、`~flow内容$で~MUST。
◎
When the SVG foreignObject element contains elements from the HTML namespace, such elements must all be flow content.
</p>

<p>
`~HTML文書$の内側における~SVG `~svg-title$e 要素の内容~modelは、`句内容$とする（これは、~SVG仕様が課す要件を更に拘束する）。
◎
The content model for the SVG title element inside HTML documents is phrasing content. (This further constrains the requirements given in the SVG specification.)
</p>

<p>
~SVG要素の意味論は、~SVG仕様と他の`適用-可能な仕様$にて定義される。
`SVG$r
◎
The semantics of SVG elements are defined by the SVG specification and other applicable specifications. [SVG]
</p>

<hr>


<dl class="domintro">
	<dt>%doc = %iframe . `getSVGDocument()$m</dt>
	<dt>%doc = %embed . `getSVGDocument()$m</dt>
	<dt>%doc = %object . `getSVGDocument()$m</dt>
	<dd>
［
`iframe$e ／ `embed$e ／ `object$e 
］要素が~SVG画像を埋込むために利用されている事例では、 `Document$I ~objを返す。
◎
Returns the Document object, in the case of iframe, embed, or object elements being used to embed SVG images.
</dd>
</dl>

<dl class="idl-def">
	<dt>`getSVGDocument()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getSVGDocument() method must run the following steps:
</p>
		<ol>
			<li>
%B ~LET 此れが`入子にしている閲覧文脈$
◎
↓</li>
			<li>
~IF［
%B ~EQ ~NULL
］
⇒
~RET ~NULL
◎
If the element's nested browsing context is null, then return null.
</li>
			<li>
%文書 ~LET %B にて`作動中の文書$
◎
↓</li>
			<li>
~IF［
( %文書 の`生成元$, 此れの`~node文書$の`生成元$ )
は `同じ生成元~domain$でない
］
⇒
~RET ~NULL
◎
If the origin of the active document of the nested browsing context is not same origin-domain with the element's node document's origin, then return null.
</li>
			<li>
~IF［
%文書 は、［
`~navigate$~algoにおいて`資源に算出される~MIME型$は `image/svg+xml$mt であった
］ため，
<a href="~NAVI#read-xml">~XML~fileに対する頁~読込み処理~model</a>
節により作成されたものである
］
⇒
~RET %文書 
◎
If the nested browsing context's active document was created by the page load processing model for XML files section because the computed type of the resource in the navigate algorithm was image/svg+xml, then return that Document object.
</li>
			<li>
~RET ~NULL
◎
Otherwise, return null.
</li>
		</ol>
	</dd>
</dl>

			</section>
			<section id="dimension-attributes">
<h3 title="Dimension attributes">4.8.18. 寸法~属性</h3>

<p>
<strong>作者~要件</strong>：
［
`img$e ／ `iframe$e ／ `embed$e ／ `object$e ／ `video$e ／ ［
`type$a 属性が `Image$st 状態にある `input$e
］］要素~上には、要素の視覚的~内容の寸法を`~CSS~pixel$単位で与える［
`width@a,
`height@a
］属性が指定されてよい（順に，出力~mediaの名目上の方向に相対的な［
横幅, 縦幅
］を与える）。
これらの属性に指定する値は、`妥当な非負~整数$で~MUST。
◎
Author requirements: The width and height attributes on img, iframe, embed, object, video, and, when their type attribute is in the Image Button state, input elements may be specified to give the dimensions of the visual content of the element (the width and height respectively, relative to the nominal direction of the output medium), in CSS pixels. The attributes, if specified, must have values that are valid non-negative integers.
</p>

<p>
指定される寸法は、資源~自身に指定されている寸法から相違してもよい
— 資源の解像度は`~CSS~pixel$の解像度から相違することもあるので。
（`~CSS~pixel$の解像度は、~screen上では 96ppi になるが，一般には 読み取り距離に依存する。）
両~属性とも指定された場合、次のいずれかが満たされ~MUST：
◎
The specified dimensions given may differ from the dimensions specified in the resource itself, since the resource may have a resolution that differs from the CSS pixel resolution. (On screens, CSS pixels have a resolution of 96ppi, but in general the CSS pixel resolution depends on the reading distance.) If both attributes are specified, then one of the following statements must be true:
</p>

<ul>
	<li>
%W − 0.5 ~LTE %H ÷ %iH × %iW ~LTE %W + 0.5
◎
specified width - 0.5 ≤ specified height * target ratio ≤ specified width + 0.5
</li>
	<li>
%H − 0.5 ~LTE %W ÷ %iW × %iH ~LTE %H + 0.5
◎
specified height - 0.5 ≤ specified width / target ratio ≤ specified height + 0.5
</li>
	<li>
%H = %W = 0
◎
specified height = specified width = 0
</li>
</ul>

<p>
— ここで、
%W, %H は，順に
`width$a, `height$a
属性の値とする。
%iW, %iH は，順に資源の［
`内在的~横幅$, `内在的~縦幅$
］とする。
◎
The target ratio is the ratio of the intrinsic width to the intrinsic height in the resource. The specified width and specified height are the values of the width and height attributes respectively.
</p>


<p>
当の資源が`内在的~横幅$も`内在的~縦幅$も持たない場合、両~属性とも省略され~MUST。
◎
The two attributes must be omitted if the resource in question does not have both an intrinsic width and an intrinsic height.
</p>

<p>
両~属性とも値が 0 の場合、要素は 利用者~向けに意図されていないことを指示する（例：頁が見られた回数を数える~service用途など）。
◎
If the two attributes are both zero, it indicates that the element is not intended for the user (e.g. it might be a part of a service to count page views).
</p>

<p class="note">注記：
寸法~属性には、画像を伸張するための用途は意図されていない。
◎
The dimension attributes are not intended to be used to stretch the image.
</p>

<p>
<strong>~UA要件</strong>：
~UAには、これらの属性を`具現化~用~hint$に利用することが期待される。
◎
User agent requirements: User agents are expected to use these attributes as hints for the rendering.
</p>

<p class="idl-def">
［
`iframe$e ／ `embed$e ／ `object$e ／ `video$e
］要素~上の
`width@m,
`height@m
~IDL属性は、順に，（同じ名前の）［
`width$a,
`height$a
］内容~属性を`反映-$し~MUST。
◎
The width and height IDL attributes on the iframe, embed, object, and video elements must reflect the respective content attributes of the same name.
</p>

<p class="note">注記：
これらの~IDL属性の型は、［
`iframe$e ／ `embed$e ／ `object$e
］に対しては `DOMString^I であるが，
`video$e に対しては `unsigned long^I である。
◎
For iframe, embed, and object the IDL attributes are DOMString; for video the IDL attributes are unsigned long.
</p>

<p class="note">注記：
［
`img$e ／ `input$e
］要素~上の対応する~IDL属性は、それぞれの要素の節にて定義される
— それらには、それらの要素の他の挙動に特有の~~面が少しばかりあるので。
◎
The corresponding IDL attributes for img and input elements are defined in those respective elements' sections, as they are slightly more specific to those elements' other behaviors.
</p>

			</section>
</main>
