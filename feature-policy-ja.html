<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Feature Policy （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<style>
pre.http-code {
	background: #EEE;
}

.feature {
	color: gray;
}

</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const link_map = this.link_map;
	const class_map = {
		P: 'production', // protocol element
		e: 'element',
		a: 'attr',
		aF: 'attr',
		dir: 'directive',
		ft: 'feature',
		h: 'header',
		U: 'code-point',
	};
	const tag_map = {
		p: 'var',
		P: 'code',
		dir: 'code',
		h: 'code',
		I: 'code',
		m: 'code',
		v: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		ft: 'code',
		aF: 'code',
		s: 'samp',
		U: 'span',
		i: 'i',
	}

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

let text = key;
let href = '';
let classname = class_map[klass];
let tag = tag_map[klass];

switch(klass){
case 'r': // 文献
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();
	break;
case 'l': //literal
	return '"<code class="literal">' + key +'</code>"'
	break;
case 'm' : // interface member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U': // 
	text = 'U+' + key;
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
}

if(tag) {
	text = '<' + tag +
		(classname ? ' class="' + classname + '">' : '>') +
		text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options

spec_title:Feature Policy
spec_date:2018-07-16
trans_update:2018-07-28
source_checked:180710
page_state_key:WEBAPPSEC
original_url:https://wicg.github.io/feature-policy/
spec_status:EDCG
ref_id_prefix:biblio-
ref_id_lowercase:true
	site_nav:
conformance:w3c
	copyright:2018,wicg
trans_1st_pub:2018-07-15


●●original_id_map

	dom-featurepolicyviolationreportbody-columnnumber:featurepolicyviolationreportbody-columnnumber
	dom-featurepolicyviolationreportbody-disposition:featurepolicyviolationreportbody-disposition
	dom-featurepolicyviolationreportbody-featureid:featurepolicyviolationreportbody-featureid
	dom-featurepolicyviolationreportbody-linenumber:featurepolicyviolationreportbody-linenumber
	dom-featurepolicyviolationreportbody-message:featurepolicyviolationreportbody-message
	dom-featurepolicyviolationreportbody-sourcefile:featurepolicyviolationreportbody-sourcefile

●●link_map

	●IDL
SameObject:~WEBIDL#SameObject
NoInterfaceObject:~WEBIDL#NoInterfaceObject

I.FeaturePolicyViolationReportBody:#featurepolicyviolationreportbody
I.Policy:#policy
I.ReportBody:~REPORTING#reportbody
I.Node:~DOM4#node
I.Element:~DOM4#element
I.Document:~DOM4#document
I.HTMLIFrameElement:~HEembed#htmliframeelement
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest
I.XMLHttpRequest:~XHR#xmlhttprequest

m.~policyD:#dom-document-policy
m.document.policy:#dom-document-policy
m.~policyF:#dom-htmliframeelement-policy


m.columnNumber:#dom-featurepolicyviolationreportbody-columnnumber
m.disposition:#dom-featurepolicyviolationreportbody-disposition
m.featureId:#dom-featurepolicyviolationreportbody-featureid
m.lineNumber:#dom-featurepolicyviolationreportbody-linenumber
m.message:#dom-featurepolicyviolationreportbody-message
m.sourceFile:#dom-featurepolicyviolationreportbody-sourcefile
	columnNumber:#featurepolicyviolationreportbody-columnnumber
	disposition:#featurepolicyviolationreportbody-disposition
	featureId:#featurepolicyviolationreportbody-featureid
	lineNumber:#featurepolicyviolationreportbody-linenumber
	message:#featurepolicyviolationreportbody-message
	sourceFile:#featurepolicyviolationreportbody-sourcefile

m.allowedFeatures:#dom-policy-allowedfeatures
m.allowsFeature:#dom-policy-allowsfeature
m.getAllowlistForFeature:#dom-policy-getallowlistforfeature

m.getUserMedia:https://w3c.github.io/mediacapture-main/#dom-mediadevices-getusermedia
	m.getUserMedia():~HTMLINFRA#dom-mediadevices-getusermedia
m.requestFullscreen:~FULLSCREEN#dom-element-requestfullscreen
m.allow:~HEembed#dom-iframe-allow
	m.allow:#dom-htmliframeelement-allow
m.document.fullscreenEnabled:~FULLSCREEN#dom-document-fullscreenenabled


e.iframe:~HEembed#the-iframe-element

a.allow:#iframe-allow-attribute

aF.sandbox:~HEembed#attr-iframe-sandbox
aF.src:~HEembed#attr-iframe-src
aF.allow:~HEembed#attr-iframe-allow
aF.allowfullscreen:~HEembed#attr-iframe-allowfullscreen
	#iframe-allowfullscreen-attribute
aF.allowpaymentrequest:~HEembed#attr-iframe-allowpaymentrequest
	#iframe-allowpaymentrequest-attribute
aF.allowusermedia:~HEembed#attr-iframe-allowusermedia
	#iframe-allowusermedia-attribute

dir.sandbox:~CSP3#sandbox

P.*:#the-special-value
i.全~生成元:#_any-origin
P.serialized-feature-policy:#serialized-feature-policy
P.serialized-policy-directive:#serialized-policy-directive
直列形の特色機能~施策:#serialized-policy-directive
P.feature-identifier:#feature-identifier
P.allow-list:#allow-list
P.allow-list-value:#allow-list-value
P.serialized-origin:#serialized-origin

h.Feature-Policy:#feature-policy-header

	●用語


特色機能~施策を初期化する:#initialize-for-document
応答からの特色機能~施策で文書のそれを初期化する:#initialize-from-response
	~allow属性を構文解析する:#parse-allow-attribute
指令を宣言-済み施策に併合する:#merge-directive-with-declared-policy
値と生成元から~headerを構文解析する:#parse-header
値と生成元から施策~指令を構文解析する:#parse-policy-directive
特色機能~施策~属性を処理する:#process-feature-policy-attributes
応答~施策を処理する:#process-response-policy
pd.~ASCII直列化:#ascii-serialization
特色機能~用に継承される施策を定義する:#define-inherited-policy
容器~内の特色機能~用に継承される施策を定義する:#define-inherited-policy-in-container

利用は許容される:~HEembed#allowed-to-use
	利用は許容される:#allowed-to-use
許容list:#allowlist
	§許容-属性:#iframe-allow-attribute
容器~施策:#container-policy
宣言された特色機能~施策:#declared-policy
宣言-済み施策:#declared-policy
既定の許容list:#default-allowlist

空の特色機能~施策:#empty-feature-policy
特色機能は施策により生成元~用に可能化されるか？:#is-feature-enabled

施行する:#enforce
施行-:#enforce
許容listは生成元に合致する:#matches

特色機能:#policy-controlled-feature
特色機能~施策:#feature-policy
~header施策:#header-policy
継承される施策:#inherited-policy
継承した施策:#inherited-policy
特色機能~用に継承される施策:#inherited-policy-for-a-feature

施策により制御される特色機能:#policy-controlled-feature
特色機能:#policy-controlled-feature
施策~指令:#policy-directive
~support済み特色機能:#supported-features

違反:#violate
違反-:#violate
結付けられている~node:#associated-node
宣言された生成元:#declared-origin
既定の生成元:#default-origin
観測-可能な施策:#observable-policy
特色機能~施策~違反~報告:#feature-policy-violation-reports
doc.施策~obj:#document-policy-object
iF.施策~obj:#iframe-policy-object


	●外部
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII小文字~化する:~INFRA#ascii-lowercase
~ASCII空白で分割する:~INFRA#split-on-ascii-whitespace
~commaで分割する:~INFRA#split-on-commas
区切子で厳密に分割する:~INFRA#strictly-split
有順序~集合:~INFRA#ordered-set
有順序~map:~INFRA#ordered-map
構造体:~INFRA#struct

doc.特色機能~施策:~HTMLdom#concept-document-feature-policy

文書:~HTMLdom#the-document-object
	文書:~DOM4#concept-document

作動中の文書:~BROWSERS#active-document
閲覧文脈:~BROWSERS#browsing-context
入子の閲覧文脈:~BROWSERS#nested-browsing-context
入子にしている閲覧文脈:~BROWSERS#nested-browsing-context
閲覧文脈~容器:~BROWSERS#browsing-context-container
~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
属する文書:~BROWSERS#concept-document-bc
親~閲覧文脈:~BROWSERS#parent-browsing-context
新たな閲覧文脈を作成する:~BROWSERS#creating-a-new-browsing-context

文書を初期化する:~NAVI#initialise-the-document-object
相対的に構文解析-:~HTMLurl#parse-a-url

生成元:~ORIGIN#concept-origin
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元の直列化:~ORIGIN#ascii-serialisation-of-an-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
生成元を直列化する:~ORIGIN#ascii-serialisation-of-an-origin

環境~設定群~obj:~WAPI#environment-settings-object

~node文書:~DOM4#concept-node-document

~URL構文解析する:~URL1#concept-url-parser
url.生成元:~URL1#concept-url-origin

応答:~FETCH#concept-response
	応答:~FETCH#concept-response-response＊原文誤
rs.~header~list:~FETCH#concept-response-header-list
名前に持つ~header:~FETCH#_headers-of-name
hd.値:~FETCH#concept-header-value
hd.結合-済みの値:~FETCH#concept-header-value-combined

報告:~REPORTING#report
rP.本体:~REPORTING#report-body
報告~種別:~REPORTING#report-type
報告用~観測器から可視:~REPORTING#visible-to-reportingobservers
報告先~group用に~dataを~queueする:~REPORTING#queue-report
	https://wicg.github.io/reporting//#queue-report

	施策:~CSP3#violation-policy → `Policy$I 


●●words_table1
REPORTING:reporting1-ja.html

policyD:policy
policyF:policy

●●words_table

	●施策／feature
特色機能:feature::~::フィーチャ
	特色機能~名:feature-name:~
	~support済み特色機能:recognized feature 
許容-:allow::~
	許容されない:disallow:~
許容list:allowlist::許容 list:許容リスト
指令:directive::~::ディレクティブ
提出-:submit::~
施策:policy::~:ポリシー
	施策により制御される:policy-controlled
施行-:enforce::~

camera::::カメラ
microphone::::マイクロフォン
script::::スクリプト
form::::フォーム

Vibration:
Geolocation:

	地理情報／^en:geolocation

報告-:report::~::レポート
報告:report::~::レポート
	報告のみ:report-only
	報告-法:reporting
報告用:reporting::~::レポート用
報告先:endpoint::~::レポート先
報告用:reporting:~
種別:type::~
可視:visible::~
本体:body::~::ボディ
列番号:column number:~
行番号:line number:~


	●環境
環境:environment::~
Worker:
Worklet:
frame::::フレーム
下位frame:subframe::下位 frame:下位フレーム
	~frame化され:framed
	`iframe^e:iframe
top-level::::トップレベル
入子の:nested:入れ子の
入子に:nest:入れ子に
内容:content::~
埋込む:embed する::埋め込む
埋込んで:embed して::埋め込んで
埋込んだ:embed した::埋め込んだ
埋込まれ:embed され::埋め込まれ
	自身が埋込む〜~host:embedee
	埋込んだ側／埋込む側:embedder
容器:container:::コンテナ
文書:document::~
閲覧文脈:browsing context::~
	閲覧:browsing::~
文脈:context::~
継承-:inherit::~
資源:resource::~
読込まれ:load され::読み込まれ::ロードされ
要素:element::~
親:parent::~
子:child::~
木:tree::~::ツリー
作動中の:active な::~::アクティブな
非同一生成元:cross-origin::~::クロスオリジン
同一生成元:same-origin::~::同一オリジン
生成元:origin::~::オリジン
第三者主体:third-party::~
可能化-:enable::~
	`可能化される^i:"Enabled"
不能化-:disable::~
	`不能化される^i:"Disabled"
	不能化-:off
不透明:opaque::~

頁:page:::ページ
site::::サイト
検索engine:search engine:::検索エンジン
plugin::::プラグイン
social-network:social network:::ソーシャルネットワーク

VR:
	~VR:vr
WebUSB:
WebVR:
fullscreen:

	●network
client::::クライアント
domain::::ドメイン
header::::ヘッダ
host::::ホスト
message::::メッセージ
server::::サーバ
serve::::サービス供与
social::::ソーシャル
url:
送達-:deliver::~
送達:delivery::~
通信-:communicate::~
受信-:receive::~
応答:response::~::レスポンス
protocol::::プロトコル
redirect::::リダイレクト

	●保安
privacy::::プライバシー
risk::::リスク
sandbox::::サンドボックス
	~sandbox法:sandboxing
security::::セキュリティ
access::::アクセス
予防策:precaution::~
注入-:inject::~
	監禁:lock down
抽出-:extract::~
検出-:detect::~
検出:detection::~
吟味-:examine::~
検分-:inspect::~
検査:check::~
安全:safe::~
懸念:concern::~
推定-:infer::~
攻撃者:attacker::~
是認-:grant::~
特権:privilege::~
脆弱:vulnerable::~
許可:permission::~
軽減-:mitigate::~
迂回-:bypass::~
違反-:violate::~
違反:violation::~
log-in:log in:::ログイン
強制-:force::~
	強制-法:forcing
予想外の:unanticipated:~
不自然な:contrived:~
予期-:expect:~
	予期することなく書かれた:not written with the expectation
公表-:publish::~
公開-:expose::~
公開:exposure::~
明示-:express:~
信用-:trust::~
	信用できない:potentially untrusted
care::::ケア
否認-:deny::~
漏洩-:leak::~
漏洩:leakage::~
露呈-:reveal::~

	~~影響は抑えられる:increase the chance that
	悪化させ:make worse
	無用に:needlessly
	最も重大な:biggest
	長期に存在していた:existing, long-standing


	●データ／構文
item::::アイテム
list::::リスト
	挙げ:list
map::::マップ
key::::キー
data::::データ
queue::::キュー
field::::フィールド
構造体:struct::~
有順序:ordered::~
集合:set::~
格納-:store::~
改変-:modify::~
拡充-:populate::~
構築-:construct::~
取得-:get::~
取得子:getter::~
設定-:set::~
設定群:settings::~
除去-:remove::~
付加-:append::~
作成-:create::~
置換-:replace::~
併合-:merge::~
結合-:combine::~
追加-:add:~
包含-:contain:~
照会-:query::~
検索取得-:retrieve::~
生成-:generate::~
初期:initial::~
初期化-:initialize::~
合致-:match::~
対応付ける:map する::~

ASCII:
keyword::::キーワード
comma::::カンマ
percent-::: %-
token::::トークン
error::::エラー
大小無視:case-insensitive::~
小文字:lowercase::~
空白:whitespace::~
宣言-:declare::~
宣言:declaration::~
空:empty::~
符号位置:code point::~
符号化-:encode::~::エンコード
直列化-:serialize::~::シリアル化
直列形の:serialized::~::シリアル形の
直列化:serialization::~::シリアル化
	直列化された宣言:serialized-declaration
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
文字:character::~
文字列:string::~
	文字列:character strings
失敗:failure::~
失敗-:fail::~
区切子:delimiter::~
分割-:split::~
厳密:strict::~
形成-:form:~
名:name:~
名前:name:~
命名-:name:~

属性:attribute::~
値:value:~
入力:input::~
表現-:represent::~
表現:representation::~
識別-:identify::~



	-:separated
	-:concatenation

	●仕様
API:
UA:user agent:UA
app:application:::アプリ
browser::::ブラウザ
custom::::カスタム
	~custom化:customize
framework::::フレームワーク
platform::::プラットフォーム
algo:algorithm:::アルゴリズム
web:

一貫して:consistentに:~
不可能:impossible:~
事例:case:~
互換性:compatibility:~
仕方:way:~
仕様:spec:~
仕組み:mechanism:~
処理能:performance:~
効果:effect:~
	効果を発揮している:in effect
有効:effective:~
単純:simple:~
	単純に:simply:~

供-:provide:~
保守-:maintain:~
処理-:process:~
利用者:user:~
	利用-:use:~
	利用して:using
制御:control:~
制約:restriction:~
制約的:restrictive:~
制限:limitation:~
制限-:limit:~
動作-:act:~
取組む:address する:取り組む
受持って:cover して:~

可用:available:~
アリ:possible:可能
	場合によっては:possibly
可能性:possibility:~
困難:hard:~
多彩:rich:~
	より多彩な:richer
多義性:ambiguity:~
姉妹:companion:~
将来:future:~
情報:information:~
手続き:steps:~
旧来の:legacy な:~
明確さ:clarity:~
明示的:explicit:~
最適化:optimization:~
有意:significant:~
概念的:conceptual:~
機能性:functionality:~
特定の:specific な:~
特別:special:~
用語:term:~
直に:direct に:~
能:ability:~
能力:capability:~
自動的:automatic:~
要件:requirements:~
	要約:abstract:~
規範的:normative:~
	規範的でない:non-normative
間接的:indirect:~
局面:scenario:~
標準:standard:~
	標準~化-:standardize:~
一般:general:~
正しく:correct に:~
課題:issue:~
適切:appropriate:~
手引き:guidance:~
任意選択で:optional に:~
	任意選択で元に戻す:opt back in
代替:alternative:~
有意:significant:~
自己検分:introspection:~
実際:actual:~
実際の:actual な:~
将来:future:~
概して:typical に:~
概観:overview:~
一意:unique:~
完全:complete:~
詳細:details:~
副作用:side effect:~

	種類:kind:~
	使い勝手:ergonomics:~
	関わらず:regardless
	欠如:lack of thereof
	現時点では:currently
	べき:should
	しかしながら，:however
	この仕様:Feature Policy
	ために:in order to
	絶えず発展し続ける:ever-expanding
	これまで無かった:missing piece
	より良い:better:#1
	任意選択で外す:opt-out
	例:example
	例えば:for example
	因り:due
	多い:often
	簡潔にするため:for brevity
	そのようなわけで:As such
	ある程度:to a degree
	に足る:sufficient
	注意:note that
	具体例として:for instance
	少なくとも:at least
	仮に，ある:hypothetical
	具体例として:for-instance
	見込まれる:likely
	早期段階:early
	人:human
	広い~~意味:broad
	場合によっては:possibly

	●仕様（動詞
support::::サポート
	support済み:supported
定義-:define:~
	定義し直す:redefine:~
	〜で定義されている:〜-defined
実装-:implement:~
導入-:introduce:~
序論:introduction:~
意図-:intend:~
意図的:intentional:~
抑制-:reduce:~
拡張-:extend:~
	拡張-可能:extensible／:extendable
指定-:specify:~
指示-:indicate:~
挙動:behavior:ふるまい
	挙動:behaviour
提供-:offer:~
改善-:improve:~
改訂:revision:~
期待-:expect:~
	期待されない:unexpected
求める:want する:~
求めら:want さ:~
求めて:want して:~
求まれ:want され:~
	求まれない:unwanted
決定-:determine:~
波及-:influence:~
約束:promise:~
統合-:integrate:~
統合:integration:~
考慮点:considerations:~
考える:consider する:~
見なさ:consider さ:~
要旨-:outline:~
要求-:require:~
解釈-:interpret:~
言明-:assert:~
詳細な:detailed:~
述べる:describe する:~
適合性:conformance:~
適用-:apply:~
選択的:selective:~
避ける:avoid する:~
開発:development:~
開発者:developer:~
関係-:relate:~
防止-:prevent:~
組合せて:combine して:~
策定者:author:~
裁定-:decide:~
設計:design:~
設計-:design:~
試みた:attempt した:~
試みる:attempt する:~
制限-:limit:~
依存-:depend:~
	依存しない:independent
取扱う:handle する:取り扱う
取扱って:handle して:取り扱って
意味-:mean:~
実用的:practical:~
依頼-:ask:~
参照-:reference::~
	指す／~~参照:refer
	詳細はそれらを参照すること。:references which ought to be consulted for detailed information
認識-:recognize:~
前提:assumption:~
演繹-:deduce:~
奨励-:encourage:~
影響-:affect:~
意識-:aware:~
	意識しておくように:should aware
裁定:decision:~
調整-:adjust:~
保証-:guarantee:~
実験-:experiment:~
feedback::::フィードバック
	呼応して:in response to
	に則って:accordingly
	重複-:duplicate
	もたらす／:caused
	用立てる make use
	知り:learn
	組合せて:in combination with
	見よ:see
	課す:impose
	略称され:referred to 〜 simply as 
	織り込む:account
	〜に基づく:based
	対処:deals with
	可能性も含みにする言い回しを見つける:figure out how to word this to include the possibility of
	に加えて:in addition to
	他が指示されない限り:unless otherwise indicated
	現時点で定義されている:currently-defined
	追加の:additional:~
	書ける:can be written
	読める:readable
	指す:refer
	専用:exclusively dedicated
	完成-:finalize

	●未分類（動詞
call:
在する:present する:在る
結付けら:associate さ:結び付けら
実行-:execute::~
更新-:update::~
走らす:run する:~
	返す:return
観測-:observe::~
	観測-可能:observable
観測器:observer::~
発火-:fire::~
event::::イベント
listen::::リッスン
投出-:throw::~
継続-:continue:~
動作:action::~::アクション

登録:registration::~
移譲-:delegate::~
存在-:exist:~
変更-:change:~
変化-:change:~
変化:changes:~
所在:location::~
要請:request::~
表示-:display:~

	含-:include
	含めて:including
	対応-:correspond
	-:expand
	現れ:appear
	除-:except:~
	数える:count する:~
	挙げら:mention
	生じ:occur
	与えられていない:omit
	省略時:optional
	示す:show

	●未分類
mode::::モード
Geolocation:
HTML:
HTTP:
IANA:
URL:
W3C:
CSP:
	CSP:Content Security Policy
IDL:IDL
JS:JavaScript
UI:user interface:UI
console::::コンソール
file::::ファイル
source::::ソース
group::::グループ
method::::メソッド
navi:navigation:::ナビ
navigate:navigate:::ナビゲート

FastCorp:
SecureCorp:

interface::::インタフェース
node::::ノード
obj:object:::オブジェクト
registry::::レジストリ
target:
	~target~list:targetlist

text::::テキスト
条件:condition:~
外部:external::~
既定の:default::~::デフォルト
既定:default::~::デフォルト
状態:state:~
段:step:~
恒久的:permanent:~
例外:exception::~
同期的:synchronous:~
既知:known:~
相対的:relative::~

	を有するならば:presence
	対象:subject
	-:documented
	-:property
	類似する／同様に:similar
	節:section
	DOMString
	~web~platform:web-platform
	^en:fast path
	~RET:abort these steps
	^r:Fullscreen
	^I:XMLHttpRequest
	社:Inc.
	-:in place for
	^l:payment
	^l:syncxhr
	何であれ:whatever
	~obj:instance
	-:isInherited
	それ以上の:no further
	-:single

	●指示語
全部的:full:~
新たな:new:~
現在の:current:~
	現在:currently:~
	現時点では、:currently
既存の:existing:~
自前の:own:~
特定0の:particular:ある特定の
	あらゆる:every
	一定の／ある種の:certain
	ある種の:certain type:~
	いくつかの:several
	および:as well as
	ここ:here
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	その他:others
	それら:they
	それらの:their
	それらの:those
	それらを:them
	それら自身:themselves
	にわたって:across
	も:as well
	一連の／の集合:set of
	上:above
	介:via
	他の:other
	他の場合:otherwise
	他方:the other
	以上の~or~more
	各:each
	同じ:same
	常に:always
	後:after
	所与の:given
	様々な:various
	次の:the following
	異なる:different
	等々:and so on
	結果:result
	結果の:resulting
	通:through
	長い方の:longer
	間:during
	同様に:similarly
	個別に:individual
	個々の:individual／:each individual
	両者:both
	何か:something
	前:before
	別の:another
	個の:one／:two
	別に:alongside
	nor
	thereof
	類の:sort of
	一部:part of／:some of
	自身:itself


●●ref_normative

[CSP-3]
    Content Security Policy Level 3 URL: https://www.w3.org/TR/CSP3/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[FETCH]
    Anne van Kesteren. Fetch Standard. Living Standard. URL: https://fetch.spec.whatwg.org/ 
[FULLSCREEN]
    Philip Jägenstedt. Fullscreen API Standard. Living Standard. URL: https://fullscreen.spec.whatwg.org/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[RFC3864]
    G. Klyne; M. Nottingham; J. Mogul. Registration Procedures for Message Header Fields. September 2004. Best Current Practice. URL: https://tools.ietf.org/html/rfc3864 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WebIDL]
    Cameron McCormack; Boris Zbarsky; Tobie Langel. Web IDL. 15 December 2016. ED. URL: https://heycam.github.io/webidl/ 

●●ref_informative

[CSP2]
    Mike West; Adam Barth; Daniel Veditz. Content Security Policy Level 2. 15 December 2016. REC. URL: https://www.w3.org/TR/CSP2/ 
[HTML5]
    Ian Hickson; et al. HTML5. 27 March 2018. REC. URL: https://www.w3.org/TR/html5/ 


●●trans_metadata
<p>
~THIS_PAGEは、
Web Platform Incubator Community Group
により
Draft Community Group Report として公開された
<a href="~SPEC_URL">Feature Policy</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

このバージョン
	https://wicg.github.io/feature-policy/

最新の課題
	<a href="https://github.com/wicg/feature-policy/issues/">GitHub</a>

編集
	<a href="mailto:iclelland@google.com">Ian Clelland</a> (Google)

commit 履歴
	https://github.com/WICG/feature-policy/commits/master

</script>

</head><body>

<header>
	<hgroup>
<h1 id="title">特色機能施策 — Feature Policy</h1>
	</hgroup>

<details><summary>©</summary><small class="copyright" lang="en-x-a0">
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2018 the Contributors to the Feature Policy Specification, published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>.
A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.
</small></details>

</header>

<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">要約</h2>

<p>
この仕様は、~browserに備わる様々な［
特色機能や~API
］の利用を選択的に［
可能化する／不能化する
］ことを，開発者に許容する仕組みを定義する。
◎
This specification defines a mechanism that allows developers to selectively enable and disable use of various browser features and APIs.
</p>

	</section>
	<section id="status">
<h2 title="Status of this document">この文書の位置付け</h2>

<p lang="en-x-a0">
This specification was published by the <a href="https://www.w3.org/community/wicg/">Web Platform Incubator Community Group</a>.
It is not a W3C Standard nor is it on the W3C Standards Track.
Please note that under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a> there is a limited opt-out and other conditions apply.
Learn more about <a href="http://www.w3.org/community/">W3C Community and Business Groups</a>.
</p>

	</section>

<main id="MAIN0">

	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoの記述に利用されている各種記号（ε, 此れ, ~LET, ~IF, ~RET, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
一部の箇所では、既存の用語を利用して記述を簡約している。
</p>

	</section>

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>


<p>
~web~platformは、絶えず発展し続ける一連の［
特色機能や~API
］を供して，より［
多彩な機能性, 開発者にとって使い勝手の良さ, 改善された処理能
］を提供する。
しかしながら、開発者が，~browserに備わるこれらの［
特色機能や~API
］のうち一部の挙動を 自身の~appの中で選択的に［
可能化- ／ 不能化- ／ 改変-
］する能は、これまで無かった：
◎
The web-platform provides an ever-expanding set of features and APIs, offering richer functionality, better developer ergonomics, and improved performance. However, a missing piece is the ability for the developer to selectively enable, disable, or modify the behavior of some of these browser features and APIs within their application:
</p>

<ol>
	<li>
開発者は、~browserに備わる ある種の［
特色機能や~API
］への~accessを 選択的に<em>不能化-</em>したいと求めることもある
— ~securityや処理能のための予防策として，［
自前の, あるいは第三者主体の
］内容が，自身の~appの中で実行されるのを防止して、［
求まれない／期待されない
］挙動を導入しないように，自身の~appを “監禁する” ために。
◎
The developer may want to selectively disable access to certain browser features and APIs to "lock down" their application, as a security or performance precaution, to prevent own and third-party content executing within their application from introducing unwanted or unexpected behaviors within their application.
</li>
	<li>
開発者は、［
既定では不能化され得るような，~browserに備わる ある種の［
特色機能や~API
］］への~accessを，選択的に<em>可能化-</em>したいと求めることもある
— 例：一部の特色機能は、［
埋込まれた文脈においては，明示的に可能化されない限り 既定で不能化されたり、他の施策~要件の対象になる
］こともある。
◎
The developer may want to selectively enable access to certain browser features and APIs which may be disabled by default - e.g. some features may be disabled by default in embedded context unless explicitly enabled; some features may be subject to other policy requirements.
</li>
	<li>
<p>
開発者は、［
ある種の［
特色機能や~API
］の利用
— または その欠如 —
について，自身の~app［
の~client／を埋込む側
］に約束する
］ことを言明する施策を利用したいと求めることもある。
例えば：
</p>
		<ul>
			<li>
~browserにおいて ある種の “`fast path^en”† 最適化を可能化するため。
【†よくある事例~用の “優先路”（短期滞在者用の入出国手続きのような）】
</li>
			<li>
埋込む側
— 例：様々な~social-network, 検索engine, 等々 —
が設定した一部の要件に対する適合性についての約束を言明するため。
</li>
		</ul>
◎
The developer may want to use the policy to assert a promise to a client or an embedder about the use—or lack of thereof—of certain features and APIs. For example, to enable certain types of "fast path" optimizations in the browser, or to assert a promise about conformance with some requirements set by other embedders - e.g. various social networks, search engines, and so on.
</li>
</ol>

<p>
この仕様は、上の利用~事例に取組む特色機能~施策の仕組みを定義する。
◎
This specification defines a feature policy mechanism that addresses the above use cases.
</p>


	</section>
	<section id="examples">
<h2 title="Examples">2. 例</h2>

<div class="example">

<p>
~SecureCorp社は、自身の~appの中では［
~Vibration／~Geolocation
］~APIの利用を不能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~headerを送達すれば、それを行える：
◎
SecureCorp Inc. wants to disable use of Vibration and Geolocation APIs within their application. It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: vibrate 'none'; geolocation 'none'
</pre>

<p>
生成元~list用の~keyword `'none'^l を指定することにより、指定された特色機能は
— どの閲覧文脈においても，その生成元に関わらず —
不能化されることになる。
◎
By specifying the "'none'"keyword for the origin list, the specified features will be disabled for all browsing contexts, regardless of their origin.
</p>

</div>

<div class="example">

<p>
~SecureCorp社は、［
自前の生成元／ 生成元 `https://example.com^l 
］用を除くどの閲覧文脈の中でも~Geolocation~APIの利用を不能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~headerを送達すれば、それを行える：
◎
SecureCorp Inc. wants to disable use of Geolocation API within all browsing contexts except for its own origin and those whose origin is "https://example.com". It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: geolocation 'self' https://example.com
</pre>

<p>
`許容list$は、 1 個~以上の生成元からなる~listである
— その各~生成元には、次のいずれかを与えれる
⇒＃
任意選択で ~keyword `'self'^l を伴う，~appの生成元 ／
任意の第三者主体~生成元
◎
The allowlist is a list of one or more origins, which can include the application’s origin, optionally with the keyword "'self'", and any third-party origin.
</p>
</div>

<div class="example">

<p>
~SecureCorp社は、
`https://example.com^l にて ある~appを~hostしていて，自前の生成元~上では［
~camera／~microphone
］入力を不能化したいが，自身が埋込む特定の~host（ `https://other.com^l ）用には可能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~headerを送達すれば、それを行える：
◎
SecureCorp Inc. is hosting an application on "https://example.com" and wants to disable camera and microphone input on its own origin but enable it for a specific embedee ("https://other.com"). It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: camera https://other.com; microphone https://other.com
</pre>

<p>
一部の特色機能は、埋込まれた文脈~内では既定で不能化される。
施策は、そのような特色機能を，指定された生成元~用に選択的に可能化することを，~appに許容する。
◎
Some features are disabled by default in embedded contexts. The policy allows the application to selectively enable such features for specified origins.
</p>

</div>

<div class="example">

<p>
~FastCorp社は、特定の `iframe^e 用を除く，すべての非同一生成元の子~frame用には，地理情報（ `geolocation^en ）を不能化したいと求めているとする。
次のような特色機能~施策を定義する~HTTP応答~header：
◎
FastCorp Inc. wants to disable geolocation for all cross-origin child frames, except for a specific iframe. It can do so by delivering the following HTTP response header to define a feature policy:
</p>


<pre class="http-code">
`Feature-Policy$h: geolocation 'self'
</pre>

<p>
を送達した上で，
`iframe^e 要素に `allow^a 属性を含めることで，それを行える：
◎
and including an "allow" attribute on the iframe element:
</p>


<pre class="http-code">
&lt;iframe src="https://other.com/map" <a href="#iframe-allow-attribute">allow</a>="geolocation"&gt;&lt;/iframe&gt;
</pre>


<p>
各種 `iframe^e 用の属性は、一定の~frame内に限り，選択的に特色機能を可能化できる
— 他では，同じ生成元からの文書を包含する場合でも可能化しないように。
◎
Iframe attributes can selectively enable features in certain frames, and not in others, even if those contain documents from the same origin.
</p>

</div>


	</section>
	<section id="other-and-related-mechanisms">
<h2 title="Other and related mechanisms">3. 他の／関係する仕組み</h2>

<p>
`HTML5$r が `iframe$e 要素~用に定義する `sandbox$aF 属性は、［
内容の能に制約を課すことにより，信用できない内容が含まれることによる~riskを抑制する
］ことを，開発者に許容する
— 例：［
~formを提出する／~scriptや~pluginを走らす／その他
］を防止するなど。
`CSP2$r が定義する `sandbox$dir 指令は、同じ一連の制約を依頼するために，この能力を どの資源にも
— ~frame化されるかどうかを問わず —
拡張する
— 例： ~HTTP応答~headerを介することにより（ `Content-Security-Policy: sandbox^l ）。
これらの仕組みは、開発者に次を可能化する：
◎
[HTML5] defines a sandbox attribute for iframe elements that allows developers to reduce the risk of including potentially untrusted content by imposing restrictions on content’s abilities - e.g. prevent it from submitting forms, running scripts and plugins, and more. The sandbox directive defined by [CSP2] extends this capability to any resource, framed or not, to ask for the same set of restrictions - e.g. via an HTTP response header (Content-Security-Policy: sandbox). These mechanisms enable the developer to:
</p>

<ul>
	<li>
どの資源に対しても，~CSPを介して~sandbox施策を［
設定する／~custom化する
］。
◎
Set and customize a sandbox policy on any resource via CSP.
</li>
	<li>
自身の~appの中の各 `iframe^e 要素に対し，個別に~sandbox施策を［
設定する／ ~custom化する
］。
◎
Set and customize individual sandbox policies on each iframe element within their application.
</li>
</ul>


<p>
しかしながら，上の仕組みには、いくつかの制限がある：
◎
However, there are several limitations to the above mechanism:＼
</p>
<ul>
	<li>
開発者は、すべての文脈にわたって施策を自動的には適用できないため、一部の事例では，一貫して施行することが困難または不可能である（例：第三者主体からの内容が，開発者が制御しない~frameを注入することに因るものなど）
◎
the developer cannot automatically apply a policy across all contexts, which makes it hard or impossible to enforce consistently in some cases (e.g. due to third-party content injecting frames, which the developer does not control);＼
</li>
	<li>
既定では不能化され得るような特色機能を，選択的に可能化する仕組みが無い
◎
there is no mechanism to selectively enable features that may be off by default;＼
</li>
	<li>
~sandboxの仕組みは、すべての~sandbox特色機能を自動的に不能化して，そのそれぞれを任意選択で元に戻すことを，開発者に要求するので、有意な互換性~riskなしに一連の~sandbox特色機能を拡張することは不可能である。
◎
the sandbox mechanism automatically disables all sandbox features, and requires the developer to opt back in to each of them, so it is impossible to extend the set of sandbox features without significant compatibility risk.
</li>
</ul>

<p>
特色機能~施策は、~sandboxの仕組みと組合せて利用することが意図されており（すなわち、すでに~sandboxが受持っている特色機能~制御とは重複しない），上の制限に取組む拡張-可能な仕組みを供する。
◎
Feature Policy is intended to be used in combination with the sandbox mechanism (i.e. it does not duplicate feature controls already covered by sandbox), and provides an extensible mechanism that addresses the above limitations.
</p>


	</section>
	<section id="framwork">
<h2 title="Framework">4. ~framework</h2>

		<section id="features">
<h3 title="Policy-controlled Features">4.1. 施策により制御される特色機能</h3>


<p>
`施策により制御される特色機能@
は、`特色機能~施策$を~~参照することにより，文書において［
可能化-／不能化-
］できる［
~APIや挙動
］である。
◎
A policy-controlled feature is an API or behaviour which can be enabled or disabled in a document by referring to it in a feature policy.
</p>


<p class="note">注記：
簡潔にするため，この文書においては、施策により制御される特色機能は “特色機能” と略称されることが多い。
他が指示されない限り，用語 “特色機能” は`施策により制御される特色機能$を指す。
そのような特色機能を定義する他の仕様は、多義性を避けるため，長い方の用語を利用するべきである。
◎
For brevity, policy-controlled features will often be referred to in this document simply as "Features". Unless otherwise indicated, the term "feature" refers to policy-controlled features. Other specifications, defining such features, should use the longer term to avoid any ambiguity.
</p>


<p class="issue">
この仕様は、現時点では，文書~内に定義される特色機能しか対処していない。
これについて，~Workerや~Worklet内の［
特色機能／特色機能~施策
］の可能性も含みにする言い回しを見つけるべきである。
◎
This spec currently only deals with features defined in Documents. We should figure out how to word this to include the possibility of features and feature policies in Workers and Worklets as well.
</p>


<p>
`施策により制御される特色機能$は、［
`施策~指令$内で利用される，文字列による~token
］により識別される。
◎
Policy-controlled features are identified by tokens, which are character strings used in policy directives.
</p>

<p>
各 `特色機能$には、`既定の許容list$がある
— それは、次の 2 つを定義する
⇒＃
その特色機能は `~top-level閲覧文脈$に`属する文書$内で可用かどうか／
その特色機能への~accessは `入子の閲覧文脈$にはどう継承されるか
◎
Each policy-controlled feature has a default allowlist, which defines whether that feature is available in documents in top-level browsing contexts, and how access to that feature is inherited in nested browsing contexts.
</p>

<p>
`特色機能$のうち，~UAが施策を通して制御することを許容するものは、
`~support済み特色機能@
と呼ばれる。
~UAには、あらゆる`特色機能$を~supportすることは要求されない。
◎
A user agent has a set of supported features, which is the set of features which it allows to be controlled through policies. User agents are not required to support every feature.
</p>


<p class="note">注記：
`施策により制御される特色機能$自体は、この~frameworkの一部を成すものではない。
現時点で定義されている規範的でない特色機能の~listは、この仕様とは別に，
<a href="https://github.com/WICG/feature-policy/blob/master/features.md">姉妹~文書</a>
にて保守されている。
◎
The policy-controlled features themselves are not themselves part of this framework. A non-normative list of currently-defined features is maintained as a companion document alongside this specification.
</p>

		</section>
		<section id="policies">
<h3 title="Policies">4.2. 施策</h3>

<p>
`特色機能~施策@
は、次の~itemからなる`構造体$である
⇒＃
`継承した施策$,
`宣言-済み施策$
◎
A feature policy is a struct with the following items:
• An inherited policy.
• A declared policy.
</p>

<div class="p">
<p>
`空の特色機能~施策@
は、次のようにされた`特色機能~施策$である：
</p>

<ul>
	<li>
どの`~support済み特色機能$ %特色機能 に対しても
⇒
`継承した施策$[ %特色機能 ] ~EQ `可能化される^i
</li>
	<li>
`宣言-済み施策$は空~map
</li>
</ul>

◎
An empty feature policy is a feature policy that has an inherited policy which contains "Enabled" for every supported feature, and a declared policy which is an empty map.
</div>


		</section>
		<section id="inherited-policies">
<h3 title="Inherited policies">4.3. 継承した施策</h3>

<p>
`継承した施策@
は、各 `特色機能$を［
ある施策 ~IN { `可能化される^i, `不能化される^i }
］に対応付ける`有順序~map$である。
◎
An inherited policy is an ordered map from features to either "Enabled" or "Disabled".
</p>


<p>
`特色機能~用に継承される施策@
は、所与の %特色機能 に対し，`継承した施策$[ %特色機能 ] で与えられる。
`特色機能~施策$が初期化された後には、それが`継承した施策$は，各`~support済み特色機能$用に何らかの値を包含することになる。
◎
The inherited policy for a feature feature is the value in the inherited policy whose key is feature. After a feature policy has been initialized, its inherited policy will contain a value for each supported feature.
</p>

<div class="note" role="note">
<p>注記：
~frame木を成す各 文書は、一連の施策を継承する
— ［
~top-level文書は 各`特色機能$用に定義される既定~のものから ／
他の文書は その親~frameから
］。
この継承した施策は、次を決定する
⇒＃
各~特色機能の初期~状態（ `可能化される^i ／ `不能化される^i ） ／
文書~内の`宣言-済み施策$により制御できるかどうか。
◎
Each document in a frame tree inherits a set of policies from its parent frame, or in the case of the top-level document, from the defined defaults for each policy-controlled feature. This inherited policy determines the initial state ("Enabled" or "Disabled") of each feature, and whether it can be controlled by a declared policy in the document.
</p>

<p>
`~top-level閲覧文脈$に`属する文書$に継承される施策は、各~特色機能~用に定義される既定の施策に基づく。
◎
In a Document in a top-level browsing context, the inherited policy is based on defined defaults for each feature.
</p>

<p>
`入子の閲覧文脈$に`属する文書$に継承される施策は、［
親~文書の`特色機能~施策$doc, および`入子の閲覧文脈$の`容器~施策$
］に基づく。
◎
In a Document in a nested browsing context, the inherited policy is based on the parent document’s feature policy, as well as the nested browsing context's container policy.
</p>

</div>


		</section>
		<section id="declared-policies">
<h3 title="Declared policies">4.4. 宣言-済み施策</h3>

<p>
`宣言-済み施策@
は、各 `特色機能$を ある`許容list$に対応付ける`有順序~map$である。
◎
A declared policy is an ordered map from features to allowlists.
</p>

		</section>
		<section id="header-policies">
<h3 title="Header policies">4.5. ~header施策</h3>


<p>
`~header施策@
は、文書に伴う~HTTP~headerを介して送達された`施策~指令$からなる~listである。
これは、文書の`特色機能~施策$の`宣言-済み施策$を形成する。
◎
A header policy is a list of policy directives delivered via an HTTP header with a document. This forms the document’s feature policy’s declared policy.
</p>

		</section>
		<section id="container-policies">
<h3 title="Container policies">4.6. 容器~施策</h3>

<p>
各`入子の閲覧文脈$は、`~header施策$に加えて，
`容器~施策@
を持つ。
それは、`施策~指令$であり，空にもなり得る。
`容器~施策$は、`閲覧文脈~容器$上の属性により設定できる。
◎
In addition to the header policy, each nested browsing context has a container policy, which is a policy directive, which may be empty. The container policy can set by attributes on the browsing context container.
</p>

<p>
`入子の閲覧文脈$用の`容器~施策$は、その文脈の中に読込まれる文書に`継承される施策$に波及する（`特色機能~用に継承される施策を定義する$を見よ）。
◎
The container policy for a nested browsing context influences the inherited policy of any document loaded into that context. (See §10.9 Define an inherited policy for feature)
</p>

<p class="note">注記：
現時点では，`容器~施策$は直には設定できないが、
`iframe^e 要素の
<a href="#iframe-allowfullscreen-attribute">`allowfullscreen^a</a>,
<a href="#iframe-allowpaymentrequest-attribute">`allowpaymentrequest^a</a>,
<a href="#iframe-allowusermedia-attribute">`allowusermedia^a</a>,
<a href="#iframe-allow-attribute">`allow^a</a>
属性により，間接的に設定される。
この仕様の将来の改訂は、全部的な`容器~施策$を明示的に宣言する仕組みを導入し得る。
◎
Currently, the container policy cannot be set directly, but is indirectly set by iframe "allowfullscreen", "allowpaymentrequest", "allowusermedia", and "allow" attributes. Future revisions to this spec may introduce a mechanism to explicitly declare the full container policy.
</p>


		</section>
		<section id="policy-directives">
<h3 title="Policy directives">4.7. 施策~指令</h3>

<p>
`施策~指令@
は、各 `特色機能$を ある`許容list$に対応付ける`有順序~map$である。
◎
A policy directive is an ordered map, mapping policy-controlled features to corresponding allowlists of origins.
</p>


<p>
`施策~指令$は、［
~HTTP~header／~HTML属性
］内では，`~ASCII直列化$pdとして表現される。
◎
A policy directive is represented in HTTP headers and HTML attributes as its ASCII serialization.
</p>

		</section>
		<section id="allowlists">
<h3 title="Allowlists">4.8. 許容list</h3>

<p>
特色機能~施策
`許容list@
は、概念的には，いくつかの`生成元$からなる集合である。
`許容list$は、次のいずれかをとり得る：
◎
A feature policy allowlist is conceptually a set of origins. An allowlist may be either:
</p>

<ul>
	<li>
あらゆる生成元を表現する，特別な値
"`*@P"
。
この仕様における
`全~生成元@i
は、この値を表す別名として利用される。
【 この別名は、表記的／意味的に明快にするために，この訳に導入している。】
◎
The special value *, which represents every origin, or
</li>
	<li>
`生成元$たちが成す`有順序~集合$
◎
An ordered set of origins
</li>
</ul>


<p class="note">注記：
［
~headerや属性
］内の文字列による許容listの~text表現には、~keyword［
`'self'^l, `'src'^l, `'none'^l
］も現れ得る
【属性の場合は、一重引用符は不要】
。
これらの各~keywordは，常に構文解析の間に文脈~内で解釈され、それぞれが指す生成元のみが，許容list~内に格納される。
~keyword自身は、許容listの一部を成すことはない。
◎
The keywords 'self', 'src', and 'none' can appear in the text representation of allowlists in headers and attribute strings. These keywords are always interpreted in context during parsing, and only the origins which they refer to are stored in the allowlist. The keywords themselves are not part of the allowlist.
</p>

<p class="algo-head">
`許容listは生成元に合致する@
かどうか決定するときは、所与の
( `許容list$ %許容list, 生成元 %生成元 )
に対し，次の手続きを走らす：
◎
To determine whether an allowlist matches an origin origin, run these steps:
</p>

<ol>
	<li>
~IF［
%許容list ~EQ `全~生成元$i
］
⇒
~RET ~T
◎
If the allowlist is the special value *, then return true.
</li>
	<li>
%許容list 内の
~EACH( %~item )
に対し
⇒
~IF［
( %~item, %生成元 ) 
は`同じ生成元~domain$である
］
⇒
~RET ~T
◎
Otherwise, for each item in the allowlist:
• If item is same origin-domain with origin, then return true.
</li>
	<li>
~RET ~F
◎
return false.
</li>
</ol>


		</section>
		<section id="default-allowlists">
<h3 title="Default Allowlists">4.9. 既定の許容list</h3>


<p>
各 `特色機能$には、
`既定の許容list@
がある。
`既定の許容list$は、次を決定する
⇒＃
`~top-level閲覧文脈$内に宣言された施策は無い下で，所与の特色機能は文書において許容されるかどうか ／
特色機能への~accessは自動的に`入子の閲覧文脈$に`属する文書$に移譲されるかどうか
◎
Every policy-controlled feature has a default allowlist. The default allowlist determines whether the feature is allowed in a document with no declared policy in a top-level browsing context, and also whether access to the feature is automatically delegated to documents in nested browsing contexts.
</p>

<p>
`特色機能$用の`既定の許容list$は、次のいずれかの値をとる：
◎
The default allowlist for a feature is one of these values:
</p>

<dl>
	<dt>`全~生成元$i</dt>
	<dd>
特色機能は、既定では，`~top-level閲覧文脈$に`属する文書$において許容されることに加え、許容されるときは，
`入子の閲覧文脈$に`属する文書$においても既定で許容される。
◎
The feature is allowed in documents in top-level browsing contexts by default, and when allowed, is allowed by default to documents in nested browsing contexts.
</dd>

	<dt>`'self'^l</dt>
	<dd>
特色機能は、既定では，`~top-level閲覧文脈$に`属する文書$において許容されることに加え、許容されるときは：
`入子の閲覧文脈$に`属する文書$のうち，同じ生成元~domainのものにおいては既定で許容されるが、非同一生成元の文書においては，既定では許容されない。
◎
The feature is allowed in documents in top-level browsing contexts by default, and when allowed, is allowed by default to same-origin domain documents in nested browsing contexts, but is disallowed by default in cross-origin documents in nested browsing contexts.
</dd>

	<dt>`'none'^l</dt>
	<dd>
特色機能は、既定では，`~top-level閲覧文脈$に`属する文書$において許容されないことに加え、`入子の閲覧文脈$に`属する文書$においても，既定では許容されない。
◎
The feature is disallowed in documents in top-level browsing contexts by default, and is also disallowed by default to documents in nested browsing contexts.
</dd>
</dl>

		</section>
	</section>
	<section id="serialization">
<h2 title="Feature Policy Serialization">5. 特色機能~施策の直列化</h2>

		<section id="ascii-serialization">
<h3 title="ASCII serialization">5.1. ~ASCII直列化</h3>


<p>
`施策~指令$は［
~HTTP~header／~HTML属性
］内では、~ASCII~textとして表現される。
◎
Policy Directives are represented in HTTP headers and in HTML attributes as ASCII text.
</p>


<pre class="ABNF">
`serialized-feature-policy@P = `serialized-policy-directive$P *(";" `serialized-policy-directive$P)
`serialized-policy-directive@P = `feature-identifier$P RWS `allow-list$P
`feature-identifier@P = 1*( ALPHA / DIGIT / "-")
`allow-list@P = `allow-list-value$P *(RWS `allow-list-value$P)
`allow-list-value@P = `serialized-origin$P / "*" / "'self'" / "'src'" / "'none'"
</pre>

<p>
`serialized-origin@P
は、`生成元の直列化$である。
しかしながら，符号位置［
`0027^U (') ／
`0021^U (*) ／
`002C^U (,) ／
`003B^U (;)
］は、直列化~内に現れては~MUST_NOT
— それらが要求される場合には、［
`%27^l ／ `%2A^l ／ `%2C^l ／ `%3B^l
］として~percent-符号化され~MUST。
◎
serialized-origin is the serialization of an origin. However, the code points U+0027 ('), U+0021 (*), U+002C (,) and U+003B (;) MUST NOT appear in the serialization. If they are required, they must be percent-encoded as "%27", "%2A", "%2C" or "%3B", respectively.
</p>

<p class="note">注記：
文字列 `'self'^l は、許容list内の生成元として利用されても~MAY。
この仕方で利用されたときは、当の特色機能~施策を包含する文書の生成元を指すことになる。
◎
The string "'self'" may be used as an origin in an allowlist. When it is used in this way, it will refer to the origin of the document which contains the feature policy.
</p>

		</section>
	</section>
	<section id="delivery">
<h2 title="Delivery">6. 送達</h2>

		<section id="feature-policy-http-header-field">
<h3 title="Feature-Policy HTTP Header Field">6.1. `Feature-Policy^h ~HTTP~header</h3>

<p>
［
~clientにより施行されるべきである`特色機能~施策$
］を（ ~serverから~clientへ ）通信するときには、~HTTP応答~内に
`Feature-Policy@h
~headerを利用できる。
◎
The `Feature-Policy` HTTP header field can be used in the response (server to client) to communicate the feature policy that should be enforced by the client.
</p>

<p>
この~headerの値は、 1 個~以上の［
`施策~指令$の`~ASCII直列化$pd
］からなる。
◎
The header’s value is the §5.1 ASCII serialization of one or more policy directives:.
</p>

<pre class="ABNF">
FeaturePolicy = `serialized-feature-policy$P *("," `serialized-feature-policy$P)
</pre>

<p>
`Feature-Policy$h ~headerを受信した~UAは、
<a href="#integration-with-html">~HTMLとの統合</a>
に従って，
<a href="#process-response-policy">応答~施策を処理して</a>
`施行-$し~MUST。
◎
When the user agent receives a `Feature-Policy` header field, it MUST process and enforce the serialized policy as described in §8.1 Integration with HTML.
</p>


		</section>
		<section id="iframe-allow-attribute">
<h3 title="The allow attribute of the iframe element">6.2. `iframe^e 要素の `allow^a 属性</h3>

<p>
`iframe$e 要素の `allow$aF 属性は、`直列形の特色機能~施策$を包含する。
◎
iframe elements have an "allow" attribute, which contains an ASCII-serialized policy directive.
</p>

<p>
この属性~内に挙げられた名前の特色機能~用の`許容list$は、空になることもある。
その事例では、当の許容list用の既定の値は `'src'^l とする
— この値は、 `iframe^e 要素の `src$aF 属性に与えられた~URLの`生成元$urlを表現する。
◎
The allowlist for the features named in the attribute may be empty; in that case, the default value for the allowlist is 'src', which represents the origin of the URL in the iframe’s src attribute.
</p>

<p>
空でないときは、 `allow^aF 属性により，それを有する `iframe^e 要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に［
認識される各`特色機能$用の`許容list$
］が追加されることになる。
◎
When not empty, the "allow" attribute will result in adding an allowlist for each recognized feature to the nested browsing context's container policy, when it is constructed.
</p>


		</section>
		<section id="legacy-attributes">
<h3 title="Additional attributes to support legacy features">6.3. 旧来の特色機能を~supportする追加の属性</h3>

<p>
この仕様により制御される一部の`特色機能$に対しては、それ用の既存の属性が `iframe^e 要素~上に定義されている。
この仕様は、これらの属性を `iframe^e 要素~用に宣言された施策として動作するように定義し直す。
◎
Some features controlled by Feature Policy have existing iframe attributes defined. This specification redefines these attributes to act as declared policies for the iframe element.
</p>

			<section id="iframe-allowfullscreen-attribute">
<h4 title="allowfullscreen">6.3.1. `allowfullscreen^a</h4>

<p>
`iframe^e 要素~上の `allowfullscreen$aF 属性は、
`requestFullscreen()$m への~accessを制御する。
◎
The "allowfullscreen" iframe attribute controls access to requestFullscreen().
</p>


<p>
`iframe^e 要素が `allow$aF 属性を有していて，その値は ~token `fullscreen^l を包含する場合、
`allowfullscreen$aF 属性は効果を及ぼしては~MUST_NOT。
◎
If the iframe element has an "allow" attribute whose value contains the token "fullscreen", then the "allowfullscreen" attribute must have no effect.
</p>

<p>
他の場合， `iframe^e 要素が `allowfullscreen$aF 属性を有するならば、要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に `fullscreen^l 特色機能~用の`許容list$として `全~生成元$i が追加されることになる。
◎
Otherwise, the presence of an "allowfullscreen" attribute on an iframe will result in adding an allowlist of * for the "fullscreen" feature to the nested browsing context's container policy, when it is constructed.
</p>


<p class="note">注記：
これは、
`&lt;iframe allow="fullscreen"&gt;^c
の挙動から異なるが、既存の `allowfullscreen^a の利用と互換性を得るためにある。
`allow="fullscreen"^c,
`allowfullscreen^c
の両者とも `iframe^e 要素~上に在する場合、より制約的な方の許容listを成す `allow="fullscreen"^c が利用されることになる。
◎
This is different from the behaviour of &lt;iframe allow="fullscreen"&gt;, and is for compatibility with existing uses of allowfullscreen. If allow="fullscreen" and allowfullscreen are both present on an iframe element, then the more restrictive allowlist of allow="fullscreen" will be used.
</p>

			</section>
			<section id="iframe-allowpaymentrequest-attribute">
<h4 title="allowpaymentrequest">6.3.2. `allowpaymentrequest^a</h4>

<p>
`iframe^e 要素~上の `allowpaymentrequest$aF 属性は
`PaymentRequest$I への~accessを制御する。
◎
The "allowpaymentrequest" iframe attribute controls access to paymentrequest.
</p>

<p>
`iframe^e 要素は `allow$aF 属性を有していて，その値は `payment^l を包含する場合、
`allowpaymentrequest$aF 属性は効果を及ぼしては~MUST_NOT。
◎
If the iframe element has an "allow" attribute whose value contains the token "payment", then the "allowpaymentrequest" attribute must have no effect.
</p>


<p>
他の場合， `iframe^e 要素が `allowpaymentrequest$aF 属性を有するならば、要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に `payment^l 特色機能~用の`許容list$として `全~生成元$i が追加されることになる。
◎
Otherwise, the presence of an "allowpaymentrequest" attribute on an iframe will result in adding an allowlist of * for the "payment" feature to the nested browsing context's container policy, when it is constructed.
</p>


<p class="note">注記：
これは、 `&lt;iframe allow="payment"&gt;^c の挙動と異なるが、既存の `allowpaymentrequest^a の利用と互換性を得るためにある。
`allow="payment"^c,
`allowpaymentrequest^a
の両者とも `iframe^e 要素~上に在する場合、より制約的な方の許容listを成す `allow="payment"^c が利用されることになる。
◎
This is different from the behaviour of &lt;iframe allow="payment"&gt;, and is for compatibility with existing uses of allowpaymentrequest. If allow="payment" and allowpaymentrequest are both present on an iframe element, then the more restrictive allowlist of allow="payment" will be used.
</p>

			</section>
			<section id="iframe-allowusermedia-attribute">
<h4 title="allowusermedia">6.3.3. `allowusermedia^a</h4>


<p>
`iframe^e 要素~上の `allowusermedia$aF 属性は、
`getUserMedia()$m への~accessを制御する。
◎
The "allowusermedia" iframe attribute controls access to getUserMedia().
</p>

<p>
`iframe^e 要素が `allow$aF 属性を有していて，その値は~token `payment^l を包含する場合、
`allowusermedia$aF 属性は効果を及ぼしては~MUST_NOT。
◎
If the iframe element has an "allow" attribute whose value contains the token "payment", then the "allowusermedia" attribute must have no effect.
</p>


<p>
他の場合， `iframe^e 要素が `allowusermedia$aF 属性を有するならば、要素が`入子にしている閲覧文脈$が構築されるときに，その`容器~施策$に［
`camera^l, `microphone^l
］各~特色機能~用の`許容list$として `全~生成元$i が追加されることになる。
◎
Otherwise, the presence of an "allowusermedia" attribute on an iframe will result in adding an allowlist of * for each of the "camera" and "microphone" features to the nested browsing context's container policy, when it is constructed.
</p>


<p class="note">注記：
これは
`&lt;iframe allow="camera; microphone"&gt;^c
の挙動と異なるが、既存の `allowusermedia^a の利用と互換性を得るためにある。
`allow="camera; microphone"^c,
`allowusermedia^a
の両者とも `iframe^e 要素~上に在る場合、より制約的な方の許容listを成す `allow="camera; microphone"^c が利用されることになる。
同様に，［
`allow="camera"^c,
`allow="microphone"^c
］の片方だけが在する場合、その特色機能~用には より制約的な方の許容listが利用されることになる一方で、
他方には より制約的でない方の許容listを成す `全~生成元$i を利用することになる。
◎
This is different from the behaviour of &lt;iframe allow="camera; microphone"&gt;, and is for compatibility with existing uses of allowusermedia. If allow="camera; microphone" and allowusermedia are both present on an iframe element, then the more restrictive allowlist of allow="camera; microphone" will be used. Similarly, if only one of allow="camera" or allow="microphone" is present, then the more restrictive allowlist will be used for that feature, while the other will use the less restrictive *.
</p>

			</section>
		</section>
	</section>

	<section id="introspection" class="unstable">
<h2 title="Policy Introspection from Scripts">7. ~scriptからの施策の自己検分</h2>

<p class="advisement">
この節にて述べる自己検分~APIは、開発の早期段階にあり，完成する前に
— 場合によっては有意に —
変更されるものと見込まれる。
~web開発者には、この~APIを利用して実験して
<a href="https://github.com/WICG/feature-policy/issues/new">~feedbackを供する</a>ことが
奨励されるが、変更されたり，完全に除去されることを意識しておくように。
◎
The introspection API described in this section is early in development, and is likely to change — possibly significantly — before it is finalized. Web developers are encouraged to experiment with using the API, and provide feedback, but should be aware that it may change or be removed completely.
</p>

		<section id="introspection-overview" class="non-normative">
<h3 title="Overview">7.1. 概観</h3>

<p>
文書~内で効果を発揮している現在の施策は、~scriptから観測できる。
これは、［
ある特色機能が可能化されているかどうか判らない限り，何か
— 具体例として, どの~UIを表示するかなど —
を決定する
］のがアリでない事例で，裁定を下すときに利用できる。
（特色機能には、観測-可能な失敗~modeが無いものや，特色機能~検出に際し求まれない副作用を伴うものもあるかもしれない。）
◎
The current policy which is in effect in a document can be observed by scripts. This can be used to make decisions, for instance, about what user interface to display, in cases it is not possible to determine otherwise whether a feature is enabled or not. (Some features may not have any observable failure mode, or may have unwanted side effects to feature detection.)
</p>


<p>
文書, `iframe^e の両者とも， `Policy$I ~objを供する
— それを利用すれば、自身に適用される特色機能~施策を検分できる。
◎
Documents and iframes both provide a Policy object which can be used to inspect the feature policies which apply to them.
</p>


<p class="note">注記：
“`policy^en” という名は、意図的に広い~~意味にされている：
`Policy$I ~objは、この仕様~専用ではなく，~CSPなどの他の種類の施策~用にも拡張-可能になるものと意図されている。
将来に この~objに追加される~methodは、それが指す施策の種類を指示するよう，適切に命名されるべきである。
◎
The name policy is intentionally broad: the Policy object is intended to be extendable to other kinds of policies, such as Content Security Policy, rather than being exclusively dedicated to Feature Policy. Future methods added to the object should be named appropriately, to indicate the kinds of policies they refer to.
</p>

			<section id="document-policies">
<h4 title="Document policies">7.1.1. 文書~施策</h4>

<p>
現在~有効な施策を検索取得するときは、
`document.policy()$m
を利用する。
これは、次に利用できる `Policy$I ~objを返す：
<!-- policy object -->
◎
To retreive the currently effective policy, use document.policy(). This returns a policy object, which can be used to:
</p>

<ul>
	<li>
現在の文書に対し，所与の特色機能~用の状態（許容されるか／否認されるか）を照会する
◎
query the state (allowed or denied) in the current document for a given feature,
</li>
	<li>
現在の文書にて許容される特色機能すべてからなる~listを取得する
◎
get a list of all allowed features in the current document, or
</li>
	<li>
現在の文書における，所与の特色機能~用の許容listを取得する。
◎
get the allowlist for a given feature in the current document.
</li>
</ul>

<div class="example">

<pre class="html-code">
&lt;!doctype html&gt;
&lt;script&gt;
 let %policy = document.policy;

 /* <span class="comment">
この文書が~WebUSBを利用できるならば、次の結果は ~T になる。
◎
This will be true if this document can use WebUSB
</span> */
 let %can_use_usb = %policy.allowsFeature('usb');

 /* <span class="comment">
`https://example.com^s にある新たな~frameには，~WebVRの利用は許容されるならば、次の結果は ~T になる。
◎
True if a new frame at https://example.com will be allowed to use WebVR
</span> */
 if (%policy.allowsFeature('vr', 'https://example.com')) {
   /* <span class="comment">
`https://example.com^s にある~frameを作成する~UIを示す
◎
Show UI to create frame at https://example.com
</span> */
 } else {
   /* <span class="comment">
代替~UIを示す
◎
Show an alternative UI
</span> */
 }

 /* <span class="comment">
`payment^l （支払い）要請が許容される生成元たちの~listを取得する。
結果は、すべての生成元に許容される場合は `全~生成元$i のみからなる~list（ `['\*']^c ）になり，他の場合は 明示的な生成元の~listになる。
◎
Get the list of origins which are allowed to request payment. The result will be a list of explicit origins, or the single element ['\*'] if all origins are allowed.
</span> */
 let %allowed_payment_origins = %policy.getAllowlistForFeature('payment');
&lt;/script&gt;
</pre>
</div>

			</section>
			<section id="frame-policies">
<h4 title="Frame policies">7.1.2. ~frame 施策</h4>

<p>
`iframe^e 要素~上の施策を，それを包含する文書から検分することもアリである。
この事例における施策~objは、その~frame用の`観測-可能な施策$を表現する
— それは、現在の文書と `iframe^e 要素の属性のみに依存し，［
~frame内で，ある特色機能が実際に現在~許容されているかどうか
］を露呈することはない。
~frame内の文書は、~HTTP~headerを介して自前の施策を適用していることもあれば，初期の所在から新たな生成元へ~navigateされることもある。
そのような事例で 入子の閲覧文脈~内で有効な施策が露呈されれば、非同一生成元~文書の挙動について情報を漏洩することになり得る。
◎
It is also possible to inspect the policy on an iframe element, from the document which contains it. The policy object in this case represents the observable policy for the frame, which depends only on the current document and the attributes of the iframe element. It does not reveal whether a feature is actually currently allowed in the frame, as the document in the frame may have applied its own policy via an HTTP header, or may have navigated away from its initial location to a new origin. Revealing the effective policy in the nested browsing context in that case could leak information about the behaviour of a cross-origin document.
</p>

<div class="unstable example">

<pre class="html-code">
&lt;!doctype html&gt;
&lt;iframe id="frame" allow="fullscreen; vr"&gt;&lt;/iframe&gt;
&lt;script&gt;
 let %iframe_element = document.getElementById("frame");
 let %iframe_policy = %iframe_element.policy;

 /* <span class="comment">
~frame化された文書にて~WebVRの利用は許容されるならば、次の結果は ~T になる。
◎
True if the framed document will be allowed to use WebVR
</span> */
 if (%iframe_policy.allowsFeature('vr')) {
  /* <span class="comment">
~VR制御を表示する
◎
display vr controls
</span> */
 }
&lt;/script&gt;
</pre>
</div>

<p>
`iframe^e 要素~上で`観測-可能な施策$は、~frameの中に読込まれた実際の内容には依存しない（非同一生成元への情報~漏洩を避けるため）
— また、要素が文書~木~内にあるかどうかにも依存しない。
◎
The observable policy on an iframe element is independent of any actual content loaded into the frame (to avoid cross-origin information leakage,) or even whether it is in a document tree.
</p>

<div class="unstable example">

<pre class="html-code">
&lt;!doctype html&gt;
&lt;!-- <span class="comment">
次の~frameの `src^a 属性に与えた文書が読込まれるときは、その~frameには，~fullscreenを利用することは許容されるべきでない。
◎
this frame should not be allowed to use fullscreen when the document in its src attribute is loaded in it
</span> --&gt;
&lt;iframe id="frame" allow="fullscreen https://example.com" src="https://example.net/" &gt;&lt;/iframe&gt;

&lt;script&gt;
 let %iframe_element = document.getElementById("frame");
 let %iframe_policy = %iframe_element.policy;
 /* <span class="comment">
次の結果は、~F になる
— 施策により、 `src^a 属性~内に挙げられた~URLには，~fullscreenの利用-は許容されないので。
◎
This will be false, as the URL listed in the src attribute is not allowed by policy to use fullscreen.
</span> */
 let %is_fullscreen_allowed_in_frame = iframe_policy.allowsFeature('fullscreen');

 let %new_frame = document.createElement('iframe');
 %new_frame.allow = 'syncxhr';
 /* <span class="comment">
次の結果は、 ~T になる。
すなわち、この `iframe^e には `syncxhr^l 【同期的 `XMLHttpRequest$I 】の利用-は許容される
— `src^a 属性に挙げられた~URLが何であれ，属性がまだ設定されてなくとも。
◎
This will be true, as the iframe is allowed to use syncxhr at whatever URL is mentioned in its src attribute, even though that attribute is not yet set.
</span> */
 let %is_syncxhr_allowed = %new_frame.policy.allowsFeature('syncxhr');
&lt;/script&gt;
</pre>
</div>


			</section>
		</section>
		<section id="the-policy-object">
<h3 title="The policy object">7.2. 施策~obj</h3>

<pre class="idl">[`NoInterfaceObject$]
interface `Policy@I {
  boolean `allowsFeature$m(DOMString %feature, optional DOMString %origin);
  sequence&lt;DOMString&gt; `allowedFeatures$m();
  sequence&lt;DOMString&gt; `getAllowlistForFeature$m(DOMString %feature);
};

partial interface `Document$I {
    [`SameObject$] readonly attribute `Policy$I `~policyD$m;
};

partial interface `HTMLIFrameElement$I {
    [`SameObject$] readonly attribute `Policy$I `~policyF$m;
};
</pre>


<p>
各 `Policy$I ~obj %P には、 `Node$I ~objが結付けられる
— それは， %P に
`結付けられている~node@
と称され、 %P の作成-時に設定される。
◎
A Policy object has an associated node, which is a Node. The associated node is set when the Policy object is created.
</p>

<p>
各 `Policy$I ~obj %P の
`既定の生成元@
は、 %P に`結付けられている~node$ %N に応じて，次で与えられる`生成元$になる
⇒＃
`Document$I であるならば %N の`生成元$ ／
`Element$I であるならば %N に`宣言された生成元$
◎
A Policy object has a default origin, which is an origin, whose value depends on the state of the Policy object’s associated node:
• If the Policy object’s associated node is a Document, then its default origin is the Document's origin.
• If the Policy object’s associated node is an Element, then its default origin is the Element's declared origin.
</p>

<p>
各 `Document$I ~obj %D には、 %D の
`施策~obj@doc
と称される，次を満たす `Policy$I ~obj %P がただ一つ在る
⇒
%P に`結付けられている~node$ ~EQ %D
◎
Each Document has a policy object, which is a Policy instance whose associated node is that Document.
</p>

<p class="idl-def">
`Document$I 上の `~policyD@m ~IDL属性の取得子は、此れの`施策~obj$docを返さ~MUST
◎
A Document's policy IDL attribute, on getting, must return the Document's policy object.
</p>

<p>
各 `iframe$e 要素 %E には、 %E の
`施策~obj@doc
と称される，次を満たす `Policy$I ~obj %P がただ一つ在る
⇒
%P に`結付けられている~node$ ~EQ %E
◎
Each iframe element has a policy object, which is a Policy instance whose associated node is that element.
</p>

<p class="idl-def">
`iframe$e %E 上の `~policyF@m ~IDL属性の取得子は、此れの`施策~obj$iFを返さ~MUST。
◎
An iframe's policy IDL attribute, on getting, must return the iframe's policy object.
</p>

<dl class="idl-def">
	<dt>`allowsFeature(feature, origin)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The allowsFeature(feature, origin) method must run the following steps:
</p>
		<ol>
			<li>
~IF［
%origin は与えられていない
］
⇒
%origin ~SET 此れの`既定の生成元$
◎
If origin is omitted, set origin to this Policy object’s default origin.
</li>
			<li>
%施策 ~LET 此れに`結付けられている~node$用の`観測-可能な施策$
◎
Let policy be the observable policy for this Policy object’s associated node.
</li>
			<li>
~IF［
%施策 により， %特色機能 は %origin 用に許容される【具体的な~algoは指定されていない】
］
⇒
~RET ~T
◎
If feature is allowed by policy for origin, return true.
</li>
			<li>
~RET ~F
◎
Otherwise, return false.
</li>
		</ol>
	</dd>

	<dt>`allowedFeatures()@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The allowedFeatures() method must run the following steps:
</p>
		<ol>
			<li>
%結果 ~SET 空~list
◎
Set result to an empty list
</li>
			<li>
%生成元 ~LET 此れの`既定の生成元$
◎
Let origin be this Policy object’s default origin.
</li>
			<li>
%施策 ~LET 此れに`結付けられている~node$用に`観測-可能な施策$
◎
Let policy be the observable policy for this Policy object’s associated node.
</li>
			<li>
~EACH( `~support済み特色機能$ %特色機能 )
に対し
⇒
~IF［
%施策 により， %特色機能 は %生成元 用に許容される
］
⇒
%結果 に %特色機能 を付加する
◎
For each supported feature feature:
• If feature is allowed by policy for origin, append feature to result.
</li>
			<li>
~RET %結果
◎
return result
</li>
		</ol>
	</dd>

	<dt>`getAllowlistForFeature(feature)@m</dt>
	<dd>
<p>
被呼出時には、次を走らせ~MUST：
◎
The getAllowlistForFeature(feature) method must run the following steps:
</p>
		<ol>
			<li>
%結果 ~SET 空~list
◎
Set result to an empty list
</li>
			<li>
%生成元 ~LET 此れの`既定の生成元$
◎
Let origin be this Policy object’s default origin.
</li>
			<li>
%施策 ~LET 此れに`結付けられている~node$用の`観測-可能な施策$
◎
Let policy be the observable policy for this Policy object’s associated node.
</li>
			<li>
~IF［
%施策 により， %特色機能 は %生成元 用には許容されない
］
⇒
~RET %結果
◎
If feature is not allowed in policy for origin, return result
</li>
			<li>
%許容list ~LET %施策 の宣言-済み施策[ %特色機能 ]
◎
Let allowlist be policy’s declared policy[feature]
</li>
			<li>
~IF［
%許容list ~EQ `全~生成元$i
］
⇒
%結果 に`全~生成元$iを付加する
◎
If allowlist is the special value *, append "*" to result
</li>
			<li>
~ELSE
⇒
%許容list 内の
~EACH( %生成元 )
に対し
⇒
%結果 に次の結果を付加する
⇒
`生成元を直列化する$( %生成元 )
◎
Otherwise, for each origin in allowlist:
• Append the serialization of origin to result
</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>
	</dd>
</dl>


<p>
~node %N 用の
`観測-可能な施策@
は、現在の閲覧文脈から可視である`特色機能~施策$のうち，［
%N により表現される，閲覧文脈~内の施策についての情報
］を包含するものである。
◎
The observable policy for any Node is a feature policy, which contains the information about the policy in the browsing context represented by that Node which is visible from the current browsing context.
</p>

<p class="algo-head">
所与の %文書 用の`観測-可能な施策$を取得するときは、
%文書 の`特色機能~施策$docを返す。
◎
To get the observable policy for a Document document, return document’s feature policy.
</p>

<p class="algo-head">
所与の要素 %~node 用に`観測-可能な施策$を取得するときは、次を走らす：
◎
To get the observable policy for an Element node, run the following steps:
</p>

<ol>
	<li>
%継承した施策 ~LET 新たな有順序~map
◎
Let inherited policy be a new ordered map.
</li>
	<li>
%宣言-済み施策 ~LET 新たな有順序~map
◎
Let declared policy be a new ordered map.
</li>
	<li>
~EACH( `~support済み特色機能$ %特色機能 )
に対し
⇒
%継承した施策[ %特色機能 ] ~SET `容器~内の特色機能~用に継承される施策を定義する$( %特色機能, %~node )
◎
For each supported feature feature:
• Let isInherited be the result of running §10.10 Define an inherited policy for feature in container on feature and node.
• Set inherited policy[feature] to isInherited.
</li>
	<li>
~RET 次のようにされた新たな`特色機能~施策$
⇒＃
`継承した施策$ ~SET %継承した施策,
`宣言-済み施策$ ~SET %宣言-済み施策
◎
Return a new feature policy with inherited policy inherited policy and declared policy declared policy.
</li>
</ol>

<p class="algo-head">
`Element$I %~node 用に
`宣言された生成元@
を取得するときは、次を走らす：
◎
To get the declared origin for an Element node, run the following steps:
</p>

<ol>
	<li>
%文書 ~LET %~node の`~node文書$
◎
↓</li>
			<li>
<p>
~IF［
%~node は `src^a 属性を有する
］：
◎
If node has a src attribute:
</p>
		<ol>
			<li>
%~url ~LET %~node の `src^a 属性の値を %文書 に`相対的に構文解析-$した結果
◎
Let url be the result of parsing node’s src attribute, relative to node’s node document.
</li>
			<li>
~IF［
%~url ~NEQ 失敗
］
⇒
~RET %~url の生成元
◎
If url is not failure, return url’s origin.
</li>
		</ol>
	</li>
	<li>
~RET %文書 の生成元
◎
Return node’s node document’s origin.
</li>
</ol>

		</section>
	</section>
	<section id="integrations">
<h2 title="Integrations">8. 統合</h2>

<p>
この文書は、一連の~algoを定義する
— 他の仕様は、この仕様が定義する制約を実装するために，それらを利用することになる。
統合については，明確さを得るためここで要旨するが†、それらの外部~仕様が規範的であり，詳細はそれらを参照すること。
◎
This document defines a set of algorithms which other specifications will use in order to implement the restrictions which Feature Policy defines. The integrations are outlined here for clarity, but those external documents are the normative references which ought to be consulted for detailed information.
</p>

		<section id="integration-with-html">
<h3 title="Integration with HTML">8.1. ~HTMLとの統合</h3>

<p class="trans-note">【†
この訳では、原文をさらに簡約して，該当する変更点とその参照先を挙げるにとどめる（原文の “引用” による記述は、~HTML仕様の更新に伴い，次第に乖離していくと予想されるので）。
】</p>

<ol>
	<li>
`文書$用の`特色機能~施策$は、各 `文書$の`特色機能~施策$doc（初期~時は空）を設定することにより，
`施行-@
されることになる。
【具体的には、次項に挙げる~algo, および`特色機能~施策~属性を処理する$ことを通して。】
◎
Document objects have a Feature Policy, which is initially empty.
◎
↓</li>
	<li>
次に挙げる~algoは改変された
⇒＃
`新たな閲覧文脈を作成する$／
`文書を初期化する$／
特色機能の`利用は許容される$かどうかを決定する
◎
Replace the existing step 12 of "Create a new browsing context" with with the following step:
• Execute the Initialize document’s Feature Policy algorithm on the Document object. 
◎
Replace the existing step 8 of "Initialising a new Document object" with the following step:
• Execute the Initialize document’s Feature Policy from response algorithm on the Document object and the response used to generate the document. 
◎
A feature policy is enforced for a Document by setting it as the Document's Feature Policy.
◎
The "allowed to use" algorithm is replaced with the following:
• 以下略
</li>
	<li>
`iframe$e 要素に `allow$aF 属性が追加された。
◎
The allow attribute is added to the IDL for the iframe element, with the description:
• 以下略
</li>
	<li>
`allowfullscreen$aF,
`allowpaymentrequest$aF,
`allowusermedia$aF
属性の挙動は変更された。
◎
The description of the behavior of the allowfullscreen, allowpaymentrequest and allowusermedia attributes is changed to refer to this specification:
• 以下略
</li>
	<li>
もはや参照されなくなった “`set the allow* flags^en” ~algoは除去された。
◎
The set the allow* flags algorithm is removed, as it is no longer referenced.
</li>
</ol>

		</section>
	</section>
	<section id="reporting">
<h2 title="Reporting">9. 報告-法</h2>

<p>
`特色機能~施策~違反~報告@
は、［
`文書$内のある挙動が，特色機能~施策に`違反-$している
］ことを指示する。
その施策の
`違反@
がいつ生じるか［
定義する／決定する
］のは、個々の特色機能~施策に委ねられる。
◎
Feature policy violation reports indicate that some behavior of the Document has violated a feature policy. It is up to each individual feature policy to define/determine when a violation of that policy has occurred.
</p>

<p>
`特色機能~施策~違反~報告$の`報告~種別$は、 `feature-policy-violation^l とする。
◎
Feature policy violation reports have the report type "feature-policy-violation".
</p>

<p>
`特色機能~施策~違反~報告$は、`報告用~観測器から可視$になるとする。
◎
Feature policy violation reports are visible to ReportingObservers.
</p>


<pre class="idl">
interface `FeaturePolicyViolationReportBody@I : `ReportBody$I {
  readonly attribute DOMString `featureId$m;
  readonly attribute DOMString `message$m;
  readonly attribute DOMString? `sourceFile$m;
  readonly attribute long? `lineNumber$m;
  readonly attribute long? `columnNumber$m;
  readonly attribute DOMString `disposition$m;
};
</pre>


<p>
`特色機能~施策~違反~報告$の`本体$rPは、~JSにおいては，次の~fieldを包含する
`FeaturePolicyViolationReportBody$I により表現される：
◎
A feature policy violation report’s body, represented in JavaScript by FeaturePolicyViolationReportBody, contains the following fields:
</p>

<dl class="idl-def">
	<dt>`featureId@m</dt>
	<dd>
施策に`違反-$した`特色機能$を識別する文字列。
この文字列は、関係する報告を~group化する／数えるときに利用できる。
◎
featureId: The string identifying the policy-controlled feature whose policy has been violated. This string can be used for grouping and counting related reports.
</dd>

	<dt>`message@m</dt>
	<dd>
詳細を伴う，人が読める文字列
— 開発者~consoleに表示されるものに概して合致するような。
この~messageは、所与の `featureId$m に一意になることは保証されない（例：~APIがどう利用されたかについて追加の文脈を包含することもある）。
◎
message: A human-readable string with details typically matching what would be displayed on the developer console. The message is not guaranteed to be unique for a given featureId (e.g. it may contain additional context on how the API was used).
</dd>

	<dt>`sourceFile@m</dt>
	<dd>
既知ならば，`違反$が生じた~file
— 他の場合は ~NULL 。
◎
sourceFile: If known, the file where the violation occured, or null otherwise.
</dd>

	<dt>`lineNumber@m</dt>
	<dd>
既知ならば， `sourceFile$m において`違反$が生じた箇所の行番号
— 他の場合は ~NULL 。
◎
lineNumber: If known, the line number in sourceFile where the violation occured, or null otherwise.
</dd>

	<dt>`columnNumber@m</dt>
	<dd>
既知ならば， `sourceFile$m において`違反$が生じた箇所の列番号
— 他の場合は ~NULL 。
◎
columnNumber: If known, the column number in sourceFile where the violation occured, or null otherwise.
</dd>

	<dt>`disposition@m</dt>
	<dd>
`違反-$された特色機能~施策は、この事例にて施行されたかどうかを指示する文字列。
施策は施行されたなら `enforce^l に設定される。
`違反$は この報告を生成させるだけであったなら `report^l に設定される（~UAは、違反に呼応してそれ以上の動作はとらなかった）。
◎
disposition: A string indicating whether the violated feature policy was enforced in this case. disposition will be set to "enforce" if the policy was enforced, or "report" if the violation resulted only in this report being generated (with no further action taken by the user agent in response to the violation).
</dd>
	<dd class="note">注記：
現時点では、報告のみ行う~modeを可能化する仕組みは無いので、これは，常に `enforce^l に設定されることになる。
◎
Note: There is currently no mechanism in place for enabling report-only mode, so disposition will always be set to "enforce".
</dd>
</dl>

	</section>
	<section id="algorithms">
<h2 title="Algorithms">10. 各種~algo</h2>

		<section id="process-response-policy">
<h3 title="Process response policy">10.1. 応答~施策を処理する</h3>

<p>
この~algoは、所与の
( `応答$ %応答, `生成元$ %生成元 )
に対し，`宣言-済み施策$を返す：
◎
Given a response (response) and an origin (origin), this algorithm returns a declared feature policy.
</p>

<ol>
	<li>
~IF［
%応答 の`~header~list$rs内に `Feature-Policy^h を`名前に持つ~header$は無い
］
⇒
~RET
◎
Abort these steps if the response’s header list does not contain a header whose name is "Feature-Policy".
</li>
	<li>
%~header値 ~LET %応答 の`~header~list$rs内の `Feature-Policy^h に対する`結合-済みの値$hd
◎
Let header be the concatenation of the values of all header fields in response’s header list whose name is "Feature-Policy", separated by U+002C (,) (according to [RFC7230, 3.2.2]).
</li>
	<li>
%特色機能~施策 ~LET `値と生成元から~headerを構文解析する$( %~header値, %生成元 )
◎
Let feature policy be the result of executing §10.2 Parse header from value and origin on header and origin.
</li>
	<li>
~RET %特色機能~施策
◎
Return feature policy.
</li>
</ol>

		</section>
		<section id="parse-header">
<h3 title="Parse header from value and origin">10.2. %値 と %生成元 から~headerを構文解析する</h3>

<p>
この~algoは、所与の
( 文字列 %値, `生成元$ %生成元 )
に対し，`宣言-済み施策$を返す：
◎
Given a string (value) and an origin (origin) this algorithm will return a declared feature policy.
</p>

<ol>
	<li>
%施策 ~LET 新たな`有順序~map$
◎
Let policy be an empty ordered map.
</li>
	<li>
<p>
`~commaで分割する$( %値 ) の結果を成す
~EACH( %要素 )
に対し：
◎
For each element returned by splitting value on commas:
</p>
		<ol>
			<li>
%指令 ~LET `値と生成元から施策~指令を構文解析する$( %要素, %生成元 )
◎
Let directive be the result of executing §10.3 Parse policy directive from value and origin on element and origin
</li>
			<li>
`指令を宣言-済み施策に併合する$( %指令, %施策 )
◎
Run §10.4 Merge directive with declared policy on directive and policy.
</li>
		</ol>
	</li>
	<li>
~RET %施策
◎
Return policy.
</li>
</ol>

		</section>
		<section id="parse-policy-directive">
<h3 title="Parse policy directive from value and origin">10.3. %値 と %生成元 から施策~指令を構文解析する</h3>

<p>
この~algoは、所与の
( 文字列 %値, `生成元$ %生成元 )
に対し，`施策~指令$を返す：
◎
Given a string (value) and an origin (origin) this algorithm will return a policy directive.
</p>

<ol>
	<li>
%指令 ~LET 新たな`有順序~map$
◎
Let directive be an empty ordered map.
</li>
	<li>
<p>
`区切子で厳密に分割する$( %値, `003B^U (;) )
の結果を成す
~EACH( %直列形の宣言 )
に対し：
◎
For each serialized-declaration returned by strictly splitting value on the delimiter U+003B (;):
</p>
		<ol>
			<li>
%~token~list ~LET `~ASCII空白で分割する$( %直列形の宣言 )
◎
Let tokens be the result of splitting serialized-declaration on ASCII whitespace.
</li>
			<li>
~IF［
%~token~list は空である
］
⇒
~CONTINUE
◎
If tokens is an empty list, then continue.
</li>
			<li>
%特色機能~名 ~LET %~token~list[0]
◎
Let feature-name be the first element of tokens.
</li>
			<li>
%特色機能 ~LET %特色機能~名 により識別される`~support済み特色機能$が［
在るならば それ ／
無いならば ε
］
◎
If feature-name does not identify any recognized policy-controlled feature, then continue.
</li>
			<li>
~IF［
%特色機能 ~EQ ε
］
⇒
~CONTINUE
◎
Let feature be the policy-controlled feature identified by feature-name.
</li>
			<li>
%~target~list ~LET %~token~list から最初の~itemを除去して得られる~list
◎
Let targetlist be the remaining elements, if any, of tokens.
</li>
			<li>
%許容list ~LET `全~生成元$i
◎
↓</li>
			<li>
<p>
~IF［
`全~生成元$i ~NIN %~target~list
］
◎
Let allowlist be a new allowlist.
◎
If any element of targetlist is the string "*", set allowlist to the special value *.
◎
Otherwise:
</p>
				<ol>
					<li>
%許容list ~SET 新たな`有順序~集合$
◎
Set allowlist to an new ordered set.
</li>
					<li>
<p>
%~target~list 内の
~EACH( %~target )
に対し：
◎
For each element in targetlist:
</p>
						<ol>
							<li>
~IF［
%~target は 文字列 `'self'^l に`~ASCII大小無視$で合致しない
］
⇒
%~target ~SET %生成元
◎
If element is an ASCII case-insensitive match for the string "'self'", let result be origin.
</li>
							<li>
<p>
~ELSE：
</p>
								<ol>
									<li>
%~target ~LET `~URL構文解析する$( %~target )
◎
Otherwise, let result be the result of executing the URL parser on element.
</li>
									<li>
~IF［
%~target ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If result is not failure:
</li>
									<li>
%~target ~SET %~target の`生成元$url
◎
Let target be the origin of result.
</li>
								</ol>
							</li>
							<li>
~IF［
%~target は`不透明な生成元$でない
］
⇒
%許容list に %~target を付加する
◎
If target is not an opaque origin, append target to allowlist.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%指令[ %特色機能 ] ~SET %許容list
◎
Set directive[feature] to allowlist.
</li>
		</ol>
	</li>
	<li>
~RET %指令
◎
Return directive
</li>
</ol>

		</section>
		<section id="merge-directive-with-declared-policy">
<h3 title="Merge directive with declared policy">10.4. 指令を宣言-済み施策に併合する</h3>

<p>
この~algoは、所与の
( 施策~指令 %指令, `宣言-済み施策$ %施策 )
に対し，新たな指令を織り込むように %施策 を改変する：
◎
Given a policy directive (directive) and a declared policy (policy), this algorithm will modify policy to account for the new directive.
</p>

<ol>
	<li>
<p>
%指令 を成す
~EACH( %特色機能 → %許容list )
に対し：
◎
For each feature → allowlist of directive:
</p>
		<ol>
			<li>
~IF［
%施策[ %特色機能 ] ~EQ ε
］
⇒
%施策[ %特色機能 ] ~SET %許容list
◎
If policy does not contain an allowlist for feature, then set policy[feature] to allowlist.
</li>
		</ol>
	</li>
</ol>


		</section>
		<section id="process-feature-policy-attributes">
<h3 title="Process feature policy attributes">10.5. 特色機能~施策~属性を処理する</h3>

<p>
この~algoは、所与の
( 要素 %要素 )
に対し，`容器~施策$を返す（空にもなり得る）：
◎
Given an element (element), this algorithm returns a container policy, which may be empty.
</p>

<ol>
	<li>
%施策 ~LET 新たな`施策~指令$
◎
Let policy be a new policy directive.
</li>
	<li>
%容器~施策 ~LET 
<a href="#parse-allow-attribute">`allow^a 属性を構文解析する</a>(
%要素 の `allow$aF 属性の値,
%要素 の`~node文書$の生成元,
%要素 に`宣言された生成元$
)
◎
Let container policy be the result of running Parse allow attribute on the value of element’s allow attribute, with container origin set to the origin of element’s node document, and target origin set to element’s declared origin.
</li>
	<li>
~IF［
%要素 は `iframe$e 要素でない
］
⇒
~RET %容器~施策
【 `allow^a 属性が定義されているのは `iframe^e しかないので、この記述はおかしい。】
◎
If element is an iframe element:
</li>
	<li>
~IF［
%要素 は `allowfullscreen$aF 属性を有する
］~AND［
%容器~施策[ `fullscreen^ft ] ~EQ ε
］
⇒
%容器~施策[ `fullscreen^ft ] ~SET `全~生成元$i
◎
If element’s allowfullscreen attribute is specified, and container policy does not contain an allowlist for fullscreen,
• Construct a new declaration for fullscreen, whose allowlist is the special value *.
• Add declaration to container policy.
</li>
	<li>
~IF［
%要素 は `allowpaymentrequest$aF 属性を有する
］~AND［
%容器~施策[ `payment^ft ] ~EQ ε
］
⇒＃
%容器~施策[ `payment^ft ] ~SET `全~生成元$i
◎
If element’s allowpaymentrequest attribute is specified, and container policy does not contain an allowlist for payment,
• Construct a new declaration for payment, whose allowlist is the special value *.
• Add declaration to container policy.
</li>
	<li>
<p>
~IF［
%要素 は `allowusermedia$aF 属性を有する
【原文の `allowusermediarequest^a は誤記であろう】
］
⇒
◎
If element’s allowusermediarequest attribute is specified:
</p>
		<ol>
			<li>
~IF［
%容器~施策[ `camera^ft ] ~EQ ε
］
⇒
%施策[ `camera^ft ]† ~SET `全~生成元$i
◎
If container policy does not contain an allowlist for camera,
• Construct a new declaration for camera, whose allowlist is the special value *.
• Add declaration to policy.
</li>
			<li>
~IF［
%施策[ `microphone^ft ]† ~EQ ε
］
⇒
%容器~施策[ `microphone^ft ] ~SET `全~生成元$i
◎
If policy does not contain an allowlist for microphone,
• Construct a new declaration for microphone, allowlist is the special value *.
• Add declaration to container policy.
</li>
		</ol>

【† おそらく、 %施策 ではなく， %容器~施策 （したがって最初の段も不要）】
	</li>
	<li>
~RET %容器~施策
◎
Return container policy.
</li>
</ol>


		</section>
		<section id="parse-allow-attribute">
<h3 title="Parse allow attribute">10.6. `allow^a 属性を構文解析する</h3>


<p>
この~algoは、所与の
( 文字列 %値, 生成元 %容器~生成元, 生成元 %~target生成元 )
に対し，`施策~指令$を返す：
◎
Given a string (value), and two origins (container origin and target origin), this algorithm returns a policy directive.
</p>

<ol>
	<li>
%指令 ~LET 新たな`有順序~map$
◎
Let directive be an empty ordered map.
</li>
	<li>
<p>
`区切子で厳密に分割する$( %値, `003B^U (;) )
の結果を成す
~EACH( %直列形の宣言 )
に対し：
◎
For each serialized-declaration returned by strictly splitting value on the delimiter U+003B (;):
</p>
		<ol>
			<li>
%~token~list ~LET `~ASCII空白で分割する$( %直列形の宣言 )
◎
Let tokens be the result of splitting serialized-declaration on ASCII whitespace.
</li>
			<li>
~IF［
%~token~list は空である
］
⇒
~CONTINUE
◎
If tokens is an empty list, then continue.
</li>
			<li>
%特色機能~名 ~LET %~token~list[0]
◎
Let feature-name be the first element of tokens.
</li>
			<li>
%特色機能 ~LET %特色機能~名 により識別される`~support済み特色機能$が［
在るならば それ ／
無いならば ε
］
◎
If feature-name does not identify any recognized policy-controlled feature, then continue.
</li>
			<li>
~IF［
%特色機能 ~EQ ε
］
⇒
~CONTINUE
◎
Let feature be the policy-controlled feature identified by feature-name.
</li>
			<li>
%~target~list ~LET %~token~list から最初の~itemを除去して得られる~list
◎
Let targetlist be the remaining elements, if any, of tokens.
</li>
			<li>
%許容list ~LET 新たな`許容list$
◎
Let allowlist be a new allowlist.
</li>
			<li>
~IF［
`全~生成元$i ~IN %~target~list
］
⇒
%許容list ~SET `全~生成元$i
◎
If any element of targetlist is the string "*", set allowlist to the special value *.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%許容list ~SET 新たな `有順序~集合$
◎
Set allowlist to an new ordered set.
</li>
					<li>
~IF［
%~target~list は空である
］
⇒
%許容list に %~target生成元 を付加する
◎
If targetlist is empty, append target origin to allowlist.
</li>
					<li>
<p>
%~target~list を成す
~EACH( %~target )
に対し：
◎
For each element in targetlist:
</p>
						<ol>
							<li>
~IF［
%~target は`~ASCII大小無視$で `'self'^l に合致する
］
⇒
%~target ~SET %容器~生成元
◎
If element is an ASCII case-insensitive match for "'self'", let result be container origin.
</li>
							<li>
~ELIF［
%~target は`~ASCII大小無視$で `'src'^l に合致する
］
⇒
%~target ~SET %~target生成元
◎
If element is an ASCII case-insensitive match for "'src'", let result be target origin.
</li>
							<li>
<p>
~ELSE：
</p>
								<ol>
									<li>
%~target ~LET `~URL構文解析する$( %~target )
◎
Otherwise, let result be the result of executing the URL parser on element.
</li>
									<li>
~IF［
%~target ~EQ `失敗^i
］
⇒
~CONTINUE
◎
If result is not failure:
</li>
									<li>
%~target ~SET %~target の`生成元$url
◎
Let target be the origin of result.
</li>
								</ol>
							</li>
							<li>
~IF［
%~target は`不透明な生成元$でない
］
⇒
%許容list に %~target を付加する
◎
If target is not an opaque origin, append target to allowlist.
</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
%指令[ %特色機能 ] ~SET %許容list
◎
Set directive[feature] to allowlist.
</li>
		</ol>
	</li>
	<li>
~RET %指令
◎
Return directive
</li>
</ol>


		</section>
		<section id="initialize-for-document">
<h3 title="Initialize document’s Feature Policy">10.7. %文書 の特色機能~施策を初期化する</h3>

<p>
この~algoは、所与の
( `文書$ %文書 )
に対し， %文書 の`特色機能~施策$docを初期化する：
◎
Given a Document object (document), this algorithm initialises document’s Feature Policy
</p>

<ol>
	<li>
%継承した施策 ~LET 新たな`有順序~map$
◎
Let inherited policy be a new ordered map.
</li>
	<li>
%宣言-済み施策 ~LET 新たな`有順序~map$
◎
Let declared policy be a new ordered map.
</li>
	<li>
~EACH( `~support済み特色機能$ %特色機能 )
に対し
⇒
%継承した施策[ %特色機能 ] ~SET ~LET `特色機能~用に継承される施策を定義する$( %特色機能, %文書 が`属する閲覧文脈$ )
◎
For each feature supported,
• Let isInherited be the result of running §10.9 Define an inherited policy for feature on feature and document’s browsing context.
• Set inherited policy[feature] to isInherited.
</li>
	<li>
%施策 ~LET 次のようにされた新たな`特色機能~施策$
⇒＃
`継承した施策$ ~SET %継承した施策,
`宣言-済み施策$ ~SET %宣言-済み施策
◎
Let policy be a new feature policy, with inherited policy inherited policy and declared policy declared policy.
</li>
	<li>
%文書 の`特色機能~施策$doc ~SET %施策
（すなわち、 %施策 を`施行する$）
◎
Enforce the policy policy on document.
</li>
</ol>

		</section>
		<section id="initialize-from-response">
<h3 title="Initialize document’s Feature Policy from response">10.8. %応答 からの特色機能~施策で %文書 のそれを初期化する</h3>

<p>
この~algoは、所与の
( `応答$ %応答, `文書$ %文書 )
に対し，
%文書 の`特色機能~施策$を拡充する：
◎
Given a response (response) and a Document (document), this algorithm populates document’s Feature Policy
</p>

<ol>
	<li>
%文書 の`特色機能~施策を初期化する$
◎
Initialize document’s Feature Policy
</li>
	<li>
%継承した施策 ~LET %文書 の特色機能~施策が`継承した施策$
◎
Let inherited policy be document’s Feature Policy’s inherited policy.
</li>
	<li>
%宣言-済み施策 ~LET 新たな`有順序~map$
◎
Let declared policy be a new ordered map.
</li>
	<li>
%施策~指令 ~LET `応答~施策を処理する$( %応答, %文書 の生成元 )
◎
Let d be the result of running Process response policy on response and document’s origin.
</li>
	<li>
%施策~指令 を成す
~EACH( %特色機能 → %許容list )
に対し
⇒
~IF［
%継承した施策[ %特色機能 ] ~EQ ~T
］
⇒
%宣言-済み施策[ %特色機能 ] ~SET %許容list
◎
For each feature → allowlist of d:
• If inherited policy[feature] is true, then set declared policy[feature] to allowlist.
</li>
	<li>
%施策 ~LET 次のようにされた新たな`特色機能~施策$
⇒＃
`継承した施策$ ~SET %継承した施策,
`宣言-済み施策$ ~SET %宣言-済み施策
◎
Let policy be a new feature policy, with inherited policy inherited policy and declared policy declared policy.
</li>
	<li>
%文書 上で施策 %施策 を`施行する$
◎
Enforce the policy policy on document.
</li>
</ol>

		</section>
		<section id="define-inherited-policy">
<h3 title="Define an inherited policy for feature">10.9. %特色機能 用に継承される施策を定義する</h3>

<p>
この~algoは、所与の
( `特色機能$ %特色機能, `閲覧文脈$ %文脈 )
に対し， %文脈 が %特色機能 用に`継承した施策$を返す：
◎
Given a feature (feature) and a browsing context (context), this algorithm returns the inherited policy for that feature.
</p>

<ol>
	<li>
~IF［
%文脈 は`入子の閲覧文脈$である
］
⇒
~RET `容器~内の特色機能~用に継承される施策を定義する$( %特色機能, %文脈 の`閲覧文脈~容器$ )
◎
If context is a nested browsing context, return the result of executing §10.10 Define an inherited policy for feature in container on context’s browsing context container.
</li>
	<li>
~RET `可能化される^i
◎
Otherwise, return 'Enabled'.
</li>
</ol>

		</section>
		<section id="define-inherited-policy-in-container">
<h3 title="Define an inherited policy for feature in container">10.10. %容器 内の %特色機能 用に継承される施策を定義する</h3>

<p>
この~algoは、所与の
( `特色機能$ %特色機能, `閲覧文脈~容器$ %容器 )
に対し， %容器 が %特色機能 用に`継承した施策$を返す：
◎
Given a feature (feature) and a browsing context container (container), this algorithm returns the inherited policy for that feature.
</p>

<ol>
	<li>
%親 ~LET %容器 の`~node文書$
◎
Let parent be container’s node document.
</li>
	<li>
%生成元 ~LET %親 の`生成元$
◎
Let origin be parent’s origin
</li>
	<li>
%容器~施策 ~LET `特色機能~施策~属性を処理する$( %容器 )
◎
Let container policy be the result of running §10.5 Process feature policy attributes on container.
</li>
	<li>
<p>
~IF［
%容器~施策[ %特色機能 ] ~NEQ ε
］：
◎
If feature is a key in container policy:
</p>
		<ol>
			<li>
~IF［
`許容listは生成元に合致する$( %容器~施策[ %特色機能 ], %生成元 )
］~AND［
%親 が`継承した施策$[ %特色機能 ] ~EQ `可能化される^i
］
⇒
~RET `可能化される^i
◎
If the allowlist for feature in container policy matches origin, and parent’s inherited policy for feature is "Enabled", return "Enabled".
</li>
			<li>
~RET `不能化される^i
◎
Otherwise return "Disabled".
</li>
		</ol>
	</li>
	<li>
~RET `特色機能は施策により生成元~用に可能化されるか？$( %特色機能, %親, %生成元 )
◎
Otherwise, if feature is enabled in parent for origin, return "Enabled".
◎
Otherwise return "Disabled".
</li>
</ol>

		</section>
		<section id="is-feature-enabled">
<h3 title="Is feature enabled in document for origin?">10.11. %文書 内の %特色機能 は %生成元 用に可能化されるか？</h3>

<p>
この~algoは、所与の
( 特色機能 %特色機能, `文書$ %文書, `生成元$ %生成元 )
に対し，［
%特色機能 は不能化されるべきと見なされるならば `不能化される^i ／
~ELSE_ `可能化される^i
］を返す：
◎
Given a feature (feature), a Document object (document), and an origin (origin), this algorithm returns "Disabled" if feature should be considered disabled, and "Enabled" otherwise.
</p>

<ol>
	<li>
%施策 ~LET %文書 の`特色機能~施策$
◎
Let policy be document’s Feature Policy
</li>
	<li>
~IF［
%施策 が`継承した施策$[ %特色機能 ] ~EQ `不能化される^i
］
⇒
~RET `不能化される^i
◎
If policy’s inherited policy for feature is Disabled, return "Disabled".
</li>
	<li>
<p>
~IF［
%施策 の`宣言-済み施策$[ %特色機能 ] ~NEQ ε
］：
◎
If feature is present in policy’s declared policy:
</p>
		<ol>
			<li>
~IF［
`許容listは生成元に合致する$( %施策 の`宣言-済み施策$[ %特色機能 ], %生成元 )
］
⇒
~RET `可能化される^i
◎
If the allowlist for feature in policy’s declared policy matches origin, then return "Enabled".
</li>
			<li>
~RET `不能化される^i
◎
Otherwise return "Disabled".
</li>
		</ol>
	</li>
	<li>
~IF［
%特色機能 の`既定の許容list$ ~EQ `全~生成元$i
］
⇒
~RET `可能化される^i
◎
If feature’s default allowlist is *, return "Enabled".
</li>
	<li>
~IF［
%特色機能 の`既定の許容list$ ~EQ `'self'^l
］~AND［
( %生成元, %文書 の生成元 )
は`同じ生成元~domain$である
］
⇒
~RET `可能化される^i
◎
If feature’s default allowlist is 'self', and origin is same origin-domain with document’s origin, return "Enabled".
</li>
	<li>
~RET `不能化される^i
◎
Return "Disabled".
</li>
</ol>

		</section>
		<section id="report-violation">
<h3 title="Generate report for violation of feature policy with message, on settings">10.12. %設定群 上で %特色機能~施策 の違反~用に %~message を伴う報告を生成する</h3>

<p>
この~algoは、所与の
( `特色機能$ %特色機能, 文字列 %~message, `環境~設定群~obj$ %設定群, 文字列 %~group （省略時は `default^l ） )
に対し，［
%特色機能 に対する施策の`違反$についての %~message
］を包含する`報告$を生成する：
◎
Given a feature (feature), a string (message), an environment settings object (settings), and an optional string (group), this algorithm generates a report, containing message, about the violation of the policy on feature.
</p>

<ol>
	<li>
%本体 ~LET 次のように初期化された新たな `FeaturePolicyViolationReportBody$I
⇒＃
`featureId$m ~SET %特色機能 の文字列~表現,
`message$m ~SET %~message,
`sourceFile$m ~SET ~NULL,
`lineNumber$m ~SET ~NULL,
`columnNumber$m ~SET ~NULL,
`disposition$m ~SET `enforce^l
◎
Let body be a new FeaturePolicyViolationReportBody, initialized as follows:
◎
featureId
• feature’s string representation.
message
• message
sourceFile
• null
lineNumber
• null
columnNumber
• null
disposition
• "enforce"
</li>
	<li>
~IF［
~UAは現在~scriptを実行している
］~AND［
%設定群 から~source~fileの［
~URL, 行番号, 列番号
］を抽出できる†
］
⇒
それに則って， %本体 の［
`sourceFile$m, `lineNumber$m, `columnNumber$m
］を設定する
【† ~URLのみ抽出できる場合もあるかもしれない。その場合、 `sourceFile^m のみ設定されることになりそうだが，何もしないようにも読める。】
◎
If the user agent is currently executing script, and can extract the source file’s URL, line number, and column number from settings, then set body’s sourceFile, lineNumber, and columnNumber accordingly.
</li>
	<li>
`報告先~group用に~dataを~queueする$( %本体, `feature-policy-violation^l, %~group, %設定群 )
◎
↑↑If group is omitted, set group to "default".
◎
Execute Reporting API §#queue-report with body, "feature-policy-violation", group, and settings.
</li>
</ol>

<p class="note">注記：
特色機能~施策が`違反-$されたときには、この~algoが~callされるべきである。
◎
Note: This algorithm should be called when a feature policy has been violated.
</p>

		</section>
	</section>
	<section id="iana-considerations">
<h2 title="IANA Considerations">11. ~IANA 考慮点</h2>

<p>
恒久的~message~header~registryは、次の登録で更新されるべきである
`RFC3864$r
：
◎
The permanent message header field registry should be updated with the following registration [RFC3864]:
</p>

<div>

<dl>
	<dt>~header名</dt>
	<dd>`Feature-Policy^h</dd>

	<dt>適用-可能な~protocol</dt>
	<dd>http</dd>

	<dt>位置付け</dt>
	<dd>標準</dd>

	<dt>Author/Change controller</dt>
	<dd>W3C</dd>

	<dt>仕様~文書</dt>
	<dd>
<a href="https://wicg.github.io/feature-policy/">Feature Policy API</a>
【この仕様】
</dd>
</dl>

◎
Header field name
• Feature-Policy
Applicable protocol
• http
Status
• standard
Author/Change controller
• W3C
Specification document
• Feature Policy API
</div>

	</section>
	<section id="privacy-and-security">
<h2 title="Privacy and Security">12. ~privacyと~security</h2>

<p>
この仕様は、埋込まれる頁~上で施行することになる施策を設定するための仕組みを標準~化する。
`iframe^e 要素の `sandbox$aF 属性と同様に、これは，埋込まれる頁から許可が明示されなくとも行える。
それは、すでに公表された~web~site内に存在している特色機能の挙動を変更できることを意味する
— 別の文書~内で、それらの頁を，適切な容器~施策を伴わせて埋込むことにより。
◎
This specification standardizes a mechanism for an embedding page to set a policy which will be enforced on an embedded page. Similar to iframe sandbox, this can be done without the express permission of the embedded page, which means that behaviors of existing features can be changed in published web sites, by embedding them in another document with an appropriate container policy.
</p>


<p>
そのようなわけで、最も重大な
~privacy／~security
上の懸念は：
◎
As such, the biggest privacy and security concerns are:
</p>

<ul>
	<li>
非同一生成元 下位frame内の挙動が，それを埋込んでいる側に公開されること
◎
Exposure of behavior in a cross-origin subframe to its embedder
</li>
	<li>
埋込んだ側が制御することによる、下位frameにおける挙動の予想外の変化
◎
Unanticipated behavior changes in subframes controlled by the embedder
</li>
</ul>

<p>
これらの懸念は、すでにある程度~web~platformに在する。
この仕様は、少なくとも それを無用に悪化させないよう試みる。
◎
To a degree, these concerns are already present in the web platform, and this specification attempts to at least not make them needlessly worse.
</p>


<p>
個々の特色機能の設計も，~securityと~privacyの課題をもたらし得るので、この仕様と統合するときには，~careされ~MUST。
この節は、どの種類の挙動がそのような課題をもたらし得るかについて，いくつかの手引きを供することを試みる。
◎
Security and privacy issues may also be caused by the design of individual features, so care must be taken when integrating with this specification. This section attempts to provide some guidance as to what kinds of behaviors could cause such issues.
</p>



		<section id="privacy-expose-behavior">
<h3 title="Exposure of cross-origin behavior">12.1. 埋込まれた非同一生成元の挙動の公開</h3>

<p>
特色機能は、［
~frame化された文書における施策の`違反$は、他の~frame内の文書からは観測-可能にならない
］ように，設計されるべきである。
具体例として、仮に，ある特色機能が［
施策により不能化されている下で利用されたときは、当の~frameを埋込んでいる文書に向けて~eventを発火させる
］となると、埋込まれた文書の状態についての情報を抽出することにも利用できることになる。
具体例として，［
その特色機能は，利用者が~siteに~log-inしている間に限り利用される
］ことが既知である場合、埋込んだ側は
— その特色機能を当の~frameに対し不能化した上で，結果の~eventを~listenすることにより —
利用者が~log-inしているかどうか決定することもできる。
◎
Features should be designed such that a violation of the policy in a framed document is not observable by documents in other frames. For instance, a hypothetical feature which caused a event to be fired in the embedding document if it is used while disabled by policy, could be used to extract information about the state of an embedded document. If the feature is known only to be used while a user is logged in to the site, for instance, then the embedder could disable that feature for the frame, and then listen for the resulting events to determine whether or not the user is logged in.
</p>

<p>
自己検分~APIは、［
下位frameの施策について、埋込んでいる文書から，すでに演繹できる情報
］のみを示すように設計されている。
この`観測-可能な施策$は、~frame化された文書に伴って送達された どの~HTTP~headerからも影響されない。
加えて、~frame自身が他へ~navigateされても
— その先が，異なる施策が適用される異なる生成元であっても —
変化しない。
`観測-可能な施策$を更新させるのは、 `iframe^e 要素の `src$aF 属性を設定して生じる~naviに限られる。
◎
The introspection API is designed to only show information about a subframe’s policy which could already be deduced by the embedding document. This observable policy is not affected by any HTTP headers delivered with the framed document, and does not change when the frame navigates itself, even if such navigation is to a different origin, where a different policy applies. Only navigations caused by setting the src attribute of the &lt;iframe&gt; element will cause the observable policy to be updated.
</p>


		</section>
		<section id="privacy-alter-behavior">
<h3 title="Unanticipated behavior changes">12.2. 挙動の予想外の変化</h3>

<p>
特色機能~施策は、［
ある下位frameが読込まれる時点で，［
その~frame内で，どの特色機能が可用になるか, ならないか
］を制御する能
］を，文書に是認する。
当の特色機能が，~web~platformに長期に存在していた挙動を表現しているならば、このことは［
~web上に公表された既存の内容において，特定0の~APIが失敗し得る
］ことを意味する（内容がそれを予期することなく書かれたならば）。
◎
Feature policy grants a document the ability to control which features will and will not be availble in a subframe at the time it is loaded. When a feature represents an existing, long-standing behavior of the web platform, this may mean that existing published content on the web was not written with the expectation that a particular API could fail.
</p>

<div class="example">

<p>
（不自然だが）実用的な例として、［
利用者が頁に~accessするに足る特権を有するかどうか
］を，同期的 `XMLHttpRequest$I を利用して決定している文書を考える：
◎
As a practical (though contrived) example, consider a document which uses synchronous XMLHttpRequest to determine whether a user has sufficient privileges to access the page:
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;h1&gt;Welcome to SecureCorp!&lt;/h1&gt;
&lt;script&gt;
  var %req = new XMLHttpRequest();
  %req.open("GET", "/api/security_check.json", false);
  %req.send();
  if (%req.response == "untrusted user") {
	/* <span class="comment">
利用者は~log-inしていない
— 安全な頁へ~redirectする
◎
User is not logged in; redirect to a safe page
</span> */
    location.href = "/security_check_failed.html";
  }
&lt;/script&gt;
&lt;!-- <span class="comment">
頁は、利用者が~log-inした前提の下で継続する
◎
Page continues with assumption that user is logged in
</span> --&gt;
</pre>

<p>
この文書がある頁に埋込まれ，その頁が `sync-xhr^l 特色機能を不能化した場合、
`XMLHttpRequest.open()^m の~callは失敗して，~security検査は迂回されることになる。
◎
If this document is embedded by a page which disables the "sync-xhr" feature, the call to XMLHttpRequest.open() would fail, and the security check would be bypassed.
</p>

</div>

<p>
~web上では、この類の挙動の強制-法はすでにアリなことに注意。
特色機能には、 `iframe^e には許容されず，~top-level文書~内に限り許容されるものもある。
また， `iframe^e ~sandbox法は、類似する仕方で，~frameを
— それが依存し得る特色機能に~accessすることなく —
埋込むときに利用できる。
◎
Note that this sort of behavior forcing is already possible on the web: some features are only allowed in top-level documents, and not in any iframes, and iframe sandboxing can be used in a similar way to embed a frame without access to features which it may be depending on.
</p>


<p>
一般に，この懸念を軽減するには、 2 つの仕方がある：
◎
In general, this concern is mitigated in two ways:
</p>

<ul>
	<li>
脆弱な頁は、 `X-Frame-Options^h ~HTTP~headerを伴わせて ~serveできる
— そうすれば、攻撃者が~frame化するのは許容されなくなるので。
◎
The vulnerable page may be served with an X-Frame-Options HTTP header which does not allow it to be framed by an attacker.
</li>
	<li>
~siteは、~APIや挙動を利用しようと試みる前に，それが可用かどうかを特色機能~検出を利用して決定した上で、~callした~APIから［
返された~error／投出された例外
］を取扱うべきである。
◎
Sites should use feature detection to determine whether an API or behavior is available before attempting to use it, and should handle any documented errors returned or exceptions thrown by the APIs they call.
</li>
	<li>
特色機能~検出がアリでない事例では、新たな~web内容は［
`Policy$I ~objを利用して，現在~施行されている特色機能~施策を検分した上で、それに則って挙動や~UIを調整する
］ように書ける。
◎
In the case where feature detection is not possible, new web content can be written to use the policy object to inspect the feature policy which is currently enforced, and adjust behaviour or user interface accordingly.
</li>
</ul>

<p>
自身による特色機能を この仕様と統合している策定者は、［
当の特色機能が不能化されている下で，文書がそれを利用しようと試みたとき、それが いつどのように失敗することになるか
］を裁定できる。
策定者は、既存の失敗~mode【既存の例外~名など】が存在するならば，それを用立てようと試みるべきである
— そうすれば、そのような失敗をすでに正しく取扱っている既存の内容への~~影響は抑えられるので。
◎
Authors integrating their features with Feature Policy can decide when and how the feature will fail when a document attempts to use it while it is disabled. Authors should attempt to make use of existing failure modes, when they exist, to increase the chance that existing content will already be correctly handling such failures.
</p>

		</section>
		<section id="privacy-expose-policy">
<h3 title="Exposure of embedding policy">12.3. 埋込んでいる側の施策の公開</h3>

<p>
ある頁が非同一生成元~頁を埋込んでいるとき
— 埋込んだ側が，埋込まれた側の挙動について推定できる情報を制限するよう~careされていたとしても —
局面によっては、埋込まれた側が，埋込んだ側の情報について推定することも
— ［
自身に対し，埋込んだ側が施行した施策
］を吟味することにより —
アリになり得る。
◎
Care has been taken to limit the information which an page can infer about the behavior of cross-origin pages which it embeds. It may be possible in some scenarios however, for the embedded page to infer information about its embedder, by examining the policy which the embedder has enforced on it.
</p>

<p>
これは既存の `document.fullscreenEnabled$m に類似する。
それは、埋込まれた側の文書が［
埋込んだ側は、埋込まれた側に `FULLSCREEN$r ~APIを利用する能を是認したかどうか
］を推定するために利用できる。
これが ある種の事例
— 具体例として，利用者が埋込んだ側の~siteに~log-inしたとき —
に限り是認される場合、埋込まれた側の~siteは，埋込んだ側の状態について何かを知り得るようになる。
◎
This is similar to the existing document.fullscreenEnabled property, which can be used by the embedded document to infer whether its embedder has granted it the ability to use the Fullscreen API. If this is only granted in certain cases — when the user is logged in to the embedding site, for instance — then the embedded site can learn something about the state of its embedder.
</p>
		</section>
	</section>
</main></div>
