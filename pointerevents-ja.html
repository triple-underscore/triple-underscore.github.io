<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Pointer Events — Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<style>

img {
	object-fit:contain;
}

table.propdef {
	border-spacing: 0;
	background-color: #ddeeff;
	border-left: 0.5em solid;
}

table.propdef {
	border-left-color: #8ccbf2;
}

table.propdef tr {
	border-top-color: #bbd7e9;
}

table.propdef th {
	white-space: nowrap;
}

table.propdef td {
	min-width: 12em;
	border-left: 1px solid #bbd7e9;
}


</style>

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	var source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked 161118 spec
}

function expand(){
	var link_map = this.link_map;
	var unicode_map = this.unicode_map;
	var class_map = {
		E: 'error',
		l: 'literal',
		et: 'event-type',
		e: 'element',
		p: 'css', // CSS
		v: 'value', // CSS
	};
	var tag_map = {
		c: 'code',
		I: 'code',
		E: 'code',
		m: 'code',
		et: 'code',
		l: 'code',
		e: 'code',
		p: 'code', // CSS
		v: 'code',// CSS
		i: 'i',
		V: 'var',// CSS
	};
	var current_ifc = '';

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#bib-' + key;//.toLowerCase();
	break;
case 'e': // DOM element tag name
	break;
case 'I': // IDL interface
	if((indicator === '@') || (indicator === '!')){
		current_ifc = '#dom-' + key.toLowerCase() + '-';
	}
	break;
case 'E': // Error
	break;
case 'C': // interface attr cnst member
	break;
case 'm' : // interface member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = current_ifc + key.toLowerCase();
	break;
case 'et': // event type
	href = '#the-' + key + '-event';
	break;
case 'l': //literal
	return '"<code class="literal">' + key +'</code>"'
	break;
case 'v': // CSS 値
	href = '#valdef-touch-action-' + key;
	break;
case 'en': // english words
	return '<span lang="en-x-a0">' + key + '</span>'
	break;
case 'pull': // bug
	text = '(#' + key + ')';
	href = '~POINTEREVENTS_pull/' + key;
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}

if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;

	}
}
</script>



<script type="text/plain" id="_source_data">


●●options

spec_date:2018-04-03
trans_update:2018-04-07
page_state_key:UIEVENTS
original_url:https://w3c.github.io/pointerevents/
spec_status:ED
ref_id_prefix:bib-
conformance:w3c
copyright:2018,permissive
trans_1st_pub:2015-10-08


●●original_id_map


	implicit-pointer-capture:dfn-implicit-pointer-capture

	tracking-the-effective-position-of-the-legacy-mouse-pointer:dfn-tracking-the-effective-position-of-the-legacy-mouse-pointer

	propdef-touch-action:the-touch-action-css-property
valdef-touch-action-auto:
valdef-touch-action-none:
valdef-touch-action-pan-x:
valdef-touch-action-pan-y:
valdef-touch-action-manipulation:

	●二重 id
	the-pointerover-event:dfn-pointerover
	the-pointerenter-event:dfn-pointerenter
	the-pointerdown-event:dfn-pointerdown
	the-pointermove-event:dfn-pointermove
	the-pointerup-event:dfn-pointerup
	the-pointercancel-event:dfn-pointercancel
	the-pointerout-event:dfn-pointerout
	the-pointerleave-event:dfn-pointerleave
	the-gotpointercapture-event:dfn-gotpointercapture
	the-lostpointercapture-event:dfn-lostpointercapture
	pointer-capture:dfn-pointer-capture
	compatibility-mapping-with-mouse-events:dfn-compatibility-mouse-events
		the-primary-pointer:dfn-primary-pointer


●●link_map



Exposed:~WEBIDL#Exposed
I.Element:~DOM4#element
	#dom-element
I.MouseEvent:~UIEVENTS#interface-mouseevent
I.MouseEventInit:~UIEVENTS#dictdef-mouseeventinit
I.GlobalEventHandlers:~WAPI#globaleventhandlers
	#dom-globaleventhandlers
I.Navigator:~HTMLnavigator#navigator
	#dom-navigator
I.PointerEventInit:#idl-def-pointereventinit
	#dom-pointereventinit
I.PointerEvent:#idl-def-pointerevent
	#dom-pointerevent

m.target:~DOM4#dom-event-target
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.composed:~DOM4#dom-event-composed
m.isTrusted:~DOM4#dom-event-istrusted
m.preventDefault:~DOM4#dom-event-preventdefault

m.setPointerCapture:#dom-element-setpointercapture
m.releasePointerCapture:#dom-element-releasepointercapture
m.hasPointerCapture:#dom-element-haspointercapture

m.maxTouchPoints:#dom-navigator-maxtouchpoints

m.relatedTarget:~UIEVENTS#dom-mouseevent-relatedtarget
m.button:~UIEVENTS#dom-mouseevent-button
m.buttons:~UIEVENTS#dom-mouseevent-buttons
m.detail:~UIEVENTS#dom-uievent-detail

	m.isPrimary:#dom-pointerevent-isprimary
	m.pointerType:#dom-pointerevent-pointertype
	m.pointerId:#dom-pointerevent-pointerid
	m.ownerDocument:~DOM4#dom-Node-ownerDocument

m.InputDeviceCapabilities.pointerMovementScrolls:https://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-pointermovementscrolls

m.screenY:~CSSOMVIEW#dom-mouseevent-screeny
m.screenX:~CSSOMVIEW#dom-mouseevent-screenx

et.contextmenu:~HTMLindex#event-contextmenu
et.click:~UIEVENTS#event-type-click
et.dblclick:~UIEVENTS#event-type-dblclick
et.focus:~UIEVENTS#event-type-focus
et.blur:~UIEVENTS#event-type-blur

et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseup:~UIEVENTS#event-type-mouseup
et.mouseover:~UIEVENTS#event-type-mouseover
et.mouseout:~UIEVENTS#event-type-mouseout
et.mouseenter:~UIEVENTS#event-type-mouseenter
et.mouseleave:~UIEVENTS#event-type-mouseleave
et.mousemove:~UIEVENTS#event-type-mousemove


p.touch-action:#propdef-touch-action
p.display:~CSSDISP#propdef-display
p.width:~CSS2VISUDET#propdef-width
p.height:~CSS2VISUDET#propdef-height


作動状態:#dfn-active-buttons-state
作動中の~pointer:#dfn-active-pointer
作動中の:#dfn-active-pointer
作動中:#dfn-active-pointer

取消された:#dfn-canceled-event
接触~幾何:#dfn-contact-geometry
~digitizer:#dfn-digitizer
接触判定:#dfn-hit-test
~pointer:#dfn-pointer
~pointing先:#_pointing
捕捉~込みの~pointing先:#_pointing-with-capture

~UA:#dfn-user-agent
~taskを~queueする:#dfn-queue-a-task
~mouse~event:#_mouse-event
~pointer~event:#_pointer-event
~buttonの追加押下げ:#dfn-chorded-buttons
追加押下げ:#dfn-chorded-buttons
	#chorded-button-interactions

首~pointer:#dfn-primary-pointer
~pointer~eventを発火-:#dfn-fire-a-pointer-event-name-e

発火-:#dfn-fire-an-event-named-e
発火する:~DOM4#concept-event-fire
	#dfn-fire-an-event-named-e
	~eventを発火-
~pointer捕捉:#pointer-capture
捕捉:#pointer-capture
明示的に解放-:#releasing-pointer-capture
~pointer捕捉の解放-法:#releasing-pointer-capture
設定-:#setting-pointer-capture
~pointer捕捉の設定-法:#setting-pointer-capture

	Pointer Capture:#dfn-pointer-capture
捕捉標的:#dfn-pointer-capture-target-override
処理待ち捕捉標的:#dfn-pending-pointer-capture-target-override
互換性~mouse~event:#compatibility-mapping-with-mouse-events
	#dfn-compatibility-mouse-events＊原文リンク先未定義
旧来の~mouse~pointerの実効~位置:#dfn-effective-position-of-the-legacy-mouse-pointer

~hoverを~supportしない:#mapping-for-devices-that-do-not-support-hover
~pointer捕捉の暗黙的な解放-:#implicit-release-of-pointer-capture
暗黙的に解放-:#implicit-release-of-pointer-capture
処理待ち~pointer捕捉を処理-:#process-pending-pointer-capture

暗黙的な~pointer捕捉:#implicit-pointer-capture

旧来の~mouse~pointerに対する位置の追跡-法:#tracking-the-effective-position-of-the-legacy-mouse-pointer

適合する:#dfn-conforming-touch-behavior

	§各種 属性と既定~動作:#attributes-and-default-actions
	§各種 ~pointer~event型:#pointer-event-types
	§~pointer捕捉の設定-法:#setting-pointer-capture
	§~pointer捕捉の解放-法:#releasing-pointer-capture
	§処理待ち~pointer捕捉を処理-:#process-pending-pointer-capture
	§~pointer捕捉の暗黙的な解放-:#implicit-release-of-pointer-capture
	§`touch-action^p 値:#details-of-touch-action-values
	§首~pointer:#dfn-primary-pointer


	●補完
互換性~mouse~eventも込みで配送する:#_fire-compatibility-mouse-events
~mouse~event防止~flag:#_prevent-mouse-event-flag
	既定の~touch挙動:#_default-touch-behavior
~touch用の既定の挙動:#_default-touch-behavior

置換され:~CSSDISP#replaced-element
行内~要素:~CSSDISP#inline

接続されて:~DOM4#connected
広義先祖:~DOM4#concept-tree-inclusive-ancestor
文書~内:~DOM4#in-a-document
	文脈~obj:~DOM4#context-object
	~node文書

~trusted:~UIEVENTS#trusted-events
非trusted:~UIEVENTS#trusted-events
同期的:~UIEVENTS#sync-async
浮上-:~UIEVENTS#bubble-phase
伝播~経路:~UIEVENTS#propagation-path
取消~可:~UIEVENTS#_cancelable
	＊
既定~動作:~UIEVENTS#default-action
	作動化の挙動:~UIEVENTS#activation-behavior
~event連列:#_event-sequence

~event~handler IDL 属性:~WAPI#event-handler-idl-attributes
~Window:~UIEVENTS#window

~top-level閲覧文脈:~BROWSERS#top-level-browsing-context
	https://www.w3.org/TR/html/browsers.html#〜
~drag操作oが開始され:~HTMLdnd#initiate-the-drag-and-drop-operation


●●words_table1


TOUCHEVENTS:touch-events-ja.html
	http://www.w3.org/TR/touch-events/
COMPAT:compat-ja.html
public_pointer_events:https://lists.w3.org/Archives/Public/public-pointer-events
POINTEREVENTS_pull:https://github.com/w3c/pointerevents/pull

hover_ps:<code class="pseudo">:hover</code>


●●words_table




	●UI
UX:
利用者体験:experience:~
様式:modalities:方式
UI:user interface:UI
client::::クライアント
navi:navigation:::ナビ
window::::ウィンドウ
menu::::メニュー
click::::クリック
	~overscroll
	~pull-to-refresh
pointing::::ポインタ指示
metaphor::::メタファー
widget::::ウィジェット
affordances::::アフォーダンス
control::::コントロール
form::::フォーム
shortcut::::ショートカット
	x1
	x2
drag::::ドラッグ
button::::ボタン
cursor::::カーソル
gesture::::ジェスチャ
double-tap::::連続タップ
tap::::タップ
hardware::::ハードウェア
hover::::
	hoverしている／:hovering
keyboard::::キーボード
	に類するkeyboard-like
machine::::マシン
trackpad::::トラックパッド
laptop::::ラップトップ
mouse::::マウス
pen::::ペン
pointer::::ポインタ
screen::::スクリーン
screenreader::::スクリーン読取り器
pan::::パン
zoom::::ズーム
panning::::パン操作
pan-zoom:panning or zooming:::パン／ズーム操作
scroll::::スクロール
scrolling::::スクロール操作
zooming::::ズーム操作
slide::::スライド
slider::::スライダ
stylus::::スタイラス
thumb:::つまみ

中央:middle:~
左:left:~
右:right:~

digitizer::::ディジタイザ
eraser::::イレーザ
barrel::::バレル
airbrush::::エアブラシ
wheel::::ホイール
中立の:neutral:~
制御:control:~

twist::::ツィスト
touch::::タッチ
touchscreen::::タッチスクリーン
transducer::::
感知:sense::~
感知器:sensing device::~
	~sense:sense:::
	~single-pointer:single-pointer:::
装置:device:~
機器:device:~
携帯:mobile::~::モバイル
tablet::::タブレット
複button:multi-button:::複ボタン
複pointer:multi-pointer:::複ポインタ
複touch:multi-touch:::複タッチ
押-:press:~
	押して
離され:release され:~
離した:release した:~
押下する:depress する:押下げる
押下され:depress され:押下げられ
追加押下げ:chorded presses:~
	~chorded:chorded:::
	~chordedボタン~presses
	押下-:depress:~
押圧:pressure:~
圧:pressure:~
方位:orientation:~
方向:direction:~
物理的:physical:~
物理的面:surface:~

持上げら:lift さ:持ち上げら
	~~離した:lift した
手指:finger:指
接触:contact::~
接触-:contact::~
	近接しているclose proximity
接続-:connect:~
対話:interaction:~
対話-:interact::やりとり
操作i:interaction::操作
操作o:operation:操作
操作-:manipulate:~
操作:manipulation:~
	~~操作
支援的:assistive:支援
主導的:master:~

前後:back-and-forth:~
	応答性を〜:low-latency:~
外部:external:~
動き:movement:~
動いて:move して:~
	動いた:move した:~
制動-:counteract:~
制動:counteraction:~
惰性:simulated inertia:~
敏捷:rapid:~
休めれ:rest でき:休められ:~
遅める:slow down する:~
停止-:stop:~
勢い:momentum:~
	もっと勢いをつける:provide further momentum
	置いて:place
	投げつけ:fling
	錯覚させるような:providing a physical illusion
	出た:leave
	なくなった:leave
	なった:enter
	それた:slides off
	それた:drifts off
	それる:stray
	遅延:delay
	~buttonが押され:down
	利用-中にある:actively being used
	手:hand


	●event
task::::タスク
event::::イベント
handler::::ハンドラ
listener::::リスナ
listen::::リッスン
bind::::バインド
lock::::ロック
処理待ち:pending::~
bitmask::::ビットマスク
composed:
文書:document:~
標的:target:::ターゲット
	retarget
標的にし:target し:::ターゲットにし
浮上-:bubble::~
発火-:fire::~
発火:firing::~
伝播:propagation::~
経路:path::~
要素:element:~
遷移:transition:~
配送-:dispatch::~
非trusted:untrusted:非 trusted
同期的:synchronous:~
首:primary::~
動作-:act::~::アクト
動作:action::~::アクション

取消-:cancel::取り消::キャンセル
取消:cancel::取り消し::キャンセル
	取消~結果:cancellation
取消す:cancel する::取り消す::キャンセルする

受取って:receive して:受け取って
受取る:receive する:受け取る
focus::::フォーカス
	~focus可能:focusable
同時に:simultaneous に:~
同時的:concurrent:~
合成の:synthetic:~

作動中:active::~::アクティブ
作動中の:active な::~::アクティブな
作動化:activation::~::アクティブ化
作動状態:active state::~::アクティブ状態
初期化-:initialize::~
接触判定:hit test::~
	hit testing
送信-:send:~
queue::::キュー
誘発-:trigger:~
誘発:triggering:~
解放-:release:~
	解放-法:releasing
連列:sequence:~
	~~連列:stream
生成-:generate:~
生産-:produce:~
生産:production:~
登録:registration:~
消費-:consume:~
追跡-:track:~
	追跡-法:tracking
順序:order:~
順序関係:relative ordering:~
捕捉標的:pointer capture target override::捕捉ターゲット
捕捉:capture::~
	~pointer捕捉:pointer-capture:::

	●幾何
傾き:tilt:::~
	側に傾いて:tilt away
接線方向:tangential::~
接線:tangent::~
平面:plane:~
座標:coordinate:~
幾何:geometry::形状
座標系:coordinate space:~
size::::サイズ
位置:position:~
回転:rotation:~
回転-:rotate:~
変形-:transform:~
変形:transformation:~
領域:region:~
角度:angle:~
法線:normal:~
	境界:boundaries:~
境界:boundary:~
外側:outside:~
	上端:top:~
	上方:upward:~
	下方:downward:~
	右端
	右側
	右方
	左方
	上方
時計回り:clockwise:~
平行:parallel:~
形:form:~
軸:axis:~
縦幅:height:~
横幅:width:~
横方向:horizontal:~
縦方向:vertical:~
分解能:resolution:~

	●CSS
CSS:
layout::::レイアウト
prop:property:::プロパティ
table::::テーブル
group::::
animation::::アニメーション
媒体:media::~::メディア
置換-:replace:~
	置換されない:non-replaced::~
行内:inline::~
画素:pixel::~
pixel::::ピクセル
	異なる:different:~
疑似類:pseudo-class:::疑似クラス
継承-:inherit:~
視覚的:visual:~
表示域:viewport:~
算出値:computed value:~
指定値:specified value:~
百分率:percentage:~
初期値:initial value:~
離散的:discrete:~


	●仕様
system::::システム
API:
level::::レベル
tool::::ツール
algo:algorithm:::アルゴリズム
app:application:::アプリ
approach::::アプローチ
native::::ネイティブ
overhead::::オーバーヘッド
UA:user agent:UA
OS:operating system:OS
手間:cost:~
	版:edition:::
	emulation
抑止-:suppress:~
中止-:abort:~
logic::::ロジック
model::::モデル
custom::::カスタム
	~custom化:customize
platform::::プラットフォーム
program::::プログラム
vendor::::ベンダ
version::::バージョン
	~advice:advice:::
level::::レベル
一定の:certain:~
一意:unique:~
手法:method::~
不意の:accidental:~
事例:case:~
互換性:compatibility:~
互換:compatible:~
	互換にならない:incompatible:~
今日:today:~
仕様:spec:~
仕組み:mechanism:~
代表的な:typical:~
低次の:low-level な:~
高次の:high-level な:~
類似性:similarities:~
作者:author:~
効果:effect:~
勧告:Recommendation:~
編集者草案:Editor’s Draft:~

参考:informative:~
同義語:synonymous:~
問題:problem:~
基本的な:basic:~
多義性:ambiguity:~
多義的:ambiguous:~
相互運用可能:interoperable:~
実際の:actual:~

	容易:easily:~
容易く:easy に:~
容易に:easy に:~
対照的に:in-contrast:~
将来:future:~
将来の:future:~
局面:scenario:~
	それについては:scenario:~
履歴:history:~
	必要とされ／必要に応じて:necessary
	不必要な:unnecessary
	とは限らない:necessarily
手段:means:~
手続き:steps:~
下位手続き:substeps:~
抽象化:abstract:~
抽象的:abstract:~
方式:manner:~
既定:default::~::デフォルト
旧来の:legacy:~
明示的:explicit:~
暗黙的:implicit:~
暗黙的な:implicit:~
有効:effective:~
実効:effective:~
実質的:effective:~
有用:useful:~
概して:typical に:~
汎用:generic:~
一般:general:~
特別:special:~
特定0の:particular:ある特定の
特定の:specific な:~
特有の:-specific な:~
特色機能:feature:~
状況0:situation:状況
状況:circumstance:~
独立:independent:~
現在:currently:~
現在の:current:~
用語:term:~
用語集:glossary:~
目標:goal:~
目的:purpose:~

節:section:~
精確な:precise:~
編集上の:editorial:~
編集者:editor:~
注意深く:careful に:~
規範的:normative:~
視野外:out of scope:~
詳細:details:~
課題:issue:~
開発者:developer:~
関連する:relevant な:~
	難しく:hard に:~
非依存の:-agnostic:に依らない

共通的な:common な:よくある
共通的に:common に:よく
	可能:possible
	念頭:mind:~
情報:information:~
技術:technology:~
通例の:usual:~
通常の:normal:~
通常は:normal には:~
通常通り:as normal:通常どおり
変更点:changes:~
序論:introduction:~
任意選択の:optional:~
	OPTIONAL
最良の:best:~
機能性:functionality:~
概念:concept:~
理由:reason:~
整合する:consistent になる:~
妥当:valid:~

制限:limitations:~
懸念:concerns:~
伝統的:traditional:~
間接的:indirect:~
直接的:direct:~
直接:direct:~
概念的:conceptual:~
正確:exact:~
慣行:convention:~
支配的:dominant:~
特質:properties:~
指針:guideline:~
仕方:way:~
受容-:accept:~
公開-:expose:~
標準:standard:~
	標準でない:non-standard
	標準~化:standardize
代替:alternate:~
意味論:semantics:~
要旨-:outline:~
通例的:usual:~

	区別されない:no distinction
	視点:perspective
	直前:right before／Immediately before
	より良く:better
	利する:behalf
	見よ:see
	できる:capable
	介:via
	依然として:still
	例:example
	方法:how
	支持を受けて:in favor of
	note
	noted
	~~区別する:differentiating
	方々:people
	先駆的:pioneer
	acknowledge
	~~向上:augmented／best
	~helped
	大勢を占めている:vast majority
	用例:sample code demonstrating how to
	用例:author code that demonstrates how
	用例:demonstration of how
	しかしながら:however
	したがって:therefore
	したがって:thus
	とりわけ:especially
	ないと見込まれる:unlikely
	より容易:easier
	しないように:avoid
	あり得る:possible
	~~重要な:key
	natively:~UA既定の挙動で
	~~推測／~~偽造guessing/faking
	上手く:well
	具体例として:for instance
	まず第一に:In the first instance
	第一:primary
	第二:additional key

	●仕様（動詞
opt-in:
support::::サポート
著作:authoring:~
	易くする:help with
対応付けて:map して::~
対応付けら:map さ::~
対応付け:mapping::~
	map
	mapping
	~~影響:impact
影響-:affect:~
上書き:override:~
依存-:depend:~
依存関係:dependency:~
保証-:guarantee:~
保証:guarantee:~
保守-:maintain:~
単純化-:simplify:~
取扱い:handling:取り扱い
取扱う:handle する:取り扱う
取扱える:handle できる:取り扱える
奨励-:encourage:~
定義-:define:~
定義:definition:~
実装-:implement:~
実装:implementation:~
宣言-:declare:~
	宣言-法:declaring
意味-:mean:~
意味:meaning:~
意図的:intentional:~
手助け:facilitate:~
	易く
	招かれ:incur され
拡張-:extend:~
拡張0-:expand:拡張
拡張:extension:~
指示-:indicate:~
挙動:behavior:ふるまい
挙動する:behave する:ふるまう
	助言:recommendation:~
供-:provide:~
提案-:propose:~
提案:proposal:~
改訂:revision:~
既存の:existing:~
既知:known:~
明確化-:clarify:~
明確化:clarifications:~
最適化:optimization:~
期待-:expect:~
未定義:undefined:~
決定-:determine:~
	決定-法:determining
無視-:ignore:~
相違-:differ:~
相違点:difference:~
確保-:ensure:~
築く:build する:~
表現-:represent:~
表現:representation:~
	統一された:unified:~
組入れら:incorporate さ:組み入れら
組入れて:incorporate して:組み入れて
考慮-:consider:~
要約-:summarize:~
	要約:summary
	要約:outline
見なさ:consider さ:~
見做す:assume する:~
見做して:assume して:~
見做せな:assume できな:~
見做され:assume され:~
見出され:find され:~
	受け入れ:adoption
要求-:require:~
設計:design:~
貢献:contribution:~
選定:selection:~
述べる:describe する:~
適用-:apply:~
	選ぶ:choose する:~
関係-:relate:~
関係性:relationship:~
防止-:prevent:~
阻む:block する:~
働く:work する:~
共有-:share:~
	利用:use:~
利用者:user:~
制約-:restrict:~
制約:restriction:~
	発行:publication:~
移行-:migrate:~
	migration
解釈-:interpret:~
検索取得-:retrieve:~
設定-:set:~
	設定-法:setting
許容-:allow:~
	許容しない:disallow
可能化-:enable:~
不能化-:disable:~
減らす:reduce する:~
追加-:add:~
追加:addition:~
追加の:additional:~
	加えて:additionally
所与の:与えられた
翻訳-:translate:~
取組む:address する:取り組む
修正-:fix:~
周知:known:~
浮動-:float:~
呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
欲-:desire:~
避ける:avoid する:~
孕む:involve する:~
決める:decide する:~
	現時点では:Currently
	に委ねら:left up to
複雑:complex:~
	ならば:suppose
	~~非互換な:breaking
	浮かび上がった-:raise
	課されるものに関して:implied by
	書き直し:reword
	使われなくなっ:retire
	抜けていた:missing
	に基づく:based on
	則って:according
	対象外である:not covered
	run
	vary
	~caused
	~causing
	与え:give／given
	切り替える:toggle
	~~再利用:recycle
	返-:return
	書-:write
	書かれ:written
	含-:include
	含め:including
	生じ-:occur
	得られる:achieve
	持つ:convey
	指す:refer する／

	●未分類（動詞
call:
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
投出-:throw:~
被呼出時:被 invoke 時:~
構築-:construct:~
	constructing:~
構築子:constructor::~::コンストラクタ
作成-:create:~
処理-:process:~
処理:processing:~
処理能:performance:~
包含-:contain:~
単調増加-:monotonic に増加:~
	monotonically-increasing
合致-:match:~
呈示-:present:~
走らせ:run し:~
走らす:run する:~
変化:change:~
変更-:change:~
変更:change:~
在する:present する:在る
	在り得る:present し得:在り得
報告-:report:~
	横切った:cross:::
始まる:begin する:~
存在-:exist:~
完全な:complete:~
実行-:execute:~
実行:execution:~
	executing:~
応答-:respond:~
応答:response:~
改変-:modify:~
改変:modification:~
更新-:update:~
検出-:detect:~
	検出-可能:detectable
検出:detection:~
正規化-:normalize:~
検分-:inspect:~
稼働中の:run している:~
移動-:move:~
移動:movement:~
給-:supply:~
競合-:conflict:~
認識-:recognize:~
識別-:identify:~
識別子:identifier:~
超過-:exceed:~
継続的な:continuous:~
開始-:start:~
除去-:remove:~
適合-:conform:~
	適合-度:conformity:~
	出入り:entry/exit
	呼ばれ:call され:~
	呼んで:call して:~
	終わらせ:end
	何もしない:fails silently

	●未分類
browser::::ブラウザ
code::::コード
computing::::コンピューティング
data::::データ
interface::::インタフェース
flag::::フラグ
fallback::::フォールバック
member::::メンバ
method::::メソッド
	法／方法／手法:method
node::::ノード
obj:object:::オブジェクト
script::::スクリプト
site::::サイト
web:

	 0:zero
Window:
top-level::::トップレベル
閲覧文脈:browsing context::~
接頭辞:prefix:~
親:parent:~
子:child:~
先祖:ancestor:~
子孫:descendant:~
木:tree::~::ツリー

instance::::インスタンス
辞書:dictionary:::ディクショナリ
名前:name:~
型:type:~
	-:argument:~
属性:attribute:~
文字列:string:~
例外:exception:~
文脈:context:~
候補:candidate:~
値:value:~
絶対:absolute:~
入力:input:~
内容:content:~
可視性:visibility:~
後続の:subsequent:~
	引き続いて:subsequent
所在:location:~
条件:condition:~
逐次的:sequential:~
源:source:~
状態:state:~

空:empty:~
等価な:equivalent:~
範囲:range:~
粗い:coarse な:~

自動的:automatic:~
複thread:multi-thread:::複スレッド
	multi-threaded
	負の:negative:~
重複:duplication:~
頁:page:::ページ
成功裡:successful:~


	通:through
	表:table
	挟まれている:intermediate
	重ねて:overlapping
	~missing:missing
	-:clear
	大きさ:magnitude
	端:extent
	-:mark
	に関わらず:no matter
	-:mentioned
	:nothing
	:greater
	:back
	し続ける:continue
	:forward
	:further
	:get
	:likely
	:look
	:made
	NEQ:equal
	:point
	~~性質:qualities
	:space
	~time:time
	逆:reverse
	正の:positive
	数:number
	へ向かう:toward
	単に:simply
	近い:near
	°:degree
	属性:property


	~~地点を囲う矩形域~bounding~box
	直前に指していたwhose bounds the pointer just left
	直後に指しているwhose bounds the pointer is entering
	素早く quickly

	●保安
access::::アクセス
予見-:believe:~
保持-:hold:~
判別-:distinguish:~
導入-:introduce:~
指紋収集-:fingerprint:~
推定-:infer:~
発生-:arise:~
読込む:load する:読み込む
論じる:discuss する:~
試みる:attempt する:~
考える:consider する:~
考慮点:considerations:~
持続-:persist:~
	persistent
降格-:downgrade:~

privacy::::プライバシー
profile::::プロファイル
security::::セキュリティ
sensor::::センサー
session::::セッション
mode::::モード
一時的な:temporary:~
付録:appendix:~
個人識別可能:personally-identifiable:~
局所的:local:~
生成元:origin:~
	異なる生成元:cross-origin:~
第三者主体:third-party:~
当事者主体:first-party:~
悪意的な:malicious な:悪意のある
機密的:confidential:~
特徴:characteristic:~
環境:environment:~
直に:direct に:~
私的閲覧:incognito:~
能:ability:~
論点:discussion:~
閲覧:browsing:~
高価値:high-value:~
	working group
	呼応して:in response to
	得る:gain
	扱:deal with
	~~感知~exert
	potentially
	超え:beyond
	越し:over
	限られ:limit


	●指示語
新たな:new:~
旧-:old:~
新-:new:~
内側:inside:~
	-:intrinsic
単独の:single:~
最大:maximum:~
最小:minimum:~
自前の:own:~
	ほとんどの:most
	最初:first:~
	最後:last:~
	2 度目の:secondary:~
	2 度目:second:~
	個々の:individual:~
	最も〜:-most／-est
	途中:in the middle
	次:next
	後:after
	全く:at-all
	別の:another
	前:before
	各:each
	合間:between
	同じ:same
	等々:etc
	結果:result
	自身:itself
	両者:both
	以前の:previous
	多い:often
	対応-:correspond
	対応ing:corresponding
	常に:always
	決して:never
	~amongst
	他の:other
	他の場合:otherwise
	代わりに:instead
	一部:part
	上:above
	間:during
	~~主な:major
	~~主:major
	~~主要な:substantial
	この:this
	これらの:these
	すでに:already
	すべての:all
	その:that
	そのような:such
	それら:those
	まだ:still
	より先に:prior
	より新たな:newer
	のみならず:not just
	様々に:vary
	一式:single set
	直に:immediately
	respective
	respectively
	the following
	~~後続する:follow
	follow
	followed by
	:further
	その逆に:vice-versa
	類似する:similar
	種々の:variety
	複数／:two
	まで:until
	複数の:multiple:~
	超えて:beyond:~
	:no longer
	よく:a lot
	たくさん:lots of
	多くの:many
	一連の:series of
	別個の:separate discrete


●●ref_normative

[COMPAT]
    Compatibility Standard. Mike Taylor. WHATWG. Living Standard. URL: https://compat.spec.whatwg.org/ 
[DOM4]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTML5]
    HTML5. Ian Hickson; Robin Berjon; Steve Faulkner; Travis Leithead; Erika Doyle Navara; Theresa O'Connor; Silvia Pfeiffer. W3C. 27 March 2018. W3C Recommendation. URL: https://www.w3.org/TR/html5/ 
[PointerLock]
    Pointer Lock. Vincent Scheib. W3C. 27 October 2016. W3C Recommendation. URL: https://www.w3.org/TR/pointerlock/ 
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[UIEVENTS]
    UI Events. Gary Kacmarcik; Travis Leithead. W3C. 4 August 2016. W3C Working Draft. URL: https://www.w3.org/TR/uievents/ 

●●ref_informative

[CSS21]
    Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. Bert Bos; Tantek Çelik; Ian Hickson; Håkon Wium Lie et al. W3C. 7 June 2011. W3C Recommendation. URL: https://www.w3.org/TR/CSS2/ 
[CSSOM-VIEW]
    CSSOM View Module. Simon Pieters. W3C. 17 March 2016. W3C Working Draft. URL: https://www.w3.org/TR/cssom-view-1/ 
[PointerEvents]
    Pointer Events. Jacob Rossi; Matt Brubeck. W3C. 24 February 2015. W3C Recommendation. URL: https://www.w3.org/TR/pointerevents/ 
[TOUCH-EVENTS]
    Touch Events. Doug Schepers; Sangwhan Moon; Matt Brubeck; Arthur Barstow. W3C. 10 October 2013. W3C Recommendation. URL: https://www.w3.org/TR/touch-events/ 
[WEBIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">Pointer Events — Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>



●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/pointerevents2/

編集者草案
	https://w3c.github.io/pointerevents/

テスト一式
	https://wpt.fyi/pointerevents/

最新の勧告
	https://www.w3.org/TR/pointerevents

編集
	Matt Brubeck, Mozilla
	Rick Byers, Google
	Patrick H. Lauke, The Paciello Group

Participate:
	<a href="https://github.com/w3c/pointerevents/">GitHub w3c/pointerevents</a>
	<a href="https://github.com/w3c/pointerevents/issues/">File a bug</a>
	<a href="https://github.com/w3c/pointerevents/commits/gh-pages">Commit history</a> 

Mailing list:
	<a href="https://lists.w3.org/Archives/Public/public-pointer-events/">Mailing list archive.</a>
</script>

</head>

<body>

<header>
	<hgroup>
<h1 id="title">Pointer Events — Level 2</h1>
	</hgroup>
</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">
<h2 title="Abstract">~~要約</h2>

<p>
 W3C 勧告である Pointer Events は、［
~mouse, ~pen, ~touchscreen, 等々を含む装置
］からの［
~hardware非依存の~pointer入力
］を取扱うための~eventと関係する各種~interfaceについて述べている。
この仕様は、その勧告に見出される特色機能を拡張する／改変するものである。
また、既存の，~mouseを~~念頭に書かれた内容との互換性のため、他の型の~pointer装置による~eventから`~mouse~event$の発火-への対応付けについても述べる。
◎
The features in this specification extend or modify those found in Pointer Events, a W3C Recommendation that describes events and related interfaces for handling hardware agnostic pointer input from devices including a mouse, pen, touchscreen, etc. For compatibility with existing mouse based content, this specification also describes a mapping to fire Mouse Events for other pointer device types.
</p>

	</section>
	<section id="sotd">
<h2 title="Status of This Document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
【以下、この節の他の内容は <a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>に委譲。】
</p>

<p>
この仕様は、 `PointerEvents$r に対する更新です。
それは
Microsoft Internet Explorer ／ Microsoft Edge
にのみ，広く出荷されました（他にも， Pointer Events 仕様が W3C 勧告として発行された時点で，独立かつほぼ相互運用可能な実装が Mozilla Firefox の pre-release build にてありましたが）。
この Level 2 では、より幅広い~browserからの受け入れを可能化するため、設計のある側面から浮かび上がった ある種の制限と懸念に取組む，編集上の明確化, 新たな特色機能, 小さな~~非互換な変更を含みます。
◎
This specification is an update to [PointerEvents] which was shipped broadly only by Microsoft Internet Explorer and Microsoft Edge (though a further independent and mostly interoperable implementation was present in a pre-release build of Mozilla Firefox when the Pointer Events specification was published as a W3C Recommendation). Level 2 includes editorial clarifications, new features and minor breaking changes that address certain limitations and concerns that have been raised about aspects of the design, in an effort to enable wider browser adoption.
</p>


<p>
この文書は
<a href="https://www.w3.org/2012/pointerevents/">Pointer Events Working Group</a>
により編集者草案として~~発行されました。
コメントがあれば、
<a href="mailto:public-pointer-events@w3.org">public-pointer-events@w3.org</a>
(
<a href="mailto:public-pointer-events-request@w3.org">subscribe</a>,
<a href="https://lists.w3.org/Archives/Public/public-pointer-events/">archived</a>
)
宛まで送られるよう願います。
◎
This document was published by the Pointer Events Working Group as an Editor's Draft. If you wish to make comments regarding this document, please send them to public-pointer-events@w3.org (subscribe, archives). All comments are welcome. 
</p>

	</section>

<main id="MAIN0">

	<section id="intro">

<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<!-- `PointerEvent!I -->

<p>
今日のほとんどの `HTML5$r 内容は、~mouse入力~向けに利用され／設計されている。
入力を~custom方式で取扱う~codeは、概して `~mouse~event$向けに書かれている。
しかしながら，今日のより新たな~computing機器は、~touchscreen, ~pen入力, 等々も含む，他の形による入力も組入れている。
これらの入力~形の各々に対し，それを取扱うための~event型が個々に提案されてきている。
しかしながら，そのような~approachでは、新たな型の入力~用に~supportが追加される度に，不必要な~logicの重複や, ~eventの取扱いにおける~overheadも招かれ易くなる。
これはまた、内容が ある型の装置のみを念頭に書かれるときにも，互換性の問題を生じさせ易い。
加えて、~mouse用に書かれている既存の内容との互換性のため、ほとんどの`~UA$は，どの型の入力に対しても`~mouse~event$を発火する。
このため、`~mouse~event$が［
実際の~mouse装置を表現している
］のか, ［
別の型の入力~装置から，互換性のために生産されたもの
］なのか，多義的になり、双方の型の装置に対応する~codeを書くのも難しくなっている。
◎
Today, most [HTML5] content is used with and/or designed for mouse input. Those that handle input in a custom manner typically code to [UIEVENTS] Mouse Events. Newer computing devices today, however, incorporate other forms of input, including touchscreens, pen input, etc. Event types have been proposed for handling each of these forms of input individually. However, that approach often incurs unnecessary duplication of logic and event handling overhead when adding support for a new input type. This often creates a compatibility problem when content is written with only one device type in mind. Additionally, for compatibility with existing mouse-based content, most user agents fire Mouse Events for all input types. This makes it ambiguous whether a Mouse Event represents an actual mouse device or is being produced from another input type for compatibility, which makes it hard to code to both device types simultaneously.
</p>

<p>
複数の入力~型に対応する~codeを書く手間を減らすため，および
上に述べた`~mouse~event$の多義性に~~対処し易くするため、この仕様は，`~pointer$と呼ばれる より抽象的な入力~形を定義する。
［
~mouse~cursor, ~pen, ~touch（複touchも含む）, その他
］の~pointing装置により ~screen上に入力される どの接触~点も，~pointerになり得る。
この~modelにより、利用者~側の~hardwareに関わらず，~siteや~appを上手く働くように書くことは、より容易くなる。
装置~特有の取扱いが欲される局面においては、この仕様は，当の~eventを生産した装置の型を検分するための属性も定義する。
◎
To reduce the cost of coding to multiple input types and also to help with the above described ambiguity with Mouse Events, this specifications defines a more abstract form of input, called a pointer. A pointer can be any point of contact on the screen made by a mouse cursor, pen, touch (including multi-touch), or other pointing input device. This model makes it easier to write sites and applications that work well no matter what hardware the user has. For scenarios when device-specific handling is desired, this specification also defines properties for inspecting the device type which produced the event.＼
</p>

<p>
この仕様の第一の目標は、［
装置に依らない~pointer入力に対応する著作は より容易くする
］一方で，［
利用者体験の~~向上に必要とされる所では 装置~特有の取扱いに限り許容する
］ような、一式の［
~event, および~interface
］を供することである。
◎
The primary goal is to provide a single set of events and interfaces that allow for easier authoring for cross-device pointer input while still allowing for device-specific handling only when necessary for an augmented experience.
</p>

<p>
第二の目標は、［
~UAが，~script実行を阻むことなく, 既定の~touch動作（~scrollingなど）を取扱える
］ように，複thread化も可能化することである。
◎
An additional key goal is to enable multi-threaded user agents to handle default touch actions, such as scrolling, without blocking on script execution.
</p>


<p class="note">注記：
この仕様は、種々の~pointer入力~用に 統一された~event~modelを定義する。
~keyboardに類する~UIなど，他の形の入力は、この~modelの~~対象外である（具体例として、~touchscreenのみの装置~上で稼働中の~screenreaderや類似する支援的~技術
— ~focus可能な［
~controlや要素
］を通して 利用者による逐次的な~naviを可能にするような）。
その種の~UIに呼応して~pointer~eventを生成する~UAもあるかもしれないが、それについては，この仕様の~~対象外である。
◎
While this specification defines a unified event model for a variety of pointer inputs, this model does not cover other forms of input such as keyboards or keyboard-like interfaces (for instance, a screenreader or similar assistive technology running on a touchscreen-only device, which allows users sequential navigation through focusable controls and elements). While user agents might choose to also generate pointer events in response to these interfaces, this scenario is not covered in this specification.
</p>

<p class="note">注記：
作者には、まず第一に，どの形の入力に対しても
`focus$et, `blur$et, `click$et
などの高次の~eventで応答することで，等価な機能性を供することが奨励される。
しかしながら、低次の~event（`~pointer~event$など）を利用するときは、すべての型の入力~用の~supportを確保することが奨励される。
~keyboardに類する~UIの事例においては、これには，~keyboard~event用の明示的な取扱いの追加を要することもある。
詳細は、
<a href="http://www.w3.org/TR/WCAG20/#keyboard-operation">WCAG 2.0 指針 2.1</a>
見よ。
◎
In the first instance, authors are encouraged to provide equivalent functionality for all forms of input by responding to high-level events such as focus, blur and click. However, when using low-level events (such as Pointer Events), authors are encouraged to ensure that all types of input are supported. In the case of keyboards and keyboard-like interfaces, this might require the addition of explicit keyboard event handling. See WCAG 2.0 Guideline 2.1 for further details.
</p>


<figure id="figure_martini_glass"><img
	style="width:264px; height:280px;"
	src="pointerevents/pointer.png"
	alt="Pointer input combines input from mouse, pen, touch, etc."
><figcaption>
~pointerは、~screen上の特定の座標（または座標の集合）を標的に捉えられる入力~装置の，~hardware非依存の表現である。
◎
A pointer is a hardware agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen.
</figcaption></figure>

<p>
汎用~pointer入力を取扱うための~eventは、
~mouse用のものとよく似る：
`pointerdown$et,
`pointermove$et,
`pointerup$et,
`pointerover$et,
`pointerout$et,
等々。
これにより、内容を，各種`~mouse~event$から`~pointer~event$へ移行するのも容易になる。
`~pointer~event$は、各種`~mouse~event$に在する通例の属性すべて（
~client座標, 標的~要素, ~button状態, 等々
）を供することに加え、他の形の入力
— 押圧（ `pressure^en ）, `接触~幾何$（ `contact geometry^en ）, 傾き（ `tilt^en ）, 等々 —
のための新たな属性も供する。
作者は、`~pointer~event$の~codeを，異なる【装置】型の入力~間で同じ~logicを共有するように書くことが容易になり、利用者体験の~~向上に必要とされる所のみ，特定0の型の入力を~custom化できる。
◎
The events for handling generic pointer input look a lot like those for mouse: pointerdown, pointermove, pointerup, pointerover, pointerout, etc. This facilitates easy content migration from Mouse Events to Pointer Events. Pointer Events provide all the usual properties present in Mouse Events (client coordinates, target element, button states, etc.) in addition to new properties for other forms of input: pressure, contact geometry, tilt, etc. So authors can easily code to Pointer Events to share logic between different input types where it makes sense, and customize for a particular type of input only where necessary to get the best experience.
</p>

<p>
様々な入力~装置が`~pointer~event$の源になり得るが、`~pointer~event$が，他の［
何らかの装置~特有の~eventの集合（例： 各種 `~mouse~event$, ~touch~event, 等々）
］に属する~eventに伴って生成されるものとして定義されることはない。
この仕様は、他の装置~特有の~eventの~supportは，要求しない。
そうすることも可能であり，互換性のために奨励されるが。
~UAは、他のどの装置~eventも~supportすることなく，~pointer~eventを~supportできる。
［
~mouse特有の~event用に書かれた内容
］との互換性のため、この仕様は，［
~mouse以外の装置による~pointer入力に基づいて，`互換性~mouse~event$を生成する
］ための方法も述べる。
◎
While Pointer Events are sourced from a variety of input devices, they are not defined as being generated from some other set of device-specific events. While possible and encouraged for compatibility, this spec does not require other device-specific events be supported (e.g. mouse events, touch events, etc.). A user agent could support pointer events without supporting any other device events. For compatibility with content written to mouse-specific events, this specification does provide an optional section describing how to generate compatibility mouse events based on pointer input from devices other than a mouse.
</p>

<p class="note informative">
この仕様は、［
`~pointer~event$と
`TOUCH-EVENTS$r に定義される~touch~eventの両者とも~supportする~UA
］に期待される挙動について，何も~~述べない。
これら二つの仕様の関係性についての更なる情報は、
<a href="http://www.w3.org/community/touchevents/">Touch Events Community Group</a>
を見よ。
◎
This specification does not provide any advice on the expected behavior of user agents that support both Touch Events (as defined in [TOUCH-EVENTS]) and Pointer Events. For more information on the relationship between these two specifications, see the Touch Events Community Group.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>

	</section>
	<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~ON, ~OFF, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="examples">
<h2 title="Examples">3. 例</h2>

~INFORMATIVE

<div class="example">

<p>
この仕様に定義される~APIの用例を以下に示す。
◎
The following are example author code that demonstrates how the APIs in this specification might be used.
</p>

<p>例 1 ：
~pointer~event特色機能を検出して，~eventを~bindする：
◎
Example 1: Feature detection and event binding
</p>

<pre id="example_1">
/* <span class="comment">
`~pointer~event$, または［
伝統的 ~touch／~mouse
］のいずれかを~bindする
◎
Bind to either Pointer Events or traditional touch/mouse
</span> */

if (window.PointerEvent) {
    /* <span class="comment">
`~pointer~event$が~supportされる場合は、~pointer~eventのみを~listenする
◎
if Pointer Events are supported, only listen to pointer events
</span> */
    %target.addEventListener("pointerdown", function(%event) {
        /* <span class="comment">
必要とされるなら、 ~touch／~pen／~mouse に対する異なる挙動~用に，
%event`.pointerType^c
に基づいて，別々の~logicを適用する
◎
if necessary, apply separate logic based on e.pointerType for different touch/pen/mouse behavior
</span> */
        ...
    });
    ...
} else {
    /* <span class="comment">
伝統的な ~touch／~mouse ~event~handler
◎
traditional touch/mouse event handlers
</span> */
    %target.addEventListener('touchstart', function(%event) {
        /* <span class="comment">
互換性~mouse~eventと~clickを防止する
◎
prevent compatibility mouse events and click
</span> */
        %event.preventDefault();
        ...
    });
    ...
    %target.addEventListener('mousedown', ...);
    ...
}

/* <span class="comment">
~keyboardを取扱うための，追加の~event~listener
◎
additional event listeners for keyboard handling
</span> */
...
</pre>


<p>例 2：
利用者による入力を検出する例：
◎
Detecting the type of input from a user
</p>

<pre id="example_2">
window.addEventListener("pointerdown", %detectInputType);

function detectInputType(%event) {
    switch(%event.pointerType) {
        case "mouse":
            /* <span class="comment">
~mouse入力が検出された
◎
mouse input detected
</span> */
            break;
        case "pen":
            /* <span class="comment">
~pen／~stylus入力が検出された
◎
pen/stylus input detected
</span> */
            break;
        case "touch":
            /* <span class="comment">
~touch入力が検出された
◎
touch input detected
</span> */
            break;
        case "":
            /* <span class="comment">
空~文字列は、~UAが検出できない装置を意味する
◎
↓</span> */
            break;
        default:
            /* <span class="comment">
~UA特有の~custom型
◎
pointerType is empty (could not be detected) or UA-specific custom type
</span> */
    }
}</pre>



<p>例 3 ：
HTML5 Canvas を利用する基本的な~app：
◎
Basic HTML5 Canvas painting application
</p>

<pre id="example_3">
&lt;style&gt;
  /* <span class="comment">
`~touch用の既定の挙動$（~pan-zoomなど）を不能化して、
`canvas^e 要素~上のすべての~eventを，~appに仕向ける。
◎
Disable intrinsic user agent touch behaviors (such as panning or zooming) so that all events on the canvas element are given to the application instead.
</span> */

  canvas { 
    `touch-action$p: none; 
  }
&lt;/style&gt;

&lt;canvas
    id="drawSurface"
    width="500px" height="500px"
    style="border:1px solid black;"
&gt;&lt;/canvas&gt;

&lt;script&gt;
    var %canvas = document.getElementById("drawSurface"),
    %context = %canvas.getContext("2d");

    if (window.PointerEvent) {
        %canvas.addEventListener("pointermove", paint);
        if(window.navigator.maxTouchPoints &gt; 1) {
    	   /* <span class="comment">
~UAと~hardwareは複touchを~supportする
◎
user agent and hardware support multi-touch
</span> */
        }
    }
    else {
        /* <span class="comment">
`~pointer~event$を~supportしない~UA用の~fallback
◎
provide fallback for user agents that do not support Pointer Events
</span> */
        %canvas.addEventListener("mousemove", paint);
    }

    function paint(%event) {
        if(%event.buttons &gt; 0)
    	   %context.fillRect(%event.clientX, %event.clientY, 5, 5);
    }

    /* <span class="comment">
~keyboardを取扱うための，追加の~event~listener／関数
◎
additional event listeners/functions for keyboard handling
</span> */
    ...

&lt;/script&gt;
</pre>


<p>例 4：
要素~sizeを`接触~幾何$に合わせる例：
◎
Resizing an element to match the contact geometry
</p>

<pre id="example_4">
&lt;div style=
    "position:absolute;
    top:0px; left:0px;
    width:100px; height:100px;"
&gt;&lt;/div&gt;
&lt;script&gt;
window.addEventListener("pointerdown", checkPointerSize);

function checkPointerSize(%event) {
    %event.target.style.width = %event.width + "px";
    %event.target.style.height = %event.height + "px";
}
&lt;/script&gt;
</pre>

<p>例 5：
~scriptから`非trusted$~pointer~eventを発火する例：
◎
Firing an untrusted pointer event from script
</p>

<pre id="example_5">
var %event = new PointerEvent("pointerover", {
    bubbles: true,
    cancelable: true,
    composed: true,
    pointerId: 42,
    pointerType: "pen",
    clientX: 300,
    clientY: 500
});
eventTarget.dispatchEvent(%event); 
</pre>

</div>


	</section>
	<section id="glossary">
<h2 title="Glossary">4. 用語集</h2>

~INFORMATIVE

<dl>
	<dt>~pointerの~buttonが`作動状態@にある</dt>
	<dd>
<p>
`~pointer~event$の `buttons$m 属性が非 0 値をとる条件を満たしている：
</p>

<ul>
	<li>
~mouseに対しては、装置にて何らかの~buttonが押下されているとき。
</li>
	<li>
~touchに対しては、`~digitizer$との物理的~接触があるとき。
</li>
	<li>
~penに対しては、~penによる`~digitizer$との物理的~接触があるとき, または
~hover中にいずれかの~buttonが押下されているとき。
</li>
</ul>
◎
The condition when a pointer has a non-zero value for the buttons property. For mouse, this is when the device has at least one button depressed. For touch, this is when there is physical contact with the digitizer. For pen, this is when either the pen has physical contact with the digitizer, or at least one button is depressed while hovering.
</dd>

	<dt>`作動中の~pointer@, または 単に~pointer†</dt>
	<dd>
<p>
~touch接触, ~pen~stylus, ~mouse~cursor,
その他，~eventを生産し得るような~pointer。
所与の~pointer（ `pointerId$m により一意に識別される）が，文書の中で追加の~eventを生産し得るならば、その~pointerは，依然として作動中と見なされる。
例えば：
◎
Any touch contact, pen stylus, mouse cursor, or other pointer that can produce events. If it is possible for a given pointer (identified by a unique pointerId) to produce additional events within the document, then that pointer is still considered active. Examples:
</p>

		<ul>
			<li>
機器に接続された~mouseは、常に作動中と見なされる。
◎
A mouse connected to the device is always active.
</li>
			<li>
~screen上の~touch接触は、作動中と見なされる。
◎
A touch contact on the screen is considered active.
</li>
			<li>
~touch接触／~pen~stylus
が`~digitizer$の範囲を超えるように持上げられた場合、それは最早~作動中とは見なされない。
◎
If a touch contact or pen stylus is lifted beyond the range of the digitizer, then it is no longer considered active.
</li>
		</ul>

<p class="note">注記：
~platformによっては、`作動中の~pointer$の集合には，~UAを標的にしていない（例： 他の~appを標的にしている）ものも含め，装置へのすべての~pointer入力も含まれる。
◎
On some platforms, the set of active pointers includes all pointer input to the device, including any that are not targeted at the user agent (e.g. those targeted at other applications).
</p>
	</dd>
	<dd class="trans-note">【†
`~pointer~event$を生産する装置を意味する用語として， “`~pointer$” が下に定義されていて，紛らわしいが、~event処理の文脈における，語 “~pointer” は，この`作動中の~pointer$を（暗黙的に）指している
— 定義により，作動中でない~pointer<em>装置</em>からは~eventは生じ得ないので。
すなわち，~pointerは、装置が同じであっても，`作動中の$ 各~期間ごとに別々の~instanceを表現する（原文には明示的にそう記されていないが、そう解釈しなければ，~modelをきちんと定義できなくなる）。
】</dd>

	<dd class="note">
各 `作動中の~pointer$には、少なくとも`~top-level閲覧文脈$ `HTML5$r の視野の中では，同じ識別子（ `pointerId$m ）が付与されるべきである。
しかしながら、複数の`~top-level閲覧文脈$にまたがって そうなる保証は，ない。
◎
Each active pointer should have the same id within the scope of the top-level browsing context (as defined by [HTML5]). However, there is no such guarantee across multiple top-level browsing contexts.
</dd>

	<dt>`取消された@~event （ `canceled event^en ）</dt>
	<dd>
`UIEVENTS$r, `HTML5$r の定義に従って，`既定~動作$が防止された~event
— 
`preventDefault()$m により ／
~event~handlerから ~F が返されたため ／
他の手段により。
◎
An event whose default action was prevented by means of preventDefault(), returning false in an event handler, or other means as defined by [UIEVENTS] and [HTML5].
</dd>

	<dt>`接触~幾何@（ `contact geometry^en ）</dt>
	<dd>
`~digitizer$上で入力された~~地点を囲う矩形域（最も共通的なものは，~touch ）。
これは概して、~pointer入力の分解能が単独の画素より粗い装置を指す
【指先の大きさなど】
。
この~dataを全く報告しない装置もある。
◎
The bounding box of an input (most commonly, touch) on a digitizer. This typically refers to devices with coarser pointer input resolution than a single pixel. Some devices do not report this data at all.
</dd>

	<dt>`~digitizer@ （ `digitizer^en ）</dt>
	<dd>
物理的面に接触-あるいは近接している入力を検出できる型の入力~感知器。
最も共通的なものは、~touch接触や~pen~stylusからの入力を感知する物理的面である。
◎
A type of input sensing device in which a surface can detect input which is in contact and/or in close proximity. Most commonly, this is the surface that senses input from the touch contact or a pen stylus.
</dd>

	<dt>`接触判定@ （ `hit test^en ）</dt>
	<dd>
~UAが `~pointer~event$用の標的~要素を決定する処理-。
これは概して、~pointerの所在, および
~screen媒体~上の文書~内の要素たちの視覚的~layoutを考慮して決定される。
接触判定の仕組みは、この仕様の視野外である。
◎
The process by which a user agent determines a target element for a pointer event. Typically, this is determined by considering the pointer's location and also the visual layout of elements in a document on screen media.
</dd>
	<dd class="trans-note">【
`~pointer捕捉$は，この仕組みを上書きする。
】</dd>

	<dt>`~pointer@ （ `pointer^en ）</dt>
	<dd>
~screen上の特定の座標（または座標の集合）を標的に捉えられる入力~装置
— ~mouse, ~pen, ~touch接触 など —
の，~hardware非依存の表現。

◎
A hardware agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen, such as a mouse, pen, or touch contact.
</dd>
	<dd class="trans-note">【
上に述べたように、この語は，`作動中の~pointer$を意味する場合もある。
】</dd>

	<dt>`~UA@ （ `user agent^en ）</dt>
	<dd>
~browserや内容~著作~toolなど，通常は~client~machine上で稼働中の~programであって、利用者に利するように，内容を［
検索取得- ／ 解釈- ／ 実行- ／ 呈示- ／ 作成-
］するものとして動作するもの。
◎
A program, such as a browser or content authoring tool, normally running on a client machine, which acts on a user's behalf in retrieving, interpreting, executing, presenting, or creating content.
</dd>

	<dt>`~taskを~queueする@ （ `queue a task^en ）`HTML5$r</dt>
	<dd>
【この用語は利用されていないので、和訳は省略する。】
◎
Adding the task to events task queue of the relevant event loop, as defined in [HTML5].
</dd>

</dl>

<p>【以下の用語は、この訳による補完, もしくは明示的な定義／集約。】</p>

<dl>
	<dt>`~event連列@</dt>
	<dd>
`作動中の~pointer$から所定の順序で`同期的$に生じる一連の~event。
</dd>

	<dt>`~mouse~event@ （ `Mouse Events^en ）</dt>
	<dd>
`UIEVENTS$r にて定義される各種~mouse~eventのうち，
`click$et, `dblclick$et
を除くものの総称（
`mouseXXX^et ~event
— 概ね、
`MouseEvent$I ~interfaceを実装しつつ，
`PointerEvent$I など，拡張された~interfaceは実装しない~event）。
</dd>

	<dt>`~pointer~event@ （ `Pointer Events^en ）</dt>
	<dd>
この仕様にて定義される各種~pointer~eventの総称（言い換えれば、
`PointerEvent$I ~interfaceを実装する~event）。
</dd>

	<dt>`~pointing先@ （ `pointing^en 先 ）</dt>
	<dd>
`作動中の~pointer$に対し，`接触判定$により決定される要素。
</dd>

	<dt>`捕捉~込みの~pointing先@</dt>
	<dd>
~pointerを捕捉している要素がある場合、~event配送の目的において`~pointing先$とされ得るものは，要素または その子孫に拘束されることもある。
すなわち，ある要素が`作動中の~pointer$を`捕捉$している（すなわち，要素は その~pointerの`処理待ち捕捉標的$である）, かつ
`~pointing先$は［
要素でも その子孫でもない
］ならば 要素~自身 ／
他の場合は`~pointing先$。
</dd>

	<dt>~touch （ `touch^en ）</dt>
	<dd>
~penなどの装置を介さない、人の手指による入力。
</dd>

	<dt>接触（ `contact^en ）</dt>
	<dd>
`~digitizer$が検出できる程に，物理的に接触-／近接している状態を意味する。
<!-- 
touch と contact の概念的な違いは、前者には，何らかの~~操作が含意される点にある
-->
</dd>

	<dt>`~touch用の既定の挙動@</dt>
	<dd>
~UAにより定義される，~touch入力~用の既定の挙動（表示域の~pan-zoomなど）。
</dd>

	<dt>`~mouse~event防止~flag@ （ `PREVENT MOUSE EVENT flag^en ）</dt>
	<dd>
初期時は~OFF。
この~flagは、~pointer装置の各~型に結び付けられる。
~ON にされたときは、その型の~pointer装置からは`互換性~mouse~event$は，生成されなくなる。
</dd>
</dl>

<p>
各 `作動中の~pointer$には、次のものが結付けられる：
</p>

<dl>
	<dt>`捕捉標的@ （ `pointer capture target override^en ）</dt>
	<dt>`処理待ち捕捉標的@ （ `pending pointer capture target override^en ）</dt>
	<dd>
要素, または ~NULL（初期値）。
これらは，`~pointer捕捉$の制御に利用され、当の~pointerにより生じる~eventの標的を上書きする。
</dd>

</dl>


	</section>
	<section id="pointer-events-and-interfaces">
<h2 title="Pointer Events and Interfaces">5. 各種~pointer~eventと各種~interface</h2>
		<section id="pointerevent-interface">
<h3 title="PointerEvent Interface">5.1 `PointerEvent^I ~interface</h3>


<pre class="idl">
dictionary `PointerEventInit@I : `MouseEventInit$I {
    long      `pointerId@m = 0;
    double    `width@m = 1;
    double    `height@m = 1;
    float     `pressure@m = 0;
    float     `tangentialPressure@m = 0;
    long      `tiltX@m = 0;
    long      `tiltY@m = 0;
    long      `twist@m = 0;
    DOMString `pointerType@m = "";
    boolean   `isPrimary@m = false;
};

[Constructor(DOMString type, optional `PointerEventInit$I %eventInitDict),
 `Exposed$=Window]
interface `PointerEvent@I : `MouseEvent$I {
    readonly attribute long      `pointerId$m;
    readonly attribute double    `width$m;
    readonly attribute double    `height$m;
    readonly attribute float     `pressure$m;
    readonly attribute float     `tangentialPressure$m;
    readonly attribute long      `tiltX$m;
    readonly attribute long      `tiltY$m;
    readonly attribute long      `twist$m;
    readonly attribute DOMString `pointerType$m;
    readonly attribute boolean   `isPrimary$m;
};
</pre>


<dl class="idl-def">
	<dt>`pointerId@m</dt>
	<dd>
~eventを生じさせた~pointerを一意に識別する識別子。
この識別子は、その時点で，`~top-level閲覧文脈$ `HTML5$r において`作動中の~pointer$すべての中で一意で~MUST。
~UAは、必要に応じて，以前に`作動中$であった~pointerによる使われなくなった値を `pointerId$m 値に~~再利用して~MAY。
◎
A unique identifier for the pointer causing the event. This identifier MUST be unique from all other active pointers in the top-level browsing context (as defined by [HTML5]) at the time. A user agent MAY recycle previously retired values for pointerId from previous active pointers, if necessary.
</dd>

<dd class="note">注記：
`pointerId$m の選定~algoは、実装~特有である。
したがって作者は、この値を，上の意味で一意であること以外の意味を持つものとは見做せない。
例として、値が単調増加することは保証されない。
◎
The pointerId selection algorithm is implementation specific. Therefore authors cannot assume values convey any particular meaning other than an identifier for the pointer that is unique from all other active pointers. As an example, values are not guaranteed to be monotonically increasing.
</dd>


	<dt>`width@m</dt>
	<dt>`height@m</dt>
	<dd>
順に、~pointerの`接触~幾何$の横幅, 縦幅（ X, Y 軸~上の大きさ）を表す。
その~~単位は~CSS~pixel（ `CSS21$r ）による。
この値は、所与の~pointer用の各~eventごとに更新されても~MAY。
［
概して`接触~幾何$を欠く入力（伝統的な~mouseなど） ／
実際の幾何が~hardwareにより検出されない入力
］に対しては、~UAは，既定の値として 1 を返さ~MUST。
◎
The width (magnitude on the X axis), in CSS pixels (see [CSS21]), of the contact geometry of the pointer. This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the user agent MUST return a default value of 1.
◎
The height (magnitude on the Y axis), in CSS pixels (see [CSS21]), of the contact geometry of the pointer. This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the user agent MUST return a default value of 1.
</dd>

	<dt>`pressure@m</dt>
	<dd>
<p>
~pointer入力による，範囲 0 〜 1 に正規化された押圧
—
値［
0 ／ 1
］は、~hardwareが検出できる［
最小／最大
］の押圧を表現する。
押圧を~supportしない~hardware用の値は、［
~buttonが`作動状態$にあるなら 0.5 ／
~ELSE_ 0
］にされ~MUST。
</p>
<p>
`pointerup$et ~eventに対しては、 `pressure$m は常に 0 にされることに注意。
</p>
◎
The normalized pressure of the pointer input in the range of [0,1], where 0 and 1 represent the minimum and maximum pressure the hardware is capable of detecting, respectively. For hardware that does not support pressure, the value MUST be 0.5 when in the active buttons state and 0 otherwise. Note: all pointerup events will have pressure 0.
</dd>

	<dt>`tangentialPressure@m</dt>
	<dd>
範囲 −1 〜 1 に正規化された，~pointer入力の接線方向~圧†（ ~barrel圧としても周知）。
概して，追加の制御により設定される（例： ~airbrush~stylus上の手指~wheelなど）。
値 0 は、中立の位置を指す。
~hardwareによっては，範囲 0 〜 1 による正の値しか~supportしないものもあることに注意。
接線方向~圧を~supportしない~hardware用の値は、 0 にされ~MUST。
◎
The normalized tangential pressure (also known as barrel pressure), typically set by an additional control (e.g. a finger wheel on an airbrush stylus), of the pointer input in the range of [-1,1], where 0 is the neutral position of the control. Note that some hardware may only support positive values in the range of [0,1]. For hardware that does not support tangential pressure, the value MUST be 0.
</dd>
	<dd class="trans-note">【†
接線方向~圧（ `tangential pressure^en ） —
おそらく，~stylus等のひねるときの力。
~barrel（“樽”）の周に沿う，接線~方向。
】</dd>

	<dt>`tiltX@m</dt>
	<dd>
<p>
`~digitizer$の Y-Z 平面と, ［
~transducer（例：~pen~stylus）軸と Y 軸を包含する平面
］がなす角度。
値の範囲は −90° 〜 90° 。
正の `tiltX$m は、~transducer軸が右側に傾いていることを表す。
絶対~値が大きいほど，~transducer軸が~digitizer面の法線から離れていることを表す。
</p>

<p>
傾きを報告しない装置~用の値は、 0 で~MUST。
</p>

◎
The plane angle (in degrees, in the range of [-90,90]) between the Y-Z plane and the plane containing both the transducer (e.g. pen stylus) axis and the Y axis. A positive tiltX is to the right. tiltX can be used along with tiltY to represent the tilt away from the normal of a transducer with the digitizer. For devices that do not report tilt, the value MUST be 0.
</dd>
	<dd class="trans-note">【
標的~要素に対する変形（回転など）が X, Y 軸の解釈に影響し得るのか,
どう影響するのかについては、この仕様には述べられていない。
】</dd>

	<dd><figure id="figure_tiltX"><img
	style="width:600px; height:360px;"
	src="pointerevents/tiltX_600px.png"
	alt="tiltX explanation diagram"
><figcaption>
正の `tiltX$m 。
◎
Positive tiltX.
</figcaption></figure>
</dd>

	<dt>`tiltY@m</dt>
	<dd>
<p>
X-Z 平面と, ［
~transducer（例：~pen~stylus）軸と X 軸を包含する平面
］がなす角度（ −90° 〜 90° の範囲）。
正の `tiltY$m は、~transducer軸が利用者~側に傾いている†ことを表す。
絶対~値が大きいほど，~transducer軸が~digitizer面の法線から離れていることを表す。
</p>

<p>
傾きを報告しない装置~用の値は、 0 で~MUST。
</p>

◎
The plane angle (in degrees, in the range of [-90,90]) between the X-Z plane and the plane containing both the transducer (e.g. pen stylus) axis and the X axis. A positive tiltY is towards the user. tiltY can be used along with tiltX to represent the tilt away from the normal of a transducer with the digitizer. For devices that do not report tilt, the value MUST be 0.
</dd>
	<dd class="trans-note">【†
図が紛らわしいが、下の図の Y 軸の反対~方向。
GUI の文脈にて通例的な Y 軸の向き（ ~screenの下方向が正の向き）においては、正~方向。
】</dd>

	<dd><figure id="figure_tiltY"><img
	style="width:600px; height:450px;"
	src="pointerevents/tiltY_600px.png"
	alt="tiltY explanation diagram"
><figcaption>
負の `tiltY$m 。
◎
Negative tiltY.
</figcaption></figure></dd>

	<dt>`twist@m</dt>
	<dd>
~transducer（例： ~pen~stylus）自身の~~主~軸~周りにおける
— 時計回り，［
0° 〜 359°
］の範囲による —
回転~角度。
~twist【ひねり？】を報告しない装置に対しては、値 0 を返さ~MUST。
◎
The clockwise rotation (in degrees, in the range of [0,359]) of a transducer (e.g. pen stylus) around its own major axis. For devices that do not report twist, the value MUST be 0.
</dd>

	<dt>`pointerType@m</dt>
	<dd>
<p>
~eventを生じさせた装置の型（
~mouse,
~pen,
~touch,
等々）を指示する。
［
~mouse ／
~pen~stylus ／
~touch入力~装置
］に対し`~pointer~eventを発火-$する~UAは、
その `pointerType$m の値を次の表に則って~~初期化し~MUST：
◎
Indicates the device type that caused the event (mouse, pen, touch, etc.). If a user agent is to fire a pointer event for a mouse, pen stylus, or touch input device, then the value of pointerType MUST be according to the following table:
</p>

<table>
<thead><tr><th>~pointer装置の型◎ Pointer Device Type
<th>`pointerType$m 値◎ pointerType Value
</thead>

<tbody><tr><td>~mouse◎ Mouse
<td>`mouse^l

<tr><td>~pen~stylus◎ Pen Stylus
<td>`pen^l

<tr><td>~touch接触◎ Touch Contact
<td>`touch^l

</tbody></table>

</dd>
	<dd>
~UAが検出できない型の装置~用の値は、空~文字列にされ~MUST。
上に挙げたもの以外の，~UAが~supportする型の~pointer装置~用の `pointerType$m 値は、異なる型の装置~間で名前が競合しないように，~vendor接頭辞が~~付与される~SHOULDである。
将来の仕様は、他の型の装置~用に規範的な値を追加し得る。
◎
If the device type cannot be detected by the user agent, then the value MUST be an empty string. If a user agent supports pointer device types other than those listed above, the value of pointerType SHOULD be vendor prefixed to avoid conflicting names for different types of devices. Future specifications MAY provide additional normative values for other device types.
</dd>
	<dd class="note">注記：
<a href="#example_2">例 2</a>
に、 `pointerType$m の基本的な用例がある。
開発者は、何らかの形で既定の取扱いを含めるべきであることに注意
— 自前の~custom `pointerType$m 値を実装している~UAや,
`pointerType$m が単に空~文字列である状況0に対応するために。
◎
See Example 2 for a basic demonstration of how the pointerType can be used. Also note that developers should include some form of default handling to cover user agents that may have implemented their own custom pointerType values and for situations where pointerType is simply an empty string.
</dd>

	<dd class="trans-note">【
この仕様では、同じ型の装置が複数~存在する状況は想定されていない
— 特に，`~mouse~event防止~flag$の扱いに関して（~mouseについては、
<a href="#multiple-mouse-inputs">一つの装置に統合される</a>
ものとみなされている）。
】</dd>

	<dt>`isPrimary@m</dt>
	<dd>
~pointerがこの~pointer型の`首~pointer$を表現するかどうかを指示する。
◎
Indicates if the pointer represents the primary pointer of this pointer type.
</dd>
</dl>


<p>
`PointerEventInit$I 辞書は、 `PointerEvent$I ~interfaceの構築子に，`非trusted$（合成の）`~pointer~event$を構築する仕組みを供する。
それは `UIEVENTS$r にて定義される `MouseEventInit$I 辞書を継承する。
~eventを構築する手続きは、 `DOM4$r にて定義される。
<a href="#example_5">例 5</a>
に、`非trusted$ `~pointer~eventを発火-$する用例がある。
◎
The PointerEventInit dictionary is used by the PointerEvent interface's constructor to provide a mechanism by which to construct untrusted (synthetic) pointer events. It inherits from the MouseEventInit dictionary defined in [UIEVENTS]. The steps for constructing an event are defined in [DOM4]. See the examples for sample code demonstrating how to fire an untrusted pointer event.
</p>


<p class="note">注記：
`PointerEvent$I ~interfaceは、 `MouseEvent$I `UIEVENTS$r を継承し， `CSSOM-VIEW$r により拡張される。
◎
The PointerEvent interface inherits from MouseEvent, defined in [UIEVENTS] and extended by [CSSOM-VIEW].
</p>

		<section id="button-states">
<h4 title="Button States">5.1.1. ~button状態</h4>
			<section id="chorded-button-interactions">
<h5 title="Chorded Button Interactions">5.1.1.1. ~buttonの追加押下げ操作i</h5>

<p>
~mouseや~penなどの一部の~pointer装置は、複数の~buttonを~supportする。
`~mouse~event$~model `UIEVENTS$r においては、どの~buttonが押されたときも，
`mousedown$et, `mouseup$et
~eventが生産される。
この~hardware相違点を より良く抽象化して，入力に対する装置に依らない著作を単純化するため、`~pointer~event$においては、
`~buttonの追加押下げ@
— ~pointer装置~上の別の~buttonがすでに押下されている間に
追加の~buttonを押下すること —
に対しては、
`pointerdown$et, `pointerup$et
~eventが重ねて発火されることはない†。
◎
Some pointer devices, such as mouse or pen, support multiple buttons. In the [UIEVENTS] Mouse Event model, each button press produces a mousedown and mouseup event. To better abstract this hardware difference and simplify cross-device input authoring, Pointer Events do not fire overlapping pointerdown and pointerup events for chorded button presses (depressing an additional button while another button on the pointer device is already depressed).
</p>

<p class="trans-note">【†
~button A, B をこの順に押して，同じ順に離した場合、
`pointerup$et は，最後に B を離したときに呼応して発火される？
それとも A を離したときに発火される？
】</p>

<p>
~buttonの追加押下げは、［
`button$m, `buttons$m
］属性の変化を検分すれば検出できる†。
これらの属性は
`MouseEvent$I ~interface `UIEVENTS$r
から継承されるが、意味論と値には，次~節~以下に要旨する変更が加えられている。
◎
Instead, chorded button presses can be detected by inspecting changes to the button and buttons properties. The button and buttons properties are inherited from the [UIEVENTS] MouseEvent interface, but with a change in semantics and values, as outlined in the following sections.
</p>

<p class="trans-note">【†
追加押下げに対しては、少なくとも，何らかの（ `pointerdown$et, `pointerup$et 以外の）~pointer~eventが発火される。
`pointermove$et を見よ。
】</p>


<p class="note">注記：
［
`button^m ／ `buttons^m
］属性に対する改変が適用されるのは、~pointer~eventに限られる。
`互換性~mouse~event$に対する［
`button^m ／ `buttons^m
］の値は `UIEVENTS$r に従うべきである。
◎
The modifications to the button and buttons properties apply only to pointer events. For any compatibility mouse events the value of button and buttons should follow [UIEVENTS].
</p>

			</section>
			<section id="the-button-property">
<h5 title="The button property">5.1.1.2. `button^m 属性</h5>


<p>
~pointer~eventにおける~button状態の（単なる `pointerdown$et, `pointerup$et 以上の）遷移を識別できるようにするため、 `button$m 属性は，状態~変化により~eventを発火させた装置~buttonを指示する。
◎
To identify button state transitions in any pointer event (and not just pointerdown and pointerup), the button property indicates the device button whose state-change fired the event.
</p>


<table>
<thead><tr><th>装置の~button状態◎ Device Button State
<th>`button^m
</thead>

<tbody><tr><td>
前回の~eventから，どの~buttonも, どの~touch／~pen接触も変化していない
◎
Neither buttons nor touch/pen contact changed since last event
<td>−1

<tr><td>
~mouseの左~buttonが押されている ／
~touch接触がある ／
~pen接触がある
◎
Left Mouse,
Touch Contact,
Pen contact
<td>0

<tr><td>
~mouseの中央~buttonが押されている
◎
Middle Mouse
<td>1

<tr><td>
~mouseの右~buttonが押されている ／
~penの~barrel~buttonが押されている
◎
Right Mouse,
Pen barrel button
<td>2

<tr><td>
~mouseの x1（ `back^en ）~buttonが押されている
◎
X1 (back) Mouse
<td>3

<tr><td>
~mouseの x2（ `forward^en ）~buttonが押されている
◎
X2 (forward) Mouse
<td>4

<tr><td>
~penの~eraser~buttonが押されている
◎
Pen eraser button
<td>5

</tbody></table>


<p class="note">注記：
~mouse~dragの間、 `pointermove$et ~eventにおける `button^m 属性の値は，
`mousemove$et ~eventから異なることになる。
例えば，右~buttonを押しながら~mouseを動かしている間、
`pointermove$et ~eventの `button^m 値は −1 になる一方で，
`mousemove$et ~eventの `button^m 値は 2 になる。
◎
During a mouse drag, the value of the button property in a pointermove event will be different from that in a mousemove event. For example, while moving the mouse with the right button pressed, the pointermove events will have the button value -1, but the mousemove events will have the button value 2.
</p>


			</section>
			<section id="the-buttons-property">
<h5 title="The buttons property">5.1.1.3. `buttons^m 属性</h5>

<p>
`buttons$m 属性は、装置の個々の~buttonの現在の状態を~bitmaskとして与える（ `MouseEvent$I におけるそれと同じだが、とり得る値は拡張0されている）。
◎
The buttons property gives the current state of the device buttons as a bitmask (same as in MouseEvent, but with an expanded set of possible values).
</p>


<table>
<thead><tr><th>装置の現在の~button状態◎ Current state of device buttons
<th>`buttons^m
</thead>

<tbody><tr><td>
［
~mouse ／
~hoverしている~pen
］は どの~buttonも押されずに動いている
◎
Mouse moved with no buttons pressed,
Pen moved while hovering with no buttons pressed
<td>0

<tr><td>
~mouseの左~buttonが押されている ／
~touch接触がある ／
~pen接触がある
◎
Left Mouse,
Touch Contact,
Pen contact
<td>1

<tr><td>
~mouseの中央~buttonが押されている
◎
Middle Mouse
<td>4

<tr><td>
［
~mouseの右~button ／
~penの~barrel~button
］が押されている
◎
Right Mouse,
Pen barrel button
<td>2

<tr><td>
~mouseの x1（ `back^en ）~buttonが押されている
◎
X1 (back) Mouse
<td>8

<tr><td>
~mouseの x2（ `forward^en ）~buttonが押されている
◎
X2 (forward) Mouse
<td>16

<tr><td>
~penの~eraser~buttonが押されている
◎
Pen eraser button
<td>32

</tbody></table>


			</section>
		</section>
		<section id="the-primary-pointer">
<h4 title="The Primary Pointer">5.1.2. 首~pointer</h4>

<p>
複pointer装置（例：複touch）
【複数の装置ではなく，複数の同時的~接触を~supportする~pointer装置】
に対しては、
`isPrimary$m 属性が，`首~pointer$を識別するために利用される。
`首~pointer@
とは、各~pointer【装置】型に対する`作動中の~pointer$の集合の中で，主導的とされる~pointerである：
◎
In a multi-pointer (e.g. multi-touch) scenario, the isPrimary property is used to identify a master pointer amongst the set of active pointers for each pointer type.
</p>

<ul>
	<li>
どの時点であれ、`首~pointer$は，各~pointer型に対し高々一つまでとする。
◎
At any given time, there can only ever be at most one primary pointer for each pointer type.
</li>
	<li>
特定0の~pointer型に対し最初に作動中になる~pointer（例えば 複touchによる操作iなら，手指による~screenへの最初の~touch）が、その~pointer型の`首~pointer$になる。
◎
The first pointer to become active for a particular pointer type (e.g. the first finger to touch the screen in a multi-touch interaction) becomes the primary pointer for that pointer type.
</li>
	<li>
`首~pointer$のみが`互換性~mouse~event$を生産することになる。
`首~pointer$が複数ある事例では、それぞれの~pointerが，`互換性~mouse~event$を生産することになる。
◎
Only a primary pointer will produce compatibility mouse events. In the case where there are multiple primary pointers, these pointers will all produce compatibility mouse events.
</li>
</ul>

<p class="note">注記：
作者は、欲するなら，非 首~pointerを無視することで 非 複pointerによる操作iを得られる（しかしながら，下の
<a href="#multiple-primary-pointers">複数の首~pointer</a>
についての注記を見よ）。
◎
Authors who desire single-pointer interaction can achieve this by ignoring non-primary pointers (however, see the note below on multiple primary pointers).
</p>

<p class="note" id="multiple-primary-pointers">注記：
複数の型の~pointer装置が同時的に利用されている場合、それぞれの~pointer（各 `pointerType$m ごとに一つ）が首と見なされる。
例えば、同時に動いた ~touch接触と~mouse~cursorは，両者とも首と見なされる~pointerを生産することになる。
◎
When two or more pointer device types are being used concurrently, multiple pointers (one for each pointerType) are considered primary. For example, a touch contact and a mouse cursor moved simultaneously will produce pointers that are both considered primary.
</p>


<p class="note">注記：
~OSや~UAは、一部の装置に対し
— 不意の対話を避けるため —
複数の型の~pointer入力の同時的な利用を無視することもある。
具体例として，~touch, ~pen両者による対話を~supportする装置は、~penが利用-中にある間は
— 利用者が~touchscreen上で手を休めれるよう —
~touch入力を無視することもある（この特色機能は “`palm rejection^en” 
【 “手のひらが触れても~~無視する” 】
と共通的に称されている）。
現時点では、作者がこの挙動を抑止することは可能でない。
◎
Some devices, operating systems and user agents may ignore the concurrent use of more than one type of pointer input to avoid accidental interactions. For instance, devices that support both touch and pen interactions may ignore touch inputs while the pen is actively being used, to allow users to rest their hand on the touchscreen while using the pen (a feature commonly referred to as "palm rejection"). Currently, it is not possible for authors to suppress this behavior.
</p>

<p class="note">注記：
~UAが、どの~pointerも`首~pointer$とされていない下で，~pointer~eventを発火する場合もあり得る。
具体例として、複touchの様な特定0の型の 作動中の~pointerが複数あって，首~pointerが除去された場合（~screenから離されたなど）、首~pointer~eventは生じない。
また、［
`首~pointer$が，（~UAを標的にしていないものも含め）装置~上で`作動中の$すべての~pointerを利用して決定される
］ような~platformにおいては、［
最初の~touch操作iは ~UAの外側を標的にしていて，（複touchによる） 2 度目の~touch操作iは ~UAの内側を標的にしている
］場合、~UAは， 2 度目の接触に対し、
`isPrimary$m が ~F にされた`~pointer~eventを発火-$し得る。
◎
In some cases, it is possible for the user agent to fire pointer events in which no pointer is marked as a primary pointer. For instance, when there are multiple active pointers of a particular type like multi-touch and the primary pointer is removed (e.g. it leaves the screen), there will be no primary pointer events. Also on the platforms where the primary pointer is determined using all active pointers on the device (including those targeted at an application other than the user agent), if the first touch interaction is targeted outside the user agent and a secondary (multi-touch) touch interaction is targeted inside the user agent, then the user agent may fire pointer events for the second contact with a value of false for isPrimary.
</p>

<p class="note" id="multiple-mouse-inputs">注記：
現在の~OSや~UAは、通例的に複数の~mouseによる入力の概念を備えていない。
複数の~mouse装置が在する場合（具体例として、~trackpadと外部~mouseを備える~laptopなど）、一般に，それら一まとめに単独の装置に扱われる
— どの装置による移動も，単独の~mouse~pointerの移動に翻訳され、異なる~mouse装置で押される~buttonは~~区別されない。
この理由から、~mouse~pointerは，通例的に一つだけあって，その~pointerが首になることになる。
<span class="trans-note">【
したがって、 2 つの~mouseがあって，それぞれの左~buttonが順に押されてから, 順に離されたとき， 2 番目に押されたときと, 最初に離されたときは，無視されることになるであろう。
】【
他の型について同じ型の~pointer装置が複数ある場合については，この仕様には言及されていない。
<!-- が、同様になるのか？そのような状況は生じ得ないのか？ -->
】</span>

◎
Current operating systems and user agents don't usually have a concept of multiple mouse inputs. When more than one mouse device is present (for instance, on a laptop with both a trackpad and an external mouse), all mouse devices are generally treated as a single device - movements on any of the devices are translated to movement of a single mouse pointer, and there is no distinction between button presses on different mouse devices. For this reason, there will usually only be a single mouse pointer, and that pointer will be primary.
</p>

			</section>
			<section id="firing-events-using-the-pointerevent-interface">
<h4 title="Firing events using the PointerEvent interface">5.1.3. `PointerEvent^I ~interfaceを利用する~eventの発火</h4>

<p class="algo-head">
名前 %e の
`~pointer~eventを発火-@
するときは、次を走らす：
◎
To fire a pointer event named e means to fire an event named e as defined in [DOM4] with an event using the PointerEvent interface whose attributes are set as defined in PointerEvent Interface and Attributes and Default Actions.
</p>

<ol>
	<li>
%~event ~LET `PointerEvent$I ~interfaceを利用する新たな~event：
</li>
	<li>
%~event の各種~属性を［
`PointerEvent$I ~interface, および
<a href="#attributes-and-default-actions">各種 属性と既定~動作 節</a>
］の定義に従って設定する
◎
↑</li>
	<li>
~IF［
%e ~NIN { `gotpointercapture$et, `lostpointercapture$et }
］
⇒
%~event に対し，`処理待ち~pointer捕捉を処理-$する手続きを走らす
◎
If the event is not gotpointercapture or lostpointercapture, run Process Pending Pointer Capture steps for this PointerEvent.
</li>
	<li>
%~pointer ~LET この %~event を生じさせた`作動中の~pointer$
◎
↓</li>
	<li>
%標的 ~LET ［
%~pointer の`捕捉標的$ ~NEQ ~NULL ならば それ ／
~ELSE_ 通常の`~pointing先$
］
◎
The target object at which the event is fired is determined as follows:
◎
• If the pointer capture target override has been set for the pointer, set the target to pointer capture target override object.
◎
• Otherwise, set the target to the object returned by normal hit test mechanisms (out of scope for this specification).
</li>
	<li>
~IF［
%e ~EQ `pointerdown^et
］~AND［
%~pointer を動かしている装置は、
<a href="#implicit-pointer-capture">直接~操作~装置</a>
である
］~AND［
%標的 は `Element^I である
］
⇒
`暗黙的な~pointer捕捉$に従って
⇒
%~pointer の `pointerId$m を渡して，~pointer捕捉を %標的 に`設定-$する
◎
If this is a pointerdown event, the associated device is a direct manipulation device and the target is an Element, then set pointer capture for this pointerId to the target element as described in implicit pointer capture.
</li>
	<li>
`DOM4$r による定義に従って
⇒
%標的 に向けて %~event を`発火する$
◎
Fire the event to the determined target.
</li>
</ol>

<p class="note">注記：
通常の`~pointing先$に代えて`捕捉標的$を利用することは、何らかの境界~event†を発火する結果になり得る。
【要素~境界をまたいだときに生じるような~event — すなわち， `pointerenter$et など。】
これは、~pointerが その前の標的から出て【 pointerleave 】
，この新たな捕捉している標的に入った【 pointerenter 】
場合と同じになる。
それらの標的が互いに異なる場合、境界~eventが先ず配送されるべきである。
捕捉が解放されたときにも，~pointerを捕捉している標的から出て 接触判定による標的に入るに伴い，同じことが起こり得る。
◎
Using the pointer capture target override as the target instead of the normal hit-test result may fire some boundary events. This is the same as the pointer leaving its previous target and entering this new capturing target and if they are different targets boundary events should be dispatched first. When the capture is released the same scenario may happen as the pointer is leaving the capturing target and entering the hit-test target.
</p>
				<section id="attributes-and-default-actions">
<h5 title="Attributes and Default Actions">5.1.3.1 各種 属性と既定~動作</h5>

<p>
この仕様にて定義される各種~event型に対する
`bubbles$m, `cancelable$m ~prop
および 既定~動作を，次の表に示す。
これらの各~event型の詳細は、
<a href="#pointer-event-types">各種 ~pointer~event型 節</a>
にて供される：
◎
The bubbles and cancelable properties and the default actions for the event types defined in this specification appear in the following table. Details of each of these event types are provided in Pointer Event types.
</p>

<table id="pointer-event-type-table">
<thead><tr><th>~event型◎ Event Type
<th>`浮上-$？◎ Bubbles
<th>`取消~可$？◎ Cancelable
<th>`既定~動作$◎ Default Action
</thead>

<!-- 
<th>Event Type<th>Bubbles<th>Cancelable<th>Default Action
 -->
<tbody>
<tr><td>`pointerover$et
<td>する
<td>可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseover

<tr><td>`pointerenter$et
<td>しない
<td>不可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseenter

<tr><td>`pointerdown$et
<td>する
<td>可 (2)
<td>`mousedown$et と同じ (1)
◎
Varies: when the pointer is primary, all default actions of the mousedown event Canceling this event also sets the PREVENT MOUSE EVENT flag for this pointerType, which prevents subsequent firing of certain compatibility mouse events.

<tr><td>`pointermove$et
<td>する
<td>可
<td>`mousemove$et と同じ (1)
◎
Varies: when the pointer is primary, all default actions of mousemove

<tr><td>`pointerup$et
<td>する
<td>可
<td>`mouseup$et と同じ (1)
◎
Varies: when the pointer is primary, all default actions of mouseup

<tr><td>`pointercancel$et
<td>する
<td>不可
<td>なし

<tr><td>`pointerout$et
<td>する
<td>可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseout

<tr><td>`pointerleave$et
<td>しない
<td>不可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseleave

<tr><td>`gotpointercapture$et
<td>する
<td>不可
<td>なし

<tr><td>`lostpointercapture$et
<td>する
<td>不可
<td>なし

</tbody></table>

<p>
上の表における (1), (2) は：
</p>
<ul>
	<li>(1)
`既定~動作$が生じるのは、`首~pointer$に対してのみであり，対応する`~mouse~event$に対するとき同様に文脈に依存する
— 文脈に応じて適切な既定~動作が行われることになる。
</li>
	<li>(2)
`pointerdown$et を取消した場合、この~eventの `pointerType$m に対する後続の`互換性~mouse~event$（のうち一部）の発火も防止される（`~mouse~event防止~flag$は ~ON にされる）。
</li>
</ul>

<p>
上の表に挙げたどの`~pointer~event$に対しても，その
`composed$m 属性 `DOM4$r は ~T にされ,
`detail$m 属性 `UIEVENTS$r は 0 にされるべきである。
◎
For all pointer events in the table above, composed ([DOM4]) attribute SHOULD be true and detail [UIEVENTS] attribute SHOULD be 0.
</p>

<p class="note">注記：
多くの~UAは、旧来の内容を~supportするため，
`MouseEvent$I 内に標準でない属性［
`fromElement^m, `toElement^m
］を公開している。
標準~化された代替（すなわち， `target^m, `relatedTarget^m ）の利用を奨励するため、そのような~UAであっても， `PointerEvent$I 内の（継承された）それらの属性は ~NULL を返さ~MUST。
◎
Many user agents expose non-standard attributes fromElement and toElement in MouseEvents to support legacy content. In those user agents, the values of those (inherited) attributes in PointerEvents must be null to encourage the use of the standardized alternates (i.e. target and relatedTarget).
</p>

<p>
MouseEvents `UIEVENTS$r 同様，
`relatedTarget$m は、［
`pointerover$et ／ `pointerenter$et
］~eventに対しては 直前の`捕捉~込みの~pointing先$, ［
`pointerout$et ／ `pointerleave$et
］~eventに対しては 新たな`捕捉~込みの~pointing先$
に初期化されるべきである。
他の~pointer~eventに対しては、この値は既定で~NULLになる。
◎
Similar to the MouseEvents [UIEVENTS] the relatedTarget should be initialized to the element whose bounds the pointer just left (in the case of a pointerover or pointerenter event) or the element whose bounds the pointer is entering (in the case of a pointerout or pointerleave). For other pointer events, this value will default to null. Note that when an element receives the pointer capture all the following events for that pointer are considered to be inside the boundary of the capturing element.
</p>

<p>
［
`gotpointercapture$et ／ `lostpointercapture$et
］~eventに対しては、上の表に定義されるものを除くすべての属性は、［
~UAに`処理待ち~pointer捕捉を処理-$させ, その~event発火させた`~pointer~event$
］のそれらと同じにされるべきである。
◎
For gotpointercapture and lostpointercapture all the attributes except the ones defined in the table above should be the same as the Pointer Event that caused the user agent to run Process Pending Pointer Capture and fire the gotpointercapture and lostpointercapture events.
</p>

				</section>
				<section id="process-pending-pointer-capture">
<h5 title="Process Pending Pointer Capture">5.1.3.2. 処理待ち~pointer捕捉を処理する</h5>

<p class="algo-head">
~UAは、［
~pointer捕捉を暗黙的に解放する
］とき, および［
`gotpointercapture$et, `lostpointercapture$et
］以外の`~pointer~eventを発火-$するときは，次の手続きを走らせ~MUST：
◎
The user agent MUST run the following steps when implicitly releasing pointer capture as well as when firing Pointer Events that are not gotpointercapture or lostpointercapture.
</p>


<div >

<ol>
	<li>
%~pointer ~LET 当の~eventを生じさせた`作動中の~pointer$
</li>
	<li>
%旧-標的 ~LET %~pointer の`捕捉標的$
</li>
	<li>
%新-標的 ~LET %~pointer の`処理待ち捕捉標的$
</li>
	<li>
%~pointer の`捕捉標的$ ~SET %新-標的
</li>
	<li>
~IF［
%旧-標的 ~EQ %新-標的
］
⇒
~RET
</li>
	<li>
~IF［
%旧-標的 ~NEQ ~NULL
］
⇒
%旧-標的 に向けて，名前 `lostpointercapture$et の`~pointer~eventを発火-$する
</li>
	<li>
<p>
~IF［
%新-標的  ~NEQ ~NULL
］
⇒
%新-標的 に向けて，名前 `gotpointercapture$et の`~pointer~eventを発火-$する
</li>
</ol>

◎
If the pointer capture target override for this pointer is set and is not equal to the pending pointer capture target override, then fire a pointer event named lostpointercapture at the pointer capture target override node.
◎
If the pending pointer capture target override for this pointer is set and is not equal to the pointer capture target override, then fire a pointer event named gotpointercapture at the pending pointer capture target override.
◎
Set the pointer capture target override to the pending pointer capture target override, if set. Otherwise, clear the pointer capture target override.
</div>

				</section>
			</section>
		</section>
		<section id="pointer-event-types">
<h3 title="5.2 Pointer Event types">5.2. 各種~pointer~event型</h3>

<p>
この仕様にて定義される各種~event型を以下に述べる。
◎
Below are the event types defined in this specification.
</p>

<p>
`首~pointer$に対しては、（ `gotpointercapture$et, `lostpointercapture$et を例外として）これらの~eventからは，`互換性~mouse~event$も発火され得る。
◎
In the case of the primary pointer, these events (with the exception of gotpointercapture and lostpointercapture) may also fire compatibility mouse events.
</p>

			<section id="the-pointerover-event">
<h4 title="The pointerover event">5.2.1. `pointerover^et ~event</h4>


<div class="p">
<p>
~UAは、［
~pointerが~~操作されて, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］による結果，`捕捉~込みの~pointing先$が変化した
］とき，新たなそれが要素であるならば、その要素に向けて，名前 `pointerover$et の`~pointer~eventを発火-$し~MUST。
</p>

<p>
この~eventは、［
`~hoverを~supportしない$装置により `pointerdown$et ~eventが発火される
］よりも先に発火され~MUST（ `pointerdown$et を見よ）。
</p>
◎
A user agent MUST fire a pointer event named pointerover when a pointing device is moved into the hit test boundaries of an element. Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. A user agent MUST also fire this event prior to firing a pointerdown event for devices that do not support hover (see pointerdown).
</div>

			</section>
			<section id="the-pointerenter-event">
<h4 title="The pointerenter event">5.2.2. `pointerenter^et ~event</h4>


<div >
<p>
~UAは、［
~pointerが~~操作されて, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］による結果，［
`捕捉~込みの~pointing先$が［
要素, および その子孫
］以外から それらのいずれかに変化した†
］とき、名前 `pointerenter$et の`~pointer~eventを発火-$し~MUST。
</p>

<p>
`~hoverを~supportしない$装置の場合、それにより `pointerdown$et ~eventが生じるとき（ `pointerdown$et を見よ）にも，新たな`捕捉~込みの~pointing先$が要素または そのいずれかの子孫であるならば，
“変化した”
ものと見做される。
</p>

<p>
この型の~eventは `pointerover$et に類似するが、浮上しない点で相違する。
</p>

◎
A user agent MUST fire a pointer event named pointerenter when a pointing device is moved into the hit test boundaries of an element or one of its descendants, including as a result of a pointerdown event from a device that does not support hover (see pointerdown). Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. This event type is similar to pointerover, but differs in that it does not bubble.
</div>


<div class="trans-note">
<p>【†
すなわち、（捕捉~込みの）~pointing先が変化したとき，次の両~条件を満たす要素があれば、<em>それら</em>に向けて発火されることになる：
</p>

<ul><li>要素は、新たな~pointing先か, または その先祖である。
</li><li>要素は、前の~pointing先でも, その子孫でもない。
</li></ul>

<p>
そのような要素は、同時に複数~存在し得る（前の~pointing先が存在しない場合は、新たな~pointing先と その先祖~要素すべてが該当することになる）。
その場合， `mouseenter$et のときと同様に、該当する各~要素に向けて，最も先祖のものから順に，この~eventを発火することになるであろう。
】</p>

</div>


<p class="note">注記：
［
この型の~event ,
`mouseenter$et ~event `UIEVENTS$r ,
~CSS~hover_ps 疑似類 `CSS21$r
］の間には類似性がある。
`pointerleave$et ~eventも見よ。
◎
There are similarities between this event type, the mouseenter event described in [UIEVENTS], and the CSS :hover pseudo-class described in [CSS21]. See also the pointerleave event.
</p>
			</section>
			<section id="the-pointerdown-event">
<h4 title="The pointerdown event">5.2.3. `pointerdown^et ~event</h4>

<p>
~UAは、［
~pointerの~buttonが非`作動状態$から`作動状態$へ遷移した
］とき、`~pointing先$が要素であるならば，その要素に向けて
名前 `pointerdown$et の`~pointer~eventを発火-$し~MUST。
【この段落の他の内容は，作動状態の定義に委譲。】
◎
A user agent MUST fire a pointer event named pointerdown when a pointer enters the active buttons state. For mouse, this is when the device transitions from no buttons depressed to at least one button depressed. For touch, this is when physical contact is made with the digitizer. For pen, this is when the pen either makes physical contact with the digitizer without any button depressed, or transitions from no buttons depressed to at least one button depressed while hovering.
</p>

<p class="note">注記：
~mouse（または他の複button~pointer装置）に対しては、これは［
`mousedown$et ／ `mouseup$et
が発火される状況と同じ状況で，常に
`pointerdown$et ／ `pointerup$et
が発火されるとは限らない
］ことを意味する。
`~buttonの追加押下げ$を見よ。
◎
For mouse (or other multi-button pointer devices), this means pointerdown and pointerup are not fired for all of the same circumstances as mousedown and mouseup. See chorded buttons for more information.
</p>

<p>
~UAは、`~hoverを~supportしない$入力~装置に対しては、
`pointerdown$et ~eventを配送するより先に，順に，名前［
`pointerover$et, `pointerenter$et
］の`~pointer~eventを発火-$し~MUST。
【~hoverを~supportする装置の~pointerが、~window外から瞬時に移動してきて，一瞬だけ静止した後，作動状態に遷移したときの挙動と同様になる。】
◎
For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerover followed by a pointer event named pointerenter prior to dispatching the pointerdown event.
</p>

<p class="note">注記：
作者は、 `pointerdown$et ~eventを取消して（その `isPrimary$m 属性が ~T ならば），
ある種の`互換性~mouse~event$の発火を防止できる。
これは、~pointerの`~mouse~event防止~flag$を ~ON にする。
ただし、［
`mouseover$et ／ `mouseenter$et ／ `mouseout$et ／ `mouseleave$et
］~eventの発火は防止されないことに注意。
◎
Authors can prevent the firing of certain compatibility mouse events by canceling the pointerdown event (if the isPrimary property is true). This sets the PREVENT MOUSE EVENT FLAG on the pointer. Note, however, that this does not prevent the mouseover, mouseenter, mouseout, or mouseleave events from firing.
</p>

			</section>
			<section id="the-pointermove-event">
<h4 title="The pointermove event">5.2.4. `pointermove^et ~event</h4>

<p>
~UAは、~pointerの座標が変化した, または［
~event~objに反映されるような~pointerの状態~変化がある, かつ
その状況により 他の~pointer~eventは生産されない
］とき，その`~pointing先$に向けて，名前 `pointermove$et の`~pointer~eventを発火-$し~MUST。
この状態~変化には、~pointerの［
~button状態 ／ 押圧 ／ 接線方向~圧 ／ 傾き ／ ~twist ／ `接触~幾何$（例： `width$m, `height$m ）
］が含まれる。
◎
A user agent MUST fire a pointer event named pointermove when a pointer changes coordinates. Additionally, when a pointer changes button state, pressure, tangential pressure, tilt, twist, or contact geometry (e.g. width and height) and the circumstances produce no other pointer events defined in this specification then a user agent MUST fire a pointer event named pointermove.
</p>

<p class="trans-note">【
実質的には、座標の変化も後者に解釈して差し支えないであろう。
その変化は、ほぼ “~~連続的” であり，他の~eventと直交的に生じると見なせるので。
ある瞬間に，~pointerの物理的な動きと同時に`~pointing先$が変化したとしても、その変化は，座標~変化の前／後に生じたことにして十分になる
— 前／後いずれにせよ，~UI操作i~modelに現れる相違は無視できるので。
】</p>


			</section>
			<section id="the-pointerup-event">
<h4 title="The pointerup event">5.2.5. `pointerup^et ~event</h4>

<p>
~UAは、［
~pointerの~buttonが`作動状態$から非`作動状態$へ遷移した
］とき、その~pointing先に向けて，名前 `pointerup$et の`~pointer~eventを発火-$し~MUST。
【この段落の他の内容は，作動状態の定義に委譲。】
◎
A user agent MUST fire a pointer event named pointerup when a pointer leaves the active buttons state. For mouse, this is when the device transitions from at least one button depressed to no buttons depressed. For touch, this is when physical contact is removed from the digitizer. For pen, this is when the pen is removed from the physical contact with the digitizer while no button is depressed, or transitions from at least one button depressed to no buttons depressed while hovering.
</p>

<p>
`~hoverを~supportしない$入力~装置に対しては、~UAは，
`pointerup$et ~eventを配送した後に，［
順に，名前 `pointerout$et, `pointerleave$et の`~pointer~eventを発火-$
］し~MUST。
【~hoverを~supportする装置の~pointerが、非~作動状態に遷移して，一瞬だけ静止した後，瞬時に~window外へ移動したときの挙動と同様になる。】
◎
For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerout followed by a pointer event named pointerleave after dispatching the pointerup event.
</p>

<p class="note">注記：
~mouse（または他の複button~pointer装置）に対しては、これは［
`mousedown$et ／ `mouseup$et
が発火される状況と同じ状況で，常に
`pointerdown$et ／ `pointerup$et
が発火されるとは限らない
］ことを意味する。
`~buttonの追加押下げ$を見よ。
◎
For mouse (or other multi-button pointer devices), this means pointerdown and pointerup are not fired for all of the same circumstances as mousedown and mouseup. See chorded buttons for more information.
</p>
			</section>
			<section id="the-pointercancel-event">
<h4 title="The pointercancel event">5.2.6. `pointercancel^et ~event</h4>

<p>
~UAは、次の状況においては，名前 `pointercancel$et の`~pointer~eventを発火-$し~MUST：
◎
A user agent MUST fire a pointer event named pointercancel in the following circumstances:
</p>

<ul>
	<li>
~UAが、その~pointerは，それ以上~eventを生産し続ける見込みは低いと決定した場合（例えば ~hardware~eventにより【この節の末尾の注記】
）。
◎
The user agent has determined that a pointer is unlikely to continue to produce events (for example, because of a hardware event).
</li>
	<li>
<p>
`pointerdown$et ~eventが発火された後に引き続いて、~pointerは，頁~表示域を操作するために利用された（例： ~pan-zoom）。
◎
After having fired the pointerdown event, if the pointer is subsequently used to manipulate the page viewport (e.g. panning or zooming).
</p>

<p class="note">注記：
~UAは，~panningや~zoomingを複数の~pointer型（~touchや~penなど）を通して誘発し得るので、~panや~zoom動作を開始した結果，各種~pointerは取消されることもある
— 異なる~pointer型も含め。
◎
User agents can trigger panning or zooming through multiple pointer types (such as touch and pen), and therefore the start of a pan or zoom action may result in the cancellation of various pointers, including pointers with different pointer types.
</p>
	</li>
	<li>
<p>
~pointerにより`~drag操作oが開始され$る直前。
`HTML$r
◎
Immediately before drag operation starts [HTML], for the pointer that caused the drag operation.
</p>

<p class="note">注記：
手段を問わず，~drag操作oの開始-が防止された場合（例：
`dragstart^et ~event上で `preventDefault()$m を~callするなど）、
`pointercancel$et ~eventは生じなくなる。
◎
If the start of the drag operation is prevented through any means (e.g. through calling preventDefault on the dragstart event) there will be no pointercancel event.
</p>
	</li>
</ul>

<p>
~UAは、 `pointercancel$et ~eventを発火した後に，［
順に，名前 `pointerout$et, `pointerleave$et の`~pointer~eventを発火-$
］し~MUST。
◎
After firing the pointercancel event, a user agent MUST also fire a pointer event named pointerout followed by firing a pointer event named pointerleave.
</p>


<div class="note">

<p>注記：
［
~UAが，~pointerがそれ以上~eventを生産し続ける見込みは低いと決定する
］であろう局面の例には、次が挙げられる：
◎
This section is non-normative.
◎
Examples of scenarios in which a user agent might determine that a pointer is unlikely to continue to produce events include:
</p>

<ul>
	<li>
~pointerが`作動中の$間に装置の~screen方位が変化した。
◎
A device's screen orientation is changed while a pointer is active.
</li>
	<li>
利用者が、装置にて~supportされる数より大きい数の~pointerを同時に入力した。
◎
The user inputs a greater number of simultaneous pointers than is supported by the device.
</li>
	<li>
~UAは、入力が不意のものと解釈した（例えば、 `palm rejection^en を~supportする~hardware）。
◎
The user agent interprets the input as accidental (for example, the hardware supports palm rejection).
</li>
	<li>
~UAは、入力を~panまたは~zoomによる~gestureと解釈した。
◎
The user agent interprets the input as a pan or zoom gesture.
</li>

<!-- 
同じ型の別の装置による入力が生じた（例えば 2 つの~mouse）
-->
</ul>

<p>
装置の~screen方位を変化させる ／
不意の入力を認識する ／
~pointerを利用して表示域を操作する（例： ~pan-zoom）
ための手法は、この仕様の視野外である。
◎
Methods for changing the device's screen orientation, recognizing accidental input, or using a pointer to manipulate the viewport (e.g. panning or zooming) are out of scope for this specification.
</p>
</div>


			</section>
			<section id="the-pointerout-event">
<h4 title="The pointerout event">5.2.7. `pointerout^et ~event</h4>


<p>
~UAは、［
~pointerが~~操作されて, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］による結果，`捕捉~込みの~pointing先$が変化した
］とき，前のそれが要素であるならば、その要素に向けて，名前 `pointerout$et の`~pointer~eventを発火-$し~MUST。
ここで、次の場合も “変化した” ものと見做される：
◎
A user agent MUST fire a pointer event named pointerout when any of the following occurs:
◎
A pointing device is moved out of the hit test boundaries of an element. Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events.
</p>

<div>

<ul>
	<li>
`~hoverを~supportしない$装置により，要素に向けて
`pointerup$et ~eventが発火されたとき（ `pointerup$et を見よ）。
◎
After firing the pointerup event for a device that does not support hover (see pointerup).
</li>
	<li>
要素に向けて `pointercancel$et ~eventが発火されたとき（ `pointercancel$et を見よ）。
◎
After firing the pointercancel event (see pointercancel).
</li>
	<li>
~pen~stylusが，`~digitizer$により検出-可能な~hover範囲から出たとき。
◎
When a pen stylus leaves the hover range detectable by the digitizer.
</li>
</ul>
</div>


			</section>
			<section id="the-pointerleave-event">
<h4 title="The pointerleave event">5.2.8. `pointerleave^et ~event</h4>


<div class="p">

<p>
~UAは、［
~pointerが~~操作されて, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］による結果，［
`捕捉~込みの~pointing先$が［
要素, および その子孫
］いずれかから それら以外に変化した†
］とき、その要素に向けて，名前 `pointerleave$et の`~pointer~eventを発火-$し~MUST。
</p>

<p>
ここで，次が生じた場合も、直前の`捕捉~込みの~pointing先$が［
要素, または その ある子孫
］であった場合には， “変化した” ものと見做される：
</p>

<ul><li>~pen~stylusが，`~digitizer$により検出-可能な~hover範囲を出たとき。
</li><li>`~hoverを~supportしない$装置により
`pointerup$et ／ `pointercancel$et
~eventが生じたとき（
`pointerup$et ／ `pointercancel$et
を見よ）。
</li>
</ul>

<p>
この型の~eventは `pointerout$et に類似するが、浮上しないこと, および
~pointing装置が［
要素と そのすべての子孫が成す境界
］を出るまでは，発火されては~MUST_NOT点で相違する。
</p>

◎
A user agent MUST fire a pointer event named pointerleave when a pointing device is moved out of the hit test boundaries of an element and all of its descendants, including as a result of a pointerup and pointercancel events from a device that does not support hover (see pointerup and pointercancel). Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. User agents MUST also fire a pointer event named pointerleave when a pen stylus leaves hover range detectable by the digitizer. This event type is similar to pointerout, but differs in that it does not bubble and that it MUST not be fired until the pointing device has left the boundaries of the element and the boundaries of all of its descendants.
</div>



<div class="trans-note">
<p>【†
すなわち、（捕捉~込みの）~pointing先が変化したとき，次の両~条件を満たす要素があれば、<em>それら</em>に向けて発火されることになる：
</p>

<ul><li>要素は、前の~pointing先か, または その先祖である。
</li><li>要素は、新たな~pointing先でも, その子孫でもない。
</li></ul>

<p>
そのような要素は、同時に複数~存在し得る（新たな~pointing先が存在しない場合は、前の~pointing先と その先祖~要素すべてが該当することになる）。
その場合、該当する各~要素に向けて，（ `pointerenter$et のときとは逆順に）最も子孫のものから順に，この~eventを発火することになるであろう。
】</p>

</div>

<p class="note">注記：
［
この型の~event,
`mouseleave$et ~event `UIEVENTS$r,
~CSS~hover_ps 疑似類 `CSS21$r
］の間には類似性がある。

`pointerenter$et ~eventも見よ。
◎
There are similarities between this event type, the mouseleave event described in [UIEVENTS], and the CSS :hover pseudo-class described in [CSS21]. See also the pointerenter event.
</p>
			</section>
			<section id="the-gotpointercapture-event">
<h4 title="The gotpointercapture event">5.2.9. `gotpointercapture^et ~event</h4>

<p>
~UAは、［
~pointerが要素に`捕捉$された
］とき、その要素に向けて，名前 `gotpointercapture$et の`~pointer~eventを発火-$し~MUST。
その~pointerに対する後続の~eventは、この要素に向けて発火されることになる。
［
`~pointer捕捉の設定-法$ ／
`処理待ち~pointer捕捉を処理-$する
］各~節を見よ。
◎
A user agent MUST fire a pointer event named gotpointercapture when an element receives pointer capture. This event is fired at the element that is receiving pointer capture. Subsequent events for that pointer will be fired at this element. See the Setting Pointer Capture and Process Pending Pointer Capture sections.
</p>
			</section>
			<section id="the-lostpointercapture-event">
<h4 title="The lostpointercapture event">5.2.10. `lostpointercapture^et ~event</h4>

<p>
~UAは、［
要素による`~pointer捕捉$が解放された
］とき，その要素に向けて 名前 `lostpointercapture$et の`~pointer~eventを発火-$し~MUST。
この~eventは、~pointerが捕捉から解放された後に生じるどの~eventよりも先に発火され~MUST。
~pointerによる後続の~eventの標的は、通常の`~pointing先$になる。
`~pointer捕捉の解放-法$ ／
<a href="#implicit-release-of-pointer-capture">~pointer捕捉の暗黙的な解放-</a> ／
`処理待ち~pointer捕捉を処理-$する
各~節を見よ。
◎
A user agent MUST fire a pointer event named lostpointercapture after pointer capture is released for a pointer. This event MUST be fired prior to any subsequent events for the pointer after capture was released. This event is fired at the element from which pointer capture was removed. Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. See the Releasing Pointer Capture, Implicit Release of Pointer Capture, and Process Pending Pointer Capture sections.
</p>
				</section>
			</section>
		</section>
		<section id="extensions-to-the-element-interface">
<h2 title="Extensions to the Element interface">6. `Element^I ~interfaceに対する拡張</h2>


<p>
以下の各~節では、 `HTML5$r にて定義される既存の `Element^I ~interfaceに対する拡張を述べる。
これにより、~scriptは，~pointer捕捉を設定-／解放できるようになる。
◎
The following section describes extensions to the existing Element interface, defined in [HTML5], to facilitate the setting and releasing of pointer capture.
</p>


<pre class="idl">
partial interface `Element!I {
    void    `setPointerCapture$m(long %pointerId);
    void    `releasePointerCapture$m(long %pointerId);
    boolean `hasPointerCapture$m(long %pointerId);
};
</pre>

<dl class="idl-def">

	<dt>`setPointerCapture(pointerId)@m</dt>
	<dd>
此れが［
%pointerId により識別される~pointer
］を`捕捉$するよう`設定-$する。
この~pointerにより生じる後続の~eventに対しては、当の~pointerが常に それを捕捉している標的に重なっているかのように，通常の接触判定の結果は標的に置き換えられ、この捕捉が解放されるまで，常に此れを標的にし~MUST。
この~methodが有効になるのは，~pointerの~buttonが`作動状態$にあるときに限られ、そうでなければ，何もしては~MUST_NOT。
%pointerId が`作動中の$どの~pointerにも合致しない場合、
`InvalidPointerId^E 例外が投出される。
◎
Sets pointer capture for the pointer identified by the argument pointerId to the element on which this method is invoked. For subsequent events of the pointer, the capturing target will substitute the normal hit testing result as if the pointer is always over the capturing target, and they MUST always be targeted at this element until capture is released. The pointer MUST be in its active buttons state for this method to be effective, otherwise it fails silently. Throws a DOMException with the name InvalidPointerId when the provided method's argument does not match any of the active pointers.
</dd>
	<dd class="trans-note">【
~methodの定義は、`~pointer捕捉の設定-法$ 節に。
】</dd>

	<dt>`releasePointerCapture(pointerId)@m</dt>
	<dd>
此れが`捕捉$している［
%pointerId により識別される~pointer
］を`明示的に解放-$する。
すなわち、~pointerにより生じる後続の~eventにおける標的は、通常の`~pointing先$になる。
%pointerId が`作動中の$どの~pointerにも合致しない場合、
`InvalidPointerId^E 例外が投出される。
◎
Releases pointer capture for the pointer identified by the argument pointerId from the element on which this method is invoked. Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. Throws a DOMException with the name InvalidPointerId when the provided the method's argument does not match any of the active pointers.
</dd>
	<dd class="trans-note">【
~methodの定義は、`~pointer捕捉の解放-法$ 節に。
】</dd>

	<dt>`hasPointerCapture(pointerId)@m</dt>
	<dd>
此れが［
%pointerId により識別される~pointer
］を`捕捉$しているかどうかを指示する。
すなわち、［
%pointerId に対する`処理待ち捕捉標的$ ~EQ 此れ ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Indicates whether the element on which this method is invoked has pointer capture for the pointer identified by the argument pointerId. In particular, returns true if the pending pointer capture target override for pointerId is set to the element on which this method is invoked, and false otherwise.
</dd>
	<dd class="note">注記：
この~methodは、 `setPointerCapture()$m を~callした直後において，当の要素が まだ `gotpointercapture$et ~eventを受取っていなくても、 ~T を返す。
その結果、 `pointerdown$et ~event用の~listenerの内側から `暗黙的な~pointer捕捉$を検出するときに有用になる。
◎
This method will return true immediately after a call to setPointerCapture, even though that element will not yet have received a gotpointercapture event. As a result it can be useful for detecting implicit pointer capture from inside of a pointerdown event listener.
</dd>

</dl>

		</section>
		<section id="extensions-to-the-globaleventhandlers-interface">
<h2 title="Extensions to the GlobalEventHandlers interface">7. `GlobalEventHandlers^I ~interfaceに対する拡張</h2>

<p>
この節では、既存の `GlobalEventHandlers$I ~interface `HTML5$r に対し，~event~handlerを登録し易くするための拡張を述べる。
◎
The following section describes extensions to the existing GlobalEventHandlers interface, defined in [HTML5], to facilitate the event handler registration.
</p>

<pre class="idl">
partial interface `GlobalEventHandlers!I {
    attribute `EventHandler^I `ongotpointercapture@m;
    attribute `EventHandler^I `onlostpointercapture@m;
    attribute `EventHandler^I `onpointerdown@m;
    attribute `EventHandler^I `onpointermove@m;
    attribute `EventHandler^I `onpointerup@m;
    attribute `EventHandler^I `onpointercancel@m;
    attribute `EventHandler^I `onpointerover@m;
    attribute `EventHandler^I `onpointerout@m;
    attribute `EventHandler^I `onpointerenter@m;
    attribute `EventHandler^I `onpointerleave@m;
};
</pre>

<p>
これらの属性は、いずれも，対応する名前の~event型に対する`~event~handler IDL 属性$ `HTML5$r である。
◎
ongotpointercapture
◎
The event handler IDL attribute (see [HTML5]) for the gotpointercapture event type. 
◎
onlostpointercapture
◎
The event handler IDL attribute (see [HTML5]) for the lostpointercapture event type. 
◎
onpointerdown
◎
The event handler IDL attribute (see [HTML5]) for the pointerdown event type.
◎
onpointermove
◎
The event handler IDL attribute (see [HTML5]) for the pointermove event type.
◎
onpointerup
◎
The event handler IDL attribute (see [HTML5]) for the pointerup event type.
◎
onpointercancel
◎
The event handler IDL attribute (see [HTML5]) for the pointercancel event type.
◎
onpointerover
◎
The event handler IDL attribute (see [HTML5]) for the pointerover event type.
◎
onpointerout
◎
The event handler IDL attribute (see [HTML5]) for the pointerout event type.
◎
onpointerenter
◎
The event handler IDL attribute (see [HTML5]) for the pointerenter event type.
◎
onpointerleave
◎
The event handler IDL attribute (see [HTML5]) for the pointerleave event type.
</p>

		</section>
		<section id="extensions-to-the-navigator-interface">
<h2 title="Extensions to the Navigator interface">8. `Navigator^I ~interfaceに対する拡張</h2>

<p>
装置の検出~supportを供するため、この仕様は，
`Navigator^I ~interface `HTML5$r を拡張する。
◎
The Navigator interface is defined in [HTML5]. This specification extends the Navigator interface to provide device detection support.
</p>

<pre class="idl">
partial interface `Navigator!I {
    readonly    attribute long `maxTouchPoints$m;
};
</pre>


<dl class="idl-def">

	<dt>`maxTouchPoints@m</dt>
	<dd>
装置により~supportされる同時~touch接触の最大~数。
複数の`~digitizer$を備える装置の事例では（例： 複数の~touchscreen）、値は，［
個々の~digitizerにより~supportされる最大~接触~数
］のうちの最大で~MUST。
◎
The maximum number of simultaneous touch contacts supported by the device. In the case of devices with multiple digitizers (e.g. multiple touchscreens), the value MUST be the maximum of the set of maximum supported contacts by each individual digitizer.
</dd>
	<dd class="example">
例えば、装置が 3 つの~touchscreenを備えていて
~supportする同時~touch接触~数が 2, 5, 10 ならば、
`maxTouchPoints$m 値は `10^c にされるべきである。
◎
For example, suppose a device has 3 touchscreens, which support 2, 5, and 10 simultaneous touch contacts, respectively. The value of maxTouchPoints should be 10.
</dd>

</dl>

<p class="note">注記：
`maxTouchPoints$m に対する 0 より大きい値が，利用者の装置が~touch入力を~supportすることを指示するとしても、利用者が~touch入力を利用している<em>とは限らない</em>。
作者は、［
~mouse, ~pen, ~screenreader, 等々
］，~system上に在り得る他の入力~様式も注意深く考慮するべきである。
◎
While a maxTouchPoints value of greater than 0 indicates the user's device is capable of supporting touch input, it does not necessarily mean the user will use touch input. Authors should be careful to also consider other input modalities that could be present on the system, such as mouse, pen, screen readers, etc.
</p>

<p class="note">注記：
`maxTouchPoints$m は、［
現在の~hardwareでも，内容の対話~modelを認識できるようにする
］ことを確保するために利用されることが多い。
~hardware能力がより限られた下でも、利用者に~UI ~affordancesを供することはできる。
精確な最大~接触~数が既知でない~platform上では、認識されることが保証される最小~数が供される。
したがって、認識される~touch接触~数が `maxTouchPoints$m の値を超過することもあり得る。
◎
maxTouchPoints is often used to ensure that the interaction model of the content can be recognized by the current hardware. UI affordances can be provided to users with less capable hardware. On platforms where the precise number of touch points is not known, the minimum number guaranteed to be recognized is provided. Therefore, it is possible for the number of recognized touch points to exceed the value of maxTouchPoints.
</p>

	</section>
	<section id="declaring-candidate-regions-for-default-touch-behaviors">
<h2 title="Declaring candidate regions for default touch behaviors">9. ~touch用の既定の挙動に対する候補~領域の宣言-法</h2>

<!-- `PointerEvent!I -->

<p>
~touch入力に対しては、どの`~pointer~event$であれ，その`既定~動作$が 表示域の操作（例： ~pan-zoom）になっては~MUST_NOT。
◎
For touch input, the default action of any and all pointer events MUST NOT be a manipulation of the viewport (e.g. panning or zooming).
</p>

<p class="note">注記：
~touch操作は、意図的に，~pointer~eventの`既定~動作$にされていない。
この，［
~eventの取消~結果に対する依存関係
］を除去することは、~UAによる処理能の最適化を手助けするためである。
◎
Touch manipulations are intentionally not a default action of pointer events. Removing this dependency on the cancellation of events facilitates performance optimizations by the user agent.
</p>

<p class="note">注記：
表示域の操作-時に利用される~pointerに関する課題は，一般に~touch入力に限られるが（利用者の手指が，内容との対話-にも, 頁の~pan／~zoomにも利用され得る所で）、他の~pointer型に対しても（直接的／間接的を問わず）同じ型の操作を許容する~UAも中にはある。
具体例として，携帯~装置／~tablet装置においては、利用者は~stylusを用いて~panすることもできるかもしれない。
この節は、そのような局面にも適用される（この仕様における語 “~touch” の~~用法にかかわらず）。
◎
While the issue of pointers used to manipulate the viewport is generally limited to touch input (where a user's finger can both interact with content and pan/zoom the page), certain user agents may also allow the same types of (direct or indirect) manipulation for other pointer types. For instance, on mobile/tablet devices, users may also be able to pan using a stylus. This section applies to these scenarios as well (despite the specification's use of "touch").
</p>

		<section id="the-touch-action-css-property">
<h3 title="The touch-action CSS property">9.1. `touch-action^p ~CSS~prop</h3>

◎名 `touch-action@p
◎値 `auto$v | `none$v | [ `pan-x$v || `pan-y$v ] | `manipulation$v
◎初 `auto$v
◎適 
次を除くすべての要素：
`置換され$ない 【行内】要素, ~tableの［
`row^v, `row-group^v, `column^v, `column-group^v
］
◎
all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups.
◎継 されない
◎百 受容しない
◎媒 視覚的
◎算 指定値
◎表終

<p>
`touch-action$p ~CSS~propは、~touch入力により，~UAが給する既定の挙動が誘発されてよいかどうかを決定する。
これには、少なくとも，~pan-zoomの挙動が含まれる。
<a href="#details-of-touch-action-values">`touch-action^p 値の節</a>
を見よ。
◎
The touch-action CSS property determines whether touch input MAY trigger default behavior supplied by user agent. This includes, but is not limited to, behaviors such as panning or zooming. See the section on touch-action values.
</p>


<p class="note">注記：
先に注記したように、~touch以外の~pointer型にも既定の挙動（~panningや~zoomingなど）を許容する~UAは，その種の~pointer型にも~touchと同じように適用し~MUST。
具体例として，~stylusによる~panning／~zoomingを許容する~UAは、どの既定の挙動を取扱うかを決定する際に，関連する `touch-action^p 値を織り込ま~MUST。
◎
As noted previously, in the case of user agents that allow default behaviors (such as panning or zooming) for other pointer types, these user agents MUST apply the same consideration for those pointer types. For instance, if a user agent allows panning/zooming with a stylus, the user agent must take into account the relevant touch-action value when determining which default behaviors it should handle.
</p>

<p>
~UAは、`~touch用の既定の挙動$を実行している間は，その~pointerよる後続の`~pointer~eventを発火-$しては~MUST_NOT。
~UAは、次のすべてが成立するときは、~pointerによる`~event連列$を終わらせるため，名前 `pointercancel$et の`~pointer~eventを発火-$し~MUST（それに伴い， `pointerout$et ~event, 一つ以上の `pointerleave$et ~eventも発火されることになる）：
◎
During the execution of a user agent touch behavior, the user agent MUST NOT fire subsequent pointer events for the pointer. The user agent MUST fire a pointer event named pointercancel (and subsequently a pointerout event and one or more pointerleave events) whenever all of the following are true, in order to end the stream of events for the pointer:
</p>

<ul>
	<li>
~UAは、その~touch入力を，`~touch用の既定の挙動$用に消費するものと決定した（その決定-法は、この仕様の視野外である）。
◎
The user agent has determined (via methods out of scope for this specification) that touch input is to be consumed for a touch behavior,
</li>
	<li>
【その`~event連列$において】
~pointerに対する `pointerdown$et ~eventは、すでに送信した。
◎
a pointerdown event has been sent for the pointer, and
</li>
	<li>
~pointerに対する［
（前項の `pointerdown$et に後続する）
`pointerup$et
］ ／ `pointercancel$et
~eventは、まだ送信していない。
◎
a pointerup or pointercancel event (following the above mentioned pointerdown) has not yet been sent for the pointer.
</li>
</ul>

<p class="note">注記：
~UAは、既定の挙動~用に［
一連の別個の~gestureを孕むが，それらすべてが単独の継続的な~gestureを成すものとして扱われる
］ような複雑な~gestureを実装しても~MAY。
例えば、利用者が~touchscreen上で “投げつける” ように~scrollする（ “`fling to scroll^en” ）~gestureを考える
— 敏捷な手指の動きで，文書の~panningを開始して, ~touchscreenから手指を~~離したとき，文書は惰性で~scrollし続けるような。
文書がまだ動いている間、利用者は，~touchscreenに手指を置いて別の “投げつけ” を実行するかもしれない
— 現在の~scrollingに対し、もっと勢いをつけるか，制動して［
遅める／停止する／逆~方向にする
］ような。
この仕様は、~gestureと既定の挙動がどう実装されるかは、規範的に定義しない
— 2 度目の~touchが（現在の~scrollingに対する 2 度目の “投げつけ” ／制動として解釈される前に）~pointer~eventを発火するべきかどうか決めるのは、~UAに委ねられる。
◎
User agents may implement complex gestures for default behaviors that involve a series of separate discrete gestures, but which are all treated as part of a single continuous gesture. For example, consider a "fling to scroll" gesture on a touchscreen: a user starts panning the document with a rapid finger movement, lifts the finger from the touchscreen, and the document continues scrolling with simulated inertia. While the document is still moving, the user may place their finger on the touchscreen and execute another "fling" to provide further momentum for the scrolling, or counteract the current scrolling to slow it down, stop scrolling altogether, or reverse the direction of the scrolling. As this specification does not normatively define how gestures and default behaviors are implemented, it is left up to the user agent to decide whether or not the second touch (before it is interpreted as a second "fling" or counteraction of the current scrolling) should fire pointer events or not.
</p>

		</section>
		<section id="determining-supported-touch-behavior">
<h3 title="Determining supported touch behavior">9.2. ~touchの挙動の決定-法</h3>


<p>
利用者による~touchに対する効果は、［
要素とその各~先祖
］上の［
`touch-action$p ~propの値, および
`~touch用の既定の挙動$
］により，次に従って決定される：
◎
When a user touches an element, the effect of that touch is determined by the value of the touch-action property, and the default touch behaviors of the element and its ancestors, as follows:
</p>

<ul>
	<li>
~touchの挙動は、要素の座標系にて許容されるならば，要素の `touch-action$p に
`適合する@
とされる。
~CSS変形-が適用されている場合、要素の座標系は，ここでの適合-度に影響する仕方で~screen座標から異なり得ることに注意。
例えば，要素の X 軸が~screenを基準に 90° 回転されている場合、~screen座標系の Y 軸に平行になる。
◎
A touch behavior conforms to an element's touch-action if the behavior is allowed in the coordinate space of the element. Note that if CSS transforms have been applied, the element's coordinate space may differ from the screen coordinate in a way to affect the conformity here; for example, the X axis of an element rotated by 90 degrees with respect to the screen will be parallel to the Y-axis of the screen coodinate.
</li>
	<li>
<p>
~UAが`~touch用の既定の挙動$を~supportするのは、その挙動が，［
次に与える %E から %F まで
］の どの要素の `touch-action$p ~propにも`適合する$ときになる
— ここで：
</p>

<ol><li>%E は、~touchの`~pointing先$。
</li><li>%F は、［
%E, および %E の各~先祖
］のうち，`~touch用の既定の挙動$を有するような要素であって，最も子孫~側のもの。
</li></ol>
◎
A touch behavior is supported if it conforms to the touch-action property of each element between the hit tested element and its nearest ancestor with the default touch behavior (including both the hit tested element and the element with the default touch behavior).
</li>
	<li>
~touch動作が開始され，［
その動作を~touch用の既定の挙動として取扱うべきかどうか
］を~UAが決定して以降は、その動作が終わるまでは，関連する `touch-action$p 値を変更しても無視されることになる。
具体例として、要素~上の `touch-action$p 値を，~scriptの `pointerdown$et ~handlerの中で~program的に `auto^v から `none^v に変更しても、~pointerが作動中にある限り，~UAがその~touch用の既定の挙動を中止したり抑止することはない。
◎
Once a touch action has been started, and the user agent has already determined whether or not the action should be handled as a user agent touch behavior, any changes to the relevant touch-action value will be ignored for the duration of the touch action. For instance, programmatically changing the touch-action value for an element from auto to none as part of a pointerdown handler script will not result in the user agent aborting or suppressing any default touch behavior for that touch for as long as that pointer is active.
</li>
</ul>

<p class="note">注記：
一部の~UAは、［
複数の同時的~pointerによる操作i
］により誘発される~touch動作も~supportする（例： 複touch）。
複数の同時的~pointerに対し `touch-action$p 値を
処理したり／結付ける
ための手法は、この仕様の視野外である。
◎
Some user agents support touch actions triggered by interactions of multiple concurrent pointers (e.g. multi-touch). Methods for processing or associating the touch-action values of multiple concurrent pointers is out of scope for this specification.
</p>

		</section>
		<section id="details-of-touch-action-values">
<h3 title="Details of touch-action values">9.3. `touch-action^p 値の詳細</h3>

<dl>
	<dt>`auto@v</dt>
	<dd>
~UAは、要素~上から始まる`~touch用の既定の挙動$を任意に決定して~MAY。
◎
The user agent MAY determine any permitted touch behaviors, such as panning and zooming of the viewport, for touches that begin on the element.
</dd>

	<dt>`none@v</dt>
	<dd>
~UAは、要素~上から始まる`~touch用の既定の挙動$を誘発しては~MUST_NOT。
◎
Touches that begin on the element MUST NOT trigger default touch behaviors.
</dd>

	<dt>`pan-x@v</dt>
	<dt>`pan-y@v</dt>
	<dd>
これらの成分~値の組み合わせに対しては、~UAは，要素で始まる~touchを［
各~成分が表す各~軸~方向への~scrollingを開始する目的
］に限って，考慮して~MAY。
【例えば `pan-y^v のみならば縦のみ， `pan-x pan-y^v ならば縦横両方とも。】
◎
The user agent MAY consider touches that begin on the element only for the purposes of scrolling that starts in any of the directions specified by all of the listed values.＼
</dd>
	<dd>
~scrollingが開始されてから，利用者が~scrollできる方向は、単独の軸に制約されている場合には（例： `pan-y^v ），その軸に限られる。
【原文には “逆~方向へ~scrollできる” という記述もあるが、仕様~更新により~~意味を成さなくなったので，和訳は省略する。】
<!-- https://github.com/w3c/pointerevents/commit/17647a38cf3dac4d200953417f27202de5f2febd -->
◎
Once scrolling is started, the direction may be reversed by the user even if scrolls that start in the reversed direction are disallowed. In contrast, when scrolling is restricted to starting along a single axis (eg. pan-y), the axis cannot be changed during the scroll.
</dd>

	<dt>`manipulation@v</dt>
	<dd>
~UAは、要素~上で始まる~touchを［
~scrollingと継続的な~zooming
］の目的に限って考慮して~MAY。
`auto$v において~supportされる 他のどの挙動も，この仕様の視野外である。
◎
The user agent MAY consider touches that begin on the element only for the purposes of scrolling and continuous zooming. Any additional behaviors supported by auto are out of scope for this specification.
</dd>

</dl>

<p class="note">注記：
各 実装に共通する追加の `touch-action$p 値も，
`COMPAT$r にて
<a href="~COMPAT#touch-action">定義されている</a>
◎
Additional touch-action values common in implementations are defined in [COMPAT].
</p>

<p class="note">注記：
用語
“~pan” と “~scroll”
は、同義語と見なされる。
［
~panningや~scrollingを誘発させる
操作iや~gestureを定義すること ／
`auto$v や `none$v 値に対する誘発の挙動
］は、この仕様の視野外である。
◎
The terms "pan" and "scroll" are considered synonymous. Defining an interaction or gesture for triggering panning or scrolling, or for triggering behavior for the auto or none values are out of scope for this specification.
</p>

<p class="note">注記：
`touch-action$p ~propを適用し得る要素は、~CSS `width$p, `height$p ~prop `CSS21$r のいずれも適用し得るものに限られる。
この制約は、~UAが~touch動作の応答性を最適化し易くするための設計である。
`span^e （ `HTML5$r）などの`置換され$ない`行内~要素$など，既定では~supportされない要素~用には、作者は，~CSS `display$p ~propに［
`block^v などの `width^p, `height^p を適用し得る値
］を設定できる。
将来の仕様は、この~APIをすべての要素にまで拡張し得る。
◎
The touch-action property only applies to elements that support both the CSS width and height properties (see [CSS21]). This restriction is designed to facilitate user agent optimizations for low-latency touch actions. For elements not supported by default, such as &lt;span&gt; which is a non-replaced inline element (see [HTML5]), authors can set the display CSS property to a value, such as block, that supports width and height. Future specifications could extend this API to all elements.
</p>

<p class="note">注記：
一部の`~touch用の既定の挙動$を不能化すると、~UAによる他の挙動に対する応答が素早くなることもある。
例えば，~UAによっては、~double-tap ~gestureを取扱えるようにするため，
`click^et の前に 300ms ほどの遅延を自動的に入れるものもある。
そのような事例では、
`touch-action$p に明示的に値［
`none$v ／ `manipulation$v
］を設定することにより，この遅延は除かれることになる。
~tapや~double-tap ~gestureを決定するための手法については、この仕様の視野外であることに注意。
◎
Note
Disabling some default touch behaviors may allow user agents to respond to other behaviors more quickly. For example, with auto user agents typically add 300ms of delay before click to allow for double-tap gestures to be handled. In these cases, explicitly setting touch-action: none or touch-action: manipulation will remove this delay. Note that the methods for determining a tap or double-tap gesture are out of scope for this specification.
</p>


		</section>

<div class="example">

<p>
~touchの挙動をすべて許容しない例：
◎
Disallowing all touch behaviors
</p>

<pre id="example_6">
&lt;div style="touch-action: none;"&gt;
<span class="comment">
この要素は、すべての~touchに対し~pointer~eventを受取る。
◎
This element receives pointer events for all touches.
</span>
&lt;/div&gt;
</pre>

<p>
横方向への~panningに限り許容する例：
◎
Allowing horizontal panning only
</p>

<pre id="example_7">
&lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、横方向へ~panしていないときは~pointer~eventを受取る
◎
This element receives pointer events when not panning in the horizontal direction.
</span>
&lt;/div&gt;
</pre>

<p>
~touchの挙動を許容しない子~領域がある例：
◎
Child regions that disallow touch behaviors
</p>

<pre id="example_8">&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: none;"&gt;
<span class="comment">
この要素は、すべての~touchに対し~pointer~eventを受取る。
◎
This element receives pointer events for all touches.
</span>
    &lt;/div&gt;
    &lt;div&gt;
<span class="comment">
この要素~上の~touchは、親を操作するために消費され得る。
◎
Touches on this element MAY be consumed for manipulating the parent.
</span>
    &lt;/div&gt;
&lt;/div&gt;
</pre>

<p>
~touchの挙動を許容しない親が挟まれている例：
◎
Intermediate parent that disallows touch behaviors
</p>
<pre id="example_9">
&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: pan-y;"&gt;
        &lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、すべての~touchに対し~pointer~eventを受取る
— 横方向への~panningのみを許容する要素と `auto$v 先祖との間には，縦方向の~panningのみを許容する先祖があるので。
したがって、要素に対しては，`~touch用の既定の挙動$は許容されない。
◎
This element receives pointer events for all touches because
it allows only horizontal panning yet an intermediate ancestor 
(between it and the pannable element) only allows vertical panning. 
Therefore, no touch behaviors are allowed.
</span>
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>

</div>

	</section>
	<section id="pointer-capture">
<h2 title="Pointer Capture">10. ~pointer捕捉</h2>

~INFORMATIVE

<p>
~pointer捕捉により、特定0の~pointerから生じる各~event（`互換性~mouse~event$も含む）の標的を、通常の`~pointing先$でない，特定0の要素にすることが可能になる。
これは、（ `&lt;input type="range"&gt;^e ~control `HTML5$r に類する）~custom~slider~controlを作るときなどに有用になる。
~pointer捕捉を ~slider~thumbの要素~上に設定すれば、利用者は，~pointerがその~thumbからそれたときにも ~controlを前後に~slideさせられるようになる。
◎
Pointer capture allows the events for a particular pointer (including any compatibility mouse events) to be retargeted to a particular element other than the normal hit test result of the pointer's location. This is useful in scenarios like a custom slider control (e.g. similar to the [HTML5] &lt;input type="range"&gt; control). Pointer capture can be set on the slider thumb element, allowing the user to slide the control back and forth even if the pointer slides off of the thumb.
</p>


<figure id="figure_slider">

<div style="margin: 0.5em;">
<span style="vertical-align:middle;">音量：</span>
<div style="vertical-align:middle;
	display:inline-block;
	position:relative;
	border:solid silver 0.2em;
	width:15em;"
><div style="position:absolute;
	left:8em;
	top:-0.8em;
	width:1em;
	height:1.6em;
	background: black;
"></div></div>
</div>

<!-- 
<img
	style="width:404px; height:40px;"
	src="pointerevents/slider.png"
	alt="Custom Volume Slider"
>
 -->
<figcaption>
~thumb要素を前後に~slideして値を選ぶような，~custom~slider~controlの例。
~thumb上で `pointerdown$et が生じたとき，~pointer捕捉を利用すれば、利用者は，~pointerが~sliderからそれても ~slideできるようになる。
◎
Example of a custom slider control that chooses a value by sliding the thumb element back and forth. After pointerdown on the thumb, pointer capture can be used to allow the user to slide the thumb even if the pointer drifts off of it.
</figcaption></figure>

		<section id="setting-pointer-capture">
<h3 title="Setting Pointer Capture">10.1. ~pointer捕捉の設定-法</h3>

<p>
要素による~pointer捕捉は、要素~上の `setPointerCapture(pointerId)$m ~methodにより設定される。
被呼出時には、次の手続きを走らせ~MUST：
◎
Pointer capture is set on an element by calling the element.setPointerCapture(pointerId) method. When this method is invoked, a user agent MUST run the following steps:
</p>

<ol>
	<li>
~IF［
%pointerId は、`作動中の$どの~pointerにも合致しない
］
⇒
~THROW `InvalidPointerId^E
◎
If the pointerId provided as the method's argument does not match any of the active pointers, then throw a DOMException with the name InvalidPointerId.
</li>
	<li>
~IF［
此れは`接続されて$いない `DOM4$r
］
⇒
~THROW `InvalidStateError^E
◎
If the Element on which this method is invoked is not connected ([DOM4]), throw an exception with the name InvalidStateError.
</li>
	<li>
~IF［
此れは~lockされている（ `PointerLock$r ）
］
⇒
~THROW `InvalidStateError^E
◎
If this method is invoked while the document has a locked element ([PointerLock]), throw an exception with the name InvalidStateError.
</li>
	<li>
%~pointer ~SET %pointerId に合致する`作動中の~pointer$
◎
↓</li>
	<li>
~IF［
%~pointer の~buttonは`作動状態$でない
］
⇒
~RET
◎
If the pointer is not in the active buttons state, then terminate these steps.
</li>
	<li>
%~pointer の`処理待ち捕捉標的$ ~SET 此れ
◎
For the specified pointerId, set the pending pointer capture target override to the Element on which this method was invoked.
</li>
</ol>

		</section>
		<section id="releasing-pointer-capture">
<h3 title="Releasing Pointer Capture">10.2. ~pointer捕捉の解放-法</h3>

<p>
要素による~pointer捕捉は、要素~上の `releasePointerCapture(pointerId)$m ~methodにより，明示的に解放できる。
被呼出時には、次の手続きを走らせ~MUST：
◎
Pointer capture is released on an element explicitly by calling the element.releasePointerCapture(pointerId) method. When this method is called, a user agent MUST run the following steps:
</p>

<ol>
	<li>
~IF［
%pointerId は、`作動中の$どの~pointerにも合致しない
<!-- ＊
］~AND［
この手続きは、
<a href="#implicit-release-of-pointer-capture">~pointer捕捉の暗黙的な解放-</a>
の結果として呼出されていない
 -->
］
⇒
~THROW `InvalidPointerId^E
◎
If the pointerId provided as the method's argument does not match any of the active pointers and these steps are not being invoked as a result of the implicit release of pointer capture, then throw a DOMException with the name InvalidPointerId.
</li>
	<li>
%~pointer ~SET %pointerId に合致する`作動中の~pointer$
◎
↑</li>
	<li>
~IF［
%~pointer の`処理待ち捕捉標的$ ~EQ 此れ
（すなわち，此れの `hasPointerCapture$m ~EQ ~T ）
］
⇒
%~pointer の`処理待ち捕捉標的$ ~SET ~NULL
◎
If hasPointerCapture is false for the Element with the specified pointerId, then terminate these steps.
◎
For the specified pointerId, clear the pending pointer capture target override, if set.
</li>
</ol>

		</section>
		<section id="implicit-pointer-capture">
<h3 title="Implicit Pointer Capture">10.3. 暗黙的な~pointer捕捉</h3>


<p>
一部の入力~装置（~touchscreenなど）は、
“直接~操作” の~metaphorを実装する 
— そこでの~pointerは、首に~UI要素~上で作動中になるように動作するものと意図される（ ~cursorを介して，~UI上を概念的に浮動する間接的な接触に代わって，物理的な直接~接触に錯覚させるような）。
そのような装置は、 `InputDeviceCapabilities.pointerMovementScrolls$m ~propにより識別され、次のような “暗黙的な~pointer捕捉” の挙動を備えるべきである。
◎
Some input devices (such as touchscreens) implement a "direct manipulation" metaphor where a pointer is intended to act primarily on the UI element it became active upon (providing a physical illusion of direct contact, instead of indirect contact via a cursor that conceptually floats above the UI). Such devices are identified by the InputDeviceCapabilities.pointerMovementScrolls property and should have "implicit pointer capture" behavior as follows.
</p>

<p>
直接~操作 装置は、正確に，［
`pointerdown^et 用の~listenerが呼出される直前に，標的~要素~上で `setPointerCapture()$m が~callされた
］かのように挙動するべきである。
これが生じたかどうかは、
`hasPointerCapture()$m ~APIを用いて決定できる（例えば `pointerdown^et ~listenerの中で）。
次の~pointer~eventが発火される前に，~pointerに対し `releasePointerCapture()$m が~callされなかった場合、 `gotpointercapture$et ~eventは，標的に（通常通り）配送されることになり、その捕捉が作動中であることを指示する。
◎
Direct manipulation devices should behave exactly as if setPointerCapture was called on the target element just before the invocation of any pointerdown listeners. The hasPointerCapture API may be used (eg. within any pointerdown listener) to determine whether this has occurred. If releasePointerCapture is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched to the target (as normal) indicating that capture is active.
</p>

<p class="note">注記：
これは， `PointerEvents$r からの~~非互換な変更であるが、既存の内容の大勢には~~影響しない。
この暗黙的な捕捉~用の設計は、代表的な~platform~UX慣行に合致することに加えて、開発者による明示的な~opt-inなしに，~UAによる［［
~touch移動による~eventに対し 接触判定を呼出す必要
］を防止するような，処理能の最適化
］を可能化する（既存の支配的な ~touch入力~用の，~native ／~web~APIの処理能~上の特質に整合する）。
◎
This is a breaking change from [[PointerEvents]], but does not impact the vast majority of existing content. In addition to matching typical platform UX conventions, this design for implicit capture enables user agents to make a performance optimization which prevents the need to invoke hit-testing on touch movement events without explicit developer opt-in (consistent with the performance properties of existing dominant native and web APIs for touch input).
</p>

<p class="note">注記：
加えて，~UAは、入力~範囲~controlなどの特定の~UI~widget上で，すべての入力~装置~用に暗黙的な~pointer捕捉の挙動を実装してよい（手指を動している間に ~form~controlの外側に それることも許容するような）。
◎
In addition, user agents may implement implicit pointer capture behavior for all input devices on specific UI widgets such as input range controls (allowing some finger movement to stray outside of the form control itself during the interaction).
</p>


		</section>
		<section id="implicit-release-of-pointer-capture">
<h3 title="Implicit Release of Pointer Capture">10.4. ~pointer捕捉の暗黙的な解放-</h3>

<div class="p">
<p class="algo-head">
~UAは、
`pointerup$et ／ `pointercancel$et
~eventを発火した直後に，次を走らせ~MUST：
</p>

<ol><li>%~pointer ~LET ~eventの `pointerId$m で識別される`作動中の~pointer$
</li><li>%~pointer の`処理待ち捕捉標的$ ~SET ~NULL
</li><li>`処理待ち~pointer捕捉を処理-$する手続きを走らす
</li></ol>

◎
Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending Pointer Capture steps to fire lostpointercapture if necessary.
</div>

<p>
`click$et ~eventの発火-を~supportする~UA（`互換性~mouse~event$を見よ）は、暗黙的な解放-時に
`click$et, `lostpointercapture$et
両~eventを発火するときは、 `click^et の方を先に発火するべきである。
◎
If the user agent supports firing the click event (see compatibility mouse events) and if in an implicit release scenario both click and lostpointercapture events are fired, click should be fired before lostpointercapture.
</p>


<div class="p">
<p class="algo-head">
`作動中の~pointer$ %~pointer の`捕捉標的$が`文書~内$から除去されたときは、次を走らせ~MUST：
</p>

<ol ><li>%~pointer の`処理待ち捕捉標的$ ~SET ~NULL
</li><li>%~pointer の`捕捉標的$ ~SET ~NULL
</li><li>文書に向けて，名前 `lostpointercapture$et の`~pointer~eventを発火-$する
</li></ol>
◎
When the pointer capture target override is removed from its ownerDocument's tree, clear the pending pointer capture target override and pointer capture target override nodes and fire a PointerEvent named lostpointercapture corresponding to the captured pointer at the document.
</div>

<p>
要素が ある~pointerの［
`捕捉標的$／`処理待ち捕捉標的$
］である間に，要素に~pointer~lock `PointerLock$r が成功裡に適用されたときも、~UAは，この手続きを走らせ~MUST。
<!-- ＊無為に惑わす記述 
as if the releasePointerCapture() method has been called 
-->
◎
When a pointer lock ([PointerLock]) is successfully applied on an element, a user agent MUST run the steps as if the releasePointerCapture() method has been called if any element is set to be captured or pending to be captured.
</p>

		</section>
	</section>
	<section id="compatibility-mapping-with-mouse-events">
<h2 title="Compatibility Mapping with Mouse Events">11. ~mouse~eventとの互換性のための対応付け</h2>

<p>
今日の~web内容では、`~mouse~event$向けのみに書かれている~codeが大勢を占めている。
~UAは、その種の内容との互換性を得るためとして，以下に与える~algoにより，汎用~pointer入力を~mouse~eventに対応付けて~MAY。
◎
The vast majority of web content existing today codes only to Mouse Events. The following describes an algorithm for how a user agent MAY map generic pointer input to mouse events for compatibility with this content.
</p>

<p>
互換性のための ~mouse~eventへの対応付けは、この仕様の任意選択の特色機能である。
~UAには、既存の旧来の内容との最良の互換性を得るために，この特色機能を~supportすることが奨励される。
`互換性~mouse~event$を~supportしない~UAにも、依然として
`click$et, `contextmenu$et
~eventは~supportすることが奨励される（下の注記を見よ）。
◎
The compatibility mapping with mouse events are an OPTIONAL feature of this specification. User agents are encouraged to support the feature for best compatibility with existing legacy content. User agents that do not support compatibility mouse events are still encouraged to support the click and contextmenu events (see the note below).
</p>


<div class="note">注記：
<p>
`click$et ~event `UIEVENTS$r,
`contextmenu$et ~event `HTML5$r
は、`互換性~mouse~event$とは見なされない。
それらは、概して~UIの作動化と束ねられており，~keyboardの様な他の入力~装置からも発火されるので。
◎
The click event, defined in [UIEVENTS], and the contextmenu event, defined in [HTML5], are not considered compatibility mouse events as they are typically tied to user interface activation and are fired from other input devices, like keyboards.
</p>

<p>
`click$et ／ `contextmenu$et
の発火を~supportする~UAにおいては、`~pointer~event$の間に `preventDefault()$m を呼んでも，概して
`click$et ／ `contextmenu$et
が発火されるかどうかには効果を持たない。
それらは`互換性~mouse~event$ではないので、~UAは概して，`首~pointer$でない~pointerも含め，すべての~pointing装置に対し
`click$et ／ `contextmenu$et
を発火する。
◎
In user agents that support firing click and/or contextmenu, calling preventDefault during a pointer event typically does not have an effect on whether click and/or contextmenu are fired or not. Because they are not compatibility mouse events, user agents typically fire click and contextmenu for all pointing devices, including pointers that are not primary pointers.
</p>

<p>
これらの高次の~event（
`click$et,
`contextmenu$et,
`focus$et,
`blur$et,
等々）と, `~pointer~event$との順序関係は、未定義であり，~UA間で様々になる。
例えば、
`pointerup$et, `contextmenu$et
の順に発火されることが多い~UAもあれば、その逆順になることが多い~UAもある。
また、対応する`~pointer~event$なしに発火される状況0もある（~keyboard~shortcutなど）。
◎
The relative ordering of these high-level events (click, contextmenu, focus, blur, etc.) with pointer events is undefined and varies between user agents. For example, in some user agents contextmenu will often follow a pointerup, in others it'll often precede a pointerup or pointercancel, and in some situations it may be fired without any corresponding pointer event (such as a keyboard shortcut).
</p>

</div>


<div class="p">
<p>
他に注記されない限り、対応付けられた`~mouse~event$は、次で与えられる標的に向けて発火されるべきである：
</p>

<ul>
	<li>
~mouse~eventを発火する時点で，`~pointer~event$の標的がまだ`文書~内$にあるならば、それと同じ標的。
</li>
	<li>
他の場合、［
`~pointer~event$を発火した時点で，その標的の先祖であった~nodeたち
］のうち，［
`~mouse~event$を発火する時点で`文書~内$にあるもの
］のうち，最も子孫の~node†。
特に、~mouse~eventの伝播~経路は，この先祖に基づく新たなものにされることになる。
</li>
</ul>

<p class="trans-note">【†
~event~handlerにより，~nodeたちが文書~内で他所に移動された場合、そのような子孫は一意に定まらなくなる場合もあり得るが、はっきりしない。
そのような子孫は除外されるべきようにも思われる。
また、標的が除去されず文書の他所へ移動された場合も，同様になるかもしれない。
】</p>

◎
Unless otherwise noted, the target of any mapped mouse event SHOULD be the same target as the respective pointer event unless the target is no longer participating in its ownerDocument's tree. In this case, the mouse event should be fired at the original target's nearest ancestor node (at the time it was removed from the tree) that still participates in its ownerDocument's tree, meaning that a new event path (based on the new target node) is built for the mouse event.
</div>

<p>
作者は、 `pointerdown$et ~eventを取消すことにより，一定の`互換性~mouse~event$の生産を防止できる。
◎
Authors can prevent the production of certain compatibility mouse events by canceling the pointerdown event.
</p>

<p class="note">注記：
~mouse~eventは、~pointerの~buttonが押されたときにのみ防止できる。
~hoverしている~pointer（例： どの~buttonも押されていない~mouse）による~mouse~eventは、防止できない。
加えて、［
`mouseover$et,
`mouseout$et,
`mouseenter$et,
`mouseleave$et
］~eventは，（~pointerの~buttonが押されていても）決して防止されない。
◎
Mouse events can only be prevented when the pointer is down. Hovering pointers (e.g. a mouse with no buttons pressed) cannot have their mouse events prevented. And, the mouseover, mouseout, mouseenter, and mouseleave events are never prevented (even if the pointer is down).
</p>

		<section id="tracking-the-effective-position-of-the-legacy-mouse-pointer">
<h3 title="Tracking the effective position of the legacy mouse pointer">11.1. 旧来の~mouse~pointerに対する位置の追跡-法</h3>

<p>
`互換性~mouse~event$を生産し得るのは`首~pointer$に限られるが、
<a href="#multiple-primary-pointers">複数の首~pointer</a>が
— 各自が自前の`互換性~mouse~event$を生産するように —
同時に作動中になり得る。
これらすべての互換性~eventは、 `MouseEvent^I ~codeにとっては，単独の~mouse装置から生じたかのように現れるので、~UAには，［
`互換性~mouse~event$が単独の装置~視点で整合するように現れる
］ことを保証することが奨励される。
~mouse遷移~event（すなわち，
`mouseover$et ／ `mouseout$et ／ `mouseenter$et ／ `mouseleave$et
）に対しては、このことは，どの~event標的に対しても［
~mouseの出入り状態が， `UIEVENTS$r から課されるものに関して妥当になる
］ことを意味する。
~UAは、文書~内の
`旧来の~mouse~pointerの実効~位置@
を，次に従って保守することにより，これを保証する~SHOULDである。
◎
While only the primary pointers can produce compatibility mouse events, multiple primary pointers can be active simultaneously, each producing its own compatibility mouse events. Since all these compatibility events would appear to MouseEvent code to be coming from a single mouse device, user agents are encouraged to guarantee that the compatibility mouse events are consistent from a single device perspective. For mouse transition events (i.e., mouseover, mouseout, mouseenter and mouseleave), this means the entry/exit state for every event target is valid as implied by [UIEVENTS]. Users agents SHOULD guarantee this by maintaining the effective position of the legacy mouse pointer in the document as follows.
</p>

<p class="trans-note">【
例えば、同じ要素に向けて `mouseenter^et が（ `mouseleave^et を挟まずに）続けて発火されないようにするなど。
】</p>

<p>
~UAは、［
`pointerdown$et ／ `pointerup$et ／ `pointermove$et
］~eventを発火するとき, あるいは［
`~Window$に向けて `pointerleave$et
］~eventを発火するときは、その~event %event を発火する直前に，次の手続きを走らす~SHOULDである：
◎
Right before firing a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, the user agent SHOULD run the following steps:
</p>

<ol>
	<li>
%旧~位置 ~LET 現在の`旧来の~mouse~pointerの実効~位置$
◎
↓</li>
	<li>
%新~位置 ~LET ［
%event が `pointerleave$et ならば `域外^i ／
~ELSE_ %event の標的
］
◎
Let T be the target of the pointerdown, pointerup or pointermove event being dispatched. For the pointerleave event, unset T.
</li>
	<li>
~IF［
%新~位置 ~EQ %旧~位置
］
⇒
~RET
◎
If T and current effective legacy mouse pointer position are both unset or they are uqual, terminate these steps.
</li>
	<li>
`UIEVENTS$r に従って、［
~mouseが %旧~位置 から %新~位置 へ移動した
］ものと見なした下で［
`mouseover$et ／
`mouseout$et ／
`mouseenter$et ／
`mouseleave$et
］~eventを発火する
— ここでの［
%旧~位置 ／ %新~位置
］に対する値 `域外^i は、~mouse位置が~window外にあると見なす
◎
Dispatch mouseover, mouseout, mouseenter and mouseleave events as per [UIEVENTS] for a mouse moving from the current effective legacy mouse pointer position to T. Consider an unset value of either current effective legacy mouse pointer position or T as an out-of-window mouse position.
</li>
	<li>
`旧来の~mouse~pointerの実効~位置$ ~SET %新~位置
◎
Set effective legacy mouse pointer position to T.
</li>
</ol>

		</section>
		<section id="mapping-for-devices-that-support-hover">
<h3 title="Mapping for devices that support hover">11.2. ~hoverを~supportする装置に対する対応付け</h3>

<p>
~UAは、~hoverを~supportする装置による`~pointer~event$ %event を配送するときは，次の手続きを走らす~SHOULDである：
◎
Whenever a user agent is to dispatch a pointer event for a device that supports hover, it SHOULD run the following steps:
</p>

<ol>
	<li>
~IF［
%event の `isPrimary$m 属性 ~EQ ~F
］
⇒＃
%event を配送する；
~RET
◎
If the isPrimary property for the pointer event to be dispatched is false then dispatch the pointer event and terminate these steps.
</li>
	<li>
~IF［
%event の型 ~IN
{ `pointerdown$et, `pointerup$et, `pointermove$et }
］~OR［［
%event の型 ~EQ `pointerleave$et
］~AND［
%event の標的は`~Window$である
］］
⇒
`旧来の~mouse~pointerに対する位置の追跡-法$に従って，互換性~mouse遷移~eventを配送する
◎
If the pointer event to be is dispatched is a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, dispatch compatibility mouse transition events as described in Tracking the effective position of the legacy mouse pointer.
</li>
	<li>
%event を`互換性~mouse~eventも込みで配送する$
◎
↓</li>
</ol>

<p class="algo-head">
`~pointer~event$ %event を
`互換性~mouse~eventも込みで配送する@
ときは、次を走らす：
◎
↓</p>

<ol>
	<li>
%event を配送する
◎
Dispatch the pointer event.
</li>

	<li>
%装置~型 ~LET %event の `pointerType$m
</li>
	<li>
~IF［
%event の型 ~EQ `pointerdown$et
］~AND［
%event は`取消された$
］
⇒
%装置~型 に対する`~mouse~event防止~flag$ ~SET ~ON
◎
If the pointer event dispatched was pointerdown and the event was canceled, then set the PREVENT MOUSE EVENT flag for this pointerType.
</li>
	<li>
<p>
~IF［
%装置~型 に対する`~mouse~event防止~flag$ ~EQ ~OFF
］
⇒
%event の型に応じて，次の表の 2 列目に与える型の~mouse~eventを，3 列目に与える標的に向けて発火する：
</p>

<table>
<thead><tr><th>%event の型
<th>~mouse~event型
<th>標的
</thead>

<tbody><tr><td>`pointerdown$et
<td>`mousedown$et
<td>%event の標的

<tr><td>`pointermove$et
<td>`mousemove$et
<td>%event の標的

<tr><td>`pointerup$et
<td>`mouseup$et
<td>%event の標的

<tr><td>`pointercancel$et
<td>`mousecancel$et
<td>`~Window$

</tbody></table>

◎
If the PREVENT MOUSE EVENT flag is not set for this pointerType and the pointer event dispatched was:
◎
pointerdown, then fire a mousedown event.
◎
pointermove, then fire a mousemove event.
◎
pointerup, then fire a mouseup event.
◎
pointercancel, then fire a mouseup event at the window.
</li>
	<li>
~IF［
%event の型 ~IN { `pointerup$et, `pointercancel$et }
］
⇒
%装置~型 に対する`~mouse~event防止~flag$ ~SET ~OFF
◎
If the pointer event dispatched was pointerup or pointercancel, clear the PREVENT MOUSE EVENT flag for this pointerType.
</li>
</ol>


		</section>
		<section id="mapping-for-devices-that-do-not-support-hover">
<h3 title="Mapping for devices that do not support hover">11.3. ~hoverを~supportしない装置~用の対応付け</h3>

<p>
ほとんどの~touchscreenなど、`作動中$でない間は，座標（または座標の集合）に対する~hoverを~supportしない装置もある。
~mouse~event向けに書かれている既存の多数の~codeは、~eventが~mouseにより生産されていて，次の~~性質が一般に成り立つものと見做している：
◎
Some devices, such as most touchscreens, do not support hovering a coordinate (or set of coordinates) while not in the active state. Much existing content coded to mouse events assumes that a mouse is producing the events and thus certain qualities are generally true:
</p>

<ul>
	<li>
入力は、作動化と独立に~hoverできる（例：どの~buttonも押さないまま~mouse~cursorを動かす）。
◎
The input can hover independently of activation (e.g. moving a mouse cursor without any buttons pressed).
</li>
	<li>
入力は、要素が~clickされる前に `mousemove$et ~eventを生産する見込みが高い。
◎
The input will likely produce the mousemove event on an element before clicking it.
</li>
</ul>

<p class="note">注記：
~hoverは、~mouse向けに設計された内容にて，~UI要素の可視性を切り替えるために利用されることもある（例： “~hover~menu” ）。
そのような内容は、`~hoverを~supportしない$装置と互換にならないことが多い。
この仕様は、この局面における互換性のための対応付けや挙動は定義しない。
それは、将来~versionの仕様にて考慮されることになる。
◎
Hover is sometimes used to toggle the visibility of UI elements in content designed for mouse (e.g. "hover menus"). This content is often incompatible with devices that do not support hover. This specification does not define a mapping or behavior for compatibility with this scenario. It will be considered in a future version of the specification.
</p>

<p class="algo-head">
このことから、~UAには，これらの型の入力~装置に対しては，異なる対応付けを供することが要求される。
~UAは、所与の %標的 に向けて［
`~hoverを~supportしない$装置による`~pointer~event$
］ %event を配送するときは，次の手続きを走らす~SHOULDである：
◎
This requires that user agents provide a different mapping for these types of input devices. Whenever a user agent is to dispatch a pointer event for a device that does not support hover, it SHOULD run the following steps:
</p>

<ol>
	<li>
~IF［
%event の `isPrimary$m 属性 ~EQ ~F
］
⇒＃
%event を配送する；
~RET
◎
If the isPrimary property for the pointer event to be dispatched is false then dispatch the pointer event and terminate these steps.
</li>
	<li>
%~pointer ~LET %event を生じさせた~pointer
</li>
	<li>
~IF［
%event の型 ~EQ `pointerover$et
］~AND［
%~pointer による `pointerdown$et ~eventはまだ生じていない
］
⇒
`mousemove$et ~eventを発火する（旧来の~mouse向け~codeとの互換性をとるために）
◎
If the pointer event to be dispatched is pointerover and the pointerdown event has not yet been dispatched for this pointer, then fire a mousemove event (for compatibility with legacy mouse-specific code).
</li>
	<li>
~IF［
%event の型 ~IN
{ `pointerdown$et, `pointerup$et, `pointermove$et }
］~OR［［
%event の型 ~EQ `pointerleave$et
］~AND［
%event の標的は`~Window$である
］］
⇒
`旧来の~mouse~pointerに対する位置の追跡-法$に従って，互換性~mouse遷移~eventを配送する
◎
If the pointer event to be is dispatched is a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, dispatch compatibility mouse transition events as described in Tracking the effective position of the legacy mouse pointer.
</li>
	<li>
%event を，`互換性~mouse~eventも込みで配送する$
◎
Dispatch the pointer event.
◎
If the pointer event dispatched was pointerdown and the event was canceled, then set the PREVENT MOUSE EVENT flag for this pointerType.
◎
If the PREVENT MOUSE EVENT flag is not set for this pointerType and the pointer event dispatched was:
◎
pointerdown, then fire a mousedown event.
◎
pointermove, then fire a mousemove event.
◎
pointerup, then fire a mouseup event.
◎
pointercancel, then fire a mouseup event at the window.
◎
If the pointer event dispatched was pointerup or pointercancel, clear the PREVENT MOUSE EVENT flag for this pointerType.
</li>
</ol>


<p class="note">注記：
`~pointer~event$と
`TOUCH-EVENTS$r に定義される~touch~eventの両者とも~supportする~UAは、この節に述べた`互換性~mouse~event$を生成するべきでない
— そうすると、［
`TOUCH-EVENTS$r にて
<a href="~TOUCHEVENTS#mouse-events">要旨されている~model</a>
に則って，~mouse~eventが生成される
］ことを期待している~siteに，互換性の問題をもたらす見込みが高いので。
◎
If the user agent supports both Touch Events (as defined in [TOUCH-EVENTS]) and Pointer Events, the user agent SHOULD NOT generate compatibility mouse events as described in this section as it is likely to introduce compatibility problems for sites that expect mouse events to be generated in accordance with the model outlined in [TOUCH-EVENTS].
</p>

<div class="note">
<p>注記：
`~hoverを~supportしない$ `首~pointer$による要素の作動化（ `click$et ）
（例： ~touchscreen上の単独の手指）は、概して，次の`~event連列$を生産することになる：
◎
The activation of an element (click) with a primary pointer that does not support hover (e.g. single finger on a touchscreen) would typically produce the following event sequence:
</p>

<ol ><li>`mousemove$et
</li><li>`pointerover$et
</li><li>`pointerenter$et
</li><li>`mouseover$et
</li><li>`mouseenter$et
</li><li>`pointerdown$et †
</li><li>`mousedown$et
</li><li>~pointerの動きに依存して， 0 回以上の［
`pointermove$et ／ `mousemove$et
］~event
◎
Zero or more pointermove and mousemove events, depending on movement of the pointer

</li><li>`pointerup$et
</li><li>`mouseup$et
</li><li>`click$et
</li><li>`pointerout$et
</li><li>`pointerleave$et
</li><li>`mouseout$et
</li><li>`mouseleave$et
</li></ol>

<p>†
ただし、この操作iの間に `pointerdown$et ~eventが取消された場合の`~event連列$は、上の連列から［
`mousedown$et, `mousemove$et, `mouseup$et
］を除いたものになる。

◎
If, however, the pointerdown event is canceled during this interaction then the sequence of events would be:

mousemove
pointerover
pointerenter
mouseover
mouseenter
pointerdown
Zero or more pointermove events, depending on movement of the pointer
pointerup
click
pointerout
pointerleave
mouseout
mouseleave
</p>

</div>


		</section>
	</section>
	<section id="security-and-privacy-considerations">
<h2 title="Security and privacy considerations">12. ~securityと~privacy上の考慮点</h2>

<p>
この付録では、 Pointer Events 実装における~securityと~privacy上の考慮点について論じる。
論点は、この仕様に定義される［
~event~model, ~API, ~event
］の実装から直に発生する
~security／~privacy
上の課題に限られる。
◎
This appendix discusses security and privacy considerations for Pointer Events implementations. The discussion is limited to security and privacy issues that arise directly from implementation of the event model, APIs and events defined in this specification.
</p>

<p>
この仕様に定義される~event型の多くは、利用者の動作に呼応して配送される。
これは、悪意的な~event~listenerが［
概して，利用者が機密的と考える情報
］
— 例：利用者が頁と対話している間の［
~mouse／~stylus／手指
］の正確な経路や動きなど —
への~accessを得られるようにする。
◎
Many of the event types defined in this specification are dispatched in response to user actions. This allows malicious event listeners to gain access to information users would typically consider confidential, e.g., the exact path/movement of a user's mouse/stylus/finger while interacting with a page.
</p>

<p>
~pointer~eventは、追加の情報を（利用者の装置が~supportする所で）包含する
— ~pen入力に保持されている角度や傾き／
接触~物理的面の幾何／
~stylusや~touch~screen上に~~感知された押圧
など。
［
角度, 傾き, 幾何, 押圧
］の情報は、利用者~機器の~sensorに直に関係する。
すなわち、この仕様は，そのような~sensorへの~accessを生成元に許容する。
◎
Pointer events contain additional information (where supported by the user's device), such as the angle or tilt at which a pen input is held, the geometry of the contact surface, and the pressure exerted on the stylus or touch screen. Information about angle, tilt, geometry and pressure are directly related to sensors on the user's device, meaning that this specification allows an origin access to these sensors.
</p>

<p>
この~sensor~dataは、［
どの型の仕組み（~mouse, ~touch, ~pen, 等）が入力に利用されているか
］を決定する能とともに，［
利用者, あるいは利用者の装置や環境
］についての特徴を推定するために利用され得る。
この情報はまた、特定0の利用者を追跡しようと試みるために［
利用者~profileを築く, あるいは “指紋収集する”
］目的にも利用され得る。
◎
This sensor data, as well as the ability to determine the type of input mechanism (mouse, touch, pen) used, may be used to infer characteristics of a user, or of the user's device and environment. This information can also be potentially used for the purposes of building a user profile and/or attempting to "fingerprint" and track a particular user.
</p>

<p>
当 working group は、上述を超えるような考慮点は，この仕様には無いものと予見している：
◎
Beyond these considerations, the working group believes that this specification:
</p>

<ul>
	<li>
個人識別可能な情報は、公開しない。
◎
Does not expose personally-identifiable information.
</li>
	<li>
高価値な~dataは、扱わない。
◎
Does not deal with high-value data.
</li>
	<li>
複数の閲覧~sessionに持続するような，生成元~用の新たな状態は、導入しない。
◎
Does not introduce new state for an origin that persists across browsing sessions.
</li>
	<li>
異なる生成元にわたって持続するような状態は、~webに公開しない。
◎
Does not expose persistent, cross-origin state to the web.
</li>
	<li>
現在~accessできない他のどのような~dataも、生成元に公開しない。
◎
Does not expose any other data to an origin that it doesn’t currently have access to.
</li>
	<li>
~scriptを［
実行する／読込む
］ような新たな仕組みは、可能化しない。
◎
Does not enable new script execution/loading mechanisms.
</li>
	<li>
利用者の所在への~accessは、生成元に許容しない。
◎
Does not allow an origin access to a user’s location.
</li>
	<li>
~UAが “私的閲覧” ~mode下にあるときの特別な取扱いは、要求しない。
◎
Does not require any special handling when the user agent is in "incognito" mode.
</li>
	<li>
他の装置への~accessは、生成元に許容しない。
◎
Does not allow an origin access to other devices.
</li>
	<li>
~UAに~nativeな~UI越しの制御は、生成元に許容しない。
◎
Does not allow an origin control over a user agent’s native UI.
</li>
	<li>
一時的な識別子は、~webに公開しない。
◎
Does not expose temporary identifiers to the web.
</li>
	<li>
挙動が［
当事者主体, 第三者主体
］どちらの文脈におけるものかは、判別しない。
◎
Does not distinguish between behavior in first-party and third-party contexts.
</li>
	<li>
利用者に局所的な装置には、~dataを持続しない。
◎
Does not persist data to a user’s local device.
</li>
	<li>
既定の~security特徴へ降格することは、許容しない。
◎
Does not allow downgrading default security characteristics.
</li>
</ul>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
たくさんの方々からの提案や助言に感謝する。
それらの一部は、この文書に組入れられている。
次に挙げる，~~現在／~~過去の~group~memberの方々による貢献にも：
◎
Many thanks to lots of people for their proposals and recommendations, some of which are incorporated into this document. The group's Chair acknowledges contributions from the following past and present group members and participants: 
</p>

<p lang="en-x-a0">
Mustaq Ahmed,
Arthur Barstow,
Matt Brubeck,
Rick Byers,
Cathy Chan,
Ted Dinklocker,
Dave Fleck,
Ella Ge,
Scott González,
Philippe Le Hégaret,
Hayato Ito,
Patrick Kettner,
Patrick H. Lauke,
Scott Low,
Sangwhan Moon,
Olli Pettay,
Jacob Rossi,
Doug Schepers,
Ming-Chou Shih,
Brenton Simpson,
Dave Tapuska,
Asir Vedamuthu,
Lan Wei,
Navid Zolghadr
</p>

<p>
この~modelの最初の版のために先駆的な仕事をされた方々にも特別な謝意を
— とりわけ次の方々に：
</p>

<p lang="en-x-a0">
Special thanks to those that helped pioneer the first edition of this model, including especially: Charu Chandiram, Peter Freiling, Nathan Furtwangler, Thomas Olsen, Matt Rakow, Ramu Ramanathan, Justin Rogers, Jacob Rossi, Reed Townsend and Steve Wright.
</p>

	</section>
	<section id="revision-history">
<h2 title="Revision History">改訂~履歴</h2>

~INFORMATIVE

<p>
最初の `PointerEvents$r 仕様からの，~~主要な, および編集上の~~主な変更点（参考）を以下に要約する（この仕様の編集者草案の
<a href="https://github.com/w3c/pointerevents/commits">完全な改訂~履歴</a>
）。
◎
The following is an informative summary of substantial and major editorial changes between publications of this specification, relative to the first [PointerEvents] specification. See the complete revision history of the Editor's Drafts of this specification.
</p>


<h4 title="Changes since the 24 February 2015 Recommendation">2015 年 2 月 24 日付 勧告からの変更点</h4>

<ul>
	<li>
注釈文における `DOM4$r の `ownerDocument^m 木【`文書~内$】の概念を
`接続されて$いる／いない
に置換した。【全部ではない】
`246$pull
◎
Replace prose about ownerDocument tree with DOM4 concept of connected
</li>
	<li>
~securityと~privacy上の考慮点
節を追加した
`235$pull
</li>
	<li>
旧来の属性 `fromElement^m, `toElement^m （ `MouseEvent$I から継承される）は、
~NULL を返さ~MUSTことについての注記を追加した。
`234$pull：
◎
Added note about legacy attributes fromElement and toElement (inherited from MouseEvents) must be null
</li>
	<li>
`218$pull：
構築子に [Exposed=Window] を追加した。
◎
Add [Exposed=Window] to Constructor
</li>
	<li>
`138$pull：
捕捉の間に境界~eventを送信しないようにした。
◎
Don't send boundary events during capture
</li>
	<li>
`129$pull：
直接~操作~pointing装置に対する暗黙的な捕捉。
◎
Implicit capture for direct manipulation pointing devices
</li>
	<li>
`122$pull：
`~pointer捕捉$が暗黙的に解放された場合を除き、~pointer捕捉~処理は遅延される~modelに従うようにした。
◎
Add pointer capture processing follow delayed model except implicit release and set the pointer capture events attributes
</li>
	<li>
`127$pull：
`hasPointerCapture()$m を追加した。
◎
Add hasPointerCapture
</li>
	<li>
`96$pull：
`button^m ／ `buttons^m
から “~pen接触” 条件を除去した。
◎
Removed "pen contact" condition on button/buttons
</li>
	<li>
`92$pull：
すべての~pointer~eventを~composed~eventにした。
◎
Make all pointer events composed events
</li>
	<li>
`87$pull：
~digitizer／~pen による接線方向（~barrel）圧を追加した。
◎
Add digitizer/pen tangential (barrel) pressure
</li>
	<li>
`79$pull：
~digitizer／~penの~twistを追加。
◎
Add digitizer/pen twist
</li>
	<li>
`69$pull：
`width$m ／ `height$m の既定を 1 にした上で、~UAによる幾何の “~~推測／~~偽造” を除去した。
◎
Make width/height default to 1, remove UA "guessing"/faking geometry
</li>
	<li>
`56$pull：
`mouseover$et／ `mouseout$et／ `mouseenter$et／ `mouseleave$et
~eventは，対応する~pointer~eventとは独立に発火されるようにした。
◎
Made mouseover/out/enter/leave event firing independent of corresponding PEs
</li>
	<li>
`53$pull：
`首~pointer$節を，言い回しを単純化した上で、複数の~mouse入力~装置の可能性を許容した。
◎
Rewrite of primary pointer section to simplify the wording and allow for possibility of multiple mouse input devices
</li>
	<li>
`50$pull：
`首~pointer$が除去された場合についての~~言及。
◎
Cover the case when primary pointer is removed
</li>
	<li>
`43$pull：
`touch-action$p の動的な変化について明確化した。
◎
Clarification about dynamic touch-action changes
</li>
	<li>
`36$pull：
`処理待ち~pointer捕捉を処理-$する際の，抜けていた
`pointerover$et／`pointerenter$et
~eventを追加した。
◎
Add the missing pointerover/enter events to the "Process Pending Pointer Capture" section
</li>
	<li>
`34$pull：
~mouse~drag用に~button値を明確化した。
◎
Clarify the button value for mouse drag
</li>
	<li>
`24$pull：
~zoomにおける `touch-action$p の処理~modelを修正した。
◎
Fix the touch-action processing model for zoom scenarios
</li>
</ul>

	</section>

</main></div><!-- MAIN -->
