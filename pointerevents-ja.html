<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Pointer Events — Level 2 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />

<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	let current_ifc = '';

	return this.html.replace(
		/%[\w\-~一-鿆]+|`(.*?)([$@!\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let text = key;
let href = '';

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'I':
	if((indicator === '@') || (indicator === '!')){
		current_ifc = `#dom-${key.toLowerCase()}-`;
	}
	break;
case 'm' : // interface member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = current_ifc + key.toLowerCase();
	break;
case 'l':
	return `"<code class="literal">${key}</code>"`;
	break;
case 'v': // CSS touch-action 値
	href = `#valdef-touch-action-${key}`;
	break;
case 'ex':
	href = `#example_${key}`;
	text = `例 ${key}`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'pull': // pull req
	text = `(#${key})`;
	href = `~POINTEREVENTS_pull/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>



<script type="text/plain" id="_source_data">


●●options
spec_title:Pointer Events
spec_date:2019-04-04
trans_update:2022-03-22
source_checked:161118
page_state_key:UIEVENTS
original_url:https://www.w3.org/TR/pointerevents2/
	original_url:https://w3c.github.io/pointerevents/
	abbr_url:POINTEREVENTS
spec_status:REC
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2019,permissive
trans_1st_pub:2015-10-08


●●class_map
E:error
et:event-type
e:element
p:css
v:value

●●tag_map
c:code
I:code
E:code
m:code
et:code
e:code
p:code
v:code
i:i
em:em

●●original_id_map


	implicit-pointer-capture:dfn-implicit-pointer-capture

	tracking-the-effective-position-of-the-legacy-mouse-pointer:dfn-tracking-the-effective-position-of-the-legacy-mouse-pointer

propdef-touch-action:dfn-touch-action
valdef-touch-action-auto:
valdef-touch-action-none:
valdef-touch-action-pan-x:
valdef-touch-action-pan-y:
valdef-touch-action-manipulation:

	●二重 id
	the-pointerover-event:dfn-pointerover
	the-pointerenter-event:dfn-pointerenter
	the-pointerdown-event:dfn-pointerdown
	the-pointermove-event:dfn-pointermove
	the-pointerup-event:dfn-pointerup
	the-pointercancel-event:dfn-pointercancel
	the-pointerout-event:dfn-pointerout
	the-pointerleave-event:dfn-pointerleave
	the-gotpointercapture-event:dfn-gotpointercapture
	the-lostpointercapture-event:dfn-lostpointercapture
	pointer-capture:dfn-pointer-capture
	compatibility-mapping-with-mouse-events:dfn-compatibility-mouse-events
		the-primary-pointer:dfn-primary-pointer

●●mdn_urls
propdef-touch-action:CSS/touch-action

idl-def-pointerevent:API/PointerEvent
	idl-def-pointereventinit:API/PointerEventInit

the-gotpointercapture-event:API/HTMLElement/gotpointercapture_event
the-lostpointercapture-event:API/HTMLElement/lostpointercapture_event
the-pointercancel-event:API/HTMLElement/pointercancel_event
the-pointerdown-event:API/HTMLElement/pointerdown_event
the-pointerenter-event:API/HTMLElement/pointerenter_event
the-pointerleave-event:API/HTMLElement/pointerleave_event
the-pointermove-event:API/HTMLElement/pointermove_event
the-pointerout-event:API/HTMLElement/pointerout_event
the-pointerover-event:API/HTMLElement/pointerover_event
the-pointerup-event:API/HTMLElement/pointerup_event
	the-pointerrawupdate-event:Events/pointerrawupdate

●●link_map



Exposed:~WEBIDLjs#Exposed
I.Element:~DOM4#element
	#dom-element
I.MouseEvent:~UIEVENTS#interface-mouseevent
I.MouseEventInit:~UIEVENTS#dictdef-mouseeventinit
I.GlobalEventHandlers:~WAPI#globaleventhandlers
	#dom-globaleventhandlers
I.Navigator:~HTMLnavigator#navigator
	#dom-navigator
I.PointerEventInit:#idl-def-pointereventinit
	#dom-pointereventinit
I.PointerEvent:#idl-def-pointerevent
	#dom-pointerevent

m.target:~DOM4#dom-event-target
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.composed:~DOM4#dom-event-composed
m.isTrusted:~DOM4#dom-event-istrusted
m.preventDefault:~DOM4#dom-event-preventdefault

m.setPointerCapture:#dom-element-setpointercapture
m.releasePointerCapture:#dom-element-releasepointercapture
m.hasPointerCapture:#dom-element-haspointercapture

m.maxTouchPoints:#dom-navigator-maxtouchpoints

m.relatedTarget:~UIEVENTS#dom-mouseevent-relatedtarget
m.button:~UIEVENTS#dom-mouseevent-button
m.buttons:~UIEVENTS#dom-mouseevent-buttons
m.detail:~UIEVENTS#dom-uievent-detail

	m.isPrimary:#dom-pointerevent-isprimary
	m.pointerType:#dom-pointerevent-pointertype
	m.pointerId:#dom-pointerevent-pointerid
	m.ownerDocument:~DOM4#dom-Node-ownerDocument

m.InputDeviceCapabilities.pointerMovementScrolls:https://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-pointermovementscrolls

m.screenY:~CSSOMVIEW#dom-mouseevent-screeny
m.screenX:~CSSOMVIEW#dom-mouseevent-screenx

et.contextmenu:~UIEVENTS#event-type-contextmenu
et.click:~UIEVENTS#event-type-click
et.dblclick:~UIEVENTS#event-type-dblclick
et.focus:~UIEVENTS#event-type-focus
et.blur:~UIEVENTS#event-type-blur
et.dragstart:~HTMLdnd#event-dnd-dragstart

et.mousedown:~UIEVENTS#event-type-mousedown
et.mouseup:~UIEVENTS#event-type-mouseup
et.mouseover:~UIEVENTS#event-type-mouseover
et.mouseout:~UIEVENTS#event-type-mouseout
et.mouseenter:~UIEVENTS#event-type-mouseenter
et.mouseleave:~UIEVENTS#event-type-mouseleave
et.mousemove:~UIEVENTS#event-type-mousemove

et.pointerover:#the-pointerover-event
	#dfn-pointerover-event
et.pointerenter:#the-pointerenter-event
	#dfn-pointerenter-event
et.pointerdown:#the-pointerdown-event
	#dfn-pointerdown-event
et.pointermove:#the-pointermove-event
	#dfn-pointermove-event
et.pointerup:#the-pointerup-event
	#dfn-pointerup-event
et.pointercancel:#the-pointercancel-event
	#dfn-pointercancel-event
et.pointerout:#the-pointerout-event
	#dfn-pointerout-event
et.pointerleave:#the-pointerleave-event
	#dfn-pointerleave-event
et.gotpointercapture:#the-gotpointercapture-event
	#dfn-gotpointercapture-event
et.lostpointercapture:#the-lostpointercapture-event
	#dfn-lostpointercapture-event

p.touch-action:#propdef-touch-action
p.display:~CSSDISP#propdef-display
p.width:~CSS2VISUDET#propdef-width
p.height:~CSS2VISUDET#propdef-height


作動~状態:#dfn-active-buttons-state
作動中の~pointer:#dfn-active-pointer
作動中の:#dfn-active-pointer
作動中:#dfn-active-pointer

取消された:#dfn-canceled-event
接触~幾何:#dfn-contact-geometry
~digitizer:#dfn-digitizer
接触判定:#dfn-hit-test
~pointer:#dfn-pointer
~pointing先:#_pointing
~pointer型:#dom-pointerevent-pointertype
捕捉~込みの~pointing先:#_pointing-with-capture
境界~event:#_boundary-event

~UA:#dfn-user-agent
~taskを~queueする:#dfn-queue-a-task
~mouse~event:#_mouse-event
~pointer~event:#_pointer-event
~buttonの追加押下げ:#dfn-chorded-buttons
追加押下げ:#dfn-chorded-buttons
	#chorded-button-interactions

首~pointer:#dfn-primary-pointer
~pointer~eventを発火する:#dfn-fire-a-pointer-event-name-e
~pointer~eventを発火-:#dfn-fire-a-pointer-event-name-e

発火-:#dfn-fire-an-event-named-e
~eventを発火する:~DOM4#concept-event-fire
	#dfn-fire-an-event-named-e
	~eventを発火-
~eventを作成する:~DOM4#concept-event-create
~eventを配送する:~DOM4#concept-event-dispatch
~pointer捕捉:#pointer-capture
捕捉:#pointer-capture
明示的に解放-:#releasing-pointer-capture
~pointer捕捉の解放-法:#releasing-pointer-capture
設定-:#setting-pointer-capture
~pointer捕捉の設定-法:#setting-pointer-capture

	Pointer Capture:#dfn-pointer-capture
捕捉標的:#dfn-pointer-capture-target-override
処理待ち捕捉標的:#dfn-pending-pointer-capture-target-override
互換性~mouse~event:#compatibility-mapping-with-mouse-events
	#dfn-compatibility-mouse-events＊原文リンク先未定義
旧来の~mouse~pointerの実効~位置:#dfn-effective-position-of-the-legacy-mouse-pointer

~hoverを~supportしない:#mapping-for-devices-that-do-not-support-hover
~pointer捕捉の暗黙的な解放-:#implicit-release-of-pointer-capture
暗黙的に解放-:#implicit-release-of-pointer-capture
処理待ち~pointer捕捉を処理-:#process-pending-pointer-capture

暗黙的な~pointer捕捉:#implicit-pointer-capture

旧来の~mouse~pointerに対する位置の追跡-法:#tracking-the-effective-position-of-the-legacy-mouse-pointer

適合する:#dfn-conforming-touch-behavior

	§各種 属性と既定~動作:#attributes-and-default-actions
	§各種 ~pointer~event型:#pointer-event-types
	§~pointer捕捉の設定-法:#setting-pointer-capture
	§~pointer捕捉の解放-法:#releasing-pointer-capture
	§処理待ち~pointer捕捉を処理-:#process-pending-pointer-capture
	§~pointer捕捉の暗黙的な解放-:#implicit-release-of-pointer-capture
	§`touch-action^p 値:#details-of-touch-action-values
	§首~pointer:#dfn-primary-pointer


	●補完
互換性~mouse~eventも込みで配送する:#_fire-compatibility-mouse-events
~mouse~eventは防止するか:#_prevent-mouse-event-flag
	既定の~touch挙動:#_default-touch-behavior
~touch用の既定の挙動:#_default-touch-behavior

置換され:~CSSDISP#replaced-element
行内~要素:~CSSDISP#inline

接続されて:~DOM4#connected
文書~内:~DOM4#in-a-document
	~node文書

~trusted:~UIEVENTS#trusted-events
非trusted:~UIEVENTS#trusted-events
同期的:~UIEVENTS#sync-async
浮上-:~UIEVENTS#bubble-phase
伝播~経路:~UIEVENTS#propagation-path
取消~可:~UIEVENTS#_cancelable
	＊
既定~動作:~UIEVENTS#default-action
	作動化の挙動:~UIEVENTS#activation-behavior
~event連列:#_event-sequence

~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~Window:~UIEVENTS#window

~top-level閲覧~文脈:~BROWSERS#top-level-browsing-context
	https://www.w3.org/TR/html/browsers.html#〜
~drag操作oが開始され:~HTMLdnd#initiate-the-drag-and-drop-operation


●●words_table1


TOUCHEVENTS:touch-events-ja.html
	~TR/touch-events/
COMPAT:compat-ja.html
public_pointer_events:https://lists.w3.org/Archives/Public/public-pointer-events
POINTEREVENTS_pull:https://github.com/w3c/pointerevents/pull

hover_ps:<code class="pseudo">:hover</code>


●●words_table




	●UI
UX:
利用者体験:experience:~
様式:modalities:方式
	~overscroll
	~pull-to-refresh
pointing::::ポインタ指示
metaphor::::メタファー
affordances::::アフォーダンス
shortcut::::ショートカット
	x1
	x2
drag::::ドラッグ
cursor::::カーソル
gesture::::ジェスチャ
double-tap::::連続タップ
tap::::タップ
hover::::
	hoverしている／:hovering
	に類するkeyboard-like
machine::::マシン
trackpad::::トラックパッド
laptop::::ラップトップ
pen::::ペン
screenreader::::スクリーン読取り器
pan::::パン
zoom::::ズーム
panning::::パン操作
pan-zoom:panning or zooming:::パン／ズーム操作
scrolling::::スクロール操作
zooming::::ズーム操作
slide::::スライド
slider::::スライダ
stylus::::スタイラス
	~penや~stylus:pen stylus
thumb:::つまみ

中央:middle:~
左:left:~
右:right:~

digitizer::::ディジタイザ
eraser::::イレーザ
barrel::::バレル
airbrush::::エアブラシ
wheel::::ホイール
中立の:neutral:~

twist::::ツィスト
touch::::タッチ
touchscreen::::タッチスクリーン
transducer::::
感知:sense::~
感知器:sensing device::~
	~sense:sense:::
	~single-pointer:single-pointer:::
携帯:mobile::~::モバイル
tablet::::タブレット
押-:press:~
	押して
離され:releaseされ:~
離した:releaseした:~
押下する:depressする:押下げる
押下され:depressされ:押下げられ
追加押下げ:chorded presses:~
	~chorded:chorded:::
	~chordedボタン~presses

押圧:pressure::~
圧:pressure::~
物理面:surface:~

持上げら:liftさ:持ち上げら
	~~離した:liftした
手指:finger:指
接触:contact::~
接触-:contact::~
	近接しているclose proximity
操作i:interaction::操作
操作o:operation:操作
	~~操作
支援技術:assistive technology:~
主導的:master:~

前後:back-and-forth:~

動き:movement:~
動いて:moveして:~

制動-:counteract:~
制動:counteraction:~
惰性:simulated inertia:~
敏捷:rapid:~
休めれ:restでき:休められ:~
遅める:slow downする:~
勢い:momentum:~
	もっと勢いをつける:provide further momentum
	置いて:place
	投げつけ:fling
	錯覚させるような:providing a physical illusion
	出た:leave
	なくなった:leave
	なった:enter
	それた:slides off
	それた:drifts off
	それる:stray
	遅延:delay
	~buttonが押され:down
	利用-中にある:actively being used
	手:hand


	●event
bind::::バインド
処理待ち:pending::~
bitmask::::ビットマスク
composed:
標的:target:::ターゲット
	retarget
標的にし:targetし:::ターゲットにし
経路:path::~
非trusted:untrusted:非 trusted
首:primary::~
	~focus可能:focusable
	同時に:simultaneous
同時的:concurrent:~
合成な:syntheticな:~
作動:active::~::アクティブ
接触判定:hit test::~
	hit testing
誘発:triggering:~
解放-:release:~
	~~連列:stream
生産:production:~
順序関係:relative ordering:~
捕捉標的:pointer capture target override::捕捉ターゲット
捕捉:capture::~
	~pointer捕捉:pointer-capture:::

	●幾何
傾き:tilt:::~
	側に傾いて:tilt away
接線方向:tangential::~
接線:tangent::~
平面:plane::~
幾何:geometry::形状
回転:rotation::~
回転-:rotate::~
変形:transform::~
法線:normal::~
時計回り:clockwise::~
平行:parallel::~
横方向:horizontal::~
縦方向:vertical::~
分解能:resolution::~

	右端:
	右側:
	右方:
	左方:
	上方:

	●仕様
overhead::::オーバーヘッド
一定の:certain:~
偶発的:accidental:~
今日:today:~
類似性:similarities:~
参考:informative:~
同義語:synonymous:~
有効:effective:~
実効:effective:~
現在:currently:~
用語集:glossary:~
不問な:agnosticな:依らない
任意選択の:optional:~
	OPTIONAL
直接:direct:~
慣行:convention:~
支配的:dominant:~
特質:property:~:::プロパティ
opt-in:
	あるいは〜ヨイ:may opt to
手助け:facilitate:~
拡げら:expandさ:~
	選ぶ:chooseする
移行-:migrate:~
	migration
翻訳-:translate:~
周知:known:~
浮動-:float:~
実証-:demonstrate:~
採用:adoption:~

	低~level:low-level
	高~level:high-level
	版:edition
	emulation
	~advice:advice
	あり得る／可能性もある:possible
	視野から外れる:out of scope
	難しく:hardに
	まず~~第一に:In the first instance
	~~第二の:additional key 〜
	区別されない:no distinction
	視点:perspective
	直前:right before／Immediately before
	利する:behalf
	できる:capable
	支持を受けて:in favor of
	note
	noted
	~~区別する:differentiating
	方々:people
	先駆的:pioneer
	acknowledge
	~~向上:augmented／best
	~helped
	大勢を占めている:vast majority
	ないと見込まれる:unlikely
	しないように:avoid
	~~重要な:key
	UA既定の挙動で
	~~推測／~~偽造guessing/faking
	手間を減らす:reduce the cost of
	易く
	招かれ:incurされ
	易くする:help with
	map
	mapping
	に委ねら:left up to
	ならば:suppose
	浮かび上がった-:raise
	課されるものに関して:implied by
	書き直し:reword
	使われなくなっ:retire
	抜けていた:missing
	run
	vary
	~caused
	~causing
	切り替える:toggle
	~~再利用:recycle
	書-:write
	書かれ:written
	指す:refer する／
	法／方法:method

	●未分類（動詞
単調増加-:monotonic に increase:~
始まる:beginする:~
稼働中の:runしている:~
移動:movement:~
給-:supply:~
競合-:conflict:~
超過-:exceed:~

	横切った:cross
	出入り:entry/exit
	終わらせ:end
	何もしない:fails silently

	●未分類
computing::::コンピューティング
Window:
候補:candidate:~
後続の:subsequent:~
	引き続いて:subsequent
逐次的:sequential:~
等価な:equivalent:~
粗い:coarseな:~
重複:duplication:~

	複-~thread化:multi-threaded
	表:table
	挟まれている:intermediate
	重ねて:overlapping
	~missing:missing
	-:clear
	大きさ:magnitude
	端:extent
	-:mark
	に関わらず:no matter
	-:mentioned
	:nothing
	:greater
	:back
	し続ける:continue
	:forward
	:further
	:get
	:likely
	:look
	:made
	NEQ:equal
	:point
	~~性質:qualities
	:space
	~time:time
	逆:reverse
	数:number
	へ向かう:toward
	単に:simply
	近い:near
	°:degree
	属性:property


	~~地点を囲う矩形域~bounding~box
	直前に指していた:whose bounds the pointer just left
	直後に指している:whose bounds the pointer is entering
	素早く quickly

	●保安
推定-:infer:~
発生-:arise:~
持続-:persist:~
	persistent
降格-:downgrade:~
sensor::::センサー
	~randomさ:randomness
	~random:randomize
一時的な:temporary:~
個人識別可能:personally-identifiable:~
機密的:confidential:~
私的閲覧:incognito:~
高価値:high-value:~
可能性:possibility:~
暗号的:cryptographical:~

	予測-不能:not predictable
	使い回さない:remains the same only for the lifetime of
	working group
	得る:gain
	~~扱:deal with
	~~感知~exert
	potentially
	限られ:limit


	●指示語
旧-:old:~
新-:new:~
	-:intrinsic
	途中:in the middle
	次回:next
	全く:at-all
	以前の:previous
	~amongst
	一部:part
	~~主な:major
	~~主:major
	~~主要な:substantial
	それら:those
	まだ:still
	より先に:prior
	のみならず:not just
	様々に:vary
	一式:single set
	直後:immediately after
	respective
	respectively
	~~後続する:follow
	follow
	followed by
	:further
	その逆に:vice-versa
	種々の:variety
	複数／:two
	:no longer
	よく:a lot
	たくさん:lots of
	別々な:separate discrete

●●images
＠pointerevents/
pointer｜width:264px; height:280px;｜｜pointer.png
tiltX｜height:30em;｜｜tiltX.png
tiltY｜height:30em;｜｜tiltY.png
	tiltX_600px｜width:600px; height:360px;｜｜tiltX_600px.png
	tiltY_600px｜width:600px; height:450px;｜｜tiltY_600px.png
	slider｜width:404px; height:40px;｜Custom Volume Slider｜slider.png

●●ref_normative

[CSS21]
    Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. Bert Bos; Tantek Çelik; Ian Hickson; Håkon Wium Lie et al. W3C. 7 June 2011. W3C Recommendation. URL: https://www.w3.org/TR/CSS2/
[DOM4]
    DOM Standard. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/
[HTML]
    HTML Standard. Anne van Kesteren; Domenic Denicola; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[HTML5]
    HTML5. Steve Faulkner; Arron Eicholz; Travis Leithead; Alex Danilo; Sangwhan Moon. W3C. 14 December 2017. W3C Recommendation. URL: https://www.w3.org/TR/html5/
[PointerLock]
    Pointer Lock. Vincent Scheib. W3C. 27 October 2016. W3C Recommendation. URL: https://www.w3.org/TR/pointerlock/
[RFC2119]
    Key words for use in RFCs to Indicate Requirement Levels. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119
[UIEVENTS]
    UI Events. Gary Kacmarcik; Travis Leithead; Doug Schepers. W3C. 8 November 2018. W3C Working Draft. URL: https://www.w3.org/TR/uievents/
[WEBIDL]
    Web IDL. Cameron McCormack; Boris Zbarsky; Tobie Langel. W3C. 15 December 2016. W3C Editor's Draft. URL: https://heycam.github.io/webidl/

●●ref_informative

[COMPAT]
    Compatibility Standard. Mike Taylor. WHATWG. Living Standard. URL: https://compat.spec.whatwg.org/
[CSSOM-VIEW]
    CSSOM View Module. Simon Pieters. W3C. 17 March 2016. W3C Working Draft. URL: https://www.w3.org/TR/cssom-view-1/
[PointerEvents1]
    Pointer Events. Jacob Rossi; Matt Brubeck. W3C. 24 February 2015. W3C Recommendation. URL: https://www.w3.org/TR/pointerevents1/
[TOUCH-EVENTS]
    Touch Events. Doug Schepers; Sangwhan Moon; Matt Brubeck; Arthur Barstow. W3C. 10 October 2013. W3C Recommendation. URL: https://www.w3.org/TR/touch-events/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより勧告として公開された
<a href="~SPEC_URL">Pointer Events — Level 2</a>
を日本語に翻訳したものです。
~PUB
</p>



●●spec_metadata

このバージョン
	https://www.w3.org/TR/2019/REC-pointerevents2-20190404/
最新公表バージョン
	https://www.w3.org/TR/pointerevents2/
公表履歴
	https://www.w3.org/standards/history/pointerevents2
編集者草案
	https://w3c.github.io/pointerevents/
テスト一式
	https://wpt.fyi/pointerevents/
実装報告
	http://w3c.github.io/test-results/pointerevents/all.html
最新の勧告
	https://www.w3.org/TR/pointerevents1/
編集
	Matt Brubeck (Mozilla)
	Rick Byers (Google)
	Patrick H. Lauke (The Paciello Group)
	Navid Zolghadr (Google)
Participate:
	<a href="https://github.com/w3c/pointerevents/">GitHub w3c/pointerevents</a>
	<a href="https://github.com/w3c/pointerevents/issues/">File a bug</a>
	<a href="https://github.com/w3c/pointerevents/commits/gh-pages">Commit history</a> 
	<a href="https://github.com/w3c/pointerevents/pulls/">Pull requests</a>
Mailing list:
	<a href="mailto:public-pointer-events@w3.org">public-pointer-events@w3.org</a> (<a href="https://lists.w3.org/Archives/Public/public-pointer-events/">archived</a>)
正誤表
	https://www.w3.org/2019/04/pe2-errata.html
ブラウザサポート
	https://caniuse.com/pointer
公表者
	<a href="https://www.w3.org/2012/pointerevents/">Pointer Events Working Group</a>
</script>

</head>

<body>

<header>
	<hgroup>
<h1>Pointer Events — Level 2</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">
~ABSTRACT

<p>
 W3C 勧告である Pointer Events は、［
~mouse, ~pen, ~touchscreen, 等々を含む装置
］からの［
~hardwareに不問な~pointer入力
］を取扱うための~eventと関係する各種~interfaceについて述べている。
この仕様は、その勧告に見出される特能を拡張する／改変するものである。
また、既存の，~mouseを~~念頭に書かれた内容との互換性のため、他の型の~pointer装置による~eventから`~mouse~event$を発火するための対応付けについても述べる。
◎
The features in this specification extend or modify those found in Pointer Events, a W3C Recommendation that describes events and related interfaces for handling hardware agnostic pointer input from devices including a mouse, pen, touchscreen, etc. For compatibility with existing mouse based content, this specification also describes a mapping to fire Mouse Events for other pointer device types.
</p>

	</section>
	<section id="sotd">
~STATUSofTHIS

<p>
`この節では、公表~時点における…^em
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

<p>
この文書は、
<a href="https://www.w3.org/2012/pointerevents/">Pointer Events Working Group</a>
により，勧告として公表されました。
<a href="http://w3c.github.io/test-results/pointerevents/all.html">実装~報告</a>
に相互運用能が実証されています。
この文書は、 `PointerEvents1$r に取って代わります。
◎
This document was published by the Pointer Events Working Group as a Recommendation. The implementation report demonstrates interoperability. This document supersedes [PointerEvents1]. 
</p>

<p>
この仕様は、
~level 1 `PointerEvents1$r に対する更新です。
~level 1 は［
Microsoft Internet Explorer ／ Microsoft Edge
］に限り，広く出荷されました
（他にも、
`PointerEvents1^r が~W3C勧告として公表された時点で，
独立かつほぼ相互運用可能な実装が Mozilla Firefox の `pre-release build^en にてありましたが）。
この~level 2 は、
より幅広い~browserからの採用を可能化するため，［
設計のある側面から浮かび上がった ある種の制限と懸念
］に取組む［
編集上の明確化, 新たな特能, ~level 1 を非互換化する小さな変更
］を含みます。
◎
This specification is an update to [PointerEvents1] which was shipped broadly only by Microsoft Internet Explorer and Microsoft Edge (though a further independent and mostly interoperable implementation was present in a pre-release build of Mozilla Firefox when the Pointer Events specification was published as a W3C Recommendation). Level 2 includes editorial clarifications, new features and minor breaking changes that address certain limitations and concerns that have been raised about aspects of the design, in an effort to enable wider browser adoption.
</p>

<p>
前回の公表版からの変更点は、ありません。
◎
No changes were applied since previous publication.
</p>

	</section>

<main id="MAIN0">

	<section id="intro">

<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<!-- `PointerEvent!I -->

<p>
今日のほとんどの `HTML5$r 内容は、~mouse入力~向けに利用され／設計されている。
入力を~custom方式で取扱う~codeは、概して `~mouse~event$向けに書かれている。
しかしながら，今日のより新たな~computing機器は、~touchscreen, ~pen入力, 等々も含む，他の形による入力も組入れている。
これらの入力~形の各々に対し，それを取扱うための~event型が個別に提案されてきている。
しかしながら，そのような~approachでは、新たな型の入力~用に~supportが追加される度に，不必要な~logicの重複や, ~eventの取扱いにおける~overheadも招かれ易くなる。
これはまた、内容が ある型の装置のみを念頭に書かれるときにも，互換性の問題を生じさせ易い。
加えて、~mouse用に書かれている既存の内容との互換性のため、ほとんどの`~UA$は，どの型の入力に対しても`~mouse~event$を発火する。
このため、`~mouse~event$が［
実際の~mouse装置を表現している
］のか, ［
別の型の入力~装置から，互換性のために生産されたもの
］なのか，多義的になり、双方の型の装置に対応する~codeを書くのも難しくなっている。
◎
Today, most [HTML5] content is used with and/or designed for mouse input. Those that handle input in a custom manner typically code to [UIEVENTS] Mouse Events. Newer computing devices today, however, incorporate other forms of input, including touchscreens, pen input, etc. Event types have been proposed for handling each of these forms of input individually. However, that approach often incurs unnecessary duplication of logic and event handling overhead when adding support for a new input type. This often creates a compatibility problem when content is written with only one device type in mind. Additionally, for compatibility with existing mouse-based content, most user agents fire Mouse Events for all input types. This makes it ambiguous whether a Mouse Event represents an actual mouse device or is being produced from another input type for compatibility, which makes it hard to code to both device types simultaneously.
</p>

<p>
複数の入力~型に対応する~codeを書く手間を減らすため，および
上に述べた`~mouse~event$の多義性に~~対処し易くするため、この仕様は，`~pointer$と呼ばれる より抽象的な入力~形を定義する。
［
~mouse~cursor, ~pen, ~touch（複-~touchも含む）, その他
］の~pointing装置により ~screen上に入力される どの接触~点も，~pointerになり得る。
この~modelにより、利用者~側の~hardwareに関わらず，~siteや~appを上手く働くように書くことは、より容易になる。
装置に特有な取扱いが欲される局面においては、この仕様は，当の~eventを生産した装置の型を検分するための属性も定義する。
◎
To reduce the cost of coding to multiple input types and also to help with the above described ambiguity with Mouse Events, this specifications defines a more abstract form of input, called a pointer. A pointer can be any point of contact on the screen made by a mouse cursor, pen, touch (including multi-touch), or other pointing input device. This model makes it easier to write sites and applications that work well no matter what hardware the user has. For scenarios when device-specific handling is desired, this specification also defines properties for inspecting the device type which produced the event.＼
</p>

<p>
この仕様の首な目標は、［
装置に依らない~pointer入力に対応する著作は より容易にする
］一方で，［
利用者体験の~~向上に必要とされる所では 装置に特有な取扱いに限り許容する
］ような、一式の［
~event, および~interface
］を供することである。
◎
The primary goal is to provide a single set of events and interfaces that allow for easier authoring for cross-device pointer input while still allowing for device-specific handling only when necessary for an augmented experience.
</p>

<p>
~~第二の目標は、［
~UAが，~script実行を阻むことなく, 既定の~touch動作（~scrollingなど）を取扱える
］ように，複-~thread化も可能化することである。
◎
An additional key goal is to enable multi-threaded user agents to handle default touch actions, such as scrolling, without blocking on script execution.
</p>

<p class="note">注記：
この仕様は、種々の~pointer入力~用に 統一された~event~modelを定義する。
~keyboardに類する~UIなど，他の形の入力は、この~modelは受持たない（一例として、~touchscreenのみの装置~上で稼働中の~screenreaderや類似な支援技術
— ~focus可能な［
~controlや要素
］を通して 利用者による逐次的な~naviを可能にするような）。
その種の~UIに呼応して~pointer~eventを生成する~UAもあるかもしれないが、それについては，この仕様は受持たない。
◎
While this specification defines a unified event model for a variety of pointer inputs, this model does not cover other forms of input such as keyboards or keyboard-like interfaces (for instance, a screenreader or similar assistive technology running on a touchscreen-only device, which allows users sequential navigation through focusable controls and elements). While user agents might choose to also generate pointer events in response to these interfaces, this scenario is not covered in this specification.
</p>

<p class="note">注記：
作者には、まず~~第一に，どの形の入力に対しても
`focus$et, `blur$et, `click$et
などの高~levelな~eventで応答することで，等価な機能性を供することが奨励される。
しかしながら、低~levelな~event（`~pointer~event$など）を利用するときは、すべての型の入力~用の~supportを確保することが奨励される。
~keyboardに類する~UIの事例においては、これには，~keyboard~event用の明示的な取扱いの追加を要することもある。
詳細は、
<a href="~TR/WCAG20/#keyboard-operation">WCAG 2.0 指針 2.1</a>
見よ。
◎
In the first instance, authors are encouraged to provide equivalent functionality for all forms of input by responding to high-level events such as focus, blur and click. However, when using low-level events (such as Pointer Events), authors are encouraged to ensure that all types of input are supported. In the case of keyboards and keyboard-like interfaces, this might require the addition of explicit keyboard event handling. See WCAG 2.0 Guideline 2.1 for further details.
</p>

<figure id="figure_martini_glass">
<p class="alt" hidden id="_dgm-pointer">
~pointer入力は、
~mouse, ~pen, ~touch, 等々からの入力を組合せる。
◎
Pointer input combines input from mouse, pen, touch, etc.
</p>
<figcaption>
~pointerは、~screen上の特定の座標（または座標の集合）を標的に捉えられる入力~装置の，~hardwareに不問な表現である。
◎
A pointer is a hardware agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen.
</figcaption></figure>

<p>
汎用~pointer入力を取扱うための~eventは、
~mouse用のものとよく似る：
`pointerdown$et,
`pointermove$et,
`pointerup$et,
`pointerover$et,
`pointerout$et,
等々。
これにより、内容を，各種`~mouse~event$から`~pointer~event$へ移行するのも容易になる。
`~pointer~event$は、各種`~mouse~event$に在る通例の属性すべて（
~client座標, 標的~要素, ~button状態, 等々
）を供することに加え、他の形の入力
— 押圧（ `pressure^en ）, `接触~幾何$（ `contact geometry^en ）, 傾き（ `tilt^en ）, 等々 —
のための新たな属性も供する。
作者は、`~pointer~event$の~codeを，異なる【装置】型の入力~間で同じ~logicを共有するように書くことが容易になり、利用者体験の~~向上に必要とされる所に限って，特定0の型の入力を~custom化できる。
◎
The events for handling generic pointer input look a lot like those for mouse: pointerdown, pointermove, pointerup, pointerover, pointerout, etc. This facilitates easy content migration from Mouse Events to Pointer Events. Pointer Events provide all the usual properties present in Mouse Events (client coordinates, target element, button states, etc.) in addition to new properties for other forms of input: pressure, contact geometry, tilt, etc. So authors can easily code to Pointer Events to share logic between different input types where it makes sense, and customize for a particular type of input only where necessary to get the best experience.
</p>

<p>
様々な入力~装置が`~pointer~event$の源になり得るが、`~pointer~event$が，他の［
何らかの装置に特有な~eventの集合（例： 各種 `~mouse~event$, ~touch~event, 等々）
］に属する~eventに伴って生成されるものとして定義されることはない。
この仕様は、他の装置に特有な~eventの~supportは，要求しない。
そうすることもアリであり，互換性のために奨励されるが。
~UAは、他のどの装置~eventも~supportすることなく，~pointer~eventを~supportできる。
［
~mouseに特有な~event用に書かれた内容
］との互換性のため、この仕様は，［
~mouse以外の装置による~pointer入力に基づいて，`互換性~mouse~event$を生成する
］ための方法も述べる。
◎
While Pointer Events are sourced from a variety of input devices, they are not defined as being generated from some other set of device-specific events. While possible and encouraged for compatibility, this spec does not require other device-specific events be supported (e.g. mouse events, touch events, etc.). A user agent could support pointer events without supporting any other device events. For compatibility with content written to mouse-specific events, this specification does provide an optional section describing how to generate compatibility mouse events based on pointer input from devices other than a mouse.
</p>

<p class="note informative">
この仕様は、［
`~pointer~event$と
`TOUCH-EVENTS$r に定義される~touch~eventの両者とも~supportする~UA
］に期待される挙動について，何も~~述べない。
これら二つの仕様の関係性についての更なる情報は、
<a href="https://www.w3.org/community/touchevents/">Touch Events Community Group</a>
を見よ。
◎
This specification does not provide any advice on the expected behavior of user agents that support both Touch Events (as defined in [TOUCH-EVENTS]) and Pointer Events. For more information on the relationship between these two specifications, see the Touch Events Community Group.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
以下、この節の他の内容は
<a href="~W3Ccommon#conformance">~W3C日本語訳 共通~page</a>
に移譲。
】</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, コレ, ~IN, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

	</section>
	<section id="examples">
<h2 title="Examples">3. 例</h2>

~INFORMATIVE

<p>
この仕様に定義される~APIの利用を以下の作者~code例にデモる。
◎
The following are example author code that demonstrates how the APIs in this specification might be used.
</p>

<div class="example">

<p>`1@ex：
~pointer~event特能を検出して，~eventを~bindする：
◎
Example 1: Feature detection and event binding
</p>

<pre class="lang-js">
/* <span class="comment">
`~pointer~event$, または［
伝統的 ~touch／~mouse
］のいずれかを~bindする
◎
Bind to either Pointer Events or traditional touch/mouse
</span> */

if (window.PointerEvent) {
    /* <span class="comment">
`~pointer~event$が~supportされる場合は、~pointer~eventのみを~listenする
◎
if Pointer Events are supported, only listen to pointer events
</span> */
    %target.addEventListener("pointerdown", function(%event) {
        /* <span class="comment">
必要とされるなら、 ~touch／~pen／~mouse に対する異なる挙動~用に，
%event`.pointerType^c
に基づいて，別々な~logicを適用する
◎
if necessary, apply separate logic based on e.pointerType for different touch/pen/mouse behavior
</span> */
        ...
    });
    ...
} else {
    /* <span class="comment">
伝統的な ~touch／~mouse ~event~handler
◎
traditional touch/mouse event handlers
</span> */
    %target.addEventListener('touchstart', function(%event) {
        /* <span class="comment">
互換性~mouse~eventと~clickを防止する
◎
prevent compatibility mouse events and click
</span> */
        %event.preventDefault();
        ...
    });
    ...
    %target.addEventListener('mousedown', ...);
    ...
}

/* <span class="comment">
~keyboardを取扱うための，追加的な~event~listener
◎
additional event listeners for keyboard handling
</span> */
...
</pre>
</div>

<div class="example">
<p>`2@ex：
利用者による入力を検出する例：
◎
Detecting the type of input from a user
</p>

<pre class="lang-js">
window.addEventListener("pointerdown", %detectInputType);

function detectInputType(%event) {
    switch(%event.pointerType) {
        case "mouse":
            /* <span class="comment">
~mouse入力が検出された
◎
mouse input detected
</span> */
            break;
        case "pen":
            /* <span class="comment">
~pen／~stylus入力が検出された
◎
pen/stylus input detected
</span> */
            break;
        case "touch":
            /* <span class="comment">
~touch入力が検出された
◎
touch input detected
</span> */
            break;
        case "":
            /* <span class="comment">
空~文字列は、~UAが検出できない装置を意味する
◎
↓</span> */
            break;
        default:
            /* <span class="comment">
~UAに特有な~custom型
◎
pointerType is empty (could not be detected) or UA-specific custom type
</span> */
    }
}</pre>
</div>

<div class="example">
<p>`3@ex：
基本的な HTML5 Canvas の~app：
◎
Basic HTML5 Canvas painting application
</p>

<pre class="lang-html">
&lt;style&gt;
  /* <span class="comment">
`~touch用の既定の挙動$（~pan-zoomなど）を不能化して、
`canvas^e 要素~上のすべての~eventを，~appに仕向ける。
◎
Disable intrinsic user agent touch behaviors (such as panning or zooming) so that all events on the canvas element are given to the application instead.
</span> */

  canvas { 
    `touch-action$p: none; 
  }
&lt;/style&gt;

&lt;canvas
    id="drawSurface"
    width="500px" height="500px"
    style="border:1px solid black;"
&gt;&lt;/canvas&gt;

&lt;script&gt;
    var %canvas = document.getElementById("drawSurface"),
    %context = %canvas.getContext("2d");

    if (window.PointerEvent) {
        %canvas.addEventListener("pointermove", paint);
        if(window.navigator.maxTouchPoints &gt; 1) {
    	   /* <span class="comment">
~UAと~hardwareは複-~touchを~supportする
◎
user agent and hardware support multi-touch
</span> */
        }
    }
    else {
        /* <span class="comment">
`~pointer~event$を~supportしない~UA用の~fallback
◎
provide fallback for user agents that do not support Pointer Events
</span> */
        %canvas.addEventListener("mousemove", paint);
    }

    function paint(%event) {
        if(%event.buttons &gt; 0)
    	   %context.fillRect(%event.clientX, %event.clientY, 5, 5);
    }

    /* <span class="comment">
~keyboardを取扱うための，追加的な~event~listener／関数
◎
additional event listeners/functions for keyboard handling
</span> */
    ...

&lt;/script&gt;
</pre>
</div>

<div class="example">
<p>`4@ex：
要素~sizeを`接触~幾何$に合わせる例：
◎
Resizing an element to match the contact geometry
</p>

<pre class="lang-html">
&lt;div style=
    "position:absolute;
    top:0px; left:0px;
    width:100px; height:100px;"
&gt;&lt;/div&gt;
&lt;script&gt;
window.addEventListener("pointerdown", checkPointerSize);

function checkPointerSize(%event) {
    %event.target.style.width = %event.width + "px";
    %event.target.style.height = %event.height + "px";
}
&lt;/script&gt;
</pre>
</div>

<div class="example">
<p>`5@ex：
~scriptから`非trusted$な~pointer~eventを発火する例：
◎
Firing an untrusted pointer event from script
</p>

<pre class="lang-js">
var %event = new PointerEvent("pointerover", {
    bubbles: true,
    cancelable: true,
    composed: true,
    pointerId: 42,
    pointerType: "pen",
    clientX: 300,
    clientY: 500
});
eventTarget.dispatchEvent(%event); 
</pre>
</div>

	</section>
	<section id="glossary">
<h2 title="Glossary">4. 用語集</h2>

~INFORMATIVE

<dl class="def-list">
	<dt>~pointerの~buttonが`作動~状態@にある</dt>
	<dd>
<p>
`~pointer~event$の `buttons$m 属性が非 0 値をとる条件を満たしている：
</p>

<ul>
	<li>
~mouseに対しては、装置にて何らかの~buttonが押下されているとき。
</li>
	<li>
~touchに対しては、`~digitizer$との物理的~接触があるとき。
</li>
	<li>
~penに対しては、~penによる`~digitizer$との物理的~接触があるとき, または
~hover中にいずれかの~buttonが押下されているとき。
</li>
</ul>
◎
The condition when a pointer has a non-zero value for the buttons property. For mouse, this is when the device has at least one button depressed. For touch, this is when there is physical contact with the digitizer. For pen, this is when either the pen has physical contact with the digitizer, or at least one button is depressed while hovering.
</dd>

	<dt>`作動中の~pointer@, または 単に~pointer†</dt>
	<dd>
<p>
~touch接触, ~penや~stylus, ~mouse~cursor,
その他，~eventを生産し得るような~pointer。
所与の~pointer（ `pointerId$m により一意に識別される）が，文書の中で追加的な~eventを生産し得るならば、その~pointerは，依然として作動中と見なされる。
例えば：
◎
Any touch contact, pen stylus, mouse cursor, or other pointer that can produce events. If it is possible for a given pointer (identified by a unique pointerId) to produce additional events within the document, then that pointer is still considered active. Examples:
</p>

		<ul>
			<li>
機器に接続された~mouseは、常に作動中と見なされる。
◎
A mouse connected to the device is always active.
</li>
			<li>
~screen上の~touch接触は、作動中と見なされる。
◎
A touch contact on the screen is considered active.
</li>
			<li>
~touch接触／~penや~stylus
が`~digitizer$の範囲を超えるように持上げられた場合、それは もはや作動中とは見なされない。
◎
If a touch contact or pen stylus is lifted beyond the range of the digitizer, then it is no longer considered active.
</li>
		</ul>

<p class="note">注記：
~platformによっては、`作動中の~pointer$の集合には，~UAを標的にしていない（例： 他の~appを標的にしている）ものも含め，装置へのすべての~pointer入力も含まれる。
◎
On some platforms, the set of active pointers includes all pointer input to the device, including any that are not targeted at the user agent (e.g. those targeted at other applications).
</p>
	</dd>
	<dd class="trans-note">【†
`~pointer~event$を生産する装置を意味する用語として， “`~pointer$” が下に定義されていて，紛らわしいが、~event処理の文脈における，語 “~pointer” は，この`作動中の~pointer$を（暗黙的に）指している
— 定義により，作動中でない~pointer`装置^emからは~eventは生じ得ないので。
すなわち，~pointerは、装置が同じであっても，`作動中の$ 各~期間ごとに別々な~instanceを表現する（原文には明示的にそう記されていないが、そう解釈しなければ，~modelをきちんと定義できなくなる）。
】</dd>

	<dd class="note">
各 `作動中の~pointer$には、少なくとも`~top-level閲覧~文脈$ `HTML$r の視野の中では，同じ識別子（ `pointerId$m ）が付与されるべきである。
しかしながら、複数の`~top-level閲覧~文脈$にまたがって そうなる保証は，ない。
◎
Each active pointer should have the same id within the scope of the top-level browsing context (as defined by [HTML]). However, there is no such guarantee across multiple top-level browsing contexts.
</dd>

	<dt>`取消された@~event （ `canceled event^en ）</dt>
	<dd>
`UIEVENTS$r, `HTML$r の定義に従って，`既定~動作$が防止された~event
— 
`preventDefault()$m により ／
~event~handlerから ~F が返されたため ／
他の手段により。
◎
An event whose default action was prevented by means of preventDefault(), returning false in an event handler, or other means as defined by [UIEVENTS] and [HTML].
</dd>

	<dt>`接触~幾何@（ `contact geometry^en ）</dt>
	<dd>
`~digitizer$上で入力された~~地点を囲う矩形域（最も共通的なものは，~touch ）。
これは概して、~pointer入力の分解能が単独の画素より粗い装置を指す
【指先の大きさなど】
。
この~dataを全く報告しない装置もある。
◎
The bounding box of an input (most commonly, touch) on a digitizer. This typically refers to devices with coarser pointer input resolution than a single pixel. Some devices do not report this data at all.
</dd>

	<dt>`~digitizer@ （ `digitizer^en ）</dt>
	<dd>
物理面に接触-あるいは近接している入力を検出できる型の入力~感知器。
最も共通的なものは、［
~touch接触／~penや~stylus
］からの入力を感知する物理面である。
◎
A type of input sensing device in which a surface can detect input which is in contact and/or in close proximity. Most commonly, this is the surface that senses input from the touch contact or a pen stylus.
</dd>

	<dt>`接触判定@ （ `hit test^en ）</dt>
	<dd>
~UAが `~pointer~event$用の標的~要素を決定する処理-。
これは概して、~pointerの所在, および
~screen媒体~上の文書~内の要素たちの視覚的な~layoutを考慮して決定される。
接触判定の仕組みは、この仕様の視野から外れる。
◎
The process by which a user agent determines a target element for a pointer event. Typically, this is determined by considering the pointer's location and also the visual layout of elements in a document on screen media.
</dd>
	<dd class="trans-note">【
`~pointer捕捉$は，この仕組みを上書きする。
】</dd>

	<dt>`~pointer@ （ `pointer^en ）</dt>
	<dd>
~screen上の特定の座標（または座標の集合）を標的に捉えられる入力~装置
— ~mouse, ~pen, ~touch接触 など —
の，~hardwareに不問な表現。

◎
A hardware agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen, such as a mouse, pen, or touch contact.
</dd>
	<dd class="trans-note">【
上に述べたように、この語は，`作動中の~pointer$を意味する場合もある。
】</dd>

	<dt>`~UA@ （ `user agent^en ）</dt>
	<dd>
~browserや内容~著作~toolなど，通常は~client~machine上で稼働中の~programであって、利用者に利するように，内容を［
検索取得- ／ 解釈- ／ 実行- ／ 呈示- ／ 作成-
］するものとして動作するもの。
◎
A program, such as a browser or content authoring tool, normally running on a client machine, which acts on a user's behalf in retrieving, interpreting, executing, presenting, or creating content.
</dd>

	<dt>`~taskを~queueする@ （ `queue a task^en ）`HTML5$r</dt>
	<dd>
【この用語は利用されていないので、和訳は省略する。】
◎
Adding the task to events task queue of the relevant event loop, as defined in [HTML5].
</dd>

</dl>

<p>【以下の用語は、この訳による補完, もしくは明示的な定義／集約。】</p>

<dl class="def-list">
	<dt>`~event連列@</dt>
	<dd>
`作動中の~pointer$から所定の順序で`同期的$に生じる一連の~event。
</dd>

	<dt>`~mouse~event@ （ `Mouse Events^en ）</dt>
	<dd>
`UIEVENTS$r にて定義される各種~mouse~eventのうち，
`click$et, `dblclick$et
を除くものの総称（
`mouseXXX^et ~event
— 概ね、
`MouseEvent$I ~interfaceを実装しつつ，
`PointerEvent$I など，拡張された~interfaceは実装しない~event）。
</dd>

	<dt>`~pointer~event@ （ `Pointer Events^en ）</dt>
	<dd>
この仕様にて定義される各種~pointer~eventの総称（言い換えれば、
`PointerEvent$I ~interfaceを実装する~event）。
</dd>

	<dt>`~pointing先@ （ `pointing^en 先 ）</dt>
	<dd>
`作動中の~pointer$に対し，`接触判定$により決定される要素。
</dd>

	<dt>`捕捉~込みの~pointing先@</dt>
	<dd>
~pointerを捕捉している要素がある場合、~event配送の目的において`~pointing先$とされ得るものは，要素または その子孫に拘束されることもある。
すなわち，ある要素 %要素 が`作動中の~pointer$を`捕捉$している（すなわち， %要素 は その~pointerの`処理待ち捕捉標的$である）, かつ
`~pointing先$は［
%要素 でも その子孫でもない
］ならば  %要素 ／
他の場合は`~pointing先$。
</dd>

	<dt>`境界~event@ （ `boundary event^en ）</dt>
	<dd>
`~pointing先$が要素~境界をまたいだときに生じる~eventの総称
— 具体的には，次に挙げるものなど【正確には定義されていない】
⇒
`pointerover$et, `pointerout$et, `pointerenter$et, `pointerleave$et
</dd>

	<dt>~touch （ `touch^en ）</dt>
	<dd>
~penなどの装置を介さない、人の手指による入力。
</dd>

	<dt>接触（ `contact^en ）</dt>
	<dd>
`~digitizer$が検出できる程に，物理的に接触-／近接している状態を意味する。
<!-- 
touch と contact の概念的な違いは、前者には，何らかの~~操作が含意される点にある
-->
</dd>

	<dt>`~touch用の既定の挙動@</dt>
	<dd>
~UAにより定義される，~touch入力~用の既定の挙動（表示域の~pan-zoomなど）。
</dd>

	<dt>`~mouse~eventは防止するか@ （ `PREVENT MOUSE EVENT^c ~flag ）</dt>
	<dd>
真偽値
— 初期時は ~F とする。
これは、~pointer装置の各~型に結び付けられる。
~T にされたときは、その型の~pointer装置からは`互換性~mouse~event$は，生成されなくなる。
<!-- 
原文では `code^e タグでマークアップされているが（理由は不明）、抽象的な概念なので，この訳ではそのようなマークアップはしない。
-->
</dd>
</dl>

<p>
各 `作動中の~pointer$には、次のものが結付けられる：
</p>

<dl class="def-list">
	<dt>`捕捉標的@ （ `pointer capture target override^en ）</dt>
	<dt>`処理待ち捕捉標的@ （ `pending pointer capture target override^en ）</dt>
	<dd>
要素, または ~NULL（初期~値）。
これらは，`~pointer捕捉$の制御に利用され、当の~pointerにより生じる~eventの標的を上書きする。
</dd>
</dl>

	</section>
	<section id="pointer-events-and-interfaces">
<h2 title="Pointer Events and Interfaces">5. 各種~pointer~eventと各種~interface</h2>
		<section id="pointerevent-interface">
<h3 title="PointerEvent Interface">5.1. `PointerEvent^I ~interface</h3>

<pre class="idl">
dictionary `PointerEventInit@I : `MouseEventInit$I {
    long      `pointerId@m = 0;
    double    `width@m = 1;
    double    `height@m = 1;
    float     `pressure@m = 0;
    float     `tangentialPressure@m = 0;
    long      `tiltX@m = 0;
    long      `tiltY@m = 0;
    long      `twist@m = 0;
    DOMString `pointerType@m = "";
    boolean   `isPrimary@m = false;
};

[`Exposed$=Window]
interface `PointerEvent@I : `MouseEvent$I {
    constructor(DOMString %type, optional `PointerEventInit$I %eventInitDict = {});
    readonly attribute long      `pointerId$m;
    readonly attribute double    `width$m;
    readonly attribute double    `height$m;
    readonly attribute float     `pressure$m;
    readonly attribute float     `tangentialPressure$m;
    readonly attribute long      `tiltX$m;
    readonly attribute long      `tiltY$m;
    readonly attribute long      `twist$m;
    readonly attribute DOMString `pointerType$m;
    readonly attribute boolean   `isPrimary$m;
};
</pre>

<dl class="idl-def">
	<dt>`pointerId@m</dt>
	<dd>
~eventを生じさせた~pointerを一意に識別する識別子。
この識別子は、その時点で，`~top-level閲覧~文脈$ `HTML5$r において`作動中の~pointer$すべての中で一意になるモノトスル。
~UAは、必要に応じて，以前に`作動中$であった~pointerによる使われなくなった値を `pointerId$m 値に~~再利用してもヨイ。
◎
A unique identifier for the pointer causing the event. This identifier MUST be unique from all other active pointers in the top-level browsing context (as defined by [HTML5]) at the time. A user agent MAY recycle previously retired values for pointerId from previous active pointers, if necessary.
</dd>

<dd class="note">注記：
`pointerId$m の選定~algoは，実装に特有なので、作者は，この値を［
上の意味で一意であること以外の意味を伝達する
］ものとは見做せない。
例として，~UAは、単純に［
どの~pointerにも，作動中になった順に 1 から開始する数をアテガってもヨイ
］が，これらの値が単調増加することは保証されない。
あるいは，［
作動中の各~pointerに，完全に~randomかつ, 一意な数をアテガってもヨイ
］が、この局面においては，~UAは、［
異なる~pageにわたり，利用者が一意に指紋収集され, 追跡される可能性
］を最小限にするため，［
異なる~pageに同じ `pointerId$m 値を使い回さないこと
］, および［
新たなどの `pointerId$m 値も予測-不能になること（暗号的に強い~randomさで生成するなど）
］を確保するモノトスル。
◎
The pointerId selection algorithm is implementation specific. Therefore authors cannot assume values convey any particular meaning other than an identifier for the pointer that is unique from all other active pointers. As an example, user agents may simply assign a number, starting from 1, to any active pointers, in the order that they become active - but these values are not guaranteed to be monotonically increasing. Other user agents may opt to assign a completely randomized and unique number to each active pointer. However, in the latter scenarios user agents MUST ensure that the pointerId that is assigned remains the same only for the lifetime of the current page, and that any new pointerId values are not predictable (e.g. generated randomly with cryptographically strong randomness), to minimize the possibility of users being uniquely fingerprinted and tracked across different pages.
</dd>

	<dt>`width@m</dt>
	<dt>`height@m</dt>
	<dd>
順に、~pointerの`接触~幾何$の横幅, 縦幅（ X, Y 軸~上の大きさ）を~CSS~pixel数（ `CSS21$r ）で表す。
この値は、所与の~pointer用の各~eventごとに更新されてもヨイ。
［
概して`接触~幾何$を欠く入力（伝統的な~mouseなど） ／
実際の幾何が~hardwareにより検出されない入力
］に対しては、~UAは，既定の値として 1 を返すモノトスル。
◎
The width (magnitude on the X axis), in CSS pixels (see [CSS21]), of the contact geometry of the pointer. This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the user agent MUST return a default value of 1.
◎
The height (magnitude on the Y axis), in CSS pixels (see [CSS21]), of the contact geometry of the pointer. This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the user agent MUST return a default value of 1.
</dd>

	<dt>`pressure@m</dt>
	<dd>
~pointer入力による，範囲 0 〜 1 に正規化された押圧
—
値［
0 ／ 1
］は、~hardwareが検出できる［
最小／最大
］の押圧を表現する。
~hardwareや~platformが押圧を~supportしないときの値は、［
~buttonが`作動~状態$にあるなら 0.5 ／
~ELSE_ 0
］を返すモノトスル。
◎
The normalized pressure of the pointer input in the range of [0,1], where 0 and 1 represent the minimum and maximum pressure the hardware is capable of detecting, respectively. For hardware and platforms that do not support pressure, the value MUST be 0.5 when in the active buttons state and 0 otherwise.＼
</dd>
	<dd>
`pointerup$et ~eventに対しては、 `pressure$m は常に 0 にされることに注意。
◎
Note: all pointerup events will have pressure 0.
</dd>

	<dt>`tangentialPressure@m</dt>
	<dd>
範囲 −1 〜 1 に正規化された，~pointer入力の接線方向~圧†（ ~barrel圧としても周知）。
概して，追加的な制御により設定される（例： ~airbrush~stylus上の手指~wheelなど）。
値 0 は、中立の位置を指す。
~hardwareによっては，範囲 0 〜 1 に入る正な値しか~supportしないものもあることに注意。
~hardwareや~platformが接線方向~圧を~supportしないときは、 0 を返すモノトスル。
◎
The normalized tangential pressure (also known as barrel pressure), typically set by an additional control (e.g. a finger wheel on an airbrush stylus), of the pointer input in the range of [-1,1], where 0 is the neutral position of the control. Note that some hardware may only support positive values in the range of [0,1]. For hardware and platforms that do not support tangential pressure, the value MUST be 0.
</dd>
	<dd class="trans-note">【†
接線方向~圧（ `tangential pressure^en ） —
おそらく，~pen等をひねるときの力。
~barrel（“樽”）の周に沿う，接線~方向。
】</dd>

	<dt>`tiltX@m</dt>
	<dd>
`~digitizer$の Y-Z 平面と, ［
~transducer（例：~penや~stylus）軸と Y 軸を包含する平面
］がなす角度。
値の範囲は −90° 〜 90° 。
正な `tiltX$m は、~transducer軸が右側に傾いていることを表す。
絶対~値が大きいほど，~transducer軸が~digitizer面の法線から離れていることを表す。
◎
The plane angle (in degrees, in the range of [-90,90]) between the Y-Z plane and the plane containing both the transducer (e.g. pen stylus) axis and the Y axis. A positive tiltX is to the right. tiltX can be used along with tiltY to represent the tilt away from the normal of a transducer with the digitizer.＼
</dd>
	<dd>
~hardwareや~platformが傾きを報告しないときの値は、 0 になるモノトスル。
◎
For hardware and platforms that do not report tilt, the value MUST be 0.
</dd>
	<dd class="trans-note">【
標的~要素に対する変形（回転など）が X, Y 軸の解釈に影響し得るのか,
どう影響するのかについては、この仕様には述べられていない。
】</dd>

	<dd>
<figure id="figure_tiltX">
<p class="alt" hidden id="_dgm-tiltX">
`tiltX^m を説明する図式
◎
tiltX explanation diagram
</p>
<figcaption>
正な `tiltX$m 。
【この訳では、原文の図式を ~level 3 による改善された図式に置換している。】
◎
Positive tiltX.
</figcaption></figure>
</dd>

	<dt>`tiltY@m</dt>
	<dd>
X-Z 平面と, ［
~transducer（例：~penや~stylus）軸と X 軸を包含する平面
］がなす角度（ −90° 〜 90° の範囲）。
正な `tiltY$m は、~transducer軸が利用者~側に傾いている†ことを表す。
絶対~値が大きいほど，~transducer軸が~digitizer面の法線から離れていることを表す。
◎
The plane angle (in degrees, in the range of [-90,90]) between the X-Z plane and the plane containing both the transducer (e.g. pen stylus) axis and the X axis. A positive tiltY is towards the user. tiltY can be used along with tiltX to represent the tilt away from the normal of a transducer with the digitizer.＼
</dd>
	<dd>
~hardwareや~platformが傾きを報告しないときの値は、 0 になるモノトスル。
◎
For hardware and platforms that do not report tilt, the value MUST be 0.
</dd>
	<dd>
<figure id="figure_tiltY">
<p class="alt" hidden id="_dgm-tiltY">
`tiltY^m を説明する図式
◎
tiltY explanation diagram
</p>
<figcaption>
正な `tiltY$m 。
【この訳では、原文の紛らわしかった図式を ~level 3 による改善された図式に置換している。】
◎
Negative tiltY.
</figcaption></figure>
</dd>

	<dt>`twist@m</dt>
	<dd>
~transducer（例： ~penや~stylus）自身の~~主~軸~周りにおける
— 時計回りで範囲［
0° 〜 359°
］に入る —
回転~角度。
◎
The clockwise rotation (in degrees, in the range of [0,359]) of a transducer (e.g. pen stylus) around its own major axis.＼
</dd>
	<dd>
~hardwareや~platformが~twist【ひねり？】を報告しないときの値は、 0 になるモノトスル。
◎
For hardware and platforms that do not report twist, the value MUST be 0.
</dd>

	<dt>`pointerType@m</dt>
	<dd>
<p>
~eventを生じさせた装置の型（
~mouse,
~pen,
~touch,
等々）を指示する。
~UAは，［
~mouse ／ ~penや~stylus ／ ~touch入力~装置
］用に`~pointer~eventを発火する$ときは、その `pointerType$m の値を，次の表に則って~~初期化するモノトスル：
◎
Indicates the device type that caused the event (mouse, pen, touch, etc.). If a user agent is to fire a pointer event for a mouse, pen stylus, or touch input device, then the value of pointerType MUST be according to the following table:
</p>

<div>
<table><thead><tr><th>~pointer装置の型
<th>`pointerType$m 値
</thead><tbody>

<tr><td>~mouse
<td>`mouse^l

<tr><td>~pen／~stylus
<td>`pen^l

<tr><td>~touch接触
<td>`touch^l

</tbody></table>

◎
Pointer Device Type	pointerType Value
Mouse	mouse
Pen Stylus	pen
Touch Contact	touch
</div>

	</dd>
	<dd>
~UAが検出できない型の装置~用の値は、空~文字列になるモノトスル。
上に挙げたもの以外の，~UAが~supportする型の~pointer装置~用の `pointerType$m 値は、異なる型の装置~間で名前が競合しないように，~vendor接頭辞が~~付与されるベキである。
将来の仕様は、他の型の装置~用に規範的な値を追加し得る。
◎
If the device type cannot be detected by the user agent, then the value MUST be an empty string. If a user agent supports pointer device types other than those listed above, the value of pointerType SHOULD be vendor prefixed to avoid conflicting names for different types of devices. Future specifications MAY provide additional normative values for other device types.
</dd>
	<dd class="trans-note">【
~penも~stylusも，~penのように手で持って~~扱う装置であるが
（ `stylus^en は `stylus pen ^en の略称でもある）、
一般に，機能が簡素なものは “~stylus”, より豊富なものは “~pen” と<a href="https://en.wikipedia.org/wiki/Active_pen">称されるようだ</a>
（~stylusには、座標しか供さないものもあろう）。
~touchは、
そのような装置を介さない，手指による入力。
】</dd>
	<dd class="note">注記：
`2$ex に、 `pointerType$m の基本的な利用-法のデモがある。
開発者は、何らかの形で既定の取扱いを含めるべきであることに注意
— 自前の~custom `pointerType$m 値を実装している~UAや,
`pointerType$m が単に空~文字列である状況に対応するために。
◎
See Example 2 for a basic demonstration of how the pointerType can be used. Also note that developers should include some form of default handling to cover user agents that may have implemented their own custom pointerType values and for situations where pointerType is simply an empty string.
</dd>
	<dd class="trans-note">【
この仕様では、同じ型の装置が複数~在る状況は想定されていない
— 特に，`~mouse~eventは防止するか$の扱いに関して。
複数の~mouseについては、
<a href="#multiple-mouse-inputs">一つの装置に統合する</a>
ものとみなしている。
~mouse以外については、同じ型の装置が複数ある場合に関して，明示的に言及されていないが。
】</dd>

	<dt>`isPrimary@m</dt>
	<dd>
~pointerがこの`~pointer型$の`首~pointer$を表現するかどうかを指示する。
◎
Indicates if the pointer represents the primary pointer of this pointer type.
</dd>
</dl>

<p>
`PointerEventInit$I 辞書は、 `PointerEvent$I ~interfaceの構築子に，`非trusted$（合成な）`~pointer~event$を構築する仕組みを供する。
それは `UIEVENTS$r にて定義される `MouseEventInit$I 辞書を継承する。
~eventを構築する手続きは、 `DOM4$r にて定義される。
`5$ex に、`非trusted$な`~pointer~eventを発火する$方法をデモる見本~codeがある。
◎
The PointerEventInit dictionary is used by the PointerEvent interface's constructor to provide a mechanism by which to construct untrusted (synthetic) pointer events. It inherits from the MouseEventInit dictionary defined in [UIEVENTS]. The steps for constructing an event are defined in [DOM4]. See the examples for sample code demonstrating how to fire an untrusted pointer event.
</p>

<p class="note">注記：
`PointerEvent$I ~interfaceは、 `MouseEvent$I `UIEVENTS$r を継承し， `CSSOM-VIEW$r により拡張される。
◎
The PointerEvent interface inherits from MouseEvent, defined in [UIEVENTS] and extended by [CSSOM-VIEW].
</p>

		<section id="button-states">
<h4 title="Button States">5.1.1. ~button状態</h4>
			<section id="chorded-button-interactions">
<h5 title="Chorded Button Interactions">5.1.1.1. ~buttonの追加押下げ操作i</h5>

<p>
~mouseや~penなどの一部の~pointer装置は、複数の~buttonを~supportする。
`~mouse~event$~model `UIEVENTS$r においては、どの~buttonが押されたときも，
`mousedown$et, `mouseup$et
~eventが生産される。
この~hardware相違を より良く抽象-化して，入力に対する装置に依らない著作を単純~化するため、`~pointer~event$においては、
`~buttonの追加押下げ@
— ~pointer装置~上の別の~buttonがすでに押下されている間に
追加的な~buttonを押下すること —
に対しては、
`pointerdown$et, `pointerup$et
~eventが重ねて発火されることはない†。
◎
Some pointer devices, such as mouse or pen, support multiple buttons. In the [UIEVENTS] Mouse Event model, each button press produces a mousedown and mouseup event. To better abstract this hardware difference and simplify cross-device input authoring, Pointer Events do not fire overlapping pointerdown and pointerup events for chorded button presses (depressing an additional button while another button on the pointer device is already depressed).
</p>

<p class="trans-note">【†
~button A, B をこの順に押して，同じ順に離した場合、
`pointerup$et は，最後に B を離したときに呼応して発火される？
それとも A を離したときに発火される？
】</p>

<p>
~buttonの追加押下げは、［
`button$m, `buttons$m
］属性の変化を検分すれば検出できる†。
これらの属性は
`MouseEvent$I ~interface `UIEVENTS$r
から継承されるが、意味論と値には，次~節~以下に要旨する変更が加えられている。
◎
Instead, chorded button presses can be detected by inspecting changes to the button and buttons properties. The button and buttons properties are inherited from the [UIEVENTS] MouseEvent interface, but with a change in semantics and values, as outlined in the following sections.
</p>

<p class="trans-note">【†
追加押下げに対しては、少なくとも，何らかの（ `pointerdown$et, `pointerup$et 以外の）~pointer~eventが発火される。
`pointermove$et を見よ。
】</p>

<p class="note">注記：
［
`button^m ／ `buttons^m
］属性に対する改変が適用されるのは、~pointer~eventに限られる。
`互換性~mouse~event$用の［
`button^m ／ `buttons^m
］の値は `UIEVENTS$r に従うべきである。
◎
The modifications to the button and buttons properties apply only to pointer events. For any compatibility mouse events the value of button and buttons should follow [UIEVENTS].
</p>

			</section>
			<section id="the-button-property">
<h5 title="The button property">5.1.1.2. `button^m 属性</h5>

<p>
~pointer~eventにおける~button状態の（単なる `pointerdown$et, `pointerup$et を超える）遷移を識別できるようにするため、 `button$m 属性は，状態~変化により~eventを発火させた装置~buttonを指示する。
◎
To identify button state transitions in any pointer event (and not just pointerdown and pointerup), the button property indicates the device button whose state-change fired the event.
</p>

<table>
<thead><tr><th>装置の~button状態◎ Device Button State
<th>`button^m
</thead>

<tbody><tr><td>
前回の~eventから，どの~buttonも, どの~touch／~pen接触も変化していない
◎
Neither buttons nor touch/pen contact changed since last event
<td>−1

<tr><td>
~mouseの左~buttonが押されている ／
~touch接触がある ／
~pen接触がある
◎
Left Mouse,
Touch Contact,
Pen contact
<td>0

<tr><td>
~mouseの中央~buttonが押されている
◎
Middle Mouse
<td>1

<tr><td>
~mouseの右~buttonが押されている ／
~penの~barrel~buttonが押されている
◎
Right Mouse,
Pen barrel button
<td>2

<tr><td>
~mouseの x1（ `back^en ）~buttonが押されている
◎
X1 (back) Mouse
<td>3

<tr><td>
~mouseの x2（ `forward^en ）~buttonが押されている
◎
X2 (forward) Mouse
<td>4

<tr><td>
~penの~eraser~buttonが押されている
◎
Pen eraser button
<td>5

</tbody></table>

<p class="note">注記：
~mouse~dragの間、 `pointermove$et ~eventにおける `button^m 属性の値は，
`mousemove$et ~eventから異なることになる。
例えば，右~buttonを押しながら~mouseを動かしている間、
`pointermove$et ~eventの `button^m 値は −1 になる一方で，
`mousemove$et ~eventの `button^m 値は 2 になる。
◎
During a mouse drag, the value of the button property in a pointermove event will be different from that in a mousemove event. For example, while moving the mouse with the right button pressed, the pointermove events will have the button value -1, but the mousemove events will have the button value 2.
</p>

			</section>
			<section id="the-buttons-property">
<h5 title="The buttons property">5.1.1.3. `buttons^m 属性</h5>

<p>
`buttons$m 属性は、装置の個々の~buttonの現在の状態を~bitmaskとして与える（ `MouseEvent$I におけるそれと同じだが、アリな値は拡げられている）。
◎
The buttons property gives the current state of the device buttons as a bitmask (same as in MouseEvent, but with an expanded set of possible values).
</p>

<table>
<thead><tr><th>装置の現在の~button状態◎ Current state of device buttons
<th>`buttons^m
</thead>

<tbody><tr><td>
［
~mouse ／
~hoverしている~pen
］は どの~buttonも押されずに動いている
◎
Mouse moved with no buttons pressed,
Pen moved while hovering with no buttons pressed
<td>0

<tr><td>
~mouseの左~buttonが押されている ／
~touch接触がある ／
~pen接触がある
◎
Left Mouse,
Touch Contact,
Pen contact
<td>1

<tr><td>
~mouseの中央~buttonが押されている
◎
Middle Mouse
<td>4

<tr><td>
［
~mouseの右~button ／
~penの~barrel~button
］が押されている
◎
Right Mouse,
Pen barrel button
<td>2

<tr><td>
~mouseの x1（ `back^en ）~buttonが押されている
◎
X1 (back) Mouse
<td>8

<tr><td>
~mouseの x2（ `forward^en ）~buttonが押されている
◎
X2 (forward) Mouse
<td>16

<tr><td>
~penの~eraser~buttonが押されている
◎
Pen eraser button
<td>32

</tbody></table>

			</section>
		</section>
		<section id="the-primary-pointer">
<h4 title="The Primary Pointer">5.1.2. 首~pointer</h4>

<p>
複-~pointer装置（例：複-~touch）
【複数の装置ではなく，複数の同時的な接触を~supportする~pointer装置】
に対しては、
`isPrimary$m 属性が，`首~pointer$を識別するために利用される。
各`~pointer型$に対し，
`首~pointer@
とは、その型の~pointer用の`作動中の~pointer$の集合の中で，主導的とされる~pointerである：
◎
In a multi-pointer (e.g. multi-touch) scenario, the isPrimary property is used to identify a master pointer amongst the set of active pointers for each pointer type.
</p>

<ul>
	<li>
どの時点であれ、`首~pointer$は，各`~pointer型$に対し高々一つまでとする。
◎
At any given time, there can only ever be at most one primary pointer for each pointer type.
</li>
	<li>
特定0の`~pointer型$に対し最初に作動中になる~pointer（例えば 複-~touchによる操作iなら，手指による~screenへの最初の~touch）が、その`~pointer型$の`首~pointer$になる。
◎
The first pointer to become active for a particular pointer type (e.g. the first finger to touch the screen in a multi-touch interaction) becomes the primary pointer for that pointer type.
</li>
	<li>
`首~pointer$のみが`互換性~mouse~event$を生産することになる。
【複数の型の~pointer装置が同時的に利用されていて】
`首~pointer$が複数ある事例では、それぞれの~pointerが，`互換性~mouse~event$を生産することになる。
◎
Only a primary pointer will produce compatibility mouse events. In the case where there are multiple primary pointers, these pointers will all produce compatibility mouse events.
</li>
</ul>

<p class="note">注記：
作者は、欲するなら，首~pointer以外を無視することで 単独の-~pointerによる操作iを達成できる（しかしながら，下の
<a href="#multiple-primary-pointers">複数の首~pointer</a>
についての注記を見よ）。
◎
Authors who desire single-pointer interaction can achieve this by ignoring non-primary pointers (however, see the note below on multiple primary pointers).
</p>

<p class="note" id="multiple-primary-pointers">注記：
複数の型の~pointer装置が同時的に利用されている場合、それぞれの~pointer（各 `pointerType$m ごとに一つ）が首と見なされる。
例えば、同時に動いた ~touch接触と~mouse~cursorは，両者とも首と見なされる~pointerを生産することになる。
◎
When two or more pointer device types are being used concurrently, multiple pointers (one for each pointerType) are considered primary. For example, a touch contact and a mouse cursor moved simultaneously will produce pointers that are both considered primary.
</p>

<p class="note">注記：
~OSや~UAは、一部の装置に対し
— 偶発的なヤリトリを避けるため —
複数の型の~pointer入力の同時的な利用を無視することもある。
一例として，~touch, ~pen両者によるヤリトリを~supportする装置は、~penが利用-中にある間は
— 利用者が~touchscreen上で手を休めれるよう —
~touch入力を無視することもある（この特能は “`palm rejection^en” 
【 “手のひらが触れても~~無視する” 】
と共通的に称されている）。
現時点では、作者がこの挙動を抑止することはアリでない。
◎
Some devices, operating systems and user agents may ignore the concurrent use of more than one type of pointer input to avoid accidental interactions. For instance, devices that support both touch and pen interactions may ignore touch inputs while the pen is actively being used, to allow users to rest their hand on the touchscreen while using the pen (a feature commonly referred to as "palm rejection"). Currently, it is not possible for authors to suppress this behavior.
</p>

<p class="note">注記：
~UAが、どの~pointerも`首~pointer$とされていない下で，~pointer~eventを発火する可能性もある。
一例として、複-~touchの様な特定0の型の 作動中の~pointerが複数あって，首~pointerが除去された場合（~screenから離されたなど）、首~pointer~eventは生じない。
また、［
`首~pointer$が，（~UAを標的にしていないものも含め）装置~上で`作動中の$すべての~pointerを利用して決定される
］ような~platformにおいては、［
最初の~touch操作iは ~UAの外側を標的にしていて，（複-~touchによる） 2 度目の~touch操作iは ~UAの内側を標的にしている
］場合、~UAは， 2 度目の接触に対し、
`isPrimary$m が ~F にされた`~pointer~eventを発火-$し得る。
◎
In some cases, it is possible for the user agent to fire pointer events in which no pointer is marked as a primary pointer. For instance, when there are multiple active pointers of a particular type like multi-touch and the primary pointer is removed (e.g. it leaves the screen), there will be no primary pointer events. Also on the platforms where the primary pointer is determined using all active pointers on the device (including those targeted at an application other than the user agent), if the first touch interaction is targeted outside the user agent and a secondary (multi-touch) touch interaction is targeted inside the user agent, then the user agent may fire pointer events for the second contact with a value of false for isPrimary.
</p>

<p class="note" id="multiple-mouse-inputs">注記：
現在の~OSや~UAは、通例的に複数の~mouseによる入力の概念を備えていない。
複数の~mouse装置が在る場合（一例として、~trackpadと外部~mouseを備える~laptopなど）、一般に，それら一まとめに単独の装置に扱われる
— どの装置による移動も，単独の~mouse~pointerの移動に翻訳され、異なる~mouse装置で押される~buttonは~~区別されない。
この理由から、~mouse~pointerは通例的に一つだけあり，それが首~pointerになることになる。
<span class="trans-note">【
したがって、 2 つの~mouseがあって，それぞれの左~buttonが順に押されてから, 同じ順に離されたとき， 2 番目に押されたときと, 最初に離されたときは，無視されることになるであろう。
】</span>
◎
Current operating systems and user agents don't usually have a concept of multiple mouse inputs. When more than one mouse device is present (for instance, on a laptop with both a trackpad and an external mouse), all mouse devices are generally treated as a single device - movements on any of the devices are translated to movement of a single mouse pointer, and there is no distinction between button presses on different mouse devices. For this reason, there will usually only be a single mouse pointer, and that pointer will be primary.
</p>

			</section>
			<section id="firing-events-using-the-pointerevent-interface">
<h4 title="Firing events using the PointerEvent interface">5.1.3. `PointerEvent^I ~interfaceを利用する~eventの発火</h4>

<div class="algo">
<p>
名前 %e の
`~pointer~eventを発火する@
ときは、次を走らす：
◎
To fire a pointer event named e means to fire an event named e as defined in [DOM4]＼
</p>

<ol>
	<li>
%~event ~LET `PointerEvent$I ~interfaceを利用する新たな~event
【`~eventを作成する$( `PointerEvent$I, … ) 】
◎
with an event using the PointerEvent interface＼
</li>
	<li>
%~event の各種~属性を［
`PointerEvent$I ~interface, および
§ <a href="#attributes-and-default-actions">各種 属性と既定~動作</a>
］の定義に従って設定する
◎
whose attributes are set as defined in PointerEvent Interface and Attributes and Default Actions.
</li>
	<li>
~IF［
%e ~NIN { `gotpointercapture$et, `lostpointercapture$et }
］
⇒
%~event に対し，`処理待ち~pointer捕捉を処理-$する手続きを走らす
◎
If the event is not gotpointercapture or lostpointercapture, run Process Pending Pointer Capture steps for this PointerEvent.
</li>
	<li>
%~pointer ~LET この %~event を生じさせた`作動中の~pointer$
◎
↓</li>
	<li>
%標的 ~LET ［
%~pointer の`捕捉標的$ ~NEQ ~NULL ならば それ ／
~ELSE_ 通常の`~pointing先$
］
◎
The target object at which the event is fired is determined as follows:
◎
• If the pointer capture target override has been set for the pointer, set the target to pointer capture target override object.
◎
• Otherwise, set the target to the object returned by normal hit test mechanisms (out of scope for this specification).
</li>
	<li>
~IF［
%e ~EQ `pointerdown^et
］~AND［
%~pointer を動かしている装置は、
<a href="#implicit-pointer-capture">直接~操作~装置</a>
である
］~AND［
%標的 は `Element^I である
］
⇒
`暗黙的な~pointer捕捉$に従って
⇒
%~pointer の `pointerId$m を渡して，~pointer捕捉を %標的 に`設定-$する
◎
If this is a pointerdown event, the associated device is a direct manipulation device and the target is an Element, then set pointer capture for this pointerId to the target element as described in implicit pointer capture.
</li>
	<li>
`DOM4$r による定義に従って
⇒
`~eventを発火する$【`~eventを配送する$】( %標的, %~event )
◎
Fire the event to the determined target.
</li>
</ol>
</div>

<p class="note">注記：
通常の`~pointing先$に代えて`捕捉標的$を利用することは、何らかの`境界~event$を発火する結果になり得る。
これは、~pointerが 以前の標的から出て【 `pointerleave^et 】
，この新たな捕捉している標的に入った【 `pointerenter^et 】
場合と同じになる。
それらの標的が互いに異なる場合、`境界~event$が先ず配送されるべきである。
捕捉が解放されたときにも
— ~pointerが、捕捉している標的から出て 接触判定による標的に入るに伴い —
同じことが起こり得る。
◎
Using the pointer capture target override as the target instead of the normal hit-test result may fire some boundary events. This is the same as the pointer leaving its previous target and entering this new capturing target - and if they are different targets, boundary events should be dispatched first. When the capture is released, the same scenario may happen, as the pointer is leaving the capturing target and entering the hit-test target.
</p>

				<section id="attributes-and-default-actions">
<h5 title="Attributes and Default Actions">5.1.3.1. 各種 属性と既定~動作</h5>

<p>
この仕様にて定義される各種~event型~用の
`bubbles$m, `cancelable$m ~prop
および 既定~動作を，次の表に示す。
これらの各~event型の詳細は、
§ <a href="#pointer-event-types">各種 ~pointer~event型</a>
にて供される：
◎
The bubbles and cancelable properties and the default actions for the event types defined in this specification appear in the following table. Details of each of these event types are provided in Pointer Event types.
</p>

<table id="pointer-event-type-table">
<thead><tr><th>~event型◎ Event Type
<th>`浮上-$？◎ Bubbles
<th>`取消~可$？◎ Cancelable
<th>`既定~動作$◎ Default Action
</thead>

<!-- 
<th>Event Type<th>Bubbles<th>Cancelable<th>Default Action
 -->
<tbody>
<tr><td>`pointerover$et
<td>する
<td>可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseover

<tr><td>`pointerenter$et
<td>しない
<td>不可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseenter

<tr><td>`pointerdown$et
<td>する
<td>可 (2)
<td>`mousedown$et と同じ (1)
◎
Varies: when the pointer is primary, all default actions of the mousedown event Canceling this event also sets the PREVENT MOUSE EVENT flag for this pointerType, which prevents subsequent firing of certain compatibility mouse events.

<tr><td>`pointermove$et
<td>する
<td>可
<td>`mousemove$et と同じ (1)
◎
Varies: when the pointer is primary, all default actions of mousemove

<tr><td>`pointerup$et
<td>する
<td>可
<td>`mouseup$et と同じ (1)
◎
Varies: when the pointer is primary, all default actions of mouseup

<tr><td>`pointercancel$et
<td>する
<td>不可
<td>なし

<tr><td>`pointerout$et
<td>する
<td>可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseout

<tr><td>`pointerleave$et
<td>しない
<td>不可
<td>なし
◎
Varies: when the pointer is primary, all default actions of mouseleave

<tr><td>`gotpointercapture$et
<td>する
<td>不可
<td>なし

<tr><td>`lostpointercapture$et
<td>する
<td>不可
<td>なし

</tbody></table>

<p>
上の表における (1), (2) は：
</p>
<ul>
	<li>(1)
`既定~動作$が生じるのは、`首~pointer$に対してのみであり，対応する`~mouse~event$に対するとき同様に文脈に依存する
— 文脈に応じて適切な既定~動作が行われることになる。
</li>
	<li>(2)
`pointerdown$et を取消した場合、この~eventの `pointerType$m 用の後続の`互換性~mouse~event$（のうち一部）の発火も防止される（`~mouse~eventは防止するか$は ~T にされる）。
</li>
</ul>

<p>
上の表に挙げた どの`~pointer~event$に対しても：
`detail$m 属性 `UIEVENTS$r は 0 にされるべきである ／
［
`pointerenter$et, `pointerleave$et
］以外のものは，その `composed$m 属性 `DOM4$r は ~T にされるべきである。
◎
For all pointer events in the table above except pointerenter and pointerleave the composed ([DOM4]) attribute SHOULD be true. For all pointer events in the table above the detail [UIEVENTS] attribute SHOULD be 0.
</p>

<p class="note">注記：
多くの~UAは、旧来の内容を~supportするため，
`MouseEvent$I 内に標準でない属性［
`fromElement^m, `toElement^m
］を公開している。
標準~化された代替-（すなわち， `target^m, `relatedTarget^m ）の利用を奨励するため、そのような~UAであっても， `PointerEvent$I 内の（継承された）それらの属性は ~NULL を返すモノトスル。
◎
Many user agents expose non-standard attributes fromElement and toElement in MouseEvents to support legacy content. In those user agents, the values of those (inherited) attributes in PointerEvents must be null to encourage the use of the standardized alternates (i.e. target and relatedTarget).
</p>

<p>
MouseEvents `UIEVENTS$r 同様，
`relatedTarget$m は、［
`pointerover$et ／ `pointerenter$et
］~eventに対しては 直前の`捕捉~込みの~pointing先$, ［
`pointerout$et ／ `pointerleave$et
］~eventに対しては 新たな`捕捉~込みの~pointing先$
に初期化されるべきである。
他の~pointer~eventに対しては、この値は既定で~NULLになる。
◎
Similar to the MouseEvents [UIEVENTS] the relatedTarget should be initialized to the element whose bounds the pointer just left (in the case of a pointerover or pointerenter event) or the element whose bounds the pointer is entering (in the case of a pointerout or pointerleave). For other pointer events, this value will default to null. Note that when an element receives the pointer capture all the following events for that pointer are considered to be inside the boundary of the capturing element.
</p>

<p>
［
`gotpointercapture$et ／ `lostpointercapture$et
］~eventに対しては、上の表に定義されるものを除くすべての属性は、［
~UAに`処理待ち~pointer捕捉を処理-$させ, その~event発火させた`~pointer~event$
］のそれらと同じにされるべきである。
◎
For gotpointercapture and lostpointercapture all the attributes except the ones defined in the table above should be the same as the Pointer Event that caused the user agent to run Process Pending Pointer Capture and fire the gotpointercapture and lostpointercapture events.
</p>

				</section>
				<section id="process-pending-pointer-capture">
<h5 title="Process Pending Pointer Capture">5.1.3.2. 処理待ち~pointer捕捉を処理する</h5>

<div class="algo">
<p>
~UAは、［
~pointer捕捉を暗黙的に解放する
］とき, および［
`gotpointercapture$et, `lostpointercapture$et
］以外の`~pointer~eventを発火する$ときは，次の手続きを走らすモノトスル：
</p>

<ol>
	<li>
%~pointer ~LET 当の~eventを生じさせた`作動中の~pointer$
</li>
	<li>
%旧-標的 ~LET %~pointer の`捕捉標的$
</li>
	<li>
%新-標的 ~LET %~pointer の`処理待ち捕捉標的$
</li>
	<li>
%~pointer の`捕捉標的$ ~SET %新-標的
</li>
	<li>
~IF［
%旧-標的 ~EQ %新-標的
］
⇒
~RET
</li>
	<li>
~IF［
%旧-標的 ~NEQ ~NULL
］
⇒
%旧-標的 に向けて 名前 `lostpointercapture$et の`~pointer~eventを発火する$
</li>
	<li>
~IF［
%新-標的  ~NEQ ~NULL
］
⇒
%新-標的 に向けて 名前 `gotpointercapture$et の`~pointer~eventを発火する$
</li>
</ol>

◎
The user agent MUST run the following steps when implicitly releasing pointer capture as well as when firing Pointer Events that are not gotpointercapture or lostpointercapture.
• If the pointer capture target override for this pointer is set and is not equal to the pending pointer capture target override, then fire a pointer event named lostpointercapture at the pointer capture target override node.
• If the pending pointer capture target override for this pointer is set and is not equal to the pointer capture target override, then fire a pointer event named gotpointercapture at the pending pointer capture target override.
• Set the pointer capture target override to the pending pointer capture target override, if set. Otherwise, clear the pointer capture target override.
</div>

				</section>
			</section>
		</section>
		<section id="pointer-event-types">
<h3 title="5.2 Pointer Event types">5.2. 各種~pointer~event型</h3>

<p>
この仕様にて定義される各種~event型を以下に述べる。
◎
Below are the event types defined in this specification.
</p>

<p>
`首~pointer$に対しては、（ `gotpointercapture$et, `lostpointercapture$et を例外として）これらの~eventからは，`互換性~mouse~event$も発火され得る。
◎
In the case of the primary pointer, these events (with the exception of gotpointercapture and lostpointercapture) may also fire compatibility mouse events.
</p>

			<section id="the-pointerover-event">
<h4 title="The pointerover event">5.2.1. `pointerover^et ~event</h4>

<div class="p">
<p>
`捕捉~込みの~pointing先$が
— ~pointerが~~操作されたか, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］により —
変化したとき，新たなそれが要素であるならば、~UAは，その要素に向けて 名前 `pointerover$et の`~pointer~eventを発火する$モノトスル。
</p>

<p>
この~eventは、［
`~hoverを~supportしない$装置により `pointerdown$et ~eventが発火される
］よりも先に発火するモノトスル（ `pointerdown$et を見よ）。
</p>
◎
A user agent MUST fire a pointer event named pointerover when a pointing device is moved into the hit test boundaries of an element. Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. A user agent MUST also fire this event prior to firing a pointerdown event for devices that do not support hover (see pointerdown).
</div>

			</section>
			<section id="the-pointerenter-event">
<h4 title="The pointerenter event">5.2.2. `pointerenter^et ~event</h4>

<div >
<p>
`捕捉~込みの~pointing先$が
— ~pointerが~~操作されたか, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］により —
［
要素, および その子孫
］以外から それらのいずれかに変化した†ときは、~UAは，名前 `pointerenter$et の`~pointer~eventを発火する$モノトスル。
</p>

<p>
`~hoverを~supportしない$装置の場合、それにより `pointerdown$et ~eventが生じるとき（ `pointerdown$et を見よ）にも，新たな`捕捉~込みの~pointing先$が［
要素, または その子孫
］であるならば，
“変化した”
ものと見做される。
</p>

<p>
この型の~eventは `pointerover$et に類似するが、浮上しない点で相違する。
</p>

◎
A user agent MUST fire a pointer event named pointerenter when a pointing device is moved into the hit test boundaries of an element or one of its descendants, including as a result of a pointerdown event from a device that does not support hover (see pointerdown). Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. This event type is similar to pointerover, but differs in that it does not bubble.
</div>

<div class="trans-note">
<p>【†
すなわち、
（捕捉~込みの）~pointing先が変化したとき，
次の両~条件を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
新たな~pointing先か, または その先祖である。
</li>
	<li>
以前の~pointing先でも, その先祖でもない。
</li>
</ul>
<p>
該当する要素が複数~在る場合
（例：以前の~pointing先が存在しない場合、
新たな~pointing先と その先祖~要素~すべてが該当する）、
（ `mouseenter$et のときと同様に）
最も先祖のものから順に，この~eventを発火することになろう。
】</p>
</div>

<p class="note">注記：
［
この型の~event ,
`mouseenter$et ~event `UIEVENTS$r ,
~CSS~hover_ps 疑似類 `CSS21$r
］の間には類似性がある。
`pointerleave$et ~eventも見よ。
◎
There are similarities between this event type, the mouseenter event described in [UIEVENTS], and the CSS :hover pseudo-class described in [CSS21]. See also the pointerleave event.
</p>
			</section>
			<section id="the-pointerdown-event">
<h4 title="The pointerdown event">5.2.3. `pointerdown^et ~event</h4>

<p>
［
~pointerの~buttonが非`作動~状態$から`作動~状態$へ遷移した
］とき，`~pointing先$が要素であるならば、~UAは，その要素に向けて 名前 `pointerdown$et の`~pointer~eventを発火する$モノトスル。
【この段落の他の内容は，作動~状態の定義に移譲。】
◎
A user agent MUST fire a pointer event named pointerdown when a pointer enters the active buttons state. For mouse, this is when the device transitions from no buttons depressed to at least one button depressed. For touch, this is when physical contact is made with the digitizer. For pen, this is when the pen either makes physical contact with the digitizer without any button depressed, or transitions from no buttons depressed to at least one button depressed while hovering.
</p>

<p class="note">注記：
~mouse（または他の複-~button~pointer装置）に対しては、これは［
`mousedown$et ／ `mouseup$et
が発火されるときと同じ状況下で，常に
`pointerdown$et ／ `pointerup$et
が発火されるとは限らない
］ことを意味する。
`~buttonの追加押下げ$を見よ。
◎
For mouse (or other multi-button pointer devices), this means pointerdown and pointerup are not fired for all of the same circumstances as mousedown and mouseup. See chorded buttons for more information.
</p>

<p>
~UAは、`~hoverを~supportしない$入力~装置に対しては、
`pointerdown$et ~eventを配送するより先に，順に，名前［
`pointerover$et, `pointerenter$et
］の`~pointer~eventを発火する$モノトスル。
【~hoverを~supportする装置の~pointerが、~UIwindow外から瞬時に移動してきて，一瞬だけ静止した後，作動~状態に遷移したときの挙動と同様になる。】
◎
For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerover followed by a pointer event named pointerenter prior to dispatching the pointerdown event.
</p>

<p class="note">注記：
作者は、 `pointerdown$et ~eventを取消して（その `isPrimary$m 属性が ~T ならば），
ある種の`互換性~mouse~event$の発火を防止できる。
これは、~pointerの`~mouse~eventは防止するか$を ~T にする。
ただし、［
`mouseover$et ／ `mouseenter$et ／ `mouseout$et ／ `mouseleave$et
］~eventの発火は防止されないことに注意。
◎
Authors can prevent the firing of certain compatibility mouse events by canceling the pointerdown event (if the isPrimary property is true). This sets the PREVENT MOUSE EVENT FLAG on the pointer. Note, however, that this does not prevent the mouseover, mouseenter, mouseout, or mouseleave events from firing.
</p>

			</section>
			<section id="the-pointermove-event">
<h4 title="The pointermove event">5.2.4. `pointermove^et ~event</h4>

<p>
~pointerの座標が変化した, または［
~event~objに~~反映されるような~pointerの状態~変化がある, かつ
その状況下により 他の~pointer~eventは生産されない
］ときは、~UAは，その`~pointing先$に向けて 名前 `pointermove$et の`~pointer~eventを発火する$モノトスル。
この状態~変化には、~pointerの［
~button状態 ／ 押圧 ／ 接線方向~圧 ／ 傾き ／ ~twist ／ `接触~幾何$（例： `width$m, `height$m ）
］が含まれる。
◎
A user agent MUST fire a pointer event named pointermove when a pointer changes coordinates. Additionally, when a pointer changes button state, pressure, tangential pressure, tilt, twist, or contact geometry (e.g. width and height) and the circumstances produce no other pointer events defined in this specification then a user agent MUST fire a pointer event named pointermove.
</p>

<p class="trans-note">【
実質的には、座標の変化も後者に解釈して差し支えないであろう。
その変化は、ほぼ “~~連続的” であり，他の~eventと直交的に生じると見なせるので。
ある瞬間に，~pointerの物理的な動きと同時に`~pointing先$が変化したとしても、その変化は，座標~変化の前／後に生じたことにして十分になる
— 前／後いずれにせよ，~UI操作i~modelに現れる相違は無視できるので。
】</p>

			</section>
			<section id="the-pointerup-event">
<h4 title="The pointerup event">5.2.5. `pointerup^et ~event</h4>

<p>
［
~pointerの~buttonが`作動~状態$から非`作動~状態$へ遷移した
］ときは、~UAは，その~pointing先に向けて 名前 `pointerup$et の`~pointer~eventを発火する$モノトスル。
【この段落の他の内容は，作動~状態の定義に移譲。】
◎
A user agent MUST fire a pointer event named pointerup when a pointer leaves the active buttons state. For mouse, this is when the device transitions from at least one button depressed to no buttons depressed. For touch, this is when physical contact is removed from the digitizer. For pen, this is when the pen is removed from the physical contact with the digitizer while no button is depressed, or transitions from at least one button depressed to no buttons depressed while hovering.
</p>

<p>
`~hoverを~supportしない$入力~装置に対しては、~UAは，
`pointerup$et ~eventを配送した後に，［
順に，名前 `pointerout$et, `pointerleave$et の`~pointer~eventを発火する$
］モノトスル。
【~hoverを~supportする装置の~pointerが、非~作動~状態に遷移して，一瞬だけ静止した後，瞬時に~UIwindow外へ移動したときの挙動と同様になる。】
◎
For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerout followed by a pointer event named pointerleave after dispatching the pointerup event.
</p>

<p class="note">注記：
~mouse（または他の複-~button~pointer装置）に対しては、これは［
`mousedown$et ／ `mouseup$et
が発火されるときと同じ状況下で，常に
`pointerdown$et ／ `pointerup$et
が発火されるとは限らない
］ことを意味する。
`~buttonの追加押下げ$を見よ。
◎
For mouse (or other multi-button pointer devices), this means pointerdown and pointerup are not fired for all of the same circumstances as mousedown and mouseup. See chorded buttons for more information.
</p>
			</section>
			<section id="the-pointercancel-event">
<h4 title="The pointercancel event">5.2.6. `pointercancel^et ~event</h4>

<p>
次の状況下では、~UAは，名前 `pointercancel$et の`~pointer~eventを発火する$モノトスル：
◎
A user agent MUST fire a pointer event named pointercancel in the following circumstances:
</p>

<ul>
	<li>
~UAが、その~pointerは，それ以上~eventを生産し続ける見込みは低いと決定した場合（例えば ~hardware~eventにより【この節の末尾の注記】
）。
◎
The user agent has determined that a pointer is unlikely to continue to produce events (for example, because of a hardware event).
</li>
	<li>
<p>
`pointerdown$et ~eventが発火された後に引き続いて、~pointerは，~page表示域を操作するために利用された（例： ~pan-zoom）。
◎
After having fired the pointerdown event, if the pointer is subsequently used to manipulate the page viewport (e.g. panning or zooming).
</p>

<p class="note">注記：
~UAは，~panningや~zoomingを複数の`~pointer型$（~touchや~penなど）を通して誘発し得るので、~panや~zoom動作を開始した結果，各種~pointerは取消されることもある
— 異なる~pointer型も含め。
◎
User agents can trigger panning or zooming through multiple pointer types (such as touch and pen), and therefore the start of a pan or zoom action may result in the cancellation of various pointers, including pointers with different pointer types.
</p>
	</li>
	<li>
<p>
~pointerにより`~drag操作oが開始され$る直前。
`HTML$r
◎
Immediately before drag operation starts [HTML], for the pointer that caused the drag operation.
</p>

<p class="note">注記：
手段を問わず，~drag操作oの開始が防止された場合（例：
`dragstart$et ~event上で `preventDefault()$m を~callするなど）、
`pointercancel$et ~eventは生じなくなる。
◎
If the start of the drag operation is prevented through any means (e.g. through calling preventDefault on the dragstart event) there will be no pointercancel event.
</p>
	</li>
</ul>

<p>
~UAは、 `pointercancel$et ~eventを発火した後に，［
順に，名前 `pointerout$et, `pointerleave$et の`~pointer~eventを発火する$
］モノトスル。
◎
After firing the pointercancel event, a user agent MUST also fire a pointer event named pointerout followed by firing a pointer event named pointerleave.
</p>

<div class="note">

<p>注記：
［
~UAが，~pointerがそれ以上~eventを生産し続ける見込みは低いと決定する
］であろう局面の例には、次が挙げられる：
◎
This section is non-normative.
◎
Examples of scenarios in which a user agent might determine that a pointer is unlikely to continue to produce events include:
</p>

<ul>
	<li>
~pointerが`作動中の$間に装置の~screen方位が変化した。
◎
A device's screen orientation is changed while a pointer is active.
</li>
	<li>
利用者が、装置にて~supportされる数より大きい数の~pointerを同時に入力した。
◎
The user inputs a greater number of simultaneous pointers than is supported by the device.
</li>
	<li>
~UAは、入力が不意のものと解釈した（例えば、 `palm rejection^en を~supportする~hardware）。
◎
The user agent interprets the input as accidental (for example, the hardware supports palm rejection).
</li>
	<li>
~UAは、入力を~panまたは~zoomによる~gestureと解釈した。
◎
The user agent interprets the input as a pan or zoom gesture.
</li>

<!-- 
同じ型の別の装置による入力が生じた（例えば 2 つの~mouse）
-->
</ul>

<p>
装置の~screen方位を変化させる ／
不意の入力を認識する ／
~pointerを利用して表示域を操作する（例： ~pan-zoom）
ための手法は、この仕様の視野から外れる。
◎
Methods for changing the device's screen orientation, recognizing accidental input, or using a pointer to manipulate the viewport (e.g. panning or zooming) are out of scope for this specification.
</p>
</div>

			</section>
			<section id="the-pointerout-event">
<h4 title="The pointerout event">5.2.7. `pointerout^et ~event</h4>

<p>
`捕捉~込みの~pointing先$が
— ~pointerが~~操作されたか, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］により —
変化したとき，以前のそれが要素であるならば、~UAは，その要素に向けて 名前 `pointerout$et の`~pointer~eventを発火する$モノトスル。
ここで、次の場合も “変化した” ものと見做される：
◎
A user agent MUST fire a pointer event named pointerout when any of the following occurs:
◎
A pointing device is moved out of the hit test boundaries of an element. Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events.
</p>

<ul>
	<li>
`~hoverを~supportしない$装置により，要素に向けて
`pointerup$et ~eventが発火されたとき（ `pointerup$et を見よ）。
◎
After firing the pointerup event for a device that does not support hover (see pointerup).
</li>
	<li>
要素に向けて `pointercancel$et ~eventが発火されたとき（ `pointercancel$et を見よ）。
◎
After firing the pointercancel event (see pointercancel).
</li>
	<li>
~penや~stylusが，`~digitizer$により検出-可能な~hover範囲から出たとき。
◎
When a pen stylus leaves the hover range detectable by the digitizer.
</li>
</ul>

			</section>
			<section id="the-pointerleave-event">
<h4 title="The pointerleave event">5.2.8. `pointerleave^et ~event</h4>

<div class="p">

<p>
`捕捉~込みの~pointing先$が
— ~pointerが~~操作されたか, または［
`setPointerCapture()$m ／ `releasePointerCapture()$m
］により —
［
要素, および その子孫
］のいずれかから それら以外に変化した†ときは、~UAは，その要素に向けて 名前 `pointerleave$et の`~pointer~eventを発火する$モノトスル。
</p>

<p>
ここで，次が生じた場合も、直前の`捕捉~込みの~pointing先$が［
要素, または その ある子孫
］であった場合には， “変化した” ものと見做される：
</p>

<ul><li>~penや~stylusが，`~digitizer$により検出-可能な~hover範囲を出たとき。
</li><li>`~hoverを~supportしない$装置により
`pointerup$et ／ `pointercancel$et
~eventが生じたとき（
`pointerup$et ／ `pointercancel$et
を見よ）。
</li>
</ul>

<p>
この型の~eventは `pointerout$et に類似するが、浮上しないこと, および
~pointing装置が［
要素と そのすべての子孫が成す境界
］を出るまでは，発火されないモノトスル点で相違する。
</p>

◎
A user agent MUST fire a pointer event named pointerleave when a pointing device is moved out of the hit test boundaries of an element and all of its descendants, including as a result of a pointerup and pointercancel events from a device that does not support hover (see pointerup and pointercancel). Note that setPointerCapture or releasePointerCapture might have changed the hit test target and while a pointer is captured it is considered to be always inside the boundaries of the capturing element for the purpose of firing boundary events. User agents MUST also fire a pointer event named pointerleave when a pen stylus leaves hover range detectable by the digitizer. This event type is similar to pointerout, but differs in that it does not bubble and that it MUST not be fired until the pointing device has left the boundaries of the element and the boundaries of all of its descendants.
</div>

<div class="trans-note">
<p>【†
すなわち、
（捕捉~込みの）~pointing先が変化したとき，
次の両~条件を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
以前の~pointing先か, または その先祖である。
</li>
	<li>
新たな~pointing先でも, その先祖でもない。
</li>
</ul>
<p>
該当する要素が複数~在る場合
（例：新たな~pointing先が存在しない場合、
以前の~pointing先と その先祖~要素~すべてが該当する）、
（ `pointerenter$et のときとは逆順に）
最も子孫のものから順に，この~eventを発火することになろう。
】</p>
</div>

<p class="note">注記：
［
この型の~event,
`mouseleave$et ~event `UIEVENTS$r,
~CSS~hover_ps 疑似類 `CSS21$r
］の間には類似性がある。

`pointerenter$et ~eventも見よ。
◎
There are similarities between this event type, the mouseleave event described in [UIEVENTS], and the CSS :hover pseudo-class described in [CSS21]. See also the pointerenter event.
</p>
			</section>
			<section id="the-gotpointercapture-event">
<h4 title="The gotpointercapture event">5.2.9. `gotpointercapture^et ~event</h4>

<p>
~pointerが要素に`捕捉$されたときは、~UAは，その要素に向けて 名前 `gotpointercapture$et の`~pointer~eventを発火する$モノトスル。
その~pointer用の後続の~eventは、この要素に向けて発火されることになる。
［
§ `~pointer捕捉の設定-法$ ／
§ `処理待ち~pointer捕捉を処理-$する
］を見よ。
◎
A user agent MUST fire a pointer event named gotpointercapture when an element receives pointer capture. This event is fired at the element that is receiving pointer capture. Subsequent events for that pointer will be fired at this element. See the Setting Pointer Capture and Process Pending Pointer Capture sections.
</p>
			</section>
			<section id="the-lostpointercapture-event">
<h4 title="The lostpointercapture event">5.2.10. `lostpointercapture^et ~event</h4>

<p>
要素による`~pointer捕捉$が解放されたときは、~UAは，その要素に向けて 名前 `lostpointercapture$et の`~pointer~eventを発火する$モノトスル。
この~eventは、~pointerが捕捉から解放された後に生じるどの~eventよりも先に発火するモノトスル。
~pointerによる後続の~eventの標的は、通常の`~pointing先$になる。
`~pointer捕捉の解放-法$ ／
§ <a href="#implicit-release-of-pointer-capture">~pointer捕捉の暗黙的な解放-</a> ／
§ `処理待ち~pointer捕捉を処理-$する
を見よ。
◎
A user agent MUST fire a pointer event named lostpointercapture after pointer capture is released for a pointer. This event MUST be fired prior to any subsequent events for the pointer after capture was released. This event is fired at the element from which pointer capture was removed. Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. See the Releasing Pointer Capture, Implicit Release of Pointer Capture, and Process Pending Pointer Capture sections.
</p>
				</section>
			</section>
		</section>
		<section id="extensions-to-the-element-interface">
<h2 title="Extensions to the Element interface">6. `Element^I ~interfaceに対する拡張</h2>

<p>
以下の各~節では、 `HTML5$r にて定義される既存の `Element^I ~interfaceに対する拡張を述べる。
これにより、~scriptは，~pointer捕捉を設定-／解放できるようになる。
◎
The following section describes extensions to the existing Element interface, defined in [HTML5], to facilitate the setting and releasing of pointer capture.
</p>

<pre class="idl">
partial interface `Element!I {
    undefined `setPointerCapture$m(long %pointerId);
    undefined `releasePointerCapture$m(long %pointerId);
    boolean `hasPointerCapture$m(long %pointerId);
};
</pre>

<dl class="idl-def">

	<dt>`setPointerCapture(pointerId)@m</dt>
	<dd>
コレが［
%pointerId により識別される~pointer
］を`捕捉$するよう`設定-$する。
この~pointerにより生じる後続の~eventに対しては、当の~pointerが常に それを捕捉している標的に重なっているかのように，通常の接触判定の結果は標的に置き換えられ、この捕捉が解放されるまで，常にコレを標的にするモノトスル。
この~methodが有効になるのは，~pointerの~buttonが`作動~状態$にあるときに限られ、そうでなければ，何もしないモノトスル。
%pointerId が`作動中の$どの~pointerにも合致しない場合、
`NotFoundError^E 例外が投出される。
◎
Sets pointer capture for the pointer identified by the argument pointerId to the element on which this method is invoked. For subsequent events of the pointer, the capturing target will substitute the normal hit testing result as if the pointer is always over the capturing target, and they MUST always be targeted at this element until capture is released. The pointer MUST be in its active buttons state for this method to be effective, otherwise it fails silently. Throws a DOMException with the name NotFoundError when the provided method's argument does not match any of the active pointers.
</dd>
	<dd class="trans-note">【
~methodの定義は、§ `~pointer捕捉の設定-法$に。
】</dd>

	<dt>`releasePointerCapture(pointerId)@m</dt>
	<dd>
コレが`捕捉$している［
%pointerId により識別される~pointer
］を`明示的に解放-$する。
すなわち、~pointerにより生じる後続の~eventにおける標的は、通常の`~pointing先$になる。
%pointerId が`作動中の$どの~pointerにも合致しない場合、
`NotFoundError^E 例外が投出される。
◎
Releases pointer capture for the pointer identified by the argument pointerId from the element on which this method is invoked. Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. Throws a DOMException with the name NotFoundError when the provided the method's argument does not match any of the active pointers.
</dd>
	<dd class="trans-note">【
~methodの定義は、§ `~pointer捕捉の解放-法$に。
】</dd>

	<dt>`hasPointerCapture(pointerId)@m</dt>
	<dd>
コレが［
%pointerId により識別される~pointer
］を`捕捉$しているかどうかを指示する。
すなわち、［
%pointerId 用の`処理待ち捕捉標的$ ~EQ コレ ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Indicates whether the element on which this method is invoked has pointer capture for the pointer identified by the argument pointerId. In particular, returns true if the pending pointer capture target override for pointerId is set to the element on which this method is invoked, and false otherwise.
</dd>
	<dd class="note">注記：
この~methodは、 `setPointerCapture()$m を~callした直後において，当の要素が まだ `gotpointercapture$et ~eventを受取っていなくても、 ~T を返す。
その結果、 `pointerdown$et ~event用の~listenerの内側から `暗黙的な~pointer捕捉$を検出するときに有用になる。
◎
This method will return true immediately after a call to setPointerCapture, even though that element will not yet have received a gotpointercapture event. As a result it can be useful for detecting implicit pointer capture from inside of a pointerdown event listener.
</dd>

</dl>

		</section>
		<section id="extensions-to-the-globaleventhandlers-interface">
<h2 title="Extensions to the GlobalEventHandlers mixin">7. `GlobalEventHandlers^I ~mixinに対する拡張</h2>

<p>
この節では、既存の `GlobalEventHandlers$I ~mixin `HTML5$r に対し，~event~handlerを登録し易くするための拡張を述べる。
◎
The following section describes extensions to the existing GlobalEventHandlers interface, defined in [HTML5], to facilitate the event handler registration.
</p>

<pre class="idl">
partial interface mixin `GlobalEventHandlers!I {
    attribute `EventHandler^I `ongotpointercapture@m;
    attribute `EventHandler^I `onlostpointercapture@m;
    attribute `EventHandler^I `onpointerdown@m;
    attribute `EventHandler^I `onpointermove@m;
    attribute `EventHandler^I `onpointerup@m;
    attribute `EventHandler^I `onpointercancel@m;
    attribute `EventHandler^I `onpointerover@m;
    attribute `EventHandler^I `onpointerout@m;
    attribute `EventHandler^I `onpointerenter@m;
    attribute `EventHandler^I `onpointerleave@m;
};
</pre>

<p>
これらの属性は、いずれも，対応する名前の~event型~用の`~event~handler~IDL属性$ `HTML5$r である。
◎
ongotpointercapture
◎
The event handler IDL attribute (see [HTML5]) for the gotpointercapture event type. 
◎
onlostpointercapture
◎
The event handler IDL attribute (see [HTML5]) for the lostpointercapture event type. 
◎
onpointerdown
◎
The event handler IDL attribute (see [HTML5]) for the pointerdown event type.
◎
onpointermove
◎
The event handler IDL attribute (see [HTML5]) for the pointermove event type.
◎
onpointerup
◎
The event handler IDL attribute (see [HTML5]) for the pointerup event type.
◎
onpointercancel
◎
The event handler IDL attribute (see [HTML5]) for the pointercancel event type.
◎
onpointerover
◎
The event handler IDL attribute (see [HTML5]) for the pointerover event type.
◎
onpointerout
◎
The event handler IDL attribute (see [HTML5]) for the pointerout event type.
◎
onpointerenter
◎
The event handler IDL attribute (see [HTML5]) for the pointerenter event type.
◎
onpointerleave
◎
The event handler IDL attribute (see [HTML5]) for the pointerleave event type.
</p>

		</section>
		<section id="extensions-to-the-navigator-interface">
<h2 title="Extensions to the Navigator interface">8. `Navigator^I ~interfaceに対する拡張</h2>

<p>
装置の検出~supportを供するため、この仕様は，
`Navigator^I ~interface `HTML5$r を拡張する。
◎
The Navigator interface is defined in [HTML5]. This specification extends the Navigator interface to provide device detection support.
</p>

<pre class="idl">
partial interface `Navigator!I {
    readonly    attribute long `maxTouchPoints$m;
};
</pre>

<dl class="idl-def">

	<dt>`maxTouchPoints@m</dt>
	<dd>
装置により~supportされる同時~touch接触の最大~数。
複数の`~digitizer$を備える装置の事例では（例： 複数の~touchscreen）、値は，［
個々の~digitizerにより~supportされる最大~接触~数
］のうちの最大になるモノトスル。
◎
The maximum number of simultaneous touch contacts supported by the device. In the case of devices with multiple digitizers (e.g. multiple touchscreens), the value MUST be the maximum of the set of maximum supported contacts by each individual digitizer.
</dd>
	<dd class="example">
例えば、装置が 3 つの~touchscreenを備えていて
~supportする同時~touch接触~数が 2, 5, 10 ならば、
`maxTouchPoints$m 値は `10^c にされるべきである。
◎
For example, suppose a device has 3 touchscreens, which support 2, 5, and 10 simultaneous touch contacts, respectively. The value of maxTouchPoints should be 10.
</dd>

</dl>

<p class="note">注記：
`maxTouchPoints$m に対する 0 より大きい値が，利用者の装置が~touch入力を~supportすることを指示するとしても、利用者が~touch入力を利用している`とは限らない^em。
作者は、［
~mouse, ~pen, ~screenreader, 等々
］，~system上に在り得る他の入力~様式も考慮するよう気を付けるべきである。
◎
While a maxTouchPoints value of greater than 0 indicates the user's device is capable of supporting touch input, it does not necessarily mean the user will use touch input. Authors should be careful to also consider other input modalities that could be present on the system, such as mouse, pen, screen readers, etc.
</p>

<p class="note">注記：
`maxTouchPoints$m は、［
現在の~hardwareでも，内容の対話~modelを認識できるようにする
］ことを確保するために利用されることが多い。
~hardware~~能力がより限られた下でも、利用者に~UI ~affordancesを供することはできる。
精確な最大~接触~数が既知でない~platform上では、認識されることが保証される最小~数が供される。
したがって、認識される~touch接触~数が `maxTouchPoints$m の値を超過する可能性もある。
◎
maxTouchPoints is often used to ensure that the interaction model of the content can be recognized by the current hardware. UI affordances can be provided to users with less capable hardware. On platforms where the precise number of touch points is not known, the minimum number guaranteed to be recognized is provided. Therefore, it is possible for the number of recognized touch points to exceed the value of maxTouchPoints.
</p>

	</section>
	<section id="declaring-candidate-regions-for-default-touch-behaviors">
<h2 title="Declaring candidate regions for default touch behaviors">9. ~touch用の既定の挙動~用の候補~領域の宣言-法</h2>

<!-- `PointerEvent!I -->

<p>
~touch入力に対しては、どの`~pointer~event$であれ，その`既定~動作$は 表示域の操作（例： ~pan-zoom）にならないモノトスル。
◎
For touch input, the default action of any and all pointer events MUST NOT be a manipulation of the viewport (e.g. panning or zooming).
</p>

<p class="note">注記：
~touch操作は、意図的に，~pointer~eventの`既定~動作$にされていない。
この，［
~eventの取消nに対する依存関係
］を除去することは、~UAによる処理能の最適化を手助けするためである。
◎
Touch manipulations are intentionally not a default action of pointer events. Removing this dependency on the cancellation of events facilitates performance optimizations by the user agent.
</p>

<p class="note">注記：
表示域の操作-時に利用される~pointerに関する課題は，一般に~touch入力に限られるが（利用者の手指が，内容とのヤリトリ-にも, ~pageの~pan／~zoomにも利用され得る所で）、他の`~pointer型$に対しても（直接的／間接的を問わず）同じ型の操作を許容する~UAも中にはある。
一例として，携帯~装置／~tablet装置においては、利用者は~stylusを利用して~panすることもできるかもしれない。
この節は、そのような局面にも適用される（この仕様における語 “~touch” の用-法にかかわらず）。
◎
While the issue of pointers used to manipulate the viewport is generally limited to touch input (where a user's finger can both interact with content and pan/zoom the page), certain user agents may also allow the same types of (direct or indirect) manipulation for other pointer types. For instance, on mobile/tablet devices, users may also be able to pan using a stylus. This section applies to these scenarios as well (despite the specification's use of "touch").
</p>

		<section id="the-touch-action-css-property">
<h3 title="The touch-action CSS property">9.1. `touch-action^p ~CSS~prop</h3>

◎名 `touch-action@p
◎値 `auto$v | `none$v | [ `pan-x$v || `pan-y$v ] | `manipulation$v
◎初 `auto$v
◎適 
次を除くすべての要素：
`置換され$ない 【行内】要素, ~tableの［
`row^v, `row-group^v, `column^v, `column-group^v
］
◎
all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups.
◎継 されない
◎百 受容しない
◎算 指定d値
◎表終

<p>
`touch-action$p ~CSS~propは、~touch入力により，~UAが給する既定の挙動が誘発されてよいかどうかを決定する。
これには、少なくとも，~pan-zoomの挙動が含まれる。
§ <a href="#details-of-touch-action-values">`touch-action^p 値</a>
を見よ。
◎
The touch-action CSS property determines whether touch input MAY trigger default behavior supplied by user agent. This includes, but is not limited to, behaviors such as panning or zooming. See the section on touch-action values.
</p>

<p class="note">注記：
先に注記したように、~touch以外の`~pointer型$にも既定の挙動（~panningや~zoomingなど）を許容する~UAは，その種の~pointer型にも~touchと同じように適用するモノトスル。
一例として，~stylusによる~panning／~zoomingを許容する~UAは、どの既定の挙動を取扱うかを決定する際に，関連な `touch-action^p 値を織り込むモノトスル。
◎
As noted previously, in the case of user agents that allow default behaviors (such as panning or zooming) for other pointer types, these user agents MUST apply the same consideration for those pointer types. For instance, if a user agent allows panning/zooming with a stylus, the user agent must take into account the relevant touch-action value when determining which default behaviors it should handle.
</p>

<p>
~UAは、`~touch用の既定の挙動$を実行している間は，その~pointerよる後続の`~pointer~eventを発火-$しないモノトスル。
~UAは、次のすべてが成立するときは、~pointerによる`~event連列$を終わらせるため，名前 `pointercancel$et の`~pointer~eventを発火する$モノトスル（それに伴い， `pointerout$et ~event, 一つ以上の `pointerleave$et ~eventも発火されることになる）：
◎
During the execution of a user agent touch behavior, the user agent MUST NOT fire subsequent pointer events for the pointer. The user agent MUST fire a pointer event named pointercancel (and subsequently a pointerout event and one or more pointerleave events) whenever all of the following are true, in order to end the stream of events for the pointer:
</p>

<ul>
	<li>
~UAは、その~touch入力を，`~touch用の既定の挙動$用に消費するものと決定した（その決定-法は、この仕様の視野から外れる）。
◎
The user agent has determined (via methods out of scope for this specification) that touch input is to be consumed for a touch behavior,
</li>
	<li>
【その`~event連列$において】
~pointer用の `pointerdown$et ~eventは、すでに送信した。
◎
a pointerdown event has been sent for the pointer, and
</li>
	<li>
~pointer用の［
（前項の `pointerdown$et に後続する）
`pointerup$et
］ ／ `pointercancel$et
~eventは、まだ送信していない。
◎
a pointerup or pointercancel event (following the above mentioned pointerdown) has not yet been sent for the pointer.
</li>
</ul>

<p class="note">注記：
~UAは、既定の挙動~用に［
一連の別々な~gestureを孕むが，それらすべてが単独の継続的な~gestureを成すものとして扱われる
］ような複階的な~gestureを実装してもヨイ。
例えば、利用者が~touchscreen上で “投げつける” ように~scrollする（ “`fling to scroll^en” ）~gestureを考える
— 敏捷な手指の動きで，文書の~panningを開始して, ~touchscreenから手指を~~離したとき，文書は惰性で~scrollし続けるような。
文書がまだ動いている間、利用者は，~touchscreenに手指を置いて別の “投げつけ” を実行するかもしれない
— 現在の~scrollingに対し、もっと勢いをつけるか，制動して［
遅める／停止する／逆~方向にする
］ような。
この仕様は、~gestureと既定の挙動がどう実装されるかは、規範的に定義しない
— 2 度目の~touchが（現在の~scrollingに対する 2 度目の “投げつけ” ／制動として解釈される前に）~pointer~eventを発火するべきかどうか裁定するのは、~UAに委ねられる。
◎
User agents may implement complex gestures for default behaviors that involve a series of separate discrete gestures, but which are all treated as part of a single continuous gesture. For example, consider a "fling to scroll" gesture on a touchscreen: a user starts panning the document with a rapid finger movement, lifts the finger from the touchscreen, and the document continues scrolling with simulated inertia. While the document is still moving, the user may place their finger on the touchscreen and execute another "fling" to provide further momentum for the scrolling, or counteract the current scrolling to slow it down, stop scrolling altogether, or reverse the direction of the scrolling. As this specification does not normatively define how gestures and default behaviors are implemented, it is left up to the user agent to decide whether or not the second touch (before it is interpreted as a second "fling" or counteraction of the current scrolling) should fire pointer events or not.
</p>

		</section>
		<section id="determining-supported-touch-behavior">
<h3 title="Determining supported touch behavior">9.2. ~touchの挙動の決定-法</h3>

<p>
利用者による~touchに対する効果は、［
要素とその各~先祖
］上の［
`touch-action$p ~propの値, および
`~touch用の既定の挙動$
］により，次に従って決定される：
◎
When a user touches an element, the effect of that touch is determined by the value of the touch-action property, and the default touch behaviors of the element and its ancestors, as follows:
</p>

<ul>
	<li>
~touchの挙動は、要素の座標~空間にて許容されるならば，要素の `touch-action$p に
`適合する@
とされる。
~CSS変形が適用されている場合、要素の座標~空間は，ここでの適合-度に影響する仕方で~screen座標から異なり得ることに注意。
例えば，要素の X 軸が~screenを基準に 90° 回転されている場合、~screen座標~空間の Y 軸に平行になる。
◎
A touch behavior conforms to an element's touch-action if the behavior is allowed in the coordinate space of the element. Note that if CSS transforms have been applied, the element's coordinate space may differ from the screen coordinate in a way to affect the conformity here; for example, the X axis of an element rotated by 90 degrees with respect to the screen will be parallel to the Y-axis of the screen coodinate.
</li>
	<li>
<p>
~UAが`~touch用の既定の挙動$を~supportするのは、その挙動が，［
次に与える %E から %F まで
］の どの要素の `touch-action$p ~propにも`適合する$ときになる
— ここで：
</p>

<ol><li>%E は、~touchの`~pointing先$。
</li><li>%F は、［
%E, および %E の各~先祖
］のうち，`~touch用の既定の挙動$を有するような要素であって，最も子孫~側のもの。
</li></ol>
◎
A touch behavior is supported if it conforms to the touch-action property of each element between the hit tested element and its nearest ancestor with the default touch behavior (including both the hit tested element and the element with the default touch behavior).
</li>
	<li>
~touch動作が開始され，［
その動作を~touch用の既定の挙動として取扱うべきかどうか
］を~UAが決定して以降は、その動作が終わるまでは，関連な `touch-action$p 値を変更しても無視されることになる。
一例として、要素~上の `touch-action$p 値を，~scriptの `pointerdown$et ~handlerの中で~program的に `auto^v から `none^v に変更しても、~pointerが作動中にある限り，~UAがその~touch用の既定の挙動を中止したり抑止することはない。
◎
Once a touch action has been started, and the user agent has already determined whether or not the action should be handled as a user agent touch behavior, any changes to the relevant touch-action value will be ignored for the duration of the touch action. For instance, programmatically changing the touch-action value for an element from auto to none as part of a pointerdown handler script will not result in the user agent aborting or suppressing any default touch behavior for that touch for as long as that pointer is active.
</li>
</ul>

<p class="note">注記：
一部の~UAは、［
複数の同時的~pointerによる操作i
］により誘発される~touch動作も~supportする（例：複-~touch）。
複数の同時的~pointerに対し `touch-action$p 値を
処理したり／結付ける
ための手法は、この仕様の視野から外れる。
◎
Some user agents support touch actions triggered by interactions of multiple concurrent pointers (e.g. multi-touch). Methods for processing or associating the touch-action values of multiple concurrent pointers is out of scope for this specification.
</p>

		</section>
		<section id="details-of-touch-action-values">
<h3 title="Details of touch-action values">9.3. `touch-action^p 値の詳細</h3>

<dl>
	<dt>`auto@v</dt>
	<dd>
~UAは、要素~上から始まる`~touch用の既定の挙動$を~~任意に決定してヨイ。
◎
The user agent MAY determine any permitted touch behaviors, such as panning and zooming of the viewport, for touches that begin on the element.
</dd>

	<dt>`none@v</dt>
	<dd>
~UAは、要素~上から始まる`~touch用の既定の挙動$を誘発しないモノトスル。
◎
Touches that begin on the element MUST NOT trigger default touch behaviors.
</dd>

	<dt>`pan-x@v</dt>
	<dt>`pan-y@v</dt>
	<dd>
これらの~~成分~値の組み合わせに対しては、~UAは、要素で始まる~touchを，［
各~~成分が表す各~軸~方向への~scrollingを開始する目的
］に限って考慮してもヨイ。
【例えば `pan-y^v のみならば縦のみ， `pan-x pan-y^v ならば縦横両方とも。】
◎
The user agent MAY consider touches that begin on the element only for the purposes of scrolling that starts in any of the directions specified by all of the listed values.＼
</dd>
	<dd>
~scrollingが開始されてから，利用者が~scrollできる方向は、単独の軸に制約されている場合には（例： `pan-y^v ），その軸に限られる。
【原文には “逆~方向へ~scrollできる” という記述もあるが、<a href="https://github.com/w3c/pointerevents/commit/17647a38cf3dac4d200953417f27202de5f2febd">仕様~更新</a>により~~意味を成さなくなったので，和訳は省略する。】
◎
Once scrolling is started, the direction may be reversed by the user even if scrolls that start in the reversed direction are disallowed. In contrast, when scrolling is restricted to starting along a single axis (eg. pan-y), the axis cannot be changed during the scroll.
</dd>

	<dt>`manipulation@v</dt>
	<dd>
~UAは、要素~上で始まる~touchを，［
~scrollingと継続的な~zooming
］の目的に限って考慮してもヨイ。
`auto$v において~supportされる 他のどの挙動も，この仕様の視野から外れる。
◎
The user agent MAY consider touches that begin on the element only for the purposes of scrolling and continuous zooming. Any additional behaviors supported by auto are out of scope for this specification.
</dd>

</dl>

<p class="note">注記：
各 実装に共通な追加的な `touch-action$p 値も，
`COMPAT$r にて
<a href="~COMPAT#touch-action">定義されている</a>。
◎
Additional touch-action values common in implementations are defined in [COMPAT].
</p>

<p class="note">注記：
用語
“~pan” と “~scroll”
は、同義語と見なされる。
［
~panningや~scrollingを誘発する操作iや~gestureを定義すること ／
`auto$v や `none$v 値~用の誘発の挙動
］は、この仕様の視野から外れる。
◎
The terms "pan" and "scroll" are considered synonymous. Defining an interaction or gesture for triggering panning or scrolling, or for triggering behavior for the auto or none values are out of scope for this specification.
</p>

<p class="note">注記：
`touch-action$p ~propを適用し得る要素は、~CSS `width$p, `height$p ~prop `CSS21$r のいずれも適用し得るものに限られる。
この制約は、~UAが~touch動作の応答性を最適化し易くするための設計である。
`span^e （ `HTML5$r）などの`置換され$ない`行内~要素$など，既定では~supportされない要素~用には、作者は，~CSS `display$p ~propに［
`block^v などの `width^p, `height^p を適用し得る値
］を設定できる。
将来の仕様は、この~APIをすべての要素にまで拡張し得る。
◎
The touch-action property only applies to elements that support both the CSS width and height properties (see [CSS21]). This restriction is designed to facilitate user agent optimizations for low-latency touch actions. For elements not supported by default, such as &lt;span&gt; which is a non-replaced inline element (see [HTML5]), authors can set the display CSS property to a value, such as block, that supports width and height. Future specifications could extend this API to all elements.
</p>

<p class="note">注記：
一部の`~touch用の既定の挙動$を不能化すると、~UAによる他の挙動に対する応答が素早くなることもある。
例えば，~UAによっては、~double-tap ~gestureを取扱えるようにするため，
`click^et の前に 300ms ほどの遅延を自動的に入れるものもある。
そのような事例では、
`touch-action$p に明示的に値［
`none$v ／ `manipulation$v
］を設定することにより，この遅延は除かれることになる。
~tapや~double-tap ~gestureを決定するための手法については、この仕様の視野から外れることに注意。
◎
Note
Disabling some default touch behaviors may allow user agents to respond to other behaviors more quickly. For example, with auto user agents typically add 300ms of delay before click to allow for double-tap gestures to be handled. In these cases, explicitly setting touch-action: none or touch-action: manipulation will remove this delay. Note that the methods for determining a tap or double-tap gesture are out of scope for this specification.
</p>

		</section>

<div class="example">
<p>`6@ex：
~touchの挙動をすべて許容しない例：
◎
Disallowing all touch behaviors
</p>

<pre class="lang-html">
&lt;div style="touch-action: none;"&gt;
<span class="comment">
この要素は、すべての~touchに対し~pointer~eventを受取る。
◎
This element receives pointer events for all touches.
</span>
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>`7@ex：
横方向への~panningに限り許容する例：
◎
Allowing horizontal panning only
</p>

<pre class="lang-html">
&lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、横方向へ~panしていないときは~pointer~eventを受取る
◎
This element receives pointer events when not panning in the horizontal direction.
</span>
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>`8@ex：
~touchの挙動を許容しない子~領域がある例：
◎
Child regions that disallow touch behaviors
</p>

<pre class="lang-html">
&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: none;"&gt;
<span class="comment">
この要素は、すべての~touchに対し~pointer~eventを受取る。
◎
This element receives pointer events for all touches.
</span>
    &lt;/div&gt;
    &lt;div&gt;
<span class="comment">
この要素~上の~touchは、親を操作するために消費され得る。
◎
Touches on this element MAY be consumed for manipulating the parent.
</span>
    &lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>`9@ex：
~touchの挙動を許容しない親が挟まれている例：
◎
Intermediate parent that disallows touch behaviors
</p>
<pre class="lang-html">
&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: pan-y;"&gt;
        &lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、すべての~touchに対し~pointer~eventを受取る
— 横方向への~panningのみを許容する要素と `auto$v 先祖との間には，縦方向の~panningのみを許容する先祖があるので。
したがって、要素に対しては，`~touch用の既定の挙動$は許容されない。
◎
This element receives pointer events for all touches because
it allows only horizontal panning yet an intermediate ancestor 
(between it and the pannable element) only allows vertical panning. 
Therefore, no touch behaviors are allowed.
</span>
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

	</section>
	<section id="pointer-capture">
<h2 title="Pointer Capture">10. ~pointer捕捉</h2>

		<section id="introduction">
<h3 title="Introduction">10.1. 序論</h3>

~INFORMATIVE

<p>
~pointer捕捉により、特定0の~pointerから生じる各~event（`互換性~mouse~event$も含む）の標的を、通常の`~pointing先$でない，特定0の要素にすることが可能になる。
これは、（ `&lt;input type="range"&gt;^e ~control `HTML5$r に類する）~custom~slider~controlを作るときなどに有用になる。
~pointer捕捉を ~slider~thumbの要素~上に設定すれば、利用者は，~pointerがその~thumbからそれたときにも ~controlを前後に~slideさせられるようになる。
◎
Pointer capture allows the events for a particular pointer (including any compatibility mouse events) to be retargeted to a particular element other than the normal hit test result of the pointer's location. This is useful in scenarios like a custom slider control (e.g. similar to the [HTML5] &lt;input type="range"&gt; control). Pointer capture can be set on the slider thumb element, allowing the user to slide the control back and forth even if the pointer slides off of the thumb.
</p>

<figure id="figure_slider">
【！slider.png】
<div style="margin: 0.5em;" aria-label="Custom Volume Slider">
<span style="vertical-align:middle;">音量：</span>
<div style="vertical-align:middle;
	display:inline-block;
	position:relative;
	border:solid silver 0.2em;
	width:15em;"
><div style="position:absolute;
	left:8em;
	top:-0.8em;
	width:1em;
	height:1.6em;
	background: black;
"></div></div>
</div>

<figcaption>
~thumb要素を前後に~slideして値を選ぶような，~custom~slider~controlの例。
~thumb上で `pointerdown$et が生じたとき，~pointer捕捉を利用すれば、利用者は，~pointerが~sliderからそれても ~slideできるようになる。
◎
Example of a custom slider control that chooses a value by sliding the thumb element back and forth. After pointerdown on the thumb, pointer capture can be used to allow the user to slide the thumb even if the pointer drifts off of it.
</figcaption></figure>

		</section>
		<section id="setting-pointer-capture">
<h3 title="Setting Pointer Capture">10.2. ~pointer捕捉の設定-法</h3>

<div class="algo">
<p>
要素による~pointer捕捉は、
要素の `setPointerCapture(pointerId)$m ~methodにより設定される。
その~method手続きは：
◎
Pointer capture is set on an element by calling the element.setPointerCapture(pointerId) method. When this method is invoked, a user agent MUST run the following steps:
</p>
<ol>
	<li>
~IF［
%pointerId は、`作動中の$どの~pointerにも合致しない
］
⇒
~THROW `NotFoundError^E
◎
If the pointerId provided as the method's argument does not match any of the active pointers, then throw a DOMException with the name NotFoundError.
</li>
	<li>
~IF［
コレは`接続されて$いない `DOM4$r
］
⇒
~THROW `InvalidStateError^E
◎
If the Element on which this method is invoked is not connected ([DOM4]), throw an exception with the name InvalidStateError.
</li>
	<li>
~IF［
コレは~lockされている `PointerLock$r
］
⇒
~THROW `InvalidStateError^E
◎
If this method is invoked while the document has a locked element ([PointerLock]), throw an exception with the name InvalidStateError.
</li>
	<li>
%~pointer ~SET %pointerId に合致する`作動中の~pointer$
◎
↓</li>
	<li>
~IF［
%~pointer の~buttonは`作動~状態$でない
］
⇒
~RET
◎
If the pointer is not in the active buttons state, then terminate these steps.
</li>
	<li>
%~pointer の`処理待ち捕捉標的$ ~SET コレ
◎
For the specified pointerId, set the pending pointer capture target override to the Element on which this method was invoked.
</li>
</ol>
</div>

		</section>
		<section id="releasing-pointer-capture">
<h3 title="Releasing Pointer Capture">10.3. ~pointer捕捉の解放-法</h3>

<div class="algo">
<p>
要素による~pointer捕捉は、
要素の `releasePointerCapture(pointerId)$m ~methodにより，明示的に解放できる。
その~method手続きは：
◎
Pointer capture is released on an element explicitly by calling the element.releasePointerCapture(pointerId) method. When this method is called, a user agent MUST run the following steps:
</p>
<ol>
	<li>
~IF［
%pointerId は、`作動中の$どの~pointerにも合致しない
<!-- ＊
］~AND［
この手続きは、
<a href="#implicit-release-of-pointer-capture">~pointer捕捉の暗黙的な解放-</a>
の結果として呼出されていない
 -->
］
⇒
~THROW `NotFoundError^E
◎
If the pointerId provided as the method's argument does not match any of the active pointers and these steps are not being invoked as a result of the implicit release of pointer capture, then throw a DOMException with the name NotFoundError.
</li>
	<li>
%~pointer ~SET %pointerId に合致する`作動中の~pointer$
◎
↑</li>
	<li>
~IF［
%~pointer の`処理待ち捕捉標的$ ~EQ コレ
（すなわち，コレの `hasPointerCapture$m ~EQ ~T ）
］
⇒
%~pointer の`処理待ち捕捉標的$ ~SET ~NULL
◎
If hasPointerCapture is false for the Element with the specified pointerId, then terminate these steps.
◎
For the specified pointerId, clear the pending pointer capture target override, if set.
</li>
</ol>
</div>

		</section>
		<section id="implicit-pointer-capture">
<h3 title="Implicit Pointer Capture">10.4. 暗黙的な~pointer捕捉</h3>

<p>
一部の入力~装置（~touchscreenなど）は、
“直接~操作” の~metaphorを実装する 
— そこでの~pointerは、首に~UI要素~上で作動中になるように動作するものと意図される（ ~cursorを介して，~UI上を概念的に浮動する間接的な接触に代わって，物理的な直接~接触に錯覚させるような）。
そのような装置は、 `InputDeviceCapabilities.pointerMovementScrolls$m ~propにより識別され、次のような “暗黙的な~pointer捕捉” の挙動を備えるべきである。
◎
Some input devices (such as touchscreens) implement a "direct manipulation" metaphor where a pointer is intended to act primarily on the UI element it became active upon (providing a physical illusion of direct contact, instead of indirect contact via a cursor that conceptually floats above the UI). Such devices are identified by the InputDeviceCapabilities.pointerMovementScrolls property and should have "implicit pointer capture" behavior as follows.
</p>

<p>
直接~操作 装置は、正確に，［
`pointerdown^et 用の~listenerが呼出される直前に，標的~要素~上で `setPointerCapture()$m が~callされた
］かのように挙動するべきである。
これが生じたかどうかは、
`hasPointerCapture()$m ~APIを利用して決定できる（例えば `pointerdown^et ~listenerの中で）。
次回に~pointer~eventが発火される前に，~pointerに対し `releasePointerCapture()$m が~callされなかった場合、 `gotpointercapture$et ~eventは，標的に（通常通り）配送されることになり、その捕捉が作動中であることを指示する。
◎
Direct manipulation devices should behave exactly as if setPointerCapture was called on the target element just before the invocation of any pointerdown listeners. The hasPointerCapture API may be used (eg. within any pointerdown listener) to determine whether this has occurred. If releasePointerCapture is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched to the target (as normal) indicating that capture is active.
</p>

<p class="note">注記：
これは， `PointerEvents1$r を非互換化する変更であるが、
既存の内容の大勢には影響iしない。
この暗黙的な捕捉~用の設計は、代表的な~platform~UX慣行に合致することに加えて、開発者による明示的な~opt-inなしに，~UAによる［［
~touch移動による~eventに対し 接触判定を呼出す必要
］を防止するような，処理能の最適化
］を可能化する（既存の支配的な ~touch入力~用の，~native ／~web~APIの処理能~上の特質に整合する）。
◎
This is a breaking change from [PointerEvents1], but does not impact the vast majority of existing content. In addition to matching typical platform UX conventions, this design for implicit capture enables user agents to make a performance optimization which prevents the need to invoke hit-testing on touch movement events without explicit developer opt-in (consistent with the performance properties of existing dominant native and web APIs for touch input).
</p>

<p class="note">注記：
加えて，~UAは、入力~範囲~controlなどの特定の~UI~widget上で，すべての入力~装置~用に暗黙的な~pointer捕捉の挙動を実装してよい（手指を動している間に ~form~controlの外側に それることも許容するような）。
◎
In addition, user agents may implement implicit pointer capture behavior for all input devices on specific UI widgets such as input range controls (allowing some finger movement to stray outside of the form control itself during the interaction).
</p>

		</section>
		<section id="implicit-release-of-pointer-capture">
<h3 title="Implicit Release of Pointer Capture">10.5. ~pointer捕捉の暗黙的な解放-</h3>

<div class="algo">
<p>
~UAは、
`pointerup$et ／ `pointercancel$et
~eventを発火した直後に，次を走らすモノトスル：
</p>

<ol>
	<li>
%~pointer ~LET ~eventの `pointerId$m で識別される`作動中の~pointer$
</li>
	<li>
%~pointer の`処理待ち捕捉標的$ ~SET ~NULL
</li>
	<li>
`処理待ち~pointer捕捉を処理-$する手続きを走らす
</li>
	<li>
~IF［
%~pointer は~hoverを~supportする
］
⇒
必要とされるなら、 %~pointer の現在の位置を反映するよう，対応する`境界~event$
【以前に送信した`境界~event$と対になる それ】
を
— 捕捉なしに —
送信する
</li>
</ol>

◎
Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending Pointer Capture steps to fire lostpointercapture if necessary. After running Process Pending Pointer Capture steps, if the pointer supports hover, user agent MUST also send corresponding boundary events necessary to reflect the current position of the pointer with no capture.
</div>

<p>
`click$et ~eventの発火-を~supportする~UA（`互換性~mouse~event$を見よ）は、暗黙的な解放-時に
`click$et, `lostpointercapture$et
両~eventを発火するときは、 `click^et の方を先に発火するべきである。
◎
If the user agent supports firing the click event (see compatibility mouse events), and if in an implicit release scenario both click and lostpointercapture events are fired, click SHOULD be fired before lostpointercapture.
</p>

<div class="algo">
<p>
`作動中の~pointer$ %~pointer の`捕捉標的$が`接続されて$いなくなった `DOM4$r
ときは、次を走らすべきである：
</p>

<ol>
	<li>
%~pointer の`処理待ち捕捉標的$ ~SET ~NULL
</li>
	<li>
%~pointer の`捕捉標的$ ~SET ~NULL
</li>
	<li>
文書に向けて 名前 `lostpointercapture$et の`~pointer~eventを発火する$
</li>
</ol>

◎
When the pointer capture target override is no longer connected ([DOM4]), the pending pointer capture target override and pointer capture target override nodes SHOULD be cleared and also a PointerEvent named lostpointercapture corresponding to the captured pointer SHOULD be fired at the document.
</div>

<p>
要素が ある~pointerの［
`捕捉標的$／`処理待ち捕捉標的$
］である間に，要素に~pointer~lock `PointerLock$r が成功裡に適用されたときも、~UAは，この手続きを走らすモノトスル。
<!-- ＊無為に惑わす記述 
as if the releasePointerCapture() method has been called 
-->
◎
When a pointer lock ([PointerLock]) is successfully applied on an element, a user agent MUST run the steps as if the releasePointerCapture() method has been called if any element is set to be captured or pending to be captured.
</p>

		</section>
	</section>
	<section id="compatibility-mapping-with-mouse-events">
<h2 title="Compatibility Mapping with Mouse Events">11. ~mouse~eventとの互換性のための対応付け</h2>

<p>
今日の~web内容では、`~mouse~event$向けのみに書かれている~codeが大勢を占めている。
~UAは、その種の内容との互換性を得るためとして，以下に与える~algoにより，汎用~pointer入力を~mouse~eventに対応付けてもヨイ。
◎
The vast majority of web content existing today codes only to Mouse Events. The following describes an algorithm for how a user agent MAY map generic pointer input to mouse events for compatibility with this content.
</p>

<p>
互換性のための ~mouse~eventへの対応付けは、この仕様の任意選択の特能である。
~UAには、既存の旧来の内容との最良な互換性を得るために，この特能を~supportすることが奨励される。
`互換性~mouse~event$を~supportしない~UAにも、依然として
`click$et, `contextmenu$et
~eventは~supportすることが奨励される（下の注記を見よ）。
◎
The compatibility mapping with mouse events are an OPTIONAL feature of this specification. User agents are encouraged to support the feature for best compatibility with existing legacy content. User agents that do not support compatibility mouse events are still encouraged to support the click and contextmenu events (see the note below).
</p>

<div class="note">注記：
<p>
`click$et ~event `UIEVENTS$r,
`contextmenu$et ~event `HTML5$r
は、`互換性~mouse~event$とは見なされない。
それらは、概して~UIの作動化と束ねられており，~keyboardの様な他の入力~装置からも発火されるので。
◎
The click event, defined in [UIEVENTS], and the contextmenu event, defined in [HTML5], are not considered compatibility mouse events as they are typically tied to user interface activation and are fired from other input devices, like keyboards.
</p>

<p>
`click$et ／ `contextmenu$et
の発火を~supportする~UAにおいては、`~pointer~event$の間に `preventDefault()$m を呼んでも，概して
`click$et ／ `contextmenu$et
が発火されるかどうかには効果を持たない。
それらは`互換性~mouse~event$ではないので、~UAは概して，`首~pointer$でない~pointerも含め，すべての~pointing装置に対し
`click$et ／ `contextmenu$et
を発火する。
◎
In user agents that support firing click and/or contextmenu, calling preventDefault during a pointer event typically does not have an effect on whether click and/or contextmenu are fired or not. Because they are not compatibility mouse events, user agents typically fire click and contextmenu for all pointing devices, including pointers that are not primary pointers.
</p>

<p>
これらの高~levelな~event（
`click$et,
`contextmenu$et,
`focus$et,
`blur$et,
等々）と, `~pointer~event$との順序関係は、未定義であり，~UA間で様々になる。
例えば、
`pointerup$et, `contextmenu$et
の順に発火されることが多い~UAもあれば、その逆順になることが多い~UAもある。
また、対応する`~pointer~event$なしに発火される状況もある（~keyboard~shortcutなど）。
◎
The relative ordering of these high-level events (click, contextmenu, focus, blur, etc.) with pointer events is undefined and varies between user agents. For example, in some user agents contextmenu will often follow a pointerup, in others it'll often precede a pointerup or pointercancel, and in some situations it may be fired without any corresponding pointer event (such as a keyboard shortcut).
</p>

</div>

<div class="p">
<p>
他に注記されない限り、対応付けられた`~mouse~event$は、次で与えられる標的に向けて発火されるべきである：
</p>

<ul>
	<li>
~mouse~eventを発火する時点で，`~pointer~event$の標的がまだ`文書~内$にあるならば、それと同じ標的。
</li>
	<li>
他の場合、［
`~pointer~event$を発火した時点で，その標的の先祖であった~nodeたち
］のうち，［
`~mouse~event$を発火する時点で`文書~内$にあるもの
］のうち，最も子孫の~node†。
特に、~mouse~eventの伝播~経路は，この先祖に基づく新たなものにされることになる。
</li>
</ul>

<p class="trans-note">【†
~event~handlerにより，~nodeたちが文書~内で他所に移動された場合、そのような子孫は一意に定まらなくなる場合もあり得るが、はっきりしない。
そのような子孫は除外されるべきようにも思われる。
また、標的が除去されず文書の他所へ移動された場合も，同様になるかもしれない。
】</p>

◎
Unless otherwise noted, the target of any mapped mouse event SHOULD be the same target as the respective pointer event unless the target is no longer participating in its ownerDocument's tree. In this case, the mouse event should be fired at the original target's nearest ancestor node (at the time it was removed from the tree) that still participates in its ownerDocument's tree, meaning that a new event path (based on the new target node) is built for the mouse event.
</div>

<p>
作者は、 `pointerdown$et ~eventを取消すことにより，一定の`互換性~mouse~event$の生産を防止できる。
◎
Authors can prevent the production of certain compatibility mouse events by canceling the pointerdown event.
</p>

<p class="note">注記：
~mouse~eventは、~pointerの~buttonが押されたときにのみ防止できる。
~hoverしている~pointer（例： どの~buttonも押されていない~mouse）による~mouse~eventは、防止できない。
加えて、［
`mouseover$et,
`mouseout$et,
`mouseenter$et,
`mouseleave$et
］~eventは，（~pointerの~buttonが押されていても）決して防止されない。
◎
Mouse events can only be prevented when the pointer is down. Hovering pointers (e.g. a mouse with no buttons pressed) cannot have their mouse events prevented. And, the mouseover, mouseout, mouseenter, and mouseleave events are never prevented (even if the pointer is down).
</p>

		<section id="tracking-the-effective-position-of-the-legacy-mouse-pointer">
<h3 title="Tracking the effective position of the legacy mouse pointer">11.1. 旧来の~mouse~pointerに対する位置の追跡-法</h3>

<p>
`互換性~mouse~event$を生産し得るのは`首~pointer$に限られるが、
<a href="#multiple-primary-pointers">複数の首~pointer</a>が
— 各自が自前の`互換性~mouse~event$を生産するように —
同時に作動中になり得る。
これらすべての互換性~eventは、 `MouseEvent^I ~codeにとっては，単独の~mouse装置から生じたかのように現れるので、~UAには，［
`互換性~mouse~event$が単独の装置~視点で整合するように現れる
］ことを保証することが奨励される。
~mouse遷移~event（すなわち，
`mouseover$et ／ `mouseout$et ／ `mouseenter$et ／ `mouseleave$et
）に対しては、このことは，どの~event標的に対しても［
~mouseの出入り状態が， `UIEVENTS$r から課されるものに関して妥当になる
］ことを意味する。
~UAは、文書~内の
`旧来の~mouse~pointerの実効~位置@
を，次に従って保守することにより，これを保証するベキである。
◎
While only the primary pointers can produce compatibility mouse events, multiple primary pointers can be active simultaneously, each producing its own compatibility mouse events. Since all these compatibility events would appear to MouseEvent code to be coming from a single mouse device, user agents are encouraged to guarantee that the compatibility mouse events are consistent from a single device perspective. For mouse transition events (i.e., mouseover, mouseout, mouseenter and mouseleave), this means the entry/exit state for every event target is valid as implied by [UIEVENTS]. Users agents SHOULD guarantee this by maintaining the effective position of the legacy mouse pointer in the document as follows.
</p>

<p class="trans-note">【
例えば、同じ要素に向けて `mouseenter^et が（ `mouseleave^et を挟まずに）続けて発火されないようにするなど。
】</p>

<div class="algo">
<p>
~UAは、［
`pointerdown$et ／ `pointerup$et ／ `pointermove$et
］~eventを発火するとき, あるいは［
`~Window$に向けて `pointerleave$et
］~eventを発火するときは、その~event %event を発火する直前に，次の手続きを走らすベキである：
◎
Right before firing a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, the user agent SHOULD run the following steps:
</p>

<ol>
	<li>
%旧~位置 ~LET 現在の`旧来の~mouse~pointerの実効~位置$
◎
↓</li>
	<li>
%新~位置 ~LET ［
%event が `pointerleave$et ならば `域外^i ／
~ELSE_ %event の標的
］
◎
Let T be the target of the pointerdown, pointerup or pointermove event being dispatched. For the pointerleave event, unset T.
</li>
	<li>
~IF［
%新~位置 ~EQ %旧~位置
］
⇒
~RET
◎
If T and current effective legacy mouse pointer position are both unset or they are equal, terminate these steps.
</li>
	<li>
`UIEVENTS$r に従って、［
~mouseが %旧~位置 から %新~位置 へ移動した
］ものと見なした下で［
`mouseover$et ／
`mouseout$et ／
`mouseenter$et ／
`mouseleave$et
］~eventを発火する
— ここでの［
%旧~位置 ／ %新~位置
］に対する値 `域外^i は、~mouse位置が~UIwindow外にあると見なす
◎
Dispatch mouseover, mouseout, mouseenter and mouseleave events as per [UIEVENTS] for a mouse moving from the current effective legacy mouse pointer position to T. Consider an unset value of either current effective legacy mouse pointer position or T as an out-of-window mouse position.
</li>
	<li>
`旧来の~mouse~pointerの実効~位置$ ~SET %新~位置
◎
Set effective legacy mouse pointer position to T.
</li>
</ol>
</div>

		</section>
		<section id="mapping-for-devices-that-support-hover">
<h3 title="Mapping for devices that support hover">11.2. ~hoverを~supportする装置~用の対応付け</h3>

<div class="algo">
<p>
~UAは、~hoverを~supportする装置による`~pointer~event$ %event を配送するときは，次の手続きを走らすベキである：
◎
Whenever a user agent is to dispatch a pointer event for a device that supports hover, it SHOULD run the following steps:
</p>

<ol>
	<li>
~IF［
%event の `isPrimary$m 属性 ~EQ ~F
］
⇒＃
%event を配送する；
~RET
◎
If the isPrimary property for the pointer event to be dispatched is false then dispatch the pointer event and terminate these steps.
</li>
	<li>
~IF［
%event の型 ~IN
{ `pointerdown$et, `pointerup$et, `pointermove$et }
］~OR［［
%event の型 ~EQ `pointerleave$et
］~AND［
%event の標的は`~Window$である
］］
⇒
`旧来の~mouse~pointerに対する位置の追跡-法$に従って，互換性~mouse遷移~eventを配送する
◎
If the pointer event to be dispatched is a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, dispatch compatibility mouse transition events as described in Tracking the effective position of the legacy mouse pointer.
</li>
	<li>
%event を`互換性~mouse~eventも込みで配送する$
◎
↓</li>
</ol>
</div>

<div class="algo">
<p>
`~pointer~event$ %event を
`互換性~mouse~eventも込みで配送する@
ときは、次を走らす：
◎
↓</p>

<ol>
	<li>
%event を配送する
◎
Dispatch the pointer event.
</li>

	<li>
%装置~型 ~LET %event の `pointerType$m
</li>
	<li>
~IF［
%event の型 ~EQ `pointerdown$et
］~AND［
%event は`取消された$
］
⇒
%装置~型 用の`~mouse~eventは防止するか$ ~SET ~T
◎
If the pointer event dispatched was pointerdown and the event was canceled, then set the PREVENT MOUSE EVENT flag for this pointerType.
</li>
	<li>
<p>
~IF［
%装置~型 用の`~mouse~eventは防止するか$ ~EQ ~F
］
⇒
%event の型に応じて，次の表の 2 列目に与える型の~mouse~eventを，3 列目に与える標的に向けて発火する：
</p>

<table>
<thead><tr><th>%event の型
<th>~mouse~event型
<th>標的
</thead>

<tbody><tr><td>`pointerdown$et
<td>`mousedown$et
<td>%event の標的

<tr><td>`pointermove$et
<td>`mousemove$et
<td>%event の標的

<tr><td>`pointerup$et
<td>`mouseup$et
<td>%event の標的

<tr><td>`pointercancel$et
<td>`mousecancel^et【？】
<td>`~Window$

</tbody></table>

◎
If the PREVENT MOUSE EVENT flag is not set for this pointerType and the pointer event dispatched was:
◎
pointerdown, then fire a mousedown event.
◎
pointermove, then fire a mousemove event.
◎
pointerup, then fire a mouseup event.
◎
pointercancel, then fire a mouseup event at the window.
</li>
	<li>
~IF［
%event の型 ~IN { `pointerup$et, `pointercancel$et }
］
⇒
%装置~型 用の`~mouse~eventは防止するか$ ~SET ~F
◎
If the pointer event dispatched was pointerup or pointercancel, clear the PREVENT MOUSE EVENT flag for this pointerType.
</li>
</ol>
</div>

		</section>
		<section id="mapping-for-devices-that-do-not-support-hover">
<h3 title="Mapping for devices that do not support hover">11.3. ~hoverを~supportしない装置~用の対応付け</h3>

<p>
ほとんどの~touchscreenなど、`作動中$でない間は，座標（または座標の集合）に対する~hoverを~supportしない装置もある。
~mouse~event向けに書かれている既存の多数の~codeは、~eventが~mouseにより生産されていて，次の~~性質が一般に成り立つものと見做している：
◎
Some devices, such as most touchscreens, do not support hovering a coordinate (or set of coordinates) while not in the active state. Much existing content coded to mouse events assumes that a mouse is producing the events and thus certain qualities are generally true:
</p>

<ul>
	<li>
入力は、作動化と独立に~hoverできる（例：どの~buttonも押さないまま~mouse~cursorを動かす）。
◎
The input can hover independently of activation (e.g. moving a mouse cursor without any buttons pressed).
</li>
	<li>
入力は、要素が~clickされる前に `mousemove$et ~eventを生産する見込みが高い。
◎
The input will likely produce the mousemove event on an element before clicking it.
</li>
</ul>

<p class="note">注記：
~hoverは、~mouse向けに設計された内容にて，~UI要素の可視性を切り替えるために利用されることもある（例： “~hover~menu” ）。
そのような内容は、`~hoverを~supportしない$装置と互換にならないことが多い。
この仕様は、この局面における互換性のための対応付けや挙動は定義しない。
それは、将来~versionの仕様にて考慮されることになる。
◎
Hover is sometimes used to toggle the visibility of UI elements in content designed for mouse (e.g. "hover menus"). This content is often incompatible with devices that do not support hover. This specification does not define a mapping or behavior for compatibility with this scenario. It will be considered in a future version of the specification.
</p>

<div class="algo">
<p>
このことから、~UAには，これらの型の入力~装置に対しては，異なる対応付けを供することが要求される。
~UAは、所与の %標的 に向けて［
`~hoverを~supportしない$装置による`~pointer~event$
］ %event を配送するときは，次の手続きを走らすベキである：
◎
This requires that user agents provide a different mapping for these types of input devices. Whenever a user agent is to dispatch a pointer event for a device that does not support hover, it SHOULD run the following steps:
</p>

<ol>
	<li>
~IF［
%event の `isPrimary$m 属性 ~EQ ~F
］
⇒＃
%event を配送する；
~RET
◎
If the isPrimary property for the pointer event to be dispatched is false then dispatch the pointer event and terminate these steps.
</li>
	<li>
%~pointer ~LET %event を生じさせた~pointer
</li>
	<li>
~IF［
%event の型 ~EQ `pointerover$et
］~AND［
%~pointer による `pointerdown$et ~eventはまだ生じていない
］
⇒
`mousemove$et ~eventを発火する（旧来の~mouse向け~codeとの互換性をとるために）
◎
If the pointer event to be dispatched is pointerover and the pointerdown event has not yet been dispatched for this pointer, then fire a mousemove event (for compatibility with legacy mouse-specific code).
</li>
	<li>
~IF［
%event の型 ~IN
{ `pointerdown$et, `pointerup$et, `pointermove$et }
］~OR［［
%event の型 ~EQ `pointerleave$et
］~AND［
%event の標的は`~Window$である
］］
⇒
`旧来の~mouse~pointerに対する位置の追跡-法$に従って，互換性~mouse遷移~eventを配送する
◎
If the pointer event to be is dispatched is a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, dispatch compatibility mouse transition events as described in Tracking the effective position of the legacy mouse pointer.
</li>
	<li>
%event を，`互換性~mouse~eventも込みで配送する$
◎
Dispatch the pointer event.
◎
If the pointer event dispatched was pointerdown and the event was canceled, then set the PREVENT MOUSE EVENT flag for this pointerType.
◎
If the PREVENT MOUSE EVENT flag is not set for this pointerType and the pointer event dispatched was:
◎
pointerdown, then fire a mousedown event.
◎
pointermove, then fire a mousemove event.
◎
pointerup, then fire a mouseup event.
◎
pointercancel, then fire a mouseup event at the window.
◎
If the pointer event dispatched was pointerup or pointercancel, clear the PREVENT MOUSE EVENT flag for this pointerType.
</li>
</ol>
</div>

<p class="note">注記：
`~pointer~event$と
`TOUCH-EVENTS$r に定義される~touch~eventの両者とも~supportする~UAは、この節に述べた`互換性~mouse~event$を生成するべきでない
— そうすると、［
`TOUCH-EVENTS$r にて
<a href="~TOUCHEVENTS#mouse-events">要旨されている~model</a>
に則って，~mouse~eventが生成される
］ことを期待している~siteに，互換性の問題をもたらす見込みが高いので。
◎
If the user agent supports both Touch Events (as defined in [TOUCH-EVENTS]) and Pointer Events, the user agent SHOULD NOT generate compatibility mouse events as described in this section as it is likely to introduce compatibility problems for sites that expect mouse events to be generated in accordance with the model outlined in [TOUCH-EVENTS].
</p>

<div class="note">
<p>注記：
`~hoverを~supportしない$ `首~pointer$による要素の作動化（ `click$et ）
（例： ~touchscreen上の単独の手指）は、概して，次の`~event連列$を生産することになる：
</p>

<ol>
<li>`mousemove$et
<li>`pointerover$et
<li>`pointerenter$et
<li>`mouseover$et
<li>`mouseenter$et
<li>`pointerdown$et
— この~eventが取消された場合、以降における［
`mousedown$et, `mousemove$et, `mouseup$et
］は生産されない。
<li>`mousedown$et
<li>~pointerの動きに依存して， 0 回以上の［
`pointermove$et ／ `mousemove$et
］~event
<li>`pointerup$et
<li>`mouseup$et
<li>`click$et
<li>`pointerout$et
<li>`pointerleave$et
<li>`mouseout$et
<li>`mouseleave$et
</ol>

◎
The activation of an element (click) with a primary pointer that does not support hover (e.g. single finger on a touchscreen) would typically produce the following event sequence:
• mousemove
• pointerover
• pointerenter
• mouseover
• mouseenter
• pointerdown
• mousedown
• Zero or more pointermove and mousemove events, depending on movement of the pointer
• pointerup
• mouseup
• click
• pointerout
• pointerleave
• mouseout
• mouseleave
◎
If, however, the pointerdown event is canceled during this interaction then the sequence of events would be:
• mousemove
• pointerover
• pointerenter
• mouseover
• mouseenter
• pointerdown
• Zero or more pointermove events, depending on movement of the pointer
• pointerup
• click
• pointerout
• pointerleave
• mouseout
• mouseleave
</div>

		</section>
	</section>
	<section id="security-and-privacy-considerations">
<h2 title="Security and privacy considerations">12. ~securityと~privacy上の考慮点</h2>

<p>
この付録では、 Pointer Events 実装における~securityと~privacy上の考慮点について論じる。
論点は、この仕様に定義される［
~event~model, ~API, ~event
］の実装から直に発生する
~security／~privacy
上の課題に限られる。
◎
This appendix discusses security and privacy considerations for Pointer Events implementations. The discussion is limited to security and privacy issues that arise directly from implementation of the event model, APIs and events defined in this specification.
</p>

<p>
この仕様に定義される~event型の多くは、利用者の動作に呼応して配送される。
これは、悪意的な~event~listenerが［
概して，利用者が機密的と考える情報
］
— 例：利用者が~pageとヤリトリしている間の［
~mouse／~stylus／手指
］の正確な経路や動きなど —
への~accessを得られるようにする。
◎
Many of the event types defined in this specification are dispatched in response to user actions. This allows malicious event listeners to gain access to information users would typically consider confidential, e.g., the exact path/movement of a user's mouse/stylus/finger while interacting with a page.
</p>

<p>
~pointer~eventは、追加的な情報を（利用者の装置が~supportする所で）包含する
— ~pen入力に保持されている角度や傾き／
接触~物理面の幾何／
~stylusや~touch~screen上に~~感知された押圧
など。
［
角度, 傾き, 幾何, 押圧
］の情報は、利用者~機器の~sensorに直に関係する。
すなわち、この仕様は，そのような~sensorへの~accessを生成元に許容する。
◎
Pointer events contain additional information (where supported by the user's device), such as the angle or tilt at which a pen input is held, the geometry of the contact surface, and the pressure exerted on the stylus or touch screen. Information about angle, tilt, geometry and pressure are directly related to sensors on the user's device, meaning that this specification allows an origin access to these sensors.
</p>

<p>
この~sensor~dataは、［
どの型の仕組み（~mouse, ~touch, ~pen, 等）が入力に利用されているか
］を決定する能とともに，［
利用者, あるいは利用者の装置や環境
］についての特徴を推定するために利用され得る。
このように推定された特徴, および装置や環境の情報それ自体も敏感になり得る
— 一例として、悪意的な~siteは，さらに利用者が支援技術を利用しているか推定できるようになる。
この情報はまた、特定0の利用者を追跡しようと試みるために［
利用者~profileを築く, あるいは “指紋収集する”
］目的にも利用され得る。
◎
This sensor data, as well as the ability to determine the type of input mechanism (mouse, touch, pen) used, may be used to infer characteristics of a user, or of the user's device and environment. These inferred characteristics and any device/environment information may themselves be sensitive - for instance, they may allow a malicious site to further infer if a user is using assistive technologies. This information can also be potentially used for the purposes of building a user profile and/or attempting to "fingerprint" and track a particular user.
</p>

<p>
当 working group は、上述を超えるような考慮点は，この仕様には無いものと予見している：
◎
Beyond these considerations, the working group believes that this specification:
</p>

<ul>
	<li>
個人識別可能な情報は、公開しない。
◎
Does not expose personally-identifiable information.
</li>
	<li>
高価値な~dataは、~~扱わない。
◎
Does not deal with high-value data.
</li>
	<li>
複数の閲覧~sessionに持続するような，生成元~用の新たな状態は、導入しない。
◎
Does not introduce new state for an origin that persists across browsing sessions.
</li>
	<li>
異なる生成元にわたって持続するような状態は、~webに公開しない。
◎
Does not expose persistent, cross-origin state to the web.
</li>
	<li>
現在~accessできない他のどのような~dataも、生成元に公開しない。
◎
Does not expose any other data to an origin that it doesn’t currently have access to.
</li>
	<li>
~scriptを［
実行する／読込む
］ような新たな仕組みは、可能化しない。
◎
Does not enable new script execution/loading mechanisms.
</li>
	<li>
利用者の所在への~accessは、生成元に許容しない。
◎
Does not allow an origin access to a user’s location.
</li>
	<li>
~UAが “私的閲覧” ~mode下にあるときの特別な取扱いは、要求しない。
◎
Does not require any special handling when the user agent is in "incognito" mode.
</li>
	<li>
他の装置への~accessは、生成元に許容しない。
◎
Does not allow an origin access to other devices.
</li>
	<li>
~UAに~nativeな~UI越しの制御は、生成元に許容しない。
◎
Does not allow an origin control over a user agent’s native UI.
</li>
	<li>
一時的な識別子は、~webに公開しない。
◎
Does not expose temporary identifiers to the web.
</li>
	<li>
挙動が［
当事者-主体, 第三者-主体
］どちらの文脈におけるものかは、判別しない。
◎
Does not distinguish between behavior in first-party and third-party contexts.
</li>
	<li>
利用者に局所的な装置には、~dataを持続しない。
◎
Does not persist data to a user’s local device.
</li>
	<li>
既定の~security特徴へ降格することは、許容しない。
◎
Does not allow downgrading default security characteristics.
</li>
</ul>

	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
たくさんの方々からの提案や助言に感謝する。
それらの一部は、この文書に組入れられている。
次に挙げる，~~現在／~~過去の~group~memberの方々による貢献にも：
◎
Many thanks to lots of people for their proposals and recommendations, some of which are incorporated into this document. The group's Chair acknowledges contributions from the following past and present group members and participants: 
</p>

<p lang="en">
Mustaq Ahmed,
Arthur Barstow,
Matt Brubeck,
Rick Byers,
Cathy Chan,
Ted Dinklocker,
Dave Fleck,
Ella Ge,
Scott González,
Philippe Le Hégaret,
Hayato Ito,
Patrick Kettner,
Patrick H. Lauke,
Scott Low,
Sangwhan Moon,
Olli Pettay,
Jacob Rossi,
Doug Schepers,
Ming-Chou Shih,
Brenton Simpson,
Dave Tapuska,
Asir Vedamuthu,
Lan Wei,
Navid Zolghadr
</p>

<p>
この~modelの最初の版のために先駆的な仕事をされた方々にも特別な謝意を
— とりわけ次の方々に：
</p>

<p lang="en">
Special thanks to those that helped pioneer the first edition of this model, including especially: Charu Chandiram, Peter Freiling, Nathan Furtwangler, Thomas Olsen, Matt Rakow, Ramu Ramanathan, Justin Rogers, Jacob Rossi, Reed Townsend and Steve Wright.
</p>

	</section>
	<section id="revision-history">
<h2 title="Revision History">改訂~履歴</h2>

~INFORMATIVE

<p>
最初の `PointerEvents1$r 仕様からの，~~主要な, および編集上の~~主な変更点（参考）を以下に要約する（この仕様の編集者草案の
<a href="https://github.com/w3c/pointerevents/commits">完全な改訂~履歴</a>
）。
◎
The following is an informative summary of substantial and major editorial changes between publications of this specification, relative to the first [PointerEvents1] specification. See the complete revision history of the Editor's Drafts of this specification.
</p>

<ul>
	<li>
参考~節からの規範的~参照を除去した。
（加えて， `COMPAT$r は純粋に参考とした）
（ <a href="https://github.com/w3c/pointerevents/commit/d2779fe71e3b1c26d6b4657ad0330bed378b8b69">commit</a> ）
◎
Remove normative references from informative sections (and mark [COMPAT] as purely informative)
</li>
	<li>
`270$pull：
§ <a href="#pointer-capture">~pointer捕捉</a>
全体を参考としていたのを修正した。
◎
Fix Pointer Capture section erroneously marked as informative
</li>
	<li>
`251$pull：
暗黙的な捕捉の局面における`境界~event$を追加した。
◎
Add boundary events in implicit capture scenarios
</li>
	<li>
`246$pull：
注釈文における `DOM4$r の `ownerDocument^m ~tree【`文書~内$】の概念を
`接続されて$いる／いない
に置換した。【全部ではない】
◎
Replace prose about ownerDocument tree with DOM4 concept of connected
</li>
	<li>
`235$pull：
§ ~securityと~privacy上の考慮点を追加した。
◎
Add security and privacy considerations section
</li>
	<li>
`234$pull：
旧来の属性 `fromElement^m, `toElement^m （ `MouseEvent$I から継承される）は、
~NULL を返すモノトスルことについての注記を追加した。
◎
Add note about legacy attributes fromElement and toElement (inherited from MouseEvents) must be null
</li>
	<li>
`218$pull：
構築子に [Exposed=Window] を追加した。
◎
Add [Exposed=Window] to Constructor
</li>
	<li>
`138$pull：
捕捉の間に`境界~event$を送信しないようにした。
◎
Don't send boundary events during capture
</li>
	<li>
`129$pull：
直接~操作~pointing装置~用の暗黙的な捕捉。
◎
Implicit capture for direct manipulation pointing devices
</li>
	<li>
`122$pull：
`~pointer捕捉$が暗黙的に解放された場合を除き、~pointer捕捉~処理は遅延される~modelに従うようにした。
◎
Add pointer capture processing follow delayed model except implicit release and set the pointer capture events attributes
</li>
	<li>
`127$pull：
`hasPointerCapture()$m を追加した。
◎
Add hasPointerCapture
</li>
	<li>
`96$pull：
`button^m ／ `buttons^m
から “~pen接触” 条件を除去した。
◎
Removed "pen contact" condition on button/buttons
</li>
	<li>
`92$pull：
すべての~pointer~eventを~composed~eventにした。
◎
Make all pointer events composed events
</li>
	<li>
`87$pull：
~digitizer／~pen による接線方向（~barrel）圧を追加した。
◎
Add digitizer/pen tangential (barrel) pressure
</li>
	<li>
`79$pull：
~digitizer／~penの~twistを追加。
◎
Add digitizer/pen twist
</li>
	<li>
`69$pull：
`width$m ／ `height$m の既定を 1 にした上で、~UAによる幾何の “~~推測／~~偽造” を除去した。
◎
Make width/height default to 1, remove UA "guessing"/faking geometry
</li>
	<li>
`56$pull：
`mouseover$et／ `mouseout$et／ `mouseenter$et／ `mouseleave$et
~eventは，対応する~pointer~eventとは独立に発火されるようにした。
◎
Made mouseover/out/enter/leave event firing independent of corresponding PEs
</li>
	<li>
`53$pull：
§ `首~pointer$を，言い回しを単純~化した上で、複数の~mouse入力~装置の可能性を許容した。
◎
Rewrite of primary pointer section to simplify the wording and allow for possibility of multiple mouse input devices
</li>
	<li>
`50$pull：
`首~pointer$が除去された場合についての~~言及。
◎
Cover the case when primary pointer is removed
</li>
	<li>
`43$pull：
`touch-action$p の動的な変化について明確化した。
◎
Clarification about dynamic touch-action changes
</li>
	<li>
`36$pull：
`処理待ち~pointer捕捉を処理-$する際の，抜けていた
`pointerover$et／`pointerenter$et
~eventを追加した。
◎
Add the missing pointerover/enter events to the "Process Pending Pointer Capture" section
</li>
	<li>
`34$pull：
~mouse~drag用に~button値を明確化した。
◎
Clarify the button value for mouse drag
</li>
	<li>
`24$pull：
~zoomにおける `touch-action$p の処理~modelを修正した。
◎
Fix the touch-action processing model for zoom scenarios
</li>
</ul>

	</section>
</main></div>
