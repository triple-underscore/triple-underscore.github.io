<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Pointer Events Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-w3c.css" type="text/css">
<style>
img {
	background: white;
}

@supports (grid-template-columns: subgrid) and (display: contents) {

#pointer-event-type-table {
	grid-template-columns: 4em 8em 8em 1fr;
	min-width: 28em;
	max-width: 42em;
	tr {
		grid-template-areas:
			"event event event event"
			". 浮上 取消可否 既定動作"
		;
		> *:nth-child(1) {
			grid-area: event;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: 浮上;
		}
		> *:nth-child(3) {
			grid-area: 取消可否;
		}
		> *:nth-child(4) {
			grid-area: 既定動作;
		}
	}
}

}


</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>
Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN0',
		generate: expand
	}

	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!indicator) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `#bib-${key.toLowerCase()}`;
	break;
case 'm' : // interface member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'l':
	return `"<code class="literal">${key}</code>"`;
	break;
case 'v': // CSS touch-action 値
	href = `#valdef-touch-action-${key}`;
	break;
case 'dgm':
	return `<a id="_dgm-${key}">＊</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
case 'pull': // pull req
	text = `#${key}`;
	href = `~POINTEREVENTS_pull/${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">

●●options
spec_title:Pointer Events Level 4
spec_date:2026-02-11
trans_update:2026-02-24
source_checked:260211
page_state_key:UIEVENTS
original_url:https://w3c.github.io/pointerevents/
	abbr_url:POINTEREVENTS3
spec_status:ED
ref_id_prefix:bib-
ref_id_lowercase:true
conformance:w3c
copyright:2025,permissive
trans_1st_pub:2019-11-08


●●class_map
E:error
et:event-type
e:element
p:css
v:value

●●tag_map
c:code
I:code
E:code
m:code
mb:code
et:code
e:code
p:code
v:code
i:i
em:em
cite:cite

●●original_id_map

propdef-touch-action:dfn-touch-action
valdef-touch-action-auto:
valdef-touch-action-none:
valdef-touch-action-pan-x:
valdef-touch-action-pan-left:
valdef-touch-action-pan-right:
valdef-touch-action-pan-y:
valdef-touch-action-pan-up:
valdef-touch-action-pan-down:
valdef-touch-action-manipulation:

	_modifiers-map:dfn-shift-flag
	_modifiers-map:dfn-control-flag
	_modifiers-map:dfn-alt-flag
	_modifiers-map:dfn-altgraph-flag
	_modifiers-map:dfn-meta-flag

	_maybe-send-pointer-event:maybe-send-pointerout-event
	_maybe-send-pointer-event:maybe-send-pointerleave-event
	_maybe-send-pointer-event:maybe-send-pointerover-event
	_maybe-send-pointer-event:maybe-send-pointerenter-event
	_maybe-send-pointer-event:maybe-send-pointermove-event
	_maybe-send-pointer-event:maybe-send-pointerdown-event
	_maybe-send-pointer-event:maybe-send-pointerrawupdate-event
	_maybe-send-pointer-event:maybe-send-pointerup-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerout-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerleave-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerover-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerenter-event
	_maybe-send-pointer-event:dfn-maybe-send-pointermove-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerdown-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerrawupdate-event
	_maybe-send-pointer-event:dfn-maybe-send-pointerup-event

	●多重 id（§）
	the-click-auxclick-and-contextmenu-events:dfn-click-auxclick-and-contextmenu-events
		the-primary-pointer:dfn-primary-pointer
	attributes-and-default-actions:dfn-attributes-and-default-actions
	pointer-event-types:dfn-pointer-event-types
		process-pending-pointer-capture:dfn-process-pending-pointer-capture
	declaring-direct-manipulation-behavior:dfn-direct-manipulation-behavior
	details-of-touch-action-values:dfn-touch-action-values
		pointer-capture:dfn-pointer-capture
		setting-pointer-capture:dfn-set-pointer-capture
		releasing-pointer-capture:dfn-release-pointer-capture
	implicit-pointer-capture:dfn-implicit-pointer-capture
		implicit-release-of-pointer-capture:dfn-implicitly-release-the-pointer-capture
	coalesced-events:dfn-coalesced-events
	predicted-events:dfn-predicted-events
	compatibility-mapping-with-mouse-events:dfn-compatibility-mouse-events
	tracking-the-effective-position-of-the-legacy-mouse-pointer:dfn-tracking-the-effective-position-of-the-legacy-mouse-pointer
	boundary-events-caused-by-layout-changes:dfn-events-from-layout-changes
	events-wheelevents:wheel-events
	interface-wheelevent:interface-wheelevent-0
	idl-wheelevent:wheelevent
	idl-wheeleventinit:wheeleventinit
	events-wheel-types:wheel-event-types
	cancelability-of-wheel-events:cancelability-of-wheel-events-0
	legacy-event-initializers:legacy-event-initializers-0
	idl-interface-MouseEvent-initializers:initializers-for-interface-mouseevent


●●mdn_urls
propdef-touch-action:CSS/touch-action

dom-mouseevent:API/MouseEvent
dom-pointerevent:API/PointerEvent
dom-wheelevent:API/WheelEvent

dfn-auxclick:API/Element/auxclick_event
dfn-click:API/Element/click_event
dfn-dblclick:API/Element/dblclick_event
dfn-contextmenu:API/Element/contextmenu_event
dfn-mousedown:API/Element/mousedown_event
dfn-mouseenter:API/Element/mouseenter_event
dfn-mouseleave:API/Element/mouseleave_event
dfn-mousemove:API/Element/mousemove_event
dfn-mouseout:API/Element/mouseout_event
dfn-mouseover:API/Element/mouseover_event
dfn-mouseup:API/Element/mouseup_event
dfn-wheel:API/Element/wheel_event
dfn-gotpointercapture:API/HTMLElement/gotpointercapture_event
dfn-lostpointercapture:API/HTMLElement/lostpointercapture_event
dfn-pointercancel:API/HTMLElement/pointercancel_event
dfn-pointerdown:API/HTMLElement/pointerdown_event
dfn-pointerenter:API/HTMLElement/pointerenter_event
dfn-pointerleave:API/HTMLElement/pointerleave_event
dfn-pointermove:API/HTMLElement/pointermove_event
dfn-pointerout:API/HTMLElement/pointerout_event
dfn-pointerover:API/HTMLElement/pointerover_event
dfn-pointerup:API/HTMLElement/pointerup_event
	dfn-pointerrawupdate:Events/pointerrawupdate


●●link_map

	●IDL

Exposed:~WEBIDLjs#Exposed
SecureContext:~WEBIDLjs#SecureContext

E.NotFoundError:~WEBIDL#notfounderror
E.InvalidStateError:~WEBIDL#invalidstateerror

undefined:~WEBIDL#idl-undefined
short:~WEBIDL#idl-short
unsigned short:~WEBIDL#idl-unsigned-short
long:~WEBIDL#idl-long
unsigned long:~WEBIDL#idl-unsigned-long
float:~WEBIDL#idl-float
double:~WEBIDL#idl-double
boolean:~WEBIDL#idl-boolean
DOMString:~WEBIDL#idl-DOMString
sequence:~WEBIDL#idl-sequence

I.Event:~DOM4#event
I.EventTarget:~DOM4#eventtarget
I.EventHandler:~WAPI#eventhandler
I.UIEvent:~UIEVENTS#uievent
I.EventModifierInit:~UIEVENTS#dictdef-eventmodifierinit
I.MouseEvent:#dom-mouseevent
I.MouseEventInit:#dom-mouseeventinit
I.PointerEvent:#dom-pointerevent
I.PointerEventInit:#dom-pointereventinit
I.WheelEvent:#dom-wheelevent
I.WheelEventInit:#dom-wheeleventinit
I.Element:~DOM4#element
I.KeyboardEvent:~UIEVENTS#keyboardevent
I.GlobalEventHandlers:~WAPI#globaleventhandlers
I.Navigator:~HTMLnavigator#navigator

m.type:~DOM4#dom-event-type
m.target:~DOM4#dom-event-target
m.bubbles:~DOM4#dom-event-bubbles
m.cancelable:~DOM4#dom-event-cancelable
m.composed:~DOM4#dom-event-composed
m.isTrusted:~DOM4#dom-event-istrusted
m.preventDefault:~DOM4#dom-event-preventdefault
m.timeStamp:~DOM4#dom-event-timestamp
	m.initEvent:~DOM4#dom-event-initevent

m.dispatchEvent:~DOM4#dom-eventtarget-dispatchevent

m.pointerLockElement:~TR/pointerlock/#dom-documentorshadowroot-pointerlockelement

m.setPointerCapture:#dom-element-setpointercapture
m.releasePointerCapture:#dom-element-releasepointercapture
m.hasPointerCapture:#dom-element-haspointercapture

m.maxTouchPoints:#dom-navigator-maxtouchpoints

m.detail:~UIEVENTS#dom-uievent-detail
m.view:~UIEVENTS#dom-uievent-view

m.screenX:#dom-mouseevent-screenx
m.screenY:#dom-mouseevent-screeny
m.clientX:#dom-mouseevent-clientx
m.clientY:#dom-mouseevent-clienty
m.layerX:#dom-mouseevent-layerx
m.layerY:#dom-mouseevent-layery
m.ctrlKey:#dom-mouseevent-ctrlkey
m.shiftKey:#dom-mouseevent-shiftkey
m.altKey:#dom-mouseevent-altkey
m.metaKey:#dom-mouseevent-metakey
m.button:#dom-mouseevent-button
m.buttons:#dom-mouseevent-buttons
m.relatedTarget:#dom-mouseevent-relatedtarget
m.getModifierState:#dom-mouseevent-getmodifierstate
	m.getModifierState:#dfn-getmodifierstate-keyarg
m.initMouseEvent:#dom-mouseevent-initmouseevent

mb.screenX:#dom-mouseeventinit-screenx
mb.screenY:#dom-mouseeventinit-screeny
mb.clientX:#dom-mouseeventinit-clientx
mb.clientY:#dom-mouseeventinit-clienty
mb.button:#dom-mouseeventinit-button
mb.buttons:#dom-mouseeventinit-buttons
mb.relatedTarget:#dom-mouseeventinit-relatedtarget

mb.pointerId:#dom-pointereventinit-pointerid
mb.width:#dom-pointereventinit-width
mb.height:#dom-pointereventinit-height
mb.pressure:#dom-pointereventinit-pressure
mb.tangentialPressure:#dom-pointereventinit-tangentialpressure
mb.tiltX:#dom-pointereventinit-tiltx
mb.tiltY:#dom-pointereventinit-tilty
mb.twist:#dom-pointereventinit-twist
mb.pointerType:#dom-pointereventinit-pointertype
mb.altitudeAngle:#dom-pointereventinit-altitudeangle
mb.azimuthAngle:#dom-pointereventinit-azimuthangle
mb.isPrimary:#dom-pointereventinit-isprimary
mb.persistentDeviceId:#dom-pointereventinit-persistentdeviceid
mb.coalescedEvents:#dom-pointereventinit-coalescedevents
mb.predictedEvents:#dom-pointereventinit-predictedevents

constructor:~DOM4#concept-event-constructor
	constructor:#dom-pointerevent-constructor
	constructor:#dom-wheelevent-constructor
	constructor:#dom-mouseevent-constructor

m.pointerId:#dom-pointerevent-pointerid
m.width:#dom-pointerevent-width
m.height:#dom-pointerevent-height
m.pressure:#dom-pointerevent-pressure
m.tangentialPressure:#dom-pointerevent-tangentialpressure
m.tiltX:#dom-pointerevent-tiltx
m.tiltY:#dom-pointerevent-tilty
m.twist:#dom-pointerevent-twist
m.pointerType:#dom-pointerevent-pointertype
m.altitudeAngle:#dom-pointerevent-altitudeangle
m.azimuthAngle:#dom-pointerevent-azimuthangle
m.isPrimary:#dom-pointerevent-isprimary
m.persistentDeviceId:#dom-pointerevent-persistentdeviceid
m.getCoalescedEvents:#dom-pointerevent-getcoalescedevents
m.getPredictedEvents:#dom-pointerevent-getpredictedevents
	getCoalescedEvents:#getCoalescedEvents

	m.ownerDocument:~DOM4#dom-node-ownerdocument

m.ongotpointercapture:#dom-globaleventhandlers-ongotpointercapture
m.onlostpointercapture:#dom-globaleventhandlers-onlostpointercapture
m.onpointerdown:#dom-globaleventhandlers-onpointerdown
m.onpointermove:#dom-globaleventhandlers-onpointermove
m.onpointerrawupdate:#dom-globaleventhandlers-onpointerrawupdate
m.onpointerup:#dom-globaleventhandlers-onpointerup
m.onpointercancel:#dom-globaleventhandlers-onpointercancel
m.onpointerover:#dom-globaleventhandlers-onpointerover
m.onpointerout:#dom-globaleventhandlers-onpointerout
m.onpointerenter:#dom-globaleventhandlers-onpointerenter
m.onpointerleave:#dom-globaleventhandlers-onpointerleave

m.DOM_DELTA_PIXEL:#dom-wheelevent-dom_delta_pixel
m.DOM_DELTA_LINE:#dom-wheelevent-dom_delta_line
m.DOM_DELTA_PAGE:#dom-wheelevent-dom_delta_page
m.deltaX:#dom-wheelevent-deltax
m.deltaY:#dom-wheelevent-deltay
m.deltaZ:#dom-wheelevent-deltaz
m.deltaMode:#dom-wheelevent-deltamode

mb.deltaX:#dom-wheeleventinit-deltax
mb.deltaY:#dom-wheeleventinit-deltay
mb.deltaZ:#dom-wheeleventinit-deltaz
mb.deltaMode:#dom-wheeleventinit-deltamode

m.initMouseEvent:#dom-mouseevent-initmouseevent

	＠~CSSOMVIEW#dom-document-elementfrompoint
	＠~CSSOMVIEW#dom-document-elementsfrompoint
	＠~UIEVENTS#dom-keyboardevent-getmodifierstate

	●code 他
c.Math.round:~TC39#sec-math.round
c.Math.floor:~TC39#sec-math.floor

et.auxclick:#dfn-auxclick
et.click:#dfn-click
et.contextmenu:#dfn-contextmenu
et.dblclick:#dfn-dblclick
et.mousedown:#dfn-mousedown
et.mouseenter:#dfn-mouseenter
et.mouseleave:#dfn-mouseleave
et.mousemove:#dfn-mousemove
et.mouseout:#dfn-mouseout
et.mouseover:#dfn-mouseover
et.mouseup:#dfn-mouseup
et.wheel:#dfn-wheel

et.pointerover:#dfn-pointerover
et.pointerenter:#dfn-pointerenter
et.pointerdown:#dfn-pointerdown
et.pointermove:#dfn-pointermove
et.pointerup:#dfn-pointerup
et.pointercancel:#dfn-pointercancel
et.pointerout:#dfn-pointerout
et.pointerleave:#dfn-pointerleave
et.gotpointercapture:#dfn-gotpointercapture
et.lostpointercapture:#dfn-lostpointercapture
et.pointerrawupdate:#dfn-pointerrawupdate

et.blur:~UIEVENTS#event-type-blur
	et.blur:~HTMLindex#event-blur
et.focus:~UIEVENTS#event-type-focus
	et.focus:~HTMLindex#event-focus
et.focusout:~UIEVENTS#focusout
et.dragstart:~HTMLdnd#event-dnd-dragstart

~hover_ps 疑似類:~SELECTORS4#the-hover-pseudo
	~TR/CSS2/selector.html#dynamic-pseudo-classes
p.pointer-events:~CSSUI#propdef-pointer-events
p.touch-action:#propdef-touch-action
p.display:~CSSDISP#propdef-display
p.width:~SIZING#propdef-width
	p.width:~CSS2J#propdef-width
p.height:~SIZING#propdef-height
	p.height:~CSS2J#propdef-height

e.iframe:~HEembed#the-iframe-element
e.canvas:~HEcanvas#the-canvas-element
e.span:~HEtextlevel#the-span-element


	●用語
	取消されたか
~pointer型:#dom-pointerevent-pointertype
~pointer~event~streamを抑止する局面:#dfn-suppress-a-pointer-event-stream
~pointer~event~streamを抑止する:#_suppress-a-pointer-event-stream
	~layout変化:#dfn-events-from-layout-changes
~buttonの追加押下げ:#dfn-chorded-buttons
追加押下げ:#dfn-chorded-buttons
	#chorded-button-interactions

首~pointer:#dfn-primary-pointer
合体された~event群:#coalesced-events
合体d~event~list:#dfn-coalesced-events-list
	:#predicted-events
予測された~event群:#predicted-events
予測d~event~list:#dfn-predicted-events-list
~pointer~eventを発火する:#dfn-fire-a-pointer-event
~pointer~eventを発火-:#dfn-fire-a-pointer-event

~PointerEventを作成する:#dfn-creating-a-pointerevent
~PointerEventを初期化する:#dfn-initialize-a-pointerevent
~MouseEventから~PointerEventを作成する:#dfn-creating-pointerevent-from-mouseevent

~pointer捕捉:#dfn-pointer-capture
捕捉-:#dfn-pointer-capture
	Pointer Capture:#dfn-pointer-capture
捕捉している~target:#dfn-pointer-capture-target-override
~pointer捕捉を設定する:#dfn-set-pointer-capture
~pointer捕捉を解放する:#dfn-release-pointer-capture
~pointer捕捉を暗黙的に解放する:#dfn-implicitly-release-the-pointer-capture
処理待ち~pointer捕捉を処理する:#dfn-process-pending-pointer-capture

互換性~mouse~event:#compatibility-mapping-with-mouse-events
旧来の~mouse~pointerの実効~位置:#dfn-effective-position-of-the-legacy-mouse-pointer
~hoverを~supportしない:#mapping-for-devices-that-do-not-support-hover
~hoverを~supportしない装置:#mapping-for-devices-that-do-not-support-hover
適合する:#dfn-conforming-touch-behavior

	●用語（MouseEvent/WheelEvent

最後の~mouse~DOM経路:#dfn-last-mouse-dom-path
最後の~mouse要素:#dfn-last-mouse-element
現在の~click回数:#dfn-current-click-count
	現在の~click回数:#current-click-count
内部~UIkey修飾~状態:#dfn-internal-key-modifier-state
~UIkey修飾~名:#dfn-key-modifier-name
修飾~UIkey状態~map:#_modifiers-map
接触判定する:#dfn-hit-test
接触判定:#dfn-hit-test
~MouseEventを作成する:#_create-a-mouseevent
	取消~可能な~MouseEventを作成する＠#dfn-creating-a-cancelable-mouseevent
	取消~不能な~MouseEventを作成する＠#dfn-creating-a-non-cancelable-mouseevent
~MouseEventを初期化する:#dfn-initialize-a-mouseevent
~MouseEvent属性を~nativeな~eventから設定する:#dfn-set-mouseevent-attributes-from-native
~button名を整数に変換する:#dfn-calculate-mouseevent-button-attribute
~click~eventを送信する:#dfn-send-click-event
~mouse~button~bitmask:#dfn-mouse-button-bitmask
~mouse~button名:#_mouse-button-name
表示域~座標:#_viewport-coordinates
~desktop座標:#_desktop-coordinates
~mouse~eventの修飾~UIkey状態を設定する:#dfn-set-mouse-event-modifiers
~nativeな~clickを取扱う:#dfn-handle-native-mouse-click
~nativeな~double-clickを取扱う:#dfn-handle-native-mouse-double-click
~nativeな~mousedownを取扱う:#dfn-handle-native-mouse-down
~nativeな~mousemoveを取扱う:#dfn-handle-native-mouse-move
~nativeな~mouseupを取扱う:#dfn-handle-native-mouse-up
必要なら~pointer~eventを送信する:#_maybe-send-pointer-event

必要なら文脈~menuを示す:#dfn-maybe-show-context-menu
§ 各種~mouse~eventに共通な文脈~情報:#_common-mouse-event-context

~wheel~event~transaction:#dfn-wheel-event-transaction
測定~単位:#_scroll-unit

	●用語（用語集
作動~状態:#dfn-active-buttons-state
作動中な文書:#dfn-active-document
作動中な~pointer:#dfn-active-pointer
作動中:#dfn-active-pointer
捕捉~target:#dfn-pointer-capture-target-override
処理待ち捕捉~target:#dfn-pending-pointer-capture-target-override
接触~幾何:#dfn-contact-geometry
~delta:#dfn-delta
~digitizer:#dfn-digitizer
直な操作:#dfn-direct-manipulation
直な~pan-zoom:#_direct-manipulation-for-panning/zooming
~hysteresis:#dfn-hysteresis
測定-可能な~prop:#dfn-measurable-properties
~pointer:#dfn-pointer
回転:#dfn-rotation
最上層な~event~target:#dfn-topmost-event-target

~event連列:#_event-sequence
~mouse~event:#_mouse-event
~pointer~event:#_pointer-event
~pointing先:#_pointing
捕捉~込みの~pointing先:#_pointing-with-capture
	~targetを決定する段:#dfn-determine-the-target → 捕捉~込みの~pointing先
境界~event:#_boundary-event
右手~座標系:#_right-hand-coordinate-system
有効に変化-:#_effectively-changed

§ ~pointer~event:#pointer-events-and-interfaces


	●用語（UIEVENTS
~MouseEvent用に各~pointer~lock属性を初期化する:~UIEVENTS#initialize-pointerlock-attributes-for-mouseevent
~UIEventを初期化する:~UIEVENTS#initialize-a-uievent
~mousemove用に各~pointer~lock属性を設定する:~UIEVENTS#set-pointerlock-attributes-for-mousemove
修飾~UIkey:~UIEVENTS#modifier-key
修飾~UIkey状態:~UIEVENTS#key-modifier-state
未初期化~値:~UIEVENTS#un-initialized-value
既定~動作:~UIEVENTS#default-action
~host言語:~UIEVENTS-A#host-language
~UIkey値:~UIEVENTS#key-value

修飾~UIkeyの表t:~UIEVENTS-KEY#keys-modifier

	●用語（外部
~UA:~INFRA#user-agent
~map:~INFRA#ordered-map
付加する:~INFRA#list-append
連結する:~INFRA#string-concatenate

~target:~DOM4#event-target
~eventを発火する:~DOM4#concept-event-fire
	#dfn-fire-an-event-named-e
	~eventを発火-
~eventを作成する:~DOM4#concept-event-create
~eventを配送する:~DOM4#concept-event-dispatch
~event構築-時の手続き:~DOM4#concept-event-constructor-ext
~event~listener:~DOM4#concept-event-listener
	I.EventListener:~DOM4#callbackdef-eventlistener
evL.受動的か:~DOM4#event-listener-passive
	m.passive:~DOM4#dom-addeventlisteneroptions-passive
ev.取消されたか:~DOM4#canceled-flag
作動化の挙動:~DOM4#eventtarget-activation-behavior

~node文書:~DOM4#concept-node-document
接続されて:~DOM4#connected
文書~要素:~DOM4#document-element
文書:~DOM4#concept-document
先祖:~DOM4#concept-tree-ancestor
共通な広義-先祖:~DOM4#_common-inclusive-ancestor
広義-子孫:~DOM4#concept-inclusive-descendant
広義-先祖:~DOM4#concept-tree-inclusive-ancestor

~body要素:~HTMLdom#the-body-element-2
切断された:~HTMLINFRA#becomes-disconnected
~objを~focusする:~HTMLinteraction#focusing-steps
不活:~HTMLinteraction#inert
fe.不能化されて:~HTMLforms#concept-fe-disabled
~clickで~focus可能:~HTMLinteraction#click-focusable
~event~handler:~WAPI#event-handlers
~focus可能な区画:~HTMLinteraction#focusable-area

~event~handler~IDL属性:~WAPI#event-handler-idl-attributes
~task:~WAPI#concept-task
~event~loop:~WAPI#event-loop
enV.~secureな文脈:~WAPI#secure-context

~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
bc.容器:~BROWSERS#bc-container


	●用語（CSS
~scroll容器:~CSSOVERFLOW3#scroll-container
~box~tree:~CSSDISP#box-tree
置換され:~CSSDISP#replaced-element
行内~要素:~CSSDISP#inline
行内~box:~CSSDISP#inline-box
根~要素:~CSSDISP#root-element
表示域:~CSS2J#viewport
積層~文脈:~CSS2J#stacking-context
積層~文脈を塗る:~CSSPOS4#paint-a-stacking-context
有位置:~CSSPOS#positioned-box

	●補完

関連な設定群~obj:~WAPI#relevant-settings-object

前回の~target:#_previous-target
~over~eventは必要か:#_needs-over-event
互換性~mouse~eventも込みで配送する:#_fire-compatibility-mouse-events
~mouse~eventは防止するか:#_prevent-mouse-event-flag


文書~tree内:~DOM4#in-a-document-tree

~trusted:~UIEVENTS#_trusted-event
取消~可:~UIEVENTS#_cancelable
浮上-:~UIEVENTS#_bubbles
	廃）同期的:~UIEVENTS#sync-async

~window:~WINDOW#the-window-object

●●words_table1

WEBDRIVER-BIDI:https://w3c.github.io/webdriver-bidi/
TOUCHEVENTS:https://w3c.github.io/touch-events/
public_pointer_events:https://lists.w3.org/Archives/Public/public-pointer-events
POINTEREVENTS_pull:https://github.com/w3c/pointerevents/pull
UIEVENTS-A:uievents-appendix-ja.html
UIEVENTS-KEY:uievents-key-ja.html

hover_ps:<code class="pseudo">:hover</code>


●●words_table

	●UI
UX:
利用者体験:experience:~
様式:modalities:方式
	~overscroll
	~pull-to-refresh
pointing::::ポインタ指示
metaphor::::メタファー
affordance::::アフォーダンス
X1:
	~X1:x1
X2:
	~X2:x2
drag::::ドラッグ
drop::::ドロップ
二連-:double-::~
tap::::タップ
hover::::
	hoverしている／:hovering
	に類するkeyboard-like
mouse-ball::::マウスボール
trackpad::::トラックパッド
trackball::::トラックボール
laptop::::ラップトップ
desktop::::デスクトップ
double-click::::ダブルクリック
reader:::読取り器::リーダ
pan::::パン
panning::::パン操作
zoom::::ズーム
zooming::::ズーム操作
pan-zoom:panning／zooming:::パン／ズーム操作
scrolling::::スクロール操作
slide::::スライド
slider::::スライダ
thumb:::つまみ
pen::::ペン
stylus::::スタイラス
	~penや~stylus:pen/stylus
回転台:carousel:~
component::::コンポーネント
checkbox::::チェックボックス
中央:middle:中
左:left:~
右:right:~
digitizer::::ディジタイザ
eraser::::イレーザ
barrel::::バレル
airbrush::::エアブラシ
wheel::::ホイール
中立:neutral:~
swipe::::スワイプ
twist::::ツィスト
touch::::タッチ
touchscreen::::タッチスクリーン
touchpad::::タッチパッド
transducer::::
voice::::ボイス
感知:sense::~
感知器:sensing device::~
	~sense:sense:::
mobile::::モバイル
tablet::::タブレット
	単独の:single-
押-:press:~
押す:pressする:~
長押し:long-press:~
	押して
押下する:depressする:押下げる
押下され:depressされ:押下げられ
	~~押されて:being held
	~~押下げて:down
追加押下げ:chorded presses:~
離され:releaseされ:~
離した:releaseした:~
	~~離した:liftした
	~chorded:chorded:::
	~chordedボタン:presses
押圧:pressure::~
圧:pressure::~
物理面:surface:~

持上げら:liftさ:持ち上げら
手指:finger:指
	手指を離さず動かして:and hold for single-finger
接触:contact::~
接触-:contact::~
	近接しているclose proximity
操作o:operation:操作
	~~操作
支援技術:assistive technology:~
主導的:master:~
前後:back-and-forth:~
動き:movement:~
動く:moveする:~
動いた:moveした:~
動いて:moveして:~
動かさ:moveさ:~
動かす:moveする:~
	動かした:moveした
	動かして:-
掴んで:grabして:~
制動-:counteract:~
制動:counteraction:~
惰性:simulated inertia:~
敏捷:rapid:~
休めれ:restでき:休められ:~
遅める:slow downする:~
勢い:momentum:~
知覚:perception:~
知覚-:perceive:~
clean::::クリーン
選択-:select:~
選択:selection:~
強調-:highlight:~
開く:openする:~
開いた:openした:~
閉じる:closeする:~
閉じな:closeしな:~
矩形:rectangle:~
静止中:stationary:~
回転動作:literal rotation:~
hysteresis::::ヒステリシス
所在的:locative:~
時間的:temporal:~
不活:inert::~
押下げら:depressさ:~
ズラして:shiftして:ずらして
許容誤差:tolerance::~
加速機能:acceleration:~

	~double-click:mouse double-click
	~click:mouse click
	~mousemove:mouse move
	~mousedown:mouse down
	~mouseup:mouse up
	もっと勢いをつける:provide further momentum
	置いて:place
	投げつけ:fling
	錯覚させる:providing a physical illusion
	出た:leave
	から出て行く際の:for leaving
	出た:moved off
	外へ出た:out
	なくなった:leave
	へ入って行く際の:for entering
	なった:enter
	それた:slides off
	それた:drifts off
	それる:stray
	~buttonが押され:down
	利用-中にある:actively being used
	手:hand
	素早く:quickly
	~pointer~event:pointerevent
	^en:overscroll
	^en:pull-to-refresh
	出入り:entry/exit
	^en:back
	^en:forward
	指して:pointing
	指す:point
	直前に指していた:whose bounds the pointer just left
	直後に指している:whose bounds the pointer is entering
	去る:leave
	去らない:leave
	~button:Button
	戻った:back
	手形:hand
	~space~bar:spacebar
	叩いた:hit
	~page~~区分:demarcated page
	少しの時間差:small deviation in the time
	~UItab帯:tab-strip

	●event
bind::::バインド
処理待ち:pending::~
bitmask::::ビットマスク
	~bitごとの:bitwise
delta::::デルタ

	retarget
	~targetに:target
受動的:passive::~
経路:path::~
trusted:
	~trustedでない:untrusted
首:primary:~
副:secondary:~
中央:middle:中
予備:auxiliary:~
修飾:modifier::~
	~focus可能:focusable
	同時に:simultaneous
合成な:syntheticな:~
作動:active::~::アクティブ
誘発:triggering:~
解放-:release:~
	~~連列:stream
生産:production:~
捕捉:capture::~
	捕捉~target:pointer capture target override
	~pointer捕捉:pointer-capture
	捕捉されずに:uncaptured
合体d:coalesced::合体
合体-:coalesce::~
	合体されない:un-coalesced
	合体されない:non-coalesced
予測d:predicted::予測
予測-:predict::~
予測:prediction::~
序列:order::~
over:

	取消~可否:cancelability
	取消~可能:cancelable
	取消~不能:non-cancelable

	●接触判定
接触判定-:hit test::~
接触判定:hit testing::~
最上層:topmost:~
積層-:stack::~
積層:stacking::~

	最も上層:highest
	最も手前に:frontmost
	最も手前に:over the stack
	最下層:bottom
	離れた:left
	~~重なる
	外へ出た
	境界をまたいだ:moved onto the boundaries

	●幾何
X-Y:
X-Z:
X:
Y:
x:
y:
radian::::ラジアン
傾き:tilt:::~
	側に傾いて:tilt away
仰角:altitude::~
方位角:azimuth angle::~
	方位角:azimuth
接線:tangent::~
接線方向:tangential::~
曲線:curve:~
線:line:~
点群:points:~
点:point:~
法線:normal::~
平面:plane::~
幾何:geometry::形状
回転:rotation::~
回転-:rotate::~
変形:transform::~
時計回り:clockwise::~
	そこから時計回りに:progressively 〜 going clockwise
平行:parallel::~
垂直:perpendicular::~
横:horizontal::~
縦:vertical::~
横方向:horizontal::~
縦方向:vertical::~
分解能:resolution::~
滑らか:smooth:~
	より滑らか:smoother
軌跡:trajectory:~
右手:right-hand:~
空間的:spatial:~
重合する:overlapする:重なり合う

	左方:left
	上方:upward
	上方:up
	正な~X軸~方向:direction of increasing X values
	真上から見て:looking straight down
	〜時:o'clock"
	角張った様子が目立つ:noticeably angular and jagged
	左下から右上へ:from the bottom left to the top right
	きめ細かな:granular
	速く:fast
	速く／速いほど:faster
	速さ:speed
	速める:speed-up
	大きな:large
	近く:closely
	~~地点を囲う矩形域:bounding box
	~~地点:at which
	その端:extent
	~~右端:right-most extent
	どれほど離れるか:how far they
	右方／下方／奥方:right-most edge, bottom-most edge, and farthest depth 

	●処理

単調増加-:monotonic に increase:~
	単調増加-:monotonically-increasing
投機的:speculative::~
丸める:roundする:~
併合-:merge::~
時系列順:chronological:~
起動:initiation:~
transaction::::トランザクション
連結-:concatenate:~

	複-~thread化:multi-threaded
	し続ける:continue
	何もしない:fails silently
	速く:fast
	逆:reverse
	一定時間内に:within a set period of time
	あらゆる回:every time
	事前に:ahead
	より早くに:earlier
	次回:next
	次回:next time
	常に一緒に配送される:never be dispatched in isolation
	存続する限り:lifetime
	1 に設定し直され:reset

contextmenu:
mousemove:
mousedown:
mouseup:
mouseover:
mouseout:
mouseenter:
mouseleave:
UIEvent:
MouseEvent:
PointerEvent:
PointerLock:

	●変数

	%名前:-
	%~member名:-
	%位置:pos
	%~event:event
	%~event:The "parent" trusted pointermove and pointerrawupdate event
	%~event型:eventType
	%~event~target:eventTarget
	%浮上するか:bubbles
	%取消~可能か:cancelable
	%修飾~状態:-
	%~UIkey名:-
	%取消~不能か:-
	%~button~ID:mbutton
	%~nativeな~event:native
	%~target:target
	%~target~DOM経路:targetDomPath
	%~mouseout:mouseout
	%~mouseleave要素~群:leaveElements
	%要素:element
	%~mouseleave:mouseleave
	%~mouseover:mouseover
	%~mouseenter要素~群:enterElements
	%~mouseenter:mouseenter
	%~mousemove:mousemove
	%~contextmenu:contextmenu
	%取消されなかったか:result
	%e:e
	%~pointer:-
	%~pointer:the pointer
	%旧-~target:-
	%新-~target:-
	%~mouse~event:mouseevent
	%~pointer~event:-
	%利用者~event:userEvent
	%模倣された最大~touch接触~数:emulated maxTouchPoints
	%文書:-
	%~list:-
	%旧~位置:-
	%新~位置:-
	%装置~型:pointerType

	●保安
推定-:infer:~
発生-:arise:~
持続-:persist:~
	persistent
降格-:downgrade:~
sensor::::センサー
	~random／~randomに:randomize
一時的な:temporary:~
個人識別可能:personally-identifiable:~
機密的:confidential:~
私的閲覧:incognito:~
高価値:high-value:~
可能性:possibility:~

	得る:gain
	~~扱:deal with
	~~感知~exert
	potentially
	限られ:limit

	●仕様
overhead::::オーバーヘッド
手間:cost:~
統一-:unify:~
安定的:stable:~
偶発的:accidental:~
今日:today:~
類似性:similarities:~
同義語:synonymous:~
実効:effective:~
有効果:effective:~
現在:currently:~
用語集:glossary:~
不問な:agnosticな:依らない
	OPTIONAL
慣行:convention:~
支配的:dominant:~
特質:property:~:::プロパティ
opt-in:
	あるいは〜ヨイ:may opt to
手助け:facilitate:~
拡げら:expandさ:~
	選ぶ:chooseする
	ことにする:chooseする
移行:migration:~
減らす:reduceする:~
翻訳-:translate:~
周知:known:~
採用-:adopt:~
相補的:complementary:~
	もう片方:complementary
捏造な:fakeな:捏造された
直接間接:direct or indirect:~
条項:clause:~
参照r:refer:参照
処する:dealする:~
立証-:prove:~
退役-:retire:~
策:strategy:~
多人数協同:multi-user collaborative:~
最小化-:minimize:~
模倣-:emulate:~
模倣s-:simulate:模倣
義務:mandatory:~
説明書き:explainer:~
責務:responsibility:~
想定-:envisage:~
露呈-:reveal:露わに
為せ:makeでき:~
為され:makeされ:~
参加者:participant:~
proprietary::::プロプライエタリ
由来-:originate:~
	由来するもの:origin
無視r:disregard:無視することに
応答性:responsiveness:~
補足-:supplement:~
補足的:supplemental:~
	補足的な:supplementary
標準的:standard:~
直書き:hardcode:~

	低~level:low-level
	高~level:high-level
	版:edition
	-:advice
	備考:notes
	あり得る／可能性もある:possible
	節:section:~
	視野から外れる:out of scope
	難しく:hardに
	まず~~第一に:In the first instance
	~~第二の:additional key 〜
	区別されない:no distinction
	直前:right before／Immediately before
	できる:capable
	支持を受けて:in favor of
	note
	noted
	~~区別する:differentiating
	方々:people
	先駆的:pioneer
	acknowledge
	~~向上:augmented／get the best
	~helped
	大勢を占めている:vast majority
	ないと見込まれる:unlikely
	見込みが高い:likely
	しないように:avoid
	~~重要な:key
	UA既定の挙動で
	易く
	招かれ:incurされ
	至る:lead
	易くする:help with
	map
	mapping
	要約-:summary
	に委ねら:left up to
	ならば:suppose
	使い回して:recycle
	run
	vary
	生じさせ:causing
	生じる:caused
	-:caused
	書-:write
	書かれ:written
	指す:refer する／
	悪影響を及ぼす:negatively impact
	常に:cannot be changed during
	はず:should
	事:fact
	足る:suffice
	足らない:not enough
	ではない:as opposed to
	情報:info
	~~許可された:opt-in
	事実においては:it does in fact
	見受けられ:appears to
	にもかかわらず:despite
	選んで:choose
	助けに:help
	数えられ:count
	もっと詳しく言えば:more aptly
	を問わず:no matter
	未来のどこまで:how far into the future
	〜に際して:when it comes to
	〜するよう促す:transition
	かまわない:free to
	注記:note
	互換性~mouse~event:compat event ／ :compat mouse event
	事実:fact
	規範的でない:informative
	事実:fact
	~~調和を図る~to be able to reconcile
	~~説明:illustrate
	~WG:working group
	自由に:freely
	ためとして:for the purpose of
	最大限に得る:maximum
	兼ね合いをとる:balance
	~~注力する:taking care
	無さそうに見えるが:appears to have no
	適した:fits
	似た名前の:similarly named
	注記:note
	この仕様:Pointer Events specification
	各種~mouse~event:Mouse Events
	各種~wheel~event:Wheel Events
	書くこと:writing
	多岐にわたる:diverse

	●未分類
WebDriver-BiDi:WebDriver BiDi
body:
旧-:old:~
新-:new:~
連続的:continuous:~
連続して:consecutiveに:~
実数:real number:~
稼働中の:runしている:~
始まる:beginする:~
移動:movement:~
競合-:conflict:~
超過-:exceed:~
構成-:compose:~
描く:drawする:~
描いた:drawした:~
描かれ:drawされ:~
描き:drawing:~
塗る:paintする:~
塗ng:painting:塗り
塗られ:paintされ:~
computing::::コンピューティング
等価な:equivalent:~
粗い:coarseな:~
重複:duplication:~
頭頂:cap:~
粒度:granularity:~
忠実度:fidelity:~
近似-:approximate:~
	近似-:approximation
生の:raw:~
確認-:confirm:~
小数付きな:fractionalな:小数部を伴う
切断-:disconnect::~
display::::ディスプレイ
refresh::::リフレッシュ
rate::::レート
頻度:frequency:~
	頻度:as frequently as
	高~頻度:high frequency
累積:accumulation::~
揃える:alignする:~
本物の:realな:~
集成:aggregation:~
切断-:disconnect::~
受取り:receiveし:受け取り
表面:surface:~
増大-:increase:~
増分的:incremental:~
増やす:incrementする:~
初期化子:initializer:~
丸めた:roundした:~
丸めら:roundさ:~
介在-:intervene:~
先行-:precede::~
後続-:follow:~
身体的不利:physical disabilities:~
総和:sum:~
見積もら:estimateさ:~
近過去:recent:~
深く:deepに:~
量:amount:~
回数:count:~
符号:sign:~
淵:edge:~
文脈l:contextual:文脈
未初期化:un-initialized:~
文脈依存:varies:~
代用-:substitute:~
行高:line-height:~

	手が震える:unsteady hands
	後続して〜変化:subsequent change in
	引き続き:subsequently
	^en:concatenation
	-:COULD
	-:turn to get
	挟まれて:intermediate
	重ねて:overlapping
	-:clear
	大きさ:magnitude
	-:mark
	-:mentioned
	:nothing
	:greater
	:get
	:look
	:made
	~NEQ:equal
	:point
	~~性質:qualities
	:space
	数:number
	へ向かう:toward
	単に:simply
	順に 〜 最初:nearest
	-:nearest
	°:degree
	属性:property
	〜組:sets of／:set of
	touch-action^p:touch-action
	^I:PointerEvent
	~script:JavaScript
	Google Chrome
	Microsoft Edge
	Mozilla Firefox
	tilt2spherical^c:tilt to spherical

	黒っぽい／中空な:grey
	赤い:red
	丸:dot
	中空な丸:circle
	近接図:close-up view
	`touch-action^p が指定されていなければ 〜 に至る:otherwise lead to 
	-:from a large domain
	~ID:pointerId
	とる~IDたち:elements of 
	高:high
	白い:white
	橙色:orange
	-:intrinsic
	途中:is taking place
	まったく:at all
	以前の:previous
	~amongst
	ほとんどは:mostly
	一部:part
	一環:part of
	一連の:series of
	一連の:successive
	~~主な:major
	~~主:major
	~~主要な:substantial
	それら:those
	まだ:still
	より先に:prior
	のみならず:not just
	様々に:vary
	一式:single set
	直後:immediately after
	respective
	respectively
	follow
	followed by
	:further
	その逆に:vice-versa
	種々の:variety
	各種:various
	複数／:two
	:no longer
	よく:a lot
	たくさん:lots of
	別個:separate discrete
	最終-:final
	最終的:final
	最終的に:final
	広く:broadly
	それだけ:just as
	最~小:smallest
	直前:moment before
	時点:at the moment
	一緒:together
	同時:simultaneous
	各自に対応する:respective
	から〜まで:the time period
	その間，:period
	互いに差し挟まれ:interleave
	〜と同じ値をとる:match the values of
	先行-:precede
	先行-:last
	一定:constant
	変化しない:remain unchanged
	複数:different
	~~移動距離や~~頻度:lag time, degree, distance, and number of
	表示位置はそのままに
	逆順:reverse
	環境設定:environment configuration
	環境設定:environment settings
	渡-:pass
	互いに相対的な順序:set order relative to one another
	外れた:out
	直ぐに:immediately
	なぞる:along
	遠ざかる:away from
	二回:twice
	~~収まる:falls within
	吸い取る:swallow
	~~持続的:sustained
	~~指す／:point
	~pointing先:containing block
	似た:similarly
	倍々に:double
	より~~上位~bitに対応する:starting with 0x08
	~~持続的な:sustained
	一定限度までは:within a certain range
	同時に複数の軸が回転された場合:diagonal
	微小な時間差:small deviation in the time
	1 画素~単位より精細に:sub-pixel
	正負:sign／positive or negative
	複数回 生じ得る:Multiple mousemove events
	0 回 以上生じ得る:OPTIONAL, multiple events
	回され:turned
	~mouse:mice
	一群の:single set of
	無さそうに見える:appears to have no
	どのように作動されるか:actuation method

●●images
＠pointerevents/
martini_glass｜height:280px;｜｜pointer.png
tiltX｜height:30em;｜｜.png
tiltY｜height:30em;｜｜.png
altitudeAngle｜height:30em;｜｜.png
azimuthAngle｜height:30em;｜｜.png
	slider｜height:40px;｜Custom Volume Slider｜.png
coalesced-points｜height:260px;｜｜.png
predicted-points｜height:260px;｜｜.png
stacked-event-mouse-dispatch｜height:250px;｜＝Graphical representation of three stacked elements all on top of each other. The bottom element is labeled A and the top element is C｜.svg


●●ref_normative

[CSS-OVERFLOW-3]
    ＜CSS Overflow Module Level 3＞. Elika Etemad; Florian Rivoal. W3C. 7 October 2025. W3C Working Draft. URL: https://www.w3.org/TR/css-overflow-3/ 
[css-position]
    ＜CSS Positioned Layout Module Level 3＞. Elika Etemad; Tab Atkins Jr. W3C. 7 October 2025. W3C Working Draft. URL: https://www.w3.org/TR/css-position-3/ 
[CSS21]
    ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. Bert Bos; Tantek Çelik; Ian Hickson; Håkon Wium Lie. W3C. 7 June 2011. W3C Recommendation. URL: https://www.w3.org/TR/CSS2/ 
[CSSOM-View]
    ＜CSSOM View Module＞. Simon Fraser; Emilio Cobos Álvarez. W3C. 16 September 2025. W3C Working Draft. URL: https://www.w3.org/TR/cssom-view-1/ 
[DOM]
    ＜DOM Standard＞. Anne van Kesteren. WHATWG. Living Standard. URL: https://dom.spec.whatwg.org/ 
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. Ecma International. URL: https://tc39.es/ecma262/multipage/ 
[HTML]
    ＜HTML Standard＞. Anne van Kesteren; Domenic Denicola; Dominic Farolino; Ian Hickson; Philip Jägenstedt; Simon Pieters. WHATWG. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[HTML401]
    ＜HTML 4.01 Specification＞. Dave Raggett; Arnaud Le Hors; Ian Jacobs. W3C. 27 March 2018. W3C Recommendation. URL: https://www.w3.org/TR/html401/ 
[infra]
    ＜Infra Standard＞. Anne van Kesteren; Domenic Denicola. WHATWG. Living Standard. URL: https://infra.spec.whatwg.org/ 
[PointerEvents]
    ＜Pointer Events＞. Patrick Lauke; Robert Flack. W3C. 11 February 2026. W3C Working Draft. URL: https://www.w3.org/TR/pointerevents4/ 
[PointerLock]
    ＜Pointer Lock 2.0＞. Mustaq Ahmed; Vincent Scheib. W3C. 29 September 2025. W3C Working Draft. URL: https://www.w3.org/TR/pointerlock-2/ 
[RFC2119]
    ＜Key words for use in RFCs to Indicate Requirement Levels＞. S. Bradner. IETF. March 1997. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc2119 
[RFC8174]
    ＜Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words＞. B. Leiba. IETF. May 2017. Best Current Practice. URL: https://www.rfc-editor.org/rfc/rfc8174 
[TOUCH-EVENTS]
    ＜Touch Events＞. Doug Schepers; Sangwhan Moon; Matt Brubeck; Arthur Barstow. W3C. 10 October 2013. W3C Recommendation. URL: https://www.w3.org/TR/touch-events/ 
[UIEVENTS]
    ＜UI Events＞. Xiaoqian Wu. W3C. 10 February 2026. W3C Working Draft. URL: https://www.w3.org/TR/uievents/ 
[UIEvents-Key]
    ＜UI Events KeyboardEvent key Values＞. Travis Leithead; Gary Kacmarcik. W3C. 22 April 2025. W3C Recommendation. URL: https://www.w3.org/TR/uievents-key/ 
[WEBDRIVER-BIDI]
    ＜WebDriver BiDi＞. James Graham; Alex Rudenko; Maksim Sadym. W3C. 16 February 2026. W3C Working Draft. URL: https://www.w3.org/TR/webdriver-bidi/ 
[WEBIDL]
    ＜Web IDL Standard＞. Edgar Chen; Timothy Gu. WHATWG. Living Standard. URL: https://webidl.spec.whatwg.org/ 

●●ref_informative

[COMPAT]
    ＜Compatibility Standard＞. Mike Taylor. WHATWG. Living Standard. URL: https://compat.spec.whatwg.org/ 
[PointerEvents3]
    ＜Pointer Events＞. Patrick Lauke; Robert Flack. W3C. 13 February 2026. CRD. URL: https://www.w3.org/TR/pointerevents3/ 
[WCAG22]
    ＜Web Content Accessibility Guidelines (WCAG) 2.2＞. Michael Cooper; Andrew Kirkpatrick; Alastair Campbell; Rachael Bradley Montgomery; Charles Adams. W3C. 12 December 2024. W3C Recommendation. URL: https://www.w3.org/TR/WCAG22/ 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより勧告として公開された
<a href="~SPEC_URL">Pointer Events Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>



●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/pointerevents4/
公表履歴
	https://www.w3.org/standards/history/pointerevents4/
テスト一式
	https://wpt.fyi/pointerevents/
最新の勧告
	https://www.w3.org/TR/pointerevents/
編集
	Patrick H. Lauke (TetraLogical)
	Robert Flack (Google)
前任編集者
	Matt Brubeck (Mozilla)
	Rick Byers (Google)
	Navid Zolghadr (Google)
フィードバック
	<a href="https://github.com/w3c/pointerevents/">GitHub w3c/pointerevents</a> (<a href="https://github.com/w3c/pointerevents/pulls/">pull requests</a>, <a href="https://github.com/w3c/pointerevents/issues/new/choose">new issue</a>, <a href="https://github.com/w3c/pointerevents/issues/">open issues</a>)
	<a href="mailto:public-pointer-events@w3.org?subject=%5Bpointerevents3%5D%20YOUR%20TOPIC%20HERE">public-pointer-events@w3.org</a> with subject line <kbd>[pointerevents3] <em>… message topic …</em></kbd> (<a rel="discussion" href="https://lists.w3.org/Archives/Public/public-pointer-events">archives</a>)
ブラウザサポート
	https://caniuse.com/pointer
commit 履歴
	https://github.com/w3c/pointerevents/commits/
公表者
	<a href="https://www.w3.org/groups/wg/pointer-events">Pointer Events Working Group</a>
</script>

</head>

<body>

<template id="_persisted_parts">
<div
	id="_dgm-slider"
	style="margin: 0.5em;"
	aria-label="Custom Volume Slider"
	role="img"
>
<span style="vertical-align:middle;">音量：</span>
<div style="vertical-align:middle;
	display:inline-block;
	position:relative;
	border:solid 0.2em var(--N-color);
	width:15em;"
><div style="position:absolute;
	left:8em;
	top:-0.8em;
	width:1em;
	height:1.6em;
	background: var(--K-color);
"></div></div>
</div>

</template>

<header>
	<hgroup>
<h1>Pointer Events — Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この仕様は、
様々な装置【~pointing装置】
— ~mouse, ~touchscreen, ~penや~stylusを含む —
からの入力を取扱うための，~hardwareに不問な統一された~frameworkを定義する。
この仕様は、
一群の~event
（例： `pointerdown$et, `pointermove$et, `pointerup$et ）
を供することにより，多岐にわたる入力~methodを［
各~装置~用に特有な~logicを書くことなく，~supportすること
］を開発者に許容する。
◎
The Pointer Events specification defines a unified hardware-agnostic framework for handling input from various devices, including mice, touchscreens, and pens/styluses. By providing a single set of events (e.g., pointerdown, pointermove, pointerup), it allows developers to support diverse input methods without writing device-specific logic for each.
</p>

<p>
この仕様は、
各種［
~mouse~event／~wheel~event
］および
他の~pointer装置~型【~mouse以外の`~pointer型$】用に~mouse~eventを発火するための対応付けも定義する。
◎
This specification also defines Mouse and Wheel Events, as well as a mapping to fire Mouse Events for other pointer device types.
</p>

	</section>
	<section id="sotd">
◎位置付け

<p>
`この節では、公表~時点における…^em
【以下、この節の他の内容は，~SOTD-W3Cに移譲。】
</p>

<p>
この仕様（~level 4 ）は、
`PointerEvents3$r に対する更新である。
また、
以前は `UIEVENTS$r に在った［
~mouse~event, ~wheel~event
］も含む。
◎
This specification is an update to [PointerEvents3] specification. It also includes the Mouse and Wheel Events, previously in the [UIEVENTS] specification.
</p>

<p>
この改訂は、
次に挙げる新たな特能を含む：
◎
This revision includes new features:
</p>
<ul>
	<li>
`persistentDeviceId$m
⇒
各種~入力~装置~用に複数のヤリトリにまたがって安定的な識別子を供する。
◎
persistentDeviceId to provide a stable identifier for input devices across multiple interactions.
</li>
	<li>
`touch-action$p ~CSS~prop用の新たな値
⇒＃
`pan-left$v,
`pan-right$v,
`pan-up$v,
`pan-down$v
◎
new CSS touch-action values: pan-left, pan-right, pan-up, pan-down
</li>
</ul>

	</section>

<main id="MAIN0">

	<section id="intro">

<h2 title="Introduction">1. 序論</h2>

◎非規範的

<p>
今日のほとんどの `HTML$r 内容は、
~mouse入力~向けに利用され／設計されている。
入力を~custom方式で取扱う~codeは、
概して `~mouse~event$向けに書かれている。
しかしながら，今日のより新たな~computing機器は、
~touchscreenや~penも含む，他の形による入力も組入れている。
これらの入力~形の各々に対し，それを取扱うための~event型が個別に提案されてきている。
しかしながら，そのような~approachでは、
新たな型の入力~用に~supportが追加される度に，不必要な~logicの重複や, ~eventの取扱いにおける~overheadも招かれ易くなる。
これはまた、
内容が ある型の装置のみを念頭に書かれるときにも，互換性の問題を生じさせ易い。
加えて，~mouse用に書かれている既存の内容との互換性を得るため、
ほとんどの~UAは，どの型の入力に対しても`~mouse~event$を発火する。
このため、
`~mouse~event$が［
実際の~mouse装置を表現している
］のか, ［
別の型の入力~装置から，互換性を得るために生産されたもの
］なのか，多義的になり、
双方の型の装置に対応する~codeを書くのも難しくなっている。
◎
Today, most [HTML] content is used with and/or designed for mouse input. Those that handle input in a custom manner typically code to [UIEVENTS] Mouse Events. Newer computing devices today, however, incorporate other forms of input, including touchscreens and pen input. Event types have been proposed for handling each of these forms of input individually. However, that approach often incurs unnecessary duplication of logic and event handling overhead when adding support for a new input type. This often creates a compatibility problem when content is written with only one device type in mind. Additionally, for compatibility with existing mouse-based content, most user agents fire Mouse Events for all input types. This makes it ambiguous whether a Mouse Event represents an actual mouse device or is being produced from another input type for compatibility, which makes it hard to code to both device types simultaneously.
</p>

<p>
複数の入力~型に対応する~codeを書く手間を減らすため，および
上に述べた`~mouse~event$の多義性に~~対処し易くするため、
この仕様は，`~pointer$と呼ばれる より抽象的な入力~形を定義する。
［
~mouse~cursor, ~pen, ~touch（複-~touchも含む）, その他
］の~pointing装置により ~screen上に入力される どの接触~点も，~pointerになり得る。
この~modelにより、［
利用者~側の~hardwareを問わず，~siteや~appを上手く働くように書く
］ことは，より容易になる。
装置に特有な取扱いが欲される局面においては、
この仕様は，当の~eventを生産した装置の型を検分するための属性も定義する。
◎
To reduce the cost of coding to multiple input types and also to help with the above described ambiguity with Mouse Events, this specification defines a more abstract form of input, called a pointer. A pointer can be any point of contact on the screen made by a mouse cursor, pen, touch (including multi-touch), or other pointing input device. This model makes it easier to write sites and applications that work well no matter what hardware the user has. For scenarios when device-specific handling is desired, this specification also defines properties for inspecting the device type which produced the event.＼
</p>

<p>
この仕様の首な目標は、［
装置に依らない~pointer入力に対応する著作は、
より容易にする
］一方で［
利用者体験の~~向上に必要yな所では、
装置に特有な取扱いに限り許容する
］ような，一式の［
~event, および~interface
］を供することである。
◎
The primary goal is to provide a single set of events and interfaces that allow for easier authoring for cross-device pointer input while still allowing for device-specific handling only when necessary for an augmented experience.
</p>

<p>
~~第二の目標は、
~UAが`直な~pan-zoom$による動作
（一例として、
~touchscreenに対する手指や~stylusによるそれ）
を
— ~script実行を阻むことなく —
取扱えるよう，複-~thread化も可能化することである。
◎
An additional key goal is to enable multi-threaded user agents to handle direct manipulation actions for panning and zooming (for instance, with a finger or stylus on a touchscreen), without blocking on script execution.
</p>

<p class="note">注記：
この仕様は、
種々の~pointer入力~用に統一された~event~modelを定義する。
~keyboardに類する~UIなど，他の形の入力は、
この~modelは受持たない
（一例として、
~touchscreenのみの装置~上で稼働中の~screen~readerや類似な支援技術
— ~focus可能な［
~controlや要素
］を通して，利用者による連列的~naviを許容するような）。
その種の~UIに呼応して~pointer~eventを生成する~UAもあるかもしれないが、
それについては，この仕様は受持たない。
◎
Note
While this specification defines a unified event model for a variety of pointer inputs, this model does not cover other forms of input such as keyboards or keyboard-like interfaces (for instance, a screen reader or similar assistive technology running on a touchscreen-only device, which allows users sequential navigation through focusable controls and elements). While user agents might choose to also generate pointer events in response to these interfaces, this scenario is not covered in this specification.
</p>

<p class="note">注記：
作者には、
まず~~第一に，［
どの形の入力に対しても、
高~levelな~event
— `focus$et, `blur$et, `click$et, など —
で応答することにより，等価な機能性を供する
］ことが奨励される。
しかしながら，低~levelな~event（`~pointer~event$など）を利用するときは、［
すべての型の入力~用の~supportを確保する
］ことが奨励される。
~keyboardに類する~UIの事例においては、
そのためには，［
~keyboard~event用の明示的な取扱い
］の追加が要求されることもある。
詳細は、
`WCAG22$r `§ ~keyboard~access可能＠~TR/WCAG22/#keyboard-accessible
を見よ。
◎
In the first instance, authors are encouraged to provide equivalent functionality for all forms of input by responding to high-level events such as focus, blur and click. However, when using low-level events (such as Pointer Events), authors are encouraged to ensure that all types of input are supported. In the case of keyboards and keyboard-like interfaces, this might require the addition of explicit keyboard event handling. See Keyboard Accessible [WCAG22] for further details.
</p>

<figure id="figure_martini_glass">
<p class="alt" hidden id="_dgm-martini_glass">
~pointer入力は、
様々な入力~source
— ~mouse, ~pen, ~touch, など —
を組合せる。
◎
Pointer input combines various input sources such as mouse, pen, and touch
</p>
<figcaption>
~pointerは、［
~screen上の特定の座標（または座標たちが成す集合）を~targetに捉えられる入力~装置
］の~hardwareに不問な表現である。
◎
Figure 1＼
A pointer is a hardware-agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen.
</figcaption></figure>

<p>
汎用~pointer入力を取扱うための~eventは、
~mouse用のものとよく似る：
`pointerdown$et,
`pointermove$et,
`pointerup$et,
`pointerover$et,
`pointerout$et,
等々。
これは、［
内容を各種`~mouse~event$から`~pointer~event$への容易な移行
］を手助けする。
`~pointer~event$は、
各種`~mouse~event$に在る通例の属性すべて
（~client座標, ~target要素, ~button状態を含む）
を供することに加え，
他の形の入力
— 押圧（ `pressure^en ）, `接触~幾何$（ `contact geometry^en ）, 傾き（ `tilt^en ）, など —
用の新たな属性も供する。
作者は、
`~pointer~event$の~codeを［
異なる【装置】型の入力~間で同じ~logicを共有する
］ように書くことが容易になり、
最良な利用者体験に必要yな所に限って，特定0の型の入力を~custom化できる。
◎
The events for handling generic pointer input look a lot like those for mouse: pointerdown, pointermove, pointerup, pointerover, pointerout, and so on. This facilitates easy content migration from Mouse Events to Pointer Events. Pointer Events provide all the usual properties present in Mouse Events (including client coordinates, target element, button states) in addition to new properties for other forms of input, such as pressure, contact geometry, tilt. Authors can easily code to Pointer Events to share logic between different input types where it makes sense, and customize for a particular type of input only where necessary to get the best experience.
</p>

<p>
様々な入力~装置が`~pointer~event$の~sourceになり得るが、
`~pointer~event$が他の［
何らかの装置に特有な~eventたちが成す集合
（`~mouse~event$や~touch~eventなど）
］に属する~eventに伴って生成されるものとして定義されることはない。
この仕様は、
他の装置に特有な~eventの~supportは，要求しない。
そうすることもアリであり，互換性を得るために奨励されるが。
~UAは、
他のどの装置~eventも~supportすることなく，
~pointer~eventを~supportできる。
［
~mouseに特有な~event用に書かれた内容
］との互換性を得るため、
この仕様は，［
~mouse以外の装置による~pointer入力に基づいて，`互換性~mouse~event$を生成する
］ための方法も述べる。
◎
While Pointer Events are sourced from a variety of input devices, they are not defined as being generated from some other set of device-specific events. While possible and encouraged for compatibility, this spec does not require other device-specific events be supported (such as mouse events or touch events). A user agent could support pointer events without supporting any other device events. For compatibility with content written to mouse-specific events, this specification does provide an optional section describing how to generate compatibility mouse events based on pointer input from devices other than a mouse.
</p>

<p class="note informative">
この仕様は、［
`~pointer~event$,
`TOUCH-EVENTS$r に定義される~touch~event
］の両者を~supportする~UAに対し期待される挙動については，何も~~述べない。
これら二つの仕様の関係性についての更なる情報は、
`Touch Events Community Group＠https://www.w3.org/community/touchevents/$
を見よ。
◎
This specification does not provide any advice on the expected behavior of user agents that support both Touch Events (as defined in [TOUCH-EVENTS]) and Pointer Events. For more information on the relationship between these two specifications, see the Touch Events Community Group.
</p>

	</section>
	<section id="conformance">
<h2 title="Conformance">2. 適合性</h2>

<p class="trans-note">【
以下、この節の他の内容は
`~W3C日本語訳 共通~page＠~W3Ccommon#conformance$
に移譲。
】</p>

	</section>
	<section id="_conventions">
<h2>【この訳に特有な表記規約】</h2>

◎表記記号

	</section>
	<section id="examples">
<h2 title="Examples">3. 例</h2>

◎非規範的

<p>
以下では、
この仕様における一部の~APIを作者がどう利用し得るかをデモる基本的な例を与える。
さらには、
より特定な例も，この文書を成す関連な節に供される。
◎
The following are basic examples that demonstrate how some of the APIs in this specification might be used by authors. Further, more specific examples are provided in the relevant sections of this document.
</p>

<div class="example">
<p>
~pointer~event特能を検出して，~eventを~bindする例：
◎
Example 1: Feature detection and event binding
</p>

<pre class="lang-js">
/* <span class="comment">
`~pointer~event$, または［
伝統的 ~touch／~mouse
］のいずれかを~bindする
◎
Bind to either Pointer Events or traditional touch/mouse
</span> */

if (window.PointerEvent) {
    /* <span class="comment">
`~pointer~event$が~supportされる場合は、
~pointer~eventのみを~listenする
◎
if Pointer Events are supported, only listen to pointer events
</span> */
    %target.addEventListener("pointerdown", function(%event) {
        /* <span class="comment">
必要yなら、［
~touch／~pen／~mouse
］に対する異なる挙動~用に，
%event`.pointerType^c
に基づいて，別々な~logicを適用する
◎
if necessary, apply separate logic based on e.pointerType for different touch/pen/mouse behavior
</span> */
        ...
    });
    ...
} else {
    /* <span class="comment">
伝統的な ~touch／~mouse ~event~handler
◎
traditional touch/mouse event handlers
</span> */
    %target.addEventListener('touchstart', function(%event【！e】) {
        /* <span class="comment">
互換性~mouse~eventと~clickを防止する
◎
prevent compatibility mouse events and click
</span> */
        %event.preventDefault();
        ...
    });
    ...
    %target.addEventListener('mousedown', ...);
    ...
}

/* <span class="comment">
~keyboardを取扱うための，追加的な~event~listener
◎
additional event listeners for keyboard handling
</span> */
...
</pre>
</div>

<div class="example" id="_detecting-input-type">
<p>
利用者による入力を検出する例：
◎
Example 2: Detecting the type of input from a user
</p>

<pre class="lang-js">
window.addEventListener("pointerdown", %detectInputType);

function detectInputType(%event) {
    switch(%event.pointerType) {
        case "mouse":
            /* <span class="comment">
~mouse入力が検出された
◎
mouse input detected
</span> */
            break;
        case "pen":
            /* <span class="comment">
~penや~stylusからの入力が検出された
◎
pen/stylus input detected
</span> */
            break;
        case "touch":
            /* <span class="comment">
~touch入力が検出された
◎
touch input detected
</span> */
            break;
        case "":
            /* <span class="comment">
空~文字列は、
~UAが検出できない装置を意味する
◎
↓</span> */
            break;
        default:
            /* <span class="comment">
~UAに特有な~custom型
◎
pointerType is empty (could not be detected) or UA-specific custom type
</span> */
    }
}
</pre>
</div>

<div class="example">
<p>
要素~sizeを`接触~幾何$に合わせる例：
◎
Example 3: Resizing an element to match the contact geometry
</p>

<pre class="lang-html">
&lt;div style=
    "position:absolute;
    top:0px; left:0px;
    width:100px; height:100px;"
&gt;&lt;/div&gt;
&lt;script&gt;
window.addEventListener("pointerdown", checkPointerSize);

function checkPointerSize(%event) {
    %event.target.style.width = %event.width + "px";
    %event.target.style.height = %event.height + "px";
}
&lt;/script&gt;
</pre>
</div>

<div class="example" id="_untrusted-pointer-events">
<p>
~scriptから`~trusted$でない~pointer~eventを発火する例：
◎
Example 4: Firing untrusted pointer events from script
</p>

<pre class="lang-js">
const %event1 = new PointerEvent("pointerover", {
    bubbles: true,
    cancelable: true,
    composed: true,
    pointerId: 42,
    pointerType: "pen",
    clientX: 300,
    clientY: 500
});
%eventTarget.dispatchEvent(%event1);

let %pointerEventInitDict = {
  bubbles: true,
  cancelable: true,
  composed: true,
  pointerId: 42,
  pointerType: "pen",
  clientX: 300,
  clientY: 500,
};
const %p1 = new PointerEvent("pointermove", %pointerEventInitDict);
%pointerEventInitDict.clientX += 10;
const %p2 = new PointerEvent("pointermove", %pointerEventInitDict);
%pointerEventInitDict.coalescedEvents = [%p1, %p2];
const %event2 = new PointerEvent("pointermove", %pointerEventInitDict);
%eventTarget.dispatchEvent(%event2);
</pre>
</div>

<div class="example">
<p>
`pointerdown^et に対し，~penの色をアテガう例
◎
Example 5: Assigning a pen color on PointerDown
</p>

<pre class="lang-html">
&lt;div style="position:absolute; top:0px; left:0px; width:100px;height:100px;"&gt;&lt;/div&gt;
</pre>

<pre class="lang-js">
window.addEventListener("pointerdown", assignPenColor);
window.addEventListener("pointermove", assignPenColor);
const %colorMap = new Map();

function assignPenColor(%event) {
    const %uniqueId = %event.persistentDeviceId;
    /* <span class="comment">
一意な~IDが存在するか否か検査する
◎
Check if a unique Id exists.
</span> */
    if (%uniqueId == 0) {
        return;
    }
    /* <span class="comment">
当の装置には色はアテガわれたか否か検査する
◎
Check if a color has been assigned to the device.
</span> */
    if (%colorMap【！map】.has(%uniqueId)) {
        return;
    }
    /* <span class="comment">
当の装置に色をアテガう
◎
Assign a color to the device.
</span> */
    let %newColor = getNewColor();
    %colorMap【！map】.set(%uniqueId, %newColor);
    return %newColor;
}

function getNewColor() {
    /* <span class="comment">
何らかの色~値を返す
◎
return some color value
</span> */
}
</pre>
</div>

	</section>
	<section id="mouse-events">
<h2 title="Mouse Events">4. ~mouse~event</h2>

<p>
~mouse~event~moduleは、
`HTML401$r の［
`onclick^c,
`ondblclick^c,
`onmousedown^c,
`onmouseup^c,
`onmouseover^c,
`onmousemove^c,
`onmouseout^c
］属性に由来する。
この~event~moduleは、
特定的には，~pointing入力~装置
（~mouseや~trackballなど）
で利用するために設計されている。
◎
The mouse event module originates from the [HTML401] onclick, ondblclick, onmousedown, onmouseup, onmouseover, onmousemove, and onmouseout attributes. This event module is specifically designed for use with pointing input devices, such as a mouse or a trackball.
</p>

		<section id="interface-mouseevent">
<h3 title="Interface MouseEvent">4.1. `MouseEvent^I ~interface</h3>

<p class="intro-dom">
`DOM Level 2^cite にて導入され，この仕様において改変された。
◎
Introduced in DOM Level 2, modified in this specification.
</p>

<p>
`MouseEvent$I ~interfaceは、
`~mouse~event$に特有な文脈l情報を供する。
◎
The MouseEvent interface provides specific contextual information associated with Mouse events.
</p>

<p>
入子な要素に対しては、
~mouse~eventは，常に【通例的には】最も深く入子にされた要素を~targetにすることになる。
◎
In the case of nested elements, mouse events are always targeted at the most deeply nested element.
</p>

<p class="note">注記：
~targetにされた要素の先祖は、
~event浮上を利用して，子孫~要素の中で生じた~mouse~eventの通知を得せる。
◎
Note

Ancestors of the targeted element can use event bubbling to obtain notifications of mouse events which occur within their descendent elements.
</p>

<p>
`MouseEvent$I ~interfaceの~instanceを作成するためには、
その構築子に `MouseEventInit$I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the MouseEvent interface, use the MouseEvent constructor, passing an optional MouseEventInit dictionary.
</p>

<p class="note">注記：
実装は、
~client座標
— `clientX$m, `clientY$m —
を利用して，［
`initMouseEvent()$m 【 ／ `MouseEventInit$I 】を利用して `MouseEvent$I ~objを初期化する際
］の他の座標
（ “DOM Level 0” 実装や他の~proprietaryな属性
— 例： `pageX^c —
により公開される~targetの座標）
を計算できる。
◎
Note

When initializing MouseEvent objects using initMouseEvent, implementations can use the client coordinates clientX and clientY for calculation of other coordinates (such as target coordinates exposed by DOM Level 0 implementations or other proprietary attributes, e.g., pageX).
</p>

			<section id="mouseevent">
<h4 title="MouseEvent">4.1.1. `MouseEvent^I</h4>

<pre class="idl">
[`Exposed$=Window]
interface `MouseEvent@I : `UIEvent$I {
    `constructor$(`DOMString$ %type, optional `MouseEventInit$I %eventInitDict = {});

    readonly attribute `long$ `screenX$m;
    readonly attribute `long$ `screenY$m;
    readonly attribute `long$ `clientX$m;
    readonly attribute `long$ `clientY$m;
    readonly attribute `long$ `layerX$m;
    readonly attribute `long$ `layerY$m;

    readonly attribute `boolean$ `ctrlKey$m;
    readonly attribute `boolean$ `shiftKey$m;
    readonly attribute `boolean$ `altKey$m;
    readonly attribute `boolean$ `metaKey$m;

    readonly attribute `short$ `button$m;
    readonly attribute `unsigned short$ `buttons$m;

    readonly attribute `EventTarget$I? `relatedTarget$m;

    `boolean$ `getModifierState$m(`DOMString$ %keyArg);
};
</pre>

<dl class="idl-def">
	<dt>`screenX@m</dt>
	<dd>
~screen座標系の原点に相対的な，当の~eventが生じた~~地点の横方向~座標。
◎
The horizontal coordinate at which the event occurred relative to the origin of the screen coordinate system.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`screenY@m</dt>
	<dd>
横方向を縦方向に読み替える下で，
`screenX$m と同じ。
◎
The vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`clientX@m</dt>
	<dd>
当の~eventに結付けられた表示域に相対的な，当の~eventが生じた~~地点の横方向~座標。
◎
The horizontal coordinate at which the event occurred relative to the viewport associated with the event.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`clientY@m</dt>
	<dd>
横方向を縦方向に読み替える下で，
`clientX$m と同じ。
◎
The vertical coordinate at which the event occurred relative to the viewport associated with the event.
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`layerX@m</dt>
	<dd>
<p>
~AND↓ を満たす要素のうち【`~target$】に最も近いもの【が生成する~boxの左上隅】からの【当の~eventが生じた~~地点の】横方向~offset：
</p>
		<ul>
			<li>
【`~box~tree$において，`~target$の】`先祖$である
</li>
			<li>
`積層~文脈$を生成している【！is a】
</li>
			<li>
`有位置$である
</li>
			<li>
`積層~文脈を塗る$ときにおける有位置 `phase^en【？】 にて塗られる
</li>
		</ul>

<p class="trans-note">【
該当する要素が無い場合について言及されていない
（ ［
`clientX$m ／ `clientY$m
］と同じになる？）。
】</p>
◎
The horizontal offset from the nearest ancestor element which is a stacking context, is positioned, or paints in the positioned phase when painting a stacking context.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`layerY@m</dt>
	<dd>
横方向を縦方向に読み替える下で，
`layerX$m と同じ。
◎
The vertical offset from the nearest ancestor element which is a stacking context, is positioned, or paints in the positioned phase when painting a stacking context.
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`ctrlKey@m</dt>
	<dt>`shiftKey@m</dt>
	<dt>`altKey@m</dt>
	<dt>`metaKey@m</dt>
	<dd>
これらについては、
`KeyboardEvent$I の同じ名前の属性を見よ。
◎
ctrlKey
• Refer to the KeyboardEvent's ctrlKey attribute.
• The un-initialized value of this attribute MUST be false.
◎
shiftKey
• Refer to the KeyboardEvent's shiftKey attribute.
• The un-initialized value of this attribute MUST be false.
◎
altKey
• Refer to the KeyboardEvent's altKey attribute.
• The un-initialized value of this attribute MUST be false.
◎
metaKey
• Refer to the KeyboardEvent's metaKey attribute.
• The un-initialized value of this attribute MUST be false.
</dd>
	<dd>
`未初期化~値$： ~F
◎
↑</dd>

	<dt>`button@m</dt>
	<dd>
~mouse~buttonの状態~変化による~mouse~eventに対しては、
この属性を利用して，その状態を変化させた~pointing装置の~buttonを指示するモノトスル。
◎
During mouse events caused by the depression or release of a mouse button, button MUST be used to indicate which pointer device button changed state.
</dd>
	<dd>
<p>
この属性に対する整数~値 ~IN { 0 〜 4 } は、
次を指示するモノトスル：
◎
The value of the button attribute MUST be as follows:
</p>
		<ul>
			<li>
0 は、
装置の首~button
（一般に、
~UI~controlや選択~textを作動化するために利用される，
左~button, または 単-~buttonな装置の唯一の~button）,
または`未初期化~値$。
◎
0 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text) or the un-initialized value.
</li>
			<li>
1 は、
予備~button
（一般に，中央~button — ~mouse~wheelと組合されることが多い）。
◎
1 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).
</li>
			<li>
2 は、
副~button
（一般に，右~button — 文脈~menuを表示するために利用されることが多い）。
◎
2 MUST indicate the secondary button (in general, the right button, often used to display a context menu).
</li>
			<li>
3 は、
~X1（ `back^en ）~button。
◎
3 MUST indicate the X1 (back) button.
</li>
			<li>
4 は、
~X2（ `forward^en ） ~button。
◎
4 MUST indicate the X2 (forward) button.
</li>
		</ul>
	</dd>
	<dd>
~pointing装置には，もっと他の~button状態を［
供する／模倣sする
］ものもあり、
そのような~buttonを表現するために，上に挙げたもの以外の整数が利用されることもある。
◎
Some pointing devices provide or simulate more button states, and values higher than 2 or lower than 0 MAY be used to represent such buttons.
</dd>
	<dd class="note">注記：
`button$m の値は、
~mouse~buttonの状態~変化によるものでない~eventに対しては，更新されない。
そのような局面における値 0 は、
左~buttonではなく，既定の値として解釈すること。
◎
Note

The value of button is not updated for events not caused by the depression/release of a mouse button. In these scenarios, take care not to interpret the value 0 as the left button, but rather as the default value.
</dd>
	<dd class="note">注記：
`mousedown$et や `mouseup$et などの~eventに関係する`既定~動作$には、
利用-中にある特定の~mouse~buttonに依存するものもある。
◎
Note

Some default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`buttons@m</dt>
	<dd>
~mouse~buttonが現在どの組合nで押されているかを表出する~bitmask。
どの~mouse~eventにおいても、
それを指示するときには，この属性を利用するモノトスル。
◎
During any mouse events, buttons MUST be used to indicate which combination of mouse buttons are currently being pressed, expressed as a bitmask.
</dd>
	<dd class="note">注記：
似た名前の `button$m 属性がとる値とは，まったく異なる。
`button^m の値を妥当と見做せるのは，［
`mousedown$et ／ `mouseup$et
］用の`~event~handler$の中に限られる一方、
`buttons^m 属性は，`~trusted$な どの `MouseEvent$I ~objに対しても（それが配送される間）~mouseの各~buttonの状態を反映する
— それは、
“現在どの~buttonも作動中でない” 状態（ 0 ）も表現できるので。
◎
Note

Though similarly named, the values for the buttons attribute and the button attribute are very different. The value of button is assumed to be valid during mousedown / mouseup event handlers, whereas the buttons attribute reflects the state of the mouse's buttons for any trusted MouseEvent object (while it is being dispatched), because it can represent the "no button currently active" state (0).
</dd>
	<dd>
<p>
`buttons$m 属性の~bitmask値［
0 ／ 1 ／ 2  ／ 4 
］は、
次を指示するモノトスル：
◎
The value of the buttons attribute MUST be as follows:
</p>
		<ul>
			<li>
0 は、
どの~buttonも現在~作動中でないこと。
◎
0 MUST indicate no button is currently active.
</li>
			<li>
1 は、
装置の首~button
（一般に、［
~UI~controlや選択~textを作動化するために利用される左~button
］または［
単-~buttonな装置を成す唯一の~button
］）。
◎
1 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text).
</li>
			<li>
2 は、
副~button
（一般に，右~button
— 文脈~menuを表示するために利用されることが多い）。
◎
2 MUST indicate the secondary button (in general, the right button, often used to display a context menu), if present.
</li>
			<li>
4 は、
予備~button
（一般に，中央~button
— ~mouse~wheelと組合されることが多い）。
◎
4 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).
</li>
		</ul>

	</dd>
	<dd>
~pointing装置には、
上述以外の~buttonを［
供する／模倣sする
］ものもある
— そのような~buttonを表現する値は、
各~buttonごとに倍々にするモノトスル
（ 8, 16, 32, ... ）。
◎
Some pointing devices provide or simulate more buttons. To represent such buttons, the value MUST be doubled for each successive button (in the binary series 8, 16, 32, ... ).
</dd>
	<dd class="note" id="buttons-mask">注記：
~buttonたち全体が成すどの状態も，各~button値の総和で一意に表現されるので、
内容~作者は，装置~上の~mouse~buttonがいくつあっても，~bitごとの演算を利用して，現在どの~buttonが押されているかを決定できる。
例えば、
値 3 は，左＆右~buttonが押された（押されている）ことを指示し、
値 5 は，左＆中央~buttonが押されたことを指示する。
◎
Note

Because the sum of any set of button values is a unique number, a content author can use a bitwise operation to determine how many buttons are currently being pressed and which buttons they are, for an arbitrary number of mouse buttons on a device. For example, the value 3 indicates that the left and right button are currently both pressed, while the value 5 indicates that the left and middle button are currently both pressed.
</dd>
	<dd class="note">注記：
【！複製】
一部の~event
— `mousedown$et や `mouseup$et など —
に関係する`既定~動作$には、
どの~mouse~buttonが利用-中にあるかに依存するものもある。
◎
Note

Some default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>

	<dt>`relatedTarget@m</dt>
	<dd>
~eventの型に依存して、
~UI~eventに関係する副 `EventTarget$I を識別するために利用される。
◎
Used to identify a secondary EventTarget related to a UI event, depending on the type of event.
</dd>
	<dd>
`未初期化~値$： ~NULL
◎
The un-initialized value of this attribute MUST be null.
</dd>

	<dt>`getModifierState(keyArg)@m</dt>
	<dd>
%keyArg に渡された ある`修飾~UIkey$用の`~UIkey値$を利用して，ある修飾の状態を~queryする。
◎
Queries the state of a modifier using a key value.
</dd>
	<dd>
当の~UIkeyは作動化されて［
いるならば ~T ／
いないならば ~F
］を返す。
◎
Returns true if it is a modifier key and the modifier is activated, false otherwise.
</dd>
	<dd>
妥当な`修飾~UIkey$は、
`UIEvents-Key$r の`修飾~UIkeyの表t$にて定義される。
◎
DOMString keyArg 
• Refer to the KeyboardEvent's getModifierState() method for a description of this parameter.
</dd>
	<dd class="trans-note">【
`KeyboardEvent$I の `getModifierState()＠~UIEVENTS#dom-keyboardevent-getmodifierstate$m ~methodと同様にふるまう。
】</dd>
</dl>

			</section>
			<section id="idl-mouseeventinit">
<h4 title="MouseEventInit">4.1.2. `MouseEventInit^I</h4>

<pre class="idl">
dictionary `MouseEventInit@I : `EventModifierInit$I {
    `long$ `screenX@mb = 0;
    `long$ `screenY@mb = 0;
    `long$ `clientX@mb = 0;
    `long$ `clientY@mb = 0;

    `short$ `button@mb = 0;
    `unsigned short$ `buttons@mb = 0;
    `EventTarget$I? `relatedTarget@mb = null;
};
</pre>

<p>
この辞書の各~memberは、
`MouseEvent$I ~obj上の同じ名前の属性を初期化する。
それぞれがとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
screenX
• Initializes the screenX attribute of the MouseEvent object to the desired horizontal relative position of the mouse pointer on the user's screen.
• Initializing the event object to the given mouse position must not move the user's mouse pointer to the initialized position.
◎
screenY
• Initializes the screenY attribute of the MouseEvent object to the desired vertical relative position of the mouse pointer on the user's screen.
• Initializing the event object to the given mouse position must not move the user's mouse pointer to the initialized position.
◎
clientX
• Initializes the clientX attribute of the MouseEvent object to the desired horizontal position of the mouse pointer relative to the client window of the user's browser.
• Initializing the event object to the given mouse position must not move the user's mouse pointer to the initialized position.
◎
clientY
• Initializes the clientY attribute of the MouseEvent object to the desired vertical position of the mouse pointer relative to the client window of the user's browser.
• Initializing the event object to the given mouse position must not move the user's mouse pointer to the initialized position.
◎
button
• Initializes the button attribute of the MouseEvent object to a number representing the desired state of the button(s) of the mouse.
• The value 0 is used to represent the primary mouse button, 1 is used to represent the auxiliary/middle mouse button, and 2 to represent the right mouse button. Numbers greater than 2 are also possible, but are not specified in this document.
◎
buttons
• Initializes the buttons attribute of the MouseEvent object to a number representing one or more of the button(s) of the mouse that are to be considered active.
• The buttons attribute is a bit-field. If a mask value of 1 is true when applied to the value of the bit field, then the primary mouse button is down. If a mask value of 2 is true when applied to the value of the bit field, then the right mouse button is down. If a mask value of 4 is true when applied to the value of the bit field, then the auxiliary/middle button is down.
• In JavaScript, to initialize the buttons attribute as if the right (2) and middle button (4) were being pressed simultaneously, the buttons value can be assigned as either:
    { buttons: 2 | 4 }
    or:
    { buttons: 6 }
◎
relatedTarget
• The relatedTarget should be initialized to the element whose bounds the mouse pointer just left (in the case of a mouseover or mouseenter event) or the element whose bounds the mouse pointer is entering (in the case of a mouseout or mouseleave or focusout event). For other events, this value need not be assigned (and will default to null).
</p>

<p>
`MouseEvent$I ~objが指示する~mouse位置がどう初期化されようが，利用者の~mouse~pointerはその位置に動かされないモノトスル。
◎
↑</p>

<p id="current-click-count">
実装は、
~mouse~eventを生成するときには，
`現在の~click回数@
を保守するモノトスル。
これは、
【同じ】~pointing装置の~buttonが，特定の時間~内に連続して~clickされた数を指示する負でない整数になるモノトスル。
どの程度の遅延で回数が 1 に設定し直されるかは、
環境設定に特有になる。
◎
Implementations MUST maintain the current click count when generating mouse events. This MUST be a non-negative integer indicating the number of consecutive clicks of a pointing device button within a specific time. The delay after which the count resets is specific to the environment configuration.
</p>

<p class="trans-note">【
回数が増加される~~正確な時機がいつなのか記されていないが、
`click$et ~eventが配送される直前と思われる。
】【
複数の~pointing装置があるときは、
装置ごとに~click回数を保守する？
それとも，~clickした装置が切り替わったら，~click回数は設定し直される？
】</p>

			</section>
		</section>
		<section id="mouseevent-algorithms">
<h3 title="MouseEvent Algorithms">4.2. `MouseEvent$I 用の各種~algo</h3>

			<section id="native-os-requirements">
<h4 title="Native OS Requirements">4.2.1. ~native~OS要件</h4>

<p>
この節に与える~algoは、
~native~platform~OSが次を供することになるものと見做す：
◎
The algorithms in this section assume that the native platform OS will provide the following:
</p>

<ul>
	<li>
~nativeな~mousemove
⇒
~mouseが動かされたときの~event
（`~nativeな~mousemoveを取扱う$ことにより取扱われる）
◎
An event when the mouse is moved (handled by handle native mouse move)
</li>
	<li>
~nativeな~mousedown
⇒
~mouse~buttonが押されたときの~event
（`~nativeな~mousedownを取扱う$ことにより取扱われる）
◎
An event when a mouse button is pressed (handled by handle native mouse down)
</li>
	<li>
~nativeな~mouseup
⇒
~mouse~buttonが離されたときの~event
（`~nativeな~mouseupを取扱う$ことにより取扱われる）
◎
An event when a mouse button is released (handled by handle native mouse up)
</li>
	<li>
<p>
~mouse~buttonが押されたとき，それを “~click” として解釈するべきか否かを識別する仕方
（`~nativeな~clickを取扱う$ことにより取扱われる）：
◎
A way to identify when a mouse button press should be interpreted as a "click" (handled by handle native mouse click)
</p>
		<ul>
			<li>
例えば、
ある~flagとして，あるいは別々な~eventとして
◎
For example, as a flag or as a separate event
</li>
			<li>
別々な “~click” ~eventとして発火する場合には、
~native~OSは，それを対応する［
~mouse~buttonが離されたときの~event【！"mouseup" event】
］の直後に
— その間に，~mouseに関係する他の~eventは介在することなく —
発火することになる。
◎
If a separate "click" event is fired, then the native OS will fire it immediately after the corresponding "mouse up" event, with no intervening mouse-related events
</li>
		</ul>
	</li>
	<li>
所与の~clickを “~double-click” として解釈するべきか否かを識別する仕方
（`~nativeな~double-clickを取扱う$ことにより取扱われる）
◎
A way to identify when a mouse click is a "double click" (handled by handle native mouse double click)
</li>
</ul>

<p class="trans-note">【
原文には触れられていないが、
これは，実質的には、
~UAが［
所与の~nativeな~eventが どの`文書$上で生じたか
］を決定する処理nも含意する。
以下に定義される各~algoは、
暗黙的に，当の~eventが生じた文書の文脈で遂行されるものと見做される。
】</p>

<p>
加えて、
これらの~event用には，次に挙げる報を供することも可能であるものと見做す：
◎
For these events, the OS will be able to provide the following info:
</p>
<ul>
	<li>
<p>
`~desktop座標@
⇒
~native~OSの~desktop【の原点】に相対的な ( ~x, ~y ) ~mouse座標
</p>

<p class="trans-note">【
何が~desktopが占める区画になるかは定義されていない。
】</p>
◎
The x,y mouse coordinates relative to the native OS desktop
</li>
	<li>
`表示域~座標@
⇒
~UAの~UIwindowの表示域【実際には，当の`文書$の`表示域$】【の原点】に相対的な ( ~x, ~y ) ~mouse座標
◎
The x,y mouse coordinates relative to the UA's window viewport
</li>
	<li>
~keyboardにて現在~~押されている修飾~UIkeyたち
【`修飾~UIkey状態~map$に挙げる文字列で識別される。】
◎
Which keyboard modifiers are currently being held
</li>
	<li>
`~mouse~button名@
【この項は、この訳による補完】
⇒
~mouse~buttonが［
押された／離された
］ときの~event用に，どの~buttonが［
押された／離された
］かを識別する値として，次に挙げるいずれかが供される
（それらの意味は `button$m を見よ）
⇒＃
`首~button^i,
`予備~button^i,
`副~button^i,
`~X1~button^i,
`~X2~button^i
</li>
</ul>

			</section>
			<section id="constructing-mouse-events">
<h4 title="Constructing Mouse Events">4.2.2. ~mouse~eventの構築-法</h4>

<p class="warning">
この節は改訂される必要がある。
◎
Warning

This section needs to be revised.
</p>

<p>
一般に、
`Event$I ~interface またはそれを継承する~interfaceの構築子が呼出されたときは，
`DOM$r に述べられる手続きに従うべきである。
しかしながら、
`MouseEvent$I ~interfaceは，［
`Event$I ~objにおける`~UIkey修飾＠#keys-modifiers$の内部~状態を初期化する
］ための追加的な辞書~memberも供する。
この内部~状態は、
特定的には `getModifierState()$m ~methodを利用して~queryできる。
この節では、
`DOM$r による新たな `MouseEvent$I ~objを初期化する手続きに，
この修飾~状態の初期化も補足する。
◎
Generally, when a constructor of an Event interface, or of an interface inherited from the Event interface, is invoked, the steps described in [DOM] should be followed. However the MouseEvent interfaces provide additional dictionary members for initializing the internal state of the Event object's key modifiers: specifically, the internal state queried for using the getModifierState() methods. This section supplements the [DOM] steps for intializing a new MouseEvent object with these optional modifier states.
</p>

<div class="p">
<p>
`MouseEvent$I ~interface（それを継承するものも含む）を実装する各~objは、
各`~UIkey修飾~名$ごとに対応する
`内部~UIkey修飾~状態@
を有する。
それは：
</p>
<ul>
	<li>
`UIEvents-Key$r の`修飾~UIkeyの表t$内に述べられる
`~UIkey修飾~名@
を利用して検索取得できる。
</li>
	<li>
<p>
次に与える~algoを利用して，~objを構築する際に設定できる
— `DOM$r【！DOM4】 による~eventの構築-法に定義される~algoには、
次の手続きが補足される：
</p>

<div class="algo">
<p>
~event~obj %~event を構築するとき，構築子に
( `EventModifierInit$I 引数 %eventInitDict )
が供された場合は、
次を走らす：
</p>
		<ol>
			<li>
<p>
~EACH( `~UIkey修飾~名$ %名前 )
に対し：
</p>
				<ol>
					<li>
%~member名 ~LET 次を順に`連結する$
⇒＃
`modifier^l,
%名前
</li>
					<li>
~IF［
%eventInitDict[ %~member名 ] ~NEQ ε
］
⇒
%名前 に対応する %~event の`内部~UIkey修飾~状態$ ~SET %eventInitDict[ %~member名 ]
</li>
				</ol>
			</li>
		</ol>
</div>
◎
For the purposes of constructing a MouseEvent, or object derived from these objects using the algorithm below, all MouseEvent, and derived objects have internal key modifier state which can be set and retrieved using the key modifier names described in the Modifier Keys table in [UIEvents-Key].
◎
The following steps supplement the algorithm defined for constructing events in [DOM]:
• If the Event being constructed is a MouseEvent object or an object that derives from it, and a EventModifierInit argument was provided to the constructor, then run the following sub-steps:
•• For each EventModifierInit argument, if the dictionary member begins with the string "modifier", then let the key modifier name be the dictionary member's name excluding the prefix "modifier", and set the Event object's internal key modifier state that matches the key modifier name to the corresponding value.
</li>
</ul>
</div>

<p class="trans-note">【
`内部~UIkey修飾~状態$は，
`MouseEvent$I 用に導入された`修飾~UIkey状態~map$と~~重複するが、
後者が受持つ`~UIkey修飾~名$は，一部に限られる。
】</p>

			</section>
			<section id="global-state-for-mouseevent">
<h4 title="Global State for MouseEvent">4.2.3. `MouseEvent^I 用の大域的な状態</h4>

<p class="warning">
この節は改訂される必要がある。
◎
Warning

This section needs to be revised.
</p>

<p id="user-agent-level-state">
~UAは、
~UA全体~用に共有される値をとして，次を保守するモノトスル
⇒
`~mouse~button~bitmask@
⇒
各~mouse~buttonの現在の状態を追跡する。
◎
4.2.3.1. User Agent-Level State
◎
The UA must maintain the following values that are shared for the entire User Agent.
◎
A mouse button bitmask that tracks the current state of the mouse buttons.
</p>

<p id="window-level-state">
~UAは、
各`~window$用に共有される値をとして，次を保守するモノトスル：
◎
4.2.3.2. Window-Level State
◎
The UA must maintain the following values that are shared for the Window.
</p>
<ul>
	<li>
`最後の~mouse要素@
⇒
`MouseEvent$I が最後に送信された要素【！`Element$I】を追跡し続ける
— 初期~時は ~NULL【！undefined】 とする。
◎
A last mouse element value (initially undefined) that keeps track of the last Element that we sent a MouseEvent to.
</li>
	<li>
<p>
`最後の~mouse~DOM経路@
⇒
最も近過去に~mouse~eventを送信した時点における`最後の~mouse要素$の先祖~要素【！`Element$I】たちが成す~list（~snapshot）
— 初期~時は空とする。
</p>

<p class="trans-note">【
順序が指定されていないため、
この用語を利用している~algoにおいて~eventたちを発火する順序が不明瞭になっている。
】</p>
◎
A last mouse DOM path value (initially empty) that contains a snapshot of the ancestors Elements of the last mouse element when the most recent mouse event was sent.
</li>
</ul>

			</section>
			<section id="internal-state-for-mouseevent">
<h4 title="Internal State for MouseEvent">4.2.4. `MouseEvent^I 用の内部~状態</h4>

<p class="warning">
この節は改訂される必要がある。
◎
Warning

This section needs to be revised.
</p>

<div>
<p>
各 `MouseEvent$I は、
`修飾~UIkey状態~map@
を有する
— それは、
~mouse~eventに関連な修飾~UIkeyたちの状態を追跡するために利用される`~map$であり，
初期~時は空とする
（~eventの作成-時に拡充される）：
</p>
<ul>
	<li>
この~mapを成す各~keyは、
文字列であり，次に挙げる`~UIkey修飾~名$として与えられる
⇒＃
`Shift^l,
`Control^l,
`Alt^l,
`AltGraph^l,
`Meta^l
</li>
	<li>
対応する各~値は、
真偽値をとる
— 当の~keyが指示する修飾~UIkeyが当の~mouse~eventが生じた時点に押されて［
いたならば ~T ／
いなかったならば ~F
］に設定される。
</li>
</ul>

◎
A MouseEvent has the following internal flags that are used to track the state of various modifier keys: shift flag, control flag, alt flag, altgraph flag, and meta flag. These flags are set if the corresponding modifier key was pressed at the time of the mouse event.
</div>

<p class="trans-note">【
これは、
原文では，挙げられた各~UIkey名ごとに 同じ名前を伴う~flagとして定義されているが、
この訳では，一つの~mapに集約することにする。
】</p>

			</section>
			<section id="_algorithms-for-mouseevent">
<h3>4.2.X. 各種~algo</h3>

<p class="warning">
この節を成す ほとんどの~algoは、
改訂される必要がある。
</p>

<div class="algo">
<p id="hit-test">
`接触判定する@
~algoは、
所与の
( 表示域に相対的な座標 %位置 )
に対し：
◎
4.2.5 hit test
◎
Warning

This section needs to be revised.
◎
• Let pos be the x,y coordinates relative to the viewport
</p>
<ol>
	<li>
<p>
~RET 当の文書~上の `elementFromPoint＠~CSSOMVIEW#dom-document-elementfrompoint$m ~method手続き( %位置 の~x座標, %位置 の~y座標 )
`CSSOM-View$r
（すなわち， %位置 に重なる~DOM要素のうち最も手前にあるもの）
◎
Return [CSSOM-View]'s elementFromPoint() with pos (the frontmost DOM element at pos)
</p>

<p class="note">注記：
［
`不活$な要素／
`不能化されて$feいる要素
］を織り込む必要がある。
この段は、
`elementsFromPoint()＠~CSSOMVIEW#dom-document-elementsfrompoint$m を~callして，
妥当でない要素を却下するべきである。
◎
Note

To account for inert or disabled elements. this should call elementsFromPoint() and reject invalid elements.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p id="initialize-a-mouseevent">
`~MouseEventを初期化する@
~algoは、
所与の
⇒＃
`MouseEvent$I %~event,
文字列 %~event型,
`EventTarget$I %~event~target,
真偽値 %浮上するか,
真偽値 %取消~可能か
◎終
に対し：
◎
4.2.6 initialize a MouseEvent
◎
Warning

This section needs to be revised.
◎
To initialize a MouseEvent with event, eventType and eventTarget, bubbles, and cancelable, run the following steps:
</p>
<ol>
	<li>
`~UIEventを初期化する$( %~event, %~event型, %~event~target, %浮上するか, %取消~可能か )
◎
Initialize a UIEvent with event, eventType, eventTarget, bubbles and cancelable.
</li>
	<li>
%位置 ~LET 当の~eventが生じた位置
【この情報は、本当は引数として渡される必要があろう。】
◎
↓</li>
	<li>
%~event の
⇒＃
`screenX$m ~SET `~desktop座標$による %位置 の~x座標,
`screenY$m ~SET `~desktop座標$による %位置 の~y座標,
`clientX$m ~SET `表示域~座標$による %位置 の~x座標,
`clientY$m ~SET `表示域~座標$による %位置 の~y座標,
◎
Set event.screenX to the x-coordinate of the position where the event occurred relative to the origin of the desktop
◎
Set event.screenY to the y-coordinate of the position where the event occurred relative to the origin of the desktop
◎
Set event.clientX to the x-coordinate of the position where the event occurred relative to the origin of the viewport
◎
Set event.clientY to the y-coordinate of the position where the event occurred relative to the origin of the viewport
</li>
	<li>
`~mouse~eventの修飾~UIkey状態を設定する$( %~event )
◎
Set mouse event modifiers with event
</li>
	<li>
%~event の
⇒＃
`button$m ~SET 0,
`buttons$m ~SET `~mouse~button~bitmask$
◎
Set event.button to 0
◎
Set event.buttons to mouse button bitmask
</li>
	<li>
<p>
`~MouseEvent用に各~pointer~lock属性を初期化する$( %~event )
◎
Initialize PointerLock attributes for MouseEvent with event
</p>

<p class="issue">
~PointerLock用の~hookを供するべきである
— それをここに直書きする代わりに。
◎
We should provide a hook for PointerLock instead of hardcoding it here.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p id="set-mouse-event-modifiers">
`~mouse~eventの修飾~UIkey状態を設定する@
~algoは、
所与の
( `MouseEvent$I %~event )
に対し：
◎
4.2.7 set mouse event modifiers
◎
Warning

This section needs to be revised. 
◎
• Let event be the MouseEvent to update
</p>
<ol>
	<li>
%修飾~状態 ~LET %~event の`修飾~UIkey状態~map$
◎
↓</li>
	<li>
« `Shift^l, `Control^l, `Alt^l, `AltGraph^l, `Meta^l »
を成す
~EACH( %~UIkey名 )
に対し
⇒
%修飾~状態[ %~UIkey名 ] ~SET `修飾~UIkey状態$( %~UIkey名 )
◎
Set event's shift flag if key modifier state includes "Shift", unset it otherwise
◎
Set event's control flag if key modifier state includes "Control", unset it otherwise
◎
Set event's alt flag if key modifier state includes "Alt", unset it otherwise
◎
Set event's altgraph flag if key modifier state includes "AltGraph", unset it otherwise
◎
Set event's meta flag if key modifier state includes "Meta", unset it otherwise
</li>
	<li>
%~event の `shiftKey$m ~SET %修飾~状態[ `Shift^l ]
◎
Set event.shiftKey to true if the event's shift flag is set, false otherwise
</li>
	<li>
%~event の `ctrlKey$m ~SET %修飾~状態[ `Control^l ]
◎
Set event.ctrlKey to true if the event's control flag is set, false otherwise
</li>
	<li>
%~event の `altKey$m ~SET ~IS［
%修飾~状態[ `Alt^l ] ~EQ ~T
］~OR［
%修飾~状態[ `AltGraph^l ] ~EQ ~T
］
◎
Set event.altKey to true if the event's alt flag or altgraph flag is set, false otherwise
</li>
	<li>
%~event の `metaKey$m ~SET %修飾~状態[ `Meta^l ]
◎
Set event.metaKey to true if the event's meta flag is set, false otherwise
</li>
</ol>
</div>

<div class="algo">
<p id="create-a-cancelable-mouseevent">
`~MouseEventを作成する@
~algoは、
所与の
( 文字列 %~event型, `EventTarget$I %~event~target, 真偽値 %取消~不能か ~DF ~F )
に対し：
◎
4.2.8 create a cancelable MouseEvent
◎
Warning

This section needs to be revised.
◎
• Let eventType be a DOMString containing a valid MouseEvent type
• Let eventTarget be the EventTarget of the event
</p>
<ol>
	<li>
%取消~可能か ~LET ~IS［
%取消~不能か ~EQ ~F
］
◎
Let bubbles be true
◎
Let cancelable be true
</li>
	<li>
%浮上するか ~LET %取消~可能か
◎
↑↓</li>
	<li>
%~event ~SET `~eventを作成する$( `MouseEvent$I )
◎
Let event be the result of creating an event using MouseEvent
</li>
	<li>
`~MouseEventを初期化する$( ↓ )
⇒＃
%~event,
%~event型,
%~event~target,
%浮上するか,
%取消~可能か
◎
Initialize a MouseEvent with event, eventType, eventTarget, bubbles and cancelable.
</li>
	<li>
~RET %~event
◎
Return event
</li>
</ol>

<div>
<p class="trans-note">【
%~event~target には ~NULL も渡され得るが、
その場合にどうなるのか，はっきりしない。
】【
この~algoは，原文においては 2 つの~algo
—
`取消~可能な~MouseEventを作成する＠#dfn-creating-a-cancelable-mouseevent@
,
`取消~不能な~MouseEventを作成する＠#dfn-creating-a-non-cancelable-mouseevent@
—
に分けて定義されているが、
この訳では，追加的な引数 %取消~可能か を導入することにより一つに統合する。
】</p>
◎
4.2.9 create a non-cancelable MouseEvent
Warning
◎
This section needs to be revised.
◎
• Let eventType be a DOMString containing a valid MouseEvent type
• Let eventTarget be the EventTarget of the event
• Let bubbles be "false"
• Let cancelable be "false"
• Let event be the result of creating an event using MouseEvent
• Initialize a MouseEvent with event, eventType, eventTarget, bubbles and cancelable.
• Return event
</div>
</div>

<div class="algo">
<p id="calculate-mouseevent-button-attribute">
`~button名を整数に変換する@
~algoは、
所与の
( `~mouse~button名$ %~button~ID )
に対し，
`MouseEvent$I の `button$m 属性への格納-用に相応しい値を返す：
◎
4.2.10 calculate MouseEvent button attribute
◎
Warning

This section needs to be revised.
◎
This will return a button ID suitable for storing in the MouseEvent's button attribute.
◎
Let mbutton be an ID that identifies a mouse button
</p>
<ol>
	<li>
~RET %~button~ID に応じて
⇒＃
`首~button^i ならば 0 ／
`予備~button^i ならば 1 ／
`副~button^i ならば 2 ／
`~X1~button^i ならば 3 ／
`~X2~button^i ならば 4
◎
If mbutton is the primary mouse button, then return 0
◎
If mbutton is the auxiliary (middle) mouse button, then return 1
◎
If mbutton is the secondary mouse button, then return 2
◎
If mbutton is the X1 (back) button, then return 3
◎
If mbutton is the X2 (forward) button, then return 4
</li>
</ol>
</div>

<div class="algo">
<p id="set-mouseevent-attributes-from-native">
`~MouseEvent属性を~nativeな~eventから設定する@
~algoは、
所与の
( `MouseEvent$I %~event, ~nativeな~mouse~event %~nativeな~event )
に対し：
◎
4.2.11 set MouseEvent attributes from native
◎
Warning

This section needs to be revised.
◎
• Let event be the MouseEvent to initialize
• Let native be the native mouse event
</p>
<ol>
	<li class="issue">【！ class="note" Editor's note （以下同様）】
ここで設定すべき属性は他にもある。
◎
Editor's note

TODO.
</li>
	<li>
~IF［
%~event の `type$m ~IN { `mousedown^l, `mouseup^l }
］
⇒
%~event の `button$m ~SET `~button名を整数に変換する$( %~nativeな~event の`~mouse~button名$ )
◎
If event.type is one of [ mousedown, mouseup ], then
• Let mbutton be an ID from native that identifies which mouse button was pressed
• Set event.button to calculate MouseEvent button attribute with mbutton
</li>
</ol>
</div>

<div class="algo">
<p id="handle-native-mouse-down">
`~nativeな~mousedownを取扱う@
~algoは、
所与の
( ~nativeな~mousedown %~nativeな~event )
に対し：
◎
4.2.12 handle native mouse down
◎
Warning

This section needs to be revised.
◎
• Let native be the native mousedown
</p>
<ol>
	<li>
%~button~ID ~LET %~nativeな~event の`~mouse~button名$
◎
Let mbutton be an ID from native that identifies which mouse button was pressed
</li>
	<li>
<p>
`~mouse~button~bitmask$を更新する
— %~button~ID に応じて，次に与える~bitが 1 になるよう
⇒＃
`首~button^i ならば 0x01 ／
`副~button^i ならば 0x02 ／
`予備~button^i ならば 0x04
◎
Update the mouse button bitmask as follows:
• If mbutton is the primary mouse button, then set the 0x01 bit
• If mbutton is the secondary mouse button, then set the 0x02 bit
• If mbutton is the auxiliary (middle) mouse button, then set the 0x04 bit
</p>

<p class="note">注記：
より~~上位~bitに対応する他の~buttonも追加され得る。
◎
Note

Other buttons can be added starting with 0x08 .
</p>
	</li>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target be hit test with viewport-relative coordinates from native
</li>
	<li>
%~event ~LET `~MouseEventを作成する$( `mousedown^l, %~target )
◎
Let event be the result of creating a cancelable MouseEvent with "mousedown", target
</li>
	<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with native
</li>
	<li>
`必要なら~pointer~eventを送信する$( %~event )
◎
Maybe send pointerdown event with event
</li>
	<li>
%取消されなかったか ~LET `~eventを配送する$( %~target, %~event )
◎
Let result be dispatch event at target
</li>
	<li>
~IF［
%取消されなかったか ~EQ ~T
］~AND［
%~target は`~focus可能な区画$である
］~AND［
%~target は`~clickで~focus可能$である
］
⇒
`~objを~focusする$( %~target )
◎
If result is true and target is a focusable area that is click focusable, then
• Run the focusing steps at target
</li>
	<li>
~IF［
%~button~ID ~EQ `副~button^i
］
⇒
`必要なら文脈~menuを示す$( %~nativeな~event, %~target )
◎
if mbutton is the secondary mouse button, then
• Maybe show context menu with native, target
</li>
</ol>
</div>

<div class="algo">
<p id="handle-native-mouse-up">
`~nativeな~mouseupを取扱う@
~algoは、
所与の
( ~nativeな~mouseup %~nativeな~event )
に対し：
◎
4.2.13 handle native mouse up
◎
Warning

This section needs to be revised.
◎
• Let native be the native mouseup
</p>

<p class="note">注記：
`mousedown$et と `mouseup$et の合間には、
他の~mouse~eventも生じ得る。
◎
• Note

• Other mouse events can occur between the mousedown and mouseup.
</p>
<ol>
	<li>
%~button~ID ~LET %~nativeな~event の`~mouse~button名$
◎
Let mbutton be an ID from native that identifies which mouse button was pressed
</li>
	<li>
`~mouse~button~bitmask$を更新する
— %~button~ID に応じて，次に与える~bitが 0 になるよう
⇒＃
`首~button^i ならば 0x01 ／
`副~button^i ならば 0x02 ／
`予備~button^i ならば 0x04
◎
Update the mouse button bitmask as follows:
• If mbutton is the primary mouse button, then clear the 0x01 bit
• If mbutton is the secondary mouse button, then clear the 0x02 bit
• If mbutton is the auxiliary (middle) mouse button, then clear the 0x04 bit
</li>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target be hit test with viewport-relative coordinates from native
</li>
	<li>
%~event ~LET `~MouseEventを作成する$( `mouseup^l, %~target )
◎
Let event be the result of creating a cancelable MouseEvent with "mouseup", target
</li>
	<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with native
</li>
	<li>
`必要なら~pointer~eventを送信する$( %~event )
◎
Maybe send pointerup event with event
</li>
	<li>
`~eventを配送する$( %~target, %~event )
◎
dispatch event at target
</li>
</ol>
</div>

<div class="algo">
<p id="handle-native-mouse-click">
`~nativeな~clickを取扱う@
~algoは、
所与の
( ~nativeな~click %~nativeな~event )
に対し：
◎
4.2.14 handle native mouse click
◎
Warning

This section needs to be revised.
◎
• Let native be the native mouse click
</p>

<p class="note">注記：
~platformは、
~clickを生成する~mouseup用には，
`~nativeな~mouseupを取扱う$の直後にこれを~callするべきである。
◎
• Note

• The platform should call this immediately after handle native mouse up for mouseups that generate clicks.
</p>
<ol>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target be hit test with viewport-relative coordinates from native
</li>
	<li>
`~click~eventを送信する$( %~nativeな~event, %~target )
◎
Send click event with native and target.
</li>
</ol>
</div>

<div class="algo">
<p id="send-click-event">
`~click~eventを送信する@
~algoは、
所与の
( ~nativeな~mousedown %~nativeな~event, `EventTarget$I %~target )
に対し：
◎
4.2.15 send click event
◎
Warning

This section needs to be revised.
◎
• Let native be the native mousedown
• Let target be the EventTarget of the event
</p>
<ol>
	<li>
%~event型 ~SET ［
次が満たされるならば `click^l ／
~ELSE_ `auxclick^l
］
⇒
［
%~nativeな~event は妥当でない
【何をもって “妥当” とされる？】
］~OR［
%~nativeな~event の`~mouse~button名$ ~EQ `首~button^i
］
◎
Let mbutton be 1 (primary mouse button by default)
◎
If native is valid, then
• Let mbutton be an ID from native that identifies which mouse button was pressed
◎
Set eventType to "click" if mbutton is the primary mouse button, otherwise "auxclick"
</li>
	<li>
%~event ~LET `~PointerEventを作成する$( %~event型, %~target )
◎
Let event be the result of creating a PointerEvent with eventType and target
</li>
	<li>
<p>
~IF［
%~nativeな~event は妥当である
］：
◎
If native is valid, then
</p>
		<ol>
			<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with event, native
</li>
			<li>
%~event の `screenX$m ~SET %~event の `screenX$m を整数に丸めた結果
◎
If event.screenX is not an integer value, then round it.
</li>
			<li>
%~event の `screenY$m ~SET %~event の `screenY$m を整数に丸めた結果
◎
If event.screenY is not an integer value, then round it.
</li>
		</ol>
	</li>
	<li>
`~eventを配送する$( %~target, %~event )
◎
dispatch event at target
</li>
</ol>

<p class="note">注記：
［
`PointerEvent^I, 丸められた座標
］を利用している~browserについての報は、
`課題 #100＠https://github.com/w3c/pointerevents/issues/100$
を見よ。
◎
• Note

• See pointerevents/100 for info about browsers using PointerEvents and rounded coordinates.
</p>

<p class="issue">
“`既定~動作$” は、［
配送する間に，~target用の`作動化の挙動$を誘発する
］ことにより取扱われる。
なので、
ここで それを取扱う必要は無い。
しかしながら、
既存の仕様が［
`不能化されて$feいるもの／
~CSS `pointer-events$p ／
`不活$なもの
］などを取扱うことを検証yする必要がある。
◎
• Editor's note

• Any "default action" is handled during dispatch by triggering the activation behavior algorithm for the target. So there is no need for handle that here. However, need to verify that the existing spec handles disabled/css-pointer-events/inert/...
</p>

<p class="note">注記：
`~HTML要素＠~HTMLINFRA#html-elements$【！HTMLelement】の `click()＠~HTMLinteraction#dom-click$c を取扱うときは、［
%~nativeな~event には ~NULL,
%~target には当の要素
］を渡して，この~algoを~callすること。
◎
• Note

• To handle HTMLelement.click(), call this algorithm with native = null and target = HTMLelement.
</p>

<p class="note">注記：
~keyboardから起動される~clickを取扱うときは、［
%~nativeな~event には ~NULL,
%~target には現在~focusされている要素
］を渡して，この~algoを~callすること。
◎
• Note

• To handle keyboard-initiated clicks, call this algorithm with native = null and target = currently focused element.
</p>
</div>

<div class="algo">
<p id="handle-native-mouse-double-click">
`~nativeな~double-clickを取扱う@
~algoは、
所与の
( ~nativeな~double-click %~nativeな~event )
に対し：
◎
4.2.16 handle native mouse double click
◎
Warning

This section needs to be revised.
◎
• Let native be the native mouse double click
</p>

<p class="note">注記：
これは、
~double-clickを生成する~click用には，
`~nativeな~clickを取扱う$の直後に~callされるべきである。
◎
• Note

• This should be called immediately after handle native mouse click for mouse clicks that generate double clicks.
</p>
<ol>
	<li>
~IF［
%~nativeな~event の`~mouse~button名$ ~NEQ `首~button^i
］
⇒
~RET
◎
Let mbutton be an ID from native that identifies which mouse button was pressed
◎
If mbutton is not the primary mouse button, then return
</li>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target be hit test with viewport-relative coordinates from native
</li>
	<li>
<p>
%~event ~LET `~PointerEventを作成する$( `dblclick^l, %~target )
</p>

<p class="trans-note">【
`dblclick$et は `MouseEvent$I を実装するものと定義されているが、
この段は，それに反する。
】</p>
◎
Let event be the result of creating a PointerEvent with "dblclick" and target
</li>
	<li>
`~MouseEvent属性を~nativeな~eventから設定する$( %~event, %~nativeな~event )
◎
Set MouseEvent attributes from native with event, native
</li>
	<li>
%~event の `screenX$m ~SET %~event の `screenX$m を整数に丸めた結果
◎
If event.screenX is not an integer value, then round it.
</li>
	<li>
%~event の `screenY$m ~SET %~event の `screenY$m を整数に丸めた結果
◎
If event.screenY is not an integer value, then round it.
</li>
	<li>
`~eventを配送する$( %~target, %~event )
◎
dispatch event at target
</li>
</ol>
</div>

<div class="algo">
<p id="handle-native-mouse-move">
`~nativeな~mousemoveを取扱う@
~algoは、
所与の
( ~nativeな~mousemove %~nativeな~event )
に対し：
◎
4.2.17 handle native mouse move
◎
Warning

This section needs to be revised.
◎
• Let native be the native mouse move
</p>

<p class="note">注記：
この~algoは、
`PointerEvent$I の配送について，ある種の前提を置く
— それらは、
現時点では明示的に指定されていないので。
`課題 #285＠https://github.com/w3c/pointerevents/issues/285$
が解決されたなら、
これは更新される必要があろう。
◎
• Issue 2

• This algorithm makes assumptions about the dispatch of PointerEvents because they are not currently specified explicitly. Once pointerevents/285 is resolved this may need to be updated.
</p>
<ol>
	<li>
%~target ~LET `接触判定する$( %~nativeな~event の`表示域~座標$ )
◎
Let target be hit test with viewport-relative coordinates from native
</li>
	<li>
<p>
%~target~DOM経路 ~LET %~target の`広義-先祖$たち
</p>

<p class="trans-note">【
順序が指定されていないため、
以下において~eventたちを発火する順序が不明瞭になっている。
】</p>
◎
Let targetDomPath be inclusive ancestors of target
</li>
	<li>
<p>
（この段は、
現在の要素から出て行く際の~eventを生成する。）
◎
Generate events for leaving the current element:
</p>

<p>
~IF［
`最後の~mouse要素$ ~NIN { ~NULL, %~target }
【！is defined and not equal to】
］：
◎
• If last mouse element is defined and not equal to target, then
</p>
		<ol>
			<li>
%~mouseout ~LET `~MouseEventを作成する$( `mouseout^l, `最後の~mouse要素$ )
◎
• Let mouseout be the result of creating a cancelable MouseEvent with "mouseout" and last mouse element
</li>
			<li class="issue">
%~nativeな~event から，
%~mouseout を成す `MouseEvent$I の属性
— `CSSOM-View$r による`拡張＠~CSSOMVIEW#extensions-to-the-mouseevent-interface$も含む —
を設定する。
◎
• Editor's note
• TODO: Set mouseout attributes from native. +CSSOM attributes.
</li>
			<li>
`必要なら~pointer~eventを送信する$( %~mouseout )
◎
• Maybe send pointerout event with mouseout
</li>
			<li>
<p>
`~eventを配送する$( %~target, %~mouseout )
◎
Dispatch mouseout at target
</p>

<p class="issue">【！note】
取消されたときの挙動を（その効果は無さそうに見えるが）検証yする。
◎
Note

Verify behavior when canceled (appears to have no effect).
</p>
			</li>
			<li>
%~mouseleave要素~群 ~LET « »
◎
↓</li>
			<li>
`最後の~mouse~DOM経路$を成す
~EACH( %要素 )
に対し
⇒
~IF［
%要素 ~NIN %~target~DOM経路
］
⇒
%~mouseleave要素~群 に %要素 を`付加する$
◎
Let leaveElements be a copy of last mouse DOM path with all elements common to targetDomPath removed.
</li>
			<li>
<p>
%~mouseleave要素~群 を成す
~EACH( %要素 )
に対し：
◎
For each element in leaveElements, do
</p>

<p class="issue">【！note】
%要素 が【~event~handlerなどにより】［
削除された事例, 移動された事例
］を取扱う：
`mouseleave$et ~eventは、
~DOM変異により誘発-済みになるべきか？
ここで送信するべきか？
落とされるべきか？
— 現在の~browserが何を行っているか検証yする必要がある。
◎
Editor's note

Handle case where element has been deleted. Also case where it has been moved: Should the DOM mutation have triggered a mouseleave event? Should we sent it now? Should it be dropped? Need to verify what current browsers do.
</p>
				<ol>
					<li>
%~mouseleave ~LET `~MouseEventを作成する$( `mouseleave^l, 
%要素, ~T )
◎
Let mouseleave be the result of creating a non-cancelable MouseEvent with "mouseleave" and element
</li>
					<li>
<p>
%~mouseleave の `composed$m ~SET ~F
◎
Set mouseleave.Event.composed = false
</p>

<p class="issue">【！note】
互換性を検査する：
`composed$m の値は、
仕様に従うなら ~F になるが，［
Linux 上の Chrome においては ~T,
Linux 上の Firefox においては ~F
］になる。
◎
Note

Check compat: Value of event.composed. Spec says false. Chrome/Linux = true. Firefox/Linux = false.
</p>
					</li>
					<li>
`必要なら~pointer~eventを送信する$( %~mouseleave )
◎
Maybe send pointerleave event with mouseleave
</li>
					<li>
【！result ~LET 】
`~eventを配送する$( %要素, %~mouseleave )
◎
Let result be dispatch mouseleave at element
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
（この段は、
新たな要素へ入って行く際の~eventを生成する。）
◎
Generate events for entering the new element:
</p>

<p>
~IF［
%~target ~NEQ `最後の~mouse要素$
］：
◎
• If target is not last mouse element, then
</p>
		<ol>
			<li>
%~mouseover ~LET `~MouseEventを作成する$( `mouseover^l, %~target )
◎
• Let mouseover be the result of creating a cancelable MouseEvent with "mouseover" and target
</li>
			<li class="issue">【！note】
%~nativeな~event から，
%~mouseout を成す `MouseEvent$I の属性
— `CSSOM-View$r による`拡張＠~CSSOMVIEW#extensions-to-the-mouseevent-interface$も含む —
を設定する。
◎
• Editor's note

• TODO: Set mouseout attributes from native. +CSSOM attributes.
</li>
			<li>
`必要なら~pointer~eventを送信する$( %~mouseover )
◎
• Maybe send pointerover event with mouseover
</li>
			<li>
<p>
`~eventを配送する$( %~target, %~mouseout )
◎
• Dispatch mouseout at target
</p>

<p class="issue">【！note】
取消されたときの挙動を（その効果は無さそうに見えるが）検証yする。
◎
• Note

• Need to verify behavior when canceled (appears to have no effect).
</p>
			</li>
			<li>
%~mouseenter要素~群 ~LET « »
◎
↓</li>
			<li>
%~target~DOM経路 を成す
~EACH( %要素 )
に対し
⇒
~IF［
%要素 ~NIN `最後の~mouse~DOM経路$
］
⇒
%~mouseenter要素~群 に %要素 を`付加する$
◎
• Let enterElements be a copy of targetDomPath with all elements common to last mouse DOM path removed.
</li>
			<li>
<p>
%~mouseenter要素~群 を成す
~EACH( %要素 )
に対し：
◎
• For each element in enterElements, do
</p>

<p class="issue">【！note】
%要素 が【~event~handlerなどにより】［
削除された事例, 移動された事例
］を取扱う。
◎
• Note

• Handle case where element has been deleted or moved.
</p>
				<ol>
					<li>
%~mouseenter ~LET `~MouseEventを作成する$( `mouseenter^l, %要素, ~T )
◎
• Let mouseenter be the result of creating a non-cancelable MouseEvent with "mouseenter" and element
</li>
					<li>
<p>
%~mouseenter の `composed$m ~SET ~F
◎
• Set mouseenter.Event.composed = false
</p>

<p class="issue">【！note】
互換性を検査する：
`composed$m の値は、
仕様に従うなら ~F になるが，［
Linux 上の Chrome においては ~T,
Linux 上の Firefox においては ~F
］になる。
◎
• Note

• Check compat: Value of event.composed. Spec says false. Chrome/Linux = true. Firefox/Linux = false.
</p>
					</li>
					<li>
`必要なら~pointer~eventを送信する$( %~mouseenter )
◎
• Maybe send pointerenter event with mouseenter
</li>
					<li class="issue">【！note】
~shadow~DOM要素~用に互換性を検査する。
Linux 上の Chrome は、
この~eventを当の［
要素, ~shadow根
］に向けて発火する。
◎
• Note

• Check compat for shadow DOM elements. Chrome/Linux fires this event at the element and the shadow root.
</li>
					<li>
【！利用されない変数 Let result = 】
`~eventを配送する$( %要素, %~mouseenter )
◎
• Let result be dispatch mouseenter at element
</li>
				</ol>
			</li>
			<li>
`最後の~mouse要素$ ~SET %~target
◎
• Set last mouse element to target
</li>
			<li>
`最後の~mouse~DOM経路$ ~SET %~target~DOM経路
◎
• Set last mouse DOM path to targetDomPath
</li>
		</ol>
	</li>
	<li>
%~mousemove ~LET `~MouseEventを作成する$( `mousemove^l, %要素 )
◎
Let mousemove be the result of creating a cancelable MouseEvent with "mousemove" and element
</li>
	<li>
`~mousemove用に各~pointer~lock属性を設定する$( %~mousemove )
◎
Set PointerLock attributes for mousemove
</li>
	<li>
`必要なら~pointer~eventを送信する$( %~mousemove )
◎
Maybe send pointermove event with mousemove
</li>
	<li>
`~eventを配送する$( %要素, %~mousemove )
◎
Dispatch mousemove at element
</li>
</ol>
</div>

<div class="algo">
<p id="maybe-show-context-menu">
`必要なら文脈~menuを示す@
~algoは、
所与の
( ~nativeな~mousedown【！ or pointer event】 %~nativeな~event, `EventTarget$I %~target )
に対し：
◎
4.2.18 maybe show context menu
◎
Warning
◎
This section needs to be revised.
• Let native be the native mousedown or pointer event
• Let target be the EventTarget of the event
</p>
<ol>
	<li>
%~contextmenu ~LET `~PointerEventを作成する$( `contextmenu^l, %~target )
◎
• Let menuevent be the result of creating a PointerEvent with "contextmenu", target
</li>
	<li>
~IF［
%~nativeな~event は妥当である
【何をもって “妥当” とされる？】
］
⇒
`~MouseEvent属性を~nativeな~eventから設定する$( %~contextmenu, %~nativeな~event )
◎
• If native is valid, then
•• Set MouseEvent attributes from native with native
</li>
	<li>
%取消されなかったか ~LET `~eventを配送する$( %~target, %~contextmenu )
◎
• Let result be dispatch menuevent at target
</li>
	<li>
~IF［
%取消されなかったか ~EQ ~T
］
⇒
~UAの文脈~menuを示す
◎
• If result is true, then show the UA context menu
</li>
</ol>

<p class="note">注記：
~keyboardにより誘発される文脈~menuを取扱うときは、［
%~nativeな~event には ~NULL,
%~target には 現在~focusされている要素
］を渡して，この~algoを~callすること。
◎
Note

To handle a context menu triggered by the keyboard, call this algorithm with native = null and target = currently focused element.
</p>
</div>

			</section>
		</section>
		<section id="mouse-event-order">
<h3 title="Mouse Event Order">4.3. ~mouse~event序列</h3>

<p>
この仕様にて定義される ある種の~mouse~eventたちは、
互いに相対的な順序で生じるモノトスル。
`~pointing先$が，ある要素 %A に変化したときは、
次の`~event連列$が生じるモノトスル：
◎
Certain mouse events defined in this specification MUST occur in a set order relative to one another. The following shows the event sequence that MUST occur when a pointing device's cursor is moved over an element:
</p>

<div>
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>要素
<th>備考
<tbody>

<tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A に変化した…
</em>

<tr><td>2.
<td>`mouseover$et
<td>%A
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A でなくなった…
</em>

<tr><td>5.
<td>`mouseout$et
<td>%A
<td>

<tr><td>6.
<td>`mouseleave$et
<td>%A
<td>
</table>
◎
#｜Event Type｜Element｜Notes
1｜mousemove｜｜
｜｜｜Pointing device is moved into element A...
2｜mouseover｜A｜
3｜mouseenter｜A｜
4｜mousemove｜A｜Multiple mousemove events
｜｜｜Pointing device is moved out of element A...
5｜mouseout｜A｜
6｜mouseleave｜A｜
</div>

<p>
`~pointing先$が要素 %A に変化して，その入子な要素 %B に変化して
また %A に戻ったときは、
次の~event連列が生じるモノトスル：
◎
When a pointing device is moved into an element A, and then into a nested element B and then back out again, the following sequence of events MUST occur:
</p>

<div>
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>要素
<th>備考
<tbody>

<tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A に変化した…
</em>

<tr><td>2.
<td>`mouseover$et
<td>%A
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %B に変化した…
</em>

<tr><td>5.
<td>`mouseout$et
<td>%A
<td>

<tr><td>6.
<td>`mouseover$et
<td>%B
<td>

<tr><td>7.
<td>`mouseenter$et
<td>%B
<td>

<tr><td>8.
<td>`mousemove$et
<td>%B
<td>複数回 生じ得る

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %B から %A に変化した…
</em>

<tr><td>9.
<td>`mouseout$et
<td>%B
<td>

<tr><td>10.
<td>`mouseleave$et
<td>%B
<td>

<tr><td>11.
<td>`mouseover$et
<td>%A
<td>

<tr><td>12.
<td>`mousemove$et
<td>%A
<td>複数回 生じ得る

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は %A でなくなった…
</em>

<tr><td>13.
<td>`mouseout$et
<td>%A
<td>

<tr><td>14.
<td>`mouseleave$et
<td>%A
<td>
</table>
◎
#｜Event Type｜Element｜Notes
1｜mousemove｜｜
｜｜｜Pointing device is moved into element A...
2｜mouseover｜A｜
3｜mouseenter｜A｜
4｜mousemove｜A｜Multiple mousemove events
｜｜｜Pointing device is moved into nested element B...
5｜mouseout｜A｜
6｜mouseover｜B｜
7｜mouseenter｜B｜
8｜mousemove｜B｜Multiple mousemove events
｜｜｜Pointing device is moved from element B into A...
9｜mouseout｜B｜
10｜mouseleave｜B｜
11｜mouseover｜A｜
12｜mousemove｜A｜Multiple mousemove events
｜｜｜Pointing device is moved out of element A...
13｜mouseout｜A｜
14｜mouseleave｜A｜
</div>

<p>
~CSSの利用により，いくつかの要素が視覚的に重合することもある。
次の例では、
3 個の要素［
%A, %B, %C
］は，いずれも ~web~page上で 同じ［
寸法, 絶対~位置
］にされていて、
~DOM内では，
%C は %B の子,
%B は %A の子
であるとする：
◎
Sometimes elements can be visually overlapped using CSS. In the following example, three elements labeled A, B, and C all have the same dimensions and absolute position on a web page. Element C is a child of B, and B is a child of A in the DOM:
</p>

<figure id="figure-mouse-event-stacked-elements">
<figcaption id="_dgm-stacked-event-mouse-dispatch">
同じ所に積層された 3 個の要素の~graphicな表現（最下層から順に %A, %B, %C ）
— ~pointing装置は、
最も手前にある要素（ %C ）上に動いている。
◎
Figure 2＼
Graphical representation of three stacked elements all on top of each other, with the pointing device moving over the stack.
</figcaption></figure>

<p>
~pointing装置が、
積層された要素の外側から要素 %C 内に動いて，また外へ出たときは、
次の~event連列が生じるモノトスル：
◎
When the pointing device is moved from outside the element stack to the element labeled C and then moved out again, the following series of events MUST occur:
</p>

<div>
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>要素
<th>備考
<tbody>

<tr><td>1.
<td>`mousemove$et
<td>
<td>

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は［
積層-内の最上層な要素である要素 %C
］に変化した…
</em>

<tr><td>2.
<td>`mouseover$et
<td>%C
<td>

<tr><td>3.
<td>`mouseenter$et
<td>%A
<td>

<tr><td>4.
<td>`mouseenter$et
<td>%B
<td>

<tr><td>5.
<td>`mouseenter$et
<td>%C
<td>

<tr><td>6.
<td>`mousemove$et
<td>%C
<td>複数回 生じ得る

<tr><td>
<td>
<td>
<td><em>
`~pointing先$は 要素 %C でなくなった…
</em>

<tr><td>7.
<td>`mouseout$et
<td>%C
<td>

<tr><td>8.
<td>`mouseleave$et
<td>%C
<td>

<tr><td>9.
<td>`mouseleave$et
<td>%B
<td>

<tr><td>10.
<td>`mouseleave$et
<td>%A
<td>
</table>
◎
#｜Event Type｜Element｜Notes
1｜mousemove｜｜
｜｜｜Pointing device is moved into element C, the topmost element in the stack
2｜mouseover｜C｜
3｜mouseenter｜A｜
4｜mouseenter｜B｜
5｜mouseenter｜C｜
6｜mousemove｜C｜Multiple mousemove events
｜｜｜Pointing device is moved out of element C...
7｜mouseout｜C｜
8｜mouseleave｜C｜
9｜mouseleave｜B｜
10｜mouseleave｜A｜
</div>

<p class="note">注記：
［
`mouseover$et ／ `mouseout$et
］~eventが発火されるのは， 1 回に限られる一方、［
`mouseenter$et ／ `mouseleave$et
］~eventは，（各~要素ごとに 1 回ずつ）計 3 回~発火される。
◎
Note

The mouseover/mouseout events are only fired once, while mouseenter/mouseleave events are fired three times (once to each element).
</p>

<p class="trans-note">【
概念的には、
一連の［
`mouseenter$et ／ `mouseleave$et
］~eventは，~pointerが［
先祖から子孫に向かって ／ 子孫から先祖に向かって
］（微小な間をおいて）要素の境界を順々にまたいでいったと解釈した下で生じるもの，
と捉えられる
— ただし、
この解釈は，
`relatedTarget$m に関して~~正確でないが
（この解釈の下では、
各~子孫に配送される `mouseenter$et ~eventの `relatedTarget^m は，各自の親を指すことになる）。
これらは、
~eventの伝播ではないので、
例えば，［
要素 %A に登録されている `mouseenter$et 用の`~event~handler$
］が，［
%B ／ %C を その表示位置はそのままに，~DOM内での位置を変えた場合
］の挙動は，明示的に規定されていない
（この節の最後の記述も見よ）。
】</p>

<p>
~pointing装置に結付けられた~button
（例：~mouse~buttonや~trackpad）
が，要素~上で押されてから, 離されたときの，代表的な~event連列：
◎
The following is the typical sequence of events when a button associated with a pointing device (e.g., a mouse button or trackpad) is pressed and released over an element:
</p>

<div>
<table class="event-sequence-table"><thead>
<tr><td>
<th>~event型
<th>備考
<tbody>

<tr><td>1.
<td>`mousedown$et
<td>

<tr><td>2.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）

<tr><td>3.
<td>`mouseup$et
<td>

<tr><td>4.
<td>`click$et
<td>

<tr><td>5.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）

<tr><td>6.
<td>`mousedown$et
<td>

<tr><td>7.
<td>`mousemove$et
<td>
0 回 以上生じ得る（下記~注記も見よ）

<tr><td>8.
<td>`mouseup$et
<td>

<tr><td>9.
<td>`click$et
<td>

<tr><td>10.
<td>`dblclick$et
<td>
</table>
◎
#｜Event Type｜Notes
1｜mousedown｜
2｜mousemove｜OPTIONAL, multiple events, some limits
3｜mouseup｜
4｜click｜
5｜mousemove｜OPTIONAL, multiple events, some limits
6｜mousedown｜
7｜mousemove｜OPTIONAL, multiple events, some limits
8｜mouseup｜
9｜click｜
10｜dblclick｜
</div>

<p class="note">注記：
上の［
`mousedown$et と `mouseup$et ~eventの間
］に許容される `mousemove$et ~eventを生じさせる~~移動距離や~~頻度は、［
実装／装置／~platform
］に特有になる。
この許容誤差は、
身体的不利
— 手が震えるなど —
を抱える利用者が~pointing装置でヤリトリするときの援助にもなり得る。
◎
Note

The lag time, degree, distance, and number of mousemove events allowed between the mousedown and mouseup events while still firing a click or dblclick event will be implementation-, device-, and platform-specific. This tolerance can aid users that have physical disabilities like unsteady hands when these users interact with a pointing device.
</p>

<p>
各~実装は，適切な`~hysteresis$を決定することになるが、
一般に［
結付けられた［
`mousedown$et ~event, `mouseup$et ~event
］の~targetが同じ要素であって，
`mouseout$et ~eventや `mouseleave$et ~eventは介在しない
］ときには、［
`click$et ／ `dblclick$et
］~eventを発火するベキである。
また，結付けられた［
`mousedown$et ~event, `mouseup$et ~event
］の~targetが異なるときは、
最も近い共通な`広義-先祖$に対し［
`click$et ／ `dblclick$et
］~eventを発火するベキである。
◎
Each implementation will determine the appropriate hysteresis tolerance, but in general SHOULD fire click and dblclick events when the event target of the associated mousedown and mouseup events is the same element with no mouseout or mouseleave events intervening, and SHOULD fire click and dblclick events on the nearest common inclusive ancestor when the associated mousedown and mouseup event targets are different.
</p>

<div class="example">
<p>
`mousedown$et ~eventが~HTML文書の`~body要素$を~targetにしていて，
対応する `mouseup$et ~eventが`文書~要素$を~targetにしている場合、
`click$et ~eventは当の文書~要素へ配送されることになる
— それが，最も近い共通な`広義-先祖$なので。
◎
If a mousedown event was targeted at an HTML document's body element, and the corresponding mouseup event was targeted at the document element, then the click event will be dispatched to the document element, since it is the nearest common inclusive ancestor.
</p>
</div>

<p>
~mouse~event連列の最中に，`~target$が~DOMから除去された場合、
当の連列を成す残りの~eventは，当の要素には発火しないモノトスル。
◎
If the target (e.g. the target element) is removed from the DOM during the mouse events sequence, the remaining events of the sequence MUST NOT be fired on that element.
</p>

<p class="trans-note">【
~targetが~DOMの中で移動された場合はどうなる？
その種の位置~変化が伴われるような いかなる~DOM~~操作も，［
要素をいったん~DOM~treeから除去してから挿入し直すものである
］と解釈するならば、
それらの要素には，~eventは配送されなくなることになるが。
】</p>

<div class="example">
<p>
`mousedown$et ~eventの結果，【~event~listenerにより】
~target要素が~DOMから除去された場合、
その要素に対しては［
`mouseup$et, `click$et, `dblclick$et,
］~eventは発火されず、
これらの~eventによる既定の`作動化の挙動$も誘発されなくなる。
それでも、
`mouseup$et ~eventは，［
~target要素が除去された後に新たに`~pointing先$になった要素
］に対しては発火されることになる。
同様に， `mouseup$et ~eventの配送-の最中に ~target要素が~DOMから除去された場合、
`click$et, および後続な~eventは，配送されなくなる。
◎
If the target element is removed from the DOM as the result of a mousedown event, no events for that element will be dispatched for mouseup, click, or dblclick, nor any default activation events. However, the mouseup event will still be dispatched on the element that is exposed to the mouse after the removal of the initial target element. Similarly, if the target element is removed from the DOM during the dispatch of a mouseup event, the click and subsequent events will not be dispatched.
</p>
</div>

		</section>
		<section id="mouse-event-types">
<h3 title="Mouse Event Types">4.4. 各種~mouse~event型</h3>

<p>
以下に，各種~mouse~event型を挙げる。
入子な要素に対しては、
~mouse~event型は，常に`~pointing先$
— 最も深く入子にされた要素† —
を~targetにする。
~targetにされた要素の先祖は、
~event浮上を利用して，その子孫~要素たちの中で生じた~mouse~eventの通知を得することができる。
◎
The Mouse event types are listed below. In the case of nested elements, mouse event types are always targeted at the most deeply nested element. Ancestors of the targeted element MAY use bubbling to obtain notification of mouse events which occur within its descendent elements.
</p>

<p class="trans-note">【†
`mouseenter$et, `mouseleave$et に関しては、
その限りでない。
】</p>

			<section id="auxclick">
<h4>4.4.1. `auxclick^et</h4>

<div>
◎イ型 `auxclick@et
◎界面 `PointerEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 文脈依存
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`detail$m：
`現在の~click回数$を指示する
— 属性~値は、
利用者がこの動作を始めたときは 1 になり，
その後，各~clickごとに 1 ずつ増やすモノトスル。
</li>
	<li>
`PointerEvent$I に特有な属性については、
`§ ~pointer~event$【！`PointerEvents$r】
を見よ。
</li>
</ul>
◎表終

◎
Type 	auxclick
Interface 	PointerEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
• For PointerEvent specific attributes, see the [PointerEvents] spec.
</div>

<p>
`auxclick$et ~event型は、
利用者が非~首~pointer~buttonを［
押してから, 離した
］とき, あるいは［
そのような動作を模倣sする方式で~pointerが作動化された
］ときに、
`最上層な~event~target$が要素であるならば，それに向けて発火するモノトスル。
~mouse~buttonがどのように作動されるかは、［
~pointing装置, 環境設定
］に依存する。
例えば、
~screen上の所在や，~buttonが押されてから離されるまでの遅延に依存することもある。
◎
The auxclick event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the non-primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.
</p>

<p>
`auxclick^et ~eventは、
非~首~pointer~button用に限り，発火されるベキである
（すなわち， `MouseEvent$I の
`button$m 値 ~NEQ 0 ／
`buttons$m 値 ~GT 1
）。
`auxclick^et ~eventは、
首~button（標準的な~mouseの左~buttonなど）からは，発火されないモノトスル。
対応する，首~buttonに結付けられた~eventについては `click$et を見よ。
◎
The auxclick event should only be fired for the non-primary pointer buttons (i.e., when button value is not 0, buttons value is greater than 1). The primary button (like the left button on a standard mouse) MUST NOT fire auxclick events. See click for a corresponding event that is associated with the primary button.
</p>

<p>
`auxclick$et ~eventに先行して，同じ要素~上に［
`mousedown$et ／ `mouseup$et
］~eventが発火される場合もある
— 他の~node型（例： ~text~node）への移動は無視rして【下記 例を見よ】。
環境設定に依存して、
`auxclick$et ~eventは、
~pointing装置の~buttonが押されてから離されるまでの間に ~event型［
`mouseover$et,
`mousemove$et,
`mouseout$et
］ 1 回以上 生じた場合にも発火されてヨイ。
◎
The auxclick event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the auxclick event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button.
</p>

<p>
`auxclick$et ~event型の`既定~動作$は、
文脈依存であり，［
当の~eventの`~target$
］および［
`MouseEvent$I の
`button$m ／ `buttons$m
属性の値
］に基づく。
`auxclick$et ~event型の代表的な`既定~動作$は、
次に従う：
◎
The default action of the auxclick event type varies based on the target of the event and the value of the button or buttons attributes. Typical default actions of the auxclick event type are as follows:
</p>

<ul>
	<li>
`~target$に結付けられた`作動化の挙動$がある場合、
`既定~動作$は，それを実行するモノトスル。
◎
If the target has associated activation behavior, the default action MUST be to execute that activation behavior.
</li>
</ul>

<div class="example">
<p id="example-receiving-and-handling-auxclick-for-the-middle">
中央~buttonによる `auxclick^et を受取って取扱う例：
◎
Example 6: Receiving and handling auxclick for the middle
</p>

<pre class="lang-js">
%myLink.addEventListener( "auxclick", function(%e) {
   if (%e.button === 1) {
     /* <span class="comment">
これは既定の挙動
— 例えば ~link上で中央~clickしたときに新たな~UItabで開くなど —
を防止することになる。
◎
This would prevent the default behavior which is for example opening a new tab when middle clicking on a link.
</span> */
     %e.preventDefault();

     /* <span class="comment">
中央~buttonの~clickを取扱うために何か他を行う
— ~appに適した仕方で新たな~UItab内に ~linkや非~link~buttonを開くことに~~注力する様な。
~UItab帯~内の~UItabを閉じる様な，~click動作で行われるべき他の動作もここで行える。
◎
Do something else to handle middle button click like taking care of opening link or non-link buttons in new tabs in a way that fits the app. Other actions like closing a tab in a tab-strip which should be done on the click action can be done here too.
</span> */
   }
 });
</pre>

</div>

<p class="note">注記：
右~buttonの事例では、
`auxclick^et ~eventは，
`contextmenu$et ~eventより後に配送される。
一部の~UAは、
文脈~menuが表示されている間，すべての入力~eventを吸い取ることに注意
— そのような局面では、
`auxclick$et は~appに可用にならないであろう。
より明確には、
`次の例＠#example-auxclick-right$を見よ。
◎
In the case of right button, the auxclick event is dispatched after any contextmenu event. Note that some user agents swallow all input events while a context menu is being displayed, so auxclick may not be available to applications in such scenarios. See Example 7 for more clarification. 
</p>

<div class="example">
<p id="example-auxclick-right">
右~buttonによる `auxclick^et を受取って取扱う例：
◎
Example 7: Receiving and handling auxclick for the right button 
</p>

<pre class="lang-js">
%myDiv.addEventListener("contextmenu", function(%e) {
   /* <span class="comment">
この~callは、
~pageが~eventを受取ったときに，~pageに干渉するような文脈~menuは示されないようにする。
◎
This call makes sure no context menu is shown to interfere with page receiving the events.
</span> */
    %e.preventDefault();
});

%myDiv.addEventListener("auxclick", function(%e) {
  if (%e.button === 2) {
    /* <span class="comment">
右~button~clickを取扱うために何か他を行う
— ~appの内側に~custom化した文脈~menuを開く様な。
◎
Do something else to handle right button click like opening a customized context menu inside the app.
</span> */
 }
});
</pre>

</div>

			</section>
			<section id="click">
<h4>4.4.2. `click^et</h4>

<div>
◎イ型 `click@et
◎界面 `PointerEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 文脈依存
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`detail$m：
`現在の~click回数$を指示する
— 属性~値は、
利用者がこの動作を始めたときは
1 になり，その後，各~clickごとに 1 ずつ増やすモノトスル。
</li>
	<li>
`PointerEvent$I に特有な属性については、
`§ ~pointer~event$【！`PointerEvents$r】
を見よ。
</li>
</ul>
◎表終

◎
Type 	click
Interface 	PointerEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
• For PointerEvent specific attributes, see the [PointerEvents] spec.
</div>

<p>
`click$et ~event型は、
利用者が首~pointer~buttonを［
押してから, 離した
］とき, あるいは［
そのような動作を模倣sする方式で~pointerが作動化された
］ときに、
`最上層な~event~target$が要素であるならば，それに向けて発火するモノトスル。
~mouse~buttonがどのように作動されるかは、［
~pointing装置, 環境設定
］に依存する。
例えば、
~screen上の所在や，~buttonが押されてから離されるまでの遅延に依存することもある。
◎
The click event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.
</p>

<p>
`click^et ~eventは、
首~pointer~button用に限り，発火されるベキである
（すなわち， `MouseEvent$I の
`button$m 値は 0 ／
`buttons$m 値は 1
）。
`click^et ~eventは、
副~button
（標準的な~mouseの［
中央~button／右~button
］など）
からは，発火されないモノトスル。
対応する，非~首~buttonに結付けられた~eventについては `auxclick$et を見よ。
◎
The click event should only be fired for the primary pointer button (i.e., when button value is 0, buttons value is 1). Secondary buttons (like the middle or right button on a standard mouse) MUST NOT fire click events. See auxclick for a corresponding event that is associated with the non-primary buttons.
</p>

<p>
`click$et ~eventに先行して，同じ要素~上に［
`mousedown$et ／ `mouseup$et
］~eventが発火される場合もある
— 他の~node型（例： ~text~node）への移動は無視rして【下記 例を見よ】。
環境設定に依存して、
`click$et ~eventは、
~pointing装置の~buttonが押されてから離されるまでの間に ~event型［
`mouseover$et,
`mousemove$et,
`mouseout$et
］ 1 回以上 生じた場合にも発火されてヨイ。
`click$et ~eventには `dblclick$et ~eventが後続してもヨイ。
◎
The click event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the click event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button. The click event MAY also be followed by the dblclick event.
</p>

<div class="example">
<p>
利用者が［
（~CSS~propにより）行高が大きくなるよう~styleされた `p^e 要素
］の ある子~text~node上で~mouseを~~押下げて，
~mouseを当の~text~nodeを外れる所まで少しズラしてから
（すなわち、
~pointerは同じ~text~blockを成す行lたちの合間にあるが，
`~pointing先$は依然として `p^e 要素を指している）
~mouseを~~離した場合でも、
まだ同じ要素の視野にあるので，依然として `click$et ~eventを誘発する見込みが高い
（ `click$et 用の通常の時間的な`~hysteresis$に~~収まるならば）。
~UAにより生成される~mouse~eventは、
~text~nodeへ向けて発火されることはないことに注意。
◎
If a user mouses down on a text node child of a &lt;p&gt; element which has been styled with a large line-height, shifts the mouse slightly such that it is no longer over an area containing text but is still within the containing block of that &lt;p&gt; element (i.e., the pointer is between lines of the same text block, but not over the text node per se), then subsequently mouses up, this will likely still trigger a click event (if it falls within the normal temporal hysteresis for a click), since the user has stayed within the scope of the same element. Note that user-agent-generated mouse events are not dispatched on text nodes.
</p>
		</div>

<p>
~event型 `click$et は、
結付けられた~pointing装置に加えて，
要素に対する作動化の一環としても発火するモノトスル。
◎
In addition to being associated with pointer devices, the click event type MUST be dispatched as part of an element activation.
</p>

<p class="note">注記：
~accessibilityを最大限に得るため、
内容~作者には，~custom~control用の`作動化の挙動$を定義する際にも `click$et ~event型を利用することが奨励される
— `mousedown$et や `mouseup$et など，より~pointing装置に特有な他の~event型ではなく。
`click$et ~event型は，~pointing装置（例： ~mouse）に由来するものであるが、
後続な実装においては，その結付けを超えるよう拡張されており、
要素を作動化するための，装置に依存しない~event型と見なせるので。
◎
Note

For maximum accessibility, content authors are encouraged to use the click event type when defining activation behavior for custom controls, rather than other pointing-device event types such as mousedown or mouseup, which are more device-specific. Though the click event type has its origins in pointer devices (e.g., a mouse), subsequent implementation enhancements have extended it beyond that association, and it can be considered a device-independent event type for element activation.
</p>

<p>
`click$et ~event型の`既定~動作$は、
文脈依存であり，［
当の~eventの`~target$
］および［
`MouseEvent$I の
`button$m ／ `buttons$m
属性の値
］に基づく。
`click$et ~event型の代表的な`既定~動作$は、
次に従う：
◎
The default action of the click event type varies based on the target of the event and the value of the button or buttons attributes. Typical default actions of the click event type are as follows:
</p>
<ul>
	<li>
`~target$に結付けられた`作動化の挙動$がある場合、
`既定~動作$は，それを実行するモノトスル。
◎
If the target has associated activation behavior, the default action MUST be to execute that activation behavior.
</li>
	<li>
`~target$が~focus可能ならば、
`既定~動作$は，その要素に文書~focusを与えるモノトスル。
◎
If the target is focusable, the default action MUST be to give that element document focus.
</li>
</ul>

			</section>
			<section id="contextmenu">
<h4>4.4.3. `contextmenu^et</h4>

<div>
◎イ型 `contextmenu@et
◎界面 `PointerEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 ~supportされるなら、文脈~menuを呼出す
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li class="trans-note">【
`PointerEvent$I に特有な属性については、
`§ ~pointer~event$を見よ。
】</li>
</ul>

◎表終

◎
Type 	contextmenu
Interface 	PointerEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Invoke a context menu if supported.
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shiftmodifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
`~UA$は、
この~eventを文脈~menuを呼出す前に配送するモノトスル。
◎
A user agent MUST dispatch this event before invoking a context menu.
</p>

<p>
`contextmenu$et ~eventが右~mouse~buttonにより誘発されたときは、
`mousedown$et ~eventより後に配送するモノトスル。
◎
When the contextmenu event is triggered by right mouse button, the contextmenu event MUST be dispatched after the mousedown event.
</p>

<p class="note">注記：
`contextmenu$et ~eventが `mouseup$et ~eventより前に配送されるか後に配送されるかは、
~platformに依存する。
◎
Note

Depending on the platform, the contextmenu event may be dispatched before or after the mouseup event.
</p>

			</section>
			<section id="dblclick">
<h4>4.4.4. `dblclick^et</h4>

<div>
◎イ型 `dblclick@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`detail$m：
`現在の~click回数$を指示する
</li>
</ul>
◎表終

◎
Type 	dblclick
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• UIEvent.view : Window
• UIEvent.detail : indicates the current click count
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
`~UA$は、［
要素~上で~pointing装置の首~buttonが
【ある時間内に】
二回~clickされた
］とき，この~eventを発火するモノトスル。
~double-clickの定義は、
その~targetが［
`mousedown$et ／ `mouseup$et ／ `dblclick$et
］と同じになるモノトスルことを除いて，環境設定に依存する。
この~event型は、［
~clickと~double-clickが同時に生じた場合は `click$et  ／
他の場合は `mouseup$et
］の後に配送するモノトスル。
◎
A user agent MUST dispatch this event when the primary button of a pointing device is clicked twice over an element. The definition of a double click depends on the environment configuration, except that the event target MUST be the same between mousedown, mouseup, and dblclick. This event type MUST be dispatched after the event type click if a click and double click occur simultaneously, and after the event type mouseup otherwise.
</p>

<p>
`click$et ~eventと同様に，
`dblclick$et ~eventが発火されるのは、
首~pointer~buttonからに限られるベキであり，
副~buttonからは発火されないモノトスル。
◎
As with the click event, the dblclick event should only be fired for the primary pointer button. Secondary buttons MUST NOT fire dblclick events.
</p>

<p class="note">注記：
`click$et ~eventを取消しても、
`dblclick$et ~eventが発火されるかどうかには影響しない。
◎
Note

Canceling the click event does not affect the firing of a dblclick event.
</p>

<p>
`click$et ~event型と同じく，
`dblclick$et ~event型の`既定~動作$は、
文脈依存であり，
~eventの`~target$および［
`button$m ／ `buttons$m
］属性の値に基づく。
`dblclick$et ~event型の代表的な`既定~動作$は、
`click$et ~event型のそれと合致する。
◎
As with the click event type, the default action of the dblclick event type varies based on the target of the event and the value of the button or buttons attributes. The typical default actions of the dblclick event type match those of the click event type.
</p>

			</section>
			<section id="mousedown">
<h4>4.4.5. `mousedown^et</h4>

<div>
◎イ型 `mousedown@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 
<ul>
	<li>
~drag／~drop操作oを開始する
</li>
	<li>
~text選択を開始する
</li>
	<li>
~scroll／~panによるヤリトリを開始する
（~supportされるなら，中央~mouse~buttonとの組合nで）
</li>
</ul>
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`detail$m：
( `現在の~click回数$ + 1 )
を指示する。
例えば、
`mousedown$et の直前に~clickが起きていない場合の `detail$m 値は
1 になる。
</li>
</ul>
◎表終

◎
Type 	mousedown
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	Varies: Start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported)
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count incremented by one. For example, if no click happened before the mousedown, detail will contain the value 1
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
`~UA$は、［
~pointing装置の~buttonが要素~上で押された
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when a pointing device button is pressed over an element.
</p>

<p class="note">注記：
多くの実装が、
`mousedown$et ~eventを利用して，文脈に依存する種々の`既定~動作$を開始する。
これらの既定~動作は、
この~eventを取消すことにより，防止できる。
これらの既定~動作には、
画像や~linkに対し［
~drag／~drop
］によるヤリトリを始めたり，~text選択を開始する, 等々がある。
加えて、
~mouse駆動な~panning特能を供する実装もある
（ `mousedown$et ~eventの配送-時に，中央~mouse~buttonが押されていた場合に作動化されるような）。
◎
Note

Many implementations use the mousedown event to begin a variety of contextually dependent default actions. These default actions can be prevented if this event is canceled. Some of these default actions could include: beginning a drag/drop interaction with an image or link, starting text selection, etc. Additionally, some implementations provide a mouse-driven panning feature that is activated when the middle mouse button is pressed at the time the mousedown event is dispatched.
</p>

			</section>
			<section id="mouseenter">
<h4>4.4.6. `mouseenter^et</h4>

<div>
◎イ型 `mouseenter@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Element$I
◎取消 不可
◎構 No
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
注釈文を見よ。
</li>
	<li>
`button$m： 0
</li>
	<li>
`relatedTarget$m：
以前の`~pointing先$。
</li>
</ul>
◎表終

◎
Type 	mouseenter
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Element
Cancelable 	No
Composed 	No
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the target | a pointing device is exiting, if any.
</div>

<p>
`~UA$は、［
`~pointing先$が`有効に変化-$して，ある要素とその子孫たちが成す境界に入った†
］とき、
その要素に向けて，この~eventを発火するモノトスル。
この~event型は， `mouseover$et に類似するが、
浮上しないこと, および［
以前の`~pointing先$が要素の子孫である場合、
要素に向けて発火してはナラナイ
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or one of its descendent elements. A user agent MUST also dispatch this event when the element or one of its descendants moves to be underneath the primary pointing device. This event type is similar to mouseover, but differs in that it does not bubble, and MUST NOT be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
</p>

<div class="trans-note">
<p>【†
すなわち、
~pointing先が変化したとき，
~AND↓ を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
新たな~pointing先か, または その先祖である。
</li>
	<li>
以前の~pointing先でも, その先祖でもない。
</li>
</ul>
<p>
該当する要素が複数~在る場合
（例：以前の~pointing先が ~NULL ならば、
新たな~pointing先と その先祖~要素~すべてが該当する）、
最も先祖のものから順に，この~eventを発火することになろう
（この順序は、
一般な記述として明文化されてはいないが，
`積層された例＠#figure-mouse-event-stacked-elements$
における~mouse~event序列に基づく）。
</p>

<p>
該当する要素のうち，新たな`~pointing先$ 以外のものは、
`接触判定＠#dfn-topmost-event-target$の対象から除外されるかもしれない
— そのような要素には発火しないとするのが正しい挙動かもしれない（はっきりしない）。
】</p>

</div>

<p class="note">注記：
この~event型と~CSSの `~hover_ps 疑似類$ `CSS2$r には、
類似性がある。
`mouseleave$et ~event型も見よ。
◎
Note

There are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseleave event type.
</p>

			</section>
			<section id="mouseleave">
<h4>4.4.7. `mouseleave^et</h4>

<div>
◎イ型 `mouseleave@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 しない
◎標的 `Element$I
◎取消 不可
◎構 No
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
注釈文を見よ。
</li>
	<li>
`button$m：
0
</li>
	<li>
`relatedTarget$m：
新たな`~pointing先$
【！issue #307】
</li>
</ul>
◎表終

◎
Type 	mouseleave
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	No
Trusted Targets 	Element
Cancelable 	No
Composed 	No
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the target | a pointing device is exiting, if any.
</div>

<p>
`~UA$は、［
`~pointing先$が`有効に変化-$して，ある要素とその子孫たちが成す境界から出た†
］とき、
その要素に向けて，この~eventを発火するモノトスル。
この~event型は， `mouseout$et に類似するが、
浮上しないこと, および［
新たな`~pointing先$が要素の子孫である場合、
要素に向けて発火してはナラナイ
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element and all of its descendent elements. A user agent MUST also dispatch this event when the element or one of its descendants moves to be no longer underneath the primary pointing device. This event type is similar to mouseout, but differs in that does not bubble, and that it MUST NOT be dispatched until the pointing device has left the boundaries of the element and the boundaries of all of its children.
</p>

<div class="trans-note">
<p>【†
すなわち、
~pointing先が変化したとき，
~AND↓ を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
以前の~pointing先か, または その先祖である。
</li>
	<li>
新たな~pointing先でも, その先祖でもない。
</li>
</ul>
<p>
該当する要素が複数~在る場合
（例：新たな~pointing先が ~NULL ならば、
以前の~pointing先と その先祖~要素~すべてが該当する）、
最も子孫のものから順に
（ `mouseenter$et のときとは逆順に），
この~eventを発火することになろう。
】</p>
</div>

<p class="note">注記：
この~event型と~CSSの `~hover_ps 疑似類$ `CSS2$r には、
類似性がある。
`mouseenter$et ~event型も見よ。
◎
Note

There are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseenter event type.
</p>

			</section>
			<section id="mousemove">
<h4>4.4.8. `mousemove^et</h4>

<div>
◎イ型 `mousemove@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`button$m：
0
</li>
</ul>
◎表終

◎
Type 	mousemove
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
`~UA$は、［
`~pointing先$が要素~上で動いた
］とき，その要素に向けて，この~eventを発火するモノトスル。
~pointing装置が動かされる間に~eventが生じる頻度は［
実装／装置／~platform
］に特有であるが、
~~持続的な動きに対しては，動きが止まる度にではなく，複数の `mousemove$et ~eventが連続して発火されるベキである。
実装には、
応答性と処理能との兼ね合いをとる最適な頻度を決定することが奨励される。
◎
A user agent MUST dispatch this event when a pointing device is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive mousemove events SHOULD be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance.
</p>

<p class="note">注記：
~browserなどの一部の実装~環境においては、
`mousemove$et ~eventは，利用者が（~mouse~buttonを押すなどして）~drag操作oを始めてから ~pointing装置が~UAの境界から離れた後も，発火し続け得る。
◎
Note

In some implementation environments, such as a browser, mousemove events can continue to fire if the user began a drag operation (e.g., a mouse button is pressed) and the pointing device has left the boundary of the user agent.
</p>

<p class="note" id="mousemove-now-cancelable">注記：
この~eventは、
以前は DOM Level 2 Events においては取消~可能でないものと指定されていたが，
既存の~UA間の相互運用能を反映するよう変更された。
◎
Note

This event was formerly specified to be non-cancelable in DOM Level 2 Events, but was changed to reflect existing interoperability between user agents.
</p>

			</section>
			<section id="mouseout">
<h4>4.4.9. `mouseout^et</h4>

<div>
◎イ型 `mouseout@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
以前の`~pointing先$
</li>
	<li>
`button$m：
0
</li>
	<li>
`relatedTarget$m：
新たな`~pointing先$
</li>
</ul>
◎表終

◎
Type 	mouseout
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the target | a pointing device is entering, if any.
</div>

<p>
`~UA$は、
`~pointing先$が`有効に変化-$したとき，以前の`~pointing先$が要素であるならば、
この~eventをその要素に向けて発火するモノトスル。
この~event型は， `mouseleave$et に類似するが、
浮上すること, および［
新たな`~pointing先$が要素の子孫であっても、
要素に向けて発火するモノトスル
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element or when the element is moved to be no longer underneath the primary pointing device. This event type is similar to mouseleave, but differs in that does bubble, and that it MUST be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.
</p>

<p class="note">注記：
`mouseover$et ~event型も見よ。
◎
Note

See also the mouseover event type.
</p>

			</section>
			<section id="mouseover">
<h4>4.4.10. `mouseover^et</h4>

<div>
◎イ型 `mouseover@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`button$m：
0
</li>
	<li>
`relatedTarget$m：
以前の`~pointing先$
【原文では `mouseout$et と同じ “新たな~pointing先” を示唆しているが、誤りであろう。】
【！issue #307】
</li>
</ul>
◎表終

◎
Type 	mouseover
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : 0
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the target | a pointing device is entering, if any.
</div>

<p>
`~UA$は、
`~pointing先$が`有効に変化-$したとき，新たな`~pointing先$が要素であるならば、
この~eventを当の要素に向けて発火するモノトスル。
この~event型は， `mouseenter$et に類似するが、
浮上すること, および［
以前の`~pointing先$が要素の子孫であっても、
要素に向けて発火するモノトスル
］点で相違する。
◎
A user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or when the element is moved to be underneath the primary pointing device. This event type is similar to mouseenter, but differs in that it bubbles, and that it MUST be dispatched when the pointer device moves onto the boundaries of an element whose ancestor element is the target for the same event listener instance.
</p>

<p class="note">注記：
`mouseout$et ~event型も見よ。
◎
Note

See also the mouseout event type.
</p>

			</section>
			<section id="mouseup">
<h4>4.4.11. `mouseup^et</h4>

<div>
◎イ型 `mouseup@et
◎界面 `MouseEvent$I
◎同期 あり
◎浮上 する
◎標的 `Element$I
◎取消 可
◎構 Yes
◎既定動作 なし
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`detail$m：
( `現在の~click回数$ + 1 )
を指示する
</li>
</ul>
◎表終

◎
Type 	mouseup
Interface 	MouseEvent
Sync / Async 	Sync
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Yes
Composed 	Yes
Default action 	None
Context
(trusted events) 	

• Event.target : topmost event target
• UIEvent.view : Window
• UIEvent.detail : indicates the current click count incremented by one.
• MouseEvent.screenX : value based on the pointer position on the screen
• MouseEvent.screenY : value based on the pointer position on the screen
• MouseEvent.clientX : value based on the pointer position within the viewport
• MouseEvent.clientY : value based on the pointer position within the viewport
• MouseEvent.layerX : value based on the pointer position within the containing element
• MouseEvent.layerY : value based on the pointer position within the containing element
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : value based on current button pressed
• MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : null
</div>

<p>
`~UA$は、［
~pointing装置の~buttonが要素~上で離された
］とき，この~eventを発火するモノトスル。
◎
A user agent MUST dispatch this event when a pointing device button is released over an element.
</p>

<p class="note">注記：
~browserなど，実装~環境によっては、
`mouseup$et ~eventは，~pointing装置が~UAの境界から出たときにも発火され得る。
例： 利用者が~mouse~buttonを押して~drag操作oを始めたときなど。
◎
Note

In some implementation environments, such as a browser, a mouseup event can be dispatched even if the pointing device has left the boundary of the user agent, e.g., if the user began a drag operation with a mouse button pressed.
</p>

			</section>
			<section id="_common-mouse-event-context">
<h4>4.4.X. 各種~mouse~eventに共通な文脈~情報</h4>

<p class="trans-note">【
この訳では、
各所に共通な記述をこの節に集約する。
】</p>

<p>
多くの~mouse~eventに共通な文脈~情報を以下に挙げる。
個々の~event型にて定義されるものは、
これらより優先される：
</p>

<dl>
	<dt>`target$m</dt>
	<dd>
`最上層な~event~target$
◎
Event.target : topmost event target
</dd>

	<dt>`UIEvent$I の各~属性：</dt>
	<dd>
`UIEVENTS$r `§ 各種~UI~eventに共通な文脈~情報＠~UIEVENTS#_common-UI-event-context$を見よ。
</dd>

	<dt>`MouseEvent$I ：</dt>
	<dd>
		<dl>
			<dt>`screenX$m</dt>
			<dd>
~screen上の~pointer位置に基づく値
◎
MouseEvent.screenX : value based on the pointer position on the screen
</dd>

			<dt>`screenY$m</dt>
			<dd>
~screen上の~pointer位置に基づく値
◎
MouseEvent.screenY : value based on the pointer position on the screen
</dd>

			<dt>`clientX$m</dt>
			<dd>
`表示域$の中の~pointer位置に基づく値
◎
MouseEvent.clientX : value based on the pointer position within the viewport
</dd>

			<dt>`clientY$m</dt>
			<dd>
`表示域$の中の~pointer位置に基づく値
◎
MouseEvent.clientY : value based on the pointer position within the viewport
</dd>

			<dt>`layerX$m</dt>
			<dd>
包含している要素の中の~pointer位置に基づく値
◎
MouseEvent.layerX : value based on the pointer position within the containing element
</dd>

			<dt>`layerY$m</dt>
			<dd>
包含している要素の中の~pointer位置に基づく値
◎
MouseEvent.layerY : value based on the pointer position within the containing element
</dd>

			<dt>`altKey$m</dt>
			<dd>
`Alt^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.altKey : true if Alt modifier was active, otherwise false
</dd>

			<dt>`ctrlKey$m</dt>
			<dd>
`Control^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
</dd>

			<dt>`shiftKey$m</dt>
			<dd>
`Shift^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
</dd>

			<dt>`metaKey$m</dt>
			<dd>
`Meta^cap 修飾が作動中であったなら ~T，
~ELSE_ ~F
◎
MouseEvent.metaKey : true if Meta modifier was active, otherwise false
</dd>

			<dt>`button$m</dt>
			<dd>
現在 押されている~buttonに基づく値。
◎
MouseEvent.button : value based on current button pressed
</dd>

			<dt>`buttons$m</dt>
			<dd>
現在の押下げられているすべての~buttonに基づく値。
押された~buttonが無ければ 0 になる。
◎
MouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed
</dd>

			<dt>`relatedTarget$m</dt>
			<dd>
~NULL
◎
MouseEvent.relatedTarget : null
</dd>
		</dl>
	</dd>
</dl>

			</section>
		</section>
	</section>
	<section id="pointer-events-and-interfaces">
<h2 title="Pointer Events and interfaces">5. 各種~pointer~eventと各種~interface</h2>
		<section id="pointerevent-interface">
<h3 title="PointerEvent Interface">5.1. `PointerEvent^I ~interface</h3>

<pre class="idl">
dictionary `PointerEventInit@I : `MouseEventInit$I {
    `long$      `pointerId@mb = 0;
    `double$    `width@mb = 1;
    `double$    `height@mb = 1;
    `float$     `pressure@mb = 0;
    `float$     `tangentialPressure@mb = 0;
    `long$      `tiltX@mb;
    `long$      `tiltY@mb;
    `long$      `twist@mb = 0;
    `double$    `altitudeAngle@mb;
    `double$    `azimuthAngle@mb;
    `DOMString$ `pointerType@mb = "";
    `boolean$   `isPrimary@mb = false;
    `long$      `persistentDeviceId@mb = 0;
    `sequence$&lt;`PointerEvent$I&gt; `coalescedEvents@mb = [];
    `sequence$&lt;`PointerEvent$I&gt; `predictedEvents@mb = [];
};

[`Exposed$=Window]
interface `PointerEvent@I : `MouseEvent$I {
    `constructor$(`DOMString$ %type, optional `PointerEventInit$I %eventInitDict = {});
    readonly attribute `long$      `pointerId$m;
    readonly attribute `double$    `width$m;
    readonly attribute `double$    `height$m;
    readonly attribute `float$     `pressure$m;
    readonly attribute `float$     `tangentialPressure$m;
    readonly attribute `long$      `tiltX$m;
    readonly attribute `long$      `tiltY$m;
    readonly attribute `long$      `twist$m;
    readonly attribute `double$    `altitudeAngle$m;
    readonly attribute `double$    `azimuthAngle$m;
    readonly attribute `DOMString$ `pointerType$m;
    readonly attribute `boolean$   `isPrimary$m;
    readonly attribute `long$      `persistentDeviceId$m;
    [`SecureContext$] sequence&lt;`PointerEvent$I&gt; `getCoalescedEvents()$m;
    sequence&lt;`PointerEvent$I&gt; `getPredictedEvents()$m;
};
</pre>

<dl class="idl-def">
	<dt>`pointerId@m</dt>
	<dd>
~eventを生じさせた~pointerを一意に識別する識別子
— 以下、
ここでは，単に~IDと称する。
◎
A unique identifier for the pointer causing the event.＼
</dd>
	<dd>
~UAは、
値［
0 または 1
］を［
~mouseによる`首~pointer$用の汎用な~ID
］用に予約してもヨイ。
◎
user agents MAY reserve a generic pointerId value of 0 or 1 for the primary mouse pointer.＼
</dd>
	<dd>
~ID用の値 −1 は、［
当の~eventは，~pointing装置~以外の何かから生成されたこと
］を指示するものとして，［
予約され，利用する
］モノトスル。
◎
The pointerId value of -1 MUST be reserved and used to indicate events that were generated by something other than a pointing device.＼
</dd>
	<dd>
他の~pointer用には、
~UAは，~IDをアテガうための［
策／~approach
］として何を実装してもかまわない。
ただし，~IDは、
所与の`~top-level閲覧~文脈$ `HTML$r において［
すべての`作動中な~pointer$にわたって一意になる
］かつ［
他の`~top-level閲覧~文脈$から波及されない
］ようにするモノトスル
（すなわち、
ある~pointerが［
ある~top-level閲覧~文脈から別の~top-level閲覧~文脈の中へ移動した
］とき，［
当の~pointerの `pointerId$m が両~閲覧~文脈において同じになる
］ものとは見做せない）。
◎
For any other pointers, user agents are free to implement different strategies and approaches in how they assign a pointerId value. However, all active pointers in the top-level browsing context (as defined by [HTML]) must be unique, and the identifier MUST NOT be influenced by any other top-level browsing context (i.e. one top-level browsing context cannot assume that the pointerId of a pointer will be the same when the pointer moves outside of the browsing context and into another top-level browsing context).
</dd>
	<dd>
~UAは、［
以前に`作動中$であった~pointer用の退役した~ID
］を使い回してもヨイ
— あるいは、［
特定0の~pointing装置~用には，常に同じ~IDを再利用する
］ことにしてもヨイ
（一例として、
多人数協同~appにおいて，
特定の利用者による特定0の装置からの入力を一意に識別するため）。
しかしながら，後者の事例では、［
異なる~pageや~domainにまたがる指紋収集や追跡
］の機会cを最小化するため、
当の［
~page／~session
］が存続する限り，当の~IDを当の装置のみに明示的に結付けるモノトスル
— 次回に，当の装置が新たな~sessionにて再び利用されたときは、
新たな~IDを~randomに選ぶモノトスル。
◎
The user agent MAY recycle previously retired values for pointerId from previous active pointers, or it MAY always reuse the same pointerId for a particular pointing device (for instance, to uniquely identify particular pen/stylus inputs from a specific user in a multi-user collaborative application). However, in the latter case, to minimize the chance of fingerprinting and tracking across different pages or domains, the pointerId MUST only be associated explicitly with that particular pointing device for the lifetime of the page / session, and a new randomized pointerId MUST be chosen the next time that particular pointing device is used again in a new session.
</dd>
	<dd class="note">注記：
~IDの選定~algoは、
実装に特有である
— 作者は、
~IDを［
上の意味で一意であること以外の意味を伝達するもの
］とは見做せない。
例として、
~UAは，単純に［
どの~pointerにも，作動中になった順に 0 から開始する数をアテガう
］こともあろうが、
これらの値が単調増加することは保証されない。
特定0の~pointing装置~用に同じ~IDを再利用するか否かは，個々の実装に委ねられるので、
作者が~IDに依拠することは，強く忌避される
— 代わりに `persistentDeviceId$m を参照rすること。
◎
Note
The pointerId selection algorithm is implementation specific. Authors cannot assume values convey any particular meaning other than an identifier for the pointer that is unique from all other active pointers. As an example, user agents may simply assign a number, starting from 0, to any active pointers, in the order that they become active — but these values are not guaranteed to be monotonically increasing. As the reuse of the same pointerId for a particular pointing device is left up to individual implementations, authors are strongly discouraged from relying on it, and to refer to persistentDeviceId instead.
</dd>

	<dt>`width@m</dt>
	<dt>`height@m</dt>
	<dd>
順に、
~pointerの`接触~幾何$の［
横幅, 縦幅
］（ X, Y 軸~上の大きさ）を~CSS~pixel数（ `CSS21$r ）で表す。
この値は、
所与の~pointer用の各~eventごとに更新されてもヨイ。
［
概して`接触~幾何$を欠く入力（伝統的な~mouseなど） ／
実際の幾何が~hardwareにより検出されない入力
］に対しては、
既定の値として 1 を返すモノトスル。
◎
The width (magnitude on the X axis), in CSS pixels (see [CSS21]), of the contact geometry of the pointer. This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the user agent MUST return a default value of 1.
◎
The height (magnitude on the Y axis), in CSS pixels (see [CSS21]), of the contact geometry of the pointer. This value MAY be updated on each event for a given pointer. For inputs that typically lack contact geometry (such as a traditional mouse), and in cases where the actual geometry of the input is not detected by the hardware, the user agent MUST return a default value of 1.
</dd>

	<dt>`pressure@m</dt>
	<dd>
~pointer入力による押圧
— 値の範囲は、［
0 以上, 1 以下
］に正規化される。
値［
0 ／ 1
］は、
~hardwareが検出できる［
最小／最大
］の押圧を表現する。
~hardwareや~platformが押圧を~supportしないときの値は、［
~buttonが`作動~状態$にあるなら 0.5 ／
~ELSE_ 0
］を返すモノトスル。
◎
The normalized pressure of the pointer input in the range of [0,1], where 0 and 1 represent the minimum and maximum pressure the hardware is capable of detecting, respectively. For hardware and platforms that do not support pressure, the value MUST be 0.5 when in the active buttons state and 0 otherwise.
</dd>

	<dt>`tangentialPressure@m</dt>
	<dd>
~pointer入力の接線方向~圧†（ ~barrel圧としても周知）
— 値の範囲は、［
−1 以上, 1 以下
］に正規化される。
概して，追加的な制御により設定される（例： ~airbrush~stylusの手指~wheelなど）。
値 0 は、
中立な位置を指す。
~hardwareによっては，範囲［
0 以上, 1 以下
］に入る正な値しか~supportしないものもあることに注意。
~hardwareや~platformが接線方向~圧を~supportしないときは、
0 を返すモノトスル。
◎
The normalized tangential pressure (also known as barrel pressure), typically set by an additional control (e.g. a finger wheel on an airbrush stylus), of the pointer input in the range of [-1,1], where 0 is the neutral position of the control. Note that some hardware may only support positive values in the range of [0,1]. For hardware and platforms that do not support tangential pressure, the value MUST be 0.
</dd>
	<dd class="trans-note">【†
接線方向~圧（ `tangential pressure^en ） —
おそらく，~pen等をひねるときの力。
~barrel（“樽”）の周に沿う，接線~方向。
】</dd>
	<dd class="note">注記：
その名前にかかわらず、
実施においては，
この~prop用の値を生成する~hardware［
~control／~sensor
］は、
圧に敏感とは限らない。
例として、
ほとんどの事例では，ほとんどの［
~airbrush／塗ng
］~stylus上の手指~wheel用の実装では，【この~propが返す値を】自由に設定できる
— それが 0 を返すのを防止するために，~wheelに一定な圧を適用するよう利用者に要求しないよう。
◎
Despite the property's name, in practice the hardware controls/sensors that generate the values for this property may not necessarily be pressure sensitive. As an example, in most cases the finger wheel on most airbrush/painting stylus implementations can be freely set, rather than requiring the user to apply a constant pressure on the wheel to prevent it from returning to the zero position.
</dd>

	<dt>`tiltX@m</dt>
	<dd>
［
`~digitizer$が成す Y-Z 平面
］と［
~transducer（例：~penや~stylus）軸と Y 軸を包含する平面
］が成す角度。
値の範囲は［
−90° 以上, 90° 以下
］。
正な `tiltX$m は、
X 値が増大する方向
— ~transducer軸が右に傾いていること —
を表す。
絶対~値が大きいほど，~transducer軸が~digitizer面の法線から離れていることを表す。
◎
The plane angle (in degrees, in the range of [-90,90]) between the Y-Z plane and the plane containing both the transducer (e.g. pen/stylus) axis and the Y axis. A positive tiltX is to the right, in the direction of increasing X values. tiltX can be used along with tiltY to represent the tilt away from the normal of a transducer with the digitizer.＼
</dd>
	<dd>
~hardwareや~platformが［
傾き／角度
］を報告しないときの値は、
0 になるモノトスル。
◎
For hardware and platforms that do not report tilt or angle, the value MUST be 0.
</dd>
	<dd class="trans-note">【
~target要素に対する変形（回転など）が
X, Y 軸の解釈に影響し得るのか, どう影響するのかについては、
この仕様には述べられていない。
】</dd>

	<dd>
<figure id="figure_tiltX">
<p class="alt" hidden id="_dgm-tiltX">
`tiltX^m を説明する図式
◎
tiltX explanation diagram
</p>
<figcaption>
正な `tiltX$m 。
◎
Figure 3＼
Positive tiltX.
</figcaption></figure></dd>

	<dt>`tiltY@m</dt>
	<dd>
［
`~digitizer$が成す Y-Z 平面
］と［
~transducer（例：~penや~stylus）軸と X 軸を包含する平面
］が成す角度。
値の範囲は［
−90° 以上, 90° 以下
］。
正な `tiltY$m は、
Y 値が増大する方向
— ~transducer軸が利用者~側に傾いていること —
を表す。
絶対~値が大きいほど，~transducer軸が~digitizer面の法線から離れていることを表す。
◎
The plane angle (in degrees, in the range of [-90,90]) between the X-Z plane and the plane containing both the transducer (e.g. pen/stylus) axis and the X axis. A positive tiltY is towards the user, in the direction of increasing Y values. tiltY can be used along with tiltX to represent the tilt away from the normal of a transducer with the digitizer.＼
</dd>
	<dd>
~hardwareや~platformが［
傾き／角度
］を報告しないときの値は、
0 になるモノトスル。
◎
For hardware and platforms that do not report tilt or angle, the value MUST be 0.
</dd>
	<dd>
<figure id="figure_tiltY">
<p class="alt" hidden id="_dgm-tiltY">
`tiltY^m を説明する図式
◎
tiltY explanation diagram
</p>
<figcaption>
正な `tiltY$m 。
◎
Figure 4＼
Positive tiltY.
</figcaption></figure></dd>

	<dt>`twist@m</dt>
	<dd>
~transducer（例：~penや~stylus）自身の~~主~軸~周りにおける，時計回りによる回転~角度
— 値の範囲は、［
0° 以上, 359° 以下
］。
◎
The clockwise rotation (in degrees, in the range of [0,359]) of a transducer (e.g. pen/stylus) around its own major axis.＼
</dd>
	<dd>
~hardwareや~platformが~twist【ひねり？】を報告しないときの値は、
0 になるモノトスル。
◎
For hardware and platforms that do not report twist, the value MUST be 0.
</dd>

	<dt>`altitudeAngle@m</dt>
	<dd>
~transducer（例：~penや~stylus）の仰角
— 値の範囲は、
~radianで［
0 以上, π/2 以下
］。
0 は物理面（~X-Y平面）に平行, π/2 は物理面に垂直なことを表す。
~hardwareや~platformが［
傾き／角度
］を報告しないときの値は、
π/2 になるモノトスル。
◎
The altitude (in radians) of the transducer (e.g. pen/stylus), in the range [0,π/2] — where 0 is parallel to the surface (X-Y plane), and π/2 is perpendicular to the surface. For hardware and platforms that do not report tilt or angle, the value MUST be π/2.
</dd>
	<dd class="note">注記：
`altitudeAngle^m 用に ここで定義される既定の値は、
π/2 であり，~transducerの位置が物理面に垂直であることを表す。
これは、
`Touch Events ~level 2＠~TOUCHEVENTS$cite 仕様が，その
`altitudeAngle＠~TOUCHEVENTS#dom-touch-altitudeangle$m
用に定義する既定の値 0 と相違する。
◎
Note
The default value defined here for altitudeAngle is π/2, which positions the transducer as being perpendicular to the surface. This differs from the Touch Events - Level 2 specification's definition for the altitudeAngle property, which has a default value of 0.
</dd>
	<dd>
<figure id="figure_altitudeAngle">
<p class="alt" hidden id="_dgm-altitudeAngle">
`altitudeAngle^m を説明する図式
◎
altitudeAngle explanation diagram
</p>
<figcaption>
`altitudeAngle^m が π/4 をとるとき（~X-Y平面から 45° ）。
◎
Figure 5＼
Example altitudeAngle of π/4 (45 degrees from the X-Y plane).
</figcaption></figure></dd>

	<dt>`azimuthAngle@m</dt>
	<dd>
~transducer（例：~penや~stylus）の方位角
— 値の範囲は、
~radianで［
0 以上, π/2 以下
］。
値 0 は，~transducerの頭頂が~X-Y平面~上で正な~X軸~方向（真上から見て “3時” の方向）を指していることを表現し、
そこから時計回りに増大する
（ π/2 なら “6時”, π なら “9時”, 3π/2 なら “12時” を指している）。
~transducerが物理面に垂直になったとき（ `altitudeAngle$m ~EQ π/2 ）の値は、
0 になるモノトスル。
~hardwareや~platformが［
傾き／角度
］を報告しないときの値は、
0 になるモノトスル。
◎
The azimuth angle (in radians) of the transducer (e.g. pen/stylus), in the range [0, 2π] — where 0 represents a transducer whose cap is pointing in the direction of increasing X values (point to "3 o'clock" if looking straight down) on the X-Y plane, and the values progressively increase when going clockwise (π/2 at "6 o'clock", π at "9 o'clock", 3π/2 at "12 o'clock"). When the transducer is perfectly perpendicular to the surface (altitudeAngle of π/2), the value MUST be 0. For hardware and platforms that do not report tilt or angle, the value MUST be 0.
</dd>
	<dd>
<figure id="figure_azimuthAngle">
<p class="alt" hidden id="_dgm-azimuthAngle">
`azimuthAngle^m を説明する図式
◎
azimuthAngle explanation diagram
</p>
<figcaption>
`azimuthAngle^m が π/6 をとるとき（ “4 時” を指す ）。
◎
Figure 6＼
Example azimuthAngle of π/6 ("4 o'clock").
</figcaption></figure></dd>

	<dt>`pointerType@m</dt>
	<dd>
<p>
~eventを生じさせた装置の型
（~mouse, ~pen, ~touch, など）
を指示する。
~UAは，［
~mouse ／ ~penや~stylus ／ ~touch入力~装置
］用に`~pointer~eventを発火する$ときは、
その `pointerType$m の値を，
次の表tに則って~~初期化するモノトスル：
◎
Indicates the device type that caused the event (such as mouse, pen, touch). If the user agent is to fire a pointer event for a mouse, pen/stylus, or touch input device, then the value of pointerType MUST be according to the following table:
</p>

<div>
<table id="pointer-type-table"><thead>
<tr><th>~pointer装置の型
<th>`pointerType$m 値
<tbody>

<tr><td>~mouse
<td>`mouse^l

<tr><td>~pen／~stylus
<td>`pen^l

<tr><td>~touch接触
<td>`touch^l
</table>

◎
Pointer Device Type	pointerType Value
Mouse	mouse
Pen / stylus	pen
Touch contact	touch
</div>
	</dd>
	<dd>
~UAが検出できない型の装置~用の値は、
空~文字列になるモノトスル。
上に挙げたもの以外の，~UAが~supportする型の~pointer装置~用の `pointerType$m 値は、
異なる型の装置~間で名前が競合しないよう，~vendor接頭辞が~~付与されるベキである。
将来の仕様は、
他の型の装置~用に規範的な値を追加し得る。
◎
If the device type cannot be detected by the user agent, then the value MUST be an empty string. If the user agent supports pointer device types other than those listed above, the value of pointerType SHOULD be vendor prefixed to avoid conflicting names for different types of devices. Future specifications MAY provide additional normative values for other device types.
</dd>
	<dd class="trans-note">【
~penも~stylusも，~penのように手で持って~~扱う装置であるが
（ `stylus^en は `stylus pen ^en の略称でもある）、
一般に，機能が簡素なものは “~stylus”, より豊富なものは “~pen” と`称されるようだ＠https://en.wikipedia.org/wiki/Active_pen$
（~stylusには、座標しか供さないものもあろう）。
~touchは、
そのような装置を介さない，手指による入力。
】</dd>
	<dd class="note">注記：
`利用者による入力を検出する例＠#_detecting-input-type$【！Example 2】に、
`pointerType$m の基本的な利用-法のデモがある。
開発者は、
何らかの形で既定の取扱いを含めるべきであることに注意
— 自前の~customな `pointerType$m 値を実装している~UAや,
`pointerType$m が単に空~文字列である状況に対応するために。
◎
Note
See Example 2 for a basic demonstration of how the pointerType can be used. Also note that developers should include some form of default handling to cover user agents that may have implemented their own custom pointerType values and for situations where pointerType is simply an empty string.
</dd>
	<dd class="trans-note">【
この仕様では、
同じ型の装置が複数~在る状況は~~想定されていない
— 特に，`~mouse~eventは防止するか$の扱いに関して。
複数の~mouseについては、
`一つの装置に統合する＠#multiple-mouse-inputs$ものとみなしている。
~mouse以外については、
そのような状況に関して何も言及されていないが。
】</dd>

	<dt>`isPrimary@m</dt>
	<dd>
~pointerがこの`~pointer型$の`首~pointer$を表現するかどうかを指示する。
◎
Indicates if the pointer represents the primary pointer of this pointer type.
</dd>

	<dt>`persistentDeviceId@m</dt>
	<dd>
~pointing装置~用の一意な識別子【を与える整数】
— 以下、
ここでは，単に~ID【！ persistentDeviceId 】と称する。
◎
A unique identifier for the pointing device.＼
</dd>
	<dd>
当の~hardwareは複数の~pointerを~supportする場合†、
同じ~pointing装置から生成された~pointer~eventは
— それらの~pointerが~sessionを通して一意に識別-可能ならば†† —
一つの~IDに限り取得するモノトスル。
当の~pointerが一意に識別-可能になって以降は††、
その~pointing装置へアテガわれる~IDは，
当の~sessionを通して一定であり続けることになる。
◎
If the hardware supports multiple pointers, pointer events generated from pointing devices MUST only get a persistentDeviceId if those pointers are uniquely identifiable over the session. If the pointer is uniquely identifiable, the assigned persistentDeviceId to that pointing device will remain constant for the remainder of the session.＼
</dd>
	<dd class="trans-note">【†
同じ`~digitizer$を複数の~pointing装置が共有する状況
（例：
用途が異なる複数の~pen（あるいは交換-可能な~pen先）を利用している，など）
が~~想定されていると思われる。
】【††
下の注記を見よ。
】【
原文からは明瞭でないが、
同じ~pointing装置を複数の`~digitizer$で利用している場合も含めて，それら［
`~digitizer$, ~pointing装置
］の組合nごとに異なる~IDになろう。
】【
参考：
`この属性についての説明書き＠https://github.com/WICG/pointer-event-extensions/blob/main/pointer-event-device-id-explainer.md$
】</dd>
	<dd>
~ID用の値 0 は、［
当の~eventを生成している装置を識別できなかったこと
］を指示するものとして［
予約され, 利用する
］モノトスル。
◎
The persistentDeviceId value of 0 MUST be reserved and used to indicate events whose generating device could not be identified.＼
</dd>
	<dd>
`pointerId$m と同様に，［
異なる~pageや~domainにまたがる指紋収集や追跡
］の機会cを最小化するため、
当の［
~page／~session
］が存続する限り，この~IDを当の装置のみに明示的に結付けるモノトスル
— 次回に，当の装置が新たな~sessionにて再び利用されたときは、
新たな~IDを~randomに選ぶモノトスル。
◎
Like pointerId, to minimize the chance of fingerprinting and tracking across different pages or domains, the persistentDeviceId MUST only be associated explicitly with that particular pointing device for the lifetime of the page / session, and a new randomized persistentDeviceId MUST be chosen the next time that particular pointing device is used again in a new session.
</dd>
	<dd class="note">注記：
［
`~digitizer$／~pointing装置
］~hardwareの拘束に因り、［
~IDが，ある~pointing装置から生成される すべての~pointer~event用に可用になる
］ことは保証されない。
例えば、
当の装置は［
`pointerdown$et† が 0 でない~IDを有する
］よう［
その~hardware~IDを~digitizerへ報告する
］とは限らない。
そのような事例では、
`persistentDeviceId^m は，初期~時は 0 であっても妥当な値へ変化する†。
◎
Due to digitizer and pointing device hardware constraints, a persistentDeviceId is not guaranteed to be available for all pointer events from a pointing device. For example, the device may not report its hardware id to the digitizer in time for pointerdown to have a persistentDeviceId. In such a case, the persistentDeviceId may initially be 0 and change to a valid value.
</dd>
	<dd class="trans-note">【†
なぜ `pointerdown^et だけ挙げられているのか，
初期~時だけ~IDを取得できないことの背後に どんな論理があるのか
（および，この 2 つには関連性があるのか）は、
よくわからない。
】</dd>
	<dt>`getCoalescedEvents()@m</dt>
	<dd>
コレの`合体d~event~list$【！合体された~event群】を返す。
◎
A method that returns the list of coalesced events.
</dd>

	<dt>`getPredictedEvents()@m</dt>
	<dd>
コレの`予測d~event~list$【！予測された~event群】を返す。
◎
A method that returns the list of predicted events.
</dd>
</dl>

<p>
`PointerEventInit$I 辞書は、
`PointerEvent$I ~interfaceの構築子に，
`~trusted$でない（合成な）`~pointer~event$を構築する仕組みを供する。
それは、
`UIEVENTS$r にて定義される `MouseEventInit$I 辞書を継承する。
`~trustedでない~pointer~eventを発火する例＠#_untrusted-pointer-events$に，
`~trusted$でない`~pointer~eventを発火する$方法をデモる見本~codeがある。
◎
The PointerEventInit dictionary is used by the PointerEvent interface's constructor to provide a mechanism by which to construct untrusted (synthetic) pointer events. It inherits from the MouseEventInit dictionary defined in [UIEVENTS]. See the examples for sample code demonstrating how to fire an untrusted pointer event.
</p>

<p>
`PointerEvent$I 用の`~event構築-時の手続き$は、
`PointerEventInit$I の［
`coalescedEvents$mb ／ `predictedEvents$mb
］を当の~eventの［
`合体d~event~list$／`予測d~event~list$
］に~cloneする。
◎
The event constructing steps for PointerEvent clones PointerEventInit's coalescedEvents to coalesced events list and clones PointerEventInit's predictedEvents to predicted events list.
</p>

<p class="note">注記：
`PointerEvent$I ~interfaceは、
`UIEVENTS$r に定義される `MouseEvent$I を継承する。
また， `CSSOM-VIEW$r にて提案された拡張は、
種々の座標~propを
— 小数付きな座標を許容するためとして —
`long^c から `double^c 型に変更することに注意。
この提案された拡張を［
`PointerEvent$I 用にはすでに実装したが
定例の `MouseEvent$I 用には実装していない~UA
］に対しては、［
`click$et, `auxclick$et, `contextmenu$et
］~eventに際して，追加的な要件がある。
◎
Note
The PointerEvent interface inherits from MouseEvent, defined in UI Events. Also note the proposed extension in CSSOM View Module, which changes the various coordinate properties from long to double to allow for fractional coordinates. For user agents that already implement this proposed extension for PointerEvent, but not for regular MouseEvent, there are additional requirements when it comes to the click, auxclick, and contextmenu events.
</p>

		<section id="button-states">
<h4 title="Button states">5.1.1. ~button状態</h4>
			<section id="chorded-button-interactions">
<h5 title="Chorded button interactions">5.1.1.1. ~buttonの追加押下げ</h5>

<p>
一部の~pointer装置
— ~mouseや~penなど —
は、
複数の~buttonを~supportする。
`~mouse~event$~model `UIEVENTS$r においては、
どの~buttonが押されたときも［
`mousedown$et, `mouseup$et
］~eventが生産される。
この~hardware相違を より良く抽象-化して，入力に対する装置に依らない著作を単純~化するため、`~pointer~event$においては，
`~buttonの追加押下げ@
（ `chorded button press^en ）
— ~pointer装置の別の~buttonがすでに押下されている間に，追加的な~buttonを押下すること —
に対し［
`pointerdown$et, `pointerup$et
］~eventが重ねて発火されることはない†。
◎
Some pointer devices, such as mouse or pen, support multiple buttons. In the [UIEVENTS] Mouse Event model, each button press produces a mousedown and mouseup event. To better abstract this hardware difference and simplify cross-device input authoring, Pointer Events do not fire overlapping pointerdown and pointerup events for chorded button presses (depressing an additional button while another button on the pointer device is already depressed).
</p>

<p class="trans-note">【†
~button A, B をこの順に押して，同じ順に離した場合、
`pointerup$et は，最後に B を離したときに呼応して発火される？
それとも A を離したときに発火される？
】</p>

<p>
~buttonの追加押下げは、［
`button$m, `buttons$m
］属性の変化を検分すれば検出できる†。
これらの属性は `MouseEvent$I ~interfaceから継承されるが、
意味論と値には，次~節~以下に要旨する変更が加えられている。
◎
Instead, chorded button presses can be detected by inspecting changes to the button and buttons properties. The button and buttons properties are inherited from the MouseEvent interface, but with a change in semantics and values, as outlined in the following sections.
</p>

<p class="trans-note">【†
追加押下げに対しては、
少なくとも，何らかの（ `pointerdown$et, `pointerup$et 以外の）~pointer~eventが発火される。
`pointermove$et を見よ。
】</p>

<p>
［
`button^m ／ `buttons^m
］属性に対する改変が適用されるのは、
~pointer~eventに限られる。
しかしながら，［
`click$et, `auxclick$et, `contextmenu$et
］~eventの［
`button^m ／ `buttons^m
］の値は、
`互換性~mouse~event$の事例と同じく，
`§ ~mouse~event＠#mouse-events$【！`UIEVENTS$r】
に従うモノトスル。
◎
The modifications to the button and buttons properties apply only to pointer events. However for click, auxclick and contextmenu the value of button and buttons MUST follow [UIEVENTS], as is the case for compatibility mouse events .
</p>

			</section>
			<section id="the-button-property">
<h5 title="The button property">5.1.1.2. `button^m 属性</h5>

<p>
~pointer~eventにおける~button状態の
（単なる `pointerdown$et, `pointerup$et を超える）
遷移を識別するため、
`button$m 属性は，
状態~変化により~eventを発火させた装置~buttonを指示する。
◎
To identify button state transitions in any pointer event (and not just pointerdown and pointerup), the button property indicates the device button whose state change fired the event.
</p>

<table><thead>
<tr><th>
装置の~button変化
◎
Device Button Changes
<th>`button^m
<tbody>

<tr><td>
前回の~eventから，どの~buttonも, どの~touch／~pen接触も変化していない
◎
Neither buttons nor touch/pen contact changed since last event
<td>−1

<tr><td>
~mouseの左~buttonが押されている ／
~touch接触がある ／
~pen接触がある
◎
Left Mouse,
Touch contact,
Pen contact
<td>0

<tr><td>
~mouseの中央~buttonが押されている
◎
Middle Mouse
<td>1

<tr><td>
~mouseの右~buttonが押されている ／
~penの~barrel~buttonが押されている
◎
Right Mouse,
Pen barrel button
<td>2

<tr><td>
~mouseの~X1（ `back^en ）~buttonが押されている
◎
X1 (back) Mouse
<td>3

<tr><td>
~mouseの~X2（ `forward^en ）~buttonが押されている
◎
X2 (forward) Mouse
<td>4

<tr><td>
~penの~eraser~buttonが押されている
◎
Pen eraser button
<td>5
</table>

<p class="note">注記：
~mouse~dragの間、
`pointermove$et ~eventにおける `button^m 属性の値は，
`mousemove$et ~eventから異なることになる。
例えば，右~buttonを押しながら~mouseを動かしている間、
`pointermove$et ~eventの `button^m 値は −1 になる一方で，
`mousemove$et ~eventの `button^m 値は 2 になる。
◎
Note
During a mouse drag, the value of the button property in a pointermove event will be different from that in a mousemove event. For example, while moving the mouse with the right button pressed, the pointermove events will have the button value -1, but the mousemove events will have the button value 2.
</p>

			</section>
			<section id="the-buttons-property">
<h5 title="The buttons property">5.1.1.3. `buttons^m 属性</h5>

<p>
`buttons$m 属性は、
装置の個々の~buttonの現在の状態を~bitmaskとして与える
（ `MouseEvent$I におけるそれと同じだが、
アリな値は拡げられている）。
◎
The buttons property gives the current state of the device buttons as a bitmask (same as in MouseEvent, but with an expanded set of possible values).
</p>

<table><thead>
<tr><th>
装置の現在の~button状態
◎
Current state of device buttons
<th>`buttons^m
<tbody>

<tr><td>
［
~mouse ／
~hoverしている~pen
］は どの~buttonも押されずに動いている
◎
Mouse moved with no buttons pressed,
Pen moved while hovering with no buttons pressed
<td>0

<tr><td>
~mouseの左~buttonが押されている ／
~touch接触がある ／
~pen接触がある
◎
Left Mouse,
Touch contact,
Pen contact
<td>1

<tr><td>
~mouseの中央~buttonが押されている
◎
Middle Mouse
<td>4

<tr><td>
［
~mouseの右~button ／
~penの~barrel~button
］が押されている
◎
Right Mouse,
Pen barrel button
<td>2

<tr><td>
~mouseの~X1（ `back^en ）~buttonが押されている
◎
X1 (back) Mouse
<td>8

<tr><td>
~mouseの~X2（ `forward^en ）~buttonが押されている
◎
X2 (forward) Mouse
<td>16

<tr><td>
~penの~eraser~buttonが押されている
◎
Pen eraser button
<td>32
</table>

			</section>
		</section>
		<section id="the-primary-pointer">
<h4 title="The primary pointer">5.1.2. 首~pointer</h4>

<p>
複-~pointer装置（例：複-~touch）
【複数の装置ではなく，複数の同時並行な接触を~supportする~pointer装置】
に対しては、
`isPrimary$m 属性が，`首~pointer$を識別するために利用される。
各`~pointer型$に対し，
`首~pointer@
（ `primary pointer^en ）
とは、
その型の~pointer用の`作動中な~pointer$たちが成す集合の中で，主導的とされる~pointerである：
◎
In a multi-pointer (e.g. multi-touch) scenario, the isPrimary property is used to identify a master pointer amongst the set of active pointers for each pointer type.
</p>
<ul>
	<li>
どの時点であれ、
`首~pointer$は，各`~pointer型$に対し高々一つまでとする。
◎
At any given time, there can only ever be at most one primary pointer for each pointer type.
</li>
	<li>
特定0の`~pointer型$に対し最初に作動中になる~pointer（例えば 複-~touchによるヤリトリなら，手指による~screenへの最初の~touch）が、
その`~pointer型$の`首~pointer$になる。
◎
The first pointer to become active for a particular pointer type (e.g. the first finger to touch the screen in a multi-touch interaction) becomes the primary pointer for that pointer type.
</li>
	<li>
`首~pointer$のみが`互換性~mouse~event$を生産することになる。
【複数の型の~pointer装置が同時並行に利用されていて】`首~pointer$が複数ある事例では、
各~首~pointerが`互換性~mouse~event$を生産することになる。
◎
Only a primary pointer will produce compatibility mouse events. In the case where there are multiple primary pointers, these pointers will all produce compatibility mouse events.
</li>
</ul>

<p class="note">注記：
作者は、
欲するなら，
首~pointer以外を無視することで単独の~pointerによるヤリトリを達成できる
（しかしながら，下の
`複数の首~pointerについての注記＠#multiple-primary-pointers$
を見よ）。
◎
Note
Authors who desire single-pointer interaction can achieve this by ignoring non-primary pointers (however, see the note below on multiple primary pointers).
</p>

<p class="note" id="multiple-primary-pointers">注記：
複数の型の~pointer装置が同時並行に利用されている場合、
それぞれの~pointer（各`~pointer型$【！pointerType】ごとに一つ）が首と見なされる。
例えば，同時に動いた［
~touch接触と~mouse~cursor
］は、
どちらも首と見なされる~pointerを生産することになる。
◎
Note
When two or more pointer device types are being used concurrently, multiple pointers (one for each pointerType) are considered primary. For example, a touch contact and a mouse cursor moved simultaneously will produce pointers that are both considered primary.
</p>

<p class="note">注記：
~OSや~UAは、
一部の装置に対し
— 偶発的なヤリトリを避けるため —
複数の型の~pointer入力の同時並行な利用を無視することもある。
一例として，［
~touch, ~pen
］両者によるヤリトリを~supportする装置は、
~penが利用-中にある間は
— 利用者が~touchscreen上で手を休めれるよう —
~touch入力を無視することもある（この特能は “`palm rejection^en” 
【 “手のひらが触れても~~無視する” 】
と共通的に称されている）。
現時点では、
作者がこの挙動を抑止することはアリでない。
◎
Note
Some devices, operating systems and user agents may ignore the concurrent use of more than one type of pointer input to avoid accidental interactions. For instance, devices that support both touch and pen interactions may ignore touch inputs while the pen is actively being used, to allow users to rest their hand on the touchscreen while using the pen (a feature commonly referred to as "palm rejection"). Currently, it is not possible for authors to suppress this behavior.
</p>

<p class="note">注記：
~UAが、
どの~pointerも`首~pointer$とされていない下で，
~pointer~eventを発火する可能性もある。
一例として、
特定0の型の`作動中な~pointer$が複数あって（例：複-~touchによるヤリトリ），
`首~pointer$が除去された場合（例：~screenから離された）、
首~pointerは無いことになろう。
また、
`首~pointer$が［
~UAを~targetにしていないものも含む，装置~上で作動中かつ型も同じ~pointerすべて
］を利用して決定される~platformにおいては、
首~pointerが~UAの外側にあって，別の~pointerが~UAの内側を~targetにしている場合、
~UAは，
後者の~pointer用に `isPrimary$m が ~F にされた`~pointer~eventを発火-$し得る。
◎
Note
In some cases, it is possible for the user agent to fire pointer events in which no pointer is marked as a primary pointer. For instance, when there are multiple active pointers of a particular type, like a multi-touch interaction, and the primary pointer is removed (e.g. it leaves the screen), there may end up being no primary pointers. Also on platforms where the primary pointer is determined using all active pointers of the same type on the device (including those targeted at an application other than the user agent), if the first (primary) pointer is outside of the user agent and other (non-primary) pointers targeted inside the user agent, then the user agent may fire pointer events for the other pointers with a value of false for isPrimary.
</p>

<p class="note" id="multiple-mouse-inputs">注記：
現在の~OSや~UAは、
通例的に複数の~mouseによる入力の概念を備えていない。
複数の~mouse装置が在る場合
（一例として、
~trackpadと外部~mouseを備える~laptopなど）、
一般に，それらは一まとめに単独の装置として扱われる
— どの装置による動きも，単独の~mouse~pointerの動きに翻訳され、
異なる~mouse装置で押される~buttonは~~区別されない。
この理由から、
~mouse~pointerは通例的に一つだけあり，それが首~pointerになることになる。
<span class="trans-note">【
したがって、
2 個の~mouseが接続されていて，互いに同種の~button（例：左~button）が［
順に押されてから, 同じ順に離された
］とするとき、［
2 回目に押されたとき, 1 回目に離されたとき
］は，無視されることになろう。
】</span>
◎
Note
Current operating systems and user agents don't usually have a concept of multiple mouse inputs. When more than one mouse device is present (for instance, on a laptop with both a trackpad and an external mouse), all mouse devices are generally treated as a single device — movements on any of the devices are translated to movement of a single mouse pointer, and there is no distinction between button presses on different mouse devices. For this reason, there will usually only be a single mouse pointer, and that pointer will be primary.
</p>

			</section>
			<section id="firing-events-using-the-pointerevent-interface">
<h4 title="Firing events using the PointerEvent interface">5.1.3. `PointerEvent^I ~interfaceを利用する~eventの発火-法</h4>

<div class="algo">
<p>
名前 %e の
`~pointer~eventを発火する@
~algoは：
◎
To fire a pointer event named e means to fire an event named e＼
</p>
<ol>
	<li>
%~pointer ~LET この %~event を生じさせた`作動中な~pointer$
（  で識別されるそれ）
◎
↓</li>
	<li>
【！`~eventを発火する$】
%~event ~LET `~eventを作成する$( `PointerEvent$I )
◎
using PointerEvent＼
</li>
	<li>
%~event の各種~属性を［
`PointerEvent$I ~interface, および
`§ 各種 属性と既定~動作＠#attributes-and-default-actions$
］の定義に従って設定する
【 %~event の `pointerId$m は %~pointer を識別する~IDに設定する】
◎
whose attributes are set as defined in PointerEvent Interface and Attributes and Default Actions.
</li>
	<li>
~IF［
%e ~NIN { `gotpointercapture$et, `lostpointercapture$et, `click$et, `auxclick$et, `contextmenu$et }
］
⇒
`処理待ち~pointer捕捉を処理する$( %~pointer )
◎
If the event is not a gotpointercapture, lostpointercapture, click, auxclick or contextmenu event, run the process pending pointer capture steps for this PointerEvent.
</li>
	<li id="dfn-determine-the-target">
%~target ~LET %~pointer の`捕捉~target$
◎
Determine the target at which the event is fired as follows:
• If the pointer capture target override has been set for the pointer, set the target to pointer capture target override object.
</li>
	<li>
~IF［
%~target ~EQ ~NULL
］
⇒
%~target ~SET `接触判定する$( 【 %~pointer の現在の位置／ %~event の`表示域~座標$ 】 )
◎
• Otherwise, set the target to the object returned by hit test.
</li>
	<li>
~IF［
%e ~IN { `pointerdown$et, `pointermove$et, `pointerup$et }
］
⇒
%~pointer にて`作動中な文書$ ~SET %~target の`~node文書$ `DOM$r
◎
Let targetDocument be target's node document [DOM].
◎
If the event is pointerdown, pointermove, or pointerup, set active document for the event's pointerId to targetDocument.
</li>
	<li>
~IF［
%e ~EQ `pointerdown$et
］~AND［
%~pointer を動かしている装置は、
`直な操作$を~~為すものである
］~AND［
%~target は `Element^I である
］
⇒
`~pointer捕捉を設定する$( %~target, %~pointer )
（ `§ 暗黙的な~pointer捕捉＠#implicit-pointer-capture$に述べられるとおりに）
◎
If the event is pointerdown, the associated device is a direct manipulation device, and the target is an Element, then set pointer capture for this pointerId to the target element as described in implicit pointer capture.
</li>
	<li>
~UAは，`~event順序付けを確保する＠#mouse-event-order$ためとして、
%~event を発火する【次の段で配送する】前に，［
当の~pointing装置は %~pointer の`前回の~target$から %~target 上へ移動した
］かのように~targetを扱うベキである。
%~pointer の`~over~eventは必要か$ ~EQ ~T の場合、
`pointerover$et ~eventが必要になる
【いつ配送するのかは明瞭に述べられていない】
— ~target要素が同じ
【`前回の~target$ ~EQ %~target 】
であった場合でも。
◎
Before firing this event, the user agent SHOULD treat the target as if the pointing device has moved over it from the previousTarget for the purpose of ensuring event ordering [UIEVENTS]. If the needsOverEvent flag is set, a pointerover event is needed even if the target element is the same.
</li>
	<li>
【！`~eventを発火する$】
`~eventを配送する$( %~target, %~event )
◎
Fire the event to the determined target.
</li>
	<li>
%~pointer 【！the given pointer】の`前回の~target$ ~SET %~target【！the determined target】
◎
Save the determined target as the previousTarget for the given pointer,＼
</li>
	<li>
%~pointer の`~over~eventは必要か$ ~SET ~F
◎
and reset the needsOverEvent flag to false.＼
</li>
</ol>

<div>
<p>
この~algoの目的においては：
</p>
<ul>
	<li>
<p>
各`作動中な~pointer$には，次に挙げるものが結付けられる：
</p>
		<ul>
			<li>
<p>
`前回の~target@
（ `previousTarget^en ）
⇒
ε／ある要素
— 初期~時は ε とする。
</p>

<p class="trans-note">【
初期~時の値は、
原文には定義されていない
— ~UIwindowの外を表現すると思われる。
】</p>
			</li>
			<li>
`~over~eventは必要か@
（ `needsOverEvent^en ）
⇒
真偽値
— 初期~時は ~F とする。
</li>
		</ul>
	</li>
	<li>
<p>
これらは、
%~pointer の`前回の~target$が`切断された$ときには，次に従って更新するとする：
</p>
		<ol>
			<li>
%~pointer の`前回の~target$ ~SET 配送している~eventの`~event経路＠~DOM4#event-path$の中で`前回の~target$から【`接続されて$いたときの】`親＠~DOM4#get-the-parent$を順に追っていって，まだ`接続されて$いる最初のもの
`DOM$r
</li>
			<li>
%~pointer の`~over~eventは必要か$ ~SET ~T
</li>
		</ol>
<p class="trans-note">【
`前回の~target$が影響する箇所は，
上で %~event を配送する直前の段なので、
`接続されて$いるか否かの検査は，その前のどこかで行われることになろう。
】</p>
	</li>
</ul>
◎
If the previousTarget at any point will no longer be connected [DOM], update the previousTarget to the nearest still connected [DOM] parent following the event path corresponding to dispatching events to the previousTarget, and set the needsOverEvent flag to true.
</div>
</div>

<p class="note">注記：
通常の`~pointing先$に代えて`捕捉~target$を利用することは、
この仕様【！`UIEVENTS$r 】に定義されるとおり，
何らかの`境界~event$を発火する結果になり得る。
これは、
~pointerが それまでの~targetから出て【 `pointerleave$et 】，
この新たな［
それを`捕捉している~target$
］に入った【 `pointerenter$et 】場合と同じになる。
捕捉が解放されたときにも
— ~pointerが、
それを`捕捉している~target$から出て，接触判定による~targetに入るに伴い —
同じことが起こり得る。
◎
Note
Using the pointer capture target override as the target instead of the normal hit-test result may fire some boundary events, as defined by [UIEVENTS]. This is the same as the pointer leaving its previous target and entering this new capturing target. When the capture is released, the same scenario may happen, as the pointer is leaving the capturing target and entering the hit-test target.
</p>

				<section id="attributes-and-default-actions">
<h5 title="Attributes and default actions">5.1.3.1. 各種 属性と既定~動作</h5>

<p>
この仕様にて定義される各種~event型~用の
`bubbles$m, `cancelable$m ~prop
および 既定~動作を，次の表tに示す。
これらの各~event型の詳細は、
`§ 各種 ~pointer~event型＠#pointer-event-types$
にて供される：
◎
The bubbles and cancelable properties and the default actions for the event types defined in this specification appear in the following table. Details of each of these event types are provided in Pointer Event types.
</p>

<div>
<table class="grid-table" id="pointer-event-type-table"><thead>
<tr><th>~event型
<th>`浮上-$？
<th>`取消~可$？
<th>`既定~動作$
<tbody>

<tr><td>`pointerover$et
<td>する
<td>可
<td>なし

<tr><td>`pointerenter$et
<td>しない
<td>不可
<td>なし

<tr><td>`pointerdown$et
<td>する
<td>可 (2)
<td>`mousedown$et と同じ (1)

<tr><td>`pointermove$et
<td>する
<td>可
<td>`mousemove$et と同じ (1)

<tr><td>`pointerrawupdate$et
<td>する
<td>不可
<td>なし

<tr><td>`pointerup$et
<td>する
<td>可
<td>`mouseup$et と同じ (1)

<tr><td>`pointercancel$et
<td>する
<td>不可
<td>なし

<tr><td>`pointerout$et
<td>する
<td>可
<td>なし

<tr><td>`pointerleave$et
<td>しない
<td>不可
<td>なし

<tr><td>`gotpointercapture$et
<td>する
<td>不可
<td>なし

<tr><td>`lostpointercapture$et
<td>する
<td>不可
<td>なし
</table>

<p>
上の表tにおける (1), (2) は：
</p>
<ul>
	<li>
<p>(1)
`既定~動作$が生じるのは，`首~pointer$に限られ、
対応する`~mouse~event$に対するとき同様に，文脈に依存する
— 文脈に応じて適切な既定~動作が行われることになる。
</p>

<p class="trans-note">【
とは言え、
挙げられた`~mouse~event$のうち［
`mousemove$et, `mouseup$et
］は，
既定~動作 “なし” として定義されている。
】</p>

	</li>
	<li>(2)
`pointerdown$et を取消した場合、
この~eventの `pointerType$m 用の後続な`互換性~mouse~event$の発火も防止される。
</li>
</ul>

◎
Event Type｜Bubbles｜Cancelable｜Default Action
pointerover ｜Yes ｜Yes ｜None
pointerenter ｜No ｜No ｜None
pointerdown ｜Yes ｜Yes ｜Varies: when the pointer is primary, all default actions of the mousedown event
Canceling this event also prevents subsequent firing of compatibility mouse events.
pointermove ｜Yes ｜Yes ｜Varies: when the pointer is primary, all default actions of mousemove
pointerrawupdate ｜Yes ｜No ｜None
pointerup ｜Yes ｜Yes ｜Varies: when the pointer is primary, all default actions of mouseup
pointercancel ｜Yes ｜No ｜None
pointerout ｜Yes ｜Yes ｜None
pointerleave ｜No ｜No ｜None
gotpointercapture ｜Yes ｜No ｜None
lostpointercapture ｜Yes ｜No ｜None
</div>

<p>
表示域の操作（~pan-zoom）
— 一般に，`直な操作$の結果として生じる —
は、
意図的に，~pointer~eventの`既定~動作$にされていない
— すなわち，これらの挙動
（例：~touchscreen上で手指を動かした結果として，~pageを~panすること）
は、
~pointer~eventを取消しても抑止できない。
作者は、
代わりに `touch-action$p を利用して，文書の領域に対し
`直な操作~用の挙動を明示的に宣言し＠#declaring-direct-manipulation-behavior$なければナラナイ。
このようにしてあるのは、
~eventの取消nに対する依存関係を除去して，
~UAによる処理能の最適化を手助けするためである。
◎
Viewport manipulations (panning and zooming) — generally, as a result of a direct manipulation interaction — are intentionally NOT a default action of pointer events, meaning that these behaviors (e.g. panning a page as a result of moving a finger on a touchscreen) cannot be suppressed by canceling a pointer event. Authors must instead use touch-action to explicitly declare the direct manipulation behavior for a region of the document. Removing this dependency on the cancelation of events facilitates performance optimizations by the user agent.
</p>

<p>
上の表tに挙げた`~pointer~event$に対しては：
◎
↓</p>
<ul>
	<li>
その `composed$m 属性 `DOM$r は、［［
`pointerenter$et, `pointerleave$et
］においては ~F ／
他においては ~T
］にされるべきである。
◎
For pointerenter and pointerleave events, the composed [DOM] attribute SHOULD be false; for all other pointer events in the table above, the attribute SHOULD be true.
</li>
	<li>
その `detail$m 属性 `UIEVENTS$r は 0 にされるべきである。
◎
For all pointer events in the table above, the detail [UIEVENTS] attribute SHOULD be 0.
</li>
</ul>

<p class="note">注記：
多くの~UAは、
旧来の内容を~supportするため，
`MouseEvent$I 内に標準でない属性［
`fromElement^m, `toElement^m
］を公開している。
それらの~UAには、［
標準~化された代替-（ `target^m, `relatedTarget^m ）を利用するよう，作者に促す
］ため，［
`PointerEvent$I 内の（継承された）それらの属性の値を ~NULL に設定する
］ことが奨励される。
◎
Note
Many user agents expose non-standard attributes fromElement and toElement in MouseEvents to support legacy content. We encourage those user agents to set the values of those (inherited) attributes in PointerEvents to null to transition authors to the use of standardized alternates (target and relatedTarget).
</p>

<p>
`MouseEvent$I の `relatedTarget$m と類似に、
`relatedTarget^m は，［
`pointerover$et ／ `pointerenter$et
］~event用には 直前の`捕捉~込みの~pointing先$, ［
`pointerout$et ／ `pointerleave$et
］~event用には 新たな`捕捉~込みの~pointing先$
に初期化されるべきである。
他の~pointer~event用には、
この値は既定で~NULLになる。
◎
Similar to MouseEvent relatedTarget, the relatedTarget should be initialized to the element whose bounds the pointer just left (in the case of a pointerover or pointerenter event) or the element whose bounds the pointer is entering (in the case of a pointerout or pointerleave). For other pointer events, this value will default to null. Note that when an element receives the pointer capture all the following events for that pointer are considered to be inside the boundary of the capturing element.
</p>

<p>
［
`gotpointercapture$et ／ `lostpointercapture$et
］~event用には、
上の表tに定義されるものを除くすべての属性は，［
~UAに`処理待ち~pointer捕捉を処理-＠#process-pending-pointer-capture$させ,
その~event発火させた`~pointer~event$
］のそれらと同じにされるべきである。
◎
For gotpointercapture and lostpointercapture events, all the attributes except the ones defined in the table above should be the same as the Pointer Event that caused the user agent to run the process pending pointer capture steps and fire the gotpointercapture and lostpointercapture events.
</p>

				</section>
				<section id="process-pending-pointer-capture">
<h5 title="Process pending pointer capture">5.1.3.2. 処理待ち~pointer捕捉の処理-法</h5>

<p>
`~UA$は、
`~pointer捕捉を暗黙的に解放する$とき, および［
`gotpointercapture$et, `lostpointercapture$et
］以外の`~pointer~eventを発火する$ときは，`処理待ち~pointer捕捉を処理する$モノトスル。
◎
The user agent MUST run the following steps when implicitly releasing pointer capture as well as when firing Pointer Events that are not gotpointercapture or lostpointercapture.
</p>

<div class="algo">
<p>
`処理待ち~pointer捕捉を処理する@
~algoは、
所与の
( `作動中な~pointer$ %~pointer )
に対し：
</p>
<ol>
	<li>
%旧-~target ~LET %~pointer の`捕捉~target$
</li>
	<li>
%新-~target ~LET %~pointer の`処理待ち捕捉~target$
</li>
	<li>
~IF［
%旧-~target ~EQ %新-~target
］
⇒
~RET
</li>
	<li>
~IF［
%旧-~target ~NEQ ~NULL
］
⇒
名前 `lostpointercapture$et の`~pointer~eventを発火する$
（これは、
%旧-~target に向けて発火されることになる）
</li>
	<li>
%~pointer の`捕捉~target$ ~SET %新-~target
</li>
	<li>
~IF［
%新-~target  ~NEQ ~NULL
］
⇒
名前 `gotpointercapture$et の`~pointer~eventを発火する$
（これは、
%新-~target に向けて発火されることになる）
</li>
</ol>
◎
• If the pointer capture target override for this pointer is set and is not equal to the pending pointer capture target override, then fire a pointer event named lostpointercapture at the pointer capture target override node.
• If the pending pointer capture target override for this pointer is set and is not equal to the pointer capture target override, then fire a pointer event named gotpointercapture at the pending pointer capture target override.
• Set the pointer capture target override to the pending pointer capture target override, if set. Otherwise, clear the pointer capture target override.
</div>

<p class="note">注記：
<a href="#the-click-auxclick-and-contextmenu-events">§ `click^et ／ `auxclick^et ／ `contextmenu^et ~event</a>
にて定義されるとおり、
`lostpointercapture$et ~eventを配送した後であっても，［
対応している［
`click$et ／ `auxclick$et ／ `contextmenu$et
］~eventがある場合、
それらを`捕捉している~target$に向けて配送される
］ことになる。
◎
Note
As defined in the section for click, auxclick, and contextmenu events, even after the lostpointercapture event has been dispatched, the corresponding click, auxclick or contextmenu event, if any, would still be dispatched to the capturing target.
</p>

				</section>
				<section id="suppressing-a-pointer-event-stream">
<h5 title="Suppressing a pointer event stream">5.1.3.3. ~pointer~event~streamの抑止-法</h5>

<p>
~UAは、
`~pointer~event~streamを抑止する局面$を検出したときは，
`~pointer~event~streamを抑止する$モノトスル。
`~pointer~event~streamを抑止する局面@
とは、
~UAが［
当の~web~pageが特定の `pointerId$m を伴う~pointer~eventを受取り続ける見込みは低い
］とみなす局面である
— 次に挙げる局面は、
これに含まれるとする
（他にも追加的な局面があってもヨイ）：
◎
The user agent MUST suppress a pointer event stream when it detects that the web page is unlikely to continue to receive pointer events with a specific pointerId. Any of the following scenarios satisfy this condition (there MAY be additional scenarios):
</p>
<ul>
	<li>
~UAが［
~modal~dialog／~menu
］を開いたとき。
◎
The user agent has opened a modal dialog or menu.
</li>
	<li>
~pointer入力~装置が物理的に切断されたとき。
◎
A pointer input device is physically disconnected,＼
</li>
	<li>
~hover可能な~pointer入力~装置（例：~penや~stylus）が，
`~digitizer$により検出-可能な~hover範囲から出たとき。
◎
or a hoverable pointer input device (e.g. a hoverable pen/stylus) has left the hover range detectable by the digitizer.
</li>
	<li>
<p>
当の~pointerは、
引き続き，~UAが~page表示域を操作する（例： ~pan-zoom）ために利用されたとき。
詳細は、
§ `touch-action$p ~propを見よ。
◎
The pointer is subsequently used by the user agent to manipulate the page viewport (e.g. panning or zooming). See the section on touch-action CSS property for details.
</p>

<p class="note">注記：
~UAは，［
~pan／~zoom
］動作を複数の`~pointer型$（~touchや~penなど）を通して誘発し得るので、
その動作を開始した結果，同じ~pointer型に限らず様々な~pointerが抑止されることもある。
◎
Note
User agents can trigger panning or zooming through multiple pointer types (such as touch and pen), and therefore the start of a pan or zoom action may result in the suppression of various pointers, including pointers with different pointer types.
</p>
	</li>
	<li>
当の~pointerは、
`HTML$r `§ ~drag＆~drop処理~model＠~HTMLdnd#drag-and-drop-processing-model$
にて定義されるとおり
— `~drag操作oの起動~algo＠~HTMLdnd#initiate-the-drag-and-drop-operation$の一部として —
~drag操作oを生じさせたとき。
◎
As part of the drag operation initiation algorithm as defined in the drag and drop processing model [HTML], for the pointer that caused the drag operation.
</li>
</ul>

<div class="note">
<p>注記：
`~pointer~event~streamを抑止する局面$には、
他にも，次が含まれ得る：
◎
Note
Other scenarios in which the user agent MAY suppress a pointer event stream include:
</p>
<ul>
	<li>
~pointerが`作動中$な間に，
装置の~screen方位が変化したとき。
◎
A device's screen orientation is changed while a pointer is active.
</li>
	<li>
利用者が、
装置が~supportするより多い~pointer入力を同時に利用してヤリトリしようと試みたとき。
◎
The user attempts to interact using more simultaneous pointer inputs than the device supports.
</li>
	<li>
~UAが、
入力を不意なものと解釈したとき
（例えば、
`palm rejection^en 【 “手のひらは~~無視する” 】 を~supportする~hardware）。
◎
The user agent interprets the input as accidental (for example, the hardware supports palm rejection).
</li>
</ul>

<p>
これらの局面を検出する手法は、
この仕様の視野から外れる。
◎
Methods for detecting any of these scenarios are out of scope for this specification.
</p>
</div>

<div class="algo">
<p>
`~pointer~event~streamを抑止する@
~algoは：
◎
The user agent MUST run the following steps to suppress a pointer event stream:
</p>
<ol>
	<li>
名前 `pointercancel$et の`~pointer~eventを発火する$
◎
Fire a pointercancel event.
</li>
	<li>
名前 `pointerout$et の`~pointer~eventを発火する$
◎
Fire a pointerout event.
</li>
	<li>
名前 `pointerleave$et の`~pointer~eventを発火する$
◎
Fire a pointerleave event.
</li>
	<li>
~IF［
当の~pointer %~pointer は現在`捕捉-$されている
］
⇒
`~pointer捕捉を暗黙的に解放する$( %~pointer )
◎
Implicitly release the pointer capture if the pointer is currently captured.
</li>
</ol>
</div>

				</section>
			</section>
			<section id="boundary-events-caused-by-layout-changes">
<h4 title="Boundary events caused by layout changes">5.1.4 ~layout変化</h4>

<p>
~pointing装置が静止中（ `stationary^en ）であるとは、［
当の装置が~screenの物理面に相対的に移動していない
］かつ［
~screenの各~prop【（~displayにおける）その方位や位置など】に何ら変化は生じていない
］ことをいう。
~pointing装置は、
静止中でない間は，
`§ 各種 ~pointer~event型＠#pointer-event-types$
にて定義されるとおりに`~pointer~event$を発火する。
静止中であっても，~layoutが変化したときは、
`~pointing先$に影響する結果，`境界~event$を発火させ得る【！モノトスル】。
~UAは、
処理能の理由があるときは，これら`境界~event$の発火を遅延してもヨイ
（例：
境界~event用の~event~handler【！~listener】により生じる［
接触判定／~layout変化
］†が多過ぎになることを避けるため）。
◎
A pointing device that moved relative to the screen surface or underwent some change in any of its properties fires various events as defined in Pointer Event types. For a stationary pointing device (that neither moved relative to the screen surface nor underwent any change in any properties), the user agent MUST fire certain boundary events after a layout change that affected the hit test target for the pointer, see pointerover, pointerenter, pointerout and pointerleave for details. The user agent MAY delay the firing of these boundary events because of performance reasons (e.g. to avoid too many hit-tests or layout changes caused by boundary event listeners).
</p>

<p class="trans-note">【†
例えば，~event~handlerが~pageの~styleを変更することにより。
したがって， “遅延する”とは、
`~event~loop$の各~反復における そのような発火の回数を抑制することを意味する。
】</p>

<p class="note">注記：
静止中な~pointing装置は、
`pointermove$et ~eventを決して発火しない。
◎
Note
A stationary pointing device (that neither moved relative to the screen surface nor underwent any change in any properties) never fires a pointermove event.
</p>

			</section>
			<section id="converting-between-tiltx-tilty-and-altitudeangle-azimuthangle">
<h4 title="Converting between tiltX / tiltY and altitudeAngle / azimuthAngle">5.1.5. ［ `tiltX^m, `tiltY^m ］と［ `altitudeAngle^m, `azimuthAngle^m ］の間の変換-法</h4>

<p>
`~pointer~event$は、
~transducerに相対的な~X-Z平面の方位を表出するためとして，
2 つの相補的な属性~組を含む：
◎
Pointer Events include two complementary sets of attributes to express the orientation of a transducer relative to the X-Y plane:＼
</p>
<ul>
	<li>
(T)：
`tiltX$m,
`tiltY$m
（元の Pointer Events 仕様にて導入された）
◎
tiltX / tiltY (introduced in the original Pointer Events specification), and＼
</li>
	<li>
(A)：
`altitudeAngle$m,
`azimuthAngle$m
（ `Touch Events, ~level 2＠~TOUCHEVENTS$cite 仕様から採用された）
◎
azimuthAngle / altitudeAngle (adopted from the Touch Events - Level 2 specification).
</li>
</ul>

<p>
特定の［
~hardware, ~platform
］に依存して、
~UAは，~transducer方位に相対的な~screen平面~用の値として［
上の属性~組 (T), (A)
］のうち片方しか受取らない見込みが高い。
~UAは，これらの値を変換するときは、
以下の~algo【次の例に述べられる変換-法】を利用するモノトスル。
◎
Depending on the specific hardware and platform, user agents will likely only receive one set of values for the transducer orientation relative to the screen plane — either tiltX / tiltY or altitudeAngle / azimuthAngle. User agents MUST use the following algorithm for converting these values.
</p>

<p>
~UAは，上の (A) から (T) を計算するときは、
`Math.round$c の規則 `ECMASCRIPT$r を利用して，整数~値を最終的に丸めるベキである。
◎
When the user agent calculates tiltX / tiltY from azimuthAngle / altitudeAngle it SHOULD round the final integer values using Math.round [ECMASCRIPT] rules.
</p>

<div class="example">
<p>
［
`tiltX$m ／ `tiltY$m
］と［
`azimuthAngle$m ／ `altitudeAngle$m
］の間の変換-法：
◎
Example 8: Converting between tiltX/tiltY and altitudeAngle/azimuthAngle
◎
/* Converting between tiltX/tiltY and altitudeAngle/azimuthAngle */
</p>

<pre class="lang-js">
const π = Math.PI;  /* <span class="comment">
【これは、以下を読み易くするための，この訳による追加。】
</span> */

function spherical2tilt(%altitudeAngle, %azimuthAngle) {
  const %radToDeg = 180/π;

  let %tiltXrad = 0;
  let %tiltYrad = 0;

  if (%altitudeAngle == 0) {
    /* <span class="comment">
~penは~X-Y平面~内にある
◎
the pen is in the X-Y plane
</span> */
    if (%azimuthAngle == 0 || %azimuthAngle == 2*π) {
      /* <span class="comment">
~penは正な~X軸~上にある
◎
pen is on positive X axis
</span> */
      %tiltXrad = π/2;
    }
    if (%azimuthAngle == π/2) {
      /* <span class="comment">
~penは正な~Y軸~上にある
◎
pen is on positive Y axis
</span> */
      %tiltYrad = π/2;
    }
    if (%azimuthAngle == π) {
      /* <span class="comment">
~penは負な~X軸~上にある
◎
pen is on negative X axis
</span> */
      %tiltXrad = -π/2;
    }
    if (%azimuthAngle == 3*π/2) {
      /* <span class="comment">
~penは負な~Y軸~上にある
◎
pen is on negative Y axis
</span> */
      %tiltYrad = -π/2;
    }
    if (%azimuthAngle &gt; 0 &amp;&amp; %azimuthAngle &lt; π/2) {
      %tiltXrad = π/2;
      %tiltYrad = π/2;
    }
    if (%azimuthAngle &gt; π/2 &amp;&amp; %azimuthAngle &lt; π) {
      %tiltXrad = -π/2;
      %tiltYrad = π/2;
    }
    if (%azimuthAngle &gt; π &amp;&amp; %azimuthAngle &lt; 3*π/2) {
      %tiltXrad = -π/2;
      %tiltYrad = -π/2;
    }
    if (%azimuthAngle &gt; 3*π/2 &amp;&amp; %azimuthAngle &lt; 2*π) {
      %tiltXrad = π/2;
      %tiltYrad = -π/2;
    }
  }

  if (%altitudeAngle != 0) {
    const %tanAlt = Math.tan(%altitudeAngle);

    %tiltXrad = Math.atan(Math.cos(%azimuthAngle) / %tanAlt);
    %tiltYrad = Math.atan(Math.sin(%azimuthAngle) / %tanAlt);
  }

  return {"tiltX": %tiltXrad * %radToDeg, "tiltY": %tiltYrad * %radToDeg};
}

function tilt2spherical(%tiltX, %tiltY) {
  const %tiltXrad = %tiltX * π/180;
  const %tiltYrad = %tiltY * π/180;

  /* <span class="comment">
方位角を計算する
◎
calculate azimuth angle
</span> */
  let %azimuthAngle = 0;

  if (%tiltX == 0) {
    if (%tiltY &gt; 0) {
      %azimuthAngle = π/2;
    }
    else if (%tiltY &lt; 0) {
      %azimuthAngle = 3*π/2;
    }
  } else if (%tiltY == 0) {
    if (%tiltX &lt; 0) {
      %azimuthAngle = π;
    }
  } else if (Math.abs(%tiltX) == 90 || Math.abs(%tiltY) == 90) {
    /* <span class="comment">
方位角を計算するための情報が足らない
◎
not enough information to calculate azimuth
</span> */
    %azimuthAngle = 0;
  } else {
    /* <span class="comment">
非~境界~事例：
%tiltX, %tiltY どちらも 90 の倍数でない
◎
Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90
</span> */
    const %tanX = Math.tan(%tiltXrad);
    const %tanY = Math.tan(%tiltYrad);

    %azimuthAngle = Math.atan2(%tanY, %tanX);
    if (%azimuthAngle &lt; 0) {
      %azimuthAngle += 2*π;
    }
  }

  /* <span class="comment">
仰角を計算する
◎
calculate altitude angle
</span> */
  let %altitudeAngle = 0;

  if (Math.abs(%tiltX) == 90 || Math.abs(%tiltY) == 90) {
      %altitudeAngle = 0
  } else if (%tiltX == 0) {
    %altitudeAngle = π/2 - Math.abs(%tiltYrad);
  } else if (%tiltY == 0) {
    %altitudeAngle = π/2 - Math.abs(%tiltXrad);
  } else {
    /* <span class="comment">
非~境界~事例：
%tiltX, %tiltY どちらも 90 の倍数でない
◎
Non-boundary case: neither tiltX nor tiltY is equal to 0 or +-90
</span> */
    %altitudeAngle =  Math.atan(1.0/Math.sqrt(Math.pow(Math.tan(%tiltXrad),2) + Math.pow(Math.tan(%tiltYrad),2)));
  }

  return {"altitudeAngle": %altitudeAngle, "azimuthAngle": %azimuthAngle};
}
</pre>
</div>
			</section>
		</section>
		<section id="pointerevent-algorithms">
<h3 title="PointerEvent Algorithms">5.2. `PointerEvent^I 用の各種~algo</h3>

<div class="algo">
<p id="initialize-a-pointerevent">
`~PointerEventを初期化する@
~algoは、
所与の
⇒＃
`PointerEvent$I %~event,
文字列 %~event型,
`EventTarget$I %~event~target,
真偽値 %浮上するか,
真偽値 %取消~可能か
◎終
に対し：
◎
5.2.1. initialize a PointerEvent
◎
To initialize a PointerEvent with event, eventType and eventTarget, bubbles, and cancelable, run the following steps:
</p>
<ol>
	<li>
`~MouseEventを初期化する$( ↓ )
⇒＃
%~event,
%~event型,
%~event~target,
%浮上するか,
%取消~可能か
◎
Initialize a MouseEvent with event, eventType and eventTarget, bubbles and cancelable
</li>
	<li>
他の属性
— `PointerEvent$I の属性のうち `MouseEvent$I の属性でないものを各自の既定の値
【 `PointerEventInit$I に定義される同名の~memberの既定~値】
に初期化する
◎
Initialize all other attributes to default PointerEvent values.
</li>
</ol>
</div>

<div class="algo">
<p id="create-a-pointerevent">
`~PointerEventを作成する@
~algoは、
所与の
⇒＃
%~event型,
%~event~target,
真偽値 %浮上するか,
真偽値 %取消~可能か
◎終
に対し：
◎
5.2.2. create a PointerEvent
◎
To create a PointerEvent with eventType and eventTarget, bubbles, and cancelable, run the following steps:
</p>

<p class="trans-note">【
この~algoを呼出している各所では［
%浮上するか, %取消~可能か
］を渡していない
— これらの引数は省略可能かもしれないが、
省略時にとる既定の値が指定されていない。
】</p>

<ol>
	<li>
%~event ~LET `~eventを作成する$( `PointerEvent$I )
◎
Let event be the result of creating an event using PointerEvent
</li>
	<li>
`~PointerEventを初期化する$( ↓ )
⇒＃
%~event,
%~event型,
%~event~target,
%浮上するか,
%取消~可能か
◎
Initialize a PointerEvent with event, eventType and eventTarget, bubbles and cancelable
</li>
	<li>
~RET %~event
◎
Return event
</li>
</ol>
</div>

<div class="algo">
<p id="create-pointerevent-from-mouseevent">
`~MouseEventから~PointerEventを作成する@
~algoは、
所与の
( 文字列 %~event型, `MouseEvent$I %~mouse~event )
に対し：
◎
5.2.3. create PointerEvent from MouseEvent
◎
• Let eventType be a DOMString containing the event type
• Let mouseevent be the corresponding MouseEvent
</p>
<ol>
	<li>
%~event ~LET `~eventを作成する$( `PointerEvent$I )
◎
Let event be the result of creating an event using PointerEvent
</li>
	<li>
`~PointerEventを初期化する$( ↓ )
⇒＃
%~event,
%~event型,
%~mouse~event の`~target$【！`target$m 以下同様】
◎
Let target be the mouseevent.target
◎
Initialize a PointerEvent with event, eventType and target
</li>
	<li>
%~mouse~event から %~event の中へ `MouseEvent$I に属する各~属性を複製する
◎
Copy MouseEvent attributes from mouseevent into event
</li>
	<li>
~RET %~event
◎
Return event
</li>
</ol>
</div>

<div class="algo">
<p>
`必要なら~pointer~eventを送信する@
~algoは、
所与の
( `MouseEvent$I %~mouse~event, 文字列 %~event型 ~DF ε )
に対し：
</p>

<p class="trans-note">【
この~algoは、
原文では %~event型 ごとに別々な~algoとして定義されているが，
この訳では一つに統合することにする。
】【
原文には %~event型 が `pointerrawupdate^l になる場合の~algoもあるが、
現時点では利用されていない。
】【
“必要なら（ `maybe^en ）”：
この~algoは，現時点では常に %~mouse~event に対応する~pointer~eventを配送するよう定義されているが、
将来には そうならない事例を追加することが意図されているかもしれない。
】</p>

<ol>
	<li>
~IF［
%~event型 ~EQ ε
］
⇒
%~event型 ~SET %~mouse~event の `type$m に応じて
⇒＃
`mouseout^l ならば `pointerout^l ／
`mouseleave^l ならば `pointerleave^l ／
`mouseover^l ならば `pointerover^l ／
`mouseenter^l ならば `pointerenter^l ／
`mousemove^l ならば `pointermove^l ／
`mousedown^l ならば `pointerdown^l ／
`mouseup^l ならば `pointerup^l
</li>
	<li>
%~pointer~event ~LET `~MouseEventから~PointerEventを作成する$( %~event型, %~mouse~event )
</li>
	<li class="issue">
この段の中で `PointerEvent$I に特有な属性たちを設定する必要がある。
</li>
	<li>
%~target ~LET %~mouse~event の`~target$
</li>
	<li>
`~eventを配送する$( %~target, %~pointer~event )
</li>
</ol>

<div class="note">
<p>注記：
%~event型 に応じて：
</p>
<ul>
	<li>
`pointermove^l の場合
⇒
これは［
`pointermove$et, `pointerrawupdate$et
］を送信し得るか？
それとも 2 つの~methodが必要か？
【！Can this send pointermove and pointerrawupdate? Or do we need 2 methods?】
</li>
	<li>
`pointermove^l の場合
⇒
`pointermove$et ~eventたちをどう合体するかを適正に定義するためには，
何が必要になるか？
【！What is needed to properly define how pointermove events are coalesced?】
</li>
	<li>
［
`pointerdown^l ／ `pointerup^l
］の場合
⇒
［
`mousedown$et ／ `mouseup$et
］~eventとは違って，［
`pointerdown$et ／ `pointerup$et
］~eventは複数の~buttonが押されたときでも入子にされない
【~eventが “入子にされる” とは何を意味する？】。
%~mouse~event は、
`MouseEvent$I に属する各~fieldを %~pointer~event の中へ複製できるよう渡される。
【！Unlike mousedown events, pointerdown events are...】
【！Unlike mouseup events, pointerup events are】
</li>
</ul>
</div>

◎
5.2.4 maybe send pointerout event

• Let mouseout be the corresponding mouseout MouseEvent
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target
◎
5.2.5 maybe send pointerleave event

• Let mouseout be the corresponding mouseout MouseEvent
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target

◎
5.2.6 maybe send pointerover event

• Let mouseout be the corresponding mouseout MouseEvent
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target

◎
5.2.7 maybe send pointerenter event

• Let mouseout be the corresponding mouseout MouseEvent
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target

◎
5.2.8 maybe send pointermove event

• Let mouseout be the corresponding mouseout MouseEvent
• Editor's note

• Can this send pointermove and pointerrawupdate? Or do we need 2 methods?
• Editor's note

• What is needed to properly define how pointermove events are coalesced?
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target

◎
5.2.9 maybe send pointerdown event

• Let mouseout be the corresponding mouseout MouseEvent
• Note

• Unlike mousedown events, pointerdown events are not nested when multiple buttons are pressed. The MouseEvent is passed so that the fields can be copied into the PointerEvent.
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target

◎
5.2.10 maybe send pointerrawupdate event

• Let mouseout be the corresponding mouseout MouseEvent
• Let target be the mouseout.target
• dispatch pointerout at target

◎
5.2.11 maybe send pointerup event

• Let mouseout be the corresponding mouseout MouseEvent
• Note

• Unlike mouseup events, pointerup events are not nested when multiple buttons are pressed. The MouseEvent is passed so that the fields can be copied into the PointerEvent.
• Let pointerout be the result of creating PointerEvent from MouseEvent with "pointerout" and mouseout
• Set pointerevent attributes
• Editor's note

• TODO.
• Let target be the mouseout.target
• dispatch pointerout at target
</div>

		</section>
		<section id="pointer-event-types">
<h3 title="Pointer Event types">5.3. 各種~pointer~event型</h3>

<p>
この仕様にて定義される各種~event型を以下に述べる。
◎
Below are the event types defined in this specification.
</p>

<p>
`首~pointer$に対しては、
（ `gotpointercapture$et, `lostpointercapture$et を例外として）
これらの~eventからは，`互換性~mouse~event$も発火され得る。
◎
In the case of the primary pointer, these events (with the exception of gotpointercapture and lostpointercapture) may also fire compatibility mouse events.
</p>

			<section id="the-pointerover-event">
<h4 title="The pointerover event">5.3.1. `pointerover@et ~event</h4>

<div>
<p>
`~UA$は、
所与の要素 %要素 に関して［
~pointerの`捕捉~込みの~pointing先$が %要素 以外から %要素 になった
］ことを検出したときは，
名前 `pointerover$et の`~pointer~eventを発火する$モノトスル。
</p>

<p>
この~eventは、
入力~装置が`~hoverを~supportしない$場合でも，
`pointerdown$et ~eventを発火する前に発火されることになる
（ `pointerdown$et を見よ）。
</p>
◎
The user agent MUST fire a pointer event named pointerover when any of the following occurs:
• The step to determine the target of a pointer detects that the pointer has moved into an element.
• A layout change causes the hit test boundaries of an element to move underneath an uncaptured pointer of a stationary pointing device.
• Before the user agent fires a pointerdown event for a device that does not support hover (see pointerdown).
</div>

			</section>
			<section id="the-pointerenter-event">
<h4 title="The pointerenter event">5.3.2. `pointerenter@et ~event</h4>

<div>
<p>
`~UA$は、
所与の要素 %要素 に関して［
~pointerの`捕捉~込みの~pointing先$が
%要素 の`広義-子孫$以外から それらいずれかになった
］ことを検出したときは，
名前 `pointerover$et の`~pointer~eventを発火する$モノトスル。
</p>

<div class="trans-note">
<p>【
したがって、
`捕捉~込みの~pointing先$が変化したとき，
~AND↓ を満たす`各^em 要素に向けて発火されることになる：
</p>
<ul>
	<li>
新たな~pointing先の`広義-先祖$である
（新たな~pointing先 ~EQ ~NULL の場合は無条件）。
</li>
	<li>
以前の~pointing先の`広義-先祖$でない
（以前の~pointing先 ~EQ ~NULL の場合は無条件）。
</li>
</ul>
<p>
該当する要素が複数~在る場合、
（ `mouseenter$et のときと同様に）
最も先祖のものから順に，この~eventを発火することになろう。
】</p>
</div>

<p>
この~eventは、
入力~装置が`~hoverを~supportしない$場合でも，
`pointerdown$et ~eventを発火する前に発火されることになる
（ `pointerdown$et を見よ）。
</p>
◎
The user agent MUST fire a pointer event named pointerenter when any of the following occurs:
• The step to determine the target of a pointer detects that the pointer has moved into an element or one of its descendants.
• A layout change causes the hit test boundaries of an element or one of its descendants to move underneath an uncaptured pointer of a stationary pointing device.
• Before the user agent fires a pointerdown event for a device that does not support hover (see pointerdown).
</div>

<p class="note">注記：
`pointerenter$et は、
`pointerover$et に類似するが，次において相違する
⇒＃
浮上しない。
その配送には子孫~要素の`接触判定$境界も考慮される。
◎
Note
This event type is similar to pointerover but with two differences: pointerenter does not bubble, and its dispatch considers the hit test boundaries of even descendant elements.
</p>

<p class="note">注記：
［
この型の~event,
`mouseenter$et ~event `UIEVENTS$r,
~CSSの `~hover_ps 疑似類$ `CSS21$r
］の間には類似性がある。
`pointerleave$et ~eventも見よ。
◎
Note
There are similarities between this event type, the mouseenter event described in [UIEVENTS], and the CSS :hover pseudo-class described in [CSS21]. See also the pointerleave event.
</p>

			</section>
			<section id="the-pointerdown-event">
<h4 title="The pointerdown event">5.3.3. `pointerdown@et ~event</h4>

<p>
［
~pointerの~buttonが非`作動~状態$から`作動~状態$へ遷移した
］とき，`~pointing先$が要素である（ ~NULL でない）ならば、
名前 `pointerdown$et の`~pointer~eventを発火する$モノトスル。
【この段落を成す他の内容は，作動~状態の定義に移譲。】
◎
The user agent MUST fire a pointer event named pointerdown when a pointer enters the active buttons state. For mouse, this is when the device transitions from no buttons depressed to at least one button depressed. For touch, this is when physical contact is made with the digitizer. For pen, this is when the pen either makes physical contact with the digitizer without any button depressed, or transitions from no buttons depressed to at least one button depressed while hovering.
</p>

<p class="note">注記：
~mouse（または他の複-~button~pointer装置）に対しては、
このことは，［［
`mousedown$et ／ `mouseup$et
］が発火されるときと同じ状況下で，常に［
`pointerdown$et ／ `pointerup$et
］が発火されるとは限らない
］ことを意味する。
`~buttonの追加押下げ$を見よ。
◎
Note
For mouse (or other multi-button pointer devices), this means pointerdown and pointerup are not fired for all of the same circumstances as mousedown and mouseup. See chorded buttons for more information.
</p>

<p>
入力~装置が`~hoverを~supportしない$場合には、
`pointerdown$et ~eventを配送するより先に，順に，名前［
`pointerover$et, `pointerenter$et
］の`~pointer~eventを発火する$モノトスル。
◎
For input devices that do not support hover, the user agent MUST also fire a pointer event named pointerover followed by a pointer event named pointerenter prior to dispatching the pointerdown event.
</p>

<p class="trans-note">【
~hoverを~supportする装置の~pointerが［
~UIwindow外から瞬時に移動してきて，一瞬だけ静止した後、
作動~状態に遷移した
］ときの挙動と同様になる。
】</p>

<p class="note">注記：
作者は、
`pointerdown$et ~eventを取消して（その `isPrimary$m 属性が ~T ならば），
ある種の`互換性~mouse~event$の発火を防止できる。
これは、
~pointerの`~mouse~eventは防止するか$を ~T にする。
ただし、［
`mouseover$et ／
`mouseenter$et ／
`mouseout$et ／
`mouseleave$et
］~eventの発火は防止されないことに注意。
◎
Note
Authors can prevent the firing of certain compatibility mouse events by canceling the pointerdown event (if the isPrimary property is true). This sets the PREVENT MOUSE EVENT flag on the pointer. Note, however, that this does not prevent the mouseover, mouseenter, mouseout, or mouseleave events from firing.
</p>

			</section>
			<section id="the-pointermove-event">
<h4 title="The pointermove event">5.3.4. `pointermove@et ~event</h4>

<p>
~pointerの~propのうち［
`pointerdown$et ／ `pointerup$et
］~eventを発火しないものが変化したときは、
名前 `pointermove$et の`~pointer~eventを発火する$モノトスル。
◎
The user agent MUST fire a pointer event named pointermove when a pointer changes any properties that don't fire pointerdown or pointerup events.＼
</p>

<p>
該当する~propには、
次に挙げるものが含まれる
⇒＃
座標／
押圧／
接線方向~圧／
傾き／
~twist／
`接触~幾何$（ `width$m, `height$m ）／
`~buttonの追加押下げ$
◎
This includes any changes to coordinates, pressure, tangential pressure, tilt, twist, contact geometry (width and height) or chorded buttons.
</p>

<p>
`~UA$は、
`pointermove^et ~eventの配送を遅延してもヨイ
（一例として，処理能の理由で）。
`合体された~event群$の情報は、
それ用に配送される 1 個の `pointermove$et ~event内に，
`getCoalescedEvents()$m ~methodを介して公開されることになる。
`~UA$は、
この~eventの~targetを合体された~event群の最終-座標を利用して見出すベキである。
◎
User agents MAY delay dispatch of the pointermove event (for instance, for performance reasons). The coalesced events information will be exposed via thegetCoalescedEvents method for the single dispatched pointermove event. The final coordinates of such events should be used for finding the target of the event.
</p>

			</section>
			<section id="the-pointerrawupdate-event">
<h4 title="The pointerrawupdate event">5.3.5. `pointerrawupdate@et ~event</h4>

<p>
~pointerの~propのうち［
`pointerdown$et ／ `pointerup$et
］~eventを発火しないものが変化したときには
（該当する~propについては、 `pointermove$et を見よ）、
`~secureな文脈$enVの中に限り，
名前 `pointerrawupdate$et の`~pointer~eventを発火する$モノトスル：
◎
The user agent MUST fire a pointer event named pointerrawupdate, and only do so within a secure context, when a pointer changes any properties that don't fire pointerdown or pointerup events. See pointermove event for a list of such properties.
</p>
<ul>
	<li>
`~UA$は、
`pointerrawupdate$et ~eventを［
アリな限り早く, ~JSが~eventを取扱える限りの~rate
］で配送するベキである
— `pointermove$et とは対照的に。
◎
In contrast with pointermove, user agents SHOULD dispatch pointerrawupdate events as soon as possible and as frequently as the JavaScript can handle the events.
</li>
	<li>
`pointerrawupdate$et ~eventの `target$m は、
`pointermove$et ~eventのそれとは異なるかもしれない
— 後者は、
遅延されたり合体され得るので。
また， `target^m を見出すために利用される最終-位置は、
合体された各~eventとは異なり得る。
◎
The target of pointerrawupdate events might be different from the pointermove events due to the fact that pointermove events might get delayed or coalesced, and the final position of the event which is used for finding the target could be different from its coalesced events.
</li>
	<li>
`~event~loop$内に［
同じ `pointerId$m を伴う別の `pointerrawupdate$et ~event
］を配送する`~task$が まだある場合、
`~UA$は
— 新たな`~task$を作成する代わりに —
その~eventに新たな `pointerrawupdate$et を合体してもヨイことに注意。
よって，それらの~eventは、
`~event~loop$内で処理される時点で［
1 個の `pointerrawupdate$et ~eventに`合体された~event群$
］として送達され得ることになる。
さらなる情報は `getCoalescedEvents()$m を見よ。
◎
Note that if there is already another pointerrawupdate with the same pointerId that hasn't been dispatched in the event loop, the user agent MAY coalesce the new pointerrawupdate with that event instead of creating a new task. This may cause pointerrawupdate to have coalesced events, and they will all be delivered as coalesced events of one pointerrawupdate event as soon as the event is processed in the event loop. SeegetCoalescedEvents for more information.
</li>
	<li>
【！In terms of ordering of ...】
`~UA$は、
~platformから［
`pointerrawupdate$et, `pointermove$et
］両~eventを生じさせるような更新を受取った場合には，
`pointerrawupdate$et ~eventから先に配送するモノトスル。
◎
In terms of ordering of pointerrawupdate and pointermove, if the user agent received an update from the platform that causes both pointerrawupdate and pointermove events, then the user agent MUST dispatch the pointerrawupdate event before the corresponding pointermove.
</li>
	<li>
`target$m 以外の~event属性については、［
最後の `pointermove$et ~event以降に配送された すべての `pointerrawupdate$et ~event
］が成す合体d~event~listたちが成す連結（ `concatenation^en ）【意図不明】は、
次回の `pointermove$et ~eventの合体d~eventたちと同じになる。
◎
Other than the target, the concatenation of coalesced events lists of all dispatched pointerrawupdate events since the last pointermove event is the same as the coalesced events of the next pointermove event in terms of the other event attributes.＼
</li>
	<li>
`pointerrawupdate$et の各種~属性のほとんどは、
`pointermove$et のそれらと同じになる
— 例外として， `pointerrawupdate$et 用には、
`cancelable$m は ~F にするモノトスル。
◎
The attributes of pointerrawupdate are mostly the same as pointermove, with the exception of cancelable which MUST be false for pointerrawupdate.
</li>
	<li>
`~UA$は、
`pointerrawupdate$et 用には，`互換性~mouse~event$を発火しないベキである。
◎
User agents SHOULD not fire compatibility mouse events for pointerrawupdate.
</li>
</ul>

<p class="note">注記：
`pointerrawupdate$et ~event用の~listenerを追加すると、
~UAの実装によっては，~web~pageの処理能に悪影響を及ぼすかもしれない。
ほとんどの利用事例では、
他の型の~pointer~eventで足るはずである。
そのような~listenerは、
~scriptが［
高~頻度な~eventが必要で，それだけ速くそれらを取扱える場合
］に限り，追加されるベキである。
これらの事例では、
他の型の~pointer~eventを~listenする必要はおそらく無い。
◎
Note
Adding listeners for the pointerrawupdate event might negatively impact the performance of the web page, depending on the implementation of the user agent. For most use cases the other pointerevent types should suffice. A pointerrawupdate listener should only be added if JavaScript needs high frequency events and can handle them just as fast. In these cases, there is probably no need to listen to other types of pointer events.
</p>

			</section>
			<section id="the-pointerup-event">
<h4 title="The pointerup event">5.3.6. `pointerup@et ~event</h4>

<p>
`~UA$は、
~pointerの~buttonが`作動~状態$から非`作動~状態$へ遷移したときは，
名前 `pointerup$et の`~pointer~eventを発火する$モノトスル。
【この段落を成す他の内容は，作動~状態の定義に移譲。】
◎
The user agent MUST fire a pointer event named pointerup when a pointer leaves the active buttons state. For mouse, this is when the device transitions from at least one button depressed to no buttons depressed. For touch, this is when physical contact is removed from the digitizer. For pen, this is when the pen is removed from the physical contact with the digitizer while no button is depressed, or transitions from at least one button depressed to no buttons depressed while hovering.
</p>

<p>
`~UA$は、
入力~装置が`~hoverを~supportしない$場合には，
`pointerup$et ~eventを配送した後に［
順に，名前 `pointerout$et, `pointerleave$et の`~pointer~eventを発火する$
］モノトスル。
◎
For input devices that do not support hover, the user agent MUST also fire a pointer event named pointerout followed by a pointer event named pointerleave after dispatching the pointerup event.
</p>

<p class="trans-note">【
~hoverを~supportする装置の~pointerが［
非~作動~状態に遷移してから、
一瞬だけ静止した後，瞬時に~UIwindow外へ移動した
］ときの挙動と同様になる。
】</p>

<p>
どの `pointerup$et ~eventにおいても、
`pressure$m の値は 0 になる。
◎
All pointerup events have a pressure value of 0.
</p>

<p>
`~UA$は、
当の~pointerが現在`捕捉-$されている場合には，
`~pointer捕捉を暗黙的に解放する$モノトスル。
◎
The user agent MUST also implicitly release the pointer capture if the pointer is currently captured.
</p>

<p class="note">注記：
~mouse（または他の複-~button~pointer装置）に対しては、
このことは，［［
`mousedown$et ／ `mouseup$et
］が発火されるときと同じ状況下で，常に［
`pointerdown$et ／ `pointerup$et
］が発火されるとは限らない
］ことを意味する。
`~buttonの追加押下げ$を見よ。
◎
Note
For mouse (or other multi-button pointer devices), this means pointerdown and pointerup are not fired for all of the same circumstances as mousedown and mouseup. See chorded buttons for more information.
</p>

			</section>
			<section id="the-pointercancel-event">
<h4 title="The pointercancel event">5.3.7. `pointercancel@et ~event</h4>

<p>
`~UA$は、
`~pointer~event~streamを抑止する局面$を検出したときは，
名前 `pointercancel$et の`~pointer~eventを発火する$モノトスル：
◎
The user agent MUST fire a pointer event named pointercancel when it detects a scenario to suppress a pointer event stream.
</p>

<p>
`pointercancel$et ~eventは、
次に従うモノトスル：
◎
↓</p>
<ul>
	<li>
次に挙げる~propは、［
その取消nに先行して配送された~pointer~event
］のうち［
同じ `pointerId$m を伴うもの
］のうち［
最後のもの
］と同じ値をとる
⇒＃
`width$m,
`height$m,
`pressure$m,
`tangentialPressure$m,
`tiltX$m,
`tiltY$m,
`twist$m,
`altitudeAngle$m,
`azimuthAngle$m,
`pointerType$m,
`isPrimary$m,
`UIEVENTS$r から継承した各~座標
◎
The values of the following properties of the pointercancel event MUST match the values of the last dispatched pointer event with the same pointerId: width, height, pressure, tangentialPressure, tiltX, tiltY, twist, altitudeAngle, azimuthAngle, pointerType, isPrimary, and the coordinates inherited from [UIEVENTS].＼
</li>
	<li>
［
`合体d~event~list$, `予測d~event~list$
【！the coalescedEvents and predictedEvents lists】
］は空。
◎
The coalescedEvents and predictedEvents lists in the pointercancel event MUST be empty,＼
</li>
	<li>
`cancelable$m 属性は ~F をとる。
◎
and the event's cancelable attribute MUST be false.
</li>
</ul>

			</section>
			<section id="the-pointerout-event">
<h4 title="The pointerout event">5.3.8. `pointerout@et ~event</h4>

<div>
<p>
`~UA$は、
所与の要素 %要素 に関して，次に挙げるいずれかが生じたときは，
名前 `pointerout$et の`~pointer~eventを発火する$モノトスル：
</p>
<ul>
	<li>
~pointerの`捕捉~込みの~pointing先$が %要素 から %要素 以外になったことを検出したとき。
</li>
	<li>
【 %要素 に向けて `pointerover$et ~eventを発火した後，】
`~pointer~event~streamを抑止する局面$を検出したとき。
</li>
</ul>

<p>
この~eventは、
入力~装置が`~hoverを~supportしない$場合でも，
`pointerup$et ~eventを発火した後に発火されることになる
（ `pointerup$et を見よ）。
</p>
◎
The user agent MUST fire a pointer event named pointerout when any of the following occurs:
• The step to determine the target of a pointer detects that the pointer has moved out of an element.
• A layout change causes the hit test boundaries of an element to move away from underneath an uncaptured pointer of a stationary pointing device.
• After the user agent fires a pointerup event for a device that does not support hover (see pointerup).
• The user agent has detected a scenario to suppress a pointer event stream.
</div>

			</section>
			<section id="the-pointerleave-event">
<h4 title="The pointerleave event">5.3.9. `pointerleave@et ~event</h4>

<div>
<p>
`~UA$は、
所与の要素 %要素 に関して次に挙げるいずれかが生じたときは，
名前 `pointerleave$et の`~pointer~eventを発火する$モノトスル：
</p>
<ul>
	<li>
<p>
~pointerの`捕捉~込みの~pointing先$が
%要素 の`広義-子孫$から それら以外になったことを検出したとき。
</p>

<div class="trans-note">
<p>【
したがって、
`捕捉~込みの~pointing先$が変化したとき，
~AND↓ を満たす`各^em 要素に向けて発火されることになる：
</p>
		<ul>
			<li>
以前の~pointing先の`広義-先祖$である
（以前の~pointing先 ~EQ ~NULL の場合は無条件）
</li>
			<li>
新たな~pointing先の`広義-先祖$でない
（新たな~pointing先 ~EQ ~NULL の場合は無条件）
</li>
		</ul>
<p>
該当する要素が複数~在る場合
（例：新たな~pointing先が存在しない場合、
（ `pointerenter$et のときとは逆順に）
最も子孫のものから順に，この~eventを発火することになろう。
】</p>
</div>

</li>
	<li>
【 %要素 に向けて `pointerenter$et ~eventを発火した後，】
`~pointer~event~streamを抑止する局面$を検出したとき。
</li>
</ul>

<p>
この~eventは、
入力~装置が`~hoverを~supportしない$場合でも，
`pointerup$et ~eventを発火した後に発火されることになる
（ `pointerup$et を見よ）。
</p>

◎
The user agent MUST fire a pointer event named pointerleave when any of the following occurs:
• The step to determine the target of a pointer detects that the pointer has moved out of an element and all of its descendants.
• A layout change causes the hit test boundaries of an element and all of its descendants to move away from underneath an uncaptured pointer of a stationary pointing device.
• After the user agent fires the pointerup event for a device that does not support hover (see pointerup).
• The user agent has detected a scenario to suppress a pointer event stream.
</div>

<p class="note">注記：
`pointerleave$et は、
`pointerout$et に類似するが，次において相違する
⇒＃
浮上しない。
その配送には子孫~要素の`接触判定$境界も考慮される。
◎
Note
This event type is similar to pointerout but with two differences: pointerleave does not bubble, and its dispatch considers the hit test boundaries of even descendant elements.
</p>

<p class="note">注記：
［
この型の~event,
`mouseleave$et ~event `UIEVENTS$r,
~CSSの `~hover_ps 疑似類$ `CSS21$r
］の間には類似性がある。
`pointerenter$et ~eventも見よ。
◎
Note
There are similarities between this event type, the mouseleave event described in [UIEVENTS], and the CSS :hover pseudo-class described in [CSS21]. See also the pointerenter event.
</p>

			</section>
			<section id="the-gotpointercapture-event">
<h4 title="The gotpointercapture event">5.3.10. `gotpointercapture@et ~event</h4>

<p>
`~UA$は、
~pointerが要素に`捕捉-$されたときは，
名前 `gotpointercapture$et の`~pointer~eventを発火する$モノトスル。
その~pointer用の後続な~eventは、
この要素に向けて発火されることになる。
［
`§ ~pointer捕捉の設定-法＠#setting-pointer-capture$ ／
`§ 処理待ち~pointer捕捉の処理-法＠#process-pending-pointer-capture$
］を見よ。
◎
The user agent MUST fire a pointer event named gotpointercapture when an element receives pointer capture. This event is fired at the element that is receiving pointer capture. Subsequent events for that pointer will be fired at this element. See the setting pointer capture and process pending pointer capture sections.
</p>
			</section>
			<section id="the-lostpointercapture-event">
<h4 title="The lostpointercapture event">5.3.11. `lostpointercapture@et ~event</h4>

<p>
`~UA$は、
要素による`~pointer捕捉$が解放されたときは，
名前 `lostpointercapture$et の`~pointer~eventを発火する$モノトスル。
この~eventは、
~pointerが捕捉から解放された後に生じるどの~eventよりも先に発火するモノトスル。
~pointerによる後続な~eventのうち［
`click$et, `auxclick$et, `contextmenu$et
］~eventを除くすべてにおいて、
その~targetは，通常の`~pointing先$になる。
［
`§ ~pointer捕捉の解放-法＠#releasing-pointer-capture$ ／
`§ ~pointer捕捉の暗黙的な解放-法＠#implicit-release-of-pointer-capture$ ／
`§ 処理待ち~pointer捕捉の処理-法＠#process-pending-pointer-capture$
］を見よ。
◎
The user agent MUST fire a pointer event named lostpointercapture after pointer capture is released for a pointer. This event MUST be fired prior to any subsequent events for the pointer after capture was released. This event is fired at the element from which pointer capture was removed. All subsequent events for the pointer except click, auxclick, and contextmenu events follow normal hit testing mechanisms (out of scope for this specification) for determining the event target. See the releasing pointer capture, implicit release of pointer capture, and process pending pointer capture sections.
</p>

				</section>
				<section id="the-click-auxclick-and-contextmenu-events">
<h3 title="The click, auxclick, and contextmenu events">5.3.12. `click^et ／ `auxclick^et ／ `contextmenu^et ~event</h3>

<p>
この節は、
`UIEVENTS$r にて定義される［
`click$et, `auxclick$et, `contextmenu$et
］~eventに対する追加である。
これらの~eventは、
概して~UIの作動化に束ねられており，
~pointerでない入力~装置（~keyboardなど）からも発火されるので。
◎
This section is an addition to click, auxclick and contextmenu events defined in [UIEVENTS]. These events are typically tied to user interface activation, and are fired even from non-pointer input devices, such as keyboards.
</p>

<p>
これらの~eventは、
`PointerEvent$I になるモノトスル
— 加えて、
この節を成す以降に言及される追加的な要件の~subjectになる。
◎
These events MUST be of type PointerEvent, and are subject to the additional requirements mentioned in the rest of this section.
</p>

					<section id="event-attributes">
<h5 title="Event attributes">5.3.12.1. ~event属性</h5>

<p>
これらの~event用の `PointerEvent$I に特有な属性（この仕様にて定義されるもの）は、
次を除き，既定の値をとるモノトスル
⇒
［
`pointerId$m ／ `pointerType$m
］属性は、
当の~eventを生成させたものに応じて
⇒＃
~pointing装置ならば，当の~eventを生じさせた`~pointer~event$と同じになるモノトスル ／
他の装置（~voice認識~softwareや~keyboardとのヤリトリなど）ならば，［ −1 ／ 空~文字列 ］になるモノトスル
◎
For these events, all PointerEvent specific attributes (defined in this spec) other than pointerId and pointerType MUST have their default values. In addition:
• If the events are generated by a pointing device, their pointerId and pointerType MUST be the same as the PointerEvents that caused these events.
• If the events are generated by a non-pointing device (such as voice recognition software or a keyboard interaction), pointerId MUST be -1 and pointerType MUST be an empty string.
</p>

					</section>
					<section id="event-coordinates">
<h5 title="Event coordinates">5.3.12.2. ~event座標</h5>

<p>
`CSSOM-VIEW$r は、
<a href="#pointerevent-interface">§ `PointerEvent^I</a>
にて注記したとおり，各種~座標~prop
（ `screenX^m, `screenY^m, `pageX^m, `pageY^m, `clientX^m, `clientY^m, `x^m, `y^m, `offsetX^m, `offsetY^m ）
の型を
— 小数付きな座標を許容するため —
`double^c として定義し直すよう提案する。
しかしながら、
この変更が［
定例の `MouseEvent$I ではない `PointerEvent$I に限って適用される
］と，［
`click$et ／ `auxclick$et ／`contextmenu$et
］の事例で［
旧来の~codeとの~web互換性の課題に至る
］ことが立証された。
この理由から、
`CSSOM-VIEW$r にて提案された変更を
`PointerEvent$I に限って実装した~UAは，［
`click$et ／ `auxclick$et ／ `contextmenu$et
］用の各種~座標~propを
`Math.floor$c `ECMASCRIPT$r を利用して
（元の `UIEVENTS$r にて定義されたとおりに）
`long^c 値に変換するモノトスル。
◎
As noted in PointerEvent, CSSOM View Module proposes to redefine the various coordinate properties (screenX, screenY, pageX, pageY, clientX, clientY, x, y, offsetX, offsetY) as double, to allow for fractional coordinates. However, this change — when applied only to PointerEvent, but not to regular MouseEvent — has proven to lead to web compatibility issues with legacy code in the case of click, auxclick, and contextmenu. For this reason, user agents that have implemented the proposed change in CSSOM View Module only for PointerEvent MUST convert the various coordinate properties for the click, auxclick, and contextmenu to long values (as defined in the original UI Events) using Math.floor [ECMASCRIPT].
</p>

					</section>
					<section id="event-dispatch">
<h5 title="Event dispatch">5.3.12.3. ~event配送</h5>

<div class="algo">
<p>
［
`click$et ／ `auxclick$et ／ `contextmenu$et
］~event %~event は、
`UIEVENTS$r にて定義される配送~処理nに従うモノトスル
— ただし、
%~event の`~target$は，次の~algoの結果に上書きするモノトスル：
◎
A click, auxclick or contextmenu event MUST follow the dispatch process defined in the [UIEVENTS] spec except that the event target is overridden using the algorithm below:
</p>
<ol>
	<li>
<p>
%利用者~event ~LET %~event を発火させた利用者ヤリトリ~event
【 %~event に先行して（直前に） %~event と同期的に発火された~event】
◎
Let event be the click, auxclick or contextmenu event being dispatched, and userEvent be the user interaction event that caused the firing of event.
</p>

<div class="note">
<p>注記：
%利用者~event は、
`PointerEvent$I でない場合もある
— 例えば，
`click$et ~eventが~checkboxに対し~space~barを叩いて生じたときは、
`KeyboardEvent$I になる。
◎
Note
Event userEvent could be a non-PointerEvent; for example, it is a KeyboardEvent when a click event dispatch is caused by hitting the spacebar on a checkbox element.
</p>

<p>
%利用者~event が `PointerEvent$I である場合、
%利用者~event は %~event に応じて：
◎
When userEvent is a PointerEvent,＼
</p>
		<ul>
			<li>
［
`click$et ／ `auxclick$et
］~eventであるならば `pointerup$et になる。
◎
userEvent is a pointerup for a click or auxclick event,＼
</li>
			<li>
`contextmenu$et ~eventであるならば［
`pointerdown$et ／ `pointerup$et
］~eventいずれかになる
（どちらになるかは、
~native~platformの規約に依存する）。
◎
and either a pointerdown or a pointerup event (depending on native platform convention) for a contextmenu event.
</li>
		</ul>
</div>
	</li>
	<li>
<p>
~IF［
~OR↓
］…
</p>
		<ul>
			<li>
%利用者~event は `PointerEvent$I でない
</li>
			<li>
%~event は `contextmenu$et ~eventである
</li>
			<li>
%利用者~event は それに対応する~pointerが捕捉されている間に配送された
</li>
		</ul>
<p>
…ならば
⇒
~RET %~event の`~target$
（すなわち、~targetを上書きしない）
</p>
◎
If userEvent is not a PointerEvent,＼
↑↑ dispatch event following the [UIEVENTS] spec without overriding event target and＼
skip the remaining steps below.
◎
Define target as follows:
◎
If event is a contextmenu event, or userEvent was dispatched while the corresponding pointer was captured, then let target be the target of userEvent.
</li>
	<li>
~Assert：［
%~event は［
`click$et ／ `auxclick$et
］~eventである
］~AND［
%利用者~event は `pointerup$et ~eventである
］
◎
Otherwise (event is a click or auxclick event for which userEvent is a pointerup event that was dispatched uncaptured)＼
</li>
	<li>
<p>
~RET %~event が配送される時点における［
%利用者~event に対応する `pointerdown$et の`~target$, %利用者~event の`~target$
］に`共通な広義-先祖$
◎
let target be the nearest common inclusive ancestor of the corresponding pointerdown and pointerup targets in the DOM at the moment event is being dispatched.
◎
↑↑ Dispatch event to target following the [UIEVENTS] spec.
</p>

<p class="note">注記：
%利用者~event が捕捉されていた場合、
同じ `pointerId$m を伴う `lostpointercapture$et ~eventが すでに配送された場合でも，
%~event は %利用者~event を`捕捉している~target$へ配送される。
◎
Note
If userEvent was captured, event is dispatched to the capturing target of userEvent even though the lostpointercapture event with the same pointerId has been dispatched already.
</p>
	</li>
</ol>
</div>

					</section>
				</section>
			</section>
		</section>
	<section id="events-wheelevents">
<h2 title="Wheel Events">6. ~wheel~event</h2>

<p>
~wheelは、
1 つ以上の空間的~次元にて回転できる装置であり，~pointing装置に結付けられ得る。
座標系は環境設定に依存する。
◎
Wheels are devices that can be rotated in one or more spatial dimensions, and which can be associated with a pointer device. The coordinate system depends on the environment configuration.
</p>

<p class="example">
利用者の環境は、［
横~scroll／縦~scroll／~zoom
］を［
x-軸／y-軸／z-軸
］に沿う回転に結付けるよう環境設定され得る。
◎
The user's environment might be configured to associate vertical scrolling with rotation along the y-axis, horizontal scrolling with rotation along the x-axis, and zooming with rotation along the z-axis.
</p>

<p>
`WheelEvent$I ~objの［
`deltaX$m ／ `deltaY$m ／ `deltaZ$m
］属性は、
各自の軸に沿う，いずれかの`測定~単位$による測定を指示する。
報告される測定は、
環境に特有な~algoが，~wheel装置の実際の［
回転や動き
］を［
適切な単位を伴う適切な値
］に翻訳した後に供される。
◎
The deltaX, deltaY, and deltaZ attributes of WheelEvent objects indicate a measurement along their respective axes in units of pixels, lines, or pages. The reported measurements are provided after an environment-specific algorithm translates the actual rotation/movement of the wheel device into the appropriate values and units.
</p>

<p>
【定義追加：】
`測定~単位@
とは、
画素~数, 行l数, ~page数の総称である。
</p>

<div class="trans-note">
<p>
原文には、
これらが何の計量に基づくかは，定義されていない。
次の定義が考えられるが：
</p>
<ul>
	<li>
画素~数は、
~CSS `px^css 単位
（機器~画素~単位ではなく）。
</li>
	<li>
行数は、
`根~要素$の~CSS `line-height^p ~propに基づく。
</li>
	<li>
~page数は、
よくある~computer~screenの下では，`表示域$（ `viewport^en ）の寸法に基づく。
</li>
</ul>
</div>

<p class="note">注記：
利用者は、
~wheel装置の実際の［
回転／動き
］を異なる仕方で解釈させるよう環境設定を~custom化し得る。
共通的な “`dented^en” 【？】 ~mouse~wheelの一回の動きは、
何~画素か（実際の値は ~UAの現在の~screen寸法に依存する）に測定されるが、
利用者は、
自身の環境設定を変更して この数を増大させ，~mouse~wheelを速めることもある。
更には，
~mouse~wheel~softwareには、
加速機能
（~wheelを速く［
回転する／動かす
］ほど，各~測定の`~delta$が大きくなる）
を~supportするものや，
1 画素~単位より精細に`回転$を測定するものもある。
よって作者は、［
ある~UAにおける`回転$量が，他の~UAにおいても同じ`~delta$値を生産する
］と見做すことはできない。
◎
Note

A user's environment settings can be customized to interpret actual rotation/movement of a wheel device in different ways. One movement of a common dented mouse wheel can produce a measurement of 162 pixels (162 is just an example value, actual values can depend on the current screen dimensions of the user-agent). But a user can change their default environment settings to speed-up their mouse wheel, increasing this number. Furthermore, some mouse wheel software can support acceleration (the faster the wheel is rotated/moved, the greater the delta of each measurement) or even sub-pixel rotation measurements. Because of this, authors can not assume a given rotation amount in one user agent will produce the same delta value in all user agents.
</p>

<p>
［
`deltaX^m ／ `deltaY^m ／ `deltaZ^m
］属性~値の正負は、
実際の~wheel装置が同じ方向に［
回転する間, 動く間
］は， `wheel$et ~eventの複数の発火において一貫するモノトスル。
~UAは、［
`wheel$et ~eventの既定~動作として~scrollする場合
］の`~delta$の符号を
`右手~座標系@
で
— すなわち，［
X／Y／Z
］軸の正な方向が，`文書$の［
右方／下方／奥方（利用者から遠ざかる）
］を向くように —
与えるベキである。
◎
The sign (positive or negative) of the values of the deltaX, deltaY, and deltaZ attributes MUST be consistent between multiple dispatches of the wheel event while the motion of the actual wheel device is rotating/moving in the same direction. If a user agent scrolls as the default action of the wheel event then the sign of the delta SHOULD be given by a right-hand coordinate system where positive X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.
</p>

<p class="note">注記：
~wheelの物理的な操作oに対する解釈は、
個々の~UAに応じて
（あるいは~UAや~hardwareの環境設定に依存して）
異なることもある。
例えば，~trackpadの淵で上から下へ~swipeされたとき、
下への~page~scrollを意図する~wheel動作として解釈されることもあれば，
その逆に解釈されることもある
（すなわち， `deltaY^m 値は、
前者が正に, 後者が負に）。
◎
Note

Individual user agents can (depending on their environment and hardware configuration) interpret the same physical user interaction on the wheel differently. For example, a vertical swipe on the edge of a trackpad from top to bottom can be interpreted as a wheel action intended to either scroll the page down or to pan the page up (i.e., resulting in either a positive or negative deltaY value respectively).
</p>

<p>
`~wheel~event~transaction@
とは、
ある単独の利用者~gestureに結付けられる【から生じる】一連の~wheel~eventである。
`~UA$は、
それらのうち最初の~wheel~eventが発火されたとき，［
実装に特有な時間
【言い換えれば、単独の~gestureが成し得る最大な時間】
内で生じる後続な~wheel~eventすべて
］が同じ要素を~targetにできるよう，
`~wheel~event~transaction$を作成するモノトスル。
各`~wheel~event~transaction$には、
それを成す最初の~wheel~eventが生じた時点における`最上層な~event~target$が結付けられるモノトスル。
◎
A user agent MUST create a wheel event transaction when the first wheel event is fired, so that all subsequent wheel events within a implementation-specific amount of time can be targetted at the same element. A wheel event transaction is series of wheel events that are associated with a single user gesture. The wheel event transaction MUST have an associated event target that is the topmost event target at the time the first wheel event occurs in the group.
</p>

<p class="example">
ある~scroll可能な要素~内のどこかを~targetにする一連の~wheel~eventが，
ある子~要素から開始された場合、
当の子~要素が，同じ利用者~gesture用の後続な~eventが生じ得る要素になる。
◎
If a series of wheel events targetted in a scrollable element start above a child element, later events for the same user gesture may occur over the child element.
</p>

		<section id="interface-wheelevent">
<h3 title="Interface WheelEvent">6.1. `WheelEvent^I ~interface</h3>

<p>
`WheelEvent$I ~interfaceは、
`wheel$et ~eventに特有な文脈l情報を供する。
◎
The WheelEvent interface provides specific contextual information associated with wheel events.＼
</p>

<p>
`WheelEvent$I ~interfaceの~instanceを作成するためには、
その構築子に `WheelEventInit$I 辞書（省略可能）を渡して呼び出す。
◎
To create an instance of the WheelEvent interface, use the WheelEvent constructor, passing an optional WheelEventInit dictionary.
</p>

			<section id="idl-wheelevent">
<h4 title="WheelEvent">6.1.1. `WheelEvent^I</h4>

<pre class="idl">
[`Exposed$=Window]
interface `WheelEvent@I : `MouseEvent$I {
    `constructor@(`DOMString$ %type, optional `WheelEventInit$I %eventInitDict = {});

    /* <span class="comment">
`deltaMode^m 値がとり得る定数
◎
DeltaModeCode</span> */
    const `unsigned long$ `DOM_DELTA_PIXEL$m = 0x00;
    const `unsigned long$ `DOM_DELTA_LINE$m = 0x01;
    const `unsigned long$ `DOM_DELTA_PAGE$m = 0x02;

    readonly attribute `double$ `deltaX$m;
    readonly attribute `double$ `deltaY$m;
    readonly attribute `double$ `deltaZ$m;
    readonly attribute `unsigned long$ `deltaMode$m;
};
</pre>

<dl class="idl-def">
	<dt>`DOM_DELTA_PIXEL@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、
`~delta$用の`測定~単位$は，画素~数になるモノトスル。
これは、
ほとんどの~OSや実装の環境設定における，最も代表的な事例である。
◎
The units of measurement for the delta MUST be pixels. This is the most typical case in most operating system and implementation configurations.
</dd>

	<dt>`DOM_DELTA_LINE@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、
`~delta$用の`測定~単位$は，~textの行l数になるモノトスル。
これは，多くの~form~controlに該当する。
◎
The units of measurement for the delta MUST be individual lines of text. This is the case for many form controls.
</dd>

	<dt>`DOM_DELTA_PAGE@m</dt>
	<dd>
`deltaMode$m 属性がこの値をとる場合、
`~delta$用の`測定~単位$は，［
単独の~screen, ~page~~区分
］いずれかに基いて定義される~page数になるモノトスル。
◎
The units of measurement for the delta MUST be pages, either defined as a single screen or as a demarcated page.
</dd>

	<dt>`deltaX@m</dt>
	<dt>`deltaY@m</dt>
	<dt>`deltaZ@m</dt>
	<dd>
`wheel$et ~eventの既定~動作が~scrollである~UAにおいては、
~eventが取消されなかった場合の値は，
当該の軸に沿って~scrollされることになる（いずれかの`測定~単位$による）測定になるモノトスル。
他の場合、
これは，実装に特有な［
当該の軸~周りの~wheel装置の動きの（いずれかの`測定~単位$による）測定
］になる。
◎
In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the x-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the x-axis.＼
The un-initialized value of this attribute MUST be 0.0.
◎
In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the y-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the y-axis.＼
The un-initialized value of this attribute MUST be 0.0.
◎
In user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the z-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the z-axis.＼
The un-initialized value of this attribute MUST be 0.0.
</dd>

	<dd>
`未初期化~値$： 0.0
◎
↑</dd>

	<dt>`deltaMode@m</dt>
	<dd>
`deltaMode^m 属性~値は、
`~delta$値~用の`測定~単位$を指示する。
既定~値は `DOM_DELTA_PIXEL$m （画素~数）。
◎
The deltaMode attribute contains an indication of the units of measurement for the delta values. The default value is DOM_DELTA_PIXEL (pixels).＼
</dd>
	<dd>
この属性は、［
`~delta$値~用の`測定~単位$を指示する，いずれかの `DOM_DELTA_…^m 定数
］に設定するモノトスル。
精確な測定は，［
装置／~OS／~app
］の環境設定に特有になる。
◎
This attribute MUST be set to one of the DOM_DELTA constants to indicate the units of measurement for the delta values. The precise measurement is specific to device, operating system, and application configurations.＼
</dd>
	<dd>
`未初期化~値$： 0
◎
The un-initialized value of this attribute MUST be 0.
</dd>
</dl>

			</section>
			<section id="idl-wheeleventinit">
<h4 title="WheelEventInit">6.1.2. `WheelEventInit^I</h4>

<pre class="idl">
dictionary `WheelEventInit@I : `MouseEventInit$I {
    `double$ `deltaX@mb = 0.0;
    `double$ `deltaY@mb = 0.0;
    `double$ `deltaZ@mb = 0.0;
    `unsigned long$ `deltaMode@mb = 0;
};
</pre>

<p>
この辞書の各~memberは、
`WheelEvent$I ~obj上の同じ名前の属性を初期化する。
各自がとり得る値とその意味については、
その~interface定義の記述を見よ。
◎
deltaX
• See deltaZ attribute.
◎
deltaY
• See deltaZ attribute.
◎
deltaZ
• Initializes the deltaZ attribute of the WheelEvent object. Relative positive values for this attribute (as well as the deltaX and deltaY attributes) are given by a right-hand coordinate system where the X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively. Negative relative values are in the respective opposite directions.
◎
deltaMode
• Initializes the deltaMode attribute on the WheelEvent object to the enumerated values 0, 1, or 2, which represent the amount of pixels scrolled (DOM_DELTA_PIXEL), lines scrolled (DOM_DELTA_LINE), or pages scrolled (DOM_DELTA_PAGE) if the rotation of the wheel would have resulted in scrolling.
</p>

			</section>
		</section>
		<section id="events-wheel-types">
<h3 title="Wheel Event Types">6.2. 各種~wheel~event型</h3>

			<section id="wheel">
<h4 title="wheel">6.2.1. `wheel^et</h4>

<div>
◎イ型 `wheel@et
◎界面 `WheelEvent$I
◎同期 なし
◎浮上 する
◎標的 `Element$I
◎取消 `文脈依存＠#cancelability-of-wheel-events$
◎構 Yes
◎既定動作 
文書を~scroll（または~zoom）する
◎文脈
<p>
次を除き，`§ 各種~mouse~eventに共通な文脈~情報$を見よ：
</p>
<ul>
	<li>
`target$m：
現在の`~wheel~event~transaction$用の~target
</li>

	<li>
<p>
~wheelが~pointing装置に結付けられていない場合、
`MouseEvent$I の：
</p>
		<ul>
			<li>
次に挙げる属性は 0 【すなわち，`未初期化~値$】になる
⇒＃
`screenX$m,
`screenY$m,
`clientX$m,
`clientY$m,
`button$m,
`buttons$m
</li>
			<li class="trans-note">【
`layerX$m, `layerY$m も，前項と同様になると思われるが、
原文には言及されていない。
】</li>
			<li class="trans-note">【
`relatedTarget$m は， ~NULL （`未初期化~値$）になると思われるが、
原文には言及されていない。
】</li>
		</ul>
	</li>
	<li>
`WheelEvent$I の［
`deltaX$m ／
`deltaY$m ／
`deltaZ$m
］：
［
X ／ Y ／ Z
］軸~周りの~wheel装置の動きを~~反映する量であって、［
~pageが `deltaMode$m 単位に従って，その軸に沿って~scrollする量
］であるか，または実装に特有な値
</li>
	<li>
`deltaMode$m：
［
`deltaX$m ／ `deltaY$m ／ `deltaZ$m
］属性~用の（いずれかの`測定~単位$を表現する）単位~指示子
</li>
</ul>
◎表終

◎
Type 	wheel
Interface 	WheelEvent
Sync / Async 	Async
Bubbles 	Yes
Trusted Targets 	Element
Cancelable 	Varies
Composed 	Yes
Default action 	Scroll (or zoom) the document
Context
(trusted events) 	

• Event.target : element target for the current wheel event transaction
• UIEvent.view : Window
• UIEvent.detail : 0
• MouseEvent.screenX : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0
• MouseEvent.screenY : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0
• MouseEvent.clientX : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0
• MouseEvent.clientY : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0
• MouseEvent.altKey : true if Alt modifier was active, otherwise false
• MouseEvent.ctrlKey : true if Control modifier was active, otherwise false
• MouseEvent.shiftKey : true if Shift modifier was active, otherwise false
• MouseEvent.metaKey : true if Meta modifier was active, otherwise false
• MouseEvent.button : if wheel is associated with a pointing device, value based on current button pressed, otherwise 0
• MouseEvent.buttons : if wheel is associated with a pointing device, value based on all buttons current depressed, 0 if no buttons pressed
• MouseEvent.relatedTarget : indicates the target the pointing device is pointing at, if any
• WheelEvent.deltaX : expected amount that the page will scroll along the x-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the x-axis
• WheelEvent.deltaY : expected amount that the page will scroll along the y-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the y-axis
• WheelEvent.deltaZ : expected amount that the page will scroll along the z-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the z-axis
• WheelEvent.deltaMode : unit indicator (pixels, lines, or pages) for the deltaX, deltaY, and deltaZ attributes
</div>

<p>
~UAは、
~mouse~wheelが いずれかの軸~周りで回転されたとき
— あるいは、
等価な入力~装置
（~mouse-ballや, ある種の~tabletや~touchpad, 等々）
が そのような動作を模倣したとき —
この~eventを発火するモノトスル。
同時に複数の軸が回転された場合の~wheel`~delta$は、
~platformや入力~装置に依存して，［
単独の `wheel$et ~eventにまとめて, あるいは
軸ごとに別々な `wheel$et ~eventとして
］送達されることもある。
◎
A user agent MUST dispatch this event when a mouse wheel has been rotated around any axis, or when an equivalent input device (such as a mouse-ball, certain tablets or touchpads, etc.) has emulated such an action. Depending on the platform and input device, diagonal wheel deltas MAY be delivered either as a single wheel event with multiple non-zero axes or as separate wheel events for each non-zero axis.＼
</p>

<p>
`wheel$et ~event型の代表的な`既定~動作$は、
指示された量だけ文書を~scrollする
（あるいは一部の事例では，~zoomする）。
この~eventが取消された場合、
実装は，文書を［
~scroll／~zoom
］しないモノトスル
（あるいは，何であれ、
この~event型に結付けられた他の実装に特有な既定~動作も）。
◎
The typical default action of the wheel event type is to scroll (or in some cases, zoom) the document by the indicated amount. If this event is canceled, the implementation MUST NOT scroll or zoom the document (or perform whatever other implementation-specific default action is associated with this event type).
</p>

<p class="note">注記：
`~UA$や入力~装置によっては、
~wheelが回される速さも`~delta$値に影響し得る
— 速いほど高い`~delta$値を生産するよう。
◎
Note

In some user agents, or with some input devices, the speed that the wheel has been turned can affect the delta values, with a faster speed producing a higher delta value.
</p>

			</section>
			<section id="cancelability-of-wheel-events">
<h4 title="cancelability of wheel events">6.2.2. `wheel^et ~eventの取消~可否</h4>

<p>
`wheel$et ~eventに対し `preventDefault()$m を~callした場合、
~scrollingを［
防止-／中断-
］し得る。
~UAは，~scroll処理能を最大にするためとして、
~scrollに結付けられた `wheel^et ~event連列を成す各~eventに対し，それが
— 取消されたかどうか見るために —
処理されるまで待機しなくてもヨイ。
そのような事例では、
~UAは，生成する `wheel^et ~eventの `cancelable$m を ~F にするべきである
— これは、
`preventDefault()$m を利用しても，~scrollingを［
防止-／中断-
］し得ないことを指示する。
他の場合、
`cancelable$m は ~T になる。
◎
Calling preventDefault on a wheel event can prevent or otherwise interrupt scrolling. For maximum scroll performance, a user agent may not wait for each wheel event associated with the scroll to be processed to see if it will be canceled. In such cases the user agent should generate wheel events whose cancelable property is false, indicating that preventDefault cannot be used to prevent or interrupt scrolling. Otherwise cancelable will be true.
</p>

<p>
特に，~UAは、
~event用の`受動的でない~listenerは無いことを観測した＠~DOM4#observing-event-listeners$ならば，
生成するどの `wheel$et ~eventも取消~不能にする【 `cancelable^m を ~F にする】ベキである。
◎
In particular, a user agent should generate only uncancelable wheel events when it observes that there are no non-passive listeners for the event.
</p>
			</section>
		</section>
	</section>
	<section id="extensions-to-the-element-interface">
<h2 title="Extensions to the Element interface">7. `Element^I ~interfaceに対する拡張</h2>

<p>
以下の各~節では、
既存の `Element$I ~interfaceに対する
— ~scriptが~pointer捕捉を［
設定する／解放する
］ことを手助けするための —
拡張を述べる。
◎
The following section describes extensions to the existing Element interface to facilitate the setting and releasing of pointer capture.
</p>

<pre class="idl">
partial interface `Element$I {
    `undefined$ `setPointerCapture$m(`long$ %pointerId);
    `undefined$ `releasePointerCapture$m(`long$ %pointerId);
    `boolean$ `hasPointerCapture$m(`long$ %pointerId);
};
</pre>

<dl class="idl-def">
	<dt>`setPointerCapture(pointerId)@m</dt>
	<dd>
コレが［
%pointerId により識別される~pointer
］を`捕捉-$するよう設定する
— `§ ~pointer捕捉の設定-法＠#setting-pointer-capture$
を見よ。
◎
Set pointer capture for the pointer identified by the argument pointerId to the element on which this method is invoked.＼
</dd>
	<dd>
当の~pointerにより生じる後続な各~eventに対しては、
通常の`接触判定$の結果【それらの~target】は，コレで代用されるようになる
— 当の~pointerが常に それを捕捉している~target（コレ）に重なっているかのように。
この捕捉が解放されるまでは、
常にコレを~targetにするモノトスル。
◎
For subsequent events of the pointer, the capturing target will substitute the normal hit testing result as if the pointer is always over the capturing target, and they MUST always be targeted at this element until capture is released.＼
</dd>
	<dd>
この~methodが有効果になるのは、
~pointerの~buttonが`作動~状態$にあるときに限られる
— そうでないときは、
何もしないモノトスル。
◎
The pointer MUST be in its active buttons state for this method to be effective, otherwise it fails silently.＼
</dd>
	<dd>
%pointerId が`作動中$な どの~pointerにも合致しない場合、
`NotFoundError$E 例外が投出される。
◎
When the provided method's argument does not match any of the active pointers, throw a "NotFoundError" DOMException.
</dd>

	<dt>`releasePointerCapture(pointerId)@m</dt>
	<dd>
コレが`捕捉-$している［
%pointerId により識別される~pointer
］を明示的に解放する
— `§ ~pointer捕捉の解放-法＠#releasing-pointer-capture$
を見よ。
◎
Release pointer capture for the pointer identified by the argument pointerId from the element on which this method is invoked.＼
</dd>
	<dd>
当の~pointerにより生じる後続な各~eventに対し，それらの~targetを決定する際には、
通常の`接触判定$の仕組み【！(out of scope for this specification)】に従うようになる。
◎
Subsequent events for the pointer follow normal hit testing mechanisms (out of scope for this specification) for determining the event target.＼
</dd>
	<dd>
%pointerId が`作動中$な どの~pointerにも合致しない場合、
`NotFoundError$E 例外が投出される。
◎
When the provided method's argument does not match any of the active pointers, throw a "NotFoundError" DOMException.
</dd>

	<dt>`hasPointerCapture(pointerId)@m</dt>
	<dd>
コレが［
%pointerId により識別される~pointer
］を`捕捉-$しているかどうかを指示する。
すなわち、［
%pointerId 用の`処理待ち捕捉~target$ ~EQ コレ ならば ~T ／
~ELSE_ ~F
］を返す。
◎
Indicates whether the element on which this method is invoked has pointer capture for the pointer identified by the argument pointerId. In particular, returns true if the pending pointer capture target override for pointerId is set to the element on which this method is invoked, and false otherwise.
</dd>
	<dd class="note">注記：
この~methodは、
`setPointerCapture()$m を~callした直後において当の要素が まだ `gotpointercapture$et ~eventを受取っていなくても，
~T を返す。
その結果、
`pointerdown$et ~event用の~listenerの内側から`暗黙的な~pointer捕捉＠#implicit-pointer-capture$を検出するときに有用になる。
◎
Note
This method will return true immediately after a call to setPointerCapture(), even though that element will not yet have received a gotpointercapture event. As a result it can be useful for detecting implicit pointer capture from inside of a pointerdown event listener.
</dd>
</dl>

	</section>
	<section id="extensions-to-the-globaleventhandlers-interface">
<h2 title="Extensions to the GlobalEventHandlers mixin">8. `GlobalEventHandlers^I ~mixinに対する拡張</h2>

<p>
この節では、
既存の `GlobalEventHandlers$I ~mixinに対する
— ~event~handlerの登録を手助けするための —
拡張を述べる
◎
The following section describes extensions to the existing GlobalEventHandlers mixin to facilitate the event handler registration.
</p>

<pre class="idl">
partial interface mixin `GlobalEventHandlers$I {
    attribute `EventHandler$I `onpointerover@m;
    attribute `EventHandler$I `onpointerenter@m;
    attribute `EventHandler$I `onpointerdown@m;
    attribute `EventHandler$I `onpointermove@m;
    [`SecureContext$] attribute `EventHandler$I `onpointerrawupdate@m;
    attribute `EventHandler$I `onpointerup@m;
    attribute `EventHandler$I `onpointercancel@m;
    attribute `EventHandler$I `onpointerout@m;
    attribute `EventHandler$I `onpointerleave@m;
    attribute `EventHandler$I `ongotpointercapture@m;
    attribute `EventHandler$I `onlostpointercapture@m;
};
</pre>

<p>
これらの属性は、
いずれも，対応する名前の~event
（ `ongotpointercapture$m は `gotpointercapture$et に対応する, 等々）
用の`~event~handler~IDL属性$ `HTML$r である。
◎
onpointerover
• The event handler IDL attribute for the pointerover event type.
◎
onpointerenter
• The event handler IDL attribute for the pointerenter event type.
◎
onpointerdown
• The event handler IDL attribute for the pointerdown event type.
◎
onpointermove
• The event handler IDL attribute for the pointermove event type.
◎
onpointerrawupdate
• The event handler IDL attribute for the pointerrawupdate event type.
◎
onpointerup
• The event handler IDL attribute for the pointerup event type.
◎
onpointercancel
• The event handler IDL attribute for the pointercancel event type.
◎
onpointerout
• The event handler IDL attribute for the pointerout event type.
◎
onpointerleave
• The event handler IDL attribute for the pointerleave event type.
◎
ongotpointercapture
• The event handler IDL attribute for the gotpointercapture event type.
◎
onlostpointercapture
• The event handler IDL attribute for the lostpointercapture event type.
</p>

	</section>
	<section id="extensions-to-the-navigator-interface">
<h2 title="Extensions to the Navigator interface">9. `Navigator^I ~interfaceに対する拡張</h2>

<p>
装置の検出~supportを供するため、
この仕様は，
`Navigator^I ~interface `HTML$r を拡張する。
◎
The Navigator interface is defined in [HTML]. This specification extends the Navigator interface to provide device detection support.
</p>

<pre class="idl">
partial interface `Navigator$I {
    readonly attribute `long$ `maxTouchPoints$m;
};
</pre>

<div class="algo">
<p>
`maxTouchPoints@m
取得子~手続きは：
◎
maxTouchPoints
• The getter steps are:
</p>
<ol>
	<li>
%模倣された最大~touch接触~数 ~LET 
`~WebDriver-BiDi模倣された最大~touch接触~数＠~WEBDRIVER-BIDI#webdriver-bidi-emulated-max-touch-points$( 【コレに`関連な設定群~obj$】 )
`WEBDRIVER-BIDI$r
◎
Let emulated maxTouchPoints be the result of WebDriver BiDi emulated max touch points [WEBDRIVER-BIDI].
</li>
	<li>
~IF［
%模倣された最大~touch接触~数 ~NEQ ~NULL
］
⇒
~RET %模倣された最大~touch接触~数
◎
If emulated maxTouchPoints is not null, return emulated maxTouchPoints.
</li>
	<li>
<p>
~RET 当の装置により~supportされる同時~touch接触の最大~数
— 当の装置が複数個の`~digitizer$を有する事例では
（例： 複数の~touchscreen）、
これは，各［
個々の~digitizerにより~supportされる最大~接触~数
］のうちの最大になるモノトスル。
◎
Return the maximum number of simultaneous touch contacts supported by the device. In the case of devices with multiple digitizers (e.g. multiple touchscreens), the value MUST be the maximum of the set of maximum supported contacts by each individual digitizer.
</p>

<p>
例えば、
装置が 3 個の~touchscreenを有していて，
~supportする同時~touch接触~数が 2, 5, 10 ならば、
結果は 10 になるべきである。
◎
For example, suppose a device has 3 touchscreens, which support 2, 5, and 10 simultaneous touch contacts, respectively. The value of maxTouchPoints should be 10.
</p>
	</li>
</ol>
</div>

<p class="note">注記：
`maxTouchPoints$m に対する 0 より大きい値が，
利用者の装置が~touch入力を~supportすることを指示するとしても、
利用者が~touch入力を利用している`とは限らない^em。
作者は、
~system上に在り得る他の入力~様式
— ~mouse, ~pen, ~screen~reader, など —
も考慮するよう気を付けるべきである。
◎
Note
While a maxTouchPoints value of greater than 0 indicates the user's device is capable of supporting touch input, it does not necessarily mean the user will use touch input. Authors should be careful to also consider other input modalities that could be present on the system, such as mouse, pen, or screen readers.
</p>

<p class="note">注記：
`maxTouchPoints$m は、［
現在の~hardwareでも，内容のヤリトリ~modelを認識できる
］ことを確保するために利用されることが多い。
~hardware~~能力がより限られた下でも、
利用者に~UI~affordanceを供することはできる。
精確な最大~接触~数が既知でない~platform上では、
認識されることが保証される最小~数が供される。
したがって、
認識される~touch接触~数が `maxTouchPoints$m の値を超過する可能性もある。
◎
Note
maxTouchPoints is often used to ensure that the interaction model of the content can be recognized by the current hardware. UI affordances can be provided to users with less capable hardware. On platforms where the precise number of touch points is not known, the minimum number guaranteed to be recognized is provided. Therefore, it is possible for the number of recognized touch points to exceed the value of maxTouchPoints.
</p>

	</section>
	<section id="declaring-direct-manipulation-behavior">
<h2 title="Declaring direct manipulation behavior">10. 直な操作の挙動の宣言-法</h2>

<p>
`§ 各種 属性と既定~動作＠#attributes-and-default-actions$
にて注記したとおり、
表示域~操作（~pan-zoom）は，~pointer~eventを取消しても抑止できない。
作者は，代わりに、
`touch-action$p ~CSS~propを利用して，［
これらの挙動のうち，どれを許容して どれを抑止したいと求めるか
］を宣言的に定義しなければナラナイ。
◎
As noted in Attributes and Default Actions, viewport manipulations (panning and zooming) cannot be suppressed by canceling a pointer event. Instead, authors must declaratively define which of these behaviors they want to allow, and which they want to suppress, using the touch-action CSS property.
</p>

<p class="note">注記：
表示域を操作するために利用される~pointerに関する課題は，一般に~touch入力に限られるが
（利用者の手指が［
内容とヤリトリする, ~pageを［
~panする／~zoomする
］］どちらにも利用され得る所で）、
他の`~pointer型$に対しても，（直接間接を問わず）同じ型の操作を許容する~UAもある。
一例として，［
~mobile／~tablet
］機器においては、
利用者は~stylusを利用して~scroll可能かもしれない。
歴史的な理由から、［
この仕様に定義される `touch-action$p ~CSS~propは，
~touch入力のみを指す
］ように見受けられるが，事実においては［
`直な~pan-zoom$を許容する形を成す~pointer入力
］すべてに適用される。
◎
Note
While the issue of pointers used to manipulate the viewport is generally limited to touch input (where a user's finger can both interact with content and pan/zoom the page), certain user agents may also allow the same types of (direct or indirect) manipulation for other pointer types. For instance, on mobile/tablet devices, users may also be able to scroll using a stylus. While, for historical reasons, the touch-action CSS property defined in this specification appears to refer only to touch inputs, it does in fact apply to all forms of pointer inputs that allow direct manipulation for panning and zooming.
</p>

		<section id="the-touch-action-css-property">
<h3 title="The touch-action CSS property">10.1. `touch-action^p ~CSS~prop</h3>

<div>
◎名 `touch-action@p
◎値 
`auto$v | `none$v | [ [ `pan-x$v | `pan-left$v | `pan-right$v ] || [ `pan-y$v | `pan-up$v | `pan-down$v ] ] | `manipulation$v
◎初 `auto$v
◎適 
次を除くすべての要素
⇒
`置換され$ない行内~要素【すなわち，`行内~box$】／~tableの［
`row^v,
`row-group^v,
`column^v,
`column-group^v
］
◎継 されない
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア ~animate不可
◎表終
◎
Name:	touch-action
Value:	auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] ] | manipulation
Initial:	auto
Applies to:	all elements except: non-replaced inline elements, table rows, row groups, table columns, and column groups
Inherited:	no
Percentages:	N/A
Media:	visual
Computed value:	same as specified value
Canonical order:	per grammar
Animation type:	not animatable
</div>

<p>
`touch-action$p ~propは、
`直な操作$（~propの名前にもかかわらず，~touchのみに制限されない）により，
~UAによる~pan-zoom用の挙動が誘発されてよいかどうかを決定する。
<a href="#details-of-touch-action-values">§ `touch-action^p 値</a>
を見よ。
◎
The touch-action CSS property determines whether direct manipulation interactions (which are not limited to touch, despite the property's name) MAY trigger the user agent's panning and zooming behavior. See the section on touch-action values.
</p>

<p>
［
~pan／~zoom
］が開始される直前にて， ~AND↓ が満たされるときは、
`~pointer~event~streamを抑止する$モノトスル
◎
Right before starting to pan or zoom, the user agent MUST suppress a pointer event stream if all of the following conditions are true:
</p>
<ul>
	<li>
~UAは、
`直な操作$を~pan-zoom用に消費するものと決定した
（その決定-法は、この仕様の視野から外れる）。
◎
The user agent has determined (via methods out of scope for this specification) that a direct manipulation interaction is to be consumed for panning or zooming,
</li>
	<li>
【当の`~event連列$の一部として】
~pointer用の `pointerdown$et ~eventを すでに送信した。
◎
a pointerdown event has been sent for the pointer, and
</li>
	<li>
~pointer用の［
 `pointercancel$et ／
（前項の `pointerdown$et に後続する） `pointerup$et
］~eventを まだ送信していない。
◎
a pointerup or pointercancel event (following the above mentioned pointerdown) has not yet been sent for the pointer.
</li>
</ul>

<p class="note">注記：
一部の~UAは、［
一連の別個な~gestureを孕むが，
それらが継続的な単独の~gestureを成すものとして扱われる
］ような挙動~用に，
複階的な~gestureを実装する。
例えば、
利用者が~touchscreen上で “投げつける” ように~scrollする（ “`fling to scroll^en” ）~gestureを考える
— 敏捷な手指の動きで，文書の~panningを開始して, ~touchscreenから手指を~~離したとき、
文書は惰性で~panし続けるような。
文書がまだ動いている間、
利用者は，~touchscreenに手指を置いて別の “投げつけ” を実行するかもしれない
— 現在の~panningに対し、
もっと勢いをつけるか，制動して［
遅める／停止する／逆~方向にする
］ような。
この仕様は、［
~gestureと挙動を どう実装するか，規範的に定義する
］ことはない
— 2 度目の~touchが（現在の~panningに対する 2 度目の［
“投げつけ” ／制動
］として解釈される前に）~pointer~eventを発火するか否か裁定することは、
~UAに委ねられる。
◎
Note
Some user agents implement complex gestures for behaviors that involve a series of separate discrete gestures, but which are all treated as part of a single continuous gesture. For example, consider a "fling to scroll" gesture on a touchscreen: a user starts panning the document with a rapid finger movement, lifts the finger from the touchscreen, and the document continues panning with simulated inertia. While the document is still moving, the user may place their finger on the touchscreen and execute another "fling" to provide further momentum for the panning, or counteract the current panning to slow it down, stop panning altogether, or reverse the direction of the panning. As this specification does not normatively define how gestures and behaviors are implemented, it is left up to the user agent to decide whether or not the second touch (before it is interpreted as a second "fling" or counteraction of the current panning) fires pointer events or not.
</p>

<p class="note">注記：
`touch-action$p は、
埋込まれた閲覧~文脈を通して適用される【！／~cascadeする】ことはない。
【！~cascadeしないのは他の~propも同様】
一例として、
`touch-action^p が ある `iframe$e に適用されたとしても，
`iframe^e の中で【 `iframe^e が埋込んでいる文書における】`直な~pan-zoom$用の挙動に効果を及ぼすことはない。
◎
Note
touch-action does not apply/cascade through to embedded browsing contexts. For instance, even applying touch-action to an &lt;iframe&gt; won't have any effect on the behavior of direct manipulation interactions for panning and zooming within the &lt;iframe&gt; itself.
</p>

		</section>
		<section id="determining-supported-direct-manipulation-behavior">
<h3 title="Determining supported direct manipulation behavior">10.2. ~supportされる直な操作の挙動の決定-法</h3>

<p>
利用者が，`直な操作$による~pointer（~touchscreen上の~touchや~stylusなど）を利用して要素とヤリトリするとき、
その入力による効果は，［
要素, その各~先祖
］の［
`touch-action$p ~propの値, および
`直な~pan-zoom$用の既定の挙動
］により次に従って決定される：
◎
When a user interacts with an element using a direct manipulation pointer (such as touch or stylus on a touchscreen), the effect of that input is determined by the value of the touch-action property, and the default direct manipulation behaviors of the element and its ancestors, as follows:
</p>
<ul>
	<li>
`直な~pan-zoom$は、
要素の座標~空間において許容されるならば，要素の `touch-action$p に
`適合する@
とされる。
~CSS変形が適用されている場合、
要素の座標~空間は，ここでの適合-度に影響する仕方で~screen座標から異なり得ることに注意。
例えば，要素の X 軸が~screenを基準に 90° 回転されている場合、
~screen座標~空間の Y 軸に平行になる。
◎
A direct manipulation interaction for panning and zooming conforms to an element's touch-action if the behavior is allowed in the coordinate space of the element. Note that if CSS transforms have been applied, the element's coordinate space may differ from the screen coordinate in a way that affects the conformity here; for example, the X axis of an element rotated by 90 degrees with respect to the screen will be parallel to the Y-axis of the screen coordinate.
</li>
	<li>
<p>
~UAが［
`~pointing先$の要素に対する`直な~pan-zoom$
］を~supportするかどうかは、
次に従う：
</p>
		<ul>
			<li>
<p>
【ある方向への】直な~panningは、
~AND↓ が満たされるとき，~supportされる：
</p>
				<ul>
					<li>
当の~panningは、
要素の `touch-action$p ~propに`適合する$
</li>
					<li>
［
要素は`~scroll容器$ `CSS-OVERFLOW-3$r である
］~OR［
【同じ方向への】直な~panningは、
要素の親に対しても~supportされる
］
</li>
				</ul>
◎
A direct manipulation interaction for panning is supported if it conforms to the touch-action property of each element between the hit tested element and its nearest inclusive ancestor that is a scroll container (as defined in [CSS-OVERFLOW-3]).
</li>
			<li>
<p>
直な~zoomingは、
~AND↓ が満たされるとき，~supportされる：
</p>
				<ul>
					<li>
当の~zoomingは、
要素の `touch-action$p ~propに`適合する$
</li>
					<li>
<p>
要素に応じて，次が満たされる：
</p>
						<ul class="switch">
							<li>
`文書~要素$である場合
⇒
要素の`~node文書$が`属する閲覧~文脈$は、
次を満たす
⇒
［
`~top-level閲覧~文脈$である
］~OR［
直な~zoomingは、
その`容器$bcに対しても~supportされる
］
</li>
							<li>
他の場合
⇒
直な~zoomingは、
要素の親に対しても~supportされる
</li>
						</ul>
					</li>
				</ul>
◎
A direct manipulation interaction for zooming is supported if it conforms to the touch-action property of each element between the hit tested element and the document element of the top-level browsing context (as defined in [HTML]).
</li>
		</ul>
	</li>
	<li>
~pan-zoomが開始され，［
その~gestureを`直な操作$による挙動として取扱うべきかどうか
］を~UAが決定して以降は、
その動作が終わるまでは，関連な `touch-action$p 値を変更しても無視されることになる。
一例として，
要素の `touch-action$p 値を，~scriptの `pointerdown$et ~handlerの中で~program的に `auto^v から `none^v に変更しても、
~pointerが作動中にある限り，~UAが当の入力に対する［
~pan／~zoom
］用の挙動を中止したり抑止することはない。
◎
Once panning or zooming has been started, and the user agent has already determined whether or not the gesture should be handled as a user agent direct manipulation behavior, any changes to the relevant touch-action value will be ignored for the duration of the action. For instance, programmatically changing the touch-action value for an element from auto to none as part of a pointerdown handler script will not result in the user agent aborting or suppressing any of the pan or zoom behavior for that input for as long as that pointer is active.
</li>
	<li>
類似に，
`touch-action$p 用の各種 `pan-*^v 値の事例では、
~UAは，~gestureの開始-時に~gestureを直に取扱うかどうか決定したなら，
後続して当の~gestureの方向が変化しても
— 当の~pointerが作動中にある限り —
無視するベキである。
一例として，
ある要素の `touch-action^p が `pan-y*^v に設定されている下で
（すなわち、~UAは縦方向への~panningしか取扱わない），
~touchによる~gestureが横方向から開始された場合、
その~gestureの方向が
— 利用者の手指が まだ~screenに~touchしている間に —
縦方向に変化しても，縦方向への~panningは生じるべきでない。
◎
Similarly, in the case of the various touch-action values of pan-*, once the user agent has determined whether to handle a gesture directly or not at the start of the gesture, a subsequent change in the direction of the same gesture SHOULD be ignored by the user agent for as long as that pointer is active. For instance, if an element has been set to touch-action: pan-y (meaning that only vertical panning is handled by the user agent), and a touch gesture starts off horizontally, no vertical panning should occur if the user changes the direction of their gesture to be vertical while their finger is still touching the screen.
</li>
</ul>

<p class="note">注記：
一部の~UAは、
複数の同時並行な~pointerを孕むような~pan-zoomも~supportする
（例： 複-~touch）。
複数の同時並行な~pointerに対し `touch-action$p 値を［
処理する／結付ける
］ための手法は、
この仕様の視野から外れる。
◎
Note
Some user agents support panning and zooming interactions involving multiple concurrent pointers (e.g. multi-touch). Methods for processing or associating the touch-action values of multiple concurrent pointers is out of scope for this specification.
</p>

		</section>
		<section id="details-of-touch-action-values">
<h3 title="Details of touch-action values">10.3. `touch-action^p 値の詳細</h3>

<p>
`touch-action$p ~propは、
`直な操作$用の挙動のうち，表示域の~pan-zoomに関係するものを受持つ。
この~propは、
他の追加的な~UAの挙動
— ［
~textを選択したり強調する／
~linkや~form~controlを作動化する
］など —
には影響しないモノトスル。
◎
The touch-action property covers direct manipulation behaviors related to viewport panning and zooming. Any additional user agent behaviors, such as text selection/highlighting, or activating links and form controls, MUST NOT be affected by this CSS property.
</p>

<p class="note">注記：
用語
“~panning” と “~scrolling”
は、
同義語と見なされる
（もっと詳しく言うなら、
“~panning” とは`直な操作$による入力を利用している “~scrolling” である）。
［
~panningや~scrollingを誘発する［
ヤリトリや~gesture
］を定義することや，値［
`auto$v ／ `none$v
］用の誘発の挙動は、
この仕様の視野から外れる。
◎
Note
The terms "panning" and "scrolling" are considered synonymous (or, more aptly, "panning" is "scrolling" using a direct manipulation input). Defining an interaction or gesture for triggering panning/scrolling, or for triggering behavior for the auto or none values, are out of scope for this specification.
</p>

<dl>
	<dt>`auto@v</dt>
	<dd>
~UAは、［
要素から始まる`直な操作$
］に対し，［
表示域の~pan-zoomに関係する挙動
］のうち許可されるものを考慮してもヨイ。
◎
The user agent MAY consider any permitted direct manipulation behaviors related to panning and zooming of the viewport that begin on the element.
</dd>

	<dt>`none@v</dt>
	<dd>
［
要素から始まる`直な操作$
］に対し，［
表示域の~pan-zoomに関係する挙動
］を誘発しないモノトスル。
◎
Direct manipulation interactions that begin on the element MUST NOT trigger behaviors related to viewport panning and zooming.
</dd>

	<dt>`pan-x@v</dt>
	<dt>`pan-left@v</dt>
	<dt>`pan-right@v</dt>
	<dt>`pan-y@v</dt>
	<dt>`pan-up@v</dt>
	<dt>`pan-down@v</dt>
	<dd>
これらの~~成分~値の組み合わせに対しては、
~UAは，［
要素から始まる`直な操作$
］を［
指定された各~~成分が表す方向への~panningを開始する目的
］に限って考慮してもヨイ。
【例： `pan-y^v のみなら縦のみ， `pan-x pan-up^v なら縦と上方。】
◎
The user agent MAY consider direct manipulation interactions that begin on the element only for the purposes of panning that starts in any of the directions specified by all of the listed values.＼
</dd>
	<dd>
逆~方向が許容されていない場合でも【例： `pan-right^v のときの左方】、
~panningが開始されたなら，利用者は逆~方向にも~panできる。
対照的に，片方の軸に制約されている場合
（一例として，［
`pan-x^v, `pan-y^v
］いずれかのみ）
には、
利用者が~panできる方向は，常にその軸に限られる。
◎
Once panning has started, the direction may be reversed by the user even if panning that starts in the reversed direction is disallowed. In contrast, when panning is restricted to a single axis (for instance, with pan-x or pan-y), the axis cannot be changed during panning.
</dd>

	<dt>`manipulation@v</dt>
	<dd>
［
要素から始まる`直な操作$
］を［
~panning／<strong>継続的</strong>な~zooming
］の目的において考慮してもヨイ
— ただし，関係する他の挙動のうち［
一定時間内に起こらなければならない複数の作動化
］に依拠するもの（
二連-~tapで~zoomする／
二連-~tapの最後に手指を離さず（ `double-tap and hold^en ）動かして~zoomする
など）は、
誘発しないモノトスル。
◎
The user agent MAY consider direct manipulation interactions that begin on the element only for the purposes of panning and continuous zooming (such as pinch-zoom), but MUST NOT trigger other related behaviors that rely on multiple activations that must happen within a set period of time (such as double-tap to zoom, or double-tap and hold for single-finger zoom).
</dd>
</dl>

<p class="note">注記：
各 実装に共通な，
`touch-action$p 用の`追加的な値＠~COMPAT#touch-action$も
`COMPAT$r にて定義されている。
◎
Note
Additional touch-action values common in implementations are defined in [COMPAT].
</p>

<p class="note">注記：
`touch-action$p ~propが適用される要素は、［
`width$p, `height$p
］どちらの~CSS~propも~supportする【`適用される＠~CASCADE#apply$】ものに限られる【！ (see [CSS21])】。
この制約は、
~UAが`直な~pan-zoom$に対する応答性の最適化を手助けするための設計である。
作者は、
既定では~supportしない要素
— 既定では`行内~box$【！`置換され$ない`行内~要素$】になる `span$e など —
用には，その `display$p ~propに［
当の要素が［
`width^p, `height^p
］を~supportするようになる値
］
— `block^v など —
を設定できる。
将来の仕様は、
この~APIをすべての要素にまで拡張し得る。
◎
Note
The touch-action property only applies to elements that support both the CSS width and height properties (see [CSS21]). This restriction is designed to facilitate user agent optimizations for low-latency direct manipulation panning and zooming. For elements not supported by default, such as &lt;span&gt; which is a non-replaced inline element, authors can set the display CSS property to a value, such as block, that supports width and height. Future specifications could extend this API to all elements.
</p>

<div class="note">
<p>注記：
方向に特有な~pan値は、
一部の
“過~scroll（ `overscroll^en ）” 時の挙動†を~custom化するときに有用になる。
例えば、
文書の `touch-action$p を［
~scroll位置が 0 のときは `pan-x pan-down^v ／
他の場合は `pan-x pan-y^v 
］に設定すれば，単純な
“引っ張ったら~~更新する（ `pull-to-refresh^en ）”
効果††を実装できる。
これは、
~pointer~event~handlerが［
文書の上端から上方への［
~panning／~scrolling
］が開始されたときの挙動
］を定義することを許容する。
◎
Note
The direction-specific pan values are useful for customizing some overscroll behaviors. For example, to implement a simple pull-to-refresh effect the document's touch-action can be set to pan-x pan-down whenever the scroll position is 0 and pan-x pan-y otherwise. This allows pointer event handlers to define the behavior for upward panning/scrolling that start from the top of the document.
</p>

<p class="trans-note">【†
終端まで~scrollし切った所で，同じ方向に更に~scrollしようと~~操作した際に、
ある程度まで（空間が現れるように）~scrollしつつ，
~~操作し終えたときは ~scroll位置を終端に戻すような効果。
利用者にとっては、
内容がそこで終わりであること
（~touchの不正確さや~UIの~~操作~modelに因り~scrollできないわけではないこと）
が認識されやすくなる。
】【††
過~scroll時に，新たな更新~内容を要請し、
何か更新があれば，~~空いた空間をその内容で埋めるように挙動する~UI。
】</p>

<p>
方向に特有な各種~pan値は、［
~nativeに~scrollする要素の中で，~pointer~eventの取扱いを伴う（あるいは，その逆にする）
］ような，~customな~panningを実装する~componentを構成するためにも利用できる。
例えば，ある “画像~回転台” に `pan-y$v を利用すれば、［
文書の縦方向への~panningに干渉することなく，
横方向の~pan操作oに対し~pointer~eventを受取る
］ことを確保できるようになる。
回転台が~~右端に達したとき，
その `touch-action$p を `pan-y pan-right^v に変更すれば、
その端を超える後続な~scroll操作oは，アリなら表示域の中で文書を~scrollできるようになる。
［
~panning／~scrolling
］の挙動を途中で変更することは、
アリでない。
◎
The direction-specific pan values can also be used for composing a component that implements custom panning with pointer event handling within an element that scrolls natively (or vice-versa). For example, an image carousel may use pan-y to ensure it receives pointer events for any horizontal pan operations without interfering with vertical panning of the document. When the carousel reaches its right-most extent, it may change its touch-action to pan-y pan-right so that a subsequent scroll operation beyond its extent can scroll the document within the viewport if possible. It's not possible to change the behavior of a panning/scrolling operation while it is taking place.
</p>
</div>

<p class="note">注記：
一部の`直な~pan-zoom$用の既定の挙動を不能化すると、
~UAによる他の挙動に対する応答が素早くなることもある。
例えば，~UAによっては、
二連-~tap~gestureを取扱えるようにするため，
`click$et の前に 300ms ほどの遅延を自動的に入れるものもある。
そのような事例では、
`touch-action$p に明示的に値［
`none$v ／ `manipulation$v
］を設定することにより，この遅延は除かれることになる。
~tapや二連-~tap~gestureを決定するための手法については、
この仕様の視野から外れることに注意。
◎
Note
Disabling some default direct manipulation behaviors for panning and zooming may allow user agents to respond to other behaviors more quickly. For example, with auto user agents typically add 300ms of delay before click to allow for double-tap gestures to be handled. In these cases, explicitly setting touch-action: none or touch-action: manipulation will remove this delay. Note that the methods for determining a tap or double-tap gesture are out of scope for this specification.
</p>

		</section>

<div class="example">
<p>
`直な操作$用の挙動をすべて許容しない例：
◎
Example 9: Disallowing all direct manipulation behaviors
</p>

<pre class="lang-html">
&lt;div style="touch-action: none;"&gt;
<span class="comment">
この要素は、
`直な操作$のうち［
`touch-action^p が指定されていなければ~pan-zoomに至るもの
］に対しても，~pointer~eventを受取る。
◎
This element receives pointer events for all direct manipulation interactions that otherwise lead to panning or zooming.
</span>
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
横方向への~panningに限り許容する例：
◎
Example 10: Allowing horizontal panning only
</p>

<pre class="lang-html">
&lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、
横方向へ~panしていないときは~pointer~eventを受取る
◎
This element receives pointer events when not panning in the horizontal direction.
</span>
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
`直な~pan-zoom$用の挙動を許容しない子~領域がある例：
◎
Example 11: Child regions that disallow direct manipulation behaviors for panning and zooming
</p>

<pre class="lang-html">
&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: none;"&gt;
<span class="comment">
この要素は、
`直な操作$のうち［
`touch-action^p が指定されていなければ~pan-zoomに至るもの
］に対しても，~pointer~eventを受取る。
◎
This element receives pointer events for all direct manipulation interactions that otherwise lead to panning or zooming.
</span>
    &lt;/div&gt;
    &lt;div&gt;
<span class="comment">
この要素に対する`直な操作$は、
親を操作するために消費されてもヨイ。
◎
Direct manipulation interactions on this element MAY be consumed for manipulating the parent.
</span>
    &lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
`直な~pan-zoom$用の挙動を許容しない親が挟まれている例：
◎
Example 12: Intermediate parent that disallows direct manipulation behaviors for panning and zooming
</p>

<pre class="lang-html">
&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: pan-y;"&gt;
        &lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、
すべての`直な操作$に対し~pointer~eventを受取る
— 横方向への~panningに限り許容する要素と~scroll可能な要素（ `overflow: auto^css ）との間には、
縦方向の~panningに限り許容する先祖があるので。
したがって、
`直な~pan-zoom$用の挙動は，~UAにより取扱われない。
◎
This element receives pointer events for all direct manipulation interactions because
it allows only horizontal panning yet an intermediate ancestor
(between it and the scrollable element) only allows vertical panning.
Therefore, no direct manipulation behaviors for panning/zooming are
handled by the user agent.
</span>
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

<div class="example">
<p>
許容される`直な~pan-zoom$用の挙動を制約する親が挟まれている例：
◎
Example 13: Intermediate parent that restricts allowed direct manipulation behaviors for panning and zooming
</p>

<pre class="lang-html">
&lt;div style="overflow: auto;"&gt;
    &lt;div style="touch-action: pan-y pan-left;"&gt;
        &lt;div style="touch-action: pan-x;"&gt;
<span class="comment">
この要素は、
左方へ~panしていないときは~pointer~eventを受取る。
◎
This element receives pointer events when not panning to the left.
</span>
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</pre>
</div>

	</section>
	<section id="pointer-capture">
<h2 title="Pointer capture">11. ~pointer捕捉</h2>

		<section id="introduction">
<h3 title="Introduction">11.1. 序論</h3>

◎非規範的

<p>
`~pointer捕捉@
（ `pointer capture^en ）
により、
特定0の~pointerから生じる各~event（`互換性~mouse~event$も含む）の~targetを［
通常の`~pointing先$でない，特定0の要素
］にすることが可能になる。
これは、
（ `&lt;input type="range"&gt;^e ~control `HTML$r に類する）~custom~slider~controlを作るときなどに有用になる。
~slider~thumbの要素に対し，~pointer捕捉を設定すれば、
利用者は，~pointerがその~thumbからそれたときにも ~controlを前後に~slideさせられるようになる。
◎
Pointer capture allows the events for a particular pointer (including any compatibility mouse events) to be retargeted to a particular element other than the normal hit test result of the pointer's location. This is useful in scenarios like a custom slider control (e.g. similar to the [HTML] &lt;input type="range"&gt; control). Pointer capture can be set on the slider thumb element, allowing the user to slide the control back and forth even if the pointer slides off of the thumb.
</p>

<figure id="figure_slider">
`slider^dgm

<figcaption>
~thumb要素を前後に~slideして値を選ぶような，~custom~slider~controlの例。
~thumb上で `pointerdown$et が生じたとき，~pointer捕捉を利用すれば、
利用者は，~pointerが~sliderからそれても ~slideできるようになる。
◎
Figure 7＼
Example of a custom slider control that chooses a value by sliding the thumb element back and forth. After pointerdown on the thumb, pointer capture can be used to allow the user to slide the thumb even if the pointer drifts off of it.
</figcaption></figure>

		</section>
		<section id="setting-pointer-capture">
<h3 title="Setting pointer capture">11.2. ~pointer捕捉の設定-法</h3>

<div class="algo">
<p>
要素による`~pointer捕捉$は、
要素に対し `setPointerCapture(pointerId)$m ~methodを~callすることにより設定される
— その~method手続きは：
</p>
<ol>
	<li>
%~pointer ~LET %pointerId に合致する`作動中な~pointer$は［
在るならば それ／
無いならば ε
］
</li>
	<li>
~IF［
%~pointer ~EQ ε
］
⇒
~THROW `NotFoundError$E
</li>
	<li>
`~pointer捕捉を設定する$( コレ, %~pointer )
</li>
</ol>

◎
Pointer capture is set on an element of type Element by calling the element.setPointerCapture(pointerId) method.＼
When this method is invoked, the user agent MUST run the following steps:
• If the pointerId provided as the method's argument does not match any of the active pointers, then throw a "NotFoundError" DOMException.
• Let the pointer be the active pointer specified by the given pointerId.
</div>

<div class="algo">
<p>
`~pointer捕捉を設定する@
~algoは、
所与の
( `Element$I %要素, `作動中な~pointer$ %~pointer )
に対し：
◎
↑</p>
<ol>
	<li>
~IF［
%要素 は`接続されて$いない `DOM$r
］
⇒
~THROW `InvalidStateError$E
◎
If the element is not connected [DOM], throw an "InvalidStateError" DOMException.
</li>
	<li>
%文書 ~LET %要素 の`~node文書$ `DOM$r
◎
↓</li>
	<li>
~IF［
%文書 には現在~lockされている要素がある
（ `PointerLock$r `pointerLockElement$m 【が ~NULL 以外を返す要素がある】 ）
］
⇒
~THROW `InvalidStateError$E
◎
If this method is invoked while the element's node document [DOM] has a locked element ([PointerLock] pointerLockElement), throw an "InvalidStateError" DOMException.
</li>
	<li>
~IF［
%~pointer の~buttonは`作動~状態$でない
］~OR［
%文書 ~NEQ %~pointer にて`作動中な文書$
］
⇒
~RET
◎
If the pointer is not in the active buttons state or the element's node document is not the active document of the pointer, then terminate these steps.
</li>
	<li>
%~pointer の`処理待ち捕捉~target$ ~SET %要素
◎
For the specified pointerId, set the pending pointer capture target override to the Element on which this method was invoked.
</li>
</ol>
</div>

<p class="note">注記：
［
`~pointer捕捉を設定する$／`~pointer捕捉を解放する$
］~callが処理待ち状態にある間に（`処理待ち~pointer捕捉を処理する$を見よ），［
~pointer捕捉を設定する／~pointer捕捉を解放する
］~call（順不同）が為された場合、
後者の~callが成功裡であるならば，後者の~callが前者の~callを上書きする
— 他の場合は，前者の~callが有効果であり続ける。
このことは、
`pointerdown$et 用の~listenerにて，`暗黙的な~pointer捕捉＠#implicit-pointer-capture$を解放する試みが失敗した場合にも該当する。
◎
Note
If a call to set or release a pointer capture is made while a previous set or release call is in a pending state (see process pending pointer capture), the second call overrides the first call if the second call is successful, otherwise the first call remains effective. This is true for a failed attempt to release an implicit pointer capture at a pointerdown listener.
</p>

		</section>
		<section id="releasing-pointer-capture">
<h3 title="Releasing pointer capture">11.3. ~pointer捕捉の解放-法</h3>

<div class="algo">
<p>
要素による`~pointer捕捉$は、
要素に対し `releasePointerCapture(pointerId)$m ~methodを~callすることにより，明示的に解放できる
— その~method手続きは：
</p>
<ol>
	<li>
%~pointer ~LET %pointerId に合致する`作動中な~pointer$は［
在るならば それ／
無いならば ε
］
</li>
	<li>
~IF［
%~pointer ~EQ ε
【！and these steps are not being...】
］
⇒
~THROW `NotFoundError$E
</li>
	<li>
`~pointer捕捉を解放する$( コレ, %~pointer )
</li>
</ol>

◎
Pointer capture is released on an element explicitly by calling the element.releasePointerCapture(pointerId) method.＼
When this method is called, the user agent MUST run the following steps:
◎
• If the pointerId provided as the method's argument does not match any of the active pointers and these steps are not being invoked as a result of the implicit release of pointer capture, then throw a "NotFoundError" DOMException.
</div>

<div class="algo">
<p>
`~pointer捕捉を解放する@
~algoは、
所与の
( `Element$I %要素, `作動中な~pointer$ %~pointer )
に対し
⇒
~IF［
%~pointer の`処理待ち捕捉~target$ ~EQ %要素
（すなわち，%要素 の `hasPointerCapture$m ~EQ ~T ）
］
⇒
%~pointer の`処理待ち捕捉~target$ ~SET ~NULL
◎
• If hasPointerCapture is false for the Element with the specified pointerId, then terminate these steps.
• For the specified pointerId, clear the pending pointer capture target override, if set.
</div>

<p class="note">注記：
`§ ~pointer捕捉の設定-法＠#setting-pointer-capture$
の注記も見よ。
◎
Note
See the note in the section Setting pointer capture.
<p>

		</section>
		<section id="implicit-pointer-capture">
<h3 title="Implicit pointer capture">11.4. 暗黙的な~pointer捕捉</h3>

<p>
`直な~pan-zoom$（~touchscreen上の~touchや~stylusなど）を実装する入力は、
正確に，［
`pointerdown$et 用の~listenerが呼出される直前に，
~target要素に対し `setPointerCapture()$m が~callされた
］かのように挙動するベキである。
これが生じたかどうかは、
`hasPointerCapture()$m ~APIを利用して決定できる
（一例として， `pointerdown$et ~listenerにおいて）。
次回に~pointer~eventが発火される前に，~pointerに対し `releasePointerCapture()$m が~callされなかった場合、
`gotpointercapture$et ~eventは~targetに（通常通り）配送されることになり，
その捕捉が作動中であることを指示する。
◎
Inputs that implement direct manipulation interactions for panning and zooming (such as touch or stylus on a touchscreen) SHOULD behave exactly as if setPointerCapture() was called on the target element just before the invocation of any pointerdown listeners. The hasPointerCapture API may be used (for instance, in a pointerdown listener) to determine whether this has occurred. If releasePointerCapture() is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched to the target (as normal) indicating that capture is active.
</p>

<p class="note">注記：
これは， `PointerEvents$r 【~level 1 】を非互換化する変更であるが、
既存の内容の大勢には影響iしない。
この暗黙的な捕捉~用の設計は、
代表的な~platform~UX慣行に合致することに加え、
開発者による明示的な~opt-inなしに，~UAによる［［
~touch移動による~eventに対し接触判定を呼出す必要
］を防止するような，処理能の最適化
］を可能化する（既存の支配的な ~touch入力~用の［
~native ／~web
］~APIの処理能~上の特質に整合する）。
◎
Note
This is a breaking change from [PointerEvents], but does not impact the vast majority of existing content. In addition to matching typical platform UX conventions, this design for implicit capture enables user agents to make a performance optimization which prevents the need to invoke hit-testing on touch movement events without explicit developer opt-in (consistent with the performance properties of existing dominant native and web APIs for touch input).
</p>

<p class="note">注記：
加えて，~UAは、
入力~範囲~controlなどの特定の~UI~widget上で，
すべての入力~装置~用に暗黙的な~pointer捕捉の挙動を実装してよい
（手指を動している間に ~form~controlの外側に それることも許容するような）。
◎
Note
In addition, user agents may implement implicit pointer capture behavior for all input devices on specific UI widgets such as input range controls (allowing some finger movement to stray outside of the form control itself during the interaction).
</p>

		</section>
		<section id="implicit-release-of-pointer-capture">
<h3 title="Implicit release of pointer capture">11.5. ~pointer捕捉の暗黙的な解放-法</h3>

<p>
`~UA$は、［
`pointerup$et ／ `pointercancel$et
］~eventを発火した直後には、
`~pointer捕捉を暗黙的に解放する$モノトスル。
◎
↓</p>

<div class="algo">
<p>
`~pointer捕捉を暗黙的に解放する@
~algoは、
所与の
( `作動中な~pointer$ %~pointer )
に対し：
</p>
<ol>
	<li>
%~pointer の`処理待ち捕捉~target$ ~SET ~NULL
</li>
	<li>
`処理待ち~pointer捕捉を処理する$( %~pointer )
</li>
	<li>
~IF［
%~pointer は~hoverを~supportする
］
⇒
必要yなら、
%~pointer の現在の位置を反映するよう，対応する`境界~event$
【以前に送信した`境界~event$と対になる それ】
を
— 捕捉を伴わずに —
送信する
</li>
</ol>
◎
Immediately after firing the pointerup or pointercancel events, the user agent MUST clear the pending pointer capture target override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run process pending pointer capture steps to fire lostpointercapture if necessary. After running process pending pointer capture steps, if the pointer supports hover, user agent MUST also send corresponding boundary events necessary to reflect the current position of the pointer with no capture.
</div>

<p>
ある`文書$に`接続されて$いた `DOM$r ［
ある`作動中な~pointer$の`捕捉~target$
］が`切断された$ときは、
当の~pointerの`捕捉~target$を当の文書に設定するべきである。
◎
When the pointer capture target override is no longer connected [DOM], the pointer capture target override SHOULD be set to the document.
</p>

<p>
`接続されて$いた `DOM$r ［
ある`作動中な~pointer$の`処理待ち捕捉~target$
］が`切断された$ときは、
当の~pointerの`処理待ち捕捉~target$を ~NULL に設定するべきである。
◎
When the pending pointer capture target override is no longer connected [DOM], the pending pointer capture target override node SHOULD be cleared.
</p>

<p>
前 2 つの段落による結果、
当の文書に向けて，当の~pointerに対応する `lostpointercapture$et ~eventが
— 捕捉~nodeが除去された後【`捕捉~target$が接続されなくなった後】，次回に`処理待ち~pointer捕捉を処理する$間に —
発火されるようになる。
◎
The previous two paragraphs result in a lostpointercapture event corresponding to the captured pointer being fired at the document during the next Process pending pointer capture after the capture node is removed.
</p>

<p>
要素が ある`作動中な~pointer$の［
`捕捉~target$／`処理待ち捕捉~target$
］である間に［
要素に~pointer~lock `PointerLock$r が成功裡に適用された
］ときは、
`releasePointerCapture()$m ~method用の手続きを走らすモノトスル。
◎
When a pointer lock [PointerLock] is successfully applied on an element, the user agent MUST run the steps as if the releasePointerCapture() method has been called if any element is set to be captured or pending to be captured.
</p>

		</section>
	</section>
	<section id="coalesced-and-predicted-events">
<h2 title="Coalesced and predicted events">12. 合体された~event群と予測された~event群</h2>

<p class="note">注記：
この仕様は、
~UAが，~pointerの動き~dataをどう［
合体する／予測する
］べきかは定義しない。
この情報へ~accessするための~APIを指定するだけである。
◎
Note
This specification does not define how user agents should coalesce or predict pointer movement data. It only specifies the API for accessing this information.
</p>

		<section id="coalesced-events">
<h3 title="Coalesced events">12.1. 合体された~event群</h3>

<p>
処理能の理由から、
~UAは，~pointerの`測定-可能な~prop$
（［
座標／押圧／接線方向~圧／傾き／~twist／`接触~幾何$
］など）
が更新される あらゆる回には
`pointermove$et ~eventを送信しないことを選んで、
代わりに，それら複数回の変化を 1 個の［
`pointermove$et ／ `pointerrawupdate$et
］~eventの中に合体して（結合して／併合して）もヨイ。
この~approachは，~UAが遂行しなければならない~event取扱い量を抑制する助けになるが、
~pointerの位置【など，それらの~prop】を追跡するときの粒度と忠実度も
— 特に，速く大きな動きに対し —
自然に抑制されることになる。
`getCoalescedEvents()$m ~methodを利用すれば、
~appは，合体されない生の位置~変化への~accessがアリになる
— これは、
~pointerの動き~dataに対し，もっと精確な取扱いを許容する。
一例として，描き~appの事例では、
合体されない~event群を，~pointer実際の動きに より近く合致する滑らかな曲線を描くために利用できる。
◎
For performance reasons, user agents may choose not to send a pointermove event every time a measurable property (such as coordinates, pressure, tangential pressure, tilt, twist, or contact geometry) of a pointer is updated. Instead, they may coalesce (combine/merge) multiple changes into a single pointermove or pointerrawupdate event. While this approach helps in reducing the amount of event handling the user agent MUST perform, it will naturally reduce the granularity and fidelity when tracking a pointer position, particularly for fast and large movements. Using the getCoalescedEvents() method it is possible for applications to access the raw, un-coalesced position changes. These allow for a more precise handling of pointer movement data. In the case of drawing applications, for instance, the un-coalesced events can be used to draw smoother curves that more closely match the actual movement of a pointer.
</p>

<figure id="figure_coalesced">
<p class="alt" hidden id="_dgm-coalesced-points">
合体された／合体されない点群を示している曲線の近接図
◎
Close-up view of a curve, showing coalesced and un-coalesced points
</p>
<figcaption>
描き~appにおける曲線の例。
`pointermove$et ~eventからの合体された座標のみを利用して（黒っぽい丸）描いた曲線は，角張った様子が目立つ。
同じ線を `getCoalescedEvents()$m が供する もっと きめ細かな点群（赤い中空な丸）利用して描いた結果は，~pointerの動きを もっと滑らかに近似する。
◎
Figure 8＼
Example of a curve in a drawing application — using only the coalesced coordinates from pointermove events (the grey dots), the curve is noticeably angular and jagged; the same line drawn using the more granular points provided by getCoalescedEvents() (the red circles) results in a smoother approximation of the pointer movement.
</figcaption></figure>

<p>
各 `PointerEvent$I ~obj %~event には、
`合体d~event~list@
（ `coalesced events list^en ）が結付けられる
— それは、
`PointerEvent$I ~objたちが成す~listである。
この~listは：
◎
A PointerEvent has an associated coalesced events list (a list of zero or more PointerEvents).＼
</p>
<ul class="switch">
	<li>
<p>
%~event は`~trusted$である場合
— %~event の~event型に応じて：
◎
↓</p>
		<ul class="switch">
			<li>
<p>
`pointermove$et ／ `pointerrawupdate$et
⇒
%~event の中に合体された すべての `PointerEvent$I ~objが成す連列になる。
%~event は、
これら合体された~eventの累積を表現するが，追加的な処理も伴い得る
（例えば、~displayの~refresh~rateに揃えるため）。
その結果、
この~listは，常に 1 個以上の~eventを包含する。
◎
For trusted pointermove and pointerrawupdate events, the list is a sequence of all PointerEvents that were coalesced into this event. The "parent" trusted pointermove and pointerrawupdate event represents an accumulation of these coalesced events, but may have additional processing (for example to align with the display refresh rate). As a result, the coalesced events lists for these events always contain at least one event.＼
</p>

<p class="note">注記：
この場合，
開発者は［
%~event, %~event の`合体d~event~list$を成すすべて
］のうち一方しか処理する必要はないはずである
— 前者は後者の要約あるいは集成なので。
◎
↓</p>
			</li>
			<li>
他の場合
⇒
空になる。
◎
For all other trusted event types, it is an empty list.＼
</li>
		</ul>
	</li>
	<li>
%~event は`~trusted$でない場合
⇒
構築子に渡された値に初期化される。
◎
Untrusted events have their coalesced events list initialized to the value passed to the constructor.
</li>
</ul>

<p class="note">注記：
ある`合体d~event~list$ %~list を包含している~trustedな~eventが~JSから配送し直されたときは、
当の~event の `isTrusted$m は~event配送~algoにより ~F に設定されるが，
%~list を成す各~eventの `isTrusted^m は元の値 ~T から変化しない。
◎
↑↑ Note
Since a trusted parent event is a summary or aggregation of the coalesced events, developers should only need to process either the parent events or all of the coalesced events, but not both.
◎
Note
When a trusted event containing a coalesced events list is re-dispatched from JavaScript, the event dispatch algorithm sets the isTrusted bit of the event to false but the same bits in the coalesced events list remain unchanged from their original true values.
</p>

<p>
`~trusted$な`~pointer~event$ %~event の`合体d~event~list$
— 配送された %~event に対し，その `getCoalescedEvents()$m 【！`getPredictedEvents()$m 】~methodを~callして得られるそれ —
を成す各~eventは：
◎
The events in the coalesced events list of a trusted event will have:
</p>
<ul>
	<li>
<p>
その `timeStamp$m 属性 `DOM$r の値は、
%~event の `timeStamp$m の値~以下になり，~list順に単調増加する。
◎
Monotonically increasing timeStamp values [DOM] — all coalesced events have a timeStamp that is smaller than or equal to the timeStamp of the dispatched pointer event that the getPredictedEvents method was called on.＼
</p>

<p>
すなわち， %~event の`合体d~event~list$は、
各自の `timeStamp$m 値により時系列順に~sortするモノトスル
— ~listを成す最初の~eventの `timeStamp$m が最~小になる。
◎
The coalesced events list MUST be chronologically sorted by timeStamp, so the first event will have the smallest timeStamp.
</p>
	</li>
	<li>
その［
`pointerId$m,
`pointerType$m,
`isPrimary$m
］属性の値は、
%~event のそれらと同じになる。
◎
The same pointerId, pointerType, and isPrimary as the dispatched "parent" pointer event.
</li>
	<li>
その自前の［
`合体d~event~list$, `予測d~event~list$
］は空になる。
◎
Empty coalesced events list and predicted events list of their own.
</li>
</ul>

<div class="example">
<p>
合体d~event~listを利用している
基本的な~canvasの描き~app
◎
Example 14: Basic canvas drawing application using the coalesced events list
</p>

<pre class="lang-html">
&lt;style&gt;
  /* <span class="comment">
直な操作による挙動（~pan-zoomなど）を不能化して、
`canvas$e 要素に対する すべての~eventを，~appに仕向ける。
◎
Disable intrinsic user agent direct manipulation behaviors (such as panning or zooming) so that all events on the canvas element are given to the application instead.
</span> */

  canvas { `touch-action$p: none; }
&lt;/style&gt;

&lt;canvas
    id="drawSurface"
    width="500px" height="500px"
    style="border:1px solid black;"
&gt;&lt;/canvas&gt;

&lt;script&gt;
    const %canvas = document.getElementById("drawSurface"),
    %context = %canvas.getContext("2d");

    %canvas.addEventListener("pointermove", (%e)=&gt; {

        if (%e.getCoalescedEvents) {
            for (let %coalesced_event of %e.getCoalescedEvents()) {
                paint(%coalesced_event); /* <span class="comment">
合体されない生の点群をすべて塗る
◎
Paint all raw/non-coalesced points
</span> */
            }
        } else {
            paint(%e); /* <span class="comment">
合体された最終的な点を塗る
◎
Paint the final coalesced point
</span> */
        }
    });

    function paint(%event) {
        if (%event.buttons&gt;0) {
            %context.fillRect(%event.clientX, %event.clientY, 5, 5);
        }
    }

&lt;/script&gt;
</pre>
</div>

<p class="note">注記：
`PointerEvent$I の各~属性は、［
合体d~event~listを成す各~eventを最良に表現する仕方
］で初期化されることになる。
~UAが これをどのような手法で行うベキかついては、
この仕様が受持つ所ではない。
◎
Note
The PointerEvent's attributes will be initialized in a way that best represents the events in the coalesced events list. The specific method by which user agents should do this is not covered by this specification.
</p>

<p>
これらの~eventが配送される順序は、
元の~eventたちと合致させるモノトスル。
例えば，
【~pointerの~buttonが押されることにより】
`pointerdown$et ~eventに加え，合体された `pointermove$et ~eventたちも配送される場合、
~UAは最初に，それらの合体された［
同じ `pointerId$m を伴う~event
］すべてを伴う 1 個の `pointermove$et ~eventを配送してから、
`pointerdown$et ~eventを配送するモノトスル。
◎
The order of all these dispatched events MUST match the actual order of the original events. For example if a pointerdown event causes the dispatch for the coalesced pointermove events the user agent MUST first dispatch one pointermove event with all those coalesced events of a pointerId followed by the pointerdown event.
</p>

<div class="note">
<p>注記：
次の例に、
実際に起きた~event列と，
~UAにより配送される~event列を~~時系列順に示す
（すなわち、
各~eventの `timeStamp$m 値は順に増大する）：
◎
Note
Here is an example of the actual events happening with increasing timeStamp values and the events dispatched by the user agent:
</p>

<div>
<table>
<caption>
カッコ内の数は~pointerの `pointerId$m
</caption>
<thead>
<tr><th>実際の~pointerの状態~変化
<th>配送される~event／合体される~eventの個数
</tr><tbody>

<tr><td>（ 2 ）座標~変化
<td>`pointerrawupdate$et（ 2 ）／ 1 個【 0 個？】

<tr><td>（ 1 ）座標~変化
<td>`pointerrawupdate$et（ 1 ）／ 1 個

<tr><td>（ 2 ）座標~変化
<td>`pointerrawupdate$et（ 2 ）／ 1 個

<tr><td>（ 2 ）座標~変化
<td>`pointerrawupdate$et（ 2 ）／ 1 個

<tr><td>（ 1 ）座標~変化
<td>`pointerrawupdate$et（ 1 ）／ 1 個

<tr><td>（ 2 ）座標~変化
<td>`pointerrawupdate$et（ 2 ）／ 1 個

<tr><td>（ 1 ）~buttonが押された
<td>
`pointermove$et（ 1 ）／ 2 個<br>
`pointermove$et（ 2 ）／ 4 個<br>
`pointerdown$et（ 1 ）／ 0 個<br>

<tr><td>（ 2 ）座標~変化
<td>`pointerrawupdate$et（ 2 ）／ 1 個

<tr><td>（ 2 ）座標~変化
<td>`pointerrawupdate$et（ 2 ）／ 1 個

<tr><td>（ 1 ）~buttonが離された
<td>
`pointermove$et（ 2 ）／ 2 個<br>
`pointerup$et（ 1 ）／ 0 個<br>
</table>

◎
Actual events｜Dispatched events
pointer (pointerId=2) coordinate change｜pointerrawupdate (pointerId=2) w/ one coalesced event
pointer (pointerId=1) coordinate change｜pointerrawupdate (pointerId=1) w/ one coalesced event
pointer (pointerId=2) coordinate change｜pointerrawupdate (pointerId=2) w/ one coalesced event
pointer (pointerId=2) coordinate change｜pointerrawupdate (pointerId=2) w/ one coalesced event
pointer (pointerId=1) coordinate change｜pointerrawupdate (pointerId=1) w/ one coalesced event
pointer (pointerId=2) coordinate change｜pointerrawupdate (pointerId=2) w/ one coalesced event
pointer (pointerId=1) button press｜pointermove (pointerId=1) w/ two coalesced events
pointermove (pointerId=2) w/ four coalesced events
pointerdown (pointerId=1) w/ zero coalesced events
pointer (pointerId=2) coordinate change｜pointerrawupdate (pointerId=2) w/ one coalesced event
pointer (pointerId=2) coordinate change｜pointerrawupdate (pointerId=2) w/ one coalesced event
pointer (pointerId=1) button release｜pointermove (pointerId=2) w/ two coalesced events
pointerup (pointerId=1) w/ zero coalesced events
</div>
</div>

		</section>
		<section id="predicted-events">
<h3 title="Predicted events">12.2. 予測された~event群</h3>

<p>
一部の~UAは、［
~pointerに確認された一連の動きの後に，未来の~pointerの動きを成す位置は どうなるか
］について
（［
現在の~gestureにおいて先行する~eventたち, 当の動きの速さや軌跡
］に基づいて）
予測を為せるような，
組込みの~algoを有する。
この情報は `getPredictedEvents()$m ~methodから得られる：
~appは、
それを利用して予測された位置を “事前に” 投機的に描くことにより，
知覚される待時間を抑制できる
— 予測されたこれらの点群は、
実際の点群を受取った時点で破棄するようにして。
◎
Some user agents have built-in algorithms which, after a series of confirmed pointer movements, can make a prediction (based on the preceding events for the current gesture, and the speed/trajectory of the movement) what the position of future pointer movements may be. Applications can use this information with the getPredictedEvents method to speculatively "draw ahead" to a predicted position to reduce perceived latency, and then discarding these predicted points once the actual points are received.
</p>

<figure id="figure_predicted">
<p class="alt" hidden id="_dgm-predicted-points">
合体された点群を利用して描かれた線は、
予測された未来の点群を示している
◎
A line drawn using coalesced points, showing predicted future points
</p>
<figcaption>
描き~appにおける線の例（
`pointermove$et ~eventからの合体された座標~群を利用して，左下から右上へ~gestureを描いた結果）
— ~UAが予測した未来の点群（中空な丸）を示している。
◎
Figure 9＼
Example of a line in a drawing application (the result of a drawing gesture from the bottom left to the top right), using the coalesced coordinates from pointermove events, showing the user agent's predicted future points (the grey circles).
</figcaption></figure>

<p>
各 `PointerEvent$I ~obj %~event には
`予測d~event~list@
（ `predicted events list^en ）
が結付けられる
— それは、
`PointerEvent$I ~objたちが成す~listである。
この~listは：
◎
A PointerEvent has an associated predicted events list (a list of zero or more PointerEvents).＼
</p>
<ul>
	<li>
%~event は`~trusted$である場合
⇒
%~event の~event型は `pointermove$et ならば，［
~UAが［
未来に %~event に後続することになる
］ものと予測する `PointerEvent$I ~objが成す連列
］になり、
他の場合は空になる。
◎
For trusted pointermove events, it is a sequence of PointerEvents that the user agent predicts will follow the event in the future. For all other trusted event types, it is an empty list.＼
</li>
	<li>
%~event は`~trusted$でない場合
⇒
構築子に渡された値に初期化される。
◎
Untrusted events have their predicted events list initialized to the value passed to the constructor.
</li>
</ul>

<p class="note">注記：
`pointerrawupdate$et ~eventは、
その`合体d~event~list$は，空でないこともあるが、
その`予測d~event~list$は，処理能の理由により通例的に空になる。
◎
Note
While pointerrawupdate events may have a non-empty coalesced events list, their predicted events list will, for performance reasons, usually be an empty list.
</p>

<p class="note">注記：
ある`予測d~event~list$ %~list を包含している~trustedな~eventが~JSから配送し直されたときは、
当の~event の `isTrusted$m は~event配送~algoにより ~F に設定されるが，
%~list を成す各~eventの `isTrusted^m は元の値 ~T から変化しない。
◎
Note
When a trusted event containing a predicted events list is re-dispatched from JavaScript, the event dispatch algorithm sets the isTrusted bit of the event to false but the same bits in the predicted events list remain unchanged from their original true values.
</p>

<p>
この~listを成す~eventの個数, および［
各~eventが現在の時刻印から どれほど離れるか
］は、［
~UA, ~UAが利用する予測~algo
］により決定される。
◎
The number of events in the list and how far they are from the current timestamp are determined by the user agent and the prediction algorithm it uses.
</p>

<p>
`~trusted$な`~pointer~event$ %~event の`予測d~event~list$
— 配送された %~event に対し，その `getPredictedEvents()$m ~methodを~callして得られるそれ —
を成す各~eventは：
◎
The events in the predicted events list of a trusted event will have:
</p>
<ul>
	<li>
<p>
その `timeStamp$m 値 `DOM$r は、
%~event の `timeStamp$m 以上になる, かつ
~list順に単調増加する。
◎
Monotonically increasing timeStamp values [DOM]＼
— all predicted events have a timeStamp that is greater than or equal to the timeStamp of the dispatched pointer event that the getPredictedEvents method was called on.＼
</p>

<p>
すなわち，`予測d~event~list$は、
`timeStamp$m 値により時系列順に~sortするモノトスル
— ~listを成す最初の~eventの `timeStamp$m が最~小になる。
◎
The predicted events list MUST be chronologically sorted by timeStamp, so the first event will have the smallest timeStamp.
</p>
	</li>
	<li>
その［
`pointerId$m,
`pointerType$m,
`isPrimary$m
］属性は、
%~event のそれらと同じになる。
◎
The same pointerId, pointerType, and isPrimary as the dispatched "parent" pointer event.
</li>
	<li>
その自前の［
`合体d~event~list$, `予測d~event~list$
］は空になる。
◎
Empty coalesced events list and predicted events list of their own.
</li>
</ul>

<p class="note">注記：
作者は、
予測された~eventを［
次回に~pointer~eventが配送されるまでの間に限り，
妥当な予測と見なすベキである
］ことに注意。
~UAが未来のどこまで~eventを予測するかに依存するが、
定例の~pointer~eventは，
予測された~eventのうち いくつかの時刻印より早くに配送されることもアリである。
◎
Note
Note that authors should only consider predicted events as valid predictions until the next pointer event is dispatched. It is possible, depending on how far into the future the user agent predicts events, that regular pointer events are dispatched earlier than the timestamp of one or more of the predicted events.
</p>

<div class="example">
<p>
合体された~event群, 予測された~event群を利用して何か描く概念的な~approach。
◎
Example 15: Conceptual approach to drawing using coalesced events and predicted events
</p>

<pre class="lang-js">
let %predicted_points = [];
window.addEventListener("pointermove", function(%event) {
  /* <span class="comment">
それまでに描いた予測された点群を~clearする。
◎
Clear the previously drawn predicted points.
</span> */
  for (let %e of %predicted_points.reverse())
    clearPoint(%e.pageX, %e.pageY);

  /* <span class="comment">
最後に受取った~event以降に起きた，実際の動きを描く。
◎
Draw the actual movements that happened since the last received event.
</span> */
  for (let %e of %event.getCoalescedEvents())
    drawPoint(%e.pageX, %e.pageY);

  /* <span class="comment">
待時間の知覚を抑制するため，現在の予測された点群を描く。
◎
Draw the current predicted points to reduce the perception of latency.
</span> */
  %predicted_points = %event.getPredictedEvents();
  for (let %e of %predicted_points)
    drawPoint(%e.pageX, %e.pageY);
});
</pre>
</div>

		</section>
		<section id="populating-and-maintaining-the-coalesced-and-predicted-event-lists">
<h3 title="Populating and maintaining the coalesced and predicted events lists">12.3. 合体d~event~list, 予測d~event~listの拡充-法と保守-法</h3>

<div class="algo">
<p>
~UAは，`~trusted$な `PointerEvent$I %~pointer~event の作成-時には、
その［
`合体d~event~list$, `予測d~event~list$
］を成す
~EACH( %~event )
に対し，次の手続きを走らすベキである：
◎
When a trusted PointerEvent is created, user agents SHOULD run the following steps for each event in the coalesced events list and predicted events list:
</p>
<ol>
	<li>
%~event の次に挙げる属性を %~pointer~event の対応する属性と合致するように設定する
⇒＃
`pointerId$m,
`pointerType$m,
`isPrimary$m,
`isTrusted$m
◎
Set the event's pointerId, pointerType, isPrimary and isTrusted to match the respective properties of the "parent" pointer event.
</li>
	<li>
%~event の
⇒＃
`cancelable$m ~SET ~F,
`bubbles$m ~SET ~F
◎終
（当の~listを成す~eventたちは、常に一緒に配送されるので）
◎
Set the event's cancelable and bubbles to false (as these events will never be dispatched in isolation).
</li>
	<li>
%~event の`合体d~event~list$ ~SET 空~list
◎
Set the event's coalesced events list and predicted events list to an empty list.
</li>
	<li>
%~event の`予測d~event~list$ ~SET 空~list
◎
↑</li>
	<li>
%~event の他の属性を `PointerEvent$I 用の既定の値に初期化する
◎
Initialize all other attributes to default PointerEvent values.
</li>
</ol>
</div>

<div class="algo">
<p>
~UAは，`~trusted$な `PointerEvent$I %~pointer~event の`~target$【！`target$m】が変化したときは、
その［
`合体d~event~list$, `予測d~event~list$
］を成す
~EACH( %~event )
に対し，次の手続きを走らすベキである：
◎
When a trusted PointerEvent's target is changed, user agents SHOULD, for each event in the coalesced events list and predicted events list:
</p>
<ol>
	<li>
%~event の`~target$ ~SET %~pointer~event の`~target$【！`target$m】
◎
Set the event's target to match the target of the "parent" pointer event.
</li>
</ol>
</div>

<p class="trans-note">【
これらの手続きの要件~levelは、
なぜ “ベキ” とされている？
】</p>

		</section>
	</section>
	<section id="compatibility-mapping-with-mouse-events">
<h2 title="Compatibility mapping with mouse events">13. ~mouse~eventとの互換性を得るための対応付け</h2>

<p>
今日の~web内容では、
`~mouse~event$向けのみに書かれている~codeが大勢を占めている。
~UAは、
その種の内容との互換性を得るためとして、
以下に与える~algoにより，汎用~pointer入力を~mouse~eventに対応付けてもヨイ。
◎
The vast majority of web content existing today codes only to Mouse Events. The following describes an algorithm for how the user agent MAY map generic pointer input to mouse events for compatibility with this content.
</p>

<p>
互換性を得るための ~mouse~eventへの対応付けは、
この仕様の任意選択な特能である。
~UAには、
既存の旧来の内容との最良な互換性を得るために，
この特能を~supportすることが奨励される。
◎
The compatibility mapping with mouse events is an OPTIONAL feature of this specification. User agents are encouraged to support the feature for best compatibility with existing legacy content.
</p>

<div class="note">
<p>注記：
高~levelからは、
互換性~mouse~eventは，各自に対応する~pointer~eventと “互いに差し挟まれる” ものと意図される。
しかしながら、
この特定の順序は，義務ではない
— 互換性~mouse~eventを実装する~UAは、
~mouse~eventの配送を［
遅延する／~group化
］するものと裁定してもヨイ
— それらの相対的な順序が一貫する限り。
◎
At a high level, compatibility mouse events are intended to be "interleaved" with their respective pointer events. However, this specific order is not mandatory, and user agents that implement compatibility mouse events MAY decide to delay or group the dispatch of mouse events, as long as their relative order is consistent.
</p>

<p>
特に，~touchscreen入力の事例では、
~UAは，~gesture認識~用に追加的な経験則を適用してもヨイ
（作者により `touch-action$p を通して明示的に抑止されてない限り）。
`pointerdown$et ~eventから `pointerup$et ~eventまでを成す`~event連列$の間、
~gesture認識は
— ~gestureを検出するか無視するか決定するために —
`pointerup$et ~eventまで待機する必要もあろう。
その結果，~UAが［
当のヤリトリが特定0の~gestureとして意図されたものでない
］ことを決定した場合、
当の連列~用の互換性~mouse~eventは，最後の `pointerup$et ~eventの後に一緒に配送され得る。
これらの~UAに特有な~gesture認識は、
この仕様では定義されないので，実装ごとに相違し得る。
◎
Particularly in the case of touchscreen inputs, user agents MAY apply additional heuristics for gesture recognition (unless explicitly suppressed by authors through touch-action). During a sequence of events between a pointerdown event and a pointerup event, the gesture recognition may have to wait until the pointerup event to detect or ignore a gesture. As a result the compatibility mouse events for the whole sequence may be dispatched together after the last pointerup event, if the user agent determined that an interaction was not intended as a particular gesture. These specifics of user agent gesture recognition are not defined in this specification, and they may differ between implementations.
</p>
</div>

<p>
~UAは、［
`click$et, `auxclick$et, `contextmenu$et
］~eventを
— `互換性~mouse~event$を~supportするかどうかに関わらず，常に —
~supportするモノトスル
— これらの~eventは、
`PointerEvent$I 型であり，`互換性~mouse~event$ではないので。
`~pointer~event$の間に `preventDefault()$m が~callされても，
これらの~eventが発火されるか否かに対する効果は無いモノトスル。
◎
Regardless of their support for compatibility mouse events, the user agents MUST always support the click, auxclick and contextmenu events because these events are of type PointerEvent and are therefore not compatibility mouse events. Calling preventDefault during a pointer event MUST NOT have an effect on whether click, auxclick, or contextmenu are fired or not.
</p>

<div class="note">
<p>注記：
これらの高~levelな~eventのうち一部
（ `contextmenu$et, `focus$et, `blur$et など）
と`~pointer~event$との相対的な順序は、
未定義であり，~UAごとに変わり得る。
例えば、［
`pointerup$et, `contextmenu$et
］の順に発火されることが多い~UAもあれば，
その逆順に発火されることが多い~UAもある。
また、
対応する`~pointer~event$を伴わずに発火される状況もある
（一例として、
~keyboardによるヤリトリの結果として）。
◎
Note
The relative order of some of these high-level events (such as contextmenu, focus, blur) with pointer events is undefined and varies between user agents. For example, in some user agents contextmenu will often follow a pointerup, while in others it'll often precede a pointerup or pointercancel, and in some situations it may be fired without any corresponding pointer event (for instance, as a result of a keyboard interaction).
</p>

<p>
加えて，~UAは、［
`click^et ／ `auxclick^et ／ `contextmenu^et
］~eventを発火するべきかかどうか決定するときに，自前の経験則を適用し得る。
一部の~UAは、
これらの~eventを［
同じ型の他の（首~pointerでない）~pointer／
異なる型の他の首~pointer
］がある場合には，発火しないことを選ぶこともある。
~UAは、
特定0の動作を “~clean” な［
~tap／~click／長押し
］ではなかったものと決定して
（一例として、
手指による~touch~screenとのヤリトリが，
~screenと接触-中にある間に多過ぎる動きを含むとき），
［
`click^et ／ `auxclick^et ／ `contextmenu^et
］~eventを発火しないものと裁定することもある。
~UAの挙動を成すこれらの側面は、
この仕様では定義されないので，実装ごとに相違し得る。
◎
In addition, user agents may apply their own heuristics to determine whether or not a click, auxclick, or contextmenu event should be fired. Some user agents may choose not to fire these events if there are other (non-primary) pointers of the same type, or other primary pointers of a different type. User agents may determine that a particular action was not a "clean" tap, click, or long-press (for instance, if an interaction with a finger on a touch screen includes too much movement while the finger is in contact with the screen) and decide not to fire a click, auxclick, or contextmenu event. These aspects of user agent behavior are not defined in this specification, and they may differ between implementations.
</p>
</div>

<div class="p">
<p>
対応付けられた`~mouse~event$は、
他が注記されない限り，
次で与えられる~targetに向けて発火されるべきである：
</p>
<ul>
	<li>
~mouse~eventを発火する時点で，`~pointer~event$の~targetがまだ`文書~tree内$にあるならば、
それと同じ~target。
</li>
	<li>
他の場合、［
`~pointer~event$を発火した時点で，その~targetの先祖であった~nodeたち
］のうち，［
`~mouse~event$を発火する時点で`文書~tree内$にあるもの
］のうち，最も子孫の~node†。
特に、
~mouse~eventの伝播~経路は，この先祖に基づく新たなものにされることになる。
</li>
</ul>

<p class="trans-note">【†
~event~handlerにより，~nodeたちが文書~内で他所に移動された場合、
そのような子孫は一意に定まらなくなる場合もあり得るが、
はっきりしない。
そのような子孫は除外されるべきようにも思われる。
また、
~targetが除去されず文書の他所へ移動された場合も，同様になるかもしれない
（`関係する課題＠https://github.com/w3c/pointerevents/issues/285$）。
】</p>

◎
Unless otherwise noted, the target of any mapped mouse event SHOULD be the same target as the respective pointer event unless the target is no longer participating in its ownerDocument's tree. In this case, the mouse event should be fired at the original target's nearest ancestor node (at the time it was removed from the tree) that still participates in its ownerDocument's tree, meaning that a new event path (based on the new target node) is built for the mouse event.
</div>

<p>
作者は、
`pointerdown$et ~eventを取消すことにより，
ある種の`互換性~mouse~event$の生産を防止できる
— ただし：
◎
Authors can prevent the production of certain compatibility mouse events by canceling the pointerdown event.
</p>
<ul>
	<li>
防止できるのは、
~pointerの~buttonが押されたときに限られる。
~hoverしている~pointer
（例： どの~buttonも押されていない~mouse）
による~mouse~eventは、
防止できない。
◎
Mouse events can only be prevented when the pointer is down. Hovering pointers (e.g. a mouse with no buttons pressed) cannot have their mouse events prevented.
</li>
	<li>
次に挙げる~eventは、
決して防止されない（~pointerの~buttonが押されていても）
⇒＃
`mouseover$et,
`mouseout$et,
`mouseenter$et,
`mouseleave$et
◎
The mouseover, mouseout, mouseenter, and mouseleave events are never prevented (even if the pointer is down).
</li>
</ul>

<p>
`互換性~mouse~event$は、
`~pointer~event$用の`~event~listener$【！EventListener】の`受動的か$evLが ~T に設定された所では，
防止し得ない。
`DOM$r
◎
Compatibility mouse events can't be prevented when a pointer event EventListener is set to be passive [DOM].
</p>

		<section id="tracking-the-effective-position-of-the-legacy-mouse-pointer">
<h3 title="Tracking the effective position of the legacy mouse pointer">13.1. 旧来の~mouse~pointerに対する位置の追跡-法</h3>

<p>
`互換性~mouse~event$を生産し得るのは`首~pointer$に限られるが、
`複数の首~pointer＠#multiple-primary-pointers$が
— 各自が自前の`互換性~mouse~event$を生産するように —
同時に作動中になり得る。
`MouseEvent$I に依拠している~scriptとの互換性を得るため、
~mouse遷移~event
（ `mouseover$et ／ `mouseout$et ／ `mouseenter$et ／ `mouseleave$et ）
は，単独の旧来の~mouse入力の動きを模倣sするベキである。
このことは、
どの~event~targetに対しても，［
~mouseの出入り状態は， `UIEVENTS$r に則って妥当になる
］ことを意味する。
~UAは、
文書~内の
`旧来の~mouse~pointerの実効~位置@
（ `effective legacy mouse pointer position^en ）
を次に従って保守することにより，これを保証するベキである。
◎
While only primary pointers can produce compatibility mouse events, multiple primary pointers can be active simultaneously, each producing its own compatibility mouse events. For compatibility with scripts relying on MouseEvents, the mouse transition events (mouseover, mouseout, mouseenter and mouseleave) SHOULD simulate the movement of a single legacy mouse input. This means that the entry/exit state for every event target is valid, in accordance with [UIEVENTS]. User agents SHOULD guarantee this by maintaining the effective position of the legacy mouse pointer in the document as follows.
</p>

<p class="trans-note">【
例えば、
同じ要素に向けて `mouseenter$et が（ `mouseleave$et を挟まずに）続けて発火されないようにするなど。
】</p>

<div class="algo">
<p>
~UAは、［
`pointerdown$et ／
`pointerup$et ／
`pointermove$et
］~eventを発火するとき, あるいは［
`~window$に向けて `pointerleave$et
］~eventを発火するときは、
その~event %event を発火する直前に，次の手続きを走らすベキである：
◎
Right before firing a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, the user agent SHOULD run the following steps:
</p>
<ol>
	<li>
%旧~位置 ~LET 現在の`旧来の~mouse~pointerの実効~位置$
◎
↓</li>
	<li>
%新~位置 ~LET ［
%event が `pointerleave$et ならば `域外^i ／
~ELSE_ %event の~target
］
◎
Let T be the target of the pointerdown, pointerup or pointermove event being dispatched. For the pointerleave event, unset T.
</li>
	<li>
~IF［
%新~位置 ~EQ %旧~位置
］
⇒
~RET
◎
If T and current effective legacy mouse pointer position are both unset or they are equal, terminate these steps.
</li>
	<li>
`UIEVENTS$r に従って、［
~mouseが %旧~位置 から %新~位置 へ移動した
］ものと見なした下で［
`mouseover$et ／
`mouseout$et ／
`mouseenter$et ／
`mouseleave$et
］~eventを発火する
— ここでの［
%旧~位置 ／ %新~位置
］に対する値 `域外^i は、
~mouse位置が~UIwindow外にあると見なす
◎
Dispatch mouseover, mouseout, mouseenter and mouseleave events as per [UIEVENTS] for a mouse moving from the current effective legacy mouse pointer position to T. Consider an unset value of either current effective legacy mouse pointer position or T as an out-of-window mouse position.
</li>
	<li>
`旧来の~mouse~pointerの実効~位置$ ~SET %新~位置
◎
Set effective legacy mouse pointer position to T.
</li>
</ol>
</div>

<div class="note">
<p>注記：
~pointer遷移~event
（ `pointerover^et, `pointerout^et, `pointerenter^et,  `pointerleave^et ）
から対応する旧来の~mouse遷移~event
（ `mouseover^et, `mouseout^et, `mouseenter^et, `mouseleave^et ）
への直な対応付けは、
常に可能とは限らない
— `旧来の~mouse~pointerの実効~位置$は、
その事実を~model化する。
~UAが［
単独の旧来の~mouse入力を利用している 2 つの`首~pointer$
］の~~調和を図るために［
旧来の~mouse遷移~eventを~pointer遷移~eventより多く配送する
］ことが必要になる事例を次の~animationで~~説明する。
◎
Note
The effective position of the legacy mouse pointer models the fact that we cannot always have a direct mapping from pointer transition events (pointerover, pointerout, pointerenter and pointerleave) to corresponding legacy mouse transition events (mouseover, mouseout, mouseenter and mouseleave). The following animation illustrates a case where a user agent needs to dispatch more legacy mouse transition events than pointer transition events to be able to reconcile two primary pointers using a single legacy mouse input.
</p>

<figure id="legacy-pointer-transition">
<video
	controls
	style="height:358px; max-width:100%; object-fit:contain;"
>
<source src="https://w3c.github.io/pointerevents/images/legacy-pointer-animation.webm" type="video/webm">
<source src="https://w3c.github.io/pointerevents/images/legacy-pointer-animation.mp4" type="video/mp4">
</video>
<figcaption>
同時な 2 つ~pointer
— ~mouse~pointer（白い~cursor）と~touch~pointer（白い “手形” ~cursor） —
が，単独の旧来の~mouse入力（橙色~cursor）を移動させる様子。
◎
Figure 10＼
Simultaneous mouse pointer (white cursor) and touch pointer (white "hand" cursor) causing the single legacy mouse input (orange cursor) to move between the two pointers.
</figcaption></figure>

<p>
この~animationにおいては、
~button 1 は：
◎
In this animation, note the time period between the mouse click and the touch tap.＼
</p>
<ul>
	<li>
~mouse~clickから~touch~tapまでの間は，
`pointerout^et ~eventを受取らない
（その間， “本物の” ~mouse~pointerは~button矩形を去らないので）
が、
`旧来の~mouse~pointerの実効~位置$が~touch~tapにより ~button 2 へ移動したとき， `mouseout^et ~eventを受取る。
◎
Button 1 receives no pointerout event (because the "real" mouse pointer didn't leave the button rectangle within this period), but Button 1 receives a mouseout event when the effective position of the legacy mouse pointer moves to Button 2 on touch tap.＼
</li>
	<li>
類似に，
~touch~tapから~mouseが~button 1 を去る直前までの間は，
同じ理由で `pointerover^et ~eventを受取らないが、
`旧来の~mouse~pointerの実効~位置$が移動して ~button 1 の内側へ戻ったとき，
`mouseover^et ~eventを受取る。
◎
Similarly, in the time period between the touch tap and the moment before the mouse leaves Button 1, Button 1 receives no pointerover event for the same reason, but Button 1 receives a mouseover event when the effective position of the legacy mouse pointer moves back inside Button 1.
</li>
</ul>
</div>

		</section>
		<section id="mapping-for-devices-that-support-hover">
<h3 title="Mapping for devices that support hover">13.2. ~hoverを~supportする装置~用の対応付け</h3>

<div class="algo">
<p>
~UAは、
~hoverを~supportする装置による`~pointer~event$ %~event を配送するときは，
次の手続きを走らすベキである：
◎
Whenever the user agent is to dispatch a pointer event for a device that supports hover, it SHOULD run the following steps:
</p>
<ol>
	<li>
~IF［
%~event の `isPrimary$m 属性 ~EQ ~F
］
⇒＃
%~event を配送する；
~RET
◎
If the isPrimary property for the pointer event to be dispatched is false then dispatch the pointer event and terminate these steps.
</li>
	<li>
~IF［
%~event の型 ~IN
{ `pointerdown$et, `pointerup$et, `pointermove$et }
］~OR［［
%~event の型 ~EQ `pointerleave$et
］~AND［
%~event の~targetは`~window$である
］］
⇒
`§ 旧来の~mouse~pointerに対する位置の追跡-法＠#tracking-the-effective-position-of-the-legacy-mouse-pointer$に従って，互換性~mouse遷移~eventを配送する
◎
If the pointer event to be dispatched is a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, dispatch compatibility mouse transition events as described in Tracking the effective position of the legacy mouse pointer.
</li>
	<li>
%~event を`互換性~mouse~eventも込みで配送する$
◎
↓</li>
</ol>
</div>

<div class="algo">
<p>
`~pointer~event$ %~event を
`互換性~mouse~eventも込みで配送する@
~algoは：
◎
↓</p>

<ol>
	<li>
%~event を配送する
◎
Dispatch the pointer event.
</li>
	<li>
%装置~型 ~LET %~event の `pointerType$m
◎
↓</li>
	<li>
~IF［
%~event の型 ~EQ `pointerdown$et
］~AND［
%~event の`取消されたか$ev ~EQ ~T
］
⇒
%装置~型 用の`~mouse~eventは防止するか$ ~SET ~T
◎
If the pointer event dispatched was pointerdown and event's canceled flag is set, then set the PREVENT MOUSE EVENT flag for this pointerType.
</li>
	<li>
<p>
~IF［
%装置~型 用の`~mouse~eventは防止するか$ ~EQ ~F
］
⇒
%~event の型に応じて、
次の表tの 2 列目に与える型の~mouse~eventを，
3 列目に与える~targetに向けて発火する：
</p>

<table><thead>
<tr><th>%~event の型
<th>~mouse~event型
<th>~target
<tbody>

<tr><td>`pointerdown$et
<td>`mousedown$et
<td>%~event の~target

<tr><td>`pointermove$et
<td>`mousemove$et
<td>%~event の~target

<tr><td>`pointerup$et
<td>`mouseup$et
<td>%~event の~target

<tr><td>`pointercancel$et
<td>`mouseup$et
<td>`~window$
</table>

◎
If the PREVENT MOUSE EVENT flag is not set for this pointerType and the pointer event dispatched was:
◎
pointerdown, then fire a mousedown event.
◎
pointermove, then fire a mousemove event.
◎
pointerup, then fire a mouseup event.
◎
pointercancel, then fire a mouseup event at the window.
</li>
	<li>
~IF［
%~event の型 ~IN { `pointerup$et, `pointercancel$et }
］
⇒
%装置~型 用の`~mouse~eventは防止するか$ ~SET ~F
◎
If the pointer event dispatched was pointerup or pointercancel, clear the PREVENT MOUSE EVENT flag for this pointerType.
</li>
</ol>
</div>

		</section>
		<section id="mapping-for-devices-that-do-not-support-hover">
<h3 title="Mapping for devices that do not support hover">13.3. ~hoverを~supportしない装置~用の対応付け</h3>

<p>
ほとんどの~touchscreenなど、
`作動中$でない間は，座標（または座標たちが成す集合）に対する~hoverを~supportしない装置もある。
~mouse~event向けに書かれている既存の多数の~codeは、
~eventが~mouseにより生産されていて，次の~~性質が一般に成り立つものと見做している：
◎
Some devices, such as most touchscreens, do not support hovering a coordinate (or set of coordinates) while not in the active state. Much existing content coded to mouse events assumes that a mouse is producing the events and thus certain qualities are generally true:
</p>

<ul>
	<li>
入力は、
作動化と独立に~hoverできる
（例：どの~buttonも押さないまま~mouse~cursorを動かす）。
◎
The input can hover independently of activation (e.g. moving a mouse cursor without any buttons pressed).
</li>
	<li>
入力は、
要素が~clickされる前に `mousemove$et ~eventを生産する見込みが高い。
◎
The input will likely produce the mousemove event on an element before clicking it.
</li>
</ul>

<p class="note">注記：
~hoverは、
~mouse向けに設計された内容にて，~UI要素の可視性を~toggleするために利用されることもある
（例： “~hover~menu” ）。
そのような内容は、
`~hoverを~supportしない装置$と互換にならないことが多い。
この仕様は、
この局面における互換性を得るための対応付けや挙動は定義しない。
それは、
将来~versionの仕様にて考慮されることになる。
◎
Note
Hover is sometimes used to toggle the visibility of UI elements in content designed for mouse (e.g. "hover menus"). This content is often incompatible with devices that do not support hover. This specification does not define a mapping or behavior for compatibility with this scenario. It will be considered in a future version of the specification.
</p>

<div class="algo">
<p>
このことから，~UAには、
これらの型の入力~装置に対しては，異なる対応付けを供することが要求される。
~UAは、
所与の %~target に向けて［
`~hoverを~supportしない装置$による`~pointer~event$
］ %~event を配送するときは，次の手続きを走らすベキである：
◎
This requires that user agents provide a different mapping for these types of input devices. Whenever the user agent is to dispatch a pointer event for a device that does not support hover, it SHOULD run the following steps:
</p>

<ol>
	<li>
~IF［
%~event の `isPrimary$m 属性 ~EQ ~F
］
⇒＃
%~event を配送する；
~RET
◎
If the isPrimary property for the pointer event to be dispatched is false then dispatch the pointer event and terminate these steps.
</li>
	<li>
%~pointer ~LET %~event を生じさせた~pointer
◎
↓</li>
	<li>
~IF［
%~event の型 ~EQ `pointerover$et
］~AND［
%~pointer による `pointerdown$et ~eventはまだ生じていない
］
⇒
`mousemove$et ~eventを発火する（旧来の~mouse向け~codeとの互換性を得るために）
◎
If the pointer event to be dispatched is pointerover and the pointerdown event has not yet been dispatched for this pointer, then fire a mousemove event (for compatibility with legacy mouse-specific code).
</li>
	<li>
~IF［
%~event の型 ~IN
{ `pointerdown$et, `pointerup$et, `pointermove$et }
］~OR［［
%~event の型 ~EQ `pointerleave$et
］~AND［
%~event の~targetは`~window$である
］］
⇒
`§ 旧来の~mouse~pointerに対する位置の追跡-法＠#tracking-the-effective-position-of-the-legacy-mouse-pointer$に従って，互換性~mouse遷移~eventを配送する
◎
If the pointer event to be dispatched is a pointerdown, pointerup or pointermove event, or a pointerleave event at the window, dispatch compatibility mouse transition events as described in Tracking the effective position of the legacy mouse pointer.
</li>
	<li>
%~event を`互換性~mouse~eventも込みで配送する$
◎
Dispatch the pointer event.
◎
If the pointer event dispatched was pointerdown and event's canceled flag is set, then set the PREVENT MOUSE EVENT flag for this pointerType.
◎
If the PREVENT MOUSE EVENT flag is not set for this pointerType and the pointer event dispatched was:
◎
pointerdown, then fire a mousedown event.
◎
pointermove, then fire a mousemove event.
◎
pointerup, then fire a mouseup event.
◎
pointercancel, then fire a mouseup event at the window.
◎
If the pointer event dispatched was pointerup or pointercancel, clear the PREVENT MOUSE EVENT flag for this pointerType.
</li>
</ol>
</div>

<p>
［
`~pointer~event$,
`TOUCH-EVENTS$r に定義される~touch~event
］どちらも~supportする~UAは、［
この節に述べた`互換性~mouse~event$,
`TOUCH-EVENTS$r にて要旨される`~fallback~mouse~event＠~TOUCHEVENTS#mouse-events$
］を両方とも生成しないモノトスル。
◎
If the user agent supports both Touch Events (as defined in [TOUCH-EVENTS]) and Pointer Events, the user agent MUST NOT generate both the compatibility mouse events as described in this section, and the fallback mouse events outlined in [TOUCH-EVENTS].
</p>

<div class="note">
<p>注記：
`~hoverを~supportしない装置$の`首~pointer$による要素の作動化（ `click$et ）
（例： ~touchscreen上の単独の手指）は、
概して，次の`~event連列$を生産することになる：
</p>

<ol>
<li>`mousemove$et
<li>`pointerover$et
<li>`pointerenter$et
<li>`mouseover$et
<li>`mouseenter$et
<li>`pointerdown$et
— この~eventの`取消されたか$evが ~T に設定された場合、
以降における［
`mousedown$et, `mousemove$et, `mouseup$et
］は生産されない。
<li>`mousedown$et
<li>~pointerの動きに依存して， 0 回以上の［
`pointermove$et ／ `mousemove$et
］~event
<li>`pointerup$et
<li>`mouseup$et
<li>`pointerout$et
<li>`pointerleave$et
<li>`mouseout$et
<li>`mouseleave$et
<li>`click$et
</ol>

◎
Note
The activation of an element (click) with a primary pointer that does not support hover (e.g. single finger on a touchscreen) would typically produce the following event sequence:
• mousemove
• pointerover
• pointerenter
• mouseover
• mouseenter
• pointerdown
• mousedown
• Zero or more pointermove and mousemove events, depending on movement of the pointer
• pointerup
• mouseup
• pointerout
• pointerleave
• mouseout
• mouseleave
• click
◎
If, however, the pointerdown event canceled flag is set during this interaction then the sequence of events would be:
• mousemove
• pointerover
• pointerenter
• mouseover
• mouseenter
• pointerdown
• Zero or more pointermove events, depending on movement of the pointer
• pointerup
• pointerout
• pointerleave
• mouseout
• mouseleave
• click
</div>

		</section>
	</section>
	<section id="security-and-privacy-considerations">
<h2 title="Security and privacy considerations">~security／~privacyの考慮点</h2>

<p>
この付録では、
Pointer Events 実装における［
~security／~privacy
］の考慮点について論じる。
論点は、
この仕様に定義される［
~event~model, ~API, ~event
］の実装から直に発生する［
~security／~privacy
］の課題に限られる。
◎
This appendix discusses security and privacy considerations for Pointer Events implementations. The discussion is limited to security and privacy issues that arise directly from implementation of the event model, APIs and events defined in this specification.
</p>

<p>
この仕様に定義される~event型の多くは、
利用者の動作に呼応して配送される。
これは、
悪意的な~event~listenerが［
概して，利用者が機密的と考える情報
］
— 例：利用者が~pageとヤリトリしている間の［
~mouse／~stylus／手指
］の正確な経路や動きなど —
への~accessを得られるようにする。
◎
Many of the event types defined in this specification are dispatched in response to user actions. This allows malicious event listeners to gain access to information users would typically consider confidential, e.g., the exact path/movement of a user's mouse/stylus/finger while interacting with a page.
</p>

<p>
~pointer~eventは、
追加的な情報を（利用者の装置が~supportする所で）包含する
— ~pen入力に保持されている角度や傾き／
接触~物理面の幾何／
~stylusや~touch~screen上に~~感知された押圧
など。
［
角度, 傾き, 幾何, 押圧
］の情報は、
利用者~機器の~sensorに直に関係する。
すなわち、
この仕様は，そのような~sensorへの~accessを生成元に許容する。
◎
Pointer events contain additional information (where supported by the user's device), such as the angle or tilt at which a pen input is held, the geometry of the contact surface, and the pressure exerted on the stylus or touch screen. Information about angle, tilt, geometry and pressure are directly related to sensors on the user's device, meaning that this specification allows an origin access to these sensors.
</p>

<p>
この~sensor~dataは、［
どの型の仕組み（~mouse, ~touch, ~pen, 等）が入力に利用されているか
］を決定する能とともに，［
利用者, あるいは利用者の装置や環境
］についての特性を推定するために利用され得る。
このように推定された特性, および装置や環境の情報それ自体も敏感になり得る
— 一例として、［
悪意的な~siteが，利用者が支援技術を利用しているか否か推定すること
］をさらに許容する。
この情報はまた、
特定0の利用者を追跡しようと試みるために［
利用者~profileを築く, あるいは “指紋収集する”
］目的に利用されるものにもなり得る。
◎
This sensor data, as well as the ability to determine the type of input mechanism (mouse, touch, pen) used, may be used to infer characteristics of a user, or of the user's device and environment. These inferred characteristics and any device/environment information may themselves be sensitive — for instance, they may allow a malicious site to further infer if a user is using assistive technologies. This information can also be potentially used for the purposes of building a user profile and/or attempting to "fingerprint" and track a particular user.
</p>

<p>
~UAは、
軽減策として，［
特定0の~sensor~data（角度, 傾き, 押圧など）への~access
］を［
利用者が不能化する能を含める
］ことや，それを［
利用者から明示的に~~許可された後に限り，可用にする
］ことを考慮してもよい。
◎
As mitigation, user agents may consider including the ability for users to disable access to particular sensor data (such as angle, tilt, pressure), and/or to make it available only after an explicit opt-in from the user.
</p>

<p>
この仕様は、［
作者が “予測された~event群” へ~accessできる
］ような~methodを定義する。
この仕様~自体は、
~UAが そのような予測~用に利用するべき~algoを定義しない。
この仕様の策定者は、
そのような~algoが依拠するものは，先行する［
利用者が遂行している現在の~gestureに関係する`~pointer~event$
］に限られるものと想定している。
~UAに特有な予測~algoの実装が［
利用者についての敏感な情報も露呈し得る／
利用者を “指紋収集して” 追跡するためにも利用し得る
］ような追加的な~data
— 複数~siteにわたる利用者-ヤリトリの全部的な履歴など —
に依拠しないことを確保することは、
~UAの責務である。
◎
This specification defines the method by which authors can access "predicted events". The specification does not, itself, define the algorithms that user agents should use for their prediction. The specification authors envisage the algorithms to only rely on preceding pointer events related to the current gesture that a user is performing. It is the responsibility of user agents to ensure that their specific implementation of a prediction algorithm does not rely on any additional data - such as the user's full interaction history across different sites - that could reveal sensitive information about a user or be used to "fingerprint" and track them.
</p>

<p>
当~WGは、
上述を超えるような考慮点は，この仕様には無いものと予見している：
◎
Beyond these considerations, the working group believes that this specification:
</p>

<ul>
	<li>
個人識別可能な情報は、
公開しない。
◎
Does not expose personally-identifiable information.
</li>
	<li>
高価値な~dataを処することはない。
◎
Does not deal with high-value data.
</li>
	<li>
複数の閲覧~sessionに持続するような，生成元~用の新たな状態は、
導入しない。
◎
Does not introduce new state for an origin that persists across browsing sessions.
</li>
	<li>
異なる生成元にわたって持続するような状態は、
~webに公開しない。
◎
Does not expose persistent, cross-origin state to the web.
</li>
	<li>
現在~accessできない他のどのような~dataも、
生成元に公開しない。
◎
Does not expose any other data to an origin that it doesn’t currently have access to.
</li>
	<li>
~scriptを［
実行する／読込む
］ような新たな仕組みは、
可能化しない。
◎
Does not enable new script execution/loading mechanisms.
</li>
	<li>
利用者の所在への~accessは、
生成元に許容しない。
◎
Does not allow an origin access to a user’s location.
</li>
	<li>
~UAが “私的閲覧” ~mode下にあるときの特別な取扱いは、
要求しない。
◎
Does not require any special handling when the user agent is in "incognito" mode.
</li>
	<li>
他の装置への~accessは、
生成元に許容しない。
◎
Does not allow an origin access to other devices.
</li>
	<li>
~UAに~nativeな~UI越しの制御は、
生成元に許容しない。
◎
Does not allow an origin control over a user agent’s native UI.
</li>
	<li>
一時的な識別子は、
~webに公開しない。
◎
Does not expose temporary identifiers to the web.
</li>
	<li>
挙動が［
当事者-主体, 第三者-主体
］どちらの文脈におけるものかは、
判別しない。
◎
Does not distinguish between behavior in first-party and third-party contexts.
</li>
	<li>
利用者に局所的な装置には、
~dataを持続しない。
◎
Does not persist data to a user’s local device.
</li>
	<li>
既定の~security特性へ降格することは、
許容しない。
◎
Does not allow downgrading default security characteristics.
</li>
</ul>

	</section>
	<section id="glossary">
<h2 title="Glossary">用語集</h2>

◎非規範的

<dl class="def-list">
	<dt>
~pointerの~buttonが
`作動~状態@
（ `active buttons state^en ）にある
</dt>
	<dd>
<p>
`~pointer~event$の `buttons$m 属性が 0 以外の値をとる条件を満たしていることを意味する：
</p>
		<ul>
			<li>
~mouseに対しては、
装置にて何らかの~buttonが押下されているとき。
</li>
			<li>
~touchに対しては、
`~digitizer$との物理的~接触があるとき。
</li>
			<li>
~penに対しては、
~penによる`~digitizer$との物理的~接触があるとき, または
~hover中にいずれかの~buttonが押下されているとき。
</li>
		</ul>
◎
The condition when a pointer has a non-zero value for the buttons property. For mouse, this is when the device has at least one button depressed. For touch, this is when there is physical contact with the digitizer. For pen, this is when either the pen has physical contact with the digitizer, or at least one button is depressed while hovering.
</dd>

	<dt>
`作動中な文書@
（ `active document^en ）
</dt>
	<dd>
所与の`作動中な~pointer$に対し，その~pointerからの【ある種の型の】~eventを最後に受取った文書【に設定されることになる（初期~時は “未設定” ）】。
◎
For every active pointer, the document that received the last event from that pointer.
</dd>

	<dt>
`作動中な~pointer@
（ `active pointer^en ）, または 単に~pointer† 
</dt>
	<dd>
<p>
~touch接触, ~penや~stylus, ~mouse~cursor,
その他，~eventを生産し得るような~pointer。
所与の~pointer（ `pointerId$m により一意に識別される）が，文書の中で追加的な~eventを生産し得るならば、
その~pointerは，依然として作動中と見なされる。
例えば：
◎
Any touch contact, pen/stylus, mouse cursor, or other pointer that can produce events. If it is possible for a given pointer (identified by a unique pointerId) to produce additional events within the document, then that pointer is still considered active. Examples:
</p>
		<ul>
			<li>
機器に接続された~mouseは、
常に作動中と見なされる。
◎
A mouse connected to the device is always active.
</li>
			<li>
~screen上の~touch接触は、
作動中と見なされる。
◎
A touch contact on the screen is considered active.
</li>
			<li>
~touch接触／~penや~stylus
が`~digitizer$の範囲を超えるように持上げられた場合、
それは もはや作動中とは見なされない。
◎
If a touch contact or pen/stylus is lifted beyond the range of the digitizer, then it is no longer considered active.
</li>
		</ul>

<p class="note">注記：
~platformによっては、
`作動中な~pointer$たちが成す集合には，~UAを~targetにしていないもの
（例： 他の~appを~targetにしているもの）も含め，
装置へのすべての~pointer入力も含まれる。
◎
Note
On some platforms, the set of active pointers includes all pointer input to the device, including any that are not targeted at the user agent (e.g. those targeted at other applications).
</p>
	</dd>
	<dd class="trans-note">【†
`~pointer~event$を生産する装置を意味する用語として “`~pointer$” が下に定義されていて，紛らわしいが、
~event処理の文脈における語 “~pointer” は，この`作動中な~pointer$を（暗黙的に）指している
— 定義により，作動中でない~pointer`装置^emからは~eventは生じ得ないので。
すなわち，~pointerは、
装置が同じであっても，`作動中$な各~期間ごとに別々の~instanceを表現する
（原文には明示的にそう記されていないが、
そう解釈しなければ，~modelをきちんと定義できなくなる）。
】</dd>
	<dd>
<p>
各 `作動中な~pointer$には、
次に挙げるものが結付けられる
— これらは、
`~pointer捕捉$の制御に利用され，
当の~pointerにより生じる~eventの~targetを上書きする：
</p>
		<ul>
			<li>
`捕捉~target@
（ `pointer capture target override^en ）
⇒
~NULL／ある要素／`文書$
— 初期~時は ~NULL とする
（`文書$に設定されるのは、
~pointerが`作動中$な間に~targetが~DOMから除去された場合に起こる）。
</li>
			<li>
`処理待ち捕捉~target@
（ `pending pointer capture target override^en ）
⇒
~NULL／ある要素
— 初期~時は ~NULL とする。
</li>
		</ul>

<p class="trans-note">【
これらの用語は，原文では他所（~algo内）で定義されているが、
この訳では，ここに集約する（規範的）。
】</p>
	</dd>

	<dt>
`接触~幾何@
（ `contact geometry^en ）
</dt>
	<dd>
`~digitizer$上で入力された~~地点を囲う矩形域（最も共通的なものは，~touch ）。
これは概して、
~pointer入力の分解能が単独の画素より粗い装置を指す
【指先の大きさなど】
。
この~dataをまったく報告しない装置もある。
◎
The bounding box of an input (most commonly, touch) on a digitizer. This typically refers to devices with coarser pointer input resolution than a single pixel. Some devices do not report this data at all.
</dd>

	<dt>
`~delta@
（ `delta^en ）
</dt>
	<dd>
~UAが `WheelEvent$I ~interfaceとして~supportされるような入力~装置（~mouse~wheelや~touchpadなど）の物理的な動きに呼応して，~pageを~scrollしたり~zoomするときに見積もられる~scroll量。
`~delta$の値（例：
`deltaX$m, `deltaY$m, `deltaZ$m
属性）は、
`deltaMode$m ~propによる`測定~単位$として解釈される。
~wheel（または他の装置）の物理的な動きと`~delta$の正負との関係性は、
環境や装置に依存する。
しかしながら，~UAが`既定~動作$として~scrollする場合、
`~delta$の正負は`右手~座標系$により与えられる。
◎
The estimated scroll amount (in pixels, lines, or pages) that the user agent will scroll or zoom the page in response to the physical movement of an input device that supports the WheelEvent interface (such as a mouse wheel or touch pad). The value of a delta (e.g., the deltaX, deltaY, or deltaZ attributes) is to be interpreted in the context of the current deltaMode property. The relationship between the physical movement of a wheel (or other device) and whether the delta is positive or negative is environment and device dependent. However, if a user agent scrolls as the default action then the sign of the delta is given by a right-hand coordinate system where positive X,Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.
</dd>

	<dt>
`~digitizer@
（ `digitizer^en ）
</dt>
	<dd>
物理面に接触-あるいは近接している入力を検出できる型の入力~感知器。
最も共通的なものは、
~touch接触や~penや~stylusからの入力を感知する物理面である。
◎
A type of input sensing device in which a surface can detect input which is in contact and/or in close proximity. Most commonly, this is the surface that senses input from the touch contact or a pen/stylus.
</dd>

	<dt>
`直な操作@
（ `direct manipulation^en ／ `direct manipulation interaction^en† ）
◎
direct manipulation
</dt>
	<dd>
ある種の~UA（~touchscreen装置~上の~browserなど）は、
“直な操作” の~metaphorを実装する
— そこでの~pointerは、
各種~controlとヤリトリするのみならず，
現在の~pageを直に［
~panする／~zoomする
］ためにも利用され、
物理的に直に接触しているかのように錯覚させる。
例として，~touchscreen装置の利用者は、
一般に［
手指や~stylusを利用して~pointerを動かすことにより，
~pageを “掴んで” いるかのように~panする
］ことで，~pageを直に操作できる。
対照的に，定例の［
~desktop／~laptop
］用の~mouse~pointerでは、
~panningは~scrollbarを利用して行われる
— ~pageを “~dragする” のではなく。
◎
Certain user agents (such as browsers on a touchscreen device) implement a "direct manipulation" metaphor where a pointer not only interacts with controls, but is also used to directly pan or zoom the current page, providing the illusion of direct physical contact. As an example, users on a touchscreen device are generally able to use a finger or a stylus to "grab" a page and pan it by moving the pointer, directly manipulating the page. Contrast this with a mouse pointer on a regular desktop/laptop, where panning is done by using a scrollbar, rather than by "dragging" the page.
</dd>
	<dd class="note">注記：
“~dragする” ことにより~scrollすることを利用者に許容する事例には、
（~laptop上に見出される様な）~touchpadも挙げられる。
しかしながら，これは、
一般に［
“捏造な” ~mouse~wheel~eventを生成することにより達成される
］ので，直な操作には数えられない。
◎
Note
In some cases, touchpads (like those found on a laptop) will allow the user to scroll by "dragging" on the touchpad. However, this is generally achieved by the touchpad generating "fake" mouse wheel events, so this wouldn't count as a direct manipulation.
</dd>
	<dd class="trans-note">【†
この訳では、
`direct manipulation interaction^en
（`直な操作$によるヤリトリ）も単に “`直な操作$” と略記する
— この仕様における`直な操作$は、
常に，それによる（~pageとの）ヤリトリを含意するので。
</dd>

	<dt>
`直な~pan-zoom@
（ `direct manipulation for panning and zooming^en ）
</dt>
	<dd>
“~pan-zoom用の`直な操作$”
の【この訳による】略記。
</dd>
	<dd class="trans-note">【
`直な操作$のうち，何が~pan-zoom用とされるかは、
~UAに委ねられる。
】</dd>

	<dt>
`~hysteresis@
（ `hysteresis^en ）
</dt>
	<dd>
利用者~体験を改善するために［
所在や時間がずれた入力も一定限度までは受容する
］ような，ヒト~interface設計の特能。
例えば、［
利用者が~mouse~buttonを~double-clickするとき，
少しの時間差を受容すること
］は時間的~hysteresisであり，［
利用者が子~menuへ遷移しようとして~mouseが親~UIwindowから外れたとき，
入子な~menuを直ぐに閉じないこと
］は所在的~hysteresisである。
◎
A feature of human interface design to accept input values within a certain range of location or time, in order to improve the user experience. For example, allowing for small deviation in the time it takes for a user to double-click a mouse button is temporal hysteresis, and not immediately closing a nested menu if the user mouses out from the parent window when transitioning to the child menu is locative hysteresis.
</dd>

	<dt>
`測定-可能な~prop@
（ `measurable properties^en ）
</dt>
	<dd>
連続的な~pointer~sensor~dataに関係していて［
実数／整数
］【！from a large domain】を利用して表出される値を表現する~prop。
`~pointer~event$においては、
次に挙げるものが測定-可能な~propとされる
⇒＃
`width$m,
`height$m,
`pressure$m,
`tangentialPressure$m,
`tiltX$m,
`tiltY$m,
`twist$m,
`altitudeAngle$m,
`azimuthAngle$m,
（以下は `UIEVENTS$r に定義される `MouseEvent$I の~prop）
`screenX$m,
`screenY$m,
`clientX$m,
`clientY$m
◎
Measurable properties represent values relating to continuous pointer sensor data that is expressed using a real number or an integer from a large domain. For pointer events, width, height, pressure, tangentialPressure, tiltX, tiltY, twist, altitudeAngle, azimuthAngle, and the [UIEVENTS] Mouse Event model properties screenX, screenY, clientX, clientY are measurable properties.
</dd>
	<dd>
対照的に，次に挙げるものは、
~sensor~dataには関係しないので，測定-可能な~propとは見なされない
⇒＃
`pointerId$m,
`pointerType$m,
`isPrimary$m,
（以下は `UIEVENTS$r に定義される `MouseEvent$I の~prop）
`button$m,
`buttons$m,
`ctrlKey$m,
`shiftKey$m,
`altKey$m,
`metaKey$m
◎
In contrast pointerId, pointerType, isPrimary, and the [UIEVENTS] Mouse Event model properties button, buttons, ctrlKey, shiftKey, altKey, and metaKey are not considered measurable properties, as they don't relate to sensor data.
</dd>

	<dt>
`~pointer@
（ `pointer^en ）
</dt>
	<dd>
~screen上の特定の座標（または座標たちが成す集合）を~targetに捉えられる入力~装置
— ~mouse, ~pen, ~touch接触 など —
の，~hardwareに不問な表現。
◎
A hardware-agnostic representation of input devices that can target a specific coordinate (or set of coordinates) on a screen, such as a mouse, pen, or touch contact.
</dd>
	<dd class="trans-note">【
上で述べたとおり、
この語は，文脈によっては`作動中な~pointer$を意味することもある。
】</dd>

	<dt>
`回転@
（ `rotation^en ）
</dt>
	<dd>
`WheelEvent$I ~interfaceを利用している入力~装置~上の増分的な変化の指示。
装置によっては、
これには［
~wheelの回転動作,
平坦な表面をなぞる動き,
特定0の~buttonの押圧
］などがあり得る。
◎
An indication of incremental change on an input device using the WheelEvent interface. On some devices this MAY be a literal rotation of a wheel, while on others, it MAY be movement along a flat surface, or pressure on a particular button.
</dd>

	<dt>
`最上層な~event~target@
（ `topmost event target^en ）
</dt>
	<dd>
最上層な~event~targetは、
`~target$になれるような，最も上層に描画される要素でなければナラナイ。
~graphicな~UIにおいては、
これは，利用者の~pointing装置が~~指す所の~~直下にある要素になる。
</dd>
	<dd>
この~targetの決定は、
~UIの “接触判定” に基づく。
接触判定と積層~順序に関する特定の詳細は、
`~host言語$を見よ。
◎
The topmost event target MUST be the element highest in the rendering order which is capable of being a target. In graphical user interfaces this is the element under the user's pointing device. A user interface's hit testing facility is used to determine the target. For specific details regarding hit testing and stacking order, refer to the host language.
</dd>
	<dd class="trans-note">【
すなわち、
`~pointing先$か`捕捉~込みの~pointing先$
（どちらを指すかは明瞭でない）。
】【
例えば `pointer-events$p ~propなどにより，明示的に接触判定の対象から除外されるものは、
最も上層に塗られていても，最上層な~event~targetにはならない。
】</dd>
</dl>

<p class="trans-note">【
以下に挙げる用語は、
この訳による［
補完／明示的な定義／他の各所にある記述の集約
］。
】</p>

<dl class="def-list">
	<dt>
`~event連列@
（ `event sequence^en ）
</dt>
	<dd>
`作動中な~pointer$から所定の順序で同期的に生じる一連の~event。
</dd>

	<dt>
`~mouse~event@
（ `Mouse Events^en ）
</dt>
	<dd>
この仕様にて定義される各種~mouse~event（ `mouseXXX^et ）の総称
— 概ね、
`MouseEvent$I ~interfaceを実装するが，
`PointerEvent$I など，拡張された~interfaceは実装しない~event
（ `dblclick$et も含まれることになるが，はっきりしない）
（ `click$et, `contextmenu$et, `auxclick$et は含まれない）。
</dd>

	<dt>
`~pointer~event@
（ `Pointer Events^en ）
</dt>
	<dd>
この仕様にて定義される各種~pointer~event（ `pointerXXX^et ）の総称
— <a href="#the-click-auxclick-and-contextmenu-events">§ `click^et ／ `auxclick^et ／ `contextmenu^et ~event</a>
による追加を除いて，
`PointerEvent$I ~interfaceを実装する~eventとほぼ同義。
</dd>

	<dt>
`~pointing先@
（ `pointing^en 先 ）
</dt>
	<dd>
`作動中な~pointer$に対し，`接触判定$により決定される要素
— 無い場合は ~NULL になる。
~pointing先は、
当の~pointerが静止中であっても，`~layout変化＠#boundary-events-caused-by-layout-changes$により変化し得る。
</dd>
	<dd>
`~pointing先$が
`有効に変化-@
したとは、
その変化が［
~pointing装置の`首~pointer$によるものである†1
］かつ［
当の~pointerが利用者による`直な操作$により動かされたか，ある要素が動いた†2
］ことにより生じたことを意味する。
</dd>
	<dd class="trans-note">【†1
非 `首~pointer$からは、
この定義を参照する~mouse~event（`互換性~mouse~event$）は生じない。
】【†2
要素が “動いた” とは、
~scrollや~layout変化によるそれに加えて，要素を挿入するなどの~DOM変異によるそれも含まれる
（と思われる
— 少なくとも一部の~browserの実装は、
そうなっている）。
】【†2
動いた要素と変化-［
前／後
］の~pointing先が一致することは必要yでない。
例えば、
動いた要素は新たな~pointing先の先祖かもしれない。
】</dd>

	<dt>
`捕捉~込みの~pointing先@
</dt>
	<dd>
<p>
ある`作動中な~pointer$ %~pointer を捕捉している要素が在る場合、
~event配送の目的において`~pointing先$になり得るものは，要素の`広義-子孫$に拘束されることもある。
すなわち，ある要素 %要素 に関して［
~AND↓ が満たされるならば %要素 ／
~ELSE_ %~pointer の`~pointing先$
］：
</p>
		<ul>
			<li>
%要素 ~EQ %~pointer の`処理待ち捕捉~target$
（すなわち， %要素 は %~pointer を`捕捉-$している）
</li>
			<li>
%~pointer の`~pointing先$は、
%要素 の`広義-子孫$でない
</li>
		</ul>
	</dd>

	<dt>
`境界~event@
（ `boundary event^en ）
</dt>
	<dd>
`~pointing先$が要素~境界をまたいだときに生じる`~pointer~event$の総称
— 具体的には，次に挙げるもの
⇒＃
`pointerover$et,
`pointerout$et,
`pointerenter$et,
`pointerleave$et
</dd>

	<dt>
接触
（ `contact^en ）
</dt>
	<dd>
`~digitizer$が検出できる程に，物理的に［
接触している／近接している
］ことを意味する。
【！ touch と contact の概念的な相違は、前者には，何らかの~~操作が含意されることにある？】
</dd>

	<dt>
`~mouse~eventは防止するか@
（ `PREVENT MOUSE EVENT^c ~flag ）
</dt>
	<dd>
真偽値
— 初期~時は ~F とする。
</dd>
	<dd>
これは、
~pointer装置の各~型に結び付けられる。
~T をとる間は、
当の型の~pointer装置からは`互換性~mouse~event$は，生成されなくなる。
</dd>
</dl>

	</section>
	<section id="legacy-event-initializers">
<h2 title="Legacy Event Initializers">旧来の~event初期化子</h2>

<p>
`この節は規範的である。^em
以下の特能は、
廃用にされた。
これらは、
旧来の~softwareとの互換性が要求される`~UA$に限り，実装されるべきである。
◎
This section is normative. The following features are obsolete and should only be implemented by user agents that require compatibility with legacy software.＼
</p>

<p>
`UIEvents$r `§ 旧来の~event初期化子＠~UIEVENTS-A#legacy-event-initializers$
も見よ。
◎
See also the legacy event initializers in [UIEvents].
</p>

		<section id="idl-interface-MouseEvent-initializers">
<h3 title="Initializers for interface MouseEvent">16.1. `MouseEvent^I ~interface用の初期化子</h3>

<pre class="idl">
partial interface `MouseEvent$I {
    /* <span class="comment">
この仕様により非推奨にされた
◎
Deprecated in this specification
</span> */
    `undefined$ `initMouseEvent@m(<span class="comment">/* たくさんの引数 */</span>);
};
</pre>

<div>
<p class="trans-note">【
以下、
この訳では，この節を成す内容を省略する。
】</p>
◎
initMouseEvent(typeArg)
• Initializes attributes of a MouseEvent object. This method has the same behavior as UIEvent.initUIEvent().
• Warning
• The initMouseEvent method is deprecated, but supported for backwards-compatibility with widely-deployed implementations.

• DOMString typeArg
•• Refer to the initEvent() method for a description of this parameter.
• boolean bubblesArg
•• Refer to the initEvent() method for a description of this parameter.
• boolean cancelableArg
•• Refer to the initEvent() method for a description of this parameter.
• Window? viewArg
•• Specifies view. This value MAY be null.
• long detailArg
•• Specifies detail.
• long screenXArg
•• Specifies screenX.
• long screenYArg
•• Specifies screenY.
• long clientXArg
•• Specifies clientX.
• long clientYArg
•• Specifies clientY.
• boolean ctrlKeyArg
•• Specifies ctrlKey.
• boolean altKeyArg
•• Specifies altKey.
• boolean shiftKeyArg
•• Specifies shiftKey.
• boolean metaKeyArg
•• Specifies metaKey.
• short buttonArg
•• Specifies button.
• EventTarget? relatedTargetArg
•• Specifies relatedTarget. This value MAY be null.
</div>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
たくさんの方々からの提案や助言に感謝する。
それらの一部は、
この文書に組入れられている。
次に挙げる［
~~現在／~~過去
］の［
~group~memberたち, 参加者たち
］による貢献にも：
◎
Many thanks to lots of people for their proposals and recommendations, some of which are incorporated into this document. The group's Chair acknowledges contributions from the following past and present group members and participants:＼
</p>

<p lang="en">
Mustaq Ahmed,
Arthur Barstow,
Ben Boyle,
Matt Brubeck,
Rick Byers,
Marcos Cáceres,
Cathy Chan,
Bo Cupp,
Domenic Denicola,
Ted Dinklocker,
Adam Ettenberger,
Robert Flack,
Dave Fleck,
Mike Fraser,
Ella Ge,
Olga Gerchikov,
Scott González,
Kartikaya Gupta,
Dominique Hazael-Massieux,
Philippe Le Hégaret,
Hayato Ito,
Patrick Kettner,
Patrick H. Lauke,
Scott Low,
Sangwhan Moon,
Masayuki Nakano,
Olli Pettay,
Addison Phillips,
Alan Pyne,
Antoine Quint,
Jacob Rossi,
Kagami Sascha Rosylight,
Doug Schepers,
Ming-Chou Shih,
Brenton Simpson,
Dave Tapuska,
Liviu Tinta,
Asir Vedamuthu,
Lan Wei,
Jeffrey Yasskin,
Navid Zolghadr.
</p>

<p>
年月にわたり，［
~mouse~event, ~wheel~event
］に対し~careされた `Gary Kacmarcik^en, `Travis Leithead^en 各氏その他の様々な貢献者たちに謝意を。
◎
Thanks to those who took care of mouse and wheel events in the past: Gary Kacmarcik, Travis Leithead, and the various contributors over the years.
</p>

<p>
この~modelの最初の版のために先駆的な仕事をされた方々にも特別な謝意を
— とりわけ，次の方々に：
◎
Special thanks to those that helped pioneer the first edition of this model, including especially:＼
</p>

<p lang="en">
Charu Chandiram, Peter Freiling, Nathan Furtwangler, Thomas Olsen, Matt Rakow, Ramu Ramanathan, Justin Rogers, Jacob Rossi, Reed Townsend and Steve Wright.
</p>

	</section>
	<section id="revision-history">
<h2 title="Revision history">改訂~履歴</h2>

◎非規範的

<p>
`PointerEvents3$r 仕様からの［
~~主要な, および編集上の~~主な変更点
］を以下に要約する
（この仕様の編集者草案の
`完全な改訂~履歴＠https://github.com/w3c/pointerevents/commits$
を見よ）。
◎
The following is an informative summary of substantial and major editorial changes between publications of this specification, relative to the [PointerEvents3] specification. See the complete revision history of the Editor's Drafts of this specification.
</p>
<ul>
	<li>
`PointerEvent$I に `persistentDeviceId$m を追加した。
（ `495$pull ）
◎
Add persistentDeviceId to PointerEvent
</li>
</ul>

	</section>
</main></div>


