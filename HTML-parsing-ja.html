<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>HTML Standard — Parsing HTML documents（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>
.bytes,
.literal {
	color: var(--literal-color-2);
}

.encoding {
	font-family: sans-serif0, sans-serif;
}
.domTree {
	li {
		margin-top: 0;
		margin-bottom: 0;
		list-style-type: none;
		font-family: monospace0, monospace;
	}
	li::before {
		content: "└ ";
	}
	ul {
		padding-left: 2em;
	}
}

.parse-error,
.tokenizer-state,
.insertion-mode {
	font-family: sans-serif0, sans-serif;
}

.insertion-mode::after {
	content: " mode ";
	font-size: smaller;
	color: var(--dim-color);
}

.tokenizer-state::after {
	content: " state ";
	font-size: smaller;
	color: var(--dim-color);
}


#_dgm-model {
	contain: strict;
	position: relative;
	width: 480px;
	height: 400px;
	text-align: center;
	font-size: 16px;
	background: url(HTML-resources/parsing-model-overview.svg);
	background-repeat: no-repeat;

	> ._dgm-model-node:first-child,
	> ._dgm-model-node:last-child {
		background: linear-gradient(var(--W-color), #AAF);
	}
}

._dgm-model-node {
	position: absolute;
	width: 240px;
	height: 35px;
	line-height: 35px;
	top: 0;
	left: 0;
	white-space: nowrap;
	border: thin solid var(--K-color);
	background: linear-gradient(var(--W-color), #7F7);
	box-shadow: 0.2em 0.2em 0.2em 0.2em rgba(0,0,0,0.4)
}

#_text-node-sample1 {
	.lang-html {
		margin-left: 0;
	}
	td {
		vertical-align: top;
	}
}

@supports (grid-template-columns: subgrid) and (display: contents) {

#_text-node-sample1 {
	grid-template-columns: 2em 1fr;
	tr {
		grid-template-areas:
			"見本 見本"
			". text-node"
		;
		> *:nth-child(1) {
			grid-area: 見本;
			border-left-width: 0;
		}
		> *:nth-child(2) {
			grid-area: text-node;
			border: none;
		}
	}
}

}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	const unicode_map = PAGE_DATA.unicode_map
	.replace( /\n(\w+):(.+):(.*)/g, function(t0, t1, t2, t3){
		if(t3 === '-'){
			t3 = `&#x${t1};`
		}
		t3 = t3? ` (<span class="char-symbol">${t3}</span>)` : '';
		return(
`\n${t1}:<span class="code-point">U+${t1}</span> <span class="cp-name">${t2}</span>${t3}`
		);
	});

	delete PAGE_DATA.unicode_map;

	const source_data = {
		unicode_map: Util.get_mapping(unicode_map),
		toc_main: 'syntax',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;
	const unicode_map = this.unicode_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r': // ref
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l': // literal
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl': // literal bytes
	text = `\`<code class="bytes">${text}</code>\``;
	break;
case 'U': // code point
	text = unicode_map[key] || `<span class="code-point">U+${key}</span>`;
	break;
case 'X':
	text = `0x${text}`;
	break;
case 'pE':
	href = `#parse-error-${key}`;
	if(indicator === '$'){
		return (
`<a href="#parse-errors">~perror</a>( <a class="parse-error" href="${href}">${key}</a> )`
		);
	}
	break;
case 'm': // IDL member
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}


if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2025-10-17
trans_update:2025-10-18
source_checked:240712
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/parsing.html
	abbr_url:HTMLparsing
site_nav:html-syntax,html
nav_prev:HTMLwriting
nav_next:HTML-charrefs-ja.html
trans_1st_pub:2017-07-13


●●class_map
E:error
e:element
a:attr
et:event-type
U:code-point
X:hex-value
M:method
P:production
v:value
st:tokenizer-state
md:insertion-mode
pE:parse-error
enc:encoding
ast:attr-state

●●tag_map
I:code
m:code
c:code
e:code
a:code
et:code
v:code
U:span
X:span
M:code
P:code
st:span
md:span
mt:code
pE:span
enc:span
ast:span
sub:sub
i:i
wBDst:i
em:em
V:var
cite:cite


●●original_urls
writing:https://html.spec.whatwg.org/multipage/writing.html

●●unicode_map


0000:NULL:
0009:CHARACTER TABULATION:tab
000A:LINE FEED:LF
000C:FORM FEED:FF
000D:CARRIAGE RETURN:CR
0020:SPACE:
0021:EXCLAMATION MARK:-
0022:QUOTATION MARK:-
0023:NUMBER SIGN:-
0026:AMPERSAND:-
0027:APOSTROPHE:-
002D:HYPHEN-MINUS:-
002F:SOLIDUS:-
003B:SEMICOLON:-
003C:LESS-THAN SIGN:-
003D:EQUALS SIGN:-
003E:GREATER-THAN SIGN:-
003F:QUESTION MARK:-
005B:LEFT SQUARE BRACKET:-
005D:RIGHT SQUARE BRACKET:-
0060:GRAVE ACCENT:-
0058:LATIN CAPITAL LETTER:-
0055:LATIN CAPITAL LETTER:-
0078:LATIN SMALL LETTER:-
FFFD:REPLACEMENT CHARACTER:


●●original_id_map


●●words_table1

WEBDRIVER-BIDI:https://w3c.github.io/webdriver-bidi/
UIEVENTS-A:uievents-appendix-ja.html

about_legacy-compat:<code class="scheme">about:legacy-compat</code>
HTMLcharrefs:HTML-charrefs-ja.html

script0:script
title0:title
APPEND:<b class="op">&lt;&lt;</b>
EOF:<i>EOF</i>


●●link_map


	●IDL

#text:~DOM4#interface-text
#comment:~DOM4#interface-comment
I.Comment:~DOM4#interface-comment
I.Element:~DOM4#interface-element
I.Document:~HTMLdom#document
I.DocumentType:~DOM4#interface-documenttype
I.HTMLMenuElement:~HEgrouping#htmlmenuelement
I.ServiceWorkerContainer:~SW1#serviceworkercontainer
I.ShadowRoot:~DOM4#interface-shadowroot
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window

m.bubbles:~DOM4#dom-event-bubbles
m.doctype:~DOM4#dom-document-doctype
m.persisted:~WINDOW#dom-pagetransitionevent-persisted

c.document.close():~HTMLdynamic#dom-document-close
c.document.open():~HTMLdynamic#dom-document-open
c.document.write():~HTMLdynamic#dom-document-write
c.document.writeln():~HTMLdynamic#dom-document-writeln

et.DOMContentLoaded:~HTMLindex#event-domcontentloaded
et.load:~HTMLindex#event-load
et.pageshow:~HTMLindex#event-pageshow

	＊about:legacy-compat:~HTMLurl#about:legacy-compat
mt.text/html:~HTMLiana#text/html

	●要素

e.a:~HEtextlevel#the-a-element
e.abbr:~HEtextlevel#the-abbr-element
e.b:~HEtextlevel#the-b-element
e.bdi:~HEtextlevel#the-bdi-element
e.bdo:~HEtextlevel#the-bdo-element
e.br:~HEtextlevel#the-br-element
e.cite:~HEtextlevel#the-cite-element
e.code:~HEtextlevel#the-code-element
e.data:~HEtextlevel#the-data-element
e.dfn:~HEtextlevel#the-dfn-element
e.em:~HEtextlevel#the-em-element
e.i:~HEtextlevel#the-i-element
e.kbd:~HEtextlevel#the-kbd-element
e.mark:~HEtextlevel#the-mark-element
e.q:~HEtextlevel#the-q-element
e.rp:~HEtextlevel#the-rp-element
e.rt:~HEtextlevel#the-rt-element
e.ruby:~HEtextlevel#the-ruby-element
e.s:~HEtextlevel#the-s-element
e.samp:~HEtextlevel#the-samp-element
e.small:~HEtextlevel#the-small-element
e.span:~HEtextlevel#the-span-element
e.strong:~HEtextlevel#the-strong-element
e.sub:~HEtextlevel#the-sub-and-sup-elements
e.sup:~HEtextlevel#the-sub-and-sup-elements
e.time:~HEtextlevel#the-time-element
e.u:~HEtextlevel#the-u-element
e.var:~HEtextlevel#the-var-element
e.wbr:~HEtextlevel#the-wbr-element

e.blockquote:~HEgrouping#the-blockquote-element
e.div:~HEgrouping#the-div-element
e.dl:~HEgrouping#the-dl-element
e.dd:~HEgrouping#the-dd-element
e.dt:~HEgrouping#the-dt-element
e.figure:~HEgrouping#the-figure-element
e.figcaption:~HEgrouping#the-figcaption-element
e.hr:~HEgrouping#the-hr-element
e.li:~HEgrouping#the-li-element
e.main:~HEgrouping#the-main-element
e.menu:~HEgrouping#the-menu-element
e.ol:~HEgrouping#the-ol-element
e.p:~HEgrouping#the-p-element
e.pre:~HEgrouping#the-pre-element
e.search:~HEgrouping#the-search-element
e.ul:~HEgrouping#the-ul-element

e.del:~HEedits#the-del-element
e.ins:~HEedits#the-ins-element

e.address:~HEsections#the-address-element
e.article:~HEsections#the-article-element
e.aside:~HEsections#the-aside-element
e.body:~HEsections#the-body-element
e.footer:~HEsections#the-footer-element
e.header:~HEsections#the-header-element
e.hgroup:~HEsections#the-hgroup-element
e.nav:~HEsections#the-nav-element
e.section:~HEsections#the-section-element
e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h2:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h3:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h4:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h5:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h6:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements

e.base:~HEmetadata#the-base-element
e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element
e.title:~HEmetadata#the-title-element

e.noscript:~HEscripting#the-noscript-element
e.script:~HEscripting#the-script-element
e.slot:~HEscripting#the-slot-element
e.template:~HEscripting#the-template-element
e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.fieldset:~HEforms#the-fieldset-element
e.form:~HEforms#the-form-element
e.legend:~HEforms#the-legend-element
e.label:~HEforms#the-label-element
e.meter:~HEforms#the-meter-element
e.output:~HEforms#the-output-element
e.optgroup:~HEforms#the-optgroup-element
e.option:~HEforms#the-option-element
e.progress:~HEforms#the-progress-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.summary:~HEinteractive#the-summary-element

e.area:~HEimages#the-area-element
e.img:~HEimages#the-img-element
e.map:~HEimages#the-map-element
e.source:~HEimages#the-source-element
e.picture:~HEimages#the-picture-element

e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.object:~HEembed#the-object-element

e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element
e.track:~HEtrack#the-track-element

e.table:~HEtables#the-table-element
e.td:~HEtables#the-td-element
e.th:~HEtables#the-th-element
e.tr:~HEtables#the-tr-element
e.caption:~HEtables#the-caption-element
e.colgroup:~HEtables#the-colgroup-element
e.tbody:~HEtables#the-tbody-element
e.tfoot:~HEtables#the-tfoot-element
e.thead:~HEtables#the-thead-element
e.col:~HEtables#the-col-element

e.applet:~HTMLobs#applet
e.basefont:~HTMLobs#basefont
e.bgsound:~HTMLobs#bgsound
e.big:~HTMLobs#big
e.center:~HTMLobs#center
e.dir:~HTMLobs#dir
e.font:~HTMLobs#font
e.frame:~HTMLobs#frame
e.frameset:~HTMLobs#frameset
e.keygen:~HTMLobs#keygen
e.listing:~HTMLobs#listing
e.marquee:~HTMLobs#the-marquee-element
e.nobr:~HTMLobs#nobr
e.noembed:~HTMLobs#noembed
e.noframes:~HTMLobs#noframes
e.param:~HTMLobs#param
e.plaintext:~HTMLobs#plaintext
e.rb:~HTMLobs#rb
e.rtc:~HTMLobs#rtc
e.strike:~HTMLobs#strike
e.tt:~HTMLobs#tt
e.xmp:~HTMLobs#xmp


	eMath.
e.annotation-xml:~MATHMLcore#dfn-annotation-xml
e.mi:~MATHMLcore#the-mi-element
e.mn:~MATHMLcore#number-mn
e.mo:~MATHMLcore#operator-fence-separator-or-accent-mo
e.ms:~MATHMLcore#string-literal-ms
e.mtext:~MATHMLcore#text-mtext


e.desc:~SVGstruct#elementdef-desc
e.foreignObject:~SVGembedded#elementdef-foreignObject
e.~title0:~SVGstruct#elementdef-title
e.~script0:~SVGinteract#elementdef-script


a.id:~HTMLdom#the-id-attribute
a.is:~HEcustom#attr-is
a.http-equiv:~HEmetadata#attr-meta-http-equiv
a.charset:~HEmetadata#attr-meta-charset
a.content:~HEmetadata#attr-meta-content
a.src:~HEscripting#attr-script-src
a.class:~HTMLdom#classes
a.form:~HTMLforms#attr-fae-form
a.name:~HEmetadata#attr-meta-name
a.shadowrootmode:~HEscripting#attr-template-shadowrootmode
a.shadowrootclonable:~HEscripting#attr-template-shadowrootclonable
a.shadowrootserializable:~HEscripting#attr-template-shadowrootserializable
a.shadowrootdelegatesfocus:~HEscripting#attr-template-shadowrootdelegatesfocus
a.shadowrootcustomelementregistry:~HEscripting#attr-template-shadowrootcustomelementregistry

l.referrer:~HEmetadata#meta-referrer

ast.なし:~HEscripting#attr-shadowrootmode-none-state

	●error
	#parse-error-abrupt-closing-of-empty-comment
	#parse-error-abrupt-doctype-public-identifier
	#parse-error-abrupt-doctype-system-identifier
	#parse-error-absence-of-digits-in-numeric-character-reference
	#parse-error-cdata-in-html-content
	#parse-error-character-reference-outside-unicode-range
	#parse-error-control-character-in-input-stream
	#parse-error-control-character-reference
	#parse-error-duplicate-attribute
	#parse-error-end-tag-with-attributes
	#parse-error-end-tag-with-trailing-solidus
	#parse-error-eof-before-tag-name
	#parse-error-eof-in-cdata
	#parse-error-eof-in-comment
	#parse-error-eof-in-doctype
	#parse-error-eof-in-script-html-comment-like-text
	#parse-error-eof-in-tag
	#parse-error-incorrectly-closed-comment
	#parse-error-incorrectly-opened-comment
	#parse-error-invalid-character-sequence-after-doctype-name
	#parse-error-invalid-first-character-of-tag-name
	#parse-error-missing-attribute-value
	#parse-error-missing-doctype-name
	#parse-error-missing-doctype-public-identifier
	#parse-error-missing-doctype-system-identifier
	#parse-error-missing-end-tag-name
	#parse-error-missing-quote-before-doctype-public-identifier
	#parse-error-missing-quote-before-doctype-system-identifier
	#parse-error-missing-semicolon-after-character-reference
	#parse-error-missing-whitespace-after-doctype-public-keyword
	#parse-error-missing-whitespace-after-doctype-system-keyword
	#parse-error-missing-whitespace-before-doctype-name
	#parse-error-missing-whitespace-between-attributes
	#parse-error-missing-whitespace-between-doctype-public-and-system-identifiers
	#parse-error-nested-comment
	#parse-error-non-void-html-element-start-tag-with-trailing-solidus
	#parse-error-noncharacter-character-reference
	#parse-error-noncharacter-in-input-stream
	#parse-error-null-character-reference
	#parse-error-surrogate-character-reference
	#parse-error-surrogate-in-input-stream
	#parse-error-unexpected-character-after-doctype-system-identifier
	#parse-error-unexpected-character-in-attribute-name
	#parse-error-unexpected-character-in-unquoted-attribute-value
	#parse-error-unexpected-equals-sign-before-attribute-name
	#parse-error-unexpected-null-character
	#parse-error-unexpected-question-mark-instead-of-tag-name
	#parse-error-unexpected-solidus-in-tag
	#parse-error-unknown-named-character-reference

	●enc
enc.Big5:~ENCODING#big5
enc.EUC-KR:~ENCODING#euc-kr
enc.ISO-2022-JP:~ENCODING#iso-2022-jp
enc.ISO-8859-2:~ENCODING#iso-8859-2
enc.ISO-8859-7:~ENCODING#iso-8859-7
enc.ISO-8859-8:~ENCODING#iso-8859-8
enc.Shift_JIS:~ENCODING#shift_jis
enc.UTF-16BE:~ENCODING#utf-16be
enc.UTF-16LE:~ENCODING#utf-16le
enc.UTF-16BE/LE:~ENCODING#utf-16be-le
enc.UTF-8:~ENCODING#utf-8
enc.GBK:~ENCODING#gbk
enc.windows-1250:~ENCODING#windows-1250
enc.windows-1251:~ENCODING#windows-1251
enc.windows-1252:~ENCODING#windows-1252
enc.windows-1254:~ENCODING#windows-1254
enc.windows-1255:~ENCODING#windows-1255
enc.windows-1256:~ENCODING#windows-1256
enc.windows-1257:~ENCODING#windows-1257
enc.windows-1258:~ENCODING#windows-1258
enc.windows-874:~ENCODING#windows-874
enc.x-user-defined:~ENCODING#x-user-defined


	●state

st.~CDATAsec~bracket:#cdata-section-bracket-state
st.~CDATAsec:#cdata-section-state
st.~CDATAsec終端:#cdata-section-end-state
st.~DOCTYPE~public-keywordの後:#after-doctype-public-keyword-state
st.~DOCTYPE~publicIDの前:#before-doctype-public-identifier-state
st.~DOCTYPE~publicIDの後:#after-doctype-public-identifier-state
st.~DOCTYPE~publicID（一重引用符）:#doctype-public-identifier-(single-quoted)-state
st.~DOCTYPE~publicID（二重引用符）:#doctype-public-identifier-(double-quoted)-state
st.~DOCTYPE:#doctype-state
st.~DOCTYPE~system-keywordの後:#after-doctype-system-keyword-state
st.~DOCTYPE~systemIDの前:#before-doctype-system-identifier-state
st.~DOCTYPE~systemIDの後:#after-doctype-system-identifier-state
st.~DOCTYPE~systemID（一重引用符）:#doctype-system-identifier-(single-quoted)-state
st.~DOCTYPE~systemID（二重引用符）:#doctype-system-identifier-(double-quoted)-state
st.~DOCTYPE名:#doctype-name-state
st.~DOCTYPE名の前:#before-doctype-name-state
st.~DOCTYPE名の後:#after-doctype-name-state
st.~PLAINTEXT:#plaintext-state
st.~RAWTEXT~LTsign:#rawtext-less-than-sign-state
st.~RAWTEXT:#rawtext-state
st.~RAWTEXT終了~tag~open:#rawtext-end-tag-open-state
st.~RAWTEXT終了~tag名:#rawtext-end-tag-name-state
st.~RCDATA~LTsign:#rcdata-less-than-sign-state
st.~RCDATA:#rcdata-state
st.~RCDATA終了~tag~open:#rcdata-end-tag-open-state
st.~RCDATA終了~tag名:#rcdata-end-tag-name-state
st.~DOCTYPE~publicIDと~systemIDの合間:#between-doctype-public-and-system-identifiers-state
st.似非~DOCTYPE:#bogus-doctype-state
st.似非~comment:#bogus-comment-state
st.~comment~LTsign~bang~dash~dash:#comment-less-than-sign-bang-dash-dash-state
st.~comment~LTsign~bang~dash:#comment-less-than-sign-bang-dash-state
st.~comment~LTsign~bang:#comment-less-than-sign-bang-state
st.~comment~LTsign:#comment-less-than-sign-state
st.~comment:#comment-state
st.~comment始端~dash:#comment-start-dash-state
st.~comment始端:#comment-start-state
st.~comment終端~bang:#comment-end-bang-state
st.~comment終端~dash:#comment-end-dash-state
st.~comment終端:#comment-end-state
st.~data:#data-state
st.~decimal文字~参照:#decimal-character-reference-state
st.~decimal文字~参照~始端:#decimal-character-reference-start-state
st.~hexadecimal文字~参照:#hexadecimal-character-reference-state
st.~hexadecimal文字~参照~始端:#hexadecimal-character-reference-start-state
st.~markup宣言~open:#markup-declaration-open-state
st.数量-文字~参照:#numeric-character-reference-state
st.数量-文字~参照~終端:#numeric-character-reference-end-state
st.~script~data二重~escape済み~dash~dash:#script-data-double-escaped-dash-dash-state
st.~script~data二重~escape済み~dash:#script-data-double-escaped-dash-state
st.~script~data二重~escape済み~LTsign:#script-data-double-escaped-less-than-sign-state
st.~script~data二重~escape済み:#script-data-double-escaped-state
st.~script~data二重~escape始端:#script-data-double-escape-start-state
st.~script~data二重~escape終端:#script-data-double-escape-end-state
st.~script~data~escape済み~dash~dash:#script-data-escaped-dash-dash-state
st.~script~data~escape済み~dash:#script-data-escaped-dash-state
st.~script~data~escape済み~LTsign:#script-data-escaped-less-than-sign-state
st.~script~data~escape済み:#script-data-escaped-state
st.~script~data~escape済み終了~tag~open:#script-data-escaped-end-tag-open-state
st.~script~data~escape済み終了~tag名:#script-data-escaped-end-tag-name-state
st.~script~data~escape始端~dash:#script-data-escape-start-dash-state
st.~script~data~escape始端:#script-data-escape-start-state
st.~script~data~LTsign:#script-data-less-than-sign-state
st.~script~data:#script-data-state
st.~script~data終了~tag~open:#script-data-end-tag-open-state
st.~script~data終了~tag名:#script-data-end-tag-name-state
st.~tag~open:#tag-open-state
st.~tag名:#tag-name-state
st.属性~値の前:#before-attribute-value-state
st.一重引用符付き属性~値:#attribute-value-(single-quoted)-state
st.二重引用符付き属性~値:#attribute-value-(double-quoted)-state
st.引用符付き属性~値の後:#after-attribute-value-(quoted)-state
st.引用符無し属性~値:#attribute-value-(unquoted)-state
st.属性~名:#attribute-name-state
st.属性~名の前:#before-attribute-name-state
st.属性~名の後:#after-attribute-name-state
st.文字~参照:#character-reference-state
st.有名~文字~参照:#named-character-reference-state
st.多義的~ampersand:#ambiguous-ampersand-state
st.終了~tag~open:#end-tag-open-state
st.自己閉じ開始~tag:#self-closing-start-tag-state

	●mode

md.初期:#the-initial-insertion-mode
md.~bodyの後の後:#the-after-after-body-insertion-mode
md.~framesetの後の後:#the-after-after-frameset-insertion-mode
md.~headの後:#the-after-head-insertion-mode
md.~headの前:#the-before-head-insertion-mode
md.~htmlの前:#the-before-html-insertion-mode
md.~bodyの後:#parsing-main-afterbody
md.~framesetの後:#parsing-main-afterframeset
md.~body内:#parsing-main-inbody
md.~caption内:#parsing-main-incaption
md.~cell内:#parsing-main-intd
md.~col~group内:#parsing-main-incolgroup
md.~frameset内:#parsing-main-inframeset
md.~head内:#parsing-main-inhead
md.~head~noscript内:#parsing-main-inheadnoscript
md.~row内:#parsing-main-intr
md.~table内:#parsing-main-intable
md.~table~body内:#parsing-main-intbody
md.~table~text内:#parsing-main-intabletext
md.~template内:#parsing-main-intemplate
md.~text:#parsing-main-incdata

md.外来~内容~内:#parsing-main-inforeign


	●用語
M.GET:~HTTPsem#GET

文書:#_document

特別:#special
特別な要素:#special
整形~要素:#formatting
普通の要素:#ordinary

作成させた~token:#_token-for-which-it-was-created
~perror:#parse-errors
~HTML素片の構文解析~algo:#html-fragment-parsing-algorithm
	:#html-fragment-parsing-algorithm
~HTML素片~用:#_for-html-fragment-parsing
素片~事例:#fragment-case

~HTML構文:#syntax
~HTML構文解析器:#html-parser

静止するか:#parser-pause-flag
~script入子ng~level:#script-nesting-level
構文解析を停止する:#stop-parsing
中止-:#abort-a-parser
構文解析器を中止する:#abort-a-parser

構文解析器は~modeを変更できないか:#parser-cannot-change-the-mode-flag

~load~eventを遅延する:#delay-the-load-event
~load後~task用に準備済み:#ready-for-post-load-tasks

~open要素~stack:#stack-of-open-elements
出るまで~open要素~stackから~popする:#_pop-until
~stackを~table~body文脈まで遡って~clearする:#clear-the-stack-back-to-a-table-body-context
~stackを~table文脈まで遡って~clearする:#clear-the-stack-back-to-a-table-context
~stackを~table~row文脈まで遡って~clearする:#clear-the-stack-back-to-a-table-row-context

作動中な整形~要素~list:#list-of-active-formatting-elements
作動中な整形~要素~listに~pushする:#push-onto-the-list-of-active-formatting-elements
作動中な整形~要素たちを構築し直す:#reconstruct-the-active-formatting-elements
~marker:#concept-parser-marker
作動中な整形~要素~listを最後の~markerまで~clearする:#clear-the-list-of-active-formatting-elements-up-to-the-last-marker

	§tree構築
~token化~段階:#tokenization
~tree構築~段階:#tree-construction
~tree構築~配送器:#tree-construction-dispatcher
	:#meta-charset-during-parse

~tokenから要素を作成する:#create-an-element-for-the-token
暗黙な終了~tagすべてを生成する:#generate-all-implied-end-tags-thoroughly
暗黙な終了~tagたちを生成する:#generate-implied-end-tags
~MathML~text統合~地点:#mathml-text-integration-point
~HTML統合~地点:#html-integration-point


挿入~mode:#insertion-mode
V.元の挿入~mode:#original-insertion-mode
挿入~modeを適切に設定し直す:#reset-the-insertion-mode-appropriately
~template挿入~mode~stack:#stack-of-template-insertion-modes
	現在の~template挿入~mode:#current-template-insertion-mode
用の規則を利用して:#using-the-rules-for
~HTML要素を挿入する:#insert-an-html-element
~commentを挿入する:#insert-a-comment
要素を挿入する:#_insert-an-element
外来な要素を挿入する:#insert-a-foreign-element
文字を挿入する:#insert-a-character

現在の調整-済み~node:#adjusted-current-node
要素を調整-済み挿入-先に挿入する:#insert-an-element-at-the-adjusted-insertion-location
外来な属性たちを調整する:#adjust-foreign-attributes
	:#adjust-foreign-attributes
~MathML属性たちを調整する:#adjust-mathml-attributes
~SVG属性たちを調整する:#adjust-svg-attributes

~frameset-ok~flag:#frameset-ok-flag
~scripting~flag:#scripting-flag
過去互換を強制するか:#force-quirks-flag
自己閉じか:#self-closing-flag
自己閉じを承認する:#acknowledge-self-closing-flag

養子縁組~algo:#adoption-agency-algorithm
	:#adoptionAgency

適切な終了~tag~token:#appropriate-end-tag-token
適切な~node挿入-先:#appropriate-place-for-inserting-a-node
属性の一部として消費されて:#charref-in-attribute
文字~参照として消費される~cpを一掃する:#flush-code-points-consumed-as-a-character-reference

~p要素を閉じる:#close-a-p-element
~cellを閉じる:#close-the-cell

V.文字~参照~code:#character-reference-code
V.文脈:#concept-frag-parse-context

現在の入力~文字:#current-input-character
現在の~node:#current-node

~form要素~pointer:#form-element-pointer
~head要素~pointer:#head-element-pointer

親を違える:#foster-parent

~RCDATA要素の汎用~構文解析~algo:#generic-rcdata-element-parsing-algorithm
生~text要素の汎用~構文解析~algo:#generic-raw-text-element-parsing-algorithm

視野~内:#has-an-element-in-the-specific-scope

既定の視野:#has-an-element-in-scope
~table視野:#has-an-element-in-table-scope
~list~item視野:#has-an-element-in-list-item-scope
~button視野:#has-an-element-in-button-scope

入力~byte~stream:#the-input-byte-stream
入力~stream:#input-stream
挿入~地点:#insertion-point
明示的な~EOF:#explicit-eof-character
次回の文字:#next-input-character
次回の入力~文字:#next-input-character
次回の~token:#next-token
次回の~LF文字~tokenは無視するようにしておく:#_ignore-next-lf-token

V.処理待ち~table文字~token~list:#concept-pending-table-char-tokens
消費し直す:#reconsume
	:#nestedParsing

V.一時~buffer:#temporary-buffer
~tokenizer:#tokenization
状態:#_tokenizer-state
V.戻先~状態:#return-state
切替える:#_switch-to

	§ 投機的
投機的な~HTML構文解析器:#speculative-html-parser
作動中な投機的な~HTML構文解析器:#active-speculative-html-parser
投機的な~HTML構文解析器を開始する:#start-the-speculative-html-parser
投機的な~HTML構文解析器を停止する:#stop-the-speculative-html-parser
投機的な~fetch:#speculative-fetch
doc.投機的な~fetch~URLたちが成す~list:#list-of-speculative-fetch-urls
投機的な模擬~要素を作成する:#create-a-speculative-mock-element
投機的な模擬~要素:#speculative-mock-element
mock.属性~list:#concept-mock-attribute-list
mock.子~群:#concept-mock-children
mock.局所-名:#concept-mock-local-name
mock.名前空間:#concept-mock-namespace


	§符号化法
確度:#concept-encoding-confidence
属性を取得する:#concept-get-attributes-when-sniffing
既知かつ確定的な符号化法:#a-known-definite-encoding
符号化法を変更する:#change-the-encoding
符号化法を~sniffする~algo:#encoding-sniffing-algorithm
~byte~streamを予走査して符号化法を決定する:#prescan-a-byte-stream-to-determine-its-encoding
V.終了~条件:#prescan-end-condition
~XML符号化法を取得する:#concept-get-xml-encoding-when-sniffing

	#documentEncoding
	#utf-8
	#iso-8859-2
	#iso-8859-7
	#iso-8859-8
	#windows-874
	#windows-1250
	#windows-1251
	#windows-1252
	#windows-1254
	#windows-1255
	#windows-1256
	#windows-1257
	#windows-1258
	#gbk
	#big5
	#iso-2022-jp
	#shift_jis
	#euc-kr
	#utf-16be
	#utf-16le
	#x-user-defined

	●syntax
有名~文字~参照:~HTMLcharrefs#named-character-references

~DOCTYPE:~HTMLwriting#syntax-doctype
~CDATAsec:~HTMLwriting#syntax-cdata
~comment:~HTMLwriting#syntax-comments
~DOCTYPE:~HTMLwriting#syntax-doctype
多義的~ampersand:~HTMLwriting#syntax-ambiguous-ampersand
属性:~HTMLwriting#syntax-attributes
属性~名:~HTMLwriting#syntax-attribute-name
属性~値:~HTMLwriting#syntax-attribute-value
文字~参照:~HTMLwriting#syntax-charref
~void要素:~HTMLwriting#void-elements
終了~tag:~HTMLwriting#syntax-end-tag
開始~tag:~HTMLwriting#syntax-start-tag

	●HTML
~XML構文:~HTMLxml#the-xhtml-syntax
~HTML要素:~HTMLINFRA#html-elements
並列的:~HTMLINFRA#in-parallel

	in the terminology section:~HTMLINFRA#html-elements
	:~HTMLINFRA#hardwareLimitations
~scriptingを~supportしない:~HTMLINFRA#non-scripted
要素~型:~HTMLINFRA#element-type

~meta要素から符号化法を抽出する:~HTMLurl#algorithm-for-extracting-a-character-encoding-from-a-meta-element
~Content-Type~metadata:~HTMLurl#content-type

環境に合致する:~HTMLcms#matches-the-environment

内部~資源~link群を処理する:~HTMLlinks#process-internal-resource-links

scE.すでに開始したか:~HEscripting#already-started
scE.非同期cを強制するか:~HEscripting#script-force-async
scE.構文解析器~文書:~HEscripting#parser-document
scE.構文解析器にて実行されるに準備済みか:~HEscripting#ready-to-be-parser-executed
~script要素を実行する:~HEscripting#execute-the-script-element
~script要素を準備する:~HEscripting#prepare-the-script-element
アリな限りすぐに実行される~scriptたちが成す集合:~HEscripting#set-of-scripts-that-will-execute-as-soon-as-possible
アリな限りすぐに順に実行される~scriptたちが成す~list:~HEscripting#list-of-scripts-that-will-execute-in-order-as-soon-as-possible
文書の構文解析を完遂したとき実行されることになる~scriptたちが成す~list:~HEscripting#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing
構文解析器を阻んでいる~script:~HEscripting#pending-parsing-blocking-script
~template内容:~HEscripting#template-contents
	:~HEscripting#restrictions-for-contents-of-script-elements

doc.容器~文書:~HTMLds#doc-container-document
閲覧~文脈:~HTMLds#browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc

同一-生成元:~ORIGIN#same-origin
非同一-生成元:~ORIGIN#same-origin

~navigateする:~HTMLnav#navigate
	i.履歴~取扱い:~HTMLnav#navigation-hh
hH.replace:~HTMLnav#navigationhistorybehavior-replace
doc.~pageを示しているか:~HTMLlifecycle#page-showing
読込ngを完全に終わらす:~HTMLlifecycle#completely-finish-loading

~page遷移~eventを発火する:~HTMLnavAPI#fire-a-page-transition-event

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document

~listされる要素:~HEforms#category-listed
~formに所有され得る要素:~HEforms#form-associated-element
~form所有者:~HTMLforms#form-owner
	所有させる:~HTMLforms#concept-form-association
fe.~check有りか:~HTMLforms#concept-fe-checked
fe.値:~HTMLforms#concept-fe-value
再設定する~algo:~HTMLforms#concept-form-reset-control
構文解析器が挿入したか:~HTMLforms#parser-inserted-flag
再設定-可能な要素:~HEforms#category-reset
	＠~HEforms#maybe-clone-an-option-into-selectedcontent

doc.~load計時~報:~HTMLdom#load-timing-info
doc.読込ng中における~WebDriver-BiDi用の~navi~ID:~HTMLdom#concept-document-navigation-id

文書の現在の準備度を更新する:~HTMLdom#update-the-current-document-readiness

~DOMContentLoaded~event開始~時刻:~HTMLdom#dom-content-loaded-event-start-time
~DOMContentLoaded~event終了~時刻:~HTMLdom#dom-content-loaded-event-end-time
~load~event開始~時刻:~HTMLdom#load-event-start-time
~load~event終了~時刻:~HTMLdom#load-event-end-time

~custom要素~構築子:~HEcustom#custom-element-constructor
~custom要素~反応~stack:~HEcustom#custom-element-reactions-stack
~custom化された組込みの要素:~HEcustom#customized-built-in-element
要素~queue:~HEcustom#element-queue
~custom要素~callback反応を~enqueueする:~HEcustom#enqueue-a-custom-element-callback-reaction
~custom要素~反応を呼出す:~HEcustom#invoke-custom-element-reactions
~custom要素~定義を検索する:~HEcustom#look-up-a-custom-element-definition
~formに所有され得る~custom要素:~HEcustom#form-associated-custom-element
~custom要素~registryを検索する:~HEcustom#look-up-a-custom-element-registry

~scriptを阻んでいる~stylesheetは在るか？:~HEmetadata#has-a-style-sheet-that-is-blocking-scripts
~CSP状態:~HEmetadata#attr-meta-http-equiv-content-security-policy


動的~markup挿入-時には投出する~counter:~HTMLdynamic#throw-on-dynamic-markup-insertion-counter
	:~HTMLdynamic#script-created-parser
	:~HTMLdynamic#dynamic-markup-insertion

doc.読込んだとき印刷するか:~HTMLGAPI#print-when-loaded
文書を印刷する手続き:~HTMLGAPI#printing-steps

~task:~WAPI#concept-task
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
大域~taskを~queueする:~WAPI#queue-a-global-task
~event~loop:~WAPI#event-loop
~event~loopを回す:~WAPI#spin-the-event-loop
小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
~scriptingは可能化されて:~WAPI#concept-n-script
関連な~agent:~WAPI#relevant-agent

	:https://www.w3.org/Bugs/Public/show_bug.cgi?id=27314

	●外部
実装定義:~INFRA#implementation-defined
~list:~INFRA#list
構造体:~INFRA#struct
sct.~item:~INFRA#struct-item

文字列:~INFRA#string
sub.大小無視:~INFRA#ascii-case-insensitive
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII英字:~INFRA#ascii-alpha
~ASCII英小文字:~INFRA#ascii-lower-alpha
~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII英大文字:~INFRA#ascii-upper-alpha
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII~hex数字（小文字）:~INFRA#ascii-lower-hex-digit
~ASCII~hex数字（大文字）:~INFRA#ascii-upper-hex-digit
~ASCII空白:~INFRA#ascii-whitespace
~cp:~INFRA#code-point
制御文字:~INFRA#control
非文字:~INFRA#noncharacter
~surrogate:~INFRA#surrogate
~ASCII小文字~化する:~INFRA#ascii-lowercase
~byte小文字~化する:~INFRA#byte-lowercase
改行文字を正規化する:~INFRA#normalize-newlines
同型に復号する:~INFRA#isomorphic-decode

~HTML名前空間:~INFRA#html-namespace
~MathML名前空間:~INFRA#mathml-namespace
~SVG名前空間:~INFRA#svg-namespace
~XLink名前空間:~INFRA#xlink-namespace
~XML名前空間:~INFRA#xml-namespace
~XMLNS名前空間:~INFRA#xmlns-namespace

~stack:~INFRA#stack
	~pop
	~push

	~byte大小無視$

~HTML~MIME型:~MIMESNIFF#html-mime-type
~URL:~URL1#concept-url

符号化法:~ENCODING#encoding
~labelから符号化法を取得する:~ENCODING#concept-encoding-get
~BOMを~sniffする:~ENCODING#bom-sniff
~Unicodeに復号する:~ENCODING#decode

~node:~DOM4#concept-node
	Node object → ~node
属性を付加する:~DOM4#concept-element-attributes-append
~nodeを付加する:~DOM4#concept-node-append

子~群:~DOM4#concept-tree-child
el.名前空間:~DOM4#concept-element-namespace
el.属性~list:~DOM4#concept-element-attribute
el.局所~名:~DOM4#concept-element-local-name
el.~shadow根:~DOM4#concept-element-shadow-root
~shadow~host:~DOM4#element-shadow-host
el.~custom要素~registry:~DOM4#element-custom-element-registry

~eventを発火する:~DOM4#concept-event-fire
~HTML文書:~DOM4#html-document
doc.符号化法:~DOM4#concept-document-encoding
doc.~mode:~DOM4#concept-document-mode
doc.種別:~DOM4#concept-document-type
doc.生成元:~DOM4#concept-document-origin
doc.~URL:~DOM4#concept-document-url
doc.宣言的な~shadow根を許容するか:~DOM4#document-allow-declarative-shadow-roots
要素を作成する:~DOM4#concept-create-element
elem.作成:~DOM4#concept-create-element
文書~要素:~DOM4#document-element
	制限付き過去互換~mode:~DOM4#concept-document-limited-quirks
	過去互換なし~mode:~DOM4#concept-document-no-quirks
	過去互換~mode:~DOM4#concept-document-quirks
	→ `limited-quirks^l/`no-quirks^l/`quirks^l
~node文書:~DOM4#concept-node-document
~tree:~DOM4#concept-tree
~tree順序:~DOM4#concept-tree-order

cd.~data:~DOM4#concept-cd-data
dT.名前:~DOM4#concept-doctype-name
dT.公な~ID:~DOM4#concept-doctype-publicid
dT.~system~ID:~DOM4#concept-doctype-systemid

sR.宣言的か:~DOM4#shadowroot-declarative
sR.要素の内部特能から可用か:~DOM4#shadowroot-available-to-element-internals
sR.~custom要素~registryを~NULLに保つか:~DOM4#shadowroot-keep-custom-element-registry-null
~shadow根を付する:~DOM4#concept-attach-a-shadow-root


現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
~navi計時を~queueする:~NAV-TIMING#dfn-queue-the-navigation-timing-entry

~client~message~queue:~SW1#dfn-client-message-queue
~sw~client:~SW1#serviceworkercontainer-service-worker-client

~JS実行~文脈~stack:~TC39#execution-context-stack
~SVG~script要素を処理する:https://www.w3.org/TR/SVGMobile12/script.html#ScriptContentProcessing
	~TR/xml/#sec-lang-tag

~WebDriver-BiDi~DOM内容が読込まれた:~WEBDRIVER-BIDI#webdriver-bidi-dom-content-loaded
~WebDriver-BiDi読込nを完了した:~WEBDRIVER-BIDI#webdriver-bidi-load-complete
新たな~WebDriver-BiDi~navi状態s:~HTMLdep#_new-webdriver-bidi-navigation-status
wBDst.処理待ち:~WEBDRIVER-BIDI#navigation-status-pending
wBDst.完了した:~WEBDRIVER-BIDI#navigation-status-complete

●●words_table


AnyElse:<i>Anything else</i>:<i>その他</i>
Content-Type:
MathML:
	REPLACEMENT-CHARACTER:REPLACEMENT-CHARACTER
SGML:
UTF-16:
XLink:
XMLNS:
	around:
bookmark:
alert::::
check::::チェック
	~check有りか:checkedness
contrast:
iframe-srcdoc:iframe srcdoc
in-line::::インライン
infoset:
pragma:
time:
	not-ok
	ok
	~~落とし込み:coercing
	~script用:scripting

	●構造
誤入子な:misnested::入れ子に誤りがある
誤入子に:misnest::誤って入れ子に
深さ:depth:~

	~byte列:sequence of bytes
	子たち:children
	称され:refer
	指す:refer

	●データ操作
clear:
shift::::シフト
増やし:incrementし:~
変換器:converter::~
付-:attach:~
	設定し直す:reset
	付加-:insert 〜 at the end of
	挿入-時:insertion
	挿入-先:place for inserting a node／insertion location
	改変されない:unmodified

	●処理
pipeline::::パイプライン
	call元:caller
checkpoint:
小task:microtask::小 task:小タスク
切替える:switchする::切り替える
切替えな:switchしな::切り替えな
切替えら:switchさ::切り替えら
切替えて:switchして::切り替えて
切替えた:switchした::切り替えた
	誤り:error:
	~error含み:erroneous
前処理-:preprocess:~
前処理器:preprocessor:~
処理命令:processing instruction::~
	処理し直す:reprocess
	阻むのをやめ:unblock
処理待ち:pending:~
静止-:pause::~
周回:pass:~
	2 周回:two-pass
復旧-:restore::~
指図-:instruct:~
停滞-:stall::~
observer:
遅い:slowな:~
	長時間:long time
検索-:look up::~
回す:spinする:~
	skip over
	終わらす:finish
load:
	~load後:post-load
投機的:speculative::~
模擬:mock::~
書込んだ:writeした::書き込んだ
保つ:keepする:~

	開始し直す:restart
	~cache用の:caching

	●文字
bang:
bracket:
surrogate::::サロゲート
ampersand::::アンパサンド
	~spaceでない:non-space
BOM:
	BOM:byte order mark
CR:
LF:
DOCTYPE:
cp:code point::符号位置
CDATAsec:CDATA section::CDATA 節::CDATA セクション
eof:end-of-file
hex:::16 進
decimal:::10 進法
hexadecimal:::16 進法
非文字:noncharacter::~
	文字~tokenでない:non-character tokens
	-:capital letters
制御文字:control::~
C1:
	数:number
数量-:numeric::~
	~ASCII空白／空白:space
英字:alpha::~
英数字:alphanumeric::~
英小文字:lower alpha::~
英大文字:upper alpha::~
引用符付き:quoted::~
引用符付きの:quotedな::~
引用符無し:unquoted::~
引用符無しの:unquotedな::~
一重引用符:single quote::~
二重引用符:double quote::~
二重:double::~
一重引用符付き:single-quoted::~
二重引用符付き:double-quoted::~

	●parser
sniff:
	sniffing
dash:
html:
p:
meta:
head:
noscript:
body:
table:
caption:
select:
template:
frameset:
frameset-ok:
CDATA:
DOCTYPE:
LTsign:less-than sign::小なり記号
PLAINTEXT:
RAWTEXT:
RCDATA:
little-endian:
big-endian:

一掃-:flush::~
戻先:return:戻り先
	後で戻る:return
	戻-:back

perror:parse error::構文解析 error:構文解析エラー:パースエラー
	構文解析し直-:re-parse
	予め構文解析-:preparse
	構文解析器にて実行され:parser-executed
準備度:readiness::~

養子縁組:adoption agency::~

前置き:preamble::~
設置され:placeされ:置かれ
発-:emit::~
	pop off:pop
	消費され尽くした:lack
	消費し直す:reconsume
	から開始-:starts with
現token:current token:現 token::現トークン
tokenizer:::token 化器:トークン化器:トークナイザ
	token化:tokenization
	token化:tokenize
close::::
closing::::
charset::::
open::::
publicID:public identifier::public 識別子
systemID:system identifier::system 識別子
public-keyword:public keyword:::public キーワード
system-keyword:system keyword:system キーワード
配送器:dispatcher::~
走査:scan::~
予走査:prescan::~
	予走査-:pre-scan
同型:isomorphic::~
承認-:acknowledge::~
自己閉じ:self-closing::~
閉じる:closeする::~
閉じら:closeさ::~
閉じな:closeしな::~
開かれ:openされ::~
	再び開かれ:reopening
void:
	~void要素:void element
条項:clause:~
普通の:ordinary::~
整形式:well-formed::~
段階:stage::~::ステージ
確定的:definite::~
確度:confidence::~
暫定的:tentative::~
確か:certain::~
無関連:irrelevant::関連しない
似非:bogus::~
構築器:builder::~

	と記される~~分岐:clause
	特定の~~分岐:specifically
	調整-済み:adjusted
	遡って:back して
	弾き出される:dropped on the floor
	尽きる:runs out of
	〜に流し込まれる:make their way into
	構築し直す:reconstruct
	〜に出くわした／出くわす:seen
	親を違える:foster parent
	符号化法:character encoding
	〜数として解釈した結果:numeric version
	-:in increasing numeric order
	ε:undefined
	探し出す:looking for
	位置:encodingPosition
	~XML宣言~終端:xmlDeclarationEnd
	最初に生じた:first occurrence
	~INCBY 1:advance 〜 at the next
	直後:past
	から:inclusive
	直前まで:exlusive

	%局所~名:localName
	%引用符:quoteMark
	%符号化法~終端~位置:encodingEndPosition
	%符号化法かも:potentialEncoding
	%属性~群:attributes
	%~URL:url
	%投機的な構文解析器:speculativeParser
	%投機的な文書:speculativeDoc
	%~tag名:tagName
	%意図された親:intended parent
	%意図された親:intendedParent
	%宣言的な~shadow根を許容するか:allowDeclarativeShadowRoots
	%要素~queue:-
	%要素~stackのみに追加するか:onlyAddToElementStack
	%~template開始~tag:templateStartTag
	%~template:template
	%~focusを委任するか:delegates focus
	%宣言的~shadowの~host要素:declarativeShadowHostElement
	%~mode:mode
	%~clone可能か:clonable
	%~scriptを実行するか:willExecuteScript
	%調整-済み挿入-先:adjustedInsertionLocation
	%調整-済み挿入-先:adjusted insertion location

	●環境／保安
locale::::ロケール
agent:

	●仕様
	Annex
	HTML2〜HTML4
	Windows, Chrome, Firefox
toolchain::::ツール鎖
事実:fact:~
傾向:tend:~
合法:legal:~
微妙な:subtle:~
機械:machine:~
都合よく:convenientに:~
複雑:complicated:~
誤記:typo:~
過度の:excessive:~
変則的:strange:~
地位:status:~
素直:straightforward:~
	straight-forward manner
比較的:relativeに:比較的
頻度解析:frequency analysis:~
重み:weight:~
類似性:resemblance:~
真似る:resembleする:~
真似て:resembleして:~
共通部分:intersection:~
捏造:fake:~
参考:informational:~
包括的:comprehensive:~
本番の:realな:~
本番:real:~
	-:real
再入的:reentrant:~
黙示-:imply:~
強いら:forceさ:~
強調-:highlight:~
自動検出-:autodetect:~
自動検出:autodetection:~
浪費-:waste:~
生産性:productivity:~
禁制-:prohibit:~
競合-:conflict:~
衝突-:clash:~
見かけ:look:~
誤解釈-:misinterpret:~
課-:impose:~
遭遇-:encounter:~
防ぐ:preventする:~
内来的:inherent:~
遺棄-:abandon:~
制定-:prescribe:~
策:strategy:~
opt-outする:opt outする:任意で外す
排他的:exclusive:~
上限:limit:~
的確:right:~

	実施~上の:practical
	に基づかないもの:non- 〜 basis
	可能性がある:it is possible that
	問わない:matter
	ひどく:dramatically
	~~必須:imperative
	一方で:whereas／however
	導く:lead to
	それでも:still
	そのため:by necessity
	そのため、because of
	すなわち:i.e.
	非常に〜易い:highly
	〜であっても:notwithstanding
	的に:fashion
	その場で:on-the-fly
	~~進行に伴い:course
	として／すなわち／:namely
	にもかかわらず:despite
	なることはない:by any means
	きちんと定義される:well-defined
	様な見かけ:looks like
	見込まれる:likely
	およそ〜と見込まれる:very likely
	明らかに:clear
	更に詳しく:elaborating
	ため:For the sake of
	-:we
	-:indeed
	何十年もの間:decades
	真の:true
	頻用:frequent
	表れ:sign
	込み入って:tricky
	非常に〜易い:highly
	頻用:frequent
	~~対処-:dealing with

	予期せず／予期されない:unexpected
	実用的でない:impractical
	再び呼出-:reinvoke
	併用:use 〜 in conjunction with
	の制御~下に戻す:yielding control back to
	書かれ:written
	~~問題になる:offending
	より重くなる:outweigh
	関心がある:interesting
	導く:taking
	そのままにされる:remains intact 
	次に挙げるいずれかに分類される:fall into the following categories
	仕分けられる:fall into
	と記された所では:talks about
	知らしめ:let us know
	挙げ／:listed
	~~保ち続けて:bear
	:Don’t ask
	said
	causing
	単純にする:simplicity
	〜する所では:says
	在るとき:presence

	●未分類
側:side:~
一時:temporary:~
外来:foreign::~
現在:currently:~
次回の:next:~
地点:point:~
最遠な:furthest:~
供与-:contribute:~
先行-:precede:~
近過去:recent:~
	最も近過去なもの:youngest
漏れる:leakする:~
現れる:appearする:~
覚える:rememberする:~
忘れた:forgetした:~
	forgotten
表示中:showing:~
近似:approximation:~
集析:mining::~::マイニング
成長-:grow:~
接触-:contact:~
吹飛ば:吹き飛ば
	吹き飛ばす:blow away

時系列順:chronological:~
DOMContentLoaded:
高分解能:high resolution::~

帯域外の:out-of-band:~
種類:kind:~
	下位節:subsection
記号:symbol:~
重複:duplicate:~
WebDriver-BiDi:
投入-:feed:~
内部特能:internals::~

	重くなる:outweigh
	通過-:passed through
	所属する:finds itself
	-:rewind
	見える／見つかる:seen
	来ている:coming
	成す:comprise
	転換される:turned into
	〜が生じたときは常に any occurrences of
	~MUL:multiply 〜
	され続け／し続け:continue to
	のない:missing
	を閉じる:closing
	入る:enter する
	去る:gone
	始-:begin
	始め／:beginning
	属性を有さない:unadorned
	散らばって:spread across
	来る:come
	〜に由来する:comes from
	棄て:throw away
	示す:say
	結果になる／:end-up
	記す／示す／:say
	設け／箇所／置く:place
	流す:place into
	誤って置かれた:misplaced
	次の様になる:looks as follows
	-:take
	かかって:taken
	~~現れる:stand
	置く:put
	push:put

	:doing
	去る／:leave
	何もしない:do nothing
	GOTO: jump to the step below labeled
	GOTO:jump to the
	GOTO:jump to the step labeled
	GOTO:jump back to the step labeled
	GOTO:return to
	GOTO:return to the step labeled
	GOTO:return to the step above labeled
	RET:stop this algorithm
	:came
	:didn’t
	:get ／got 〜
	:goes
	:having
	-:subject
	経つ:-
	が宣言的でない~shadow根である場合:non-declarative-shadow-root

	以外も混じっている:not all
	箇所:parts
	箇所がいくつかある:some parts
	他所:new location
	箇所:point
	指す:point to

	何個かの:several
	もたらし:result in
	最後の:final
	後続-:follow
	後続して:subsequently
	直:immediate
	直前:right before
	末尾:inside, after its last child (if any)
	直前:immediately before
	の手前まで:but not including,
	以前の／前の／前:previous
	前述した:aforementioned
	頭部:leading
	尾部:trailing
	-:downward
	先頭（ stack ）:first
	先頭:the top
	先頭:topmost
	末尾:the bottom
	末尾:bottommost
	直前:just before
	直後:immediately after
	直前:immediately before
	直後:just after
	直後:immediately followed-by
	より後に在る（~stack内で）:lower
	直前に在る（~stack内で）:immediately above

	どう〜であれ:however
	ものは、何であれ:everything
	誰もが:everyone
	方:whichever
	いずれか早い方:whichever came first
	ことがある:ever
	以降の各:at any later
	何ら:any
	他にも:other than
	ある／いくつか:some
	様々な:varying
	変わる:varies
	その他の:any other
	もう一つ:yet-another
	どこかへ／〜周りの:around
	の一つ:is in the list of
	単に／のみならず:just
	多量の:a lot of
	ずっと少ない:far fewer
	その後，／次に:then
	さらに:more

	超え:beyond／greater than
	残りの部分:the rest
	もあるが:amongst
	とともに:along with
	全体を通して:throughout
	全体:whole
	まるごと:altogether
	対応している:corresponding
	所:where
	最も近い:nearest
	様々な:various
	そのままに:as-is
	またがって:across
	〜下:under
	〜が指す:pointed to by
	まで:up to and including
	広い:wide
	広く:widely
	:most
	連続する:consecutive
	最もよく:most often
	旧:old
	外へ:out of
	〜似の:〜-like
	~HTML-like
	後の:later
	今度は:this time
	し過ぎた:too long
	どの時点であれ、:at any time
	EQ:longer than the empty string
	それまでに:so far
	この時点:at this point
	この時点で、now
	最終的に:finally
	最終結果:end result
	同時に:together
	ここでも:again
	早期の／:earlier
	〜内で最初のもの:earliest
	当面の間:in the meantime
	時系列順:least recently〜
	新:
	現:
	それ以上
	一方で:while
	組
	先立って:-
	中途で:abrupt に
	たいしてない:have much
	近い:close
	対に:pair
	分類-／-:categories
	-:category
	経る:through
	からなる:consisting
	〜で:manner
	ない／しない:nothing
	neither 〜 nor
	-:now
	-:thoroughly
	各組:per family
	だけ／neither
	一連の:〜s
	一連の:series of
	列／並び:sequence
	:followed by
	~WHILE:repeatedly
	今度は:this time


●●html_code_list


■parsing-model-1
...
<％script>
％
document.write('<p>');
<％/script>
...

■invalid-first-character-of-tag-name
<42></42>

■non-void-html-element-start-tag-with-trailing-solidus
<div/><span></span><span></span>

■unexpected-character-in-attribute-name-1
<div foo<div>

■unexpected-character-in-attribute-name-2
<div id'bar'>

■unexpected-character-in-unquoted-attribute-value
<div foo=b'ar'>

■unexpected-equals-sign-before-attribute-name
<div foo="bar" ="baz">

■unexpected-question-mark-instead-of-tag-name
<?xml-stylesheet type="text/css" href="style.css"?>

■text-node-1
A<％script>
var %script = document.getElementsByTagName('script')[0];
document.body.removeChild(%script);
<％/script>B

■text-node-2
A<％script>
var %text = document.createTextNode('B');
document.body.appendChild(%text);
<％/script>C

■text-node-3
A<％script>
var %text = document.getElementsByTagName('script')[0].firstChild;
%text.data = 'B';
document.body.appendChild(%text);
<％/script>C

■text-node-4
A<table>B<tr>C</tr>D</table>

■text-node-5
A<table><tr> B</tr> C</table>

■text-node-6
A<table><tr> B</tr> </em>C</table>

■misnested-tags-1
<p>1<b>2<i>3</b>4</i>5</p>

■misnested-tags-2
<b>1<p>2</b>3</p>

■unexpected-markup-in-tables
<table>＜<b>＞<tr><td>aaa</td></tr>＜bbb＞</table>ccc

■scripts-that-modify-the-page
<div id=a>
 <％script>
  var %div = document.getElementById('a');
  parent.document.body.appendChild(%div);
 <％/script>
 <％script>
  alert(document.URL);
 <％/script>
</div>
％
<％script>
 alert(document.URL);
<％/script>

■unclosed-formatting-elements
<!DOCTYPE html>
<p><b class=x><b class=x><b><b class=x><b class=x><b>X
<p>X
<p><b><b class=x><b>X
<p></b></b></b></b></b></b>X

●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
§ The HTML syntax
内の
<a href="~SPEC_URL">§ Parsing HTML documents, § Parsing HTML fragments</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — HTML 文書／素片の構文解析法</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

	<section id="syntax">
<h2 title="The HTML syntax">13. ~HTMLの構文</h2>

<p class="note">注記：
この節は、`~HTML~MIME型$とされた資源に対する規則のみを述べる。
~XML資源に対する規則は、
`§ ~XML構文＠~HTMLxml#the-xhtml-syntax$にて論じられる。
◎
This section only describes the rules for resources labeled with an HTML MIME type. Rules for XML resources are discussed in the section below entitled "The XML syntax".
</p>

		<section id="_conventions">
<h3>【この訳に特有な表記規約】</h3>

◎表記記号

<p>
用語
`文書@
は `Document$I ~objの略記として用いられるが、
構文解析の文脈においては、
他が指定されない限り，当の`~HTML構文解析器$に結付けられたそれを指す
（この~pageに現れるほとんどのそれが該当する）。
~algoの中で宣言されずに現れる %構文解析器 は、
この［
`~HTML構文解析器$の~instance
］を指す
（ただし、［
`作動中な投機的な~HTML構文解析器$ ~NEQ ~NULL
］の間は，それを指す場合もある）。
</p>

<p>
“%s ~APPEND %a ~APPEND %b ~APPEND …”
という表記は、
文字列 %s の末尾に後続の［
文字／文字列
］ %a, %b, …
を示された順に付加する演算を表す。
</p>

		</section>
		<section id="writing">
<h3 title="Writing HTML documents">13.1.  ~HTML文書の書き方</h3>

<p class="trans-note">【
この節の内容は、
`別~page＠~HTMLwriting#writing$にて。
】</p>

		</section>
		<section id="parsing">
<h3 title="Parsing HTML documents">13.2. ~HTML文書の構文解析-法</h3>

<p><i>
この節が適用されるのは、［
~UA, ~data集析~tool, 適合性~検査器
］に限られる。
</i>
◎
This section only applies to user agents, data mining tools, and conformance checkers.
</p>

<p class="note">注記：
~XML文書を構文解析して~DOM~treeにするための規則は、
次~節の`~XML構文$が受持つ。
◎
The rules for parsing XML documents into DOM trees are covered by the next section, entitled "The XML syntax".
</p>

<p>
~UAは、
`text/html$mt 資源から~DOM~treeを生成するときは，
この節に述べる構文解析~規則を利用するモノトスル。
これらの規則は、
~~同時に
`~HTML構文解析器@
と称されるものも定義する。
◎
User agents must use the parsing rules described in this section to generate the DOM trees from text/html resources. Together, these rules define what is referred to as the HTML parser.
</p>

<div class="note">
<p>注記：
この仕様に述べる~HTML構文は、
~SGMLや~XMLに近い類似性を~~保ち続けてはいるが，
自前の構文解析~規則を備える別々な言語である。
◎
While the HTML syntax described in this specification bears a close resemblance to SGML and XML, it is a separate language with its own parsing rules.
</p>

<p>
~HTMLの早期の~versionのうち一部（特に HTML2 〜 HTML4）は、
~SGMLに基づいていたため，~SGML構文解析~規則を利用していた。
しかしながら、
~HTML文書に対し真の~SGML構文解析を実装したことがある~web~browserは，
（あっても）少数に限られる。
歴史的に、
~HTMLを厳密に~SGML応用として取扱っていた~UAは，検証器に限られる。
その結果，［
検証器が文書が有するべきであるものと主張していた表現
］と［
広く配備された~web~browserが相互運用可能に実装していた表現
］が異なっていたことによる混同は、
何十年もの間，生産性を浪費していた。
したがって、
この~versionの~HTMLは，
~SGMLに基づかないものへ返る。
◎
Some earlier versions of HTML (in particular from HTML2 to HTML4) were based on SGML and used SGML parsing rules. However, few (if any) web browsers ever implemented true SGML parsing for HTML documents; the only user agents to strictly handle HTML as an SGML application have historically been validators. The resulting confusion — with validators claiming documents to have one representation while widely deployed web browsers interoperably implemented a different representation — has wasted decades of productivity. This version of HTML thus returns to a non-SGML basis.
</p>
</div>

<p>
適合性~検査器の目的においては、
`~HTML構文$であると決定された資源は，
`~HTML文書$とされる。
◎
For the purposes of conformance checkers, if a resource is determined to be in the HTML syntax, then it is an HTML document.
</p>

<p class="note" id="_notes-on-element-type">注記：
`§ ~XMLとの互換性＠~HTMLINFRA#xml$にて言明したとおり、
名前空間を明示的に指定していない`要素~型$への参照は，
常に`~HTML名前空間$に属する要素を指す。
例えば，仕様にて “`menu$e 要素” と記された所では、
その要素の［
局所~名は `menu^l,
名前空間は `http://www.w3.org/1999/xhtml^l,
~interfaceは `HTMLMenuElement$I
］になる。
アリな所では、
そのような要素への参照には，その定義への~hyperlinkが付与される。
◎
As stated in the terminology section, references to element types that do not explicitly specify a namespace always refer to elements in the HTML namespace. For example, if the spec talks about "a menu element", then that is an element with the local name "menu", the namespace "http://www.w3.org/1999/xhtml", and the interface HTMLMenuElement. Where possible, references to such elements are hyperlinked to their definition.
</p>

			<section id="overview-of-the-parsing-model">
<h3 title="Overview of the parsing model">13.2.1. 構文解析~modelの概観</h3>

<figure style="float:right;">
<!-- parsing-model-overview.svg -->
<div id="_dgm-model">
<div class="_dgm-model-node" style="top:0px;">~network</div>
<div class="_dgm-model-node" style="top:70px;">~byte~stream~復号器</div>
<div class="_dgm-model-node" style="top:140px;">入力~stream前処理器</div>
<div class="_dgm-model-node" style="top:210px;">~tokenizer</div>
<div class="_dgm-model-node" style="top:280px;">~tree構築</div>
<div class="_dgm-model-node" style="top:280px; left: 300px; width: 160px;">~script実行</div>
<code style="position:absolute; top:135px; left:280px; width: 160px;">document.write()</code>
<div class="_dgm-model-node" style="top:350px;">~DOM</div>
</div>
</figure>

<div style="display:inline-block; min-width:15em;"></div>

<p>
~HTML構文解析~処理-の入力は，一連の`~cp$からなる~streamであり、
`~token化~段階$, `~tree構築~段階$を順に通過し，
その出力は`文書$になる。
◎
The input to the HTML parsing process consists of a stream of code points, which is passed through a tokenization stage followed by a tree construction stage. The output is a Document object.
</p>

<p class="note">注記：
実装は，`~scriptingを~supportしない$ならば`文書$を実際に作成する必要はないが、
そのような事例であっても，
~DOM~treeは，この仕様の残りの部分のための~modelとして利用される。
◎
Implementations that do not support scripting do not have to actually create a DOM Document object, but the DOM tree in such cases is still used as the model for the rest of the specification.
</p>

<p>
~token化~段階で取扱われる~dataは、
共通的な事例では~networkから来るが，
~UA内で走っている`~scriptから＠~HTMLdynamic#dynamic-markup-insertion$
— 例えば `document.write()$c ~APIを利用して —
来ることもある。
◎
In the common case, the data handled by the tokenization stage comes from the network, but it can also come from script running in the user agent, e.g. using the document.write() API.
</p>

<p id="nestedParsing">
［
~tokenizer段階, ~tree構築~段階
］どちらも，［
とり得る状態たちが成す集合
］は 1 つだけであるが、
~tree構築~段階は再入的である
— すなわち、
~tree構築~段階が ある~tokenを取扱っている間に［
~tokenizerが再開され，
その~tokenの処理が完了する前に別の~tokenを更に発して処理させる
］こともある。
◎
There is only one set of states for the tokenizer stage and the tree construction stage, but the tree construction stage is reentrant, meaning that while the tree construction stage is handling one token, the tokenizer might be resumed, causing further tokens to be emitted and processed before the first token's processing is complete.
</p>

<div class="example">
<p>
次の例では、
`script^l 終了~tag~tokenを取扱っている間に［
`p^l 開始~tag~tokenを取扱うため，~tree構築~段階が~callされる
］ことになる：
◎
In the following example, the tree construction stage will be called upon to handle a "p" start tag token while handling the "script" end tag token:
</p>

`parsing-model-1^xCode
</div>

<div class="p">
<p>
これらの事例を取扱うため、
各 構文解析器は，次に挙げるものを有する：
</p>

<dl class="def-list">
	<dt>`~script入子ng~level@</dt>
	<dd>
初期~時は 0 に設定するモノトスル。
</dd>

	<dt>`静止するか@</dt>
	<dd>
真偽値
— 初期~時は ~F に設定するモノトスル。
</dd>
</dl>

◎
To handle these cases, parsers have a script nesting level, which must be initially set to zero, and a parser pause flag, which must be initially set to false.
</div>

			</section>
			<section id="parse-errors">
<h4 title="Parse errors">13.2.2. ~perror</h4>

<p>
この仕様は、
~HTML文書に対し，［
その構文解析~規則,
それが構文上は正しいか否か
］を定義する。
構文解析~algoには、
`~perror$と記される箇所がある。
~perrorによる~errorの取扱いは，きちんと定義されるが
（処理~規則は，この仕様~全体を通して述べる）、
~UAは，［
~HTML文書を構文解析している間に遭遇した`~perror$のうち，
この仕様に述べる規則を適用したいと望まない最初の所
］で構文解析器を`中止-$してもヨイ。
◎
This specification defines the parsing rules for HTML documents, whether they are syntactically correct or not. Certain points in the parsing algorithm are said to be parse errors. The error handling for parse errors is well-defined (that's the processing rules described throughout this specification), but user agents, while parsing an HTML document, may abort the parser at the first parse error that they encounter for which they do not wish to apply the rules described in this specification.
</p>

<div class="p">
<p>
適合性~検査器は、
文書~内に~perrorを生じさせる条件が：
</p>
<ul>
	<li>
存在しない場合、
~perrorを利用者に報告しないモノトスル。
</li>
	<li>
存在する場合、
それらのうち 1 個~以上は利用者に報告するモノトスル。
</li>
	<li>
複数個~存在する場合、
それらのうち 2 個~以上を利用者に報告してもヨイ。
</li>
</ul>
◎
Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document.
</div>

<p class="note">注記：
~perrorは、
~HTML`構文^emに限られる~errorである。
適合性~検査器は、
~perrorを検査することに加え，［
文書は，この仕様に述べる他のすべての適合性~要件を順守するかどうか
］も検証yすることになる。
◎
Parse errors are only errors with the syntax of HTML. In addition to checking for parse errors, conformance checkers will also verify that the document obeys all the other conformance requirements described in this specification.
</p>

<p>
一部の~perrorには、
以下に要旨される専用の~codeがある
— 適合性~検査器は、
報告-内にそれらを利用するべきである。
◎
Some parse errors have dedicated codes outlined in the table below that should be used by conformance checkers in reports.
</p>

<p class="trans-note">【
~error~code %~code を伴う`~perror$は、
この訳においては，
“~perror( %~code )”
のように記される。
】</p>

<div class="p">
<p>
`以下の~listにおける~errorの記述は、規範的でない^em
— 各~error~codeに対し：
</p>
<ul>
	<li>
“誘因” が付与された項目は、
構文解析器がどこで何に遭遇したとき，当の~errorが生じるかを述べる。
</li>
	<li>
“例” （または “例えば…” ）が付与された項目は、
当の~errorを生じさせる~code例を示す。
</li>
	<li>
“処置” が付与された項目は、
遭遇した~errorを構文解析器がどう取扱うかを述べる。
</li>
</ul>

<p class="trans-note">【
この~error~listは，原文では~table~markupで与えられているが、
この訳では，~listによる~markupで
— これらの項目名を伴わせて —
与えることにする。
】</p>

◎
Error descriptions in the table below are non-normative.
◎
Code | Description
</div>

<dl>

	<dt>`abrupt-closing-of-empty-comment@pE</dt>
	<dd>誘因：
中途で `003E^U で閉じられた空な`~comment$に遭遇した。
◎
This error occurs if the parser encounters an empty comment that is abruptly closed by a U+003E (&gt;) code point＼
</dd>
	<dd>例：
`&lt;!--&gt;^c ／ `&lt;!---&gt;^c
（これら以外にない）
◎
(i.e., &lt;!--&gt; or &lt;!---&gt;).＼
</dd>
	<dd>処置：
当の~commentは正しく閉じられたかのように挙動する。
◎
The parser behaves as if the comment is closed correctly.
</dd>

	<dt>`abrupt-doctype-public-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$の~publicID内で `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point in the DOCTYPE public identifier＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC "foo&gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC "foo&gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`abrupt-doctype-system-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$の~systemID内で `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point in the DOCTYPE system identifier＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "foo&gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "foo&gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`absence-of-digits-in-numeric-character-reference@pE</dt>
	<dd>誘因：
数字を包含しない，数量-`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that doesn't contain any digits＼
</dd>
	<dd>例：
`&amp;#qux;^c
◎
(e.g., &amp;#qux;).＼
</dd>
	<dd>処置：
そのような文字~参照は、
解決しない。
◎
In this case the parser doesn't resolve the character reference.
</dd>

	<dt>`cdata-in-html-content@pE</dt>
	<dd>誘因：
外来~内容（~SVG／~MathML）の外側で，`~CDATAsec$に遭遇した。
◎
This error occurs if the parser encounters a CDATA section outside of foreign content (SVG or MathML).＼
</dd>
	<dd>処置：
そのような~CDATAsecは、
~commentとして扱う（頭部の `[CDATA[^l と尾部の `]]^l も含めて）。
◎
The parser treats such CDATA sections (including leading "[CDATA[" and trailing "]]" strings) as comments.
</dd>

	<dt>`character-reference-outside-unicode-range@pE</dt>
	<dd>誘因：
妥当な~Unicode範囲を超える`~cp$を参照する，数量-`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a code point that is greater than the valid Unicode range.＼
</dd>
	<dd>処置：
そのような文字~参照は、
`FFFD^U に解決する。
◎
The parser resolves such a character reference to a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`control-character-in-input-stream@pE</dt>
	<dd>誘因：
`入力~stream$は、
次の`~cp$を包含している
⇒
［
`~ASCII空白$／ `0000^U
］以外の`制御文字$
◎
This error occurs if the input stream contains a control code point that is not ASCII whitespace or U+0000 NULL.＼
</dd>
	<dd>処置：
そのような`~cp$は，そのままに構文解析され、
通例的には
— すなわち、構文解析~規則が追加的な制約を適用しない所では —
~DOMに流し込まれる。
◎
Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.
</dd>

	<dt>`control-character-reference@pE</dt>
	<dd>誘因：
次の`~cp$を参照する，数量-`文字~参照$に遭遇した
⇒
［
`~ASCII空白$ ／ `000D^U
］以外の`制御文字$
◎
This error occurs if the parser encounters a numeric character reference that references a control code point that is not ASCII whitespace or is a U+000D CARRIAGE RETURN.＼
</dd>
	<dd>処置：
そのような文字~参照は、
そのままに解決する
— `数量-文字~参照~終端$stに則って置換される~C1制御文字~参照を除いて。
◎
The parser resolves such character references as-is except C1 control references that are replaced according to the numeric character reference end state.
</dd>

	<dt>`duplicate-attribute@pE</dt>
	<dd>誘因：
同じ~tag内にすでに在る属性と同じ名前の`属性$に遭遇した。
◎
This error occurs if the parser encounters an attribute in a tag that already has an attribute with the same name.＼
</dd>
	<dd>処置：
そのような重複した属性は、
無視する。
◎
The parser ignores all such duplicate occurrences of the attribute.
</dd>

	<dt>`end-tag-with-attributes@pE</dt>
	<dd>誘因：
`属性$を伴う`終了~tag$に遭遇した。
◎
This error occurs if the parser encounters an end tag with attributes.＼
</dd>
	<dd>処置：
終了~tag内の属性は、
無視される
— ~DOMに流し込まれることはない。
◎
Attributes in end tags are ignored and do not make their way into the DOM.
</dd>

	<dt>`end-tag-with-trailing-solidus@pE</dt>
	<dd>誘因：
`終了~tag$を閉じる `003E^U が期待される所で，
`002F^U に遭遇した。
◎
This error occurs if the parser encounters an end tag that has a U+002F (/) code point right before the closing U+003E (&gt;) code point＼
</dd>
	<dd>例：
`&lt;/div/&gt;^c 
◎
(e.g., &lt;/div/&gt;).＼
</dd>
	<dd>処置：
そのような~tagは、
定例の終了~tagとして扱う。
◎
Such a tag is treated as a regular end tag.
</dd>

	<dt>`eof-before-tag-name@pE</dt>
	<dd>誘因：
~tag名が期待される所で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream where a tag name is expected.＼
</dd>
	<dd>処置：
~tagの始まり（すなわち，
`開始~tag$に対しては `&lt;^l ／
`終了~tag$に対しては `&lt;/^l
）を~text内容として扱う。
◎
In this case the parser treats the beginning of a start tag (i.e., &lt;) or an end tag (i.e., &lt;/) as text content.
</dd>

	<dt>`eof-in-cdata@pE</dt>
	<dd>誘因：
`~CDATAsec$内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a CDATA section.＼
</dd>
	<dd>処置：
そのような~CDATAsecは、
入力~streamの終端の直前で閉じられたかのように扱う。
◎
The parser treats such CDATA sections as if they are closed immediately before the end of the input stream.
</dd>

	<dt>`eof-in-comment@pE</dt>
	<dd>誘因：
`~comment$内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a comment.＼
</dd>
	<dd>処置：
そのような~commentは、
入力~streamの終端の直前で閉じられたかのように扱う。
◎
The parser treats such comments as if they are closed immediately before the end of the input stream.
</dd>

	<dt>`eof-in-doctype@pE</dt>
	<dd>誘因：
`~DOCTYPE$内で，入力~streamの終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a DOCTYPE.＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`eof-in-script-html-comment-like-text@pE</dt>
	<dd>誘因：
`script$e 要素~内容の内側の`~comment$を真似る~text内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in text that resembles an HTML comment inside script element content＼
</dd>
	<dd>例：
`&lt;script&gt;&lt;!-- foo^c
◎
(e.g., &lt;script&gt;&lt;!-- foo).
</dd>
	<dd>処置：
【次の注記。】
</dd>
	<dd class="note">注記：
`script$e 要素~内の~HTML~commentを真似る構文-構造は、
~text内容として構文解析される。
それらは［
~script用~言語に特有な構文-構造の一部を成す／
~HTML似の~commentとして扱われる
］こともある
— ~script用~言語がそれらを~supportするならば
（例：~HTML似の~comment用の構文解析~規則は、
~JS仕様の Annex B にて見出せる）。
この~errorを生じさせる共通的な理由は、
`script^e 要素の`内容に課される制約＠~HEscripting#restrictions-for-contents-of-script-elements$に対する違反である。
`JAVASCRIPT$r
◎
Syntactic structures that resemble HTML comments in script elements are parsed as text content. They can be a part of a scripting language-specific syntactic structure or be treated as an HTML-like comment, if the scripting language supports them (e.g., parsing rules for HTML-like comments can be found in Annex B of the JavaScript specification). The common reason for this error is a violation of the restrictions for contents of script elements. [JAVASCRIPT]
</dd>

	<dt>`eof-in-tag@pE</dt>
	<dd>誘因：
［
`開始~tag$／`終了~tag$
］内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a start tag or an end tag＼
</dd>
	<dd>例：
`&lt;div id=^c 
◎
(e.g., &lt;div id=).＼
</dd>
	<dd>処置：
そのような~tagは、
無視する。
◎
Such a tag is ignored.
</dd>

	<dt>`incorrectly-closed-comment@pE</dt>
	<dd>誘因：
`--!&gt;^l `~cp$列により閉じられた`~comment$に遭遇した。
◎
This error occurs if the parser encounters a comment that is closed by the "--!&gt;" code point sequence.＼
</dd>
	<dd>処置：
そのような~commentは、
`--&gt;^l ~cp列により正しく閉じられたかのように扱う。
◎
The parser treats such comments as if they are correctly closed by the "--&gt;" code point sequence.
</dd>

	<dt>`incorrectly-opened-comment@pE</dt>
	<dd>誘因：
次のいずれも満たさない`~cp$列 `&lt;!^l に遭遇した：
<ul ><li>直後に 2 個の `002D^U が続く
</li><li>`~DOCTYPE$を開始させる
</li><li>`~CDATAsec$を開始させる
</li></ul>

◎
This error occurs if the parser encounters the "&lt;!" code point sequence that is not immediately followed by two U+002D (-) code points and that is not the start of a DOCTYPE or a CDATA section.＼
</dd>
	<dd>処置：
そのような~cp列に後続する最初の `003E^U （無ければ `入力~stream$の終端）までのすべての内容を，~commentとして扱う。
◎
All content that follows the "&lt;!" code point sequence up to a U+003E (&gt;) code point (if present) or to the end of the input stream is treated as a comment.
</dd>
	<dd class="note">注記：
例えば，~HTML内で~XML~markup宣言（例：
`&lt;!ELEMENT br EMPTY&gt;^c
）を利用した場合、
この~errorが生じる。
◎
One possible cause of this error is using an XML markup declaration (e.g., &lt;!ELEMENT br EMPTY&gt;) in HTML.
</dd>

	<dt>`invalid-character-sequence-after-doctype-name@pE</dt>
	<dd>誘因：
`~DOCTYPE$ の名前の後にて，［
`PUBLIC^l ／ `SYSTEM^l
］~keyword以外の`~cp$列に遭遇した。
◎
This error occurs if the parser encounters any code point sequence other than "PUBLIC" and "SYSTEM" keywords after a DOCTYPE name.＼
</dd>
	<dd>処置：
後続する［
~publicID／~systemID
］は無視した上で、［
~DOCTYPEが文書の前置きとして正しく設置されている
］かつ［
`構文解析器は~modeを変更できないか$ ~EQ ~F
］ならば，［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, the parser ignores any following public or system identifiers, and if the DOCTYPE is correctly placed as a document preamble, and if the parser cannot change the mode flag is false, sets the Document to quirks mode.
</dd>

	<dt>`invalid-first-character-of-tag-name@pE</dt>
	<dd>誘因：
［
`開始~tag$／`終了~tag$
］の名前を成す最初の~cpが期待される所で，`~ASCII英字$でない`~cp$に遭遇した。
◎
This error occurs if the parser encounters a code point that is not an ASCII alpha where first code point of a start tag name or an end tag name is expected.＼
</dd>
	<dd>処置：
開始~tagに対しては、
名前に先行する `003C^U を~text内容として扱って，
後続する内容は~markupとして扱う。
終了~tagに対しては、
そのような~cpから［
それに後続する最初の `003E^U （無ければ `入力~stream$の終端）
］までのすべての内容を，~commentとして扱う。
◎
If a start tag was expected such code point and a preceding U+003C (&lt;) is treated as text content, and all content that follows is treated as markup. Whereas, if an end tag was expected, such code point and all content that follows up to a U+003E (&gt;) code point (if present) or to the end of the input stream is treated as a comment.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

`invalid-first-character-of-tag-name^xCode

<p>
これは、
次のように構文解析されることになる：
◎
This will be parsed into:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
		</li><li>`body$e
			<ul><li class="t3">`#text$: <span>&lt;42&gt;</span>
			</li><li>`#comment$: <span>42</span>
			</li></ul>
		</li></ul>
	</li></ul>
</dd>

	<dd class="note">注記：
~tag名を成す最初の~cpは，`~ASCII英字$に制限される一方、
後続な~cpには（`~ASCII数字$を含め）広~範囲の~cpが許容される。
◎
While the first code point of a tag name is limited to an ASCII alpha, a wide range of code points (including ASCII digits) is allowed in subsequent positions.
</dd>

	<dt>`missing-attribute-value@pE</dt>
	<dd>誘因：
`属性$値が期待される所で，`003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where an attribute value is expected＼
</dd>
	<dd>例：
`&lt;div id=&gt;^c 
◎
(e.g., &lt;div id=&gt;).
</dd>
	<dd>処置：
そのような属性の値は、
空であるものと扱う。
◎
The parser treats the attribute as having an empty value.
</dd>

	<dt>`missing-doctype-name@pE</dt>
	<dd>誘因：
名前のない`~DOCTYPE$に遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE that is missing a name＼
</dd>
	<dd>例：
`&lt;!DOCTYPE&gt;^c 
◎
(e.g., &lt;!DOCTYPE&gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`missing-doctype-public-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$ ~publicIDの開始が期待される所で， `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where start of the DOCTYPE public identifier is expected＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC &gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC &gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`missing-doctype-system-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$ ~systemIDの開始が期待される所で， `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where start of the DOCTYPE system identifier is expected＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html SYSTEM &gt;^c
◎
(e.g., &lt;!DOCTYPE html SYSTEM &gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`missing-end-tag-name@pE</dt>
	<dd>誘因：
`終了~tag$の名前が期待される所で， `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where an end tag name is expected,＼
</dd>
	<dd>例：
`&lt;/&gt;^c （これ以外にない）
◎
i.e., &lt;/&gt;.＼
</dd>
	<dd>処置：
~cp列 `&lt;/&gt;^l 全体を無視する。
◎
The parser ignores the whole "&lt;/&gt;" code point sequence.
</dd>

	<dt>`missing-quote-before-doctype-public-identifier@pE</dt>
	<dd>誘因：
引用符が先行していない
`~DOCTYPE$ ~publicIDに遭遇した。
◎
This error occurs if the parser encounters the DOCTYPE public identifier that is not preceded by a quote＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01//EN"&gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01//EN"&gt;).＼
</dd>
	<dd>処置：
そのような~publicIDは無視した上で、
~DOCTYPEが文書の前置きとして正しく設置されているならば，［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, the parser ignores the public identifier, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.
</dd>

	<dt>`missing-quote-before-doctype-system-identifier@pE</dt>
	<dd>誘因：
引用符が先行していない `~DOCTYPE$ ~systemIDに遭遇した。
◎
This error occurs if the parser encounters the DOCTYPE system identifier that is not preceded by a quote＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html SYSTEM http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;^c
◎
(e.g., &lt;!DOCTYPE html SYSTEM http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;).＼
</dd>
	<dd>処置：
そのような~systemIDは無視した上で、
~DOCTYPEが文書の前置きとして正しく設置されているならば，［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, the parser ignores the system identifier, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.
</dd>

	<dt>`missing-semicolon-after-character-reference@pE</dt>
	<dd>誘因：
`003B^U で終了されない`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a character reference that is not terminated by a U+003B (;) code point.＼
</dd>
	<dd>処置：
当の文字~参照は `003B^U で終了されていた場合と同じに挙動する。
◎
The parser behaves the same as if the character reference is terminated by the U+003B (;) code point.
</dd>
	<dd class="note">注記：
ほとんどの`有名~文字~参照$は、
`~cp$ `003B^U で終了していることを要求する。
そうでないものは、
ある種の多義的な局面において，
より長く命名された`文字~参照$として解決されなくなるかもしれない。
◎
Most named character references require a terminating U+003B (;) code point. Those that don't might get resolved as a longer named character reference in certain ambiguous scenarios.
</dd>
	<dd class="example">
例えば `&amp;notin^c は，
`¬in^l に
— すなわち， `&amp;not;in^c であった場合と同じに —
構文解析されることになる一方で、
`&amp;notin;^c は，
`∉^l に構文解析されることになる。
◎
For example, &amp;notin will be parsed as "¬in", i.e., the same as if the input were &amp;not;in, whereas &amp;notin; will be parsed as "∉".
</dd>

	<dt>`missing-whitespace-after-doctype-public-keyword@pE</dt>
	<dd>誘因：
`~DOCTYPE$における `PUBLIC^l ~keywordの後に，`~ASCII空白$で分離されていない~publicIDに遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose "PUBLIC" keyword and public identifier are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-after-doctype-system-keyword@pE</dt>
	<dd>誘因：
`~DOCTYPE$における `SYSTEM^l ~keywordの後に，`~ASCII空白$で分離されていない~systemIDに遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose "SYSTEM" keyword and system identifier are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-before-doctype-name@pE</dt>
	<dd>誘因：
`~DOCTYPE$における `DOCTYPE^l ~keywordの後に，`~ASCII空白$で分離されていない名前に遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose "DOCTYPE" keyword and name are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-between-attributes@pE</dt>
	<dd>誘因：
`~ASCII空白$で分離されてない`属性$たちに遭遇した。
◎
This error occurs if the parser encounters attributes that are not separated by ASCII whitespace＼
</dd>
	<dd>例：
`&lt;div id="foo"class="bar"&gt;^c
◎
(e.g., &lt;div id="foo"class="bar"&gt;).＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-between-doctype-public-and-system-identifiers@pE</dt>
	<dd>誘因：
`~DOCTYPE$において，`~ASCII空白$で分離されてない~publicIDと~systemIDに遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose public and system identifiers are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`nested-comment@pE</dt>
	<dd>誘因：
入子な`~comment$に遭遇した。
◎
This error occurs if the parser encounters a nested comment＼
</dd>
	<dd>例：
`&lt;!-- &lt;!-- 入子な~comment --&gt; --&gt;^c
◎
(e.g., &lt;!-- &lt;!-- nested --&gt; --&gt;).＼
</dd>
	<dd>処置：
そのような~commentは，最初に生じた `--&gt;^l `~cp$列で閉じる
— 後続するものは、
何であれ~markupとして扱われることになる。
◎
Such a comment will be closed by the first occurring "--&gt;" code point sequence and everything that follows will be treated as markup.
</dd>

	<dt>`noncharacter-character-reference@pE</dt>
	<dd>誘因：
`非文字$を参照する，数量-`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a noncharacter.＼
</dd>
	<dd>処置：
そのような文字~参照は、
そのままに解決する。
◎
The parser resolves such character references as-is.
</dd>

	<dt>`noncharacter-in-input-stream@pE</dt>
	<dd>誘因：
`入力~stream$が`非文字$を包含している。
◎
This error occurs if the input stream contains a noncharacter.＼
</dd>
	<dd>処置：
そのような`~cp$は，そのままに構文解析され、
通例的には
— すなわち、
構文解析~規則が追加的な制約を適用しない所では —
~DOMに流し込まれる。
◎
Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.
</dd>

	<dt>`non-void-html-element-start-tag-with-trailing-solidus@pE</dt>
	<dd>誘因：［
次のいずれにも該当しない要素
］の`開始~tag$を閉じる `003E^U の直前にて，
`002F^U に遭遇した
⇒
`~void要素$／
外来~内容の一部である要素（すなわち，~SVG／~MathML要素）
◎
This error occurs if the parser encounters a start tag for an element that is not in the list of void elements or is not a part of foreign content (i.e., not an SVG or MathML element) that has a U+002F (/) code point right before the closing U+003E (&gt;) code point.＼
</dd>
	<dd>処置：
この `002F^U は無かったかのように挙動する。
◎
The parser behaves as if the U+002F (/) is not present.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

`non-void-html-element-start-tag-with-trailing-solidus^xCode

<p>
これは、
次のように構文解析されることになる：
◎
This will be parsed into:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`div$e
			<ul><li>`span$e
			</li><li>`span$e
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

	</dd>
	<dd class="note">注記：
開始~tagの名前~内の尾部に `002F^U を利用できるのは
自己閉じ~tagを指定する外来~内容~内に限られる。
（~HTMLには自己閉じ~tagは存在しない。）
それは，`~void要素$にも許容されるが、
この事例では，何ら効果はない。
◎
The trailing U+002F (/) in a start tag name can be used only in foreign content to specify self-closing tags. (Self-closing tags don't exist in HTML.) It is also allowed for void elements, but doesn't have any effect in this case.
</dd>

	<dt>`null-character-reference@pE</dt>
	<dd>誘因：
`0000^U を参照する，数量-`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a U+0000 NULL code point.＼
</dd>
	<dd>処置：
そのような文字~参照は、
`FFFD^U に解決する。
◎
The parser resolves such character references to a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`surrogate-character-reference@pE</dt>
	<dd>誘因：
`~surrogate$を参照する，数量-`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a surrogate.＼
</dd>
	<dd>処置：
そのような文字~参照は、
`FFFD^U に解決する。
◎
The parser resolves such character references to a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`surrogate-in-input-stream@pE</dt>
	<dd>誘因：
`入力~stream$は`~surrogate$を包含している。
◎
This error occurs if the input stream contains a surrogate.＼
</dd>
	<dd>処置：
そのような`~cp$は，そのままに構文解析され、
通例的には
— すなわち、
構文解析~規則が追加的な制約を適用しない所では —
~DOMに流し込まれる。
◎
Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.
</dd>
	<dd class="note">注記：
~surrogateが入力~streamの中に生じるのは、
`document.write()$c などの~script~APIを介した場合に限られる。
◎
Surrogates can only find their way into the input stream via script APIs such as document.write().
</dd>

	<dt>`unexpected-character-after-doctype-system-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$における~systemIDの後にて，次に挙げるもの以外の`~cp$に遭遇した
⇒＃
`~ASCII空白$,
~DOCTYPEを閉じる `003E^U
◎
This error occurs if the parser encounters any code points other than ASCII whitespace or closing U+003E (&gt;) after the DOCTYPE system identifier.＼
</dd>
	<dd>処置：
そのような~cpは、
無視する。
◎
The parser ignores these code points.
</dd>

	<dt>`unexpected-character-in-attribute-name@pE</dt>
	<dd>誘因：
`属性~名$内で，次に挙げるいずれかの`~cp$に遭遇した
⇒＃
`0022^U,
`0027^U,
`003C^U
◎
This error occurs if the parser encounters a U+0022 ("), U+0027 ('), or U+003C (&lt;) code point in an attribute name.＼
</dd>
	<dd>処置：
そのような~cpは、
属性~名に含める。
◎
The parser includes such code points in the attribute name.
</dd>
	<dd class="note">注記：
この~errorを誘発する~cpは、
通例的には別の構文-構成子の一部である
— 属性~名~周りの誤記の表れを示すものなど。
◎
Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute name.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

`unexpected-character-in-attribute-name-1^xCode

<p>
`foo^c の後に `003E^U を忘れたことに因り、
構文解析器は，この~markupを［
`foo&lt;div^l 属性を伴う 1 個の `div$e 要素
］として扱う。
◎
Due to a forgotten U+003E (&gt;) code point after foo the parser treats this markup as a single div element with a "foo&lt;div" attribute.
</p>

	</dd>
	<dd class="example">
<p>
この~errorの別の例として、
次の~markupを考える：
◎
As another example of this error, consider the following markup:
</p>

`unexpected-character-in-attribute-name-2^xCode

<p>
属性~名と値の合間に `003D^U を忘れたことに因り、構文解析器は，
この~markupを［
値が空にされた属性 `id'bar'^l を伴う `div$e 要素
］として扱う。
◎
Due to a forgotten U+003D (=) code point between an attribute name and value the parser treats this markup as a div element with the attribute "id'bar'" that has an empty value.
</p>
	</dd>

	<dt>`unexpected-character-in-unquoted-attribute-value@pE</dt>
	<dd>誘因：
引用符無しの`属性~値$内で，
次に挙げるいずれかの`~cp$に遭遇した
⇒＃
`0022^U,
`0027^U,
`003C^U,
`003D^U,
`0060^U
◎
This error occurs if the parser encounters a U+0022 ("), U+0027 ('), U+003C (&lt;), U+003D (=), or U+0060 (`) code point in an unquoted attribute value.＼
</dd>
	<dd>処置：
そのような~cpは、
属性~値に含める。
◎
The parser includes such code points in the attribute value.
</dd>
	<dd class="note">注記：
この~errorを誘発する~cpは、
通例的には別の構文-構成子の一部である
— 属性~値~周りの誤記の表れを示すものなど。
◎
Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute value.
</dd>
	<dd class="note">注記：
`0060^U は、
この~errorを誘発する~cpの一つである
— ある種の旧来の~UAは、
それを引用符として扱うので。
◎
U+0060 (`) is in the list of code points that trigger this error because certain legacy user agents treat it as a quote.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

`unexpected-character-in-unquoted-attribute-value^xCode

<p>
誤って置かれた `0027^U に因り、
構文解析器は `foo^l 属性の値を `b'ar'^l に設定する。
◎
Due to a misplaced U+0027 (') code point the parser sets the value of the "foo" attribute to "b'ar'".
</p>
	</dd>

	<dt>`unexpected-equals-sign-before-attribute-name@pE</dt>
	<dd>誘因：
属性~名の前で `003D^U に遭遇した。
◎
This error occurs if the parser encounters a U+003D (=) code point before an attribute name.＼
</dd>
	<dd>処置：
`003D^U を属性~名を成す最初の~cpとして扱う。
◎
In this case the parser treats U+003D (=) as the first code point of the attribute name.
</dd>
	<dd class="note">注記：
この~errorに共通的な理由は、
属性~名を忘れたときである。
◎
The common reason for this error is a forgotten attribute name.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

`unexpected-equals-sign-before-attribute-name^xCode

<p>
属性~名を忘れたことに因り、
構文解析器は，この~markupを
2 個の属性
— 値 `bar^lにされた `foo^l 属性, 値は空にされた `="baz"^l 属性 —
を伴う `div$e 要素として扱う。 
◎
Due to a forgotten attribute name the parser treats this markup as a div element with two attributes: a "foo" attribute with a "bar" value and a "="baz"" attribute with an empty value.
</p>
	</dd>

	<dt>`unexpected-null-character@pE</dt>
	<dd>誘因：
`入力~stream$内の一定の位置で，
`0000^U に遭遇した。
◎
This error occurs if the parser encounters a U+0000 NULL code point in the input stream in certain positions.＼
</dd>
	<dd>処置：
そのような~cpは、
一般に無視されるが，
~securityの理由から `FFFD^U に置換されることもある。
◎
In general, such code points are either ignored or, for security reasons, replaced with a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`unexpected-question-mark-instead-of-tag-name@pE</dt>
	<dd>誘因：
`開始~tag$の名前を成す最初の~cpが期待される所で， `003F^U に遭遇した。
◎
This error occurs if the parser encounters a U+003F (?) code point where first code point of a start tag name is expected.＼
</dd>
	<dd>処置：
`003F^U から［
それに後続する最初の `003E^U （無ければ `入力~stream$の終端）
］までのすべての内容を，~commentとして扱う。
◎
The U+003F (?) and all content that follows up to a U+003E (&gt;) code point (if present) or to the end of the input stream is treated as a comment.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

`unexpected-question-mark-instead-of-tag-name^xCode

<p>
これは、
次のように構文解析されることになる：
◎
This will be parsed into:
</p>

<ul class="domTree"><li>`#comment$: <span>?xml-stylesheet type="text/css" href="style.css"?</span>
</li><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
	</li></ul>
</li></ul>
</dd>
	<dd class="note">注記：
この~errorに共通的な理由は、［
~HTML内で，~XML処理命令
（例： `&lt;?xml-stylesheet type="text/css" href="style.css"?&gt;^c ） ／
~XML宣言
（例： `&lt;?xml version="1.0" encoding="UTF-8" ?&gt;^c ）
］が利用されているときである。
◎
The common reason for this error is an XML processing instruction (e.g., &lt;?xml-stylesheet type="text/css" href="style.css"?&gt;) or an XML declaration (e.g., &lt;?xml version="1.0" encoding="UTF-8" ?&gt;) being used in HTML.
</dd>

	<dt>`unexpected-solidus-in-tag@pE</dt>
	<dd>誘因：
ある~tag内で， `002F^U に遭遇したが、［
それは引用符付きの`属性$値の一部でない
］~AND［
その直後の~cpは `003E^U でない
］。
◎
This error occurs if the parser encounters a U+002F (/) code point that is not a part of a quoted attribute value and not immediately followed by a U+003E (&gt;) code point in a tag＼
</dd>
	<dd>例：
`&lt;div / id="foo"&gt;^c
◎
(e.g., &lt;div / id="foo"&gt;).＼
</dd>
	<dd>処置：
`~ASCII空白$に遭遇したかのように挙動する。
◎
In this case the parser behaves as if it encountered ASCII whitespace.
</dd>

	<dt>`unknown-named-character-reference@pE</dt>
	<dd>誘因：
`多義的~ampersand$に遭遇した。
◎
This error occurs if the parser encounters an ambiguous ampersand.＼
</dd>
	<dd>処置：
そのような`文字~参照$は、
解決しない。
◎
In this case the parser doesn't resolve the character reference.
</dd>
</dl>

			</section>
			<section id="the-input-byte-stream">
<h4 title="The input byte stream">13.2.3. 入力~byte~stream</h4>

<p>
~token化~段階への入力を成す~cp~streamは、
~UAからは初期~時には~byte列~streamとして見えることになる
（概して，~network越しに, または局所~file~systemから来ている）。
そのような~byte列は，実際の文字~並びを特定0の `符号化法^i に則って符号化した結果であり、
~UAは，その符号化法を利用して~byte列を文字~並びに復号する。
◎
The stream of code points that comprises the input to the tokenization stage will be initially seen by the user agent as a stream of bytes (typically coming over the network or from the local file system). The bytes encode the actual characters according to a particular character encoding, which the user agent uses to decode the bytes into characters.
</p>

<p class="note">注記：
~XML文書に対しては、［
符号化法を決定するために利用するよう，~UAに要求される~algo
］は， `XML^cite が与える。
この節は、
~XML文書には適用されない。
`XML$r
◎
For XML documents, the algorithm user agents are required to use to determine the character encoding is given by XML. This section does not apply to XML documents. [XML]
</p>

<p>
符号化法を決定するためには、
通例的には，下に定義する`符号化法を~sniffする~algo$を利用する。
◎
Usually, the encoding sniffing algorithm defined below is used to determine the character encoding.
</p>

<p>
`入力~byte~stream$内の~byte列は、
次の結果による文字~並びに変換した上で，~tokenizerの`入力~stream$に渡すモノトスル
⇒
`~Unicodeに復号する$( ~byte列, 所与の符号化法 )
◎
Given a character encoding, the bytes in the input byte stream must be converted to characters for the tokenizer's input stream, by passing the input byte stream and character encoding to decode.
</p>

<p class="note">注記：
頭部に~BOM（ `Byte Order Mark^en ）が在る場合、
符号化法~引数は無視され，~BOM自身も飛ばされることになる。
◎
A leading Byte Order Mark (BOM) causes the character encoding argument to be ignored and will itself be skipped.
</p>

<p class="note">注記：
元の~byte~stream内に `ENCODING$r 標準に適合しない［
~byte／~byte列
］が在る場合
（例：~UTF-8入力~byte~stream内の妥当でない~UTF-8~byte列）、
~errorである
— 適合性~検査器には、
それを報告することが期待される。
◎
Bytes or sequences of bytes in the original byte stream that did not conform to the Encoding standard (e.g. invalid UTF-8 byte sequences in a UTF-8 input byte stream) are errors that conformance checkers are expected to report. [ENCODING]
</p>

<p class="warning">
復号器~algoは、
妥当でない入力を取扱う方法を述べる。
~securityの理由から、
この規則に精確に従うことは，~~必須とされる。
妥当でない~byte列を取扱う方法において【実装~間に】相違があると、
他の問題もあるが，~script注入（ “XSS” ）の脆弱性を成し得るので。
◎
The decoder algorithms describe how to handle invalid input; for security reasons, it is imperative that those rules be followed precisely. Differences in how invalid byte sequences are handled can result in, amongst other problems, script injection vulnerabilities ("XSS").
</p>

<p>
~HTML構文解析器は、
入力~byte~streamを復号する際に
符号化法と
`確度@
~IN { `暫定的^i, `確か^i, `無関連^i }
を利用する。
利用されている符号化法, および［
そこでの確度は［
`暫定的^i, `確か^i
］どちらなのか
］は、［
`構文解析している間＠#meta-charset-during-parse$に`符号化法を変更する$かどうか決定するとき
］に利用される。
符号化法は必要yでない場合、
`確度$は `無関連^i になる
— 例：
構文解析器は ~Unicode~streamに対し演算していて，
符号化法を利用する必要はまったくないとき。
◎
When the HTML parser is decoding an input byte stream, it uses a character encoding and a confidence. The confidence is either tentative, certain, or irrelevant. The encoding used, and whether the confidence in that encoding is tentative or certain, is used during the parsing to determine whether to change the encoding. If no encoding is necessary, e.g. because the parser is operating on a Unicode stream and doesn't have to use a character encoding at all, then the confidence is irrelevant.
</p>

<p class="note">注記：
一部の~algoは、
~byte列を`入力~byte~stream$に追加することなく，
文字たちを［
`入力~stream$に直に追加する
］ことにより構文解析器に投入する。
◎
Some algorithms feed the parser by directly adding characters to the input stream rather than adding bytes to the input byte stream.
</p>

				<section id="parsing-with-a-known-character-encoding">
<h5 title="Parsing with a known character encoding">13.2.3.1. 既知な符号化法による構文解析</h5>

<p>
~HTML構文解析器が，ある
`既知かつ確定的な符号化法@
%符号化法 を伴う入力~byte~streamに対し演算するときの
( 符号化法, `確度$ )
は、
( %符号化法, `確か^i )
になるとする。
◎
When the HTML parser is to operate on an input byte stream that has a known definite encoding, then the character encoding is that encoding and the confidence is certain.
</p>

				</section>
				<section id="determining-the-character-encoding">
<h5 title="Determining the character encoding">13.2.3.2. 符号化法の決定-法</h5>

<p>
文書を構文解析する前に符号化法を一義的に決定するのは、
実用的でない事例もあるかもしれない。
そのため、
この仕様は 2 周回の仕組みを供する：
◎
In some cases, it might be impractical to unambiguously determine the encoding before parsing the document. Because of this, this specification provides for a two-pass mechanism with an optional pre-scan.＼
</p>

<ol>
	<li>
1 周回~目の予走査は、［
下に述べる，単純~化された構文解析~algo
］であり，任意選択である
— 実装には、［
文書を構文解析し始める前に可用になった~byte列
］に対し，［
それが何であれ，この~algoを適用する
］ことも許容される。
◎
Implementations are allowed, as described below, to apply a simplified parsing algorithm to whatever bytes they have available before beginning to parse the document.＼
</li>
	<li>
2 周回~目の本番の構文解析器は、［
予走査から導出された暫定的な符号化法, その他の帯域外の~metadata
］を利用して開始される。
文書が読込まれている間に，~UAが［
この情報と競合する符号化法~宣言
］を発見した場合、
構文解析器は，再び
— 本番の符号化法で文書の構文解析-を遂行し直すよう —
呼出されることになる。
◎
Then, the real parser is started, using a tentative encoding derived from this pre-parse and other out-of-band metadata. If, while the document is being loaded, the user agent discovers a character encoding declaration that conflicts with this information, then the parser can get reinvoked to perform a parse of the document with the real encoding.
</li>
</ol>

<div class="algo">
<p id="documentEncoding">
~UAは 1 周回~目にて，文書の復号-時に利用する符号化法を決定するときには、
次に与える
`符号化法を~sniffする~algo@
を利用するモノトスル。
この~algoは、
所与の［
それまでに可用な，当の資源を成す すべての~byte列 %~byte列
］および［
~UAに可用な帯域外の~metadata
（もし在れば
— 例：文書の`~Content-Type~metadata$）
］に対し，
( 符号化法, `確度$ ~IN { `暫定的^i, `確か^i } )
の組を返す：
◎
User agents must use the following algorithm, called the encoding sniffing algorithm, to determine the character encoding to use when decoding a document in the first pass. This algorithm takes as input any out-of-band metadata available to the user agent (e.g. the Content-Type metadata of the document) and all the bytes available so far, and returns a character encoding and a confidence that is either tentative or certain.
</p>

<ol>
	<li>
<p>
~IF［
`~BOMを~sniffする$( %~byte列 ) の結果 ~NEQ ~NULL
］
⇒
~RET ( 結果の符号化法, `確か^i )
◎
If the result of BOM sniffing is an encoding, return that encoding with confidence certain.
</p>

<p class="note">注記：
上述した`~Unicodeに復号する$ ~algoも［
~BOMが在るときは，それに基づいて利用する符号化法を変更する
］が、
この~algoも，正しい［
`符号化法$doc, `確度$
］を設定するために ~BOMを~sniffする。
◎
Although the decode algorithm will itself change the encoding to use based on the presence of a byte order mark, this algorithm sniffs the BOM as well in order to set the correct document's character encoding and confidence.
</p>
	</li>
	<li>
<p>
任意選択で
⇒
~IF［
利用者は、［
文書の符号化法を特定の符号化法で上書きする
］よう，明示的に~UAに指図した
］
⇒
~RET ( その符号化法, `確か^i )
◎
If the user has explicitly instructed the user agent to override the document's character encoding with a specific encoding, optionally return that encoding with the confidence certain.
</p>

<p class="note">注記：
~UAは，概して、
利用者からのそのような要請を複数~sessionにわたって覚える。
また、
一部の事例では， `iframe$e 内の文書にもそれらを適用する。
◎
Typically, user agents remember such user requests across sessions, and in some cases apply them to documents in iframes as well.
</p>

	</li>
	<li>
<p>
~UAは、［
この~algoの，この段も含む以降の各~段
］にて，資源を成す~byte列が更に可用になるまで待機してもヨイ。
一例として，~UAは、［
500ms 経つか, 1024 ~byte得られるか
］いずれか早い方まで待機するかもしれない。
一般に，符号化法を見出すために~sourceを予め構文解析すれば、
処理能は改善される
— そうすれば、
符号化法~情報が見出されたとき，
構文解析-時に利用した~data構造を棄てる必要は抑制されるので。
しかしながら、
この処理能の改善より，［
符号化法を決定するための~dataを得するために，~UAが遅延し過ぎることによる~cost
］の方が重くなることもある。
◎
The user agent may wait for more bytes of the resource to be available, either in this step or at any later step in this algorithm. For instance, a user agent might wait 500ms or 1024 bytes, whichever came first. In general preparsing the source to find the encoding improves performance, as it reduces the need to throw away the data structures used when parsing upon finding the encoding information. However, if the user agent delays too long to obtain data to determine the encoding, then the cost of the delay could outweigh any performance improvements from the preparse.
</p>

<p class="note">注記：
符号化法~宣言に対する著作~適合性~要件は、
それを`最初の 1024 ~byteまで＠~HEmetadata#charset1024$に現れるものに制限する。
したがって，~UAには、
下に示す予走査~algoを最初の 1024 ~byteまでに限って（この手続きが呼出すように）利用し，
それを超えて停滞しないことが奨励される。
◎
The authoring conformance requirements for character encoding declarations limit them to only appearing in the first 1024 bytes. User agents are therefore encouraged to use the prescan algorithm below (as invoked by these steps) on the first 1024 bytes, but not to stall beyond that.
</p>

	</li>
	<li>
~IF［
~transport層は、
~supportされる符号化法を指定している
］
⇒
~RET ( その符号化法, `確か^i )
◎
If the transport layer specifies a character encoding, and it is supported, return that encoding with the confidence certain.
</li>
	<li>
<p>
任意選択で、
次を走らす
— ~UAは，~byte列を`まったく走査しない^em方が効率的であると裁定してもヨイ
（その場合、この段は まるごと飛ばす）：
◎
Optionally,＼
</p>
		<ol>
			<li>
%符号化法 ~LET `~byte~streamを予走査して符号化法を決定する$
— その `終了~条件$V は、
~UAが［
それ以上~byte列を走査しても効率的にならない
］と裁定した所までとする。
~UAには、
最初から 1024 個までの~byteに限り予走査することが奨励される。
◎
prescan the byte stream to determine its encoding, with the end condition being when the user agent decides that scanning further bytes would not be efficient. User agents are encouraged to only prescan the first 1024 bytes. User agents may decide that scanning any bytes is not efficient, in which case these substeps are entirely skipped.
</li>
			<li>
~IF［
%符号化法 ~NEQ `失敗^i
］
⇒
~RET ( %符号化法, `暫定的^i )
◎
The aforementioned algorithm returns either a character encoding or failure. If it returns a character encoding, then return the same encoding, with confidence tentative.
</li>
		</ol>
	</li>
	<li>
%文書 ~LET この~algoを走らせている`~HTML構文解析器$を結付けている`文書$
◎
↓</li>
	<li>
<p>
~IF［
%文書 の`容器~文書$doc ~NEQ NULL
］：
◎
If the HTML parser for which this algorithm is being run is associated with a Document d whose container document is non-null, then:
</p>
		<ol>
			<li>
%親~文書 ~LET %文書 の`容器~文書$doc
◎
Let parentDocument be d's container document.
</li>
			<li>
~IF［
( %親~文書 の`生成元$doc, %文書 の`生成元$doc )
は`同一-生成元$である
］~AND［
%親~文書 の`符号化法$docは `UTF-16BE/LE$enc でない
］
⇒
~RET ( %親~文書 の`符号化法$doc, `暫定的^i )
◎
If parentDocument's origin is same origin with d's origin and parentDocument's character encoding is not UTF-16BE/LE, then return parentDocument's character encoding, with the confidence tentative.
</li>
		</ol>
	</li>
	<li>
~ELIF［
~UAは、
当の~pageに見込まれる符号化法の情報を有する
— 例：最後に訪問したときの~pageの符号化法に基づくものなど
］
⇒
~RET ( その符号化法, `暫定的^i )
◎
Otherwise, if the user agent has information on the likely encoding for this page, e.g. based on the encoding of the page when it was last visited, then return that encoding, with the confidence tentative.
</li>
	<li>
<p>
任意選択で次を走らす：
</p>
		<ol>
			<li>
~data~streamに頻度解析その他の~algoを適用して，符号化法を自動検出しようと試みる
— そのような~algoは、
資源の内容の他にも資源についての情報（例：資源の~address）が在るならば，それを利用してもヨイ
`UNIVCHARDET$r
◎
The user agent may attempt to autodetect the character encoding from applying frequency analysis or other algorithms to the data stream. Such algorithms may use information about the resource other than the resource's contents, including the address of the resource.＼
</li>
			<li>
~IF［
前~段にて符号化法を決定するのに成功した
］~AND［
結果の符号化法は~supportされる符号化法である
］
⇒
~RET ( 結果の符号化法, `暫定的^i )
◎
If autodetection succeeds in determining a character encoding, and that encoding is a supported encoding, then return that encoding, with the confidence tentative. [UNIVCHARDET]
</li>
		</ol>

<p class="note">注記：
~UAには、
一般に［
~network越しに得された資源に対しては，符号化法を自動検出しようと試みない
］ことが奨励される
— そうすることは、
内来的に相互運用可能でない経験則を孕むので。
符号化法を~HTML文書の前置きに基づいて検出しようと試みるのは、
とりわけ込み入っている
— ~HTML~markupは，概して~ASCII文字のみを利用しており、
~HTML文書は，~text内容に~~先立って多量の~markupから始まる傾向にあるので。
◎
User agents are generally discouraged from attempting to autodetect encodings for resources obtained over the network, since doing so involves inherently non-interoperable heuristics. Attempting to detect encodings based on an HTML document's preamble is especially tricky since HTML markup typically uses only ASCII characters, and HTML documents tend to begin with a lot of markup rather than with text content.
</p>

<p class="note">注記：
~UTF-8符号化法の~bit~patternは、
非常に検出し易い。
局所~file~systemからの~fileは、［
値が `7F^X より大きく, ~UTF-8~patternに合致するような，~byte列
］を包含しているならば，およそ ~UTF-8と見込まれる一方で、
合致しない~byte列を伴う文書は，およそ そうでないと見込まれる。
~UAは，前置きのみならず~file全体を精査できるなら、
特定的に~UTF-8を検出することが，とりわけ効果的になり得る。
`PPUTF8$r
`UTF8DET$r
◎
The UTF-8 encoding has a highly detectable bit pattern. Files from the local file system that contain bytes with values greater than 0x7F which match the UTF-8 pattern are very likely to be UTF-8, while documents with byte sequences that do not match it are very likely not. When a user agent can examine the whole file, rather than just the preamble, detecting for UTF-8 specifically can be especially effective. [PPUTF8] [UTF8DET]
</p>
	</li>
	<li>
<p>
~RET ( ［
`実装定義$な／利用者が指定した
］既定の符号化法, `暫定的^i )
◎
Otherwise, return an implementation-defined or user-specified default character encoding, with the confidence tentative.
</p>
		<ul>
			<li>
［
制御~下にある環境／
文書の符号化法が制定-済みな環境
］
（例えば、［
新たな~networkに専用の利用
］が意図される~UA用の）
においては、
包括的な `UTF-8^enc 符号化法が示唆される。
◎
In controlled environments or in environments where the encoding of documents can be prescribed (for example, for user agents intended for dedicated use in new networks), the comprehensive UTF-8 encoding is suggested.
</li>
			<li>
<p>
他の環境においては、
既定の符号化法は，概して利用者の~localeに依存する
（~localeとは，利用者が ~pageたちにわたって頻用すると見込まれる言語の近似であり、
符号化法も その言語から~~導出されることが多い）。
次の表tに、
旧来の内容との互換性のために，利用者の~localeに基づいて示唆される既定の符号化法を与える：
◎
In other environments, the default encoding is typically dependent on the user's locale (an approximation of the languages, and thus often encodings, of the pages that the user is likely to frequent). The following table gives suggested defaults based on the user's locale, for compatibility with legacy content. Locales are identified by BCP 47 language tags. [BCP47] [ENCODING]
</p>

<table><thead>
<tr><th>言語~tag `BCP47$r
<th>
~locale言語
◎
Locale language
<th>
示唆される既定の符号化法 `ENCODING$r
◎
Suggested default encoding 
<tbody>

<tr><td>ar
<td>Arabic
<td>`windows-1256$enc

<tr><td>az
<td>Azeri
<td>`windows-1254$enc

<tr><td>ba
<td>Bashkir
<td>`windows-1251$enc

<tr><td>be
<td>Belarusian
<td>`windows-1251$enc

<tr><td>bg
<td>Bulgarian
<td>`windows-1251$enc

<tr><td>cs
<td>Czech
<td>`windows-1250$enc

<tr><td>el
<td>Greek
<td>`ISO-8859-7$enc

<tr><td>et
<td>Estonian
<td>`windows-1257$enc

<tr><td>fa
<td>Persian
<td>`windows-1256$enc

<tr><td>he
<td>Hebrew
<td>`windows-1255$enc

<tr><td>hr
<td>Croatian
<td>`windows-1250$enc

<tr><td>hu
<td>Hungarian
<td>`ISO-8859-2$enc

<tr><td>ja
<td>Japanese
<td>`Shift_JIS$enc

<tr><td>kk
<td>Kazakh
<td>`windows-1251$enc

<tr><td>ko
<td>Korean
<td>`EUC-KR$enc

<tr><td>ku
<td>Kurdish
<td>`windows-1254$enc

<tr><td>ky
<td>Kyrgyz
<td>`windows-1251$enc

<tr><td>lt
<td>Lithuanian
<td>`windows-1257$enc

<tr><td>lv
<td>Latvian
<td>`windows-1257$enc

<tr><td>mk
<td>Macedonian
<td>`windows-1251$enc

<tr><td>pl
<td>Polish
<td>`ISO-8859-2$enc

<tr><td>ru
<td>Russian
<td>`windows-1251$enc

<tr><td>sah
<td>Yakut
<td>`windows-1251$enc

<tr><td>sk
<td>Slovak
<td>`windows-1250$enc

<tr><td>sl
<td>Slovenian
<td>`ISO-8859-2$enc

<tr><td>sr
<td>Serbian
<td>`windows-1251$enc

<tr><td>tg
<td>Tajik
<td>`windows-1251$enc

<tr><td>th
<td>Thai
<td>`windows-874$enc

<tr><td>tr
<td>Turkish
<td>`windows-1254$enc

<tr><td>tt
<td>Tatar
<td>`windows-1251$enc

<tr><td>uk
<td>Ukrainian
<td>`windows-1251$enc

<tr><td>vi
<td>Vietnamese
<td>`windows-1258$enc

<tr><td>zh-Hans, zh-CN, zh-SG
<td>Chinese, Simplified
<td>`GBK$enc

<tr><td>zh-Hant, zh-HK, zh-MO, zh-TW
<td>Chinese, Traditional
<td>`Big5$enc

<tr><td colspan="2">
他のすべての~locale
◎
All other locales
<td>`windows-1252$enc
</table>

<p class="tablenote"><small>
この表tの内容は、
Windows, Chrome, Firefox
による既定~のそれらの共通部分から導出されている。
</small>
◎
The contents of this table are derived from the intersection of Windows, Chrome, and Firefox defaults.
</p>
			</li>
		</ul>
	</li>
</ol>

<p>
文書の`符号化法$docは、
即時に，この~algoが返す値に設定するモノトスル
— ~UAが，返された値を利用して［
入力~byte~stream用に利用する復号器
］を選定するときと同時に。
◎
The document's character encoding must immediately be set to the value returned from this algorithm, at the same time as the user agent uses the returned value to select the decoder to use for the input byte stream.
</p>

</div>

<hr>

<div class="algo">
<div class="p">
<p>
`~byte~streamを予走査して符号化法を決定する@
~algoは：
</p>
<ul>
	<li>
符号化法を返すか，どこかで中止される。
中止された場合、
次を適用した結果を返すとする
⇒
`~XML符号化法を取得する$( この~algoが中止されるまで走査した~byte列 )
</li>
	<li>
入力~byte~stream内のどこかを指す，
%位置 と記される~pointerを利用する
— 初期~時は最初の~byteを指すとする。
また， %位置↗ という表記は、
%位置 が指している~byteを表すとする。
</li>
	<li>
ある定義-済みな
`終了~条件@V
が与えられる。
~UAは、［
この手続きの間のある地点にて
（この手続きが呼出す`属性を取得する$も含めて），
%終了~条件 に達した場合、
この~algoを中止する
— ~byte列が尽きた場合も %終了~条件 に達したものと見なす。
すなわち， %終了~条件 は、
手続き内の %位置↗ が現れるすべての箇所で検査され，達した時点で中止する。
</li>
	<li>
この手続きの目的における `空白~byte^i は、
次に挙げる~byteの総称とする
⇒＃
`09^X (HT),
`0A^X (LF),
`0C^X (FF),
`0D^X (CR),
`20^X (SP)
</li>
</ul>
◎
When an algorithm requires a user agent to prescan a byte stream to determine its encoding, given some defined end condition, then it must run the following steps. If at any point during these steps (including during instances of the get an attribute algorithm invoked by this one) the user agent either runs out of bytes (meaning the position pointer created in the first step below goes beyond the end of the byte stream obtained so far) or reaches its end condition, then abort the prescan a byte stream to determine its encoding algorithm and return the result get an XML encoding applied to the same bytes that the prescan a byte stream to determine its encoding algorithm was applied to. Otherwise, these steps will return a character encoding.
• Let position be a pointer to a byte in the input byte stream, initially pointing at the first byte.
</div>
<ol>
	<li>
<p>
（この段は、
~UTF-16~XML宣言を予走査する）：
◎
Prescan for UTF-16 XML declarations: If position points to:
</p>
		<ol>
			<li>
%~XML宣言~開始 ~LET 入力~byte~streamの先頭から 6 個までの~byteが成す~byte列
◎
↓</li>
			<li>
~IF［
%~XML宣言~開始 ~EQ ［
`3C^X, `0^X, `3F^X, `0^X, `78^X, `0^X
］（~UTF-16 ~little-endian `&lt;?x^bl ）
］
⇒
~RET `UTF-16LE$enc
◎
A sequence of bytes starting with: 0x3C, 0x0, 0x3F, 0x0, 0x78, 0x0 (case-sensitive UTF-16 little-endian '&lt;?x')
• Return UTF-16LE.
</li>
			<li>
~IF［
%~XML宣言~開始 ~EQ ［
`0^X, `3C^X, `0^X, `3F^X, `0^X, `78^X
］（~UTF-16 ~big-endian `&lt;?x^bl ）
］
⇒
~RET `UTF-16BE$enc
◎
A sequence of bytes starting with: 0x0, 0x3C, 0x0, 0x3F, 0x0, 0x78 (case-sensitive UTF-16 big-endian '&lt;?x')
• Return UTF-16BE.
</li>
		</ol>

<p class="note">注記：
歴史的~理由から、
次は検査されない
⇒
<span lang="en">
the prefix is two bytes longer than in
`Appendix F＠~TR/REC-xml/#sec-guessing$ of `XML^cite
</span>【？】,
および符号化法の名前。
◎
For historical reasons, the prefix is two bytes longer than in Appendix F of XML and the encoding name is not checked.
</p>

	</li>
	<li>
`~loop先頭^i：
<p>
~WHILE［
%位置↗ ~NEQ `3C^X ( `&lt;^bl )
］
⇒
%位置 ~INCBY 1
</p>
◎
↓</li>
	<li>
%~byte列 ~LET `~byte小文字~化する$( 入力~byte~streamの ( %位置 ~PLUS 1 ) から 5 個までの~byteが成す~byte列 )
◎
↓</li>
	<li>

<div>
<p>
~IF［
次の表tの中に %~byte列 に合致する行はある
］
⇒
［
最初に合致した行の~label列に与える~label
］に対応する［
表tの下に与える手続き
］を走らす：
</p>

<table>
<caption>
表t内の `小文字^i は `61^X 〜 `7A^X を表す。
表t内の空欄は無条件を表す
（当の~byteが存在しない場合も含む）。
</caption>
<thead>
<tr><th>1 個目
<th>2 個目
<th>3 個目
<th>4 個目
<th>5 個目
<th>~label
<tbody>

<tr><td>`21^X (`!^bl)
<td>`2D^X (`-^bl)
<td>`2D^X (`-^bl)
<td>
<td>
<td>`~comment^i

<tr><td>`6D^X (`m^bl) 
<td>`65^X (`e^bl) 
<td>`74^X (`t^bl)
<td>`61^X (`a^bl)
<td class="preline">`空白~byte^i ／
`2F^X (`/^bl)
<td>`meta^i

<tr><td>`小文字^i
<td>
<td>
<td>
<td>
<td>`他の~tag^i

<tr><td>`2F^X (`/^bl)
<td>`小文字^i
<td>
<td>
<td>
<td>`他の~tag^i

<tr><td class="preline">`21^X (`!^bl) ／
`2F^X (`/^bl) ／
`3F^X (`?^bl)
<td>
<td>
<td>
<td>
<td>`他の~mark^i
</table>

◎
Loop: If position points to:
</div>

		<dl class="switch">
			<dt>
`~comment^i
◎
A sequence of bytes starting with: 0x3C 0x21 0x2D 0x2D (`&lt;!--`)
</dt>
			<dd>
				<ol>
					<li>
~WHILE［
入力~byte~streamの %位置 から 3 個までの~byteが成す~byte列 ~NEQ `2D^X `2D^X `3E^X ( `--&gt;^bl ) †
］
⇒
%位置 ~INCBY 1
</li>
					<li>
%位置 ~INCBY 2
</li>
				</ol>

（† 2 個の `2D^X ~byteは、
合致した `!--^bl と重なり得る）

◎
Advance the position pointer so that it points at the first 0x3E byte which is preceded by two 0x2D bytes (i.e. at the end of an ASCII '--&gt;' sequence) and comes after the 0x3C byte that was found. (The two 0x2D bytes can be the same as those in the '&lt;!--' sequence.)
</dd>
			<dt>
`meta^i
◎
A sequence of bytes starting with: 0x3C, 0x4D or 0x6D, 0x45 or 0x65, 0x54 or 0x74, 0x41 or 0x61, and one of 0x09, 0x0A, 0x0C, 0x0D, 0x20, 0x2F (case-insensitive ASCII '&lt;meta' followed by a space or slash)
</dt>
			<dd>
				<ol>
					<li>
%位置 ~INCBY 5
◎
Advance the position pointer so that it points at the next 0x09, 0x0A, 0x0C, 0x0D, 0x20, or 0x2F byte (the one in sequence of characters matched above).
</li>
					<li>
%属性~list ~LET （文字列たちが成す）空~list
◎
Let attribute list be an empty list of strings.
</li>
					<li>
%~pragmaは得られたか ~LET ~F
◎
Let got pragma be false.
</li>
					<li>
%~pragmaは必要か ~LET ε
◎
Let need pragma be null.
</li>
					<li>
%~charset ~LET ε
（この値は、
この~algoの目的においては［
認識されない符号化法／空~文字列
］とは別個である。）
◎
Let charset be the null value (which, for the purposes of this algorithm, is distinct from an unrecognized encoding or the empty string).
</li>
					<li>
<p>
~WHILE 無条件：
◎
Attributes:＼
</p>
						<ol>
							<li>
( %属性~名, %属性~値 ) ~LET `属性を取得する$
◎
Get an attribute and its value.＼
</li>
							<li>
~IF［
%属性~名 ~EQ ε
］
⇒
~BREAK
◎
If no attribute was sniffed, then jump to the processing step below.
</li>
							<li>
~IF［
%属性~名 ~IN %属性~list
］
⇒
~CONTINUE
◎
If the attribute's name is already in attribute list, then return to the step labeled attributes.
</li>
							<li>
%属性~list に %属性~名 を追加する
◎
Add the attribute's name to attribute list.
</li>
							<li>
<p>
%属性~名 に応じて：
◎
Run the appropriate step from the following list, if one applies:
</p>
								<ul class="switch">
									<li>
`http-equiv^l
⇒
~IF［
%属性~値 ~EQ `content-type^l
］
⇒
%~pragmaは得られたか ~SET ~T
◎
If the attribute's name is "http-equiv"
• If the attribute's value is "content-type", then set got pragma to true.
</li>
									<li>
<p>
`content^l ：
</p>
										<ol>
											<li>
~IF［
%~charset ~NEQ ε
］
⇒
~CONTINUE
</li>
											<li>
%符号化法 ~LET `~meta要素から符号化法を抽出する$( %属性~値 )
</li>
											<li>
~IF［
%符号化法 ~EQ ε
］
⇒
~CONTINUE
</li>
											<li>
%~charset ~LET %符号化法
</li>
											<li>
%~pragmaは必要か ~SET ~T
</li>
										</ol>
◎
If the attribute's name is "content"
• Apply the algorithm for extracting a character encoding from a meta element, giving the attribute's value as the string to parse. If a character encoding is returned, and if charset is still set to null, let charset be the encoding returned, and set need pragma to true.
</li>
									<li>
`charset^l
⇒＃
%~charset ~LET `~labelから符号化法を取得する$( %属性~値 )；
%~pragmaは必要か ~SET ~F
◎
If the attribute's name is "charset"
• Let charset be the result of getting an encoding from the attribute's value, and set need pragma to false.
</li>
									<li>
その他
⇒
何もしない
◎
↑↑</li>
								</ul>
							</li>
							<li>
（ ~CONTINUE ）
◎
Return to the step labeled attributes.
</li>
						</ol>
					</li>
					<li>
~IF［
%~pragmaは必要か ~EQ ε
］
⇒
~GOTO `次回の~byte^i
◎
Processing: If need pragma is null, then jump to the step below labeled next byte.
</li>
					<li>
~IF［
%~pragmaは必要か ~EQ ~T
］~AND［
%~pragmaは得られたか ~EQ ~F
］
⇒
~GOTO `次回の~byte^i
◎
If need pragma is true but got pragma is false, then jump to the step below labeled next byte.
</li>
					<li>
~IF［
%~charset ~EQ `失敗^i
］
⇒
~GOTO `次回の~byte^i
◎
If charset is failure, then jump to the step below labeled next byte.
</li>
					<li>
~RET %~charset に応じて
⇒＃
`UTF-16BE/LE$enc であるならば `UTF-8$enc ／
`x-user-defined$enc ならば `windows-1252$enc ／
~ELSE_ %~charset
◎
If charset is UTF-16BE/LE, then set charset to UTF-8.
◎
If charset is x-user-defined, then set charset to windows-1252.
◎
Return charset.
</li>
				</ol>
			</dd>
			<dt>
`他の~tag^i
◎
A sequence of bytes starting with a 0x3C byte (&lt;), optionally a 0x2F byte (/), and finally a byte in the range 0x41-0x5A or 0x61-0x7A (A-Z or a-z)
</dt>
			<dd>
				<ol>
					<li>
~WHILE［
%位置↗ ~NIN { `空白~byte^i, `3E^X (`&gt;^bl) }
］
⇒
%位置 ~INCBY 1
◎
Advance the position pointer so that it points at the next 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP), or 0x3E (&gt;) byte.
</li>
					<li>
~WHILE ［
`属性を取得する$の結果 ~NEQ ( ε, ε )
］
⇒
（何もしない）
◎
Repeatedly get an attribute until no further attributes can be found, then＼
◎
jump to the step below labeled next byte.
</li>
				</ol>
			</dd>

			<dt>
`他の~mark^i
◎
A sequence of bytes starting with: 0x3C 0x21 (`&lt;!`)
◎
A sequence of bytes starting with: 0x3C 0x2F (`&lt;/`)
◎
A sequence of bytes starting with: 0x3C 0x3F (`&lt;?`)
</dt>
			<dd>
~WHILE［
%位置↗ ~NEQ `3E^X ( `&gt;^bl )
］
⇒
%位置 ~INCBY 1
◎
Advance the position pointer so that it points at the first 0x3E byte (&gt;) that comes after the 0x3C byte that was found.
</dd>
		</dl>
	</li>
	<li>
`次回の~byte^i
⇒＃
%位置 ~INCBY 1；
~GOTO `~loop先頭^i
◎
Any other byte
• Do nothing with that byte.
◎
Next byte: Move position so it points at the next byte in the input byte stream, and return to the step above labeled loop.
</li>
</ol>

<div class="algo">
<p>
上の~algoにおいて
`属性を取得する@
下位-手続きは：
◎
When the prescan a byte stream to determine its encoding algorithm says to get an attribute, it means doing this:
</p>
<ol>
	<li>
~WHILE［
%位置↗ ~IN { `空白~byte^i, `2F^X (`/^bl) }
］
⇒
%位置 ~INCBY 1
◎
If the byte at position is one of 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP), or 0x2F (/), then advance position to the next byte and redo this step.
</li>
	<li>
~IF［
%位置↗ ~EQ `3E^X (`&gt;^bl)
］
⇒
~RET ( ε, ε )
◎
If the byte at position is 0x3E (&gt;), then abort the get an attribute algorithm. There isn't one.
</li>
	<li>
~Assert：
%位置 は属性~名の始端を指す。
◎
Otherwise, the byte at position is the start of the attribute name.＼
</li>
	<li>
%属性~名~LET 空~文字列
◎
Let attribute name and attribute value be the empty string.
</li>
	<li>
<p>
~WHILE［
%位置↗ ~NIN { `空白~byte^i }
］：
</p>
		<ol>
			<li>
<p>
%位置↗ に応じて：
◎
Process the byte at position as follows:
</p>

				<dl class="switch">
					<dt>
`3D^X (`=^bl)
◎
If it is 0x3D (=), and the attribute name is longer than the empty string
</dt>
					<dd>
						<ol>
							<li>
~IF［
%属性~名 ~EQ 空~文字列
］
⇒
~GOTO ~AnyElse
</li>
							<li>
%位置 ~INCBY 1
</li>
							<li>
~GOTO `値^i
</li>
						</ol>

◎
Advance position to the next byte and jump to the step below labeled value.
◎
↑If it is 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), or 0x20 (SP)
• Jump to the step below labeled spaces.
</dd>

					<dt>`2F^X (`/^bl)</dt>
					<dt>`3E^X (`&gt;^bl)</dt>
					<dd>
~RET ( %属性~名, 空~文字列 )
◎
If it is 0x2F (/) or 0x3E (&gt;)
◎
Abort the get an attribute algorithm. The attribute's name is the value of attribute name, its value is the empty string.
</dd>

					<dt>~AnyElse</dt>
					<dd>
%属性~名 ~APPEND ~cp( `~byte小文字~化する$( %位置↗ ) )
◎
If it is in the range 0x41 (A) to 0x5A (Z)
• Append the code point b+0x20 to attribute name (where b is the value of the byte at position). (This converts the input to lowercase.)
◎
Anything else
• Append the code point with the same value as the byte at position to attribute name.＼
</dd>
					<dd>
（~ASCII範囲の外側にある~byteが ここでどう取扱われるかは、
実際に問われることはない
— ~ASCII~byteのみが符号化法の検出に寄与し得るので。）
◎
(It doesn't actually matter how bytes outside the ASCII range are handled here, since only ASCII bytes can contribute to the detection of a character encoding.)
</dd>
				</dl>
			</li>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next byte and return to the previous step.
</li>
		</ol>
	</li>
	<li>
~WHILE［
%位置↗ ~IN { `空白~byte^i }
］
⇒
%位置 ~INCBY 1
◎
Spaces: If the byte at position is one of 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), or 0x20 (SP), then advance position to the next byte, then, repeat this step.
</li>
	<li>
~IF［
%位置↗ ~NEQ `3D^X (`=^bl)
］
⇒
~RET ( %属性~名, 空~文字列 )
◎
If the byte at position is not 0x3D (=), abort the get an attribute algorithm. The attribute's name is the value of attribute name, its value is the empty string.
</li>
	<li>
~WHILE［
%位置↗ ~EQ `3D^X (`=^bl)
］
⇒
%位置↗ ~INCBY 1
◎
Advance position past the 0x3D (=) byte.
</li>
	<li>
`値^i
:
~WHILE［
%位置↗ ~IN { `空白~byte^i }
］
⇒
%位置 ~INCBY 1
◎
Value: If the byte at position is one of 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), or 0x20 (SP), then advance position to the next byte, then, repeat this step.
</li>
	<li>
%属性~値 ~LET 空~文字列
◎
↑</li>
	<li>
<p>
~IF［
%位置↗ ~IN { `22^X (`"^bl), `27^X (`'^bl) }
］：
◎
Process the byte at position as follows:
◎
If it is 0x22 (") or 0x27 (')
</p>
		<ol>
			<li>
%引用符 ~LET %位置↗
◎
Let b be the value of the byte at position.
</li>
			<li>
<p>
~WHILE 無条件：
◎
Quote loop:＼
</p>
				<ol>
					<li>
%位置 ~INCBY 1
◎
Advance position to the next byte.
</li>
					<li>
<p>
~IF［
%位置↗ ~EQ %引用符
］：
</p>
<ol><li>%位置 ~INCBY 1
</li><li>~RET ( %属性~名, %属性~値 )
</li></ol>
◎
If the value of the byte at position is the value of b, then advance position to the next byte and abort the "get an attribute" algorithm. The attribute's name is the value of attribute name, and its value is the value of attribute value.
</li>
					<li>
~ELSE
⇒
%属性~値 ~APPEND ~cp( `~byte小文字~化する$( %位置↗ ) )
◎
Otherwise, if the value of the byte at position is in the range 0x41 (A) to 0x5A (Z), then append a code point to attribute value whose value is 0x20 more than the value of the byte at position.
◎
Otherwise, append a code point to attribute value whose value is the same as the value of the byte at position.
◎
Return to the step above labeled quote loop.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~Assert：
%位置↗ ~NIN { `空白~byte^i }
◎
（これらの段は後続の段で吸収されるので不要）
◎
If it is 0x3E (&gt;)
• Abort the get an attribute algorithm. The attribute's name is the value of attribute name, its value is the empty string.
◎
If it is in the range 0x41 (A) to 0x5A (Z)
• Append a code point b+0x20 to attribute value (where b is the value of the byte at position). Advance position to the next byte.
◎
Anything else
• Append a code point with the same value as the byte at position to attribute value. Advance position to the next byte.
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
<p>
%位置↗ に応じて：
◎
Process the byte at position as follows:
</p>

				<dl class="switch">
					<dt>`空白~byte^i</dt>
					<dt>`3E^X (`&gt;^bl)
◎
If it is 0x09 (HT), 0x0A (LF), 0x0C (FF), 0x0D (CR), 0x20 (SP), or 0x3E (&gt;)
</dt>
					<dd>
~RET ( %属性~名, %属性~値 )
◎
Abort the get an attribute algorithm. The attribute's name is the value of attribute name and its value is the value of attribute value.
</dd>

					<dt>~AnyElse</dt>
					<dd>
%属性~値 ~APPEND ~cp( `~byte小文字~化する$( %位置↗ ) )
◎
If it is in the range 0x41 (A) to 0x5A (Z)
• Append a code point b+0x20 to attribute value (where b is the value of the byte at position).
◎
Anything else
• Append a code point with the same value as the byte at position to attribute value.
</dd>
				</dl>
			</li>
			<li>
%位置 ~INCBY 1
◎
Advance position to the next byte and return to the previous step.
			</li>
		</ol>
	</li>
</ol>
</div>
</div>

<div class="algo">
<p>
`~XML符号化法を取得する@
~algoは、
所与の
( %入力~byte列 )
に対し
（この手続きは、
`~byte~streamを予走査して符号化法を決定する$ ~algoが中止されたとき，適用される）：
◎
When the prescan a byte stream to determine its encoding algorithm is aborted without returning an encoding, get an XML encoding means doing this.
</p>

<p class="note">
~XML宣言を真似ている構文を探し出すことは、
`text/html$mt においても，既存の内容との互換性を得るために必要yである。
◎
Looking for syntax resembling an XML declaration, even in text/html, is necessary for compatibility with existing content.
</p>
<ol>
	<li>
~IF［［
%入力~byte列 の先頭から 5 個までの~byteが成す~byte列
］ ~NEQ ［
`3C^X, `3F^X, `78^X, `6D^X, `6C^X (`&lt;?xml^bl)
］］
⇒
~RET `失敗^i
◎
↓Let encodingPosition be a pointer to the start of the stream.
◎
If encodingPosition does not point to the start of a byte sequence 0x3C, 0x3F, 0x78, 0x6D, 0x6C (`&lt;?xml`), then return failure.
</li>
	<li>
~IF［
%入力~byte列 内に `3E^X (`&gt;^bl) ~byte（~XML宣言~終端）は無い
］
⇒
~RET `失敗^i
◎
Let xmlDeclarationEnd be a pointer to the next byte in the input byte stream which is 0x3E (&gt;). If there is no such byte, then return failure.
</li>
	<li>
~IF［
%入力~byte列 内に~byte列［
`65^X, `6E^X, `63^X, `6F^X, `64^X, `69^X, `6E^X, `67^X (`encoding^bl)
］は無い
］
⇒
~RET `失敗^i
◎
Set encodingPosition to the position of the first occurrence of the subsequence of bytes 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67 (`encoding`) at or after the current encodingPosition. If there is no such sequence, then return failure.
</li>
	<li>
<p>
%位置 ~LET %入力~byte列 内で最初に生じた［
前~段に挙げた~byte列
］の直後を指す位置
— 以下に現れる “%位置↗” は、
`~byte~streamを予走査して符号化法を決定する$ ~algoのそれと同様とする。
◎
↑
◎
Advance encodingPosition past the 0x67 (g) byte.
</p>

<p class="trans-note">【
先頭にある `&lt;?xml^bl と `encoding^bl の間に何が挟まれるかは問われていない
（誤りかも？）。
】</p>

	</li>
	<li>
~WHILE［
%位置↗ ~LTE `20^X
（すなわち，~ASCII［
~space／制御~文字
］）
］
⇒
%位置 ~INCBY 1
◎
While the byte at encodingPosition is less than or equal to 0x20 (i.e., it is either an ASCII space or control character), advance encodingPosition to the next byte.
</li>
	<li>
~IF［
%位置↗ ~NEQ `3D^X (`=^bl)
］
⇒
~RET `失敗^i
◎
If the byte at encodingPosition is not 0x3D (=), then return failure.
</li>
	<li>
%位置 ~INCBY 1
◎
Advance encodingPosition to the next byte.
</li>
	<li>
~WHILE［
%位置↗ ~LTE `20^X
］
⇒
%位置 ~INCBY 1
◎
While the byte at encodingPosition is less than or equal to 0x20 (i.e., it is either an ASCII space or control character), advance encodingPosition to the next byte.
</li>
	<li>
%引用符 ~LET %位置↗
◎
Let quoteMark be the byte at encodingPosition.
</li>
	<li>
~IF［
%引用符 ~NIN { `22^X (`"^bl), `27^X (`'^bl) }
］
⇒
~RET `失敗^i
◎
If quoteMark is not either 0x22 (") or 0x27 ('), then return failure.
</li>
	<li>
%位置 ~INCBY 1
◎
Advance encodingPosition to the next byte.
</li>
	<li>
~IF［
%入力~byte列 内の %位置 より後に %引用符 は無い
］
⇒
~RET `失敗^i
◎
Let encodingEndPosition be the position of the next occurrence of quoteMark at or after encodingPosition. If quoteMark does not occur again, then return failure.
</li>
	<li>
%符号化法かも ~LET %入力~byte列 内の［
%位置 から［
%位置 より後に生じる最初の %引用符 の直前
］まで
］を成す~byte列
◎
Let potentialEncoding be the sequence of the bytes between encodingPosition (inclusive) and encodingEndPosition (exclusive).
</li>
	<li>
~IF［
%符号化法かも を成す ある~byte ~LTE `20^X
］
⇒
~RET `失敗^i
◎
If potentialEncoding contains one or more bytes whose byte value is 0x20 or below, then return failure.
</li>
	<li>
%符号化法 ~LET `~labelから符号化法を取得する$( `同型に復号する$( %符号化法かも ) )
◎
Let encoding be the result of getting an encoding given potentialEncoding isomorphic decoded.
</li>
	<li>
~RET %符号化法 に応じて
⇒＃
`UTF-16BE/LE$enc であるならば `UTF-8$enc ／
~ELSE_ %符号化法
◎
If the encoding is UTF-16BE/LE, then change it to UTF-8.
◎
Return encoding.
</li>
</ol>
</div>

<p>
相互運用能を得るため、
~UAは，上に述べたものと異なる結果を返すような予走査~algoを利用するべきでない。
（もし，そうする場合は、
少なくとも我々に知らしめたし
— 我々がこの~algoを改善して誰もが便益を得られるよう...
）
◎
For the sake of interoperability, user agents should not use a pre-scan algorithm that returns different results than the one described above. (But, if you do, please at least let us know, so that we can improve this algorithm and benefit everyone...)
</p>

				</section>
				<section id="character-encodings">
<h5 title="Character encodings">13.2.3.3. 符号化法</h5>

<p>
~UAは、
`Encoding^cite に定義される各種~符号化法
— 次に挙げるものを含む —
は~supportし，他の符号化法は~supportしないモノトスル
⇒＃
`UTF-8$enc,
`ISO-8859-2$enc,
`ISO-8859-7$enc,
`ISO-8859-8$enc,
`windows-874$enc,
`windows-1250$enc,
`windows-1251$enc,
`windows-1252$enc,
`windows-1254$enc,
`windows-1255$enc,
`windows-1256$enc,
`windows-1257$enc,
`windows-1258$enc,
`GBK$enc,
`Big5$enc,
`ISO-2022-JP$enc,
`Shift_JIS$enc,
`EUC-KR$enc,
`UTF-16BE$enc,
`UTF-16LE$enc,【！`UTF-16BE/LE$enc,】
`x-user-defined$enc
◎
User agents must support the encodings defined in Encoding, including, but not limited to, UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows-1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, GBK, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE, UTF-16BE/LE, and x-user-defined. User agents must not support other encodings.
</p>

<div class="note">
<p>注記：
例えば、
次の~supportは禁制される
`CESU8$r
`UTF7$r
`BOCU1$r
`SCSU$r
⇒＃
`CESU-8^enc,
`UTF-7^enc,
`BOCU-1^enc,
`SCSU^enc,
`EBCDIC^enc,
`UTF-32^enc
</p>

<p>
この仕様は、
禁制されるどの符号化法も，~algo内で~supportしようと試みることはない。
そのような符号化法を~supportしたり利用した場合、
期待されない挙動へ導くことになる。
</p>
◎
The above prohibits supporting, for example, CESU-8, UTF-7, BOCU-1, SCSU, EBCDIC, and UTF-32.＼
This specification does not make any attempt to support prohibited encodings in its algorithms; support and use of prohibited encodings would thus lead to unexpected behavior. [CESU8] [UTF7] [BOCU1] [SCSU]
</div>

				</section>
				<section id="changing-the-encoding-while-parsing">
<h5 title="Changing the encoding while parsing">13.2.3.4. 構文解析-中における符号化法の変更-法</h5>

<p>
構文解析器は、
`符号化法を変更する$よう要求し得る。
これは、
`符号化法を~sniffする~algo$にて，次が生じた場合に起こるかもしれない
⇒＃
符号化法を見出すのに失敗した／
見出された符号化法は ~fileの実際の符号化法でなかった
◎
When the parser requires the user agent to change the encoding, it must run the following steps. This might happen if the encoding sniffing algorithm described above failed to find a character encoding, or if it found a character encoding that was not the actual encoding of the file.
</p>

<div class="algo">
<p>
`符号化法を変更する@
~algoは、
所与の
( %新~符号化法 )
に対し：
◎
↑</p>
<ol>
	<li>
%現~符号化法 ~LET 入力~streamを解釈するために利用していた符号化法
◎
↓</li>
	<li>
<p>
~IF［
%現~符号化法 は `UTF-16BE/LE$enc である
］
⇒＃
`確度$ ~SET `確か^i；
~RET
</p>

<p>
%新~符号化法 は無視する
— それが `UTF-16BE/LE^enc でないならば、
明らかに不正なので。
</p>
◎
If the encoding that is already being used to interpret the input stream is UTF-16BE/LE, then set the confidence to certain and return. The new encoding is ignored; if it was anything but the same encoding, then it would be clearly incorrect.
</li>
	<li>
~IF［
%新~符号化法 は `UTF-16BE/LE$enc である
］
⇒
%新~符号化法 ~SET `UTF-8$enc
◎
If the new encoding is UTF-16BE/LE, then change it to UTF-8.
</li>
	<li>
~IF［
%新~符号化法 ~EQ `x-user-defined$enc
］
⇒
%新~符号化法 ~SET `windows-1252$enc
◎
If the new encoding is x-user-defined, then change it to windows-1252.
</li>
	<li>
<p>
~IF［
%新~符号化法 は %現~符号化法 に一致するか等価である
］
⇒＃
`確度$ ~SET `確か^i；
~RET
◎
If the new encoding is identical or equivalent to the encoding that is already being used to interpret the input stream, then set the confidence to certain and return.＼
</p>

<p>
これは、
次のときに起こる：
◎
This happens when＼
</p>
		<ul>
			<li>
［
~file内に見出された符号化法~情報
］は［
`符号化法を~sniffする~algo$が決定した符号化法
］に合致するとき
◎
the encoding information found in the file matches what the encoding sniffing algorithm determined to be the encoding, and＼
</li>
			<li>
構文解析器が 1 周回~目で［
`符号化法を~sniffする~algo$が的確な符号化法を見出すのに失敗した
］場合の 2 周回~目
◎
in the second pass through the parser if the first pass found that the encoding sniffing algorithm described in the earlier section failed to find the right encoding.
</li>
		</ul>
	</li>
	<li>
<p>
任意選択で
— ~UAは 符号化法を “その場で変更する” ことを~supportするならば：
</p>
		<ol>
			<li>
%~byte列 ~LET この~algoを呼出した時点までに
%現~符号化法 の復号器により変換された，入力~streamを成す~byte列
</li>
			<li>
~IF［
%~byte列 に対する［
%現~符号化法, %新~符号化法
］による~Unicode解釈は同じである
］
⇒＃
`文書$の`符号化法$doc ~SET %新~符号化法；
入力~streamを変換するために利用する符号化法 ~SET %新~符号化法；
`確度$ ~SET `確か^i；
~RET
</li>
		</ol>
◎
If all the bytes up to the last byte converted by the current decoder have the same Unicode interpretations in both the current encoding and the new encoding, and if the user agent supports changing the converter on the fly, then the user agent may change to the new converter for the encoding on the fly. Set the document's character encoding and the encoding used to convert the input stream to the new encoding, set the confidence to certain, and return.
</li>
	<li>
<p>
再度，`文書$を`~navigateする$
— 次に与えるもの以外の入力は，同じに保ったまま
⇒＃
`履歴~取扱い^i ~SET `replace$hH
</p>

<p>
加えて、
今度は`符号化法を~sniffする~algo$は飛ばす
— 代わりに、［
符号化法は %新~符号化法,
`確度$は `確か^i
］に設定する。
◎
Otherwise, restart the navigate algorithm, with historyHandling set to "replace" and other inputs kept the same, but this time skip the encoding sniffing algorithm and instead just set the encoding to the new encoding and the confidence to certain.＼
</p>

<p>
アリな所では，これは、［
~network層に実際に接触することなく行われる
］べきである
（~memoryからの~byte列が，構文解析し直されるべきである）
— 例えば、
当の文書が~cache可能でないものとされていても。
これがアリでないため，［
~network層に接触することが［
`GET$M 以外の~methodを利用する要請を繰返す
］ことを孕む
］ことになる場合、
代わりに［
`確度$ ~SET `確か^i,
%新~符号化法 は無視する
］とする
— 資源は、
誤解釈されることになる。
~UAは、
~app開発を援助するため，利用者にこの状況を通知してもヨイ。
◎
Whenever possible, this should be done without actually contacting the network layer (the bytes should be re-parsed from memory), even if, e.g., the document is marked as not being cacheable. If this is not possible and contacting the network layer would involve repeating a request that uses a method other than `GET`, then instead set the confidence to certain and ignore the new encoding. The resource will be misinterpreted. User agents may notify the user of the situation, to aid in application development.
</p>

	</li>
</ol>

<p class="note">注記：
この~algoが呼出されるのは、［
`meta$e 要素~上に新たな符号化法が宣言されている
］ことが見出されたときに限られる。
◎
This algorithm is only invoked when a new encoding is found declared on a meta element.
</p> 
</div>

				</section>
				<section id="preprocessing-the-input-stream">
<h5 title="Preprocessing the input stream">13.2.3.5. 入力~streamの前処理-法</h5>

<p>
`入力~stream@
は、［
復号された`入力~byte~stream$として, または
入力~streamを直に操作する様々な~APIから
］~pushされてきた一連の文字からなる。
◎
The input stream consists of the characters pushed into it as the input byte stream is decoded or from the various APIs that directly manipulate the input stream.
</p>

<ul>
	<li>
`~surrogate$が生じたときは，常に
`surrogate-in-input-stream$pE
になるとする。
◎
Any occurrences of surrogates are surrogate-in-input-stream parse errors.＼
</li>
	<li>
`非文字$が生じたときは，常に
`noncharacter-in-input-stream$pE
になるとする。
◎
Any occurrences of noncharacters are noncharacter-in-input-stream parse errors and＼
</li>
	<li>
<p>
［
`~ASCII空白$／ `0000^U
］以外の`制御文字$が生じたときは，常に
`control-character-in-input-stream$pE
になるとする。
◎
any occurrences of controls other than ASCII whitespace and U+0000 NULL characters are control-character-in-input-stream parse errors.
</p>

<p class="note">注記：
`0000^U 文字の取扱いは、
構文解析を成す後の段階にて起こり，当の文字が見出された所に基づいて変わる。
それらは無視されるか, ~securityの理由から `FFFD^U に置換される。
そのため、
この取扱いは，［
~token化~段階, ~tree構築~段階
］の両者に散らばっている。
◎
The handling of U+0000 NULL characters varies based on where the characters are found and happens at the later stages of the parsing. They are either ignored or, for security reasons, replaced with a U+FFFD REPLACEMENT CHARACTER. This handling is, by necessity, spread across both the tokenization stage and the tree construction stage.
</p>
	</li>
	<li>
`~token化~段階$に先立って、
入力~streamは，`改行文字を正規化する$モノトスル。
したがって，~HTML~DOM内では、
すべての改行文字は `000A^U で表現され，
`000D^U は`~token化~段階$には決して入力されない。
◎
Before the tokenization stage, the input stream must be preprocessed by normalizing newlines. Thus, newlines in HTML DOMs are represented by U+000A LF characters, and there are never any U+000D CR characters in the input to the tokenization stage.
</li>
</ul>

<p>
`次回の入力~文字@
は、
`入力~stream$内の［
まだ
<dfn>消費-</dfn>
されていない, かつ
この節の要件により明示的に無視されていない
【！ not X or Y = not ( X or Y ) 】
］文字のうち，最初のものを指す。
初期~時の`次回の入力~文字$は、
入力を成す最初の文字とする
【入力が空である場合、下に述べる ~EOF になる】
。
`現在の入力~文字@
は、
最後に `消費-^i された文字とする。
◎
The next input character is the first character in the input stream that has not yet been consumed or explicitly ignored by the requirements in this section. Initially, the next input character is the first character in the input. The current input character is the last character to have been consumed.
</p>


<p>
`挿入~地点@
は、［
ある文字 ／ 入力~streamの終端
］の直前を指す位置であり、
`document.write()$c を利用して挿入される内容が実際に挿入される所である。
挿入~地点は、［
その直後の文字の位置
］に相対的であり、
入力~streamの中を指す絶対的~offsetではない。
挿入~地点は、
初期~時は ε （未定義）とする。
◎
The insertion point is the position (just before a character or just before the end of the input stream) where content inserted using document.write() is actually inserted. The insertion point is relative to the position of the character immediately after it, it is not an absolute offset into the input stream. Initially, the insertion point is undefined.
</p>

<p>
以下における記号 ~EOF は、
`入力~stream$の終端を表現する概念的な文字であり，文字が消費され尽くしたことを表す。
構文解析器が`~scriptにより作成された＠~HTMLdynamic#script-created-parser$ものである場合、
`入力~stream$は
`明示的な~EOF@
で終端する
（これは、
`document.close()$c ~methodにより挿入される）。
◎
The "EOF" character in the tables below is a conceptual character representing the end of the input stream. If the parser is a script-created parser, then the end of the input stream is reached when an explicit "EOF" character (inserted by the document.close() method) is consumed. Otherwise, the "EOF" character is not a real character in the stream, but rather the lack of any further characters.
</p>

				</section>
			</section>
			<section id="parse-state">
<h4 title="Parse state">13.2.4. 構文解析-状態</h4>

				<section id="the-insertion-mode">
<h5 title="The insertion mode">13.2.4.1. 挿入~mode</h5>


<div class="p">
<p>
`挿入~mode@
は，状態~変数であり、
~tree構築~段階の首な演算を制御する。
それは、
~tokenがどう処理されるか, および
`~CDATAsec$は~supportされるかどうかに影響し、
構文解析の~~進行に伴い，`~tree構築~段階$の中で次に挙げるいずれかに変化し得る：
</p>

<ul ><li>`初期$md — これが、初期~時の`挿入~mode$
</li><li>`~htmlの前$md
</li><li>`~headの前$md
</li><li>`~head内$md
</li><li>`~head~noscript内$md
</li><li>`~headの後$md
</li><li>`~body内$md
</li><li>`~text$md
</li><li>`~table内$md
</li><li>`~table~text内$md
</li><li>`~caption内$md
</li><li>`~col~group内$md
</li><li>`~table~body内$md
</li><li>`~row内$md
</li><li>`~cell内$md
</li><li>`~template内$md
</li><li>`~bodyの後$md
</li><li>`~frameset内$md
</li><li>`~framesetの後$md
</li><li>`~bodyの後の後$md
</li><li>`~framesetの後の後$md
</li></ul>

◎
The insertion mode is a state variable that controls the primary operation of the tree construction stage.
◎
Initially, the insertion mode is "initial". It can change to "before html", "before head", "in head", "in head noscript", "after head", "in body", "text", "in table", "in table text", "in caption", "in column group", "in table body", "in row", "in cell", "in template", "after body", "in frameset", "after frameset", "after after body", and "after after frameset" during the course of the parsing, as described in the tree construction stage. The insertion mode affects how tokens are processed and whether CDATA sections are supported.
</div>

<p>
これらの`挿入~mode$のうち［
`~head内$md ／ `~body内$md ／ `~table内$md 【／ `~template内$md 】
］は、
他の~modeが様々な時点で これらの~modeへ先送りする点で特別である
— すなわち，以下の~algoにて、
ここに挙げたいずれかの~mode %m に対し，
<q>%m
`用の規則を利用して@
%何か を行う</q>
と記される所では、
~UAは， %m `挿入~mode$の節に述べる規則を利用するモノトスル
— %m 内の規則~自身が`挿入~mode$を他の~modeへ切替えない限り、
`挿入~mode$は変更することなく。
◎
Several of these modes, namely "in head", "in body", and "in table", are special, in that the other modes defer to them at various times. When the algorithm below says that the user agent is to do something "using the rules for the m insertion mode", where m is one of these modes, the user agent must use the rules described under the m insertion mode's section, but must leave the insertion mode unchanged unless the rules in m themselves switch the insertion mode to a new value.
</p>

<p>
挿入~modeが［
`~text$md ／ `~table~text内$md
］に切替えられるときは、
`元の挿入~mode@V
も設定される。
これは、
~tree構築~段階が後で戻ることになる，挿入~modeを指す。
◎
When the insertion mode is switched to "text" or "in table text", the original insertion mode is also set. This is the insertion mode to which the tree construction stage will return.
</p>

<p>
同様に，入子な `template$e 要素を構文解析するときには、
`~template挿入~mode~stack@
が利用される
— それは`挿入~mode$たちが成す`~stack$であり†，初期~時は空とする。
◎
Similarly, to parse nested template elements, a stack of template insertion modes is used. It is initially empty. The current template insertion mode is the insertion mode that was most recently added to the stack of template insertion modes. The algorithms in the sections below will push insertion modes onto this stack, meaning that the specified insertion mode is to be added to the stack, and pop insertion modes from the stack, which means that the most recently added insertion mode must be removed from the stack.
</p>

<p class="trans-note" id="current-template-insertion-mode">【†
この訳では `Infra$r による`~stack$の定義を参照して、
原文の記述を簡約している。
】</p>

<hr>

<div class="algo">
<p>
`挿入~modeを適切に設定し直す@
~algoは
⇒
`挿入~mode$ ~SET 次の手続きを遂行した結果：
◎
When the steps below require the UA to reset the insertion mode appropriately, it means the UA must follow these steps:
</p>
<ol>
	<li>
%~stack ~LET `~open要素~stack$
◎
↓</li>
	<li>
~Assert：
%~stack は空でない
◎
↓</li>
	<li>
%最後か ~LET ~F
◎
Let last be false.
</li>
	<li>
<p>
%~stack を成す
~EACH( %~node )
に対し，末尾から順に：
◎
Let node be the last node in the stack of open elements.
</p>
		<ol>
			<li>
<p>
~IF［
%~node は %~stack の先頭にある~nodeである
］：
</p>
		<ol>
			<li>
%最後か ~SET ~T
</li>
			<li>
~IF［
%構文解析器 は`~HTML素片~用$である
（`素片~事例$）
］
⇒
%~node ~SET その~algoに渡された `文脈$V
</li>
		</ol>

◎
Loop: If node is the first node in the stack of open elements, then set last to true, and, if the parser was created as part of the HTML fragment parsing algorithm (fragment case), set node to the context element passed to that algorithm.
</li>
			<li>
<p>
%~node の型に応じて：
◎
↓</p>
				<dl class="switch">
					<dt>`td$e</dt>
					<dt>`th$e</dt>
					<dd>
~IF［
%最後か ~EQ ~F
］
⇒
~RET `~cell内$md
◎
If node is a td or th element and last is false, then switch the insertion mode to "in cell" and return.
</dd>

					<dt>`tr$e</dt>
					<dd>
~RET `~row内$md
◎
If node is a tr element, then switch the insertion mode to "in row" and return.
</dd>

					<dt>`tbody$e</dt>
					<dt>`thead$e</dt>
					<dt>`tfoot$e</dt>
					<dd>
~RET `~table~body内$md
◎
If node is a tbody, thead, or tfoot element, then switch the insertion mode to "in table body" and return.
</dd>

					<dt>`caption$e</dt>
					<dd>
~RET `~caption内$md
◎
If node is a caption element, then switch the insertion mode to "in caption" and return.
</dd>

					<dt>`colgroup$e</dt>
					<dd>
~RET `~col~group内$md
◎
If node is a colgroup element, then switch the insertion mode to "in column group" and return.
</dd>

					<dt>`table$e</dt>
					<dd>
~RET `~table内$md
◎
If node is a table element, then switch the insertion mode to "in table" and return.
</dd>

					<dt>`template$e</dt>
					<dd>
~RET `~template挿入~mode~stack$を成す最後の~item
◎
If node is a template element, then switch the insertion mode to the current template insertion mode and return.
</dd>

					<dt>`head$e</dt>
					<dd>
~IF［
%最後か ~EQ ~F
］
⇒
~RET `~head内$md
◎
If node is a head element and last is false, then switch the insertion mode to "in head" and return.
</dd>

					<dt>`body$e</dt>
					<dd>
~RET `~body内$md
◎
If node is a body element, then switch the insertion mode to "in body" and return.
</dd>

					<dt>`frameset$e（`素片~事例$）</dt>
					<dd>
~RET `~frameset内$md
◎
If node is a frameset element, then switch the insertion mode to "in frameset" and return. (fragment case)
</dd>

					<dt>`html$e</dt>
					<dd>
~RET ［
`~head要素~pointer$ ~EQ ~NULL（`素片~事例$）ならば `~headの前$md ／
~ELSE_ `~headの後$md
］
◎
If node is an html element, run these substeps:
◎
If the head element pointer is null, switch the insertion mode to "before head" and return. (fragment case)
◎
Otherwise, the head element pointer is not null, switch the insertion mode to "after head" and return.
</dd>
				</dl>
			</li>
			<li>
~IF［
%最後か ~EQ ~T
（`素片~事例$）
］
⇒
~RET `~body内$md
◎
If last is true, then switch the insertion mode to "in body" and return. (fragment case)
◎
Let node now be the node before node in the stack of open elements.
◎
Return to the step labeled loop.
</li>
		</ol>
	</li>
</ol>
</div>

				</section>
				<section id="the-stack-of-open-elements">
<h5 title="The stack of open elements">13.2.4.2. ~open要素~stack</h5>

<p>
`~open要素~stack@
は、
初期~時は空とする。
この~stackは、
末尾側（ `downward^en† ）へ成長する
— ~stackの先頭にある~nodeは，~stackに最初に追加されたものであり、
~stackの末尾にある~nodeは，~stackに最も近過去に追加されたものである
（`誤入子な~tagを取扱う＠#adoptionAgency$一部として，
~stackが~random~access的に操作されたときであっても）。
◎
Initially, the stack of open elements is empty. The stack grows downwards; the topmost node on the stack is the first one added to the stack, and the bottommost node of the stack is the most recently added node in the stack (notwithstanding when the stack is manipulated in a random access fashion as part of the handling for misnested tags).
</p>

<p class="trans-note">【†
この語 `downward^en, および原文に現れる［
`bottommost, bottom ／ topmost, top ／ lower^en
］などの語は、［
この~stackが表現する，~nodeたちが成す入子ng
］の “深さ” を意図して用いられているが、
この訳では，一律に，通例的な~listにおける順序関係を表す語
（先頭, 〜のうち最初の, 末尾, 〜のうち最後の, 〜より後, 〜より前）
で表記する。
~stackの `bottom^en や `top^en が［
~listとしての~stack
］の［
先頭, 末尾
］どちらかを指すか直感的でないことに加え、
原文には，これら~list用の
（ `first, last, after, before^en ）
も混用されていて，惑わされるので。
】</p>

<p class="note">注記：
`挿入~mode$ `~htmlの前$mdでは、
`html$e `文書~要素$が作成され，~stackに追加される。
◎
The "before html" insertion mode creates the html document element, which is then added to the stack.
</p>

<p class="note">注記：
`素片~事例$においては、
`~open要素~stack$は，［
`~HTML素片の構文解析~algo$の一部として作成された `html$e 要素
］を包含するように初期化される
（`素片~事例$は`~htmlの前$md `挿入~mode$を飛ばす）。
◎
In the fragment case, the stack of open elements is initialized to contain an html element that is created as part of that algorithm. (The fragment case skips the "before html" insertion mode.)
</p>

<p>
`html$e ~nodeは、
どう作成されたものであれ，~stackの先頭にある~nodeになる。
それが~stackから~popされるのは、
構文解析器が`完遂した＠#stop-parsing$ときに限られる。
◎
The html node, however it is created, is the topmost node of the stack. It only gets popped off the stack when the parser finishes.
</p>

<p>
`現在の~node@
は、
この`~open要素~stack$の末尾にある~nodeを指す。
◎
The current node is the bottommost node in this stack of open elements.
</p>

<p>
`現在の調整-済み~node@
は、［
%構文解析器 は`~HTML素片~用$であって
`~open要素~stack$は唯一の要素からなる（`素片~事例$）ならば `文脈$V ／
~ELSE_ `現在の~node$
］を指す。
◎
The adjusted current node is the context element if the parser was created as part of the HTML fragment parsing algorithm and the stack of open elements has only one element in it (fragment case); otherwise, the adjusted current node is the current node.
</p>

<p>
`~open要素~stack$から`現在の~node$ %~node が除去されたときは
⇒
`内部~資源~link群を処理する$( %~node の`~node文書$ )
◎
When the current node is removed from the stack of open elements, process internal resource links given the current node's node document.
</p>

<p>
`~open要素~stack$内の各 要素は、
次に挙げるいずれかに分類される：
◎
Elements in the stack of open elements fall into the following categories:
</p>

<dl class="def-list">
	<dt>
`特別な要素@
◎
Special
</dt>
	<dd>
<p>
次に挙げる要素~型には、
様々な~levelの特別な構文解析~規則がある：
</p>
		<dl>
			<dt>
~HTMLの：
</dt>
			<dd>
`address$e,
`applet$e,
`area$e,
`article$e,
`aside$e,
`base$e,
`basefont$e,
`bgsound$e,
`blockquote$e,
`body$e,
`br$e,
`button$e,
`caption$e,
`center$e,
`col$e,
`colgroup$e,
`dd$e,
`details$e,
`dir$e,
`div$e,
`dl$e,
`dt$e,
`embed$e,
`fieldset$e,
`figcaption$e,
`figure$e,
`footer$e,
`form$e,
`frame$e,
`frameset$e,
`h1$e,
`h2$e,
`h3$e,
`h4$e,
`h5$e,
`h6$e,
`head$e,
`header$e,
`hgroup$e,
`hr$e,
`html$e,
`iframe$e,
`img$e,
`input$e,
`keygen$e,
`li$e,
`link$e,
`listing$e,
`main$e,
`marquee$e,
`menu$e,
`meta$e,
`nav$e,
`noembed$e,
`noframes$e,
`noscript$e,
`object$e,
`ol$e,
`p$e,
`param$e,
`plaintext$e,
`pre$e,
`script$e,
`search$e,
`section$e,
`select$e,
`source$e,
`style$e,
`summary$e,
`table$e,
`tbody$e,
`td$e,
`template$e,
`textarea$e,
`tfoot$e,
`th$e,
`thead$e,
`title$e,
`tr$e,
`track$e,
`ul$e,
`wbr$e,
`xmp$e
</dd>

			<dt>
~MathMLの：
</dt>
			<dd>
`mi$e,
`mo$e,
`mn$e,
`ms$e,
`mtext$e,
`annotation-xml$e
</dd>

			<dt>
~SVGの：
</dt>
			<dd>
`foreignObject$e,
`desc$e,
`~title0$e
</dd>
		</dl>
◎
The following elements have varying levels of special parsing rules:＼
HTML's address, applet, area, article, aside, base, basefont, bgsound, blockquote, body, br, button, caption, center, col, colgroup, dd, details, dir, div, dl, dt, embed, fieldset, figcaption, figure, footer, form, frame, frameset, h1, h2, h3, h4, h5, h6, head, header, hgroup, hr, html, iframe, img, input, keygen, li, link, listing, main, marquee, menu, meta, nav, noembed, noframes, noscript, object, ol, p, param, plaintext, pre, script, search, section, select, source, style, summary, table, tbody, td, template, textarea, tfoot, th, thead, title, tr, track, ul, wbr, xmp;＼
MathML mi, MathML mo, MathML mn, MathML ms, MathML mtext, and MathML annotation-xml; and＼
SVG foreignObject, SVG desc, and SVG title.
</dd>
	<dd class="note">注記：
`image^c 開始~tag~tokenは，~tree構築器により取扱われるが、
それは要素ではないので，この~listには含まれない
— それは、
`img$e 要素に転換される。
◎
An image start tag token is handled by the tree builder, but it is not in this list because it is not an element; it gets turned into an img element.
</dd>

	<dt>`整形~要素@
◎
Formatting
</dt>
	<dd>
次に挙げる~HTML要素は、
`作動中な整形~要素~list$内に加えられることになる
⇒
`a$e,
`b$e,
`big$e,
`code$e,
`em$e,
`font$e,
`i$e,
`nobr$e,
`s$e,
`small$e,
`strike$e,
`strong$e,
`tt$e,
`u$e
◎
The following HTML elements are those that end up in the list of active formatting elements: a, b, big, code, em, font, i, nobr, s, small, strike, strong, tt, and u.
</dd>

	<dt>`普通の要素@
◎
Ordinary
</dt>
	<dd>
~HTML文書を構文解析している間に見出された，他のすべての要素。
◎
All other elements found while parsing an HTML document.
</dd>
</dl>

<p class="note">注記：
`特別な要素$の［
開始~tag ／ 終了~tag
］~tokenは、
概して，特定の~~分岐で取扱われる一方で、
`普通の要素$の~tokenは、［
“その他の開始~tag” ／ “その他の終了~tag”
］と記される~~分岐に仕分けられる。
また，~tree構築器には、［
`~open要素~stack$内の特定0の要素が`特別$である
］かどうか検査する箇所がいくつかある。
［
開始~tag ／ 終了~tag
］~tokenが特定の~~分岐で取扱われる要素は，他にもあるが（例： `option$e 要素）、
他所では`普通の要素$として取扱われるので，`特別$とされない。
◎
Typically, the special elements have the start and end tag tokens handled specifically, while ordinary elements' tokens fall into "any other start tag" and "any other end tag" clauses, and some parts of the tree builder check if a particular element in the stack of open elements is in the special category. However, some elements (e.g., the option element) have their start or end tag tokens handled specifically, but are still not in the special category, so that they get the ordinary handling elsewhere.
</p>

<div class="algo">
<div class="p">
<p>
`~open要素~stack$において，特定の
`視野~内@
に ある条件を満たす要素が `在る^i とは、
所与の：
</p>

<ol >
	<li>
<p>
視野を与える要素~型たちが成す集合 %S
</p>
<p class="trans-note">【
要素~型は、
( 要素の~tag名, 要素が属する名前空間) 
の組であることに注意。
名前空間が明示的に指定されていないものは、
`~HTML名前空間に属する＠#_notes-on-element-type$。
】</p>

	</li>
	<li>
<p>
条件 %~target条件
— ここで、
条件として：
</p>
		<ul>
			<li>
要素~型（または それらが成す集合）が与えられた場合、
条件は “その（いずれかの）要素~型である” と解釈する。
</li>
			<li>
ある要素~instanceが与えられた場合、
条件は “その要素と同じ~instance” と解釈する。
</li>
		</ul>
	</li>
</ol>

<p>
に対し，［
次の~algoを走らせた結果 ~EQ `在る^i 
］になることを意味する。
`視野~内$に `無い^i は、
その否定を意味する：
</p>

◎
The stack of open elements is said to have an element target node in a specific scope consisting of a list of element types list when the following algorithm terminates in a match state:
</div>

<ol>
	<li>
~Assert：
`html$e ~IN %S
◎
↓</li>
	<li>
<p>
`~open要素~stack$を成す
~EACH( %~node )
に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
		<ol>
			<li>
~IF［
%~node は %~target条件 を満たす
］
⇒
~RET `在る^i
◎
If node is target node, terminate in a match state.
</li>
			<li>
~IF［
%~node の要素~型 ~IN %S
］
⇒
~RET `無い^i
◎
Otherwise, if node is one of the element types in list, terminate in a failure state.
</li>
		</ol>
	</li>
	<li>
~Assert：
~stackの先頭は `html$e 要素なので、
この段に達することは決してない
◎
Otherwise, set node to the previous entry in the stack of open elements and return to step 2. (This will never fail, since the loop will always terminate in the previous step if the top of the stack — an html element — is reached.)
</li>
</ol>
</div>

<p>
上の “`視野~内$” 手続きに与える要素~型たちが成す集合 %S として、
次に挙げるものが定義される：
<!-- 
（
“%要素 は %X 視野~内” にあるとは、
%要素 ~IN %S ではなく
%要素 は %S の`視野~内$にあることを意味することに注意）
 -->
◎
↑↓</p>

<dl class="def-list">
	<dt>
`既定の視野@
◎
The stack of open elements is said to have a particular element in scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`applet$e,
`caption$e,
`html$e,
`table$e,
`td$e,
`th$e,
`marquee$e,
`object$e,
`select$e,
`template$e
◎
applet
caption
html
table
td
th
marquee
object
select
template
</dd>
	<dd>
`~MathML名前空間$に属する，次に挙げる要素~型
⇒
`mi$e,
`mo$e,
`mn$e,
`ms$e,
`mtext$e,
`annotation-xml$e
◎
MathML mi
MathML mo
MathML mn
MathML ms
MathML mtext
MathML annotation-xml
</dd>
	<dd>
`~SVG名前空間$に属する，次に挙げる要素~型
⇒
`foreignObject$e,
`desc$e,
`~title0$e
◎
SVG foreignObject
SVG desc
SVG title
</dd>

	<dt>
`~list~item視野@
◎
The stack of open elements is said to have a particular element in list item scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`既定の視野$
◎
All the element types listed above for the has an element in scope algorithm.
</dd>
	<dd>
`ol$e,`ul$e
◎
ol in the HTML namespace
◎
ul in the HTML namespace
</dd>

	<dt>
`~button視野@
◎
The stack of open elements is said to have a particular element in button scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`既定の視野$
◎
All the element types listed above for the has an element in scope algorithm.
</dd>
	<dd>
`button$e
◎
button in the HTML namespace
</dd>

	<dt>
`~table視野@
◎
The stack of open elements is said to have a particular element in table scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`html$e,
`table$e,
`template$e
◎
html in the HTML namespace
◎
table in the HTML namespace
◎
template in the HTML namespace
</dd>
</dl>

<p>
どの時点であれ、
`~open要素~stack$内の要素が，`文書$を成す~tree内の他所へ移動されても, あるいは~treeから除去されても，~~特別な何かが起こることはない
— 特に、
この状況においても，~stackは変更されない。
その結果、
もはや~DOM内にない~nodeに内容が付加されることもある
— 変則的な効果は他にもあるが。
◎
Nothing happens if at any time any of the elements in the stack of open elements are moved to a new location in, or removed from, the Document tree. In particular, the stack is not changed in this situation. This can cause, amongst other strange effects, content to be appended to nodes that are no longer in the DOM.
</p>

<p class="note">注記：
一部の事例では
（すなわち，`誤入子な整形~要素を閉じるとき＠#adoptionAgency$は）、
~stackは~random~access的に操作される。
◎
In some cases (namely, when closing misnested formatting elements), the stack is manipulated in a random-access fashion.
</p>

				</section>
				<section id="the-list-of-active-formatting-elements">
<h5 title="The list of active formatting elements">13.2.4.3. 作動中な整形~要素たちが成す~list</h5>

<p>
`作動中な整形~要素~list@
は、
誤入子な`整形~要素$~tagを取扱うために利用される。
初期~時は空とする。
◎
Initially, the list of active formatting elements is empty. It is used to handle mis-nested formatting element tags.
</p>

<p>
この~listは、［
`整形~要素$／`~marker$
］たちを包含する。
`~marker@
は、［
`applet$e ／ `object$e ／ `marquee$e ／ `template$e ／ `td$e ／ `th$e ／ `caption$e
］要素に入るとき挿入され，［
整形が，これらの要素の`中へ^em “漏れる”
］のを防ぐために利用される。
◎
The list contains elements in the formatting category, and markers. The markers are inserted when entering applet, object, marquee, template, td, th, and caption elements, and are used to prevent formatting from "leaking" into applet, object, marquee, template, td, th, and caption elements.
</p>

<p>
加えて、
`作動中な整形~要素~list$内の各~要素には，それを
`作成させた~token@
が結付けられる
— 必要yなら，その~token用の要素を更に作成できるよう。
◎
In addition, each element in the list of active formatting elements is associated with the token for which it was created, so that further elements can be created for that token if necessary.
</p>

<div class="algo">
<p>
`作動中な整形~要素~listに~pushする@
~algoは、
所与の
( `整形~要素$ %整形~要素 )
に対し：
◎
When the steps below require the UA to push onto the list of active formatting elements an element element, the UA must perform the following steps:
</p>

<ol id="noah">
	<li>
%~list ~LET `作動中な整形~要素~list$
◎
↓</li>
	<li>
<div class="p">

<p>
~IF［
%~list 内に ~AND↓ を満たす要素が 3 個~以上~在る
］…
</p>
		<ul>
			<li>
%整形~要素 と同じ［
~tag名, 名前空間, 属性たち
］を有する
</li>
			<li>
%~list 内には，要素より前に`~marker$は無い
</li>
		</ul>
◎
If there are already three elements in the list of active formatting elements after the last marker, if any, or anywhere in the list if there are no markers, that have the same tag name, namespace, and attributes as element, then＼
</div>

<p>
…ならば
⇒
該当する要素のうち， %~list 内で最初のものを %~list から除去する
◎
remove the earliest such element from the list of active formatting elements.＼
</p>

<p>
この段の目的においては：
◎
For these purposes,＼
</p>
		<ul>
			<li>
各~属性を比較するときは、
要素が %構文解析器 により作成された時点のものを利用するモノトスル。
◎
the attributes must be compared as they were when the elements were created by the parser;＼
</li>
			<li>
2 つの要素が同じ属性たちを有するとは、
互いのどの属性も［
名前, 名前空間, 値
］が一致するよう対にできることを意味する
（属性の順序は問わない）。
◎
two elements have the same attributes if all their parsed attributes can be paired such that the two attributes in each pair have identical names, namespaces, and values (the order of the attributes does not matter).
</li>
		</ul>

<p class="note">注記：
これがノアの方舟（ `Noah's Ark^en ）条項である
— 各組は、
つがいではなく，三つ組だが。
◎
This is the Noah's Ark clause. But with three per family instead of two.
</p>
	</li>
	<li>
%~list に %整形~要素 を追加する
◎
Add element to the list of active formatting elements.
</li>
</ol>
</div>

<div class="algo">
<p>
`作動中な整形~要素たちを構築し直す@
~algoは：
◎
When the steps below require the UA to reconstruct the active formatting elements, the UA must perform the following steps:
</p>

<ol>
	<li>
%~list ~LET `作動中な整形~要素~list$
◎
↓</li>
	<li>
%開始~entry ~LET ε
◎
↓</li>
	<li>
<p>
%~list を成す
~EACH( %~entry )
に対し，最後の（最も近過去に追加された）~entryから順に：
</p>
		<ol>
			<li>
~IF［
%~entry は`~marker$である
］~OR［
%~entry ~IN `~open要素~stack$
］
⇒
~BREAK
</li>
			<li>
%開始~entry ~SET %~entry
</li>
		</ol>

◎
If there are no entries in the list of active formatting elements, then there is nothing to reconstruct; stop this algorithm.
◎
If the last (most recently added) entry in the list of active formatting elements is a marker, or if it is an element that is in the stack of open elements, then there is nothing to reconstruct; stop this algorithm.
◎
Let entry be the last (most recently added) element in the list of active formatting elements.
◎
Rewind: If there are no entries before entry in the list of active formatting elements, then jump to the step labeled create.
◎
Let entry be the entry one earlier than entry in the list of active formatting elements.
◎
If entry is neither a marker nor an element that is also in the stack of open elements, go to the step labeled rewind.
◎
Advance: Let entry be the element one later than entry in the list of active formatting elements.
</li>
	<li>
~IF［
%開始~entry ~EQ ε
］
⇒
~RET
— 構築し直すものは何もない
◎
↑</li>
	<li>
%~list 内の %開始~entry 以降の
~EACH( %~entry )
に対し， %開始~entry から順に
⇒
%~list 内の %~entry を次の結果に置換する
⇒
`~HTML要素を挿入する$( %~entry を`作成させた~token$ )
◎
Create: Insert an HTML element for the token for which the element entry was created, to obtain new element.
◎
Replace the entry for entry in the list with an entry for new element.
◎
If the entry for new element in the list of active formatting elements is not the last entry in the list, return to the step labeled advance.
</li>
</ol>
</div>

<p>
これにより、［
次に該当する要素のうち，まだ明示的に閉じられてないもの
］すべては，再び開かれることになる
⇒
現在の［［
`body^e, `cell^e, `caption^e
］のうち，最も近過去なもの
］内で開かれた整形~要素。
◎
This has the effect of reopening all the formatting elements that were opened in the current body, cell, or caption (whichever is youngest) that haven't been explicitly closed.
</p>

<p class="note">注記：
この仕様は、［
`作動中な整形~要素~list$を成す要素たちの順序は，常に時系列順になる
（最も近過去に追加された要素が最後になる）
］ように書かれている。
【！  except for while steps 7... 】
◎
The way this specification is written, the list of active formatting elements always consists of elements in chronological order with the least recently added element first and the most recently added element last (except for while steps 7 to 10 of the above algorithm are being executed, of course).
</p>

<div class="algo">
<p>
`作動中な整形~要素~listを最後の~markerまで~clearする@
~algoは：
◎
When the steps below require the UA to clear the list of active formatting elements up to the last marker, the UA must perform the following steps:
</p>

<ol>
	<li>
<p>
`作動中な整形~要素~list$ %~list を成す
~EACH( %~entry )
に対し，最後の（最も近過去に追加された）~entryから順に：
◎
Let entry be the last (most recently added) entry in the list of active formatting elements.
</p>
		<ol>
			<li>
%~list から %~entry を除去する
◎
Remove entry from the list of active formatting elements.
</li>
			<li>
~IF［
%~entry は`~marker$である
］
⇒
~BREAK
◎
If entry was a marker, then stop the algorithm at this point. The list has been cleared up to the last marker.
◎
Go to step 1.
</li>
		</ol>
	</li>
</ol>
</div>

				</section>
				<section id="the-element-pointers">
<h5 title="The element pointers">13.2.4.4. 要素を指す~pointer</h5>

<dl class="def-list">
	<dt>`~head要素~pointer@</dt>
	<dd>
初期~時は ~NULL とする。
◎
Initially, the head element pointer and the form element pointer are both null.
</dd>
	<dd>
`head$e 要素が（暗黙的／明示的いずれにせよ）構文解析された時点で，その~nodeを指すよう設定される。
◎
Once a head element has been parsed (whether implicitly or explicitly) the head element pointer gets set to point to this node.
</dd>

	<dt>`~form要素~pointer@</dt>
	<dd>
初期~時は ~NULL とする。
◎
↑</dd>
	<dd>
［
開かれている `form$e 要素
］のうち，まだ終了~tagには出くわしてないもの
］のうち，最後のものを指す。
◎
The form element pointer points to the last form element that was opened and whose end tag has not yet been seen.＼
</dd>
	<dd>
これは、
歴史的な理由から、ひどく不良な~markupに面したとき，
~form~controlを~formに所有させるために利用される。
◎
It is used to make form controls associate with forms in the face of dramatically bad markup, for historical reasons.＼
</dd>
	<dd>
これは、
`template$e 要素の内側では無視される。
◎
It is ignored inside template elements.
</dd>
</dl>


				</section>
				<section id="other-parsing-state-flags">
<h5 title="Other parsing state flags">13.2.4.5. 他の構文解析~状態~flag</h5>

<dl class="def-list">
	<dt>`~scripting~flag@</dt>
	<dd>
%構文解析器 が作成された時点で、［
次が満たされるならば `可能化^i ／
~ELSE_ `不能化^i
］に設定される
⇒
%構文解析器 に結付けられた`文書$用の`~scriptingは可能化されて$いる
◎
The scripting flag is set to "enabled" if scripting was enabled for the Document with which the parser is associated when the parser was created, and "disabled" otherwise.
</dd>
	<dd class="note">注記：
`~scripting~flag$は、
%構文解析器 が`~HTML素片~用$であるときでも，可能化され得る
— その事例では `script$e 要素は実行しないが。
◎
The scripting flag can be enabled even when the parser was created as part of the HTML fragment parsing algorithm, even though script elements don't execute in that case.
</dd>

	<dt>`~frameset-ok~flag@</dt>
	<dd>
%構文解析器 の作成-時には `ok^i に設定される。
ある種の~tokenに出くわしたとき，`not-ok^i になる。
◎
The frameset-ok flag is set to "ok" when the parser is created. It is set to "not ok" after certain tokens are seen.
</dd>
</dl>

				</section>
			</section>
			<section id="tokenization">
<h4 title="Tokenization">13.2.5. ~token化</h4>

<p>
実装は、
~HTMLを~token化するときには，
以下に述べる状態~機械を利用したかのように動作するモノトスル
— この状態~機械は：
◎
Implementations must act as if they used the following state machine to tokenize HTML.＼
</p>

<ul>
	<li>
`~data$stから開始するモノトスル。
◎
The state machine must start in the data state.＼
</li>
	<li>
ほとんどの`状態$は，文字を 1 個だけ消費するが、
様々な副作用を備えるものもある。
また、
状態~機械を新たな`状態$に切替えて［
`現在の入力~文字$を`消費し直す$／`次回の入力~文字$を消費する
］か，
同じ`状態$に留まって次回の文字を消費する。
◎
Most states consume a single character, which may have various side-effects, and either switches the state machine to a new state to reconsume the current input character, or switches it to a new state to consume the next character, or stays in the same state to consume the next character.＼
</li>
	<li>
一部の`状態$では、
別の`状態$に`切替える$前に何個かの文字を消費するよう，より複雑に挙動する。
◎
Some states have more complicated behavior and can consume several characters before switching to another state.＼
</li>
	<li>
一部の事例では、
~tokenizerの`状態$は，~tree構築~段階の中でも変更される。
◎
In some cases, the tokenizer state is also changed by the tree construction stage.
</li>
</ul>

<div class="p">
<p>
ある`状態$の下で，別の`状態$ %S を指定した上で：
</p>

<ul>
	<li>
%S に
`切替える@
と記された所では、
以降に消費する文字は %S の下で取扱うことを意味する。
</li>
	<li>
（直前に消費した文字を）
“%S 内で
`消費し直す@
”
と記された所では、
%S に`切替える$ことに加え、
`次回の入力~文字$を消費しようと試みるときには，
代わりに`現在の入力~文字$を %S に供することを意味する。
</li>
</ul>

◎
When a state says to reconsume a matched character in a specified state, that means to switch to that state, but when it attempts to consume the next input character, provide it with the current input character instead.
</div>


<div class="p">
<p>
ある種の`状態$においては：
</p>
<ul>
	<li>
その正確な挙動は［
`挿入~mode$, `~open要素~stack$
］に依存する。
</li>
	<li>
進捗-を追跡するために
`一時~buffer@V
も利用する。
</li>
	<li>
`文字~参照$stは、
それを呼出した`状態$へ戻るために
`戻先~状態@V
を利用する。
</li>
</ul>

◎
The exact behavior of certain states depends on the insertion mode and the stack of open elements. Certain states also use a temporary buffer to track progress, and the character reference state uses a return state to return to the state it was invoked from.
</div>


<p>
~token化~段の出力は、
0 個~以上の~tokenからなる。
各~tokenは、
次に挙げるいずれかになる：
◎
The output of the tokenization step is a series of zero or more of the following tokens: DOCTYPE, start tag, end tag, comment, character, end-of-file.＼
</p>

<dl class="def-list">
	<dt>~DOCTYPE~token</dt>
	<dd>
<p>
それぞれが次に挙げるものを有する
— 作成-時には括弧内に与える値になるモノトスル：
</p>

<ul><li>名前（ ε ）
</li><li>~publicID（ ε ）
</li><li>~systemID（ ε ）
</li><li>`過去互換を強制するか@（ ~F ）
</li></ul>

◎
DOCTYPE tokens have a name, a public identifier, a system identifier, and a force-quirks flag. When a DOCTYPE token is created, its name, public identifier, and system identifier must be marked as missing (which is a distinct state from the empty string), and the force-quirks flag must be set to off (its other state is on).＼
</dd>

	<dt>開始~tag~token</dt>
	<dt>終了~tag~token</dt>
	<dd>
<p>
いずれも，それぞれが次に挙げるものを有する：
</p>
		<dl class="def-list">
			<dt>~tag名</dt>
			<dd>
作成-時に与えられる。
</dd>

			<dt>`自己閉じか@</dt>
			<dd>
初期~時は ~F
</dd>

			<dt>属性~list</dt>
			<dd>
属性たちが成す~listであり、
初期~時は空とする
— ~listを成す各~属性は［
名前（初期~時は空）,
値（初期~時は空）
］からなる。
</dd>
		</dl>
◎
Start and end tag tokens have a tag name, a self-closing flag, and a list of attributes, each of which has a name and a value. When a start or end tag token is created, its self-closing flag must be unset (its other state is that it be set), and its attributes list must be empty.＼
</dd>
	<dd>
“新たな開始~tag~token( %名前 )”
という表記は、
新たな開始~tag~tokenであって［
その~tag名 ~SET %名前
］にされたものを表すとする。
◎
＼</dd>
	<dd>
“新たな終了~tag~token()”
という表記は、
新たな終了~tag~tokenであって［
その~tag名 ~SET 空~文字列
］にされたものを表すとする。
◎
＼</dd>

	<dt>~comment~token</dt>
	<dd>
それぞれが、
作成-時に与えられる~data（文字列）を有する。
◎
Comment and＼
 </dd>
	<dd>
“新たな~comment~token( %~data )”
という表記は、
新たな~comment~tokenであって［
その~data ~SET %~data
］にされたものを表すとする。
◎
＼</dd>

	<dt>文字~token</dt>
	<dd>
それぞれが、
作成-時に与えられる 1 個の文字を有する。
◎
character tokens have data.＼
</dd>
	<dd>
“新たな文字~token( %文字 )”
という表記は、
新たな文字~tokenであって［
その文字 ~SET %文字
］にされたものを表すとする。
◎
＼</dd>

	<dt>~eof~token</dt>
	<dd>
入力~全体の終端を表現する~token。
◎
＼</dd>
</dl>

<p>
~tokenが発されたときは、
`~tree構築~段階$により即時に取扱うモノトスル。
~tree構築~段階は、
~token化~段階の`状態$に影響することもあり，
~streamの中に追加的な文字たちを挿入することもある
（例えば， `script$e 要素は、
`動的~markup挿入＠~HTMLdynamic#dynamic-markup-insertion$ ~APIを利用している~scriptを実行した結果，~token化された~streamの中に文字たちを挿入することもある。）
◎
When a token is emitted, it must immediately be handled by the tree construction stage. The tree construction stage can affect the state of the tokenization stage, and can insert additional characters into the stream. (For example, the script element can result in scripts executing and using the dynamic markup insertion APIs to insert characters into the stream being tokenized.)
</p>

<p class="note">注記：
~tokenを［
作成すること, 発すること
］は、
別個な動作である。
~tokenは、
作成されただけで発されることは決してなく，
暗黙的に遺棄されることもある
— 例：
開始~tag~tokenに構文解析される文字たちを処理している間、
当の~fileが予期せず終端した場合。
◎
Creating a token and emitting it are distinct actions. It is possible for a token to be created but implicitly abandoned (never emitted), e.g. if the file ends unexpectedly while processing the characters that are being parsed into a start tag token.
</p>

<ul>
	<li>
開始~tag~tokenが［
その`自己閉じか$ ~SET ~T
］にされて発されたときは、
それが~tree構築~段階により処理されるときに［
~tokenの
`自己閉じを承認する@
］が行われていなければ，
`non-void-html-element-start-tag-with-trailing-solidus$pE
になるとする。
◎
When a start tag token is emitted with its self-closing flag set, if the flag is not acknowledged when it is processed by the tree construction stage, that is a non-void-html-element-start-tag-with-trailing-solidus parse error.
</li>
	<li>
属性を伴う終了~tag~tokenが発されたときは、
`end-tag-with-attributes$pE
になるとする。
◎
When an end tag token is emitted with attributes, that is an end-tag-with-attributes parse error.
</li>
	<li>
終了~tag~tokenが［
その`自己閉じか$ ~SET ~T
］にされて発されたときは、
`end-tag-with-trailing-solidus$pE
になるとする
◎
When an end tag token is emitted with its self-closing flag set, that is an end-tag-with-trailing-solidus parse error.
</li>
</ul>

<p>
終了~tag~tokenは、
次を満たすならば
`適切な終了~tag~token@
とされる
⇒
この~tokenizerから，それまでに 1 個~以上の開始~tag~tokenが発されていて，それらのうち最後に発されたものと 終了~tag~tokenの~tag名は合致する
◎
An appropriate end tag token is an end tag token whose tag name matches the tag name of the last start tag to have been emitted from this tokenizer, if any. If no start tag has been emitted from this tokenizer, then no end tag token is appropriate.
</p>

<p>
`戻先~状態$V ~IN {
`二重引用符付き属性~値$st,
`一重引用符付き属性~値$st,
`引用符無し属性~値$st
}
にある下での`文字~参照$は、
`属性の一部として消費されて@
いるとされる。
◎
A character reference is said to be consumed as part of an attribute if the return state is either attribute value (double-quoted) state, attribute value (single-quoted) state, or attribute value (unquoted) state.
</p>

<div class="algo">
<p>
ある`状態$の下で
`文字~参照として消費される~cpを一掃する@
と記された所では、
次を行うモノトスル：
◎
When a state says to flush code points consumed as a character reference, it means that＼
</p>
<ol>
	<li>
<p>
`一時~buffer$V を成す
~EACH( `~cp$ %~cp )
に対し：
◎
for each code point in the temporary buffer (in the order they were added to the buffer), the user agent must＼
</p>
		<ol>
			<li>
~IF［
当の文字~参照-は`属性の一部として消費されて$いる
］
⇒
現在の属性の値 ~APPEND %~cp
◎
append the code point from the buffer to the current attribute's value if the character reference was consumed as part of an attribute, or＼
</li>
			<li>
~ELSE
⇒
新たな文字~token( %~cp ) を発する
◎
emit the code point as a character token otherwise.
</li>
		</ol>
	</li>
</ol>
</div>

<p id="check-parser-pause-flag">
~UAは、
~tokenizerを成す各~段の前に，次を行うモノトスル
⇒
~IF［
%構文解析器 の`静止するか$ ~EQ ~T
］
⇒
入子な~tokenizerの呼出nがあれば、
その処理を中止して，~call元~の制御~下に戻す
◎
Before each step of the tokenizer, the user agent must first check the parser pause flag. If it is true, then the tokenizer must abort the processing of any nested invocations of the tokenizer, yielding control back to the caller.
</p>

<p>
~tokenizerを成す状態~機械は、
以下の各 下位節にて定義される各種
`状態@
からなる。
【この~page全体を通して、名前 X の`状態$は， `X^st のように呈示される。】
◎
The tokenizer state machine consists of the states defined in the following subsections.
</p>


				<section id="data-state">
<h5 title="Data state">13.2.5.1. `~data^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0026^U</dt>
	<dd>
<ol><li>`戻先~状態$V ~SET `~data$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the data state. Switch to the character reference state.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~tag~open$stに`切替える$
</li></ol>
◎
Switch to the tag open state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit the current input character as a character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="rcdata-state">
<h5 title="RCDATA state">13.2.5.2. `~RCDATA^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0026^U</dt>
	<dd>
<ol><li>`戻先~状態$V ~SET `~RCDATA$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the RCDATA state. Switch to the character reference state.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~RCDATA~LTsign$stに`切替える$
</li></ol>
◎
Switch to the RCDATA less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="rawtext-state">
<h5 title="RAWTEXT state">13.2.5.3. `~RAWTEXT^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003C^U</dt>
	<dd>
<ol><li>`~RAWTEXT~LTsign$stに`切替える$
</li></ol>
◎
Switch to the RAWTEXT less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-state">
<h5 title="Script data state">13.2.5.4. `~script~data^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="plaintext-state">
<h5 title="PLAINTEXT state">13.2.5.5. `~PLAINTEXT^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="tag-open-state">
<h5 title="Tag open state">13.2.5.6. `~tag~open^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0021^U</dt>
	<dd>
<ol><li>`~markup宣言~open$stに`切替える$
</li></ol>
◎
Switch to the markup declaration open state.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`終了~tag~open$stに`切替える$
</li></ol>
◎
Switch to the end tag open state.
</dd>

	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>新たな開始~tag~token( 空~文字列 ) を作成する
</li><li>`~tag名$st内で`消費し直す$
</li></ol>
◎
Create a new start tag token, set its tag name to the empty string. Reconsume in the tag name state.
</dd>

	<dt>`003F^U</dt>
	<dd>
<ol><li>`unexpected-question-mark-instead-of-tag-name$pE
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`似非~comment$st内で`消費し直す$
</li></ol>
◎
This is an unexpected-question-mark-instead-of-tag-name parse error.＼
Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-before-tag-name$pE
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-before-tag-name parse error.＼
Emit a U+003C LESS-THAN SIGN character token and an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`invalid-first-character-of-tag-name$pE
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>`~data$st内で`消費し直す$
</li></ol>
◎
This is an invalid-first-character-of-tag-name parse error.＼
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the data state.
</dd>
</dl>

				</section>
				<section id="end-tag-open-state">
<h5 title="End tag open state">13.2.5.7. `終了~tag~open^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>%~token ~LET 新たな終了~tag~token()
</li><li>`~tag名$st内で`消費し直す$
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the tag name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-end-tag-name$pE
</li><li>`~data$stに`切替える$
</li></ol>
◎
This is a missing-end-tag-name parse error.＼
Switch to the data state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-before-tag-name$pE
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-before-tag-name parse error.＼
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token and an end-of-file token. 
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`invalid-first-character-of-tag-name$pE
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`似非~comment$st内で`消費し直す$
</li></ol>
◎
This is an invalid-first-character-of-tag-name parse error.＼
Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
</dd>
</dl>

				</section>
				<section id="tag-name-state">
<h5 title="Tag name state">13.2.5.8. `~tag名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`属性~名の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute name state.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`自己閉じ開始~tag$stに`切替える$
</li></ol>
◎
Switch to the self-closing start tag state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~tag~tokenの~tag名 ~APPEND `FFFD^U character
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current tag token's tag name.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name.
</dd>
</dl>

				</section>
				<section id="rcdata-less-than-sign-state">
<h5 title="RCDATA less-than sign state">13.2.5.9. `~RCDATA~LTsign^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~RCDATA終了~tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the RCDATA end tag open state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>`~RCDATA$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RCDATA state.
</dd>
</dl>

				</section>
				<section id="rcdata-end-tag-open-state">
<h5 title="RCDATA end tag open state">13.2.5.10. `~RCDATA終了~tag~open^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>%~token ~LET 新たな終了~tag~token()
</li><li>`~RCDATA終了~tag名$st内で`消費し直す$
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the RCDATA end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~RCDATA$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RCDATA state.
</dd>
</dl>

				</section>
				<section id="rcdata-end-tag-name-state">
<h5 title="RCDATA end tag name state">13.2.5.11. `~RCDATA終了~tag名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始~tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>
`一時~buffer$V を成す
~EACH( %文字 )
に対し
⇒
新たな文字~token( %文字 ) を発する
</li><li>`~RCDATA$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RCDATA state.
</dd>
</dl>

				</section>
				<section id="rawtext-less-than-sign-state">
<h5 title="RAWTEXT less-than sign state">13.2.5.12. `~RAWTEXT~LTsign^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~RAWTEXT終了~tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the RAWTEXT end tag open state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>`~RAWTEXT$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RAWTEXT state.
</dd>
</dl>

				</section>
				<section id="rawtext-end-tag-open-state">
<h5 title="RAWTEXT end tag open state">13.2.5.13. `~RAWTEXT終了~tag~open^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>%~token ~LET 新たな終了~tag~token()
</li><li>`~RAWTEXT終了~tag名$st内で`消費し直す$
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the RAWTEXT end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~RAWTEXT$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RAWTEXT state.
</dd>
</dl>

				</section>
				<section id="rawtext-end-tag-name-state">
<h5 title="RAWTEXT end tag name state">13.2.5.14. `~RAWTEXT終了~tag名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始~tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
新たな文字~token( `003C^U ) を発する
</li>
			<li>
新たな文字~token( `002F^U ) を発する
</li>
			<li>
`一時~buffer$V を成す
~EACH( %文字 )
に対し
⇒
新たな文字~token( %文字 ) を発する
</li>
			<li>
`~RAWTEXT$st内で`消費し直す$
</li>
		</ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RAWTEXT state.
</dd>
</dl>

				</section>
				<section id="script-data-less-than-sign-state">
<h5 title="Script data less-than sign state">13.2.5.15. `~script~data~LTsign^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~script~data終了~tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the script data end tag open state.
</dd>

	<dt>`0021^U</dt>
	<dd>
<ol><li>`~script~data~escape始端$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `0021^U ) を発する
</li></ol>
◎
Switch to the script data escape start state. Emit a U+003C LESS-THAN SIGN character token and a U+0021 EXCLAMATION MARK character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>`~script~data$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-end-tag-open-state">
<h5 title="Script data end tag open state">13.2.5.16. `~script~data終了~tag~open^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>%~token ~LET 新たな終了~tag~token()
</li><li>`~script~data終了~tag名$st内で`消費し直す$
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the script data end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~script~data$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-end-tag-name-state">
<h5 title="Script data end tag name state">13.2.5.17. `~script~data終了~tag名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始~tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
新たな文字~token( `003C^U ) を発する
</li>
			<li>
新たな文字~token( `002F^U ) を発する
</li>
			<li>
`一時~buffer$V を成す
~EACH( %文字 )
に対し
⇒
新たな文字~token( %文字 ) を発する
</li>
			<li>
`~script~data$st内で`消費し直す$
</li>
		</ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-escape-start-state">
<h5 title="Script data escape start state">13.2.5.18. `~script~data~escape始端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~script~data~escape始端~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escape start dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data$st内で`消費し直す$
</li></ol>
◎
Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-escape-start-dash-state">
<h5 title="Script data escape start dash state">13.2.5.19. `~script~data~escape始端~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~dash~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data$st内で`消費し直す$
</li></ol>
◎
Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-state">
<h5 title="Script data escaped state">13.2.5.20. `~script~data~escape済み^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data escaped less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-dash-state">
<h5 title="Script data escaped dash state">13.2.5.21. `~script~data~escape済み~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~dash~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data escaped less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-dash-dash-state">
<h5 title="Script data escaped dash dash state">13.2.5.22. `~script~data~escape済み~dash~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data escaped less-than sign state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~script~data$stに`切替える$
</li><li>新たな文字~token( `003E^U ) を発する
</li></ol>
◎
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-less-than-sign-state">
<h5 title="Script data escaped less-than sign state">13.2.5.23. `~script~data~escape済み~LTsign^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~script~data~escape済み終了~tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the script data escaped end tag open state.
</dd>

	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>`一時~buffer$V ~SET 空~文字列
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>`~script~data二重~escape始端$st内で`消費し直す$
</li></ol>
◎
Set the temporary buffer to the empty string. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data double escape start state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>`~script~data~escape済み$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-end-tag-open-state">
<h5 title="Script data escaped end tag open state">13.2.5.24. `~script~data~escape済み終了~tag~open^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol><li>%~token ~LET 新たな終了~tag~token()
</li><li>`~script~data~escape済み終了~tag名$st内で`消費し直す$
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the script data escaped end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~script~data~escape済み$st内で`消費し直す$
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-end-tag-name-state">
<h5 title="Script data escaped end tag name state">13.2.5.25. `~script~data~escape済み終了~tag名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始~tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了~tag~tokenは`適切な終了~tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
新たな文字~token( `003C^U ) を発する
</li>
			<li>
新たな文字~token( `002F^U ) を発する
</li>
			<li>
`一時~buffer$V を成す
~EACH( %文字 )
に対し
⇒
新たな文字~token( %文字 ) を発する
</li>
			<li>
`~script~data~escape済み$st内で`消費し直す$
</li>
		</ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-double-escape-start-state">
<h5 title="Script data double escape start state">13.2.5.26. `~script~data二重~escape始端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`一時~buffer$V ~EQ `script^l
］：
</p>
<ol><li>`~script~data二重~escape済み$stに`切替える$
</li><li>~RET
</li></ol>

</li>
			<li>
`~script~data~escape済み$stに`切替える$
</li>
			<li>
新たな文字~token( `現在の入力~文字$ ) を発する
</li>
		</ol>
◎
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>`一時~buffer$V ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the current input character to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data~escape済み$st内で`消費し直す$
</li></ol>
◎
Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-state">
<h5 title="Script data double escaped state">13.2.5.27. `~script~data二重~escape済み^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~script~data二重~escape済み~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data double escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data二重~escape済み~LTsign$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li></ol>
◎
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-dash-state">
<h5 title="Script data double escaped dash state">13.2.5.28. `~script~data二重~escape済み~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~script~data二重~escape済み~dash~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data double escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data二重~escape済み~LTsign$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li></ol>
◎
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data double escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-dash-dash-state">
<h5 title="Script data double escaped dash dash state">13.2.5.29. `~script~data二重~escape済み~dash~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data二重~escape済み~LTsign$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li></ol>
◎
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~script~data$stに`切替える$
</li><li>新たな文字~token( `003E^U ) を発する
</li></ol>
◎
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data double escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-less-than-sign-state">
<h5 title="Script data double escaped less-than sign state">13.2.5.30. `~script~data二重~escape済み~LTsign^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~script~data二重~escape終端$stに`切替える$
</li><li>新たな文字~token( `002F^U ) を発する
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the script data double escape end state. Emit a U+002F SOLIDUS character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data二重~escape済み$st内で`消費し直す$
</li></ol>
◎
Reconsume in the script data double escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-double-escape-end-state">
<h5 title="Script data double escape end state">13.2.5.31. `~script~data二重~escape終端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`一時~buffer$V ~EQ `script^l
］：
</p>
<ol><li>`~script~data~escape済み$stに`切替える$
</li><li>~RET
</li></ol>
			</li>
			<li>
`~script~data二重~escape済み$stに`切替える$
</li>
			<li>
新たな文字~token( `現在の入力~文字$ ) を発する
</li>
		</ol>
◎
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>`一時~buffer$V ~APPEND `現在の入力~文字$ に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the current input character to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data二重~escape済み$st内で`消費し直す$
</li></ol>
◎
Reconsume in the script data double escaped state.
</dd>
</dl>

				</section>
				<section id="before-attribute-name-state">
<h5 title="Before attribute name state">13.2.5.32. `属性~名の前^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dt>~EOF</dt>
	<dd>
<ol><li>`属性~名の後$st内で`消費し直す$
</li></ol>
◎
Reconsume in the after attribute name state.
</dd>

	<dt>`003D^U</dt>
	<dd>
<ol><li>`unexpected-equals-sign-before-attribute-name$pE
</li><li>現在の~tag~token内で新たな属性( 名前 ~SET `現在の入力~文字$, 値 ~SET 空~文字列 ) を開始する
</li><li>`属性~名$stに`切替える$
</li></ol>
◎
This is an unexpected-equals-sign-before-attribute-name parse error.＼
Start a new attribute in the current tag token. Set that attribute's name to the current input character, and its value to the empty string. Switch to the attribute name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~tag~token内で新たな属性( 名前 ~SET 空~文字列, 値 ~SET 空~文字列 ) を開始する
</li><li>`属性~名$st内で`消費し直す$
</li></ol>
◎
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
</dd>
</dl>

				</section>
				<section id="attribute-name-state">
<h5 title="Attribute name state">13.2.5.33. `属性~名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dt>~EOF</dt>
	<dd>
<ol><li>`属性~名の後$st内で`消費し直す$
</li></ol>
◎
Reconsume in the after attribute name state.
</dd>

	<dt>`003D^U</dt>
	<dd>
<ol><li>`属性~値の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute value state.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の属性の名前 ~APPEND `現在の入力~文字$ に対応する小文字
（文字の~cpに `0020^X を加算する）
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current attribute's name.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の名前 ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's name.
</dd>

	<dt>`0022^U</dt>
	<dt>`0027^U</dt>
	<dt>`003C^U</dt>
	<dd>
<ol><li>`unexpected-character-in-attribute-name$pE
</li><li>~GOTO ~AnyElse
</li></ol>
◎
This is an unexpected-character-in-attribute-name parse error.＼
Treat it as per the "anything else" entry below.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の名前 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's name.
</dd>
</dl>

<p>
~UAは，`属性~名$stから去るときには
（および，適切になるなら、
現在の~tag~tokenを発する前に）、
現在の~tag~token上の属性たちの完全な名前どうしを比較するモノトスル。
正確に同じ名前の属性が~token上にすでに在る場合、
`duplicate-attribute$pE
になり，新たな
【後から追加された】
属性は~tokenから除去するモノトスル。
◎
When the user agent leaves the attribute name state (and before emitting the tag token, if appropriate), the complete attribute's name must be compared to the other attributes on the same token; if there is already an attribute on the token with the exact same name, then this is a duplicate-attribute parse error and the new attribute must be removed from the token.
</p>

<p class="note">注記：
ある属性が ~tokenからそのように除去された場合、
それに対応する値は，あっても
構文解析器により後続して利用されることは決してなく、
実質的に破棄される。
しかしながら，この仕方で属性を除去しても、
~tokenizerの目的における “現在の属性” としての地位は変化しない。
◎
If an attribute is so removed from a token, it, and the value that gets associated with it, if any, are never subsequently used by the parser, and are therefore effectively discarded. Removing the attribute in this way does not change its status as the "current attribute" for the purposes of the tokenizer, however.
</p>

				</section>
				<section id="after-attribute-name-state">
<h5 title="After attribute name state">13.2.5.34. `属性~名の後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`自己閉じ開始~tag$stに`切替える$
</li></ol>
◎
Switch to the self-closing start tag state.
</dd>

	<dt>`003D^U</dt>
	<dd>
<ol><li>`属性~値の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute value state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~tag~token内で新たな属性( 名前 ~SET 空~文字列, 値 ~SET 空~文字列 ) を開始する
</li><li>`属性~名$st内で`消費し直す$
</li></ol>
◎
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
</dd>
</dl>

				</section>
				<section id="before-attribute-value-state">
<h5 title="Before attribute value state">13.2.5.35. `属性~値の前^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`二重引用符付き属性~値$stに`切替える$
</li></ol>
◎
Switch to the attribute value (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`一重引用符付き属性~値$stに`切替える$
</li></ol>
◎
Switch to the attribute value (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-attribute-value$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
This is a missing-attribute-value parse error.＼
Switch to the data state. Emit the current tag token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`引用符無し属性~値$st内で`消費し直す$
</li></ol>
◎
Reconsume in the attribute value (unquoted) state.
</dd>
</dl>

				</section>
				<section id="attribute-value-(double-quoted)-state">
<h5 title="Attribute value (double-quoted) state">13.2.5.36. `二重引用符付き属性~値^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0022^U</dt>
	<dd>
<ol><li>`引用符付き属性~値の後$stに`切替える$
</li></ol>
◎
Switch to the after attribute value (quoted) state.
</dd>

	<dt>`0026^U</dt>
	<dd>
<ol><li>`戻先~状態$V ~SET `二重引用符付き属性~値$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the attribute value (double-quoted) state. Switch to the character reference state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の値 ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の値 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's value.
</dd>
</dl>

				</section>
				<section id="attribute-value-(single-quoted)-state">
<h5 title="Attribute value (single-quoted) state">13.2.5.37. `一重引用符付き属性~値^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0027^U</dt>
	<dd>
<ol><li>`引用符付き属性~値の後$stに`切替える$
</li></ol>
◎
Switch to the after attribute value (quoted) state.
</dd>

	<dt>`0026^U</dt>
	<dd>
<ol><li>`戻先~状態$V ~SET `一重引用符付き属性~値$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the attribute value (single-quoted) state. Switch to the character reference state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の値 ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の値 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's value.
</dd>
</dl>

				</section>
				<section id="attribute-value-(unquoted)-state">
<h5 title="Attribute value (unquoted) state">13.2.5.38. `引用符無し属性~値^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`属性~名の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute name state.
</dd>

	<dt>`0026^U</dt>
	<dd>
<ol><li>`戻先~状態$V ~SET `引用符無し属性~値$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the attribute value (unquoted) state. Switch to the character reference state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の値 ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
</dd>

	<dt>`0022^U</dt>
	<dt>`0027^U</dt>
	<dt>`003C^U</dt>
	<dt>`003D^U</dt>
	<dt>`0060^U</dt>
	<dd>
<ol><li>`unexpected-character-in-unquoted-attribute-value$pE
</li><li>~GOTO ~AnyElse
</li></ol>
◎
This is an unexpected-character-in-unquoted-attribute-value parse error.＼
Treat it as per the "anything else" entry below.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の値 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's value.
</dd>
</dl>

				</section>
				<section id="after-attribute-value-(quoted)-state">
<h5 title="After attribute value (quoted) state">13.2.5.39. `引用符付き属性~値の後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`属性~名の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute name state.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`自己閉じ開始~tag$stに`切替える$
</li></ol>
◎
Switch to the self-closing start tag state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-whitespace-between-attributes$pE
</li><li>`属性~名の前$st内で`消費し直す$
</li></ol>
◎
This is a missing-whitespace-between-attributes parse error.＼
Reconsume in the before attribute name state.
</dd>
</dl>

				</section>
				<section id="self-closing-start-tag-state">
<h5 title="Self-closing start tag state">13.2.5.40. `自己閉じ開始~tag^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol><li>現在の~tag~tokenの`自己閉じか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Set the self-closing flag of the current tag token. Switch to the data state. Emit the current tag token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`unexpected-solidus-in-tag$pE
</li><li>`属性~名の前$st内で`消費し直す$
</li></ol>
◎
This is an unexpected-solidus-in-tag parse error.＼
Reconsume in the before attribute name state.
</dd>
</dl>

				</section>
				<section id="bogus-comment-state">
<h5 title="Bogus comment state">13.2.5.41. `似非~comment^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current comment token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
Emit the comment. Emit an end-of-file token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~comment~tokenの~data ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the comment token's data.
</dd>
</dl>

				</section>
				<section id="markup-declaration-open-state">
<h5 title="Markup declaration open state">13.2.5.42. `~markup宣言~open^st</h5>

<p>
次回の少数の文字に応じて：
◎
If the next few characters are:
</p>

<dl class="switch">
	<dt>
2 個の `002D^U
◎
Two U+002D HYPHEN-MINUS characters (-)
</dt>
	<dd>
<ol><li>それらの文字を消費する
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`~comment始端$stに`切替える$
</li></ol>
◎
Consume those two characters, create a comment token whose data is the empty string, and switch to the comment start state.
</dd>

	<dt>
`~ASCII大小無視$で `DOCTYPE^l に合致する
◎
ASCII case-insensitive match for the word "DOCTYPE"
</dt>
	<dd>
<ol><li>それらの文字を消費する
</li><li>`~DOCTYPE$stに`切替える$
</li></ol>
◎
Consume those characters and switch to the DOCTYPE state.
</dd>

	<dt>
文字列 `[CDATA[^l
◎
The string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET character before and after)
</dt>
	<dd>
		<ol>
			<li>
それらの文字を消費する
◎
Consume those characters.＼
</li>
			<li>
<p>
~IF［
`現在の調整-済み~node$が在る
］~AND［
それは`~HTML名前空間$に属する要素でない
］：
</p>
<ol><li>`~CDATAsec$stに`切替える$
</li><li>~RET
</li></ol>

◎
If there is an adjusted current node and it is not an element in the HTML namespace, then switch to the CDATA section state.＼
</li>
			<li>
`cdata-in-html-content$pE
◎
Otherwise, this is a cdata-in-html-content parse error.＼
</li>
			<li>
新たな~comment~token( `[CDATA[^l ) を作成する
◎
Create a comment token whose data is the "[CDATA[" string.＼
</li>
			<li>
`似非~comment$stに`切替える$
◎
Switch to the bogus comment state.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`incorrectly-opened-comment$pE
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`似非~comment$stに`切替える$
</li></ol>
<p>
（現在の状態~内では何も消費しないこと。）
</p>
◎
This is an incorrectly-opened-comment parse error.＼
Create a comment token whose data is the empty string. Switch to the bogus comment state (don't consume anything in the current state).
</dd>
</dl>

				</section>
				<section id="comment-start-state">
<h5 title="Comment start state">13.2.5.43. `~comment始端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment始端~dash$stに`切替える$
</li></ol>
◎
Switch to the comment start dash state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-closing-of-empty-comment$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
This is an abrupt-closing-of-empty-comment parse error.＼
Switch to the data state. Emit the current comment token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-start-dash-state">
<h5 title="Comment start dash state">13.2.5.44. `~comment始端~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment終端$stに`切替える$
</li></ol>
◎
Switch to the comment end state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-closing-of-empty-comment$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
This is an abrupt-closing-of-empty-comment parse error.＼
Switch to the data state. Emit the current comment token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.＼
Emit the current comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U 
</li><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-state">
<h5 title="Comment state">13.2.5.45. `~comment^st</h5>
<a id="comment"></a>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003C^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li><li>`~comment~LTsign$stに`切替える$
</li></ol>
◎
Append the current input character to the comment token's data. Switch to the comment less-than sign state.
</dd>

	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment終端~dash$stに`切替える$
</li></ol>
◎
Switch to the comment end dash state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~comment~tokenの~data ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.＼
Emit the current comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the comment token's data.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-state">
<h5 title="Comment less-than sign state">13.2.5.46. `~comment~LTsign^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0021^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li><li>`~comment~LTsign~bang$stに`切替える$
</li></ol>
◎
Append the current input character to the comment token's data. Switch to the comment less-than sign bang state.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the comment token's data.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-bang-state">
<h5 title="Comment less-than sign bang state">13.2.5.47. `~comment~LTsign~bang^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment~LTsign~bang~dash$stに`切替える$
</li></ol>
◎
Switch to the comment less-than sign bang dash state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-bang-dash-state">
<h5 title="Comment less-than sign bang dash state">13.2.5.48. `~comment~LTsign~bang~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment~LTsign~bang~dash~dash$stに`切替える$
</li></ol>
◎
Switch to the comment less-than sign bang dash dash state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment終端~dash$st内で`消費し直す$
</li></ol>
◎
Reconsume in the comment end dash state.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-bang-dash-dash-state">
<h5 title="Comment less-than sign bang dash dash state">13.2.5.49. `~comment~LTsign~bang~dash~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dt>~EOF</dt>
	<dd>
<ol><li>`~comment終端$st内で`消費し直す$
</li></ol>
◎
Reconsume in the comment end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`nested-comment$pE
</li><li>`~comment終端$st内で`消費し直す$
</li></ol>
◎
This is a nested-comment parse error.＼
Reconsume in the comment end state.
</dd>
</dl>

				</section>
				<section id="comment-end-dash-state">
<h5 title="Comment end dash state">13.2.5.50. `~comment終端~dash^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment終端$stに`切替える$
</li></ol>
◎
Switch to the comment end state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.＼
Emit the current comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U 
</li><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-end-state">
<h5 title="Comment end state">13.2.5.51. `~comment終端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current comment token.
</dd>

	<dt>`0021^U</dt>
	<dd>
<ol><li>`~comment終端~bang$stに`切替える$
</li></ol>
◎
Switch to the comment end bang state.
</dd>

	<dt>`002D^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U
</li></ol>
◎
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.＼
Emit the current comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U ~APPEND `002D^U
</li><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Append two U+002D HYPHEN-MINUS characters (-) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-end-bang-state">
<h5 title="Comment end bang state">13.2.5.52. `~comment終端~bang^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U ~APPEND `0021^U
</li><li>`~comment終端~dash$stに`切替える$
</li></ol>
◎
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Switch to the comment end dash state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`incorrectly-closed-comment$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
This is an incorrectly-closed-comment parse error.＼
Switch to the data state. Emit the current comment token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.＼
Emit the current comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U ~APPEND `0021^U 
</li><li>`~comment$st内で`消費し直す$
</li></ol>
◎
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="doctype-state">
<h5 title="DOCTYPE state">13.2.5.53. `~DOCTYPE^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE名の前$stに`切替える$
</li></ol>
◎
Switch to the before DOCTYPE name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~DOCTYPE名の前$st内で`消費し直す$
</li></ol>
◎
Reconsume in the before DOCTYPE name state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>`過去互換を強制するか$ ~SET ~T
</li><li>%~token を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the current token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-whitespace-before-doctype-name$pE
</li><li>`~DOCTYPE名の前$st内で`消費し直す$
</li></ol>
◎
This is a missing-whitespace-before-doctype-name parse error.＼
Reconsume in the before DOCTYPE name state.
</dd>
</dl>

				</section>
				<section id="before-doctype-name-state">
<h5 title="Before DOCTYPE name state">13.2.5.54. `~DOCTYPE名の前^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>%~token の名前 ~SET `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li><li>`~DOCTYPE名$stに`切替える$
</li></ol>
◎
Create a new DOCTYPE token. Set the token's name to the lowercase version of the current input character (add 0x0020 to the character's code point). Switch to the DOCTYPE name state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>%~token の名前 ~SET `FFFD^U
</li><li>`~DOCTYPE名$stに`切替える$
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Create a new DOCTYPE token. Set the token's name to a U+FFFD REPLACEMENT CHARACTER character. Switch to the DOCTYPE name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-name$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>%~token を発する
</li></ol>
◎
This is a missing-doctype-name parse error.＼
Create a new DOCTYPE token. Set its force-quirks flag to on. Switch to the data state. Emit the current token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>`過去互換を強制するか$ ~SET ~T
</li><li>%~token を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the current token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>%~token の名前 ~SET `現在の入力~文字$
</li><li>`~DOCTYPE名$stに`切替える$
</li></ol>
◎
Create a new DOCTYPE token. Set the token's name to the current input character. Switch to the DOCTYPE name state.
</dd>
</dl>

				</section>
				<section id="doctype-name-state">
<h5 title="DOCTYPE name state">13.2.5.55. `~DOCTYPE名^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE名の後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの名前 ~APPEND `現在の入力~文字$に対応する小文字
（文字の~cpに `0020^X を加算する）
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current DOCTYPE token's name.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの名前 ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's name.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの名前 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's name.
</dd>
</dl>

				</section>
				<section id="after-doctype-name-state">
<h5 title="After DOCTYPE name state">13.2.5.56. `~DOCTYPE名の後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［［
`現在の入力~文字$から開始する 6 個の文字~並び
］ ~EQ`大小無視$sub `PUBLIC^l
］：
</p>
<ol><li>それらの文字を消費する
</li><li>`~DOCTYPE~public-keywordの後$stに`切替える$
</li></ol>
◎
If the six characters starting from the current input character are an ASCII case-insensitive match for the word "PUBLIC", then consume those characters and switch to the after DOCTYPE public keyword state.
</li>
			<li>
<p>
~ELIF［［
`現在の入力~文字$から開始する 6 個の文字~並び
］ ~EQ`大小無視$sub `SYSTEM^l
］：
</p>
<ol><li>それらの文字を消費する
</li><li>`~DOCTYPE~system-keywordの後$stに`切替える$
</li></ol>
◎
Otherwise, if the six characters starting from the current input character are an ASCII case-insensitive match for the word "SYSTEM", then consume those characters and switch to the after DOCTYPE system keyword state.
</li>
			<li>
<p>
~ELSE：
</p>

<ol><li>`invalid-character-sequence-after-doctype-name$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
Otherwise, this is an invalid-character-sequence-after-doctype-name parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</li>
		</ol>
	</dd>
</dl>

				</section>
				<section id="after-doctype-public-keyword-state">
<h5 title="After DOCTYPE public keyword state">13.2.5.57. `~DOCTYPE~public-keywordの後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDの前$stに`切替える$
</li></ol>
◎
Switch to the before DOCTYPE public identifier state.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-public-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（二重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-public-keyword parse error.＼
Set the current DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-public-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（一重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-public-keyword parse error.＼
Set the current DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-public-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
This is a missing-quote-before-doctype-public-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="before-doctype-public-identifier-state">
<h5 title="Before DOCTYPE public identifier state">13.2.5.58. `~DOCTYPE~publicIDの前^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（二重引用符）$stに`切替える$
</li></ol>
◎
Set the current DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（一重引用符）$stに`切替える$
</li></ol>
◎
Set the current DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-public-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
This is a missing-quote-before-doctype-public-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="doctype-public-identifier-(double-quoted)-state">
<h5 title="DOCTYPE public identifier (double-quoted) state">13.2.5.59. `~DOCTYPE~publicID（二重引用符）^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0022^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE public identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-public-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's public identifier.
</dd>
</dl>

				</section>
				<section id="doctype-public-identifier-(single-quoted)-state">
<h5 title="DOCTYPE public identifier (single-quoted) state">13.2.5.60. `~DOCTYPE~publicID（一重引用符）^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0027^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE public identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-public-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's public identifier.
</dd>
</dl>

				</section>
				<section id="after-doctype-public-identifier-state">
<h5 title="After DOCTYPE public identifier state">13.2.5.61. `~DOCTYPE~publicIDの後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDと~systemIDの合間$stに`切替える$
</li></ol>
◎
Switch to the between DOCTYPE public and system identifiers state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`missing-whitespace-between-doctype-public-and-system-identifiers$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error.＼
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`missing-whitespace-between-doctype-public-and-system-identifiers$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error.＼
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="between-doctype-public-and-system-identifiers-state">
<h5 title="Between DOCTYPE public and system identifiers state">13.2.5.62. `~DOCTYPE~publicIDと~systemIDの合間^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="after-doctype-system-keyword-state">
<h5 title="After DOCTYPE system keyword state">13.2.5.63. `~DOCTYPE~system-keywordの後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE~systemIDの前$stに`切替える$
</li></ol>
◎
Switch to the before DOCTYPE system identifier state.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-system-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-system-keyword parse error.＼
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-system-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-system-keyword parse error.＼
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="before-doctype-system-identifier-state">
<h5 title="Before DOCTYPE system identifier state">13.2.5.64. `~DOCTYPE~systemIDの前^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
Set the current DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`似非~DOCTYPE$st内で`消費し直す$
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="doctype-system-identifier-(double-quoted)-state">
<h5 title="DOCTYPE system identifier (double-quoted) state">13.2.5.65. `~DOCTYPE~systemID（二重引用符）^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0022^U</dt>
	<dd>
<ol><li>`~DOCTYPE~systemIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE system identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's system identifier.
</dd>
</dl>

				</section>
				<section id="doctype-system-identifier-(single-quoted)-state">
<h5 title="DOCTYPE system identifier (single-quoted) state">13.2.5.66. `~DOCTYPE~systemID（一重引用符）^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0027^U</dt>
	<dd>
<ol><li>`~DOCTYPE~systemIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE system identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-system-identifier parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's system identifier.
</dd>
</dl>

				</section>
				<section id="after-doctype-system-identifier-state">
<h5 title="After DOCTYPE system identifier state">13.2.5.67. `~DOCTYPE~systemIDの後^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換を強制するか$ ~SET ~T
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.＼
Set the current DOCTYPE token's force-quirks flag to on. Emit the current DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`unexpected-character-after-doctype-system-identifier$pE
</li><li>`似非~DOCTYPE$st内で`消費し直す$
（これは、
現在の~DOCTYPE~tokenの`過去互換を強制するか$を `~T にしない^em。）
</li></ol>
◎
This is an unexpected-character-after-doctype-system-identifier parse error.＼
Reconsume in the bogus DOCTYPE state. (This does not set the current DOCTYPE token's force-quirks flag to on.)
</dd>
</dl>

				</section>
				<section id="bogus-doctype-state">
<h5 title="Bogus DOCTYPE state">13.2.5.68. `似非~DOCTYPE^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the DOCTYPE token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>この文字は無視する
</li></ol>
◎
This is an unexpected-null-character parse error.＼
Ignore the character.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
Emit the DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>
</dl>

				</section>
				<section id="cdata-section-state">
<h5 title="CDATA section state">13.2.5.69. `~CDATAsec^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`005D^U</dt>
	<dd>
<ol><li>`~CDATAsec~bracket$stに`切替える$
</li></ol>
◎
Switch to the CDATA section bracket state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-cdata$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-cdata parse error.＼
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

<p class="note">注記：
`0000^U は、
~tree構築~段階にて，`外来~内容~内$md内の一部として取扱われる
— それは、
`~CDATAsec$が現れ得る唯一の箇所である
◎
U+0000 NULL characters are handled in the tree construction stage, as part of the in foreign content insertion mode, which is the only place where CDATA sections can appear.
</p>

				</section>
				<section id="cdata-section-bracket-state">
<h5 title="CDATA section bracket state">13.2.5.70. `~CDATAsec~bracket^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`005D^U</dt>
	<dd>
<ol><li>`~CDATAsec終端$stに`切替える$
</li></ol>
◎
Switch to the CDATA section end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `005D^U ) を発する
</li><li>`~CDATAsec$st内で`消費し直す$
</li></ol>
◎
Emit a U+005D RIGHT SQUARE BRACKET character token. Reconsume in the CDATA section state.
</dd>
</dl>

				</section>
				<section id="cdata-section-end-state">
<h5 title="CDATA section end state">13.2.5.71. `~CDATAsec終端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`005D^U</dt>
	<dd>
<ol><li>新たな文字~token( `005D^U ) を発する
</li></ol>
◎
Emit a U+005D RIGHT SQUARE BRACKET character token.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li></ol>
◎
Switch to the data state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `005D^U ) を発する
</li><li>新たな文字~token( `005D^U ) を発する
</li><li>`~CDATAsec$st内で`消費し直す$
</li></ol>
◎
Emit two U+005D RIGHT SQUARE BRACKET character tokens. Reconsume in the CDATA section state.
</dd>
</dl>

				</section>
				<section id="character-reference-state">
<h5 title="Character reference state">13.2.5.72. `文字~参照^st</h5>

<ol>
	<li>
`一時~buffer$V ~SET 空~文字列
~APPEND `0026^U
~APPEND `現在の入力~文字$
◎
Set the temporary buffer to the empty string. Append a U+0026 AMPERSAND (&amp;) character to the temporary buffer.＼
</li>
	<li>
<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

		<dl class="switch">
			<dt>`~ASCII英数字$</dt>
			<dd>
<ol><li>`有名~文字~参照$st内で`消費し直す$
</li></ol>
◎
Reconsume in the named character reference state.
</dd>

			<dt>`0023^U</dt>
			<dd>
<ol><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>`数量-文字~参照$stに`切替える$
</li></ol>
◎
Append the current input character to the temporary buffer. Switch to the numeric character reference state.
</dd>

			<dt>~AnyElse</dt>
			<dd>
<ol><li>`文字~参照として消費される~cpを一掃する$
</li><li>`戻先~状態$V 内で`消費し直す$
</li></ol>
◎
Flush code points consumed as a character reference. Reconsume in the return state.
</dd>
		</dl>
	</li>
</ol>


				</section>
				<section id="named-character-reference-state">
<h5 title="Named character reference state">13.2.5.73. `有名~文字~参照^st</h5>

<ol>
	<li>
<p>
%識別子 ~LET アリな限り最大~個数の文字を［
消費して得られた文字列 ~IN 次に挙げる文字列たちが成す集合
］を満たす限り消費して得られる文字列：
</p>
		<ul>
			<li>
`有名~文字~参照$ 一覧の 1 列目に挙げられている識別子に~semicolon（ `003B^U ）を付加したもの
</li>
			<li>
同じ一覧の 1 列目に挙げられている識別子のうち， “※” が付与されているもの
（~markup内で~semicolonを省略しても有効になるもの）
</li>
			<li>
空~文字列
</li>
		</ul>

<p class="trans-note">【
この訳における有名~文字~参照の一覧は，
~semicolonを省略している（ “※” に代えている）ため、
この段の記述は，それに整合するように原文と違えている。
】</p>

◎
Consume the maximum number of characters possible, where the consumed characters are one of the identifiers in the first column of the named character references table. Append each character to the temporary buffer when it's consumed.
</li>
	<li>
<p>
~IF［
%識別子 ~NEQ 空~文字列
］
◎
If there is a match
</p>
		<ol>
			<li>
%~semicolonなしか ~LET ~IS［
%識別子 を成す最後の文字 ~NEQ `003B^U
］
◎
↓</li>
			<li>
<p>
~IF［
~AND↓
］…
</p>
				<ul>
					<li>
文字~参照は`属性の一部として消費されて$いる
</li>
					<li>
%~semicolonなしか ~EQ ~T
</li>
					<li>
`次回の入力~文字$ ~IN { `003D^U, `~ASCII英数字$ }
</li>
				</ul>
<p>
…ならば
⇒
`一時~buffer$V ~APPEND %識別子
（これは、
歴史的な理由による）
</p>

◎
If the character reference was consumed as part of an attribute, and the last character matched is not a U+003B SEMICOLON character (;), and the next input character is either a U+003D EQUALS SIGN character (=) or an ASCII alphanumeric, then, for historical reasons,＼
◎
↓↓flush code points consumed as a character reference and switch to the return state.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~IF［
%~semicolonなしか ~EQ ~T
］
⇒
`missing-semicolon-after-character-reference$pE
◎
If the last character matched is not a U+003B SEMICOLON character (;), then this is a missing-semicolon-after-character-reference parse error.
</li>
					<li>
`一時~buffer$V ~SET `有名~文字~参照$ 一覧の 2 列目に与えられる， %識別子 に対応している 1 〜 2 個の文字
◎
Set the temporary buffer to the empty string. Append one or two characters corresponding to the character reference name (as given by the second column of the named character references table) to the temporary buffer.
◎
↓↓Flush code points consumed as a character reference. Switch to the return state.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`文字~参照として消費される~cpを一掃する$
◎
↑↓</li>
	<li>
［
%識別子 ~NEQ 空~文字列 ならば `戻先~状態$V ／
~ELSE_ `多義的~ampersand$st
］に`切替える$
◎
Otherwise
• Flush code points consumed as a character reference. Switch to the ambiguous ampersand state.
</li>
</ol>

<div class="example">
<p>
~markupが，属性の外で文字列
`I'm &amp;notit; I tell you^l
を包含する場合、
文字~参照は，
`I'm ¬it; I tell you^l
のように
“~~否定（ `not^en ）”
として構文解析される（これは~perrorでもある）。
が、
文字列が
`I'm &amp;notin; I tell you^l
であったなら、
文字~参照は
`notin;^l
として構文解析される結果，
`I'm ∉ I tell you^l
になる（また，~perrorもない）。
◎
If the markup contains (not in an attribute) the string I'm &amp;notit; I tell you, the character reference is parsed as "not", as in, I'm ¬it; I tell you (and this is a parse error). But if the markup was I'm &amp;notin; I tell you, the character reference would be parsed as "notin;", resulting in I'm ∉ I tell you (and no parse error).
</p>

<p>
一方で，~markupが ある属性~内に文字列
`I'm &amp;notit; I tell you^l
を包含する場合、
構文解析される文字~参照はなく，文字列はそのままにされる
（また，~perrorもない）。
◎
However, if the markup contains the string I'm &amp;notit; I tell you in an attribute, no character reference is parsed and string remains intact (and there is no parse error).
</p>

</div>

				</section>
				<section id="ambiguous-ampersand-state">
<h5 title="Ambiguous ampersand state">13.2.5.74. `多義的~ampersand^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英数字$</dt>
	<dd>
		<ol>
			<li>
~IF［
文字~参照は`属性の一部として消費されて$いる
］
⇒
現在の属性の値 ~APPEND `現在の入力~文字$
</li>
			<li>
~ELSE
⇒
新たな文字~token( `現在の入力~文字$ ) を発する
</li>
		</ol>

◎
If the character reference was consumed as part of an attribute, then append the current input character to the current attribute's value. Otherwise, emit the current input character as a character token.
</dd>

	<dt>`003B^U</dt>
	<dd>
<ol><li>`unknown-named-character-reference$pE
</li><li>`戻先~状態$V 内で`消費し直す$
</li></ol>
◎
This is an unknown-named-character-reference parse error.＼
Reconsume in the return state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`戻先~状態$V 内で`消費し直す$
</li></ol>
◎
Reconsume in the return state.
</dd>
</dl>

				</section>
				<section id="numeric-character-reference-state">
<h5 title="Numeric character reference state">13.2.5.75. `数量-文字~参照^st</h5>

<ol>
	<li>
`文字~参照~code@V
~SET 0
◎
Set the character reference code to zero (0).
</li>
	<li>
<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

		<dl class="switch">
			<dt>`0078^U</dt>
			<dt>`0058^U</dt>
			<dd>
<ol><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>`~hexadecimal文字~参照~始端$stに`切替える$
</li></ol>
◎
Append the current input character to the temporary buffer. Switch to the hexadecimal character reference start state.
</dd>

			<dt>~AnyElse</dt>
			<dd>
<ol><li>`~decimal文字~参照~始端$st内で`消費し直す$
</li></ol>
◎
Reconsume in the decimal character reference start state.
</dd>
		</dl>
	</li>
</ol>


				</section>
				<section id="hexadecimal-character-reference-start-state">
<h5 title="Hexadecimal character reference start state">13.2.5.76. `~hexadecimal文字~参照~始端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII~hex数字$</dt>
	<dd>
<ol><li>`~hexadecimal文字~参照$st内で`消費し直す$
</li></ol>
◎
Reconsume in the hexadecimal character reference state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`absence-of-digits-in-numeric-character-reference$pE
</li><li>`文字~参照として消費される~cpを一掃する$
</li><li>`戻先~状態$V 内で`消費し直す$
</li></ol>
◎
This is an absence-of-digits-in-numeric-character-reference parse error.＼
Flush code points consumed as a character reference. Reconsume in the return state.
</dd>
</dl>

				</section>
				<section id="decimal-character-reference-start-state">
<h5 title="Decimal character reference start state">13.2.5.77. `~decimal文字~参照~始端^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII数字$</dt>
	<dd>
<ol><li>`~decimal文字~参照$st内で`消費し直す$
</li></ol>
◎
Reconsume in the decimal character reference state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`absence-of-digits-in-numeric-character-reference$pE
</li><li>`文字~参照として消費される~cpを一掃する$
</li><li>`戻先~状態$V 内で`消費し直す$
</li></ol>
◎
This is an absence-of-digits-in-numeric-character-reference parse error.＼
Flush code points consumed as a character reference. Reconsume in the return state.
</dd>
</dl>

				</section>
				<section id="hexadecimal-character-reference-state">
<h5 title="Hexadecimal character reference state">13.2.5.78. `~hexadecimal文字~参照^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII~hex数字$</dt>
	<dd>
		<ol>
			<li>
`文字~参照~code$V ~SET
( `文字~参照~code$V ~MUL 16 )
~PLUS ( `現在の入力~文字$を 16 進数として解釈した結果の整数† )
</li>
		</ol>

<p>†
この整数は、
`現在の入力~文字$が［
`~ASCII数字$ならば その~cpから`0030^X を減算した結果 ／
`~ASCII~hex数字（大文字）$ならば その~cpから`0037^X を減算した結果 ／
`~ASCII~hex数字（小文字）$ならば その~cpから`0057^X を減算した結果
］になる。
</p>

◎
ASCII digit
◎
Multiply the character reference code by 16. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
◎
ASCII upper hex digit
◎
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexadecimal digit (subtract 0x0037 from the character's code point) to the character reference code.
◎
ASCII lower hex digit
◎
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexadecimal digit (subtract 0x0057 from the character's code point) to the character reference code.
</dd>

	<dt>`003B^U</dt>
	<dd>
<ol><li>`数量-文字~参照~終端$stに`切替える$
</li></ol>
◎
Switch to the numeric character reference end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-semicolon-after-character-reference$pE
</li><li>`数量-文字~参照~終端$st内で`消費し直す$
</li></ol>
◎
This is a missing-semicolon-after-character-reference parse error.＼
Reconsume in the numeric character reference end state.
</dd>
</dl>

				</section>
				<section id="decimal-character-reference-state">
<h5 title="Decimal character reference state">13.2.5.79. `~decimal文字~参照^st</h5>

<p>
`次回の入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII数字$</dt>
	<dd>
		<ol>
			<li>
`文字~参照~code$V ~SET
( `文字~参照~code$V ~MUL 10 )
~PLUS ( `現在の入力~文字$を 10 進数として解釈した結果の整数（文字の~cpから`0030^X を減算した結果） )
◎
Multiply the character reference code by 10. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
</li>
		</ol>
	</dd>

	<dt>`003B^U</dt>
	<dd>
<ol><li>`数量-文字~参照~終端$stに`切替える$
</li></ol>
◎
Switch to the numeric character reference end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-semicolon-after-character-reference$pE
</li><li>`数量-文字~参照~終端$st内で`消費し直す$
</li></ol>
◎
This is a missing-semicolon-after-character-reference parse error.＼
Reconsume in the numeric character reference end state.
</dd>
</dl>

				</section>
				<section id="numeric-character-reference-end-state">
<h5 title="Numeric character reference end state">13.2.5.80. `数量-文字~参照~終端^st</h5>

<ol>
	<li>
<p>
`文字~参照~code$V （が指す~cp）に応じて：
◎
Check the character reference code:
</p>

		<dl class="switch">
			<dt>
`00^X
◎
If the number is 0x00,＼
</dt>
			<dd>
<ol><li>`null-character-reference$pE
</li><li>`文字~参照~code$V ~SET `FFFD^X
</li></ol>
◎
then this is a null-character-reference parse error.＼
Set the character reference code to 0xFFFD.
</dd>

			<dt>
`10FFFF^X を超える
◎
If the number is greater than 0x10FFFF,＼
</dt>
			<dd>
<ol><li>`character-reference-outside-unicode-range$pE
</li><li>`文字~参照~code$V ~SET `FFFD^X
</li></ol>
◎
then this is a character-reference-outside-unicode-range parse error.＼
Set the character reference code to 0xFFFD.
</dd>

			<dt>
`~surrogate$
◎
If the number is a surrogate,＼
</dt>
			<dd>
<ol><li>`surrogate-character-reference$pE
</li><li>`文字~参照~code$V ~SET `FFFD^X
</li></ol>
◎
then this is a surrogate-character-reference parse error.＼
Set the character reference code to 0xFFFD.
</dd>

			<dt>
`非文字$
◎
If the number is a noncharacter,＼
</dt>
			<dd>
<ol><li>`noncharacter-character-reference$pE
</li></ol>
◎
then this is a noncharacter-character-reference parse error.
</dd>

			<dt>
`0D^X
◎
If the number is 0x0D,＼
</dt>
			<dt>
`~ASCII空白$以外の`制御文字$
◎
or a control that's not ASCII whitespace,＼
</dt>
			<dd>
<ol><li>`control-character-reference$pE
</li></ol>
◎
then this is a control-character-reference parse error.＼
</dd>

			<dt>
下の表tの 1 列目に現れる
◎
If the number is one of the numbers in the first column of the following table,＼
</dt>
			<dd>
<p>
`文字~参照~code$V ~SET 現れた行の 2 列目の数
◎
then find the row with that number in the first column, and set the character reference code to the number in the second column of that row.
</p>

<table id="table-charref-overrides"><thead>
<tr><th>
数
◎
Number
<th colspan="2">
~cp
◎
Code point
<tbody>

<tr><td>`80^X
<td>`20AC^X
<td>EURO SIGN (€)

<tr><td>`82^X
<td>`201A^X
<td>SINGLE LOW-9 QUOTATION MARK (‚)

<tr><td>`83^X
<td>`0192^X
<td>LATIN SMALL LETTER F WITH HOOK (ƒ)

<tr><td>`84^X
<td>`201E^X
<td>DOUBLE LOW-9 QUOTATION MARK („)

<tr><td>`85^X
<td>`2026^X
<td>HORIZONTAL ELLIPSIS (…)

<tr><td>`86^X
<td>`2020^X
<td>DAGGER (†)

<tr><td>`87^X
<td>`2021^X
<td>DOUBLE DAGGER (‡)

<tr><td>`88^X
<td>`02C6^X
<td>MODIFIER LETTER CIRCUMFLEX ACCENT (ˆ)

<tr><td>`89^X
<td>`2030^X
<td>PER MILLE SIGN (‰)

<tr><td>`8A^X
<td>`0160^X
<td>LATIN CAPITAL LETTER S WITH CARON (Š)

<tr><td>`8B^X
<td>`2039^X
<td>SINGLE LEFT-POINTING ANGLE QUOTATION MARK (‹)

<tr><td>`8C^X
<td>`0152^X
<td>LATIN CAPITAL LIGATURE OE (Œ)

<tr><td>`8E^X
<td>`017D^X
<td>LATIN CAPITAL LETTER Z WITH CARON (Ž)

<tr><td>`91^X
<td>`2018^X
<td>LEFT SINGLE QUOTATION MARK (‘)

<tr><td>`92^X
<td>`2019^X
<td>RIGHT SINGLE QUOTATION MARK (’)

<tr><td>`93^X
<td>`201C^X
<td>LEFT DOUBLE QUOTATION MARK (“)

<tr><td>`94^X
<td>`201D^X
<td>RIGHT DOUBLE QUOTATION MARK (”)

<tr><td>`95^X
<td>`2022^X
<td>BULLET (•)

<tr><td>`96^X
<td>`2013^X
<td>EN DASH (–)

<tr><td>`97^X
<td>`2014^X
<td>EM DASH (—)

<tr><td>`98^X
<td>`02DC^X
<td>SMALL TILDE (˜)

<tr><td>`99^X
<td>`2122^X
<td>TRADE MARK SIGN (™)

<tr><td>`9A^X
<td>`0161^X
<td>LATIN SMALL LETTER S WITH CARON (š)

<tr><td>`9B^X
<td>`203A^X
<td>SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (›)

<tr><td>`9C^X
<td>`0153^X
<td>LATIN SMALL LIGATURE OE (œ)

<tr><td>`9E^X
<td>`017E^X
<td>LATIN SMALL LETTER Z WITH CARON (ž)

<tr><td>`9F^X
<td>`0178^X
<td>LATIN CAPITAL LETTER Y WITH DIAERESIS (Ÿ)
</table>

			</dd>
		</dl>
	</li>
	<li>
`一時~buffer$V ~SET ~cp( `文字~参照~code$V )
◎
Set the temporary buffer to the empty string. Append a code point equal to the character reference code to the temporary buffer.＼
</li>
	<li>
`文字~参照として消費される~cpを一掃する$
◎
Flush code points consumed as a character reference.＼
</li>
	<li>
`戻先~状態$V に`切替える$
◎
Switch to the return state.
</li>
</ol>

				</section>
			</section>
			<section id="tree-construction">
<h4 title="Tree construction">13.2.6. 文書~treeの構築</h4>

<p>
~tree構築~段階には、
`~token化~段階$から~token列が入力される。
~tree構築~段階は、
構文解析器の作成-時に`文書$に結付けられる。
この段階の “出力” は、
当の文書［
を動的に改変する ／ の~DOM~treeを拡張する
］ことからなる。
◎
The input to the tree construction stage is a sequence of tokens from the tokenization stage. The tree construction stage is associated with a DOM Document object when a parser is created. The "output" of this stage consists of dynamically modifying or extending that document's DOM tree.
</p>

<p>
この仕様は、
ヤリトリありな~UAが いつ［
利用者に可用になるよう`文書$を具現化する必要があるか ／
利用者~入力を受容し始める必要がある
］かは，定義しない。
◎
This specification does not define when an interactive user agent has to render the Document so that it is available to the user, or when it has to begin accepting user input.
</p>

<hr>


<p>
この節を通して，
<dfn>現token</dfn>
は、
~tokenizerから発され，~tree構築~段階が現在~処理している~tokenを指すとする。
◎
↓</p>

<div class="algo">
<p>
~UAは、
~tokenizerから~tokenが発される度に，
`~tree構築~配送器@
（ `tree construction dispatcher^en ）と称される次の手続きに従うモノトスル：
◎
As each token is emitted from the tokenizer, the user agent must follow the appropriate steps from the following list, known as the tree construction dispatcher:
</p>

<ol>
	<li>
%~node ~LET `現在の調整-済み~node$
</li>
	<li>
<p>
~IF［
~OR↓
］…
◎
↓</p>

		<ul>
			<li>
`~open要素~stack$は空である
◎
If the stack of open elements is empty
</li>
			<li>
%~node は`~HTML名前空間$に属する要素である
◎
If the adjusted current node is an element in the HTML namespace
</li>
			<li>
［
%~node は`~MathML~text統合~地点$である
］~AND［
現tokenは開始~tag~tokenである
］~AND［
現tokenの~tag名 ~NIN { `mglyph^l, `malignmark^l }
］
◎
If the adjusted current node is a MathML text integration point and the token is a start tag whose tag name is neither "mglyph" nor "malignmark"
</li>
			<li>
［
%~node は`~MathML~text統合~地点$である
］~AND［
現tokenは文字~tokenである
］
◎
If the adjusted current node is a MathML text integration point and the token is a character token
</li>
			<li>
［
%~node は~MathML `annotation-xml$e 要素である
］~AND［
現tokenは開始~tag~tokenである
］~AND［
現tokenの~tag名 ~EQ `svg^l
］
◎
If the adjusted current node is a MathML annotation-xml element and the token is a start tag whose tag name is "svg"
</li>
			<li>
［
%~node は`~HTML統合~地点$である
］~AND［
現tokenは開始~tag~tokenである
］
◎
If the adjusted current node is an HTML integration point and the token is a start tag
</li>
			<li>
［
%~node は`~HTML統合~地点$である
］~AND［
現tokenは文字~tokenである
］
◎
If the adjusted current node is an HTML integration point and the token is a character token
</li>
			<li>
現tokenは~eof~tokenである
◎
If the token is an end-of-file token
</li>
		</ul>

<p>
…ならば
⇒
［
`~HTML内容~内の~token＠#parsing-main-inhtml$用の，
現在の`挿入~mode$に対応する節
］に与える規則に則って、
現tokenを処理する
◎
Process the token according to the rules given in the section corresponding to the current insertion mode in HTML content.
</p>
	</li>
	<li>
~ELSE
⇒
`外来~内容~内$md節に与える規則に則って、
現tokenを処理する
◎
Otherwise
◎
Process the token according to the rules given in the section for parsing tokens in foreign content.
</li>
</ol>
</div>

<p>
`次回の~token@
とは、
`~tree構築~配送器$により処理されようとしている~tokenを指す
（その~tokenは後続して，単に無視される場合もある）。
◎
The next token is the token that is about to be processed by the tree construction dispatcher (even if the token is subsequently just ignored).
</p>

<p class="trans-note">【
この訳では、
この用語は利用せず，
`次回の~LF文字~tokenは無視するようにしておく$
手続きに置き換えている。
その用途にしか利用されていないので。
】</p>

<p>
次に該当する~MathML要素~nodeは、
`~MathML~text統合~地点@
とされる
⇒
`mi$e, `mo$e, `mn$e, `ms$e, `mtext$e
◎
A node is a MathML text integration point if it is one of the following elements:
• A MathML mi element
• A MathML mo element
• A MathML mn element
• A MathML ms element
• A MathML mtext element
</p>

<p>
次に挙げるいずれかに該当する~nodeは、
`~HTML統合~地点@
とされる：
◎
A node is an HTML integration point if it is one of the following elements:
</p>

<ul>
	<li>
~MathML `annotation-xml$e 要素のうち，それを作成させた開始~tag~tokenが 次を満たす属性を有していたもの
⇒
［
名前 ~EQ `encoding^l 
］~AND［
値 ~IN`大小無視$sub { `text/html^l, `application/xhtml+xml^l }
］
◎
A MathML annotation-xml element whose start tag token had an attribute with the name "encoding" whose value was an ASCII case-insensitive match for the string "text/html"
◎
A MathML annotation-xml element whose start tag token had an attribute with the name "encoding" whose value was an ASCII case-insensitive match for the string "application/xhtml+xml"
</li>
	<li>
~SVG 
`foreignObject$e, `desc$e, `~title0$e
要素
◎
An SVG foreignObject element
An SVG desc element
An SVG title element
</li>
</ul>

<p class="note">注記：
~nodeが［
`~HTML素片の構文解析~algo$に渡された `文脈$V
］である場合、
その要素~用の開始~tag~tokenは，その~algo内で作成された “捏造” ~tokenである。
◎
If the node in question is the context element passed to the HTML fragment parsing algorithm, then the start tag token for that element is the "fake" token created during by that HTML fragment parsing algorithm.
</p>

<hr>

<p class="note">注記：
下に言及される~tag名には、
この仕様に適合tな~tag名にならないものもある
— その多くは、
旧来の内容を取扱うために含められている。
それらは、
依然として~algoの一部を形成する
— 適合性を主張する実装は、
それらを実装することが要求される。
◎
Not all of the tag names mentioned below are conformant tag names in this specification; many are included to handle legacy content. They still form part of the algorithm that implementations are required to implement to claim conformance.
</p>

<p class="note">注記：
以下に述べる~algoは、
生成される~DOM~treeの深さにも, ［
~tag名, 属性~名, 属性~値, `Text$I ~node, 等々
］の長さにも上限は設けない。
実装者には，
`恣意的な上限は避ける＠~INFRA#algorithm-limits$ことが奨励されるが、［
~UAは、
実施~上の懸念により，入子ngの深さに拘束を課すよう強いられる
］と見込まれることも認識されている。
◎
The algorithm described below places no limit on the depth of the DOM tree generated, or on the length of tag names, attribute names, attribute values, Text nodes, etc. While implementers are encouraged to avoid arbitrary limits, it is recognized that practical concerns will likely force user agents to impose nesting depth constraints.
</p>

				<section id="creating-and-inserting-nodes">
<h5 title="Creating and inserting nodes">13.2.6.1. ~nodeの作成-法と挿入-法</h5>

<p>
%構文解析器 は、
ある~tokenを処理している間，
`親を違える@
（ `foster parenting^en ）ことを［
可能化する／不能化する
］こともある。
これは、
次の~algoに影響する。
◎
While the parser is processing a token, it can enable or disable foster parenting. This affects the following algorithm.
</p>

<div class="algo">
<p>
`適切な~node挿入-先@
は、
所与の
( `上書き~target^i %~target )
に対し，次の手続きを走らせた結果で与えられる［
ある要素~内の位置
］である：
◎
The appropriate place for inserting a node, optionally using a particular override target, is the position in an element returned by running the following steps:
• If there was an override target specified, then let target be the override target.
• Otherwise, let target be the current node.
</p>

<ol>
	<li>
%調整-済み挿入-先 ~LET %~target 内の末尾
◎
↓↓</li>
	<li class="algo">
<p>
~IF［
`親を違える$ことは可能化されている
］~AND［
%~target は［
`table$e ／ `tbody$e ／ `tfoot$e ／ `thead$e ／ `tr$e
］要素である
⇒
%調整-済み挿入-先 ~SET 次の手続きを走らせた結果：
◎
Determine the adjusted insertion location using the first matching steps from the following list:
◎
If foster parenting is enabled and target is a table, tbody, tfoot, thead, or tr element
</p>

<p class="note">注記：
親を違えるのは、
ある内容が~table内に誤入子にされたときに起こる。
◎
Foster parenting happens when content is misnested in tables.
◎
Run these substeps:
</p>
		<ol>
			<li>
%~stack ~LET `~open要素~stack$
◎
↓</li>
			<li>
%最後の~template ~LET %~stack 内に `template$e 要素が［
在るならば それらのうち最後のもの ／
無いならば ε
］
◎
Let last template be the last template element in the stack of open elements, if any.
</li>
			<li>
%最後の~table ~LET %~stack 内に `table$e 要素が［
在るならば それらのうち最後のもの ／
無いならば ε
］
◎
Let last table be the last table element in the stack of open elements, if any.
</li>
			<li>
~IF［
%最後の~template ~NEQ ε
］
⇒
~IF［［
%最後の~table ~EQ ε
］~OR［［
%最後の~table ~NEQ ε
］~AND［
%最後の~template は %~stack 内で %最後の~table より後に在る（より近過去に追加された）
］］］
⇒
~RET %最後の~template の`~template内容$内の末尾
◎
If there is a last template and either there is no last table, or there is one, but last template is lower (more recently added) than last table in the stack of open elements, then: let adjusted insertion location be inside last template's template contents, after its last child (if any), and abort these steps.
</li>
			<li>
~IF［
%最後の~table ~EQ ε 
（`素片~事例$）
］
⇒
~RET %~stack の先頭にある要素（ `html$e 要素）内の末尾
◎
If there is no last table, then let adjusted insertion location be inside the first element in the stack of open elements (the html element), after its last child (if any), and abort these steps. (fragment case)
</li>
			<li>
~IF［
%最後の~table の親~node %親 はある
］
⇒
~RET %親 の内側の， %最後の~table の直前
◎
If last table has a parent node, then let adjusted insertion location be inside last table's parent node, immediately before last table, and abort these steps.
</li>
			<li>
~RET［
%~stack 内で， %最後の~table の直前に在る要素
］内の末尾
◎
Let previous element be the element immediately above last table in the stack of open elements.
◎
Let adjusted insertion location be inside previous element, after its last child (if any).
</li>
		</ol>

<p class="note">注記：
これら一連の段が孕まれているわけは、
要素
— この事例では特に `table$e 要素 —
が構文解析器により挿入された後でも，［
~scriptにより~DOM内のどこかへ移動される／
まるごと~DOMから除去される
］こともあり得るためである。
◎
These steps are involved in part because it's possible for elements, the table element in this case in particular, to have been moved by a script around in the DOM, or indeed removed from the DOM entirely, after the element was inserted by the parser.
</p>
	</li>
	<li>
~IF［
%調整-済み挿入-先 が所属する~nodeは `template$e 要素である
］
⇒
~RET `template$e 要素の`~template内容$内の末尾
◎
Otherwise
• Let adjusted insertion location be inside target, after its last child (if any).
◎
If the adjusted insertion location is inside a template element, let it instead be inside the template element's template contents, after its last child (if any).
</li>
	<li>
~RET %調整-済み挿入-先
◎
Return the adjusted insertion location.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~tokenから要素を作成する@
~algoは、
所与の
( ~token %~token, 文字列 %名前空間, `~node$ %意図される親 )
に対し：
◎
To create an element for a token, given a token token, a string namespace, and a Node object intendedParent:
</p>
<ol>
	<li>
~IF［
`作動中な投機的な~HTML構文解析器$ ~NEQ ~NULL
］
⇒
~RET `投機的な模擬~要素を作成する$( %名前空間, %~token の~tag名, %~token の属性~list )
◎
If the active speculative HTML parser is not null, then return the result of creating a speculative mock element given namespace, token's tag name, and token's attributes.
</li>
	<li>
<p>
~ELSE
⇒
任意選択で
⇒
`投機的な模擬~要素を作成する$( %名前空間, %~token の~tag名, %~token の属性~list )
◎
Otherwise, optionally create a speculative mock element given namespace, token's tag name, and token's attributes.
</p>

<p class="note">注記：
結果は利用されない。
この段は、［
投機的でない構文解析から`投機的な~fetch$を起動する
］のを許容するためにある。
その~fetchは、
この時点では依然として投機的である
— 例えば，［
%意図される親 は、
当の要素が挿入されるまでに，文書から除去される
］かもしれないので。
◎
The result is not used. This step allows for a speculative fetch to be initiated from non-speculative parsing. The fetch is still speculative at this point, because, for example, by the time the element is inserted, intended parent might have been removed from the document.
</p>
	</li>
	<li>
%文書 ~LET %意図される親 の`~node文書$
◎
Let document be intendedParent's node document.
</li>
	<li>
%局所~名 ~LET %~token の~tag名
◎
Let localName be token's tag name.
</li>
	<li>
%is ~LET %~token 内に `is$a 属性が［
在るならば その値 ／
無いならば ~NULL
］
◎
Let is be the value of the "is" attribute in token, if such an attribute exists; otherwise null.
</li>
	<li>
%~registry ~LET `~custom要素~registryを検索する$( %意図される親 )
◎
Let registry be the result of looking up a custom element registry given intendedParent.
</li>
	<li>
%定義 ~LET `~custom要素~定義を検索する$( %~registry, %名前空間, %局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given registry, namespace, localName, and is.
</li>
	<li>
%~scriptを実行するか ~LET ~IS［
%定義 ~NEQ ~NULL 
］~AND［
%構文解析器 は`~HTML素片~用$でない
］
◎
Let willExecuteScript be true if definition is non-null and the parser was not created as part of the HTML fragment parsing algorithm; otherwise false.
</li>
	<li>
<p>
~IF［
%~scriptを実行するか ~EQ ~T
］：
◎
If willExecuteScript is true:
</p>

		<ol>
			<li>
%文書 の`動的~markup挿入-時には投出する~counter$ ~INCBY 1
◎
Increment document's throw-on-dynamic-markup-insertion counter.
</li>
			<li>
~IF［
`~JS実行~文脈~stack$は空である
］
⇒
`小task~checkpointを遂行する$
◎
If the JavaScript execution context stack is empty, then perform a microtask checkpoint.
</li>
			<li>
%文書 に`関連な~agent$の`~custom要素~反応~stack$に新たな`要素~queue$を~pushする
◎
Push a new element queue onto document's relevant agent's custom element reactions stack.
</li>
		</ol>
	</li>
	<li>
<p>
%要素 ~LET `要素を作成する$( ↓ )
⇒＃
%文書,
%局所~名,
%名前空間,
~NULL,
%is,
%~scriptを実行するか,
%~registry
◎
Let element be the result of creating an element given document, localName, namespace, null, is, willExecuteScript, and registry.
</p>

<p class="note">注記：
これは、［
%~scriptを実行するか ~EQ ~T
］ならば`~custom要素~構築子$を走らすことになる。
しかしながら，`動的~markup挿入-時には投出する~counter$を増やしたので、
これにより，［
`~tokenizerの中に新たな文字が挿入される＠~HTMLdynamic#dom-document-write$ ／
`文書が吹飛ばされる＠~HTMLdynamic#dom-document-open$
］ことはない。
◎
This will cause custom element constructors to run, if willExecuteScript is true. However, since we incremented the throw-on-dynamic-markup-insertion counter, this cannot cause new characters to be inserted into the tokenizer, or the document to be blown away.
</p>
	</li>
	<li>
<p>
%~token の属性~listを成す
~EACH( %属性 )
に対し
⇒
`属性を付加する$( %属性, %要素 )
◎
Append each attribute in the given token to element.
</p>

<p class="note">注記：
これは、
`attributeChangedCallback^c 用の`~custom要素~callback反応を~enqueueする$こともある
— それは、
（次~段にて）即時に走るかもしれない。
◎
This can enqueue a custom element callback reaction for the attributeChangedCallback, which might run immediately (in the next step).
</p>

<p class="note">注記：
`is$a 属性は，`~custom化された組込みの要素$の`作成$elemを統治するが、
関連な`~custom要素~構築子$を実行する間は，まだ無い
— それは、
この段にて，他の属性とともに付加されるので。
◎
Even though the is attribute governs the creation of a customized built-in element, it is not present during the execution of the relevant custom element constructor; it is appended in this step, along with all other attributes.
</p>
	</li>
	<li>
<p>
~IF［
%~scriptを実行するか ~EQ ~T
］：
◎
If willExecuteScript is true:
</p>
		<ol>
			<li>
%~queue ~LET %文書 に`関連な~agent$の`~custom要素~反応~stack$から~popする
（これは、
上で~pushしたものと同じ`要素~queue$になる。）
◎
Let queue be the result of popping from document's relevant agent's custom element reactions stack. (This will be the same element queue as was pushed above.)
</li>
			<li>
`~custom要素~反応を呼出す$( %~queue )
◎
Invoke custom element reactions in queue.
</li>
			<li>
%文書 の`動的~markup挿入-時には投出する~counter$ ~DECBY 1
◎
Decrement document's throw-on-dynamic-markup-insertion counter.
</li>
		</ol>
	</li>
	<li>
~IF［
%要素 は`~XMLNS名前空間$に属する `xmlns^a 属性を有していて，その値 ~NEQ %要素 の`名前空間$el
］
⇒
`~perror$
◎
If element has an xmlns attribute in the XMLNS namespace whose value is not exactly the same as the element's namespace, that is a parse error.＼
</li>
	<li>
~IF［
%要素 は`~XMLNS名前空間$に属する `xmlns:xlink^a 属性を有していて，その値 ~NEQ `~XLink名前空間$
］
⇒
`~perror$
◎
Similarly, if element has an xmlns:xlink attribute in the XMLNS namespace whose value is not the XLink Namespace, that is a parse error.
</li>
	<li>
~IF［
%要素 は`再設定-可能な要素$である
］~AND［
%要素 は`~formに所有され得る~custom要素$でない
］
⇒
%要素 を`再設定する~algo$を呼出す
（これは、
%要素 の属性に基いて，
%要素 の［
`値$fe, `~check有りか$fe
］を初期化する。）
◎
If element is a resettable element and not a form-associated custom element, then invoke its reset algorithm. (This initializes the element's value and checkedness based on the element's attributes.)
</li>
	<li>
%form ~LET `~form要素~pointer$
◎
↓</li>
	<li>
<p>
~IF［
~AND↓
］…
◎
If＼
</p>
		<ul>
			<li>
%要素 は`~formに所有され得る要素$である
◎
element is a form-associated element＼
</li>
			<li>
%要素 は`~formに所有され得る~custom要素$でない
◎
and not a form-associated custom element,＼
</li>
			<li>
%form ~NEQ ~NULL
◎
the form element pointer is not null,＼
</li>
			<li>
`~open要素~stack$内に `template$e 要素は無い
◎
there is no template element on the stack of open elements,＼
</li>
			<li>
［
%要素 は`~listされる要素$でない
］~OR［
%要素 は `form$a 属性を有さない
］
◎
element is either not listed or doesn't have a form attribute,＼
</li>
			<li>
( %form, %意図される親 ) は同じ`~tree$内に在る
◎
and the intendedParent is in the same tree as the element pointed to by the form element pointer,＼
</li>
		</ul>
<p>
…ならば：
◎
then＼
</p>
		<ol>
			<li>
%要素 の`~form所有者$ ~SET %form
◎
associate element with the form element pointed to by the form element pointer and＼
</li>
			<li>
%要素 の`構文解析器が挿入したか$ ~SET ~T
◎
set element's parser inserted flag.
</li>
		</ol>
	</li>
	<li>
~RET %要素
◎
Return element.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`要素を調整-済み挿入-先に挿入する@
~algoは、
所与の
( 要素, %要素 )
に対し：
◎
To insert an element at the adjusted insertion location with an element element:
</p>
<ol>
	<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$
◎
Let the adjusted insertion location be the appropriate place for inserting a node.
</li>
	<li>
~IF［
%要素 は %調整-済み挿入-先 に挿入-可能でない
【下の注記を見よ】
］
⇒
~RET
◎
If it is not possible to insert element at the adjusted insertion location, abort these steps.
</li>
	<li>
~IF ［
%構文解析器 は`~HTML素片~用$でない
］
⇒
%要素 に`関連な~agent$の`~custom要素~反応~stack$に新たな`要素~queue$を~pushする
◎
If the parser was not created as part of the HTML fragment parsing algorithm, then push a new element queue onto element's relevant agent's custom element reactions stack.
</li>
	<li>
%要素 を %調整-済み挿入-先 に挿入する
◎
Insert element at the adjusted insertion location.
</li>
	<li>
<p>
~IF［
%構文解析器 は`~HTML素片~用$でない
］：
</p>
		<ol>
			<li>
%要素~queue ~LET %要素 に`関連な~agent$の`~custom要素~反応~stack$から`要素~queue$を~popする
</li>
			<li>
`~custom要素~反応を呼出す$( %要素~queue )
</li>
		</ol>
◎
If the parser was not created as part of the HTML fragment parsing algorithm, then pop the element queue from element's relevant agent's custom element reactions stack, and invoke custom element reactions in that queue.
</li>
</ol>

<p class="note">注記：
%調整-済み挿入-先 がそれ以上~要素を受容できない場合、
%要素 は弾き出される
— 例えば、
そこは すでに ある要素を子に有している`文書$内である場合。
【すなわち、挿入すると~DOM~treeに課される拘束を満たせなくなる場合。】
◎
If the adjusted insertion location cannot accept more elements, e.g., because it's a Document that already has an element child, then element is dropped on the floor.
</p>
</div>

<div class="algo">
<p>
`要素を挿入する@
~algoは、
所与の
⇒＃
~token %~token,
文字列 %名前空間 ~DF `~HTML名前空間$,
真偽値 %要素~stackのみに追加するか ~DF ~F
◎終
に対し：
◎
To insert a foreign element, given a token token, a string namespace, and a boolean onlyAddToElementStack:
</p>
<ol>
	<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$( `現在の~node$ )
◎
Let the adjustedInsertionLocation be the appropriate place for inserting a node.
</li>
	<li>
%要素 ~LET `~tokenから要素を作成する$( %~token, %名前空間, %調整-済み挿入-先 が所属する要素 )
◎
Let element be the result of creating an element for the token given token, namespace, and the element in which the adjustedInsertionLocation finds itself.
</li>
	<li>
~IF［
%要素~stackのみに追加するか ~EQ ~F
］
⇒
`要素を調整-済み挿入-先に挿入する$( %要素 )
◎
If onlyAddToElementStack is false, then run insert an element at the adjusted insertion location with element.
</li>
	<li>
`~open要素~stack$に %要素 を~pushする
◎
Push element onto the stack of open elements so that it is the new current node.
</li>
	<li>
~RET %要素
◎
Return element.
</li>
</ol>

<div>
<p class="trans-note">【
この訳では、
原文による 2 つの手続き［
`外来な要素を挿入する@,
`~HTML要素を挿入する@
］を この手続きに集約して，命名を簡素化する
（これらは順に，この手続きにて %名前空間 を［
明示的に与えた場合, 省略した場合
］に対応する）。
】</p>
◎
To insert an HTML element given a token token: insert a foreign element given token, the HTML namespace, and false.
</div>
</div>

<hr>

<div class="algo">
<p>
`~MathML属性たちを調整する@
~algoは、
所与の
( %~token )
に対し
⇒
%~token の属性~listを成す
~EACH( %属性 )
に対し
⇒
~IF［
%属性 の名前 ~EQ `definitionurl^l
］
⇒
%属性 の名前 ~SET `definitionURL^l
◎
When the steps below require the user agent to adjust MathML attributes for a token, then, if the token has an attribute named definitionurl, change its name to definitionURL (note the case difference).
</p>
</div>

<div class="algo">
<p>
`~SVG属性たちを調整する@
~algoは、
所与の
( %~token )
に対し
⇒
%~token の属性~listを成す
~EACH( %属性 )
に対し
⇒
~IF［
%属性 の名前 ~IN { 次の表tの 1 列目に挙げる名前 }
］
⇒
%属性 の名前 ~SET 同じ行の 2 列目に与えられる名前
（これは、すべて小文字ではない~SVG属性の文字大小を修正する）
◎
When the steps below require the user agent to adjust SVG attributes for a token, then, for each attribute on the token whose attribute name is one of the ones in the first column of the following table, change the attribute's name to the name given in the corresponding cell in the second column. (This fixes the case of SVG attributes that are not all lowercase.)
</p>

<table><thead>
<tr><th>
~token上の属性~名
◎
Attribute name on token
<th>
要素~上の属性~名
◎
Attribute name on element
<tbody>

<tr><td>`attributename^c
<td>`attributeName^c

<tr><td>`attributetype^c
<td>`attributeType^c

<tr><td>`basefrequency^c
<td>`baseFrequency^c

<tr><td>`baseprofile^c
<td>`baseProfile^c

<tr><td>`calcmode^c
<td>`calcMode^c

<tr><td>`clippathunits^c
<td>`clipPathUnits^c

<tr><td>`diffuseconstant^c
<td>`diffuseConstant^c

<tr><td>`edgemode^c
<td>`edgeMode^c

<tr><td>`filterunits^c
<td>`filterUnits^c

<tr><td>`glyphref^c
<td>`glyphRef^c

<tr><td>`gradienttransform^c
<td>`gradientTransform^c

<tr><td>`gradientunits^c
<td>`gradientUnits^c

<tr><td>`kernelmatrix^c
<td>`kernelMatrix^c

<tr><td>`kernelunitlength^c
<td>`kernelUnitLength^c

<tr><td>`keypoints^c
<td>`keyPoints^c

<tr><td>`keysplines^c
<td>`keySplines^c

<tr><td>`keytimes^c
<td>`keyTimes^c

<tr><td>`lengthadjust^c
<td>`lengthAdjust^c

<tr><td>`limitingconeangle^c
<td>`limitingConeAngle^c

<tr><td>`markerheight^c
<td>`markerHeight^c

<tr><td>`markerunits^c
<td>`markerUnits^c

<tr><td>`markerwidth^c
<td>`markerWidth^c

<tr><td>`maskcontentunits^c
<td>`maskContentUnits^c

<tr><td>`maskunits^c
<td>`maskUnits^c

<tr><td>`numoctaves^c
<td>`numOctaves^c

<tr><td>`pathlength^c
<td>`pathLength^c

<tr><td>`patterncontentunits^c
<td>`patternContentUnits^c

<tr><td>`patterntransform^c
<td>`patternTransform^c

<tr><td>`patternunits^c
<td>`patternUnits^c

<tr><td>`pointsatx^c
<td>`pointsAtX^c

<tr><td>`pointsaty^c
<td>`pointsAtY^c

<tr><td>`pointsatz^c
<td>`pointsAtZ^c

<tr><td>`preservealpha^c
<td>`preserveAlpha^c

<tr><td>`preserveaspectratio^c
<td>`preserveAspectRatio^c

<tr><td>`primitiveunits^c
<td>`primitiveUnits^c

<tr><td>`refx^c
<td>`refX^c

<tr><td>`refy^c
<td>`refY^c

<tr><td>`repeatcount^c
<td>`repeatCount^c

<tr><td>`repeatdur^c
<td>`repeatDur^c

<tr><td>`requiredextensions^c
<td>`requiredExtensions^c

<tr><td>`requiredfeatures^c
<td>`requiredFeatures^c

<tr><td>`specularconstant^c
<td>`specularConstant^c

<tr><td>`specularexponent^c
<td>`specularExponent^c

<tr><td>`spreadmethod^c
<td>`spreadMethod^c

<tr><td>`startoffset^c
<td>`startOffset^c

<tr><td>`stddeviation^c
<td>`stdDeviation^c

<tr><td>`stitchtiles^c
<td>`stitchTiles^c

<tr><td>`surfacescale^c
<td>`surfaceScale^c

<tr><td>`systemlanguage^c
<td>`systemLanguage^c

<tr><td>`tablevalues^c
<td>`tableValues^c

<tr><td>`targetx^c
<td>`targetX^c

<tr><td>`targety^c
<td>`targetY^c

<tr><td>`textlength^c
<td>`textLength^c

<tr><td>`viewbox^c
<td>`viewBox^c

<tr><td>`viewtarget^c
<td>`viewTarget^c

<tr><td>`xchannelselector^c
<td>`xChannelSelector^c

<tr><td>`ychannelselector^c
<td>`yChannelSelector^c

<tr><td>`zoomandpan^c
<td>`zoomAndPan^c
</table>
</div>

<div class="algo">
<p>
`外来な属性たちを調整する@
~algoは、
所与の
( %~token )
に対し
⇒
%~token の属性~listを成す
~EACH( %属性 )
に対し
⇒
~IF［
%属性 は次の表tのある行の 1 列目に与える文字列に合致する
］
⇒
%属性 ~SET 同じ行の ( 2, 3, 4 ) 列目に与える
( 接頭辞, 局所~名, 名前空間 )
を伴う名前空間~付きの属性
◎
When the steps below require the user agent to adjust foreign attributes for a token, then, if any of the attributes on the token match the strings given in the first column of the following table, let the attribute be a namespaced attribute, with the prefix being the string given in the corresponding cell in the second column, the local name being the string given in the corresponding cell in the third column, and the namespace being the namespace given in the corresponding cell in the fourth column.＼
</p>

<p>
（これは、
名前空間~付きの属性の利用
— 特に，
<a href="~TR/xml/#sec-lang-tag">~XML名前空間に属する `lang^a 属性</a> —
を修正する。）
◎
(This fixes the use of namespaced attributes, in particular lang attributes in the XML namespace.)
</p>

<table><thead>
<tr><th>
属性~名
◎
Attribute name
<th>接頭辞
◎
Prefix
<th>局所~名
◎
Local name
<th>名前空間
◎
Namespace
<tbody>

<tr><td>`xlink:actuate^l
<td>`xlink^l
<td>`actuate^l
<td>`~XLink名前空間$

<tr><td>`xlink:arcrole^l
<td>`xlink^l
<td>`arcrole^l
<td>`~XLink名前空間$

<tr><td>`xlink:href^l
<td>`xlink^l
<td>`href^l
<td>`~XLink名前空間$

<tr><td>`xlink:role^l
<td>`xlink^l
<td>`role^l
<td>`~XLink名前空間$

<tr><td>`xlink:show^l
<td>`xlink^l
<td>`show^l
<td>`~XLink名前空間$

<tr><td>`xlink:title^l
<td>`xlink^l
<td>`title^l
<td>`~XLink名前空間$

<tr><td>`xlink:type^l
<td>`xlink^l
<td>`type^l
<td>`~XLink名前空間$

<tr><td>`xml:lang^l
<td>`xml^l
<td>`lang^l
<td>`~XML名前空間$

<tr><td>`xml:space^l
<td>`xml^l
<td>`space^l
<td>`~XML名前空間$

<tr><td>`xmlns^l
<td>（なし）
◎
(none)
<td>`xmlns^l
<td>`~XMLNS名前空間$

<tr><td>`xmlns:xlink^l
<td>`xmlns^l
<td>`xlink^l
<td>`~XMLNS名前空間$
</table>
</div>

<hr>

<div class="algo">
<p>
`文字を挿入する@
~algoは、
所与の
( %文字 )
に対し：
◎
When the steps below require the user agent to insert a character while processing a token, the user agent must run the following steps:
</p>

<ol>
	<li>
%~data ~LET %文字
◎
Let data be the characters passed to the algorithm, or, if no characters were explicitly specified, the character of the character token being processed.
</li>
	<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$( `現在の~node$ )
◎
Let the adjusted insertion location be the appropriate place for inserting a node.
</li>
	<li>
<p>
~IF［
%調整-済み挿入-先 が所属する~nodeは`文書$である
］
⇒
~RET
◎
If the adjusted insertion location is in a Document node, then return.
</p>

<p class="note">注記：
~DOMの~~制約により、
`Text$I ~nodeは，`文書$の子になれないので弾き出される。
◎
The DOM will not let Document nodes have Text node children, so they are dropped on the floor.
</p>

	</li>
	<li>
~IF［
%調整-済み挿入-先 の直前に `Text$I ~nodeは在る
］
⇒
その~nodeの`~data$cdに %~data を付加する
◎
If there is a Text node immediately before the adjusted insertion location, then append data to that Text node's data.
</li>
	<li>
<p>
~ELSE：
</p>
		<ol>
			<li>
%text ~LET 新たな `Text$I ~node
— その
⇒＃
`~data$cd ~SET %~data,
`~node文書$ ~SET %調整-済み挿入-先 が所属する要素の`~node文書$
</li>
			<li>
%text を %調整-済み挿入-先 に挿入する
</li>
		</ol>
◎
Otherwise, create a new Text node whose data is data and whose node document is the same as that of the element in which the adjusted insertion location finds itself, and insert the newly created node at the adjusted insertion location.
</li>
</ol>
</div>

<div class="example">
<p>
構文解析器への見本~入力と生成される~DOM内の対応する `Text$I ~nodeを，以下にいくつか挙げる
— ここでは、
~UAは~scriptを実行すると見做す：
◎
Here are some sample inputs to the parser and the corresponding number of Text nodes that they result in, assuming a user agent that executes scripts.
</p>

<table class="grid-table" id="_text-node-sample1"><thead>
<tr><th>
入力
◎
Input
<th>
`Text$I ~nodeの個数
◎
Number of Text nodes
<tbody>

<tr><td>
`text-node-1^xCode

<td>
1 個の `Text$I ~node：
`AB^l を包含する。
◎
One Text node in the document, containing "AB".

<tr><td>
`text-node-2^xCode

<td>
3 個の `Text$I ~node：
順に［
`script^e の前に `A^l,
`script^e の内容,
`script^e の後に `BC^l
］を包含する
（構文解析器は、
~scriptが作成した `Text$I ~nodeを付加する）。
◎
Three Text nodes; "A" before the script, the script's contents, and "BC" after the script (the parser appends to the Text node created by the script).

<tr><td>
`text-node-3^xCode

<td>
2 個の `Text$I ~node：
この 2 個は隣接し，順に `A^l, `BC^l を包含する。
◎
Two adjacent Text nodes in the document, containing "A" and "BC".

<tr><td>
`text-node-4^xCode

<td>
1 個の `Text$I ~node：
`table^e の前にあり， `ABCD^l を包含する
（これは、
`親を違える$ことにより生じる）。
◎
One Text node before the table, containing "ABCD". (This is caused by foster parenting.)

<tr><td>
`text-node-5^xCode

<td>
1 個の `Text$I ~node：
`table^e の前にあり，
`A B C^l （ A-space-B-space-C ）を包含する
（これは、
`親を違える$ことにより生じる）。
◎
One Text node before the table, containing "A B C" (A-space-B-space-C). (This is caused by foster parenting.)

<tr><td>
`text-node-6^xCode

<td>
2 個の `Text$I ~node：
1 個目は `table^e の前にあり，
`A BC^l （ A-space-B-C ）を包含する。
2 個目は `table^e の内側に（ `tbody$e の子として）あり，
1 個の~space文字を包含する。
（~space文字は、
文字~tokenでない~token
【ここでは `&lt;/em&gt;^l 】
により~spaceでない文字から分離される場合には，`親を違える$ことにより影響されない
— その後，分離している~tokenが無視されることになる場合でも。）
◎
One Text node before the table, containing "A BC" (A-space-B-C), and one Text node inside the table (as a child of a tbody) with a single space character. (Space characters separated from non-space characters by non-character tokens are not affected by foster parenting, even if those other tokens then get ignored.)
</table>
</div>

<hr>

<div class="algo">
<p>
`~commentを挿入する@
~algoは、
所与の
( ~comment~token %~comment~token【！comment】, 挿入~位置 %位置 ~DF ε )
に対し：
</p>

<ol>
	<li>
~IF［
%位置 ~EQ ε
］
⇒
%位置 ~SET `適切な~node挿入-先$( `現在の~node$ )
</li>
	<li>
%comment ~LET 新たな `Comment$I ~node
— その
⇒＃
`~data$cd【！data attribute】 ~SET %~comment~token の~data,
`~node文書$ ~SET %位置 が所属する~nodeの`~node文書$
</li>
	<li>
%comment を %位置 に挿入する
</li>
</ol>
◎
When the steps below require the user agent to insert a comment while processing a comment token, optionally with an explicit insertion position position, the user agent must run the following steps:
• Let data be the data given in the comment token being processed.
• If position was specified, then let the adjusted insertion location be position. Otherwise, let adjusted insertion location be the appropriate place for inserting a node.
• Create a Comment node whose data attribute is set to data and whose node document is the same as that of the node in which the adjusted insertion location finds itself.
• Insert the newly created node at the adjusted insertion location.
</div>

				</section>
				<section id="parsing-elements-that-contain-only-text">
<h5 title="Parsing elements that contain only text">13.2.6.2. ~textのみを包含する要素の構文解析</h5>

<div class="algo">
<p>
［
`生~text要素の汎用~構文解析~algo@
／
`~RCDATA要素の汎用~構文解析~algo@
］は、
所与の
( 開始~tag~token %~token )
に対し：
◎
The generic raw text element parsing algorithm and the generic RCDATA element parsing algorithm consist of the following steps. These algorithms are always invoked in response to a start tag token.
</p>

<ol>
	<li>
`要素を挿入する$( %~token )
◎
Insert an HTML element for the token.
</li>
	<li>
%次回の状態 ~LET ［
`生~text要素の汎用~構文解析~algo$用には `~RAWTEXT$st ／
`~RCDATA要素の汎用~構文解析~algo$用には `~RCDATA$st
］
◎
If the algorithm that was invoked is the generic raw text element parsing algorithm, switch the tokenizer to the RAWTEXT state; otherwise the algorithm invoked was the generic RCDATA element parsing algorithm,＼
</li>
	<li>
~tokenizerを %次回の状態 に`切替える$
◎
switch the tokenizer to the RCDATA state.
</li>
	<li>
`元の挿入~mode$V ~SET 現在の`挿入~mode$
◎
Set the original insertion mode to the current insertion mode.
</li>
	<li>
`挿入~mode$ ~SET `~text$md
◎
Then, switch the insertion mode to "text".
</li>
</ol>
</div>

				</section>
				<section id="closing-elements-that-have-implied-end-tags">
<h5 title="Closing elements that have implied end tags">13.2.6.3. 暗黙な終了~tagを有する要素を閉じるとき</h5>

<div class="algo">
<p>
`暗黙な終了~tagたちを生成する@
~algoは、
所与の
( 要素~型 %除外-~node型 ~DF ε )
に対し
⇒
~WHILE［
`現在の~node$の要素~型は［
`dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e
］のいずれかであって %除外-~node型 ではない
］
⇒
`~open要素~stack$から~popする
◎
When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.
◎
If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.
</p>
</div>

<div class="algo">
<p>
`暗黙な終了~tagすべてを生成する@
~algoは
⇒
~WHILE［
`現在の~node$の要素~型は［
`caption$e, `colgroup$e, `dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e, `tbody$e, `td$e, `tfoot$e, `th$e, `thead$e, `tr$e
］のいずれかである
］
⇒
`~open要素~stack$から~popする
◎
When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.
</p>
</div>

				</section>
				<section id="_closing-end-tags">
<h5>13.2.6.X. 要素を閉じるとき</h5>

<p class="trans-note">【
次に与える手続きは、
以下を簡潔に記述するために，この訳に導入している。
これは、
~DOMにおいて，当の要素とその子孫が成す~treeを “閉じる” ことに相当する。
】</p>

<div class="algo">
<p>
所与の %条件 を満たす要素が
`出るまで~open要素~stackから~popする@
~algoは
— ここで、
%条件 として：
</p>
<ul>
	<li>
1 個以上の要素~型が与えられた場合
（例： “`div^e 要素が出るまで…”）
⇒
%条件 は
“それらのうち, いずれかの要素~型である”
と解釈する。
</li>
	<li>
ある要素~instanceが与えられた場合
⇒
%条件 は
“その要素と同じ~instance”
と解釈する。
</li>
</ul>

<ol>
	<li>
~Assert：
`~open要素~stack$内には %条件 を満たす要素は在る
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%要素 ~LET `~open要素~stack$から~popした結果
</li>
			<li>
~IF［
%要素 は %条件 を満たす
］
⇒
~BREAK
</li>
		</ol>
	</li>
</ol>
</div>

				</section>
				<section id="parsing-main-inhtml">
<h5 title="The rules for parsing tokens in HTML content">13.2.6.4. ~HTML内容~内の~tokenを構文解析するための規則</h5>

					<section id="the-initial-insertion-mode">
<h6 title="The &quot;initial&quot; insertion mode">13.2.6.4.1. `初期^md</h6>

<p>
各 `文書$には
`構文解析器は~modeを変更できないか@
が結付けられる
— それは、
真偽値をとり，初期~時は ~F 【 “変更できる” 】とする。
◎
A Document object has an associated parser cannot change the mode flag (a boolean). It is initially false.
</p>

<p>
［
`挿入~mode$ ~EQ `初期$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "initial" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>現tokenは無視する
</li></ol>
◎
Ignore the token.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
		<ol>
			<li>
%名前 ~LET 現~token（すなわち，現在の~DOCTYPE~token）の名前
◎
↓</li>
			<li>
%~publicID ~LET 現~tokenの~publicID
◎
↓</li>
			<li>
%~systemID ~LET 現~tokenの~systemID
◎
↓</li>
			<li>
~IF［
%名前 ~NEQ `html^l
］~OR［
%~publicID ~NEQ ε
］~OR［
%~systemID ~NIN { ε, `about:legacy-compat＠~HTMLurl#about:legacy-compat$l }
］
⇒
`~perror$
◎
If the DOCTYPE token's name is not "html", or the token's public identifier is not missing, or the token's system identifier is neither missing nor "about:legacy-compat", then there is a parse error.
</li>
			<li>
<p>
%doctype ~LET 新たな `DocumentType$I ~node
— その：
◎
Append a DocumentType node to the Document node, with＼
</p>
				<ul>
					<li>
`名前$dT ~SET ［
%名前 ~NEQ ε ならば %名前 ／
~ELSE_ 空~文字列
］
◎
its name set to the name given in the DOCTYPE token, or the empty string if the name was missing;＼
</li>
					<li>
`公な~ID$dT ~SET ［
%~publicID ~NEQ ε ならば %~publicID ／
~ELSE_ 空~文字列
］
◎
its public ID set to the public identifier given in the DOCTYPE token, or the empty string if the public identifier was missing;＼
</li>
					<li>
`~system~ID$dT ~SET ［
%~systemID ~NEQ ε ならば %~systemID ／
~ELSE_ 空~文字列
］
◎
and its system ID set to the system identifier given in the DOCTYPE token, or the empty string if the system identifier was missing.
</li>
				</ul>

<p class="note">注記：
これはまた、
当の `DocumentType$I ~nodeは［
当の`文書$の `doctype$m 属性の値として返される
］ことを確保する。
◎
This also ensures that the DocumentType node is returned as the value of the doctype attribute of the Document object.
</p>
			</li>
			<li>
`文書$に %doctype を付加する
◎
↑＼</li>
			<li>
`文書$に %doctype を結付けて，
`文書$の `doctype$m 属性が値 %doctype を返すようにする
◎
Associate the DocumentType node with the Document object so that it is returned as the value of the doctype attribute of the Document object.
</li>
			<li>
<div>
<p id="quirks-mode-doctypes">
~IF［
`文書$は`~iframe-srcdoc文書$でない
］~AND［
`文書$の`構文解析器は~modeを変更できないか$ ~EQ ~F
］：
</p>
				<ol>
					<li>
~IF［
現~tokenは、
下の `quirks 条件^i に挙げるいずれかの条件を満たす
］
⇒
`文書$の`~mode$doc ~SET `quirks^l
</li>
					<li>
~ELIF［
現~tokenは、
下の `limited-quirks 条件^i に挙げるいずれかの条件を満たす
］
⇒
`文書$の`~mode$doc ~SET `limited-quirks^l
</li>
				</ol>
◎
↓</div>

<p>
`quirks 条件^i：
◎
Then, if the document is not an iframe srcdoc document, and the parser cannot change the mode flag is false, and the DOCTYPE token matches one of the conditions in the following list, then set the Document to quirks mode:
</p>
				<ul>
					<li>
`過去互換を強制するか$ ~EQ ~T
◎
The force-quirks flag is set to on.
</li>
					<li>
%名前 ~NEQ `html^l
◎
The name is not "html".
</li>
					<li>
%~publicID は 次に挙げるいずれかの文字列に合致する
⇒＃
`-//W3O//DTD W3 HTML Strict 3.0//EN//^l,
`-/W3C/DTD HTML 4.0 Transitional/EN^l,
`HTML^l
◎
• The public identifier is set to: "-//W3O//DTD W3 HTML Strict 3.0//EN//"
• The public identifier is set to: "-/W3C/DTD HTML 4.0 Transitional/EN"
• The public identifier is set to: "HTML"
</li>
					<li>
%~systemID は 次の文字列に合致する
⇒
`http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd^l
◎
• The system identifier is set to: "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"
</li>
					<li>
%~publicID は 次に挙げるいずれかの文字列から開始する
⇒＃
`+//Silmaril//dtd html Pro v0r11 19970101//^l,
`-//AS//DTD HTML 3.0 asWedit + extensions//^l,
`-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//^l,
`-//IETF//DTD HTML 2.0 Level 1//^l,
`-//IETF//DTD HTML 2.0 Level 2//^l,
`-//IETF//DTD HTML 2.0 Strict Level 1//^l,
`-//IETF//DTD HTML 2.0 Strict Level 2//^l,
`-//IETF//DTD HTML 2.0 Strict//^l,
`-//IETF//DTD HTML 2.0//^l,
`-//IETF//DTD HTML 2.1E//^l,
`-//IETF//DTD HTML 3.0//^l,
`-//IETF//DTD HTML 3.2 Final//^l,
`-//IETF//DTD HTML 3.2//^l,
`-//IETF//DTD HTML 3//^l,
`-//IETF//DTD HTML Level 0//^l,
`-//IETF//DTD HTML Level 1//^l,
`-//IETF//DTD HTML Level 2//^l,
`-//IETF//DTD HTML Level 3//^l,
`-//IETF//DTD HTML Strict Level 0//^l,
`-//IETF//DTD HTML Strict Level 1//^l,
`-//IETF//DTD HTML Strict Level 2//^l,
`-//IETF//DTD HTML Strict Level 3//^l,
`-//IETF//DTD HTML Strict//^l,
`-//IETF//DTD HTML//^l,
`-//Metrius//DTD Metrius Presentational//^l,
`-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//^l,
`-//Microsoft//DTD Internet Explorer 2.0 HTML//^l,
`-//Microsoft//DTD Internet Explorer 2.0 Tables//^l,
`-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//^l,
`-//Microsoft//DTD Internet Explorer 3.0 HTML//^l,
`-//Microsoft//DTD Internet Explorer 3.0 Tables//^l,
`-//Netscape Comm. Corp.//DTD HTML//^l,
`-//Netscape Comm. Corp.//DTD Strict HTML//^l,
`-//O'Reilly and Associates//DTD HTML 2.0//^l,
`-//O'Reilly and Associates//DTD HTML Extended 1.0//^l,
`-//O'Reilly and Associates//DTD HTML Extended Relaxed 1.0//^l,
`-//SQ//DTD HTML 2.0 HoTMetaL + extensions//^l,
`-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//^l,
`-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//^l,
`-//Spyglass//DTD HTML 2.0 Extended//^l,
`-//Sun Microsystems Corp.//DTD HotJava HTML//^l,
`-//Sun Microsystems Corp.//DTD HotJava Strict HTML//^l,
`-//W3C//DTD HTML 3 1995-03-24//^l,
`-//W3C//DTD HTML 3.2 Draft//^l,
`-//W3C//DTD HTML 3.2 Final//^l,
`-//W3C//DTD HTML 3.2//^l,
`-//W3C//DTD HTML 3.2S Draft//^l,
`-//W3C//DTD HTML 4.0 Frameset//^l,
`-//W3C//DTD HTML 4.0 Transitional//^l,
`-//W3C//DTD HTML Experimental 19960712//^l,
`-//W3C//DTD HTML Experimental 970421//^l,
`-//W3C//DTD W3 HTML//^l,
`-//W3O//DTD W3 HTML 3.0//^l,
`-//WebTechs//DTD Mozilla HTML 2.0//^l,
`-//WebTechs//DTD Mozilla HTML//^l
◎
• The public identifier starts with: "+//Silmaril//dtd html Pro v0r11 19970101//"
• The public identifier starts with: "-//AS//DTD HTML 3.0 asWedit + extensions//"
• The public identifier starts with: "-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0//"
• The public identifier starts with: "-//IETF//DTD HTML 2.1E//"
• The public identifier starts with: "-//IETF//DTD HTML 3.0//"
• The public identifier starts with: "-//IETF//DTD HTML 3.2 Final//"
• The public identifier starts with: "-//IETF//DTD HTML 3.2//"
• The public identifier starts with: "-//IETF//DTD HTML 3//"
• The public identifier starts with: "-//IETF//DTD HTML Level 0//"
• The public identifier starts with: "-//IETF//DTD HTML Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML Level 3//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 0//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 3//"
• The public identifier starts with: "-//IETF//DTD HTML Strict//"
• The public identifier starts with: "-//IETF//DTD HTML//"
• The public identifier starts with: "-//Metrius//DTD Metrius Presentational//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 HTML//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 Tables//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 HTML//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 Tables//"
• The public identifier starts with: "-//Netscape Comm. Corp.//DTD HTML//"
• The public identifier starts with: "-//Netscape Comm. Corp.//DTD Strict HTML//"
• The public identifier starts with: "-//O'Reilly and Associates//DTD HTML 2.0//"
• The public identifier starts with: "-//O'Reilly and Associates//DTD HTML Extended 1.0//"
• The public identifier starts with: "-//O'Reilly and Associates//DTD HTML Extended Relaxed 1.0//"
• The public identifier starts with: "-//SQ//DTD HTML 2.0 HoTMetaL + extensions//"
• The public identifier starts with: "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//"
• The public identifier starts with: "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//"
• The public identifier starts with: "-//Spyglass//DTD HTML 2.0 Extended//"
• The public identifier starts with: "-//Sun Microsystems Corp.//DTD HotJava HTML//"
• The public identifier starts with: "-//Sun Microsystems Corp.//DTD HotJava Strict HTML//"
• The public identifier starts with: "-//W3C//DTD HTML 3 1995-03-24//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2 Draft//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2 Final//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2S Draft//"
• The public identifier starts with: "-//W3C//DTD HTML 4.0 Frameset//"
• The public identifier starts with: "-//W3C//DTD HTML 4.0 Transitional//"
• The public identifier starts with: "-//W3C//DTD HTML Experimental 19960712//"
• The public identifier starts with: "-//W3C//DTD HTML Experimental 970421//"
• The public identifier starts with: "-//W3C//DTD W3 HTML//"
• The public identifier starts with: "-//W3O//DTD W3 HTML 3.0//"
• The public identifier starts with: "-//WebTechs//DTD Mozilla HTML 2.0//"
• The public identifier starts with: "-//WebTechs//DTD Mozilla HTML//"
</li>
					<li>
［
%~systemID ~EQ ε
］~AND［
%~publicID は 次に挙げるいずれかの文字列から開始する
］
⇒＃
`-//W3C//DTD HTML 4.01 Frameset//^l,
`-//W3C//DTD HTML 4.01 Transitional//^l
◎
• The system identifier is missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Frameset//"
• The system identifier is missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Transitional//"
</li>
				</ul>

<p>
`limited-quirks 条件^i：
◎
Otherwise, if the document is not an iframe srcdoc document, and the parser cannot change the mode flag is false, and the DOCTYPE token matches one of the conditions in the following list, then set the Document to limited-quirks mode:
</p>
				<ul>
					<li>
%~publicID は 次に挙げるいずれかの文字列から開始する
⇒＃
`-//W3C//DTD XHTML 1.0 Frameset//^l,
`-//W3C//DTD XHTML 1.0 Transitional//^l
◎
• The public identifier starts with: "-//W3C//DTD XHTML 1.0 Frameset//"
• The public identifier starts with: "-//W3C//DTD XHTML 1.0 Transitional//"
</li>
					<li>
［
%~systemID ~NEQ ε
］~AND［
%~publicID は 次に挙げるいずれかの文字列から開始する
］
⇒＃
`-//W3C//DTD HTML 4.01 Frameset//^l,
`-//W3C//DTD HTML 4.01 Transitional//^l
◎
• The system identifier is not missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Frameset//"
• The system identifier is not missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Transitional//"
</li>
				</ul>

<p>
上に与えた各~条件においては、［
%~systemID, %~publicID
］とも，（非 ε ならば）`~ASCII大小無視$で比較するモノトスル。
◎
↑↑The system identifier and public identifier strings must be compared to the values given in the lists above in an ASCII case-insensitive manner. A system identifier whose value is the empty string is not considered missing for the purposes of the conditions above.
</p>

			</li>
			<li>
`挿入~mode$ ~SET `~htmlの前$md
◎
Then, switch the insertion mode to "before html".
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`文書$は`~iframe-srcdoc文書$でない
］：
</p>
<ol><li>`~perror$
</li><li>
~IF［
`文書$の`構文解析器は~modeを変更できないか$ ~EQ ~F
］
⇒
`文書$の`~mode$doc ~SET `quirks^l
</li></ol>
◎
If the document is not an iframe srcdoc document, then this is a parse error; if the parser cannot change the mode flag is false, set the Document to quirks mode.
</li>
			<li>
`挿入~mode$ ~SET `~htmlの前$md
</li>
			<li>
現tokenを処理し直す
◎
In any case, switch the insertion mode to "before html", then reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="the-before-html-insertion-mode">
<h6 title="The &quot;before html&quot; insertion mode">13.2.6.4.2. `~htmlの前^md</h6>

<p>
［
`挿入~mode$ ~EQ `~htmlの前$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "before html" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>現tokenは無視する
</li></ol>
◎
Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
%html ~LET `~tokenから要素を作成する$( 現token, `~HTML名前空間$, `文書$ )
◎
Create an element for the token in the HTML namespace, with the Document as the intended parent.＼
</li>
			<li>
`文書$に %html を付加する
◎
Append it to the Document object.＼
</li>
			<li>
`~open要素~stack$に %html を~pushする
◎
Put this element in the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~headの前$md
◎
Switch the insertion mode to "before head".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `head^l, `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "head", "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
%html ~LET 新たな `html$e 要素
◎
Create an html element＼
</li>
			<li>
%html の`~node文書$ ~SET `文書$
◎
whose node document is the Document object.＼
</li>
			<li>
`文書$に %html を付加する
◎
Append it to the Document object.＼
</li>
			<li>
`~open要素~stack$に %html を~pushする
◎
Put this element in the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~headの前$md
◎
Switch the insertion mode to "before head",＼
</li>
			<li>
現tokenを処理し直す
◎
then reprocess the token.
</li>
		</ol>
	</dd>
</dl>

<p>
`文書~要素$は
— 例えば~scriptにより —
`文書$から除去される結果になり得る。
そのような事例でも，特に何も起こらず、
次~節に述べるとおり，
内容は~nodeたち
【すなわち、文書~要素, またはその子孫】
に付加され続ける。
◎
The document element can end up being removed from the Document object, e.g. by scripts; nothing in particular happens in such cases, content continues being appended to the nodes as described in the next section.
</p>

					</section>
					<section id="the-before-head-insertion-mode">
<h6 title="The &quot;before head&quot; insertion mode">13.2.6.4.3. `~headの前^md</h6>

<p>
［
`挿入~mode$ ~EQ `~headの前$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "before head" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>現tokenは無視する
</li></ol>
◎
Ignore the token.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始~tag { `head^l }
◎
A start tag whose tag name is "head"
</dt>
	<dd>
		<ol>
			<li>
%head ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~head要素~pointer$ ~SET %head
◎
Set the head element pointer to the newly created head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `head^l, `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "head", "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
%head ~LET `要素を挿入する$( 新たな開始~tag~token( `head^l ) )
◎
Insert an HTML element for a "head" start tag token with no attributes.
</li>
			<li>
`~head要素~pointer$ ~SET %head
◎
Set the head element pointer to the newly created head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the current token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-inhead">
<h6 title="The &quot;in head&quot; insertion mode">13.2.6.4.4. `~head内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~head内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in head" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( ~tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始~tag { `base^l, `basefont^l, `bgsound^l, `link^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `meta^l }
◎
A start tag whose tag name is "meta"
</dt>
	<dd>
		<ol>
			<li>
%meta ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
<p>
~IF［
`作動中な投機的な~HTML構文解析器$ ~EQ ~NULL
］：
◎
If the active speculative HTML parser is null, then:
</p>
				<ol>
					<li>
~IF［
`確度$ ~NEQ `暫定的^i
］
⇒
~RET
◎
↓</li>
					<li id="meta-charset-during-parse">
<p>
~IF［
%meta は `charset$a 属性を有する
］：
</p>
						<ol>
							<li>
%符号化法 ~LET `~labelから符号化法を取得する$( `charset$a 属性の値 )
</li>
							<li>
<p>
~IF［
%符号化法 ~NEQ `失敗^i
］：
</p>
<ol><li>`符号化法を変更する$( %符号化法 )
</li><li>~RET
</li></ol>
							</li>
						</ol>
◎
If the element has a charset attribute, and getting an encoding from its value results in an encoding, and the confidence is currently tentative, then change the encoding to the resulting encoding.
</li>
					<li>
<p>
~IF［
%meta は `http-equiv$a 属性を有していて その値 ~EQ`大小無視$sub `Content-Type^l
］~AND［
%meta は `content$a 属性を有する
］：
</p>
						<ol>
							<li>
%符号化法 ~LET `~meta要素から符号化法を抽出する$( `content$a 属性の値 )
</li>
							<li>
~IF［
%符号化法 ~NEQ ε
］
⇒
`符号化法を変更する$( %符号化法 )
</li>
						</ol>
◎
Otherwise, if the element has an http-equiv attribute whose value is an ASCII case-insensitive match for the string "Content-Type", and the element has a content attribute, and applying the algorithm for extracting a character encoding from a meta element to that attribute's value returns an encoding, and the confidence is currently tentative, then change the encoding to the extracted encoding.
</li>
				</ol>
			</li>
		</ol>
<p class="note">注記：
実装の複階性を抑制するため、
`投機的な~HTML構文解析器$においては，符号化法~宣言は投機的に適用されない。
◎
The speculative HTML parser doesn't speculatively apply character encoding declarations in order to reduce implementation complexity.
</p>
	</dd>

	<dt>
開始~tag { `title^l }
◎
A start tag whose tag name is "title"
</dt>
	<dd>
<ol><li>`~RCDATA要素の汎用~構文解析~algo$( 現token )
</li></ol>
◎
Follow the generic RCDATA element parsing algorithm.
</dd>

	<dt>
開始~tag { `noframes^l, `style^l }
◎
A start tag whose tag name is "noscript", if the scripting flag is enabled
◎
A start tag whose tag name is one of: "noframes", "style"
</dt>
	<dd>
<ol><li>`生~text要素の汎用~構文解析~algo$( 現token )
</li></ol>
◎
Follow the generic raw text element parsing algorithm.
</dd>

	<dt>
開始~tag { `noscript^l }
◎
A start tag whose tag name is "noscript", if the scripting flag is disabled
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~scripting~flag$ ~EQ `可能化^i
］：
</p>
<ol><li>`生~text要素の汎用~構文解析~algo$( 現token )
</li><li>~RET
</li></ol>
◎
↑↑</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`挿入~mode$ ~SET `~head~noscript内$md
◎
Switch the insertion mode to "in head noscript".
</li>
		</ol>
	</dd>

	<dt id="scriptTag">
開始~tag { `script^l }
◎
A start tag whose tag name is "script"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$( `現在の~node$ )
◎
Let the adjusted insertion location be the appropriate place for inserting a node.
</li>
			<li>
%script ~LET `~tokenから要素を作成する$( 現token, `~HTML名前空間$, %調整-済み挿入-先 が所属する要素 )
◎
Create an element for the token in the HTML namespace, with the intended parent being the element in which the adjusted insertion location finds itself.
</li>
			<li>
<p>
%script の
⇒＃
`構文解析器~文書$scE ~SET `文書$,
`非同期cを強制するか$scE ~SET ~F
◎
Set the element's parser document to the Document, and set the element's force async to false.
</p>

<p class="note">注記：
これは、［
%script が外部~scriptを与えている場合に，~script内の `document.write()$c の~callは~in-lineに実行する
］ことを確保する
— 他のほとんどの事例では、
それは，文書を吹飛ばすことになる。
また、
終了~tagに出くわすまで %script を実行されるのも防ぐ。
◎
This ensures that, if the script is external, any document.write() calls in the script will execute in-line, instead of blowing the document away, as would happen in most other cases. It also prevents the script from executing until the end tag is seen.
</p>

	</li>
			<li>
~IF［
%構文解析器 は`~HTML素片~用$である
（`素片~事例$）
］
⇒
%script の`すでに開始したか$scE ~SET ~T
◎
If the parser was created as part of the HTML fragment parsing algorithm, then set the script element's already started to true. (fragment case)
</li>
			<li id="document-written-scripts-intervention">
<p>
任意選択で
⇒
~IF［
%構文解析器 は［
`document.write()$c ／ `document.writeln()$c
］~methodを介して呼出されている
］
⇒
%script の`すでに開始したか$scE ~SET ~T
</p>

<p>
（例えば~UAは，［
~networkが遅い／
~pageを読込むのに長時間かかっていた
］条件~下では、
この条項を利用して，挿入された`非同一-生成元$~scriptの実行を防ぐかもしれない。）
</p>
◎
If the parser was invoked via the document.write() or document.writeln() methods, then optionally set the script element's already started to true. (For example, the user agent might use this clause to prevent execution of cross-origin scripts inserted via document.write() under slow network conditions, or when the page has already taken a long time to load.)
</li>
			<li>
%script を
%調整-済み挿入-先 に挿入する
◎
Insert the newly created element at the adjusted insertion location.
</li>
			<li>
`~open要素~stack$に %script を~pushする
◎
Push the element onto the stack of open elements so that it is the new current node.
</li>
			<li>
~tokenizerを `~script~data$st に`切替える$
◎
Switch the tokenizer to the script data state.
</li>
			<li>
<p>
`元の挿入~mode$V ~LET 現在の`挿入~mode$
◎
Set the original insertion mode to the current insertion mode.
</p>

	</li>
			<li>
`挿入~mode$ ~SET `~text$md
◎
Switch the insertion mode to "text".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `head^l }
◎
An end tag whose tag name is "head"
</dt>
	<dd>
		<ol>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be the head element) off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~headの後$md
◎
Switch the insertion mode to "after head".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
開始~tag { `template^l }
◎
A start tag whose tag name is "template"
</dt>
	<dd>
<p>
◎
Run these steps:
</p>
		<ol>
			<li>
%~template開始~tag ~LET 現token【！the start tag】
◎
Let templateStartTag be the start tag.
</li>
			<li>
`作動中な整形~要素~list$に`~marker$を付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~template内$md
◎
Switch the insertion mode to "in template".
</li>
			<li>
`~template挿入~mode~stack$に`~template内$mdを~pushする
◎
Push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$
◎
Let the adjustedInsertionLocation be the appropriate place for inserting a node.
</li>
			<li>
%意図された親 ~LET %調整-済み挿入-先 が所属する要素
◎
Let intendedParent be the element in which the adjustedInsertionLocation finds itself.
</li>
			<li>
%文書 ~LET %意図された親 の`~node文書$
◎
Let document be intendedParent's node document.
</li>
			<li>
<p>
~IF［
~OR↓
］…
◎
If any of the following are false:
</p>
				<ul>
					<li>
%~template開始~tag の `shadowrootmode$a 属性の状態 ~EQ `なし$ast
◎
templateStartTag's shadowrootmode is not in the None state;
</li>
					<li>
%文書 の`宣言的な~shadow根を許容するか$doc ~EQ ~F
◎
document's allow declarative shadow roots is true; or
</li>
					<li>
`現在の調整-済み~node$ ~EQ `~open要素~stack$の先頭にある要素
◎
the adjusted current node is not the topmost element in the stack of open elements,
</li>
				</ul>
<div>
<p>
…ならば：
</p>
				<ol>
					<li>
`要素を挿入する$( %~template開始~tag【！the token】 )
</li>
					<li>
~RET
</li>
				</ol>
◎
then insert an HTML element for the token.
◎
Otherwise:
</div>
			</li>
			<li>
%宣言的~shadowの~host要素 ~LET `現在の調整-済み~node$
◎
Let declarativeShadowHostElement be adjusted current node.
</li>
			<li>
%~template ~LET `要素を挿入する$( %~template開始~tag, `~HTML名前空間$, ~T )
◎
Let template be the result of insert a foreign element for templateStartTag, with HTML namespace and true.
</li>
			<li id="_template-shadowrootmode">
%~mode ~LET %~template開始~tag の `shadowrootmode$a 属性の値
◎
Let mode be templateStartTag's shadowrootmode attribute's value.
</li>
			<li>
%~clone可能か ~LET ~IS［
%~template開始~tag は `shadowrootclonable$a 属性を有する
］
◎
Let clonable be true if templateStartTag has a shadowrootclonable attribute; otherwise false.
</li>
			<li>
%直列化-可能か ~LET ~IS［
%~template開始~tag は `shadowrootserializable$a 属性を有する
］
◎
Let serializable be true if templateStartTag has a shadowrootserializable attribute; otherwise false.
</li>
			<li>
%~focusを委任するか ~LET ~IS［
%~template開始~tag は `shadowrootdelegatesfocus$a 属性を有する
］
◎
Let delegatesFocus be true if templateStartTag has a shadowrootdelegatesfocus attribute; otherwise false.
</li>
			<li>
~IF［
%宣言的~shadowの~host要素 は`~shadow~host$である
］
⇒
`要素を調整-済み挿入-先に挿入する$( %~template )
◎
If declarativeShadowHostElement is a shadow host, then insert an element at the adjusted insertion location with template.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
%~registry ~LET %宣言的~shadowの~host要素 の`~custom要素~registry$el
◎
Let registry be declarativeShadowHostElement's custom element registry.
</li>
					<li>
~IF［
%~template開始~tag は `shadowrootcustomelementregistry$a 属性を有する
］
⇒
%~registry ~SET ~NULL
◎
If templateStartTag has a shadowrootcustomelementregistry attribute, then set registry to null.
</li>
					<li>
<p>
`~shadow根を付する$( ↓ )
⇒＃
%宣言的~shadowの~host要素,
%~mode,
%~clone可能か,
%直列化-可能か,
%~focusを委任するか,
`named^l,
%~registry
◎
Attach a shadow root with declarativeShadowHostElement, mode, clonable, serializable, delegatesFocus, "named", and registry.
</p>

<p>
例外が投出されたときは、
~catchして：
◎
If an exception is thrown, then catch it and:
</p>
						<ol>
							<li>
`要素を調整-済み挿入-先に挿入する$( %~template )
◎
Insert an element at the adjusted insertion location with template.
</li>
							<li>
任意選択で
⇒
開発者~consoleへ~errorを報告する
◎
The user agent may report an error to the developer console.
</li>
							<li>
~RET
◎
Return.
</li>
						</ol>
					</li>
					<li>
%~shadow ~LET %宣言的~shadowの~host要素 の`~shadow根$el
◎
Let shadow be declarativeShadowHostElement's shadow root.
</li>
					<li>
%~shadow の`宣言的か$sR ~SET ~T
◎
Set shadow's declarative to true.
◎
↓</li>
					<li>
%~template の`~template内容$ ~SET %~shadow
◎
Set template's template contents property to shadow.
</li>
					<li>
%~shadow の`要素の内部特能から可用か$sR ~SET ~T
◎
Set shadow's available to element internals to true.
</li>
					<li>
~IF［
%~template開始~tag は `shadowrootcustomelementregistry$a 属性を有する
］
⇒
%~shadow の`~custom要素~registryを~NULLに保つか$sR ~SET ~T
◎
If templateStartTag has a shadowrootcustomelementregistry attribute, then set shadow's keep custom element registry null to true.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>
終了~tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~open要素~stack$内には `template$e 要素は無い
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If there is no template element on the stack of open elements, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
<p>
`暗黙な終了~tagすべてを生成する$
◎
Generate all implied end tags thoroughly.
</p></li>
			<li>
~IF［
`現在の~node$は `template$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a template element, then this is a parse error.
</li>
			<li>
`template$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a template element has been popped from the stack.
</li>
			<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`挿入~modeを適切に設定し直す$
◎
Reset the insertion mode appropriately.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `head^l }
◎
A start tag whose tag name is "head"
</dt>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be the head element) off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~headの後$md
◎
Switch the insertion mode to "after head".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-inheadnoscript">
<h6 title="The &quot;in head noscript&quot; insertion mode">13.2.6.4.5. `~head~noscript内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~head~noscript内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in head noscript" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
終了~tag { `noscript^l }
◎
An end tag whose tag name is "noscript"
</dt>
	<dd>
		<ol>
			<li>
~Assert：
`現在の~node$は `noscript$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a noscript element) from the stack of open elements;＼
</li>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
the new current node will be a head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
		</ol>
	</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>

	<dt>
~comment~token
◎
A comment token
</dt>

	<dt>
開始~tag { `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `style^l }
◎
A start tag whose tag name is one of: "basefont", "bgsound", "link", "meta", "noframes", "style"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
終了~tag { `br^l }
◎
An end tag whose tag name is "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
開始~tag { `head^l, `noscript^l }
◎
A start tag whose tag name is one of: "head", "noscript"
</dt>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~Assert：
`現在の~node$は `noscript$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a noscript element) from the stack of open elements;＼
</li>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
the new current node will be a head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="the-after-head-insertion-mode">
<h6 title="The &quot;after head&quot; insertion mode">13.2.6.4.6. `~headの後^md</h6>

<p>
［
`挿入~mode$ ~EQ `~headの後$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "after head" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始~tag { `body^l }
◎
A start tag whose tag name is "body"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~body内$md
◎
Switch the insertion mode to "in body".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `frameset^l }
◎
A start tag whose tag name is "frameset"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`挿入~mode$ ~SET `~frameset内$md
◎
Switch the insertion mode to "in frameset".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `base^l, `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `script^l, `style^l, `template^l, `title^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
`~open要素~stack$に `~head要素~pointer$が指す~nodeを~pushする
◎
Push the node pointed to by the head element pointer onto the stack of open elements.
</li>
			<li>
`~head内$md`用の規則を利用して$現tokenを処理する
◎
Process the token using the rules for the "in head" insertion mode.
</li>
			<li>
<p>
`~open要素~stack$から `~head要素~pointer$が指す~nodeを除去する
（この時点では、
それは`現在の~node$でないかもしれない）
◎
Remove the node pointed to by the head element pointer from the stack of open elements. (It might not be the current node at this point.)
</p>

<p class="note">注記：
この時点では、
`~head要素~pointer$は ~NULL になり得ない。
◎
The head element pointer cannot be null at this point.
</p>
			</li>
		</ol>
	</dd>

	<dt>
終了~tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
終了~tag { `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
開始~tag { `head^l }
◎
A start tag whose tag name is "head"
</dt>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 新たな開始~tag~token( `body^l ) )
◎
Insert an HTML element for a "body" start tag token with no attributes.
</li>
			<li>
`挿入~mode$ ~SET `~body内$md
◎
Switch the insertion mode to "in body".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the current token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-inbody">
<h6 title="The &quot;in body&quot; insertion mode">13.2.6.4.7. `~body内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~body内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`文字を挿入する$( 現tokenの文字 )
◎
Insert the token's character.
</li>
		</ol>
	</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`文字を挿入する$( 現tokenの文字 )
◎
Insert the token's character.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`~open要素~stack$内に `template$e 要素は在る
］
⇒
~RET — 現tokenは無視する
◎
If there is a template element on the stack of open elements, then ignore the token.
</li>
			<li>
%要素 ~LET `~open要素~stack$の先頭にある要素
◎
↓</li>
			<li>
~tokenの属性~listを成す
~EACH( %属性 )
に対し
⇒
~IF［
%要素 は［
%属性 と同じ名前の属性
］を有していない
］
⇒
%要素 に［
%属性 の［
名前, 値
］で与えられる属性
］を追加する
◎
Otherwise, for each attribute on the token, check to see if the attribute is already present on the top element of the stack of open elements. If it is not, add the attribute and its corresponding value to that element.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `base^l, `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `script^l, `style^l, `template^l, `title^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
</dt>

	<dt>
終了~tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
開始~tag { `body^l }
◎
A start tag whose tag name is "body"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
%body ~LET `~open要素~stack$内に 2 個目の要素は［
在るならば それ ／
無いならば ε
］
◎
↓</li>
			<li>
~IF［
%body は `body$e 要素でない
］~OR［
`~open要素~stack$内には `template$e 要素は在る
］（`素片~事例$または`~open要素~stack$内には `template$e 要素は在る）
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements has only one node on it, or if the second element on the stack of open elements is not a body element, or if there is a template element on the stack of open elements, then ignore the token. (fragment case or there is a template element on the stack)
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Otherwise, set the frameset-ok flag to "not ok"; then,＼
</li>
			<li>
~tokenの属性~listを成す
~EACH( %属性 )
に対し
⇒
~IF［
%body は，まだ %属性 を有していない
］
⇒
%body に %属性 を（対応している値とともに）追加する
◎
for each attribute on the token, check to see if the attribute is already present on the body element (the second element) on the stack of open elements, and if it is not, add the attribute and its corresponding value to that element.
</li>
		</ol>
</dd>

	<dt>
開始~tag { `frameset^l }
◎
A start tag whose tag name is "frameset"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
%body ~LET `~open要素~stack$内に 2 個目の要素が［
在るならば それ ／
無いならば ε
］
◎
↓</li>
			<li>
~IF［
%body は `body$e 要素でない
（`素片~事例$または`~open要素~stack$内には `template$e 要素は在る）
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements has only one node on it, or if the second element on the stack of open elements is not a body element, then ignore the token. (fragment case or there is a template element on the stack)
</li>
			<li>
~IF［
`~frameset-ok~flag$ ~EQ `not-ok^i
］
⇒
~RET — 現tokenは無視する
◎
If the frameset-ok flag is set to "not ok", ignore the token.
◎
Otherwise, run the following steps:
</li>
			<li>
~IF［
%body の親~nodeは在る
］
⇒
%body を親~nodeから除去する
◎
Remove the second element on the stack of open elements from its parent node, if it has one.
</li>
			<li>
~WHILE［
`現在の~node$は根 `html$e 要素でない
］
⇒
`~open要素~stack$から~popする
◎
Pop all the nodes from the bottom of the stack of open elements, from the current node up to, but not including, the root html element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`挿入~mode$ ~SET `~frameset内$md
◎
Switch the insertion mode to "in frameset".
</li>
		</ol>
	</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~template挿入~mode~stack$は空でない
］：
</p>

<ol><li>`~template内$md`用の規則を利用して$現tokenを処理する
</li><li>~RET
</li></ol>

◎
If the stack of template insertion modes is not empty, then process the token using the rules for the "in template" insertion mode.
◎
Otherwise, follow these steps:
</li>
			<li>
<p>
~IF［
`~open要素~stack$内に，次に挙げる要素~型~以外の~nodeは在る
］…
⇒
`dd$e,
`dt$e,
`li$e,
`optgroup$e,
`option$e,
`p$e,
`rb$e,
`rp$e,
`rt$e,
`rtc$e,
`tbody$e,
`td$e,
`tfoot$e,
`th$e,
`thead$e,
`tr$e,
`body$e,
`html$e
</p>

<p>
…ならば
⇒
`~perror$
</p>
◎
If there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
</li>
			<li>
`構文解析を停止する$
◎
Stop parsing.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l }
◎
An end tag whose tag name is "body"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, `body^e )
］：
</p>

<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a body element in scope, this is a parse error; ignore the token.
</li>
			<li>
<p>
~IF［
`~open要素~stack$内に，次に挙げる要素~型~以外の~nodeは在る
］…
⇒
`dd$e,
`dt$e,
`li$e,
`optgroup$e,
`option$e,
`p$e,
`rb$e,
`rp$e,
`rt$e,
`rtc$e,
`tbody$e,
`td$e,
`tfoot$e,
`th$e,
`thead$e,
`tr$e,
`body$e,
`html$e
</p>

<p>
…ならば
⇒
`~perror$
</p>

◎
Otherwise, if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
</li>
			<li>
`挿入~mode$ ~SET `~bodyの後$md
◎
Switch the insertion mode to "after body".
</li>
		</ol>
	</dd>
	<dt>
終了~tag { `html^l }
◎
An end tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, `body^e )
］：
</p>

<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the stack of open elements does not have a body element in scope, this is a parse error; ignore the token.
</li>
			<li>
<p>
~IF［
`~open要素~stack$内に，次に挙げる要素~型~以外の~nodeは在る
］…
⇒
`dd$e,
`dt$e,
`li$e,
`optgroup$e,
`option$e,
`p$e,
`rb$e,
`rp$e,
`rt$e,
`rtc$e,
`tbody$e,
`td$e,
`tfoot$e,
`th$e,
`thead$e,
`tr$e,
`body$e,
`html$e
</p>

<p>
…ならば
⇒
`~perror$
</p>

◎
Otherwise, if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
</li>
			<li>
`挿入~mode$ ~SET `~bodyの後$md
◎
Switch the insertion mode to "after body".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `address^l, `article^l, `aside^l, `blockquote^l, `center^l, `details^l, `dialog^l, `dir^l, `div^l, `dl^l, `fieldset^l, `figcaption^l, `figure^l, `footer^l, `header^l, `hgroup^l, `main^l, `menu^l, `nav^l, `ol^l, `p^l, `search^l, `section^l, `summary^l, `ul^l }
◎
A start tag whose tag name is one of: "address", "article", "aside", "blockquote", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p", "search", "section", "summary", "ul"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l }
◎
A start tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
<p>
~IF［
`現在の~node$は`~HTML要素$である
］~AND［
その~tag名 ~IN { `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l }
］：
</p>
<ol><li>`~perror$
</li><li>`~open要素~stack$から~popする
</li></ol>
◎
If the current node is an HTML element whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a parse error; pop the current node off the stack of open elements.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `pre^l, `listing^l }
◎
A start tag whose tag name is one of: "pre", "listing"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`次回の~LF文字~tokenは無視するようにしておく$
◎
If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `form^l }
◎
A start tag whose tag name is "form"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~form要素~pointer$ ~NEQ ~NULL
］~AND［
`~open要素~stack$内には `template$e 要素は無い
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the form element pointer is not null, and there is no template element on the stack of open elements, then this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
• If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
• Insert an HTML element for the token,＼
</li>
			<li>
~IF［
`~open要素~stack$内には `template$e 要素は無い
］
⇒
`~form要素~pointer$ ~SET %要素
◎
and, if there is no template element on the stack of open elements, set the form element pointer to point to the element created.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `li^l }
◎
A start tag whose tag name is "li"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
<p>
`~open要素~stack$を成す
~EACH( %~node )
に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
				<ol>
					<li>
<p>
~IF［
%~node は `li$e 要素である
］：
◎
Loop: If node is an li element, then run these substeps:
</p>
						<ol>
							<li>
`暗黙な終了~tagたちを生成する$( `li$e )
◎
Generate implied end tags, except for li elements.
</li>
							<li>
~IF［
`現在の~node$は `li$e 要素でない
］
⇒
`~perror$
◎
If the current node is not an li element, then this is a parse error.
</li>
							<li>
`li$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an li element has been popped from the stack.
</li>
							<li>
~BREAK
◎
Jump to the step labeled done below.
</li>
						</ol>
					</li>
					<li>
~IF［
%~node は`特別$である
］~AND［
%~node は［
`address$e, `div$e, `p$e
］要素ではない
］
⇒
~BREAK
◎
If node is in the special category, but is not an address, div, or p element, then jump to the step labeled done below.
◎
Otherwise, set node to the previous entry in the stack of open elements and return to the step labeled loop.
</li>
				</ol>
			</li>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
Done: If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Finally, insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `dd^l, `dt^l }
◎
A start tag whose tag name is one of: "dd", "dt"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
<p>
`~open要素~stack$を成す
~EACH( %~node )
に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
				<ol>
					<li>
<p>
~IF［
%~node は `dd$e 要素である
］：
◎
Loop: If node is a dd element, then run these substeps:
</p>

						<ol>
							<li>
`暗黙な終了~tagたちを生成する$( `dd$e )
◎
Generate implied end tags, except for dd elements.
</li>
							<li>
~IF［
`現在の~node$は `dd$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a dd element, then this is a parse error.
</li>
							<li>
`dd$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a dd element has been popped from the stack.
</li>
							<li>
~BREAK
◎
Jump to the step labeled done below.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~node は `dt$e 要素である
］：
◎
If node is a dt element, then run these substeps:
</p>
						<ol>
							<li>
`暗黙な終了~tagたちを生成する$( `dt$e )
◎
Generate implied end tags, except for dt elements.
</li>
							<li>
~IF［
`現在の~node$は `dt$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a dt element, then this is a parse error.
</li>
							<li>
`dt$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a dt element has been popped from the stack.
</li>
							<li>
~BREAK
◎
Jump to the step labeled done below.
</li>
						</ol>
					</li>
					<li>
~IF［
%~node は`特別$であって［
`address$e ／ `div$e ／ `p$e
］ 要素ではない
］
⇒
~BREAK
◎
If node is in the special category, but is not an address, div, or p element, then jump to the step labeled done below.
◎
Otherwise, set node to the previous entry in the stack of open elements and return to the step labeled loop.
</li>
				</ol>
			</li>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
Done: If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Finally, insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `plaintext^l }
◎
A start tag whose tag name is "plaintext"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
~tokenizerを `~PLAINTEXT$st に`切替える$
◎
Switch the tokenizer to the PLAINTEXT state.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
［
開始~tagであって［
その~tag名 ~EQ `plaintext^l
］なるもの
］に出くわしたならば、
残りすべての~tokenは，文字~token（および最後の~eof~token）になる
— ~tokenizerを `~PLAINTEXT$st から外へ`切替える$仕方はないので。
しかしながら，~tree構築器は、
既存の挿入~modeにあり続けるので，
それらの文字~tokenを処理している間に`作動中な整形~要素たちを構築し直す$かもしれない。
このことは、
構文解析器は， `plaintext$e 要素の中へ他の要素を挿入し得ることを意味する。
◎
Once a start tag with the tag name "plaintext" has been seen, all remaining tokens will be character tokens (and a final end-of-file token) because there is no way to switch the tokenizer out of the PLAINTEXT state. However, as the tree builder remains in its existing insertion mode, it might reconstruct the active formatting elements while processing those character tokens. This means that the parser can insert other elements into the plaintext element.
</dd>

	<dt>
開始~tag { `button^l }
◎
A start tag whose tag name is "button"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `button^e )
］：
◎
If the stack of open elements has a button element in scope, then run these substeps:
</p>
				<ol>
					<li>
`~perror$
◎
Parse error.
</li>
					<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
`button$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a button element has been popped from the stack.
</li>
				</ol>
			</li>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `address^l, `article^l, `aside^l, `blockquote^l, `button^l, `center^l, `details^l, `dialog^l, `dir^l, `div^l, `dl^l, `fieldset^l, `figcaption^l, `figure^l, `footer^l, `header^l, `hgroup^l, `listing^l, `main^l, `menu^l, `nav^l, `ol^l, `pre^l, `search^l, `section^l, `select^l, `summary^l, `ul^l }
◎
An end tag whose tag name is one of: "address", "article", "aside", "blockquote", "button", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre", "search", "section", "select", "summary", "ul"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `form^l }
◎
An end tag whose tag name is "form"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~open要素~stack$内には `template$e 要素は無い
］：
◎
If there is no template element on the stack of open elements, then run these substeps:
</p>
				<ol>
					<li>
%~node ~LET ［
`~form要素~pointer$ は要素ならば それ ／
~ELSE_ ~NULL
］
◎
Let node be the element that the form element pointer is set to, or null if it is not set to an element.
</li>
					<li>
`~form要素~pointer$ ~SET ~NULL
◎
Set the form element pointer to null.
</li>
					<li>
<p>
~IF［
%~node ~EQ ~NULL
］~OR［
`視野~内$に無い( `既定の視野$, %~node  )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If node is null or if the stack of open elements does not have node in scope, then this is a parse error; return and ignore the token.
</li>
					<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
~IF［
`現在の~node$ ~NEQ %~node
］
⇒
`~perror$
◎
If the current node is not node, then this is a parse error.
</li>
					<li>
`~open要素~stack$から %~node を除去する
◎
Remove node from the stack of open elements.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
`~open要素~stack$内に `template$e 要素は`在る^em
］：
◎
If there is a template element on the stack of open elements, then run these substeps instead:
</p>
				<ol>
					<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, `form^e )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a form element in scope, then this is a parse error; return and ignore the token.
</li>
					<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
~IF［
`現在の~node$は `form$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a form element, then this is a parse error.
</li>
					<li>
`form$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a form element has been popped from the stack.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>
終了~tag { `p^l }
◎
An end tag whose tag name is "p"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~button視野$, `p^e )
］：
</p>
<ol><li>`~perror$
</li><li>`要素を挿入する$( 新たな開始~tag~token( `p^l ) )
</li></ol>
◎
If the stack of open elements does not have a p element in button scope, then this is a parse error; insert an HTML element for a "p" start tag token with no attributes.
</li>
			<li>
`~p要素を閉じる$
◎
Close a p element.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `li^l }
◎
An end tag whose tag name is "li"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~list~item視野$, `li^e )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an li element in list item scope, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙な終了~tagたちを生成する$( `li$e )
◎
Generate implied end tags, except for li elements.
</li>
			<li>
~IF［
`現在の~node$は `li$e 要素でない
］
⇒
`~perror$
◎
If the current node is not an li element, then this is a parse error.
</li>
			<li>
`li$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an li element has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `dd^l, `dt^l }
◎
An end tag whose tag name is one of: "dd", "dt"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙な終了~tagたちを生成する$( 現tokenと~tag名が同じ`~HTML要素$ )
◎
Generate implied end tags, except for HTML elements with the same tag name as the token.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l }
◎
An end tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, { `h1^e, `h2^e, `h3^e, `h4^e, `h5^e, `h6^e } )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element and whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
{ `h1^e, `h2^e, `h3^e, `h4^e, `h5^e, `h6^e }
いずれかの要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6" has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `sarcasm^l }
◎
An end tag whose tag name is "sarcasm"
</dt>
	<dd>
<ol><li>Take a deep breath, then…
</li><li>~GOTO その他の終了~tag
</li></ol>
◎
Take a deep breath, then act as described in the "any other end tag" entry below.
</dd>

	<dt>
開始~tag { `a^l }
◎
A start tag whose tag name is "a"
</dt>
	<dd>
		<ol>
			<li>
<div class="p">
<p>
~IF［
`作動中な整形~要素~list$内に ~AND↓ を満たす %要素 は在る
］…
</p>
				<ul>
					<li>
%要素 は `a$e 要素である
</li>
					<li>
~list内の %要素 より後には`~marker$は無い
</li>
				</ul>
<p>
…ならば：
</p>
◎
If the list of active formatting elements contains an a element between the end of the list and the last marker on the list (or the start of the list if there is no marker on the list), then＼
</div>

				<ol>
					<li>
`~perror$
◎
this is a parse error;＼
</li>
					<li>
`養子縁組~algo$( 現token )
◎
run the adoption agency algorithm for the token, then＼
</li>
					<li>
［
`作動中な整形~要素~list$, `~open要素~stack$
］から %要素 を除去する
— 前~段による結果、
%要素 は除去されていなければ
（`視野~内$に無い( `~table視野$, %要素 ) の場合、
除去されていないかもしれない。）
◎
remove that element from the list of active formatting elements and the stack of open elements if the adoption agency algorithm didn't already remove it (it might not have if the element is not in table scope).
</li>
				</ol>

<p class="example">
適合してない~stream
`&lt;a&nbsp;href="a"&gt;a&lt;table&gt;&lt;a&nbsp;href="b"&gt;b&lt;/table&gt;x^c
内では、
1 個目の `a$e 要素は 2 個目のそれに出くわした所で閉じられ，
文字 `x^l は "a" への~linkではなく "b" への~linkの内側に置かれることになる
— 1 個目の `a$e 要素は，~table視野~内に無い
（~tableの始端に定例の`&lt;/a&gt;^c 終了~tagがあっても，
1 個目の `a$e 要素を閉じないことを意味する）
事実にもかかわらず。
その結果、
この 2 個の `a$e 要素は間接的に互いの内側に
【~markup的な意味で】
入子にされる
— 適合してない~markupを構文解析した結果は、
適合してない~DOMになることが多い。
◎
In the non-conforming stream &lt;a href="a"&gt;a&lt;table&gt;&lt;a href="b"&gt;b&lt;/table&gt;x, the first a element would be closed upon seeing the second one, and the "x" character would be inside a link to "b", not to "a". This is despite the fact that the outer a element is not in table scope (meaning that a regular &lt;/a&gt; end tag at the start of the table wouldn't close the outer a element). The result is that the two a elements are indirectly nested inside each other — non-conforming markup will often result in non-conforming DOMs when parsed.
</p>
			</li>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`作動中な整形~要素~listに~pushする$( %要素 )
◎
Push onto the list of active formatting elements that element.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `b^l, `big^l, `code^l, `em^l, `font^l, `i^l, `s^l, `small^l, `strike^l, `strong^l, `tt^l, `u^l }
◎
A start tag whose tag name is one of: "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u"
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`作動中な整形~要素~listに~pushする$( %要素 )
◎
Push onto the list of active formatting elements that element.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `nobr^l }
◎
A start tag whose tag name is "nobr"
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `nobr^e )
］：
</p>

<ol><li>`~perror$
</li><li>`養子縁組~algo$( 現token )
</li><li>`作動中な整形~要素たちを構築し直す$
</li></ol>

◎
If the stack of open elements has a nobr element in scope, then this is a parse error; run the adoption agency algorithm for the token, then once again reconstruct the active formatting elements, if any.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`作動中な整形~要素~listに~pushする$( %要素 )
◎
Push onto the list of active formatting elements that element.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `a^l, `b^l, `big^l, `code^l, `em^l, `font^l, `i^l, `nobr^l, `s^l, `small^l, `strike^l, `strong^l, `tt^l, `u^l }
◎
An end tag whose tag name is one of: "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u"
</dt>
	<dd>
<ol><li>`養子縁組~algo$( 現token )
</li></ol>
◎
Run the adoption agency algorithm for the token.
</dd>

	<dt>
開始~tag { `applet^l, `marquee^l, `object^l }
◎
A start tag whose tag name is one of: "applet", "marquee", "object"
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`作動中な整形~要素~list$に`~marker$を付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `applet^l, `marquee^l, `object^l }
◎
An end tag token whose tag name is one of: "applet", "marquee", "object"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
			<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `table^l }
◎
A start tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`文書$の`~mode$doc ~NEQ `quirks^l
］~AND［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the Document is not set to quirks mode, and the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `br^l }
◎
An end tag whose tag name is "br"
</dt>
	<dd>
<ol><li>`~perror$
</li><li>現token ~SET 新たな開始~tag~token( `br^l ) とする下で，現tokenを処理し直す
</li></ol>
◎
Parse error. Drop the attributes from the token, and act as described in the next entry; i.e. act as if this was a "br" start tag token with no attributes, rather than the end tag token that it actually is.
</dd>

	<dt>
開始~tag { `area^l, `br^l, `embed^l, `img^l, `keygen^l, `wbr^l }
◎
A start tag whose tag name is one of: "area", "br", "embed", "img", "keygen", "wbr"
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `input^l }
◎
A start tag whose tag name is "input"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%構文解析器 は`~HTML素片~用$である
（`素片~事例$）
］~AND［
その~algoに渡された `文脈$V は `select$e 要素である
］：
◎
If the parser was created as part of the HTML fragment parsing algorithm (fragment case) and the context element passed to that algorithm is a select element:
</p>
				<ol>
					<li>
`~perror$
◎
Parse error.
</li>
					<li>
~RET
— 現tokenは無視する
◎
Ignore the token.
◎
Return.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `select^e )
］：
◎
If the stack of open elements has a select element in scope:
</p>
				<ol>
					<li>
`~perror$
◎
Parse error.
</li>
					<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
				</ol>
			</li>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
<p>
~IF［
現token上に ~AND↓ を満たす属性は在る
］…
</p>
<ul><li>名前 ~EQ `type^l
</li><li>値 ~EQ`大小無視$sub `hidden^l
</li></ul>

<p>
…ならば
⇒
~RET
</p>
◎
If the token does not have an attribute with the name "type", or if it does, but that attribute's value is not an ASCII case-insensitive match for the string "hidden", then:＼
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `param^l, `source^l, `track^l }
◎
A start tag whose tag name is one of: "param", "source", "track"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `hr^l }
◎
A start tag whose tag name is "hr"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `select^e )
］：
◎
If the stack of open elements has a select element in scope:
</p>
				<ol>
					<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
~IF［
`視野~内$に在る( `既定の視野$, { `option^e, `optgroup^e } )
］
⇒
`~perror$
◎
If the stack of open elements has an option element in scope or has an optgroup element in scope, then this is a parse error.
</li>
				</ol>
			</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `image^l }
◎
A start tag whose tag name is "image"
</dt>
	<dd>
<ol><li>`~perror$
</li><li>現tokenの~tag名 ~SET `img^l
</li><li>現tokenを処理し直す
</li></ol>

<p>
Don’t ask.
【わけは聞かないでくれ？】
</p>

◎
Parse error. Change the token's tag name to "img" and reprocess it. (Don't ask.)
</dd>

	<dt>
開始~tag { `textarea^l }
◎
A start tag whose tag name is "textarea"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`次回の~LF文字~tokenは無視するようにしておく$
◎
If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
</li>
			<li>
~tokenizerを `~RCDATA$st に`切替える$
◎
Switch the tokenizer to the RCDATA state.
</li>
			<li>
`元の挿入~mode$V ~LET 現在の`挿入~mode$
◎
Set the original insertion mode to the current insertion mode.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~text$md
◎
Switch the insertion mode to "text".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `xmp^l }
◎
A start tag whose tag name is "xmp"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`生~text要素の汎用~構文解析~algo$( 現token )
◎
Follow the generic raw text element parsing algorithm.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `iframe^l }
◎
A start tag whose tag name is "iframe"
</dt>
	<dd>
		<ol>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`生~text要素の汎用~構文解析~algo$( 現token )
◎
Follow the generic raw text element parsing algorithm.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `noembed^l }
◎
A start tag whose tag name is "noembed"
</dt>
	<dd>
<ol><li>`生~text要素の汎用~構文解析~algo$( 現token )
</li></ol>

◎
↓</dd>

	<dt>
開始~tag { `noscript^l }
◎
A start tag whose tag name is "noscript", if the scripting flag is enabled
</dt>
	<dd>
		<ol>
			<li>
~IF［
`~scripting~flag$ ~NEQ `可能化^i
］
⇒
~GOTO その他の開始~tag
</li>
			<li>
`生~text要素の汎用~構文解析~algo$( 現token )
</li>
		</ol>

◎
Follow the generic raw text element parsing algorithm.
</dd>

	<dt>
開始~tag { `select^l }
◎
A start tag whose tag name is "select"
</dt>
	<dd>
		<ol>
			<li>
~IF［
%構文解析器 は`~HTML素片~用$である
（`素片~事例$）
］~AND［
その~algoに渡された `文脈$V は `select$e 要素である
］
⇒
`~perror$ — 現tokenは無視する
◎
If the parser was created as part of the HTML fragment parsing algorithm (fragment case) and the context element passed to that algorithm is a select element:
• Parse error.
• Ignore the token.
</li>
			<li>
<p>
~ELIF［
`視野~内$に在る( `既定の視野$, `select^e )
］：
◎
Otherwise, if the stack of open elements has a select element in scope:
</p>
				<ol>
					<li>
`~perror$ — 現tokenは無視する
◎
Parse error.
◎
Ignore the token.
</li>
					<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
					<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
					<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>
開始~tag { `option^l }
◎
A start tag whose tag name is "option"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `select^e )
］：
◎
If the stack of open elements has a select element in scope:
</p>
				<ol>
					<li>
`暗黙な終了~tagたちを生成する$( `optgroup$e )
◎
Generate implied end tags except for optgroup elements.
</li>
					<li>
~IF［
`視野~内$に在る( `既定の視野$, `option^e )
］
⇒
`~perror$
◎
If the stack of open elements has an option element in scope, then this is a parse error.
</li>
				</ol>
			</li>
			<li>
~ELIF［
`現在の~node$は `option$e 要素である
］
⇒
`~open要素~stack$から~popする
◎
Otherwise:
• If the current node is an option element, then pop the current node off the stack of open elements.
</li>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `optgroup^l }
◎
A start tag whose tag name is "optgroup"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `select^e )
］：
◎
If the stack of open elements has a select element in scope:
</p>
				<ol>
					<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
~IF［
`視野~内$に在る( `既定の視野$, { `option^e, `optgroup^e } )
］
⇒
`~perror$
◎
If the stack of open elements has an option element in scope or has an optgroup element in scope, then this is a parse error.
</li>
				</ol>
			</li>
			<li>
~ELIF［
`現在の~node$は `option$e 要素である
］
⇒
`~open要素~stack$から~popする
◎
Otherwise, if the current node is an option element, then pop the current node from the stack of open elements.
</li>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `rb^l, `rtc^l }
◎
A start tag whose tag name is one of: "rb", "rtc"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `ruby^e )
］：
</p>
				<ol>
					<li>
`暗黙な終了~tagたちを生成する$()
</li>
					<li>
~IF［
`現在の~node$は `ruby$e 要素でない
］
⇒
`~perror$
</li>
				</ol>
◎
If the stack of open elements has a ruby element in scope, then generate implied end tags. If the current node is not now a ruby element, this is a parse error.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `rp^l, `rt^l }
◎
A start tag whose tag name is one of: "rp", "rt"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `ruby^e )
］：
</p>
				<ol>
					<li>
`暗黙な終了~tagたちを生成する$( `rtc$e )
</li>
					<li>
~IF［
`現在の~node$は［
`rtc$e ／ `ruby$e
］要素でない
］
⇒
`~perror$
</li>
				</ol>

◎
If the stack of open elements has a ruby element in scope, then generate implied end tags, except for rtc elements. If the current node is not now a rtc element or a ruby element, this is a parse error.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `math^l }
◎
A start tag whose tag name is "math"
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`~MathML属性たちを調整する$( 現token )
（これは、
すべて小文字ではない~MathML属性の文字大小を修正する。）
◎
Adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)
</li>
			<li>
`外来な属性たちを調整する$( 現token )
（これは、
名前空間~付きの属性の利用
 — 特に~XLink  —
 を修正する。）
◎
Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink.)
</li>
			<li>
`要素を挿入する$( 現token, `~MathML名前空間$ )
◎
Insert a foreign element for the token, with MathML namespace and false.
</li>
			<li>
<p>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］：
</p>

<ol><li>`~open要素~stack$から~popする
</li><li>`自己閉じを承認する$( 現token )
</li></ol>

◎
If the token has its self-closing flag set, pop the current node off the stack of open elements and acknowledge the token's self-closing flag.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `svg^l }
◎
A start tag whose tag name is "svg"
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`~SVG属性たちを調整する$( 現token )
（これは、
すべて小文字ではない~SVG属性の文字大小を修正する。）
◎
Adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)
</li>
			<li>
`外来な属性たちを調整する$( 現token )
（これは、
名前空間~付きの属性の利用
— 特に~SVGにおける~XLink —
を修正する。）
◎
Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)
</li>
			<li>
`要素を挿入する$( 現token, `~SVG名前空間$ )
◎
Insert a foreign element for the token, with SVG namespace and false.
</li>
			<li>
<p>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］：
</p>

<ol><li>`~open要素~stack$から~popする
</li><li>`自己閉じを承認する$( 現token )
</li></ol>

◎
If the token has its self-closing flag set, pop the current node off the stack of open elements and acknowledge the token's self-closing flag.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `caption^l, `col^l, `colgroup^l, `frame^l, `head^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
その他の開始~tag
◎
Any other start tag
</dt>
	<dd>
		<ol>
			<li>
`作動中な整形~要素たちを構築し直す$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
<p>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</p>

<p class="note">注記：
この要素は、
`普通の要素$になる。
ただし，例外として、［
`~scripting~flag$ ~EQ `不能化^i
］の場合，
`noscript$e 要素にもなり得る。
◎
This element will be an ordinary element. With one exception: if the scripting flag is disabled, it can also be a noscript element.
</p>
			</li>
		</ol>
	</dd>

	<dt>
その他の終了~tag
◎
Any other end tag
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
<p>
`~open要素~stack$を成す
~EACH( %~node )
に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
				<ol>
					<li>
<p>
~IF［
%~node は現tokenと~tag名が同じ`~HTML要素$である
］：
◎
Loop: If node is an HTML element with the same tag name as the token, then:
</p>

						<ol>
							<li>
`暗黙な終了~tagたちを生成する$( 現tokenと~tag名が同じ`~HTML要素$ )
◎
Generate implied end tags, except for HTML elements with the same tag name as the token.
</li>
							<li>
~IF［
%~node は`現在の~node$でない
］
⇒
`~perror$
◎
If node is not the current node, then this is a parse error.
</li>
							<li>
%~node が`出るまで~open要素~stackから~popする$
◎
Pop all the nodes from the current node up to node, including node, then stop these steps.
</li>
							<li>
~RET
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~node は`特別$である
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
Otherwise, if node is in the special category, then this is a parse error; ignore the token, and return.
◎
Set node to the previous entry in the stack of open elements.
◎
Return to the step labeled loop.
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>


<div class="algo">
<p>
上の手続きにて
`次回の~LF文字~tokenは無視するようにしておく@
と記された所では、
次回に発された~tokenが次を満たす場合には，
それは無視する（飛ばす）ようにしておくことを意味する
⇒
文字~tokenであって，その文字 ~EQ `000A^U である
</p>

<p>
（これは，著作~便利のため、［
`pre$e ~block ／ `textarea$e 要素
］の始端に在る改行文字を無視するためにある。）
</p>

◎
↑↑</div>

<div class="algo">
<p>
`~p要素を閉じる@
~algoは：
◎
When the steps above say the user agent is to close a p element, it means that the user agent must run the following steps:
</p>
<ol>
	<li>
`暗黙な終了~tagたちを生成する$( `p$e )
◎
Generate implied end tags, except for p elements.
</li>
	<li>
~IF［
`現在の~node$は `p$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a p element, then this is a parse error.
</li>
	<li>
`p$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a p element has been popped from the stack.
</li>
</ol>
</div>

<div class="algo">
<p id="adoptionAgency">
`養子縁組~algo@
は、
所与の
( ~token %~token )
に対し：
◎
The adoption agency algorithm, which takes as its only argument a token token for which the algorithm is being run, consists of the following steps:
</p>
<ol>
	<li>
%整形~要素~list ~LET `作動中な整形~要素~list$
◎
↓</li>
	<li>
<p>
~IF［
`現在の~node$は`~HTML要素$である
］~AND［
`現在の~node$の~tag名 ~EQ %~token の~tag名
］~AND［
`現在の~node$ ~NIN %整形~要素~list
］：
</p>
<ol><li>`~open要素~stack$から~popする
</li><li>~RET
</li></ol>
◎
Let subject be token's tag name.
◎
If the current node is an HTML element whose tag name is subject, and the current node is not in the list of active formatting elements, then pop the current node off the stack of open elements and return.
</li>
	<li>
%外縁~loop~counter ~LET 0
◎
Let outerLoopCounter be 0.
</li>
	<li>
<p>
~WHILE 無条件：
◎
While true:
</p>
		<ol>
			<li>
~IF［
%外縁~loop~counter ~GTE 8
］
⇒
~RET
◎
If outerLoopCounter is greater than or equal to 8, then return.
</li>
			<li>
%外縁~loop~counter ~INCBY 1
◎
Increment outerLoopCounter by 1.
</li>
			<li>
<p>
%整形~要素 ~LET %整形~要素~list 内に次を満たす要素が［
在るならば それらのうち最後のもの／
無いならば ε
］：
◎
Let formattingElement be the last element in the list of active formatting elements that:
</p>
				<ul>
					<li>
%整形~要素~list 内の要素より後には`~marker$は無い
◎
is between the end of the list and the last marker in the list, if any, or the start of the list otherwise, and
</li>
					<li>
要素の~tag名 ~EQ %~token の~tag名
◎
has the tag name subject.
</li>
				</ul>
			</li>
			<li>
<p>
~IF［
%整形~要素 ~EQ ε
］：
</p>
<ol><li>上に述べた  “その他の終了~tag” と同じに動作する
</li><li>~RET
</li></ol>

◎
If there is no such element, then return and instead act as described in the "any other end tag" entry above.
</li>
			<li>
<p>
~IF［
%整形~要素 ~NIN `~open要素~stack$
］：
</p>
<ol><li>`~perror$
</li><li>%整形~要素~list から %整形~要素 を除去する
</li><li>~RET
</li></ol>

◎
If formattingElement is not in the stack of open elements, then this is a parse error; remove the element from the list, and return.
</li>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, %整形~要素 )
］：
</p>
<ol><li>`~perror$
</li><li>~RET
</li></ol>
◎
If formattingElement is in the stack of open elements, but the element is not in scope, then this is a parse error; return.
</li>
			<li>
~IF［
%整形~要素 ~NEQ `現在の~node$
］
⇒
`~perror$
◎
If formattingElement is not the current node, this is a parse error. (But do not return.)
</li>
			<li>
%最遠な~block ~LET `~open要素~stack$内で %整形~要素 より後に`特別な要素$が［
在るならば それらのうち最初のもの ／
無いならば ε
］
◎
Let furthestBlock be the topmost node in the stack of open elements that is lower in the stack than formattingElement, and is an element in the special category. There might not be one.
</li>
			<li>
<p>
~IF［
%最遠な~block ~EQ ε
］：
</p>

<ol><li>%整形~要素 が`出るまで~open要素~stackから~popする$
</li><li>%整形~要素~list から %整形~要素 を除去する
</li><li>~RET
</li></ol>
◎
If there is no furthestBlock, then the UA must first pop all the nodes from the bottom of the stack of open elements, from the current node up to and including formattingElement, then remove formattingElement from the list of active formatting elements, and finally return.
</li>
			<li>
%共通な先祖 ~LET
`~open要素~stack$内で %整形~要素 の直前に在る要素
◎
Let commonAncestor be the element immediately above formattingElement in the stack of open elements.
</li>
			<li>
%~bookmark ~LET %整形~要素~list 内で %整形~要素 の直後を指す位置
◎
Let a bookmark note the position of formattingElement in the list of active formatting elements relative to the elements on either side of it in the list.
</li>
			<li>
%最後の~node ~LET %最遠な~block
◎
Let node and lastNode be furthestBlock.
↓↓</li>
			<li>
%内縁~loop~counter ~LET 0
◎
Let innerLoopCounter be 0.
</li>
			<li>
<p>
`~open要素~stack$内で
%整形~要素 より後に在る, かつ
%最遠な~block より前に在る
~EACH( %~node )
に対し，最後のものから順に：
◎
While true:
• Increment innerLoopCounter by 1.
• Let node be the element immediately above node in the stack of open elements, or if node is no longer in the stack of open elements (e.g. because it got removed by this algorithm), the element that was immediately above node in the stack of open elements before node was removed.
• If node is formattingElement, then break.
</p>
				<ol>
					<li>
%内縁~loop~counter ~INCBY 1
◎
↑</li>
					<li>
~IF［
%内縁~loop~counter ~GT 3
］~AND［
%~node ~IN %整形~要素~list
］
⇒
%整形~要素~list から %~node を除去する
◎
If innerLoopCounter is greater than 3 and node is in the list of active formatting elements, then remove node from the list of active formatting elements.
</li>
					<li>
<p>
~IF［
%~node ~NIN %整形~要素~list
］：
</p>
<ol><li>%~node を`~open要素~stack$から除去する
</li><li>~CONTINUE
</li></ol>
◎
If node is not in the list of active formatting elements, then remove node from the stack of open elements and continue.
</li>
					<li>
%新たな要素 ~LET
`~tokenから要素を作成する$( 要素 %~node を`作成させた~token$, `~HTML名前空間$, %共通な先祖 )
◎
Create an element for the token for which the element node was created, in the HTML namespace, with commonAncestor as the intended parent;＼
</li>
					<li>
%整形~要素~list 内で %~node を %新たな要素 に置換する
◎
replace the entry for node in the list of active formatting elements with an entry for the new element,＼
</li>
					<li>
`~open要素~stack$内で %~node を %新たな要素 に置換する
◎
replace the entry for node in the stack of open elements with an entry for the new element, and＼
</li>
					<li>
%~node ~SET %新たな要素
◎
let node be the new element.
</li>
					<li>
~IF［
%最後の~node ~EQ %最遠な~block
］
⇒
%~bookmark ~SET %整形~要素~list 内で %~node の直後を指す位置
◎
If lastNode is furthestBlock, then move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
</li>
					<li>
%~node に`~nodeを付加する$( %最後の~node )
◎
Append lastNode to node.
</li>
					<li>
%最後の~node ~SET %~node
◎
Set lastNode to node.
</li>
				</ol>
			</li>
			<li>
%最後の~node を`適切な~node挿入-先$( %共通な先祖 ) に挿入する
— この段に達した時点での %最後の~node が何であれ
◎
Insert whatever lastNode ended up being in the previous step at the appropriate place for inserting a node, but using commonAncestor as the override target.
</li>
			<li>
%新たな要素 ~LET `~tokenから要素を作成する$( %整形~要素 を`作成させた~token$, `~HTML名前空間$, %最遠な~block )
◎
Create an element for the token for which formattingElement was created, in the HTML namespace, with furthestBlock as the intended parent.
</li>
			<li>
<p>
%最遠な~block を成す
~EACH( 子~node %子 )
に対し：
</p>
<ol><li>%最遠な~block から %子 を除去する
</li><li>%新たな要素 に %子 を付加する
</li></ol>

◎
Take all of the child nodes of furthestBlock and append them to the element created in the last step.
</li>
			<li>
%最遠な~block に
%新たな要素 を付加する
◎
Append that new element to furthestBlock.
</li>
			<li>
%整形~要素 を %整形~要素~list から除去する
◎
Remove formattingElement from the list of active formatting elements, and＼
</li>
			<li>
%整形~要素~list 内で %~bookmark が指す位置に，
%新たな要素 を挿入する
◎
insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
</li>
			<li>
%整形~要素 を`~open要素~stack$から除去する
◎
Remove formattingElement from the stack of open elements, and＼
</li>
			<li>
`~open要素~stack$内で %最遠な~block の直後に，
%新たな要素 を挿入する
◎
insert the new element into the stack of open elements immediately below the position of furthestBlock in that stack.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この~algoの名前
“養子縁組”
は、
それが要素の親を変更する仕方に~~由来する
— 誤入子な内容に~~対処する~algoの`~~候補は他にもあったが＠https://ln.hixie.ch/?start=1037910467&amp;count=1$。
◎
This algorithm's name, the "adoption agency algorithm", comes from the way it causes elements to change parents, and is in contrast with other possible algorithms for dealing with misnested content.
</p>
</div>

					</section>
					<section id="parsing-main-incdata">
<h6 title="The &quot;text&quot; insertion mode">13.2.6.4.8. `~text^md</h6>

<p>
［
`挿入~mode$ ~EQ `~text$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "text" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token
◎
A character token
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the token's character.
</dd>
	<dd class="note">注記：
この~tokenの文字が、
`0000^U になることは決してない
— そのような文字は、
~tokenizerにより `FFFD^U に変換されるので。
◎
This can never be a U+0000 NULL character; the tokenizer converts those to U+FFFD REPLACEMENT CHARACTER characters.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`現在の~node$は `script$e 要素である
］
⇒
`現在の~node$の`すでに開始したか$scE ~SET ~T
◎
If the current node is a script element, then set its already started to true.
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt id="scriptEndTag">
終了~tag { `script^l }
◎
An end tag whose tag name is "script"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`作動中な投機的な~HTML構文解析器$ ~EQ ~NULL
］~AND［
`~JS実行~文脈~stack$は空である
］
⇒
`小task~checkpointを遂行する$
◎
If the active speculative HTML parser is null and the JavaScript execution context stack is empty, then perform a microtask checkpoint.
</li>
			<li>
%~script ~LET `現在の~node$
◎
Let script be the current node＼
</li>
			<li>
~Assert：
%~script は `script$e 要素である
◎
(which will be a script element).
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode.
</li>
			<li>
%旧~挿入~地点~LET 現在の`挿入~地点$
◎
Let the old insertion point have the same value as the current insertion point.＼
</li>
			<li>
`挿入~地点$ ~SET `次回の入力~文字$の直前
◎
Let the insertion point be just before the next input character.
</li>
			<li>
%構文解析器 の`~script入子ng~level$ ~INCBY 1
◎
Increment the parser's script nesting level by one.
</li>
			<li>
~IF［
`作動中な投機的な~HTML構文解析器$ ~EQ ~NULL
］
⇒
`~script要素を準備する$( %~script )
⇒
これは何らかの~scriptを実行させ得る
— その結果
⇒
~tokenizerに`新たな文字たちが挿入され得る＠~HTMLdynamic#dom-document-write$
— その結果
⇒
~tokenizerにさらに~tokenたちを出力させ得る
— その結果
⇒
%構文解析器 は`再入的に呼出される＠#nestedParsing$
◎
If the active speculative HTML parser is null, then prepare the script element script. This might cause some script to execute, which might cause new characters to be inserted into the tokenizer, and might cause the tokenizer to output more tokens, resulting in a reentrant invocation of the parser.
</li>
			<li>
%構文解析器 の`~script入子ng~level$ ~DECBY 1
◎
Decrement the parser's script nesting level by one.＼
</li>
			<li>
~IF［
%構文解析器 の`~script入子ng~level$ ~EQ 0
］
⇒
%構文解析器 の`静止するか$ ~SET ~F
◎
If the parser's script nesting level is zero, then set the parser pause flag to false.
</li>
			<li>
`挿入~地点$ ~SET %旧~挿入~地点
◎
Let the insertion point have the value of the old insertion point. (In other words, restore the insertion point to its previous value. This value might be the "undefined" value.)
</li>
			<li id="scriptTagParserResumes">
~IF［
`文書$の`構文解析器を阻んでいる~script$ ~EQ ~NULL
］
⇒
~RET
◎
At this stage, if the pending parsing-blocking script is not null, then:
</li>
			<li>
<p>
~IF［
`~script入子ng~level$ ~NEQ 0
］：
◎
If the script nesting level is not zero:
</p>
				<ol>
					<li>
%構文解析器 の`静止するか$ ~SET ~T
◎
Set the parser pause flag to true, and＼
</li>
			<li>
<p>
入子にして呼出されている~tokenizerがあれば、
その処理も中止して，その~call元~の制御~下に戻す
（~token化は、
~call元が “外縁の” ~tree構築~段階に戻ったとき，
再開することになる。）
◎
abort the processing of any nested invocations of the tokenizer, yielding control back to the caller. (Tokenization will resume when the caller returns to the "outer" tree construction stage.)
</p>

<p class="note">注記：
%構文解析器 の~tree構築~段階は、
`再入的に~callされている＠#nestedParsing$
— 例えば `document.write()$c の~callから。
◎
The tree construction stage of this particular parser is being called reentrantly, say from a call to document.write().
</p>
					</li>
					<li>
~RET
◎
↓</li>
				</ol>
			</li>
			<li>
<p>
~WHILE［
`文書$の`構文解析器を阻んでいる~script$ ~NEQ ~NULL
］：
◎
Otherwise:
• While the pending parsing-blocking script is not null:
</p>
				<ol>
					<li>
%当の~script ~LET `文書$の`構文解析器を阻んでいる~script$
◎
Let the script be the pending parsing-blocking script.
</li>
					<li>
`文書$の`構文解析器を阻んでいる~script$ ~SET ~NULL
◎
Set the pending parsing-blocking script to null.
</li>
					<li>
%構文解析器 用の`投機的な~HTML構文解析器を開始する$
◎
Start the speculative HTML parser for this instance of the HTML parser.
</li>
					<li>
%構文解析器 の`~tokenizer$を阻む
— `~event~loop$が その`~tokenizer$を呼出す`~task$を走らすことのないよう
◎
Block the tokenizer for this instance of the HTML parser, such that the event loop will not run tasks that invoke the tokenizer.
</li>
					<li>
<p>
%条件 ~LET ~AND↓：
</p>
						<ul>
							<li>
`~scriptを阻んでいる~stylesheetは在るか？$( `文書$ ) ~EQ ~F
</li>
							<li>
%当の~script の`構文解析器にて実行されるに準備済みか$scE ~EQ ~T
</li>
						</ul>
◎
↓</li>
					<li>
~IF［
%条件 は満たされていない
］
⇒
%条件 が満たされるまで`~event~loopを回す$
◎
If the parser's Document has a style sheet that is blocking scripts or the script's ready to be parser-executed is false: spin the event loop until the parser's Document has no style sheet that is blocking scripts and the script's ready to be parser-executed becomes true.
</li>
					<li>
<p>
~IF［
%構文解析器 は（当面の間）`中止-$されている
］
⇒
~RET
◎
If this parser has been aborted in the meantime, return.
</p>

<p class="note">注記：
これは，例えば、
`~event~loopを回す$~algoが走っている間に，［
`文書$が`破壊された＠~HTMLlifecycle#destroy-a-document$／
`文書$上で `document.open()$c ~methodが呼出された
］場合に起こり得る。
◎
This could happen if, e.g., while the spin the event loop algorithm is running, the Document gets destroyed, or the document.open() method gets invoked on the Document.
</p>
					</li>
					<li>
%構文解析器 用の`投機的な~HTML構文解析器を停止する$
◎
Stop the speculative HTML parser for this instance of the HTML parser.
</li>
					<li>
%構文解析器 の`~tokenizer$を阻むのをやめて、
`~tokenizer$を呼出している`~task$が，再度~走れるようにする
◎
Unblock the tokenizer for this instance of the HTML parser, such that tasks that invoke the tokenizer can again be run.
</li>
					<li>
`挿入~地点$ ~SET `次回の入力~文字$の直前
◎
Let the insertion point be just before the next input character.
</li>
					<li>
~Assert：
%構文解析器 の`~script入子ng~level$ ~EQ 0 であるべき
◎
↓</li>
					<li>
%構文解析器 の`~script入子ng~level$ ~INCBY 1
◎
Increment the parser's script nesting level by one (it should be zero before this step, so this sets it to one).
</li>
					<li>
`~script要素を実行する$( %当の~script )
◎
Execute the script element the script.
</li>
					<li>
%構文解析器 の`~script入子ng~level$ ~DECBY 1
◎
Decrement the parser's script nesting level by one.＼
</li>
					<li>
~Assert：
%構文解析器 の`~script入子ng~level$ ~EQ 0 であるべき
◎
↓</li>
					<li>
~IF［
%構文解析器 の`~script入子ng~level$ ~EQ 0
］
⇒
%構文解析器 の`静止するか$ ~SET ~F
◎
If the parser's script nesting level is zero (which it always should be at this point), then set the parser pause flag to false.
</li>
					<li>
`挿入~地点$ ~SET ε
◎
Let the insertion point be undefined again.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
		<ol>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-intable">
<h6 title="The &quot;in table&quot; insertion mode">13.2.6.4.9. `~table内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~table内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in table" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token
◎
A character token,＼
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は［
`table$e, `tbody$e, `template$e, `tfoot$e, `thead$e, `tr$e
］いずれの要素でもない
］
⇒
~GOTO ~AnyElse
◎
if the current node is table, tbody, template, tfoot, thead, or tr element
</li>
			<li>
`処理待ち~table文字~token~list@V ~LET 空な~token~list
◎
Let the pending table character tokens be an empty list of tokens.
</li>
			<li>
`元の挿入~mode$V ~SET `~table内$md
◎
Set the original insertion mode to the current insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~table~text内$md
◎
Switch the insertion mode to "in table text" and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `caption^l }
◎
A start tag whose tag name is "caption"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`作動中な整形~要素~list$に`~marker$を付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~caption内$md
◎
switch the insertion mode to "in caption".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `colgroup^l }
◎
A start tag whose tag name is "colgroup"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~col~group内$md
◎
switch the insertion mode to "in column group".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `col^l }
◎
A start tag whose tag name is "col"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 新たな開始~tag~token( `colgroup^l ) )
◎
Insert an HTML element for a "colgroup" start tag token with no attributes, then＼
</li>
			<li>
`挿入~mode$ ~SET `~col~group内$md
◎
switch the insertion mode to "in column group".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the current token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `tbody^l, `tfoot^l, `thead^l }
◎
A start tag whose tag name is one of: "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
switch the insertion mode to "in table body".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `td^l, `th^l, `tr^l }
◎
A start tag whose tag name is one of: "td", "th", "tr"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 新たな開始~tag~token( `tbody^l ) )
◎
Insert an HTML element for a "tbody" start tag token with no attributes, then＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
switch the insertion mode to "in table body".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the current token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `table^l }
◎
A start tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`視野~内$に無い( `~table視野$, `table^e )
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have a table element in table scope, ignore the token.
◎
Otherwise:
</li>
			<li>
`table$e 要素が`出るまで~open要素~stackから~popする$
◎
• Pop elements from this stack until a table element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に設定し直す$
◎
• Reset the insertion mode appropriately.
</li>
			<li>
現tokenを処理し直す
◎
• Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `table^e )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a table element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`table$e 要素が`出るまで~open要素~stackから~popする$
◎
• Pop elements from this stack until a table element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に設定し直す$
◎
• Reset the insertion mode appropriately.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `style^l, `script^l, `template^l }
◎
A start tag whose tag name is one of: "style", "script", "template"
</dt>

	<dt>
終了~tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
開始~tag { `input^l }
◎
A start tag whose tag name is "input"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
現token上に ~AND↓ を満たす属性は無い
］…
</p>
				<ul>
					<li>
名前 ~EQ `type^l
</li>
					<li>
値 ~EQ`大小無視$sub `hidden^l
</li>
				</ul>
<p>
…ならば
⇒
~GOTO ~AnyElse
</p>
◎
If the token does not have an attribute with the name "type", or if it does, but that attribute's value is not an ASCII case-insensitive match for the string "hidden", then: act as described in the "anything else" entry below.
◎
Otherwise:
</li>
			<li>
`~perror$
◎
• Parse error.
</li>
			<li>
`要素を挿入する$( 現token )
◎
• Insert an HTML element for the token.
</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop that input element off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
• Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `form^l }
◎
A start tag whose tag name is "form"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`~open要素~stack$内には `template$e 要素は在る
］~OR［
`~form要素~pointer$ ~NEQ ~NULL
］
⇒
~RET — 現tokenは無視する
◎
If there is a template element on the stack of open elements, or if the form element pointer is not null, ignore the token.
◎
Otherwise:
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
• Insert an HTML element for the token, and＼
</li>
			<li>
`~form要素~pointer$ ~SET %要素
◎
set the form element pointer to point to the element created.
</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop that form element off the stack of open elements.
</li>
		</ol>
	</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.＼
</li>
			<li>
`親を違える$ことを可能化する
◎
Enable foster parenting,＼
</li>
			<li>
`~body内$md`用の規則を利用して$現tokenを処理する
◎
process the token using the rules for the "in body" insertion mode, and then＼
</li>
			<li>
`親を違える$ことを不能化する
◎
disable foster parenting.
</li>
		</ol>
	</dd>
</dl>

<div class="algo">
<p>
`~stackを~table文脈まで遡って~clearする@
~algoは
⇒
~WHILE［
`現在の~node$は［
`table$e ／ `template$e ／ `html$e
］要素でない
］
⇒
`~open要素~stack$から~popする
◎
When the steps above require the UA to clear the stack back to a table context, it means that the UA must, while the current node is not a table, template, or html element, pop elements from the stack of open elements.
</p>

<p class="note">注記：
これは、
`~table視野$に挙げられた要素たちと同じである。
◎
This is the same list of elements as used in the has an element in table scope steps.
</p>

<p class="note">注記：
この処理-後に`現在の~node$が `html$e 要素になるのは、
`素片~事例$に限られる。
◎
The current node being an html element after this process is a fragment case.
</p>
</div>

					</section>
					<section id="parsing-main-intabletext">
<h6 title="The &quot;in table text&quot; insertion mode">13.2.6.4.10. `~table~text内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~table~text内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in table text" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
<ol><li>`処理待ち~table文字~token~list$V に現tokenを付加する
</li></ol>
◎
Append the character token to the pending table character tokens list.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`処理待ち~table文字~token~list$V 内の ある文字~tokenの文字は`~ASCII空白$でない
］：
</p>

<ol><li>`~perror$
</li><li>`処理待ち~table文字~token~list$V を成す
~EACH( 文字~token )
に対し
⇒
文字~tokenを［
`~table内$md 挿入~modeにおける ~AnyElse ~entryに与える規則
］を利用して処理し直す
</li></ol>

◎
If any of the tokens in the pending table character tokens list are character tokens that are not ASCII whitespace, then this is a parse error: reprocess the character tokens in the pending table character tokens list using the rules given in the "anything else" entry in the "in table" insertion mode.
</li>
			<li>
~ELSE
⇒
`処理待ち~table文字~token~list$V を成す
~EACH( ~token )
に対し
⇒
`文字を挿入する$( ~tokenの文字 )
◎
Otherwise, insert the characters given by the pending table character tokens list.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-incaption">
<h6 title="The &quot;in caption&quot; insertion mode">13.2.6.4.11. `~caption内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~caption内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in caption" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
終了~tag { `caption^l }
◎
An end tag whose tag name is "caption"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `caption^e )
（`素片~事例$）
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a caption element in table scope, this is a parse error; ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`暗黙な終了~tagたちを生成する$()
◎
• Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は `caption$e 要素でない
］
⇒
`~perror$
◎
• Now, if the current node is not a caption element, then this is a parse error.
</li>
			<li>
`caption$e 要素が`出るまで~open要素~stackから~popする$
◎
• Pop elements from this stack until a caption element has been popped from the stack.
</li>
			<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
• Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
• Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>

	<dt>
終了~tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `caption^e )
（`素片~事例$）
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a caption element in table scope, this is a parse error; ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`暗黙な終了~tagたちを生成する$()
◎
• Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は `caption$e 要素でない
］
⇒
`~perror$
◎
• Now, if the current node is not a caption element, then this is a parse error.
</li>
			<li>
`caption$e 要素が`出るまで~open要素~stackから~popする$
◎
• Pop elements from this stack until a caption element has been popped from the stack.
</li>
			<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
• Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
• Switch the insertion mode to "in table".
</li>
			<li>
現tokenを処理し直す
◎
• Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l, `col^l, `colgroup^l, `html^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
An end tag whose tag name is one of: "body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>
</dl>

					</section>
					<section id="parsing-main-incolgroup">
<h6 title="The &quot;in column group&quot; insertion mode">13.2.6.4.12. `~col~group内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~col~group内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in column group" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始~tag { `col^l }
◎
A start tag whose tag name is "col"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `colgroup^l }
◎
An end tag whose tag name is "colgroup"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は `colgroup$e 要素でない
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the current node is not a colgroup element, then this is a parse error; ignore the token.
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise, pop the current node from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `col^l }
◎
An end tag whose tag name is "col"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `template^l }
◎
A start tag whose tag name is "template"
</dt>

	<dt>
終了~tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は `colgroup$e 要素でない
］：
</p>

<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the current node is not a colgroup element, then this is a parse error; ignore the token.
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise, pop the current node from the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-intbody">
<h6 title="The &quot;in table body&quot; insertion mode">13.2.6.4.13. `~table~body内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~table~body内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in table body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
開始~tag { `tr^l }
◎
A start tag whose tag name is "tr"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
Clear the stack back to a table body context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
switch the insertion mode to "in row".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `th^l, `td^l }
◎
A start tag whose tag name is one of: "th", "td"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
Clear the stack back to a table body context. (See below.)
</li>
			<li>
`要素を挿入する$( 新たな開始~tag~token( `tr^l ) )
◎
Insert an HTML element for a "tr" start tag token with no attributes, then＼
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
switch the insertion mode to "in row".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the current token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `tbody^l, `tfoot^l, `thead^l }
◎
An end tag whose tag name is one of: "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as the token, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
• Clear the stack back to a table body context. (See below.)
</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop the current node from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
• Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `tfoot^l, `thead^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot", "thead"
</dt>

	<dt>
終了~tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, { `tbody^e, `thead^e, `tfoot^e } )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a tbody, thead, or tfoot element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
• Clear the stack back to a table body context. (See below.)
</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop the current node from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
• Switch the insertion mode to "in table".
</li>
			<li>
現tokenを処理し直す
◎
• Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l, `td^l, `th^l, `tr^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td", "th", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~table内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in table" insertion mode.
</dd>
</dl>

<div class="algo">
<p>
`~stackを~table~body文脈まで遡って~clearする@
~algoは
⇒
~WHILE［
`現在の~node$は［
`tbody$e ／ `tfoot$e ／ `thead$e ／ `template$e ／ `html$e
］ 要素でない
］
⇒
`~open要素~stack$から~popする
◎
When the steps above require the UA to clear the stack back to a table body context, it means that the UA must, while the current node is not a tbody, tfoot, thead, template, or html element, pop elements from the stack of open elements.
</p>

<p class="note">注記：
この処理-後に`現在の~node$が `html$e 要素になるのは、
`素片~事例$に限られる。
◎
The current node being an html element after this process is a fragment case.
</p>
</div>

					</section>
					<section id="parsing-main-intr">
<h6 title="The &quot;in row&quot; insertion mode">13.2.6.4.14. `~row内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~row内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in row" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
開始~tag { `th^l, `td^l }
◎
A start tag whose tag name is one of: "th", "td"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
Clear the stack back to a table row context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~cell内$md
◎
switch the insertion mode to "in cell".
</li>
			<li>
`作動中な整形~要素~list$に`~marker$を付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `tr^l }
◎
An end tag whose tag name is "tr"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `tr^e )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a tr element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
• Clear the stack back to a table row context. (See below.)
</li>
			<li>
~Assert：
`現在の~node$は `tr$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop the current node (which will be a tr element) from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
• Switch the insertion mode to "in table body".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `tfoot^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot", "thead", "tr"
</dt>

	<dt>
終了~tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `tr^e )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a tr element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
• Clear the stack back to a table row context. (See below.)
</li>
			<li>
~Assert：
`現在の~node$は `tr$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop the current node (which will be a tr element) from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
• Switch the insertion mode to "in table body".
</li>
			<li>
現tokenを処理し直す
◎
• Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `tbody^l, `tfoot^l, `thead^l }
◎
An end tag whose tag name is one of: "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>

<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as the token, this is a parse error; ignore the token.
</li>
			<li>
~IF［
`視野~内$に無い( `~table視野$, `tr^e )
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have a tr element in table scope, ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
• Clear the stack back to a table row context. (See below.)
</li>
			<li>
~Assert：
`現在の~node$は `tr$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
• Pop the current node (which will be a tr element) from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
• Switch the insertion mode to "in table body".
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l, `td^l, `th^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td", "th"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~table内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in table" insertion mode.
</dd>
</dl>

<div class="algo">
<p>
`~stackを~table~row文脈まで遡って~clearする@
~algoは
⇒
~WHILE［
`現在の~node$は［
`tr$e ／ `template$e ／ `html$e
］ 要素でない
］
⇒
`~open要素~stack$から~popする
◎
When the steps above require the UA to clear the stack back to a table row context, it means that the UA must, while the current node is not a tr, template, or html element, pop elements from the stack of open elements.
</p>

<p class="note">注記：
この処理-後に`現在の~node$が `html$e 要素になるのは、
`素片~事例$に限られる。
◎
The current node being an html element after this process is a fragment case.
</p>
</div>

					</section>
					<section id="parsing-main-intd">
<h6 title="The &quot;in cell&quot; insertion mode">13.2.6.4.15. `~cell内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~cell内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in cell" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
終了~tag { `td^l, `th^l }
◎
An end tag whose tag name is one of: "td", "th"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`暗黙な終了~tagたちを生成する$()
◎
• Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
• Now, if the current node is not an HTML element with the same tag name as the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
• Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
			<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
• Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
• Switch the insertion mode to "in row".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
		<ol>
			<li>
~Assert：
`視野~内$に在る( `~table視野$, { `td^e, `th^e } )
◎
Assert: The stack of open elements has a td or th element in table scope.
</li>
			<li>
`~cellを閉じる$
◎
Close the cell (see below) and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了~tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
終了~tag { `table^l, `tbody^l, `tfoot^l, `thead^l, `tr^l }
◎
An end tag whose tag name is one of: "table", "tbody", "tfoot", "thead", "tr"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>

<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
</li>
			<li>
`~cellを閉じる$
◎
Otherwise, close the cell (see below) and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>
</dl>

<div class="algo">
<p>
`~cellを閉じる@
~algoは：
◎
Where the steps above say to close the cell, they mean to run the following algorithm:
</p>
<ol>
	<li>
`暗黙な終了~tagたちを生成する$()
◎
Generate implied end tags.
</li>
	<li>
~IF［
`現在の~node$は［
`td$e ／ `th$e
］要素でない
］
⇒
`~perror$
◎
If the current node is not now a td element or a th element, then this is a parse error.
</li>
	<li>
{ `td$e, `th$e }
いずれかの要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a td element or a th element has been popped from the stack.
</li>
	<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
	<li>
`挿入~mode$ ~SET `~row内$md
◎
Switch the insertion mode to "in row".
</li>
</ol>

<p class="note">注記：
`~cellを閉じる$~algoが呼出されるときは、常に，［
`視野~内$に在る( `~table視野$, `td$e ),
`視野~内$に在る( `~table視野$, `th$e )
］のうち片方だけが満たされる。
◎
The stack of open elements cannot have both a td and a th element in table scope at the same time, nor can it have neither when the close the cell algorithm is invoked.
</p>
</div>

					</section>
					<section id="parsing-main-intemplate">
<h6 title="The &quot;in template&quot; insertion mode">13.2.6.4.16. `~template内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~template内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in template" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token
◎
A character token
</dt>

	<dt>
~comment~token
◎
A comment token
</dt>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始~tag { `base^l, `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `script^l, `style^l, `template^l, `title^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
</dt>

	<dt>
終了~tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
開始~tag { `caption^l, `colgroup^l, `tbody^l, `tfoot^l, `thead^l }
◎
A start tag whose tag name is one of: "caption", "colgroup", "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~table内$mdを~pushする
◎
Push "in table" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table", and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `col^l }
◎
A start tag whose tag name is "col"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~col~group内$mdを~pushする
◎
Push "in column group" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~col~group内$md
◎
Switch the insertion mode to "in column group", and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `tr^l }
◎
A start tag whose tag name is "tr"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に `~table~body内$mdを~pushする
◎
Push "in table body" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
Switch the insertion mode to "in table body", and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `td^l, `th^l }
◎
A start tag whose tag name is one of: "td", "th"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~row内$mdを~pushする
◎
Push "in row" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
Switch the insertion mode to "in row", and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
その他の開始~tag
◎
Any other start tag
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~body内$mdを~pushする
◎
Push "in body" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~body内$md
◎
Switch the insertion mode to "in body", and＼
</li>
			<li>
現tokenを処理し直す
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
その他の終了~tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~open要素~stack$内には `template$e 要素は無い
（`素片~事例$）
］：
</p>

<ol><li>`構文解析を停止する$
</li><li>~RET
</li></ol>
◎
If there is no template element on the stack of open elements, then stop parsing. (fragment case)
</li>
			<li>
`~perror$
◎
Otherwise, this is a parse error.
</li>
			<li>
`template$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a template element has been popped from the stack.
</li>
			<li>
`作動中な整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`挿入~modeを適切に設定し直す$
◎
Reset the insertion mode appropriately.
</li>
			<li>
現tokenを処理し直す
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-afterbody">
<h6 title="The &quot;after body&quot; insertion mode">13.2.6.4.17. `~bodyの後^md</h6>

<p>
［
`挿入~mode$ ~EQ `~bodyの後$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "after body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `~open要素~stack$の先頭にある要素（ `html$e 要素）内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the first element in the stack of open elements (the html element).
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
終了~tag { `html^l }
◎
An end tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%構文解析器 は`~HTML素片~用$である
（`素片~事例$）
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the parser was created as part of the HTML fragment parsing algorithm, this is a parse error; ignore the token. (fragment case)
</li>
			<li>
~ELSE
⇒
`挿入~mode$ ~SET `~bodyの後の後$md
◎
Otherwise, switch the insertion mode to "after after body".
</li>
		</ol>
	</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$
</li><li>`挿入~mode$ ~SET `~body内$md
</li><li>現tokenを処理し直す
</li></ol>
◎
Parse error. Switch the insertion mode to "in body" and reprocess the token.
</dd>
</dl>

					</section>
					<section id="parsing-main-inframeset">
<h6 title="The &quot;in frameset&quot; insertion mode">13.2.6.4.18. `~frameset内^md</h6>

<p>
［
`挿入~mode$ ~EQ `~frameset内$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "in frameset" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始~tag { `frameset^l }
◎
A start tag whose tag name is "frameset"
</dt>
	<dd>
<ol><li>`要素を挿入する$( 現token )
</li></ol>
◎
Insert an HTML element for the token.
</dd>

	<dt>
終了~tag { `frameset^l }
◎
An end tag whose tag name is "frameset"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は根 `html$e 要素である
（`素片~事例$）
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the current node is the root html element, then this is a parse error; ignore the token. (fragment case)
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise, pop the current node from the stack of open elements.
</li>
			<li>
~IF［
%構文解析器 は`~HTML素片~用$でない
（`素片~事例$でない）
］~AND［
`現在の~node$は `frameset$e 要素でない
］
⇒
`挿入~mode$ ~SET `~framesetの後$md
◎
If the parser was not created as part of the HTML fragment parsing algorithm (fragment case), and the current node is no longer a frameset element, then switch the insertion mode to "after frameset".
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `frame^l }
◎
A start tag whose tag name is "frame"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~T
］
⇒
`自己閉じを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始~tag { `noframes^l }
◎
A start tag whose tag name is "noframes"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は根 `html$e 要素でない
］
⇒
`~perror$
◎
If the current node is not the root html element, then this is a parse error.
</p>

<p class="note">注記：
`素片~事例$においては、
`現在の~node$は，常に根 `html$e 要素になる
◎
The current node can only be the root html element in the fragment case.
</p>
			</li>
			<li>
`構文解析を停止する$
◎
Stop parsing.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
					<section id="parsing-main-afterframeset">
<h6 title="The &quot;after frameset&quot; insertion mode">13.2.6.4.19. `~framesetの後^md</h6>

<p>
［
`挿入~mode$ ~EQ `~framesetの後$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "after frameset" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
終了~tag { `html^l }
◎
An end tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`挿入~mode$ ~SET `~framesetの後の後$md
</li></ol>
◎
Switch the insertion mode to "after after frameset".
</dd>

	<dt>
開始~tag { `noframes^l }
◎
A start tag whose tag name is "noframes"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
					<section id="the-after-after-body-insertion-mode">
<h6 title="The &quot;after after body&quot; insertion mode">13.2.6.4.20. `~bodyの後の後^md</h6>

<p>
［
`挿入~mode$ ~EQ `~bodyの後の後$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "after after body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$
</li><li>`挿入~mode$ ~SET `~body内$md
</li><li>現tokenを処理し直す
</li></ol>
◎
Parse error. Switch the insertion mode to "in body" and reprocess the token.
</dd>
</dl>

					</section>
					<section id="the-after-after-frameset-insertion-mode">
<h6 title="The &quot;after after frameset&quot; insertion mode">13.2.6.4.21. `~framesetの後の後^md</h6>

<p>
［
`挿入~mode$ ~EQ `~framesetの後の後$md
］の下では、
現tokenを以下に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for the "after after frameset" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>

	<dt>
開始~tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>
開始~tag { `noframes^l }
◎
A start tag whose tag name is "noframes"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を利用して$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
				</section>
				<section id="parsing-main-inforeign">
<h5 title="The rules for parsing tokens in foreign content">13.2.6.5. 外来~内容~内~token用の構文解析~規則</h5>

<p>
~UAは、
外来~内容~内の~tokenを構文解析するための規則を適用するときは，
現tokenを次に従って取扱うモノトスル：
◎
When the user agent is to apply the rules for parsing tokens in foreign content, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$
</li><li>`文字を挿入する$( `FFFD^U )
</li></ol>
◎
Parse error. Insert a U+FFFD REPLACEMENT CHARACTER character.
</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the token's character.
</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
		<ol>
			<li>
`文字を挿入する$( 現tokenの文字 )
◎
Insert the token's character.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始~tag { `b^l, `big^l, `blockquote^l, `body^l, `br^l, `center^l, `code^l, `dd^l, `div^l, `dl^l, `dt^l, `em^l, `embed^l, `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l, `head^l, `hr^l, `i^l, `img^l, `li^l, `listing^l, `menu^l, `meta^l, `nobr^l, `ol^l, `p^l, `pre^l, `ruby^l, `s^l, `small^l, `span^l, `strong^l, `strike^l, `sub^l, `sup^l, `table^l, `tt^l, `u^l, `ul^l, `var^l }
◎
A start tag whose tag name is one of: "b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "menu", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"
</dt>
	<dt>
開始~tag { `font^l }
— ただし、
名前［
`color^l ／ `face^l ／ `size^l
］いずれかの属性を有するものに限る
◎
A start tag whose tag name is "font", if the token has any attributes named "color", "face", or "size"
</dt>
	<dt>
終了~tag { `br^l, `p^l }
◎
An end tag whose tag name is "br", "p"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~WHILE ［
`現在の~node$は［
`~MathML~text統合~地点$ ／ `~HTML統合~地点$ ／ `~HTML名前空間$に属する要素
］でない
］
⇒
`~open要素~stack$から~popする
◎
While the current node is not a MathML text integration point, an HTML integration point, or an element in the HTML namespace, pop elements from the stack of open elements.
</li>
			<li>
［
`~HTML内容~内の~token＠#parsing-main-inhtml$用の，
現在の`挿入~mode$に対応する節
］に与える規則に則って、
現tokenを処理し直す
◎
Reprocess the token according to the rules given in the section corresponding to the current insertion mode in HTML content.
</li>
		</ol>
	</dd>

	<dt>
その他の開始~tag
◎
Any other start tag
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の調整-済み~node$は`~MathML名前空間$に属する要素である
］
⇒
`~MathML属性たちを調整する$( 現token )
（これは、
すべて小文字ではない~MathML属性の文字大小を修正する。）
◎
If the adjusted current node is an element in the MathML namespace, adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)
</li>
			<li>
<p>
~IF［
`現在の調整-済み~node$は`~SVG名前空間$に属する要素である
］~AND［
現tokenの~tag名 ~IN { 次の表tの 1 列目に挙げる名前 }
］
⇒
現tokenの~tag名 ~SET 名前が見出された行の 2 列目に与える名前
（これは、
すべて小文字ではない~SVG要素の文字大小を修正する。）
◎
If the adjusted current node is an element in the SVG namespace, and the token's tag name is one of the ones in the first column of the following table, change the tag name to the name given in the corresponding cell in the second column. (This fixes the case of SVG elements that are not all lowercase.)
</p>

<table><thead>
<tr><th>
~tag名
◎
Tag name
<th>
要素~名
◎
Element name
<tbody>

<tr><td>`altglyph^c
<td>`altGlyph^e

<tr><td>`altglyphdef^c
<td>`altGlyphDef^e

<tr><td>`altglyphitem^c
<td>`altGlyphItem^e

<tr><td>`animatecolor^c
<td>`animateColor^e

<tr><td>`animatemotion^c
<td>`animateMotion^e

<tr><td>`animatetransform^c
<td>`animateTransform^e

<tr><td>`clippath^c
<td>`clipPath^e

<tr><td>`feblend^c
<td>`feBlend^e

<tr><td>`fecolormatrix^c
<td>`feColorMatrix^e

<tr><td>`fecomponenttransfer^c
<td>`feComponentTransfer^e

<tr><td>`fecomposite^c
<td>`feComposite^e

<tr><td>`feconvolvematrix^c
<td>`feConvolveMatrix^e

<tr><td>`fediffuselighting^c
<td>`feDiffuseLighting^e

<tr><td>`fedisplacementmap^c
<td>`feDisplacementMap^e

<tr><td>`fedistantlight^c
<td>`feDistantLight^e

<tr><td>`fedropshadow^c
<td>`feDropShadow^e

<tr><td>`feflood^c
<td>`feFlood^e

<tr><td>`fefunca^c
<td>`feFuncA^e

<tr><td>`fefuncb^c
<td>`feFuncB^e

<tr><td>`fefuncg^c
<td>`feFuncG^e

<tr><td>`fefuncr^c
<td>`feFuncR^e

<tr><td>`fegaussianblur^c
<td>`feGaussianBlur^e

<tr><td>`feimage^c
<td>`feImage^e

<tr><td>`femerge^c
<td>`feMerge^e

<tr><td>`femergenode^c
<td>`feMergeNode^e

<tr><td>`femorphology^c
<td>`feMorphology^e

<tr><td>`feoffset^c
<td>`feOffset^e

<tr><td>`fepointlight^c
<td>`fePointLight^e

<tr><td>`fespecularlighting^c
<td>`feSpecularLighting^e

<tr><td>`fespotlight^c
<td>`feSpotLight^e

<tr><td>`fetile^c
<td>`feTile^e

<tr><td>`feturbulence^c
<td>`feTurbulence^e

<tr><td>`foreignobject^c
<td>`foreignObject^e

<tr><td>`glyphref^c
<td>`glyphRef^e

<tr><td>`lineargradient^c
<td>`linearGradient^e

<tr><td>`radialgradient^c
<td>`radialGradient^e

<tr><td>`textpath^c
<td>`textPath^e
</table>

			</li>
			<li>
~IF［
`現在の調整-済み~node$は`~SVG名前空間$に属する要素である
］
⇒
`~SVG属性たちを調整する$( 現token )
（これは、
すべて小文字ではない~SVG属性の文字大小を修正する。）
◎
If the adjusted current node is an element in the SVG namespace, adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)
</li>
			<li>
`外来な属性たちを調整する$( 現token )
（これは、
名前空間~付きの属性の利用
— 特に~SVGにおける~XLink —
を修正する。）
◎
Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)
</li>
			<li>
`要素を挿入する$( 現token, `現在の調整-済み~node$が属する名前空間 )
◎
Insert a foreign element for the token, with the adjusted current node's namespace and false.
</li>
			<li>
~IF［
現tokenの`自己閉じか$ ~EQ ~F
］
⇒
~RET
◎
If the token has its self-closing flag set, then run the appropriate steps from the following list:
</li>
			<li>
`自己閉じを承認する$( 現token )
◎
↓</li>
			<li>
~IF［
現tokenの~tag名 ~EQ `script^l
］~AND［
`現在の~node$は`~SVG名前空間$に属する
］
⇒
~GOTO 終了~tag { `script^l }
◎
If the token's tag name is "script", and the new current node is in the SVG namespace
• Acknowledge the token's self-closing flag, and then act as described in the steps for a "script" end tag below.
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise
• Pop the current node off the stack of open elements and acknowledge the token's self-closing flag.
</li>
		</ol>
	</dd>

	<dt id="scriptForeignEndTag">
終了~tag { `script^l }
◎
An end tag whose tag name is "script",＼
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は ~SVG `~script0$e 要素でない
］
⇒
~GOTO その他の終了~tag
◎
if the current node is an SVG script element
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
%旧~挿入~地点 ~LET現在の`挿入~地点$
◎
Let the old insertion point have the same value as the current insertion point.＼
</li>
			<li>
`挿入~地点$ ~LET `次回の入力~文字$の直前
◎
Let the insertion point be just before the next input character.
</li>
			<li>
%構文解析器 の`~script入子ng~level$ ~INCBY 1
◎
Increment the parser's script nesting level by one.＼
</li>
			<li>
%構文解析器 の`静止するか$ ~SET ~T
◎
Set the parser pause flag to true.
</li>
			<li>
<p>
~IF［
`作動中な投機的な~HTML構文解析器$ ~EQ ~NULL
］~AND［
~UAは~SVGを~supportする
］
⇒
~SVG規則に則って，`~SVG~script要素を処理する$
`SVG$r
◎
If the active speculative HTML parser is null and the user agent supports SVG, then Process the SVG script element according to the SVG rules. [SVG]
</p>

<p class="note">注記：
これにより，
`~tokenizerの中に新たな文字たちが挿入される＠~HTMLdynamic#dom-document-write$ことになる場合でも、
%構文解析器 の`静止するか$ ~EQ ~T なので，
%構文解析器 は再入的に実行されない。
◎
Even if this causes new characters to be inserted into the tokenizer, the parser will not be executed reentrantly, since the parser pause flag is true.
</p>
			</li>
			<li>
%構文解析器 の`~script入子ng~level$ ~DECBY 1
◎
Decrement the parser's script nesting level by one.＼
</li>
			<li>
~IF［
%構文解析器 の`~script入子ng~level$ ~EQ 0
］
⇒
%構文解析器 の`静止するか$ ~SET ~F
◎
If the parser's script nesting level is zero, then set the parser pause flag to false.
</li>
			<li>
`挿入~地点$ ~SET %旧~挿入~地点
◎
Let the insertion point have the value of the old insertion point. (In other words, restore the insertion point to its previous value. This value might be the "undefined" value.)
</li>
		</ol>
	</dd>

	<dt>
その他の終了~tag
◎
Any other end tag
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
%~node ~LET `現在の~node$
◎
Initialize node to be the current node (the bottommost node of the stack).
</li>
			<li>
~IF［
`~ASCII小文字~化する$( %~node の~tag名 ) ~NEQ 現tokenの~tag名
］
⇒
`~perror$
◎
If node's tag name, converted to ASCII lowercase, is not the same as the tag name of the token, then this is a parse error.
</li>
			<li>
<p>
~WHILE 無条件：
◎
↓</p>
				<ol>
					<li>
~IF［
%~node ~EQ `~open要素~stack$の先頭にある要素
（`素片~事例$）
］
⇒
~RET
◎
Loop: If node is the topmost element in the stack of open elements, then return. (fragment case)
</li>
					<li>
<p>
~IF［
`~ASCII小文字~化する$( %~node の~tag名 ) ~EQ 現tokenの~tag名
］：
</p>
<ol><li>%~node が`出るまで~open要素~stackから~popする$
</li><li>~RET
</li></ol>
◎
If node's tag name, converted to ASCII lowercase, is the same as the tag name of the token, pop elements from the stack of open elements until node has been popped from the stack, and then return.
</li>
					<li>
%~node ~SET `~open要素~stack$内で %~node の直前の~entry
◎
Set node to the previous entry in the stack of open elements.
</li>
					<li>
~IF［
%~node は`~HTML名前空間$に属する要素である
］
⇒
~BREAK
◎
If node is not an element in the HTML namespace, return to the step labeled loop.
</li>
				</ol>
			</li>
			<li>
［
`~HTML内容~内の~token＠#parsing-main-inhtml$用の，
現在の`挿入~mode$に対応する節
］に与える規則に則って、
現tokenを処理する
◎
Otherwise, process the token according to the rules given in the section corresponding to the current insertion mode in HTML content.
</li>
		</ol>
	</dd>
</dl>

				</section>
			</section>
			<section id="the-end">
<h4 title="The end">13.2.7. 終了</h4>

<div class="algo">
<p>
`文書$ %文書 の
`構文解析を停止する@
~algoは：
◎
Once the user agent stops parsing the document, the user agent must run the following steps:
</p>
<ol>
	<li>
~IF［
`作動中な投機的な~HTML構文解析器$ ~NEQ ~NULL
］
⇒＃
`投機的な~HTML構文解析器を停止する$；
~RET
◎
If the active speculative HTML parser is not null, then stop the speculative HTML parser and return.
</li>
	<li>
`挿入~地点$ ~SET ε
◎
Set the insertion point to undefined.
</li>
	<li>
`文書の現在の準備度を更新する$( %文書, `interactive^l )
◎
Update the current document readiness to "interactive".
</li>
	<li>
`~open要素~stack$を空にする
◎
Pop all the nodes off the stack of open elements.
</li>
	<li>
%~script~list ~LET %構文解析器 の`文書の構文解析を完遂したとき実行されることになる~scriptたちが成す~list$を指す参照
◎
↓</li>
	<li>
<p>
~WHILE［
%~script~list は空でない
］：
◎
While the list of scripts that will execute when the document has finished parsing is not empty:
</p>
		<ol>
			<li>
<p>
~AND↓ が満たされるまで`~event~loopを回す$：
</p>
				<ul>
					<li>
%~script~list を成す最初の `script$e の`構文解析器にて実行されるに準備済みか$scE ~EQ ~T
</li>
					<li>
`~scriptを阻んでいる~stylesheetは在るか？$( %文書 ) ~EQ ~F
</li>
				</ul>
◎
Spin the event loop until the first script in the list of scripts that will execute when the document has finished parsing has its ready to be parser-executed set to true and the parser's Document has no style sheet that is blocking scripts.
</li>
			<li>
%~script ~LET %~script~list を成す最初の `script$e
◎
↓</li>
			<li>
`~script要素を実行する$( %~script )
◎
Execute the script element given by the first script in the list of scripts that will execute when the document has finished parsing.
</li>
			<li>
%~script~list から %~script を除去する
◎
Remove the first script element from the list of scripts that will execute when the document has finished parsing (i.e. shift out the first entry in the list).
</li>
		</ol>
	</li>
	<li>
%大域~obj ~LET %文書 に`関連な大域~obj$
◎
↓</li>
	<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %大域~obj, 次の手続き )
◎
Queue a global task on the DOM manipulation task source given the Document's relevant global object＼
</p>

<div class="algo">
<p>
手続きは：
◎
to run the following substeps:
</p>
		<ol>
			<li>
%文書 の`~load計時~報$docの`~DOMContentLoaded~event開始~時刻$ ~SET 
`現在の高分解能~時刻$( %大域~obj )
◎
Set the Document's load timing info's DOM content loaded event start time to the current high resolution time given the Document's relevant global object.
</li>
			<li id="the-end:event-domcontentloaded">
`~eventを発火する$( %文書, `DOMContentLoaded$et )
— 次のように初期化して
⇒
`bubbles$m 属性 ~SET ~T
◎
Fire an event named DOMContentLoaded at the Document object, with its bubbles attribute initialized to true.
</li>
			<li>
%文書 の`~load計時~報$docの`~DOMContentLoaded~event終了~時刻$ ~SET 
`現在の高分解能~時刻$( %大域~obj )
◎
Set the Document's load timing info's DOM content loaded event end time to the current high resolution time given the Document's relevant global object.
</li>
			<li>
次を満たす `ServiceWorkerContainer$I ~obj %C の`~client~message~queue$を可能化する
⇒
%C に結付けられた`~sw~client$ ~EQ %文書 に`関連な設定群~obj$
◎
Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is the Document object's relevant settings object.
</li>
			<li>
`~WebDriver-BiDi~DOM内容が読込まれた$(
%文書 が`属する閲覧~文脈$,
`新たな~WebDriver-BiDi~navi状態s$( %文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc, `処理待ち$wBDst, %文書 の`~URL$doc )
)
◎
Invoke WebDriver BiDi DOM content loaded with the Document's browsing context, and a new WebDriver BiDi navigation status whose id is the Document object's during-loading navigation ID for WebDriver BiDi, status is "pending", and url is the Document object's URL.
</li>
		</ol>
</div>
	</li>
	<li>
<p>
~AND↓ が満たされるまで`~event~loopを回す$：
</p>
		<ul>
			<li>
`アリな限りすぐに実行される~scriptたちが成す集合$は空である
</li>
			<li>
`アリな限りすぐに順に実行される~scriptたちが成す~list$は空である
</li>
		</ul>
◎
Spin the event loop until the set of scripts that will execute as soon as possible and the list of scripts that will execute in order as soon as possible are empty.
</li>
	<li>
次が満たされるまで`~event~loopを回す$
⇒
%文書 内に
`~load~eventを遅延する@
ものは無い
◎
Spin the event loop until there is nothing that delays the load event in the Document.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~DOM操作~task~source$, %大域~obj, 次の手続き )
◎
Queue a global task on the DOM manipulation task source given the Document's relevant global object＼
</p>

<div class="algo">
<p>
手続きは：
◎
to run the following steps:
</p>
		<ol>
			<li>
`文書の現在の準備度を更新する$( %文書, `complete^l )
◎
Update the current document readiness to "complete".
</li>
			<li>
~IF［
%文書 が`属する閲覧~文脈$ ~NEQ ~NULL
］
⇒
~RET
◎
If the Document object's browsing context is null, then abort these steps.
</li>
			<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be the Document's relevant global object.
</li>
			<li>
%文書 の`~load計時~報$docの`~load~event開始~時刻$ ~SET
`現在の高分解能~時刻$( %~window )
◎
Set the Document's load timing info's load event start time to the current high resolution time given window.
</li>
			<li id="the-end:event-load">
`~eventを発火する$( %~window, `load$et )
— `~targetを上書きする^i 下で
◎
Fire an event named load at window, with legacy target override flag set.
</li>
			<li>
`~WebDriver-BiDi読込nを完了した$(
%文書 が`属する閲覧~文脈$,
`新たな~WebDriver-BiDi~navi状態s$( %文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc, `完了した$wBDst, %文書 の`~URL$doc )
)
◎
Invoke WebDriver BiDi load complete with the Document's browsing context, and a new WebDriver BiDi navigation status whose id is the Document object's during-loading navigation ID for WebDriver BiDi, status is "complete", and url is the Document object's URL.
</li>
			<li>
%文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc ~SET ~NULL
◎
Set the Document object's during-loading navigation ID for WebDriver BiDi to null.
</li>
			<li>
%文書 の`~load計時~報$docの`~load~event終了~時刻$ ~SET `現在の高分解能~時刻$( %~window )
◎
Set the Document's load timing info's load event end time to the current high resolution time given window.
</li>
			<li>
~Assert：
%文書 の`~pageを示しているか$doc ~EQ ~F
◎
Assert: Document's page showing is false.
</li>
			<li>
%文書 の`~pageを示しているか$doc ~SET ~T
◎
Set the Document's page showing to true.
</li>
			<li>
`~page遷移~eventを発火する$( %~window, `pageshow$et, ~F )
◎
Fire a page transition event named pageshow at window with false.
</li>
			<li>
%文書 の`読込ngを完全に終わらす$
◎
Completely finish loading the Document.
</li>
			<li>
`~navi計時を~queueする$( %文書 )
◎
Queue the navigation timing entry for the Document.
</li>
		</ol>
</div>
	</li>
	<li>
~IF［
%文書 の`読込んだとき印刷するか$doc ~EQ ~T
］
⇒
`文書を印刷する手続き$( %文書 )
◎
If the Document's print when loaded flag is set, then run the printing steps.
</li>
	<li>
この時点で、
%文書 は
`~load後~task用に準備済み@
になるとする
◎
The Document is now ready for post-load tasks.
</li>
</ol>
</div>

<div class="algo">
<p>
`構文解析器を中止する@
~algoは：
◎
When the user agent is to abort a parser, it must run the following steps:
</p>
<ol>
	<li>
`入力~stream$内の処理待ち内容は、
未来に追加されることになるものも含め，破棄する
◎
Throw away any pending content in the input stream, and discard any future content that would have been added to it.
</li>
	<li>
%構文解析器 用の`投機的な~HTML構文解析器を停止する$
◎
Stop the speculative HTML parser for this HTML parser.
</li>
	<li>
`文書の現在の準備度を更新する$( %文書, `interactive^l )
◎
Update the current document readiness to "interactive".
</li>
	<li>
`~open要素~stack$を空にする
◎
Pop all the nodes off the stack of open elements.
</li>
	<li>
`文書の現在の準備度を更新する$( %文書, `complete^l )
◎
Update the current document readiness to "complete".
</li>
</ol>
</div>

			</section>
			<section id="speculative-html-parsing">
<h4 title="Speculative HTML parsing">13.2.8. 投機的な~HTML構文解析</h4>

<p>
~UAは、
この節に述べるとおりに最適化を実装してもヨイ
— ~HTML構文解析器が［
~HTML~markup内に宣言された資源たち
］を［
`構文解析器を阻んでいる~script$が~fetchされ, 実行されるまで待機している間に／
通常の構文解析の間に`~tokenから要素を作成する$時点で
］投機的（ `speculative^en ）に~fetchするよう。
この最適化の詳細は精確には定義されないが、
相互運用能を得るために考慮する規則があり，以下に与えられる。
◎
User agents may implement an optimization, as described in this section, to speculatively fetch resources that are declared in the HTML markup while the HTML parser is waiting for a pending parsing-blocking script to be fetched and executed, or during normal parsing, at the time an element is created for a token. While this optimization is not defined in precise detail, there are some rules to consider for interoperability.
</p>

<p>
各`~HTML構文解析器$には、
`作動中な投機的な~HTML構文解析器@
があり，初期~時は ~NULL とする。
【 ~NULL でない間は、`投機的な~HTML構文解析器$の下で構文解析することになる。】
◎
Each HTML parser can have an active speculative HTML parser. It is initially null.
</p>

<p>
`投機的な~HTML構文解析器@
は、
次に挙げる例外を除いて，通常の~HTML構文解析器の様に動作するモノトスル
（例：~tree構築器の規則は適用される）：
◎
The speculative HTML parser must act like the normal HTML parser (e.g., the tree builder rules apply), with some exceptions:
</p>
<ul>
	<li>
<p>
［
通常の~HTML構文解析器, `文書$~自身
］の状態は影響されてはナラナイ。
◎
The state of the normal HTML parser and the document itself must not be affected.
</p>

<p class="example">
例えば，通常の~HTML構文解析器~用の［
`次回の入力~文字$／`~open要素~stack$
］は、
`投機的な~HTML構文解析器$により影響されない。
◎
For example, the next input character or the stack of open elements for the normal HTML parser is not affected by the speculative HTML parser.
</p>
	</li>
	<li>
~HTML構文解析器の`入力~byte~stream$の中へ~pushされた~byte列は、
投機的な~HTML構文解析器の`入力~byte~stream$の中へも~pushするモノトスル。
双方の~streamから読取られる~byte列は、
独立になるモノトスル。
◎
Bytes pushed into the HTML parser's input byte stream must also be pushed into the speculative HTML parser's input byte stream. Bytes read from the streams must be independent.
</li>
	<li>
<p>
投機的な構文解析の結果は、
首に一連の`投機的な~fetch$からなる。
どの種類の資源を投機的に~fetchするかは`実装定義$とするが、
~HTML構文解析器を阻んでいる~scriptは何もしない前提の下では，
~UAは［
通常の~HTML構文解析器では~fetchされない資源
］を投機的に~fetchしてはナラナイ。
◎
The result of the speculative parsing is primarily a series of speculative fetches. Which kinds of resources to speculatively fetch is implementation-defined, but user agents must not speculatively fetch resources that would not be fetched with the normal HTML parser, under the assumption that the script that is blocking the HTML parser does nothing.
</p>

<p class="note">注記：
`投機的な~HTML構文解析器$, 通常の~HTML構文解析器は、
この順に，同じ~markupに出くわすアリ性もある。
重複した~fetchは、
~cache用の規則により防止されることが期待される
— まだ全部的に指定されていないが。
◎
It is possible that the same markup is seen multiple times from the speculative HTML parser and then the normal HTML parser. It is expected that duplicated fetches will be prevented by caching rules, which are not yet fully specified.
</p>
	</li>
</ul>

<p>
`投機的な模擬~要素$ %要素 用の
`投機的な~fetch@
は、
次の規則に従うモノトスル：
◎
A speculative fetch for a speculative mock element element must follow these rules:
</p>

<p class="XXX">
これらのうち一部のものは、
投機的に見出されるものであっても，
“本番~用” の`文書$にも適用されるべきか？
◎
Should some of these things be applied to the document "for real", even though they are found speculatively?
</p>
<ul>
	<li>
<p>
`投機的な~HTML構文解析器$は、
次に挙げるいずれかの要素に遭遇した場合には，［
それによる後続な投機的な~fetchの効果の目的においては、
要素は【次項に従って】処理される
］かのように動作する：
◎
If the speculative HTML parser encounters one of the following elements, then act as if that element is processed for the purpose of its effect of subsequent speculative fetches.
</p>
		<ul>
			<li>
`base$e 要素。
◎
A base element.
</li>
			<li>
`meta$e 要素のうち，その `http-equiv$a 属性は `~CSP状態$にあるもの。
◎
A meta element whose http-equiv attribute is in the Content security policy state.
</li>
			<li>
`meta$e 要素のうち，その `name$a 属性は`~ASCII大小無視$で `referrer$l に合致するもの
◎
A meta element whose name attribute is an ASCII case-insensitive match for "referrer".
</li>
			<li>
`meta$e 要素のうち，その `name$a 属性は
`~ASCII大小無視$で `viewport^l に合致するもの
（これは、
媒体~query~listは`環境に合致する$かどうかに影響し得る。）
`CSSDEVICEADAPT$r
◎
A meta element whose name attribute is an ASCII case-insensitive match for "viewport". (This can affect whether a media query list matches the environment.) [CSSDEVICEADAPT]
</li>
		</ul>
	</li>
	<li>
%~URL は %要素 が通常に処理された場合に，~fetchされることになる`~URL$は［
在るならばそれ／
無いならば ε
］とするとき、［
%~URL ~NIN { ε, 空~文字列 }
］~AND［
%~URL ~NIN `投機的な~fetch~URLたちが成す~list$doc
］ならば
⇒＃
要素は通常に処理されたかのように %~URL を~fetchする；
`投機的な~fetch~URLたちが成す~list$docに %~URL を追加する
◎
Let url be the URL that element would fetch if it was processed normally. If there is no such URL or if it is the empty string, then do nothing. Otherwise, if url is already in the list of speculative fetch URLs, then do nothing. Otherwise, fetch url as if the element was processed normally, and add url to the list of speculative fetch URLs.
</li>
</ul>

<p>
各`文書$は
`投機的な~fetch~URLたちが成す~list@doc
を有する
— それは`~URL$群が成す`~list$であり，初期~時は空とする。
◎
Each Document has a list of speculative fetch URLs, which is a list of URLs, initially empty.
</p>

<div class="algo">
<p>
%構文解析器 用の
`投機的な~HTML構文解析器を開始する@
~algoは：
◎
To start the speculative HTML parser for an instance of an HTML parser parser:
</p>
<ol>
	<li>
<p>
任意選択で
⇒
~RET
◎
Optionally, return.
</p>

<p class="note">注記：
この段は、
投機的な~HTML構文解析を~opt-outすることを~UAに許容する。
◎
This step allows user agents to opt out of speculative HTML parsing.
</p>
	</li>
	<li>
<p>
~IF［
%構文解析器 にて`作動中な投機的な~HTML構文解析器$ ~NEQ ~NULL
］
⇒
%構文解析器 用の`投機的な~HTML構文解析器を停止する$
◎
If parser's active speculative HTML parser is not null, then stop the speculative HTML parser for parser.
</p>

<p class="note">注記：
これは、
`document.write()$c が別の［
構文解析器を阻んでいる~script
］を書込んだ場合に起こり得る。
単純にするため，この仕様は［
常に，投機的な構文解析を開始し直す
］が、
~UAは，最終結果が等価になる限り より効率的な策を実装できる。
◎
This can happen when document.write() writes another parser-blocking script. For simplicity, this specification always restarts speculative parsing, but user agents can implement a more efficient strategy, so long as the end result is equivalent.
</p>
	</li>
	<li>
%投機的な構文解析器 ~LET %構文解析器 と同じ状態を伴う新たな`投機的な~HTML構文解析器$
◎
Let speculativeParser be a new speculative HTML parser, with the same state as parser.
</li>
	<li>
%投機的な文書 ~LET 新たな， %構文解析器 の`文書$と同型な表現
⇒＃
%投機的な文書 内の要素は、
すべて`投機的な模擬~要素$になるとする。
%投機的な構文解析器 が構文解析した結果の行き先は %投機的な文書 になるとする。
◎
Let speculativeDoc be a new isomorphic representation of parser's Document, where all elements are instead speculative mock elements. Let speculativeParser parse into speculativeDoc.
</li>
	<li>
%構文解析器 にて`作動中な投機的な~HTML構文解析器$ ~SET %投機的な構文解析器
◎
Set parser's active speculative HTML parser to speculativeParser.
</li>
	<li class="algo">
この段は`並列的$に走らす
⇒
%投機的な構文解析器 を次に挙げるいずれかが生じるまで走らす
⇒＃
停止された／
`入力~stream$の終端に達した
◎
In parallel, run speculativeParser until it is stopped or until it reaches the end of its input stream.
</li>
</ol>
</div>

<div class="algo">
<p>
%構文解析器 用の
`投機的な~HTML構文解析器を停止する@
~algoは：
◎
To stop the speculative HTML parser for an instance of an HTML parser parser:
</p>
<ol>
	<li>
%投機的な構文解析器 ~LET %構文解析器 にて`作動中な投機的な~HTML構文解析器$
◎
Let speculativeParser be parser's active speculative HTML parser.
</li>
	<li>
~IF［
%投機的な構文解析器 ~EQ ~NULL
］
⇒
~RET
◎
If speculativeParser is null, then return.
</li>
	<li>
%投機的な構文解析器 の`入力~stream$内［
の処理待ち内容は棄てる／
に未来に追加されることになる内容は破棄する
］
◎
Throw away any pending content in speculativeParser's input stream, and discard any future content that would have been added to it.
</li>
	<li>
%構文解析器 にて`作動中な投機的な~HTML構文解析器$ ~SET ~NULL
◎
Set parser's active speculative HTML parser to null.
</li>
</ol>
</div>

<p>
`投機的な~HTML構文解析器$は、
通常の要素の代わりに`投機的な模擬~要素$を作成することになる。
~tree構築器が各~要素に対し通常に行う~DOM演算は、
投機的な模擬~要素に対しても適切に働くことが期待される。
◎
The speculative HTML parser will create speculative mock elements instead of normal elements. DOM operations that the tree builder normally does on elements are expected to work appropriately on speculative mock elements.
</p>

<p>
`投機的な模擬~要素@
（ `speculative mock element^en ）は、
次に挙げる`~item$sctを伴う`構造体$である：
◎
A speculative mock element is a struct with the following items:
</p>
<ul>
	<li>
`名前空間@mock
⇒
`文字列$
— 要素の`名前空間$elに対応する。
◎
A string namespace, corresponding to an element's namespace.
</li>
	<li>
`局所-名@mock
⇒
`文字列$
— 要素の`局所~名$elに対応する。
◎
A string local name, corresponding to an element's local name.
</li>
	<li>
`属性~list@mock
⇒
`~list$
— 要素の`属性~list$elに対応する。
◎
A list attribute list, corresponding to an element's attribute list.
</li>
	<li>
`子~群@mock
⇒
`~list$
— 要素の`子~群$に対応する。
◎
A list children, corresponding to an element's children.
</li>
</ul>

<div class="algo">
<p>
`投機的な模擬~要素を作成する@
~algoは、
所与の
( %名前空間, %~tag名, %属性~群 )
に対し：
◎
To create a speculative mock element given a namespace, tagName, and attributes:
</p>
<ol>
	<li>
%要素 ~LET 新たな`投機的な模擬~要素$
◎
Let element be a new speculative mock element.
</li>
	<li>
%要素 の
⇒＃
`名前空間$mock ~SET %名前空間,
`局所-名$mock ~SET %~tag名,
`属性~list$mock ~SET %属性~群,
`子~群$mock ~SET 新たな空`~list$
◎
Set element's namespace to namespace.
◎
Set element's local name to tagName.
◎
Set element's attribute list to attributes.
◎
Set element's children to a new empty list.
</li>
	<li>
任意選択で
⇒
%要素 用の`投機的な~fetch$を遂行する
◎
Optionally, perform a speculative fetch for element.
</li>
	<li>
~RET %要素
◎
Return element.
</li>
</ol>
</div>

<p>
~tree構築器が `template$e 要素の`~template内容$ %内容 の中へ要素 %要素 を挿入する所では、［
%要素 は`投機的な模擬~要素$である
］~AND［
%内容 は `ShadowRoot$I ~nodeでない
］が満たされる場合，代わりに何もしない。
`template$e 要素が宣言的でない~shadow根である場合、
その内側にて投機的に見出された各~URL
（それ自体も~templateかもしれない）
を投機的に~fetchしてはナラナイ。
◎
When the tree builder says to insert an element into a template element's template contents, if that is a speculative mock element, and the template element's template contents is not a ShadowRoot node, instead do nothing. URLs found speculatively inside non-declarative-shadow-root template elements might themselves be templates, and must not be speculatively fetched.
</p>

			</section>
			<section id="coercing-an-html-dom-into-an-infoset">
<h4 title="Coercing an HTML DOM into an infoset">13.2.9. ~HTML~DOMから~XML~infosetへの~~落とし込み</h4>

<p>
~appが`~HTML構文解析器$を~XML~pipelineと併用するときに構築される~DOMは、
ある種の微妙な仕方で~XML~toolchainと互換でない可能性もある。
例えば，~XML~toolchainは、
名前 `xmlns^c の属性を表現-可能でないかもしれない
— それは、
`XMLNS$r の構文と競合するので。
`~HTML構文解析器$が生成する~dataには、
~DOM自身には含まれないものもある。
この節は、
これらの課題を取扱うための規則をいくつか指定する。
◎
When an application uses an HTML parser in conjunction with an XML pipeline, it is possible that the constructed DOM is not compatible with the XML tool chain in certain subtle ways. For example, an XML toolchain might not be able to represent attributes with the name xmlns, since they conflict with the Namespaces in XML syntax. There is also some data that the HTML parser generates that isn't included in the DOM itself. This section specifies some rules for handling these issues.
</p>

<p>
利用-中な~XML~API
— 以下，単に “~XML~API” —
が~DOCTYPEを~supportしない場合、
~toolは，~DOCTYPEをまるごと落としてもヨイ。
◎
If the XML API being used doesn't support DOCTYPEs, the tool may drop DOCTYPEs altogether.
</p>

<p>
~XML~APIが［
名前空間に属さない名前 `xmlns^l の属性 ／
`xmlns:^l で開始する名前の属性 ／
`~XMLNS名前空間$に属する属性 
］を~supportしない場合、
~toolは，そのような属性を落としてもヨイ。
◎
If the XML API doesn't support attributes in no namespace that are named "xmlns", attributes whose names start with "xmlns:", or attributes in the XMLNS namespace, then the tool may drop such attributes.
</p>

<p>
~toolは、
適正に演算するために要求される名前空間~宣言が在るならば，
出力を それで注釈してもヨイ。
◎
The tool may annotate the output with any namespace declarations required for proper operation.
</p>

<div class="p">
<p>
~XML~APIが［
要素／属性
］の局所~名に許容-可能な文字を制約する場合、
~toolは，［［
要素／属性
］の局所~名を成す文字のうち，当の~APIが~supportしないもの
］を次の文字~並びに置換することにより，
許容される名前たちが成す集合に対応付けてもヨイ：
</p>

<ol><li>`0055^U
</li><li>文字の~cpを~hexadecimalで表出する 6 個の`~ASCII~hex数字（大文字）$
【！？in increasing numeric order】
</li></ol>

◎
If the XML API being used restricts the allowable characters in the local names of elements and attributes, then the tool may map all element and attribute local names that the API wouldn't support to a set of names that are allowed, by replacing any character that isn't supported with the uppercase letter U and the six digits of the character's code point when expressed in hexadecimal, using digits 0-9 and capital letters A-F as the symbols, in increasing numeric order.
</div>

<p class="example">
例えば、
`~HTML構文解析器$は［
合法な~HTML要素~名でも整形式な~XML要素~名でもない要素~名 `foo&lt;bar^c
］を出力し得るが，それは、
`fooU00003Cbar^c に変換され，`整形式な^em ~XML要素~名になる
（それでも、
~HTMLにおいては合法にならない）。
◎
For example, the element name foo&lt;bar, which can be output by the HTML parser, though it is neither a legal HTML element name nor a well-formed XML element name, would be converted into fooU00003Cbar, which is a well-formed XML element name (though it's still not legal in HTML by any means).
</p>

<p class="example">
別の例として、
属性 `xlink:href^c を考える。
~MathML要素~上で利用された場合、
それは，`調整-後＠#adjust-foreign-attributes$には
( 接頭辞 `xlink^l, 局所~名 `href^l )
を伴う属性になる。
しかしながら，~HTML要素~上で利用された場合、
( 接頭辞なし, 局所~名 `xlink:href^l )
を伴う属性になり，妥当な `NCName^P でないため、
~XML~APIには受容されないかもしれない。
したがって、
`xlinkU00003Ahref^l になるよう変換することもできる。
◎
As another example, consider the attribute xlink:href. Used on a MathML element, it becomes, after being adjusted, an attribute with a prefix "xlink" and a local name "href". However, used on an HTML element, it becomes an attribute with no prefix and the local name "xlink:href", which is not a valid NCName, and thus might not be accepted by an XML API. It could thus get converted, becoming "xlinkU00003Ahref".
</p>

<p class="note">注記：
この変換による結果の名前は、
都合よく，`~HTML構文解析器$が生成するどの属性とも衝突し得ない
— それらは、
どれも，小文字のみからなるか［
`外来な属性たちを調整する$~algoの表に挙げたもの
］に限られるので。
◎
The resulting names from this conversion conveniently can't clash with any attribute generated by the HTML parser, since those are all either lowercase or those listed in the adjust foreign attributes algorithm's table.
</p>

<p>
~XML~APIが［
~comment内の連続する 2 個の `002D^U
］を制約する場合、
~toolは，そのような~~問題になる文字~並びの合間に 1 個の `0020^U を挿入してもヨイ。
◎
If the XML API restricts comments from having two consecutive U+002D HYPHEN-MINUS characters (--), the tool may insert a single U+0020 SPACE character between any such offending characters.
</p>

<p>
~XML~APIが［
~comment内を `002D^U で終端する
］のを制約する場合、
~toolは，そのような~commentの終端に 1 個の `0020^U を挿入してもヨイ。
◎
If the XML API restricts comments from ending in a U+002D HYPHEN-MINUS character (-), the tool may insert a single U+0020 SPACE character at the end of such comments.
</p>

<p>
~XML~APIが［
文字~data／ 属性~値 ／~comment
］内に許容される文字を制約する場合、
~toolは，
`000C^U は `0020^U に,
その他の~literal【すなわち，文字~参照に~escapeされていない】非~XML文字は `FFFD^U に置換してもヨイ。
◎
If the XML API restricts allowed characters in character data, attribute values, or comments, the tool may replace any U+000C FORM FEED (FF) character with a U+0020 SPACE character, and any other literal non-XML character with a U+FFFD REPLACEMENT CHARACTER.
</p>

<p>
帯域外の情報を伝達する仕方がない~toolは、
次の情報を落としてもヨイ：
◎
If the tool has no way to convey out-of-band information, then the tool may drop the following information:
</p>

<ul>
<li>
文書の`~mode$docは［
`no-quirks^l, `limited-quirks^l, `quirks^l
］のどれに設定されているか
◎
Whether the document is set to no-quirks mode, limited-quirks mode, or quirks mode
</li>
	<li>
~form~controlと，［
それに最も近い先祖 `form$e 要素ではない `form$e 要素
］との結付け
（構文解析器における`~form要素~pointer$の利用）
◎
The association between form controls and forms that aren't their nearest form element ancestor (use of the form element pointer in the parser)
</li>
	<li>
`template$e 要素の`~template内容$
◎
The template contents of any template elements.
</li>
</ul>

<p class="note">注記：
この節により許容される変異が適用されるのは、
`~HTML構文解析器$の規則が`適用された後^emになる。
例えば、
開始~tag `&lt;a::&gt;^l は，
終了~tag `&lt;/a::&gt;^l で閉じられることになり、
終了~tag `&lt;/aU00003AU00003A&gt;^l で閉じられることは，決してない
— ~UAが，上を規則を利用していて、
開始~tagに対する名前 `aU00003AU00003A^l の要素を実際に~DOM内に生成する場合でも。
◎
The mutations allowed by this section apply after the HTML parser's rules have been applied. For example, a &lt;a::&gt; start tag will be closed by a &lt;/a::&gt; end tag, and never by a &lt;/aU00003AU00003A&gt; end tag, even if the user agent is using the rules above to then generate an actual element in the DOM with the name aU00003AU00003A for that start tag.
</p>

			</section>
			<section id="an-introduction-to-error-handling-and-strange-cases-in-the-parser">
<h4 title="An introduction to error handling and strange cases in the parser">13.2.10. 構文解析器における~errorの取扱いと変則的な事例の序論</h4>

◎非規範的

<p>
この節では、
~error含みな~markupをいくつか精査し，
`~HTML構文解析器$がこれらの事例をどう取扱うかを論じる。
◎
This section examines some erroneous markup and discusses how the HTML parser handles these cases.
</p>

				<section id="misnested-tags:-b-i-/b-/i">
<h5 title="Misnested tags: &lt;b&gt;&lt;i&gt;&lt;/b&gt;&lt;/i&gt;">13.2.10.1. 誤入子な~tag：`&lt;b&gt;&lt;i&gt;&lt;/b&gt;&lt;/i&gt;^c</h5>

◎非規範的

<p>
次のような~markupは、
~error含みな例として，最もよく論じられる：
◎
The most-often discussed example of erroneous markup is as follows:
</p>

`misnested-tags-1^xCode

<p>
この~markupの構文解析は、
`3^l までは素直に進む。
この時点での~DOMは、
次の様な見かけになる：
◎
The parsing of this markup is straightforward up to the "3". At this point, the DOM looks like this:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`p$e
			<ul><li>`#text$: <span>1</span>
			</li><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li><li>`i$e
					<ul><li>`#text$: <span>3</span>
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この時点で、
`~open要素~stack$は 順に 5 個の要素
— `html$e, `body$e, `p$e, `b$e, `i$e —
からなり，`作動中な整形~要素~list$は  2 個の要素
— `b$e, `i$e —
からなり，`挿入~mode$は`~body内$mdになる。
◎
Here, the stack of open elements has five elements on it: html, body, p, b, and i. The list of active formatting elements just has two: b and i. The insertion mode is "in body".
</p>

<p>
~tag名に `b^l を伴う終了~tag~tokenを受取ったときには、
`養子縁組~algo$が呼出される。
これは単純な事例であり、
%整形~要素 は `b$e 要素，
%最遠な~block は無い。
したがって`~open要素~stack$は 3 個の要素
— `html$e, `body$e, `p$e —
からなる一方で，`作動中な整形~要素~list$は `i$e 要素 1 個だけからなる。
この時点では、
~DOM~treeはまだ改変されない。
◎
Upon receiving the end tag token with the tag name "b", the "adoption agency algorithm" is invoked. This is a simple case, in that the formattingElement is the b element, and there is no furthest block. Thus, the stack of open elements ends up with just three elements: html, body, and p, while the list of active formatting elements has just one: i. The DOM tree is unmodified at this point.
</p>

<p>
次回の~tokenは文字 `4^l であり、
`作動中な整形~要素たちを構築し直す$ことを誘発する
— この事例では、
`i$e 要素だけを。
したがって， `Text$I ~node `4^l 用に新たな `i$e 要素が作成される。
`i^l に対する終了~tag~tokenも受取った後には，
`Text$I ~node `5^l も挿入され、
~DOMは次の様になる：
◎
The next token is a character ("4"), triggers the reconstruction of the active formatting elements, in this case just the i element. A new i element is thus created for the "4" Text node. After the end tag token for the "i" is also received, and the "5" Text node is inserted, the DOM looks as follows:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`p$e
			<ul><li>`#text$: <span>1</span>
			</li><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li><li>`i$e
					<ul><li>`#text$: <span>3</span>
					</li></ul>
				</li></ul>
				</li><li>`i$e
					<ul><li>`#text$: <span>4</span>
					</li></ul>
				</li><li>`#text$: <span>5</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

				</section>
				<section id="misnested-tags:-b-p-/b-/p">
<h5 title="Misnested tags: &lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;">13.2.10.2. 誤入子な~tag： `&lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;^c</h5>

◎非規範的

<p>
前~節に類似な事例：
◎
A case similar to the previous one is the following:
</p>

`misnested-tags-2^xCode

<p>
ここでの構文解析は、
`2^l の所までは素直に進む：
◎
Up to the "2" the parsing here is straightforward:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
		</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li><li>`p$e
				<ul><li>`#text$: <span>2</span>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
関心があるのは、
~tag名に `b^l を伴う終了~tag~tokenが構文解析されるときである。
◎
The interesting part is when the end tag token with the tag name "b" is parsed.
</p>

<p>
その~tokenに出くわす前までは、
`~open要素~stack$は 4 個の要素
— `html$e, `body$e, `b$e, `p$e —
からなり，
`作動中な整形~要素~list$は `b$e のみからなり，
`挿入~mode$は`~body内$mdになる。
◎
Before that token is seen, the stack of open elements has four elements on it: html, body, b, and p. The list of active formatting elements just has the one: b. The insertion mode is "in body".
</p>

<p>
~tag名に `b^l を伴う終了~tag~tokenを受取るときには、
前の例と同じく`養子縁組~algo$が呼出される。
しかしながら，
今度の事例では %最遠な~block として `p$e 要素が在るので、
養子縁組~algoは飛ばされない。
◎
Upon receiving the end tag token with the tag name "b", the "adoption agency algorithm" is invoked, as in the previous example. However, in this case, there is a furthest block, namely the p element. Thus, this time the adoption agency algorithm isn't skipped over.
</p>

<p>
%共通な先祖 は `body$e 要素。
概念的な “~bookmark” は，`作動中な整形~要素~list$における `b$e の位置を~markするが、
その~listを成す要素は 1 個だけなので，~bookmarkによる効果はたいしてない。
◎
The common ancestor is the body element. A conceptual "bookmark" marks the position of the b in the list of active formatting elements, but since that list has only one element in it, the bookmark won't have much effect.
</p>

<p>
~algoが進捗するに伴い、
%~node は整形~要素 （ `b$e ）に設定され，
%最後の~node は %最遠な~block（ `p$e ）に設定される。
◎
As the algorithm progresses, node ends up set to the formatting element (b), and last node ends up set to the furthest block (p).
</p>

<p>
%最後の~node は、
~DOMが次の様な見かけになるよう，
%共通な先祖 に付加されることになる
（移動される）：
◎
The last node gets appended (moved) to the common ancestor, so that the DOM looks like:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li></ul>
		</li><li>`p$e
			<ul><li>`#text$: <span>2</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
新たな `b$e 要素が作成され， `p$e 要素の子たちはそこに移動される：
◎
A new b element is created, and the children of the p element are moved to it:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
		</li><li>`body$e
			<ul><li>`b$e
				<ul><li>`#text$: <span>1</span>
				</li></ul>
			</li><li>`p$e
		</li></ul>
	</li></ul>
</li></ul>

<ul class="domTree"><li>`b$e
	<ul><li>`#text$: <span>2</span>
	</li></ul>
</li></ul>

<p>
最終的に，新たな `b$e 要素は、
~DOMが次の様な見かけになるよう，
`p$e 要素に付加される：
◎
Finally, the new b element is appended to the p element, so that the DOM looks like:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
`b$e 要素は、
`3^l が構文解析されるときに `p$e 要素に付加されるよう，［
`作動中な整形~要素~list$, `~open要素~stack$
］から除去される：
◎
The b element is removed from the list of active formatting elements and the stack of open elements, so that when the "3" is parsed, it is appended to the p element:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li></ul>
			</li><li>`#text$: <span>3</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

				</section>
				<section id="unexpected-markup-in-tables">
<h5 title="Unexpected markup in tables">13.2.10.3. ~table内の予期されない~markup</h5>

◎非規範的

<p>
~tableにおける~errorの取扱いは、
歴史的な理由から，とりわけ変則的である。
例えば、
次の~markupを考える：
◎
Error handling in tables is, for historical reasons, especially strange. For example, consider the following markup:
</p>

`unexpected-markup-in-tables^xCode

<p>
上の様な強調されている `b$e 要素の開始~tagは，
~tableの内側には直には許容されないので、
構文解析器はこの事例に対しては，
要素を~tableの`前に置く^emように取扱う
（これは、`親を違える$と呼ばれる）。
これは、
~DOM~treeを精査すれば見つかる
— それは、
`table$e 要素の開始~tagに出くわした直後に~~現れるので：
◎
The highlighted b element start tag is not allowed directly inside a table like that, and the parser handles this case by placing the element before the table. (This is called foster parenting.) This can be seen by examining the DOM tree as it stands just after the table element's start tag has been seen:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`table$e
		</li></ul>
	</li></ul>
</li></ul>

<p>
`b$e 要素の開始~tagに出くわした直後には、
次の様になる：
◎
...and then immediately after the b element start tag has been seen:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`table$e
		</li></ul>
	</li></ul>
</li></ul>

<p>
この時点では、
`~open要素~stack$は［
`html$e, `body$e, `table$e, `b$e
］要素からなり
（結果の~DOM~treeに関わらず，この順序になる），
`作動中な整形~要素~list$は `b$e 要素のみからなり，
`挿入~mode$は`~table内$mdになる。
◎
At this point, the stack of open elements has on it the elements html, body, table, and b (in that order, despite the resulting DOM tree); the list of active formatting elements just has the b element in it; and the insertion mode is "in table".
</p>

<p>
`tr$e 開始~tagは、
`b$e 要素を~stackから~popさせ，
`tbody$e 開始~tagが黙示されることになる
— 次の `tbody$e と `tr$e 要素は素直に取扱われ，
構文解析器が挿入~mode［
`~table~body内$md, `~row内$md
］を経るよう導く。
結果の~DOMは、
次の様になる：
◎
The tr start tag causes the b element to be popped off the stack and a tbody start tag to be implied; the tbody and tr elements are then handled in a rather straight-forward manner, taking the parser through the "in table body" and "in row" insertion modes, after which the DOM looks as follows:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
ここでの`~open要素~stack$は［
`html$e, `body$e, `table$e, `tbody$e, `tr$e
］要素からなり，`作動中な整形~要素~list$は依然として `b$e 要素のみからなり，`挿入~mode$は`~row内$mdになる。
◎
Here, the stack of open elements has on it the elements html, body, table, tbody, and tr; the list of active formatting elements still has the b element in it; and the insertion mode is "in row".
</p>

<p>
`td$e 要素を~treeに置いた後、
その開始~tag~tokenは，
`作動中な整形~要素~list$に`~marker$を置く
（それはまた，`~cell内$mdに切替える）。
◎
The td element start tag token, after putting a td element on the tree, puts a marker on the list of active formatting elements (it also switches to the "in cell" insertion mode).
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この`~marker$は、［
文字~token列 `aaa^l に出くわしたとき、［
それによる結果の `Text$I ~nodeを保持するために `b$e 要素を作成する
］ことはない
］ことを意味する：
◎
The marker means that when the "aaa" character tokens are seen, no b element is created to hold the resulting Text node:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
	<ul><li>`b$e
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
						<ul><li>`#text$: <span>aaa</span>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
終了~tagたちは，素直に取扱われ、
それらを取扱った後には，
`~open要素~stack$は［
`html$e, `body$e, `table$e, `tbody$e
］要素からなり，
`作動中な整形~要素~list$は 依然として `b$e 要素のみからなり
（`~marker$は `td^l 終了~tag~tokenによりすでに除去されている），
`挿入~mode$は`~table~body内$mdになる。
◎
The end tags are handled in a straight-forward manner; after handling them, the stack of open elements has on it the elements html, body, table, and tbody; the list of active formatting elements still has the b element in it (the marker having been removed by the "td" end tag token); and the insertion mode is "in table body".
</p>

<p>
したがって見出されるのは、
文字~token列 `bbb^l になる。
これらは、
`~table~text内$mdの利用を誘発する
（ `元の挿入~mode$V を`~table~body内$mdに設定して）。
この文字~token列は収集され、
次回の~token（ `table$e 要素の終了~tag）に出くわしたときには，
~groupとして処理される。
それらには~space以外も混じっているので、
`~table内$mdにおける “~AnyElse” 規則に従って取扱われる
— それは、
`親を違える$下で，`~body内$mdに先送りする。
◎
Thus it is that the "bbb" character tokens are found. These trigger the "in table text" insertion mode to be used (with the original insertion mode set to "in table body"). The character tokens are collected, and when the next token (the table element end tag) is seen, they are processed as a group. Since they are not all spaces, they are handled as per the "anything else" rules in the "in table" insertion mode, which defer to the "in body" insertion mode but with foster parenting.
</p>

<p>
`作動中な整形~要素たちを構築し直す$ときには、
`親を違える$ように `b$e 要素が作成され，
`Text$I ~node `bbb^l はそれに付加される：
◎
When the active formatting elements are reconstructed, a b element is created and foster parented, and then the "bbb" Text node is appended to it:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`b$e
			<ul><li>`#text$: <span>bbb</span>
			</li></ul>
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
						<ul><li>`#text$: <span>aaa</span>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
`~open要素~stack$は［
`html$e, `body$e, `table$e, `tbody$e, 新たな `b$e
］要素からなり
（ここでも，順序は結果の~treeには合致しないことに注意！），
`作動中な整形~要素~list$は 新たな `b$e 要素からなり，`挿入~mode$は依然として `~table~body内$mdになる。
◎
The stack of open elements has on it the elements html, body, table, tbody, and the new b (again, note that this doesn't match the resulting tree!); the list of active formatting elements has the new b element in it; and the insertion mode is still "in table body".
</p>

<p>
文字~token列が `bbb^l に代えて`~ASCII空白$のみからなっていた場合、
単に `tbody$e 要素に付加されることになる。
◎
Had the character tokens been only ASCII whitespace instead of "bbb", then that ASCII whitespace would just be appended to the tbody element.
</p>

<p>
最終的に `table$e は、
終了~tag `table^l により閉じられる。
これは，［
`~open要素~stack$から `table$e 要素までの~nodeすべてを~popさせるが、
`作動中な整形~要素~list$には影響しない
］ので、
`table^e の後に在る文字~token列 `ccc^l は，
今度は `table^e の後に もう一つ作成される `b$e 要素~内に置かれる：
◎
Finally, the table is closed by a "table" end tag. This pops all the nodes from the stack of open elements up to and including the table element, but it doesn't affect the list of active formatting elements, so the "ccc" character tokens after the table result in yet another b element being created, this time after the table:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`b$e
			<ul><li>`#text$: <span>bbb</span>
			</li></ul>
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
						<ul><li>`#text$: <span>aaa</span>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`b$e
			<ul><li>`#text$: <span>ccc</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

				</section>
				<section id="scripts-that-modify-the-page-as-it-is-being-parsed">
<h5 title="Scripts that modify the page as it is being parsed">13.2.10.4. 構文解析されている~pageを改変する~script</h5>

◎非規範的

<p>
次の~markupを考える。
この例においては、
“内縁” 文書
（ `~URL$ `https://example.com/inner^l ）は，
別の “外縁” 文書
（ `~URL$ `https://example.com/outer^l ）内で
`iframe$e の内容として具現化されているとする：
◎
Consider the following markup, which for this example we will assume is the document with URL https://example.com/inner, being rendered as the content of an iframe in another document with the URL https://example.com/outer:
</p>

`scripts-that-modify-the-page^xCode

<p>
1 個目の `script^l 終了~tagまでの，~scriptが構文解析される前の結果は、
比較的~素直に進む：
◎
Up to the first "script" end tag, before the script is parsed, the result is relatively straightforward:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`div$e <span class="t2">`id$a="`a^c"</span>
			<ul><li>`#text$: <span></span>
			</li><li>`script$e
				<ul><li>`#text$: <span>var %div = document.getElementById('a'); ⏎ parent.document.body.appendChild(%div);</span>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
が、
~scriptが構文解析された後では，
`div$e 要素とその子 `script$e 要素は去る：
◎
After the script is parsed, though, the div element and its child script element are gone:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
	</li></ul>
</li></ul>

<p>
去ったそれらは、
この時点で，前述した “外縁” 文書
— 外縁な`閲覧~文脈$の`文書$ —
内に在る。
しかしながら、
`~open要素~stack$は，`依然として^em `div$e 要素を包含する。
◎
They are, at this point, in the Document of the aforementioned outer browsing context. However, the stack of open elements still contains the div element.
</p>

<p>
したがって， 2 個目の `script$e 要素が構文解析されるとき、
それは， `“外縁” 文書の中^emに挿入される。
◎
Thus, when the second script element is parsed, it is inserted into the outer Document object.
</p>

<p>
構文解析器が作成したものとは異なる`文書$用に構文解析されるものは，実行されないので、
1 個目の~alertは示されない。
◎
Those parsed into different Documents than the one the parser was created for do not execute, so the first alert does not show.
</p>

<p>
`div$e 要素の終了~tagが構文解析されたなら、
`div$e 要素は~stackから~popされるので，
3 個目の `script$e 要素は内縁 `文書$内に在る：
◎
Once the div element's end tag is parsed, the div element is popped off the stack, and so the next script element is in the inner Document:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`script$e
			<ul><li>`#text$: <span>alert(document.URL);</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この~scriptが実行される結果、
`https://example.com/inner^l
を示す~alertが生じる。
◎
This script does execute, resulting in an alert that says "https://example.com/inner".
</p>

				</section>
				<section id="the-execution-of-scripts-that-are-moving-across-multiple-documents">
<h5 title="The execution of scripts that are moving across multiple documents">13.2.10.5. 複数の文書にまたがって移動する~scriptの実行</h5>

◎非規範的

<p>
前~節の例から更に詳しく、
2 個目の `script$e 要素は外部~scriptである事例
（すなわち， `src$a 属性を有する事例）
を考える。
要素は作成-時点では構文解析器の`文書$内にはなかったので、
この外部~scriptは~downloadすらされない。
◎
Elaborating on the example in the previous section, consider the case where the second script element is an external script (i.e. one with a src attribute). Since the element was not in the parser's Document when it was created, that external script is not even downloaded.
</p>

<p>
`src$a 属性を有する `script$e 要素が［
通常に構文解析器の`文書$の中へ構文解析されつつ，
その外部~scriptの~download中に 要素が別の文書へ移動された
］場合、
~downloadは継続されるが，~scriptは実行されない。
◎
In a case where a script element with a src attribute is parsed normally into its parser's Document, but while the external script is being downloaded, the element is moved to another document, the script continues to download, but does not execute.
</p>

<p class="note">注記：
一般に、
`script$e 要素を`文書$間で移動することは，
不良な実施と見なされる。
◎
In general, moving script elements between Documents is considered a bad practice.
</p>

				</section>
				<section id="unclosed-formatting-elements">
<h5 title="Unclosed formatting elements">13.2.10.6. 閉じられてない整形~要素</h5>

◎非規範的

<p>
次の~markupに、
入子な整形~要素（ `b$e など）が
— それを包含する要素が閉じられても —
収集され，適用され続けることになる様子を示す。
ただし、
過度の重複は棄てられる。
◎
The following markup shows how nested formatting elements (such as b) get collected and continue to be applied even as the elements they are contained in are closed, but that excessive duplicates are thrown away.
</p>

`unclosed-formatting-elements^xCode

<p>
結果の~DOM~treeは、
次の様になる：
◎
The resulting DOM tree is as follows:
</p>

<ul class="domTree"><li>DOCTYPE: `html^c
	</li><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`p$e
			<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
				<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
					<ul><li>`b$e
						<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
							<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
								<ul><li>`b$e
									<ul><li>`#text$: <span>X⏎</span>
									</li></ul>
								</li></ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
				<ul><li>`b$e
					<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
						<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
							<ul><li>`b$e
								<ul><li>`#text$: <span>X⏎</span>
								</li></ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
				<ul><li>`b$e
					<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
						<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
							<ul><li>`b$e
								<ul><li>`b$e
									<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
										<ul><li>`b$e
											<ul><li>`#text$: <span>X⏎</span>
											</li></ul>
										</li></ul>
									</li></ul>
								</li></ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`p$e
			<ul><li>`#text$: <span>X⏎</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この~markup内の 2 個目の `p$e 要素は，明示的な `b$e 要素を有さないが、
結果の~DOM内では，要素の `X^l の前にて 3 個までの各~種類の整形~要素
（この事例では、
`class^a 属性を有する 3 個の `b$e 要素と, 有さない 2 個の `b$e 要素）
が構築し直されることになる様子に注意。
◎
Note how the second p element in the markup has no explicit b elements, but in the resulting DOM, up to three of each kind of formatting element (in this case three b elements with the class attribute, and two unadorned b elements) get reconstructed before the element's "X".
</p>

<p>
この地点までに 9 個の `b$e 開始~tagに出くわしたが、
このことは，［
最後の段落において、`作動中な整形~要素~list$内で完全に~clearする必要があるのは， 6 個の `b$e 終了~tagに限られる
］ことを意味することにも注意。
◎
Also note how this means that in the final paragraph only six b end tags are needed to completely clear the list of active formatting elements, even though nine b start tags have been seen up to this point.
</p>

				</section>
			</section>
		</section>
		<section id="serialising-html-fragments">
<h3 title="Serializing HTML fragments">13.3. ~HTML素片の直列化-法</h3>

<p class="trans-note">【
この節の内容は、
`別~page＠~HTMLwriting#serialising-html-fragments$にて。
】</p>


		</section>
		<section id="parsing-html-fragments">
<h3 title="Parsing HTML fragments">13.4. ~HTML素片の構文解析-法</h3>

<div class="algo">
<div class="p">
<p>
`~HTML素片の構文解析~algo@
は、
所与の
⇒＃
`Element$I ~node `文脈@V,
文字列 %入力,
真偽値 %宣言的な~shadow根を許容するか ~DF ~F
◎終
に対し，
~nodeたちが成す~listを返す：
</p>

<p>
この~algoの中で作成される構文解析器は、
`~HTML素片~用@
であるとされる。
【この用語は、他所の記述を簡素化するための，この訳による追加。】
</p>
◎
The HTML fragment parsing algorithm, given an Element node context, string input, and an optional boolean allowDeclarativeShadowRoots (default false) is the following steps. They return a list of zero or more nodes.
</div>

<p class="note">注記：
`§ ~HTML構文解析器＠#parsing$に与えた各種~algoにおいて
`素片~事例@
と~markされた箇所は、
当の構文解析器が この~algoの目的で作成されたときに限り生じる。
そのような~markは、
参考~目的に限って注釈されており，規範的な重みはない。
`素片~事例$として述べられた条件は、
構文解析器が この~algoを取扱う目的で作成されたものでない場合でも，生じる可能性がある
— それは，この仕様における
【~markの】
誤りである。
◎
Parts marked fragment case in algorithms in the HTML parser section are parts that only occur if the parser was created for the purposes of this algorithm. The algorithms have been annotated with such markings for informational purposes only; such markings have no normative weight. If it is possible for a condition described as a fragment case to occur even when the parser wasn't created for the purposes of handling this algorithm, then that is an error in the specification.
</p>

<ol>
	<li>
%文書 ~LET 新たな`文書$
— その
⇒＃
`種別$doc ~SET `html^l,
`~mode$doc ~SET %文脈 の`~node文書$の`~mode$doc
◎
Let document be a Document node whose type is "html".
◎
If context's node document is in quirks mode, then set document's mode to "quirks".
◎
Otherwise, if context's node document is in limited-quirks mode, then set document's mode to "limited-quirks".
</li>
	<li>
~IF［
%宣言的な~shadow根を許容するか ~EQ ~T
］
⇒
%文書 の`宣言的な~shadow根を許容するか$doc ~SET ~T
◎
If allowDeclarativeShadowRoots is true, then set document's allow declarative shadow roots to true.
</li>
	<li>
%構文解析器 ~LET 新たな `~HTML構文解析器$
◎
Create a new HTML parser, and＼
</li>
	<li>
%構文解析器 を %文書 に結付ける
◎
associate it with document.
</li>
	<li>
<p>
%構文解析器 の`~token化~段階$の状態 ~SET %文脈 に応じて，次で与えられる`状態$：
◎
Set the state of the HTML parser's tokenization stage as follows, switching on the context element:
</p>
		<dl class="switch">
			<dt>`title$e</dt>
			<dt>`textarea$e</dt>
			<dd>
`~RCDATA$st
◎
Switch the tokenizer to the RCDATA state.
</dd>
			<dt>`style$e</dt>
			<dt>`xmp$e</dt>
			<dt>`iframe$e</dt>
			<dt>`noembed$e</dt>
			<dt>`noframes$e</dt>
			<dd>
`~RAWTEXT$st
◎
Switch the tokenizer to the RAWTEXT state.
</dd>
			<dt>`script$e</dt>
			<dd>
`~script~data$st
◎
Switch the tokenizer to the script data state.
</dd>
			<dt>`noscript$e</dt>
			<dd>
`~scripting~flag$に応じて
⇒＃
`可能化^i  ならば `~RAWTEXT$st ／
`不能化^i ならば `~data$st
◎
If the scripting flag is enabled, switch the tokenizer to the RAWTEXT state. Otherwise, leave the tokenizer in the data state.
</dd>
			<dt>`plaintext$e</dt>
			<dd>
`~PLAINTEXT$st
◎
Switch the tokenizer to the PLAINTEXT state.
</dd>
			<dt>
その他
◎
Any other element
</dt>
			<dd>
`~data$st
◎
Leave the tokenizer in the data state.
</dd>
		</dl>

<p class="note">注記：
実装は、
処理能の理由から［
~errorを報告しない, かつ
この仕様に述べた実際の状態~機械を直に利用する
］ならば，上に挙げた［
`~RAWTEXT^st ／ `~script~data^st
］に代えて `~PLAINTEXT^st を利用することもできる。
それらは、
~perrorに関する規則を除き等価である
— `素片~事例$には，`適切な終了~tag~token$は無いので、
`yet^en【？】 それらが孕む状態~遷移はずっと少ない。
◎
For performance reasons, an implementation that does not report errors and that uses the actual state machine described in this specification directly could use the PLAINTEXT state instead of the RAWTEXT and script data states where those are mentioned in the list above. Except for rules regarding parse errors, they are equivalent, since there is no appropriate end tag token in the fragment case, yet they involve far fewer state transitions.
</p>
	</li>
	<li>
%根 ~LET `要素を作成する$( ↓ )
⇒＃
%文書,
`html^l,
`~HTML名前空間$,
~NULL,
~NULL,
~F,
%文脈 の`~custom要素~registry$el
◎
Let root be the result of creating an element given document, "html", the HTML namespace, null, null, false, and context's custom element registry.
</li>
	<li>
%文書 に`~nodeを付加する$( %根 )
◎
Append root to document.
</li>
	<li>
%構文解析器 の`~open要素~stack$は %根 のみを包含するように設定しておく
◎
Set up the HTML parser's stack of open elements so that it contains just the single element root.
</li>
	<li>
~IF［
%文脈 は `template$e 要素である
］
⇒
`~template挿入~mode~stack$に`~template内$mdを~pushする
◎
If context is a template element, then push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
	<li>
%開始~tag~token ~LET 新たな開始~tag~token( %文脈 の局所~名 )
◎
Create a start tag token whose name is the local name of context and＼
</li>
	<li>
%開始~tag~token の属性~list ~SET %文脈 の属性~list
◎
whose attributes are the attributes of context.
</li>
	<li>
<p>
%開始~tag~token を［
%文脈 を作成させた開始~tag~token
］とする
</p>

<p class="note">注記：
これは例えば、
`~HTML統合~地点$であるかどうか決定するときに利用される。
</p>
◎
Let this start tag token be the start tag token of context; e.g. for the purposes of determining if it is an HTML integration point.
</li>
	<li>
<p>
%構文解析器 の`挿入~modeを適切に設定し直す$
◎
Reset the parser's insertion mode appropriately.
</p>

<p class="note">注記：
%構文解析器 は、
その~algoの一部として %文脈 を参照することになる。
◎
The parser will reference the context element as part of that algorithm.
</p>
	</li>
	<li>
%構文解析器 の`~form要素~pointer$ ~SET ［
%文脈 または その先祖たち
］に `form$e 要素が［
在るならば それらのうち %文脈 に最も近いもの ／
無いならば ~NULL
］
◎
Set the HTML parser's form element pointer to the nearest node to context that is a form element (going straight up the ancestor chain, and including the element itself, if it is a form element), if any. (If there is no such form element, the form element pointer keeps its initial value, null.)
</li>
	<li>
［
符号化法の`確度$ ~SET `無関連^i
］とする下で、
%構文解析器 の`入力~stream$の中へ %入力 を流す
◎
Place the input into the input stream for the HTML parser just created. The encoding confidence is irrelevant.
</li>
	<li>
入力~streamをすべて消費するまで、
%構文解析器 を走らす
◎
Start the HTML parser and let it run until it has consumed all the characters just inserted into the input stream.
</li>
	<li>
~RET %根 の`子~群$
◎
Return root's children, in tree order.
</li>
</ol>
</div>

		</section>
	</section>
</main>
