<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8" />
<title>HTML Standard — Parsing HTML documents（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-whatwg.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>


<script>


PAGE_DATA = {
	trans_update: '2017-08-23',
	page_state_key: '___HTML',
	spec_status: 'LS',
	original_url: 'https://html.spec.whatwg.org/multipage/parsing.html',
	original_urls: {
		'writing': 'https://html.spec.whatwg.org/multipage/writing.html',
	},
	nav_prev: 'HTMLwriting',
	nav_next: 'HTMLxml',
};

Util.ready = function(){
	var source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		unicode_map: Util.get_mapping(
			Util.textData('_unicode_map')
			.replace( /\n(\w+):(.+):(.*)/g, function(t0, t1, t2, t3){
				return(
'\n'
+ t1
+ ':<span class="code-point">U+'
+ t1
+ '</span> <small class="cp-name">'
+ t2
+ '</small>'
+ ( !t3 ? '' : (
' (<span class="char-symbol">' + ( (t3 === '-' ) ? '&#x' + t1 + ';' : t3 ) + '</span>)'
	))
				);
			})
		),
		toc_main: 'syntax',
		levels: 'ほぼ英語:英語主体:漢字+英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	};
	Util.switchWordsInit(source_data);

//	Util.del_j(); //checked: 170706 spec
}

function expand(mapping1){

	var class_map = {
		E: 'error',
		e: 'element',
		a: 'attr',
		et: 'event-type',
		U: 'code-point',
		X: 'hex-value',
		P: 'production',
		v: 'value',
		st: 'tokenizer-state',
		md: 'insertion-mode',
		pE: 'parse-error',
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		c: 'code',
		e: 'code',
		a: 'code',
		et: 'code',
		v: 'code',
		U: 'span',
		X: 'span',
		P: 'code',
		st: 'span',
		md: 'span',
		mt: 'code',
		pE: 'span',
		sub: 'sub',
		i: 'i',
		V: 'var',
	};

	var link_map = this.link_map;
	var unicode_map = this.unicode_map;

	E('MAIN').innerHTML = Util.generateSource(this, mapping1, function(source){
		return source.replace(
			/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
			create_html
		);
	});
	return;

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return '<var>' + match.slice(1) + '</var>';
}

var text = key;
var href = '';
var classname = class_map[klass];
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = 'HTML-references.html#refs' + key;
	break;
case 'l': // literal
	text = '"<code class="literal">' + text + '</code>"';
	break;
case 'bl': // literal bytes
	text = '`<code class="bytes">' + text + '</code>`';
	break;
case 'U': // code point
	text = unicode_map[key] || '<span class="code-point">U+' + key + '</span>';
	break;
case 'X':
	text = '0x' + text;
	break;
case 'pE':
	href = '#parse-error-' + key;
	if(indicator === '$') return (
		'<a href="#parse-errors">~perror</a>( <a class="parse-error" href="' + href + '">' + key + '</a> )'
	);
	break;
}

if(tag) {
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return text;


	}
}

</script>

<!--%unicode data -->
<script type="text/plain" id="_unicode_map">
0000:NULL:
0009:CHARACTER TABULATION:tab
000A:LINE FEED:LF
000C:FORM FEED:FF
000D:CARRIAGE RETURN:CR
0020:SPACE:
0021:EXCLAMATION MARK:-
0022:QUOTATION MARK:-
0023:NUMBER SIGN:-
0026:AMPERSAND:-
0027:APOSTROPHE:-
002D:HYPHEN-MINUS:-
002F:SOLIDUS:-
003B:SEMICOLON:-
003C:LESS-THAN SIGN:-
003D:EQUALS SIGN:-
003E:GREATER-THAN SIGN:-
003F:QUESTION MARK:-
005B:LEFT SQUARE BRACKET:-
005D:RIGHT SQUARE BRACKET:-
0060:GRAVE ACCENT:-
0058:LATIN CAPITAL LETTER:-
0055:LATIN CAPITAL LETTER:-
0078:LATIN SMALL LETTER:-
FFFD:REPLACEMENT CHARACTER:

</script>

<script type="text/plain" id="_original_id_map">
</script>



<!--% 置換データ -->
<script type="text/plain" id="words_table1">
about_legacy-compat:<code class="scheme">about:legacy-compat</code>
HTMLcharref:HTML-charrefs-ja.html
MATHML:https://www.w3.org/Math/draft-spec

SVGscript:script
APPEND:<b class="op">&lt;&lt;</b>
EOF:<i>EOF</i>
</script>

<!--% リンク置換データ -->
<script type="text/plain" id="_link_map">
	●IDL

	SW:https://w3c.github.io/ServiceWorker/
#text:~DOM4#interface-text
#comment:~DOM4#interface-comment
I.Comment:~DOM4#interface-comment
I.Element:~DOM4#interface-element
I.Document:~HTMLdom#document
I.DocumentType:~DOM4#interface-documenttype
I.HTMLMenuElement:~HEgrouping#htmlmenuelement
I.PageTransitionEvent:~NAVI#pagetransitionevent
I.ServiceWorkerContainer:~SW#serviceworkercontainer
I.Text:~DOM4#interface-text
I.Window:~WINDOW#window

m.document.close():~HTML5/dynamic-markup-insertion.html#dom-document-close
m.document.open():~HTML5/dynamic-markup-insertion.html#dom-document-open
m.document.write():~HTML5/dynamic-markup-insertion.html#dom-document-write
m.document.writeln():~HTML5/dynamic-markup-insertion.html#dom-document-writeln

m.bubbles:~DOM4#dom-event-bubbles
m.doctype:~DOM4#dom-document-doctype
m.persisted:~NAVI#dom-pagetransitionevent-persisted

et.DOMContentLoaded:~HTMLindex#event-domcontentloaded
et.load:~HTMLindex#event-load
et.pageshow:~HTMLindex#event-pageshow

	＊about:legacy-compat:~HTMLurl#about:legacy-compat
mt.text/html:~HTML5/iana.html#text/html

	●要素

e.a:~HEtextlevel#the-a-element
e.abbr:~HEtextlevel#the-abbr-element
e.b:~HEtextlevel#the-b-element
e.bdi:~HEtextlevel#the-bdi-element
e.bdo:~HEtextlevel#the-bdo-element
e.br:~HEtextlevel#the-br-element
e.cite:~HEtextlevel#the-cite-element
e.code:~HEtextlevel#the-code-element
e.data:~HEtextlevel#the-data-element
e.dfn:~HEtextlevel#the-dfn-element
e.em:~HEtextlevel#the-em-element
e.i:~HEtextlevel#the-i-element
e.kbd:~HEtextlevel#the-kbd-element
e.mark:~HEtextlevel#the-mark-element
e.q:~HEtextlevel#the-q-element
e.rp:~HEtextlevel#the-rp-element
e.rt:~HEtextlevel#the-rt-element
e.ruby:~HEtextlevel#the-ruby-element
e.s:~HEtextlevel#the-s-element
e.samp:~HEtextlevel#the-samp-element
e.small:~HEtextlevel#the-small-element
e.span:~HEtextlevel#the-span-element
e.strong:~HEtextlevel#the-strong-element
e.sub:~HEtextlevel#the-sub-and-sup-elements
e.sup:~HEtextlevel#the-sub-and-sup-elements
e.time:~HEtextlevel#the-time-element
e.u:~HEtextlevel#the-u-element
e.var:~HEtextlevel#the-var-element
e.wbr:~HEtextlevel#the-wbr-element

e.blockquote:~HEgrouping#the-blockquote-element
e.div:~HEgrouping#the-div-element
e.dl:~HEgrouping#the-dl-element
e.dd:~HEgrouping#the-dd-element
e.dt:~HEgrouping#the-dt-element
e.figure:~HEgrouping#the-figure-element
e.figcaption:~HEgrouping#the-figcaption-element
e.hr:~HEgrouping#the-hr-element
e.li:~HEgrouping#the-li-element
e.main:~HEgrouping#the-main-element
e.menu:~HEgrouping#the-menu-element
e.ol:~HEgrouping#the-ol-element
e.p:~HEgrouping#the-p-element
e.pre:~HEgrouping#the-pre-element
e.ul:~HEgrouping#the-ul-element

e.del:~HEedits#the-del-element
e.ins:~HEedits#the-ins-element

e.address:~HEsections#the-address-element
e.article:~HEsections#the-article-element
e.aside:~HEsections#the-aside-element
e.body:~HEsections#the-body-element
e.footer:~HEsections#the-footer-element
e.header:~HEsections#the-header-element
e.hgroup:~HEsections#the-hgroup-element
e.nav:~HEsections#the-nav-element
e.section:~HEsections#the-section-element
e.h1:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h2:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h3:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h4:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h5:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements
e.h6:~HEsections#the-h1,-h2,-h3,-h4,-h5,-and-h6-elements

e.base:~HEmetadata#the-base-element
e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.link:~HEmetadata#the-link-element
e.meta:~HEmetadata#the-meta-element
e.style:~HEmetadata#the-style-element
e.title:~HEmetadata#the-title-element

e.noscript:~HEscripting#the-noscript-element
e.script:~HEscripting#the-script-element
e.slot:~HEscripting#the-slot-element
e.template:~HEscripting#the-template-element
e.canvas:~HEcanvas#the-canvas-element

e.input:~HEinput#the-input-element
e.button:~HEforms#the-button-element
e.datalist:~HEforms#the-datalist-element
e.fieldset:~HEforms#the-fieldset-element
e.form:~HEforms#the-form-element
e.legend:~HEforms#the-legend-element
e.label:~HEforms#the-label-element
e.meter:~HEforms#the-meter-element
e.output:~HEforms#the-output-element
e.optgroup:~HEforms#the-optgroup-element
e.option:~HEforms#the-option-element
e.progress:~HEforms#the-progress-element
e.select:~HEforms#the-select-element
e.textarea:~HEforms#the-textarea-element

e.details:~HEinteractive#the-details-element
e.dialog:~HEinteractive#the-dialog-element
e.summary:~HEinteractive#the-summary-element

e.area:~HEimages#the-area-element
e.img:~HEimages#the-img-element
e.map:~HEimages#the-map-element
e.source:~HEimages#the-source-element
e.picture:~HEimages#the-picture-element

e.embed:~HEembed#the-embed-element
e.iframe:~HEembed#the-iframe-element
e.object:~HEembed#the-object-element
e.param:~HEembed#the-param-element

e.audio:~HEmedia#the-audio-element
e.video:~HEmedia#the-video-element
e.track:~HEmedia#the-track-element

e.table:~HEtables#the-table-element
e.td:~HEtables#the-td-element
e.th:~HEtables#the-th-element
e.tr:~HEtables#the-tr-element
e.caption:~HEtables#the-caption-element
e.colgroup:~HEtables#the-colgroup-element
e.tbody:~HEtables#the-tbody-element
e.tfoot:~HEtables#the-tfoot-element
e.thead:~HEtables#the-thead-element
e.col:~HEtables#the-col-element

e.applet:~HTMLobs#applet
e.basefont:~HTMLobs#basefont
e.bgsound:~HTMLobs#bgsound
e.big:~HTMLobs#big
e.center:~HTMLobs#center
e.dir:~HTMLobs#dir
e.font:~HTMLobs#font
e.frame:~HTMLobs#frame
e.frameset:~HTMLobs#frameset
e.keygen:~HTMLobs#keygen
e.listing:~HTMLobs#listing
e.marquee:~HTMLobs#the-marquee-element
e.nobr:~HTMLobs#nobr
e.noembed:~HTMLobs#noembed
e.noframes:~HTMLobs#noframes
e.plaintext:~HTMLobs#plaintext
e.rb:~HTMLobs#rb
e.rtc:~HTMLobs#rtc
e.strike:~HTMLobs#strike
e.tt:~HTMLobs#tt
e.xmp:~HTMLobs#xmp


eMath.
e.mi:~MATHML/chapter3.html#presm.mi
e.mn:~MATHML/chapter3.html#presm.mn
e.mo:~MATHML/chapter3.html#presm.mo
e.ms:~MATHML/chapter3.html#presm.ms
e.mtext:~MATHML/chapter3.html#presm.mtext
e.annotation-xml:~MATHML/chapter5.html#mixing.elements.annotation.xml

e.desc:~SVG11/struct.html#DescElement
e.foreignObject:~SVG11/extend.html#ForeignObjectElement
e.title:~SVG11/struct.html#TitleElement
e.~SVGscript:~SVG11/script.html#ScriptElement


a.id:~HTMLdom#the-id-attribute
a.is:~HEscripting#attr-is
a.http-equiv:~HEmetadata#attr-meta-http-equiv
a.charset:~HEmetadata#attr-meta-charset
a.content:~HEmetadata#attr-meta-content
a.src:~HEscripting#attr-script-src
a.class:~HTMLdom#classes
a.form:~HTMLforms#attr-fae-form

	●error
	#parse-error-abrupt-closing-of-empty-comment
	#parse-error-abrupt-doctype-public-identifier
	#parse-error-abrupt-doctype-system-identifier
	#parse-error-absence-of-digits-in-numeric-character-reference
	#parse-error-cdata-in-html-content
	#parse-error-character-reference-outside-unicode-range
	#parse-error-control-character-in-input-stream
	#parse-error-control-character-reference
	#parse-error-duplicate-attribute
	#parse-error-end-tag-with-attributes
	#parse-error-end-tag-with-trailing-solidus
	#parse-error-eof-before-tag-name
	#parse-error-eof-in-cdata
	#parse-error-eof-in-comment
	#parse-error-eof-in-doctype
	#parse-error-eof-in-script-html-comment-like-text
	#parse-error-eof-in-tag
	#parse-error-incorrectly-closed-comment
	#parse-error-incorrectly-opened-comment
	#parse-error-invalid-character-sequence-after-doctype-name
	#parse-error-invalid-first-character-of-tag-name
	#parse-error-missing-attribute-value
	#parse-error-missing-doctype-name
	#parse-error-missing-doctype-public-identifier
	#parse-error-missing-doctype-system-identifier
	#parse-error-missing-end-tag-name
	#parse-error-missing-quote-before-doctype-public-identifier
	#parse-error-missing-quote-before-doctype-system-identifier
	#parse-error-missing-semicolon-after-character-reference
	#parse-error-missing-whitespace-after-doctype-public-keyword
	#parse-error-missing-whitespace-after-doctype-system-keyword
	#parse-error-missing-whitespace-before-doctype-name
	#parse-error-missing-whitespace-between-attributes
	#parse-error-missing-whitespace-between-doctype-public-and-system-identifiers
	#parse-error-nested-comment
	#parse-error-non-void-html-element-start-tag-with-trailing-solidus
	#parse-error-noncharacter-character-reference
	#parse-error-noncharacter-in-input-stream
	#parse-error-null-character-reference
	#parse-error-surrogate-character-reference
	#parse-error-surrogate-in-input-stream
	#parse-error-unexpected-character-after-doctype-system-identifier
	#parse-error-unexpected-character-in-attribute-name
	#parse-error-unexpected-character-in-unquoted-attribute-value
	#parse-error-unexpected-equals-sign-before-attribute-name
	#parse-error-unexpected-null-character
	#parse-error-unexpected-question-mark-instead-of-tag-name
	#parse-error-unexpected-solidus-in-tag
	#parse-error-unknown-named-character-reference

	●enc
en.Big5:~ENCODING#big5
en.EUC-KR:~ENCODING#euc-kr
en.ISO-2022-JP:~ENCODING#iso-2022-jp
en.ISO-8859-2:~ENCODING#iso-8859-2
en.ISO-8859-7:~ENCODING#iso-8859-7
en.ISO-8859-8:~ENCODING#iso-8859-8
en.Shift_JIS:~ENCODING#shift_jis
en.UTF-16BE:~ENCODING#utf-16be
en.UTF-16LE:~ENCODING#utf-16le
en.UTF-8:~ENCODING#utf-8
en.gb18030:~ENCODING#gb18030
en.windows-1250:~ENCODING#windows-1250
en.windows-1251:~ENCODING#windows-1251
en.windows-1252:~ENCODING#windows-1252
en.windows-1254:~ENCODING#windows-1254
en.windows-1255:~ENCODING#windows-1255
en.windows-1256:~ENCODING#windows-1256
en.windows-1257:~ENCODING#windows-1257
en.windows-1258:~ENCODING#windows-1258
en.windows-874:~ENCODING#windows-874
en.x-user-defined:~ENCODING#x-user-defined


	●state

st.~CDATAsec~bracket:#cdata-section-bracket-state
st.~CDATAsec:#cdata-section-state
st.~CDATAsec終端:#cdata-section-end-state
st.~DOCTYPE~public-keywordの後:#after-doctype-public-keyword-state
st.~DOCTYPE~publicIDの前:#before-doctype-public-identifier-state
st.~DOCTYPE~publicIDの後:#after-doctype-public-identifier-state
st.~DOCTYPE~publicID（一重引用符）:#doctype-public-identifier-(single-quoted)-state
st.~DOCTYPE~publicID（二重引用符）:#doctype-public-identifier-(double-quoted)-state
st.~DOCTYPE:#doctype-state
st.~DOCTYPE~system-keywordの後:#after-doctype-system-keyword-state
st.~DOCTYPE~systemIDの前:#before-doctype-system-identifier-state
st.~DOCTYPE~systemIDの後:#after-doctype-system-identifier-state
st.~DOCTYPE~systemID（一重引用符）:#doctype-system-identifier-(single-quoted)-state
st.~DOCTYPE~systemID（二重引用符）:#doctype-system-identifier-(double-quoted)-state
st.~DOCTYPE名:#doctype-name-state
st.~DOCTYPE名の前:#before-doctype-name-state
st.~DOCTYPE名の後:#after-doctype-name-state
st.~PLAINTEXT:#plaintext-state
st.~RAWTEXT~LTsign:#rawtext-less-than-sign-state
st.~RAWTEXT:#rawtext-state
st.~RAWTEXT終了tag~open:#rawtext-end-tag-open-state
st.~RAWTEXT終了tag名:#rawtext-end-tag-name-state
st.~RCDATA~LTsign:#rcdata-less-than-sign-state
st.~RCDATA:#rcdata-state
st.~RCDATA終了tag~open:#rcdata-end-tag-open-state
st.~RCDATA終了tag名:#rcdata-end-tag-name-state
st.~DOCTYPE~publicIDと~systemIDの合間:#between-doctype-public-and-system-identifiers-state
st.似非~DOCTYPE:#bogus-doctype-state
st.似非~comment:#bogus-comment-state
st.~comment~LTsign~bang~dash~dash:#comment-less-than-sign-bang-dash-dash-state
st.~comment~LTsign~bang~dash:#comment-less-than-sign-bang-dash-state
st.~comment~LTsign~bang:#comment-less-than-sign-bang-state
st.~comment~LTsign:#comment-less-than-sign-state
st.~comment:#comment-state
st.~comment始端~dash:#comment-start-dash-state
st.~comment始端:#comment-start-state
st.~comment終端~bang:#comment-end-bang-state
st.~comment終端~dash:#comment-end-dash-state
st.~comment終端:#comment-end-state
st.~data:#data-state
st.~decimal文字~参照:#decimal-character-reference-state
st.~decimal文字~参照~始端:#decimal-character-reference-start-state
st.~hexademical文字~参照:#hexademical-character-reference-state
st.~hexademical文字~参照~始端:#hexademical-character-reference-start-state
st.~markup宣言~open:#markup-declaration-open-state
st.数的な文字~参照:#numeric-character-reference-state
st.数的な文字~参照~終端:#numeric-character-reference-end-state
st.~script~data二重~escape済み~dash~dash:#script-data-double-escaped-dash-dash-state
st.~script~data二重~escape済み~dash:#script-data-double-escaped-dash-state
st.~script~data二重~escape済み~LTsign:#script-data-double-escaped-less-than-sign-state
st.~script~data二重~escape済み:#script-data-double-escaped-state
st.~script~data二重~escape始端:#script-data-double-escape-start-state
st.~script~data二重~escape終端:#script-data-double-escape-end-state
st.~script~data~escape済み~dash~dash:#script-data-escaped-dash-dash-state
st.~script~data~escape済み~dash:#script-data-escaped-dash-state
st.~script~data~escape済み~LTsign:#script-data-escaped-less-than-sign-state
st.~script~data~escape済み:#script-data-escaped-state
st.~script~data~escape済み終了tag~open:#script-data-escaped-end-tag-open-state
st.~script~data~escape済み終了tag名:#script-data-escaped-end-tag-name-state
st.~script~data~escape始端~dash:#script-data-escape-start-dash-state
st.~script~data~escape始端:#script-data-escape-start-state
st.~script~data~LTsign:#script-data-less-than-sign-state
st.~script~data:#script-data-state
st.~script~data終了tag~open:#script-data-end-tag-open-state
st.~script~data終了tag名:#script-data-end-tag-name-state
st.~tag~open:#tag-open-state
st.~tag名:#tag-name-state
st.属性~値の前:#before-attribute-value-state
st.一重引用符付き属性~値:#attribute-value-(single-quoted)-state
st.二重引用符付き属性~値:#attribute-value-(double-quoted)-state
st.引用符付き属性~値の後:#after-attribute-value-(quoted)-state
st.引用符無し属性~値:#attribute-value-(unquoted)-state
st.属性~名:#attribute-name-state
st.属性~名の前:#before-attribute-name-state
st.属性~名の後:#after-attribute-name-state
st.文字~参照:#character-reference-state
st.有名~文字~参照:#named-character-reference-state
st.多義的amp:#ambiguous-ampersand-state
st.終了tag~open:#end-tag-open-state
st.自己閉じ開始tag:#self-closing-start-tag-state

	●mode

md.初期:#the-initial-insertion-mode
md.~bodyの後の後:#the-after-after-body-insertion-mode
md.~framesetの後の後:#the-after-after-frameset-insertion-mode
md.~headの後:#the-after-head-insertion-mode
md.~headの前:#the-before-head-insertion-mode
md.~htmlの前:#the-before-html-insertion-mode
md.~bodyの後:#parsing-main-afterbody
md.~framesetの後:#parsing-main-afterframeset
md.~body内:#parsing-main-inbody
md.~caption内:#parsing-main-incaption
md.~cell内:#parsing-main-intd
md.~column-group内:#parsing-main-incolgroup
md.~frameset内:#parsing-main-inframeset
md.~head内:#parsing-main-inhead
md.~head~noscript内:#parsing-main-inheadnoscript
md.~row内:#parsing-main-intr
md.~select内:#parsing-main-inselect
md.~table内~select内:#parsing-main-inselectintable
md.~table内:#parsing-main-intable
md.~table~body内:#parsing-main-intbody
md.~table~text内:#parsing-main-intabletext
md.~template内:#parsing-main-intemplate
md.~text:#parsing-main-incdata

md.外来~内容~内:#parsing-main-inforeign


	●用語
文書:#_document

特別:#special
特別な要素:#special
整形~要素:#formatting
普通の要素:#ordinary

作成させた~token:#_token-for-which-it-was-created
~perror:#parse-errors
~HTML素片の構文解析~algo:#html-fragment-parsing-algorithm
	:#html-fragment-parsing-algorithm
~HTML素片~用:#_for-html-fragment-parsing
	素片~構文解析~flag
素片~flag:_#fragment-flag
素片~事例:#fragment-case

~HTML構文:#syntax
~HTML構文解析器:#html-parser

一時停止~flag:#parser-pause-flag
~script入子~level:#script-nesting-level
構文解析を停止する:#stop-parsing
中止-:#abort-a-parser
構文解析器を中止-:#abort-a-parser

~load~eventを遅延する:#delay-the-load-event
~load後~task準備済み:#ready-for-post-load-tasks
完全に読込まれ:#completely-loaded

~open要素~stack:#stack-of-open-elements
出るまで~open要素~stackから~popする:#_pop-until
~stackを~table~body文脈まで遡って~clearする:#clear-the-stack-back-to-a-table-body-context
~stackを~table文脈まで遡って~clearする:#clear-the-stack-back-to-a-table-context
~stackを~table~row文脈まで遡って~clearする:#clear-the-stack-back-to-a-table-row-context

作動中の整形~要素~list:#list-of-active-formatting-elements
作動中の整形~要素~listに~pushする:#push-onto-the-list-of-active-formatting-elements
作動中の整形~要素たちを再構築する:#reconstruct-the-active-formatting-elements
~marker:#concept-parser-marker
作動中の整形~要素~listを最後の~markerまで~clearする:#clear-the-list-of-active-formatting-elements-up-to-the-last-marker

	§tree構築
~token化~段階:#tokenization
木~構築~段階:#tree-construction
木~構築~分配器:#tree-construction-dispatcher
	:#meta-charset-during-parse

~tokenから要素を作成する:#create-an-element-for-the-token
暗黙の終了tagすべてを生成する:#generate-all-implied-end-tags-thoroughly
暗黙の終了tagたちを生成する:#generate-implied-end-tags
~MathML~text統合~地点:#mathml-text-integration-point
~HTML統合~地点:#html-integration-point


挿入~mode:#insertion-mode
V.元の挿入~mode:#original-insertion-mode
挿入~modeを適切に再設定する:#reset-the-insertion-mode-appropriately
~template挿入~mode~stack:#stack-of-template-insertion-modes
	現在の~template挿入~mode:#current-template-insertion-mode
用の規則を用いて:#using-the-rules-for
~HTML要素を挿入する:#insert-an-html-element
~commentを挿入する:#insert-a-comment
要素を挿入する:#_insert-an-element
外来の要素を挿入する:#insert-a-foreign-element
文字を挿入する:#insert-a-character

現在の調整-済み~node:#adjusted-current-node
外来の属性たちを調整する:#adjust-foreign-attributes
	:#adjust-foreign-attributes
~MathML属性たちを調整する:#adjust-mathml-attributes
~SVG属性たちを調整する:#adjust-svg-attributes


過去互換強制~flag:#force-quirks-flag
~frameset-ok~flag:#frameset-ok-flag
~scripting~flag:#scripting-flag
自己閉じ~flag:#self-closing-flag
自己閉じ~flagを承認する:#acknowledge-self-closing-flag

養子縁組~algo:#adoption-agency-algorithm
	:#adoptionAgency

適切な終了tag~token:#appropriate-end-tag-token
適切な~node挿入-先:#appropriate-place-for-inserting-a-node
属性の一部として消費されて:#charref-in-attribute
文字~参照として消費される~cpを一掃する:#flush-code-points-consumed-as-a-character-reference

~p要素を閉じる:#close-a-p-element
~cellを閉じる:#close-the-cell

V.文字~参照~code:#character-reference-code
V.文脈~要素:#concept-frag-parse-context

現在の入力~文字:#current-input-character
現在の~node:#current-node

~form要素~pointer:#form-element-pointer
~head要素~pointer:#head-element-pointer

親を違える:#foster-parent

~RCDATA要素の汎用~構文解析~algo:#generic-rcdata-element-parsing-algorithm
生~text要素の汎用~構文解析~algo:#generic-raw-text-element-parsing-algorithm
属性を取得-:#concept-get-attributes-when-sniffing

視野~内:#has-an-element-in-the-specific-scope

既定の視野:#has-an-element-in-scope
~table視野:#has-an-element-in-table-scope
~list~item視野:#has-an-element-in-list-item-scope
~button視野:#has-an-element-in-button-scope
~select視野:#has-an-element-in-select-scope

入力~byte~stream:#the-input-byte-stream
入力~stream:#input-stream
挿入~地点:#insertion-point
明示的な~EOF:#explicit-eof-character
次n文字:#next-input-character
次n入力~文字:#next-input-character
次n~token:#next-token
次n~LF文字~tokenは無視するようにしておく:#_igonore-next-lf-token

V.処理待ち~table文字~token~list:#concept-pending-table-char-tokens
再消費-:#reconsume
	:#nestedParsing

V.一時~buffer:#temporary-buffer
~tokenizer:#tokenization
状態:#_tokenizer-state
V.戻先~状態:#return-state
切替える:#_switch-to


	§符号化方式
確度:#concept-encoding-confidence
属性を取得-@
既知の確定的な符号化方式:#a-known-definite-encoding
符号化方式を変更する:#change-the-encoding
符号化方式を~sniffする~algo:#encoding-sniffing-algorithm
~byte~streamを予走査して符号化方式を決定する:#prescan-a-byte-stream-to-determine-its-encoding
	#documentEncoding
	#utf-8
	#iso-8859-2
	#iso-8859-7
	#iso-8859-8
	#windows-874
	#windows-1250
	#windows-1251
	#windows-1252
	#windows-1254
	#windows-1255
	#windows-1256
	#windows-1257
	#windows-1258
	#gb18030
	#big5
	#iso-2022-jp
	#shift_jis
	#euc-kr
	#utf-16be
	#utf-16le
	#x-user-defined

	●syntax
有名~文字~参照:~HTMLcharref#named-character-references

~DOCTYPE:~HTMLwriting#syntax-doctype
~CDATAsec:~HTMLwriting#syntax-cdata
~comment:~HTMLwriting#syntax-comments
~DOCTYPE:~HTMLwriting#syntax-doctype
多義的amp:~HTMLwriting#syntax-ambiguous-ampersand
属性:~HTMLwriting#syntax-attributes
属性~名:~HTMLwriting#syntax-attribute-name
属性~値:~HTMLwriting#syntax-attribute-value
文字~参照:~HTMLwriting#syntax-charref
~void要素:~HTMLwriting#void-elements
終了tag:~HTMLwriting#syntax-end-tag
開始tag:~HTMLwriting#syntax-start-tag

	●HTML
~XML構文:~HTMLxhtml#the-xhtml-syntax

~ASCII互換な符号化方式:~HTMLINFRA#ascii-compatible-encoding
~HTML要素:~HTMLINFRA#html-elements
	in the terminology section:~HTMLINFRA#html-elements
	:~HTMLINFRA#hardwareLimitations
~UTF-16:~HTMLINFRA#utf-16-encoding
文字大小区別:~HTMLINFRA#case-sensitive
~scriptingを~supportしない:~HTMLINFRA#non-scripted
要素~型:~HTMLINFRA#element-type

~meta要素から符号化方式を抽出する:~HTMLurl#algorithm-for-extracting-a-character-encoding-from-a-meta-element
~Content-Type~metadata:~HTMLurl#content-type


開始済み~flag:~HEscripting#already-started
阻まず~flag:~HEscripting#non-blocking
解析器挿入~flag:~HEscripting#parser-inserted
解析器実行準備済み~flag:~HEscripting#ready-to-be-parser-executed
~script~blockを実行する:~HEscripting#execute-the-script-block
準備-:~HEscripting#prepare-a-script
可能な限りすぐに順に実行される~scriptの~list:~HEscripting#list-of-scripts-that-will-execute-in-order-as-soon-as-possible
文書を構文解析し終えたときに実行されることになる~scriptの~list:~HEscripting#list-of-scripts-that-will-execute-when-the-document-has-finished-parsing
構文解析器を阻んでいる~script:~HEscripting#pending-parsing-blocking-script
可能な限りすぐに実行される~scriptの集合:~HEscripting#set-of-scripts-that-will-execute-as-soon-as-possible
~template内容:~HEscripting#template-contents
	:~HEscripting#restrictions-for-contents-of-script-elements

作動中の文書:~BROWSERS#active-document
閲覧文脈:~BROWSERS#browsing-context
属する閲覧文脈:~BROWSERS#concept-document-bc
入子の閲覧文脈:~BROWSERS#nested-browsing-context
頁~表示中:~NAVI#page-showing
親~閲覧文脈:~BROWSERS#parent-browsing-context
~source閲覧文脈:~BROWSERS#source-browsing-context
通して入子にされて:~BROWSERS#browsing-context-nested-through

生成元:~ORIGIN#concept-origin
同一生成元:~ORIGIN#same-origin
非同一生成元:~ORIGIN#same-origin

~navigate:~NAVI#navigate
置換え可能化~flag:~NAVI#replacement-enabled

結付けている~window:~WINDOW#concept-document-window
	I.Window:~WINDOW#window

~iframe-srcdoc文書:~HEembed#an-iframe-srcdoc-document

~listされる要素:~HEforms#category-listed
~formに所有され得る要素:~HEforms#form-associated-element
~form所有者:~HTMLforms#form-owner
	所有させる:~HTMLforms#concept-form-association
~checkedness:~HTMLforms#concept-fe-checked
再設定-:~HTMLforms#concept-form-reset
再設定する~algo:~HTMLforms#concept-form-reset-control
構文解析器挿入~flag:~HTMLforms#parser-inserted-flag
再設定-可能な要素:~HEforms#category-reset
値:~HTMLforms#concept-fe-value

doc.現在の準備度:~HTMLdom#current-document-readiness
	:~HTMLdom#attr-xml-lang

現在の要素~待行列:~HEcustom#current-element-queue
~custom要素~構築子:~HEcustom#custom-element-constructor
~custom要素~反応~stack:~HEcustom#custom-element-reactions-stack
~custom化された組込みの要素:~HEcustom#customized-built-in-element
要素~待行列:~HEcustom#element-queue
~custom要素~callback反応を待入れる:~HEcustom#enqueue-a-custom-element-callback-reaction
~custom要素~反応を呼出す:~HEcustom#invoke-custom-element-reactions
~custom要素~定義を検索する:~HEcustom#look-up-a-custom-element-definition

~scriptを阻んでいる~stylesheet:~HEmetadata#a-style-sheet-that-is-blocking-scripts
~scriptを阻んでいる~stylesheetはある:~HEmetadata#has-a-style-sheet-that-is-blocking-scripts
~scriptを阻んでいる~stylesheetは無い:~HEmetadata#has-no-style-sheet-that-is-blocking-scripts
	:~HEmetadata#charset1024

	:~HTML5/dynamic-markup-insertion.html#dom-document-write
	:~HTML5/dynamic-markup-insertion.html#dom-document-open
	:~HTML5/dynamic-markup-insertion.html#dynamic-markup-insertion
	:~HTML5/dynamic-markup-insertion.html#dynamic-markup-insertion
動的~markup挿入-時には投出する~counter:~HTMLGAPI#throw-on-dynamic-markup-insertion-counter
	:~HTML5/dynamic-markup-insertion.html#script-created-parser


読込まれたとき印刷する~flag:~HTMLGAPI#print-when-loaded
印刷-時の手続き:~HTMLGAPI#printing-steps

~task:~WAPI#concept-task
~task源:~WAPI#task-source
~DOM操作~task源:~WAPI#dom-manipulation-task-source
~taskを待入する:~WAPI:#queue-a-task
~event~loop:~WAPI#event-loop
~event~loopを回す:~WAPI#spin-the-event-loop
極小task~checkpointを遂行する:~WAPI#perform-a-microtask-checkpoint
関連する設定群~obj:~WAPI#relevant-settings-object
~scriptingは可能化されて:~WAPI#concept-n-script

	:https://www.w3.org/Bugs/Public/show_bug.cgi?id=27314

	●外部
sub.大小無視:~INFRA#ascii-case-insensitive
~ASCII大小無視:~INFRA#ascii-case-insensitive
~ASCII英字:~INFRA#ascii-alpha
~ASCII英小文字:~INFRA#ascii-lower-alpha
~ASCII英数字:~INFRA#ascii-alphanumeric
~ASCII英大文字:~INFRA#ascii-upper-alpha
~ASCII数字:~INFRA#ascii-digit
~ASCII~hex数字:~INFRA#ascii-hex-digit
~ASCII~hex数字（小文字）:~INFRA#ascii-lower-hex-digit
~ASCII~hex数字（大文字）:~INFRA#ascii-upper-hex-digit
~ASCII空白:~INFRA#ascii-whitespace
~cp:~INFRA#code-point
制御文字:~INFRA#control
~ASCII小文字~化:~INFRA#ascii-lowercase
非文字:~INFRA#noncharacter
~surrogate:~INFRA#surrogate

~HTML名前空間:~INFRA#html-namespace
~MathML名前空間:~INFRA#mathml-namespace
~SVG名前空間:~INFRA#svg-namespace
~XLink名前空間:~INFRA#xlink-namespace
~XML名前空間:~INFRA#xml-namespace
~XMLNS名前空間:~INFRA#xmlns-namespace

~stack:~INFRA#stack
	~pop
	~push

	~byte大小無視$

~HTML~MIME型:~MIMESNIFF#html-mime-type
~URL:~URL1#concept-url

復号-:~ENCODING#decode
符号化方式:~ENCODING#encoding
符号化方式を取得する:~ENCODING#concept-encoding-get

属性を付加する:~DOM4#concept-element-attributes-append
~eventを発火-:~DOM4#concept-event-fire
~HTML文書:~DOM4#html-document
doc.符号化方式:~DOM4#concept-document-encoding
doc.~mode:~DOM4#concept-document-mode
doc.種別:~DOM4#concept-document-type
新たな要素:~DOM4#concept-create-element
elem.作成:~DOM4#concept-create-element
文書~要素:~DOM4#document-element
	限定的互換~mode:~DOM4#concept-document-limited-quirks
	非過去互換~mode:~DOM4#concept-document-no-quirks
	過去互換~mode:~DOM4#concept-document-quirks
変異~observer:~DOM4#mutation-observers
~node文書:~DOM4#concept-node-document
木:~DOM4#concept-tree
木~順序:~DOM4#concept-tree-order

~client~message待行列:~SW#dfn-client-message-queue
~sw~client:~SW#serviceworkercontainer-service-worker-client

~JS実行~文脈~stack:~TC39#execution-context-stack
~SVG~script要素を処理する:https://www.w3.org/TR/SVGMobile12/script.html#ScriptContentProcessing

</script>

<!--% 語彙置換データ-->
<script type="text/plain" id="words_table">
AnyElse:<i>Anything else</i>:<i>その他</i>
Content-Type:
DOM:
MIME:
HTML:
JS:JavaScript
MathML:
	REPLACEMENT-CHARACTER:REPLACEMENT-CHARACTER
SGML:
SVG:
URL:
UTF-16:
UTF-8:
Unicode:
XLink:
XML:
XMLNS:
address::::アドレス
algo:algorithm:::アルゴリズム
	around:
bit::::ビット
block::::ブロック
bookmark:
button::::ボタン
byte::::バイト
	byte列:sequence of bytes
cache::::キャッシュ
call::::
callback::::
	call元:caller
access::::アクセス
alert::::
interface::::インタフェース
link::::リンク
list::::リスト
mark::::マーク
markup::::マークアップ
message::::メッセージ
loop::::ループ
checkedness::::チェック有無
checkpoint::::
極小task:microtask:::極小タスク
client::::クライアント
code::::コード
contrast::::
cost::::コスト

custom::::カスタム
data::::データ
entry::::エントリ

event::::イベント
file::::ファイル

script::::スクリプト
scripting::::スクリプト処理
	~script用:scripting
stylesheet::::スタイルシート

form-control:form control:::フォームコントロール
form::::フォーム
group::::グループ
hyperlink::::ハイパーリンク
iframe-srcdoc::::
in-line::::インライン
instance::::インスタンス
item::::アイテム
keyword::::キーワード
level::::レベル
locale::::ロケール
memory::::メモリ
metadata::::メタデータ
method::::メソッド
mode::::モード
navigate::::ナビゲート
network::::ネットワーク
	not-ok
	ok
obj:object:::オブジェクト

pair::::ペア

pattern::::パタン

pipeline:
infoset:
	落とし込み:coercing

pragma::::
random::::ランダム
record::::レコード
security::::セキュリティ
session::::セッション
shift::::シフト
source::::ソース
stack::::スタック
status::::ステータス
stream::::ストリーム
sw:service worker
transport::::トランスポート
system::::システム
target::::ターゲット
task::::タスク
text::::テキスト
time::::
window:

	●文字
bang:
bracket:
surrogate::::サロゲート
semicolon::::セミコロン
slash:
space:
	~spaceでない:non-space
BOM:
CR:
LF:
ASCII:
DOCTYPE:
cp:code point:符号位置
CDATAsec:CDATA section::CDATA 節::CDATA セクション
comment::::コメント
text::::テキスト
eof:end-of-file
escape::::エスケープ

hex:::16 進
decimal:::10 進数による
hexadecimal:::16 進数
hexademical:::16 進数による
	numerical 同様に形容詞？
literal:
文字列:string::~
文字:character::~
非文字:noncharacter::~
	文字~tokenでない:non-character tokens
小文字:lowercase::~
大文字:uppercase::~
	大文字:capital letters
制御文字:control::~
C1:
	数:number
数的な:numeric::数による
改行文字:newline::~
空:empty:~
空白:whitespace::~
	~ASCII空白／空白:space
整数:integer:~
数字:digit::~
英字:alpha::~
英数字:alphanumeric::~
英小文字:lower alpha::~
英大文字:upper alpha::~
引用符:quote mark::~
引用符付き:quoted::~
引用符無し:unquoted::~
引用符無しの:unquoted::~
一重引用符:single quote::~
二重引用符:double quote::~
二重:double::~
一重引用符付き:single-quoted::~
二重引用符付き:double-quoted::~
文字大小:case::~
大小無視:case-insensitive::~
文字大小区別:case-sensitive::~

多義的amp:ambiguous ampersand::多義的 ampersand:多義的アンパサンド

	●parser
sniff:
	sniffing
dash:
html:
p:
meta:
head:
noscript:
body:
table:
caption:
column-group:column group
row:
cell:
select:
template:
frameset:
frameset-ok:
CDATA:
DOCTYPE:
LTsign:less-than sign::小なり記号
PLAINTEXT:
RAWTEXT:
RCDATA:
一掃-:flush::~
戻先:return:戻り先
	後で戻る:return
	戻-:back

構文解析器:parser::~::パーサ
構文解析-:parse::~::パース
構文解析:parsing::~::パース処理
	構文解析-法:parsing
	再~構文解析-:re-parse
	予め構文解析-:preparse
解析器挿入:parser-inserted::~::パーサ挿入
構文解析器挿入:parser-inserted::~::パーサ挿入
解析器実行準備済み:ready to be parser-executed::~
準備-:prepare::~
準備度:readiness::~
準備済み:ready::~
perror:parse error::構文解析 error:構文解析エラー:パースエラー
error::::エラー
	誤り:error:
	~error含みの:erroneous
直列化器:serializer::~::シリアライザ
直列化:serialization::~::シリアル化
直列化-:serialize::~::シリアル化
処理-:process::~
処理:processing::~
前処理-:preprocess::~
前処理器:preprocessor::~
処理命令:processing instruction::~
処理能:performance::~
再処理-:reprocess::~

養子縁組:adoption agency::~

前置き:preamble::~
設置され:place され:置かれ
生成-:generate::~
発-:emit::~
切替える:switch する::切り替える
切替えな:switch しない::切り替えな
切替えら:switch さ::切り替えら
切替えて:switch して::切り替えて
切替えた:switch した::切り替えた

pop::::
	pop off:pop
push:

消費-:consume::~
	消費され尽くした:lack
再消費-:reconsume::~
開始:start::~
開始-:start::~
終端:end::~
始端:start::~
tag::::タグ
開始tag:start tag::開始 tag:開始タグ
終了tag:end tag::終了 tag:終了タグ
開始済み:already started:start 済み:~

token::::トークン
現token:current token:現 token::現トークン
tokenizer::::トークン化器:トークナイザ
	token化:tokenization
	token化:tokenize
buffer::::バッファ
clear::::
close::::
closing::::
counter::::
charset::::
flag::::フラグ
marker::::マーカ
node::::ノード
open::::
一時停止:pause::~
停止-:stop::~
pointer::::ポインタ
publicID:public identifier:public 識別子
systemID:system identifier:system 識別子
public-keyword:public keyword:::public キーワード
system-keyword:system keyword:system キーワード
阻む:block する::~::ブロックする
	阻むのをやめ:unblock
阻んで:block して::~::ブロックして
阻まず:non-blocking::~::非ブロッキング
入子:nesting::入れ子
入子に:nest::入れ子に
入子の:nested::入れ子の
入子で:nest して::入れ子に
誤入子な:misnested::入れ子に誤りがある
誤入子に:misnest::誤って入れ子に
不能化-:disable:~
不能化:disabled:~
可能化-:enable:~
可能化:enabled:~
先送り:defer:~
再構築-:reconstruct::~
構築:construction::~
分配器:dispatcher::~
	〜に出くわした:seen
	親を違える:foster parent
挿入-:insert::~
挿入:insertion::~
	挿入-時:insertion
	挿入-先:place for inserting a node／insertion location
	弾き出される:dropped on the floor
付加-:append:~
	付加-:insert 〜 at the end of
作成-:create:~
作成:creation:~
除去-:remove:~
復号-:decode::~::デコード
復号器:decoder::~::デコーダ
走査:scan::~
予走査:prescan::~
	予走査:pre-scan

失敗-:fail:~
失敗:failure:~
成功-:succeed:~
成功裡:successful:~
承認-:acknowledge::~
自己閉じ:self-closing::~
	尽きる:runs out of
	〜に流し込まれる:make their way into

閉じる:close する::~
閉じら:close さ::~
閉じな:close しな::~
開かれ:open され::~
	再び開かれ:reopening
符号化-:encode::~::エンコード
符号化方式:encoding::~::エンコーディング
	符号化方式:character encoding
	〜数として解釈した結果:numeric version
	-:in increasing numeric order
	ε:undefined

限定的互換:limited-quirks::~
非過去互換:no-quirks::~
過去互換:quirks::~
過去互換強制:force-quirks::~
先祖:ancestor::~
子孫:descendant::~
名前空間:namespace::~
根:root::~::ルート
文書:document::~
親:parent::~
子:child::~
	子たち:children
木:tree::~::ツリー
要素:element::~
void:
	~void要素:void element
属性:attribute::~
名前:name::~
名:name::~
有名:named::~
値:value::~
型:type::~
局所:local::~::ローカル
	局所~名:localName
条項:clause:~
分岐:clause:~
	と記される分岐:clause
視野:scope::~::スコープ
前置き:preamble::~
遷移:transition:~
普通の:ordinary::~
整形:formatting::~
整形式の:well-formed::~
構成子:construct::~
構築-:construct::~
築く:build する:~
	builder
構文:syntax::~
構文的:syntactic::~
段階:stage::~::ステージ
素片:fragment::~::フラグメント
確定的:definite::~
確度:confidence::~
暫定的:tentative::~
確か:certain::~
無関係:irrelevant::~
状態:state::~
中止-:abort::~
似非:bogus::~
調整-:adjust::~
	調整-済み:adjusted
宣言-:declare::~
宣言:declaration::~
統合:integration::~
	遡って:back して

	●仕様
API:
UA:user agent:UA
Web:
app:application:::アプリ
browser::::ブラウザ
model::::モデル
tool::::ツール
toolchain::::ツール鎖
version::::バージョン
web::::
well-defined::::
	Annex
	HTML2〜HTML4
	Windows, Chrome, Firefox

一義的:unambiguous:~
多義的:ambiguous:~
一般:general:~
不正:incorrect:~
正しい:correct:~
正しく:correct に:~
主張-:claim:~
事例:case:~
事実:fact:~
互換:compatible:~
互換性:compatibility:~
仕方:way:~
仕組み:mechanism:~
作者:author:~
利便:convenience:~
傾向:tend:~
共通の:common:~
共通的な:common な:よくある
単純:simple:~
	単純~化:simplify
厳格:strict:~
可用:available:~
	可能／あり得る:possible:~
	問わない:matter
問題:problem:~
各種用語:terminology:~
合法:legal:~
定例の:regular:~
効果的:effective:~
実質的:effective:~
実際:actual:~
実際の:actual:~
	実際には:actually
序論:introduction:~
微妙な:subtle:~
	必要:need:~
	必要とされ:necessary:~
恣意的な:arbitrary:~
情報:information:~
手続き:steps:~
下位手続き:substeps:~
段:step:~
方式:manner:~
明示的:explicit:~
暗黙的:implicit:~
未来の:future:~
条件:condition:~
概して:typical に:~
概念的:conceptual:~
概観:overview:~
標準:standard:~
機械:machine:~
正確:exact:~
歴史的:historical:~
仕様:spec:~
特別:special:~
特定0の:particular:ある特定の
特定の:specific:~
特有の:specific な:~
特定的:specifical:~
	特に:specifical
状況:situation:~
直接的:direct:~
理由:reason:~
環境:environment:~
目的:purpose:~
相互運用可能:interoperable:~
相互運用性:interoperability:~
相違:differences:~
	省略可:optional:~
都合よく:convenient に:~
精確:precise:~
経験則:heuristics:~
著作:authoring:~
複雑な:complicated:~
見本:sample:~
規範的:normative:~
詳細:details:~
誤記:typo:~
課題:issue:~
通例的:usual:~
	通常のように:normal に
過度の:excessive:~
適切:appropriate:~
適正:proper:~
関連する:relevant な:~
間接的:indirect:~
変則的:strange:~
不良:bad:~
便益:benefit:~
地位:status:~
素直:straightforward:~
	straight-forward manner
比較的:relative に:比較的
効果:effect:~
効率的:efficient:~
基礎:basis:~
頻度解析:frequency analysis:~
重み:weight:~
類似性:resemblance:~
真似る:resemble する:~
共通部分:intersection:~
模造:fake:~
参考:informational:~
	ひどく:dramatically
	~~必須:imperative
	本番の／実の:real
	~UAの任意選択で:optionally
	しかしながら，:however
	一方で:whereas／however
	したがって:therefore
	したがって:thus
	とりわけ:especially
	べき:should
	もたらす:lead
	因り:due
	依然として／それでも:still
	そのため:by necessity
	すなわち:i.e.
	非常に〜易い:highly
	〜であっても:notwithstanding
	的に:fashion
	その場で:on-the-fly
	~~進行に伴い:course
	として／すなわち／:namely
	にもかかわらず:despite
	なることはない:by any means
	具体例として:for instance
	きちんと定義される:well-defined
	様な見かけ:looks like
	可能性もある:it is possible that
	言い換えれば:In other words,
	見込まれる:plausibly
	見込まれる:likely
	およそ〜と見込まれる:very likely
	であろう:will likely
	明らかに:clear
	更に詳しく:elaborating
	そのため、because of
	ため:For the sake of
	-:we
	-:indeed
	何十年もの間:decades
	真の:true
	頻用:frequent
	表れ:sign
	例:example

	●仕様（動詞
support::::サポート
依存-:depend:~
修正-:fix:~
利用-:use:~
	を利用して:using
	併用:use 〜 in conjunction with
利用者:user:~
制御:control:~
	制御を明け渡す:yielding control back to
制約-:restrict:~
制約:restriction:~
制限-:limit:~
副作用:side-effect:~
再入的:reentrant:~
取扱って:handle して:取り扱って
取扱われ:handle され:取り扱われ
取扱わ:handle し:取り扱わ
取扱う:handle する:取り扱う
取扱い:handling:取り扱い
呼出:invocation:呼び出し
呼出して:invoke して:呼び出して
呼出した:invoke した:呼び出した
呼出され:invoke され:呼び出され
呼出す:invoke する:呼び出す
	再び呼出-:reinvoke
報告-:report:~
受容-:accept:~
奨励-:encourage:~
	しないことが奨励される:discourage
孕む:involve する:~
定義-:define:~
定義:definition:~
実施:practice:~
実施上の:practical:~
実用的:practical:~
	実用的でない:impractical
実装-:implement:~
実装:implementation:~
実装者:implementor:~
暗黙の:implied:~
黙示-:imply:~
対話的:interactive:~
専用の:dedicated:~
導入-:introduce:~
導出-:derive:~
強いら:force さ:~
強調-:highlight:~
影響-:affect:~
意味-:mean:~
意味:meaning:~
意図-:intend:~
懸念:concern:~
拘束:constraints:~
拡張-:extend:~
指定-:specify:~
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
提供-:provide:~
援助-:aid:~
改善-:improve:~
改善:improvement:~
既知の:known:~
旧来の:legacy:~
望む:wish する:~
期待-:expect:~
予期-:expect:~
	予期せず／予期されない:unexpected
未定義:undefined:~
検出-:detect:~
		検出-可能な:detectable
検出:detection:~
自動検出-:autodetect:~
自動検出:autodetection:~
検分-:examine:~
検査-:check:~
検査器:checker:~
検証y-:verify:検証
検証器:validator:~
決定-:determine:~
注釈-:annotate:~
浪費-:waste:~
混同:confusion:~
確保-:ensure:~
生産性:productivity:~
発見-:discover:~
示唆-:suggest:~
禁制-:prohibit:~
競合-:conflict:~
結付け:association:結び付け
結付けら:associate さ:結び付けら
結付ける:associate する:結び付ける
結付けて:associate して:結び付けて
統治-:govern:~
考える:consider する:~
見なさ:consider さ:~
衝突-:clash:~
表現-:represent:~
表現:representation:~
要求-:require:~
要件:requirements:~
要請-:request:~
見かけ:look:~
見做す:assume する:~
見出す:find する:~
見出せる:find できる:~
見出され:find され:~
解決-:resolve:~
解釈-:interpret:~
解釈:interpretation:~
言及-:mention:~
許容-:allow:~
	 許容できる:allowable
試みて:attempt して:~
試みる:attempt する:~
認識-:recognize:~
誘発-:trigger:~
誤解釈-:misinterpret:~
課-:impose:~
論じら:discuss さ:~
論じる:discuss する:~
	起こる:happen
記述:description:~
記述-:describe:~
述べる:describe する:~
述べた:describe した:~
追跡-:track:~
違反:violation:~
適合-:conform:~
	:conformant
適合性:conformance:~
適用-:apply:~
遭遇-:encounter:~
避ける:avoid する:~
配備-:deploy:~
開発:development:~
防ぐ:prevent する:~
除外-:exclude:~
順守-:obey:~
定めた:state した:~
内来的:inherent:~
受持つ:cover する:受け持つ
遺棄-:abandon:~

	呼ばれ:call
	書かれ:written
	落として:dropして
	~~問題になる:offending
	より重くなる:outweigh
	則って:according
	加えて:in addition
	扱う:treat
	概説-:outline
	見よ:see
	関心がある:interesting
	関心のある:interested
	導く:taking
	そのままにされる:remains intact 
	次のいずれかに分類される:fall into the following categories
	仕分けられる:fall into
	と記された所では:talks about
	〜に基づく:based
	知らしめたし:please 〜 let us know
	注記:note
	挙げ／:listed
	~~保ち続けて:bear
	:Don’t ask
	dealing
	said
	causing

	●未分類（動詞
load:
download::::ダウンロード
observer:
再開-:resume:~
読込まれ:load され::読み込まれ::ロードされ
読込む:load する::読み込む::ロードする
上書き:override:~
	付加-
供与-:contribute:~
保持-:hold:~
先行-:precede:~
具現化-:render:~
分離-:separate:~
初期:initial:~
	初期~時には:initially
初期化-:initialize:~
動作-:act::~
動作:action::~
作動中の:active な::~::アクティブな
参照:reference:~
参照-:reference:~
	称され:refer
	指す:refer
包含-:contain:~
収集-:collect:~
取得-:get:~
設定-:set:~
再設定-:reset:~
設定群:settings:~
待入する:queue する::待ち行列に入れる::キューする
待入れる:enqueue する::待ち行列に入れる::エンキューする
待行列:queue::待ち行列::キュー
回す:spin する:~

検索-:look up::~
反応:reaction::~
構築子:constructor::~::コンストラクタ
組込みの:built-in::~
操作-:manipulate:~
操作:manipulation:~
飛ばす:skip する:~
	skip over
所有-:own:~
所有者:owner:~
合致-:match:~
増やし:increment し:~
変化-:change:~
変換-:convert:~
変換:conversion:~
変換器:converter:~
変更-:change:~
変更:changes:~
変異:mutation:~
存在-:exist:~
完了-:complete:~
完全:complete:~
実行-:execute:~
実行:execution:~
遅延-:delay::~
待機-:wait:~
復旧-:restore:~
忘れた:forget した:~
	forgotten
抑制-:reduce:~
投出:throw:~
抽出-:extract:~

改変-:modify:~
	改変されない:unmodified
比較-:compare:~
	決め:decide:~
注入:injection:~
減算-:subtract:~
	渡-:pass:~
漏れる:leak する:~
演算-:operate:~
演算:operation:~
無視-:ignore:~
発火-:fire:~
破棄-:discard:~
移動-:move:~

終了-:terminate:~
継続-:continue:~
	繰返-:repeat:~
置換-:replace:~
現れる:appear する:~
	異なる:different:~
	示す:show:~

覚える:remember する:~
受取った:receive した:受け取った
受取る:receiveする:受け取る
伝達-:convey:~
処理待ち:pending:~
完遂-:finish:~
対応付けて:map して:~
訪問-:visit:~

識別-:identify:~
識別子:identifier:~
走って:run して:~
走らす:run する:~
走らせ:run し:~
走れる:run できる:~
走る:run する:~

加算-:add:~
追加-:add:~
	追加の:additional
通知-:notify:~
進捗-:progress:~
遂行-:perform:~
達-:reach:~
形成-:form:~
表示中:showing:~
近似:approximation:~
集析:mining::~::マイニング
成長-:grow:~
指図-:instruct:~
選定-:~select:~
接触-:contact:~
印刷-:print:~
	得-:obtain:~
	通過-:passed through
	所属する:finds itself
	作成されたものであれ:however it is created
	-:rewind

	見える／見つかる:seen
	来ている:coming
	に加えて:in addition to
	成す:comprise
	転換される:turned into
	生じ:occur
	〜が生じたときは常に any occurrences of
	~MUL:multiply 〜
	され／し続ける:continue to
	のない:missing
	を閉じる:closing
	入る:enter する
	去る:gone
	含-:include
	含めて:including
	呼応して:in response to
	在る／無かった:present
	埋められ~fill-in
	始-:begin
	始め／:beginning
	属性を有さない:unadorned
	挙げられ:list
	散らばって:spread across
	来る:come
	〜に由来する:comes from
	棄てら:throw away
	留まって:stay して:~
	示す:say
	等し:equal
	結果になる／:end-up
	給-:feed:
	記す／示す／:say
	設け／箇所／置く:place
	流す:place into
	誤って置かれた:misplaced
	返す:return
	除く:except
	次の様になる:looks as follows
吹飛ば:吹き飛ば
	吹き飛ばす:blow away
	-:take
	かかって:taken
	~~現れる:stand
	置く:put
	push:put
	進める:advance する:~
	:doing
	去る／:leave
	何もしない:do nothing
	GOTO: jump to the step below labeled
	GOTO:jump to the
	GOTO:jump to the step labeled
	GOTO:jump back to the step labeled
	GOTO:return to
	GOTO:return to the step labeled
	GOTO:return to the step above labeled
	RET:stop this algorithm
	:came
	:didn’t
	:get ／got 〜
	:goes
	:having
	-:subject

	●未分類
源:source::~::ソース
閲覧文脈:browsing context::~
生成元:origin::~::オリジン
同一生成元:same-origin:~::同一オリジン
非同一生成元:cross-origin::~::クロスオリジン

種別:type::~
汎用:generic:~
構造:structure::~
段落:paragraph:~
空:empty:~
深さ:depth:~
範囲:range:~
終端:end:~

文脈:context::~
一時:temporary:~
一致:identical:~
位置:position:~
側:side:~

入力:input:~
出力:output:~

内容:content:~
動的:dynamic:~
即時:immediate:~
同期:synchronous:~

妥当:valid::~
	妥当でない:invalid:~
変数:variable:~
引数:argument:~

層:layer:~
攻撃路:attack-vector:~
接頭辞:prefix:~

新たな:new:~
既定の:default:~
時系列順:chronological:~


帯域外の:out-of-band:~
資源:resource::~:リソース
頁:page:::ページ


相対的:relative:~
種類:kind:~
等価:equivalent:~
	節:section
	下位節:subsection
絶対的:absolute:~
脆弱性:vulnerabilities:~


規則:rule:~
言語:language:~
記号:symbol:~
重複:duplicate:~
長さ:length:~
集合:set:~
順序:order:~

offset::::オフセット
遅い:slow な:~
	長時間:long time

	●指示語
所与の:given:~
	与え:give／	giving
内側:inside:~
内縁:inner:~
外側:outside:~
外来:foreign::~
外縁:outer:~
外部:external:~
現在:currently:~
現在の:current:~
	現:current:~
次n:next:次の
地点:point:~
最遠の:furthest:~
元の:original:~
	元々:originally

	この:this
	これらの:these
	すべての:all
	以外も混じっている:not all
	その:that
	そのような:such
	それら:they
	それらの:their
	それらの:those
	それらを:them
	それら自身:themselves
	自前の:own:~
	自身:itself
	主要な:primary:~
	一部:part of
	箇所:parts
	箇所がいくつかある:some parts
	他所:elsewhere／new location
	箇所:point
	指す:point to

	1 個の:single
	〜個:one／two／ three ／ four ／ five ／ six ／eight ／ nine
	何個かの:several
	周回:pass
	2 周回:two-pass
	多くの:many
	結果:result
	結果の:resulting
	もたらし:result in
	0:zero
	1 個 以上:one or more
	複数の:multiple

	〜個目:first／second／
	最初の:first
	最後の:last
	最後の:final
	前:before
	後:after
	後続-:follow
	後続して:subsequently
	後続の:subsequent
	直:immediate
	直前:right before
	末尾:inside, after its last child (if any)
	直前:immediately before
	の手前まで:but not including,
	以前の／前の／前:previous
	前述の:aforementioned
	尾部の:trailing
	-:downward
	先頭（ stack ）:first
	頭部の:leading
	末尾:the bottom
	末尾:bottommost
	先頭:the top
	先頭:topmost
	直前:just before
	直後:immediately after
	直前:immediately before
	直後:just after
	直後:immidiately followed-by
	より後にある（~stack内で）:lower
	直前にある（~stack内で）:immediately above

	ものは、何であれ:everything
	誰もが:everyone
	何であれ:whatever
	方:whichever
	いずれか早い方:whichever came first
	決して:never
	ことがある:ever
	以降のどこか:at any later
	ある種の／一定の:certain
	何ら:any
	他の:other
	別々の:separate
	別個の:distinct
	別の:another
	何か:something
	一部の／ある／いくつか／何らかの:some
	様々な:varying
	変わる:varies
	その他の:any other
	もう一つ:yet-another
	どこかへ／〜周りの:around
	の一つ:is in the list of
	単に／のみならず:just
	少なくとも:at least
	多量の:a lot of
	ずっと少ない:far fewer
	各:each
	少数:few
	上:above
	下:below
	合間:between
	その後，／次に:then
	さらに:more
	ほとんどの:most

	超え:beyond／greater than
	残りの部分:the rest
	もあるが:amongst
	とともに:along with
	全体を通して:throughout
	全体:whole
	まるごと:entirely
	まるごと:altogether
	同じ:same
	両者:both
	対応している:corresponding
	従って／従う:follow
	更なる:further
	等々:etc
	所:where
	最も近い:nearest
	最大:maximum
	様々な:various

	非:non
	そのままに:as-is
	またがって:across
	〜下:under
	当の:in question
	〜が指す:pointed to by
	まで:up to and including
	広い:wide
	広く:widely
	最も／:most
	連続する:consecutive
	まで:until
	類似する:similar
	同様に:similarly
	多い:often
	最もよく:most often
	通じて:over

	旧:old
	外へ:out of
	〜似の:〜-like
	~HTML-like

	後の:later
	今度は:this time
	し過ぎた:too long
	すでに:already
	どの時点であれ、:at any time
	もはや:no longer
	EQ:longer than the empty string
	常に:always
	それまでに:so far
	この時点:at this point
	まだ:yet
	この時点で、now
	最終的に:finally
	同時に:together
	再度／ここでも:again
	早期の／:earlier
	〜内で最初のもの:earliest
	当面の間:in the meantime
近過去:recent:~
	最も近過去のもの:youngest
	時系列順:least recently〜

	中途で:abrupt に
	たいしてない:have much
	近い:close
	対に:pair
	隣接する:adjacent
	分類-／-:categories
	-:category
	介:via
	通-／経る:through
	からなる:consisting
	〜で:manner
	ない／しない:nothing
	neither 〜 nor
	-:now
	-:thoroughly
	各組:per family
	だけ／neither
	一連の:series／s
	列／並び:sequence
	〜の代わりに:instead
	間:during
	:followed by
	~WHILE:repeatedly

</script>


<!--%HTML見本 -->
<script type="text/plain" id="_html_code_list">

</script>

<!--%style -->
<style type="text/css">

.bytes, 
.literal {
	color: #DD1111;
}

.domTree li {
	margin-top: 0;
	margin-bottom: 0;
	list-style-type: none;
	font-family: monospace0, monospace;
}
.domTree li::before {
	content: "└ ";
}
.domTree ul {
	padding-left: 2em;
}

.hex-value,
.parse-error,
.tokenizer-state,
.insertion-mode {
	font-family: sans-serif0, sans-serif;
}
.cp-name {
	color: gray;
}

.insertion-mode::after {
	content: " mode ";
	font-size: smaller;
	color: gray;
}

.tokenizer-state::after {
	content: " state ";
	font-size: smaller;
	color: gray;
}


#_dgm-model {
	contain: strict;
	position: relative;
	width: 480px;
	height: 400px;
	text-align: center;
	font-size: 16px;
	background: url(HTML-resources/parsing-model-overview.svg);
	background-repeat: no-repeat;
}

._dgm-model-node {
	position: absolute;
	width: 240px;
	height: 35px;
	line-height: 35px;
	top: 0;
	left: 0;
	white-space: nowrap;
	border: solid black 1px;
	background: linear-gradient(white, #AFA);
	box-shadow: 0.2em 0.2em 0.2em 0.2em rgba(0,0,0,0.4)
}
#_dgm-model > ._dgm-model-node:first-child,
#_dgm-model > ._dgm-model-node:last-child {
	background: linear-gradient(white, #AAF);
}

#_text-node-sample1 .html-code {
	margin-left: 0;
}
#_text-node-sample1 td {
	vertical-align: top;
}
</style>

<body>

<header id="head">
<a href="https://whatwg.org/" id="_WHATWG">WHATWG</a>
	<hgroup>
<h1>HTML 文書／素片の構文解析法 — <span lang="en-x-a0">Parsing HTML documents/fragments</span></h1>
<h2>Living Standard — 最終更新 2017 年 8 月 22 日</h2>
	</hgroup>

<details id="_trans-metadata"><summary></summary><p>
このページは、
<a href="https://whatwg.org/">WHATWG</a>
による，副題の日付け時点における
HTML 仕様の The HTML syntax 章の
<a id="_SPEC_URL">Parsing HTML documents 節, Parsing HTML fragments 節</a>
を日本語に翻訳したものです。
（公開：<time>2017-07-13</time> ）
</p></details>

</header>

<main id="MAIN" style="display:none;">

	<section id="syntax">
<h1 title="The HTML syntax">12. ~HTMLの構文</h1>

<p class="note">注記：
この節は、`~HTML~MIME型$とされた資源に対する規則のみを述べる。
~XML資源に対する規則は、
<a href="~HTMLxml#the-xhtml-syntax">~XML構文~節</a>
にて論じられる。
◎
This section only describes the rules for resources labeled with an HTML MIME type. Rules for XML resources are discussed in the section below entitled "The XML syntax".
</p>

		<section id="_conventions">
<h2>【この訳に固有の表記規約】</h2>

<p>
この訳の，~algoや定義の記述に利用されている各種記号（ ~LET, 此れ, ~IF, ~THROW, 等々）の意味や定義の詳細は、~SYMBOL_DEF_REFを~~参照されたし。
</p>

<p>
用語
`文書@
は `Document$I ~objの略記として用いられるが、構文解析の文脈においては、特に指定されない限り，当の`~HTML構文解析器$に結付けられているそれを指す（この頁に現れるほとんどのそれが該当する）。
~algoの中で宣言されずに現れる %構文解析器 は、この，`~HTML構文解析器$の~instanceを指す。
</p>

<p>
“%s ~APPEND %a ~APPEND %b ~APPEND …”
という表記は、
文字列 %s の末尾に後続の［
文字／文字列
］ %a, %b, …
を示された順に付加する演算を表す。
</p>

		</section>
		<section id="writing">
<h2 title="Writing HTML documents">12.1.  ~HTML文書の書き方</h2>

<p class="trans-note">【
この節の内容は、<a href="~HTMLwriting#writing" >別ページ</a>にて。
】</p>

		</section>
		<section id="parsing">
<h2 title="Parsing HTML documents">12.2. ~HTML文書の構文解析-法</h2>

<p><i>
この節が適用されるのは、［
~UA, ~data集析~tool, 適合性~検査器
］に限られる。
</i>
◎
This section only applies to user agents, data mining tools, and conformance checkers.
</p>

<p class="note">注記：
~XML文書を構文解析して~DOM木にするための規則は、次~節の`~XML構文$が受持つ。
◎
The rules for parsing XML documents into DOM trees are covered by the next section, entitled "The XML syntax".
</p>

<p>
~UAは、 `text/html$mt 資源から~DOM木を生成するときは，この節に述べる構文解析~規則を利用し~MUST。
これらの規則は，~~同時に
`~HTML構文解析器@
と称されるものも定義する。
◎
User agents must use the parsing rules described in this section to generate the DOM trees from text/html resources. Together, these rules define what is referred to as the HTML parser.
</p>

<div class="note">

<p>注記：
この仕様に述べる~HTML構文は、~SGMLや~XMLに近い類似性を~~保ち続けてはいるが，自前の構文解析~規則を備える別々の言語である。
◎
While the HTML syntax described in this specification bears a close resemblance to SGML and XML, it is a separate language with its own parsing rules.
</p>

<p>
~HTMLの早期の~versionのうち一部（特に HTML2 〜 HTML4）は、~SGMLに基づいていたため，~SGML構文解析~規則を利用していた。
しかしながら、~HTML文書に対し真の~SGML構文解析を実装したことがある~web~browserは，（あっても）少数に限られている。
歴史的に，~HTMLを厳格に~SGML~appとして取扱っていた~UAは、検証器に限られる。
その結果、検証器が主張していた 文書が持つべきとされる表現と，広く配備された~Web~browserが相互運用可能に実装していた表現とが異なっていたことによる混同は、何十年もの間，生産性を浪費していた。
したがって，この~versionの~HTMLでは、戻って，非~SGMLを基礎に置く。
◎
Some earlier versions of HTML (in particular from HTML2 to HTML4) were based on SGML and used SGML parsing rules. However, few (if any) web browsers ever implemented true SGML parsing for HTML documents; the only user agents to strictly handle HTML as an SGML application have historically been validators. The resulting confusion — with validators claiming documents to have one representation while widely deployed Web browsers interoperably implemented a different representation — has wasted decades of productivity. This version of HTML thus returns to a non-SGML basis.
</p>

<p>
~SGML~toolを著作~pipelineに利用することに関心がある作者には、~XML~toolと~XML直列化による~HTMLを利用することが奨励される。
◎
Authors interested in using SGML tools in their authoring pipeline are encouraged to use XML tools and the XML serialization of HTML.
</p>

</div>

<p>
適合性~検査器の目的においては、`~HTML構文$であると決定された資源は，`~HTML文書$とされる。
◎
For the purposes of conformance checkers, if a resource is determined to be in the HTML syntax, then it is an HTML document.
</p>

<p class="note" id="_notes-on-element-type">注記：
<a href="~HTMLINFRA#xml">~XMLとの互換性</a>
節にて定めたように、名前空間を明示的に指定していない`要素~型$への参照は、常に`~HTML名前空間$に属する要素を指す。
例えば，仕様にて “`menu$e 要素” と記された所では、その要素の
局所~名は `menu^l,
名前空間は `http://www.w3.org/1999/xhtml^l,
~interfaceは `HTMLMenuElement$I
になる。
可能な所では、そのような要素への参照には，その定義への~hyperlinkが付与される。
◎
As stated in the terminology section, references to element types that do not explicitly specify a namespace always refer to elements in the HTML namespace. For example, if the spec talks about "a menu element", then that is an element with the local name "menu", the namespace "http://www.w3.org/1999/xhtml", and the interface HTMLMenuElement. Where possible, references to such elements are hyperlinked to their definition.
</p>

			<section id="overview-of-the-parsing-model">
<h3 title="Overview of the parsing model">12.2.1. 構文解析~modelの概観</h3>

<figure style="float:right;">
<!-- parsing-model-overview.svg -->
<div id="_dgm-model">
<div class="_dgm-model-node" style="top:0px;">~network</div>
<div class="_dgm-model-node" style="top:70px;">~byte~stream~復号器</div>
<div class="_dgm-model-node" style="top:140px;">入力~stream前処理器</div>
<div class="_dgm-model-node" style="top:210px;">~tokenizer</div>
<div class="_dgm-model-node" style="top:280px;">木~構築</div>
<div class="_dgm-model-node" style="top:280px; left: 300px; width: 160px;">~script実行</div>
<code style="position:absolute; top:135px; left:280px; width: 160px;">document.write()</code>
<div class="_dgm-model-node" style="top:350px;">~DOM</div>
</div>
</figure>

<div style="display:inline-block; min-width:15em;"></div>

<p>
~HTML構文解析~処理-の入力は，一連の`~cp$からなる~streamであり、`~token化~段階$, `木~構築~段階$を順に通過し、その出力は`文書$になる。
◎
The input to the HTML parsing process consists of a stream of code points, which is passed through a tokenization stage followed by a tree construction stage. The output is a Document object.
</p>

<p class="note">注記：
実装は、`~scriptingを~supportしない$ならば`文書$を実際に作成する必要はないが、そのような事例であっても依然として，~DOM木は，この仕様の残りの部分のための~modelとして利用される。
◎
Implementations that do not support scripting do not have to actually create a DOM Document object, but the DOM tree in such cases is still used as the model for the rest of the specification.
</p>

<p>
~token化~段階で取扱われる~dataは、共通的な事例では~networkから来るが，~UA内で走っている
<a href="~HTML5/dynamic-markup-insertion.html#dynamic-markup-insertion">~scriptから </a>
— 例えば `document.write()$m ~APIを利用して —
来ることもある。
◎
In the common case, the data handled by the tokenization stage comes from the network, but it can also come from script running in the user agent, e.g. using the document.write() API.
</p>

<p id="nestedParsing">
~tokenizer段階も, 木~構築~段階も，とり得る状態の集合は 1 つだけであるが、木~構築~段階は再入的である
— すなわち，木~構築~段階が ある~tokenを取扱っている間に、~tokenizerが再開され，その~tokenの処理が完了する前に別の~tokenを更に発して処理させることもある。
◎
There is only one set of states for the tokenizer stage and the tree construction stage, but the tree construction stage is reentrant, meaning that while the tree construction stage is handling one token, the tokenizer might be resumed, causing further tokens to be emitted and processed before the first token's processing is complete.
</p>

<div class="example">

<p>
次の例では、
`script^l 終了tag~tokenを取扱っている間に、 `p^l 開始tag~tokenを取扱うため，木~構築~段階が~callされることになる：
◎
In the following example, the tree construction stage will be called upon to handle a "p" start tag token while handling the "script" end tag token:
</p>

<pre class="html-code">
...
&lt;script&gt;

document.write('&lt;p&gt;');
&lt;/script&gt;
...
</pre>

</div>

<div class="p">
<p>
これらの事例を取扱うため、各
構文解析器は，次のものを持つ：
</p>

<dl class="def-list">
	<dt>`~script入子~level@</dt>
	<dd>
初期~時には 0 に設定され~MUST。
</dd>

	<dt>`一時停止~flag@</dt>
	<dd>
初期~時には ~F に設定され~MUST。
</dd>
</dl>

◎
To handle these cases, parsers have a script nesting level, which must be initially set to zero, and a parser pause flag, which must be initially set to false.
</div>

			</section>
			<section id="parse-errors">
<h3 title="Parse errors">12.2.2. ~perror</h3>

<p>
この仕様は、~HTML文書に対する構文解析~規則, および それが構文的に正しいか否かを定義する。
構文解析~algoにおける一定の箇所では、`~perror$と記される。
~perrorによる~errorの取扱いは，きちんと定義されるが（処理~規則は，この仕様~全体を通して述べる）、~UAは，~HTML文書を構文解析している間に遭遇した`~perror$のうち，この仕様に述べる規則を適用したいと望まない最初の所で`構文解析器を中止-$しても~MAY。
◎
This specification defines the parsing rules for HTML documents, whether they are syntactically correct or not. Certain points in the parsing algorithm are said to be parse errors. The error handling for parse errors is well-defined (that's the processing rules described throughout this specification), but user agents, while parsing an HTML document, may abort the parser at the first parse error that they encounter for which they do not wish to apply the rules described in this specification.
</p>

<div class="p">
<p>
適合性~検査器は、文書~内に~perrorを生じさせる条件が：
</p>
<ul ><li>存在しない場合、利用者に~perrorを報告しては~MUST_NOT。
</li><li>存在する場合、それらのうち 1 個~以上は利用者に報告し~MUST。
</li><li>複数個~存在する場合、それらのうち 2 個~以上を利用者に報告して~MAY。
</li></ul>

◎
Conformance checkers must report at least one parse error condition to the user if one or more parse error conditions exist in the document and must not report parse error conditions if none exist in the document. Conformance checkers may report more than one parse error condition if more than one parse error condition exists in the document.
</div>

<p class="note">注記：
~perrorは、~HTML<em>構文</em>に限られる~errorである。
適合性~検査器は、~perrorを検査することに加え，［
文書は，この仕様に述べる他のすべての適合性~要件を順守するかどうか
］も検証yすることになる。
◎
Parse errors are only errors with the syntax of HTML. In addition to checking for parse errors, conformance checkers will also verify that the document obeys all the other conformance requirements described in this specification.
</p>

<p>
一部の~perrorには、以下に概説される専用の~codeがある
— 適合性~検査器は，報告-内にそれらを利用するべきである。
◎
Some parse errors have dedicated codes outlined in the table below that should be used by conformance checkers in reports.
</p>

<div class="p">
<p>
<em >以下の~listにおける~errorの記述は、規範的でない</em>
— 各~errorにおいては：
</p>

<ul ><li>“誘因” と記される項目に、構文解析器がどこで何に遭遇したとき，当の~errorが生じるかを述べる。
</li><li>“例” と記される項目に、当の~errorを生じさせる~code例を示す。
</li><li>“処置” と記される項目に、遭遇した~errorを構文解析器がどう取扱うかを述べる。
</li></ul>

<p class="trans-note">【
これらの項目名の付与は、この訳による。
それに伴い、これらの~errorは
— 原文では~table~markupで与えられているが —
~listによる~markupで与えることにする。
】</p>

◎
Error descriptions in the table below are non-normative.
◎
Code | Description
</div>

<dl>

	<dt>`abrupt-closing-of-empty-comment@pE</dt>
	<dd>誘因：
中途で `003E^U で閉じられた空`~comment$に遭遇した。
◎
This error occurs if the parser encounters an empty comment that is abruptly closed by a U+003E (&gt;) code point＼
</dd>
	<dd>例：
`&lt;!--&gt;^c ／ `&lt;!---&gt;^c
（これら以外にない）
◎
(i.e., &lt;!--&gt; or &lt;!---&gt;).＼
</dd>
	<dd>処置：
当の~commentは正しく閉じられたかのように挙動する。
◎
The parser behaves as if the comment is closed correctly.
</dd>

	<dt>`abrupt-doctype-public-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$の~publicID内で `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point in the DOCTYPE public identifier＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC "foo&gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC "foo&gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`abrupt-doctype-system-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$の~systemID内で `003E^U に遭遇した
◎
This error occurs if the parser encounters a U+003E (&gt;) code point in the DOCTYPE system identifier＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "foo&gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "foo&gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`absence-of-digits-in-numeric-character-reference@pE</dt>
	<dd>誘因：
数字を包含しない，数的な`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that doesn't contain any digits＼
</dd>
	<dd>例：
`&amp;#qux;^c
◎
(e.g., &amp;#qux;).＼
</dd>
	<dd>処置：
そのような文字~参照は、解決しない。
◎
In this case the parser doesn't resolve the character reference.
</dd>

	<dt>`cdata-in-html-content@pE</dt>
	<dd>誘因：
外来~内容（~SVG／~MathML）の外側で，`~CDATAsec$に遭遇した。
◎
This error occurs if the parser encounters a CDATA section outside of foreign content (SVG or MathML).＼
</dd>
	<dd>処置：
そのような~CDATAsecは、~commentとして扱う（頭部の `[CDATA[^l と尾部の `]]^l も含めて）。
◎
The parser treats such CDATA sections (including leading "[CDATA[" and trailing "]]" strings) as comments.
</dd>

	<dt>`character-reference-outside-unicode-range@pE</dt>
	<dd>誘因：
妥当な~Unicode範囲を超える`~cp$を参照する，数的な`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a code point that is greater than the valid Unicode range.＼
</dd>
	<dd>処置：
そのような文字~参照は、 `FFFD^U に解決する。
◎
The parser resolves such a character reference to a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`control-character-in-input-stream@pE</dt>
	<dd>誘因：
`入力~stream$は、次の`~cp$を包含している
⇒
［
`~ASCII空白$／ `0000^U
］以外の`制御文字$
◎
This error occurs if the input stream contains a control code point that is not ASCII whitespace or U+0000 NULL.＼
</dd>
	<dd>処置：
そのような`~cp$は，そのままに構文解析され、通例的には
— すなわち、構文解析~規則が他に制約を適用しない所では —
~DOMに流し込まれる。
◎
Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.
</dd>

	<dt>`control-character-reference@pE</dt>
	<dd>誘因：
次の`~cp$を参照する，数的な`文字~参照$に遭遇した
⇒
［
`~ASCII空白$ ／ `000D^U ／ `0000^U 
］以外の`制御文字$
◎
This error occurs if the parser encounters a numeric character reference that references a control code point that is not ASCII whitespace, a U+000D CARRIAGE RETURN, or U+0000 NULL.＼
</dd>
	<dd>処置：
そのような文字~参照は、そのままに解決する
— `数的な文字~参照~終端$stに則って置換されるような~C1制御文字~参照を除いて。
◎
The parser resolves such character references as-is except C1 control references that are replaced according to the numeric character reference end state.
</dd>

	<dt>`end-tag-with-attributes@pE</dt>
	<dd>誘因：
`属性$を伴う`終了tag$に遭遇した。
◎
This error occurs if the parser encounters an end tag with attributes.＼
</dd>
	<dd>処置：
終了tag内の属性は、完全に無視される
— ~DOMに流し込まれることはない。
◎
Attributes in end tags are completely ignored and do not make their way into the DOM.
</dd>

	<dt>`duplicate-attribute@pE</dt>
	<dd>誘因：
同じ~tag内にすでにある属性と同じ名前の`属性$に遭遇した。
◎
This error occurs if the parser encounters an attribute in a tag that already has an attribute with the same name.＼
</dd>
	<dd>処置：
そのような重複する属性は、無視する。
◎
The parser ignores all such duplicate occurrences of the attribute.
</dd>

	<dt>`end-tag-with-trailing-solidus@pE</dt>
	<dd>誘因：
`終了tag$を閉じる `003E^U が期待される所で，
`002F^U に遭遇した。
◎
This error occurs if the parser encounters an end tag that has a U+002F (/) code point right before the closing U+003E (&gt;) code point＼
</dd>
	<dd>例：
`&lt;/div/&gt;^c 
◎
(e.g., &lt;/div/&gt;).＼
</dd>
	<dd>処置：
そのような~tagは、定例の終了tagとして扱う。
◎
Such a tag is treated as a regular end tag.
</dd>

	<dt>`eof-before-tag-name@pE</dt>
	<dd>誘因：
~tag名が期待される所で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream where a tag name is expected.＼
</dd>
	<dd>処置：
~tagの始まり（すなわち，
`開始tag$に対しては `&lt;^l ／
`終了tag$に対しては `&lt;/^l
）を~text内容として扱う。
◎
In this case the parser treats the beginning of a start tag (i.e., &lt;) or an end tag (i.e., &lt;/) as text content.
</dd>

	<dt>`eof-in-cdata@pE</dt>
	<dd>誘因：
`~CDATAsec$内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a CDATA section.＼
</dd>
	<dd>処置：
そのような~CDATAsecは、入力~streamの終端の直前で閉じられたかのように扱う。
◎
The parser treats such CDATA sections as if they are closed immediately before the end of the input stream.
</dd>

	<dt>`eof-in-comment@pE</dt>
	<dd>誘因：
`~comment$内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a comment.＼
</dd>
	<dd>処置：
そのような~commentは、入力~streamの終端の直前で閉じられたかのように扱う。
◎
The parser treats such comments as if they are closed immediately before the end of the input stream.
</dd>

	<dt>`eof-in-doctype@pE</dt>
	<dd>誘因：
`~DOCTYPE$内で，入力~streamの終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a DOCTYPE.＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`eof-in-script-html-comment-like-text@pE</dt>
	<dd>誘因：
`script$e 要素~内容の内側の`~comment$を真似る~text内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in text that resembles an HTML comment inside script element content＼
</dd>
	<dd>例：
`&lt;script&gt;&lt;!-- foo^c
◎
(e.g., &lt;script&gt;&lt;!-- foo).
</dd>
	<dd>処置：
【次の注記。】
</dd>
	<dd class="note">注記：
`script$e 要素~内の~HTML~commentを真似る構文的~構造は、~text内容として構文解析される。
それらは［
~script用~言語に特有の構文的~構造の一部を成す／
~HTML似の~commentとして扱われる
］こともある
— ~script用~言語がそれらを~supportするならば（例：~HTML似の~comment用の構文解析~規則は、~JS仕様の Annex B にて見出せる）。
この~errorを生じさせる共通的な理由は、
<a href="~HEscripting#restrictions-for-contents-of-script-elements">`script^e 要素の内容に課される制約</a>
に対する違反である。
`JAVASCRIPT$r
◎
Syntactic structures that resemble HTML comments in script elements are parsed as text content. They can be a part of a scripting language-specific syntactic structure or be treated as an HTML-like comment, if the scripting language supports them (e.g., parsing rules for HTML-like comments can be found in Annex B of the JavaScript specification). The common reason for this error is a violation of the restrictions for contents of script elements. [JAVASCRIPT]
</dd>

	<dt>`eof-in-tag@pE</dt>
	<dd>誘因：
［
`開始tag$／`終了tag$
］内で，`入力~stream$の終端に遭遇した。
◎
This error occurs if the parser encounters the end of the input stream in a start tag or an end tag＼
</dd>
	<dd>例：
`&lt;div id=^c 
◎
(e.g., &lt;div id=).＼
</dd>
	<dd>処置：
そのような~tagは、完全に無視する。
◎
Such a tag is completely ignored.
</dd>

	<dt>`incorrectly-closed-comment@pE</dt>
	<dd>誘因：
`--!&gt;^l `~cp$列により閉じられた`~comment$に遭遇した。
◎
This error occurs if the parser encounters a comment that is closed by the "--!&gt;" code point sequence.＼
</dd>
	<dd>処置：
そのような~commentは、
`--&gt;^l ~cp列により正しく閉じられたかのように扱う。
◎
The parser treats such comments as if they are correctly closed by the "--&gt;" code point sequence.
</dd>

	<dt>`incorrectly-opened-comment@pE</dt>
	<dd>誘因：
次のいずれも満たさない`~cp$列 `&lt;!^l に遭遇した：
<ul ><li>直後に 2 個の `002D^U が続く
</li><li>`~DOCTYPE$を開始させる
</li><li>`~CDATAsec$を開始させる
</li></ul>

◎
This error occurs if the parser encounters the "&lt;!" code point sequence that is not immidiately followed by two U+002D (-) code points and that is not the start of a DOCTYPE or a CDATA section.＼
</dd>
	<dd>処置：
そのような~cp列に後続する［
最初の `003E^U （無ければ `入力~stream$の終端）
］までのすべての内容を，~commentとして扱う。
◎
All content that follows the "&lt;!" code point sequence up to a U+003E (&gt;) code point (if present) or to the end of the input stream is treated as a comment.
</dd>
	<dd class="note">注記：
例えば，~HTML内で~XML~markup宣言（例：
`&lt;!ELEMENT br EMPTY&gt;^c
）を利用した場合、この~errorが生じる。
◎
One possible cause of this error is using an XML markup declaration (e.g., &lt;!ELEMENT br EMPTY&gt;) in HTML.
</dd>

	<dt>`invalid-character-sequence-after-doctype-name@pE</dt>
	<dd>誘因：
`~DOCTYPE$ の名前の後にて，［
`PUBLIC^l ／ `SYSTEM^l
］~keyword以外の`~cp$列に遭遇した。
◎
This error occurs if the parser encounters any code point sequence other than "PUBLIC" and "SYSTEM" keywords after a DOCTYPE name.＼
</dd>
	<dd>処置：
後続する［
~publicID／~systemID
］は無視した上で、~DOCTYPEが文書の前置きとして正しく設置されているならば，［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, the parser ignores any following public or system identifiers, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.
</dd>

	<dt>`invalid-first-character-of-tag-name@pE</dt>
	<dd>誘因：
［
`開始tag$／`終了tag$
］の名前の最初の~cpが期待される所で，`~ASCII英字$でない`~cp$に遭遇した。
◎
This error occurs if the parser encounters a code point that is not an ASCII alpha where first code point of a start tag name or an end tag name is expected.＼
</dd>
	<dd>処置：
開始tagに対しては、名前に先行する `003C^U を~text内容として扱い，後続する内容は~markupとして扱う。
終了tagに対しては、そのような~cpから［
それに後続する最初の `003E^U （無ければ `入力~stream$の終端）
］までのすべての内容を，~commentとして扱う。
◎
If a start tag was expected such code point and a preceding U+003C (&lt;) is treated as text content, and all content that follows is treated as markup. Whereas, if an end tag was expected, such code point and all content that follows up to a U+003E (&gt;) code point (if present) or to the end of the input stream is treated as a comment.
</dd>
	<dd class="example">
<p>
例えば次の~markupを考える：
◎
For example, consider the following markup:
</p>

<pre class="html-code">
&lt;42&gt;&lt;/42&gt;
</pre>

<p>
これは、次のように構文解析されることになる：
◎
This will be parsed into:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
		</li><li>`body$e
			<ul><li class="t3">`#text$: <span>&lt;42&gt;</span>
			</li><li>`#comment$: <span>42</span>
			</li></ul>
		</li></ul>
	</li></ul>
</dd>

	<dd class="note">注記：
~tag名の最初の~cpは，`~ASCII英字$に制限される一方、後続の~cpには（`~ASCII数字$を含め）広~範囲の~cpが許容される。
◎
While the first code point of a tag name is limited to an ASCII alpha, a wide range of code points (including ASCII digits) is allowed in subsequent positions.
</dd>

	<dt>`missing-attribute-value@pE</dt>
	<dd>誘因：
`属性$値が期待される所で，`003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where an attribute value is expected＼
</dd>
	<dd>例：
`&lt;div id=&gt;^c 
◎
(e.g., &lt;div id=&gt;).
</dd>
	<dd>処置：
そのような属性の値は、空であるものと扱う。
◎
The parser treats the attribute as having an empty value.
</dd>

	<dt>`missing-doctype-name@pE</dt>
	<dd>誘因：
名前のない`~DOCTYPE$に遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE that is missing a name＼
</dd>
	<dd>例：
`&lt;!DOCTYPE&gt;^c 
◎
(e.g., &lt;!DOCTYPE&gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`missing-doctype-public-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$ ~publicIDの開始-が期待される所で， `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where start of the DOCTYPE public identifier is expected＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC &gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC &gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`missing-doctype-system-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$ ~systemIDの開始-が期待される所で， `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where start of the DOCTYPE system identifier is expected＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html SYSTEM &gt;^c
◎
(e.g., &lt;!DOCTYPE html SYSTEM &gt;).＼
</dd>
	<dd>処置：
~DOCTYPEが文書の前置きとして正しく設置されているならば、［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, if the DOCTYPE is correctly placed as a document preamble, the parser sets the Document to quirks mode.
</dd>

	<dt>`missing-end-tag-name@pE</dt>
	<dd>誘因：
`終了tag$の名前が期待される所で， `003E^U に遭遇した。
◎
This error occurs if the parser encounters a U+003E (&gt;) code point where an end tag name is expected,＼
</dd>
	<dd>例：
`&lt;/&gt;^c （これ以外にない）
◎
i.e., &lt;/&gt;.＼
</dd>
	<dd>処置：
~cp列 `&lt;/&gt;^l 全体を、完全に無視する。
◎
The parser completely ignores whole "&lt;/&gt;" code point sequence.
</dd>

	<dt>`missing-quote-before-doctype-public-identifier@pE</dt>
	<dd>誘因：
引用符が先行していない
`~DOCTYPE$ ~publicIDに遭遇した。
◎
This error occurs if the parser encounters the DOCTYPE public identifier that is not preceded by a quote＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01//EN"&gt;^c
◎
(e.g., &lt;!DOCTYPE html PUBLIC -//W3C//DTD HTML 4.01//EN"&gt;).＼
</dd>
	<dd>処置：
そのような~publicIDは無視した上で、~DOCTYPEが文書の前置きとして正しく設置されているならば，［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, the parser ignores the public identifier, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.
</dd>

	<dt>`missing-quote-before-doctype-system-identifier@pE</dt>
	<dd>誘因：
引用符が先行していない `~DOCTYPE$ ~systemIDに遭遇した。
◎
This error occurs if the parser encounters the DOCTYPE system identifier that is not preceded by a quote＼
</dd>
	<dd>例：
`&lt;!DOCTYPE html SYSTEM http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;^c
◎
(e.g., &lt;!DOCTYPE html SYSTEM http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;).＼
</dd>
	<dd>処置：
そのような~systemIDは無視した上で、~DOCTYPEが文書の前置きとして正しく設置されているならば，［
`文書$の`~mode$doc ~SET `quirks^l
］にする。
◎
In such a case, the parser ignores the system identifier, and if the DOCTYPE is correctly placed as a document preamble, sets the Document to quirks mode.
</dd>

	<dt>`missing-semicolon-after-character-reference@pE</dt>
	<dd>誘因：
`003B^U で終了されない`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a character reference that is not terminated by a U+003B (;) code point.＼
</dd>
	<dd>処置：
通例的には、文字~参照は `003B^U で終了されたかのように挙動する。
しかしながら，多義的になる事例もあり、そこでは，後続の~cpを文字~参照~内に含める。
◎
Usually the parser behaves as if character reference is terminated by the U+003B (;) code point; however, there are some ambiguous cases in which the parser includes subsequent code points in the character reference.
</dd>
	<dd class="example">
例えば
`&amp;not;in^c
は
`¬in^l に構文解析されることになる一方で
`&amp;notin^c
は `∉^l に構文解析されることになる。
◎
For example, &amp;not;in will be parsed as "¬in" whereas &amp;notin will be parsed as "∉".
</dd>

	<dt>`missing-whitespace-after-doctype-public-keyword@pE</dt>
	<dd>誘因：
`~DOCTYPE$における `PUBLIC^l ~keywordの後に，`~ASCII空白$で分離されていない~publicIDに遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose "PUBLIC" keyword and public identifier are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-after-doctype-system-keyword@pE</dt>
	<dd>誘因：
`~DOCTYPE$における `SYSTEM^l ~keywordの後に，`~ASCII空白$で分離されていない~systemIDに遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose "SYSTEM" keyword and system identifier are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-before-doctype-name@pE</dt>
	<dd>誘因：
`~DOCTYPE$における `DOCTYPE^l ~keywordの後に，`~ASCII空白$で分離されていない名前に遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose "DOCTYPE" keyword and name are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-between-attributes@pE</dt>
	<dd>誘因：
`~ASCII空白$で分離されてない`属性$たちに遭遇した。
◎
This error occurs if the parser encounters attributes that are not separated by ASCII whitespace＼
</dd>
	<dd>例：
`&lt;div id="foo"class="bar"&gt;^c
◎
(e.g., &lt;div id="foo"class="bar"&gt;).＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`missing-whitespace-between-doctype-public-and-system-identifiers@pE</dt>
	<dd>誘因：
`~DOCTYPE$において，`~ASCII空白$で分離されてない~publicIDと~systemIDに遭遇した。
◎
This error occurs if the parser encounters a DOCTYPE whose public and system identifiers are not separated by ASCII whitespace.＼
</dd>
	<dd>処置：
~ASCII空白が在るかのように挙動する。
◎
In this case the parser behaves as if ASCII whitespace is present.
</dd>

	<dt>`nested-comment@pE</dt>
	<dd>誘因：
入子の`~comment$に遭遇した。
◎
This error occurs if the parser encounters a nested comment＼
</dd>
	<dd>例：
`&lt;!-- &lt;!-- 入子の~comment --&gt; --&gt;^c
◎
(e.g., &lt;!-- &lt;!-- nested --&gt; --&gt;).＼
</dd>
	<dd>処置：
そのような~commentは，最初に生じた `--&gt;^l `~cp$列で閉じる
— 後続するものは、何であれ~markupとして扱われることになる。
◎
Such a comment will be closed by the first occuring "--&gt;" code point sequence and everything that follows will be treated as markup.
</dd>

	<dt>`noncharacter-character-reference@pE</dt>
	<dd>誘因：
`非文字$を参照する，数的な`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a noncharacter.＼
</dd>
	<dd>処置：
そのような文字~参照は、そのままに解決する。
◎
The parser resolves such character references as-is.
</dd>

	<dt>`noncharacter-in-input-stream@pE</dt>
	<dd>誘因：
`入力~stream$が`非文字$を包含している。
◎
This error occurs if the input stream contains a noncharacter.＼
</dd>
	<dd>処置：
そのような`~cp$は，そのままに構文解析され、通例的には
— すなわち、構文解析~規則が他に制約を適用しない所では —
~DOMに流し込まれる。
◎
Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.
</dd>

	<dt>`non-void-html-element-start-tag-with-trailing-solidus@pE</dt>
	<dd>誘因：［
次のいずれにも該当しない要素
］の`開始tag$を閉じる `003E^U の直前にて，
`002F^U に遭遇した
⇒
`~void要素$／
外来~内容の一部である要素（すなわち，~SVG／~MathML要素）
◎
This error occurs if the parser encounters a start tag for an element that is not in the list of void elements or is not a part of foreign content (i.e., not an SVG or MathML element) that has a U+002F (/) code point right before the closing U+003E (&gt;) code point.＼
</dd>
	<dd>処置：
この `002F^U は無かったかのように挙動する。
◎
The parser behaves as if the U+002F (/) is not present.
</dd>
	<dd class="example">
<p>
例えば次の~markupを考える：
◎
For example, consider the following markup:
</p>

<pre class="html-code">
&lt;div/&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;
</pre>

<p>
これは、次のように構文解析されることになる：
◎
This will be parsed into:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`div$e
			<ul><li>`span$e
			</li><li>`span$e
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

	</dd>
	<dd class="note">注記：
開始tagの名前~内の尾部に `002F^U を利用できるのは
自己閉じ~tagを指定する外来~内容~内に限られる。
（~HTMLには自己閉じ~tagは存在しない。）
それは，`~void要素$にも許容されるが、この事例では，何ら効果はない。
◎
The trailing U+002F (/) in a start tag name can be used only in foreign content to specify self-closing tags. (Self-closing tags don't exist in HTML.) It is also allowed for void elements, but doesn't have any effect in this case.
</dd>

	<dt>`null-character-reference@pE</dt>
	<dd>誘因：
`0000^U を参照する，数的な`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a U+0000 NULL code point.＼
</dd>
	<dd>処置：
そのような文字~参照は、 `FFFD^U に解決する。
◎
The parser resolves such character references to a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`surrogate-character-reference@pE</dt>
	<dd>誘因：
`~surrogate$を参照する，数的な`文字~参照$に遭遇した。
◎
This error occurs if the parser encounters a numeric character reference that references a surrogate.＼
</dd>
	<dd>処置：
そのような文字~参照は、 `FFFD^U に解決する。
◎
The parser resolves such character references to a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`surrogate-in-input-stream@pE</dt>
	<dd>誘因：
`入力~stream$は`~surrogate$を包含している。
◎
This error occurs if the input stream contains a surrogate.＼
</dd>
	<dd>処置：
そのような`~cp$は，そのままに構文解析され、通例的には
— すなわち、構文解析~規則が他に制約を適用しない所では —
~DOMに流し込まれる。
◎
Such code points are parsed as-is and usually, where parsing rules don't apply any additional restrictions, make their way into the DOM.
</dd>
	<dd class="note">注記：
~surrogateが入力~streamの中に生じるのは、
`document.write()$m などの~script~APIを介した場合に限られる。
◎
Surrogates can only find their way into the input stream via script APIs such as document.write().
</dd>

	<dt>`unexpected-character-after-doctype-system-identifier@pE</dt>
	<dd>誘因：
`~DOCTYPE$における~systemIDの後にて，次に挙げるもの以外の`~cp$に遭遇した
⇒
`~ASCII空白$ ／
~DOCTYPEを閉じる `003E^U
◎
This error occurs if the parser encounters any code points other than ASCII whitespace or closing U+003E (&gt;) after the DOCTYPE system identifier.＼
</dd>
	<dd>処置：
そのような~cpは、無視する。
◎
The parser ignores these code points.
</dd>

	<dt>`unexpected-character-in-attribute-name@pE</dt>
	<dd>誘因：
`属性~名$内で，次のいずれかの`~cp$に遭遇した
⇒
`0022^U ／ `0027^U ／ `003C^U
◎
This error occurs if the parser encounters a U+0022 ("), U+0027 ('), or U+003C (&lt;) code point in an attribute name.＼
</dd>
	<dd>処置：
そのような~cpは、属性~名に含ませる。
◎
The parser includes such code points in the attribute name.
</dd>
	<dd class="note">注記：
この~errorを誘発する~cpは、通例的には別の構文的~構成子の一部である
— 属性~名~周りの誤記の表れを示すものなど。
◎
Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute name.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

<pre class="html-code">
&lt;div foo&lt;div&gt;
</pre>

<p>
`foo^c の後に `003E^U を忘れたことに因り、構文解析器は
この~markupを `foo&lt;div^l 属性を伴う 1 個の `div$e 要素として扱う。
◎
Due to a forgotten U+003E (&gt;) code point after foo the parser treats this markup as a single div element with a "foo&lt;div" attribute.
</p>

	</dd>
	<dd class="example">
<p>
この~errorの別の例として、次の~markupを考える：
◎
As another example of this error, consider the following markup:
</p>

<pre class="html-code">
&lt;div id'bar'&gt;
</pre>

<p>
属性~名と値の合間に `003D^U を忘れたことに因り、構文解析器は，
この~markupを［
値が空にされた属性 `id'bar'^l
］を伴う `div$e 要素として扱う。
◎
Due to a forgotten U+003D (=) code point between an attribute name and value the parser treats this markup as a div element with the attribute "id'bar'" that has an empty value.
</p>
	</dd>

	<dt>`unexpected-character-in-unquoted-attribute-value@pE</dt>
	<dd>誘因：
引用符無しの`属性~値$内で，次のいずれかの`~cp$に遭遇した
⇒
`0022^U ／  `0027^U ／ `003C^U ／  `003D^U ／ `0060^U
◎
This error occurs if the parser encounters a U+0022 ("), U+0027 ('), U+003C (&lt;), U+003D (=), or U+0060 (`) code point in an unquoted attribute value.＼
</dd>
	<dd>処置：
そのような~cpは、属性~値に含ませる。
◎
The parser includes such code points in the attribute value.
</dd>
	<dd class="note">注記：
この~errorを誘発する~cpは、通例的には別の構文的~構成子の一部である
— 属性~値~周りの誤記の表れを示すものなど。
◎
Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute value.
</dd>
	<dd class="note">注記：
 `0060^U は、この~errorを誘発する~cpの一つである
— ある種の旧来の~UAは、それを引用符として扱うので。
◎
U+0060 (`) is in the list of code points that trigger this error because certain legacy user agents treat it as a quote.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

<pre class="html-code">
&lt;div foo=b'ar'&gt;
</pre>

<p>
誤って置かれた `0027^U に因り、構文解析器は `foo^l 属性の値を `b'ar'^l に設定する。
◎
Due to a misplaced U+0027 (') code point the parser sets the value of the "foo" attribute to "b'ar'".
</p>
	</dd>

	<dt>`unexpected-equals-sign-before-attribute-name@pE</dt>
	<dd>誘因：
属性~名の前で `003D^U に遭遇した。
◎
This error occurs if the parser encounters a U+003D (=) code point before an attribute name.＼
</dd>
	<dd>処置：
`003D^U を属性~名の最初の~cpとして扱う。
◎
In this case the parser treats U+003D (=) as the first code point of the attribute name.
</dd>
	<dd class="note">注記：
この~errorに共通的な理由は、属性~名を忘れたときである。
◎
The common reason for this error is a forgotten attribute name.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

<pre class="html-code">
&lt;div foo="bar" ="baz"&gt;
</pre>

<p>
属性~名を忘れたことに因り、構文解析器は，この~markupを
2 個の属性
— 値 `bar^lにされた `foo^l 属性, 値は空にされた `="baz"^l 属性 —
を伴う `div$e 要素として扱う。 
◎
Due to a forgotten attribute name the parser treats this markup as a div element with two attributes: a "foo" attribute with a "bar" value and a "="baz"" attribute with an empty value.
</p>
	</dd>

	<dt>`unexpected-null-character@pE</dt>
	<dd>誘因：
`入力~stream$内の一定の位置で，
`0000^U に遭遇した。
◎
This error occurs if the parser encounters a U+0000 NULL code point in the input stream in certain positions.＼
</dd>
	<dd>処置：
一般に，そのような~cpは完全に無視されるが、~security上の理由から `FFFD^U に置換されることもある。
◎
In general, such code points are either completely ignored or, for security reasons, replaced with a U+FFFD REPLACEMENT CHARACTER.
</dd>

	<dt>`unexpected-question-mark-instead-of-tag-name@pE</dt>
	<dd>誘因：
`開始tag$の名前の最初の~cpが期待される所で， `003F^U に遭遇した。
◎
This error occurs if the parser encounters a U+003F (?) code point where first code point of a start tag name is expected.＼
</dd>
	<dd>処置：
`003F^U から［
それに後続する最初の `003E^U （無ければ `入力~stream$の終端）
］までのすべての内容を，~commentとして扱う。
◎
The U+003F (?) and all content that follows up to a U+003E (&gt;) code point (if present) or to the end of the input stream is treated as a comment.
</dd>
	<dd class="example">
<p>
例えば，次の~markupを考える：
◎
For example, consider the following markup:
</p>

<pre class="html-code">
&lt;?xml-stylesheet type="text/css" href="style.css"?&gt;
</pre>

<p>
これは、次のように構文解析されることになる：
◎
This will be parsed into:
</p>

<ul class="domTree"><li>`#comment$: <span>?xml-stylesheet type="text/css" href="style.css"?</span>
</li><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
	</li></ul>
</li></ul>
</dd>
	<dd class="note">注記：
この~errorに共通的な理由は、~HTML内で，~XML処理命令（例：
`&lt;?xml-stylesheet type="text/css" href="style.css"?&gt;^c
） ／
~XML宣言（例：
`&lt;?xml version="1.0" encoding="UTF-8" ?&gt;^c
）が利用されているときである。
◎
The common reason for this error is an XML processing instruction (e.g., &lt;?xml-stylesheet type="text/css" href="style.css"?&gt;) or an XML declaration (e.g., &lt;?xml version="1.0" encoding="UTF-8" ?&gt;) being used in HTML.
</dd>

	<dt>`unexpected-solidus-in-tag@pE</dt>
	<dd>誘因：
ある~tag内で， `002F^U に遭遇したが、［
それは引用符~付きの`属性$値の一部でない
］~AND［
その直後の~cpは `003E^U でない
］。
◎
This error occurs if the parser encounters a U+002F (/) code point that is not a part of a quoted attribute value and not immediately followed by a U+003E (&gt;) code point in a tag＼
</dd>
	<dd>例：
`&lt;div / id="foo"&gt;^c
◎
(e.g., &lt;div / id="foo"&gt;).＼
</dd>
	<dd>処置：
`~ASCII空白$に遭遇したかのように挙動する。
◎
In this case the parser behaves as if it encountered ASCII whitespace.
</dd>

	<dt>`unknown-named-character-reference@pE</dt>
	<dd>誘因：
`多義的amp$に遭遇した。
◎
This error occurs if the parser encounters an ambiguous ampersand.＼
</dd>
	<dd>処置：
そのような`文字~参照$は、解決しない。
◎
In this case the parser doesn't resolve the character reference.
</dd>
</dl>

			</section>
			<section id="the-input-byte-stream">
<h3 title="The input byte stream">12.2.3. 入力~byte~stream</h3>

<p>
~token化~段階への入力を成す~cp~streamは、~UAからは初期~時には~byte列~streamとして見えることになる（概して，~networkを通じて, または局所~file~systemから来ている）。
そのような~byte列は，実際の文字~並びを特定0の `符号化方式^i に則って符号化した結果であり、~UAは，その符号化方式を利用して~byte列を文字~並びに復号する。
◎
The stream of code points that comprises the input to the tokenization stage will be initially seen by the user agent as a stream of bytes (typically coming over the network or from the local file system). The bytes encode the actual characters according to a particular character encoding, which the user agent uses to decode the bytes into characters.
</p>

<p class="note">注記：
~XML文書に対しては、［
符号化方式を決定するために利用するよう，~UAに要求される~algo
］は，~XML仕様が与える。
この節は、~XML文書には適用されない。
`XML$r
◎
For XML documents, the algorithm user agents are required to use to determine the character encoding is given by the XML specification. This section does not apply to XML documents. [XML]
</p>

<p>
通例的には，符号化方式を決定するためには、下に定義する`符号化方式を~sniffする~algo$を利用する。
◎
Usually, the encoding sniffing algorithm defined below is used to determine the character encoding.
</p>

<p>
`入力~byte~stream$内の~byte列は、`復号-$用の符号化方式を与える下で，~tokenizerの`入力~stream$用に文字~並びに変換され~MUST。
◎
Given a character encoding, the bytes in the input byte stream must be converted to characters for the tokenizer's input stream, by passing the input byte stream and character encoding to decode.
</p>

<p class="note">注記：
頭部の ~BOM （ Byte Order Mark）がある場合、符号化方式~引数は無視され，~BOM自身も飛ばされることになる。
◎
A leading Byte Order Mark (BOM) causes the character encoding argument to be ignored and will itself be skipped.
</p>

<p class="note">注記：
元の~byte~stream内の
~byte／~byte列
のうち `ENCODING$r 標準に適合しないもの（例：~UTF-8入力~byte~stream内の妥当でない~UTF-8~byte列）は，~errorであり、適合性~検査器には，それを報告することが期待される。
◎
Bytes or sequences of bytes in the original byte stream that did not conform to the Encoding standard (e.g. invalid UTF-8 byte sequences in a UTF-8 input byte stream) are errors that conformance checkers are expected to report. [ENCODING]
</p>

<p class="warning">
復号器~algoは、妥当でない入力を取扱う方法を述べる。
~security上の理由から、この規則には精確に従うことは，~~必須とされる。
妥当でない~byte列を取扱う方法における相違は、他の問題もあるが，~script注入（ “XSS” ）の脆弱性をもたらし得る。
◎
The decoder algorithms describe how to handle invalid input; for security reasons, it is imperative that those rules be followed precisely. Differences in how invalid byte sequences are handled can result in, amongst other problems, script injection vulnerabilities ("XSS").
</p>

<p>
~HTML構文解析器は、入力~byte~streamを復号する際に
符号化方式と
`確度@
~IN { `暫定的^i, `確か^i, `無関係^i }
を利用する。
利用される符号化方式, および
その符号化方式における確度が［
`暫定的^i, `確か^i
］のどちらになるかは、`符号化方式を変更する$かどうか決定するために
<a href="#meta-charset-during-parse">構文解析の間に利用される</a>。
符号化方式は必要とされない場合、 `確度$は `無関係^i とする
— 例： 構文解析器は ~Unicode~stream上で演算していて，符号化方式を利用する必要はまったくないなど。
◎
When the HTML parser is decoding an input byte stream, it uses a character encoding and a confidence. The confidence is either tentative, certain, or irrelevant. The encoding used, and whether the confidence in that encoding is tentative or certain, is used during the parsing to determine whether to change the encoding. If no encoding is necessary, e.g. because the parser is operating on a Unicode stream and doesn't have to use a character encoding at all, then the confidence is irrelevant.
</p>

<p class="note">注記：
一部の~algoは、~byte列を`入力~byte~stream$に追加することなく，`入力~stream$に直接的に 文字たちを追加することにより，構文解析器に給する。
◎
Some algorithms feed the parser by directly adding characters to the input stream rather than adding bytes to the input byte stream.
</p>

				<section id="parsing-with-a-known-character-encoding">
<h4 title="Parsing with a known character encoding">12.2.3.1. 既知の符号化方式による構文解析</h4>

<p>
~HTML構文解析器は、
`既知の確定的な符号化方式@
を伴う入力~byte~stream上で演算するときは、
( 符号化方式, `確度$ )
は
( その符号化方式, `確か^i )
になる。
◎
When the HTML parser is to operate on an input byte stream that has a known definite encoding, then the character encoding is that encoding and the confidence is certain.
</p>

				</section>
				<section id="determining-the-character-encoding">
<h4 title="Determining the character encoding">12.2.3.2. 符号化方式の決定-法</h4>

<p class="trans-note">【
この節の内容は未訳。
次の用語が定義される：
<span id="documentEncoding">`符号化方式を~sniffする~algo@</span>,
`~byte~streamを予走査して符号化方式を決定する@,
`属性を取得-@
する
】</p>

				</section>
				<section id="character-encodings">
<h4 title="Character encodings">12.2.3.3. 符号化方式</h4>

<p>
~UAは、 `ENCODING$r 標準に定義される各種~符号化方式は~supportし~MUST
— 他の符号化方式は~supportしては~MUST_NOT。
◎
User agents must support the encodings defined in the WHATWG Encoding standard, including, but not limited to, UTF-8, ISO-8859-2, ISO-8859-7, ISO-8859-8, windows-874, windows-1250, windows-1251, windows-1252, windows-1254, windows-1255, windows-1256, windows-1257, windows-1258, gb18030, Big5, ISO-2022-JP, Shift_JIS, EUC-KR, UTF-16BE, UTF-16LE, and x-user-defined. User agents must not support other encodings.
</p>

<p class="note">注記：
例えば、次の~supportは禁制される：
CESU-8,
UTF-7,
BOCU-1,
SCSU,
EBCDIC,
UTF-32
。
この仕様は、禁制されるどの符号化方式も，~algo内で~supportしようと試みることはない。
そのような符号化方式を~supportしたり利用した場合、予期されない挙動をもたらすことになる。
`CESU8$r
`UTF7$r
`BOCU1$r
`SCSU$r
◎
The above prohibits supporting, for example, CESU-8, UTF-7, BOCU-1, SCSU, EBCDIC, and UTF-32. This specification does not make any attempt to support prohibited encodings in its algorithms; support and use of prohibited encodings would thus lead to unexpected behavior. [CESU8] [UTF7] [BOCU1] [SCSU]
</p>

				</section>
				<section id="changing-the-encoding-while-parsing">
<h4 title="Changing the encoding while parsing">12.2.3.4. 構文解析-中における符号化方式の変更-法</h4>

<p class="algo-head">
~UAは、
`符号化方式を変更する@
よう構文解析器から要求されたときは、所与の
%新たな符号化方式
に対し，次の手続きを走らせ~MUST。
これは、上に述べた`符号化方式を~sniffする~algo$にて，［
符号化方式を見出すに失敗した場合／
見出された符号化方式は ~fileの実際の符号化方式でなかった場合
］に起こり得る：
◎
When the parser requires the user agent to change the encoding, it must run the following steps. This might happen if the encoding sniffing algorithm described above failed to find a character encoding, or if it found a character encoding that was not the actual encoding of the file.
</p>

<p class="trans-note">【
以下、この~algoの内容は未訳。
】</p>

<p class="note">注記：
この~algoが呼出されるのは、［
`meta$e 要素~上に新たな符号化方式が宣言されている
］ことが見出されたときに限られる。
◎
This algorithm is only invoked when a new encoding is found declared on a meta element.
</p> 

				</section>
				<section id="preprocessing-the-input-stream">
<h4 title="Preprocessing the input stream">12.2.3.5. 入力~streamの前処理-法</h4>

<p>
`入力~stream@
は、復号されて, あるいは 入力~streamを直接的に操作する様々な~APIから，`入力~byte~stream$として~pushされてきた一連の文字からなる。
◎
The input stream consists of the characters pushed into it as the input byte stream is decoded or from the various APIs that directly manipulate the input stream.
</p>

<ul>
	<li>
`~surrogate$が生じたときは，常に
`surrogate-in-input-stream$pE
になるとする。
◎
Any occurrences of surrogates are surrogate-in-input-stream parse errors.＼
</li>
	<li>
`非文字$が生じたときは，常に
`noncharacter-in-input-stream$pE
になるとする。
◎
Any occurrences of noncharacters are noncharacter-in-input-stream parse errors and＼
</li>
	<li>
<p>
［
`~ASCII空白$／ `0000^U
］以外の`制御文字$が生じたときは，常に
`control-character-in-input-stream$pE
になるとする。
◎
any occurrences of controls other than ASCII whitespace and U+0000 NULL characters are control-character-in-input-stream parse errors.
</p>

<p class="note">注記：
`0000^U 文字の取扱いは、構文解析の後の段階にて起こり，当の文字が見出された所に基づいて変わる。
一般に，それらは無視される
— そうすると、攻撃路を導入し得ると見込まれる所は除いて。
そのため、この取扱いは，
~token化~段階, 木~構築~段階
の両者に散らばっている。
◎
The handling of U+0000 NULL characters varies based on where the characters are found and happens at the later stages of the parsing. In general, they are ignored except where doing so could plausibly introduce an attack vector. This handling is, by necessity, spread across both the tokenization stage and the tree construction stage.
</p>
	</li>
	<li>
<p>
文字［
`000D^U ／ `000A^U
］は、特別に扱われ~MUST：
</p>
<ol ><li>~CR の直後の ~LF は無視され~MUST
</li><li>すべての~CR は ~LF に変換され~MUST
</li></ol>

<p>
したがって，~HTML~DOM内では、すべての改行文字は ~LF で表現され，~CRは決して`~token化~段階$に入力されない。
</p>

◎
U+000D CARRIAGE RETURN (CR) characters and U+000A LINE FEED (LF) characters are treated specially. Any LF character that immediately follows a CR character must be ignored, and all CR characters must then be converted to LF characters. Thus, newlines in HTML DOMs are represented by LF characters, and there are never any CR characters in the input to the tokenization stage.
</li>
</ul>


<p>
`次n入力~文字@
は、`入力~stream$内の［
まだ<dfn>消費-</dfn>されていない, かつ
この節の要件により明示的に無視されていない
<!-- not X or Y = not ( X or Y ) -->
］文字のうち，最初のものを指す。
初期~時の`次n入力~文字$は、入力~内の最初の文字とする
【入力が空の場合、下に述べる ~EOF になる】
。
`現在の入力~文字@
は、最後に `消費-^i された文字とする。
◎
The next input character is the first character in the input stream that has not yet been consumed or explicitly ignored by the requirements in this section. Initially, the next input character is the first character in the input. The current input character is the last character to have been consumed.
</p>


<p>
`挿入~地点@
は、［
ある文字 ／ 入力~streamの終端
］の直前を指す位置であり、
`document.write()$m を利用して挿入される内容が実際に挿入される所である。
挿入~地点は、［
その直後の文字の位置
］に相対的であり、入力~streamの中を指す絶対的~offsetではない。
初期~時には、挿入~地点は ε （未定義）とする。
◎
The insertion point is the position (just before a character or just before the end of the input stream) where content inserted using document.write() is actually inserted. The insertion point is relative to the position of the character immediately after it, it is not an absolute offset into the input stream. Initially, the insertion point is undefined.
</p>

<p>
以下における記号 ~EOF は、`入力~stream$の終端を表現する概念的な文字であり，文字が消費され尽くしたことを表す。
構文解析器が
<a href="~HTML5/dynamic-markup-insertion.html#script-created-parser">~scriptにより作成された</a>ものである場合、（ `document.close()$m ~methodにより挿入される）
`明示的な~EOF@
で，`入力~stream$は終端する。
◎
The "EOF" character in the tables below is a conceptual character representing the end of the input stream. If the parser is a script-created parser, then the end of the input stream is reached when an explicit "EOF" character (inserted by the document.close() method) is consumed. Otherwise, the "EOF" character is not a real character in the stream, but rather the lack of any further characters.
</p>

				</section>
			</section>
			<section id="parse-state">
<h3 title="Parse state">12.2.4. 構文解析-状態</h3>

				<section id="the-insertion-mode">
<h4 title="The insertion mode">12.2.4.1. 挿入~mode</h4>


<div class="p">
<p>
`挿入~mode@
は，状態~変数であり、木~構築~段階の主要な演算を制御する。
それは、~tokenがどう処理されるか, および
`~CDATAsec$は~supportされるかどうかに影響し、構文解析の~~進行に伴い，`木~構築~段階$の中で次のいずれかに変化し得る：
</p>

<ul ><li>`初期$md — これが、初期~時の`挿入~mode$
</li><li>`~htmlの前$md
</li><li>`~headの前$md
</li><li>`~head内$md
</li><li>`~head~noscript内$md
</li><li>`~headの後$md
</li><li>`~body内$md
</li><li>`~text$md
</li><li>`~table内$md
</li><li>`~table~text内$md
</li><li>`~caption内$md
</li><li>`~column-group内$md
</li><li>`~table~body内$md
</li><li>`~row内$md
</li><li>`~cell内$md
</li><li>`~select内$md
</li><li>`~table内~select内$md
</li><li>`~template内$md
</li><li>`~bodyの後$md
</li><li>`~frameset内$md
</li><li>`~framesetの後$md
</li><li>`~bodyの後の後$md
</li><li>`~framesetの後の後$md
</li></ul>

◎
The insertion mode is a state variable that controls the primary operation of the tree construction stage.
◎
Initially, the insertion mode is "initial". It can change to "before html", "before head", "in head", "in head noscript", "after head", "in body", "text", "in table", "in table text", "in caption", "in column group", "in table body", "in row", "in cell", "in select", "in select in table", "in template", "after body", "in frameset", "after frameset", "after after body", and "after after frameset" during the course of the parsing, as described in the tree construction stage. The insertion mode affects how tokens are processed and whether CDATA sections are supported.
</div>

<p>
これらの`挿入~mode$のうち［
`~head内$md ／ `~body内$md ／ `~table内$md ／ `~select内$md
【／ `~template内$md 】
］は、他の~modeが様々な時点で これらの~modeへ先送りする点で特別である
— すなわち，以下の~algoにて、ここに挙げたいずれかの~mode %m に対し，
<q>%m
`用の規則を用いて@
%何か を行う</q>
と記される所では、~UAは， %m `挿入~mode$の節に述べる規則を利用し~MUST
— %m 内の規則~自身が`挿入~mode$を他の~modeへ切替えない限り、`挿入~mode$は変更することなく。
◎
Several of these modes, namely "in head", "in body", "in table", and "in select", are special, in that the other modes defer to them at various times. When the algorithm below says that the user agent is to do something "using the rules for the m insertion mode", where m is one of these modes, the user agent must use the rules described under the m insertion mode's section, but must leave the insertion mode unchanged unless the rules in m themselves switch the insertion mode to a new value.
</p>

<p>
挿入~modeが［
`~text$md ／ `~table~text内$md
］に切替えられるときは、
`元の挿入~mode@V
も設定される。
これは、木~構築~段階が後で戻ることになる，挿入~modeを指す。
◎
When the insertion mode is switched to "text" or "in table text", the original insertion mode is also set. This is the insertion mode to which the tree construction stage will return.
</p>

<p>
同様に，入子にされた `template$e 要素を構文解析するときには、
`~template挿入~mode~stack@
が利用される
— それは 0 個~以上の`挿入~mode$からなる`~stack$であり†，初期~時には空とする。
◎
Similarly, to parse nested template elements, a stack of template insertion modes is used. It is initially empty. The current template insertion mode is the insertion mode that was most recently added to the stack of template insertion modes. The algorithms in the sections below will push insertion modes onto this stack, meaning that the specified insertion mode is to be added to the stack, and pop insertion modes from the stack, which means that the most recently added insertion mode must be removed from the stack.
</p>

<p class="trans-note" id="current-template-insertion-mode">【†
この訳では `Infra$r による`~stack$の定義を参照して、原文の記述を簡約している。
】</p>

<hr>

<p class="algo-head">
以下の手続きにて
`挿入~modeを適切に再設定する@
するときは、`挿入~mode$を次の手続きを走らせた結果に設定し~MUST：
◎
When the steps below require the UA to reset the insertion mode appropriately, it means the UA must follow these steps:
</p>

<ol>
	<li>
%~stack ~LET `~open要素~stack$
◎
↓</li>
	<li>
~Assert：
%~stack は空でない
◎
↓</li>
	<li>
%最後の ~LET ~F
◎
Let last be false.
</li>
	<li>
<p>
%~stack 内の~EACH( %~node ) に対し，末尾から順に：
◎
Let node be the last node in the stack of open elements.
</p>
		<ol>
			<li>
<p>
~IF［
%~node は %~stack の先頭の~nodeである
］：
</p>
		<ol>
			<li>
%最後の ~SET ~T
</li>
			<li>
~IF［
%構文解析器 は `~HTML素片~用$である
（`素片~事例$）
］
⇒
%~node ~SET その~algoに渡された `文脈~要素$V
</li>
		</ol>

◎
Loop: If node is the first node in the stack of open elements, then set last to true, and, if the parser was originally created as part of the HTML fragment parsing algorithm (fragment case), set node to the context element passed to that algorithm.
</li>
			<li>
<p>
%~node の型に応じて：
◎
↓</p>
				<dl class="switch">
					<dt>`select$e
◎
If node is a select element, run these substeps:
</dt>
					<dd>
						<ol>
							<li>
<p>
~IF［
%~stack 内に次をいずれも満たす要素は在る
］：
</p>

<ul ><li>`table$e である
</li><li>%~stack 内で %~node より前に在る
</li><li>%~stack 内の，要素より後, かつ  %~node より前には、 `template$e ~nodeは無い
</li></ul>

<p>
…ならば
⇒
~RET `~table内~select内$md
</p>
◎
If last is true, jump to the step below labeled done.
◎
Let ancestor be node.
◎
Loop: If ancestor is the first node in the stack of open elements, jump to the step below labeled done.
◎
Let ancestor be the node before ancestor in the stack of open elements.
◎
If ancestor is a template node, jump to the step below labeled done.
◎
If ancestor is a table node, switch the insertion mode to "in select in table" and abort these steps.
◎
Jump back to the step labeled loop.
</li>
							<li>
~RET `~select内$md
◎
Done: Switch the insertion mode to "in select" and abort these steps.
</li>
						</ol>
					</dd>

					<dt>`td$e</dt>
					<dt>`th$e</dt>
					<dd>
~IF［
%最後の ~EQ ~F
］
⇒
~RET `~cell内$md
◎
If node is a td or th element and last is false, then switch the insertion mode to "in cell" and abort these steps.
</dd>

					<dt>`tr$e</dt>
					<dd>
~RET `~row内$md
◎
If node is a tr element, then switch the insertion mode to "in row" and abort these steps.
</dd>

					<dt>`tbody$e</dt>
					<dt>`thead$e</dt>
					<dt>`tfoot$e</dt>
					<dd>
~RET `~table~body内$md
◎
If node is a tbody, thead, or tfoot element, then switch the insertion mode to "in table body" and abort these steps.
</dd>

					<dt>`caption$e</dt>
					<dd>
~RET `~caption内$md
◎
If node is a caption element, then switch the insertion mode to "in caption" and abort these steps.
</dd>

					<dt>`colgroup$e</dt>
					<dd>
~RET `~column-group内$md
◎
If node is a colgroup element, then switch the insertion mode to "in column group" and abort these steps.
</dd>

					<dt>`table$e</dt>
					<dd>
~RET `~table内$md
◎
If node is a table element, then switch the insertion mode to "in table" and abort these steps.
</dd>

					<dt>`template$e</dt>
					<dd>
~RET `~template挿入~mode~stack$の最後の~item
◎
If node is a template element, then switch the insertion mode to the current template insertion mode and abort these steps.
</dd>

					<dt>`head$e</dt>
					<dd>
~IF［
%最後の ~EQ ~F
］
⇒
~RET `~head内$md
◎
If node is a head element and last is false, then switch the insertion mode to "in head" and abort these steps.
</dd>

					<dt>`body$e</dt>
					<dd>
~RET `~body内$md
◎
If node is a body element, then switch the insertion mode to "in body" and abort these steps.
</dd>

					<dt>`frameset$e（`素片~事例$）</dt>
					<dd>
~RET `~frameset内$md
◎
If node is a frameset element, then switch the insertion mode to "in frameset" and abort these steps. (fragment case)
</dd>

					<dt>`html$e</dt>
					<dd>
~RET ［
`~head要素~pointer$ ~EQ ~NULL（`素片~事例$）ならば `~headの前$md ／
~ELSE_ `~headの後$md
］
◎
If node is an html element, run these substeps:
◎
If the head element pointer is null, switch the insertion mode to "before head" and abort these steps. (fragment case)
◎
Otherwise, the head element pointer is not null, switch the insertion mode to "after head" and abort these steps.
</dd>
				</dl>
			</li>
		</ol>
	</li>
	<li>
~IF［
%最後の ~EQ ~T
（`素片~事例$）
］
⇒
~RET `~body内$md
◎
If last is true, then switch the insertion mode to "in body" and abort these steps. (fragment case)
◎
Let node now be the node before node in the stack of open elements.
◎
Return to the step labeled loop.
</li>
</ol>

				</section>
				<section id="the-stack-of-open-elements">
<h4 title="The stack of open elements">12.2.4.2. ~open要素~stack</h4>

<p>
初期~時には
`~open要素~stack@
は空とする。
この~stackは、末尾側（ downward† ）へ成長する
— ~stackの先頭の~nodeは，~stackに最初に追加されたものであり、~stackの末尾の~nodeは，~stackに最も近過去に追加されたものである（
<a href="#adoptionAgency">誤入子な~tagを取扱う</a>
一部として，~stackが~random~access的に操作されたときであっても）。
◎
Initially, the stack of open elements is empty. The stack grows downwards; the topmost node on the stack is the first one added to the stack, and the bottommost node of the stack is the most recently added node in the stack (notwithstanding when the stack is manipulated in a random access fashion as part of the handling for misnested tags).
</p>

<p class="trans-note">【†
この語 downward, および原文に現れる［
bottommost, bottom ／ topmost, top ／ lower
］などの語は、［
この~stackが表現する，~nodeたちが成す入子
］の “深さ” を反映することを意図して用いられているが、この訳では，一律に，通例の~listにおける順序関係を表す語（
先頭, 〜のうち最初の, 末尾, 〜のうち最後の, 〜より後, 〜より前
）を用いて表記する。
~stackの bottom や top が［
~listとしての~stack
］の先頭, 末尾のどちらかを指すか直感的でないことに加え、原文には，これら~list用の語（ first, last, after, before）も混用されていて，惑わされるので。
】</p>

<p class="note">注記：
`挿入~mode$ `~htmlの前$mdでは、
`html$e `文書~要素$が作成され，~stackに追加される。
◎
The "before html" insertion mode creates the html document element, which is then added to the stack.
</p>

<p class="note">注記：
`素片~事例$においては、`~open要素~stack$は，［
`~HTML素片の構文解析~algo$の一部として作成された `html$e 要素
］を包含するように初期化される（`素片~事例$は`~htmlの前$md `挿入~mode$を飛ばす）。
◎
In the fragment case, the stack of open elements is initialized to contain an html element that is created as part of that algorithm. (The fragment case skips the "before html" insertion mode.)
</p>

<p>
`html$e ~nodeは、作成されたものであれ，~stackの先頭の~nodeになる。
それが~stackから~popされるのは、構文解析器が
<a href="#stop-parsing">完遂した</a>ときに限られる。
◎
The html node, however it is created, is the topmost node of the stack. It only gets popped off the stack when the parser finishes.
</p>

<p>
`現在の~node@
は、この`~open要素~stack$の末尾の~nodeである。
◎
The current node is the bottommost node in this stack of open elements.
</p>

<p>
`現在の調整-済み~node@
は、［
%構文解析器 は `~HTML素片~用$であって
`~open要素~stack$は唯一の要素からなる（`素片~事例$）ならば `文脈~要素$V ／
~ELSE_ `現在の~node$
］を指す。
◎
The adjusted current node is the context element if the parser was created by the HTML fragment parsing algorithm and the stack of open elements has only one element in it (fragment case); otherwise, the adjusted current node is the current node.
</p>

<!-- ＊27314 -->

<p>
`~open要素~stack$内の各 要素は、次のいずれかに分類される：
◎
Elements in the stack of open elements fall into the following categories:
</p>

<dl>
	<dt>`特別な要素@
◎
Special
</dt>
	<dd>
<p>
次に挙げる要素~型には、様々な~levelの特別な構文解析~規則がある：
</p>
		<ul>
			<li>
~HTMLの
`address$e, `applet$e, `area$e, `article$e, `aside$e, `base$e, `basefont$e, `bgsound$e, `blockquote$e, `body$e, `br$e, `button$e, `caption$e, `center$e, `col$e, `colgroup$e, `dd$e, `details$e, `dir$e, `div$e, `dl$e, `dt$e, `embed$e, `fieldset$e, `figcaption$e, `figure$e, `footer$e, `form$e, `frame$e, `frameset$e, `h6$e, `h6$e, `h6$e, `h6$e, `h6$e, `h6$e, `head$e, `header$e, `hgroup$e, `hr$e, `html$e, `iframe$e, `img$e, `input$e, `keygen$e, `li$e, `link$e, `listing$e, `main$e, `marquee$e, `menu$e, `meta$e, `nav$e, `noembed$e, `noframes$e, `noscript$e, `object$e, `ol$e, `p$e, `param$e, `plaintext$e, `pre$e, `script$e, `section$e, `select$e, `source$e, `style$e, `summary$e, `table$e, `tbody$e, `td$e, `template$e, `textarea$e, `tfoot$e, `th$e, `thead$e, `title$e, `tr$e, `track$e, `ul$e, `wbr$e, `xmp$e
</li>
			<li>
~MathMLの
`mi$e, `mo$e, `mn$e, `ms$e, `mtext$e, `annotation-xml$e
</li>
			<li>
~SVGの
`foreignObject$e, `desc$e, `title$e
</li>
		</ul>
◎
The following elements have varying levels of special parsing rules: HTML's address, applet, area, article, aside, base, basefont, bgsound, blockquote, body, br, button, caption, center, col, colgroup, dd, details, dir, div, dl, dt, embed, fieldset, figcaption, figure, footer, form, frame, frameset, h1, h2, h3, h4, h5, h6, head, header, hgroup, hr, html, iframe, img, input, keygen, li, link, listing, main, marquee, menu, meta, nav, noembed, noframes, noscript, object, ol, p, param, plaintext, pre, script, section, select, source, style, summary, table, tbody, td, template, textarea, tfoot, th, thead, title, tr, track, ul, wbr, xmp; MathML mi, MathML mo, MathML mn, MathML ms, MathML mtext, and MathML annotation-xml; and SVG foreignObject, SVG desc, and SVG title.
</dd>
	<dd class="note">注記：
`image^c 開始tag~tokenは、木を築くときに取扱われるが，この~list内にはない
— それは要素ではなく， `img$e 要素に転換されるので。
◎
An image start tag token is handled by the tree builder, but it is not in this list because it is not an element; it gets turned into an img element.
</dd>

	<dt>`整形~要素@
◎
Formatting
</dt>
	<dd>
次に挙げる~HTML要素は、`作動中の整形~要素~list$内に加えられることになる
⇒
`a$e, `b$e, `big$e, `code$e, `em$e, `font$e, `i$e, `nobr$e, `s$e, `small$e, `strike$e, `strong$e, `tt$e, `u$e
◎
The following HTML elements are those that end up in the list of active formatting elements: a, b, big, code, em, font, i, nobr, s, small, strike, strong, tt, and u.
</dd>

	<dt>`普通の要素@
◎
Ordinary
</dt>
	<dd>
~HTML文書の構文解析している間に見出された，他のすべての要素。
◎
All other elements found while parsing an HTML document.
</dd>
</dl>

<p class="note">注記：
概して、`特別な要素$の［
開始tag ／ 終了tag
］~tokenは，特定的な分岐で取扱われる一方で、`普通の要素$の~tokenは，［
“その他の開始tag” ／ “その他の終了tag”
］と記される分岐に仕分けられる。
また，木を築くときには、［
`~open要素~stack$内の特定0の要素が`特別$である
］かどうか検査する箇所がいくつかある。
［
開始tag ／ 終了tag
］~tokenが特定的な分岐で取扱われる要素は，他にもあるが（例： `option$e 要素）、他所では`普通の要素$として取扱われるので，`特別$とされない。
◎
Typically, the special elements have the start and end tag tokens handled specifically, while ordinary elements' tokens fall into "any other start tag" and "any other end tag" clauses, and some parts of the tree builder check if a particular element in the stack of open elements is in the special category. However, some elements (e.g., the option element) have their start or end tag tokens handled specifically, but are still not in the special category, so that they get the ordinary handling elsewhere.
</p>

<div class="p">
<p class="algo-head">
`~open要素~stack$において、特定の
`視野~内@
に ある条件を満たす要素が `在る^i とは、所与の：
</p>

<ol >
	<li>
<p>
視野を与える いくつか要素~型からなる集合 %S
</p>
<p class="trans-note">【
要素~型は、
( 要素の~tag名, 要素が属する名前空間) 
の組であることに注意。
名前空間が明示的に指定されていないものは、
<a href="#_notes-on-element-type">~HTML名前空間に属する</a>。
】</p>

	</li>
	<li>
<p>
条件 %~target条件
— ここで、条件 として：
</p>

<ul ><li>要素~型（または それらの集合）が与えられた場合、条件は “その（いずれかの）要素~型である” と解釈する。
</li><li>ある要素~instanceが与えられた場合、条件は “その要素と同じ~instance” と解釈する。
</li></ul>

	</li>
</ol>

<p>
に対し，［
次の~algoを走らせた結果 ~EQ `在る^i 
］になることを意味する。
`視野~内$に `無い^i は、その否定を意味する：
</p>

◎
The stack of open elements is said to have an element target node in a specific scope consisting of a list of element types list when the following algorithm terminates in a match state:
</div>

<ol>
	<li>
~Assert：
`html$e ~IN %S
◎
↓</li>
	<li>
<p>
`~open要素~stack$内の~EACH( %~node ) に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
		<ol>
			<li>
~IF［
%~node は %~target条件 を満たす
］
⇒
~RET `在る^i
◎
If node is the target node, terminate in a match state.
</li>
			<li>
~IF［
%~node の要素~型 ~IN %S
］
⇒
~RET `無い^i
◎
Otherwise, if node is one of the element types in list, terminate in a failure state.
</li>
		</ol>
	</li>
	<li>
~Assert：
~stackの先頭は `html$e 要素なので、この段に達することは決してない
◎
Otherwise, set node to the previous entry in the stack of open elements and return to step 2. (This will never fail, since the loop will always terminate in the previous step if the top of the stack — an html element — is reached.)
</li>
</ol>

<p>
上の “`視野~内$” 手続きに与える要素~型の集合 %S として、次のものが定義される：
<!-- 
（
“%要素 は %X 視野~内” にあるとは、
%要素 ~IN %S ではなく
%要素 は %S の`視野~内$にあることを意味することに注意）
 -->
◎
↑↓</p>

<dl>
	<dt>`既定の視野@
◎
The stack of open elements is said to have a particular element in scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`applet$e, `caption$e, `html$e, `table$e, `td$e, `th$e, `marquee$e, `object$e, `template$e
◎
applet
caption
html
table
td
th
marquee
object
template
</dd>
	<dd>
`~MathML名前空間$に属する，次に挙げる要素~型
⇒
`mi$e, `mo$e, `mn$e, `ms$e, `mtext$e, `annotation-xml$e
◎
template
MathML mi
MathML mo
MathML mn
MathML ms
MathML mtext
MathML annotation-xml
</dd>
	<dd>
`~SVG名前空間$に属する，次に挙げる要素~型
⇒
`foreignObject$e, `desc$e, `title$e
◎
SVG foreignObject
SVG desc
SVG title
</dd>

	<dt>`~list~item視野@
◎
The stack of open elements is said to have a particular element in list item scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`既定の視野$
◎
All the element types listed above for the has an element in scope algorithm.
</dd>
	<dd>
`ol$e,`ul$e
◎
ol in the HTML namespace
◎
ul in the HTML namespace
</dd>

	<dt>`~button視野@
◎
The stack of open elements is said to have a particular element in button scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`既定の視野$
◎
All the element types listed above for the has an element in scope algorithm.
</dd>
	<dd>
`button$e
◎
button in the HTML namespace
</dd>

	<dt>`~table視野@
◎
The stack of open elements is said to have a particular element in table scope when it has that element in the specific scope consisting of the following element types:
</dt>
	<dd>
`html$e, `table$e, `template$e
◎
html in the HTML namespace
◎
table in the HTML namespace
◎
template in the HTML namespace
</dd>

	<dt>`~select視野@</dt>
	<dd>
［
`optgroup$e, `option$e
］<em>以外の</em>，すべての要素~型（名前空間を問わず）
◎
The stack of open elements is said to have a particular element in select scope when it has that element in the specific scope consisting of all element types except the following:
• optgroup in the HTML namespace
• option in the HTML namespace
</dd>
</dl>

<p>
どの時点であれ、`~open要素~stack$内の要素が，`文書$を成す木~内の他所へ移動されても, あるいは木から除去されても，~~特別な何かが起こることはない
— 特に、この状況においても，~stackは変更されない。
その結果、もはや~DOM内にない~nodeに内容が付加されることもある
— 変則的な効果は他にもあるが。
◎
Nothing happens if at any time any of the elements in the stack of open elements are moved to a new location in, or removed from, the Document tree. In particular, the stack is not changed in this situation. This can cause, amongst other strange effects, content to be appended to nodes that are no longer in the DOM.
</p>

<p class="note">注記：
一部の事例（すなわち，<a href="#adoptionAgency">誤入子な整形~要素を閉じるとき</a>
）では、~stackは~random~access的に操作される。
◎
In some cases (namely, when closing misnested formatting elements), the stack is manipulated in a random-access fashion.
</p>

<p class="algo-head">
所与の条件を満たす要素が
`出るまで~open要素~stackから~popする@
ときは、次を走らす
— ここで、条件として：
</p>

<ul ><li>単に要素~型（またはその集合）が与えられた場合（例： “`div^e 要素が出るまで…”）、条件は “その（いずれかの）要素~型である” と解釈する。
</li><li>単にある要素~instanceが与えられた場合、条件は “その要素と同じ~instance” と解釈する。
</li></ul>

<ol>
	<li>
~Assert：
`~open要素~stack$内には条件を満たす要素はある
</li>
	<li>
<p>
~WHILE 無条件：
</p>
		<ol>
			<li>
%要素 ~LET `~open要素~stack$から~popした結果
</li>
			<li>
~IF［
%要素 は条件を満たす
］
⇒
~BREAK
</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
この手続きは、以下を簡潔に記述するために，この訳に導入している。
これは、~DOMにおいて，当の要素とその子孫が成す木を “閉じる” ことに相当する。
】</p>


				</section>
				<section id="the-list-of-active-formatting-elements">
<h4 title="The list of active formatting elements">12.2.4.3. 作動中の整形~要素からなる~list</h4>

<p>
`作動中の整形~要素~list@
は、誤入子な`整形~要素$~tagを取扱うために利用され，初期~時には空とする。
◎
Initially, the list of active formatting elements is empty. It is used to handle mis-nested formatting element tags.
</p>

<p>
この~listは、一連の［
`整形~要素$／`~marker$
］からなる。
`~marker@
は、要素 ~IN %S ~EQ { `applet$e, `object$e, `marquee$e, `template$e, `td$e, `th$e, `caption$e }
に入るとき挿入され、整形が %S に属する要素の<em>中へ</em> “漏れる” のを防ぐために利用される。
◎
The list contains elements in the formatting category, and markers. The markers are inserted when entering applet, object, marquee, template, td, th, and caption elements, and are used to prevent formatting from "leaking" into applet, object, marquee, template, td, th, and caption elements.
</p>

<p>
加えて、`作動中の整形~要素~list$内の各~要素には，それを
`作成させた~token@
が結付けられる
— 必要とされれば，その~token用の要素を更に作成できるように。
◎
In addition, each element in the list of active formatting elements is associated with the token for which it was created, so that further elements can be created for that token if necessary.
</p>

<p class="algo-head">
以下の手続きにて
`作動中の整形~要素~listに~pushする@
ときは、所与の`整形~要素$ %整形~要素 に対し，次の手続きを遂行し~MUST:
◎
When the steps below require the UA to push onto the list of active formatting elements an element element, the UA must perform the following steps:
</p>

<ol id="noah">
	<li>
%~list ~LET `作動中の整形~要素~list$
</li>
	<li>
<div class="p">

<p>
~IF［
%~list 内に次を満たす要素が 3 個~以上ある
］…：
</p>

<ul><li>%整形~要素 と同じ［
~tag名, 名前空間, 属性たち
］を有する
</li><li>%~list 内には，要素より前に`~marker$はない
</li></ul>

◎
If there are already three elements in the list of active formatting elements after the last marker, if any, or anywhere in the list if there are no markers, that have the same tag name, namespace, and attributes as element, then＼
</div>

<p>
…ならば
⇒
該当する要素のうち， %~list 内で最初のものを %~list から除去する
◎
remove the earliest such element from the list of active formatting elements.＼
</p>

<p>
この段の目的においては：
◎
For these purposes,＼
</p>
		<ul>
			<li>
各~属性を比較するときは、要素が %構文解析器 により作成された時点のものを利用し~MUST。
◎
the attributes must be compared as they were when the elements were created by the parser;＼
</li>
			<li>
2 つの要素が同じ属性たちを有するとは、互いのどの属性も［
名前, 名前空間, 値
］が一致するよう対にできることを意味する（属性の順序は問わない）。
◎
two elements have the same attributes if all their parsed attributes can be paired such that the two attributes in each pair have identical names, namespaces, and values (the order of the attributes does not matter).
</li>
		</ul>

<p class="note">注記：
これがノアの方舟（Noah's Ark ）条項である
— 各組は、つがいではなく，三つ組だが。
◎
This is the Noah's Ark clause. But with three per family instead of two.
</p>
	</li>
	<li>
%~list に %整形~要素 を追加する
◎
Add element to the list of active formatting elements.
</li>
</ol>

<p class="algo-head">
以下の手続きにて
`作動中の整形~要素たちを再構築する@
ときは、次を走らせ~MUST：
◎
When the steps below require the UA to reconstruct the active formatting elements, the UA must perform the following steps:
</p>

<ol>
	<li>
%~list ~LET `作動中の整形~要素~list$
◎
↓</li>
	<li>
%開始~entry ~LET ε
◎
↓</li>
	<li>
<p>
%~list 内の~EACH( %~entry ) に対し，最後の（最も近過去に追加された）~entryから順に：
</p>
		<ol>
			<li>
~IF［
%~entry は`~marker$である
］~OR［
%~entry ~IN `~open要素~stack$
］
⇒
~BREAK
</li>
			<li>
%開始~entry ~SET %~entry
</li>
		</ol>

◎
If there are no entries in the list of active formatting elements, then there is nothing to reconstruct; stop this algorithm.
◎
If the last (most recently added) entry in the list of active formatting elements is a marker, or if it is an element that is in the stack of open elements, then there is nothing to reconstruct; stop this algorithm.
◎
Let entry be the last (most recently added) element in the list of active formatting elements.
◎
Rewind: If there are no entries before entry in the list of active formatting elements, then jump to the step labeled create.
◎
Let entry be the entry one earlier than entry in the list of active formatting elements.
◎
If entry is neither a marker nor an element that is also in the stack of open elements, go to the step labeled rewind.
◎
Advance: Let entry be the element one later than entry in the list of active formatting elements.
</li>
	<li>
~IF［
%開始~entry ~EQ ε
］
⇒
~RET
— 再構築するものは何もない
◎
↑</li>
	<li>
%~list 内の %開始~entry 以降の~EACH( %~entry ) に対し， %開始~entry から順に
⇒
%~list 内の %~entry を次の結果に置換する
⇒
`~HTML要素を挿入する$( %~entry を`作成させた~token$ )
◎
Create: Insert an HTML element for the token for which the element entry was created, to obtain new element.
◎
Replace the entry for entry in the list with an entry for new element.
◎
If the entry for new element in the list of active formatting elements is not the last entry in the list, return to the step labeled advance.
</li>
</ol>

<p>
これにより，［［
現在の［［
`body^e, `cell^e, `caption^e
］のうち，最も近過去のもの
］内で開かれた整形~要素
］のうち，まだ明示的に閉じられてないもの
］すべては、再び開かれることになる。
◎
This has the effect of reopening all the formatting elements that were opened in the current body, cell, or caption (whichever is youngest) that haven't been explicitly closed.
</p>

<p class="note">注記：
この仕様は、［
`作動中の整形~要素~list$を成す要素たちの順序は，常に時系列順（最も近過去に追加された要素が最後）になる
］ように書かれている。
<!-- except for while steps 7... -->
◎
The way this specification is written, the list of active formatting elements always consists of elements in chronological order with the least recently added element first and the most recently added element last (except for while steps 7 to 10 of the above algorithm are being executed, of course).
</p>

<p class="algo-head">
以下の手続きにて
`作動中の整形~要素~listを最後の~markerまで~clearする@
ときは、次を遂行し~MUST：
◎
When the steps below require the UA to clear the list of active formatting elements up to the last marker, the UA must perform the following steps:
</p>

<ol>
	<li>
<p>
`作動中の整形~要素~list$ %~list 内の~EACH( %~entry ) に対し，最後の（最も近過去に追加された）~entryから順に：
◎
Let entry be the last (most recently added) entry in the list of active formatting elements.
</p>
		<ol>
			<li>
%~list から %~entry を除去する
◎
Remove entry from the list of active formatting elements.
</li>
			<li>
~IF［
%~entry は`~marker$である
］
⇒
~BREAK
◎
If entry was a marker, then stop the algorithm at this point. The list has been cleared up to the last marker.
◎
Go to step 1.
</li>
		</ol>
	</li>
</ol>


				</section>
				<section id="the-element-pointers">
<h4 title="The element pointers">12.2.4.4. 要素を指す~pointer</h4>


<dl class="def-list">
	<dt>`~head要素~pointer@</dt>
	<dd>
初期~時は， ~NULL 。
◎
Initially, the head element pointer and the form element pointer are both null.
</dd>
	<dd>
`head$e 要素が（暗黙的／明示的いずれにせよ）構文解析された時点で，その~nodeを指すよう設定される。
◎
Once a head element has been parsed (whether implicitly or explicitly) the head element pointer gets set to point to this node.
</dd>

	<dt>`~form要素~pointer@</dt>
	<dd>
初期~時は， ~NULL 。
◎
↑</dd>
	<dd>
［
開かれている `form$e 要素
］のうち，まだ終了tagには出くわしてないもの
］のうち，最後のものを指す。
それは，歴史的~理由から、ひどく不良な~markupに面したとき，~form-controlを~formに所有させるために利用される。
それは， `template$e 要素の内側では無視される。
◎
The form element pointer points to the last form element that was opened and whose end tag has not yet been seen. It is used to make form controls associate with forms in the face of dramatically bad markup, for historical reasons. It is ignored inside template elements.
</dd>
</dl>


				</section>
				<section id="other-parsing-state-flags">
<h4 title="Other parsing state flags">12.2.4.5. 他の構文解析~状態~flag</h4>

<dl class="def-list">
	<dt>`~scripting~flag@</dt>
	<dd>
%構文解析器 が作成された時点で、それに結付けられている`文書$に対し `~scriptingは可能化されて$いるならば `可能化^i
~ELSE_ `不能化^i に設定される。
◎
The scripting flag is set to "enabled" if scripting was enabled for the Document with which the parser is associated when the parser was created, and "disabled" otherwise.
</dd>
	<dd class="note">注記：
`~scripting~flag$は、 %構文解析器 が`~HTML素片~用$であるときでも，可能化され得る
— その事例では `script$e 要素は実行しないが。
◎
The scripting flag can be enabled even when the parser was originally created for the HTML fragment parsing algorithm, even though script elements don't execute in that case.
</dd>

	<dt>`~frameset-ok~flag@</dt>
	<dd>
%構文解析器 の作成-時には `ok^i に設定される。
ある種の~tokenに出くわしたとき，`not-ok^i になる。
◎
The frameset-ok flag is set to "ok" when the parser is created. It is set to "not ok" after certain tokens are seen.
</dd>
</dl>

				</section>
			</section>
			<section id="tokenization">
<h3 title="Tokenization">12.2.5. ~token化</h3>

<p>
実装は、~HTMLを~token化するときには，以下に述べる状態~機械を利用したかのように動作し~MUST
— この状態~機械は：
◎
Implementations must act as if they used the following state machine to tokenize HTML.＼
</p>

<ul>
	<li>
`~data$stから開始し~MUST。
◎
The state machine must start in the data state.＼
</li>
	<li>
ほとんどの`状態$は，文字を 1 個だけ消費するが、様々な副作用を備えるものもある。
また、状態~機械を新たな`状態$に切替えて［
`現在の入力~文字$を`再消費-$／`次n入力~文字$を消費-
］するか、同じ`状態$に留まって次n文字を消費する。
◎
Most states consume a single character, which may have various side-effects, and either switches the state machine to a new state to reconsume the current input character, or switches it to a new state to consume the next character, or stays in the same state to consume the next character.＼
</li>
	<li>
一部の`状態$では、別の`状態$に`切替える$前に何個かの文字を消費するよう，より複雑に挙動する。
◎
Some states have more complicated behavior and can consume several characters before switching to another state.＼
</li>
	<li>
一部の事例では、~tokenizerの`状態$は，木~構築~段階の中でも変更される。
◎
In some cases, the tokenizer state is also changed by the tree construction stage.
</li>
</ul>

<div class="p">
<p>
ある`状態$の下で，別の`状態$ %S を指定した上で：
</p>

<ul>
	<li>
%S に
`切替える@
と記された所では、以降に消費する文字は %S の下で取扱うことを意味する。
</li>
	<li>
（直前に消費した文字を）
“%S 内で
`再消費-@
する”
と記された所では、
%S に`切替える$ことに加え、`次n入力~文字$を消費しようと試みるときには，代わりに`現在の入力~文字$を %S に提供することを意味する。
</li>
</ul>

◎
When a state says to reconsume a matched character in a specified state, that means to switch to that state, but when it attempts to consume the next input character, provide it with the current input character instead.
</div>


<div class="p">
<p>
ある種の`状態$においては：
</p>
<ul>
	<li>
その正確な挙動は［
`挿入~mode$, `~open要素~stack$
］に依存する。
</li>
	<li>
進捗-を追跡するために
`一時~buffer@V
も利用する。
</li>
	<li>
`文字~参照$stは、それを呼出した`状態$へ戻るために
`戻先~状態@V
を利用する。
</li>
</ul>

◎
The exact behavior of certain states depends on the insertion mode and the stack of open elements. Certain states also use a temporary buffer to track progress, and the character reference state uses a return state to return to the state it was invoked from.
</div>


<p>
~token化~段の出力は、一連の 0 個~以上の~tokenからなる。
その各~tokenは、次のいずれかとして与えられる：
◎
The output of the tokenization step is a series of zero or more of the following tokens: DOCTYPE, start tag, end tag, comment, character, end-of-file.＼
</p>

<dl class="def-list">
	<dt>~DOCTYPE~token</dt>
	<dd>
<p>
それぞれが次のものを持つ
— 作成-時には括弧内に与える値にされ~MUST：
</p>

<ul><li>名前（ ε ）
</li><li>~publicID（ ε ）
</li><li>~systemID（ ε ）
</li><li>`過去互換強制~flag@（ ~OFF ）
</li></ul>

◎
DOCTYPE tokens have a name, a public identifier, a system identifier, and a force-quirks flag. When a DOCTYPE token is created, its name, public identifier, and system identifier must be marked as missing (which is a distinct state from the empty string), and the force-quirks flag must be set to off (its other state is on).＼
</dd>

	<dt>開始tag~token</dt>
	<dt>終了tag~token</dt>
	<dd>
<p>
いずれも，それぞれが次のものを持つ：
</p>
		<dl class="def-list">
			<dt>~tag名</dt>
			<dd>
作成-時に与えられる。
</dd>

			<dt>`自己閉じ~flag@</dt>
			<dd>
初期~時は ~OFF
</dd>

			<dt>属性~list</dt>
			<dd>
一連の属性からなる~listであり、初期~時は空とする
— そのそれぞれは，名前（初期~時は空）と値（初期~時は空）からなる。
</dd>
		</dl>
◎
Start and end tag tokens have a tag name, a self-closing flag, and a list of attributes, each of which has a name and a value. When a start or end tag token is created, its self-closing flag must be unset (its other state is that it be set), and its attributes list must be empty.＼
</dd>
	<dd>
“新たな開始tag~token( %名前 )”
という表記は、新たな開始tag~tokenであって［
その~tag名 ~SET %名前
］にされたものを表すとする。
◎＼
</dd>
	<dd>
“新たな終了tag~token()”
という表記は、新たな終了tag~tokenであって［
その~tag名 ~SET 空~文字列
］にされたものを表すとする。
◎＼
</dd>

	<dt>~comment~token</dt>
	<dd>
それぞれが、作成-時に与えられる~data（文字列）を持つ。
◎
Comment and＼
 </dd>
	<dd>
“新たな~comment~token( %~data )”
という表記は、新たな~comment~tokenであって［
その~data ~SET %~data
］にされたものを表すとする。
</dd>

	<dt>文字~token</dt>
	<dd>
それぞれが、作成-時に与えられる 1 個の文字を持つ。
◎
character tokens have data.＼
</dd>
	<dd>
“新たな文字~token( %文字 )”
という表記は、新たな文字~tokenであって［
その文字 ~SET %文字
］にされたものを表すとする。
◎＼
</dd>

	<dt>~eof~token</dt>
	<dd>
入力~全体の終端を表現する~token。
◎＼
</dd>
</dl>

<p>
~tokenが発されたときは、`木~構築~段階$により即時に取扱われ~MUST。
木~構築~段階は、~token化~段階の`状態$に影響することもあり，~streamの中に追加の文字たちを挿入することもある（例えば， `script$e 要素は、
<a href="~HTML5/dynamic-markup-insertion.html#dynamic-markup-insertion">動的~markup挿入</a>
~APIを利用している~scriptを実行した結果、~token化された~streamの中に文字たちを挿入することもある。）
◎
When a token is emitted, it must immediately be handled by the tree construction stage. The tree construction stage can affect the state of the tokenization stage, and can insert additional characters into the stream. (For example, the script element can result in scripts executing and using the dynamic markup insertion APIs to insert characters into the stream being tokenized.)
</p>

<p class="note">注記：
~tokenを［
作成すること, 発すること
］は、別個の動作である。
~tokenは、作成されただけで発されることは決してなく，暗黙的に遺棄され得る
— 例：
開始tag~tokenに構文解析される文字たちを処理している間、当の~fileが予期せず終端した場合。
◎
Creating a token and emitting it are distinct actions. It is possible for a token to be created but implicitly abandoned (never emitted), e.g. if the file ends unexpectedly while processing the characters that are being parsed into a start tag token.
</p>

<ul>
	<li>
開始tag~tokenが［
その`自己閉じ~flag$ ~SET ~ON
］にされて発されたときは、それが木~構築~段階により処理されるときに［
~tokenの
`自己閉じ~flagを承認する@
］が行われていなければ，
`non-void-html-element-start-tag-with-trailing-solidus$pE
になるとする。
◎
When a start tag token is emitted with its self-closing flag set, if the flag is not acknowledged when it is processed by the tree construction stage, that is a non-void-html-element-start-tag-with-trailing-solidus parse error.
</li>
	<li>
属性を伴う終了tag~tokenが発されたときは、
`end-tag-with-attributes$pE
になるとする。
◎
When an end tag token is emitted with attributes, that is an end-tag-with-attributes parse error.
</li>
	<li>
終了tag~tokenが［
その`自己閉じ~flag$ ~SET ~ON
］にされて発されたときは、
`end-tag-with-trailing-solidus$pE
になるとする
◎
When an end tag token is emitted with its self-closing flag set, that is an end-tag-with-trailing-solidus parse error.
</li>
</ul>

<p>
終了tag~tokenは、次を満たすならば
`適切な終了tag~token@
とされる
⇒
この~tokenizerから，それまでに 1 個~以上の開始tag~tokenが発されていて，それらのうち最後に発されたものと 終了tag~tokenの~tag名は合致する
◎
An appropriate end tag token is an end tag token whose tag name matches the tag name of the last start tag to have been emitted from this tokenizer, if any. If no start tag has been emitted from this tokenizer, then no end tag token is appropriate.
</p>

<p>
`戻先~状態$V ~IN {
`二重引用符付き属性~値$st,
`一重引用符付き属性~値$st,
`引用符無し属性~値$st
}
にある下での`文字~参照$は、
`属性の一部として消費されて@
いるとされる。
◎
A character reference is said to be consumed as part of an attribute if the return state is either attribute value (double-quoted) state, attribute value (single-quoted) state or attribute value (unquoted) state.
</p>

<p class="algo-head">
ある`状態$の下で
`文字~参照として消費される~cpを一掃する@
と記された所では、次をし~MUST：
◎
When a state says to flush code points consumed as a character reference, it means that ＼</p>

<ol>
	<li>
<p>
`一時~buffer$V 内の ~EACH( `~cp$ %~cp ) に対し：
◎
for each code point in the temporary buffer (in the order they were added to the buffer) user agent must＼
</p>
		<ol>
			<li>
~IF［
当の文字~参照-は`属性の一部として消費されて$いる
］
⇒
現在の属性の値 ~APPEND %~cp
◎
append the code point from the buffer to the current attribute's value if the character reference was consumed as part of an attribute, or＼
</li>
			<li>
~ELSE
⇒
新たな文字~token( %~cp ) を発する
◎
emit the code point as a character token otherwise.
</li>
		</ol>
	</li>
</ol>

<p id="check-parser-pause-flag">
~UAは、~tokenizerを成す各~段の前に，次をし~MUST：
⇒
~IF［
%構文解析器 の`一時停止~flag$ ~EQ ~T
］
⇒
入子にされた~tokenizerの呼出があれば，その処理を中止して、~call元に制御を明け渡す
◎
Before each step of the tokenizer, the user agent must first check the parser pause flag. If it is true, then the tokenizer must abort the processing of any nested invocations of the tokenizer, yielding control back to the caller.
</p>

<p>
~tokenizerを成す状態~機械は、以下の各 下位節にて定義される各種
`状態@
からなる。
（ この頁~全体を通して、名前 X の`状態$は， `X^st のように表記される。）
◎
The tokenizer state machine consists of the states defined in the following subsections.
</p>


				<section id="data-state">
<h4 title="Data state">12.2.5.1. `~data^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0026^U</dt>
	<dd>
<ol ><li>`戻先~状態$V ~SET `~data$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the data state. Switch to the character reference state.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~tag~open$stに`切替える$
</li></ol>
◎
Switch to the tag open state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit the current input character as a character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="rcdata-state">
<h4 title="RCDATA state">12.2.5.2. `~RCDATA^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0026^U</dt>
	<dd>
<ol ><li>`戻先~状態$V ~SET `~RCDATA$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the RCDATA state. Switch to the character reference state.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~RCDATA~LTsign$stに`切替える$
</li></ol>
◎
Switch to the RCDATA less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="rawtext-state">
<h4 title="RAWTEXT state">12.2.5.3. `~RAWTEXT^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003C^U</dt>
	<dd>
<ol><li>`~RAWTEXT~LTsign$stに`切替える$
</li></ol>
◎
Switch to the RAWTEXT less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-state">
<h4 title="Script data state">12.2.5.4. `~script~data^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="plaintext-state">
<h4 title="PLAINTEXT state">12.2.5.5. `~PLAINTEXT^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>~eof~tokenを発する
</li></ol>
◎
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="tag-open-state">
<h4 title="Tag open state">12.2.5.6. `~tag~open^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0021^U</dt>
	<dd>
<ol><li>`~markup宣言~open$stに`切替える$
</li></ol>
◎
Switch to the markup declaration open state.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`終了tag~open$stに`切替える$
</li></ol>
◎
Switch to the end tag open state.
</dd>

	<dt>`~ASCII英字$</dt>
	<dd>
<ol ><li>新たな開始tag~token( 空~文字列 ) を作成する
</li><li>`~tag名$st内で`再消費-$する
</li></ol>
◎
Create a new start tag token, set its tag name to the empty string. Reconsume in the tag name state.
</dd>

	<dt>`003F^U</dt>
	<dd>
<ol><li>`unexpected-question-mark-instead-of-tag-name$pE
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`似非~comment$st内で`再消費-$する
</li></ol>
◎
This is an unexpected-question-mark-instead-of-tag-name parse error.
Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-before-tag-name$pE
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-before-tag-name parse error.
Emit a U+003C LESS-THAN SIGN character token and an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`invalid-first-character-of-tag-name$pE
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>`~data$st内で`再消費-$する
</li></ol>
◎
This is an invalid-first-character-of-tag-name parse error.
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the data state.
</dd>
</dl>

				</section>
				<section id="end-tag-open-state">
<h4 title="End tag open state">12.2.5.7. `終了tag~open^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol ><li>%~token ~LET 新たな終了tag~token()
</li><li>`~tag名$st内で`再消費-$する
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the tag name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-end-tag-name$pE
</li><li>`~data$stに`切替える$
</li></ol>
◎
This is a missing-end-tag-name parse error.
Switch to the data state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-before-tag-name$pE
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-before-tag-name parse error.
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token and an end-of-file token. 
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`invalid-first-character-of-tag-name$pE
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`似非~comment$st内で`再消費-$する
</li></ol>
◎
This is an invalid-first-character-of-tag-name parse error.
Create a comment token whose data is the empty string. Reconsume in the bogus comment state.
</dd>
</dl>

				</section>
				<section id="tag-name-state">
<h4 title="Tag name state">12.2.5.8. `~tag名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`属性~名の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute name state.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`自己閉じ開始tag$stに`切替える$
</li></ol>
◎
Switch to the self-closing start tag state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~tag~tokenの~tag名 ~APPEND `FFFD^U character
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current tag token's tag name.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name.
</dd>
</dl>

				</section>
				<section id="rcdata-less-than-sign-state">
<h4 title="RCDATA less-than sign state">12.2.5.9. `~RCDATA~LTsign^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol ><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~RCDATA終了tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the RCDATA end tag open state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>`~RCDATA$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RCDATA state.
</dd>
</dl>

				</section>
				<section id="rcdata-end-tag-open-state">
<h4 title="RCDATA end tag open state">12.2.5.10. `~RCDATA終了tag~open^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol ><li>%~token ~LET 新たな終了tag~token()
</li><li>`~RCDATA終了tag名$st内で`再消費-$する
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the RCDATA end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~RCDATA$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RCDATA state.
</dd>
</dl>

				</section>
				<section id="rcdata-end-tag-name-state">
<h4 title="RCDATA end tag name state">12.2.5.11. `~RCDATA終了tag名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`一時~buffer$V 内の~EACH( %文字 ) に対し
⇒
新たな文字~token( %文字 ) を発する
</li><li>`~RCDATA$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RCDATA state.
</dd>
</dl>

				</section>
				<section id="rawtext-less-than-sign-state">
<h4 title="RAWTEXT less-than sign state">12.2.5.12. `~RAWTEXT~LTsign^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol ><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~RAWTEXT終了tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the RAWTEXT end tag open state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>`~RAWTEXT$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the RAWTEXT state.
</dd>
</dl>

				</section>
				<section id="rawtext-end-tag-open-state">
<h4 title="RAWTEXT end tag open state">12.2.5.13. `~RAWTEXT終了tag~open^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol ><li>%~token ~LET 新たな終了tag~token()
</li><li>`~RAWTEXT終了tag名$st内で`再消費-$する
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the RAWTEXT end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~RAWTEXT$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the RAWTEXT state.
</dd>
</dl>

				</section>
				<section id="rawtext-end-tag-name-state">
<h4 title="RAWTEXT end tag name state">12.2.5.14. `~RAWTEXT終了tag名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
新たな文字~token( `003C^U ) を発する
</li>
			<li>
新たな文字~token( `002F^U ) を発する
</li>
			<li>
`一時~buffer$V 内の~EACH( %文字 ) に対し
⇒
新たな文字~token( %文字 ) を発する
</li>
			<li>
`~RAWTEXT$st内で`再消費-$する
</li>
		</ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the RAWTEXT state.
</dd>
</dl>

				</section>
				<section id="script-data-less-than-sign-state">
<h4 title="Script data less-than sign state">12.2.5.15. `~script~data~LTsign^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol ><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~script~data終了tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the script data end tag open state.
</dd>

	<dt>`0021^U</dt>
	<dd>
<ol ><li>`~script~data~escape始端$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `0021^U ) を発する
</li></ol>
◎
Switch to the script data escape start state. Emit a U+003C LESS-THAN SIGN character token and a U+0021 EXCLAMATION MARK character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>`~script~data$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-end-tag-open-state">
<h4 title="Script data end tag open state">12.2.5.16. `~script~data終了tag~open^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
<ol ><li>%~token ~LET 新たな終了tag~token()
</li><li>`~script~data終了tag名$st内で`再消費-$する
</li></ol>
◎
Create a new end tag token, set its tag name to the empty string. Reconsume in the script data end tag name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~script~data$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-end-tag-name-state">
<h4 title="Script data end tag name state">12.2.5.17. `~script~data終了tag名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
新たな文字~token( `003C^U ) を発する
</li>
			<li>
新たな文字~token( `002F^U ) を発する
</li>
			<li>
`一時~buffer$V 内の~EACH( %文字 ) に対し
⇒
新たな文字~token( %文字 ) を発する
</li>
			<li>
`~script~data$st内で`再消費-$する
</li>
		</ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-escape-start-state">
<h4 title="Script data escape start state">12.2.5.18. `~script~data~escape始端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>`~script~data~escape始端~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escape start dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data$st内で`再消費-$する
</li></ol>
◎
Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-escape-start-dash-state">
<h4 title="Script data escape start dash state">12.2.5.19. `~script~data~escape始端~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>`~script~data~escape済み~dash~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data$st内で`再消費-$する
</li></ol>
◎
Reconsume in the script data state.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-state">
<h4 title="Script data escaped state">12.2.5.20. `~script~data~escape済み^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>`~script~data~escape済み~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data escaped less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-dash-state">
<h4 title="Script data escaped dash state">12.2.5.21. `~script~data~escape済み~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>`~script~data~escape済み~dash~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data escaped less-than sign state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-dash-dash-state">
<h4 title="Script data escaped dash dash state">12.2.5.22. `~script~data~escape済み~dash~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>`~script~data~escape済み~LTsign$stに`切替える$
</li></ol>
◎
Switch to the script data escaped less-than sign state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~script~data$stに`切替える$
</li><li>新たな文字~token( `003E^U ) を発する
</li></ol>
◎
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Switch to the script data escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>`~script~data~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-less-than-sign-state">
<h4 title="Script data escaped less-than sign state">12.2.5.23. `~script~data escaped~LTsign^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol ><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~script~data~escape済み終了tag~open$stに`切替える$
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the script data escaped end tag open state.
</dd>

	<dt>`~ASCII英字$</dt>
	<dd>
<ol ><li>`一時~buffer$V ~SET 空~文字列
</li><li>新たな文字~token( `003C^U ) を発する
</li><li>`~script~data二重~escape始端$st内で`再消費-$する
</li></ol>
◎
Set the temporary buffer to the empty string. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data double escape start state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>`~script~data~escape済み$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token. Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-end-tag-open-state">
<h4 title="Script data escaped end tag open state">12.2.5.24. `~script~data~escape済み終了tag~open^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英字$</dt>
	<dd>
		<ol>
			<li>
%~token ~LET 新たな終了tag~token()
</li>
			<li>
`~script~data~escape済み終了tag名$st内で`再消費-$する
</li>
		</ol>

<p>
（ %~token はまだ発しないこと
— %~token の詳細は，それが発される前に埋められることになる。）
</p>
◎
Create a new end tag token. Reconsume in the script data escaped end tag name state. (Don't emit the token yet; further details will be filled in before it is emitted.)
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `003C^U ) を発する
</li><li>新たな文字~token( `002F^U ) を発する
</li><li>`~script~data~escape済み$st内で`再消費-$する
</li></ol>
◎
Emit a U+003C LESS-THAN SIGN character token and a U+002F SOLIDUS character token. Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-escaped-end-tag-name-state">
<h4 title="Script data escaped end tag name state">12.2.5.25. `~script~data~escape済み終了tag名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`属性~名の前$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the before attribute name state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`002F^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`自己閉じ開始tag$stに`切替える$
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the self-closing start tag state. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
~IF［
現在の終了tag~tokenは`適切な終了tag~token$でない
］
⇒
~GOTO ~AnyElse
</li>
			<li>
`~data$stに`切替える$
</li>
			<li>
現在の~tag~tokenを発する
</li>
		</ol>
◎
If the current end tag token is an appropriate end tag token, then switch to the data state and emit the current tag token. Otherwise, treat it as per the "anything else" entry below.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol ><li>現在の~tag~tokenの~tag名 ~APPEND `現在の入力~文字$
</li><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current tag token's tag name. Append the current input character to the temporary buffer.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
新たな文字~token( `003C^U ) を発する
</li>
			<li>
新たな文字~token( `002F^U ) を発する
</li>
			<li>
`一時~buffer$V 内の~EACH( %文字 ) に対し
⇒
新たな文字~token( %文字 ) を発する
</li>
			<li>
`~script~data~escape済み$st内で`再消費-$する
</li>
		</ol>
◎
Emit a U+003C LESS-THAN SIGN character token, a U+002F SOLIDUS character token, and a character token for each of the characters in the temporary buffer (in the order they were added to the buffer). Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-double-escape-start-state">
<h4 title="Script data double escape start state">12.2.5.26. `~script~data二重~escape始端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`一時~buffer$V ~EQ `script^l
］：
</p>
<ol ><li>`~script~data二重~escape済み$stに`切替える$
</li><li>~RET
</li></ol>

</li>
			<li>
`~script~data~escape済み$stに`切替える$
</li>
			<li>
新たな文字~token( `現在の入力~文字$ ) を発する
</li>
		</ol>
◎
If the temporary buffer is the string "script", then switch to the script data double escaped state. Otherwise, switch to the script data escaped state. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>`一時~buffer$V ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol ><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the current input character to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data~escape済み$st内で`再消費-$する
</li></ol>
◎
Reconsume in the script data escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-state">
<h4 title="Script data double escaped state">12.2.5.27. `~script~data二重~escape済み^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data double escaped dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み~LTsign$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li></ol>
◎
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-dash-state">
<h4 title="Script data double escaped dash state">12.2.5.28. `~script~data二重~escape済み~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み~dash~dash$stに`切替える$
</li><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Switch to the script data double escaped dash dash state. Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み~LTsign$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li></ol>
◎
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data double escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-dash-dash-state">
<h4 title="Script data double escaped dash dash state">12.2.5.29. `~script~data二重~escape済み~dash~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>新たな文字~token( `002D^U ) を発する
</li></ol>
◎
Emit a U+002D HYPHEN-MINUS character token.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み~LTsign$stに`切替える$
</li><li>新たな文字~token( `003C^U ) を発する
</li></ol>
◎
Switch to the script data double escaped less-than sign state. Emit a U+003C LESS-THAN SIGN character token.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~script~data$stに`切替える$
</li><li>新たな文字~token( `003E^U ) を発する
</li></ol>
◎
Switch to the script data state. Emit a U+003E GREATER-THAN SIGN character token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `FFFD^U ) を発する
</li></ol>
◎
This is an unexpected-null-character parse error.
Switch to the script data double escaped state. Emit a U+FFFD REPLACEMENT CHARACTER character token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-script-html-comment-like-text$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-script-html-comment-like-text parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>`~script~data二重~escape済み$stに`切替える$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Switch to the script data double escaped state. Emit the current input character as a character token.
</dd>
</dl>

				</section>
				<section id="script-data-double-escaped-less-than-sign-state">
<h4 title="Script data double escaped less-than sign state">12.2.5.30. `~script~data二重~escape済み~LTsign^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002F^U</dt>
	<dd>
<ol ><li>`一時~buffer$V ~SET 空~文字列
</li><li>`~script~data二重~escape終端$stに`切替える$
</li><li>新たな文字~token( `002F^U ) を発する
</li></ol>
◎
Set the temporary buffer to the empty string. Switch to the script data double escape end state. Emit a U+002F SOLIDUS character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data二重~escape済み$st内で`再消費-$する
</li></ol>
◎
Reconsume in the script data double escaped state.
</dd>
</dl>

				</section>
				<section id="script-data-double-escape-end-state">
<h4 title="Script data double escape end state">12.2.5.31. `~script~data二重~escape終端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`一時~buffer$V ~EQ `script^l
］：
</p>
<ol ><li>`~script~data~escape済み$stに`切替える$
</li><li>~RET
</li></ol>
			</li>
			<li>
`~script~data二重~escape済み$stに`切替える$
</li>
			<li>
新たな文字~token( `現在の入力~文字$ ) を発する
</li>
		</ol>
◎
If the temporary buffer is the string "script", then switch to the script data escaped state. Otherwise, switch to the script data double escaped state. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>`一時~buffer$V ~APPEND `現在の入力~文字$ に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>`~ASCII英小文字$</dt>
	<dd>
<ol ><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Append the current input character to the temporary buffer. Emit the current input character as a character token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~script~data二重~escape済み$st内で`再消費-$する
</li></ol>
◎
Reconsume in the script data double escaped state.
</dd>
</dl>

				</section>
				<section id="before-attribute-name-state">
<h4 title="Before attribute name state">12.2.5.32. `属性~名の前^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dt>~EOF</dt>
	<dd>
<ol><li>`属性~名の後$st内で`再消費-$する
</li></ol>
◎
Reconsume in the after attribute name state.
</dd>

	<dt>`003D^U</dt>
	<dd>
<ol><li>`unexpected-equals-sign-before-attribute-name$pE
</li><li>現在の~tag~token内で新たな属性( 名前 ~SET `現在の入力~文字$, 値 ~SET 空~文字列 ) を開始する
</li><li>`属性~名$stに`切替える$
</li></ol>
◎
This is an unexpected-equals-sign-before-attribute-name parse error.
Start a new attribute in the current tag token. Set that attribute's name to the current input character, and its value to the empty string. Switch to the attribute name state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>現在の~tag~token内で新たな属性( 名前 ~SET 空~文字列, 値 ~SET 空~文字列 ) を開始する
</li><li>`属性~名$st内で`再消費-$する
</li></ol>
◎
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
</dd>
</dl>

				</section>
				<section id="attribute-name-state">
<h4 title="Attribute name state">12.2.5.33. `属性~名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dt>`002F^U</dt>
	<dt>`003E^U</dt>
	<dt>~EOF</dt>
	<dd>
<ol><li>`属性~名の後$st内で`再消費-$する
</li></ol>
◎
Reconsume in the after attribute name state.
</dd>

	<dt>`003D^U</dt>
	<dd>
<ol><li>`属性~値の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute value state.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の属性の名前 ~APPEND `現在の入力~文字$ に対応する小文字（文字の~cpに `0020^X を加算する）
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current attribute's name.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の名前 ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's name.
</dd>

	<dt>`0022^U</dt>
	<dt>`0027^U</dt>
	<dt>`003C^U</dt>
	<dd>
<ol><li>`unexpected-character-in-attribute-name$pE
</li><li>~GOTO ~AnyElse
</li></ol>
◎
This is an unexpected-character-in-attribute-name parse error.
Treat it as per the "anything else" entry below.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の名前 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's name.
</dd>
</dl>

<p>
~UAは，`属性~名$stから去るときには（および，適切になるなら、現在の~tag~tokenを発する前に）、現在の~tag~token上の属性たちの完全な名前どうしを比較し~MUST。
正確に同じ名前の属性が~token上にすでにある場合、
`duplicate-attribute$pE
になり，新たな
【後から追加された】
属性は~tokenから除去され~MUST。
◎
When the user agent leaves the attribute name state (and before emitting the tag token, if appropriate), the complete attribute's name must be compared to the other attributes on the same token; if there is already an attribute on the token with the exact same name, then this is a duplicate-attribute parse error and the new attribute must be removed from the token.
</p>

<p class="note">注記：
ある属性が ~tokenからそのように除去された場合、それに対応する値は，あっても
構文解析器により後続して利用されることは決してなく、実質的に破棄される。
しかしながら，この仕方で属性を除去しても、~tokenizerの目的における “現在の属性” としての地位は変化しない。
◎
If an attribute is so removed from a token, it, and the value that gets associated with it, if any, are never subsequently used by the parser, and are therefore effectively discarded. Removing the attribute in this way does not change its status as the "current attribute" for the purposes of the tokenizer, however.
</p>

				</section>
				<section id="after-attribute-name-state">
<h4 title="After attribute name state">12.2.5.34. `属性~名の後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`自己閉じ開始tag$stに`切替える$
</li></ol>
◎
Switch to the self-closing start tag state.
</dd>

	<dt>`003D^U</dt>
	<dd>
<ol><li>`属性~値の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute value state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>現在の~tag~token内で新たな属性( 名前 ~SET 空~文字列, 値 ~SET 空~文字列 ) を開始する
</li><li>`属性~名$st内で`再消費-$する
</li></ol>
◎
Start a new attribute in the current tag token. Set that attribute name and value to the empty string. Reconsume in the attribute name state.
</dd>
</dl>

				</section>
				<section id="before-attribute-value-state">
<h4 title="Before attribute value state">12.2.5.35. `属性~値の前^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`二重引用符付き属性~値$stに`切替える$
</li></ol>
◎
Switch to the attribute value (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`一重引用符付き属性~値$stに`切替える$
</li></ol>
◎
Switch to the attribute value (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-attribute-value$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
This is a missing-attribute-value parse error.
Switch to the data state. Emit the current tag token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`引用符無し属性~値$st内で`再消費-$する
</li></ol>
◎
Reconsume in the attribute value (unquoted) state.
</dd>
</dl>

				</section>
				<section id="attribute-value-(double-quoted)-state">
<h4 title="Attribute value (double-quoted) state">12.2.5.36. `二重引用符付き属性~値^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0022^U</dt>
	<dd>
<ol><li>`引用符付き属性~値の後$stに`切替える$
</li></ol>
◎
Switch to the after attribute value (quoted) state.
</dd>

	<dt>`0026^U</dt>
	<dd>
<ol ><li>`戻先~状態$V ~SET `二重引用符付き属性~値$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the attribute value (double-quoted) state. Switch to the character reference state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の値 ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の値 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's value.
</dd>
</dl>

				</section>
				<section id="attribute-value-(single-quoted)-state">
<h4 title="Attribute value (single-quoted) state">12.2.5.37. `一重引用符付き属性~値^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0027^U</dt>
	<dd>
<ol><li>`引用符付き属性~値の後$stに`切替える$
</li></ol>
◎
Switch to the after attribute value (quoted) state.
</dd>

	<dt>`0026^U</dt>
	<dd>
<ol ><li>`戻先~状態$V ~SET `一重引用符付き属性~値$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the attribute value (single-quoted) state. Switch to the character reference state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の値 ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の値 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's value.
</dd>
</dl>

				</section>
				<section id="attribute-value-(unquoted)-state">
<h4 title="Attribute value (unquoted) state">12.2.5.38. `引用符無し属性~値^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`属性~名の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute name state.
</dd>

	<dt>`0026^U</dt>
	<dd>
<ol ><li>`戻先~状態$V ~SET `引用符無し属性~値$st
</li><li>`文字~参照$stに`切替える$
</li></ol>
◎
Set the return state to the attribute value (unquoted) state. Switch to the character reference state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の属性の値 ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current attribute's value.
</dd>

	<dt>`0022^U</dt>
	<dt>`0027^U</dt>
	<dt>`003C^U</dt>
	<dt>`003D^U</dt>
	<dt>`0060^U</dt>
	<dd>
<ol><li>`unexpected-character-in-unquoted-attribute-value$pE
</li><li>~GOTO ~AnyElse
</li></ol>
◎
This is an unexpected-character-in-unquoted-attribute-value parse error.
Treat it as per the "anything else" entry below.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の属性の値 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current attribute's value.
</dd>
</dl>

				</section>
				<section id="after-attribute-value-(quoted)-state">
<h4 title="After attribute value (quoted) state">12.2.5.39. `引用符付き属性~値の後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`属性~名の前$stに`切替える$
</li></ol>
◎
Switch to the before attribute name state.
</dd>

	<dt>`002F^U</dt>
	<dd>
<ol><li>`自己閉じ開始tag$stに`切替える$
</li></ol>
◎
Switch to the self-closing start tag state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current tag token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-whitespace-between-attributes$pE
</li><li>`属性~名の前$st内で`再消費-$する
</li></ol>
◎
This is a missing-whitespace-between-attributes parse error.
Reconsume in the before attribute name state.
</dd>
</dl>

				</section>
				<section id="self-closing-start-tag-state">
<h4 title="Self-closing start tag state">12.2.5.40. `自己閉じ開始tag^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol ><li>現在の~tag~tokenの`自己閉じ~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~tag~tokenを発する
</li></ol>
◎
Set the self-closing flag of the current tag token. Switch to the data state. Emit the current tag token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-tag$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-tag parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`unexpected-solidus-in-tag$pE
</li><li>`属性~名の前$st内で`再消費-$する
</li></ol>
◎
This is an unexpected-solidus-in-tag parse error.
Reconsume in the before attribute name state.
</dd>
</dl>

				</section>
				<section id="bogus-comment-state">
<h4 title="Bogus comment state">12.2.5.41. `似非~comment^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the comment token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol ><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
Emit the comment. Emit an end-of-file token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~comment~tokenの~data ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the comment token's data.
</dd>
</dl>

				</section>
				<section id="markup-declaration-open-state">
<h4 title="Markup declaration open state">12.2.5.42. `~markup宣言~open^st</h4>

<p>
次n少数の文字に応じて：
◎
If the next few characters are:
</p>

<dl class="switch">
	<dt>
2 個の `002D^U
◎
Two U+002D HYPHEN-MINUS characters (-)
</dt>
	<dd>
<ol ><li>それらの文字を消費する
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`~comment始端$stに`切替える$
</li></ol>
◎
Consume those two characters, create a comment token whose data is the empty string, and switch to the comment start state.
</dd>

	<dt>
`~ASCII大小無視$で `DOCTYPE^l に合致する
◎
ASCII case-insensitive match for the word "DOCTYPE"
</dt>
	<dd>
<ol ><li>それらの文字を消費する
</li><li>`~DOCTYPE$stに`切替える$
</li></ol>
◎
Consume those characters and switch to the DOCTYPE state.
</dd>

	<dt>
文字列 `[CDATA[^l
◎
Case-sensitive match for the string "[CDATA[" (the five uppercase letters "CDATA" with a U+005B LEFT SQUARE BRACKET character before and after)
</dt>
	<dd>
		<ol>
			<li>
それらの文字を消費する
◎
Consume those characters.＼
</li>
			<li>
<p>
~IF［
`現在の調整-済み~node$がある
］~AND［
それは`~HTML名前空間$に属する要素でない
］：
</p>
<ol ><li>`~CDATAsec$stに`切替える$
</li><li>~RET
</li></ol>

◎
If there is an adjusted current node and it is not an element in the HTML namespace, then switch to the CDATA section state.＼
</li>
			<li>
`cdata-in-html-content$pE
◎
Otherwise, this is a cdata-in-html-content parse error.＼
</li>
			<li>
新たな~comment~token( `[CDATA[^l ) を作成する
◎
Create a comment token whose data is the "[CDATA[" string.＼
</li>
			<li>
`似非~comment$stに`切替える$
◎
Switch to the bogus comment state.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`incorrectly-opened-comment$pE
</li><li>新たな~comment~token( 空~文字列 ) を作成する
</li><li>`似非~comment$stに`切替える$
</li></ol>
<p>
（現在の状態~内では何も消費しないこと。）
</p>
◎
This is an incorrectly-opened-comment parse error.
Create a comment token whose data is the empty string. Switch to the bogus comment state (don't consume anything in the current state).
</dd>
</dl>

				</section>
				<section id="comment-start-state">
<h4 title="Comment start state">12.2.5.43. `~comment始端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment始端~dash$stに`切替える$
</li></ol>
◎
Switch to the comment start dash state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-closing-of-empty-comment$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
This is an abrupt-closing-of-empty-comment parse error.
Switch to the data state. Emit the comment token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-start-dash-state">
<h4 title="Comment start dash state">12.2.5.44. `~comment始端~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment終端$stに`切替える$
</li></ol>
◎
Switch to the comment end state
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-closing-of-empty-comment$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
This is an abrupt-closing-of-empty-comment parse error.
Switch to the data state. Emit the comment token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.
Emit the comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `002D^U 
</li><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-state">
<h4 title="Comment state">12.2.5.45 `~comment^st</h4>
<a id="comment"></a>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003C^U</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li><li>`~comment~LTsign$stに`切替える$
</li></ol>
◎
Append the current input character to the comment token's data. Switch to the comment less-than sign state.
</dd>

	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment終端~dash$stに`切替える$
</li></ol>
◎
Switch to the comment end dash state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~comment~tokenの~data ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the comment token's data.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.
Emit the comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the comment token's data.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-state">
<h4 title="Comment less-than sign state">12.2.5.46. `~comment~LTsign^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0021^U</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li><li>`~comment~LTsign~bang$stに`切替える$
</li></ol>
◎
Append the current input character to the comment token's data. Switch to the comment less-than sign bang state.
</dd>

	<dt>`003C^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the comment token's data.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-bang-state">
<h4 title="Comment less-than sign bang state">12.2.5.47. `~comment~LTsign~bang^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment~LTsign~bang~dash$stに`切替える$
</li></ol>
◎
Switch to the comment less-than sign bang dash state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-bang-dash-state">
<h4 title="Comment less-than sign bang dash state">12.2.5.48. `~comment~LTsign~bang~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment~LTsign~bang~dash~dash$stに`切替える$
</li></ol>
◎
Switch to the comment less-than sign bang dash dash state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~comment終端~dash$st内で`再消費-$する
</li></ol>
◎
Reconsume in the comment end dash state.
</dd>
</dl>

				</section>
				<section id="comment-less-than-sign-bang-dash-dash-state">
<h4 title="Comment less-than sign bang dash dash state">12.2.5.49. `~comment~LTsign~bang~dash~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dt>~EOF</dt>
	<dd>
<ol><li>`~comment終端$st内で`再消費-$する
</li></ol>
◎
Reconsume in the comment end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`nested-comment$pE
</li><li>`~comment終端$st内で`再消費-$する
</li></ol>
◎
This is a nested-comment parse error.
Reconsume in the comment end state.
</dd>
</dl>

				</section>
				<section id="comment-end-dash-state">
<h4 title="Comment end dash state">12.2.5.50. `~comment終端~dash^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol><li>`~comment終端$stに`切替える$
</li></ol>
◎
Switch to the comment end state
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.
Emit the comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `002D^U 
</li><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-end-state">
<h4 title="Comment end state">12.2.5.51. `~comment終端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the comment token.
</dd>

	<dt>`0021^U</dt>
	<dd>
<ol><li>`~comment終端~bang$stに`切替える$
</li></ol>
◎
Switch to the comment end bang state.
</dd>

	<dt>`002D^U</dt>
	<dd>
<ol><li>現在の~comment~tokenの~data ~APPEND `002D^U
</li></ol>
◎
Append a U+002D HYPHEN-MINUS character (-) to the comment token's data.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.
Emit the comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `002D^U ~APPEND `002D^U
</li><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Append two U+002D HYPHEN-MINUS characters (-) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="comment-end-bang-state">
<h4 title="Comment end bang state">12.2.5.52. `~comment終端~bang^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`002D^U</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `002D^U ~APPEND `0021^U
</li><li>`~comment終端~dash$stに`切替える$
</li></ol>
◎
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Switch to the comment end dash state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`incorrectly-closed-comment$pE
</li><li>`~data$stに`切替える$
</li><li>現在の~comment~tokenを発する
</li></ol>
◎
This is an incorrectly-closed-comment parse error.
Switch to the data state. Emit the comment token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-comment$pE
</li><li>現在の~comment~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-comment parse error.
Emit the comment token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>現在の~comment~tokenの~data ~APPEND `002D^U ~APPEND `0021^U 
</li><li>`~comment$st内で`再消費-$する
</li></ol>
◎
Append two U+002D HYPHEN-MINUS characters (-) and a U+0021 EXCLAMATION MARK character (!) to the comment token's data. Reconsume in the comment state.
</dd>
</dl>

				</section>
				<section id="doctype-state">
<h4 title="DOCTYPE state">12.2.5.53. `~DOCTYPE^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE名の前$stに`切替える$
</li></ol>
◎
Switch to the before DOCTYPE name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~DOCTYPE名の前$st内で`再消費-$する
</li></ol>
◎
Reconsume in the before DOCTYPE name state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>`過去互換強制~flag$ ~SET ~ON
</li><li>%~token を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-whitespace-before-doctype-name$pE
</li><li>`~DOCTYPE名の前$st内で`再消費-$する
</li></ol>
◎
This is a missing-whitespace-before-doctype-name parse error.
Reconsume in the before DOCTYPE name state.
</dd>
</dl>

				</section>
				<section id="before-doctype-name-state">
<h4 title="Before DOCTYPE name state">12.2.5.54. `~DOCTYPE名の前^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol ><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>%~token の名前 ~SET `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li><li>`~DOCTYPE名$stに`切替える$
</li></ol>
◎
Create a new DOCTYPE token. Set the token's name to the lowercase version of the current input character (add 0x0020 to the character's code point). Switch to the DOCTYPE name state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>%~token の名前 ~SET `FFFD^U
</li><li>`~DOCTYPE名$stに`切替える$
</li></ol>
◎
This is an unexpected-null-character parse error.
Create a new DOCTYPE token. Set the token's name to a U+FFFD REPLACEMENT CHARACTER character. Switch to the DOCTYPE name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-name$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>%~token を発する
</li></ol>
◎
This is a missing-doctype-name parse error.
Create a new DOCTYPE token. Set its force-quirks flag to on. Switch to the data state. Emit the token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>`過去互換強制~flag$ ~SET ~ON
</li><li>%~token を発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Create a new DOCTYPE token. Set its force-quirks flag to on. Emit the token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>%~token ~LET 新たな~DOCTYPE~token
</li><li>%~token の名前 ~SET `現在の入力~文字$
</li><li>`~DOCTYPE名$stに`切替える$
</li></ol>
◎
Create a new DOCTYPE token. Set the token's name to the current input character. Switch to the DOCTYPE name state.
</dd>
</dl>

				</section>
				<section id="doctype-name-state">
<h4 title="DOCTYPE name state">12.2.5.55. `~DOCTYPE名^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE名の後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE name state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>`~ASCII英大文字$</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの名前 ~APPEND `現在の入力~文字$に対応する小文字（文字の~cpに `0020^X を加算する）
</li></ol>
◎
Append the lowercase version of the current input character (add 0x0020 to the character's code point) to the current DOCTYPE token's name.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの名前 ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's name.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの名前 ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's name.
</dd>
</dl>

				</section>
				<section id="after-doctype-name-state">
<h4 title="After DOCTYPE name state">12.2.5.56. `~DOCTYPE名の後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［［
`現在の入力~文字$から開始する 6 個の文字~並び
］ ~EQ`大小無視$sub `PUBLIC^l
］：
</p>
<ol ><li>それらの文字を消費する
</li><li>`~DOCTYPE~public-keywordの後$stに`切替える$
</li></ol>
◎
If the six characters starting from the current input character are an ASCII case-insensitive match for the word "PUBLIC", then consume those characters and switch to the after DOCTYPE public keyword state.
</li>
			<li>
<p>
~ELIF［［
`現在の入力~文字$から開始する 6 個の文字~並び
］ ~EQ`大小無視$sub `SYSTEM^l
］：
</p>
<ol ><li>それらの文字を消費する
</li><li>`~DOCTYPE~system-keywordの後$stに`切替える$
</li></ol>
◎
Otherwise, if the six characters starting from the current input character are an ASCII case-insensitive match for the word "SYSTEM", then consume those characters and switch to the after DOCTYPE system keyword state.
</li>
			<li>
<p>
~ELSE：
</p>

<ol ><li>`invalid-character-sequence-after-doctype-name$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
Otherwise, this is an invalid-character-sequence-after-doctype-name parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</li>
		</ol>
	</dd>
</dl>

				</section>
				<section id="after-doctype-public-keyword-state">
<h4 title="After DOCTYPE public keyword state">12.2.5.57. `~DOCTYPE~public-keywordの後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDの前$stに`切替える$
</li></ol>
◎
Switch to the before DOCTYPE public identifier state.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-public-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（二重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-public-keyword parse error.
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-public-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（一重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-public-keyword parse error.
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-public-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
This is a missing-quote-before-doctype-public-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="before-doctype-public-identifier-state">
<h4 title="Before DOCTYPE public identifier state">12.2.5.58. `~DOCTYPE~publicIDの前^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（二重引用符）$stに`切替える$
</li></ol>
◎
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenの~publicID ~SET 空~文字列
</li><li>`~DOCTYPE~publicID（一重引用符）$stに`切替える$
</li></ol>
◎
Set the DOCTYPE token's public identifier to the empty string (not missing), then switch to the DOCTYPE public identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-public-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
This is a missing-quote-before-doctype-public-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="doctype-public-identifier-(double-quoted)-state">
<h4 title="DOCTYPE public identifier (double-quoted) state">12.2.5.59. `~DOCTYPE~publicID（二重引用符）^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0022^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE public identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-public-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's public identifier.
</dd>
</dl>

				</section>
				<section id="doctype-public-identifier-(single-quoted)-state">
<h4 title="DOCTYPE public identifier (single-quoted) state">12.2.5.60. `~DOCTYPE~publicID（一重引用符）^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0027^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE public identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `FFFD^U 
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's public identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-public-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-public-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~publicID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's public identifier.
</dd>
</dl>

				</section>
				<section id="after-doctype-public-identifier-state">
<h4 title="After DOCTYPE public identifier state">12.2.5.61. `~DOCTYPE~publicIDの後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE~publicIDと~systemIDの合間$stに`切替える$
</li></ol>
◎
Switch to the between DOCTYPE public and system identifiers state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`missing-whitespace-between-doctype-public-and-system-identifiers$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error.
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`missing-whitespace-between-doctype-public-and-system-identifiers$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-between-doctype-public-and-system-identifiers parse error.
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="between-doctype-public-and-system-identifiers-state">
<h4 title="Between DOCTYPE public and system identifiers state">12.2.5.62. `~DOCTYPE~publicIDと~systemIDの合間^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="after-doctype-system-keyword-state">
<h4 title="After DOCTYPE system keyword state">12.2.5.63. `~DOCTYPE~system-keywordの後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>`~DOCTYPE~systemIDの前$stに`切替える$
</li></ol>
◎
Switch to the before DOCTYPE system identifier state.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-system-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-system-keyword parse error.
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol><li>`missing-whitespace-after-doctype-system-keyword$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
This is a missing-whitespace-after-doctype-system-keyword parse error.
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="before-doctype-system-identifier-state">
<h4 title="Before DOCTYPE system identifier state">12.2.5.64. `~DOCTYPE~systemIDの前^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`0022^U</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（二重引用符）$stに`切替える$
</li></ol>
◎
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (double-quoted) state.
</dd>

	<dt>`0027^U</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenの~systemID ~SET 空~文字列
</li><li>`~DOCTYPE~systemID（一重引用符）$stに`切替える$
</li></ol>
◎
Set the DOCTYPE token's system identifier to the empty string (not missing), then switch to the DOCTYPE system identifier (single-quoted) state.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`missing-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is a missing-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-quote-before-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`似非~DOCTYPE$st内で`再消費-$する
</li></ol>
◎
This is a missing-quote-before-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Reconsume in the bogus DOCTYPE state.
</dd>
</dl>

				</section>
				<section id="doctype-system-identifier-(double-quoted)-state">
<h4 title="DOCTYPE system identifier (double-quoted) state">12.2.5.65. `~DOCTYPE~systemID（二重引用符）^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0022^U</dt>
	<dd>
<ol><li>`~DOCTYPE~systemIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE system identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's system identifier.
</dd>
</dl>

				</section>
				<section id="doctype-system-identifier-(single-quoted)-state">
<h4 title="DOCTYPE system identifier (single-quoted) state">12.2.5.66. `~DOCTYPE~systemID（一重引用符）^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0027^U</dt>
	<dd>
<ol><li>`~DOCTYPE~systemIDの後$stに`切替える$
</li></ol>
◎
Switch to the after DOCTYPE system identifier state.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `FFFD^U
</li></ol>
◎
This is an unexpected-null-character parse error.
Append a U+FFFD REPLACEMENT CHARACTER character to the current DOCTYPE token's system identifier.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`abrupt-doctype-system-identifier$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
This is an abrupt-doctype-system-identifier parse error.
Set the DOCTYPE token's force-quirks flag to on. Switch to the data state. Emit that DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>現在の~DOCTYPE~tokenの~systemID ~APPEND `現在の入力~文字$
</li></ol>
◎
Append the current input character to the current DOCTYPE token's system identifier.
</dd>
</dl>

				</section>
				<section id="after-doctype-system-identifier-state">
<h4 title="After DOCTYPE system identifier state">12.2.5.67. `~DOCTYPE~systemIDの後^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`0009^U</dt>
	<dt>`000A^U</dt>
	<dt>`000C^U</dt>
	<dt>`0020^U</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the current DOCTYPE token.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-doctype$pE
</li><li>現在の~DOCTYPE~tokenの`過去互換強制~flag$ ~SET ~ON
</li><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-doctype parse error.
Set the DOCTYPE token's force-quirks flag to on. Emit that DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`unexpected-character-after-doctype-system-identifier$pE
</li><li>`似非~DOCTYPE$st内で`再消費-$する
（これは、現在の~DOCTYPE~tokenの`過去互換強制~flag$を <em>~ON にしない</em>。）
</li></ol>
◎
This is an unexpected-character-after-doctype-system-identifier parse error.
Reconsume in the bogus DOCTYPE state. (This does not set the DOCTYPE token's force-quirks flag to on.)
</dd>
</dl>

				</section>
				<section id="bogus-doctype-state">
<h4 title="Bogus DOCTYPE state">12.2.5.68. `似非~DOCTYPE^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`003E^U</dt>
	<dd>
<ol ><li>`~data$stに`切替える$
</li><li>現在の~DOCTYPE~tokenを発する
</li></ol>
◎
Switch to the data state. Emit the DOCTYPE token.
</dd>

	<dt>`0000^U</dt>
	<dd>
<ol><li>`unexpected-null-character$pE
</li><li>この文字は無視する
</li></ol>
◎
This is an unexpected-null-character parse error.
Ignore the character.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol ><li>現在の~DOCTYPE~tokenを発する
</li><li>~eof~tokenを発する
</li></ol>
◎
Emit the DOCTYPE token. Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>この文字は無視する
</li></ol>
◎
Ignore the character.
</dd>
</dl>

				</section>
				<section id="cdata-section-state">
<h4 title="CDATA section state">12.2.5.69. `~CDATAsec^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`005D^U</dt>
	<dd>
<ol><li>`~CDATAsec~bracket$stに`切替える$
</li></ol>
◎
Switch to the CDATA section bracket state.
</dd>

	<dt>~EOF</dt>
	<dd>
<ol><li>`eof-in-cdata$pE
</li><li>~eof~tokenを発する
</li></ol>
◎
This is an eof-in-cdata parse error.
Emit an end-of-file token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>新たな文字~token( `現在の入力~文字$ ) を発する
</li></ol>
◎
Emit the current input character as a character token.
</dd>
</dl>

<p class="note">注記：
`0000^U は、木~構築~段階にて，`外来~内容~内$md内の一部として取扱われる
— それは、`~CDATAsec$が現れ得る唯一の箇所である
◎
U+0000 NULL characters are handled in the tree construction stage, as part of the in foreign content insertion mode, which is the only place where CDATA sections can appear.
</p>

				</section>
				<section id="cdata-section-bracket-state">
<h4 title="CDATA section bracket state">12.2.5.70. `~CDATAsec~bracket^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`005D^U</dt>
	<dd>
<ol><li>`~CDATAsec終端$stに`切替える$
</li></ol>
◎
Switch to the CDATA section end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `005D^U ) を発する
</li><li>`~CDATAsec$st内で`再消費-$する
</li></ol>
◎
Emit a U+005D RIGHT SQUARE BRACKET character token. Reconsume in the CDATA section state.
</dd>
</dl>

				</section>
				<section id="cdata-section-end-state">
<h4 title="CDATA section end state">12.2.5.71. `~CDATAsec終端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`005D^U</dt>
	<dd>
<ol><li>新たな文字~token( `005D^U ) を発する
</li></ol>
◎
Emit a U+005D RIGHT SQUARE BRACKET character token.
</dd>

	<dt>`003E^U</dt>
	<dd>
<ol><li>`~data$stに`切替える$
</li></ol>
◎
Switch to the data state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>新たな文字~token( `005D^U ) を発する
</li><li>新たな文字~token( `005D^U ) を発する
</li><li>`~CDATAsec$st内で`再消費-$する
</li></ol>
◎
Emit two U+005D RIGHT SQUARE BRACKET character tokens. Reconsume in the CDATA section state.
</dd>
</dl>

				</section>
				<section id="character-reference-state">
<h4 title="Character reference state">12.2.5.72. `文字~参照^st</h4>

<ol>
	<li>
`一時~buffer$V ~SET 空~文字列
~APPEND `0026^U
~APPEND `現在の入力~文字$
◎
Set the temporary buffer to the empty string. Append a U+0026 AMPERSAND (&amp;) character to the temporary buffer.＼
</li>
	<li>
<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

		<dl class="switch">
			<dt>`~ASCII英数字$</dt>
			<dd>
<ol ><li>`有名~文字~参照$st内で`再消費-$する
</li></ol>
◎
Reconsume in the named character reference state.
</dd>

			<dt>`0023^U</dt>
			<dd>
<ol ><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>`数的な文字~参照$stに`切替える$
</li></ol>
◎
Append the current input character to the temporary buffer. Switch to the numeric character reference state.
</dd>

			<dt>~AnyElse</dt>
			<dd>
<ol ><li>`文字~参照として消費される~cpを一掃する$
</li><li>`戻先~状態$V 内で`再消費-$する
</li></ol>
◎
Flush code points consumed as a character reference. Reconsume in the return state.
</dd>
		</dl>
	</li>
</ol>


				</section>
				<section id="named-character-reference-state">
<h4 title="Named character reference state">12.2.5.73. `有名~文字~参照^st</h4>

<ol>
	<li>
<p>
%識別子 ~LET 次の条件を満たすような，可能な限り最大~個数の文字を消費して得られる文字列
⇒
消費して得られた文字列 ~IN 次に挙げる文字列からなる集合：
</p>

<ul ><li>`有名~文字~参照$ 一覧の 1 列目に挙げられている識別子に~semicolon（ `003B^U ）を付加したもの
</li><li>同じ一覧の 1 列目に挙げられている識別子のうち，“†” が付与されているもの（~markup内で~semicolonを省略しても有効になるもの）
</li><li>空~文字列
</li></ul>

<p class="trans-note">【
この訳における有名~文字~参照の一覧は、~semicolonを省略している（  “†” に代えている）ため、この段の記述は，それに整合するように原文と違えている。
】</p>

◎
Consume the maximum number of characters possible, with the consumed characters matching one of the identifiers in the first column of the named character references table (in a case-sensitive manner). Append each character to the temporary buffer when it's consumed.
</li>
	<li>
<p>
~IF［
%識別子 ~NEQ 空~文字列
］
◎
If there is a match
</p>
		<ol>
			<li>
%~semicolonなし ~LET ［
%識別子 の最後の文字 ~NEQ `003B^U ならば ~T ／ ~ELSE_ ~F
］
◎
↓</li>
			<li>
~IF［
次がいずれも満たされる
］…：

<ul><li>文字~参照は`属性の一部として消費されて$いる
</li><li>%~semicolonなし ~EQ ~T
</li><li>`次n入力~文字$ ~IN { `003D^U, `~ASCII英数字$ }
</li></ul>

<p>
…ならば
⇒
`一時~buffer$V ~APPEND %識別子
（これは、歴史的~理由による）
</p>

◎
If the character reference was consumed as part of an attribute, and the last character matched is not a U+003B SEMICOLON character (;), and the next input character is either a U+003D EQUALS SIGN character (=) or an ASCII alphanumeric, then, for historical reasons,＼
◎
↓↓flush code points consumed as a character reference and switch to the return state.
</li>
			<li>
<p>
~ELSE：
◎
Otherwise:
</p>
				<ol>
					<li>
~IF［
%~semicolonなし ~EQ ~T
］
⇒
`missing-semicolon-after-character-reference$pE
◎
If the last character matched is not a U+003B SEMICOLON character (;), then this is a missing-semicolon-after-character-reference parse error.
</li>
					<li>
`一時~buffer$V ~SET `有名~文字~参照$ 一覧の 2 列目に与えられる， %識別子 に対応している 1 〜 2 個の文字
◎
Set the temporary buffer to the empty string. Append one or two characters corresponding to the character reference name (as given by the second column of the named character references table) to the temporary buffer.
◎
↓↓Flush code points consumed as a character reference. Switch to the return state.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
`文字~参照として消費される~cpを一掃する$
◎
↑↓</li>
	<li>
［
%識別子 ~NEQ 空~文字列 ならば  `戻先~状態$V ／
~ELSE_ `多義的amp$st
］に`切替える$
◎
Otherwise
• Flush code points consumed as a character reference. Switch to the ambiguous ampersand state.
</li>
</ol>

<div class="example">

<p>
~markupが，属性の外で文字列
`I'm &amp;notit; I tell you^l
を包含する場合、文字~参照は、
`I'm ¬it; I tell you^l
のように，
“~~否定（ not ）”
として構文解析される（これは~perrorでもある）。
が、文字列が
`I'm &amp;notin; I tell you^l
であったなら、文字~参照は
`notin;^l
として構文解析される結果，
`I'm ∉ I tell you^l
になる（また，~perrorもない）。
◎
If the markup contains (not in an attribute) the string I'm &amp;notit; I tell you, the character reference is parsed as "not", as in, I'm ¬it; I tell you (and this is a parse error). But if the markup was I'm &amp;notin; I tell you, the character reference would be parsed as "notin;", resulting in I'm ∉ I tell you (and no parse error).
</p>

<p>
一方で，~markupが ある属性~内に文字列
`I'm &amp;notit; I tell you^l
を包含する場合、構文解析される文字~参照はなく，文字列はそのままにされる（また，~perrorもない）。
◎
However, if the markup contains the string I'm &amp;notit; I tell you in an attribute, no character reference is parsed and string remains intact (and there is no parse error).
</p>

</div>

				</section>
				<section id="ambiguous-ampersand-state">
<h4 title="Ambiguous ampersand state">12.2.5.74. `多義的amp^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII英数字$</dt>
	<dd>
		<ol>
			<li>
~IF［
文字~参照は`属性の一部として消費されて$いる
］
⇒
現在の属性の値 ~APPEND `現在の入力~文字$
</li>
			<li>
~ELSE
⇒
新たな文字~token( `現在の入力~文字$ ) を発する
</li>
		</ol>

◎
If the character reference was consumed as part of an attribute, then append the current input character to the current attribute's value. Otherwise, emit the current input character as a character token.
</dd>

	<dt>`003B^U</dt>
	<dd>
<ol><li>`unknown-named-character-reference$pE
</li><li>`戻先~状態$V 内で`再消費-$する
</li></ol>
◎
This is an unknown-named-character-reference parse error.
Reconsume in the return state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`戻先~状態$V 内で`再消費-$する
</li></ol>
◎
Reconsume in the return state.
</dd>
</dl>

				</section>
				<section id="numeric-character-reference-state">
<h4 title="Numeric character reference state">12.2.5.75. `数的な文字~参照^st</h4>

<ol>
	<li>
`文字~参照~code@V
~SET 0
◎
Set the character reference code to zero (0).
</li>
	<li>
<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

		<dl class="switch">
			<dt>`0078^U</dt>
			<dt>`0058^U</dt>
			<dd>
<ol ><li>`一時~buffer$V ~APPEND `現在の入力~文字$
</li><li>`~hexademical文字~参照~始端$stに`切替える$
</li></ol>
◎
Append the current input character to the temporary buffer. Switch to the hexademical character reference start state.
</dd>

			<dt>~AnyElse</dt>
			<dd>
<ol><li>`~decimal文字~参照~始端$st内で`再消費-$する
</li></ol>
◎
Reconsume in the decimal character reference start state.
</dd>
		</dl>
	</li>
</ol>


				</section>
				<section id="hexademical-character-reference-start-state">
<h4 title="Hexademical character reference start state">12.2.5.76. `~hexademical文字~参照~始端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII~hex数字$</dt>
	<dd>
<ol><li>`~hexademical文字~参照$st内で`再消費-$する
</li></ol>
◎
Reconsume in the hexademical character reference state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`absence-of-digits-in-numeric-character-reference$pE
</li><li>`文字~参照として消費される~cpを一掃する$
</li><li>`戻先~状態$V 内で`再消費-$する
</li></ol>
◎
This is an absence-of-digits-in-numeric-character-reference parse error.
Flush code points consumed as a character reference. Reconsume in the return state.
</dd>
</dl>

				</section>
				<section id="decimal-character-reference-start-state">
<h4 title="Decimal character reference start state">12.2.5.77. `~decimal文字~参照~始端^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII数字$</dt>
	<dd>
<ol><li>`~decimal文字~参照$st内で`再消費-$する
</li></ol>
◎
Reconsume in the decimal character reference state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`absence-of-digits-in-numeric-character-reference$pE
</li><li>`文字~参照として消費される~cpを一掃する$
</li><li>`戻先~状態$V 内で`再消費-$する
</li></ol>
◎
This is an absence-of-digits-in-numeric-character-reference parse error.
Flush code points consumed as a character reference. Reconsume in the return state.
</dd>
</dl>

				</section>
				<section id="hexademical-character-reference-state">
<h4 title="Hexademical character reference state">12.2.5.78. `~hexademical文字~参照^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt >`~ASCII~hex数字$</dt>
	<dd>
		<ol>
			<li>
`文字~参照~code$V ~SET
( `文字~参照~code$V ~MUL 16 )
~PLUS ( `現在の入力~文字$を 16 進数として解釈した結果の整数† )
</li>
		</ol>

<p>†
この整数は、`現在の入力~文字$が［
`~ASCII数字$ならば その~cpから`0030^X を減算した結果 ／
`~ASCII~hex数字（大文字）$ならば その~cpから`0037^X を減算した結果 ／
`~ASCII~hex数字（小文字）$ならば その~cpから`0057^X を減算した結果
］になる。
</p>

◎
ASCII digit
◎
Multiply the character reference code by 16. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
◎
ASCII upper hex digit
◎
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexademical digit (subtract 0x0037 from the character's code point) to the character reference code.
◎
ASCII lower hex digit
◎
Multiply the character reference code by 16. Add a numeric version of the current input character as a hexademical digit (subtract 0x0057 from the character's code point) to the character reference code.
</dd>

	<dt>`003B^U</dt>
	<dd>
<ol><li>`数的な文字~参照~終端$stに`切替える$
</li></ol>
◎
Switch to the numeric character reference end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-semicolon-after-character-reference$pE
</li><li>`数的な文字~参照~終端$st内で`再消費-$する
</li></ol>
◎
This is a missing-semicolon-after-character-reference parse error.
Reconsume in the numeric character reference end state.
</dd>
</dl>

				</section>
				<section id="decimal-character-reference-state">
<h4 title="Decimal character reference state">12.2.5.79. `~decimal文字~参照^st</h4>

<p>
`次n入力~文字$を消費する：
◎
Consume the next input character:
</p>

<dl class="switch">
	<dt>`~ASCII数字$</dt>
	<dd>
		<ol>
			<li>
`文字~参照~code$V ~SET
( `文字~参照~code$V ~MUL 10 )
~PLUS ( `現在の入力~文字$を 10 進数として解釈した結果の整数（文字の~cpから`0030^X を減算した結果） )
◎
Multiply the character reference code by 10. Add a numeric version of the current input character (subtract 0x0030 from the character's code point) to the character reference code.
</li>
		</ol>
	</dd>

	<dt>`003B^U</dt>
	<dd>
<ol><li>`数的な文字~参照~終端$stに`切替える$
</li></ol>
◎
Switch to the numeric character reference end state.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`missing-semicolon-after-character-reference$pE
</li><li>`数的な文字~参照~終端$st内で`再消費-$する
</li></ol>
◎
This is a missing-semicolon-after-character-reference parse error.
Reconsume in the numeric character reference end state.
</dd>
</dl>

				</section>
				<section id="numeric-character-reference-end-state">
<h4 title="Numeric character reference end state">12.2.5.80. `数的な文字~参照~終端^st</h4>

<ol>
	<li>
<p>
`文字~参照~code$V （が指す符号位置）に応じて：
◎
Check the character reference code:
</p>

		<dl class="switch">
			<dt>`00^X</dt>
			<dd>
<ol><li>`null-character-reference$pE
</li><li>`文字~参照~code$V ~SET `FFFD^X
</li></ol>
◎
If the number is 0x00, then this is a null-character-reference parse error.
Set the character reference code to 0xFFFD.
</dd>

			<dt>`10FFFF^X を超える</dt>
			<dd>
<ol><li>`character-reference-outside-unicode-range$pE
</li><li>`文字~参照~code$V ~SET `FFFD^X
</li></ol>
◎
If the number is greater than 0x10FFFF, then this is a character-reference-outside-unicode-range parse error.
Set the character reference code to 0xFFFD.
</dd>

			<dt>`~surrogate$</dt>
			<dd>
<ol><li>`surrogate-character-reference$pE
</li><li>`文字~参照~code$V ~SET `FFFD^X
</li></ol>
◎
If the number is a surrogate, then this is a surrogate-character-reference parse error.
Set the character reference code to 0xFFFD.
</dd>

			<dt>`非文字$</dt>
			<dd>
<ol><li>`noncharacter-character-reference$pE
</li></ol>
◎
If the number is a noncharacter, then this is a noncharacter-character-reference parse error.
</dd>

			<dt>`0D^X</dt>
			<dt>`~ASCII空白$以外の`制御文字$</dt>
			<dd>
<ol><li>`control-character-reference$pE
</li></ol>
◎
If the number is 0x0D, or a control that's not ASCII whitespace, then this is a control-character-reference parse error.＼
</dd>

			<dt>下の表の 1 列目に現れる</dt>
			<dd>
<p>
`文字~参照~code$V ~SET 現れた行の 2 列目の数
◎
If the number is one of the numbers in the first column of the following table, then find the row with that number in the first column, and set the character reference code to the number in the second column of that row.
</p>

<table id="table-charref-overrides">
<thead><tr><th>数◎Number
</th><th colspan="2">~cp◎Code point
</th></thead>

<tbody>

<tr><td>`80^X<td>`20AC^X<td>EURO SIGN (€)

<tr><td>`82^X<td>`201A^X<td>SINGLE LOW-9 QUOTATION MARK (‚)

<tr><td>`83^X<td>`0192^X<td>LATIN SMALL LETTER F WITH HOOK (ƒ)

<tr><td>`84^X<td>`201E^X<td>DOUBLE LOW-9 QUOTATION MARK („)

<tr><td>`85^X<td>`2026^X<td>HORIZONTAL ELLIPSIS (…)

<tr><td>`86^X<td>`2020^X<td>DAGGER (†)

<tr><td>`87^X<td>`2021^X<td>DOUBLE DAGGER (‡)

<tr><td>`88^X<td>`02C6^X<td>MODIFIER LETTER CIRCUMFLEX ACCENT (ˆ)

<tr><td>`89^X<td>`2030^X<td>PER MILLE SIGN (‰)

<tr><td>`8A^X<td>`0160^X<td>LATIN CAPITAL LETTER S WITH CARON (Š)

<tr><td>`8B^X<td>`2039^X<td>SINGLE LEFT-POINTING ANGLE QUOTATION MARK (‹)

<tr><td>`8C^X<td>`0152^X<td>LATIN CAPITAL LIGATURE OE (Œ)

<tr><td>`8E^X<td>`017D^X<td>LATIN CAPITAL LETTER Z WITH CARON (Ž)

<tr><td>`91^X<td>`2018^X<td>LEFT SINGLE QUOTATION MARK (‘)

<tr><td>`92^X<td>`2019^X<td>RIGHT SINGLE QUOTATION MARK (’)

<tr><td>`93^X<td>`201C^X<td>LEFT DOUBLE QUOTATION MARK (“)

<tr><td>`94^X<td>`201D^X<td>RIGHT DOUBLE QUOTATION MARK (”)

<tr><td>`95^X<td>`2022^X<td>BULLET (•)

<tr><td>`96^X<td>`2013^X<td>EN DASH (–)

<tr><td>`97^X<td>`2014^X<td>EM DASH (—)

<tr><td>`98^X<td>`02DC^X<td>SMALL TILDE (˜)

<tr><td>`99^X<td>`2122^X<td>TRADE MARK SIGN (™)

<tr><td>`9A^X<td>`0161^X<td>LATIN SMALL LETTER S WITH CARON (š)

<tr><td>`9B^X<td>`203A^X<td>SINGLE RIGHT-POINTING ANGLE QUOTATION MARK (›)

<tr><td>`9C^X<td>`0153^X<td>LATIN SMALL LIGATURE OE (œ)

<tr><td>`9E^X<td>`017E^X<td>LATIN SMALL LETTER Z WITH CARON (ž)

<tr><td>`9F^X<td>`0178^X<td>LATIN CAPITAL LETTER Y WITH DIAERESIS (Ÿ)

</tbody></table>

			</dd>
		</dl>
	</li>
	<li>
`一時~buffer$V ~SET ~cp( `文字~参照~code$V )
◎
Set the temporary buffer to the empty string. Append a code point equal to the character reference code to the temporary buffer.＼
</li>
	<li>
`文字~参照として消費される~cpを一掃する$
◎
Flush code points consumed as a character reference.＼
</li>
	<li>
`戻先~状態$V に`切替える$
◎
Switch to the return state.
</li>
</ol>

				</section>
			</section>
			<section id="tree-construction">
<h3 title="Tree construction">12.2.6. 文書~木の構築</h3>

<p>
木~構築~段階には、`~token化~段階$から~token列が入力される。
木~構築~段階は、構文解析器の作成-時に`文書$に結付けられる。
この段階の “出力” は、当の文書［
を動的に改変する ／ の~DOM木を拡張する
］ことからなる。
◎
The input to the tree construction stage is a sequence of tokens from the tokenization stage. The tree construction stage is associated with a DOM Document object when a parser is created. The "output" of this stage consists of dynamically modifying or extending that document's DOM tree.
</p>

<p>
この仕様は、対話的~UAが いつ［
利用者に可用になるよう`文書$を具現化する必要があるか ／
利用者~入力を受容し始する必要がある
］かは，定義しない。
◎
This specification does not define when an interactive user agent has to render the Document so that it is available to the user, or when it has to begin accepting user input.
</p>

<hr>

<div class="p">

<p>
この節を通して，
<dfn>現token</dfn>
は、~tokenizerから発され，木~構築~段階が現在~処理している~tokenを指すとする。
</p>

<p class="algo-head">
~UAは、~tokenizerから~tokenが発される度に，
`木~構築~分配器@
と称される次の手続きに従わ~MUST：
</p>

◎
As each token is emitted from the tokenizer, the user agent must follow the appropriate steps from the following list, known as the tree construction dispatcher:
</div>

<ol>
	<li>
%~node ~LET `現在の調整-済み~node$
</li>
	<li>
<p>
~IF［
次のいずれかが満たされる
］…
◎
↓</p>

		<ul>
			<li>
`~open要素~stack$は空である
◎
If the stack of open elements is empty
</li>
			<li>
%~node は`~HTML名前空間$に属する要素である
◎
If the adjusted current node is an element in the HTML namespace
</li>
			<li>
［
%~node は`~MathML~text統合~地点$である
］~AND［
現tokenは開始tag~tokenである
］~AND［
現tokenの~tag名 ~NIN { `mglyph^l, `malignmark^l }
］
◎
If the adjusted current node is a MathML text integration point and the token is a start tag whose tag name is neither "mglyph" nor "malignmark"
</li>
			<li>
［
%~node は`~MathML~text統合~地点$である
］~AND［
現tokenは文字~tokenである
］
◎
If the adjusted current node is a MathML text integration point and the token is a character token
</li>
			<li>
［
%~node は~MathML `annotation-xml$e 要素である
］~AND［
現tokenは開始tag~tokenである
］~AND［
現tokenの~tag名 ~EQ `svg^l
］
◎
If the adjusted current node is a MathML annotation-xml element and the token is a start tag whose tag name is "svg"
</li>
			<li>
［
%~node は`~HTML統合~地点$である
］~AND［
現tokenは開始tag~tokenである
］
◎
If the adjusted current node is an HTML integration point and the token is a start tag
</li>
			<li>
［
%~node は`~HTML統合~地点$である
］~AND［
現tokenは文字~tokenである
］
◎
If the adjusted current node is an HTML integration point and the token is a character token
</li>
			<li>
現tokenは~eof~tokenである
◎
If the token is an end-of-file token
</li>
		</ul>

<p>
…ならば
⇒
［
<a href="#parsing-main-inhtml">~HTML内容~内の~token</a>
用の，現在の`挿入~mode$に対応する節
］に与える規則に則って、現tokenを処理する
◎
Process the token according to the rules given in the section corresponding to the current insertion mode in HTML content.
</p>
	</li>
	<li>
~ELSE
⇒
`外来~内容~内$md節に与える規則に則って、現tokenを処理する
◎
Otherwise
◎
Process the token according to the rules given in the section for parsing tokens in foreign content.
</li>
</ol>

<p>
`次n~token@
とは、`木~構築~分配器$により処理されようとしている~tokenを指す（その~tokenは後続して，単に無視される場合もある）。
◎
The next token is the token that is about to be processed by the tree construction dispatcher (even if the token is subsequently just ignored).
</p>

<p class="trans-note">【
この訳では、この用語は利用せず，
`次n~LF文字~tokenは無視するようにしておく$
手続きに置き換えている。
その用途にしか用いられていないので。
】</p>

<p>
次に該当する~MathML要素~nodeは、
`~MathML~text統合~地点@
とされる
⇒
`mi$e, `mo$e, `mn$e, `ms$e, `mtext$e
◎
A node is a MathML text integration point if it is one of the following elements:
• A MathML mi element
• A MathML mo element
• A MathML mn element
• A MathML ms element
• A MathML mtext element
</p>

<p>
次のいずれかに該当する~nodeは、
`~HTML統合~地点@
とされる：
◎
A node is an HTML integration point if it is one of the following elements:
</p>

<ul>
	<li>
<p>
~MathML `annotation-xml$e 要素のうち，それを作成させた開始tag~tokenが 次を満たす属性を有していたもの：
</p>

<ul><li>名前 ~EQ `encoding^l  ~AND
</li><li>値 ~IN`大小無視$sub { `text/html^l, `application/xhtml+xml^l }
</li></ul>

◎
A MathML annotation-xml element whose start tag token had an attribute with the name "encoding" whose value was an ASCII case-insensitive match for the string "text/html"
◎
A MathML annotation-xml element whose start tag token had an attribute with the name "encoding" whose value was an ASCII case-insensitive match for the string "application/xhtml+xml"
</li>
	<li>
~SVG 
`foreignObject$e, `desc$e, `title$e
要素
◎
An SVG foreignObject element
An SVG desc element
An SVG title element
</li>
</ul>

<p class="note">注記：
~nodeが［
`~HTML素片の構文解析~algo$に渡された `文脈~要素$V
］である場合、その要素~用の開始tag~tokenは，その~algo内で作成された “模造” ~tokenである。
◎
If the node in question is the context element passed to the HTML fragment parsing algorithm, then the start tag token for that element is the "fake" token created during by that HTML fragment parsing algorithm.
</p>

<hr>

<p class="note">注記：
下に言及される~tag名には、この仕様に適合する~tag名にならないものもある
— その多くは、旧来の内容を取扱うために含められている。
それらは依然として~algoの一部を形成し、適合性を主張する実装には，実装することが要求される。
◎
Not all of the tag names mentioned below are conformant tag names in this specification; many are included to handle legacy content. They still form part of the algorithm that implementations are required to implement to claim conformance.
</p>

<p class="note">注記：
以下に述べる~algoは、生成される~DOM木の深さにも, ［
~tag名, 属性~名, 属性~値, `Text$I ~node, 等々
］の長さにも制限-は設けない。
実装者には，恣意的な制限-は避けることが奨励されるが、
<a href="~HTMLINFRA#hardwareLimitations">実施上の懸念</a>
により，~UAは入子~の深さに拘束を課すよう強いられるであろうことも認識されている。
◎
The algorithm described below places no limit on the depth of the DOM tree generated, or on the length of tag names, attribute names, attribute values, Text nodes, etc. While implementors are encouraged to avoid arbitrary limits, it is recognized that practical concerns will likely force user agents to impose nesting depth constraints.
</p>

				<section id="creating-and-inserting-nodes">
<h4 title="Creating and inserting nodes">12.2.6.1. ~nodeの作成-法と挿入-法</h4>

<p>
%構文解析器 は、ある~tokenを処理している間，
`親を違える@
（ foster parenting ）のを
可能化-／不能化-
することもある。
これは、次の~algoに影響する。
◎
While the parser is processing a token, it can enable or disable foster parenting. This affects the following algorithm.
</p>

<p class="algo-head">
`適切な~node挿入-先@
は、所与の
( `上書き~target^i %~target )
に対し，次の手続きを走らせた結果で与えられる要素~内の位置である：
◎
The appropriate place for inserting a node, optionally using a particular override target, is the position in an element returned by running the following steps:
• If there was an override target specified, then let target be the override target.
• Otherwise, let target be the current node.
</p>

<ol>
	<li>
%調整-済み挿入-先 ~LET %~target 内の末尾
◎
↓↓</li>
	<li>
<p>
~IF［
`親を違える$のは可能化されている
］~AND［
%~target は［
`table$e ／ `tbody$e ／ `tfoot$e ／ `thead$e ／ `tr$e
］要素である
⇒
%調整-済み挿入-先 ~SET 次の下位手続きを走らせた結果：
◎
Determine the adjusted insertion location using the first matching steps from the following list:
◎
If foster parenting is enabled and target is a table, tbody, tfoot, thead, or tr element
</p>

<p class="note">注記：
親を違えるのは、ある内容が~table内に誤入子にされたときに起こる。
◎
Foster parenting happens when content is misnested in tables.
◎
Run these substeps:
</p>
		<ol>
			<li>
%~stack ~LET `~open要素~stack$
◎
↓</li>
			<li>
%最後の~template ~LET %~stack 内に `template$e 要素が［
在れば それらのうち最後のもの ／
無ければ ε
］
◎
Let last template be the last template element in the stack of open elements, if any.
</li>
			<li>
%最後の~table ~LET %~stack 内に `table$e 要素が［
在れば それらのうち最後のもの ／
無ければ ε
］
◎
Let last table be the last table element in the stack of open elements, if any.
</li>
			<li>
~IF［
%最後の~template ~NEQ ε
］
⇒
~IF［［
%最後の~table ~EQ ε
］~OR［［
%最後の~table ~NEQ ε
］~AND［
%最後の~template は %~stack 内で %最後の~table より後にある（より近過去に追加された）
］］］
⇒
~RET %最後の~template の`~template内容$内の末尾
◎
If there is a last template and either there is no last table, or there is one, but last template is lower (more recently added) than last table in the stack of open elements, then: let adjusted insertion location be inside last template's template contents, after its last child (if any), and abort these substeps.
</li>
			<li>
~IF［
%最後の~table ~EQ ε 
（`素片~事例$）
］
⇒
~RET %~stack の先頭の要素（ `html$e 要素）内の末尾
◎
If there is no last table, then let adjusted insertion location be inside the first element in the stack of open elements (the html element), after its last child (if any), and abort these substeps. (fragment case)
</li>
			<li>
~IF［
%最後の~table の親~nodeはある
］
⇒
~RET %最後の~table の親~nodeの内側の %最後の~table の直前
◎
If last table has a parent node, then let adjusted insertion location be inside last table's parent node, immediately before last table, and abort these substeps.
</li>
			<li>
~RET［
%~stack 内で， %最後の~table の直前にある要素
］内の末尾
◎
Let previous element be the element immediately above last table in the stack of open elements.
◎
Let adjusted insertion location be inside previous element, after its last child (if any).
</li>
		</ol>

<p class="note">注記：
この下位手続きが孕まれているわけは、要素
— この事例では特に `table$e 要素 —
が構文解析器により挿入された後でも，~scriptにより~DOM内のどこかへ移動されたり, まるごと~DOMから除去されることもあり得るためである。
◎
These steps are involved in part because it's possible for elements, the table element in this case in particular, to have been moved by a script around in the DOM, or indeed removed from the DOM entirely, after the element was inserted by the parser.
</p>
	</li>
	<li>
~IF［
%調整-済み挿入-先 が所属する~nodeは `template$e 要素である
］
⇒
~RET `template$e 要素の`~template内容$内の末尾
◎
Otherwise
• Let adjusted insertion location be inside target, after its last child (if any).
◎
If the adjusted insertion location is inside a template element, let it instead be inside the template element's template contents, after its last child (if any).
</li>
	<li>
~RET %調整-済み挿入-先
◎
Return the adjusted insertion location.
</li>
</ol>

<hr>

<p class="algo-head">
以下の手続きにて
`~tokenから要素を作成する@
ときは、所与の
( %~token, %名前空間, %意図される親 )
に対し，次を走らせ~MUST：
◎
When the steps below require the UA to create an element for a token in a particular given namespace and with a particular intended parent, the UA must run the following steps:
</p>

<ol>
	<li>
%文書 ~LET %意図される親 の`~node文書$
◎
Let document be intended parent's node document.
</li>
	<li>
%局所~名 ~LET %~token の~tag名
◎
Let local name be the tag name of the token.
</li>
	<li>
%is ~LET %~token 内に `is$a 属性が［
在れば その値 ／
無ければ ~NULL
］
◎
Let is be the value of the "is" attribute in the given token, if such an attribute exists, or null otherwise.
</li>
	<li>
%定義 ~LET `~custom要素~定義を検索する$( %文書, %所与の名前空間, %局所~名, %is )
◎
Let definition be the result of looking up a custom element definition given document, given namespace, local name, and is.
</li>
	<li>
%~scriptを実行する ~LET ~F
</li>
	<li>
~IF ［
%定義 ~NEQ ~NULL 
］~AND［
%構文解析器 は `~HTML素片~用$でない
］
⇒
%~scriptを実行する ~SET ~T
◎
If definition is non-null and the parser was not originally created for the HTML fragment parsing algorithm, then let will execute script be true. Otherwise, let it be false.
</li>
	<li>
<p>
~IF［
%~scriptを実行する ~EQ ~T
］：
◎
If will execute script is true, then:
</p>

		<ol>
			<li>
%文書 の`動的~markup挿入-時には投出する~counter$ ~INCBY 1
◎
Increment document's throw-on-dynamic-markup-insertion counter.
</li>
			<li>
~IF［
`~JS実行~文脈~stack$は空である
］
⇒
`極小task~checkpointを遂行する$
◎
If the JavaScript execution context stack is empty, then perform a microtask checkpoint.
</li>
			<li>
新たな`要素~待行列$を`~custom要素~反応~stack$に~pushする
◎
Push a new element queue onto the custom element reactions stack.
</li>
		</ol>
	</li>
	<li>
%同期~custom要素~flag ~LET 
%~scriptを実行する に応じて［
~T ならば ~ON ／
~F ならば ~OFF
］
◎
↓</li>
	<li>
<p>
%要素 ~LET `新たな要素$( %文書, %局所~名, %名前空間, ~NULL, %is, %同期~custom要素~flag )
◎
Let element be the result of creating an element given document, localName, given namespace, null, and is. If will execute script is true, set the synchronous custom elements flag; otherwise, leave it unset.
</p>

<p class="note">注記：
これは、［
%~scriptを実行する ~EQ ~T
］ならば`~custom要素~構築子$を走らすことになる。
しかしながら，`動的~markup挿入-時には投出する~counter$は増やしたので、これにより，［
<a href="~HTML5/dynamic-markup-insertion.html#dom-document-write">~tokenizerの中に新たな文字が挿入される</a> ／
<a href="~HTML5/dynamic-markup-insertion.html#dom-document-open">文書が吹飛ばされる</a>
］ことはない。
◎
This will cause custom element constructors to run, if will execute script is true. However, since we incremented the throw-on-dynamic-markup-insertion counter, this cannot cause new characters to be inserted into the tokenizer, or the document to be blown away.
</p>
	</li>
	<li>
<p>
%~token 内の ~EACH( %属性 ) に対し
⇒
%要素 に`属性を付加する$( %属性 )
◎
Append each attribute in the given token to element.
</p>

<p class="note">注記：
これは、 `attributeChangedCallback^c 用の`~custom要素~callback反応を待入れる$こともある
— それは（次~段にて）即時に走るかもしれない。
◎
This can enqueue a custom element callback reaction for the attributeChangedCallback, which might run immediately (in the next step).
</p>

<p class="note">注記：
`is$a 属性は，`~custom化された組込みの要素$の`作成$elemを統治するが、それは関連する`~custom要素~構築子$を実行する間は，まだない
— それは、この段にて，他の属性とともに付加されるので。
◎
Even though the is attribute governs the creation of a customized built-in element, it is not present during the execution of the relevant custom element constructor; it is appended in this step, along with all other attributes.
</p>
	</li>
	<li>
<p>
~IF［
%~scriptを実行する ~EQ ~T
］：
◎
If will execute script is true, then:
</p>

		<ol>
			<li>
%待行列 ~LET `現在の要素~待行列$から`~custom要素~反応~stack$を~popした結果
（これは、上で~pushしたのと同じ`要素~待行列$になる。）
◎
Let queue be the result of popping the current element queue from the custom element reactions stack. (This will be the same element queue as was pushed above.)
</li>
			<li>
%待行列 内の`~custom要素~反応を呼出す$
◎
Invoke custom element reactions in queue.
</li>
			<li>
%文書 の`動的~markup挿入-時には投出する~counter$ ~DECBY 1
◎
Decrement document's throw-on-dynamic-markup-insertion counter.
</li>
		</ol>
	</li>
	<li>
~IF［
%要素 は`~XMLNS名前空間$に属する `xmlns^a 属性を有していて，その値 ~EQ 要素の名前空間
］
⇒
`~perror$
◎
If element has an xmlns attribute in the XMLNS namespace whose value is not exactly the same as the element's namespace, that is a parse error.＼
</li>
	<li>
~IF［
%要素 は`~XMLNS名前空間$に属する `xmlns:xlink^a 属性を有していて，その値 ~NEQ `~XLink名前空間$
］
⇒
`~perror$
◎
Similarly, if element has an xmlns:xlink attribute in the XMLNS namespace whose value is not the XLink Namespace, that is a parse error.
</li>
	<li>
~IF［
%要素 は`再設定-可能な要素$である
］
⇒
%要素 を`再設定する~algo$を呼出す
（これは、要素の属性に基いて，要素の`値$と`~checkedness$を初期化する。）
◎
If element is a resettable element, invoke its reset algorithm. (This initializes the element's value and checkedness based on the element's attributes.)
</li>
	<li>
%form ~LET `~form要素~pointer$
◎
↓</li>
	<li>
<p>
~IF［
次がすべて満たされる
］…：
</p>

<ul><li>%要素 は`~formに所有され得る要素$である
</li><li>%form ~NEQ ~NULL
</li><li>`~open要素~stack$内に `template$e 要素はない
</li><li>［
%要素 は`~listされる要素$でない
］~OR［
%要素 は `form$a 属性を有さない
］
</li><li>( %form, %意図される親 ) は同じ`木$内にある
</li></ul>

<p>
…ならば：
</p>

<ol ><li>%要素 の`~form所有者$ ~SET %form
</li><li>%要素 の`構文解析器挿入~flag$ ~SET ~ON
</li></ol>

◎
If element is a form-associated element, the form element pointer is not null, there is no template element on the stack of open elements, element is either not listed or doesn't have a form attribute, and the intended parent is in the same tree as the element pointed to by the form element pointer, then associate element with the form element pointed to by the form element pointer and set element's parser inserted flag.
</li>
	<li>
~RET %要素
◎
Return element.
</li>
</ol>

<hr>

<p class="algo-head">
以下の手続きにて
`要素を挿入する@
ときは、所与の
( 開始tag~token %~token, 名前空間 %名前空間 （省略時は `~HTML名前空間$）)
に対し，次の手続きを走らせ~MUST：
◎
When the steps below require the user agent to insert a foreign element for a token in a given namespace, the user agent must run these steps:
</p>

<p class="trans-note">【
この訳では、原文による 2 つの手続き［
`外来の要素を挿入する@,
`~HTML要素を挿入する@
］を この手続きに集約して，命名を簡素化する（これらの手続きは、順に，この手続きにて %名前空間 を［
明示的に与えた場合, 省略した場合
］の挙動に一致する）。
】</p>

<ol>
	<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$( `現在の~node$ )
◎
Let the adjusted insertion location be the appropriate place for inserting a node.
</li>
	<li>
%要素 ~LET `~tokenから要素を作成する$( %~token, %名前空間, %調整-済み挿入-先 が所属する要素 )
◎
Let element be the result of creating an element for the token in the given namespace, with the intended parent being the element in which the adjusted insertion location finds itself.
</li>
	<li>
<p>
~IF［
%要素 を %調整-済み挿入-先 に挿入-可能である
【下の注記を見よ】
］：
◎
If it is possible to insert element at the adjusted insertion location, then:
</p>

		<ol>
			<li>
`~custom要素~反応~stack$に新たな`要素~待行列$を~pushする
◎
Push a new element queue onto the custom element reactions stack.
</li>
	<li>
%要素 を %調整-済み挿入-先 に挿入する
◎
Insert element at the adjusted insertion location.
</li>
	<li>
%待行列 ~LET `~custom要素~反応~stack$から`要素~待行列$を~popする
◎
Pop the element queue from the custom element reactions stack, and＼
</li>
	<li>
%待行列 内の`~custom要素~反応を呼出す$
◎
invoke custom element reactions in that queue.
</li>
</ol>

<p class="note">注記：
%調整-済み挿入-先 がそれ以上~要素を受容できない場合、
%要素 は弾き出される
— 例えば、そこは すでに ある要素を子に有している`文書$内である場合。
【すなわち、挿入すると~DOM木に課される拘束を満たせなくなる場合。】
◎
If the adjusted insertion location cannot accept more elements, e.g. because it's a Document that already has an element child, then element is dropped on the floor.
</p>

	</li>
	<li>
`~open要素~stack$に %要素 を~pushする
◎
Push element onto the stack of open elements so that it is the new current node.
</li>
	<li>
~RET %要素
◎
Return element.
◎
↑↑When the steps below require the user agent to insert an HTML element for a token, the user agent must insert a foreign element for the token, in the HTML namespace.
</li>
</ol>

<hr>

<p class="algo-head">
以下の手続きにて
`~MathML属性たちを調整する@
ときは、所与の~tokenに対し，次を走らす
⇒
~token内の ~EACH( %属性 ) に対し
⇒
~IF［
%属性 の名前 ~EQ `definitionurl^l
］
⇒
%属性 の名前 ~SET `definitionURL^l
◎
When the steps below require the user agent to adjust MathML attributes for a token, then, if the token has an attribute named definitionurl, change its name to definitionURL (note the case difference).
</p>

<p class="algo-head">
以下の手続きにて
`~SVG属性たちを調整する@
ときは、所与の~tokenに対し，次を走らす
⇒
~token内の ~EACH( %属性 )に対し
⇒
~IF［
%属性 の名前 ~IN { 次の表の 1 列目に挙げる名前 }
］
⇒
%属性 の名前 ~SET 同じ行の 2 列目に与えられる名前
（これは、名前に大文字を含むような~SVG属性の文字大小を修正する）
◎
When the steps below require the user agent to adjust SVG attributes for a token, then, for each attribute on the token whose attribute name is one of the ones in the first column of the following table, change the attribute's name to the name given in the corresponding cell in the second column. (This fixes the case of SVG attributes that are not all lowercase.)
</p>

<table><thead><tr><th>~token上の属性~名◎Attribute name on token
</th><th>要素~上の属性~名◎Attribute name on element
</th></thead>

<tbody><tr><td>`attributename^c
<td>`attributeName^c

<tr><td>`attributetype^c
<td>`attributeType^c

<tr><td>`basefrequency^c
<td>`baseFrequency^c

<tr><td>`baseprofile^c
<td>`baseProfile^c

<tr><td>`calcmode^c
<td>`calcMode^c

<tr><td>`clippathunits^c
<td>`clipPathUnits^c

<tr><td>`diffuseconstant^c
<td>`diffuseConstant^c

<tr><td>`edgemode^c
<td>`edgeMode^c

<tr><td>`filterunits^c
<td>`filterUnits^c

<tr><td>`glyphref^c
<td>`glyphRef^c

<tr><td>`gradienttransform^c
<td>`gradientTransform^c

<tr><td>`gradientunits^c
<td>`gradientUnits^c

<tr><td>`kernelmatrix^c
<td>`kernelMatrix^c

<tr><td>`kernelunitlength^c
<td>`kernelUnitLength^c

<tr><td>`keypoints^c
<td>`keyPoints^c

<tr><td>`keysplines^c
<td>`keySplines^c

<tr><td>`keytimes^c
<td>`keyTimes^c

<tr><td>`lengthadjust^c
<td>`lengthAdjust^c

<tr><td>`limitingconeangle^c
<td>`limitingConeAngle^c

<tr><td>`markerheight^c
<td>`markerHeight^c

<tr><td>`markerunits^c
<td>`markerUnits^c

<tr><td>`markerwidth^c
<td>`markerWidth^c

<tr><td>`maskcontentunits^c
<td>`maskContentUnits^c

<tr><td>`maskunits^c
<td>`maskUnits^c

<tr><td>`numoctaves^c
<td>`numOctaves^c

<tr><td>`pathlength^c
<td>`pathLength^c

<tr><td>`patterncontentunits^c
<td>`patternContentUnits^c

<tr><td>`patterntransform^c
<td>`patternTransform^c

<tr><td>`patternunits^c
<td>`patternUnits^c

<tr><td>`pointsatx^c
<td>`pointsAtX^c

<tr><td>`pointsaty^c
<td>`pointsAtY^c

<tr><td>`pointsatz^c
<td>`pointsAtZ^c

<tr><td>`preservealpha^c
<td>`preserveAlpha^c

<tr><td>`preserveaspectratio^c
<td>`preserveAspectRatio^c

<tr><td>`primitiveunits^c
<td>`primitiveUnits^c

<tr><td>`refx^c
<td>`refX^c

<tr><td>`refy^c
<td>`refY^c

<tr><td>`repeatcount^c
<td>`repeatCount^c

<tr><td>`repeatdur^c
<td>`repeatDur^c

<tr><td>`requiredextensions^c
<td>`requiredExtensions^c

<tr><td>`requiredfeatures^c
<td>`requiredFeatures^c

<tr><td>`specularconstant^c
<td>`specularConstant^c

<tr><td>`specularexponent^c
<td>`specularExponent^c

<tr><td>`spreadmethod^c
<td>`spreadMethod^c

<tr><td>`startoffset^c
<td>`startOffset^c

<tr><td>`stddeviation^c
<td>`stdDeviation^c

<tr><td>`stitchtiles^c
<td>`stitchTiles^c

<tr><td>`surfacescale^c
<td>`surfaceScale^c

<tr><td>`systemlanguage^c
<td>`systemLanguage^c

<tr><td>`tablevalues^c
<td>`tableValues^c

<tr><td>`targetx^c
<td>`targetX^c

<tr><td>`targety^c
<td>`targetY^c

<tr><td>`textlength^c
<td>`textLength^c

<tr><td>`viewbox^c
<td>`viewBox^c

<tr><td>`viewtarget^c
<td>`viewTarget^c

<tr><td>`xchannelselector^c
<td>`xChannelSelector^c

<tr><td>`ychannelselector^c
<td>`yChannelSelector^c

<tr><td>`zoomandpan^c
<td>`zoomAndPan^c

</tbody></table>

<div class="p">
<p class="algo-head">
以下の手続きにて
`外来の属性たちを調整する@
ときは、所与の~tokenに対し，次を走らす
⇒
~token上の ~EACH( %属性 ) に対し
⇒
~IF［
%属性 は次の表のある行の 1 列目に与える文字列に合致する
］
⇒
%属性 ~SET 同じ行の ( 2, 3, 4 ) 列目に与える
( 接頭辞, 局所~名, 名前空間 )
を伴う名前空間~付きの属性
</p>

<p>
（これは、名前空間~付きの属性の利用
— 特に <a href="~HTMLdom#attr-xml-lang">~XML名前空間に属する `lang^a 属性</a> —
を修正する。）
</p>

◎
When the steps below require the user agent to adjust foreign attributes for a token, then, if any of the attributes on the token match the strings given in the first column of the following table, let the attribute be a namespaced attribute, with the prefix being the string given in the corresponding cell in the second column, the local name being the string given in the corresponding cell in the third column, and the namespace being the namespace given in the corresponding cell in the fourth column. (This fixes the use of namespaced attributes, in particular lang attributes in the XML namespace.)
</div>

<table><thead><tr><th>属性~名◎Attribute name
</th><th>接頭辞◎Prefix
</th><th>局所~名◎Local name
</th><th>名前空間◎Namespace

</th></thead>

<tbody><tr><td>`xlink:actuate^l
<td>`xlink^l
<td>`actuate^l
<td>`~XLink名前空間$

<tr><td>`xlink:arcrole^l
<td>`xlink^l
<td>`arcrole^l
<td>`~XLink名前空間$

<tr><td>`xlink:href^l
<td>`xlink^l
<td>`href^l
<td>`~XLink名前空間$

<tr><td>`xlink:role^l
<td>`xlink^l
<td>`role^l
<td>`~XLink名前空間$

<tr><td>`xlink:show^l
<td>`xlink^l
<td>`show^l
<td>`~XLink名前空間$

<tr><td>`xlink:title^l
<td>`xlink^l
<td>`title^l
<td>`~XLink名前空間$

<tr><td>`xlink:type^l
<td>`xlink^l
<td>`type^l
<td>`~XLink名前空間$

<tr><td>`xml:lang^l
<td>`xml^l
<td>`lang^l
<td>`~XML名前空間$

<tr><td>`xml:space^l
<td>`xml^l
<td>`space^l
<td>`~XML名前空間$

<tr><td>`xmlns^l
<td>（なし）◎(none)
<td>`xmlns^l
<td>`~XMLNS名前空間$

<tr><td>`xmlns:xlink^l
<td>`xmlns^l
<td>`xlink^l
<td>`~XMLNS名前空間$

</tbody></table>

<hr>

<p class="algo-head">
以下の手続きにて~tokenを処理している間に，
`文字を挿入する@
ときは、所与の %文字 に対し，次を走らせ~MUST：
◎
When the steps below require the user agent to insert a character while processing a token, the user agent must run the following steps:
</p>

<ol>
	<li>
%~data ~LET %文字
◎
Let data be the characters passed to the algorithm, or, if no characters were explicitly specified, the character of the character token being processed.
</li>
	<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$( `現在の~node$ )
◎
Let the adjusted insertion location be the appropriate place for inserting a node.
</li>
	<li>
<p>
~IF［
%調整-済み挿入-先 が所属する~nodeは`文書$である
］
⇒
~RET
◎
If the adjusted insertion location is in a Document node, then abort these steps.
</p>

<p class="note">注記：
~DOMの~~制約により、 `Text$I ~nodeは，`文書$の子になれないので弾き出される。
◎
The DOM will not let Document nodes have Text node children, so they are dropped on the floor.
</p>

	</li>
	<li>
~IF［
%調整-済み挿入-先 の直前に `Text$I ~nodeはある
］
⇒
その~nodeの~dataに %~data を付加する
◎
If there is a Text node immediately before the adjusted insertion location, then append data to that Text node's data.
</li>
	<li>
<p>
~ELSE
⇒
次のようにされた新たな `Text$I ~nodeを %調整-済み挿入-先 に挿入する
</p>

<ul><li>%text の~data ~SET %~data
</li><li>%text の`~node文書$ ~SET %調整-済み挿入-先 が所属する要素の`~node文書$
</li></ul>

◎
Otherwise, create a new Text node whose data is data and whose node document is the same as that of the element in which the adjusted insertion location finds itself, and insert the newly created node at the adjusted insertion location.
</li>
</ol>

<div class="example">

<p>
構文解析器への見本~入力と対応する `Text$I ~nodeを，以下にいくつか挙げる
— ここでは、~UAは~scriptを実行すると見做す：
◎
Here are some sample inputs to the parser and the corresponding number of Text nodes that they result in, assuming a user agent that executes scripts.
</p>

<table><thead><tr><th>入力◎Input
</th><th>`Text$I ~nodeの個数◎Number of Text nodes

</th></thead>

<tbody id="_text-node-sample1"><tr><td>
<pre class="html-code">
A&lt;script&gt;
var %script = document.getElementsByTagName('script')[0];
document.body.removeChild(%script);
&lt;/script&gt;B
</pre>

<td>
文書~内に，
`AB^l を包含している
1 個の `Text$I ~node。
◎
One Text node in the document, containing "AB".

<tr><td>
<pre class="html-code">
A&lt;script&gt;
var %text = document.createTextNode('B');
document.body.appendChild(%text);
&lt;/script&gt;C
</pre>

<td>
3 個の `Text$I ~node
— 順に、
`script^e の前に `A^l,
`script^e の内容,
`script^e の後に `BC^l
（構文解析器は、~scriptが作成した `Text$I ~nodeを付加する）。
◎
Three Text nodes; "A" before the script, the script's contents, and "BC" after the script (the parser appends to the Text node created by the script).

<tr><td>
<pre class="html-code">
A&lt;script&gt;
var %text = document.getElementsByTagName('script')[0].firstChild;
%text.data = 'B';
document.body.appendChild(%text);
&lt;/script&gt;C
</pre>

<td>
文書~内に，隣接する 2 個の,
順に `A^l, `BC^l を包含している
`Text$I ~node。
◎
Two adjacent Text nodes in the document, containing "A" and "BC".

<tr><td>
<pre class="html-code">
A&lt;table&gt;B&lt;tr&gt;C&lt;/tr&gt;D&lt;/table&gt;
</pre>

<td>
`table^e の前に，
`ABCD^l を包含している
1 個の `Text$I ~node
（これは、`親を違える$ことにより生じる）。
◎
One Text node before the table, containing "ABCD". (This is caused by foster parenting.)

<tr><td>
<pre class="html-code">
A&lt;table&gt;&lt;tr&gt;&nbsp;B&lt;/tr&gt;&nbsp;C&lt;/table&gt;
</pre>

<td>
`table^e の前に，
`A B C^l （ A-space-B-space-C ）を包含している
1 個の `Text$I ~node（これは、`親を違える$ことにより生じる）。
◎
One Text node before the table, containing "A B C" (A-space-B-space-C). (This is caused by foster parenting.)

<tr><td>
<pre class="html-code">
A&lt;table&gt;&lt;tr&gt;&nbsp;B&lt;/tr&gt;&nbsp;&lt;/em&gt;C&lt;/table&gt;
</pre>

<td>
`table^e の前に，
`A BC^l （ A-space-B-C ）を包含している 1 個の `Text$I ~node。
`table^e の内側に，
1 個の~space文字を包含している
1 個の `Text$I ~node（ `tbody$e の子として）。
（~space文字は、文字~tokenでない~token
【ここでは "&lt;/em&gt;"】
により~spaceでない文字から分離される場合には，`親を違える$ことにより影響されない
— その後，分離している~tokenが無視されることになる場合でも。）
◎
One Text node before the table, containing "A BC" (A-space-B-C), and one Text node inside the table (as a child of a tbody) with a single space character. (Space characters separated from non-space characters by non-character tokens are not affected by foster parenting, even if those other tokens then get ignored.)
</tbody></table>

</div>

<hr>

<div class="p">
<p class="algo-head">
以下の手続きにて~comment~tokenを処理している間に
`~commentを挿入する@
ときは、所与の
( ~comment~token %~comment, 挿入~位置 %位置 （省略時は `適切な~node挿入-先$( `現在の~node$ )） )
に対し，次のようにされた新たな `Comment$I ~nodeを %位置 に挿入し~MUST：
</p>

<ul ><li>`data^m 属性 ~SET %~comment の~data
</li><li>`~node文書$ ~SET %位置 が所属する~nodeの`~node文書$
</li></ul>

◎
When the steps below require the user agent to insert a comment while processing a comment token, optionally with an explicitly insertion position position, the user agent must run the following steps:
• Let data be the data given in the comment token being processed.
• If position was specified, then let the adjusted insertion location be position. Otherwise, let adjusted insertion location be the appropriate place for inserting a node.
• Create a Comment node whose data attribute is set to data and whose node document is the same as that of the node in which the adjusted insertion location finds itself.
• Insert the newly created node at the adjusted insertion location.
</div>

<hr>

<p id="mutation-during-parsing">
~UAは、文書の構文解析による変更に対しては，~DOM変異~eventは発火しては~MUST_NOT。
これには、［
`document.write()$m ／
`document.writeln()$m
］~callを利用して挿入される内容の構文解析も含まれる。
`UIEVENTS$r
◎
DOM mutation events must not fire for changes caused by the UA parsing the document. This includes the parsing of any content inserted using document.write() and document.writeln() calls. [UIEVENTS]
</p>

<p>
しかしながら，`変異~observer$は、<em>発火する</em>
— WHATWG DOM Standard により要求されるように。
◎
However, mutation observers do fire, as required by the WHATWG DOM Standard.
</p>

				</section>
				<section id="parsing-elements-that-contain-only-text">
<h4 title="Parsing elements that contain only text">12.2.6.2. ~textのみを包含する要素の構文解析</h4>

<p class="algo-head">
［
`生~text要素の汎用~構文解析~algo@
／
`~RCDATA要素の汎用~構文解析~algo@
］は、所与の
( 開始tag~token %~token )
に対し，次を走らす：
◎
The generic raw text element parsing algorithm and the generic RCDATA element parsing algorithm consist of the following steps. These algorithms are always invoked in response to a start tag token.
</p>

<ol>
	<li>
`要素を挿入する$( %~token )
◎
Insert an HTML element for the token.
</li>
	<li>
%次n状態 ~LET ［
`生~text要素の汎用~構文解析~algo$に対しては `~RAWTEXT$st ／
`~RCDATA要素の汎用~構文解析~algo$に対しては `~RCDATA$st
］
◎
If the algorithm that was invoked is the generic raw text element parsing algorithm, switch the tokenizer to the RAWTEXT state; otherwise the algorithm invoked was the generic RCDATA element parsing algorithm,＼
</li>
	<li>
~tokenizerを %次n状態 に`切替える$
◎
switch the tokenizer to the RCDATA state.
</li>
	<li>
`元の挿入~mode$V ~SET 現在の`挿入~mode$
◎
Let the original insertion mode be the current insertion mode.
</li>
	<li>
`挿入~mode$ ~SET `~text$md
◎
Then, switch the insertion mode to "text".
</li>
</ol>

				</section>
				<section id="closing-elements-that-have-implied-end-tags">
<h4 title="Closing elements that have implied end tags">12.2.6.3. 暗黙の終了tagを有する要素を閉じるとき</h4>

<p class="algo-head">
以下の手続きにて
`暗黙の終了tagたちを生成する@
ときは、所与の要素~型 %除外-~node型 （省略時は ε ）に対し，次を走らせ~MUST
⇒
~WHILE［
`現在の~node$の要素~型は、［
`dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e
］いずれかであって %除外-~node型 ではない
⇒
`~open要素~stack$から~popする
◎
When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, or an rtc element, the UA must pop the current node off the stack of open elements.
◎
If a step requires the UA to generate implied end tags but lists an element to exclude from the process, then the UA must perform the above steps as if that element was not in the above list.
</p>

<p class="algo-head">
以下の手続きにて
`暗黙の終了tagすべてを生成する@
ときは、次を走らせ~MUST
⇒
~WHILE［
`現在の~node$は［
`caption$e, `colgroup$e, `dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e, `tbody$e, `td$e, `tfoot$e, `th$e, `thead$e, `tr$e
］いずれかの要素である
］
⇒
`~open要素~stack$から~popする
◎
When the steps below require the UA to generate all implied end tags thoroughly, then, while the current node is a caption element, a colgroup element, a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, or a tr element, the UA must pop the current node off the stack of open elements.
</p>

				</section>
				<section id="parsing-main-inhtml">
<h4 title="The rules for parsing tokens in HTML content">12.2.6.4. ~HTML内容~内の~tokenを構文解析するための規則</h4>

					<section id="the-initial-insertion-mode">
<h5 title="The &quot;initial&quot; insertion mode">12.2.6.4.1. `初期^md</h5>

<p>
［
`挿入~mode$ ~EQ `初期$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "initial" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>現tokenは無視する
</li></ol>
◎
Ignore the token.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
		<ol>
			<li>
%名前 ~LET 現~token（すなわち，現在の~DOCTYPE~token）の名前
◎
↓</li>
			<li>
%~publicID ~LET 現~tokenの~publicID
◎
↓</li>
			<li>
%~systemID ~LET 現~tokenの~systemID
◎
↓</li>
			<li>
~IF［
%名前 ~NEQ `html^l
］~OR［
%~publicID ~NEQ ε
］~OR［
%~systemID ~NIN { ε,
<a href="~HTMLurl#about:legacy-compat">`about:legacy-compat^l</a>
}
］
⇒
`~perror$
◎
If the DOCTYPE token's name is not a case-sensitive match for the string "html", or the token's public identifier is not missing, or the token's system identifier is neither missing nor a case-sensitive match for the string "about:legacy-compat", then there is a parse error.
</li>
			<li>
<p>
%doctype ~LET 次のように初期化された，新たな `DocumentType$I ~node：
</p>

<ul><li>`name^m 属性 ~SET ［
%名前 ~NEQ ε ならば %名前 ／
~ELSE_ 空~文字列
］
</li><li>`publicId^m 属性 ~SET ［
%~publicID ~NEQ ε ならば %~publicID ／
~ELSE_ 空~文字列
］
</li><li>`systemId^m 属性 ~SET ［
%~systemID ~NEQ ε ならば %~systemID ／
~ELSE_ 空~文字列
］
</li><li>`DocumentType$I ~objに特有の他の属性は［
~NULL, 空~list
］のうち適切な方に設定する
</li></ul>

◎
Append a DocumentType node to the Document node, with the name attribute set to the name given in the DOCTYPE token, or the empty string if the name was missing; the publicId attribute set to the public identifier given in the DOCTYPE token, or the empty string if the public identifier was missing; the systemId attribute set to the system identifier given in the DOCTYPE token, or the empty string if the system identifier was missing; and the other attributes specific to DocumentType objects set to null and empty lists as appropriate.＼
</li>
			<li>
%doctype を`文書$に付加する
◎
↑＼</li>
			<li>
`文書$に %doctype を結付けて，
`文書$の `doctype$m 属性の値が %doctype を返すようにする
◎
Associate the DocumentType node with the Document object so that it is returned as the value of the doctype attribute of the Document object.
</li>
			<li>
<p id="quirks-mode-doctypes">
~IF［
`文書$は`~iframe-srcdoc文書$でない
］：
</p>

				<ol>
					<li>
<p>
~IF［
現~tokenは、次に挙げるいずれかの条件を満たす
］…：
</p>

<ul ><li>`過去互換強制~flag$ ~EQ ~ON
</li><li>%名前 ~NEQ `html^l
</li><li>( %~publicID, %~systemID ) は ある “込み入った条件†” を満たす
</li></ul>

<p>
…ならば
⇒
`文書$の`~mode$doc ~SET `quirks^l
</p>

◎
Then, if the document is not an iframe srcdoc document, and the DOCTYPE token matches one of the conditions in the following list, then set the Document to quirks mode:

• The force-quirks flag is set to on.
• The name is set to anything other than "html" (compared case-sensitively).
• The public identifier is set to: "-//W3O//DTD W3 HTML Strict 3.0//EN//"
• The public identifier is set to: "-/W3C/DTD HTML 4.0 Transitional/EN"
• The public identifier is set to: "HTML"
• The system identifier is set to: "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"
• The public identifier starts with: "+//Silmaril//dtd html Pro v0r11 19970101//"
• The public identifier starts with: "-//AS//DTD HTML 3.0 asWedit + extensions//"
• The public identifier starts with: "-//AdvaSoft Ltd//DTD HTML 3.0 asWedit + extensions//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0 Strict//"
• The public identifier starts with: "-//IETF//DTD HTML 2.0//"
• The public identifier starts with: "-//IETF//DTD HTML 2.1E//"
• The public identifier starts with: "-//IETF//DTD HTML 3.0//"
• The public identifier starts with: "-//IETF//DTD HTML 3.2 Final//"
• The public identifier starts with: "-//IETF//DTD HTML 3.2//"
• The public identifier starts with: "-//IETF//DTD HTML 3//"
• The public identifier starts with: "-//IETF//DTD HTML Level 0//"
• The public identifier starts with: "-//IETF//DTD HTML Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML Level 3//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 0//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 1//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 2//"
• The public identifier starts with: "-//IETF//DTD HTML Strict Level 3//"
• The public identifier starts with: "-//IETF//DTD HTML Strict//"
• The public identifier starts with: "-//IETF//DTD HTML//"
• The public identifier starts with: "-//Metrius//DTD Metrius Presentational//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 HTML Strict//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 HTML//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 2.0 Tables//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 HTML Strict//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 HTML//"
• The public identifier starts with: "-//Microsoft//DTD Internet Explorer 3.0 Tables//"
• The public identifier starts with: "-//Netscape Comm. Corp.//DTD HTML//"
• The public identifier starts with: "-//Netscape Comm. Corp.//DTD Strict HTML//"
• The public identifier starts with: "-//O'Reilly and Associates//DTD HTML 2.0//"
• The public identifier starts with: "-//O'Reilly and Associates//DTD HTML Extended 1.0//"
• The public identifier starts with: "-//O'Reilly and Associates//DTD HTML Extended Relaxed 1.0//"
• The public identifier starts with: "-//SQ//DTD HTML 2.0 HoTMetaL + extensions//"
• The public identifier starts with: "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//"
• The public identifier starts with: "-//SoftQuad//DTD HoTMetaL PRO 4.0::19971010::extensions to HTML 4.0//"
• The public identifier starts with: "-//Spyglass//DTD HTML 2.0 Extended//"
• The public identifier starts with: "-//Sun Microsystems Corp.//DTD HotJava HTML//"
• The public identifier starts with: "-//Sun Microsystems Corp.//DTD HotJava Strict HTML//"
• The public identifier starts with: "-//W3C//DTD HTML 3 1995-03-24//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2 Draft//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2 Final//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2//"
• The public identifier starts with: "-//W3C//DTD HTML 3.2S Draft//"
• The public identifier starts with: "-//W3C//DTD HTML 4.0 Frameset//"
• The public identifier starts with: "-//W3C//DTD HTML 4.0 Transitional//"
• The public identifier starts with: "-//W3C//DTD HTML Experimental 19960712//"
• The public identifier starts with: "-//W3C//DTD HTML Experimental 970421//"
• The public identifier starts with: "-//W3C//DTD W3 HTML//"
• The public identifier starts with: "-//W3O//DTD W3 HTML 3.0//"
• The public identifier starts with: "-//WebTechs//DTD Mozilla HTML 2.0//"
• The public identifier starts with: "-//WebTechs//DTD Mozilla HTML//"
• The system identifier is missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Frameset//"
• The system identifier is missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Transitional//" 
</li>
					<li>
~ELIF［
( %~publicID, %~systemID ) は ある “込み入った条件†” を満たす
］
⇒
`文書$の`~mode$doc ~SET `limited-quirks^l
◎
Otherwise, if the document is not an iframe srcdoc document, and the DOCTYPE token matches one of the conditions in the following list, then set the Document to limited-quirks mode:

• The public identifier starts with: "-//W3C//DTD XHTML 1.0 Frameset//"
• The public identifier starts with: "-//W3C//DTD XHTML 1.0 Transitional//"
• The system identifier is not missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Frameset//"
• The system identifier is not missing and the public identifier starts with: "-//W3C//DTD HTML 4.01 Transitional//" 
◎
The system identifier and public identifier strings must be compared to the values given in the lists above in an ASCII case-insensitive manner. A system identifier whose value is the empty string is not considered missing for the purposes of the conditions above.
</li>
				</ol>

<p class="trans-note">【†
この段の “込み入った条件” の具体的な内容は、未訳。
】</p>

			</li>
			<li>
`挿入~mode$ ~SET `~htmlの前$md
◎
Then, switch the insertion mode to "before html".
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`文書$は`~iframe-srcdoc文書$でない
］：
</p>
<ol ><li>`~perror$
</li><li>`文書$の`~mode$doc ~SET `quirks^l
</li></ol>
◎
If the document is not an iframe srcdoc document, then this is a parse error; set the Document to quirks mode.
</li>
			<li>
`挿入~mode$ ~SET `~htmlの前$md
</li>
			<li>
現tokenを再処理する
◎
In any case, switch the insertion mode to "before html", then reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="the-before-html-insertion-mode">
<h5 title="The &quot;before html&quot; insertion mode">12.2.6.4.2. `~htmlの前^md</h5>

<p>
［
`挿入~mode$ ~EQ `~htmlの前$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "before html" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>現tokenは無視する
</li></ol>
◎
Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
%html ~LET `~tokenから要素を作成する$( 現token, `~HTML名前空間$, `文書$ )
◎
Create an element for the token in the HTML namespace, with the Document as the intended parent.＼
</li>
			<li>
%html を`文書$に付加する
◎
Append it to the Document object.＼
</li>
			<li>
%html を`~open要素~stack$に~pushする
◎
Put this element in the stack of open elements.
</li>
			<li id="parser-appcache">
【<a href="~NAVI#_for-app-cache">~app~cache関連の処理</a>】
◎
If the Document is being loaded as part of navigation of a browsing context, run these steps:
• If the result of running match service worker registration for the document's URL is non-null, run the application cache selection algorithm passing the Document object with no manifest.
• Otherwise, run these substeps:
•• If the newly created element has a manifest attribute whose value is not the empty string, then parse the value of that attribute, relative to the newly created element's node document, and if that is successful, run the application cache selection algorithm passing the Document object with the result of applying the URL serializer algorithm to the resulting URL record with the exclude fragment flag set.
• Otherwise, run the application cache selection algorithm passing the Document object with no manifest.
</li>
			<li>
`挿入~mode$ ~SET `~headの前$md
◎
Switch the insertion mode to "before head".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `head^l, `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "head", "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
%html ~LET 新たな `html$e 要素
◎
Create an html element＼
</li>
			<li>
%html の`~node文書$ ~SET `文書$
◎
whose node document is the Document object.＼
</li>
			<li>
%html を`文書$に付加する
◎
Append it to the Document object.＼
</li>
			<li>
%html を`~open要素~stack$に~pushする
◎
Put this element in the stack of open elements.
</li>
			<li>
【<a href="~NAVI#_for-app-cache">~app~cache関連の処理</a>】
◎
If the Document is being loaded as part of navigation of a browsing context, then: run the application cache selection algorithm with no manifest, passing it the Document object.
</li>
			<li>
`挿入~mode$ ~SET `~headの前$md
</li>
			<li>
現tokenを再処理する
◎
Switch the insertion mode to "before head", then reprocess the token.
</li>
		</ol>
	</dd>
</dl>

<p>
`文書~要素$は
— 例えば~scriptにより —
`文書$から除去される結果になり得る。
そのような事例でも，特に何も起こらず、次~節に述べるように，内容は~nodeたち
【すなわち、文書~要素, またはその子孫】
に付加され続ける。
◎
The document element can end up being removed from the Document object, e.g. by scripts; nothing in particular happens in such cases, content continues being appended to the nodes as described in the next section.
</p>

					</section>
					<section id="the-before-head-insertion-mode">
<h5 title="The &quot;before head&quot; insertion mode">12.2.6.4.3. `~headの前^md</h5>

<p>
［
`挿入~mode$ ~EQ `~headの前$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "before head" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>現tokenは無視する
</li></ol>
◎
Ignore the token.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `head^l }
◎
A start tag whose tag name is "head"
</dt>
	<dd>
		<ol>
			<li>
%head ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~head要素~pointer$ ~SET %head
◎
Set the head element pointer to the newly created head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `head^l, `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "head", "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
%head ~LET `要素を挿入する$( 新たな開始tag~token( `head^l ) )
◎
Insert an HTML element for a "head" start tag token with no attributes.
</li>
			<li>
`~head要素~pointer$ ~SET %head
◎
Set the head element pointer to the newly created head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the current token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-inhead">
<h5 title="The &quot;in head&quot; insertion mode">12.2.6.4.4. `~head内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~head内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in head" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( ~tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `base^l, `basefont^l, `bgsound^l, `link^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `meta^l }
◎
A start tag whose tag name is "meta"
</dt>
	<dd>
		<ol>
			<li>
%meta ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
~IF［
`確度$ ~NEQ `暫定的^i 
］
⇒
~RET
◎
↓</li>
			<li id="meta-charset-during-parse">
<p>
~IF［
%meta は `charset$a 属性を有する
］：
</p>
				<ol>
					<li>
%符号化方式 ~LET `符号化方式を取得する$( `charset$a 属性の値 )
</li>
					<li>
<p>
~IF［
%符号化方式 ~NEQ `失敗^i
］：
</p>
<ol><li>`符号化方式を変更する$( %符号化方式 )
</li><li>~RET
</li></ol>
					</li>
				</ol>
◎
If the element has a charset attribute, and getting an encoding from its value results in an encoding, and the confidence is currently tentative, then change the encoding to the resulting encoding.
</li>
			<li>
<p>
~IF［
%meta は `http-equiv$a 属性を有していて その値 ~EQ`大小無視$sub `Content-Type^l
］~AND［
%meta は `content$a 属性を有する
］：
</p>
				<ol>
					<li>
%符号化方式 ~LET `~meta要素から符号化方式を抽出する$( `content$a 属性の値 )
</li>
					<li>
~IF［
%符号化方式 ~NEQ ε
］
⇒
`符号化方式を変更する$( %符号化方式 )
</li>
				</ol>
◎
Otherwise, if the element has an http-equiv attribute whose value is an ASCII case-insensitive match for the string "Content-Type", and the element has a content attribute, and applying the algorithm for extracting a character encoding from a meta element to that attribute's value returns an encoding, and the confidence is currently tentative, then change the encoding to the extracted encoding.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `title^l }
◎
A start tag whose tag name is "title"
</dt>
	<dd>
<ol><li>`~RCDATA要素の汎用~構文解析~algo$に従う
</li></ol>
◎
Follow the generic RCDATA element parsing algorithm.
</dd>

	<dt>
開始tag { `noframes^l, `style^l }
◎
A start tag whose tag name is "noscript", if the scripting flag is enabled
◎
A start tag whose tag name is one of: "noframes", "style"
</dt>
	<dd>
<ol><li>`生~text要素の汎用~構文解析~algo$に従う
</li></ol>
◎
Follow the generic raw text element parsing algorithm.
</dd>

	<dt>
開始tag { `noscript^l }
◎
A start tag whose tag name is "noscript", if the scripting flag is disabled
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~scripting~flag$ ~EQ `可能化^i
］：
</p>
<ol ><li>`生~text要素の汎用~構文解析~algo$に従う
</li><li>~RET
</li></ol>
◎
↑↑</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`挿入~mode$ ~SET `~head~noscript内$md
◎
Switch the insertion mode to "in head noscript".
</li>
		</ol>
	</dd>

	<dt id="scriptTag">
開始tag { `script^l }
◎
A start tag whose tag name is "script"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
%調整-済み挿入-先 ~LET `適切な~node挿入-先$( `現在の~node$ )
◎
Let the adjusted insertion location be the appropriate place for inserting a node.
</li>
			<li>
%script ~LET `~tokenから要素を作成する$( 現token, `~HTML名前空間$, %調整-済み挿入-先 が所属する要素 )
◎
Create an element for the token in the HTML namespace, with the intended parent being the element in which the adjusted insertion location finds itself.
</li>
			<li>

<p>
%script の ( `解析器挿入~flag$, `阻まず~flag$ ) ~SET ( ~ON, ~OFF )
◎
Mark the element as being "parser-inserted" and unset the element's "non-blocking" flag.
</p>

<p class="note">注記：
これは、［
%script が外部~scriptを与えている場合に，~script内の `document.write()$m の~callは~in-lineに実行する
］ことを確保する
— 他のほとんどの事例では、それは，文書を吹飛ばすことになる。
また、終了tagに出くわすまで %script を実行されるのも防ぐ。
◎
This ensures that, if the script is external, any document.write() calls in the script will execute in-line, instead of blowing the document away, as would happen in most other cases. It also prevents the script from executing until the end tag is seen.
</p>

	</li>
			<li>
~IF［
%構文解析器 は `~HTML素片~用$である
（`素片~事例$）

］
⇒
%script の`開始済み~flag$ ~SET ~ON
◎
If the parser was originally created for the HTML fragment parsing algorithm, then mark the script element as "already started". (fragment case)
</li>
			<li id="document-written-scripts-intervention">
<p>
~IF［
%構文解析器 は［
`document.write()$m ／ `document.writeln()$m
］~methodを介して呼出されている
］
⇒
~UAの任意選択で
⇒
%script の`開始済み~flag$ ~SET ~ON
</p>

<p>
（例えば~UAは，［
~networkが遅い／
頁を読込むのに長時間かかっていた
］条件~下では、この条項を利用して，挿入された`非同一生成元$~scriptの実行を防ぐかもしれない。）
</p>
◎
If the parser was invoked via the document.write() or document.writeln() methods, then optionally mark the script element as "already started". (For example, the user agent might use this clause to prevent execution of cross-origin scripts inserted via document.write() under slow network conditions, or when the page has already taken a long time to load.)
</li>
			<li>
%script を
%調整-済み挿入-先 に挿入する
◎
Insert the newly created element at the adjusted insertion location.
</li>
			<li>
`~open要素~stack$に %script を~pushする
◎
Push the element onto the stack of open elements so that it is the new current node.
</li>
			<li>
~tokenizerを `~script~data$st に`切替える$
◎
Switch the tokenizer to the script data state.
</li>
			<li>
<p>
`元の挿入~mode$V ~LET 現在の`挿入~mode$
◎
Let the original insertion mode be the current insertion mode.
</p>

	</li>
			<li>
`挿入~mode$ ~SET `~text$md
◎
Switch the insertion mode to "text".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `head^l }
◎
An end tag whose tag name is "head"
</dt>
	<dd>
		<ol>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be the head element) off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~headの後$md
◎
Switch the insertion mode to "after head".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
開始tag { `template^l }
◎
A start tag whose tag name is "template"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~marker$を
`作動中の整形~要素~list$に付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~template内$md
◎
Switch the insertion mode to "in template".
</li>
			<li>
`~template挿入~mode~stack$に`~template内$mdを~pushする
◎
Push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~open要素~stack$内には `template$e 要素はない
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If there is no template element on the stack of open elements, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
<p>
`暗黙の終了tagすべてを生成する$
◎
Generate all implied end tags thoroughly.
</p></li>
			<li>
~IF［
`現在の~node$は `template$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a template element, then this is a parse error.
</li>
			<li>
`template$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a template element has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `head^l }
◎
A start tag whose tag name is "head"
</dt>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be the head element) off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~headの後$md
◎
Switch the insertion mode to "after head".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-inheadnoscript">
<h5 title="The &quot;in head noscript&quot; insertion mode">12.2.6.4.5. `~head~noscript内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~head~noscript内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in head noscript" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
終了tag { `noscript^l }
◎
An end tag whose tag name is "noscript"
</dt>
	<dd>
		<ol>
			<li>
~Assert：
`現在の~node$は `noscript$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a noscript element) from the stack of open elements;
</li>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
the new current node will be a head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
		</ol>
	</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>

	<dt>
~comment~token
◎
A comment token
</dt>

	<dt>
開始tag { `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `style^l }
◎
A start tag whose tag name is one of: "basefont", "bgsound", "link", "meta", "noframes", "style"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
終了tag { `br^l }
◎
An end tag whose tag name is "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
開始tag { `head^l, `noscript^l }
◎
A start tag whose tag name is one of: "head", "noscript"
</dt>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~Assert：
`現在の~node$は `noscript$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a noscript element) from the stack of open elements;
</li>
			<li>
~Assert：
`現在の~node$は `head$e 要素である
◎
the new current node will be a head element.
</li>
			<li>
`挿入~mode$ ~SET `~head内$md
◎
Switch the insertion mode to "in head".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="the-after-head-insertion-mode">
<h5 title="The &quot;after head&quot; insertion mode">12.2.6.4.6. `~headの後^md</h5>

<p>
［
`挿入~mode$ ~EQ `~headの後$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "after head" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `body^l }
◎
A start tag whose tag name is "body"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~body内$md
◎
Switch the insertion mode to "in body".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `frameset^l }
◎
A start tag whose tag name is "frameset"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`挿入~mode$ ~SET `~frameset内$md
◎
Switch the insertion mode to "in frameset".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `base^l, `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `script^l, `style^l, `template^l, `title^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
`~open要素~stack$に `~head要素~pointer$が指す~nodeを~pushする
◎
Push the node pointed to by the head element pointer onto the stack of open elements.
</li>
			<li>
`~head内$md`用の規則を用いて$現tokenを処理する
◎
Process the token using the rules for the "in head" insertion mode.
</li>
			<li>
<p>
`~open要素~stack$から `~head要素~pointer$が指す~nodeを除去する
（この時点では、それは`現在の~node$でないかもしれない）
◎
Remove the node pointed to by the head element pointer from the stack of open elements. (It might not be the current node at this point.)
</p>

<p class="note">注記：
この時点では、`~head要素~pointer$は ~NULL になり得ない。
◎
The head element pointer cannot be null at this point.
</p>
			</li>
		</ol>
	</dd>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
終了tag { `body^l, `html^l, `br^l }
◎
An end tag whose tag name is one of: "body", "html", "br"
</dt>
	<dd>
<ol><li>~GOTO ~AnyElse
</li></ol>
◎
Act as described in the "anything else" entry below.
</dd>

	<dt>
開始tag { `head^l }
◎
A start tag whose tag name is "head"
</dt>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 新たな開始tag~token( `body^l ) )
◎
Insert an HTML element for a "body" start tag token with no attributes.
</li>
			<li>
`挿入~mode$ ~SET `~body内$md
◎
Switch the insertion mode to "in body".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the current token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-inbody">
<h5 title="The &quot;in body&quot; insertion mode">12.2.6.4.7. `~body内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~body内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`文字を挿入する$( 現tokenの文字 )
◎
Insert the token's character.
</li>
		</ol>
	</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`文字を挿入する$( 現tokenの文字 )
◎
Insert the token's character.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`~open要素~stack$内に `template$e 要素はある
］
⇒
~RET — 現tokenは無視する
◎
If there is a template element on the stack of open elements, then ignore the token.
</li>
			<li>
%要素 ~LET `~open要素~stack$の先頭の要素
◎
↓</li>
			<li>
~tokenの属性~list内の~EACH( %属性 ) に対し
⇒
~IF［
%要素 は［
%属性 と同じ名前の属性
］を有していない
］
⇒
%要素 に［
%属性 の［
名前, 値
］で与えられる属性
］を追加する
◎
Otherwise, for each attribute on the token, check to see if the attribute is already present on the top element of the stack of open elements. If it is not, add the attribute and its corresponding value to that element.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `base^l, `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `script^l, `style^l, `template^l, `title^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
</dt>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
開始tag { `body^l }
◎
A start tag whose tag name is "body"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
%body ~LET `~open要素~stack$内に 2 個目の要素が［
在れば それ ／
無ければ ε
］
◎
↓</li>
			<li>
~IF［
%body は `body$e 要素でない
］~OR［
`~open要素~stack$内には `template$e 要素はある
］（`素片~事例$）
⇒
~RET — 現tokenは無視する
◎
If the second element on the stack of open elements is not a body element, if the stack of open elements has only one node on it, or if there is a template element on the stack of open elements, then ignore the token. (fragment case)
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Otherwise, set the frameset-ok flag to "not ok"; then,＼
</li>
			<li>
~token上の~EACH( %属性 ) に対し
⇒
~IF［
%body は，まだ %属性 を有していない
］
⇒
%body に %属性 を（対応している値とともに）追加する
◎
for each attribute on the token, check to see if the attribute is already present on the body element (the second element) on the stack of open elements, and if it is not, add the attribute and its corresponding value to that element.
</li>
		</ol>
</dd>

	<dt>
開始tag { `frameset^l }
◎
A start tag whose tag name is "frameset"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
%body ~LET `~open要素~stack$内に 2 個目の要素が［
在れば それ ／
無ければ ε
］
◎
↓</li>
			<li>
~IF［
%body は `body$e 要素でない
（`素片~事例$）
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements has only one node on it, or if the second element on the stack of open elements is not a body element, then ignore the token. (fragment case)
</li>
			<li>
~IF［
`~frameset-ok~flag$ ~EQ `not-ok^i
］
⇒
~RET — 現tokenは無視する
◎
If the frameset-ok flag is set to "not ok", ignore the token.
◎
Otherwise, run the following steps:
</li>
			<li>
~IF［
%body の親~nodeはある
］
⇒
%body を親~nodeから除去する
◎
Remove the second element on the stack of open elements from its parent node, if it has one.
</li>
			<li>
~WHILE［
`現在の~node$は根 `html$e 要素でない
］
⇒
`~open要素~stack$から~popする
◎
Pop all the nodes from the bottom of the stack of open elements, from the current node up to, but not including, the root html element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`挿入~mode$ ~SET `~frameset内$md
◎
Switch the insertion mode to "in frameset".
</li>
		</ol>
	</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~template挿入~mode~stack$は空でない
］：
</p>

<ol ><li>`~template内$md`用の規則を用いて$現tokenを処理する
</li><li>~RET
</li></ol>

◎
If the stack of template insertion modes is not empty, then process the token using the rules for the "in template" insertion mode.
◎
Otherwise, follow these steps:
</li>
			<li>
<p>
~IF［
`~open要素~stack$内に，次に挙げる要素~型~以外の~nodeはある
］…
⇒
`dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e, `tbody$e, `td$e, `tfoot$e, `th$e, `thead$e, `tr$e, `body$e, `html$e
</p>

<p>
…ならば
⇒
`~perror$
</p>
◎
If there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
</li>
			<li>
`構文解析を停止する$
◎
Stop parsing.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l }
◎
An end tag whose tag name is "body"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, `body^e )
］：
</p>

<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a body element in scope, this is a parse error; ignore the token.
</li>
			<li>
<p>
~IF［
`~open要素~stack$内に，次に挙げる要素~型~以外の~nodeはある
］…
⇒
`dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e, `tbody$e, `td$e, `tfoot$e, `th$e, `thead$e, `tr$e, `body$e, `html$e
</p>

<p>
…ならば
⇒
`~perror$
</p>

◎
Otherwise, if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
</li>
			<li>
`挿入~mode$ ~SET `~bodyの後$md
◎
Switch the insertion mode to "after body".
</li>
		</ol>
	</dd>
	<dt>
終了tag { `html^l }
◎
An end tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, `body^e )
］：
</p>

<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the stack of open elements does not have a body element in scope, this is a parse error; ignore the token.
</li>
			<li>
<p>
~IF［
`~open要素~stack$内に，次に挙げる要素~型~以外の~nodeはある
］…
⇒
`dd$e, `dt$e, `li$e, `optgroup$e, `option$e, `p$e, `rb$e, `rp$e, `rt$e, `rtc$e, `tbody$e, `td$e, `tfoot$e, `th$e, `thead$e, `tr$e, `body$e, `html$e
</p>

<p>
…ならば
⇒
`~perror$
</p>

◎
Otherwise, if there is a node in the stack of open elements that is not either a dd element, a dt element, an li element, an optgroup element, an option element, a p element, an rb element, an rp element, an rt element, an rtc element, a tbody element, a td element, a tfoot element, a th element, a thead element, a tr element, the body element, or the html element, then this is a parse error.
</li>
			<li>
`挿入~mode$ ~SET `~bodyの後$md
◎
Switch the insertion mode to "after body".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `address^l, `article^l, `aside^l, `blockquote^l, `center^l, `details^l, `dialog^l, `dir^l, `div^l, `dl^l, `fieldset^l, `figcaption^l, `figure^l, `footer^l, `header^l, `hgroup^l, `main^l, `menu^l, `nav^l, `ol^l, `p^l, `section^l, `summary^l, `ul^l }
◎
A start tag whose tag name is one of: "address", "article", "aside", "blockquote", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p", "section", "summary", "ul"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l }
◎
A start tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
<p>
~IF［
`現在の~node$は`~HTML要素$である
］~AND［
その~tag名 ~IN { `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l }
］：
</p>
<ol ><li>`~perror$
</li><li>`~open要素~stack$から~popする
</li></ol>
◎
If the current node is an HTML element whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a parse error; pop the current node off the stack of open elements.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `pre^l, `listing^l }
◎
A start tag whose tag name is one of: "pre", "listing"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`次n~LF文字~tokenは無視するようにしておく$
◎
If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `form^l }
◎
A start tag whose tag name is "form"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~form要素~pointer$ ~NEQ ~NULL
］~AND［
`~open要素~stack$内には `template$e 要素はない
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the form element pointer is not null, and there is no template element on the stack of open elements, then this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
↓</li>
			<li>
~IF［
`~open要素~stack$内には `template$e 要素はない
］
⇒
`~form要素~pointer$ ~SET %要素
◎
Insert an HTML element for the token, and, if there is no template element on the stack of open elements, set the form element pointer to point to the element created.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `li^l }
◎
A start tag whose tag name is "li"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
<p>
`~open要素~stack$内の~EACH( %~node ) に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
				<ol>
					<li>
<p>
~IF［
%~node は `li$e 要素である
］：
◎
Loop: If node is an li element, then run these substeps:
</p>
						<ol>
							<li>
`暗黙の終了tagたちを生成する$( `li$e )
◎
Generate implied end tags, except for li elements.
</li>
							<li>
~IF［
`現在の~node$は `li$e 要素でない
］
⇒
`~perror$
◎
If the current node is not an li element, then this is a parse error.
</li>
							<li>
`li$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an li element has been popped from the stack.
</li>
							<li>
~BREAK
◎
Jump to the step labeled done below.
</li>
						</ol>
					</li>
					<li>
~IF［
%~node は`特別$である
］~AND［
%~node は［
`address$e, `div$e, `p$e
］要素ではない
］
⇒
~BREAK
◎
If node is in the special category, but is not an address, div, or p element, then jump to the step labeled done below.
◎
Otherwise, set node to the previous entry in the stack of open elements and return to the step labeled loop.
</li>
				</ol>
			</li>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
Done: If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Finally, insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `dd^l, `dt^l }
◎
A start tag whose tag name is one of: "dd", "dt"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
<p>
`~open要素~stack$内の~EACH( %~node ) に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
				<ol>
					<li>
<p>
~IF［
%~node は `dd$e 要素である
］：
◎
Loop: If node is a dd element, then run these substeps:
</p>

						<ol>
							<li>
`暗黙の終了tagたちを生成する$( `dd$e )
◎
Generate implied end tags, except for dd elements.
</li>
							<li>
~IF［
`現在の~node$は `dd$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a dd element, then this is a parse error.
</li>
							<li>
`dd$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a dd element has been popped from the stack.
</li>
							<li>
~BREAK
◎
Jump to the step labeled done below.
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~node は `dt$e 要素である
］：
◎
If node is a dt element, then run these substeps:
</p>
						<ol>
							<li>
`暗黙の終了tagたちを生成する$( `dt$e )
◎
Generate implied end tags, except for dt elements.
</li>
							<li>
~IF［
`現在の~node$は `dt$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a dt element, then this is a parse error.
</li>
							<li>
`dt$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a dt element has been popped from the stack.
</li>
							<li>
~BREAK
◎
Jump to the step labeled done below.
</li>
						</ol>
					</li>
					<li>
~IF［
%~node は`特別$であって［
`address$e ／ `div$e ／ `p$e
］ 要素ではない
］
⇒
~BREAK
◎
If node is in the special category, but is not an address, div, or p element, then jump to the step labeled done below.
◎
Otherwise, set node to the previous entry in the stack of open elements and return to the step labeled loop.
</li>
				</ol>
			</li>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
Done: If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Finally, insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `plaintext^l }
◎
A start tag whose tag name is "plaintext"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
~tokenizerを `~PLAINTEXT$st に`切替える$
◎
Switch the tokenizer to the PLAINTEXT state.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
［
開始tagであって［
その~tag名 ~EQ `plaintext^l
］なるもの
］に出くわしたならば、それが［
文字~token（および~eof~token）以外に出くわしたことがある，最後の~token
］になる
— `~PLAINTEXT$st から外へ`切替える$仕方はないので。
◎
Once a start tag with the tag name "plaintext" has been seen, that will be the last token ever seen other than character tokens (and the end-of-file token), because there is no way to switch out of the PLAINTEXT state.
</dd>

	<dt>
開始tag { `button^l }
◎
A start tag whose tag name is "button"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `button^e )
］：
◎
If the stack of open elements has a button element in scope, then run these substeps:
</p>
				<ol>
					<li>
`~perror$
◎
Parse error.
</li>
					<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
`button$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a button element has been popped from the stack.
</li>
				</ol>
			</li>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `address^l, `article^l, `aside^l, `blockquote^l, `button^l, `center^l, `details^l, `dialog^l, `dir^l, `div^l, `dl^l, `fieldset^l, `figcaption^l, `figure^l, `footer^l, `header^l, `hgroup^l, `listing^l, `main^l, `menu^l, `nav^l, `ol^l, `pre^l, `section^l, `summary^l, `ul^l }
◎
An end tag whose tag name is one of: "address", "article", "aside", "blockquote", "button", "center", "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure", "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre", "section", "summary", "ul"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `form^l }
◎
An end tag whose tag name is "form"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~open要素~stack$内には `template$e 要素はない
］：
◎
If there is no template element on the stack of open elements, then run these substeps:
</p>
				<ol>
					<li>
%~node ~LET ［
`~form要素~pointer$ は要素ならば それ ／
~ELSE_ ~NULL
］
◎
Let node be the element that the form element pointer is set to, or null if it is not set to an element.
</li>
					<li>
`~form要素~pointer$ ~SET ~NULL
◎
Set the form element pointer to null.
</li>
					<li>
<p>
~IF［
%~node ~EQ ~NULL
］~OR［
`視野~内$に無い( `既定の視野$, %~node  )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If node is null or if the stack of open elements does not have node in scope, then this is a parse error; abort these steps and ignore the token.
</li>
					<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
~IF［
`現在の~node$ ~NEQ %~node
］
⇒
`~perror$
◎
If the current node is not node, then this is a parse error.
</li>
					<li>
`~open要素~stack$から %~node を除去する
◎
Remove node from the stack of open elements.
</li>
				</ol>
			</li>
			<li>
<p>
~IF［
`~open要素~stack$内に `template$e 要素は<em>ある</em>
］：
◎
If there is a template element on the stack of open elements, then run these substeps instead:
</p>
				<ol>
					<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, `form^e )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a form element in scope, then this is a parse error; abort these steps and ignore the token.
</li>
					<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
					<li>
~IF［
`現在の~node$は `form$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a form element, then this is a parse error.
</li>
					<li>
`form$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a form element has been popped from the stack.
</li>
				</ol>
			</li>
		</ol>
	</dd>

	<dt>
終了tag { `p^l }
◎
An end tag whose tag name is "p"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~button視野$, `p^e )
］：
</p>
<ol ><li>`~perror$
</li><li>`要素を挿入する$( 新たな開始tag~token( `p^l ) )
</li></ol>
◎
If the stack of open elements does not have a p element in button scope, then this is a parse error; insert an HTML element for a "p" start tag token with no attributes.
</li>
			<li>
`~p要素を閉じる$
◎
Close a p element.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `li^l }
◎
An end tag whose tag name is "li"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~list~item視野$, `li^e )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an li element in list item scope, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙の終了tagたちを生成する$( `li$e )
◎
Generate implied end tags, except for li elements.
</li>
			<li>
~IF［
`現在の~node$は `li$e 要素でない
］
⇒
`~perror$
◎
If the current node is not an li element, then this is a parse error.
</li>
			<li>
`li$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an li element has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `dd^l, `dt^l }
◎
An end tag whose tag name is one of: "dd", "dt"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙の終了tagたちを生成する$( 現tokenと~tag名が同じ`~HTML要素$ )
◎
Generate implied end tags, except for HTML elements with the same tag name as the token.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l }
◎
An end tag whose tag name is one of: "h1", "h2", "h3", "h4", "h5", "h6"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, { `h1^e, `h2^e, `h3^e, `h4^e, `h5^e, `h6^e } )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element and whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6", then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
{ `h1^e, `h2^e, `h3^e, `h4^e, `h5^e, `h6^e }
いずれかの要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element whose tag name is one of "h1", "h2", "h3", "h4", "h5", or "h6" has been popped from the stack.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `sarcasm^l }
◎
An end tag whose tag name is "sarcasm"
</dt>
	<dd>
<ol ><li>Take a deep breath, then…
</li><li>~GOTO その他の終了tag
</li></ol>
◎
Take a deep breath, then act as described in the "any other end tag" entry below.
</dd>

	<dt>
開始tag { `a^l }
◎
A start tag whose tag name is "a"
</dt>
	<dd>
		<ol>
			<li>
<div class="p">
<p>
~IF［
`作動中の整形~要素~list$内に次を満たす %要素 はある
］…：
</p>

<ul><li>%要素 は `a$e 要素である
</li><li>~list内の %要素 より後には`~marker$はない
</li></ul>

<p>
…ならば：
</p>
◎
If the list of active formatting elements contains an a element between the end of the list and the last marker on the list (or the start of the list if there is no marker on the list), then＼
</div>

				<ol>
					<li>
`~perror$
◎
this is a parse error;＼
</li>
					<li>
`養子縁組~algo$を走らす( 現token )
◎
run the adoption agency algorithm for the token, then＼
</li>
					<li>
［
`作動中の整形~要素~list$, `~open要素~stack$
］から %要素 を除去する
— 前~段による結果、 %要素 は除去されていなければ（`視野~内$に無い( `~table視野$, %要素 ) の場合，除去されていないかもしれない。）
◎
remove that element from the list of active formatting elements and the stack of open elements if the adoption agency algorithm didn't already remove it (it might not have if the element is not in table scope).
</li>
				</ol>

<p class="example">
適合してない~stream
`&lt;a&nbsp;href="a"&gt;a&lt;table&gt;&lt;a&nbsp;href="b"&gt;b&lt;/table&gt;x^c
内では、
1 個目の `a$e 要素は 2 個目のそれに出くわした所で閉じられ，文字 `x^l は "a" への~linkではなく "b" への~linkの内側に置かれることになる
— 1 個目の `a$e 要素は，~table視野~内に無い（~tableの始端に定例の`&lt;/a&gt;^c 終了tagがあっても， 1 個目の `a$e 要素を閉じないことを意味する）事実にもかかわらず。
その結果、この 2 個の `a$e 要素は間接的に互いの内側に
【~markup的な意味で】
入子にされる
—  適合してない~markupを構文解析した結果は、適合してない~DOMになることが多い。
◎
In the non-conforming stream &lt;a href="a"&gt;a&lt;table&gt;&lt;a href="b"&gt;b&lt;/table&gt;x, the first a element would be closed upon seeing the second one, and the "x" character would be inside a link to "b", not to "a". This is despite the fact that the outer a element is not in table scope (meaning that a regular &lt;/a&gt; end tag at the start of the table wouldn't close the outer a element). The result is that the two a elements are indirectly nested inside each other — non-conforming markup will often result in non-conforming DOMs when parsed.
</p>
			</li>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`作動中の整形~要素~listに~pushする$( %要素 )
◎
Push onto the list of active formatting elements that element.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `b^l, `big^l, `code^l, `em^l, `font^l, `i^l, `s^l, `small^l, `strike^l, `strong^l, `tt^l, `u^l }
◎
A start tag whose tag name is one of: "b", "big", "code", "em", "font", "i", "s", "small", "strike", "strong", "tt", "u"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`作動中の整形~要素~listに~pushする$( %要素 )
◎
Push onto the list of active formatting elements that element.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `nobr^l }
◎
A start tag whose tag name is "nobr"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `nobr^e )
］：
</p>

<ol ><li>`~perror$
</li><li>`養子縁組~algo$を走らす( 現token )
</li><li>`作動中の整形~要素たちを再構築する$
</li></ol>

◎
If the stack of open elements has a nobr element in scope, then this is a parse error; run the adoption agency algorithm for the token, then once again reconstruct the active formatting elements, if any.
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`作動中の整形~要素~listに~pushする$( %要素 )
◎
Push onto the list of active formatting elements that element.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `a^l, `b^l, `big^l, `code^l, `em^l, `font^l, `i^l, `nobr^l, `s^l, `small^l, `strike^l, `strong^l, `tt^l, `u^l }
◎
An end tag whose tag name is one of: "a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small", "strike", "strong", "tt", "u"
</dt>
	<dd>
<ol><li>`養子縁組~algo$を走らす( 現token )
</li></ol>
◎
Run the adoption agency algorithm for the token.
</dd>

	<dt>
開始tag { `applet^l, `marquee^l, `object^l }
◎
A start tag whose tag name is one of: "applet", "marquee", "object"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~marker$を
`作動中の整形~要素~list$に付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `applet^l, `marquee^l, `object^l }
◎
An end tag token whose tag name is one of: "applet", "marquee", "object"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise, run these steps:
</li>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
If the current node is not an HTML element with the same tag name as that of the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until an HTML element with the same tag name as the token has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `table^l }
◎
A start tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`文書$の`~mode$doc ~NEQ `quirks^l
］~AND［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the Document is not set to quirks mode, and the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `br^l }
◎
An end tag whose tag name is "br"
</dt>
	<dd>
<ol><li>`~perror$
</li><li>現token ~SET 新たな開始tag~token( `br^l ) とする下で，現tokenを再処理する
</li></ol>
◎
Parse error. Drop the attributes from the token, and act as described in the next entry; i.e. act as if this was a "br" start tag token with no attributes, rather than the end tag token that it actually is.
</dd>

	<dt>
開始tag { `area^l, `br^l, `embed^l, `img^l, `keygen^l, `wbr^l }
◎
A start tag whose tag name is one of: "area", "br", "embed", "img", "keygen", "wbr"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `input^l }
◎
A start tag whose tag name is "input"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
<p>
~IF［
現token上に次を満たす属性はある
］…
</p>
<ul><li>名前 ~EQ `type^l
</li><li>値 ~EQ`大小無視$sub `hidden^l
</li></ul>

<p>
…ならば
⇒
~RET
</p>
◎
If the token does not have an attribute with the name "type", or if it does, but that attribute's value is not an ASCII case-insensitive match for the string "hidden", then:＼
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `param^l, `source^l, `track^l }
◎
A start tag whose tag name is one of: "param", "source", "track"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `hr^l }
◎
A start tag whose tag name is "hr"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `image^l }
◎
A start tag whose tag name is "image"
</dt>
	<dd>
<ol><li>`~perror$
</li><li>現tokenの~tag名 ~SET `img^l
</li><li>現tokenを再処理する
</li></ol>

<p>
Don’t ask.
【わけは聞かないでくれ？】
</p>

◎
Parse error. Change the token's tag name to "img" and reprocess it. (Don't ask.)
</dd>

	<dt>
開始tag { `textarea^l }
◎
A start tag whose tag name is "textarea"
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`次n~LF文字~tokenは無視するようにしておく$
◎
If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)
</li>
			<li>
~tokenizerを `~RCDATA$st に`切替える$
◎
Switch the tokenizer to the RCDATA state.
</li>
			<li>
`元の挿入~mode$V ~LET 現在の`挿入~mode$
◎
Let the original insertion mode be the current insertion mode.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET `~text$md
◎
Switch the insertion mode to "text".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `xmp^l }
◎
A start tag whose tag name is "xmp"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`視野~内$に在る( `~button視野$, `p^e )
］
⇒
`~p要素を閉じる$
◎
If the stack of open elements has a p element in button scope, then close a p element.
</li>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`生~text要素の汎用~構文解析~algo$に従う
◎
Follow the generic raw text element parsing algorithm.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `iframe^l }
◎
A start tag whose tag name is "iframe"
</dt>
	<dd>
		<ol>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`生~text要素の汎用~構文解析~algo$に従う
◎
Follow the generic raw text element parsing algorithm.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `noembed^l }
◎
A start tag whose tag name is "noembed"
</dt>
	<dd>
<ol ><li>`生~text要素の汎用~構文解析~algo$に従う
</li></ol>

◎
↓</dd>

	<dt>
開始tag { `noscript^l }
◎
A start tag whose tag name is "noscript", if the scripting flag is enabled
</dt>
	<dd>
		<ol>
			<li>
~IF［
`~scripting~flag$ ~NEQ `可能化^i
］
⇒
~GOTO その他の開始tag
</li>
			<li>
`生~text要素の汎用~構文解析~algo$に従う
</li>
		</ol>

◎
Follow the generic raw text element parsing algorithm.
</dd>

	<dt>
開始tag { `select^l }
◎
A start tag whose tag name is "select"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
			<li>
`挿入~mode$ ~SET ［
`挿入~mode$ ~IN { `~table内$md, `~caption内$md, `~table~body内$md, `~row内$md, `~cell内$md } ならば `~table内~select内$md ／
~ELSE_ `~select内$md
］
◎
If the insertion mode is one of "in table", "in caption", "in table body", "in row", or "in cell", then switch the insertion mode to "in select in table". Otherwise, switch the insertion mode to "in select".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `optgroup^l, `option^l }
◎
A start tag whose tag name is one of: "optgroup", "option"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$ は `option$e 要素である
］
⇒
`~open要素~stack$から~popする
◎
If the current node is an option element, then pop the current node off the stack of open elements.
</li>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `rb^l, `rtc^l }
◎
A start tag whose tag name is one of: "rb", "rtc"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `ruby^e )
］：
</p>
				<ol>
					<li>
`暗黙の終了tagたちを生成する$()
</li>
					<li>
~IF［
`現在の~node$は `ruby$e 要素でない
］
⇒
`~perror$
</li>
				</ol>
◎
If the stack of open elements has a ruby element in scope, then generate implied end tags. If the current node is not now a ruby element, this is a parse error.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `rp^l, `rt^l }
◎
A start tag whose tag name is one of: "rp", "rt"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に在る( `既定の視野$, `ruby^e )
］：
</p>
				<ol>
					<li>
`暗黙の終了tagたちを生成する$( `rtc$e )
</li>
					<li>
~IF［
`現在の~node$は［
`rtc$e ／ `ruby$e
］要素でない
］
⇒
`~perror$
</li>
				</ol>

◎
If the stack of open elements has a ruby element in scope, then generate implied end tags, except for rtc elements. If the current node is not now a rtc element or a ruby element, this is a parse error.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `math^l }
◎
A start tag whose tag name is "math"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`~MathML属性たちを調整する$( 現token )
（これは、~MathML属性に非~小文字が含まれている事例を修正する。）
◎
Adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)
</li>
			<li>
`外来の属性たちを調整する$( 現token )
（これは、名前空間~付きの属性の利用
 — 特に~XLink  —
 を修正する。）
◎
Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink.)
</li>
			<li>
`要素を挿入する$( 現token, `~MathML名前空間$ )
◎
Insert a foreign element for the token, in the MathML namespace.
</li>
			<li>
<p>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］：
</p>

<ol ><li>`~open要素~stack$から~popする
</li><li>`自己閉じ~flagを承認する$( 現token )
</li></ol>

◎
If the token has its self-closing flag set, pop the current node off the stack of open elements and acknowledge the token's self-closing flag.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `svg^l }
◎
A start tag whose tag name is "svg"
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
`~SVG属性たちを調整する$( 現token )
（これは、~SVG属性に非~小文字が含まれている事例を修正する。）
◎
Adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)
</li>
			<li>
`外来の属性たちを調整する$( 現token )
（これは、名前空間~付きの属性の利用
— 特に~SVGにおける~XLink —
を修正する。）
◎
Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)
</li>
			<li>
`要素を挿入する$( 現token, `~SVG名前空間$ )
◎
Insert a foreign element for the token, in the SVG namespace.
</li>
			<li>
<p>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］：
</p>

<ol ><li>`~open要素~stack$から~popする
</li><li>`自己閉じ~flagを承認する$( 現token )
</li></ol>

◎
If the token has its self-closing flag set, pop the current node off the stack of open elements and acknowledge the token's self-closing flag.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `caption^l, `col^l, `colgroup^l, `frame^l, `head^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "frame", "head", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
その他の開始tag
◎
Any other start tag
</dt>
	<dd>
		<ol>
			<li>
`作動中の整形~要素たちを再構築する$
◎
Reconstruct the active formatting elements, if any.
</li>
			<li>
<p>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</p>

<p class="note">注記：
この要素は、`普通の要素$になる。
◎
This element will be an ordinary element.
</p>
			</li>
		</ol>
	</dd>

	<dt>
その他の終了tag
◎
Any other end tag
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
<p>
`~open要素~stack$内の~EACH( %~node ) に対し，末尾から順に：
◎
Initialize node to be the current node (the bottommost node of the stack).
</p>
				<ol>
					<li>
<p>
~IF［
%~node は現tokenと~tag名が同じ`~HTML要素$である
］：
◎
Loop: If node is an HTML element with the same tag name as the token, then:
</p>

						<ol>
							<li>
`暗黙の終了tagたちを生成する$( 現tokenと~tag名が同じ`~HTML要素$ )
◎
Generate implied end tags, except for HTML elements with the same tag name as the token.
</li>
							<li>
~IF［
%~node は`現在の~node$でない
］
⇒
`~perror$
◎
If node is not the current node, then this is a parse error.
</li>
							<li>
%~node が`出るまで~open要素~stackから~popする$
◎
Pop all the nodes from the current node up to node, including node, then stop these steps.
</li>
							<li>
~RET
</li>
						</ol>
					</li>
					<li>
<p>
~IF［
%~node は`特別$である
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
Otherwise, if node is in the special category, then this is a parse error; ignore the token, and abort these steps.
◎
Set node to the previous entry in the stack of open elements.
◎
Return to the step labeled loop.
</li>
				</ol>
			</li>
		</ol>
	</dd>
</dl>


<p class="algo-head">
上の手続きにおいて
`次n~LF文字~tokenは無視するようにしておく@
と記された所では、次回に発された~tokenが次を満たす場合には，それは無視する（飛ばす）ようにしておくことを意味する
⇒
文字~tokenであって，その文字 ~EQ `000A^U である
◎
↑↑</p>

<p>
（これは，著作~利便のため、［
`pre$e ~block ／ `textarea$e 要素
］の始端にある改行文字を無視するためにある。）
◎
↑↑</p>

<p class="algo-head">
上の手続きにおいて
`~p要素を閉じる@
ときは、次を走らせ~MUST：
◎
When the steps above say the user agent is to close a p element, it means that the user agent must run the following steps:
</p>

<ol>
	<li>
`暗黙の終了tagたちを生成する$( `p$e )
◎
Generate implied end tags, except for p elements.
</li>
	<li>
~IF［
`現在の~node$は `p$e 要素でない
］
⇒
`~perror$
◎
If the current node is not a p element, then this is a parse error.
</li>
	<li>
`p$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a p element has been popped from the stack.
</li>
</ol>

<p class="algo-head" id="adoptionAgency">
`養子縁組~algo@
は、所与の~token %~token に対し，次を走らす：
◎
The adoption agency algorithm, which takes as its only argument a token token for which the algorithm is being run, consists of the following steps:
</p>

<ol>
	<li>
%整形~要素~list ~LET `作動中の整形~要素~list$
</li>
	<li>
<p>
~IF［
`現在の~node$は`~HTML要素$である
］~AND［
`現在の~node$の~tag名 ~EQ %~token の~tag名
］~AND［
`現在の~node$ ~NIN %整形~要素~list
］：
</p>
<ol ><li>`~open要素~stack$から~popする
</li><li>~RET
</li></ol>
◎
Let subject be token's tag name.
◎
If the current node is an HTML element whose tag name is subject, and the current node is not in the list of active formatting elements, then pop the current node off the stack of open elements, and abort these steps.
</li>
	<li>
%外縁~loop~counter ~LET 0
◎
Let outer loop counter be zero.
</li>
	<li>
<p>
~WHILE［
%外縁~loop~counter ~LT 8
］：
◎
Outer loop: If outer loop counter is greater than or equal to eight, then abort these steps.
</p>
		<ol>
			<li>
%外縁~loop~counter ~INCBY 1
◎
Increment outer loop counter by one.
</li>
			<li>
<p>
%整形~要素 ~LET %整形~要素~list 内に次を満たす要素が［
在れば それらのうち最後のもの／
無ければ ε
］：
◎
Let formatting element be the last element in the list of active formatting elements that:
</p>
				<ul>
					<li>
%整形~要素~list 内の要素より後には`~marker$はない
◎
is between the end of the list and the last marker in the list, if any, or the start of the list otherwise, and
</li>
					<li>
要素の~tag名 ~EQ %~token の~tag名
◎
has the tag name subject.
</li>
				</ul>
			</li>
			<li>
<p>
~IF［
%整形~要素 ~EQ ε
］：
</p>
<ol ><li>上に述べた  “その他の終了tag” と同じに動作する
</li><li>~RET
</li></ol>

◎
If there is no such element, then abort these steps and instead act as described in the "any other end tag" entry above.
</li>
			<li>
<p>
~IF［
%整形~要素 ~NIN `~open要素~stack$
］：
</p>
<ol ><li>`~perror$
</li><li>%整形~要素~list から %整形~要素 を除去する
</li><li>~RET
</li></ol>

◎
If formatting element is not in the stack of open elements, then this is a parse error; remove the element from the list, and abort these steps.
</li>
			<li>
<p>
~IF［
`視野~内$に無い( `既定の視野$, %整形~要素 )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET
</li></ol>
◎
If formatting element is in the stack of open elements, but the element is not in scope, then this is a parse error; abort these steps.
</li>
			<li>
~IF［
%整形~要素 ~NEQ `現在の~node$
］
⇒
`~perror$
◎
If formatting element is not the current node, this is a parse error. (But do not abort these steps.)
</li>
			<li>
%最遠の~block ~LET `~open要素~stack$内で %整形~要素 より後に`特別な要素$が［
在れば それらのうち最初のもの ／
無ければ ε
］
◎
Let furthest block be the topmost node in the stack of open elements that is lower in the stack than formatting element, and is an element in the special category. There might not be one.
</li>
			<li>
<p>
~IF［
%最遠の~block ~EQ ε
］：
</p>

<ol ><li>%整形~要素 が`出るまで~open要素~stackから~popする$
</li><li>%整形~要素~list から %整形~要素 を除去する
</li><li>~RET
</li></ol>
◎
If there is no furthest block, then the UA must first pop all the nodes from the bottom of the stack of open elements, from the current node up to and including formatting element, then remove formatting element from the list of active formatting elements, and finally abort these steps.
</li>
			<li>
%共通の先祖 ~LET
`~open要素~stack$内で %整形~要素 の直前にある要素
◎
Let common ancestor be the element immediately above formatting element in the stack of open elements.
</li>
			<li>
%~bookmark ~LET %整形~要素~list 内で %整形~要素 の直後を指す位置
◎
Let a bookmark note the position of formatting element in the list of active formatting elements relative to the elements on either side of it in the list.
</li>
			<li>
%最後の~node ~LET %最遠の~block
◎
Let node and last node be furthest block. Follow these steps:
↓↓</li>
			<li>
%内縁~loop~counter ~LET 0
◎
Let inner loop counter be zero.
</li>
			<li>
<p>
`~open要素~stack$内で
%整形~要素 より後にある, かつ
%最遠の~block より前にある ~EACH( %~node ) に対し，最後のものから順に：
◎
Inner loop: Increment inner loop counter by one.
◎
Let node be the element immediately above node in the stack of open elements, or if node is no longer in the stack of open elements (e.g. because it got removed by this algorithm), the element that was immediately above node in the stack of open elements before node was removed.
◎
If node is formatting element, then go to the next step in the overall algorithm.
</p>
				<ol>
					<li>
%内縁~loop~counter ~INCBY 1
◎
↑</li>
					<li>
~IF［
%内縁~loop~counter ~GT 3
］~AND［
%~node ~IN %整形~要素~list
］
⇒
%整形~要素~list から %~node を除去する
◎
If inner loop counter is greater than three and node is in the list of active formatting elements, then remove node from the list of active formatting elements.
</li>
					<li>
<p>
~IF［
%~node ~NIN %整形~要素~list
］：
</p>
<ol ><li>%~node を`~open要素~stack$から除去する
</li><li>~CONTINUE
</li></ol>
◎
If node is not in the list of active formatting elements, then remove node from the stack of open elements and then go back to the step labeled inner loop.
</li>
					<li>
%新たな要素 ~LET
`~tokenから要素を作成する$( 要素 %~node を`作成させた~token$, `~HTML名前空間$, %共通の先祖 )
◎
Create an element for the token for which the element node was created, in the HTML namespace, with common ancestor as the intended parent;＼
</li>
					<li>
%整形~要素~list 内で %~node を %新たな要素 に置換する
◎
replace the entry for node in the list of active formatting elements with an entry for the new element,＼
</li>
					<li>
`~open要素~stack$内で %~node  を %新たな要素 に置換する
◎
replace the entry for node in the stack of open elements with an entry for the new element, and＼
</li>
					<li>
%~node ~SET %新たな要素
◎
let node be the new element.
</li>
					<li>
~IF［
%最後の~node ~EQ %最遠の~block
］
⇒
%~bookmark ~SET %整形~要素~list 内で %~node の直後を指す位置
◎
If last node is furthest block, then move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.
</li>
					<li>
~IF［
%最後の~node の親~nodeはある
］
⇒
%最後の~node を親~nodeから除去する
◎
↓</li>
					<li>
%最後の~node を %~node の中に挿入する
◎
Insert last node into node, first removing it from its previous parent node if any.
</li>
					<li>
%最後の~node ~SET %~node
◎
Let last node be node.
◎
Return to the step labeled inner loop.
</li>
				</ol>
			</li>
			<li>
%最後の~node を`適切な~node挿入-先$( %共通の先祖 ) に挿入する
— この段に達した時点での %最後の~node が何であれ
◎
Insert whatever last node ended up being in the previous step at the appropriate place for inserting a node, but using common ancestor as the override target.
</li>
			<li>
%新たな要素 ~LET `~tokenから要素を作成する$( %整形~要素 を`作成させた~token$, `~HTML名前空間$, %最遠の~block )
◎
Create an element for the token for which formatting element was created, in the HTML namespace, with furthest block as the intended parent.
</li>
			<li>
<p>
%最遠の~block 内の~EACH( 子~node %子 ) に対し：
</p>
<ol><li>%最遠の~block から %子 を除去する
</li><li>%新たな要素 に %子 を付加する
</li></ol>

◎
Take all of the child nodes of furthest block and append them to the element created in the last step.
</li>
			<li>
%新たな要素 を %最遠の~block に付加する
◎
Append that new element to furthest block.
</li>
			<li>
%整形~要素 を %整形~要素~list から除去する
◎
Remove formatting element from the list of active formatting elements, and＼
</li>
			<li>
%整形~要素~list 内で %~bookmark が指す位置に， %新たな要素 を挿入する
◎
insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.
</li>
			<li>
%整形~要素 を`~open要素~stack$から除去する
◎
Remove formatting element from the stack of open elements, and＼
</li>
			<li>
`~open要素~stack$内で %最遠の~block の直後に， %新たな要素 を挿入する
◎
insert the new element into the stack of open elements immediately below the position of furthest block in that stack.
◎
Jump back to the step labeled outer loop.
</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
この~algoの名前
“養子縁組”
は、それが要素の親を変更する仕方に~~由来する
— 他にも，誤入子な内容を取り扱うための~algo名の~~候補として
“incest algorithm”, “secret affair algorithm”, “Heisenberg algorithm”
などが挙げられたが。
◎
This algorithm's name, the "adoption agency algorithm", comes from the way it causes elements to change parents, and is in contrast with other possible algorithms for dealing with misnested content, which included the "incest algorithm", the "secret affair algorithm", and the "Heisenberg algorithm".
</p>

					</section>
					<section id="parsing-main-incdata">
<h5 title="The &quot;text&quot; insertion mode">12.2.6.4.8. `~text^md</h5>

<p>
［
`挿入~mode$ ~EQ `~text$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "text" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token
◎
A character token
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the token's character.
</dd>
	<dd class="note">注記：
この~tokenの文字が、 `0000^U になることは決してない
— そのような文字は、~tokenizerにより `FFFD^U に変換されるので。
◎
This can never be a U+0000 NULL character; the tokenizer converts those to U+FFFD REPLACEMENT CHARACTER characters.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`現在の~node$は `script$e 要素である
］
⇒
`現在の~node$の`開始済み~flag$ ~SET ~ON
◎
If the current node is a script element, mark the script element as "already started".
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt id="scriptEndTag">
終了tag { `script^l }
◎
An end tag whose tag name is "script"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`~JS実行~文脈~stack$は空である
］
⇒
`極小task~checkpointを遂行する$
◎
If the JavaScript execution context stack is empty, perform a microtask checkpoint.
</li>
			<li>
%~script ~LET `現在の~node$
◎
Let script be the current node＼
</li>
			<li>
~Assert：
%~script は `script$e 要素である
◎
(which will be a script element).
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode.
</li>
			<li>
%旧~挿入~地点~LET 現在の`挿入~地点$
◎
Let the old insertion point have the same value as the current insertion point.＼
</li>
			<li>
`挿入~地点$ ~SET `次n入力~文字$の直前
◎
Let the insertion point be just before the next input character.
</li>
			<li>
%構文解析器 の`~script入子~level$ ~INCBY 1
◎
Increment the parser's script nesting level by one.
</li>
			<li>
%~script を`準備-$する
⇒
これは何らかの~scriptを実行させ得る
— その結果
⇒
~tokenizerに
<a href="~HTML5/dynamic-markup-insertion.html#dom-document-write">新たな文字たちが挿入され得る</a>
— その結果
⇒
~tokenizerにさらに~tokenたちを出力させ得る
— その結果
⇒
%構文解析器 は<a href="#nestedParsing">再入的に呼出される</a>
◎
Prepare the script. This might cause some script to execute, which might cause new characters to be inserted into the tokenizer, and might cause the tokenizer to output more tokens, resulting in a reentrant invocation of the parser.
</li>
			<li>
%構文解析器 の`~script入子~level$ ~DECBY 1
◎
Decrement the parser's script nesting level by one.＼
</li>
			<li>
~IF［
%構文解析器 の`~script入子~level$ ~EQ 0
］
⇒
%構文解析器 の`一時停止~flag$ ~SET ~F
◎
If the parser's script nesting level is zero, then set the parser pause flag to false.
</li>
			<li>
`挿入~地点$ ~SET %旧~挿入~地点
◎
Let the insertion point have the value of the old insertion point. (In other words, restore the insertion point to its previous value. This value might be the "undefined" value.)
</li>
			<li id="scriptTagParserResumes">
~IF［
`文書$の`構文解析器を阻んでいる~script$ ~EQ ε
］
⇒
~RET
◎
At this stage, if there is a pending parsing-blocking script, then:
</li>
			<li>
<p>
~IF［
`~script入子~level$ ~NEQ 0
］：
◎
If the script nesting level is not zero:
</p>
				<ol>
					<li>
%構文解析器 の`一時停止~flag$ ~SET ~T
◎
Set the parser pause flag to true, and＼
</li>
			<li>
<p>
入子で呼出されている~tokenizerがあれば その処理も中止して、その~call元に制御を明け渡す（~token化は、~call元が “外縁の” 木~構築~段階に戻ったとき，再開することになる。）
◎
abort the processing of any nested invocations of the tokenizer, yielding control back to the caller. (Tokenization will resume when the caller returns to the "outer" tree construction stage.)
</p>

<p class="note">注記：
%構文解析器 の木~構築~段階は、
<a href="#nestedParsing">再入的に~callされている</a>
— 例えば `document.write()$m の~callから。
◎
The tree construction stage of this particular parser is being called reentrantly, say from a call to document.write().
</p>
					</li>
					<li>
~RET
◎
Otherwise:
• Run these steps:
</li>
				</ol>
			</li>
			<li>
%当の~script ~LET `文書$の`構文解析器を阻んでいる~script$
◎
Let the script be the pending parsing-blocking script.＼
</li>
			<li>
`文書$の`構文解析器を阻んでいる~script$ ~SET ε
◎
There is no longer a pending parsing-blocking script.
</li>
			<li>
%構文解析器 の`~tokenizer$を阻む
— `~event~loop$が その`~tokenizer$を呼出す`~task$を走らすことのないよう
◎
Block the tokenizer for this instance of the HTML parser, such that the event loop will not run tasks that invoke the tokenizer.
</li>
			<li>
<p>
~IF［
次のいずれかの条件は満たされていない
］…：
</p>

<ul ><li>`文書$には`~scriptを阻んでいる~stylesheetは無い$
</li><li>%当の~script の`解析器実行準備済み~flag$ ~EQ ~ON
</li></ul>

<p>
…ならば
⇒
これらの条件がいずれも満たされるまで`~event~loopを回す$
</p>

◎
If the parser's Document has a style sheet that is blocking scripts or the script's "ready to be parser-executed" flag is not set: spin the event loop until the parser's Document has no style sheet that is blocking scripts and the script's "ready to be parser-executed" flag is set.
</li>
			<li>
<p>
~IF［
%構文解析器 は（当面の間）`中止-$されている
］
⇒
~RET
◎
If this parser has been aborted in the meantime, abort these steps.
</p>

<p class="note">注記：
これは，例えば、`~event~loopを回す$~algoが走っている間に，［
`文書$が`属する閲覧文脈$が閉じられた ／
`文書$上で `document.open()$m ~methodが呼出された
］場合に起こり得る。
◎
This could happen if, e.g., while the spin the event loop algorithm is running, the browsing context gets closed, or the document.open() method gets invoked on the Document.
</p>
			</li>
			<li>
%構文解析器 の`~tokenizer$を阻むのをやめて、`~tokenizer$を呼出している`~task$が，再度~走れるようにする
◎
Unblock the tokenizer for this instance of the HTML parser, such that tasks that invoke the tokenizer can again be run.
</li>
			<li>
`挿入~地点$ ~SET `次n入力~文字$の直前
◎
Let the insertion point be just before the next input character.
</li>
			<li>
~Assert：
%構文解析器 の`~script入子~level$ ~EQ 0 であるべき
◎
↓</li>
			<li>
%構文解析器 の`~script入子~level$ ~INCBY 1
◎
Increment the parser's script nesting level by one (it should be zero before this step, so this sets it to one).
</li>
			<li>
%当の~script の`~script~blockを実行する$
◎
Execute the script.
</li>
			<li>
%構文解析器 の`~script入子~level$ ~DECBY 1
◎
Decrement the parser's script nesting level by one.＼
</li>
			<li>
~Assert：
%構文解析器 の`~script入子~level$ ~EQ 0 であるべき
◎
↓</li>
			<li>
~IF［
%構文解析器 の`~script入子~level$ ~EQ 0
］
⇒
%構文解析器 の`一時停止~flag$ ~SET ~F
◎
If the parser's script nesting level is zero (which it always should be at this point), then set the parser pause flag to false.
</li>
			<li>
`挿入~地点$ ~SET ε
◎
Let the insertion point be undefined again.
</li>
			<li>
~IF［
`文書$の`構文解析器を阻んでいる~script$ ~NEQ ε
］
⇒
~GOTO 最初の段
◎
If there is once again a pending parsing-blocking script, then repeat these steps from step 1.
</li>
		</ol>
	</dd>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
		<ol>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-intable">
<h5 title="The &quot;in table&quot; insertion mode">12.2.6.4.9. `~table内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~table内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in table" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token
◎
A character token, ＼
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は［
`table$e, `tbody$e, `tfoot$e, `thead$e, `tr$e
］のいずれの要素でもない
］
⇒
~GOTO ~AnyElse
◎
if the current node is table, tbody, tfoot, thead, or tr element
</li>
			<li>
`処理待ち~table文字~token~list@V ~LET 空の~token~list
◎
Let the pending table character tokens be an empty list of tokens.
</li>
			<li>
`元の挿入~mode$V ~SET `~table内$md
◎
Let the original insertion mode be the current insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~table~text内$md
◎
Switch the insertion mode to "in table text" and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `caption^l }
◎
A start tag whose tag name is "caption"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`~marker$を
`作動中の整形~要素~list$に付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~caption内$md
◎
switch the insertion mode to "in caption".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `colgroup^l }
◎
A start tag whose tag name is "colgroup"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~column-group内$md
◎
switch the insertion mode to "in column group".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `col^l }
◎
A start tag whose tag name is "col"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 新たな開始tag~token( `colgroup^l ) )
◎
Insert an HTML element for a "colgroup" start tag token with no attributes, then＼
</li>
			<li>
`挿入~mode$ ~SET `~column-group内$md
◎
switch the insertion mode to "in column group".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the current token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `tbody^l, `tfoot^l, `thead^l }
◎
A start tag whose tag name is one of: "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
switch the insertion mode to "in table body".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `td^l, `th^l, `tr^l }
◎
A start tag whose tag name is one of: "td", "th", "tr"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table文脈まで遡って~clearする$
◎
Clear the stack back to a table context. (See below.)
</li>
			<li>
`要素を挿入する$( 新たな開始tag~token( `tbody^l ) )
◎
Insert an HTML element for a "tbody" start tag token with no attributes, then＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
switch the insertion mode to "in table body".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the current token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `table^l }
◎
A start tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`視野~内$に無い( `~table視野$, `table^e )
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have a table element in table scope, ignore the token.
◎
Otherwise:
</li>
			<li>
`table$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from this stack until a table element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `table^e )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a table element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`table$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from this stack until a table element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `style^l, `script^l, `template^l }
◎
A start tag whose tag name is one of: "style", "script", "template"
</dt>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
開始tag { `input^l }
◎
A start tag whose tag name is "input"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
現token上に次を満たす属性はない
］…
</p>
<ul><li>名前 ~EQ `type^l
</li><li>値 ~EQ`大小無視$sub `hidden^l
</li></ul>

<p>
…ならば
⇒
~GOTO ~AnyElse
</p>
◎
If the token does not have an attribute with the name "type", or if it does, but that attribute's value is not an ASCII case-insensitive match for the string "hidden", then: act as described in the "anything else" entry below.
◎
Otherwise:
</li>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop that input element off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `form^l }
◎
A start tag whose tag name is "form"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`~open要素~stack$内には `template$e 要素はある
］~OR［
`~form要素~pointer$ ~NEQ ~NULL
］
⇒
~RET — 現tokenは無視する
◎
If there is a template element on the stack of open elements, or if the form element pointer is not null, ignore the token.
◎
Otherwise:
</li>
			<li>
%要素 ~LET `要素を挿入する$( 現token )
◎
Insert an HTML element for the token, and＼
</li>
			<li>
`~form要素~pointer$ ~SET %要素
◎
set the form element pointer to point to the element created.
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop that form element off the stack of open elements.
</li>
		</ol>
	</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.＼
</li>
			<li>
`親を違える$のを可能化する
◎
Enable foster parenting,＼
</li>
			<li>
`~body内$md`用の規則を用いて$現tokenを処理する
◎
process the token using the rules for the "in body" insertion mode, and then＼
</li>
			<li>
`親を違える$のを不能化する
◎
disable foster parenting.
</li>
		</ol>
	</dd>
</dl>

<p class="algo-head">
上の手続きが
`~stackを~table文脈まで遡って~clearする@
所では、次を走らせ~MUST
⇒
~WHILE［
`現在の~node$は［
`table$e ／ `template$e ／ `html$e
］要素でない
］
⇒
`~open要素~stack$から~popする
◎
When the steps above require the UA to clear the stack back to a table context, it means that the UA must, while the current node is not a table, template, or html element, pop elements from the stack of open elements.
</p>

<p class="note">注記：
これは、`~table視野$に挙げられた要素たちと同じである。
◎
This is the same list of elements as used in the has an element in table scope steps.
</p>

<p class="note">注記：
この処理-後に`現在の~node$が `html$e 要素になるのは、`素片~事例$に限られる。
◎
The current node being an html element after this process is a fragment case.
</p>

					</section>
					<section id="parsing-main-intabletext">
<h5 title="The &quot;in table text&quot; insertion mode">12.2.6.4.10. `~table~text内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~table~text内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in table text" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
<ol><li>現tokenを `処理待ち~table文字~token~list$V に付加する
</li></ol>
◎
Append the character token to the pending table character tokens list.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`処理待ち~table文字~token~list$V 内の ある文字~tokenの文字は`~ASCII空白$でない
］：
</p>

<ol><li>`~perror$
</li><li>`処理待ち~table文字~token~list$V 内の ~EACH( 文字~token ) に対し
⇒
文字~tokenを［
`~table内$md 挿入~modeにおける ~AnyElse ~entryに与える規則
］を利用して再処理する
</li></ol>

◎
If any of the tokens in the pending table character tokens list are character tokens that are not ASCII whitespace, then this is a parse error: reprocess the character tokens in the pending table character tokens list using the rules given in the "anything else" entry in the "in table" insertion mode.
</li>
			<li>
~ELSE
⇒
`処理待ち~table文字~token~list$V 内の~EACH( ~token ) に対し
⇒
`文字を挿入する$( ~tokenの文字 )
◎
Otherwise, insert the characters given by the pending table character tokens list.
</li>
			<li>
`挿入~mode$ ~SET `元の挿入~mode$V
◎
Switch the insertion mode to the original insertion mode and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-incaption">
<h5 title="The &quot;in caption&quot; insertion mode">12.2.6.4.11. `~caption内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~caption内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in caption" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
終了tag { `caption^l }
◎
An end tag whose tag name is "caption"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `caption^e )
（`素片~事例$）
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a caption element in table scope, this is a parse error; ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は `caption$e 要素でない
］
⇒
`~perror$
◎
Now, if the current node is not a caption element, then this is a parse error.
</li>
			<li>
`caption$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from this stack until a caption element has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>

	<dt>
終了tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `caption^e )
（`素片~事例$）
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a caption element in table scope, this is a parse error; ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は `caption$e 要素でない
］
⇒
`~perror$
◎
Now, if the current node is not a caption element, then this is a parse error.
</li>
			<li>
`caption$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from this stack until a caption element has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l, `col^l, `colgroup^l, `html^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
An end tag whose tag name is one of: "body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>
</dl>

					</section>
					<section id="parsing-main-incolgroup">
<h5 title="The &quot;in column group&quot; insertion mode">12.2.6.4.12. `~column-group内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~column-group内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in column group" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `col^l }
◎
A start tag whose tag name is "col"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `colgroup^l }
◎
An end tag whose tag name is "colgroup"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は `colgroup$e 要素でない
］：
</p>
<ol><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the current node is not a colgroup element, then this is a parse error; ignore the token.
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise, pop the current node from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
終了tag { `col^l }
◎
An end tag whose tag name is "col"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `template^l }
◎
A start tag whose tag name is "template"
</dt>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は `colgroup$e 要素でない
］：
</p>

<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the current node is not a colgroup element, then this is a parse error; ignore the token.
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise, pop the current node from the stack of open elements.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-intbody">
<h5 title="The &quot;in table body&quot; insertion mode">12.2.6.4.13. `~table~body内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~table~body内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in table body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
開始tag { `tr^l }
◎
A start tag whose tag name is "tr"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
Clear the stack back to a table body context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
switch the insertion mode to "in row".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `th^l, `td^l }
◎
A start tag whose tag name is one of: "th", "td"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
Clear the stack back to a table body context. (See below.)
</li>
			<li>
`要素を挿入する$( 新たな開始tag~token( `tr^l ) )
◎
Insert an HTML element for a "tr" start tag token with no attributes, then＼
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
switch the insertion mode to "in row".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the current token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `tbody^l, `tfoot^l, `thead^l }
◎
An end tag whose tag name is one of: "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as the token, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
Clear the stack back to a table body context. (See below.)
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `tfoot^l, `thead^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot", "thead"
</dt>

	<dt>
終了tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, { `tbody^e, `thead^e, `tfoot^e } )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a tbody, thead, or tfoot element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~body文脈まで遡って~clearする$
◎
Clear the stack back to a table body context. (See below.)
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l, `td^l, `th^l, `tr^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td", "th", "tr"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~table内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in table" insertion mode.
</dd>
</dl>

<p class="algo-head">
上の手続きが
`~stackを~table~body文脈まで遡って~clearする@
所では、次を走らせ~MUST
⇒
~WHILE［
`現在の~node$は［
`tbody$e ／ `tfoot$e ／ `thead$e ／ `template$e ／ `html$e
］ 要素でない
］
⇒
`~open要素~stack$から~popする
◎
When the steps above require the UA to clear the stack back to a table body context, it means that the UA must, while the current node is not a tbody, tfoot, thead, template, or html element, pop elements from the stack of open elements.
</p>

<p class="note">注記：
この処理-後に`現在の~node$が `html$e 要素になるのは、`素片~事例$に限られる。
◎
The current node being an html element after this process is a fragment case.
</p>

					</section>
					<section id="parsing-main-intr">
<h5 title="The &quot;in row&quot; insertion mode">12.2.6.4.14. `~row内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~row内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in row" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
開始tag { `th^l, `td^l }
◎
A start tag whose tag name is one of: "th", "td"
</dt>
	<dd>
		<ol>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
Clear the stack back to a table row context. (See below.)
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token, then＼
</li>
			<li>
`挿入~mode$ ~SET `~cell内$md
◎
switch the insertion mode to "in cell".
</li>
			<li>
`~marker$を
`作動中の整形~要素~list$に付加する
◎
Insert a marker at the end of the list of active formatting elements.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `tr^l }
◎
An end tag whose tag name is "tr"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `tr^e )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a tr element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
Clear the stack back to a table row context. (See below.)
</li>
			<li>
~Assert：
`現在の~node$は `tr$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a tr element) from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
Switch the insertion mode to "in table body".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `tfoot^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "tfoot", "thead", "tr"
</dt>

	<dt>
終了tag { `table^l }
◎
An end tag whose tag name is "table"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, `tr^e )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a tr element in table scope, this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
Clear the stack back to a table row context. (See below.)
</li>
			<li>
~Assert：
`現在の~node$は `tr$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a tr element) from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
 Switch the insertion mode to "in table body".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `tbody^l, `tfoot^l, `thead^l }
◎
An end tag whose tag name is one of: "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>

<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as the token, this is a parse error; ignore the token.
</li>
			<li>
~IF［
`視野~内$に無い( `~table視野$, `tr^e )
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have a tr element in table scope, ignore the token.
◎
Otherwise:
</li>
			<li>
`~stackを~table~row文脈まで遡って~clearする$
◎
Clear the stack back to a table row context. (See below.)
</li>
			<li>
~Assert：
`現在の~node$は `tr$e 要素である
◎
↓</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node (which will be a tr element) from the stack of open elements.＼
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
Switch the insertion mode to "in table body".
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l, `td^l, `th^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html", "td", "th"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~table内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in table" insertion mode.
</dd>
</dl>

<p class="algo-head">
上の手続きが
`~stackを~table~row文脈まで遡って~clearする@
所では、次を走らせ~MUST
⇒
~WHILE［
`現在の~node$は［
`tr$e ／ `template$e ／ `html$e
］ 要素でない
］
⇒
`~open要素~stack$から~popする
◎
When the steps above require the UA to clear the stack back to a table row context, it means that the UA must, while the current node is not a tr, template, or html element, pop elements from the stack of open elements.
</p>

<p class="note">注記：
この処理-後に`現在の~node$が `html$e 要素になるのは、`素片~事例$に限られる。
◎
The current node being an html element after this process is a fragment case.
</p>

					</section>
					<section id="parsing-main-intd">
<h5 title="The &quot;in cell&quot; insertion mode">12.2.6.4.15. `~cell内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~cell内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in cell" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
終了tag { `td^l, `th^l }
◎
An end tag whose tag name is one of: "td", "th"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
◎
Otherwise:
</li>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
現tokenと~tag名が同じ`~HTML要素$
］ではない
］
⇒
`~perror$
◎
Now, if the current node is not an HTML element with the same tag name as the token, then this is a parse error.
</li>
			<li>
現tokenと~tag名が同じ`~HTML要素$が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements stack until an HTML element with the same tag name as the token has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
Switch the insertion mode to "in row".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `caption^l, `col^l, `colgroup^l, `tbody^l, `td^l, `tfoot^l, `th^l, `thead^l, `tr^l }
◎
A start tag whose tag name is one of: "caption", "col", "colgroup", "tbody", "td", "tfoot", "th", "thead", "tr"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, { `td^e, `th^e } )
（`素片~事例$）
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a td or th element in table scope, then this is a parse error; ignore the token. (fragment case)
</li>
			<li>
`~cellを閉じる$
◎
Otherwise, close the cell (see below) and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `body^l, `caption^l, `col^l, `colgroup^l, `html^l }
◎
An end tag whose tag name is one of: "body", "caption", "col", "colgroup", "html"
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
終了tag { `table^l, `tbody^l, `tfoot^l, `thead^l, `tr^l }
◎
An end tag whose tag name is one of: "table", "tbody", "tfoot", "thead", "tr"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］：
</p>

<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>

◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then this is a parse error; ignore the token.
</li>
			<li>
`~cellを閉じる$
◎
Otherwise, close the cell (see below) and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>
</dl>

<p class="algo-head">
上の手続きにて
`~cellを閉じる@
ときは、次を走らす：
◎
Where the steps above say to close the cell, they mean to run the following algorithm:
</p>

<ol>
			<li>
`暗黙の終了tagたちを生成する$()
◎
Generate implied end tags.
</li>
			<li>
~IF［
`現在の~node$は［
`td$e ／ `th$e
］要素でない
］
⇒
`~perror$
◎
If the current node is not now a td element or a th element, then this is a parse error.
</li>
			<li>
{ `td$e, `th$e }
いずれかの要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements stack until a td element or a th element has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
Switch the insertion mode to "in row".
</li>
</ol>

<p class="note">注記：
`~cellを閉じる$~algoが呼出されるときは，常に、
`視野~内$に在る( `~table視野$, `td$e ),
`視野~内$に在る( `~table視野$, `th$e )
］のうち，片方だけが満たされる。
◎
The stack of open elements cannot have both a td and a th element in table scope at the same time, nor can it have neither when the close the cell algorithm is invoked.
</p>

					</section>
					<section id="parsing-main-inselect">
<h5 title="The &quot;in select&quot; insertion mode">12.2.6.4.16. `~select内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~select内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in select" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the token's character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `option^l }
◎
A start tag whose tag name is "option"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は `option$e 要素である
］
⇒
`~open要素~stack$から~popその~node
◎
If the current node is an option element, pop that node from the stack of open elements.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `optgroup^l }
◎
A start tag whose tag name is "optgroup"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は `option$e 要素である
］
⇒
`~open要素~stack$から~popその~node
◎
If the current node is an option element, pop that node from the stack of open elements.
</li>
			<li>
~IF［
`現在の~node$は `optgroup$e 要素である
］
⇒
`~open要素~stack$から~popその~node
◎
If the current node is an optgroup element, pop that node from the stack of open elements.
</li>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `optgroup^l }
◎
An end tag whose tag name is "optgroup"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は `option$e 要素である
］~AND［
`~open要素~stack$内で
`現在の~node$の直前の~nodeは `optgroup$e 要素である
］
⇒
`~open要素~stack$から~popする
◎
First, if the current node is an option element, and the node immediately before it in the stack of open elements is an optgroup element, then pop the current node from the stack of open elements.
</li>
			<li>
~IF［
`現在の~node$は `optgroup$e 要素である
］
⇒
`~open要素~stack$から~popその~node
◎
If the current node is an optgroup element, then pop that node from the stack of open elements.＼
</li>
			<li>
~ELSE
⇒
`~perror$
— 現tokenは無視する
◎
Otherwise, this is a parse error; ignore the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `option^l }
◎
An end tag whose tag name is "option"
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は `option$e 要素である
］
⇒
`~open要素~stack$から~popする
◎
If the current node is an option element, then pop that node from the stack of open elements.＼
</li>
			<li>
~ELSE
⇒
`~perror$
— 現tokenは無視する
◎
Otherwise, this is a parse error; ignore the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `select^l }
◎
An end tag whose tag name is "select"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`視野~内$に無い( `~select視野$, `select^e )
（`素片~事例$）
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the stack of open elements does not have a select element in select scope, this is a parse error; ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `select^l }
◎
A start tag whose tag name is "select"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`視野~内$に無い( `~select視野$, `select^e )
（`素片~事例$）
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have a select element in select scope, ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
			<li>
<p>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</p>

<p class="note">注記：
これは単に、終了tagの様に扱われる。
◎
It just gets treated like an end tag.
</p>
			</li>
		</ol>
	</dd>

	<dt>
開始tag { `input^l, `keygen^l, `textarea^l }
◎
A start tag whose tag name is one of: "input", "keygen", "textarea"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`視野~内$に無い( `~select視野$, `select^e )
（`素片~事例$）
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have a select element in select scope, ignore the token. (fragment case)
◎
Otherwise:
</li>
			<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `script^l, `template^l }
◎
A start tag whose tag name is one of: "script", "template"
</dt>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
					<section id="parsing-main-inselectintable">
<h5 title="The &quot;in select in table&quot; insertion mode">12.2.6.4.17. `~table内~select内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~table内~select内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in select in table" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
開始tag { `caption^l, `table^l, `tbody^l, `tfoot^l, `thead^l, `tr^l, `td^l, `th^l }
◎
A start tag whose tag name is one of: "caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
終了tag { `caption^l, `table^l, `tbody^l, `tfoot^l, `thead^l, `tr^l, `td^l, `th^l }
◎
An end tag whose tag name is one of: "caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"
</dt>
	<dd>
		<ol>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
`視野~内$に無い( `~table視野$, 現tokenと~tag名が同じ`~HTML要素$ )
］
⇒
~RET — 現tokenは無視する
◎
If the stack of open elements does not have an element in table scope that is an HTML element with the same tag name as that of the token, then ignore the token.
◎
Otherwise:
</li>
			<li>
`select$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a select element has been popped from the stack.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~select内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in select" insertion mode.
</dd>
</dl>

					</section>
					<section id="parsing-main-intemplate">
<h5 title="The &quot;in template&quot; insertion mode">12.2.6.4.18. `~template内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~template内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in template" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token
◎
A character token
</dt>

	<dt>
~comment~token
◎
A comment token
</dt>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `base^l, `basefont^l, `bgsound^l, `link^l, `meta^l, `noframes^l, `script^l, `style^l, `template^l, `title^l }
◎
A start tag whose tag name is one of: "base", "basefont", "bgsound", "link", "meta", "noframes", "script", "style", "template", "title"
</dt>

	<dt>
終了tag { `template^l }
◎
An end tag whose tag name is "template"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
開始tag { `caption^l, `colgroup^l, `tbody^l, `tfoot^l, `thead^l }
◎
A start tag whose tag name is one of: "caption", "colgroup", "tbody", "tfoot", "thead"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~table内$mdを~pushする
◎
Push "in table" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~table内$md
◎
Switch the insertion mode to "in table", and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `col^l }
◎
A start tag whose tag name is "col"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~column-group内$mdを~pushする
◎
Push "in column group" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~column-group内$md
◎
Switch the insertion mode to "in column group", and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `tr^l }
◎
A start tag whose tag name is "tr"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に `~table~body内$mdを~pushする
◎
Push "in table body" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~table~body内$md
◎
Switch the insertion mode to "in table body", and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `td^l, `th^l }
◎
A start tag whose tag name is one of: "td", "th"
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~row内$mdを~pushする
◎
Push "in row" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~row内$md
◎
Switch the insertion mode to "in row", and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
その他の開始tag
◎
Any other start tag
</dt>
	<dd>
		<ol>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`~template挿入~mode~stack$に`~body内$mdを~pushする
◎
Push "in body" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
			<li>
`挿入~mode$ ~SET `~body内$md
◎
Switch the insertion mode to "in body", and＼
</li>
			<li>
現tokenを再処理する
◎
reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
その他の終了tag
◎
Any other end tag
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`~open要素~stack$内には `template$e 要素はない
（`素片~事例$）
］：
</p>

<ol ><li>`構文解析を停止する$
</li><li>~RET
</li></ol>
◎
If there is no template element on the stack of open elements, then stop parsing. (fragment case)
</li>
			<li>
`~perror$
◎
Otherwise, this is a parse error.
</li>
			<li>
`template$e 要素が`出るまで~open要素~stackから~popする$
◎
Pop elements from the stack of open elements until a template element has been popped from the stack.
</li>
			<li>
`作動中の整形~要素~listを最後の~markerまで~clearする$
◎
Clear the list of active formatting elements up to the last marker.
</li>
			<li>
`~template挿入~mode~stack$から~popする
◎
Pop the current template insertion mode off the stack of template insertion modes.
</li>
			<li>
`挿入~modeを適切に再設定する$
◎
Reset the insertion mode appropriately.
</li>
			<li>
現tokenを再処理する
◎
Reprocess the token.
</li>
		</ol>
	</dd>
</dl>

					</section>
					<section id="parsing-main-afterbody">
<h5 title="The &quot;after body&quot; insertion mode">12.2.6.4.19. `~bodyの後^md</h5>

<p>
［
`挿入~mode$ ~EQ `~bodyの後$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "after body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `~open要素~stack$の先頭の要素（ `html$e 要素）内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the first element in the stack of open elements (the html element).
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
終了tag { `html^l }
◎
An end tag whose tag name is "html"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
%構文解析器 は `~HTML素片~用$である
（`素片~事例$）
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the parser was originally created as part of the HTML fragment parsing algorithm, this is a parse error; ignore the token. (fragment case)
</li>
			<li>
~ELSE
⇒
`挿入~mode$ ~SET `~bodyの後の後$md
◎
Otherwise, switch the insertion mode to "after after body".
</li>
		</ol>
	</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>`~perror$
</li><li>`挿入~mode$ ~SET `~body内$md
</li><li>現tokenを再処理する
</li></ol>
◎
Parse error. Switch the insertion mode to "in body" and reprocess the token.
</dd>
</dl>

					</section>
					<section id="parsing-main-inframeset">
<h5 title="The &quot;in frameset&quot; insertion mode">12.2.6.4.20. `~frameset内^md</h5>

<p>
［
`挿入~mode$ ~EQ `~frameset内$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "in frameset" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
開始tag { `frameset^l }
◎
A start tag whose tag name is "frameset"
</dt>
	<dd>
<ol><li>`要素を挿入する$( 現token )
</li></ol>
◎
Insert an HTML element for the token.
</dd>

	<dt>
終了tag { `frameset^l }
◎
An end tag whose tag name is "frameset"
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は根 `html$e 要素である
（`素片~事例$）
］：
</p>
<ol ><li>`~perror$
</li><li>~RET — 現tokenは無視する
</li></ol>
◎
If the current node is the root html element, then this is a parse error; ignore the token. (fragment case)
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise, pop the current node from the stack of open elements.
</li>
			<li>
~IF［
%構文解析器 は `~HTML素片~用$でない（`素片~事例$でない）
］~AND［
`現在の~node$は `frameset$e 要素でない
］
⇒
`挿入~mode$ ~SET `~framesetの後$md
◎
If the parser was not originally created as part of the HTML fragment parsing algorithm (fragment case), and the current node is no longer a frameset element, then switch the insertion mode to "after frameset".
</li>
		</ol>
	</dd>

	<dt>
開始tag { `frame^l }
◎
A start tag whose tag name is "frame"
</dt>
	<dd>
		<ol>
			<li>
`要素を挿入する$( 現token )
◎
Insert an HTML element for the token.＼
</li>
			<li>
`~open要素~stack$から~popする
◎
Immediately pop the current node off the stack of open elements.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~ON
］
⇒
`自己閉じ~flagを承認する$( 現token )
◎
Acknowledge the token's self-closing flag, if it is set.
</li>
		</ol>
	</dd>

	<dt>
開始tag { `noframes^l }
◎
A start tag whose tag name is "noframes"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
		<ol>
			<li>
<p>
~IF［
`現在の~node$は根 `html$e 要素でない
］
⇒
`~perror$
◎
If the current node is not the root html element, then this is a parse error.
</p>

<p class="note">注記：
`素片~事例$においては、`現在の~node$は，常に根 `html$e 要素になる
◎
The current node can only be the root html element in the fragment case.
</p>
			</li>
			<li>
`構文解析を停止する$
◎
Stop parsing.
</li>
		</ol>
	</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
					<section id="parsing-main-afterframeset">
<h5 title="The &quot;after frameset&quot; insertion mode">12.2.6.4.21. `~framesetの後^md</h5>

<p>
［
`挿入~mode$ ~EQ `~framesetの後$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "after frameset" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the character.
</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
終了tag { `html^l }
◎
An end tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`挿入~mode$ ~SET `~framesetの後の後$md
</li></ol>
◎
Switch the insertion mode to "after after frameset".
</dd>

	<dt>
開始tag { `noframes^l }
◎
A start tag whose tag name is "noframes"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
					<section id="the-after-after-body-insertion-mode">
<h5 title="The &quot;after after body&quot; insertion mode">12.2.6.4.22. `~bodyの後の後^md</h5>

<p>
［
`挿入~mode$ ~EQ `~bodyの後の後$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "after after body" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol ><li>`~perror$
</li><li>`挿入~mode$ ~SET `~body内$md
</li><li>現tokenを再処理する
</li></ol>
◎
Parse error. Switch the insertion mode to "in body" and reprocess the token.
</dd>
</dl>

					</section>
					<section id="the-after-after-frameset-insertion-mode">
<h5 title="The &quot;after after frameset&quot; insertion mode">12.2.6.4.23. `~framesetの後の後^md</h5>

<p>
［
`挿入~mode$ ~EQ `~framesetの後の後$md
］の下では、現tokenを以下に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for the "after after frameset" insertion mode, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token, `文書$内の末尾 )
</li></ol>
◎
Insert a comment as the last child of the Document object.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>

	<dt>
開始tag { `html^l }
◎
A start tag whose tag name is "html"
</dt>
	<dd>
<ol><li>`~body内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in body" insertion mode.
</dd>

	<dt>
~eof~token
◎
An end-of-file token
</dt>
	<dd>
<ol><li>`構文解析を停止する$
</li></ol>
◎
Stop parsing.
</dd>

	<dt>
開始tag { `noframes^l }
◎
A start tag whose tag name is "noframes"
</dt>
	<dd>
<ol><li>`~head内$md`用の規則を用いて$現tokenを処理する
</li></ol>
◎
Process the token using the rules for the "in head" insertion mode.
</dd>

	<dt>~AnyElse</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>
</dl>

					</section>
				</section>
				<section id="parsing-main-inforeign">
<h4 title="The rules for parsing tokens in foreign content">12.2.6.5. 外来~内容~内~token用の構文解析~規則</h4>

<p>
~UAは、外来~内容~内の~tokenを構文解析するための規則を適用するときは，現tokenを次に従って取扱わ~MUST：
◎
When the user agent is to apply the rules for parsing tokens in foreign content, the user agent must handle the token as follows:
</p>

<dl class="switch">
	<dt>
文字~token { `0000^U }
◎
A character token that is U+0000 NULL
</dt>
	<dd>
<ol><li>`~perror$
</li><li>`文字を挿入する$( `FFFD^U )
</li></ol>
◎
Parse error. Insert a U+FFFD REPLACEMENT CHARACTER character.
</dd>

	<dt>
文字~token { `~ASCII空白$ }
◎
A character token that is one of U+0009 CHARACTER TABULATION, U+000A LINE FEED (LF), U+000C FORM FEED (FF), U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
</dt>
	<dd>
<ol><li>`文字を挿入する$( 現tokenの文字 )
</li></ol>
◎
Insert the token's character.
</dd>

	<dt>
その他の文字~token
◎
Any other character token
</dt>
	<dd>
		<ol>
			<li>
`文字を挿入する$( 現tokenの文字 )
◎
Insert the token's character.
</li>
			<li>
`~frameset-ok~flag$ ~SET `not-ok^i
◎
Set the frameset-ok flag to "not ok".
</li>
		</ol>
	</dd>

	<dt>
~comment~token
◎
A comment token
</dt>
	<dd>
<ol><li>`~commentを挿入する$( 現token )
</li></ol>
◎
Insert a comment.
</dd>

	<dt>
~DOCTYPE~token
◎
A DOCTYPE token
</dt>
	<dd>
<ol><li>`~perror$ — 現tokenは無視する
</li></ol>
◎
Parse error. Ignore the token.
</dd>

	<dt>
開始tag { `b^l, `big^l, `blockquote^l, `body^l, `br^l, `center^l, `code^l, `dd^l, `div^l, `dl^l, `dt^l, `em^l, `embed^l, `h1^l, `h2^l, `h3^l, `h4^l, `h5^l, `h6^l, `head^l, `hr^l, `i^l, `img^l, `li^l, `listing^l, `menu^l, `meta^l, `nobr^l, `ol^l, `p^l, `pre^l, `ruby^l, `s^l,  `small^l, `span^l, `strong^l, `strike^l,  `sub^l, `sup^l, `table^l, `tt^l, `u^l, `ul^l, `var^l, `font^l }
◎
A start tag whose tag name is one of: "b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "menu", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"
</dt>
	<dd>
		<ol>
			<li>
~IF［
現tokenの~tag名 ~EQ `font^l
］~AND［
現tokenは名前 ［
`color^l ／ `face^l ／ `size^l
］の属性をいずれも有さない
］
⇒
~GOTO その他の開始tag
◎
A start tag whose tag name is "font", if the token has any attributes named "color", "face", or "size"
</li>
			<li>
`~perror$
◎
Parse error.
</li>
			<li>
~IF［
%構文解析器 は `~HTML素片~用$である
（`素片~事例$）
］
⇒
~GOTO 下に述べる “その他の開始tag” ~entry
◎
If the parser was originally created for the HTML fragment parsing algorithm, then act as described in the "any other start tag" entry below. (fragment case)
◎
Otherwise:
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop an element from the stack of open elements, and then＼
</li>
			<li>
<p>
~WHILE 無条件：
</p>

<ol><li>`~open要素~stack$から~popする
</li><li>~IF［
`現在の~node$は［
`~MathML~text統合~地点$ ／ `~HTML統合~地点$ ／ `~HTML名前空間$に属する要素
］である
⇒
~BREAK
</li></ol>

◎
keep popping more elements from the stack of open elements until the current node is a MathML text integration point, an HTML integration point, or an element in the HTML namespace.
</li>
			<li>
現tokenを再処理する
◎
Then, reprocess the token.
</li>
		</ol>
	</dd>

	<dt>
その他の開始tag
◎
Any other start tag
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の調整-済み~node$は`~MathML名前空間$に属する要素である
］
⇒
`~MathML属性たちを調整する$( 現token )
（これは、~MathML属性に非~小文字が含まれている事例を修正する。）
◎
If the adjusted current node is an element in the MathML namespace, adjust MathML attributes for the token. (This fixes the case of MathML attributes that are not all lowercase.)
</li>
			<li>
<p>
~IF［
`現在の調整-済み~node$は`~SVG名前空間$に属する要素である
］~AND［
現tokenの~tag名 ~IN { 次の~tableの 1 列目に挙げる名前 }
］
⇒
現tokenの~tag名 ~SET 名前が見出された行の 2 列目に与える名前
（これは、~SVG要素に非~小文字が含まれている事例を修正する。）
◎
If the adjusted current node is an element in the SVG namespace, and the token's tag name is one of the ones in the first column of the following table, change the tag name to the name given in the corresponding cell in the second column. (This fixes the case of SVG elements that are not all lowercase.)
</p>

<table><thead><tr><th>~tag名◎Tag name
</th><th>要素~名◎Element name

</th></thead>

<tbody><tr><td>`altglyph^c
<td>`altGlyph^e

<tr><td>`altglyphdef^c
<td>`altGlyphDef^e

<tr><td>`altglyphitem^c
<td>`altGlyphItem^e

<tr><td>`animatecolor^c
<td>`animateColor^e

<tr><td>`animatemotion^c
<td>`animateMotion^e

<tr><td>`animatetransform^c
<td>`animateTransform^e

<tr><td>`clippath^c
<td>`clipPath^e

<tr><td>`feblend^c
<td>`feBlend^e

<tr><td>`fecolormatrix^c
<td>`feColorMatrix^e

<tr><td>`fecomponenttransfer^c
<td>`feComponentTransfer^e

<tr><td>`fecomposite^c
<td>`feComposite^e

<tr><td>`feconvolvematrix^c
<td>`feConvolveMatrix^e

<tr><td>`fediffuselighting^c
<td>`feDiffuseLighting^e

<tr><td>`fedisplacementmap^c
<td>`feDisplacementMap^e

<tr><td>`fedistantlight^c
<td>`feDistantLight^e

<tr><td>`fedropshadow^c
<td>`feDropShadow^e

<tr><td>`feflood^c
<td>`feFlood^e

<tr><td>`fefunca^c
<td>`feFuncA^e

<tr><td>`fefuncb^c
<td>`feFuncB^e

<tr><td>`fefuncg^c
<td>`feFuncG^e

<tr><td>`fefuncr^c
<td>`feFuncR^e

<tr><td>`fegaussianblur^c
<td>`feGaussianBlur^e

<tr><td>`feimage^c
<td>`feImage^e

<tr><td>`femerge^c
<td>`feMerge^e

<tr><td>`femergenode^c
<td>`feMergeNode^e

<tr><td>`femorphology^c
<td>`feMorphology^e

<tr><td>`feoffset^c
<td>`feOffset^e

<tr><td>`fepointlight^c
<td>`fePointLight^e

<tr><td>`fespecularlighting^c
<td>`feSpecularLighting^e

<tr><td>`fespotlight^c
<td>`feSpotLight^e

<tr><td>`fetile^c
<td>`feTile^e

<tr><td>`feturbulence^c
<td>`feTurbulence^e

<tr><td>`foreignobject^c
<td>`foreignObject^e

<tr><td>`glyphref^c
<td>`glyphRef^e

<tr><td>`lineargradient^c
<td>`linearGradient^e

<tr><td>`radialgradient^c
<td>`radialGradient^e

<tr><td>`textpath^c
<td>`textPath^e

</tbody></table>

			</li>
			<li>
~IF［
`現在の調整-済み~node$は`~SVG名前空間$に属する要素である
］
⇒
`~SVG属性たちを調整する$( 現token )
（これは、~SVG属性に非~小文字が含まれている事例を修正する。）
◎
If the adjusted current node is an element in the SVG namespace, adjust SVG attributes for the token. (This fixes the case of SVG attributes that are not all lowercase.)
</li>
			<li>
`外来の属性たちを調整する$( 現token )
（これは、名前空間~付きの属性の利用
— 特に~SVGにおける~XLink —
を修正する。）
◎
Adjust foreign attributes for the token. (This fixes the use of namespaced attributes, in particular XLink in SVG.)
</li>
			<li>
`要素を挿入する$( 現token, `現在の調整-済み~node$が属する名前空間 )
◎
Insert a foreign element for the token, in the same namespace as the adjusted current node.
</li>
			<li>
~IF［
現tokenの`自己閉じ~flag$ ~EQ ~OFF
］
⇒
~RET
◎
If the token has its self-closing flag set, then run the appropriate steps from the following list:
</li>
			<li>
`自己閉じ~flagを承認する$( 現token )
◎
↓</li>
			<li>
~IF［
現tokenの~tag名 ~EQ `script^l
］~AND［
`現在の~node$は`~SVG名前空間$に属する
］
⇒
~GOTO 終了tag { `script^l }
◎
If the token's tag name is "script", and the new current node is in the SVG namespace
• Acknowledge the token's self-closing flag, and then act as described in the steps for a "script" end tag below.
</li>
			<li>
`~open要素~stack$から~popする
◎
Otherwise
• Pop the current node off the stack of open elements and acknowledge the token's self-closing flag.
</li>
		</ol>
	</dd>

	<dt id="scriptForeignEndTag">
終了tag { `script^l }
◎
An end tag whose tag name is "script",＼
</dt>
	<dd>
		<ol>
			<li>
~IF［
`現在の~node$は ~SVG `~SVGscript$e 要素でない
］
⇒
~GOTO その他の終了tag
◎
if the current node is an SVG script element
</li>
			<li>
`~open要素~stack$から~popする
◎
Pop the current node off the stack of open elements.
</li>
			<li>
%旧~挿入~地点 ~LET現在の`挿入~地点$
◎
Let the old insertion point have the same value as the current insertion point.＼
</li>
			<li>
`挿入~地点$ ~LET `次n入力~文字$の直前
◎
Let the insertion point be just before the next input character.
</li>
			<li>
%構文解析器 の`~script入子~level$ ~INCBY 1
◎
Increment the parser's script nesting level by one.＼
</li>
			<li>
%構文解析器 の`一時停止~flag$ ~SET ~T
◎
Set the parser pause flag to true.
</li>
			<li>
<p>
~IF［
~UAは~SVGを~supportする
］
⇒
~SVG規則に則って，`~SVG~script要素を処理する$
`SVG$r
◎
Process the SVG script element according to the SVG rules, if the user agent supports SVG. [SVG]
</p>

<p class="note">注記：
これにより
<a href="~HTML5/dynamic-markup-insertion.html#dom-document-write">~tokenizerの中に新たな文字たちが挿入される</a>
ことになる場合でも、
%構文解析器 の`一時停止~flag$ ~EQ ~T なので，
%構文解析器 は再入的に実行されない。
◎
Even if this causes new characters to be inserted into the tokenizer, the parser will not be executed reentrantly, since the parser pause flag is true.
</p>
			</li>
			<li>
%構文解析器 の`~script入子~level$ ~DECBY 1
◎
Decrement the parser's script nesting level by one.＼
</li>
			<li>
~IF［
%構文解析器 の`~script入子~level$ ~EQ 0
］
⇒
%構文解析器 の`一時停止~flag$ ~SET ~F
◎
If the parser's script nesting level is zero, then set the parser pause flag to false.
</li>
			<li>
`挿入~地点$ ~SET %旧~挿入~地点
◎
Let the insertion point have the value of the old insertion point. (In other words, restore the insertion point to its previous value. This value might be the "undefined" value.)
</li>
		</ol>
	</dd>

	<dt>
その他の終了tag
◎
Any other end tag
◎
Run these steps:
</dt>
	<dd>
		<ol>
			<li>
%~node ~LET `現在の~node$
◎
Initialize node to be the current node (the bottommost node of the stack).
</li>
			<li>
~IF［
%~node の~tag名を`~ASCII小文字~化$した結果 ~NEQ 現tokenの~tag名
］
⇒
`~perror$
◎
If node's tag name, converted to ASCII lowercase, is not the same as the tag name of the token, then this is a parse error.
</li>
			<li>
<p>
~WHILE 無条件：
◎
↓</p>
				<ol>
					<li>
~IF［
%~node ~EQ `~open要素~stack$の先頭の要素
（`素片~事例$）
］
⇒
~RET
◎
Loop: If node is the topmost element in the stack of open elements, abort these steps. (fragment case)
</li>
					<li>
<p>
~IF［
%~node の~tag名を`~ASCII小文字~化$した結果 ~EQ 現tokenの~tag名
］：
</p>
<ol ><li>%~node が`出るまで~open要素~stackから~popする$
</li><li>~RET
</li></ol>
◎
If node's tag name, converted to ASCII lowercase, is the same as the tag name of the token, pop elements from the stack of open elements until node has been popped from the stack, and then abort these steps.
</li>
					<li>
%~node ~SET `~open要素~stack$内で %~node の直前の~entry
◎
Set node to the previous entry in the stack of open elements.
</li>
					<li>
~IF［
%~node は`~HTML名前空間$に属する要素である
］
⇒
~BREAK
◎
If node is not an element in the HTML namespace, return to the step labeled loop.
</li>
				</ol>
			</li>
			<li>
［
<a href="#parsing-main-inhtml">~HTML内容~内の~token</a>
用の，現在の`挿入~mode$に対応する節
］に与える規則に則って、現tokenを処理する
◎
Otherwise, process the token according to the rules given in the section corresponding to the current insertion mode in HTML content.
</li>
		</ol>
	</dd>
</dl>

				</section>
			</section>
			<section id="the-end">
<h3 title="The end">12.2.7. 終端</h3>

<p class="algo-head">
`文書$ %文書 の
`構文解析を停止する@
ときは、次の手続きを走らせ~MUST：
◎
Once the user agent stops parsing the document, the user agent must run the following steps:
</p>

<ol>
	<li>
%文書 の`現在の準備度$doc ~SET  `interactive^l
◎
Set the current document readiness to "interactive" and＼
</li>
	<li>
`挿入~地点$ ~SET ε
◎
the insertion point to undefined.
</li>
	<li>
`~open要素~stack$を空にする
◎
Pop all the nodes off the stack of open elements.
</li>
	<li>
%~script~list ~LET
%構文解析器 の`文書を構文解析し終えたときに実行されることになる~scriptの~list$を指す参照
◎
↓</li>
	<li>
<p>
~WHILE［
%~script~list は空でない
］：
◎
If the list of scripts that will execute when the document has finished parsing is not empty, run these substeps:
</p>
		<ol>
			<li>
<p>
次の<em>いずれも</em>満たされるまで`~event~loopを回す$：
</p>

<ul><li>%~script~list 内の 最初の `script$e の`解析器実行準備済み~flag$ ~EQ ~ON
</li><li>%文書 内には`~scriptを阻んでいる~stylesheetは無い$
</li></ul>
◎
Spin the event loop until the first script in the list of scripts that will execute when the document has finished parsing has its "ready to be parser-executed" flag set and the parser's Document has no style sheet that is blocking scripts.
</li>
			<li>
%~script ~LET %~script~list 内の 最初の `script$e
◎
↓</li>
			<li>
%~script の`~script~blockを実行する$
◎
Execute the first script in the list of scripts that will execute when the document has finished parsing.
</li>
			<li>
%~script~list から %~script を除去する
◎
Remove the first script element from the list of scripts that will execute when the document has finished parsing (i.e. shift out the first entry in the list).
◎
If the list of scripts that will execute when the document has finished parsing is still not empty, repeat these substeps again from substep 1.
</li>
		</ol>
	</li>
	<li>
<p>
次を走らす`~taskを待入する$：
◎
Queue a task to run the following substeps:
</p>

		<ol>
			<li>
<p>
%文書 に向けて，名前 `DOMContentLoaded$et の`~eventを発火-$する
— `bubbles$m 属性 ~SET ~T に初期化した上で
◎
Fire an event named DOMContentLoaded at the Document object, with its bubbles attribute initialized to true.
</p></li>
	<li>
次を満たす `ServiceWorkerContainer$I ~obj %C の`~client~message待行列$を可能化する
⇒
%C に結付けられている`~sw~client$ ~EQ %文書 に`関連する設定群~obj$
◎
Enable the client message queue of the ServiceWorkerContainer object whose associated service worker client is the Document object's relevant settings object.
</li>
		</ol>
	</li>
	<li>
<p>
次がいずれも満たされるまで`~event~loopを回す$：
</p>

<ul><li>`可能な限りすぐに実行される~scriptの集合$は空である
</li><li>`可能な限りすぐに順に実行される~scriptの~list$は空である
</li></ul>

◎
Spin the event loop until the set of scripts that will execute as soon as possible and the list of scripts that will execute in order as soon as possible are empty.
</li>
	<li>
次が満たされるまで`~event~loopを回す$
⇒
%文書 内に
`~load~eventを遅延する@
ものはない
◎
Spin the event loop until there is nothing that delays the load event in the Document.
</li>
	<li>
<p>
次を走らす`~taskを待入する$：
◎
Queue a task to run the following substeps:
</p>

		<ol>
			<li>
%文書 の`現在の準備度$doc ~SET  `complete^l
◎
Set the current document readiness to "complete".
</li>
			<li>
~IF［
%文書 が`属する閲覧文脈$ ~NEQ ε
］
⇒
［
%旧来の~target上書き~flag ~SET ~ON
］の下で、
%文書 を`結付けている~window$に向けて，名前 `load$et の`~eventを発火-$する
◎
Load event: If the Document has a browsing context, then fire an event named load at the Document object's Window object, with legacy target override flag set.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%文書 が`属する閲覧文脈$ ~NEQ ε
］
⇒
次を走らす`~taskを待入する$：
◎
If the Document has a browsing context, then queue a task to run the following substeps:
</p>

<ol>
	<li>
<p>
~IF［
%文書 の`頁~表示中$ ~flag ~EQ ~T
］
⇒
~RET
◎
If the Document's page showing flag is true, then abort this task (i.e. don't fire the event below).
</p></li>
	<li>
%文書 の`頁~表示中$ ~flag ~SET ~T
◎
Set the Document's page showing flag to true.
</li>
	<li>
<p>
［
%旧来の~target上書き~flag ~SET ~ON
］の下で、
%文書 を`結付けている~window$に向けて，次のように初期化された`~eventを発火-$する
</p>

<ul><li>名前 `pageshow$et
</li><li>`PageTransitionEvent$I を利用する
</li><li>`persisted$m 属性 ~SET ~F
</li></ul>

◎
Fire an event named pageshow at the Document object's Window object, using PageTransitionEvent, with the persisted attribute initialized to false, and legacy target override flag set.
</li>
		</ol>
	</li>
	<li>
【<a href="~NAVI#_for-app-cache">~app~cache関連の処理</a>】
◎
If the Document has any pending application cache download process tasks, then queue each such task in the order they were added to the list of pending application cache download process tasks, and then empty the list of pending application cache download process tasks. The task source for these tasks is the networking task source.
</li>
	<li>
~IF［
%文書 が`読込まれたとき印刷する~flag$ ~EQ ~ON
］
⇒
`印刷-時の手続き$を走らす
◎
If the Document's print when loaded flag is set, then run the printing steps.
</li>
	<li>
この時点で、 %文書 は
`~load後~task準備済み@
とされる
◎
The Document is now ready for post-load tasks.
</li>
	<li>
次を走らす`~taskを待入する$
⇒
この時点で、 %文書 は
`完全に読込まれ@
たものとされる
◎
Queue a task to mark the Document as completely loaded.
</li>
</ol>

<p class="algo-head">
~UAは，
`構文解析器を中止-@
するときは、次の手続きを走らせ~MUST：
◎
When the user agent is to abort a parser, it must run the following steps:
</p>

<ol>
	<li>
`入力~stream$内の処理待ち内容は、未来に追加されることになるものも含め，破棄する
◎
Throw away any pending content in the input stream, and discard any future content that would have been added to it.
</li>
	<li>
%文書 の`現在の準備度$doc ~SET  `interactive^l
◎
Set the current document readiness to "interactive".
</li>
	<li>
`~open要素~stack$を空にする
◎
Pop all the nodes off the stack of open elements.
</li>
	<li>
%文書 の`現在の準備度$doc ~SET  `complete^l
◎
Set the current document readiness to "complete".
</li>
</ol>

<p>
他が指定されない限り，この節に言及した`~task$用の`~task源$は、
`~DOM操作~task源$とする。
◎
Except where otherwise specified, the task source for the tasks mentioned in this section is the DOM manipulation task source.
</p>

			</section>
			<section id="coercing-an-html-dom-into-an-infoset">
<h3 title="Coercing an HTML DOM into an infoset">12.2.8. ~HTML~DOMから~XML~infosetへの落とし込み</h3>

<p>
~appが`~HTML構文解析器$を~XML~pipelineと併用するときに構築される~DOMは、ある種の微妙な仕方で~XML~toolchainと互換でない可能性もある。
例えば，~XML~toolchainは、名前 `xmlns^c の属性を表現できないかもしれない
— それは `XMLNS$r の構文と競合するので。
`~HTML構文解析器$が生成する~dataには、~DOM自身には含まれないものもある。
この節は、これらの課題を取扱うための規則をいくつか指定する。
◎
When an application uses an HTML parser in conjunction with an XML pipeline, it is possible that the constructed DOM is not compatible with the XML tool chain in certain subtle ways. For example, an XML toolchain might not be able to represent attributes with the name xmlns, since they conflict with the Namespaces in XML syntax. There is also some data that the HTML parser generates that isn't included in the DOM itself. This section specifies some rules for handling these issues.
</p>

<p>
利用-中の~XML~API
— 以下，単に “~XML~API” —
が~DOCTYPEを~supportしない場合、~toolは，~DOCTYPEをまるごと落として~MAY。
◎
If the XML API being used doesn't support DOCTYPEs, the tool may drop DOCTYPEs altogether.
</p>

<p>
~XML~APIが［
名前空間に属さない名前 `xmlns^l の属性 ／
`xmlns:^l で開始する名前の属性 ／
`~XMLNS名前空間$に属する属性 
］を~supportしない場合、~toolは，そのような属性を落として~MAY。
◎
If the XML API doesn't support attributes in no namespace that are named "xmlns", attributes whose names start with "xmlns:", or attributes in the XMLNS namespace, then the tool may drop such attributes.
</p>

<p>
~toolは、適正に演算するために要求される名前空間~宣言があれば，出力を それで注釈して~MAY。
◎
The tool may annotate the output with any namespace declarations required for proper operation.
</p>

<div class="p">
<p>
~XML~APIが［
要素／属性
］の局所~名に許容できる文字を制約する場合、~toolは，［［
要素／属性
］の局所~名の中の文字のうち，当の~APIが~supportしないもの
］を，次の形による文字~並びに置換することにより、許容される名前の集合に対応付けて~MAY：
</p>

<ol><li>`0055^U
</li><li>文字の~cpを~hexadecimalで表すような 6 個の`~ASCII~hex数字（大文字）$
</li></ol>

<!-- ＊？in increasing numeric order -->

◎
If the XML API being used restricts the allowable characters in the local names of elements and attributes, then the tool may map all element and attribute local names that the API wouldn't support to a set of names that are allowed, by replacing any character that isn't supported with the uppercase letter U and the six digits of the character's code point when expressed in hexadecimal, using digits 0-9 and capital letters A-F as the symbols, in increasing numeric order.
</div>

<p class="example">
例えば`~HTML構文解析器$は，合法な~HTML要素~名でも整形式の~XML要素~名でもない
要素~名 `foo&lt;bar^c を出力し得るが、それは `fooU00003Cbar^c に変換され，<em>整形式の</em> ~XML要素~名になる（それでも、~HTMLにおいて合法になることはない）。
◎
For example, the element name foo&lt;bar, which can be output by the HTML parser, though it is neither a legal HTML element name nor a well-formed XML element name, would be converted into fooU00003Cbar, which is a well-formed XML element name (though it's still not legal in HTML by any means).
</p>

<p class="example">
別の例として、属性 `xlink:href^c を考える。
~MathML要素~上で利用された場合、それは
<a href="#adjust-foreign-attributes">調整-後</a>には
( 接頭辞 `xlink^l, 局所~名 `href^l )
を伴う属性になる。
しかしながら，~HTML要素~上で利用された場合、
( 接頭辞なし, 局所~名 `xlink:href^l )
を伴う属性になり，妥当な `NCName^P でないため、~XML~APIには受容されないかもしれない。
したがって `xlinkU00003Ahref^l になるよう変換することもできる。
◎
As another example, consider the attribute xlink:href. Used on a MathML element, it becomes, after being adjusted, an attribute with a prefix "xlink" and a local name "href". However, used on an HTML element, it becomes an attribute with no prefix and the local name "xlink:href", which is not a valid NCName, and thus might not be accepted by an XML API. It could thus get converted, becoming "xlinkU00003Ahref".
</p>

<p class="note">注記：
この変換による結果の名前は、都合よく，`~HTML構文解析器$が生成するどの属性とも衝突し得ない
— それらはどれも、小文字のみからなるか［
`外来の属性たちを調整する$~algoの表に挙げたもの
］に限られるので。
◎
The resulting names from this conversion conveniently can't clash with any attribute generated by the HTML parser, since those are all either lowercase or those listed in the adjust foreign attributes algorithm's table.
</p>

<p>
~XML~APIが［
~comment内の連続する 2 個の `002D^U
］を制約する場合、~toolは，そのような~~問題になる文字~並びの合間に 1 個の `0020^U を挿入して~MAY。
◎
If the XML API restricts comments from having two consecutive U+002D HYPHEN-MINUS characters (--), the tool may insert a single U+0020 SPACE character between any such offending characters.
</p>

<p>
~XML~APIが［
~comment内を `002D^U で終端する
］のを制約する場合、~toolは，そのような~commentの終端に 1 個の `0020^U を挿入して~MAY。
◎
If the XML API restricts comments from ending in a U+002D HYPHEN-MINUS character (-), the tool may insert a single U+0020 SPACE character at the end of such comments.
</p>

<p>
~XML~APIが［
文字~data／ 属性~値 ／~comment
］内に許容される文字を制約する場合、~toolは，
`000C^U は `0020^U に,
その他の~literal 非~XML文字は `FFFD^U に置換して~MAY。
◎
If the XML API restricts allowed characters in character data, attribute values, or comments, the tool may replace any U+000C FORM FEED (FF) character with a U+0020 SPACE character, and any other literal non-XML character with a U+FFFD REPLACEMENT CHARACTER.
</p>

<p>
帯域外の情報を伝達する仕方がない~toolは、次の情報を落として~MAY：
◎
If the tool has no way to convey out-of-band information, then the tool may drop the following information:
</p>

<ul>
<li>
文書の`~mode$docは［
`no-quirks^l, `limited-quirks^l, `quirks^l
］のどれに設定されているか
◎
Whether the document is set to no-quirks mode, limited-quirks mode, or quirks mode
</li>
	<li>
~form-controlと，［
それに最も近い先祖 `form$e 要素ではない `form$e 要素
］との結付け（構文解析器における`~form要素~pointer$の利用）
◎
The association between form controls and forms that aren't their nearest form element ancestor (use of the form element pointer in the parser)
</li>
	<li>
`template$e 要素の`~template内容$
◎
The template contents of any template elements.
</li>
</ul>

<p class="note">注記：
この節により許容される変異が適用されるのは、`~HTML構文解析器$の規則が適用された<em>後</em>になる。
例えば、開始tag
`&lt;a::&gt;^l
は，終了tag
`&lt;/a::&gt;^l
で閉じられることになり、終了tag
`&lt;/aU00003AU00003A&gt;^l
で閉じられることは，決してない
— ~UAが，上を規則を利用していて，開始tagに対する名前 `aU00003AU00003A^l の要素を実際に~DOM内に生成する場合でも。
◎
The mutations allowed by this section apply after the HTML parser's rules have been applied. For example, a &lt;a::&gt; start tag will be closed by a &lt;/a::&gt; end tag, and never by a &lt;/aU00003AU00003A&gt; end tag, even if the user agent is using the rules above to then generate an actual element in the DOM with the name aU00003AU00003A for that start tag.
</p>

			</section>
			<section id="an-introduction-to-error-handling-and-strange-cases-in-the-parser">
<h3 title="An introduction to error handling and strange cases in the parser">12.2.9. 構文解析器における~errorの取扱いと変則的な事例の序論</h3>

~INFORMATIVE

<p>
この節では、~error含みの~markupをいくつか検分し，`~HTML構文解析器$がこれらの事例をどう取扱うかを論じる。
◎
This section examines some erroneous markup and discusses how the HTML parser handles these cases.
</p>

				<section id="misnested-tags:-b-i-/b-/i">
<h4 title="Misnested tags: &lt;b&gt;&lt;i&gt;&lt;/b&gt;&lt;/i&gt;">12.2.9.1. 誤入子な~tag：`&lt;b&gt;&lt;i&gt;&lt;/b&gt;&lt;/i&gt;^c</h4>

~INFORMATIVE

<p>
次のような~markupは、~error含みの例として，最もよく論じられる：
◎
The most-often discussed example of erroneous markup is as follows:
</p>

<pre class="html-code">
&lt;p&gt;1&lt;b&gt;2&lt;i&gt;3&lt;/b&gt;4&lt;/i&gt;5&lt;/p&gt;
</pre>

<p>
この~markupの構文解析は、 `3^l までは素直に進む。
この時点での~DOMは、次の様な見かけになる：
◎
The parsing of this markup is straightforward up to the "3". At this point, the DOM looks like this:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`p$e
			<ul><li>`#text$: <span>1</span>
			</li><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li><li>`i$e
					<ul><li>`#text$: <span>3</span>
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この時点で、`~open要素~stack$は 順に 5 個の要素
— `html$e, `body$e, `p$e, `b$e, `i$e —
からなり，`作動中の整形~要素~list$は  2 個の要素
— `b$e, `i$e —
からなり，`挿入~mode$は`~body内$mdになる。
◎
Here, the stack of open elements has five elements on it: html, body, p, b, and i. The list of active formatting elements just has two: b and i. The insertion mode is "in body".
</p>

<p>
~tag名に `b^l を伴う終了tag~tokenを受取ったときには、`養子縁組~algo$が呼出される。
これは単純な事例であり、
%整形~要素 は `b$e 要素，
%最遠の~block はない。
したがって`~open要素~stack$は 3 個の要素
— `html$e, `body$e, `p$e —
からなる一方で，`作動中の整形~要素~list$は `i$e 要素 1 個だけからなる。
この時点では、~DOM木はまだ改変されない。
◎
Upon receiving the end tag token with the tag name "b", the "adoption agency algorithm" is invoked. This is a simple case, in that the formatting element is the b element, and there is no furthest block. Thus, the stack of open elements ends up with just three elements: html, body, and p, while the list of active formatting elements has just one: i. The DOM tree is unmodified at this point.
</p>

<p>
次n~tokenは文字 `4^l であり、`作動中の整形~要素たちを再構築する$
— この事例では、 `i$e 要素だけ —
を誘発する。
したがって， `Text$I ~node `4^l 用に新たな `i$e 要素が作成される。
`i^l に対する終了tag~tokenも受取った後には，
`Text$I ~node `5^l も挿入され、~DOMは次の様になる：
◎
The next token is a character ("4"), triggers the reconstruction of the active formatting elements, in this case just the i element. A new i element is thus created for the "4" Text node. After the end tag token for the "i" is also received, and the "5" Text node is inserted, the DOM looks as follows:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`p$e
			<ul><li>`#text$: <span>1</span>
			</li><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li><li>`i$e
					<ul><li>`#text$: <span>3</span>
					</li></ul>
				</li></ul>
				</li><li>`i$e
					<ul><li>`#text$: <span>4</span>
					</li></ul>
				</li><li>`#text$: <span>5</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

				</section>
				<section id="misnested-tags:-b-p-/b-/p">
<h4 title="Misnested tags: &lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;">12.2.9.2. 誤入子な~tag： `&lt;b&gt;&lt;p&gt;&lt;/b&gt;&lt;/p&gt;^c</h4>

~INFORMATIVE

<p>
前~節に類似する事例：
◎
A case similar to the previous one is the following:
</p>

<pre class="html-code">
&lt;b&gt;1&lt;p&gt;2&lt;/b&gt;3&lt;/p&gt;
</pre>

<p>
ここでの構文解析は、 `2^l の所までは素直に進む：
◎
Up to the "2" the parsing here is straightforward:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
		</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li><li>`p$e
				<ul><li>`#text$: <span>2</span>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
関心があるのは、~tag名に `b^l を伴う終了tag~tokenが構文解析されるときである。
◎
The interesting part is when the end tag token with the tag name "b" is parsed.
</p>

<p>
その~tokenに出くわす前までは、`~open要素~stack$は 4 個の要素
— `html$e, `body$e, `b$e, `p$e —
からなり，`作動中の整形~要素~list$は `b$e のみからなり，`挿入~mode$は`~body内$mdになる。
◎
Before that token is seen, the stack of open elements has four elements on it: html, body, b, and p. The list of active formatting elements just has the one: b. The insertion mode is "in body".
</p>

<p>
~tag名に `b^l を伴う終了tag~tokenを受取るときには、前の例と同じく`養子縁組~algo$が呼出される。
しかしながら，今度の事例では %最遠の~block として `p$e 要素があるので、養子縁組~algoは飛ばされない。
◎
Upon receiving the end tag token with the tag name "b", the "adoption agency algorithm" is invoked, as in the previous example. However, in this case, there is a furthest block, namely the p element. Thus, this time the adoption agency algorithm isn't skipped over.
</p>

<p>
%共通の先祖 は `body$e 要素。
概念的な “~bookmark” は`作動中の整形~要素~list$における `b$e の位置を~markするが、その~listを成す要素は 1 個だけなので、~bookmarkによる効果はたいしてない。
◎
The common ancestor is the body element. A conceptual "bookmark" marks the position of the b in the list of active formatting elements, but since that list has only one element in it, the bookmark won't have much effect.
</p>

<p>
~algoが進捗するに伴い、
%~node は整形~要素 （ `b$e ）に設定され，
%最後の~node は %最遠の~block（ `p$e ）に設定される。
◎
As the algorithm progresses, node ends up set to the formatting element (b), and last node ends up set to the furthest block (p).
</p>

<p>
%最後の~node は、~DOMが次の様な見かけになるよう， %共通の先祖 に付加されることになる（移動される）：
◎
The last node gets appended (moved) to the common ancestor, so that the DOM looks like:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li></ul>
		</li><li>`p$e
			<ul><li>`#text$: <span>2</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
新たな `b$e 要素が作成され， `p$e 要素の子たちはそこに移動される：
◎
A new b element is created, and the children of the p element are moved to it:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
		</li><li>`body$e
			<ul><li>`b$e
				<ul><li>`#text$: <span>1</span>
				</li></ul>
			</li><li>`p$e
		</li></ul>
	</li></ul>
</li></ul>

<ul class="domTree"><li>`b$e
	<ul><li>`#text$: <span>2</span>
	</li></ul>
</li></ul>

<p>
最終的に，新たな `b$e 要素は、~DOMが次の様な見かけになるよう， `p$e 要素に付加される：
◎
Finally, the new b element is appended to the p element, so that the DOM looks like:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
`b$e 要素は、 `3^l が構文解析されるときに `p$e 要素に付加されるよう，［
`作動中の整形~要素~list$, `~open要素~stack$
］から除去される：
◎
The b element is removed from the list of active formatting elements and the stack of open elements, so that when the "3" is parsed, it is appended to the p element:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
			<ul><li>`#text$: <span>1</span>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e
				<ul><li>`#text$: <span>2</span>
				</li></ul>
			</li><li>`#text$: <span>3</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

				</section>
				<section id="unexpected-markup-in-tables">
<h4 title="Unexpected markup in tables">12.2.9.3. ~table内の予期されない~markup</h4>

~INFORMATIVE

<p>
~tableにおける~errorの取扱いは、歴史的~理由から，とりわけ変則的である。
例えば、次の~markupを考える：
◎
Error handling in tables is, for historical reasons, especially strange. For example, consider the following markup:
</p>

<pre class="html-code">
&lt;table&gt;<mark>&lt;b&gt;</mark>&lt;tr&gt;&lt;td&gt;aaa&lt;/td&gt;&lt;/tr&gt;<mark>bbb</mark>&lt;/table&gt;ccc
</pre>

<p>
上の様な強調されている `b$e 要素の開始tagは，~tableの内側には直接的には許容されないので、構文解析器はこの事例に対しては，要素を~tableの<em>前</em>に置くように取扱う（これは、`親を違える$と呼ばれる）。
これは、~DOM木を検分すれば見つかる
— それは `table$e 要素の開始tagに出くわした直後に~~現れるので：
◎
The highlighted b element start tag is not allowed directly inside a table like that, and the parser handles this case by placing the element before the table. (This is called foster parenting.) This can be seen by examining the DOM tree as it stands just after the table element's start tag has been seen:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`table$e
		</li></ul>
	</li></ul>
</li></ul>

<p>
`b$e 要素の開始tagに出くわした直後には、次の様になる：
◎
...and then immediately after the b element start tag has been seen:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`table$e
		</li></ul>
	</li></ul>
</li></ul>

<p>
この時点では、`~open要素~stack$は［
`html$e, `body$e, `table$e, `b$e
］要素からなり（結果の~DOM木に関わらず，この順序になる），`作動中の整形~要素~list$は `b$e 要素のみからなり，`挿入~mode$は`~table内$mdになる。
◎
At this point, the stack of open elements has on it the elements html, body, table, and b (in that order, despite the resulting DOM tree); the list of active formatting elements just has the b element in it; and the insertion mode is "in table".
</p>

<p>
`tr$e 開始tagは、 `b$e 要素を~stackから~popさせ，
`tbody$e 開始tagが黙示されることになる;
次の `tbody$e と `tr$e 要素は素直に取扱われ，構文解析器が挿入~mode
`~table~body内$md, `~row内$md
を経るように導く。
結果の~DOMは、次の様になる：
◎
The tr start tag causes the b element to be popped off the stack and a tbody start tag to be implied; the tbody and tr elements are then handled in a rather straight-forward manner, taking the parser through the "in table body" and "in row" insertion modes, after which the DOM looks as follows:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
ここでの`~open要素~stack$は［
`html$e, `body$e, `table$e, `tbody$e, `tr$e
］要素からなり，`作動中の整形~要素~list$は依然として `b$e 要素のみからなり，`挿入~mode$は`~row内$mdになる。
◎
Here, the stack of open elements has on it the elements html, body, table, tbody, and tr; the list of active formatting elements still has the b element in it; and the insertion mode is "in row".
</p>

<p>
`td$e 要素を木に置いた後、その開始tag~tokenは，`作動中の整形~要素~list$に`~marker$を置く（それはまた，`~cell内$mdに切替える）。
◎
The td element start tag token, after putting a td element on the tree, puts a marker on the list of active formatting elements (it also switches to the "in cell" insertion mode).
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この`~marker$は、［
文字~token列 `aaa^l に出くわしたとき、［
それによる結果の `Text$I ~nodeを保持するために `b$e 要素を作成する
］ことはない
］ことを意味する：
◎
The marker means that when the "aaa" character tokens are seen, no b element is created to hold the resulting Text node:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
	<ul><li>`b$e
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
						<ul><li>`#text$: <span>aaa</span>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
終了tagたちは，素直に取扱われ、それらを取扱った後には，`~open要素~stack$は［
`html$e, `body$e, `table$e, `tbody$e
］要素からなり，`作動中の整形~要素~list$は 依然として `b$e 要素のみからなり（`~marker$は `td^l 終了tag~tokenによりすでに除去されている），`挿入~mode$は`~table~body内$mdになる。
◎
The end tags are handled in a straight-forward manner; after handling them, the stack of open elements has on it the elements html, body, table, and tbody; the list of active formatting elements still has the b element in it (the marker having been removed by the "td" end tag token); and the insertion mode is "in table body".
</p>

<p>
したがって見出されるのは、文字~token列 `bbb^l になる。
これらは`~table~text内$mdの利用を誘発する（ `元の挿入~mode$V を`~table~body内$mdに設定して）。
この文字~token列は収集され、次n~token（ `table$e 要素の終了tag）に出くわしたときには，~groupとして処理される。
それらには~space以外も混じっているので、`~table内$mdにおける “~AnyElse” 規則に従って取扱われる
— それは、`親を違える$下で，`~body内$mdに先送りする。
◎
Thus it is that the "bbb" character tokens are found. These trigger the "in table text" insertion mode to be used (with the original insertion mode set to "in table body"). The character tokens are collected, and when the next token (the table element end tag) is seen, they are processed as a group. Since they are not all spaces, they are handled as per the "anything else" rules in the "in table" insertion mode, which defer to the "in body" insertion mode but with foster parenting.
</p>

<p>
`作動中の整形~要素たちを再構築する$ときには、`親を違える$ように `b$e 要素が作成され，
`Text$I ~node `bbb^l はそれに付加される：
◎
When the active formatting elements are reconstructed, a b element is created and foster parented, and then the "bbb" Text node is appended to it:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`b$e
			<ul><li>`#text$: <span>bbb</span>
			</li></ul>
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
						<ul><li>`#text$: <span>aaa</span>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
`~open要素~stack$は［
`html$e, `body$e, `table$e, `tbody$e, 新たな `b$e
］要素からなり（ここでも，順序は結果の木には合致しないことに注意！），
`作動中の整形~要素~list$は 新たな `b$e 要素からなり，`挿入~mode$は依然として `~table~body内$mdになる。
◎
The stack of open elements has on it the elements html, body, table, tbody, and the new b (again, note that this doesn't match the resulting tree!); the list of active formatting elements has the new b element in it; and the insertion mode is still "in table body".
</p>

<p>
文字~token列が `bbb^l に代えて`~ASCII空白$のみからなっていた場合、単に `tbody$e 要素に付加されることになる。
◎
Had the character tokens been only ASCII whitespace instead of "bbb", then that ASCII whitespace would just be appended to the tbody element.
</p>

<p>
最終的に `table$e は、終了tag `table^l により閉じられる。
これは，`~open要素~stack$から `table$e 要素までの~nodeすべてを~popさせるが，`作動中の整形~要素~list$には影響しないので、 `table^e の後にある文字~token列 `ccc^l は，今度は `table^e の後に もう一つ作成される `b$e 要素~内に置かれる：
◎
Finally, the table is closed by a "table" end tag. This pops all the nodes from the stack of open elements up to and including the table element, but it doesn't affect the list of active formatting elements, so the "ccc" character tokens after the table result in yet another b element being created, this time after the table:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`b$e
		</li><li>`b$e
			<ul><li>`#text$: <span>bbb</span>
			</li></ul>
		</li><li>`table$e
			<ul><li>`tbody$e
				<ul><li>`tr$e
					<ul><li>`td$e
						<ul><li>`#text$: <span>aaa</span>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`b$e
			<ul><li>`#text$: <span>ccc</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

				</section>
				<section id="scripts-that-modify-the-page-as-it-is-being-parsed">
<h4 title="Scripts that modify the page as it is being parsed">12.2.9.4. 構文解析されている頁を改変する~script</h4>

~INFORMATIVE

<p>
次の~markupを考える。
この例においては、“内縁” 文書（ `~URL$ `https://example.com/inner^l ）は，別の “外縁” 文書（ `~URL$ `https://example.com/outer^l ）内で
`iframe$e の内容として具現化されているとする：
◎
Consider the following markup, which for this example we will assume is the document with URL https://example.com/inner, being rendered as the content of an iframe in another document with the URL https://example.com/outer:
</p>

<pre class="html-code">
&lt;div id=a&gt;
 &lt;script&gt;
  var %div = document.getElementById('a');
  parent.document.body.appendChild(%div);
 &lt;/script&gt;
 &lt;script&gt;
  alert(document.URL);
 &lt;/script&gt;
&lt;/div&gt;

&lt;script&gt;
 alert(document.URL);
&lt;/script&gt;
</pre>

<p>
1 個目の `script^l 終了tagまでの，~scriptが構文解析される前の結果は、比較的~素直に進む：
◎
Up to the first "script" end tag, before the script is parsed, the result is relatively straightforward:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`div$e <span class="t2">`id$a="`a^c"</span>
			<ul><li>`#text$: <span></span>
			</li><li>`script$e
				<ul><li>`#text$: <span>var %div = document.getElementById('a'); ⏎ parent.document.body.appendChild(%div);</span>
				</li></ul>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
が、~scriptが構文解析された後では，
`div$e 要素とその子 `script$e 要素は去る：
◎
After the script is parsed, though, the div element and its child script element are gone:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
	</li></ul>
</li></ul>

<p>
去ったそれらは、この時点で，前述の 外縁`閲覧文脈$の`文書$内にある。
しかしながら，`~open要素~stack$は<em>依然として</em> `div$e 要素を包含する。
◎
They are, at this point, in the Document of the aforementioned outer browsing context. However, the stack of open elements still contains the div element.
</p>

<p>
したがって， 2 個目の `script$e 要素が構文解析されるとき、それは
<em>外縁 `文書$の中</em>に挿入される。
◎
Thus, when the second script element is parsed, it is inserted into the outer Document object.
</p>

<p>
構文解析器が作成したものとは異なる`文書$用に構文解析されるものは，実行されないので、
1 個目の~alertは示されない。
◎
Those parsed into different Documents than the one the parser was created for do not execute, so the first alert does not show.
</p>

<p>
`div$e 要素の終了tagが構文解析されたなら、 `div$e 要素は~stackから~popされるので，
3 個目の `script$e 要素は内縁 `文書$内にある：
◎
Once the div element's end tag is parsed, the div element is popped off the stack, and so the next script element is in the inner Document:
</p>

<ul class="domTree"><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`script$e
			<ul><li>`#text$: <span>alert(document.URL);</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この~scriptが実行される結果、
`https://example.com/inner^l
を示す~alertが生じる。
◎
This script does execute, resulting in an alert that says "https://example.com/inner".
</p>

				</section>
				<section id="the-execution-of-scripts-that-are-moving-across-multiple-documents">
<h4 title="The execution of scripts that are moving across multiple documents">12.2.9.5. 複数の文書にまたがって移動する~scriptの実行</h4>

~INFORMATIVE

<p>
前~節の例から更に詳しく、 2 個目の `script$e 要素は外部~scriptである（すなわち， `src$a 属性を有する）事例を考える。
要素は作成-時点では構文解析器の`文書$内にはなかったので、この外部~scriptは~downloadすらされない。
◎
Elaborating on the example in the previous section, consider the case where the second script element is an external script (i.e. one with a src attribute). Since the element was not in the parser's Document when it was created, that external script is not even downloaded.
</p>

<p>
`src$a 属性を有する `script$e 要素が 通常のように 構文解析器の`文書$の中へ構文解析されつつ，
その外部~scriptの~download中に 要素が別の文書へ移動された場合、~downloadは継続されるが，~scriptは実行されない。
◎
In a case where a script element with a src attribute is parsed normally into its parser's Document, but while the external script is being downloaded, the element is moved to another document, the script continues to download, but does not execute.
</p>

<p class="note">注記：
一般に、 `script$e 要素を`文書$間で移動することは，不良な実施と見なされる。
◎
In general, moving script elements between Documents is considered a bad practice.
</p>

				</section>
				<section id="unclosed-formatting-elements">
<h4 title="Unclosed formatting elements">12.2.9.6. 閉じられてない整形~要素</h4>

~INFORMATIVE

<p>
次の~markupに、入子にされた整形~要素（ `b$e など）が
— それを包含する要素が閉じられても —
収集され，適用され続けることになる様子を示す。
ただし、過度の重複は棄てられる。
◎
The following markup shows how nested formatting elements (such as b) get collected and continue to be applied even as the elements they are contained in are closed, but that excessive duplicates are thrown away.
</p>

<pre class="html-code">
&lt;!DOCTYPE html&gt;
&lt;p&gt;&lt;b class=x&gt;&lt;b class=x&gt;&lt;b&gt;&lt;b class=x&gt;&lt;b class=x&gt;&lt;b&gt;X
&lt;p&gt;X
&lt;p&gt;&lt;b&gt;&lt;b class=x&gt;&lt;b&gt;X
&lt;p&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;&lt;/b&gt;X
</pre>

<p>
結果の~DOM木は、次の様になる：
◎
The resulting DOM tree is as follows:
</p>

<ul class="domTree"><li>DOCTYPE: `html^c
	</li><li>`html$e
	<ul><li>`head$e
	</li><li>`body$e
		<ul><li>`p$e
			<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
				<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
					<ul><li>`b$e
						<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
							<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
								<ul><li>`b$e
									<ul><li>`#text$: <span>X⏎</span>
									</li></ul>
								</li></ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
				<ul><li>`b$e
					<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
						<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
							<ul><li>`b$e
								<ul><li>`#text$: <span>X⏎</span>
								</li></ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`p$e
			<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
				<ul><li>`b$e
					<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
						<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
							<ul><li>`b$e
								<ul><li>`b$e
									<ul><li>`b$e <span class="t2">`class$a="`x^c"</span>
										<ul><li>`b$e
											<ul><li>`#text$: <span>X⏎</span>
											</li></ul>
										</li></ul>
									</li></ul>
								</li></ul>
							</li></ul>
						</li></ul>
					</li></ul>
				</li></ul>
			</li></ul>
		</li><li>`p$e
			<ul><li>`#text$: <span>X⏎</span>
			</li></ul>
		</li></ul>
	</li></ul>
</li></ul>

<p>
この~markup内の 2 個目の `p$e 要素は，明示的な `b$e 要素を持たないが、結果の~DOM内では，要素の `X^l の前にて 3 個までの各~種類の整形~要素（この事例では、 `class^a 属性を有する 3 個の `b$e 要素と, 有さない 2 個の `b$e 要素）が再構築されることになる様子に注意。
◎
Note how the second p element in the markup has no explicit b elements, but in the resulting DOM, up to three of each kind of formatting element (in this case three b elements with the class attribute, and two unadorned b elements) get reconstructed before the element's "X".
</p>

<p>
この地点までに 9 個の `b$e 開始tagに出くわしたが、このことは，［
最後の段落において、`作動中の整形~要素~list$内で完全に~clearする必要があるのは， 6 個の `b$e 終了tagに限られる
］ことを意味するのにも注意。
◎
Also note how this means that in the final paragraph only six b end tags are needed to completely clear the list of active formatting elements, even though nine b start tags have been seen up to this point.
</p>

				</section>
			</section>
		</section>
		<section id="serialising-html-fragments">
<h2 title="Serializing HTML fragments">12.3. ~HTML素片の直列化-法</h2>

<p class="trans-note">【
この節の内容は、<a href="~HTMLwriting#serialising-html-fragments" >別ページ</a>にて。
】</p>


		</section>
		<section id="parsing-html-fragments">
<h2 title="Parsing HTML fragments">12.4. ~HTML素片の構文解析-法</h2>


<div  class="p">
<p class="algo-head">
`~HTML素片の構文解析~algo@
は，以下に述べる手続きで与えられる
— この~algoは、次の 2 つを入力にとり，
0 個~以上の~nodeからなる~listを返す：
</p>

<ul ><li>`文脈~要素@V
と称される，構文解析器~用の文脈を与える `Element$I ~node
</li><li>構文解析する文字列 %入力
</li></ul>

<p>
この~algoにより作成される構文解析器は、
`~HTML素片~用@
であるとされる。
</p>

◎
The following steps form the HTML fragment parsing algorithm. The algorithm takes as input an Element node, referred to as the context element, which gives the context for the parser, as well as input, a string to parse, and returns a list of zero or more nodes.
</div>

<p class="note">注記：
構文解析器~節における各種~algoにおいて
`素片~事例@
と~markされた箇所は、構文解析器が この~algoの目的で作成されときに限り生じる。
そのような~markは、参考~目的に限って注釈されており，規範的な重みはない。
`素片~事例$として述べられた条件は、構文解析器が この~algoを取扱う目的で作成されたものでない場合でも，生じる可能性がある
— それは，この仕様における
【~markの】
誤りである。
◎
Parts marked fragment case in algorithms in the parser section are parts that only occur if the parser was created for the purposes of this algorithm. The algorithms have been annotated with such markings for informational purposes only; such markings have no normative weight. If it is possible for a condition described as a fragment case to occur even when the parser wasn't created for the purposes of handling this algorithm, then that is an error in the specification.
</p>

<ol>
	<li>
%文書 ~LET 新たな`文書$
◎
Create a new Document node, and＼
</li>
	<li>
%文書 の`種別$doc ~SET `html^l
◎
mark it as being an HTML document.
</li>
	<li>
%文書 の`~mode$doc ~SET  `文脈~要素$V の`~node文書$の`~mode$doc
◎
If the node document of the context element is in quirks mode, then let the Document be in quirks mode. Otherwise, the node document of the context element is in limited-quirks mode, then let the Document be in limited-quirks mode. Otherwise, leave the Document in no-quirks mode.
</li>
	<li>
%構文解析器 ~LET 新たな `~HTML構文解析器$
◎
Create a new HTML parser, and＼
</li>
	<li>
%構文解析器 を %文書 に結付ける
◎
associate it with the just created Document node.
</li>
	<li>
<p>
%構文解析器 の`~token化~段階$の状態 ~SET `文脈~要素$V に応じて，次で与えられる`状態$：
◎
Set the state of the HTML parser's tokenization stage as follows, switching on the context element:
</p>
		<dl class="switch">
			<dt>`title$e</dt>
			<dt>`textarea$e</dt>
			<dd>
`~RCDATA$st
◎
Switch the tokenizer to the RCDATA state.
</dd>
			<dt>`style$e</dt>
			<dt>`xmp$e</dt>
			<dt>`iframe$e</dt>
			<dt>`noembed$e</dt>
			<dt>`noframes$e</dt>
			<dd>
`~RAWTEXT$st
◎
Switch the tokenizer to the RAWTEXT state.
</dd>
			<dt>`script$e</dt>
			<dd>
`~script~data$st
◎
Switch the tokenizer to the script data state.
</dd>
			<dt>`noscript$e</dt>
			<dd>
`~scripting~flag$に応じて
⇒
`可能化^i  ならば `~RAWTEXT$st ／
`不能化^i ならば `~data$st
◎
If the scripting flag is enabled, switch the tokenizer to the RAWTEXT state. Otherwise, leave the tokenizer in the data state.
</dd>
			<dt>`plaintext$e</dt>
			<dd>
`~PLAINTEXT$st
◎
Switch the tokenizer to the PLAINTEXT state.
</dd>
			<dt>その他◎Any other element</dt>
			<dd>
`~data$st
◎
Leave the tokenizer in the data state.
</dd>
		</dl>

<p class="note">注記：
実装は、処理能の理由から［
~errorを報告しない, かつ
この仕様に述べた実際の状態~機械を直接的に利用する
］ならば，上に挙げた［
`~RAWTEXT^st ／ `~script~data^st
］に代えて `~PLAINTEXT^st を利用することもできる。
それらは、~perrorに関する規則を除き等価である
— `素片~事例$には`適切な終了tag~token$はないので
, yet【？】
それらが孕む状態~遷移はずっと少ない。
◎
For performance reasons, an implementation that does not report errors and that uses the actual state machine described in this specification directly could use the PLAINTEXT state instead of the RAWTEXT and script data states where those are mentioned in the list above. Except for rules regarding parse errors, they are equivalent, since there is no appropriate end tag token in the fragment case, yet they involve far fewer state transitions.
</p>
	</li>
	<li>
%根 ~LET 属性を伴わない，新たな `html$e 要素
◎
Let root be a new html element with no attributes.
</li>
	<li>
%文書 に %根 を付加する
◎
Append the element root to the Document node created above.
</li>
	<li>
%構文解析器 の`~open要素~stack$は %根 のみを包含するように設定しておく
◎
Set up the parser's stack of open elements so that it contains just the single element root.
</li>
	<li>
~IF［
`文脈~要素$V は `template$e 要素である
］
⇒
`~template内$mdを `~template挿入~mode~stack$に~pushする
◎
If the context element is a template element, push "in template" onto the stack of template insertion modes so that it is the new current template insertion mode.
</li>
	<li>
%開始tag~token ~LET 新たな開始tag~token( `文脈~要素$V の局所~名 )
◎
Create a start tag token whose name is the local name of context and＼
</li>
	<li>
%開始tag~token の属性~list ~SET `文脈~要素$V の属性~list
◎
whose attributes are the attributes of context.
</li>
	<li>
<p>
%開始tag~token を［
`文脈~要素$V を作成させた開始tag~token
］とする
</p>

<p class="note">注記：
これは例えば、`~HTML統合~地点$であるかどうか決定するときに利用される。
</p>
◎
Let this start tag token be the start tag token of the context node, e.g. for the purposes of determining if it is an HTML integration point.
</li>
	<li>
<p>
%構文解析器 の`挿入~modeを適切に再設定する$
◎
Reset the parser's insertion mode appropriately.
</p>

<p class="note">注記：
%構文解析器 は その~algoの一部として `文脈~要素$V を参照することになる。
◎
The parser will reference the context element as part of that algorithm.
</p>
	</li>
	<li>
%構文解析器 の`~form要素~pointer$ ~SET
`文脈~要素$V または その先祖に `form$e 要素が［
在れば それらのうち `文脈~要素$V に最も近いもの ／
無ければ ~NULL
］
◎
Set the parser's form element pointer to the nearest node to the context element that is a form element (going straight up the ancestor chain, and including the element itself, if it is a form element), if any. (If there is no such form element, the form element pointer keeps its initial value, null.)
</li>
	<li>
［
符号化方式の`確度$ ~SET `無関係^i
］とする下で、
%構文解析器 の`入力~stream$の中へ %入力 を流す
◎
Place the input into the input stream for the HTML parser just created. The encoding confidence is irrelevant.
</li>
	<li>
入力~streamをすべて消費するまで、 %構文解析器 を走らす
◎
Start the parser and let it run until it has consumed all the characters just inserted into the input stream.
</li>
	<li>
~RET %根 の子~nodeたちからなる`木~順序$による~list
◎
Return the child nodes of root, in tree order.
</li>
</ol>

		</section>
	</section>
</main><!-- MAIN -->
