<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Document lifecycle（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'hH':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2025-07-30
trans_update:2025-08-02
source_checked:250730
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/document-lifecycle.html
	abbr_url:HTMLlifecycle
site_nav:browsers,network,html
nav_prev:HTMLnav
nav_next:WAPI
trans_1st_pub:2017-01-01
	trans_1st_pub:2022-11-08

●●class_map
e:element
a:attr
et:event-type
sc:scheme
dir:directive
jv:js-value
st:attr-state

●●tag_map
I:code
c:code
e:code
a:code
et:code
sc:code
mt:code
dir:code
st:i
i:i
sub:sub
cite:cite
	em:em

●●original_urls

●●words_table

		●network
Content-Type:
X-Frame-Options:
	HTTP_S:HTTP(S) 
COOP:
close:
load:
読込直す:reloadする::読み込み直す::リロードする
refresh:
unload:
	~unload法:unloading:
部位t:part:部位
	複-部位t:multipart

		●環境 ／ navi
lifecycle:
agent:
iframe:
worklet:
about:
回復可能:salvage 可能:~
回復不能:salvage 不能:~
opener:::open 元
	生成元が類似な:similar-origin

	●UI
操作o:operation:操作
隠さな:hideしな:~
viewer::::ビューア
popup::::ポップアップ
新鮮:fresh:~
確認-:confirm:~
閉じる:closeする::~
仔細:nuanced:~
route::::ルート
	強制的に閉じる:force-closing
	長押し:long-press
	押した:press
	進む:forward
	戻る:back
	奥へ進む選択肢:choice as to whether to go down
	選べる:chooseできる:~

	●構文
EOF:
tokenizer:::token 化器:トークン化器:トークナイザ
整形式性:well-formedness::~
同型:isomorphic::~
	和集合:union::~
区切られ:delimitされ:~
	~ID:id
	LF
	LINE FEED

	●一般処理
片付け:cleanup::~
片付ける:clean upする::~
timer::::タイマー
準備度:readiness:~
最終-:final:~
params::::パラメタ群
処置先:disposition::~
生存-:alive::~
	生存し続け:keep 〜 alive
handle:
休止:suspension::~
設置-:place:~
commit:
早期:early::~
放棄-:abandon:~
作成時の:creation::~
分岐:branch:~
連絡:entangle::~
	連絡を断つ:disentangle
復旧-:restore::~
自由化-:free:~
	~call元:caller
	終わらす:finish
	渡さな:pass
	必要なら:potentially

	●変数
旧-:old:~
新-:new:~
X:
BF:
保つ:keepする:~

	~COOP:coop
	%O:eventSource
	%O:webSocket
	%O:transport
	%body:body
	%html:html
	%head:head
	%~BF~cache内に保つか:intendToKeepInBfcache
	%~CSP~list:cspList
	%~MIME型:type
	%~X-Frame-Options:rawXFrameOptions
	%~frame~option群:xFrameOptions
	%~agent:agent
	%~event~loop:eventLoop
	%~host要素:hostelement
	%~load計時~報:loadTimingInfo
	%~navigable:navigable
	%~navi~ID:navigationId
	%~navi計時~種別:navTimingType
	%~navi計時~種別:navigationTimingType
	%~navi状態s:-
	%~realm実行~文脈:realmExecutionContext
	%~redirect回数:redirectCount
	%~referrer:referrer
	%~source~snapshot~params:sourceSnapshotParams
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%~unload計時~報:unloadTimingInfo
	%~window:window
	%~worklet大域~scope:workletGlobalScope
	%作動中な文書:-
	%作成時の~URL:creationURL
	%値:value
	%全部的な計時~報:fullTimingInfo
	%内容~型:contentType:
	%容器~文書:containerDocument
	%応答:response
	%文書:document
	%施策:policy
	%早期~hintを~commitする:-
	%最初の部位t用の~navi~params:firstPartNavigationParams
	%生成元~agent~cluster~header:oacHeader
	%生成元~agent~clusterを要請するか:requestsOAC
	%行先~生成元:destinationOrigin
	%親~環境:parentEnvironment
	%許可~施策:permissionsPolicy
	%起動元~生成元:initiatorOrigin
	%閲覧~文脈:browsingContext
	%新-文書:newDocument
	%旧-文書:oldDocument
	%~navi~params:navigationParams
	%容器:container
	%種別:type
	%生成元:origin
	%~COOP:coop
	%~COOP施行n結果:coopEnforcementResult
	%子孫~navigable群:descendantNavigables
	%子孫~navigable:descendantNavigable
	-:childNavigables
	%子~navigable:childNavigable
	%~unload済み数:numberUnloaded
	%~unload済みを増加する:incrementUnloaded
	%すべて~unload後の手続き:afterAllUnloads
	%~pageswap_evを発火する手続き:firePageSwapSteps
	%破壊-済み数:numberDestroyed
	%破壊-済みを増加する:incrementDestroyed
	%すべて破壊-後の手続き:afterAllDestruction
	%事由:reason

	●保安
濫用:abuse:~
偽り:spurious:~
罠:trap:~
粗化-:coarsen:粗く

	罠に嵌める:letting 〜 trap
	詰め込む:stuff
	許可~施策:Permissions Policy

	●仕様
濫用:abuse:~
翻訳-:translate:~
先進的:novel:~
必要最小限:minimal:~
変種:variant:~
無意味:meaningless:~
自立的:stand-alone:~
整合的に:consistent mannerで:~
固守:adherence:~
細やか:granular:~
強制的:forcible:~
	強制的に:force-〜
施行n:enforcement::施行
克服-:overcome:~

	対になる:for that matter
	問われない:do not matter
	~~真の:real
	ことになった場合:face
	するよりも~~寛容でない:less permissive compared to doing 〜 instead
	-:potentially
	取って代わる:supersede
	紛らわしく:confused
	許容されない:disallowed
	示す:illustrate
	~~形式上のものでしかなく:besides preventing the Document-creation algorithm from getting confused
	~~検討:contemplate

	●未分類
高分解能:high resolution::~
	合成-:synthesize::~
消滅-:disappear:~
埋めた:fillした:~
埋めて:fillして:~
切替えた:switchした:切り替えた
切替える:switchする:切り替える
折返す:wrapする:折り返す
発した:emitした:~
購入:purchase:~
差分:delta:~
transaction::::トランザクション
database::::データベース
POST:
PLAINTEXT:
PDF:
WebDriver-BiDi:
投入-:feed:~
quota::::クォータ

	2 個目以降の:additional
	間に挟む:intervening
	戻る:back
	現れる:appearする
	続けて:in a row
	ほとんど:largely
	より大きい:larger
	箇所で:points
	何らかの~style:extra styling
	尽きた:no more
	されなくなる:will not end-up being
	結果になる:will end-up
	いつまでかかるか:how long it took
	ことになった:faced
	2 以上:greater than one
	〜であっても:despite
	〜でなくとも:despite not
	が無い:-less
	この場合:This means that
	最終的に:eventually
	引用用の:quoting
	-:lack of
	同行する:go along with

●●words_table1
WEBDRIVER-BIDI:https://w3c.github.io/webdriver-bidi/
WEBTRANSPORT:webtransport-ja.html

sf:<sub>sf-</sub>
about_blank:about:blank
html-head-body: <code class="element">html</code>, <code class="element">head</code>, <code class="element">body</code> 
pageswap_ev: <code class="event-type">pageswap</code> 

●●original_id_map

	nav-traversal-ui:history-notes
	read-ua-inline:read-ua-plugin
	read-ua-inline:navigate-plugin
	unload-counter:ignore-opens-during-unload-counter
	destroy-a-document:discard-a-document
	nav-stop:stop-document-loading

●●mdn_urls

●●link_map

	●code

I.CustomElementRegistry:~HEcustom#customelementregistry
I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.EventSource:~HTMLsse#eventsource
I.MessagePort:~HTMLcomms#messageport
I.NavigationTimingType:~NAV-TIMING#dom-navigationtimingtype
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest
I.WebSocket:~WEBSOCKET#websocket
I.WindowProxy:~HTMLWPROXY#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WebTransport:~WEBTRANSPORT#webtransport
I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
	I.Window:~WINDOW#window
~window:~WINDOW#the-window-object

	:~WINDOW#dom-window-stop
c.document.domain:~ORIGIN#dom-document-domain

l.websocket:~WINDOW#blocking-websocket
l.masked:~WINDOW#blocking-masked
l.fetch:~WINDOW#blocking-fetch
l.parser-aborted:~WINDOW#blocking-parser-aborted

a.autoplay:~HEmedia#attr-media-autoplay
a.http-equiv:~HEmetadata#attr-meta-http-equiv
	:~HEimages#attr-img-src
	:~HEmedia#attr-media-src

e.audio:~HEmedia#the-audio-element
e.frame:~HTMLobs#frame
e.head:~HEmetadata#the-head-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.meta:~HEmetadata#the-meta-element
e.title:~HEmetadata#the-title-element
e.video:~HEmedia#the-video-element

et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.unload:~HTMLindex#event-unload

h.Origin-Agent-Cluster:~ORIGIN#origin-agent-cluster
h.Refresh:#refresh
h.X-Frame-Options:#x-frame-options

mt.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
mt.text/html:~HTMLiana#text/html

st.~refresh:~HEmetadata#attr-meta-http-equiv-refresh

sc.~about_blank:~HTMLdep#about:blank

	●用語


文書を作成して初期化する:#initialise-the-document-object
完全に読込まれた:#completely-loaded
完全に読込まれた時刻:#completely-loaded-time
読込ngを完全に終わらす:#completely-finish-loading
文書を破壊する:#destroy-a-document
文書とその子孫たちを破壊する:#destroy-a-document-and-its-descendants
文書を中止する:#abort-a-document
文書とその子孫たちを中止する:#abort-a-document-and-its-descendants
読込ngを停止する:#nav-stop

doc.~pageを示しているか:#page-showing
doc.休止~時刻:#suspension-time
doc.休止された~timer~handle群:#suspended-timer-handles
doc.回復可能か:#concept-document-salvageable

文書を~unloadする:#unload-a-document
文書とその子孫たちを~unloadする:#unload-a-document-and-its-descendants
終了n入子ng~level:#termination-nesting-level
~unload~counter:#unload-counter
文書~unload時の片付け手続き:#unloading-document-cleanup-steps

~HTML文書を読込む:#navigate-html
~text文書を読込む:#navigate-text
multipart/x-mixed-replace 文書を読込む:#navigate-multipart-x-mixed-replace
~media文書を読込む:#navigate-media
~navi応答の~X-Frame-Optionsに対する固守を検査する:#check-a-navigation-response's-adherence-to-x-frame-options
文書を~html-head-bodyで拡充する:#populate-with-html/head/body


	●用語（HTML

並列的:~HTMLINFRA#in-parallel
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications
~Content-Type~metadata:~HTMLurl#content-type

doc.~load計時~報:~HTMLdom#load-timing-info
doc.読込ng中における~WebDriver-BiDi用の~navi~ID:~HTMLdom#concept-document-navigation-id
	doc.~navi~ID:~HTMLdom#concept-document-navigation-id
doc.~referrer:~HTMLdom#the-document's-referrer
doc.初期~about_blankか:~HTMLdom#is-initial-about:blank
doc.前-文書の~unload計時~報:~HTMLdom#previous-document-unload-timing
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.現在の準備度:~HTMLdom#current-document-readiness
doc.許可~施策:~HTMLdom#concept-document-permissions-policy
doc.~opener施策:~HTMLdom#concept-document-coop
doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects
doc.~about基底~URL:~HTMLdom#concept-document-about-base-url
~navi開始~時刻:~HTMLdom#navigation-start-time
~unload~event終了~時刻:~HTMLdom#unload-event-end-time
~unload~event開始~時刻:~HTMLdom#unload-event-start-time
作動中な構文解析器:~HTMLdom#active-parser
初期~about_blank な文書:~HTMLdom#is-initial-about:blank
文書~load計時~報:~HTMLdom#document-load-timing-info
文書~unload計時~報:~HTMLdom#document-unload-timing-info

~navi応答~用に利用する閲覧~文脈を得する:~ORIGIN#obtain-browsing-context-navigation
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元:~ORIGIN#concept-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
同一-生成元:~ORIGIN#same-origin
作動中な~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
施策~容器:~ORIGIN#policy-container
~opener施策:~ORIGIN#cross-origin-opener-policy
~opener施策の施行n結果:~ORIGIN#coop-enforcement-result
cooP.~URL:~ORIGIN#coop-enforcement-url
cooP.生成元:~ORIGIN#coop-enforcement-origin
cooP.~opener施策:~ORIGIN#coop-enforcement-coop

~window用に環境~設定群~objを設定しておく:~WINDOW#set-up-a-window-environment-settings-object
結付けられた文書:~WINDOW#concept-document-window
~UAに特有な阻んでいる事由:~WINDOW#ua-specific-blocking-reasons
~page遷移~eventを発火する:~HTMLnavAPI#fire-a-page-transition-event

全部的に作動中:~HTMLds#fully-active
~navigable:~HTMLds#navigable
~node~navigable:~HTMLds#node-navigable
nav.作動中な~entry:~HTMLds#nav-active-history-entry
nav.容器:~HTMLds#nav-container
nav.容器~文書:~HTMLds#nav-container-document
doc.容器~文書:~HTMLds#doc-container-document
nav.作動中な文書:~HTMLds#nav-document
nav.作動中な閲覧~文脈:~HTMLds#nav-bc
nav.辿可能な~navigable:~HTMLds#nav-traversable
nav.~session履歴~辿り~queue:~HTMLds#tn-session-history-traversal-queue
nav.作動中な~window:~HTMLds#nav-window
tbcG.~group:~HTMLds#tlbc-group
tn.~session履歴~entry群:~HTMLds#tn-session-history-entries
子~navigable:~HTMLds#child-navigable
子孫~navigable群:~HTMLds#descendant-navigables
新たな子~navigableを作成する:~HTMLds#create-a-new-child-navigable
新鮮な~top-level辿可能を作成する:~HTMLds#create-a-fresh-top-level-traversable
辿可能な~navigable:~HTMLds#traversable-navigable
~top-level辿可能:~HTMLds#top-level-traversable
~top-level辿可能~集合:~HTMLds#top-level-traversable-set
~top-level辿可能を破壊する:~HTMLds#destroy-a-top-level-traversable
~top-level辿可能を閉じる:~HTMLds#close-a-top-level-traversable
閲覧~文脈:~HTMLds#browsing-context
bc.~popupか:~HTMLds#is-popup
bc.作動中な文書:~HTMLds#active-document
bc.作動中な~window:~HTMLds#active-window
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
属する閲覧~文脈:~HTMLds#concept-document-bc
新たな閲覧~文脈と文書を作成する:~HTMLds#creating-a-new-browsing-context

~navi~params:~HTMLnav#navigation-params
nvP.~navigable:~HTMLnav#navigation-params-navigable
nvP.最終-~sandbox~flag集合:~HTMLnav#navigation-params-sandboxing
nvP.~opener施策:~HTMLnav#navigation-params-coop
nvP.~COOP施行n結果:~HTMLnav#navigation-params-coop-enforcement-result
nvP.生成元:~HTMLnav#navigation-params-origin
nvP.応答:~HTMLnav#navigation-params-response
nvP.要請:~HTMLnav#navigation-params-request
nvP.予約-済み環境:~HTMLnav#navigation-params-reserved-environment
nvP.施策~容器:~HTMLnav#navigation-params-policy-container
nvP.~ID:~HTMLnav#navigation-params-id
nvP.~fetch制御器:~HTMLnav#navigation-params-fetch-controller
nvP.~navi計時~種別:~HTMLnav#navigation-params-nav-timing-type
nvP.早期~hintを~commitする:~HTMLnav#navigation-params-commit-early-hints
nvP.~about基底~URL:~HTMLnav#navigation-params-about-base-url
nvP.利用者-関与i:~HTMLnav#navigation-params-user-involvement

~scriptを走らせてもよい:~HTMLnav#scripts-may-run-for-the-newly-created-document
~source~snapshot~params:~HTMLnav#source-snapshot-params
文書を読込む:~HTMLnav#loading-a-document
~navigateする:~HTMLnav#navigate
~navigableを~URLへ~navigateする:~HTMLnav#navigate
	i.応答:~HTMLnav#navigation-response
	i.履歴~取扱い:~HTMLnav#navigation-hh
hH.replace:~HTMLnav#navigationhistorybehavior-replace
~naviに対する利用者-関与i:~HTMLnav#user-navigation-involvement
i.~browser~UI:~HTMLnav#uni-browser-ui
~navi~ID:~HTMLnav#navigation-id
~session履歴~entry:~HTMLnav#session-history-entry
shE.文書~状態:~HTMLnav#she-document-state
dS.文書:~HTMLnav#document-state-document
進行中な~navi:~HTMLnav#ongoing-navigation
進行中な~naviを設定する:~HTMLnav#set-the-ongoing-navigation
読込直す:~HTMLnav#reload
~navigableを読込直す:~HTMLnav#reload
履歴を差分だけ辿る:~HTMLnav#traverse-the-history-by-a-delta
素片へ~navigateする:~HTMLnav#navigate-fragid
dS.資源:~HTMLnav#document-state-resource
~POST資源:~HTMLnav#post-resource
doc.利用者により~scrollされたか:~HTMLnav#has-been-scrolled-by-the-user
~top-level辿可能とその子孫~用に復旧されない事由~群を築く:~HTMLnav#build-not-restored-reasons-for-a-top-level-traversable-and-its-descendants
文書を回復不能にする:~HTMLnav#make-document-unsalvageable


enV.~secureな文脈:~WAPI#secure-context
	enV.非~secureな文脈:~WAPI#non-secure-context
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
生成元が類似な~window~agentを得する:~WAPI#obtain-similar-origin-window-agent
新たな~realmを作成する:~WAPI#creating-a-new-javascript-realm
rM.大域~obj:~WAPI#concept-realm-global
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な~agent:~WAPI#relevant-agent
~task:~WAPI#concept-task
tK.文書:~WAPI#concept-task-document
~task~queue:~WAPI#task-queue
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
要素~taskを~queueする:~WAPI#queue-an-element-task
~event~loop:~WAPI#event-loop
aG.~event~loop:~WAPI#concept-agent-event-loop
~network用~task~source:~WAPI#networking-task-source
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
~naviと辿り~task~source:~WAPI#navigation-and-traversal-task-source

~iframe属性~群を処理する:~HEembed#process-the-iframe-attributes
~iframe~load~event手続き:~HEembed#iframe-load-event-steps
~link~header群を処理する:~HEmetadata#process-link-headers
共用~宣言的~refresh手続き:~HEmetadata#shared-declarative-refresh-steps
~XML構文解析器:~HTMLxml#xml-parser
可視性~状態を更新する:~HTMLinteraction#update-the-visibility-state
作動中な~timer群が成す~map:~HTMLGAPI#map-of-active-timers
作動中な構文解析器は中止されたか:~HTMLdynamic#active-parser-was-aborted
wG.所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set
doc.~worklet大域~scope~list:~WORKLETS#concept-document-worklet-global-scopes
~worklet大域~scopeを終了させる:~WORKLETS#terminate-a-worklet-global-scope

強制的に~closeする:~HTMLsse#concept-eventsource-forcibly-close
~portの連絡を断つ:~HTMLcomms#disentangle


~HTML構文解析器:~HTMLparsing#html-parser
構文解析器を中止する:~HTMLparsing#abort-a-parser
構文解析を停止した:~HTMLparsing#stop-parsing
構文解析器は~modeを変更できないか:~HTMLparsing#parser-cannot-change-the-mode-flag
入力~byte~stream:~HTMLparsing#the-input-byte-stream
~tokenizer:~HTMLparsing#tokenization
~PLAINTEXT状態:~HTMLparsing#plaintext-state
中止-:~HTMLparsing#abort-a-parser

	●用語（外部

同型に復号する:~INFRA#isomorphic-decode
~list:~INFRA#list
map.~key群:~INFRA#map-getting-the-keys
map.~clearする:~INFRA#map-clear
除去する:~INFRA#list-remove
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~ASCII小文字~化する:~INFRA#ascii-lowercase
~size:~INFRA#list-size
~HTML名前空間:~INFRA#html-namespace
~byte列:~INFRA#byte-sequence

	~Assert:~INFRA#assert
	~IN:~INFRA#list-contain
	~EACH:~INFRA#list-iterate
	~CONTINUE:~INFRA#iteration-continue
	~WHILE:~INFRA#iteration-while

新たな~obj:~WEBIDLjs#new

~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

fT.開始~時刻:~FETCH#fetch-timing-info-start-time
rq.~URL:~FETCH#concept-request-url
rq.~redirect回数:~FETCH#concept-request-redirect-count
rq.~referrer:~FETCH#concept-request-referrer
rq.現在の~URL:~FETCH#concept-request-current-url
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
rs.~sw計時~報:~FETCH#response-service-worker-timing-info
rs.本体:~FETCH#concept-response-body
rs.本体~報:~FETCH#concept-response-body-info
rs.計時~報:~FETCH#concept-response-timing-info
rs.非同一-生成元~redirectはあるか:~FETCH#response-has-cross-origin-redirects
~ABNF:~FETCH#abnf
~fetch:~FETCH#concept-fetch
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split
全部的な計時~報を抽出する:~FETCH#extract-full-timing-info
応答:~FETCH#concept-response
有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header
先送d~fetch~quotaを必要なら自由化する:~FETCH#potentially-free-deferred-fetch-quota

doc.種別:~DOM4#concept-document-type
doc.内容~型:~DOM4#concept-document-content-type
doc.生成元:~DOM4#concept-document-origin
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
doc.~mode:~DOM4#concept-document-mode
doc.宣言的な~shadow根を許容するか:~DOM4#document-allow-declarative-shadow-roots
doc.~custom要素~registry:~DOM4#document-custom-element-registry
~eventを発火する:~DOM4#concept-event-fire
要素を作成する:~DOM4#concept-create-element
~nodeを付加する:~DOM4#concept-node-append
属性~値を設定する:~DOM4#concept-element-attributes-set-value

dir.frame-ancestors:~CSP3#frame-ancestors
~CSP~list:~CSP3#csp-list
処置先:~CSP3#policy-disposition
指令~集合:~CSP3#policy-directive-set
文書~用に~CSP初期化を走らす:~CSP3#run-document-csp-initialization
応答から~navigable用の許可~施策を作成する:~PERMISSIONS-POLICY#create-from-response

~agent:~TC39#sec-agents

~sf真偽値:~STRUCTURED-FIELDS#boolean

閲覧~文脈の特能を設定しておく:~CSSOMVIEW#set-up-browsing-context-features

~navi計時~entryを作成する:~NAV-TIMING#dfn-create-the-navigation-timing-entry
算出される~MIME型:~MIMESNIFF#computed-mime-type
現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
時刻を粗化する:~HRTIME#dfn-coarsen-time
消滅させる:~WEBSOCKET#make-disappear
~WebDriver-BiDi~naviは中止された:~WEBDRIVER-BIDI#webdriver-bidi-navigation-aborted
wBDst.取消された:~WEBDRIVER-BIDI#navigation-status-canceled
新たな~WebDriver-BiDi~navi状態s:~HTMLdep#_new-webdriver-bidi-navigation-status

文脈を片付ける手続き:~WEBTRANSPORT#context-cleanup-steps

●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Document lifecycle</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — 文書の lifecycle</h1>
<p>Document lifecycle</p>

	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="document-lifecycle">
<h3 title="Document lifecycle">7.5. 文書~lifecycle</h3>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

◎表記記号

			</section>
			<section id="shared-document-creation-infrastructure">
<h4 title="Shared document creation infrastructure">7.5.1. 共用~文書~作成~基盤</h4>

<p>
この節に与える手続き（`文書を作成して初期化する$）は、
後続の各節に定義する各~algoにて，文書を読込むときに利用される。
◎
When loading a document using one of the below algorithms, we use the following steps＼
</p>

<div class="algo">
<p>
`文書を作成して初期化する@
~algoは、
所与の
( `種別$doc %種別, `内容~型$doc %内容~型, `~navi~params$ %~navi~params )
に対し：
◎
to create and initialize a Document object, given a type type, content type contentType, and navigation params navigationParams:
</p>

<p class="note">注記：
`文書$は，
`新たな閲覧~文脈と文書を作成する$ときにも作成されるが、
この~algoは，そのような`初期~about_blank な文書$を決して作成しない。
`属する閲覧~文脈$が無い`文書$は、
`document.implementation.createHTMLDocument()＠~DOM4#dom-domimplementation-createhtmldocument$c など，様々な~APIを介して作成され得る。
◎
Document objects are also created when creating a new browsing context and document; such initial about:blank Document are never created by this algorithm. Also, browsing context-less Document objects can be created via various APIs, such as document.implementation.createHTMLDocument().
</p>
<ol>
	<li>
<p>
%閲覧~文脈 ~LET `~navi応答~用に利用する閲覧~文脈を得する$( %~navi~params )
◎
Let browsingContext be the result of obtaining a browsing context to use for a navigation response given navigationParams.
</p>

<p class="note">注記：
これは、
`閲覧~文脈~groupを切替える＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy$こともある
— その事例では、
%閲覧~文脈 は，［
%~navi~params の`~navigable$nvPにて`作動中な閲覧~文脈$navではなく，
`新たに作成され＠~HTMLds#creating-a-new-browsing-context$た`閲覧~文脈$
］になる。
そのような事例では、
作成された［
`~window$, `文書$, `~agent$
］は利用されなくなる
— 作成された`文書$の`生成元$docは`不透明な生成元$なので、
`この~algoの後の段＠#create-new-agent-and-window$で，
新たな`文書$と同行する新たな［
`~agent$, `~window$
］を作成する結果になる。
◎
This can result in a browsing context group switch, in which case browsingContext will be a newly-created browsing context instead of being navigationParams's navigable's active browsing context. In such a case, the created Window, Document, and agent will not end up being used; because the created Document's origin is opaque, we will end up creating a new agent and Window later in this algorithm to go along with the new Document.
</p>
	</li>
	<li>
<p>
%許可~施策 ~LET
`応答から~navigable用の許可~施策を作成する$( ↓ ) `PERMISSIONSPOLICY$r
⇒＃
%~navi~params の`~navigable$nvPの`容器$nav,
%~navi~params の`生成元$nvP,
%~navi~params の`応答$nvP
◎
Let permissionsPolicy be the result of creating a permissions policy from a response given navigationParams's navigable's container, navigationParams's origin, and navigationParams's response. [PERMISSIONSPOLICY]
</p>

<div class="note">
<p>注記：
ここで`応答から~navigable用の許可~施策を作成する$ときは、
渡された`生成元$を用立てる。
%~navi~params の`~navigable$nvPの`容器~文書$navに対し `document.domain$c が利用されていた場合、
【以下で作成される文書】
%文書 の`生成元$docと渡された生成元は，`同じ生成元~domain$にはなり得ない
— この手続きは %文書 が作成される前に走るので、
この時点では，まだ %文書 の `document.domain$c は利用し得ないので。
したがって，許可~施策の検査は、
`同一-生成元$かどうか検査するよりも~~寛容でない。
◎
The creating a permissions policy from a response algorithm makes use of the passed origin. If document.domain has been used for navigationParams's navigable's container document, then its origin cannot be same origin-domain with the passed origin, because these steps run before the document is created, so it cannot itself yet have used document.domain. Note that this means that Permissions Policy checks are less permissive compared to doing a same origin check instead.
</p>

<p>
これの動作~例は、
下を見よ。
◎
See below for some examples of this in action.
</p>
</div>

	</li>
	<li>
%作成時の~URL ~LET %~navi~params の`応答$nvPの`~URL$rs
◎
Let creationURL be navigationParams's response's URL.
</li>
	<li>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］
⇒
%作成時の~URL ~SET %~navi~params の`要請$nvPの`現在の~URL$rq
◎
If navigationParams's request is non-null, then set creationURL to navigationParams's request's current URL.
</li>
	<li>
%~window ~LET ~NULL
◎
Let window be null.
</li>
	<li>
<p>
~IF［
%閲覧~文脈 にて`作動中な文書$bcの`初期~about_blankか$doc ~EQ ~T
］~AND［
( %閲覧~文脈 にて`作動中な文書$bcの`生成元$doc, %~navi~params の`生成元$nvP )
は`同じ生成元~domain$である
］
⇒
%~window ~SET %閲覧~文脈 にて`作動中な~window$bc
◎
If browsingContext's active document's is initial about:blank is true, and browsingContext's active document's origin is same origin-domain with navigationParams's origin, then set window to browsingContext's active window.
</p>

<p class="note">注記：
この場合、
これから作成する新たな`文書$と`初期~about_blank な文書$は，
同じ`~window$を共有することになる。
◎
This means that both the initial about:blank Document, and the new Document that is about to be created, will share the same Window object.
</p>
	</li>
	<li>
<p id="create-new-agent-and-window">
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%生成元~agent~cluster~header ~LET %~navi~params の`応答$nvPの`~header~list$rsから`有構造~field値を取得する$( `Origin-Agent-Cluster$h, `~item^i )
◎
Let oacHeader be the result of getting a structured field value given `Origin-Agent-Cluster` and "item" from navigationParams's response's header list.
</li>
			<li>
<p>
%生成元~agent~clusterを要請するか ~LET ~IS ~AND↓：
</p>
				<ul>
					<li>
%生成元~agent~cluster~header ~NEQ ~NULL
</li>
					<li>
%生成元~agent~cluster~header[ 0 ] ~EQ `~sf真偽値$ ~T
</li>
					<li>
%~navi~params の`予約-済み環境$nvPは`~secureな文脈$enVである
</li>
				</ul>
◎
Let requestsOAC be true if oacHeader is not null and oacHeader[0] is the boolean true; otherwise false.
◎
If navigationParams's reserved environment is a non-secure context, then set requestsOAC to false.
</li>
			<li>
%~agent ~LET `生成元が類似な~window~agentを得する$( ↓ )
⇒＃
%~navi~params の`生成元$nvP,
%閲覧~文脈 の`~group$tbcG,
%生成元~agent~clusterを要請するか
◎
Let agent be the result of obtaining a similar-origin window agent given navigationParams's origin, browsingContext's group, and requestsOAC.
</li>
			<li>
%~realm実行~文脈 ~LET %~agent 内で`新たな~realmを作成する$
— 次に従って~custom化する下で
⇒＃
大域~obj用に新たな`~window$を作成する,
大域 `this^jv 束縛には %閲覧~文脈 の `WindowProxy$I ~objを利用する
◎
Let realmExecutionContext be the result of creating a new realm given agent and the following customizations:
• For the global object, create a new Window object.
• For the global this binding, use browsingContext's WindowProxy object.
</li>
			<li>
%~window ~SET %~realm実行~文脈 の~Realm成分を成す`大域~obj$rM
【すなわち，前~段で作成した~window】
◎
Set window to the global object of realmExecutionContext's Realm component.
</li>
			<li>
%~top-level作成時の~URL ~LET %作成時の~URL
◎
Let topLevelCreationURL be creationURL.
</li>
			<li>
%~top-level生成元 ~LET %~navi~params の`生成元$nvP
◎
Let topLevelOrigin be navigationParams's origin.
</li>
			<li>
%~navigable ~LET %~navi~params の`~navigable$nvP
【この段は、この訳による補完。】
</li>
			<li>
<p>
~IF［
%~navigable の`容器$nav ~NEQ ~NULL
］：
◎
If navigable's container is not null, then:
</p>
				<ol>
					<li>
%親~環境 ~LET %~navigable の`容器$navに`関連な設定群~obj$
◎
Let parentEnvironment be navigable's container's relevant settings object.
</li>
					<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL.
</li>
					<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
Set topLevelOrigin to parentEnvironment's top-level origin.
</li>
				</ol>
			</li>
			<li>
`~window用に環境~設定群~objを設定しておく$( ↓ )
⇒＃
%作成時の~URL,
%~realm実行~文脈,
%~navi~params の`予約-済み環境$nvP,
%~top-level作成時の~URL,
%~top-level生成元
◎
Set up a window environment settings object with creationURL, realmExecutionContext, navigationParams's reserved environment, topLevelCreationURL, and topLevelOrigin.
</li>
		</ol>

<p class="note">注記：
これが通例的な事例であり、
これから作成する新たな`文書$は，それに同行する新たな`~window$を取得する。
◎
This is the usual case, where the new Document we're about to create gets a new Window to go along with it.
</p>
	</li>
	<li>
%~load計時~報 ~LET 新たな`文書~load計時~報$
— その
⇒
`~navi開始~時刻$ ~SET %~navi~params の`応答$nvPの`計時~報$rsの`開始~時刻$fT
◎
Let loadTimingInfo be a new document load timing info with its navigation start time set to navigationParams's response's timing info's start time.
</li>
	<li>
%文書 ~LET `新たな~obj$( `Document$I 【, %~realm実行~文脈 の Realm 成分】 )
◎
Let document be a new Document, with
</li>
	<li>
%文書 の
⇒＃
`種別$doc ~SET %種別,
`内容~型$doc ~SET %内容~型,
`生成元$doc ~SET %~navi~params の`生成元$nvP,
`属する閲覧~文脈$ ~SET %閲覧~文脈,
`施策~容器$doc ~SET %~navi~params の`施策~容器$nvP,
`許可~施策$doc ~SET %許可~施策,
`作動中な~sandbox法~flag集合$ ~SET %~navi~params の`最終-~sandbox~flag集合$nvP,
`~opener施策$doc ~SET %~navi~params の【！cross-origin】`~opener施策$nvP,
`~load計時~報$doc ~SET %~load計時~報,
`非同一-生成元~redirectを介して作成されたか$doc ~SET %~navi~params の`応答$nvPの`非同一-生成元~redirectはあるか$rs,
`読込ng中における~WebDriver-BiDi用の~navi~ID$doc ~SET %~navi~params の`~ID$nvP,
`~URL$doc ~SET %作成時の~URL,
`現在の準備度$doc ~SET `loading^l,
`~about基底~URL$doc ~SET %~navi~params の`~about基底~URL$nvP,
`宣言的な~shadow根を許容するか$doc ~SET ~T,
`~custom要素~registry$doc ~SET `新たな~obj$( `CustomElementRegistry$I 【, %~realm実行~文脈 の Realm 成分】 )
◎
type
• type
content type
• contentType
origin
• navigationParams's origin
browsing context
• browsingContext 
policy container
• navigationParams's policy container
permissions policy
• permissionsPolicy
active sandboxing flag set
• navigationParams's final sandboxing flag set
opener policy
• navigationParams's cross-origin opener policy
load timing info
• loadTimingInfo
was created via cross-origin redirects
• navigationParams's response's has cross-origin redirects
during-loading navigation ID for WebDriver BiDi
• navigationParams's id
URL
• creationURL
current document readiness
• "loading"
about base URL
• navigationParams's about base URL
allow declarative shadow roots
• true
custom element registry
• a new CustomElementRegistry object
</li>
	<li>
%~window に`結付けられた文書$ ~SET %文書
◎
Set window's associated Document to document.
</li>
	<li>
`文書~用に~CSP初期化を走らす$( %文書 )
`CSP$r
◎
Run CSP initialization for a Document given document. [CSP]
</li>
	<li>
<p>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］：
◎
If navigationParams's request is non-null, then:
</p>
		<ol>
			<li>
%文書 の`~referrer$doc ~SET 空~文字列
◎
Set document's referrer to the empty string.
</li>
			<li>
%~referrer ~LET %~navi~params の`要請$nvPの`~referrer$rq
◎
Let referrer be navigationParams's request's referrer.
</li>
			<li>
<p>
~IF［
%~referrer は`~URL~record$である
］
⇒
%文書 の`~referrer$doc ~SET `~URLを直列化する$( %~referrer )
◎
If referrer is a URL record, then set document's referrer to the serialization of referrer.
</p>

<p class="note">注記：
`FETCH$r により、
%~referrer は，この時点で［
`~URL~record$／ `no-referrer^l
］になる。
◎
Per Fetch, referrer will be either a URL record or "no-referrer" at this point.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~navi~params の`~fetch制御器$nvP ~NEQ ~NULL
］：
◎
If navigationParams's fetch controller is not null, then:
</p>
		<ol>
			<li>
%全部的な計時~報 ~LET `全部的な計時~報を抽出する$( %~navi~params の`~fetch制御器$nvP )
◎
Let fullTimingInfo be the result of extracting the full timing info from navigationParams's fetch controller.
</li>
			<li>
%~redirect回数 ~LET %~navi~params の`応答$nvPの`非同一-生成元~redirectはあるか$rsに応じて
⇒＃
~T ならば 0 ／
~F ならば %~navi~params の`要請$nvPの`~redirect回数$rq
◎
Let redirectCount be 0 if navigationParams's response's has cross-origin redirects is true; otherwise navigationParams's request's redirect count.
</li>
			<li>
`~navi計時~entryを作成する$( ↓ )
⇒＃
%文書,
%全部的な計時~報
%~redirect回数,
%navigationTimingType【未定義な変数： %~navi~params の`~navi計時~種別$nvP？】,
%~navi~params の`応答$nvPの`~sw計時~報$rs,
【ここに必要な引数が無い】,
%~navi~params の`応答$nvPの`本体~報$rs
◎
Create the navigation timing entry for document, given fullTimingInfo, redirectCount, navigationTimingType, navigationParams's response's service worker timing info, and navigationParams's response's body info.
</li>
		</ol>
	</li>
	<li>
`~navi計時~entryを作成する$( ↓ )
⇒＃
%文書,
%~navi~params の`応答$nvPの`計時~報$rs,
%~redirect回数,
%~navi~params の`~navi計時~種別$nvP,
%~navi~params の`応答$nvPの`~sw計時~報$rs,
【引数が足らない】
◎
Create the navigation timing entry for document, with navigationParams's response's timing info, redirectCount, navigationParams's navigation timing type, and navigationParams's response's service worker timing info.
</li>
	<li>
<p>
~IF［
%~navi~params の`応答$nvPには `Refresh$h ~headerは在る
］：
◎
If navigationParams's response has a `Refresh` header, then:
</p>
		<ol>
			<li>
%値 ~LET `同型に復号する$( `Refresh^h の値 )
◎
Let value be the isomorphic decoding of the value of the header.
</li>
			<li>
`共用~宣言的~refresh手続き$( %文書, %値 )
◎
Run the shared declarative refresh steps with document and value.
</li>
		</ol>

<p class="XXX">
`Refresh$h ~headerが複数あるときの取扱いは、
現時点では，まだ指定されてない。
これは、
`課題 #2900＠~HTMLissue/2900$
にて追跡されている。
◎
We do not currently have a spec for how to handle multiple `Refresh` headers. This is tracked as issue #2900.
</p>
	</li>
	<li>
%早期~hintを~commitする ~LET %~navi~params の`早期~hintを~commitする$nvP
◎
↓</li>
	<li>
~IF［
%早期~hintを~commitする ~NEQ ~NULL
］
⇒
%早期~hintを~commitする( %文書 )
◎
If navigationParams's commit early hints is not null, then call navigationParams's commit early hints with document.
</li>
	<li>
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `pre-media^l )
◎
Process link headers given document, navigationParams's response, and "pre-media".
</li>
	<li>
`先送d~fetch~quotaを必要なら自由化する$( %文書 )
◎
Potentially free deferred fetch quota for document.
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="example">
<p>
次の例では、
子~文書（ `b.html^c ）には `PaymentRequest$I の利用は許容されない
— 子~文書が それを利用するよう試行した時点では，`同じ生成元~domain$であっても。
子~文書が初期化された時点では、
`document.domain$c は 親~文書にのみ設定されていて，子~文書にはまだ設定されてない。
◎
In this example, the child document is not allowed to use PaymentRequest, despite being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, only the parent document has set document.domain, and the child document has not.
</p>

<pre class="lang-html">&lt;!-- https://foo.example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
document.domain = 'example.com';
&lt;/script&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
</pre>

<pre class="lang-html">&lt;!-- https://bar.example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
document.domain = 'example.com'; /* <span class="comment">
これは、
文書が初期化された後に起こる。
◎
This happens after the document is initialized
</span> */
new PaymentRequest(…); /* <span class="comment">
利用は許容されない
◎
Not allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="example">
<p>
次の例では、
子~文書には `PaymentRequest$I の利用は<em>許容される</em>
— 子~文書が それを利用するよう試行した時点では，`同じ生成元~domain$でなくとも。
子~文書が初期化される時点では，どちらの文書にも まだ `document.domain$c は設定されていないので、
`同じ生成元~domain$の検査は，通常の`同一-生成元$の検査に~fall-backする。
◎
In this example, the child document is allowed to use PaymentRequest, despite not being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, none of the documents have set document.domain yet so same origin-domain falls back to a normal same origin check.
</p>

<pre class="lang-html">&lt;!-- https://example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
子~文書は、
下の~scriptが走る前の，この時点で初期化-済み。
◎
The child document is now initialized, before the script below is run.
</span> --&gt;
&lt;script&gt;
document.domain = 'example.com';
&lt;/script&gt;
</pre>

<pre class="lang-html">&lt;!-- https://example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
new PaymentRequest(…); /* <span class="comment">
利用は許容される
◎
Allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="algo">
<p>
`文書を~html-head-bodyで拡充する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To populate with html/head/body given a Document document:
</p>
<ol>
	<li>
%html ~LET `要素を作成する$( %文書, `html^l, `~HTML名前空間$ )
◎
Let html be the result of creating an element given document, "html", and the HTML namespace.
</li>
	<li>
%head ~LET `要素を作成する$( %文書, `head^l, `~HTML名前空間$ )
◎
Let head be the result of creating an element given document, "head", and the HTML namespace.
</li>
	<li>
%body ~LET `要素を作成する$( %文書, `body^l, `~HTML名前空間$ )
◎
Let body be the result of creating an element given document, "body", and the HTML namespace.
</li>
	<li>
%文書 に`~nodeを付加する$( %html )
◎
Append html to document.
</li>
	<li>
%html に`~nodeを付加する$( %head )
◎
Append head to html.
</li>
	<li>
%html に`~nodeを付加する$( %body )
◎
Append body to html.
</li>
	<li>
~RET ( %html, %head, %body )
【この段は、この訳による追加。】
</li>
</ol>
</div>

			</section>
			<section id="read-html">
<h4 title="Loading HTML documents">7.5.2. ~HTML文書の読込n法</h4>

<div class="algo">
<p>
`~HTML文書を読込む@
~algoは、
所与の
( `~navi~params$ %~navi~params )
に対し：
◎
To load an HTML document, given navigation params navigationParams:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
~IF［
%文書 の`~URL$doc ~EQ `~about_blank$sc
］
⇒
`文書を~html-head-bodyで拡充する$( %文書 )
◎
If document's URL is about:blank, then populate with html/head/body given document.
</p>

<p class="note">注記：
この特別な事例では、
%文書 が`初期~about_blank な文書$でない場合でも，
要素~nodeが同期的に与えられる
— これは、
配備-済みな内容と互換にするために必要yである。
言い換えれば、
次の段 ~ELSE 以下の分岐へ入って［
%文書 を非同期的に拡充するよう，`~HTML構文解析器$の中へ空な`~byte列$を投入する
］こととは互換でない。
◎
This special case, where even non-initial about:blank Documents are synchronously given their element nodes, is necessary for compatible with deployed content. In other words, it is not compatible to instead go down the "otherwise" branch and feed the empty byte sequence into an HTML parser to asynchronously populate document.
</p>
	</li>
	<li>
<p>
~ELSE
⇒
新たな`~HTML構文解析器$ %構文解析器 を作成して %文書 に結付ける
— ~UAは、
以下に挙げる各項に従うモノトスル：
◎
Otherwise, create an HTML parser and associate it with the document.＼
</p>
		<ul>
			<li>
~fetchingを走らせている間に`~network用~task~source$から`~task~queue$に設置される各`~task$には、
%構文解析器 への`入力~byte~stream$を~fetchされた~byte列で埋めた上で，
入力~streamの適切な処理を %構文解析器 に遂行させる。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</li>
			<li>
前項の`~task$のうち，最初に設置されたものは、
%構文解析器 により処理された後に，次を走らす
⇒
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the HTML parser.
</li>
			<li>
<p>
%文書 用に`~scriptを走らせてもよい$とされる時点まで，~script実行は生じさせない。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for document.
</p>

<p class="note">注記：
`入力~byte~stream$に渡された~byte列は、文字~並びに変換されて`~tokenizer$に渡される。
この処理nの一部は、
資源の~~真の `~Content-Type~metadata$から見出される文字~符号化法~情報に依拠する
— 資源から`算出される~MIME型$は、
その目的には利用されない。
◎
The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.
</p>
			</li>
			<li>
<p>
可用な~byte列が尽きたときは、
次を遂行する
⇒
`大域~taskを~queueする$( `~network用~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given document's relevant global object to＼
</p>

<div class="algo">
手続きは
⇒
構文解析器に暗黙な~EOF文字を処理させる
（これは、最終的に `load$et ~eventを発火させることになる）
◎
have the parser process the implied EOF character, which eventually causes a load event to be fired.
</div>
			</li>
		</ul>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

			</section>
			<section id="read-xml">
<h4 title="Loading XML documents">7.5.3. ~XML文書の読込n法</h4>

<div class="algo">
<p>
~UAは，~XML~fileを~inlineに表示することになった場合には、
供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，
次に挙げる各~仕様
⇒＃
`XML$r,
`XMLNS$r,
`RFC7303$r,
`DOM$r,
関連な他の仕様
◎終
に定義される要件に従う下で，次を行うモノトスル：
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `xml^l, %~MIME型, %~navi~params )
</li>
	<li>
対応する`~XML構文解析器$を作成する
</li>
	<li>
~RET %文書
</li>
</ol>
◎
When faced with displaying an XML file inline, provided navigation params navigationParams and a string type, user agents must follow the requirements defined in XML and Namespaces in XML, XML Media Types, DOM, and other relevant specifications to create and initialize a Document object document, given "xml", type, and navigationParams, and return that Document. They must also create a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]
</div>

<p class="note">注記：
これを書いている時点では，~XML仕様~communityは、
実際には，~XMLと~DOMとがどう相互作用するか まだ指定していない。
◎
At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.
</p>

<p>
~UAは、
作成した`文書$ %文書 に対し，以下に挙げる各項に従うモノトスル：
◎
↓</p>
<ul>
	<li>
~fetchingを走らす間に［
`~network用~task~source$から`~task~queue$に対し設置された最初の`~task$
］は、
`~XML構文解析器$により処理された後に，次を走らす
⇒
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the XML parser.
</li>
	<li>
［
上に挙げた各 仕様の規則に則って，文字~符号化法を決定する
］ときには、［
実際の~HTTP~headerや他の~metadata
］のうち［
この仕様が与える~algoにより［
変異される／含意される
］~header
］でないものを利用した上で、
%文書 の`符号化法$docは，そのように確立された符号化法に設定する。
◎
The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.
</li>
	<li>
%文書 用に`~scriptを走らせてもよい$とされる時点まで，~script実行は生じさせない。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for the newly-created Document.
</li>
	<li>
<p>
構文解析が完了したなら、
%文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$docを ~NULL に設定する。
◎
Once parsing is complete, the user agent must set document's during-loading navigation ID for WebDriver BiDi to null.
</p>

<p class="note">注記：
~HTML文書に対しては，これは、
構文解析を完了したとき `load^et ~eventを発火した後に設定し直される
◎
For HTML documents this is reset when parsing is complete, after firing the load event.
</p>
	</li>
</ul>

<p>
~UAは、
構文解析-時の~error（例： ~XML名前空間 整形式性~error）に際しては，
当の`文書$を変異して~inlineに報告してもヨイ。
◎
Error messages from the parse process (e.g., XML namespace well-formedness errors) may be reported inline by mutating the Document.
</p>

			</section>
			<section id="read-text">
<h4 title="Loading text documents">7.5.4. ~text文書の読込n法</h4>

<div class="algo">
<p>
`~text文書を読込む@
~algoは、
所与の
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し：
◎
To load a text document, given a navigation params navigationParams and a string type:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
%文書 の`構文解析器は~modeを変更できないか$ ~SET ~T
◎
Set document's parser cannot change the mode flag to true.
</li>
	<li>
%文書 の`~mode$doc ~SET `no-quirks^l
◎
Set document's mode to "no-quirks".
</li>
	<li>
<p>
新たな`~HTML構文解析器$を作成して %文書 に結付ける
— ~UAは、
以下に挙げる各項に従うモノトスル：
◎
Create an HTML parser and associate it with the document.＼
</p>
		<ul>
			<li>
この構文解析器は、
その~tokenizerが すでに次を順に行ったかのように動作する
⇒＃
~tag名 `pre^l の開始~tag~tokenを発した；
1 個の文字 <span class="code-point">U+000A</span> （LF）を発した；
`~PLAINTEXT状態$に切替えた
◎
Act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state.＼
</li>
			<li>
~fetchingを走らせている間に`~network用~task~source$から`~task~queue$に設置される各`~task$は、
構文解析器の`入力~byte~stream$を~fetchされた~byte列で埋めて，構文解析器に入力~streamの適切な処理を遂行させる。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</li>
			<li>
%文書 の`符号化法$docは、
当の文書を復号する間に利用した文字~符号化法に設定する。
◎
document's encoding must be set to the character encoding used to decode the document during parsing.
</li>
			<li>
前述の`~task$のうち，最初に設置されたものは、
%構文解析器 により処理された後に，次を走らす
⇒
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the HTML parser.
</li>
			<li>
%文書 用に`~scriptを走らせてもよい$とされる時点まで，~script実行は生じさせない。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for document.
</li>
			<li>
<p>
可用な~byte列が尽きたときは、
次を遂行する
⇒
`大域~taskを~queueする$( `~network用~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given document's relevant global object to＼
</p>

<div class="algo">
手続きは
⇒
構文解析器に暗黙な~EOF文字を処理させる
（これは、最終的に `load$et ~eventを発火させることになる）
◎
have the parser process the implied EOF character, which eventually causes a load event to be fired.
</div>
			</li>
		</ul>
	</li>
	<li>
<p>
任意選択で
⇒
%文書 の `head$e 要素に内容を追加する
— 例：
~stylesheetへ~linkする／
~scriptを供する／
文書に `title$e を与える／
等々。
◎
User agents may add content to the head element of document, e.g., linking to a style sheet, providing script, or giving the document a title.
</p>

<p class="note">注記：
特に、
 RFC 3676 の `Format=Flowed^c 特能を~supportする~UAは、［
~textを正しく折返す／
【行頭の "&gt;" による】 引用用の特能を取扱う
］ために，何らかの~styleを適用する必要が生じることになる。
これは、
例えば~CSS拡張を利用して遂行することもできる。
◎
In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<p>
素な~text文書の~byte列を
実際の文字に変換する規則，および
その~textを利用者~向けに実際に具現化する規則は、
当の資源から`算出される~MIME型$（すなわち， %~MIME型 ）の仕様により定義される。
◎
The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (i.e., type).
</p>

			</section>
			<section id="read-multipart-x-mixed-replace">
<h4 title="Loading multipart/x-mixed-replace documents">7.5.5. `multipart/x-mixed-replace$mt 文書の読込n法</h4>

<div class="algo">
<p>
`multipart/x-mixed-replace 文書を読込む@
~algoは、
所与の
⇒＃
`~navi~params$ %~navi~params,
`~source~snapshot~params$ %~source~snapshot~params,
`生成元$ %起動元~生成元
◎終
に対し：
◎
To load a multipart/x-mixed-replace document, given navigation params navigationParams, source snapshot params sourceSnapshotParams, and origin initiatorOrigin:
</p>
<ol>
	<li>
%~navi~params の`応答$nvPの`本体$rsを
`RFC2046$r による複-部位t（ `multipart^c ）型~用の規則を利用して構文解析する
◎
Parse navigationParams's response's body using the rules for multipart types. [RFC2046]
</li>
	<li>
%最初の部位t用の~navi~params ~LET %~navi~params の複製
◎
Let firstPartNavigationParams be a copy of navigationParams.
</li>
	<li>
%最初の部位t用の~navi~params の`応答$nvP ~SET 
%~navi~params の`応答$nvPの`本体$rsの複-部位t~streamを成す最初の部位tを表現している新たな`応答$
◎
Set firstPartNavigationParams's response to a new response representing the first part of navigationParams's response's body's multipart stream.
</li>
	<li>
<p>
%文書 ~LET `文書を読込む$( %最初の部位t用の~navi~params, %~source~snapshot~params,
%起動元~生成元 )
◎
Let document be the result of loading a document given firstPartNavigationParams, sourceSnapshotParams, and initiatorOrigin.
</p>

<p>
%~navi~params の`応答$nvPから得された 2 個目以降の各 本体~部位tに対しては、
~UAは，次を行うモノトスル
⇒
`~navigableを~URLへ~navigateする$( %文書 の`~node~navigable$, %~navi~params の`要請$nvPの`~URL$rq, %文書 )
— 次を与える下で
⇒＃
`応答^i ~SET %~navi~params の`応答$nvP,
`履歴~取扱い^i ~SET `replace$hH
◎
For each additional body part obtained from navigationParams's response, the user agent must navigate document's node navigable to navigationParams's request's URL, using document, with response set to navigationParams's response and historyHandling set to "replace".
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<p>
~UAは、
これらの［
各 本体~部位tを完全に自立的な資源であったかのように処理する目的
］においては、
各 本体~部位tに対し［
それに後続する境界に達した所で，当の資源~用の~byte列は尽きた
］かのように動作するモノトスル。
◎
For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.
</p>

<p class="note">注記：
したがって， `load$et ~event（および，対になる `unload$et ~event）は、
各 本体~部位tが読込まれる度に発火されることになる。
◎
Thus, load events (and for that matter unload events) do fire for each body part loaded.
</p>

			</section>
			<section id="read-media">
<h4 title="Loading media documents">7.5.6. ~media文書の読込n法</h4>

<div class="algo">
<p>
`~media文書を読込む@
~algoは、
所与の
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し：
◎
To load a media document, given navigationParams and a string type:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
%文書 の`~mode$doc ~SET `no-quirks^l
◎
Set document's mode to "no-quirks".
</li>
	<li>
( %html, %head, %body ) ~LET `文書を~html-head-bodyで拡充する$( %文書 )
◎
Populate with html/head/body given document.
</li>
	<li>
%要素~型 ~LET 【 %~MIME型 から導出される】当の資源の~media型に応じて
⇒＃
画像ならば `img$e ／
動画ならば `video$e ／
音声ならば `audio$e
◎
↓</li>
	<li>
%~host要素 ~LET `要素を作成する$( %文書, %要素~型, `~HTML名前空間$ )
◎
↓</li>
	<li>
%body に`~nodeを付加する$( %要素 )
◎
Append an element host element for the media,＼
↓↓as described below, to the body element.
</li>
	<li>
<p>
%~host要素 の`属性~値を設定する$( `src^l, 当の資源の~address )
</p>

<p>
（これは、［
画像の場合は `img$e の `src＠~HEimages#attr-img-src$a ／
［
動画／音声
］の場合は［
`video$e ／ `audio$e
］の `src＠~HEmedia#attr-media-src$a
］を設定する。）
</p>
◎
Set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.
◎
↓↓</li>
	<li>
<p>
任意選択で
⇒＃
%head に内容を追加する／
%~host要素 に属性を追加する
◎
User agents may add content to the head element of document, or attributes to host element,＼
</p>

<p>
例
⇒＃
ある~stylesheetへ~linkする
ある~scriptを供する／
当の文書に `title$e を与える／
当の~mediaを `autoplay$a にする
◎
e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.
</p>
	</li>
	<li>
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
Process link headers given document, navigationParams's response, and "media".
</li>
	<li>
%文書 の`構文解析を停止した$かのように動作する
◎
Act as if the user agent had stopped parsing document.
</li>
	<li>
~RET %文書
◎
Return document.
◎
↑↑ The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.
◎
↑↑ Type of media｜Element for the media｜Appropriate attribute
Image｜img｜src
Video｜video｜src
Audio｜audio｜src
</li>
</ol>
</div>

<p>
~UAは、
`文書$用に`~scriptを走らせてもよい$とされる時点まで，
~script実行は生じさせないモノトスル。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for the Document.
</p>

			</section>
			<section id="read-ua-inline">
<h4 title="Loading a document for inline content that doesn't have a DOM">7.5.7. ~DOMを有さない~inline内容~用の文書の読込n法</h4>

<div class="algo">
<p>
~UAは，［
~UA~page／~PDF~viewer
］を~inlineに表示するための文書を作成するときは、
供された
⇒＃
`~navigable$ %~navigable,
`~navi~ID$ %~navi~ID,
`NavigationTimingType$I %~navi計時~種別,
`~naviに対する利用者-関与i$ %利用者-関与i
◎終
に対し，次に従うベキである：
◎
When the user agent is to create a document to display a user agent page or PDF viewer inline, provided a navigable navigable, a navigation ID navigationId, a NavigationTimingType navTimingType, and a user navigation involvement userInvolvement, the user agent should:
</p>
<ol>
	<li>
%生成元 ~LET 新たな`不透明な生成元$
◎
Let origin be a new opaque origin.
</li>
	<li>
%~COOP ~LET 新たな`~opener施策$
◎
Let coop be a new opener policy.
</li>
	<li>
%~COOP施行n結果 ~LET 新たな`~opener施策の施行n結果$
— その
⇒＃
`~URL$cooP ~SET %応答 の`~URL$rs,
`生成元$cooP ~SET %生成元,
`~opener施策$cooP ~SET %~COOP
◎
Let coopEnforcementResult be a new opener policy enforcement result with
◎
url
• response's URL
origin
• origin
opener policy
• coop
</li>
	<li>
%~navi~params ~LET 新たな`~navi~params$
— その
⇒＃
`~ID$nvP ~SET %~navi~ID,
`~navigable$nvP ~SET %~navigable,
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET 新たな`応答$,
`生成元$nvP ~SET %生成元,
`~fetch制御器$nvP ~SET ~NULL,
`早期~hintを~commitする$nvP ~SET ~NULL,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`施策~容器$nvP ~SET 新たな`施策~容器$,
`最終-~sandbox~flag集合$nvP ~SET 空な集合,
`~opener施策$nvP ~SET %COOP,
`~navi計時~種別$nvP ~SET %~navi計時~種別,
`~about基底~URL$nvP ~SET ~NULL,
`利用者-関与i$nvP ~SET %利用者-関与i
◎
Let navigationParams be a new navigation params with
◎
id
• navigationId
navigable
• navigable
request
• null
response
• a new response
origin
• origin
fetch controller
• null
commit early hints
• null
COOP enforcement result
• coopEnforcementResult
reserved environment
• null
policy container
• a new policy container
final sandboxing flag set
• an empty set
opener policy
• coop
navigation timing type
• navTimingType
about base URL
• null
user involvement
• userInvolvement
</li>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
次のいずれかを行う：
◎
Either＼
</p>
		<ul>
			<li>
%文書 に~customな
— `文書$の通常の具現化~規則を利用しない —
具現化を結付ける
◎
associate document with a custom rendering that is not rendered using the normal Document rendering rules, or＼
</li>
			<li>
%文書 を［
~UAが具現化するよう求める内容
］を表現するよう変異させる
◎
mutate document until it represents the content the user agent wants to render.
</li>
		</ul>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>

<p class="note">注記：
結果の`文書$は、
その`生成元$docは`不透明な生成元$になるよう確保され，
~DOMへの~accessを伴う~scriptを走らすことはないので、
この文書の存在, その~propは，~web開発者~codeからは観測-可能にならない。
このことは、
上の値のうち ほとんど
— 例： `種別$doc `text/html$mt —
は問われないことを意味する。
類似に，
%~navi~params を成す ほとんどの~itemは、
~~形式上のものでしかなく，観測-可能な効果を伴うことはない
— なので、
既定の値に設定される。
◎
Because we ensure the resulting Document's origin is opaque, and the resulting Document cannot run script with access to the DOM, the existence and properties of this Document are not observable to web developer code. This means that most of the above values, e.g., the text/html type, do not matter. Similarly, most of the items in navigationParams don't have any observable effect, besides preventing the Document-creation algorithm from getting confused, and so are set to default values.
</p>
</div>

<p>
~UAは、
~pageが設定しておかれたなら，`構文解析を停止した$かのように動作するモノトスル。
◎
Once the page has been set up, the user agent must act as if it had stopped parsing.
</p>

			</section>
			<section id="loading-documents">
<h4 title="Finishing the loading process">7.5.8. 読込ng処理nの完遂-法</h4>

<p>
各 `文書$には
`完全に読込まれた時刻@
（ある時刻または ~NULL ）がある
— 初期~時は ~NULL とする。
◎
A Document has a completely loaded time (a time or null), which is initially null.
</p>

<p>
所与の`文書$は、
その`完全に読込まれた時刻$ ~NEQ ~NULL ならば，
`完全に読込まれた@
ものと見なされる。
◎
A Document is considered completely loaded if its completely loaded time is non-null.
</p>

<div class="algo">
<p>
`文書$ %文書 の
`読込ngを完全に終わらす@
~algoは：
◎
To completely finish loading a Document document:
</p>
<ol>
	<li>
~Assert：
%文書 が`属する閲覧~文脈$ ~NEQ ~NULL
◎
Assert: document's browsing context is non-null.
</li>
	<li>
%文書 の`完全に読込まれた時刻$ ~SET 現在の時刻
◎
Set document's completely loaded time to the current time.
</li>
	<li>
<p>
%容器 ~LET %文書 の`~node~navigable$の`容器$nav
◎
Let container be document's node navigable's container.
</p>

<div class="note">
<p>注記：
これは、
%文書 が［
`iframe$e ／ `frame$e
］内の`初期~about_blank な文書$である事例では， ~NULL になる
— この~algoを~callする`新たな閲覧~文脈と文書を作成する$時点では、
当の容器~関係性は，まだ確立されていないので
（それが起こる段は、
`新たな子~navigableを作成する$ときである）。
◎
This will be null in the case where document is the initial about:blank Document in a frame or iframe, since at the point of browsing context creation which calls this algorithm, the container relationship has not yet been established. (That happens in a subsequent step of create a new child navigable.)
</p>

<p>
その帰結として、
以降の手続きは，何もしなくなる
— すなわち，そのような事例では、
`load$et ~eventは， %容器 に向けて非同期的には発火されなくなる。
代わりに，その~eventは、
`~iframe属性~群を処理する$ときに，ある特別な初期~挿入~事例において同期的に発火される。
◎
The consequence of this is that the following steps do nothing, i.e., we do not fire an asynchronous load event on the container element for such cases. Instead, a synchronous load event is fired in a special initial-insertion case when processing the iframe attributes.
</p>
</div>
	</li>
	<li>
<p>
~IF［
%容器 は `iframe$e 要素である
］
⇒
`要素~taskを~queueする$( `~DOM操作~task~source$, %容器, 次の手続き )
</p>

<div class="algo">
手続きは
⇒
`~iframe~load~event手続き$( %容器 )
</div>
◎
If container is an iframe element, then queue an element task on the DOM manipulation task source given container to run the iframe load event steps given container.
</li>
	<li>
<p>
~ELIF［
%容器 ~NEQ ~NULL
］
⇒
`要素~taskを~queueする$( `~DOM操作~task~source$, %容器, 次の手続き )
</p>
<div class="algo">
手続きは
⇒
`~eventを発火する$( %容器, `load$et )
</div>
◎
Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.
</li>
</ol>
</div>

			</section>
			<section id="unloading-documents">
<h4 title="Unloading documents">7.5.9. 文書の~unload法</h4>

<p>
各 `文書$は、
次に挙げるものを有する：
◎
↓</p>
<ul>
	<li>
`回復可能か@doc
⇒
真偽値
— 初期~時は ~T になるモノトスル。
◎
A Document has a salvageable state, which must initially be true,＼
</li>
	<li>
<p>
`~pageを示しているか@doc
⇒
真偽値
— 初期~時は ~F になるモノトスル。
◎
and a page showing boolean, which is initially false.＼
</p>

<p>
これは、
次を確保するために利用される
⇒
~scriptが［
`pageshow$et, `pagehide$et
］~eventを整合的に受取る
（例： `pageshow$et を間に挟むことなく 2 つの `pagehide$et ~eventを続けて受取ったり，その逆が生じることは、
決してない）。
◎
The page showing boolean is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g., that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).
</p>
	</li>
	<li>
`休止~時刻@doc
⇒
`DOMHighResTimeStamp$I 値
— 初期~時は 0 とする。
◎
A Document has a DOMHighResTimeStamp suspension time, initially 0.
</li>
	<li>
`休止された~timer~handle群@doc
⇒
`~list$
— 初期~時は空とする。
◎
A Document has a list of suspended timer handles, initially empty.
</li>
</ul>

<p>
各`~event~loop$には、
`終了n入子ng~level@
と呼ばれる~counterがある
— 初期~時は 0 になるモノトスル。
◎
Event loops have a termination nesting level counter, which must initially be 0.
</p>

<p>
各 `文書$には、
`~unload~counter@
がある
— 初期~時は 0 に設定するモノトスル。
それは、
以下の各種~algoが走っている間，ある種の演算を無視するために利用される。
◎
Document objects have an unload counter, which is used to ignore certain operations while the below algorithms run. Initially, the counter must be set to zero.
</p>

<div class="algo">
<p>
`文書を~unloadする@
~algoは、
所与の
( `文書$ %旧-文書, `文書$ %新-文書 ~DF ε )
に対し：
◎
To unload a Document oldDocument, given an optional Document newDocument:
</p>
<ol>
	<li>
~Assert：
この~algoは、［
%旧-文書 に`関連な~agent$の`~event~loop$aGに~queueされた`~task$
］の一部として走っている。
◎
Assert: this is running as part of a task queued on oldDocument's relevant agent's event loop.
</li>
	<li>
%~unload計時~報 ~LET 新たな`文書~unload計時~報$
◎
Let unloadTimingInfo be a new document unload timing info.
</li>
	<li>
<p>
~IF［
%新-文書 ~EQ ε
］
⇒
%~unload計時~報 ~SET ~NULL
◎
If newDocument is not given, then set unloadTimingInfo to null.
</p>

<p class="note">注記：
この事例では、［
%旧-文書 を~unloadするのに，いつまでかかるか
］を知る必要がある新たな文書は無い。
◎
In this case there is no new document that needs to know about how long it took oldDocument to unload.
</p>
	</li>
	<li>
<div>
<p>
~ELIF［
%新-文書 の`~event~loop$ ~NEQ %旧-文書 の`~event~loop$
］：
</p>
		<ul>
			<li class="algo">
任意選択で
⇒
次を`並列的$に遂行する
⇒
`文書を~unloadする$( %旧-文書 )
</li>
			<li>
`that^en 事例においては†、
%~unload計時~報 を ~NULL に設定するベキである††。
</li>
		</ul>

<p class="trans-note">【†
［
~unloadする場合, ~IF 条件を満たす場合
］どちらを指しているのか、
はっきりしない（前者？）。
】【††
%~unload計時~報 が［
この~algo~instanceの中のそれ／
上で`文書を~unloadする$中のそれ
］どちらを指すのか，はっきりしない。
】</p>

◎
Otherwise, if newDocument's event loop is not oldDocument's event loop, then the user agent may be unloading oldDocument in parallel. In that case, the user agent should set unloadTimingInfo to null.
</div>

<p class="note">注記：
この事例では、
%新-文書 の読込ngは［
%旧-文書 を~unloadするのに，いつまでかかるか
］により影響iされないので，
その計時~報を通信することも無意味になる。
◎
In this case newDocument's loading is not impacted by how long it takes to unload oldDocument, so it would be meaningless to communicate that timing info.
</p>
	</li>
	<li>
<p>
%~BF~cache内に保つか ~LET ~IS［［
%旧-文書, および %旧-文書 のすべての子孫
］は，どれも ~AND↓ を満たす
］：
</p>
		<ul>
			<li>
その`回復可能か$doc ~EQ ~T
</li>
			<li>
~UAは、
後で`履歴~辿り用に利用できる＠~HTMLnav#note-bfcache$よう，
それが`~session履歴~entry$内に生存し続けることを意図する
</li>
		</ul>
◎
Let intendToKeepInBfcache be true if the user agent intends to keep oldDocument alive in a session history entry, such that it can later be used for history traversal.
◎
This must be false if oldDocument is not salvageable, or if there are any descendants of oldDocument which the user agent does not intend to keep alive in the same way (including due to their lack of salvageability).
</li>
	<li>
%~event~loop ~LET %旧-文書 に`関連な~agent$の`~event~loop$aG
◎
Let eventLoop be oldDocument's relevant agent's event loop.
</li>
	<li>
%~event~loop の`終了n入子ng~level$ ~INCBY 1
◎
Increase eventLoop's termination nesting level by 1.
</li>
	<li>
%旧-文書 の`~unload~counter$ ~INCBY 1
◎
Increase oldDocument's unload counter by 1.
</li>
	<li>
~IF［
%~BF~cache内に保つか ~EQ ~F
］
⇒
%旧-文書 の`回復可能か$doc ~SET ~F
◎
If intendToKeepInBfcache is false, then set oldDocument's salvageable state to false.
</li>
	<li>
<p>
~IF［
%旧-文書 の`~pageを示しているか$doc ~EQ ~T
］：
◎
If oldDocument's page showing is true:
</p>
		<ol>
			<li>
%旧-文書 の`~pageを示しているか$doc ~SET ~F
◎
Set oldDocument's page showing to false.
</li>
			<li>
`~page遷移~eventを発火する$( %旧-文書 に`関連な大域~obj$, `pagehide$et, %旧-文書 の`回復可能か$doc )
◎
Fire a page transition event named pagehide at oldDocument's relevant global object with oldDocument's salvageable state.
</li>
			<li>
`可視性~状態を更新する$( %旧-文書, `hidden^l )
◎
Update the visibility state of oldDocument to "hidden".
</li>
		</ol>
	</li>
	<li>
<!-- 
時刻を粗化するは，
現在の高分解能~時刻の中でも遂行されていて冗長に見えるが、
2 個目の引数に異なるものを［
渡すので，必要になる／
渡して，二重に適用する必要がある
］。
-->
~IF［
%~unload計時~報 ~NEQ ~NULL
］
⇒
%~unload計時~報 の`~unload~event開始~時刻$ ~SET
`時刻を粗化する$( `現在の高分解能~時刻$( %新-文書 に`関連な大域~obj$ ), %旧-文書 に`関連な設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV )
◎
If unloadTimingInfo is not null, then set unloadTimingInfo's unload event start time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.
</li>
	<li>
~IF［
%旧-文書 の`回復可能か$doc ~EQ ~F
］
⇒
`~eventを発火する$( %旧-文書 に`関連な大域~obj$, `unload$et )
— `~targetを上書きする^i 下で
◎
If oldDocument's salvageable state is false, then fire an event named unload at oldDocument's relevant global object, with legacy target override flag set.
</li>
	<li>
~IF［
%~unload計時~報 ~NEQ ~NULL
］
⇒
%~unload計時~報 の`~unload~event終了~時刻$ ~SET
`時刻を粗化する$( `現在の高分解能~時刻$( %新-文書 に`関連な大域~obj$ ), %旧-文書 に`関連な設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV )
◎
If unloadTimingInfo is not null, then set unloadTimingInfo's unload event end time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.
</li>
	<li>
%~event~loop の`終了n入子ng~level$ ~DECBY 1
◎
Decrease eventLoop's termination nesting level by 1.
</li>
	<li>
%旧-文書 の`休止~時刻$doc ~SET `現在の高分解能~時刻$( %文書【%旧-文書】 に`関連な大域~obj$ )
◎
Set oldDocument's suspension time to the current high resolution time given document's relevant global object.
</li>
	<li>
%旧-文書 の`休止された~timer~handle群$doc ~SET 【 %旧-文書 に`関連な大域~obj$の】`作動中な~timer群が成す~map$の`~key群$map
◎
Set oldDocument's suspended timer handles to the result of getting the keys for the map of active timers.
</li>
	<li>
%旧-文書 の`利用者により~scrollされたか$doc ~SET ~F
◎
Set oldDocument's has been scrolled by the user to false.
</li>
	<li>
この仕様も含む`適用-可能な仕様$にて定義される
`文書~unload時の片付け手続き$があれば、
それらの各~手続きを %旧-文書 を渡して走らす
【そのような手続きが複数ある場合に，どの順序で走らすかは、指定されていない。】
◎
Run any unloading document cleanup steps for oldDocument that are defined by this specification and other applicable specifications.
</li>
	<li>
~IF［
%旧-文書 の`~node~navigable$は`~top-level辿可能$である
］
⇒
`~top-level辿可能とその子孫~用に復旧されない事由~群を築く$( %旧-文書 の`~node~navigable$ )
◎
If oldDocument's node navigable is a top-level traversable, build not restored reasons for a top-level traversable and its descendants given oldDocument's node navigable.
</li>
	<li>
~IF［
%旧-文書 の`回復可能か$doc ~EQ ~F
］
⇒
`文書を破壊する$( %旧-文書 )
◎
If oldDocument's salvageable state is false, then destroy oldDocument.
</li>
	<li>
%旧-文書 の`~unload~counter$ ~DECBY 1
◎
Decrease oldDocument's unload counter by 1.
</li>
	<li>
~IF［
%新-文書 ~NEQ ε
］~AND［
%新-文書 の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~F
］~AND［
( %新-文書 の`生成元$doc, %旧-文書 の`生成元$doc )
は`同一-生成元$である
］
⇒
%新-文書 の`前-文書の~unload計時~報$doc ~SET %~unload計時~報
◎
If newDocument is given, newDocument's was created via cross-origin redirects is false, and newDocument's origin is the same as oldDocument's origin, then set newDocument's previous document unload timing to unloadTimingInfo.
</li>
</ol>

</div>

<div class="algo">
<p>
`文書とその子孫たちを~unloadする@
~algoは、
所与の
⇒＃
`文書$ %文書,
`文書$ %新-文書 ~DF ~NULL,
手続き %すべて~unload後の手続き ~DF ε,
手続き %~pageswap_evを発火する手続き ~DF ε
◎終
に対し：
◎
To unload a document and its descendants, given a Document document, an optional Document-or-null newDocument (default null), an optional set of steps afterAllUnloads, and an optional set of steps firePageSwapSteps:
</p>
<ol>
	<li>
~Assert：
この~algoは、［
%文書 の`~node~navigable$の`辿可能な~navigable$navの`~session履歴~辿り~queue$nav
］の中で走っている。
◎
Assert: this is running within document's node navigable's traversable navigable's session history traversal queue.
</li>
	<li>
%~unload済み数 ~LET 0
◎
↓</li>
	<li>
<p>
%文書 の【`~node~navigable$の】
~EACH( `子~navigable$ %子~navigable )
に対し
<span class="XXX">順序は どうする？</span>
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %子~navigable にて`作動中な~window$nav, 次の手続き )
◎
Let childNavigables be document's child navigables.
◎
Let numberUnloaded be 0.
◎
For each childNavigable of childNavigables in what order?, queue a global task on the navigation and traversal task source given childNavigable's active window to perform＼
</p>

<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li class="algo">
%~unload済みを増加する ~LET 次を走らす~algo
⇒
%~unload済み数 ~INCBY 1
◎
Let incrementUnloaded be an algorithm step which increments numberUnloaded.
</li>
			<li>
`文書とその子孫たちを~unloadする$( %子~navigable にて`作動中な文書$nav, ~NULL, %~unload済みを増加する )
◎
Unload a document and its descendants given childNavigable's active document, null, and incrementUnloaded.
</li>
		</ol>
</div>
	</li>
	<li>
次が満たされるまで待機する
⇒
%~unload済み数 ~EQ %子~navigable の`~size$
◎
Wait until numberUnloaded equals childNavigable's size.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %文書 に`関連な大域~obj$, 次の手続き )
◎
Queue a global task on the navigation and traversal task source given document's relevant global object to perform＼
</p>
<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
~IF［
%~pageswap_evを発火する手続き ~NEQ ε
］
⇒
%~pageswap_evを発火する手続き()
◎
If firePageSwapSteps is given, then run firePageSwapSteps.
</li>
			<li>
~IF［
%新-文書 ~EQ ~NULL
］
⇒
`文書を~unloadする$( %文書 )
◎
↓</li>
			<li>
~ELSE
⇒
`文書を~unloadする$( %文書, %新-文書 )
◎
Unload document, passing along newDocument if it is not null.
</li>
			<li>
~IF［
%すべて~unload後の手続き ~NEQ ε
］
⇒
%すべて~unload後の手続き()
◎
If afterAllUnloads was given, then run it.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

<div class="algo">
<p>
この仕様は、
`文書~unload時の片付け手続き@
として，次を定義する
— 他の仕様も，この手続きをさらに定義し得る。
それは、
所与の
( `文書$ %文書 )
に対し：
◎
This specification defines the following unloading document cleanup steps. Other specifications can define more. Given a Document document:
</p>
<ol>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be document's relevant global object.
</li>
	<li>
~EACH( `WebSocket$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒＃
%O を`消滅させる$；
`文書を回復不能にする$( %文書, `websocket$l )
◎
For each WebSocket object webSocket whose relevant global object is window, make disappear webSocket.
◎
If this affected any WebSocket objects, then make document unsalvageable given document and "websocket".
</li>
	<li>
~EACH( `WebTransport$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
`文脈を片付ける手続き$( %O )
◎
For each WebTransport object transport whose relevant global object is window, run the context cleanup steps given transport.
</li>
	<li>
<p>
~IF［
%文書 の`回復可能か$doc ~EQ ~F
］：
◎
If document's salvageable state is false, then:
</p>
		<ol>
			<li>
~EACH( `EventSource$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`強制的に~closeする$
◎
For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.
</li>
			<li>
%~window にて`作動中な~timer群が成す~map$を`~clearする$map
◎
Clear window's map of active timers.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="XXX">
<p>
`文書~unload時の片付け手続き$ ~hookを利用する仕様~策定者は、
代わりに，［
ここから自身の仕様の中への~callを直に追加する~pull要請
］を送信する方が良い
— そうすれば、［
各~仕様からの~call順序がきちんと定義される
］ことが確保されるので。
これを書いた時点では、
次に挙げる仕様が`文書~unload時の片付け手続き$を利用していることが既知であり，
それらは未指定な順序で走ることになる
⇒＃
`FULLSCREEN$r,
`WEBNFC$r,
`WEBDRIVERBIDI$r,
`COMPUTEPRESSURE$r,
`FILEAPI$r,
`MEDIASTREAM$r,
`PICTUREINPICTURE$r,
`SCREENORIENTATION$r,
`SW$r,
`WEBLOCKS$r,
`WEBAUDIO$r,
`WEBRTC$r
◎
It would be better if specification authors sent a pull request to add calls from here into their specifications directly, instead of using the unloading document cleanup steps hook, to ensure well-defined cross-specification call order. As of the time of this writing the following specifications are known to have unloading document cleanup steps, which will be run in an unspecified order: Fullscreen API, Web NFC, WebDriver BiDi, Compute Pressure, File API, Media Capture and Streams, Picture-in-Picture, Screen Orientation, Service Workers, WebLocks API, WebAudio API, WebRTC. [FULLSCREEN] [WEBNFC] [WEBDRIVERBIDI] [COMPUTEPRESSURE] [FILEAPI] [MEDIASTREAM] [PICTUREINPICTURE] [SCREENORIENTATION] [SW] [WEBLOCKS] [WEBAUDIO] [WEBRTC]
</p>

<p>
これらの手続きの順序を明瞭にする作業は、
`課題 #8906＠~HTMLissue/8906$
にて追跡されている。
◎
Issue #8906 tracks the work to make the order of these steps clear.
</p>
</div>

			</section>
			<section id="destroying-documents">
<h4 title="Destroying documents">7.5.10. 文書の破壊-法</h4>

<div class="algo">
<p>
`文書を破壊する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To destroy a Document document:
</p>
<ol>
	<li>
~Assert：
この~algoは、［
%文書 に`関連な~agent$の`~event~loop$aGに~queueされた`~task$
］の一部として走っている。
◎
Assert: this is running as part of a task queued on document's relevant agent's event loop.
</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
	<li>
%文書 の`回復可能か$doc ~SET ~F
◎
Set document's salvageable state to false.
</li>
	<li>
~EACH( `MessagePort$I %~port )
に対し
⇒
~IF［
%~port に`関連な大域~obj$に`結付けられた文書$ ~EQ %文書
］
⇒
`~portの連絡を断つ$( %~port )
◎
Let ports be the list of MessagePorts whose relevant global object's associated Document is document.
◎
For each port in ports, disentangle port.
</li>

	<li>
この仕様も含む`適用-可能な仕様$に定義される`文書~unload時の片付け手続き$があれば、
それらの各~手続きを %文書 を渡して走らす
【そのような手続きが複数ある場合に，どの順序で走らすかは、指定されていない。】
◎
Run any unloading document cleanup steps for document that are defined by this specification and other applicable specifications.
</li>
	<li>
~queueされた`~task$のうち［
その`文書$tK ~EQ %文書
］を満たすものは、
（~taskを走らすことなく）除去する
◎
Remove any tasks whose document is document from any task queue (without running those tasks).
</li>
	<li>
%文書 が`属する閲覧~文脈$ ~SET ~NULL
◎
Set document's browsing context to null.
</li>
	<li>
%文書 の`~node~navigable$にて`作動中な~entry$nav の`文書~状態$shE の`文書$dS ~SET ~NULL
◎
Set document's node navigable's active session history entry's document state's document to null.
</li>
	<li>
~EACH( `WorkerGlobalScope$I ~obj %O )
に対し
⇒
%O の`所有者~集合$wGから %文書 を`除去する$
◎
Remove document from the owner set of each WorkerGlobalScope object whose set contains document.
</li>
	<li>
%文書 の`~worklet大域~scope~list$docを成す
~EACH( %~worklet大域~scope )
に対し
⇒
`~worklet大域~scopeを終了させる$( %~worklet大域~scope )
◎
For each workletGlobalScope in document's worklet global scopes, terminate workletGlobalScope.
</li>
</ol>

<p class="note">注記：
`子~navigableを破壊-＠~HTMLds#destroy-a-child-navigable$している事例においては、
破壊の後でも，
当の`文書$は~scriptから~access可能になるかもしれない。
◎
Even after destruction, the Document object itself might still be accessible to script, in the case where we are destroying a child navigable.
</p>
</div>

<div class="algo">
<p>
`文書とその子孫たちを破壊する@
~algoは、
所与の
( `文書$ %文書, 手続き %すべて破壊-後の手続き ~DF ε )
に対し，
次の手続きを`並列的$に遂行する：
◎
To destroy a document and its descendants given a Document document and an optional set of steps afterAllDestruction, perform the following steps in parallel:
</p>
<ol>
	<li>
<p>
~IF［
%文書 は`全部的に作動中$でない
］：
◎
If document is not fully active, then:
</p>
		<ol>
			<li>
%事由 ~LET ［
`~UAに特有な阻んでいる事由$が適用されるならば それを表現する文字列 ／
~ELSE_ `masked$l
］
◎
Let reason be a string from user-agent specific blocking reasons. If none apply, then let reason be "masked".
</li>
			<li>
`文書を回復不能にする$( %文書, %事由 )
◎
Make document unsalvageable given document and reason.
</li>
			<li>
~IF［
%文書 の`~node~navigable$は`~top-level辿可能$である
］
⇒
`~top-level辿可能とその子孫~用に復旧されない事由~群を築く$( %文書 の`~node~navigable$ )
◎
If document's node navigable is a top-level traversable, build not restored reasons for a top-level traversable and its descendants given document's node navigable.
</li>
		</ol>
	</li>
	<li>
%破壊-済み数 ~LET 0
◎
↓</li>
	<li>
<p>
%文書 の【`~node~navigable$の】
~EACH( `子~navigable$ %子~navigable )
に対し
<span class="XXX">順序は どうする？</span>
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %子~navigable にて`作動中な~window$nav, 次の手続き )
◎
Let childNavigables be document's child navigables.
◎
Let numberDestroyed be 0.
◎
For each childNavigable of childNavigables in what order?, queue a global task on the navigation and traversal task source given childNavigable's active window to perform＼
</p>
<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li class="algo">
%破壊-済みを増加する ~LET 次を遂行する手続き
⇒
%破壊-済み数 ~INCBY 1
◎
Let incrementDestroyed be an algorithm step which increments numberDestroyed.
</li>
			<li>
`文書とその子孫たちを破壊する$( %子~navigable にて`作動中な文書$nav, %破壊-済みを増加する )
◎
Destroy a document and its descendants given childNavigable's active document and incrementDestroyed.
</li>
		</ol>
</div>
	</li>
	<li>
次が満たされるまで待機する
⇒
%破壊-済み数 ~EQ %子~navigable群【！childNavigable】 の`~size$
◎
Wait until numberDestroyed equals childNavigable's size.
</li>
	<li>
<p>
`大域~taskを~queueする$( `~naviと辿り~task~source$, %文書 に`関連な大域~obj$, 
次の手続き )
◎
Queue a global task on the navigation and traversal task source given document's relevant global object to perform＼
</p>
<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
`文書を破壊する$( %文書 )
◎
Destroy document.
</li>
			<li>
~IF［
%すべて破壊-後の手続き ~NEQ ε
］
⇒
%すべて破壊-後の手続き()
◎
If afterAllDestruction was given, then run it.
</li>
		</ol>
</div>
	</li>
</ol>
</div>

			</section>
			<section id="aborting-a-document-load">
<h4 title="Aborting a document load">7.5.11. 文書~読込nの中止-法</h4>

<div class="algo">
<p>
`文書を中止する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To abort a Document document:
</p>
<ol>
	<li>
~Assert：
この~algoは、［
%文書 に`関連な~agent$の`~event~loop$aGに~queueされた`~task$
］の一部として走っている。
◎
Assert: this is running as part of a task queued on document's relevant agent's event loop.
</li>
	<li>
<p>
~IF［
%文書 の文脈~下にある`~fetch$~algoの~instanceがある
］：
</p>
		<ol>
			<li>
それらの各~instanceを取消す
— 以降
⇒＃
それらに対し`~queueされ$る`~task$は破棄する ／
それらに対し~networkから受信される更なる~dataは破棄する
</li>
			<li>
`文書を回復不能にする$( %文書, `fetch$l )
</li>
		</ol>
◎
Cancel any instances of the fetch algorithm in the context of document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then make document unsalvageable given document and "fetch".
</li>
	<li>
<p>
~IF［
%文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc ~NEQ ~NULL
］：
◎
If document's during-loading navigation ID for WebDriver BiDi is non-null, then:
</p>
		<ol>
			<li>
%~navi状態s ~LET `新たな~WebDriver-BiDi~navi状態s$( %文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc, `取消された$wBDst, %文書 の`~URL$doc )
◎
↓</li>
			<li>
`~WebDriver-BiDi~naviは中止された$( %文書 の`~node~navigable$, %~navi状態s )
◎
Invoke WebDriver BiDi navigation aborted with document's node navigable and a new WebDriver BiDi navigation status whose id is document's during-loading navigation ID for WebDriver BiDi, status is "canceled", and url is document's URL.
</li>
			<li>
%文書 の`読込ng中における~WebDriver-BiDi用の~navi~ID$doc ~SET ~NULL
◎
Set document's during-loading navigation ID for WebDriver BiDi to null.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%文書 には`作動中な構文解析器$がある
］：
◎
If document has an active parser, then:
</p>
		<ol>
			<li>
%文書 の`作動中な構文解析器は中止されたか$ ~SET ~T
◎
Set document's active parser was aborted to true.
</li>
			<li>
その`構文解析器を中止する$
◎
Abort that parser.
</li>
			<li>
`文書を回復不能にする$( %文書, `parser-aborted$l )
◎
Set document's salvageable to false. （不要（削除漏れ？
◎
Make document unsalvageable given document and "parser-aborted".
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`文書とその子孫たちを中止する@
~algoは、
所与の
( `文書$ %文書 )
に対し：
◎
To abort a document and its descendants given a Document document:
</p>
<ol>
	<li>
~Assert：
この~algoは、［
%文書 に`関連な~agent$の`~event~loop$aGに~queueされた`~task$
］の一部として走っている。
◎
Assert: this is running as part of a task queued on document's relevant agent's event loop.
</li>
	<li>
%子孫~navigable群 ~LET %文書 の`子孫~navigable群$
◎
Let descendantNavigables be document's descendant navigables.
</li>
	<li>
<p>
%子孫~navigable群 を成す
~EACH( %子孫~navigable )
に対し
<span class="XXX">順序は どうする？</span>
⇒
`大域~taskを~queueする$( `~naviと辿り~task~source$, %子孫~navigable にて`作動中な~window$nav, 次の手続き )
◎
For each descendantNavigable of descendantNavigables in what order?, queue a global task on the navigation and traversal task source given descendantNavigable's active window to perform＼
</p>
<div class="algo">
<p>
手続きは：
◎
the following steps:
</p>
		<ol>
			<li>
`文書を中止する$( %子孫~navigable にて`作動中な文書$nav )
◎
Abort descendantNavigable's active document.
</li>
			<li>
~IF［
%子孫~navigable にて`作動中な文書$navの`回復可能か$doc ~EQ ~F
］
⇒
%文書 の`回復可能か$doc ~SET ~F
◎
If descendantNavigable's active document's salvageable is false, then set document's salvageable to false.
</li>
		</ol>
</div>
	</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
</ol>
</div>

<div class="algo">
<p>
`読込ngを停止する@
~algoは、
所与の
( `~navigable$ %~navigable )
に対し：
◎
To stop loading a navigable navigable:
</p>
<ol>
	<li>
%文書 ~LET %~navigable にて`作動中な文書$nav
◎
Let document be navigable's active document.
</li>
	<li>
<p>
~IF［
%文書 の`~unload~counter$ ~EQ 0
］~AND［
%~navigable の`進行中な~navi$ ~EQ `~navi~ID$
］
⇒
`進行中な~naviを設定する$( %~navigable, ~NULL )
◎
If document's unload counter is 0, and navigable's ongoing navigation is a navigation ID, then set the ongoing navigation for navigable to null.
</p>

<p class="note">注記：
これには
%~navigable にて進行中な~naviがあれば，それを中止する効果がある
— `進行中な~navi$に対する変更は、
~naviの間ある種の箇所で，更なる作業を放棄させることになるので。
◎
This will have the effect of aborting any ongoing navigations of navigable, since at certain points during navigation, changes to the ongoing navigation will cause further work to be abandoned.
</p>
	</li>
	<li>
`文書とその子孫たちを中止する$( %文書 )
◎
Abort a document and its descendants given document.
</li>
</ol>
</div>

<p class="XXX">
~UAは、
自身の`~UI＠#nav-traversal-ui$を通して，
辿りを停止することも許容する
— すなわち、［
`進行中な~navi$ ~EQ `traversal^l
］の事例で。
上の~algoは、
これを織り込んでいない
（他方、
~UAは，
`window.stop()＠~WINDOW#dom-window-stop$c により辿りを停止することは許容しないので、
上の~algoは，その~call元~用には正しくなる）。
`課題 #6905＠~HTMLissue/6905$
を見よ。
◎
Through their user interface, user agents also allow stopping traversals, i.e. cases where the ongoing navigation is "traversal". The above algorithm does not account for this. (On the other hand, user agents do not allow window.stop() to stop traversals, so the above algorithm is correct for that caller.) See issue #6905.
</p>

			</section>
		</section>
		<section id="the-x-frame-options-header">
<h3 title="The X-Frame-Options header">7.6. `X-Frame-Options^h ~header</h3>

<p>
`X-Frame-Options@h
~HTTP応答~headerは、［
`文書$は`子~navigable$の内側に どう読込まれてもよいか
］を制御する仕方である。
~CSPを利用している~site用には、
`frame-ancestors$dir 指令の方が，同じ状況に対し細やかな制御を供する。
この~headerは，元々は
`HTTP Header Field X-Frame-Options^cite `RFC7034$r
にて定義されたが、
ここでの定義と処理~modelは，その文書に取って代わる。
◎
The `X-Frame-Options` HTTP response header is a way of controlling whether and how a Document may be loaded inside of a child navigable. For sites using CSP, the frame-ancestors directive provides more granular control over the same situations. It was originally defined in HTTP Header Field X-Frame-Options, but the definition and processing model here supersedes that document. [CSP] [RFC7034]
</p>

<p class="note">注記：
特に，
`HTTP Header Field X-Frame-Options^cite
は、
その~header値~用の変種として `ALLOW-FROM^bl も指定したが，
それは実装されていない。
◎
In particular, HTTP Header Field X-Frame-Options specified an `ALLOW-FROM` variant of the header, but that is not to be implemented.
</p>

<p class="note">注記：
以下に与える処理~modelにより、
`X-Frame-Options$h ~headerは，
同じ`応答$内に~CSP `frame-ancestors$dir 指令も利用された場合には無視される。
◎
Per the below processing model, if both a CSP frame-ancestors directive and an `X-Frame-Options` header are used in the same response, then `X-Frame-Options` is ignored.
</p>

<p>
［
~web開発者／適合性~検査器
］向けとして，その値の`~ABNF$は：
◎
For web developers and conformance checkers, its value ABNF is:
</p>

<pre class="bnf">
X-Frame-Options
	= "DENY"
	/ "SAMEORIGIN"
</pre>

<div class="algo">
<p>
`~navi応答の~X-Frame-Optionsに対する固守を検査する@
~algoは、
所与の
( `応答$ %応答, `~navigable$ %~navigable, `~CSP~list$ %~CSP~list, `生成元$ %行先~生成元 )
に対し：
◎
To check a navigation response's adherence to `X-Frame-Options`, given a response response, a navigable navigable, a CSP list cspList, and an origin destinationOrigin:
</p>
<ol>
	<li>
~IF［
%~navigable は`子~navigable$でない
］
⇒
~RET ~T
◎
If navigable is not a child navigable, then return true.
</li>
	<li>
<p>
%~CSP~list を成す
~EACH( %施策 )
に対し：
◎
For each policy of cspList:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^l
］
⇒
~CONTINUE
◎
If policy's disposition is not "enforce", then continue.
</li>
			<li>
~IF［
`frame-ancestors$dir 指令 ~IN %施策 の`指令~集合$
］
⇒
~RET ~T
◎
If policy's directive set contains a frame-ancestors directive, then return true.
</li>
		</ol>
	</li>
	<li>
%~X-Frame-Options ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `X-Frame-Options$h )
◎
Let rawXFrameOptions be the result of getting, decoding, and splitting `X-Frame-Options` from response's header list.
</li>
	<li>
<p>
~IF［
%~X-Frame-Options ~EQ ~NULL
］
⇒
~RET ~T
</p>
<p class="trans-note">【
この段は、
この訳による補完
（応答~内に `X-Frame-Options$h は無い）。
】</p>
	</li>
	<li>
%~frame~option群 ~LET 新たな`集合$
◎
Let xFrameOptions be a new set.
</li>
	<li>
%~X-Frame-Options を成す
~EACH( %値 )
に対し
⇒
%~frame~option群 に次の結果を`付加する$set
⇒
`~ASCII小文字~化する$( %値 ) 
◎
For each value of rawXFrameOptions, append value, converted to ASCII lowercase, to xFrameOptions.
</li>
	<li>
<p>
~IF［
%~frame~option群 の`~size$ ~GT 1
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~frame~option群 を成す
~EACH( %値 )
に対し
⇒
~IF［
%値 ~IN { `deny^l, `allowall^l, `sameorigin^l }
］
⇒
~RET ~F
◎
If xFrameOptions's size is greater than 1, and xFrameOptions contains any of "deny", "allowall", or "sameorigin", then return false.
</p>

<p class="note">注記：
ここでの意図nは、
`X-Frame-Options$h が［
妥当な何かを行おうと試行しているが，紛らわしく現れる
］場合には，それを適用する際に 【埋込もうとする】どの試みも阻止することにある。
◎
The intention here is to block any attempts at applying `X-Frame-Options` which were trying to do something valid, but appear confused.
</p>

<p class="note">注記：
旧来の `ALLOWALL^bl 値による処理~modelに対する影響iは、
ここに限られる。
◎
This is the only impact of the legacy `ALLOWALL` value on the processing model.
</p>
			</li>
			<li>
<p>
~RET ~T
◎
If xFrameOptions's size is greater than 1, then return true.
</p>

<p class="note">注記：
~headerは、
複数個の妥当でない値を包含している
— この場合、
~headerが まるごと省略されていたときと同じ仕方で扱う。
◎
This means it contains multiple invalid values, which we treat the same way as if the header was omitted entirely.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~frame~option群[ 0 ] ~EQ `deny^l
］
⇒
~RET ~F
◎
If xFrameOptions[0] is "deny", then return false.
</li>
	<li>
<p>
~IF［
%~frame~option群[ 0 ] ~EQ `sameorigin^bl
］：
◎
If xFrameOptions[0] is "sameorigin", then:
</p>
		<ol>
			<li>
%容器~文書 ~LET %~navigable の`容器~文書$nav
◎
Let containerDocument be navigable's container document.
</li>
			<li>
<p>
~WHILE［
%容器~文書 ~NEQ ~NULL
］：
◎
While containerDocument is not null:
</p>
				<ol>
					<li>
~IF［
( %容器~文書 の`生成元$doc, %行先~生成元 )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If containerDocument's origin is not same origin with destinationOrigin, then return false.
</li>
					<li>
%容器~文書 ~SET %容器~文書 の`容器~文書$doc
◎
Set containerDocument to containerDocument's container document.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~RET ~T
◎
Return true.
</p>

<p class="note">注記：
ここまで達した場合、
妥当でない 1 個の値からなる（旧来の［
`ALLOWALL^bl ／ `ALLOW-FROM^bl
］形も該当する）
— この場合、
~headerは まるごと省略されていたかのように扱う。
◎
If we've reached this point then we have a lone invalid value (which could potentially be one the legacy `ALLOWALL` or `ALLOW-FROM` forms). These are treated as if the header were omitted entirely.
</p>
	</li>
</ol>
</div>

<hr>

<div class="example">
<p>
この~header用の様々な値の処理を
— 不適合tなものも含め —
次の表tに示す：
◎
The following table illustrates the processing of various values for the header, including non-conformant ones:
</p>

<div>
<table><thead>
<tr><th>`X-Frame-Options$h
<th>妥当か？
<th>結果
<tbody>

<tr><td>`DENY^bl
<td>✅
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN^bl
<td>✅
<td>同一-生成元なら埋込みは許容される

<tr><td>`INVALID^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOWALL^bl
<td>❌
<td>埋込みは許容される

<tr><td>`ALLOW-FROM=https://example.com/^bl
<td>❌
<td>埋込みは許容される（どこからでも）

</table>
◎
`X-Frame-Options`｜Valid｜Result
`DENY`｜✅｜embedding disallowed
`SAMEORIGIN`｜✅｜same-origin embedding allowed
`INVALID`｜❌｜embedding allowed
`ALLOWALL`｜❌｜embedding allowed
`ALLOW-FROM=https://example.com/`｜❌｜embedding allowed (from anywhere)
</div>
</div>


<div class="example">
<p>
複数の値を孕んでいる，様々な不適合tな事例がどう処理されるかを，次の表tに示す：
◎
The following table illustrates how various non-conformant cases involving multiple values are processed:
</p>

<div>
<table><thead>
<tr><th>`X-Frame-Options$h
<th>結果
<tbody>

<tr><td>`SAMEORIGIN, SAMEORIGIN^bl
<td>同一-生成元なら埋込みは許容される

<tr><td>`SAMEORIGIN, DENY^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN,^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, ALLOWALL^bl
<td>埋込みは許容されない

<tr><td>`SAMEORIGIN, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL, INVALID^bl
<td>埋込みは許容されない

<tr><td>`ALLOWALL,^bl
<td>埋込みは許容されない

<tr><td>`INVALID, INVALID^bl
<td>埋込みは許容される
</table>

◎
`X-Frame-Options`｜Result
`SAMEORIGIN, SAMEORIGIN`｜same-origin embedding allowed
`SAMEORIGIN, DENY`｜embedding disallowed
`SAMEORIGIN,`｜embedding disallowed
`SAMEORIGIN, ALLOWALL`｜embedding disallowed
`SAMEORIGIN, INVALID`｜embedding disallowed
`ALLOWALL, INVALID`｜embedding disallowed
`ALLOWALL,`｜embedding disallowed
`INVALID, INVALID`｜embedding allowed
</div>

<p>
値たちが［
~commaで区切られた値を伴う 1 個の~header,
複数個の~header
］どちらで送達されようが，得される結果は同じになる。
◎
The same results are obtained whether the values are delivered in a single header whose value is comma-delimited, or in multiple headers.
</p>
</div>

		</section>
		<section id="the-refresh-header">
<h3 title="The Refresh header">7.7. `Refresh$h ~header</h3>

<p>
`Refresh@h
~HTTP応答~headerは、［
`meta$e 要素のうち，その `http-equiv$a 属性は `~refresh$st 状態にあるもの
］を~HTTPにおいて等価に~~表現するものである。
それは，
`同じ値＠~HEmetadata#conformance-attr-meta-http-equiv-refresh$をとり，ほとんど同じに働く。
その処理~modelの詳細は、
`文書を作成して初期化する$にて与えられる。
◎
The `Refresh` HTTP response header is the HTTP-equivalent to a meta element with an http-equiv attribute in the Refresh state. It takes the same value and works largely the same. Its processing model is detailed in create and initialize a Document object.
</p>

		</section>
		<section id="nav-traversal-ui">
<h3 title="Browser user interface considerations">7.8. ~browser~UIの考慮点</h3>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
次に挙げる能を【利用者~向けに（以下同様）】供するベキである
⇒
`~navigateする$／
`読込直す$／
`読込ngを停止する$
◎
Browser user agents should provide the ability to navigate, reload, and stop loading any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、［
~URL~bar／
“読込直す” ~button／
“停止する” ~button
］などの~UIを介して。
◎
For example, via a location bar and reload/stop button UI.
</p>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
`履歴を差分だけ辿る$能を供するベキである。
◎
Browser user agents should provide the ability to traverse by a delta any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、［
戻る／進む
］~buttonを介して
— 場合によっては、
長押しにより差分を変更する能も含めて。
◎
For example, via back and forward buttons, possibly including long-press abilities to change the delta.
</p>

<p>
そのような~UAは、
2 以上の差分による辿りも許容することが示唆される
— ~pageが［
~session履歴に偽りな~entryを
（例えば，［
`history.pushState()＠~WINDOW#dom-history-pushstate$c の~callや`素片へ~navigateする$こと
］を繰返すことを介して）
詰め込む
］ことにより，利用者を “罠に嵌める” のを避けるため。
◎
It is suggested that such user agents allow traversal by deltas greater than one, to avoid letting a page "trap" the user by stuffing the session history with spurious entries. (For example, via repeated calls to history.pushState() or fragment navigations.)
</p>

<p class="note">注記：
一部の~UAは、
特定的にそのような濫用を克服するために，［
“戻る” ／ “進む”
］~buttonが 1 回だけ押されたとき より大きい差分に翻訳する経験則を備える。
`課題 #7832＠~HTMLissue/7832$ にて，
これらの経験則を指定することが~~検討されている。
◎
Some user agents have heuristics for translating a single "back" or "forward" button press into a larger delta, specifically to overcome such abuses. We are contemplating specifying these heuristics in issue #7832.
</p>

<p>
~browser~UAは、
`新鮮な~top-level辿可能を作成する$能を利用者に提供するベキである
— ［
利用者が供した／~UAにより決定される
］初期`~URL$を与えて。
◎
Browser user agents should offer users the ability to create a fresh top-level traversable, given a user-provided or user agent-determined initial URL.
</p>

<p class="example">
例えば［
“新たな~UItab” ／ “新たな~UIwindow”
］~buttonを介して。
◎
For example, via a "new tab" or "new window" button.
</p>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
利用者が任意に`~top-level辿可能を閉じる$能を提供するベキである。
◎
Browser user agents should offer users the ability to arbitrarily close any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、
“~UItabを閉じる” ~buttonを~clickすることにより。
◎
For example, by clicking a "close tab" button.
</p>

<hr>

<p>
~browser~UAは、
利用者~向けに，`~navigable$（`~top-level辿可能$に限らず）を明示的に［
`~navigateする$／`読込直す$／`読込ngを停止する$
］仕方を供してもヨイ。
◎
Browser user agents may provide ways for the user to explicitly cause any navigable (not just a top-level traversable) to navigate, reload, or stop loading.
</p>

<p class="example">
例えば，文脈~menuを介して。
◎
For example, via a context menu.
</p>

<p>
~browser~UAは、
利用者~向けに，`~top-level辿可能を破壊する$能を供してもヨイ。
◎
Browser user agents may provide the ability for users to destroy a top-level traversable.
</p>

<p class="example">
例えば、
そのような`~top-level辿可能$を複数~個 包含している~UIwindowを強制的に閉じることにより。
◎
For example, by force-closing a window containing one or more such top-level traversables.
</p>

<hr>

<p>
利用者から`~navigable$を`読込直す$よう要請されたとき，
その`作動中な~entry$navの`文書~状態$shEの`資源$dSが`~POST資源$である場合には、
~UAは，先ず利用者に その操作oを確認してもらうよう~promptするベキである
— さもなければ、
~transaction（例：購入や~database改変）が繰返され得るので。
◎
When a user requests a reload of a navigable whose active session history entry's document state's resource is a POST resource, the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g., purchases or database modifications) could be repeated.
</p>

<p>
~UAは，利用者から`~navigable$を`読込直す$よう要請されたときは、
読込直す際に~cacheを無視するための仕組みを供してもヨイ。
◎
When a user requests a reload of a navigable, user agents may provide a mechanism for ignoring any caches when reloading.
</p>

<hr>

<p>
`~navigableを~URLへ~navigateする$
~callが上で言及した仕組みにより起動される場合、
その引数 %利用者-関与i に `~browser~UI$i を渡すモノトスル。
◎
All calls to navigate initiated by the mechanisms mentioned above must have the userInvolvement argument set to "browser UI".
</p>

<p>
`~navigableを読込直す$
~callが上で言及した仕組みにより起動される場合、
その引数 %利用者-関与i に `~browser~UI$i を渡すモノトスル。
◎
All calls to reload initiated by the mechanisms mentioned above must have the userInvolvement argument set to "browser UI".
</p>

<p>
`履歴を差分だけ辿る$
~callが上で言及した仕組みにより起動される場合、
その引数 %~source文書 には値を渡さないモノトスル。
◎
All calls to traverse the history by a delta initiated by the mechanisms mentioned above must not pass a value for the sourceDocument argument.
</p>

<hr>

<p>
上に挙げた推奨, および
この仕様における~data構造には、［
~UAが利用者に~session履歴をどう表現するかに対し制約を設置する
］ことは意味されない。
◎
The above recommendations, and the data structures in this specification, are not meant to place restrictions on how user agents represent the session history to the user.
</p>

<p>
例えば、
`~top-level辿可能$の`~session履歴~entry群$tnは，
~listとして［
格納され, 保守される
］
— ~UAには、
`履歴を差分だけ辿る$ための~UIを与えることが推奨される —
が、
先進的な~UAは，それに［
代えて／加えて
］~treeの様な~viewを呈示して，［
各~pageが複数の “進む” ~pageを備えていて，利用者がそれらを選べる
］ようにすることもできる。
◎
For example, although a top-level traversable's session history entries are stored and maintained as a list, and the user agent is recommended to give an interface for traversing that list by a delta, a novel user agent could instead or in addition present a tree-like view, with each page having multiple "forward" pages that the user can choose between.
</p>

<p>
類似に、
`辿可能な~navigable$内には，［
そのすべての子孫`~navigable$
］用の~session履歴が格納されるが、
~UAは，もっと仔細に［
`~navigable$ごとに，~session履歴の~viewを利用者に呈示する
］こともできる。
◎
Similarly, although session history for all descendant navigables is stored in their traversable navigable, user agents could present the user with a more nuanced per-navigable view of the session history.
</p>

<hr>

<p>
~browser~UAは、
`~top-level閲覧~文脈$の`~popupか$bcを次に挙げる目的に利用してもヨイ：
◎
Browser user agents may use a top-level browsing context's is popup boolean for the following purposes:
</p>
<ul>
	<li>
対応している`~top-level辿可能$用に必要最小限な~web~browser~UIを供するかどうかを裁定する。
◎
Deciding whether or not to provide a minimal web browser user interface for the corresponding top-level traversable.
</li>
	<li>
`閲覧~文脈の特能を設定しておく$とき，その中の任意選択な各~段を遂行する所。
◎
Performing the optional steps in set up browsing context features.
</li>
</ul>

<p>
どちらの事例においても、
~UAは，それに加えて［
利用者-選好を組入れる／
~popup~routeを奥へ進む選択肢を呈示する
］こともできよう。
◎
In both cases user agents might additionally incorporate user preferences, or present a choice as to whether to go down the popup route.
</p>

<p>
~UAは、［
そのような~popup用に必要最小限な~UIを供する場合でも，
~browserの~URL~barは隠さない
］ことが奨励される。
◎
User agents that provide a minimal user interface for such popups are encouraged to not hide the browser's location bar.
</p>

		</section>
</main>

