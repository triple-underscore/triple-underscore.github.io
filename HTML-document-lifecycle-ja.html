<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — Document lifecycle（日本語訳）</title>
<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'MAIN',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w~\-一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'bl':
	text = `\`<code class="literal">${key}</code>\``;
	break;
case 'h':
	text = `\`<code class="header">${key}</code>\``;
	break;
case 'en':
	return `<span lang="en">${key}</span>`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>

<script type="text/plain" id="_source_data">


●●options

spec_date:2022-12-26
trans_update:2022-12-28
source_checked:221101
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/document-lifecycle.html
	abbr_url:HTMLlifecycle
site_nav:browsers,network,html
nav_prev:HTMLnav
nav_next:WAPI
trans_1st_pub:2017-01-01
	trans_1st_pub:2022-11-08

●●class_map
e:element
a:attr
et:event-type
dir:directive
jv:js-value
st:attr-state

●●tag_map
I:code
c:code
e:code
a:code
et:code
mt:code
dir:code
st:span
i:i
sub:sub
cite:cite
	em:em

●●original_urls

●●words_table

		●network
Content-Type:
X-Frame-Options:
	HTTP_S:HTTP(S) 
COOP:
close:
load:
読込直す:reloadする::読み込み直す::リロードする
refresh:
unload:
	~unload法:unloading:
部位t:part:部位
	複-部位t:multipart

		●環境 ／ navi
lifecycle:
agent:
iframe:
worklet:
辿可能:traversable::辿り可能
辿り:traversal::~
辿る:traverseする::~
回復可能:salvage 可能:~
opener:::open 元
	生成元が類似な:similar-origin

	●UI
操作o:operation:操作
隠さな:hideしな:~
prompt:
viewer::::ビューア
popup::::ポップアップ
bar::::バー
新鮮:fresh:~
確認-:confirm:~
閉じる:closeする::~
仔細:nuanced:~
route::::ルート
	強制的に閉じる:force-closing
	長押し:long-press
	押した:press
	進む:forward
	戻る:back
	奥へ進む選択肢:choice as to whether to go down
	選べる:chooseできる:~

	●構文
EOF:
tokenizer:::token 化器:トークン化器:トークナイザ
整形式性:well-formedness::~
同型:isomorphic::~
	和集合:union::~
区切られ:delimitされ:~
	~ID:id
	LF
	LINE FEED

	●一般処理
片付け:cleanup::~
timer::::タイマー
準備度:readiness:~
最終-:final:~
params::::パラメタ群
処置先:disposition::~
生存-:alive::~
	生存し続け:keep 〜 alive
handle:
休止:suspension::~
設置-:place:~
commit:
早期:early::~
進行中の:ongoing:~
放棄-:abandon:~
作成時の:creation::~
制御器:controller::~

	~call元:caller
	終わらす:finish

	●変数
旧-:old:~
新-:new:~
X:
BF:
保つ:keepする:~

	~COOP:coop
	%O:eventSource
	%O:webSocket
	%~BF~cache内に保つか:intendToKeepInBfcache
	%~BF~cache内に保つか:intendToStoreInBfcache
	%~CSP~list:cspList
	%~MIME型:type0
	%~X~frame~option群:xFrameOptions0
	%~agent:agent
	%~event~loop:eventLoop
	%~host要素:hostelement
	%~load計時~情報:loadTimingInfo
	%~navigable:navigable
	%~navi~ID:navigationId
	%~navi計時~種別:navTimingType
	%~navi計時~種別:navigationTimingType
	%~realm実行~文脈:realmExecutionContext
	%~redirect回数:redirectCount
	%~referrer:referrer
	%~source~snapshot~params:sourceSnapshotParams
	%~top-level作成時の~URL:topLevelCreationURL
	%~top-level生成元:topLevelOrigin
	%~unload計時~情報:unloadTimingInfo
	%~window:window
	%~worklet大域~scope:workletGlobalScope
	%作動中の文書:-
	%作成時の~URL:creationURL
	%値:value
	%全部的な計時~情報:fullTimingInfo
	%内容~型:contentType:
	%容器~文書:containerDocument
	%応答:response
	%文書:document
	%施策:policy
	%早期~hintを~commitする:-
	%最初の部位t用の~navi~params:firstPartNavigationParams
	%生~X~frame~option群:rawXFrameOptions0
	%生成元~agent~cluster~header:oacHeader
	%生成元~agent~clusterを要請するか:requestsOAC
	%行先~生成元:destinationOrigin
	%親~環境:parentEnvironment
	%許可~施策:permissionsPolicy
	%起動元~生成元:initiatorOrigin
	%閲覧~文脈:browsingContext
	%新-文書:newDocument
	%旧-文書:oldDocument
	%~navi~params:navigationParams
	%容器:container
	%種別:type
	%生成元:origin
	%~COOP:coop
	%~COOP施行n結果:coopEnforcementResult

	●保安
濫用:abuse:~
偽り:spurious:~
罠:trap:~
	罠に嵌める:letting 〜 trap
	詰め込む:stuff
	許可~施策:Permissions Policy
	細かさを抑えた:coarsen

	●仕様
濫用:abuse:~
翻訳-:translate:~
先進的:novel:~
必要最小限:minimal:~
変種:variant:~
無意味:meaningless:~
自立的:stand-alone:~
整合的に:consistent mannerで:~
固守:adherence:~
細やか:granular:~
強制的:forcible:~
	強制的に:force-〜
施行n:enforcement::施行
克服-:overcome:~

	対になる:for that matter
	~~真の:real
	ことになった場合:face
	するよりも~~寛容でない:less permissive compared to doing 〜 instead
	-:potentially
	取って代わる:supersede
	紛らわしく:confused
	許容されない:disallowed
	示す:illustrate
	~~形式上のものでしかなく:besides preventing the Document-creation algorithm from getting confused
	~~検討:contemplate

	●未分類
高分解能:high resolution::~
	合成-:synthesize::~
消滅-:disappear:~
埋めた:fillした:~
埋めて:fillして:~
切替えた:switchした:切り替えた
切替えら:switchさ:切り替えら
折返す:wrapする:折り返す
発した:emitした:~
購入:purchase:~
差分:delta:~
transaction::::トランザクション
database::::データベース

POST:
PLAINTEXT:
PDF:
WebDriver-BiDi:

	2 個目以降の:additional
	間に挟む:intervening
	戻る:back
	現れる:appearする
	表:table
	続けて:in a row
	ほとんど:largely
	より大きい:larger
	箇所で:points
	何らかの~style:extra styling
	尽きた:no more
	ようになる:will not end-up being
	結果になる:will end-up
	いつまでかかるか:how long it took
	~~関心事にならない:do not matter
	ことになった:faced
	2 以上:greater than one
	〜であっても:despite
	〜でなくとも:despite not
	が無い:-less
	この場合:This means that
	最終的に:eventually
	引用用の:quoting
	~~伝える:communicate
	-:lack of
	同行する:go along with

●●words_table1
WEBDRIVER-BIDI:https://w3c.github.io/webdriver-bidi/

sf:<sub>sf-</sub>
about_blank:about:blank

●●original_id_map

	nav-traversal-ui:history-notes
	read-ua-inline:read-ua-plugin
	read-ua-inline:navigate-plugin
	unload-counter:ignore-opens-during-unload-counter
	destroy-a-document:discard-a-document
	nav-stop:stop-document-loading

●●mdn_urls

●●link_map

	●code

I.DOMHighResTimeStamp:~HRTIME#dom-domhighrestimestamp
I.EventSource:~HTMLsse#eventsource
I.NavigationTimingType:~NAV-TIMING#dom-navigationtimingtype
I.PaymentRequest:https://w3c.github.io/payment-request/#dom-paymentrequest
I.WebSocket:~WEBSOCKET#websocket
I.WindowProxy:~HTMLWPROXY#windowproxy
I.WorkerGlobalScope:~WORKERS#workerglobalscope
	I.Document:~HTMLdom#document
文書:~HTMLdom#the-document-object
	I.Window:~WINDOW#window
~window:~WINDOW#the-window-object

	:~WINDOW#dom-window-stop
c.document.domain:~ORIGIN#dom-document-domain

a.autoplay:~HEmedia#attr-media-autoplay
a.http-equiv:~HEmetadata#attr-meta-http-equiv
	:~HEimages#attr-img-src
	:~HEmedia#attr-media-src

e.audio:~HEmedia#the-audio-element
e.body:~HEsections#the-body-element
e.frame:~HTMLobs#frame
e.head:~HEmetadata#the-head-element
e.html:~HEmetadata#the-html-element
e.iframe:~HEembed#the-iframe-element
e.img:~HEimages#the-img-element
e.meta:~HEmetadata#the-meta-element
e.title:~HEmetadata#the-title-element
e.video:~HEmedia#the-video-element

et.load:~HTMLindex#event-load
et.pagehide:~HTMLindex#event-pagehide
et.pageshow:~HTMLindex#event-pageshow
et.unload:~HTMLindex#event-unload

h.Origin-Agent-Cluster:~ORIGIN#origin-agent-cluster
h.Refresh:#refresh
h.X-Frame-Options:#x-frame-options

mt.multipart/x-mixed-replace:~HTMLiana#multipart/x-mixed-replace
mt.text/html:~HTMLiana#text/html

st.~refresh:~HEmetadata#attr-meta-http-equiv-refresh

	●用語


文書を作成して初期化する:#initialise-the-document-object
完全に読込まれた:#completely-loaded
完全に読込まれた時刻:#completely-loaded-time
読込ngを完全に終わらす:#completely-finish-loading
文書を破壊する:#destroy-a-document
文書を中止する:#abort-a-document
読込ngを停止する:#nav-stop

doc.~pageを示しているか:#page-showing
doc.休止~時刻:#suspension-time
doc.休止された~timer~handle群:#suspended-timer-handles
doc.回復可能か:#concept-document-salvageable

文書を~unloadする:#unload-a-document
終了n入子ng~level:#termination-nesting-level
~unload~counter:#unload-counter
文書~unload時の片付け手続き:#unloading-document-cleanup-steps

~HTML文書を読込む:#navigate-html
~text文書を読込む:#navigate-text
multipart/x-mixed-replace 文書を読込む:#navigate-multipart-x-mixed-replace
~media文書を読込む:#navigate-media
~navi応答の~X-Frame-Optionsに対する固守を検査する:#check-a-navigation-response's-adherence-to-x-frame-options



	●用語（HTML

並列的:~HTMLINFRA#in-parallel
適用-可能な仕様:~HTMLINFRA#other-applicable-specifications
~Content-Type~metadata:~HTMLurl#content-type

doc.~load計時~情報:~HTMLdom#load-timing-info
doc.~navi~ID:~HTMLdom#concept-document-navigation-id
doc.~referrer:~HTMLdom#the-document's-referrer
doc.初期~about_blankか:~HTMLdom#is-initial-about:blank
doc.前-文書の~unload計時~情報:~HTMLdom#previous-document-unload-timing
doc.施策~容器:~HTMLdom#concept-document-policy-container
doc.現在の準備度:~HTMLdom#current-document-readiness
doc.許可~施策:~HTMLdom#concept-document-permissions-policy
doc.非同一-生成元~opener施策:~HTMLdom#concept-document-coop
doc.非同一-生成元~redirectを介して作成されたか:~HTMLdom#was-created-via-cross-origin-redirects
~navi開始~時刻:~HTMLdom#navigation-start-time
~unload~event終了~時刻:~HTMLdom#unload-event-end-time
~unload~event開始~時刻:~HTMLdom#unload-event-start-time
作動中の構文解析器:~HTMLdom#active-parser
初期~about_blank な文書:~HTMLdom#is-initial-about:blank
文書~load計時~情報:~HTMLdom#document-load-timing-info
文書~unload計時~情報:~HTMLdom#document-unload-timing-info

~navi応答~用に利用する閲覧~文脈を得する:~ORIGIN#obtain-browsing-context-navigation
不透明な生成元:~ORIGIN#concept-origin-opaque
生成元:~ORIGIN#concept-origin
同じ生成元~domain:~ORIGIN#same-origin-domain
同一-生成元:~ORIGIN#same-origin
作動中の~sandbox法~flag集合:~ORIGIN#active-sandboxing-flag-set
施策~容器:~ORIGIN#policy-container
非同一-生成元~opener施策:~ORIGIN#cross-origin-opener-policy
非同一-生成元~opener施策の施行n結果:~ORIGIN#coop-enforcement-result
cooP.~URL:~ORIGIN#coop-enforcement-url
cooP.生成元:~ORIGIN#coop-enforcement-origin
cooP.非同一-生成元~opener施策:~ORIGIN#coop-enforcement-coop

~window用に環境~設定群~objを設定しておく:~WINDOW#set-up-a-window-environment-settings-object
結付けられている文書:~WINDOW#concept-document-window
~page遷移~eventを発火する:~WINDOW#fire-a-page-transition-event

~navigable:~HTMLds#navigable
~node~navigable:~HTMLds#node-navigable
nav.作動中の~entry:~HTMLds#nav-active-history-entry
nav.容器:~HTMLds#nav-container
nav.容器~文書:~HTMLds#nav-container-document
doc.容器~文書:~HTMLds#doc-container-document
nav.作動中の文書:~HTMLds#nav-document
nav.作動中の閲覧~文脈:~HTMLds#nav-bc
tbcG.~group:~HTMLds#tlbc-group
tn.~session履歴~entry群:~HTMLds#tn-session-history-entries
子~navigable:~HTMLds#child-navigable
子孫~navigable群:~HTMLds#descendant-navigables
新たな入子な~navigableを作成する:~HTMLds#create-a-new-nested-navigable
新鮮な~top-level辿可能を作成する:~HTMLds#create-a-fresh-top-level-traversable
辿可能な~navigable:~HTMLds#traversable-navigable
~top-level辿可能:~HTMLds#top-level-traversable
~top-level辿可能~集合:~HTMLds#top-level-traversable-set
~top-level辿可能を破壊する:~HTMLds#destroy-a-top-level-traversable
~top-level辿可能を閉じる:~HTMLds#close-a-top-level-traversable
閲覧~文脈:~HTMLds#browsing-context
bc.~popupか:~HTMLds#is-popup
bc.作動中の文書:~HTMLds#active-document
bc.作動中の~window:~HTMLds#active-window
~top-level閲覧~文脈:~HTMLds#top-level-browsing-context
入子な~navigableを破壊-:~HTMLds#destroy-the-nested-navigable
属する閲覧~文脈:~HTMLds#concept-document-bc
新たな閲覧~文脈と文書を作成する:~HTMLds#creating-a-new-browsing-context

nvP.~navigable:~HTMLnav#navigation-params-navigable
nvP.最終-~sandbox~flag集合:~HTMLnav#navigation-params-sandboxing
nvP.非同一-生成元~opener施策:~HTMLnav#navigation-params-coop
nvP.~COOP施行n結果:~HTMLnav#navigation-params-coop-enforcement-result
nvP.生成元:~HTMLnav#navigation-params-origin
nvP.応答:~HTMLnav#navigation-params-response
nvP.要請:~HTMLnav#navigation-params-request
nvP.予約-済み環境:~HTMLnav#navigation-params-reserved-environment
nvP.施策~容器:~HTMLnav#navigation-params-policy-container
nvP.~ID:~HTMLnav#navigation-params-id
nvP.~fetch制御器:~HTMLnav#navigation-params-fetch-controller
nvP.~navi計時~種別:~HTMLnav#navigation-params-nav-timing-type
nvP.早期~hintを~commitする:~HTMLnav#navigation-params-commit-early-hints
~navi~params:~HTMLnav#navigation-params
~scriptを走らせてもよい:~HTMLnav#scripts-may-run-for-the-newly-created-document
~source~snapshot~params:~HTMLnav#source-snapshot-params
文書を読込む:~HTMLnav#loading-a-document
~navigableを~URLへ~navigateする:~HTMLnav#navigate
~navigateする:~HTMLnav#navigate
i.応答:~HTMLnav#navigation-response
i.履歴~取扱い:~HTMLnav#navigation-hh
i.置換-:~HTMLnav#hh-replace
~navi~ID:~HTMLnav#navigation-id
~session履歴~entry:~HTMLnav#session-history-entry
shE.文書~状態:~HTMLnav#she-document-state
dS.文書:~HTMLnav#document-state-document
進行中の~navi:~HTMLnav#ongoing-navigation
読込直す:~HTMLnav#reload
履歴を差分だけ辿る:~HTMLnav#traverse-the-history-by-a-delta
素片へ~navigateする:~HTMLnav#navigate-fragid
dS.資源:~HTMLnav#document-state-resource
~POST資源:~HTMLnav#post-resource
doc.利用者により~scrollされたか:~HTMLnav#has-been-scrolled-by-the-user


enV.~secureな文脈:~WAPI#secure-context
	enV.非~secureな文脈:~WAPI#non-secure-context
enV.~top-level作成時の~URL:~WAPI#concept-environment-top-level-creation-url
enV.~top-level生成元:~WAPI#concept-environment-top-level-origin
enV.非同一-生成元~能力は隔離されるか？:~WAPI#concept-settings-object-cross-origin-isolated-capability
生成元が類似な~window~agentを得する:~WAPI#obtain-similar-origin-window-agent
新たな~realmを作成する:~WAPI#creating-a-new-javascript-realm
rM.大域~obj:~WAPI#concept-realm-global
関連な設定群~obj:~WAPI#relevant-settings-object
関連な大域~obj:~WAPI#concept-relevant-global
関連な~agent:~WAPI#relevant-agent
~task:~WAPI#concept-task
tK.文書:~WAPI#concept-task-document
~task~queue:~WAPI#task-queue
~taskを~queueする:~WAPI#queue-a-task
~queueされ:~WAPI#queue-a-task
大域~taskを~queueする:~WAPI#queue-a-global-task
要素~taskを~queueする:~WAPI#queue-an-element-task
~event~loop:~WAPI#event-loop
aG.~event~loop:~WAPI#concept-agent-event-loop
~network用~task源:~WAPI#networking-task-source
~DOM操作~task源:~WAPI#dom-manipulation-task-source

~iframe属性~群を処理する:~HEembed#process-the-iframe-attributes
~iframe~load~event手続き:~HEembed#iframe-load-event-steps
~link~header群を処理する:~HEmetadata#process-link-headers
共用~宣言的~refresh手続き:~HEmetadata#shared-declarative-refresh-steps
~XML構文解析器:~HTMLxml#xml-parser
可視性~状態を更新する:~HTMLinteraction#update-the-visibility-state
作動中の~timer群が成す~map:~HTMLGAPI#map-of-active-timers
作動中の構文解析器は中止されたか:~HTMLdynamic#active-parser-was-aborted
wG.所有者~集合:~WORKERS#concept-WorkerGlobalScope-owner-set
doc.~worklet大域~scope~list:~WORKLETS#concept-document-worklet-global-scopes
~worklet大域~scopeを終了させる:~WORKLETS#terminate-a-worklet-global-scope
強制的に~closeする:~HTMLsse#concept-eventsource-forcibly-close

~HTML構文解析器:~HTMLparsing#html-parser
構文解析器を中止する:~HTMLparsing#abort-a-parser
構文解析を停止した:~HTMLparsing#stop-parsing
構文解析器は~modeを変更できないか:~HTMLparsing#parser-cannot-change-the-mode-flag
入力~byte~stream:~HTMLparsing#the-input-byte-stream
~tokenizer:~HTMLparsing#tokenization
~PLAINTEXT状態:~HTMLparsing#plaintext-state
中止-:~HTMLparsing#abort-a-parser

	●用語（外部

同型に復号する:~INFRA#isomorphic-decode
~list:~INFRA#list
~key群を取得する:~INFRA#map-getting-the-keys
map.~clearする:~INFRA#map-clear
除去する:~INFRA#list-remove
集合:~INFRA#ordered-set
set.付加する:~INFRA#set-append
~ASCII小文字~化する:~INFRA#ascii-lowercase
~size:~INFRA#list-size

	~Assert:~INFRA#assert
	~IN:~INFRA#list-contain
	~EACH:~INFRA#list-iterate
	~CONTINUE:~INFRA#iteration-continue
	~WHILE:~INFRA#iteration-while

~URL:~URL1#concept-url
~URL~record:~URL1#concept-url
~URLを直列化する:~URL1#concept-url-serializer

fT.開始~時刻:~FETCH#fetch-timing-info-start-time
rq.~URL:~FETCH#concept-request-url
rq.~redirect回数:~FETCH#concept-request-redirect-count
rq.~referrer:~FETCH#concept-request-referrer
rq.現在の~URL:~FETCH#concept-request-current-url
rs.~URL:~FETCH#concept-response-url
rs.~header~list:~FETCH#concept-response-header-list
rs.~sw計時~情報:~FETCH#response-service-worker-timing-info
rs.本体:~FETCH#concept-response-body
rs.本体~情報:~FETCH#concept-response-body-info
rs.計時~情報:~FETCH#concept-response-timing-info
rs.非同一-生成元~redirectはあるか:~FETCH#response-has-cross-origin-redirects
~ABNF:~FETCH#abnf
~fetch:~FETCH#concept-fetch
~fetch制御器:~FETCH#fetch-controller
~header~listから値を取得して復号して分割する:~FETCH#concept-header-list-get-decode-split
全部的な計時~情報を抽出する:~FETCH#extract-full-timing-info
応答:~FETCH#concept-response
有構造~field値を取得する:~FETCH#concept-header-list-get-structured-header

doc.種別:~DOM4#concept-document-type
doc.内容~型:~DOM4#concept-document-content-type
doc.生成元:~DOM4#concept-document-origin
doc.~URL:~DOM4#concept-document-url
doc.符号化法:~DOM4#concept-document-encoding
doc.~mode:~DOM4#concept-document-mode
~eventを発火する:~DOM4#concept-event-fire

dir.frame-ancestors:~CSP3#frame-ancestors
~CSP~list:~CSP3#csp-list
処置先:~CSP3#policy-disposition
指令~集合:~CSP3#policy-directive-set
文書~用に~CSP初期化を走らす:~CSP3#run-document-csp-initialization
応答から閲覧~文脈~用の許可~施策を作成する:~PERMISSIONS-POLICY#create-from-response

~agent:~TC39#sec-agents

~sf真偽値:~STRUCTURED-FIELDS#boolean

閲覧~文脈の特能を設定しておく:~CSSOMVIEW#set-up-browsing-context-features

~navi計時~entryを作成する:~NAV-TIMING#dfn-create-the-navigation-timing-entry
算出される~MIME型:~MIMESNIFF#computed-mime-type
現在の高分解能~時刻:~HRTIME#dfn-current-high-resolution-time
細かさを抑えた時刻:~HRTIME#dfn-coarsen-time
消滅させる:~WEBSOCKET#make-disappear
~WebDriver-BiDi~naviは中止された:~WEBDRIVER-BIDI#webdriver-bidi-navigation-aborted
wBDst.取消された:~WEBDRIVER-BIDI#navigation-status-canceled
新たな~WebDriver-BiDi~navi状態s:~HTMLdep#_new-webdriver-bidi-navigation-status


●●trans_metadata
<p>
~THIS_PAGEは、
~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ Document lifecycle</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>


<body>

<header>
	<hgroup>
<h1>HTML — 文書の lifecycle</h1>
<p>Document lifecycle</p>

	</hgroup>
</header>

<hr>

<main id="MAIN" hidden>

		<section id="document-lifecycle">
<h3 title="Document lifecycle">7.5. 文書~lifecycle</h3>

			<section id="_conventions">
<h4>【この訳に特有な表記規約】</h4>

<p>
この訳における，
~algoや定義の記述に利用されている各種記号（ ~LET, ~IF, ε, コレ, ~THROW 等々）の意味や定義の詳細は、
~SYMBOL_DEF_REFを~~参照されたし。
</p>

			</section>
			<section id="shared-document-creation-infrastructure">
<h4 title="Shared document creation infrastructure">7.5.1. 共用~文書~作成~基盤</h4>

<div class="algo">
<p>
以下に与える各~algoは、
文書を読込むときに，
`文書を作成して初期化する@
手続きを利用する。
それは、
所与の
( `種別$doc %種別, `内容~型$doc %内容~型, `~navi~params$ %~navi~params )
に対し，次を走らす：
◎
When loading a document using one of the below algorithms, we use the following steps to create and initialize a Document object, given a type type, content type contentType, and navigation params navigationParams:
</p>

<p class="note">注記：
`文書$は，
`新たな閲覧~文脈と文書を作成する$ときにも作成されるが、
この~algoは，そのような`初期~about_blank な文書$を決して作成しない。
`属する閲覧~文脈$が無い`文書$は、
`document.implementation.createHTMLDocument()＠~DOM4#dom-domimplementation-createhtmldocument$c など，様々な~APIを介して作成され得る。
◎
Document objects are also created when creating a new browsing context and document; such initial about:blank Document are never created by this algorithm. Also, browsing context-less Document objects can be created via various APIs, such as document.implementation.createHTMLDocument().
</p>
<ol>
	<li>
%閲覧~文脈 ~LET %~navi~params の`~navigable$nvPにて`作動中の閲覧~文脈$nav
◎
Let browsingContext be navigationParams's navigable's active browsing context.
</li>
	<li>
<p>
%閲覧~文脈 ~SET `~navi応答~用に利用する閲覧~文脈を得する$( ↓ )
⇒＃
%閲覧~文脈,
%~navi~params の`最終-~sandbox~flag集合$nvP,
%~navi~params の`非同一-生成元~opener施策$nvP,
%~navi~params の`~COOP施行n結果$nvP
◎
Set browsingContext to the result of the obtaining a browsing context to use for a navigation response given browsingContext, navigationParams's final sandboxing flag set, navigationParams's cross-origin opener policy, and navigationParams's COOP enforcement result.
</p>

<p class="note">注記：
これにより、
`閲覧~文脈~groupが切替えられ＠~ORIGIN#browsing-context-group-switches-due-to-cross-origin-opener-policy$ることもある
— その事例では、
%閲覧~文脈 は，［
%~navi~params の`~navigable$nvPにて`作動中の閲覧~文脈$navではなく，
`新たに作成され＠~HTMLds#creating-a-new-browsing-context$た`閲覧~文脈$
］になる。
そのような事例では、
作成された［
`~window$, `文書$, `~agent$
］は利用されないようになる
— 作成された`文書$の`生成元$docは`不透明な生成元$なので、
`この~algoの後の段＠#create-new-agent-and-window$で，
新たな`文書$と同行する新たな［
`~agent$, `~window$
］を作成する結果になる。
◎
This can result in a browsing context group switch, in which case browsingContext will be a newly-created browsing context instead of being navigationParams's navigable's active browsing context. In such a case, the created Window, Document, and agent will not end up being used; because the created Document's origin is opaque, we will end up creating a new agent and Window later in this algorithm to go along with the new Document.
</p>
	</li>
	<li>
<p>
%許可~施策 ~LET
`応答から閲覧~文脈~用の許可~施策を作成する$( %閲覧~文脈, %~navi~params の`生成元$nvP, %~navi~params の`応答$nvP )
`PERMISSIONSPOLICY$r
◎
Let permissionsPolicy be the result of creating a permissions policy from a response given browsingContext, navigationParams's origin, and navigationParams's response. [PERMISSIONSPOLICY]
</p>

<div class="note">
<p>注記：
ここで`応答から閲覧~文脈~用の許可~施策を作成する$ときは、
渡された`生成元$を用立てる。
%~navi~params の`~navigable$nvPの`容器~文書$navに対し `document.domain$c が利用されていた場合、
【以下で作成される文書】
%文書 の`生成元$docと渡された生成元は，`同じ生成元~domain$にはなり得ない
— この手続きは %文書 が作成される前に走るので、
この時点では，まだ %文書 の `document.domain$c は利用し得ないので。
したがって，許可~施策の検査は、
`同一-生成元$かどうか検査するよりも~~寛容でない。
◎
The creating a permissions policy from a response algorithm makes use of the passed origin. If document.domain has been used for navigationParams's navigable's container document, then its origin cannot be same origin-domain with the passed origin, because these steps run before the document is created, so it cannot itself yet have used document.domain. Note that this means that Permissions Policy checks are less permissive compared to doing a same origin check instead.
</p>

<p>
これの動作~例は、
下を見よ。
◎
See below for some examples of this in action.
</p>
</div>

	</li>
	<li>
%作成時の~URL ~LET %~navi~params の`応答$nvPの`~URL$rs
◎
Let creationURL be navigationParams's response's URL.
</li>
	<li>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］
⇒
%作成時の~URL ~SET %~navi~params の`要請$nvPの`現在の~URL$rq
◎
If navigationParams's request is non-null, then set creationURL to navigationParams's request's current URL.
</li>
	<li>
%~window ~LET ~NULL
◎
Let window be null.
</li>
	<li>
<p>
~IF［
%閲覧~文脈 にて`作動中の文書$bcの`初期~about_blankか$doc ~EQ ~T
］~AND［
( %閲覧~文脈 にて`作動中の文書$bcの`生成元$doc, %~navi~params の`生成元$nvP )
は`同じ生成元~domain$である
］
⇒
%~window ~SET %閲覧~文脈 にて`作動中の~window$bc
◎
If browsingContext's active document's is initial about:blank is true, and browsingContext's active document's origin is same origin-domain with navigationParams's origin, then set window to browsingContext's active window.
</p>

<p class="note">注記：
この場合、
これから作成する新たな`文書$と`初期~about_blank な文書$は，
同じ`~window$を共有することになる。
◎
This means that both the initial about:blank Document, and the new Document that is about to be created, will share the same Window object.
</p>
	</li>
	<li>
<p id="create-new-agent-and-window">
~ELSE：
◎
Otherwise:
</p>
		<ol>
			<li>
%生成元~agent~cluster~header ~LET %~navi~params の`応答$nvPの`~header~list$rsから`有構造~field値を取得する$( `Origin-Agent-Cluster$h, `~item^i )
◎
Let oacHeader be the result of getting a structured field value given `Origin-Agent-Cluster` and "item" from navigationParams's response's header list.
</li>
			<li>
%生成元~agent~clusterを要請するか ~LET ［
次が満たされるならば ~T ／
~ELSE_ ~F
］
⇒
［
%生成元~agent~cluster~header ~NEQ ~NULL
］~AND［
%生成元~agent~cluster~header[ 0 ] ~EQ `~sf真偽値$ ~T
］~AND［
%~navi~params の`予約-済み環境$nvPは`~secureな文脈$enVである
］
◎
Let requestsOAC be true if oacHeader is not null and oacHeader[0] is the boolean true; otherwise false.
◎
If navigationParams's reserved environment is a non-secure context, then set requestsOAC to false.
</li>
			<li>
%~agent ~LET `生成元が類似な~window~agentを得する$( %~navi~params の`生成元$nvP, %閲覧~文脈 の`~group$tbcG, %生成元~agent~clusterを要請するか )
◎
Let agent be the result of obtaining a similar-origin window agent given navigationParams's origin, browsingContext's group, and requestsOAC.
</li>
			<li>
%~realm実行~文脈 ~LET %~agent 内で`新たな~realmを作成する$
— 次に従って~custom化する下で
⇒＃
大域~obj用に新たな`~window$を作成する,
大域 `this^jv 束縛には %閲覧~文脈 の `WindowProxy$I ~objを利用する
◎
Let realmExecutionContext be the result of creating a new realm given agent and the following customizations:
• For the global object, create a new Window object.
• For the global this binding, use browsingContext's WindowProxy object.
</li>
			<li>
%~window ~SET %~realm実行~文脈 の~Realm成分を成す`大域~obj$rM
【すなわち，前~段で作成した~window】
◎
Set window to the global object of realmExecutionContext's Realm component.
</li>
			<li>
%~top-level作成時の~URL ~LET %作成時の~URL
◎
Let topLevelCreationURL be creationURL.
</li>
			<li>
%~top-level生成元 ~LET %~navi~params の`生成元$nvP
◎
Let topLevelOrigin be navigationParams's origin.
</li>
			<li>
%~navigable ~LET %~navi~params の`~navigable$nvP
【この段は、この訳による補完。】
</li>
			<li>
<p>
~IF［
%~navigable の`容器$nav ~NEQ ~NULL
］：
◎
If navigable's container is not null, then:
</p>
				<ol>
					<li>
%親~環境 ~LET %~navigable の`容器$navに`関連な設定群~obj$
◎
Let parentEnvironment be navigable's container's relevant settings object.
</li>
					<li>
%~top-level作成時の~URL ~SET %親~環境 の`~top-level作成時の~URL$enV
◎
Set topLevelCreationURL to parentEnvironment's top-level creation URL.
</li>
					<li>
%~top-level生成元 ~SET %親~環境 の`~top-level生成元$enV
◎
Set topLevelOrigin to parentEnvironment's top-level origin.
</li>
				</ol>
			</li>
			<li>
`~window用に環境~設定群~objを設定しておく$( ↓ )
⇒＃
%作成時の~URL,
%~realm実行~文脈,
%~navi~params の`予約-済み環境$nvP,
%~top-level作成時の~URL,
%~top-level生成元
◎
Set up a window environment settings object with creationURL, realmExecutionContext, navigationParams's reserved environment, topLevelCreationURL, and topLevelOrigin.
</li>
		</ol>

<p class="note">注記：
これが通例的な事例であり、
これから作成する新たな`文書$は，それに同行する新たな`~window$を取得する。
◎
This is the usual case, where the new Document we're about to create gets a new Window to go along with it.
</p>
	</li>
	<li>
%~load計時~情報 ~LET 新たな`文書~load計時~情報$
— その
⇒
`~navi開始~時刻$ SET %~navi~params の`応答$nvPの`計時~情報$rsの`開始~時刻$fT
◎
Let loadTimingInfo be a new document load timing info with its navigation start time set to navigationParams's response's timing info's start time.
</li>
	<li>
<p>
%文書 ~LET 新たな`文書$
— その
⇒＃
`種別$doc ~SET %種別,
`内容~型$doc ~SET %内容~型,
`生成元$doc ~SET %~navi~params の`生成元$nvP,
`属する閲覧~文脈$ ~SET %閲覧~文脈,
`施策~容器$doc ~SET %~navi~params の`施策~容器$nvP,
`許可~施策$doc ~SET %許可~施策,
`作動中の~sandbox法~flag集合$ ~SET %~navi~params の`最終-~sandbox~flag集合$nvP,
`非同一-生成元~opener施策$doc ~SET %~navi~params の`非同一-生成元~opener施策$nvP,
`~load計時~情報$doc ~SET %~load計時~情報,
`非同一-生成元~redirectを介して作成されたか$doc ~SET %~navi~params の`応答$nvPの`非同一-生成元~redirectはあるか$rs,
`~navi~ID$doc ~SET %~navi~params の`~ID$nvP,
`~URL$doc ~SET %作成時の~URL,
`現在の準備度$doc ~SET `loading^l
◎
Let document be a new Document, with
◎
type
• type
content type
• contentType
origin
• navigationParams's origin
browsing context
• browsingContext 
policy container
• navigationParams's policy container
permissions policy
• permissionsPolicy
active sandboxing flag set
• navigationParams's final sandboxing flag set
cross-origin opener policy
• navigationParams's cross-origin opener policy
load timing info
• loadTimingInfo
was created via cross-origin redirects
• navigationParams's response's has cross-origin redirects
navigation id
• navigationParams's id
URL
• creationURL
current document readiness
• "loading"
</p>
	</li>
	<li>
%~window に`結付けられている文書$ ~SET %文書
◎
Set window's associated Document to document.
</li>
	<li>
`文書~用に~CSP初期化を走らす$( %文書 )
`CSP$r
◎
Run CSP initialization for a Document given document. [CSP]
</li>
	<li>
<p>
~IF［
%~navi~params の`要請$nvP ~NEQ ~NULL
］：
◎
If navigationParams's request is non-null, then:
</p>
		<ol>
			<li>
%文書 の`~referrer$doc ~SET 空~文字列
◎
Set document's referrer to the empty string.
</li>
			<li>
%~referrer ~LET %~navi~params の`要請$nvPの`~referrer$rq
◎
Let referrer be navigationParams's request's referrer.
</li>
			<li>
<p>
~IF［
%~referrer は`~URL~record$である
］
⇒
%文書 の`~referrer$doc ~SET `~URLを直列化する$( %~referrer )
◎
If referrer is a URL record, then set document's referrer to the serialization of referrer.
</p>

<p class="note">注記：
`FETCH$r により、
%~referrer は，この時点で［
`~URL~record$／ `no-referrer^l
］になる。
◎
Per Fetch, referrer will be either a URL record or "no-referrer" at this point.
</p>
			</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%~navi~params の`~fetch制御器$nvP ~NEQ ~NULL
］：
◎
If navigationParams's fetch controller is not null, then:
</p>
		<ol>
			<li>
%全部的な計時~情報 ~LET `全部的な計時~情報を抽出する$( %~navi~params の`~fetch制御器$nvP )
◎
Let fullTimingInfo be the result of extracting the full timing info from navigationParams's fetch controller.
</li>
			<li>
%~redirect回数 ~LET %~navi~params の`応答$nvPの`非同一-生成元~redirectはあるか$rsに応じて
⇒＃
~T ならば 0 ／
~F ならば %~navi~params の`要請$nvPの`~redirect回数$rq
◎
Let redirectCount be 0 if navigationParams's response's has cross-origin redirects is true; otherwise navigationParams's request's redirect count.
</li>
			<li>
`~navi計時~entryを作成する$( ↓ )
⇒＃
%文書,
%全部的な計時~情報
%~redirect回数,
%navigationTimingType【未定義な変数： %~navi~params の`~navi計時~種別$nvP？】,
%~navi~params の`応答$nvPの`~sw計時~情報$rs,
【ここに必要な引数が無い】,
%~navi~params の`応答$nvPの`本体~情報$rs
◎
Create the navigation timing entry for document, given fullTimingInfo, redirectCount, navigationTimingType, navigationParams's response's service worker timing info, and navigationParams's response's body info.
</li>
		</ol>
	</li>
	<li>
`~navi計時~entryを作成する$( ↓ )
⇒＃
%文書,
%~navi~params の`応答$nvPの`計時~情報$rs,
%~redirect回数,
%~navi~params の`~navi計時~種別$nvP,
%~navi~params の`応答$nvPの`~sw計時~情報$rs,
【引数が足らない】
◎
Create the navigation timing entry for document, with navigationParams's response's timing info, redirectCount, navigationParams's navigation timing type, and navigationParams's response's service worker timing info.
</li>
	<li>
<p>
~IF［
%~navi~params の`応答$nvPには `Refresh$h ~headerは在る
］：
◎
If navigationParams's response has a `Refresh` header, then:
</p>
		<ol>
			<li>
%値 ~LET `同型に復号する$( `Refresh^h の値 )
◎
Let value be the isomorphic decoding of the value of the header.
</li>
			<li>
`共用~宣言的~refresh手続き$( %文書, %値 )
◎
Run the shared declarative refresh steps with document and value.
</li>
		</ol>

<p class="XXX">
`Refresh$h ~headerが複数あるときの取扱いは、
現時点では，まだ指定していない。
これは、
`課題 #2900＠~HTMLissue/2900$
にて追跡されている。
◎
We do not currently have a spec for how to handle multiple `Refresh` headers. This is tracked as issue #2900.
</p>
	</li>
	<li>
%早期~hintを~commitする ~LET %~navi~params の`早期~hintを~commitする$nvP
◎
↓</li>
	<li>
~IF［
%早期~hintを~commitする ~NEQ ~NULL
］
⇒
%早期~hintを~commitする( %文書 )
◎
If navigationParams's commit early hints is not null, then call navigationParams's commit early hints with document.
</li>
	<li>
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `pre-media^l )
◎
Process link headers given document, navigationParams's response, and "pre-media".
</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<div class="example">
<p>
次の例では、
子~文書（ `b.html^c ）には `PaymentRequest$I の利用は許容されない
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$であっても。
子~文書が初期化された時点では、
`document.domain$c は 親~文書にのみ設定されていて，子~文書にはまだ設定されてない。
◎
In this example, the child document is not allowed to use PaymentRequest, despite being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, only the parent document has set document.domain, and the child document has not.
</p>

<pre class="lang-html">&lt;!-- https://foo.example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
document.domain = 'example.com';
&lt;/script&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
</pre>

<pre class="lang-html">&lt;!-- https://bar.example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
document.domain = 'example.com'; /* <span class="comment">
これは、
文書が初期化された後に起こる。
◎
This happens after the document is initialized
</span> */
new PaymentRequest(…); /* <span class="comment">
利用は許容されない
◎
Not allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

<div class="example">
<p>
次の例では、
子~文書には `PaymentRequest$I の利用は<em>許容される</em>
— 子~文書が それを利用しようと試行した時点では，`同じ生成元~domain$でなくとも。
子~文書が初期化される時点では，どちらの文書にも まだ `document.domain$c は設定されていないので、
`同じ生成元~domain$の検査は，通常の`同一-生成元$の検査に~fall-backする。
◎
In this example, the child document is allowed to use PaymentRequest, despite not being same origin-domain at the time the child document tries to use it. At the time the child document is initialized, none of the documents have set document.domain yet so same origin-domain falls back to a normal same origin check.
</p>

<pre class="lang-html">&lt;!-- https://example.com/a.html --&gt;
&lt;!doctype html&gt;
&lt;iframe src=b.html&gt;&lt;/iframe&gt;
&lt;!-- <span class="comment">
子~文書は、
下の~scriptが走る前の，この時点で初期化-済み。
◎
The child document is now initialized, before the script below is run.
</span> --&gt;
&lt;script&gt;
document.domain = 'example.com';
&lt;/script&gt;
</pre>

<pre class="lang-html">&lt;!-- https://example.com/b.html --&gt;
&lt;!doctype html&gt;
&lt;script&gt;
new PaymentRequest(…); /* <span class="comment">
利用は許容される
◎
Allowed to use
</span> */
&lt;/script&gt;
</pre>
</div>

			</section>
			<section id="read-html">
<h4 title="Loading HTML documents">7.5.2. ~HTML文書の読込n法</h4>

<div class="algo">
<p>
`~HTML文書を読込む@
ときは、
所与の
( `~navi~params$ %~navi~params )
に対し：
◎
To load an HTML document, given navigation params navigationParams:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
新たな`~HTML構文解析器$ %構文解析器 を作成して %文書 に結付ける
— ~UAは、
以下に挙げる各項に従うモノトスル：
◎
Create an HTML parser and associate it with the document.＼
</p>
		<ul>
			<li>
~fetchingを走らせている間に`~network用~task源$から`~task~queue$に設置される各`~task$には、
%構文解析器 への`入力~byte~stream$を~fetchされた~byte列で埋めた上で，
入力~streamの適切な処理を %構文解析器 に遂行させる。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</li>
			<li>
前項の`~task$のうち，最初に設置されたものは、
%構文解析器 により処理された後に，次を走らす
⇒
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the HTML parser.
</li>
			<li>
<p>
%文書 用に`~scriptを走らせてもよい$とされる時点まで，~script実行は生じさせない。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for document.
</p>

<p class="note">注記：
`入力~byte~stream$に渡された~byte列は、文字~並びに変換されて`~tokenizer$に渡される。
この処理nの一部は、
資源の~~真の `~Content-Type~metadata$から見出される文字~符号化法~情報に依拠する
— 資源から`算出される~MIME型$は、
その目的には利用されない。
◎
The input byte stream converts bytes into characters for use in the tokenizer. This process relies, in part, on character encoding information found in the real Content-Type metadata of the resource; the computed type is not used for this purpose.
</p>
			</li>
			<li>
可用な~byte列が尽きたときは、
次を走らす`大域~taskを~queueする$( `~network用~task源$, %文書 に`関連な大域~obj$ )
⇒
構文解析器に暗黙の~EOF文字を処理させる
（これは、最終的に `load$et ~eventを発火させることになる）
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given document's relevant global object to have the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
		</ul>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

			</section>
			<section id="read-xml">
<h4 title="Loading XML documents">7.5.3. ~XML文書の読込n法</h4>

<div class="algo">
<p>
~UAは，~XML~fileを~inlineに表示することになった場合には、
供された
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し，
次に挙げる各種 仕様
⇒＃
`XML^cite `XML$r,
`Namespaces in XML^cite `XMLNS$r,
`XML Media Types^cite `RFC7303$r,
`DOM^cite `DOM$r,
関連な他の仕様
◎終
に定義される要件に従う下で，次を行うモノトスル：
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `xml^l, %~MIME型, %~navi~params )
</li>
	<li>
対応する`~XML構文解析器$を作成する
</li>
	<li>
~RET %文書
</li>
</ol>
◎
When faced with displaying an XML file inline, provided navigation params navigationParams and a string type, user agents must follow the requirements defined in XML and Namespaces in XML, XML Media Types, DOM, and other relevant specifications to create and initialize a Document object document, given "xml", type, and navigationParams, and return that Document. They must also create a corresponding XML parser. [XML] [XMLNS] [RFC7303] [DOM]
</div>

<p class="note">注記：
これを書いている時点では，~XML仕様~communityは、
実際には，~XMLと~DOMとがどう相互作用するか まだ指定していない。
◎
At the time of writing, the XML specification community had not actually yet specified how XML and the DOM interact.
</p>

<p>
~UAは、
作成した`文書$ %文書 に対し，以下に挙げる各項に従うモノトスル：
◎
↓</p>
<ul>
	<li>
~fetchingを走らす間に［
`~network用~task源$から`~task~queue$に対し設置された最初の`~task$
］は、
`~XML構文解析器$により処理された後に，次を走らす
⇒
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the XML parser.
</li>
	<li>
［
上に挙げた各 仕様の規則に則って，文字~符号化法を決定する
］ときには、［
実際の~HTTP~headerや他の~metadata
］のうち［
この仕様が与える~algoにより［
変異される／含意される
］~header
］でないものを利用した上で、
%文書 の`符号化法$docは，そのように確立された符号化法に設定する。
◎
The actual HTTP headers and other metadata, not the headers as mutated or implied by the algorithms given in this specification, are the ones that must be used when determining the character encoding according to the rules given in the above specifications. Once the character encoding is established, the document's character encoding must be set to that character encoding.
</li>
	<li>
%文書 用に`~scriptを走らせてもよい$とされる時点まで，~script実行は生じさせない。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for the newly-created Document.
</li>
	<li>
<p>
構文解析が完了したなら、
%文書 の`~navi~ID$docを ~NULL に設定する。
◎
Once parsing is complete, the user agent must set document's navigation id to null.
</p>

<p class="note">注記：
~HTML文書に対しては，これは、
構文解析を完了したとき `load^et ~eventを発火した後に設定し直される
◎
For HTML documents this is reset when parsing is complete, after firing the load event.
</p>
	</li>
</ul>

<p>
~UAは、
構文解析-時の~error（例： ~XML名前空間 整形式性~error）に際しては，
当の`文書$を変異して~inlineに報告してもヨイ。
◎
Error messages from the parse process (e.g., XML namespace well-formedness errors) may be reported inline by mutating the Document.
</p>

			</section>
			<section id="read-text">
<h4 title="Loading text documents">7.5.4. ~text文書の読込n法</h4>

<div class="algo">
<p>
`~text文書を読込む@
ときは、
所与の
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し：
◎
To load a text document, given a navigation params navigationParams and a string type:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
%文書 の`構文解析器は~modeを変更できないか$ ~SET ~T
◎
Set document's parser cannot change the mode flag to true.
</li>
	<li>
%文書 の`~mode$doc ~SET `no-quirks^l
◎
Set document's mode to "no-quirks".
</li>
	<li>
<p>
新たな`~HTML構文解析器$を作成して %文書 に結付ける
— ~UAは、
以下に挙げる各項に従うモノトスル：
◎
Create an HTML parser and associate it with the document.＼
</p>
		<ul>
			<li>
この構文解析器は、
その~tokenizerが すでに次を順に行ったかのように動作する
⇒＃
~tag名 `pre^l の開始~tag~tokenを発した；
1 個の文字 <span class="code-point">U+000A</span> （LF）を発した；
`~PLAINTEXT状態$に切替えた
◎
Act as if the tokenizer had emitted a start tag token with the tag name "pre" followed by a single U+000A LINE FEED (LF) character, and switch the HTML parser's tokenizer to the PLAINTEXT state.＼
</li>
			<li>
~fetchingを走らせている間に`~network用~task源$から`~task~queue$に設置される各`~task$は、
構文解析器の`入力~byte~stream$を~fetchされた~byte列で埋めて，構文解析器に入力~streamの適切な処理を遂行させるモノトスル。
◎
Each task that the networking task source places on the task queue while fetching runs must then fill the parser's input byte stream with the fetched bytes and cause the HTML parser to perform the appropriate processing of the input stream.
</li>
			<li>
%文書 の`符号化法$docは、
当の文書を復号する間に利用した文字~符号化法に設定する。
◎
document's encoding must be set to the character encoding used to decode the document during parsing.
</li>
			<li>
前述の`~task$のうち，最初に設置されたものは、
%構文解析器 により処理された後に，次を走らす
⇒
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
The first task that the networking task source places on the task queue while fetching runs must process link headers given document, navigationParams's response, and "media", after the task has been processed by the HTML parser.
</li>
			<li>
%文書 用に`~scriptを走らせてもよい$とされる時点まで，~script実行は生じさせない。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for document.
</li>
			<li>
可用な~byte列が尽きたときは、
次を走らす`大域~taskを~queueする$( `~network用~task源$, %文書 に`関連な大域~obj$ )
⇒
構文解析器に暗黙の~EOF文字を処理させる
（これは、最終的に `load$et ~eventを発火させることになる）
◎
When no more bytes are available, the user agent must queue a global task on the networking task source given document's relevant global object to have the parser to process the implied EOF character, which eventually causes a load event to be fired.
</li>
		</ul>
	</li>
	<li>
<p>
任意選択で
⇒
%文書 の `head$e 要素に内容を追加する
— 例：
~stylesheetへ~linkする,
~scriptを供する,
文書に `title$e を与える,
等々。
◎
User agents may add content to the head element of document, e.g., linking to a style sheet, providing script, or giving the document a title.
</p>

<p class="note">注記：
特に、
 RFC 3676 の `Format=Flowed^c 特能を~supportする~UAは、［
~textを正しく折返す／
【行頭の "&gt;" による】 引用用の特能を取扱う
］ために，何らかの~styleを適用する必要が生じることになる。
これは、
例えば~CSS拡張を利用して遂行することもできる。
◎
In particular, if the user agent supports the Format=Flowed feature of RFC 3676 then the user agent would need to apply extra styling to cause the text to wrap correctly and to handle the quoting feature. This could be performed using, e.g., a CSS extension.
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<p>
素な~text文書の~byte列を
実際の文字に変換する規則，および
その~textを利用者~向けに実際に具現化する規則は、
当の資源から`算出される~MIME型$（すなわち， %~MIME型 ）の仕様により定義される。
◎
The rules for how to convert the bytes of the plain text document into actual characters, and the rules for actually rendering the text to the user, are defined by the specifications for the computed MIME type of the resource (i.e., type).
</p>

			</section>
			<section id="read-multipart-x-mixed-replace">
<h4 title="Loading multipart/x-mixed-replace documents">7.5.5. `multipart/x-mixed-replace$mt 文書の読込n法</h4>

<div class="algo">
<p>
`multipart/x-mixed-replace 文書を読込む@
ときは、
所与の
( `~navi~params$ %~navi~params, `~source~snapshot~params$ %~source~snapshot~params, `生成元$ %起動元~生成元 )
に対し：
◎
To load a multipart/x-mixed-replace document, given navigation params navigationParams, source snapshot params sourceSnapshotParams, and origin initiatorOrigin:
</p>
<ol>
	<li>
%~navi~params の`応答$nvPの`本体$rsを
`RFC2046$r による複-部位t（ `multipart^c ）型~用の規則を利用して構文解析する
◎
Parse navigationParams's response's body using the rules for multipart types. [RFC2046]
</li>
	<li>
%最初の部位t用の~navi~params ~LET %~navi~params の複製
◎
Let firstPartNavigationParams be a copy of navigationParams.
</li>
	<li>
%最初の部位t用の~navi~params の`応答$nvP ~SET 
%~navi~params の`応答$nvPの`本体$rsの複-部位t~streamを成す最初の部位tを表現している新たな`応答$
◎
Set firstPartNavigationParams's response to a new response representing the first part of navigationParams's response's body's multipart stream.
</li>
	<li>
<p>
%文書 ~LET `文書を読込む$( %最初の部位t用の~navi~params, %~source~snapshot~params,
%起動元~生成元 )
◎
Let document be the result of loading a document given firstPartNavigationParams, sourceSnapshotParams, and initiatorOrigin.
</p>

<p>
%~navi~params の`応答$nvPから得された 2 個目以降の各 本体~部位tに対しては、
~UAは，次を行うモノトスル
⇒
`~navigableを~URLへ~navigateする$( %文書 の`~node~navigable$, %~navi~params の`要請$nvPの`~URL$rq, %文書 )
— 次を与える下で
⇒＃
`応答$i ~SET %~navi~params の`応答$nvP
`履歴~取扱い$i ~SET `置換-$i
◎
For each additional body part obtained from navigationParams's response, the user agent must navigate document's node navigable to navigationParams's request's URL, using document, with response set to navigationParams's response and historyHandling set to "replace".
</p>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>
</div>

<p>
~UAは、
これらの［
各 本体~部位tを完全に自立的な資源であったかのように処理する目的
］においては、
各 本体~部位tに対し［
それに後続する境界に達した所で，当の資源~用の~byte列は尽きた
］かのように動作するモノトスル。
◎
For the purposes of algorithms processing these body parts as if they were complete stand-alone resources, the user agent must act as if there were no more bytes for those resources whenever the boundary following the body part is reached.
</p>

<p class="note">注記：
したがって， `load$et ~event（および，対になる `unload$et ~event）は、
各 本体~部位tが読込まれる度に発火されることになる。
◎
Thus, load events (and for that matter unload events) do fire for each body part loaded.
</p>

			</section>
			<section id="read-media">
<h4 title="Loading media documents">7.5.6. ~media文書の読込n法</h4>

<div class="algo">
<p>
`~media文書を読込む@
ときは、
所与の
( `~navi~params$ %~navi~params, 文字列 %~MIME型 )
に対し：
◎
To load a media document, given navigationParams and a string type:
</p>
<ol>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, %~MIME型, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", type, and navigationParams.
</li>
	<li>
%文書 の`~mode$doc ~SET `no-quirks^l
◎
Set document's mode to "no-quirks".
</li>
	<li>
%文書 に新たな `html$e 要素を付加する
◎
Append an html element to document.
</li>
	<li>
`html$e 要素に新たな `head$e 要素を付加する
◎
Append a head element to the html element.
</li>
	<li>
`html$e 要素に新たな `body$e 要素を付加する
◎
Append a body element to the html element.
</li>
	<li>
%~host要素 ~LET ［
資源の~media型に応じて，次に与える型
］の新たな要素
⇒＃
画像ならば `img$e ／
動画ならば `video$e ／
音声ならば `audio$e
◎
↓</li>
	<li>
`body$e 要素に %~host要素 を付加する
◎
Append an element host element for the media,＼
↓↓as described below, to the body element.
</li>
	<li>
%~host要素 の［
資源の~media型に応じて，次に与える属性
］の値 ~SET 資源の~address
⇒＃
画像ならば `src＠~HEimages#attr-img-src$a ／
動画または音声ならば `src＠~HEmedia#attr-media-src$a ／
◎
Set the appropriate attribute of the element host element, as described below, to the address of the image, video, or audio resource.
◎
↓↓</li>
	<li>
<p>
任意選択で
⇒＃
%文書 の `head$e 要素に内容を追加する／
%~host要素 に属性を追加する
◎
User agents may add content to the head element of document, or attributes to host element,＼
</p>

<p>
例
⇒＃
ある~stylesheetへ~linkする
ある~scriptを供する／
当の文書に `title$e を与えする／
当の~mediaを `autoplay$a にする
◎
e.g., to link to a style sheet, to provide a script, to give the document a title, or to make the media autoplay.
</p>
	</li>
	<li>
`~link~header群を処理する$( %文書, %~navi~params の`応答$nvP, `media^l )
◎
Process link headers given document, navigationParams's response, and "media".
</li>
	<li>
%文書 の`構文解析を停止した$かのように動作する
◎
Act as if the user agent had stopped parsing document.
</li>
	<li>
~RET %文書
◎
Return document.
◎
↑↑ The element host element to create for the media is the element given in the table below in the second cell of the row whose first cell describes the media. The appropriate attribute to set is the one given by the third cell in that same row.
◎
↑↑ Type of media｜Element for the media｜Appropriate attribute
Image｜img｜src
Video｜video｜src
Audio｜audio｜src
</li>
</ol>
</div>

<p>
~UAは、
`文書$用に`~scriptを走らせてもよい$とされる時点まで，
~script実行は生じさせないモノトスル。
◎
Before any script execution occurs, the user agent must wait for scripts may run for the newly-created document to be true for the Document.
</p>

			</section>
			<section id="read-ua-inline">
<h4 title="Loading a document for inline content that doesn't have a DOM">7.5.7. ~DOMを有さない~inline内容~用の文書の読込n法</h4>

<div class="algo">
<p>
~UAは，［
~UA~page／~PDF~viewer
］を~inlineに表示するための文書を作成するときは、
供された
( `~navigable$ %~navigable,
`~navi~ID$ %~navi~ID,
`NavigationTimingType$I %~navi計時~種別 )
に対し，次に従うベキである：
◎
When the user agent is to create a document to display a user agent page or PDF viewer inline, provided a navigable navigable, a navigation ID navigationId, a NavigationTimingType navTimingType, the user agent should:
</p>
<ol>
	<li>
%生成元 ~LET 新たな`不透明な生成元$
◎
Let origin be a new opaque origin.
</li>
	<li>
%~COOP ~LET 新たな`非同一-生成元~opener施策$
◎
Let coop be a new cross-origin opener policy.
</li>
	<li>
%~COOP施行n結果 ~LET 新たな`非同一-生成元~opener施策の施行n結果$
— その
⇒＃
`~URL$cooP ~SET %応答 の`~URL$rs,
`生成元$cooP ~SET %生成元,
`非同一-生成元~opener施策$cooP ~SET %~COOP
◎
Let coopEnforcementResult be a new cross-origin opener policy enforcement result with
◎
url
• response's URL
origin
• origin
cross-origin opener policy
• coop
</li>
	<li>
%~navi~params ~LET 新たな`~navi~params$
— その
⇒＃
`~ID$nvP ~SET %~navi~ID,
`要請$nvP ~SET ~NULL,
`応答$nvP ~SET 新たな`応答$,
`生成元$nvP ~SET %生成元,
`施策~容器$nvP ~SET 新たな`施策~容器$,
`最終-~sandbox~flag集合$nvP ~SET 空な集合,
`非同一-生成元~opener施策$nvP ~SET %COOP,
`~COOP施行n結果$nvP ~SET %~COOP施行n結果,
`予約-済み環境$nvP ~SET ~NULL,
`~navigable$nvP ~SET %~navigable,
`~navi計時~種別$nvP ~SET %~navi計時~種別,
`~fetch制御器$nvP ~SET ~fetch制御器【新たな`~fetch制御器$？】,
`早期~hintを~commitする$nvP ~SET ~NULL
◎
Let navigationParams be a new navigation params with
◎
id
• navigationId
request
• null
response
• a new response
origin
• origin
policy container
• a new policy container
final sandboxing flag set
• an empty set
cross-origin opener policy
• coop
COOP enforcement result
• coopEnforcementResult
reserved environment
• null
navigable
• navigable
navigation timing type
• navTimingType
fetch controller
• fetch controller
commit early hints
• null
</li>
	<li>
%文書 ~LET `文書を作成して初期化する$( `html^l, `text/html^l, %~navi~params )
◎
Let document be the result of creating and initializing a Document object given "html", "text/html", and navigationParams.
</li>
	<li>
<p>
次のいずれかを行う：
◎
Either＼
</p>
		<ul>
			<li>
%文書 を［
`文書$の通常の具現化~規則を利用して具現化されない
］ような~customな具現化に結付ける
◎
associate document with a custom rendering that is not rendered using the normal Document rendering rules, or＼
</li>
			<li>
%文書 を［
それが~UAが具現化しようと求める内容を表現する
］よう変異させる
◎
mutate document until it represents the content the user agent wants to render.
</li>
		</ul>
	</li>
	<li>
~RET %文書
◎
Return document.
</li>
</ol>

<p class="note">注記：
結果の`文書$は、
その`生成元$docは`不透明な生成元$になるよう確保され，
~DOMへの~accessを伴う~scriptを走らすことはないので、
この文書の存在, その~propは，~web開発者~codeからは観測-可能にならない。
このことは、
上の値のうち ほとんど
— 例： `種別$doc `text/html$mt —
は~~関心事にならないことを意味する。
類似に，
%~navi~params を成す ほとんどの~itemは、
~~形式上のものでしかなく，観測-可能な効果を伴うことはない
— なので、
既定の値に設定される。
◎
Because we ensure the resulting Document's origin is opaque, and the resulting Document cannot run script with access to the DOM, the existence and properties of this Document are not observable to web developer code. This means that most of the above values, e.g., the text/html type, do not matter. Similarly, most of the items in navigationParams don't have any observable effect, besides preventing the Document-creation algorithm from getting confused, and so are set to default values.
</p>
</div>

<p>
~UAは、
~pageが設定しておかれたなら，`構文解析を停止した$かのように動作するモノトスル。
◎
Once the page has been set up, the user agent must act as if it had stopped parsing.
</p>

			</section>
			<section id="loading-documents">
<h4 title="Finishing the loading process">7.5.8. 読込ng処理nの完遂-法</h4>

<p>
各 `文書$には
`完全に読込まれた時刻@
（ある時刻または ~NULL ）がある
— 初期~時は ~NULL とする。
◎
A Document has a completely loaded time (a time or null), which is initially null.
</p>

<p>
所与の`文書$は、
その`完全に読込まれた時刻$ ~NEQ ~NULL ならば，
`完全に読込まれた@
ものと見なされる。
◎
A Document is considered completely loaded if its completely loaded time is non-null.
</p>

<div class="algo">
<p>
`文書$ %文書 の
`読込ngを完全に終わらす@
ときは：
◎
To completely finish loading a Document document:
</p>
<ol>
	<li>
~Assert：
%文書 が`属する閲覧~文脈$ ~NEQ ~NULL
◎
Assert: document's browsing context is non-null.
</li>
	<li>
%文書 の`完全に読込まれた時刻$ ~SET 現在の時刻
◎
Set document's completely loaded time to the current time.
</li>
	<li>
<p>
%容器 ~LET %文書 の`~node~navigable$の`容器$nav
◎
Let container be document's node navigable's container.
</p>

<div class="note">
<p>注記：
これは、
%文書 が［
`iframe$e ／ `frame$e
］内の`初期~about_blank な文書$である事例では， ~NULL になる
— この~algoを~callする`新たな閲覧~文脈と文書を作成する$時点では、
当の容器~関係性は，まだ確立されていないので
（それが起こる段は、
`新たな入子な~navigableを作成する$ときである）。
◎
This will be null in the case where document is the initial about:blank Document in a frame or iframe, since at the point of browsing context creation which calls this algorithm, the container relationship has not yet been established. (That happens in a subsequent step of create a new nested navigable.)
</p>

<p>
その帰結として、
以降の手続きは，何もしなくなる
— すなわち，そのような事例では、
`load$et ~eventは， %容器 に向けて非同期的には発火されなくなる。
代わりに，その~eventは、
`~iframe属性~群を処理する$ときに，ある特別な初期~挿入~事例において同期的に発火される。
◎
The consequence of this is that the following steps do nothing, i.e., we do not fire an asynchronous load event on the container element for such cases. Instead, a synchronous load event is fired in a special initial-insertion case when processing the iframe attributes.
</p>
</div>
	</li>
	<li>
~IF［
%容器 は `iframe$e 要素である
］
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %容器 )
⇒
`~iframe~load~event手続き$( %容器 )
◎
If container is an iframe element, then queue an element task on the DOM manipulation task source given container to run the iframe load event steps given container.
</li>
	<li>
~ELIF［
%容器 ~NEQ ~NULL
］
⇒
次を走らす`要素~taskを~queueする$( `~DOM操作~task源$, %容器 )
⇒
`~eventを発火する$( %容器, `load$et )
◎
Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.
</li>
</ol>
</div>

			</section>
			<section id="unloading-documents">
<h4 title="Unloading documents">7.5.9. 文書の~unload法</h4>

<p>
各 `文書$は、
次に挙げるものを持つ：
</p>
<ul>
	<li>
`回復可能か@doc
⇒
真偽値
— 初期~時は ~T になるモノトスル。
◎
A Document has a salvageable state, which must initially be true,＼
</li>
	<li>
<p>
`~pageを示しているか@doc
⇒
真偽値
— 初期~時は ~F になるモノトスル。
◎
and a page showing flag, which must initially be false.＼
</p>

<p>
これは、
次を確保するために利用される
⇒
~scriptが［
`pageshow$et, `pagehide$et
］~eventを整合的に受取る
（例： `pageshow$et を間に挟むことなく 2 つの `pagehide$et ~eventを続けて受取ったり，その逆が生じることは決してない）。
◎
The page showing flag is used to ensure that scripts receive pageshow and pagehide events in a consistent manner (e.g. that they never receive two pagehide events in a row without an intervening pageshow, or vice versa).
</p>
	</li>
	<li>
`休止~時刻@doc
⇒
`DOMHighResTimeStamp$I 値
— 初期~時は 0 とする。
◎
A Document has a DOMHighResTimeStamp suspension time, initially 0.
</li>
	<li>
`休止された~timer~handle群@doc
⇒
`~list$
— 初期~時は空とする。
◎
A Document has a list of suspended timer handles, initially empty.
</li>
</ul>

<p>
各`~event~loop$には、
`終了n入子ng~level@
と呼ばれる~counterがある
— 初期~時には 0 になるモノトスル。
◎
Event loops have a termination nesting level counter, which must initially be 0.
</p>

<p>
各 `文書$には、
`~unload~counter@
がある
— 初期~時は 0 に設定するモノトスル。
それは、
以下の各種~algoが走っている間，ある種の演算を無視するために利用される。
◎
Document objects have an unload counter, which is used to ignore certain operations while the below algorithms run. Initially, the counter must be set to zero.
</p>

<div class="algo">
<p>
`文書を~unloadする@
ときは、
所与の
( `文書$ %旧-文書, 所与の `文書$ %新-文書（省略時は ε ） )
に対し：
◎
To unload a Document oldDocument, given an optional Document newDocument:
</p>
<ol>
	<li>
~Assert：
この~algoは、
%旧-文書 の`~event~loop$に~queueされた`~task$の一部として走っている。
◎
Assert: this is running as part of a task queued on oldDocument's event loop.
</li>
	<li>
%~unload計時~情報 ~LET 新たな`文書~unload計時~情報$
◎
Let unloadTimingInfo be a new document unload timing info.
</li>
	<li>
<p>
~IF［
%新-文書 ~EQ ε
］
⇒
%~unload計時~情報 ~SET ~NULL
◎
If newDocument is not given, then set unloadTimingInfo to null.
</p>

<p class="note">注記：
この事例では、［
%旧-文書 を~unloadするのに，いつまでかかるか
］を知る必要がある新たな文書は無い。
◎
In this case there is no new document that needs to know about how long it took oldDocument to unload.
</p>
	</li>
	<li>
<p>
~ELIF［
%新-文書 の`~event~loop$ ~NEQ %旧-文書 の`~event~loop$
］
⇒
~UAは、
次を`並列的$に行ってもヨイ
⇒
`文書を~unloadする$( %旧-文書 )
— その場合【行う場合？】、
%~unload計時~情報 を ~NULL に設定するベキである。
◎
Otherwise, if newDocument's event loop is not oldDocument's event loop, then the user agent may be unloading oldDocument in parallel. In that case, the user agent should set unloadTimingInfo to null.
</p>

<p class="note">注記：
この事例では
%新-文書 の読込ngは、［
%旧-文書 を~unloadするのに，いつまでかかるか
］により影響iされないので、
その計時~情報を~~伝えることも無意味になる。
◎
In this case newDocument's loading is not impacted by how long it takes to unload oldDocument, so it would be meaningless to communicate that timing info.
</p>
	</li>
	<li>
%~BF~cache内に保つか ~LET ~F
◎
↓</li>
	<li>
<p>
~IF［
%旧-文書, および その どの子孫に対しても、［
その`回復可能か$doc ~EQ ~T
］~AND［
~UAは［
後で`履歴~辿り用に利用できる＠~HTMLnav#note-bfcache$よう，
`~session履歴~entry$内に生存し続けるよう意図する
］
⇒
%~BF~cache内に保つか ~SET ~T
◎
Let intendToStoreInBfcache be true if the user agent intends to keep oldDocument alive in a session history entry, such that it can later be used for history traversal.
◎
This must be false if oldDocument is not salvageable, or if there are any descendants of oldDocument which the user agent does not intend to keep alive in the same way (including due to their lack of salvageability).
</p>
	</li>
	<li>
%~event~loop ~LET %旧-文書 に`関連な~agent$の`~event~loop$aG
◎
Let eventLoop be oldDocument's relevant agent's event loop.
</li>
	<li>
%~event~loop の`終了n入子ng~level$ ~INCBY 1
◎
Increase eventLoop's termination nesting level by 1.
</li>
	<li>
%旧-文書 の`~unload~counter$ ~INCBY 1
◎
Increase oldDocument's unload counter by 1.
</li>
	<li>
~IF［
%~BF~cache内に保つか ~EQ ~F
］
⇒
%旧-文書 の`回復可能か$doc ~SET ~F
◎
If intendToKeepInBfcache is false, then set oldDocument's salvageable state to false.
</li>
	<li>
<p>
~IF［
%旧-文書 の`~pageを示しているか$doc ~EQ ~T
］：
◎
If oldDocument's page showing is true:
</p>
		<ol>
			<li>
%旧-文書 の`~pageを示しているか$doc ~SET ~F
◎
Set oldDocument's page showing to false.
</li>
			<li>
`~page遷移~eventを発火する$( %旧-文書 に`関連な大域~obj$, `pagehide$et, %旧-文書 の`回復可能か$doc )
◎
Fire a page transition event named pagehide at oldDocument's relevant global object with oldDocument's salvageable state.
</li>
			<li>
`可視性~状態を更新する$( %旧-文書, `hidden^l )
◎
Update the visibility state of oldDocument to "hidden".
</li>
		</ol>
	</li>
	<li>
<!-- 
細かさを抑えた時刻は，
現在の高分解能~時刻の中でも遂行されていて冗長に見えるが、
2 個目の引数に異なるものを［
渡すので，必要になる／
渡して，二重に適用する必要がある
］。
-->
~IF［
%~unload計時~情報 ~NEQ ~NULL
］
⇒
%~unload計時~情報 の`~unload~event開始~時刻$ ~SET
`細かさを抑えた時刻$( `現在の高分解能~時刻$( %新-文書 に`関連な大域~obj$ ), %旧-文書 に`関連な設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV )
◎
If unloadTimingInfo is not null, then set unloadTimingInfo's unload event start time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.
</li>
	<li>
~IF［
%旧-文書 の`回復可能か$doc ~EQ ~F
］
⇒
`~eventを発火する$( %旧-文書 に`関連な大域~obj$, `unload$et )
— `~targetを上書きする^i 下で
◎
If oldDocument's salvageable state is false, then fire an event named unload at oldDocument's relevant global object, with legacy target override flag set.
</li>
	<li>
~IF［
%~unload計時~情報 ~NEQ ~NULL
］
⇒
%~unload計時~情報 の`~unload~event終了~時刻$ ~SET
`細かさを抑えた時刻$( `現在の高分解能~時刻$( %新-文書 に`関連な大域~obj$ ), %旧-文書 に`関連な設定群~obj$の`非同一-生成元~能力は隔離されるか？$enV )
◎
If unloadTimingInfo is not null, then set unloadTimingInfo's unload event end time to the current high resolution time given newDocument's relevant global object, coarsened given oldDocument's relevant settings object's cross-origin isolated capability.
</li>
	<li>
%~event~loop の`終了n入子ng~level$ ~DECBY 1
◎
Decrease eventLoop's termination nesting level by 1.
</li>
	<li>
%旧-文書 の`休止~時刻$doc ~SET `現在の高分解能~時刻$( %文書【%旧-文書】 に`関連な大域~obj$ )
◎
Set oldDocument's suspension time to the current high resolution time given document's relevant global object.
</li>
	<li>
%旧-文書 の`休止された~timer~handle群$doc ~SET `~key群を取得する$( 【 %旧-文書 に`関連な大域~obj$の】`作動中の~timer群が成す~map$ )
◎
Set oldDocument's suspended timer handles to the result of getting the keys for the map of active timers.
</li>
	<li>
%旧-文書 の`利用者により~scrollされたか$doc ~SET ~F
◎
Set oldDocument's has been scrolled by the user to false.
</li>
	<li>
この仕様も含む`適用-可能な仕様$にて定義される
`文書~unload時の片付け手続き$があれば、
それらの各~手続きを %旧-文書 を渡して走らす
【手続きが複数ある場合に，どの順序で走らすかは、指定されていない。】
◎
Run any unloading document cleanup steps for oldDocument that are defined by this specification and other applicable specifications.
</li>
	<li>
~IF［
%旧-文書 の`回復可能か$doc ~EQ ~F
］
⇒
`文書を破壊する$( %旧-文書 )
◎
If oldDocument's salvageable state is false, then destroy oldDocument.
</li>
	<li>
%旧-文書 の`~unload~counter$ ~DECBY 1
◎
Decrease oldDocument's unload counter by 1.
</li>
	<li>
~IF［
%新-文書 ~NEQ ε
］~AND［
%新-文書 の`非同一-生成元~redirectを介して作成されたか$doc ~EQ ~F
］~AND［
( %新-文書 の`生成元$doc, %旧-文書 の`生成元$doc )
は`同一-生成元$である
］
⇒
%新-文書 の`前-文書の~unload計時~情報$doc ~SET %~unload計時~情報
◎
If newDocument is given, newDocument's was created via cross-origin redirects is false, and newDocument's origin is the same as oldDocument's origin, then set newDocument's previous document unload timing to unloadTimingInfo.
</li>
</ol>
</div>

<div class="algo">
<p>
この仕様は、
`文書~unload時の片付け手続き@
として，次を定義する
— 他の仕様も，この手続きをさらに定義し得る。
それは、
所与の
( `文書$ %文書 )
に対し：
◎
This specification defines the following unloading document cleanup steps. Other specifications can define more. Given a Document document:
</p>
<ol>
	<li>
%~window ~LET %文書 に`関連な大域~obj$
◎
Let window be document's relevant global object.
</li>
	<li>
~EACH( `WebSocket$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒＃
%O を`消滅させる$；
%文書 の`回復可能か$doc ~SET ~F
◎
For each WebSocket object webSocket whose relevant global object is window, make disappear webSocket.
◎
If this affected any WebSocket objects, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 の`回復可能か$doc ~EQ ~F
］：
◎
If document's salvageable state is false, then:
</p>
		<ol>
			<li>
~EACH( `EventSource$I ~obj %O )
に対し
⇒
~IF［
%O に`関連な大域~obj$ ~EQ %~window
］
⇒
%O を`強制的に~closeする$
◎
For each EventSource object eventSource whose relevant global object is equal to window, forcibly close eventSource.
</li>
			<li>
%~window にて`作動中の~timer群が成す~map$を`~clearする$map
◎
Clear window's map of active timers.
</li>
		</ol>
	</li>
</ol>
</div>

			</section>
			<section id="destroying-documents">
<h4 title="Destroying documents">7.5.10. 文書の破壊-法</h4>

<div class="algo">
<p>
`文書を破壊する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To destroy a Document document:
</p>
<ol>
	<li>
%文書 の`子孫~navigable群$を成す
~EACH( %~navigable )
に対し
<span class="XXX">順序は どうする？</span>
⇒
`文書を破壊する$( ~navigableにて`作動中の文書$nav )
◎
Destroy the active documents of each of document's descendant navigables. In what order?
</li>
	<li>
%文書 の`回復可能か$doc ~SET ~F
◎
Set document's salvageable state to false.
</li>
	<li>
この仕様も含む`適用-可能な仕様$に定義される`文書~unload時の片付け手続き$があれば、
それらの各~手続きを %文書 を渡して走らす
【手続きが複数ある場合に，どの順序で走らすかは、
指定されていない。】
◎
Run any unloading document cleanup steps for document that are defined by this specification and other applicable specifications.
</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
	<li>
~queueされた`~task$のうち，［
その`文書$tK ~EQ %文書
］なるものは、
（~taskを走らすことなく）除去する
◎
Remove any tasks whose document is document from any task queue (without running those tasks).
</li>
	<li>
%文書 が`属する閲覧~文脈$ ~SET ~NULL
◎
Set document's browsing context to null.
</li>
	<li>
%文書 の`~node~navigable$にて`作動中の~entry$nav の`文書~状態$shE の`文書$dS ~SET ~NULL
◎
Set document's node navigable's active session history entry's document state's document to null.
</li>
	<li>
~EACH( `WorkerGlobalScope$I ~obj %O )
に対し
⇒
%O の`所有者~集合$wGから %文書 を`除去する$
◎
Remove document from the owner set of each WorkerGlobalScope object whose set contains document.
</li>
	<li>
%文書 の`~worklet大域~scope~list$docを成す
~EACH( %~worklet大域~scope )
に対し：
`~worklet大域~scopeを終了させる$( %~worklet大域~scope )
◎
For each workletGlobalScope in document's worklet global scopes, terminate workletGlobalScope.
</li>
</ol>

<p class="note">注記：
`入子な~navigableを破壊-$している事例においては、
破壊の後でも，［
当の`文書$は、
依然として~scriptから~access可能
］かもしれない。
◎
Even after destruction, the Document object itself might still be accessible to script, in the case where we are destroying a nested navigable.
</p>
</div>

			</section>
			<section id="aborting-a-document-load">
<h4 title="Aborting a document load">7.5.11. 文書~読込nの中止-法</h4>

<div class="algo">
<p>
`文書を中止する@
ときは、
所与の
( `文書$ %文書 )
に対し：
◎
To abort a Document document:
</p>
<ol>
	<li>
<p>
%文書 の`子孫~navigable群$を成す
~EACH( %~navigable )
に対し
<span class="XXX">順序は どうする？</span>：
</p>
		<ol>
			<li>
%作動中の文書 ~LET ~navigableにて`作動中の文書$nav
</li>
			<li>
`文書を中止する$( %作動中の文書 )
</li>
			<li>
~IF［
%作動中の文書 の`回復可能か$doc ~EQ ~F
］
⇒
%文書 の`回復可能か$doc ~SET ~F
</li>
		</ol>
◎
Abort the active documents of each of document's descendant navigables. In what order? If this results in any of those Document objects having their salvageable state set to false, then set document's salvageable state to false also.
</li>
	<li>
<p>
~IF［
%文書 の文脈~下にある`~fetch$~algoの~instanceがある
］：
</p>
		<ol>
			<li>
それらの各~instanceを取消す
— 以降
⇒＃
それらに対し`~queueされ$る`~task$は破棄する ／
それらに対し~networkから受信される更なる~dataは破棄する
</li>
			<li>
%文書 の`回復可能か$doc ~SET ~F
</li>
		</ol>
◎
Cancel any instances of the fetch algorithm in the context of document, discarding any tasks queued for them, and discarding any further data received from the network for them. If this resulted in any instances of the fetch algorithm being canceled or any queued tasks or any network data getting discarded, then set document's salvageable state to false.
</li>
	<li>
<p>
~IF［
%文書 の`~navi~ID$doc ~NEQ ~NULL
］：
◎
If document's navigation id is non-null, then:
</p>
		<ol>
			<li>
`~WebDriver-BiDi~naviは中止された$( %文書 が`属する閲覧~文脈$, `新たな~WebDriver-BiDi~navi状態s$( %文書 の`~navi~ID$doc, `取消された$wBDst, %文書 の`~URL$doc ) )
◎
Invoke WebDriver BiDi navigation aborted with document's browsing context, and new WebDriver BiDi navigation status whose whose id is document's navigation id, status is "canceled", and url is document's URL.
</li>
			<li>
%文書 の`~navi~ID$doc ~SET ~NULL
◎
Set document's navigation id to null.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%文書 には`作動中の構文解析器$がある
］：
◎
If document has an active parser, then:
</p>
		<ol>
			<li>
%文書 の`作動中の構文解析器は中止されたか$ ~SET ~T
◎
Set document's active parser was aborted to true.
</li>
			<li>
その`構文解析器を中止する$
◎
Abort that parser.
</li>
			<li>
%文書 の`回復可能か$doc ~SET ~F
◎
Set document's salvageable state to false.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algo">
<p>
`読込ngを停止する@
ときは、
所与の
( `~navigable$ %~navigable )
に対し：
◎
To stop loading a navigable navigable:
</p>
<ol>
	<li>
%文書 ~LET %~navigable にて`作動中の文書$nav
◎
Let document be navigable's active document.
</li>
	<li>
<p>
~IF［
%文書 の`~unload~counter$ ~EQ 0
］~AND［
%~navigable の`進行中の~navi$ ~EQ `~navi~ID$
］
⇒
%~navigable の`進行中の~navi$ ~SET ~NULL
◎
If document's unload counter is 0, and navigable's ongoing navigation is a navigation ID, then set navigable's ongoing navigation to null.
</p>

<p class="note">注記：
これには
%~navigable にて進行中の~naviがあれば，それを中止する効果がある
— `進行中の~navi$に対する変更は、
~naviの間ある種の箇所で，更なる作業を放棄させることになるので。
◎
This will have the effect of aborting any ongoing navigations of navigable, since at certain points during navigation, changes to the ongoing navigation will cause further work to be abandoned.
</p>
	</li>
	<li>
`文書を中止する$( %文書 )
◎
Abort document.
</li>
</ol>
</div>

<p class="XXX">
~UAは、
自身の`~UI＠#nav-traversal-ui$を通して，
辿りの停止-法も許容する
— すなわち、［
`進行中の~navi$ ~EQ `traversal^l
］の事例で。
上の~algoは、
これを織り込まない。
（他方、
~UAは，［
`window.stop()＠~WINDOW#dom-window-stop$c により辿りを停止する
］ことは許容しないので、
上の~algoは，その~call元~用には正しくなる。）
`課題 #6905＠~HTMLissue/6905$
を見よ。
◎
Through their user interface, user agents also allow stopping traversals, i.e. cases where the ongoing navigation is "traversal". The above algorithm does not account for this. (On the other hand, user agents do not allow window.stop() to stop traversals, so the above algorithm is correct for that caller.) See issue #6905.
</p>

			</section>
		</section>
		<section id="the-x-frame-options-header">
<h3 title="The X-Frame-Options header">7.6. `X-Frame-Options^h ~header</h3>

<p>
`X-Frame-Options@h
~HTTP応答~headerは、［
`文書$は`子~navigable$の内側に どう読込まれてもよいか
］を制御する，旧来の仕方である。
それは、［
同じ状況に対し，もっと細やかな制御を供する
`frame-ancestors$dir ~CSP指令 `CSP$r
］により，廃用にされた。
それは、
元々は
`HTTP Header Field X-Frame-Options^cite `RFC7034$r
にて定義されたが，ここでの定義と処理~modelは、
その文書に取って代わる。
◎
The `X-Frame-Options` HTTP response header is a legacy way of controlling whether and how a Document may be loaded inside of a child navigable. It is obsoleted by the frame-ancestors CSP directive, which provides more granular control over the same situations. It was originally defined in HTTP Header Field X-Frame-Options, but the definition and processing model here supersedes that document. [CSP] [RFC7034]
</p>

<p class="note">注記：
特に，
`HTTP Header Field X-Frame-Options^cite
は、
その~header値~用の変種として `ALLOW-FROM^bl も指定したが，
それは実装されていない。
◎
In particular, HTTP Header Field X-Frame-Options specified an `ALLOW-FROM` variant of the header, but that is not to be implemented.
</p>

<p class="note">注記：
下に与える処理~modelにより、
`X-Frame-Options$h ~headerは，同じ`応答$内に
~CSP `frame-ancestors$dir 指令も利用された場合には無視される。
◎
Per the below processing model, if both a CSP frame-ancestors directive and an `X-Frame-Options` header are used in the same response, then `X-Frame-Options` is ignored.
</p>

<p>
［
~web開発者／適合性~検査器
］向けとして，その値の`~ABNF$は：
◎
For web developers and conformance checkers, its value ABNF is:
</p>

<pre class="bnf">X-Frame-Options
	= "DENY"
	/ "SAMEORIGIN"
</pre>

<div class="algo">
<p>
`~navi応答の~X-Frame-Optionsに対する固守を検査する@
ときは、
所与の
( `応答$ %応答, `~navigable$ %~navigable, `~CSP~list$ %~CSP~list, `生成元$ %行先~生成元 )
に対し：
◎
To check a navigation response's adherence to `X-Frame-Options`, given a response response, a navigable navigable, a CSP list cspList, and an origin destinationOrigin:
</p>
<ol>
	<li>
~IF［
%~navigable は`子~navigable$でない
］
⇒
~RET ~T
◎
If navigable is not a child navigable, then return true.
</li>
	<li>
<p>
%~CSP~list を成す
~EACH( %施策 )
に対し：
◎
For each policy of cspList:
</p>
		<ol>
			<li>
~IF［
%施策 の`処置先$ ~NEQ `enforce^l
］
⇒
~CONTINUE
◎
If policy's disposition is not "enforce", then continue.
</li>
			<li>
~IF［
`frame-ancestors$dir 指令 ~IN %施策 の`指令~集合$
］
⇒
~RET ~T
◎
If policy's directive set contains a frame-ancestors directive, then return true.
</li>
		</ol>
	</li>
	<li>
%生~X~frame~option群 ~LET `~header~listから値を取得して復号して分割する$( %応答 の`~header~list$rs, `X-Frame-Options$h )
◎
Let rawXFrameOptions be the result of getting, decoding, and splitting `X-Frame-Options` from response's header list.
</li>
	<li>
<p>
~IF［
%生~X~frame~option群 ~EQ ~NULL
］
⇒
~RET ~T
</p>
<p class="trans-note">【
この段は、
この訳による補完
（応答~内に `X-Frame-Options$h は無い）。
】</p>
	</li>
	<li>
%~X~frame~option群 ~LET 新たな`集合$
◎
Let xFrameOptions be a new set.
</li>
	<li>
%生~X~frame~option群 を成す
~EACH( %値 )
に対し
⇒
%~X~frame~option群 に次の結果を`付加する$set
⇒
`~ASCII小文字~化する$( %値 ) 
◎
For each value of rawXFrameOptions, append value, converted to ASCII lowercase, to xFrameOptions.
</li>
	<li>
<p>
~IF［
%~X~frame~option群 の`~size$ ~GT 1
］：
◎
↓</p>
		<ol>
			<li>
<p>
%~X~frame~option群 を成す
~EACH( %値 )
に対し
⇒
~IF［
%値 ~IN { `deny^l, `allowall^l, `sameorigin^l }
］
⇒
~RET ~F
◎
If xFrameOptions's size is greater than 1, and xFrameOptions contains any of "deny", "allowall", or "sameorigin", then return false.
</p>

<p class="note">注記：
ここでの意図nは、
`X-Frame-Options$h が［
妥当な何かを行おうと試行しているが，紛らわしく現れる
］場合には，それを適用する際に 【埋込もうとする】どの試みも阻止することにある。
◎
The intention here is to block any attempts at applying `X-Frame-Options` which were trying to do something valid, but appear confused.
</p>

<p class="note">注記：
旧来の `ALLOWALL^bl 値による処理~modelに対する影響iは、
ここに限られる。
◎
This is the only impact of the legacy `ALLOWALL` value on the processing model.
</p>
			</li>
			<li>
<p>
~RET ~T
◎
If xFrameOptions's size is greater than 1, then return true.
</p>

<p class="note">注記：
~headerは、
複数個の妥当でない値を包含している
— この場合、
~headerが まるごと省略されていたときと同じ仕方で扱う。
◎
This means it contains multiple invalid values, which we treat the same way as if the header was omitted entirely.
</p>
			</li>
		</ol>
	</li>
	<li>
~IF［
%~X~frame~option群[ 0 ] ~EQ `deny^l
］
⇒
~RET ~F
◎
If xFrameOptions[0] is "deny", then return false.
</li>
	<li>
<p>
~IF［
%~X~frame~option群[ 0 ] ~EQ `sameorigin^bl
］：
◎
If xFrameOptions[0] is "sameorigin", then:
</p>
		<ol>
			<li>
%容器~文書 ~LET %~navigable の`容器~文書$nav
◎
Let containerDocument be navigable's container document.
</li>
			<li>
<p>
~WHILE［
%容器~文書 ~NEQ ~NULL
］：
◎
While containerDocument is not null:
</p>
				<ol>
					<li>
~IF［
( %容器~文書 の`生成元$doc, %行先~生成元 )
は`同一-生成元$でない
］
⇒
~RET ~F
◎
If containerDocument's origin is not same origin with destinationOrigin, then return false.
</li>
					<li>
%容器~文書 ~SET %容器~文書 の`容器~文書$doc
◎
Set containerDocument to containerDocument's container document.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
<p>
~RET ~T
◎
Return true.
</p>

<p class="note">注記：
ここまで達した場合、
妥当でない 1 個の値からなる（旧来の［
`ALLOWALL^bl ／ `ALLOW-FROM^bl
］形も該当する）
— この場合、
~headerは まるごと省略されていたかのように扱う。
◎
If we've reached this point then we have a lone invalid value (which could potentially be one the legacy `ALLOWALL` or `ALLOW-FROM` forms). These are treated as if the header were omitted entirely.
</p>
	</li>
</ol>
</div>

<hr>

<div class="example">
<p>
この~header用の様々な値の処理を
— 不適合tなものも含め —
次の表に示す：
◎
The following table illustrates the processing of various values for the header, including non-conformant ones:
</p>

<div>
<table><thead><tr><th>`X-Frame-Options$h
</th><th>妥当か？
</th><th>結果

</th></tr></thead><tbody><tr><td>`DENY^bl
</td><td>✅
</td><td>埋込みは許容されない

</td></tr><tr><td>`SAMEORIGIN^bl
</td><td>✅
</td><td>同一-生成元なら埋込みは許容される

</td></tr><tr><td>`INVALID^bl
</td><td>❌
</td><td>埋込みは許容される

</td></tr><tr><td>`ALLOWALL^bl
</td><td>❌
</td><td>埋込みは許容される

</td></tr><tr><td>`ALLOW-FROM=https://example.com/^bl
</td><td>❌
</td><td>埋込みは許容される（どこからでも）

</td></tr></tbody></table>
◎
`X-Frame-Options`｜Valid｜Result
`DENY`｜✅｜embedding disallowed
`SAMEORIGIN`｜✅｜same-origin embedding allowed
`INVALID`｜❌｜embedding allowed
`ALLOWALL`｜❌｜embedding allowed
`ALLOW-FROM=https://example.com/`｜❌｜embedding allowed (from anywhere)
</div>
</div>


<div class="example">
<p>
複数の値を孕んでいる，様々な不適合tな事例がどう処理されるかを，次の表に示す：
◎
The following table illustrates how various non-conformant cases involving multiple values are processed:
</p>

<div>
<table><thead>
<tr><th>`X-Frame-Options$h
</th><th>結果
</th></tr></thead><tbody>

<tr><td>`SAMEORIGIN, SAMEORIGIN^bl
</td><td>同一-生成元なら埋込みは許容される

</td></tr><tr><td>`SAMEORIGIN, DENY^bl
</td><td>埋込みは許容されない

</td></tr><tr><td>`SAMEORIGIN,^bl
</td><td>埋込みは許容されない

</td></tr><tr><td>`SAMEORIGIN, ALLOWALL^bl
</td><td>埋込みは許容されない

</td></tr><tr><td>`SAMEORIGIN, INVALID^bl
</td><td>埋込みは許容されない

</td></tr><tr><td>`ALLOWALL, INVALID^bl
</td><td>埋込みは許容されない

</td></tr><tr><td>`ALLOWALL,^bl
</td><td>埋込みは許容されない

</td></tr><tr><td>`INVALID, INVALID^bl
</td><td>埋込みは許容される

</td></tr></tbody></table>

◎
`X-Frame-Options`｜Result
`SAMEORIGIN, SAMEORIGIN`｜same-origin embedding allowed
`SAMEORIGIN, DENY`｜embedding disallowed
`SAMEORIGIN,`｜embedding disallowed
`SAMEORIGIN, ALLOWALL`｜embedding disallowed
`SAMEORIGIN, INVALID`｜embedding disallowed
`ALLOWALL, INVALID`｜embedding disallowed
`ALLOWALL,`｜embedding disallowed
`INVALID, INVALID`｜embedding allowed
</div>

<p>
値たちが［
~commaで区切られた値を伴う 1 個の~header,
複数個の~header
］どちらで送達されようが，得される結果は同じになる。
◎
The same results are obtained whether the values are delivered in a single header whose value is comma-delimited, or in multiple headers.
</p>
</div>

		</section>
		<section id="the-refresh-header">
<h3 title="The Refresh header">7.7. `Refresh$h ~header</h3>

<p>
`Refresh@h
~HTTP応答~headerは、［
`meta$e 要素のうち，その `http-equiv$a 属性は `~refresh$st 状態にあるもの
］を~HTTPにおいて等価に~~表現するものである。
それは，
`同じ値＠~HEmetadata#conformance-attr-meta-http-equiv-refresh$をとり，ほとんど同じに働く。
その処理~modelの詳細は、
`文書を作成して初期化する$にて与えられる。
◎
The `Refresh` HTTP response header is the HTTP-equivalent to a meta element with an http-equiv attribute in the Refresh state. It takes the same value and works largely the same. Its processing model is detailed in create and initialize a Document object.
</p>

		</section>
		<section id="nav-traversal-ui">
<h3 title="Browser user interface considerations">7.8. ~browser~UIの考慮点</h3>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
次に挙げる能を【利用者~向けに（以下同様）】供するベキである
⇒
`~navigateする$／
`読込直す$／
`読込ngを停止する$
◎
Browser user agents should provide the ability to navigate, reload, and stop loading any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、［
所在~bar／
“読込直す” ~button／
“停止する” ~button
］などの~UIを介して。
◎
For example, via a location bar and reload/stop button UI.
</p>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
`履歴を差分だけ辿る$能を供するベキである。
◎
Browser user agents should provide the ability to traverse by a delta any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、［
戻る／進む
］~buttonを介して
— 場合によっては、
長押しにより差分を変更する能も含めて。
◎
For example, via back and forward buttons, possibly including long-press abilities to change the delta.
</p>

<p>
そのような~UAは、
2 以上の差分による辿りも許容することが示唆される
— ~pageが［
~session履歴に偽りな~entryを
（例えば，［
`history.pushState()＠~WINDOW#dom-history-pushstate$c の~callや`素片へ~navigateする$こと
］を繰返すことを介して）
詰め込む
］ことにより，利用者を “罠に嵌める” のを避けるため。
◎
It is suggested that such user agents allow traversal by deltas greater than one, to avoid letting a page "trap" the user by stuffing the session history with spurious entries. (For example, via repeated calls to history.pushState() or fragment navigations.)
</p>

<p class="note">注記：
一部の~UAは、
特定的にそのような濫用を克服するために，［
“戻る” ／ “進む”
］~buttonが 1 回だけ押されたとき より大きい差分に翻訳する経験則を備える。
`課題 #7832＠~HTMLissue/7832$ にて，
これらの経験則を指定することが~~検討されている。
◎
Some user agents have heuristics for translating a single "back" or "forward" button press into a larger delta, specifically to overcome such abuses. We are contemplating specifying these heuristics in issue #7832.
</p>

<p>
~browser~UAは、
`新鮮な~top-level辿可能を作成する$能を利用者に提供するベキである
— ［
利用者が供した／~UAにより決定される
］初期`~URL$を与えて。
◎
Browser user agents should offer users the ability to create a fresh top-level traversable, given a user-provided or user agent-determined initial URL.
</p>

<p class="example">
例えば［
“新たな~UItab” ／ “新たな~UIwindow”
］~buttonを介して。
◎
For example, via a "new tab" or "new window" button.
</p>

<p>
~browser~UAは、
自身の`~top-level辿可能~集合$に属する どの`~top-level辿可能$に対しても，
利用者が任意に`~top-level辿可能を閉じる$能を提供するベキである。
◎
Browser user agents should offer users the ability to arbitrarily close any top-level traversable in their top-level traversable set.
</p>

<p class="example">
例えば、
“~UItabを閉じる” ~buttonを~clickすることにより。
◎
For example, by clicking a "close tab" button.
</p>

<hr>

<p>
~browser~UAは、
利用者~向けに，`~navigable$（`~top-level辿可能$に限らず）を明示的に［
`~navigateする$／`読込直す$／`読込ngを停止する$
］仕方を供してもヨイ。
◎
Browser user agents may provide ways for the user to explicitly cause any navigable (not just a top-level traversable) to navigate, reload, or stop loading.
</p>

<p class="example">
例えば，文脈~menuを介して。
◎
For example, via a context menu.
</p>

<p>
~browser~UAは、
利用者~向けに，`~top-level辿可能を破壊する$能を供してもヨイ。
◎
Browser user agents may provide the ability for users to destroy a top-level traversable.
</p>

<p class="example">
例えば、
そのような`~top-level辿可能$を複数~個 包含している~UIwindowを強制的に閉じることにより。
◎
For example, by force-closing a window containing one or more such top-level traversables.
</p>

<hr>

<p>
利用者から`~navigable$を`読込直す$よう要請されたとき，
その`作動中の~entry$navの`文書~状態$shEの`資源$dSが`~POST資源$である場合には、
~UAは，先ず利用者に その操作oを確認してもらうよう~promptするベキである
— さもなければ、
~transaction（例：購入や~database改変）が繰返され得るので。
◎
When a user requests a reload of a navigable whose active session history entry's document state's resource is a POST resource, the user agent should prompt the user to confirm the operation first, since otherwise transactions (e.g., purchases or database modifications) could be repeated.
</p>

<p>
~UAは，利用者から`~navigable$を`読込直す$よう要請されたときは、
読込直す際に~cacheを無視するための仕組みを供してもヨイ。
◎
When a user requests a reload of a navigable, user agents may provide a mechanism for ignoring any caches when reloading.
</p>

<hr>

<p>
上に挙げた推奨, および
この仕様における~data構造には、［
~UAが利用者に~session履歴をどう表現するかに対し制約を設置する
］ことは意味されない。
◎
The above recommendations, and the data structures in this specification, are not meant to place restrictions on how user agents represent the session history to the user.
</p>

<p>
例えば、
`~top-level辿可能$の`~session履歴~entry群$tnは，
~listとして［
格納され, 保守される
］
— ~UAには、
`履歴を差分だけ辿る$ための~UIを与えることが推奨される —
が、
先進的な~UAは，それに［
代えて／加えて
］~treeの様な~viewを呈示して，［
各~pageが複数の “進む” ~pageを備えていて，利用者がそれらを選べる
］ようにすることもできる。
◎
For example, although a top-level traversable's session history entries are stored and maintained as a list, and the user agent is recommended to give an interface for traversing that list by a delta, a novel user agent could instead or in addition present a tree-like view, with each page having multiple "forward" pages that the user can choose between.
</p>

<p>
類似に，［
すべての子孫`~navigable$
］用の~session履歴は，
それらの`辿可能な~navigable$内に格納されるが、
~UAは，［
もっと仔細な，`~navigable$ごとに~session履歴の~view
］を利用者に呈示することもできる。
◎
Similarly, although session history for all descendant navigables is stored in their traversable navigable, user agents could present the user with a more nuanced per-navigable view of the session history.
</p>

<hr>

<p>
~browser~UAは、
`~top-level閲覧~文脈$の`~popupか$bcを次に挙げる目的に利用してもヨイ：
◎
Browser user agents may use a top-level browsing context's is popup boolean for the following purposes:
</p>
<ul>
	<li>
対応している`~top-level辿可能$用に必要最小限な~web~browser~UIを供するかどうかを裁定する。
◎
Deciding whether or not to provide a minimal web browser user interface for the corresponding top-level traversable.
</li>
	<li>
`閲覧~文脈の特能を設定しておく$とき，その中の任意選択な各~段を遂行する所。
◎
Performing the optional steps in set up browsing context features.
</li>
</ul>

<p>
どちらの事例においても、
~UAは，それに加えて［
利用者~選好を組入れる／
~popup~routeを奥へ進む選択肢を呈示する
］こともできよう。
◎
In both cases user agents might additionally incorporate user preferences, or present a choice as to whether to go down the popup route.
</p>

<p>
~UAは、
そのような~popup用に必要最小限な~UIを供する場合には，
~browserの所在~barを隠さないことが奨励される。
◎
User agents that provides a minimal user interface for such popups are encouraged to not hide the browser's location bar.
</p>

		</section>
</main>

