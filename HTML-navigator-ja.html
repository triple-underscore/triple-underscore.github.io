<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>HTML Standard — System state and capabilities（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-whatwg.css" type="text/css">

<style>

.category-list {
	column-width: 8em;
}
.category-list > li {
	margin: 0;
	margin-left: 0.5em;
	word-break: break-all;
}

</style>

<script src="common0.js"></script>
<script src="common1.js" async></script>


<script>

Util.ready = function(){
	const source_data = {
		toc_main: 'system-state-and-capabilities',
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	const link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.+?)([$@\^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){

if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `HTML-references.html#refs${key}`;
	break;
case 'l':
case 'rph':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'm':
case 'pA':
case 'mA':
case 'mP':
case 'mM':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	break;
case 'U':
	text = `U+${key}`;
	break;
case 'smb':
	text = `(<span class="char-symbol">${text}</span>)`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;


	}
}

</script>


<script type="text/plain" id="_source_data">


●●options

spec_date:2023-10-24
trans_update:2023-10-26
source_checked:210416
page_state_key:HTML
spec_status:LS
original_url:https://html.spec.whatwg.org/multipage/system-state.html
	abbr_url:HTMLnavigator
nav_prev:HTMLdynamic
nav_next:HTMLcomms
trans_1st_pub:2017-02-28


●●class_map
e:element
a:attr
et:event-type
sc:scheme
mt:mime-type
jt:js-type
h:header
M:method
E:error
U:code-point

●●tag_map
I:code
E:code
m:code
pA:code
mA:code
mP:code
mM:code
c:code
s:samp
e:code
a:code
sc:code
mt:code
et:code
jt:code
h:code
M:code
sub:sub
V:var
i:i
cite:cite
U:span

●●original_id_map

dom-window-navigator:dom-navigator
dom-window-clientinformation:dom-clientinformation

	navigator.online:browser-state

●●mdn_urls
navigator:API/Navigator
	navigatorcontentutils:API/NavigatorContentUtils
	navigatorcookies:API/NavigatorCookies
navigatorid:API/NavigatorID
	NavigatorID-partial:API/NavigatorID
navigatorlanguage:API/NavigatorLanguage
navigatoronline:API/NavigatorOnLine

●●link_map

Exposed:~WEBIDLjs#Exposed
LegacyUnenumerableNamedProperties:~WEBIDLjs#LegacyUnenumerableNamedProperties

E.SecurityError:~WEBIDL#securityerror
E.SyntaxError:~WEBIDL#syntaxerror

	I.DOMException:~WEBIDL#idl-DOMException
I.MimeType:#mimetype
I.MimeTypeArray:#mimetypearray
I.Navigator:#navigator
I.NavigatorConcurrentHardware:~WORKERS#navigatorconcurrenthardware
I.NavigatorContentUtils:#navigatorcontentutils
I.NavigatorCookies:#navigatorcookies
I.NavigatorID:#navigatorid
	I.NavigatorID:#NavigatorID-partial
I.NavigatorLanguage:#navigatorlanguage
I.NavigatorOnLine:#navigatoronline
I.NavigatorPlugins:#navigatorplugins
I.Plugin:#dom-plugin
	I.Plugin:~HTMLINFRA#plugin
I.PluginArray:#pluginarray

I.Window:~WINDOW#window
I.WorkerGlobalScope:~WORKERS#workerglobalscope
I.WorkerNavigator:~WORKERS#workernavigator

m.navigator:#dom-window-navigator
m.clientInformation:#dom-window-clientinformation

m.appCodeName:#dom-navigator-appcodename
m.appName:#dom-navigator-appname
m.appVersion:#dom-navigator-appversion
m.cookieEnabled:#dom-navigator-cookieenabled
m.language:#dom-navigator-language
m.languages:#dom-navigator-languages
m.onLine:#dom-navigator-online
m.oscpu:#dom-navigator-oscpu
m.platform:#dom-navigator-platform
m.product:#dom-navigator-product
m.productSub:#dom-navigator-productsub
m.registerProtocolHandler:#dom-navigator-registerprotocolhandler
m.taintEnabled:#dom-navigator-taintenabled
m.unregisterProtocolHandler:#dom-navigator-unregisterprotocolhandler
m.userAgent:#dom-navigator-useragent
m.vendor:#dom-navigator-vendor
m.vendorSub:#dom-navigator-vendorsub

m.plugins:#dom-navigator-plugins
m.mimeTypes:#dom-navigator-mimetypes
m.javaEnabled:#dom-navigator-javaenabled
m.pdfViewerEnabled:#dom-navigator-pdfviewerenabled

mP.name:#dom-plugin-name
mP.description:#dom-plugin-description
mP.filename:#dom-plugin-filename
mP.length:#dom-plugin-length
mP.item:#dom-plugin-item
mP.namedItem:#dom-plugin-nameditem

mM.type:#dom-mimetype-type
mM.description:#dom-mimetype-description
mM.suffixes:#dom-mimetype-suffixes
mM.enabledPlugin:#dom-mimetype-enabledplugin

pA.length:#dom-pluginarray-length
pA.item:#dom-pluginarray-item
pA.namedItem:#dom-pluginarray-nameditem
pA.refresh:#dom-pluginarray-refresh

mA.length:#dom-mimetypearray-length
mA.item:#dom-mimetypearray-item
mA.namedItem:#dom-mimetypearray-nameditem


e.iframe:~HEembed#the-iframe-element
et.languagechange:~HTMLindex#event-languagechange
et.online:~HTMLindex#event-online
et.offline:~HTMLindex#event-offline

h.Accept-Language:~HTTPsem#field.accept-language

rph.none:#rph-automation-mode-none
rph.autoAccept:#rph-automation-mode-auto-accept
rph.autoReject:#rph-automation-mode-auto-reject

	sc.sms::~RFCx/rfc5724#section-2

結付けられた~Navigator:#associated-navigator

確からしい言語:#a-plausible-language

~navigator互換性~mode:#concept-navigator-compatibility-mode
~protocol~handler~parameterを正規化する:#normalize-protocol-handler-parameters
安全とされる~scheme:#safelisted-scheme
~protocol~handlerを登録する:#protocol-handler-registration
登録した~handlerを利用する:#protocol-handler-invocation

型:#concept-mimetype-type
pG.名前:#concept-plugin-name
~PDF~viewerは~supportされるか:#pdf-viewer-supported
~MIME型~配列:#mime-types-array
~PDF~viewer~MIME型~obj~list:#pdf-viewer-mime-type-objects
~PDF~viewer~MIME型~list:#pdf-viewer-mime-types
~PDF~viewer~plugin名~list:#pdf-viewer-plugin-names
~PDF~viewer~plugin~obj~list:#pdf-viewer-plugin-objects
~plugin配列:#plugins-array

~UA自動化:#rph-user-agent-automation
~RPH自動化~mode:#registerprotocolhandler()-automation-mode
~RPH登録~modeを設定する:#set-rph-registration-mode

	●用語（HTML
並列的:~HTMLINFRA#in-parallel

~URLを符号化法の下で相対的に構文解析する:~HTMLurl#encoding-parsing-a-url
文書:~HTMLdom#the-document-object
	I.Document:~HTMLdom#document

大域~taskを~queueする:~WAPI#queue-a-global-task
~DOM操作~task~source:~WAPI#dom-manipulation-task-source
~network用~task~source:~WAPI#networking-task-source
関連な大域~obj:~WAPI#concept-relevant-global
関連な設定群~obj:~WAPI#relevant-settings-object
関連な~realm:~WAPI#concept-relevant-realm
環境~設定群~obj:~WAPI#environment-settings-object
enV.生成元:~WAPI#concept-settings-object-origin
enV.~secureな文脈:~WAPI#secure-context

同一-生成元:~ORIGIN#same-origin
結付けられた文書:~WINDOW#concept-document-window
~navigable:~HTMLds#navigable
bc.作動中な文書:~HTMLds#active-document
~navigate:~HTMLnav#navigate
~navi:~HTMLnav#navigate
	processing model for navigating across documents:browsers.html#navigate

	●用語（外部

実装定義:~INFRA#implementation-defined
~size:~INFRA#list-size
~index群:~INFRA#list-get-the-indices
~ASCII英小文字:~INFRA#ascii-lower-alpha
~ASCII小文字~化する:~INFRA#ascii-lowercase

凍結d配列:~WEBIDL#dfn-frozen-array-type
新たな:~WEBIDLjs#new
	有名~propを~supportする:~WEBIDL#dfn-support-named-properties
	有index~propを~supportする:~WEBIDL#dfn-support-indexed-properties
~supportする~prop名:~WEBIDL#dfn-supported-property-names
~supportする~prop~index:~WEBIDL#dfn-supported-property-indices

~eventを発火する:~DOM4#concept-event-fire

~URL:~URL1#concept-url
url.生成元:~URL1#concept-url-origin
url.~scheme:~URL1#concept-url-scheme
妥当な~URL文字列:~URL1#valid-url-string
絶対~URL:~URL1#absolute-url-string
	絶対~URL:~URL1#syntax-url-absolute
文字列を~UTF-8~percent-符号化する:~URL1#string-utf-8-percent-encode
成分~percent-符号化-集合:~URL1#component-percent-encode-set
生成元:~URL1#concept-url-origin
~URL構文解析する:~URL1#concept-url-parser
~URLを直列化する:~URL1#concept-url-serializer
~usernameを設定する:~URL1#set-the-username
~passwordを設定する:~URL1#set-the-password

~HTTP_S~scheme:~FETCH#http-scheme
既定の~User-Agent値:~FETCH#default-user-agent-value

信用に価し得る~URL:~SECURE-CONTEXT#potentially-trustworthy-url

拡張~command:~WEBDRIVER#dfn-extension-commands
~remote端~手続き:~WEBDRIVER#dfn-remote-end-steps
~WebDriver~error:~WEBDRIVER#dfn-errors
~WebDriver~error~code:~WEBDRIVER#dfn-error-code
無効な引数:~WEBDRIVER#dfn-invalid-argument
~propを取得する:~WEBDRIVER#dfn-getting-properties
現在の閲覧~文脈:~WEBDRIVER#dfn-current-browsing-context
成功:~WEBDRIVER#dfn-success


●●words_table1
WEBDRIVER:https://w3c.github.io/webdriver/

●●words_table



	●仕様
事実:fact:~
対処:work around:~
強いる:forceする:~
相似する:analogousな:~
自明:trivial:~
通常運用:normal operation:~
準拠する:compliantな:~
黙って:silentに:~
上品:graceful:~
大多数:majority:~
内来的:inherent:~
複雑:complicated:~
調査結果:evidence:~
変種:variant:~
同意:consent:~
設置-:place:~
確認:confirmation:~

	解する所の:understanding
	:wish
	場合もある:possibly
	されないよう:avoid
	さらに重要な点として:even more importantly
	念頭に置く:bear-in-mind
	したがって〜ことになる:forcibly
	ある程度:To some extent,
	easily
	好きに:whatever they like
	より~~正確には:or rather,
	対策も講じておく:prepared to handle
	産業界:entire industry
	にもかかわらず:despite of
	確からしい:plausible
	対象になる:that they consider
	要となる:key
	おそらく／定かでない:Maybe
	あり得る:potential
	様々になる:variation
	期待-:expectation
	選ぶ:choice
	強制される:forcibly
	間違いなく:definitely
	いまどき:these days
	入り組んだ:intertwined
	とみなした:mark
	されかねない:lead
	知る:know
	出自を~~隠す:obfuscates the user's point of origin
	寄せられたし:please send

	●network ／ 保安／環境
User-Agent:
HTTP_S:HTTP(S)
下位domain:subdomain:::下位ドメイン
username::::ユーザ名
password::::パスワード
IP-address-block:IP address block:::IP アドレスブロック
navigator::::ナビゲータ
intranet::::イントラネット
offline::::オフライン
online::::オンライン
Internet:
管理者:administrator:~
	追跡し続ける:keep track
活動:activity:~
濫用-:abuse:~
	能力を備える:capable of
	Cancel
受認-:accept:~
認証:authentication:~
匿名性:anonymity:~
匿名化:anonymizing:~
spam::::スパム
	~spam的な:spamming
乗取り:hijacking:乗っ取り
同一性:identity:~
crash::::クラッシュ
buffer-overrun:buffer overrun:::バッファ溢れ
online-telephone-messaging:online telephone messaging:::オンライン電話メッセージ用
pornography::::ポルノ
私的:private::~
組織:organization:~
切断-:disconnect::~
接触-:contact:~
	追う:follow
	信用に価し得る:potentially trustworthy
	押し出され:push off

	●plugin／handler
MimeType:
helper::::ヘルパー
選抜list:shortlist:::選抜リスト
辞退-:decline:~
経由-:route:~
仮入力:placeholder::~::プレースホルダ
viewer::::ビューア
PDF:
RPH:
	~RPH:registerProtocolHandler()
	~RPH:RPH
WebDriver:
template:
URI:
端:end:~

	安全とされる:safelisted
	登録-済み:registered
	未登録に:unregister／deregistration

	●処理
合成-:synthesize:~
手渡す:handする:~
繰返し:repeatedly:繰り返し
素通り:bypass:~
指図-:instruct:~
模倣-:simulate:~

	し続け:continue
	渡-:pass

	%正規化した~scheme:normalizedScheme
	%正規化した~URL:normalizedURLString
	%符号化した~URL:encodedURL
	%入力~URL:inputURL
	%入力~URL文字列:inputURLString
	%~handler~URL文字列:handlerURLString
	%結果~URL:resultURL
	%大域~obj:global
	%~MIME型:mimeType
	%~MIME型~list:mimeTypes
	%~plugin~list:plugins
	%~plugin:plugin
	%結果:trail

	●未分類
Navigator:
英小文字:lower alpha:~
percent-::: %-
	error:not successful
	-:the exact literal
	time
出自:origin:~
数:number:~
種類:kind:~
所在-:locate::~
alphabet::::アルファベット
	~alphabet順に挙げられ:ordered alphabetically

	~view用の／~viewする:viewing
	再利用-:re-use
	-:fail
	-:get
	-:check to see
	頭部:starts with
	consist
	保つ:keep
	対応-:correspond
	変わる:varies／vary
	見当たらない:missing
	現れる:occurrence
	hidden
	長い:long
	見る:view
	束ねられ:binding
	選ば:pick
	置き換えられる:where to put
	送る:ship
	抗して／:against
	頭部／:substring
	-:accordingly
	Tor
	-:made
	しばらく経ってから:...and then, much later
	スープ:soup
	potentially
	長過ぎる:over-long
	-:Example
	社:Company
	-:Sample
	using
	指す／指せる／指して:point／:pointing
	大域~obj:global
	0 番:0th

	-:naturally now the data is stale
	happen
	見た:has seen
	:gather
	object^jt:Object

	●指示語
	各部:parts
	一連の:collection of
	多数の:large number of
	の集合:set of
	何年も:many years
	それ以上:any more
	を除き:beyond
	以前の:previous
	少ない:little
	-:prior to
	単に:just
	旧:old
	non-
	sometime
	beyond
	previous
	re
	whichever
	に際して:upon


●●trans_metadata
<p>
~THIS_PAGEは、~WHATWGによる
HTML 仕様の
<a href="~SPEC_URL">§ System state and capabilities</a>
を日本語に翻訳したものです。
~PUB
</p>

</script>

</head>
<body>

<header>
	<hgroup>
<h1>HTML — システムの状態と能力</h1>
	</hgroup>
</header>

<main id="MAIN" hidden>

		<section id="system-state-and-capabilities">
<h2 title="System state and capabilities">8.9. ~systemの状態と能力</h2>

			<section id="the-navigator-object">
<h4 title="The Navigator object">8.9.1. `Navigator^I ~obj</h4>

<p>
`Navigator$I の~instanceは、
~UA（~client）の同一性と状態を表現する。
それはまた、
汎用な大域~objとして~serveする
— ［
この仕様／他の仕様
］内の様々な~APIが、
そこに所在する。
◎
Instances of Navigator represent the identity and state of the user agent (the client). They also serve as a generic global under which various APIs are located in this and other specifications.
</p>

<pre class="idl">
[Exposed=Window]
interface `Navigator@I {
  /* <span class="comment">
この~interfaceを実装している~objは、
下に与える~interfaceも実装する。
◎
objects implementing this interface also implement the interfaces given below
</span> */
};
`Navigator$I includes `NavigatorID$I;
`Navigator$I includes `NavigatorLanguage$I;
`Navigator$I includes `NavigatorOnLine$I;
`Navigator$I includes `NavigatorContentUtils$I;
`Navigator$I includes `NavigatorCookies$I;
`Navigator$I includes `NavigatorPlugins$I;
`Navigator$I includes `NavigatorConcurrentHardware$I;
</pre>

<p class="note">注記：
これらの~interface~mixinは、
`WorkerNavigator$I が `Navigator$I ~interfaceを成す各部を再利用できるよう，
別々に定義される。
◎
These interface mixins are defined separately so that WorkerNavigator can reuse parts of the Navigator interface.
</p>

<p>
各 `Window$I には、
それに
`結付けられた~Navigator@
がある
— それは、
ある `Navigator$I ~objである。
`Window$I ~objの作成に際しては、
それに`結付けられた~Navigator$を［
当の `Window$I ~objに`関連な~realm$内に作成される，`新たな$ `Navigator$I ~obj
］に設定するモノトスル。
◎
Each Window has an associated Navigator, which is a Navigator object. Upon creation of the Window object, its associated Navigator must be set to a new Navigator object created in the Window object's relevant realm.
</p>

<div class="algo">
`Window$I の［
`navigator@m
／
`clientInformation@m
］取得子~手続きは
⇒
~RET コレに`結付けられた~Navigator$
◎
The navigator and clientInformation getter steps are to return this's associated Navigator.
</div>

				<section id="client-identification">
<h5 title="Client identification">8.9.1.1. ~clientの識別</h5>

<pre class="idl">
interface mixin `NavigatorID@I {
  readonly attribute DOMString `appCodeName$m; /* <span class="comment">
常に `Mozilla^l
◎
constant "Mozilla"
</span> */
  readonly attribute DOMString `appName$m; /* <span class="comment">
常に `Netscape^l
◎
constant "Netscape"
</span> */
  readonly attribute DOMString `appVersion$m;
  readonly attribute DOMString `platform$m;
  readonly attribute DOMString `product$m; /* <span class="comment">
常に `Gecko^l
◎
constant "Gecko"
</span> */
  [`Exposed$=Window] readonly attribute DOMString `productSub$m;
  readonly attribute DOMString `userAgent$m;
  [`Exposed$=Window] readonly attribute DOMString `vendor$m;
  [`Exposed$=Window] readonly attribute DOMString `vendorSub$m; /* <span class="comment">
常に空~文字列
◎
constant ""
</span> */
};
</pre>

<p>
産業界における最善な労にもかかわらず，ある種の事例では、
~web~browserには，~web作者に対処を強いるような~bugや制限がある。
◎
In certain cases, despite the best efforts of the entire industry, web browsers have bugs and limitations that web authors are forced to work around.
</p>

<p>
この節では、
これらの課題に対処するため，
~scriptから利用-中な~UAの種類を決定するために利用できる 一連の属性を定義する。
◎
This section defines a collection of attributes that can be used to determine, from script, the kind of user agent in use, in order to work around these issues.
</p>

<p>
~UAは、
次のいずれかを値にとる
`~navigator互換性~mode@
を持つ
⇒＃
`Chrome^i,
`Gecko^i,
`WebKit^i
◎
The user agent has a navigator compatibility mode, which is either Chrome, Gecko, or WebKit.
</p>

<p class="note">注記：
`~navigator互換性~mode$は、
`NavigatorID$I ~mixinにおける［
各種 属性~値, ［
`taintEnabled()$m ／ `oscpu$m
］の有無
］を，［
既存の~web内容と互換であることが既知である組合n
］に拘束する。
◎
The navigator compatibility mode constrains the NavigatorID mixin to the combinations of attribute values and presence of taintEnabled() and oscpu that are known to be compatible with existing web content.
</p>

<p>
~client検出は、
常に，既知である現在の~versionを検出するものに制限されるベキである
— 将来の／未知な~versionは、
常に，全部的に準拠するものと見做されるベキである。
◎
Client detection should always be limited to detecting known current versions; future versions and unknown versions should always be assumed to be fully compliant.
</p>

<dl class="domintro">

	<dt>%self.`navigator$m.`appCodeName$m</dt>
	<dd>
文字列 `Mozilla^l を返す。
◎
Returns the string "Mozilla".
</dd>

	<dt>%self.`navigator$m.`appName$m</dt>
	<dd>
文字列 `Netscape^l を返す。
◎
Returns the string "Netscape".
</dd>

	<dt>%self.`navigator$m.`appVersion$m</dt>
	<dd>
~browserの~versionを返す。
◎
Returns the version of the browser.
</dd>

	<dt>%self.`navigator$m.`platform$m</dt>
	<dd>
~platformの名前を返す。
◎
Returns the name of the platform.
</dd>

	<dt>%self.`navigator$m.`product$m</dt>
	<dd>
文字列 `Gecko^l を返す。
◎
Returns the string "Gecko".
</dd>

	<dt>%window.`navigator$m.`productSub$m</dt>
	<dd>
文字列［
`20030107^l, `20100101^l
］いずれかを返す。
◎
Returns either the string "20030107", or the string "20100101".
</dd>

	<dt>%self.`navigator$m.`userAgent$m</dt>
	<dd>
完全な `User-Agent^h ~headerを返す。
◎
Returns the complete `User-Agent` header.
</dd>

	<dt>%window.`navigator$m.`vendor$m</dt>
	<dd>
次のいずれかの文字列を返す
⇒
空~文字列, `Apple Computer, Inc.^l, `Google Inc.^l
◎
Returns either the empty string, the string "Apple Computer, Inc.", or the string "Google Inc.".
</dd>

	<dt>%window.`navigator$m.`vendorSub$m</dt>
	<dd>
空~文字列を返す。
◎
Returns the empty string.
</dd>
</dl>

<p class="trans-note">【
“%window . …” は `Window^I にのみ公開され，~worker環境では利用できない（ [`Exposed$=Window] ）。
】</p>

<div class="algo">
`appCodeName@m
取得子~手続きは
⇒
~RET 文字列 `Mozilla^l
◎
Must return the string "Mozilla".
</div>

<div class="algo">
`appName@m
取得子~手続きは
⇒
~RET 文字列 `Netscape^l
◎
Must return the string "Netscape".
</div>

<div class="algo">
<p>
`appVersion@m
取得子~手続きは：
</p>
<ol>
	<li>
%結果 ~LET `既定の~User-Agent値$
</li>
	<li>
~Assert：
%結果 は文字列 `Mozilla/^l から開始している†
</li>
	<li>
%結果 ~LET %結果 から，頭部を成す `Mozilla/^l を除去した結果
</li>
	<li>
~Assert：
%結果 は文字列 `5.0 (^l から開始している†
</li>
	<li>
<p>
`~navigator互換性~mode$に応じて：
</p>
		<ul class="switch">
			<li>
`Chrome^i ／ `WebKit^i
⇒
~RET %結果
</li>
			<li>
<p>
`Gecko^i：
</p>
				<ol>
					<li>
~IF［
%結果 は `5.0 (Windows^l から開始している
］
⇒
~RET `5.0 (Windows)^l
</li>
					<li>
~Assert：
%結果 内に文字 `003B^U `;^smb が在る†
</li>
					<li>
%結果 ~SET %結果 から最初の `003B^U `;^smb 以降の文字列を除去した結果
</li>
					<li>
~RET %結果 に文字 `0029^U `)^smb を付加した結果
— 例
⇒＃
`5.0 (Macintosh)^l ／
`5.0 (Android 10)^l ／
`5.0 (X11)^l
</li>
				</ol>
			</li>
		</ul>
	</li>
</ol>

<p class="trans-note">【†
これらの ~Assert は、
この訳による補完
— 原文は、
これらの条件を満たすかのように記されている
（満たさない場合の挙動が指定されていない
— `既定の~User-Agent値$は`実装定義$なので、
理論上は満たさない可能性もあるにもかかわらず）。
】</p>

◎
appVersion
◎
Must return the appropriate string that starts with "5.0 (", as follows:
◎
Let trail be the substring of default `User-Agent` value that follows the "Mozilla/" prefix.
◎
If the navigator compatibility mode is Chrome or WebKit
• Return trail.
◎
If the navigator compatibility mode is Gecko
• If trail starts with "5.0 (Windows", then return "5.0 (Windows)".
• Otherwise, return the prefix of trail up to but not including the first U+003B (;), concatenated with the character U+0029 RIGHT PARENTHESIS. For example, "5.0 (Macintosh)", "5.0 (Android 10)", or "5.0 (X11)".
</div>

<div class="algo">
<p>
`platform@m
取得子~手続きは
⇒
~RET 次のいずれか
⇒＃
~browserを実行している~platformを表現する文字列／
~privacyや互換性を得るためとして，別の~platformにて共通して返される文字列
</p>

<p class="example">
例：
`MacIntel^l ／
`Win32^l ／
`FreeBSD i386^l ／
`Linux armv81^l
</p>

◎
Must return a string representing the platform on which the browser is executing (e.g. "MacIntel", "Win32", "Linux x86_64", "Linux armv81") or, for privacy and compatibility, a string that is commonly returned on another platform.
</div>

<div class="algo">
`product@m
取得子~手続きは
⇒
~RET 文字列 `Gecko^l
◎
Must return the string "Gecko".
</div>

<div class="algo">
`productSub@m
取得子~手続きは
⇒
~RET `~navigator互換性~mode$に応じて
⇒＃
`Chrome^i ならば 文字列 `20030107^l ／
`WebKit^i ならば 文字列 `20030107^l ／
`Gecko^i ならば 文字列 `20100101^l
◎
Must return the appropriate string from the following list:
◎
If the navigator compatibility mode is Chrome or WebKit
• The string "20030107".
◎
If the navigator compatibility mode is Gecko
• The string "20100101".
</div>

<div class="algo">
`userAgent@m
取得子~手続きは
⇒
~RET `既定の~User-Agent値$
◎
Must return the default `User-Agent` value.
</div>

<div class="algo">
`vendor@m
取得子~手続きは
⇒
~RET `~navigator互換性~mode$に応じて
⇒＃
`Chrome^i ならば 文字列 `Google Inc.^l ／
`Gecko^i ならば 空~文字列 ／
`WebKit^i ならば 文字列 `Apple Computer, Inc.^l
◎
Must return the appropriate string from the following list:
◎
If the navigator compatibility mode is Chrome
• The string "Google Inc.".
◎
If the navigator compatibility mode is Gecko
• The empty string.
◎
If the navigator compatibility mode is WebKit
• The string "Apple Computer, Inc.".
</div>

<div class="algo">
`vendorSub@m
取得子~手続きは
⇒
~RET 空~文字列
◎
Must return the empty string.
</div>

<p>
［
`~navigator互換性~mode$ ~EQ `Gecko^i
］の場合、
~UAは，次の部分的~interfaceも~supportするモノトスル：
◎
If the navigator compatibility mode is Gecko, then the user agent must also support the following partial interface:
</p>

<pre class="idl" id="NavigatorID-partial">
partial interface mixin `NavigatorID$I {
  [`Exposed$=Window] boolean `taintEnabled$m(); /* <span class="comment">
常に ~F
◎
constant false
</span> */
  [`Exposed$=Window] readonly attribute DOMString `oscpu$m;
};
</pre>

<div class="algo">
`taintEnabled()@m
取得子~手続きは
⇒
~RET ~F
◎
The taintEnabled() method must return false.
</div>

<div class="algo">
<p>
`oscpu@m
取得子~手続きは
【"oscpu" = “OS ＋ CPU”】
⇒
~RET 次のいずれか
⇒＃
空~文字列 ／
~browserを実行している~platformを表現する文字列
◎
The oscpu attribute's getter must return either the empty string or a string representing the platform on which the browser is executing,＼
</p>

<p class="example">
例：
`Windows NT 10.0; Win64; x64^l ／
`Linux x86_64^l
◎
e.g. "Windows NT 10.0; Win64; x64", "Linux x86_64".
</p>
</div>

<p class="warning">
◎追跡路
この~APIにおいて利用者ごとに変わる情報は、
どれも，利用者を~profileするために利用され得る。
事実、
そのような情報が十分に可用にされたならば，利用者は実際に一意に識別され得る。
この理由から、
~UA実装者には，［
この~APIに含める情報は、
アリな限り少なくする
］ことが強く督促される。
◎
(This is a tracking vector.)
Any information in this API that varies from user to user can be used to profile the user. In fact, if enough such information is available, a user can actually be uniquely identified. For this reason, user agent implementers are strongly urged to include as little information in this API as possible.
</p>

				</section>
				<section id="language-preferences">
<h5 title="Language preferences">8.9.1.2. 言語~選好</h5>

<pre class="idl">
interface mixin `NavigatorLanguage@I {
  readonly attribute DOMString `language$m;
  readonly attribute FrozenArray&lt;DOMString&gt; `languages$m;
};
</pre>

<dl class="domintro">

	<dt>%self.`navigator$m.`language$m</dt>
	<dd>
利用者が最も選好する言語を表現する，言語~tagを返す。
◎
Returns a language tag representing the user's preferred language.
</dd>

	<dt>%self.`navigator$m.`languages$m</dt>
	<dd>
利用者が選好する言語たちを表現する，言語~tagからなる配列を返す
— 最も選好する言語が最初に来る。
◎
Returns an array of language tags representing the user's preferred languages, with the most preferred language first.
◎
The most preferred language is the one returned by navigator.language.
</dd>
</dl>

<p class="note">注記：
`languagechange$et ~eventは、［
~UAが解する所の，利用者が選好する言語
］が変化したとき，［
`Window$I ／ `WorkerGlobalScope$I
］~objに向けて発火される。
◎
A languagechange event is fired at the Window or WorkerGlobalScope object when the user agent's understanding of what the user's preferred languages are changes.
</p>

<div class="algo">
`language@m
取得子~手続きは
⇒
~RET ［
`確からしい言語$／利用者が最も選好する言語
］を表現している，妥当な BCP 47 言語~tag
`BCP47$r
◎
Must return a valid BCP 47 language tag representing either a plausible language or the user's most preferred language. [BCP47]
</div>

<div class="algo">
<p>
`languages@m
取得子~手続きは
⇒
~RET 次を満たす`凍結d配列$：
◎
Must return a frozen array＼
</p>
<ul>
	<li>
1 個~以上の妥当な BCP 47 言語~tag `BCP47$r からなる。
◎
of valid BCP 47 language tags＼
</li>
	<li>
［
`確からしい言語$たち／利用者が選好する言語たち
］を表現している。
◎
representing either one or more plausible languages, or the user's preferred languages,＼
</li>
	<li>
それらの順序は、
最も選好される言語からとする。
◎
ordered by preference with the most preferred language first.＼
</li>
</ul>

<p>
加えて、
~UAは，次に従うモノトスル：
</p>
<ul>
	<li>
［
異なる言語~tag／異なる順序
］で値を返す必要が生じるまでは、
同じ~objを返す。
◎
The same object must be returned until the user agent needs to return different values, or values in a different order. [BCP47]
</li>
	<li>
<p>
［
`Window$I ／ `WorkerGlobalScope$I
］~obj %G 上のこの取得子が［
新たな言語~tagの集合を返す
］ようにする必要が生じたときは：
</p>
		<ul>
			<li class="algo">
次を走らす`大域~taskを~queueする$( `~DOM操作~task~source$, %G )
⇒
`~eventを発火する$( %G, `languagechange$et )
</li>
			<li>
新たな値を実際に返す前に，前項の~taskが実行されるのを待機する
</li>
		</ul>
◎
Whenever the user agent needs to make the navigator.languages attribute of a Window or WorkerGlobalScope object global return a new set of language tags, the user agent must queue a global task on the DOM manipulation task source given global to fire an event named languagechange at global, and wait until that task begins to be executed before actually returning a new value.
</li>
</ul>
</div>

<p>
~UAは、
`確からしい言語@
を決定するときは，次を念頭に置くベキである：
◎
To determine a plausible language, the user agent should bear in mind the following:
</p>
<ul>
	<li>
◎追跡路
この~APIにおいて利用者ごとに変わる情報は、
どれも，利用者を［
~profileする／識別する
］ために利用され得る。
◎
(This is a tracking vector.)
Any information in this API that varies from user to user can be used to profile or identify the user.
</li>
	<li>
利用者が出自を~~隠す~service（例： Tor などの匿名性~network）を利用していない場合、
出自が類似な利用者たち（例：同じ~IP-address-blockからの）が最も互いに判別されにくい値は，
そのような利用者たちの大多数が利用している言語である。
`TOR$r
◎
If the user is not using a service that obfuscates the user's point of origin (e.g. the Tor anonymity network), then the value that is least likely to distinguish the user from other users with similar origins (e.g. from the same IP address block) is the language used by the majority of such users. [TOR]
</li>
	<li>
利用者が匿名化~serviceを利用していて、
互いの利用者が判別される可能性を抑制するためとして，同じ値を利用する場合、
その値には， `en-US^l が示唆される。
◎
If the user is using an anonymizing service, then the value "en-US" is suggested; if all users of the service use that same value, that reduces the possibility of distinguishing the users from each other.
</li>
</ul>

<p>
◎追跡路
これ以上の指紋収集~行路が導入されないよう、
~UAは，この関数に定義される~API用には同じ~listを利用するベキである
— ~HTTP `Accept-Language$h ~headerのときと同じく。
◎
(This is a tracking vector.)
To avoid introducing any more fingerprinting vectors, user agents should use the same list for the APIs defined in this function as for the HTTP `Accept-Language` header.
</p>

				</section>
				<section id="navigator.online">
<h5 title="Browser state">8.9.1.3. ~browser状態</h5>

<pre class="idl">
interface mixin `NavigatorOnLine@I {
  readonly attribute boolean `onLine$m;
};
</pre>

<dl class="domintro">
	<dt>%self.`navigator$m.`onLine$m</dt>
	<dd>
~UAは［
間違いなく~offlineである（~networkから切断されている）ならば ~F ／
~onlineかもしれないならば ~T
］を返す。
◎
Returns false if the user agent is definitely offline (disconnected from the network). Returns true if the user agent might be online.
</dd>
	<dd>
この属性が返す値が変化したときは、［
`online$et ／ `offline$et
］~eventが発火される。
◎
The events online and offline are fired when the value of this attribute changes.
</dd>
</dl>

<div class="algo">
`onLine@m
取得子~手続きは
⇒
~RET ［
次に該当するときは ~F ／
~ELSE_ ~T
］
⇒
~UAは、［
利用者が~linkを追うとき／
~scriptが~remote~pageを要請するとき
（または，そのような試みが失敗することを知るとき）
］に，~networkに接触しない
◎
The onLine attribute must return false if the user agent will not contact the network when the user follows links or when a script requests a remote page (or knows that such an attempt would fail), and must return true otherwise.
</div>

<div class="algo">
<p>
［
`Window$I ／ `WorkerGlobalScope$I
］~obj %大域~obj の `onLine$m 属性が返す値が %X に変化したときは、
次を走らすモノトスル：
</p>
<ol>
	<li>
%~event名 ~LET %X に応じて
⇒＃
~F ならば `offline$et ／
~T ならば `online$et
</li>
	<li>
`大域~taskを~queueする$( `~network用~task~source$, %大域~obj )
⇒
`~eventを発火する$( %大域~obj, %~event名 )
</li>
</ol>

◎
When the value that would be returned by the navigator.onLine attribute of a Window or WorkerGlobalScope global changes from true to false, the user agent must queue a global task on the networking task source given global to fire an event named offline at global.
◎
On the other hand, when the value that would be returned by the navigator.onLine attribute of a Window or WorkerGlobalScope global changes from false to true, the user agent must queue a global task on the networking task source given global to fire an event named online at the Window or WorkerGlobalScope object.
</div>

<p class="note">注記：
この属性は、
内来的に依拠~可能でない。
~computerは、
~Internet~accessが無い下でも~networkに接続され得る。
◎
This attribute is inherently unreliable. A computer can be connected to a network without having Internet access.
</p>

<div class="example">
<p>
この例では、
~browserが~onlineか~offlineになるに伴い，
ある指示子（ `id=indicator^c ）が更新される。
◎
In this example, an indicator is updated as the browser goes online and offline.
</p>

<pre class="lang-html">
&lt;!DOCTYPE HTML&gt;
&lt;html lang="ja"&gt;
 &lt;head&gt;
  &lt;title&gt;~online状態&lt;/title&gt;
  &lt;script&gt;
   function updateIndicator() {
     document.getElementById('indicator').textContent = navigator.onLine ? '~online' : '~offline';
   }
  &lt;/script&gt;
 &lt;/head&gt;
 &lt;body onload="updateIndicator()" ononline="updateIndicator()" onoffline="updateIndicator()"&gt;
  &lt;p&gt;~networkは： &lt;span id="indicator"&gt;（未知な状態）&lt;/span&gt;
 &lt;/body&gt;
&lt;/html&gt;
</pre>
</div>

				</section>
				<section id="custom-handlers">
<h5 title="Custom scheme handlers: the registerProtocolHandler() method">8.9.1.4. ~custom~scheme~handler： `registerProtocolHandler()^m ~method</h5>

<pre class="idl">
interface mixin `NavigatorContentUtils@I {
  [SecureContext] undefined `registerProtocolHandler$m(DOMString %scheme, USVString %url);
  [SecureContext] undefined `unregisterProtocolHandler$m(DOMString %scheme, USVString %url);
};
</pre>

<dl class="domintro">
	<dt>%window.`navigator$m.`registerProtocolHandler(scheme, url)$m</dt>
	<dd>
%url における %scheme 用の~handlerとして， %handler を登録する。
例えば，~online-telephone-messaging~serviceは、
自身を
`sms:＠~RFCx/rfc5724#section-2$sc ~scheme用の~handlerとして登録することもできる
— 利用者がそのような~linkを~clickしたとき，その~web~siteを利用する機会が与えられるように。
`SMS$r
◎
Registers a handler for scheme at url. For example, an online telephone messaging service could register itself as a handler of the sms: scheme, so that if the user clicks on such a link, they are given the opportunity to use that web site. [SMS]
</dd>
	<dd>
%url 内の文字列 `%s^l は、［
取扱われることになる内容の~URL
］に置き換えられる仮入力として利用される。
◎
The string "%s" in url is used as a placeholder for where to put the URL of the content to be handled.
</dd>
	<dd>
~UAが登録を阻止する場合、
`SecurityError$E 例外が投出される
（一例として、
`http^sc 用の~handlerを登録しようと試行した場合）。
◎
Throws a "SecurityError" DOMException if the user agent blocks the registration (this might happen if trying to register as a handler for "http", for instance).
</dd>
	<dd>
%url 内に文字列 `%s^l が見当たらない場合、
`SyntaxError$E 例外が投出される。
◎
Throws a "SyntaxError" DOMException if the "%s" string is missing in url.
</dd>

	<dt>%window.`navigator$m.`unregisterProtocolHandler(scheme, url)$m</dt>
	<dd>
引数で記述される~handlerを未登録にする。
◎
Unregisters the handler given by the arguments.
</dd>
	<dd>
~UAが未登録にするのを阻止する場合、
`SecurityError$E が投出される
（一例として、
~schemeが妥当でない場合に起こり得る）。
◎
Throws a "SecurityError" DOMException if the user agent blocks the deregistration (this might happen if with invalid schemes, for instance).
</dd>
	<dd>
%url 内に文字列 `%s^l が見当たらない場合、
`SyntaxError$E 例外が投出される。
◎
Throws a "SyntaxError" DOMException if the "%s" string is missing in url.
</dd>
</dl>

<div class="algo">
<p>
`registerProtocolHandler(scheme, url)@m
~method手続きは：
◎
The registerProtocolHandler(scheme, url) method steps are:
</p>
<ol>
	<li>
( %正規化した~scheme, %正規化した~URL )
~LET `~protocol~handler~parameterを正規化する$( %scheme, %url, コレに`関連な設定群~obj$ )
◎
Let (normalizedScheme, normalizedURLString) be the result of running normalize protocol handler parameters with scheme, url, and this's relevant settings object.
</li>
	<li>
<p>
`~protocol~handlerを登録する@
— 以下に従う下で，`並列的$に
( %正規化した~scheme, %正規化した~URL )
用の~handlerを登録する：
◎
In parallel: register a protocol handler for normalizedScheme and normalizedURLString.＼
</p>
		<ul>
			<li>
<p>
~handlerを登録するときは、
他所に述べられる拘束の下で，好きに行ってヨイ。
一例として、
次を行うこともできる：
◎
User agents may, within the constraints described, do whatever they like. A user agent could, for instance,＼
</p>
				<ul>
					<li>
利用者に~promptして，［
~handlerの選抜listに~siteを追加する ／
既定の~handlerにする ／
要請を取消す
］機会を提供する。
◎
prompt the user and offer the user the opportunity to add the site to a shortlist of handlers, or make the handlers their default, or cancel the request.＼
</li>
					<li>
黙って情報を収集しておいた上で、
利用者に関連するときに限り，前項を供する。
◎
User agents could also silently collect the information, providing it only when relevant to the user.
</li>
				</ul>
			</li>
			<li>
同じ要請が利用者に繰返し~promptされないよう，［
どの~siteが どの~handlerを登録したか
］を追跡し続けるベキである
（利用者が登録を辞退した場合も含めて）。
◎
User agents should keep track of which sites have registered handlers (even if the user has declined such registrations) so that the user is not repeatedly prompted with the same request.
</li>
		</ul>

<p>
コレに`関連な大域~obj$に`結付けられた文書$の［
`~RPH自動化~mode$ ~NEQ
`none@rph
］の場合、
~UAは，次に従うベキである：
◎
If the registerProtocolHandler() automation mode of this's relevant global object's associated Document is not "none", the user agent should＼
</p>
		<ol>
			<li>
自動化~文脈の下にあることを検証yする
（ `WEBDRIVER$r `§ ~securityの考慮点＠~WEBDRIVER#security$
を見よ）。
◎
first verify that it is in an automation context (see WebDriver's security considerations).＼
</li>
			<li>
上述した［
情報の通信, 利用者からの同意を得ること
］を素通りして，代わりに利用者が次を行ったかのように動作する
⇒
利用者は、
登録の詳細を見て，当の要請を`~RPH自動化~mode$の値に応じて
⇒
`autoAccept@rph
ならば受容した／
`autoReject@rph
ならば却下した
◎
The user agent should then bypass the above communication of information and gathering of user consent,＼
and instead do the following based on the value of the registerProtocolHandler() automation mode:
• "autoAccept"
•• Act as if the user has seen the registration details and accepted the request.
• "autoReject"
•• Act as if the user has seen the registration details and rejected the request.
</li>
		</ol>


<div class="algo">
<p>
~UAが所与の
( `~URL$ %入力~URL )
用に
`登録した~handlerを利用する@
ときは：
◎
When the user agent uses this handler for a URL inputURL:
</p>
		<ol>
			<li>
~Assert：
%入力~URL の`~scheme$url ~EQ %正規化した~scheme
◎
Assert: inputURL's scheme is normalizedScheme.
</li>
			<li>
`~usernameを設定する$( %入力~URL, 空~文字列 )
◎
Set the username given inputURL and the empty string.
</li>
			<li>
`~passwordを設定する$( %入力~URL, 空~文字列 )
◎
Set the password given inputURL and the empty string.
</li>
			<li>
%入力~URL文字列 ~LET `~URLを直列化する$( %入力~URL )
◎
Let inputURLString be the serialization of inputURL.
</li>
			<li>
%符号化した~URL ~LET `文字列を~UTF-8~percent-符号化する$( %入力~URL文字列, `成分~percent-符号化-集合$ )
◎
Let encodedURL be the result of running UTF-8 percent-encode on inputURLString using the component percent-encode set.
</li>
			<li>
%~handler~URL文字列 ~LET `~URLを直列化する$( %正規化した~URL )
◎
Let handlerURLString be normalizedURLString.
</li>
			<li>
%~handler~URL文字列 の中の最初に現れる文字列 `%s^l を %符号化した~URL に置換する
◎
Replace the first instance of "%s" in handlerURLString with encodedURL.
</li>
			<li>
%結果~URL ~LET `~URL構文解析する$( %~handler~URL文字列 )
◎
Let resultURL be the result of parsing handlerURLString.
</li>
			<li>
適切な`~navigable$を %結果~URL へ`~navigate$する
◎
Navigate an appropriate navigable to resultURL.
</li>
		</ol>
</div>

<div class="example">
<p>
利用者が［
~site `https://example.com/^c を訪問している間
］に，次が~callされたとする：
◎
If the user had visited a site at https://example.com/ that made the following call:
</p>

<pre class="lang-js">
navigator.registerProtocolHandler('web+soup', 'soup?url=`%s^_')
</pre>

<p>
しばらく経ってから、［
`https://www.example.net/^c を訪問している間
］に，次のような~linkを~clickしたとする：
◎
...and then, much later, while visiting https://www.example.net/, clicked on a link such as:
</p>

<pre class="lang-html">
&lt;a href="web+soup:chickenkïwi"&gt;チキンのキーウィスープをダウンロードする&lt;/a&gt;
</pre>

<p>
このとき、
~UAは，次の~URLへ~navigateするかもしれない：
◎
...then the UA might navigate to the following URL:
</p>

<pre>
`https://example.com/soup?url=web+soup:chicken-k%C3%AFwi^l
</pre>

<p>
この~siteは、
何であれ `soup^c についての何かを行うこともできる
（それを合成した上で，利用者に送るなど）。
◎
This site could then do whatever it is that it does with soup (synthesize it and ship it to the user, or whatever).
</p>
</div>

<p>
これは、
当の~handlerがいつ利用されるかは，定義しない。
文書~間を`~navigate$するときの処理~modelは，関連な事例を ある程度~定義するが、
一般に，［
さもなければ、［
~nativeな~plugin／~helper~app
］に~schemeを手渡すことを考慮することになる所
］では、
~UAは，この情報を利用してもヨイ。
◎
This does not define when the handler is used. To some extent, the processing model for navigating across documents defines some cases where it is relevant, but in general user agents may use this information wherever they would otherwise consider handing schemes to native plugins or helper applications.
</p>
	</li>
</ol>
</div>

<div class="algo">
<p>
`unregisterProtocolHandler(scheme, url)@m
~method手続きは：
◎
The unregisterProtocolHandler(scheme, url) method steps are:
</p>
<ol>
	<li>
( %正規化した~scheme, %正規化した~URL ) ~LET `~protocol~handler~parameterを正規化する$( %scheme, %url, コレに`関連な設定群~obj$ )
◎
Let (normalizedScheme, normalizedURLString) be the result of running normalize protocol handler parameters with scheme, url, and this's relevant settings object.
</li>
	<li>
`並列的$に
⇒
( %正規化した~scheme, %正規化した~URL )
で記述される~handlerを未登録にする
◎
In parallel: unregister the handler described by normalizedScheme and normalizedURLString.
</li>
</ol>
</div>

<hr>

<div class="algo">
<p>
`~protocol~handler~parameterを正規化する@
ときは、所与の
( 文字列 %~scheme, 文字列 %~URL, `環境~設定群~obj$ %環境 )
に対し，次の手続きを走らす：
◎
To normalize protocol handler parameters, given a string scheme, a string url, and an environment settings object environment, run these steps:
</p>

<ol>
	<li>
%~scheme ~SET `~ASCII小文字~化する$( %~scheme )
◎
Set scheme to scheme, converted to ASCII lowercase.
</li>
	<li>
<div class="p">
<p>
~IF［
~NOT ~OR↓
］…
</p>
		<ul>
			<li>
%~scheme は`安全とされる~scheme$である
</li>
			<li>
%~scheme は `web+^l から開始していて，後続する部分は 1 個以上の`~ASCII英小文字$のみからなる
</li>
		</ul>
<p>
…ならば
⇒
~THROW `SecurityError$E
</p>

◎
If scheme is neither a safelisted scheme nor a string starting with "web+" followed by one or more ASCII lower alphas, then throw a "SecurityError" DOMException.
</div>

<p class="note">注記：
%~scheme 内に~colonを含めると（例： `mailto:^l ），この段で投出されることになる。
◎
This means that including a colon in scheme (as in "mailto:") will throw.
</p>

<p>
`安全とされる~scheme@
は、
次に挙げるものからなる：
◎
The following schemes are the safelisted schemes:
</p>

<ul class="category-list"><li>`bitcoin^sc
</li><li>`ftp^sc
</li><li>`ftps^sc
</li><li>`geo^sc
</li><li>`im^sc
</li><li>`irc^sc
</li><li>`ircs^sc
</li><li>`magnet^sc
</li><li>`mailto^sc
</li><li>`matrix^sc
</li><li>`mms^sc
</li><li>`news^sc
</li><li>`nntp^sc
</li><li>`openpgp4fpr^sc
</li><li>`sftp^sc
</li><li>`sip^sc
</li><li>`sms^sc
</li><li>`smsto^sc
</li><li>`ssh^sc
</li><li>`tel^sc
</li><li>`urn^sc
</li><li>`webcal^sc
</li><li>`wtai^sc
</li><li>`xmpp^sc
</li></ul>

<p class="note">注記：
この~listは変更され得る。
追加されるべき~schemeがあれば、
~feedbackを寄せられたし。
◎
This list can be changed. If there are schemes that ought to be added, please send feedback.
</p>
	</li>
	<li>
~IF［
%~URL は文字列 `%s^l を包含していない
］
⇒
~THROW `SyntaxError$E
◎
If url does not contain "%s", then throw a "SyntaxError" DOMException.
</li>
	<li>
%~URL~record ~LET `~URLを符号化法の下で相対的に構文解析する$( %~URL, %環境 )
◎
Let urlRecord be the result of encoding-parsing a URL given url, relative to environment.
</li>
	<li>
<p>
~IF［
%~URL~record ~EQ `失敗^i
］
⇒
~THROW `SyntaxError$E
◎
If urlRecord is failure, then throw a "SyntaxError" DOMException.
</p>

<p class="note">注記：
仮入力 `%s^l が %~URL の［
~host／~port
］†内にある事例では、
この段が強制される。
【† `~schemeが除外されている理由＠https://github.com/web-platform-tests/wpt/pull/24886$】
◎
This is forcibly the case if the %s placeholder is in the host or port of the URL.
</p>
	</li>
	<li>
~IF［
%~URL~record の`~scheme$url は`~HTTP_S~scheme$でない
］~OR［
( %~URL~record の`生成元$url, %環境 の`生成元$enV )
は`同一-生成元$でない
］
⇒
~THROW `SecurityError$E
◎
If urlRecord's scheme is not an HTTP(S) scheme or urlRecord's origin is not same origin with environment's origin, then throw a "SecurityError" DOMException.
</li>
	<li>
<p>
~Assert：
%~URL~record は`信用に価し得る~URL$である
◎
Assert: the result of Is url potentially trustworthy? given urlRecord is "Potentially Trustworthy".
</p>

<p class="note">注記：
この~algoは，`~secureな文脈$enVの中で走るので、
これは，`同一-生成元$の条件により含意される。
◎
Because normalize protocol handler parameters is run within a secure context, this is implied by the same origin condition.
</p>
	</li>
	<li>
<p>
~RET ( %~scheme, %~URL~record )
◎
Return (scheme, urlRecord).
</p>

<p class="note">注記：
%~URL~record を`直列化した結果＠~URL1#concept-url-serializer$は、
~URL内では妥当な成分でない文字列 `%s^l を含むので，
定義により`妥当な~URL文字列$にはならない。
◎
The serialization of urlRecord will by definition not be a valid URL string as it includes the string "%s" which is not a valid component in a URL.
</p>
	</li>
</ol>
</div>

					<section id="security-and-privacy">
<h6 title="Security and privacy">8.9.1.4.1. ~securityと~privacy</h6>

<p>
~custom~scheme~handlerは、
いくつかの懸念
— 特に，~privacyの懸念 —
を導入し得る：
◎
Custom scheme handlers can introduce a number of concerns, in particular privacy concerns.
</p>

<dl>
	<dt>
すべての~web用法の乗取り
◎
Hijacking all web usage.＼
</dt>
	<dd>
~UAは、［
`~HTTP_S~scheme$など，通常運用の要を成す~scheme
］に対しては，［
第三者-主体~siteに経由し直される
］ことを許容するベキでない。
これを許容すると、
利用者の活動は自明に追跡され，［
~secureな接続であろうが，利用者~情報は収集される
］ことになる。
◎
User agents should not allow schemes that are key to its normal operation, such as an HTTP(S) scheme, to be rerouted through third-party sites. This would allow a user's activities to be trivially tracked, and would allow user information, even in secure connections, to be collected.
</dd>

	<dt>
既定に対する乗取り
◎
Hijacking defaults.＼
</dt>
	<dd>
~UAには、［
どの既定も自動的に変更しない
］ことが強く督促される
— そうすると、
利用者が期待していない~remote~hostへ~dataが送信されかねないので。
自身を登録している新たな~handlerに，自動的にその種の~siteを利用させることは、
決して生じるベキでない。
◎
User agents are strongly urged to not automatically change any defaults, as this could lead the user to send data to remote hosts that the user is not expecting. New handlers registering themselves should never automatically cause those sites to be used.
</dd>

	<dt>
~spam的な登録
◎
Registration spamming.＼
</dt>
	<dd>
~UAは、［
ある~siteが多数の~handlerを登録しようと試みる可能性
］を考慮するベキである。
複数の~domainから行われる場合もある
（例：
異なる~domain上にある 一連の~pageを通して~redirectして，
複数の `web+mpeg^mt 用の~handlerを登録するなど
— 他の~web~browser特能を濫用するような，相似する実施は、
~pornography~web~siteにより何年も利用されている）。
~UAは、
そのような敵対的な試みを上品に取扱って，
利用者を保護するベキである。
◎
User agents should consider the possibility that a site will attempt to register a large number of handlers, possibly from multiple domains (e.g., by redirecting through a series of pages each on a different domain, and each registering a handler for web+spam: — analogous practices abusing other web browser features have been used by pornography web sites for many years). User agents should gracefully handle such hostile attempts, protecting the user.
</dd>

	<dt>
敵対的な~handler~metadata
◎
Hostile handler metadata.＼
</dt>
	<dd>
~UAは、［
自身の~UI内に埋込まれる文字列
］を利用する代表的な攻撃に抗して，保護するベキである
— 例えば、
次に挙げるふるまいを確保するなど
⇒＃
そのような文字列~内の~markupや文字~escapeは，実行しない／
~NULL ~byteを適正に取扱う／
長過ぎる文字列により~crashや~buffer-overrunは，生じない／
…等々
◎
User agents should protect against typical attacks against strings embedded in their interface, for example ensuring that markup or escape characters in such strings are not executed, that null bytes are properly handled, that over-long strings do not cause crashes or buffer overruns, and so forth.
</dd>

	<dt>
私的な~dataの漏洩ng
◎
Leaking private data.＼
</dt>
	<dd>
~web~page作者は、
私的と見なされる~URL~dataを利用して，
~custom~scheme~handlerを参照することもあろう
— 利用者が［
ある組織の内側にある~pageを指す~handler
］を選ぶことを期待して，それにより［
敏感な~dataは第三者-主体に公開されない
］ことが確保されるよう。
しかしながら，利用者は［
外部~siteを指している~handler
］を登録するかもしれず、
その場合，その第三者-主体へ~dataが漏洩する。
実装者は、
ある種の［
下位domain／内容~型／~scheme
］に対しては，［
【~intranetなどの】管理者が~custom~handlerを不能化できる
］ようにしたいと考えるかもしれない。
◎
Web page authors may reference a custom scheme handler using URL data considered private. They might do so with the expectation that the user's choice of handler points to a page inside the organization, ensuring that sensitive data will not be exposed to third parties. However, a user may have registered a handler pointing to an external site, resulting in a data leak to that third party. Implementers might wish to consider allowing administrators to disable custom handlers on certain subdomains, content types, or schemes.
</dd>

	<dt>
~UIへの干渉
◎
Interface interference.＼
</dt>
	<dd>
~UAは、［
~methodに意図的に長い引数が渡されたとき
］の~~対策も講じておくベキである。
例えば、
公開される~UI内に 2 個の~button［
“受認-”, “否認-”
］があって，
~handlerの名前が “受認-” ~buttonに束ねられている場合、［
長い名前により “否認-” ~buttonが~screen外へ押し出されないようにする
］ことが重要になる。
◎
User agents should be prepared to handle intentionally long arguments to the methods. For example, if the user interface exposed consists of an "accept" button and a "deny" button, with the "accept" binding containing the name of the handler, it's important that a long name not cause the "deny" button to be pushed off the screen.
</dd>
</dl>

					</section>
					<section id="user-agent-automation">
<h6 title="User agent automation">8.9.1.4.2. `~UA自動化@</h6>

<p>
各`文書$は、
`~RPH自動化~mode@
を有する。
それは、［
`none$rph,
`autoAccept$rph,
`autoReject$rph
］いずれかをとり，
既定は `none$rph とする。
◎
Each Document has a registerProtocolHandler() automation mode. It defaults to "none", but it also can be either "autoAccept" or "autoReject".
</p>

<p class="trans-note">【
~RPHは、
`registerProtocolHandler()$m の略語
（この訳では、
一律に略語表記に統一する）。
】</p>

<p>
この標準は、
~UA自動化と~web~siteを~testする目的~用に，
~WebDriver`拡張~command$
`~RPH登録~modeを設定する@
を定義する。
それは、
~UAに`文書$を ある~modeの中へ設置するよう指図する
— その~modeにおいては、
~UAは，［
登録~確認~prompt~dialogを［
受容して／却下して
］いる利用者
］を自動的に模倣することになる。
◎
For the purposes of user agent automation and website testing, this standard defines Set RPH Registration Mode WebDriver extension command. It instructs the user agent to place a Document into a mode where it will automatically simulate a user either accepting or rejecting and registration confirmation prompt dialog.
</p>

<table><thead><tr><th>~HTTP~method
<th>~URI~template
<tbody><tr><td>`POST^M
<td>`/session/{session id}/custom-handlers/set-mode^c
</table>

<div class="algo">
<p>
この~commandの`~remote端~手続き$は
【所与の %~parameter群 に対し】：
◎
The remote end steps are:
</p>
<ol>
	<li>
~IF［
%~parameter群 は~JSON `object^jt でない
］
⇒
~RET 新たな`~WebDriver~error$
— その
⇒
`~WebDriver~error~code$ ~SET `無効な引数$
◎
If parameters is not a JSON Object, return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
%~mode ~LET %~parameter群 から `mode^l と命名された`~propを取得する$
◎
Let mode be the result of getting a property named "mode" from parameters.
</li>
	<li>
~IF［
%~mode ~NIN { `autoAccept$rph, `autoReject$rph, `none$rph }
⇒
~RET 新たな`~WebDriver~error$
— その
⇒
`~WebDriver~error~code$ ~SET `無効な引数$
◎
If mode is not "autoAccept", "autoReject, or "none", return a WebDriver error with WebDriver error code invalid argument.
</li>
	<li>
%文書 ~LET `現在の閲覧~文脈$にて`作動中な文書$bc
◎
Let document be the current browsing context's active document.
</li>
	<li>
%文書 の`~RPH自動化~mode$ ~SET %~mode
◎
Set document's registerProtocolHandler() automation mode to mode.
</li>
	<li>
~RET 新たな`成功$
— その
⇒
~data ~SET ~NULL
◎
Return success with data null.
</li>
</ol>
</div>

					</section>
				</section>
				<section id="cookies">
<h5 title="Cookies">8.9.1.5. ~cookie</h5>

<pre class="idl">
interface mixin `NavigatorCookies@I {
  readonly attribute boolean `cookieEnabled$m;
};
</pre>

<dl class="domintro">

	<dt>%window.`navigator$m.`cookieEnabled$m</dt>
	<dd>
~cookieを設定しても無視されるならば ~F ／
~ELSE_ ~T
を返す。
◎
Returns false if setting a cookie will be ignored, and true otherwise.
</dd>
</dl>

<div class="algo">
`cookieEnabled@m
取得子~手続きは
⇒
~RET ［
~UAが `HTTP State Management Mechanism^cite `COOKIES$r に則って~cookieを取扱うよう試みるならば ~T ／
~ELSE_（すなわち，~cookie変更-要請を無視するならば） ~F
］
◎
The cookieEnabled attribute must return true if the user agent attempts to handle cookies according to HTTP State Management Mechanism, and false if it ignores cookie change requests. [COOKIES]
</div>

				</section>
				<section id="pdf-viewing-support">
<h5 title="PDF viewing support">8.9.1.6. ~PDF~view用の~support</h5>

<dl class="domintro">
	<dt>%window.`navigator$m.`pdfViewerEnabled$m</dt>
	<dd>
~UAは次を［
~supportするならば ~T ／ ~supportしないならば ~F
］を返す
⇒
~PDF~fileへ`~navigate$するとき，~inlineで それを~viewする
◎
Returns true if the user agent supports inline viewing of PDF files when navigating to them, or false otherwise.＼
</dd>
	<dd>
~supportしない事例では、
当の~PDF~fileは，
`外部~softwareにより取扱われる＠~HTMLnav#hand-off-to-external-software$ことになる。
◎
In the latter case, PDF files will be handled by external software.
</dd>
</dl>

<pre class="idl">
interface mixin `NavigatorPlugins@I {
  [SameObject] readonly attribute `PluginArray$I `plugins$m;
  [SameObject] readonly attribute `MimeTypeArray$I `mimeTypes$m;
  boolean `javaEnabled$m();
  readonly attribute boolean `pdfViewerEnabled$m;
};

[Exposed=Window,
 `LegacyUnenumerableNamedProperties$]
interface `PluginArray@I {
  undefined `refresh$pA();
  readonly attribute unsigned long `length$pA;
  getter `Plugin$I? `item$pA(unsigned long index);
  getter `Plugin$I? `namedItem$pA(DOMString name);
};

[Exposed=Window,
 `LegacyUnenumerableNamedProperties$]
interface `MimeTypeArray@I {
  readonly attribute unsigned long `length$mA;
  getter `MimeType$I? `item$mA(unsigned long index);
  getter `MimeType$I? `namedItem$mA(DOMString name);
};

[Exposed=Window,
 `LegacyUnenumerableNamedProperties$]
interface `Plugin@I {
  readonly attribute DOMString `name$mP;
  readonly attribute DOMString `description$mP;
  readonly attribute DOMString `filename$mP;
  readonly attribute unsigned long `length$mP;
  getter `MimeType$I? `item$mP(unsigned long index);
  getter `MimeType$I? `namedItem$mP(DOMString name);
};

[Exposed=Window]
interface `MimeType@I {
  readonly attribute DOMString `type$mM;
  readonly attribute DOMString `description$mM;
  readonly attribute DOMString `suffixes$mM;
  readonly attribute `Plugin$I `enabledPlugin$mM;
};
</pre>

<p>
~PDF~viewerの~support有無は、
いまどきは， `pdfViewerEnabled$m を介して検出できるが、
歴史的な理由から，同じ能力を供する［
複階的で入り組んだ，いくつかの~interface
］があり、
旧来の~codeは，それらに依拠している。
この節では、
前者の単純な現代の変種に加え，
後者の複雑な歴史的な方も指定する。
◎
Although these days detecting PDF viewer support can be done via navigator.pdfViewerEnabled, for historical reasons, there are a number of complex and intertwined interfaces that provide the same capability, which legacy code relies on. This section specifies both the simple modern variant and the complicated historical one.
</p>

<p>
各~UAは、
真偽値をとる
`~PDF~viewerは~supportされるか@
を有する
— その値は、
`実装定義$とする
（加えて、利用者-選好に則って変わり得る）。
◎
Each user agent has a PDF viewer supported boolean, whose value is implementation-defined (and might vary according to user preferences).
</p>

<p class="note">注記：
この値は、
`~navi$の処理~modelにも影響iする。
◎
This value also impacts the navigation processing model.
</p>

<hr>

<p>
各 `Window$I ~objは、
次に挙げるものを有する：
◎
↓
</p>
<ul>
	<li>
<p>
`~PDF~viewer~plugin~obj~list@
⇒
~UAの`~PDF~viewerは~supportされるか$に応じて
⇒＃
~F ならば 空~list ／
~T ならば 5 個の `Plugin$I ~objを包含する~list
◎
Each Window object has a PDF viewer plugin objects list. If the user agent's PDF viewer supported is false, then it is the empty list. Otherwise, it is a list containing five Plugin objects,＼
</p>

<p>
後者を成す各 `Plugin$I は、
順に，次に挙げる`名前$pGを伴うとする
⇒＃
`PDF Viewer^l,
`Chrome PDF Viewer^l,
`Chromium PDF Viewer^l,
`Microsoft Edge PDF Viewer^l,
`WebKit built-in PDF^l
◎
whose names are, respectively:
• "PDF Viewer"
• "Chrome PDF Viewer"
• "Chromium PDF Viewer"
• "Microsoft Edge PDF Viewer"
• "WebKit built-in PDF" 
</p>

<p>
`~PDF~viewer~plugin名~list@
は、
順に，上に挙げた値たちから形成される。
◎
The values of the above list form the PDF viewer plugin names list.
</p>

<p class="note">注記：
これらの名前は、
~web~siteに対し，歴史的に何が探索されていたかについての調査結果
— したがって、
~UAにとって［
既存の内容との互換性を保守するために，公開すること
］が必要yなもの —
に基づいて選ばれた。
これらは，~alphabet順に挙げられているが、
名前 `PDF Viewer^l は
— `enabledPlugin$mM 取得子が汎用な~plugin名を指せるよう —
0 番の位置に挿入される。
◎
These names were chosen based on evidence of what websites historically search for, and thus what is necessary for user agents to expose in order to maintain compatibility with existing content. They are ordered alphabetically. The "PDF Viewer" name was then inserted in the 0th position so that the enabledPlugin getter could point to a generic plugin name.
</p>
	</li>
	<li>
<p>
`~PDF~viewer~MIME型~obj~list@
⇒
~UAの`~PDF~viewerは~supportされるか$に応じて
⇒＃
~F ならば 空~list／
~T ならば 2 個の `MimeType$I ~objを包含している~list
◎
Each Window object has a PDF viewer mime type objects list. If the user agent's PDF viewer supported is false, then it is the empty list. Otherwise, it is a list containing two MimeType objects,＼
</p>

<p>
後者を成す各 `MimeType$I は、
順に，次に挙げる`型$を伴うとする
⇒＃
`application/pdf^l,
`text/pdf^l
◎
whose types are, respectively:
• "application/pdf"
• "text/pdf" 
</p>

<p>
`~PDF~viewer~MIME型~list@
は、
順に，上に挙げた型たちから形成される。
◎
The values of the above list form the PDF viewer mime types list.
</p>
	</li>
</ul>

<hr>

<p>
各 `NavigatorPlugins$I ~objは、
次に挙げるものを有する：
◎
Each NavigatorPlugins object has＼
</p>
<ul>
	<li>
`~plugin配列@
⇒
新たな `PluginArray$I ~obj
◎
a plugins array, which is a new PluginArray,＼
</li>
	<li>
`~MIME型~配列@
⇒
新たな `MimeTypeArray$I ~obj
◎
and a mime types array, which is a new MimeTypeArray.
</li>
</ul>

<p>
`NavigatorPlugins$I ~mixinの：
◎
↓</p>
<ul>
	<li class="algo">
`plugins@m
取得子~手続きは
⇒
~RET コレの`~plugin配列$
◎
The NavigatorPlugins mixin's plugins getter steps are to return this's plugins array.
</li>
	<li class="algo">
`mimeTypes@m
取得子~手続きは
⇒
~RET コレの`~MIME型~配列$
◎
The NavigatorPlugins mixin's mimeTypes getter steps are to return this's mime types array.
</li>
	<li class="algo">
`javaEnabled()@m
~method手続きは
⇒
~RET ~F
◎
The NavigatorPlugins mixin's javaEnabled() method steps are to return false.
</li>
	<li class="algo">
`pdfViewerEnabled@m
取得子~手続きは
⇒
~RET ~UAの`~PDF~viewerは~supportされるか$
◎
The NavigatorPlugins mixin's pdfViewerEnabled getter steps are to return the user agent's PDF viewer supported.
</li>
</ul>

<hr>

<p>
`PluginArray$I ~interfaceの：
◎
↓</p>
<ul>
	<li>
`~supportする~prop名$は
⇒
~UAの`~PDF~viewerは~supportされるか$に応じて
⇒＃
~T ならば `~PDF~viewer~plugin名~list$ ／
~F ならば空~list
◎
The PluginArray interface supports named properties. If the user agent's PDF viewer supported is true, then they are the PDF viewer plugin names. Otherwise, they are the empty list.
</li>
	<li class="algo">
<p>
`namedItem(name)@pA
~method手続きは：
◎
The PluginArray interface's namedItem(name) method steps are:
</p>
		<ol>
			<li>
コレに`関連な大域~obj$の`~PDF~viewer~plugin~obj~list$を成す
~EACH( `Plugin$I %~plugin )
に対し
⇒
~IF［
%~plugin の`名前$pG ~EQ %name
］
⇒
~RET %~plugin
◎
For each Plugin plugin of this's relevant global object's PDF viewer plugin objects: if plugin's name is name, then return plugin.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li class="algo">
`~supportする~prop~index$は
⇒
コレに`関連な大域~obj$の`~PDF~viewer~plugin~obj~list$の`~index群$
◎
The PluginArray interface supports indexed properties. The supported property indices are the indices of this's relevant global object's PDF viewer plugin objects.
</li>
	<li class="algo">
<p>
`item(index)@pA
~method手続きは：
◎
The PluginArray interface's item(index) method steps are:
</p>
		<ol>
			<li>
%~plugin~list ~LET コレに`関連な大域~obj$の`~PDF~viewer~plugin~obj~list$
◎
Let plugins be this's relevant global object's PDF viewer plugin objects.
</li>
			<li>
~IF［
%index ~LT %~plugin~list の`~size$
］
⇒
~RET %~plugin~list[ %index ]
◎
If index &lt; plugins's size, then return plugins[index].
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li class="algo">
`length@pA
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$の`~PDF~viewer~plugin~obj~list$の`~size$
◎
The PluginArray interface's length getter steps are to return this's relevant global object's PDF viewer plugin objects's size.
</li>
	<li class="algo">
`refresh()@pA
~method手続きは、
何もしない。
◎
The PluginArray interface's refresh() method steps are to do nothing.
</li>
</ul>

<hr>

<p>
`MimeTypeArray$I ~interfaceの：
◎
↓</p>
<ul>
	<li>
`~supportする~prop名$は
⇒
~UAの`~PDF~viewerは~supportされるか$に応じて
⇒＃
~T ならば `~PDF~viewer~MIME型~list$／
~F ならば 空~list
◎
The MimeTypeArray interface supports named properties. If the user agent's PDF viewer supported is true, then they are the PDF viewer mime types. Otherwise, they are the empty list.
</li>
	<li class="algo">
<p>
`namedItem(name)@mA
~method手続きは：
◎
The MimeTypeArray interface's namedItem(name) method steps are:
</p>
		<ol>
			<li>
コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$を成す
~EACH( `MimeType$I %~MIME型 )
に対し
⇒
~IF［
%~MIME型 の`型$ ~EQ %name
］
⇒
~RET %~MIME型
◎
For each MimeType mimeType of this's relevant global object's PDF viewer mime type objects: if mimeType's type is name, then return mimeType.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
`~supportする~prop~index$は
⇒
コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$の`~index群$
◎
The MimeTypeArray interface supports indexed properties. The supported property indices are the indices of this's relevant global object's PDF viewer mime type objects.
</li>
	<li class="algo">
<p>
`item(index)@mA
~method手続きは：
◎
The MimeTypeArray interface's item(index) method steps are:
</p>
		<ol>
			<li>
%~MIME型~list ~LET コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$
◎
Let mimeTypes be this's relevant global object's PDF viewer mime type objects.
</li>
			<li>
~IF［
%index ~LT %~MIME型~list の`~size$
］
⇒
~RET %~MIME型~list[ %index ]
◎
If index &lt; mimeTypes's size, then return mimeTypes[index].
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li class="algo">
`length@mA
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$の`~size$
◎
The MimeTypeArray interface's length getter steps are to return this's relevant global object's PDF viewer mime type objects's size.
</li>
</ul>

<hr>

<p>
各 `Plugin$I ~objは
`名前@pG
を有する
— それは、
当の~objの作成-時に設定される。
◎
Each Plugin object has a name, which is set when the object is created.
</p>

<p>
`Plugin$I ~interfaceの：
◎
↓</p>
<ul>
	<li class="algo">
`name@mP
取得子~手続きは
⇒
~RET コレの`名前$pG
◎
The Plugin interface's name getter steps are to return this's name.
</li>
	<li class="algo">
`description@mP
取得子~手続きは
⇒
~RET `Portable Document Format^l
◎
The Plugin interface's description getter steps are to return "Portable Document Format".
</li>
	<li class="algo">
`filename@mP
取得子~手続きは
⇒
~RET `internal-pdf-viewer^l
◎
The Plugin interface's filename getter steps are to return "internal-pdf-viewer".
</li>
	<li>
`~supportする~prop名$は
⇒
~UAの`~PDF~viewerは~supportされるか$に応じて
⇒＃
~T ならば `~PDF~viewer~MIME型~list$／
~F ならば 空~list
◎
The Plugin interface supports named properties. If the user agent's PDF viewer supported is true, then they are the PDF viewer mime types. Otherwise, they are the empty list.
</li>
	<li class="algo">
<p>
`namedItem(name)@mP
~method手続きは：
◎
The Plugin interface's namedItem(name) method steps are:
</p>
		<ol>
			<li>
コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$を成す
~EACH( `MimeType$I %~MIME型 )
に対し
⇒
~IF［
%~MIME型 の`型$ ~EQ %name
］
⇒
~RET %~MIME型
◎
For each MimeType mimeType of this's relevant global object's PDF viewer mime type objects: if mimeType's type is name, then return mimeType.
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li>
`~supportする~prop~index$は
⇒
コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$の`~index群$
◎
The Plugin interface supports indexed properties. The supported property indices are the indices of this's relevant global object's PDF viewer mime type objects.
</li>
	<li class="algo">
<p>
`item(index)@mP
~method手続きは：
◎
The Plugin interface's item(index) method steps are:
</p>
		<ol>
			<li>
%~MIME型~list ~LET コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$
◎
Let mimeTypes be this's relevant global object's PDF viewer mime type objects.
</li>
			<li>
~IF［
%index ~LT %~MIME型~list の`~size$
］
⇒
~RET %~MIME型~list[ %index ]
◎
If index &lt; mimeType's size, then return mimeTypes[index].
</li>
			<li>
~RET ~NULL
◎
Return null.
</li>
		</ol>
	</li>
	<li class="algo">
`length@mP
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$の`~PDF~viewer~MIME型~obj~list$の`~size$
◎
The Plugin interface's length getter steps are to return this's relevant global object's PDF viewer mime type objects's size.
</li>
</ul>

<hr>

<p>
各 `MimeType$I ~objは
`型@
を有する
— それは、
当の~objの作成-時に設定される。
◎
Each MimeType object has a type, which is set when the object is created.
</p>

<p>
`MimeType$I ~interfaceの：
◎
↓</p>
<ul>
	<li class="algo">
`type@mM
取得子~手続きは
⇒
~RET コレの`型$
◎
The MimeType interface's type getter steps are to return this's type.
</li>
	<li class="algo">
`description@mM
取得子~手続きは
⇒
~RET `Portable Document Format^l
◎
The MimeType interface's description getter steps are to return "Portable Document Format".
</li>
	<li class="algo">
`suffixes@mM
取得子~手続きは
⇒
~RET `pdf^l
◎
The MimeType interface's suffixes getter steps are to return "pdf".
</li>
	<li class="algo">
`enabledPlugin@mM
取得子~手続きは
⇒
~RET コレに`関連な大域~obj$の`~PDF~viewer~plugin~obj~list$[ 0 ]
（すなわち，汎用な `PDF Viewer^l ）
◎
The MimeType interface's enabledPlugin getter steps are to return this's relevant global object's PDF viewer plugin objects[0] (i.e., the generic "PDF Viewer" one).
</li>
</ul>

				</section>
			</section>
		</section>
</main>
