<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS の値と単位 — CSS Values and Units Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
	} else {
		text = `${key}()`;
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if( i > 0 ){
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i+1)}</code>`;
		}
	}
	break;
case 'at':
	text = `@${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Values and Units Module Level 5
spec_date:2023-04-06
trans_update:2023-05-08
source_checked:230406
page_state_key:CSS
original_url:https://drafts.csswg.org/css-values-5/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2023,permissive
trans_1st_pub:2023-04-15

●●class_map
p:property
css:css
at:at-rule
t:type
u:unit
f:func
v:value
e:element
a:attr
P:prod

●●tag_map
p:code
t:var
css:code
at:code
v:code
e:code
a:code
f:code
u:code
c:code
P:code
i:i
em:em
I:code
cite:cite

●●words_table1
NaN:NaN

●●words_table

	●構文
	-:trimming
	文字大小区別かどうか:case-sensitivity
	構文に:syntactically
	値~全体:sole value
	現れて:appear
	2 回:twice
	`ident-token$t:ident

	●CSS
出自の:originating::~
全域:wide:~
math:
計算式:calculation:~

	継承されない:non-inherited
	下位prop:longhand
	名前空間を伴う:namespaced

	●処理
代用-:substitute::~
代用:substitution::~
剥いだ:stripした:~

	%要請:req
	%~URL:url
	~EACH:in sequence
	得られ:yield
	-:earliest
	-:looked up

	●仕様
短絡-:short-circuit:~
差分:diff:~
近過去:recent:~
整理:cleanup:~
違法:illegal:~
稀:rare:~
自明:trivial:~

	調べる:look at
	〜過ぎ:overly
	ほとんど，:mostly
	~level 4:`CSS-VALUES-4$r
	`CSS21$r :Level 2
	〜とする:called
	欄:line
	書き直す:rewrite
	~~考えて:think
	確かめる:make sure
	〜にも:partially

	●未分類
toggle:
所在指定子:locator::~
改変子:modifier::~
式:expression::~
normal:
	~normal体:normal#1
italic:
	~italic体:~italic:#2
図形:shape:~
	図形:shaped
巡回-:cycle:~
種類:kind:~
数量-:numeric:~

	階が深まるごとに:repeat
	-:present
	深さで:deep
	成す:constitute
	時点:time
	~~説明:illustrate
	そのまま:literal

	●random 関数
暗号:cryptography::~
暗号-:cryptographic::~
強度:strength:~
高品質な:quality:~
協調:coordination:~
存続期間:lifetime:~
相関:correlation:~
丸ng:rounding::丸め
疑似-:pseudo-:~
段差:step:~
thema::::テーマ
	~thema的:thematic
時間的:temporal:~
一様:uniform:~
分布-:distribute:~
正方形:square:~
別物:distinct:~
数-:number:~
	~randomな数-:random-number
任意的:arbitrary::~

	~group分け:grouping
	~random~cache用の:random-caching
	~cache法:caching
	一様に分布する:drawn from a uniform distribution
	ある範囲内:between a minimum and maximum value
	上限, 下限:limits
	~~確率:weight
	~~確率:chance
	~random性:randomness
	~~最大な値:the final step to land
	最~大:largest
	約:approximately
	最も近い:nearest
	2 倍の~~確率で:twice as often
	偶然:coincidentally
	一意~性:uniqueness
	整数倍:whole
	整数倍:multiple of
	最小~値との差が~step の整数倍になるよう:form min + (N * step), where N is …
	~randomに:uniformly randomly
	範囲の最小~値からの差が段差の整数倍になる:step between those limits
	何ら繋がりはなく:have no connection
	選び取る:pick

	●random 関数（仕様
素朴:naive:~
生来:natural:~
理論:theory:~
	理論~上は:in theory
各利用:usage:~
根本的:fundamental:~
不用意:accidental:~

	ある程度の:some degree
	視点:perspective
	してもらう:letting
	許容しない:disallow
	とは言え:tho
	大丈夫なはず:should be fine
	別として:aside from
	伝える:tell
	“代用” に類する:leaning
	控えて:upcoming
	見込みが高い:likely
	のか〜のか:versus
	か否か:differently
	するようになる:end up
	かどうかは〜のみに基づく:all that matters is
	〜はずと見込まれる:should be likely
	保つ:keep
	選ばれ:chosen
	きちんと:well-
	疑わしい:suspect
	外れる:falls out of
	アリでない:impossible
	およそ〜ない:it very unlikely
	必要とされない:necessarily
	足る:sufficient
	十分:enough
	“ゆらぎ”:less static and identical
	“華を添える”:just to add a bit of "flair"
	感じられ:feel
	気が散らないほどの:without being distracting
	少なくとも 〜は:definitely
	同じに:identically
	見かけ:look
	見かけ上は異なる:superficially look
	By default:この引数が省略された場合
	影響し得る:issues might have an effect
	情報:info

	●random 関数（未分類
新規:fresh:~
refresh:
	少し:slightly
	両端を成す:boundary
	書く:written
	一緒:together
	残りの:remaining
	複数の箇所で:multiple places 〜 each location
	何であれ:whatever
	どこか:somewhere
	他の〜は一致する:otherwise-identical
	箇所:place
	現れな／現れる:appear
	含め:including
	前後で／どうしで:across
	`var$f の様にふるまう:var()-like
	上の:preceding
	-:does nothing
	-:inclusive
	-:put
	`CSS-VARIABLES-2$r:Variables


●●original_id_map

●●mdn_urls
●●link_map

	●p
p.background-position:~CSSBG#propdef-background-position
p.height:~SIZING#propdef-height
p.width:~SIZING#propdef-width
p.list-style-type:~CSSLIST#propdef-list-style-type

	●t （構文
t.any-value:~CSSSYN#typedef-any-value
t.declaration-value:~CSSSYN#typedef-declaration-value
t.delim-token:~CSSSYN#typedef-delim-token
t.dimension-token:~CSSSYN#typedef-dimension-token
t.number-token:~CSSSYN#typedef-number-token
t.percentage-token:~CSSSYN#typedef-percentage-token
t.ident-token:~CSSSYN#typedef-ident-token
t.hash-token:~CSSSYN#typedef-hash-token

	●t
t.angle:~CSSVAL#angle-value
t.attr-type:#typedef-attr-type
t.calc-sum:~CSSVAL#typedef-calc-sum
t.color:~CSSCOLOR#typedef-color
t.crossorigin-modifier:#typedef-request-url-modifier-crossorigin-modifier
t.custom-ident:~CSSVAL#identifier-value
t.dashed-ident:~CSSVAL#typedef-dashed-ident
t.dimension-unit:#typedef-dimension-unit
t.dimension:~CSSVAL#typedef-dimension
t.flex:~CSSGRID#typedef-flex
t.frequency:~CSSVAL#frequency-value
t.hex-color:~CSSCOLOR#typedef-hex-color
t.integrity-modifier:#typedef-request-url-modifier-integrity-modifier
t.length:~CSSVAL#length-value
t.number:~CSSVAL#number-value
t.integer:~CSSVAL#integer-value
t.percentage:~CSSVAL#percentage-value
t.random-caching-options:#typedef-random-caching-options
t.referrerpolicy-modifier:#typedef-request-url-modifier-referrerpolicy-modifier
t.request-url-modifier:#typedef-request-url-modifier
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.toggle-value:#typedef-toggle-value
t.url-modifier:~CSSVAL#typedef-url-modifier
t.url:~CSSVAL#url-value

	●f
f.attr:#funcdef-attr
f.calc:~CSSVAL#funcdef-calc
f.random-item:#funcdef-random-item
f.random:#funcdef-random
f.round:~CSSVAL#funcdef-round
f.toggle:#funcdef-toggle
f.url:~CSSVAL#funcdef-url
f.var:~CSSVAR#funcdef-var

	●v

v.angle:#valdef-attr-angle
v.color:#valdef-attr-color
v.flex:#valdef-attr-flex
v.frequency:#valdef-attr-frequency
v.ident:#valdef-attr-ident
v.length:#valdef-attr-length
v.number:#valdef-attr-number
v.percentage:#valdef-attr-percentage
v.string:#valdef-attr-string
v.time:#valdef-attr-time
v.url:#valdef-attr-url

v.integrity:#funcdef-request-url-modifier-integrity
v.referrerpolicy:#funcdef-request-url-modifier-referrerpolicy
v.crossorigin:#funcdef-request-url-modifier-crossorigin

v.anonymous:#valdef-request-url-modifier-anonymous
v.no-referrer-when-downgrade:#valdef-request-url-modifier-no-referrer-when-downgrade
v.no-referrer:#valdef-request-url-modifier-no-referrer
v.origin-when-cross-origin:#valdef-request-url-modifier-origin-when-cross-origin
v.origin:#valdef-request-url-modifier-origin
v.same-origin:#valdef-request-url-modifier-same-origin
v.strict-origin-when-cross-origin:#valdef-request-url-modifier-strict-origin-when-cross-origin
v.strict-origin:#valdef-request-url-modifier-strict-origin
v.unsafe-url:#valdef-request-url-modifier-unsafe-url
v.use-credentials:#valdef-request-url-modifier-use-credentials

v.circle:~CSSCOUNTER#circle
	v.circle:~CSS22#value-def-circle
v.disc:~CSSCOUNTER#disc
	v.disc:~CSS22#value-def-disc
v.square:~CSSCOUNTER#square
	v.disc:~CSS22#value-def-square
v.green:~CSSCOLOR#valdef-color-green
v.inherit:~CASCADE#valdef-all-inherit
v.blue:~CSSCOLOR#valdef-color-blue
v.red:~CSSCOLOR#valdef-color-red


	●code 他
u.ms:~CSSVAL#ms
u.px:~CSSVAL#px

I.ReferrerPolicy:~REFERRER-POLICY#enumdef-referrerpolicy


	●用語
~URL値からの要請~改変子を適用する:#apply-request-modifiers-from-url-value
~random-caching~key:#random-caching-key
~random関数:#css-random-functions
代用する:#substitute-an-attr
代用-:#substitute-an-attr
代用~値:#attr-substitution-value
任意的~代用~関数:#_arbitrary-substitution-function
~random~cache用~key:#random-caching-key

	●用語（ level 4
~level 4:#biblio-css-values-4

~URLの要請~改変子~用の手続き:~CSSVAL#url-request-modifier-steps

~CSS全域~keyword:~CSSVAL#css-wide-keywords
~math関数:~CSSVAL#math-function
型を決定する:~CSSVAL#determine-the-type-of-a-calculation
計算式:~CSSVAL#calc-calculation
	＠~CSSVAL#simplify-a-calculation-tree
関数-記法:~CSSVAL#functional-notation
次元:~CSSVAL#dimension


	●用語（CSS
~custom~prop:~CSSVAR#custom-property
無効が保証される値:~CSSVAR#guaranteed-invalid-value
算出d値の時点で無効:~CSSVAR#invalid-at-computed-value-time

出自の要素:~SELECTORS4#originating-element
属性~選択子:~SELECTORS4#attribute-selector

略式~prop:~CASCADE#shorthand-property
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
継承d値:~CASCADE#inherited-value

成分~値を構文解析する:~CSSSYN#parse-a-component-value

有名~色:~CSSCOLOR#named-color

型:~CSSTOM1#cssnumericvalue-type
型を決定-:~CSSVAL#determine-the-type-of-a-calculation

	●用語（外部

~tuple:~INFRA#tuple
前後の~ASCII空白~列を剥いだ:~INFRA#strip-leading-and-trailing-ascii-whitespace

属性:~DOM4#concept-attribute
要素:~DOM4#concept-element
要請:~FETCH#concept-request
rq.~mode:~FETCH#concept-request-mode
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
rq.資格証~mode:~FETCH#concept-request-credentials-mode

●●images

●●html_code_list

■attr-types-1
<在庫>
  <木材 長さ="12"/>
  <木材 長さ="5"/>
  <金属 長さ="19"/>
  <木材 長さ="4"/>
</在庫>
％
在庫::before {
  display: block;
  content: "ある縮尺による，在庫の各素材の長さ：";
}
在庫 > * {
  display: block;
  width: attr(length em, 0px);
  height: 1em;
  border: solid thin;
  margin: 0.5em;
}
木材 {
  background: orange url(wood.png);
}
金属 {
  background: silver url(metal.png);
}

<stock>
  <wood length="12"/>
  <wood length="5"/>
  <metal length="19"/>
  <wood length="4"/>
</stock>

stock::before {
  display: block;
  content: "To scale, the lengths of materials in stock are:";
}
stock > * {
  display: block;
  width: attr(length em, 0px);
  height: 1em;
  border: solid thin;
  margin: 0.5em;
}
wood {
  background: orange url(wood.png);
}
metal {
  background: silver url(metal.png);
}


●●ref_normative

[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color/
[CSS-COLOR-5]
    Chris Lilley; et al. ＜CSS Color Module Level 5＞. URL: https://drafts.csswg.org/css-color-5/
[CSS-GRID-2]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. ＜CSS Grid Layout Module Level 2＞. URL: https://drafts.csswg.org/css-grid-2/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VARIABLES-2]
    CSS Custom Properties for Cascading Variables Module Level 2 URL: https://drafts.csswg.org/css-variables-2/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[REFERRER-POLICY]
    Jochen Eisinger; Emily Stark. ＜Referrer Policy＞. URL: https://w3c.github.io/webappsec-referrer-policy/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/

●●ref_informative

[CSS-BACKGROUNDS-3]
    Bert Bos; Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Values and Units Module Level 5</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-values-5/
公表履歴
	https://www.w3.org/standards/history/css-values-5
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-values-5">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Invited Expert)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-values-5/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-values-5

</script>
<body>

<header>
	<hgroup>
<h1>CSS の値と単位 — CSS Values and Units Module Level 5</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~CSS~moduleは、
~CSS~propに受容される共通な値と単位，および
~CSS~prop定義の中でそれらの値と単位を述べるために利用される構文について述べる。
◎
This CSS module describes the common values and units that CSS properties accept and the syntax used for describing them in CSS property definitions.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p class="issue">
<strong>
これは、
`~level 4$ からの差分~仕様である。
</strong>
◎
This is a diff spec against CSS Values and Units Level 4.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
`~level 4$ は、
`CSS21$r の
`§ 1.4.2.1＠~TR/CSS2/about.html#value-defs$,
`§ 4.3＠~TR/CSS2/syndata.html#values$,
`§ A.2＠~TR/CSS2/aural.html#aural-intro$
による各種~data型~定義を置換して，拡張する。
この~moduleは、
`~level 4$ を拡張する。
◎
This module extends [CSS-VALUES-4] which replaces and extends the data type definitions in [CSS21] sections 1.4.2.1, 4.3, and A.2.
</p>

		</section>
		<section id="urls">
<h3 title="Resource Locators: the &lt;url&gt; type">1.2. 資源の所在指定子： `url$t 型</h3>

<p>
`~level 4$ の `§ 資源の所在指定子＠~CSSVAL#urls$
を見よ。
◎
See CSS Values 4 § 4.5 Resource Locators: the &lt;url&gt; type.
</p>

			</section>
			<section id="request-url-modifiers">
<h4 title="Request URL Modifiers">1.2.1. 要請~URL改変子</h4>

<p>
`request-url-modifier@t
【 “要請~URL改変子” 】は、
`url-modifier$t を表現する
— それは、
自身に結付けられた`~URLの要請~改変子~用の手続き$を適用することにより，
`url$t への資源`要請$に影響する。
`~level 4$ の `§ ~URL処理~model＠~CSSVAL#url-processing$
を見よ。
◎
&lt;request-url-modifier&gt;s are &lt;url-modifier&gt;s that affect the &lt;url&gt;’s resource request by applying associated URL request modifier steps. See CSS Values 4 § 4.5.4 URL Processing Model.
</p>

<p>
この仕様は、
次に挙げる `request-url-modifier$t を定義する：
◎
This specification defines the following &lt;request-url-modifier&gt;s:
</p>

<pre class="prod">
`request-url-modifier$t
    = `crossorigin-modifier$t
	| `integrity-modifier$t
	| `referrerpolicy-modifier$t
</pre>

<dl>
	<dt>
<pre class="prod">
`crossorigin-modifier@t
	= `crossorigin@v(`anonymous@v | `use-credentials@v)
</pre>
</dt>
	<dd class="algo">
<p>
この改変子~用の`~URLの要請~改変子~用の手続き$は、
所与の
( `要請$ %要請 )
に対し：
◎
The URL request modifier steps for this modifier given request req are:
</p>
		<ol>
			<li>
`要請$の`~mode$rq ~SET `cors^l
◎
Set request's mode to "cors".
</li>
			<li>
~IF［
引数に与えられた値 ~EQ `use-credentials$v
］
⇒
`要請$の`資格証~mode$rq ~SET `include^l
◎
If the given value is use-credentials, set request's credentials mode to "include".
</li>
		</ol>
	</dd>

	<dt>
<pre class="prod">
`integrity-modifier@t
	= `integrity@v(`string$t)
</pre>
</dt>
	<dd>
	</dd>
	<dd class="algo">
この改変子~用の`~URLの要請~改変子~用の手続き$は、
所与の
( `要請$ %要請 )
に対し
⇒
%要請 の`完全性~metadata$rq ~SET 引数に与えられた `string$t
◎
The URL request modifier steps for this modifier given request req are to set request's integrity metadata to the given &lt;string&gt;.
</dd>

	<dt>
<pre class="prod">
`referrerpolicy-modifier@t
	= `referrerpolicy@v(
		`no-referrer@v
		| `no-referrer-when-downgrade@v
		| `same-origin@v
		| `origin@v
		| `strict-origin@v
		| `origin-when-cross-origin@v
		| `strict-origin-when-cross-origin@v
		| `unsafe-url@v )
</pre>
</dt>
	<dd class="algo">
この改変子~用の`~URLの要請~改変子~用の手続き$は、
所与の
( `要請$ %要請 )
に対し
⇒
%要請 の`~referrer施策$rq ~SET 引数に与えられた値に合致する `ReferrerPolicy$I 値
◎
The URL request modifier steps for this modifier given request req are to set request's referrer policy to the ReferrerPolicy that matches the given value.
</dd>
</dl>

<div class="algo">
<p>
`~URL値からの要請~改変子を適用する@
ときは、
所与の
( `要請$ %要請, `url$t %~URL )
に対し
⇒
%~URL 内に指定された
~EACH( `request-url-modifier$t %改変子 )
に対し
⇒
%改変子 用の`~URLの要請~改変子~用の手続き$( %要請 )
◎
To apply request modifiers from URL value given a request req and a &lt;url&gt; url, call the request modifier steps for url’s &lt;request-url-modifier&gt;s in sequence given req.
</p>
</div>

		</section>
		<section id="toggle-notation">
<h3 title="Toggling Between Values: toggle()">1.3. 一連の値の~toggle法： `toggle^f</h3>

<p>
`toggle@f
式は、
子孫~要素たちが
— 同じ値を継承する代わりに —
~listを成す各~値を巡回することを許容する。
◎
The toggle() expression allows descendant elements to cycle over a list of values instead of inheriting the same value.
</p>

<div class="example">
<p>
次の例は、
`em^e 要素を一般には~italic体にしつつ，~italic体の内側では~normal体に戻す：
◎
The following example makes &lt;em&gt; elements italic in general, but makes them normal if they’re inside something that’s italic:
</p>
<pre class="lang-css">
em { font-style: toggle(italic; normal); }
</pre>
</div>

<div class="example">
<p>
次の例は、
入子な~list用に，~markerたちを巡回する。
~marker図形は、
~top-levelの~listにおいては `disc$v になり，
その中に入子にされた~listにおいては
— 階が深まるごとに —
順に［
`circle$v, `square$v, `box^v
］になり，
（ 5 階の深さで）再び `disc$v から開始するようになる。
◎
The following example cycles markers for nested lists, so that a top level list has disc-shaped markers, but nested lists use circle, then square, then box, and then repeat through the list of marker shapes, starting again (for the 5th list deep) with disc.
</p>

<pre class="lang-css">
ul { list-style-type: toggle(disc; circle; square; box); }
</pre>
</div>

<p>
`toggle$f 式の構文は：
◎
The syntax of the toggle() expression is:
</p>

<pre class="prod">
toggle( `toggle-value$t [ ';' `toggle-value$t ]+ )
</pre>

<p>
`toggle-value@t
がとる~CSS値は、［
当の式が配置された所で妥当になる
］ならば何でもよい。
`toggle$f 式の内側に妥当でない値がある場合、
式~全体が無効になる。
`toggle$f 式は、
どの~propの値に利用してもヨイが，
当の~propの値を成す唯一の成分でなければナラナイ。
◎
where &lt;toggle-value&gt; is any CSS value that is valid where the expression is placed. If any of the values inside are not valid, then the entire toggle() expression is invalid. The toggle() expression may be used as the value of any property, but must be the only component in that property’s value.
</p>

<p class="note">注記：
この`関数-記法$が，引数どうしを
— 典型的な~commaではなく —
~semicolonを利用して分離するのは、
各~値~自体が~commaを包含し得るからである。
◎
Note: This functional notation uses semicolons to separate arguments rather than the more typical comma because the values themselves can contain commas.
</p>

<p>
`toggle$f 記法は入子にできない。
また［
`attr$f ／ `calc$f
］記法も包含できない。
そのような構成子を包含している宣言は無効になる。
◎
The toggle() notation is not allowed to be nested; nor may it contain attr() or calc() notations. Declarations containing such constructs are invalid.
</p>

<div class="example">
<p>
次に挙げる `toggle$f 式は、
どれも無効になる：
◎
The following toggle() examples are all invalid:
</p>

<pre class="lang-css">
background-position: 10px toggle(50px, 100px);
/* <span class="comment">
`toggle$f は~propの値~全体を成していなければナラナイ。
◎
toggle() must be the sole value of the property
</span> */

list-style-type: toggle(disc, 50px);
/* <span class="comment">
`50px^v は `list-style-type$p 用の妥当な値でない。
◎
50px isn’t a valid value of 'list-style-type'
</span> */
</pre>
</div>

<div class="algo">
<p>
`toggle$f 式 %式 の`算出d値$は、
次に従って決定される：
</p>
<ol>
	<li>
%最初の値 ~LET ε
</li>
	<li>
%初回の反復か ~SET ~F
</li>
	<li>
%前回の反復で合致したか ~SET ~F
</li>
	<li>
<p>
%式 の
~EACH( 引数 %引数 )
に対し，順に：
</p>
		<ol>
			<li>
%値 ~LET ［
%引数 が %式 を利用している~propの値~全体を成していた
］とするとき，~propの`算出d値$を評価した結果
</li>
			<li>
~IF［
%前回の反復で合致したか ~EQ ~T
］
⇒
~RET %値
</li>
			<li>
~IF［
%初回の反復か ~EQ ~T
］
⇒＃
%初回の反復か ~SET ~F；
%最初の値 ~SET %値
</li>
			<li>
~IF［
%値 ~EQ %式 を利用している~propの`継承d値$
］
⇒
%前回の反復で合致したか ~SET ~T
</li>
		</ol>
	</li>
	<li>
~RET %最初の値
</li>
</ol>
◎
To determine the computed value of toggle(), first evaluate each argument as if it were the sole value of the property in which toggle() is placed to determine the computed value that each represents, called Cn for the n-th argument to toggle(). Then, compare the property’s inherited value with each Cn. For the earliest Cn that matches the inherited value, the computed value of toggle() is Cn+1. If the match was the last argument in the list, or there was no match, the computed value of toggle() is the computed value that the first argument represents.
</div>

<p class="note">注記：
したがって， `toggle$f 内で同じ値が繰返された場合、
~listは短絡されることになる。
例えば， `toggle(1em; 2em; 1em; 4em)^v は、
`toggle(1em; 2em)^v と等価になる。
◎
Note: This means that repeating values in a toggle() short-circuits the list. For example toggle(1em; 2em; 1em; 4em) will be equivalent to toggle(1em; 2em).
</p>

<p class="note">注記：
`toggle$f は，明示的に親の算出d値を調べるので、
継承されない~propであっても働く。
このことは、
継承されない~propに対しても働く `inherit$v ~keywordと類似する。
◎
Note: That toggle() explicitly looks at the computed value of the parent, so it works even on non-inherited properties. This is similar to the inherit keyword, which works even on non-inherited properties.
</p>

<p class="note">注記：
~propの`算出d値$は、
抽象的な［
値たちが成す集合
］であり，特定0の直列化ではない `CSS21$r ので、
算出d値どうしの比較は常に一義的になり，
期待される結果になるべきである。
例えば， `CSS21$r における `background-position$p の算出d値は、
各自が［
絶対~長さ／百分率
］として表現される 2 個の~offsetだけからなるので、［
宣言 <span class="css">`background-position^p: `top center^v</span>
］と［
宣言 <span class="css">`background-position^p: `50% 0%^v</span>
］が生産する算出d値は，一致する。
~prop定義の “算出d値” の欄が何かを［
多義的／厳密~過ぎ
］に定義すると見受けられる場合は、
修正できるよう`~feedback＠#sotd$を供されたし。
◎
Note: That the computed value of a property is an abstract set of values, not a particular serialization [CSS21], so comparison between computed values should always be unambiguous and have the expected result. For example, a Level 2 background-position computed value is just two offsets, each represented as an absolute length or a percentage, so the declarations background-position: top center and background-position: 50% 0% produce identical computed values. If the "Computed Value" line of a property definition seems to define something ambiguous or overly strict, please provide feedback so we can fix it.
</p>

<p>
`toggle$f が`略式~prop$に利用された場合、
その各~下位propの値も `toggle$f 値になるが、
その各~引数は，元の `toggle$f 式の各~引数に対し［
それが当の略式~propの値~全体を成していたとするとき，下位propが受取ることになる値
］に設定される。
◎
If toggle() is used on a shorthand property, it sets each of its longhands to a toggle() value with arguments corresponding to what the longhand would have received had each of the original toggle() arguments been the sole value of the shorthand.
</p>

<div class="example">
<p>
次の略式~prop宣言は：
◎
For example, the following shorthand declaration:
</p>

<pre class="lang-css">
margin: toggle(1px 2px, 4px, 1px 5px 4px);
</pre>

<p>
次の下位prop宣言と等価になる：
◎
is equivalent to the following longhand declarations:
</p>

<pre class="lang-css">
margin-top:    toggle(1px; 4px; 1px);
margin-right:  toggle(2px; 4px; 5px);
margin-bottom: toggle(1px; 4px; 4px);
margin-left:   toggle(2px; 4px; 5px);
</pre>

<p>
［
上端~margin／下端~margin
］は、［
`1px^v ／ `4px^v
］が 2 回~現れているので，
2 個の値のみを巡回する。
一方で，［
左端~margin／右端~margin
］は、 3 個の値を巡回することになる。
言い換えれば、
上の宣言から得られる算出d値は，次の下位prop宣言と同じになる：
◎
Note that, since 1px appears twice in the top margin and 4px appears twice in bottom margin, they will cycle between only two values while the left and right margins cycle through three. In other words, the declarations above will yield the same computed values as the longhand declarations below:
</p>

<pre class="lang-css">
margin-top:    toggle(1px; 4px);
margin-right:  toggle(2px; 4px; 5px);
margin-bottom: toggle(1px; 4px);
margin-left:   toggle(2px; 4px; 5px);
</pre>

<p>
その結果は、
意図されるものではなかろう。
◎
which may not be what was intended.
</p>
</div>

		</section>
	</section>
	<section id="attr-notation">
<h2 title="Attribute References: the attr() function">2. 属性~参照： `attr^f 関数</h2>

<p>
`attr@f
関数は、［
それを利用している~propが適用される`要素$の ある`属性$
］を参照し，その`属性$の値で`代用-$される
（ `var$f 関数が`~custom~prop$の値で代用されるのと類似に）。
◎
The attr() function substitutes the value of an attribute on an element into a property, similar to how the var() function substitutes a custom property value into a function.
</p>

<pre class="prod">
attr() = attr(`q-name^t `attr-type$t? , `declaration-value$t?)

`attr-type@t
	= `string$v
	| `url$v
	| `ident$v
	| `color$v
	| `number$v
	| `percentage$v
	| `length$v
	| `angle$v
	| `time$v
	| `frequency$v
	| `flex$v
	| `dimension-unit$t
</pre>

<p>
`dimension-unit@t
生成規則は、
次に挙げるものに合致する：
◎
The &lt;dimension-unit&gt; production matches＼
</p>
<ul>
	<li>
~literal `%^l
（すなわち， .値 `%^l を伴う `delim-token$t ）
◎
a literal "%" character (that is, a &lt;delim-token&gt; with a value of "%")＼
</li>
	<li>
`ident-token$t のうち，その .値 は［
`length$t ／ `angle$t ／ `time$t ／ `frequency$t ／ `flex$t
］値~用の~CSS単位（ `px$u や `ms$u など ）であるもの。
◎
or an ident whose value is any of the CSS units for &lt;length&gt;, &lt;angle&gt;, &lt;time&gt;, &lt;frequency&gt;, or &lt;flex&gt; values (such as px or ms).
</li>
</ul>

<p>
`attr$f の各~引数は：
◎
The arguments of attr() are:
</p>
<dl>
	<dt>`q-name^t</dt>
	<dd class="trans-note">【
この生成規則の構文は、
この仕様には述べられていない。
`Selectors^cite に定義される `wq-name＠~SELECTORS4#typedef-wq-name$t ／
`~XML名前空間^cite に定義される `QName＠~XNLNS10#NT-QName$P ／
`CSS Namespaces^cite に定義される ［
`qname＠~CSSNS#qname$t
`wqname＠~CSSNS#wqname$t
`wqwname＠~CSSNS#wqwname$t
］なども考えられるが。
】</dd>
	<dd>
参照している属性の名前を与える。
◎
Gives the name of the attribute being referenced.
</dd>
	<dd>
名前空間が指定されなかった場合
（ `attr(foo)^v の様に，識別子だけが与えられた場合）
~NULL名前空間が含意される。
（名前空間を伴う属性は稀なので、
通例的には，これが欲されるものになる。
特に、［
~HTML／~SVG
］には，名前空間を伴う属性は無い。）
◎
If no namespace is specified (just an identifier is given, like attr(foo)), the null namespace is implied. (This is usually what’s desired, as namespaced attributes are rare. In particular, HTML and SVG do not contain namespaced attributes.)＼
</dd>
	<dd>
`属性~選択子$と同じく、
`q-name^t が文字大小区別かどうかは，文書~言語に依存する。
◎
As with attribute selectors, the case-sensitivity of &lt;q-name&gt; depends on the document language.
</dd>
	<dd>
ある［
要素／疑似要素
］に適用される~propにて利用された `attr$f は、［
当の要素／当の疑似要素の`出自の要素$
］の所与の名前を伴う属性を参照する。
◎
If attr() is used in a property applied to an element, it references the attribute of the given name on that element; if applied to a pseudo-element, the attribute is looked up on the pseudo-element’s originating element.
</dd>

	<dt>`attr-type$t</dt>
	<dd>
参照された属性の値が，どの種類の~CSS値として解釈されるかを
— および、
もしあれば，値に対し行われる特別な構文解析も —
指定する。
解釈した結果が当の `attr$f の
`代用~値@
を与える。
◎
Specifies what kind of CSS value the attribute’s value will be interpreted into (the attr()’s substitution value) and what, if any, special parsing will be done to the value.
</dd>
	<dd>
アリな値，それらの挙動は、
<a href="#attr-types">§ `attr^f 型</a>
にて定義される。
◎
The possible values and their behavior are defined in § 2.1 attr() Types.
</dd>
	<dd>
省略された場合、
`string$v が既定になる。
◎
Defaults to string if omitted.
</dd>

	<dt>`declaration-value$t</dt>
	<dd>
~fallback値を指定する
— それは、
参照された属性［
が欠落な場合／
の値を指定された型として構文解析するのに失敗した場合
］、
当の`attr$f は，この~fallback値で`代用-$されることになる。
◎
Specifies a fallback value for the attr(), which will be substituted instead of the attribute’s value if the attribute is missing or fails to parse as the specified type.
</dd>
	<dd>
省略された場合の既定の~fallback値は、
`attr-type$t 引数に応じて
⇒＃
`string$v ならば空~文字列になる／
~ELSE_ `無効が保証される値$になる
◎
If the &lt;attr-type&gt; argument is string, defaults to the empty string if omitted; otherwise, defaults to the guaranteed-invalid value if omitted.
</dd>
</dl>

<p>
~propが包含している各 `attr$f 関数が，どれも構文上は妥当な場合、
~prop全体の文法は，構文解析-時点では妥当であると見做すモノトスル。
構文は、
`attr^f 関数が`代用-$された後の算出d値の時点に限り，検査される。
◎
If a property contains one or more attr() functions, and those functions are syntactically valid, the entire property’s grammar must be assumed to be valid at parse time. It is only syntax-checked at computed-value time, after attr() functions have been substituted.
</p>

<div class="note">
<p>注記：
~fallback値【！既定の値】の型は、
`attr-type$t 【！所与の型】と一致する必要は無いことに注意。
一例として、
作者により要求された属性の型が `px$u の場合でも，
~fallback値は `auto^v をとり得る
— <code class="css">`width$p: `attr(size px, auto)^v;</code>
の様に。
◎
Note that the default value need not be of the type given. For instance, if the type required of the attribute by the author is px, the default could still be auto, like in width: attr(size px, auto);.
</p>
</div>

		<section id="attr-types">
<h3 title="attr() Types">2.1. `attr$f 型</h3>

<div class="p">
<p>
`attr$f 関数の挙動は、
`attr-type$t 引数の値にも依存する
— 以下においては：
</p>
<ul>
	<li>
%属性~値 は、
関数が参照している属性の値をそのまま表すとする。
（属性が欠落な場合、
上で述べたとおり~fallback値が利用されることになる）。
</li>
	<li>
%成分~値 は、
次の結果を表すとする
⇒
`成分~値を構文解析する$( %属性~値 )
（結果が構文-~errorならば、~fallback値が利用されることになる）
</li>
</ul>
◎
The behavior of the attr() function depends partially on the value of the &lt;attr-type&gt; argument:
</div>

<dl>
	<dt>`string@v</dt>
	<dd>
`代用~値$は、
~CSS文字列としての %属性~値 になる。
（ %属性~値 に対し遂行される~CSS構文解析や “整理” は無い。）
◎
The substitution value is a CSS string, whose value is the literal value of the attribute. (No CSS parsing or "cleanup" of the value is performed.)
</dd>
	<dd>
~fallbackを誘発する値は無い。
◎
No value triggers fallback.
</dd>

	<dt>`url@v</dt>
	<dd>
`代用~値$は、
`url$t 値であって，その~URLに %属性~値 を伴うものになる。
（ %属性~値 に対し遂行される~CSS構文解析や “整理” は無い。）
◎
The substitution value is a CSS &lt;url&gt; value, whose url is the literal value of the attribute. (No CSS parsing or "cleanup" of the value is performed.)
</dd>
	<dd class="note">注記：
`url$f の構文に関数を包含する能力があったとするなら、
`attr(foo url)^v は，
`url(attr(foo string))^v と一致する。
◎
Note: If url() was syntactically capable of containing functions, attr(foo url) would be identical to url(attr(foo string)).
</dd>
	<dd>
~fallbackを誘発する値は無い。
◎
No value triggers fallback.
</dd>

	<dt>`ident@v</dt>
	<dd>
<p>
`代用~値$は、
%属性~値 から`前後の~ASCII空白~列を剥いだ$結果 %結果 に応じて：
</p>
		<ul class="switch">
			<li>
［
空~文字列 ／ `~CSS全域~keyword$ ／ `default^v
］の場合は無い。
【おそらく，~ASCII文字無視。】
</li>
			<li>
他の場合、
`custom-ident$t としての %結果 になる。
（ %結果 に対し遂行される~CSS構文解析は無い）。
</li>
		</ul>
◎
The substitution value is a CSS &lt;custom-ident&gt;, whose value is the literal value of the attribute, with leading and trailing ASCII whitespace stripped. (No CSS parsing of the value is performed.)
◎
If the attribute value, after trimming, is the empty string, there is instead no substitution value.
◎
If the &lt;custom-ident&gt;’s value is a CSS-wide keyword or default, there is instead no substitution value.
</dd>

	<dt>`color@v</dt>
	<dd>
`代用~値$は、
%成分~値 が［
`hex-color$t である／
`ident-token$t であって，その.値は`有名~色$である
］ならば，
%成分~値 が表現する `color$t になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;hex-color&gt; or a named color ident, the substitution value is that result as a &lt;color&gt;.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise there is no substitution value.
</dd>

	<dt>`number@v</dt>
	<dd>
`代用~値$は、
%成分~値 は `number-token$t であるならば，
%成分~値 【が表現する `number$t 値（または `integer$t 値）】になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;number-token&gt;, the result is the substitution value.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>

	<dt>`percentage@v</dt>
	<dd>
`代用~値$は、
%成分~値 は `percentage-token$t であるならば，
%成分~値 【が表現する `percentage$t 値】になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;percentage-token&gt;, the result is the substitution value.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>

	<dt>`length@v</dt>
	<dt>`angle@v</dt>
	<dt>`time@v</dt>
	<dt>`frequency@v</dt>
	<dt>`flex@v</dt>
	<dd>
`代用~値$は、［
%成分~値 は `dimension-token$t であって，その .単位 は所与の型に合致する
］ならば，
%成分~値 【が表現する`次元$】になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;dimension-token&gt; whose unit matches the given type, the result is the substitution value.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>

	<dt id="valdef-attr-dimension-unit">`dimension-unit$t</dt>
	<dd>
`代用~値$は、
%成分~値 は `number-token$t であるならば，［
%成分~値 の .値, 所与の単位
］を伴う`次元$になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;number-token&gt;, the substitution value is a dimension with the result’s value, and the given unit.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>
</dl>

<p class="issue">
`attr^f の`代用~値$として，［
すべての数量-型~用には`~math関数$／
“色” 用には色~関数
］を許容するよう求まれるか？
編集者は そう~~考えているが、
代用~値が更に参照~関数を包含していないことを確かめるため，内容を検査する必要もある
— <code>`foo^a="`rgb(var(--red), 0, 0)^v"</code> は、
`attr(foo color)^v 用には違法になる必要がある。
◎
Do we want to allow math functions as attr values for all the numeric types? And color functions for "color"? I think we do, but I’d have to check the contents to make sure they don’t contain further reference functions; foo="rgb(var(--red), 0, 0)" needs to be illegal for attr(foo color).
</p>

<div class="example">
<p>
`attr$f を利用して，
~XML~file内の~dataを視覚的に~~説明する例：
◎
This example shows the use of attr() to visually illustrate data in an XML file:
</p>

`attr-types-1^xCode
</div>



		</section>
		<section id="attr-substitution">
<h3 title="attr() Substitution">2.2. `attr$f の代用</h3>

<p class="issue">
`attr$f と `var$f は，同時に代用されるので、
“`var$f を`代用する＠~CSSVAR#substitute-a-var$” は，おそらく［
これらの関数どちらにも利用される，より一般な “参照を代用する”
］に書き直すべきである。
◎
attr() and var() substitute at the same time, so I should probably rewrite substitute a var() to be more generally about "substitute a reference" and just use that for both of these functions.
</p>

<p>
`attr$f 関数は、
算出d値の時点で`代用-$される。
所与の宣言が，
すべての `attr^f 関数が代用された後において文法に合致しない場合、
当の宣言は，`算出d値の時点で無効$になる。
◎
attr() functions are substituted at computed-value time. If a declaration, once all attr() functions are substituted in, does not match its declared grammar, the declaration is invalid at computed-value time.
</p>

<div class="algo">
<p>
`attr$f 関数 %関数 を
`代用する@
ときは：
◎
To substitute an attr():
</p>
<ol>
	<li>
~IF［
%関数 に`代用~値$は在る
］
⇒
%関数 を`代用~値$で置換する
◎
If the attr() function has a substitution value, replace the attr() function by the substitution value.
</li>
	<li>
<p>
~ELIF［
%関数 の最後の引数として~fallback値 %~fallback は在る
］：
</p>
		<ol>
			<li>
%~fallback 内の
~EACH( ［
`var$f ／ `attr$f
］ 参照 %参照 )
に対し
⇒
%~fallback 内の %参照 を［
`代用する＠~CSSVAR#substitute-a-var$／`代用する$
］
</li>
			<li>
%関数 を %~fallback で置換する
</li>
		</ol>
◎
Otherwise, if the attr() function has a fallback value as its last argument, replace the attr() function by the fallback value. If there are any var() or attr() references in the fallback, substitute them as well.
</li>
	<li>
~ELSE
⇒
%関数 を利用している~propは、
`算出d値の時点で無効$になる
◎
Otherwise, the property containing the attr() function is invalid at computed-value time.
</li>
</ol>
</div>

		</section>
	</section>
	<section id="randomness">
<h2 title="Generating Random Values">3. ~randomな値の生成-法</h2>

<p>
設計に ある程度の “~random性” を組入れると有用になることが多い
— 同じ~page内で繰返される要素に多少の “ゆらぎ” が感じられるようにしたり，
~pageに気が散らないほどの “華を添える” ために。
◎
It is often useful to incorporate some degree of "randomness" to a design, either to make repeated elements on a page feel less static and identical, or just to add a bit of "flair" to a page without being distracting.
</p>

<p>
`~random関数@
と総称される［
`random$f, `random-item$f
］関数は、
作者が［
自身の~pageの中へ~random性を組入れる
］ことを許容する
— それは、［
この~random性を設計~視点からは予測-可能に保つ
］一方で，
~randomな値を［
複数箇所で再利用するべきか，~instanceごとに一意になるべきか
］は作者に裁定してもらう。
◎
The random() and random-item() functions (the random functions) allow authors to incorporate randomness into their page, while keeping this randomness predictable from a design perspective, letting authors decide whether a random value should be reused in several places or be unique between instances.
</p>

<p>
~randomな数-を生成する正確な手法は、
~UAにより定義される。
2 つの別個な~random値の相関は，容易に検出-可能になる`べきではない^emが、
この仕様は，［
それが暗号-強度の用語で何を意味するか
］は意図的に指定しない。
作者は、
高品質な暗号に依存する目的においては，
`~random関数$に依拠しては`ナラナイ^em。
◎
The exact random-number generation method is UA-defined. It should be the case that two distinct random values have no easily-detectable correlation, but this specification intentionally does not specify what that means in terms of cryptographic strength. Authors must not rely on random functions for any purposes that depend on quality cryptography.
</p>

		<section id="random">
<h3 title="Generating a Random Numeric Value: the random() function">3.1. ~randomな数量-値の生成-法： `random^f 関数</h3>

<p>
`random@f
関数は、
`~math関数$であり，
ある範囲内で一様に分布する~randomな値を表現する。
【以下、この節に現れる~randomは，一様（すべての値は、同じ~~確率で選ばれる）と見做される。】
それはまた、
任意選択で，アリな値を［
最小~値からの差が，ある段差の整数倍になる
］よう制限できる。
その構文は：
◎
The random() function is a math function that represents a random value between a minimum and maximum value, drawn from a uniform distribution, optionally limiting the possible values to a step between those limits:
</p>

<pre class="prod">
`random()^t
	= random(
		`random-caching-options$t? ,
		`calc-sum$t,
		`calc-sum$t,
		[by `calc-sum$t]? );

`random-caching-options@t
	= `dashed-ident$t || per-element
</pre>

<p>
その引数たちは：
◎
Its arguments are:
</p>

<dl class="valdef">
	<dt>`random-caching-options$t</dt>
	<dd>
省略可能な この引数は、
当の `random$f 関数が［
~page上の他の `random^f 関数と類似に解決されるか否か
］に対する，いくぶんの制御を供する。
詳細は、
`§ ~randomな値の生成-法／~cache法＠#random-caching$
を見よ。
◎
The optional &lt;random-caching-options&gt; provides some control over whether a given random() function resolves similarly or differently to other random()s on the page. See § 3.3 Generating/Caching Random Values: the &lt;random-caching-options&gt; value for details.
</dd>
	<dd class="note">
<p>
注記：
`random$f 関数は：
◎
↓</p>
		<ul>
			<li>
この引数が省略された場合、［
それを含んだ~styleを利用している要素~すべて
］から共有される単独の値に解決される。
2 つの `random^f 関数は、
互いの引数たちがすべて一致するならば，同じ~randomな値に解決されることになる。
◎
By default, random() resolves to a single value, shared by all elements using that style, and two random() functions with identical arguments will resolve to the same random value.
</li>
			<li>
この引数に `dashed-ident$t が供された場合、［
他の引数は一致する他の `random$f 関数
］とは別物にして，別個な値を生成させる。
◎
Providing a &lt;dashed-ident&gt; does nothing, but can make the argument lists distinct between two or more otherwise-identical random() functions, so they’ll generate distinct values.
</li>
			<li>
この引数に `per-element^v ~keywordが供された場合、
当の関数が適用される`要素ごと^emに異なる値を生成させる
— ~stylesheet内での各利用ごとに単独の値に解決されるのではなく。
◎
The per-element keyword causes the random() function to generate a different value on each element the function is applied to, rather than resolving to a single value per usage in the stylesheet.
</li>
		</ul>
	</dd>

	<dt>`calc-sum$t, `calc-sum^t</dt>
	<dd>
これら 2 個の要求される`計算式$は、
順に，当の関数を解決した結果がとり得る範囲の［
最小~値, 最大~値
］を指定する。
◎
The two required calculations specify the minimum and maximum value the function can resolve to. Both limits are inclusive (the result can be the min or the max).
</dd>
	<dd>
［
最大~値 ~LTE 最小~値
］の場合、
最大~値は最小~値と等しいものとして挙動する。
◎
If the maximum value is less than the minimum value, it behaves as if it’s equal to the minimum value.
</dd>
	<dd class="example">
例えば， `random(100px, 300px)^v は、
`100px^v 以上 `300px^v 以下の~randomな `length$t に解決されることになる。
◎
For example, random(100px, 300px) will resolve to a random &lt;length&gt; between 100px and 300px: it might be 100px, 300px, or any value between them like 234.5px.
</dd>

	<dt>`by^v `calc-sum$t</dt>
	<dd>
省略可能な最後の引数は、
段差~値を指定する。
当の関数を解決した結果は、
最小~値からの差が段差の整数倍になるよう制約され，
そこから~randomに選ばれる。
◎
The final optional argument specifies a step value: the values the function can resolve to are further restricted to the form min + (N * step), where N is a non-negative integer chosen uniformly randomly from the possible values that result in an in-range value.
</dd>
	<dd class="example">
<p>
例えば、
`random(100px, 300px, by 50px)^v
を解決した結果は，［
`100px^v,
`150px^v,
`200px^v,
`250px^v,
`300px^v
］いずれかに限られ、
`120px^v 様な値を返すことは決してない。
◎
For example, random(100px, 300px, by 50px) can only resolve to 100px, 150px, 200px, 250px, or 300px; it will never return a value like 120px.
</p>

<p>
結果が最小~値になることは，常にアリな一方、
最大~値になることは
— 最小~値との差が段差の整数倍である場合を除き —
アリでない。
例えば，［
`random(100px, 300px, by 30px)^v を解決した結果
］としてアリな最~大な値は、
`280px^v （ ~EQ 最小~値 ~PLUS 段差 ~MUL 6 ）になる。
◎
While the minimum value is always a possible result, the maximum value isn’t always, if it’s not also a multiple of the step from the minimum. For example, in random(100px, 300px, by 30px), the largest possible value it can resolve to is 280px, 6 steps from the minimum value.
</p>

<p>
これには、
丸ngが影響し得ることに注意：
`random(100px, 200px, by 100px / 3)^v
にアリな値は， 3 通り
— `100px^v, 約 `133.33px^v, 約 `166.67px^v —
以上はあるが、
`200px^v がアリになるかどうかは，丸ngの精度に依存する。
安全になるためには、
最大~値を期待される最~大な値より`少し大きく^emすればよい
— `random(100px, 201px, by 100px / 3)^v の様に。
◎
Note that rounding issues might have an effect here: in random(100px, 200px, by 100px / 3) you’ll definitely get three possible values (100px, and approximately 133.33px and 166.67px), but whether 200px is possible depends on rounding precision. To be safe, you can put the maximum value slightly above where you expect the final step to land, like random(100px, 201px, by 100px / 3).
</p>
	</dd>
	<dd class="example">
<p>
`round$f の定義にて説明したとおり，~CSSの値には “生来な” 精度は無いが、
段差~値を利用すれば，精度をアテガえる
— 例えば：
</p>
		<ul>
			<li>
`random(100px, 500px, by 1px)^v は、
解決した結果を `1px^v の整数倍に限るよう制約する。
</li>
			<li>
`random(1, 10, by 1)^v は、
解決した結果を整数に限るよう制約する。
</li>
		</ul>

◎
As explained in the definition of round(), CSS has no "natural" precision for values, but the step value can be used to assign one.
◎
For example, random(100px, 500px, by 1px) restricts it to resolving only to whole px values; random(1, 10, by 1) is restricted to resolving only to integers; etc.
</dd>
	<dd class="note">注記：
段差の定義は、
素朴に［
範囲~内の~randomな値を生成した結果を最も近い段差~値に丸める
］ことを許容するもの`ではない^em
— そうすると、
結果の各~値は，同じ~~確率で現れなくなるので。
例えば，
`random(100px, 200px, by 50px)^v は、
アリな 3 通りの値を同じ 1/3 の~~確率で生成する必要がある
— 素朴な丸ngに基づく手法は、
`150px^v を［
両端を成す他の値
］の 2 倍の~~確率で生成するので，不正である。
◎
Note: The definition of the step does not allow for naively generating a random value in the range and then rounding it to the nearest step value, as that can result in the values not appearing with the same weights. For example, random(100px, 200px, by 50px) has to generate the three possible values each with a 1/3 chance; a naive rounding-based method will instead incorrectly generate 150px twice as often as the boundary values.
</dd>
</dl>

<p>
引数として与える`計算式$は，どれも［
`number$t ／ `dimension$t ／ `percentage$t
］いずれにも解決され得るが、
各~引数の`型を決定-$した結果は，`互いに同じ^emにならなければナラナイ
— さもなければ、
当の関数は無効になる。
結果の`型$は，引数の型と同じになる。
◎
All of the calculation arguments can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have the same type, or else the function is invalid; the result will have the same type as the arguments.
</p>

<div class="example">
<p>
例えば：
◎
For example,＼
</p>
<ul>
	<li>
`random(50px, 100%, by 1em)^v は、
百分率は［
これを利用した文脈において妥当である
］かつ［
`length$t に解決される
］と見做すならば，妥当になる
— どの引数も，長さに解決されるので。
◎
random(50px, 100%, by 1em) is valid (assuming percentages are valid in the context this is used, and resolve to a &lt;length&gt;), as all three arguments resolve to a length.
</li>
	<li>
`random(50px, 180deg)^v は、
長さと角度が同じ`型$ではないので，妥当でない。
◎
However, random(50px, 180deg) is invalid, as lengths and angles are not the same type.
</li>
</ul>
</div>

<div>
<p>
`random$f 関数を`単純~化＠~CSSVAL#simplify-a-calculation-tree$できる時点は：
</p>
<ul>
	<li>
`random-caching-options$t にて `per-element^v が指定された場合
⇒
引数たちを成す各`計算式$を数量-値に単純~化できるようになった時点になる。
</li>
	<li>
他の場合
⇒
`使用~値$の時点になる。
</li>
</ul>
◎
If per-element is not present in the &lt;random-caching-options&gt;, a random() function can be simplified as soon as its argument calculations can be simplified to numeric values.＼
If per-element is specified in the &lt;random-caching-options&gt;, the function cannot be simplified until used value time.
</div>

<p class="issue">
少なくとも理論~上は、
`per-element^v が指定されない限り，
`random$f を~prop以外の文脈で利用しても大丈夫なはずである。
例えば、
<code class="css">`media^at (max-width: random(100px, 500px)) {...}</code>
で何が起こるかは，きちんと定義される。
とは言え、
それを許容するよう求まれるかどうかは疑わしい。
◎
At least in theory it should be fine to use random() in non-property contexts, so long as per-element isn’t specified; it’s well-defined what happens with @media (max-width: random(100px, 500px)) {...}, for example. I suspect we want to disallow it, tho?
</p>

			</section>
			<section id="random-infinities">
<h4 title="Argument Ranges">3.1.1. 引数の範囲</h4>

<p>
`random(A, B, by C)^f においては：
◎
In random(A, B, by C),＼
</p>
<ul>
	<li>
%A, %B いずれかが無限である場合，
結果は ~NaN になる。
◎
if A or B is infinite, the result is NaN.＼
</li>
	<li>
<p>
%C が無限である場合，
結果は %A になる。
◎
If C is infinite, the result is A.
</p>

<p>
（ %C ~LTE 0 の場合、
標準な定義から外れるが，結果は %A になる。）
◎
(If C is zero or negative, the result is A, but that falls out of the standard definition.)
</p>
	</li>
</ul>

<p class="note">注記：
通例の`~math関数$と同じく、
いずれかの計算式~引数が ~NaN になる場合，
結果は~NaNになる。
◎
Note: As usual for math functions, if any argument calculation is NaN, the result is NaN.
</p>

		</section>
		<section id="random-item">
<h3 title="Picking A Random Item From A List: the random-item() function">3.2.  ~listから~randomな~itemを選び取る： `random-item$f 関数</h3>

<p>
`random-item@f
関数は、
2 個目以降の引数たちが成す~listから~randomに選ばれる~itemに解決される。
◎
The random-item() function resolves to a random item from among its list of items.
</p>

<pre class="prod">
`random-item()^t
	= random-item( `random-caching-options$t ';' `any-value$t [ ';' `any-value$t ]* )
</pre>

<p>
この関数においては、
`random-caching-options$t は`要求される^em。
それは、
`random$f のときと同じに解釈される
（詳細は、
`§ ~randomな値の生成-法／~cache法＠#random-caching$
を見よ）。
◎
The required &lt;random-caching-options&gt; is interpreted identically to random(). (See § 3.3 Generating/Caching Random Values: the &lt;random-caching-options&gt; value for details.)
</p>

<div class="note">
<p>注記：
`random$f と同様に、［
`dashed-ident$t ／ `per-element^v 
］を利用すれば，［
類似な `random-item$f 関数たちが別個な~random値を生成する／
要素ごとに別個な値に解決される
］よう強制できる。
◎
Like random(), the &lt;dashed-ident&gt; can be used to force similar random-item() functions to generate distinct random values, and per-element causes it to resolve to a distinct value on each element.
</p>

<p>
これらは別として、
`random-item$f 関数たちの~group分けは，
`random$f より ずっと単純である
— 関数どうしが “一致するか” どうかは、
引数の個数のみに基づく。
◎
Aside from these, the grouping of random-item() functions as "identical" is much simpler: all that matters is the number of arguments.
</p>

<p>
すなわち，
`random-item(--x; red; blue; green)^v
と
`random-item(--x; 1; 2; 3)^v
は、
常に同じ引数~indexに解決され，［
`red$v, `1^v ／
`blue$v, `2^v ／
`green$v, `3^v
］いずれかになる。
これは、［
~randomな値たちが成す集合を利用するよう求まれる~prop
］たちが成す~groupどうしの協調を許容する。
◎
That is, random-item(--x; red; blue; green) and random-item(--x; 1; 2; 3) will always resolve to the same argument index: either red and 1, or blue and 2, or green and 3. This allows coordination between groups of properties that all want to use a random set of values.
</p>

<p>
他方、
`random-item(--x; red; blue; green)^v
と
`random-item(--x; 1; 2; 3; 4)^v
には何ら繋がりはなく，
12 通りある どの組合nも生じ得る。
◎
On the other hand, random-item(--x; red; blue; green) and random-item(--x; 1; 2; 3; 4) will have no connection to each other; any of the 12 possible combinations can occur.
</p>
</div>

<div class="note">
<p>注記：
`random-caching-options$t 引数が
`random$f においては省略可能な一方，
`random-item$f においては要求されるわけは：
◎
Note: The &lt;random-caching-options&gt; argument is required in random-item(), but optional in random(), both＼
</p>
<ul>
	<li>
構文解析の理由
（ `random-item(--foo; --bar; --baz)^v が
3 個の `any-value$t 引数をとるのか，
2 個のそれと `random-caching-options$t 引数をとるのか伝えることはアリでない）。
◎
for parsing reasons (it’s impossible to tell whether random-item(--foo; --bar; --baz) has three &lt;any-value&gt; arguments or two and a &lt;random-caching-options&gt; argument),＼
</li>
	<li>
省略可能にすると、［
`random-item^f 関数の~instanceどうしを判別するために利用されるもの
］は，引数の個数しかなくなる
— その結果、
別個な~random生成になるべき関数たちが，不用意に一緒くたにされ易くなる。
◎
and because accidentally associating the random generation of random-item() functions together is much easier to do accidentally, since only the number of arguments is used to distinguish instances.
</li>
</ul>
</div>

<p>
残りの引数は、
~semicolonで分離された~CSS値たちが成す任意な連列である。
`random-item$f 関数は、
この連列から~randomに選ばれる一つに解決される。
◎
The remaining arguments are arbitrary sequences of CSS values, separated by semicolons. The random-item() function resolves to one of these sequences, chosen uniformly at random.
</p>

<p class="note">注記：
~CSSにおける ほとんどの関数と違って，
`random-item$f が引数どうしを~commaではなく~semicolonで分離するのは、
各~引数~自体が~commaを包含し得るからである。
◎
Note: Unlike most functions in CSS, random-item() separates its arguments with semicolons, rather than commas, because its arguments can contain commas themselves.
</p>

<p>
`random-item$f 関数は、
`var$f の様な`任意的~代用~関数$である。
◎
The random-item() function is an arbitrary substitution function, like var().
</p>

<div class="note">
<p>注記：
すなわち，
`random-item$f を利用する場合：
◎
That is, if you use random-item():
</p>
<ul>
	<li>
`random-item$f （および他の`任意的~代用~関数$）自体は、
構文上は妥当である限り，
~prop全体が構文解析-時点では妥当であると見做される。
◎
So long as random-item() itself (and any other arbitrary substitution functions) is syntactically valid, the entire property is assumed to be valid at parse time.
</li>
	<li>
`random-item$f は、
`算出d値$の時点で
— `var$f を`代用する＠~CSSVAR#substitute-a-var$ときと同じく —
［
何であれ それを解決した結果の値
］で代用される
— したがって、
すべての子は，同じ解決した結果の値を継承する。
◎
random-item() is substituted with whatever value it resolves to at computed value time when you’d substitute a var(), so children all inherit the same resolved value.
</li>
	<li>
値で代用した結果，~propが無効になる場合、
当の~propの値は，`無効が保証される値$になる。
◎
If the substituted value ends up making the property invalid, the property’s value becomes the guaranteed-invalid value.
</li>
</ul>
</div>

<p class="issue">
`任意的~代用~関数@
を定義する
— おそらく `CSS-VARIABLES-2$r において。
この “代用” に類する機能性を備える関数が，いくつか控えているので。
◎
Define arbitrary substitution function, probably over in Variables, since we have several upcoming functions leaning on this functionality.
</p>

<p class="issue">
`random-item$f は， `var$f の様にふるまうで、
おそらく，
~prop内に限り利用-可能になるよう制約することが求まれる
（このことは、
そのようなどの関数にも適用するよう求まれる見込みが高い）。
`random$f は，根本的に異なる種類の値であるが、
~thema的な一貫性を得るため，おそらく それも制約するよう求まれる。
◎
Since random-item() is var()-like, we probably want to restrict it to only be usable in properties. (This is likely something we want to apply to all such functions.) Tho random() is a fundamentally different kind of value, we probably want to restrict it as well, for thematic consistency.
</p>

		</section>
		<section id="random-caching">
<h3 title="Generating/Caching Random Values: the &lt;random-caching-options&gt; value">3.3. ~randomな値の生成-法／~cache法： `random-caching-options$t 値</h3>

<p>
~JSの様な~programming言語においては，
~code内に明瞭な時間的~順序付けが在るので、
`Math.random()^c に対する~callの様なものが`いつ評価されるか^emを正確に伝えれる。
結果は変数~内に格納できるので、
複数の箇所で［
単独の~randomな値を再利用しているのか，別個な~random値を利用しているのか
］は，明瞭になる。
◎
In a programming language like JavaScript, there’s a clear temporal ordering to code, so you can tell exactly when something like a call to Math.random() is evaluated. You can also store the results in a variable, making it clear when you’re reusing a single random value in multiple places, versus using a distinct random value in each location.
</p>

<p>
他方，~CSSは宣言的な言語なので
（~codeは、
特定0の順序で “実行される” ことはなく，
何かが何回 “実行されるか” に対する制御も無い）、
同じ~styleを複数の要素に適用することは，ごく容易であるが：
◎
CSS, on the other hand, is a declarative language (code is not "executed" in any particular order, nor is there any control over how many times something is "executed");＼
it makes it very easy to apply identical styles to multiple elements but＼
</p>
<ul>
	<li>
各~要素に別個な値を指定することは困難である
（ `random$f が［
それを利用している~propが適用される各~要素
］に対し［
同じ値, 別個な値
］どちらに解決するよう意味されるかは、
不明瞭である）。
◎
difficult to specify distinct values for each of them (making it unclear whether a property using random() is meant to resolve to the same value on each element it’s applied to or to distinct values on each);＼
</li>
	<li>
“変数” の機能性は，ごく制限される
（特定0の［
~randomに生成された値
］を何箇所かで意図的に再利用することは、
困難である）。
◎
and it has very limited "variable" functionality (making it difficult to intentionally reuse a particular randomly-generated value in several places).
</li>
</ul>

<p>
これらの課題を解決するため、
`~random関数$【！the random() and random-item() functions】は，
次に挙げる［
~cache法の意味論
］の下で~randomな値を生成するものと定義される：
◎
To resolve these issues, the random() and random-item() functions are defined to generate random values under the following caching semantics:
</p>
<ul>
	<li>
<p>
~stylesheet内の各［
`~random関数$【！`random$f or `random-item$f】の~instance
］は、
`~random~cache用~key@
を指定する。
［
`random$f たち／ `random-item$f たち
］【！Two instances of either function】は、
`~random~cache用~key$が［
一致するならば`一致する値^em／
異なるならば`別個な値^em
］（順不同）に解決するモノトスル。
◎
Each instance of random() or random-item() in a stylesheet specifies a random-caching key. Two instances of either function must resolve to identical values if their random-caching keys are identical; they must resolve to distinct values if they’re different.
</p>

<p>
（ここでの “別個” とは、［
ある新規な~random演算により生成される
］ことを意味する
— その結果は、
別の~random演算と偶然~同じ値になるかもしれないが。）
◎
("Distinct" here means generated by a fresh random operation; this might coincidentally result in the same value as another random operation.)
</p>
	</li>
	<li>
<p>
`random$f 用の`~random~cache用~key$は、
次に挙げるものからなる`~tuple$である：
◎
For random(), the random-caching key is a tuple of:
</p>
		<ol>
			<li>
最小を与える`計算式$の`使用~値$。
◎
The used value of the minimum calculation.
</li>
			<li>
最大を与える`計算式$の`使用~値$。
◎
The used value of the maximum calculation.
</li>
			<li>
段差を与える`計算式$が［
在るならば その`使用~値$／
無いならば ~NULL
］。
◎
The used value of the step calculation, if present, or null otherwise.
</li>
			<li>
`random-caching-options$t を成す `dashed-ident$t は［
在るならば それ／
無いならば ~NULL
］。
◎
The &lt;dashed-ident&gt; part of the &lt;random-caching-options&gt;, if present, or null otherwise.
</li>
			<li>
`random-caching-options$t 内に `per-element^v が指定された場合、
当の関数が現れる［
要素／疑似要素
］ごとに一意な値。
◎
If per-element is specified in the &lt;random-caching-options&gt;, a unique value per element or pseudo-element the function appears in.
</li>
		</ol>
	</li>
	<li>
<p>
`random-item$f 用の`~random~cache用~key$は、
次に挙げるものからなる`~tuple$である：
◎
For random-item(), the random-caching key is a tuple of:
</p>
		<ol>
			<li>
当の関数に与えられた引数の個数。
◎
The number of arguments to the function.
</li>
			<li>
`random-caching-options$t を成す `dashed-ident$t は［
在るならば それ／
無いならば ~NULL
］。
◎
The &lt;dashed-ident&gt; part of the &lt;random-caching-options&gt;, if present, or null otherwise.
</li>
			<li>
`random-caching-options$t 内に `per-element^v が指定されたならば、
当の関数が現れる［
要素／疑似要素
］ごとに一意な値。
◎
If per-element is specified in the &lt;random-caching-options&gt;, a unique value per element or pseudo-element the function appears in.
</li>
		</ol>
	</li>
</ul>

<p>
［
要素／疑似要素
］ごとに “一意な値” の存続期間は、［
当の要素／当の疑似要素の`出自の要素$
（および当の疑似要素を一意に識別するために足る追加的な情報）
］への~JS参照と同じになるモノトスル。
別々な文書~内の要素どうしは、
別個な一意な値をとる`べきである^em
（同じ~pageであっても、
別個な文書を生産する場合
— 例：~pageが~refreshされた前後 —
には，別々な文書とされる）。
（このことは，厳密には［
これらの値の疑似-~random生成を許容するために要求されるもの
］ではないが、
一意~性は，作者が［
要素たちが文書どうしで同じ値をとること
］に依存し得なくするには十分なはずと見込まれる。）
◎
The "unique value per element or pseudo-element" must have the same lifetime as a JavaScript reference to the element (or to the originating element + sufficient additional info to uniquely identify the pseudo-element). Elements in separate documents (including across refreshes of the same page, which produces distinct documents with distinct elements) should have distinct unique values. (This is not strictly required, to allow for pseudo-random generation of these values, but uniqueness should be likely enough that authors cannot depend on elements having the same values across documents.)
</p>

<div class="example">
<p>
例えば、
次の~stylesheetにおいて：
◎
For example, in the following stylesheet:
</p>

<pre class="lang-css">
.random-square {
  width: random(100px, 500px);
  height: random(100px, 500px);
}
</pre>

<p>
両~関数の`~random~cache用~key$は、
どちらも
( `100px^v, `500px^v, ~NULL, ~NULL, ~NULL )
になり，一致する。
このことは、
どちらも正確に同じ値に解決されることを意味する
— その結果、
`.random-square^css に合致している要素たちは，［
縦幅, 横幅とも同じ［
`100px^v 以上 `500px^v 以下のどこかにある~size
］を伴う正方形になる
］かつ［
どの要素も同じ~sizeになる
］ことが保証される。
◎
The random-caching keys for both functions are identical: (100px, 500px, null, null, null). This means that both will resolve to the exact same value, guaranteeing a square element with a size somewhere between 100px and 500px. Additionally, every .random-square element will have the same size.
</p>

<p>
他方，次の~stylesheetでは：
◎
On other hand, in this stylesheet:
</p>

<pre class="lang-css">
.random-rect {
  width: random(100px, 500px);
  height: random(--x, 100px, 500px);
}
</pre>

<p>
両~関数の`~random~cache用~key$は、
別個になる
⇒＃
`width$p においては ( `100px^v, `500px^v, ~NULL, ~NULL, ~NULL ),
`height$p においては ( `100px^v, `500px^v, ~NULL, `--x^v, ~NULL )
◎
The random-caching keys are distinct between the two functions: the function in width has (100px, 500px, null, null, null), while the function in height has (100px, 500px, null, --x, null).
</p>

<p>
すなわち、
両~関数は別個な~random値に解決され，要素は およそ正方形にならない。
それでも、
`.random-rect^css に合致している要素たちは，
`同じ^em~randomな~sizeを有することになる。
◎
This means the two functions will resolve to distinct random values, making it very unlikely for the element to be square. However, every element matching .random-rect will still have the same random size.
</p>

<p>
この~keyは、
関数を成す どの側面を変更しても，改められる。
類似に、
次の 2 個の宣言は別個になる
— 結果の横幅と縦幅には何ら繋がりはない：
◎
Changing any aspect of the function also alters this key. The following two declarations are similarly distinct, resulting in the width and height having no connection to each other:
</p>

<pre class="lang-css">
.random-rect-2 {
  width: random(100px, 500px);
  height: random(100px, 500px, by 50px);
}
</pre>

<p>
2 つの関数は、
見かけは異なっていても，【各~引数の】使用~値が一致するならば一致する。
例えば，次の~codeでは：
◎
But so long as the used-values end up identical, two functions that look distinct might end up identical. For example, in the following code:
</p>

<pre class="lang-css">
.random-square-2 {
  font-size: 16px;
  width: random(160px, 320px);
  height: random(10em, 20em);
}
</pre>

<p>
2 つの関数は，見かけ上は異なるが、
`~random~cache用~key$は，
長さを全部的に解決した後には どちらも
( `160px^v, `320px^v, ~NULL, ~NULL, ~NULL )
になるので、［
横幅, 縦幅
］は，実際には常に一致するようになる。
◎
The two functions superficially look different, but after the lengths are fully resolved they end up with identical random-caching keys; each is (160px, 320px, null, null, null), so actually the widths and heights will end up always identical.
</p>
</div>

<div class="example">
<p>
既定では、
~stylesheet内の各［
`random$f 関数の~instance
］は，本質的に静的な値に解決され、
当の~propが適用される要素~すべてから共有される。
この挙動は、
`per-element^v ~keywordで変更できる。
◎
By default, each instance of a random() function in a stylesheet essentially resolves to a static value, which is then shared by every element that property applies to. This behavior can be changed with the per-element keyword.
</p>

<p>
例えば、
次においては：
◎
For example, in:
</p>

<pre class="lang-css">
.foo { width: random(100px, 500px); }
</pre>

<p>
`.foo^css に合致している要素たちの横幅は，
同じ~randomな値になるが、
次においては：
◎
Multiple elements matching .foo will end up with the same random width.
◎
But in:
</p>

<pre class="lang-css">
.foo { width: random(per-element, 100px, 500px); }
</pre>

<p>
`.foo^css に合致している各~要素は、
自前の`一意^emな横幅を取得することになる。
◎
Every element matching .foo will get its own unique width.
</p>

<p>
これは，値を要素ごとに一意にするが、
`値ごと^emに一意になることは必要とされないことに注意。
例えば、
次においては：
◎
Note that this causes the value to be unique per element, not per value necessarily. For example, in:
</p>

<pre class="lang-css">
.random-squares {
  width: random(per-element, 100px, 500px);
  height: random(per-element, 100px, 500px);
}
</pre>

<p>
`.random-squares^css に合致している要素たちは，互いに別個な~random値を取得するが、
各~要素の［
`width$p, `height$p
］~propは，どちらも`同じ値^emをとり，要素を正方形にする。
— それらの~propの`~random~cache用~key$は
( `100px^v, `500px^v, ~NULL, ~NULL, 当の要素~用の一意な値 )
であり、
どちらの関数も同じ要素~上では同じ長さに解決されるので。
◎
Every element matching .random-squares will get a distinct random value, but that value will be the same for width and height on a given element, making the element square. This is because in both properties the random-caching key is (100px, 500px, null, null, [unique value for the element]), so both functions will resolve to the same length on a single element.
</p>

<p>
これは、
`~custom~prop$における~randomな値が，より予測-可能に動作するようにする。
上の~codeは、
次のように書くこともできる：
◎
This makes random values in custom properties act more predictably. The preceding code could also be written as:
</p>

<pre class="lang-css">
.foo {
  --size: random(per-element, 100px, 500px);
  width: var(--size);
  height: var(--size);
}
</pre>
</div>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
まずは、
以前の~levelまでに対する`すべての貢献者たち＠~CSSVAL#acknowledgments$に感謝する。
◎
Firstly, the editors would like to thank all of the contributors to the previous level of this module.
</p>

<p>
~commentと示唆を寄せられ，この~level 5 を改善した
`L. David Baron^en,
`Mike Bremford^en
各氏にも感謝する。
◎
Secondly, we would like to acknowledge L. David Baron and Mike Bremford for their comments and suggestions, which have improved Level 5.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-recent">
近過去な変更点
◎
Recent Changes
</dt>
	<dd>
（これは、`~level 4 からの追加＠#additions-L4$の下位集合を成す。）
◎
(This is a subset of Additions Since Level 4.)
</dd>

	<dt id="additions-L4">
`~level 4$ からの追加
◎
Additions Since Level 4
◎
Additions since CSS Values and Units Level 4:
</dt>
	<dd>
`toggle$f 記法, `attr$f 記法を追加した。
◎
Added the toggle() and attr() notations
</dd>
</dl>

	</section>
	<section id="sec-pri">
<h2 title="Security and Privacy Considerations">~security／~privacyの考慮点</h2>

<p>
この仕様は、
ほぼ~CSS仕様に共通な単位を定義するだけであり，
~securityの懸念は無い。
◎
This specification mostly just defines units that are common to CSS specifications, and which present no security concerns.
</p>

<p class="note">注記：
~URLの取扱いには、
~securityの懸念はあるか？
おそらく。
◎
Note: Does URL handling have a security concern? Probably.
</p>

<p>
この仕様は、
利用者の［
~screen~size, 既定の~font~size
］を公開する単位を定義するが、
どちらも~JSから自明に観測-可能なので，
新たな~privacy~riskを成すことはない。
◎
This specification defines units that expose the user’s screen size and default font size, but both are trivially observable from JS, so they do not constitute a new privacy risk.
</p>

	</section>
</main></div>

