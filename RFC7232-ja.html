<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>RFC 7232 — HTTP/1.1: Conditional Requests（日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css">
<link rel="stylesheet" href="http-common.css" type="text/css">
<script src="common0.js"></script>
<script src="RFC723X.js"></script>
<script src="common1.js" async></script>

<script type="text/plain" id="_source_data">


●●options

spec_title:RFC 7232 — HTTP/1.1: Conditional Requests
trans_update:2020-11-27
page_state_key:HTTP
original_url:https://httpwg.org/specs/rfc7232.html
spec_status:IETFPR
abbr_url:7232
no_original_dfn:true
trans_1st_pub:2014-12-07

●●mdn_urls
header.etag:HTTP/Headers/ETag
header.last-modified:HTTP/Headers/Last-Modified
header.if-match:HTTP/Headers/If-Match
header.if-none-match:HTTP/Headers/If-None-Match
header.if-modified-since:HTTP/Headers/If-Modified-Since
header.if-unmodified-since:HTTP/Headers/If-Unmodified-Since

status.304:HTTP/Status/304
status.412:HTTP/Status/412

●●link_map

h.If:~RFCx/rfc4918#section-10.4
~lock:~RFCx/rfc4918#section-6

改変~日時:#modification-date
	~weakness指示子:#weakness-indicator
鮮度~時間:~7234#freshness-lifetime
~cache鮮度:~7234#expiration.model
条件付き:#preconditions
不透明な:#opaque
不透明:#opaque
強い:#strong-validator
弱い:#weak-validator

更新喪失:#lost-update
	評価-:~7232#evaluate
	優先順:#section-6
	事前条件の評価-:~7232#section-5
	強い比較:~7232#strong-comparison
	弱い比較:~7232#weak-comparison
	強い検証子:~7232#strong-validator
	弱い検証子:~7232#weak-validator

	条件付き:~7231#section-5.2
	条件付き要請~header:~7231#section-5.2
	~metadata~header


●●section_map


1:introduction
1.1:conformance
1.2:notation
2:validators
2.1:weak.and.strong.validators
2.2:header.last-modified
2.2.1:lastmod.generation
2.2.2:lastmod.comparison
2.3:header.etag
2.3.1:entity.tag.generation
2.3.2:entity.tag.comparison
2.3.3:example.entity.tag.vs.conneg
2.4:when.to.use.entity.tags.and.last-modified.dates
3:preconditions
3.1:header.if-match
3.2:header.if-none-match
3.3:header.if-modified-since
3.4:header.if-unmodified-since
3.5:header.if-range
4:status.code.definitions
4.1:status.304
4.2:status.412
5:evaluation
6:precedence
7:IANA.considerations
7.1:status.code.registration
7.2:header.field.registration
8:security.considerations
9:acks
10:rfc.references
A:changes.from.rfc.2616
B:imported.abnf
C:collected.abnf


●●words_table1


●●words_table


variance:
traversal:
last-modified:
結論:conclusion:~
not feasible／
	~~困難:unfeasible
相互運用目的:interoperating 目的::~
自己決定的な:self-determined:~
天気:weather:~
予報:report:~
時機:time:~
時区間:time window:~
backup::::バックアップ
scale::::スケール
	~scale能:scalability
信頼性:reliability:~
上書:overwrite::上書き
要因:significant factor:~
分解能:resolution:~
同等性:equality:~
	抑制-:reduction of
耐衝突:collision-resistant:~
利点:advantage:~
	利点~point
	~~悪影響:adverse impact
	〜に関わる:What matters to
一意性:uniqueness:~
査定-:assess:~
	assessment
演繹-:deduce:~
原理:principle:~
写像:map:~
支持:support:~
不作為:inadvertent:~
発生:arise:~
対象範囲:scope:~
不都合:inconvenient:~
等価性:equivalency:~
代用:substitute:~
置換:replacement:代用
最悪:worst:~
書込n:write::書き込み
拡げら:expandさ:~


●●

同期-に乏しい:poorly synchronized
事実がなかったとするなら:if it were not for the fact
秒単位より細かい:sub-second
秒単位:one-second
秒:seconds
過去:before
計算し直す:recalculate
1 秒:the second
問題:issues
archive
抗する防御:guard against
用心:guard
ときには:occasional
~~遠い:distant
から見て:perspective
短か過ぎる:too short
~escapeを~~解除:unescaping
写像:map
~~考える:considerする
様々になる:vary
別物distinct
~~支持:support
一種:variation
終えた:perform
一例として:for instance
保つ:keep
~~大体 同じ:around the same
種類:flavor
期間:period of time
対象にする:overする
課す:impose
~~最大の:best
~~直前の:immediately prior
に過ぎない:at best,
濫用:abuse
順調に:nicely
	浄化:clear
あまり〜でない:far less
~~観点:considerations
最良である:the best
より適化する:optimistic
“過去に戻る”:go "back in time"
~~見做され:presumed
それに伴い:thereby


●●trans_metadata
<p>
~THIS_PAGEは、
~IETF により PROPOSED STANDARD として公表された，
RFC 7232
<a href="~SPEC_URL">Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</a>
を日本語に翻訳したものです。
~PUB
</p>


●●spec_metadata

公表者
	Internet Engineering Task Force (IETF)
RFC
	7232
廃用
	<a href="https://www.rfc-editor.org/rfc/rfc2616">RFC 2616</a>
分類
	Standards Track
ISSN
	2070-1721
編集
	R. Fielding, Adobe
	J. Reschke, greenbytes
日付
	2014 年 6 月
現在の位置付け, 正誤表, フィードバックの方法
	https://www.rfc-editor.org/info/rfc7232

</script>

</head>
<body>

<header>
	<hgroup>
<h1><abbr title="Hypertext Transfer Protocol (version 1.1)">HTTP/1.1</abbr>： 条件付き要請</h1>
<h2>RFC 7232, Conditional Requests</h2>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section>
~ABSTRACT

<div class="p">

<p>
HTTP （ Hypertext Transfer Protocol ）は、分散型の, 協調的な，~hypertext情報~system用の、`~stateless$な~app~levelの~protocolである。
この文書は、次を含む，`~HTTP11$ `条件付き要請$を定義する：
◎
The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP/1.1 conditional requests, including＼
</p>

<ul>
	<li>
状態~変化を指示するための各種~metadata~header
◎
metadata header fields for indicating state changes,＼
</li>
	<li>
そのような状態に対し`事前条件$を為すための，各種 `要請~header$
◎
request header fields for making preconditions on such state, and＼
</li>
	<li>
1 つ以上の`事前条件$が偽に`評価-$されるときの，
`条件付き要請$に対する応答を構築するための規則
◎
rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.
</li>
</ul>
</div>

	</section>
	<section id="rfc.status">
<h2 title="Status of This Memo">このメモの位置付け</h2>

<p class="trans-note">【
この節の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#status$に移譲。
】</p>

	</section>
	<section id="rfc.copyrightnotice">
<h2 title="Copyright Notice">著作権の告知</h2>

<p lang="en">
Copyright © 2014 IETF Trust and the persons identified as the document authors. All rights reserved.
</p>

<p class="trans-note">【
以下、この節の他の内容は
`~IETF日本語訳 共通~page＠~IETFcommon#copyright-notice$に移譲。
】</p>

	</section>

<main id="MAIN0">

	<section id="section-1">
<h2 title="Introduction">1. 序論</h2>

<p>
`条件付き要請@
とは、［
~method意味論を`~target資源$に適用する前に~testされることになる，`事前条件$
］を指示する 1 個~以上の~header（
`条件付き~header$
）を内包する，`~HTTP要請$である。
この文書は、`~HTTP11$ `条件付き要請$の仕組みを，
`7230$R にて定義される［
~architecture,
構文~表記法,
適合性~判定基準
］を通して定義する。
◎
Conditional requests are HTTP requests [RFC7231] that include one or more header fields indicating a precondition to be tested before applying the method semantics to the target resource. This document defines the HTTP/1.1 conditional request mechanisms in terms of the architecture, syntax notation, and conformance criteria defined in [RFC7230].
</p>

<p>
条件付き `GET$m 要請は、
~HTTP~cache更新（`7234$R）用の効率的な仕組みの大部分を~~占める。
条件付き~headerは、
“`更新喪失@” 問題
— 並列的に動作している ある~clientが，別の~clientによる成果を偶発的に上書すること —
を防止するために［
`PUT$m や `DELETE$m  などの状態変更~method
］にも適用し得る。
◎
Conditional GET requests are the most efficient mechanism for HTTP cache updates [RFC7234]. Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the "lost update" problem: one client accidentally overwriting the work of another client that has been acting in parallel.
</p>

<p>
`条件付き要請$の`事前条件$は、［
全体としての`~target資源$の状態（その現在の値の集合）
］, あるいは［
以前に得した`表現$（その集合~内の 1 つの値）
］にて観測される状態に基づく。
`資源$は、現在の表現として，［
それぞれが自前の観測-可能な状態を伴うような，複数の表現
］を持ち得る。
条件付き要請の仕組みは、その利点を得ようと意図する~serverにおいては，［
要請から`選定された表現$への対応関係が，時間~越しに一貫する
］ものと見做す。
いずれにせよ、対応関係が一貫しなくなり，~serverが適切な`表現$を選定できなくなった場合、事前条件が偽に`評価-$されるときは，害を及ぼすことはない。
◎
Conditional request preconditions are based on the state of the target resource as a whole (its current value set) or the state as observed in a previously obtained representation (one value in that set). A resource might have multiple current representations, each with its own observable state. The conditional request mechanisms assume that the mapping of requests to a "selected representation" (Section 3 of [RFC7231]) will be consistent over time if the server intends to take advantage of conditionals. Regardless, if the mapping is inconsistent and the server is unable to select the appropriate representation, then no harm will result when the precondition evaluates to false.
</p>

<p>
この仕様にて定義される［
`条件付き要請$の`事前条件$
］は、受信者に適用-可能であるときに限り，それらの優先順（`6$sec）に則って`評価-$される。
◎
The conditional request preconditions defined by this specification (Section 3) are evaluated when applicable to the recipient (Section 5) according to their order of precedence (Section 6).
</p>

		<section id="section-1.1">
<h3 title="Conformance and Error Handling">1.1. 適合性, ~errorの取扱い</h3>

<p>
この文書~内の~keyword "MUST" …
【以下、この段落の内容は`~IETF日本語訳 共通~page＠~IETFcommon#requirements-notation$に移譲。】
◎
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
</p>

<p>
適合性の判定基準, および
~errorの取扱いに関する考慮点は、
`7230-2.5$rfc にて定義される。
◎
Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].
</p>

		</section>
		<section id="section-1.2">
<h3 title="Syntax Notation">1.2. 構文の表記法</h3>

<p class="trans-note">【
この節の他の内容は、
`~HTTP日本語訳 共通~page＠~HTTPcommon#syntax-notation$に移譲。
】</p>

<p>
`総集的~ABNF＠~723Xabnf#abnf-7232$
にて、他の文書から取込まれた規則, および
すべての`~list演算子$を標準な~ABNF表記法に展開した，総集的な文法を示す。
◎
Appendix B describes rules imported from other documents. Appendix C shows the collected grammar with all list operators expanded to standard ABNF notation.
</p>

		</section>
	</section>
	<section id="section-2">
<h2 title="Validators">2. 検証子</h2>

<p>
この仕様は、［
`資源$の状態を観測する, および
`事前条件$を~testする
］ために共通的に利用される， 2 種の形の~metadata［
`改変~日時$,
`不透明な$ `entity-tag$p
］を定義する。
`資源$の状態を反映する追加的な~metadataも，~HTTPの様々な拡張により定義されている
— この仕様の視野を超える
WebDAV（ Web Distributed Authoring and Versioning, `4918$R ）など。
`事前条件$の中で利用される資源~metadata値は、
`検証子^dfn
と呼ばれる。
◎
This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (Section 2.2) and opaque entity tags (Section 2.3). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning (WebDAV, [RFC4918]), that are beyond the scope of this specification. A resource metadata value is referred to as a "validator" when it is used within a precondition.
</p>

		<section id="section-2.1">
<h3 title="Weak versus Strong">2.1. 弱い vs. 強い</h3>

<p>
検証子には、強いものと, 弱いものがある。
`弱い検証子$は，容易に生成できるが、比較~~用途には，あまり有用でない。
`強い検証子$は，比較~~用途に理想的であるが、効率的に生成するのは，とても困難にも（ときには不可能にも）なり得る。
~HTTPは、［
すべての形の`資源$に，同じ強さの検証子を固守する
］ことを課すのではなく，［
利用~中にある検証子の型を公開する
］こと, および［
`弱い検証子$を いつどこで`事前条件$に利用できるか
］についての制約を課す。
◎
Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.
</p>

<p>
`強い検証子@
とは、［
`表現~data$が変化する度に値が変化する，`表現~metadata$
］であって，［
`GET$m  に対する `200$st 応答
］の`~payload本体$にて観測-可能になるものである。
◎
A "strong validator" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the payload body of a 200 (OK) response to GET.
</p>

<p>
`強い検証子$は、`表現~data$の変化-以外の事由
— `表現~metadata$の意味論的に有意な部分（例： `Content-Type$h ）が変更された，など —
から変化することもあるが、`生成元~server$にとって~~最大の関心~事は，［［
遠隔~cacheや著作~toolにより保持されている，格納-済み応答
］を無効化させる必要がある
］ときにのみ，値を変更することである。
◎
A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., Content-Type), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.
</p>

<p>
~cache~entryは、その失効~時機に関わらず，任意な期間 持続し続け得る。
したがって~cacheは、［
~~遠い過去に得された検証子を利用している~entry
］を検証しようと試みることもある。
`強い検証子$は、［
ある特定の`資源$に時間~越しに結付けられた，すべての`表現$のすべての~version
］間で，一意になる。
しかしながら、［
互いに異なる資源
］の表現~間にわたる一意性については，含意されない（すなわち、同じ`強い検証子$が，同~時に複数の資源の表現から利用~中になり得るが、それらの表現が等価であることは含意されない）。
◎
Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).
</p>

<p>
実施においては、種々の`強い検証子$が利用されている。
厳密な改訂~制御に基づくものが最良である
— 表現に対する各~変更に際して，［
表現が `GET$m から~access可能にされる前
］に，常に，一意な~node名と改訂~識別子がアテガわれるような。
［
応答~headerが送信されるに先立って，~dataが可用である
］下では，耐衝突~hash関数を`表現~data$に適用して得られる~digestでも足り、検証~要請が受信される度に計算し直す必要はない。
<span id="_errata-5236-1">
ただし、`資源$が［
~metadataにおいてのみ相違するような，別個な`表現$を持つ
］場合（`内容~折衝$の対象になる`~MIME型$のうち ~~複数のものが，同じ~data形式を共有するときに生じ得る）には、`生成元~server$は，それらの表現どうしを判別するための追加的な情報を，検証子に組入れる必要がある。</span>
◎
There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.
</p>

<div class="p">

<p>
対照的に，
`弱い検証子@
は、`表現~data$が変化しても変化しない場合もあるような，`表現~metadata$である。
この弱さは、次のいずれかに因り得る：
◎
In contrast, a "weak validator" is representation metadata that might not change for every change to the representation data. This weakness might be due to＼
</p>

<ul>
	<li>
`時計$の分解能などの，値が計算される方法における制限。
◎
limitations in how the value is calculated, such as clock resolution,＼
</li>
	<li>
`資源$にアリなすべての`表現$ 間での一意性を，確保できないとき。
◎
an inability to ensure uniqueness for all possible representations of the resource, or＼
</li>
	<li>
資源~所有者は、`表現$ 間で一意な~data列ではなく，何らかの自己決定的な等価性に基づいて、`表現$たちを いくつかの集合に~group化することを欲しているとき。
◎
a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data.＼
</li>
</ul>

<p>
`生成元~server$は、［
先立つ`表現$たちが現在の`表現$の代用として受容-可能でない
］と見なす度に，`弱い$ `entity-tag$p を変更するベキである。
言い換えれば、~cacheの中の古い応答を無効化させたく求める度に，変更する~OUGHT。
◎
An origin server SHOULD change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.
</p>

</div>

<p>
例えば、［
動的な測定に基づいて 内容が秒単位で変化するような，天気~予報の表現
］は、同じ`弱い検証子$により，（`生成元~server$から見て）等価な表現の集合に~group化されるかもしれない
— ~cache済み表現が、（たぶん，~server負荷や天気の質に基づいて動的に調整されるような）適度な期間，有効であり続けられるようにするために。
同様に、表現の改変~時刻が秒単位の分解能で定義されていて，その表現が 1 秒~間に 2 回~改変され，それらの改変の合間に検索取得され得る場合には、`弱い検証子$になることがある。
◎
For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.
</p>

<p>
同様に、検証子は、所与の`資源$の~~複数の`表現$間で同~時に共有されているならば，`弱い$ものになる
— それらの`表現~data$が一致しない限り†1。
例えば、`生成元~server$が，［
`gzip$c `内容~符号法$が適用された表現
］に対し［
内容~符号法を伴わない表現のときと同じ`検証子$
］を送信する場合、それは`弱い検証子$になる。
しかしながら†2，複数の`表現$が，同じ`強い検証子$を同時に共有することもある
— 同じ`表現~data$に対し，複数の異なる`~MIME型$が可用であるときなど、それらが`表現~metadata$においてのみ相違する場合には。
◎
Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.
</p>

<p class="trans-note">【†
`5162$errataに報告あり（ Reported: 2018-01-16 ）：
上の段落の †1 の “一致しない限り” を“…一致していても” に修正した上で、
†2 以下の文は削除するべき
— `この箇所の記述＠#_errata-5236-1$と競合するので。
】</p>

<p>
`強い検証子$は、どの`条件付き要請$にも利用できる
— ［
`~cache検証$,
`部分的$な内容~範囲,
“`更新喪失$” 回避法
］も含め。
`弱い検証子$を利用できるのは、［
~clientが以前に得された`表現~data$との正確な同等性を要求しないとき
］に限られる
— ~cache~entryを検証するときや，近過去の変更に対しては~web~traversalを制限するときなど。
◎
Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and "lost update" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.
</p>

		</section>
		<section id="section-2.2">
<h3 title="Last-Modified">2.2. `Last-Modified^h</h3>

<p>
応答~内の `Last-Modified$h ~headerは、`生成元~server$が要請の取扱いから結論に至った，
`改変~日時@
— `選定された表現$が最後に改変された日付時刻 —
を指示する時刻印を供する。
◎
The "Last-Modified" header field in a response provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.
</p>

<pre class="bnf">
`Last-Modified@p = `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of its use is
</p>

<pre class="lang-http">
Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</pre>

</div>

			<section id="section-2.2.1">
<h4 title="Generation">2.2.1. 生成</h4>

<p>
`生成元~server$は、どの`選定された表現$に対しても，［
その最後の`改変~日時$を，適度かつ一貫するように決定できる
］ならば、
`Last-Modified$h を送信するベキである
— `条件付き要請$における その利用, および`~cache鮮度$の評価は、~Internet上の~HTTP流通を相当に抑制し，~serviceの~scale能と信頼性を改善する要因になり得るので。
◎
An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([RFC7234]) results in a substantial reduction of HTTP traffic on the Internet and can be a significant factor in improving service scalability and reliability.
</p>

<p>
表現は概して、資源~interfaceの背後にある多くの部分の総和である。
~last-modified時刻は、通例的に［
それらの部分のどれかが変更された，最も近過去の時刻
］になる。
所与の任意の`資源$に対し，その値が決定される方法は、実装の詳細であり，この仕様の視野を超える。
~HTTPに関わるのは、
`Last-Modified$h  ~headerの受信者たちが［
`条件付き要請$を為す ／
局所的に~cacheされた応答の有効性を~testする
］ために，その値をどう利用し得るかである。
◎
A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification. What matters to HTTP is how recipients of the Last-Modified header field can use its value to make conditional requests and test the validity of locally cached responses.
</p>

<p>
`生成元~server$は、［［
自身が応答に対し `Date$h ~header値を生成する時刻
］にアリな限り近い，`表現$の `Last-Modified$h 値
］を得するベキである。
これにより、受信者は，表現の改変 時刻を正確aに査定できるようになる
— とりわけ，表現の変化が［
応答が`生成され$た時刻
］に近い場合に。
◎
An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.
</p>

<p>
`時計$を備える`生成元~server$は、［
~serverによる~message出生時の時刻（ `Date$h ）より後の， `Last-Modified$h 日時
］を送信してはナラナイ。
最後の改変~時刻が，［［
生成元~serverの`時計$に則って，ある未来の時刻に評価される
］ような実装に特有な~metadata
］から導出される場合、`生成元~server$は，その値を~message出生時の日時に置換しなければナラナイ。
未来の`改変~日時$は、`~cache検証$に~~悪影響があるので。
◎
An origin server with a clock MUST NOT send a Last-Modified date that is later than the server's time of message origination (Date). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.
</p>

<p>
`時計$を備えていない`生成元~server$は、応答に `Last-Modified$h 値をアテガってはナラナイ
— その値が、依拠-可能な`時計$を備える他の~systemや利用者により，`資源$に結付けられていない限り。
◎
An origin server without a clock MUST NOT assign Last-Modified values to a response unless these values were associated with the resource by some other system or user with a reliable clock.
</p>

			</section>
			<section id="section-2.2.2">
<h4 title="Comparison">2.2.2. 比較</h4>

<p>
要請~内の検証子として利用される，応答~内の `Last-Modified$h 時刻（以下 `V^var ）は、次のいずれかの規則を利用して`強い検証子$であることが演繹できない限り，暗黙的に`弱い検証子$になる（以下における `表現^var は、その検証子に結付けられている`表現$を指す）：
◎
A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:
</p>

<ul>
	<li>
<p>
`生成元~server$が、検証子 `V^var を， `表現^var に対する実際の現在の検証子と比較しているとき：
◎
• The validator is being compared by an origin server to the actual current validator for the representation and,
</p>
		<ul>
			<li>
当の生成元~serverは、［
`表現^var は、
`V^var が受持つ 1 秒【！the second】の間に 2 回~変化しない
］ことを依拠-可能に知り得る。
◎
• That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator.
</li>
		</ul>
	</li>
	<li>
<p>
~clientが、 `表現^var に対する~cache~entryを持っているので，検証子 `V^var を［
`If-Modified-Since$h ／
`If-Unmodified-Since$h ／
`If-Range$h
］~header内に利用しつつあるとき：
◎
or
◎
• The validator is about to be used by a client in an If-Modified-Since, If-Unmodified-Since, or If-Range header field, because the client has a cache entry for the associated representation, and
</p>
		<ul>
			<li>
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻を与える `Date$h 値を内包する
］，かつ
◎
• That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
</li>
			<li>
`V^var は，少なくとも 60 秒は `Date$h 値より~~過去である。
◎
• The presented Last-Modified time is at least 60 seconds before the Date value.
</li>
		</ul>
	</li>
	<li>
<p>
中継~cacheが、検証子 `V^var を，［
自身の~cache~entry内に格納-済みの， `表現^var に対する検証子
］と比較しているとき：
◎
or
◎
• The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and
</p>
		<ul>
			<li>
その~cache~entryは、［
`生成元~server$が元の応答を送信した時刻を与える `Date$h 値
］を内包する，かつ
◎
• That cache entry includes a Date value, which gives the time when the origin server sent the original response, and
</li>
			<li>
`V^var は，少なくとも 60 秒は `Date$h 値より~~過去である。
◎
• The presented Last-Modified time is at least 60 seconds before the Date value.
</li>
		</ul>
	</li>
</ul>

<!-- 
上述から、同じ応答~内の検証子に対する
強い／弱い
の定義は、~server／~client／中継~cacheの間で異なり得ることになる。
-->

<p>
この演繹-法は、［
異なる 2 個の応答が，同じ秒の間に`生成元~server$から送信されたが、両者とも同じ `Last-Modified$h 時刻を持っていた場合には、少なくとも一方の応答は，その
`Last-Modified$h 時刻に等しい `Date$h 値を持つことになる
］という事実に依拠する。
恣意的な 60 秒の上限は、
`Date$h ＆ `Last-Modified$h 値が［
異なる`時計$, あるいは
応答を準備する間にずれた時刻
］から`生成され$る可能性に対する用心である。
実装は、 60 秒では短か過ぎると予見される場合は，より大きい値を利用してヨイ。
◎
This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60-second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.
</p>

			</section>
		</section>
		<section id="section-2.3">
<h3 title="ETag">2.3. `Etag^h</h3>

<p>
応答~内の `ETag$h ~headerは、要請の取扱いから結論に至った，［
`選定された表現$に対する現在の `entity-tag$p
］を供する。
`entity-tag$p は、
同じ`資源$による複数の`表現$を相違化するための，`不透明な$検証子である。
それら複数の表現が何に因るのか
—［
`資源$の時間~越しな状態~変化によるのか，
`内容~折衝$により同~時に複数の表現が妥当になったことによるのか
］, あるいはこの両者によるのか —
に関わらず。
`entity-tag$p の主部は，引用符で括られた`不透明な$文字列（ `opaque-tag$p ）であり、`弱い検証子$であるときは，それを指示する `weak$p 接頭辞も付与される：
◎
The "ETag" header field in a response provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request. An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity-tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.
</p>

<pre class="bnf">
`ETag@p       = `entity-tag$p

`entity-tag@p = [ `weak$p ] `opaque-tag$p
`weak@p       = %x57.2F ; "W/"`, 文字大小区別^com
`opaque-tag@p = `DQUOTE$P *`etagc$p `DQUOTE$P
`etagc@p      = %x21 / %x23-7E / `obs-text$p
           ; <span class="comment"
	title="VCHAR except double quotes, plus obs-text"
	>`DQUOTE^P を除く `VCHAR^P, および `obs-text^p</span>
</pre>

<p class="note">注記：
`opaque-tag$p は、以前には
`quoted-string$p （ `2616-3.11$rfc ）として定義されていた。
そのため、受信者の中には，~backslash~escapeを~~解除しようとするものもある。
したがって，~serverは、
`entity-tag$p 内では~backslash文字を避ける~OUGHT。
◎
Note: Previously, opaque-tag was defined to be a quoted-string ([RFC2616], Section 3.11); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.
</p>

<div class="p">

<p>
次のいずれかの状況では、
`entity-tag$p は，検証において`改変~日時$よりも依拠-可能になり得る：
◎
An entity-tag can be more reliable for validation than a modification date in situations＼
</p>

<ul>
	<li>
`改変~日時$を格納しにくい不都合がある。
◎
where it is inconvenient to store modification dates,＼
</li>
	<li>
~HTTP日時~値の秒単位の分解能では足らない。
◎
where the one-second resolution of HTTP date values is not sufficient, or＼
</li>
	<li>
`改変~日時$が一貫して保守されていない。
◎
where modification dates are not consistently maintained.
</li>
</ul>
</div>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
ETag: "xyzzy"
ETag: W/"xyzzy"
ETag: ""
</pre>

</div>

<p>
`entity-tag$p は、`弱い検証子$にも, `強い検証子$（これが既定）にも，なり得る。
`表現$に `entity-tag$p を供する`生成元~server$は、［
その代の `entity-tag$p が，`強い検証子$の特性すべてを充足する
］のではない場合には、
`entity-tag$p に `weak$p 接頭辞（ "`W/^c", 文字大小区別）を与えて，`弱い検証子$として~markしなければナラナイ。
◎
An entity-tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity-tag for a representation and the generation of that entity-tag does not satisfy all of the characteristics of a strong validator (Section 2.1), then the origin server MUST mark the entity-tag as weak by prefixing its opaque value with "W/" (case-sensitive).
</p>

			<section id="section-2.3.1">
<h4 title="Generation">2.3.1. 生成</h4>

<div class="p">
<p>
`entity-tag$p の背後にある原理は、次の 2 点にある：
◎
The principle behind entity-tags is that＼
</p>

<ul>
	<li>
`資源$に対し最も正確aかつ効率的な検証の仕組みを選定するような，資源の実装を十分良く知るのは、~service作者のみである。
◎
only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that＼
</li>
	<li>
そのようなどの仕組みも、比較を容易にするために，単純な~octet列に写像できる。
◎
any such mechanism can be mapped to a simple sequence of octets for easy comparison.＼
</li>
</ul>

<p>
値は
`不透明@
なので、~clientは，各 `entity-tag$p がどのように構築されたかを意識する必要はない。
◎
Since the value is opaque, there is no need for the client to be aware of how each entity-tag is constructed.
</p>
</div>

<p>
例えば、［
どの変化にも適用される，実装に特有な~version付け
］を備える`資源$は、内部~改訂~番号を利用するかもしれない
— たぶん，互いの`表現$を正確aに相違化するため，`内容~折衝$用の~variance識別子と組合されるような。
［
表現~内容の耐衝突~hash ／
様々な~file属性の組合n ／
分解能が秒単位より細かい改変~時刻印
］を利用する実装もあり得る。
◎
For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.
</p>

<p>
`生成元~server$は、どの`選定された表現$に対しても，［
変化の検出を，適度かつ一貫するように決定できる
］ならば、
`ETag$h を送信するベキである
— `条件付き要請$における `entity-tag$p の利用, および`~cache鮮度$の評価は、~Internet上の~HTTP流通を相当に抑制し，~serviceの~scale能と信頼性を改善する要因になり得るので。
◎
An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity-tag's use in conditional requests and evaluating cache freshness ([RFC7234]) can result in a substantial reduction of HTTP network traffic and can be a significant factor in improving service scalability and reliability.
</p>

			</section>
			<section id="section-2.3.2">
<h4 title="Comparison">2.3.2. 比較</h4>

<p>
`entity-tag$p を比較するとき、その文脈において`弱い検証子$の利用が許容されるかどうかに依存して、次のいずれかの関数が用いられる：
◎
There are two entity-tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:
</p>

<dl>
	<dt>`強い比較@</dt>
	<dd>
2 つの `entity-tag$p は、［
いずれも`弱い検証子$でない, かつ
互いの `opaque-tag$p が各~文字ごとに合致する
］とき，等価とされる。
◎
• Strong comparison: two entity-tags are equivalent if both are not weak and their opaque-tags match character-by-character.
</dd>

	<dt>`弱い比較@</dt>
	<dd>
2 つの `entity-tag$p は、`弱い$かどうかに関わらず，［
互いの `opaque-tag$p が各~文字ごとに合致する
］とき，等価とされる。
◎
• Weak comparison: two entity-tags are equivalent if their opaque-tags match character-by-character, regardless of either or both being tagged as "weak".
</dd>
</dl>

<p>
下の例に、各種 `entity-tag$p ~pairと，それぞれに対する`弱い比較$／`強い比較$~関数の結果を示す:
◎
The example below shows the results for a set of entity-tag pairs and both the weak and strong comparison function results:
</p>

<div >
<table><thead><tr><td>`ETag^p (1)
<td>`ETag^p (2)
<td>`強い比較$
<td>`弱い比較$
</thead>

<tbody><tr><td>`W/"1"^c
<td>`W/"1"^c
<td>合致しない
<td>合致する

<tr><td>`W/"1"^c
<td>`W/"2"^c
<td>合致しない
<td>合致しない

<tr><td>`W/"1"^c
<td>`"1"^c
<td>合致しない
<td>合致する

<tr><td>`"1"^c
<td>`"1"^c
<td>合致する
<td>合致する

</tbody></table>
<pre lang="en" class="_en">
   +--------+--------+-------------------+-----------------+
   | ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |
   +--------+--------+-------------------+-----------------+
   | W/"1"  | W/"1"  | no match          | match           |
   | W/"1"  | W/"2"  | no match          | no match        |
   | W/"1"  | "1"    | no match          | match           |
   | "1"    | "1"    | match             | match           |
   +--------+--------+-------------------+-----------------+
</pre>

</div>

			</section>
			<section id="section-2.3.3">
<h4 title="Example: Entity-Tags Varying on Content-Negotiated Resources">2.3.3. 内容~折衝された資源により `entity-tag^p が様々になる例</h4>

<p>
`資源$が`内容~折衝$の~subjectであって,
`GET$m 要請に対する応答にて送信される`表現$が
`Accept-Encoding$h 要請~headerに基づいて様々になるときを~~考える。
◎
Consider a resource that is subject to content negotiation (Section 3.4 of [RFC7231]), and where the representations sent in response to a GET request vary based on the Accept-Encoding request header field (Section 5.3.4 of [RFC7231]):
</p>

<div class="example">
<p>
&gt;&gt; 要請：
◎
&gt;&gt; Request:
</p>

<pre class="lang-http">
GET /index HTTP/1.1
Host: www.example.com
Accept-Encoding: gzip
</pre>

<p>
この事例では、応答は
`gzip$c `内容~符号法$を利用するとき／しないときがあるとする。
利用しない場合の応答は、次の様な~~形になる：
◎
In this case, the response might or might not use the gzip content coding. If it does not, the response might look like:
</p>

<p>
&gt;&gt; 応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-a"
Content-Length: 70
Vary: Accept-Encoding
Content-Type: text/plain

Hello World!
Hello World!
Hello World!
Hello World!
Hello World!
</pre>

<p>
代替~表現が `gzip^c `内容~符号法$を利用するときは：
◎
An alternative representation that does use gzip content coding would be:
</p>

<p>
&gt;&gt;
応答：
◎
&gt;&gt; Response:
</p>

<pre class="lang-http">
HTTP/1.1 200 OK
Date: Fri, 26 Mar 2010 00:05:00 GMT
ETag: "123-b"
Content-Length: 43
Vary: Accept-Encoding
Content-Type: text/plain
Content-Encoding: gzip

`…~binary~data…^com
</pre>

</div>

<p class="note">注記：
`内容~符号法$は`表現~data$の~propertyであり、~cache更新や`範囲~要請$の間に競合が起きないようにするため、［
内容が符号化された`表現$,
されていない`表現$
］に対する`強い$ `entity-tag$p は，互いに別個なものになる。
対照的に、`転送~符号法$は ~message転送の間にのみ適用されるものなので，別個な `entity-tag$p にはならない。
◎
Note: Content codings are a property of the representation data, so a strong entity-tag for a content-encoded representation has to be distinct from the entity tag of an unencoded representation to prevent potential conflicts during cache updates and range requests. In contrast, transfer codings (Section 4 of [RFC7230]) apply only during message transfer and do not result in distinct entity-tags.
</p>

			</section>
		</section>
		<section id="section-2.4">
<h3 title="When to Use Entity-Tags and Last-Modified Dates">2.4. `entity-tag^p と `Last-Modified^h  日時 をいつ利用するか</h3>

<p>
`GET$m ／ `HEAD$m に対し， `200$st で応答する`生成元~server$は：
◎
In 200 (OK) responses to GET or HEAD, an origin server:
</p>

<ul>
	<li>
`entity-tag$p 検証子を送信するベキである
— その生成-が~~困難でない限り。
◎
• SHOULD send an entity-tag validator unless it is not feasible to generate one.
</li>
	<li>
`強い$ `entity-tag$p の代わりに `弱い$ `entity-tag$p を送信してヨイ
— 処理能の~~観点から弱い `entity-tag$p の利用が~~支持される, あるいは
強い `entity-tag$p の送信が~~困難ならば。
◎
• MAY send a weak entity-tag instead of a strong entity-tag, if performance considerations support the use of weak entity-tags, or if it is unfeasible to send a strong entity-tag.
</li>
	<li>
`Last-Modified$h 値を送信するベキである
— その送信が~~困難でなければ。
◎
• SHOULD send a Last-Modified value if it is feasible to send one.
</li>
</ul>

<p>
言い換えれば，`生成元~server$に選好される挙動は、検索取得~要請に対する成功裡な応答において，［
`強い$ `entity-tag$p, `Last-Modified$h 値
］の両者を送信することである。
◎
In other words, the preferred behavior for an origin server is to send both a strong entity-tag and a Last-Modified value in successful responses to a retrieval request.
</p>

<p>
~clientは：
◎
A client:
</p>

<ul>
	<li>
`生成元~server$から `entity-tag$p が供されていた場合：
（ `If-Match$h ／ `If-None-Match$h を利用する）どの`~cache検証~要請$ 内にも，その `entity-tag$p を送信しなければナラナイ。
◎
• MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server.
</li>
	<li>
`生成元~server$から `Last-Modified$h 値のみが供されていた場合：
（ `If-Modified-Since$h を利用する）非~部分範囲 `~cache検証~要請$ 内に，`Last-Modified$h 値を送信するベキである。
◎
• SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.
</li>
	<li>
~HTTP10`生成元~server$から `Last-Modified$h 値のみが供されていた場合：
（ `If-Unmodified-Since$h を利用する）部分範囲 `~cache検証~要請$ 内に
`Last-Modified$h 値を送信してヨイ。
困難な事例【？】では、~UAは、これを不能化する仕方を供するベキである。
◎
• MAY send the Last-Modified value in subrange cache validation requests (using If-Unmodified-Since) if only a Last-Modified value has been provided by an HTTP/1.0 origin server. The user agent SHOULD provide a way to disable this, in case of difficulty.
</li>
	<li>
`生成元~server$から［
`entity-tag$p, `Last-Modified$h 値
］の両者が供されていた場合：
`~cache検証~要請$ 内に，両~検証子とも送信するベキである。
これにより、［
~HTTP10, ~HTTP11
］~cacheのいずれも，適切に応答できるようになる。
◎
• SHOULD send both validators in cache validation requests if both an entity-tag and a Last-Modified value have been provided by the origin server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.
</li>
</ul>

		</section>
	</section>
	<section id="section-3">
<h2 title="Precondition Header Fields">3. 事前条件~header</h2>

<p>
この節では、
`条件付き~header^dfn
と呼ばれる，要請~上に`事前条件$を適用するための各種 `~HTTP11$~headerの，構文と意味論を定義する。
`5$secでは、事前条件がいつ適用されるかを定義する。
`6$secでは、事前条件が~~複数~在るときの評価~順序を定義する。
◎
This section defines the syntax and semantics of HTTP/1.1 header fields for applying preconditions on requests. Section 5 defines when the preconditions are applied. Section 6 defines the order of evaluation when more than one precondition is present.
</p>

<p class="trans-note">【
<!-- ＊
事前条件
— その条件が~server上で充足されないときは、`要請~method$を`~target資源$に適用しないものと意図されている条件。
 -->
以下に現れる
“要請~methodを
`条件付きに@
する”
という句は、後続して与えられる`事前条件$を生成元~serverに評価してもらうべく、~clientが，その事前条件を指示する~metadata（`条件付き~header$）を要請~内に`生成する$ことを意味する。
】</p>

		<section id="section-3.1">
<h3 title="If-Match">3.1. `If-Match^h</h3>

<div class="p">

<p>
`If-Match$h ~headerは、`要請~method$を次による`条件付きに$する：
◎
The "If-Match" header field makes the request method conditional on＼
</p>

<ul>
	<li>
<p>
受信者`生成元~server$上の，`~target資源$の現在の`表現$からなる集合を `S^var とするとき、`~header値$に応じて：
◎
the recipient origin server either＼
</p>
		<ul class="switch" id="condition-If-Match">
			<li>
"`*^c" の場合
⇒
`S^var は空でない。
◎
having at least one current representation of the target resource, when the field-value is "*", or＼
</li>
			<li>
`entity-tag$p の~listである場合
⇒
`S^var 内に［
~list内の ある~memberに合致する `entity-tag$p
］を持つものがある。
◎
having a current representation of the target resource that has an entity-tag matching a member of the list of entity-tags provided in the field-value.
</li>
		</ul>
	</li>
</ul>

</div>

<p>
`生成元~server$は、
`If-Match$h に対し `entity-tag$p を比較するときには，`強い比較$~関数を利用しなければナラナイ
— ~clientが，この`事前条件$に意図しているのは、［
`表現~data$に何か変化があった場合には，~methodを適用させない
］ことなので。
◎
An origin server MUST use the strong comparison function when comparing entity-tags for If-Match (Section 2.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.
</p>

<pre class="bnf">
`If-Match@p = "*" / 1#`entity-tag$p
</pre>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
If-Match: "xyzzy"
If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-Match: *
</pre>

</div>

<p>
`If-Match$h は、［［
同じ`資源$に対し，複数の~UAが並列的に動作し得る
］ときの，偶発的な上書（すなわち， “`更新喪失$”問題）
］を防止するために，状態変更~method（例：
`POST$m, `PUT$m, `DELETE$m
）と伴に，最もよく利用される。
また、`安全~method$と伴にも利用され得る
— `選定された表現$が，［
先立つ要請から すでに（あるいは`部分的$に）格納-済みのもの
］に合致しない場合に，要請を中止するために。
◎
If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the "lost update" problem). It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.
</p>

<p>
`If-Match$h ~headerを受信した`生成元~server$は：
</p>

<ol>
	<li>
~methodの遂行に先立って，その~header値に与えられた`前述の条件＠#condition-If-Match$を`評価-$しなければナラナイ。
◎
An origin server that receives an If-Match header field MUST evaluate the condition prior to performing the method (Section 5). If the field-value is "*", the condition is false if the origin server does not have a current representation for the target resource. If the field-value is a list of entity-tags, the condition is false if none of the listed tags match the entity-tag of the selected representation.
	</li>
	<li>
<p>
条件が偽に評価された場合、要請された~methodを遂行してはナラナイ
— 代わりに，次のいずれかで応答しなければナラナイ：
◎
An origin server MUST NOT perform the requested method if a received If-Match condition evaluates to false; instead, the origin server MUST respond with either a) the 412 (Precondition Failed) status code or＼
</p>

		<ul class="switch">
			<li>
<p >
［
状態~変更が要請されていて，その最終~状態が `~target資源$の現在の状態にすでに反映されている
］ことを検証yした場合（すなわち，~UAにより要請された変更はすでに成功したが、たぶん~UAが気づかないうちに，先立つ応答が失われたか, 互換な変更が他の~UAにより行われた）
⇒
いずれかの `2xx$st `状態s~code$で応答する。
◎
b) one of the 2xx (Successful) status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or a compatible change was made by some other user agent).＼
</p>

<p>
この場合、その要請が［
同じ~UAにより為された~~直前の変更
］の重複であるものと検証yできない限り、応答~内に`検証子~header$を送信してはナラナイ。
◎
In the latter case, the origin server MUST NOT send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent.
</p>
			</li>
			<li>
他の場合
⇒
`状態s~code$ `412$st で応答する。
◎
↑</li>
		</ul>
	</li>
</ol>

<p>
`If-Match$h ~headerは、格納-済み応答には適用-可能でないので，~cacheや`中継者$からは無視され得る。
◎
The If-Match header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>

		</section>
		<section id="section-3.2">
<h3 title="If-None-Match">3.2. `If-None-Match^h</h3>

<div class="p">

<p>
`If-None-Match^h ~headerは、受信者である［
~cache／`生成元~server$
］上において，`要請~method$を次による`条件付きに$する：
◎
The "If-None-Match" header field makes the request method conditional on＼
</p>

<ul>
	<li>
<p>
受信者~上の，`~target資源$の現在の`表現$からなる集合を `S^var とするとき、`~header値$に応じて：
◎
a recipient cache or origin server either＼
</p>
		<ul class="switch" id="condition-If-None-Match">
			<li>
"`*^c" の場合
⇒
`S^var は空である。
◎
not having any current representation of the target resource, when the field-value is "*", or＼
</li>
			<li>
`entity-tag$p の~listである場合
⇒
`S^var 内に［
~list内の ある~memberに合致する `entity-tag$p
］を持つものはない。
◎
having a selected representation with an entity-tag that does not match any of those listed in the field-value.
</li>
		</ul>
	</li>
</ul>

</div>

<p>
受信者は、 `If-None-Match$h に対する `entity-tag$p を比較するときには，`弱い比較$~関数を利用しなければナラナイ
— `弱い$ `entity-tag$p は、`表現~data$が変化したとしても，`~cache検証$に利用できるので。
◎
A recipient MUST use the weak comparison function when comparing entity-tags for If-None-Match (Section 2.3.2), since weak entity-tags can be used for cache validation even if there have been changes to the representation data.
</p>

<pre class="bnf">
`If-None-Match@p = "*" / 1#`entity-tag$p
</pre>

<div class="example">
<p>
例：
◎
Examples:
</p>

<pre class="lang-http">
If-None-Match: "xyzzy"
If-None-Match: W/"xyzzy"
If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"
If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"
If-None-Match: *
</pre>

</div>

<p>
`If-None-Match$h は、［
~transactionの~overheadを最小に~~抑えて，~cache済み情報の効率的な更新を可能化する
］ために、首に，条件付き `GET$m 要請にて利用される。
~clientが `entity-tag$p を持つ 1 つ以上の格納-済み応答の更新を欲するときは、
`GET$m 要請を為すときに［
それらの `entity-tag$p からなる~listを包含する， `If-None-Match$h ~header
］を`生成する$ベキである
— これにより、受信者~serverは、［
それら格納-済み応答のいずれかが，`選定された表現$に合致した
］ときに，それを指示する `304$st 応答を送信できるようになる。
◎
If-None-Match is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead. When a client desires to update one or more stored responses that have entity-tags, the client SHOULD generate an If-None-Match header field containing a list of those entity-tags when making a GET request; this allows recipient servers to send a 304 (Not Modified) response to indicate when one of those stored responses matches the selected representation.
</p>

<p>
`If-None-Match$h は、`安全$でない`要請~method$（例： `PUT$m ）にも，値 "`*^c" を伴わせて利用できる
— これにより，~clientは、［［
`資源$が現在の`表現$を持たない
］と予見できるときに，`~target資源$の既存の表現を不作為に改変する
］ことを防止できる。
これは、［
~~複数の~clientが，`~target資源$に対する初期~表現を作成しようと試みた
］ときに発生し得る， “`更新喪失$” 問題の一種である。
◎
If-None-Match can also be used with a value of "*" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (Section 4.2.1 of [RFC7231]). This is a variation on the "lost update" problem that might arise if more than one client attempts to create an initial representation for the target resource.
</p>

<p>
`If-None-Match$h ~headerを受信した`生成元~server$は：
</p>

<ol >
	<li>
<p>
~methodの遂行に先立って，その~header値に与えられた`前述の条件＠#condition-If-None-Match$を`評価-$しなければナラナイ。
</p>
◎
An origin server that receives an If-None-Match header field MUST evaluate the condition prior to performing the method (Section 5). If the field-value is "*", the condition is false if the origin server has a current representation for the target resource. If the field-value is a list of entity-tags, the condition is false if one of the listed tags match the entity-tag of the selected representation.
	</li>
	<li>
条件が偽に評価された場合、要請された~methodを遂行してはナラナイ
— 代わりに，［
`要請~method$が `GET$m または `HEAD$m ならば `304$st ／
他の要請~methodに対しては `412$st
］で応答しなければナラナイ。
◎
An origin server MUST NOT perform the requested method if the condition evaluates to false; instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.
</li>
</ol>

<p>
受信された `If-None-Match$h ~headerの~cache取扱いについての要件は、
`7234-4.3.2$rfc
にて定義される。
◎
Requirements on cache handling of a received If-None-Match header field are defined in Section 4.3.2 of [RFC7234].
</p>

		</section>
		<section id="section-3.3">
<h3 title="If-Modified-Since">3.3. `If-Modified-Since^h</h3>

<div class="p">
<p>
`If-Modified-Since^h ~headerは、 `GET$m ／ `HEAD$m 要請~methodを，次による`条件付きに$する：
◎
The "If-Modified-Since" header field makes a GET or HEAD request method conditional on＼
</p>

<ul id="condition-If-Modified-Since">
	<li>
`選定された表現$の最後の`改変~日時$は、`~header値$に供された日時より近過去である。
◎
the selected representation's modification date being more recent than the date provided in the field-value.＼
</li>
</ul>

<p>
`選定された表現$の~dataが変更されていない場合、その転送を避けれるようになる。
◎
Transfer of the selected representation's data is avoided if that data has not changed.
</p>
</div>

<pre class="bnf">
`If-Modified-Since@p = `HTTP-date$p
</pre>

<div class="example">
<p>
~header例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>

</div>

<p>
受信者は、要請が `If-None-Match$h ~headerも包含する場合には，
`If-Modified-Since$h を無視しなければナラナイ
— `If-None-Match$h 内の条件は，
`If-Modified-Since$h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは，［
`If-None-Match$h を実装していない~~可能性もある古い`中継者$
］との相互運用目的に限られる。
◎
A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.
</p>

<div class="p">

<p>
受信者は、次のいずれかの場合には，
`If-Modified-Since$h ~headerを無視しなければナラナイ：
◎
A recipient MUST ignore the If-Modified-Since header field＼
</p>

<ul>
	<li>
受信された~header値が `HTTP-date$p として妥当でない。
◎
if the received field-value is not a valid HTTP-date, or＼
</li>
	<li>
要請~methodが `GET$m, `HEAD$m のいずれでもない。
◎
if the request method is neither GET nor HEAD.
</li>
</ul>
</div>

<p>
受信者は、
`If-Modified-Since$h ~header値の時刻印を，`生成元~server$の`時計$を通して解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Modified-Since field-value's timestamp in terms of the origin server's clock.
</p>

<div class="p">
<p>
`If-Modified-Since$h は、概して，次に挙げる別個な目的に利用される：
◎
If-Modified-Since is typically used for two distinct purposes:＼
</p>

<ul>
	<li>
(A)
`entity-tag$p を持たないような~cache済み`表現$を，効率的に更新する。
◎
1) to allow efficient updates of a cached representation that does not have an entity-tag and＼
</li>
	<li>
(B)
［
~web~traversalによる，`資源$への検索取得
］の対象範囲を，近過去に変更されたもののみに制限する。
◎
2) to limit the scope of a web traversal to resources that have recently changed.
</li>
</ul>

</div>

<div class="p">

<p>
上の (A) に利用される場合、~cacheは，概して，
`If-Modified-Since$h の~header値を`生成する$ときに［
~cache済み~messageの `Last-Modified$h ~header値
］を利用することになる。
この挙動は、次の事例において，最も相互運用-可能になる：
◎
When used for cache updates, a cache will typically use the value of the cached message's Last-Modified field to generate the field value of If-Modified-Since. This behavior is most interoperable for cases＼
</p>

<ul>
	<li>
`時計$の同期-に乏しいとき, または
◎
where clocks are poorly synchronized or＼
</li>
	<li>
~serverが，［
時刻印の正確な合致-のみを尊守する
］ことを選択したとき（［
`生成元~server$の`時計$が正された
］, または［
`表現$が~backupの~archiveから再~格納された
］ことに因り，
`Last-Modified$h 日時が “~~過去に戻る” ように出現する問題のために）。
◎
when the server has chosen to only honor exact timestamp matches (due to a problem with Last-Modified dates that appear to go "back in time" when the origin server's clock is corrected or a representation is restored from an archived backup).＼
</li>
</ul>

<p>
しかしながら，~cacheは、ときには，［
~cache済み~messageの `Date$h ~header
］, あるいは［
~messageを受信したときの局所的な時計による時刻などの，他の~data
］に基づいて，~header値を`生成する$こともある
— 特に，［
~cache済み~messageが `Last-Modified$h ~headerを包含しない
］ときに。
◎
However, caches occasionally generate the field value based on other data, such as the Date header field of the cached message or the local clock time that the message was received, particularly when the cached message does not contain a Last-Modified field.
</p>

</div>

<p>
上の (B) に利用される場合、~UAは，［
自前の局所的な時計, または
先立つ応答にて~serverから受信された `Date$h ~header
］に基づいて， `If-Modified-Since$h ~header値を`生成する$ことになる。
`生成元~server$が，［
`選定された表現$の `Last-Modified$h ~headerに基づく，時刻印の正確な合致-
］を選択した場合、［
~UAが，~data転送を［
指定された時区間~内に変更されたもの
］のみに制限する
］一助にはならなくなることになる。
◎
When used for limiting the scope of retrieval to a recent time window, a user agent will generate an If-Modified-Since field value based on either its own local clock or a Date header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified field will not be able to help the user agent limit its data transfers to only those changed during the specified window.
</p>

<div class="p">
<p>
`If-Modified-Since$h ~headerを受信した`生成元~server$は：
◎
An origin server that receives an If-Modified-Since header field＼
</p>

<ol>
	<li>
`~method$の遂行に先立って，その~header値に与えられた`前述の条件＠#condition-If-Modified-Since$を`評価-$するベキである。
◎
SHOULD evaluate the condition prior to performing the method (Section 5).＼
</li>
	<li>
条件が偽に評価された場合、要請された~methodを遂行するベキでない
— 代わりに，［［［
以前に~cacheされた応答を識別する／更新する
］ために有用になるような~metadata
］のみを内包する， `304$st 応答
］を`生成する$ベキである。
◎
The origin server SHOULD NOT perform the requested method if the selected representation's last modification date is earlier than or equal to the date provided in the field-value; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.
</li>
</ol>
</div>

<p>
`If-Modified-Since$h ~headerが受信された際の，~cacheの取扱いについての要件は、
`7234-4.3.2$rfc
にて定義される。
◎
Requirements on cache handling of a received If-Modified-Since header field are defined in Section 4.3.2 of [RFC7234].
</p>

		</section>
		<section id="section-3.4">
<h3 title="If-Unmodified-Since">3.4. `If-Unmodified-Since^h</h3>

<div class="p">
<p>
`If-Unmodified-Since^h ~headerは、`要請~method$を次による`条件付きに$する：
◎
The "If-Unmodified-Since" header field makes the request method conditional on＼
</p>

<ul id="condition-If-Unmodified-Since">
	<li>
`選定された表現$の最後の`改変~日時$は，`~header値$にて供された日時より近過去でない。
◎
the selected representation's last modification date being earlier than or equal to the date provided in the field-value.＼
</li>
</ul>

<p>
この~headerは、~UAが`表現$に対する `entity-tag$p を持たない所で， `If-Match$h と同じ目的を成遂げる。
◎
This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation.
</p>
</div>

<pre class="bnf">
`If-Unmodified-Since@p = `HTTP-date$p
</pre>

<div class="example">
<p>
用例：
◎
An example of the field is:
</p>

<pre class="lang-http">
If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</pre>
</div>

<p>
`If-Unmodified-Since^h ~headerの受信者は：
◎
↓</p>

<ul>
	<li>
要請が `If-Match$h ~headerも包含する場合は、
`If-Unmodified-Since$h を無視しなければナラナイ
— `If-Match$h 内の条件は，
`If-Unmodified-Since$h 内の条件より正確aな置換と見なされるので。
この 2 つが組合されるのは，［
`If-Match$h を実装していないかもしれない古い`中継者$
］との相互運用目的に限られる。
◎
A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.
</li>
	<li>
受信された~header値が妥当な `HTTP-date$p でない場合には、
`If-Unmodified-Since$h ~headerを無視しなければナラナイ。
◎
A recipient MUST ignore the If-Unmodified-Since header field if the received field-value is not a valid HTTP-date.
</li>
	<li>
`If-Unmodified-Since$h ~header値の時刻印を，`生成元~server$の`時計$を通して解釈しなければナラナイ。
◎
A recipient MUST interpret an If-Unmodified-Since field-value's timestamp in terms of the origin server's clock.
</li>
</ul>

<p>
`If-Unmodified-Since$hは、状態変更~method（例： `POST$m, `PUT$m, `DELETE$m ）と伴に最もよく利用される
— ［
その`表現$に `entity-tag$p を給さない`資源$
］上で，複数の~UAが並列的に動作し得るときの、偶発的な上書（すなわち， “`更新喪失$” 問題）を防止するために。
また、`安全~method$と伴にも利用できる
— `選定された表現$が，［
以前の要請に対する応答として，すでに（あるいは`部分的$に）格納されたもの
］に合致しないときは、要請を中止するために。
◎
If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity-tags with its representations (i.e., to prevent the "lost update" problem). It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.
</p>

<div class="p">

<p>
`If-Unmodified-Since$h ~headerを受信した`生成元~server$は：
◎
An origin server that receives an If-Unmodified-Since header field＼
</p>

<ol>
	<li>
`~method$の遂行に先立って，その~header値に与えられた`前述の条件＠#condition-If-Unmodified-Since$を`評価-$しなければナラナイ。
◎
MUST evaluate the condition prior to performing the method (Section 5).＼
</li>
	<li>
<p>
条件が偽に評価された場合、要請された~methodを遂行してはナラナイ
<!-- ↓％copy -->
— 代わりに，次のいずれかで応答しなければナラナイ：
◎
The origin server MUST NOT perform the requested method if the selected representation's last modification date is more recent than the date provided in the field-value; instead the origin server MUST respond with either a) the 412 (Precondition Failed) status code or＼
</p>
		<ul class="switch">
			<li>
<p>
`生成元~server$が［
状態~変更が要請されていて，その最終~状態が `~target資源$の現在の状態にすでに反映されている
］ことを検証yした場合（すなわち，~UAにより要請された変更はすでに成功したが、おそらく~UAが気づかないうちに，先立つ応答が失われたか, 他の~UAにより互換な変更が行われた）
⇒
いずれかの `2xx$st `状態s~code$で応答する。
◎
b) one of the 2xx (Successful) status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of that because the prior response message was lost or a compatible change was made by some other user agent).＼
</p>

<p>
この場合、その要請が［
同じ~UAにより為された~~直前の変更
］の重複であるものと検証yできない限り、応答~内に`検証子~header$を送信してはナラナイ。
◎
In the latter case, the origin server MUST NOT send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent.
</p>
			</li>
			<li>
他の場合
⇒
`状態s~code$ `412$st で応答する
◎
↑</li>
		</ul>
	</li>
</ol>

</div>

<p>
`If-Unmodified-Since$h
~headerは、格納-済み応答には適用-可能でないので，~cacheや`中継者$からは無視され得る。
<!-- ％copy -->
◎
The If-Unmodified-Since header field can be ignored by caches and intermediaries because it is not applicable to a stored response.
</p>

		</section>
		<section id="section-3.5">
<h3 title="If-Range">3.5. `If-Range^h</h3>

<p>
`If-Range$h ~headerは、
`If-Match$h や `If-Unmodified-Since$h に~~似るが，［［
検証子が合致しない
］場合には， `Range$h ~headerを無視する
］ように，受信者に指図するための、特別な`条件付き要請$の仕組みを供する。
合致しない場合、 `412$st 応答の代わりに，新たな，`選定された表現$が転送されることになる。
◎
The "If-Range" header field provides a special conditional request mechanism that is similar to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to ignore the Range header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a 412 (Precondition Failed) response. If-Range is defined in Section 3.2 of [RFC7233].
</p>

		</section>
	</section>
	<section id="section-4">
<h2 title="Status Code Definitions">4. 状態s~code定義</h2>

		<section id="section-4.1">
<h3 title="304 Not Modified">4.1. `304^st</h3>

<p>
`状態s~code$ `304$st は、［
条件付き `GET$m ／ `HEAD$m 要請が受信された
］こと, および［
仮に［
その条件が偽に`評価-$される事実がなかった
］とするならば， `200$st で応答することになる
］ことを指示する。
言い換えれば，~serverにとって`~target資源$の`表現$を転送する必要はない
— 何故なら、その要請は，［
その要請を`条件付きに$した~clientが，妥当な表現をすでに持っている
］ことを指示するので。
すなわち，~serverは、［
~clientに格納-済みの その表現を `200$st 応答の`~payload$であったかのように，用立ててもらう
］べく，~clientを~redirectしている。
◎
The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false. In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the payload of a 200 (OK) response.
</p>

<p>
`304$st 応答を`生成する$~serverは、次の~headerのうち，［
同じ要請に対し `200$st 応答にて送信されることになるもの
］すべてを`生成し$なければナラナイ
⇒
`Cache-Control$h,
`Content-Location$h,
`Date$h,
`ETag$h,
`Expires$h,
`Vary$h
◎
The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.
</p>

<p>
`304$st0 応答の目標は，［
受信者がすでに 1 つ以上の~cache済み`表現$を持っている
］ときに転送する情報を最小限にすることなので、送信者は，上に挙げた~header以外の`表現~metadata$を`生成する$ベキでない
— その種の~metadataが~cache更新を手引きする目的で存在するのでない限り（例：
`Last-Modified$h は、応答が `ETag$h ~headerを持たない場合には，有用になり得る）。
◎
Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).
</p>

<p>
`304$st0 応答を受信した~cacheに課される要件は、 `7234-4.3.4$rfc にて定義される。
`条件付き要請$が［
自前の~cacheを持ち, 共用~proxyに向けて条件付き `GET$m を送信する~UA
］などの，`外方$~clientにより出生された場合、~proxyは，
`304$st0 応答をその~clientに向けて回送するベキである。
◎
Requirements on a cache that receives a 304 response are defined in Section 4.3.4 of [RFC7234]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy SHOULD forward the 304 response to that client.
</p>

<p>
`304$st0 応答は、 `message-body$p を包含できない
— それは、常に，`~header節$を終わらせる最初の空~行lで終了される。
◎
A 304 response cannot contain a message-body; it is always terminated by the first empty line after the header fields.
</p>

		</section>
		<section id="section-4.2">
<h3 title="412 Precondition Failed">4.2. `412^st</h3>

<p>
`状態s~code$ `412$st は、［
各種~要請~headerにて与えられた条件のうち 1 つ以上が，~server上で~testされたときに偽に`評価-$された
］ことを指示する。
この応答~状態s~codeにより、~clientは，現在の`資源$の状態（資源の現在の`表現$と~metadata）に対し，`事前条件$を設置できるようになる
— したがって、`~target資源$が期待されない状態にある場合には，`要請~method$は適用されなくなる。
◎
The 412 (Precondition Failed) status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server. This response code allows the client to place preconditions on the current resource state (its current representations and metadata) and, thus, prevent the request method from being applied if the target resource is in an unexpected state.
</p>

		</section>
	</section>
	<section id="section-5">
<h2 title="Evaluation">5. 評価</h2>

<div class="p">

<p>
以下により除外されるときを除いて、受信者である［
~cache／`生成元~server$
］は，［
自身による通常の要請~検査を成功裡に遂行した後, かつ
`要請~method$に結付けられた動作を遂行する~~直前
］に，受信された要請の`事前条件$を評価しなければナラナイ。
◎
Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would perform the action associated with the request method.＼
</p>

<p>
~serverは：
◎
＼</p>

<ul>
	<li>
［［
それらの条件を伴わない，同じ要請
］に対する応答が `2xx$st, `412$st 以外の`状態s~code$を持つことになる
］場合には，受信されたすべての`事前条件$を無視しなければナラナイ。
言い換えれば，~redirectや失敗は、`条件付き要請$内の`事前条件$の評価よりも優先される。
◎
A server MUST ignore all received preconditions if its response to the same request without those conditions would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed). In other words, redirects and failures take precedence over the evaluation of preconditions in conditional requests.
</li>
	<li>
［
`~target資源$に対する`生成元~server$でない, かつ
`~target資源$~上の要請に対する~cacheとしても動作し得ない
］ならば、この仕様で定義される`条件付き要請~header$を，評価してはナラナイ
— 要請を回送するときは，それらの~headerも回送しなければナラナイ。
それらの~headerを生成した~clientは、［
現在の`表現$を供せる~serverにより，それらが評価される
］ことを意図しているので。
◎
A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation.＼
</li>
	<li>
［［［
`CONNECT$m, `OPTIONS$m, `TRACE$m 
］などの，［
`選定された表現$の選定や改変
］を孕まない`要請~method$
］に伴って受信された，`条件付き要請~header$
］のうち，この仕様で定義されるものは、無視しなければナラナイ。
◎
Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.
</li>
</ul>

</div>

<p>
~HTTPに対する拡張により定義される条件付き要請~headerは、［
すべての受信者 ／
一般的な`~target資源$の状態 ／
`資源$の~group
］に対し，条件を設置することもある。
一例として， WebDAV における `If$h ~headerは、［
`~lock$など，複数の資源の様々な側面
］に対し，要請を`条件付きに$し得る
— 受信者がその~headerを解し, かつ実装するならば。
◎
Conditional request header fields that are defined by extensions to HTTP might place conditions on all recipients, on the state of the target resource in general, or on a group of resources. For instance, the "If" header field in WebDAV can make a request conditional on various aspects of multiple resources, such as locks, if the recipient understands and implements that field ([RFC4918], Section 10.4).
</p>

<p>
`条件付き要請~header$は，（ `HEAD$m と `GET$m との意味論の整合性を保つため）
`HEAD$m ~methodと伴用できるものと定義されるが、条件付き `HEAD$m を送信することに~~利点はない
— 何故なら、成功裡~応答は `304$st 応答と~~大体~同じ~sizeになり， `412$st 応答よりも有用なので。
◎
Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a 304 (Not Modified) response and more useful than a 412 (Precondition Failed) response.
</p>

	</section>
	<section id="section-6">
<h2 title="Precedence">6. 優先順</h2>

<div class="p">
<p>
要請~内に`条件付き要請~header$が~~複数~在る場合、それらの~headerが`評価-$される順序が重要になる。
実施においては、この文書にて定義される各種~headerは、次の~~理由から，一貫して［
ある単独の論理的~順序
］で実装されている：
◎
When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since＼
</p>

<ul>
	<li>
“`更新喪失$” のための`事前条件$は、`~cache検証$よりも厳密な要件を備える。
◎
"lost update" preconditions have more strict requirements than cache validation,＼
</li>
	<li>
検証された~cacheは、`部分的~応答$よりも効率的である。
◎
a validated cache is more efficient than a partial response, and＼
</li>
	<li>
`entity-tag$p は、日時~検証子よりも正確aと~~見做されている。
◎
entity tags are presumed to be more accurate than date validators.
</li>
</ul>

</div>

<p>
受信者である［
~cache／`生成元~server$
］は、要請における［
この仕様にて定義される各種`事前条件$
］を，次の順序で`評価-$しなければナラナイ：
◎
A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order:
</p>

<p class="trans-note">【
以下における “応答する” は、そこで評価~~手続きを終えることも意味する。
】</p>

<ol>
	<li>
<p>
受信者が`生成元~server$であるならば、要請に `If-Match$h が在るかどうかに応じて：
◎
↓</p>
		<dl class="switch">
			<dt>在る場合：</dt>
			<dd>
［
その事前条件が偽に評価される
］ならば：
`412$st で応答する
— 状態変更~要請がすでに成功したことを決定できる（`3.1$secを見よ）のでない限り。
◎
1. When recipient is the origin server and If-Match is present, evaluate the If-Match precondition: 
◎
* if true, continue to step 3
◎
* if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 3.1)
</dd>

			<dt>無い場合：</dt>
			<dd>
［
`If-Unmodified-Since$h が在って，その事前条件が偽に評価される
］ならば：
`412$st で応答する
— 状態変更~要請がすでに成功したことを決定できる（`3.4$secを見よ）のでない限り。
◎
2. When recipient is the origin server, If-Match is not present, and If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition:
◎
* if true, continue to step 3
◎
* if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 3.4)
</dd>
		</dl>
	</li>
	<li>
<p>
要請に `If-None-Match$h が在るかどうかに応じて：
</p>

		<dl class="switch">
			<dt>在る場合：</dt>
			<dd>
［
その事前条件が偽に評価される
］ならば：［
`GET$m, `HEAD$m に対しては `304$st ／
他の~methodに対しては `412$st
］で応答する。
◎
3. When If-None-Match is present, evaluate the If-None-Match precondition:
◎
* if true, continue to step 5
◎
* if false for GET/HEAD, respond 304 (Not Modified)
◎
* if false for other methods, respond 412 (Precondition Failed)
</dd>
			<dt>無い場合：</dt>
			<dd>
［
~methodは `GET$m または `HEAD$m である
］, かつ［
`If-Modified-Since$h が在って,
その事前条件が偽に評価される
］ならば：
`304$st で応答する。
◎
4. When the method is GET or HEAD, If-None-Match is not present, and If-Modified-Since is present, evaluate the If-Modified-Since precondition:
◎
* if true, continue to step 5
◎
* if false, respond 304 (Not Modified)
</dd>
		</dl>
	</li>
	<li>
［
~methodは `GET$m である
］, かつ［
`Range$h および `If-Range$h が在る
］, かつ［
`If-Range$h 事前条件を評価したとき 検証子が合致する
【真に評価される】
］, かつ［
`Range$h 指定が`選定された表現$に適用-可能である
］ならば：
`206$st で応答する。
◎
5. When the method is GET and both Range and If-Range are present, evaluate the If-Range precondition:
◎
* if the validator matches and the Range specification is applicable to the selected representation, respond 206 (Partial Content) [RFC7233]
</li>
	<li>
すべての条件は満たされたので、要請された動作を遂行した上で，その成功／失敗に則って応答する。
◎
6. Otherwise,
◎
* all conditions are met, so perform the requested action and respond according to its success or failure.
</li>
</ol>

<p>
追加的な条件付き要請~headerを定義するような，`~HTTP11$に対する拡張は、［［
この文書にて定義されるもの, および
実施において見出され得る他の条件付き~header
］と，そのような~headerを`評価-$するときの順序~関係
］に関する，自前の期待を定義する~OUGHT。
◎
Any extension to HTTP/1.1 that defines additional conditional request header fields ought to define its own expectations regarding the order for evaluating such fields in relation to those defined in this document and other conditionals that might be found in practice.
</p>

	</section>
	<section id="section-7">
<h2 title="IANA Considerations">7. ~IANA 考慮点</h2>

		<section id="section-7.1">
<h3 title="Status Code Registration">7.1. 状態s~code登録</h3>

<p>
`~HTTP状態s~code~registry＠~IANA-a/http-status-codes$
は、次の登録により更新された：
◎
The "Hypertext Transfer Protocol (HTTP) Status Code Registry" located at &lt;http://www.iana.org/assignments/http-status-codes&gt; has been updated with the registrations below:
</p>

<div>

<ul><li>`304$st
</li><li>`412$st
</li></ul>

<pre lang="en" class="_en">
   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | Section 4.1 |
   | 412   | Precondition Failed | Section 4.2 |
   +-------+---------------------+-------------+
</pre>

</div>

		</section>
		<section id="section-7.2">
<h3 title="Header Field Registration">7.2. ~header登録</h3>

<p>
以下の~HTTP~headerが、
`Message Headers＠~IANA-a/message-headers/$
にて保守される，~registryに登録された。
◎
HTTP header fields are registered within the "Message Headers" registry maintained at &lt;http://www.iana.org/assignments/message-headers/&gt;.
</p>

<p>
この文書は、次の各種~HTTP~headerを定義する。
それに伴い、それらに結付けられた~registryの~entryは，以下の恒久的~登録に則って更新された（ `BCP90$r を見よ）：
◎
This document defines the following HTTP header fields, so their associated registry entries have been updated according to the permanent registrations below (see [BCP90]):
</p>

<div>
<table><thead><tr><td>~header名
<td>~protocol
<td>位置付け
</thead>

<tbody><tr><td>`ETag$h
<td> http
<td>standard

<tr><td>`If-Match$h
<td> http
<td>standard

<tr><td>`If-Modified-Since$h
<td> http
<td>standard

<tr><td>`If-None-Match$h
<td> http
<td>standard

<tr><td>`If-Unmodified-Since$h
<td> http
<td>standard

<tr><td>`Last-Modified$h
<td> http
<td>standard

</tbody></table>

<pre lang="en" class="_en">
   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | Section 2.3 |
   | If-Match            | http     | standard | Section 3.1 |
   | If-Modified-Since   | http     | standard | Section 3.3 |
   | If-None-Match       | http     | standard | Section 3.2 |
   | If-Unmodified-Since | http     | standard | Section 3.4 |
   | Last-Modified       | http     | standard | Section 2.2 |
   +---------------------+----------+----------+-------------+
</pre>

</div>

<p>
変更管理者は~IETF-orgである。
◎
The change controller is: "IETF (iesg@ietf.org) - Internet Engineering Task Force".
</p>

		</section>
	</section>
	<section id="section-8">
<h2 title="Security Considerations">8. ~securityの考慮点</h2>

<p>
この節は、［
開発者／情報~provider／利用者
］向けに，
~HTTP `条件付き要請$の仕組みに特有な，既知な~securityの懸念を伝えることを~~意図している。
より一般的な~securityの考慮点は、
~HTTP~messaging `7230-9$rfc, および
~HTTP意味論 `7231-9$rfc にて取組まれている。
◎
This section is meant to inform developers, information providers, and users of known security concerns specific to the HTTP conditional request mechanisms. More general security considerations are addressed in HTTP "Message Syntax and Routing" [RFC7230] and "Semantics and Content" [RFC7231].
</p>

<p>
この仕様により定義される検証子は、［
`表現$の妥当性 ／
悪意的な変更に抗する防御 ／
中間者~攻撃の検出-
］を確保するものとして，意図されたものではない。
それらは最良でも、すべての参加者が順調に挙動する下で［
より効率的な~cache更新を可能化したり, 同時的な書込nをより適化する
］だけである。
最悪でも、条件は失敗し，~clientは［［
条件付きでない要請による~HTTP交換
］以上に有害にはならない，応答
］を受信するだけである。
◎
The validators defined by this specification are not intended to ensure the validity of a representation, guard against malicious changes, or detect man-in-the-middle attacks. At best, they enable more efficient cache updates and optimistic concurrent writes when all participants are behaving nicely. At worst, the conditions will fail and the client will receive a response that is no more harmful than an HTTP exchange without conditional requests.
</p>

<p>
`entity-tag$p は、~privacy~riskを高めるように濫用もされ得る。
例えば，~siteが、［
利用者や~UA間で一意, かつ
意味論的に妥当でない
］ような `entity-tag$p を故意に構築し, ［
~cache可能かつ`鮮度~時間$の長い，応答
］内に送信した上で，［
利用者／~UAを再~識別する手段として，今後の`条件付き要請$からその `entity-tag$p を読取る
］ことも，あり得る。
そのように識別する~tagは、［
~UAが元の~cache~entryを維持する限り，持続する
］ような，識別子になるであろう。
`表現$を~cacheする~UAは、利用者が，［
格納されている~cookieを~clearしたり，私的~閲覧~modeに変える
］などにより，~privacyを保守する動作を遂行したときには、その~cacheが
~clearされる／置換される
ことを確保する~OUGHT。
◎
An entity-tag can be abused in ways that create privacy risks. For example, a site might deliberately construct a semantically invalid entity-tag that is unique to the user or user agent, send it in a cacheable response with a long freshness time, and then read that entity-tag in later conditional requests as a means of re-identifying that user or user agent. Such an identifying tag would become a persistent identifier for as long as the user agent retained the original cache entry. User agents that cache representations ought to ensure that the cache is cleared or replaced whenever the user performs privacy-maintaining actions, such as clearing stored cookies or changing to a private browsing mode.
</p>

	</section>
	<section id="section-9">
<h2 title="Acknowledgments">9. 謝辞</h2>

<p class="trans-note">【
この節の内容は、
`RFC723X 共通~page＠~723X#acknowledgments$
に移譲。
】
◎
See Section 10 of [RFC7230].
</p>

	</section>
	<section id="section-10">
<h2 title="References">10. 参照文献</h2>

<p class="trans-note">【
この節の内容は、
`RFC723X 共通~page＠~723X#references$
に移譲。
】</p>

	</section>
	<section id="appendix-A">
<h2 title="Appendix A. Changes from RFC 2616">付録 A. RFC 2616 からの変更点</h2>

<ul>
	<li>
検証子の弱さの定義は、拡げられ, 明確化された。
（`2.1$sec）
◎
The definition of validator weakness has been expanded and clarified. (Section 2.1)
</li>
	<li>
`弱い$ `entity-tag$p は、今や，`範囲~要請$を除くすべての要請にて許容される。
（`2.1$sec, `3.2$sec）
◎
Weak entity-tags are now allowed in all requests except range requests. (Sections 2.1 and 3.2)
</li>
	<li>
`ETag^h ~header ~ABNFは、~escapingの~~問題を避けるため，
`quoted-string^p を利用しないように変更された。
加えて、今や `SP$P も許容されない
【この一文は、`5162$errataによる追加（ Verified: 2017-10-20 ）】
【！ Furthermore, it now disallows the space character.】
。
（`2.3$sec）
◎
The ETag header field ABNF has been changed to not use quoted-string, thus avoiding escaping issues. (Section 2.3)
</li>
	<li>
`選定された表現$に対する `entity-tag$p を供するため，
`ETag$h が定義され、それに伴い，様々な状況（ `PUT$m  に対する応答など）において，それが何に適用されるかを明確化した。
（`2.3$sec）
◎
ETag is defined to provide an entity tag for the selected representation, thereby clarifying what it applies to in various situations (such as a PUT response). (Section 2.3)
</li>
	<li>
`条件付き要請$を評価する際の優先順が定義された。
（`6$sec）
◎
The precedence for evaluation of conditional requests has been defined. (Section 6)
</li>
</ul>

	</section>
	<section id="appendix-B">
<h2 title="Appendix B. Imported ABNF">付録 B. 取込まれた~ABNF</h2>

	</section>
	<section id="appendix-C">
<h2 title="Appendix C. Collected ABNF" data-cycling=".bnf">付録 C. 総集的 ~ABNF</h2>

<p class="trans-note">【
これらの節の内容は、
`総集的~ABNF＠~723Xabnf#abnf-7232$
に移譲。
】</p>

	</section>
</main></div>
