<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>CSS の値と単位 — CSS Values and Units Module Level 4 （日本語訳）</title>

<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-css.css" type="text/css" />

<style>

samp {
	margin-left: 0.6em;
	margin-right: 0.6em;
	white-space: nowrap;
}

.grammar {
	font-family: monospace0, monospace;
/*	font-weight: normal;*/
	color: #005a9c;
	color: #0011A0;
}


.math-matrix td, 
.math-matrix th {
	min-width: 5em;
	text-align: center;
	white-space: nowrap;
}

@supports (display: grid) and (display: contents) {

#propvalues {
	min-width: 30em;
}

#propvalues tr {
	grid-template-areas:
		"prop 値定義"
		"prop 値例"
	;
	grid-template-columns: 12em 1fr;
}

#propvalues tr > *:nth-child(1) {
	grid-area: prop;
	border-left: none;
}

#propvalues tr > *:nth-child(2) {
	grid-area: 値定義;
}

#propvalues tr > *:nth-child(3) {
	grid-area: 値例;
	background: var(--bg-color-1);
}

}
</style>


<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

Util.ready = function(){
	var source_data = {
		generate: expand
	};
	Util.switchWordsInit(source_data);
}

function expand(){
	const class_map = this.class_map;
	const tag_map = this.tag_map;
	var link_map = this.link_map;

	return this.html.replace(
		/%[\w\-~一-鿆あ-ん]+|`(.*?)([$@^])(\w*)/g,
		create_html
	);

	function create_html(match, key, indicator, klass){
if(!key) {//%
	return `<var>${match.slice(1)}</var>`;
}

var text = key;
var href = '';

switch(klass){
case 'r':
	text = `[${key}]`;
	href = `#biblio-${key.toLowerCase()}`;
	break;
case 'tp': // property value type
	text = `&lt;'<code class="property">${key}</code>'&gt;`
	href = link_map[`p.${key}`];
	break;
case 'f':
	const n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
	} else {
		text = `${key}()`;
	}
	break;
case 't':
	text = `&lt;${key}&gt;`;
	key = key.replace(/\s?\[.+/, '');
	break;
case 'at':
	text = `@${key}`;
	break;
case 'l':
	text = `"<code class="literal">${text}</code>"`;
	break;
case 'U':
	text = `U+${key}`
	break;
case 'en':
	return `<span lang="en-x-a0">${key}</span>`
	break;
case 'issue':
	href = `~CSSissue/${key}`;
	text = `課題 #${key}`;
	break;
}

let tag = tag_map[klass];
if(tag) {
	let classname = class_map[klass];
	classname = classname ? ` class="${classname}"` : '';
	text = `<${tag}${classname}>${text}</${tag}>`;
}

if(indicator !== '^'){
	href = link_map[ klass ? `${klass}.${key}` : key ] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '$':
		text = `<a href="${href}">${text}</a>`;
		break;
	case '@':
		text = `<dfn id="${href.slice(1)}">${text}</dfn>`;
		break;
	}
}

return text;

	}
}
</script>

<script type="text/plain" id="_source_data">


●●options

spec_title:CSS Values and Units Module Level 4
spec_date:2020-07-05
trans_update:2020-05-30
source_checked:200124
page_state_key:CSS
original_url:https://drafts.csswg.org/css-values-4/
spec_status:ED
ref_id_prefix:biblio-
ref_id_lowercase:true
conformance:css
copyright:2020,permissive
trans_1st_pub:2012-07-17


●●class_map
p:property
d:descriptor
css:css
tp:type
t:type
g:grammar
u:unit
at:at-rule
f:func
v:value
jv:js-value
e:element
a:attr
U:code-point
cn:cp-name

●●tag_map
p:code
d:code
t:var
tp:var
at:code
css:code
v:code
e:code
a:code
f:code
g:code
u:code
c:code
U:span
cn:span
i:i
em:em
jv:code
I:code


●●words_table1

0N:0⁻
0P:0⁺
NaN:NaN
vA:<var>A</var>
vB:<var>B</var>
vC:<var>C</var>
AMP:&amp;
autoS:auto

●●words_table


	●単位／値
pixel::::ピクセル
	`px^u:pixel
Hertz::::ヘルツ
KiloHertz::::キロヘルツ
inch::::インチ
計量法:metrics:~
計量:measurement:~
	計測結果:measurement
計測:measure:~
pica::::パイカ
hash::::ハッシュ
feet::::フィート
milli:milli-:ミリ

centi:centi-:::センチ
meter::::メートル
	millimeter
	millimeters
	quarter-millimeters
	quarter-millimeter
	centimeter

radian::::ラジアン
grade::::グラード
gradian::::グラジアン
gon::::ゴン
point::::ポイント
dot::::ドット
red:
green:
blue:
alpha:

単位:unit::~
anchor::基準
算出法:computation:~
数値:number::~
実数:number::~
	実数:real number
小数部:fractional component::~
数量:quantity:~
数量-:numeric:~
	数量-値をとる:numeric-valued
数的:numeric:~
数量的:numerical:~
視野角:visual angle:~
数字:digit:~
時間長:duration:~
時間:time:~

音高:sound pitch:~
低音域:bass sound:~
高音域:treble sound:~

gradient::::グラデーション
	graphicな:graphical
関数式:function::~
関数-:functional::~
画素:pixel::~
解像度:resolution::~
方位角:bearing angle::~

周波数:frequency::~
二次元の:2D::~
三次元の:3D::~
多次元:N-dimensional::~
視聴距離:viewing distance::~
密度:density::~
固定比率:fixed ratio:~
円:circle:~
比率:ratio::~

	絶対~化:absolutize
	度:degrees
	単位を外した:cast down
	継承されない:non-inherited
	解決し直す:re-resolve
	別の解決-法:alternate resolution mechanics
	検査-法:checking
	範囲~外:out-of-range

	●算術／数式
正準化-:canonicalize::~
精度:precision::~
拡縮-:scale::~
縮尺:scale::~
拡縮ng:scaling::拡縮
基準:reference:~
基準に:refer:~
	~~基準に:against
	に対して／に基づくように:against
近似-:approximate:~
近似:approximation:~
	約:approximately
	約:approximately equal to
開区間:open interval::~
閉区間:closed interval::~

	閉区間を成す:closed
	閉区間を成す:open

切詰ng:clamping::切り詰め
切詰める:clampする::切り詰める
切詰めら:clampさ::切り詰めら
切詰めた:clampした::切り詰めた
丸めら:roundさ::~
丸める:roundする::~
丸めた:roundした::~
丸ng:rounding::丸め

代数的:algebraic::~
代数:algebra::~
算術:arithmetic::~
簡約-:reduce::~

係数:factor:~
	±∞:infinities
中央-:central::~
	最小:min
	最大:max
最小v:<var>MIN</var>:<var>最小</var>
最大v:<var>MAX</var>:<var>最大</var>
値v:<var>VAL</var>:<var>値</var>

値a:<var>V</var><sub>a</sub>
値b:<var>V</var><sub>b</sub>
	%結果値:<var>V<sub>result</sub>

分解-:decompose::~
	分解-法:decomposing
累積-:accumulate::~
累積:accumulation::~
結合-:combine::~
結合n:combination::結合
補間-:interpolate::~
補間:interpolation::~
easing:
加重平均:weighted sum::~
平均:average:~
外挿-:extrapolate::~
外挿:extrapolation::~
中間:intermediate:~
行列:matrix::~
差分:delta::~
math:
calc:
数学的:mathematical:~
数学:mathematics:~
数学体系:mathematical system:~
式:expression::~
下位式:sub-expression::~
数式:math expression::~
数値式:numeric expression::~
乗算-:multiply::~
乗算:multiplication::~
乗算的-:multiplicative::乗算
乗算済み:premultiplied::~
逆数に:invert::~
逆数:reciprocal::~
除算-:divide::~
除算:division::~
	0 による除算:division-by-zero
加算-:add::~
加算:addition::~
加法的:additive::~
減算-:subtract::~
減算:subtraction::~
反数に:negate::~
反数化:negation::~
総和:sum::~
積:product::~
可換:commutative::~
分配-:distribute:~
計算式:calculation:~
	予め計算-済み:pre-calculated
演算子:operator::~
IEEE-754:
有符号:signed::~
無符号:unsigned::~
符号n:sign::正負
	同じ符号の ±∞ :appropriate infinity
	符号nが一致する:are positive or both are negative
	符号nが一致しない:opposite sides of zero
換算-:convert:~
	~~換算-:relate:~
	~~換算法:relating
	等しい:equal
剰余:modulus::~
段差:step::~
三角-:trigonometric::~
	三角-:trig
二進-:binary:~
浮動小数点:floating-point:~
対数:logarithm:~
	対数:log
	対数~化:logarithmed
底e:base:底
指数-:exponential:~
指数:exponent:~
二乗:square:~
	二乗:squaring
平方根:square-root:~
三乗根:cube-root:~
逆-:inverse:~
冪乗:power::~
	〜乗:raising A to the power of B
	累乗
vector::::ベクター
	-:extreme
漸近:asymptote:~
漸近的:asymptotic:~
策:strategy::~
退化な:degenerateな:退化した
正なら:positiveなら:~
負なら:negativeなら:~
分子:numerator:~
分母:denominator:~
線形:linear::~

	丸めと剰余:stepped-value／:stepped value

	∞
	〜の 2 乗:²
	〜の 3 乗:³
	^i:Sum
	^i:Product
	^i:Invert
	^i:Negate
	^i:Min
	^i:Cos

	量:amount
	~~相殺-:cancel-out
	~~相殺-:canceling
	奇数:odd integer
	偶数:-
	偶数:even
	奇数:odd
	以下:less than or equal to
	2 つある場合は〜近い方:halfway between adjacent 〜 towards
	逆算-:reverse the math
	“逆”:"arc" or "inverse"
	ごく近い:very close
	かけ離れ:very different
	巨大な:very large
	との差が〜の整数倍:〜and all values a multiple
	絶対~値:absolute difference from 0
	差（絶対~値として）:absolute difference
	差が等しい:both have an equal difference (A is exactly between the two values)
	整数倍:whole number of
	整数倍:multiple of
	整数~倍:integer multiple
	丸めた結果〜減算した結果:the difference between A
	円周率:ratio of a circle’s circumference to its diameter
	以上または以下:above or below
	〜 以上 〜 未満:[〜, 〜)
	10 進表記における桁数:count the number of digit
	~bit数:counting the number of bits
	^i:e
	^i:π
	終端点:endpoint
	中間点:halfway point
	中間点:halfway-through

	●構文
percent::::パーセント
backslash::::バックスラッシュ
ampersand::::アンパサンド
slash::::スラッシュ
space::::スペース
asterisk::::アスタリスク
comma::::カンマ
dash:
	空白:white space
二重:double::~
一重:single::~
縦線:bar::~
改行文字:newline::~
	引用符で括られた／引用符~付き:quoted
角括弧:square bracket::~
角括弧付き:bracketed::~
	角括弧で括られ:bracketed
波括弧:curly braces::~
山括弧:angle bracket::~
丸括弧:parenthesis::~
	丸括弧:parentheses
	丸括弧:parenthesized 〜
	左~丸括弧:left parenthesis
	左~丸括弧:open parenthesis
	右~丸括弧:right parenthesis
	右~丸括弧:close parenthesis
	記号:mark／:sign
	10 進数:decimal
	16 進数:hexadecimal
	~literalに:literally
	~escape法:escaping
	class:group
	グループ化:grouping
alphabet:::アルファベット
	alphabet順:alphabetical
attr:
量指定子:multiplier::~
修飾子:modifier::~
非末端型:non-terminal::~
末端:terminal::~
	項:term
	百分率hint:percent hint:百分率 hint:百分率ヒント
大小:case::~
大小法:casing:~
大小変換:casing::~
文字大小比較:case-sensitivity::文字大小の区別
	常に文字大小区別になる:all the case-sensitivity that implies
	codepoint
	構文解析-時:parsing
	識別:identifying

繰返n:repetition:繰り返し
	構文単位:type, word, or group
結合子:combinator::~
文:statement::~
	並べて:alongside

貪欲:greedy:~
	greedily
完結-:complete:~
	予約-済み:reserved
省略可能:optional:~
選択肢:option:~
排他的選択肢:alternative:~
相互排他的:mutually exclusive:排他的
剥いだ:stripした:~

	分類:category
	分類-:
	書式:formatted
	括っている／括る:wrapper

	区切られ:delimited
	区切られた:separated
	区切る:separates
	区切りの:-separated
	現れる:appear
	出現:occurrences
	出現:occur
	逆にする:reverse
	並び:sequence
	一連の:sequence
	~~素の:bare
	連結-:join
	~~細切れ:piecemeal
	そのまま:literal
	-:trim
	^f:attr
	名前空間~付き:namespaced
	無い:do not contain
	算出d値:computed-value
	`ident-token$t:ident
	欠落して:missing
	最も近い:nearest
	最も近い:closest
	近い:closer
	な方を:whichever of
	小さい方:smallest
	小さい方:smaller
	大きい方:larger
	合間に入る:between
	ずらし:shifted
	入るよう:bring／:bringing

	●layout / typeset
	size:width and height／:widths and heights
table::::テーブル
marker::::マーカ
	長さの様なもの:length-like
高さ:height:~
	〜幅:wide
	〜~~高さ:tall
	縦長:tall
	横長:wide
横:horizontal::~
縦:vertical::~
植字-:typeset::~
送幅:advance measure::送り幅
	送幅:advance
行高:line height::~
	行:row
正立:upright::~
glyph::::グリフ
cell:
col:column
row:
斜字体:italic::~
通常体:normal::~
Latin:
x-:
cap-:
	~x-高さ:x-height
	~cap-高さ:cap-height
半角:narrow::~
全角:fullwidth::~
表語文字:ideographic::~
等幅:monospace::~
均衡幅:proportional::~
大字:capital letters:大文字
typographic::::タイポグラフィック
serif:
ascender::::アセンダ
descender::::ディセンダ
ascent::::アセント
限界:bounding::~
埋める:fillする:~
	整形-法:formatting
収まる:fitする:~

	占める:take up

	●幾何
変形-:transform::~
並進-:translate::~
	左上隅:top left corner
	~~移動:travel
	~~移動:between an element’s starting and ending positions
	対頂線:the main diagonal
	各辺の:side
	小さくなる get smaller
	わずかに大きく:slightly greater
	点:point
	離れて:further away move
	元位置:starting point
	X 軸:X-axis
	時計回りに同様になる:and so on around the circle

	●CSS
toggle::::トグル
基底線:baseline::~
全域:wide:~
遷移:transition::~
色:color::~
代用-:substitute::~
代用:substitution::~

	●仕様
	〜下:at risk
後継版:successor:~
	参考:informative
	位置により多義的になる:positionally-ambiguous
	暗黙に:implied
	~~不明瞭:less clear
自明:trivial:~
複雑さ:complication:~
複雑化-:complicate:複雑に
複雑:complicated:~
	複階的なので:complexities
理論的:theoretical:~
理論上は:theoreticalには:~
一般用の:general-purpose:~
	汎用に:generically
不可能:impossible:~
	アリな所すべてで:extent possible
簡便さ:convenience:~
不便:inconvenient:~
一般概念:generic notion:~
適度:reasonable:~
	reasonably
	~~適する:reasonable:~
	ちょうど／片方だけ:exact に
	単純~化:simplification／simplify
	単純~性:simplicity
名目上の:nominalな:~
	混同:confusion
不用意:accidental:~
	実際には:actually
自由:free:~
方策:strategy:~
	難く:hard
理想上は:idealには:~
現実世界:real-world:~
現実の:reality:~
乖離:divergence:~
希:rare:~
違法:illegal:~
hack::::ハック
許容d:allowed:許容
指名-:designate:指定
定義済み:pre-defined:~
定義表:definition table:~
依存性:dependency:~
関係付ける:relateする:~
拡張p:expansion:拡張
緩めら:relaxさ:~
勝つ:winする:~
表記-:denote:~
壊す:breakする:~
壊して:breakして:~
punt::先送り
変種:variation:~
競合-:conflict:~
読易い:readableな:読み易い
書直して:rewriteして:書き直して
	読んで／読める-:read
	記され:written
	書く:write
	書く:written
	書ける／書いた:write
	書ける:written
	書いた時点:At the time of writing
	書き出す:writing out
周知:well-known:~
規定-:dictate:~
分岐-:diverge:~
定期的:regular:~
壊さな:breakしな:~
調査-:study:~
賭ける:gambleする:~

	~~機能上は:Functionality-wise
	制限されない:unlimited
	~~制限を~~緩める:make them any less binding
	広く:wide
	であっても:still
	~~理由:because
	別法として:Alternately
	誤り:mistakes
	~~極端さ:eccentricities
	~~価するほど十分:worth
	~~価するほど十分:enough
	明らか:obvious
	足る:sufficiently
	ごく少数に限られ:sufficiently few
	~~形に:fashion
	-:You
	-:occasional point
	一方で:whilst
	すなわち:that is
	すなわち:meaning
	〜種の:classes of
	さもなければ:otherwise／:or else
	〜を除いて:otherwise
	別として:aside from
	が、:altho
	厄介の元:troublesome
	にもかかわらず:despite
	少なからずある:not uncommon
	できなくする:prevent
	惑わす:confusing
	答え:answer
	-:realm
	いずれにせよ:either
	そのままに:leaving the 〜 alone
	何に基づくのか:provenance
	-:indeed
	かまわない:fine
	戻って:again
	日が浅い:new
	ほぼ確実に:almost certain
	作者:you
	見受けられる:it appears to be that
	点:matter
	どのみち:anyway
	見込まれ:likely
	選ばれ:chosen
	常用されない:corner
	〜な限り:extent
	~~隅々まで:eagerly
	編集者:I
	能力がある:capable of
	通例の〜と同じく:as usual
	直感的でない:unintuitive
	一目では:at first glance
	まったく:perfectly
	主として:mostly

	局所~化:localize
	〜に関係する:-related
	覆す:breaking
	存在しない:non-existent
	許容し得る:allowable
	できるように:allow
	~~意図で:meant
	見よ:check
	間違っている:wrong-
	突然／いきなり:suddenly
	〜したい:want
	として与えられた:state
	もたらす:create／cause
	編集時:editting
	余計:excess
	-:find
	必要に応じて:as needed
	該当:claim
	未だ充足されていない:unfulfilled
	~~借用:cribbing
	追跡するのが難しく:hard-to-track-down
	から免れる:sidesteps
	悩まされ:suffer
	作者にとって:leaving you with
	沿わない:clashing
	仕事を成す:work out
	誰にとっても~~支障ない:won’t bite anyone
	待つ:wait
	解き明かす:figure out
	~~確保する:make sure
	確かめる:make sure
	課す:imposeする
	しようと:try
	真意が見え:obscure
	その誰か:reader
	可視化:visually illustrate
	dependent
	~~考えて:think
	選ぶ:pick する
	選ぶ:chooseする
	まとめる手間を要する:must be put together more manually
	手で打ち込まずに済む:Rather than require authors to manually type out
	まとめる:put together
	まかなう:cater
	の略:short for
	同じになる:share
	しないよう:avoiding
	〜でも:in terms of
	単に:just 〜immediately
	事実，:fact
	ようにした式:hacky way to say

	●未分類
覆う:coverする:~
覆われ:coverされ:~
敷詰めら:tileさ:敷き詰めら
混在な:mixされた:混在した
混在-:mix:~
混合法:mixing:~
出自の:originating:~
入替える:swapする:入れ替える
超過-:exceed:~
描く:drawする:~
検索-:look up:~
種類:kind:~
整理:cleanup:~
葉:leaf::~::リーフ
枝分かれ:branch::~::ブランチ
形:form:~
循環-:cycle::~
	循環的:cycle over
filter::::フィルタ
一時的:temporary:~
手続き:
	手続き:procedure
所在指定子:locator::~
printer::::プリンタ
laser::::レーザ
monitor::::モニタ
時計回り:clockwise:~
欄:field:~
印刷用途:printing use-cases:~
背景:background:~
優先順位:precedence:~
生の:raw:~
往来:roundtripping:~
完璧:perfect:完全
伝染的:infectious:~
近過去の:recentな:~
費やす:spendする:~

	得られ:yeilds
	常に伝染する:fully infective
	組合でき:combinable
	異なる:different／differs
	外す:discard／drop
	最中に:in the middle of
	形を変える:shapeをchangeする
	なる:become
	であり続ける:stay as
	得られ:gain
	~~同化され:censored／:censored away
	外へは~~漏れる:escape
	短絡-:short-circuit
	合間に~~挟まれ:nestled／:intersperse
	左から右の順:left-to-right
	居座る:stay
	築き上げる:building up
	戻す:send it back
	-:wrapper
	得る／得られ:yield
	-:happen
	戻-:back
	-:encounter
	転換され:turned into
	-:refer
	が:Although
	~~形:shape／
	高-:high-
	低-:low-
	高い:high
	低い／低:low
	低いB:lower B
	高いB:upper B
	-:capacity
	欄
	potentially
	個数:count
	^en:word cloud
	~font~size:font-size
	ただ記す:just putting an
	何桁もの数:enormous number
	~JS:JS
	欠いて:lack
	まさにこの~~不安を抱えた:exactly this fraught
	見かけ上は:-looking

	●言い換え
	子を持たない:leaf
	優先される:favoring
	優先度の高い:stronger
	~~結合度が高い:bind tighter than
	そのまま:unchanged
	除去する:discard
	前段落:preceding paragraph
	対応する~JS関数:it finds itself in
	互換:similar
	数量-値:plain values(numeric values
	~linkにあてがう:linking
	指す:pointer
	再度~要請:re-requesting
	~scrollbar:scroll bar
	分離-:separate out into
	~~内側の:inner
	様々な:many different
	同じになる:identical
	同じこと:identical
	省略時の既定:defaulting

	●指示語
	〜が置かれた場所:where 〜 is placed
	引数:own
	個別に:individually
	先頭の:leading
	以前／前の:previous
	部分:part
	側:side
	普通の:ordinary
	~~普通でない:unusual
	他の:cross-
	過ぎない:just
	単に:just／merely
	より小さ:smaller
	より大きい:larger
	最も大きい:largest
	異種の:disparate
	以降:or later
	何か:anything／:any
	節:section／:chapter
	左側:left
	右側:right
	時点:time
	-:as a whole
	所:somewhere
	どこでも:any place
	いくつも:many
	他の部分:elsewhere
	後続する:following
	~~内側の:inner
	~top-levelの:outer
	他と同じく:continue
	以外はすべて:everything but
	から:start with
	だけ:just
	誰か:someone
	後で:later
	反対の:opposite
	-:themselves
	それ自体:itself
	そのままに:on its own
	上の〜:preceding
	-:at-least
	-:distinct
	最後に:finally
	多い:many times

●●original_id_map

	length-advance-measure:advance-measure
	math:calc-notation

●●mdn_urls

identifier-value:CSS/custom-ident
typedef-ident:CSS/ident
string-value:CSS/string
url-value:CSS/url
number-value:CSS/number
integer-value:CSS/integer
percentage-value:CSS/percentage
typedef-dimension:CSS/dimension
length-value:CSS/length
typedef-length-percentage:CSS/length-percentage
resolution-value:CSS/resolution
angle-value:CSS/angle
typedef-angle-percentage:CSS/angle-percentage
time-value:CSS/time
typedef-time-percentage:CSS/time-percentage
frequency-value:CSS/frequency
typedef-frequency-percentage:CSS/frequency-percentage
typedef-position:CSS/position_value
	typedef-dimension-unit:CSS/？
	typedef-attr-type:CSS/？
	typedef-toggle-value:CSS/toggle-value
	typedef-url-modifier:CSS/？
	zero-value:CSS/zero
	typedef-calc-product:CSS/calc-product
	typedef-calc-sum:CSS/？
	typedef-calc-value:CSS/？
	typedef-calc-constant:CSS/？
	typedef-rounding-strategy:CSS/？

funcdef-attr:CSS/attr
	funcdef-toggle:CSS/toggle
funcdef-url:CSS/url#The_url()_functional_notation
	funcdef-abs:CSS/abs
	funcdef-acos:CSS/acos
	funcdef-asin:CSS/asin
	funcdef-atan2:CSS/atan2
	funcdef-atan:CSS/atan
funcdef-calc:CSS/calc
funcdef-clamp:CSS/clamp
	funcdef-cos:CSS/cos
	funcdef-exp:CSS/exp
	funcdef-hypot:CSS/hypot
	funcdef-log:CSS/log
funcdef-max:CSS/max
funcdef-min:CSS/min
	funcdef-mod:CSS/mod
funcdef-pow:CSS/pow
	funcdef-rem:CSS/rem
	funcdef-round:CSS/round
	funcdef-sign:CSS/sign
	funcdef-sin:CSS/sin
	funcdef-sqrt:CSS/sqrt
	funcdef-tan:CSS/tan

cap:CSS/length#cap
ch:CSS/length#ch
cm:CSS/length#cm
em:CSS/length#em
ex:CSS/length#ex
ic:CSS/length#ic
in:CSS/length#in
lh:CSS/length#lh
mm:CSS/length#mm
pc:CSS/length#pc
pt:CSS/length#pt
px:CSS/length#px
q:CSS/length#q
rem:CSS/length#rem
rlh:CSS/length#rlh
valdef-length-vb:CSS/length#vb
vh:CSS/length#vh
valdef-length-vi:CSS/length#vi
vmax:CSS/length#vmax
vmin:CSS/length#vmin
vw:CSS/length#vw
deg:CSS/angle#deg
grad:CSS/angle#grad
rad:CSS/angle#rad
turn:CSS/angle#turn
dpcm:CSS/resolution#dpcm
dpi:CSS/resolution#dpi
dppx:CSS/resolution#dppx
x:CSS/resolution#x
Hz:CSS/frequency#Hz
kHz:CSS/frequency#kHz
ms:CSS/time#ms
s:CSS/time#s


●●link_map


	●SYNATX
t.declaration-value:~CSSSYN#typedef-declaration-value
t.ident-token:~CSSSYN#typedef-ident-token
t.whitespace-token:~CSSSYN#typedef-whitespace-token
t.delim-token:~CSSSYN#typedef-delim-token
t.dimension-token:~CSSSYN#typedef-dimension-token
t.string-token:~CSSSYN#typedef-string-token
t.url-token:~CSSSYN#typedef-url-token
t.number-token:~CSSSYN#typedef-number-token
t.percentage-token:~CSSSYN#typedef-percentage-token
t.function-token:~CSSSYN#typedef-function-token

	●types
t.angle-percentage:#typedef-angle-percentage
t.angle:#angle-value
t.attr-type:#typedef-attr-type
t.ident:#typedef-ident
t.custom-ident:#identifier-value
t.dashed-ident:#typedef-dashed-ident
t.dimension:#typedef-dimension
t.dimension-unit:#typedef-dimension-unit
	t.dimension-unit:#valdef-attr-dimension-unit （多重 id）
t.frequency-percentage:#typedef-frequency-percentage
t.frequency:#frequency-value
t.integer:#integer-value
t.length-percentage:#typedef-length-percentage
t.length:#length-value
t.number:#number-value
t.percentage:#percentage-value
t.ratio:#ratio-value
t.resolution:#resolution-value
t.string:#string-value
t.time-percentage:#typedef-time-percentage
t.time:#time-value
t.toggle-value:#typedef-toggle-value
t.url-modifier:#typedef-url-modifier
t.url:#url-value
t.zero:#zero-value

t.calc-product:#typedef-calc-product
t.calc-sum:#typedef-calc-sum
t.calc-value:#typedef-calc-value
t.calc-constant:#typedef-calc-constant
t.rounding-strategy:#typedef-rounding-strategy

t.flex:~CSSGRID#typedef-flex
t.image:~CSSIMAGE#typedef-image
t.color:~CSSCOLOR#typedef-color
	~CSSWG/css-color-3/#valuea-def-color
t.wq-name:~SELECTORS4#typedef-wq-name
t.hex-color:~CSSCOLOR#typedef-hex-color
t.position:#typedef-position
t.easing-function:~CSSEASING#typedef-easing-function
t.filter-value-list:~FILTERS#typedef-filter-value-list

	●prop

p.animation-iteration-count:~CSSANIM#propdef-animation-iteration-count
p.animation-name:~CSSANIM#propdef-animation-name
p.animation-timing-function:~CSSANIM#propdef-animation-timing-function
p.animation:~CSSANIM#propdef-animation
p.background-attachment:~CSSBG#propdef-background-attachment
p.background-position:~CSSBG#propdef-background-position
	~CSS22/colors.html#propdef-background-position
p.background:~CSSBG#propdef-background
p.block-step-size:~CSSWG/css-rhythm-1/#propdef-block-step-size
p.block-step-round:~CSSWG/css-rhythm-1/#propdef-block-step-round
p.border-collapse:~CSS22/tables.html#propdef-border-collapse
p.border-color:~CSSBG#propdef-border-color
p.border-width:~CSSBG#propdef-border-width
p.box-shadow:~CSSBG#propdef-box-shadow
p.box-sizing:~SIZING#propdef-box-sizing
p.font-family:~CSSFONT#propdef-font-family
p.font-size:~CSSFONT#propdef-font-size
p.font:~CSSFONT#propdef-font
p.height:~CSS2VISUDET#propdef-height
p.image-resolution:~CSSIMAGE4#propdef-image-resolution
p.line-height:~CSS2VISUDET#propdef-line-height
p.list-style-type:~CSSLIST#propdef-list-style-type
p.max-lines:~CSSOVERFLOW3#propdef-max-lines
p.min-width:~CSS2VISUDET#propdef-min-width
p.opacity:~CSSCOLOR#propdef-opacity
p.orphans:~CSSBREAK#propdef-orphans
p.outline-color:~CSSUI#propdef-outline-color
p.overflow:~CSSOVERFLOW3#propdef-overflow
p.padding-top:~CSSBOX#propdef-padding-top
p.tab-size:~CSSTEXT#propdef-tab-size
p.text-align:~CSSTEXT#propdef-text-align
p.text-decoration:~CSSTEXTDECOR#propdef-text-decoration
p.text-emphasis-color:~CSSTEXTDECOR#propdef-text-emphasis-color
p.text-orientation:~CSSWM#propdef-text-orientation
p.transform-origin:~TRANSFORM#propdef-transform-origin
p.width:~CSS2VISUDET#propdef-width
p.writing-mode:~CSSWM#propdef-writing-mode

d.resolution:~MQ4#descdef-media-resolution

	●units
u.Hz:#Hz
u.ch:#ch
u.ic:#ic
u.cap:#cap
u.cm:#cm
u.deg:#deg
u.dpcm:#dpcm
u.dpi:#dpi
u.dppx:#dppx
u.em:#em
u.ex:#ex
u.grad:#grad
u.in:#in
u.kHz:#kHz
u.mm:#mm
u.ms:#ms
u.pc:#pc
u.pt:#pt
u.px:#px
u.Q:#q
u.q:#q
u.rad:#rad
u.rem:#rem
u.lh:#lh
u.rlh:#rlh
u.s:#s
u.turn:#turn
u.vh:#vh
u.vmax:#vmax
u.vmin:#vmin
u.vw:#vw
u.vi:#valdef-length-vi
u.vb:#valdef-length-vb
u.x:#x
u.fr:~CSSGRID#valdef-flex-fr

	●val

v.disc:~CSSCOUNTER#disc
v.square:~CSSCOUNTER#square
v.circle:~CSSCOUNTER#circle
	？box:~CSSCOUNTER#box
	css2/generate.html

v.vertical-rl:~CSSWM#valdef-writing-mode-vertical-rl
v.vertical-lr:~CSSWM#valdef-writing-mode-vertical-lr
v.upright:~CSSWM#valdef-text-orientation-upright

v.unset:~CASCADE#valdef-all-unset
v.inherit:~CASCADE#valdef-all-inherit
v.initial:~CASCADE#valdef-all-initial
v.revert:~CASCADE#valdef-all-revert

v.currentcolor:~CSSCOLOR#valdef-color-currentcolor
	~CSSWG/css-color-4/#valdef-color-currentcolor
	~CSSWG/css-text-decor-3/#valuedef-currentcolor
	~TR/css3-color/#currentcolor

v.ease-in:~CSSEASING#valdef-cubic-bezier-easing-function-ease-in
v.ease-out:~CSSEASING#valdef-cubic-bezier-easing-function-ease-out

v.inset:~CSSBG#shadow-inset

v.~autoS:~SIZING#valdef-width-auto

v.angle:#valdef-attr-angle
v.color:#valdef-attr-color
v.flex:#valdef-attr-flex
v.frequency:#valdef-attr-frequency
v.ident:#valdef-attr-ident
v.length:#valdef-attr-length
v.number:#valdef-attr-number
v.percentage:#valdef-attr-percentage
v.string:#valdef-attr-string
v.time:#valdef-attr-time
v.url:#valdef-attr-url

v.nearest:#valdef-rounding-strategy-nearest
v.up:#valdef-rounding-strategy-up
v.down:#valdef-rounding-strategy-down
v.to-zero:#valdef-rounding-strategy-to-zero

v.e:#valdef-calc-e
v.pi:#valdef-calc-pi
v.-infinity:#valdef-calc--infinity
v.infinity:#valdef-calc-infinity
v.NaN:#valdef-calc-nan

	●func
f.var:~CSSVAR#funcdef-var
f.rgba:~CSSCOLOR#funcdef-rgba
f.hsl:~CSSCOLOR#funcdef-hsl
	css-color-5
f.linear-gradient:~CSSIMAGE#funcdef-linear-gradient

f.attr:#funcdef-attr
f.toggle:#funcdef-toggle
f.url:#funcdef-url

f.abs:#funcdef-abs
f.acos:#funcdef-acos
f.asin:#funcdef-asin
f.atan2:#funcdef-atan2
f.atan:#funcdef-atan
f.calc:#funcdef-calc
f.clamp:#funcdef-clamp
f.cos:#funcdef-cos
f.exp:#funcdef-exp
f.hypot:#funcdef-hypot
f.log:#funcdef-log
f.max:#funcdef-max
f.min:#funcdef-min
f.mod:#funcdef-mod
f.pow:#funcdef-pow
f.rem:#funcdef-rem
f.round:#funcdef-round
f.sign:#funcdef-sign
f.sin:#funcdef-sin
f.sqrt:#funcdef-sqrt
f.tan:#funcdef-tan

t.abs():#funcdef-abs
t.acos():#funcdef-acos
t.asin():#funcdef-asin
t.atan():#funcdef-atan
t.atan2():#funcdef-atan2
t.calc():#funcdef-calc
t.clamp():#funcdef-clamp
t.cos():#funcdef-cos
t.exp():#funcdef-exp
t.hypot():#funcdef-hypot
t.log():#funcdef-log
t.max():#funcdef-max
t.min():#funcdef-min
t.mod():#funcdef-mod
t.pow():#funcdef-pow
t.rem():#funcdef-rem
t.round():#funcdef-round
t.sign():#funcdef-sign
t.sin():#funcdef-sin
t.sqrt():#funcdef-sqrt
t.tan():#funcdef-tan

e.base:~HEmetadata#the-base-element
c.pushState():~HISTORY#dom-history-pushstate

at.import:~CASCADE#at-ruledef-import

	●構文
g.#:#component-multipliers
g.,:#comb-comma
g.||:#comb-any
g.~AMP~AMP:#comb-all
g.|:#comb-one
g.!:#mult-req
g.#:#mult-comma
g.+:#mult-one-plus
g.*:#mult-zero-plus
g.?:#mult-opt
	{A}:mult-num
	{A,B}:mult-num-range

値~定義の構文:#css-value-definition-syntax
関数-記法:#functional-notation
量指定子:#component-multipliers
結合子:#component-combinators
~textな~data型:#css-textual-data-types
数量-~data型:#numeric-data-types
角括弧付き範囲~記法:#css-bracketed-range-notation

	●用語
実数:#number
整数:#integer
百分率:#percentage
次元:#dimension
比率:#ratio

~keyword:#css-keyword
定義済み~keyword:#css-keyword
~CSS全域~keyword:#css-wide-keywords
識別子:#css-identifier
~CSS識別子:#css-identifier

物理-単位:#physical-unit
互換:#compatible-units
正準的~単位:#canonical-unit
相対~長さ単位:#relative-length
絶対~長さ単位:#absolute-length
~anchor:#anchor-unit
~anchor単位:#anchor-unit
表示域~百分率による長さ:#viewport-percentage-lengths
表示域~百分率 単位:#viewport-relative-lengths
視野角~単位:#pixel-unit
~pixel単位:#pixel-unit
局所~url~flag:#url-local-url-flag


基準~pixel:#reference-pixel
方位角:#bearing-angle
~comma:#comb-comma
~fontに相対的な長さ:#font-relative-length
送幅:#length-advance-measure

~math関数:#math-function
計算式:#calc-calculation
計算式~tree:#calculation-tree
計算式を構文解析する:#parse-a-calculation
計算式~treeを単純~化する:#simplify-a-calculation-tree
計算式~treeを単純~化:#simplify-a-calculation-tree
計算式~treeを直列化する:#serialize-a-calculation-tree
~math関数を直列化する:#serialize-a-math-function
演算子~node:#calculation-tree-operator-nodes
~calc演算子~node:#calculation-tree-calc-operator-nodes
~top-levelの計算式:#top-level-calculation
型を決定-:#determine-the-type-of-a-calculation
型を決定する:#determine-the-type-of-a-calculation
根の子たちを~sortする:#sort-a-calculations-children
	合間:#between-zero-and-b

結合-:#combine
補間:#interpolation
補間-:#interpolation
加算:#addition
加算-:#addition
累積:#accumulation
累積-:#accumulation
加法的でない:#not-additive

§ 型の検査-法:#calc-type-checking

代用~値:#attr-substitution-value
代用-:#substitute-an-attr
~fallback値:#_fallback-value

	§ #attr-types

	●外部
文字列:~INFRA#string

離散的:~WANIM#discrete

型:~CSSTOM1#cssnumericvalue-type
型を作成する:~CSSTOM1#cssnumericvalue-create-a-type
型を加算する:~CSSTOM1#cssnumericvalue-add-two-types
型を乗算する:~CSSTOM1#cssnumericvalue-multiply-two-types
型を逆数にする:~CSSTOM1#cssnumericvalue-invert-a-type
合致する:~CSSTOM1#cssnumericvalue-match
	百分率hint:~CSSTOM1#cssnumericvalue-percent-hint
内部~表現:~CSSTOM1#css-internal-representation

無視する:~CSSSYN#css-ignored

継承d値:~CASCADE#inherited-value
算出d値:~CASCADE#computed-value
使用~値:~CASCADE#used-value
指定d値:~CASCADE#specified-value
実際の値:~CASCADE#actual-value
初期~値:~CASCADE#initial-value
解決d値:~CSSOM1#resolved-values

継承:~CASCADE#inheritance
継承されない~prop:~CASCADE#inherited-property
略式~prop:~CASCADE#shorthand-property
下位prop:~CASCADE#longhand

~custom~prop:~CSSVAR#custom-property
無効が保証される値:~CSSVAR#guaranteed-invalid-value
算出d値の時点で無効:~CSSVAR#invalid-at-computed-value-time

~escape:~CSSSYN#escape-codepoint
	~escape:~CSS22/syndata.html#escaped-characters

~easing関数:~CSSEASING#easing-function

包含塊:~CSSDISP#containing-block
初期~包含塊:~CSSDISP#initial-containing-block
整形~文脈:~CSSDISP#formatting-context

行内-軸:~CSSWM#inline-axis
塊-軸:~CSSWM#block-axis
塊~size:~CSSWM#block-size

成分~値:~CSSSYN#component-value
丸括弧~block:~CSSSYN#paren-block
	単純~block:~CSSSYN#simple-block
関数式:~CSSSYN#function
空白:~CSSSYN#whitespace
特別に構文解析され:~CSSSYN#consume-a-url-token
成分~値を構文解析する:~CSSSYN#parse-a-component-value

疑似要素:~SELECTORS4#pseudo-elements
出自の要素:~SELECTORS4#originating-element
属性~選択子:~SELECTORS4#attribute-selector

有名~色:~CSSCOLOR#named-color

~ASCII大小無視:~INFRA#ascii-case-insensitive
連結-:~INFRA#string-concatenate
前後の~ASCII空白~列を剥いだ:~INFRA#strip-leading-and-trailing-ascii-whitespace

属性:~DOM4#concept-attribute
要素:~DOM4#concept-element

~URL:~URL1#concept-url

可用な最初の~font:~CSSFONT#first-available-font

	補完

I.CSSMathValue:~CSSTOM1#cssmathvalue

直列化-:~CSSOM1#serializing-css-values
媒体~query:~MQ4#media-query
背景~位置決め区画:~CSSBG#background-positioning-area
~paged媒体:~MQ4#paged-media


●●ref_normative

[CSS-CASCADE-4]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 4. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-4/ 
[CSS-COLOR-4]
    Tab Atkins Jr.; Chris Lilley. CSS Color Module Level 4. 5 November 2019. WD. URL: https://www.w3.org/TR/css-color-4/ 
[CSS-COUNTER-STYLES-3]
    Tab Atkins Jr.. CSS Counter Styles Level 3. 14 December 2017. CR. URL: https://www.w3.org/TR/css-counter-styles-3/ 
[CSS-DISPLAY-3]
    Tab Atkins Jr.; Elika Etemad. CSS Display Module Level 3. 19 May 2020. CR. URL: https://www.w3.org/TR/css-display-3/ 
[CSS-EASING-1]
    Brian Birtles; Dean Jackson; Matt Rakow. CSS Easing Functions Level 1. 30 April 2019. CR. URL: https://www.w3.org/TR/css-easing-1/ 
[CSS-GRID-1]
    Tab Atkins Jr.; Elika Etemad; Rossen Atanassov. CSS Grid Layout Module Level 1. 14 December 2017. CR. URL: https://www.w3.org/TR/css-grid-1/ 
[CSS-IMAGES-4]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Image Values and Replaced Content Module Level 4. 13 April 2017. WD. URL: https://www.w3.org/TR/css-images-4/ 
[CSS-INLINE-3]
    Dave Cramer; Elika Etemad; Steve Zilles. CSS Inline Layout Module Level 3. 4 June 2020. WD. URL: https://www.w3.org/TR/css-inline-3/ 
[CSS-OVERFLOW-3]
    David Baron; Elika Etemad; Florian Rivoal. CSS Overflow Module Level 3. 3 June 2020. WD. URL: https://www.w3.org/TR/css-overflow-3/ 
[CSS-SIZING-3]
    Tab Atkins Jr.; Elika Etemad. CSS Intrinsic & Extrinsic Sizing Module Level 3. 22 May 2019. WD. URL: https://www.w3.org/TR/css-sizing-3/ 
[CSS-TEXT-DECOR-4]
    Elika Etemad; Koji Ishii. CSS Text Decoration Module Level 4. 6 May 2020. WD. URL: https://www.w3.org/TR/css-text-decor-4/ 
[CSS-TYPED-OM-1]
    Shane Stephens; Tab Atkins Jr.; Naina Raisinghani. CSS Typed OM Level 1. 10 April 2018. WD. URL: https://www.w3.org/TR/css-typed-om-1/ 
[CSS-UI-4]
    Florian Rivoal. CSS Basic User Interface Module Level 4. 24 January 2020. WD. URL: https://www.w3.org/TR/css-ui-4/ 
[CSS-VARIABLES-1]
    Tab Atkins Jr.. CSS Custom Properties for Cascading Variables Module Level 1. 3 December 2015. CR. URL: https://www.w3.org/TR/css-variables-1/ 
[CSS-WRITING-MODES-4]
    Elika Etemad; Koji Ishii. CSS Writing Modes Level 4. 30 July 2019. CR. URL: https://www.w3.org/TR/css-writing-modes-4/ 
[CSS21]
    Bert Bos; et al. Cascading Style Sheets Level 2 Revision 1 (CSS 2.1) Specification. 7 June 2011. REC. URL: https://www.w3.org/TR/CSS2/ 
[CSS3-BACKGROUND]
    Bert Bos; Elika Etemad; Brad Kemper. CSS Backgrounds and Borders Module Level 3. 17 October 2017. CR. URL: https://www.w3.org/TR/css-backgrounds-3/ 
[CSS3-FONTS]
    John Daggett; Myles Maxfield; Chris Lilley. CSS Fonts Module Level 3. 20 September 2018. REC. URL: https://www.w3.org/TR/css-fonts-3/ 
[CSS3-IMAGES]
    Tab Atkins Jr.; Elika Etemad; Lea Verou. CSS Images Module Level 3. 10 October 2019. CR. URL: https://www.w3.org/TR/css-images-3/ 
[CSS3CASCADE]
    Elika Etemad; Tab Atkins Jr.. CSS Cascading and Inheritance Level 3. 28 August 2018. CR. URL: https://www.w3.org/TR/css-cascade-3/ 
[CSS3COLOR]
    Tantek Çelik; Chris Lilley; David Baron. CSS Color Module Level 3. 19 June 2018. REC. URL: https://www.w3.org/TR/css-color-3/ 
[CSS3PAGE]
    Elika Etemad; Simon Sapin. CSS Paged Media Module Level 3. 18 October 2018. WD. URL: https://www.w3.org/TR/css-page-3/ 
[CSS3SYN]
    Tab Atkins Jr.; Simon Sapin. CSS Syntax Module Level 3. 16 July 2019. CR. URL: https://www.w3.org/TR/css-syntax-3/ 
[CSSOM]
    Simon Pieters; Glenn Adams. CSS Object Model (CSSOM). 17 March 2016. WD. URL: https://www.w3.org/TR/cssom-1/ 
[DOM]
    Anne van Kesteren. DOM Standard. Living Standard. URL: https://dom.spec.whatwg.org/ 
[INFRA]
    Anne van Kesteren; Domenic Denicola. Infra Standard. Living Standard. URL: https://infra.spec.whatwg.org/ 
[MEDIAQ]
    Florian Rivoal; Tab Atkins Jr.. Media Queries Level 4. 5 September 2017. CR. URL: https://www.w3.org/TR/mediaqueries-4/ 
[RFC2119]
    S. Bradner. Key words for use in RFCs to Indicate Requirement Levels. March 1997. Best Current Practice. URL: https://tools.ietf.org/html/rfc2119 
[SELECTORS-4]
    Elika Etemad; Tab Atkins Jr.. Selectors Level 4. 21 November 2018. WD. URL: https://www.w3.org/TR/selectors-4/ 
[UNICODE]
    The Unicode Standard. URL: https://www.unicode.org/versions/latest/ 
[URL]
    Anne van Kesteren. URL Standard. Living Standard. URL: https://url.spec.whatwg.org/ 
[WEB-ANIMATIONS-1]
    Brian Birtles; et al. Web Animations. 11 October 2018. WD. URL: https://www.w3.org/TR/web-animations-1/ 

●●ref_informative

[CSS-ANIMATIONS-1]
    Dean Jackson; et al. CSS Animations Level 1. 11 October 2018. WD. URL: https://www.w3.org/TR/css-animations-1/ 
[CSS-BOX-4]
    Elika Etemad. CSS Box Model Module Level 4. 21 April 2020. WD. URL: https://www.w3.org/TR/css-box-4/ 
[CSS-BREAK-3]
    Rossen Atanassov; Elika Etemad. CSS Fragmentation Module Level 3. 4 December 2018. CR. URL: https://www.w3.org/TR/css-break-3/ 
[CSS-COLOR-5]
    Chris Lilley; et al. CSS Color Module Level 5. 3 March 2020. WD. URL: https://www.w3.org/TR/css-color-5/ 
[CSS-OVERFLOW-4]
    David Baron; Florian Rivoal. CSS Overflow Module Level 4. 13 June 2017. WD. URL: https://www.w3.org/TR/css-overflow-4/ 
[CSS-RHYTHM-1]
    Koji Ishii; Elika Etemad. CSS Rhythmic Sizing. 2 March 2017. WD. URL: https://www.w3.org/TR/css-rhythm-1/ 
[CSS-TEXT-3]
    Elika Etemad; Koji Ishii; Florian Rivoal. CSS Text Module Level 3. 29 April 2020. WD. URL: https://www.w3.org/TR/css-text-3/ 
[CSS-TRANSFORMS-1]
    Simon Fraser; et al. CSS Transforms Module Level 1. 14 February 2019. CR. URL: https://www.w3.org/TR/css-transforms-1/ 
[HTML]
    Anne van Kesteren; et al. HTML Standard. Living Standard. URL: https://html.spec.whatwg.org/multipage/ 
[RFC6694]
    S. Moonesamy, Ed.. The "about" URI Scheme. August 2012. Informational. URL: https://tools.ietf.org/html/rfc6694 


●●trans_metadata
<p>
~THIS_PAGEは、~W3Cにより編集者草案として公開された
<a href="~SPEC_URL">CSS Values and Units Module Level 4</a>
を日本語に翻訳したものです。
~PUB
</p>

●●spec_metadata

最新発行バージョン
	https://www.w3.org/TR/css-values-4/

以前のバージョン
	https://www.w3.org/TR/2018/WD-css-values-4-20181010/

最新の課題
	<a href="https://github.com/w3c/csswg-drafts/labels/css-values-4">GitHub Issues</a>

編集
	<a href="http://xanthir.com/contact/">Tab Atkins</a> (Google)
	<a href="http://fantasai.inkedblade.net/contact">fantasai</a>

Suggest an Edit for this Spec
	<a href="https://github.com/w3c/csswg-drafts/blob/master/css-values-4/Overview.bs">GitHub Editor</a>
commit 履歴
	https://github.com/w3c/csswg-drafts/commits/master/css-values-4

</script>

<body>

<header>
	<hgroup>
<h1>CSS の値と単位 — CSS Values and Units Module Level 4</h1>
	</hgroup>
</header>

<div id="MAIN" hidden>

	<section id="abstract">

~ABSTRACT

<p>
この~CSS~moduleは、~CSS~propに受容される共通な値と単位，および
~CSS~prop定義の中でそれらの値と単位を述べるために利用される構文について述べる。
◎
This CSS module describes the common values and units that CSS properties accept and the syntax used for describing them in CSS property definitions.
</p>

~CSSisaLANG

	</section>
	<section id="status">
~STATUSofTHIS

<p>
これは編集者草案の公な複製です…
【以下，この節の他の内容は <a href="css-common-ja.html#status">~CSS日本語訳 共通~page</a>／冒頭の仕様~metadataに委譲。】
</p>

<p>
次の特能は
<a href="css-common-ja.html#at-risk">~risk下</a>
にあり，勧告候補の期間内に取り下げられる可能性があります：
◎
The following features are at-risk, and may be dropped during the CR period:
</p>

<ul>
	<li>`toggle$f, `attr$f</li>
</ul>

	</section>

<main id="MAIN0">

	<section id="introduction">
<h2 title="Introduction">1. 序論</h2>

<p>
各種~CSS~propの定義表における値~定義の欄には、
~keyword, ~data型（山括弧 `&lt;^c, `&gt;^c で括られて現れる）, および
それらをどう組合せるかについての情報を包含している。
この仕様では、多くの~propから利用できる，汎用~data型（最も広く利用されている `length$t など）について述べる。
より特定な~data型（例えば `spacing-limit^t ）は、対応している~moduleにて述べられる。
◎
The value definition field of each CSS property can contain keywords, data types (which appear between &lt; and &gt;), and information on how they can be combined. Generic data types (&lt;length&gt; being the most widely used) that can be used by many properties are described in this specification, while more specific data types (e.g., &lt;spacing-limit&gt;) are described in the corresponding modules.
</p>

		<section id="placement">
<h3 title="Module Interactions">1.1. ~module間の相互作用</h3>

<p>
この~moduleは `CSS21$r の
<a href="~CSS22/about.html#value-defs">§ 1.4.2.1</a>,
<a href="~CSS22/syndata.html#values">§ 4.3</a>,
<a href="~CSS22/aural.html#aural-intro">§ A.2</a>
にて定義される~data型を置換し, 拡張する。
◎
This module replaces and extends the data type definitions in [CSS21] sections 1.4.2.1, 4.3, and A.2.
</p>

		</section>
	</section>
	<section id="value-defs">
<h2 title="Value Definition Syntax">2. 値~定義の構文</h2>

<p>
ここに述べる
`値~定義の構文@
は、~CSS~prop用の妥当な値が成す集合（および，~CSSにおける他の多くの部分を成す妥当な構文）を定義するために利用される。
そのように述べられた値は、 1 個以上の成分からなり得る。
◎
The value definition syntax described here is used to define the set of valid values for CSS properties (and the valid syntax of many other parts of CSS). A value so described can have one or more components.
</p>

		</section>
		<section id="component-types">
<h3 title="Component Value Types">2.1. 成分~値の型</h3>

<p>
~propの成分~値の型は、その値~定義において，以下の仕方で指名される：
◎
Component value types are designated in several ways:
</p>

<ol>
	<li>
引用符や山括弧を伴わずに，~literalに現れるものは、`~keyword$値である（
`auto^v, `disc$v,
等々）。
◎
keyword values (such as auto, disc, etc.), which appear literally, without quotes (e.g. auto)
</li>
	<li>
基本~data型は、山括弧（
`&lt;^g, `&gt;^g
）で括られて現れる（
`length$t, `percentage$t,
等々）。
`数量-~data型$に対しては、下に述べる`角括弧付き範囲~記法$を利用して，この型~記法に範囲~制約を注釈できる。
◎
basic data types, which appear between &lt; and &gt; (e.g., &lt;length&gt;, &lt;percentage&gt;, etc.). For numeric data types, this type notation can annotate any range restrictions using the bracketed range notation described below.
</li>
	<li>
<p>
同じ名前を持つ~propと同じ範囲の値をとる，型（例えば
`border-width$tp, `background-attachment$tp
など）。
この場合、その型の名前は，山括弧の間の（引用符で完結する）~prop名になる。
ただし，この種の型は、次に該当するものは `含まない^em：
</p>
		<ul>
			<li>
`inherit$v などの `~CSS全域~keyword$値。
【どの~propも，この種の値をとれるものとされているので。】
</li>
			<li>
~top-levelの~comma区切りの~list用の量指定子（ `#^g ）（すなわち，ある名前の~prop `pairing^p の値が
<span class="prod">[ `custom-ident$t `integer$t? ]#</span>
として定義されている場合、 `pairing^tp は
<span class="prod">[ `custom-ident$t `integer$t? ]</span>
に等価になる
—
<span class="prod">[ `custom-ident$t `integer$t? ]#</span>
ではなく）。
【この規約は、様々な型の値~定義を簡素化できるようにするためにある。】
</li>
		</ul>
◎
types that have the same range of values as a property bearing the same name (e.g., &lt;'border-width'&gt;, &lt;'background-attachment'&gt;, etc.). In this case, the type name is the property name (complete with quotes) between the brackets. Such a type does not include CSS-wide keywords such as inherit, and also does not include any top-level comma-separated-list multiplier (i.e. if a property named pairing is defined as [ &lt;custom-ident&gt; &lt;integer&gt;? ]#, then &lt;'pairing'&gt; is equivalent to [ &lt;custom-ident&gt; &lt;integer&gt;? ], not [ &lt;custom-ident&gt; &lt;integer&gt;? ]#).
</li>
	<li>
非末端型【他の型や個々の値を組合せて定義される型】は、~propと同じ名前を共有しない。
この場合の非末端型の名前は、
`spacing-limit^t のように，山括弧（
`&lt;^g, `&gt;^g
）で括られて現れる。
`border-width^t と `border-width$tp との間の差異に注意：
後者は， `border-width$p ~propがとり得る値として定義される一方、前者は，他のどこかで 明示的に拡張pが定義される必要がある。
非末端型の定義は、概して，仕様の中でそれが最初に現れる近辺に示される。
◎
non-terminals that do not share the same name as a property. In this case, the non-terminal name appears between &lt; and &gt;, as in &lt;spacing-limit&gt;. Notice the distinction between &lt;border-width&gt; and &lt;'border-width'&gt;: the latter is defined as the value of the border-width property, the former requires an explicit expansion elsewhere. The definition of a non-terminal is typically located near its first appearance in the specification.
</li>
</ol>

<p>
一部の~propの値~定義は、［
~slash（ `/^c ）／~comma（ `,^c ）／丸括弧（ `(^c, `)^c ）
］も~literalとして含むことがある。
これらは、対応する~tokenを表現する。
正符号（ `+^c ）など，他の成分~値に現れ得る~keywordでない~literal文字は、一重~引用符で括って記されなければナラナイ。
◎
Some property value definitions also include the slash (/), the comma (,), and/or parentheses as literals. These represent their corresponding tokens. Other non-keyword literal characters that may appear in a component value, such as “+”, must be written enclosed in single quotes.
</p>

<p>
文法において指定された
`~comma@
（ `,^g ）は、省略可能な項を区切るために利用されたときは，
一部の状況下では `暗黙的に省略-可能になる^em。
また，文法において［
~propや他の~CSS値の中の~top-levelの~list, あるいは
関数の引数~list
］の中に指定された~commaは、次に挙げる場合には，省略されなければナラナイ：
◎
Commas specified in the grammar are implicitly omissible in some circumstances, when used to separate optional terms in the grammar. Within a top-level list in a property or other CSS value, or a function’s argument list, a comma specified in the grammar must be omitted if:
</p>

<ul>
	<li>
~commaに先行するすべての項が省略された場合
◎
all items preceding the comma have been omitted
</li>
	<li>
~commaに後続するすべての項が省略された場合
◎
all items following the comma have been omitted
</li>
	<li>
~commaに挟まれた項が省略されると，複数の~commaが（`空白$や~commentを無視して）連続することになる場合
◎
multiple commas would be adjacent (ignoring white space/comments), due to the items between the commas being omitted.
</li>
</ul>

<div class="example">
<p>
例えば，［
どれも省略可能な， 3 個の引数
］を受容する関数の文法は、次の様に記せる：
◎
For example, if a function can accept three arguments in order, but all of them are optional, the grammar can be written like:
</p>

<pre class="prod">
example( first`?$g `,$g second`?$g `,$g third`?$g )
</pre>

<p>
この文法の下では、
`example(first, second, third)^v
は妥当であり，
`example(first, second)^v ／
`example(first, third)^v ／
`example(second)^v
も同様である。
一方で，
`example(first, , third)^v
は、無効になる。
~commaには、 2 つの選択肢を分離することが要求されるので。
同じ理由から、
`example(,second)^v ／
`example(first,)^v ／
`example(first second)^v
も無効になる。
◎
Given this grammar, writing example(first, second, third) is valid, as is example(first, second) or example(first, third) or example(second). However, example(first, , third) is invalid, as one of those commas are no longer separating two options; similarly, example(,second) and example(first,) are invalid. example(first second) is also invalid, as commas are still required to actually separate the options.
</p>

<p>
~commaが暗黙的に省略し得ないものであったなら、省略し得る引数を適正に表出するための文法は，ずっと複雑になり，その特能の単純~性も損なわれるであろう。
◎
If commas were not implicitly omittable, the grammar would have to be much more complicated to properly express the ways that the arguments can be omitted, greatly obscuring the simplicity of the feature.
</p>
</div>

<hr>

<div>
<p>
すべての~CSS~propには、~prop値の単独の成分として，
`~CSS全域~keyword$値が受容される。
可読性のため、これらの~prop値は，構文~定義には明示的に挙げられない。
例えば， `border-color$p の値~定義は（
<samp class="css">`color^t{1,4}</samp>
と示されているが），~~実際には：
<span class="block prod">
[ `color^t{1,4} ] | `inherit$v | `initial$v | `unset$v
</span>
である。
◎
All CSS properties also accept the CSS-wide keyword values as the sole component of their property value. For readability these are not listed explicitly in the property value syntax definitions. For example, the full value definition of border-color is &lt;color&gt;{1,4} | inherit | initial | unset (even though it is listed as &lt;color&gt;{1,4}).
</p>

<p class="trans-note">【
`~CSS全域~keyword$の節に付記されているように，新たな全域~keywordが導入されれば、それらも追加されることになるであろう（しかしながら，仮に導入された場合、
<a href="#custom-idents">作者~定義な識別子</a>
との衝突から，後方-互換性の問題も生じ得ることになる）。
】</p>

</div>

<p class="note">注記：
したがって、一般に，同じ宣言の中で これらの~keywordが他の成分~値と組合された場合、その宣言は無効になる。
例えば
<samp class="css">`background$p: `url(corner.png) no-repeat, inherit^v;</samp>
は、無効になる。
◎
Note: This implies that, in general, combining these keywords with other component values in the same declaration results in an invalid declaration. For example, background: url(corner.png) no-repeat, inherit; is invalid.
</p>

		<section id="component-combinators">
<h3 title="Component Value Combinators">2.2. 成分~値の結合子</h3>

<p>
~propの値~定義においては、各~成分~値が次の組合nで配列される：
◎
Component values can be arranged into property values as follows:
</p>

<dl>
	<dt>（結合子を挟まずに）並記された成分</dt>
	<dd>
それらの成分すべてが，示された順序で現れなければナラナイ。
◎
Juxtaposing components means that all of them must occur, in the given order.
</dd>

	<dt id="comb-all">二重~ampersand（ `~AMP~AMP^g ）</dt>
	<dd>
複数個の成分の区切り
— それらの成分すべてが現れなければナラナイが，その順序は任意である。
◎
A double ampersand (&amp;&amp;) separates two or more components, all of which must occur, in any order.
</dd>

	<dt id="comb-any">二重~縦線（ `||^g ）</dt>
	<dd>
複数の選択肢の区切り
— それらのうち 1 個以上が現れなければナラナイが，その順序は任意である。
◎
A double bar (||) separates two or more options: one or more of them must occur, in any order.
</dd>

	<dt id="comb-one">縦線（ `|^g ）</dt>
	<dd>
複数の排他的選択肢の区切り：
それらのうち，きっかり 1 個が現れなければナラナイ。
◎
A bar (|) separates two or more alternatives: exactly one of them must occur.
</dd>

	<dt>角括弧（ `[<var>…</var>]^g ）</dt>
	<dd>
~group化を表す。
◎
Brackets ([ ]) are for grouping.
</dd>

</dl>

<p>
これらの結合順位は優先度の高いものから、［
並記, 二重~ampersand, 二重~縦線, 縦線
］の順になる。
したがって，次の 2 つの行は等価になる：
◎
Juxtaposition is stronger than the double ampersand, the double ampersand is stronger than the double bar, and the double bar is stronger than the bar. Thus, the following lines are equivalent:
</p>

<pre class="grammar">
  a b   |   c ||   d ~AMP~AMP   e f
[ a b ] | [ c || [ d ~AMP~AMP [ e f ]]]
</pre>

<p>
並び替え可能な結合子（ `||$g, `~AMP~AMP$g ）に対しては、文法における順序は重要でない
— 同じ~group内の各~成分は、どのような順序で記されてもヨイ。
したがって，次の 2 つの行は等価になる：
◎
For reorderable combinators (||, &amp;&amp;), ordering of the grammar does not matter:
components in the same grouping may be interleaved in any order. Thus, the following lines are equivalent:
</p>

<pre class="grammar">
a || b || c
b || a || c
</pre>

		</section>
		<section id="component-multipliers">
<h3 title="Component Value Multipliers">2.3. 成分~値の量指定子</h3>

<p>
どの［
値~型 ／ ~keyword ／ 角括弧で括られた~group
］にも
— 以下、これらを “構文単位” と総称する —
次のいずれかの修飾子が後置され得る：
◎
Every type, keyword, or bracketed group may be followed by one of the following modifiers:
</p>

<dl>
	<dt id="mult-zero-plus">~asterisk（ `*^g ）</dt>
	<dd>
直前の構文単位の 0 回以上の出現を指示する。
◎
An asterisk (*) indicates that the preceding type, word, or group occurs zero or more times.
</dd>

	<dt id="mult-one-plus">正符号（ `+^g ）</dt>
	<dd>
直前の構文単位の 1 回以上の出現を指示する。
◎
A plus (+) indicates that the preceding type, word, or group occurs one or more times.
</dd>

	<dt id="mult-opt">疑問符（ `?^g ）</dt>
	<dd>
直前の構文単位が省略可能であること（すなわち 0 回または 1 回の出現）を指示する。
◎
A question mark (?) indicates that the preceding type, word, or group is optional (occurs zero or one times).
</dd>

	<dt id="mult-num">波括弧に括られた整数（ `{~vA}^g ）</dt>
	<dd>
直前の構文単位の ~vA 回の出現を指示する。
◎
A single number in curly braces ({A}) indicates that the preceding type, word, or group occurs A times.
</dd>

	<dt id="mult-num-range">波括弧に括られた~comma区切りの整数の組（ `{~vA,~vB}^g ）</dt>
	<dd>
直前の構文単位の ~vA 回から ~vB 回までの出現を指示する。
~vB は省略されてもよく（
`{~vA,}^g
），その場合は ~vA 回 以上, 
上限なしの出現を指示する。
◎
A comma-separated pair of numbers in curly braces ({A,B}) indicates that the preceding type, word, or group occurs at least A and at most B times. The B may be omitted ({A,}) to indicate that there must be at least A repetitions, with no upper bound on the number of repetitions.
</dd>

	<dt id="mult-comma">~hash記号（ `#^g ）</dt>
	<dd>
直前の構文単位が~comma~tokenで区切られた上で 1 回以上 出現することを指示する（~commaの前後に`空白$や~commentが現れてもヨイ）。
これには省略可能な上述の波括弧 形が後続し得る（例えば
<code class="grammar">`length$t#{1,4}</code>
）。
その場合、より精確な出現回数を指示する。
◎
A hash mark (#) indicates that the preceding type, word, or group occurs one or more times, separated by comma tokens (which may optionally be surrounded by white space and/or comments). It may optionally be followed by the curly brace forms, above, to indicate precisely how many times the repetition occurs, like &lt;length&gt;#{1,4}.
</dd>

	<dt id="mult-req">~groupの直後の感嘆符（ `!^g ）</dt>
	<dd>
その~groupが必須であり， 1 個以上の値を生産しなければナラナイことを指示する。
すなわち、~group内の各項は文法により個別的に省略し得るとしても，全体としては成分~値をすべて省略してはならない。
◎
An exclamation point (!) after a group indicates that the group is required and must produce at least one value; even if the grammar of the items within the group would otherwise allow the entire contents to be omitted, at least one component value must not be omitted.
</dd>

</dl>

<p>
繰返される（ `*$g, `+$g, `#$g で指示される）成分~値に対しては、~UAは、少なくとも 20 回以上の繰返nを~supportするモノトスル。
~prop値が，~supportする数を超える成分の繰返nを包含する場合、その宣言は，無効であったかのように無視するモノトスル。
◎
For repeated component values (indicated by *, +, or #), UAs must support at least 20 repetitions of the component. If a property value contains more than the supported number of repetitions, the declaration must be ignored as if it were invalid.
</p>

		</section>
		<section id="combinator-multiplier-patterns">
<h3 title="Combinator and Multiplier Patterns">2.4. 結合子と量指定子の~pattern</h3>

<p>
特定の個数と順序による，複数の独立な`成分~値$を組合せるための、共通な仕方がいくつかある。
特に、仕様の策定者が，［
作者は、成分~値のある集合の中から，［
文法に指定された順序，または任意の順序
］で［
0 個以上／ 1 個以上／すべて
］を選定しなければナラナイ
］ことを表出したいことは、よくある。
◎
There are a small set of common ways to combine multiple independent component values in particular numbers and orders. In particular, it’s common to want to express that, from a set of component value, the author must select zero or more, one or more, or all of them, and in either the order specified in the grammar or in any order.
</p>

<p>
これらはすべて、`結合子$や`量指定子$による単純な~patternを利用して，容易に表出できる：
◎
All of these can be easily expressed using simple patterns of combinators and multipliers:
</p>

<table>
<thead><tr><th><th title="in order">指定された順序
<th title="any order">任意の順序
</thead>

<tbody><tr><th title="zero or more">0 個以上
<td>`~vA? ~vB? ~vC?^g
<td>`~vA? || ~vB? || ~vC?^g

<tr><th title="one or more">1 個以上
<td>`[ ~vA? ~vB? ~vC? ]!^g
<td>`~vA || ~vB || ~vC^g

<tr><th title="all">すべて
<td>`~vA ~vB ~vC ^g
<td>`~vA ~AMP~AMP ~vB ~AMP~AMP ~vC^g
</tbody>

</table>

<p>
順序が “任意” のものは，どれも結合子を利用して表出される一方、
“指定された順序” のものは，どれも並記になっていることに注意。
◎
Note that all of the "any order" possibilities are expressed using combinators, while the "in order" possibilities are all variants on juxtaposition.
</p>

		</section>
		<section id="component-whitespace">
<h3 title="Component Values and White Space">2.5. 成分~値と空白</h3>

<p>
他が指定されない限り、`空白$や~commentが，［
上の`結合子$や`量指定子$を利用して結合された成分の前後や, その各~成分の合間
］に現れてもヨイ。
◎
Unless otherwise specified, white space and/or comments may appear before, after, and/or between components combined using the above combinators and multipliers.
</p>

<p class="note">注記：
多くの場合、互いの~tokenを判別するため，成分~間の~spaceが~~実際に`要求される^em。
例えば，値 `1em2em^v は、数字 `1^v と無効な単位~識別子 `em2em^u を伴う，単独の `dimension-token$t として構文解析されることになる。
この場合、 2 個の長さ値［
`1em^v, `2em^v
］として構文解析されるためには，数字 `2^v の前に~spaceが要求される。
◎
Note: In many cases, spaces will in fact be required between components in order to distinguish them from each other. For example, the value 1em2em would be parsed as a single &lt;dimension-token&gt; with the number 1 and the identifier em2em, which is an invalid unit. In this case, a space would be required before the 2 to get this parsed as the two lengths 1em and 2em.
</p>

		</section>
		<section id="value-examples">
<h3 title="Property Value Examples">2.6. ~prop値の例</h3>

<p>
いくつかの~propについて，対応する値~定義の欄, および値の例を下に示す：
◎
Below are some examples of properties with their corresponding value definition fields
</p>

<div class="example">

<table id="propvalues" class="grid-table">
<thead><tr><th title="Property">~prop
<th title="Value definition field">値~定義の欄
<th title="Example value">値の例
</thead>

<tbody><tr><td>`orphans$p
<td class="prod">`integer^t
<td>`3^v

<tr><td>`text-align$p
<td class="prod">`left^v | `right^v | `center^v | `justify^v
<td>`center^v

<tr><td>`padding-top$p
<td class="prod">`length^t | `percentage^t
<td>`5%^v

<tr><td>`outline-color$p
<td class="prod">`color^t | `invert^v
<td>`#fefefe^v

<tr><td>`text-decoration$p
<td class="prod">`none^v | `underline^v || `overline^v || `line-through^v || `blink^v
<td>`overline underline^v

<tr><td>`font-family$p
<td class="prod">[ `family-name^t | `generic-family^t ]#
<td>`"Gill Sans", Futura, sans-serif^v

<tr><td>`border-width$p
<td class="prod">[ `length^t | `thick^v | `medium^v | `thin^v ]{1,4}
<td>`2px medium 4px^v

<tr><td>`box-shadow$p
<td class="prod">[ `inset^v? ~AMP~AMP `length^t{2,4} ~AMP~AMP `color^t? ]# | `none^v
<td>`3px 3px rgba(50%, 50%, 50%, 50%), lemonchiffon 0 0 4px inset^v

</tbody></table>

</div>

		</section>
	</section>
	<section id="combining-values">
<h2 title="Combining Values: Interpolation, Addition, and Accumulation">3. 値の結合-法： 補間, 加算, 累積</h2>

<p>
例えば［
<a href="~TRANSITION">遷移</a> ／
<a href="~CSSANIM">~animation</a>
］などにおける一部の手続きは、
2 個の~CSS~prop値を
`結合-@
する。
所与の，ある~propの 2 個の`算出d値$
( 値a, 値b )
を結合して，算出d値 %結果値 を得る演算【の種別】として、次のものが定義される
【具体的な演算-法は、一般に，個々の値~型ごとに定義される】：
◎
Some procedures, for example transitions and animations, combine two CSS property values. The following combining operations—on the two computed values Va and VB yielding the computed value Vresult—are defined:
</p>

<dl>
	<dt>
`補間@
（ `interpolation^en ）
</dt>
	<dd>
<p>
実数 %p に対し，［
区間 [ 値a, 値b ] 内の，距離 %p における中間~値
］を表す %結果値 を生産する
— ［
%p ~EQ 0 ならば 値a になる ／ %p ~EQ 1 ならば 値b になる
］ように~~拘束される下で。
◎
Given two property values Va and VB, produces an intermediate value Vresult at a distance of p along the interval between Va and VB such that p = 0 produces Va and p = 1 produces VB.
</p>

<p>
`~easing関数$の効果に因り， %p の範囲は開区間 (−∞, ∞) にわたる。
よって，この手続きは、閉区間 [0, 1] の外側にある %p に対しても外挿の挙動を定義しなければナラナイ。
◎
The range of p is (−∞, ∞) due to the effect of timing functions. As a result, this procedure must also define extrapolation behavior for p outside [0, 1].
</p>
	</dd>

	<dt>
`加算@
（ `addition^en ）
</dt>
	<dd>
( 値a, 値b )
の総和として %結果値 を返す。
加算が可換でない場合（例えば，行列の乗算）、これらの項の順序も有意になる。
◎
Given two property values Va and VB, returns the sum of the two properties, Vresult. For addition that is not commutative (for example, matrix multiplication) Va represents the first term of the operation and VB represents the second.
</dd>
	<dd class="note">注記：
`加算$は、`補間$の定義に利用される加重平均~関数と同じ用語に基づいて表出できることが多いが，常に該当するとは限らない。
例えば，変形-行列の補間は 行列~成分の分解-法と補間-法を孕む一方で、それらの加算は 行列の乗算に依拠する。
◎
Note: While addition can often be expressed in terms of the same weighted sum function used to define interpolation, this is not always the case. For example, interpolation of transform matrices involves decomposing and interpolating the matrix components whilst addition relies on matrix multiplication.
</dd>

	<dt>
`累積@
（ `accumulation^en ）
</dt>
	<dd>
［
値b は 値a からの差分として扱われる
］ように結合して得られる %結果値 を返す。
累積が可換でない場合（例えば，合致していない変形-~listの累積）、これらの項の順序も有意になる。
◎
Given two property values Va and VB, returns the result, Vresult, of combining the two operands such that VB is treated as a delta from Va. For accumulation that is not commutative (for example, accumulation of mismatched transform lists) Va represents the first term of the operation and VB represents the second.
</dd>
	<dd class="note">注記：
実数や長さなど，多くの型の~animation用の`累積$は、`加算$と一致するように定義される。
この 2 つの定義が相違する共通的な事例として，~listに基づく型がある
— そこでは、`加算$は ~listに付加するものとして, `累積$は 成分ごとの加算として定義されることもある。
例えば，~filter~list値【 `filter-value-list$t 】［
`blur(2)^v, `blur(3)^v
］は、`加算-$されるときは `blur(2) blur(3)^v を生産する一方で，`累積-$されるときは `blur(5)^v を生産することになる。
◎
Note: For many types of animation such as numbers or lengths, accumulation is defined to be identical to addition.
◎
A common case where the definitions differ is for list-based types where addition may be defined as appending to a list whilst accumulation may be defined as component-based addition. For example, the filter list values blur(2) and blur(3), when added together would produce blur(2) blur(3), but when accumulated would produce blur(5).
</dd>
</dl>

<p>
これらの演算は、`算出d値$に限り定義される（その結果、例えば `length$t 値［
`15pt^v, `5em^v
］を加算する方法を定義することは，必要とされない
— そのような値は、上の手続きに渡される前に`正準的~単位$の値に解決されることになるので）。
◎
These operations are only defined on computed values. (As a result, it is not necessary to define, for example, how to add a &lt;length&gt; value of 15pt with 5em since such values will be resolved to their canonical unit before being passed to any of the above procedures.)
</p>

<p>
次に該当する値~型の`加算$における %結果値 は、単純に 値a【値b の誤記？】 で与えられるとする
⇒
`加算$用に特定の手続きを定義していない ／
`加法的でない@
ものと定義されている
◎
If a value type does not define a specific procedure for addition or is defined as not additive, its addition operation is simply Vresult = Va.
</p>

<p>
`累積$用に特定の手続きを定義しない値~型の`累積$は、その型の`加算$に一致するとする。
◎
If a value types does not define a specific procedure for accumulation, its accumulation operation is identical to addition.
</p>

	</section>
	<section id="textual-values">
<h2 title="Textual Data Types">4. ~textな~data型</h2>

<p>
`~textな~data型@
は、［
様々な~keyword,
識別子,
文字列（`string$t）,
~URL（ `url$t ）
］を含む。
［
`定義済み~keyword$の大小変換／所与の~prop用に明示的に定義されたもの
］は別として、~Unicode正規化も含め，いかなる正規化も遂行されない
— ~propの［
`指定d値$, `算出d値$
］は、正確に，供された~Unicode値を構文解析した結果になる（他の文字~集合からの変換,
<a href="~CSSSYN#escaping">~escape法</a>
を含む）。
`UNICODE$r `CSS3SYN$r
◎
The textual data types include various keywords and identifiers as well as strings (&lt;string&gt;) and URLs (&lt;url&gt;). Aside from the casing of pre-defined keywords or as explicitly defined for a given property, no normalization is performed, not even Unicode normalization: the specified and computed value of a property are exactly the provided Unicode values after parsing (which includes character set conversion and escaping). [UNICODE] [CSS3SYN]
</p>

<p>
`~CSS識別子@
は、汎用には
`ident@t
で表記される， `ident-token$t `CSS3SYN$r に適合する文字~並びからなる。
識別子は、引用符で括れない
— さもなければ、文字列として解釈されることになる。
~CSS~propは、2 種の`識別子$
— `定義済み~keyword$, <a href="#custom-idents">作者~定義な識別子</a> —
を受容する。
◎
CSS identifiers, generically denoted by &lt;ident&gt;, consist of a sequence of characters conforming to the &lt;ident-token&gt; grammar. [CSS3SYN] Identifiers cannot be quoted; otherwise they would be interpreted as strings. CSS properties accept two classes of identifiers: pre-defined keywords and author-defined identifiers.
</p>

<p class="note">注記：
`ident$t 生成規則は、~prop値の定義~用に意味されたものではない
— 代わりに `custom-ident$t が利用されるベキである。
それは、他の構文上の構成子を簡便に定義するためとして供される。
◎
Note: The &lt;ident&gt; production is not meant for property value definitions—&lt;custom-ident&gt; should be used instead. It is provided as a convenience for defining other syntactic constructs.
</p>

<p>
~textな~data型は、すべて`離散的$に`補間-$され，`加法的でない$。
◎
All textual data types interpolate as discrete and are not additive.
</p>

		<section id="keywords">
<h3 title="Pre-defined Keywords">4.1. 定義済み~keyword</h3>

<p>
値~定義の欄の中では、定義済みな意味を伴う
`~keyword@
は，~literalに現れる。
~keywordは`~CSS識別子$ であり、`~ASCII大小無視$の下で解釈される（すなわち、 a 〜 z と A 〜 Z は等価になる）。
◎
In the value definition fields, keywords with a pre-defined meaning appear literally. Keywords are CSS identifiers and are interpreted ASCII case-insensitively (i.e., [a-z] and [A-Z] are equivalent).
</p>

<div class="example">
<p>
例えば，
`border-collapse$p
~propの値~定義は次で与えられる：
◎
For example, here is the value definition for the border-collapse property:
</p>

<table class="propdef"><tbody>
<tr><th>値
<td class="prod">`collapse^v | `separate^v
</tbody></table>

<p>
その用例：
◎
And here is an example of its use:
</p>

<pre class="lang-css">
table { border-collapse: separate }
</pre>
</div>

			<section id="common-keywords">
<h4 title="CSS-wide keywords: initial, inherit and unset">4.1.1. ~CSS全域~keyword： `initial^v, `inherit^v, `unset^v</h4>

<p>
<a href="#component-types">成分~値の型</a>に定義したように、すべての~propは
`~CSS全域~keyword@
を受容する。
これらは、すべての~CSS~propに共通な値の算出法を表現する：
◎
As defined above, all properties accept the CSS-wide keywords, which represent value computations common to all CSS properties.
</p>

<ul>
	<li>
~keyword `initial$v は、~propの`初期~値$として指定されている値を表現する。
◎
The initial keyword represents the value specified as the property’s initial value.＼
</li>
	<li>
~keyword `inherit$v は、要素の親~上の~propの`算出d値$を表現する。
◎
The inherit keyword represents the computed value of the property on the element’s parent.＼
</li>
	<li>
~keyword `unset$v は、~propが継承するかどうかに応じて，
`inherit$v か `initial$v としてふるまう。
◎
The unset keyword acts as either inherit or initial, depending on whether the property is inherited or not.＼
</li>
</ul>

<p>
これらの~keywordは、
`CSS3CASCADE$r にて規範的に定義されている。
◎
All of these keywords are normatively defined in the Cascade module. [CSS3CASCADE]
</p>

<p>
他の~CSS仕様も追加的な ~CSS全域~keywordを定義し得る。
◎
Other CSS specifications can define additional CSS-wide keywords.
</p>

			</section>
		</section>
		<section id="custom-idents">
<h3 title="Author-defined Identifiers: the &lt;custom-ident&gt; type">4.2. 作者~定義な識別子： `custom-ident^t 型</h3>

<p>
一部の~propは、成分~値として，作者~定義な任意な識別子を受容する。
この汎用~data型は
`custom-ident@t
で表記され、その~propの値~定義による`定義済み~keyword$に解釈されないような，任意の妥当な`~CSS識別子$を表現する。
その種の識別子の文字~大小は区別される（符号位置で比較される
— 例えば
`example^v と `EXAMPLE^v
は、異なる, 無関係な, 作者~定義な識別子である）。
◎
Some properties accept arbitrary author-defined identifiers as a component value. This generic data type is denoted by &lt;custom-ident&gt;, and represents any valid CSS identifier that would not be misinterpreted as a pre-defined keyword in that property’s value definition. Such identifiers are fully case-sensitive (meaning they’re compared by codepoint), even in the ASCII range (e.g. example and EXAMPLE are two different, unrelated user-defined identifiers).
</p>

<p>
`~CSS全域~keyword$は，妥当な `custom-ident$t ではない。
予約-済みの全域~keyword `default^v
【 `revert$v 】
もまた，妥当な `custom-ident$t ではない。
`custom-ident$t を利用する仕様は、どの~keywordが
`custom-ident$t から除外されるベキかを明瞭に指定しなければナラナイ
— 例えば、
“その~propの値~定義にて`定義済み~keyword$は除外される”
と記すなど。
除外される~keywordと `~ASCII大小無視$で等しいものも除外される。
◎
The CSS-wide keywords are not valid &lt;custom-ident&gt;s. The default keyword is reserved and is also not a valid &lt;custom-ident&gt;. Specifications using &lt;custom-ident&gt; must specify clearly what other keywords are excluded from &lt;custom-ident&gt;, if any—for example by saying that any pre-defined keywords in that property’s value definition are excluded. Excluded keywords are excluded in all ASCII case permutations.
</p>

<p>
~prop値において，位置により多義的になるような~keywordを構文解析するとき、
`custom-ident$t 生成規則が その~keywordに該当し得るのは，［
その~keywordに該当し得るような，未だ充足されていない生成規則
］が他に無い場合に限られる。
◎
When parsing positionally-ambiguous keywords in a property value, a &lt;custom-ident&gt; production can only claim the keyword if no other unfulfilled production can claim it.
</p>

<p class="example">
例えば、`略式~prop$による宣言
<samp class="css">`animation$p: `ease-in ease-out^v;</samp>
は、`下位prop$による宣言
<samp class="css">`animation-timing-function$p: `ease-in$v;
`animation-name$p: `ease-out$v;</samp>
に等価になる。
`ease-in$v は， `animation-timing-function$p に属する `easing-function$t 生成規則に該当する結果、
`ease-out$v は， `animation-name$p に属する `custom-ident$t 生成規則に該当するようになる。
◎
For example, the shorthand declaration animation: ease-in ease-out is equivalent to the longhand declarations animation-timing-function: ease-in; animation-name: ease-out;. ease-in is claimed by the &lt;easing-function&gt; production belonging to animation-timing-function, leaving ease-out to be claimed by the &lt;custom-ident&gt; production belonging to animation-name.
</p>

<p class="note">注記：
`custom-ident$t を伴う文法を設計するときは、~prop内のどの~keyword値とも競合し得なくなるよう，
`custom-ident$t は 常に
“位置により多義的にならない”
ようにするベキである。
◎
Note: When designing grammars with &lt;custom-ident&gt;, the &lt;custom-ident&gt; should always be "positionally unambiguous", so that it’s impossible to conflict with any keyword values in the property.
</p>

		</section>
		<section id="dashed-idents">
<h3 title="Explicitly Author-defined Identifiers: the &lt;dashed-ident&gt; type">4.3. `明示的に^em作者~定義な識別子： `dashed-ident^t 型</h3>

<p>
一部の文脈は、作者~定義な識別子, ~CSS定義な識別子の`両者^emを受容する。
これは、注意深く取扱わないと，~CSS定義な新たな値を追加するときに困難さを伴い得る
— ~UAは、［
利用-中にある作者~定義な識別子のうち，~CSS定義な新たな識別子に合致しているもの
］は，ごく少数に限られるかどうか既存の用法を調査して、新たな値に~CSS定義な特別な意味を与えても，既存の~pageを壊さないことに賭ける必要がある。
◎
Some contexts accept both author-defined identifiers and CSS-defined identifiers. If not handled carefully, this can result in difficulties adding new CSS-defined values; UAs have to study existing usage and gamble that there are sufficiently few author-defined identifiers in use matching the new CSS-defined one, so giving the new value a special CSS-defined meaning won’t break existing pages.
</p>

<p>
~CSSには，［
まさにこの~~不安を抱えた仕方で，この 2 つの値~空間が混在する
］ような多くの旧来の事例があり、
`dashed-ident$t 型は，［
作者~定義な識別子と~CSS定義な識別子とを判別する容易な仕方になる
］ことが意味される。
◎
While there are many legacy cases in CSS that mix these two values spaces in exactly this fraught way, the &lt;dashed-ident&gt; type is meant to be an easy way to distinguish author-defined identifiers from CSS-defined identifiers.
</p>

<p>
`dashed-ident@t
生成規則は、［
`custom-ident$t であり，常に文字大小区別になる
］ことに加えて，［
2 個の~dash（ `002D^U `HYPHEN-MINUS^cn ）から開始しなければナラナイ
］とする制約も伴う。
◎
The &lt;dashed-ident&gt; production is a &lt;custom-ident&gt;, with all the case-sensitivity that implies, with the additional restriction that it must start with two dashes (U+002D HYPHEN-MINUS).
</p>

<p>
`dashed-ident$t は、もっぱら作者~定義な名前~用の利用に予約される。
~CSSは、 `dashed-ident$t を自前の利用-用に定義することは決してない。
◎
&lt;dashed-ident&gt;s are reserved solely for use as author-defined names. CSS will never define a &lt;dashed-ident&gt; for its own use.
</p>


<p class="example">
例えば，`~custom~prop$は、~CSS定義な~propから判別-可能になる必要がある
— ~CSSには、新たな~propが定期的に追加されるので。
これを許容するため、`~custom~prop$の名前は `dashed-ident$t になることが要求される。
◎
For example, custom properties need to be distinguishable from CSS定義な properties, as new properties are added to CSS regularly. To allow this, custom property names are required to be &lt;dashed-ident&gt;s.
</p>

		</section>
		<section id="strings">
<h3 title="Quoted Strings: the &lt;string&gt; type">4.4. 引用符~付き文字列： `string^t 型</h3>

<p>
`文字列$は
`string@t
で表記され、一重~引用符または二重~引用符で括られた文字~並びからなる。
これらは、 `string-token$t 生成規則 `CSS3SYN$r に対応する。
◎
Strings are denoted by &lt;string&gt; and consist of a sequence of characters delimited by double quotes or single quotes. They correspond to the &lt;string-token&gt; production in the CSS Syntax Module [CSS3SYN].
</p>

<p>
二重~引用符は、（ `"\""^c または `"\22"^c として）`~escape$されない限り，二重~引用符の内側に現れることはできない。
一重~引用符も同様である（ `'\''^c または `'\27'^c ）：
◎
Double quotes cannot occur inside double quotes, unless escaped (as "\"" or as "\22"). Analogously for single quotes ('\'' or '\27').
</p>

<div class="example">
<pre class="lang-css">
content: "これは '文字列'。";
content: "これは \"文字列\"。";
content: 'これは "文字列"。';
content: 'これは \'文字列\'。';
</pre>
<!-- 
content: "this is a 'string'.";
content: "this is a \"string\".";
content: 'this is a "string".';
content: 'this is a \'string\'.';
-->
</div>

<p>
美観その他の理由で，文字列を複数~行lに分割することもアリである。
ただし，そのような場合、改行文字~自身が~backslash（ \ ）で~escapeされる必要がある。
それらの改行文字は、後で文字列から除去される。
例えば、次の 2 つの選択子は正確に同じになる：
◎
It is possible to break strings over several lines, for aesthetic or other reasons, but in such a case the newline itself has to be escaped with a backslash (\). The newline is subsequently removed from the string. For instance, the following two selectors are exactly the same:
</p>

<div class="example">

<pre class="lang-css">
a[title="そんなに長いタイ\
トルではないが"] {/*...*/}

a[title="そんなに長いタイ<!-- \ -->トルではないが"] {/*...*/}
</pre>
<!-- 
a[title="a not s\
o very long title"] {/*...*/}
a[title="a not so very long title"] {/*...*/}
-->
</div>

<p>
文字列は 改行文字を直に表現できないので、改行文字を含ませるためには "`\A^c" ~escapeを利用する。
（ 16 進数 A は~Unicode文字 `000A^U `LINE FEED^cn であるが、~CSSにおいては，一般概念としての “改行文字” を表現する。）
◎
Since a string cannot directly represent a newline, to include a newline in a string, use the escape "\A". (Hexadecimal A is the line feed character in Unicode (U+000A), but represents the generic notion of "newline" in CSS.)
</p>

		</section>
		<section id="urls">
<h3 title="Resource Locators: the &lt;url&gt; type">4.5. 資源の所在指定子： `url^t 型</h3>

<p>
`url@f
関数-記法は、 `url$t で表記され，資源を指す`~URL$を表現する。
`url$t の代表的な構文は：
◎
The url() functional notation, denoted by &lt;url&gt;, represents a URL, which is a pointer to a resource. The typical syntax of a &lt;url&gt; is:
</p>

<pre class="prod">
`url@t = url( `string$t `url-modifier$t`*$g )
</pre>

<div class="example">
<p>
背景~画像として利用される~URLの例を下に示す：
◎
Below is an example of a URL being used as a background image:
</p>

<pre class="lang-css">
body { background: url("http://www.example.com/pinkish.gif") }
</pre>

</div>

<p>
`url$t は，~URL自身を括る引用符を省いて記されてもヨイ。
（その構文は、 `url-token$t として`特別に構文解析され$る。
`CSS3SYN$r
）
◎
A &lt;url&gt; may alternately be written without quotation marks around the URL itself, in which case it is specially-parsed as a &lt;url-token&gt; [CSS3SYN].
</p>

<div class="example">
<p>
例えば，次の 2 つの宣言は、同じになる：
◎
For example, the following declarations are identical:
</p>

<pre class="lang-css">
background: url("http://www.example.com/pinkish.gif");
background: url(http://www.example.com/pinkish.gif);
</pre>
</div>

<p class="note">注記：
この引用符なしの構文は、 `url-modifier$t 引数を受容しない。
加えて、~URLの中の［
括弧, `空白$, 一重~引用符（ `'^c ）, 二重~引用符（ `"^c ）
］は、~backslash（ `\^c ）で~escapeされなければナラナイ。
~URLの種別にもよるが，これらの文字を `URL$r の~~規定に従って~URL~escapeで記すのもアリである（例えば，先の例に対する
`url(open%28parens)^v
や
`url(close%29parens)^v
）。
◎
Note: This unquoted syntax cannot accept a &lt;url-modifier&gt; argument and has extra escaping requirements: parentheses, whitespace characters, single quotes (') and double quotes (") appearing in a URL must be escaped with a backslash, e.g. url(open\(parens), url(close\)parens). (In quoted &lt;string&gt; url()s, only newlines and the character used to quote the string need to be escaped.) Depending on the type of URL, it might also be possible to write these characters as URL-escapes (e.g. url(open%28parens) or url(close%29parens)) as described in [URL].
</p>

<p>
一部の~CSS文脈（ `import$at など）では、
`url$f で括る代わりに~~素の `string$t で表現することも許容される。
これは、その文字列を包含する `url$f 関数と同じに挙動する。
◎
Some CSS contexts (such as @import) also allow a &lt;url&gt; to be represented by a bare &lt;string&gt;, without the url() wrapper. In such cases the string behaves identically to a url() function containing that string.
</p>

<div class="example">
<p>
例えば，次の 2 つの文は、同じになる：
◎
For example, the following statements are identical:
</p>

<pre class="lang-css">
@import url("base-theme.css");
@import "base-theme.css";
</pre>
</div>

			<section id="relative-urls">
<h4 title="Relative URLs">4.5.1. 相対~URL</h4>

<p>
資源の絶対的な所在に依存しない ~module化された~stylesheetを作成するためには、作者は，相対~URLを利用するベキである。
（ `URL$r にて定義される）相対~URLは、基底~URLを利用して全部的な~URLに解決される。
この処理n用の規範的な~algoは、 RFC 3986, § 3 にて定義されている。
~CSS~stylesheetにおいては、基底~URLは，~source文書のそれではなく，~stylesheet自身のそれである。
文書~内に埋込まれた~stylesheetの基底~URLは、その文書に結付けられている基底~URLになる。
◎
In order to create modular style sheets that are not dependent on the absolute location of a resource, authors should use relative URLs. Relative URLs (as defined in [URL]) are resolved to full URLs using a base URL. RFC 3986, section 3, defines the normative algorithm for this process. For CSS style sheets, the base URL is that of the style sheet itself, not that of the styled source document. Style sheets embedded within a document have the base URL associated with their container.
</p>

<p class="note">注記：
~HTML文書においては、
<a href="~HTMLurl#dynamic-changes-to-base-urls">基底~URLは変異-可能</a>
である。
◎
Note: For HTML documents, the base URL is mutable.
</p>

<p>
~propの算出d値に現れる `url$t は、前段落で述べたように，絶対~URLに解決される。
~UAが~URLを絶対~URLに解決できない場合、指定d値がその算出d値になる。
◎
When a &lt;url&gt; appears in the computed value of a property, it is resolved to an absolute URL, as described in the preceding paragraph. The computed value of a URL that the UA cannot resolve to an absolute URL is the specified value.
</p>

<div class="example">
<p>
例えば，次の規則が：
◎
For example, suppose the following rule:
</p>

<pre class="lang-css">
body { background: url("tile.png") }
</pre>

<p>
次の~URLで指名される~stylesheetの中に在るとするとき：
◎
is located in a style sheet designated by the URL:
</p>

<pre>
http://www.example.org/style/basic.css
</pre>

<p>
~source文書の `body^e の背景は、次の~URLで指名される資源の画像で，敷詰められることになる：
◎
The background of the source document’s &lt;body&gt; will be tiled with whatever image is described by the resource designated by the URL:
</p>

<pre>
http://www.example.org/style/tile.png
</pre>

<p>
`body^e を包含している~source文書の~URLに関わらず，同じ画像が利用されることになる。
◎
The same image will be used regardless of the URL of the source document containing the &lt;body&gt;.
</p></div>

				<section id="local-urls">
<h5 title="Fragment URLs">4.5.1.1. 素片~URL</h5>

<p>
~browserによる~URLの取扱いに共通な ある~~極端さに対処するため、~CSSには，素片のみの~url用に特別な挙動がある。
◎
To work around some common eccentricities in browser URL handling, CSS has special behavior for fragment-only urls.
</p>

<p>
`url$f の値が文字 `0023^U `NUMBER SIGN^cn （ `#^c ）から開始する場合、その `url$f の
`局所~url~flag@
【既定では ~F 】
を ~T にした下で、通常の~URLに対するときのように構文解析する。
◎
If a url()’s value starts with a U+0023 NUMBER SIGN (#) character, parse it as per normal for URLs, but additionally set the local url flag of the url().
</p>

<p>
［
`局所~url~flag$が ~T にされた `url$f
］を照合するときは、~URLの素片~以外はすべて無視した上で，その素片を現在の［
相対~URLの解決-時に用いる文書
］に対して解決する。
この参照は、常に（他の文書でなく）同じ文書~内として扱うモノトスル。
◎
When matching a url() with the local url flag set, ignore everything but the URL’s fragment, and resolve that fragment against the current document that relative URLs are resolved against. This reference must always be treated as same-document (rather than cross-document).
</p>

<p>
［
`局所~url~flag$が ~T にされた `url$f
］を`直列化-$した結果は、素片のみでなければナラナイ。
◎
When serializing a url() with the local url flag set, it must serialize as just the fragment.
</p>

<details class="note">
<summary>“~browserの~~極端さ” とは？
◎
What “browser eccentricities”?
</summary>

<p>
理論的には，~browserは、文書の基底~URLが変化したとき（ `base$e 要素の変異や `pushState()$c の call を通してなど）には、素片のみの~URLも含め，どの相対~URLも解決し直すベキである。
しかしながら，そうするベキでない事例も多い
— 素片のみの~URLは、特別に取扱わなければ，いきなり（以前の基底~URLを指す）他の文書への参照になり、それらを利用する箇所の多くを壊すことになるので。
◎
Theoretically, browsers should re-resolve any relative URLs, including fragment-only URLs, whenever the document’s base URL changes (such as through mutation of the base element, or calling pushState()). In many cases they don’t, however, and so without special handling, fragment-only URLs will suddenly become cross-document references (pointing at the previous base URL) and break in many of the places they’re used.
</p>

<p>
素片のみの~URLは、［
現在の文書の~URLが何かに関わらず，現在の文書を基準にする
］ことを，意味論的に明瞭に表出するので、この~hackは，少なくともこれらの事例において期待される挙動を保全する。
◎
Since fragment-only URLs express a clear semantic of wanting to refer to the current document regardless of what its current URL is, this hack preserves the expected behavior at least in these cases.
</p>
</details>

				</section>
			</section>
			<section id="url-empty">
<h4 title="Empty URLs">4.5.2. 空な~URL</h4>

<p>
`url$f の値が（ `url("")^v や `url()^v の様に）空~文字列である場合、その~urlは，無効な資源に解決されるモノトスル（ `about:invalid^c のような~urlに対するとき類似に）
◎
If the value of the url() is the empty string (like url("") or url()), the url must resolve to an invalid resource (similar to what the url about:invalid does).
</p>

<p class="note">注記：
これにより、［
~web~platformの他所における，埋込d資源に対する空~urlの挙動
］に合致することに加え、［
編集時の誤りで `url$f 値が空なままにされたことに因り，~stylesheetや~host文書が再度~要請される
］ような，余計な流通は避けられ、
`url$f がどこに現れようが，資源は ほぼ確実に無効になるであろう。
~web~platformにおいては，~linkに空~urlをあてがうことも`許容される^emので、~CSSに~hyperlinkを制御する何らかの機能性が加わったときには、この制約は，その種の文脈においては緩められ得る。
◎
Note: This matches the behavior of empty urls for embedded resources elsewhere in the web platform, and avoids excess traffic re-requesting the stylesheet or host document due to editting mistakes leaving the url() value empty, which are almost certain to be invalid resources for whatever the url() shows up in. Linking on the web platform does allow empty urls, so if/when CSS gains some functionality to control hyperlinks, this restriction can be relaxed in those contexts.
</p>

			</section>
			<section id="url-modifiers">
<h4 title="URL Modifiers">4.5.3. ~URL修飾子</h4>

<p>
`url$f 関数は、~URLの意味や解釈をいくぶん変える
`url-modifier@t
を追加的に指定することも~supportする。
`url-modifier$t は、［
`ident$t または `関数-記法$
］の いずれかである。
◎
The url() function supports specifying additional &lt;url-modifier&gt;s, which change the meaning or the interpretation of the URL somehow. A &lt;url-modifier&gt; is either an &lt;ident&gt; or a functional notation.
</p>

<p>
この仕様は、 `url-modifier$t を定義しない — 他の仕様が定義するであろう。
◎
This specification does not define any &lt;url-modifier&gt;s, but other specs may do so.
</p>

<p class="note">注記：
引用符や `url$f で括られていない `url$t には、
`url-modifier$t は受容されない。
◎
Note: A &lt;url&gt; that is either unquoted or not wrapped in url() notation cannot accept any &lt;url-modifier&gt;s.
</p>

			</section>
		</section>
	</section>
	<section id="numeric-types">
<h2 title="Numeric Data Types">5. 数量-~data型</h2>

<p>
数量-~data型は、［
数量／~index／位置
］などの値を表現するために利用される。
構文上は，数量（数的な側面）を表出するような変種がいくつも存在し得るが、［
`指定d値$ ／ `算出d値$
］は，所与の数量-値における これらの変種を判別しない
— それは、構文上の表現ではなく，値の抽象的な数量を表現する。
◎
Numeric data types are used to represent quantities, indexes, positions, and other such values. Although many syntactic variations can exist in expressing the quantity (numeric aspect) in a given numeric value, the specified and computed value do not distinguish these variations: they represent the value’s abstract quantity, not its syntactic representation.
</p>

<p>
`数量-~data型@
は、［
`integer$t,
`number$t,
`percentage$t
］, および次に挙げる様々な`次元$を含む
⇒
`length$t,
`angle$t,
`time$t,
`frequency$t,
`resolution$t
◎
The numeric data types include &lt;integer&gt;, &lt;number&gt;, &lt;percentage&gt;, and various dimensions including &lt;length&gt;, &lt;angle&gt;, &lt;time&gt;, &lt;frequency&gt;, and &lt;resolution&gt;.
</p>

<p class="note">注記：
一般用の`次元$は，ここに定義されるが、他の一部の~moduleも，追加的な
— より局所~化された用法を伴う —
~data型を定義する（例： `css-grid-1$r は `fr$u 単位を導入する）。
◎
Note: While general-purpose dimensions are defined here, some other modules define additional data types (e.g. [css-grid-1] introduces fr units) whose usage is more localized.
</p>

		<section id="numeric-ranges">
<h3 title="Range Restrictions and Range Definition Notation">5.1. 範囲の制約と範囲~定義の記法</h3>

<p>
~propには、数量-値を一定~範囲に制約するものもある。
許容d範囲~外の値を伴う宣言は
— 他が指定されない限り —
無効であり，`無視する$モノトスル。
数量-型~記法においては、
`角括弧付き範囲~記法@
を利用して，範囲~制約を注釈できる。
それは、山括弧の合間の，型を識別する~keywordの後に
`[最小v, 最大v]^g
と記され，閉区間を成す範囲 { 最小v 〜 最大v } を指示する。
例えば， `integer [0,10]$t は、範囲 { 0 〜 10 } に入る整数を指示する。
◎
Properties can restrict numeric values to some range. If the value is outside the allowed range, then unless otherwise specified, the declaration is invalid and must be ignored. Range restrictions can be annotated in the numeric type notation using CSS bracketed range notation—[min,max]—within the angle brackets, after the identifying keyword, indicating a closed range between (and including) min and max. For example, &lt;integer [0,10]&gt; indicates an integer between 0 and 10, inclusive.
</p>

<p class="note">注記：
~CSS値は，一般に開区間を成す範囲を許容しないので、角括弧~記法のみが利用される。
◎
Note: CSS values generally do not allow open ranges; thus only square-bracket notation is used.
</p>

<p>
~CSSは、理論上は，すべての値~型に対し無限な［
精度, 範囲
］を~supportするが、現実の実装においては有限になる。
~UAは、適度に有用な［
精度, 範囲
］を~supportするベキである。
理想上は制限されない範囲は、［
∞, −∞
］のうち適切な方を利用して指示される。
◎
CSS theoretically supports infinite precision and infinite ranges for all value types; however in reality implementations have finite capacity. UAs should support reasonably useful ranges and precisions. Range extremes that are ideally unlimited are indicated using ∞ or −∞ as appropriate.
</p>

<p>
`角括弧付き範囲~記法$を利用して, あるいは~propの記述にて，範囲が指示されていない場合、
`[−∞,∞]^g
と見做される。
◎
If no range is indicated, either by using the bracketed range notation or in the property description, then [−∞,∞] is assumed.
</p>

<p class="note">注記：
これを書いた時点では，`角括弧付き範囲~記法$は まだ日が浅いので、ほとんどの~CSS仕様は，範囲~制限を注釈文でしか述べていない（例えば，
“負な値は許容されない”
や
“負な値は妥当でない（無効）”
は、範囲
`[0, ∞]^g
を指示する）。
これは、~~制限を~~緩めるものではない。
◎
Note: At the time of writing, the bracketed range notation is new; thus in most CSS specifications any range limitations are described only in prose. (For example, “Negative values are not allowed” or “Negative values are invalid” indicate a [0,∞] range.) This does not make them any less binding.
</p>

		</section>
		<section id="integers">
<h3 title="Integers: the &lt;integer&gt; type">5.2. 整数： `integer^t 型</h3>

<p>
整数~値は
`integer@t
で表記される。
◎
Integer values are denoted by &lt;integer&gt;.
</p>

<p>
`整数@
は、~literalには
1 個以上の 10 進~数字（ `0^c 〜 `9^c ）の並びで記され，
`number-token$t 生成規則 `CSS3SYN$r の下位集合に対応する。
整数の先頭には，符号nを指示する［
`-^c ／ `+^c
］が前置されてもヨイ。
◎
When written literally, an integer is one or more decimal digits 0 through 9 and corresponds to a subset of the &lt;number-token&gt; production in the CSS Syntax Module [CSS3SYN]. The first digit of an integer may be immediately preceded by - or + to indicate the integer’s sign.
</p>

			<section id="combine-integers">
<h4 title="Combination of &lt;integer&gt;">5.2.1. `integer^t の結合n</h4>

<p>
`integer$t の`補間$における %結果値 は次で定義される
⇒
`number$t の`補間-$を用いて得られた結果を最も近い整数に丸める
— そのような整数が 2 つある場合は正な無限大に近い方へ丸めるとする —
ことにより， `integer^t に変換した結果
◎
Interpolation of &lt;integer&gt; is defined as Vresult = round((1 - p) × Va + p × Vb); that is, interpolation happens in the real number space as for &lt;number&gt;s, and the result is converted to an &lt;integer&gt; by rounding to the nearest integer, with values halfway between adjacent integers rounded towards positive infinity.
</p>

<p>
`integer$t の`加算$における %結果値 は次で定義される
⇒
値a ~PLUS 値b
◎
Addition of &lt;number&gt; is defined as Vresult = Va + Vb
</p>

			</section>
		</section>
		<section id="numbers">
<h3 title="Real Numbers: the &lt;number&gt; type">5.3. 実数： `number^t 型</h3>

<p>
実数~値は
`number@t
で表記され、小数部を伴い得る実数（ `real number^en ）を表現する。
◎
Number values are denoted by &lt;number&gt;, and represent real numbers, possibly with a fractional component.
</p>

<div class="p">
<p>
`実数@
は、~literalには，`整数$として, または次の並びとして記される：
</p>

<ol><li>`整数$
</li><li>~dot（ `.^c ）
</li><li>1 個以上の 10 進~数字
</li><li>
<p>
省略可能な，次の並びによる指数部†：
</p>
	<ol><li>文字［ `e^c または `E^c ］
	</li><li>`整数$
	</li></ol>
</li></ol>

<p>
`実数$は、 `number-token$t 生成規則 `CSS3SYN$r に対応する。
整数と同じく、実数の先頭には，符号nを指示する［
`-^c ／ `+^c
］が前置されてもヨイ††。
</p>

<p class="trans-note">【†
指数部は CSS2.1 までは許容されておらず，この仕様による拡張と見られる（例えば， CSS Transform による SVG 関連の~propに対する拡張に適応するための）。
】【††
指数部の整数の先頭にも。
】【
`number^t を意味する `number^en は，より限定的に “~~実数” と訳している（今後，例えば `number^t が虚数にまで拡張されることは まずないであろう）。
】</p>

◎
When written literally, a number is either an integer, or zero or more decimal digits followed by a dot (.) followed by one or more decimal digits and optionally an exponent composed of "e" or "E" and an integer. It corresponds to the &lt;number-token&gt; production in the CSS Syntax Module [CSS3SYN]. As with integers, the first character of a number may be immediately preceded by - or + to indicate the number’s sign.

</div>

<p>
値
`zero@t
は、値 0 をとる，~literalな`実数$を表現する。
単に値 0 の `number$t に評価される式（例えば `calc(0)^v ）は、
`zero$t には合致しない
— 合致するのは~literalな `number-token$t に限られる。
◎
The value &lt;zero&gt; represents a literal number with the value 0. Expressions that merely evaluate to a &lt;number&gt; with the value 0 (for example, calc(0)) do not match &lt;zero&gt;; only literal &lt;number-token&gt;s do.
</p>

			<section id="combine-numbers">
<h4 title="Combination of &lt;number&gt;">5.3.1. `number^t の結合n</h4>

<p>
`number$t の`補間$における %結果値 は次で定義される
⇒
( 1 ~MINUS %p ) ~MUL 値a ~PLUS %p ~MUL 値b
◎
Interpolation of &lt;number&gt; is defined as Vresult = (1 - p) × Va + p × Vb
</p>

<p>
`number$t の`加算$における %結果値 は次で定義される
⇒
値a ~PLUS 値b
◎
Addition of &lt;number&gt; is defined as Vresult = Va + Vb
</p>

			</section>
		</section>
		<section id="dimensions">
<h3 title="Numbers with Units: dimension values">5.4. 単位を伴う実数： 次元~付きの値</h3>

<p>
一般~用語としての
`次元@
（ `dimension^en, 計量の次元, ~~寸法）は、単位~付きの実数であり，
`dimension@t
で表記される。
◎
The general term dimension refers to a number with a unit attached to it; and is denoted by &lt;dimension&gt;.
</p>

<p>
`次元$は、~literalには［
`実数$, `識別子$である単位~識別子
］の並びで記される。
これは、 `dimension-token$t 生成規則 `CSS3SYN$r に対応する。
~keyword同様，単位~識別子も `~ASCII大小無視$である。
◎
When written literally, a dimension is a number immediately followed by a unit identifier, which is an identifier. It corresponds to the &lt;dimension-token&gt; production in the CSS Syntax Module [CSS3SYN]. Like keywords, unit identifiers are ASCII case-insensitive.
</p>

<p>
~CSSでは、［
距離（ `length$t ）,
時間長（ `time$t ）,
周波数（ `frequency$t ）,
解像度（ `resolution$t ）,
その他の数量
］に， `dimension$t を利用する。
◎
CSS uses &lt;dimension&gt;s to specify distances (&lt;length&gt;), durations (&lt;time&gt;), frequencies (&lt;frequency&gt;), resolutions (&lt;resolution&gt;), and other quantities.
</p>

			<section id="compat">
<h4 title="Compatible Units">5.4.1. 互換な単位</h4>

<p>
`算出d値$を`直列化-$する `CSSOM$r とき、その中で`互換$な単位を伴う各 値は，それらの`正準的~単位$による値に（ある静的な乗算的-係数を通して）変換される。
所与の単位どうしが
`互換@
であるとは、ある係数（
`px$u と `in$u との間の 96:1 の様な係数や，
`font-size$p の算出d値による `em$u と `px$u との間の係数など
）で互いに~~換算できることを意味する。
`互換$な単位たちが成す各~groupには、その中のある単位が
`正準的~単位@
として定義される。
【理論的には、そのような~groupが単独の単位のみからなる（他に互換な単位は無い）こともあり得る — その場合の正準的~単位はその単位~自身になる。】
◎
When serializing computed values [CSSOM], compatible units (those related by a static multiplicative factor, like the 96:1 factor between px and in, or the the computed font-size factor between em and px) are converted into a single canonical unit. Each group of compatible units defines which among them is the canonical unit that will be used for serialization.
</p>

<p>
［
`解決d値$のうち，`使用~値$を与えるもの
］を直列化する際には、長さを表現する すべての値~型（百分率, 実数, ~keyword, 等々）は，長さに`互換$と見なされる。
同様に，`使用~値$を返すような将来の API は、［
距離／時間長／周波数／等々
］を表現するどの値も，関連な`次元$の~groupに`互換$と見なした上で，それに則って正準化しなければナラナイ。
◎
When serializing resolved values that are used values, all value types (percentages, numbers, keywords, etc.) that represent lengths are considered compatible with lengths. Likewise any future API that returns used values must consider any values represent distances/durations/frequencies/etc. as compatible with the relevant class of dimensions, and canonicalize accordingly.
</p>

			</section>
			<section id="combine-dimensions">
<h4 title="Combination of Dimensions">5.4.2. 次元の結合n</h4>

<p>
`互換$な`次元$（例えば， 2 個の `length$t 値）の`補間$における %結果値 は次で定義される
⇒
( 1 ~MINUS %p ) ~MUL 値a ~PLUS %p ~MUL 値b
◎
Interpolation of compatible dimensions (for example, two &lt;length&gt; values) is defined as Vresult = (1 - p) × Va + p × Vb
</p>

<p>
`互換$な`次元$の`加算$における %結果値 は次で定義される
⇒
値a ~PLUS 値b
◎
Addition of compatible dimensions is defined as Vresult = Va + Vb
</p>
			</section>
		</section>
		<section id="percentages">
<h3 title="Percentages: the &lt;percentage&gt; type">5.5. 百分率： `percentage^t 型</h3>

<p>
百分率~値は
`percentage@t
で表記され、別の基準~値に対する割合を指示する。
◎
Percentage values are denoted by &lt;percentage&gt;, and indicates a value that is some fraction of another reference value.
</p>

<p>
`百分率@
は、~literalには［
`実数$,
~percent記号（ `%^u ）
］の並びで記される。
`百分率$は、 `percentage-token$t 生成規則 `CSS3SYN$r に対応する。
◎
When written literally, a percentage consists of a number immediately followed by a percent sign %. It corresponds to the &lt;percentage-token&gt; production in the CSS Syntax Module [CSS3SYN].
</p>

<p class="trans-note">【
“割合” , “パーセンテージ” 等と訳されることも多いが、単位に~percent記号が利用されつつ 百分率でない尺度による割合を表すことは，今後も含めて まず~~考えられないので、より限定的に “百分率” と記すことにする（語源的にも “per-cent” ）。
】</p>

<p>
百分率~値は常に，例えば長さなど, 別の数量に相対的になる。
百分率を値に許容する 各種~propは、それが基準にする数量も定義する。
この数量は、［
同じ要素の別の~prop,
先祖~要素の~prop,
`整形~文脈$における計量（例えば，`包含塊$の横幅）,
他の何か
］になり得る。
◎
Percentage values are always relative to another quantity, for example a length. Each property that allows percentages also defines the quantity to which the percentage refers. This quantity can be a value of another property for the same element, the value of a property for an ancestor element, a measurement of the formatting context (e.g., the width of a containing block), or something else.
</p>

			<section id="combine-percentages">
<h4 title="Combination of &lt;percentage&gt;">5.5.1. `percentage^t の結合n</h4>

<p>
`percentage$t の`補間$における %結果値 は次で定義される
⇒
( 1 ~MINUS %p ) ~MUL 値a ~PLUS %p ~MUL 値b
◎
Interpolation of &lt;percentage&gt; is defined as Vresult = (1 - p) × Va + p × Vb
</p>

<p>
`percentage$t の`加算$における %結果値 は次で定義される
⇒
値a ~PLUS 値b
◎
Addition of &lt;percentage&gt; is defined as Vresult = Va + Vb
</p>

			</section>
		</section>
		<section id="mixed-percentages">
<h3 title="Mixing Percentages and Dimensions">5.6. 百分率と次元の混合法</h3>

<p>
`percentage$t が 同じ`成分~値$位置にある`次元$と同じ数量を表現できる所では、 `calc$f 式の中でそれらを組合せることもでき、~prop文法では，次の簡便な記法を利用できる：
◎
In cases where a &lt;percentage&gt; can represent the same quantity as a dimension in the same component value position, and can therefore be combined with them in a calc() expression, the following convenience notations may be used in the property grammar:
</p>

<dl>
	<dt>`length-percentage@t</dt>
	<dd>
<code class="prod">[ `length$t | `percentage$t ]</code>
に等価。
この `percentage$t は `length$t に解決される。
◎
Equivalent to [ &lt;length&gt; | &lt;percentage&gt; ], where the &lt;percentage&gt; will resolve to a &lt;length&gt;.
</dd>

	<dt>`frequency-percentage@t</dt>
	<dd>
<code class="prod">[ `frequency$t | `percentage$t ]</code>
に等価。
この `percentage$t は `frequency$t に解決される。
◎
Equivalent to [ &lt;frequency&gt; | &lt;percentage&gt; ], where the &lt;percentage&gt; will resolve to a &lt;frequency&gt;.
</dd>

	<dt>`angle-percentage@t</dt>
	<dd>
<code class="prod">[ `angle$t | `percentage$t ]</code>
に等価。
この `percentage$t は `angle$t に解決される。
◎
Equivalent to [ &lt;angle&gt; | &lt;percentage&gt; ], where the &lt;percentage&gt; will resolve to an &lt;angle&gt;.
</dd>

	<dt>`time-percentage@t</dt>
	<dd>
<code class="prod">[ `time$t | `percentage$t ]</code>
に等価。
この `percentage$t は `time$t に解決される。
◎
Equivalent to [ &lt;time&gt; | &lt;percentage&gt; ], where the &lt;percentage&gt; will resolve to a &lt;time&gt;.
</dd>
</dl>

<div class="example">
<p>
例えば、 `width$p ~propは
`length$t, `percentage$t
を受容でき、両者とも距離の計測を表現する。
これは、
<samp class="css">width: `calc(500px + 50%);^v</samp>
は許容されることを意味する
— 2 つの値は，絶対~長さに変換された上で加算されることになる。
包含塊が `1000px^v 幅ならば、
`width^p に対する `50%^v は， `500px^v と等価になる。
`width^p に対する `calc(50% + 500px)^v は、 `calc(500px + 500px)^v と等価になる結果， `1000px^v と等価になる。
◎
For example, the width property can accept a &lt;length&gt; or a &lt;percentage&gt;, both representing a measure of distance. This means that width: calc(500px + 50%); is allowed—both values are converted to absolute lengths and added. If the containing block is 1000px wide, then width: 50%; is equivalent to width: 500px, and width: calc(50% + 500px) thus ends up equivalent to width: calc(500px + 500px) or width: 1000px.
</p>

<p>
一方， `hsl$f 関数の 2 個目, 3 個目の引数を表出できるのは、 `percentage$t しかない。
`calc$f 生成規則は，その場所にも許容されるが、その引数の中で組合できるのは百分率どうしに限られる
— `calc(10% + 20%)^v のように。
◎
On the other hand, the second and third arguments of the hsl() function can only be expressed as &lt;percentage&gt;s. Although calc() productions are allowed in their place, they can only combine percentages with themselves, as in calc(10% + 20%).
</p>

</div>

<p class="note">注記：
仕様は、文法における次元の所の `percentage$t を決して交代させるベキでない
— それらの単位が`互換$でない限り。
◎
Note: Specifications should never alternate &lt;percentage&gt; in place of a dimension in a grammar unless they are compatible.
</p>

<p class="note">注記：
将来においては、必要に応じて，他のある次元 `TYPE^t 用の `TYPE-percentage^t 生成規則も追加され得る。
`number-percentage^t が追加されることは決してない
— `calc$f 内では `number$t と `percentage$t は組合できないので。
◎
Note: More &lt;TYPE-percentage&gt; productions can be added in the future as needed. A &lt;number-percentage&gt; will never be added, as &lt;number&gt; and &lt;percentage&gt; can’t be combined in calc().
</p>

			<section id="combine-mixed">
<h4 title="Combination of Percentage and Dimension Mixes">5.6.1. 混在な百分率と次元の結合n</h4>

<p>
百分率~値と次元~値の組合n（例：
`length-percentage$t,
`frequency-percentage$t,
`angle-percentage$t,
`time-percentage$t,
その他の等価な記法
）の`補間$は、次に従うものと定義される：
◎
Interpolation of percengage-dimension value combinations (e.g. &lt;length-percentage&gt;, &lt;frequency-percentage&gt;, &lt;angle-percentage&gt;, &lt;time-percentage&gt; or equivalent notations) is defined as
</p>

<ul class="switch">
	<li>
値a, 値b とも純粋な `length^t 値の場合
⇒
`length$t の`補間$と等価。
◎
equivalent to interpolation of &lt;length&gt; if both Va and Vb are pure &lt;length&gt; values
</li>
	<li>
値a, 値b とも純粋な `percentage^t 値の場合
⇒
`percentage$t の`補間$と等価
◎
equivalent to interpolation of &lt;percentage&gt; if both Va and Vb are pure &lt;percentage&gt; values
</li>
	<li>
他の場合における %結果値 は次で定義される
⇒
両~値とも，次元~型と百分率（各~場合によっては 0 ）の総和を表現している `calc$f 式に変換してから，各~成分を
—［
`length$t ／ `frequency$t ／ `angle$t ／ `time$t
］として, および
`percentage$t として —
個別に`補間-$した結果
◎
equivalent to converting both values into a calc() expression representing the sum of the dimension type and a percentage (each possibly zero) and interpolating each component individually (as a &lt;length&gt;/&lt;frequency&gt;/&lt;angle&gt;/&lt;time&gt; and as a &lt;percentage&gt;, respectively)
</li>
</ul>

<p>
百分率~値と次元~値の組合nの`加算$は、各~成分を`補間-$する代わりに`加算-$することを除いて`補間$と同じとする。
◎
Addition of &lt;percentage&gt; is defined the same as interpolation except by adding each component rather than interpolating it.
</p>
			</section>
		</section>
		<section id="ratios">
<h3 title="Ratios: the &lt;ratio&gt; type">5.7. 比率： `ratio^t 型</h3>

<p>
比率~値は、
`ratio@t
で表記され，
2 個の数量-値の比率を指示する。
◎
Ratio values are denoted by &lt;ratio&gt;, and indicate a value that is a ratio of two numeric values.
</p>

<p>
~literalに記される
`比率@
の構文は：
◎
When written literally, a ratio has the syntax:
</p>

<pre class="prod">
`ratio$t = `number [0,∞]$t [ / `number [0,∞]$t ]?
</pre>

<p>
2 個目の `number$t は、供されなかった場合の既定は `1^v になるとする。
◎
If only one &lt;number&gt; is provided, the second defaults to 1.
</p>

<p>
`ratio$t の利用は、 2 個の値が何を表すかを指定しなければナラナイ。
しかしながら、一般には，横幅（ 1 個目）と縦幅（ 2 個目）の比率を表すことが期待される。
◎
Uses of &lt;ratio&gt; must specify what the two values are; generally, however, it is expected that they will be a ratio of a width (first) and a height (second).
</p>

<p>
`ratio$t の算出d値は、供された 2 個の実数が成す~pairになるが，両~実数とも 0 の事例においては ( 1, 0 ) が成す~pair（ `1/0^v のときと同じ）になる。
◎
The computed value of a &lt;ratio&gt; is the pair of numbers provided, unless both numbers are zero, in which case the computed value is the pair (1, 0) (same as 1 / 0).
</p>

<p class="note">注記：
`0/0^v 以外のすべての事例では、一般に，比率 `値a/値b^v と除算 `calc(値a / 値b)^v の挙動は整合する
— これは、 `0/0^v の事例でも，そうなるようにする。
◎
Note: This makes the behavior of calc(0 / 0) and 0 / 0 consistent, which is generally true in all other cases.
</p>

<p class="issue">
これは、 `4954$issue にて論じられている。
◎
This is being discussed in Issue 4954.
</p>

<p>
`ratio$t を比較する必要がある場合、
1 個目の実数を 2 個目の実数で除算した結果を比較する。
例えば、 `3/2^v は `2/1^v より小さい
— 前者は 1.5 に解決される一方，後者は 2 に解決されるので（言い換えれば、 “縦長な” 比率は “横長な” 比率より小さい）。
◎
If two &lt;ratio&gt;s need to be compared, divide the first number by the second, and compare the results. For example, 3/2 is less than 2/1, because it resolves to 1.5 while the second resolves to 2. (In other words, "tall" ratios are less than "wide" ratios.)
</p>

			<section id="combine-ratio">
<h4 title="Combination of &lt;ratio&gt;">5.7.1. `ratio$t の結合n</h4>


<p>
`ratio$t の補間は、各~比率の［
1 個目の値（分子）どうし,
2 個目の値（分母）どうし【！or】
］を，いずれも `number$t として補間することにより定義される。
◎
The interpolation of a &lt;ratio&gt; is defined by interpolating the first values (the numerator) of each ratio as a &lt;number&gt;, and the second values (the denominator) or each ratio as a &lt;number&gt;.
</p>

<div class="example">

<p>
例えば， `5/1^v から `3/2^v までを線形に補間するとき、中間点における結果の比率は `4/1.5^v になる。
◎
For example, halfway through a linear interpolation from 5 / 1 to 3 / 2, the result is the ratio 4 / 1.5.
</p>

<p>
これは、結果が縮尺に依存することを意味することに注意。
代わりに `5/1^v から `300/200^v までを補間した場合、終端点は見かけ上は `3/2^v と一致するが、中間点における比率は `152.5/100.5^v になり，終端点の比率 3:2 にごく近くなる。
一般に，一方の比率が他方より ずっと大きい実数で記された場合、補間した結果においては，その比率にごく近い比率が大部分の時間を費やすようなる【~animationの文脈においては】。
◎
Note that this means the results are scale-dependent; interpolating from 5 / 1 to 300 / 200, which have identical-looking endpoints, gives the value 152.5 / 100.5 at the halfway point, which is very close to the 3:2 ratio of the endpoint. In general, if one ratio is written with much larger numbers than the other, the interpolation result spends most of its time very close to the large-number ratio.
</p>

</div>

<p class="issue">
これは、 `4953$issue にて論じられている。
◎
This is being discussed in Issue 4953.
</p>

<p>
`ratio$t の加算はアリでない。
◎
Addition of &lt;ratio&gt;s is not possible.
</p>
			</section>
		</section>
	</section>
	<section id="lengths">
<h2 title="Distance Units: the &lt;length&gt; type">6. 距離の単位： `length^t 型</h2>

<p>
長さは距離の計量を基準にし，~prop定義においては
`length@t
で表記される。
長さは 何らかの`次元$による量である。
◎
Lengths refer to distance measurements and are denoted by &lt;length&gt; in the property definitions. A length is a dimension.
</p>

<p>
長さが 0 のときは、単位~識別子を省略できる（すなわち，構文上は
`number$t の `0^v として表現できる）。
ただし， `0^v は、~propにおいて
`number$t, `length$t
のどちらにも構文解析できる場合（ `line-height$p など）には，
`number$t として構文解析されるモノトスル。
◎
For zero lengths the unit identifier is optional (i.e. can be syntactically represented as the &lt;number&gt; 0). However, if a 0 could be parsed as either a &lt;number&gt; or a &lt;length&gt; in a property (such as line-height), it must parse as a &lt;number&gt;.
</p>

<p>
~propには、長さを一定~範囲に制約するものもある。
許容d範囲~外の値を伴う宣言は無効であり，`無視する$モノトスル。
◎
Properties may restrict the length value to some range. If the value is outside the allowed range, the declaration is invalid and must be ignored.
</p>

<p class="trans-note">【
無効にさせたくない場合、`~math関数$で包装する方法がある。
】</p>

<p>
一部の~propには，長さとして負な値も許容されるが、これは整形-法を複雑化する可能性があり，実装に特有な制限sがあり得る。
実装は、負な長さを~supportしないときは，~support可能な最も近い値に変換するモノトスル。
◎
While some properties allow negative length values, this may complicate the formatting and there may be implementation-specific limits. If a negative length value is allowed but cannot be supported, it must be converted to the nearest value that can be supported.
</p>

<p>
~UAは、長さを`使用~値$として~supportできない所では，`実際の値$において それを近似するモノトスル。
◎
In cases where the used length cannot be supported, user agents must approximate it in the actual value.
</p>

<p>
長さの単位は、相対と絶対の 2 つに分類される。
◎
There are two types of length units: relative and absolute.
</p>

		<section id="relative-lengths">
<h3 title="Relative Lengths">6.1. 相対~単位</h3>

<p>
`相対~長さ単位@
は、別の長さに相対的な長さを指定する。
相対~単位を利用すれば、~stylesheetをある出力~環境から別の環境に見合った縮尺に転用するのも容易になる。
◎
Relative length units specify a length relative to another length. Style sheets that use relative units can more easily scale from one output environment to another.
</p>

<p>
以下のものが相対~単位である：
◎
The relative units are:
</p>

<table class="data">
<caption title="Informative Summary of Relative Units">相対~単位の要約（参考）</caption>

<thead><tr>
<th title="unit">単位
<th title="relative to">相対基準
</thead>

<tbody><tr><td>`em$u
<td>
要素の~font~size
◎
font size of the element

<tr><td>`ex$u
<td>
要素の~fontの`~x-高さ^i
◎
x-height of the element’s font

<tr><td>`cap$u
<td>
要素の~fontの~cap-高さ（大字の名目上の高さ）
◎
cap height (the nominal height of capital letters) of the element’s font

<tr><td>`ch$u
<td>
要素の~fontにおける半角~glyphの平均 文字~送幅
— 文字 “0” （ `0030^U `ZERO^cn ）の~glyphで表現される。
◎
average character advance of a narrow glyph in the element’s font, as represented by the “0” (ZERO, U+0030) glyph

<tr><td>`ic$u
<td>
要素の~fontにおける全角~glyphの平均 文字~送幅
— 文字 “水” （ CJK 表語文字, `6C34^U ）の~glyphで表現される。
◎
average character advance of a fullwidth glyph in the element’s font, as represented by the “水” (CJK water ideograph, U+6C34) glyph 

<tr><td>`rem$u
<td>
根~要素の~font~size
◎
font size of the root element

<tr><td>`lh$u
<td>
要素の行高
◎
line height of the element

<tr><td>`rlh$u
<td>
根~要素の行高
◎
line height of the root element 

<tr><td>`vw$u
<td>
表示域の横幅の 1%
◎
1% of viewport’s width

<tr><td>`vh$u
<td>
表示域の縦幅の 1%
◎
1% of viewport’s height

<tr><td>`vi$u
<td>
表示域の~size
— 根~要素の`行内-軸$におけるそれ —
の 1%
◎
vi 	1% of viewport’s size in the root element’s inline axis

<tr><td>`vb$u
<td>
表示域の~size
— 根~要素の`塊-軸$におけるそれ —
の 1%
◎
vb 	1% of viewport’s size in the root element’s block axis

<tr><td>`vmin$u
<td>
表示域の小さい方の次元の 1%
◎
1% of viewport’s smaller dimension

<tr><td>`vmax$u
<td>
表示域の大きい方の次元の 1%
◎
1% of viewport’s larger dimension

</tbody></table>

<p>
~prop値の`継承$において，要素が継承するのは、親に指定された相対~値ではなく，親の`算出d値$である。
◎
Child elements do not inherit the relative values as specified for their parent; they inherit the computed values.
</p>

			<section id="font-relative-lengths">
<h4 title="Font-relative Lengths: the em, ex, cap, ch, ic, rem, lh, rlh units">6.1.1.  ~fontに相対的な長さ単位： `em^u, `ex^u, `cap^u, `ch^u, `ic^u, `rem^u, `lh^u, `rlh^u</h4>

<p>
`~fontに相対的な長さ@
は、それが利用される要素
— あるいは、 `rem$u, `rlh$u に対しては根~要素 —
の~font計量法を基準にする。
◎
The font-relative lengths refer to the font metrics of the element on which they are used—or, in the case of rem and rlh, the metrics of the root element.
</p>

<figure>
<img
	src="css-values/Typography_Line_Terms.svg"
	style="width:600px; height:150px;"
>
<figcaption>
<p>
共通的な~typographic計量法
— 単語 'Sphinx' には各種~font計量法が注釈されている：
</p>
<ul ><li>~ascender高さ（ `ascender height^en ）： "h" の~serifの上端
</li><li>~cap-高さ（ `cap-height^en ）：視覚的に "S" の上端~近く
</li><li>~x-高さ（ `x-height^en ）：視覚的に "x" の上端~近く
</li><li>基底線（ `baseline^en ）： "S", "h", "i", "n", "x" の下端を通る
</li><li>~descender高さ（ `descender height^en ）： "p" の下端
</li></ul>
◎
The word 'Sphinx' annotated with various font metrics: ascender height, to the top of the h’s serif; cap height, to the visually approximate top of the S; the x height, to the visually approximate top of the x; the baseline, along the bottom of S, h, i, n, and x; and the descender height, to the bottom of the p.
◎
Common typographic metrics
</figcaption></figure>

<dl>
	<dt>`em@u 単位</dt>
	<dd>
この単位が利用された要素の `font-size$p ~propの算出d値に等しい。
◎
Equal to the computed value of the font-size property of the element on which it is used.
</dd>
	<dd class="trans-note">【
`font-size^p 自身に利用された場合にどうなるかは、下に述べられる。以下に挙げる他の単位も同様。
】</dd>

	<dd class="example">
<p>
次の規則：
◎
The rule:
</p>

<pre class="lang-css">
h1 { line-height: 1.2em }
</pre>

<p>
は、 `h1^e 要素の行高が，要素~自身の~font~sizeより 2 割大きくなることを意味する。
一方で：
◎
means that the line height of h1 elements will be 20% greater than the font size of h1 element. On the other hand:
</p>

<pre class="lang-css">
h1 { font-size: 1.2em }
</pre>

<p>
は、 `h1^e 要素の~font~sizeが， `h1^e 要素に継承された~font~sizeの算出d値より 2 割大きくなることを意味する。
◎
means that the font size of h1 elements will be 20% greater than the computed font size inherited by h1 elements.
</p>

	</dd>

	<dt>`ex@u 単位</dt>
	<dd>
`可用な最初の~font$ `CSS3-FONTS$r に利用されている~x-高さに等しい。
~x-高さという呼称は、多くの場合，それが小文字 “x” の高さに等しいことに由来する。
しかしながら、文字 “x” を包含しない~fontにも， `ex$u は定義される。
~fontの~x-高さは、別の仕方で見出すこともできる。
~fontには、~x-高さ用の依拠できる計量法が可用なものもある。
可用でない場合、~UAは小文字~glyphの高さから~x-高さを決定してもヨイ。
アリな経験則として、小文字 "o" の~glyphの下端が基底線の下に突き出ている距離を調べて，その値をその限界~boxの上端から減算して得る方法がある。
~x-高さを決定するのは不可能, または実用的でない場合、値 0.5em と見做されるモノトスル。
◎
Equal to the used x-height of the first available font [CSS3-FONTS]. The x-height is so called because it is often equal to the height of the lowercase "x". However, an ex is defined even for fonts that do not contain an "x". The x-height of a font can be found in different ways. Some fonts contain reliable metrics for the x-height. If reliable font metrics are not available, UAs may determine the x-height from the height of a lowercase glyph. One possible heuristic is to look at how far the glyph for the lowercase "o" extends below the baseline, and subtract that value from the top of its bounding box. In the cases where it is impossible or impractical to determine the x-height, a value of 0.5em must be assumed.
</dd>

	<dt>`cap@u 単位</dt>
	<dd>
`可用な最初の~font$ `CSS3-FONTS$r に利用されている~cap-高さに等しい。
~cap-高さという呼称は、~Latin大字（ `capital letters^en ）の高さに近似的に等しいことに由来する。
しかしながら、~Latin大字を包含しない~fontにも， `cap$u は定義される。
~fontの~cap-高さは、別の仕方で見出すこともできる。
~fontには、~cap-高さ用の依拠できる計量法が可用なものもある。
可用でない場合、~UAは大文字~glyphの高さから~cap-高さを決定してもヨイ。
アリな経験則として、大文字 "O" の~glyphの下端が基底線の下に突き出ている距離を調べて，その値をその限界~boxの上端から減算して得る方法がある。
~cap-高さを決定するのは不可能, または実用的でない場合、~fontの~ascentが利用されるモノトスル。
◎
Equal to the used cap-height of the first available font [CSS3-FONTS]. The cap-height is so called because it is approximately equal to the height of a capital Latin letter. However, a cap is defined even for fonts that do not contain Latin letters. The cap-height of a font can be found in different ways. Some fonts contain reliable metrics for the cap-height. If reliable font metrics are not available, UAs may determine the cap-height from the height of an uppercase glyph. One possible heuristic is to look at how far the glyph for the uppercase “O” extends below the baseline, and subtract that value from the top of its bounding box. In the cases where it is impossible or impractical to determine the cap-height, the font’s ascent must be used.
</dd>

	<dt>`ch@u 単位</dt>
	<dd>
描画-時に利用される~fontの文字 "0" （ `0030^U `ZERO^cn ）の~glyphに利用される`送幅$に等しい。
（
`送幅@
とは、要素の行内-軸における~glyphの送幅（ `advance measure^en ）†である。）
◎
Equal to the used advance measure of the “0” (ZERO, U+0030) glyph in the font used to render it. (The advance measure of a glyph is its advance width or height, whichever is in the inline axis of the element.) 
</dd>
	<dd class="trans-note">【†
当の~glyph（この場合は "0" ）の始端から次の~glyph（同じ行lに描画されたとする）の始端までの距離。
】</dd>
	<dd>
この計量は，単独の半角（ `narrow^en ）~glyphの`送幅$の近似であり（等幅~fontでは，正確な計測になる）、期待される~glyph個数に基づく計量を可能にする。
◎
This measurement is an approximation (and in monospace fonts, an exact measure) of a single narrow glyph’s advance measure, thus allowing measurements based on an expected glyph count.
</dd>
	<dd>
~glyphの送幅は、~font設定群のみならず，
`writing-mode$p, `text-orientation$p, 他，~glyphの［
選定／方位
］に影響する他の~propにも依存する。
◎
Note: The advance measure of a glyph depends on writing-mode and text-orientation as well as font settings, text-transform, and any other properties that affect glyph selection or orientation.
</dd>
	<dd>
“0” ~glyphの計測は不可能, または実用的でない場合、［
~~高さ `1em^v, 幅 `0.5em^v
］と見做されるモノトスル。
したがって `ch$u 単位は、［
一般~事例では `0.5em^v ／
正立に植字されるとき（すなわち、
`writing-mode$p は［
`vertical-rl$v ／ `vertical-lr$v
］,
`text-orientation$p は `upright$v
のとき）は `1em^v
］に~fall-backする。
◎
In the cases where it is impossible or impractical to determine the measure of the “0” glyph, it must be assumed to be 0.5em wide by 1em tall. Thus, the ch unit falls back to 0.5em in the general case, and to 1em when it would be typeset upright (i.e. writing-mode is vertical-rl or vertical-lr and text-orientation is upright).
</dd>

	<dt>`ic@u 単位</dt>
	<dd>
描画-時に利用される~fontの文字 “水” （ CJK 表語文字, `6C34^U ）の~glyphに利用される`送幅$に等しい。
◎
Equal to the used advance measure of the “水” (CJK water ideograph, U+6C34) glyph found in the font used to render it.
</dd>
	<dd>
この計量は，概して正確な計測であり（全角~glyphが均衡幅であるような少数の~fontでは，近似になる）、期待される~glyph個数に基づく計量を可能にする。
◎
This measurement is a typically an exact measure (in the few fonts with proportional fullwidth glyphs, an approximation) of a single fullwidth glyph’s advance measure, thus allowing measurements based on an expected glyph count.
</dd>
	<dd>
表語文字 送幅を決定するのは不可能, または実用的でない場合、
`1em^v と見做されるモノトスル。
◎
In the cases where it is impossible or impractical to determine the ideographic advance measure, it must be assumed to be 1em.
</dd>

	<dt>`rem@u 単位</dt>
	<dd>
根~要素の `font-size$p の算出d値に等しい。
根~要素の `font-size$p ~propに指定された `rem$u 単位は、その~propの`初期~値$を基準にする。
◎
Equal to the computed value of font-size on the root element. When specified on the font-size property of the root element, the rem units refer to the property’s initial value.
</dd>

	<dt>`lh@u 単位</dt>
	<dd>
この単位が利用された要素~上の `line-height$p ~propの算出d値に等しい
— ここでは、値 `normal^v も，`可用な最初の~font$の計量法を利用して絶対~長さに変換する。
◎
Equal to the computed value of the line-height property of the element on which it is used, converting normal to an absolute length by using only the metrics of the first available font. 
</dd>

	<dt>`rlh@u 単位</dt>
	<dd>
根~要素~上の `line-height$p ~propの算出d値に等しい
— ここでは、値 `normal^v も， `lh^u のときと同様に絶対~長さに変換する。
◎
Equal to the computed value of line-height property on the root element, converting normal to an absolute length as above.
</dd>
	<dd class="note">注記：
要素の `height$p を
`lh$u ／ `rlh$u
単位を利用して設定しても，実際の行l数~制御が可能化されるわけではない。
これらの単位は、理想上は空~行lの理論的~sizeに基づく長さ計算を可能化するものではない
— 実際の行l数は、内容の多寡に応じて相違し得る。
作者は、要素~内の実際の行l数を制限したいなら，代わりに `max-lines$p ~propを利用できる。
◎
Note: Setting the height of an element using either the lh or the rlh units does not enable authors to control the actual number of lines in that element. These units only enable length calculations based on the theoretical size of an ideal empty line; the size of actual lines boxes may differ based on their content. In cases where an author wants to limit the number of actual lines in an element, the max-lines property can be used instead.
</dd>
</dl>

<p class="issue">
もっと~typographic単位を追加することもできる
— `cicero^u, `didot^u, 等々。
それらは単に絶対~単位であり，既存の単位に変換できるが、追加するに~~価するほど十分に欲されているか（印刷用途も含め）？
あるいは、単に Houdini Custom Units を待つべきか？
◎
We can potentially add more typographic units, like cicero, didot, etc. They’re just absolute units, and so can be done with the existing units, but is there enough desire for them (potentially for printing use-cases) that it would be worth adding them? Or should we just wait for Houdini Custom Units?
</p>

<p>
これらの~fontに相対的な単位は（上では，定義されていない／定義が循環する事例では）：
◎
↓</p>

<ul>
	<li>
要素の文脈の外側（`媒体~query$など）で利用されたときは、［
`font$p, `line-height$p
］~propの初期~値に対応する計量法を基準にする。
◎
When used outside the context of an element (such as in media queries), these units refer to the metrics corresponding to the initial values of the font and line-height properties.＼
</li>
	<li>
要素~上の `font-size$p ~propの値に利用されたときは、要素に親が［
在るならば 親に算出される計量法 ／
無いならば［
`font^p, `line-height^p
］~propの初期~値に対応して算出される計量法
］に基づくように解決される。
◎
When used in the value of the font-size property on the element they refer to, they resolve against the computed metrics of the parent element—or against the computed metrics corresponding to the initial values of the font and line-height properties, if the element has no parent.＼
</li>
	<li>
［
`lh$u ／ `rlh$u
］単位が，要素~上の `line-height^p ~propの値に利用されたときは、要素に親が［
在るならば 親の［
`font^p, `line-height^p
］~propに算出される計量法 ／
無いならば［［
`font^p, `line-height^p
］~propの初期~値に対応して算出される計量法
］］に基づくように解決される（他の単位については、他と同じく，要素の自前の計量法に基づくように解決される）。
◎
Additionally, when lh or rlh units are used in the value of the line-height property on the element they refer to, they resolve against the computed line-height and font metrics of the parent element—or the computed metrics corresponding to the initial values of the font and line-height properties, if the element has no parent. (The other font-relative units continue to resolve against the element’s own metrics when used in line-height.)
</li>
</ul>

			</section>
			<section id="viewport-relative-lengths">
<h4 title="Viewport-percentage Lengths: the vw, vh, vi, vb, vmin, vmax units">6.1.2. 表示域~百分率による長さ単位： `vw^u, `vh^u, `vi^u, `vb^u, `vmin^u, `vmax^u</h4>

<p>
`表示域~百分率による長さ@
は
`初期~包含塊$の~sizeに相対的になる。
初期~包含塊の縦幅／横幅が変化すれば，それに応じて拡縮される。
ただし，［
根~要素の `overflow$p の値が `auto^v
］のときは、~scrollbarは存在しないものと見做される。
<span class="note">
初期~包含塊の~sizeは、表示域の~scrollbarの有無に影響される。
</span>
◎
The viewport-percentage lengths are relative to the size of the initial containing block. When the height or width of the initial containing block is changed, they are scaled accordingly. However, when the value of overflow on the root element is auto, any scroll bars are assumed not to exist. Note that the initial containing block’s size is affected by the presence of scrollbars on the viewport.
</p>

<p>
`~paged媒体$に対する表示域~百分率による長さの正確な定義は
`CSS3PAGE$r
に委ねられる。
◎
For paged media, the exact definition of the viewport-percentage lengths is deferred to [CSS3PAGE].
</p>

<dl>
	<dt>`vw@u 単位</dt>
	<dd>

<p>
`初期~包含塊$の横幅の 1% に等しい。
◎
Equal to 1% of the width of the initial containing block.
</p>

<div class="example">
<p>
次の例で，表示域の横幅が 200mm である場合、
`h1^e 要素の~font~sizeは 16mm （すなわち， ( 8 ~MUL 200mm ) ~DIV 100 ）になる。
◎
In the example below, if the width of the viewport is 200mm, the font size of h1 elements will be 16mm (i.e. (8×200mm)/100).
</p>

<pre class="lang-css">
h1 { font-size: 8vw }
</pre>
</div>

	</dd>

	<dt>`vh@u 単位</dt>
	<dd>
`初期~包含塊$の縦幅の 1% に等しい。
◎
Equal to 1% of the height of the initial containing block.
</dd>

	<dt>`vi@u 単位</dt>
	<dd>
`初期~包含塊$の~size
— 根~要素の`行内-軸$方向におけるそれ —
の 1% に等しい。
◎
Equal to 1% of the size of the initial containing block in the direction of the root element’s inline axis. 
</dd>

	<dt>`vb@u 単位</dt>
	<dd>
`初期~包含塊$の~size
— 根~要素の`塊-軸$方向におけるそれ —
の 1% に等しい。
◎
Equal to 1% of the size of the initial containing block in the direction of the root element’s block axis.
</dd>

	<dt>`vmin@u 単位</dt>
	<dd>
`vw$u と `vh$u の小さい方に等しい。
◎
Equal to the smaller of vw or vh.
</dd>

	<dt>`vmax@u 単位</dt>
	<dd>
`vw$u と `vh$u の大きい方に等しい。
◎
Equal to the larger of vw or vh.
</dd>
</dl>

<p>
根~要素が無い, または まだ~styleがあてがわれていない状況（`媒体~query$を評価するときなど）においては、
`vi$u, `vb$u 単位に対応する軸は， `writing-mode$p ~propの初期~値を利用して決定される。
◎
In situations where there is no root element or it hasn’t yet been styled (such as when evaluating media queries), the vi and vb units use the initial value of the writing-mode property to determine which axis they correspond to.
</p>

			</section>
		</section>
		<section id="absolute-lengths">
<h3 title="Absolute Lengths: the cm, mm, Q, in, pt, pc, px units">6.2. 絶対~単位：`cm^u, `mm^u, `Q^u, `in^u, `pt^u, `pc^u, `px^u</h3>

<p>
`絶対~長さ単位@
は、何らかの物理-計量を`~anchor$にし, 互いが固定的な関係にある単位である。
これは主に、出力~環境が既知である場合に有用になる。
絶対~単位には
`物理-単位@
（ `in$u, `cm$u, `mm$u, `pt$u, `pc$u, `Q$u ）と
`視野角~単位@
— <dfn >~pixel単位</dfn> （ `px$u ）—
がある：
◎
The absolute length units are fixed in relation to each other and anchored to some physical measurement. They are mainly useful when the output environment is known. The absolute units consist of the physical units (in, cm, mm, pt, pc, Q) and the visual angle/pixel unit (px):
</p>

<div>

<table><thead><tr><th>単位
<th>名前
<th>他の単位との関係
</thead><tbody>

<tr><td>`cm@u
<td>~centi~meter（ `centimeter^en ）
<td>1 `cm^u = ( 96 ÷ 2.54 ) `px^u

<tr><td>`mm@u
<td>~milli~meter（ `millimeter^en ）
<td>1 `mm^u = ( 1 ÷ 10 ) `cm^u

<tr><td>`Q@u
<td>四分~milli~meter（ `quarter-millimeter^en ）
<td>1 `Q^u = ( 1 ÷ 40 ) `cm^u

<tr><td>`in@u
<td>~inch（ `inch^en ）
<td>1 `in^u = 2.54 `cm^u = 96 `px^u

<tr><td>`pc@u
<td>~pica（ `pica^en ）
<td>1 `pc^u = ( 1 ÷ 6 ) `in^u = 12 `pt^u

<tr><td>`pt@u
<td>~point（ `point^en ）
<td>1 `pt^u = ( 1 ÷ 72 ) `in^u

<tr><td>`px@u
<td>~pixel（ `pixel^en, “~~画素” ）
<td>1 `px^u = ( 1 ÷ 96 ) `in^u
</tbody></table>

◎
unit 	name 	equivalence
cm 	centimeters 	1cm = 96px/2.54
mm 	millimeters 	1mm = 1/10th of 1cm
Q 	quarter-millimeters 	1Q = 1/40th of 1cm
in 	inches 	1in = 2.54cm = 96px
pc 	picas 	1pc = 1/6th of 1in
pt 	points 	1pt = 1/72th of 1in
px 	pixels 	1px = 1/96th of 1in
</div>

<div class="example">

<pre class="lang-css">
h1 { margin: 0.5in }      /* <span class="comment" title="inches">~inch</span> */
h2 { line-height: 3cm }   /* <span class="comment" title="centimeters">~centi~meter</span> */
h3 { word-spacing: 4mm }  /* <span class="comment" title="millimeters">~milli~meter</span> */
h3 { letter-spacing: 1Q } /* <span class="comment" title="quarter-millimeters">四分~milli~meter</span> */
h4 { font-size: 12pt }    /* <span class="comment" title="points">~point</span> */
h4 { font-size: 1pc }     /* <span class="comment" title="picas">~pica</span> */
p  { font-size: 12px }    /* <span class="comment" title="px">~pixel</span> */
</pre>

</div>

<p>
すべての絶対~長さ単位どうしは `互換$である
— それらの`正準的~単位$は `px$u とする。
◎
All of the absolute length units are compatible, and px is their canonical unit.
</p>

<p>
~CSSに基づいて描画する機器においては、これらの次元は、次のいずれかを
`~anchor@
にする。
◎
For a CSS device, these dimensions are anchored either
</p>

<ul>
	<li>
(1) `物理-単位$と物理-計量との~~換算法，または
◎
by relating the physical units to their physical measurements, or
</li>
	<li>
(2) `基準~pixel$と`~pixel単位$との~~換算法
◎
by relating the pixel unit to the reference pixel.
</li>
</ul>

<p>
典型的な視聴距離が想定されている印刷~媒体に対しては、`~anchor単位$は，`物理-単位$（~inch, ~centi~meter, 等々）になるベキである。
~screen媒体（高-解像度 機器, 低~解像度 機器, ~~普通でない視聴距離が想定されている機器も含む）に対しては、`~pixel単位$が~anchor単位に推奨される。
この種の機器においては、~pixel単位は，基準~pixelに最良に近似するような 機器~画素の整数倍を基準にすることが推奨される。
◎
For print media at typical viewing distances, the anchor unit should be one of the physical units (inches, centimeters, etc). For screen media (including high-resolution devices), low-resolution devices, and devices with unusual viewing distances), it is recommended instead that the anchor unit be the pixel unit. For such devices it is recommended that the pixel unit refer to the whole number of device pixels that best approximates the reference pixel.
</p>

<p class="note">注記：
`~anchor単位$が`~pixel単位$である場合、`物理-単位$は，物理的な計量に一致するとは限らない。
一方で，~anchor単位が物理-単位である場合、~pixel単位は，機器~画素の整数倍に対応しないことがある。
◎
Note: If the anchor unit is the pixel unit, the physical units might not match their physical measurements. Alternatively if the anchor unit is a physical unit, the pixel unit might not map to a whole number of device pixels.
</p>

<p class="note">注記：
この`~pixel単位$と`物理-単位$の定義は、~CSSの過去~versionによる定義と異なる。
特に，過去~versionでは、~pixel単位と物理-単位は固定比率で~~換算できなかった
— 物理的な単位は，常にその物理的な計量に結付けられていた一方、~pixel単位は，基準~pixelに最も近似するような可変的なものとされていた。
（このように変更された~~理由は、 96dpi を前提にしている既存の内容があまりに多いため、その前提を覆すと，それらの内容も壊してしまうからである。）
◎
Note: This definition of the pixel unit and the physical units differs from previous versions of CSS. In particular, in previous versions of CSS the pixel unit and the physical units were not related by a fixed ratio: the physical units were always tied to their physical measurements while the pixel unit would vary to most closely match the reference pixel. (This change was made because too much existing content relies on the assumption of 96dpi, and breaking that assumption broke the content.)
</p>

<p class="note">注記：
単位は`~ASCII大小無視$であり，小文字に直列化される。
例えば `1Q^v は `1q^v に直列化される。
◎
Note: Units are ASCII case-insensitive and serialize as lower case, for example 1Q serializes as 1q.
</p>

<p>
`基準~pixel@
とは、~pixel密度 96dpi の機器において 読み手の腕の長さだけ離れたときの， 1 ~pixelが占める視野角である。
名目上の腕の長さ約 71cm の下での視野角は，約 0.0213 度であり、この腕の長さだけ離れた視点からの `1px^v は，およそ 0.26mm （ 1÷96 ~inch）に相当する。
◎
The reference pixel is the visual angle of one pixel on a device with a pixel density of 96dpi and a distance from the reader of an arm’s length. For a nominal arm’s length of 28 inches, the visual angle is therefore about 0.0213 degrees. For reading at arm’s length, 1px thus corresponds to about 0.26 mm (1/96 inch).
</p>

<p>
下の画像に、視点からの距離が基準~pixelの~~実際の大きさに及ぼす効果を示す：
読み取り距離 71cm （ 28 ~inch）のときの基準~pixelは約 0.26mm になり，
3.5m （ 12 ~feet）のときの基準~pixelは約 1.3mm になる。
◎
The image below illustrates the effect of viewing distance on the size of a reference pixel: a reading distance of 71 cm (28 inches) results in a reference pixel of 0.26 mm, while a reading distance of 3.5 m (12 feet) results in a reference pixel of 1.3 mm.
</p>

<figure>
<img
	src="css-values/pixel1.png"
	style="width:500px; height:360px;"
	alt="この図式は、~pixelの定義が利用者から表示画面（紙または~screen）までの距離に依存する様子を示すものである。
画像では、利用者から同じ方向に位置する 2 枚の平面（一方は距離 71 cm, もう一方は距離 3.5 m ）が重なって見えている様子が示されている。
利用者の目の位置からはそれらの平面に向けて，（前述の視野角により）次第に広がる円錐が投射されている。
円錐が前者／後者の平面に投射される所の 1 ~pixelの大きさは、それぞれ 0.26 mm ／ 1.4 mm になる。／
This diagram illustrates how the definition of a pixel
depends on the users distance from the viewing surface
(paper or screen).
The image depicts the user looking at two planes, one
28 inches (71 cm) from the user, the second 140 inches
(3.5 m) from the user. An expanding cone is projected
from the user’s eye onto each plane. Where the cone
strikes the first plane, the projected pixel is 0.26 mm
high. Where the cone strikes the second plane, the
projected pixel is 1.4 mm high.">

<figcaption>
~pixelの大きさは、視点からの距離に比例することになる。
◎
Showing that pixels must become larger if the viewing distance increases
</figcaption>

</figure>

<p>
次の図に、機器の解像度が`~pixel単位$に与える効果を示す：
低~解像度の機器（例えば，典型的な~computer画面）では，
`1px^v 平方の区画が 1 個の~dotで覆われるのに対し、高-解像度の機器（~printerなど）では，同じ区画に 16 ~dot入る。
◎
This second image illustrates the effect of a device’s resolution on the pixel unit: an area of 1px by 1px is covered by a single dot in a low-resolution device (e.g. a typical computer display), while the same area is covered by 16 dots in a higher resolution device (such as a printer).
</p>

<figure>

<img
	src="css-values/pixel2.png"
	style="width:412px; height:321px;"
	alt="この図式は、基準~pixelと機器~画素（“~dot” ）の関係を示すものである。
図左は 高-解像度（~dotの密度が高い）~laser~printerの出力，図右は 低-解像度の~monitor画面。
~laser~printerにおける 1 基準~pixel四方の区画は， 16 ~dotで占められている。
~monitor画面における 1 基準~pixel四方の区画は， 1 ~dotで占められている。
／
This diagram illustrates the relationship between the
reference pixel and device pixels (called &quot;dots&quot; below).
The image depicts a high resolution (large dot density)
laser printer output on the left and a low resolution
monitor screen on the right. For the laser printer, one
square reference pixel is implemented by 16 dots. For
the monitor screen, one square reference pixel is
implemented by a single dot.">

<figcaption>
機器の解像度が高くなるほど，（視覚的に同じ距離の）
`1px^v 平方を覆うのに必要な機器~画素（~dot）数は増える。
◎
Showing that more device pixels (dots) are needed to cover a 1px by 1px area on a high-resolution device than on a lower-resolution one (of the same approximate viewing distance)
</figcaption>

</figure>

		</section>
	</section>
	<section id="other-units">
<h2 title="Other Quantities">7. その他の数量</h2>

		<section id="angles">
<h3 title="Angle Units: the <angle> type and deg, grad, rad, turn units">7.1. 角度の単位： `angle^t 型と `deg^u, `grad^u, `rad^u, `turn^u 単位</h3>

<p>
角度~値は `dimension$t 型であり、
`angle@t
で表記される。
角度~単位~識別子には次のものがある：
◎
Angle values are &lt;dimension&gt;s denoted by &lt;angle&gt;. The angle unit identifiers are:
</p>

<dl>
	<dt>`deg@u</dt>
	<dd>
度。
円の全周は 360 度。
◎
Degrees. There are 360 degrees in a full circle.
</dd>

	<dt>`grad@u</dt>
	<dd>
~gradian。
“~gon” あるいは “~grade” としても知られる。
円の全周は 400 gradian 。
◎
Gradians, also known as "gons" or "grades". There are 400 gradians in a full circle.
</dd>

	<dt>`rad@u</dt>
	<dd>
~radian。
円の全周は 2π ~radian。
◎
Radians. There are 2π radians in a full circle.
</dd>

	<dt>`turn@u</dt>
	<dd>
周回数（ `turn^en ）。
円の全周は 1 周回。
◎
Turns. There is 1 turn in a full circle.
</dd>

</dl>

<p>
例えば，直角は［
`90deg^v ／
`100grad^v ／
`0.25turn^v ／
約 `1.57rad^v
］に等しい。
◎
For example, a right angle is 90deg or 100grad or 0.25turn or approximately 1.57rad.
</p>

<p>
すべての `angle$t 単位どうしは `互換$である
— それらの`正準的~単位$は `deg$u とする。
◎
All &lt;angle&gt; units are compatible, and deg is their canonical unit.
</p>

<p>
方向を表記する角度は、概して
`方位角@
として解釈されるのが慣例である
— ここで、
`0deg^v は~screen上の
“上方” あるいは “北”
を指し、角度は時計回りに大きくなる（したがって
`90deg^v は
“右方” あるいは “東”
を指す）。
◎
By convention, when an angle denotes a direction in CSS, it is typically interpreted as a bearing angle, where 0deg is "up" or "north" on the screen, and larger angles are more clockwise (so 90deg is "right" or "east").
</p>

<p>
例えば、
`linear-gradient$f 関数において~gradientの方向を決定する
`angle$t 値は、方位角に解釈される。
◎
For example, in the linear-gradient() function, the &lt;angle&gt; that determines the direction of the gradient is interpreted as a bearing angle.
</p>

<p class="note">注記：
旧来の理由から、 `angle$t の一部の利用においては、 `0deg^v を意味する~~素の `0^v も許容される。
しかしながら、これは一般には成立せず，また、将来における `angle$t 型の利用には生じない。
◎
Note: For legacy reasons, some uses of &lt;angle&gt; allow a bare 0 to mean 0deg. This is not true in general, however, and will not occur in future uses of the &lt;angle&gt; type.
</p>

		</section>
		<section id="time">
<h3 title="Duration Units: the &lt;time&gt; type and s, ms units">7.2. 時間長の単位： `time^t 型と `s^u, `ms^u 単位</h3>

<p>
時間~値は
`time@t
で表記される`次元$である。
時間の単位~識別子には次のものがある：
◎
Time values are dimensions denoted by &lt;time&gt;. The time unit identifiers are:
</p>

<dl>
	<dt>`s@u</dt>
	<dd>
秒。
◎
Seconds.
</dd>

	<dt>`ms@u</dt>
	<dd>
~milli秒。
1 秒は 1000 ~milli秒。
◎
Milliseconds. There are 1000 milliseconds in a second.
</dd>

</dl>

<p>
すべての `time$t 単位どうしは `互換$である
— それらの`正準的~単位$は `s$u とする。
◎
All &lt;time&gt; units are compatible, and s is their canonical unit.
</p>

<p>
~propには、時間~値を一定~範囲に制約するものもある。
許容d範囲~外の値を伴う宣言は無効であり，`無視する$モノトスル。
◎
Properties may restrict the time value to some range. If the value is outside the allowed range, the declaration is invalid and must be ignored.
</p>

		</section>
		<section id="frequency">
<h3 title="Frequency Units: the &lt;frequency&gt; type and Hz, kHz units">7.3. 周波数の単位： `frequency^t 型と `Hz^u, `kHz^u 単位</h3>

<p>
周波数~値は
`frequency@t
で表記される`次元$である。
周波数の単位~識別子には次のものがある：
◎
Frequency values are dimensions denoted by &lt;frequency&gt;. The frequency unit identifiers are:
</p>

<dl>
	<dt>`Hz@u</dt>
	<dd>
~Hertz。
1 秒あたりの周波数を表現する。
◎
Hertz. It represents the number of occurrences per second.
</dd>

	<dt>`kHz@u</dt>
	<dd>
~KiloHertz。
1 ~KiloHertzは 1000 ~Hertz。
◎
KiloHertz. A kiloHertz is 1000 Hertz.
</dd>

</dl>

<p>
例えば 音高を表現する際の，
`200Hz^v（または `200hz^v ）は 低音域にあり, 
`6kHz^v（または `6khz^v ）は高音域にある。
◎
For example, when representing sound pitches, 200Hz (or 200hz) is a bass sound, and 6kHz (or 6khz) is a treble sound.
</p>

<p>
すべての `frequency$t 単位どうしは `互換$である
— それらの`正準的~単位$は `Hz$u とする。
◎
All &lt;frequency&gt; units are compatible, and hz is their canonical unit.
</p>

<p class="note">注記：
単位は`~ASCII大小無視$であり，小文字に直列化される。
例えば `1Hz^v は `1hz^v に直列化される。
◎
Note: Units are ASCII case-insensitive and serialize as lower case, for example 1Hz serializes as 1hz.
</p>

		</section>
		<section id="resolution">
<h3 title="Resolution Units: the &lt;resolution&gt; type and dpi, dpcm, dppx units">7.4. 解像度の単位： `resolution^t 型と `dpi^u, `dpcm^u, `dppx^u 単位</h3>

<p>
解像度の値は
`resolution@t
で表記される`次元$である。
解像度の単位~識別子には次のものがある：
◎
Resolution units are dimensions denoted by &lt;resolution&gt;. The resolution unit identifiers are:
</p>

<dl>
	<dt>`dpi@u</dt>
	<dd>
~inchあたりの~dot数
◎
Dots per inch.
</dd>

	<dt>`dpcm@u</dt>
	<dd>
~centi~meterあたりの~dot数
◎
Dots per centimeter.
</dd>

	<dt>`dppx@u</dt>
	<dt>`x@u</dt>
	<dd>
`px$u 単位あたりの~dot数
◎
Dots per px unit.
</dd>

</dl>

<p>
`resolution$t
単位は、 1 ~CSS［
`in$u ／ `cm$u ／ `px$u
］の中に収まる~dot数を指示することにより，
1 個の “~dot” の~graphicな表現における~sizeを表現する。
用途については、例えば［
`resolution$d 媒体~query `MEDIAQ$r ／
`image-resolution$p ~prop `CSS3-IMAGES$r
］を見よ。
◎
The &lt;resolution&gt; unit represents the size of a single "dot" in a graphical representation by indicating how many of these dots fit in a CSS in, cm, or px. For uses, see e.g. the resolution media query in [MEDIAQ] or the image-resolution property defined in [CSS3-IMAGES].
</p>

<p>
すべての `resolution$t 単位どうしは `互換$である
— それらの`正準的~単位$は `dppx$u とする。
◎
All &lt;resolution&gt; units are compatible, and dppx is their canonical unit.
</p>

<p class="note">注記：
~CSS `in$u から~CSS `px$u への固定比率 1:96 に因り， 
`1dppx^v は `96dpi^v に等価になる。
これは、~CSSにて表示される画像の既定の解像度に対応する。
`image-resolution$p ~propを見よ 
◎
Note that due to the 1:96 fixed ratio of CSS in to CSS px, 1dppx is equivalent to 96dpi. This corresponds to the default resolution of images displayed in CSS: see image-resolution. 
</p>

<div class="example">

<p>
次の `media^at 規則は、
Media Queries `MEDIAQ$r
を利用して， 1 ~CSS `px$u 単位に 2 以上の機器~画素を利用する機器に 特別なスタイル規則をアテガう：
◎
The following @media rule uses Media Queries [MEDIAQ] to assign some special style rules to devices that use two or more device pixels per CSS px unit:
</p>

<pre class="lang-css">
@media (min-resolution: 2dppx) { ... }
</pre>
</div>

		</section>
	</section>
	<section id="defined-elsewhere">
<h2 title="Data Types Defined Elsewhere">8. 他所で定義される~data型</h2>

<p>
他の~moduleにおける一部の~data型は、その~module自身の中で定義されている。
ここでは，多くの仕様に最も共通的に利用されている例を挙げる。
◎
Some data types are defined in their own modules. This example talks about some of the most common ones used across several specifications.
</p>

		<section id="colors">
<h3 title="Colors: the &lt;color&gt; type">8.1.  色： `color^t 型</h3>

<p>
`color$t ~data型は， `CSS3COLOR$r にて定義される。
CSS Color Level 3 またはその後継版を~supportする~UAは、その定義に従って
`color$t
を解釈するモノトスル。
◎
The &lt;color&gt; data type is defined in [CSS3COLOR]. UAs that support CSS Color Level 3 or its successor must interpret &lt;color&gt; as defined therein.
</p>

			<section id="combine-colors">
<h4 title="Combination of &lt;color&gt;">8.1.1. `color^t の結合n</h4>

<p>
`color$t の`補間$は、値を成す［
~red, ~green, ~blue, ~alpha
］各~成分を `number$t として独立に`補間-$するものとして定義される。
補間は、乗算済み色どうしで行われる（すなわち，指定された［
~red, ~green, ~blue
］色~成分を~alphaで乗算してから補間する）。
◎
Interpolation of &lt;color&gt; is defined as the independent interpolation of each component (red, green, blue, alpha) as a &lt;number&gt;. Interpolation is done between premultiplied colors (that is, colors for which the red, green, and blue components specified have been multiplied by the alpha).
</p>

<p>
同様に `color$t の`加算$は、値を成す各~成分を乗算済み空間 内で `number$t として独立に`加算-$するものとして定義される。
◎
Addition of &lt;number&gt; is likewise defined as the independent addition of each component as a &lt;number&gt; in premultiplied space.
</p>

<div class="issue">

<p>
次のような~styleにおける `text-emphasis-color$p の値を考えるとき、算出d値は［
`currentcolor$v と実際の色との組合n
］を表現-可能になる必要がある。
`445$issue を見よ：
</p>

<pre class="lang-css">
div { text-emphasis: circle; transition: all 2s; }
div:hover { text-emphasis-color: lime; }
em { color: red; }
</pre>

◎
Computed value needs to be able to represent combinations of currentColor and an actual color. Consider the value of text-emphasis-color in div { text-emphasis: circle; transition: all 2s; }
div:hover { text-emphasis-color: lime; }
em { color: red; } See Issue 445.
</div>

			</section>
		</section>
		<section id="images">
<h3 title="Images: the &lt;image&gt; type">8.2. 画像： `image^t 型</h3>

<p>
`image$t ~data型は， `CSS3-IMAGES$r にて定義される。
CSS Images Level 3 またはその後継版を~supportする~UAは、その定義に従って
`image$t を解釈するモノトスル。
そうでない~UAは、 `image$t を `url$t として解釈するモノトスル。
◎
The &lt;image&gt; data type is defined in [CSS3-IMAGES]. UAs that support CSS Images Level 3 or its successor must interpret &lt;image&gt; as defined therein. UAs that do not yet support CSS Images Level 3 must interpret &lt;image&gt; as &lt;url&gt;.
</p>

			<section id="combine-images">
<h4 title="Combination of &lt;image&gt;">8.2.1. `image^t の結合n</h4>

<p class="note">注記：
`image$t の補間は
`CSS3-IMAGES$r による
<a href="~CSSIMAGE#interpolation">補間</a>
にて定義される。
【~level 4 による<a href="~CSSIMAGE4#interpolation">補間</a>】
◎
Note: Interpolation of &lt;image&gt; is defined in CSS Images 3 §6 Interpolation.
</p>

<p>
画像は、`加法的でない$とする。
◎
Images are not additive.
</p>

			</section>
		</section>
		<section id="position">
<h3 title="2D Positioning: the &lt;position&gt; type">8.3. 二次元の位置： `position^t 型</h3>

<p>
`position@t 値は、位置決め区画（例：`背景~位置決め区画$）の内側における~obj区画（例：背景~画像）の位置を指定する。
それは、 `background-position$p に指定されるように解釈される。
`CSS3-BACKGROUNDS$r
◎
The &lt;position&gt; value specifies the position of a object area (e.g. background image) inside a positioning area (e.g. background positioning area). It is interpreted as specified for background-position. [CSS3-BACKGROUND]
</p>

<pre class="prod">
`position$t = [
  [ `left^v | `center^v | `right^v ] || [ `top^v | `center^v | `bottom^v ]
|
  [ `left^v | `center^v | `right^v | `length-percentage$t ]
  [ `top^v | `center^v | `bottom^v | `length-percentage$t ]?
|
  [ [ `left^v | `right^v ] `length-percentage$t ] &amp;&amp;
  [ [ `top^v | `bottom^v ] `length-percentage$t ]
]
</pre>

<p class="note">注記：
`background-position$p ~propは、成分~値 3 個の構文も受容するが，これは汎用には許容されない
— ~prop値~内で他の［
長さ／百分率
］成分と組合されたとき，構文解析-時に多義性をもたらすので。
◎
Note: The background-position property also accepts a three-value syntax. This has been disallowed generically because it creates parsing ambiguities when combined with other length or percentage components in a property value.
</p>

<p>
直列化するときの正準的~順序は、［
横~成分, 縦~成分
］の順とする。
◎
The canonical order when serializing is the horizontal component followed by the vertical component.
</p>

<p>
文法~内で他の［
~keyword ／ `length$t ／ `percentage$t
］と並べて指定された `position$t は、`貪欲に^em構文解析され，アリな限り多くの成分を消費する。
◎
When specified in a grammar alongside other keywords, &lt;length&gt;s, or &lt;percentage&gt;s, &lt;position&gt; is greedily parsed; it consumes as many components as possible.
</p>

<p class="example">
例えば `transform-origin$p は、（実質的に）
<span class="prod">`position$t `length$t?</span>
として，三次元の位置を定義する。
`left 50px^v などの値は，［
z 成分が省略された成分~値 2 個の `position$t
］として構文解析される一方、
`top 50px^v などの値は，［［
成分~値 1 個の `position$t
］, `length$t
］の並びとして構文解析されることになる。
◎
For example, transform-origin defines a 3D position as (effectively) ''&lt;position&gt; &lt;length&gt;?''. A value such as left 50px will be parsed as a 2-value &lt;position&gt;, with an omitted z-component; on the other hand, a value such as top 50px will be parsed as a single-value &lt;position&gt; followed by a &lt;length&gt;.
</p>

			<section id="combine-positions">
<h4 title="Combination of &lt;position&gt;">8.3.1. `position^t の結合n</h4>

<p>
`position$t の`補間$は、値を成す［
x, y
］各~成分を［
左上隅からの~offsetに正規化された `length-percentage$t
］として独立に`補間-$するものとして定義される。
◎
Interpolation of &lt;position&gt; is defined as the independent interpolation of each component (x, y) normalized as an offset from the top left corner as a &lt;length-percentage&gt;.
</p>

<p>
同様に `position$t の`加算$は、値を成す［
x, y
］各~成分を［
左上隅からの~offsetに正規化された `length-percentage$t
］として独立に`加算-$するものとして定義される。
◎
Addition of &lt;position&gt; is likewise defined as the independent addition each component (x, y) normalized as an offset from the top left corner as a &lt;length-percentage&gt;.
</p>

			</section>
		</section>
	</section>
	<section id="functional-notations">
<h2 title="Functional Notations">9. 関数-記法</h2>

<p>
`関数-記法@
は、［
より複階的な型を表現する, あるいは特別な処理を呼出せる
］ような，成分~値の型である。
その構文は、［［
関数の名前,
左~丸括弧
］（すなわち `function-token$t ）,
引数の並び,
右~丸括弧
］の並びである。
［
左／右の丸括弧
］と［
引数の並び
］の合間には`空白$も許容される。
関数は、~CSS~prop値に似た書式で記される引数を，複数個とり得る。
◎
A functional notation is a type of component value that can represent more complex types or invoke special processing. The syntax starts with the name of the function immediately followed by a left parenthesis (i.e. a &lt;function-token&gt;) followed by the argument(s) to the notation followed by a right parenthesis. White space is allowed, but optional, immediately inside the parentheses. Functions can take multiple arguments, which are formatted similarly to a CSS property value.
</p>

<p>
`rgba$f などの一部の旧来の関数-記法では，余分に~commaを利用しているが、一般には，~commaが利用されるのは［
~list内の項を区切る, あるいは文法の一片から多義性を排する
］ときに限られる。
引数の区切りに~commaが利用される場合、その前後には省略可能な`空白$も挿入できる。
◎
Some legacy functional notations, such as rgba(), use commas unnecessarily, but generally commas are only used to separate items in a list, or pieces of a grammar that would be ambiguous otherwise. If a comma is used to separate arguments, white space is optional before and after the comma.
</p>

<div class="example">
<pre class="lang-css">
background: url(http://www.example.org/image);
color: rgb(100, 200, 50 );
content: counter(list-item) ". ";
width: calc(50% - 2em);
</pre>
</div>

<p>
`~math関数$は、
<a href="#math">§ 数学的な式</a>にて定義される。
◎
The math functions are defined in § 11 Mathematical Expressions.
</p>

		<section id="toggle-notation">
<h3 title="Toggling Between Values: toggle()">9.1. 一連の値の~toggle ： `toggle^f</h3>

<p>
`toggle@f
式は、子孫の一連の要素が，同じ値を継承する代わりに，値の~listから循環的に値を得られるようにする。
◎
The toggle() expression allows descendant elements to cycle over a list of values instead of inheriting the same value.
</p>

<div class="example">
<p>
次の例は、 `em^e 要素を一般の場所では斜字体にしつつ、斜字体の内側では通常体に戻す：
◎
The following example makes &lt;em&gt; elements italic in general, but makes them normal if they’re inside something that’s italic:
</p>

<pre class="lang-css">
em { font-style: toggle(italic, normal); }
</pre>
</div>

<div class="example">

<p>
次の例は、入子にされた~listの~markerを順繰りに循環させる。
~top-levelの~listの~markerは `disc$v 形状にされ、その中に入子にされた~listの~markerは，階が深まる度に順に
`circle$v, `square$v, `box^v
にされ, （ 5 階の深さで）また
`disc$v から始まるようになる。
◎
The following example cycles markers for nested lists, so that a top level list has disc-shaped markers, but nested lists use circle, then square, then box, and then repeat through the list of marker shapes, starting again (for the 5th list deep) with disc.
</p>

<pre class="lang-css">
ul { list-style-type: toggle(disc, circle, square, box); }
</pre>

</div>

<p>
`toggle$f 式の構文は次で与えられる：
◎
The syntax of the toggle() expression is:
</p>

<pre class="prod">
toggle( `toggle-value$t`#$g )
</pre>

<p>
ここで
`toggle-value@t
は、式が置かれた場所で妥当である, かつ
~top-levelの~commaは包含しないような，任意の~CSS値である。
内側のいずれかの値が妥当でない場合、 `toggle$f 式~全体が無効になる。
`toggle$f 式は、どの~propの値に利用してもヨイが，その~prop値の唯一の成分でなければナラナイ。
◎
where &lt;toggle-value&gt; is any CSS value that is valid where the expression is placed, and that doesn’t contain any top-level commas. If any of the values inside are not valid, then the entire toggle() expression is invalid. The toggle() expression may be used as the value of any property, but must be the only component in that property’s value.
</p>

<p>
`toggle$f 記法は入子にできない。
また `attr$f や `calc$f も包含できない。
そのような構成子を包含している宣言は無効になる。
◎
The toggle() notation is not allowed to be nested; nor may it contain attr() or calc() notations. Declarations containing such constructs are invalid.
</p>

<div class="example">
<p>
次の `toggle$f 式の例は、どれも無効になる：
◎
The following toggle() examples are all invalid:
</p>

<pre class="lang-css">
background-position: 10px toggle(50px, 100px);
/* <span class="comment" title="">
`toggle$f 式は~propの唯一の成分でなければナラナイ
◎
toggle() must be the sole value of the property
</span> */

list-style-type: toggle(disc, 50px);
/* <span class="comment">
`50px^v は `list-style-type$p の妥当な値でない
◎
50px isn’t a valid value of 'list-style-type'
</span> */
</pre>
</div>

<p>
`toggle$f 式の算出d値を決定するためには、最初に
それぞれの引数を，それが式が置かれた~propの唯一の成分であったかのように評価して，引数ごとに表現される算出d値を得る
— <var>n</var> 個目の引数に対し得られた値を <var>C<sub>n</sub></var> とする。
次に、各 <var>C<sub>n</sub></var> を~propの`継承d値$ と比較する。
`toggle$f の算出d値は、［
<var>C<sub>n</sub></var> が`継承d値$に合致するような最~小な <var>n</var>
］に対する <var>C<sub>n+1</sub></var> になる。
<var>n</var> が最後の引数に対応する場合, あるいは合致する <var>n</var> が無い場合の算出d値は、最初の引数で表現される算出d値 <var>C<sub>1</sub></var> になる。
◎
To determine the computed value of toggle(), first evaluate each argument as if it were the sole value of the property in which toggle() is placed to determine the computed value that each represents, called Cn for the n-th argument to toggle(). Then, compare the property’s inherited value with each Cn. For the earliest Cn that matches the inherited value, the computed value of toggle() is Cn+1. If the match was the last argument in the list, or there was no match, the computed value of toggle() is the computed value that the first argument represents.
</p>

<p class="note">注記：
したがって， `toggle$f 内で同じ値が繰返された場合、~listは短絡されることになる。
例えば
`toggle(1em, 2em, 1em, 4em)^v
は
`toggle(1em, 2em)^v
に等価になる。
◎
Note: This means that repeating values in a toggle() short-circuits the list. For example toggle(1em, 2em, 1em, 4em) will be equivalent to toggle(1em, 2em).
</p>

<p class="note">注記：
`toggle$f は，明示的に親の算出d値を見るので、`継承されない~prop$でも働く。
これは、継承されない~propにおける `inherit$v ~keywordと類似に働く。
◎
Note: That toggle() explicitly looks at the computed value of the parent, so it works even on non-inherited properties. This is similar to the inherit keyword, which works even on non-inherited properties.
</p>

<p class="note">注記：
~propの`算出d値$は抽象的な値の集合であり、特定0の方法による直列化
`CSS21$r で与えられるものではない。
従って、算出d値の比較は常に一義的に定まり, 期待される結果になる筈である。
例えば，Level 2 の
`background-position$p
の算出d値は、それぞれが絶対~長さまたは百分率として表現される，ちょうど 2 個の~offsetを持つので、宣言
<samp class="css">`background-position$p: `top center^v;</samp>
および
<samp class="css">`background-position$p: `50% 0%^v;</samp>
が生産する算出d値は，一致する。
~prop定義の “算出d値” の欄が多義的, 厳密に過ぎるに思われる場合は、修正に取り掛かれるよう
<a href="#status">~feedback</a>
を願う。
◎
Note: That the computed value of a property is an abstract set of values, not a particular serialization [CSS21], so comparison between computed values should always be unambiguous and have the expected result. For example, a Level 2 background-position computed value is just two offsets, each represented as an absolute length or a percentage, so the declarations background-position: top center and background-position: 50% 0% produce identical computed values. If the "Computed Value" line of a property definition seems to define something ambiguous or overly strict, please provide feedback so we can fix it.
</p>

<p>
`toggle$f が`略式~prop$に利用された場合、その各 `下位prop$の値は，
`toggle$f 式であって, その一連の引数が［
元の `toggle$f 式の引数のそれぞれについて，それが その`略式~prop$の唯一の成分であったとするとき，下位propが受取ることになる値
］にされたものになる。
◎
If toggle() is used on a shorthand property, it sets each of its longhands to a toggle() value with arguments corresponding to what the longhand would have received had each of the original toggle() arguments been the sole value of the shorthand.
</p>

<div class="example">
<p>
例えば、次の略式~propによる宣言は：
◎
For example, the following shorthand declaration:
</p>

<pre class="lang-css">
margin: toggle(1px 2px, 4px, 1px 5px 4px);
</pre>

<p>
次の下位propによる宣言に等価になる：
◎
is equivalent to the following longhand declarations:
</p>

<pre class="lang-css">
margin-top:    toggle(1px, 4px, 1px);
margin-right:  toggle(2px, 4px, 5px);
margin-bottom: toggle(1px, 4px, 4px);
margin-left:   toggle(2px, 4px, 5px);
</pre>

<p>
top ~marginには `1px^v が 2 度,
bottom ~marginには `4px^v が 2 度
現れているので， 2 個の値のみを行き来する一方、
left ／ right ~marginでは 3 個の値が順繰りに利用されることになる。
言い換えれば、上の宣言の算出d値は，次の下位propによる宣言と同じになる：
◎
Note that, since 1px appears twice in the top margin and 4px appears twice in bottom margin, they will cycle between only two values while the left and right margins cycle through three. In other words, the declarations above will yield the same computed values as the longhand declarations below:
</p>

<pre class="lang-css">
margin-top:    toggle(1px, 4px);
margin-right:  toggle(2px, 4px, 5px);
margin-bottom: toggle(1px, 4px);
margin-left:   toggle(2px, 4px, 5px);
</pre>

<p>
その結果は意図されるものではないであろう。
◎
which may not be what was intended.
</p>

</div>

		</section>
	</section>
	<section id="attr-notation">
<h2 title="Attribute References: the attr() function">10. 属性~参照： `attr^f 関数</h2>

<p>
`attr@f
関数は、~propの中で`要素$上の`属性$の値で代用される
— `var$f 関数が `~custom~prop$の値で代用される方法と類似な。
◎
The attr() function substitutes the value of an attribute on an element into a property, similar to how the var() function substitutes a custom property value into a function.
</p>

<pre class="prod">
attr() = attr( `wq-name$t `attr-type$t? , `declaration-value$t?)

`attr-type@t
    = `string$v
    | `url$v
    | `ident$v
    | `color$v
    | `number$v
    | `percentage$v
    | `length$v
    | `angle$v
    | `time$v
    | `frequency$v
    | `flex$v
    | `dimension-unit$t
</pre>

<p>
`dimension-unit@t
生成規則は、次のいずれかに合致する：
◎
The &lt;dimension-unit&gt; production matches＼
</p>

<ul>
	<li>
~literal `%^l 文字（すなわち，.値に `%^l を伴う `delim-token$t ）。
◎
a literal "%" character (that is, a &lt;delim-token&gt; with a value of "%") or＼
</li>
	<li>
`ident-token$t 【！~ident】のうち，その.値に［
次に挙げる型~用の~CSS単位（ `px$u や `ms$u など）
］を伴うもの
⇒
`length$t ／ `angle$t ／ `time$t ／ `frequency$t ／ `flex$t
◎
an ident whose value is any of the CSS units for &lt;length&gt;, &lt;angle&gt;, &lt;time&gt;, &lt;frequency&gt;, or &lt;flex&gt; values (such as px or ms).
</li>
</ul>

<p>
`attr$f の引数は：
◎
The arguments of attr() are:
</p>

<dl>
	<dt>`wq-name$t</dt>
	<dd>
参照-先の属性の名前を与える。
◎
Gives the name of the attribute being referenced.
</dd>
	<dd>
名前空間は指定されていない場合（ `attr(foo)^v 様に識別子だけ与えられている）、暗黙に， ~NULL 名前空間になる。
（名前空間~付きの属性は希なので、通例的には，これが欲されるものになる
— 特に，［
~HTML／~SVG
］には、名前空間~付きの属性は無い。）
◎
If no namespace is specified (just an identifier is given, like attr(foo)), the null namespace is implied. (This is usually what’s desired, as namespaced attributes are rare. In particular, HTML and SVG do not contain namespaced attributes.)＼
</dd>
	<dd>
`wq-name$t における文字大小比較は、`属性~選択子$と同じく，文書~言語に依存する。
◎
As with attribute selectors, the case-sensitivity of &lt;wq-name&gt; depends on the document language.
</dd>
	<dd>
ある要素に適用される~propにおいて `attr$f が利用された場合、その要素~上の所与の名前の属性を参照する。
~propが`疑似要素$に適用される場合、その`出自の要素$上の属性が検索される。
◎
If attr() is used in a property applied to an element, it references the attribute of the given name on that element; if applied to a pseudo-element, the attribute is looked up on the pseudo-element’s originating element.
</dd>

	<dt>`attr-type$t</dt>
	<dd>
当の属性の値を，どの種類の~CSS値（ `attr$f の
`代用~値@
）として解釈するかを
— 値に対し行う特別な構文解析もあれば，それも含めて —
指定する。
◎
Specifies what kind of CSS value the attribute’s value will be interpreted into (the attr()’s substitution value) and what, if any, special parsing will be done to the value.
</dd>
	<dd>
アリな値, および それらの挙動は、
<a href="#attr-types">§ `attr^f の各~型</a>
にて定義される。
◎
The possible values and their behavior are defined in § 10.1 attr() Types.
</dd>
	<dd>
省略された場合の既定は、 `string$v になる。
◎
Defaults to string if omitted.
</dd>

	<dt>`declaration-value$t</dt>
	<dd>
`attr$f 用の
`~fallback値@
を指定する。
それは、［
属性は欠落しているか，属性の値を指定された型として構文解析するのに失敗した
］場合に，属性の値に代えて代用する値を与える。
◎
Specifies a fallback value for the attr(), which will be substituted instead of the attribute’s value if the attribute is missing or fails to parse as the specified type.
</dd>
	<dd>
省略された場合の既定は、
`attr-type$t 引数が［
`string$v の場合は空~文字列／
~ELSE_ `無効が保証される値$
］になる。
◎
If the &lt;attr-type&gt; argument is string, defaults to the empty string if omitted; otherwise, defaults to the guaranteed-invalid value if omitted.
</dd>
</dl>

<p>
~propが 1 個以上の `attr$f 関数を包含していて，それらの関数はどれも構文上は妥当である場合、~prop全体の文法は，構文解析-時においては妥当と見做すモノトスル。
その構文が検査されるのは、 `attr^f 関数が`代用-$された後の算出d値の時点に限られる。
◎
If a property contains one or more attr() functions, and those functions are syntactically valid, the entire property’s grammar must be assumed to be valid at parse time. It is only syntax-checked at computed-value time, after attr() functions have been substituted.
</p>

<p class="note">注記：
既定~値は、所与の型【 `attr-type$t 】にする必要はない。
一例として，作者が要求する属性の型は `px$u であったとしても、
<samp class="css">`width$p: `attr(size px, auto)^v;</samp>
の様に，既定は `auto^v にすることもできる。
◎
Note that the default value need not be of the type given. For instance, if the type required of the attribute by the author is px, the default could still be auto, like in width: attr(size px, auto);.
</p>

		<section id="attr-types">
<h3 title="attr() Types">10.1.  `attr^f の各~型</h3>

<div class="p">
<p>
`attr$f 関数の挙動は、
`attr-type$t 引数の値に部分的に依存する
— 以下においては：
</p>
<ul>
	<li>
当の要素は、関数が参照している属性を有しているとする。
</li>
	<li>
%属性~値 は、属性の値をそのまま表すとする。
</li>
	<li>
%成分~値 は、次の結果を表すとする
⇒
`成分~値を構文解析する$( %属性~値 )
</li>
	<li>
結果の`代用~値$に対する値 ε （なし）は、~fallbackを誘発することを意味する。
</li>
</ul>
◎
The behavior of the attr() function depends partially on the value of the &lt;attr-type&gt; argument:
</div>

<dl>
	<dt>`string@v</dt>
	<dd>
`代用~値$は、~CSS文字列であり，その.値には %属性~値 があてがわれる（~CSS構文解析や値の “整理” は遂行されない）。
◎
The substitution value is a CSS string, whose value is the literal value of the attribute. (No CSS parsing or "cleanup" of the value is performed.)
</dd>
	<dd>
%属性~値 が何であれ，~fallbackは誘発されない。
◎
No value triggers fallback.
</dd>

	<dt>`url@v</dt>
	<dd>
`代用~値$は、 `url$t 値であり，その~urlには %属性~値 があてがわれる（~CSS構文解析や値の “整理” は遂行されない）。
◎
The substitution value is a CSS &lt;url&gt; value, whose url is the literal value of the attribute. (No CSS parsing or "cleanup" of the value is performed.)
</dd>
	<dd class="note">注記：
`url$f の構文に関数を包含する能力があったならば、
`attr(foo url)^v は， `url(attr(foo string))^v に一致することになる。
◎
Note: If url() was syntactically capable of containing functions, attr(foo url) would be identical to url(attr(foo string)).
</dd>
	<dd>
%属性~値 が何であれ，~fallbackは誘発されない。
◎
No value triggers fallback.
</dd>

	<dt>`ident@v</dt>
	<dd>
<p>
`代用~値$は、
%属性~値 の`前後の~ASCII空白~列を剥いだ$結果 %結果 に応じて：
</p>
		<ul>
			<li>
【文字大小無視で？】［
空~文字列 ／ `~CSS全域~keyword$ ／ `default^v
］の場合は ε 。
</li>
			<li>
他の場合、 `custom-ident$t であり，その.値には %結果 があてがわれる（~CSS構文解析は遂行されない）。
</li>
		</ul>
◎
The substitution value is a CSS &lt;custom-ident&gt;, whose value is the literal value of the attribute, with leading and trailing ASCII whitespace stripped. (No CSS parsing of the value is performed.)
◎
If the attribute value, after trimming, is the empty string, there is instead no substitution value.
◎
If the &lt;custom-ident&gt;’s value is a CSS-wide keyword or default, there is instead no substitution value.
</dd>

	<dt>`color@v</dt>
	<dd>
`代用~値$は、［
%成分~値 は［
`hex-color$t ／
`有名~色$を.値にとる `ident-token$t 【！~ident】
］であるならば %成分~値 が与える `color$t ／
~ELSE_ ε
］
◎
Parse a component value from the attribute’s value. If the result is a &lt;hex-color&gt; or a named color ident, the substitution value is that result as a &lt;color&gt;.
◎
Otherwise there is no substitution value.
</dd>

	<dt>`number@v</dt>
	<dd>
`代用~値$は、［
%成分~値 は `number-token$t であるならば %成分~値 ／
~ELSE_ ε
］
◎
Parse a component value from the attribute’s value. If the result is a &lt;number-token&gt;, the result is the substitution value.
◎
Otherwise, there is no substitution value.
</dd>

	<dt>`percentage@v</dt>
	<dd>
`代用~値$は、［
%成分~値 は `percentage-token$t であるならば %成分~値 ／
~ELSE_ ε
］
◎
Parse a component value from the attribute’s value. If the result is a &lt;percentage-token&gt;, the result is the substitution value.
◎
Otherwise, there is no substitution value.
</dd>

	<dt>`length@v</dt>
	<dt>`angle@v</dt>
	<dt>`time@v</dt>
	<dt>`frequency@v</dt>
	<dt>`flex@v</dt>
	<dd>
`代用~値$は、［
%成分~値 は `dimension-token$t であって，その.単位は所与の型に合致するならば %成分~値 ／
~ELSE_ ε
］
◎
Parse a component value from the attribute’s value. If the result is a &lt;dimension-token&gt; whose unit matches the given type, the result is the substitution value.
◎
Otherwise, there is no substitution value.
</dd>

	<dt id="valdef-attr-dimension-unit">`dimension-unit$t</dt>
	<dd>
`代用~値$は、［
%成分~値 は `number-token$t であるならば［
%成分~値 の.値, 所与の単位
］を伴う`次元$ ／
~ELSE_ ε
］
◎
Parse a component value from the attribute’s value. If the result is a &lt;number-token&gt;, the substitution value is a dimension with the result’s value, and the given unit.
◎
Otherwise, there is no substitution value.
</dd>
</dl>

<p class="issue">
`attr^f 値として、各種`~math関数$を すべての数量-型~用に許容するよう求まれるか？
同様に， “色” 用にも各種 色~関数を許容するか？
編集者は そう~~考えているが、代用~値が更に参照~関数を包含していないことを確かめるため，内容を検査する必要も生じる
— <code>`foo^a="`rgb(var(--red), 0, 0)^v"</code>
は、 `attr(foo color)^v 用には違法になる必要がある。
◎
Do we want to allow math functions as attr values for all the numeric types? And color functions for "color"? I think we do, but I’d have to check the contents to make sure they don’t contain further reference functions; foo="rgb(var(--red), 0, 0)" needs to be illegal for attr(foo color).
</p>

<div class="example">

<p>
~XML~file内の~dataを可視化するために `attr$f を利用する例：
◎
This example shows the use of attr() to visually illustrate data in an XML file:
</p>

<pre class="lang-xml">
&lt;在庫&gt;
  &lt;木材 length="12"/&gt;
  &lt;木材 length="5"/&gt;
  &lt;金属 length="19"/&gt;
  &lt;木材 length="4"/&gt;
&lt;/在庫&gt;

在庫::before {
  display: block;
  content: "ある縮尺による，在庫の各素材の長さ：";
}
在庫 &gt; * {
  display: block;
  width: attr(length em, 0px);
  height: 1em;
  border: solid thin;
  margin: 0.5em;
}
木材 {
  background: orange url(wood.png);
}
金属 {
  background: silver url(metal.png);
}
</pre>

<!-- 
To scale, the lengths of materials in stock are:
-->

</div>

		</section>
		<section id="attr-substitution">
<h3 title="attr() Substitution">10.2. `attr^f の代用</h3>

<p class="issue">
`attr^f, `var^f は，同時に代用されるので、おそらく，
<a href="~CSSVAR#substitute-a-var">`var^f を代用する</a>
を，もっと一般に
“参照を代用する”
ように書直して、それを両~関数~用に利用するべきである。
◎
attr() and var() substitute at the same time, so I should probably rewrite substitute a var() to be more generally about "substitute a reference" and just use that for both of these functions.
</p>

<p>
`attr$f 関数は、算出d値の時点に`代用-$される。
所与の宣言は、［
宣言を成すすべての `attr^f 関数を代用した結果が、宣言~用に宣言された文法に合致しない
］場合には，`算出d値の時点で無効$になる。
◎
attr() functions are substituted at computed-value time. If a declaration, once all attr() functions are substituted in, does not match its declared grammar, the declaration is invalid at computed-value time.
</p>

<p>
所与の~propの値の中で `attr$f 関数 %関数 を
`代用-@
するときは：
◎
To substitute an attr():
</p>

<ol>
	<li>
~IF［
%関数 の`代用~値$ ~NEQ ε
］
⇒
%関数 を その代用~値に置換する
◎
If the attr() function has a substitution value, replace the attr() function by the substitution value.
</li>
	<li>
~ELIF［
%関数 の`~fallback値$は`無効が保証される値$でない
］
⇒
%関数 を その~fallback値に置換する
— ~fallback内に［
`var$f ／ `attr$f
］参照がある場合は，それらも`代用-$した上で
◎
Otherwise, if the attr() function has a fallback value as its last argument, replace the attr() function by the fallback value. If there are any var() or attr() references in the fallback, substitute them as well.
</li>
	<li>
~ELSE
⇒
当の~propは`算出d値の時点で無効$とする
◎
Otherwise, the property containing the attr() function is invalid at computed-value time.
</li>
</ol>
		</section>
	</section>
	<section id="math">
<h2 title="Mathematical Expressions">11. 数学的な式</h2>

<p>
`~math関数@
（ `calc$f, `clamp$f, `sin$f, その他，この節に定義するもの）は、数量~CSS値を数学的な式として書けるようにする。
◎
The math functions (calc(), clamp(), sin(), and others defined in this chapter) allow numeric CSS values to be written as mathematical expressions.
</p>

<p>
`~math関数$は、次に挙げるいずれかの数量-値, または［
`length-percentage$t 等々の複数の型が混在なもの
］を表現し，そのような値が妥当になる所ならどこでも利用できる
⇒＃
`length$t,
`frequency$t,
`angle$t,
`time$t,
`flex$t,
`resolution$t,
`percentage$t,
`number$t,
`integer$t
◎
A math function represents a numeric value, one of:
• &lt;length&gt;,
• &lt;frequency&gt;,
• &lt;angle&gt;,
• &lt;time&gt;,
• &lt;flex&gt;,
• &lt;resolution&gt;,
• &lt;percentage&gt;,
• &lt;number&gt;,
• &lt;integer&gt;
◎
...or the &lt;length-percentage&gt;/etc mixed types, and can be used wherever such a value would be valid.
</p>

<p class="trans-note">【
この節では、無限大（−∞／ +∞）に加えて，［
負な 0 を表す ~0N ／ 正な 0 を表す ~0P
］も利用される。
したがって、 0 は ~0N, ~0P の総称を表すことになる
— 特に，［
~0N は負な数とは見なされない（ ~0N ~LT 0 ではない） ／
~0P は正な数とは見なされない（ ~0P ~GT 0 ではない）
］ことに注意。
】</p>

		<section id="calc-func">
<h3 title="Basic Arithmetic: calc()">11.1. 基本的な算術： `calc^f</h3>

<p>
`calc@f
関数は，`~math関数$であり、［
加算（ `+^css ）,
減算（ `-^css ）,
乗算（ `*^css ）,
除算（ `/^css ）,
丸括弧
］を利用して，数量的な値に対し 基本的な算術を遂行できるようにする。
◎
The calc() function is a math function that allows basic arithmetic to be performed on numerical values, using addition (+), subtraction (-), multiplication (*), division (/), and parentheses.
</p>

<p>
`calc$f 関数は、 1 個の`計算式$を包含する。
`計算式@
は、いくつかの演算子が合間に挟まれ，場合によっては丸括弧により~group化された一連の値からなる（ `calc-sum$t 文法に合致する）。
それは、標準な演算子 優先順位~規則を利用して，式を評価した結果を表現する（各~演算子は、［
`*^css ／ `/^css
］が［
`+^css ／ `-^css
］より~~結合度が高いことを除いて，左から右の順に評価される）。
`calc^f 関数は、それが包含する`計算式$の結果を表現する。
◎
A calc() function contains a single calculation, which is a sequence of values interspersed with operators, and possibly grouped by parentheses (matching the &lt;calc-sum&gt; grammar), which represents the result of evaluating the expression using standard operator precedence rules. (* and / bind tighter than + and -, and operators are otherwise evaluated left-to-right.) The calc() function represents the result of its contained calculation.
</p>

<p>
`計算式$を成す各 成分は、［
~literal値（ `5px^v など）,
他の`~math関数$,
`attr$f などの他の式
］のいずれかであって，【式を利用している文脈において】妥当な引数~型（ `length$t など）に評価されるものをとれる。
◎
Components of a calculation can be literal values (such as 5px), other math functions, or other expressions, such as attr(), that evaluate to a valid argument type (like &lt;length&gt;).
</p>

<div class="example">

<p>
`~math関数$は、異なる単位を利用する値を組合せるときに利用できる。
次の例では、作者は各 `section^e の~margin~boxが空間の 1/3 を占めるよう求めているので，
`100%/3^v から 要素の~borderと~margin分を減算する。
（ `box-sizing$p は，~borderと~paddingに対しては この効果を自動的に達成できるが、~marginを含めたいと求める場合，~math関数が必要になる。）
◎
Math functions can be used to combine value that use different units. In this example the author wants the margin box of each section to take up 1/3 of the space, so they start with 100%/3, then subtract the element’s borders and margins. (box-sizing can automatically achieve this effect for borders and padding, but a math function is needed if you want to include margins.)
</p>

<pre class="lang-css">
section {
  float: left;
  margin: 1em; border: solid 1px;
  width: calc(100% / 3 - 2 * 1em - 2 * 1px);
}
</pre>

</div>

<div class="example">

<p>
同様に，次の例の~gradientは、要素の最初と最後の `20px^v 内に限り，色の遷移を示すことになる：
◎
Similarly, in this example the gradient will show a color transition only in the first and last 20px of the element:
</p>

<pre class="lang-css">
.fade {
  background-image: linear-gradient(
    silver 0%, white 20px, white calc(100% - 20px), silver 100%
  );
}
</pre>
</div>

<div class="example">

<p>
`~math関数$は、より自然かつ読易い~~形で値を表出するためだけでも
— ただの 10 進数より真意が見える点で —
有用になり得る。
次の例では、 `35em^v がちょうど表示域に収まるように `font-size$p を設定して，［
~screenの大きさを問わず，常に概ね同じ量の~textが~screenを埋める
］ことを確保している：
◎
Math functions can also be useful just to express values in a more natural, readable fashion, rather than as an obscure decimal. For example, the following sets the font-size so that exactly 35em fits within the viewport, ensuring that roughly the same amount of text always fills the screen no matter the screen size.
</p>

<pre class="lang-css">
:root {
  font-size: calc(100vw / 35);
}
</pre>

<p>
これは，~~機能上は "`font-size: 2.857vw^css" と書くのと同じことになるが、~codeを読んでいる誰かにとっては，その意図（ `35em^v が表示域を埋める）はずっと~~不明瞭になる
— その誰かは、後で逆算して， 2.857 は 100/35 を近似する~~意図で記されたことを解き明かすはめになる。
◎
Functionality-wise, this is identical to just writing font-size: 2.857vw, but then the intent (that 35em fills the viewport) is much less clear to someone reading the code; the later reader will have to reverse the math themselves to figure out that 2.857 is meant to approximate 100/35.
</p>
</div>

<div class="example">

<p>
標準な演算子 優先順位~規則が適用されるので、
`calc(2 + 3 * 4)^v は， `20^v ではなく `14^v に等しくなる。
◎
Standard mathematical precedence rules for the operators apply: calc(2 + 3 * 4) is equal to 14, not 20.
</p>

<p>
丸括弧を利用すれば、優先順位を操作できる：
`calc((2 + 3) * 4)^v は， `20^v に等しくなる。
◎
Parentheses can be used to manipulate precedence: calc((2 + 3) * 4) is instead equal to 20.
</p>

<p>
丸括弧と, 追加的な `calc$f 関数を入子にするのとは、等価になる。
上の `calc((2 + 3) * 4)^v は、 `calc(calc(2 + 3) * 4)^v と書いても等価になる。
これは、次の例のように，~~細切れな~~成分から `var$f を介して値を築き上げるときに有用になり得る：
◎
Parentheses and nesting additional calc() functions are equivalent; the preceding expression could equivalently have been written as calc(calc(2 + 3) * 4). This can be useful when building up values piecemeal via var(), such as in the following example:
</p>

<pre class="lang-css">
.aspect-ratio-box {
  --ar: calc(16 / 9); /* 【縦横比】 */
  --w: calc(100% / 3);
  --h: calc(var(--w) / var(--ar));
  width: var(--w);
  height: var(--h);
}
</pre>

<p>
`--ar^p の値は単純に `(16 / 9)^v と書く`こともできる^em。
一方， `--w^p は、全部的な `calc^f 関数として書く必要がある
— `--ar^p と同じく， `--h^p にて `calc$f 成分に利用されているが、
`width$p にも そのままに利用されているので，。
◎
Although --ar could have been written as simply --ar: (16 / 9);, --w is used both on its own (in width) and as a calc() component (in --h), so it has to be written as a full calc() function itself.
</p>
</div>

		</section>
		<section id="comp-func">
<h3 title="Comparison Functions: min(), max(), and clamp()">11.2. 比較~関数： `min^f, `max^f, `clamp^f</h3>

<p>
比較~関数
— `min$f, `max$f, `clamp$f —
は、複数の`計算式$を比較して，それらのうち 1 つの値を表現する。
◎
The comparison functions of min(), max(), and clamp() compare multiple calculations and represent the value of one of them.
</p>

<p>
［
`min@f
／
`max@f
］関数は、~comma区切りの 1 個~以上の`計算式$を包含し，最も［
小さい （負側の）／大きい（正側の）
］項を表現する。
◎
The min() or max() functions contain one or more comma-separated calculations, and represent the smallest (most negative) or largest (most positive) of them, respectively.
</p>

<p>
`clamp@f
関数は、 3 個の`計算式$
— %最小, %中央-, %最大 —
を順にとり，
%中央- 計算式を { %最小 〜 %最大 } の範囲内に切詰める計算を表現する。
%最大 と %最小 が競合する場合は %最小 が優先される（すなわち，
`clamp( 最小v, 値v, 最大v )^v
は、
`max( 最小v, min( 値v, 最大v ) ) )^v
と正確に同じ値を表現する）。
◎
The clamp() function takes three calculations—a minimum value, a central value, and a maximum value—and represents its central calculation, clamped according to its min and max calculations, favoring the min calculation if it conflicts with the max. (That is, given clamp(MIN, VAL, MAX), it represents exactly the same value as max(MIN, min(VAL, MAX))).
</p>

<div class="example">

<p>
［
`min$f ／ `max$f ／ `clamp$f
］は、［
値は “安全な” 制限-を超過しない
］ことを~~確保するために利用できる。
例えば， `font-size$p を表示域~単位で設定する “`responsive type^en 【~screen~sizeに合わせた~~植字】” であっても，可読性を確保する最小~sizeが求まれるかもしれない：
◎
min(), max(), and clamp() can be used to make sure a value doesn’t exceed a "safe" limit: For example, "responsive type" that sets font-size with viewport units might still want a minimum size to ensure readability:
</p>

<pre class="lang-css">
.type {
  /* <span class="comment">
`font-size^p を表示域の縦幅と横幅の平均の 10/100 倍に設定するが、
`12px^v は~~下回らないようにする。
◎
Set font-size to 10x the average of vw and vh, but don’t let it go below 12px.
</span> */
  font-size: max(10 * (1vw + 1vh) / 2, 12px);
}
</pre>

<p class="note">注記：
どの引数にも全部的な~math式が許容されるので、内側に `calc$f を入子にする必要はない。
適用する拘束が複数あるならば、 3 個~以上の引数も供せる。
◎
Note: Full math expressions are allowed in each of the arguments; there’s no need to nest a calc() inside! You can also provide more than two arguments, if you have multiple constraints to apply.
</p>

</div>

<div class="example">

<p>
何かに［
最小~値を課すときは `max$f ／ 最大~値を課すときは `min$f
］を利用することになるが（すなわち， `min-width$p の様な~propは、実質的に `max^f を利用する）、これは，反対の関数に混同され易くもある
— 最小~sizeを追加するときに不用意に `min^f を利用してしまうなど。
`clamp$f を利用すれば、値は 最小と最大の合間に~~挟まれるので，~codeはより自然に読めるようになる：
◎
An occasional point of confusion when using min()/max() is that you use max() to impose a minimum value on something (that is, properties like min-width effectively use max()), and min() to impose a maximum value on something; it’s easy to accidentally reach for the opposite function and try to use min() to add a minimum size. Using clamp() can make the code read more naturally, as the value is nestled between its minimum and maximum:
</p>

<pre class="lang-css">
.type {
  /* <span class="comment">
`font-size^p を `12px^v と `100px^v の合間に~~居座るよう強制する
◎
Force the font-size to stay between 12px and 100px
</span> */
  font-size: clamp(12px, 10 * (1vw + 1vh) / 2, 100px);
}</pre>

</div>

<div class="note">

<p>注記：
`clamp$f の最小~値は最大~値に
— その 2 つの “順序が間違っている” ときでも —
“勝つ” ことに注意（他の部分は、~CSS規約に合致しているとする）。
すなわち、 `clamp(100px, ..., 50px)^v は `100px^v に解決されることになる
— “最大” として与えられた `50px^v を超過して。
◎
Note that clamp(), matching CSS conventions elsewhere, has its minimum value "win" over its maximum value if the two are in the "wrong order". That is, clamp(100px, ..., 50px) will resolve to 100px, exceeding its stated "max" value.
</p>

<p>
別の解決-法が欲される場合、 `clamp$f と `min$f ／ `max$f を組合せれば達成できる：
◎
If alternate resolution mechanics are desired they can be achieved by combining clamp() with min() or max():
</p>

<dl>
	<dt>
最大v が 最小v に勝つようにするためには：
◎
To have MAX win over MIN:
</dt>
	<dd>
`clamp( min( 最小v, 最大v ), 値v, 最大v )^v
◎
clamp(min(MIN, MAX), VAL, MAX).＼
</dd>
	<dd>
最大v の計算を繰返すのを避けたいなら、単に `clamp$f に定義した関数の入子ngを逆にする~~方法もある
⇒
`min( 最大v, max( 最小v, 値v ) )^v
◎
If you want to avoid repeating the MAX calculation, you can just reverse the nesting of functions that clamp() is defined against—min(MAX, max(MIN, VAL)).
</dd>

	<dt>
順序が間違っているときには、 最大vと最小v を “入替える” ようにするためには：
◎
To have MAX and MIN "swap" when they’re in the wrong order:
</dt>
	<dd>
`clamp( min( 最小v, 最大v ), 値v, max( 最小v, 最大v ) )^v
◎
clamp(min(MIN, MAX), VAL, max(MIN, MAX)).＼
</dd>
	<dd>
あいにく， 最小v, 最大v 項を繰返すことなく これを行う容易な仕方は無い。
◎
Unfortunately, there’s no easy way to do this without repeating the MIN and MAX terms.
</dd>
</dl>

</div>

		</section>
		<section id="round-func">
<h3 title="Stepped Value Functions: round(), mod(), and rem()">11.3. 丸ng関数と剰余~関数： `round^f, `mod^f, `rem^f</h3>

<p>
丸ng関数 `round$f と剰余~関数［
`mod$f ／ `rem$f
］は、どれも，所与の値を別の “段差~値” に則って異なる仕方で変形する。
（これらは、 `stepped-value^en 関数と総称される）。
◎
The stepped-value functions, round(), mod(), and rem(), all transform a given value according to another "step value", in different ways.
</p>

<p>
`round(~vC?, ~vA, ~vB)@f
関数は、それが包含する［
丸ng策を表す省略可能な `rounding-strategy$t 値 ~vC,
丸められる`計算式$ ~vA,
精度を表す`計算式$ ~vB
］に対し， ~vA を［
~vB の整数~倍
］のうち
— ~vC に則って，~vA 以上または以下の —
最も近い値に丸めた結果を返す。
◎
The round(&lt;rounding-strategy&gt;?, A, B) function contains an optional rounding strategy, and two calculations A and B, and returns the value of A, rounded according to the rounding strategy, to the nearest integer multiple of B either above or below A.＼
</p>

<p>
~vA, ~vB は，［
`number$t,
`dimension$t,
`percentage$t
］のどれにも解決し得るが、それらの`型を決定-$した結果は`同じ^emにならなければナラナイ
— さもなければ関数は無効になるとする。
結果の`型$は、引数のそれと同じになる。
◎
The argument calculations can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have the same type, or else the function is invalid; the result will have the same type as the arguments.
</p>

<p>
~vA が ~vB の整数~倍に正確に等しい場合、
`round$f は正確に ~vA に解決される（ ~vA が ~0N, ~0P どちらなのかも保全される）。
他の場合、
~vB の整数~倍のうち ~vA に “最も近いもの” は［
−∞ に近い方 %低いB,
+∞ に近い方 %高いB
］の 2 つがある。
どちらを選ぶかは、 ~vC に与える
`rounding-strategy@t
が規定する：
◎
If A is exactly equal to an integer multiple of B, round() resolves to A exactly (preserving whether A is 0⁻ or 0⁺, if relevant). Otherwise, there are two integer multiples of B that are potentially "closest" to A, lower B which is closer to −∞ and upper B which is closer to +∞. The following &lt;rounding-strategy&gt;s dictate how to choose between them:
</p>

<dl>
	<dt>`nearest@v</dt>
	<dd>
%低いB,
%高いB
のうち ~vA からの差が（絶対~値として）小さい方を選ぶ。
差が等しい場合は %高いB を選ぶ。
◎
Choose whichever of lower B and upper B that has the smallest absolute difference from A. If both have an equal difference (A is exactly between the two values), choose upper B.
</dd>

	<dt>`up@v</dt>
	<dd>
%高いB を選ぶ。
◎
Choose upper B.
</dd>

	<dt>`down@v</dt>
	<dd>
%低いB を選ぶ。
◎
Choose lower B.
</dd>

	<dt>`to-zero@v</dt>
	<dd>
%低いB, %高いB のうち絶対~値が小さい方を選ぶ。
◎
Choose whichever of lower B and upper B that has the smallest absolute difference from 0.
</dd>
</dl>

<p>
［
%低いB ／ %高いB
］は、 0 になる場合には，特定的に［
~0P ／ ~0N
］になるとする。
◎
If lower B would be zero, it is specifically equal to 0⁺; if upper B would be zero, it is specifically equal to 0⁻.
</p>

<p>
`rounding-strategy$t が省略された場合の既定は、 `nearest$v とする。
◎
If &lt;rounding-strategy&gt; is omitted, it defaults to nearest.
</p>

<div class="example">

<p>
JSの様な，（整数に）丸める自然な “精度” を備える言語と違って、~CSS値には，そのような精度は無い
— 値は様々な`互換$な単位で記され得るので。
なので、精度は明示的に与える必要がある。
`round(var(--width), 50px)^v と書いたなら、横幅（ `--width^p の値）を最も近い `50px^v の整数倍に丸めることになる。
◎
Unlike languages like JavaScript which have a natural "precision" to round to (integers), CSS values have no such precision because values can be written in many different compatible units. As such, the precision has to be given explicitly; to round a width to the nearest 50px, one can write round(var(--width), 50px).
</p>
</div>

<p class="note">注記：
~JSを含む~programming言語には、各種 丸ng策を別々な丸ng関数に分離しているものもある。
~JSの［
`Math.floor()^c ／
`Math.ceil()^c ／
`Math.trunc()^c ／ 
`Math.round()^c 
］は、~CSSの［
`round(down, …)^v ／
`round(up, …)^v ／
`round(to-zero, …)^v ／
`round(nearest, …)^v （あるいは単に `round(…)^v ）
］に等価になる。
◎
Note: JavaScript and other programming languages sometimes separate out the rounding strategies into separate rounding functions. JS’s Math.floor() is equivalent to CSS’s round(down, ...); JS’s Math.ceil() is equivalent to CSS’s round(up, ...); JS’s Math.trunc() is equivalent to CSS’s round(to-zero, ...); and JS’s Math.round() is equivalent to CSS’s round(nearest, ...), or just round(...).
</p>

<p class="note">注記：
`rounding-strategy$t を成す各~keywordは、
`block-step-round$p 【！ `block-step-size$p 】用の~keywordと同じであり，同じ挙動を備える（
`block-step-round^p は `to-zero$v だけ欠いているが
— `塊~size$は負になり得ず， `to-zero^v は `down$v に一致することになるので）。
◎
Note: The &lt;rounding-strategy&gt; keywords are the same as the keywords in block-step-size and have the same behavior. (block-step-size just lacks to-zero; since block sizes are always non-negative, to-zero and down would be identical.)
</p>

<p>
剰余~関数
`mod(~vA, ~vB)@f
と
`rem(~vA, ~vB)@f
は、類似する（
"mod" は “`modulus^en”  の略, "rem" は “`remainder^en” の略
）。
どちらも，それが包含する［
~~被除数を表す`計算式$ ~vA,
段差を表す`計算式$ ~vB
］に対し，
~vA から ~vA を丸めた結果
— ~vA 以上または以下の， ~vA に最も近い ~vB の整数~倍 —
を減算した結果を返す。
◎
The modulus functions mod(A, B) and rem(A, B) similarly contain two calculations A and B, and return the difference between A and the nearest integer multiple of B either above or below A.＼
</p>

<p>
~vA, ~vB は，［
`number$t,
`dimension$t,
`percentage$t
］のどれにも解決し得るが、それらの`型を決定-$した結果は`同じ^emにならなければナラナイ
— さもなければ関数は無効になるとする。
結果の`型$は、引数のそれと同じになる。
◎
The argument calculations can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have the same type, or else the function is invalid; the result will have the same type as the arguments.
</p>

<p>
この 2 つの関数はとても類似する：
◎
The two functions are very similar, and＼
</p>

<ul>
	<li>
<div class="p">
<p>
事実，引数 ~vA, ~vB の符号nが一致する場合、結果は一致する。
関数の値は、その結果が次の範囲に入るように，
~vA の値を ~vB のある整数~倍でずらした結果に等しくなる：
</p>
		<ul id="between-zero-and-b">
			<li>
引数が負ならば
⇒
~vB ~LT 結果 ~LTE ~0N （ “負な範囲” ）
— 結果が 0 になる場合は ~0N を選ぶ
</li>
			<li>
引数が正ならば
⇒
~0P ~LTE 結果 ~LT ~vB （ “正な範囲” ）
— 結果が 0 になる場合は ~0P を選ぶ
</li>
		</ul>

◎
in fact return identical results if both arguments are positive or both are negative: the value of the function is equal to the value of A shifted by the integer multiple of B that brings the value between zero and B. (Specifically, the range includes zero and excludes B. More specifically, if B is positive the range starts at 0⁺, and if B is negative it starts at 0⁻.)
</div>

<div class="example">

<p>
例えば，
`mod(18px, 5px)^v
は、値 `3px^v に解決される
— `18px^v から `5px^v の 3 倍 を減算すれば `3px^v が得られ，それが
`0px^v と `5px^v 【！3px】の合間に入る唯一の値なので。
◎
For example, mod(18px, 5px) resolves to the value 3px, because subtracting 5px * 3 from 18px yields 3px, which is the only such value between 0px and 3px.
</p>

<p>
同様に，
`mod(-140deg, -90deg)^v
は、値 `-50deg^v に解決される
— `-140deg^v に `-90deg^v  の 1 倍を加算すれば `-50deg^v が得られ，それが
`0deg^v と `-90deg^v の合間に入る唯一の値なので。
◎
Similarly, mod(-140deg, -90deg) resolves to the value -50deg, because adding -90deg * 1 to -140deg yields -50deg, which is the only such value between 0deg and -90deg.
</p>

<p>
これら各~例を `rem$f で評価した結果は、正確に同じになる。
◎
Evaluating either of these examples with rem() yields the exact same results.
</p>

</div>

	</li>
	<li>
<p>
~vA, ~vB の符号nが一致しない場合、
2 つの関数の挙動は分岐する：
◎
Their behavior diverges if the A value and the B step are on opposite sides of zero:＼
</p>
<ul>
			<li>
`mod$f は、結果の範囲を ~vB の符号nに基づいて選ぶ。
【 ~vB が 0 の事例は、下の下位節を見よ。】
◎
mod() (short for “modulus”) continues to choose the integer multiple of B that puts the value between zero and B, as above (guaranteeing that the result will either be zero or share the sign of B, not A), while＼
</li>
			<li>
`rem$f は、結果の範囲を ~vA の符号nに基づいて選ぶ。
【 ~vA が 0 の場合も， ~0N か ~0P かに応じて範囲を選ぶ（結果が同じ ~0N ／ ~0P になるよう）。】
◎
rem() (short for "remainder") chooses the integer multiple of B that puts the value between zero and -B, avoiding changing the sign of the value.
</li>
		</ul>

<p class="trans-note">【
これらの規則は、引数の符号nが一致する場合も包摂することになる。
】</p>

<div class="example">

<p>
例えば， `mod(-18px, 5px)^v は、値 `2px^v に解決される
— `-18px^v に `5px^v の 4 倍を加算すれば `2px^v が得られ，それが
`0px^v と `5px^v の合間に入る。
◎
For example, mod(-18px, 5px) resolves to the value 2px: adding 5px * 4 to -18px yields 2px, which is between 0px and 5px.
</p>

<p>
他方， `rem(-18px, 5px)^v は、値 `-3px^v に解決される
— `-18px^v に `5px^v の 3 倍を加算すれば，
`-18px^v と同じ符号nの `-3px^v が得られ、それが
`0px^v と `-5px^v の合間に入る。
◎
On the other hand, rem(-18px, 5px) resolves to the value -3px: adding 5px * 3 to -18px yields -3px, which has the same sign as -18px but is between 0px and -5px.
</p>

<p>
同様に，
`mod(140deg, -90deg)^v は，値 `-40deg^v に解決されるが（
`140deg^v に `-90deg^v の 2 倍を加算すれば，
`0deg^v と `-90deg^v の合間に入る）、
`rem(140deg, -90deg)^v は，値 `50deg^v に解決される。
◎
Similarly, mod(140deg, -90deg) resolves to the value -40deg (adding -90deg * 2 to 140deg, bringing it to between 0deg and -90deg), but rem(140deg, -90deg) resolves to the value 50deg.
</p>
</div>

	</li>
</ul>

<details class="note">
<summary>
`mod$f, `rem$f
のどっちを選ぶべきか？
◎
When should I choose mod() vs rem()?
</summary>

<p>
この演算の利用者は、概して，段差~値（ ~vB ）を制御して，未知な値 ~vA を改変する。
それゆえ，`通例的には^em、
~vA の符号nに関わらず，結果は 0 と ~vB の合間に入る方が期待される
— すなわち， `mod$f が選ばれるべきである。
◎
Typically, users of this operation are in control of the step value (B), and are modifying an unknown value A. As a result, it’s usually more expected that the result is between 0 and B, regardless of A’s sign, meaning mod() should be chosen.
</p>

<p>
作者が例えば，ある長さが `px^u ~~単位で偶数／奇数どちらになるか知りたいと求める場合（ここでは、長さは `px^u の整数倍であると見做す）、
`mod(~vA, 2px)^v は ~vA の値が何であれ，
`0px^v か `1px^v
を返すことになる。
他方，`rem(~vA, 2px)^v は、
~vA が偶数 `px^u なら `0px^v を返すが，奇数の場合は ~vA に依存して［
正ならば `1px^v ／負ならば `-1px^v
］を返すことになる。
◎
For example, if an author wants to know whether a length is an even or odd number of pixels, mod(A, 2px) will return either 0px or 1px (assuming the value is a whole number of pixels to begin with), regardless of the value of a. rem(A, 2px), on the other hand, will return 0px if A is an even number of pixels, but will return either 1px or -1px if it’s odd, depending on whether A is positive or negative.
</p>

<p>
しかしながら，反対の状況もあり【すなわち、 ~vB が未知】、それをまかなうために `rem$f が供されている。
また、 `rem^f は~JSの `%^c 演算子の挙動を備えるので、~CSSと~JS~codeとが正確に合致することが欲される場合には `rem^f が有用になり得る。
◎
The opposite situation does sometimes occur, however, and so rem() is provided to cater to that. As well, rem() is the behavior of JavaScript’s % operator, so if an exact match between CSS and JS code is desired, rem() can be useful.
</p>
</details>

<div class="note">
<p>注記：
`mod$f, `rem$f は、他の関数でも直に定義できる：
</p>

<ul>
	<li>
<p>
`mod(~vA, ~vB)^v は、次に等価になる
⇒
`calc(~vA - sign(~vB)*round(down, ~vA*sign(~vB), ~vB))^v
</p>
<p>
（ ~vB が［
正なら `calc(~vA - round(down, ~vA, ~vB))^v ／
負なら `calc(~vA - round(up, ~vA, ~vB))^v
］が得られるようにした式）
</p>
	</li>
	<li>
`rem(~vA, ~vB)^v は、次に等価になる
⇒
`calc(~vA - round(to-zero, ~vA, ~vB))^v
</li>
</ul>

<p>
（これらの式は、 ~0P, ~0N を常に正しく取扱うわけではないが
— ~0N の意味論は加算において可換でないので。）
</p>
◎
Note: mod() and rem() can also be defined directly in terms of other functions: mod(A, B) is equivalent to calc(A - sign(B)*round(down, A*sign(B), B)) (a hacky way to say "round(down) when B is positive, round(up) when B is negative), while rem(A, B) is equivalent to calc(A - round(to-zero, A, B)). (These expressions don’t always handle 0⁺ and 0⁻ correctly, though, because 0⁻ semantics aren’t commutative for addition.)
</div>

			<section id="round-infinities">
<h4 title="Argument Ranges">11.3.1. 引数の範囲</h4>

<p>
`round(~vA, ~vB)$f
においては：
◎
In round(A, B),＼
</p>

<ul>
	<li>
~vB ~IN { ~0N, ~0P } ならば，結果は ~NaN になる。
◎
if B is 0, the result is NaN.＼
</li>
	<li>
~vA ~IN { +∞, −∞ } ならば
⇒＃
~vB ~IN { +∞, −∞ } ならば，結果は ~NaN になる
他の場合，結果は ~vA になる
◎
If A and B are both infinite, the result is NaN.
◎
If A is infinite but B is finite, the result is the same infinity.
</li>
	<li>
<p>
他の場合， ~vB ~IN { +∞, −∞ } ならば、
`rounding-strategy$t に応じて：
◎
If A is finite but B is infinite, the result depends on the &lt;rounding-strategy&gt; and the sign of A:
</p>
		<ul class="switch">
			<li>
`nearest$v ／ `to-zero$v
⇒＃
~vA ~EQ ~0P または ~vA ~GT 0 ならば，結果は ~0P になる／
~vA ~EQ ~0N または ~vA ~LT 0 ならば，結果は ~0N になる
◎
nearest
to-zero
• If A is positive or 0⁺, return 0⁺. Otherwise, return 0⁻.
</li>
			<li>
`up$v
⇒＃
~vA ~GT 0 ならば，結果は +∞ になる／
~vA ~EQ ~0P ならば，結果は ~0P になる／
~vA ~EQ ~0N または ~vA ~LT 0 ならば，結果は ~0N になる
◎
up
• If A is positive (not zero), return +∞. If A is 0⁺, return 0⁺. Otherwise, return 0⁻.
</li>
			<li>
`down$v
⇒＃
~vA ~EQ ~0P または ~vA ~GT 0 ならば，結果は ~0P になる／
~vA ~EQ ~0N ならば，結果は ~0N になる／
~vA ~LT 0 ならば，結果は −∞ になる
◎
down
• If A is negative (not zero), return −∞. If A is 0⁻, return 0⁻. Otherwise, return 0⁺.
</li>
		</ul>
	</li>
</ul>

<p>
［
`mod(~vA, ~vB)$f ／
`rem(~vA, ~vB)$f
］においては、次のいずれかに該当する場合，結果は ~NaN になる：
</p>

<ul>
	<li>
~vB ~IN { ~0N, ~0P }
◎
In mod(A, B) or rem(A, B), if B is 0, the result is NaN.＼
</li>
	<li>
~vA ~IN { +∞, −∞ }
◎
If A is infinite, the result is NaN.
</li>
	<li>
<div class="P">
<p>
`mod(~vA, ~vB)$f の場合に限り：
</p>
		<ul>
			<li>
［
~vB ~EQ +∞
］~AND［
~vA ~LT 0
］
</li>
			<li>
［
~vB ~EQ −∞
］~AND［
~vA ~GT 0
］
</li>
		</ul>

◎
In mod(A, B) only, if B is infinite and A is non-zero and has opposite sign to B, the result is NaN.
</div>

<p class="note">注記：
他のすべての “無限な ~vB ” の事例は妥当であり、単に ~vA を返す。
◎
Note: All other "infinite B" cases are valid, and just return A immediately.
</p>
	</li>
</ul>

			</section>
		</section>
		<section id="trig-funcs">
<h3 title="Trigonometric Functions: sin(), cos(), tan(), asin(), acos(), atan(), and atan2()">11.4. 三角-関数： `sin^f, `cos^f, `tan^f, `asin^f, `acos^f, `atan^f, `atan2^f</h3>

<p>
三角-関数
— `sin$f, `cos$f, `tan$f, `asin$f, `acos$f, `atan$f, `atan2$f —
は、様々な基本的な三角-関係性を算出する。
◎
The trigonometric functions—sin(), cos(), tan(), asin(), acos(), atan(), and atan2()—compute the various basic trigonometric relationships.
</p>

<p>
［
`sin(~vA)@f
／
`cos(~vA)@f
／
`tan(~vA)@f
］関数は、 1 個の`計算式$ ~vA を包含する
— ~vA は、［
`number$t または `angle$t
］に解決されなければナラナイ。
これらの関数は、 ~vA を~radianとして解釈する下で，それぞれに対応している関数を算出した結果を返すモノトスル（すなわち，［
`sin(45deg)^v, `sin(.125turn)^v, `sin(3.14159 / 4)^v
］は、どれも同じ値（約 `.707^v ）を表現する）。
それらはすべて `number^t を表現する。
［
`sin$f ／ `cos$f
］は，常に −1 以上 1 以下の実数を返す一方で、
`tan$f は ±∞ も含むどの実数も返し得る。
（`~math関数$が ∞ をどう取扱うかについての詳細は`§ 型の検査-法$を見よ。）
◎
The sin(A), cos(A), and tan(A) functions all contain a single calculation which must resolve to either a &lt;number&gt; or an &lt;angle&gt;, and compute their corresponding function by interpreting the result of their argument as radians. (That is, sin(45deg), sin(.125turn), and sin(3.14159 / 4) all represent the same value, approximately .707.) They all represent a &lt;number&gt;; sin() and cos() will always return a number between −1 and 1, while tan() can return any number between −∞ and +∞. (See § 11.9 Type Checking for details on how math functions handle ∞.)
</p>

<p>
［
`asin(~vA)@f
／
`acos(~vA)@f
／
`atan(~vA)@f
］関数は、 “逆” 三角-関数であり、［
それぞれに対応する “通常の” 三角-関数
］に対する逆-関数を表現する。
いずれも， 1 個の`計算式$ ~vA を包含する。
~vA は、 `number$t に解決されなければナラナイ。
これらの関数は、それぞれに対応している関数を算出した結果を `angle$t を表現している~radian数として解釈してから，次の範囲に正規化した角度として返すモノトスル
⇒＃
`asin$f 用には `-90deg^v 以上, `90deg^v 以下 ／
`acos$f 用には `0deg^v 以上, `180deg^v 以下 ／
`atan$f 用には `-90deg^v 以上, `90deg^v 以下
◎
The asin(A), acos(A), and atan(A) functions are the "arc" or "inverse" trigonometric functions, representing the inverse function to their corresponding "normal" trig functions. All of them contain a single calculation which must resolve to a &lt;number&gt;, and compute their corresponding function, interpreting their result as a number of radians, representing an &lt;angle&gt;. The angle returned by asin() must be normalized to the range [-90deg, 90deg]; the angle returned by acos() to the range [0deg, 180deg]; and the angle returned by atan() to the range [-90deg, 90deg].
</p>

<p>
`atan2(~vA, ~vB)@f
関数は、~comma区切りの 2 個の`計算式$ ~vA, ~vB を包含する。
~vA, ~vB は［
`number$t,
`dimension$t,
`percentage$t
］のどれにも解決し得るが、`型を決定-$した結果は，`同じ^emにならなければナラナイ
— さもなければ、関数は無効になるとする。
この関数は、正な X 軸から点 ( ~vB, ~vA ) までの `angle$t を
`-180deg^v 以上, `180deg^v 未満の角度に正規化して返すモノトスル。
◎
The atan2(A, B) function contains two comma-separated calculations, A and B. A and B can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have the same type, or else the function is invalid. The function returns the &lt;angle&gt; between the positive X-axis and the point (B,A). The returned angle must be normalized to the interval (-180deg, 180deg] (that is, greater than -180deg, and less than or equal to 180deg).
</p>

<p class="note">注記：
`atan2(~vA, ~vB)$f
は，`一般に^em
`atan(~vA / ~vB)$f
と等価になるが、対応する点 ( ~vB, ~vA ) が負な成分を含み得るときには，より良い答えを与える。
点 ( −1, 1 ) に対応する `atan2(1, -1)^v は `135deg^v を返す一方で、点 ( 1, −1 ) に対応する `atan2(-1, 1)^v は `-45deg^v を返す。
対照的に
`atan(1 / -1)^v, `atan(-1 / 1)^v
は、両者とも `-45deg^v を返す
— 両者とも内部的な計算は `-1^v に解決されるので。
◎
Note: atan2(Y, X) is generally equivalent to atan(Y / X), but it gives a better answer when the point in question may include negative components. atan2(1, -1), corresponding to the point (-1, 1), returns 135deg, distinct from atan2(-1, 1), corresponding to the point (1, -1), which returns -45deg. In contrast, atan(1 / -1) and atan(-1 / 1) both return-45deg, because the internal calculation resolves to -1 for both.
</p>

			<section id="trig-infinities">
<h4 title="Argument Ranges">11.4.1. 引数の範囲</h4>

<p>
［
`sin(~vA)^v ／ `cos(~vA)^v ／ `tan(~vA)^v
］においては、 ~vA が ±∞ ならば，結果は ~NaN になる。
（`~math関数$が ~NaN をどう取扱うかの詳細は、`§ 型の検査-法$を見よ。）
◎
In sin(A), cos(A), or tan(A), if A is infinite, the result is NaN. (See § 11.9 Type Checking for details on how math functions handle NaN.)
</p>

<p>
［
`sin(~vA)^v ／ `tan(~vA)^v
］においては、
~vA ~EQ ~0N
ならば，結果は ~0N になる。
◎
In sin(A) or tan(A), if A is 0⁻, the result is 0⁻.
</p>

<p>
`tan(~vA)^v
において， ~vA が漸近~値（ `90deg^v, `270deg^v, 等）である場合の結果は、［
`90deg^v との差が `360deg^v の整数倍である値（
`-270deg^v, `90deg^v, `450deg^v
など）
］に対しては +∞ になり，［
`-90deg^v との差が `360deg^v の整数倍である値（
`-450deg^v, `-90deg^v, `270deg^v
など）
］に対しては −∞ になるモノトスル。
◎
In tan(A), if A is one of the asymptote values (such as 90deg, 270deg, etc), the result must be +∞ for 90deg and all values a multiple of 360deg from that (such as -270deg or 450deg), and −∞ for -90deg and all values a multiple of 360deg from that (such as -450deg or 270deg).
</p>

<p class="note">注記：
これが関連するのは、 `deg$u や `grad$u など，漸近的な値を正確に表現できる単位に限られる。
`rad$u では表現できないので、結果が巨大な［
負な／正な
］値になるかどうかは，［
丸ng, 実数が内部的にどう格納されるか
］の精確な詳細~に依存し得る。
そのような単位を利用している作者は、この挙動に依存しないことが推奨される。
◎
Note: This is only relevant for units that can exactly represent the asymptotic values, such as deg or grad. rad cannot, and so whether the result is a very large negative or positive value can depend on rounding and precise details of how numbers are internally stored. It’s recommended you don’t depend on this behavior if using such units.
</p>

<p>
［
`asin(~vA)^v ／ `acos(~vA)^v
］においては、［
−1 ~LTE ~vA ~LTE 1
］でないならば，結果は ~NaN になる。
◎
In asin(A) or acos(A), if A is less than -1 or greater than 1, the result is NaN.
</p>

<p>
`acos(~vA)^v においては、
~vA ~EQ 1
ならば，結果は 0 になる。
◎
In acos(A), if A is exactly 1, the result is 0.
</p>

<p>
［
`asin(~vA)^v ／ `atan(~vA)^v
］においては、
~vA ~EQ ~0N
ならば，結果は ~0N になる。
◎
In asin(A) or atan(A), if A is 0⁻, the result is 0⁻.
</p>

<p>
`atan(~vA)^v
においては
⇒＃
~vA ~EQ +∞ ならば，結果は `90deg^v になる ／
~vA ~EQ −∞ ならば，結果は `-90deg^v になる
◎
In atan(A), if A is +∞, the result is 90deg; if A is −∞, the result is -90deg.
</p>

<p>
<code class="func">atan(%Y, %X)</code>
においては、すべての通例でない引数の組合nの結果は，次の表で与えられる：
◎
In atan2(Y, X), the following table gives the results for all unusual argument combinations:
</p>

<div>
<table class="math-matrix">
<caption>
左端見出しは %Y,
上端見出しは %X
の値を表す。
結果の数はすべて `deg$u 単位とする。
</caption>

<thead><tr><td>
<th>−∞
<th>有限（負）
<th>~0N
<th>~0P
<th>有限（正）
<th>+∞
</thead><tbody>

<tr><th>−∞
<td>−135
<td>−90
<td>−90
<td>−90
<td>−90
<td>−45

<tr><th>有限（負）
<td>−180
<td>（通常）
<td>−90
<td>−90
<td>（通常）
<td>~0N

<tr><th>~0N
<td>−180
<td>−180
<td>−180
<td>~0N
<td>~0N
<td>~0N

<tr><th>~0P
<td>180
<td>180
<td>180
<td>~0P
<td>~0P
<td>~0P

<tr><th>有限（正）
<td>180
<td>（通常）
<td>90
<td>90
<td>（通常）
<td>~0P

<tr><th>+∞
<td>135
<td>90
<td>90
<td>90
<td>90
<td>45
</tbody></table>

◎
 ｜ X
 ｜ −∞ ｜ -finite ｜ 0⁻ ｜ 0⁺ ｜ +finite ｜ +∞
Y ｜ −∞ ｜ -135deg ｜ -90deg ｜ -90deg ｜ -90deg ｜ -90deg ｜ -45deg
-finite ｜ -180deg ｜ (normal) ｜ -90deg ｜ -90deg ｜ (normal) ｜ 0⁻deg
0⁻ ｜ -180deg ｜ -180deg ｜ -180deg ｜ 0⁻deg ｜ 0⁻deg ｜ 0⁻deg
0⁺ ｜ 180deg ｜ 180deg ｜ 180deg ｜ 0⁺deg ｜ 0⁺deg ｜ 0⁺deg
+finite ｜ 180deg ｜ (normal) ｜ 90deg ｜ 90deg ｜ (normal) ｜ 0⁺deg
+∞ ｜ 135deg ｜ 90deg ｜ 90deg ｜ 90deg ｜ 90deg ｜ 45deg
</div>

<p class="note">注記：
これらの関数の挙動はすべて、ほとんどの~programming言語
— 特に~JS —
に実装されている “標準な” 定義に合致することが意図されている。
◎
Note: All of these behaviors are intended to match the "standard" definitions of these functions as implemented by most programming languages, in particular as implemented in JS.
</p>

<p class="note">注記：
`tan(90deg)^v の挙動は、~JSの挙動からは拘束されないが（~JS関数の入力は~radianであり、~JS実数では値 π ~DIV 2 を完璧には表出し得ないので），値の往来が働くように定義される
— 次が得られるように
⇒＃
`tan(atan(infinity))^v からは +∞ ／
`tan(atan(-infinity))^v からは −∞ ／
`atan(tan(90deg))^v からは `90deg^v ／
`atan(tan(-90deg))^v からは `-90deg^v
◎
Note: The behavior of tan(90deg), while not constrained by JS behavior (because the JS function’s input is in radians, and one cannot perfectly express a value of π/2 in JS numbers), is defined so that roundtripping of values works; tan(atan(infinity)) yields +∞, tan(atan(-infinity)) yields −∞, atan(tan(90deg)) yields 90deg, and atan(tan(-90deg)) yields -90deg.
</p>

			</section>
		</section>
		<section id="exponent-funcs">
<h3 title="Exponential Functions: pow(), sqrt(), hypot(), log(), exp()">11.5. 指数-関数： `pow^f, `sqrt^f, `hypot^f, `log^f, `exp^f</h3>

<p>
指数-関数
— `pow$f, `sqrt$f, `hypot$f, `log$f, `exp$f —
は、引数から様々な指数-関数を算出する。
◎
The exponential functions—pow(), sqrt(), hypot(), log(), and exp()—compute various exponential functions with their arguments.
</p>

<p>
`pow(~vA, ~vB)@f
関数は、~comma区切りの 2 個の`計算式$ ~vA, ~vB を包含する。
両者とも `number$t に解決されなければナラナイ。
この関数は、 ~vA を ~vB 乗した結果の値を `number^t として返すモノトスル。
◎
The pow(A, B) function contains two comma-separated calculations A and B, both of which must resolve to &lt;number&gt;s, and returns the result of raising A to the power of B, returning the value as a &lt;number&gt;.
</p>

<p>
`sqrt(~vA)@f
関数は、 1 個の`計算式$ ~vA を包含する。
~vA は `number$t に解決されなければナラナイ。
この関数は、 ~vA の平方根を `number^t として返すモノトスル。
（ `sqrt(~vA)^v は、 `pow(~vA, .5)^v と基本的には等価だが，一部の~errorの取扱いは相違する。
`sqrt$f は、簡便さを供するに~~価するほど十分~共通的な関数である。）
◎
The sqrt(A) function contains a single calculation which must resolve to a &lt;number&gt;, and returns the square root of the value as a &lt;number&gt;. (sqrt(X) and pow(X, .5) are basically equivalent, differing only in some error-handling; sqrt() is a common enough function that it is provided as a convenience.)
</p>

<p>
`hypot(…)@f
関数は、~comma区切りの 1 個以上の`計算式$を包含する
— それは、各`計算式$に等しい成分を伴う多次元~vectorの長さを返す（すなわち、各~引数の二乗の総和の平方根）。
各~引数の`計算式$は［
`number$t,
`dimension$t,
`percentage$t
］のどれにも解決し得るが、`型を決定-$した結果は，すべて`同じ^emにならなければナラナイ
— さもなければ関数は無効になるとする。
結果の`型$は、引数と同じになる。
◎
The hypot(A, …) function contains one or more comma-separated calculations, and returns the length of an N-dimensional vector with components equal to each of the calculations. (That is, the square root of the sum of the squares of its arguments.) The argument calculations can resolve to any &lt;number&gt;, &lt;dimension&gt;, or &lt;percentage&gt;, but must have the same type, or else the function is invalid; the result will have the same type as the arguments.
</p>

<details class="note">
<summary>
`hypot$f は次元（単位を伴う値）を許容するのに、なぜ， `pow$f, `sqrt$f は実数に限り働くのか？
◎
Why does hypot() allow dimensions (values with units), but pow() and sqrt() only work on numbers?
</summary>

<p>
作者には、
`hypot(30px, 40px)^v の様な式を書くことは許容され， `50px^v に解決されるが、
`sqrt(pow(30px, 2) + pow(40px, 2))^v
の様な式を書くのは許容されない
— ほとんどの数学体系においては、この 2 つは等価であるにもかかわらず。
◎
You are allowed to write expressions like hypot(30px, 40px), which resolves to 50px, but you aren’t allowed to write the expression sqrt(pow(30px, 2) + pow(40px, 2)), despite the two being equivalent in most mathematical systems.
</p>

<p>
これには 2 つの理由
— 指数における数量-精度, 作者の期待に沿わないこと —
がある。
◎
There are two reasons for this: numeric precision in the exponents, and clashing expectations from authors.
</p>

<p>
まず、数量的な精度について。
`length$t の様な~CSS生成規則に`合致する$ためには、`型$は，その指数が正確に 1 に設定された単独の単位からなる必要がある。
`pow(pow(30px, 3), 1/3)^v
の様な式の結果は、理論上は，正確に次のように得られるべきである：
まず、~~内側の `pow(30px, 3)^v を［
`型$ «[ `length^l → 3 ]» （ `length^t の 3 乗）
］を伴う値 27000 に解決する。
次に、 `pow(~vA, 1/3)^v により，値の三乗根をとって 30 に戻すとともに指数に 1/3 を乗算する。
結果は、 «[ `length^l → 1 ]» を型に伴い， `length^t に`合致する$。
◎
First, numerical precision. For a type to match a CSS production like &lt;length&gt;, it needs to have a single unit with its exponent set to exactly 1. Theoretically, expressions like pow(pow(30px, 3), 1/3) should result in exactly that: the inner pow(30px, 3) would resolve to a value of 27000 with a type of «[ "length" → 3 ]» (aka &lt;length&gt;³), and then the pow(X, 1/3) would cube-root the value back down to 30 and multiply the exponent by 1/3, giving «[ "length" → 1 ]», which matches &lt;length&gt;.
</p>

<p>
上述は，純粋~数学においては仕事を成すことは保証されるが、二進-浮動小数点~算術を利用している~computerの現実世界においては，冪乗が正確に~~相殺されずに無効な`~math関数$になる事例もある
— それは、作者を惑わすことに加え，理由も追跡し難くなる。
（~JSの例で言えば、
`Math.pow(Math.pow(30, 10/3), .1+.1+.1)^c
を評価した結果は，正確には 30 にならない
— `.1+.1+.1^c が正確には 3 ~DIV 10 にならず、 `(10/3) * (.1+.1+.1)^c は 1 より`わずかに大きく^emなるので。）
◎
In the realm of pure mathematics, that’s guaranteed to work out; in the real-world of computers using binary floating-point arithmetic, in some cases the powers might not exactly cancel out, leaving you with an invalid math function for confusing, hard-to-track-down reasons. (For a JS example, evaluate Math.pow(Math.pow(30, 10/3), .1+.1+.1); the result is not exactly 30, because .1+.1+.1 is not exactly 3/10. Instead, (10/3) * (.1 + .1 + .1) is slightly greater than 1.)
</p>

<p>
［
値から単位を外した生の実数~上ですべての~mathを行ってから，最後に欲される単位に戻す
］よう作者に要求することは、不便にはなるが，数的な精度は誰にとっても~~支障ないことを確保する：
`calc(pow(pow(30px / 1px, 3), 1/3) * 1px)^v
は `length$t に解決され、 30 にごく近くなることは保証される
— 実際には、数量的な精度により冪乗を正確に~~相殺できず，正確には 30 ではなくとも。
◎
Requiring authors to cast their value down into a number, do all the math on the raw number, then finally send it back to the desired unit, while inconvenient, ensures that numerical precision won’t bite anyone: calc(pow(pow(30px / 1px, 3), 1/3) * 1px) is guaranteed to resolve to a &lt;length&gt;, with a value that, if not exactly 30, is at least very close to 30, even if numerical precision actually prevents the powers from exactly canceling.
</p>

<p>
次に，期待に沿わないことについて。
作者が［
`pow(30px, 2)^v の結果は
— 単位はそのままに数量的な値だけ二乗して —
`900px^v になる
］ものと期待することは，少なからずある（
<a href="https://github.com/sass/sass/issues/684">この Sass issue</a>
など）。
しかしながらこれは、［
結果が，引数をどの単位で表出しているかに依存する
］ことを意味する。
例えば `1em^v が `16px^v に等しい場合、
`pow(1em, 2)^v は `1em^v を与える一方で，
`pow(16px, 2)^v は `256px^v （ `16em^v ）を与える
— 入力~引数が一致するときに、このような かけ離れた値が得られるべきではない。
~CSSにおいては、一般に，値を`正準的~単位$に自由に~~換算することが許容されるので、この類の入力への依存性は，~CSSにとって厄介の元になる。
それは、 `pow(2em + 10px, 2)^v の様な，より複階的な式の解釈を困難にしてしまう。
◎
Second, clashing expectations. It’s not uncommon for authors to expect pow(30px, 2) to result in 900px (such as in this Sass issue); that is, just squaring the numerical value and leaving the unit alone. This, however, means the result is dependent on what unit you’re expressing the argument in; if 1em is 16px, then pow(1em, 2) would give 1em, while pow(16px, 2) would give 256px, or 16em, which are very different values for what should otherwise be identical input arguments! This sort of input dependency is troublesome for CSS, which generally allows values to be canonicalized freely; it also makes more complex expressions like pow(2em + 10px, 2) difficult to interpret.
</p>

<p>
戻って、値から単位を外してから，再び欲される単位に戻すよう作者に要求すれば、これらの課題から免れることになる。
`pow(30, 2)^v は `900^v になり、作者は自身が望む何にでも解釈できる。
◎
Again, requiring authors to cast their value down into a number and then back up again into the desired unit sidesteps these issues; pow(30, 2) is indeed 900, and the author can interpret that however they wish.
</p>

<hr>

<p>
他方， `hypot$f は、これらの問題には悩まされない
— 入力も出力もすべて同じ型であり，その演算の資質に因り，結果はいずれにせよ単位に依存しないので、単位における数量的な精度は懸念にならない。
`hypot(3em, 4em)^v,
`hypot(48px, 64px)^v
の両者とも、 `1em^v が `16px^v に等しいときの結果は，同じ長さ
`5em^v ~EQ `80px^v
になる。
したがって、作者が `hypot()^v 内に直に次元を利用できるようにしてもかまわない。
◎
On the other hand, hypot() doesn’t suffer from these problems. Numerical precision in units isn’t a concern, as the inputs and output all have the same type. The result isn’t unit-dependent, either, due to the nature of the operation; hypot(3em, 4em) and hypot(48px, 64px) both result in the same length when 1em equals 16px: 5em or 80px. Thus it’s fine to let author use dimensions directly in hypot().
</p>

</details>

<p>
`log(~vA, ~vB?)@f
関数は、［
対数~化される値を表現する`計算式$ ~vA,
対数の底eを表現する省略可能な`計算式$ ~vB （省略時の既定は `e$v とする）
］を包含する。
~vA, ~vB は `number$t に解決されなければナラナイ。
この関数は、
~vB を底eとする ~vA の対数を `number$t として返すモノトスル。
◎
The log(A, B?) function contains one or two calculations (representing the value to be logarithmed, and the base of the logarithm, defaulting to e), which must resolve to &lt;number&gt;s, and returns the logarithm base B of the value A, as a &lt;number&gt;.
</p>

<p>
`exp(~vA)@f
関数は、 1 個の`計算式$ ~vA を包含する。
~vA は `number$t に解決されなければナラナイ。
この関数は、 `pow(e, ~vA)$f と同じ値を `number$t として返すモノトスル。
◎
The exp(A) function contains one calculation which must resolve to a &lt;number&gt;, and returns the same value as pow(e, A) as a &lt;number&gt;.
</p>

<div class="example">

<p>
`pow$f 関数は、
<a href="https://www.modularscale.com/">CSS Modular Scale</a>
の様な，~page上のすべての~font~sizeを互いに固定比率で関係付ける方策に有用になり得る。
◎
The pow() function can be useful for strategies like CSS Modular Scale, which relates all the font-sizes on a page to each other by a fixed ratio.
</p>

<p>
これらの~sizeは、次の様に~custom~propの中にも容易に書ける：
◎
These sizes can be easily written into custom properties like:
</p>

<pre class="lang-css">
:root {
  --h6: calc(1rem * pow(1.5, -1));
  --h5: calc(1rem * pow(1.5, 0));
  --h4: calc(1rem * pow(1.5, 1));
  --h3: calc(1rem * pow(1.5, 2));
  --h2: calc(1rem * pow(1.5, 3));
  --h1: calc(1rem * pow(1.5, 4));
}
</pre>

<p>
値を `5.0625rem^v （ `calc(1rem * pow(1.5, 4))^v を解決した結果）の様な
— 何に基づくのか~~不明瞭な —
予め計算-済みの実数に書き出すことなく。
◎
...rather than writing out the values in pre-calculated numbers like 5.0625rem (what calc(1rem * pow(1.5, 4)) resolves to) which have less clear provenance when encountered in a stylesheet.
</p>

</div>

<div class="example">

<p>
1 個の引数を伴う `hypot$f は、入力の絶対~値を与える。
`hypot(2em)^v, `hypot(-2em)^v
は両者とも `2em^v に解決される。
◎
With a single argument, hypot() gives the absolute value of its input; hypot(2em) and hypot(-2em) both resolve to 2em.
</p>

<p>
複数個の引数を伴う場合、［
各辺の長さが各~引数により与えられた多次元~box
］の対頂線の~sizeを与える。
これは、変形-に関係するものに有用になり得る
— それは、特定0の (X, Y, Z ) 量だけ並進されたとき，要素が実際に~~移動する距離を与える。
◎
With more arguments, it gives the size of the main diagonal of a box whose side lengths are given by the arguments. This can be useful for transform-related things, giving the distance that an element will actually travel when it’s translated by a particular X, Y, and Z amount.
</p>

<p>
例えば， `hypot(30px, 40px)^v は、 `50px^v に解決され，［
`translate(30px, 40px)^v により要素が並進されたとき，要素が~~実際に~~移動する距離
］を与える。
作者は、元位置から離れるほど要素を小さくしたいと求めるなら（例えば，何らかの類の `word cloud^en 【単語の “重み”（出現頻度など）を可視化する図】を描くとき），この距離を拡縮ng係数の計算に利用することもできる。
◎
For example, hypot(30px, 40px) resolves to 50px, which is indeed the distance between an element’s starting and ending positions when it’s translated by a translate(30px, 40px) transform. If an author wanted elements to get smaller as they moved further away from their starting point (drawing some sort of word cloud, for example), they could then use this distance in their scaling factor calculations.
</p>
</div>

<div class="example">

<p>
引数を 1 個だけ伴う `log$f は、その引数の “自然~対数” を供する
— 対数の底eは ~JSと同じ `e^i になる。
◎
With a single argument, log() provides the “natural log” of its argument, or the log base e, same as JavaScript.
</p>

<p>
代わりに，［
10 を底eとする対数（例：値の 10 進表記における桁数） ／
2 を底eとする対数（例：値を成す~bit数）
］を求めるなら、［
`log(~vA, 10)^v ／
`log(~vA, 2)^v
］が，それを供する。
◎
If one instead wants log base 10 (to, for example, count the number of digits in a value) or log base 2 (counting the number of bits in a value), log(X, 10) or log(X, 2) provide those values.
</p>
</div>

			<section id="exponent-infinities">
<h4 title="Argument Ranges">11.5.1. 引数の範囲</h4>

<p>
`pow(~vA, ~vB)$f
においては、［
~vA, ~vB とも有限
］~AND［
~vA ~LT 0
］~AND［
~vB は整数でない
］ならば，結果は ~NaN になる。
◎
In pow(A, B), if A is negative and finite, and B is finite, B must be an integer, or else the result is NaN.
</p>

<p>
他の場合、
~vA, ~vB どちらかは［
±∞／ 0
］ならば，結果は次の 2 つの表で与えられる：
◎
If A or B are infinite or 0, the following tables give the results:
</p>

<div>
<table class="math-matrix">
<caption>
上端見出しは ~vA,
左端見出しは ~vB
の値を表す。
</caption>
<thead>
<tr><td>
<th>−∞
<th>~0N
<th>~0P
<th>+∞
</thead><tbody>

<tr><th>奇数（負）
<td>~0N
<td>−∞
<td>+∞
<td>~0P

<tr><th>偶数（負）
<td>~0P
<td>+∞
<td>+∞
<td>~0P

<tr><th>0
<td colspan="4">常に 1

<tr><th>奇数（正）
<td>−∞
<td>~0N
<td>~0P
<td>+∞

<tr><th>偶数（正）
<td>+∞
<td>~0P
<td>~0P
<td>+∞
</tbody></table>

◎
 ｜A is −∞｜A is 0⁻｜A is 0⁺｜A is +∞
B is −finite｜0⁻ if B is an odd integer, 0⁺ otherwise｜−∞ if B is an odd integer, +∞ otherwise｜+∞｜0⁺
B is 0｜always 1
B is +finite｜−∞ if B is an odd integer, +∞ otherwise｜0⁻ if B is an odd integer, 0⁺ otherwise｜0⁺｜+∞
</div>

<div>
<table class="math-matrix">
<caption>
上端見出しは ~vA,
左端見出しは ~vB
の値を表す。
</caption>
<thead>

<tr><td>
<th>~vA ~LT −1
<th>−1
<th>−1 ~LT ~vA ~LT 1
<th>1
<th>1 ~LT ~vA
</thead>

<tbody>

<tr><th>+∞
<td>+∞
<td>NaN
<td>~0P
<td>NaN
<td>+∞

<tr><th>−∞
<td>~0P
<td>NaN
<td>+∞
<td>NaN
<td>~0P
</tbody></table>

◎
 ｜A is &lt; -1｜A is -1｜-1 &lt; A &lt; 1｜A is 1｜A is &gt; 1
B is +∞｜result is +∞｜result is NaN｜result is 0⁺｜result is NaN｜result is +∞
B is −∞｜result is 0⁺｜result is NaN｜result is +∞｜result is NaN｜result is 0⁺ 
</div>

<p>
`sqrt(~vA)$f においては
⇒＃
~vA ~EQ +∞ ならば，結果は +∞ になる／
~vA ~EQ ~0N ならば，結果は ~0N になる／
~vA ~LT 0 ならば，結果は ~NaN になる
◎
In sqrt(A), if A is +∞, the result is +∞. If A is 0⁻, the result is 0⁻. If A is less than 0, the result is NaN.
</p>

<p>
`hypot(…)$f においては
⇒
入力のいずれかがが ±∞ ならば，結果は +∞ になる
◎
In hypot(A, …), if any of the inputs are infinite, the result is +∞.
</p>

<p>
`log(~vA, ~vB)$f
においては：
◎
In log(A, B),＼
</p>

<ul>
	<li>
<p>
［
~vB ~EQ 1 ／
~vB ~LT 0
］ならば，結果は ~NaN になる。
</p>

<p class="note">注記：
［
0 ~LT ~vB ~LT 1 ／
~vB ~GT 1
］であっても妥当である。
【当然？ ／ ~vB ~EQ +∞ の場合の結果は？】
</p>
◎
if B is 1 or negative,
＜B values between 0 and 1, or greater than 1, are valid.＞
the result is NaN.＼
</li>
	<li>
他の場合
⇒＃
~vA ~LT 0 ならば，結果は ~NaN になる／
~vA ~IN { ~0P, ~0N } ならば，結果は −∞ になる／
~vA ~EQ 1 ならば，結果は ~0P になる／
~vA ~EQ +∞ ならば，結果は +∞ になる
◎
If A is negative, the result is NaN. If A is 0⁺ or 0⁻, the result is −∞. If A is 1, the result is 0⁺. If A is +∞, the result is +∞.
</li>
</ul>

<p>
`exp(~vA)$f
においては
⇒＃
~vA ~EQ +∞ ならば，結果は +∞ になる／
~vA ~EQ −∞ ならば，結果は ~0P になる
◎
In exp(A), if A is +∞, the result is +∞. If A is −∞, the result is 0⁺.
</p>

<p>
（`~math関数$が ~NaN, ±∞ 【, ~0N, ~0P】をどう取扱うかの詳細は、`§ 型の検査-法$を見よ。）
◎
(See § 11.9 Type Checking for details on how math functions handle NaN and infinities.)
</p>

<div class="note">
<p>注記：
これらの関数の挙動はすべて、ほとんどの~programming言語
— 特に~JS —
に実装されている “標準な” 定義に合致することが意図されている。
◎
All of these behaviors are intended to match the "standard" definitions of these functions as implemented by most programming languages, in particular as implemented in JS.
</p>

<p>
等価な~JS関数の挙動からの唯一の乖離は、
~NaN は `どの関数^emにおいても “伝染的” である
— すなわち，ある引数~計算の結果が ~NaN になる場合、関数は ~NaN を返すよう強制する —
ことにある。
◎
The only divergences from the behavior of the equivalent JS functions are that NaN is "infectious" in every function, forcing the function to return NaN if any argument calculation is NaN.
</p>

<details>
<summary>
~JSの挙動の詳細
◎
Details of the JS Behavior
</summary>

<p>
~math関数に対応する~JS関数において、 ~NaN が “伝染的” にならない事例は 2 つある
⇒＃
`Math.hypot(Infinity, NaN)^c は `Infinity^jv を返す／
`Math.pow(NaN, 0)^c は `1^jv を返す
◎
There are two cases in JS where a NaN is not "infectious" to the math function it finds itself in:
• Math.hypot(Infinity, NaN) will return Infinity.
• Math.pow(NaN, 0) will return 1.
</p>

<p>
ここでの~logicは、
`NaN^jv を `どの数に置換しようが^em，返り値は同じになる点にあると見受けられる。
しかしながら，この~logicは、各種 `Math^c 関数に一貫して適用されてもいない：
`Math.max(Infinity, NaN)^c は， `Infinity^jv ではなく `NaN^jv を返すし、
`Math.min(-Infinity, NaN)^c も，同様になる。
◎
The logic appears to be that, if you replace the NaN with any Number, the return value will be the same. However, this logic is not applied consistently to the Math functions: Math.max(Infinity, NaN) returns NaN, not Infinity; the same is true of Math.min(-Infinity, NaN).
</p>

<p>
［
これは、~~常用されない~error事例であること／
~JSは、この点について一貫でないこと／
`計算式$における ~NaN の認識や取扱いは、内部~math関数~内ではなく，どのみち より高~levelな~CSSにて行われると見込まれる
］ことから、~CSSにおける一貫性が，より重要であると選ばれた。
なので、すべての関数において， ~NaN は “伝染的” になるよう定義されている。
◎
Because this is an error corner case, JS isn’t consistent on the matter, and NaN recognition/handling of calculations is likely done at a higher CSS level rather than in the internal math functions anyway, consistency in CSS was chosen to be more important, so all functions were defined to have "infectious" NaN.
</p>
</details>
</div>

			</section>
		</section>
		<section id="sign-funcs">
<h3 title="Sign-Related Functions: abs(), sign()">11.6. 符号nに関係する関数： `abs^f, `sign^f</h3>

<p>
符号nに関係する関数
— `abs$f, `sign$f —
は、引数の符号nに関係する関数を算出する。
◎
The sign-related functions—abs() and sign()—compute various functions related to the sign of their argument.
</p>

<p>
`abs(~vA)@f
関数は、 1 個の`計算式$ ~vA を包含し，
~vA の絶対~値を ~vA と同じ`型$の値として返す
— 結果の数量-値は、 ~vA の数量-値に応じて
⇒＃
~0P または正ならば そのまま ~vA になる／
~0N または負ならば −1 ~MUL ~vA になる
◎
The abs(A) function contains one calculation A, and returns the absolute value of A, as the same type as the input: if A’s numeric value is positive or 0⁺, just A again; otherwise -1 * A.
</p>

<p>
`sign(~vA)@f
関数は、 1 個の`計算式$ ~vA を包含し，
~vA の数量-値に応じて次を返す
⇒＃
負ならば −1 ／
正ならば +1 ／
~0P ならば ~0P ／
~0N ならば ~0N
◎
The sign(A) function contains one calculation A, and returns -1 if A’s numeric value is negative, +1 if A’s numeric value is positive, 0⁺ if A’s numeric value is 0⁺, and 0⁻ if A’s numeric value is 0⁻.
</p>


<p class="note">注記：
両~関数とも、引数を全部的に単純~化して解決した結果に対し演算する。
それは、一目では直感的でない結果も与え得る。
特に， `10%^v の様な式を解決した結果は、式がどの値を~~基準に解決されるかに依存して，`正にも負にも^emなり得る。
例えば， `background-position$p においては、背景~画像が背景~区画より大きい場合には，正な百分率は負な長さに（逆に，負な百分率は正な長さに）解決される。
したがって `sign(10%)$f は、百分率がどう解決されるかに依存して，
`1^v, `-1^v 
`どちらも返し得る^em（長さ 0 を~~基準に解決される場合には， `0^v にもなる）。
◎
Note: Both of these functions operate on the fully simplified/resolved form of their arguments, which may give unintuitive results at first glance. In particular, an expression like 10% might be positive or negative once it’s resolved, depending on what value it’s resolved against. For example, in background-position positive percentages resolve to a negative length, and vice versa, if the background image is larger than the background area. Thus sign(10%) might return 1 or -1, depending on how the percentage is resolved! (Or even 0, if it’s resolved against a zero length.)
</p>

		</section>
		<section id="calc-constants">
<h3 title="Numeric Constants: e, pi">11.7. 数量-定数： `e^v, `pi^v</h3>

<p>
［
三角-関数／指数-関数
］は，多くの複階的な数量-演算を取扱うが、計算式を適度にまとめる手間を要することに加え，
`e^i や `π^i などの周知な定数を含むことも多い。
◎
While the trigonometric and exponential functions handle many complex numeric operations, some reasonable calculations must be put together more manually, and many times these include well-known constants, such as e and π.
</p>

<p>
作者が これらの定数を成す一連の数字を手で打ち込まずに済むよう、少数の定数は直に供される：
◎
Rather than require authors to manually type out several digits of these constants, a few of them are provided directly:
</p>

<dl class="val-def">
	<dt>`e@v</dt>
	<dd>
自然~対数の底eを表す。
約 2.7182818284590452354 。
◎
e is the base of the natural logarithm, approximately equal to 2.7182818284590452354.
</dd>

	<dt>`pi@v</dt>
	<dd>
円周率を表す。
約 3.1415926535897932 。
◎
pi is the ratio of a circle’s circumference to its diameter, approximately equal to 3.1415926535897932.
</dd>
</dl>

<p class="note">注記：
これらの~keywordが利用-可能になるのは、
`calc(pow(e, pi) - pi)^v や `min(pi, 5, e)^v
など，`計算式$の中に限られる。
計算式の外側で利用された場合、他の~keywordと同様に扱われる：
<samp class="css">`animation-name$p: `pi^v</samp>
は、名前 `pi^l の~animationを指す。
<samp class="css">`line-height$p: `e^v</samp>
は、無効になる（
<samp class="css">`line-height^p: `2.7^v</samp>
に類似な何かにはならない【！？, but line-height: calc(e); is】）。
◎
Note: These keywords are only usable within a calculation, such as calc(pow(e, pi) - pi), or min(pi, 5, e). If used outside of a calculation, they’re treated like any other keyword: animation-name: pi; refers to an animation named "pi"; line-height: e; is invalid (not similar to line-height: 2.7, but line-height: calc(e); is).
</p>

			<section id="calc-error-constants">
<h4 title="Degenerate Numeric Constants: infinity, -infinity, NaN">11.7.1. 退化な値を表す数量-定数： `infinity^v, `-infinity^v, `NaN^v</h4>

<p>
`計算式$や その下位treeが［
無限／~NaN
］になるとき，もはや数量-値で表現することはアリでなくなる。
これらの退化な値の直列化を援助するため、追加的な~math定数として，次が定義される
⇒＃
`infinity@v （ +∞ を表す）,
`-infinity@v （ −∞ を表す）,
`NaN@v （ ~NaN を表す）
◎
When a calculation or a subtree of a calculation becomes infinite or NaN, representing it with a numeric value is no longer possible. To aid in serialization of these degenerate values, the additional math constants infinity (with the value +∞), -infinity (with the value −∞), and NaN (with the value NaN) are defined.
</p>

<p>
これらは、通例の~CSS~keywordと同じく，`~ASCII大小無視$である。
<span class="note">
したがって， `calc(InFiNiTy)^v も まったく妥当である。
</span>
しかしながら， `NaN$v は、この正準的な大小法で直列化するモノトスル。
◎
As usual for CSS keywords, these are ASCII case-insensitive. Thus, calc(InFiNiTy) is perfectly valid. However, NaN must be serialized with this canonical casing.
</p>

<p class="note">注記：
これらの~keywordは、`形上では^em実数ではないが，
`e$v や `pi$v と類似に数量-値として動作する。
したがって，無限な長さを取得するためには、
`calc(infinity * 1px)^v の様な式が要求される。
◎
Note: While not technically numbers, these keywords act as numeric values, similar to e and pi. Thus to get an infinite length, for example, requires an expression like calc(infinity * 1px).
</p>

<p class="note">注記：
これらの定数は、`主として^em［
無限／~NaN
］値の直列化をもっと単純かつ明らかにするために定義されているが、
“アリな最も大きい値”
を指示するためにも`利用できる^em
— 無限~値は、許容される範囲に切詰められることになるので。
これが~~適するのは希であるが、
`infinity$v を利用すれば，~stylesheetに何桁もの数をただ記すより意図は明瞭になる。
◎
Note: These constants are defined mostly to make serialization of infinite/NaN values simpler and more obvious, but can be used to indicate a "largest possible value", since an infinite value gets clamped to the allowed range. It’s rare for this to be reasonable, but when it is, using infinity is clearer in its intent than just putting an enormous number in one’s stylesheet.
</p>

			</section>
		</section>
		<section id="calc-syntax">
<h3 title="Syntax">11.8. 構文</h3>

<p>
`~math関数$の構文は、次で与えられる：
◎
The syntax of a math function is:
</p>

<pre class="prod">
`calc()$t
    = calc( `calc-sum$t )
`min()$t
    = min( `calc-sum$t# )
`max()$t
    = max( `calc-sum$t# )
`clamp()$t
    = clamp( `calc-sum$t#{3} )
`round()$t
    = round( `rounding-strategy$t?, `calc-sum$t, `calc-sum$t )
`mod()$t
    = mod( `calc-sum$t, `calc-sum$t )
`rem()$t
    = rem( `calc-sum$t, `calc-sum$t )
`sin()$t
    = sin( `calc-sum$t )
`cos()$t
    = cos( `calc-sum$t )
`tan()$t
    = tan( `calc-sum$t )
`asin()$t
    = asin( `calc-sum$t )
`acos()$t
    = acos( `calc-sum$t )
`atan()$t
    = atan( `calc-sum$t )
`atan2()$t
    = atan2( `calc-sum$t, `calc-sum$t )
`pow()$t
    = pow( `calc-sum$t, `calc-sum$t )
`sqrt()$t
    = sqrt( `calc-sum$t )
`hypot()$t
    = hypot( `calc-sum$t# )
`log()$t
    = log( `calc-sum$t, `calc-sum$t? )
`exp()$t
    = exp( `calc-sum$t )
`abs()$t
    = abs( `calc-sum$t )
`sign()$t
    = sign( `calc-sum$t )
`calc-sum@t
    = `calc-product$t [ [ '+' | '-' ] `calc-product$t ]*
`calc-product@t
    = `calc-value$t [ [ '*' | '/' ] `calc-value$t ]*
`calc-value@t
    = `number$t
    | `dimension$t
    | `percentage$t
    | `calc-constant$t
    | ( `calc-sum$t )
`calc-constant@t
    = `e$v | `pi$v | `infinity$v | `-infinity$v | `NaN$v
</pre>

<p>
加えて、演算子［
`+^css ／ `-^css
］の両側には`空白$が要求される（演算子［
`*^css ／ `/^css
］の両側には要求されない）。
◎
In addition, whitespace is required on both sides of the + and - operators. (The * and / operators can be used without white space around them.)
</p>

<p class="trans-note">【
例えば `5 -5^v は、
2 個の実数~token並びとして構文解析され，引数として妥当でなくなる。
一方で `5*5^v は、
`*^css も含む 3 個の~token並びとして構文解析され，引数として妥当になる。
】</p>

<p>
上に挙げた~math関数のうちいくつかには、
`calc-sum$t 引数が包含し得るものに追加的な拘束がある。
詳細は、個々の関数の定義を見よ。
◎
Several of the math functions above have additional constraints on what their &lt;calc-sum&gt; arguments can contain. Check the definitions of the individual functions for details.
</p>

<p>
~UAは、`計算式$を成す `calc-value$t の項~数として，少なくとも 20 個~以上は~supportするモノトスル。
包含する項~数が~supportする数を超える計算式は、無効であったかのように扱うモノトスル。
◎
UAs must support calculations of at least 20 &lt;calc-value&gt; terms. If a calculation contains more than the supported number of terms, it must be treated as if it were invalid.
</p>

		</section>
		<section id="calc-type-checking">
<h3 title="Type Checking">11.9. 型の検査-法</h3>

<p>
`~math関数$にアリな型
— `length$t, `number$t, 等々 —
には、それが包含する`計算式$に依存して，下に定義されるように いくつもある。
~math関数は、その型の値が許容される どこでも利用できる。
◎
A math function can be many possible types, such as &lt;length&gt;, &lt;number&gt;, etc., depending on the calculations it contains, as defined below. It can be used anywhere a value of that type is allowed.
</p>

<p class="example">
例えば， `width$p ~propは `length$t 値を受容するので、 `length$t に解決される`~math関数$
— `calc(5px + 1em)^v など —
は， `width^p に利用できる。
◎
For example, the width property accepts &lt;length&gt; values, so a math function that resolves to a &lt;length&gt;, such as calc(5px + 1em), can be used in width.
</p>

<p>
加えて， `number$t に解決される`~math関数$は、 `integer$t のみを受容する どこでも利用できる（それは、<a href="#calc-range">最も近い整数に丸められる</a>）。
◎
Additionally, math functions that resolve to &lt;number&gt; can be used in any place that only accepts &lt;integer&gt;. (It gets rounded to the nearest integer, as specified in § 11.12 Range Checking.)
</p>

<p>
演算子をとる下位式からは、その引数に基づいて型が得られる。
◎
Operators form sub-expressions, which gain types based on their arguments.
</p>

<p class="note">注記：
この仕様の以前までの~versionでは、［
乗算／除算
］がとれる引数は制限されていた
— 複階的な中間~結果（ `1px * 1em^v の次元は `length$t の 2 乗になるなど）が生産されるのを避けるため ／
0 による除算を構文解析-時に検出-可能にするため。
この~versionでは、その制約は緩められる。
◎
Note: In previous versions of this specification, multiplication and division were limited in what arguments they could take, to avoid producing more complex intermediate results (such as 1px * 1em, which is &lt;length&gt;²) and to make division-by-zero detectable at parse time. This version now relaxes those restrictions.
</p>

<div class="algorithm">

<p>
`計算式$の
`型を決定する@
ときは、以下に従う
— 以下において，`型$を得る演算の結果が `失敗^i になった場合、`計算式$の型は `失敗^i になるとする：
◎
To determine the type of a calculation:
</p>

<ul>
	<li>
［
`+^css ／ `-^css
］が成す下位式の`型$は、次の結果で与えられる
⇒
`型を加算する$( 左側の引数の`型$, 右側の引数の`型$ )
◎
At a + or - sub-expression, attempt to add the types of the left and right arguments. If this returns failure, the entire calculation’s type is failure. Otherwise, the sub-expression’s type is the returned type.
</li>
	<li>
`*^css が成す下位式の`型$は、次の結果で与えられる
⇒
`型を乗算する$( 左側の引数の`型$, 右側の引数の`型$ )
◎
At a * sub-expression, multiply the types of the left and right arguments. The sub-expression’s type is the returned result.
</li>
	<li>
`/^css が成す下位式の`型$は、次の結果で与えられる
⇒
`型を乗算する$( 左側の引数の`型$, `型を逆数にする$( 右側の引数の`型$ ) )
◎
At a / sub-expression, let left type be the result of finding the types of its left argument, and right type be the result of finding the types of its right argument and then inverting it.
◎
The sub-expression’s type is the result of multiplying the left type and right type.
</li>
	<li>
<p>
他のものは末端~値であり，その`型$は、次の手続きにより決定される：
</p>
		<ol>
			<li>
%単位 ~LET %値 に応じて
⇒＃
`percentage$t ならば `percent^l ／
`number$t ならば `number^l ／
`calc-constant$t ならば `number^l ／
~ELSE_（ `dimension$t ならば） %値 の単位
</li>
			<li>
~IF［
%単位 ~EQ `percent^l
］~AND［
%値 は［
この`計算式$を包含している`~math関数$が置かれた文脈において，［
`number$t 以外の別の型の値
］に相対的に解決される（例えば `width$p における `percentage$t は、ある `length$t に対し解決される）
］
⇒
%単位 ~SET その型の単位
</li>
			<li>
~RET `型を作成する$( %単位 )
</li>
		</ol>
◎
Anything else is a terminal value, whose type is determined based on its CSS type:
◎
&lt;number&gt;
&lt;integer&gt;
• the type is «[ ]» (empty map)
&lt;length&gt;
• the type is «[ "length" → 1 ]»
&lt;angle&gt;
• the type is «[ "angle" → 1 ]»
&lt;time&gt;
• the type is «[ "time" → 1 ]»
&lt;frequency&gt;
• the type is «[ "frequency" → 1 ]»
&lt;resolution&gt;
• the type is «[ "resolution" → 1 ]»
&lt;flex&gt;
• the type is «[ "flex" → 1 ]»
&lt;calc-constant&gt;
• the type is «[ ]» (empty map)
&lt;percentage&gt;
• If, in the context in which the math function containing this calculation is placed, &lt;percentage&gt;s are resolved relative to another type of value (such as in width, where &lt;percentage&gt; is resolved against a &lt;length&gt;), and that other type is not &lt;number&gt;, the type is determined as the other type.
• Otherwise, the type is «[ "percent" → 1 ]».
anything else
• The calculation’s type is failure.
◎
In all cases, the associated percent hint is null.
</li>
</ul>

</div>

<div class="algorithm">
<p>
`~math関数$自身も、関数に応じて，それが包含する`計算式$に則って決定される`型$を持つ：
◎
Math functions themselves have types, according to their contained calculations:
</p>

<dl class="switch">
	<dt>`calc$f</dt>
	<dt>`abs$f</dt>
	<dd>
包含する`計算式$の`型を決定-$した結果
◎
The type of a calc() or abs() expression is the type of its contained calculation.
</dd>

	<dt>`min$f</dt>
	<dt>`max$f</dt>
	<dt>`clamp$f</dt>
	<dd>
`型を加算する$( 包含している~comma区切りの各`計算式$からなる~list )
◎
The type of a min(), max(), or clamp() expression is the result of adding the types of its comma-separated calculations.
</dd>

	<dt>`sign$f</dt>
	<dd>
`型を作成する$( `number^l )
◎
The type of a sign() expression is «[ "number" → 1 ]».
</dd>

	<dt>`sin$f</dt>
	<dt>`cos$f</dt>
	<dt>`tan$f</dt>
	<dd>
`型を作成する$( `number^l )
◎
The type of a sin(), cos(), or tan() expression is «[ "number" → 1 ]».
</dd>

	<dt>`asin$f</dt>
	<dt>`acos$f</dt>
	<dt>`atan$f</dt>
	<dt>`atan2$f</dt>
	<dd>
`型を作成する$( `angle^l )
◎
The type of an asin(), acos(), atan(), or atan2() expression is «[ "angle" → 1 ]».
</dd>

	<dt>`pow$f</dt>
	<dt>`sqrt$f</dt>
	<dt>`log$f</dt>
	<dt>`exp$f</dt>
	<dd>
`型を作成する$( `number^l )
◎
The type of a pow(), sqrt(), log(), or exp() expression is «[ "number" → 1 ]».
</dd>

	<dt>`hypot$f</dt>
	<dt>`round$f</dt>
	<dt>`mod$f</dt>
	<dt>`rem$f</dt>
	<dd>
`型を加算する$( 包含している~comma区切りの各`計算式$からなる~list )
◎
The type of a hypot(), round(), mod(), or rem() expression is the result of adding the types of its comma-separated calculations.
</dd>
</dl>

<p>
上の各~項において、結果の`型$が失敗になる場合，`~math関数$は無効になるとする。
◎
For each of the above, if the type is failure, the math function is invalid.
</p>

</div>

<p>
`~math関数$は、その`型$が［
`number$t ／ `length$t ／ `angle$t ／ `time$t ／ `frequency$t ／ `resolution$t ／ `flex$t ／ `percentage$t
］のうち，どの生成規則に`合致する$かに則って，合致したものが表す型に解決される（この分類は相互排他的である）。
どれにも合致しない場合、`~math関数$は無効になる。
◎
A math function resolves to &lt;number&gt;, &lt;length&gt;, &lt;angle&gt;, &lt;time&gt;, &lt;frequency&gt;, &lt;resolution&gt;, &lt;flex&gt;, or &lt;percentage&gt; according to which of those productions its type matches. (These categories are mutually exclusive.) If it can’t match any of these, the math function is invalid.
</p>

<p>
0 による除算もアリであり、ある種の複雑さを導入する。
`~math関数$は、そのような演算に対しては，~IEEE-754意味論に従う：
◎
Division by zero is possible, which introduces certain complications. Math functions follow IEEE-754 semantics for these operations:
</p>

<ul>
	<li>
［
正な値 ／ 負な値
］を 0 で除算するときは、［
+∞ ／ −∞
］を生産する。
【この 0 が “負な 0” （ ~0N ）の場合は逆になる（下を見よ）。】
◎
Dividing a positive value by zero produces +∞.
◎
Dividing a negative value by zero produces −∞.
</li>
	<li>
次に挙げる演算は、後続する規則にて ~NaN を生産するものと定義されない限り，引数に与える ±∞ と同じ符号の ±∞ を生産する
⇒＃
何かと ±∞ を乗算するとき ／
何かと ±∞ を加算するとき ／
±∞ から何かを減算するとき ／
何かから −( ±∞ ) を減算するとき
◎
Adding or subtracting ±∞ to anything produces the appropriate infinity, unless a following rule would define it as producing NaN.
◎
Multiplying any value by ±∞ produces the appropriate infinity, unless a following rule would define it as producing NaN.
</li>
	<li>
何かを ±∞ で除算するときは、後続する規則にて ~NaN を生産するものと定義されない限り，
0 を生産する。
◎
Dividing any value by ±∞ produces zero, unless a following rule would define it as producing NaN.
</li>
	<li>
次に挙げる演算は、 ~NaN を生産する
⇒＃
0 を 0 で除算するとき ／
±∞ を ±∞ で除算するとき ／
0 と ±∞ を乗算するとき ／
+∞ と −∞ を加算するとき ／
±∞ から同じ符号の ±∞ を減算するとき
◎
Dividing zero by zero, dividing ±∞ by ±∞, multiplying 0 by ±∞, adding +∞ to −∞ (or the equivalent subtractions) produces NaN.
</li>
	<li>
どの演算も、ある引数が ~NaN ならば ~NaN を生産する。
◎
Any operation with at least one NaN argument produces NaN.
</li>
</ul>

<p>
加えて，~IEEE-754は、 “負な 0” の概念を導入する
— それも、［
計算の中／入子にされた計算の間
］で追跡されるモノトスル（以下、［
負な 0 は ~0N ／ 他の 0（ “正な 0” ）は ~0P
］と記され， 0 はこれらの総称を表す）：
◎
Additionally, IEEE-754 introduces the concept of "negative zero", which must be tracked within a calculation and between nested calculations:
</p>

<ul>
	<li>
<p>
0 を生産する［ 乗算／除算 ］のうち，片方の引数だけ負であるもの（例： `-5 * 0^v や `1 / (-infinity)^v ）は、 ~0N を生産する。
加えて、他の`~math関数$における，ある種の引数の組合nも ~0N を生産する。
◎
Negative zero (0⁻) can be produced by a multiplication or division that produces zero with exactly one negative argument (such as -5 * 0 or 1 / (-infinity)), or by certain argument combinations in the other math functions.
</p>

<p class="note">注記：
負な 0 は`~math関数$から外へは~~漏れないことに注意。
下に詳細を与えるように、負な 0 は “無符号” 0 に “~~同化される” ことになる。
◎
Note: Note that negative zeros don’t escape a math function; as detailed below, they’re "censored" away into an "unsigned" zero.
</p>
	</li>
	<li>
<p>
次に挙げる演算は、 ~0N を生産する
⇒＃
~0N と ~0N を加算するとき ／
~0N から ~0P を減算するとき
</p>

<p>
0 を生産するような他のすべての加算／減算は、 ~0P を生産する。
</p>
◎
0⁻ + 0⁻ or 0⁻ - 0 produces 0⁻. All other additions or subtractions that would produce a zero produce 0⁺.
</li>
	<li>
<p>
次に挙げる演算は、 ~0N を生産する
⇒＃
~0N と ~0P を乗算するとき ／
~0N と正な値を乗算するとき ／
~0N を正な値で除算するとき
</p>

<p>
次に挙げる演算は、 ~0P を生産する
⇒＃
~0N と ~0N を乗算するとき ／
~0N と負な値を乗算するとき ／
~0N を負な値で除算するとき
</p>

<p>
［
正な値 ／ 負な値
］を ~0N で除算するときは、［
−∞ ／ +∞
］を生産する。
</p>

<p>
（言い換えれば、 ~0N を引数にとる［
乗算／除算
］は，標準な符号n規則に従う。）
</p>

◎
Multiplying or dividing 0⁻ with a positive number (including 0⁺) produces a negative result (either 0⁻ or −∞), while multiplying or dividing 0⁻ with a negative number produces a positive result.
(In other words, multiplying or dividing with 0⁻ follows standard sign rules.)
</li>
	<li>
~0P と ~0N を比較するときは、 ~0N ~LT ~0P になるとする。
例えば，［
`min(0, -0)^v ／ `max(0, -0)^v ／ `clamp(0, -0, 1)^v
【！`min(~0P, ~0N)^v ／ `max(~0P, ~0N)^v ／ `clamp(~0P, ~0N, 1)^v】
］は、［
~0N ／ ~0P ／ ~0P
］を生産するモノトスル。
◎
When comparing 0⁺ and 0⁻, 0⁻ is less than 0⁺. For example, min(0⁺, 0⁻) must produce 0⁻, max(0⁺, 0⁻) must produce 0⁺, and clamp(0⁺, 0⁻, 1) must produce 0⁺.
</li>
</ul>

<p>
別の`~math関数$の内側に入子にされてない`~math関数$は、
`~top-levelの計算式@
と総称される。
`~top-levelの計算式$が生産する値の数量-部が［
~NaN／ ~0N 
］になる場合、数量-部は［
+∞ ／ “無符号” 0
］になったかのように動作するとする。
◎
If a top-level calculation (a math function not nested inside of another math function) would produce a value whose numeric part is NaN, it instead act as though the numeric part is +∞. If a top-level calculation would produce a value whose numeric part is 0⁻, it instead acts as though the numeric part is the standard "unsigned" zero.
</p>

<div class="example">

<p>
例えば，
`calc(-5 * 0)^v
は ~0N に解決されるが、`~top-levelの計算式$としては 無符号 0 に~~同化される。
◎
For example, calc(-5 * 0) produces an unsigned zero—the calculation resolves to 0⁻, but as it’s a top-level calculation, it’s then censored to an unsigned zero.
</p>

<p>
他方，
`calc(1 / calc(-5 * 0))^v は、 `calc(1 / (-5 * 0))^v と同じく，
−∞ を生産する。
~~内側の `calc^f は、`~top-levelの計算式$ではないので， ~0N に解決される。
その結果は，そのまま~top-levelの `calc^f に渡され、 −∞ を生産することになる
— ~~仮に，そのままではなく無符号 0 に~~同化された場合、 +∞ を生産することになる。
◎
On the other hand, calc(1 / calc(-5 * 0)) produces −∞, same as calc(1 / (-5 * 0))—the inner calc resolves to 0⁻, and as it’s not a top-level calculation, it passes it up unchanged to the outer calc to produce −∞. If it was censored into an unsigned zero, it would instead produce +∞.
</p>

</div>

<p class="note">注記：
`~math関数$やそれが解決される型の妥当性は、代数的な単純~化により影響されることはない。
例えば，
`calc(5px - 5px + 10s)^v
や
`calc(0 * 5px + 10s)^v
は、いずれも長さと時間を加算しようと試みるので，無効になる。
◎
Note: Algebraic simplifications do not affect the validity of a math function or its resolved type. For example, calc(5px - 5px + 10s) and calc(0 * 5px + 10s) are both invalid due to the attempt to add a length and a time.
</p>

<p class="note">注記：
`number$t に相対的な `percentage$t 
— `opacity$p におけるそれなど —
は、 `number$t と組合できないことに注意。
これを許容すると，（ `dimension$t の乗算や除算を許容するための） “単位~代数” に有意な問題をもたらすので。
どの事例においても，それが新たな機能性を供することはない（例えば
<samp class="css">`opacity^p: `25%^v</samp>
は，
<samp class="css">`opacity^p: `.25^v</samp>
に一致する
— それは自明な構文~変形-に過ぎない）。
それでも、他の演算は遂行できる
— 例えば
<samp class="css">`opacity^p: `calc(100% / 3)^v;</samp>
は妥当になる。
◎
Note: Note that &lt;percentage&gt;s relative to &lt;number&gt;s, such as in opacity, are not combinable with those numbers—opacity: calc(.25 + 25%) is invalid. Allowing this causes significant problems with "unit algebra" (allowing multiplication/division of &lt;dimension&gt;s), and in every case so far, doesn’t provide any new functionality. (For example, opacity: 25% is identical to opacity: .25; it’s just a trivial syntax transform.) You can still perform other operations with them, such as opacity: calc(100% / 3);, which is valid.
</p>

<p class="note">注記：
`number-token$t は，常に `number$t, `integer$t のいずれかに解釈されるので、
`~math関数$内では `length$t を意図する単位なしの `0^v は~supportされない。
すなわち、
<samp class="css">width: `0^v;</samp>
や
<samp class="css">width: `5px^v;</samp>
は妥当であっても，
<samp class="css">width: `calc(0 + 5px)^v;</samp>
は妥当でない
— `number$t と `length$t を~~加算しようと~~試みるので。
◎
Note: Because &lt;number-token&gt;s are always interpreted as &lt;number&gt;s or &lt;integer&gt;s, "unitless 0" &lt;length&gt;s aren’t supported in math functions. That is, width: calc(0 + 5px); is invalid, because it’s trying to add a &lt;number&gt; to a &lt;length&gt;, even though both width: 0; and width: 5px; are valid.
</p>

<p class="note">注記：
~~素の `number$t が使用~値の時点で `length$t になるような~propも少数あるが（特定的には `line-height$p ／ `tab-size$p ）、
`number$t は， `calc$f 内では決して “長さの様なもの” にはならず、常に `number$t であり続ける。
◎
Note: Although there are a few properties in which a bare &lt;number&gt; becomes a &lt;length&gt; at used-value time (specifically, line-height and tab-size), &lt;number&gt;s never become "length-like" in calc(). They always stay as &lt;number&gt;s.
</p>

		</section>
		<section id="calc-internal">
<h3 title="Internal Representation">11.10. 内部~表現</h3>
<p>
`~math関数$の`内部~表現$は、
`計算式~tree@
になる
— この~treeを成す各~nodeのうち：
◎
The internal representation of a math function is a calculation tree: a tree where＼
</p>

<ul>
	<li>
<p>
枝分かれ~node（子を持つ~node）には、
`演算子~node@
と総称される，次のいずれかが対応する
⇒＃
`~math関数$（ `Min^i, `Cos^i, `Sqrt^i, 等々）／
`計算式$内の演算子（ `Sum^i, `Product^i, `Negate^i, `Invert^i †）
</p>

<p>
後者は
`~calc演算子~node@
と総称される。
【† これらの各 名前は、 `CSSMathValue$I の各種 下位classの名前に対応する。】
</p>
◎
the branch nodes are operator nodes corresponding either to math functions (such as Min, Cos, Sqrt, etc) or to operators in a calculation (Sum, Product, Negate, and Invert, the calc-operator nodes), and＼
</li>
	<li>
葉~node（子を持たない~node）には、次のいずれかが対応する
⇒＃
数量-値（実数, 次元, 百分率）／
`~math関数$でない ある数量-型に解決されるもの
◎
the leaf nodes are either numeric values (such as numbers, dimensions, and percentages) or non-math functions that resolve to a numeric type.
</li>
</ul>

<p>
`~math関数$は、次に与える`計算式~tree$に転換される：
◎
Math functions are turned into calculation trees depending on the function:
</p>

<ul class="switch">
	<li>
`calc$f 関数の`内部~表現$は、次の結果になる
⇒
`計算式を構文解析する$( その引数 )
◎
calc()
• The internal representation of a calc() function is the result of parsing a calculation from its argument.
</li>
	<li>
その他の`~math関数$の`内部~表現$は、当の関数と同じ名前の`演算子~node$になる
⇒
その各~子は、関数の各~引数が現れる順序で，［
各~引数に対する次の結果
］で与えられる
⇒
`計算式を構文解析する$( 引数 )
◎
any other math function
• The internal representation is an operator node with the same name as the function, whose children are the result of parsing a calculation from each of the function’s arguments, in the order they appear.
</li>
</ul>

<div class="algorithm">

<p>
`計算式を構文解析する@
ときは、所与の
( `計算式$を表現している`成分~値$の~list %値~list )
に対し，`計算式~tree$を返す：
◎
To parse a calculation, given a calculation values represented as a list of component values, and returning a calculation tree:
</p>
<ol>
	<li>
%値~list から `whitespace-token$t をすべて除去する
◎
Discard any &lt;whitespace-token&gt;s from values.
</li>
	<li>
<p>
この段の目的においては、
%値~list を成す各 %~item には、次に与える `演算子^i が結付けられる
⇒＃
%~item は `delim-token$t であって，その.値 ~IN { `+^l, `-^l, `*^l, `/^l } ならば それ ／
~ELSE_ ε
</p>

<p class="trans-note">【
この段では、各［［
`*^l ／ `/^l
］で区切って連結された成分たちが成す連なり
］を `Product^i ~nodeの中に収集する。
それに伴い、［
`-^l ／ `/^l
］が前置された各~成分は［
`Negate^i ／ `Invert^i
］~nodeの中に包装する。
】【
この段は、原文の記述にかなり手を加えている（より~algo的に~~厳密化／~~整理集約など）
】</p>
		<ol>
			<li>
~Assert：
%値~list は［
`演算子^i ~NEQ ε のものと, それ以外のもの
］が交互に並んでいて、最初, 最後の~itemの `演算子^i ~EQ ε
</li>
			<li>
%子~list ~LET 新たな~list
</li>
			<li>
%積~list ~LET 新たな~list
</li>
			<li>
%現在の演算子 ~LET ε
</li>
			<li>
<p>
%値~list を成す
~EACH( %~item )
に対し：
</p>
				<ol>
					<li>
<p>
~IF［
%~item の `演算子^i ~NEQ ε
］：
</p>
						<ol>
							<li>
%現在の演算子 ~SET %~item の `演算子^i
</li>
							<li>
~IF［
%現在の演算子 ~IN { `*^l ／ `/^l }
］~OR［
%積~list の~size ~EQ 0
］
⇒
~CONTINUE
</li>
						</ol>
					</li>
					<li>
<p>
~ELSE：
</p>
						<ol>
							<li>
~IF［
%現在の演算子 ~EQ `-^l
］
⇒
%~item ~SET %~item を子として包含している `Negate^i ~node
</li>
							<li>
~ELIF［
%現在の演算子 ~EQ `/^l
］
⇒
%~item ~SET %~item を子として包含している `Invert^i ~node
</li>
							<li>
%積~list に %~item を付加する
</li>
							<li>
~IF［
%~item は %値~list の最後の~itemでない
］
⇒
~CONTINUE
</li>
						</ol>
					</li>
					<li>
~IF［
%積~list の~size ~EQ 1
］
⇒
%子~list に %積~list[0] を付加する
</li>
					<li>
~ELSE
⇒
%子~list に［
%子~list を成す各~itemを子として持つ `Product^i ~node
］を付加する
</li>
					<li>
%積~list を空にする
</li>

				</ol>
			</li>
		</ol>
◎
An item in values is an “operator” if it’s a &lt;delim-token&gt; with the value "+", "-", "*", or "/". Otherwise, it’s a “value”.
◎
Collect children into Product and Invert nodes.
◎
For every consecutive run of value items in values separated by "*" or "/" operators:
• For each "/" operator in the run, replace its right-hand value item rhs with an Invert node containing rhs as its child.
• Replace the entire run with a Product node containing the value items of the run as its children.
◎
Collect children into Sum and Negate nodes.
• For each "-" operator item in values, replace its right-hand value item rhs with a Negate node containing rhs as its child.
</li>
	<li>
%根 ~LET %子~list を成す各~itemを子として持つ `Sum^i ~node
◎
↓</li>
	<li>
~IF［
%子~list は唯一の~itemからなる
］~AND［
その~itemは［
`Product^i ~node／`丸括弧~block$
］である
］
⇒
%根 ~SET その~item
◎
If values has only one item, and it is a Product node or a parenthesized simple block, replace values with that item.
◎
Otherwise, replace values with a Sum node containing the value items of values as its children.
</li>
	<li>
~Assert：
%根 を根とする~treeを成す~nodeのうち，子を持つ~nodeは［
`Sum^i ／
`Product^i／
`Negate^i／
`Invert^i
］~nodeであって，他の~node（葉~node）は そうでない。
◎
At this point values is a tree of Sum, Product, Negate, and Invert nodes, with other types of values at the leaf nodes. Process the leaf nodes.
</li>
	<li>
<p>
%根 を成す
~EACH( 子を持たない~node %葉 )
に対し：
◎
For every leaf node leaf in values:
</p>
		<ol>
			<li>
~IF［
%葉 は`丸括弧~block$である
］
⇒
%葉 を次の結果に置換する
⇒
`計算式を構文解析する$( %葉 の内容 )
◎
If leaf is a parenthesized simple block, replace leaf with the result of parsing a calculation from leaf’s contents.
</li>
			<li>
~IF［
%葉 は`~math関数$である
］
⇒
%葉 をその~math関数の`内部~表現$に置換する
◎
If leaf is a math function, replace leaf with the internal representation of that math function.
</li>
		</ol>
	</li>
	<li>
~RET `計算式~treeを単純~化する$( %根 )
◎
Return the result of simplifying a calculation tree from values.
</li>
</ol>

</div>

			<section id="calc-simplification">
<h4 title="Simplification">11.10.1. 単純~化</h4>

<p>
`~math関数$の`内部~表現$は、標準な代数的な単純~化を利用して，~~隅々までアリな限り単純~化される（乗算を総和に分配する, 単位が`互換$な値どうしを結合する, 等々）。
◎
Internal representations of math functions are eagerly simplified to the extent possible, using standard algebraic simplifications (distributing multiplication over sums, combining similar units, etc.).
</p>

<div class="algorithm">

<p>
`計算式~treeを単純~化する@
ときは、所与の
( %根 )
に対し：
◎
To simplify a calculation tree root:
</p>
<ol>
	<li>
<p>
~IF［
%根 は数量-値である
］：
◎
If root is a numeric value:
</p>
		<ol>
			<li>
~IF［
%根 は ある次元の %別の値 を~~基準に解決される百分率であって，それを解決するに十分な情報は可用である
］
⇒
~RET  %根 を その次元の`正準的~単位$において解決した結果の数量-値
◎
If root is a percentage that will be resolved against another value, and there is enough information available to resolve it, do so, and express the resulting numeric value in the appropriate canonical unit. Return the value.
</li>
			<li>
~IF［
%根 は ある次元の値であって，その単位は`正準的~単位$でない
］~AND［
%根 を正準的~単位の値に換算するに十分な情報は可用である
］
⇒
~RET %根 を正準的~単位に換算した結果
◎
If root is a dimension that is not expressed in its canonical unit, and there is enough information available to convert it to the canonical unit, do so, and return the value.
</li>
			<li>
~IF［
%根 は `calc-constant$t である
］
⇒
~RET %根 の数量-値
◎
If root is a &lt;calc-constant&gt;, return its numeric value.
</li>
			<li>
~RET %根
◎
Otherwise, return root.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%根 は他の葉~nodeである（演算子~nodeでない）
］：
◎
If root is any other leaf node (not an operator node):
</p>
		<ol>
			<li>
~IF［
%根 の数量-値を決定するに十分な情報は可用である
］
⇒
~RET 値を`正準的~単位$で表出した結果
◎
If there is enough information available to determine its numeric value, return its value, expressed in the value’s canonical unit.
</li>
			<li>
~RET %根
◎
Otherwise, return root.
</li>
		</ol>
	</li>
	<li>
~Assert：
この時点で， %根 は`演算子~node$である。
◎
At this point, root is an operator node.＼
</li>
	<li>
%根 を成す
~EACH( %子 )
を次の結果に置換する
⇒
`計算式~treeを単純~化する$( %子 )
◎
Simplify all the children of root.
</li>
	<li>
<p>
~IF［
%根 は`~calc演算子~node$でない
］：
◎
If root is an operator node that’s not one of the calc-operator nodes,＼
</p>
		<ol>
			<li>
~IF［
%根 の子は どれも数量-値であって，
%根 が表現する演算を算出するに十分な情報を伴う
］
⇒
~RET ［
%根 の子たちを利用して %根 の演算を走らせた結果
］を値にとり，結果の`正準的~単位$で表出される数量-値
◎
and all of its children are numeric values with enough information to computed the operation root represents, return the result of running root’s operation using its children, expressed in the result’s canonical unit.
</li>
			<li>
~RET %根 【この段はこの訳による補完】
</li>
		</ol>
	</li>
	<li>
<p>
%根 に応じて：
</p>
		<dl class="switch">
			<dt>
`Negate^i ~node
◎
If root is a Negate node:
</dt>
			<dd>
				<ol>
					<li>
~IF［
%根 の子は数量-値である
］
⇒
~RET 0 ~MINUS その値
（反数にした結果）
◎
If root’s child is a numeric value, return an equivalent numeric value, but with the value negated (0 - value).
</li>
					<li>
~IF［
%根 の子は `Negate^i ~nodeである
］
⇒
~RET %根 の子の子
◎
If root’s child is a Negate node, return the child’s child.
</li>
					<li>
~RET %根
◎
Return root.
</li>
				</ol>
			</dd>

			<dt>
`Invert^i ~node
◎
If root is an Invert node:
</dt>
			<dd>
				<ol>
					<li>
~IF［
%根 の子は実数である（百分率でも次元でもない）
］
⇒
~RET 1 ~DIV その値（すなわち逆数）
◎
If root’s child is a number (not a percentage or dimension) return the reciprocal of the child’s value.
</li>
					<li>
~IF［
%根 の子は `Invert^i ~nodeである
］
⇒
~RET %根 の子の子
◎
If root’s child is an Invert node, return the child’s child.
</li>
					<li>
~RET %根
◎
Return root.
</li>
				</ol>
			</dd>

			<dt>
`Sum^i ~node
◎
If root is a Sum node:
</dt>
			<dd>
				<ol>
					<li>
%根 の子のうち `Sum^i ~nodeである
~EACH( %子 )
を %子 の子たちに置換する
◎
For each of root’s children that are Sum nodes, replace them with their children.
</li>
					<li>
<p>
~EACH( %根 の数量-値である子のうち，互いの単位が一致するものたちが成す集合 )
に対し
⇒
その集合を成す子たちを［
それらの総和が成す単独の数量-値
］に置換する
◎
For each set of root’s children that are numeric values with identical units, remove those children and replace them with a single numeric value containing the sum of the removed nodes, and with the same unit.
</p>

<p>
（例：［
実数どうし／百分率どうし／`px^u 値どうし
］を結合する）
◎
(E.g. combine numbers, combine percentages, combine px values, etc.)
</p>
					</li>
					<li>
~RET ［
%根 の子は 1 個だけならば %根 の子 ／
~ELSE_ %根
］
◎
If root has only a single child at this point, return the child. Otherwise, return root.
</li>
				</ol>
			</dd>

			<dt>
`Product^i ~node
◎
If root is a Product node:
</dt>
			<dd>
				<ol>
					<li>
%根 の子のうち `Product^i ~nodeである
~EACH( %子 )
を %子 の子たちに置換する
◎
For each of root’s children that are Product nodes, replace them with their children.
</li>
					<li>
~IF［
%根 には実数である（百分率でも次元でもない）子~nodeが複数個ある
］
⇒
それらの~nodeを［
それらの積が成す単独の実数
］に置換する
◎
If root has multiple children that are numbers (not percentages or dimensions), remove them and replace them with a single number containing the product of the removed nodes.
</li>
					<li>
~IF［
%根 には子が 2 つだけある
］~AND［
一方の子は 実数 %N である（百分率でも次元でもない）
］~AND［
もう一方の子は `Sum^i ~node %S であって，その子たちは すべて数量-値である
］
⇒＃
%S の ~EACH( 子 ) に対し，その値に %N を乗算する；
~RET %S
◎
If root contains only two children, one of which is a number (not a percentage or dimension) and the other of which is a Sum whose children are all numeric values, multiply all of the Sum’s children by the number, then return the Sum.
</li>
					<li>
~IF［
%根 の子は どれも［
数量-値／数量-値を子とする `Invert^i ~node
］である
］
⇒
~IF［
`型を乗算する$( %根 のすべての子 )
の結果は 当の`~math関数$を解決できる型に`合致する$
（ `Invert^i ~nodeの型は `型を逆数にする$( その子の型 ) の結果になることに注意）
］
⇒
~RET ［
%根 のすべての子の値を乗算した結果
（ `Invert^i ~nodeの値は、その子の値の逆数であることに注意）
］を値にとり，結果の`正準的~単位$で表出される数量-値
◎
If root contains only numeric values and/or Invert nodes containing numeric values, and multiplying the types of all the children (noting that the type of an Invert node is the inverse of its child’s type) results in a type that matches any of the types that a math function can resolve to, return the result of multiplying all the values of the children (noting that the value of an Invert node is the reciprocal of its child’s value), expressed in the result’s canonical unit.
</li>
					<li>
~RET %根
◎
Return root.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>
</div>
			</section>
		</section>
		<section id="calc-computed-value">
<h3 title="Computed Value">11.11. 算出d値</h3>

<p>
`~math関数$の`算出d値$は、算出d値の時点で可用なすべての情報（
`em$u と `px$u の比率,
何らかの~propにおいて百分率を解決する方法,
等々）を利用する下で，その`計算式~treeを単純~化$した結果になる。
◎
The computed value of a math function is its calculation tree simplified, using all the information available at computed value time. (Such as the em to px ratio, how to resolve percentages in some properties, etc.)
</p>

<p>
算出d値の時点で解決されない百分率は、`~math関数$の中でも解決されない。
例えば，式 `calc(100% - 100% + 1px)^v は、
`1px^v ではなく， `calc(0% + 1px)^v に解決される。
百分率から算出d値を得るための特別な規則がある場合（例えば `height$p ~prop）、その規則が`~math関数$に含まれるどの百分率にも適用される。
◎
Where percentages are not resolved at computed-value time, they are not resolved in math functions, e.g. calc(100% - 100% + 1px) resolves to calc(0% + 1px), not to 1px. If there are special rules for computing percentages in a value (e.g. the height property), they apply whenever a math function contains percentages.
</p>

<p>
`計算式~tree$は、`使用~値$の時点でも，その時点の情報で再び単純~化される
— `~math関数$は常に，単独の数量-値に さらに単純~化される。
◎
The calculation tree is again simplified at used value time; with used value time information, a math function always simplifies down to a single numeric value.
</p>

<div class="example">

<p>
例えば， `font-size$p における百分率~値は、`~fontに相対的な長さ$ 単位を算出できるよう，`算出d値$の時点で解決される。
一方で， `background-position$p における百分率~値は、その挙動が~layoutに依存するため，使用~値の時点まで解決されない。
◎
For example, whereas font-size computes percentage values at computed value time so that font-relative length units can be computed, background-position has layout-dependent behavior for percentage values, and thus does not resolve percentages until used-value time.
</p>

<p>
このことに因り、
`background-position$p における算出では， `calc$f 内の百分率は保全される一方で、
`font-size$p では，そのような式は直に長さに算出される。
◎
Due to this, background-position computation preserves the percentage in a calc() whereas font-size will compute such expressions directly into a length.
</p>

</div>

<p>
~tableを成す［
~cellその他の要素
］の~size計算は複階的なので、~tableの［
~col, ~col~group, ~row, ~row~group, ~cell
］の~sizeに対する［
長さと百分率が混在な式
］については、~table~layoutが自動（ `auto^v ）か固定（ `fixed^v ）かに関わらず，
`~autoS$v が指定されていたかのように扱う`モノトスル^em。
◎
Given the complexities of width and height calculations on table cells and table elements, math expressions mixing both percentages and lengths for widths and heights on table columns, table column groups, table rows, table row groups, and table cells in both auto and fixed layout tables MUST be treated as if auto had been specified.
</p>

		</section>
		<section id="calc-range">
<h3 title="Range Checking">11.12. 範囲の検査-法</h3>

<p>
構文解析-時には、`~math関数$の中の値に対しては，範囲は検査されないので、値が範囲~外であっても宣言は無効にならない。
しかしながら、式による結果の値は，当の文脈に許容される範囲に切詰められるモノトスル。
この切詰ngは、`算出d値$に対しては，アリな所すべてで遂行され、算出において範囲を検査するに足るまで式を単純~化できなかった場合には，`使用~値$に対し遂行される。
（`指定d値$に対しては、切詰ngは遂行されない。）
◎
Parse-time range-checking of values is not performed within math functions, and therefore out-of-range values do not cause the declaration to become invalid. However, the value resulting from an expression must be clamped to the range allowed in the target context. Clamping is performed on computed values to the extent possible, and also on used values if computation was unable to sufficiently simplify the expression to allow range-checking. (Clamping is not performed on specified values.)
</p>

<p class="note">注記：
したがって、【！＊calc】`~math関数$を受容するすべての文脈において，許容される値の範囲は（開区間ではなく）閉区間として定義することが要求される。
◎
Note: This requires all contexts accepting calc() to define their allowable values as a closed (not open) interval.
</p>

<p class="note">注記：
±∞ は、［
どの~propに対しても、定義により，許容される範囲の外側にある
］ので，許容される［
最小／最大
］値に切詰められることになる。
`animation-iteration-count$p など，~keyword値として明示的に
`infinity$v 【実際には `infinte^v だが】
を許容する~propであっても、`~math関数$は，~prop構文の`数量-部分^emの［
最小／最大
］値に切詰められ，~keyword値には解決され得ない。
◎
Note: By definition, ±∞ are outside the allowed range for any property, and will clamp to the minimum/maximum value allowed. Even for properties that explicitly allow infinity as a keyword value, such as animation-iteration-count, will end up clamping ±∞, as math functions can’t resolve to keyword values; the numeric part of the property’s syntax still has a minimum/maximum value.
</p>

<p>
加えて， `number$t に解決される`~math関数$が `integer$t のみを受容する所に利用された場合、その［
`算出d値$／ `使用~値$
］は，上の切詰ngと同じ方式で最も近い整数に丸められる。
丸める手法は、整数~値の~animationと同じそれを利用するモノトスル。
◎
Additionally, if a math function that resolves to &lt;number&gt; is used somewhere that only accepts &lt;integer&gt;, the computed value and used value are rounded to the nearest integer, in the same manner as clamping, above. The rounding method must be the same as is used for animations of integer values.
</p>

<div class="example">
<p>
`0px^v より小さい横幅は許容されないので、次の 3 つは
<samp class="css">`width$p: `0px^v;</samp>
に等価になる：
◎
Since widths smaller than 0px are not allowed, these three declarations are equivalent:
</p>

<pre class="lang-css">
width: calc(5px - 10px);
width: calc(-5px);
width: 0px;
</pre>

<p>
しかしながら、
<samp class="css">`width$p: `-5px^v;</samp>
と
<samp class="css">`width$p: `calc(-5px)^v;</samp>
は等価ではないことに注意。
`calc$f の`外側^emにある範囲~外の値は，構文上は無効であり、宣言はまるごと落とされることになる。
◎
Note however that width: -5px is not equivalent to width: calc(-5px)! Out-of-range values outside calc() are syntactically invalid, and cause the entire declaration to be dropped.
</p>

</div>

		</section>
		<section id="calc-serialize">
<h3 title="Serialization">11.13. 直列化</h3>

<p class="issue">
この節は、依然として討議中にある。
【！https://lists.w3.org/Archives/Member/w3c-css-wg/2016AprJun/0239.html】
◎
This section is still under discussion.
</p>


<div class="algorithm">

<p>
`~math関数を直列化する@
ときは、所与の
( %fn )
に対し：
◎
To serialize a math function fn:
</p>
<ol>
	<li>
%根 ~LET %fn が表現する`計算式~tree$の根~node
</li>
	<li>
~IF［
%根 は数量-値（実数／百分率／次元）である
］~AND［
これが生産している直列化は`算出d値$かそれより後のものである
］
⇒
~RET 必要とされるなら，値を その文脈に許容される範囲に切詰めた上で、値を通常通り直列化した結果
【すなわち、この~algoを適用し直す】
◎
If the root of the calculation tree fn represents is a numeric value (number, percentage, or dimension), and the serialization being produced is of a computed value or later, then clamp the value to the range allowed for its context (if necessary), then serialize the value as normal and return the result.
</li>
	<li>
<p>
~IF［
%fn は［
無限／~NaN
］値を表現する
］：
◎
If fn represents an infinite or NaN value:
</p>
		<ul>
			<li>
%s ~LET 値を表現する適切な［
`infinity$v ／ `-infinity$v ／ `NaN$v
］~keywordを直列化した結果
◎
↓↓Let s be the string "calc(".
◎
Serialize the keyword infinity, -infinity, or NaN, as appropriate to represent the value, and append it to s.
</li>
			<li>
~IF［
%fn の`型$は `number$t を表現するもの（ «[ ]» に等価／無次元）でない
］
⇒
%s に次を順に付加する【！`型$が多重次元の場合は？】
⇒＃
` * 1^l,
%fn の`型$用の`正準的~単位$（ `length$t 用には `px$u など）
◎
If fn’s type is anything other than «[ ]» (empty, representing a &lt;number&gt;), append " * " to s. Create a numeric value in the canonical unit for fn’s type (such as px for &lt;length&gt;), with a value of 1. Serialize this numeric value and append it to s.
</li>
			<li>
~RET 次を順に連結した結果
⇒＃
`calc(^l,
%s,
`)^l【！原文抜け】
◎
Return s.
</li>
		</ul>
	</li>
	<li>
%名前 ~LET %根 に応じて
⇒＃
数量-値であるならば `calc^l ／
`~calc演算子~node$であるならば `calc^l ／
~ELSE_ 小文字~化された %根 の名前（ `sin^l, `max^l など）
◎
If the calculation tree’s root node is a numeric value, or a calc-operator node, let s be a string initially containing "calc(".
◎
Otherwise, let s be a string initially containing the name of the root node, lowercased (such as "sin" or "max"), followed by a "(" (open parenthesis).
</li>
	<li>
%~list ~LET 新たな~list
◎
↓↓
</li>
	<li>
<p>
%根 の
~EACH( 子 %子 )
に対し：
</p>
		<ol>
			<li>
%直列化 ~LET `計算式~treeを直列化する$( %子 )
</li>
			<li>
~IF［
%直列化 の先頭の文字 ~EQ `(^l （左~丸括弧）
］~AND［
%直列化 の末尾の文字 ~EQ `)^l （右~丸括弧）
］
⇒
%直列化 から先頭, 末尾の文字を除去する
</li>
			<li>
%~list に %直列化 を付加する
</li>
		</ol>
◎
For each child of the root node, serialize the calculation tree. If a result of this serialization starts with a "(" (open parenthesis) and ends with a ")" (close parenthesis), remove those characters from the result.＼
</li>
	<li>
%引数~列 ~LET %~list を `, ^l （~comma, ~spaceの並び）で`連結-$した結果
◎
Concatenate all of the results using ", " (comma followed by space), then append the result to s.
</li>
	<li>
~RET 次を順に連結した結果
⇒＃
%名前,
`(^l （左~丸括弧）,
%引数~列,
`)^l （右~丸括弧）
◎
Append ")" (close parenthesis) to s.
◎
Return s.
</li>
</ol>
</div>

<div class="algorithm">

<p>
`計算式~treeを直列化する@
ときは、所与の
( `計算式~tree$の根を与える~node %根 )
に対し：
◎
To serialize a calculation tree:
• Let root be the root node of the calculation tree.
</p>
<ol>
	<li>
~IF［
%根 は数量-値である
］~OR［
%根 は`~math関数$でない
］
⇒
~RET %根 用の通常の規則により %根 を直列化した結果
◎
If root is a numeric value, or a non-math function, serialize root per the normal rules for it and return the result.
</li>
	<li>
~IF［
%根 は［
`Sum^i, `Negate^i, `Product^i, `Invert^i
］以外の~nodeである
］
⇒
~RET `~math関数を直列化する$( %根 )
【！treating the ... 不要？】
◎
If root is anything but a Sum, Negate, Product, or Invert node, serialize a math function for the function corresponding to the node type, treating the node’s children as the function’s comma-separated calculation arguments, and return the result.
</li>
	<li>
~IF［
%根 は `Negate^i ~nodeである
］
⇒
~RET 次を順に連結した結果
⇒＃
`(-1 * ^l,
`計算式~treeを直列化する$( %根 の子 ),
`)^l
◎
If root is a Negate node, let s be a string initially containing "(-1 * ".
◎
Serialize root’s child, and append it to s.
◎
Append ")" to s, then return it.
</li>
	<li>
~IF［
%根 は `Invert^i ~nodeである
］
⇒
~RET 次を順に連結した結果
⇒＃
`(1 / ^l,
`計算式~treeを直列化する$( %根 の子 ),
`)^l
◎
If root is an Invert node, let s be a string initially containing "(1 / ".
◎
Serialize root’s child, and append it to s.
◎
Append ")" to s, then return it.
</li>
	<li>
<p>
~IF［
%根 は `Sum^i ~nodeである
］：
◎
If root is a Sum node,＼
</p>
		<ol>
			<li>
%s ~LET `(^l
◎
let s be a string initially containing "(".
</li>
			<li>
%子~list ~LET `根の子たちを~sortする$( %根 )
◎
Sort root’s children.
</li>
			<li>
%s に次の結果を付加する
⇒
`計算式~treeを直列化する$( %子~list の最初の~item )
◎
Serialize root’s first child, and append it to s.
</li>
			<li>
<p>
%子~list を成す最初の~itemを除く
~EACH( %子 )
に対し：
◎
For each child of root beyond the first:
</p>
				<ol>
					<li>
~IF［
%子 は `Negate^i ~nodeである
］
⇒
%s に次を順に付加する
⇒＃
` - ^l,
`計算式~treeを直列化する$( %子 の子 )
◎
If child is a Negate node, append " - " to s, then serialize the Negate’s child and append the result to s.
</li>
					<li>
~ELIF［
%子 は 負な数量-値である
］
⇒
%s に次を順に付加する
⇒＃
` - ^l,
%子 の反数化を通常通り直列化した結果
◎
If child is a negative numeric value, append " - " to s, then serialize the negation of child as normal and append the result to s.
</li>
					<li>
~ELSE
⇒
%s に次を順に付加する
⇒＃
` + ^l,
`計算式~treeを直列化する$( %子 )
◎
Otherwise, append " + " to s, then serialize child and append the result to s.
</li>
				</ol>
			</li>
			<li>
%s に `)^l を付加する
◎
Finally, append ")" to s＼
</li>
			<li>
~RET %s
◎
and return it.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%根 は `Product^i ~nodeである
］：
◎
If root is a Product node,＼
</p>
		<ol>
			<li>
%s ~LET `(^l 
◎
let s be a string initially containing "(".
</li>
			<li>
%子~list ~LET `根の子たちを~sortする$( %根 )
◎
Sort root’s children.
</li>
			<li>
%s に次の結果を付加する
⇒
`計算式~treeを直列化する$( %子~list の最初の~item )
◎
Serialize root’s first child, and append it to s.
</li>
			<li>
<p>
%子~list を成す最初の~itemを除く
~EACH( %子 )
に対し：
◎
For each child of root beyond the first:
</p>
				<ol>
					<li>
~IF［
%子 は `Invert^i ~nodeである
］
⇒
%s に次を順に付加する
⇒＃
` / ^l を付加する,
`計算式~treeを直列化する$( %子 の子 )
◎
If child is an Invert node, append " / " to s, then serialize the Invert’s child and append the result to s.
</li>
					<li>
~ELSE
⇒
%s に次を順に付加する
⇒＃
` * ^l,
`計算式~treeを直列化する$( %子 )
◎
Otherwise, append " * " to s, then serialize child and append the result to s.
</li>
				</ol>
			</li>
			<li>
%s に `)^l を付加する；
◎
Finally, append ")" to s＼
</li>
			<li>
~RET %s
◎
and return it.
</li>
		</ol>
	</li>
</ol>
</div>

<div class="algorithm">

<p>
`根の子たちを~sortする@
ときは、所与の
( %根 )
に対し，［
%根 の子たちを，次に従って~sortした結果
］を新たな~listとして返す：
◎
To sort a calculation’s children nodes:
</p>
<ul>
	<li>
次の順に~sortする
⇒＃
`実数$を包含する~node（高々 1 個）,
`百分率$を包含する~node（高々 1 個）,
`次元$を包含する~node,
その他の~node
◎
Let ret be an empty list.
◎
If nodes contains a number, remove it from nodes and append it to ret.
◎
If nodes contains a percentage, remove it from nodes and append it to ret.
</li>
	<li>
次元を包含する~nodeどうしは、`~ASCII大小無視$の下で，それらの単位の~alphabet順に~sortする
◎
If nodes contains any dimensions, remove them from nodes, sort them by their units, ordered ASCII case-insensitively, and append them to ret.
</li>
	<li>
その他の~nodeどうしは、元と同じ順序に従う
◎
If nodes still contains any items, append them to ret in the same order.
◎
Return ret.
</li>
</ul>
</div>

<div class="example">
<p>
例えば，
`calc(20px + 30px)^v
は、指定d値としては `calc(50px)^v に，算出d値としては `50px^v に直列化する。
◎
For example, calc(20px + 30px) would serialize as calc(50px) as a specified value, or as 50px as a computed value.
</p>

<p>
`calc(20px + 0%)^v の様な値は、
`calc(0% + 20px)^v として直列化し，いずれの項も 直列化された値の中に保守する。
（ 0 値の項を保守することは重要である
— いずれかの値が一時的に 0 値になっても，遷移の最中に突然 `calc$f の “~~形が変わる” ことがないように。
また、すべての項が 0 であるときに “単位を選ぶ” 必要もなくなる。）
◎
A value like calc(20px + 0%) would serialize as calc(0% + 20px), maintaining both terms in the serialized value. (It’s important to maintain zero-valued terms, so the calc() doesn’t suddenly "change shape" in the middle of a transition when one of the values happens to have a zero value temporarily. This also removes the need to "pick a unit" when all the terms are zero.)
</p>

<p>
`calc(20px + 2em)^v の様な値は、指定d値としては
`calc(2em + 20px)^v に直列化する（両 単位とも、指定d値の時点では互換でないので，~alphabet順に~sortした上で保守する）。
また、算出d値としては `52px^v の様な値に直列化する（ `em$u 値は，算出d値の時点で絶対~長さに換算されるので、
`1em^v = `16px^v
であったなら、それらは `52px^v に結合した上で，括っている `calc$f を外す）。
◎
A value like calc(20px + 2em) would serialize as calc(2em + 20px) as a specified value (maintaining both units as they’re incompatible at specified-value time, but sorting them alphabetically), or as something like 52px as a computed value (em values are converted to absolute lengths at computed-value time, so assuming 1em = 16px, they combine into 52px, which then drops the calc() wrapper.)
</p>

</div>

<p>
直列化についての更なる情報は、 `CSSOM$r を見よ。
◎
See [CSSOM] for further information on serialization.
</p>

		</section>
		<section id="combine-math">
<h3 title="Combination of Math Functions">11.14. ~math関数の結合n</h3>

<div class="p">
<p>
［
`~math関数$どうし／
数量-値と数量-値をとる関数
］の：
</p>

<ul>
	<li>
`補間$における %結果値 は次で定義される
⇒
<code class="value">calc((1 - %p) * %値a + %p * %値b)</code>
</li>
	<li>
`加算$における %結果値 は次で定義される
⇒
<code class="value">calc(%値a + %値b)</code>
</li>
</ul>

<p>
（いずれの場合も、 %結果値 の`計算式~treeを単純~化$した結果は、式をより小さく単純な形に簡約し得る。）
</p>

◎
Interpolation of math functions, with each other or with numeric values and other numeric-valued functions, is defined as Vresult = calc((1 - p) * Va + p * Vb). (Simplification of the value might then reduce the expression to a smaller, simpler form.)
◎
Addition of math functions, with each other or with numeric values and other numeric-valued functions, is defined as Vresult = calc(Va + Vb). (Simplification of the value might then reduce the expression to a smaller, simpler form.)
</div>

		</section>
	</section>
	<section id="iana">
<h2 title="Appendix A: IANA Considerations">付録 A. IANA 考慮点</h2>

		<section id="about-invalid">
<h3 title="Registration for the about:invalid URL scheme">A.1. `about:invalid^c ~URL~schemeの登録</h3>

<p>
この節では、 `RFC6694$r にて定義される登録~手続きに則って，
`about:invalid^c ~URLを定義して登録する。
◎
This sections defines and registers the about:invalid URL, in accordance with the registration procedure defined in [RFC6694].
</p>

<p>
この登録の公式的な記録は
<a href="http://www.iana.org/assignments/about-uri-tokens/about-uri-tokens.xhtml">http://www.iana.org/assignments/about-uri-tokens/about-uri-tokens.xhtml</a>
に見出せる。
◎
The official record of this registration can be found at http://www.iana.org/assignments/about-uri-tokens/about-uri-tokens.xhtml.
</p>

<table><tbody>
<tr><th title="Registered Token" style="min-width:10em;">登録された~token
<td>`invalid^c

<tr><th title="Intended Usage">意図されている用途
<td>
`about:invalid^c ~URLは、汎用~error条件を伴う，存在しない文書を参照する。
~URLが必要な所で，既定~値がいかなる型の文書にも解決-可能になるべきでないときに、利用できる。
◎
The about:invalid URL references a non-existent document with a generic error condition. It can be used when a URL is necessary, but the default value shouldn’t be resolvable as any type of document.

<tr><th title="Contact/Change controller">連絡先／変更管理者
<td>CSS WG &lt;<a href="mailto:www-style@w3.org">www-style@w3.org</a>&gt; (on behalf of W3C)

<tr><th title="Specification">仕様
<td><a href="~TR/css3-values/">CSS Values and Units Module Level 3</a>

</tbody></table>

		</section>
	</section>
	<section id="acknowledgments">
<h2 title="Acknowledgments">謝辞</h2>

<p>
はじめに、この~moduleの
<a href="http://www.w3.org/TR/css-values-3/#acknowledgements">以前の~level</a>
に貢献されたすべての方々に感謝する。
◎
Firstly, the editors would like to thank all of the contributors to the previous level of this module.
</p>

<p>
次に、~commentと示唆を寄せられ，この Level 4 を向上させた
`Koji Ishii^en, `Xidorn Quan^en 両氏に。
◎
Secondly, we would like to acknowledge Koji Ishii and Xidorn Quan for their comments and suggestions, which have improved Level 4.
</p>

	</section>
	<section id="changes">
<h2 title="Changes">変更点</h2>

<p>
<a href="~TR/2018/WD-css-values-4-20181010/">2018年 10月 10日 作業草案</a>
からの変更点は、
<a href="~TR/2019/CR-css-values-3-20190131/#changes">CSS Level 3 における近過去の変更点</a>
と同期している：
◎
Changes since the 10 October 2018 Working Draft consist of synchronizing with the recent changes in CSS Level 3.
</p>

<p>
<a href="~TR/2018/WD-css-values-4-20180814/">2018年 8月 14日 作業草案</a>
からの変更点は：
◎
Changes since the 14 August 2018 Working Draft:
</p>

<ul>
	<li>
各~値~型ごとに補間~用の規則を追加して，算出d値を明確化した。
◎
Added rules for interpolation per value type, and clarified computed values.
</li>
</ul>

<p>
<a href="~TR/css-values-3/">Level 3</a>
からの変更点は：
◎
Changes since Level 3:
</p>

<ul>
	<li>
`vi$u, `vb$u, `ic$u, `cap$u, `lh$u, `rlh$u 単位を追加した。
◎
Added the vi, vb, ic, cap, lh and rlh units. 
</li>
	<li>
`min$f, `max$f, `clamp$f
関数-記法を追加した。
◎
Added min(), max(), and clamp() functional notations.
</li>
	<li>
`calc$f に単位の算術を追加した。
◎
Added unit arithmetic to calc().
</li>
	<li>
`toggle$f を追加した。
（元々は ~level 3 から~puntされた）。
◎
Added toggle() (punted from level 3 originally).
</li>
	<li>
`css-typed-om-1$r からの~~借用による，
<a href="#calc-type-checking">単位~代数</a>を追加した。
◎
Added unit algebra, cribbing from [css-typed-om-1].
</li>
	<li>
［
`integer$t が要求される所で利用された `calc^f
］を解決した結果が整数でないときは、自動的に最も近い整数に丸められる。
◎
A non-integer in a calc() automatically rounds to the nearest integer when used where an &lt;integer&gt; is required.
</li>
	<li>
`~math関数$の<a href="#calc-serialize">直列化</a>を定義した。
◎
Defined serialization of math functions.
</li>
</ul>

	</section>
	<section id="sec-pri">

<h2 title="Security and Privacy Considerations">~securityと~privacyの考慮点</h2>

<p>
この仕様は，ほぼ各種~CSS仕様に共通な単位を定義するだけであり、~securityの懸念になるものはない。
◎
This specification mostly just defines units that are common to CSS specifications, and which present no security concerns.
</p>

<p class="note">注記：
~URLの取扱いは~securityの懸念になるか？
おそらく。
◎
Note: Does URL handling have a security concern? Probably.
</p>

<p>
この仕様は、利用者の~screen~size, および
既定の~font~sizeを公開する単位を定義するが、両者とも~JSから自明に観測-可能なので、新たな~privacy~riskを成すことはない。
◎
This specification defines units that expose the user’s screen size and default font size, but both are trivially observable from JS, so they do not constitute a new privacy risk.
</p>

	</section>
</main></div>

