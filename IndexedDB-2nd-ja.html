<!DOCTYPE html><html lang="ja"><head><meta charset="utf-8">
<title>Indexed Database API 2.0 （日本語訳）</title>

<link rel="icon" href="IndexedDB-2nd/logo-db.png">
<link rel="stylesheet" href="common.css" type="text/css" />
<link rel="stylesheet" href="common-w3c.css" type="text/css" />
<script src="common0.js" ></script>
<script src="common1.js" async></script>

<script>

var source_data;

COMMON_DATA.init = function(expanded){
	var options = {
		original_url: 'https://w3c.github.io/IndexedDB/',
		main: 'MAIN',
		spec_status: 'ED',
		fill_text_link: '#_versions > dd, #references dd',
		alt_refs: 'references',
		ref_id_prefix: 'biblio-',
		ref_id_lowercase: true,
	};

	if(expanded) return options;

	source_data = {
		html: E('MAIN').innerHTML,
		link_map: Util.getMapping('_link_map'),
		toc_main: 'MAIN0',
		levels: '英語主体:英語寄り:漢字＋英語:漢字主体:カナ主体',
		level: 3,
		generate: expand
	}

	Util.switchWordsInit(source_data);

/*
	repeat('._summary', function(e){e.remove()});
	Util.del_j(); // checed: 160803 spec
*/

	return options;
}

function expand(mapping1){

	var class_map = {
		e: 'element',
		a: 'attr',
		et: 'event-type',
		mb: 'dictionary-member',
		E: 'error',
		l: 'literal',
		i: 'constant',
		sl: 'js',
		js: 'js',
		jA: 'abstract',
		tnote: 'trans-note'
	};

	var tag_map = {
		I: 'code',
		m: 'code',
		mF: 'code',
		mb: 'code',
		et: 'code',
		E: 'code',
		l: 'code',
		i: 'i',
		p: 'code',
		c: 'code',
		js: 'code',
		jA: 'span',
		sl: 'span',
		V: 'var',
		tnote: 'span'
	};

	var link_map = this.link_map;
	var nesting = '';
	var in_idl = false;
	var idl_ifc = '';
	var context_key ='';


	E('MAIN').innerHTML = Util.replaceWords1(
		this.html.replace(
			/⇒[！？]?|◎[^<◎]*|%[\w~\u4E00-\u9FFF]+|`(.+?)([$@!\^])(\w*)/g,
			create_html
		),
		mapping1
	);

	function create_html(match, key, indicator, klass){

if(!key) {
	if(match.charAt(0) === '%'){
		return '<var>' + match.slice(1) + '</var>'
	}
//	var t = match.charAt(0);
	switch(match){
	case '⇒':
		nesting += '</span>';
		return '：<span class="block">';
	case '⇒！':
		in_idl = true;
		nesting += '</pre>';
		return '<pre class="idl">';
	}//◎
	if(in_idl) {
		result = nesting;
		in_idl = false;
	} else {
		result = nesting + '<span lang="en">' + match.slice(1) + '</span>';
	}
	nesting = '';
	return result;
}

var quote;
var text = key;
var href = '';
var classname;
var tag = tag_map[klass];

switch(klass){
case 'r': // ref
	text = '[' + key + ']';
	href = '#biblio-' + key.toLowerCase();;
	break;
case 'I': // IDL interface
	if((indicator === '@') || (indicator === '!')){
		idl_ifc = key;
	}
	href = '#dom-' + key.toLowerCase();
	if(in_idl) tag = '';
	break;
case 'm': // IDL member
	var n = text.indexOf('(');
	if(n > 0){
		key = text.slice(0, n);
		text = key + text.slice(n).replace(/\w+/g, '<var>$&</var>');
	}
	href = key.indexOf('.');
	if(href >=0 ){
		href = key.slice(0, href) + '-' + key.slice(href + 1);
//		console.log(href);
	} else {
		href = (key === idl_ifc) ? idl_ifc : (idl_ifc + '-' + key);
	}
	href = '#dom-' + href.toLowerCase();
	if(in_idl) tag = '';
	break;
case 'et': // event-types
	href = '#_event-' + key;
	break;
case 'E': // exceptions
	href = '#exceptiondef-exceptions-' + key.toLowerCase();
	break;
case 'sl': // js intenal
	text = '[[' + text + ']]';
	break;
case 'l': // literal
	quote = '"'
	break;
case 'tnote': 
	text = '【' + text + '】';
	break;
case 'bug' :
	return (
'（ <a href="~SPECBUGS?id=' + key + '">bug #' + key + '</a> ）'
	);
	break;
case 'bug2' :
	return (
'（ <a href="~IDBISSUES/'
+ key + '">bug #' + key + '</a> ）'
	);
	break;
}

if(tag) {
	classname = class_map[klass];
	text = '<' + tag + (
		classname ? ' class="' + classname + '"' : ''
	) + '>' + text + '</' + tag + '>';
}


if(indicator !== '^'){
	href = link_map[klass ? (klass + '.' + key) : key] || href;
	if(!href){
		console.log(match); // check error
		return match;
	}

	switch(indicator){
	case '!':
	case '$':
		text = '<a href="' + href + '">' + text + '</a>';
		break;
	case '@':
		context_key = klass ? (klass + '.' + key) : key;
		text = '<dfn id="' + href.slice(1) + '">' + text + '</dfn>';
		break;
	}
}

return (quote ? quote + text + quote : text);

	}
}

</script>


<script type="text/plain" id="_original_id_map">
</script>

<!--% リンク定義 


-->
<script type="text/plain" id="_link_map">
専属する:#_belong
専属しない:#_belong
値を保持し続ける:#_remain
可換性:#_commutative-requirement
一意性:#_uniqueness-requirement
例外である:#_is-error
~access先:#_to-access

整列済み~list:#sorted-list

関係db:https://ja.wikipedia.org/wiki/%E9%96%A2%E4%BF%82%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9
図式は可換:https://ja.wikipedia.org/wiki/%E5%8F%AF%E6%8F%9B%E5%9B%B3%E5%BC%8F

	●IDL
Exposed:~WEBIDL#Exposed
EnforceRange:~WEBIDL#EnforceRange

I.IDBCursor:#idbcursor
I.IDBCursorDirection:#enumdef-idbcursordirection
I.IDBCursorWithValue:#idbcursorwithvalue
I.IDBDatabase:#idbdatabase
I.IDBFactory:#idbfactory
I.IDBIndex:#idbindex
I.IDBIndexParameters:#dictdef-idbindexparameters
I.IDBKeyRange:#idbkeyrange
I.IDBObjectStore:#idbobjectstore
I.IDBObjectStoreParameters:#dictdef-idbobjectstoreparameters
I.IDBOpenDBRequest:#idbopendbrequest
I.IDBRequest:#idbrequest
I.IDBRequestReadyState:#enumdef-idbrequestreadystate
I.IDBTransaction:#idbtransaction
I.IDBTransactionMode:#enumdef-idbtransactionmode
I.IDBVersionChangeEvent:#idbversionchangeevent
I.IDBVersionChangeEventInit:#dictdef-idbversionchangeeventinit

I.DOMStringList:#domstringlist

I.Blob:~FILEAPI#dfn-Blob
I.File:~FILEAPI#dfn-file
I.DOMError:~DOM4#domerror
I.DOMException:~WEBIDL#dfn-DOMException
I.DOMString:~WEBIDL#idl-DOMString
I.DOMTokenList:~DOM4#domtokenlist
I.Document:~HTMLdom#document
I.Event:~DOM4#event
I.Event:~DOM4#concept-event
I.EventInit:~DOM4#dictdef-eventinit
I.EventTarget:~DOM4#eventtarget
I.EventHandler:~WAPI#eventhandler
I.ImageData:~HTML5/scripting.html#imagedata
I.WindowOrWorkerGlobalScope:~HTMLGAPI#windoworworkerglobalscope

m.domain:~BROWSERS#dom-document-domain
m.preventDefault:~DOM4#dom-event-preventdefault

	m.type:~DOM4#dom-event-type

mF.size:~FILEAPI#dfn-size
mF.lastModified:~FILEAPI#dfn-lastModified
mF.name:~FILEAPI#dfn-name
mF.type:~FILEAPI#dfn-type


	E.AbortError:exceptiondef-exceptions-aborterror
	E.ConstraintError:exceptiondef-exceptions-constrainterror
	E.DataCloneError:exceptiondef-exceptions-datacloneerror
	E.DataError:exceptiondef-exceptions-dataerror
	E.InvalidAccessError:exceptiondef-exceptions-invalidaccesserror
	E.InvalidStateError:exceptiondef-exceptions-invalidstateerror
	E.NotFoundError:exceptiondef-exceptions-notfounderror
	E.QuotaExceededError:exceptiondef-exceptions-quotaexceedederror
	E.SyntaxError:exceptiondef-exceptions-syntaxerror
	E.ReadOnlyError:exceptiondef-exceptions-readonlyerror
	E.TransactionInactiveError:exceptiondef-exceptions-transactioninactiveerror
	E.UnknownError:exceptiondef-exceptions-unknownerror
	E.VersionError:exceptiondef-exceptions-versionerror

I.octet:~WEBIDL#idl-octet
~SeqDS:~WEBIDL#idl-sequence
~SeqAny:~WEBIDL#idl-sequence
~DS:~WEBIDL#idl-DOMString
I.unrestricted double:~WEBIDL#idl-unrestricted-double

	●enum
l.done:#dom-idbrequestreadystate-done
l.pending:#dom-idbrequestreadystate-pending

l.next:#dom-idbcursordirection-next
l.nextunique:#dom-idbcursordirection-nextunique
l.prev:#dom-idbcursordirection-prev
l.prevunique:#dom-idbcursordirection-prevunique

l.readonly:#dom-idbtransactionmode-readonly
l.readwrite:#dom-idbtransactionmode-readwrite
l.versionchange:#dom-idbtransactionmode-versionchange

et.blocked:#request-blocked
et.upgradeneeded:#request-upgradeneeded


	●js
中途完了:~TC39#sec-completion-record-specification-type

js.Array:~TC39#sec-array-objects
js.ArrayBuffer:~TC39#sec-arraybuffer-objects
js.Date:~TC39#sec-date-objects
js.IdentifierName:~TC39#prod-IdentifierName
js.Number:~TC39#sec-ecmascript-language-types-number-type
js.Object:~TC39#sec-object-objects
js.String:~TC39#sec-ecmascript-language-types-string-type
js.TypeError:~TC39#sec-native-error-types-used-in-this-standard-typeerror
js.Uint8Array:~TC39#sec-typedarray-objects

jA.CreateDataProperty:~TC39#sec-createdataproperty
jA.Type:~TC39#sec-ecmascript-data-types-and-values
jA.ReturnIfAbrupt:~TC39#sec-returnifabrupt
jA.IsArray:~TC39#sec-isarray
jA.ToString:~TC39#sec-tostring
jA.ToLength:~TC39#sec-tolength
jA.Get:~TC39#sec-get-o-p
jA.HasOwnProperty:~TC39#sec-hasownproperty

	Assert

	●es 言語束縛
~keyを抽出-:#extract-a-key-from-a-value-using-a-key-path
抽出される~key:#_ExtractedKeys
~key~pathを用いて値に~keyを注入-:#inject-a-key-into-a-value-using-a-key-path
値へ変換-:#convert-a-key-to-a-value
~keyへ変換-:#convert-a-value-to-a-key
複entryへ変換-:#convert-a-value-to-a-multientry-key


ExtractKey:#extract-a-key-from-a-value-using-a-key-path
Extract:#_Extract
ExtractKeySet:#_ExtractKeySet
Evaluate:#evaluate-a-key-path-on-a-value
Inject:#inject-a-key-into-a-value-using-a-key-path
Key1:#convert-a-value-to-a-key
Value1:#convert-a-key-to-a-value
MultiKey:#convert-a-value-to-a-multientry-key
Key:#_Key
Value:#_Value
Flag:#_Flag

Error:#_Error
Bool:#_Bool
Clone:#structured-clone
CheckState:#_check-opratable



	●database, 接続
~db:#database
db.名前:#database-name
db.~version:#database-version
~db~access~task源:#database-access-task-source

接続:#connection
	接続先~db:#connection
Cn.~version:#connection-version
Cn.保管庫~集合:#connection-object-store-set
Cn.状態:#connection-close-pending-flag
i.~open中:#connection-opened
i.~close済み:#connection-closed
i.~close待ち:#connection-close-pending-flag
	~close待ち~flag:#connection-close-pending-flag

	~open中:#connection-opened
~close:#connection-closed

専属の昇格~tx:#_connection-upgrade-transaction
接続~待行列:#request-connection-queue

	●transaction
~tx:#transaction-concept
tx.接続:#transaction-connection
	専属する接続:#transaction-connection
視野:#transaction-scope
~mode:#transaction-mode
作動中~flag:#transaction-active-flag
作動中:#transaction-active
要請~list:#transaction-request-list
tx.~error:#transaction-error
存続期間:#transaction-lifetime
作成-:#transaction-created
新たな~tx:#transaction-created
開始-:#transaction-start
中止-:#transaction-abort
~commit:#transaction-commit
終了-:#transaction-finish
実行-:#_transaction-execute
昇格~tx:#upgrade-transaction
稼働中:#_transaction-running
昇格~txの中:#_within-an-upgrade-transaction

~readwrite~tx:#transaction-read-write-transaction
~readonly~tx:#transaction-read-only-transaction


	●要請
要請:#request
~done~flag:#request-done-flag
~source:#request-source
結果:#request-result
~error:#request-error
~open要請:#request-open-request
演算:#_operation
設置先~tx:#request-transaction
設置-:#request-placed


	●保管庫, 索引
保管庫:#object-store
Os.~record~list:#object-store-list-of-records
	＊Os.~record:#object-store-record
Os.名前:#object-store-name
Os.~key~path:#object-store-key-path
	Os.~in-line~key:#object-store-in-line-keys
	~key~pathを持つ:#object-store-in-line-keys
	Os.~out-of-line~key:#object-store-out-of-line-keys
	~key~pathを持たない:#object-store-out-of-line-keys

保管庫~handle:#object-store-handle
OsH.保管庫:#object-store-handle-object-store
OsH.索引~集合:#object-store-handle-index-set
OsH.名前:#object-store-handle-name
OsH.専属する~tx:#object-store-handle-transaction
OsH.~tx:#object-store-handle-transaction

索引:#index
参照-:#index-referenced
参照先の保管庫:#index-referenced
参照先の値:#index-referenced-value
参照先~record:#_index-referenced-record
Ix.~record~list:#index-list-of-records
Ix.~key~path:#index-key-path
Ix.名前:#index-name
Ix.一意~flag:#index-unique-flag
Ix.複entry~flag:#index-multientry-flag

索引~handle:#index-handle
	＊Ix.索引:#index-handle-index
IxH.名前:#index-handle-name
IxH.保管庫~handle:#index-handle-object-store-handle
IxH.~tx:#index-handle-transaction



	●crusor
~cursor:#cursor
Cs.範囲:#cursor-range
Cs.~source:#cursor-source
Cs.方向:#cursor-direction
Cs.~tx:#cursor-transaction
Cs.位置:#cursor-position
Cs.保管庫~位置:#cursor-object-store-position
Cs.~key:#cursor-key
Cs.値:#cursor-value
Cs.値取得済~flag:#cursor-got-value-flag
Cs.実効~保管庫:#cursor-effective-object-store
Cs.実効~key:#cursor-effective-key
Cs.~key~only~flag:#cursor-key-only-flag
Cs.要請:#_cursor-request



	●record, value, key, key範囲, key path
~record:#_record
	Os.~record:#object-store-record
値:#value
~key:#key

i.number:#_keytype-number
i.date:#_keytype-date
i.string:#_keytype-string
i.binary:#_keytype-binary
i.array:#_keytype-array


~key範囲:#key-range
下界:#lower-bound
上界:#upper-bound
下界open~flag:#lower-open-flag
上界open~flag:#upper-open-flag
のみを包含する:#containing-only
全範囲:#unbounded-key-range
Only:#containing-only
入る:#in
Range:#convert-a-value-to-a-key-range

~key生成器:#key-generator
現在の番号:#current-number
最大の番号:#_max-number
		NUMBER.MAX_SAFE_INTEGER
		9007199254740992

key.種別:#key-type
key.値:#key-value
配列~key:#array-key
下位key:#subkeys
key.比較-:#compare-two-keys
Cmp:#compare-two-keys
より大きい:#greater-than
より小さい:#less-than
等しい:#equal-to
~key~path:#key-path
妥当な~key~path:#valid-key-path
識別子:#identifier



	●手続き

	event
~success~eventを発火する:#fire-a-success-event
~error~eventを発火する:#fire-an-error-event
~version変更~eventを発火する:#fire-a-version-change-event


~dbを~open:#steps-for-opening-a-database
~db接続を~close:#steps-for-closing-a-database-connection
~dbを削除-:#steps-for-deleting-a-database

~txを~commit:#steps-for-committing-a-transaction
~txを中止-:#steps-for-aborting-a-transaction

非同期に実行する新たな要請:#steps-for-asynchronously-executing-a-request
要請の演算を非同期に実行する:#steps-for-asynchronously-executing-a-request
非同期に実行する:#steps-for-asynchronously-executing-a-request

昇格~txを稼働-:#steps-for-running-an-upgrade-transaction
昇格~txを中止-:#steps-for-aborting-an-upgrade-transaction

保管庫に~recordを格納する:#steps-for-storing-a-record-into-an-object-store

	Retrieval Operations
範囲に入る~entryたちを検索取得する:#_steps-for-retrieving-multiple-x-from-y
範囲に入る最初の~entryを検索取得する:#_steps-for-retrieving-a-x-from-y

保管庫から~recordを削除する:#steps-for-deleting-records-from-an-object-store
範囲に入る~recordを数える:#steps-to-count-the-records-in-a-range
保管庫を~clearする:#steps-for-clearing-an-object-store

steps for clearing an object store:steps-for-clearing-an-object-store
~cursorを反復-:#steps-for-iterating-a-cursor
~cursorを作成-:#_create-new-cursor

	LI:#version-change-close-block
	LI:#delete-close-block

	●外部
被取消~flag:~DOM4#canceled-flag
発火する:~DOM4#concept-event-fire
~eventの構築法:~DOM4#constructing-events
文書:~DOM4#concept-document
親~標的を取得-:~DOM4#get-the-parent


~taskを待入する:~WAPI#queue-a-task
~taskを待入し:~WAPI#queue-a-task
~event~handler IDL 属性:~WAPI#event-handler-idl-attributes
~event~handler~event型:~WAPI#event-handler-event-type
~event~loop:~WAPI#event-loop
~task:~WAPI#concept-task
~task源:~WAPI#task-source
~task待行列:~WAPI#task-queue

~worker:~WORKERS#worker
同一生成元:~BROWSERS#same-origin
生成元:~BROWSERS#concept-origin
閲覧文脈:~BROWSERS#browsing-context

厳密に分割-:~HTMLINFRA#strictly-split-a-string
有構造~clone~algo:~HTMLcloning#safe-passing-of-structured-data
有構造~clone:~HTMLcloning#structuredclone

投出-:~WEBIDL#dfn-throw
	例外の作成-#dfn-create-exception
~buffer~source型:~WEBIDL#idl-buffer-source-types
	~buffer~source型:~WEBIDL#dfn-buffer-source-type
~buffer~sourceに保持されている~byte列の複製を取得-:~WEBIDL#dfn-get-buffer-source-copy
被support~prop~index:~WEBIDL#dfn-supported-property-indices
有index~propの値を決定する:~WEBIDL#dfn-determine-the-value-of-an-indexed-property

</script>


<!--% 語彙置換データ-->

<script type="text/plain" id="words_table1">

SeqDS: <code>sequence&lt;DOMString&gt;</code> 
SeqAny: <code>sequence&lt;any&gt;</code> 
DS: <code>DOMString</code> 
IDBISSUES:https://github.com/w3c/IndexedDB/issues
cmpkey:<a href="#_key_comparison"><sub>key</sub></a>
cmpRec:<a href="#_index_record_comparison"><sub>rec</sub></a>


invalid: <i>invalid</i> 
failure: <i>failure</i> 
PERIOD: U+002E ("<code class="literal">.</code>") 
</script>
<!-- 
error:<code class="event-type">error</code>
success:<code class="event-type">success</code>

-->

<!--%語彙  -->
<script type="text/plain" id="words_table">
此れ:<a href="#_context-object"><b>これ°</b></a>


	●db／接続／tr／event／Tr
db: database:::データベース
data::::データ

接続:connection::~
接続先の:connected::~
接続-:connect::~
生成元:origin::~::オリジン
同一生成元:same origin::~::同一オリジン

mode::::モード
要求mode:required mode:要求 mode::要求モード
	out-of-line
	in-line
open:
	opening
close:
	close 待ちclose pending
error:
success:

readonly:
readwrite:read/write
done:
commit::::コミット
record::::レコード
source::::ソース
源:source::~::ソース
handle::::ハンドル
version::::バージョン
	新~version
	旧~version
値:value:~
保管庫:object store::~::オブジェクトストア
設置-:place::~
設置先:place 先::~
索引:index::~::インデックス
索引付き:indexed::~::インデックス付き
蓄積:storage::~::ストレージ


tx: transaction:::トランザクション
視野:scope::~::スコープ

	target::::
task::::タスク
microtask::::極小タスク
配送-:dispatch::~::ディスパッチ

浮上-:bubble::~::バブル
取消可:cancelable::~::キャンセル可
取消不可:not cancelable::~::キャンセル不可
取消-:cancel::~::キャンセル
取消す:cancel する::~::キャンセルする
被取消:canceled::取消::キャンセル
既定の:default::~::デフォルト
既定:default::~::デフォルト
登録-:register:~
標的:target:::ターゲット
親:parent:~
event::::イベント
loop::::ループ
handler::::ハンドラ
listen::::リッスン
listener::::リスナ
starvation::::
伝播-:propagate::~
伝播:propagation::~

待機-:wait::~
阻止:block::~
	unblock
	failed
待行列:queue::待ち行列::キュー
待入する:queue する::待ち行列に入れる::キューする
待入され:queue され::待ち行列に入れられ::キューされ
待入し:queue し::待ち行列に入れ::キューし
	queue-up
	queuing
稼働-:run::~
稼働中:running::~
走らす:run する:~

巻戻-:roll back::~
巻戻す:roll back する::~
巻戻し:rollback::~

発火-:fire::~
発火:firing::~
成功-:succeed::~
成功裡:successful::~
成功:success::~
失敗-:fail::~
失敗:failure::~

存続期間:lifetime:~
	短命:short lived
不可分的:atomic::~
復帰-:revert::~
復帰させ:revert す::~
要請:request::~::リクエスト

同期的:synchronous::~
非同期:asynchronous::~
非同期的:asynchronous::~
非同期的な:asynchronous::~
並列的:parallel:~
事由:reason::~

例外:exception:~
例外的:exceptional:~
thread::::スレッド
検査:check:~
動作:action::~::アクション
動作-:act::~::アクト
作動中:active::~::アクティブ

終了-:finish::~
完了-:complete::~
中止-:abort::~
開始-:start::~

種別:type:~
上書不可:no-overwrite::上書き不可
上書き:overwrite:~
	上書-:override:~
開始待ちの:pending::~
遅延:delay::~
即時:immediate:~
	starting
強制:forced:~

一意性:uniqueness:~
	一意性の
送達-:deliver:~
	delivery

	●演算
	取得演算:取得 operation::~
演算:operation::~
演算-:operate::~
実行:execution:~
実行-:execute:~
	executing
削除:deletion::~
削除-:delete::~

格納-:store::~::ストア
追加の:additional:~
追加-:add:~
追加:addition:~
除去:removal:~
除去-:remove:~

更新:update:~
破壊:destruction::~
破壊-:destroy::~
昇格:upgrade::~
保存-:save::~
変更:change:~
変化:change:~

書込する:write する::書込む
書込しよ:write しよ::書込も
書込さ:write さ::書込ま
書込でき:write でき::書込め
書込し:write し::書込み
書込しな:write しな::書込まな
書込して:write して::書込んで
書込み:writing::書込み
書込:write::書込み

読取する:read する::読取る
読取さ:read さ::読取ら
読取でき:read でき::読取れ
読取し:read し::読取り
読取しな:read しな::読取らな
読取して:read して::読取って
読取した:read した::読取った
読取り:reading::読取り
読取:read::読取り

改変-:modify:~
改変ing:modifying:改変
改変:modification:~
変異:mutation:~

参照:reference::~
参照-:reference::~
参照先:referenced::~
参照先の:referenced::~
	mutating:~

結果:result:~

flag::::フラグ
entry::::エントリ
	項目


	●key 生成／cursor／走査
変換:conversion:~
変換-:convert:~
生成器:generator::~
生成-:generate::~
生成:generation::~
反復-:iterate::~::イテレート
反復:iteration::~::イテレーション
反復対象に:iterate over::~::イテレート対象に
整列-:sort:~::ソート
整列済み:sorted:~::ソート済み
拡充-:populate::~
拡充:populating::~
自動的:automatic:~
注入-:inject::~
挿入:insertion::~
挿入-:insert::~
導出-:derive:~
cursor::::カーソル
生成key:generated key::生成 key
下位key:subkey::下位 key
主key:primaryKey::主 key
only:
got:
key:
path:
範囲:range::~
全範囲:unbounded key range:~
下界:lower bound::~
上界:upper bound::~
下界open:lower open::下界 open
上界open:lower open::上界 open
比較-:compare:~
比較:comparison:~
増加-:increase:~
増分-:increment:~
減少-:decrease:~
検索取得-:retrieve::~
検索取得:retrieval::~
検索-:look up:~
移動-:move:~
単調:monotonic:~
番号:number::~
位置:position::~
方向:direction::~
抽出-:extract::~
抽出:extracted::~
走査-:traverse::~
走査:traversal::~
見出され:find され:~
見出す:find する:~
見出せ:find でき:~
	昇順:ascending order:~
始端:start::~
終端:end::~
	{key:value}:key-value
複entry:multiEntry:複 entry::複エントリ
一意:unique::~
一意な:unique::~

値取得済:got value:got 値:取得済み


	●js／IDL
連列:sequence::~::シーケンス
member::::メンバ
slot::::スロット
byte::::バイト
buffer::::バッファ
view::::ビュー
parameter::::パラメタ
index::::
scope::::スコープ
Assert:
	committing::::
crash::::クラッシュ
	crashing
instance::::インスタンス
interface::::インタフェース
list::::リスト
method::::メソッド
	null::::
obj:object:::オブジェクト
阻まれ:block され::~::ブロックされ
阻む:block する::~::ブロックする
	blocking
clone::::クローン
	cloning
snapshot::::スナップショット
collection::::コレクション
変異不可の:immutable な:~
有順序:ordered:~
配列:array:~
辞書:dictionary:::ディクショナリ
設定-:set:~
複製:copy:~
	copying
	入力:input:~

作成時:create 時:~
取得時:get 時:~
作成-:create:~
作成:creation:~
	作成ed:created:~
作成ing:creating:作成
取得子:getter:~
設定子:setter:~
	取得-:get:~
被呼出時:被 invoke 時:~
呼出時:invoke 時:呼び出し時
呼出して:invoke して:呼び出して
呼出した:invoke した:呼び出した
呼出され:invoke され:呼び出され

省略可能な:optional::~
省略可能:optional::~
省略可:optional::~
構築-:construct:~
構築:construction:~
静的:static:~
構築子:constructor:~:::コンストラクタ
構築法:constructing:~
構成子:constructs:~
投出-:throw:~
属性:attribute:~
引数:argument:~
型:type:~
識別子:identifier:~
識別-:identify:~
空:empty:~
	空でない:non-empty:~
文字列:string:~
garbage::::ガーベジ
収集-:collect:~
収集:collection:~
新たな:new:~
下層の:underlying:~
有構造:structured::~
中途完了:abrupt completion::~
文字大小区別:case-sensitive:~
符号単位:code unit:~
符号なし:unsigned:~
式:expression:~

	●
実効:effective:~
整数:integer:~
名前:name:~
名:name:~

	より古い:older:~
	古い:old:~

長さ:length:~
末尾:end:~
初期:initial:~
初期化-:initialize:~
集合:set:~
表現-:represent:~
妥当:valid:~
	妥当でない:invalid:~
文脈:context:~
言語束縛:binding:~
競合:conflict:~
	~tx間で互いに競合:merge conflicts:
directory:::ディレクトリ
	blocking:blocking:~



	●保安
証明書:certificate:~
community:::コミュニティ
privacy:::プライバシー
cross-directory:
健康診断記録:health record:~
	site-specific:
profile:::プロファイル
	差し障りないinnocuous:
ログイン:log in:~
購入:purchase:~
	純粋purely:
	晒す:~put:~
行動:action:~
	quite:
	ごく普通にあり得る:quite~possible
	責を負うresponsible:
service:::サービス
session:::セッション
追跡:tracking:~
追跡-:track:~
第三者主体:third-party:~
host:::ホスト
site:::サイト
domain:::ドメイン
client:::クライアント
risk:::リスク
	client-side
活動:activities:~
	capable:
	築く:build する:~
	id:id#1
	aware:aware#1
認証済み:authenticated:~
認証-:authenticate:~
資格証明情報:credential:~:::クレデンシャル
電子商取引:e-commerce:~
	conjunction:conjunction:~
	world:world:~
匿名:anonymous:~
	greater:greater:~
~~正確に:accuracy:~
軽減-:mitigate:~
技法:technique:~
閲覧:browsing:~
top-level:::トップレベル
制約-:restrict:~
制約:restriction:~
拒否-:deny:~
失効-:expire:~
	expiring:
	stored:stored:~
能:ability:~
	he:he:~
cookie:::クッキー
UI:user interface:UI::利用者インタフェース
	扱-:treat#2
	~~健全な疑い:healthy suspicion
	見る:view:~
権限付与-:authorize:~
保護-:protect:~
保護:protection:~
クレジットカード:credit card:~
住所:address:~
address:::アドレス

	生成元~追跡:origin-tracking:~
	取り除く:prune:~
	情報を吟味した上で決定を下せるinformed decisions~
識別情報:identifying information:~
safe-list:::安全リスト
	~whitelistに入れる:white-listing:~
blocklist:::阻止リスト
組合わす:combineする:~
信用-:trust:~
	~~提案:suggestion:
自明:trivial:~
協同-:cooperate:~
協同:cooperation:~
共通的に:よく
転用-:repurpose:~
遡及的:retroactive:~
訪問者:visitor:~
header:::ヘッダ
環境設定:configuration settings:~
復活:resurrection:~
	likely:likely:~
冗長:redundant:~
backup:::バックアップ
打破-:defeat:~

extent:~
	~~整合的に~~統合するcombine 〜 into coherent:~
sensitive:
sensitivity:
cross-directory::::クロスディレクトリ

メール:e-mail:~
機密的:confidential:~
	quite:quite:~
権限付与:authorization:~
攻撃:attack:~
	potential:potential:~
主張-:claim:~
	sure:sure:~
	URL ~path:pathname:~
	避-:avoid:~
通例の:usual:~
	scripting
保安:security:~::セキュリティ
model:::モデル
迂回-:bypass:~
	letting:letting#3
敵対的:hostile:~
	想定-:suppose:~
漏洩:leakage:~
購買:shopping:~
広告:advertising:~
文書作成:word-processing:~
作業中の:work-in-progres:~
競合企業:competing company:~

	覗き見る:examine:~
	同等に:equal に:~
危険:dangerous:~
既知の:known:~
被害者:victim:~
偽装:spoofing:~
厳格:strict:~
重要:important:~
配布-:distribute:~
本当:real:~
文書作成:word-processing:~
圧政的団体:oppressive group:~
共有-:share:~
共有:shared:~
	組み合わされconjunction:
予定表:calendar appointments:~
	即座に:promptly:~

	●仕様
API:
UA:user agent:UA
MUST_RUN:次を run しなければならない:次を走らせなければならない
targeted:
	comment:
	common:
仕様:spec:~
	~normative:normative:~
	~non-normative:non-normative:~
開発者:developer:~
言語:language:~
特色機能:feature:~
実装-:implement:~
実装:implementation:~
改訂:revision:~
履歴:history:~
付録:appendix:~
可用:available:~
定義-:define:~
期待-:expect:~
指定-:specify:~
機能性:functionality:~
影響-:affect:~
	影響する:effect:~
続行-:proceed:~
要件:requirements:~
充足-:satisfy:~
局所:local:::ローカル
	必要:need:~
	対応ing:corresponding:~
有用:useful:~
手段:means:~
	見なさ:consider さ
拘束:constraint:~
	取扱-:handle:~
取扱え:handle でき:取り扱え
取扱う:handle する:取り扱う
取扱われ:handle され:取り扱われ
	節:section:~
指針:guideline:~
図式:diagram:~
	述べら:describe さ:~
	述べる:describe する:~
適合性:conformance:~
適合-:conform:~
適合:conforming:~
適合的:conformant:適合
挙動し:behave し:ふるまわ
挙動する:behave する:ふるまう
挙動:behavior:ふるまい
	両者:both:~
用語:term:~
依存関係:dependencies:~
依拠-:rely:~
定義:definition:~
仕様:spec:~
依存-:depend:~
所与の:与えられた
	given
	欲-:desire:~
作者:author:~
施行:enforce:~
	結付-:associate:~
特定の:specific:~
特有:specific:~
	一定:constant:~
	任意の:arbitrary:~
仕組み:mechanism:~
機構:mechanism:~
	複数の:multiple:~
試み:attempt:~
試みる:attempt する:~
試みた:attempt した:~
試みら:attempt さ:~
試みて:attempt して:~
確保-:ensure:~
目的0:purpose:目的

許容-:allow:~
事例:case:~

実際の:actual:~
二番目の:second:~
特化-:specialize:~
決定-:determine:~
意味-:mean:~
推奨-:recommend:~
一般:general:~
用法:usage:~
体験:experience:~
位置付け:status:~
	複雑:complicated:~
旧来の:legacy:~
再利用:reuse:~
問題:problem:~
機会:chance:~
	容易／易く:easy:~
結付ける:associate する:結び付ける
結付けら:associate さ:結び付けら
	意図-:intend:~
検証-:verify:~
実際:actual:~
参考:informative:~
要約:summary:~
謝辞:acknowledgement:~
草案:draft:~
向上-:improve:~

違反:violation:~
違反-:violate:~
暗黙的:implicit:~
受容-:accept:~
適切:appropriate:~
	通例的に:usually:~
優位性:advantage:~
指示-:indicate:~
適用-:apply:~
通常の:normal:~
未定義の:undefined:~
観測可能:observable:~
抑制-:reduce:~
指示ing:indicating:~
制御:control:~
情報:information:~
利用者:user:~
頁:page:~
明示的:explicit:~
	則って:according:~
無視-:ignore:~
組織化-:organize:~
保証-:guarantee:~
序論:introduction:~
issue:
課題:issue:~
app:application:::アプリ
手続き:steps:~
下位手続き:substeps:~
段:step:~
設計:design:~
奨励-:encourage:~
	促す:encourage:~
導入-:introduce:~
公平さ:fairness:~
手動:manual:~
提示-:present:~
発行:publication:~
適度な:reasonable:~
単純化-:simplify:~
維持管理-:maintain:~
直接的:direct:~
要約-:summarize:~
効率的:efficient:~
探索-:searching:~
提供-:provide:~
管理:management:~
決定的:deterministic:~
algo:algorithm:::アルゴリズム
bug::::バグ
公開-:expose:~
logic::::ロジック
style::::スタイル
遂行-:perform:~
著作tool:authoring tool:著作 tool::著作ツール
出荷-:ship:~
固める:robust にする:~
考慮点:considerations:~
配備済みの:deployed:~


	●未分類
browser::::ブラウザ
platform::::プラットフォーム
script::::スクリプト
field::::フィールド
	result::::
escaping::::エスケープ処理
超過-:exceed:~
primitive:
prop:property:::プロパティ
query::::クエリ
照会:query::~::クエリ
反映-:reflect:~
processor::::プロセッサ
quota::::クォータ
	finished:
	duplicate:
発行0-:make:発行
特定0の:particular:ある特定の
access::::アクセス
	across:
	進めるadvance:
permission:
debug::::デバッグ
file::::ファイル
entry::::エントリ
disk::::ディスク
call:
clear:
code::::コード
同時並行的:concurrent:~
B-tree:::B-木::B-ツリー
関係db:relational database:::関係データベース:リレーショナルデータベース


	~~目指して:aim:~
	該当cover:
	-:concrete:~
custom::::カスタム
extreme:
item:
level:

feedback:
成長-:grow:~
区間:interval:~

message:
metadata::::メタデータ
off-line::::オフライン
提供0-:offer:提供
進捗:progress:~
support::::サポート
被support:supported:::被サポート
system::::システム
	time:
時機:timing:~
総数:total number:~
数的:numeric:~
web:
worker:

頁:page:::ページ
出自に:originate:~
pair::::ペア
永続的:persistent:~
防止-:prevent:~
	待たせて:prevent して:~
再帰-:recurse:~
報告-:report:~
文書:document:~
階層的:hierarchical:~
保持-:hold:~
記録-:record:~
単純:simple:~
構造:structure:~
管理-:manage:~
	次0の:next:次の


	zero:
	normative:
	note:

送信-:send:~
順序:order:~
	~~一定の順序で:in-order:
	書名:title:~
	著者名:author:~
	定期刊行物:magazine:~
	刊行頻度:frequency
洗練-:sophisticate:~
心臓部:heart:~
単独の:single:~
合致:match:~:::マッチ
包含-:contain:~
	close pending:close pending:~
状態:state:~
基底:base:~
現在の:current:~
高度な:advanced:~
未来:future:~
応答-:respond:~
間接的:indirect:~
内部的:internal:~
内部:internal:~

	non-numeric:non-numeric:~

関数:function:~
	再帰的:recursive:~
規則:rule:~
	正の:positive:~
	負の:negative:~
条件付きで:conditional に:~
条件:condition:~
	代入-:assign:~

自動:auto:~
階層:hierarchy:~
要求-:require:~
子:child:~
生成規則:production:~
文字:character:~
評価-:evaluate:~
固定-:fix:~
	保ち続け:keep track
却下-:reject:~
	現在:currently:~
内容:content:~
制限-:limit:~
既存の:existing:~
段落:paragraph:~

内側:inside:~

不定:indefinite:~
	高い:high:~
	access可能:accessible:~
連続的:continuous:~
要素:element:~
除外-:exclude:~

到達-:reach:~
全部的:full:~
構文解析-:parse::~::パース
自前の:own:~
能力:capabilities:~
通信-:communicate:~
	返信:communicates back
操作-:manipulate:~
付加-:append:~
許可:permission:~
提言:suggestion:~
特別な:special:~

入子に:nest:入れ子に

下位:sub:~
読込まれ:load され:読み込まれ
捜出す:locate する:捜し出す
外側:outside:~
閲覧文脈:browsing context::~


	最初の:first:~
	最後の:last:~
	存在-:exist:~
	後続の:subsequent:~
	重なって:overlapして:~
	next
	大多数のmost
	一つ以上の one or more
	成る:comprise
	より大きな:larger
	より小さな:smaller
	最も小さな:smallest
	存続する限り固定され続けるremains fixed for the life
	もたらし~lead
	同時に~at the same time
	ゆえにTo this end
	~~厳密にrigorous
	~~規定~logic
	二度:twice:~
	強い影響力を及ぼした:extremely influential in:
	例えば:for-example:~
	最も低い:lowest:~
	最も高い:highest:~
	より高い:higher:~
	大きい:high／larger
	異なる:different:~
	別の:another:~
	通:through:~
	多い:often:~
	その:that:~
	それらの:those:~
	すでに:already:~
	次の:the following:~
	例:example:~
	他の場合:otherwise:~
	他の:other:~
	二つの:two:~
	同じ:same:~
	代わりに:instead:~
	含め:including:~
	上の:above:~
	下の:below:~
	個々の:individual:~
	それに加え:additionally:~
	望-:wish:~
	各:each:~
	利用:use:~
	用立て~make use
	保-:keep:~
	別々:separate:~
	試行-:try:~
	含-:include:~
	ある種の:certain:~
	依然として:still:~
	長い:long:~
	従う:follow:~
	見よ:see:~
	除いて:except
	与-:give:~
	対応-:correspond:~
	再び:again:~
	新たに:newly:~
	結果の:resulted:~
	それら自身:themselves:~
	始-:begin:~
	後:after:~
	前:before:~
	同様に:likewise:~
	起-:happen:~
	生-:occur:~
	欠-:lack:~
	返-:return:~
	渡す:pass する
	種々の:various:~
	取得ing:getting:~
	決して:never:~
	称され:said:~
	三つの:three:~
	介:via:~
	しかしながら:however:~
	自身:itself:~
	仕方:way:~
	得-:obtain:~
	保たれ:kept:~
	この:this:~
	すべての:all:~
	示-:show:~
	示され:shown:~
	~although:
	すべて~altogether:
	~also:
	~an:
	~as-i:
	~anyone:
	~apart:
	appreciation:
	請う／請われ~ask:
辞退-:decline:~

	authoring:
	aware:
	away:
	back:
	悪化bad:
	become:
	本:book:~
	bound:
	capable:
	chain:
	~class:
	一貫する:consistent になる:~
	continue:
	continuing:

	数えるcount:
	decision:
	due:
	時間を要する:durable:
	early:
	employ:
	end:
	十分enough:
	equal:
	ever:
	部分~everything:
	ちょうどexact:
	exceeding:
	ある程度~some~extent


	false:
	~fashion:

	最後にfinally:
	follow:
	前方~forward
	片fragment:
	満たすfulfill:
	go:
	ずっとgreater:
	he:
	~~説明illustrate:
	in-order:
	in:
	infinite:
	infinity:
	~inner:
	~inspect:
	具体的には~for~instance
	やりとりinteract／interacting／interaction:
	large:
	later:
	今後の:later:~
	~~後で~later
	leading:
	left:
	letting:
	likely:

	~~対応付けmap:
	marked:
	~~合致meet:
	met:
	間に~in~the~middle:
	moreover:
	別~頁へ移動~navigating away
	neither:
	night:
	non-numeric:
	nonsupported:
	non-normative:
	once:
	逆opposite:
	option:
	options:
	outer-most:
	parameter:
	part:
	一部part of
	past:
	そのような:pattern:
	一定期間:period of time
	片piece:
	指す~point:
	pointed:
	可能possible:
	可能性／potential:
	なり得るpotentially:
	practical:
	preceding:
	prepare:
	previous:
	前回previous

	~primarily:
	主にprimary:
	process:
	処理-:process:~
	processed:

	product:

	proposed:
	put:
	publish:
	publishing:
	realize:
	~refer:
	regarding:
	関係ないunrelated:
	〜し続けremain:
	残りのremaining:
	required:
	respective:
	row:
	scenario:
	secondarily:
	series:
	いくつかの:several:
	似るsimilar:
	similarly:
	状況:situation:~
	飛ばす:skip する:
	slight:
	小さな~small:
	大きな~large
	something:
	sometime:
	~~容量space:
	speaking:
	すなわち，specifically:
	待たされるstall:
	stay:
	強くstrong:
	such:
	suffice:
	sure:
	taken:
	tell:
	thank:
	thread:
	結び付けtie:

	~~協同してact together

	top-level:
	transactionに基づくtransactional:
	true:
	unchanged:
	~undo:
	unlike:
	unpacked:
	until:
	user-specific:
	variation:
	very:
	welcome:
	全くなくてもwhatsoever:
	work-in-progres:
	wrote:
	year:
	yield:
	ものone
	総数~how many
	先ず初めにbefore proceding with rest of
	言い換えれば~in other words
	常に:always
	one and only one
	一階層~one level
	日夜~day and night
	絶え間なくone after another
	要約すると、practical result of this is



</script>


<!--%style
-->

<style>

pre[lang="en"] {
	white-space: pre-wrap;
}

._summary {
	background: #F2FDF3; /*#E9FBE9;*/
}
._summary::before {
	content: '【要約】';
	color: gray;
}


table._row > thead > tr {
	border-bottom: solid silver medium;
}
table._row > tbody > tr {
	border-bottom: solid silver thin;
}

.constant {
	text-decoration: underline;
}

i {
	color: purple;
}

.js {
	color: #006633;
}
	/* 抽象演算 */
.abstract {
	color: green;
}

ul.input-params::before {
	content: "入力：";
	display: block;
	color: gray;
	text-indent: -2em;
}

#_hierarchy td {
	text-align: center;
}

</style>

<!-- 

samp {
	white-space: nowrap;
	color: purple;
}



-->

</head>

<body>


<div style="display:none;"><input type="hidden" id="_page_config" value="" /></div>


<aside class="trans-meta">
<h1>Indexed Database API 2.0 日本語訳</h1>
<p>
<a id="_THIS_PAGE">このページ</a>
は、
<a href="http://www.w3.org/">W3C</a> により副題の日付にて <strong >編集者草案</strong>として公開された
<a id="_SPEC_URL">Indexed Database API 2.0</a>
を日本語に翻訳したものです。
<strong >この翻訳の正確性は保証されません。</strong>
この仕様の公式な文書は英語版であり、この日本語版は公式のものではありません。
【 と 】で囲まれた部分は<span class="trans-note">【訳者による注釈】</span>です。
（<a href="index.html">他のウェブ関連仕様の一覧と共通機能の詳細</a>）
</p>

<p >
更新：<time>2016-11-06</time>
（公開：<time>2015-08-06</time> ）
</p>

<p >
このページの大部分はスクリプトにより生成されています（
古いブラウザなど，一部のブラウザには対応していません：
<span id="_GENERATING"></span>）。
</p>

<p>
本文ダブルクリックで当該箇所の原文が表示されます（左下隅に各種 表示切替ボタン — CSS や DOM の対応が古いブラウザでは、一部機能しないことがあります）。
</p>

<address id="_CONTACT">　</address>

</aside>


<header>

<a href="https://www.w3.org/" id="_W3C">W3C</a>
	<hgroup>
<h1 id="title">索引付きデータベース API — Indexed Database API 2.0</h1>
<h2>2016 年 11 月 4 日付 編集者草案</h2>
	</hgroup>

<dl id="_versions">

	<dt title="This version:">このバージョン</dt>
	<dt title="Latest editor’s Draft:">編集者草案</dt>
	<dd>https://w3c.github.io/IndexedDB/</dd>

	<dt title="Previous version:">以前のバージョン</dt>
	<dd>https://www.w3.org/TR/IndexedDB/</dd>

	<dt>Feedback:</dt>
	<dd><span><a href="mailto:public-webapps@w3.org?subject=%5Bindexeddb%5D%20YOUR%20TOPIC%20HERE">public-webapps@w3.org</a> with subject line “<kbd>[indexeddb] <i>… message topic …</i></kbd>” (<a href="https://lists.w3.org/Archives/Public/public-webapps/" rel="discussion">archives</a>)</span></dd>

	<dt title="Test suite:">テスト一式</dt>
	<dd>https://github.com/w3c/web-platform-tests/tree/master/IndexedDB</dd>

	<dt title="Issue Tracking:">最新の課題</dt>
	<dd><a href="https://github.com/w3c/IndexedDB/issues/">GitHub</a></dd>
	<dd><a href="#issues-index">仕様内</a></dd>

<!--
https://github.com/w3c/IndexedDB/commits/gh-pages
 -->

	<dt title="Editors:">編集</dt>
	<dd><a href="mailto:alia@microsoft.com">Ali Alabbas</a></dd>
	<dd><a href="mailto:jsbell@google.com">Joshua Bell</a></dd>
</dl>


<small>
<a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="http://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document" rel="license">permissive document license</a> rules apply.
</small>

</header>


<div id="MAIN" style="display:none;">

	<section id="abstract">

<h2 title="Abstract">要約</h2>

<p>
この文書は、一連の~recordからなる~dbのための，~APIを定義する。
ここでの各~recordは、［
~keyと, 対応する［
単純な値, または階層的な~objを保持する
］ような何らかの値
］の組みからなる†。
加えて、~dbは，［
格納される一連の~recordたちにわたる，いくつかの索引
］も維持管理する。
~app開発者は、~APIを直接的に利用して，［
~keyにより，または索引を利用して
］，格納されている~recordを捜出す。
また、この~API上に~query言語の層を~~重ねられる。
索引付き~dbは、永続的 B-tree ~data構造を利用して実装し得る。
◎
This document defines APIs for a database of records holding simple values and hierarchical objects. Each record consists of a key and some value. Moreover, the database maintains indexes over records it stores. An application developer directly uses an API to locate records either by their key or by using an index. A query language can be layered on this API. An indexed database can be implemented using a persistent B-tree data structure.
</p>

<p class="trans-note">【†
この仕様で取り~~扱う~recordは、 CSV や`関係db$の様な平坦な~fieldの並びではない。
~recordの値である~obj（数値や文字列のような “単純な” 値は “一階層のみの~obj” と捉えられる）が主たる~data源であり、~recordの~keyは，もっぱら それらの値を~~検索したり, ~recordたちを整列するために働くものとして~~意図されている。
】</p>

	</section>
	<section id="sotd">
<h2 title="Status of this document">この文書の位置付け</h2>

<p>
<em>この節では、発行時点における…</em>
<span class="trans-note">【
以下、この節の他の内容は
<a href="w3c-common-ja.html#status" >W3C 日本語訳 共通ページ</a>
に委譲
】</span></p>
<!-- 
Status of this document

This is a public copy of the editors’ draft. It is provided for discussion only and may change at any moment. Its publication here does not imply endorsement of its contents by W3C. Don’t cite this document other than as work in progress.

Changes to this document may be tracked at https://github.com/w3c/IndexedDB.

If you wish to make comments regarding this document, please send them to this specification’s GitHub repository or (archived) public mailing list public-webapps@w3.org (see instructions). When sending e-mail, please put the text “indexeddb” in the subject, preferably like this: “[indexeddb] …summary of comment…. All comments are welcome.

This document was produced by the Web Platform Working Group.

This document was produced by a group operating under the 5 February 2004 W3C Patent Policy. W3C maintains a public list of any patent disclosures made in connection with the deliverables of the group; that page also includes instructions for disclosing a patent. An individual who has actual knowledge of a patent which the individual believes contains Essential Claim(s) must disclose the information in accordance with section 6 of the W3C Patent Policy.

This document is governed by the 1 September 2015 W3C Process Document.

-->

<p>
この文書に対する変更点は、
<a href="https://github.com/w3c/IndexedDB">https://github.com/w3c/IndexedDB</a>
にて追跡できます。
◎
Changes to this document may be tracked at https://github.com/w3c/IndexedDB.
</p>

<p>
この文書は
<a href="http://www.w3.org/WebPlatform/WG/">Web Platform Working Group</a>
により制作されました。
◎
This document was produced by the Web Platform Working Group.
</p>

</section>

<main id="MAIN0">

	<section id="introduction" class="section informative">

<h2 title="Introduction">1. 序論</h2>

~INFORMATIVE

<p>
~UAは、~web~appの~off-line~data要件を充足するため，多数の~objを局所に格納する必要がある。
`WEBSTORAGE$r は、一連の［
~keyと対応する値
］の~pairを格納するために有用ではあるが、［
~keyを~~一定の順序で検索取得する／
多数の値にわたり効率的に探索する／
一つの~keyに対し複合的な値を格納する
］方法は 提供していない。
◎
User agents need to store large numbers of objects locally in order to satisfy off-line data requirements of Web applications. [WEBSTORAGE] is useful for storing pairs of keys and their corresponding values. However, it does not provide in-order retrieval of keys, efficient searching over values, or storage of duplicate values for a key.
</p>

<p>
この仕様は、［
大多数の洗練された~query~processorの心臓部である，高度な { ~key: 値 } ~data管理
］を遂行する~APIを提供する
— ~txに基づく~dbを利用して，一連の［
~keyと（~keyごとに一つ以上の）対応する値
］を格納し，各~keyを決定的 順序で走査する手段を提供することにより。
これは、永続的 B-tree ~data構造を利用して実装されることが多い
— それは、挿入と削除に加えて，大量の~data~recordを~~一定の順序で走査するときにも効率的であると考えられているので。
◎
This specification provides a concrete API to perform advanced key-value data management that is at the heart of most sophisticated query processors. It does so by using transactional databases to store keys and their corresponding values (one or more per key), and providing a means of traversing keys in a deterministic order. This is often implemented through the use of persistent B-tree data structures that are considered efficient for insertion and deletion as well as in-order traversal of very large numbers of data records.
</p>

<aside class="example">

<p>
次の例は、~APIを利用して，`書庫^l ~dbに~accessする。
この~dbは、`保管庫$（~db内の一群の~dataを保持する単位）である `書棚^l を保持する。
この書棚には、`isbn^l 属性を~keyに用いて，一群の本が格納される。
加えて，この書棚に格納された各~obj（すなわち，本）の `書名^l に対しても，`索引$ `書名索引^l が維持管理される。
この書名索引は、本を書名でも検索できるようにする。
また、一意性の拘束（ `unique: true^js ）も施行されている。
~objの `著者名^l についても別の索引 `著者名索引^l が維持管理され，本を著者名で検索するときに利用できる。
◎
In the following example, the API is used to access a "library" database that holds books stored by their "isbn" attribute. Additionally, an index is maintained on the "title" attribute of the objects stored in the object store. This index can be used to look up books by title, and enforces a uniqueness constraint. Another index is maintained on the "author" attribute of the objects, and can be used to look up books by author.
</p>

<p>
まず、~dbへの接続を~openする。
`書庫^l ~dbが まだ存在していない場合は，新たに作成される。
~event~handlerの中で，保管庫と各~索引を作成する。
~~最後に、後続の例で利用するため，~openした接続を保存する（
`onsuccess^m ~handler内の %書庫
）。
◎
A connection to the database is opened. If the "library" database did not already exist, it is created and an event handler creates the object store and indexes. Finally, the opened connection is saved for use in subsequent examples.
</p>

<pre>
var %request = indexedDB.open(`書庫^l);

%request.onupgradeneeded = function() {
  /* <span class="comment">
書庫~dbはまだ存在しないので，保管庫と索引を作成する。
◎
The database did not previously exist, so create object stores and indexes.
</span> */
  var %書庫 = %request.result;
  var %書棚 = %書庫.createObjectStore(`書棚^l, {keyPath: `isbn^l});
  var %書名索引 = %書棚.createIndex(`書名索引^l, `書名^l, {unique: true});
  var %著者名索引 = %書棚.createIndex(`著者名索引^l, `著者名^l);

  /* <span class="comment">
初期~dataで保管庫を拡充する（索引は自動的に拡充される）。
◎
Populate with initial data.
</span> */
  %書棚.put({書名: `Quarry Memories^l, 著者名: `Fred^l, isbn: `123456^lt});
  %書棚.put({書名: `Water Buffaloes^l, 著者名: `Fred^l, isbn: `234567^lt});
  %書棚.put({書名: `Bedrock Nights^l, 著者名: `Barney^l, isbn: `345678^lt});
};

%request.onsuccess = function() {
  %書庫 = %request.result;
};</pre>

<p>
次の例は、~txを利用して~dbを拡充する。
◎
The following example populates the database using a transaction.
</p>

<pre>
var %tx = %書庫.transaction(`書棚^l, `readwrite$l);
var %書棚 = %tx.objectStore(`書棚^l);

%書棚.put({書名: `Quarry Memories^l, 著者名: `Fred^l, isbn: `123456^lt});
%書棚.put({書名: `Water Buffaloes^l, 著者名: `Fred^l, isbn: `234567^lt});
%書棚.put({書名: `Bedrock Nights^l, 著者名: `Barney^l, isbn: `345678^lt});

%tx.oncomplete = function() {
  /* <span class="comment">
すべての要請は成功し，~txは~commitされた。
◎
All requests have succeeded and the transaction has committed.
</span> */
};</pre>

<p>
次の例は、索引を利用して，~db内の単独の本を書名で検索する：
◎
The following example looks up a single book in the database by title using an index.
</p>

<pre>
var %tx = %書庫.transaction(`書棚^l, `readonly$l);
var %書棚 = %tx.objectStore(`書棚^l);
var %書名索引 = %書棚.index(`書名索引^l);

var %request = %書名索引.get(`Bedrock Nights^l);
%request.onsuccess = function() {
  var %matching = %request.result;
  if (%matching !== undefined) {
    /* <span class="comment">
合致するものが見出された。
◎
A match was found.
</span> */
    report(%matching.isbn, %matching.書名, %matching.著者名);
  } else {
    /* <span class="comment">
合致するものは見出されなかった。
◎
No match was found.
</span> */
    report(null);
  }
};</pre>

<p>
次の例は、索引と~cursorを利用して，~db内のすべての本から，著者名が合致するものを検索する：
◎
The following example looks up all books in the database by author using an index and a cursor.
</p>

<pre>
var %tx = %書庫.transaction(`書棚^l, `readonly$l);
var %書棚 = %tx.objectStore(`書棚^l);
var %著者名索引 = %書棚.index(`著者名索引^l);

var %request = %著者名索引.openCursor(<span class="typ">IDBKeyRange</span>.only(`Fred^l));
%request.onsuccess = function() {
  var %cursor = %request.result;
  if (%cursor) {
    /* <span class="comment">
合致する各~recordごとに~callされる。
◎
Called for each matching record.
</span> */
    report(%cursor.value.isbn, %cursor.value.書名, %cursor.value.著者名);
    %cursor.continue();
  } else {
    /* <span class="comment">
合致する~recordはもうない。
◎
No more matching records.
</span> */
    report(null);
  }
};</pre>

<p>
要請が失敗したときの~errorをどう取扱えるかを、次の例に示す：
◎
The following example shows how errors could be handled when a request fails.
</p>

<pre>
var %tx = %書庫.transaction(`書棚^l, `readwrite$l);
var %書棚 = %tx.objectStore(`書棚^l);
var %request = %書棚.put({書名: `Water Buffaloes^l, 著者名: `Slate^l, isbn: `987654^lt});
%request.onerror = function() {
  /* <span class="comment">
索引 `書名索引^l に対する一意性の拘束は失敗した。
◎
The uniqueness constraint of the "by_title" index failed.
</span> */
  report(%request.error);
  /* <span class="comment">
~txを中止させたくなければ，
%request.`preventDefault()$m を~callできる。
◎
Could call request.preventDefault() to prevent the transaction from aborting.
</span> */
};
%tx.onabort = function() {
  /* <span class="comment">
他の場合、失敗した要請に因り，~txは自動的に中止されることになる。
◎
Otherwise the transaction will automatically abort due the failed request.
</span> */
  report(%tx.error);
};</pre>


<p>
必要なくなったなら、~db接続は~closeしてよい。
◎
The database connection may be closed when it is no longer needed.
</p>

<pre>
%書庫.close();
</pre>

<p>
~dbは，未来に他の保管庫／索引を包含するように成長させれる。
次の例は、~openされた~dbが，要請した~versionより古かったときの取扱い方を示す。
◎
In the future, the database may have grown to contain other object stores and indexes. The following example shows one way to handle opening an older version of the database.
</p>

<pre>
var %request = indexedDB.open(`書庫^l, `3^lt); /* <span class="comment">
~version 3 を要請する。
◎
Request version 3.
</span> */

%request.onupgradeneeded = function(%event) {
  var %書庫 = %request.result;
  if (%event.oldVersion &lt; `1^lt) {
    /* <span class="comment">
~version 1 が~dbの最初の~version。
◎
Version 1 is the first version of the database.
</span> */
    var %書棚 = %書庫.createObjectStore(`書棚^l, {keyPath: `isbn^l});
    var %書名索引 = %書棚.createIndex(`書名索引^l, `書名^l, {unique: true});
    var %著者名索引 = %書棚.createIndex(`著者名索引^l, `著者名^l);
  }
  if (%event.oldVersion &lt; `2^lt) {
    /* <span class="comment">
~version 2 は、 `出版年^l で本を検索できるようにする，新たな索引を導入する。
◎
Version 2 introduces a new index of books by year.
</span> */
    var %書棚 = %request.transaction.objectStore(`書棚^l);
    var %出版年索引 = %書棚.createIndex(`出版年索引^l, `出版年^l);
  }
  if (%event.oldVersion &lt; `3^lt) {
    /* <span class="comment">
~version 3 は、 `定期刊行物^l ）のために二つの索引を伴う新たな保管庫を導入する。
◎
Version 3 introduces a new object store for magazines with two indexes.
</span> */
    var %定期刊行物 = %書庫.createObjectStore(`定期刊行物^l);
    var %出版元索引 = %定期刊行物.createIndex(`出版元索引^l, `出版元^l);
    var %刊行頻度索引 = %定期刊行物.createIndex(`刊行頻度索引^l, `刊行頻度^l);
  }
};

%request.onsuccess = function() {
  var %書庫 = %request.result; /* <span class="comment">
%書庫.`version^m は 3 になる。
◎
db.version will be 3.
</span> */
};</pre>

</aside>

	</section>
	<section id="_conventions">
<h2 class="trans-note">【この訳に固有の表記規約】</h2>


<p><small>（
この節の表記規約は、この仕様が課す要件（〜し~MUST）を集約するものでもある。
）</small></p>

<p>
この訳に利用される ~LET, ~IF, ~THROW, ~Assert 等々の意味や定義の詳細は，~SYMBOL_DEF_REFを~~参照（ ~THROW の実行制御には暗黙的な，例外の再~投出-も含められていることに注意）。
</p>

<p>
加えて、次の記法も用いる：
</p>

<dl class="def-list">
	<dt>%演算 ？</dt>
	<dd>
~algoの中で %演算 を呼出す所の末尾に付与される記号 ？ は、その %演算 から例外が投出され得ることを表す（一種の ~Assert ）。
</dd>

	<dt><dfn id="_context-object">これ°</dfn></dt>
	<dd>
各種~APIの定義における，太字で記された語 “此れ” は、
`WHATWG-DOM$r にて定義される
<a href="~DOM4#context-object">文脈~obj</a>
の略記である。
すなわち、論の対象の IDL ~interface~memberが~accessされている，当の~platform~obj（その IDL ~interfaceを実装する~obj ）, または
それを内部的に表現する抽象~obj（仕様の~modelにて定義される~obj）の~instanceを指す（この対応関係は，常に一対一なので、同一視する）。
</dd>

	<dt>↗（`~access先@）</dt>
	<dd>
~APIに公開される一部の型の~objは、ある型の抽象~objへの~accessを間接的に提供するものとして定義される（具体的には、次項 “`専属する$” の図式に示される）。
%O がそのような型の~instanceであるとき、
%O を通して~accessされる抽象~objは， %O↗ とも記される。
%O から %O↗ への対応関係は、一般に多対一になることに注意。
また、 %O に対する %O↗ が別の~instanceに変わることは，決してない。
</dd>
	<dd>
%O は、ある時点を過ぎて以降， %O↗ に~accessできなくなることもある
— %O↗ が %O よりも先に破壊された ／ %O↗ への~accessが “~closeされた” ときなど。
そうなったとしても、 %O↗ が持つ~propを反映するような，
%O が持つ IDL 属性には、その
`値を保持し続ける@
ものもある。
そのような属性は、［
%O↗ を~access先とする別の~objを通して %O↗ に変更が加えられた
］としても，元の属性~値を保つ。
</dd>

	<dt>`専属する@</dt>
	<dd>
<p>
一部の型の~obj間には、
“専属する”
という語で，その結び付けの関係が表記される。
ある型 %A の~instance %a が，別の型 %B の~instance %b に`専属する$という関係には、一般に，次が含意される：
</p>

<ul>
	<li>
%a は、自身が存在し続ける限り， %b 以外の型 %B の~instanceには`専属しない$。
</li>
	<li>
%a が存在し続ける限り， %b も存在し続ける（ %b が破壊される時点で， %a も破壊される）。
<!-- （ %a は %b への強い参照を持つ） -->
</li>
</ul>

<p>
ある~instanceに`専属する$ような~instanceは，一般に複数 存在し得る。
</p>

</dd>
	<dd>
この専属するという関係は，同じ型の~instance間で定義されたり, 循環することは決してないので、推移的に拡張して利用される。
例えば %b が また別の型 %C の~instance %c に`専属する$とき、
“%a が`専属する$ %C ~obj”
という記述は、 %c を指すことになる。
</dd>
	<dd>
<p>
次の図式に、この関係を持つ, および
上述の~accessを提供する関係を持つような，各種~objを要約する：
</p>

<table id="_hierarchy">
<caption style="font-style:italic;">
上向き矢印 “↑” を挟んだ下の~objが，上の~objに`専属する$。
斜め矢印 “↗” を挟んだ右の~objが，左の~objを通して~accessされる。
</caption>

<!-- 
<thead><tr><th>此れ（ ~interface ）
</th><th>
</th><th>此れ↗
</th></tr></thead>
-->

<tbody><tr><td><!-- 実行~文脈（ WindowOrWorkerGlobalScope$I ） -->
</td><td><!-- ↗ -->
</td><td>`生成元$

</td></tr><tr><td><!-- ↑ -->
</td><td>　
</td><td>↑

</td></tr><tr><td>`接続$（ `IDBDatabase$I ）
</td><td>↗
</td><td>`~db$

</td></tr><tr><td>↑
</td><td>　
</td><td>　

</td></tr><tr><td>`~tx$（ `IDBTransaction$I ）
</td><td>　
</td><td>↑

</td></tr><tr><td>↑
</td><td>　
</td><td>　

</td></tr><tr><td>`保管庫~handle$（ `IDBObjectStore$I ）
</td><td>↗
</td><td>`保管庫$

</td></tr><tr><td>↑
</td><td>　
</td><td>↑

</td></tr><tr><td>`索引~handle$（ `IDBIndex$I ）
</td><td>↗
</td><td>`索引$

</td></tr></tbody></table>

	</dd>
	<dd>

<p>
これらの型の~obj~instanceたちは、常に，次の可換性と一意性の要件を満たさ~MUST：
</p>

		<dl>
			<dt>`可換性@</dt>
			<dd>
<p>
上の`図式は可換$になる。
すなわち：
</p>
				<ul>
					<li>
どの`保管庫~handle$ %H に対しても†
⇒
( %H が`専属する$`接続$ ) ↗ ~EQ
( %H↗ が`専属する$`~db$ )
</li>
					<li>
どの`索引~handle$ %H に対しても†
⇒
( %H が`専属する$`保管庫~handle$ ) ↗ ~EQ ( %H↗ が`専属する$`保管庫$ )
</li>
				</ul>
			</dd>

			<dt>`一意性@</dt>
			<dd>
二つの`保管庫~handle$（または二つの`索引~handle$）
%H1, %H2 が与えられたとき†
⇒
［
%H1↗, %H2↗ は，同じ~instanceに`専属する$
］~AND［
%H1↗ ~EQ %H2↗ 
］ならば，
%H1 ~EQ %H2
になる。
</dd>
		</dl>

<p>†
ここで、 %H↗, %H1↗, %H2↗ は破壊されていないとする。
</p>

	</dd>
	<dd>
所与の型の~obj~instanceが［
作成される／取得される
］ときに［
どの~instanceに`専属する$, あるいは
どの~instanceを`~access先$にする
］ようにされるか，については、上述の要件を満たすように，当の~objを［
作成する／取得する
］~APIの記述にて定義される。
</dd>

	<dt>ε</dt>
	<dd>

<p>
記号 ε は、存在しないことを表す，他のいかなる値とも異なる仮想の定数~値である：
</p>

<ul>
	<li>
各種~手続きの引数がとる値 ε は、その手続きの呼出時に，引数が省略された（または 手続きの引数に明示的に ε が渡された）ことを表す。
</li>
	<li>
<p>
各種~API~methodの引数のうち，［
WebIDL `WEBIDL$r において、省略-時には，特殊~値 “missing” と解釈される引数
］がとる値 ε は、その~methodの呼出時に，引数が省略されたことを表す
— 具体的には、 IDL にて次の様に定義された引数：
</p>

		<ul>
			<li>
<a href="~WEBIDL#dfn-optional-argument" >省略可能</a>（ "`optional^c" が付与されている）~AND
</li>
			<li>
<a href="~WEBIDL#dfn-optional-argument-default-value">既定~値</a>を持たない（ "<code>=%既定~値</code>" が付与されていない）~AND

</li>
			<li>
<a href="~WEBIDL#dfn-dictionary">辞書~型</a>でない~AND
</li>
			<li>
（この仕様には現れないが，）
<a href="~WEBIDL#dfn-variadic">可変個</a>でない（ "`...^c" が付与されていない）
</li>
		</ul>

<p>
ECMAScript `undefined^js 値がこの種の引数に明示的に渡された場合、
WebIDL の~~規定に従って，省略されたものと見なされる（したがって ε になる）。
他の引数に対する `undefined^js は、［
既定~値があれば その値 ／
無ければ `undefined^js を表現する特別な IDL object 値
］に解釈されることになる（したがって ε でない）。

省略可能でない引数が省略された場合、
WebIDL の~~規定に従って，単に `TypeError$js が投出される。
省略可能な辞書~型の引数が省略された場合、その型の空の辞書が指定されたものと見なされる。
</p>
	</li>
	<li>
<p>
他の所では，単に存在しないことを表す。
例えば：
</p>

		<ul>
			<li>
ある~prop %x を持つこともあれば持たないこともある抽象~obj %Y に対し，［
%Y の %x  ~EQ ε
］という記述は、［
%Y は %x を持たない
］ことを意味する。
</li>
			<li>
所与の条件を満たす何かとして定義されたものは、そのような条件を満たすものが存在しないときには、値 ε をとる（例えば、与えられた~listの “最初の要素” として定義された変数は、~listが空ならば値 ε をとる）。
</li>
<!-- 
			<li>
手続きから値が返されなかった場合の結果は ε になる。
~algoの中では，明示的に
“~RET ε”
と記される。
</li>
 -->
		</ul>
	</li>
</ul>
	</dd>
	<dd><small>（
この記号を導入した目的は、~APIに現れるふるまいと内部処理~modelとの境界を明確化すること，および 記述を形式化して簡潔に記すことにある。
）</small></dd>

</dl>


	</section>
	<section id="constructs">
<h2 title="Constructs">2. 各種~構成子</h2>

<p>
`整列済み~list@
とは、包含されている文字列たちが符号単位の昇順で整列されている
`DOMStringList$I である。
◎
A sorted list is a DOMStringList containing strings sorted in ascending order by code unit.
</p>

		<section id="database-concept">
<h3 title="Database">2.1. ~db</h3>

<p>
`~db$の`生成元$は、
`文書$／ `~worker$
の`生成元$と同じである。
各`生成元$には， 0 個以上の~dbの集合が結付けられる
— `~db$は，その生成元に`専属する$。
◎
A database’s origin is the same as the origin of the document or worker. Each origin has an associated set of databases.
</p>

<p class="note">注記：
~dbの`生成元$は、
`Document$I の `domain$m が変更されても影響されない。
◎
 The database origin is not affected by changes to the Document's domain.
</p>

<p>
各
`~db@
は，自身に格納される~dataを保持する， 0 個~以上の`保管庫$からなる。
`~db$は、次のものを持つ：
◎
Each origin has an associated set of databases. A database has zero or more object stores which hold the data stored in the database.
</p>

<dl>
	<dt>`名前@db</dt>
	<dd>
特定の`生成元$の中で，`~db$を一意に識別する名前。
空~文字列も含め，どのような文字列~値にもなり得る。
また、~dbが存続する間 変わらない。
名前は常に， 16-bit 符号単位として文字大小区別で比較される。
実装は、どのような名前も~supportし~MUST。
◎
A database has a name which identifies it within a specific origin. The name can be any string value, including the empty string, and stays constant for the lifetime of the database. Database names are always compared in a case-sensitive manner, as opaque sequences of 16-bit code units. Implementations must support all names.
</dd>
	<dd class="note">注記：
実装は、利用する蓄積~機構が任意の名前を取扱えない場合は、~escapingに類する仕組みを利用して，提供された~db名を自身が取扱える名前に~~対応付け~MUST。
◎
If an implementation uses a storage mechanism which can’t handle arbitrary database names, the implementation must use an escaping mechanism or something similar to map the provided name to a name that it can handle.
</dd>
	<dd class="trans-note">【
過去にどの名前の~dbを作成したか調べる~APIは（現時点では）用意されてない（
<a href="~IDBISSUES/28">issue 31</a>
）。
名前を忘れると不味いことになる。
逆に言えば、利用者~scriptは，~siteからわからないように独自の~dbを作成できることになる。
】</dd>

	<dt>`~version@db</dt>
	<dd>
~dbの~versionを表現する非負~整数。
~db作成時の`~version$dbは， 0 である。
◎
A database has a version. When a database is first created, its version is 0 (zero).
</dd>
	<dd class="trans-note">【
~dbの作成時には，自動的に`昇格~tx$が生じるので、実質的には 1 （以上）として公開される — そのときに~errorが生じない限り。
】</dd>
	<dd class="note">注記：
`~db$が同時に持ち得る~versionは一つだけである
— 同時に複数の~versionを持つような~dbは存在し得ない。
~versionは、`昇格~tx$を通してのみ変更し得る。
◎
Each database has one version at a time; a database can’t exist in multiple versions at once. The only way to change the version is using an upgrade transaction.
</dd>

</dl>

			<section id="database-connection">
<h5 title="Database Connection">2.1.1. ~db接続</h5>

<p>
~scriptが`~db$と直接的にやりとりすることはない。
代わりに
`接続@
（ connection ）を介して間接的に~accessする。
`接続$を利用すれば，`~db$の~objたちを操作できる。
それはまた、その`~db$に対する`~tx$を得る唯一の仕方である
◎
Script does not interact with databases directly. Instead, script has indirect access via a connection. A connection object can be used to manipulate the objects of that database. It is also the only way to obtain a transaction for that database.
</p>

<p class="trans-note">【
この訳では、 `接続$ %接続 の`~access先$の`~db$を %接続↗ とも記す。
】</p>

<p>
`接続$は，`~db$を~openすることにより作成される。
所与の`~db$を~access先とする，複数の`接続$が同時にあって~MAY。
各 `接続$ %接続 には、次のものが結付けられる（括弧内は、`接続$を表現する `IDBDatabase!I ~interfaceの，対応する~member ）：
◎
The act of opening a database creates a connection. There may be multiple connections to a given database at any given time.
</p>

<dl>
<!-- 
	<dt>名前 （ name$m ）</dt>
	<dd>
~openした~dbの名前$と同じであるが、接続$は，~dbが削除されようが その名前を保持し続ける。
</dd>
 -->

	<dt>`~version@Cn （ `version$m ）</dt>
	<dd>
作成時に設定され、それ以降，変わらない。
ただし、 %接続 に`専属の昇格~tx$が中止された場合には，`~db$の元の~versionに戻される。
%接続 が`~close$されて以降は変化しない
<span class="trans-note">【
より詳細には、 %接続 に`専属の昇格~tx$が`終了-$して以降は
】</span>
。
◎
A connection has a version, which is set when the connection is created. It remains constant for the lifetime of the connection unless an upgrade is aborted, in which case it is set to the previous version of the database. Once the connection is closed the version does not change.
</dd>

	<dt>`状態@Cn</dt>
	<dd>
%接続 の`状態$Cnは［
`~open中@i
→
`~close待ち@i
→
`~close済み@i
］の順に推移する。
後戻りすることはない。
◎
Each connection has a close pending flag which is initially unset.
</dd>
	<dd class="trans-note">【
この “状態” は，原文では
“close pending flag（ ~close待ち~flag ）”
という（上の `~open中$i と `~close待ち$i を区別する）~flag値で表現されているが、原文の語
“open”, “close pending”, “closed”
と状態遷移との対応関係を明瞭にするため，この訳では上のような定義に代えている（ “後戻りしない” もこの訳による補完）。
】</dd>
	<dd>
<p>
状態が `~close済み$i になった %接続 は
<dfn>~closeされた</dfn>
ともいう（そのようにする試みを<dfn>~closeする</dfn>という）。
%接続 は、次のときに，`~close$され得る／させれる：
</p>

<ul>
	<li>
%接続 は、それを作成した実行~文脈が破壊された場合には（例えば、利用者が別~頁へ~~移動したことに因り），`~close$される。
</li>
	<li>
`~db接続を~close$する手続きを利用すれば、 %接続 を明示的に`~close$させれる。
</li>
	<li id="_exceptional-close">
<p>
%接続 は、例外的な状況でも~UAにより~closeされることがある
— 例えば、~file~systemへの~accessを失ったとき, ~permission変更, 生成元の蓄積が~clearされたことに因り。
これが生じた場合、~UAは次を入力に
`~db接続を~close$し~MUST
⇒
%接続 ~SET %接続；<br />
%強制~flag ~SET ~ON
</p>

<p class="note">🚧
これは、この版による新規の挙動。
Chrome 31 と Firefox 50 で~supportされている。
🚧
◎
This behavior is new in this edition. It is supported in Chrome 31 and Firefox 50.
</p>
	</li>
</ul>

◎
When a connection is initially created it is in opened state. The connection can be closed through several means. If the execution context where the connection was created is destroyed (for example due to the user navigating away from that page), the connection is closed. The connection can also be closed explicitly using the steps for closing a database connection. When the connection is closed the close pending flag is always set if it hasn’t already been.
◎
A connection may be closed by a user agent in exceptional circumstances, for example due to loss of access to the file system, a permission change, or clearing of the origin’s storage. If this occurs the user agent must run the steps for closing a database connection with the connection and with the forced flag set.
</dd>

	<dt>`保管庫~集合@Cn （ `objectStoreNames$m ）</dt>
	<dd>
%接続 の作成時に， %接続↗ に`専属する$`保管庫$たちの集合に初期化される。
この集合の内容は、 %接続 に`専属の昇格~tx$が`稼働中$の間を除いて，一定であり続ける。
◎
A connection has an object store set, which is initialized to the set of object stores in the associated database when the connection is created. The contents of the set will remain constant except when an upgrade transaction is running.
</dd>

</dl>

<p>
`接続$の`親~標的を取得-$する~algoは、 ~NULL を返す。
◎
A connection’s get the parent algorithm returns null.
</p>

			</section>
		</section>
		<section id="object-store-concept">

<h3 title="Object Store">2.2. 保管庫</h3>

<p>
`保管庫@
（ object store ）が、`~db$に~dataを格納するための，主たる蓄積~機構である。
◎
An object store is the primary storage mechanism for storing data in a database.
</p>

<p>
どの`保管庫$も，ある`~db$に`専属する$。
`~db$に専属する`保管庫$の集合は、`昇格~tx$を利用することを通して
— すなわち，`upgradeneeded$et ~eventに呼応して —
のみ変更できる。
新たな~dbが作成された時点では，それに`専属する$`保管庫$はない。
◎
Each database has a set of object stores. The set of object stores can be changed, but only using an upgrade transaction, i.e. in response to an upgradeneeded event. When a new database is created it doesn’t contain any object stores.
</p>

<p>
各 `保管庫$ %保管庫 は、次のものを持つ（括弧内は、保管庫を`~access先$とする `IDBObjectStore!I ~objの対応する~member）：
</p>

<dl>
	<dt>`~record~list@Os</dt>
	<dd>
%保管庫 内に格納される`~record$の~listを保持する。
各
`~record@
は、［
`~key$, および`値$
］からなる。
この~listは、~keyの昇順により整列される。
同じ保管庫~内で，複数の~recordが`等しい$~keyを持つことは、決してない。
◎
An object store has a list of records which hold the data stored in the object store. Each record consists of a key and a value. The list is sorted according to key in ascending order. There can never be multiple records in a given object store with the same key.
</dd>
	<dd class="trans-note">【
この訳では、所与の ［
`~key$ %~key, `値$ %値
］を持つ`~record$を
｛ %~key ： %値 ｝
とも表記する。
】</dd>

	<dt>`名前@Os （ `name$m ）</dt>
	<dd>
空~文字列も含め，どのような文字列~値もとり得る。
名前は、どの時点においても， %保管庫 が`専属する$`~db$に`専属する$`保管庫$たちの中で一意になる。
名前は常に， 16-bit 符号単位として文字大小区別で比較される。
◎
An object store has a name. The name can be any string value, including the empty string. At any one time, the name is unique within the database to which it belongs. Object store names are always compared in a case-sensitive manner, as opaque sequences of 16-bit code units.
</dd>

	<dt>`~key~path@Os （ `keyPath$m ）</dt>
	<dd>
`妥当な~key~path$, または ε 。
%保管庫 の作成時に設定され、それ以降（ ε かどうかも含め）変わらない。
`~key~path$Osが非 ε であるとき、
“保管庫は~key~pathを持つ”
とも記される。
◎
An object store optionally has a key path. If the object store has a key path it is said to use in-line keys. Otherwise it is said to use out-of-line keys.
</dd>
	<dd class="trans-note">【
原文では、`~key~path$Osが非 ε であることを
“<dfn id="dfn-in-line-keys">use in-line keys</dfn>” ／
ε であることを
“<dfn id="dfn-out-of-line-keys">use out-of-line keys</dfn>”
］という句で定義しているが、この訳では，これらの句は<strong>利用せず</strong>，単に “持つ（非 ε ）／持たない（ε）” で区別する。
】</dd>
	<dd class="trans-note">【
保管庫の~key~pathは［
空~文字列／ ~SeqDS 値
］をとり得ない。
】</dd>

	<dt>`~key生成器$</dt>
	<dd>
%保管庫 が~key生成器を持つかどうか（ `autoIncrement$m ）は、 %保管庫 の作成時に設定され，それ以降 変わらない。
◎
An object store optionally has a key generator.
</dd>
</dl>


<p>
`保管庫$は、次のいずれかの~sourceから~recordの`~key$を導出できる。
◎
An object store can derive a key for a record from one of three sources:
</p>

<p class="trans-note">【
すなわち，`~record~list$Osは、外部から与えられる一連の値から，一連の［
~record｛ 導出される~key ： 値 ｝
］で拡充される。
】</p>

<ul>
	<li>
~keyが必要になる度に，単調に増加する番号による~keyを`~key生成器$から自動的に生成する。
◎
A key generator. A key generator generates a monotonically increasing numbers every time a key is needed.
</li>
	<li>
所与の値から，`~key~path$Os用いて`~keyを抽出-$する。
◎
Keys can be derived via a key path.
</li>
	<li>
保管庫に値を格納するときに，明示的に
`すなわち，格納する~API~methodの引数にて^tnote
~keyを指定する。
◎
Keys can also be explicitly specified when a value is stored in the object store.
</li>
</ul>

			<section id="object-store-handle">
<h5 title="Object Store Handle">2.2.1. 保管庫~handle</h5>

<p>
~scriptが`保管庫$と直接的にやりとりすることはない。
代わりに，ある`~tx$の中で
`保管庫~handle@
を介して間接的に~accessする。
◎
Script does not interact with object stores directly. Instead, within a transaction, script has indirect access via an object store handle.
</p>

<p>
各 `保管庫~handle$ %H には、次のものが結付けられる（括弧内は、対応する `IDBObjectStore!I ~interface~member）：
◎
↓</p>

<dl>
	<dt>`保管庫@OsH</dt>
	<dd>
%H の`~access先$ `保管庫$。
<span class="trans-note">【
この訳では、 もっぱら %H↗ と記す。
】</span>
◎
↓</dd>

	<dt>`~tx@OsH（ `transaction$m ）</dt>
	<dd>
%H が`専属する$`~tx$。
%H の［
取得時／作成時
］に，`可換性$と`一意性$の要件が満たされるように設定される。
◎
An object store handle has an associated object store and an associated transaction. Multiple handles may be associated with the same object store in different transactions, but there must be only one object store handle associated with a particular object store within a transaction.
</dd>
	<dt>`索引~集合@OsH（ `indexNames$m ）</dt>
	<dd>
%H の作成時に，［
%H↗ に`専属する$`索引$たちからなる集合
］に初期化される。
この集合の内容は、 %H が`専属する$~txが［
`昇格~tx$であって, `稼働中$でもある
］ときを除いて，一定であり続ける。
◎
An object store handle has an index set, which is initialized to the set of indexes that reference the associated object store when the object store handle is created. The contents of the set will remain constant except when an upgrade transaction is running.
</dd>
	<dt>`名前@OsH （ `name$m ）</dt>
	<dd>
%H の作成時に %H↗ の`名前$Osに初期化される。
この名前は、 %H が`専属する$~txが［
`昇格~tx$であって, `稼働中$でもある
］ときを除いて，一定であり続ける。
◎
An object store handle has a name, which is initialized to the name of the associated object store when the object store handle is created. The name will remain constant except when an upgrade transaction is running.
</dd>
</dl>

			</section>
		</section>

		<section id="value-construct">
<h3 title="Values">2.3. 値</h3>

<div >
<p>
各~recordには
`値@
が結付けられる。
~UAは、［
`有構造~clone~algo$ `HTML$r により~supportされる，どのような ECMAScript 値 `ECMA-262$r
］も~supportし~MUST。
これには、少なくとも次のものが含まれる：
</p>

<ul><li>`String$js などの単純~型の~primitive値
</li><li>`Date$js
</li><li>`Object$js
</li><li>`Array$js
</li><li>`File$I
</li><li>`Blob$I
</li><li>`ImageData$I
</li></ul>

<p >
等々。
~recordの`値$は、参照~渡しではなく，値~渡しにより［
格納される／検索取得される
］。
［
格納-時に渡した値／検索取得して得られた値
］が後で変更されても、~db内に格納されている~recordには影響しない。
</p>

◎
Each record is associated with a value. User agents must support any ECMAScript [ECMA-262] value supported by the structured clone algorithm [HTML]. This includes simple types such as String primitive values and Date objects as well as Object and Array instances, File objects, Blob objects, ImageData objects, and so on. Record values are stored and retrieved by value rather than by reference; later changes to a value have no effect on the record stored in the database.
</div>

		</section>
		<section id="key-construct">
<h3 title="Keys">2.4. ~key</h3>


<p>
索引付き~db内に格納されている`~record$たちを効率的に検索取得するため、各`~record$は，それぞれの
`~key@
に則って組織化される。
◎
In order to efficiently retrieve records stored in an indexed database, each record is organized according to its key.
</p>


<p>
各 `~key$は次のものを持つ：
</p>

<dl>
	<dt>`種別@key</dt>
	<dd>
次のいずれか：
`number@i ／ `date@i ／ `string@i ／ `binary@i ／ `array@i
◎
A key has an associated type which is one of: number, date, string, binary, or array.
</dd>
	<dd class="note">🚧
`binary$i はこの版による新規追加。
Firefox 51 にて~supportされる。
🚧
◎
🚧 Binary keys are new in this edition. They will be supported in Firefox 51. 🚧
</dd>

	<dt>`値@key</dt>
	<dd>
<p>
~keyの`種別$keyに応じて，次の型の値をとる：
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dt>`date$i</dt>
			<dd>
WebIDL `unrestricted double$I 型
</dd>
			<dt>`string$i</dt>
			<dd>
WebIDL ~DS型
</dd>
			<dt>`binary$i</dt>
			<dd>
WebIDL `octet$I 型~値の~list
</dd>
			<dt>`array$i</dt>
			<dd>
（種別 `array$i のものも含め，）他の`~key$からなる~list
</dd>
		</dl>
◎
A key also has an associated value, which will be either: an unrestricted double if type is number or date, a DOMString if type is string, a list of octets if type is binary, or a list of other keys if type is array.
	</dd>
</dl>

<p>
ECMAScript `ECMA-262$r 値は、`~keyへ変換-$する手続きに従って`~key$に変換される。
◎
An ECMAScript [ECMA-262] value can be converted to a key by following the steps to convert a value to a key.
</p>

<div class="note">
<p>
次のいずれかの ECMAScript 型が，~keyとして妥当になる：
◎
The following ECMAScript types are valid keys:
</p>

<ul>
	<li>
`NaN^js 以外の `Number$js ~primitive値。
`Infinity^js, `-Infinity^js も含まれる。
◎
Number primitive values, except NaN. This includes Infinity and -Infinity.
</li>
	<li>
`Date$js ~objであって，その
`DateValue^sl 内部~slotは `NaN^js でないもの。
◎
Date objects, except where the [[DateValue]] internal slot is NaN.
</li>
	<li>
`String$js ~primitive値。
◎
String primitive values.
</li>
	<li>
各種 `~buffer~source型$ 値。
（ `ArrayBuffer$js ~objや, `Uint8Array$js などの~buffer~view）。
◎
ArrayBuffer objects (or views on buffers such as Uint8Array).
</li>
	<li>
`Array$js ~objであって、［
配列~内の どの~itemも定義されていて，~keyとして妥当である
］, かつ［
（直接的にも間接的にも）自身を包含していない
］もの。
特に，空の配列は妥当である。
配列は，他の配列を包含し得る。
◎
Array objects, where every item is defined, is itself a valid key, and does not directly or indirectly contain itself. This includes empty arrays. Arrays may contain other arrays.
</li>
</ul>

<p>
他の ECMAScript 値を`~key$に変換しようと試みても失敗することになる。
◎
Attempting to convert other ECMAScript values to a key will fail.
</p>

</div>


<p>
`種別$key `array$i の`~key$を特に
`配列~key@
という。
`配列~key$の`値$key ~listの各~memberを
`下位key@
という。
◎
An array key is a key with type array. The subkeys of an array key are the members of the array key’s value list.
</p>

<p>
二つの`~key$ %a, %b を
`比較-@key
する関数
`Cmp$( %a, %b ) は、次で定義される：
◎
To compare two keys a and b, run these steps:
</p>

<ol>
	<li>
<p >
`~key$の各 `種別$key 間の大小関係を［
`number$i ~LT `date$i ~LT `string$i ~LT `binary$i ~LT `array$i
］と定義する下で：
</p>
		<ol>
			<li>
~IF ［
%a の`種別$key ~GT %b の`種別$key
］
⇒
~RET 1
</li>
			<li>
~IF ［
%a の`種別$key ~LT %b の`種別$key
］
⇒
~RET −1
</li>
		</ol>
◎
Let ta be the type of a.
◎
Let tb be the type of b.
◎
If ta is array and tb is binary, string, date or number, return 1.
◎
If tb is array and ta is binary, string, date or number, return -1.
◎
If ta is binary and tb is string, date or number, return 1.
◎
If tb is binary and ta is string, date or number, return -1.
◎
If ta is string and tb is date or number, return 1.
◎
If tb is string and ta is date or number, return -1.
◎
If ta is date and tb is number, return 1.
◎
If tb is date and ta is number, return -1.
◎
Assert: ta and tb are equal.
</li>
	<li>
%va ~LET %a の`値$key
◎
Let va be the value of a.
</li>
	<li>
%vb ~LET %b の`値$key
◎
Let vb be the value of b.
</li>
	<li>
<p>
%a の`種別$keyに応じて：
◎
Switch on ta:
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dt>`date$i</dt>
			<dd>
				<ol>
					<li>
~IF［
%va ~GT %vb
］
⇒
~RET 1
◎
If va is greater than vb, then return 1.
</li>
					<li>
~IF［
%va ~LT %vb
］
⇒
~RET −1
◎
If va is less than vb, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`string$i</dt>
			<dd>
				<ol>
					<li>
<p>
［
0 ~LTE %i ~LT min ( %va の長さ, %vb の長さ ) 
］なる~EACH( 整数 %i ) に対し，昇順に
：
◎
Let length be the lesser of va’s length and vb’s length.
◎
Let i be 0.
◎
While i is less than length, run these substeps:
</p>
						<ol>
							<li>
%u ~LET %va の~index %i の符号単位
◎
Let u be the code unit of va at index i.
</li>
							<li>
%v ~LET %vb の~index %i の符号単位
◎
Let v be the code unit of vb at index i.
</li>
							<li>
~IF［
%u ~GT %v
］
⇒
~RET 1
◎
If u is greater than v then return 1
</li>
							<li>
~IF［
%u ~LT %v
］
⇒
~RET −1
◎
If u is less than v then return -1
◎
Increase i by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%va の長さ ~GT %vb の長さ
］
⇒
~RET 1
◎
If va’s length is greater than vb’s length, then return 1.
</li>
					<li>
~IF［
%va の長さ ~LT %vb の長さ
］
⇒
~RET −1
◎
If va’s length is less than vb’s length, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>

			<dt>`binary$i</dt>
			<dd>
				<ol>
					<li>
<p>
［
0 ~LTE %i ~LT min ( %va の長さ, %vb の長さ ) 
］なる~EACH( 整数 %i ) に対し，昇順に：
◎
Let length be the lesser of va’s length and vb’s length.
◎
Let i be 0.
◎
While i is less than length, run these substeps:
</p>
						<ol>
							<li>
%u ~LET %va の~index %i の `octet$I
◎
Let u be the octet in va at index i.
</li>
							<li>
%v ~LET %vb の~index %i の `octet$I
◎
Let v be the octet in vb at index i.
</li>
							<li>
~IF［
%u ~GT %v
］
⇒
~RET 1
◎
If u is greater than v then return 1
</li>
							<li>
~IF［
%u ~LT %v
］
⇒
~RET −1
◎
If u is less than v then return -1
◎
Increase i by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%va の長さ ~GT %vb の長さ
］
⇒
~RET 1
◎
If va’s length is greater than vb’s length, then return 1.
</li>
					<li>
~IF［
%va の長さ ~LT %vb の長さ
］
⇒
~RET −1
◎
If va’s length is less than vb’s length, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>


			<dt>`array$i</dt>
			<dd>
				<ol>
					<li>
<p>
［
0 ~LTE %i ~LT min ( %va の長さ, %vb の長さ ) 
］なる~EACH( 整数 %i ) に対し，昇順に
◎
Let length be the lesser of va’s length and vb’s length.
◎
Let i be 0.
◎
While i is less than length, run these substeps:
</p>
						<ol>
							<li>
%u ~LET %va 内の~index %i の`~key$
◎
Let u be the key in va at index i.
</li>
							<li>
%v ~LET %vb 内の~index %i の`~key$
◎
Let v be the key in vb at index i.
</li>
							<li>
%c ~LET `Cmp$( %u, %v )
◎
Let c be the result of recursively running the steps to compare two keys with u and v.
</li>
							<li>
~IF［
%c ~NEQ 0
］
⇒
~RET %c
◎
If c is not 0, return c.
◎
Increase i by 1.
</li>
						</ol>
					</li>
					<li>
~IF［
%va の長さ ~GT %vb の長さ
］
⇒
~RET 1
◎
If va’s length is greater than vb’s length, then return 1.
</li>
					<li>
~IF［
%va の長さ ~LT %vb の長さ
］
⇒
~RET −1
◎
If va’s length is less than vb’s length, then return -1.
</li>
					<li>
~RET 0
◎
Return 0.
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>

<p>
二つの`~key$ %a, %b の大小関係は、 `Cmp$( %a, %b ) の結果に応じて：
</p>

<dl class="switch">
	<dt>1 の場合</dt>
	<dd>
%a は %b
`より大きい@
とされる。
◎
The key a is greater than the key b if the result of running the steps to compare two keys with a and b is 1.
</dd>

	<dt>−1 の場合</dt>
	<dd>
%a は %b
`より小さい@
とされる。
◎
The key a is less than the key b if the result of running the steps to compare two keys with a and b is -1.
</dd>

	<dt>0 の場合</dt>
	<dd>
%a は %b に
`等しい@
とされる。
◎
The key a is equal to the key b if the result of running the steps to compare two keys with a and b is 0.
</dd>

</dl>

<p class="note">注記：
上の規則の結果として，負の `Infinity^js が， `~key$がとり得る最小の値になる。
<!-- 
種別$key 間の大小関係は［
数値 ~LT 日付 ~LT 文字列 ~LT ~binary ~LT 配列
］の順に大きくなる。
-->
最大の`~key$値は存在しない
— いかなる`配列~key$に対しても、その末尾に新たな`~key$を付加した結果の配列は，より大きくなるので。
◎
As a result of the above rules, negative infinity is the lowest possible value for a key. Number keys are less than date keys. Date keys are less than string keys. String keys are less than binary keys. Binary keys are less than array keys. There is no highest possible key value. This is because an array of any candidate highest key followed by another key is even higher.
</p>

<p class="note">注記：
種別 `binary$i の`~key$を成す各 `octet$I 値は、符号なし（範囲 [0, 255] ）として比較される。
◎
Members of binary keys are compared as unsigned octet values (in the range [0, 255]) rather than signed bytes (in the range [-128, 127]).
</p>

<p>
この訳では、表記
“<dfn id="_key_comparison">%記号<sub>key</sub></dfn>”
を用いて、次を表すことにする：
</p>

<ul ><li>二つの`~key$ %a, %b の`比較-$key
</li><li>二つの`~key$~pair %p ~EQ ( %a1, %a2 ), %q ~EQ ( %b1, %b2 ) の比較-†
</li><li>`~key$ %k が`~key範囲$ %R に`入る$かどうか
</li><li>`~key$ %k が`~key$の集合 %K に含まれるかどうか
</li></ul>


<table class="_row"><thead><tr><th>表記
</th><th>定義
</th></tr></thead>

<tbody><tr><th style="min-width: 7em;">%a ~GT~cmpkey %b
</th><td>%a は %b `より大きい$

</td></tr><tr><th>%a ~LT~cmpkey %b
</th><td>%a は %b `より小さい$

</td></tr><tr><th>%a ~EQ~cmpkey %b
</th><td>%a は %b に`等しい$

</td></tr><tr><th>%a ~GTE~cmpkey %b
</th><td>
［
%a ~GT~cmpkey %b
］~OR［
%a ~EQ~cmpkey %b
］

</td></tr><tr><th>%a ~LTE~cmpkey %b
</th><td>
［
%a ~LT~cmpkey %b
］~OR［
%a ~EQ~cmpkey %b
］

</td></tr><tr><th>%p ~GT~cmpkey %q
</th><td>
［
%a1 は %b1 `より大きい$
］~OR［［
%a1 は %b1 に`等しい$
］~AND［
%a2 は %b2 `より大きい$
］］

</td></tr><tr><th>%p ~LT~cmpkey %q
</th><td>
［
%a1 は %b1 `より小さい$
］~OR［［
%a1 は %b1 に`等しい$
］~AND［
%a2 は %b2 `より小さい$
］］

</td></tr><tr><th>%p ~EQ~cmpkey %q
</th><td>
［
%a1 は %b1 に`等しい$
］~AND［
%a2 は %b2 に`等しい$
］

</td></tr><tr><th>%p ~GTE~cmpkey %q
</th><td>
［
%p ~GT~cmpkey %q
］~OR［
%p ~EQ~cmpkey %q
］

</td></tr><tr><th>%p ~LTE~cmpkey %q
</th><td>
［
%p ~LT~cmpkey %q
］~OR［
%p ~EQ~cmpkey %q
］


</td></tr><tr><th>%k ~IN~cmpkey %R
</th><td>%k は %R に`入る$

</td></tr><tr><th>%k ~NIN~cmpkey %R
</th><td>%k ~IN~cmpkey %R の否定

</td></tr><tr><th>%k ~IN~cmpkey %K
</th><td>ある %key ~IN %K に対し， %k ~EQ~cmpkey %key

</td></tr><tr><th>%k ~NIN~cmpkey %K
</th><td>%k ~IN~cmpkey %K の否定

</td></tr></tbody></table>

<p >†
`~key$~pairの比較は、簡潔に記すための，この訳による追加の定義であり、もっぱら，`索引$の~record（または，［
それを意図して, あるいは それとの比較を意図して
］与えられる~key値~pair）を比較するときに用いられる。
</p>


		</section>
		<section id="key-path-construct">

<h3 title="Key Path">2.5. ~key~path</h3>

<p>
`~key~path@
は~DS型，または~SeqDS型であり、`値$から`~key$を抽出する方法を定義する。
次のいずれかが
`妥当な~key~path@
とされる：
◎
A key path is a DOMString or sequence&lt;DOMString&gt; that defines how to extract a key from a value. A valid key path is one of:
</p>

<ul>
	<li>
空の~DS値
◎
An empty DOMString.
</li>
	<li>
`識別子@
— すなわち，
`ECMA-262$r の `IdentifierName$js 生成規則に合致する~DS値
◎
An identifier, which is a DOMString matching the IdentifierName production from the ECMAScript Language Specification [ECMA-262].
</li>
	<li>
複数の`識別子$を~PERIODで~~区切って~~連結して得られる，~DS値
◎
A DOMString consisting of two or more identifiers separated by periods (ASCII character code 46, U+002E FULL STOP).
</li>
	<li>
上の要件に適合する文字列のみを包含するような，空でない ~SeqDS 型~値
◎
A non-empty sequence&lt;DOMString&gt; containing only strings conforming to the above requirements.
</li>
</ul>

<p class="note">注記：
~key~pathの中では space は許容されない。
◎
Spaces are not allowed within a key path.
</p>


<p>
`~key~path$で~accessできる部位は、`有構造~clone~algo$により明示的に複製される~propのみである —
次に挙げる各種~型に特有の~propも含まれる：
◎
Key path values can only be accessed from properties explicitly copied by the structured clone algorithm, as well as the following type-specific properties:
</p>

<table><tbody><tr><th>型◎Type
</th><th>~prop◎Properties
</th></tr><tr><td>`Blob$I
</td><td>`size^m, `type^m
</td></tr><tr><td>`File$I
</td><td>`name^m, `lastModified^m, `lastModifiedDate^m
</td></tr><tr><td>`Array$js
</td><td>`length^js
</td></tr><tr><td>`String$js
</td><td>`length^js
</td></tr></tbody></table>


<div class="trans-note">
<p >【補記：】</p>

<p>
`~key~path$は、任意に与えられる値（ ~obj ）の中のある一定の部位を表現する。
その目的は、外部から与える一連の値で，`保管庫$を
<em >拡充する</em>
とき
— すなわち，値を`保管庫$の`~record~list$Osの中に`~record$の`値$として格納するとき — 
に、それらの値の中の［
~key~pathが指す部位に与えられている~data
］から，自動的に`~key$を導出することである。
あるいは、`索引$を，それが`専属する$`保管庫$の`~record~list$Osに基づいて拡充するときにも、同様に利用される。
</p>

<aside class="example">

<p>
例えば文字列（ ~DS ）の~key~path `a.b^l は、任意の値 %V に対し，
%V`.a.b^js で~accessされる部位を表す（文字列の中の各~PERIODが階層を辿る~pathの区切りを表す）。
%V ~EQ `{ a: { b: "c" }}^js であれば、この~key~pathは，`~key$として `c^l を抽出する。
%V`.a.b^js に~accessし得ない場合（例えば %V`.a^js は~objでない），あるいは %V`.a.b^js の値が~keyとして妥当でない場合（例えば`undefined^js ）、 %V からは~keyは抽出されない／できないことになる
— これらの場合は，この仕様では ~invalid／~failure という定数で表現されている。
</p>

<p>
空~文字列も~key~pathとして妥当であり、それが指す部位は，値が何であろうと値~全体になる（この~key~pathは`保管庫$には許容されないが）。
すなわち、抽出される~keyは，常に値そのものになる。
</p>

<p>
文字列の連列（ ~SeqDS ）による~key~pathが指す部位は、その中の［
~key~pathとしての各 文字列が指すが部位
］からなる配列になる（この種の~key~pathも，`索引$にのみ許容される）。
例えば~key~path
( `a.b^l, `x.y.z^l )
は、値 %V から，`配列~key$
[ %V`.a.b^c, %V`.x.y.z^c ]
を~keyとして抽出する。
</p>

<p>
空~連列も~key~pathとして妥当であり、それが指す部位は，値が何であろうと空~listになる。
すなわち、抽出される~keyは，常に空~配列になる。
</p>

</aside>

</div>


		</section>
		<section id="index-concept">

<h3 title="Index">2.6. 索引</h3>

<p>
`~key$以外の手段を通して，`保管庫$内の`~record$たちを検索取得できると有用になることもときどきある。
`索引@
（ index ）により、`保管庫$内の`~record$たちを，それらの`値$の~propを通して検索できるようになる。
◎
It is sometimes useful to retrieve records in an object store through other means than their key. An index allows looking up records in an object store using properties of the values in the object stores records.
</p>

<p>
索引は、ある~~目的に特化された`~record$たちの永続的な蓄積であり、その~dataは，以下に述べるように
索引が`専属する$`保管庫$の~dataに基いて拡充される。
各 索引は、次のものを持つ（括弧内は、索引を`~access先$とする `IDBIndex!I ~objの対応する~member ）：
◎
An index is a specialized persistent key-value storage and has a referenced object store. The index has a list of records which hold the data stored in the index. The records in an index are automatically populated whenever records in the referenced object store are inserted, updated or deleted. There can be several indexes referencing the same object store, in which changes to the object store cause all such indexes to get updated.
</p>

<dl>
	<dt>`参照先の保管庫@</dt>
	<dd>
索引が`専属する$`保管庫$。
索引の作成時に設定される。
<span class="trans-note">【
この訳では、この用語は利用せず，単に
“索引が専属する保管庫”
と記す。
】</span>
以下の各項では、単に %保管庫 と記す。
◎
↑</dd>

	<dt>`~record~list@Ix</dt>
	<dd>
<p>
索引に格納される~dataを保持する，`~record$の~list。
この~listは、 %保管庫 の`~record~list$Os %L から自動的に拡充される：
</p>

		<ul>
			<li>
索引の作成時に， %L に基づいて自動的に拡充される。
</li>
			<li>
%L ［
に~recordが挿入される ／
から~recordが削除される ／
の~recordの`値$が更新される
］度に，自動的に拡充される。
</li>
		</ul>

<p>
%L に変更が加えられる度に， %保管庫 に`専属する$すべての索引は更新されることになる。
</p>

<p class="trans-note">【
どのような原則に基づいて拡充されるかの詳細は、<a href="#_populating-an-index">索引の拡充</a>節に。
】</p>

◎
↑↓
</dd>

	<dt>`~key~path@Ix （ `keyPath$m ）</dt>
	<dd>
<p>
`~key~path$。
</p>

<p>
索引~内のどの~record %R1 についても：
</p>
		<ul>
			<li>
<p>
%R1 の`値$は  %保管庫 内のある~record %R の`~key$で与えられる。
</p>

<div class="trans-note">
<p>【
したがって、`保管庫$における`~key$の一意性から，索引の`~record~list$Ix から %保管庫 の`~record~list$Os %L への対応関係：
</p>

<blockquote>
%R1 → %R ~EQ ［
%R1 の`値$を`~key$とする %L 内の~record
］
</blockquote>

<p>
が定義できる。
この訳では、この %R を %R1 の
`参照先~record@
と呼ぶことにする。
】</p>
</div>
			</li>
			<li>
%R1 の`~key$は［
%R の`値$の中の，この`~key~path$Ixが指す部位
］から`抽出される~key$（たちのいずれか）で与えられる。
</li>
		</ul>
<p>
索引の`~record~list$Ixは，そのように %R から導出される %R1 たちで拡充される。
</p>

◎
The values in the index’s records are always values of keys in the index’s referenced object store. The keys are derived from the referenced object store’s values using a key path. If a given record with key X in the object store referenced by the index has the value A, and evaluating the index’s key path on A yields the result Y, then the index will contain a record with key Y and value X.
</dd>

	<dd>
<aside class="example">

<p>
例えば，
%R ~EQ ｛ `123^c ： `{ first: "Alice", last: "Smith" }^c ｝
で，索引の`~key~path$Ixが `first^l ならば、~key `Alice^l が抽出され，索引は
%R1 ~EQ｛ `Alice^l ： `123^c ｝
を包含することになる。
◎
For example, if an index’s referenced object store contains a record with the key 123 and the value { first: "Alice", last: "Smith" }, and the index’s key path is "first" then the index would contain a record with the key "Alice" and the value 123.
</p>

</aside>

<p>
上述の %R （すなわち， %R1 の`参照先~record$）の`値$は、 %R1 の
`参照先の値@
と呼ばれる。
◎
Records in an index are said to have a referenced value. This is the value of the record in the index’s referenced object store which has a key equal to the index’s record’s value. So in the example above, the record in the index whose key is Y and value is X has a referenced value of A.
</p>

<aside class="example">

<p>
先の例の
%R1 ~EQ｛ `Alice^l ： `123^c ｝
の`参照先の値$は，
`{ first: "Alice", last: "Smith" }^c 
になる。
◎
In the preceding example, the record in the index with key "Alice" and value 123 would have a referenced value of { first: "Alice", last: "Smith" }.
</p>

</aside>

<p class="note">注記：
`この段落の内容は、<a href="#_populating-an-index">索引の拡充</a>節に委譲。^tnote
◎
Each record in an index references one and only one record in the index’s referenced object store. However there can be multiple records in an index which reference the same record in the object store. And there can also be no records in an index which reference a given record in an object store.
</p>

<p>
索引~内の`~record$たちは、常にその~keyに則って整列される。
保管庫と違い、索引は，同じ~keyを伴う複数の~recordを包含し得るので、それらの~recordは更に，それらの`値$（すなわち，`参照先~record$の~key）に則って整列される。
◎
The records in an index are always sorted according to the record’s key. However unlike object stores, a given index can contain multiple records with the same key. Such records are additionally sorted according to the index’s record’s value (meaning the key of the record in the referenced object store).
</p>
	</dd>

	<dt>`名前@Ix （ `name$m ）</dt>
	<dd>
空~文字列も含め，どのような文字列~値もとり得る。
名前は、どの時点においても，同じ`保管庫$に`専属する$索引たちにわたって一意になる。
名前は常に， 16-bit 符号単位として文字大小区別で比較される。
◎
An index has a name. The name can be any string value, including the empty string. At any one time, the name is unique within index’s referenced object store. Index names are always compared in a case-sensitive manner, as opaque sequences of 16-bit code units.
</dd>

	<dt>`一意~flag@Ix （ `unique$m ）</dt>
	<dd>
~ON に設定された下では、索引の~record~listは［
索引~内のどの二つの`~record$も同じ~keyを持たない
］条件の下で拡充される。
索引が`専属する$`保管庫$にて［
`~record$を 挿入する／改変する
］ような試みは、［
索引の`~key~path$Ixを用いて その~recordの値から`抽出される~key$（たちのいずれか）
］が［
索引~内のある~recordの~key
］と同じになるならば，失敗する。
<span class="trans-note">【
新たな索引を作成する試みも，条件を満たせないときは同様に失敗する。
この場合の取り扱いは
`IDBObjectStore.createIndex()$m
にて述べられる。
】</span>
◎
An index has a unique flag. When this flag is set, the index enforces that no two records in the index has the same key. If a record in the index’s referenced object store is attempted to be inserted or modified such that evaluating the index’s key path on the records new value yields a result which already exists in the index, then the attempted modification to the object store fails.
</dd>
	<dt>`複entry~flag@Ix （ `multiEntry$m ）</dt>
	<dd>
<p>
この~flagは、索引の`~key~path$Ixが指す（ %保管庫 に追加された`~record$の）部位が配列であるとき，索引がどう挙動するかに影響する：
</p>
		<ul>
			<li>
~OFF の場合
⇒
索引には，その配列をそのまま`配列~key$とするような，単独の`~record$が追加される。
</li>
			<li>
~ON の場合
⇒
索引には，その配列~内の重複を除いた各`~key$ %key ごとに，［
%key を`~key$にするような，`~record$
］が追加される。
この場合、 `~key~path$Ixは ~SeqDS 値をとり得ない。
</li>
		</ul>

<p class="trans-note">【
この機能により、ある部位においてのみ異なる多数の`~record$を，一つに集約して取扱えるようにもなる。
】</p>

◎
An index has a multiEntry flag. This flag affects how the index behaves when the result of evaluating the index’s key path yields an array key. If the multiEntry flag is unset, then a single record whose key is an array key is added to the index. If the multiEntry flag is true, then the one record is added to the index for each of the subkeys.
</dd>
</dl>

			<section id="_populating-an-index">
<h5>【索引の拡充】</h5>

<p class="trans-note">【
この節は、この訳による補完。
】</p>

<p>
`索引$ %I の`~record~list$Ix %L1 が精確にどのように， %I が`専属する$`保管庫$の`~record~list$Os %L から拡充されるかの詳細を、以下に定式化する（具体的な~algoは、
<a href="#database-operations">各種~db演算</a>
節にて定義される）。
</p>

<p>
まず、 %L 内の`~record$ %R に対し，
`抽出される~key@
の集合 K( %R ) は，次で定義される：
</p>

<blockquote>
K( %R ) ~EQ `ExtractKeySet$(
%R の`値$ ,
%I の`~key~path$Ix ,
%I の`複entry~flag$Ix
)
</blockquote>

<p>
%L1 は，常に次の拘束が満たされるように拡充される：
</p>

<ul>
	<li>
<p>
%L 内のどの %R に対しても、 K( %R ) 内の各`~key$ %key に対し，次の両~条件を満たす~record %R1 が %L1 内に唯一つ存在する：
</p>

		<ul>
			<li>
%R1 の`~key$ ~EQ~cmpkey %key
</li>
			<li>
%R1 の`値$ ~EQ~cmpkey %R の`~key$
</li>
		</ul>
	</li>
	<li>
%L1 は、前項により導出されるもの以外の`~record$は含まない。
</li>
</ul>

<p>
%R が %R1 の`参照先~record$を与える。
［
%I の`複entry~flag$Ix ~EQ ~OFF
］ならば、集合 K( %R ) は，常に 0 〜 1 個の~keyからなるので、
%L1 から %L への対応関係［
%R1 → %R1 の`参照先~record$
］は 単射になる。
また、 K( %R ) が常に空でないならば、この対応関係は全射になる。
</p>

<p>
したがって、索引の`~record~list$Ixは，索引が専属する保管庫の`~record~list$Osから一意に定まることになる。
例えば、保管庫に~recordを追加してから新たな索引を作成した結果と，これを逆順で行った結果は（~errorが生じなければ）同じになる。
よって、索引の~record~listを実際に構築しない実装も可能になるであろう（処理能
— 例えば~recordの整列-など —
との引き換えになるが）。
</p>

			</section>

			<section id="index-handle">
<h5 title="Index Handle">2.6.1. 索引~handle</h5>

<p>
~scriptが`索引$と直接的にやりとりすることはない。
代わりに`~tx$の中で
`索引~handle@
を介して間接的に~accessする。
◎
Script does not interact with indexes directly. Instead, within a transaction, script has indirect access via an index handle.
</p>


<p>
各`索引~handle$ %I には、次のものが結付けられる（括弧内は、対応する `IDBIndex!I ~interface~member ）：
◎
↓</p>

<dl>
	<dt>`保管庫~handle@IxH（ `objectStore$m ）</dt>
	<dd>
%I が`専属する$`保管庫~handle$。
%I の［
取得時／作成時
］に，`可換性$と`一意性$の要件が満たされるように設定される。
◎
↓</dd>

	<dt>`~tx@IxH</dt>
	<dd>
%I が`専属する$`保管庫~handle$が`専属する$`~tx$。
◎
An index handle has an associated index and an associated object store handle. The transaction of an index handle is the transaction of its associated object store handle. Multiple handles may be associated with the same index in different transactions, but there must be only one index handle associated with a particular index within a transaction.
</dd>

	<dt>`名前@IxH （ `name$m ）</dt>
	<dd>
%I の作成時に %I↗ の`名前$Ixに初期化される。
この名前は、 %I が`専属する$`~tx$が［
`昇格~tx$であって, `稼働中$でもある
］ときを除いて，一定であり続ける。
◎
An index handle has a name, which is initialized to the name of the associated index when the index handle is created. The name will remain constant except when an upgrade transaction is running.
</dd>

</dl>

			</section>
		</section>
		<section id="transaction-concept">

<h3 title="Transactions">2.7. ~tx</h3>

<p>
`~db$内の~dataとやりとりするときは、
`~tx@
（ transaction ）が利用される。
~dataが ~db［
から読取される／
に書込される
］ときには、常に，`~tx$が利用される。
◎
A Transaction is used to interact with the data in a database. Whenever data is read or written to the database it is done by using a transaction.
</p>


<div class="p">
<p>
`~tx$は、［
~app／~system
］の失敗に対する一定の保護を提供0する：
</p>

<ul>
	<li>
一度に複数の~data~recordを格納したり，~data~recordを条件付きで改変するために利用し得る。
</li>
	<li>
時間を要する［
~data~access／~data変異
］演算からなる，不可分的な集合を表現する。
</li>
</ul>

<p class="trans-note">【
すなわち，失敗-時には、中途半端な状態にならないように，これらによる変異すべてが元の状態に復帰される。
】</p>
◎
Transactions offer some protection from application and system failures. A transaction may be used to store multiple data records or to conditionally modify certain data records. A transaction represents an atomic and durable set of data access and data mutation operations.
</div>


<p>
各 `~tx$は、次のものを持つ（括弧内は、対応する `IDBTransaction!I ~interface~member ）：
</p>

<dl>
	<dt>`接続@tx （ `db$m ）</dt>
	<dd>
すべての`~tx$は、ある`接続$を通して`作成-$される（後述の`存続期間$を見よ）。
~txは、その`接続$に`専属する$。
◎
All transactions are created through a connection, which is the transaction’s connection.
</dd>
	<dd class="trans-note">【
この訳では、この接続を指すときは，もっぱら
“（~txが）専属する接続”
と記す。
】</dd>

	<dt>`視野@ （ `objectStoreNames$m ）</dt>
	<dd>
`~tx$がやりとりし得る`保管庫$たちからなる集合。
視野は、~txの作成時に決定され，~txが存続する限り固定され続ける†。
◎
A transaction has a scope that determines the object stores with which the transaction may interact. A transaction’s scope remains fixed for the lifetime of that transaction.
</dd>
	<dd class="trans-note">【†
`昇格~tx$については、その視野は <em >常に，</em>
それが`専属する$`接続$の`保管庫~集合$Cnになる。
】</dd>
	<dd class="trans-note">【
それぞれの~txは、<strong>
同じ`保管庫$を，別々の`保管庫~handle$を通して，自身の
“視野に入れる”
</strong>
ことに注意。
】</dd>

	<dt>`~mode@ （ `mode$m ）</dt>
	<dd>
<p>
`~tx$が，どの型のやりとりを遂行できるかを決定する。
`~mode$は，~txの作成時に設定され、~txが存続する間 変わらない。
次のいずれか：
◎
A transaction has a mode that determines which types of interactions can be performed upon that transaction. The mode is set when the transaction is created and remains fixed for the life of the transaction. A transaction’s mode is one of the following:
</p>

		<dl>
			<dt>`readonly@l</dt>
			<dd>
この型の`~tx$には、~dataを読取することのみが許容され，改変は行えない。
`readonly^l ~txには、複数のそれらを同時に稼働できる優位性がある
— 互いの`視野$が重なっていようが（すなわち，同じ保管庫を利用していても）。
この型の~txは、~dbが~openされたなら，いつでも作成できる。
<!-- 
手短に言えば、［ 同じ保管庫を視野に入れている，この型の~txたち ］は，その保管庫を排他的に占有する。
-->
◎
The transaction is only allowed to read data. No modifications can be done by this type of transaction. This has the advantage that several read-only transactions can run at the same time even if their scopes are overlapping, i.e. if they are using the same object stores. This type of transaction can be created any time once a database has been opened.
</dd>

			<dt>`readwrite@l</dt>
			<dd>
この型の`~tx$には、既存の保管庫から~dataを読取することに加えて，~dataを［
改変する／削除する
］ことも許容される。
しかしながら、保管庫や索引を［
追加する, 除去する
］ことはできない。
また、［
互いの`視野$が重なるような複数の `readwrite^l `~tx$
］を同時に稼働させることはできない
— そうすると，~txの間に互いの~dataを改変し得ることになるので。
この型の~txは、~dbが~openされたなら，いつでも作成できる。
◎
The transaction is allowed to read, modify and delete data from existing object stores. However object stores and indexes can’t be added or removed. Multiple "readwrite" transactions can’t run at the same time if their scopes are overlapping since that would mean that they can modify each other’s data in the middle of the transaction. This type of transaction can be created any time once a database has been opened. 
</dd>
			<dd class="trans-note">【
手短に言えば、視野に入れている保管庫たちを排他的に占有する。
】</dd>

			<dt>`versionchange@l</dt>
			<dd>
この型の`~tx$には、既存の保管庫から~dataを［
読取する, 改変する, 削除する
］ことに加えて，保管庫や索引を［
作成する, 除去する
］こともできる。
それは、この型の~txのみが行い得る。
この型の~txは、手動では作成できない
— 代わりに `upgradeneeded$et ~eventが発火されるときに自動的に作成される。
◎
The transaction is allowed to read, modify and delete data from existing object stores, and can also create and remove object stores and indexes. It is the only type of transaction that can do so. This type of transaction can’t be manually created, but instead is created automatically when an upgradeneeded event is fired.
</dd>
			<dd class="trans-note">【
手短に言えば、接続先の~db全体を排他的に占有する。
】</dd>

		</dl>
	</dd>

	<dt>`作動中~flag@</dt>
	<dd>
この~flagが ~ON のとき, そのときに限り，~txは
`作動中@
であるとされ、`要請$を~txに`設置-$できる。
◎
A transaction has an active flag, which determines if new requests can be made against the transaction. A transaction is said to be active if its active flag is set.
</dd>

	<dt>`要請~list@</dt>
	<dd>
~txに`設置-$された`要請$たちからなる, `設置された順による^tnote~list。
◎
A transaction has a request list of requests which have been made against the transaction.
</dd>

	<dt>`~error@tx</dt>
	<dd>
初期時は ε 。
`~tx$が~errorにより`中止-$されたときに設定される。
◎
A transaction has a error which is set if the transaction is aborted.
</dl>

<p>
`~tx$の`親~標的を取得-$する~algoは、~txが`専属する$`接続$を返す。
◎
A transaction’s get the parent algorithm returns the transaction’s connection.
</p>

<p>
`~mode$が `readonly$l にされた`~tx$を
`~readonly~tx@
という。
◎
A read-only transaction is a transaction with mode "readonly".
</p>

<p>
`~mode$が `readwrite$l にされた`~tx$を
`~readwrite~tx@
という。
◎
A read/write transaction is a transaction with mode "readwrite".
</p>


			<section id="transaction-lifetime-concept">
<h4 title="Transaction Lifetime">2.7.1. ~txの存続期間</h4>


<p>
`~tx$は短命であるものと期待されている。
これは、下に述べる自動`~commit$の機能性により促される。
◎
Transactions are expected to be short lived. This is encouraged by the automatic committing functionality described below.
</p>

<p class="note">注記：
作者は依然として，~txを長い間 稼働させれるが、そのような用法は，利用者~体験を悪化させ得るので、一般には推奨されない。
◎
Authors can still cause transactions to run for a long time; however, this usage pattern is not generally recommended as it can lead to a bad user experience.
</p>

<p>
`~tx$はその
`存続期間@
にわたり、以下のように変遷する：
◎
The lifetime of a transaction is as follows:
</p>

<ol>
	<li>
<p>
<strong>作成する</strong>：
`~tx$は、`~mode$と`視野$を伴って
`作成-@
される。
同時に†、~txの`作動中~flag$は ~ON にされる。
</p>

<p class="trans-note">【†
実際には、
`success$et／`error$et
が配送されている間に限り ~ON にされている。
】</p>
◎
A transaction is created with a scope and a mode. When a transaction is created its active flag is initially set.
</li>
	<li>
<p>
<strong>要請を設置する</strong>：
実装は：
</p>
		<ul>
			<li>
`作動中$にある`~tx$に対しては，`要請$を`設置-$できるようにし~MUST。
</li>
			<li>
`作動中$でない`~tx$に対し，要請を`設置-$しようと試みられた場合、`TransactionInactiveError$E を投出して，却下し~MUST。
</li>
			<li>
まだ`開始-$されてない`~tx$に対し`設置-$された`要請$たちは、`開始-$されるまで，実行しては~MUST_NOT
— 代わりに、それらの要請を，その順序も込みで保ち続け~MUST。
</li>
		</ul>

◎
The implementation must allow requests to be placed against the transaction whenever the active flag is set. This is the case even if the transaction has not yet been started. Until the transaction is started the implementation must not execute these requests; however, the implementation must keep track of the requests and their order. Requests may be placed against a transaction only while that transaction is active. If an attempt is made to place a request against a transaction when that transaction is not active, the implementation must reject the attempt by throwing a TransactionInactiveError.
</li>
	<li>
<strong>開始する</strong>：
実装は、以下に定義される［
`~tx$の`~mode$と`視野$に定義される拘束
］を施行できるようになったなら，~txを非同期に
`開始-@
する`~taskを待入し$~MUST。
◎
Once an implementation is able to enforce the constraints defined for the transaction scope and mode, defined below, the implementation must queue a task to start the transaction asynchronously.
</li>
	<li>
<strong>要請を実行する</strong>：
`~tx$が`開始-$されたなら、その~txに設置された各`要請$を
`実行-@
できるようになる。
他から定義されない限り、それらの要請は，`設置-$された順序で実行され~MUST。
同様に，それらの結果も、同じ順序で返され~MUST
`返すとは、要請に向けてその完了を報告する~eventを発火することを意味する^tnote
— 異なる~txに`設置-$された要請たちの間では，返される順序は保証されないが。
同様に，~txの`~mode$により、［
互いに異なる~txに対し，二つの要請の どちらが先に設置された
］としても，［
~db内に格納される結果の~dataには影響しない
］ことが確保される。
◎
Once the transaction has been started the implementation can start executing the requests placed against the transaction. Unless otherwise defined, requests must be executed in the order in which they were made against the transaction. Likewise, their results must be returned in the order the requests were placed against a specific transaction. There is no guarantee about the order that results from requests in different transactions are returned. Similarly, the transaction modes ensure that two requests placed against different transactions can execute in any order without affecting what resulting data is stored in the database.
</li>
	<li>
<strong>中止する</strong>：
`~tx$は、`終了-$する前に，いつでも
`中止-@
され得る／できる
— ~txが`作動中$であろうと，まだ`開始-$されていなくても。
~txが中止されるときは、実装は，その~txの間に
`~db$に発行0されたすべての変更を，元に復帰させ~MUST
`“巻戻し（ roll back ）” とも称される^tnote。
これには、［
`保管庫$の内容に対する変更 ／
`保管庫$や`索引$の［
追加／除去
］］も含まれる。
◎
A transaction can be aborted at any time before it is finished, even if the transaction isn’t currently active or hasn’t yet started. When a transaction is aborted the implementation must undo (roll back) any changes that were made to the database during that transaction. This includes both changes to the contents of object stores as well as additions and removals of object stores and indexes.
</li>
	<li>
<p>
<strong>失敗</strong>：
`~tx$は、特定0の`要請$に結付けられない事由でも失敗し得る。
例えば、~txを`~commit$する際の IO ~errorや，
特定0の要請には結付けられないような~quota制限-を超過することに因り。
この事例では、実装は，次を入力に`~txを中止-$し~MUST
⇒
%~tx ~SET ~tx；<br>
%error ~SET 適切な~error名†
</p>

<p>†
例えば
~quotaを超過した場合は `QuotaExceededError$E ／
IO ~errorの場合は `UnknownError$E
を利用すべきである。
</p>

◎
A transaction can fail for reasons not tied to a particular request. For example due to IO errors when committing the transaction, or due to running into a quota limit where the implementation can’t tie exceeding the quota to a partcular request. In this case the implementation must run the steps for aborting a transaction using the transaction as transaction and the appropriate error type as error. For example if quota was exceeded then QuotaExceededError should be used as error, and if an IO error happened, UnknownError should be used as error.
</li>
	<li>
<p>
<strong>~commitする</strong>：
実装は、すでに開始された`~tx$がこれ以上 `作動中$になり得ないとき†は、`中止-$されていない限り，それを
`~commit@
しようと~~試み~MUST。
これは通例的に，［
~txに設置されたすべての要請が実行され，それらが返した結果が取扱われた後に，かつ
~txに対し新たな要請は設置されていないとき†
］に起こる。
</p>

<p class="trans-note">【†
具体的には、結果を取扱う~event~handlerの中で，新たな要請が設置されなかったなら、~commitされる，と考えられる。
】</p>

<p>
`~tx$を~commitするときは、実装は，~txに対し設置された要請により発行0されたすべての変更を，`~db$に不可分的に書込し~MUST。
すなわち、［
変更のすべてが書込される
］か，または［
~disk書込などの~errorが生じた場合には、いかなる変更も~dbに書込されない
］かの，いずれかで~MUST。
</p>

<p>
~errorが生じた場合、実装は`~txを中止-$する手続きに従って，~txを`中止-$し~MUST。
他の場合、`~txを~commit$する手続きに従って~txを`~commit$し~MUST。
</p>
◎
When a transaction has been started and it can no longer become active, the implementation must attempt to commit it, as long as the transaction has not been aborted. This usually happens after all requests placed against the transaction have been executed and their returned results handled, and no new requests have been placed against the transaction. When a transaction is committed, the implementation must atomically write any changes to the database made by requests placed against the transaction. That is, either all of the changes must be written, or if an error occurs, such as a disk write error, the implementation must not write any of the changes to the database. If such an error occurs, the implementation must abort the transaction by following the steps for aborting a transaction, otherwise it must commit the transaction by following the steps for committing a transaction.
</li>
	<li>

<p>
<strong>終了-</strong>：
`~tx$は、それが［
`~commit$された, または
`中止-$された†
］時点で，
`終了-@
したとされる。
`~tx$を終了できない場合
— 例えば、実装が~crashした, あるいは
利用者が~txを取消すような何らかの明示的な動作をとったことに因り —
実装は、~txを`中止-$し~MUST††。
◎
When a transaction is committed or aborted, it is said to be finished. If a transaction can’t be finished, for example due to the implementation crashing or the user taking some explicit action to cancel it, the implementation must abort the transaction.
</p>

<p class="trans-note">【
中止-が要請された時点なのか，それにより`~txを中止-$する手続きを終えた時点なのか、はっきりしない。
】【††
~crashした（あるいは利用者がブラウザを強制終了させたとき）実装は何もできなくなるので，この記述はおかしいが、~commitされないまま内部状態も消し飛ぶので，中止された（復帰された）のと同じことになると考えられる。
】</p>
	</li>
</ol>

<p>
`~tx$の開始~時機は、以下に挙げる拘束により定義される：
◎
The following constraints define when a transaction can be started:
</p>

<p>
`~readonly~tx$は、同時並行的にいくつでも
— 互いの`視野$が重なっていようが —
稼働することが許容される。
`~readonly~tx$に対しては、稼働中にある限り，実装が，
その~txにより作成された`要請$を通して返す~dataは、一定であり続け~MUST。
すなわち，同じ~data片を読取する二つの要請は、~dataが見出されるかどうかも含め，同じ結果を得~MUST。
◎
Any number of read-only transactions are allowed to run concurrently, even if the transaction’s scope overlap and include the same object stores. As long as a read-only transaction is running, the data that the implementation returns through requests created with that transaction must remain constant. That is, two requests to read the same piece of data must yield the same result both for the case when data is found and the result is that data, and for the case when data is not found and a lack of data is indicated.
</p>

<p>
実装がこれを確保する仕方はいくつもある。
例えば，`~readwrite~tx$に対し、視野が重なる`~readonly~tx$が他にあるときは，それらが`終了-$するまで`開始-$を遅らせることもできる。
あるいは，`~readonly~tx$に対しては、その開始-時点での`保管庫$の~snapshotを常に見るようにする方法もある。
◎
There are a number of ways that an implementation can ensure this. The implementation could prevent any read/write transaction, whose scope overlaps the scope of the read-only transaction, from starting until the read-only transaction finishes. Or the implementation could allow the read-only transaction to see a snapshot of the contents of the object stores which is taken when the read-only transaction started.
</p>

<p>
同様に，実装は、［
`~readwrite~tx$は，それを利用して発行0された`保管庫$への変更
］以外からは影響されないこと
— 例えば、別の~txが［
`~readwrite~tx$の`視野$に入る`保管庫$の内容を改変しない
］こと —
を確保し~MUST。
実装は、成功裡に完了した`~readwrite~tx$により`保管庫$に書込された変更は、`~tx$間で互いに競合することなく
— 競合に因り~txを中止することなく —
`~db$に~commitできることを確保し~MUST。
◎
Similarly, implementations must ensure that a read/write transaction is only affected by changes to object stores that are made using the transaction itself. For example, the implementation must ensure that another transaction does not modify the contents of object stores in the read/write transaction’s scope. The implementation must also ensure that if the read/write transaction completes successfully, the changes written to object stores using the transaction can be committed to the database without merge conflicts. An implementation must not abort a transaction due to merge conflicts.
</p>

<p>
複数の`~readwrite~tx$が同じ保管庫に~accessしようと試みた（すなわち，それらの`視野$が重なっている）場合、先に`作成-$された~txが保管庫への~accessを先に取得し~MUST。
前~段落による要件に因り、これは［
その~txが`終了-$するまで，保管庫に~accessできるのはその~txのみになる
］ことも意味する。
◎
If multiple read/write transactions are attempting to access the same object store (i.e. if they have overlapping scope), the transaction that was created first must be the transaction which gets access to the object store first. Due to the requirements in the previous paragraph, this also means that it is the only transaction which has access to the object store until the transaction is finished.
</p>

<p>
`~readwrite~tx$ %A の後に`作成-$された，~tx %B は、 %A  と`視野$が重なる`保管庫$ %O があるならば， %A により書込された %O への変更を見~MUST。
前~段落による要件に因り，これは、 %A が`終了-$するまで，［
%B は， %A の`視野$に入る どの`保管庫$にも~accessできない
］ことを意味する。
◎
Any transaction created after a read/write transaction must see the changes written by the read/write transaction. So if a read/write transaction, A, is created, and later another transaction B, is created, and the two transactions have overlapping scopes, then B must see any changes made to any object stores that are part of that overlapping scope. Due to the requirements in the previous paragraph, this also means that the B transaction does not have access to any object stores in that overlapping scope until the A transaction is finished.
</p>

<p class="note">注記：
上述から、一般に，`~readwrite~tx$と, その後に作成された~txは、互いの視野が重なるならば，並列的に稼働できないことを意味する。
◎
Generally speaking, the above requirements mean that any transaction which has an overlapping scope with a read/write transaction and which was created after that read/write transaction, can’t run in parallel with that read/write transaction.
</p>

<p>
~UAは、~starvationを防止するように，各~tx間に適度な公平さを確保し~MUST。
例えば，いくつもの`~readonly~tx$が絶え間なく開始される状況下で、`開始-$待ち`~readwrite~tx$を不定に待たせては~MUST_NOT。
<!-- ＊原文誤 css-writing-modes-3/#start -->
◎
User agents must ensure a reasonable level of fairness across transactions to prevent starvation. For example, if multiple read-only transactions are started one after another the implementation must not indefinitely prevent a pending read/write transaction from starting.
</p>

			</section>
			<section id="upgrade-transactions">
<h4 title="Upgrade Transactions">2.7.2 昇格~tx</h4>

<p>
`~mode$が `versionchange$l にされた`~tx$を
`昇格~tx@
（ upgrade transaction ）という。
◎
An upgrade transaction is a transaction with mode "versionchange".
</p>

<p>
`昇格~tx$は、［
`~db$への`接続$が~openされるとき，与えられた~versionが現在の`~version$dbより大きい
］場合に，`昇格~txを稼働-$させる手続き†を通して，自動的に作成される。
この`~tx$は、 `upgradeneeded$et ~event~handlerの内側で`作動中$になり，新たな［
`保管庫$／`索引$
］を作成できるようにする。
◎
An upgrade transaction is automatically created when running steps for running an upgrade transaction after a connection is opened to a database giving a greater version than the current version. This transaction will be active inside the upgradeneeded event handler, allowing the creation of new object stores and indexes.
</p>

<p class="trans-note">【†
`昇格~tx$が
`稼働中@
（ running ）という句も現れるが、おそらく，この手続きを処理している間を指す。
】</p>

<p>
`昇格~tx$は、他の~txと同時並行的に稼働することは決してない。
~dbが現在の`~version$dbより高い番号の`~version$dbで~openされたときは、新たな `昇格~tx$が自動的に作成され†， `upgradeneeded$et ~eventが発火されたときに`~open要請$を通して可用にされる††。
同じ`~db$への他のすべての`接続$が `~close済み$i になるまでは、
`upgradeneeded$et ~eventは発火されず，
`昇格~tx$は，開始されない。
これにより、他のすべての~txは`終了-$されることが確保される。
◎
An upgrade transaction is never run concurrently with other transactions. When a database is opened with a version number higher than the current version, a new upgrade transaction is automatically created and made available through the open request when the upgradeneeded event is fired. The upgradeneeded event isn’t fired, and thus the upgrade transaction isn’t started, until all other connections to the same database are closed. This ensures that all other transactions are finished.
</p>

<div class="trans-note">

<p>【†
このとき以外に`昇格~tx$が作成される機会は無い。
従って：
</p>

<ul>
	<li>
ある`接続$に接続に`専属する$`昇格~tx$は，あっても一つだけである。
この昇格~txを指して，`接続$に
`専属の昇格~tx@
と呼ぶことにする（接続にて昇格~txが生じなければ ε ）。
</li>
	<li>
`昇格~tx$は、同じ`接続$に`専属する$他のどの`~tx$よりも先に`開始-$される。
</li>
</ul>

<p>††
この仕様に現れる，
`昇格~txの中@
という句は、［
`upgradeneeded$et ~eventにより呼出される~event~handlerの中
］を意味する。
】</p>
</div>

<p>
`接続$ %C に`専属の昇格~tx$が`稼働中$にある限り、 `~db$ %C↗ に対し別の`接続$を~openしようとする試みは遅延され、 %C を利用するような追加の~txを開始させる試みに対しては，例外が投出されることになる。
したがって，`昇格~tx$は、［
他の~txが同時並行的に稼働しない
］ことに加え，`稼働中$の間は［
同じ`~db$に対し，他の~txは待入されない
］ことを確保する。
◎
As long as an upgrade transaction is running, attempts to open more connections to the same database are delayed, and any attempts to use the same connection to start additional transactions will result in an exception being thrown. Thus upgrade transactions not only ensure that no other transactions are running concurrently, but also ensure that no other transactions are queued against the same database as long as the transaction is running.
</p>

			</section>
		</section>
		<section id="request-concept">
<h3 title="Requests">2.8. 要請</h3>

<p>
`~db$に対する各 非同期の`演算$は、
`要請@
（ request ）を利用して行われる。
どの %要請 も，ある一つの`演算$（以下， %演算 と記す）を表現し、次のものが結付けられる（括弧内は，対応する `IDBRequest!I ~interface~member ）：
◎
Each asynchronous operation on a database is done using a request. Every request represents one operation.
</p>

<dl>
	<dt>`~done~flag@ （ `readyState$m ）</dt>
	<dd>
%演算 が完了した（成功裡に終えた／失敗した／中止された）かどうかを指示する。
初期~時は ~OFF。
◎
A request has a done flag which is initially unset.
</dd>

	<dt>`~source@ （ `source$m ）</dt>
	<dd>
<span class="trans-note">【
%演算 の対象
— 次のいずれか：［
`保管庫~handle$／`索引~handle$／`~cursor$／ε
］。
%要請 の作成時に設定され（設定されない場合は ε ）、それ以降は変わらない。
】</span>
◎
A request has a source object.
</dd>

	<dt>`結果@ （ `result$m ）</dt>
	<dt>`~error@ （ `error$m ）</dt>
	<dd>
`~done~flag$が ~ON になるまでは~accessできない。
~ON の時点で，どうなるかについては、下記に。
◎
A request has a result and an error, neither of which are accessible until the done flag is set.
</dd>

	<dt>`設置先~tx@ （ `transaction$m ）</dt>
	<dd>
初期~時は ε 。
%要請 は、 %演算 を`非同期に実行する$手続きを用いて，`~tx$に
`設置-@
される。
同時に， %要請 はその~txの`要請~list$に追加される。
◎
A request has a transaction which is initially null. This will be set when a request is placed against a transaction using the steps for asynchronously executing a request.
</dd>
</dl>


<div class="p">
<p>
`要請$が発行0されるときは、［
`~done~flag$ ~SET ~OFF
］にされた 新たな`要請$が返される。
`要請$が表現する
`演算@
は、要請が非同期に実行する手続きの~instance
— すなわち，［
手続き, それに対する入力, その結果
］の組 — である。
</p>

<p>
`要請$ %要請 がその`演算$の手続きを終えたときは、先ず［
%要請 の`~done~flag$ ~SET ~ON
］にされた上で、演算から返された %結果 が：
</p>


<dl class="switch">
	<dt>~errorでない場合（演算は成功した）</dt>
	<dd>
		<ol>
			<li>
%要請 の`結果$は %結果 に設定され、
%要請 の`~error$は ε に設定される。
</li>
			<li>
%要請 に向けて `success$et ~eventが発火される。
</li>
		</ol>
	</dd>

	<dt>~errorである場合（演算は失敗した）</dt>
	<dd>
		<ol>
			<li>
%要請 の`結果$は ε に設定され、
%要請 の`~error$は %結果 に設定される。
</li>
			<li>
%要請 に向けて `error$et ~eventが発火される。
</li>
</ol>
	</dd>
</dl>

◎
When a request is made, a new request is returned with its done flag unset. If a request completes successfully, the done flag is set, the result is set to the result of the request, and an event with type success is fired at the request.
◎
If an error occurs while performing the operation, the done flag is set, the error is set to the error, and an event with type error is fired at the request.
</div>



<p>
`要請$の`親~標的を取得-$する~algoは、要請の`設置先~tx$を返す。
◎
A request’s get the parent algorithm returns the request’s transaction.
</p>

<p class="note">注記：
要請は概して，再利用されないが、例外もある。
`~cursor$が反復されるときは、その~cursorを~openしたときに利用された`要請$と同じ~obj上に，反復の成功が報告される。
また、`昇格~tx$が必要とされた場合も，［
`upgradeneeded$et ~eventと~open演算~自身の最終~結果
］の両者に，同じ`~open要請$が利用される。
いずれの場合も、要請の `~done~flag$は、演算を実行する前に，また ~OFF にされ、その`結果$も変化し得る。
◎
Requests are not typically re-used, but there are exceptions. When a cursor is iterated, the success of the iteration is reported on the same request object used to open the cursor. And when an upgrade transaction is necessary, the same open request is used for both the upgradeneeded event and final result of the open operation itself. In both cases, the request’s done flag will be unset then set again, and the result may change.
</p>


			<section id="open-requests">
<h4 title="Open Requests">2.8.1. ~open要請</h4>

<p>
`~open要請@
は、［
`接続$を~openする, あるいは`~db$を削除する
］ときに利用される，特別な型の`要請$である。
`~open要請$に対しては、［
`success$et, `error$et
］~eventに加え，進捗を指示する［
`blocked@et, `upgradeneeded@et
］~eventも発火され得る。
◎
An open request is a special type of request used when opening a connection or deleting a database. In addition to success and error events, blocked and upgradeneeded may be fired at an open request to indicate progress.
</p>

<p>
`~open要請$の`~source$は常に ε である。
◎
The source of an open request is always null.
</p>

<p>
`~open要請$の`設置先~tx$は、 `upgradeneeded$et ~eventが発火されない限り， ε にされる。
<!-- 
その~txが終了したときも ε に戻される
 -->
◎
The transaction of an open request is null unless an upgradeneeded event has been fired.
</p>

<p>
`~open要請$の`親~標的を取得-$する~algoは、 ~NULL を返す。
◎
An open request’s get the parent algorithm returns null.
</p>

<p>
`~open要請$は
`接続~待行列@
にて処理される。
この待行列は、組
( `生成元$, `名前$db )
に結付けられる，すべての`~open要請$を包含する。
`接続~待行列$に追加された要請は、順序どおりに処理され，各 要請は 次の要請が処理される前に完了され~MUST。
~open要請は、他の`接続$により阻止され得る
— それらの接続が`~close$されるまで、その要請は完了せず，更なる要請は処理できないことになる。
◎
Open requests are processed in a connection queue. The queue contains all open requests associated with an origin and a name. Requests added to the connection queue processed in order and each request must run to completion before the next request is processed. An open request may be blocked on other connections, requiring those connections to close before the request can complete and allow further requests to be processed.
</p>

<p class="note">注記：
`接続~待行列$は、`~event~loop$に結付けられている`~task待行列$ではない
— 要請は、すべての`閲覧文脈$の外側で処理されるので。
完了した`~open要請$への~eventは、依然として，要請を発行0した文脈~下の
`~event~loop$に結付けられている`~task待行列$を通して送達される。
◎
A connection queue is not a task queue associated with an event loop, as the requests are processed outside any specific browsing context. The delivery of events to completed open request still goes through a task queue associated with the event loop of the context where the request was made.
</p>



			</section>
		</section>
		<section id="range-concept">

<h3 title="Key Range">2.9. ~key範囲</h3>

<p>
`保管庫$や`索引$から一連の`~record$を検索取得するためには、［
単独の`~key$, または`~key範囲$
］を利用する。
`~key範囲@
とは、~keyに利用される ある~data型にわたる連続的な区間である。
◎
Records can be retrieved from object stores and indexes using either keys or key ranges. A key range is a continuous interval over some data type used for keys.
</p>

<p>
各 `~key範囲$には、次のものが結付けられる（括弧内は、対応する `IDBKeyRange!I ~interface~member）：
</p>

<dl>
	<dt>`下界@ （ `lower$m ）</dt>
	<dt>`上界@ （ `upper$m ）</dt>
	<dd>
いずれも`~key$, または ε 。
◎
A key range has an associated lower bound (null or a key).
◎
A key range has an associated upper bound (null or a key).
</dd>

	<dt>`下界open~flag@ （ `lowerOpen$m ）</dt>
	<dd>
~flag値。
特に指定されない限り， ~OFF 。
`下界$ ~EQ ε の場合は ~ON。
◎
A key range has an associated lower open flag. Unless otherwise stated it is unset.
</dd>
	<dt>`上界open~flag@ （ `upperOpen$m ）</dt>
	<dd>
~flag値。
特に指定されない限り， ~OFF 。
`上界$ ~EQ ε の場合は ~ON。
◎
A key range has an associated upper open flag. Unless otherwise stated it is unset.
</dd>
</dl>


<p>
［
`下界$ ~GT~cmpkey `上界$
］になっては~MUST_NOT。
◎
A key range may have a lower bound equal to its upper bound. A key range must not have a lower bound greater than its upper bound.
</p>

<p>
`Only@ ( %key )
と記される，所与の`~key$ %key のみを包含する`~key範囲$は、次の様にされた`~key範囲$として定義される
⇒
`下界$ ~SET %key；<br />
`上界$ ~SET %key；<br />
`上界open~flag$ ~SET ~OFF；<br />
`下界open~flag$ ~SET ~OFF
◎
A key range containing only key has both lower bound and upper bound equal to key.
</p>

<p>
`~key$ %key は，次の両~条件を満たすとき，`~key範囲$ %範囲 に
`入る@
とされる：
◎
A key is in a key range if both of the following conditions are fulfilled:
</p>

<ul>
	<li>
<p>
次のいずれかの条件を満たす：
</p>
		<ul>
			<li>
%範囲 の`下界$ ~EQ ε
</li>
			<li>
%範囲 の`下界$ ~LT~cmpkey %key
</li>
			<li>
［
%範囲 の`下界$ ~EQ~cmpkey %key
］~AND［
%範囲 の`下界open~flag$ ~EQ ~OFF
］
</li>
</ul>

◎
The lower bound is null, or it is less than key, or it is both equal to key and the lower open flag is unset.
</li>
	<li>
<p>
次のいずれかの条件を満たす：
</p>
		<ul>
			<li>
%範囲 の`上界$ ~EQ ε
</li>
			<li>
%範囲 の`上界$ ~GT~cmpkey %key
</li>
			<li>
［
%範囲 の`上界$ ~EQ~cmpkey %key
］~AND［
%範囲 の`上界open~flag$ ~EQ ~OFF
］
</li>
		</ul>
◎
The upper bound is null, or it is greater than key, or it is both equal to key and the upper open flag is unset.
</li>
</ul>


<div class="note">
<p>
［
`下界$ ／ `上界$
］は、`~key範囲$に`入る$とされる`~key$の［
“下限” ／ “上限”
］を与える。
［
`下界$ ／ `上界$
］に対する ε は［
下限／上限
］が無いことを表す。
</p>

<p>
`下界$は、`下界open~flag$が ~OFF のとき, そのときに限り，`~key範囲$に`入る$。
［
`下界$ ~EQ ε
］の場合の`下界open~flag$は ~ON と見なされる†。
`上界open~flag$についても同様。
</p>

<p class="trans-note">【†
原文の属性~定義には ε の場合について記されていないが、対応する
`IDBKeyRange$I ~objを作成する各種~method定義からそう推定できる。
】</p>

◎
If the lower open flag of a key range is unset, the lower bound key of the key range is included in the range itself.
◎
If the lower open flag of a key range is set, the lower bound key of the key range is excluded from the range itself.
◎
If the upper open flag of a key range is unset, the upper bound key of the key range is included in the range itself.
◎
If the upper open flag of a key range is set, the upper bound key of the key range is excluded from the range itself.
</div>




<p>
`全範囲@
とは、［
`下界$ ~EQ `上界$ ~EQ ε
］なる`~key範囲$である。
任意の`~key$に対し［
`~key$ ~IN `全範囲$
］は真になる。
◎
An unbounded key range is a key range that has both lower bound and upper bound equal to null. All keys are in an unbounded key range.
</p>

<p class="trans-note">【
`全範囲$は `IDBKeyRange$I ~objとしては~instance化され得ない
— ~modelにのみ存在する~objである。
】</p>


<p>
`Range@ ( %値, %~NULL不可 )
は、所与の %値 で表現される`~key範囲$を返すか, または
例外を投出する：
◎
The steps to convert a value to a key range with value and optional null disallowed flag are as follows:
</p>

<ol>
	<li>
<p >
%値 に応じて：
</p>


		<dl class="switch">
			<dt>`~key範囲$である</dt>
			<dd>
~RET %値
◎
If value is a key range, return value.
</dd>

			<dt>ε</dt>
			<dt>~NULL†</dt>
			<dd>
				<ol>
					<li>
~IF ［
%~NULL不可 ~NEQ ε
］
⇒
~THROW `DataError$E
</li>
					<li>
~RET `全範囲$
</li>
				</ol>
◎
If value is undefined or is null, then throw a DataError if null disallowed flag is set, or return an unbounded key range otherwise.
</dd>

			<dt>その他</dt>
			<dd>
~RET `Only$( `Key$( %値 ) ) ？
◎
Let key be the result of running the steps to convert a value to a key with value. Rethrow any exceptions.
◎
If key is invalid, throw a DataError.
◎
Return a key range containing only key.
</dd>
		</dl>
	</li>
</ol>

<p class="trans-note">【†
この手続きは、~key範囲を期待する引数（この仕様では，名前 %query の引数として記される）をとる~API~methodから呼び出される。
その引数が省略可能であって, ~NULL が渡された場合、特別に，引数が省略されたとき（ ε ）と同じに扱われることになる。
】</p>


		</section>
		<section id="cursor-concept">

<h3 title="Cursor">2.10. ~cursor</h3>

<p>
`~cursor@
は、ある~dbに`専属する$［
`索引$／`保管庫$
］の中の ある範囲に入る~recordたちを，特定の方向に反復するために利用される。
◎
A cursor is used to iterate over a range of records in an index or an object store in a specific direction.
</p>


<p>
`~cursor$
は、次のものを持つ（括弧内は、対応する `IDBCursor!I ~interface~member）：
</p>

<dl>
	<dt>`要請@Cs</dt>
	<dd>
~cursorを作成させた`要請$。
</dd>
	<dd class="trans-note">【
この項目は、この訳による補完。
】</dd>

	<dt>`~tx@Cs</dt>
	<dd>
~cursorの`~source$Csが`専属する$`~tx$。
◎
A cursor has a transaction, the transaction that was active when the cursor was created.
</dd>
	<dt>`範囲@Cs</dt>
	<dd>
`~key範囲$。
~cursorは、［
`~source$Cs↗内の`~record$のうち，`~key$がこの範囲に`入る$もの
］を反復対象にする。
◎
A cursor has a range of records in either an index or an object store.
</dd>
	<dd class="trans-note">【
~cursorの作成時に指定されなかった場合、`全範囲$が指定されたものと見なされる。
】</dd>

	<dt>`~source@Cs （ `source$m ）</dt>
	<dd>
`保管庫~handle$, または`索引~handle$。
~cursorは， ~source↗（ ~sourceの`~access先$）の~record~listを反復対象にする。
◎
A cursor has a source that indicates which index or an object store is associated with the records over which the cursor is iterating.
</dd>

	<dd class="trans-note">【
原文における`~source$Csは、［
`保管庫$, または`索引$
］として定義されているが、~modelの記述を簡潔にするため，この訳では 上述のように代えている
— ~cursorを利用するどの演算も，保管庫~handle／索引~handleを通した~accessを要しているので。
】</dd>

	<dt>`方向@Cs （ `direction$m ）</dt>
	<dd>
<p>
次の二つを指示する：
</p>
		<ul>
			<li>
反復-時に~cursorの`位置$Csを移動させる方向
— すなわち，`~record$たちを その`~key$の
昇順, 降順
いずれの順序で反復するか。
~cursor初期~位置は［
前者／後者
］に応じて，`~source$Cs↗の［
始端／終端
］側に位置することになる。
</li>
			<li>
~keyが重複する~recordがあるとき，（最初のもの以外を）飛ばすかどうか。
</li>
		</ul>
◎
A cursor has a direction that determines whether it moves in monotonically increasing or decreasing order of the record keys when iterated, and if it skips duplicated values when iterating indexes. The direction of a cursor also determines if the cursor initial position is at the start of its source or at its end. A cursor’s direction is one of the following:
</dd>

	<dd>
<p>
~cursorの`方向$Csは、次の値をとり得る：
</p>
		<dl>
			<dt>`next@l</dt>
			<dd>
`~cursor$を`~source$Cs↗の始端~側から，`~key$の昇順に反復する。
</dd>
			<dt>`prev@l</dt>
			<dd>
`~cursor$を`~source$Cs↗の終端~側から，~keyの降順に反復する。
</dd>
			<dd>
`next$l, `prev$l のいずれも、反復-時には、`~key$が`等しい$もの†も含め，`範囲$Csに`入る$すべての~recordを得るべきである††。
</dd>
			<dd class="trans-note">【†
重複する~keyを伴う~record間の反復-順序については、`保管庫~位置$Csを見よ。
】【††
“べき”
— `位置$Csの記述を見よ。
】</dd>

			<dt>`nextunique@l</dt>
			<dd>
`~key$が互いに`等しい$~recordたちについては，それらのうち最初の~record以外は飛ばすことを除いて、 `next$l と同じ。
</dd>

			<dt>`prevunique@l</dt>
			<dd>
`~key$が互いに`等しい$~recordたちについては，それらのうち
<strong >最初の</strong>
~record以外は飛ばすことを除いて、 `prev$l と同じ。
</dd>
			<dd>
［
`nextunique$l ／ `prevunique$l
］に対しては、`~source$Cs↗が［
`保管庫$, または［
`一意~flag$Ix ~EQ ~ON
］なる`索引$
］である場合の挙動は，［
`next$l ／ `prev$l
］と正確に同じになる。
</dd>
		</dl>

◎
This direction causes the cursor to be opened at the start of the source. When iterated, the cursor should yield all records, including duplicates, in monotonically increasing order of keys.
◎
This direction causes the cursor to be opened at the start of the source. When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically increasing order of keys. For every key with duplicate values, only the first record is yielded. When the source is an object store or an index with the unique flag set, this direction has exactly the same behavior as "next".
◎
This direction causes the cursor to be opened at the end of the source. When iterated, the cursor should yield all records, including duplicates, in monotonically decreasing order of keys.
◎
This direction causes the cursor to be opened at the end of the source. When iterated, the cursor should not yield records with the same key, but otherwise yield all records, in monotonically decreasing order of keys. For every key with duplicate values, only the first record is yielded. When the source is an object store or an index with the unique flag set, this direction has exactly the same behavior as "prev".
</dd>

	<dt>`位置@Cs</dt>
	<dd>
`範囲$Csに`入る$どこかを指す†。
~cursorが反復対象にしている~record~listは、~cursorの`範囲$Csが全部的に反復される前に変更されることもある。
これを取扱うため、~cursorは自身の`位置$Csを，~indexとしてではなく，前回に返した†~recordの`~key$として維持管理する。
~cursorが次の~recordへ反復するよう請われたとき、`方向$Csが~keyの昇順なら、前回に反復した~recordの~key`より大きい$~keyを持つ~recordのうち，最小の`~key$を持つものを返すことになる††。
`方向$Csが~keyの降順なら、それとは逆に，前回に反復した~recordの~key`より小さい$~keyを持つ~recordのうち，最大の`~key$を持つものを返すことになる。
◎
A cursor has a position within its range. It is possible for the list of records which the cursor is iterating over to change before the full range of the cursor has been iterated. In order to handle this, cursors maintain their position not as an index, but rather as a key of the previously returned record. For a forward iterating cursor, the next time the cursor is asked to iterate to the next record it returns the record with the lowest key greater than the one previously returned. For a backwards iterating cursor, the situation is opposite and it returns the record with the highest key less than the one previously returned.
</dd>
	<dd class="trans-note">【†
位置は、初期~時には，反復~順序における仮想の先頭（ ε ）をとるが、~cursorの作成を要請したときに，この位置のまま~APIに公開されることはない
— `範囲$Csに入る~recordが無い場合の`結果$は ~NULL になる。
】【
~cursorがすべてを反復し終えて，次の~recordへの反復が試みられた場合、
ε に設定され，それ以上~反復できなくなる。
】【††
索引における~keyの重複を無視するならば。
次項を見よ。
】</dd>

	<dt>`保管庫~位置@Cs</dt>
	<dd>
`索引$においては、複数の~recordが同じ~keyを持つこともあり，`値$によっても整列されることから、`索引$を反復する~cursorについては，少しばかり複雑になる。
この場合、`~cursor$は，前回の反復にて索引~内に見出された`~record$の`値$を指示する，<em >保管庫~位置</em>も持つ†。
次の~recordを見出すときには、`位置$Csに加え，`保管庫~位置$Csも利用される。
◎
For cursors iterating indexes the situation is a little bit more complicated since multiple records can have the same key and are therefore also sorted by value. When iterating indexes the cursor also has an object store position, which indicates the value of the previously found record in the index. Both position and the object store position are used when finding the next appropriate record.
</dd>
	<dd class="trans-note">【†
すなわち，`参照先~record$の`~key$
— ゆえに “保管庫~位置” と称されている。
】</dd>

	<dt>`~key@Cs （ `key$m ）</dt>
	<dd>
~cursorが最後に反復した`~record$の`~key$を表現する。
◎
↓</dd>
	<dd class="trans-note">【
これは，実質的に`位置$Csの別名。
】</dd>

	<dt>`値@Cs （ `IDBCursorWithValue.value$m ）</dt>
	<dd>
~cursorが最後に反復した`~record$の`値$†を表現する。
◎
A cursor has a key and a value which represent the key and the value of the last iterated record.
</dd>
	<dd class="trans-note">【†
`~source$Cs↗が`索引$の場合は`参照先の値$。
】</dd>


	<dt>`値取得済~flag@Cs</dt>
	<dd>
~ON は、［［
~cursorを利用する`要請$
］が`非同期に実行する$`演算$
］が完了し，新たな
( `~key$Cs, `値$Cs )
を得た（新たな
( `位置$Cs, `保管庫~位置$Cs )
に移動した）ことを指示する。
</dd>
	<dd class="trans-note">【
新たな~cursorを取得した時点では、その前に，`範囲$Csに入る最初の~recordが検索取得されるので、この~flagも ~ON になる。
】</dd>
	<dd>
<p>
~ON は、~OFF の否定であり、したがって，次のいずれかを指示する：
</p>
		<ul>
			<li>
~cursorを利用する`要請$が`非同期に実行する$`演算$は、完了していない。
</li>
			<li>
~cursorは，その`範囲$Cs内のすべての~recordを反復し終えて，次の~recordへの反復が一度でも試みられた。
</li>
		</ul>

<p class="trans-note">【
後者の場合のみ，［
`~key$Cs, `値$Cs
］は ε にされるので、 `key$m を調べれば前者と区別できる。
後者の場合、それ以上~cursorは利用できなくなる
— 例えば `範囲$Cs内に新たな~recordが追加されても，`値取得済~flag$Csが ~ON に戻ることはない（そうしてから もう一度~反復を試みても，例外が投出されることになる）。
】</p>

◎
A cursor has a got value flag. When this flag unset, the cursor is either in the process of loading the next value or it has reached the end of its range. When it is set, it indicates that the cursor is currently holding a value and that it is ready to iterate to the next one.
</dd>


	<dt>`実効~保管庫@Cs</dt>
	<dd>
~cursorの`~source$Cs↗が［
`保管庫$ならば それ／
`索引$ならば それが`専属する$`保管庫$
］。
◎
↓</dd>
	<dt>`実効~key@Cs （ `primaryKey$m ）</dt>
	<dd>
~cursorの`~source$Cs↗が［
`保管庫$ならば ~cursorの`位置$Cs ／
`索引$ならば ~cursorの`保管庫~位置$Cs
］。
◎
If the source of a cursor is an object store, the effective object store of the cursor is that object store and the effective key of the cursor is the cursor’s position. If the source of a cursor is an index, the effective object store of the cursor is that index’s referenced object store and the effective key is the cursor’s object store position.
</dd>

	<dt>`~key~only~flag@Cs</dt>
	<dd>
~cursorの`値$Csも~APIに公開されるかどうかを指示する。
他に言明されない限り ~OFF をとり、~cursorは `IDBCursorWithValue$I ~interfaceを実装することになる。
◎
A cursor also has a key only flag, that indicates whether the cursor’s value is exposed via the API. Unless stated otherwise it is unset.
</dd>
</dl>



		</section>
		<section id="key-generator-concept">

<h3 title="Key Generators">2.11. ~key生成器</h3>

<p>
`保管庫$を作成するとき、
`~key生成器@
を利用するようにも指定できる。
`~key生成器$は、
`現在の番号@
を内部的に保つ。
`現在の番号$は、常に正の整数である。
`~key生成器$が新たな`~key$を生成するときは常に、
生成器の`現在の番号$が返され，<strong>それから</strong>
現在の番号が次回の新たな`~key$のために増加される。
`~key生成器$が番号を生成するときは、次の規則が利用され~MUST：
◎
When a object store is created it can be specified to use a key generator. A key generator keeps an internal current number. The current number is always a positive integer. Whenever the key generator is used to generate a new key, the generator’s current number is returned and then incremented to prepare for the next time a new key is needed. Implementations must use the following rules for generating numbers when a key generator is used.
</p>

<ul>
	<li>
`~key生成器$を利用する どの保管庫も，互いに別々の`~key生成器$を利用する。
すなわち、ある保管庫とのやりとりが，他の保管庫の`~key生成器$に影響することは、決してない。
◎
Every object store that uses key generators use a separate generator. I.e. interacting with one object store never affects the key generator of any other object store.
</li>
	<li>
`保管庫$の作成時における`~key生成器$の`現在の番号$は、常に 1 に設定される。
◎
The current number of a key generator is always set to 1 when the object store for that key generator is first created.
</li>
	<li>
`~key生成器$が`保管庫$に対し新たな`~key$を生成するときは、まず，~key生成器の`現在の番号$が新たな~key値に利用されてから、`現在の番号$が 1 増加される。
◎
When a key generator is used to generate a new key for a object store, the key generator’s current number is used as the new key value and then the key generator’s current number is increased by 1.
</li>
	<li>
<div class="p">
<p>
`~record$を格納させる~callにて~key値が明示的に指定されたとき、その~key値の`種別$keyが `number$i であって, かつ`現在の番号$ 以上であるならば、`現在の番号$は，［
その~key`より大きい$，最小の整数
］に設定される。
</p>

<p>
そのような~keyは、`保管庫$が`~key~path$Os持つかどうかに応じて，次のように指定され得る／できる：
</p>

<ul>
	<li>
~key~pathを持つ場合
⇒
［
保管庫に格納されている`~record$の`値$
］の，［
~key~pathが指す部位
］にある~propの値に自動的に設定される。
</li>
	<li>
~key~pathを持たない場合
⇒
~recordを格納させる~callの引数として，~keyを渡す。
</li>
</ul>

◎
When a record is stored and a key is specified in the call to store the record, if type of the key is number and the value is greater than or equal to the key generator’s current number, then the key generator’s current number is set to the smallest integer number greater than the explicit key. A key can be specified both for object stores which use in-line keys, by setting the property on the stored value which the object store’s key path points to, and for object stores which use out-of-line keys, by passing a key argument to the call to store the record.
</div>

<p>
指定された~keyが`現在の番号$に影響するのは、その`種別$keyが `number$i の場合に限られ、他の`種別$keyの~keyは影響しない
— `string$i 値を `number$i 値に構文解析するような，暗黙的な変換の類は行われない。
また、 1 より小さい `number$i ~keyも、`現在の番号$より常に低いので，影響しない。
◎
Only specified keys of type number may affect the current number of the key generator. Keys of type date, array (regardless of the other keys they contain), binary, or string (regardless of whether they could be parsed as numbers) have no effect on the current number of the key generator. Keys of type number with value less than 1 do not affect the current number since they are always lower than the current number.
</p>
	</li>
	<li>
`現在の番号$に対する改変ingは、~db演算の一部と見なされる
— 演算が失敗して，それによる変更が復帰された場合、`現在の番号$も元の値に復帰される。
◎
Modifying a key generator’s current number is considered part of a database operation. This means that if the operation fails and the operation is reverted, the current number is reverted to the value it had before the operation started. This applies both to modifications that happen due to the current number getting increased by 1 when the key generator is used, and to modifications that happen due to a record being stored with a key value specified in the call to store the record.
</li>
	<li>
同様に，`~tx$が中止された場合も、~txの`視野$に入る各`保管庫$の`~key生成器$の`現在の番号$は，その~txの開始-前の値に復帰される。
◎
Likewise, if a transaction is aborted, the current number of the key generator for each object store in the transaction’s scope is reverted to the value it had before the transaction was started.
</li>
	<li>
<p>
`現在の番号$が，
`最大の番号@ ~EQ ［
2 の 53 乗（ ＝ 9007199254740992 ）
］を超えた† 下では、`~key生成器$を利用して新たな`~key$を生成させるような どの試みに対しても `ConstraintError$E になる。
明示的~keyを指定すれば、依然として`~record$を保管庫に挿入できるが、`~key生成器$を再び利用するためには，保管庫を削除して新たなものを作成する他にない。
◎
When the current number of a key generator reaches above the value 253 (9007199254740992) any attempts to use the key generator to generate a new key will result in a ConstraintError. It is still possible to insert records into the object store by specifying an explicit key, however the only way to use a key generator again for the object store is to delete the object store and create a new one.
</p>

<p class="note">注記：
`~key生成器$を普通に利用している限り、これは問題にはならない。
新たな~keyを毎秒 1000 回~生成し続けても，この制限に達するのは 285000 年後である。
◎
As long as key generators are used in a normal fashion this will not be a problem. If you generate a new key 1000 times per second day and night, you won’t run into this limit for over 285000 years.
</p>

<p class="trans-note">【†
原文の記述からは、整数~keyがとり得る最大数は 2 の 53 乗 になると読めるが、 ECMAScript 仕様による
“整数として安全に取り扱える上限（ `Number.MAX_SAFE_INTEGER^js ）”
は、( 2 の 53 乗 − 1) ＝ 9007199254740991 とされているので、~~本当はこちらが正しいかもしれない。
】</p>

	</li>
	<li>
`現在の番号$は、~db演算の結果が復帰される場合を除き，決して減少しない。
`保管庫$から`~record$を削除しようが， `IDBObjectStore.clear()$m ~methodを利用して全~recordを~clearしようが、保管庫の`~key生成器$には決して影響しない。
◎
The current number for a key generator never decreases, other than as a result of database operations being reverted. Deleting a record from an object store never affects the object store’s key generator. Even clearing all records from an object store, for example using the clear() method, does not affect the current number of the object store’s key generator.
</li>
</ul>

<div class="p">
<p>
~~要約すると、`~key生成器$を持つような保管庫に対しては：
</p>
<ul>
	<li>
最初に生成される~keyは（他の `number$i ~keyが明示的に挿入されない限り）常に 1 になる。
</li>
	<li>
生成される~keyは、常に，保管庫~内の最大の `number$i ~keyより大きい，正の整数になる。
</li>
	<li>
同じ保管庫にて，同じ~keyが二度~生成されることは、~txが巻戻されない限り，決してない。
</li>
</ul>

◎
A practical result of this is that the first key generated for an object store is always 1 (unless a higher numeric key is inserted first) and the key generated for an object store is always a positive integer higher than the highest numeric key in the store. The same key is never generated twice for the same object store unless a transaction is rolled back.
</div>

<aside class="example">

<p>
`~key生成器$は、保管庫ごとに別々に~~維持される：
◎
Each object store gets its own key generator:
</p>

<pre>
store1 = db.createObjectStore(`store1^l, { autoIncrement: true });
store1.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store2 = db.createObjectStore(`store2^l, { autoIncrement: true });
store2.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store1.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^js があてがわれる</span>
store2.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^js があてがわれる</span></pre>

<p>
挿入が，拘束~違反や IO ~errorに因り失敗した場合、`~key生成器$は更新されない。
◎
If an insertion fails due to constraint violations or IO error, the key generator is not updated.
</p>

<pre>
transaction.onerror = function(e) { e.preventDefault() };
store = db.createObjectStore(`store1^l, { autoIncrement: true });
index = store.createIndex(`index1^l, `ix^l, { unique: true });
store.put({ ix: `a^l}); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store.put({ ix: `a^l}); // <span class="comment"
	title="Will fail">失敗することになる</span>
store.put({ ix: `b^l}); // <span class="comment"
	title="Will get key 2">~key `2^js があてがわれる</span></pre>

<p>
保管庫から~itemを除去しようが，`~key生成器$には影響しない
— `clear()^m が~callされたときも含め。
◎
Removing items from an objectStore never affects the key generator. Including when clear() is called.
</p>

<pre>
store = db.createObjectStore(`store1^l, { autoIncrement: true });
store.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store.delete(`1^lt);
store.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^js があてがわれる</span>
store.clear();
store.put(`c^l); // <span class="comment"
	title="Will get key 3">~key `3^js があてがわれる</span>
store.delete(<span class="typ">IDBKeyRange</span>.lowerBound(`0^lt));
store.put(`d^l); // <span class="comment"
	title="Will get key 4">~key `4^js があてがわれる</span></pre>

<p>
明示的~keyを伴わせて~itemを挿入した場合、［
その~keyは `number$i である，かつ 最後に生成された~keyより大きい
］とき，そのときに限り，`~key生成器$に影響する。
◎
Inserting an item with an explicit key affects the key generator if, and only if, the key is numeric and higher than the last generated key.
</p>

<pre>
store = db.createObjectStore(`store1^l, { autoIncrement: true });
store.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store.put(`b^l, `3^lt); // <span class="comment"
	title="Will use key 3">~key `3^js を利用させる</span>
store.put(`c^l); // <span class="comment"
	title="Will get key 4">~key `4^js があてがわれる</span>
store.put(`d^l, -`10^lt); // <span class="comment"
	title="Will use key -10">~key `-10^js を利用させる</span>
store.put(`e^l); // <span class="comment"
	title="Will get key 5">~key `5^js があてがわれる</span>
store.put(`f^l, `6.00001^lt); // <span class="comment"
	title="Will use key 6.0001">~key `6.0001^js を利用させる</span>
store.put(`g^l); // <span class="comment"
	title="Will get key 7">~key `7^js があてがわれる</span>
store.put(`f^l, `8.9999^lt); // <span class="comment"
	title="Will use key 8.9999">~key `8.9999^js を利用させる</span>
store.put(`g^l); // <span class="comment"
	title="Will get key 9">~key `9^js があてがわれる</span>
store.put(`h^l, `foo^l); // <span class="comment"
	title="Will use key &quot;foo&quot;">~key `foo^l を利用させる</span>
store.put(`i^l); // <span class="comment"
	title="Will get key 10">~key `10^js があてがわれる</span>
store.put(`j^l, [`1000^lt]); // <span class="comment"
	title="Will use key [1000]">~key `[1000]^js を利用させる</span>
store.put(`k^l); // <span class="comment"
	title="Will get key 11">~key `11^js があてがわれる</span>
/* <span class="comment">
これらはどれも、保管庫が~key~pathを利用している下で，~objの中に明示的に~keyを埋め込んで渡したときと，同じに挙動することになる。
◎
All of these would behave the same if the objectStore used a keyPath and the explicit key was passed inline in the object
</span> */
</pre>

<p>
~txが中止された場合、その間に起きた`~key生成器$に対する増加は巻戻される。
これにより、すべての巻戻しは一貫するようになる
— ~crashに因る巻戻しは、増加された~key生成器の`現在の番号$を`~commit$する機会を得ることは決してないので。
◎
Aborting a transaction rolls back any increases to the key generator which happened during the transaction. This is to make all rollbacks consistent since rollbacks that happen due to crash never has a chance to commit the increased key generator value.
</p>

<pre>
db.createObjectStore(`store^l, { autoIncrement: true });
trans1 = db.transaction([`store^l], `readwrite$l);
store_t1 = trans1.objectStore(`store^l);
store_t1.put(`a^l); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store_t1.put(`b^l); // <span class="comment"
	title="Will get key 2">~key `2^js があてがわれる</span>
trans1.abort();
trans2 = db.transaction([`store^l], `readwrite$l);
store_t2 = trans2.objectStore(`store^l);
store_t2.put(`c^l); // <span class="comment"
	title="Will get key 1">~key `1^js があてがわれる</span>
store_t2.put(`d^l); // <span class="comment"
	title="Will get key 2">~key `2^js があてがわれる</span>
</pre>
</aside>

<p>
ある~objを保管庫に保存する（例えば
`IDBObjectStore.put()$m
を用いて）ときに，［
`~key~path$Osを利用するとき
］と, ［
`~key生成器$を利用するとき
］との挙動の相違を、以下の例にて~~説明する。
◎
The following examples illustrate the different behaviors when trying to use in-line keys and key generators to save an object to an object store.
</p>


<aside class="example">

<p>
以下では：
</p>

<ul>
	<li>
保管庫に保存する ~objを %O と記す。
</li>
	<li>
%O を保管庫に保存した結果の`~record$を %R と記す。
%O は（`有構造~clone$された上で） %R の`値$として保存される。
</li>
	<li>
保管庫は`~key生成器$を持つとする。
この生成器から提供される次の値を、 %生成key と記す。
</li>
</ul>

<p>
保管庫が`~key~path$Osを持たないならば、
%R の`~key$には %生成key があてがわれることになる。
以降、保管庫は`~key~path$ %keyPath を持つとする。
</p>

<p>
次の様に %O が %keyPath が指す部位に~propを持たないならば：
</p>

<pre>
%keyPath = `foo.bar^l
%O = { foo: {} }
</pre>

<p>
%O が保管庫に保存されるときには， %生成key がその~prop（ここでは
%O`.foo.bar^c
）の値にあてがわれる：
</p>

<pre>
%R の`値$ = { foo: { <mark>bar: %生成key</mark> } }
</pre>

<p>
逆に、 %O が %keyPath が指す部位に~propを持つ場合：
</p>

<pre>
%O = { foo: { bar: <mark>10</mark> } }
</pre>

<p>
%生成key は利用されず、 %R の~keyには %keyPath が指す部位の値（この例では <mark>10</mark> ）が， 利用される。
</p>

<p>
~systemは、~prop階層を満たすに必要な分の~propを作成する責を負う。
例えば：
</p>

<pre>
%keyPath = `foo.bar.baz^l
%O = {}
</pre>

<p>
であれば、 %O が`保管庫$に保存されるときには，［
`foo^c, `bar^c, `baz^c
］~propが順に入れ~~子にされた上で，
%keyPath が指す部位に %生成key があてがわれる：
</p>

<pre>
%R の`値$ = { foo: { bar: { baz: %生成key } } }
</pre>

<p>
~primitive値~上に~propを格納しようと試みられた場合、失敗して~errorが投出されることになる。
例えば：
</p>

<pre>
%keyPath = `foo^l
%O = 4
</pre>

<p>
であれば、%O は~primitive値なので~propを定義できず，失敗する。
これは、配列（ 例えば %O = `[10]^c ）にも該当する。
配列~上にも~propは許容されないので、~propを定義しようと試行しても失敗する：
</p>

<p class="trans-note">【
原文の記述構成は（少なくとも，そのまま訳すと）解りにくいので、この例の訳は等価な記述に全面的に構成し直している。
】</p>

<div lang="en">

<p>If the following conditions are true:</p>
<ul>
<li>The object store has a key generator.</li>
<li>There is no in-line value for the key path property.</li>
</ul>
<p>
Then the value provided by the key generator is used to populate the key value.
In the example below the key path for the object store is "foo.bar".
The actual object has no value for the bar property, { foo: {} }.
When the object is saved in the object store the bar property is assigned a value of 1
because that is the next key generated by the key generator.
</p>
<pre>
var store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: {} }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 1);
};
</pre>
<p>If the following conditions are true:</p>
<ul>
<li>The object store has a key generator.</li>
<li>There is a value for the key path property.</li>
</ul>
<p>
Then the value associated with the key path property is used.
The auto-generated key is not used.
In the example below the key path for the object store is "foo.bar".
The actual object has a value of 10 for the bar property, { foo: { bar: 10} }.
When the object is saved in the object store the bar property keeps its value of 10, because that is the key value.
</p>

<pre>
var store = db.createObjectStore("store", { keyPath: "foo.bar", autoIncrement: true });
store.put({ foo: { bar: 10 } }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 10);
};
</pre>
<p>
The following example illustrates the scenario when the specified in-line key is defined through a key path but there is no property matching it.
The value provided by the key generator is then used to populate the key value and the system is responsible
for creating as many properties as it requires to suffice the property dependencies on the hierarchy chain.
In the example below the key path for the object store is "foo.bar.baz".
The actual object has no value for the foo property, { zip: {} }.
When the object is saved in the object store the foo, bar, and baz properties
are created each as a child of the other until a value for foo.bar.baz can be assigned.
The value for foo.bar.baz is the next key generated by the object store.
</p>
<pre>
var store = db.createObjectStore("store", { keyPath: "foo.bar.baz", autoIncrement: true });
store.put({ zip: {} }).onsuccess = function(e) {
  var key = e.target.result;
  console.assert(key === 1);
  store.get(key).onsuccess = function(e) {
    var value = e.target.result;
    // value will be: { zip: {}, foo: { bar: { baz: 1 } } }
    console.assert(value.foo.bar.baz === 1);
  };
};
</pre>
<p>
Attempting to store a property on a primitive value will fail and throw an error.
In the first example below the key path for the object store is "foo".
The actual object is a primitive with the value, 4.
Trying to define a property on that primitive value fails.
The same is true for arrays.  Properties are not allowed on an array.
In the second example below, the actual object is an array, [10].
Trying to define a property on the array fails.
</p>
<pre>
var store = db.createObjectStore("store", { keyPath: "foo", autoIncrement: true });

// The key generation will attempt to create and store the key path property on this primitive.
store.put(4); // will throw DataError

// The key generation will attempt to create and store the key path property on this array.
store.put([10]); // will throw DataError
</pre>

</div>
</aside>

		</section>
	</section>
	<section id="exceptions">
<h3 title="Exceptions">3. 例外</h3>

<p>
この文書にて定義される例外のそれぞれは，特定の型の `DOMException$I である。
例外の型と その~code値などの~propは `WEBIDL$r にて定義される。
◎
Each of the exceptions defined in this document is a DOMException with a specific type. The exception types and properties such as code value are defined in [WEBIDL].
</p>

<table class="_row">
<thead><tr><th>例外~名
</th><th>意味
</th></tr></thead>

<tbody><tr><td>`AbortError@E
</td><td>
`要請$は中止された。
◎
A request was aborted.

</td></tr><tr><td>`ConstraintError@E
</td><td>
~txにおける変異~演算は、拘束が充足されないため，失敗した。
◎
A mutation operation in the transaction failed because a constraint was not satisfied.

</td></tr><tr><td>`DataCloneError@E
</td><td>
格納しようと試みた~dataは、`有構造~clone~algo$により~cloneできなかった。
◎
The data being stored could not be cloned by the internal structured cloning algorithm.

</td></tr><tr><td>`DataError@E
</td><td>
演算に提供された~dataは、要件を満たしていない。
◎
Data provided to an operation does not meet requirements.

</td></tr><tr><td>`InvalidAccessError@E
</td><td>
~obj上に妥当でない演算が遂行された。
◎
An invalid operation was performed on an object.

</td></tr><tr><td>`InvalidStateError@E
</td><td>
所与の演算は~obj上に許容されない, あるいは許容されない時機に~callされた。
または、すでに削除された／除去された~source~objに対し要請が発行0された。
◎
An operation was called on an object on which it is not allowed or at a time when it is not allowed, or if a request is made on a source object that has been deleted or removed.

</td></tr><tr><td>`NotFoundError@E
</td><td>
要請された~db~objを見出せなかったため、演算は失敗した。
◎
The operation failed because the requested database object could not be found.

</td></tr><tr><td>`QuotaExceededError@E
</td><td>
残りの蓄積~~容量が十分でないため、あるいは，蓄積~quotaに到達したが，利用者が~dbへの容量追加を辞退しため、演算は失敗した。
◎
The operation failed because there was not enough remaining storage space, or the storage quota was reached and the user declined to give more space to the database.

</td></tr><tr><td>`SyntaxError@E
</td><td>
渡された %keyPath 引数は，`妥当な~key~path$でない。
◎
The keyPath argument contains an invalid key path.

</td></tr><tr><td>`ReadOnlyError@E
</td><td>
`~readonly~tx$において，変異~演算が試みられた。
◎
The mutating operation was attempted in a read-only transaction.

</td></tr><tr><td>`TransactionInactiveError@E
</td><td>
現在 `作動中$でない／すでに`終了-$した~txに対し，要請が設置された。
◎
A request was placed against a transaction which is currently not active, or which is finished.

</td></tr><tr><td>`UnknownError@E
</td><td>
演算は、~db自身に関係ない, かつ
他の~errorにも該当しない事由で，失敗した。
◎
The operation failed for reasons unrelated to the database itself and not covered by any other errors.

</td></tr><tr><td>`VersionError@E
</td><td>
既存の~versionより低い~versionで~dbを~openしようと試みられた。
◎
An attempt was made to open a database using a lower version than the existing version.
</td></tr></tbody></table>


<p class="note">注記：
複数の Indexed DB 演算が，同じ型の~errorを投出したり、単独の演算であっても，複数の事由に対し同じ型の~errorを投出し得るので、実装には、より~~詳細な~messageを提供して，~errorを~debugし易くすることが奨励される。
◎
Given that multiple Indexed DB operations can throw the same type of error, and that a even single operation can throw the same type of error for multiple reasons, implementations are encouraged to provide more specific messages to enable developers to identify the cause of errors.
</p>



	</section>
	<section id="async-api">

<h2 title="APIs">4. ~API</h2>

<p>
各種~API~methodは、それを~callした~threadを阻むことなく返す。
すべての非同期的な演算は、即時に `IDBRequest$I ~instanceを返す。
この~objは、初期~時には，演算の結果について，いかなる情報も包含しない。
情報が可用になったなら、要請に向けて~eventが発火され，情報は `IDBRequest$I ~instanceの各種~属性を通して可用になる。
◎
The API methods return without blocking the calling thread. All asynchronous operations immediately return an IDBRequest instance. This object does not initially contain any information about the result of the operation. Once information becomes available, an event is fired on the request and the information becomes available through the properties of the IDBRequest instance.
</p>

<p>
`~db~access~task源@
が、これらの~task用の`~task源$である。
◎
The task source for these tasks is the database access task source.
 </p>

		<section id="request-api">

<h3 title="The IDBRequest interface">4.1. `IDBRequest^I ~interface</h3>

<p>
`IDBRequest$I ~interfaceが、`~db$や, それに専属する各種~objに対する非同期的な`要請$の結果に~accessする手段を，`~event~handler IDL 属性$ `HTML$r を利用して提供する。
◎
The IDBRequest interface provides the means to access results of asynchronous requests to databases and database objects using event handler IDL attributes [HTML].
</p>

<p>
~dbに対し`演算$を要請するような どの~methodも，［
~eventを通して，要請している~appに`結果$を~~返信する
］ような， `IDBRequest$I ~objを返す。
すなわち，`演算$は非同期に実行される。
この設計は、どの`~db$に対しても，いくつもの要請が同時に作動中になり得ることを意味する。
◎
Every method for making asynchronous requests returns an IDBRequest object that communicates back to the requesting application through events. This design means that any number of requests can be active on any database at a time.
</p>


<aside class="example">

<p>
次の例では、`~db$を非同期に~openする。
種々の状況に応答するために、種々の~event~handlerが登録される。
◎
In the following example, we open a database asynchronously. Various event handlers are registered for responding to various situations.
</p>

<pre>
var request = indexedDB.open(`AddressBook^l, `15^lt);
request.onsuccess = function(evt) {...};
request.onerror = function(evt) {...};</pre>
</aside>


⇒！
[`Exposed$=(Window,Worker)]
interface `IDBRequest@I : `EventTarget$I {
    readonly attribute any                  `result$m;
    readonly attribute `DOMException$I?        `error$m;
    readonly attribute (`IDBObjectStore$I or `IDBIndex$I or `IDBCursor$I)? `source$m;
    readonly attribute `IDBTransaction$I?      `transaction$m;
    readonly attribute `IDBRequestReadyState$I `readyState$m;

    // <span class="comment" title="Event handlers">~event~handler：</span>
             attribute `EventHandler$I         `onsuccess$m;
             attribute `EventHandler$I         `onerror$m;
};

enum `IDBRequestReadyState@I {
    `pending$l,
    `done$l
};
◎

<!-- `IDBRequest!I -->

<dl class="idl-def">
	<dt>readonly any `result@m</dt>
	<dd>
<p>
取得子は、~MUST_RUN：
</p>
		<ol>
			<li>
~IF［
此れの`~done~flag$ ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
</li>
			<li>
<p>
~RET ［
此れの`結果$ ~NEQ ε ならば それ ／
~ELSE_（すなわち此れの`~error$ ~NEQ ε ならば） `undefined^js
］
</p>
<p class="trans-note">【
結果 ~NEQ ε の場合でも， `undefined^js を返す場合がある。
例えば `IDBObjectStore.get()$m による`要請$。
】</p>
			</li>
		</ol>

◎
The result attribute’s getter must throw an InvalidStateError if the done flag is unset. Otherwise, the attribute’s getter must return the result of the request, or undefined if the request resulted in an error.
</dd>

	<dt>readonly `DOMException$I? `error@m</dt>
	<dd>
<p>
取得子は、~MUST_RUN：
</p>
		<ol>
			<li>
~IF［
此れの`~done~flag$ ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
</li>
			<li>
~RET［
此れの`~error$ ~NEQ ε ならば それ ／
~ELSE_（すなわち此れの`結果$ ~NEQ ε ならば） ~NULL
］
</li>
		</ol>
◎
The error attribute’s getter must throw an InvalidStateError if the done flag is unset. Otherwise, the attribute’s getter must return the error of the request, or null if no error occurred.
</dd>

	<dt>readonly (IDBObjectStore or IDBIndex or IDBCursor)? `source@m</dt>
	<dd>
取得子は、［
此れの`~source$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The source attribute’s getter must return the source of the request, or null if no source is set.
</dd>

	<dt>readonly `IDBTransaction$I? `transaction@m</dt>
	<dd>
取得子は、此れの［
`設置先~tx$ ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］を返さ~MUST。
`IDBFactory.open()$m から返される`要請$など，`設置先~tx$が無い要請に対しては、 ~NULL を返すことになる。
◎
The transaction attribute’s getter must return the transaction of the request. This property can be null for certain requests, such as for request returned from open().
</dd>

	<dt>readonly `IDBRequestReadyState$I `readyState@m</dt>
	<dd>
取得子は、此れの`~done~flag$に応じて［
~OFF ならば
`pending@l ／
~ON ならば
`done@l
］を返さ~MUST。
◎
The readyState attribute’s getter must return "pending" if the done flag is unset, and "done" otherwise.
</dd>

	<dt>`EventHandler$I `onsuccess@m</dt>
	<dd>
`success$et ~eventに対する~event~handler。
◎
The onsuccess attribute is the event handler for the success event.
</dd>

	<dt>`EventHandler$I `onerror@m</dt>
	<dd>
`error$et ~eventに対する~event~handler。
◎
The onerror attribute is the event handler for the error event.
</dd>

</dl>



<p>
`IDBDatabase$I 上の `~open要請$を返す各種~methodは、［
`blocked$et, `upgradeneeded$et
］~eventを~listenできるように拡張された~interfaceを利用する。
◎
Methods on IDBDatabase that return a open request use an extended interface to allow listening to the blocked event and upgradeneeded event.
</p>

⇒！
[`Exposed$=(Window,Worker)]
interface `IDBOpenDBRequest@I : `IDBRequest$I {
    // <span class="comment" title="Event handlers">~event~handler：</span>
             attribute `EventHandler$I `onblocked$m;
             attribute `EventHandler$I `onupgradeneeded$m;
};
◎

<dl class="idl-def">
	<dt>`EventHandler$I `onblocked@m</dt>
	<dd>
`blocked$et ~eventに対する~event~handler。
◎
The onblocked attribute is the event handler for the blocked event.
</dd>

	<dt>`EventHandler$I `onupgradeneeded@m</dt>
	<dd>
`upgradeneeded$et に対する~event~handler。
◎
The onupgradeneeded attribute is the event handler for the upgradeneeded event.
</dd>

</dl>

		</section>
		<section id="events">

<h3 title="Event interfaces">4.2. ~event~interface</h3>

<p>
この仕様は、次の~custom~interfaceによる~eventを発火する：
◎
This specification fires events with the following custom interfaces:
</p>

⇒！
[`Exposed$=(Window,Worker),
Constructor(DOMString %type, optional `IDBVersionChangeEventInit$I %eventInitDict)]
interface `IDBVersionChangeEvent@I : `Event$I {
    readonly attribute unsigned long long  `oldVersion$m;
    readonly attribute unsigned long long? `newVersion$m;
};

dictionary `IDBVersionChangeEventInit@I : `EventInit$I {
    unsigned long long  `oldVersion@m = 0;
    unsigned long long? `newVersion@m = null;
};
◎

<!-- `IDBVersionChangeEvent!I -->

<dl class="idl-def">

	<dt>readonly unsigned long long `oldVersion@m</dt>
	<dd>
~dbの以前の`~version$dbを返す。
◎
The oldVersion attribute getter returns the previous version of the database.
</dd>

	<dt>readonly unsigned long long? `newVersion@m</dt>
	<dd>
~dbの新たな`~version$dbを返す。
ただし、~dbが削除されつつあるときは ~NULL になる。
`昇格~txを稼働-$させる手続きを見よ。
◎
The newVersion attribute getter returns the new version of the database, or null if the database is being deleted. See the steps for running an upgrade transaction.
</dd>

</dl>

<p>
~eventは、 `DOM$r の`~eventの構築法$による定義に従って構築される。
◎
Events are constructed as defined in Constructing events, in [DOM].
</p>


<div class="p">
<p>
%標的 に向けて
`~version変更~eventを発火する@
ときは、与えられた：
</p>

<ul class="input-params"
	><li>%名前 ： `~event~handler~event型$
<li><li>
%旧~version ： 変更~前の~version
<li><li>
%新~version ： 変更~後の~version
</li></ul>

<p>
に対し、 %標的 に向けて次の様にされた~eventを発火する
⇒
`IDBVersionChangeEvent!I ~interfaceを実装する；<br>
`type^m ~SET %名前；<br />
`oldVersion^m ~SET %旧~version；<br>
`newVersion^m ~SET %新~version；<br />
浮上しない；<br>
取消不可
</p>

◎
To fire a version change event named e at target given oldVersion and newVersion, dispatch an event at target. The event must use the IDBVersionChangeEvent interface with its type set to e, its oldVersion attribute set to oldVersion, and its newVersion attribute set to newVersion. This event must not bubble or be cancelable.
</div>

		</section>
		<section id="_event-types">

<h3 class="trans-note">【 各種~event型 】</h3>

<p>
便宜のため、この訳では，この仕様にて利用される各種~event型を以下に要約する：
</p>

<p>
この仕様の~eventの発火-先は、［
`要請$／`~tx$／`接続$
］のいずれかである。
~eventは、`親~標的を取得-$する~algoを通して，複数の~objに伝播する場合もあることに注意。
親~標的は、［
`~open要請$に対しては ~NULL ／
他の`要請$に対しては その`設置先~tx$ ／
`~tx$に対しては それが`専属する$`接続$ ／
`接続$に対しては ~NULL
］になる。
</p>

<dl>
	<dt>`success@et</dt>
	<dd>
`要請$が成功したときに，その要請に向けて発火される。
</dd>

	<dt>`error@et</dt>
	<dd>
何らかの~errorにより`要請$が失敗したときに，その要請に向けて発火される。
</dd>

	<dt>`versionchange@et</dt>
	<dd>
`~db$の`~version$dbが更新されたとき、その~dbに接続している各 `接続$（~versionを更新させた当の`接続$は除く）に向けて，発火される。
</dd>

	<dt>`abort@et</dt>
	<dd>
`~tx$が~errorにより`中止-$されたときに，その~txに向けて発火される。
</dd>

	<dt>`close@et</dt>
	<dd>
`接続$が
<a href="#_exceptional-close" >例外的な状況で~closeされた</a>
ときに，その接続に向けて発火される。
</dd>

	<dt>`complete@et</dt>
	<dd>
`~tx$が`~commit$されたときに，その~txに向けて発火される。
</dd>

	<dt>`blocked$et</dt>
	<dd>
他の`接続$がまだ `~close済み$i でないために，［
`~dbを~open$する ／
`~dbを削除-$する
］`要請$が阻まれたとき、その要請に向けて発火される。
</dd>

	<dt>`upgradeneeded$et</dt>
	<dd>
`~db$を~openしたとき`昇格~tx$が生じたときに，その`~open要請$に向けて発火される。
</dd>

</dl>

		</section>
		<section id="requests">
<h3 title="The IDBFactory interface">4.3. `IDBFactory^I ~interface</h3>

<p>
`~db$~objは、 `IDBFactory$I ~interface上の各種~methodを通して~accessされる。
この~interfaceを実装する単独の~objは、 Indexed DB 演算を~supportする環境の大域~scopeに存在する。
◎
Database objects are accessed through methods on the IDBFactory interface. A single object implementing this interface is present in the global scope of environments that support Indexed DB operations.
</p>

⇒！
partial interface `WindowOrWorkerGlobalScope!I {
    readonly attribute `IDBFactory$I `indexedDB$m;
};
◎

<dl class="idl-def">

	<dt>readonly `IDBFactory$I `indexedDB@m</dt>
	<dd>
この属性は、索引付き~dbの能力に~accessするための仕組みを，~appに提供する。
◎
The indexedDB attribute provides applications a mechanism for accessing capabilities of indexed databases.
</dd>

</dl>


⇒！
[`Exposed$=(Window,Worker)]
interface `IDBFactory@I {
    `IDBOpenDBRequest$I `open$m(
        DOMString %name,
        [`EnforceRange$] optional unsigned long long %version
    );
    `IDBOpenDBRequest$I `deleteDatabase$m(
        DOMString %name
    );

    short `cmp$m(
        any %first,
        any %second
    );
};
◎

<dl class="idl-def">

	<dt>`IDBOpenDBRequest$I `open@m(%name, %version)</dt>
	<dd class="_summary">
`~version$db %version の下で，`名前$db %name の`~db$を~openするような`~open要請$を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The open(name, version) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
%version ~EQ 0
］
⇒
~THROW `TypeError$js
◎
If version is 0 (zero), throw a TypeError.
</li>
			<li>
%要請 ~LET 新たな`~open要請$
◎
Let request be a new open request.
</li>
			<li>
<p>
次の下位手続きを並列的に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
<p>
%結果 ~LET 次を入力に
`~dbを~open$した結果
⇒
%生成元 ~SET 此れへの~accessに利用された大域~scope（ `WindowOrWorkerGlobalScope$I ）の`生成元$；<br>
%名前 ~SET %name；<br>
%~version ~SET %version；<br />
%要請 ~SET %要請；<br />
◎
Let result be the result of running the steps for opening a database, with the origin of the global scope used to access this IDBFactory, name, version if given and undefined otherwise, and request. 
</p>

<p class="note">注記：
名前 %name の`~db$が存在しない場合、新たな`~db$が作成されることになる。
%version が与えられていない場合、接続は，［
既存の~dbに対しては，その`~version$dbを変更することなく
］／［
新たな~dbに対してはその`~version$dbを 1 にして
］~openすることになる。
◎
If version is not given and a database with that name already exists, a connection will be opened without changing the version. If version is not given and no database with that name exists, a new database will be created with version equal to 1.
</p>
					</li>
					<li>
<p>
次の下位手続きを走らす`~taskを待入する$：
◎
Queue a task to run these substeps:
</p>
						<ol>
							<li>
~IF［
%結果 は~errorである
］
⇒
%要請 の`~error$ ~SET %結果；<br>
%要請 に向けて 次の様にされた~eventを発火する
⇒
`Event$I ~interfaceを利用する；<br />
`type^m ~SET `error$et；<br />
浮上しない；<br />
取消不可
◎
If result is an error, set the error of request to result and dispatch an event at request. The event must use the Event interface and set the type attribute to "error". The event does bubble but is not cancelable.
</li>
							<li>
<div class="p">
<p>
~ELSE
⇒
%要請 の`結果$ ~SET %結果；<br />
%要請 に向けて 次の様にされた~eventを発火する
⇒
`Event$I ~interfaceを利用する；<br />
`type^m ~SET `success$et；<br />
浮上しない；<br />
取消不可
</p>

<p>†
上の`~dbを~open$する手続きが`昇格~txを稼働-$させた場合、
`success$et ~eventの発火は，その昇格~txが完了した後に行われ~MUST。
</p>
◎
Otherwise, set the result of request to result and dispatch an event at request. The event must use the Event interface and set the type attribute to "success". The event does not bubble and is not cancelable. If the steps above resulted in an upgrade transaction being run, then firing the "success" event must be done after the upgrade transaction completes.
</div>

<p class="note">注記：
†最後の要件は、別の~versionへの昇格が起こりつつある場合に，最初に`接続$上に `success$et ~eventを発火して、~scriptが［
`versionchange$et ~eventに対する~listenerを登録する機会
］を得られるようにするためにある。
`？^tnote
◎
The last requirement is to ensure that in case another version upgrade is about to happen, the success event is fired on the connection first so that the script gets a chance to register a listener for the versionchange event.
</p>

<p class="note">注記：
`success$et ／ `error$et
~eventの発火は、通常の［
`~success~eventを発火する$ ／
`~error~eventを発火する$
］手続きに従わない
— 発火する時点では`作動中$の~txはないので。
◎
The firing of "success" or "error" events do not follow the normal steps to fire a success event or fire an error event as there is no active transaction at the time when they fire.
</p>
							</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>
~RET %要請 を表現する，新たな `IDBOpenDBRequest$I ~obj
◎
Return a new IDBOpenDBRequest object for request.
</li>
		</ol>
	</dd>

	<dt>`IDBOpenDBRequest$I `deleteDatabase@m(%name)</dt>
	<dd class="_summary">
`生成元$に`専属する$`~db$のうち，`名前$db %name のものを削除する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The deleteDatabase(name) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%要請 ~LET 新たな`~open要請$
◎
Let request be a new open request.
</li>
			<li>
<p>
次の下位手続きを並列的に走らす：
◎
Run the following substeps in parallel:
</p>
				<ol>
					<li>
%結果 ~LET 次を入力に
`~dbを削除-$した結果
⇒
%生成元 ~SET 此れへの~accessに利用された大域~scope（ `WindowOrWorkerGlobalScope$I ）の`生成元$；<br />
%名前 ~SET %name；<br />
%要請 ~SET %要請
◎
Let result be the result of running the steps for deleting a database, with the origin of the global scope used to access this IDBFactory, name, and request.
</li>
					<li>
<p>
次の下位手続きを走らす`~taskを待入する$：
◎
Queue a task to run these substeps:
</p>
						<ol>
							<li>
~IF［
%結果 は~errorである
］
⇒
%要請 の`~error$ ~SET %結果 ；<br>
%要請 に向けて 次の様にされた~eventを`発火する$
⇒
`Event$I ~interfaceを利用する；<br />
`type^m ~SET `error$et；<br />
浮上しない；<br />
取消不可
◎
If result is an error set the error of request to result and dispatch an event at request. The event must use the Event interface and set the type attribute to "error". The event does bubble but is not cancelable.
</li>
							<li>
~ELSE
⇒
%要請 の`結果$ ~SET ε；<br>
次を入力に
%要請 に向けて`~version変更~eventを発火する$
⇒
%名前 ~SET `success$et；<br>
%旧~version ~SET %結果；<br>
%新~version ~SET ~NULL
◎
Otherwise, set the result of request to undefined and fire a version change event named success at request with result and null.
</li>
						</ol>
<p class="note">注記：
`success$et ／ `error$et
~eventの発火は、通常の［
`~success~eventを発火する$ ／
`~error~eventを発火する$
］手続きに従わない
— 発火する時点では`作動中$の~txはないので。
◎
The firing of "success" or "error" events do not follow the normal steps to fire a success event or fire an error event as there is no active transaction at the time when they fire.
</p>
					</li>
				</ol>
			</li>
			<li>
~RET %要請 を表現する，新たな `IDBOpenDBRequest$I ~obj
◎
Return a new IDBOpenDBRequest object for request.
</li>
		</ol>
	</dd>

	<dt>short `cmp@m(%first, %second)</dt>
	<dd class="_summary">
二つの`~key$を比較した結果を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The cmp(first, second) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%a ~LET `Key$( %first ) ？
◎
Let a be the result of running the steps to convert a value to a key with first. Rethrow any exceptions.
◎
If a is invalid, throw a DataError.
</li>
			<li>
%b ~LET `Key$( %second ) ？
◎
Let b be the result of running the steps to convert a value to a key with second. Rethrow any exceptions.
◎
If b is invalid, throw a DataError.
</li>
			<li>
~RET `Cmp$( %a, %b )
◎
Return the results of running the steps to compare two keys with a and b.
</li>
		</ol>
	</dd>
</dl>
		</section>
		<section id="database-interface">

<h3 title="The IDBDatabase interface">4.4. `IDBDatabase^I ~interface</h3>
<!-- TODO Add example. Should examples be in a separate section?-->

<p>
`IDBDatabase$I ~interfaceは、`~db$への`接続$を表現する。
◎
The IDBDatabase interface represents a connection to a database.
</p>

<div class="p">
<p>
［
次の両条件を満たしている`接続$
］を表現する `IDBDatabase$I ~objは、~garbage収集されては~MUST_NOT：
</p>

<ul>
	<li>
`状態$Cn ~EQ `~open中$i
</li>
	<li>
［
`abort$et, `error$et, `versionchange$et
］いずれかの型の~event~listenerが登録されている
</li>
</ul>



<p>
`IDBDatabase$I ~objを~garbage収集するときは、その前に，それが表現する`接続$は`~close$され~MUST。
</p>

◎
An IDBDatabase object must not be garbage collected if its associated connection’s close pending flag is unset and it has one or more event listeners registers whose type is one of abort, error, or versionchange. If an IDBDatabase object is garbage collected, the associated connection must be closed.
</div>


⇒！
[`Exposed$=(Window,Worker)]
interface `IDBDatabase@I : `EventTarget$I {
    readonly attribute DOMString          `name$m;
    readonly attribute unsigned long long `version$m;
    readonly attribute `DOMStringList$I      `objectStoreNames$m;

    `IDBTransaction$I `transaction$m(
        (DOMString or sequence&lt;DOMString&gt;) %storeNames,
        optional `IDBTransactionMode$I %mode = `readonly$l
    );
    void `close$m();

    `IDBObjectStore$I `createObjectStore$m(
        DOMString %name,
        optional `IDBObjectStoreParameters$I %options
    );
    void `deleteObjectStore$m(
        DOMString %name
    );

    // <span class="comment" title="Event handlers">~event~handler：</span>
             attribute `EventHandler$I       `onabort$m;
             attribute `EventHandler$I       `onclose$m;
             attribute `EventHandler$I       `onerror$m;
             attribute `EventHandler$I       `onversionchange$m;
};

dictionary `IDBObjectStoreParameters@I {
    (DOMString or sequence&lt;DOMString&gt;)? `keyPath@m = null;
    boolean                             `autoIncrement@m = false;
};
◎

<!-- `IDBDatabase!I -->

<dl class="idl-def">


	<dt>readonly DOMString `name@m</dt>
	<dd>
取得子は、此れ↗の`名前$dbを返さ~MUST。
この属性は、`値を保持し続ける$。
◎
The name attribute’s getter must return the name of the connected database. The attribute must return this name even if the close pending flag is set on the connection. In other words, the value of this attribute stays constant for the lifetime of the IDBDatabase instance.
</dd>

	<dt>readonly unsigned long long `version@m</dt>
	<dd>
取得子は、此れの`~version$Cnを返さ~MUST。
◎
The version attribute’s getter must return this connection’s version.
</dd>

	<dd class="note">注記：
この属性は、此れの`状態$Cn ~EQ `~open中$i の間は，此れ↗の`~version$dbと同じ値を返し、それ以降も同じ`値を保持し続ける$。
◎
As long as the connection is open, this is the same as the connected database’s version. Once the connection has closed, this attribute will not reflect changes made with a later upgrade transaction.
</dd>

	<dt>readonly `DOMStringList$I `objectStoreNames@m</dt>
	<dd>
取得子は、此れの`保管庫~集合$Cn内の`保管庫$たちの`名前$Osからなる`整列済み~list$を返さ~MUST。
◎
The objectStoreNames attribute’s getter must return a sorted list of the names of the object stores in this connection’s object store set.
</dd>
	<dd class="note">
この属性は、此れの`状態$Cn ~EQ `~open中$i の間は，此れ↗に専属する`保管庫$たちの`名前$Osからなる~listと同じ値を返し、それ以降も同じ`値を保持し続ける$。
◎
As long as the connection is open, this is the same as the connected database’s object store names. Once the connection has closed, this attribute will not reflect changes made with a later upgrade transaction.
</dd>

	<dt>`IDBObjectStore$I `createObjectStore@m(%name, %options)</dt>
	<dd class="_summary">
接続先の`~db$内に，名前 %name の新たな`保管庫$を作成する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The createObjectStore(name, options) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%~tx ~LET 此れに`専属の昇格~tx$
◎
↓</li>
			<li>
~IF［
%~tx ~EQ ε
］
⇒
~THROW `InvalidStateError$E
◎
Let database be the database associated with this connection.
◎
Let transaction be the currently running upgrade transaction associated with database, or throw an InvalidStateError if none.
</li>
			<li>
~IF［
%~tx は`作動中$でない
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%keyPath ~LET %options の `keyPath^m ~member値
◎
Let keyPath be options’s keyPath member if it is not undefined or null, or null otherwise.
</li>
			<li>
~IF［
%keyPath ~NEQ ~NULL
］~AND［
%keyPath は`妥当な~key~path$でない
］
⇒
~THROW `SyntaxError$E
◎
If keyPath is not null and is not a valid key path, throw a SyntaxError.
</li>
			<li>
~IF［
此れの`保管庫~集合$Cn内に［
`名前$Os ~EQ %name
］なる`保管庫$がある
］
⇒
~THROW `ConstraintError$E
◎
If an object store named name already exists in database throw a ConstraintError.
</li>
			<li>
%自動生成 ~LET %options の `autoIncrement^c ~member値
◎
Let autoIncrement be set if options’s autoIncrement member is true, or unset otherwise.
</li>
			<li>
~IF［
%自動生成 ~EQ ~T
］
⇒
~IF［
%keyPath ~EQ 空~DS値
］~OR［
%keyPath は~SeqDS型である
］
⇒
~THROW `InvalidAccessError$E
◎
If autoIncrement is set and keyPath is an empty string or any sequence (empty or otherwise), throw an InvalidAccessError.
</li>
			<li>
%保管庫 ~LET 次の様にされた，新たな`保管庫$
⇒
此れ↗に`専属する$；<br />
`~record~list$Os ~SET 空~list；<br />
`名前$Os ~SET %name；<br />
`~key生成器$を［
%自動生成 ~EQ ~T ならば持つ ／
~ELSE_ 持たない
］；<br />
`~key~path$Os ~SET ［
%keyPath ~NEQ ~NULL ならば %keyPath ／
~ELSE_ ε
］
◎
Let store be a new object store in database. Set the created object store’s name to name. If autoIncrement is set, then the created object store uses a key generator. If keyPath is not null, set the created object store’s key path to keyPath.
</li>
			<li>
此れの`保管庫~集合$Cnに %保管庫 を追加する
`この段は、この訳による補完^tnote
</li>
			<li>
~RET 次の様にされた，新たな`保管庫~handle$ %H
⇒
%H↗ ~EQ %保管庫；<br />
%H は %~tx に`専属する$
◎
Return a new object store handle associated with store and transaction.
</li>
		</ol>

	</dd>
	<dd>
この~methodは、新たな`保管庫$を作成した上で，それを`~access先$とする新たな`保管庫~handle$を返す。
この~methodを~callできるのは、`昇格~txの中$からに限られることに注意。
◎
This method creates and returns a new object store with the given name in the connected database. Note that this method must only be called from within an upgrade transaction.
</dd>
	<dd>
この~methodは，此れ上の `objectStoreNames$m 属性を同期的に改変する。
◎
This method synchronously modifies the objectStoreNames property on the IDBDatabase instance on which it was called.
</dd>
	<dd>
<p>
実装によっては、この~methodが~~呼出し元に~~制御を返して，~db内に`保管庫$を作成する演算を待入した後に，問題になる可能性がある。
例えば、［
新たに作成された`保管庫$についての~metadataを，~dbに非同期に挿入する所
］，あるいは［
~quota事由から，利用者に許可を請う必要があり得る所
］で。
そうなり得る場合でも、実装は：
</p>

		<ul>
			<li>
依然として `IDBObjectStore$I ~objを作成して返さ~MUST。
</li>
			<li>
<p>
加えて，`保管庫$の作成ingに失敗したときは、［
失敗の事由に適切な~error名†
］を入力に
`~txを中止-$する手続きを行って，
%~tx を`中止-$し~MUST。
</p>

<p>†
例えば
~quota事由に因り`保管庫$の作成ingに失敗した場合は、 `QuotaExceededError$E を利用し~MUST。
</p>
			</li>
		</ul>

◎
In some implementations it is possible for the implementation to run into problems after queuing a task to create the object store after the createObjectStore() method has returned. For example in implementations where metadata about the newly created object store is inserted into the database asynchronously, or where the implementation might need to ask the user for permission for quota reasons. Such implementations must still create and return an IDBObjectStore object, and once the implementation determines that creating the object store has failed, it must abort the transaction using the steps for aborting a transaction using the appropriate error. For example if creating the object store failed due to quota reasons, QuotaExceededError must be used as error.
</dd>

	<dt>void `deleteObjectStore@m(%name)</dt>
	<dd class="_summary">
接続先の`~db$に`専属する$，名前 %name の`保管庫$を削除する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The deleteObjectStore(name) method, when invoked, must run these steps:
</p>


		<ol>
			<li>
%~tx ~LET 此れに`専属の昇格~tx$
◎
↓</li>
			<li>
~IF［
%~tx ~EQ ε
］
⇒
~THROW `InvalidStateError$E
◎
Let database be the database associated with this connection.
◎
Let transaction be the currently running upgrade transaction associated with database, or throw an InvalidStateError if none.
</li>
			<li>
~IF［
%~tx は`作動中$でない
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%保管庫 ~LET 此れの`保管庫~集合$Cn内の［
`名前$Os ~EQ %name
］なる`保管庫$
◎
Let store be the object store named name in database, or throw a NotFoundError if none.
</li>
			<li>
~IF［
%保管庫 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
↑</li>
			<li>
此れの`保管庫~集合$Cnから %保管庫 を除去する
◎
Remove store from this connection’s object store set.
</li>
			<li>
~IF［
%~tx に`専属する$, かつ
%保管庫 を`~access先$とする`保管庫~handle$ %H がある
］
⇒
%H の`索引~集合$OsHを空にする
◎
If there is an object store handle associated with store and transaction, remove all entries from its index set.
</li>
			<li>
此れ↗内の %保管庫 を（ %保管庫 に`専属する$`索引$たちも込みで）破壊する
◎
Destroy store.
</li>
		</ol>
	</dd>
	<dd>
この~methodは、この`接続$↗に専属している，名前 %name の`保管庫$を破壊する。
この~methodを~callできるのは、`昇格~txの中$からに限られることに注意。
◎
This method destroys the object store with the given name in the connected database. Note that this method must only be called from within an upgrade transaction.
</dd>
	<dd>
この~methodは，此れ上の `objectStoreNames$m 属性を同期的に改変する。
◎
This method synchronously modifies the objectStoreNames property on the IDBDatabase instance on which it was called.
</dd>

	<dt>`IDBTransaction$I `transaction@m(%storeNames, %mode = `readonly$l)</dt>
	<dd class="_summary">
この接続に`専属する$新たな`~tx$を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The transaction(storeNames, mode) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%mode ~NIN { `readonly$l, `readwrite$l }
］
⇒
~THROW `TypeError$js 
◎
If mode parameter is not "readonly" or "readwrite", throw a TypeError.
</li>
			<li>
~IF［
此れに`専属の昇格~tx$があって, `稼働中$である
］
⇒
~THROW `InvalidStateError$E
◎
If this method is called on IDBDatabase object for which an upgrade transaction is still running, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`状態$Cn ~NEQ `~open中$i
］
⇒
~THROW `InvalidStateError$E
◎
If this method is called on an IDBDatabase instance where the close pending flag is set, throw an InvalidStateError.
</li>
<li>
%視野 ~LET %storeNames の型に応じて
⇒
~SeqDSならば，その中の一意な文字列からなる集合（集合なので，重複するものは一つにする）；<br />
~DSならば，その文字列のみからなる集合
◎
Let scope be the set of unique strings in storeNames if it is a sequence, or a set containing one string equal to storeNames otherwise.
</li>
			<li>
~IF［
%視野 内に，此れの`保管庫~集合$Cn内のどの`保管庫$の`名前$Osにも一致しないものがある
］
⇒
~THROW `NotFoundError$E
◎
If any string in scope is not the name of an object store in the connected database, throw a NotFoundError.
</li>
			<li>
~IF［
%視野 は 空~集合である
］
⇒
~THROW `InvalidAccessError$E
◎
If scope is empty, throw an InvalidAccessError.
</li>
			<li>
%~tx ~LET 次のようにされた`新たな~tx$
⇒
`視野$ ~SET ［
此れの`保管庫~集合$Cn内の， %視野 により指示される`保管庫$たち
］からなる集合；<br />
`~mode$ ~SET %mode；<br />
`専属する$`接続$ ~SET 此れ；<br />
◎
Let transaction be a newly created transaction with connection, mode and the set of object stores named in scope.
</li>
			<li>
実装は、制御が~event~loopに返されたときには，［
`作動中~flag$ ~SET ~OFF
］にし~MUST。
◎
When control is returned to the event loop, the implementation must unset the active flag.
</li>
			<li>
<p>
~RET %~tx を表現する `IDBTransaction$I ~obj
◎
Return an IDBTransaction object representing transaction.
</p>

			</li>
		</ol>
	</dd>
	<dd class="note">注記：
作成された~txは、その`存続期間$の規則に従う。
◎
The created transaction will follow the lifetime rules.
</dd>

	<dt>void `close@m()</dt>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The close() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
次を入力に
`~db接続を~close$する
⇒
%接続 ~SET 此れ
◎
Run the steps for closing a database connection with this connection.
</li>
		</ol>
	</dd>

	<dt>`EventHandler$I `onabort@m</dt>
	<dd>
`abort$et ~eventに対する~event~handler。
◎
The onabort attribute is the event handler for the abort event.
</dd>

	<dt>`EventHandler$I `onclose@m</dt>
	<dd>
`close$et ~eventに対する~event~handler。
◎
The onclose attribute is the event handler for the close event.
</dd>
	<dd class="note">🚧
この属性は、この版による新規追加。
Chrome 31 と Firefox 50 で~supportされている。
🚧
◎
🚧 The onclose attribute is new in this edition. It is supported in Chrome 31 and Firefox 50. 🚧
</dd>

	<dt>`EventHandler$I `onerror@m</dt>
	<dd>
`error$et ~eventに対する~event~handler。
◎
The onerror attribute is the event handler for the error event.
</dd>

	<dt>`EventHandler$I `onversionchange@m</dt>
	<dd>
`versionchange$et ~eventに対する~event~handler。
◎
The onversionchange attribute is the event handler for the versionchange event.
</dd>

</dl>


		</section>
		<section id="object-store">

<h3 title="The IDBObjectStore interface">4.5. `IDBObjectStore^I ~interface</h3>

<p>
`IDBObjectStore$I ~interfaceは、`保管庫~handle$を表現する。
◎
The IDBObjectStore interface represents an object store handle.
</p>

⇒！
[`Exposed$=(Window,Worker)]
interface `IDBObjectStore@I {
             attribute DOMString      `name$m;
    readonly attribute any            `keyPath$m;
    readonly attribute `DOMStringList$I  `indexNames$m;
    readonly attribute `IDBTransaction$I `transaction$m;
    readonly attribute boolean        `autoIncrement$m;

    `IDBRequest$I `put$m(
        any %value,
        optional any %key
    );
    `IDBRequest$I `add$m(
        any %value,
        optional any %key
    );
    `IDBRequest$I `delete$m(
        any %query
    );
    `IDBRequest$I `clear$m();
    `IDBRequest$I `get$m(
        any %query
    );
    `IDBRequest$I `getKey$m(
        any %query
    );
    `IDBRequest$I `getAll$m(
        optional any %query,
        [`EnforceRange$] optional unsigned long %count
    );
    `IDBRequest$I `getAllKeys$m(
        optional any %query,
        [`EnforceRange$] optional unsigned long %count
    );
    `IDBRequest$I `count$m(
        optional any %query
    );

    `IDBRequest$I `openCursor$m(
        optional any %query,
        optional `IDBCursorDirection$I %direction = "next"
    );
    `IDBRequest$I `openKeyCursor$m(
        optional any %query,
        optional `IDBCursorDirection$I direction = "next"
    );

    `IDBIndex$I   `index$m(
        DOMString %name
    );

    `IDBIndex$I   `createIndex$m(
        DOMString %name,
        (DOMString or sequence&lt;DOMString&gt;) %keyPath,
        optional `IDBIndexParameters$I %options
    );
    void       `deleteIndex$m(
        DOMString %indexName
    );
};

dictionary `IDBIndexParameters@I {
    boolean `unique@m = false;
    boolean `multiEntry@m = false;
};
◎

<!-- `IDBObjectStore!I -->

<dl class="idl-def">

	<dt>DOMString `name@m</dt>
	<dd>
取得子は、此れの`名前$OsHを返さ~MUST。
◎
The name attribute’s getter must return this object store handle’s name.
</dd>
	<dd class="note">注記：
この属性は、此れが`専属する$~txが`終了-$されるまでは，此れ↗の`名前$Osと同じ値を返し、それ以降も同じ`値を保持し続ける$。
◎
As long as the transaction has not finished, this is the same as the associated object store’s name. Once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</dd>

	<dd>
<p>
設定子は、~MUST_RUN：
◎
The name attribute’s setter must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `versionchange^l ) ？
◎
Let name be the given value.
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎変則＊
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not an upgrade transaction, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%name ~LET 与えられた値
◎
↑</li>
			<li>
~IF［
此れの`名前$OsH ~EQ %name
］
⇒
~RET
◎
If store’s name is equal to name, terminate these steps.
</li>
			<li>
~IF［
此れが`専属する$`接続$の`保管庫~集合$Cnに［
`名前$Os ~EQ %name
］なる`保管庫$がある
］
⇒
~THROW `ConstraintError$E
◎
If an object store named name already exists in store’s database, throw a ConstraintError.
</li>
			<li>
此れ↗の`名前$Os ~SET %name
◎
Set store’s name to name.
</li>
			<li>
此れの`名前$OsH ~SET %name
◎
Set this object store handle’s name to name.
</li>
		</ol>
	</dd>
	<dd class="note">🚧
この設定子は、この版による新規追加。
Firefox 51 にて~supportされる。
🚧
◎
🚧 The name attribute’s setter is new in this edition. It will be supported in Firefox 51.🚧
</dd>

	<dt>readonly any `keyPath@m</dt>
	<dd>
取得子は、［
此れ↗の`~key~path$Os ~NEQ ε ならば それ ／
~ELSE_  ~NULL
］を返さ~MUST。
この属性は、`値を保持し続ける$。
◎
The keyPath attribute’s getter must return this object store handle’s object store’s key path, or null if none.
</dd>

	<dd id="_return-value-of-keypath">
<p>
~DS ／ ~SeqDS 値からの変換は、通常の `WEBIDL$r 言語束縛~logicに従って適切に行われる。
◎
The conversion is done following the normal [WEBIDL] binding logic for DOMString and sequence&lt;DOMString&gt; values, as appropriate.
</p>

<p>
返される値は、此れの作成時に利用した~instanceと同じではない。
しかしながら、この属性が~obj（すなわち, `Array$js ）を返す場合、毎回~同じ~instanceを返す。
返された~objの~prop値を変更しても，此れに効果を及ぼすことはない。
◎
The returned value is not the same instance that was used when the object store was created. However, if this attribute returns an object (specifically an Array), it returns the same object instance every time it is inspected. Changing the properties of the object has no effect on the object store.
</p>
	</dd>

	<dt>readonly `DOMStringList$I `indexNames@m</dt>
	<dd>
取得子は、［
此れの`索引~集合$OsH内の，すべての`索引$の`名前$Ix
］からなる`整列済み~list$を返さ~MUST。
◎
The indexNames attribute’s getter must return a sorted list of the names of indexes in this object store handle’s index set.
</dd>
	<dd class="note">注記：
この属性は、此れが`専属する$~txが`終了-$されるまでは，此れ↗に専属する`索引$たちの名前からなる~listと同じ値を返し、それ以降も同じ`値を保持し続ける$。
◎
As long as the transaction has not finished, this is the same as the associated object store’s list of index names. Once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</dd>

	<dt>readonly `IDBTransaction$I `transaction@m</dt>
	<dd>
取得子は、此れが`専属する$~txを返さ~MUST。
◎
The transaction attribute’s getter must return this object store handle’s transaction.
</dd>

	<dt>readonly boolean `autoIncrement@m</dt>
	<dd>
取得子は、［
此れ↗の`~key生成器$ ~EQ ε ならば ~F ／
~ELSE_ ~T
］を返さ~MUST。
この属性は、`値を保持し続ける$。
◎
The autoIncrement attribute’s getter must return true if this object store handle’s object store has a key generator, and false otherwise.
</dd>

	<dt>`IDBRequest$I `put@m(%value, %key)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Os内の［
%key を持つ`~record$（無ければ新たに作成する）
］の`値$を %value に更新するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The put(value, key) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `readwrite^l ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
</li>
			<li>
%keyPath ~LET 此れ↗の`~key~path$Os
</li>
			<li>
%生成器 ~LET 此れ↗の`~key生成器$
</li>
			<li>
~IF［
%keyPath ~NEQ ε
］~AND［
%key ~NEQ ε
］
⇒
~THROW `DataError$E
◎
If store uses in-line keys and key was given, throw a DataError.
</li>
			<li>
~IF［
%keyPath ~EQ ε
］~AND［
%key ~EQ ε
］~AND［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
◎
If store uses out-of-line keys and has no key generator and key was not given, throw a DataError.
</li>
			<li>
<p>
~IF［
%key ~NEQ ε
］
⇒
%key ~LET `Key$( %key ) ？
◎
If key was given, run these substeps:
◎
	Let r be the result of running the steps to convert a value to a key with key. Rethrow any exceptions.
◎
	If r is invalid, throw a DataError.
◎
	Let key be r.
</li>
			<li>
%clone ~LET `Clone$( %value ) ？
◎
Let clone be structured clone of value. Rethrow any exceptions.
</li>
			<li>
<p>
~IF［
%keyPath ~NEQ ε
］
⇒
%key ~LET `Extract$( %clone, %keyPath, %生成器 ) ？
◎
If store uses in-line keys, run these substeps:
◎
	Let kpk be the result of running the steps to extract a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
◎
	If kpk is invalid, throw a DataError.
◎
	If kpk is not failure, let key be kpk.
◎
	Otherwise, if store does not have a key generator, throw a DataError.
</li>
			<li>
%演算 ~SET 次を入力に
`保管庫に~recordを格納する$`演算$
⇒
%保管庫 ~SET 此れ↗；<br>
%値 ~SET %clone；<br>
%key ~SET %key；<br>
%上書不可~flag ~SET ~OFF
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for storing a record into an object store as operation, using store, the clone as value, key, and with the no-overwrite flag unset.
</li>
		</ol>
	</dd>

	<dt>`IDBRequest$I `add@m(%value, %key)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Osに，新たな`~record$を追加するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The add(value, key) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `readwrite^l ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
</li>
			<li>
%keyPath ~LET 此れ↗の`~key~path$Os
</li>
			<li>
%生成器 ~LET 此れ↗の`~key生成器$
</li>
			<li>
~IF［
%keyPath ~NEQ ε
］~AND［
%key ~NEQ ε
］
⇒
~THROW `DataError$E
◎
If store uses in-line keys and key was given, throw a DataError.
</li>
			<li>
~IF［
%keyPath ~EQ ε
］~AND［
%key ~EQ ε
］~AND［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
◎
If store uses out-of-line keys and has no key generator and key was not given, throw a DataError.
</li>
			<li>
<p>
~IF［
%key ~NEQ ε
］
⇒
%key ~LET `Key$( %key ) ？
◎
If key was given, run these substeps:
◎
	Let r be the result of running the steps to convert a value to a key with key. Rethrow any exceptions.
◎
	If r is invalid, throw a DataError.
◎
	Let key be r.
</li>
			<li>
%clone ~LET `Clone$( %value ) ？
◎
Let clone be structured clone of value. Rethrow any exceptions.
</li>
			<li>
<p>
~IF［
%keyPath ~NEQ ε
］
⇒
%key ~LET `Extract$( %clone, %keyPath, %生成器 ) ？
◎
If store uses in-line keys, run these substeps:
◎
	Let kpk be the result of running the steps to extract a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
◎
	If kpk is invalid, throw a DataError.
◎
	If kpk is not failure, let key be kpk.
◎
	Otherwise, if store does not have a key generator, throw a DataError.
</li>
			<li>
%演算 ~SET 次を入力に
`保管庫に~recordを格納する$`演算$
⇒
%保管庫 ~SET 此れ↗；<br>
%値 ~SET %clone；<br>
%key ~SET %key；<br>
%上書不可~flag ~SET ~ON
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for storing a record into an object store as operation, using store, clone as value, key, and with the no-overwrite flag set.
</li>
		</ol>
	</dd>


	<dt>`IDBRequest$I `delete@m(%query)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Osから［
%query に合致する~recordたち
］を削除するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The delete(query) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `readwrite^l ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
</li>
			<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query and null disallowed flag set. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`保管庫から~recordを削除する$`演算$
⇒
%保管庫 ~SET 此れ↗；<br>
%範囲 ~SET %範囲
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for deleting records from an object store as operation, using store and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、削除する`~record$たちの~keyを識別する
`~key$／`~key範囲$
をとり得る。
◎
The query parameter may be a key or an IDBKeyRange identifying the records keys to be deleted.
</dd>
	<dd class="note">注記：
他の~methodと違って、この~methodの %query 引数は，
<strong>省略可能でなく, また~NULL 値も許容されない</strong>（すなわち，`全範囲$は指定できない）。
これは、小さな~bugにより，保管庫すべてを~clearする~riskを抑制するためである。
◎
Unlike other methods which take keys or key ranges, this method does not allow null to be given as key. This is to reduce the risk that a small bug would clear a whole object store.
</dd>

	<dt>`IDBRequest$I `clear@m()</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Osを空にするよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The clear() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `readwrite^l ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
</li>
			<li>
%演算 ~SET 次を入力に
`保管庫を~clearする$`演算$
⇒
%保管庫 ~SET 此れ↗
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for clearing an object store as operation, using store.
</li>
		</ol>
	</dd>

	<dt>`IDBRequest$I `get@m(%query)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］のうち，最初の~recordの`値$を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The get(query) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
<p>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query and null disallowed flag set. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る最初の~entryを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Clone$( %record の`値$ )
］
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for retrieving a value from an object store as operation, using store and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$を識別する
`~key$／`~key範囲$
をとり得る。
範囲が指定された場合、~methodは，その範囲に入る最初の既存の値を検索取得する。
◎
The query parameter may be a key or an IDBKeyRange identifying the record to be retrieved. If a range is specified, the method retrieves the first existing value in that range.
</dd>
	<dd class="note">注記：
この~methodによる要請の`結果$は、所与の~keyを伴う~recordが存在しない場合も,
`値$が `undefined^js の~recordが存在する場合も，
`undefined^js 値になる。
両者を区別する必要があるときは、同じ~keyで `openCursor()$m を利用できる
— その`結果$は、~recordが存在しなければ ~NULL になる一方で，存在するときは［
`値$Cs ~SET `undefined^js†
］にされた`~cursor$になる。
<span class="trans-note">【†
この訳では、内部処理~modelにおいては，値 ε により，そのような~recordが存在する場合とを区別している。
】</span>
◎
This method produces the same result if a record with the given key doesn’t exist as when a record exists, but has undefined as value. If you need to tell the two situations apart, you can use openCursor() with the same key. This will return a cursor with undefined as value if a record exists, or no cursor if no such record exists.
</dd>

	<dt>`IDBRequest$I `getKey@m(%query)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］のうち，最初の~recordの`~key$を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The getKey(query) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle's transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query and null disallowed flag set. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る最初の~entryを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Clone$( %record の`~key$ )
］
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for retrieving a key from an object store as operation, using store and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$の~keyを識別する
`~key$／`~key範囲$
をとり得る。
範囲が指定された場合、~methodは，その範囲に入る最初の既存の~keyを検索取得する。
◎
The query parameter may be a key or an IDBKeyRange identifying the record key to be retrieved. If a range is specified, the method retrieves the first existing key in that range.
</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Firefox 51 にて~supportされる。
🚧
◎
🚧 The getKey() method on IDBObjectStore is new in this edition. It will be supported in Firefox 51. 🚧
</dd>


	<dt>`IDBRequest$I `getAll@m(%query, %count)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］のうち，最初から %count 個までの~recordたちの`値$を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The getAll(query, count) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
<p>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る~entryたちを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Clone$( %record の`値$ )
］；<br>
%count ~SET %count
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for retrieving multiple values from an object store as operation, using store, range, and count if given.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$たちを識別する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~record数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter may be a key or an IDBKeyRange identifying the records to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count records in range, only the first count will be retrieved.
</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Chrome 48 と Firefox 44 で~supportされている。
🚧
◎
🚧 The getAll() method is new in this edition. It is supported in Chrome 48 and Firefox 44. 🚧
</dd>


	<dt>`IDBRequest$I `getAllKeys@m(%query, %count)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］のうち，最初から %count 個までの~recordの`~key$を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The getAllKeys(query, count) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
<p>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る~entryたちを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Value1$( %record の`~key$ )
］；<br>
%count ~SET %count
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for retrieving multiple keys from an object store as operation, using store, range, and count if given.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$たちの~keyを識別する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~key数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter may be a key or an IDBKeyRange identifying the records keys to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count keys in range, only the first count will be retrieved.
</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Chrome 48 と Firefox 44 で~supportされている。
🚧
◎
🚧 The getAllKeys() method is new in this edition. It is supported in Chrome 48 and Firefox 44. 🚧
</dd>

	<dt>`IDBRequest$I `count@m(%query)</dt>
	<dd class="_summary">
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］の総数を得るよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The count(query) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る~recordを数える$`演算$
⇒
%source ~SET 此れ↗；<br>
%範囲 ~SET %範囲
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps to count the records in a range as operation, with source and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$たちの~keyを識別する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter may be a key or an IDBKeyRange identifying the records keys to be counted. If null or not given, an unbounded key range is used.
</dd>

	<dt>`IDBRequest$I `openCursor@m(%query, %direction = `next^l)</dt>
	<dd class="_summary">
［
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The openCursor(query, direction) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを作成-$する`演算$
⇒
%source ~SET 此れ；<br>
%方向 ~SET %direction；<br>
%範囲 ~SET %範囲；<br>
%~key~only~flag ~SET ~OFF
◎
Let cursor be a new cursor with transaction set to transaction, an undefined position, direction set to direction, got value flag unset, and undefined key and value. The source of cursor is store. The range of cursor is range.
</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for iterating a cursor with cursor as operation.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、`~cursor$の`範囲$Csとして利用する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter may be a key or an IDBKeyRange to use as the cursor’s range. If null or not given, an unbounded key range is used.
</dd>

	<dt>`IDBRequest$I `openKeyCursor@m(%query, %direction = `next^l)</dt>
	<dd class="_summary">
［
`保管庫$の`~record~list$Os内の［
%query に合致する~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
この`~cursor$は、~recordの~keyのみを取得する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The openKeyCursor(query, direction) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを作成-$する`演算$
⇒
%source ~SET 此れ；<br>
%方向 ~SET %direction；<br>
%範囲 ~SET %範囲；<br>
%~key~only~flag ~SET ~ON
◎
Let cursor be a new cursor with transaction set to transaction, an undefined position, direction set to direction, got value flag unset, and undefined key and value. The source of cursor is store. The range of cursor is range. The key only flag of cursor is set.
</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this object store handle as source and the steps for iterating a cursor with cursor as operation.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、`~cursor$の`範囲$Csとして利用する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter may be a key or an IDBKeyRange to use as the cursor’s range. If null or not given, an unbounded key range is used.
</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Chrome 48 と Firefox 44 で~supportされている。
🚧
◎
🚧 The openKeyCursor() method is new in this edition. It is supported in Chrome 48 and Firefox 44. 🚧
</dd>

	<dt>`IDBIndex$I `createIndex@m(%name, %keyPath, %options)</dt>
	<dd class="_summary">
`保管庫$内に，名前 %name の新たな`索引$を作成する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The createIndex(name, keyPath, options) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
`CheckState$( 此れ, `versionchange^l ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If transaction is not an upgrade transaction, throw an InvalidStateError.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
~IF［
此れの`索引~集合$OsHに［
`名前$Ix ~EQ %name
］なる`索引$がある
］
⇒
~THROW `ConstraintError$E
◎
If an index named name already exists in store, throw a ConstraintError.
</li>
			<li>
~IF［
%keyPath は`妥当な~key~path$でない
］
⇒
~THROW `SyntaxError$E
◎
If keyPath is not a valid key path, throw a SyntaxError.
</li>
			<li>
`一意?^V ~LET %options の `unique^m ~memberの値
◎
Let unique be set if options’s unique member is true, and unset otherwise.
</li>
			<li>
%multiEntry ~LET %options の `multiEntry^m ~memberの値
◎
Let multiEntry be set if options’s multiEntry member is true, and unset otherwise.
</li>
			<li>
~IF［
%keyPath は~SeqDS型である
］~AND［
%multiEntry ~EQ ~T
］
⇒
~THROW `InvalidAccessError$E
◎
If keyPath is a sequence and multiEntry is set, throw an InvalidAccessError.
</li>
			<li>
%索引 ~LET 次の様にされた新たな`索引$†
⇒
此れ↗に`専属する$；<br>
`名前$Ix ~SET %name；<br>
`~key~path$Ix ~SET %keyPath；<br>
`一意~flag$Ix ~SET `Flag$( `一意?^V )；<br>
`複entry~flag$Ix ~SET `Flag$( %multiEntry )
◎
Let index be a new index in store. Set index’s name to name and key path to keyPath. If unique is set, set index’s unique flag. If multiEntry is set, set index’s multiEntry flag.
</li>
			<li>
%索引 を此れの`索引~集合$OsHに追加する
◎
Add index to this object store handle’s index set.
</li>
			<li>
~RET 次のようにされた，新たな`索引~handle$ %H
⇒
%H↗ ~EQ %索引；<br />
%H は此れに`専属する$；<br />
`名前$IxH ~SET %name
◎
Return a new index handle associated with index and this object store handle.
</li>
		</ol>

<p class="trans-note">【†
索引の`~record~list$Ixは、自動的に此れの`~record~list$Osにより拡充されることになる。
】</p>

	</dd>
	<dd>
<p>
この~methodは、此れに`専属する$, 名前 %name の新たな`索引$を作成した上で、それを`~access先$とする 新たな`索引~handle$を返す。
この~methodを~callできるのは、`昇格~txの中$からに限られることに注意。
◎
This method creates and returns a new index with the given name in the object store. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
作成するよう要請された索引は、［
自身が`専属する$`保管庫$に許容される~data
］についての拘束を伴うこともある
— `一意~flag$Ixにより，索引の`~key~path$Ixが指す部位の値（`参照先の値$）の一意性が要求されるなど。
その保管庫が，この拘束に違反する~dataをすでに包含している場合でも、実装は，［
この~methodにて例外を投出したり，それが返すものに影響させる
］ことなく，依然として `IDBIndex^I ~objを作成して返さ~MUST。
代わりに実装は、［
この~methodの~callに利用された，`昇格~tx$
］を中止する`~taskを待入し$~MUST。
◎
The index that is requested to be created can contain constraints on the data allowed in the index’s referenced object store, such as requiring uniqueness of the values referenced by the index’s keyPath. If the referenced object store already contains data which violates these constraints, this must not cause the implementation of createIndex to throw an exception or affect what it returns. The implementation must still create and return an IDBIndex object, and the implementation must queue a task to abort the upgrade transaction which was used for the createIndex() call.
</p>

<p>
この~methodは、此れ上の `indexNames$m ~propを同期的に改変する。
この~methodは `IDBRequest$I ~objを返さないが、索引の作成~自体は，`昇格~tx$の中の非同期的な要請として，処理される。
◎
This method synchronously modifies the indexNames property on the IDBObjectStore instance on which it was called. Although this method does not return an IDBRequest object, the index creation itself is processed as an asynchronous request within the upgrade transaction.
</p>

<div class="p">
<p>
実装によっては、この~methodが`索引~handle$（ `IDBIndex^I ~obj）を返した後，`索引$を非同期に作成するときに，問題になる可能性がある。
例えば、［
新たに作成された索引の~metadataを~dbに挿入する~taskを待入する所
］，あるいは［
~quota事由から，利用者に許可を請う必要があり得る所
］で。
そのような場合でも，実装は：
</p>

		<ul>
			<li>
依然として、`索引~handle$を作成して返さ~MUST。
</li>
			<li>
<p>
加えて，`索引$の作成ingに失敗したときは、次を入力に
`~txを中止-$して，その~txを`中止-$し~MUST
⇒
%error ~SET 失敗の事由に適切な~error名
</p>

<p>
例えば、［
~quota事由に因り`索引$の作成ingに失敗した場合は `QuotaExceededError$E ／
`一意~flag$Ixの拘束に因り索引を作成できない場合は `ConstraintError$E
］を利用し~MUST。
</p>
			</li>
		</ul>
◎
In some implementations it is possible for the implementation to asynchronously run into problems creating the index after the createIndex method has returned. For example in implementations where metadata about the newly created index is queued up to be inserted into the database asynchronously, or where the implementation might need to ask the user for permission for quota reasons. Such implementations must still create and return an IDBIndex object, and once the implementation determines that creating the index has failed, it must abort the transaction using the steps for aborting a transaction using an appropriate error as error. For example if creating the index failed due to quota reasons, QuotaExceededError must be used as error and if the index can’t be created due to unique flag constraints, ConstraintError must be used as error.
</div>


<aside class="example">
<p>
索引の非同期的な作成は、次の例のように観測される：
◎
The asynchronous creation of indexes is observable in the following example:
</p>

<pre>
var request1 = objectStore.put({name: `betty^l}, `1^lt);
var request2 = objectStore.put({name: `betty^l}, `2^lt);
var index = objectStore.createIndex(`by_name^l, `name^l, {unique: true});
</pre>

<p>
`createIndex()^m が~callされた時点では，いずれの`要請$もまだ実行されていない。
二番目の要請が実行されるとき，同じ `name^js ~propを`値$に持つ`~record$が重複して作成される。
索引の作成は非同期的な`要請$と見なされ、索引の`一意~flag$Ixによる拘束は，二番目の`要請$を失敗させないので。
代わりに，`~tx$は、索引の作成時に拘束を満たせないときは，`中止-$されることになる。
◎
At the point where createIndex() called, neither of the requests have executed. When the second request executes, a duplicate name is created. Since the index creation is considered an asynchronous request, the index’s uniqueness constraint does not cause the second request to fail. Instead, the transaction will be aborted when the index is created and the constraint fails.
</p>
</aside>
	</dd>

	<dt>`IDBIndex$I `index@m(%name)</dt>
	<dd class="_summary">
［
この`保管庫~handle$の`索引~集合$OsH内の，名前 %name の`索引$
］を`~access先$とする`索引~handle$を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The index(name) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
~IF［
此れ↗は削除されている
］
⇒
~THROW `InvalidStateError$E
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If store has been deleted, throw an InvalidStateError.
</li>
			<li>
~IF
此れが`専属する$`~tx$は すでに`終了-$した
⇒
~THROW `InvalidStateError$E
◎
If transaction has finished, throw an InvalidStateError.
</li>
			<li>
%索引 ~LET 
此れの`索引~集合$OsH 内の`索引$のうち，［
`名前$Ix ~EQ %name
］なるもの
</li>
			<li>
~IF［
%索引 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
Let index be the index named name in this object store handle’s index set if one exists, or throw a NotFoundError otherwise.
</li>
			<li>
~RET 次を満たすような`索引~handle$ %H
⇒
%H↗ ~EQ %索引；<br />
%H は此れに`専属する$；<br />
`一意性$の要件を満たす（`可換性$の要件は、`索引~集合$OsHの構成から自動的に満たされる）
◎
Return an index handle associated with index and this object store handle.
</li>
		</ol>
	</dd>
	<dd class="note">注記：
`一意性$の要件から，返される~instanceは一意に定まる
`~instanceがその前のどの時点で作成されるかは，実装の詳細になる^tnote
。
よって、`昇格~tx$の間を除き、同じ `IDBObjectStore$I ~instance上で，同じ %name をこの~methodに渡して返される `IDBIndex$I ~instanceは、常に同じになる。
◎
Each call to this method on the same IDBObjectStore instance with the same name returns the same IDBIndex instance.
</dd>
	<dd class="note">注記：
%H は此れに`専属する$ので、他の `IDBObjectStore$I ~instanceに対し同じ %name で この~methodを呼出しても， %H と異なる `IDBIndex$I ~instanceが返される。
◎
The returned IDBIndex instance is specific to this IDBObjectStore instance. If this method is called on a different IDBObjectStore instance with the same name, a different IDBIndex instance is returned.
</dd>

	<dt>void `deleteIndex@m(%indexName)</dt>
	<dd class="_summary">
`保管庫$に`専属する$，名前 %indexName の`索引$を削除する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The deleteIndex(name) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
`CheckState$( 此れ, `versionchange^l ) ？
◎
Let transaction be this object store handle’s transaction.
◎
Let store be this object store handle’s object store.
◎
If transaction is not an upgrade transaction, throw an InvalidStateError.
◎
If store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%索引 ~LET 
此れ↗に`専属する$`索引$のうち，［
`名前$Ix ~EQ %indexName
］なるもの
◎
↓</li>
			<li>
~IF［
%索引 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
Let index be the index named name in store if one exists, or throw a NotFoundError otherwise.
</li>
			<li>
此れの`索引~集合$OsHから %索引 を除去する
◎
Remove index from this object store handle’s index set.
</li>
			<li>
%索引 を破壊する
◎
Destroy index.
</li>
		</ol>

<p>
この~methodは、此れ↗に専属する，名前 %indexName の`索引$を破壊する。
この~methodを~callできるのは、`昇格~txの中$からに限られることに注意。
◎
This method destroys the index with the given name in the object store. Note that this method must only be called from within an upgrade transaction.
</p>

<p>
この~methodは、此れ上の
`indexNames$m
属性を同期的に改変する。
この~methodは `IDBRequest$I ~objを返さないが、索引の破壊~自体は，`昇格~tx$の中で非同期的な要請として処理される。
◎
This method synchronously modifies the indexNames property on the IDBObjectStore instance on which it was called. Although this method does not return an IDBRequest object, the index destruction itself is processed as an asynchronous request within the upgrade transaction.
</p>
	</dd>
</dl>

		</section>
		<section id="index">

<h3 title="The IDBIndex interface">4.6. `IDBIndex^I ~interface</h3>
<!-- TODO Add example. Should examples be in a separate section?-->

<p>
`IDBIndex$I ~interfaceは、`索引~handle$を表現する。
◎
The IDBIndex interface represents an index handle.
</p>

⇒！
[`Exposed$=(Window,Worker)]
interface `IDBIndex@I {
             attribute DOMString      `name$m;
    readonly attribute `IDBObjectStore$I `objectStore$m;
    readonly attribute any            `keyPath$m;
    readonly attribute boolean        `multiEntry$m;
    readonly attribute boolean        `unique$m;

    `IDBRequest$I `get$m(
        any %query
    );
    `IDBRequest$I `getKey$m(
        any %query
    );
    `IDBRequest$I `getAll$m(
        optional any %query,
        [`EnforceRange$] optional unsigned long %count
    );
    `IDBRequest$I `getAllKeys$m(
        optional any %query,
        [`EnforceRange$] optional unsigned long %count
    );
    `IDBRequest$I `count$m(
        optional any %query
    );

    `IDBRequest$I `openCursor$m(
        optional any %query,
        optional `IDBCursorDirection$I %direction = "next"
    );
    `IDBRequest$I `openKeyCursor$m(
        optional any %query,
        optional `IDBCursorDirection$I %direction = "next"
    );
};
◎

<dl class="idl-def">

	<dt>DOMString `name@m</dt>
	<dd>
取得子は、此れの`名前$IxHを返さ~MUST。
◎
The name attribute’s getter must return this index handle’s index’s name.
</dd>
	<dd class="note">注記：
此れが`専属する$~txが`終了-$されない限り、返される値は此れ↗の`名前$Ixと同じになり、それ以降も同じ`値を保持し続ける$。
◎
As long as the transaction has not finished, this is the same as the associated index’s name. Once the transaction has finished, this attribute will not reflect changes made with a later upgrade transaction.
</dd>
	<dd>
<p>
設定子は、~MUST_RUN：
◎
The name attribute’s setter must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `versionchange^l ) ？
◎
Let name be the given value.
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If transaction is not an upgrade transaction, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
◎変則＊
If index or index’s object store has been deleted, throw an InvalidStateError.
</li>
			<li>
%name ~LET 与えられた値
◎
↑</li>
			<li>
~IF［
此れの`名前$IxH ~EQ %name
］
⇒
~RET
◎
If index’s name is equal to name, terminate these steps.
</li>
			<li>
~IF［［
此れが`専属する$`保管庫~handle$
］の`索引~集合$OsHに［
`名前$IxH ~EQ %name
］なる`索引$がある
］
⇒
~THROW `ConstraintError$E
◎
If an index named name already exists in index’s object store, throw a ConstraintError.
</li>
			<li>
此れ↗の`名前$Ix ~SET %name
◎
Set index’s name to name.
</li>
			<li>
此れの`名前$IxH ~SET %name
◎
Set this index handle’s name to name.
</li>
		</ol>
	</dd>
	<dd class="note">🚧
この設定子は、この版による新規追加。
Firefox 51 にて~supportされる。
🚧
◎
🚧 The name attribute’s setter is new in this edition. It will be supported in Firefox 51. 🚧
</dd>

	<dt>readonly `IDBObjectStore$I `objectStore@m</dt>
	<dd>
取得子は、此れが`専属する$`保管庫~handle$を返さ~MUST。
◎
The objectStore attribute’s getter must return this index handle’s object store handle.
</dd>

	<dt>readonly any `keyPath@m</dt>
	<dd>
取得子は、此れ↗の`~key~path$Ixを返さ~MUST。
この属性は、`値を保持し続ける$。
◎
The keyPath attribute’s getter must return this index handle’s index’s key path.
</dd>
	<dd>
この属性にも， `IDBObjectStore.keyPath$m 
<a href="#_return-value-of-keypath">にて述べたことと同じこと</a>
が該当する。
◎
The conversion is done following the normal [WEBIDL] binding logic for DOMString and sequence&lt;DOMString&gt; values, as appropriate.
◎
The returned value is not the same instance that was used when the index was created. However, if this attribute returns an object (specifically an Array), it returns the same object instance every time it is inspected. Changing the properties of the object has no effect on the index.
</dd>

	<dt>readonly boolean `multiEntry@m</dt>
	<dd>
取得子は、
`Bool$( 此れ↗の`複entry~flag$Ix )
を返さ~MUST。
この属性は、`値を保持し続ける$。
◎
The multiEntry attribute’s getter must return true if this index handle’s index’s multiEntry flag is set, and false otherwise.
</dd>

	<dt>readonly boolean `unique@m</dt>
	<dd class="_summary">
`索引$内の各~recordの~keyが`~record~list$Ixの中で一意にされるかどうかを返す。
</dd>
	<dd>
取得子は、
`Bool$( 此れ↗の`一意~flag$Ix )
を返さ~MUST。
この属性は、`値を保持し続ける$。
◎
The unique attribute’s getter must return true if this index handle’s index’s unique flag is set, and false otherwise.
</dd>

	<dt>`IDBRequest$I `get@m(%query)</dt>
	<dd class="_summary">
`索引$の`~record~list$Ix内の［
%query に合致する~recordたち
］のうち，最初の~recordの`参照先の値$を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The get(query) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query and null disallowed flag set. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る最初の~entryを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Clone$( %record の`参照先の値$ )
］
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps for retrieving a referenced value from an index as operation, using index and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$を識別する
`~key$／`~key範囲$
をとり得る。
範囲が指定された場合、~methodは，その範囲に入る最初の既存の~recordの値を検索取得する。
◎
The query parameter may be a key or an IDBKeyRange identifying the record to be retrieved. If a range is specified, the method retrieves the first existing record in that range.
</dd>
	<dd class="note">注記：
`IDBObjectStore.get()$m の注記にて述べたことが，この~methodにも該当する。
◎
This method produces the same result if a record with the given key doesn’t exist as when a record exists, but has undefined as value. If you need to tell the two situations apart, you can use openCursor() with the same key. This will return a cursor with undefined as value if a record exists, or no cursor if no such record exists.
</dd>

	<dt>`IDBRequest$I `getKey@m(%query)</dt>
	<dd class="_summary">
`索引$の`~record~list$Ix内の［
%query に合致する~recordたち
］のうち，最初の~recordの`値$（すなわち，`参照先~record$の`~key$）を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The getKey(query) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query, `~NULL不可^i ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query and null disallowed flag set. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る最初の~entryを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗：<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Value1$( %record の`値$ )
］
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps for retrieving a value from an index as operation, using index and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$の~keyを識別する
`~key$／`~key範囲$
をとり得る。
範囲が指定された場合、~methodは，その範囲に入る最初の既存の~keyを検索取得する。
◎
The query parameter may be a key or an IDBKeyRange identifying the record key to be retrieved. If a range is specified, the method retrieves the first existing key in that range.
</dd>

	<dt>`IDBRequest$I `getAll@m(%query, %count)</dt>
	<dd class="_summary">
`索引$の`~record~list$Ix内の［
%query に合致する~recordたち
］のうち，最初から %count 個までの~recordたちの`参照先の値$を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The getAll(query, count) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る~entryたちを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Clone$( %record の`参照先の値$ )
］；<br>
%count ~SET %count
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps for retrieving multiple referenced values from an index as operation, using index, range, and count if given.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$たちを識別する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~record数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter may be a key or an IDBKeyRange identifying the records to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count records in range, only the first count will be retrieved.
</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Chrome 48 と Firefox 44 で~supportされている。
🚧
◎
🚧 The getAll() method is new in this edition. It is supported in Chrome 48 and Firefox 44. 🚧
</dd>


	<dt>`IDBRequest$I `getAllKeys@m(%query, %count)</dt>
	<dd class="_summary">
`索引$の`~record~list$Ix内の［
%query に合致する~recordたち
］のうち，最初から %count 個の~recordたちの`値$（すなわち，`参照先~record$の`~key$）を検索取得するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The getAllKeys(query, count) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る~entryたちを検索取得する$`演算$
⇒
%対象 ~SET 此れ↗；<br>
%範囲 ~SET %範囲；<br>
%取得演算 ~SET ［
%record → `Value1$( %record の`値$ )
］；<br>
%count ~SET %count
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps for retrieving multiple values from an index as operation, using index, range, and count if given.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、検索取得する`~record$たちの~keyを識別する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
%count が指定されていて，範囲に入る~key数がそれを超える場合，最初から %count 個までが検索取得される。
◎
The query parameter may be a key or an IDBKeyRange identifying the records keys to be retrieved. If null or not given, an unbounded key range is used. If count is specified and there are more than count keys in range, only the first count will be retrieved.
</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Chrome 48 と Firefox 44 で~supportされている。
🚧
◎
🚧 The getAllKeys() method is new in this edition. It is supported in Chrome 48 and Firefox 44. 🚧
</dd>

	<dt>`IDBRequest$I `count@m(%query)</dt>
	<dd class="_summary">
`索引$の`~record~list$Ix内の［
%query に合致する~recordたち
］の総数を得るよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The count(query) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`範囲に入る~recordを数える$`演算$
⇒
%source ~SET 此れ↗；<br>
%範囲 ~SET %範囲
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps to count the records in a range as operation, with index as source and range.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、数えられる`~record$たちの~keyを識別する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter may be a key or an IDBKeyRange identifying the records keys to be counted. If null or not given, an unbounded key range is used.
</dd>

	<dt>`IDBRequest$I `openCursor@m(%query, %direction = `next^l)</dt>
	<dd class="_summary">
［
`索引$の`~record~list$Os内の［
%query に合致する~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The openCursor(query, direction) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを作成-$する`演算$
⇒
%source ~SET 此れ；<br>
%方向 ~SET %direction；<br>
%範囲 ~SET %範囲；<br>
%~key~only~flag ~SET ~OFF
◎
↓</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Let cursor be a new cursor with transaction set to transaction, an undefined position, direction set to direction, got value flag unset, and undefined key and value. The source of cursor is index. The range of cursor is range.
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps for iterating a cursor with cursor as operation.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、`~cursor$の`範囲$Csとして利用する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter may be a key or an IDBKeyRange to use as the cursor’s range. If null or not given, an unbounded key range is used.
</dd>

	<dt>`IDBRequest$I `openKeyCursor@m(%query, %direction = `next^l)</dt>
	<dd class="_summary">
［
`索引$の`~record~list$Ix内の［
%query に合致する~recordたち
］を，`方向$Cs %direction で反復する`~cursor$
］を作成するよう要請する。
この`~cursor$は、~recordの~keyのみを取得する。
</dd>

	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The openKeyCursor(query, direction) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this index handle’s transaction.
◎
Let index be this index handle’s index.
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
%範囲 ~LET `Range$( %query ) ？
◎
Let range be the result of running the steps to convert a value to a key range with query. Rethrow any exceptions.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを作成-$する`演算$
⇒
%source ~SET 此れ；<br>
%方向 ~SET %direction；<br>
%範囲 ~SET %範囲；<br>
%~key~only~flag ~SET ~ON
◎
Let cursor be a new cursor with transaction set to transaction, an undefined position, direction set to direction, got value flag unset, and undefined key and value. The source of cursor is index. The range of cursor is range. The key only flag of cursor is set.
</li>
			<li>
~RET 此れ上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this index handle as source and the steps for iterating a cursor with cursor as operation.
</li>
		</ol>
	</dd>
	<dd>
%query ~parameterは、`~cursor$の`範囲$Csとして利用する
`~key$／`~key範囲$
をとり得る。
~NULL または省略時には，`全範囲$が利用される。
◎
The query parameter may be a key or an IDBKeyRange to use as the cursor’s range. If null or not given, an unbounded key range is used.
</dd>
</dl>

		</section>
		<section id="keyrange">

<h3 title="The IDBKeyRange interface">4.7. `IDBKeyRange^I ~interface</h3>

<p>
`IDBKeyRange$I ~interfaceは、`~key範囲$を表現する。
◎
The IDBKeyRange interface represents a key range.
</p>

⇒！
[`Exposed$=(Window,Worker)]
interface `IDBKeyRange@I {
    readonly attribute any     `lower$m;
    readonly attribute any     `upper$m;
    readonly attribute boolean `lowerOpen$m;
    readonly attribute boolean `upperOpen$m;

    // <span class="comment" title="Static construction methods">静的~構築~method：</span>
    static `IDBKeyRange$I `only$m(
        any %value
    );
    static `IDBKeyRange$I `lowerBound$m(
        any %lower,
        optional boolean %open = false
    );
    static `IDBKeyRange$I `upperBound$m(
        any %upper,
        optional boolean %open = false
    );
    static `IDBKeyRange$I `bound$m(
        any %lower,
        any %upper,
        optional boolean %lowerOpen = false,
        optional boolean %upperOpen = false
    );

    boolean `includes$m(any %key);
};
◎



<dl class="idl-def">

	<dt>readonly any `lower@m</dt>
	<dd>
取得子は、
`Value$( 此れの`下界$ )
を返さ~MUST。
◎
The lower attribute’s getter must return result of running the steps to convert a key to a value with the lower bound if it is not null, or undefined otherwise.
</dd>

	<dt>readonly any `upper@m</dt>
	<dd>
取得子は、
`Value$( 此れの`上界$ )
を返さ~MUST。
◎
The upper attribute’s getter must return the result of running the steps to convert a key to a value with the upper bound if it is not null, or undefined otherwise.
</dd>

	<dt>readonly boolean `lowerOpen@m</dt>
	<dd>
取得子は、
`Bool$( 此れの`下界open~flag$ )
を返さ~MUST。
◎
The lowerOpen attribute’s getter must return true if the lower open flag is set, and false otherwise.
</dd>

	<dt>readonly boolean `upperOpen@m</dt>
	<dd>
取得子は、
`Bool$( 此れの`上界open~flag$ )
を返さ~MUST。
◎
The upperOpen attribute’s getter must return true if the upper open flag is set, and false otherwise.
</dd>

	<dt>static `IDBKeyRange$I `only@m(%value)</dt>
	<dd class="_summary">
%value のみを包含する，新たな`~key範囲$を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The only(value) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~RET `Only$( `Key$( %value ) ) ？
◎
Let key be the result of running the steps to convert a value to a key with value. Rethrow any exceptions.
◎
If key is invalid, throw a DataError.
◎
Create and return a new key range containing only key.
</li>
		</ol>
	</dd>

	<dt>static `IDBKeyRange$I `lowerBound@m(%lower, %open = false)</dt>
	<dd class="_summary">
`下界$のみを持つ，新たな`~key範囲$を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The lowerBound(lower, lowerOpen) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%lowerKey ~LET `Key$( %lower ) ？
◎
Let lowerKey be the result of running the steps to convert a value to a key with lower. Rethrow any exceptions.
◎
If lowerKey is invalid, throw a DataError.
</li>
			<li>
~RET 次の様にされた，新たな`~key範囲$
⇒
`下界$ ~SET %lowerKey；<br />
`下界open~flag$ ~SET `Flag$( %open )；<br />
`上界$ ~SET ε；<br />
`上界open~flag$ ~SET ~ON
◎
Create and return a new key range with lower bound set to lowerKey, lower open flag set if lowerOpen is true, upper bound set to null and upper open flag set.
</li>
		</ol>
	</dd>

	<dt>static `IDBKeyRange$I `upperBound@m(%upper, %open = false)</dt>
	<dd class="_summary">
`上界$のみを持つ，新たな`~key範囲$を返す。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The upperBound(upper, upperOpen) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%upperKey ~LET `Key$( %upper ) ？
◎
Let upperKey be the result of running the steps to convert a value to a key with upper. Rethrow any exceptions.
◎
If upperKey is invalid, throw a DataError.
</li>
			<li>
~RET 次の様にされた，新たな`~key範囲$
⇒
`下界$ ~SET ε；<br />
`下界open~flag$ ~SET ~ON；<br />
`上界$ ~SET %upperKey；<br />
`上界open~flag$ ~SET `Flag$( %open )
◎
Create and return a new key range with lower bound set to null, lower open flag set, upper bound set if upperKey, and upper open flag set to upperOpen.
</li>
		</ol>
	</dd>

	<dt>static `IDBKeyRange$I `bound@m(%lower, %upper, %lowerOpen = false, %upperOpen = false)</dt>
	<dd class="_summary">
`下界$と`上界$を持つ，新たな`~key範囲$を返す。
</dd>
	<dd>

<p>
被呼出時には、~MUST_RUN：
◎
The bound(lower, upper, lowerOpen, upperOpen) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
%lowerKey ~LET `Key$( %lower ) ？
◎
Let lowerKey be the result of running the steps to convert a value to a key with lower. Rethrow any exceptions.
◎
If lowerKey is invalid, throw a DataError.
</li>
			<li>
%upperKey ~LET `Key$( %upper ) ？
◎
Let upperKey be the result of running the steps to convert a value to a key with upper. Rethrow any exceptions.
◎
If upperKey is invalid, throw a DataError.
</li>
			<li>
~IF［
%lower ~GT~cmpkey %upper
］
⇒
~THROW `DataError$E：
◎
If lowerKey is greater than upperKey, throw a DataError.
</li>
			<li>
~RET 次の様にされた，新たな`~key範囲$
⇒
`下界$ ~SET %lowerKey；<br />
`下界open~flag$ ~SET `Flag$( %lowerOpen )；<br />
`上界$ ~SET %upperKey；<br />
`上界open~flag$ ~SET `Flag$( %upperOpen )
◎
Create and return a new key range with lower bound set to lowerKey, lower open flag set if lowerOpen is true, upper bound set to upperKey and upper open flag set if upperOpen is true.
</li>
		</ol>
	</dd>
	<dd class="trans-note">【
%lower ／ %upper
のいずれも省略可能でないので、 `undefined^js は許容されない。
したがって，［
`下界$ ／`上界$
］を持たない`~key範囲$を作成するためには、他の~methodを利用する必要がある。
`全範囲$を表現する `IDBKeyRange^I ~objは 作成できないが、
<code>`lowerBound$m(`-Infinity^js)</code>
により，実質的に等価なものは作成できる。
また、他の各種~API~methodの引数のうち，`~key範囲$を期待するもの（この仕様の IDL で %query と記される引数）は、（省略可能であるならば）省略した場合に`全範囲$に解釈される。
】</dd>

	<dt>`includes@m(%key)</dt>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The includes(key) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
%key ~LET `Key$( %key ) ？
◎
Let k be the result of running the steps to convert a value to a key with key. Rethrow any exceptions.
◎
If k is invalid, throw a DataError.
</li>
			<li>
~RET ［
%key ~IN~cmpkey 此れならば ~T ／
~ELSE_ ~F
］
◎
Return true if k is in this range, and false otherwise.
</li>
		</ol>
	</dd>
	<dd class="note">🚧
この~methodは、この版による新規追加。
Chrome 52 と Firefox 47 で~supportされている。
🚧
◎
🚧 The includes() method is new in this edition. It is supported in Chrome 52 and Firefox 47. 🚧
</dd>
</dl>
		</section>
		<section id="cursor">

<h3 title="The IDBCursor interface">4.8. `IDBCursor^I ~interface</h3>
<!-- TODO Add example. Should examples be in a separate section?-->

<p>
`~cursor$~objは、 `IDBCursor$I ~interfaceを実装する。
所与の`~cursor$を表現するような `IDBCursor$I ~instanceは，唯一つに限られるが、同時に利用できる~cursorの~~総数に制限-はない。
◎
Cursor objects implement the IDBCursor interface. There is only ever one IDBCursor instance representing a given cursor. There is no limit on how many cursors can be used at the same time.
</p>


⇒！
[`Exposed$=(Window,Worker)]
interface `IDBCursor@I {
    readonly attribute (`IDBObjectStore$I or `IDBIndex$I) `source$m;
    readonly attribute `IDBCursorDirection$I           `direction$m;
    readonly attribute any                          `key$m;
    readonly attribute any                          `primaryKey$m;

    void `advance$m(
        [`EnforceRange$] unsigned long %count
    );
    void `continue$m(
        optional any %key
    );
    void `continuePrimaryKey$m(
        any %key,
        any %primaryKey
    );

    `IDBRequest$I `update$m(
        any %value
    );
    `IDBRequest$I `delete$m();
};

enum `IDBCursorDirection@I {
    `next$l,
    `nextunique$l,
    `prev$l,
    `prevunique$l
};

◎

<!-- `IDBCursor!I -->

<dl class="idl-def">

	<dt>readonly (IDBObjectStore or IDBIndex) `source@m</dt>
	<dd>
取得子は、此れの`~source$Csを返さ~MUST。
`~source$Csは、［
`~cursorを作成-$する手続きにて，此れの作成を要請した［
`保管庫~handle$／`索引~handle$
］］に初期化され、それ以降は変化しない（その`~source$Csが`専属する$~txが`作動中$でなくとも，その`~source$Cs↗が破壊されようが）。
◎
The source attribute’s getter must return the source of this cursor. This attribute never returns null or throws an exception, even if the cursor is currently being iterated, has iterated past its end, or its transaction is not active.
</dd>

	<dt>readonly `IDBCursorDirection$I `direction@m</dt>
	<dd>
取得子は、此れの`方向$Csを返さ~MUST。
◎
The direction attribute’s getter must return the direction of the cursor.
</dd>

	<dt>readonly any `key@m</dt>
	<dd>
<p>
取得子は、
`Value$( 此れの`~key$Cs )
を返さ~MUST。
</p>

<p id="_key-getter-return-value">
この属性から~obj（ `Date$js や `Array$js など）が返される場合、此れの`~key$Cs が変更されるまで，毎回~同じ~instanceを返すことになる。
すなわち、~objに加えられる改変は，どこからも見えることになる
— しかしながら、その改変が~dbの内容を改変することはない。
</p>

◎
The key attribute’s getter must return the result of running the steps to convert a key to a value with the cursor’s current key. Note that if this property returns an object (e.g. a Date or Array), it returns the same object instance every time it is inspected, until the cursor’s key is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</dd>

	<dt>readonly any `primaryKey@m</dt>
	<dd>
取得子は、
`Value$( 此れの`実効~key$Cs )
を返さ~MUST。
この属性にも
<a href="#_key-getter-return-value">`key^m 属性にて述べたこと</a>
が該当する。
◎
The primaryKey attribute’s getter must return the result of running the steps to convert a key to a value with the cursor’s current effective key. Note that if this property returns an object (e.g. a Date or Array), it returns the same object instance every time it is inspected, until the cursor’s effective key is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</dd>



	<dt>`IDBRequest$I `update@m(%value)</dt>
	<dd class="_summary">
%value を`~cursor$の現在の`位置$Csに格納する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The update(value) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `readwrite^l ) ？
◎
Let transaction be this cursor’s transaction.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
◎
If the cursor’s source or effective object store has been deleted, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`値取得済~flag$Cs ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s got value flag is unset, indicating that the cursor is being iterated or has iterated past its end, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`~key~only~flag$Cs ~EQ ~ON
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s key only flag is set, throw an InvalidStateError.
</li>
			<li>
%clone ~LET `Clone$( %value ) ？
◎
Let clone be structured clone of value. Rethrow any exceptions.
</li>
			<li>
%keyPath ~LET 此れの`実効~保管庫$Csの`~key~path$Os
</li>
			<li>
<p>
~IF［
%keyPath ~NEQ ε
］：
◎
If the effective object store of this cursor uses in-line keys, run these substeps:
</p>
				<ol>
					<li>
%抽出~key ~LET `Extract$( %clone, %keyPath ) ？
◎
Let kpk be the result of running the steps to extract a key from a value using a key path with clone and the key path of the effective object store. Rethrow any exceptions.
◎
If kpk is failure, invalid, or not equal to the cursor’s effective key, throw a DataError.
</li>
					<li>
~IF［
%抽出~key ~NEQ~cmpkey ~cursorの`実効~key$Cs
］
⇒
~THROW `DataError$E
◎
↑</li>
				</ol>
			</li>
			<li>
%演算 ~SET 次を入力に
`保管庫に~recordを格納する$`演算$
⇒
%保管庫 ~SET 此れの`実効~保管庫$Cs；<br>
%値 ~SET %clone<br>
%key ~SET 此れの`実効~key$Cs<br>
%上書不可~flag ~SET ~OFF
◎
Run steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this cursor as source and the steps for storing a record into an object store as operation, using this cursor’s effective object store as store, the clone as value, this cursor’s effective key as key, and with the no-overwrite flag unset.
</li>
			<li>
<p>
~RET 此れの`~source$Cs上で %演算 を`非同期に実行する新たな要請$
◎
↑</p>

<p class="note">注記：
`保管庫に~recordを格納する$演算は、~cursorが指す位置へ移動してから その位値の~recordが削除されていた場合、新たな~recordを作成させることになる。
◎
A result of running the steps for storing a record into an object store is that if the record has been deleted since the cursor moved to it, a new record will be created.
</p>
			</li>
		</ol>
	</dd>

	<dt>void `advance@m(%count)</dt>
	<dd class="_summary">
`~cursor$を %count に与えられた数だけ進める。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The advance(count) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
%count ~EQ 0
］
⇒
~THROW `TypeError$js
◎
If count is 0 (zero), throw a TypeError.
</li>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this cursor’s transaction.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If the cursor’s source or effective object store has been deleted, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`値取得済~flag$Cs ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s got value flag is unset, indicating that the cursor is being iterated or has iterated past its end, throw an InvalidStateError.
</li>
			<li>
此れの`値取得済~flag$Cs ~SET ~OFF
◎
Unset the got value flag on the cursor.
</li>
			<li>
%要請 ~SET 此れの`要請$Cs
◎
Let request be the request created when this cursor was created.
</li>
			<li>
%要請 の`~done~flag$ ~SET ~OFF
◎
Unset the done flag on request.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを反復-$する`演算$
⇒
%cursor ~SET 此れ；<br />
%count ~SET %count
◎
↓</li>
			<li>
%要請 を用いて，此れの`~source$Cs上で %演算 を`非同期に実行する$
◎
Run the steps for asynchronously executing a request with the cursor’s source as source and the steps for iterating a cursor with this cursor and count, and request.
</li>
		</ol>

<p class="note">注記：
新たな~cursor~dataが読込まれる前に，この~methodを重ねて~callした場合
— 例えば，同じ `onsuccess^m ~handlerの~callの中で二度~callした場合 — 
二度目の~call時には、~cursorの`値取得済~flag$Csは ~OFF なので， `InvalidStateError$E 例外が投出されることになる。
◎
Calling this method more than once before new cursor data has been loaded - for example, calling advance() twice from the same onsuccess handler - results in an InvalidStateError exception being thrown on the second call because the cursor’s got value flag has been unset.
</p>
	</dd>

	<dt>void `continue@m(%key)</dt>
	<dd class="_summary">
`~cursor$の`位置$Csを %key 以降に移動させる。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The continue(key) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this cursor’s transaction.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If the cursor’s source or effective object store has been deleted, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`値取得済~flag$Cs ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s got value flag is unset, indicating that the cursor is being iterated or has iterated past its end, throw an InvalidStateError.
</li>
			<li>
<p>
~IF［
%key ~NEQ ε
］：
◎
If key is given, run these substeps:
</p>
				<ol>
					<li>
%key ~LET `Key$( %key ) ？
◎
Let r be the result of running the steps to convert a value to a key with key. Rethrow any exceptions.
◎
If r is invalid, throw a DataError.
◎
Let key be r.
</li>
					<li>
~IF［
%key ~LTE~cmpkey 此れの`位置$Cs
］~AND［
此れの`方向$Cs ~IN { `next^l, `nextunique^l }
］
⇒
~THROW `DataError$E
◎
If key is less than or equal to this cursor’s position and this cursor’s direction is "next" or "nextunique", throw a DataError.
</li>
					<li>
~IF［
%key ~GTE~cmpkey 此れの`位置$Cs
］~AND［
此れの`方向$Cs ~IN { `prev^l, `prevunique^l }
］
⇒
~THROW `DataError$E
◎
If key is greater than or equal to this cursor’s position and this cursor’s direction is "prev" or "prevunique", throw a DataError.
</li>
				</ol>
			</li>
			<li>
此れの`値取得済~flag$Cs ~SET ~OFF
◎
Unset the got value flag on the cursor.
</li>
			<li>
%要請 ~SET 此れの`要請$Cs
◎
Let request be the request created when this cursor was created.
</li>
			<li>
%要請 の`~done~flag$ ~SET ~OFF
◎
Unset the done flag on request.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを反復-$する`演算$
⇒
%cursor ~SET 此れ；<br>
%key ~SET %key
◎
↓</li>
			<li>
%要請 を用いて，此れの`~source$Cs上で %演算 を`非同期に実行する$
◎
Run the steps for asynchronously executing a request with the cursor’s source as source and the steps for iterating a cursor with this cursor and key (if given), and request.
</li>
		</ol>

<p class="note">注記：
`advance$m の注記と同じ文言がこの~methodにも該当する。
◎
Calling this method more than once before new cursor data has been loaded - for example, calling continue() twice from the same onsuccess handler - results in an InvalidStateError exception being thrown on the second call because the cursor’s got value flag has been unset.
</p>
	</dd>

	<dt>void `continuePrimaryKey@m(%key, %primaryKey)</dt>
	<dd class="_summary">
`~cursor$の ( `位置$Cs, `保管庫~位置$Cs ) を所与の位置~以降へ移動させる。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The continuePrimaryKey(key, primaryKey) method, when invoked, must run these steps:
</p>

		<ol>
			<li>
`CheckState$( 此れ ) ？
◎
Let transaction be this cursor’s transaction.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If the cursor’s source or effective object store has been deleted, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`~source$Csは`索引~handle$でない
］
⇒
~THROW `InvalidAccessError$E
◎
If this cursor’s source is not an index throw an InvalidAccessError.
</li>
			<li>
~IF［
此れの`方向$Cs ~NIN { `next^l, `prev^l }
］
⇒
~THROW `InvalidAccessError$E
◎
If this cursor’s direction is not "next" or "prev", throw an InvalidAccessError.
</li>
			<li>
~IF［
此れの`値取得済~flag$Cs ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s got value flag is unset, indicating that the cursor is being iterated or has iterated past its end, throw an InvalidStateError.
</li>
			<li>
%key ~LET `Key$( %key ) ？
◎
Let r be the result of running the steps to convert a value to a key with key. Rethrow any exceptions.
◎
If r is invalid, throw a DataError.
◎
Let key be r.
</li>
			<li>
%主key ~LET `Key$( %primaryKey ) ？
◎
Let r be the result of running the steps to convert a value to a key with primaryKey. Rethrow any exceptions.
◎
If r is invalid, throw a DataError.
◎
Let primaryKey be r.
</li>
			<li>
~IF［
此れの`方向$Cs ~EQ `next^l
］~AND［
( %key, %主key ) ~LTE~cmpkey 此れの ( `位置$Cs, `保管庫~位置$Cs )
］
⇒
~THROW `DataError$E
◎
↓</li>
			<li>
~IF［
此れの`方向$Cs ~EQ `prev^l
］~AND［
( %key, %主key ) ~GTE~cmpkey 此れの ( `位置$Cs, `保管庫~位置$Cs )
］
⇒
~THROW `DataError$E
◎
If key is less than this cursor’s position and this cursor’s direction is "next", throw a DataError.
◎
If key is greater than this cursor’s position and this cursor’s direction is "prev", throw a DataError.
◎
If key is equal to this cursor’s position and primaryKey is less than or equal to this cursor’s object store position and this cursor’s direction is "next", throw a DataError.
◎
If key is equal to this cursor’s position and primaryKey is greater than or equal to this cursor’s object store position and this cursor’s direction is "prev", throw a DataError.
</li>
			<li>
此れの`値取得済~flag$Cs ~SET ~OFF
◎
Unset the got value flag on the cursor.
</li>
			<li>
%要請 ~SET 此れの`要請$Cs
◎
Let request be the request created when this cursor was created.
</li>
			<li>
%要請 の`~done~flag$ ~SET ~OFF
◎
Unset the done flag on request.
</li>
			<li>
%演算 ~SET 次を入力に
`~cursorを反復-$する`演算$
⇒
%cursor ~SET 此れ；<br>
%key ~SET %key；<br />
%主key ~SET %主key
◎
↓</li>
			<li>
%要請 を用いて，此れの`~source$Cs上で %演算 を`非同期に実行する$
◎
Run the steps for asynchronously executing a request with the cursor’s source as source and the steps for iterating a cursor with this cursor, key, primaryKey, and request.
</li>
		</ol>

<p class="note">🚧
この~methodは、この版による新規追加。
Firefox 51 で~supportされる。
🚧
◎
🚧 The continuePrimaryKey() method is new in this edition. It will be supported in Firefox 51. 🚧
</p>

<p class="note">注記：
`advance$m の注記と同じ文言がこの~methodにも該当する。
◎
Calling this method more than once before new cursor data has been loaded - for example, calling continuePrimaryKey() twice from the same onsuccess handler - results in an InvalidStateError being thrown on the second call because the cursor’s got value flag has been unset.
</p>
	</dd>

	<dt>`IDBRequest$I `delete@m()</dt>
	<dd class="_summary">
`~cursor$が現在~指している~recordを削除する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The delete() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
`CheckState$( 此れ, `readwrite^l ) ？
◎
Let transaction be this cursor’s transaction.
◎
If transaction is not active, throw a TransactionInactiveError.
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
◎
If the cursor’s source or effective object store has been deleted, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`値取得済~flag$Cs ~EQ ~OFF
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s got value flag is unset, indicating that the cursor is being iterated or has iterated past its end, throw an InvalidStateError.
</li>
			<li>
~IF［
此れの`~key~only~flag$Cs ~EQ ~ON
］
⇒
~THROW `InvalidStateError$E
◎
If this cursor’s key only flag is set, throw an InvalidStateError.
</li>
			<li>
%演算 ~SET 次を入力に
`保管庫から~recordを削除する$`演算$
⇒
%保管庫 ~SET 此れの`実効~保管庫$Cs；<br>
%key ~SET `Only$( 此れの`実効~key$Cs )
◎
↓</li>
			<li>
~RET 此れの`~source$Cs上で %演算 を`非同期に実行する新たな要請$
◎
Run the steps for asynchronously executing a request and return the IDBRequest created by these steps. The steps are run with this cursor as source and the steps for deleting records from an object store as operation, using this cursor’s effective object store and effective key as store and key respectively.
</li>
		</ol>
	</dd>
</dl>

<p>
`~key~only~flag$Cs ~EQ ~OFF の`~cursor$は
`IDBCursorWithValue$I ~interfaceも実装する。
◎
A cursor that has the key only flag unset implements the IDBCursorWithValue interface as well.
</p>



⇒！
[`Exposed$=(Window,Worker)]
interface `IDBCursorWithValue@I : `IDBCursor$I {
    readonly attribute any `value$m;
};
◎

<dl class="idl-def">

	<dt>readonly any `value@m</dt>
	<dd>
取得子は、［
此れの`値$Cs ~NEQ ε ならば それ ／
~ELSE_ `undefined^js
］を返さ~MUST。
この属性にも
<a href="#_key-getter-return-value">`key^m 属性にて述べたこと</a>
が該当する。
◎
The value attribute’s getter must return the cursor’s current value. Note that if this property returns an object, it returns the same object instance every time it is inspected, until the cursor’s value is changed. This means that if the object is modified, those modifications will be seen by anyone inspecting the value of the cursor. However modifying such an object does not modify the contents of the database.
</dd>

</dl>


		</section>
		<section id="transaction">

<h3 title="The IDBTransaction interface">4.9. `IDBTransaction^I ~interface</h3>
<!-- TODO Add example. Should examples be in a separate section?-->

<p>
`~tx$は、次の~interfaceを実装する~objで表現される：
◎
transaction objects implement the following interface:
</p>

⇒！
[`Exposed$=(Window,Worker)]
interface `IDBTransaction@I : `EventTarget$I {
    readonly    attribute `DOMStringList$I      `objectStoreNames$m;
    readonly    attribute `IDBTransactionMode$I `mode$m;
    readonly    attribute `IDBDatabase$I        `db$m;
    readonly    attribute `DOMException$I       `error$m;

    `IDBObjectStore$I `objectStore$m(DOMString %name);
    void `abort$m();

    // <span class="comment" title="Event handlers">~event~handler：</span>
                attribute `EventHandler$I       `onabort$m;
                attribute `EventHandler$I       `oncomplete$m;
                attribute `EventHandler$I       `onerror$m;
};

enum `IDBTransactionMode@I {
    `readonly$l,
    `readwrite$l,
    `versionchange$l
};
◎

<!-- `IDBTransaction!I -->

<dl class="idl-def">
	<dt>readonly `DOMStringList$I `objectStoreNames@m</dt>
	<dd>
<p>
取得子は、~MUST_RUN：
◎
The objectStoreNames attribute’s getter must run the following steps:
</p>

		<ol>
			<li>
%保管庫~集合 ~LET ［
此れが`昇格~tx$であるならば 此れが`専属する$`接続$の`保管庫~集合$Cn ／
~ELSE_ 此れが`視野$に入れている`保管庫$たち
］
◎
↓</li>
			<li>
~RET %保管庫~集合 の`名前$Osからなる，`整列済み~list$
◎
If this transaction is an upgrade transaction, return a sorted list of the names of the object stores in this transaction’s connection’s object store set.
◎
Otherwise, return a sorted list of the names of the object stores in this transaction’s scope.
</li>
		</ol>
	</dd>
	<dd class="note">🚧
この属性は、この版による新規追加。
Chrome 48 と Firefox 44 で~supportされている。
🚧
◎
🚧 The objectStoreNames attribute is new in this edition. It is supported in Chrome 48 and Firefox 44. 🚧
</dd>
	<dd class="note">注記：
この属性は、いつも同じ内容の~listを返す
— ただし、`昇格~tx$の間は，保管庫が作成-／削除されるに伴い，異なる内容の~listを返し得る。
◎
The contents of each list returned by this attribute does not change, but subsequent calls to this attribute during an upgrade transaction may return lists with different contents as object stores are created and deleted.
</dd>

	<dt>readonly `IDBTransactionMode$I `mode@m</dt>
	<dd>
取得子は、此れの`~mode$を返さ~MUST。
◎
The mode attribute’s getter must return the mode of the transaction.
</dd>

	<dt>readonly `IDBDatabase$I `db@m</dt>
	<dd>
取得子は、此れが`専属する$`接続$を返さ~MUST。
◎
The db attribute’s getter must return the database connection of which this transaction is a part.
</dd>

	<dt>readonly `DOMException$I `error@m</dt>
	<dd>
取得子は、［
此れの`~error$tx ~NEQ ε ならば それ ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The error attribute’s getter must return this transaction’s error, or null if none.
</dd>
	<dd class="note">
<p>
注記：
~txが中止されたときは、その事由に応じて，次を返す：
</p>
		<ul>
			<li>
失敗した`要請$に因り`中止-$された場合、`要請$の`~error$と同じ名前の~error。
</li>
			<li>
~event~handlerから投出された例外に因り`中止-$された場合、 `AbortError$E
</li>
			<li>
`~commit$時の~errorに因り`中止-$された場合、失敗の事由を反映する~error
— 例えば
`QuotaExceededError$E ／ `ConstraintError$E ／ `UnknownError$E
</li>
		</ul>

<p class="trans-note">【
`abort()$m ~methodに因り`中止-$された場合は、 ~NULL が返される。
】</p>

◎
If this transaction was aborted due to a failed request, this will be the same as the request’s error. If this transaction was aborted due to an uncaught exception in an event handler, the error will be AbortError. If the transaction was aborted due to an error while committing, it will reflect the reason for the failure (e.g. QuotaExceededError, ConstraintError, or UnknownError).
</dd>

	<dt>`IDBObjectStore$I `objectStore@m(%name)</dt>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The objectStore(name) method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れはすでに`終了-$した
］
⇒
~THROW `InvalidStateError$E
◎
If transaction has finished, throw an InvalidStateError.
</li>
			<li>
%保管庫 ~LET 
此れの`視野$に入る~AND［
`名前$Os ~EQ %name
］なる`保管庫$
◎
↓</li>
			<li>
~IF［
%保管庫 ~EQ ε
］
⇒
~THROW `NotFoundError$E
◎
Let store be the object store named name in this transaction’s scope, or throw a NotFoundError if none.
</li>
			<li>
~RET 次を満たすような`保管庫~handle$ %H
⇒
%H↗ ~EQ %保管庫；<br />
%H は此れに`専属する$；<br />
`一意性$の要件を満たす（`可換性$の要件は、`視野$の構成から自動的に満たされる）
◎
Return an object store handle associated with store and this transaction.
</li>
		</ol>

<p class="note">注記：
`一意性$の要件から，返される~instanceは一意に定まる
`~instanceがその前のどの時点で作成されるかは，実装の詳細になる^tnote
。
よって、`昇格~tx$の間を除き、同じ `IDBTransaction$I ~instance上で，同じ %name をこの~methodに渡して返される `IDBObjectStore$I ~instanceは、常に同じになる。
◎
Each call to this method on the same IDBTransaction instance with the same name returns the same IDBObjectStore instance.
</p>

<p class="note">注記：
%H は此れに`専属する$ので、他の `IDBTransaction$I ~instanceに対し同じ引数で この~methodを呼出しても， %H と異なる `IDBObjectStore$I ~instanceが返される。
◎
The returned IDBObjectStore instance is specific to this IDBTransaction. If this method is called on a different IDBTransaction, a different IDBObjectStore instance is returned.
</p>
	</dd>

	<dt>void `abort@m()</dt>
	<dd class="_summary">
この`~tx$を`中止-$する。
</dd>
	<dd>
<p>
被呼出時には、~MUST_RUN：
◎
The abort() method, when invoked, must run these steps:
</p>
		<ol>
			<li>
~IF［
此れはすでに`終了-$した
］
⇒
~THROW `InvalidStateError$E
◎
If this transaction is finished, throw an InvalidStateError.
</li>
			<li >
此れの`作動中~flag$ ~SET ~OFF
◎
↓</li>
			<li>
次を入力に
`~txを中止-$する
⇒
%~tx ~SET 此れ
◎
Unset the transaction’s active flag and run the steps for aborting a transaction with null as error.
</li>
		</ol>
	</dd>

	<dt>`EventHandler$I `onabort@m</dt>
	<dd>
`abort$et ~eventに対する~event~handler。
◎
The onabort attribute is the event handler for the abort event.
</dd>

	<dt>`EventHandler$I `oncomplete@m</dt>
	<dd>
`complete$et ~eventに対する~event~handler。
◎
The oncomplete attribute is the event handler for the complete event.
</dd>
	<dd class="note">注記：
`~tx$が成功裡に完了したかどうかは、要請に配送される `success$et ~eventではなく，`~tx$に配送される `complete$et ~eventを~listenして決定すること
— `~tx$は、 `success$et ~eventを発火した後でも失敗することがあるので。
◎
To determine if a transaction has completed successfully, listen to the transaction’s complete event rather than the success event of a particular request, because the transaction may still fail after the success event fires.
</dd>

	<dt>`EventHandler$I `onerror@m</dt>
	<dd>
`error$et ~eventに対する~event~handler。
◎
The onerror attribute is the event handler for the error event.
</dd>
</dl>


		</section>
		<section id="domstringlist-api">
<h3 title="The DOMStringList interface">4.10. `DOMStringList^I ~interface</h3>

<p>
`DOMStringList$I ~interfaceは、変異不可の，
0 個以上の `DOMString$I 値からなる，有順序~collectionを表現する。
`DOMStringList^I 内の各~itemは、 0 以上の整数~indexを介して~accessできる。
◎
The DOMStringList interface represents an immutable ordered collection of zero or more DOMString values. The items in a DOMStringList are accessible via an integral index, starting from zero.
</p>

<p class="note">注記：
`DOMStringList$I ~interfaceは、以前は `DOM-Level-3-core$r にて定義されていたが、現在の~versionである `DOM$r からは除去された
— 今やこの仕様のみから参照される。
将来には、この型の利用すべては，概念的に類似する `FrozenArray&lt;DOMString&gt;^I
に置換され，他の `Array$js ~methodの利用が可能化されるものと希望されるが、配備済みの内容との互換性をとるため， `contains()^m ~methodの~supportを保ち続ける。
◎
The DOMStringList interface was previously defined in [DOM-Level-3-core] but has been removed from the current versions of [DOM] and is now only referenced in this specification. It is hoped that in the future all uses of this type can be replaced by the conceptually similar FrozenArray&lt;DOMString&gt; to enable the use of other Array methods, but retaining support for the contains() method for compatibility with deployed content.
</p>


⇒！
interface `DOMStringList@I {
    readonly attribute unsigned long `length$m;
    getter DOMString (unsigned long %index);
    DOMString? `item$m(unsigned long %index);

    boolean `contains$m(DOMString %str);
};
◎

<p>
`DOMStringList$I %list に対する`被support~prop~index$は、
{ 0 〜 ( %list 内の~item数 − 1 ) }
である（~item数が 0 ならば空）。
◎
The supported property indices for a DOMStringList list are the numbers zero to the number of items in list minus one. If list has no items, it has no supported property indices.
</p>

<p>
所与の~index %index に対する `DOMStringList$I %list 内の`有index~propの値を決定する$ときは、
%list 内の %index 番の~itemを返す。
◎
To determine the value of an indexed property for a given index index in a DOMStringList list, return the indexth item in list.
</p>


<dl class="idl-def">
	<dt>`length@m</dt>
	<dd>
取得子は、此れ内の~item数を返さ~MUST。
◎
The length attribute’s getter must return the number of items in the collection.
</dd>

	<dt>`item(index)@m</dt>
	<dd>
被呼出時には、［
%index ~IN { 0 〜 ( 此れ内の~item数 − 1 ) } ならば 
此れ内の %index 番の~item ／
~ELSE_ ~NULL
］を返さ~MUST。
◎
The item(index) method must return the indexth item in the collection, or null if there are less than index + 1 items in the collection.
</dd>

	<dt>`contains(str)@m</dt>
	<dd>
被呼出時には、［
%str ~IN 此れならば ~T ／
~ELSE_ ~F
］を返さ~MUST。
◎
The contains(str) method must return true if str is equal to any item in the collection, and false otherwise.
</dd>

</dl>


		</section>
	</section>
	<section id="_algorithms0">
<h2 class="trans-note">X. この訳に固有の各種~algo</h2>

<p class="trans-note">【
この節では、原文~仕様の各種~API定義に繰り返し現れる記述を集約して定義する。
集約~以外にも、~APIの演算において即時に行われる演算（失敗した場合は例外が投出される, この節にて述べるもの）と, `要請$にて非同期に行われる演算（失敗は~eventを通して通知される）とを区別して，挙動を明快にする目的もある。
<!-- 
両者が同じ下位~algoを重複して呼出すこともある。
-->
】</p>

		<section id="_X-Error">
<h3 class="trans-note">X.1. Error()</h3>

<p>
`Error@ ( %~error名 )
は、名前 %~error名 の新たな `DOMException$I ~objを
<a href="~WEBIDL#dfn-create-exception">作成して</a>
返す。
</p>
		</section>
		<section id="_X-Flag">
<h3 class="trans-note">X.2. Flag(), Bool()</h3>

<p>
`Flag@ () は、 IDL `boolean^I 型~値 を~flag値に変換する：
</p>

<ul>
	<li>
`Flag$( ~T ) ~EQ ~ON
</li>
	<li>
`Flag$( ~F ) ~EQ ~OFF
</li>
</ul>

<p>
`Bool@ () は、~flag値を IDL `boolean^I 型~値に変換する：
</p>

<ul>
	<li>
`Bool$( ~ON ) ~EQ ~T
</li>
	<li>
`Bool$( ~OFF ) ~EQ ~F
</li>
</ul>

		</section>
		<section id="_X-structuredclone">
<h3 class="trans-note">X.3. Clone()</h3>

<p>
`Clone@ ( %値 )
は、 %値 の`有構造~clone$を返す。
</p>

		</section>
		<section id="_X-create-a-cursor">
<h3 class="trans-note">X.4. ~cursorを作成する手続き</h3>

<p>
`~cursorを作成-@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>
%source ： `保管庫~handle$／`索引~handle$
</li><li>%方向 ： `方向$Cs
</li><li>%範囲： `~key範囲$
</li><li>%~key~only~flag： ~flag値
</li></ul>


<ol>
	<li>
%cursor ~LET 次の様にされた，新たな`~cursor$
⇒
`要請$Cs ~SET この手続きを`演算$として呼出した`要請$；<br>
`~source$Cs ~SET %source；<br>
`範囲$Cs ~SET %範囲；<br>
`方向$Cs ~SET %方向；<br>
`位置$Cs ~SET ε；<br>
`保管庫~位置$Cs ~SET ε；<br>
`~key$Cs ~SET ε；<br>
`値$Cs ~SET ε；<br>
`値取得済~flag$Cs ~SET ~OFF；<br>
`~key~only~flag$Cs ~SET %~key~only~flag
</li>
	<li>
%cursor ~LET %cursor を入力に`~cursorを反復-$した結果
</li>
	<li>
~IF［
%cursor ~EQ ~NULL
］
⇒
~RET ~NULL
</li>
	<li>
~IF［
%~key~only~flag ~EQ ~ON
］
⇒
~RET %cursor を表現する `IDBCursor!I ~obj
</li>
	<li>
~RET %cursor を表現する `IDBCursorWithValue!I ~obj
</li>
</ol>

		</section>
		<section id="_X-CheckState">
<h3 class="trans-note">X.5. CheckState()</h3>

<p>
`CheckState@ ( %O, %要求mode )
は、次を実行する。
これは、 %O を通して `保管庫$または`索引$に［
~accessし得るかどうか, および演算し得るかどうか
］を検査する：
</p>

<ol>
	<li>
<p>
~IF
%O は`~cursor$である：
</p>
		<ol>
			<li>
［
%O ~SET %O の`~source$Cs
］の下に、下の手続きを
`段 A^i, `段 C^i, `段 B^i の順に実行する
</li>
			<li>
~RET
</li>
		</ol>
	</li>
	<li>
`段 A^i：
		<ol>
			<li>
%transaction ~LET %O が`専属する$~tx
</li>
			<li>
~IF［
%要求mode ~EQ `versionchange^l
］~AND［
%transaction は`昇格~tx$でない
］
⇒
~THROW `InvalidStateError$E
◎
If transaction is not an upgrade transaction, throw an InvalidStateError.
</li>
		</ol>
	</li>
	<li>
`段 B^i：
		<ol>
			<li>
~IF［
%O↗ はすでに削除されている
］
⇒
~THROW `InvalidStateError$E
◎
If index or index’s object store has been deleted, throw an InvalidStateError.
◎
If store has been deleted, throw an InvalidStateError.
</li>
		</ol>
	</li>
	<li>
`段 C^i：
		<ol>
			<li>
~IF［
%transaction は`作動中$でない
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
			<li>
~IF［
%要求mode ~EQ `readwrite^l
］~AND［
%transaction は`~readonly~tx$である
］
⇒
~THROW `ReadOnlyError$E
◎
If transaction is a read-only transaction, throw a ReadOnlyError.
</li>
		</ol>
	</li>
</ol>

<p class="trans-note">【
原文では、
`IDBIndex.name$m,
`IDBObjectStore.name$m
の設定子については、上の手続きを他と異なる順序で検査するように記述されている（この２つについても互いに異なる
— 単なる誤記かも？）。
詳細は原文を参照されたし。
<a href="~IDBISSUES/11">現実の実装も，上のものと一致するとは限らない</a>（各~実装, 各~methodごとにまちまちな部分もあるかもしれない）。
】</p>


		</section>
		<section id="_X-Value">
<h3 class="trans-note">X.6. Value()</h3>

<p>
`Value@ ( %key )
は、所与の［
`~key$ または ε
］を値に変換した結果を返す：
</p>

<ol>
	<li>
~IF［
%key ~EQ ε
］
⇒
~RET `undefined^js
</li>
	<li>
~RET `Value1$( %key )
</li>
</ol>


		</section>
		<section id="_X-Key">
<h3 class="trans-note">X.7. Key()</h3>

<p>
`Key@ ( %input )
は、所与の値を`~key$に変換した結果を返すか, または例外を`投出-$する：
</p>

<ol>
	<li>
%~key ~LET `Key1$( %input )
</li>
	<li>
~IF［
%~key ~EQ ~invalid
］
⇒
~THROW `DataError$E
</li>
	<li>
~IF［
%~key は`例外である$
］
⇒
~THROW その例外
</li>
	<li>
~RET %~key
</li>
</ol>

		</section>
		<section id="_X-Extract">
<h3 class="trans-note">X.8. Extract()</h3>

<p>
`Extract@ ( %値, %keyPath, %生成器 )
は、
( `値$, `~key~path$, `~key生成器$ )
を入力に，例外を`投出-$するか, または［
`~key$ ／ ε
］を返す：
</p>

<ol>
	<li>
%抽出~key ~LET `ExtractKey$ ( %値, %keyPath )
</li>
	<li>
<p>
%抽出~key に応じて：
</p>
		<dl class="switch">
			<dt>`例外である$</dt>
			<dd>
~THROW その例外
</dd>
			<dt>`~key$である</dt>
			<dd>
~RET %抽出~key
</dd>
			<dt>~invalid</dt>
			<dd>
~THROW `DataError$E
</dd>
			<dt>~failure</dt>
			<dd>
				<ol>
					<li>
~IF［
%生成器 ~EQ ε
］
⇒
~THROW `DataError$E
</li>
					<li>
~RET ε
</li>
				</ol>
</dd>
		</dl>
◎
Let kpk be the result of running the steps to extract a key from a value using a key path with clone and store’s key path. Rethrow any exceptions.
◎
If kpk is invalid, throw a DataError.
◎
If kpk is not failure, let key be kpk.
◎
Otherwise, if the object store does not have a key generator, throw a DataError.
	</li>
</ol>

		</section>
	</section>
	<section id="algorithms">

<h2 title="Algorithms">5. 各種~algo</h2>


		<section id="opening">
<h3 title="Opening a database">5.1. ~dbを~openする</h3>

<div class="p">
<p>
`~dbを~open@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%生成元： `生成元$
</li><li>%名前： ~dbの`名前$db
</li><li>%~version： `~version$db
</li><li>%要請： `~open要請$
</li></ul>
◎
The steps for opening a database are defined in the following steps. The algorithm in these steps takes four arguments: the origin which requested the database to be opened, a database name, a database version, and a request.
</div>

<ol>
	<li>
%待行列 ~LET ( %生成元, %名前 ) に対する`接続~待行列$
◎
Let queue be the connection queue for origin and name.
</li>
	<li>
%要請 を %待行列 に追加する
◎
Add request to queue.
</li>
	<li>
%待行列 内の %要請 以前の要請すべてが処理されるまで待機する
◎
Wait until all previous requests in queue have been processed.
</li>
	<li>
%~db ~LET
%生成元 に`専属する$`~db$であって, ［
`名前$db ~EQ %名前
］なるもの
◎
Let db be the database named name in origin, or null otherwise.
</li>
	<li>
~IF ［
%~version ~EQ ε
］
⇒
%~version ~SET ［
%~db ~EQ ε ならば 1 ／
~ELSE_ %~db の`~version$db
］
◎
If version is undefined, let version be 1 if db is null, or db’s version otherwise.
</li>
	<li>
<p>~IF ［
%~db ~EQ ε
］：
</p>
		<ol>
			<li>
%~db ~LET 次の様にされた新たな`~db$
⇒
%生成元 に`専属する$；<br>
`名前$db ~SET %名前；<br>
`~version$db ~SET `0^c ；<br>
`専属する$`保管庫$はない
</li>
			<li>
~IF［
何らかの事由で前~段は失敗した
］
⇒
~RET `Error$( 適切な~error名 )
— 例えば `QuotaExceededError$E ／ `UnknownError$E
</li>
		</ol>
◎
If db is null, let db be a new database with name name, version 0 (zero), and with no object stores. If this fails for any reason, return an appropriate error (e.g. QuotaExceededError or UnknownError).
</li>
	<li>
~IF［
%~version ~LT %~db の`~version$db
］
⇒
~RET `Error$( `VersionError$E )
◎
If db’s version is greater than version, abort these steps and return a new VersionError.
</li>
	<li>
%新~接続 ~LET
%~db を`~access先$とする新たな`接続$
◎
Let connection be a new connection to db.
</li>
	<li>
%新~接続 の`~version$Cn ~SET %~version
◎
Set connection’s version to version.
</li>
	<li>
<p>
~IF ［
%~version ~GT %~db の`~version$db
］：
◎
If db’s version is less than version, run these substeps:
</p>
		<ol>
			<li>
`接続たち^V ~LET ［
%~db を`~access先$とする  %新~接続 以外の`接続$
］からなる集合
◎
Let openConnections be the set of all connections, except connection, associated with db.
</li>
			<li>
<p>
`接続たち^V 内の ~EACH ( %接続 ) に対し
⇒
~IF［
%接続 の`状態$Cn ~EQ `~open中$i
］
⇒
次を走らす`~taskを待入する$
⇒
次を入力に
%接続 に向けて`~version変更~eventを発火する$
⇒
%名前 ~SET `versionchange$et；<br>
%旧~version ~SET %~db の`~version$db；<br>
%新~version ~SET %~version
◎
For each entry in openConnections that does not have its close pending flag set, queue a task to fire a version change event named versionchange at entry with db’s version and version.
</p>

<p class="note" id="_note-open-steps">注記：
この~eventの発火は、上の反復の途中で，いくつかの接続を`~close$させ得る。
それらの接続に向けては（すでに発火されていなければ）、
`versionchange$et ~eventは発火されてはならない。
◎
Firing this event might cause one or more of the other objects in openConnections to be closed, in which case the versionchange event must not be fired at those objects if that hasn’t yet been done.
</p>
			</li>
			<li>
すべての~eventが発火されるまで待機する
◎
Wait for all of the events to be fired.
</li>
			<li>
~IF［
`接続たち^V 内に，［
`状態$Cn ~NEQ `~close済み$i
］なる`接続$が依然としてある
］
⇒
次を走らす`~taskを待入する$
⇒
次を入力に
%新~接続 に向けて`~version変更~eventを発火する$
⇒
%名前 ~SET `blocked$et；<br>
%旧~version ~SET %~db の`~version$db；<br>
%新~version ~SET %~version
◎
If any of the connections in openConnections are still not closed, queue a task= to fire a version change event named blocked at request with db’s version and version.
</li>
			<li id="version-change-close-block">
`接続たち^V 内のすべての`接続$について，［
その`状態$Cn ~EQ `~close済み$i
］になるまで，待機する
◎
Wait until all connections in openConnections are closed.
</li>
			<li>
<p>
次を入力に
`昇格~txを稼働-$させる
⇒
%接続 ~SET %新~接続；<br>
%~version ~SET %~version；<br>
%要請 ~SET %要請
◎
Run the steps for running an upgrade transaction using connection, version and request.
</p>

<p class="trans-note">【
`昇格~tx$が`終了-$するまで待機した上で
】</p>
				<ul>
					<li>
［
%新~接続 の`状態$Cn ~EQ `~close済み$i
］になったときは
⇒
~RET `Error$( `AbortError$E )
◎
If connection was closed, create and return a newly created AbortError and abort these steps.
</li>
					<li>
<p >
`昇格~tx$が中止されたときは：
</p>
						<ol>
							<li>
次を入力に
`~db接続を~close$する
⇒
%接続 ~SET %新~接続
</li>
							<li>
~RET `Error$( `AbortError$E )
</li>
						</ol>
◎
If the upgrade transaction was aborted, run the steps for closing a database connection with connection, create and return a newly created AbortError and abort these steps.
</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>
~RET %新~接続
◎
Return connection.
</li>
</ol>
		</section>
		<section id="closing-connection">
<h3 title="Closing a database">5.2. ~dbを~closeする</h3>

<div class="p">
<p>
`~db接続を~close@
する手続きは、次で与えられる：
</p>

<!-- 
この手続きは、
IDBDatabase.close()$m
から同期的に呼出されているが，同期的に待機する段がある。
 -->

<ul class="input-params"
	><li>
%接続： `接続$
</li><li>%強制~flag
</li></ul>

◎
The steps for closing a database connection are as follows. These steps take two arguments, a connection object, and an optional forced flag.
</div>

<ol>
	<li>
%接続 の`状態$Cn ~SET `~close待ち$i
◎
Set the close pending flag of connection.
</li>
	<li>
`~txたち^V ~LET ［
%接続 に`専属する$`~tx$であって, `終了-$していないもの
］からなる集合
◎
↓</li>
	<li>
~IF［
%強制~flag ~EQ ~ON
］
⇒
`~txたち^V 内の
~EACH (  `~tx$ %~tx ) に対し
⇒
次を入力に
`~txを中止-$する
⇒
%~tx ~SET %~tx；<br>
%error ~SET `AbortError$E
◎
If the forced flag is set, then for each transaction created using connection run the steps for aborting a transaction with transaction and newly created AbortError.
</li>
	<li>
`~txたち^V 内の すべての~txが`終了-$するまで待機する
◎
↓</li>
	<li>
%接続 の`状態$Cn ~SET `~close済み$i
◎
Wait for all transactions created using connection to complete. Once they are complete, connection is closed.
</li>
	<li>
<p>
~IF
%強制~flag ~EQ ~ON
⇒
%接続 に向けて 次の様にされた~eventを`発火する$
⇒
`type^m ~SET `close$et；<br>
`Event$I ~interfaceを利用する；<br>
浮上しない；<br>
取消不可
◎
If the forced flag is set, then fire a close event at connection. The event must use the Event interface and have its type set to "close". The event must not bubble or be cancelable.
</p>

<p class="note">🚧
この段は、この版による新規の挙動。
Chrome 31 と Firefox 50 で~supportされている。
🚧
◎
🚧 This behavior is new in this edition. It is supported in Chrome 31 and Firefox 50.🚧
</p>
	</li>
</ol>

<p class="note">注記：
%接続 の`状態$Cnが `~close待ち$i にされて以降は、［
%接続 を利用して，新たな`~tx$を`作成-$する
］ことはできなくなる。
~txを`作成-$する すべての~methodは、最初に %接続 の`状態$Cnを検査した上で， `~open中$i でないならば例外を投出する。
◎
Once the close pending flag has been set no new transactions can be created using connection. All methods that create transactions first check the close pending flag first and throw an exception if it is set.
</p>

<p class="note">注記：
`接続$が~closeされたとき、所与の`~db$への`接続$がすべて~closeされるまで，
<a href="#version-change-close-block">阻まれ</a>,
<a href="#delete-close-block">待機~中</a>にあった［
`昇格~txを稼働-$させる演算／ `~dbを削除-$する演算
］の待機は、解かれ得る。
◎
Once the connection is closed, this can unblock the steps for running an upgrade transaction, and the steps for deleting a database, which both wait for connections to a given database to be closed before continuing.
</p>
		</section>
		<section id="deleting-a-database">

<h3 title="Deleting a database">5.3. ~dbを削除する</h3>

<div class="p">
<p>
`~dbを削除-@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%生成元： `生成元$
</li><li>%名前： `~db$の`名前$db
</li><li>%要請： `~open要請$
</li></ul>
◎
The steps for deleting a database are as follows. The algorithm in these steps takes three arguments: the origin that requested the database to be deleted, a database name, and a request.
</div>

<ol>
	<li>
%待行列 ~LET ( %生成元, %名前 ) に対する`接続~待行列$
◎
Let queue be the connection queue for origin and name.
</li>
	<li>
%要請 を %待行列 に追加する
◎
Add request to queue.
</li>
	<li>
%待行列 内の %要請 以前の要請すべてが処理されるまで待機する
◎
Wait until all previous requests in queue have been processed.
</li>
	<li>
%~db ~LET %生成元 に`専属する$`~db$であって, ［
`名前$db ~EQ %名前
］なるもの
◎
Let db be the database named name in origin, if one exists. Otherwise, return 0 (zero).
</li>
	<li>
~IF［
%~db ~EQ ε
］
⇒
~RET 0
◎
↑</li>
	<li>
`接続たち^V ~LET ［
%~db を`~access先$とするような`接続$
］のうち，［
`状態$Cn ~NEQ `~close済み$i
］なるものすべてからなる集合
◎
Let openConnections be the set of all connections associated with db.
</li>
	<li>
<p>
`接続たち^V 内の ~EACH ( %接続 ) に対し
⇒
~IF［
%接続 の`状態$Cn ~EQ `~open中$i
］
⇒
次を走らす`~taskを待入する$
⇒
次を入力に
%接続 に向けて`~version変更~eventを発火する$
⇒
%名前 ~SET `versionchange$et；<br>
%旧~version ~SET %~db の`~version$db；<br>
%新~version ~SET ~NULL
◎
For each entry in openConnections that does not have its close pending flag set, queue a task to fire a version change event named versionchange at entry with db’s version and null.
</p>

<p class="note">注記：
ここでも，<a href="#_note-open-steps">~dbを~openするときと同様の注記</a>
が該当する。
◎
Firing this event might cause one or more of the other objects in openConnections to be closed, in which case the versionchange event must not be fired at those objects if that hasn’t yet been done.
</p>
	</li>
			<li>
すべての~eventが発火されるまで待機する
◎
Wait for all of the events to be fired.
</li>
	<li>
~IF［
`接続たち^V 内に［
`状態$Cn ~NEQ `~close済み$i
］なる`接続$が，依然としてある
］
⇒
次を入力に
%要請 に向けて`~version変更~eventを発火する$
⇒
%名前 ~SET `blocked$et；<br>
%旧~version ~SET %~db の`~version$db；<br>
%新~version ~SET ~NULL
◎
If any of the connections in openConnections are still not closed, fire a version change event named blocked at request with db’s version and null.
</li>
	<li id="delete-close-block">
`接続たち^V 内のすべての`接続$について，［
その`状態$Cn ~EQ `~close済み$i
］になるまで，待機する
◎
Wait until all connections in openConnections are closed.
</li>
	<li>
%~version ~LET %~dbの `~version$db
◎
Let version be db’s version.
</li>
	<li>
%~db を削除する
◎
↓</li>
	<li>
~IF［
何らかの事由で前~段は失敗した
］
⇒
~RET `Error$( 適切な~error名 )
— 例えば `QuotaExceededError$E ／ `UnknownError$E
◎
Delete db. If this fails for any reason, return an appropriate error (e.g. QuotaExceededError or UnknownError).
</li>
	<li>
~RET %~version
◎
Return version.
</li>
</ol>

		</section>
		<section id="commit-transaction">

<h3 title="Committing a transaction">5.4. ~txを~commitするとき</h3>

<div class="p">
<p>
`~txを~commit@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%~tx： ~commitする`~tx$
</li></ul>
◎
When taking the steps for committing a transaction the implementation must execute the following algorithm. This algorithm takes one argument, the transaction to commit.
</div>

<ol>
	<li>
%接続 ~LET %~tx が`専属する$`接続$
◎
↓</li>
	<li>
<p >
%~tx により発行0された すべての変更を、 %接続↗ に書込する：
◎
All the changes made to the database by transaction are written to the database.
</p>

		<ul>
			<li>
書込み時に~errorが生じたときは
⇒
次を入力に
`~txを中止-$する
⇒
%~tx ~SET %~tx；<br />
%error ~SET その~errorに適切な~error名
— 例えば `QuotaExceededError$E ／ `UnknownError$E
◎
If an error occurs while writing the changes to the database, abort the transaction by following the steps for aborting a transaction with transaction and an appropriate for the error, for example QuotaExceededError or UnknownError.
</li>
			<li>
<p>
書込みを成功裡に終えたときは†
⇒
次を走らす`~taskを待入する$
⇒
%~tx に向けて 次の様にされた~eventを`発火する$
⇒
`type^m ~SET `complete$et；<br>
`Event$I ~interfaceを利用する；<br>
浮上しない；<br>
取消不可
◎
Queue a task to dispatch an event at transaction. The event must use the Event interface and have its type set to "complete". The event does not bubble and is not cancelable.
</p>

<p class="note">注記：
この~eventに対する~event~handlerから例外が投出されても、~db変更の書込みは~eventの配送-前に終わるので，~txは~commitされる。
`complete$et ~eventが発火されるのは、~txが成功裡に書込されてから限られる。
◎
Even if an exception is thrown from one of the event handlers of this event, the transaction is still committed since writing the database changes happens before the event takes places. Only after the transaction has been successfully written is the "complete" event fired.
</p>
			</li>
		</ul>
	</li>
</ol>

<p class="trans-note">【
`~readonly~tx$に対してもこの手続は呼出されるのかどうか？
はっきりしない（呼出された方が~txの`終了-$時も検知し易い）。
】【†
上の注記から、 `complete$et ~eventが発火されるのは，~errorが生じなかった場合のみと考えられるので，そのような形に読めるように修正を加えているが、原文の記述では，~errorが生じた場合にも発火するようにも読み取れてしまう。
】</p>

		</section>
		<section id="abort-transaction">

<h3 title="Aborting a transaction">5.5. ~txを中止するとき</h3>

<div class="p">
<p>
`~txを中止-@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%~tx： 中止する`~tx$
</li><li>%error （省略可）： ~error名
</li></ul>
◎
When taking the steps for aborting a transaction the implementation must execute the following algorithm. This algorithm takes two arguments: the transaction to abort, and error.
</div>

<ol>
	<li>
<p>
%~tx により`~db$に発行0された，すべての変更を、復帰させる
—
`昇格~tx$に対しては：
</p>
		<ul>
			<li>
`~db$に`専属する$［
`保管庫$／`索引$
］たちの集合, および`~version$dbの変更も，復帰させる。
</li>
			<li>
%~tx の間に作成された［
`保管庫$／`索引$
］は、他の~algoの目的0においては，削除されたものと見なされる。
			</li>
		</ul>
◎
All the changes made to the database by the transaction are reverted. For upgrade transactions this includes changes to the set of object stores and indexes, as well as the change to the version. Any object stores and indexes which were created during the transaction are now considered deleted for the purposes of other algorithms.
</li>
	<li>
<p>
~IF［
%~tx は`昇格~tx$である
］
</p>

<ol>
	<li>
<p>
次を入力に
`昇格~txを中止-$する
⇒
%~tx ~SET %~tx
</p>

<p>
この結果、［
%~tx が`専属する$`接続$ ／ %~tx に`専属する$［
`保管庫~handle$ ／ `索引~handle$
］］すべての~instanceに対する変更は復帰されることになる。
</p>
	</li>
</ol>

◎
If transaction is an upgrade transactions, run the steps for aborting an upgrade transaction with transaction. This reverts changes to all connection, object store handle, and index handle instances associated with transaction. </li>
	<li>
~IF［
%error ~NEQ ε
］
⇒
%~tx の`~error$tx ~SET `Error$( %error )
◎
If error is not null, set transaction’s error to error.
</li>
	<li>
<p>
%~tx の`要請~list$内の［
`~done~flag$ ~EQ ~OFF
］なる~EACH ( `要請$ %要請 ) に対し，順に：
◎
For each request in transaction’s request list with done flag unset, abort the steps for asynchronously executing a request for request and queue a task to run these substeps:
</p>

		<ol>
			<li>
%要請 を`非同期に実行する$手続きを中止する
◎
↑</li>
			<li>
<p>
次の手続きを行う`~taskを待入する$：
◎
↑</p>

				<ol>
					<li>
%要請 上の`~done~flag$ ~SET ~ON
◎
Set the done flag on request.
</li>
					<li>
%要請 の`結果$ ~SET ε
◎
Set the result of request to undefined.
</li>
					<li>
%要請 の`~error$ ~SET `Error$( `AbortError$E )
◎
Set the error of request to a newly created AbortError.
</li>
					<li>
%要請 に向けて次の様にされた~eventを`発火する$
⇒
`type^m ~SET `error$et；<br>
`Event$I ~interfaceを利用する；<br>
浮上する；<br>
取消可
◎
Dispatch an event at request. The event must use the Event interface and have its type set to "error". The event bubbles and is cancelable.
</li>
				</ol>

<p class="note">注記：
これは常に `error$et ~eventを発火させるとは限らない。
例えば~txを`~commit$している間に~errorに因り中止された場合や，それは失敗した最後の残りの要請であった場合 `？^tnote。
◎
This does not always result in any error events being fired. For example if a transaction is aborted due to an error while committing the transaction, or if it was the last remaining request that failed.
</p>
			</li>
		</ol>
	</li>
	<li>
次を走らす`~taskを待入する$
⇒
%~tx に向けて 次の様にされた~eventを`発火する$
⇒
`type^m ~SET `abort$et；<br>
`Event$I ~interfaceを利用する；<br>
浮上しない；<br>
取消不可
◎
Queue a task to dispatch an event at transaction. The event must use the Event interface and have its type set to "abort". The event does bubble but is not cancelable.
</li>
</ol>


		</section>
		<section id="async-execute-request">

<h3 title="Asynchronously executing a request">5.6. 要請を非同期に実行するとき</h3>

<div class="p">
<p>
%source 上で %演算 を
`非同期に実行する@
新たな要請を作成する手続き、あるいは
既存の %要請 を用いて，
%source 上で %演算 を
<dfn>非同期に実行する</dfn>
手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%source ： `保管庫~handle$／`索引~handle$
</li><li>%演算： ~db上で遂行する`演算$
</li><li>%要請（省略可）： `要請$（ 省略された場合は，新たな要請を作成する）
</li></ul>
◎
When taking the steps for asynchronously executing a request the implementation must run the following algorithm. The algorithm takes a source object and an operation to perform on a database, and an optional request.
</div>

<p>
この手続きは、作成された`要請$の`設置先~tx$が`~txを中止-$する手続きを利用して`中止-$された場合、いつでも中止され得る。
◎
These steps can be aborted at any point if the transaction the created request belongs to is aborted using the steps for aborting a transaction.
</p>

<ol>
	<li>
%~tx ~LET %source が`専属する$`~tx$
◎
Let transaction be the transaction associated with source.
</li>
	<li>
~IF［
%transaction は`作動中$でない
］
⇒
~THROW `TransactionInactiveError$E
◎
If transaction is not active, throw a TransactionInactiveError.
</li>
	<li>
~IF［
%要請 ~EQ ε
］
⇒
%要請 ~SET 次の様にされた`要請$を表現する，新たな `IDBRequest$I ~obj
⇒
`~source$ ~SET %source；<br />
`設置先~tx$ ~SET %~tx
◎
If request was not given, let request be a new request with source as source.
</li>
	<li>
%要請 の`結果$ ~SET ε
◎
↓</li>
	<li>
%要請 の`~error$ ~SET ε
◎
↓</li>
	<li>
%要請 の`~done~flag$ ~SET ~OFF
`この段は、この訳による補完^tnote
</li>
	<li>
%~tx の`要請~list$に %要請 を追加する
◎
Add request to the end of transaction’s request list.
</li>
	<li>
~RET %要請
— ただし，以下の手続きも並列的に実行する
<!-- ＊
queue up 待入する？
-->
◎
Return request and queue up the execution of the remaining steps in this algorithm.
</li>
	<li>
%~tx の`要請~list$内の %要請 より前に設置された すべての要請について，それらの［
`~done~flag$ ~EQ ~ON
］になるまで待機する
◎
Wait until all previously added requests in transaction have their done flag set.
</li>
	<li>
%結果 ~LET %演算 を遂行した結果
◎
Let result be the result of performing operation.
</li>
	<li>
%要請 の`~done~flag$ ~SET ~ON
◎
↓</li>
	<li>
%~tx の`要請~list$から %要請 を除去する
`この段は、この訳による補完^tnote
</li>
	<li>
<p>
~IF［
%結果 は~errorである
］（ %演算 は失敗した）
⇒
%演算 により生じたすべての変更を復帰する
◎
If result is an error, then revert all changes made by operation.
</p>

<p class="note">注記：
これは、この要請により行われた変更のみを復帰させる。
~txにより発行0された他の変更は復帰されない。
◎
This only reverts the changes done by this request, not any other changes made by the transaction.
</p>
	</li>
	<li>
<p>
次の下位手続きを走らす`~taskを待入する$：
◎
Queue a task to run these substeps:
</p>

		<ol>
			<li>
<p>
%要請 の`~done~flag$ ~SET ~ON
◎
Set the done flag on request.
</li>
			<li>
<p>
~IF［
%結果 は~errorである
］：
◎
If result is an error, then run these substeps:
</p>
				<ol>
					<li>
%要請 の`結果$ ~SET ε
◎
Set the result of request to undefined.
</li>
					<li>
%要請 の`~error$ ~SET %結果
◎
Set the error of request to result.
</li>
					<li>
%要請 に向けて`~error~eventを発火する$
◎
Fire an error event at request.
</li>
				</ol>
			</li>
			<li>
<p>
~ELSE：
◎
Otherwise, run these substeps:
</p>
				<ol>
					<li>
%要請 の`結果$ ~SET %結果
◎
Set the result of request to result.
</li>
					<li>
%要請 の`~error$ ~SET ε
◎
Set the error of request to undefined.
</li>
					<li>
%要請 に向けて`~success~eventを発火する$
◎
Fire a success event at request.
</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>


		</section>
		<section id="upgrade-transaction-steps">

<h3 title="Running an upgrade transaction">5.7. 昇格~txを稼働するとき</h3>

<div class="p">
<p>
`昇格~txを稼働-@
させる手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%接続： `~db$を更新するために利用する`接続$
</li><li>%~version： ~dbに設定する新たな~version
</li><li>%要請： `要請$
</li></ul>
◎
The steps for running an upgrade transaction are as follows. This algorithm takes three arguments: a connection object which is used to update the database, a new version to be set for the database, and a request.
</div>

<ol>
	<li>
%~db ~LET %接続↗
◎
Let db be connection’s database.
</li>
	<li>
<p>
%~tx ~LET 次の様にされた新たな`昇格~tx$
⇒
`専属する$`接続$ ~SET %接続；<br>
`視野$ ~SET %~db に`専属する$すべての`保管庫$；<br />
`作動中~flag$ ~SET ~OFF†
</p>

<p class="trans-note">【†
~ONにすべきでは？（ここ以外に昇格~txの`作動中~flag$が設定される箇所がないのはおかしい）
】</p>
◎
Let transaction be a new upgrade transaction with connection used as connection. The scope of transaction includes every object store in connection.
◎
Unset transaction’s active flag.
</li>
	<li>
<p>
%~tx を開始する
◎
Start transaction.
</p>

<p class="note">注記：
この`~tx$が`終了-$するまで，他の`接続$は %~db を~openできないことに注意。
◎
Note that until this transaction is finished, no other connections can be opened to the same database.
</p>
	</li>
	<li>
%旧~version ~LET %~db の`~version$db
◎
Let old version be db’s version.
</li>
	<li>
%~db の`~version$db ~SET %~version
—
この変更は，`~tx$の一部と見なされ、~txが`中止-$された場合には復帰される。
◎
Set the version of db to version. This change is considered part of the transaction, and so if the transaction is aborted, this change is reverted.
</li>
	<li>
<p>
次の手続きを行う`~taskを待入する$：
◎
Queue a task to run the following steps:
</p>

		<ol>
			<li>
%要請 の`結果$ ~SET %接続
◎
Set request’s result to connection.
</li>
			<li>
%要請 の`設置先~tx$ ~SET %~tx
◎
Set request’s transaction to transaction.
</li>
			<li>
%要請 の`~done~flag$ ~SET ~OFF
◎
Set the done flag on the request.
</li>
			<li>
<p >
次を入力に
%要請 に向けて`~version変更~eventを発火する$
⇒
%名前 ~SET `upgradeneeded$et；<br>
%旧~version ~SET %旧~version；<br>
%新~version ~SET %~version；<br>
◎
Fire a version change event named upgradeneeded at request with old version and version.
</p>

<p>
~eventの配送-中に，~event~handlerから例外が投出されたときは
⇒
次を入力に`~txを中止-$する
⇒
%error ~SET `AbortError$E
◎
If an exception was propagated out from any event handler while dispatching the event in the previous step, abort the transaction by following the steps for aborting a transaction with the error property set to a newly created AbortError.
</p>

			</li>
		</ol>
	</li>
	<li>
<p>
%~tx が`終了-$するまで待機する：
◎
Wait for transaction to finish.
</p>

		<ul>
			<li>
何らかの事由で %~tx が`中止-$された場合、次を入力に
`~txを中止-$し~MUST
⇒
%error ~SET 事由に適切な~error名
◎
If transaction is aborted for any reason, the steps for aborting a transaction must be run.
</li>
			<li>
<p>
%~tx の`終了-$時には，即時に
⇒
%要請 の`設置先~tx$ ~SET ε
</p>

<p>
これは、［
`complete$et ／ `abort$et
］~eventが配送された後に，その~eventを発火した~taskと同じ~taskにて，即時に行われ~MUST。
</p>

◎
When transaction is finished, immediately set request’s transaction to null. This must be done in the same task as the task firing the complete or abort event, but after the event has been fired.
</li>
		</ul>
	</li>
</ol>
		</section>
		<section id="abort-upgrade-transaction">

<h3 title="Aborting an upgrade transaction">5.8. 昇格~txを中止するとき</h3>

<div class="p">
<p>
`昇格~txを中止-@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%~tx ： `昇格~tx$
</li></ul>

◎
The steps for aborting an upgrade transaction transaction are as follows.
</div>


<p class="note">注記：
この手続きは、通常の`~txを中止-$する手続き（`~db$に`専属する$［
`保管庫$／`索引$
］たちの集合, および
`~version$db変更を復帰させる手続き）の後に稼働される。
`~APIに公開される部分を復帰させる。^tnote
◎
The steps are run after the normal steps for aborting a transaction, which revert changes to the database including the set of associated object stores and indexes, as well as the change to the version.
</p>


<ol>
	<li>
%接続 ~LET %~tx が`専属する$`接続$
◎
Let connection be transaction’s connection.
</li>
	<li>
%~db ~LET %接続↗ （ %接続 の`~access先$`~db$）
◎
Let database be connection’s database.
</li>
	<li>
<p>
%接続 の`~version$Cn ~SET %~db の`~version$db
（ %~tx が %~db を新たに作成したのであれば 0 ）
◎
Set connection’s version to database’s version if database previously existed, or 0 (zero) if database was newly created.
</p>


<p class="note">注記：
これは、
`IDBDatabase!I ~objから返される `version$m 値を復帰させる。
◎
This reverts the value of version returned by the IDBDatabase object.
</p>

	</li>
	<li>
<p>
%接続 の`保管庫~集合$Cn ~SET %~db に`専属する$`保管庫$の集合
（ %~tx が %~db を新たに作成したのであれば 空~集合 ）
◎
Set connection’s object store set to the set of object stores in database if database previously existed, or the empty set if database was newly created.
</p>

<p class="note">注記：
これは、
`IDBDatabase!I ~objから返される `objectStoreNames$m 値を復帰させる。
◎
This reverts the value of objectStoreNames returned by the IDBDatabase object.
</p>
	</li>
	<li>
<p>
この段において反復される~handleたちには、その`~access先$が %~tx により削除-または作成されたものも含まれることに注意。
◎
↓</p>

<p>
%~tx に`専属する$
~EACH ( `保管庫~handle$ %H ) に対し：
◎
For each object store handle handle associated with transaction, including those for object stores that were created or deleted during transaction, run these substeps:
</p>

		<ol>
			<li>
~IF［
%H↗ は %~tx により作成されたものではない
］
⇒
%H の`名前$OsH ~SET %H↗ の`名前$Os
◎
If handle’s object store was not newly created during transaction, set handle’s name to its object store's name.
</li>
			<li>
<p>
%H の`索引~集合$OsH ~SET %H↗ に`専属する$`索引$たちの集合
◎
Set handle’s index set to the set of indexes that reference its object store.
</p>

<div class="note">
<p>注記：
これは、［
%H を表現する `IDBObjectStore!I ~obj
］が返す［
`name$m, `indexNames$m
］値を復帰させる。
◎
This reverts the values of name and indexNames returned by related IDBObjectStore objects.
</p>

<p>
~scriptは、
%~tx が中止されて以降は，［
%~tx を表現する `IDBTransaction!I ~instance
］の `objectStore()$m ~methodを利用しても`保管庫$には~accessできないが、依然として，~scriptが持つ［
%~tx に`専属する$`保管庫~handle$を表現する `IDBObjectStore!I ~instance
］の［
`name$m ／ `indexNames$m
］属性を照会できる。
◎
Although script cannot access an object store by using the objectStore() method on an IDBTransaction instance after the transaction is aborted, it may still have references to IDBObjectStore instances where the name and indexNames properties can be queried.
</p>
</div>
			</li>
			<li>
<p>
%H に`専属する$
~EACH ( `索引~handle$ %I ) に対し：
◎
For each index handle handle associated with transaction, including those for indexes that were created or deleted during transaction, run these substeps:
</p>
		<ol >
			<li>
~IF［
%I↗ は %~tx により作成されたものではない
］
⇒
%I の`名前$IxH ~SET %I↗ の`名前$Ix
◎
If handle’s index was not newly created during transaction, set handle’s name to its index's name.
</li>
		</ol>

<p class="note">注記：
これは、
%I を表現する `IDBIndex!I ~objが返す `name$m 値を復帰させる。
◎
This reverts the value of name returned by related IDBIndex objects.
</p>

<p class="note">注記：
~scriptは、`~tx$が中止されて以降は，［
%H を表現する `IDBObjectStore!I ~instance
］の `index()$m ~methodを利用しても，`索引$には~accessできないが、依然として，~scriptが持つ［
%H に`専属する$`索引~handle$を表現する `IDBIndex!I ~instance
］の `name$m 属性を照会できる。
◎
Although script cannot access an index by using the index() method on an IDBObjectStore instance after the transaction is aborted, it may still have references to IDBIndex instances where the name property can be queried.
</p>
			</li>
		</ol>
	</li>
</ol>

<p class="note">注記：
［
%接続 を表現する `IDBDatabase!I ~instance
］の `name$m は、中止された`昇格~tx$が新たな`~db$を作成していたとしても，`値を保持し続ける$。
◎
The name property of the IDBDatabase instance is not modified, even if the aborted upgrade transaction was creating a new database.
</p>

		</section>
		<section id="fire-success-event">

<h3 title="Firing a success event">5.9. ~success~eventの発火</h3>

<p>
`要請$ %要請 に向けて
`~success~eventを発火する@
手続きは、次で与えられる：
◎
To fire a success event at a request, the implementation must run the following steps:
</p>

<ol>

	<li>
%~tx ~LET %要請 の`設置先~tx$
<!-- 
~source$に結付けられている~tx
 -->
◎
Set transaction to the transaction associated with the source.
</li>
	<li>
%~tx の`作動中~flag$ ~SET ~ON
◎
Set the active flag of transaction.
</li>
	<li>
%要請 に向けて 次の様にされた~eventを`発火する$†
⇒
`type^m ~SET `success$et；<br>
`Event$I ~interfaceを利用する；<br>
浮上しない；<br>
取消不可
◎
Dispatch an event at request. The event must use the Event interface and have its type set to "success". The event does not bubble and is not cancelable.
</li>
	<li>
%~tx の`作動中~flag$ ~SET ~OFF
◎
Unset the active flag of transaction.
</li>
</ol>

<div class="p">
<p>†
~event配送-時に，~event~handlerから例外が投出されたときは：
</p>

<ol>
	<li>
次を入力に
`~txを中止-$する
⇒
%~tx ~SET %~tx；<br>
%error ~SET `AbortError$E
</li>
</ol>

◎
If an exception was propagated out from any event handler while dispatching the event in step 3, abort the transaction by following the steps for aborting a transaction with transaction and a newly created AbortError.
</div>


		</section>
		<section id="fire-error-event">

<h3 title="Firing an error event">5.10. ~error~eventの発火</h3>

<p>
`要請$ %要請 に向けて
`~error~eventを発火する@
手続きは、次で与えられる：
◎
To fire an error event at a request, the implementation must run the following steps:
</p>

<ol>
	<li>
%~tx ~LET %要請 の`設置先~tx$
<!-- 
要請 の~sourceに結付けられている~tx
 -->
◎
Set transaction to the transaction associated with the source.
</li>
	<li>
%~tx の`作動中~flag$ ~SET ~ON
◎
Set the active flag of transaction.
</li>
	<li>
%~event ~LET 次の様にされた新たな~event
⇒
`type^m ~SET `error$et；<br>
`Event$I ~interfaceを利用する；<br>
浮上する；<br>
取消可
</li>
	<li>
%要請 に向けて %~event を`発火する$
◎
Dispatch an event at request. The event must use the Event interface and have its type set to "error". The event bubbles and is cancelable.
</li>
	<li>
%~tx の`作動中~flag$ ~SET ~OFF
◎
Unset the active flag of transaction.
</li>
	<li>
<div class="p">

<p>
~IF［
%~event の配送-時に，~event~handlerから例外が投出された
］：
</p>

<ol>
	<li>
次を入力に
`~txを中止-$する
⇒
%~tx ~SET %~tx；<br>
%error ~SET `AbortError$E
</li>
	<li>
~RET
</li>
</ol>

<p>
これは、［
%~event の`被取消~flag$ ~EQ ~ON
］の下でも行われる。
</p>

◎
If an exception was propagated out from any event handler while dispatching the event in step 3, abort the transaction by following the steps for aborting a transaction with transaction and a newly created AbortError and terminate these steps. This is done even if the event’s canceled flag is not set.
</div>

<div class="note">
<p>注記：
すなわち、 `error$et ~eventの配送-時に，いずれかの~event~handlerから例外が投出されたときは：
</p>

<ul>
	<li>
~eventが `preventDefault()$m の~callにより取消されようが されまいが，~txは中止される。
</li>
	<li>
~tx上の `error^m 属性には、要請の`~error$に代わって， `AbortError$E が利用される。
</li>
</ul>

◎
This means that if an error event is fired and any of the event handlers throw an exception, transaction’s error property is set to an AbortError rather than request’s error, even if preventDefault() is never called.
</div>
	</li>
	<li>
~IF［
%~event の`被取消~flag$ ~EQ ~OFF
］
⇒
次を入力に
`~txを中止-$する
⇒
%~tx ~SET %~tx；<br>
%error ~SET %要請 の`~error$
◎
If the event’s canceled flag is not set, run the steps for aborting a transaction using transaction and request’s error.
</li>
</ol>


		</section>
	</section>
	<section id="database-operations">

<h2 title="Database operations">6. 各種~db演算</h2>

<p>
この節では、［
`保管庫$内の~data／`~db$内の`索引$
］にて行われる種々の演算について述べる。
これらの演算は、要請を`非同期に実行する$手続きにより稼働される。
◎
This section describes various operations done on the data in object stores and indexes in a database. These operations are run by the steps for asynchronously executing a request.
</p>


		<section id="object-store-storage-operation">

<h3 title="Object Store Storage Operation">6.1. 保管庫における蓄積~演算</h3>

<div class="p">
<p>
`保管庫に~recordを格納する@
手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%保管庫： `保管庫$
</li><li>%値： 格納する~recordの`値$
</li><li>%key （省略可）： 格納する~recordの`~key$
</li><li>%上書不可~flag： ~ON の場合，既存の~recordの値は上書きできない。
</li></ul>
◎
The steps for storing a record into an object store with store, value, an optional key, and a no-overwrite flag are as follows.
</div>

<ol>

	<li>
%生成器 ~LET %保管庫 の`~key生成器$
</li>
	<li>
%keyPath ~LET %保管庫 の`~key~path$Os
</li>
	<li>
<p>
~IF［
%keyPath ~NEQ ε
］
◎
If store uses in-line keys, run these substeps:
</p>
		<ol>
			<li>
<p >
%抽出~key ~SET `ExtractKey$( %値, %keyPath )
◎
Let kpk be the result of running the steps to extract a key from a value using a key path with value and store’s key path.
</p>

<p class="trans-note">【
ExtractKey はこの手続きが呼び出される前にも，［
この手続きを実行させる要請を発行0する~API~method
］にて（同期的に）呼び出されているが、この手続きは非同期に実行されるので，結果は異なる可能性もある。
】</p>

			</li>
			<li>
~Assert：［
%抽出~key ~NEQ ~invalid
］~AND ［
%抽出~key は例外でない
］
◎
Assert: kpk will not be invalid or an exception.
</li>
			<li>
~IF［
%抽出~key ~NEQ ~failure
］
⇒
%key ~SET %抽出~key
◎
If kpk is not failure, let key be kpk.
</li>
		</ol>
	</li>
	<li>
<p >
~IF［
%生成器 ~NEQ ε
］：
◎
If store uses a key generator, run these substeps:
</p>
		<ol>
			<li>
%番号 ~LET %生成器 の`現在の番号$
</li>
			<li>
<p>
~IF［
%key ~EQ ε
］：
◎
If key is undefined, run these substeps:
</p>
				<ol>
					<li>
~IF ［
%番号 ~GT `最大の番号$
］
⇒
~RET `Error$( `ConstraintError$E )
◎
If the key generator’s current number is greater than 253 (9007199254740992), then this operation failed with a ConstraintError. Abort this algorithm without taking any further steps.
</li>
					<li>
%key ~SET %番号
◎
Set key to the key generator’s current number.
</li>
					<li>
%生成器 の`現在の番号$ ~SET %番号 ~PLUS 1
◎
Increase the key generator’s current number by 1.
</li>
					<li>
<p >
~IF［
%keyPath ~NEQ ε
］
</p>
						<ol>
							<li>
%e ~LET `Inject$( %値, %keyPath, %key )
</li>
							<li>
~IF［
%e は`例外である$
］
⇒
~RET %e
</li>
						</ol>

◎
If store also uses in-line keys, then run the steps to inject a key into a value using a key path with value, key and store’s key path.
</li>
				</ol>
			</li>
			<li>
~ELIF［
%key の`種別$key ~EQ `number$i
］~AND［
%key ~GTE %番号
］
⇒
%生成器 の`現在の番号$ ~SET ［
%整数 ~GT %key
］なる，最小の %整数
◎
Otherwise, if the type of key is number and the value is greater than or equal to the key generator’s current number, set the current number to lowest integer greater than key.
</li>
		</ol>
	</li>
	<li>
<p>
~IF［
%保管庫 の`~record~list$Os内に［
`~key$ ~EQ~cmpkey %key
］なる`~record$がある
］
</p>
		<ol >
			<li>
~IF［
%上書不可~flag ~EQ ~ON
］
⇒
~RET `Error$( `ConstraintError$E )
◎
If the no-overwrite flag was given to these steps and is set, and a record already exists in store with its key equal to key, then this operation failed with a ConstraintError. Abort this algorithm without taking any further steps.
</li>
			<li>
次を入力に
`保管庫から~recordを削除する$
⇒
%保管庫 ~SET %保管庫；<br>
%範囲 ~SET `Only$( %key )
◎
If a record already exists in store with its key equal to key, then remove the record from store using the steps for deleting records from an object store.
</li>
		</ol>
	</li>
	<li>
%保管庫 の`~record~list$Osに
~record｛ %key ： %値 ｝
を格納する
— それに伴い，~listの~recordたちを~keyの昇順で整列し直すことになる。
◎
Store a record in store containing key as its key and value as its value. The record is stored in the object store’s list of records such that the list is sorted according key of the records in ascending order.
</li>
	<li>
<p>
%保管庫 に`専属する$ ~EACH( `索引$ %索引 ) に対し：
◎
For each index which reference store, run these substeps:
</p>

		<ol>
			<li>
%~key集合 ~LET
`ExtractKeySet$( %値,  %索引 の`~key~path$Ix, %索引 の`複entry~flag$Ix )
◎
Let index key be the result of running the steps to extract a key from a value using a key path with value, index’s key path, and index’s multiEntry flag.
◎
If index key is an exception, or invalid, or failure, take no further actions for this index, and continue these substeps for the next index.
◎
An exception thrown in this step is not rethrown.
</li>
			<li>
<p>
~IF［
%索引 の`一意~flag$Ix ~EQ ~ON
］~AND［
%索引 の`~record~list$Ix内に［
`~key$ ~IN~cmpkey %~key集合
］なる`~record$がある
］
⇒
~RET `Error$( `ConstraintError$E )
◎
If index’s multiEntry flag is unset, or if index key is not an array key, and if index already contains a record with key equal to index key, and index has its unique flag set, then this operation failed with a ConstraintError. Abort this algorithm without taking any further steps.
◎
If index’s multiEntry flag is set and index key is an array key, and if index already contains a record with key equal to any of the subkeys of index key, and index has its unique flag set, then this operation failed with a ConstraintError. Abort this algorithm without taking any further steps.
</p>

<p class="trans-note">【
この手続きを呼び出した要請は失敗とされ、要請を`非同期に実行する$手続きに従って，ここまでの改変は復帰されることになる。
したがって、索引たちを反復する順序も，結果には影響しない。
】</p>
			</li>
			<li>
<p>
%~key集合 内の~EACH( %索引~key ) に対し
⇒
%索引 の`~record~list$Ix内に
新たな~record｛ %索引~key ： %key ｝
を格納する
— それに伴い、~record~listは 先ず~keyの昇順に整列した上で，~keyが等しい~recordたちを値の昇順に整列することになる。
◎
If index’s multiEntry flag is unset, or if index key is not an array key then store a record in index containing index key as its key and key as its value. The record is stored in index’s list of records such that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending order.
◎
If index’s multiEntry flag is set and index key is an array key, then for each subkey of the subkeys of index key store a record in index containing subkey as its key and key as its value. The records are stored in index’s list of records such that the list is sorted primarily on the records keys, and secondarily on the records values, in ascending order.
</p>

<p class="note">注記：
%~key集合 が空でも妥当である
— その場合、索引に追加される~recordはない。
◎
It is valid for there to be no subkeys. In this case no records are added to the index.
◎
Even if any member of subkeys is itself an array key, the member is used directly as the key for the index record. Nested array keys are not flattened or "unpacked" to produce multiple rows; only the outer-most array key is.
</p>

			</li>
		</ol>
	</li>
	<li>
~RET %key
◎
Return key.
</li>
</ol>
		</section>
		<section id="_retrieval-operations">
<h3 title="Object Store/Index Retrieval Operations">6.2〜3. 保管庫／索引から検索取得する演算</h3>


<a id="object-store-retrieval-operations"></a>
<a id="steps-for-retrieving-a-value-from-an-object-store"></a>
<a id="steps-for-retrieving-multiple-values-from-an-object-store"></a>
<a id="steps-for-retrieving-a-key-from-an-object-store"></a>
<a id="steps-for-retrieving-multiple-keys-from-an-object-store"></a>

<a id="index-retrieval-operation"></a>
<a id="steps-for-retrieving-a-referenced-value-from-an-index"></a>
<a id="steps-for-retrieving-multiple-referenced-values-from-an-index"></a>
<a id="steps-for-retrieving-a-value-from-an-index"></a>
<a id="steps-for-retrieving-multiple-values-from-an-index"></a>

<p class="trans-note">【
この訳では、原文の 6.2, 6.3 節の各種~演算を，（下の %取得演算 の）~parameter化により まとめて定義する。
】</p>

<p>
`範囲に入る最初の~entryを検索取得する@
手続きは、次で与えられる：
◎
The steps for retrieving a (value|referenced value) from an (object store|index) with (store|index) and range are as follows:
</p>

<ul class="input-params"
	><li>%対象： `保管庫$／`索引$
</li><li>%範囲： `~key範囲$
</li><li>%取得演算： `~record$から対応する何かを取得する演算
</li></ul>

<ol>
	<li>
%record ~LET %対象 の~record~list内の［
`~key$ ~IN~cmpkey %範囲
］なる`~record$のうち，最初のもの
◎
Let record be the first record in (store|index)’s list of records whose key is in range, if any.
</li>
	<li>
~RET［
%record ~EQ ε ならば ε ／
~ELSE_ %取得演算( %record )
］
◎
If record was not found, return undefined.
◎
Return (a structured clone of )?record’s (referenced )?value.
</li>
</ol>

<p>
`範囲に入る~entryたちを検索取得する@
手続きは、次で与えられる：
◎
The steps for retrieving multiple (values|keys|referenced values) from an (object store|index) with (store|index), range and optional count are as follows:
</p>

<ul class="input-params"
	><li>
%対象： `保管庫$ ／ `索引$
</li><li>%範囲： `~key範囲$
</li><li>%取得演算： `~record$から対応する何かを取得する演算
</li><li>%count （省略可）： 取り出す最大の個数
</li></ul>

<ol>
	<li>
%list ~LET %対象 の~record~list内の［
`~key$ ~IN %範囲
］なる`~record$のうち，［
%count ~IN { ε, 0 } ならば すべての~record ／
~ELSE_ 最初から %count 個までの~record
］からなる~list
◎
If count is not given or is 0 (zero), let count be infinity.
◎
Let records be a list containing the first count records in (store|index)’s list of records whose key is in range.
</li>
	<li>
%連列 ~LET 新たな `~SeqAny$ 型~値
◎
Let sequence be a sequence&lt;any&gt;.
</li>
	<li>
~FOR
%list 内の ~EACH ( %record ) に対し
⇒
%連列 に %取得演算( %record ) を付加する
◎
For each record in records, run these substeps:
• Let entry be (a structured clone of record’s (referenced )?value|the result of running the steps to convert a key to a value with record’s (key|value)).
• Append entry to sequence.
</li>
	<li>
~RET %連列
◎
Return sequence.
</li>
</ol>


<div lang="en">

<!-- Object Store Retrieval Operations -->


<p>
The steps for retrieving a value from an object store with store and range are as follows:
</p>

<ol >
	<li>
Let record be the first record in store’s list of records whose key is in range, if any.
</li>
	<li>
If record was not found, return undefined.
</li>
	<li>
Return a structured clone of record’s value.
</li>
</ol>


<p>
The steps for retrieving multiple values from an object store with store, range and optional count are as follows:
</p>

<ol>
	<li>
If count is not given or is 0 (zero), let count be infinity.
</li>
	<li>
Let records be a list containing the first count records in store’s list of records whose key is in range.
</li>
	<li>
Let sequence be a sequence&lt;any&gt;.
</li>
	<li>
<p>
For each record in records, run these substeps:
</p>
		<ol >
			<li>
Let entry be a structured clone of record’s value.
</li>
			<li>
Append entry to sequence.
</li>
		</ol>
	</li>
	<li>
Return sequence.
</li>
</ol>

<p>
The steps for retrieving a key from an object store with store and range are as follows:
</p>

<ol>
	<li>
Let record be the first record in store’s list of records whose key is in range, if any.
</li>
	<li>
If record was not found, return undefined.
</li>
	<li>
Return record’s key.
</li>
</ol>

<p>
The steps for retrieving multiple keys from an object store with store, range and optional count are as follows:
</p>

<ol>
	<li>
If count is not given or is 0 (zero), let count be infinity.
</li>
	<li>
Let records be a list containing the first count records in store’s list of records whose key is in range.
</li>
	<li>
Let sequence be a sequence&lt;any&gt;.
</li>
	<li>
<p>
For each record in records, run these substeps:
</p>
		<ol >
			<li>
Let entry be the result of running the steps to convert a key to a value with record’s key.
</li>
			<li>
Append entry to sequence.
</li>
		</ol>
	</li>
	<li>
Return sequence.
</li>
</ol>

<!-- Index Retrieval Operations

DFN:steps for retrieving a referenced value from an index#dfn-steps-for-retrieving-a-referenced-value-from-an-index
DFN:steps for retrieving multiple referenced values from an index#dfn-steps-for-retrieving-multiple-referenced-values-from-an-index
DFN:steps for retrieving a value from an index#dfn-steps-for-retrieving-a-value-from-an-index
DFN:steps for retrieving multiple values from an index#dfn-steps-for-retrieving-multiple-values-from-an-index
-->
<p>
The steps for retrieving a referenced value from an index with index and range are as follows.
</p>

<ol>
	<li>
Let record be the first record in index’s list of records whose key is in range, if any.
</li>
	<li>
If record was not found, return undefined.
</li>
	<li>
Return a structured clone of record’s referenced value.
</li>
</ol>



<p>
The steps for retrieving multiple referenced values from an index with index, range and optional count are as follows:
</p>

<ol>
	<li>
If count is not given or is 0 (zero), let count be infinity.
</li>
	<li>
Let records be a list containing the first count records in index’s list of records whose key is in range.
</li>
	<li>
Let sequence be a sequence&lt;any&gt;.
</li>
	<li>
<p>
For each record in records, run these substeps:
</p>
		<ol >
			<li>
Let entry be a structured clone of record’s referenced value.
</li>
			<li>
Append entry to sequence.
</li>
		</ol>
	</li>
	<li>
Return sequence.
</li>
</ol>

<p>
The steps for retrieving a value from an index with index and range are as follows.
</p>

<ol>
	<li>
Let record be the first record in index’s list of records whose key is in range, if any.
</li>
	<li>
If record was not found, return undefined.
</li>
	<li>
Return record’s value.
</li>
</ol>


<p>
The steps for retrieving multiple values from an index with index, range and optional count are as follows:
</p>

<ol>
	<li>
If count is not given or is 0 (zero), let count be infinity.
</li>
	<li>
Let records be a list containing the first count records in index’s list of records whose key is in range.
</li>
	<li>
Let sequence be a sequence&lt;any&gt;.
</li>
	<li>
<p>
For each record in records, run these substeps:
</p>
		<ol >
			<li>
Let entry be the result of running the steps to convert a key to a value with record’s value.
</li>
			<li>
Append entry to sequence.
</li>
		</ol>
	</li>
	<li>
Return sequence.
</li>
</ol>
</div>



		</section>
		<section id="object-store-deletion-operation">

<h3 title="Object Store Deletion Operation">6.4. 保管庫から~recordを削除する演算</h3>

<div class="p">
<p>
`保管庫から~recordを削除する@
手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%保管庫： `保管庫$
</li><li>%範囲： `~key範囲$
</li></ul>
◎
The steps for deleting records from an object store with store and range are as follows.
</div>


<ol>
	<li>
%保管庫 の`~record~list$Osから［
`~key$ ~IN~cmpkey %範囲
］なるすべての`~record$を除去する
◎
Remove all records, if any, from store’s list of records with key in range.
</li>
	<li>
%保管庫 に`専属する$~EACH ( `索引$ ) に対し
⇒
`索引$の`~record~list$Ixから［
`値$ ~IN~cmpkey %範囲
］なるすべての`~record$を除去する
◎
For each index which references store, remove every record from index’s list of records whose value is in range, if any such records exist.
</li>
	<li>
~RET ε
◎
Return undefined.
</li>
</ol>

		</section>
		<section id="record-counting-operation">
<h3 title="Record Counting Operation">6.5. 範囲に入る~recordを数える演算</h3>


<div class="p">
<p>
`範囲に入る~recordを数える@
手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%source： `保管庫$または`索引$
</li><li>%範囲： `~key範囲$
</li></ul>

◎
The steps to count the records in a range with source and range are as follows:
</div>

<ol>
	<li>
~RET %source の~record~list内の［
~recordの`~key$ ~IN~cmpkey %範囲
］なる~recordの総数
◎
Let count be the number of records, if any, in source’s list of records with key in range.
◎
Return count.
</li>
</ol>
		</section>

		<section id="object-store-clear-operation">

<h3 title="Object Store Clear Operation">6.6. 保管庫を~clearする演算</h3>

<div class="p">
<p>
`保管庫を~clearする@
手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%保管庫： `保管庫$
</li></ul>
◎
The steps for clearing an object store with store are as follows.
</div>

<ol>

	<li>
%保管庫 からすべての`~record$を除去する
◎
Remove all records from store.
</li>
	<li>
%保管庫 に`専属する$~EACH ( `索引$ ) に対し
⇒
`索引$からすべての`~record$を除去する
◎
In all indexes which reference store, remove all records.
</li>
	<li>
~RET ε
◎
Return undefined.
</li>
</ol>
		</section>

		<section id="cursor-iteration-operation">

<h3 title="Cursor Iteration Operation">6.7. ~cursorを反復する演算</h3>


<div class="p">
<p>
`~cursorを反復-@
する手続きは、次で与えられる：
</p>

<ul class="input-params"
	><li>%cursor： `~cursor$
</li><li>%key （省略可）： 移動先の`~key$
</li><li>%主key （省略可）： 保管庫における移動先の`~key$
</li><li>%count （省略可）： 反復する回数
</li></ul>
◎
The steps for iterating a cursor with cursor, an optional key and primaryKey to iterate to, and an optional count are as follows.
</div>

<ol>
	<li>
%source ~LET %cursor の`~source$Cs↗
◎
Let source be cursor’s source.
</li>
	<li>
%方向 ~LET %cursor の`方向$Cs
◎
Let direction be cursor’s direction.
</li>
	<li>
~Assert：
［
%主key ~EQ ε
］~OR ［［
%source は`索引$である
］~AND［
%方向 ~IN { `next^l, `prev^l }
］］
◎
Assert: if primaryKey is given, source is an index and direction is "next" or "prev".
</li>
	<li>
<p>
%~record~list ~LET %source 内の すべての~recordからなる~list
◎
Let records be the list of records in source.
</p>

<p class="note">注記：
%~record~list は常に`~key$の昇順で整列される。
%source が`索引$である場合、それに加えて，同じ`~key$を持つ~recordたちは，それらの`値$（すなわち， ~recordの`参照先~record$の`~key$）の昇順でも整列される。
◎
records is always sorted in ascending key order. In the case of source being an index, records is secondarily sorted in ascending value order (where the value in an index is the key of the record in the referenced object store).
</p>
	</li>
	<li>
%範囲 ~LET %cursor の`範囲$Cs
◎
Let range be cursor’s range.
</li>
	<li>
%位置 ~LET %cursor の`位置$Cs
◎
Let position be cursor’s position.
</li>
	<li>
%保管庫~位置 ~LET %cursor の`保管庫~位置$Cs
◎
Let object store position be cursor’s object store position.
</li>
	<li>
~IF［
%count ~EQ ε
］
⇒
%count ~SET 1
◎
If count is not given, let count be 1.
</li>
	<li>
<p >
%~record~list から，以下に従って一つの~recordに絞り込む：
</p>
		<ol>
			<li>
%~record~list から［
`~key$ ~NIN~cmpkey %範囲
］なる すべての~recordを取り除く
</li>
			<li>
~IF［
%位置 ~NEQ ε
］：
				<ol>
					<li>
<p>
~IF［
%source は`保管庫$である
］~OR［
%方向 ~IN { `nextunique^l, `prevunique^l}
］
⇒
%~record~list から［
%方向 に応じて，次で与えられる条件
］を満たす すべての~recordを取り除く：
</p>

<dl class="switch">
	<dt>`next^l</dt>
	<dt>`nextunique^l</dt>
	<dd>
`~key$ ~LTE~cmpkey %位置
</dd>
	<dt>`prev^l</dt>
	<dt>`prevunique^l</dt>
	<dd>
`~key$ ~GTE~cmpkey %位置
</dd>
</dl>
					</li>
					<li>
<p>
~ELSE
⇒
%~record~list から［
%方向 に応じて，次で与えられる条件
］を満たす すべての~recordを取り除く：
</p>
<dl class="switch">
	<dt>`next^l</dt>
	<dd>
( `~key$, `値$ ) ~LTE~cmpkey ( %位置, %保管庫~位置 )
</dd>

	<dt>`prev^l</dt>
	<dd>
( `~key$, `値$ ) ~GTE~cmpkey ( %位置, %保管庫~位置 )
</dd>
</dl>
					</li>
					<li>
<p>
~IF［
%key ~NEQ ε
］
</p>
						<ol>
							<li>
<p>
~IF［
%主key ~EQ ε
］
⇒
%~record~list から［
%方向 に応じて，次で与えられる条件
］を満たす すべての~recordを取り除く：
</p>
<dl class="switch">
	<dt>`next^l</dt>
	<dt>`nextunique^l</dt>
	<dd>
`~key$ ~LT~cmpkey %key
</dd>
	<dt>`prev^l</dt>
	<dt>`prevunique^l</dt>
	<dd>
`~key$ ~GT~cmpkey %key
</dd>
</dl>
							</li>
							<li>
<p>
~ELSE
⇒
%~record~list から［
%方向 に応じて，次で与えられる条件
］を満たす すべての~recordを取り除く：
</p>
<dl class="switch">
	<dt>`next^l</dt>
	<dd>
( `~key$, `値$ ) ~LT~cmpkey ( %key, %主key )
</dd>
	<dt>`prev^l</dt>
	<dd>
( `~key$, `値$ ) ~GT~cmpkey ( %key, %主key )
</dd>
</dl>
							</li>
						</ol>
					</li>
				</ol>
			<li>
~IF［
%方向 ~IN { `nextunique^l, `prevunique^l }
］
⇒
%~record~list 内の ~EACH (
~keyが重複している一群の~record
) に対し
⇒
それらのうち，最初のものを除くすべての~recordを %~record~list から取り除く
</li>
			<li>
<p>
%record ~LET %方向 に応じて，次で与えられる~record：
</p>

<dl class="switch">
	<dt>`next^l</dt>
	<dt>`nextunique^l</dt>
	<dd>
%~record~list 内の最初から %count 番目の~record
</dd>
	<dt>`prev^l</dt>
	<dt>`prevunique^l</dt>
	<dd>
%~record~list 内の最後から %count 番目の~record
</dd>

<!-- ＊
Iterating with "prevunique" visits the same records that "nextunique" visits, but in reverse order.
-->
</dl>
			</li>
			<li>
<p>
~IF［
%record ~EQ ε
］：
</p>
				<ol>
					<li>
%cursor の`~key$Cs ~SET ε
</li>
					<li>
~IF［
%source は`索引$である
］
⇒
%cursor の`保管庫~位置$Cs ~SET ε
</li>
					<li>
~IF［
%cursor の`~key~only~flag$Cs ~EQ ~OFF
］
⇒
%cursor の`値$Cs ~SET ε
</li>
					<li>
~RET ~NULL
</li>
				</ol>
			</li>
		</ol>

<div lang="en">
<p>
While count is greater than 0, run these substeps:
</p>
		<ol>
			<li>
<p>
Switch on direction:
</p>
				<dl class="switch">
					<dt>"next"</dt>
					<dd>
Let found record be the first record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is greater than or equal to key.
</li>
							<li>
If primaryKey is defined, the record’s key is equal to key and the record’s value is greater than or equal to primaryKey, or the record’s key is greater than key.
</li>
							<li>
If position is defined, and source is an object store, the record’s key is greater than position.
</li>
							<li>
If position is defined, and source is an index, the record’s key is equal to position and the record’s value is greater than object store position or the record’s key is greater than position.
							</li>
							<li>
The record’s key is in range.
</li>
						</ul>
					</dd>

					<dt>"nextunique"</dt>
					<dd>
◎
Let found record be the first record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is greater than or equal to key.
</li>
							<li>
If position is defined, the record’s key is greater than position.
</li>
							<li>
The record’s key is in range.
</li>
						</ul>
					</dd>

					<dt>"prev"</dt>
					<dd>
Let found record be the last record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is less than or equal to key.
</li>
							<li>
If primaryKey is defined, the record’s key is equal to key and the record’s value is less than or equal to primaryKey, or the record’s key is less than key.
</li>
							<li>
If position is defined, and source is an object store, the record’s key is less than position.
</li>
							<li>
If position is defined, and source is an index, the record’s key is equal to position and the record’s value is less than object store position or the record’s key is less than position.
</li>
							<li>
The record’s key is in range.
</li>
						</ul>
					</dd>

					<dt>"prevunique"</dt>
					<dd>
Let temp record be the last record in records which satisfy all of the following requirements:
						<ul>
							<li>
If key is defined, the record’s key is less than or equal to key.
</li>
							<li>
If position is defined, the record’s key is less than position.
</li>
							<li>
The record’s key is in range.
</li>
						</ul>
<p>
If temp record is defined, let found record be the first record in records whose key is equal to temp record’s key.
</p>
<p>
Iterating with "prevunique" visits the same records that "nextunique" visits, but in reverse order.
</p>
					</dd>
				</dl>
			</li>
			<li>
<p>
If found record is not defined, run these substeps:
</p>
				<ol>
					<li>
Set cursor’s key to undefined.
</li>
					<li>
If source is an index, set cursor’s object store position to undefined.
</li>
					<li>
If cursor’s key only flag is unset, set cursor’s value to undefined.
</li>
					<li>
Return null.
</li>
				</ol>
			</li>
			<li>
Let position be found record’s key.
</li>
			<li>
If source is an index, let object store position be found record’s value.
</li>
			<li>
Decrease count by 1.
</li>
		</ol>
</div>

	</li>
	<li>
%cursor の`位置$Cs ~SET %record の`~key$
◎
Set cursor’s position to position.
</li>
	<li>
~IF［
%source は`索引$である
］
⇒
%cursor の`保管庫~位置$Cs ~SET %record の`値$
◎
If source is an index, set cursor’s object store position to object store position.
</li>
	<li>
%cursor の`~key$Cs ~SET %record の`~key$
◎
Set cursor’s key to found record’s key.
</li>
	<li>
~IF［
%cursor の`~key~only~flag$Cs ~EQ ~OFF
］：
		<ol>
			<li>
~IF［
%source は`索引$である
］
⇒
%record ~LET %record の`参照先~record$
</li>
			<li>
%cursor の`値$Cs ~SET `Clone$( %record の`値$ ) †
</li>
		</ol>
◎
If cursor’s key only flag is unset, set cursor’s value to a structured clone of found record’s referenced value.
</li>
	<li>
%cursor の`値取得済~flag$Cs ~SET ~ON
◎
Set cursor’s got value flag.
</li>
	<li>
~RET %cursor
◎
Return cursor.
</li>
</ol>

<p class="trans-note">【†
保管庫に~recordを格納する前に一度 Clone されているので、この Clone で例外が生じることはない筈。
】</p>

		</section>
	</section>
	<section id="binding">
<h2 title="ECMAScript binding">7. ECMAScript 言語束縛</h2>

<p>
この節では、この仕様にて定義された`~key$値を［
ECMAScript 値に変換する／その逆向きに変換する
］方法, および
`~key~path$を用いて`~key$を ECMAScript 値の［
中から抽出する／中に注入する
］方法を定義する。
この節では、 ECMAScript 言語~仕様 `ECMA-262$r の各種
型／~algo
を参照し，いくつかの
<a href=":~TC39#sec-algorithm-conventions">~algo表記規約</a>†
を用いる。
◎
This section defines how key values defined in this specification are converted to and from ECMAScript values, and how they may be extracted from and injected into ECMAScript values using key paths. This section references types and algorithms and uses some algorithm conventions from the ECMAScript Language Specification. [ECMA-262]
</p>

<p class="trans-note">【†
概ね、~algo内の抽象演算（ `Get^jA() など）の前に現れる記号 "?", "!" を指す。
（大雑把に言えば、 "?" は 例外が生じ得ることを表し， "!" は 例外は決して生じないことを表す）。
】</p>

<p class="issue">
~key変換~logicを より `WEBIDL$r に依拠するようにして，この節を可能な限り単純化する。
◎
Simplify this section as much as possible by relying more on [WEBIDL] for key conversion logic.
</p>


<div class="trans-note">
<p >
【
この節の各種~algoは、~algoが呼び出す ECMAScript 抽象演算も含め，例外を値として返す（この訳で用いている ~THROW のような，例外の自動的な伝播は伴わない）。
すなわち、 ECMAScript が~algoの定義に利用している
<a href="~TC39#sec-throw-an-exception">throw の定義</a>
に従う（言語機能としての throw 文ではなく）。
そのため、この訳では，原文の語 rethrow （例外の再~投出-）を単に ~RET 文に置換している。
</p>

<p>
所与の値が
`例外である@
という句は、［
その値を表現する ECMAScript 
<a href="~TC39#sec-completion-record-specification-type">Completion Record</a>
］の `type^sl 内部~slot が `throw^i にされている（`中途完了$である）ことを意味する。
】</p>

</div>

<!-- ＊


Algorithms steps that say to throw an exception, such as

    Throw a TypeError exception.

mean the same things as:

    Return Completion{[[type]]: throw, [[value]]: a newly created TypeError object, [[target]]:empty}.

 -->



		<section id="extract-key-from-value">
<h3 title="Extract a key from a value">7.1. 値から~keyを抽出する</h3>


<div >
<p>
抽象~演算
`ExtractKey@ ( %値, %keyPath )
は、
( `値$, `~key~path$ )
を入力にとり，［
`~key$／~failure／~invalid／例外
］を返す：
</p>

<ol>
	<li>
%r ~LET `Evaluate$( %値, %keyPath )
</li>
	<li>
~IF［
%r は`例外である$
］~OR［
%r ~EQ ~failure
］
⇒
~RET %r
</li>
	<li>
~RET `Key1$( %r )
</li>
</ol>

<p>
抽象~演算
`ExtractKeySet@ ( %値, %keyPath, %複entry~flag )
は、
( `値$, `~key~path$, ~flag値 )
を入力にとり，`~key$の集合を返す：
</p>

<ol>
	<li>
%r ~LET `Evaluate$( %値, %keyPath )
</li>
	<li>
~IF［
%r は`例外である$
］~OR［
%r ~EQ ~failure
］
⇒
~RET 空~集合
</li>
	<li>
~IF［
%複entry~flag ~EQ ~ON
］~AND［
`IsArray$jA( %r )
］
⇒
~RET `MultiKey$( %r )
</li>
	<li>
%key ~LET `Key1$( %r )
</li>
	<li>
~IF［
%key は`~key$でない
］
⇒
~RET 空~集合
</li>
	<li>
~RET %key のみからなる集合
</li>
</ol>

◎
The steps to extract a key from a value using a key path with value, keyPath and an optional multiEntry flag are as follows. The result of these steps is a key, invalid, or failure, or the steps may throw an exception.
◎
Let r be the result of running the steps to evaluate a key path on a value with value and keyPath. Rethrow any exceptions.
◎
If r is failure, return failure.
◎
Let key be the result of running the steps to convert a value to a key with r if the multiEntry flag is unset, and the result of running the steps to convert a value to a multiEntry key with r otherwise. Rethrow any exceptions.
◎
If key is invalid, return invalid.
◎
Return key.
</div>


<p class="trans-note">【
この手続きは、`保管庫に~recordを格納する$手続きに伴って 索引を拡充するときに呼び出される。】【
`ExtractKey$ と `ExtractKeySet$ は、原文では一つの~algoとして定義されたものを，この訳にて二つに分離したものである。
その方が、依存関係の見通しも良くなるので（同時に、原文による `MultiKey$ の処理の一部もこの手続きに移行させている）。
原文の `ExtractKeySet$ に該当する部分は，`配列~key$を返しているが、ここでは，単に~keyの集合を返すように変えている。
そうした方が、この手続きを呼出している手続きの記述も，簡明になるので。
】</p>


<div class="p">
<p>
抽象~演算
`Evaluate@ ( %値, %keyPath )
は、
( `値$, `~key~path$ )
を入力にとり，［
ECMAScript 値／~failure／例外
］を返す：
</p>

<p class="trans-note">【
返り値~failureは、 %値 の中に %keyPath が指す部位が存在しないことを表す。
】</p>
◎
The steps to evaluate a key path on a value with value and keyPath are as follows. The result of these steps is an ECMAScript value or failure, or the steps may throw an exception.
</div>


<ol>
	<li>
<p>
~IF［
%keyPath は~SeqDSである
］：
◎
If keyPath is a sequence&lt;DOMString&gt;, run these substeps:
</p>
		<ol>
			<li>
%結果 ~LET 
式 `[]^js で作成されるものと同じ，新たな `Array$js ~obj
◎
Let result be a new Array object created as if by the expression [].
</li>
			<li>
%i ~LET 0
◎
Let i be 0.
</li>
			<li>
<p>
%keyPath 連列~内の ~EACH ( %item ) に対し，順に：
◎
For each item in the keyPath sequence, run these substeps:
</p>
				<ol>
					<li>
%key ~LET `ExtractKey$( %値, %item )†
◎
Let key be the result of recursively running the steps to extract a key from a value using a key path using item as keyPath and value as value.
</li>
					<li>
~Assert：
%key は`中途完了$でない
◎
Assert: key is not an abrupt completion.
</li>
					<li>
~IF［
%key ~EQ ~failure
］
⇒
~RET ~failure
◎
If key is failure, abort the overall algorithm and return failure.
</li>
					<li>
%p ~LET ! `ToString$jA( %i )
◎
Let p be ! ToString(i).
</li>
					<li>
%status ~LET `CreateDataProperty$jA(%result, %p, %key)
◎
Let status be CreateDataProperty(result, p, key).
</li>
					<li>
~Assert： %status ~EQ ~T
◎
Assert: status is true.
</li>
					<li>
%i ~INCBY 1
◎
Increase i by 1.
</li>
				</ol>
			</li>
			<li>
~RET %結果
◎
Return result.
</li>
		</ol>

<p class="note">注記（†）：
これは、一階層のみ “再帰する” 
— `~key~path$ 連列は入子にできないので。
◎
This will only ever "recurse" one level since key path sequences can’t ever be nested.
</p>
	</li>
	<li>
~IF［
%keyPath ~EQ 空~文字列
］
⇒
~RET %値
<!-- この段は不要 -->
◎
If keyPath is the empty string, return value and skip the remaining steps.
</li>
	<li>
%識別子~list ~LET
%keyPath を~PERIODで`厳密に分割-$した結果
◎
Let identifiers be the result of strictly splitting the string keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
<p>
~FOR
%識別子~list 内の~EACH ( %識別子 ) に対し
◎
For each identifier in identifiers, jump to the appropriate step below:
</p>

		<ol>
			<li>
<p>
~IF［
下の表内に
( %値 が満たす条件, %識別子 )
に該当する行がある
］
⇒
%値 ~LET 同じ行の “結果” の列に与える値
</p>

<table>

<thead><tr><th>%値 が満たす条件
</th><th>%識別子
</th><th>結果
</th></tr></thead>

<tbody><tr><td>`Type$jA( %値 ) ~EQ `String$js
</td><td>`length^l
</td><td>%値 内の要素~数に等しい `Number$js 値

</td></tr><tr lang="en"><td colspan="3">
If Type(value) is String, and identifier is "length"
• Let value be a Number equal to the number of elements in value.
</td></tr></tbody>

<tbody><tr><td>`Array$js である
</td><td>`length^l
</td><td>! `ToLength$jA( ! `Get$jA( %値, `length^l ) )

</td></tr><tr lang="en"><td colspan="3">
If value is an Array and identifier is "length"
• Let value be ! ToLength(! Get(value, "length")).
</td></tr></tbody>

<tbody><tr><td>`Blob$I である
</td><td>`size^l
</td><td>%値 の `size$mF に等しい `Number$js 値

</td></tr><tr lang="en"><td colspan="3">
If value is a Blob and identifier is "size"
• Let value be a Number equal to value’s size.
</td></tr></tbody>

<tbody><tr><td>`Blob$I である
</td><td>`type^l
</td><td>%値 の `type$mF に等しい `String$js 値

</td></tr><tr lang="en"><td colspan="3">
If value is a Blob and identifier is "type"
• Let value be a String equal to value’s type.
</td></tr></tbody>

<tbody><tr><td>`File$I である
</td><td>`name^l
</td><td>%値 の `name$mF に等しい `String$js 値

</td></tr><tr lang="en"><td colspan="3">
If value is a File and identifier is "name"
• Let value be a String equal to value’s name.
</td></tr></tbody>

<tbody><tr><td>`File$I である
</td><td>`lastModified^l
</td><td>%値 の `lastModified$mF に等しい `Number$js 値

</td></tr><tr lang="en"><td colspan="3">
If value is a File and identifier is "lastModified"
• Let value be a Number equal to value’s lastModified.
</td></tr></tbody>

<tbody><tr><td>`File$I である
</td><td>`lastModifiedDate^l
</td><td>
`DateValue^sl 内部~slotが %値 の `lastModified$mF に等しくされた，新たな `Date$js ~obj

</td></tr><tr lang="en"><td colspan="3">
If value is a File and identifier is "lastModifiedDate"
• Let value be a new Date object with [[DateValue]] internal slot equal to value’s lastModified.

</td></tr></tbody></table>

			</li>
			<li>
<p>
~ELSE：
◎
Otherwise
</p>
				<ol>
					<li>
~IF［
`Type$jA( %値 ) ~NEQ `Object$js
］
⇒
~RET ~failure
◎
If Type(value) is not Object, return failure.
</li>
					<li>
%hop ~LET ! `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier)
</li>
					<li>
~IF［
%hop ~EQ `false^js
］
⇒
~RET ~failure
◎
If hop is false, return failure.
</li>
					<li>
%値 ~LET ! `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
					<li>
~IF［
%値 ~EQ `undefined^js
］
⇒
~RET ~failure
◎
If value is undefined, return failure.
</li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
~Assert：
%値 は`中途完了$でない
◎
Assert: value is not an abrupt completion.
</li>
	<li>
~RET %値
◎
Return value.
</li>
</ol>


<p class="note">注記：
この~algoが適用される値は，`有構造~clone~algo$からの出力であり,
“own” ~propのみに~accessするので、上の手続きにおける ~Assert は満たされる。
◎
Assertions can be made in the above steps because this algorithm is only applied to values that are the output of the structured clone algorithm and only access "own" properties.
</p>


		</section>
		<section id="inject-key-into-value">
<h3 title="Inject a key into a value">7.2. 値に~keyを注入する</h3>


<p>
抽象~演算
`Inject@ ( %値, %keyPath, %key )
は、
( `値$, `~key~path$Os, `~key$ )
を入力にとり，［
例外 ／ ε
］を返す：
◎
The steps to inject a key into a value using a key path are as follows. The algorithm takes a value, a key and a keyPath.
</p>


<ol>
	<li>
%識別子~list ~LET
%keyPath を~PERIODで`厳密に分割-$した結果
◎
Let identifiers be the result of strictly splitting the string keyPath on U+002E FULL STOP characters (.).
</li>
	<li>
~Assert：
%識別子~list ~NEQ 空
◎
Assert: identifiers is not empty.
</li>
	<li>
%last ~LET %識別子~list の最後の要素
◎
Let last be the last member of identifiers and remove it from the list.
</li>
	<li>
<p>
~FOR
%識別子~list 内の最後の要素を除く
~EACH ( %識別子 ) に対し：
◎
For each remaining identifier in identifiers, run these substeps:
</p>
		<ol>
			<li>
~IF［
%値 は［
`Object$js ／ `Array$js
］~objでない（ `有構造~clone~algo$ `HTML$r を見よ）
］
⇒
~RET `Error$( `DataError$E )
◎
If value is not an Object object or an Array object (see structured clone algorithm [HTML]), then throw a DataError.
</li>
			<li>
%hop ~LET ! `HasOwnProperty$jA( %値, %識別子 )
◎
Let hop be ! HasOwnProperty(value, identifier).
</li>
			<li>
<p>
~IF［
%hop ~EQ `false^js
］：
◎
If hop is false, run these substeps:
</p>
				<ol>
					<li>
%o ~LET 
式 `({})^js で作成されるものと同じ，新たな `Object$js
◎
Let o be a new Object created as if by the expression ({}).
</li>
					<li>
%status ~LET `CreateDataProperty$jA( %値, %識別子, %o )
◎
Let status be CreateDataProperty(value, identifier, o)
</li>
					<li>
~Assert：
%status ~EQ `true^js
◎
Assert: status is true
</li>
				</ol>
			</li>
			<li>
%値 ~LET ! `Get$jA( %値, %識別子 )
◎
Let value be ! Get(value, identifier).
</li>
		</ol>
	</li>
	<li>
~Assert：
%値 は `Object$js または `Array$js である
◎
Assert: value is an Object or an Array.
</li>
	<li>
%keyValue ~LET `Value1$( %key )
◎
Let keyValue be the result of running the steps to convert a key to a value.
</li>
	<li>
%status ~LET
`CreateDataProperty$jA( %値, %last, %keyValue )
◎
Let status be CreateDataProperty(value, last, keyValue).
</li>
	<li>
~Assert：
%status ~EQ `true^js
◎
Assert: status is true.
</li>
</ol>

<p class="note">注記：
入力の %keyPath は保管庫の`~key~path$Osであり、常に~DS型である（ ~SeqDS型でない）
— `保管庫$には，`索引$の`複entry~flag$Ixに該当するものはないので。
◎
The key path used here is always a string and never a sequence, since it is not possible to create a object store which has a key generator and also has a key path that is a sequence.
</p>

<p class="note">注記：
この~algoが適用される値は，`有構造~clone~algo$からの出力なので、上の手続きにおける ~Assert は満たされる。
◎
Assertions can be made in the above steps because this algorithm is only applied to values that are the output of the structured clone algorithm.
</p>

		</section>
		<section id="convert-key-to-value">
<h3 title="Convert a key to a value">7.3. ~keyから値へ変換する</h3>

<p>
抽象~演算
`Value1@ ( %key )
は、
( `~key$  )
を入力にとり， ECMAScript 値を返す：
◎
The steps to convert a key to a value are as follows. These steps take one argument, key, and return an ECMAScript value.
</p>

<ol>
	<li>
%値 ~LET %key の`値$key
◎
Let type be key’s type.
◎
Let value be key’s value.
</li>
	<li>
<p>
%key の`種別$keyに応じて：
◎
Switch on type:
</p>
		<dl class="switch">
			<dt>`number$i</dt>
			<dd>
~RET %値 に等しい ECMAScript `Number$js 値
◎
Return an ECMAScript Number value equal to value
</dd>
			<dt>`string$i</dt>
			<dd>
~RET %値 に等しい ECMAScript `String$js 値
◎
Return an ECMAScript String value equal to value
</dd>
			<dt>`date$i</dt>
			<dd>
				<ol>
					<li>
%date ~LET
( %値 ) を引数に
ECMAScript `Date$js 構築子を実行した結果
◎
Let date be the result of executing the ECMAScript Date constructor with the single argument value
</li>
					<li>
~Assert：
%date は`中途完了$でない
◎
Assert: date is not an abrupt completion.
</li>
					<li>
~RET %date
◎
Return date
</li>
				</ol>
			</dd>

			<dt>`binary$i</dt>
			<dd>
				<ol>
					<li>
%buffer ~LET
( %値 の長さ ) を引数に
ECMAScript `ArrayBuffer$js 構築子を実行した結果
◎
Let len be the length of value.
◎
Let buffer be the result of executing the ECMAScript ArrayBuffer constructor with len.
</li>
					<li>
~Assert：
%buffer は`中途完了$でない
◎
Assert: buffer is not an abrupt completion.
</li>
					<li>
%buffer の `ArrayBufferData^sl 内部~slotの~entryたち ~SET
%値 の~entryたち
◎
Set the entries in buffer’s [[ArrayBufferData]] internal slot to the entries in value.
</li>
					<li>
~RET %buffer
◎
Return buffer
</li>
				</ol>
			</dd>

			<dt>`array$i</dt>
			<dd>
				<ol>
					<li>
%array ~LET
引数なしで
ECMAScript `Array$js 構築子を実行した結果
◎
Let array be the result of executing the ECMAScript Array constructor with no arguments.
</li>
					<li>
~Assert：
%array は`中途完了$でない
◎
Assert: array is not an abrupt completion.
</li>
					<li>
<p>
~FOR［
0 ~LTE %index ~LT %値 の長さ
］なる ~EACH ( 整数 %index ) に対し，昇順に
：
◎
Let len be the length of value.
◎
Let index be 0.
◎
While index is less than len, run these substeps:
</p>
						<ol>
							<li>
%entry ~LET `Value1$( %値 の中の %index 番の~entry )
◎
Let entry be the result of running the steps to convert a key to a value with the indexth entry of value as input.
</li>
							<li>
%status ~LET
`CreateDataProperty$jA( %array, %index, %entry )
◎
Let status be CreateDataProperty(array, index, entry).
</li>
							<li>
~Assert：
%status ~EQ ~T
◎
Assert: status is true.
◎
Increase index by 1.
</li>
						</ol>
					</li>
					<li>
~RET %array
◎
Return array
</li>
				</ol>
			</dd>
		</dl>
	</li>
</ol>


		</section>
		<section id="convert-value-to-key">
<h3 title="Convert a value to a key">7.4. 値から~keyへ変換する</h3>

<p>
抽象~演算
`Key1@ ( %input, %seen )
は、
( ECMAScript 値, 集合 )
を入力にとり，［
`~key$／~invalid／例外
］を返す：
◎
The steps to convert a value to a key are as follows. These steps take two arguments, an ECMAScript value input, and an optional set seen. The result of these steps is a key or invalid, or the steps may throw an exception.
</p>

<p class="trans-note">【
%seen は %input 配列が自身を入子にしているかどうか検査するために利用される。
】</p>

<ol>
	<li>
~IF［
%seen ~EQ ε
］
⇒
%seen ~SET 新たな空~集合
◎
If seen was not given, let seen be a new empty set.
</li>
	<li>
~IF［
%input ~IN %seen
］
~RET ~invalid
◎
If input is in seen return invalid.
</li>
	<li>
<p>
~IF `Type$jA( %input ) ~EQ `Number$js
◎
Jump to the appropriate step below:
◎
If Type(input) is Number
</p>

		<ol>
			<li>
~ELIF［
%input ~EQ `NaN^js
］
⇒
~RET ~invalid
◎
If input is NaN then return invalid.
</li>
			<li>
~RET 次の様にされた新たな`~key$
⇒
`種別$key ~SET `number$i；<br />
`値$key ~SET %input
◎
Otherwise, return a new key with type number and value input
</li>
		</ol>
	</li>
			<!-- Date -->
	<li>
<p>
~ELIF［
%input は `Date$js ~objである（ `DateValue^sl 内部~slotを持つ）
］：
◎
If input is a Date (has a [[DateValue]] internal slot)
</p>
		<ol>
			<li>
%ms ~LET %input の `DateValue^sl 内部~slotの値
◎
Let ms be the value of input’s [[DateValue]] internal slot.
</li>
			<li>
~IF［
%ms ~EQ `NaN^js
］
⇒
~RET ~invalid
◎
If ms is NaN then return invalid.
</li>
			<li>
~RET 次の様にされた新たな`~key$
⇒
`種別$key ~SET `date$i；<br />
`値$key ~SET %ms
◎
Otherwise, return a new key with type date and value ms.
</li>
		</ol>
	</li>
	<li>
<p>
~ELIF［
`Type$jA( %input ) ~EQ `String$js
］
◎
If Type(input) is String
</p>
		<ol>
			<li>
~RET 次の様にされた新たな`~key$
⇒
`種別$key ~SET `string$i；<br />
`値$key ~SET %input
◎
Return a new key with type string and value input.
</li>
		</ol>
	</li>
			<!-- Binary -->
	<li>
<p>
~ELIF［
%input は`~buffer~source型$である
］
◎
If input is a buffer source type
</p>
		<ol>
			<li>
%octets ~LET
%input から`~buffer~sourceに保持されている~byte列の複製を取得-$した結果
◎
Let octets be the result of running the steps for getting a copy of the bytes held by a buffer source with value. Rethrow any exceptions.
</li>
			<li>
~IF［
%octets は`例外である$
］
⇒
~RET %octets
◎
↑</li>
			<li>
~RET 次の様にされた新たな`~key$
⇒
`種別$key ~SET `binary$i；<br />
`値$key ~SET %octets
◎
Return a new key with type binary and value octets.
</li>
		</ol>

			<!-- Array -->
	<li>
<p>
~ELIF［
`IsArray$jA( %input )
］：
◎
If IsArray(input)
</p>
		<ol>
			<li>
%len ~LET ? `ToLength$jA( ? `Get$jA( %input, `length^l))
◎
Let len be ? ToLength( [=?-] Get(input, "length")).
<!-- [=?-]＊ -->
</li>
			<li>
%input を %seen に追加する
◎
Add input to seen
</li>
			<li>
%keys ~LET 新たな空~list
◎
Let keys be a new empty list.
</li>
			<li>
<p>
~FOR
0 ~LTE %index ~LT %len なる ~EACH ( 整数 %index ) に対し，昇順に
：
◎
Let index be 0.
◎
While index is less than len, run these substeps:
</p>
				<ol>
					<li>
%hop ~LET ? `HasOwnProperty$jA( %input, %index )
◎
Let hop be ? HasOwnProperty(input, index).
</li>
					<li>
~IF［
%hop ~EQ `false^js
］
⇒
~RET ~invalid
◎
If hop is false, return invalid.
</li>
					<li>
%entry ~LET ? `Get$jA( %input, %index )
◎
Let entry be ? Get(input, index).
</li>
					<li>
%key ~LET `Key1$( %entry, %seen )
◎
Let key be the result of running the steps to convert a value to a key with arguments entry and seen
</li>
					<li>
~IF［
%key は`例外である$
］~OR［
%key ~EQ ~invalid
］
⇒
~RET %key
◎
ReturnIfAbrupt(key)
◎
If key is invalid abort these steps and return invalid.
</li>
					<li>
%key を %keys に付加する
◎
Append key to keys
◎
Increase index by 1.
</li>
				</ol>
			</li>
			<li>
~RET 次の様にされた新たな`~key$
⇒
`種別$key ~SET `array$i；<br />
`値$key ~SET %keys
◎
Return a new array key with value keys.
</li>
		</ol>
	</li>
	<li>
~ELSE
⇒
~RET ~invalid
◎
Otherwise
• Return invalid.
</li>
</ol>


<p>
抽象~演算
`MultiKey@ ( %array )
は、
( ECMAScript `Array$js 値 )
を入力にとり，`~key$の集合を返す：
◎
The steps to convert a value to a multiEntry key are as follows. These steps take one argument, an ECMAScript value input. The result of these steps is a key or invalid, or the steps may throw an exception.
◎
If IsArray(input), then:
</p>

<ol>
	<!-- Array -->
	<li>
%len ~LET ? `ToLength$jA( ? `Get$jA( %array, `length^l))
◎
Let len be ? ToLength( ? Get(input, "length")).
</li>
	<li>
~Assert：
%len は`中途完了$でない
◎
Assert: len will never an abrupt completion.
</li>
	<li>
%seen ~LET %array のみからなる新たな集合
◎
Let seen be a new set containing only input.
</li>
	<li>
%key集合 ~LET 新たな空~集合
◎
Let keys be a new empty set.
</li>
	<li>
%index ~LET 0
◎
Let index be 0.
</li>
	<li>
<p>
~WHILE ( %index ~LT %len )
：
◎
While index is less than len, run these substeps:
</p>
			<ol>
				<li>
%entry ~LET `Get$jA( %array, %index )
◎
Let entry be Get(input, index).
</li>
				<li>
<p>
~IF［
%entry は`中途完了$でない
］：
◎
If entry is not an abrupt completion, run these substeps:
</p>
					<ol>
						<li>
%key ~LET `Key1$( %entry, %seen )
◎
Let key be the result of running the steps to convert a value to a key with arguments entry and seen
</li>
						<li>
~IF［
%key は`~key$である
<!-- 
~invalidでない~AND 中途完了でない
-->
］~AND ［
%key ~NIN~cmpkey %key集合
］
⇒
%key を %key集合 に追加する
◎
If key is not invalid or an abrupt completion, add key to keys if there are no other members of keys equal to key.
</li>
					</ol>
				</li>
				<li>
%index ~INCBY 1
◎
Increase index by 1.
</li>
			</ol>
		</li>
		<li>
~RET %key集合
◎
Return a new array key with value set to a list of the members of keys.
</li>
</ol>

<div class="note">
<p>
この手続きは、`~key$へ変換できない~memberは無視した上で, 重複するものを除去する。
◎
Otherwise, return the result of running the steps to convert a value to a key with argument input.
◎
These steps are similar to those to convert a value to a key but if the top-level value is an Array then members which can not be converted to keys are ignored, and duplicates are removed.
</p>

<p>
例えば配列
`[10, 20, null, 30, 20]^js
は、`~key$の集合 { 10, 20, 30 } に変換される。
◎
For example, the value [10, 20, null, 30, 20] is converted to an array key with subkeys 10, 20, 30.
</p>
</div>

		</section>
	</section>

	<section id="privacy" class="informative">

<h2 title="Privacy Considerations">8. ~privacy上の考慮点</h2>

~INFORMATIVE

		<section id="user-tracking">

<h3 title="User tracking">8.1. 利用者の追跡</h3>

<p>
第三者主体~host （あるいは、複数の~siteに配布される内容を取得する~~能力を持つ任意の~obj）は、その~client側~db内に格納された一意な識別子を利用して，複数~sessionにわたって利用者を追跡した上で，利用者の活動について~profileを築くこともできる。
利用者の本当の~~識別情報を知る~site（
例えば、認証済み資格証明情報を要求する電子商取引~site
）と組み合わされれば、どこかの圧政的団体が，純粋に匿名な~webの用法より ずっと~~正確に個々人を標的にすることも可能になる。
◎
A third-party host (or any object capable of getting content distributed to multiple sites) could use a unique identifier stored in its client-side database to track a user across multiple sessions, building a profile of the user’s activities. In conjunction with a site that is aware of the user’s real id object (for example an e-commerce site that requires authenticated credentials), this could allow oppressive groups to target individuals with greater accuracy than in a world with purely anonymous Web usage.
</p>

<p>
利用者~追跡の~riskを軽減するために利用できる，いくつもの技法がある：
◎
There are a number of techniques that can be used to mitigate the risk of user tracking:
</p>

<dl>
	<dt>
第三者主体による蓄積を阻止する。
◎
Blocking third-party storage
</dt>

	<dd>
~UAは、~db~objへの~accessを［
<span>閲覧~文脈</span>の~top-level文書の~domainを出自にする~script
］に制約して~MAY
—
具体的には `iframe^c 内で稼働中の他の~domainからの頁に対しては~APIへの~accessを拒否する。
◎
User agents may restrict access to the database objects to scripts originating at the domain of the top-level document of the browsing context, for instance denying access to the API for pages from other domains running in iframes.
</dd>

	<dt>
格納された~dataを失効させる
◎
Expiring stored data
</dt>
	<dd>
<p>
~UAは、格納されている~dataを、一定期間の後に自動的に削除して~MAY。
◎
User agents may automatically delete stored data after a period of time.
</p>

<p>
これは、~siteが利用者を追跡する能を制約し得る
— ~siteは、~site自身が利用者を認証する（例：購入や~serviceへのログイン時など）以外にも，利用者を複数~sessionにわたって追跡できなくする。
◎
This can restrict the ability of a site to track a user, as the site would then only be able to track the user across multiple sessions when she authenticates with the site itself (e.g. by making a purchase or logging in to a service).
</p>

<p>
しかしながら一方で、利用者の~dataも~riskに晒す。
◎
However, this also puts the user’s data at risk.
</p>
	</dd>

	<dt>
永続的~蓄積を~cookieと同様に扱う
◎
Treating persistent storage as cookies
</dt>
	<dd>
<p>
~UAは、~db特色機能を
HTTP ~session~cookie `COOKIES$r
に強く結付けるような仕方で利用者に提示するべきである。
◎
User agents should present the database feature to the user in a way that associates them strongly with HTTP session cookies. [COOKIES]
</p>

<p>
これは、利用者が そのような蓄積を~~健全な疑いで見ることを促すであろう。
◎
This might encourage users to view such storage with healthy suspicion.
</p>
	</dd>

	<dt>
~dbへ~accessできる~siteを個別に~safe-listに入れる
◎
Site-specific safe-listing of access to databases
</dt>
	<dd>
~UAは、~siteがこの仕様の特色機能を利用できるようになる前に、~dbへの~accessに対する利用者からの権限付与-を要求して~MAY。
◎
User agents may require the user to authorize access to databases before a site can use the feature.
</dd>

	<dt>
格納された~dataの生成元~追跡
◎
Origin-tracking of stored data
</dt>
	<dd>

<p>
~UAは、第三者主体 `生成元$による内容を包含している~siteが，~dataを格納させたときは、その~siteの`生成元$を記録して~MAY。
◎
User agents may record the origins of sites that contained content from third-party origins that caused data to be stored.
</p>

<p>
その上で、この情報を，永続的に蓄積されている現在の~dataを提示するために利用するならば、
利用者は，その情報を吟味した上で 永続的~蓄積からどの部分を取り除くか~~決定を下せるようになる。
~blocklist（
“この~dataを削除して，この~domainにこれ以上~dataを格納させない”
）と組合わすことで、利用者は，永続的~蓄積の利用を自身が信用する~siteのみに制約できるようになる。
◎
If this information is then used to present the view of data currently in persistent storage, it would allow the user to make informed decisions about which parts of the persistent storage to prune. Combined with a blocklist ("delete this data and prevent this domain from ever storing data again"), the user can restrict the use of persistent storage to sites that she trusts.
</p>
	</dd>

	<dt>
共有~blocklist
◎
Shared blocklists
</dt>

	<dd>
<p>
~UAは、利用者たちが，永続的~蓄積~domainの~blocklistを共有できるようにして~MAY。
◎
User agents may allow users to share their persistent storage domain blocklists.
</p>

<p>
これは、~communityが~~協同して自らの~privacyを保護できるようにする。
◎
This would allow communities to act together to protect their privacy.
</p>
	</dd>

</dl>

<p>
これらの提言は、この~APIによる，利用者を追跡するための自明な利用については防止するが、すべてを阻止できるわけではない。
単独の~domainの中では、~siteは，~sessionの間 利用者を追跡し続けて、その情報すべてを［
~siteが得た識別情報（名前, クレジットカード番号, 住所など）
］と一緒に第三者主体に渡すこともできる。
第三者主体が複数の~siteと協同して，そのような情報を得た場合、依然として~profileを作成し得る。
◎
While these suggestions prevent trivial use of this API for user tracking, they do not block it altogether. Within a single domain, a site can continue to track the user during a session, and can then pass all this information to the third party along with any identifying information (names, credit card numbers, addresses) obtained by the site. If a third party cooperates with multiple sites to obtain such information, a profile can still be created.
</p>

<p>
しかしながら，利用者~追跡は、~UAとの協同が全くなくても，ある程度まで~~可能である
— 具体的には、URL 内に~session識別子を利用して。
この技法は、差し障りない目的0でも すでに共通的に利用されているが，利用者~追跡に容易に（遡及的にすら）転用できる。
しかる後，この情報は、他~siteと共有され得る
— 訪問者の IP ~addressその他の，利用者~特有の~data（例： user-agent ~headerや環境設定）を利用して、別々の~sessionを，利用者~profileに~~整合的に~~統合するために。
◎
However, user tracking is to some extent possible even with no cooperation from the user agent whatsoever, for instance by using session identifiers in URLs, a technique already commonly used for innocuous purposes but easily repurposed for user tracking (even retroactively). This information can then be shared with other sites, using using visitors' IP addresses and other user-specific data (e.g. user-agent headers and configuration settings) to combine separate sessions into coherent user profiles.
</p>
		</section>

		<section id="cookie-resurrection">

<h3 title="Cookie resurrection">8.2. ~cookieの復活</h3>

<p>
永続的~蓄積のための~UIが、この仕様に述べた特色機能による永続的~蓄積の~dataを HTTP ~session~cookieの~dataと別々に提示する場合、利用者は，一方の~dataしか削除しない可能性が高い。
そうすると~siteは、二つの特色機能を互いの冗長~backupに利用して，利用者による~privacyを保護する試みを打破できるようにもなる。
◎
If the user interface for persistent storage presents data in the persistent storage features described in this specification separately from data in HTTP session cookies, then users are likely to delete data in one and not the other. This would allow sites to use the two features as redundant backup for each other, defeating a user’s attempts to protect his privacy.
</p>
		</section>

		<section id="sensitivity-of-data">

<h3 title="Sensitivity of data">8.3. ~dataの~sensitivity</h3>

<p>
~UAは、永続的に格納された~dataを，~sensitiveになり得るものと扱うべきである
— この仕組み内に［
メール ／ 予定表 ／ 健康診断記録
］その他の機密的~文書が格納されることは、ごく普通にあり得る。
◎
User agents should treat persistently stored data as potentially sensitive; it is quite possible for e-mails, calendar appointments, health records, or other confidential documents to be stored in this mechanism.
</p>

<p>
ゆえに、~UAは、~dataを削除するときには，下層の蓄積からも即座に削除されることを確保するべきである。
◎
To this end, user agents should ensure that when deleting data, it is promptly deleted from the underlying storage.
</p>
		</section>
	</section>

	<section id="security" class="informative">
<h2 title="Security Considerations">9. 保安~上の考慮点</h2>

		<section id="dns-spoofing-attacks">

<h3 title="DNS spoofing attacks">9.1. DNS 偽装~攻撃</h3>

<p>
DNS 偽装~攻撃の~~可能性があるので、ある~domainに属すると主張している~hostが本当にその~domainなのかは，保証できない。
これを軽減するため、頁は SSL を利用できる。
SSL を利用している頁は、［［
それらを識別する同じ~domainからの証明書を持つような SSL
］を利用している頁のみが，その~domainの~dbに~accessできる
］ようになることを確保できる。
◎
Because of the potential for DNS spoofing attacks, one cannot guarantee that a host claiming to be in a certain domain really is from that domain. To mitigate this, pages can use SSL. Pages using SSL can be sure that only pages using SSL that have certificates identifying them as being from the same domain can access their databases.
</p>
		</section>
		<section id="cross-directory-attacks">

<h3 title="Cross-directory attacks">9.2. ~cross-directory攻撃</h3>

<p>
同じ~host名
— 例えば `geocities.com^c —
を共有している作者たちは、同じ~dbの集合を共有する。
◎
Different authors sharing one host name, for example users hosting content on geocities.com, all share one set of databases.
</p>

<p>
~accessを URL ~pathに基いて制約する特色機能は無い。
したがって、共有~host上の作者には、これらの特色機能を利用しないことが推奨される
— 他の作者が，その~dataを読取したり上書きできるのは自明なので。
◎
There is no feature to restrict the access by pathname. Authors on shared hosts are therefore recommended to avoid using these features, as it would be trivial for other authors to read the data and overwrite it.
</p>

<p class="note">注記：
~pathによる制約の特色機能が可用にされたとしても、通例の DOM ~scriptにおける保安~modelの下では，この保護を迂回して任意の~pathから~dataへ~accessすることは自明になる。
◎
Even if a path-restriction feature was made available, the usual DOM scripting security model would make it trivial to bypass this protection and access the data from any path.
</p>
		</section>
		<section id="implementation-risks">
<h3 title="Implementation risks">9.3. 実装にあたっての~risk</h3>

<p>
これらの永続的~蓄積のための特色機能を実装するにあたって，主に二つの~risk
— 敵対的~siteが［
他の~domainから情報を読取する ／
情報を書込して他の~domainに読取させる
］こと —
がある：
◎
The two primary risks when implementing these persistent storage features are letting hostile sites read information from other domains, and letting hostile sites write information that is then read from other domains.
</p>

<p>
第三者主体~siteが，その~domainから読取されるものと~~想定されていないような~dataを読取できるようになれば、<em>情報~漏洩</em>になる。
例えば，ある購買~site~domainの，利用者の “欲しい物リスト” が、別の~domainにより~targeted広告に利用されたり，あるいは、文書作成~siteに格納された，利用者が作業中の機密的~文書を，競合企業~siteが覗き見ることも可能になる。
◎
Letting third-party sites read data that is not supposed to be read from their domain causes information leakage, For example, a user’s shopping wish list on one domain could be used by another domain for targeted advertising; or a user’s work-in-progress confidential documents stored by a word-processing site could be examined by the site of a competing company.
</p>

<p>
第三者主体~siteが，他の~domainの永続的~蓄積に~dataを書込できるようになれば、<em>情報~偽装</em>（なりすまし）になり，同等に危険である。
例えば，敵対的~siteは、利用者の “欲しい物リスト” に~recordを追加したり、利用者の~session識別子を既知の ID に設定して，利用者の被害者~siteにおける行動を追跡するためにそれを利用することも可能になる。
◎
Letting third-party sites write data to the persistent storage of other domains can result in information spoofing, which is equally dangerous. For example, a hostile site could add records to a user’s wish list; or a hostile site could set a user’s session identifier to a known ID that the hostile site can then use to track the user’s actions on the victim site.
</p>

<p>
したがって、この仕様に述べられる生成元~modelに厳格に従うことは、利用者の保安にとって重要である。
◎
Thus, strictly following the origin model described in this specification is important for user security.
</p>
		</section>
	</section>
	<section id="revision-history">

<h2 title="Revision History">10. 改訂~履歴</h2>

<p>
以下は、この仕様の最後の発行からの変更点の要約（参考）である。
<a href="https://github.com/w3c/IndexedDB/">完全な改訂~履歴</a> ／
<a href="https://www.w3.org/TR/IndexedDB/#revision-history">第１版の改訂~履歴</a>
◎
The following is an informative summary of the changes since the last publication of this specification. A complete revision history can be found here. For the revision history of the first edition, see that document’s Revision History.
</p>

<ul>
	<li>
空~配列の比較に取り組んだ。
`27712$bug
◎
Address comparison of empty arrays. (bug #27712)
</li>
	<li>
`IDBObjectStore!I に `openKeyCursor()$m を追加した。
`19955$bug
◎
Added openKeyCursor() on IDBObjectStore. (bug #19955)
</li>
	<li>
`IDBIndex!I の［
`get()$m, `getKey()$m, `openKeyCursor()$m
］の演算に用いられていた %source を正しいものに。
◎
Correct source used for get(), getKey() and openKeyCursor() on IDBIndex.
</li>
	<li>
`IDBDatabase$I ~objの~garbage収集に関わる詳細を追加した。
`25223$bug
◎
Added details around garbage collection of IDBDatabase objects. (bug #25223)
</li>
	<li>
各~interfaceに
[Exposed=(Window,Worker)]
注釈を追加した。
◎
Added [Exposed=(Window,Worker)] annotations to interfaces.
</li>
	<li>
`~db接続を~close$する手続きに，
`close$et ~eventの発火-について述べる %強制~flag を追加し、それに伴い
`IDBDatabase!I に `onclose$m を追加した。
`22540$bug
◎
Added forced flag to the steps for closing a database connection, described the firing of a "close" event, and onclose. (bug #22540)
</li>
	<li>
仕様をより~algo的な~styleに変換した。
`~key$などの抽象~型をより~~厳密に定義した。
`17681$bug
◎
Converted specification to a more algorithmic style, and define abstract types such as key more rigorously. (bug #17681)
</li>
	<li>
`IDBObjectStore!I に
`getAll()$m, `getAllKeys()$m
~methodを追加した。
`IDBIndex!I に
`getAll()$m, `getAllKeys()$m
~methodを追加した。
`16595$bug
◎
Added getAll() and getAllKeys() on IDBObjectStore, and getAll() and getAllKeys() on IDBIndex. (bug #16595)
</li>
	<li>
`DOMError^I を `DOMException$I に置換した。
`16$bug2
◎
Replaced DOMError with DOMException. (bug #16)
</li>
	<li>
`IDBTransaction!I に `objectStoreNames$m 属性を追加した。
`18$bug2
◎
Added objectStoreNames on IDBTransaction. (bug #18)
</li>
	<li>
`binary$i `~key$を追加し，その比較, および
ECMAScript 言語束縛にも追加した。
`21$bug2
◎
Added binary keys, including comparisons and ECMAScript bindings. (bug #21)
</li>
	<li>
`保管庫$／`索引$
に対する名前の変更を
`IDBObjectStore!I の`name$m ／ `IDBIndex!I の `name$m
設定子を介して許容されるようにした。
`22$bug2
◎
Allow renaming stores and indexes via IDBObjectStore’s name and IDBIndex’s name attribute setters. (bug #22)
</li>
	<li>
`IDBCursor!I に `continuePrimaryKey()$m を追加した。
`22$bug2
◎
Added continuePrimaryKey() on IDBCursor. (bug #14)
</li>
	<li>
`IDBKeyRange!I に `includes()$m を追加した。
`41$bug2
◎
Added includes() on IDBKeyRange. (bug #41)
</li>
	<li>
`IDBObjectStore!I に `getKey()$m を追加した。
`26$bug2
◎
Added getKey() on IDBObjectStore. (bug #26)
</li>
	<li>
~txがいつ~commitを~~試みれるか明確化した。
`77$bug2
◎
Clarified when a transaction can attempt to commit. (bug #77)
</li>
	<li>
`~open要請$ ／ `接続~待行列$
の処理を明確化した。
`9$bug2,
`78$bug2,
`79$bug2,
`81$bug2,
◎
Clarified open request / connection queue processing. (bug #9, bug #78, bug #79, bug #81)
</li>
	<li>
`DOMStringList$I を追加した。
`28$bug2
◎
Added DOMStringList. (bug #28)
</li>
</ul>

	</section>
	<section id="acknowledgements">

<h2 title="Acknowledgements">11. 謝辞</h2>


<p>
この仕様の第１版の元々の作者である Nikunj Mehta 氏に特に感謝する。
次の方々，並びに第１版の他の編集者たちにも。
</p>

<div >
Special thanks to Nikunj Mehta, the original author of the first edition, and Jonas Sicking, Eliot Graff, Andrei Popescu, and Jeremy Orlow, additional editors of the first edition.
</div>

<p>
この仕様の設計に強い影響力を及ぼした Garret Swart 氏に。
◎
Garret Swart was extremely influential in the design of this specification.
</p>

<p>
この文書の作成-時に利用した 仕様~著作tool Bikeshed を作成-／維持管理されている Tab Atkins, Jr. 氏に。
◎
Thanks to Tab Atkins, Jr. for creating and maintaining Bikeshed, the specification authoring tool used to create this document.
</p>

<p>
~feedbackと提言を寄せられ，この仕様を向上させた，次の方々に特別な謝意を：
</p>

<p>
Special thanks to

Chris Anderson,
Pablo Castro,
Victor Costan,
Kristof Degrave,
Jake Drew,
Ben Dilts,
João Eiras,
Alec Flett,
Dana Florescu,
David Grogan,
Israel Hilerio,
Kyle Huey,
Laxminarayan G Kamath A,
Anne van Kesteren,
Adam Klein,
Tobie Langel,
Kang-Hao Lu,
Andrea Marchesini,
Glenn Maynard,
Ms2ger,
Odin Omdal,
Danillo Paiva,
Olli Pettay,
Simon Pieters,
Anthony Ramine,
Yonathan Randolph,
Arun Ranganathan,
Margo Seltzer,
Maciej Stachowiak,
Bevis Tseng,
Ben Turner,
Kyaw Tun,
Hans Wennborg,
Shawn Wilsher,
Brett Zamir,
Boris Zbarsky,
Zhiqiang Zhang, and
Kris Zyp,

all of whose feedback and suggestions have led to improvements to this specification.
</p>

	</section>


</main></div>

	<section id="conformance">

<h2 title="Conformance">適合性</h2>

<p class="trans-note">【
この他の内容は
<a href="w3c-common-ja.html#conformance" >W3C 日本語訳 共通ページ</a>
に委譲
】</p>


	</section>
	<section id="references">

<h2 title="References">参照文献</h2>

		<section id="normative-references">
<h3 title="Normative references">文献（規範）</h3>


<dl>
	<dt>[DOM]</dt>
	<dd>Anne van Kesteren. DOM Standard. Living Standard.</dd>
	<dd>https://dom.spec.whatwg.org/</dd>

	<dt>[ECMA-262]</dt>
	<dd>ECMAScript Language Specification.</dd>
	<dd>https://tc39.github.io/ecma262/</dd>

	<dt>[FileAPI]</dt>
	<dd>Arun Ranganathan; Jonas Sicking. File API.</dd>
	<dd>https://w3c.github.io/FileAPI/</dd>

	<dt>[HTML]</dt>
	<dd>Ian Hickson. HTML Standard. Living Standard.</dd>
	<dd>https://html.spec.whatwg.org/multipage/</dd>

<!-- 
	<dt>[RFC2119]</dt>
 -->

	<dt>[WEBIDL]</dt>
	<dd>Cameron McCormack; Boris Zbarsky; Tobie Langel. WebIDL.</dd>
	<dd>https://heycam.github.io/webidl/</dd>
</dl>

		</section>
		<section id="informative-references">
<h3 title="Informative references">文献（参考）</h3>

<dl>

	<dt>[COOKIES]</dt>
	<dd>A. Barth. HTTP State Management Mechanism. April 2011. Proposed Standard.</dd>
	<dd>https://tools.ietf.org/html/rfc6265</dd>

	<dt>[DOM-Level-3-core]</dt>
	<dd>Arnaud Le Hors; et al. Document Object Model (DOM) Level 3 Core Specification. 7 April 2004. REC.</dd>
	<dd>https://www.w3.org/TR/DOM-Level-3-Core/</dd>

	<dt>[WEBSTORAGE]</dt>
	<dd>Ian Hickson. Web Storage (Second Edition).</dd>
	<dd>https://w3c.github.io/webstorage/</dd>
</dl>


		</section>
	</section>

	<section id="idl-index">
<h2 title="IDL Index" data-cycling="pre.idl">IDL 索引</h2>
<p class="trans-note">【
この節の内容は省略（見出しクリックで巡回）。
】</p>
	</section>
